<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>RFC 6455 - The WebSocket Protocol （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="RFC-common.css" type="text/css" />

<style type="text/css">
span[lang="en"] {
	white-space: pre-line;
}

.hex-value {
	font-family: sans-serif0, sans-serif;
}

/* status code */
.status {
	color: green;
}

/* reason phrase */
.phrase {
	color: gray;
}

#framing-table {
	border-collapse: separate;
	border-spacing: 1px 1px;
	margin:1em 2em;
}
#framing-table td, #framing-table th {
	border: solid black 1px;
	min-width:1em;
	text-align:center;
}
#framing-table th {
	border: none;
	text-align:left;
	padding:0;
}
#framing-table td {
	padding:0;
	background: #EEE;
}
#framing-table a {
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	var source_data = {
		toc_main: 'MAIN0',
		generate: expand,
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked:
}

function expand(){

	var class_map = {
		P: 'production',
		X: 'hex-value',
		st: 'status',
		h: 'header',
		hm: 'method',
		ph: 'phrase',
		cme: 'comment',
		sc: 'scheme',
	};

	var tag_map = {
		h: 'code',
		hm: 'code',
		P: 'code',
		sc: 'code',
		st: 'code',
		s: 'samp',
		ph: 'span',
		X: 'span',
		cme: 'span',
		c: 'code',
		i: 'i',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#ref-' + key;//.toLowerCase();
	break;
case 'l': // octet literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'h':
	href = '#h.' + key;
	break;
case 'P':
	href = '#p.' + key;
	break;
case 'ch':
	return(
'<span class="hex-value">%x'
+ (key.charCodeAt(0)).toString(16).toUpperCase() + '</span>'
+ '（ "<code class="literal">' + key + '</code>" ）'
	);
	break;
case 'sec':
	var m1 = key.match(/^(\d+)-([\d\.]+)$/);
	if(m1){
		text = 'RFC' + m1[1] + ', ' + m1[2] + ' 節';
		href = '~IETF/rfc' + m1[1] + '#section-' + m1[2];
	} else {
		text = ' ' + key + ' 節'
		href = '#section-' + key;
	}

	break;
case 'X': // hex value
	text = '0x' + text;
	break;
case 'errata': 
	text = '正誤表';
	href = 'http://www.rfc-editor.org/errata_search.php?rfc=6455&eid=' + key;
	break;
case 'smb': //＊
	text = '(<span class="char-symbol">' + text + '</span>)'
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options
trans_update:2019-01-21
original_url:http://tools.ietf.org/html/rfc6455
spec_status:IETFPR
no_original_dfn:true
main:MAIN
toc:toc
ref_id_prefix:ref-
site_nav:network,security
trans_1st_pub:2012-04-06

●●original_id_map

references:section-14


●●link_map

	ASCII#dfn-ascii
	~ASCII小文字~化:#dfn-to-lowercase
~ASCII大小無視:#dfn-case-insensitive

~WebSocket~closing~handshakeを開始する:#dfn-to-start-closing-handshake
~WebSocket~closing~handshakeは開始された:#dfn-closing-handshake-started
~WebSocket接続を確立する:#dfn-to-establish
~WebSocket接続を中止する:#dfn-abort
~WebSocket~messageが受信された:#dfn-received
~WebSocket~messageを送信する:#dfn-to-send
~dataを送信する:#dfn-to-send
~WebSocket接続は~close済み:#dfn-closed
~cleanに:#dfn-closed-cleanly
~WebSocket接続は確立されて:#dfn-established
~WebSocket接続を~close:#dfn-to-close
~WebSocket接続を失敗させ:#dfn-to-fail
~close~code:#dfn-close-code
~close事由:#dfn-close-reason
~serverの~opening~handshakeの間に設定される~cookie:#dfn-cookie-during-handshake
	設定する:#dfn-cookie-during-handshake

利用中の拡張:#dfn-extensions-in-use
利用中の下位protocol:#dfn-subprotocol-in-use

~OPEN状態:#dfn-OPEN-state
~CLOSING状態:#dfn-CLOSING-state
~CLOSED状態:#dfn-CLOSED-state
~CONNECTING状態:#dfn-CONNECTING-state

~hashを構築-:#generate-an-accept-nonce
~base64に符号化-:~IETF/rfc4648#section-4
~ABNF拡張:~RFC7230#section-7
	~ABNF変種

~status~code:#status-code

P.start-line:~RFC7230#section-3.1
P.request-line:~RFC7230#section-3.1.1
P.status-line:~RFC7230#section-3.1.2
P.token:~RFC7230#section-3.2.6
P.request-target:~RFC7230#section-5.3
P.quoted-string:~RFC7230#section-3.2.6
P.path-abempty:~IETF/rfc3986#section-3.3
P.authority:~IETF/rfc3986#section-3.2


h.Upgrade:~RFC7230#section-6.7
~Upgrade:~RFC7230#section-6.7
h.Host:~RFC7230#section-5.4
h.Connection:~RFC7230#section-6.1
h.Authorization:~RFC7235#section-4.2
h.WWW-Authenticate:~RFC7235#section-4.1
h.Cookie:~RFC6265#section-4.2
h.Origin:
	h.Origin:~FETCH#http-origin

hm.GET:~RFC7231#section-4.3.1

st.101:~RFC7231#section-6.2.2
st.3xx:~RFC7231#section-6.4
st.400:~RFC7231#section-6.5.1
st.401:~RFC7235#section-3.1
st.403:~RFC7231#section-6.5.3
st.404:~RFC7231#section-6.5.4
st.426:~RFC7231#section-6.5.15

st.1000:#status-1000
st.1001:#status-1001
st.1002:#status-1002
st.1003:#status-1003
st.1004:#status-1004
st.1005:#status-1005
st.1006:#status-1006
st.1007:#status-1007
st.1008:#status-1008
st.1009:#status-1009
st.1010:#status-1010
st.1011:#status-1011
st.1015:#status-1015

応答~code:#response-code
~HTTP~status~code:~RFC7231#section-6
	P.status-code:~RFC7230#section-3.1.2

	種別:#frame-type
制御~frame:#section-5.5
~data~frame:#section-5.6
	非~制御~frame:#section-5.6
fr.Close:#section-5.5.1
fr.Ping:#section-5.5.2
fr.Pong:#section-5.5.3
fr.Text:#data-Text
fr.Continuation:#data-Continuation
fr.Binary:#data-Binary


~FIN:#data-FIN
予約-済み~bit:#data-RSV
~opcode:#data-opcode
~mask:#data-MASK
~payload長さ:#data-payload-length
~mask用~key:#data-Masking-key
~payload~data:#data-Payload
拡張~data:#data-Extension
~app~data:#data-Application

~proxyの用法:#dfn-proxy-usage

RFC 6455:~IETF/rfc6455


	:#subprotocol-req
	:#validate-server-response
	:#framing-table
	~ASCII:#dfn-ascii



●●words_table1
RFC7235:RFC7235-ja.html
RFC6265:RFC6265-ja.html

MUST:なければ<em class="rfc2119">ならない</em>
MUST_NOT:<em class="rfc2119">ならない</em>
REQUIRED:<em class="rfc2119">要求される</em>
SHOULD:<em class="rfc2119">べき</em>
	RECOMMENDED:<em class="rfc2119">推奨される</em>
MAY:<em class="rfc2119">よい</em>

●●words_table


	●network
DNS:
HTTP:
SMTP:
HTTPS:
URL:
URI:
IRI:
RST:
IDN:
IP:
Protocol:
SOCKS5:
TCP:
TLS:
UI:
Upgrade:
	UPGRADE:Upgrade

network::::ネットワーク
上流:upstream:~
帯域内:in-band:~
層:layer::~
積層-:layer::~
透過型:intercepting::~
双路:two-way::~
双方向:bidirectional::~
単方向:unidirectional:~
方向:direction:~
多重化:multiplexing::~
負荷:load::~
負荷分散装置:load balancer::~
負荷委譲-:offload::~

site::::サイト
非同一生成元:cross-origin::~::クロスオリジン
生成元:origin::~::オリジン
address::::アドレス
	~address法:addressing
端点:endpoint::~::エンドポイント
peer:
	端点:peer
end-to-end::::エンドツーエンド
local::::ローカル
remote::::リモート
主体:party:~
proxy::::プロキシ
client::::クライアント
	~client側:client-side
serve::::サービス供与:
server::::サーバ
	~server側:server-side
service::::サービス

listen::::リッスン
session::::セッション
polling::::ポーリング

handshake::::ハンドシェイク
method::::メソッド
scheme::::スキーム
protocol::::プロトコル
下位protocol:subprotocol::下位 protocol:下位プロトコル
header::::ヘッダ
	~header~field:header field
	~header:header field
packet::::パケット
tunnel::::トンネル
socket::::ソケット
cache::::キャッシュ
cookie:::::クッキー
channel::::チャンネル
transport::::トランスポート

punycode::::ピュニコード
domain::::ドメイン
host::::ホスト
port::::ポート
path::::パス
絶対:absolute::~
相対:relative::~
password::::パスワード
payload::::ペイロード

提出-:submit::~
提出:submission::~
接続待ち:pending connections:~
redirect::::リダイレクト
追従-:follow:~
追跡-:track:~
	~~記録:track
	セグメント寿命:segment lifetimes
着信:incoming::~
発信:outgoing::~
伝送-:transmit::~
伝送:transmission::~
転送:transfer::~
伝送路:wire::~
流通:traffic::~::トラフィック
通信:communication::~
通信-:communicate::~
中継点:intermediary::~
折衝-:negotiate::~::ネゴシエート
	折衝-法:negotiating
折衝:negotiation::~::ネゴシエーション
接続:connection::~
接続-:connect::~
再接続:reconnect::~
持続的:persistent:~
確立-:establish::~
確立:establishing::~
受容-:accept::~
	受容-可能:acceptable
	受容-可能でない:unacceptable
受容:acceptance:~
中止-:abort::~
正常:normal::~
異常:abnormal::~

応答:response::~::レスポンス
応答-:respond::~::レスポンド
	応答-可能:responsive
要請:request::~::リクエスト
送信-:send::~
送信:sending::~
返送-:send back::~
送信側:sender::~
受信-:receive::~
受信:receiving::~
	送受信:sending／receiving
受信先:recipient::~
受信側:receiver::~
返信:reply::~
送達-:deliver:~
接触-:contact:~
切断-:disconnect:~
接続維持:keepalive:~
環境設定-:configure:~

body::::ボディ

鼓動:heartbeat:~
resource::::リソース
	~resource名:resource-name
	資源
種別:type::~
code::::コード
	側:party
	~~主体:entity
行先:destination:~

	●WebScoket
WebSocket:
OPEN:
CLOSING:
CLOSED:
CONNECTING::::
Chat:
FIN::::
Close:
bit::::
	最上位~bit:most significant bit
buffer::::バッファ
caching::::
clean::::
opcode::::
bit::::ビット
mask::::マスク
	~mask法:masking
	~mask~~処理:masking
	~mask用~key:masking key
	~maskを解く:unmask
	~maskされていない:unmasked
key::::キー
	 0 に:clear
	 1 に:set

message::::メッセージ
messaging::::メッセージング
frame::::フレーム
	~frame法:~framing

制御:control::~
制御-:control::~
opening::::
open::::
	再~open:reopen
close::::
closing::::
closure::::
ping::::
pong::::
text::::テキスト
	~textの:textual
binary::::バイナリ
data::::データ
継続:continuation::~
継続-:continue::~
合併-:coalesce:~
分割-:split:~
再構築:reassembly::~
交互挿入:interleave::~
境界:boundary:~
断片:fragment::~
断片化:fragmentation::~
断片化状態:fragmentation::~
断片化-:fragment 化::~
	fragment 化された:fragmented 
	fragment 化されていない:unfragmented


version::::バージョン
	~version付け:versioning
状態:state::~
status:::状態°::ステータス
事由:reason::~
hash::::ハッシュ


	●構文
ABNF:
ASCII::::
GUID::::
	Globally Unique Identifier
escape::::エスケープ
	escape復元後:unescaping 後
percent::::パーセント
octet::::オクテット
list::::リスト
byte::::バイト
token::::トークン
flag::::フラグ
Unicode:
UTF-8::::
base64::::
SHA-1::::
nonce::::
false::::
true::::
error::::エラー

文字:character::~
構文:syntax::~
構成子:construct::~
要素:element::~
規則:rule::~
生成規則:production::~
形式:format::~
形:form::~
形成-:form::~
	形成-済み:formed
共通名:common name::~
正規化:normalization::~
終端値:terminal value::~
文字集合:character set::~
大小無視:case-insensitive::~
番号:number::~
符号化-:encode::~::エンコード
符号化:encoded::~::エンコード
符号化方式:encoding::~::エンコーディング
	符号化~data:encoded data
文字符号化:character-encoding::~
符号化形:encoded form::~
復号-:decode::~::デコード
直列化-:serialize::~::シリアル化
直列化:serialization::~::シリアル化
構文解析-:parse::~::パース
	構文解析-法:parsing
妥当:valid:~
	妥当でない:invalid
検証-:verify:~
妥当性:validity:~
	妥当性を~~検証:validate:~
	0:zero
入力:input:~
整数:integer:~
識別-:identify:~
素片:fragment::~::フラグメント
識別子:identifier::~
合致-:match::~
空:empty::~
成分:component::~
長さ:length::~
文字列:string:~
空:empty:~
名:name:~
名前:name:~
命名:naming:~
命名-:name:~
空白:whitespace:~
終端:terminal:~
終端記号:terminals:~
小文字:lowercase:~
	小文字~化:lowercased
	区切り文字:separator character
接尾辞:suffix:~
	大小は無視される:case-insensitive:~
符号位置:code point:~
文法:grammar:~
非負:non-negative:~
無符号:unsigned:~
	不一致:conflict

	●保安
security::::セキュリティ
secure::::セキュア
policy::::ポリシー
証明書:certificate::~
完全性:integrity::~
悪意的な:malicious:悪意のある::~
機密性:confidentiality::~
暗号:cipher:~
暗号化-:encrypt::~
	暗号化されてない:unencrypted
暗号論的:cryptographic:~
解読可能:decipherable:~
情報量:entropy:~
平均情報量:entropy:~
乱数生成器:random number generator:~
予測-:predict:~
	予測-可能:predictable
	予測-不能:unpredictable
	予測-不能性:unpredictability
DoS:denial-of-service:DoS
攻撃:attack::~
攻撃者:attacker::~
認証:authentication::~
認証-:authenticate::~
特権:privilege:~
権限:authority:~
敏感:sensitive:~
露出-:expose:~
衝突:collision:~
耐性:resistance:~
第二原像攻撃:second pre-image attack:~
細工-:craft:~
信用-:trust:~
	信用できない:untrusted
random::::ランダム
依拠-:rely:~
	依拠-可能な:reliable
信頼性:reliability:~
脆弱:vulnerable:~
防御策:defense adopted:~
巧妙:careful:~
誤誘導-:mislead:~
	危うく:compromising
感染源:susceptible:~
安全:safe::~
安全性:safety::~
汚染:poisoning:~
	記憶域の枯渇:exhaust memory:~
強度:strength:~
脅威:threat:~
	偽装:fake:~
偽造-:forge:~
注入:injection::~::インジェクション
保護-:protect::~
保護:protection::~


	●仕様
RFC:
API:
HTML:
IANA:
	IETF
	RFC
Web::::

agent::::エージェント
level::::レベル
overhead::::オーバーヘッド
interface::::インタフェース
software::::ソフトウェア
component::::コンポーネント
algo::::アルゴリズム
support::::サポート
	未~support:unsupported
option::::オプション
opt-in::::オプトイン
任意選択:optional:~
feedback::::フィードバック
community::::コミュニティ
trade-off::::トレードオフ
library::::ライブラリ
framework::::フレームワーク
platform::::プラットフォーム
model::::モデル
style:::スタイル
markup:::マークアップ
	アイデア
	メモ
	段:step
	手続き:steps／procedure
仕組み:mechanism::~
通信基盤:infrastructure::~
安定的:stable::~
意味論:semantics::~
	semantic meaning
特色機能:feature::~
正誤表:errata::~
連絡先:contact::~
既定:default::~
可用:available::~
正誤表:errata:~
一般:general:~
一般的:general:~
代表的:typical:~
典型的:typical:~
概して:typical に:~
概観:overview:~
概念:concept:~
概念的:conceptual:~
恩恵:benefit:~
通常の:normal な:~
定例の:regular な:~
通例的:usual:~
過度の:unusual:~
解決策:solution:~
環境:environment:~
関連情報:relate information:~
判定基準:criteria:~
基底部:base:~
基底:base:~
基本的:basic:~
機器:device:~
能力:capability:~
	できる:capable
帰結:consequence:~
規約:convention:~
表記規約:convension:~
技術:technology:~
技法:technique:~
共通的な:common な:よくある:~
共通して:common に:~:~
形式的:formal:~
権利:rights:~
原則:principle:~
互換:compatible:~
	互換でない:incompatible
後方互換:backward compatible:~
	後方互換でない:backward-incompatible:~
厳格:strict:~
実質的:effective:~
	~~有効:effect
効率性:efficiency:~
恒久的:permanent:~
合法:legal:~
困難:difficult:~
仕組み:mechanism:~
方式:manner:~
仕様:spec:~
	仕様~文書:Specification document(s):~
手引き:guidance:~
私的:private:~
事例:case:~
	場合:case
自動設定:autoconfiguration:~
自由:free:~
実際:actual:~
実際の:actual な:~
実用的:practical:~
有意:significant:~
将来:future:~
詳細:details:~
情報:information:~
	詳細:further information
	片:pieces of
条件:condition:~
状況:situation:~
図式:diagram:~
正確:exact:~
正しく:correct に:~
不正:incorrect:~
不正形の:malformed な:不正な形の
網羅的:exhaustive:~
本質的:essential:~
無保証:without warranty:~
明示的:explicit:~
目的:purpose:~
目標:goal:~
問題:problem:~
用語:term:~
各種用語:terminology:~
利点:benefit:~
可用:available:~
歴史的:historical:~
論法:logic:~
論理:logic:~
論理的:logical:~
局面:scenario:~
不断に:tireless に:~
標準:standard:~
標準的:standard:~
考査:review:~
不適正:improper:~
複雑さ:complexity:~
精巧:elaborate:~
設計:design:~
設計理念:design philosophy:~
草案:draft:~
代替:alternative:~
注意深く:careful に:~
適切:appropriate:~
相応しい:suitable な:~
適度:reasonable:~
	reasonably
資質:nature:~
特色機能:feature:~
独立:independent:~
独立の:independent な:~
	読み易く:readability:~
背景調査:background research:~
発行:publication:~
発展:expansion:~
汎用:generic:~
汎用の:generic な:~
改訂:revision::~
単純:simple:~
	単純~化:simplify
	単純に:simply
文書:document:~
	文書~化:documented
mailing-list:mailing list:::メーリングリスト
潜在的:potential:~
規範的:normative:~
	~~規範になるもの:prescriptive
公共の:public な:公の
比較的:relative に:~
仕方:way:~
手段:means:~
	注記:note
	通じている:aware of
	リンク
	ごく普通に:quite likely
	浪費:-hogging
	一般的な手口:general form
	解散:close
	命令的言い回し:phrased in the imperative
	優先される:authoritative
	舞台裏:behind the scene
	必須の:Mandatory
	規定:prescribe
	則って／則り:in accordance with
	手短か:In short,
	足らない:sufficient
	要約:Abstract
	どこでも:readily
	良好な:good
	判断材料:part of a determination
	伴われる:imply
	担当する:responsible
	当然:Naturally
	統制:control
	同一視:considered to match
	覆す:break する
	とは限らない:necessarily
	不必要:unnecessarily
	必要性:necessarily
	必要とされ:necessary
	とする必要:necessarily
	必要／要する:need
	適時:timely manner
	とりわけ:especially
	~~意向:at will
	つもりがある:willing
	位置付け:Status
	不可能:not possible
	不可
	可能
	可能性:potential
	関わらず:regardless／
	にも関わらず:despite of
	帰着:all the way
	区別:distinction
	確定-:establish
	語句:term
	厳密な:exactly
	誤った:wrong
	真似:similar to
	人々:people
	図:figure
	整合:consistent
	きちんと:orderly
	ちょうど:really
	理由:reason:because
	分類-:-
	用途:-
	用法:usage
	後継仕様:replacement
	則って／則り:accordance:according
	導く:lead
	念頭: 1
	ゆえに:Ergo
	強:strong
	人から読める:human readable
	対照的に:as opposed to
	例:example
	〜に基づく:-base:-based 

	●仕様（動詞
app:application:::アプリ
registry::::レジストリ
応用:application:~
適用-:apply:~
	適用-可能:applicable:~
利用者:user::~
有用:useful:~
利用事例:use-case::~
	併用:used with:~
	採用:uses
	利用
	利用中:
	利用法:usage

予約-:reserve::~
	予約-済み:reserved
濫用:abuse:~
拡張-:extend:~
	拡張-可能:extensible:~
拡張:extension::~
拡張性:extensibility:~
違反-:violate:~
違反:violation:~
処理能:performance:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
暗黙の:implied:~
依拠-:rely:~
依存-:depend:~
意図:intent:~
意図-:intend:~
	想定／企図:intend:~
	意味:meaning:~
	意味を成す:make sense
	無意味
保守-:maintain:~
波及:influence:~
運用:operation:~
相互運用-:interoperate:~
相互運用性:interoperability:~
避ける:avoid する:~
避けれ:avoid でき:~
開発-:develop:~
開発者:developer:~
	確かめられる:be sure:~
	そのためには:accomplish
充足-:fulfill:~:~
課す:impose:~
解釈-:interpret:~
誤解釈:misinterpret:~
解釈:interpretation:~
確保-:ensure:~:~
関係性:relationship:~
関係-:relate:~
関与:participation:~
許容-:allow:~
競う:compete する:~
	competing
共存:coexist:~
議論:discussions:~
経験:experience:~
決定-:decide:~
決定:determine:~

前提:assumption:~
見做さ:assume さ:~
見做す:assume する:~
見做した:assume した:~
見なさ:consider さ:~
見なす:consider する:~
見なして:consider して:~
考慮-:consider:~
考慮点:considerations:~
同意-:agree:~
	agree:一致
合意:consensus:~
告知-:advertise:~
告知:advertisement:~
国際化:Internationalized:~
査読:review:~
再発明:reinventing:~
再利用:reuse:~
採択:elect:~
作者:author:~
作者定義:author-defined:~
仕事:work:~
働く:work する:~
使役-:employ:~
指示-:indicate:~
指示:indication:~
指図-:instruct:~
指名され:designate され:指定され
指名域:designated locations:指定域
指定-:specify:~
特定の:specific な:~
特有の:specific な:~
	-:specifical
	特に:specifically
	具体的:concretely
寄与:contribution:~
推奨-:recommend:~
推進:move:~
制限:limit:~
制約-:restrict:~
拘束:constraints:~
制約条項:restriction:~
移行-:proceed:~
編集者:editor:~
編集上:editorial:~
	編集-:edit
防止-:prevent:~
未知の:unknown:~
定義-:define:~
	定義されない:undefined
定義:definition:~
定義済みの:predefined:~
明確化:clarifications:~
誘引-:induce:~
期待-:expect:~
	期待されていない:no expectation
予期-:expect:~
期待:expectation:~
予期:expectation:~
	予期しない:unexpected
	予期せず:unexpectedly
立証-:prove:~
要求-:require:~
要件:requirements:~
抑制-:reduce:~
軽減-:reduce:~

試験-:test:~
試行-:try:~
試み:attempt:~
試みて:attempt して:~
試みら:attempt さ:~
試みる:attempt する:~

	仕掛け:try:~
混同-:confuse:~
実行-:execute:~
稼働-:run:~
走らす:run する:~
走らせ:run し:~
走って:run して:~
実装-:implement:~
実装:implementation:~
実装者:implementor:~
奨励-:encourage:~
承認-:endorse:~
診断:diagnosing:~
供-:provide:~
供せ:provide でき:~
供さな:provide しな:~
給-:supply:~
公開-:expose:~
設けら:set out さ:~
	~~設けられ:made:~
示唆-:suggest:~
適合-:conform:~
	適合しない:nonconformant
適合性:conformance:~
予見-:believe:~
是認-:grant:~
導出-:derive:~
導入-:introduce:~
補完:complement:~
保証:guarantee:~
緩めら:relax さ:~
達成-:achieve:~
望む:wish する:~
望まな:wish しな:~
欲され:desire され:~
記述:description:~
記述-:describe:~
述べる:describe する:~
述べた:describe した:~
述べら:describe さ:~
論じる:discuss する:~
論じた:discuss した:~
論じら:discuss さ:~
登録-:register::~
登録:registration::~
登録済みの:registered::~
registry::::レジストリ
占有-:monopolize:~
影響-:affect:~
判断-:deem:~
解-:understand:~
依頼-:ask:~
遂行-:perform:~
管理-:manage:~
管理:management:~
作成変更管理:Author/Change controller:作成／変更管理
	~~影響:impact
	選好-:prefer
	選好:preference
	選好順:would like to speak／wishes to speak／ordered by preference ／ preference of 〜 wishes to use
	準じ:compliant
	〜に相当する高負荷に晒され:experience what amounts to〜
	申し出／申し出る:offer
	進める:proceed:~
	公示-:post:~
	適化:better:~
	一致を見ない:not agree
	事前の取り決め:prior agreement:~
	失われた:lost:~
	暫定:Interim:~
	実証する実験が実施:an experiment was conducted to demonstrate:~
	支援:help:~
	助ける／易くする
	気付かずに:convinced:~
	役務:serve:~
	用をなす:serve
	機能する:serve
	機能:function:~
	予想される:anticipate:~
	落とす:drop :~
	取り組む:attempt to address
	生じる:arise:~
	強いられる:forced:~
	含む
	有さない:missing:lack
	結び付け:associate:~
	見込まれている:intended:~
	考案者:originator:~
	とされる:is said that
	成立-:hold true

	●未分類（動詞
navigate::::ナビゲート
encapsulate::::カプセル化
確認-:confirm:~
圧縮-:compress:~
圧縮:compression:~
選択-:select:~
選定-:select:~
喪失:loss:~
隠す:hide する:~
運ぶ:carry する:~
延長:extended:~
停止-:stop:~
一時停止-:pause:~
解決-:resolve:~
起動-:initiate:~
完遂-:finish:~
完了-:complete:~
完了:completion:~
完全:complete:~
	完全でない:incomplete
検査:check:~
検出-:detect:~
発見-:discover:~
見出した:find した:~
拒める:refuse できる:~
却下-:reject:~
共有-:share:~
交換:exchange:~
	広げる:extend:~
更新:update:~
拘束:tied:~
構築-:construct:~
広告:advertise:~
作成-:create:~
算出-:compute:~
計算-:calculate:~
通知-:notify:~
通知:notification:~
	参照-:refer ／cf. ／see ／ reference
写像:mapping:~
	得る:obtain
除外-:exclude:~
除去-:remove:~
出現-:appear:~
受領:receipt:~
準備-:prepare:~
消去っ:go away し:消え去っ
信号:signal:~
	信号を送る
	信号:signaling
成功-:succeed:~
成功:succeess:~
	成功-後:successful:~
	成功~率:success rates:~
生成-:generate:~
挿入-:insert:~
挿入:interject:~
挿入(fragment):inject:~
結合-:combine:~
設定-:set:~
演算:operation:~
遭遇-:encounter:~
対応付け:mapping:~
	渡す:pass する
動作-:act:~
動作:action:~
破棄-:discard:~
設置:setups:~
配備-:deploy:~
頒布:deployed:~
	頒布／広範の／配備（訳さない）:deployed
割振る:allocate する:割り振る
割振れる:allocate できる:割り振れる
	反映:exposing
比較-:compare:~
保持-:hold:~
報告-:report:~
訪問-:visit:~
無視-:ignore:~
	話す:speak
連結-:concatenate:~
連結:concatenation:~
表現-:represent:~
表現:representation:~
付加-:append:~
復帰-:recover:~
復帰:recovery:~
分離-:separate:~
	表す:denote:~
	表記:express:~
変化-:change:~
変更-:change:~
変更:change:~
変換-:convert:~
変換:conversion:~
	結果の:transformed
	-:translation
対話的:interactive:~
	やりとり:interaction
	やりとり:talking
置換-:replace:~
	超過:exceeding:~
限定:limit:~
出力:output:~
省略-:omit:~
	置かれ:place:~
追加-:add:~
追加:addition:~
追加の:additional:~
失敗-:fail::~
失敗:failure::~
開始-:start::~
下層の:underlying::~
	処理:process::~
待機-:wait::~
backoff::::バックオフ
遅延-:delay::~
遅延:delay::~
終了-:terminate:~
組織:organization:~
改変-:modify:~
読取り:read:読み取り
読取った:read した:読み取った
読取れて:read できて:読み取れて
	読取り法／読取り中:reading
内容:content:~
包含-:contain:~
割当て:assignment:割り当て
	有する／である:contain
	含む:include
	対応-:correspond:~
	対応:corresponding:~
	漸増:increasingly:~
	選ばれ:chosen:~
	素通り:skip:~
	回復:resumption of
	始め／始まる:begin
	繰り返す:repeat:~
	数え上げる:count:~
	請求が無い:unsolicited:~
	介在:presence
	在る下で:presence
	不在:absence
	有無:presence
	在る／示す:present:there is
	無い:not present:there are no
	伝え:inform:~
	からなる:compose
	成す:constitute
	成す／からなる:comprise:comprised of
	復唱／返される／返す:echo
	仕立て上げる
	近似:closely match
	~~記録:note:~
	開いて:open して:~
	prefix
	consists
	:look
	できる:ready to
	選ぶ:choose
	返-:return



	●未分類
SQL:
JS:JavaScript
	Mixed Content
	積み重ね:stack
queue::::キュー
field::::フィールド
stream::::ストリーム
script::::スクリプト
filtering::::フィルタリング
download::::ダウンロード
down::::ダウン
data-center:data center:::データセンター
streaming::::ストリーミング
page::::ページ
web::::ウェブ
metadata::::メタデータ
query::::クエリ
class::::クラス
pattern::::パターン
property::::プロパティ
group::::グループ
keyword::::キーワード
call::::コール
major::::メジャー
game::::ゲーム
	~game用:gaming
real-time:real time:::リアルタイム
size::::サイズ
access::::アクセス
parameter::::パラメタ
instant-messaging::::インスタントメッセンジャ
carrier::::キャリア
community:コミュンティ
comment::::コメント
computer::::コンピュータ
comma::::カンマ
system::::システム
shutdown::::シャットダウン
space::::スペース
selector::::セレクタ
tab-window::::タブウィンドウ
debug::::デバッグ
net::::ネット
	実~net:wild
part::::パート
bug::::バグ
form::::フォーム
browser::::ブラウザ
log::::ログ

文脈:context::~
	高次:high-level
順序:order::~
	~ABNF拡張:ABNF variant

携帯機:handset:~
携帯機上:mobile handset 上:~
源:source:~
言語:language:~
割合:percentage:~
一意的:unique:~
一時的:transient:~
間隔:interval:~
広告配信:ad-serving:~
初期:initial:~
	初期~時:initially
相場表示機:stock tickers:~
即時:immediate:~
種類:kind:~
数量:quantities:~
単位:unit:~
値:value:~
等価:equivalent:~
動的:dynamic:~
内部:internal:~
内側:inside:~
日付:date:~
標的:target:~
頻度:rate:~
別名:another name
変数:variable:~
	集合
	数
	量:amount
	総覧
	同様
	最大セグメント寿命:maximum segment lifetimes
	引数:with
	分担
	ある団体:Example Corporation
	べき乗打切り待機法:truncated binary exponential backoff

	●指示語
単独の:single:~
全部的:full:~
満杯:full:~
既存の:existing:~
現存の:existing:~
	従来の:pre-existing
既知の:known:~
新たな:new:~
新規に:fresh な:~
部位:portion:~
特定0の:particular:ある特定の
	個々の:particular
部分的:partial:~
	部分:part:~
	一部:part
	部:part
	一部分:part
近過去:recent:~
現在の:current:~
	現時点:currently:~
背後:behind:~
直の:direct な:~
直に:direct に:~
末端:end:~
専用の:dedicated:~
一定の:certain:~
関連する:relevant な:~
	第一の:primary
	第二の:secondary
	別種／別々:separate
	頭部:leading
	尾部:trailing
	先頭:leading
	先頭行:leading line
	最初の行:first line
	並び:〜s
	並び／列:sequence
	対象:subject
	範囲:range
	任意:arbitrarily／arbitrary／any
	非:non
	小:small
	同時／同時刻:simultaneous
	巨大:big
	広範:widely
	介し:via
	結果:result
	行:line
	段落:paragraph

	先立って:prior to
	同時
	今後:will
	今度:now
	期間
	それまでに:previously
	時を経れば:with time
	時間
	時刻:time
	時点
	以降
	以前
	待ち時間:latency
	最新に／直前の:latest
	〜待ち:pending-

	節:section
	下位節:sub sections
	総:total
	後続:subsequent／subsequently
	後続の:trailing
	元の:original
	だけ:just
	どこか他へ:away
	組:pair
	依然:still
	異なる:different
	個／つ:
	複数個: 1
	個目
	番目
	個数
	一環
	一組
	一度限り
	list:一覧
	一つ上の:top of
	いくつも:number of
	一連の:set
	合間:middle
	左端:leftmost
	最高位:most preferable
	最後の:final
	最終成果:end result
	最終的な結果:end result
	最初の:first
	最初の段階:first place
	最小の:minimal
	最小限に:minimal
	最上位:most significant
	自身:itself
	自体:itself
	主要な:main
	長い:long
	長大:long
	一致:identical
	同じ:same
	以上:or higher／
	それ以上の／:further
	以下
	以外
	双方
	相手
	相手側
	複数:multiple
	複数行:multiple lines
	下記
	各種
	各
	個別
	次項
	次第
	上述
	場合
	前記
	前後
	前述
	前~
	全体
	総数
	側:-side
	多少
	多数／多くの:many
	大多数:majority
	同順
	別個
	唯一
	両方／両者／両:both
	散在:around
	無い:absent 
	〜を通じて:over
	大きく:greatly
	もっぱら:solely
	限り早く:as soon as
	より少数の:fewer
	:high
	:higher
	:instead
	:parts


●●ref_normative

[ANSI.X3-4.1986]
    American National Standards Institute, <cite>Coded Character Set - 7-bit American Standard Code for Information Interchange</cite>, ANSI X3.4, 1986.

[FIPS.180-3]
    National Institute of Standards and Technology, <cite>Secure Hash Standard</cite>, FIPS PUB 180-3, October 2008, URL: http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf
    <div lang="ja" class="trans-ja-refs"><a href="http://www.ipa.go.jp/security/rfc/RFC3174JA.html">日本語訳（ RFC 3174 ）</a> <a href="http://www7b.biglobe.ne.jp/~k-west/SSLandTLS/rfc3174-Ja.txt">日本語訳（ RFC 3174 ）</a></div>

[RFC1928]
    Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, <cite>SOCKS Protocol Version 5</cite>, RFC 1928, March 1996. URL: https://tools.ietf.org/html/rfc1928

[RFC2119]
    Bradner, S., <cite>Key words for use in RFCs to Indicate Requirement Levels</cite>, BCP 14, RFC 2119, March 1997. URL: https://tools.ietf.org/html/rfc2119

[HTTP]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1),  June 2014. Proposed Standard.
    <cite>Message Syntax and Routing</cite>. URL: https://tools.ietf.org/html/rfc7230 
    <cite>Authentication</cite>. URL: https://tools.ietf.org/html/rfc7235 
    <cite>Semantics and Content</cite>. URL: https://tools.ietf.org/html/rfc7231 

[RFC2616]
    Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, <cite>Hypertext Transfer Protocol -- HTTP/1.1</cite>, RFC 2616, June 1999. URL: https://tools.ietf.org/html/rfc2616

[RFC2817]
    Khare, R. and S. Lawrence, <cite>Upgrading to TLS Within HTTP/1.1</cite>, RFC 2817, May 2000. URL: https://tools.ietf.org/html/rfc2817

[RFC2818]
    Rescorla, E., <cite>HTTP Over TLS</cite>, RFC 2818, May 2000. URL: https://tools.ietf.org/html/rfc2818

[RFC3629]
    Yergeau, F., <cite>UTF-8, a transformation format of ISO 10646</cite>, STD 63, RFC 3629, November 2003. URL: https://tools.ietf.org/html/rfc3629

[RFC3864]
    Klyne, G., Nottingham, M., and J. Mogul, <cite>Registration Procedures for Message Header Fields</cite>, <a href="./bcp90">BCP 90</a>, RFC 3864, September 2004. URL: https://tools.ietf.org/html/rfc3864

[RFC3986]
    Berners-Lee, T., Fielding, R., and L. Masinter, <cite>Uniform Resource Identifier (URI): Generic Syntax</cite>, STD 66, RFC 3986, January 2005. URL: https://tools.ietf.org/html/rfc3986

[RFC3987]
    Duerst, M. and M. Suignard, <cite>Internationalized Resource Identifiers (IRIs)</cite>, RFC 3987, January 2005. URL: https://tools.ietf.org/html/rfc3987

[RFC4086]
    Eastlake, D., Schiller, J., and S. Crocker, <cite>Randomness Requirements for Security</cite>, <a href="./bcp106">BCP 106</a>, RFC 4086, June 2005. URL: https://tools.ietf.org/html/rfc4086

[RFC4648]
    Josefsson, S., <cite>The Base16, Base32, and Base64 Data Encodings</cite>, RFC 4648, October 2006. URL: https://tools.ietf.org/html/rfc4648

[RFC5226]
    Narten, T. and H. Alvestrand, <cite>Guidelines for Writing an IANA Considerations Section in RFCs</cite>, <a href="./bcp26">BCP 26</a>, RFC 5226, May 2008. URL: https://tools.ietf.org/html/rfc5226

[RFC5234]
    Crocker, D. and P. Overell, <cite>Augmented BNF for Syntax Specifications: ABNF</cite>, STD 68, RFC 5234, January 2008. URL: https://tools.ietf.org/html/rfc5234

[RFC5246]
    Dierks, T. and E. Rescorla, <cite>The Transport Layer Security (TLS) Protocol Version 1.2</cite>, RFC 5246, August 2008. URL: https://tools.ietf.org/html/rfc5246

[RFC6066]
    Eastlake, D., <cite>Transport Layer Security (TLS) Extensions: Extension Definitions</cite>, RFC 6066, January 2011. URL: https://tools.ietf.org/html/rfc6066

[RFC6454]
    Barth, A., <cite>The Web Origin Concept</cite>, RFC 6454, December 2011. URL: https://tools.ietf.org/html/rfc6454


●●ref_informative


[RFC4122]
    Leach, P., Mealling, M., and R. Salz, <cite>A Universally Unique IDentifier (UUID) URN Namespace</cite>, RFC 4122, July 2005. URL: https://tools.ietf.org/html/rfc4122

[RFC4270]
    Hoffman, P. and B. Schneier, <cite>Attacks on Cryptographic Hashes in Internet Protocols</cite>, RFC 4270, November 2005. URL: https://tools.ietf.org/html/rfc4270

[RFC5321]
    Klensin, J., <cite>Simple Mail Transfer Protocol</cite>, RFC 5321, October 2008. URL: https://tools.ietf.org/html/rfc5321

[RFC6202]
    Loreto, S., Saint-Andre, P., Salsano, S., and G. Wilkins, <cite>Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP</cite>, RFC 6202, April 2011. URL: https://tools.ietf.org/html/rfc6202

[RFC6265]
    Barth, A., <cite>HTTP State Management Mechanism</cite>, RFC 6265, April 2011. URL: https://tools.ietf.org/html/rfc6265

[TALKING]
    Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, <cite>Talking to Yourself for Fun and Profit</cite>, 2010. URL: http://w2spconf.com/2011/papers/websocket.pdf

[W3C.REC-wsc-ui-20100812]
    Roessler, T. and A. Saldhana, <cite>Web Security Context: User Interface Guidelines</cite>, World Wide Web Consortium Recommendation REC-wsc-ui-20100812, August 2010. URL: https://www.w3.org/TR/2010/REC-wsc-ui-20100812/
    URL: https://www.w3.org/TR/wsc-ui/

[WSAPI]
    Hickson, I., <cite>The WebSocket API</cite>, W3C Working Draft WD-websockets-20110929, September 2011, URL: https://www.w3.org/TR/2011/WD-websockets-20110929/
    URL: https://www.w3.org/TR/websockets/

[XMLHttpRequest]
    van Kesteren, A., Ed., <cite>XMLHttpRequest</cite>, W3C Candidate Recommendation CR-XMLHttpRequest-20100803, August 2010, URL: https://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/
    URL: https://www.w3.org/TR/XMLHttpRequest/


●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.ietf.org/">IETF</a>
による
IETF による， 2011 年 12 月発行 PROPOSED STANDARD
<a href="https://www.ietf.org/rfc/rfc6455.txt">RFC 6455</a>
（<a href="https://tools.ietf.org/html/rfc6455">HTML 版</a>）
"The WebSocket Protocol"
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

発行
	Internet Engineering Task Force (IETF)
RFC
	6455
分類
	Standards Track
ISSN
	2070-1721
編集
	I. Fette, Google, Inc.
	A. Melnikov, Isode Ltd.
日付
	2011 年 12 月
著作者アドレス
	Ian Fette, Google, Inc. EMail: ifette+ietf@google.com, URI: http://www.ianfette.com/
	Alexey Melnikov, Isode Ltd. 5 Castle Business Village, 36 Station Road, Hampton, Middlesex TW12 2BX, UK, EMail: Alexey.Melnikov@isode.com

</script>

</head>

<body>


<header>
	<hgroup>
<h1>WebSocket Protocol</h1>
<h2>RFC 6455, The WebSocket Protocol</h2>
	</hgroup>
</header>


<div id="MAIN" style="display:none;">
	<section>
<h2 title="Abstract">~~要約</h2>

<p>
~WebSocket~Protocolは、制御された環境~下で信用できない~codeを走らせている~clientと，その~codeからの通信に対する~opt-inを備える~remote~hostとの間の双路~通信を可能にする。
利用される~security~modelは、各~web~browserから共通して用いられている，生成元（ origin ）に基づく~security~modelである。
~protocolは、~TCPの上に重ねられる，~opening~handshake, および後続の基本的な~message~frame法からなる。
この技術の目標は、~serverとの双路~通信を必要とする，~browserに基づく~app用に、複数の~HTTP接続の open （例えば， `XMLHttpRequest^c や `&lt;iframe&gt;^c と長い~pollingを併用するものなど）に依拠しない仕組みを供することである。
◎
The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the origin-based security model commonly used by web browsers. The protocol consists of an opening handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using XMLHttpRequest or &lt;iframe&gt;s and long polling).
</p>

	</section>
	<section>
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p>
これは、 Internet Standards Track 文書である。
◎
This is an Internet Standards Track document.
</p>

<p>
この文書は、
<abbr title="Internet Engineering Task Force">IETF</abbr>
よる成果物であり，
IETF ~communityの合意を表現するものである。
それは、公共の考査を受け，
<abbr title="Internet Engineering Steering Group">IESG</abbr>
から~~発行が承認されたものである。
Internet Standards
についての更なる情報は `5741-2$secに見られる。
◎
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
</p>

<p>
この文書の現在の位置付け, 正誤表, ~feedbackの方法についての情報は、
<a href="http://www.rfc-editor.org/info/rfc6455">http://www.rfc-editor.org/info/rfc6455</a>
から得られる。
◎
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6455.
</p>

		<section>
<h5 title="Copyright Notice">著作権の~~告知</h5>

<p lang="en-x-a0">
Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p>
この文書は、その~~発行の日付から~~有効なものとして、
<a href="~IETF/bcp78">BCP 78</a>,
および IETF Trust の IETF Documents に対する Legal Provisions Relating の対象になる（
<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>
）。
これらの文書には、この文書に関するあなたの権利と制約条項が述べらているので，入念に査読されたし。
この文書から取り出された Code Components は、
Trust Legal Provisions の 4.e 節
に述べられるように, Simplified BSD License ~textを含んでいなければならず、
Simplified BSD License に述べられるように，無保証で供される。
◎
This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
</p>
		</section>
	</section>

<main id="MAIN0">


	<section id="section-1">
<h2 title="Introduction">1. 序論</h2>

		<section id="section-1.1">
<h3 title="Background">1.1. 背景</h3>

~INFORMATIVE

<p>
歴史的に、~client↔~server間の双方向~通信を必要とする~web~app（例えば，~instant-messagingや, ~game用~app）の作成においては、~serverから更新を~pollingするために，上流への通知を別個の~HTTP~callとして送信する間、~HTTPの濫用を要していた `RFC6202$r 。
◎
Historically, creating web applications that need bidirectional communication between a client and a server (e.g., instant messaging and gaming applications) has required an abuse of HTTP to poll the server for updates while sending upstream notifications as distinct HTTP calls [RFC6202].
</p>

<p>
これは様々な問題を引き起こす：
◎
This results in a variety of problems:
</p>

<ul>

	<li>
~serverは、~clientのそれぞれに対し，下層の~TCP接続をいくつも利用するよう強いられる：
~clientへの情報の送信に 1 個，着信~messageのそれぞれに新たなものを 1 個ずつ。
◎
The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client and a new one for each incoming message.
</li>
	<li>
~clientから~serverへの~messageのそれぞれに~HTTP~headerが含まれるため、伝送路~protocolの~overheadが高くなる。
◎
The wire protocol has a high overhead, with each client-to-server message having an HTTP header.
</li>
	<li>
~client側~scriptは、返信を追跡するために，発信~接続から着信~接続への対応付けを保守することを強いられる。
◎
The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.
</li>
</ul>

<p>
より単純な解決策は、両~方向の流通~用に，単独の~TCP接続を利用するものになるであろう。
これが、~WebSocket~Protocolが供するものである。
それは，~WebSocket~API
`WSAPI$r
との併用により、~web~pageから~remote~serverへの双路~通信~用の，~HTTP~pollingに代わるものを供する。
◎
A simpler solution would be to use a single TCP connection for traffic in both directions. This is what the WebSocket Protocol provides. Combined with the WebSocket API [WSAPI], it provides an alternative to HTTP polling for two-way communication from a web page to a remote server.
</p>

<p>
同じ技法は様々な~web~appにも利用できる：
~game, 相場表示機, 複数~利用者から同時に編集できる~app,
~server側の~serviceが~real-timeに反映される利用者~interface，等々。
◎
The same technique can be used for a variety of web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.
</p>

<p>
~WebSocket~Protocolは、現存の通信基盤からの利点（~proxy, ~filtering, 認証）を得るために~HTTPを~transport層に利用している，既存の双方向~通信~技術に、なり代わるものを目指して設計されている。
~HTTPには元々，双方向~通信の用途は想定されていないので（更なる論は `RFC6202$r を見よ）、その種の技術は，効率性と信頼性の~trade-offとして実装されていた。
~WebSocket~Protocolは、現存の~HTTP通信基盤の環境~下における，既存の双方向~HTTP技術の目標に取り組むものである。
そのようなわけで、現在の環境に特有の 多少の複雑さも伴うことにはなるが、それは、
~HTTPの~port 80 ／ 443 を通じて働くように，加えて~HTTP~proxyや中継点を~supportするように設計されている。
しかしながら，その設計は~WebSocketを~HTTPに限定するものではなく、将来の実装は~protocol全体を再発明することなく，専用の~portを通じた，より単純な~handshakeを利用するものにもなり得る。
この最後の点は、対話的~messagingの流通~patternが標準の~HTTPの流通に近似しないものであり，一部の~componentにおいては過度の負荷を誘引し得ることから、重要である。
◎
The WebSocket Protocol is designed to supersede existing bidirectional communication technologies that use HTTP as a transport layer to benefit from existing infrastructure (proxies, filtering, authentication). Such technologies were implemented as trade-offs between efficiency and reliability because HTTP was not initially meant to be used for bidirectional communication (see [RFC6202] for further discussion). The WebSocket Protocol attempts to address the goals of existing bidirectional HTTP technologies in the context of the existing HTTP infrastructure; as such, it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries, even if this implies some complexity specific to the current environment. However, the design does not limit WebSocket to HTTP, and future implementations could use a simpler handshake over a dedicated port without reinventing the entire protocol. This last point is important because the traffic patterns of interactive messaging do not closely match standard HTTP traffic and can induce unusual loads on some components.
</p>

		</section>
		<section id="section-1.2">
<h3 title="Protocol Overview">1.2. ~protocolの概観</h3>

~INFORMATIVE

<p>
この~protocolは、~handshakeおよび~data転送の， 2 つの~partからなる：
◎
The protocol has two parts: a handshake and the data transfer.
</p>

<p>
次のような~~形の~clientからの~handshakeに対し：
◎
The handshake from the client looks as follows:
</p>

<pre class="example">
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
</pre>

<p>
~serverからの~handshakeは次のような~~形をとる：
◎
The handshake from the server looks as follows:
</p>

<pre class="example">
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
</pre>

<p>
~clientからの先頭行は `request-line$P 形式に従う。
~serverからの先頭行は `status-line$P 形式に従う。
`HTTP$r
◎
The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format. The Request-Line and Status-Line productions are defined in [RFC2616].
</p>

<p>
いずれの場合も，先頭行（ `start-line$P ）の後に順序のない一連の~HTTP~headerが続く。
これらの~headerの意味は、この文書の `4$secにて指定される。
`Cookie$h `RFC6265$r などの追加の~headerも在ってよい。
~headerの形式と構文解析-法は， `HTTP$r にて定義される。
◎
An unordered set of header fields comes after the leading line in both cases. The meaning of these header fields is specified in Section 4 of this document. Additional header fields may also be present, such as cookies [RFC6265]. The format and parsing of headers is as defined in [RFC2616].
</p>

<p>
~client, ~serverの両者が それぞれの~handshakeを送信した後，~handshakeに成功したならば、~data転送~partが開始される。
これは、それぞれの側が互いに独立に, 自身の~~意向で~dataを送信できる，双路~通信~channelである。
◎
Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can, independently from the other, send data at will.
</p>

<p>
~handshakeの成功-後、~clientと~serverは，この仕様において “~message” と呼ばれる，概念的な単位で区切られた~dataを 相互に転送しあう。
伝送路~上では， 1 個の~messageは 1 個~以上の~frameからなる。
~WebSocket~messageは特定0の~network層~frame法に対応する必要はなく、断片化された~messageは，中継点において合併-／分割され得る。
◎
After a successful handshake, clients and servers transfer data back and forth in conceptual units referred to in this specification as "messages". On the wire, a message is composed of one or more frames. The WebSocket message does not necessarily correspond to a particular network layer framing, as a fragmented message may be coalesced or split by an intermediary.
</p>


<div class="p">
<p id="frame-type">
~frameには種別（ type ）が結び付けられる。
同じ~messageに属する~frameたちは，同じ種別の~dataを包含する。
おおまかには、種別は次のものに分類される：
</p>

<ul>
	<li>
~text~data用途（ ~UTF-8 `RFC3629$r ~textとして解釈される）
</li>
	<li>
~binary~data用途（その解釈は~appに委ねられる）
</li>
	<li>
`制御~frame$用途（~app用の~dataを運ぶのではなく，接続が~closeされるべき旨の信号を送るなど，~protocol~levelの信号~用に意図される）。
</li>
</ul>

<p>
この~versionの~protocolは 6 種類の~frame種別を定義し，残る 10 種類は将来~利用のために予約-済みとする。
</p>

◎
A frame has an associated type. Each frame belonging to the same message contains the same type of data. Broadly speaking, there are types for textual data (which is interpreted as UTF-8 [RFC3629] text), binary data (whose interpretation is left up to the application), and control frames (which are not intended to carry data for the application but instead for protocol-level signaling, such as to signal that the connection should be closed). This version of the protocol defines six frame types and leaves ten reserved for future use.

</div>

		</section>
		<section id="section-1.3">
<h3 title="Opening Handshake">1.3. ~opening~handshake</h3>

~INFORMATIVE

<p>
単独の~portを，~serverとやりとりする~HTTP~clientからも,
および~serverとやりとりする~WebSocket~clientからも利用できるようにするため、~opening~handshakeは，~HTTPに基づく~server側~softwareや中継点と互換になることが意図されている。
そのため、~WebSocket~clientの~handshakeは，~HTTP`~Upgrade$要請になる：
◎
The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. To this end, the WebSocket client's handshake is an HTTP Upgrade request:
</p>

<pre class="example">
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
</pre>

<p>
`HTTP$r に従い、~clientから送信される~handshake内の~headerの順序は任意であり，受信される~headerの順序は有意ではない。
◎
In compliance with [RFC2616], header fields in the handshake may be sent by the client in any order, so the order in which different header fields are received is not significant.
</p>

<p>
`GET$hm ~methodの `request-target$P `HTTP$r は，~WebSocket接続の端点†を識別するために用いられ、 1 個の~IP~addressによる複数~domainにわたる~serve，および
単独の~serverによる複数の~WebSocket端点に対する~serveを可能にする。
◎
The "Request-URI" of the GET method [RFC2616] is used to identify the endpoint of the WebSocket connection, both to allow multiple domains to be served from one IP address and to allow multiple WebSocket endpoints to be served by a single server.
</p>

<p class="trans-note">【†
“端点（ endpoint ）” ：
~network通信の両端
— この仕様では、~client, ~server —
を指す総称。
対義語は “中継点（ intermediary ）”。
原文には，端点と同じ意味で語 “~peer（ピア）” も用いられているが、この訳では一律に “端点” と記すことにする：
<a href="~IETF/rfc7540#section-2.2">HTTP/2 による定義</a>
によれば、この語は，論の主題とされている端点から見た，他方の端点を指すとされているが、日本語に訳す際には “相手の~peer”, “〜側の~peer”, 等々と記すことになり， “端点” と使い分ける意味が無いので。
】</p>

<p>
~clientは、 `HTTP$r に従い，利用中の~hostがどれなのか~clientと~server間で互いの一致を検証できるように，その~handshakeの `Host$h ~header内に~host名を含ませる。
◎
The client includes the hostname in the |Host| header field of its handshake as per [RFC2616], so that both the client and the server can verify that they agree on which host is in use.
</p>

<p>
~WebSocket~Protocolには 追加の~headerもあり、~optionを選択するために利用できる。
この~versionにて可用な代表的な~optionには、下位protocol~selector（ `Sec-WebSocket-Protocol^h ）,
~clientが~supportする拡張の~list（ `Sec-WebSocket-Extensions^h ）,
`Origin^h ~header，などがある。
<!-- over -->
`Sec-WebSocket-Protocol^h 要請
~headerは、~clientが受容-可能な下位protocol（~WebSocket~Protocol層~上の，~app~levelの~protocol）の指示に利用できる。
~serverは、受容-可能な~protocolのうち，いずれか 1 個または 0 個を選択して、その~protocolが選択されたことを指示するために，~handshakeにてその値を返す。
◎
Additional header fields are used to select options in the WebSocket Protocol. Typical options available in this version are the subprotocol selector (|Sec-WebSocket-Protocol|), list of extensions support by the client (|Sec-WebSocket-Extensions|), |Origin| header field, etc. The |Sec-WebSocket-Protocol| request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket Protocol) are acceptable to the client. The server selects one or none of the acceptable protocols and echoes that value in its handshake to indicate that it has selected that protocol.
</p>

<pre class="example">
Sec-WebSocket-Protocol: chat
</pre>

<p>
`Origin^h ~header `RFC6454$r は、［
~web~browserの中で~WebSocket~APIを利用する~scriptによる，権限のない非同一生成元による~WebSocket~serverの利用
］から保護するために利用される。
~serverには、~WebSocket接続~要請を生成する~scriptの生成元が伝えられる。
~serverは，この生成元からの接続の受容を望まない場合、適切な~HTTP~error~codeを送信して，接続を却下できる。
この~headerは，~browser~clientから送信される。
非~browser~clientの場合、その種の~clientの文脈において意味を成すのであれば，この~headerが送信されてもよい。
◎
The |Origin| header field [RFC6454] is used to protect against unauthorized cross-origin use of a WebSocket server by scripts using the WebSocket API in a web browser. The server is informed of the script origin generating the WebSocket connection request. If the server does not wish to accept connections from this origin, it can choose to reject the connection by sending an appropriate HTTP error code. This header field is sent by browser clients; for non-browser clients, this header field may be sent if it makes sense in the context of those clients.
</p>

<p>
最後に、~serverは，~WebSocket接続でない接続を受容しないようにするために、~clientに対し，~clientによる~WebSocket~handshakeを受信したことを立証する必要がある。
これにより、攻撃者が `XMLHttpRequest^c `XMLHttpRequest$r や~form提出を用いて巧妙に細工された~packetを送信して，~WebSocket~serverを騙そうとする試みは防止される。
◎
Finally, the server has to prove to the client that it received the client's WebSocket handshake, so that the server doesn't accept connections that are not WebSocket connections. This prevents an attacker from tricking a WebSocket server by sending it carefully crafted packets using XMLHttpRequest [XMLHttpRequest] or a form submission.
</p>

<p>
~handshakeの受信を立証するためには、~serverは，先ず
~client~handshake要請の `Sec-WebSocket-Key^h ~headerから得られる`~base64に符号化-$された~nonce：
◎
The first piece of information comes from the |Sec-WebSocket-Key| header field in the client handshake:
</p>

<pre class="example">
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
</pre>

<p>
を得た上で、その値から`~hashを構築-$した結果（この例では
`s3pPLMBiTxaQ9kYGzzhZRbK+xOo=^l
になる）を，~serverの~handshake応答の `Sec-WebSocket-Accept^h ~header内に返す必要がある。
【`~hashを構築-$する具体的な過程は、その~algoに付記されている例に見られるので、この訳では省略する。】
◎
To prove that the handshake was received, the server has to take two pieces of information and combine them to form a response. For this header field, the server has to take the value (as present in the header field, e.g., the base64-encoded [RFC4648] version minus any leading and trailing whitespace) and concatenate this with the Globally Unique Identifier (GUID, [RFC4122]) "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" in string form, which is unlikely to be used by network endpoints that do not understand the WebSocket Protocol. A SHA-1 hash (160 bits) [FIPS.180-3], base64-encoded (see Section 4 of [RFC4648]), of this concatenation is then returned in the server's handshake.
◎
Concretely, if as in the example above, the |Sec-WebSocket-Key| header field had the value "dGhlIHNhbXBsZSBub25jZQ==", the server would concatenate the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" to form the string "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11". The server would then take the SHA-1 hash of this, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded (see Section 4 of [RFC4648]), to give the value "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=". This value would then be echoed in the |Sec-WebSocket-Accept| header field.
</p>

<p>
~serverからの~handshakeは、~clientからの~handshakeよりもずっと単純になる。
最初の行は`応答~code$ `101$st を伴う~HTTP `status-line$P になる：
◎
The handshake from the server is much simpler than the client handshake. The first line is an HTTP Status-Line, with the status code 101:
</p>

<pre class="example">
HTTP/1.1 101 Switching Protocols
</pre>

<p>
`101$st 以外のどの`応答~code$も
~WebSocket~handshakeが完了しておらず，~HTTPの意味論が依然として適用されることを指示する。
`応答~code$の後に~headerが続く。
◎
Any status code other than 101 indicates that the WebSocket handshake has not completed and that the semantics of HTTP still apply. The headers follow the status code.
</p>

<p>
`Connection$h と `Upgrade$h ~headerが~HTTP`~Upgrade$を成す。
<!--  -->
`Sec-WebSocket-Accept^h ~headerは、~serverが接続を受容するつもりがあるかどうかを指示する。
在るならば，この~headerは［
`Sec-WebSocket-Key^h 内に送信された~clientの~nonce
］から`~hashを構築-$した結果を含んでいなければならない。
他のすべての値は、~serverによる接続の受容に解釈されてはならない。
◎
The |Connection| and |Upgrade| header fields complete the HTTP Upgrade. The |Sec-WebSocket-Accept| header field indicates whether the server is willing to accept the connection. If present, this header field must include a hash of the client's nonce sent in |Sec-WebSocket-Key| along with a predefined GUID. Any other value must not be interpreted as an acceptance of the connection by the server.
</p>

<pre class="example">
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
</pre>

<p>
これらの~headerは、~scriptされた~pageに対し，~WebSocket~clientから検査される。
［
`Sec-WebSocket-Accept^h を有さないか,
有しているが その値が期待される値に合致しない場合
］または［
`応答~code$が `101$st でない場合
］、接続は確立されず，~WebSocket~frameは送信されないことになる。
◎
These fields are checked by the WebSocket client for scripted pages. If the |Sec-WebSocket-Accept| value does not match the expected value, if the header field is missing, or if the HTTP status code is not 101, the connection will not be established, and WebSocket frames will not be sent.
</p>

<p>
~optionの~headerを含めることもできる。
この~versionの~protocolにおける主要な~option~headerは、~serverが選択した下位protocolを指示する， `Sec-WebSocket-Protocol^h である。
~WebSocket~clientは、自身が~handshakeに指定した下位protocol値のうちの 1 つを，~serverが含ませたかどうか検証する。
複数の下位protocolを話せる~serverは、~clientの~handshakeに基づいて，いずれか 1 つを選択して、その~handshakeに指定する必要がある。
◎
Option fields can also be included. In this version of the protocol, the main option field is |Sec-WebSocket-Protocol|, which indicates the subprotocol that the server has selected. WebSocket clients verify that the server included one of the values that was specified in the WebSocket client's handshake. A server that speaks multiple subprotocols has to make sure it selects one based on the client's handshake and specifies it in its handshake.
</p>

<pre class="example">
Sec-WebSocket-Protocol: chat
</pre>

<p>
~serverは、 `RFC6265$r の記述に従って，~cookieに関係する~option~headerを設定することにより、~cookieを
<a href="#dfn-cookie-during-handshake">設定する</a>
こともできる。
◎
The server can also set cookie-related option fields to _set_ cookies, as described in [RFC6265].
</p>

		</section>
		<section id="section-1.4">
<h3 title="Closing Handshake">1.4. ~closing~handshake</h3>

~INFORMATIVE

<p>
~closing~handshakeは，~opening~handshakeよりもずっと単純である。
◎
The closing handshake is far simpler than the opening handshake.
</p>

<p>
双方の端点とも、~closing~handshakeを始めるために，指定された制御~列を包含する~dataを伴う`制御~frame$を送信できる（詳細は `5.5.1$secに述べる）。
その種の~frameが受信された際には、相手の端点は，まだ送信していなければ，応答として `Close$fr ~frameを送信する。
最初に送信した側の端点は，その`制御~frame$を受信した際に、それ以上の~dataが来ないものとして，接続を安全に~closeする。
<!-- in~the~knowledge~that -->
◎
Either peer can send a control frame with data containing a specified control sequence to begin the closing handshake (detailed in Section 5.5.1). Upon receiving such a frame, the other peer sends a Close frame in response, if it hasn't already sent one. Upon receiving _that_ control frame, the first peer then closes the connection, safe in the knowledge that no further data is forthcoming.
</p>

<p>
接続の~closeを指示する`制御~frame$を［
送信した端点は，それ以降 ~dataを送信しない ／
受信した端点は，それ以降に受信した~dataを破棄する
］。
◎
After sending a control frame indicating the connection should be closed, a peer does not send any further data; after receiving a control frame indicating the connection should be closed, a peer discards any further data received.
</p>

<p>
双方の端点が，この~handshakeを同時に起動しても 安全である。
◎
It is safe for both peers to initiate this handshake simultaneously.
</p>

<p>
~closing~handshakeは、特に透過型~proxyや他の中継点が介在する場合において，~TCP~closing~handshakeが常に依拠-可能な~end-to-endになるとは限らない意味で、~TCP~closing~handshake（~FIN/ACK ）を補完することが意図されている。
◎
The closing handshake is intended to complement the TCP closing handshake (FIN/ACK), on the basis that the TCP closing handshake is not always reliable end-to-end, especially in the presence of intercepting proxies and other intermediaries.
</p>

<p>
`Close$fr ~frameを送信して，その応答の `Close$fr ~frameを待機することにより、~dataが不必要に失われ得る一定の事例を避けれる。
例えば，何らかの~platformにおいて，~dataが受信~queueに残ったまま~socketが~closeされた場合、~RST~packetが送信され、読取り待ちの~dataがあったとしても，その~RSTを受信した側の `recv()^c は失敗する。
◎
By sending a Close frame and waiting for a Close frame in response, certain cases are avoided where data may be unnecessarily lost. For instance, on some platforms, if a socket is closed with data in the receive queue, a RST packet is sent, which will then cause recv() to fail for the party that received the RST, even if there was data waiting to be read.
</p>

		</section>
		<section id="section-1.5">
<h3 title="Design Philosophy">1.5. 設計理念</h3>

~INFORMATIVE

<p>
~WebSocket~Protocolは、~frame法は最小限に留めるべき，とする原則に基づいて設計されている（~frame法は、~protocolを~streamではなく~frameに基づくものにすること, および~Unicode~textと~binaryの~frameの区別を~supportすること、のために限られている）。
~metadataは、~app層により，~WebSocketの一つ上に積層することが期待されている — ~metadataが~app層により，~TCPの一つ上に積層するのと同じ仕方で（例えば，~HTTP）。
◎
The WebSocket Protocol is designed on the principle that there should be minimal framing (the only framing that exists is to make the protocol frame-based instead of stream-based and to support a distinction between Unicode text and binary frames). It is expected that metadata would be layered on top of WebSocket by the application layer, in the same way that metadata is layered on top of TCP by the application layer (e.g., HTTP).
</p>

<p>
概念的には，~WebSocketは、ちょうど，次だけを行う~TCPの一つ上の層である：
◎
Conceptually, WebSocket is really just a layer on top of TCP that does the following:
</p>

<ul>
	<li>
~browser用の，~web生成元に基づく~security~modelを追加する
◎
adds a web origin-based security model for browsers
</li>
	<li>
1 個の~port上における複数の~serviceを,
および  1 個の~IP~address上における複数の~host名を~supportするための、~address法と~protocol命名の仕組みを追加する
◎
adds an addressing and protocol naming mechanism to support multiple services on one port and multiple host names on one IP address
</li>
	<li>
~TCPの一つ上に~frame法の仕組みを積層することにより、~TCPの下層の~IP~packetの仕組みを（長さ制限を取り払いつつ）取り戻す
◎
layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits
</li>
	<li>
~proxyや他の中継点が介在していても働くように設計された、追加の~closing~handshakeを帯域内に含む
<!--  -->
◎
includes an additional closing handshake in-band that is designed to work in the presence of proxies and other intermediaries
</li>
</ul>

<p>
それ以外のものは、~WebSocketには加えられない。
基本的に，それは、~Webの拘束~下において，ちょうど，~scriptに生の~TCPを露出させるに近いものが意図されている。
また、その~handshakeを妥当な~HTTP`~Upgrade$要請に仕立て上げることにより，
~serverが~portを~HTTP~serverと共有できるようにも設計されている。
~client↔~server間の~messagingを他の~protocolを利用して確立することも考えられるが、~WebSocketの意図は、~HTTPや配備-済みの通信基盤（~proxyなど）と共存し，~security面においても そのような通信基盤と~TCPとの併用に近い安全さを備えつつ、利用法を単純~化して，単純な事を単純なまま保つことも念頭に（~message意味論の追加など）、比較的~単純な~protocolを供する所にある。
◎
Other than that, WebSocket adds nothing. Basically it is intended to be as close to just exposing raw TCP to script as possible given the constraints of the Web. It's also designed in such a way that its servers can share a port with HTTP servers, by having its handshake be a valid HTTP Upgrade request. One could conceptually use other protocols to establish client-server messaging, but the intent of WebSockets is to provide a relatively simple protocol that can coexist with HTTP and deployed HTTP infrastructure (such as proxies) and that is as close to TCP as is safe for use with such infrastructure given security considerations, with targeted additions to simplify usage and keep simple things simple (such as the addition of message semantics).
</p>

<p>
~protocolは，拡張-可能なように意図されている。
将来の~versionでは、おそらく，多重化などの追加の概念も導入されることになるものと見込まれている。
◎
The protocol is intended to be extensible; future versions will likely introduce additional concepts such as multiplexing.
</p>

		</section>
		<section id="section-1.6">
<h3 title="Security Model">1.6. ~security~model</h3>

~INFORMATIVE

<p>
~WebSocket~Protocolが~web~pageから利用される際に，~WebSocket~serverに接触できる~web~pageを制約するため、~WebSocket~Protocolでは，~web~browser間で利用されている生成元（ origin ）~modelが採用されている。
当然，~WebSocket~Protocolが専用の~clientから直に利用される場合（すなわち，~web~browserを通した~web~pageからではなく）、~clientは任意の生成元~文字列を供せるので，生成元~modelは有用なものにならない。
◎
The WebSocket Protocol uses the origin model used by web browsers to restrict which web pages can contact a WebSocket server when the WebSocket Protocol is used from a web page. Naturally, when the WebSocket Protocol is used by a dedicated client directly (i.e., not from a web page through a web browser), the origin model is not useful, as the client can provide any arbitrary origin string.
</p>

<p>
この~protocolは、~SMTP `RFC5321$r や~HTTPなどの従来の~protocolの~serverとの接続の確立には失敗する一方で、欲されるなら，~HTTP~serverがこの~protocolを~opt-inで~support可能にすることが意図されている。
これは、~handshakeを厳格かつ精巧にして，~handshakeが完遂する前に 接続に挿入できる~dataを制限することにより（したがって~serverへの波及も制限される）、達成される。
◎
This protocol is intended to fail to establish a connection with servers of pre-existing protocols like SMTP [RFC5321] and HTTP, while allowing HTTP servers to opt-in to supporting this protocol if desired. This is achieved by having a strict and elaborate handshake and by limiting the data that can be inserted into the connection before the handshake is finished (thus limiting how much the server can be influenced).
</p>

<p>
同様に、他の~protocol，特に~HTTPから~WebSocket~serverに向けて~dataが送信される際にも、接続の確立は失敗するように意図されている
— 例えば、~HTMLの “~form” が~WebSocket~serverに提出されたとき，起こり得るような。
これは主に、~serverに対し，~handshakeを読取ったことを立証するよう要求することにより、達成される。
すなわち，~serverからの~handshakeを行えるのは、~WebSocket~client以外からは送信され得ない適切な要素
【~protocol要素（ `6365-6$sec ）】
を包含している場合に限られるようにされている。
特に，この仕様が書かれた時点においては、攻撃者は，~HTMLと `XMLHttpRequest^c `XMLHttpRequest$r  などの~JS~APIのみを利用する~web~browserからは， `Sec-^h で始まる~headerは設定し得ない。
◎
It is similarly intended to fail to establish a connection when data from other protocols, especially HTTP, is sent to a WebSocket server, for example, as might happen if an HTML "form" were submitted to a WebSocket server. This is primarily achieved by requiring that the server prove that it read the handshake, which it can only do if the handshake contains the appropriate parts, which can only be sent by a WebSocket client. In particular, at the time of writing of this specification, fields starting with |Sec-| cannot be set by an attacker from a web browser using only HTML and JavaScript APIs such as XMLHttpRequest [XMLHttpRequest].
</p>

		</section>
		<section id="section-1.7">
<h3 title="Relationship to TCP and HTTP">1.7. ~TCPおよび~HTTPとの関係性</h3>

~INFORMATIVE

<p>
~WebSocket~Protocolは、~TCPに基づく，独立の~protocolである。
その~HTTPとの関係性は、その~handshakeが~HTTP~serverからは`~Upgrade$要請として解釈される点に限られている。
◎
The WebSocket Protocol is an independent TCP-based protocol. Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.
</p>

<p>
~WebSocket~Protocolの既定においては、定例の~WebSocket接続には~port 80 が利用され，~TLS（ Transport Layer Security ） `RFC2818$r を通じて~tunnelされた~WebSocket接続には~port 443 が利用される。
◎
By default, the WebSocket Protocol uses port 80 for regular WebSocket connections and port 443 for WebSocket connections tunneled over Transport Layer Security (TLS) [RFC2818].
</p>


		</section>
		<section id="section-1.8">
<h3 title="Establishing a Connection">1.8. 接続の確立</h3>

~INFORMATIVE

<p>
~HTTP~serverと共有されている~portに接続が~~設けられる場合（~port 80 ／ 443 への流通ではごく普通に生じ得る状況）、その接続は，~HTTP~serverからは`~Upgrade$の申し出を伴う定例の `GET$hm 要請に見えることになる。
~IP~addressが 1 個だけで, すべての流通が単独の~host名の単独の~serverと行き交うような，比較的~単純な設置においては、これは，配備されることになる~WebSocket~Protocolに基づく~systemにとり, 実用的な仕方になり得る。
より精巧な（例えば，負荷分散装置や複数の~serverを伴う）設置においては、~HTTP~serverから分離された，~WebSocket接続~専用の~hostたちを~~用意する方が、おそらく管理し易いものになる。
この仕様が書かれた時点では、~port 80 上と 443 上では，接続の成功~率は~port 443 の方が有意に高いことは記しておくべきだが、これは，時を経れば変わり得るものでもある。
◎
When a connection is to be made to a port that is shared by an HTTP server (a situation that is quite likely to occur with traffic to ports 80 and 443), the connection will appear to the HTTP server to be a regular GET request with an Upgrade offer. In relatively simple setups with just one IP address and a single server for all traffic to a single hostname, this might allow a practical way for systems based on the WebSocket Protocol to be deployed. In more elaborate setups (e.g., with load balancers and multiple servers), a dedicated set of hosts for WebSocket connections separate from the HTTP servers is probably easier to manage. At the time of writing of this specification, it should be noted that connections on ports 80 and 443 have significantly different success rates, with connections on port 443 being significantly more likely to succeed, though this may change with time.
</p>

		</section>
		<section id="section-1.9">
<h3 title="Subprotocols Using the WebSocket Protocol">1.9. ~WebSocket~protocolを利用する下位protocol</h3>

~INFORMATIVE

<p>
~clientは、~handshake内に `Sec-WebSocket-Protocol^h ~headerを含めることにより，~serverに対し, 特定の下位protocolの利用を要請できる。
指定された場合，接続が確立されるためには、~serverは，対する応答~内に同じ名前の~headerを含ませて, その値に［
~clientが選択した下位protocol値のいずれか 1 つ
］を与える必要がある。
◎
The client can request that the server use a specific subprotocol by including the |Sec-WebSocket-Protocol| field in its handshake. If it is specified, the server needs to include the same field and one of the selected subprotocol values in its response for the connection to be established.
</p>

<p>
これらの下位protocol名は、 `11.5$secに従って登録されるべきである。
衝突の可能性を避けるため、下位protocolの考案者の~domain名の~ASCII~versionを包含する名前の利用が推奨される。
例えば、ある団体が，~Webに散在する多数の~serverへの実装が期待される~Chat下位protocolを作成して, `chat.example.com^l と命名したとして、別の組織が，それと競う下位protocolを `chat.example.org^l と命名したとする
— その 2 つの下位protocolは、［
~serverにおいて利用する下位protocolを，~clientから送信される値に基づいて 動的に選択する
］ことにより，同時に実装することもできる。
◎
These subprotocol names should be registered as per Section 11.5. To avoid potential collisions, it is recommended to use names that contain the ASCII version of the domain name of the subprotocol's originator. For example, if Example Corporation were to create a Chat subprotocol to be implemented by many servers around the Web, they could name it "chat.example.com". If the Example Organization called their competing subprotocol "chat.example.org", then the two subprotocols could be implemented by servers simultaneously, with the server dynamically selecting which subprotocol to use based on the value sent by the client.
</p>

<p>
下位protocolは、その名前を変更することで，後方互換でない仕方で~version付けできる。
例えば
`bookings.example.net^l
から
`v2.bookings.example.net^l
へ，等々。
これらの下位protocolは完全に別種の~WebSocket~clientと見なされることになる。
後方互換な~version付けは、同じ下位protocol文字列を再利用して，この種の拡張性を~supportするように, 実際の下位protocolを注意深く設計することにより、実装できる。
◎
Subprotocols can be versioned in backward-incompatible ways by changing the subprotocol name, e.g., going from "bookings.example.net" to "v2.bookings.example.net". These subprotocols would be considered completely separate by WebSocket clients. Backward-compatible versioning can be implemented by reusing the same subprotocol string but carefully designing the actual subprotocol to support this kind of extensibility.
</p>

		</section>
	</section>
	<section id="section-2">
<h2 title="Conformance Requirements">2. 適合性の要件</h2>

<p>
明示的に “規範的でない” と記された節に加えて、この仕様~内のすべての 図式, 例, 注記 は，規範的ではない。
他のすべては規範的である。
◎
All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
</p>

<p>
この文書における次の~keywordは、 `RFC2119$r に則って解釈されるものとする
⇒＃
“〜しなければ（〜しては）~MUST_NOT” = “MUST (NOT)”,
“〜する~SHOULDである（でない）” = “SHOULD (NOT)”,
“〜しても~MAY” = “MAY”,
<em class="rfc2119">任意選択</em> = “OPTIONAL”
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
</p>

<p>
~algoの中の命令的言い回しによる要件（例えば “頭部の~space文字~並びを取り除く” ,  “ false を返してこの手続きを中止する” など）は、~algoを導入する際に利用されている~keyword（「〜し~MUST」, 「〜する~SHOULD」, 「〜しても~MAY」, 等々）の意味の下に解釈されることになる。
<!-- （"MUST", " SHOULD", " MAY"） -->
◎
Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the key word ("MUST", "SHOULD", "MAY", etc.) used in introducing the algorithm.
</p>

<p>
~algoまたは特定の手続きとして記される適合性の要件は、最終的な結果が等価になるのであれば，どう実装されても~MAY。
特に，この仕様で定義される~algoは、処理能より追い易さが意図されている。
◎
Conformance requirements phrased as algorithms or specific steps MAY be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow and not intended to be performant.)
</p>

		<section id="section-2.1">
<h3 title="Terminology and Other Conventions">2.1. 各種用語とその他の表記規約</h3>

<p class="trans-note">【
この節の一部の内容の和訳は、省略する
— 原文の素の~textにおける 文字に基づく表記規約（この訳は~HTML~markupを利用するので）や，利用されていない用語など。
】</p>

<p>
~ASCIIは `ANSI.X3-4.1986$r に定義される文字符号化~schemeとする。
◎
_ASCII_ shall mean the character-encoding scheme defined in [ANSI.X3-4.1986].
</p>

<p>
この文書は、STD 63 `RFC3629$r で定義される，~UTF-8 値と~UTF-8 表記~形式を参照する。
◎
This document makes reference to UTF-8 values and uses UTF-8 notational formats as defined in STD 63 [RFC3629].
◎
以下和訳は省略：
Key terms such as named algorithms or definitions are indicated like _this_.
◎
Names of header fields or variables are indicated like |this|.
◎
Variable values are indicated like /this/.
◎
（無意味な記述）
This document references the procedure to _Fail the WebSocket Connection_. This procedure is defined in Section 7.1.7.
◎
_Converting a string to ASCII lowercase_ means replacing all characters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters in the range U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL LETTER Z).
</p>

<p>
2 つの文字列を
`~ASCII大小無視@
で比較するときは、 U+0041 〜 U+005A （すなわち LATIN CAPITAL LETTER A 〜 LATIN CAPITAL LETTER Z ）の範囲の文字と対応する U+0061 〜 U+007A （すなわち LATIN SMALL LETTER A 〜 LATIN SMALL LETTER Z ）の範囲の文字は同一視することを除き，それぞれの文字の符号位置ごとに厳密に比較することを意味する。
【実際には、この仕様の “文字” は，すべて~byteを意味する。】
◎
Comparing two strings in an _ASCII case-insensitive_ manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding characters in the range U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to also match.
</p>

<p>
この文書の用語 "~URI" は `RFC3986$r にて定義される。
◎
The term "URI" is used in this document as defined in [RFC3986].
</p>

<p>
実装が~WebSocket~Protocolの一部として，`~dataを送信する$必要が生じた際は、実際の伝送は任意に遅延しても~MAY。
例えば、より少数の~IP~packetで送信するために~dataを~bufferするなど。
◎
When an implementation is required to _send_ data as part of the WebSocket Protocol, the implementation MAY delay the actual transmission arbitrarily, e.g., buffering data so as to send fewer IP packets.
</p>

<p>
この文書は、 `RFC5234$r に加えて，節に応じて `HTTP$r による`~ABNF拡張$も利用することに注意。
◎
Note that this document uses both [RFC5234] and [RFC2616] variants of ABNF in different sections.
</p>

		</section>
		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
~WebSocket`~status~code$と混同されないよう、`~HTTP~status~code$は一律に
`応答~code@
と記すことにする。
</p>

<p>
この仕様が参照している~HTTP仕様の用語は `RFC2616$r によるが、ここでは，その後継~仕様である RFC7230 〜 RFC7235 `HTTP$r を参照することにする（そのため、一部の用語は等価なものに置換し，参照文献に `HTTP$r を追加している）。
</p>

<p>
用語の定義箇所を表す，節 番号の多くは、代わりに用語そのものにリンクをあてがった上で，節 番号の記述を省略している。
</p>

		</section>
	</section>
	<section id="section-3">
<h2 title="WebSocket URIs">3. ~WebSocket~URI</h2>

<p>
この仕様は、 `RFC5234$r にて定義される~ABNF構文，および
~URI仕様 `RFC3986$r にて定義される用語と~ABNF生成規則を用いて， 2 つの~URI~schemeを定義する。
◎
This specification defines two URI schemes, using the ABNF syntax defined in RFC 5234 [RFC5234], and terminology and ABNF productions defined by the URI specification RFC 3986 [RFC3986].
</p>


<pre class="ABNF">
`ws-URI@P
      = "ws:" "//" `host$P [ ":" `port$P ] `path$P [ "?" `query$P ]
`wss-URI@P
      = "wss:" "//" `host$P [ ":" `port$P ] `path$P [ "?" `query$P ]

`host@P
      = &lt;host, `3986-3.2.2$secの定義による&gt;

`port@P
      = &lt;port, `3986-3.2.3$secの定義による&gt;
`path@P
      = &lt;path-abempty, `3986-3.3$secの定義による&gt;
`query@P
      = &lt;query, `3986-3.4$secの定義による&gt;
</pre>

<!-- 
ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]
wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]

host = &lt;host, defined in [RFC3986], Section 3.2.2&gt;

port = &lt;port, defined in [RFC3986], Section 3.2.3&gt;
path = &lt;path-abempty, defined in <a href="~IETF/rfc3986#section-3.3">[RFC3986], Section 3.3</a>&gt;
query = &lt;query, defined in [RFC3986], Section 3.4&gt;
-->

<p>
所与の~WebSocket~URI（ `ws-URI$P ／ `wss-URI$P ）に対しては，次が定義される：
</p>

<ul>
	<li>
%~host
— `host$P 成分
</li>
	<li>
%~port
— `port$P 成分。
これは，<em class="rfc2119">任意選択</em>であり、省略時の既定の~port番号は，次項に与える %~secure~flag に応じて［
~OFF ならば 80 ／
~ON ならば 443
］とする。
◎
The port component is OPTIONAL; the default for "ws" is port 80, while the default for "wss" is port 443.
</li>
	<li>
%~secure~flag
— ［
~scheme成分が `wss^sc に~ASCII大小無視で合致するならば ~T ／
他の場合は ~F
］とする。
◎
The URI is called "secure" (and it is said that "the secure flag is set") if the scheme component matches "wss" case-insensitively.
</li>
	<li>
<p>
%~resource名
— 次を順に連結した結果として与えられる：
◎
The "resource-name" (also known as /resource name/ in Section 4.1) can be constructed by concatenating the following:
</p>
		<ol>
			<li>
`path$P 成分は空ならば `/^l ／
~ELSE_ `path$P 成分
◎
"/" if the path component is empty
◎
the path component
</li>
			<li>
`query$P 成分は空ならば空~文字列 ／
~ELSE_ 次を順に連結した結果
⇒
`?^l, `query$P
◎
"?" if the query component is non-empty
◎
the query component
</li>
		</ol>
	</li>
</ul>


<p>
~WebSocket~URIの文脈においては、素片~識別子は無意味であり，これらの~URIに利用されては~MUST_NOT。
他の~URI~scheme同様、素片の開始を指示しない文字 `#^l は `%23^P に~escapeされ~MUST。
◎
Fragment identifiers are meaningless in the context of WebSocket URIs and MUST NOT be used on these URIs. As with any URI scheme, the character "#", when not indicating the start of a fragment, MUST be escaped as %23.
</p>

	</section>
	<section id="section-4">
<h2 title="Opening Handshake">4. ~opening~handshake</h2>

		<section id="section-4.1">
<h3 title="Client Requirements">4.1. ~clientに課される要件</h3>

<div class="p">
<p>
`~WebSocket接続を確立する$ためには、この節で定義されるように，~clientは、接続を~openして~handshakeを送信する。
接続は、初期~時には
`~CONNECTING状態@
にあるものと定義される。
~clientは、接続を~openするにあたり，次を入力に給する必要がある：
</p>

<ul>
	<li>
%~host,
%~port,
%~secure~flag,
%~resource名
— `3$secにて述べた，~WebSocket~URIの成分
</li>
	<li>
%~protocol~list
— 利用する下位protocolの~list
</li>
	<li>
%拡張~list
— 利用する拡張の~list
</li>
	<li>
%生成元 （~clientが~web~browserの場合に限り）
</li>
</ul>


◎
To _Establish a WebSocket Connection_, a client opens a connection and sends a handshake as defined in this section. A connection is defined to initially be in a CONNECTING state. A client will need to supply a /host/, /port/, /resource name/, and a /secure/ flag, which are the components of a WebSocket URI as discussed in Section 3, along with a list of /protocols/ and /extensions/ to be used. Additionally, if the client is a web browser, it supplies /origin/.


</div>

<p>
制御された環境~下で稼働している~client，例えば，特定の~carrierに拘束された携帯機上の~browserでは、接続の管理を~network上の他の~agentに負荷委譲しても~MAY。
その種の状況における~clientは、この仕様の目的においては，その携帯機~softwareとその種の任意の~agentの両方を含むものと見なされる。
◎
Clients running in controlled environments, e.g., browsers on mobile handsets tied to specific carriers, MAY offload the management of the connection to another agent on the network. In such a situation, the client for the purposes of this specification is considered to include both the handset software and any such agents.
</p>

<p>
~clientは，
`~WebSocket接続を確立する@
ときは、上述の入力の下に，以下に与える~algoに従わ~MUST：
<!-- ＊冗長なので残りは省略 -->
◎
When the client is to _Establish a WebSocket Connection_ given a set of (/host/, /port/, /resource name/, and /secure/ flag), along with a list of /protocols/ and /extensions/ to be used, and an /origin/ in the case of web browsers, it MUST open a connection, send an opening handshake, and read the server's handshake in response. The exact requirements of how the connection should be opened, what should be sent in the opening handshake, and how the server's response should be interpreted are as follows in this section. In the following text, we will use terms from Section 3, such as "/host/" and "/secure/ flag" as defined in that section.
</p>

<ol>
	<li>
［
%~host, %~port, %~resource名, %~secure~flag
］のうち いずれかが， `3$secに指定される~WebSocket~URIの仕様に則って妥当でない場合、`~WebSocket接続を失敗させ$て，この手続きを中止する。
【`4398$errataによる追記あり（ Held for Document Update ）。 %~secure~flag ~EQ ~F の下での Mixed Content （<a href="~MIXED-CONTENT#mixed-content">混在内容</a>）に関する取扱いについて述べている。】
◎
1. The components of the WebSocket URI passed into this algorithm (/host/, /port/, /resource name/, and /secure/ flag) MUST be valid according to the specification of WebSocket URIs specified in Section 3. If any of the components are invalid, the client MUST _Fail the WebSocket Connection_ and abort these steps.
</li>
	<li>
<div class="p">
<p>
<del>~host %~host と~port %~port の組で識別される~remote~host（~IP~address）</del>
<ins>同じ［~IP~addressと~portの組］</ins>
への~WebSocket接続がすでにある場合、その~remote~hostが別の名前として既知であるとしても，その接続が［
確立される, または失敗する
］まで，待機する
— その際には、次に従わ~MUST：
</p>
		<ul>
			<li>
<ins>どの［~IP~addressと~portの組］に対しても</ins>，
`~CONNECTING状態$にある接続が同時に複数~~存在しないようにする。
</li>
			<li>
同じ~IP~address<ins >と~portの組</ins>に対し，複数の接続が同時に試みられている場合、以下の手続きを走らせている間，複数の接続が~~存在しないように, それらを直列化する。
</li>
		</ul>

【`3473$errataによる修正（ Verified ）】
<span lang="en">
2. If the client already has a WebSocket connection to the
<del>remote host (IP address) identified by /host/ and port /port/ pair</del>
<ins>same IP address and port pair</ins>,
even if the remote host is known by another name, the client MUST wait until that connection has been established or for that connection to have failed. There MUST be no more than one connection in
<del>a CONNECTING state</del>
<ins>the CONNECTING state for any IP address and port pair</ins>.
If multiple connections to the same IP address
<ins>and port pair</ins>
are attempted simultaneously, the client MUST serialize them so that there is no more than one connection at a time running through the following steps.
</span>

</div>


<p>
~remote~hostの~IP~addressを決定できない場合（例えば，すべての通信は~DNS~query自体を遂行する~proxy~serverを通して行われているとき）、この段の目的においては 各~host名が別個の~remote~hostを参照しているものと見做した上で，同時の接続待ちの総数を適度に低い数に制限する~SHOULDである（例えば，~clientが `a.example.com^s と `b.example.com^s への同時の接続待ちを許容し得るとしても，単独の~hostに対し 30 個の同時~接続が要請された場合、許容されなくなり得る）。
例えば，~web~browser~clientは、同時の接続待ち数を制限するにあたり，利用者が開いている~tab-window数を考慮する必要がある。
◎
If the client cannot determine the IP address of the remote host (for example, because all communication is being done through a proxy server that performs DNS queries itself), then the client MUST assume for the purposes of this step that each host name refers to a distinct remote host, and instead the client SHOULD limit the total number of simultaneous pending connections to a reasonably low number (e.g., the client might allow simultaneous pending connections to a.example.com and b.example.com, but if thirty simultaneous connections to a single host are requested, that may not be allowed). For example, in a web browser context, the client needs to consider the number of tabs the user has open in setting a limit to the number of simultaneous pending connections.
</p>

<p class="note">注記：
これにより、~scriptが［
単に~remote~hostへ向けて多数の~WebSocket接続を~openするような，~DoS攻撃
］を遂行するのは、より困難になる。
更に、~serverは，攻撃された際には、接続を~closeする前に一時停止して, ~clientによる再接続の頻度を抑制することにより，自身の負荷を軽減できる。
◎
NOTE: This makes it harder for a script to perform a denial-of-service attack by just opening a large number of WebSocket connections to a remote host. A server can further reduce the load on itself when attacked by pausing before closing the connection, as that will reduce the rate at which the client reconnects.
</p>

<p class="note">注記：
~clientが単独の~remote~host向けて確立できる~WebSocket接続の総数に，制限はない。
~serverは、すでに接続~数が過度にある~host／~IP~addressからの接続の受容を拒める。
~serverは、高~負荷を被った際には, ~resourceを浪費している接続を切断できる。
◎
NOTE: There is no limit to the number of established WebSocket connections a client can have with a single remote host. Servers can refuse to accept connections from hosts/IP addresses with an excessive number of existing connections or disconnect resource-hogging connections when suffering high load.
</p>
	</li>
	<li>
<p>
`~proxyの用法@
◎
3. _Proxy Usage_:＼
</p>

		<ul>
			<li>
<p>
~WebSocket~Protocolを利用して
( ~host %~host, ~port %~port )
に接続する際に，~proxyを利用するように環境設定されている場合には、その~proxyに接続して，
( ~host %~host, ~port %~port )
に向けて, ~TCP接続を~openするよう依頼する~SHOULDである。
◎
If the client is configured to use a proxy when using the WebSocket Protocol to connect to host /host/ and port /port/, then the client SHOULD connect to that proxy and ask it to open a TCP connection to the host given by /host/ and the port given by /port/.
</p>

<div class="example">

<p>
例えば，~clientが、すべての流通に~HTTP~proxyを利用していて，~server `example.com^s の~port 80 への接続を試行している場合、次の行を~proxy~serverに送信することになろう：
◎
EXAMPLE: For example, if the client uses an HTTP proxy for all traffic, then if it was to try to connect to port 80 on server example.com, it might send the following lines to the proxy server:
</p>

<pre>
CONNECT example.com:80 HTTP/1.1
Host: example.com
</pre>

<p>
~passwordがある場合の接続は次のようになろう：
◎
If there was a password, the connection might look like:
</p>

<pre>
CONNECT example.com:80 HTTP/1.1
Host: example.com
Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=
</pre>
</div>

			</li>
			<li>
<p>
~clientが~proxyを利用するよう環境設定されていない場合、
( ~host %~host, ~port %~port )
に向けて，直の~TCP接続が~openされる~SHOULDである。
◎
If the client is not configured to use a proxy, then a direct TCP connection SHOULD be opened to the host given by /host/ and the port given by /port/.
</p>

<p class="note">注記：
WebSocket 接続~用の~proxyを他の~proxyとは別に選択するための，明示的な~UIを公開しない実装は、可用であれば，~SOCKS5`RFC1928$r ~proxyを~WebSocket接続に利用することが奨励される。
それができない場合、~HTTP接続~用に環境設定された~proxyを通じて，~HTTPS接続~用に環境設定された~proxyを利用することが選好される。
◎
NOTE: Implementations that do not expose explicit UI for selecting a proxy for WebSocket connections separate from other proxies are encouraged to use a SOCKS5 [RFC1928] proxy for WebSocket connections, if available, or failing that, to prefer the proxy configured for HTTPS connections over the proxy configured for HTTP connections.
</p>
			</li>
			<li>
<p>
~proxy自動設定~script目的で渡される~URIは、
`3$secの~WebSocket~URIの定義に従って，
%~host, %~port, %~resource名, %~secure~flag
から構築されてい~MUST。
◎
For the purpose of proxy autoconfiguration scripts, the URI to pass the function MUST be constructed from /host/, /port/, /resource name/, and the /secure/ flag using the definition of a WebSocket URI as given in Section 3.
</p>

<p class="note">注記：
~proxy自動設定~scriptにおいては、~WebSocket~Protocolであるかどうかは，~schemeから識別できる（暗号化されてない接続に対しては `ws^sc, 暗号化された接続に対しては `wss^sc ）
◎
NOTE: The WebSocket Protocol can be identified in proxy autoconfiguration scripts from the scheme ("ws" for unencrypted connections and "wss" for encrypted connections).
</p>

			</li>
		</ul>
	</li>
	<li>
直の接続が失敗した, あるいは利用している~proxyが~errorを返したなどにより，接続を~openできなかった場合、`~WebSocket接続を失敗させ$て 接続の試みを中止する。
◎
4. If the connection could not be opened, either because a direct connection failed or because any proxy used returned an error, then the client MUST _Fail the WebSocket Connection_ and abort the connection attempt.
</li>
	<li>
<p>
%~secure が ~T の場合、接続を~openした後, ~handshake~data `RFC2818$r を送信する前までに，接続を通じて~TLS~handshakeを
— その Server Name Indication 拡張 `RFC6066$r を利用する下で —
遂行する：
</p>
		<ul>
			<li>
~TLS~handshakeに失敗した場合（例えば，~serverの証明書を検証できなかったとき）、`~WebSocket接続を失敗させ$て, 接続を中止する。
</li>
			<li>
他の場合、この~channel上の以降の通信はすべて，暗号化された~tunnel `RFC5246$r を通して稼働させる。
</li>
		</ul>
◎
5. If /secure/ is true, the client MUST perform a TLS handshake over the connection after opening the connection and before sending the handshake data [RFC2818]. If this fails (e.g., the server's certificate could not be verified), then the client MUST _Fail the WebSocket Connection_ and abort the connection. Otherwise, all further communication on this channel MUST run through the encrypted tunnel [RFC5246].
◎
Clients MUST use the Server Name Indication extension in the TLS handshake [RFC6066].
</li>
</ol>

<p>
~serverへの接続がいったん確立されたなら（~proxyを介した接続や, ~TLSで暗号化された~tunnelを通じた接続も含め）、~clientは，~serverへ向けて~opening~handshakeを送信し~MUST。
~handshakeは，~HTTP`~Upgrade$要請であり、それに伴う~headerには, 要求されるものと, 任意選択のものがある。
この~handshakeを成す要請は、次に挙げるすべての要件を満たさ~MUST：
◎
Once a connection to the server has been established (including a connection via a proxy or over a TLS-encrypted tunnel), the client MUST send an opening handshake to the server. The handshake consists of an HTTP Upgrade request, along with a list of required and optional header fields. The requirements for this handshake are as follows.
</p>

<ul>
	<li>
`HTTP$r に指定されるように 妥当な~HTTP要請である。
◎
1. The handshake MUST be a valid HTTP request as specified by [RFC2616].
</li>
<!-- 2 -->
	<li>
<p>
~methodは `GET$hm である, かつ
~HTTP~versionは 1.1 以上である。
◎
2. The method of the request MUST be GET, and the HTTP version MUST be at least 1.1.
</p>

<p class="example">
例えば，~WebSocket~URIが
`ws://example.com/chat^l
ならば、送信される最初の行は
`GET /chat HTTP/1.1^l
になっているべきである。
◎
For example, if the WebSocket URI is "ws://example.com/chat", the first line sent should be "GET /chat HTTP/1.1".
</p>

	</li>
	<li>
<p>
`request-target$P が成す部分は、次のいずれかに合致する：
</p>
		<ul>
			<li>
`3$secに定義した %~resource名 （相対~URI）
</li>
			<li>
構文解析された際に対応する
`ws^sc／`wss^sc ~URIに合致する
%~resource名, %~host, %~port 
を持つような 絶対 `http^c ／ `https^c ~URI。
</li>
		</ul>
◎
3. The "Request-URI" part of the request MUST match the /resource name/ defined in Section 3 (a relative URI) or be an absolute http/https URI that, when parsed, has a /resource name/, /host/, and /port/ that match the corresponding ws/wss URI.
</li>
	<li>
`Host$h ~headerを有していて, その値は次のいずれかである
⇒＃
%~host（既定の~portを利用する場合）／
%~host, `:^l, %~port を順に連結した結果
◎
4. The request MUST contain a |Host| header field whose value contains /host/ plus optionally ":" followed by /port/ (when not using the default port).
</li>
	<li>
`Upgrade$h ~headerを有していて,
その値は~keyword `websocket^l を含んでいる
◎
5. The request MUST contain an |Upgrade| header field whose value MUST include the "websocket" keyword.
</li>
	<li>
`Connection$h ~headerを有していて,
その値は `Upgrade^l ~tokenを含んでいる。
◎
5. The request MUST contain a |Connection| header field whose value MUST include the "Upgrade" token.
</li>
	<li>
<p>
`Sec-WebSocket-Key^h ~headerを有していて, かつ
その値は［
~randomに選ばれた長さ 16 の~byte列
］を`~base64に符号化-$した結果の~nonceである。
~nonceは、各 接続ごとに，~randomに選ばれ~MUST。
【~nonce：一度限りのもの（ “number used once” ）】
◎
7. The request MUST include a header field with the name |Sec-WebSocket-Key|. The value of this header field MUST be a nonce consisting of a randomly selected 16-byte value that has been base64-encoded (see Section 4 of [RFC4648]). The nonce MUST be selected randomly for each connection.
</p>

<p class="example">
例えば，~randomに選ばれた値が~byte列
`0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10^s
であった場合、~headerの値は
<del>`AQIDBAUGBwgJCgsMDQ4PEC==^l</del>
<ins>`AQIDBAUGBwgJCgsMDQ4PEA==^l</ins>
になる。
【`3150$errataによる修正（ Verified ）】
◎
NOTE: As an example, if the randomly selected value was the sequence of bytes 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, the value of the header field would be "AQIDBAUGBwgJCgsMDQ4PEC=="
</p>

	</li>
	<li>
<p>
~browser~clientである場合は、 `Origin^h ~header `RFC6454$r を有している。
非~browser~clientである場合、その~clientの意味論が~browser~clientに対しここに述べた利用事例に合致するならば、要請は， `Origin^h ~headerを含ませても~MAY。
この~headerの値は、接続を確立している~codeが属する文脈の生成元を~ASCIIに直列化した結果とする。
この~headerの値がどう構築されるかについての詳細は、 `RFC6454$r を見よ。
◎
8. The request MUST include a header field with the name |Origin| [RFC6454] if the request is coming from a browser client. If the connection is from a non-browser client, the request MAY include this header field if the semantics of that client match the use-case described here for browser clients. The value of this header field is the ASCII serialization of origin of the context in which the code establishing the connection is running. See [RFC6454] for the details of how this header field value is constructed.
</p>

<p class="example">
例えば，
`www.example.com^l
から~downloadされた~codeが
`ww2.example.com^l
へ向けて接続を確立しようと試みる場合、~headerの値は
`http://www.example.com^l
になるであろう。
◎
As an example, if code downloaded from www.example.com attempts to establish a connection to ww2.example.com, the value of the header field would be "http://www.example.com".
</p>

	</li>
	<li>
<p>
`Sec-WebSocket-Version^h ~headerを有していて, その値は 13 である。
◎
9. The request MUST include a header field with the name |Sec-WebSocket-Version|. The value of this header field MUST be 13.
</p>

<p class="note">注記：
この文書の草案の~version番号（ -09, -10, -11, -12 ）が公示されたが（それらのほとんどは、伝送路~protocolに対する変更ではなく，編集上の変更や明確化からなる）、番号 9, 10, 11, 12 は `Sec-WebSocket-Version^h の妥当な番号としては利用されていない。
これらの値は~IANA~registryに予約-済みであるが、これまでも利用されておらず，今後も利用されることはない。
◎
NOTE: Although draft versions of this document (-09, -10, -11, and -12) were posted (they were mostly comprised of editorial changes and clarifications and not changes to the wire protocol), values 9, 10, 11, and 12 were not used as valid values for Sec-WebSocket-Version. These values were reserved in the IANA registry but were not and will not be used.
</p>

	</li>
	<li id="subprotocol-req">
`Sec-WebSocket-Protocol^h ~headerを有さないか, または
有していて その値は次を満たす
⇒
［
`Sec-WebSocket-Protocol-Client$P 生成規則に合致する
］, かつ［
値を成す各 `token$P は値の中で一意的である
］
⇒
各`token$P は下位protocolを指示し，それらの順序は、~clientの選好順を指示する。
◎
10. The request MAY include a header field with the name |Sec-WebSocket-Protocol|. If present, this value indicates one or more comma-separated subprotocol the client wishes to speak, ordered by preference. The elements that comprise this value MUST be non-empty strings with characters in the range U+0021 to U+007E not including separator characters as defined in [RFC2616] and MUST all be unique strings. The ABNF for the value of this header field is 1#token, where the definitions of constructs and rules are as given in [RFC2616].
</li>
	<li>
`Sec-WebSocket-Extensions^h ~headerを有さないか, または
有していて その値は `Sec-WebSocket-Extensions$P 生成規則に合致する
⇒
これは 1 個~以上の~protocol~levelの拡張を，~clientの選好順に指示する。
この~headerの解釈と形式は `9.1$secにて述べる。
◎
11. The request MAY include a header field with the name |Sec-WebSocket-Extensions|. If present, this value indicates the protocol-level extension(s) the client wishes to speak. The interpretation and format of this header field is described in Section 9.1.
</li>
</ul>

<p>
要請は、他の任意の~headerを含ませても~MAY
— 例えば `Cookie$h ~header `RFC6265$r や,
`Authorization$h `HTTP$r などの認証に関係する~headerなど。
それらは、それぞれを定義する文書に則って処理される。
◎
12. The request MAY include any other header fields, for example, cookies [RFC6265] and/or authentication-related header fields such as the |Authorization| header field [RFC2616], which are processed according to documents that define them.
</p>

<p id="validate-server-response">
~clientは、~opening~handshakeを送信したなら、更に~dataを送信する前に，~serverからの応答を待機し~MUST。
~clientは、以下に従って~server応答の妥当性を~~検証し~MUST：
◎
Once the client's opening handshake has been sent, the client MUST wait for a response from the server before sending any further data. The client MUST validate the server's response as follows:
</p>

<ol>
<!-- 1 -->
	<li>
~serverから受信された`応答~code$が `101$st でない場合、応答を~HTTP `HTTP$r の手続きに従って取扱う。
特に，~clientは、`応答~code$ `401$st を受信した際には，認証を遂行し得る。
~serverは、`応答~code$ `3xx$st を用いて~clientを~redirectし得る（ただし，~clientがそれに追従することは要求されていない），等々。
他の場合、次へ進む。
◎
If the status code received from the server is not 101, the client handles the response per HTTP [RFC2616] procedures. In particular, the client might perform authentication if it receives a 401 status code; the server might redirect the client using a 3xx status code (but clients are not required to follow them), etc. Otherwise, proceed as follows.
</li>
<!-- 2 〜 6 -->
	<li>
<p>
応答が次のいずれかに該当する場合、`~WebSocket接続を失敗させ$~MUST：
◎
↓</p>
		<ul>
			<li>
応答は `Upgrade$h ~headerを有さないか,
有していて その値は `websocket^l に~ASCII大小無視で合致しない値を包含している場合。
◎
If the response lacks an |Upgrade| header field or the |Upgrade| header field contains a value that is not an ASCII case-insensitive match for the value "websocket", the client MUST _Fail the WebSocket Connection_.
</li>
<!-- 3 -->
			<li>
応答は `Connection$h ~headerを有さないか,
有していて その値は `Upgrade^l に~ASCII大小無視で合致する~tokenを包含していない場合。
◎
If the response lacks a |Connection| header field or the |Connection| header field doesn't contain a token that is an ASCII case-insensitive match for the value "Upgrade", the client MUST _Fail the WebSocket Connection_.
</li>
<!-- 4 -->
			<li>
応答は `Sec-WebSocket-Accept^h ~headerを有さないか,
有していて その値は（頭部と尾部の空白を無視した上で）,
`Sec-WebSocket-Key^h の値から`~hashを構築-$した結果に一致しない場合。
◎
If the response lacks a |Sec-WebSocket-Accept| header field or the |Sec-WebSocket-Accept| contains a value other than the base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-Key| (as a string, not base64-decoded) with the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" but ignoring any leading and trailing whitespace, the client MUST _Fail the WebSocket Connection_.
</li>
<!-- 5 -->
			<li>
応答は
`Sec-WebSocket-Extensions^h ~headerを有していて, かつ
その~header値は~clientの~handshakeには無かった拡張の利用を指示している場合（~serverが~clientから要請されなかった拡張を指示した）。
（どの拡張が要請されたかを決定するための，この~headerの構文解析-法については、 `9.1$secにて論じる。）
◎
If the response includes a |Sec-WebSocket-Extensions| header field and this header field indicates the use of an extension that was not present in the client's handshake (the server has indicated an extension not requested by the client), the client MUST _Fail the WebSocket Connection_. (The parsing of this header field to determine which extensions are requested is discussed in Section 9.1.)
</li>
<!-- 6 -->
			<li>
応答は
`Sec-WebSocket-Protocol^h ~headerを有していて, かつ
その~header値は~clientの~handshakeには無かった下位protocolの利用を指示している場合（~serverが~clientから要請されなかった下位protocolを指示した）。
◎
If the response includes a |Sec-WebSocket-Protocol| header field and this header field indicates the use of a subprotocol that was not present in the client's handshake (the server has indicated a subprotocol not requested by the client), the client MUST _Fail the WebSocket Connection_.
</li>
		</ul>
	</li>
</ol>

<p>
~serverの応答が，この節に加えて `4.2.2$secに定義されている~serverの~handshakeに課される要件に適合していない場合、~clientは`~WebSocket接続を失敗させ$~MUST。
◎
If the server's response does not conform to the requirements for the server's handshake as defined in this section and in Section 4.2.2, the client MUST _Fail the WebSocket Connection_.
</p>

<p>
`HTTP$r に則って、どの~headerであれ
— 要請, 応答にかかわらず —
その名前は ~ASCII大小無視で比較されることに注意。
◎
Please note that according to [RFC2616], all header field names in both HTTP requests and HTTP responses are case-insensitive.
</p>

<p>
~server応答の妥当性が 上に与えたように~~検証されたならば：
◎
If the server's response is validated as provided for above,＼
</p>

<ul>
	<li>
`~WebSocket接続は確立されて@
いるとされ，~WebSocket接続は
`~OPEN状態@
にあるとされる。
◎
it is said that _The WebSocket Connection is Established_ and that the WebSocket Connection is in the OPEN state.＼
</li>
	<li>
`利用中の拡張@
は、~serverの~handshakeに `Sec-WebSocket-Extensions^h ~headerが［
在るならば その値（空にもなり得る） ／
無いならば ~NULL 値
］と定義される。
◎
The _Extensions In Use_ is defined to be a (possibly empty) string, the value of which is equal to the value of the |Sec-WebSocket-Extensions| header field supplied by the server's handshake or the null value if that header field was not present in the server's handshake.＼
</li>
	<li>
`利用中の下位protocol@
は、~serverの~handshakeに `Sec-WebSocket-Protocol^h ~headerが［
在るならば その値 ／
無いならば ~NULL 値
］と定義される。
◎
The _Subprotocol In Use_ is defined to be the value of the |Sec-WebSocket-Protocol| header field in the server's handshake or the null value if that header field was not present in the server's handshake.＼
</li>
	<li>
加えて，~serverの~handshakeに~cookieが設定されるべきであることを指示する~header（ `RFC6265$r ）がある場合、その~cookieを指して
`~serverの~opening~handshakeの間に設定される~cookie@
と呼ぶ。
◎
Additionally, if any header fields in the server's handshake indicate that cookies should be set (as defined by [RFC6265]), these cookies are referred to as _Cookies Set During the Server's Opening Handshake_.
</li>
</ul>


		</section>
		<section id="section-4.2">
<h3 title="Server-Side Requirements">4.2. ~server側に課される要件</h3>

<p>
~serverは接続の管理を~network上の他の~agentに負荷委譲しても~MAY。
例えば負荷分散装置（ load balancer ）や逆~proxy（ reverse proxy ）など。
その種の状況では、~serverは，この仕様の目的においては、~server側の通信基盤のすべての部分，最初の機器から~TCP接続の終了まで、要請の処理と応答の送信について~server側に帰着されるすべてを含むものと見なされる。
◎
Servers MAY offload the management of the connection to other agents on the network, for example, load balancers and reverse proxies. In such a situation, the server for the purposes of this specification is considered to include all parts of the server-side infrastructure from the first device to terminate the TCP connection all the way to the server that processes requests and sends responses.
</p>

<p class="example">例：
~data-centerは、適切な~handshakeを伴う~WebSocket要請に応答する~serverを持つことがあり，接続を，実際に`~data~frame$を処理する別~serverに 渡し得る。
この仕様の目的においては、 “~server” は，両者の~computerの組み合わせになる。
◎
EXAMPLE: A data center might have a server that responds to WebSocket requests with an appropriate handshake and then passes the connection to another server to actually process the data frames. For the purposes of this specification, the "server" is the combination of both computers.
</p>


			<section id="section-4.2.1">
<h4 title="Reading the Client's Opening Handshake">4.2.1. ~clientからの~opening~handshakeの読取り法</h4>

<p>
~clientは、~WebSocket接続を開始するとき，自身の分担の~opening~handshakeを送信する。
~serverは、［
~server側~分担の~handshakeを生成するために必要とされる情報
］を得るために，少なくともこの~handshakeの一部分を構文解析しなければならない。
◎
When a client starts a WebSocket connection, it sends its part of the opening handshake. The server must parse at least part of this handshake in order to obtain the necessary information to generate the server part of the handshake.
</p>

<p>
~clientの~opening~handshakeは、以下に挙げる部分からなる。
~serverは、~handshakeの読取り中に，~clientが下の記述に合致する~handshakeを送信していないことを見出した場合（ `HTTP$r に従って，~headerの順序は重要でないことに注意）
— ~handshakeの成分に指定されている~ABNF文法への違反も含め，それに限られず —
~clientからの~handshakeの処理を停止して，適切な~error~codeを伴う~HTTP応答（ `400$st `Bad Request^ph など）を返さ~MUST。
◎
The client's opening handshake consists of the following parts. If the server, while reading the handshake, finds that the client did not send a handshake that matches the description below (note that as per [RFC2616], the order of the header fields is not important), including but not limited to any violations of the ABNF grammar specified for the components of the handshake, the server MUST stop processing the client's handshake and return an HTTP response with an appropriate error code (such as 400 Bad Request).
</p>

<ul>
<!-- 1 -->
	<li>
`3$secで定義される %~resource名 として解釈されるべきである `request-target$P または（ %~resource名 を包含している絶対 ~HTTP／~HTTPS ~URI）を含んでいる， HTTP/1.1 以上の `GET$hm 要請。
◎
An HTTP/1.1 or higher GET request, including a "Request-URI" [RFC2616] that should be interpreted as a /resource name/ defined in Section 3 (or an absolute HTTP/HTTPS URI containing the /resource name/).
</li>
<!-- 2 -->
	<li>
~serverの権限（ authority ）を包含している
`Host$h ~header。
◎
A |Host| header field containing the server's authority.
</li>
<!-- 3 -->
	<li>
~ASCII大小無視の値として値 `websocket^l を包含している，
`Upgrade$h ~header。
◎
An |Upgrade| header field containing the value "websocket", treated as an ASCII case-insensitive value.
</li>
<!-- 4 -->
	<li>
~ASCII大小無視の値として~token `Upgrade^l を含んでいる，
`Connection$h ~header。
◎
A |Connection| header field that includes the token "Upgrade", treated as an ASCII case-insensitive value.
</li>
<!-- 5 -->
	<li>
`~base64に符号化-$された値であって，復号した結果が長さ 16 ~byteの値になる，
`Sec-WebSocket-Key^h ~header。
◎
A |Sec-WebSocket-Key| header field with a base64-encoded (see Section 4 of [RFC4648]) value that, when decoded, is 16 bytes in length.
</li>
<!-- 6 -->
	<li>
値 13 の
`Sec-WebSocket-Version^h ~header。
◎
A |Sec-WebSocket-Version| header field, with a value of 13.
</li>
<!-- 7 -->
	<li>
~optionで、 `Origin^h ~header。
この~headerは、すべての~browser~clientから送信される。
この~headerを欠く接続の試みは、~browser~clientからのものと解釈される~SHOULDでない。
◎
Optionally, an |Origin| header field. This header field is sent by all browser clients. A connection attempt lacking this header field SHOULD NOT be interpreted as coming from a browser client.
</li>
<!-- 8 -->
	<li>
~optionで、~clientの選好順に挙げられた，下位protocolを指示する値の~listを伴う，
`Sec-WebSocket-Protocol^h ~header。
<!-- ~speak -->
◎
Optionally, a |Sec-WebSocket-Protocol| header field, with a list of values indicating which protocols the client would like to speak, ordered by preference.
</li>
<!-- 9 -->
	<li>
~optionで、~clientの選好順に挙げられた，拡張を指示する値の~listを伴う，
`Sec-WebSocket-Extensions^h ~header。
この~headerの解釈については `9.1$secにて論じる。
◎
Optionally, a |Sec-WebSocket-Extensions| header field, with a list of values indicating which extensions the client would like to speak. The interpretation of this header field is discussed in Section 9.1.
</li>
<!-- 10 -->
	<li>
~optionで、~serverに向けて，~cookieを送信したり認証を要請する際に用いられる，他の~header。
未知の~headerは、 `HTTP$r に従って無視される。
◎
Optionally, other header fields, such as those used to send cookies or request authentication to a server. Unknown header fields are ignored, as per [RFC2616].
</li>
</ul>

			</section>
			<section id="section-4.2.2">
<h4 title="Sending the Server's Opening Handshake">4.2.2. ~serverによる~opening~handshakeの送信</h4>

<p>
~serverは、~clientが~serverへの~WebSocket接続を確立する際に，その接続を受容して, ~opening~handshakeを送信するためには、次の手続きを完了し~MUST：
◎
When a client establishes a WebSocket connection to a server, the server MUST complete the following steps to accept the connection and send the server's opening handshake.
</p>

<ol>
<!-- 1 -->
	<li>
接続が~HTTPS（ HTTP-over-TLS ）~portに対して生じたものである場合、接続を通じて~TLS~handshakeを遂行する。
これに失敗した場合（例えば，~clientが extended client hello
`server_name^l <!--  -->において~serverが~hostしない~host名を指示した場合）、接続を~closeする。
他の場合、接続における，それ以降の（~serverの~handshakeも含む）すべての通信は、暗号化された~tunnel `RFC5246$r を通して稼働させ~MUST。
◎
If the connection is happening on an HTTPS (HTTP-over-TLS) port, perform a TLS handshake over the connection. If this fails (e.g., the client indicated a host name in the extended client hello "server_name" extension that the server does not host), then close the connection; otherwise, all further communication for the connection (including the server's handshake) MUST run through the encrypted tunnel [RFC5246].
</li>
<!-- 2 -->
	<li>
~serverは、例えば `HTTP$r に述べられるように，対応する `WWW-Authenticate$h ~headerを伴う`応答~code$ `401$st を返すことにより，追加の~client認証を遂行できる。
◎
The server can perform additional client authentication, for example, by returning a 401 status code with the corresponding |WWW-Authenticate| header field as described in [RFC2616].
</li>
<!-- 3 -->
	<li>
~serverは、`応答~code$ `3xx$st を用いて，~clientを~redirectしても~MAY。
この段は、上述の認証~optionの段と伴に，その前後いずれにも生じ得ることに注意。
<!-- together with -->
◎
The server MAY redirect the client using a 3xx status code [RFC2616]. Note that this step can happen together with, before, or after the optional authentication step described above.
</li>
<!-- 4 -->
	<li>
<p>
次の情報を確定させる：
◎
Establish the following information:
</p>

		<dl class="defs">
			<dt>%生成元
◎
/origin/
</dt>
			<dd>
~clientからの~handshake内の `Origin^h ~headerは、接続を確立-中の~scriptの生成元を指示する。
生成元は~ASCIIに直列化され，小文字~化される。
~serverは、この情報を着信~接続を受容するかどうかの判断材料にしても~MAY。
~serverが生成元の妥当性を~~検証しない場合、どこからの接続も受容することになる。
この接続の受容を望まない場合、適切な~HTTP~error~code（例えば，`403$st `Forbidden^ph ）を返して，この節にて述べている~WebSocket~handshakeを中止し~MUST。
更なる詳細は `10$secを参照。
◎
The |Origin| header field in the client's handshake indicates the origin of the script establishing the connection. The origin is serialized to ASCII and converted to lowercase. The server MAY use this information as part of a determination of whether to accept the incoming connection. If the server does not validate the origin, it will accept connections from anywhere. If the server does not wish to accept this connection, it MUST return an appropriate HTTP error code (e.g., 403 Forbidden) and abort the WebSocket handshake described in this section. For more detail, refer to Section 10.
</dd>

			<dt>%~key
◎
/key/
</dt>
			<dd>
~clientからの~handshake内の `Sec-WebSocket-Key^h ~headerは、復号した結果の長さが 16 ~byteになるような，`~base64に符号化-$された値を与える。
~serverは、接続の受容を指示する~handshakeを作成するときに，この値を（符号化されたまま）利用する。
~serverには、この値を~base64から復号することは必要とされない。
◎
The |Sec-WebSocket-Key| header field in the client's handshake includes a base64-encoded value that, if decoded, is 16 bytes in length. This (encoded) value is used in the creation of the server's handshake to indicate an acceptance of the connection. It is not necessary for the server to base64-decode the |Sec-WebSocket-Key| value.
</dd>

			<dt>%~version
◎
/version/
</dt>
			<dd>
~clientからの~handshake内の `Sec-WebSocket-Version^h ~headerは、~clientが通信を試みている~WebSocket~Protocolの~versionを与える。
この~versionが~serverが解せる~versionに合致しない場合、~serverは、この節にて述べられる~WebSocket~handshakeを中止して，
適切な~HTTP~error~code（ `426$st `Upgrade Required^ph など）, および
~serverが解せる 1 つ以上の~versionを指示する
`Sec-WebSocket-Version^h ~headerを送信し~MUST。
◎
The |Sec-WebSocket-Version| header field in the client's handshake includes the version of the WebSocket Protocol with which the client is attempting to communicate. If this version does not match a version understood by the server, the server MUST abort the WebSocket handshake described in this section and instead send an appropriate HTTP error code (such as 426 Upgrade Required) and a |Sec-WebSocket-Version| header field indicating the version(s) the server is capable of understanding.
</dd>

			<dt>%~resource名
◎
/resource name/
</dt>
			<dd>
~serverから供される~serviceの識別子。
~serverが複数の~serviceを供する場合、値は［
~clientからの~handshake内の， `GET$hm ~methodの `request-target$P `HTTP$r
］内に所与の~resource名から導出されるべきである。
要請された~serviceが可用でない場合、~serverは、適切な~HTTP~error~code（ `404$st `Not Found^ph など）を送信して，~WebSocket~handshakeを中止し~MUST。
◎
An identifier for the service provided by the server. If the server provides multiple services, then the value should be derived from the resource name given in the client's handshake in the "Request-URI" [RFC2616] of the GET method. If the requested service is not available, the server MUST send an appropriate HTTP error code (such as 404 Not Found) and abort the WebSocket handshake.
</dd>

			<dt>%下位protocol
◎
/subprotocol/
</dt>
			<dd>
~serverにて利用できる下位protocolを表現する単独の値であるか, または null 。
選ばれる値は、［
~clientからの~handshake内の `Sec-WebSocket-Protocol^h ~headerの値
］の中から，~serverがこの接続に利用するつもりがある 1 つを（もしあれば）選択することにより、導出され~MUST。
~clientからの~handshakeがそのような~headerを有していないか, または~serverが~clientが要請した下位protocolのどれにも同意しない場合、受容-可能な値は ~NULL のみになる。
そのような~headerの不在は ~NULL 値と等価である（すなわち，~serverが示唆されたどの下位protocolにも同意しない場合、その応答に
`Sec-WebSocket-Protocol^h ~headerを返送しては~MUST_NOT）。
この目的においては、空~文字列は ~NULL 値と同じではなく，この~header用の合法な値ではない。
この~header値の~ABNFは `token$P であり，その定義は `HTTP$r にて与えられる。
◎
Either a single value representing the subprotocol the server is ready to use or null. The value chosen MUST be derived from the client's handshake, specifically by selecting one of the values from the |Sec-WebSocket-Protocol| field that the server is willing to use for this connection (if any). If the client's handshake did not contain such a header field or if the server does not agree to any of the client's requested subprotocols, the only acceptable value is null. The absence of such a field is equivalent to the null value (meaning that if the server does not wish to agree to one of the suggested subprotocols, it MUST NOT send back a |Sec-WebSocket-Protocol| header field in its response). The empty string is not the same as the null value for these purposes and is not a legal value for this field. The ABNF for the value of this header field is (token), where the definitions of constructs and rules are as given in [RFC2616].
</dd>

			<dt>%拡張~list
◎
/extensions/
</dt>
			<dd>
~serverにて利用できる~protocol~levelの拡張を表現する，~list（空にもなり得る）。
~serverが複数の拡張を~supportする場合、値は［
~clientからの~handshake内の `Sec-WebSocket-Extensions^h ~header値
］から 1 個~以上の値を選択することにより，導出され~MUST。
そのような~headerの不在は ~NULL 値と等価である。
この目的においては、空~文字列は ~NULL 値と同じではない。
~clientから~listされなかった拡張が~listされては~MUST_NOT。
これらの値をどう選択して解釈するべきかは `9.1$secにて論じる。
<!--  -->
◎
A (possibly empty) list representing the protocol-level extensions the server is ready to use. If the server supports multiple extensions, then the value MUST be derived from the client's handshake, specifically by selecting one or more of the values from the |Sec-WebSocket-Extensions| field. The absence of such a field is equivalent to the null value. The empty string is not the same as the null value for these purposes. Extensions not listed by the client MUST NOT be listed. The method by which these values should be selected and interpreted is discussed in Section 9.1.
</dd>
		</dl>

	</li>
<!-- 5 -->
	<li>
<p>
~serverは、着信~接続の受容を選ぶ場合、以下を指示する妥当な~HTTP応答で
返信し~MUST：
◎
If the server chooses to accept the incoming connection, it MUST reply with a valid HTTP response indicating the following.
</p>

		<ol>
		<!-- 1 -->
			<li>
`status-line$P には`応答~code$ `101$st を伴わせる。
その種の応答は、次のような~~形をとるであろう
⇒
`HTTP/1.1 101 Switching Protocols^l
◎
A Status-Line with a 101 response code as per RFC 2616 [RFC2616]. Such a response could look like "HTTP/1.1 101 Switching Protocols".
</li>
		<!-- 2 -->
			<li>
`Upgrade$h ~header
— その値には `websocket^l をあてがう。
◎
An |Upgrade| header field with value "websocket" as per RFC 2616 [RFC2616].
</li>
		<!-- 3 -->
			<li>
`Connection$h ~header
— その値には `Upgrade^l を含ませる。
◎
A |Connection| header field with value "Upgrade".
</li>
		<!-- 4 -->
			<li>
<p>
`Sec-WebSocket-Accept^h ~header
— その値には、［
上で定義した %~key から`~hashを構築-$した結果
］をあてがう。
◎
A |Sec-WebSocket-Accept| header field. The value of this header field is constructed by＼
</p>

<div class="p">
<p>
所与の %~nonce から
`~hashを構築-@
するときは：
</p>
				<ol>
					<li>
%~nonce に文字列 `258EAFA5-E914-47DA-95CA-C5AB0DC85B11^l を付加する。
</li>
					<li>
前~段の結果に対し，~SHA-1 ~hash（ 160 ~bit） `FIPS.180-3$r をとる（結果は長さ 20 の~byte列になる）。
</li>
					<li>
前~段の結果を`~base64に符号化-$した結果を返す。
</li>
				</ol>
◎
concatenating /key/, defined above in step 4 in Section 4.2.2, with the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", taking the SHA-1 hash of this concatenated value to obtain a 20-byte value and base64-encoding (see Section 4 of [RFC4648]) this 20-byte hash.
</div>

<p>
この~headerの~ABNF（ `HTTP$r による`~ABNF拡張$が利用される）は、次で定義される：
◎
The ABNF [RFC2616] of this header field is defined as follows:
</p>

<pre class="ABNF">
`Sec-WebSocket-Accept@P
      = `base64-value-non-empty$P
`base64-value-non-empty@P
      = (1*`base64-data$P [ `base64-padding$P ])
      | `base64-padding$P
`base64-data@P
      = 4`base64-character$P
`base64-padding@P
      = (2`base64-character$P "==")
      | (3`base64-character$P "=")
`base64-character@P
      = `ALPHA$P | `DIGIT$P | "+" | "/"
</pre>


<div class="example">
<p>
例えば、~clientからの~handshakeの
`Sec-WebSocket-Key^h ~headerの値が
`dGhlIHNhbXBsZSBub25jZQ==^l
であったなら、~serverは：
</p>

<ol>
	<li>
<p>
まず、文字列の形をとる~GUID
`258EAFA5-E914-47DA-95CA-C5AB0DC85B11^l
を付加して，次の文字列を形成する
⇒
`dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11^l
</p>

<p>
（この~GUID `RFC4122$r は、~WebSocket~Protocolを解さない~network端点からは利用されないものと見込まれている。）
</p>
	</li>
	<li>
次に、その~SHA-1 ~hashをとり，次の値を得る
⇒
`0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea^s
</li>
	<li>
最後に、この値を`~base64に符号化-$して，次の値を得る
⇒
`s3pPLMBiTxaQ9kYGzzhZRbK+xOo=^l
</li>
	<li>
結果の値が，
`Sec-WebSocket-Accept^h ~headerに返されることになる。
</li>
</ol>

◎
NOTE: As an example, if the value of the |Sec-WebSocket-Key| header field in the client's handshake were "dGhlIHNhbXBsZSBub25jZQ==", the server would append the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" to form the string "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11". The server would then take the SHA-1 hash of this string, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded, to give the value "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", which would be returned in the |Sec-WebSocket-Accept| header field.
</div>


			</li>
		<!-- 5 -->
			<li>
~optionで、
`Sec-WebSocket-Protocol^h ~header
— その値には、上で定義した %下位protocol をあてがう。
◎
Optionally, a |Sec-WebSocket-Protocol| header field, with a value /subprotocol/ as defined in step 4 in Section 4.2.2.
</li>
		<!-- 6 -->
			<li>
~optionで、
`Sec-WebSocket-Extensions^h ~header
— その値には、上で定義した %拡張~list をあてがう。
複数の拡張を利用する場合、
それらすべてを単独の `Sec-WebSocket-Extensions^h ~header内に~listすることも,
複数個の `Sec-WebSocket-Extensions^h ~headerに分割してあてがうこともできる。
◎
Optionally, a |Sec-WebSocket-Extensions| header field, with a value /extensions/ as defined in step 4 in Section 4.2.2. If multiple extensions are to be used, they can all be listed in a single |Sec-WebSocket-Extensions| header field or split between multiple instances of the |Sec-WebSocket-Extensions| header field.
</li>
		</ol>
	</li>
</ol>

<p>
これにより、~serverの~handshakeは完了する。
~serverが~WebSocket~handshakeを中止することなくこの手続きを完遂した時点から、~serverにおいて，~WebSocket接続は確立されたものと見なされ, `~OPEN状態$になる。
~serverは、この時点から~dataの送信-（および受信-）し始めてよい。
◎
This completes the server's handshake. If the server finishes these steps without aborting the WebSocket handshake, the server considers the WebSocket connection to be established and that the WebSocket connection is in the OPEN state. At this point, the server may begin sending (and receiving) data.
</p>

			</section>
		</section>
		<section id="section-4.3">
<h3 title="Collected ABNF for New Header Fields Used in Handshake">4.3. ~handshakeに用いられる新たな~headerの~ABNF総覧</h3>

<p>
この節では、
`HTTP$r による`~ABNF拡張$が利用される。
◎
This section is using ABNF syntax/rules from Section 2.1 of [RFC2616], including the "implied *LWS rule".
</p>

<p>
この節の~ABNFには、次の規約が用いられることに注意：
~ABNF規則の名前うち，一部のものは、対応する~header名に対応する。
その種の規則は、対応する~headerの値を表記する。
例えば，~ABNF規則 `Sec-WebSocket-Key^P は、
`Sec-WebSocket-Key^h ~headerの値の構文を記述する。
名前に "`-Client^P" 接尾辞を伴う~ABNF規則は、~clientから~serverへ向けて送信される要請~内に限り用いられる。
名前に "`-Server^P" 接尾辞を伴う~ABNF規則は、~serverから~clientへ向けて送信される応答~内に限り用いられる。
例えば，~ABNF規則 `Sec-WebSocket-Protocol-Client$P は、~clientから~serverに向けて送信される， `Sec-WebSocket-Protocol^h ~header値の構文を記述する。
◎
Note that the following ABNF conventions are used in this section. Some names of the rules correspond to names of the corresponding header fields. Such rules express values of the corresponding header fields, for example, the Sec-WebSocket-Key ABNF rule describes syntax of the |Sec-WebSocket-Key| header field value. ABNF rules with the "-Client" suffix in the name are only used in requests sent by the client to the server; ABNF rules with the "-Server" suffix in the name are only used in responses sent by the server to the client. For example, the ABNF rule Sec-WebSocket-Protocol-Client describes syntax of the |Sec-WebSocket-Protocol| header field value sent by the client to the server.
</p>

<p>
~clientは、次の新たな~headerを，~serverへの~handshakeにて送信できる：
◎
The following new header fields can be sent during the handshake from the client to the server:
</p>

<pre class="ABNF">
`Sec-WebSocket-Key@P
      = `base64-value-non-empty$P
`Sec-WebSocket-Extensions@P
      = `extension-list$P
`Sec-WebSocket-Protocol-Client@P
      = 1#`token$P
`Sec-WebSocket-Version-Client@P
      = `version$P

`base64-value-non-empty@P
      = (1*`base64-data$P [ `base64-padding$P ])
      | `base64-padding$P
`base64-data@P
      = 4`base64-character$P
`base64-padding@P
      = (2`base64-character$P "==")
      | (3`base64-character$P "=")
`base64-character@P
      = `ALPHA$P | `DIGIT$P | "+" | "/"
`extension-list@P
      = 1#`extension$P
`extension@P
      = `extension-token$P *( ";" `extension-param$P )
`extension-token@P
      = `registered-token$P
`registered-token@P
      = `token$P

`extension-param@P
      = `token$P [ "=" (`token$P | `quoted-string$P) ]
      ; <span class="comment">
`quoted-string$P 構文を利用する場合、それによる~escape復元後の値は `token$P ~ABNFに適合し~MUST
◎
When using the quoted-string syntax variant, the value after quoted-string unescaping MUST conform to the 'token' ABNF.
</span>

`NZDIGIT@P
      = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
`version@P
      = `DIGIT$P
      | (`NZDIGIT$P `DIGIT$P)
      | ("1" `DIGIT$P `DIGIT$P)
      | ("2" `DIGIT$P `DIGIT$P)
      ; <span class="comment">
0 〜 255 の範囲に制限され, かつ先頭の 0 は不可。
◎
Limited to 0-255 range, with no leading zeros
</span>
</pre>

<p>
~serverは、次の新たな~headerを，~clientへの~handshakeにて送信できる：
◎
The following new header fields can be sent during the handshake from the server to the client:
</p>

<pre class="ABNF">
`Sec-WebSocket-Extensions@P
      = `extension-list$P
`Sec-WebSocket-Accept@P
      = `base64-value-non-empty$P
`Sec-WebSocket-Protocol-Server@P
      = `token$P
`Sec-WebSocket-Version-Server@P
      = 1#`version$P
</pre>

		</section>
		<section id="section-4.4">
<h3 title="Supporting Multiple Versions of WebSocket Protocol">4.4. 複数の~versionの~WebSocket~Protocolの~support法</h3>

<p>
この節では、~clientと~serverにおいて，複数の~versionの~WebSocket~Protocolを~supportするための手引きを供する。
◎
This section provides some guidance on supporting multiple versions of the WebSocket Protocol in clients and servers.
</p>

<p>
~clientは、~WebSocket~version告知~能力（
`Sec-WebSocket-Version^h ~header）を利用して，選好する~WebSocket~Protocolの~versionを（~clientで最新に~supportされるとする必要はない）初期~時に要請できる。
~serverが要請された~versionを~supportし, かつ
~handshake~messageの他の部分も妥当であれば、~serverはその~versionを受容することになる。<!--  -->
~serverが要請された~versionを~supportしない場合、利用するつもりがあるすべての~versionを包含している
`Sec-WebSocket-Version^h ~header（または複数の
`Sec-WebSocket-Version^h ~header）により，応答し~MUST。
このとき，~clientは、告知された~versionのいずれかを~supportするならば，新たな~version値を用いて~WebSocket~handshakeを繰り返すことができる。
◎
Using the WebSocket version advertisement capability (the |Sec-WebSocket-Version| header field), a client can initially request the version of the WebSocket Protocol that it prefers (which doesn't necessarily have to be the latest supported by the client). If the server supports the requested version and the handshake message is otherwise valid, the server will accept that version. If the server doesn't support the requested version, it MUST respond with a |Sec-WebSocket-Version| header field (or multiple |Sec-WebSocket-Version| header fields) containing all versions it is willing to use. At this point, if the client supports one of the advertised versions, it can repeat the WebSocket handshake using a new version value.
</p>

<div class="example">
<p>
上述の~version折衝の例を示す：
◎
The following example demonstrates version negotiation described above:
</p>

<pre>
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
...
Sec-WebSocket-Version: 25
</pre>


<p>
~serverからの応答は次のような~~形をとり得る：
◎
The response from the server might look as follows:
</p>

<pre>
HTTP/1.1 400 Bad Request
...
Sec-WebSocket-Version: 13, 8, 7
</pre>

<p>
前記の~serverからの応答は次のような~~形もとり得ることに注意：
◎
Note that the last response from the server might also look like:
</p>

<pre>
HTTP/1.1 400 Bad Request
...
Sec-WebSocket-Version: 13
Sec-WebSocket-Version: 8, 7
</pre>

<p>
~clientは、今度は，~version 13 に適合する~handshakeを繰り返す：
◎
The client now repeats the handshake that conforms to version 13:
</p>

<pre>
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
...
Sec-WebSocket-Version: 13
</pre>

</div>


		</section>
	</section>
	<section id="section-5">
<h2 title="Data Framing">5. ~dataの~frame法</h2>

		<section id="section-5.1">
<h3 title="Overview">5.1. 概観</h3>

<p>
~WebSocket~Protocolにおいては、~dataは一連の~frameを用いて伝送される。
（透過型~proxyなどの）~network中継点から混同されるのを避けるため, および `10.3$secにて更に論じる~security上の理由から、~clientは，~serverに向けて送信するすべての~frameを~maskし~MUST（詳細は `5.3$secを見よ）。
（~mask~~処理は、~WebSocket~Protocolが~TLSを通じて稼働していようがいまいが行われることに注意。）
~serverは、~maskされていない~frameを受信した際には，接続を~closeし~MUST。
この場合，~serverは、 `7.4.1$secの定義に従って，~status~code `1002$st （~protocol~error）を伴う `Close$fr ~frameを送信しても~MAY。
~serverは、~clientに送信するどの~frameも~maskしては~MUST_NOT。
~clientは、~maskされた~frameを検出したときには，接続を~closeし~MUST。
この場合、`~status~code$ `1002$st （~protocol~error）を用いても~MAY。
（これらの規則は、将来~仕様においては，緩められ得る。）
◎
In the WebSocket Protocol, data is transmitted using a sequence of frames. To avoid confusing network intermediaries (such as intercepting proxies) and for security reasons that are further discussed in Section 10.3, a client MUST mask all frames that it sends to the server (see Section 5.3 for further details). (Note that masking is done whether or not the WebSocket Protocol is running over TLS.) The server MUST close the connection upon receiving a frame that is not masked. In this case, a server MAY send a Close frame with a status code of 1002 (protocol error) as defined in Section 7.4.1. A server MUST NOT mask any frames that it sends to the client. A client MUST close a connection if it detects a masked frame. In this case, it MAY use the status code 1002 (protocol error) as defined in Section 7.4.1. (These rules might be relaxed in a future specification.)
</p>

<p>
~frame法~protocolの基底部は、`~opcode$による~frameの種別, および~payloadの長さを定義し，`拡張~data$と`~app~data$（および，この 2 つを併せた`~payload~data$）が占める指名域を定義する。
一部の~bitと`~opcode$は、~protocolの将来の発展~用に予約-済みである。
◎
The base framing protocol defines a frame type with an opcode, a payload length, and designated locations for "Extension data" and "Application data", which together define the "Payload data". Certain bits and opcodes are reserved for future expansion of the protocol.
</p>

<p>
`~data~frame$は、~clientと~serverのどちらからも, ［
~opening~handshakeの完了から その端点が `Close$fr ~frameを送信し終えるまで
］のいつでも，伝送されて~MAY。
◎
A data frame MAY be transmitted by either the client or the server at any time after opening handshake completion and before that endpoint has sent a Close frame (Section 5.5.1).
</p>

		</section>
		<section id="section-5.2">
<h3 title="Base Framing Protocol">5.2. ~frame法~protocolの基底部</h3>

<p>
~data転送~part用の伝送路~形式は、この節にて~ABNF`RFC5234$r を用いて詳細に述べられる。
（この文書の他の節と異なり，この節の~ABNFは~bitの~groupを対象にしていることに注意。
各~groupの~bit長は~comment内に指示される。
伝送路~上に符号化される際の最上位~bitは、~ABNFにおいては左端に位置する。）
~frame法のより高次の概観は次の図により与えられる。
この図とこの節の以下で指定される~ABNFとの間に不一致がある場合、この図の方が優先される。
◎
This wire format for the data transfer part is described by the ABNF [RFC5234] given in detail in this section. (Note that, unlike in other sections of this document, the ABNF in this section is operating on groups of bits. The length of each group of bits is indicated in a comment. When encoded on the wire, the most significant bit is the leftmost in the ABNF). A high-level overview of the framing is given in the following figure. In a case of conflict between the figure below and the ABNF specified later in this section, the figure is authoritative.
</p>

<div style="overflow:auto;">
<table id="framing-table">

<thead><tr>
<th colspan="10">0
<th colspan="10">1
<th colspan="10">2
<th colspan="2">3

<tr>
<th>0<th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9
<th>0<th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9
<th>0<th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9
<th>0<th>1
</thead>

<tbody><tr>
<td><a href="#data-FIN">F<br>I<br>N</a>
<td><a href="#data-RSV">R<br>S<br>V<br>1</a>
<td><a href="#data-RSV">R<br>S<br>V<br>2</a>
<td><a href="#data-RSV">R<br>S<br>V<br>3</a>
<td colspan="4">`~opcode$<br>(4 bit)
<td><a href="#data-MASK">M<br>A<br>S<br>K</a>
<td colspan="7" style="border-right-style: dashed">`~payload長さ$<br>(7 bit)
<td colspan="16" style="border-style: solid dashed solid none;">延長~payload長さ<br>(16/64 bit)<br>
（~payload長さ == 126/127 の場合）

<tr><td colspan="32" style="border-style: solid none solid dashed;">延長~payload長さ（続き），（~payload長さ == 

<tr><td colspan="16" style="border-left-style: none">127 の場合）
<td colspan="16" style="border-right-style: none">`~mask用~key$（`~mask$が 1 の場合）

<tr><td colspan="16" style="border-left-style: none">`~mask用~key$（続き）
<td colspan="16" style="border-right-style: none">`~payload~data$

<tr><td colspan="32" style="border-style: none; line-height:1.7; background:transparent;">…

<tr><td colspan="32" style="border-style: solid none solid none;">Payload~data（続き）

<tr><td colspan="32" style="border-style: none; line-height:1.7; background:transparent;">…

<tr><td colspan="24" style="border-left-style: none; border-right-style: none;">Payload~data（続き）
<td colspan="8" style="border-style: none; background:transparent;">…

</tbody></table>
</div>

<pre style="line-height:1">
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
</pre>

<dl class="defs">

	<dt>`~FIN@： 1 ~bit
◎
FIN:  1 bit
</dt>
	<dd>
~message内の最後の断片である（ 1 の場合）かどうかを指示する。
最初の断片が最後の断片になっていても~MAY。
◎
Indicates that this is the final fragment in a message. The first fragment MAY also be the final fragment.
</dd>

	<dt>
3 個の
`予約-済み~bit@
— RSV1, RSV2, RSV3： 各 1 ~bit 
◎
RSV1, RSV2, RSV3:  1 bit each
</dt>
	<dd>
非 0 値に対する意味を定義する拡張が折衝されていない限り、 0 にされ~MUST。
非 0 値が受信されたにも関わらず，折衝されたどの拡張もそのような非 0 値の意味を定義していない場合、受信している端点は，`~WebSocket接続を失敗させ$~MUST。
◎
MUST be 0 unless an extension is negotiated that defines meanings for non-zero values. If a nonzero value is received and none of the negotiated extensions defines the meaning of such a nonzero value, the receiving endpoint MUST _Fail the WebSocket Connection_.
</dd>

	<dt>`~opcode@
： 4 ~bit
◎
Opcode:  4 bits
</dt>
	<dd>
`~payload~data$の解釈を定義する。
未知の~opcodeが受信された場合、受信している端点は，`~WebSocket接続を失敗させ$~MUST。
◎
Defines the interpretation of the "Payload data". If an unknown opcode is received, the receiving endpoint MUST _Fail the WebSocket Connection_. The following values are defined.
</dd>

	<dd>
<p>
次の値が定義されている：
</p>

<ul>
	<li>
`0^X は継続~frameを表す
◎
%x0 denotes a continuation frame
</li>
	<li>
`1^X は~text~frameを表す
◎
%x1 denotes a text frame
</li>
	<li>
`2^X は~binary~frameを表す
◎
%x2 denotes a binary frame
</li>
	<li>
`3^X 〜 `7^X は追加の`~data~frame$用に予約-済み
◎
%x3-7 are reserved for further non-control frames
</li>
	<li>
`8^X は接続の~closeを表す
◎
%x8 denotes a connection close
</li>
	<li>
`9^X は~pingを表す
◎
%x9 denotes a ping
</li>
	<li>
`A^X は~pongを表す
◎
%xA denotes a pong
</li>
	<li>
`B^X 〜 `F^X は追加の`制御~frame$用に予約-済み
◎
%xB-F are reserved for further control frames
</li>
</ul>

	</dd>

	<dt>`~mask@： 1 ~bit
◎
Mask:  1 bit
</dt>
	<dd>
`~payload~data$が~maskされているかどうかを定義する。
1 にされている場合、`~mask用~key$内に~mask用~keyが在り、 `5.3$secに従って，
`~payload~data$の~maskを解く際に用いられる。
~clientから~serverへ送信される すべての~frameにおいて、この~bitは 1 にされる。
◎
Defines whether the "Payload data" is masked. If set to 1, a masking key is present in masking-key, and this is used to unmask the "Payload data" as per Section 5.3. All frames sent from client to server have this bit set to 1.
</dd>

	<dt>`~payload長さ@
： 7, 7+16, 7+64 ~bitのいずれか
◎
Payload length:  7 bits, 7+16 bits, or 7+64 bits
</dt>
	<dd>
~byte数による `~payload~data$の長さ：
0 〜 125 の場合、それがそのまま~payloadの長さになる。
126 の場合、後続の 2 ~byteが 16 ~bit無符号~整数に解釈されて~payloadの長さになる。
127 の場合、後続の 8 ~byteが 64 ~bit無符号~整数（最上位~bitは 0 で~MUST）に解釈されて~payloadの長さになる。
複~byteによる長さ数量は~network~byte順序で表記される。<!--  -->
いかなる場合も、長さを符号化するときには最小の~byte数が用いられ~MUSTことに注意。
例えば， 124 ~byteの文字列に対し、その長さが 126, 0, 124 の並びに符号化されることはない。
~payloadの長さは、`拡張~data$の長さと`~app~data$の長さの和である。
`拡張~data$の長さは 0 もあり得る。
この場合の~payloadの長さは`~app~data$の長さになる。
◎
The length of the "Payload data", in bytes: if 0-125, that is the payload length. If 126, the following 2 bytes interpreted as a 16-bit unsigned integer are the payload length. If 127, the following 8 bytes interpreted as a 64-bit unsigned integer (the most significant bit MUST be 0) are the payload length. Multibyte length quantities are expressed in network byte order. Note that in all cases, the minimal number of bytes MUST be used to encode the length, for example, the length of a 124-byte-long string can't be encoded as the sequence 126, 0, 124. The payload length is the length of the "Extension data" + the length of the "Application data". The length of the "Extension data" may be zero, in which case the payload length is the length of the "Application data".
</dd>

	<dt>`~mask用~key@
： 0 ~byteまたは 4 ~byte
◎
Masking-key:  0 or 4 bytes
</dt>
	<dd>
~clientから~serverへ送信されるすべての~frameは、~frameの中に包含された 32 ~bit値により~maskされる。
~mask~bitが 1 にされている場合、この~fieldが在る。
~mask~bitが 0 にされている場合、この~fieldは無い。
~clientから~serverへの~mask法についての詳細は `5.3$secを見よ。
◎
All frames sent from the client to the server are masked by a 32-bit value that is contained within the frame. This field is present if the mask bit is set to 1 and is absent if the mask bit is set to 0. See Section 5.3 for further information on client-to-server masking.
</dd>

	<dt>`~payload~data@
◎
Payload data:  (x+y) bytes
</dt>
	<dd>
`~payload~data$は、`拡張~data$と`~app~data$を連結したものとして定義される。
◎
The "Payload data" is defined as "Extension data" concatenated with "Application data".
</dd>

	<dt>`拡張~data@
◎
Extension data:  x bytes
</dt>
	<dd>
`拡張~data$は、拡張が折衝されていない限り， 0 ~byteになる。
いずれにせよ、その長さは~payloadの長さ以下になる。
どの拡張に対しても、`拡張~data$の長さ, またはその計算-方法が指定され~MUSTことに加え、~opening~handshakeの間に`拡張~data$をどう利用するかが折衝され~MUST。
◎
The "Extension data" is 0 bytes unless an extension has been negotiated. Any extension MUST specify the length of the "Extension data", or how that length may be calculated, and how the extension use MUST be negotiated during the opening handshake. If present, the "Extension data" is included in the total payload length.
</dd>

	<dt>`~app~data@
◎
Application data:  y bytes
</dt>
	<dd>
`拡張~data$の後の~frameの残りの部分を占める任意の~data。
その長さは、`~payload~data$の長さから`拡張~data$の長さを引いた結果に等しい。
◎
Arbitrary "Application data", taking up the remainder of the frame after any "Extension data". The length of the "Application data" is equal to the payload length minus the length of the "Extension data".
</dd>

</dl>

<p>
~frame法~protocolの基底部は、次の~ABNF`RFC5234$r により形式的に定義される。
この~dataの表現は~binaryであり，~ASCII文字でないことに注意。
したがって，値 `0^X または `1^X をとる長さ  1 ~bitの~fieldは、~ASCII符号化方式（文字 `0^l または `1^l ）による全部的~byte（~octet）ではなく，値 0 または 1 をとる単独の~bitで表現される。
値 `0^X 〜 `F^X をとる長さ  4 ~bitの~fieldもまた、これらの値をとる~ASCII文字や全部的~byte（~octet）では<em>なく</em>， 4 ~bitで表現される。
`RFC5234$r は、文字~符号化方式を指定しない：
◎
The base framing protocol is formally defined by the following ABNF [RFC5234]. It is important to note that the representation of this data is binary, not ASCII characters. As such, a field with a length of 1 bit that takes values %x0 / %x1 is represented as a single bit whose value is 0 or 1, not a full byte (octet) that stands for the characters "0" or "1" in the ASCII encoding. A field with a length of 4 bits with values between %x0-F again is represented by 4 bits, again NOT by an ASCII character or full byte (octet) with these values. [RFC5234] does not specify a character encoding:
</p>

<blockquote style="font-style:italic;"><p >
“終端値の並び（ string ）に解決される規則は、文字の列（ characters ）と呼ばれることがある。
~ABNFにおいては、各~文字は単なる非負~整数である。
ある種の文脈においては、値から文字集合（~ASCIIなど）への特定の写像（符号化方式）が指定されることになる。”
◎
"Rules resolve into a string of terminal values, sometimes called characters. In ABNF, a character is merely a non-negative integer. In certain contexts, a specific mapping (encoding) of values into a character set (such as ASCII) will be specified."
</p></blockquote>

<p>
ここで指定される符号化方式は、各~終端値が符号化される際の~bit数が，各~fieldごとに異なり得るものとして指定される、~binary符号化方式である。
◎
Here, the specified encoding is a binary encoding where each terminal value is encoded in the specified number of bits, which varies for each field.
</p>

<pre class="ABNF">
`ws-frame@P
       = `frame-fin$P      ; `長さ 1 ~bit^cme
         `frame-rsv1$P     ; `長さ 1 ~bit^cme
         `frame-rsv2$P     ; `長さ 1 ~bit^cme
         `frame-rsv3$P     ; `長さ 1 ~bit^cme
         `frame-opcode$P   ; `長さ 4 ~bit^cme
         `frame-masked$P   ; `長さ 1 ~bit^cme
         `frame-payload-length$P  ; `長さ 7, 7+16, 7+64 ~bitいずれか^cme
         [ `frame-masking-key$P ] ; `長さ 32 ~bit^cme
         `frame-payload-data$P    ; `長さ 8 の整数倍~bit^cme

`frame-fin@P
      = `%x0^_ ; `この~messageに後続する~frameがある^cme
      / `%x1^_ ; `この~messageの最後の~frameである^cme
      ; `長さ 1 ~bit^cme

`frame-rsv1@P
      = `%x0^_ / `%x1^_
      ; `長さ 1 ~bit^cme
`frame-rsv2@P
      = `%x0^_ / `%x1^_
      ; `長さ 1 ~bit^cme
`frame-rsv3@P
      = `%x0^_ / `%x1^_
      ; `長さ 1 ~bit^cme
      ; `いずれも，拡張が折衝されていない限り 0 にされ~MUST^cme

`frame-opcode@P
      = `frame-opcode-non-control$P
      / `frame-opcode-control$P
      / `frame-opcode-cont$P
      ; `長さ 4 ~bit^cme

`frame-opcode-cont@P
      = `%x0^_
      ; `継続~frame^cme
      ; `長さ 1 ~bit^cme

`frame-opcode-non-control@P
      = `%x1^_ ; `~text~frame^cme
      / `%x2^_ ; `~binary~frame^cme
      / `%x3-7^_ ; <span class="comment">更なる`~data~frame$用に予約-済み</span>
      ; `長さ 4 ~bit^cme

`frame-opcode-control@P
      = `%x8^_ ; `接続の~close^cme
      / `%x9^_ ; `ping^cme
      / `%xA^_ ; `pong^cme
      / `%xB-F^_ ; `更なる制御~frame用に予約-済み^cme
      ; `長さ 4 ~bit^cme

`frame-masked@P
      = `%x0^_ ; <span class="comment">~frameは~maskされてない，`frame-masking-key$P は無い</span>
      / `%x1^_ ; <span class="comment">~frameは~mask済み，`frame-masking-key$P は在る</span>
      ; `長さ 1 ~bit^cme

`frame-payload-length@P
      = ( `%x00-7D^_ )   ; `長さ 7 ~bit^cme
      / ( `%x7E^_ `frame-payload-length-16$P )  ; `長さ 7+16 ~bit^cme
      / ( `%x7F^_ `frame-payload-length-63$P )  ; `長さ 7+64 ~bit^cme

`frame-payload-length-16@P
      = `%x0000-FFFF^_ 
      ; `長さ 16 ~bit^cme

`frame-payload-length-63@P
      = `%x0000000000000000-7FFFFFFFFFFFFFFF^_
      ; `長さ 64 ~bit^cme

`frame-masking-key@P
      = 4( `%x00-FF^_ )
      ; <span class="comment">在るのは `frame-masked^P が 1 のときに限る</span>
      ; `長さ 32 ~bit^cme

`frame-payload-data@P
      = (`frame-masked-extension-data$P `frame-masked-application-data$P)
      ; <span class="comment">`frame-masked^P が 1 のとき</span>
      / (`frame-unmasked-extension-data$P `frame-unmasked-application-data$P)
      ; <span class="comment">`frame-masked^P が 0 のとき</span>

`frame-masked-extension-data@P
      = *( `%x00-FF^_ )
      ; `将来の拡張~用に予約-済み^cme
      ; `長さ 8 の整数倍~bit^cme

`frame-masked-application-data@P
      = *( `%x00-FF^_ )
      ; `長さ 8 の整数倍~bit^cme

`frame-unmasked-extension-data@P
      = *( `%x00-FF^_ )
      ; `将来の拡張~用に予約-済み^cme
      ; `長さ 8 の整数倍~bit^cme

`frame-unmasked-application-data@P
      = *( `%x00-FF^_ )
      ; `長さ 8 の整数倍~bit^cme
</pre>

<!-- 

    ws-frame                = frame-fin           ; 1 bit in length
                              frame-rsv1          ; 1 bit in length
                              frame-rsv2          ; 1 bit in length
                              frame-rsv3          ; 1 bit in length
                              frame-opcode        ; 4 bits in length
                              frame-masked        ; 1 bit in length
                              frame-payload-length   ; either 7, 7+16,
                                                     ; or 7+64 bits in
                                                     ; length
                              [ frame-masking-key ]  ; 32 bits in length
                              frame-payload-data     ; n*8 bits in
                                                     ; length, where
                                                     ; n >= 0

    frame-fin               = %x0 ; more frames of this message follow
                            / %x1 ; final frame of this message
                                  ; 1 bit in length

    frame-rsv1              = %x0 / %x1
                              ; 1 bit in length, MUST be 0 unless
                              ; negotiated otherwise

    frame-rsv2              = %x0 / %x1
                              ; 1 bit in length, MUST be 0 unless
                              ; negotiated otherwise

    frame-rsv3              = %x0 / %x1
                              ; 1 bit in length, MUST be 0 unless
                              ; negotiated otherwise

    frame-opcode            = frame-opcode-non-control /
                              frame-opcode-control /
                              frame-opcode-cont

    frame-opcode-cont       = %x0 ; frame continuation

    frame-opcode-non-control= %x1 ; text frame
                            / %x2 ; binary frame
                            / %x3-7
                            ; 4 bits in length,
                            ; reserved for further non-control frames

    frame-opcode-control    = %x8 ; connection close
                            / %x9 ; ping
                            / %xA ; pong
                            / %xB-F ; reserved for further control
                                    ; frames
                                    ; 4 bits in length

    frame-masked            = %x0
                            ; frame is not masked, no frame-masking-key
                            / %x1
                            ; frame is masked, frame-masking-key present
                            ; 1 bit in length

    frame-payload-length    = ( %x00-7D )
                            / ( %x7E frame-payload-length-16 )
                            / ( %x7F frame-payload-length-63 )
                            ; 7, 7+16, or 7+64 bits in length,
                            ; respectively

    frame-payload-length-16 = %x0000-FFFF ; 16 bits in length

    frame-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF
                            ; 64 bits in length

    frame-masking-key       = 4( %x00-FF )
                              ; present only if frame-masked is 1
                              ; 32 bits in length

    frame-payload-data      = (frame-masked-extension-data
                               frame-masked-application-data)
                            ; when frame-masked is 1
                              / (frame-unmasked-extension-data
                                frame-unmasked-application-data)
                            ; when frame-masked is 0

    frame-masked-extension-data     = *( %x00-FF )
                            ; reserved for future extensibility
                            ; n*8 bits in length, where n >= 0

    frame-masked-application-data   = *( %x00-FF )
                            ; n*8 bits in length, where n >= 0

    frame-unmasked-extension-data   = *( %x00-FF )
                            ; reserved for future extensibility
                            ; n*8 bits in length, where n >= 0

    frame-unmasked-application-data = *( %x00-FF )
                            ; n*8 bits in length, where n >= 0
-->

		</section>
		<section id="section-5.3">
<h3 title="Client-to-Server Masking">5.3. ~clientから~serverへの~mask法</h3>

<p>
~maskされた~frameにおける `frame-masked$P ~fieldは、
`5.2$secの定義に従って， 1 にされてい~MUST。
◎
A masked frame MUST have the field frame-masked set to 1, as defined in Section 5.2.
</p>

<p>
`5.2$secにて定義したように、~mask用~keyは，その~frame内に `frame-masking-key$P として完全に包含される。
それは、同じ節で`~payload~data$として定義された `frame-payload-data$P を~maskするために用いられる。
◎
The masking key is contained completely within the frame, as defined in Section 5.2 as frame-masking-key. It is used to mask the "Payload data" defined in the same section as frame-payload-data, which includes "Extension data" and "Application data".
</p>

<p>
~mask用~keyは、~clientにより~randomに選ばれる 32 ~bit値である。
~maskされた~frameを準備する際には、~clientは， 32 ~bit値の集合から 新規に~mask用~keyを取り出さ~MUST。
~mask用~keyは予測-不能になる必要がある。
したがって、~mask用~keyは，平均情報量（ entropy ）の強い源から導出され~MUSTことに加え、所与の~frame用の~mask用~keyから, 後続の~frame用の~mask用~keyが，~serverや~proxyから容易に予測できては~MUST_NOT。
~mask用~keyの予測-不能性は、悪意的な~appの作者が伝送路~上に現れる~byteを選定できなくするために，本質的である。
~securityに敏感な~appにとり，情報量の源として相応しいとされるものについては、 `RFC4086$r にて論じられている。
<!--  -->
◎
The masking key is a 32-bit value chosen at random by the client. When preparing a masked frame, the client MUST pick a fresh masking key from the set of allowed 32-bit values. The masking key needs to be unpredictable; thus, the masking key MUST be derived from a strong source of entropy, and the masking key for a given frame MUST NOT make it simple for a server/proxy to predict the masking key for a subsequent frame. The unpredictability of the masking key is essential to prevent authors of malicious applications from selecting the bytes that appear on the wire. RFC 4086 [RFC4086] discusses what entails a suitable source of entropy for security-sensitive applications.
</p>

<p>
~mask法は `~payload~data$の長さには影響しない。
~mask済み~dataから~maskされていない~dataへ変換するときも,
その逆へ変換するときも、同じ~algoが適用される
— それは、［
次の等式を満たす, かつ元の~dataと同じ長さの，結果の~data
］を返す
⇒
結果の~data[ %i ] ~EQ 元の~data[ %i ] xor %~key[ %i mod 4 ]
◎
The masking does not affect the length of the "Payload data". To convert masked data into unmasked data, or vice versa, the following algorithm is applied. The same algorithm applies regardless of the direction of the translation, e.g., the same steps are applied to mask the data as to unmask the data.
</p>

<div class="p">
<p>
— ここで：
</p>
<ul>
	<li>
%~key は ~mask用~key。
</li>
	<li>
%i は 0 以上, 元の~dataの長さ未満の整数
</li>
	<li>
~octet列 %A に対する %A[ %i ] は、
%A の先頭から %i 番（ 0 番から数える）の~octetを表す。
</li>
	<li>
xor は 排他的論理和を表す。
</li>
	<li>
mod は 剰余演算を表す。
</li>
</ul>
◎
Octet i of the transformed data ("transformed-octet-i") is the XOR of octet i of the original data ("original-octet-i") with octet at index i modulo 4 of the masking key ("masking-key-octet-j"):
◎
j                   = i MOD 4
transformed-octet-i = original-octet-i XOR masking-key-octet-j
</div>

<p>
~frame法における `frame-payload-length$P により指示される~payloadの長さは、~mask用~keyの長さを<em>含まない</em>。
それは、 `~payload~data$の長さであり，~mask用~keyに後続する~byteの個数である。
◎
The payload length, indicated in the framing as frame-payload-length, does NOT include the length of the masking key. It is the length of the "Payload data", e.g., the number of bytes following the masking key.
</p>

		</section>
		<section id="section-5.4">
<h3 title="Fragmentation">5.4. 断片化</h3>

<p>
断片化の第一の目的は、~messageが開始される際に，~messageの~bufferを要することなく，未知~sizeの~messageを送信できるようにする所にある。
仮に~messageを断片化できないとした場合、端点は，最初の~byteが送信される前にその長さを数え上げるため, ~message全体を~bufferしなければならなくなる。
断片化が可能であれば、~serverや中継点は、~bufferを適度な~sizeにした上で，~bufferが満杯になり次第, 断片を~networkに書き出せるようになる。
◎
The primary purpose of fragmentation is to allow sending a message that is of unknown size when the message is started without having to buffer that message. If messages couldn't be fragmented, then an endpoint would have to buffer the entire message so its length could be counted before the first byte is sent. With fragmentation, a server or intermediary may choose a reasonable size buffer and, when the buffer is full, write a fragment to the network.
</p>

<p>
断片化の第二の利用事例は、多重化にある。
巨大な~messageを 1 個の論理~channel上に流して，出力~channelを占有させるのは好ましくないので。
<!--  -->
多重化においては、出力~channelの共有を適化できるように，~messageをより小さな断片に自由に分割できる必要がある。
（この文書では多重化~拡張については述べられないことに注意。）
◎
A secondary use-case for fragmentation is for multiplexing, where it is not desirable for a large message on one logical channel to monopolize the output channel, so the multiplexing needs to be free to split the message into smaller fragments to better share the output channel. (Note that the multiplexing extension is not described in this document.)
</p>

<p>
拡張から特に指定されない限り，~frame【断片~化のされ方】には意味論はない。
中継点は、拡張が~client↔~server間で折衝されていない場合、あるいは何らかの拡張が折衝されていても，中継点が 折衝されているすべての拡張について解せる, かつ これらの拡張が在る下において~frameの合併-／分割-方法を知っている場ならば、それを行い得る。
このことから、拡張の不在の下では，送信側と受信側は, 特定の~frame境界の有無に依存してはならないことになる。
◎
Unless specified otherwise by an extension, frames have no semantic meaning. An intermediary might coalesce and/or split frames, if no extensions were negotiated by the client and the server or if some extensions were negotiated, but the intermediary understood all the extensions negotiated and knows how to coalesce and/or split frames in the presence of these extensions. One implication of this is that in absence of extensions, senders and receivers must not depend on the presence of specific frame boundaries.
</p>

<p>
次の規則が断片化に適用される：
◎
The following rules apply to fragmentation:
</p>

<ul>
	<li>
断片化されていない~messageは、`~FIN$~bitは 1 にされ, `~opcode$は 0 以外にされた，単独の~frameからなる。
◎
An unfragmented message consists of a single frame with the FIN bit set (Section 5.2) and an opcode other than 0.
</li>
	<li>
<p>
断片化された~messageは、次に与える複数の~frameからなる：
◎
A fragmented message consists of＼
</p>
		<ol>
			<li>
`~FIN$~bitは 0 にされ, `~opcode$は 0 以外にされた，
1 個の~frameから始まる
◎
a single frame with the FIN bit clear and an opcode other than 0,＼
</li>
			<li>
`~FIN$~bitは 0 にされ, `~opcode$は 0 にされた，
0 個~以上の~frameが後続する。
◎
followed by zero or more frames with the FIN bit clear and the opcode set to 0,＼
</li>
			<li>
`~FIN$~bitは 1 にされ, `~opcode$は 0 にされた，
1 個の~frameで終了する。
◎
and terminated by a single frame with the FIN bit set and an opcode of 0.＼
</li>
		</ol>

<p>
断片化された~messageは、概念的には、断片の~payloadを順に連結した~payloadを持つ，単独のより大きな~messageと等価である。
しかしながら，拡張が在る下では、拡張が`拡張~data$の解釈を定義するので，これは成り立たない。
例えば、`拡張~data$が最初の断片の始めのみに在って，後続の断片にも適用されるかもしれないし、それぞれの断片ごとに，その断片のみに適用される`拡張~data$が在るかもしれない。
◎
A fragmented message is conceptually equivalent to a single larger message whose payload is equal to the concatenation of the payloads of the fragments in order; however, in the presence of extensions, this may not hold true as the extension defines the interpretation of the "Extension data" present. For instance, "Extension data" may only be present at the beginning of the first fragment and apply to subsequent fragments, or there may be "Extension data" present in each of the fragments that applies only to that particular fragment.＼
</p>

<p class="example">
`拡張~data$が不在の下での断片化の例：
3 個の断片として送信される~text~messageにおいては、
1 個目の断片は`~opcode$は 1 に, `~FIN$~bitは 0 にされ，
2 個目の断片は`~opcode$は 0 に, `~FIN$~bitは 0 にされ，
3 個目の断片は`~opcode$は 0 に, `~FIN$~bitは 1 にされることになる。
◎
In the absence of "Extension data", the following example demonstrates how fragmentation works.
◎
EXAMPLE: For a text message sent as three fragments, the first fragment would have an opcode of 0x1 and a FIN bit clear, the second fragment would have an opcode of 0x0 and a FIN bit clear, and the third fragment would have an opcode of 0x0 and a FIN bit that is set.
</p>


	</li>
	<li>
断片化された~messageの合間に`制御~frame$が挿入されても~MAY。
`制御~frame$は断片化されては~MUST_NOT。
◎
Control frames (see Section 5.5) MAY be injected in the middle of a fragmented message. Control frames themselves MUST NOT be fragmented.
</li>
	<li>
~messageの断片は、送信側から送信された順序で受信先に送達され~MUST。
◎
Message fragments MUST be delivered to the recipient in the order sent by the sender.
</li>
	<li>
ある~messageに属するいくつかの断片と別の~messageに属するいくつかの断片とが、互いに交互挿入されては~MUST_NOT。
ただし、拡張が折衝されていて，それにより交互挿入が解釈できる場合を除く。
◎
The fragments of one message MUST NOT be interleaved between the fragments of another message unless an extension has been negotiated that can interpret the interleaving.
</li>
	<li>
端点は、断片化された~messageの合間に挟まれた`制御~frame$を取扱え~MUST。
◎
An endpoint MUST be capable of handling control frames in the middle of a fragmented message.
</li>
	<li>
送信側は、非~制御~messageに対しては，任意~sizeの断片を作成して~MAY。
◎
A sender MAY create fragments of any size for non-control messages.
</li>
	<li>
~clientと~serverは、断片化された~messageと断片化されていない~messageのいずれの受信も~supportし~MUST。
◎
Clients and servers MUST support receiving both fragmented and unfragmented messages.
</li>
	<li>
`制御~frame$は断片化され得ないので、中継点は，`制御~frame$の断片化状態を変更しようと試みては~MUST_NOT。
◎
As control frames cannot be fragmented, an intermediary MUST NOT attempt to change the fragmentation of a control frame.
</li>
	<li>
中継点は、いずれかの`予約-済み~bit$値が用いられていて, かつ これらの値の意味を知らない場合、~messageの断片化状態を変更しては~MUST_NOT。
◎
An intermediary MUST NOT change the fragmentation of a message if any reserved bit values are used and the meaning of these values is not known to the intermediary.
</li>
	<li>
中継点は、拡張が折衝されていて, かつ 折衝された拡張の意味論に通じていないならば、接続の文脈~下のどの~messageの断片化状態も変更しては~MUST_NOT。
同様に，~WebSocket接続により生じた~WebSocket~handshakeを見ない（したがって、その内容についても通知されていない）中継点は、その種の接続のどの~messageの断片化状態も変更しては~MUST_NOT。
◎
An intermediary MUST NOT change the fragmentation of any message in the context of a connection where extensions have been negotiated and the intermediary is not aware of the semantics of the negotiated extensions. Similarly, an intermediary that didn't see the WebSocket handshake (and wasn't notified about its content) that resulted in a WebSocket connection MUST NOT change the fragmentation of any message of such connection.
</li>
	<li>
これらの規則の帰結として、同じ~messageに属する すべての断片の種別は，それらの最初の断片の`~opcode$に設定された種別と同じに揃うことになる。
<!--  -->
`制御~frame$は断片化できないので、同じ~messageに属するすべての断片の種別は、［
~text, ~binary, ［
いずれかの予約-済み`~opcode$
］］のいずれかに揃えられ~MUST。
◎
As a consequence of these rules, all fragments of a message are of the same type, as set by the first fragment's opcode. Since control frames cannot be fragmented, the type for all fragments in a message MUST be either text, binary, or one of the reserved opcodes.
</li>
</ul>

<p class="note">注記：
仮に制御~frameを挿入できないとした場合、例えば，~pingの待ち時間は、大きい~messageの背後に回されたときに不必要に長くされる。
それゆえ、断片化された~messageの合間に挟まれた制御~frameの取扱いも要件にされている。
◎
NOTE: If control frames could not be interjected, the latency of a ping, for example, would be very long if behind a large message. Hence, the requirement of handling control frames in the middle of a fragmented message.
</p>

<p class="note">実装に対する注記：
拡張の不在の下では、受信側は~frame全体を~bufferしなくても処理できる。
例えば，~streaming~APIが用いられている場合、~frameの一部を~appに送達できる。
しかしながら、この前提は，将来のどの~WebSocket拡張においても成立するとは限らないことに注意。
◎
IMPLEMENTATION NOTE: In the absence of any extension, a receiver doesn't have to buffer the whole frame in order to process it. For example, if a streaming API is used, a part of a frame can be delivered to the application. However, note that this assumption might not hold true for all future WebSocket extensions.
</p>

		</section>
		<section id="section-5.5">
<h3 title="Control Frames">5.5. 制御~frame</h3>

<p>
制御~frameは，`~opcode$の最上位~bitが 1 かどうかで識別される。
現時点で，制御~frame用に定義済みの`~opcode$には、
`8^X （ `Close$fr ）, `9^X （ `Ping$fr ）, `A^X（ `Pong$fr ）
がある。
`B^X 〜 `F^X の`~opcode$はまだ定義されていないが、追加の制御~frame用に予約-済みである。
◎
Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Opcodes 0xB-0xF are reserved for further control frames yet to be defined.
</p>

<p>
制御~frameは，WebSocket の状態について通信するために用いられる。
制御~frameは，断片化された~messageの合間に挿入できる。
◎
Control frames are used to communicate state about the WebSocket. Control frames can be interjected in the middle of a fragmented message.
</p>

<p>
すべての制御~frameは、~payloadの長さが 125 ~byte以下, かつ
断片化されては~MUST_NOT。
◎
All control frames MUST have a payload length of 125 bytes or less and MUST NOT be fragmented.
</p>

			<section id="section-5.5.1">
<h4 title="Close">5.5.1. Close</h4>

<p>
`Close^fr ~frameの`~opcode$は `8^X である。
◎
The Close frame contains an opcode of 0x8.
</p>

<p>
`Close$fr ~frameは，~closingの事由を指示する~body（~frameの`~app~data$部位）を包含しても~MAY
— 例えば：
端点は ~shutdown中にある,
端点は 大き過ぎる~frameを受信している,
端点は 期待される形式に適合していない~frameを受信した，等々。
~bodyが在る場合、~bodyの最初の 2 ~byteは、 %~code 値をとる`~status~code$を表現する，（~network~byte順序で）2 ~byteの無符号~整数で~MUST。
2 ~byte整数に後続して、~bodyは，~UTF-8に符号化された %事由 値の~dataを包含していても~MAY。
その解釈はこの仕様では定義されない。
この~dataは、人が読めるとする必要はないが，~debug時や関連する情報を接続を~openした~scriptに渡すのには有用になり得る。
この~dataは 人から読めるようにされる保証はないので、~clientは末端~利用者にそれを示しては~MUST_NOT。
◎
The Close frame MAY contain a body (the "Application data" portion of the frame) that indicates a reason for closing, such as an endpoint shutting down, an endpoint having received a frame too large, or an endpoint having received a frame that does not conform to the format expected by the endpoint. If there is a body, the first two bytes of the body MUST be a 2-byte unsigned integer (in network byte order) representing a status code with value /code/ defined in Section 7.4. Following the 2-byte integer, the body MAY contain UTF-8-encoded data with value /reason/, the interpretation of which is not defined by this specification. This data is not necessarily human readable but may be useful for debugging or passing information relevant to the script that opened the connection. As the data is not guaranteed to be human readable, clients MUST NOT show it to end users.
</p>

<p>
~clientから~serverへ送信される `Close$fr ~frameは、 `5.3$secに従って~maskされなければならない。
◎
Close frames sent from client to server must be masked as per Section 5.3.
</p>

<p>
~appは、 `Close$fr ~frameを送信して以降は，`~data~frame$を送信しては~MUST_NOT。
◎
The application MUST NOT send any more data frames after sending a Close frame.
</p>

<p>
`Close$fr ~frameを受信した端点は、それまでに `Close$fr ~frameを送信していなかったならば，応答として `Close$fr ~frameを送信し~MUST。
（概して，応答として `Close$fr ~frameを送信する際は、端点は受信した`~status~code$を返す。）
実用的な限り早く行う~SHOULDである。
端点は、現在の~messageの送信を終えるまで， `Close$fr ~frameの送信を遅延しても~MAY。
（例えば，断片化された~messageの大多数をすでに送信していた場合、端点は `Close$fr ~frameを送信する前に残りの断片を送信しても~MAY）。
しかしながら，すでに `Close$fr ~frameを送信した相手の端点が~dataの処理を継続する保証はない。
◎
If an endpoint receives a Close frame and did not previously send a Close frame, the endpoint MUST send a Close frame in response. (When sending a Close frame in response, the endpoint typically echos the status code it received.) It SHOULD do so as soon as practical. An endpoint MAY delay sending a Close frame until its current message is sent (for instance, if the majority of a fragmented message is already sent, an endpoint MAY send the remaining fragments before sending a Close frame). However, there is no guarantee that the endpoint that has already sent a Close frame will continue to process data.
</p>

<p>
`Close$fr ~messageの送信と受信の両方を終えた端点は、~WebSocket接続は~closeされたものと見なして，下層の~TCP接続を~closeし~MUST。
~serverは、下層の~TCP接続を即時に~closeし~MUST。
~clientは、~serverが接続を~closeするまで待機する~SHOULDであるが、例えば~serverからの~TCP~Closeを適度な時間~内に受信できなかったときなど，
`Close$fr ~messageの送信と受信を終えた後に，いつでも接続を~closeして~MAY。
◎
After both sending and receiving a Close message, an endpoint considers the WebSocket connection closed and MUST close the underlying TCP connection. The server MUST close the underlying TCP connection immediately; the client SHOULD wait for the server to close the connection but MAY close the connection at any time after sending and receiving a Close message, e.g., if it has not received a TCP Close from the server in a reasonable time period.
</p>

<p>
~clientと~serverの双方が同時に `Close$fr ~messageを送信した場合、両~端点とも `Close$fr ~messageを送信し，受信することになる。
この場合も`~WebSocket接続は~close済み$と見なして，下層の~TCP接続を~closeすべきである。
◎
If a client and server both send a Close message at the same time, both endpoints will have sent and received a Close message and should consider the WebSocket connection closed and close the underlying TCP connection.
</p>

			</section>
			<section id="section-5.5.2">
<h4 title="Ping">5.5.2. `Ping^fr</h4>

<p>
`Ping$fr ~frameの`~opcode$は `9^X である。
◎
The Ping frame contains an opcode of 0x9.
</p>

<p>
`Ping$fr ~frameには`~app~data$を含ませても~MAY。
◎
A Ping frame MAY include "Application data".
</p>

<p>
端点が `Ping$fr ~frameを受領した際には、すでに `Close$fr ~frameを受信していない限り，応答として `Pong$fr ~frameを送信し~MUST。
行い得る限り早く， `Pong$fr ~frameで応答する~SHOULDである。
`Pong$fr ~frameについては `5.5.3$secにて論じる。
◎
Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in response, unless it already received a Close frame. It SHOULD respond with Pong frame as soon as is practical. Pong frames are discussed in Section 5.5.3.
</p>

<p>
端点は、接続が確立されてから，接続が~closeされるまで、いつでも， `Ping$fr ~frameを送信して~MAY。
◎
An endpoint MAY send a Ping frame any time after the connection is established and before the connection is closed.
</p>

<p class="note">注記：
`Ping$fr ~frameは、接続維持（ keepalive ）, あるいは~remoteの端点がまだ応答-可能かどうか検証する手段として用をなし得る。
◎
NOTE: A Ping frame may serve either as a keepalive or as a means to verify that the remote endpoint is still responsive.
</p>

			</section>
			<section id="section-5.5.3">
<h4 title="Pong">5.5.3. `Pong^fr</h4>

<p>
`Pong$fr ~frameの`~opcode$は `A^X である。
◎
The Pong frame contains an opcode of 0xA.
</p>

<p>
`Ping$fr および `Pong$fr ~frameに適用される要件の詳細は `5.5.2$secに述べられている。
◎
Section 5.5.2 details requirements that apply to both Ping and Pong frames.
</p>

<p>
`Ping$fr ~frameに対する応答として送信される `Pong$fr ~frameの`~app~data$は、返信-対象の `Ping$fr ~frameの~message~bodyのそれに一致しなければならない。
◎
A Pong frame sent in response to a Ping frame must have identical "Application data" as found in the message body of the Ping frame being replied to.
</p>

<p>
`Ping$fr ~frameを受信した端点は、より以前の `Ping$fr ~frameに対する `Pong$fr ~frameをまだ応答として送信していない場合、最も近過去に処理された `Ping$fr ~frameに対する `Pong$fr ~frameのみの送信を採択しても~MAY。
◎
If an endpoint receives a Ping frame and has not yet sent Pong frame(s) in response to previous Ping frame(s), the endpoint MAY elect to send a Pong frame for only the most recently processed Ping frame.
</p>

<p>
`Pong$fr ~frameは，請求が無いときに送信されても~MAY。
これは、単方向の鼓動として機能する。
請求されていない `Pong$fr ~frameに対する応答は期待されていない。
◎
A Pong frame MAY be sent unsolicited. This serves as a unidirectional heartbeat. A response to an unsolicited Pong frame is not expected.
</p>

			</section>
		</section>
		<section id="section-5.6">
<h3 title="Data Frames">5.6. ~data~frame</h3>

<p>
~data~frame（すなわち，非~制御~frame）は、`~opcode$の最上位~bitが 0 かどうかで識別され，~app層や拡張~層の~dataを運ぶ。
現時点では、`~opcode$
`1^X （ `Text$fr ）, `2^X （ `Binary$fr ）
が~data~frame用に定義されている。
【および `0^X （ `Continuation$fr ）†】
である。
`~opcode$ `3^X 〜 `7^X はまだ定義されていないが，追加の`~data~frame$用に予約-済みである。
`~opcode$は、~dataの解釈を決定する：
◎
Data frames (e.g., non-control frames) are identified by opcodes where the most significant bit of the opcode is 0. Currently defined opcodes for data frames include 0x1 (Text), 0x2 (Binary). Opcodes 0x3-0x7 are reserved for further non-control frames yet to be defined.
◎
Data frames carry application-layer and/or extension-layer data. The opcode determines the interpretation of the data:
</p>

<dl class="defs">
	<dt>`Text@fr</dt>
	<dd>
`~payload~data$は~UTF-8に符号化された~text~dataである。
特定0の~text~frameは部分的な~UTF-8~byte列を含み得るが、~message全体としては妥当な~UTF-8 を包含し~MUSTことに注意。
再構築された~messageにおいて妥当でない~UTF-8 は、
`8.1$secの記述に従って取扱われる。
◎
The "Payload data" is text data encoded as UTF-8. Note that a particular text frame might include a partial UTF-8 sequence; however, the whole message MUST contain valid UTF-8. Invalid UTF-8 in reassembled messages is handled as described in Section 8.1.
</dd>

	<dt> `Binary@fr</dt>
	<dd>
`~payload~data$は任意の~binary~dataであり、その解釈はもっぱら
~app層に委ねられる。
◎
The "Payload data" is arbitrary binary data whose interpretation is solely up to the application layer.
</dd>

	<dt>`Continuation@fr （継続~frame）</dt>
	<dd class="trans-note">【†
この項目は，
`4672$errataによる追加であり（ Reported — まだ Verified ではない）、そこでは，
“仕様の他所との整合性をとるためには、 `Continuation$fr ~frameは，`~data~frame$に分類されるべき”
と述べられている。
】</dd>
	<dd class="trans-note">
この~frame（`~opcode$ `0^X ）には、常に，`~FIN$~bitが 0 にされた
`Text$fr ／ `Binary$fr
~frameが先行する（ `5.2$secを見よ）。
`~payload~data$は、同じ~messageの，直前に伝送された［
`Text$fr ／ `Binary$fr
］~frameの次の断片（ `5.4$secを見よ）を包含し、~messageの最初の断片と同じ仕方で解釈され~MUST。
◎
These frames MUST be always preceeded by either Text or Binary frame with FIN bit clear (See Section 5.2). The "Payload data" contains next fragment (See section 5.4) of the message whose transmission were opened by the latest Text or Binary frame and MUST be interpreted in the same way as the initial fragment of the message.
</dd>

</dl>


		</section>
		<section id="section-5.7">
<h3 title="Examples">5.7. 例</h3>

<div class="example">
<ul>
	<li>
<p>
~maskされていない~text~message（ `Hello^l ）を包含する単独の~frame
⇒
`0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f^s
◎
A single-frame unmasked text message
• 0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains "Hello")
</li>
	<li>
~maskされた~text~message（ `Hello^l ）を包含する単独の~frame
⇒
`0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58^s
◎
A single-frame masked text message
• 0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58
 (contains "Hello")
</li>
	<li>
<p>
断片化された~maskされていない~text~message（順に， `Hel^l, `lo^l を包含する）：
</p>
		<ol>
			<li>
`0x01 0x03 0x48 0x65 0x6c^s 
</li>
			<li>
`0x80 0x02 0x6c 0x6f^s
</li>
		</ol>
◎
A fragmented unmasked text message
• 0x01 0x03 0x48 0x65 0x6c (contains "Hel")
• 0x80 0x02 0x6c 0x6f (contains "lo")
</li>
	<li>
<p>
~maskされていない `Ping$fr 要請（~body内に `Hello^l を包含するが，~bodyの内容は任意）
⇒
`0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f^s
</p>

<p>
対応する~maskされた<del>`Ping$fr</del> <ins>`Pong$fr</ins>†応答（~pingの~bodyに合致する `Hello^l を~bodyに含む）
⇒
`0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58^s
</p>

【†`3432$errataによる修正（ Held for Document Update ）】


◎
Unmasked Ping request and masked Ping response
• 0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of "Hello",
 but the contents of the body are arbitrary)
• 0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58
 (contains a body of "Hello", matching the body of the ping)
</li>
	<li>
256 ~byteの~binary~messageを含む単独の~maskされていない~frame
⇒
`0x82 0x7E 0x0100…^s [256 ~byteの~binary~data]
◎
256 bytes binary message in a single unmasked frame
• 0x82 0x7E 0x0100 [256 bytes of binary data]
</li>
	<li>
64KiB の~binary~messageを含む単独の~maskされていない~frame
⇒
`0x82 0x7F 0x0000000000010000…^s [ 65536 ~byteの~binary~data]
◎
64KiB binary message in a single unmasked frame
• 0x82 0x7F 0x0000000000010000 [65536 bytes of binary data]
</li>
</ul>

</div>


		</section>
		<section id="section-5.8">
<h3 title="Extensibility">5.8. 拡張性</h3>

<div class="p">
<p>
この~protocolは、基底~protocolに能力を追加する拡張を許容するように設計されている。
接続の端点は、利用する拡張があれば，~opening~handshakeの間に折衝し~MUST。
この仕様は、次のものを拡張~用途に供する：
</p>

<ul>
	<li>
`~opcode$ `3^X 〜 `7^X, `B^X 〜 `F^X
</li>
	<li>
`拡張~data$~field
</li>
	<li>
~frame~headerの
`frame-rsv1$P,
`frame-rsv2$P,
`frame-rsv3$P
~bit
【“`予約-済み~bit$”】
</li>
</ul>

<p >
拡張の折衝についての詳細は、 `9.1$secにて論じる。
予想される拡張の利用の一部を以下に挙げる。
この~listは、完全でも~~規範になるものでもない。
</p>

◎
The protocol is designed to allow for extensions, which will add capabilities to the base protocol. The endpoints of a connection MUST negotiate the use of any extensions during the opening handshake. This specification provides opcodes 0x3 through 0x7 and 0xB through 0xF, the "Extension data" field, and the frame-rsv1, frame-rsv2, and frame-rsv3 bits of the frame header for use by extensions. The negotiation of extensions is discussed in further detail in Section 9.1. Below are some anticipated uses of extensions. This list is neither complete nor prescriptive.
</div>

<ul>
	<li>
`拡張~data$を `~payload~data$内で`~app~data$の前に置いてよい。
◎
"Extension data" may be placed in the "Payload data" before the "Application data".
</li>
	<li>
`予約-済み~bit$は、~frameごとに必要に応じて割振れる。
◎
Reserved bits can be allocated for per-frame needs.
</li>
	<li>
予約-済み`~opcode$値を定義できる。
◎
Reserved opcode values can be defined.
</li>
	<li>
より多くの`~opcode$値が必要であれば、`予約-済み~bit$を~opcode~fieldに割振れる。
◎
Reserved bits can be allocated to the opcode field if more opcode values are needed.
</li>
	<li>
`予約-済み~bit$や “拡張”~opcodeを、より大きな~opcodeやより多くの~frameごとの~bitを定義するために，
`~payload~data$の外
【？】
に追加の~bitを割振ることにより、定義できる。
◎
A reserved bit or an "extension" opcode can be defined that allocates additional bits out of the "Payload data" to define larger opcodes or more per-frame bits.
</li>
</ul>

		</section>
	</section>
	<section id="section-6">
<h2 title="Sending and Receiving Data">6. ~dataの送信と受信</h2>

		<section id="section-6.1">
<h3 title="Sending Data">6.1. ~dataの送信</h3>

<p>
~WebSocket接続を通じて， %~data で構成される
`~WebSocket~messageを送信する@
ときは、端点は，次の手続きを遂行し~MUST。
◎
To _Send a WebSocket Message_ comprising of /data/ over a WebSocket connection, an endpoint MUST perform the following steps.
</p>

<ol>

<!-- 1 -->
	<li>
端点は、~WebSocket接続の`~OPEN状態$を確保し~MUST（ `4.1$sec, `4.2.2$sec 参照）。
いつの時点においても，~WebSocket接続の状態が変化した場合、端点は以下の手続きを中止し~MUST。
<!-- 変更 -->
◎
The endpoint MUST ensure the WebSocket connection is in the OPEN state (cf. Sections 4.1 and 4.2.2.) If at any point the state of the WebSocket connection changes, the endpoint MUST abort the following steps.
</li>
<!-- 2 -->
	<li>
端点は、~WebSocket~frame内の %~data を `5.2$secの定義に従って，~encapsulateし~MUST。
送信される~dataが大きいとき, あるいは 端点が~dataを送信し始めたいと望む時点では まだ~data全体が可用になっていない場合、端点は，代わりに `5.4$secの定義に従って，~dataを一連の~frameに~encapsulateしても~MAY。
◎
An endpoint MUST encapsulate the /data/ in a WebSocket frame as defined in Section 5.2. If the data to be sent is large or if the data is not available in its entirety at the point the endpoint wishes to begin sending the data, the endpoint MAY alternately encapsulate the data in a series of frames as defined in Section 5.4.
</li>
<!-- 3 -->
	<li>
~dataを包含している最初の~frameの`~opcode$（ `frame-opcode$P ）は、~textまたは~binary~dataとして 受信先に解釈されることになる~dataに適切な， `5.2$secによる値に設定され~MUST。
◎
The opcode (frame-opcode) of the first frame containing the data MUST be set to the appropriate value from Section 5.2 for data that is to be interpreted by the recipient as text or binary data.
</li>
<!-- 4 -->
	<li>
~dataを包含している最後の~frameの`~FIN$~bit（ `frame-fin$P ）は、 `5.2$secの定義に従って，
1 にされ~MUST。
◎
The FIN bit (frame-fin) of the last frame containing the data MUST be set to 1 as defined in Section 5.2.
</li>
<!-- 5 -->
	<li>
~dataが~clientから送信される場合、その各~frameは，
`5.3$secの定義に従って，~maskされ~MUST。
◎
If the data is being sent by the client, the frame(s) MUST be masked as defined in Section 5.3.
</li>
<!-- 6 -->
	<li>
~WebSocket接続において，何らかの拡張（ `9$sec ）が折衝されている場合、それらの拡張の定義に従って，追加の考慮点が適用され得る。
◎
If any extensions (Section 9) have been negotiated for the WebSocket connection, additional considerations may apply as per the definition of those extensions.
</li>
<!-- 7 -->
	<li>
形成-済みの各~frameは、下層の~network接続を通じて伝送され~MUST。
◎
The frame(s) that have been formed MUST be transmitted over the underlying network connection.
</li>
</ol>

		</section>
		<section id="section-6.2">
<h3 title="Receiving Data">6.2. ~dataの受信</h3>

<p>
端点は、~WebSocket~dataを受信するために，下層の~network接続を~listenする。
着信~dataは、 `5.2$secの定義に従って，~WebSocket~frameとして構文解析され~MUST。
`制御~frame$が受信された際には、その定義に従って，取扱わ~MUST。
端点は、`~data~frame$の受信に際し，
`5.2$secにて`~opcode$（ `frame-opcode$P ）に定義された，~dataの %種別 を~~記録しておか~MUST。
この~frameの`~app~data$が~messageの %~data として定義される。
~frameが断片化されていない~message（ `5.4$sec ）を成す場合、種別 %種別，~data %~data の
`~WebSocket~messageが受信された@
とされる。
~frameが断片化された~messageの一部である場合、後続の`~data~frame$からの`~app~data$を連結した結果が %~data を形成し、`~FIN$~bit（ `frame-fin$P ）で指示される最後の断片が受信されたとき，（各 断片の`~app~data$の連結が成す）~data %~data と（断片化された~messageの最初の~frameで~~記録された）種別 %種別 の`~WebSocket~messageが受信された$とされる。
後続の`~data~frame$は、新たな~WebSocket~messageに属するものとして，解釈され~MUST。
◎
To receive WebSocket data, an endpoint listens on the underlying network connection. Incoming data MUST be parsed as WebSocket frames as defined in Section 5.2. If a control frame (Section 5.5) is received, the frame MUST be handled as defined by Section 5.5. Upon receiving a data frame (Section 5.6), the endpoint MUST note the /type/ of the data as defined by the opcode (frame-opcode) from Section 5.2. The "Application data" from this frame is defined as the /data/ of the message. If the frame comprises an unfragmented message (Section 5.4), it is said that _A WebSocket Message Has Been Received_ with type /type/ and data /data/. If the frame is part of a fragmented message, the "Application data" of the subsequent data frames is concatenated to form the /data/. When the last fragment is received as indicated by the FIN bit (frame-fin), it is said that _A WebSocket Message Has Been Received_ with data /data/ (comprised of the concatenation of the "Application data" of the fragments) and type /type/ (noted from the first frame of the fragmented message). Subsequent data frames MUST be interpreted as belonging to a new WebSocket message.
</p>

<p>
拡張（ `9$sec ）は、特に何が~message境界をなすのかも含めて，~dataの読取り方の意味論を変更しても~MAY。
拡張は、~payload内の`~app~data$の前に`拡張~data$を追加することに加えて，`~app~data$に（圧縮などの）手を加えても~MAY。
◎
Extensions (Section 9) MAY change the semantics of how data is read, specifically including what comprises a message boundary. Extensions, in addition to adding "Extension data" before the "Application data" in a payload, MAY also modify the "Application data" (such as by compressing it).
</p>

<p>
~serverは、~clientから受信した`~data~frame$の~maskを，
`5.3$secに従って除去し~MUST。
◎
A server MUST remove masking for data frames received from a client as described in Section 5.3.
</p>


		</section>
	</section>
	<section id="section-7">
<h2 title="Closing the Connection">7. 接続の~closing</h2>

		<section id="section-7.1">
<h3 title="Definitions">7.1. 定義</h3>

			<section id="section-7.1.1">
<h4 title="Close the WebSocket Connection">7.1.1. ~WebSocket接続を~closeする</h4>

<p>
`~WebSocket接続を~close@
するときは、端点は，下層の~TCP接続を~closeする。
端点は、~TLS~sessionも含め，~cleanに~TCP接続を~closeする~methodを用いる~SHOULDである。
適用-可能ならば，受信された後続の~byteも破棄する。
端点は、攻撃されたときなど必要とされるときは，どのような手段で接続を~closeして~MAY。
<!--  -->
◎
To _Close the WebSocket Connection_, an endpoint closes the underlying TCP connection. An endpoint SHOULD use a method that cleanly closes the TCP connection, as well as the TLS session, if applicable, discarding any trailing bytes that may have been received. An endpoint MAY close the connection via any means available when necessary, such as when under attack.
</p>

<p>
下層の~TCP接続は、ほとんどの通常の事例では，~serverが TIME_WAIT 状態を保持するようにするため、~clientではなく，まず~serverから~closeされる~SHOULDである。
（これにより、最大セグメント寿命の 2 倍の期間（ 2MSL — 2 maximum segment lifetime ）、~serverは接続を再~openしないようになる,
while<!-- ＊ -->
より高い seq 番号による新たな SYN に際しては， TIME_WAIT 接続が即時に再~openされるので、対応する~serverへの~~影響は無い
【？】
）。
異常な事例においては（適度な時間~内に~serverから~TCP~Closeを受信していないときなど）~clientから~TCP~Closeを起動しても~MAY。
そのようなわけで、~serverが
`~WebSocket接続を~close$するよう指図されたときは，即時に~TCP~Closeを起動する~SHOULDであり、~clientが同じことを指図されたときは，~serverからの~TCP~Closeを待機する~SHOULDである。
◎
The underlying TCP connection, in most normal cases, SHOULD be closed first by the server, so that it holds the TIME_WAIT state and not the client (as this would prevent it from re-opening the connection for 2 maximum segment lifetimes (2MSL), while there is no corresponding server impact as a TIME_WAIT connection is immediately reopened upon a new SYN with a higher seq number). In abnormal cases (such as not having received a TCP Close from the server after a reasonable amount of time) a client MAY initiate the TCP Close. As such, when a server is instructed to _Close the WebSocket Connection_ it SHOULD initiate a TCP Close immediately, and when a client is instructed to do the same, it SHOULD wait for a TCP Close from the server.
</p>

<div>
<p>
Berkeley ~socketを利用して，~cleanな~closureを得るための、 C 言語による例：
</p>

<ol>
	<li>
`SHUT_WR^c を引数に，~socketに対し `shutdown()^c を~callする。
</li>
	<li>
値 0 が返されるまで， `recv()^c を~callする。
（値 0 は端点がきちんと~shutdownを遂行したことを指示する）
</li>
	<li>
~socketに対し `close()^c を~callする。
</li>
</ol>

◎
As an example of how to obtain a clean closure in C using Berkeley sockets, one would call shutdown() with SHUT_WR on the socket, call recv() until obtaining a return value of 0 indicating that the peer has also performed an orderly shutdown, and finally call close() on the socket.
</div>

			</section>
			<section id="section-7.1.2">
<h4 title="Start the WebSocket Closing Handshake">7.1.2. ~WebSocket~closing~handshakeを開始する</h4>

<p>
`~status~code$ %~code, および
~optionの`~close事由$ %事由 を~parameterに
`~WebSocket~closing~handshakeを開始する@
ときは、端点は `5.5.1$secの記述に従って，`~status~code$が %~code にされ, `~close事由$が %事由 にされた， `Close$fr `制御~frame$を送信し~MUST。
いったん，端点が `Close$fr `制御~frame$を送信し, 受信したなら、その端点は `7.1.1$secの定義に従って，`~WebSocket接続を~close$する~SHOULDである。
◎
To _Start the WebSocket Closing Handshake_ with a status code (Section 7.4) /code/ and an optional close reason (Section 7.1.6) /reason/, an endpoint MUST send a Close control frame, as described in Section 5.5.1, whose status code is set to /code/ and whose close reason is set to /reason/. Once an endpoint has both sent and received a Close control frame, that endpoint SHOULD _Close the WebSocket Connection_ as defined in Section 7.1.1.
</p>


			</section>
			<section id="section-7.1.3">
<h4 title="The WebSocket Closing Handshake is Started">7.1.3. ~WebSocket~closing~handshakeは開始された</h4>

<p>
`Close$fr `制御~frame$を送信-または受信したとき、
`~WebSocket~closing~handshakeは開始された@
とされ，その~WebSocket接続は
`~CLOSING状態@
になる。
◎
Upon either sending or receiving a Close control frame, it is said that _The WebSocket Closing Handshake is Started_ and that the WebSocket connection is in the CLOSING state.
</p>

			</section>
			<section id="section-7.1.4">
<h4 title="The WebSocket Connection is Closed">7.1.4. ~WebSocket接続は~close済み</h4>

<p>
下層の~TCP接続が~closeされたとき、
`~WebSocket接続は~close済み@
とされ，その~WebSocket接続は
`~CLOSED状態@
になる。
~WebSocket~closing~handshakeの完了-後に~TCP接続が~closeされた場合、~WebSocket接続は
`~cleanに@
~closeされたとされる。
◎
When the underlying TCP connection is closed, it is said that _The WebSocket Connection is Closed_ and that the WebSocket connection is in the CLOSED state. If the TCP connection was closed after the WebSocket closing handshake was completed, the WebSocket connection is said to have been closed _cleanly_.
</p>

<p>
~WebSocket接続が確立できなかったときも`~WebSocket接続は~close済み$とされるが、`~cleanに$とは言わない。
◎
If the WebSocket connection could not be established, it is also said that _The WebSocket Connection is Closed_, but not _cleanly_.
</p>

			</section>
			<section id="section-7.1.5">
<h4 title="The WebSocket Connection Close Code">7.1.5. ~WebSocket接続の~close~code</h4>

<p>
`5.5.1$sec, `7.4$secにて定義されるように、
`Close$fr `制御~frame$は，~closureの事由を指示する`~status~code$を包含し得る。
~WebSocket接続の~closingは，どちらの端点からも（同時の可能性も含めて）起動され得る。
~WebSocket接続の
`~close~code@
は、この~protocolを実装している~appが最初に受信した `Close$fr `制御~frame$に包含されている`~status~code$として定義される。
この `Close$fr `制御~frame$が`~status~code$を包含していない場合、`~close~code$は `1005$st であるものと見なされる。
`~WebSocket接続は~close済み$であり，かつ
その端点で他に `Close$fr `制御~frame$が受信されなかった場合（下層の~transport層の接続が失われた場合などに生じ得る）、`~close~code$は `1006$st であるものと見なされる。
◎
As defined in Sections 5.5.1 and 7.4, a Close control frame may contain a status code indicating a reason for closure. A closing of the WebSocket connection may be initiated by either endpoint, potentially simultaneously. _The WebSocket Connection Close Code_ is defined as the status code (Section 7.4) contained in the first Close control frame received by the application implementing this protocol. If this Close control frame contains no status code, _The WebSocket Connection Close Code_ is considered to be 1005. If _The WebSocket Connection is Closed_ and no Close control frame was received by the endpoint (such as could occur if the underlying transport connection is lost), _The WebSocket Connection Close Code_ is considered to be 1006.
</p>

<p class="note">注記：
2 つの端点において~WebSocket接続の`~close~code$の値に一致を見ないことも起こり得る。
例えば，~remoteの端点が `Close$fr ~frameを送信したが、~local~appは，まだその~socketの受信~bufferから `Close$fr ~frameを包含している~dataを読取れてなく，かつ
その~local~appが独立に接続を~closeすることにして `Close$fr ~frameを送信した場合、どちらの端点も `Close$fr ~frameを送信し, 受信し，それ以上 `Close$fr ~frameを送信しないことになる。
それぞれの端点は相手の端点から送信された`~status~code$を`~close~code$として見ることになる。
そのため、両者の端点がほぼ同じ時刻に，独立に`~WebSocket~closing~handshakeを開始する$手続きを行った場合、互いの`~close~code$の値が一致を見ないことが起こり得る。
◎
NOTE: Two endpoints may not agree on the value of _The WebSocket Connection Close Code_. As an example, if the remote endpoint sent a Close frame but the local application has not yet read the data containing the Close frame from its socket's receive buffer, and the local application independently decided to close the connection and send a Close frame, both endpoints will have sent and received a Close frame and will not send further Close frames. Each endpoint will see the status code sent by the other end as _The WebSocket Connection Close Code_. As such, it is possible that the two endpoints may not agree on the value of _The WebSocket Connection Close Code_ in the case that both endpoints _Start the WebSocket Closing Handshake_ independently and at roughly the same time.
</p>

			</section>
			<section id="section-7.1.6">
<h4 title="The WebSocket Connection Close Reason">7.1.6. ~WebSocket接続の~close事由</h4>

<p>
`5.5.1$sec, `7.4$secにて定義されるように、
`Close$fr `制御~frame$は、~closureの事由を指示する`~status~code$に伴って，~UTF-8に符号化された~dataも包含し得る。
その~dataの解釈は端点に委ねられ，この~protocolでは定義されない。
~WebSocket接続の~closingは、同時の可能性も含め，どちらの端点からも起動され得る。
~WebSocket接続の
`~close事由@
は、この~protocolを実装する~appで受信された最初の `Close$fr `制御~frame$に包含された`~status~code$に後続する，~UTF-8に符号化された~dataとして、定義される。
`Close$fr `制御~frame$にその種の~dataがない場合、`~close事由$は空~文字列とする。
◎
As defined in Sections 5.5.1 and 7.4, a Close control frame may contain a status code indicating a reason for closure, followed by UTF-8-encoded data, the interpretation of said data being left to the endpoints and not defined by this protocol. A closing of the WebSocket connection may be initiated by either endpoint, potentially simultaneously. _The WebSocket Connection Close Reason_ is defined as the UTF-8-encoded data following the status code (Section 7.4) contained in the first Close control frame received by the application implementing this protocol. If there is no such data in the Close control frame, _The WebSocket Connection Close Reason_ is the empty string.
</p>

<p class="note">注記：
`7.1.5$secと同じ論法により、 2 つの端点の`~close事由$に一致を見ないことも起こり得る。
◎
NOTE: Following the same logic as noted in Section 7.1.5, two endpoints may not agree on _The WebSocket Connection Close Reason_.
</p>

			</section>
			<section id="section-7.1.7">
<h4 title="Fail the WebSocket Connection">7.1.7. ~WebSocket接続を失敗させる</h4>

<p>
~algoと仕様の一部は、端点に対し，
`~WebSocket接続を失敗させ@
ることを要求する。
そのためには、~clientは`~WebSocket接続を~close$し~MUST
— 加えて，問題を適切な方式で利用者に報告しても~MAY（とりわけ開発者に有用になるであろう）。
同様に、~serverは`~WebSocket接続を~close$し~MUST
— 加えて，問題を~logにとる~SHOULDである。
◎
Certain algorithms and specifications require an endpoint to _Fail the WebSocket Connection_. To do so, the client MUST _Close the WebSocket Connection_, and MAY report the problem to the user (which would be especially useful for developers) in an appropriate manner. Similarly, to do so, the server MUST _Close the WebSocket Connection_, and SHOULD log the problem.
</p>

<p>
端点において`~WebSocket接続を失敗させ$るよう要求された時点に先立って，`~WebSocket接続は確立されて$いる場合、端点は，
`~WebSocket接続を~close$する前に，適切な`~status~code$を伴う `Close$fr ~frameを送信する~SHOULDである。
端点は、最初の段階で［
~WebSocket接続を失敗させた~errorの資質から，相手が `Close$fr ~frameの受信とその処理を行える見込みはない
］と予見されるときは， `Close$fr ~frameの送信を省略しても~MAY。
端点は、`~WebSocket接続を失敗させ$るよう指図された後は，~remote端点からの~dataの処理の試みを（ `Close$fr ~frameへの応答も含め）継続しては~MUST_NOT。
◎
If _The WebSocket Connection is Established_ prior to the point where the endpoint is required to _Fail the WebSocket Connection_, the endpoint SHOULD send a Close frame with an appropriate status code (Section 7.4) before proceeding to _Close the WebSocket Connection_. An endpoint MAY omit sending a Close frame if it believes the other side is unlikely to be able to receive and process the Close frame, due to the nature of the error that led the WebSocket connection to fail in the first place. An endpoint MUST NOT continue to attempt to process data (including a responding Close frame) from the remote endpoint after being instructed to _Fail the WebSocket Connection_.
</p>

<p>
上に指示されたもの，および
~app層（例えば，~WebSocket~APIを利用する~script）から指定されたときを除き、~clientは接続を~closeする~SHOULDでない。
◎
Except as indicated above or as specified by the application layer (e.g., a script using the WebSocket API), clients SHOULD NOT close the connection.
</p>

			</section>
		</section>
		<section id="section-7.2">
<h3 title="Abnormal Closure">7.2. 異常な closure</h3>

			<section id="section-7.2.1">
<h4 title="Client-Initiated Closure">7.2.1. ~clientから開始される~closure</h4>

<p>
一部の~algo
— 特に~opening~handshakeの間 —
においては、`~WebSocket接続を失敗させ$ることが~clientに要求される。
そのためには、~clientは， `7.1.7$secの定義に従って
`~WebSocket接続を失敗させ$~MUST。
◎
Certain algorithms, in particular during the opening handshake, require the client to _Fail the WebSocket Connection_. To do so, the client MUST _Fail the WebSocket Connection_ as defined in Section 7.1.7.
</p>

<p>
どの時点においても，下層の~transport層の接続が予期せず失われた場合、~clientは
`~WebSocket接続を失敗させ$~MUST。
◎
If at any point the underlying transport layer connection is unexpectedly lost, the client MUST _Fail the WebSocket Connection_.
</p>

<p>
上に指示されたもの，および
~app層（例えば，~WebSocket~APIを利用する~script）から指定されたときを除き、~clientは接続を~closeする~SHOULDでない。
◎
Except as indicated above or as specified by the application layer (e.g., a script using the WebSocket API), clients SHOULD NOT close the connection.
</p>

			</section>
			<section id="section-7.2.2">
<h4 title="Server-Initiated Closure">7.2.2. ~serverから開始される~closure</h4>

<p>
一部の~algoでは、~opening~handshakeの間に，~serverに対し
`~WebSocket接続を中止する@
よう要求-または推奨する。
そのためには、~serverは単純に`~WebSocket接続を~close$し~MUST。
◎
Certain algorithms require or recommend that the server _Abort the WebSocket Connection_ during the opening handshake. To do so, the server MUST simply _Close the WebSocket Connection_ (Section 7.1.1).
</p>

			</section>
			<section id="section-7.2.3">
<h4 title="Recovering from Abnormal Closure">7.2.3. 異常な~closureからの復帰-法</h4>

<p>
異常な~closureが起きる事由はいくつもある。
その種の~closureが一時的な~errorによる場合、再接続により，良好な接続と通常の運用を回復し得る。
その種の~closureが一時的でない問題に起因する場合もある。
その場合、広範の~clientのそれぞれが異常な~closureを経験していて，即時に, かつ持続的に再接続を試行した場合、~serverは多数の~clientからの再接続の試行-により，~DoS攻撃に相当する高負荷に晒され得る。
そのような局面による結果、適時に~serviceを復帰できない, あるいは復帰がずっと困難なものになり得る。
◎
Abnormal closures may be caused by any number of reasons. Such closures could be the result of a transient error, in which case reconnecting may lead to a good connection and a resumption of normal operations. Such closures may also be the result of a nontransient problem, in which case if each deployed client experiences an abnormal closure and immediately and persistently tries to reconnect, the server may experience what amounts to a denial-of-service attack by a large number of clients trying to reconnect. The end result of such a scenario could be that the service is unable to recover in a timely manner or recovery is made much more difficult.
</p>

<p>
これを防止するため、~clientは、この節で述べたような異常な~closureが起きた後に再接続を試行する際には，何らかの形の~backoffを利用する~SHOULDである。
<!-- backoff
http://www.atmarkit.co.jp/fwin2k/network/tcpip006/tcpip04.html
-->
◎
To prevent this, clients SHOULD use some form of backoff when trying to reconnect after abnormal closures as described in this section.
</p>

<p>
最初の再接続の試みは、~randomな時間だけ遅延される~SHOULDである。
この~randomな遅延を選ぶための~parameterの決定は、~clientに委ねられる。
0 〜 5 秒までの~randomな値は、初期の遅延として適度なものである。
もっとも，~clientは、実装の経験と個々の応用に基づいて，異なる間隔を遅延の長さに選択しても~MAY。
◎
The first reconnect attempt SHOULD be delayed by a random amount of time. The parameters by which this random delay is chosen are left to the client to decide; a value chosen randomly between 0 and 5 seconds is a reasonable initial delay though clients MAY choose a different interval from which to select a delay length based on implementation experience and particular application.
</p>

<p>
最初の再接続の試みが失敗した場合、後続の再接続では，べき乗打切り待機法（ truncated binary exponential backoff ）などを用いて，遅延の間隔を漸増させる~SHOULDである。
◎
Should the first reconnect attempt fail, subsequent reconnect attempts SHOULD be delayed by increasingly longer amounts of time, using a method such as truncated binary exponential backoff.
</p>

			</section>
		</section>
		<section id="section-7.3">
<h3 title="Normal Closure of Connections">7.3. 接続の正常な closure</h3>

<p>
~serverは、欲されたときは, いつでも，~WebSocket接続を~closeして~MAY。
~clientは~WebSocket接続を任意に~closeする~SHOULDでない。
いずれの場合も、端点は`~WebSocket~closing~handshakeを開始する$手続き（ `7.1.2$sec ）へ移行して，~closureに起動する。
◎
Servers MAY close the WebSocket connection whenever desired. Clients SHOULD NOT close the WebSocket connection arbitrarily. In either case, an endpoint initiates a closure by following the procedures to _Start the WebSocket Closing Handshake_ (Section 7.1.2).
</p>

		</section>
		<section id="section-7.4">
<h3 title="Status Codes">7.4. ~status~code</h3>

<p>
すでに確立されている接続の~closingに際しては（例えば，~opening~handshakeが完了した後に `Close$fr ~frameを送信する際）、端点は~closureの事由を指示しても~MAY。
端点によるこの事由の解釈，および
端点がこの事由に基づいてとるべき動作は、この仕様では定義されないままにされている。
この仕様は、一連の定義済みの
`~status~code@
を定義し，拡張, ~framework, ~appが利用できる それらの~code範囲を指定する。
`~status~code$, および それに結び付けられる~textの~messageは、 `Close$fr ~frameの~optionの成分である。
◎
When closing an established connection (e.g., when sending a Close frame, after the opening handshake has completed), an endpoint MAY indicate a reason for closure. The interpretation of this reason by an endpoint, and the action an endpoint should take given this reason, are left undefined by this specification. This specification defines a set of pre-defined status codes and specifies which ranges may be used by extensions, frameworks, and end applications. The status code and any associated textual message are optional components of a Close frame.
</p>

			<section id="section-7.4.1">
<h4 title="Defined Status Codes">7.4.1. 定義済みの~status~code</h4>

<p>
端点は、 `Close$fr ~frameを送信する際に，以下に挙げる定義済みの`~status~code$を利用して~MAY。
◎
Endpoints MAY use the following pre-defined status codes when sending a Close frame.
</p>

<dl class="defs">

	<dt>`1000@st</dt>
	<dd>
正常な~closureを指示する。
確立された接続の目的が充足されたことを意味する。
◎
1000 indicates a normal closure, meaning that the purpose for which the connection was established has been fulfilled.
</dd>

	<dt>`1001@st</dt>
	<dd>
端点が “消去っている” ことを指示する。
~serverが~downしたり，~browserが~pageからどこか他へ~navigateしたときなど。
◎
1001 indicates that an endpoint is "going away", such as a server going down or a browser having navigated away from a page.
</dd>
	<dd class="trans-note">【
`4919$errata
に報告あり（ Reported ）
— 要約：
<q>同じ~codeを，まったく別の~~状況
“~down”,“どこか他へ~navigate”
にあてがう根拠は？
状況別に~codeを分けるべきでは？</q>
という指摘。
】</dd>

	<dt>`1002@st</dt>
	<dd>
端点が~protocol~errorにより接続を終了していることを指示する。
◎
1002 indicates that an endpoint is terminating the connection due to a protocol error.
</dd>

	<dt>`1003@st</dt>
	<dd>
受容できない~dataを受信したため、端点は 接続を終了していることを指示する（例えば，~text~dataしか解せない端点が~binary~messageを受信したとき、これを送信しても~MAY）。
◎
1003 indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept (e.g., an endpoint that understands only text data MAY send this if it receives a binary message).
</dd>

	<dt>`1004@st</dt>
	<dd>
予約-済み。
特定の意味は、将来に定義されることになるであろう。
◎
Reserved. The specific meaning might be defined in the future.
</dd>

	<dt>`1005@st</dt>
	<dd>
予約-済みの値であり、端点は，
`Close$fr `制御~frame$の~status~codeに設定しては~MUST_NOT。
これは、どの~status~codeも実際には無いことを指示する~status~codeを期待する~app用のものとして，指名されている。
◎
1005 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that no status code was actually present.
</dd>

	<dt>`1006@st</dt>
	<dd>
予約-済みの値であり、端点は，
`Close$fr `制御~frame$の~status~codeに設定しては~MUST_NOT。
これは、接続が異常に（例えば， `Close$fr `制御~frame$の送信や受信-抜きに）~closeされたことを指示する~status~codeを期待する~app用のものとして，指名されている。
◎
1006 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that the connection was closed abnormally, e.g., without sending or receiving a Close control frame.
</dd>

	<dt>`1007@st</dt>
	<dd>
受信した~message内の~dataが~messageの種別と整合していないため（例えば，~text~message内の非 UTF-8 `RFC3629$r ），端点は 接続を終了していることを指示する。
◎
1007 indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [RFC3629] data within a text message).
</dd>

	<dt>`1008@st</dt>
	<dd>
~policyに違反している~messageを受信したため、端点は 接続を終了していることを指示する。
これは、より相応しい~status~code（例えば， `1003$st や `1009$st ）が他にないとき, または~policyに特有の詳細を隠す必要があるときに返し得る，汎用の~status~codeである。
◎
1008 indicates that an endpoint is terminating the connection because it has received a message that violates its policy. This is a generic status code that can be returned when there is no other more suitable status code (e.g., 1003 or 1009) or if there is a need to hide specific details about the policy.
</dd>

	<dt>`1009@st</dt>
	<dd>
処理するには大き過ぎる~messageを受信したため、端点は 接続を終了していることを指示する。
◎
1009 indicates that an endpoint is terminating the connection because it has received a message that is too big for it to process.
</dd>

	<dt>`1010@st</dt>
	<dd>
1 つ以上の拡張を折衝するよう期待していたのに，~serverは~WebSocket~handshakeの応答~message内にそれらを返さなかったため、~clientは 接続を終了していることを指示する。
`Close$fr ~frameの %事由 には、必要な拡張の~listが出現する~SHOULDである。
~serverは、代わりに~WebSocket~handshakeを失敗させれるので，この~status~codeを利用することはないことに注意。
◎
1010 indicates that an endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, but the server didn't return them in the response message of the WebSocket handshake. The list of extensions that are needed SHOULD appear in the /reason/ part of the Close frame. Note that this status code is not used by the server, because it can fail the WebSocket handshake instead.
</dd>

	<dt>`1011@st</dt>
	<dd>
要請を充足できなくするような，予期されない条件に遭遇したため、~serverは 接続を終了していることを指示する。
◎
1011 indicates that a server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.
</dd>
	<dd class="trans-note">【
`3227$errataによる修正提案（ Held for Document Update ）あり：
“~server” → “端点”
】</dd>

	<dt>`1015@st</dt>
	<dd>
予約-済みの値であり、端点は，
`Close$fr `制御~frame$の~status~codeに設定しては~MUST_NOT。
これは、~TLS~handshakeを遂行した際の失敗により（例えば，~serverが証明書を検証できないなど），接続が~closeされたことを指示する~status~codeを期待する~app用のものとして，指名されている。
◎
1015 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).
</dd>

</dl>

			</section>
			<section id="section-7.4.2">
<h4 title="Reserved Status Code Ranges">7.4.2. 予約-済み~status~codeの範囲</h4>

<dl class="defs">

	<dt>`0^st 〜 `999^st</dt>
	<dd>
この範囲の`~status~code$は、利用されない。
◎
Status codes in the range 0-999 are not used.
</dd>

	<dt>`1000^st 〜 `2999^st</dt>
	<dd>
この範囲の`~status~code$は、この~protocolとその将来の改訂, および［
恒久的かつ どこでも可用な公共の仕様にて指定される拡張
］による定義~用に，予約-済みである。
◎
Status codes in the range 1000-2999 are reserved for definition by this protocol, its future revisions, and extensions specified in a permanent and readily available public specification.
</dd>

	<dt>`3000^st 〜 `3999^st</dt>
	<dd>
この範囲の`~status~code$は、［
~library ／ ~framework ／ ~app
］による利用のために，予約-済みである。
これらの~status~codeは、 IANA により直に登録される。
これらの~codeの解釈は、この~protocolでは定義されない。
◎
Status codes in the range 3000-3999 are reserved for use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by this protocol.
</dd>

	<dt>`4000^st 〜 `4999^st</dt>
	<dd>
この範囲の`~status~code$は、私的~利用のために予約-済みなので，登録できない。
これらの~codeは~WebSocket~appとの事前の取り決めにより利用できる。
これらの~codeの解釈は、この~protocolでは定義されない。
◎
Status codes in the range 4000-4999 are reserved for private use and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by this protocol.
</dd>

</dl>

			</section>
		</section>
	</section>
	<section id="section-8">
<h2 title="Error Handling">8. ~errorの取扱い</h2>

		<section id="section-8.1">
<h3 title="Handling Errors in UTF-8-Encoded Data">8.1. ~UTF-8に符号化された~dataにおける~errorの取扱い</h3>

<p>
端点が~byte~streamを~UTF-8 として解釈する際に，その~byte~streamが実際には妥当な~UTF-8~streamではなかった場合、その端点は，`~WebSocket接続を失敗させ$~MUST。
この規則は、~opening~handshakeの間にも, 後続の~data交換の間にも，いずれにも適用される。
◎
When an endpoint is to interpret a byte stream as UTF-8 but finds that the byte stream is not, in fact, a valid UTF-8 stream, that endpoint MUST _Fail the WebSocket Connection_. This rule applies both during the opening handshake and during subsequent data exchange.
</p>


		</section>
	</section>
	<section id="section-9">
<h2 title="Extensions">9. 拡張</h2>

<p>
~WebSocket~clientは、この仕様の拡張を要請しても~MAY。
~WebSocket~serverは、~clientから要請された拡張の一部またはすべてを
受容して~MAY。
~serverは、~clientから要請されていない拡張を応答しては~MUST_NOT。
~client↔~server間の折衝において，拡張の~parameterが含まれる場合、これらの~parameterは，~parameterを適用する拡張の仕様に則って選ばれ~MUST。
◎
WebSocket clients MAY request extensions to this specification, and WebSocket servers MAY accept some or all extensions requested by the client. A server MUST NOT respond with any extension not requested by the client. If extension parameters are included in negotiations between the client and the server, those parameters MUST be chosen in accordance with the specification of the extension to which the parameters apply.
</p>

		<section id="section-9.1">
<h3 title="Negotiating Extensions">9.1. 拡張の折衝-法</h3>

<p>
~clientは、
<a href="~RFC7230#section-3.2">~HTTP~headerの通常の規則</a>
`HTTP$r
に従って，
`Sec-WebSocket-Extensions^h ~headerを含めることにより、拡張を要請する。
~headerの値は，次の~ABNFにて定義される。
この~ABNFには、 `HTTP$r による`~ABNF拡張$が用いられることに注意。
~client／~serverは、折衝の間に この~ABNFに適合しない値を受信したときは，即時に`~WebSocket接続を失敗させ$~MUST。
◎
A client requests extensions by including a |Sec-WebSocket-Extensions| header field, which follows the normal rules for HTTP header fields (see [RFC2616], Section 4.2) and the value of the header field is defined by the following ABNF [RFC2616]. Note that this section is using ABNF syntax/rules from [RFC2616], including the "implied *LWS rule". If a value is received by either the client or the server during negotiation that does not conform to the ABNF below, the recipient of such malformed data MUST immediately _Fail the WebSocket Connection_.
</p>

<pre class="ABNF">
`Sec-WebSocket-Extensions@P
      = `extension-list$P
`extension-list@P
      = 1#`extension$P
`extension@P
      = `extension-token$P *( ";" `extension-param$P )
`extension-token@P
      = `registered-token$P
`registered-token@P
      = `token$P
`extension-param@P
      = `token$P [ "=" (`token$P | `quoted-string$P) ]
      ; <span class="comment">
`quoted-string$P 構文を利用する場合、それによる~escape復元後の値は `token$P ~ABNFに適合し~MUST
◎
When using the quoted-string syntax variant, the value after quoted-string unescaping MUST conform to the 'token' ABNF.
</span>
</pre>

<p>
他の~HTTP~headerと同様、この~headerは，複数行に渡って，分割されたり結合されても~MAYことに注意。
◎
Note that like other HTTP header fields, this header field MAY be split or combined across multiple lines.＼
</p>

<div class="example">
<p>
よって，次は：
◎
Ergo, the following are equivalent:
</p>

<pre>
Sec-WebSocket-Extensions: foo
Sec-WebSocket-Extensions: bar; baz=2
</pre>

<p>
次と正確に等価になる：
◎
is exactly equivalent to
</p>

<pre>
Sec-WebSocket-Extensions: foo, bar; baz=2
</pre>

</div>

<p>
利用されるどの拡張~tokenも，登録済みの~tokenにされ~MUST（ `11.4$secを見よ）。
所与の拡張に伴って給される~parameterは、その拡張~用に定義されたもので~MUST。
~clientは，告知された拡張を申し出るのみであり、~serverがその拡張の利用を指示しない限り，それらを利用しては~MUST_NOTことに注意。
◎
Any extension-token used MUST be a registered token (see Section 11.4). The parameters supplied with any given extension MUST be defined for that extension. Note that the client is only offering to use any advertised extensions and MUST NOT use them unless the server indicates that it wishes to use the extension.
</p>

<p>
拡張の順序は有意であることに注意。
複数の拡張~間のやりとりが拡張を定義する文書において定義されても~MAY。
そのような定義がない場合、~clientの要請に~listされた~headerの順序は，最初の~optionを最高位として, ~clientの選好順を表現しているものと解釈する。
~serverの応答に~listされる拡張は、接続に実際に利用される拡張を表現する。
もし，拡張が~dataや~frame法に手を加えることがある場合、~dataに対する演算の順序は、~opening~handshakeにおける~serverの応答に~listされた拡張の順序と同じであるものと見做されるべきである。
◎
Note that the order of extensions is significant. Any interactions between multiple extensions MAY be defined in the documents defining the extensions. In the absence of such definitions, the interpretation is that the header fields listed by the client in its request represent a preference of the header fields it wishes to use, with the first options listed being most preferable. The extensions listed by the server in response represent the extensions actually in use for the connection. Should the extensions modify the data and/or framing, the order of operations on the data should be assumed to be the same as the order in which the extensions are listed in the server's response in the opening handshake.
</p>

<p>
例えば， 2 つの拡張 `foo^l, `bar^l があって，~serverから送信された
`Sec-WebSocket-Extensions^h ~header値が `foo, bar^l の場合、~dataに対する演算は
— ~dataに対する変更（圧縮など）や~frame法に対する変更を “積み重ねれる” ように —
`foo^l を適用してから `bar^l を適用することになる。
◎
For example, if there are two extensions "foo" and "bar" and if the header field |Sec-WebSocket-Extensions| sent by the server has the value "foo, bar", then operations on the data will be made as bar(foo(data)), be those changes to the data itself (such as compression) or changes to the framing that may "stack".
</p>

<div class="example">
<p>
受容-可能な拡張の~headerの<!-- 非規定 -->例：
◎
Non-normative examples of acceptable extension header fields (note that long lines are folded for readability):
</p>

<pre>
Sec-WebSocket-Extensions: deflate-stream
Sec-WebSocket-Extensions: mux; max-channels=4; flow-control, deflate-stream
Sec-WebSocket-Extensions: private-extension
</pre>

</div>

<p>
~serverは、~clientから要請された 1 個~以上の拡張を
`Sec-WebSocket-Extensions^h ~headerに包含することにより，受容する。
拡張~parameterの解釈、および~clientから要請された~parameterの集合に対し，~serverから妥当な応答を成すための要素については、それらの拡張が個別に定義することになる。
◎
A server accepts one or more extensions by including a |Sec-WebSocket-Extensions| header field containing one or more extensions that were requested by the client. The interpretation of any extension parameters, and what constitutes a valid response by a server to a requested set of parameters by a client, will be defined by each such extension.
</p>

		</section>
		<section id="section-9.2">
<h3 title="Known Extensions">9.2. 既知の拡張</h3>

<p>
拡張は、実装が追加の~protocol特色機能を~opt-inするための仕組みを供する。
この文書は いかなる拡張も定義しないが、実装は別々に定義された拡張を利用して~MAY。
◎
Extensions provide a mechanism for implementations to opt-in to additional protocol features. This document doesn't define any extension, but implementations MAY use extensions defined separately.
</p>

		</section>
	</section>
	<section id="section-10">
<h2 title="Security Considerations">10. ~security上の考慮点</h2>

<p>
この節では、~WebSocket~Protocolに適用-可能な，いくつかの~security上の考慮点について述べる。
特定の~security上の考慮点は、この節の下位節にて述べられる。
◎
This section describes some security considerations applicable to the WebSocket Protocol. Specific security considerations are described in subsections of this section.
</p>

		<section id="section-10.1">
<h3 title="Non-Browser Clients">10.1. 非~browser~client</h3>

<p>
~WebSocket~Protocolは、~web~browserなどの信用できる~appの内側で走っている悪意的な~JSから保護する。
例えば，
`Origin^h ~headerの検査（下を見よ）など。
追加の詳細は `1.6$secを見よ。
そのような前提は、より<!--  -->
~capableな~clientの場合には成立しない。
◎
The WebSocket Protocol protects against malicious JavaScript running inside a trusted application such as a web browser, for example, by checking of the |Origin| header field (see below). See Section 1.6 for additional details. Such assumptions don't hold true in the case of a more-capable client.
</p>

<p>
この~protocolは、~web~page内の~scriptからの利用が想定されているが、~hostから直にも利用もできる。
そのような~hostは自身に利するように動作するので、~serverを誤誘導するように偽装された `Origin^h ~headerも送信し得る。
したがって、~serverは，既知の生成元からの~scriptと直にやりとりしていると見做すことには注意深くあるべきで、予期されない仕方で~accessされている可能性を考慮しなければならない。
特に、~serverは，どの入力も妥当であるものと信用すべきではない。
◎
While this protocol is intended to be used by scripts in web pages, it can also be used directly by hosts. Such hosts are acting on their own behalf and can therefore send fake |Origin| header fields, misleading the server. Servers should therefore be careful about assuming that they are talking directly to scripts from known origins and must consider that they might be accessed in unexpected ways. In particular, a server should not trust that any input is valid.
</p>

<p class="example">例：
~serverは、入力を~SQL~queryの一部に利用する際に，自身が~SQL注入の感染源にならないように、すべての入力~textを~SQL~serverに渡す前に~escapeすべきである。
◎
EXAMPLE: If the server uses input as part of SQL queries, all input text should be escaped before being passed to the SQL server, lest the server be susceptible to SQL injection.
</p>

		</section>
		<section id="section-10.2">
<h3 title="Origin Considerations">10.2. 生成元についての考慮点</h3>

<p>
任意の~web~pageでなく，一定の~siteのみに属する~web~pageからの入力を処理することが想定されている~serverは、
`Origin^h ~headerの値が期待されている生成元であるかどうか，検証する~SHOULDである。
生成元が~serverにとって受容-可能でない場合、［
`応答~code$ `403$st `Forbidden^ph
］を包含させた返信により，~WebSocket~handshakeに応答する~SHOULDである。
◎
Servers that are not intended to process input from any web page but only for certain sites SHOULD verify the |Origin| field is an origin they expect. If the origin indicated is unacceptable to the server, then it SHOULD respond to the WebSocket handshake with a reply containing HTTP 403 Forbidden status code.
</p>

<p>
`Origin^h ~headerは、概して，信用できる~clientの文脈の下で実行されている~JS~appの作者が 信用できない主体であるときの 攻撃~事例から保護する。
<!--  -->
~client自身は、~serverと接触することができ，
`Origin^h ~headerの仕組みにより，その種の通信~特権を~JS~appにまで広げるかどうかを決定する。
その意図は、非~browserによる接続の確立を防止するのではなく、信用できる~browserが潜在的に悪意的な~JSの制御~下にあっても，~WebSocket~handshakeを偽装できなくする所にある。
◎
The |Origin| header field protects from the attack cases when the untrusted party is typically the author of a JavaScript application that is executing in the context of the trusted client. The client itself can contact the server and, via the mechanism of the |Origin| header field, determine whether to extend those communication privileges to the JavaScript application. The intent is not to prevent non-browsers from establishing connections but rather to ensure that trusted browsers under the control of potentially malicious JavaScript cannot fake a WebSocket handshake.
</p>

		</section>
		<section id="section-10.3">
<h3 title="Attacks On Infrastructure (Masking)">10.3. 通信基盤に対する攻撃（~mask法）</h3>

<p>
端点が~WebSocketを介した攻撃の標的になることに加えて、~proxyなどの，~web通信基盤の他の部分も攻撃の対象になり得る。
◎
In addition to endpoints being the target of attacks via WebSockets, other parts of web infrastructure, such as proxies, may be the subject of an attack.
</p>

<p>
この~protocolが開発されていくに伴い、実~netに配備されている~caching~proxyを汚染に導くような，~proxyに対する攻撃の~classを実証する実験が実施された
`TALKING$r
。
攻撃の一般的な手口は、 “攻撃者の” 制御~下にある~serverへの接続を確立させ、
~WebSocket~Protocolによる接続の確立を真似るように~HTTP接続~上で`~Upgrade$を遂行し、その~Upgradeされた接続を通じて，特定の既知の~resourceに対する `GET^hm 要請に似せるように（攻撃の中では、ごくありふれた，広告配信~network上の~access~~記録や~resource用の~scriptに似た何か），後続して~dataを送信するものであった。
~remoteの~serverは、偽装された `GET^hm 要請に対する応答に似た何かで応答することになるであろう。
この応答が 0 でない割合の中継点に~cacheされることにより，~cacheが汚染される。
この攻撃による結果、利用者が攻撃者の制御~下の~web~siteを気付かずに訪問したとするとき、攻撃者はその利用者の~cacheや同じ~cacheを共有する他の利用者のそれを汚染することにより，他の生成元に属する悪意的な~scriptを走らすこともでき、~webの~security~modelが危うくされる。
◎
As this protocol was being developed, an experiment was conducted to demonstrate a class of attacks on proxies that led to the poisoning of caching proxies deployed in the wild [TALKING]. The general form of the attack was to establish a connection to a server under the "attacker's" control, perform an UPGRADE on the HTTP connection similar to what the WebSocket Protocol does to establish a connection, and subsequently send data over that UPGRADEd connection that looked like a GET request for a specific known resource (which in an attack would likely be something like a widely deployed script for tracking hits or a resource on an ad-serving network). The remote server would respond with something that looked like a response to the fake GET request, and this response would be cached by a nonzero percentage of deployed intermediaries, thus poisoning the cache. The net effect of this attack would be that if a user could be convinced to visit a website the attacker controlled, the attacker could potentially poison the cache for that user and other users behind the same cache and run malicious script on other origins, compromising the web security model.
</p>

<p>
中継点に対するその種の攻撃を避けるためには、［
~appから給された~dataに，~HTTPに準じない~frame法を施す
］だけでは足らない。
それぞれの適合しない中継点が［
そのような非~HTTP~frame法を素通りさせずに，~frame~payloadに対し不正に動作しているかどうか
］を、網羅的に発見したり試験することは不可能なので。
したがって，防御策として、~clientから~serverへの~dataすべてに~maskを施すことにより，［
~remoteの~script（攻撃者）が 伝送路に出現する~dataがどう送信されるか
］を制御できなくし、［
中継点から誤って~HTTP要請に解釈され得るような~message
］は構築できないようにされている。
◎
To avoid such attacks on deployed intermediaries, it is not sufficient to prefix application-supplied data with framing that is not compliant with HTTP, as it is not possible to exhaustively discover and test that each nonconformant intermediary does not skip such non-HTTP framing and act incorrectly on the frame payload. Thus, the defense adopted is to mask all data from the client to the server, so that the remote script (attacker) does not have control over how the data being sent appears on the wire and thus cannot construct a message that could be misinterpreted by an intermediary as an HTTP request.
</p>

<p>
~clientは、［
~dataを供する末端~appからは予測できないような~algo
］を用いて，各~frameごとに新たな~mask用~keyを選ば~MUST。
例えば、各~mask用~keyを暗号論的に強い乱数生成器から取り出すなど。
同じ~keyが用いられたり，次の~keyがどう選ばれるかについて解読可能な~patternが存在する場合、攻撃者は~maskされた際に~HTTP要請に見え得る~messageを送信-可能になる（攻撃者が伝送路~上の目的の~messageを得て，次に用いられる~mask用~keyにより~maskを施せば、~clientが~mask用~keyを適用したときに，~dataの~maskは実質的に解かれることになる。）
◎
Clients MUST choose a new masking key for each frame, using an algorithm that cannot be predicted by end applications that provide data. For example, each masking could be drawn from a cryptographically strong random number generator. If the same key is used or a decipherable pattern exists for how the next key is chosen, the attacker can send a message that, when masked, could appear to be an HTTP request (by taking the message the attacker wishes to see on the wire and masking it with the next masking key to be used, the masking key will effectively unmask the data when the client applies it).
</p>

<p>
ひとたび~clientから~frameの伝送が始まったなら、［
その~frameの~payload（~appから給された~data）は，~appから改変されない
］ようにすることが必要とされる。
さもなくば，攻撃者は、長い~frameを送信して，初期~dataが既知の値である所から（例えばすべて 0 ）［
~dataの最初の部分を受領した際に利用されている~mask用~key
］を算出し、［
~frame内のまだ送信されていない~dataに対し，~maskされた際に~HTTP要請に見えるように手を加える
］ことが可能になる（これは前~段落で述べた、既知の, または予測-可能な~mask用~keyを用いたときの問題と本質的に同じである）。
追加の~dataが送信されたり, 送信されつつある~dataが何らかの方法で変更された場合、その新たな／変更された~dataは，新たな~frame内で, したがって新たな~mask用~keyにより，送信されなければならない。
手短かに言えば、~frameの伝送が始まった時点から，その内容に~remoteの~script（~app）から手が加えられるようになってはならない。
◎
It is also necessary that once the transmission of a frame from a client has begun, the payload (application-supplied data) of that frame must not be capable of being modified by the application. Otherwise, an attacker could send a long frame where the initial data was a known value (such as all zeros), compute the masking key being used upon receipt of the first part of the data, and then modify the data that is yet to be sent in the frame to appear as an HTTP request when masked. (This is essentially the same problem described in the previous paragraph with using a known or predictable masking key.) If additional data is to be sent or data to be sent is somehow changed, that new or changed data must be sent in a new frame and thus with a new masking key. In short, once transmission of a frame begins, the contents must not be modifiable by the remote script (application).
</p>

<p>
対抗して保護すべき脅威~modelは、~clientが送信する~dataが~HTTP要請として現れることである。
したがって、~maskすることが必要とされる~channelは，~clientから~serverへの~dataになる。
~serverから~clientへの~dataは，応答に似せ得るが、そのためには~clientも要請を偽造できなければならない。
そのようなわけで、両~方向とも~dataを~maskする必要があるとは判断されていない（~serverから~clientへの~dataは~maskされない）。
◎
The threat model being protected against is one in which the client sends data that appears to be an HTTP request. As such, the channel that needs to be masked is the data from the client to the server. The data from the server to the client can be made to look like a response, but to accomplish this request, the client must also be able to forge a request. As such, it was not deemed necessary to mask data in both directions (the data from the server to the client is not masked).
</p>

<p>
~mask法により供される保護にも関わらず，適合しない~HTTP~proxyは、依然として，~maskを適用しない~clientと~serverによる，この種の攻撃からの汚染に脆弱であることになる。
◎
Despite the protection provided by masking, non-compliant HTTP proxies will still be vulnerable to poisoning attacks of this type by clients and servers that do not apply masking.
</p>

		</section>
		<section id="section-10.4">
<h3 title="Implementation-Specific Limits">10.4. 実装に特有の制限</h3>

<p>
複数~frameからの再構築-後の~frame~sizeまたは総~message~sizeに対し，自身に, あるいは~platformに特有の制限がある実装は、これらの制限の超過から自身を保護し~MUST。
（例えば，悪意的な端点は、単独の巨大~frame（例えば，~sizeが 2 の 60 乗）を送信したり, 断片化された~messageの一部をなす 小~frameの長大な~streamを送信することにより，相手の端点の記憶域の枯渇や~DoS攻撃を仕掛け得る。）
そのような実装は、~frame~size, および複数~frameからの再構築-後の総~message~sizeに制限を課する~SHOULDである。
◎
Implementations that have implementation- and/or platform-specific limitations regarding the frame size or total message size after reassembly from multiple frames MUST protect themselves against exceeding those limits. (For example, a malicious endpoint can try to exhaust its peer's memory or mount a denial-of-service attack by sending either a single big frame (e.g., of size 2**60) or by sending a long stream of small frames that are a part of a fragmented message.) Such an implementation SHOULD impose a limit on frame sizes and the total message size after reassembly from multiple frames.
</p>

		</section>
		<section id="section-10.5">
<h3 title="WebSocket Client Authentication">10.5. ~WebSocket~client認証</h3>

<p>
この~protocolは、~WebSocket~handshakeの間に~serverが~clientを認証できるような，特定0の仕方は規定しない。
~WebSocket~serverは、~cookie, ~HTTP認証, ~TLS認証など，汎用~HTTP~serverにて可用な，任意の~client認証の仕組みを利用できる。
◎
This protocol doesn't prescribe any particular way that servers can authenticate clients during the WebSocket handshake. The WebSocket server can use any client authentication mechanism available to a generic HTTP server, such as cookies, HTTP authentication, or TLS authentication.
</p>

		</section>
		<section id="section-10.6">
<h3 title="Connection Confidentiality and Integrity">10.6. 接続の機密性と完全性</h3>

<p>
接続の機密性と完全性は、~WebSocket~Protocolを~TLS（ `wss^sc ~URI）を通して稼働させることにより供される。
~WebSocketの実装は、~TLSを~supportし~MUSTことに加え，相手の端点と通信するときはそれを使役する~SHOULDである。
◎
Connection confidentiality and integrity is provided by running the WebSocket Protocol over TLS (wss URIs). WebSocket implementations MUST support TLS and SHOULD employ it when communicating with their peers.
</p>

<p>
~TLSを利用する接続において~TLSが供する利点の大きさは、~TLS~handshakeの間に折衝される~algoの強度に大きく依存する。
例えば、一部の~TLS暗号の仕組みは接続の機密性を供さない。
適度な~levelの保護を達成するためには，~clientは、 Strong TLS ~algoのみを利用するべきである。
"Web Security Context：User Interface Guidelines" `W3C.REC-wsc-ui-20100812$r
に， Strong TLS ~algoを成す要素について論じられている。
`RFC5246$r の
<a href="~IETF/rfc5246#appendix-A.5">Appendix A.5</a>
と
<a href="~IETF/rfc5246#appendix-D.3">Appendix D.3</a>
にて、追加の手引きを見られる。
◎
For connections using TLS, the amount of benefit provided by TLS depends greatly on the strength of the algorithms negotiated during the TLS handshake. For example, some TLS cipher mechanisms don't provide connection confidentiality. To achieve reasonable levels of protection, clients should use only Strong TLS algorithms. "Web Security Context: User Interface Guidelines" [W3C.REC-wsc-ui-20100812] discusses what constitutes Strong TLS algorithms. [RFC5246] provides additional guidance in Appendix A.5 and Appendix D.3.
</p>

		</section>
		<section id="section-10.7">
<h3 title="Handling of Invalid Data">10.7. 妥当でない~dataの取扱い</h3>

<p>
着信~dataの妥当性は、~client, ~serverの両者において~~検証され~MUST。
どの時点であれ、端点は、妥当でない~data
— 自身が解し得ない, または 入力の安全性を決定するにあたって何らかの判定基準に違反している~data, あるいは期待される値に対応しない~opening~handshake（例えば，~clientの要請内の不正な~pathや生成元） —
に直面した場合には，~TCP接続を落としても~MAY。
妥当でない~dataが~WebSocket~handshakeの成功-後に受信された場合、端点は、
`~WebSocket接続を~close$しようとする前に，適切な`~status~code$を伴う `Close$fr ~frameを送信する~SHOULDである。
適切な`~status~code$を伴う `Close$fr ~frameの利用は、問題の診断を助ける。
~WebSocket~handshakeの間に妥当でない~dataが送信されてきた場合、~serverは適切な`応答~code$を返す~SHOULDである。
◎
Incoming data MUST always be validated by both clients and servers. If, at any time, an endpoint is faced with data that it does not understand or that violates some criteria by which the endpoint determines safety of input, or when the endpoint sees an opening handshake that does not correspond to the values it is expecting (e.g., incorrect path or origin in the client request), the endpoint MAY drop the TCP connection. If the invalid data was received after a successful WebSocket handshake, the endpoint SHOULD send a Close frame with an appropriate status code (Section 7.4) before proceeding to _Close the WebSocket Connection_. Use of a Close frame with an appropriate status code can help in diagnosing the problem. If the invalid data is sent during the WebSocket handshake, the server SHOULD return an appropriate HTTP [RFC2616] status code.
</p>

<p>
誤った符号化方式を用いた~text~dataの送信から生じる，共通的な~security問題の~classがある。
この~protocolは、種別 `Text$fr の~messageは，（ `Binary$fr その他の種別とは対照的に）~UTF-8符号化~dataを包含するものと指定している。
長さも依然として指示されており、この~protocolを実装する~appは，~frameが実際に終端する所を決定する際に 長さを利用すべきであるが、不適正な符号化方式による~dataの送信は，依然として，この~protocol上に構築された~appの前提を覆し得るものであり、~dataの誤解釈による，~dataの喪失や潜在的~security~bugを導き得る。
◎
A common class of security problems arises when sending text data using the wrong encoding. This protocol specifies that messages with a Text data type (as opposed to Binary or other types) contain UTF-8-encoded data. Although the length is still indicated and applications implementing this protocol should use the length to determine where the frame actually ends, sending data in an improper encoding may still break assumptions that applications built on top of this protocol may make, leading to anything from misinterpretation of data to loss of data or potential security bugs.
</p>

		</section>
		<section id="section-10.8">
<h3 title="Use of SHA-1 by the WebSocket Handshake">10.8. ~WebSocket~handshakeによる~SHA-1 の利用</h3>

<p>
この文書で述べられた~WebSocket~handshakeは、衝突~耐性や第二原像攻撃
【`<a href="https://ja.wikipedia.org/wiki/%E5%8E%9F%E5%83%8F%E6%94%BB%E6%92%83" >参考</a>^_】
に対する耐性など，いかなる~SHA-1 の~propertyにも依存しない（ `RFC4270$r に述べられるように）。
◎
The WebSocket handshake described in this document doesn't depend on any security properties of SHA-1, such as collision resistance or resistance to the second pre-image attack (as described in [RFC4270]).
</p>

		</section>
	</section>

	<section id="section-11">
<h2 title="IANA Considerations">11. IANA Considerations</h2>

		<section id="section-11.1">
<h3 title="Registration of New URI Schemes">11.1. 新たな~URI~schemeの登録</h3>

			<section id="section-11.1.1">
<h4 title="Registration of &quot;ws&quot; Scheme">11.1.1. `ws^sc, `wss^sc ~schemeの登録</h4>

<p>
［
`ws^sc ／ `wss^sc
］~URIは、~WebSocket~serverと~resource名を識別する。
加えて， `wss^sc ~URIは、その接続を通る流通が~TLSにより保護されることになることを指示する（~dataの機密性と完全性および端点の認証などの，~TLSの標準的な利点も含め）。
◎
A |ws| URI identifies a WebSocket server and resource name.
</p>

<dl>
	<dt>
~URI~scheme名
◎
URI scheme name
</dt>
	<dd>
`ws^sc ／ `wss^sc
</dd>

	<dt>位置付け
◎
Status
</dt>
	<dd>
恒久的
◎
Permanent
</dd>

	<dt>
~URI~scheme構文
◎
URI scheme syntax
</dt>
	<dd>
<p>
~ABNF`RFC5234$r 構文および
~URI仕様 `RFC3986$r の~ABNFの終端記号を用いて：
◎
Using the ABNF [RFC5234] syntax and ABNF terminals from the URI specification [RFC3986]:
</p>

<pre class="ABNF">
( "ws:" / "wss:" ) "//" `authority$P `path-abempty$P [ "?" `query$P ]
</pre>

<p>
`path-abempty$P と `query$P `RFC3986$r 成分は、欲された~serviceの種類を識別するために，~serverへ送信される~resource名を形成する。
他の成分は、 `RFC3986$r に述べられる意味を持つ。
◎
The &lt;path-abempty&gt; and &lt;query&gt; [RFC3986] components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in [RFC3986].
</p>

	</dd>

	<dt>
~URI~scheme意味論
◎
URI scheme semantics
</dt>
	<dd>
［
`ws^sc ／ `wss^sc 
］~scheme用の唯一の運用は、~WebSocket~Protocolを利用して［
接続 ／ ~TLSで暗号化された接続
］を~openすることである。
◎
The only operation for this scheme is to open a connection using the WebSocket Protocol.
</dd>

	<dt>符号化方式についての考慮点
◎
Encoding considerations
</dt>
	<dd>
上で定義された構文から除外された~host成分~内の文字は、
`RFC3987$r またはその後継仕様の指定に従って，~Unicodeから~ASCIIに変換され~MUST。
~schemeに基づく正規化の目的においては、~host成分の Internationalized Domain Name （ IDN ）形とそれらの~punycode【<a href="https://ja.wikipedia.org/wiki/Punycode" >
~punycode</a>】
への変換は，等価なものと見なされる（ `3987-5.3.3$sec を見よ）。
◎
Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII as specified in [RFC3987] or its replacement. For the purposes of scheme-based normalization, Internationalized Domain Name (IDN) forms of the host component and their conversions to punycode are considered equivalent (see Section 5.3.3 of [RFC3987]).
</dd>

	<dd>
上で定義された構文から除外された，他の成分~内の文字は、まず，~UTF-8に符号化した上で，結果の~byte列を［
~URI `RFC3986$r, ~IRI `RFC3987$r
］仕様の定義に従って，~percent符号化形に置換することにより、~Unicodeから~ASCIIへ変換され~MUST。
◎
Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI [RFC3986] and Internationalized Resource Identifier (IRI) [RFC3987] specifications.
</dd>

	<dt>この~URI~scheme名を利用する~app／~protocol
◎
Applications/protocols that use this URI scheme name
</dt>
	<dd>
`ws^sc に対しては ~WebSocket~Protocol／
`wss^sc に対しては ~TLSを通した~WebSocket~Protocol
</dd>

	<dt>相互運用性についての考慮点
◎
Interoperability considerations
</dt>
	<dd>
~WebSocketの利用は~HTTP~version 1.1 以上の利用を要求する。
◎
Use of WebSocket requires use of HTTP version 1.1 or higher.
</dd>

	<dt>
~security上の考慮点
◎
Security considerations
</dt>
	<dd>
<a href="#section-10"> ~security上の考慮点</a>
節を見よ。
◎
See "Security Considerations" section.
</dd>

	<dt>連絡先
◎
Contact
</dt>
	<dd>HYBI WG &lt;hybi@ietf.org&gt;</dd>

	<dt>作成変更管理
◎
Author/Change controller
</dt>
	<dd>IETF &lt;iesg@ietf.org&gt;</dd>

	<dt>参照
◎
References
</dt>
	<dd>`RFC 6455$</dd>
</dl>

			</section>
			<section id="section-11.1.2">
<h4 title="Registration of &quot;ws&quot; Scheme">11.1.2. `wss^sc ~schemeの登録</h4>

<p>
【この節の内容は、`11.1.1$sec に集約。】
◎
A |wss| URI identifies a WebSocket server and resource name and indicates that traffic over that connection is to be protected via TLS (including standard benefits of TLS such as data confidentiality and integrity and endpoint authentication).
◎
URI scheme name
• wss
◎
Status
• Permanent
◎
URI scheme syntax
• Using the ABNF [RFC5234] syntax and ABNF terminals from the URI specification [RFC3986]:
• "wss:" "//" authority path-abempty [ "?" query ]
• The &lt;path-abempty&gt; and &lt;query&gt; components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in [RFC3986].
◎
URI scheme semantics
• The only operation for this scheme is to open a connection using the WebSocket Protocol, encrypted using TLS.
◎
Encoding considerations
• Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII as specified in [RFC3987] or its replacement. For the purposes of scheme-based normalization IDN forms of the host component and their conversions to punycode are considered equivalent (see Section 5.3.3 of [RFC3987]).
• Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI [RFC3986] and IRI [RFC3987] specifications.
◎
Applications/protocols that use this URI scheme name
• WebSocket Protocol over TLS
◎
Interoperability considerations
• Use of WebSocket requires use of HTTP version 1.1 or higher.
◎
Security considerations
• See "Security Considerations" section.
◎
Contact
◎
Author/Change controller
• IETF &lt;iesg@ietf.org&gt;
◎
References
• RFC 6455
</p>

			</section>
		</section>
		<section id="section-11.2">
<h3 title="Registration of the &quot;WebSocket&quot; HTTP Upgrade Keyword">11.2. "WebSocket" ~HTTP~Upgrade~keywordの登録</h3>

<p>
この節では、 `RFC2817$r に従って， HTTP Upgrade Tokens Registry に登録された~keywordを定義する。
◎
This section defines a keyword registered in the HTTP Upgrade Tokens Registry as per RFC 2817 [RFC2817].
</p>

<dl>

	<dt>
~tokenの名前
◎
Name of token
</dt>
	<dd>`WebSocket^P</dd>

	<dt>作成変更管理
◎
Author/Change controller
</dt>
	<dd>IETF &lt;iesg@ietf.org&gt;</dd>
	
	<dt>連絡先
◎
Contact
</dt>
	<dd>HYBI &lt;hybi@ietf.org&gt;</dd>
	
	<dt>参照
◎
References
</dt>
	<dd>`RFC 6455$</dd>

</dl>

		</section>
		<section id="section-11.3">
<h3 title="Registration of New HTTP Header Fields">11.3. 新たな~HTTP~headerの登録</h3>

<div>
<p>
この節とその各 下位節では、
Permanent Message Header Field Names ~registry `RFC3864$r
に登録された~headerを述べる。
</p>

<dl>
	<dt>~header名</dt>
	<dd>`Sec-WebSocket-Key^h</dd>
	<dd>`Sec-WebSocket-Extensions^h</dd>
	<dd>`Sec-WebSocket-Accept^h</dd>
	<dd>`Sec-WebSocket-Protocol^h</dd>
	<dd>`Sec-WebSocket-Version^h</dd>

	<dt>適用-可能な~protocol</dt>
	<dd>http</dd>

	<dt>位置付け</dt>
	<dd>標準</dd>

	<dt>作成変更管理</dt>
	<dd>IETF</dd>

	<dt>仕様~文書</dt>
	<dd>`RFC 6455$</dd>

	<dt>関連情報</dt>
	<dd>
これらの~headerが利用されるのは、~WebSocket~opening~handshakeに限られる。
</dd>
</dl>

◎
↓</div>

			<section id="section-11.3.1">
<h4>11.3.1. `Sec-WebSocket-Key^h</h4>

<p>
【この節の他の内容は、`11.3$secに集約。】
◎
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
◎
Header field name
• Sec-WebSocket-Key
Applicable protocol
• http
Status
• standard
Author/Change controller
• IETF
Specification document(s)
• RFC 6455
Related information
• This header field is only used for WebSocket opening handshake.
</p>


<p>
`Sec-WebSocket-Key^h ~headerは、~WebSocket~opening~handshake内で利用される。
これは、~serverが妥当な~WebSocket~opening~handshakeを受信したことを立証するための一環として，~clientから~serverへ送信されるものであり、~serverが利用する情報の一部を供する。
これは、 "疑わない" （ unsuspecting ）~WebSocket~serverへ向けて~data送信を濫用する非~WebSocket~client（例えば，~HTTP~client）からの接続を，~serverが受容しないようにすることを助ける。
◎
The |Sec-WebSocket-Key| header field is used in the WebSocket opening handshake. It is sent from the client to the server to provide part of the information used by the server to prove that it received a valid WebSocket opening handshake. This helps ensure that the server does not accept connections from non-WebSocket clients (e.g., HTTP clients) that are being abused to send data to unsuspecting WebSocket servers.
</p>

<p>
`Sec-WebSocket-Key^h ~headerは、一個の~HTTP要請~内に複数回~出現しては~MUST_NOT。
◎
The |Sec-WebSocket-Key| header field MUST NOT appear more than once in an HTTP request.
</p>

			</section>
			<section id="section-11.3.2">
<h4>11.3.2. `Sec-WebSocket-Extensions^h</h4>

<p>
【この節の他の内容は、`11.3$secに集約。】
◎
This section describes a header field for registration in the Permanent Message Header Field Names registry [RFC3864].
◎
Header field name
• Sec-WebSocket-Extensions
Applicable protocol
• http
Status
• standard
Author/Change controller
• IETF
Specification document(s)
• RFC 6455
Related information
• This header field is only used for WebSocket opening handshake.
</p>

<p>
`Sec-WebSocket-Extensions^h ~headerは、~WebSocket~opening~handshake内で利用される。
~clientから~serverへ初期~時に送信され，後続して，接続の間に利用する~protocol~levelの一連の拡張に同意したことを示すため，~serverから~clientへ送信される。
◎
The |Sec-WebSocket-Extensions| header field is used in the WebSocket opening handshake. It is initially sent from the client to the server, and then subsequently sent from the server to the client, to agree on a set of protocol-level extensions to use for the duration of the connection.
</p>

<p>
一個の~HTTP要請~内に複数の `Sec-WebSocket-Extensions^h ~headerが出現しても~MAY（すべての値を包含してる単独の `Sec-WebSocket-Extensions^h ~headerと論理的に同じになる）。
<del>
しかしながら，一個の~HTTP応答~内では、複数の
`Sec-WebSocket-Extensions^h ~headerが出現しては~MUST_NOT。
</del>
【`3433$errataによる修正（ Verified ）：】
<ins>
また、一個の~HTTP応答~内に複数の `Sec-WebSocket-Extensions^h ~headerが出現しても~MAY（すべての値を包含してる単独の `Sec-WebSocket-Extensions^h ~headerと論理的に同じになる）。
</ins>

<span lang="en">
The |Sec-WebSocket-Extensions| header field MAY appear multiple times in an HTTP request (which is logically the same as a single |Sec-WebSocket-Extensions| header field that contains all values. <del>However, the |Sec-WebSocket-Extensions| header field MUST NOT appear more than once in an HTTP response.</del>
<ins>The |Sec-WebSocket-Extensions| header field MAY appear multiple 
times in an HTTP response (which is logically the same as a single
|Sec-WebSocket-Extensions| header field that contains all values).</ins>
</span></p>

			</section>
			<section id="section-11.3.3">
<h4>11.3.3. `Sec-WebSocket-Accept^h</h4>

<p>
【この節の他の内容は、`11.3$secに集約。】
◎
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
◎
Header field name
• Sec-WebSocket-Accept
Applicable protocol
• http
Status
• standard
Author/Change controller
• IETF
Specification document(s)
• RFC 6455
Related information
• This header field is only used for the WebSocket opening handshake.
</p>

<p>
`Sec-WebSocket-Accept^h ~headerは、~WebSocket~opening~handshake内で利用される。
それは、~serverが~WebSocket接続に起動するつもりがあることを立証するために，~serverから~clientへ送信される。
◎
The |Sec-WebSocket-Accept| header field is used in the WebSocket opening handshake. It is sent from the server to the client to confirm that the server is willing to initiate the WebSocket connection.
</p>

<p>
`Sec-WebSocket-Accept^h ~headerは、一個の~HTTP応答~内に複数回~出現しては~MUST_NOT。
◎
The |Sec-WebSocket-Accept| header MUST NOT appear more than once in an HTTP response.
</p>

			</section>
			<section id="section-11.3.4">
<h4>11.3.4. `Sec-WebSocket-Protocol^h</h4>

<p>
【この節の他の内容は、`11.3$secに集約。】
◎
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
◎
Header field name
• Sec-WebSocket-Protocol
Applicable protocol
• http
Status
• standard
Author/Change controller
• IETF
Specification document(s)
• RFC 6455
Related information
• This header field is only used for the WebSocket opening handshake.
</p>

<p>
`Sec-WebSocket-Protocol^h ~headerは~WebSocket~opening~handshake内で利用される。
接続の下位protocolを確認するために、~clientから~serverへ送信され，~serverから~clientへ返信される。
これにより，~scriptは、下位protocolを選択した上で，~serverがその下位protocolの役務に同意したことを確かめられるようになる。
◎
The |Sec-WebSocket-Protocol| header field is used in the WebSocket opening handshake. It is sent from the client to the server and back from the server to the client to confirm the subprotocol of the connection. This enables scripts to both select a subprotocol and be sure that the server agreed to serve that subprotocol.
</p>

<p><!-- copy* -->
一個の~HTTP要請~内に複数の
`Sec-WebSocket-Protocol^h ~headerが出現しても~MAY（すべての値を包含している単独の `Sec-WebSocket-Protocol^h ~headerと論理的に同じ）。
しかしながら，一個の~HTTP応答~内では，複数の
`Sec-WebSocket-Protocol^h ~headerが出現しては~MUST_NOT。
◎
The |Sec-WebSocket-Protocol| header field MAY appear multiple times in an HTTP request (which is logically the same as a single |Sec-WebSocket-Protocol| header field that contains all values). However, the |Sec-WebSocket-Protocol| header field MUST NOT appear more than once in an HTTP response.
</p>


			</section>
			<section id="section-11.3.5">
<h4>11.3.5. `Sec-WebSocket-Version^h</h4>

<p>
【この節の他の内容は、`11.3$secに集約。】
◎
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
◎
Header field name
• Sec-WebSocket-Version
Applicable protocol
• http
Status
• standard
Author/Change controller
• IETF
Specification document(s)
• RFC 6455
Related information
• This header field is only used for the WebSocket opening handshake.
</p>

<p>
`Sec-WebSocket-Version^h ~headerは~WebSocket~opening~handshakeにおいて利用される。
これは接続の~protocol~versionを指示するために，~clientから~serverへ送信される。
これにより、~serverは，~opening~handshakeとその~dataに後続して送信された~dataを正しく解釈でき、~serverが~dataを安全な方式で解釈できない場合には 接続を~closeできるようになる。
`Sec-WebSocket-Version^h ~headerは、~clientから受信された~versionが~serverが解せる~versionに合致しないときの~WebSocket~handshake~errorの際にも，~serverから~clientへ送信される。
その場合、この~headerは，~serverで~supportされる~protocol~versionを含む。
◎
The |Sec-WebSocket-Version| header field is used in the WebSocket opening handshake. It is sent from the client to the server to indicate the protocol version of the connection. This enables servers to correctly interpret the opening handshake and subsequent data being sent from the data, and close the connection if the server cannot interpret that data in a safe manner. The |Sec-WebSocket-Version| header field is also sent from the server to the client on WebSocket handshake error, when the version received from the client does not match a version understood by the server. In such a case, the header field includes the protocol version(s) supported by the server.
</p>

<p>
［
より高い~version番号が より低い~version番号と後方互換になる
］とする必要は、期待されていないことに注意。
◎
Note that there is no expectation that higher version numbers are necessarily backward compatible with lower version numbers.
</p>

<p><!-- copy* -->
一個の~HTTP要請~内に
`Sec-WebSocket-Version^h ~headerが複数回~出現しても~MAY（すべての値を包含している単独の
`Sec-WebSocket-Version^h ~headerと論理的に同じ）。
しかしながら，一個の~HTTP応答~内では、
`Sec-WebSocket-Version^h ~headerが複数回~出現しては~MUST_NOT。
◎
The |Sec-WebSocket-Version| header field MAY appear multiple times in an HTTP response (which is logically the same as a single |Sec-WebSocket-Version| header field that contains all values). However, the |Sec-WebSocket-Version| header field MUST NOT appear more than once in an HTTP request.
</p>

			</section>
		</section>
		<section id="section-11.4">
<h3 title="WebSocket Extension Name Registry">11.4. ~WebSocket拡張~名~registry</h3>

<p>
この仕様は、 `RFC5226$r に設けられた原則に則り，~WebSocket~Protocolと併用される~WebSocket拡張~名 用の、新たな~IANA~registryを作成する。
◎
This specification creates a new IANA registry for WebSocket Extension names to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].
</p>

<p>
この~registryの一部として、~IANAは以下の情報を保守する：
◎
As part of this registry, IANA maintains the following information:
</p>

<dl>

	<dt>拡張~識別子
◎
Extension Identifier
</dt>
	<dd>
この仕様の `11.3.2$secにて登録される，
`Sec-WebSocket-Extensions^h ~headerに利用されることになる拡張の識別子。
値は、この仕様の `9.1$secで定義されている `extension-token$P に課される要件に適合しなければならない。
◎
The identifier of the extension, as will be used in the |Sec-WebSocket-Extensions| header field registered in Section 11.3.2 of this specification. The value must conform to the requirements for an extension-token as defined in Section 9.1 of this specification.
</dd>

	<dt>拡張~共通名
◎
Extension Common Name
</dt>
	<dd>
拡張を一般に参照するための，拡張の名前。
◎
The name of the extension, as the extension is generally referred to.
</dd>

	<dt>拡張~定義
◎
Extension Definition
</dt>
	<dd>
~WebSocket~Protocolと伴用される拡張が定義される文書への参照
◎
A reference to the document in which the extension being used with the WebSocket Protocol is defined.
</dd>

	<dt>既知の互換でない拡張
◎
Known Incompatible Extensions
</dt>
	<dd>
この拡張と互換でないことが既知である拡張の，識別子の~list
◎
A list of extension identifiers with which this extension is known to be incompatible.
</dd>

</dl>

<p>
~WebSocket拡張~名は、
"First Come First Served"~IANA登録~policy `RFC5226$r
の対象になる。
◎
WebSocket Extension names are to be subject to the "First Come First Served" IANA registration policy [RFC5226].
</p>

<p>
この~registryには初期~値は無い。
◎
There are no initial values in this registry.
</p>

		</section>
		<section id="section-11.5">
<h3 title="WebSocket Subprotocol Name Registry">11.5. ~WebSocket下位protocol名~registry</h3>

<p><!-- copy* -->
この仕様は、 `RFC5226$r に設けられた原則に則り，~WebSocket~Protocolと併用される~WebSocket下位protocol名 用の、新たな~IANA~registryを作成する。
◎
This specification creates a new IANA registry for WebSocket Subprotocol names to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].
</p>

<p><!-- copy -->
この~registryの一部として、~IANAは以下の情報を保守する：
◎
As part of this registry, IANA maintains the following information:
</p>

<dl>
	<dt>下位protocol識別子
◎
Subprotocol Identifier
</dt>
	<dd>
`11.3.4$secにて登録される `Sec-WebSocket-Protocol^h ~headerに利用されることになる，下位protocolの識別子。
値は、 `4.1$secの<a href="#subprotocol-req">第 10 項</a>に与えた要件に適合しなければならない
— すなわち，値は、 `token$P `HTTP$r でなければならない。
◎
The identifier of the subprotocol, as will be used in the |Sec-WebSocket-Protocol| header field registered in Section 11.3.4 of this specification. The value must conform to the requirements given in item 10 of Section 4.1 of this specification -- namely, the value must be a token as defined by RFC 2616 [RFC2616].
</dd>

	<dt>下位protocol共通名
◎
Subprotocol Common Name
</dt>
	<dd>
下位protocolを一般に参照するための，下位protocolの名前。
◎
The name of the subprotocol, as the subprotocol is generally referred to.
</dd>

	<dt>下位protocol定義
◎
Subprotocol Definition
</dt>
	<dd>
<!-- copy* -->
~WebSocket~Protocolと伴用される下位protocolが定義される文書への参照
◎
A reference to the document in which the subprotocol being used with the WebSocket Protocol is defined.
</dd>

</dl>

<p><!-- copy* -->
~WebSocket下位protocol名は、
“First Come First Served（出願順）” ~IANA登録~policy `RFC5226$r
の対象になる。
◎
WebSocket Subprotocol names are to be subject to the "First Come First Served" IANA registration policy [RFC5226].
</p>


		</section>
		<section id="section-11.6">
<h3 title="WebSocket Version Number Registry">11.6. ~WebSocket~version番号~registry</h3>

<p><!-- copy* -->
この仕様は、 `RFC5226$r に設けられた原則に則り，~WebSocket~Protocolと併用される~WebSocket~version番号 用の、新たな~IANA~registryを作成する。
◎
This specification creates a new IANA registry for WebSocket Version Numbers to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].
</p>

<p><!-- copy -->
この~registryの一部として、~IANAは以下の情報を保守する：
◎
As part of this registry, IANA maintains the following information:
</p>

<dl>
	<dt>
~version番号
◎
Version Number
</dt>
	<dd>
`Sec-WebSocket-Version^h ~header内に利用される~version番号は、この仕様の `4.1$secにて指定される。
値は、 0 〜 255 の範囲の非負~整数でなければならない。
◎
The version number to be used in the |Sec-WebSocket-Version| is specified in Section 4.1 of this specification. The value must be a non-negative integer in the range between 0 and 255 (inclusive).
</dd>

	<dt>参照
◎
Reference
</dt>
	<dd>
新たな~version番号または~version番号を伴う草案の名前を要請している~RFC（下を見よ）。
◎
The RFC requesting a new version number or a draft name with version number (see below).
</dd>

	<dt>位置付け
◎
Status
</dt>
	<dd>
"Interim" （暫定）または "Standard" （標準）のいずれか。
下の記述を見よ。
◎
Either "Interim" or "Standard". See below for description.
</dd>

</dl>

<p>
~version番号は、 "Interim" または "Standard" として指定されている。
◎
A version number is designated as either "Interim" or "Standard".
</p>

<p>
"Standard" ~version番号は、~RFC内に文書~化され、この~RFCで定義される~versionのような，~WebSocket~protocolの~majorかつ安定的な~versionを識別するために利用される。
"Standard" ~version番号は、
"IETF Review" ~IANA登録~policy `RFC5226$r
の対象になる。
◎
A "Standard" version number is documented in an RFC and used to identify a major, stable version of the WebSocket protocol, such as the version defined by this RFC. "Standard" version numbers are subject to the "IETF Review" IANA registration policy [RFC5226].
</p>

<p>
"Interim" ~version番号は、 Internet-Draft 内に文書~化され、この~RFCの発行前に開発された~versionなど，実装者による，~WebSocket~protocolの頒布~versionを識別して相互運用し易くするために利用される。
"Interim" ~version番号は、initial Designated Experts である HYBI Working Group の chairs（または， working group が解散したときは， IETF Applications Area の Area Directors ）からの， "Expert Review" ~IANA登録~policy `RFC5226$r の対象になる。
◎
An "Interim" version number is documented in an Internet-Draft and used to help implementors identify and interoperate with deployed versions of the WebSocket protocol, such as versions developed before the publication of this RFC. "Interim" version numbers are subject to the "Expert Review" IANA registration policy [RFC5226], with the chairs of the HYBI Working Group (or, if the working group closes, the Area Directors for the IETF Applications Area) being the initial Designated Experts.
</p>

<p>
~IANAは、以下の，~registryの初期~値を追加した。
◎
IANA has added initial values to the registry as follows.
</p>

<table>
<thead><tr>
<th>
~version番号

◎
Version Number
<th>参照

◎
Reference
<th>位置付け

◎
Status
</thead>

<tbody><tr><td>0<td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-00">draft-ietf-hybi-thewebsocketprotocol-00</a>
<td>Interim 
<tr><td>1<td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-01">draft-ietf-hybi-thewebsocketprotocol-01</a>
<td>Interim 
<tr><td>2<td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-02">draft-ietf-hybi-thewebsocketprotocol-02</a>
<td>Interim 
<tr><td>3<td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-03">draft-ietf-hybi-thewebsocketprotocol-03</a>
<td>Interim 
<tr><td>4<td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-04">draft-ietf-hybi-thewebsocketprotocol-04</a>
<td>Interim 
<tr><td>5<td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-05">draft-ietf-hybi-thewebsocketprotocol-05</a>
<td>Interim 
<tr><td>6<td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-06">draft-ietf-hybi-thewebsocketprotocol-06</a>
<td>Interim 
<tr><td>7<td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-07">draft-ietf-hybi-thewebsocketprotocol-07</a>
<td>Interim 
<tr><td>8<td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-08">draft-ietf-hybi-thewebsocketprotocol-08</a>
<td>Interim 
<tr><td>9<td>Reserved<td>
<tr><td>10<td>Reserved<td>
<tr><td>11<td>Reserved<td>
<tr><td>12<td>Reserved<td>
<tr><td>13<td>`RFC 6455$<td>Standard

</tbody></table>


		</section>
		<section id="section-11.7">
<h3 title="WebSocket Close Code Number Registry">11.7. ~WebSocket~close~code番号~registry</h3>

<p><!-- copy* -->
この仕様は、 `RFC5226$r に設けられた原則に則り，
~WebSocket~Protocolと併用される~WebSocket`~close~code$番号 用の、新たな~IANA~registryを作成する。
◎
This specification creates a new IANA registry for WebSocket Connection Close Code Numbers in accordance with the principles set out in RFC 5226 [RFC5226].
</p>

<p><!-- copy -->
この~registryの一部として、~IANAは以下の情報を保守する：
◎
As part of this registry, IANA maintains the following information:
</p>

<dl>

	<dt>
`~status~code$
◎
Status Code
</dt>
	<dd>
~WebSocket接続~closureの事由を表す。
~status~codeは `1000^st 〜 `4999^st の範囲の整数である。
◎
The Status Code denotes a reason for a WebSocket connection closure as per Section 7.4 of this document. The status code is an integer number between 1000 and 4999 (inclusive).
</dd>

	<dt>意味
◎
Meaning
</dt>
	<dd>
`~status~code$が持つ意味。
それぞれの~status~codeは一意的な意味を持つ必要がある。
◎
The meaning of the status code. Each status code has to have a unique meaning.
</dd>

	<dt>連絡先
◎
Contact
</dt>
	<dd>
`~status~code$を予約した~~主体の連絡先。
◎
A contact for the entity reserving the status code.
</dd>

	<dt>参照
◎
Reference
</dt>
	<dd>
`~status~code$とそれらの意味の定義を要請している安定的な文書。
これは、範囲 `1000^st 〜 `2999^st の~status~codeに要求され，範囲 `3000^st 〜  `3999^st  の~status~codeに推奨される。
◎
The stable document requesting the status codes and defining their meaning. This is required for status codes in the range 1000-2999 and recommended for status codes in the range 3000-3999.
</dd>

</dl>

<p>
WebSocket Close Code Numbers は、それらの範囲に依存して，異なる登録~要件の対象になる。
［
この~protocolとその後続~version, または拡張
］用途の`~status~code$の要請は［
"Standards Action",
"Specification Required" （ "Designated Expert" も伴われることになる），
"IESG Review" IANA 登録~policy
］のいずれかの対象になり、範囲 `1000^st  〜 `2999^st  に対して是認されるべきである。
［
~library／~framework／~app
］用途の`~status~code$の要請は、
“First Come First Served" IANA 登録~policyの対象になり、範囲 `3000^st 〜 `3999^st  に対して認可されるべきである。
範囲 `4000^st 〜 `4999^st  の`~status~code$は Private Use （私的~利用）として，指名されている。
その要請は、次のうち，どの用途で`~status~code$を要請しているかを指示するべきである
⇒
~WebSocket~Protocol（またはその将来~version） ／
拡張 ／
［
~library／~framework／~app
］
◎
WebSocket Close Code Numbers are subject to different registration requirements depending on their range. Requests for status codes for use by this protocol and its subsequent versions or extensions are subject to any one of the "Standards Action", "Specification Required" (which implies "Designated Expert"), or "IESG Review" IANA registration policies and should be granted in the range 1000-2999. Requests for status codes for use by libraries, frameworks, and applications are subject to the "First Come First Served" IANA registration policy and should be granted in the range 3000-3999. The range of status codes from 4000-4999 is designated for Private Use. Requests should indicate whether they are requesting status codes for use by the WebSocket Protocol (or a future version of the protocol), by extensions, or by libraries/frameworks/applications.
</p>

<p><!-- copy -->
~IANAは、以下の~registryの初期~値を追加した。
◎
IANA has added initial values to the registry as follows.
</p>

<table>
<thead><tr><th>
`~status~code$
◎
Status Code
<th>意味
◎
Meaning
<th>
連絡先
◎
Contact
<th>
参照
◎
Reference
</thead><tbody>
<!-- 
Status Code｜Meaning｜Contact｜Reference
 -->

<tr><td>`1000$st
<td>
正常な~closure
◎
Normal Closure
<td rowspan="13">hybi@ietf.org
<td rowspan="13">`RFC 6455$

<tr><td>`1001$st
<td>
消去っている
◎
Going Away

<tr><td>`1002$st
<td>
~protocol~error
◎
Protocol error

<tr><td>`1003$st
<td>
未~supportの~data
◎
Unsupported Data

<tr><td>`1004$st
<td>
（予約-済み）
◎
---Reserved----

<tr><td>`1005$st
<td>
~statusが受信されなかった
◎
No Status Rcvd

<tr><td>`1006$st
<td>
異常な~closure
◎
Abnormal Closure

<tr><td>`1007$st
<td>
妥当でない~frame~payload~data
◎
Invalid frame payload data

<tr><td>`1008$st
<td>
~policy違反
◎
Policy Violation

<tr><td>`1009$st
<td>
大き過ぎる~message
◎
Message Too Big

<tr><td>`1010$st
<td>
必須の拡張
◎
Mandatory Ext.

<tr><td>`1011$st
<td>
~server内部の~error
◎
Internal Server Error

<tr><td>`1015$st
<td>
~TLS~handshake
◎
TLS handshake

</tbody></table>


		</section>
		<section id="section-11.8">
<h3 title="WebSocket Opcode Registry">11.8. ~WebSocket~opcode~registry</h3>

<p><!-- copy* -->
この仕様は、 `RFC5226$r に設けられた原則に則り，
~WebSocket~Protocolと併用される~WebSocket`~opcode$用の、新たな~IANA~registryを作成する。
◎
This specification creates a new IANA registry for WebSocket Opcodes in accordance with the principles set out in RFC 5226 [RFC5226].
</p>

<p><!-- copy -->
この~registryの一部として、~IANAは以下の情報を保守する：
◎
As part of this registry, IANA maintains the following information:
</p>

<dl>

	<dt>Opcode
◎
Opcode
</dt>
	<dd>
`~opcode$は、~WebSocket~frameの~frame種別を表す。
`5.2$secの定義に従って，`~opcode$は、 0 〜 15 の範囲の整数である。
◎
The opcode denotes the frame type of the WebSocket frame, as defined in Section 5.2. The opcode is an integer number between 0 and 15, inclusive.
</dd>

	<dt>意味
◎
Meaning
</dt>
	<dd>
`~opcode$値の意味。
◎
The meaning of the opcode value.
</dd>

	<dt>参照
◎
Reference
</dt>
	<dd>
`~opcode$を要請している仕様。
◎
The specification requesting the opcode.
</dd>

</dl>

<p>
WebSocket Opcode 番号は、
"Standards Action" IANA 登録~policy `RFC5226$r
の対象である。
◎
WebSocket Opcode numbers are subject to the "Standards Action" IANA registration policy [RFC5226].
</p>

<p><!-- copy -->
~IANAは、以下の~registryの初期~値を追加した。
◎
IANA has added initial values to the registry as follows.
</p>


<table><thead><tr><th>~opcode
<th>意味
◎
Meaning
<th>参照
◎
Reference
</thead><tbody>

<tr><th>0 <td>`Continuation$fr ~frame<td>`RFC 6455$
<tr><th>1 <td>`Text$fr ~frame<td>`RFC 6455$
<tr><th>2 <td>`Binary$fr ~frame<td>`RFC 6455$
<tr><th>8 <td>接続 `Close$fr ~frame<td>`RFC 6455$
<tr><th>9 <td>`Ping$fr ~frame<td>`RFC 6455$
<tr><th>10<td>`Pong$fr ~frame<td>`RFC 6455$

</tbody></table>


		</section>
		<section id="section-11.9">
<h3 title="WebSocket Framing Header Bits Registry">11.9. ~WebSocket~frame法~header~bit~registry</h3>

<p><!-- copy* -->
この仕様は、 `RFC5226$r に設けられた原則に則り，~WebSocket~Protocolと併用される~WebSocket~frame法~header~bit用の、新たな~IANA~registryを作成する。
この~registryは、`予約-済み~bit$の割当てを統制する。
◎
This specification creates a new IANA registry for WebSocket Framing Header Bits in accordance with the principles set out in RFC 5226 [RFC5226]. This registry controls assignment of the bits marked RSV1, RSV2, and RSV3 in Section 5.2.
</p>

<p>
これらの~bitは、この仕様の将来~versionまたは拡張~用に，予約-済みである。
◎
These bits are reserved for future versions or extensions of this specification.
</p>

<p>
WebSocket Framing Header Bits の割当ては、
"Standards Action"~IANA登録~policy `RFC5226$r
の対象になる。
◎
WebSocket Framing Header Bits assignments are subject to the "Standards Action" IANA registration policy [RFC5226].
</p>

		</section>
	</section>
	<section id="section-12">
<h2 title="Using the WebSocket Protocol from Other Specifications">12. 他の仕様からの~WebSocket~protocolの利用</h2>

<p>
~WebSocket~Protocolは、作者が定義する動的な内容のための汎用の仕組みを供する
— それには、他の仕様からの利用が意図されている
— 例えば，~script用の~APIを定義する仕様にて。
◎
The WebSocket Protocol is intended to be used by another specification to provide a generic mechanism for dynamic author-defined content, e.g., in a specification defining a scripted API.
</p>

<p>
その種の仕様には、次が求められる：
</p>
<ul>
	<li>
<p>
まず，次に挙げるものを伴う~algoを供して`~WebSocket接続を確立する$必要がある：
◎
Such a specification first needs to _Establish a WebSocket Connection_, providing that algorithm with:
</p>

		<ul>
			<li>
( %~host, %~port )
— 行先を成す。
◎
The destination, consisting of a /host/ and a /port/.
</li>
			<li>
%~resource名
— ( %~host, %~port ) 組の下で，複数の~serviceを識別できるようにする。
◎
A /resource name/, which allows for multiple services to be identified at one host and port.
</li>
			<li>
%~secure~flag
— 接続が暗号化される場合は ~T ／ 他の場合は ~F 。
◎
A /secure/ flag, which is true if the connection is to be encrypted and false otherwise.
</li>
			<li>
接続を担当するものとされる生成元の，~ASCII直列化。
`RFC6454$r
◎
An ASCII serialization of an origin [RFC6454] that is being made responsible for the connection.
</li>
			<li>
~optionで、~WebSocket接続~上に積層される~protocolを識別する，文字列。
◎
Optionally, a string identifying a protocol that is to be layered over the WebSocket connection.
</li>
		</ul>

<p>
( %~host, %~port, %~resource名, %~secure~flag )
は、通例的には，~WebSocket~URIの成分を構文解析する手続きを用いて，~URIから得られる。
その手続きは、~URIが~WebSocketを指定していなければ失敗する。
◎
The /host/, /port/, /resource name/, and /secure/ flag are usually obtained from a URI using the steps to parse a WebSocket URI's components. These steps fail if the URI does not specify a WebSocket.
</p>

	</li>
	<li>
接続が~closeするときは、どの時点であれ，仕様は`~WebSocket接続を~close$する~algoを利用する必要がある。
◎
If at any time the connection is to be closed, then the specification needs to use the _Close the WebSocket Connection_ algorithm (Section 7.1.1).
</li>
	<li>
接続がいつ~closeされるかは、`~WebSocket接続は~close済み$にて定義されている。
◎
Section 7.1.4 defines when _The WebSocket Connection is Closed_.
</li>
	<li>
接続が~openしている間、仕様は，`~WebSocket~messageが受信された$場合を取扱う必要がある。
◎
While a connection is open, the specification will need to handle the cases when _A WebSocket Message Has Been Received_ (Section 6.2).
</li>
	<li>
何らかの~dataを~open接続に送信するためには、仕様は`~WebSocket~messageを送信する$必要がある。
◎
To send some data /data/ to an open connection, the specification needs to _Send a WebSocket Message_ (Section 6.1).
</li>
</ul>


	</section>
	<section id="section-13">
<h2 title="Acknowledgements">13. 謝辞</h2>

<p>
次の方々に特別な謝意を：
</p>

<ul>
	<li>
この~protocolの元々の著者であり，編集者であった Ian Hickson 氏。
この仕様の初期の設計は、WHATWG と WHATWG の~mailing-listの多くの方々の関与から恩恵を受けている。
その仕様への寄与は、節として~~記録されてはいないが，その仕様に寄与された方々すべての一覧は、
WHATWG HTML 仕様
<a href="https://html.spec.whatwg.org/multipage/#toc-acknowledgments">http://whatwg.org/html5</a>
に掲載されている。
◎
Special thanks are due to Ian Hickson, who was the original author and editor of this protocol. The initial design of this specification benefitted from the participation of many people in the WHATWG and WHATWG mailing list. Contributions to that specification are not tracked by section, but a list of all who contributed to that specification is given in the WHATWG HTML specification at http://whatwg.org/html5.
</li>
	<li>
この仕様の "<a href="#section-5">Data Framing</a>" 節に，有意な量の~textを寄稿していただいた John Tamplin 氏。
◎
Special thanks also to John Tamplin for providing a significant amount of text for the "Data Framing" section of this specification.
</li>
	<li>
この仕様の "Data Masking" 節に，有意な量の文章と背景調査を寄稿／供していただいた Adam Barth 氏。
◎
Special thanks also to Adam Barth for providing a significant amount of text and background research for the "Data Masking" section of this specification.
</li>
	<li>
Apps Area 考査をされた Lisa Dusseault 氏（氏には，この仕事の開始も助けていただいた）
◎
Special thanks to Lisa Dusseault for the Apps Area review (and for helping to start this work),
</li>
	<li>
Gen-Art 考査をされた Richard Barnes 氏。
◎
Richard Barnes for the Gen-Art review, and
</li>
	<li>
Transport Area Review をされた Magnus Westerlund 氏。
◎
Magnus Westerlund for the Transport Area Review.
</li>
	<li>
舞台裏で不断に働き，この仕事を完了に向けて推進された過去の HYBI WG および~~現在の WG chairs である，
Joe Hildebrand 氏,
Salvatore Loreto 氏,
Gabriel Montenegro 氏
◎
Special thanks to HYBI WG past and present WG chairs who tirelessly worked behind the scene to move this work toward completion: Joe Hildebrand, Salvatore Loreto, and Gabriel Montenegro.
</li>
	<li>
responsible Area Director の Peter Saint-Andre 氏。
◎
And last but not least, special thank you to the responsible Area Director Peter Saint-Andre.
</li>
	<li>
<p>
HYBI WG ~mailing-listの議論に加わり，アイデアや詳細な考査を供された次の方々（この一覧はおそらく完全でない）：
◎
Thank you to the following people who participated in discussions on the HYBI WG mailing list and contributed ideas and/or provided detailed reviews (the list is likely to be incomplete): 
</p>

<div lang="en-x-a0">
Greg Wilkins, John Tamplin, Willy Tarreau, Maciej Stachowiak, Jamie Lokier, Scott Ferguson, Bjoern Hoehrmann, Julian Reschke, Dave Cridland, Andy Green, Eric Rescorla, Inaki Baz Castillo, Martin Thomson, Roberto Peon, Patrick McManus, Zhong Yu, Bruce Atherton, Takeshi Yoshino, Martin J. Duerst, James Graham, Simon Pieters, Roy T. Fielding, Mykyta Yevstifeyev, Len Holgate, Paul Colomiets, Piotr Kulaga, Brian Raymor, Jan Koehler, Joonas Lehtolahti, Sylvain Hellegouarch, Stephen Farrell, Sean Turner, Pete Resnick, Peter Thorson, Joe Mason, John Fallows, and Alexander Philippou.
</div>

<p>
上に挙げたからと言って、彼らがこの仕事の最終成果を承認しているとは限らないことに注意。
◎
Note that people listed above didn't necessarily endorse the end result of this work.
</p>

</li>
</ul>

	</section>

</main></div>


<!-- 正誤表
3150: Verified
3433: Verified
3473: Verified
4672: Reported
4919: Reported
3227: Held for Document Update
3432: Held for Document Update
4398: Held for Document Update
3215: Rejected
3912: Rejected
4184: Rejected
-->
