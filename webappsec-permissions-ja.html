<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Permissions（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style>
samp {
	white-space: nowrap;
	background: #F0F0F0;
	margin-left: 0.5em;
	margin-right: 0.5em;
}

i {
	text-decoration: underline;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // 文献
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l': //literal
case 'pS':
case 'pN':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl': // js slot
	text = `[[${key}]]`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Permissions
spec_date:2021-10-26
trans_update:2021-10-27
source_checked:210831
page_state_key:WEBAPPSEC
original_url:https://w3c.github.io/permissions/
	abbr_url:PERMISSIONS
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
conformance:w3c
copyright:2021,permissive
trans_1st_pub:2017-03-14


●●class_map
et:event-type
a:attr
sl:js-slot

●●tag_map
p:var
a:code
I:code
m:code
et:code
sl:span
c:code
i:i
cite:cite

●●original_id_map

●●mdn_urls
dom-permissions:API/Permissions
dom-permissionstatus:API/PermissionStatus
	dom-permissiondescriptor:API/PermissionDescriptor
	dom-pushpermissiondescriptor:API/PushPermissionDescriptor
	dom-midipermissiondescriptor:API/MidiPermissionDescriptor
	dom-devicepermissiondescriptor:API/DevicePermissionDescriptor
	dom-permissionname:API/PermissionName
	dom-permissionstate:API/PermissionState

●●link_map

	●IDL
SameObject:~WEBIDLjs#SameObject
Exposed:~WEBIDLjs#Exposed

object:~WEBIDL#idl-object
boolean:~WEBIDL#idl-boolean
DOMString:~WEBIDL#idl-DOMString
Promise:~WEBIDL#idl-promise

I.Window:~WINDOW#window
I.WorkerGlobalScope:~WORKERS#workerglobalscope

I.Permissions:#dom-permissions
I.PermissionDescriptor:#dom-permissiondescriptor
I.PermissionName:#dom-permissionname
I.PermissionState:#dom-permissionstate
I.PermissionStatus:#dom-permissionstatus
I.PushPermissionDescriptor:#dom-pushpermissiondescriptor
I.MidiPermissionDescriptor:#dom-midipermissiondescriptor
I.DevicePermissionDescriptor:#dom-devicepermissiondescriptor
I.CameraDevicePermissionDescriptor:#dom-cameradevicepermissiondescriptor

I.EventHandler:~WAPI#eventhandler
I.EventTarget:~DOM4#eventtarget
I.Navigator:~HTMLnavigator#navigator
I.WorkerNavigator:~WORKERS#workernavigator

pN.accelerometer:#dom-permissionname-accelerometer
pN.ambient-light-sensor:#dom-permissionname-ambient-light-sensor
pN.background-fetch:#dom-permissionname-background-fetch
pN.background-sync:#dom-permissionname-background-sync
pN.bluetooth:#dom-permissionname-bluetooth
pN.camera:#dom-permissionname-camera
pN.display-capture:#dom-permissionname-display-capture
pN.geolocation:#dom-permissionname-geolocation
pN.gyroscope:#dom-permissionname-gyroscope
pN.magnetometer:#dom-permissionname-magnetometer
pN.microphone:#dom-permissionname-microphone
pN.midi:#dom-permissionname-midi
pN.nfc:#dom-permissionname-nfc
pN.notifications:#dom-permissionname-notifications
pN.persistent-storage:#dom-permissionname-persistent-storage
pN.push:#dom-permissionname-push
pN.screen-wake-lock:#dom-permissionname-screen-wake-lock
pN.speaker-selection:#dom-permissionname-speaker-selection
pN.xr-spatial-tracking:#dom-permissionname-xr-spatial-tracking

pS.denied:#dom-permissionstate-denied
pS.granted:#dom-permissionstate-granted
pS.prompt:#dom-permissionstate-prompt

m.getUserMedia:~MEDIACAPTURE#dom-mediadevices-getusermedia
m.deviceId:#dom-devicepermissiondescriptor-deviceid
m.panTiltZoom:#dom-cameradevicepermissiondescriptor-pantiltzoom
m.name:#dom-permissiondescriptor-name
m.~name0:#dom-permissionstatus-name
m.onchange:#dom-permissionstatus-onchange
m.query:#dom-permissions-query
m.state:#dom-permissionstatus-state

m.permissions:#dom-navigator-permissions
m.~permissions0:#dom-workernavigator-permissions
m.userVisibleOnly:#dom-pushpermissiondescriptor-uservisibleonly
m.sysex:#dom-midipermissiondescriptor-sysex

sl.query:#dfn-query
c.deviceId:~MEDIACAPTURE#dom-mediadeviceinfo-deviceid

a.allow:~HEembed#attr-iframe-allow

	●用語
~risk下:w3c-common-ja.html#at-risk
	~risk下:#dfn-at-risk

許可:#dfn-permission
名前:#dfn-name
側面:#dfn-aspects
状態:#dfn-states
~prompt:#dfn-prompt
是認-:#dfn-granted
否認-:#dfn-denied
許可を表出する:#dfn-express-permission

許可~記述子~型:#dfn-permission-descriptor-type
許可~query~algo:#dfn-permission-query-algorithm
許可~結果型:#dfn-permission-result-type
許可~revocation~algo:#dfn-permission-revocation-algorithm
許可~状態~拘束:#dfn-permission-state-constraints
許可~状態:#dfn-permission-state
~extra許可~data拘束:#dfn-extra-permission-data-constraints
~extra許可~data型:#dfn-extra-permission-data-type
~extra許可~data:#dfn-extra-permission-data
強力な特能:#dfn-powerful-feature
既定の強力な特能:#dfn-default-powerful-feature
識別される特能:#_powerful-feature-by-name
選ぶよう利用者に~promptする:#dfn-prompt-the-user-to-choose
利用する許可を要請する:#dfn-request-permission-to-use
暗黙的な兆候:#dfn-implicit-signals

既定の許可を~queryする~algo:#dfn-default-permission-query-algorithm
~PermissionStatusを作成する:#dfn-create-a-permissionstatus
利用者の意図についての新たな情報:#dfn-new-information-about-the-user-s-intent
より強い:#dfn-stronger-than
利用者により許可が~revokeされたとき反応する:#dfn-react-to-the-user-revoking-permission
~PermissionStatus更新~手続き:#dfn-permissionstatus-update-steps

許可~task源:#dfn-permissions-task-source
許可を~queryする:#dfn-query-a-permission
~secureでない文脈にて許容されるか:#dfn-allowed-in-non-secure-contexts
~secureでない文脈にて許容されて:#dfn-allowed-in-non-secure-contexts

	●用語（外部
汎用~sensor許可~revocation~algo:~SENSORS#generic-sensor-permission-revocation-algorithm

~UA:~INFRA#user-agent

現在の~realm:~TC39#current-realm

辞書:~WEBIDL#dfn-dictionary
diC.継承-:~WEBIDL#dfn-inherit-dictionary
~IDL値に変換-:~WEBIDLjs#dfn-convert-ecmascript-to-idl-value
新たな~promise:~WEBIDLjs#a-new-promise
却下される~promise:~WEBIDLjs#a-promise-rejected-with
解決する:~WEBIDLjs#resolve

~eventを発火する:~DOM4#concept-event-fire

許可~施策:~PERMISSIONS-POLICY#permissions-policy
	doc.許可~施策:~HTMLdom#concept-document-permissions-policy

利用は許容されて:~HEembed#allowed-to-use
並列的:~HTMLINFRA#in-parallel
同一-生成元:~ORIGIN#same-origin
結付けられている文書:~WINDOW#concept-document-window
~realm:~WAPI#concept-global-object-realm
設定群~obj:~WAPI#concept-realm-settings-object
現在の設定群~obj:~WAPI#current-settings-object
環境~設定群~obj:~WAPI#environment-settings-object
いくつかアリな設定群~obj:~WAPI#realms-settings-objects-global-objects
関連な大域~obj:~WAPI#concept-relevant-global
enV.大域~obj:~WAPI#concept-settings-object-global
enV.担当の~event~loop:~WAPI#responsible-event-loop
enV.~secureな文脈:~WAPI#secure-context
	enV.~secureでない文脈:~WAPI#non-secure-context
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler:~WAPI#event-handlers
~taskを~queueする:~WAPI#queue-a-task
~task源:~WAPI#task-source

施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature

~installされ:~APPMANIFEST#dfn-installed-web-application

機器~許可~revocation~algo:~MEDIACAPTURE#dfn-device-permission-revocation-algorithm

cite.Geolocation API:https://www.w3.org/TR/geolocation/
cite.Notifications API Standard:~NOTIFICATIONS
	https://notifications.spec.whatwg.org/
cite.Push API:https://www.w3.org/TR/push-api/
cite.Web MIDI API:https://www.w3.org/TR/webmidi/
cite.Screen Wake Lock API:https://www.w3.org/TR/screen-wake-lock/
cite.Background Fetch:https://wicg.github.io/background-fetch/
cite.Web Background Synchronization:https://wicg.github.io/background-sync/spec/
cite.Web Bluetooth:https://webbluetoothcg.github.io/web-bluetooth/
cite.Storage Standard:~STORAGE
	https://storage.spec.whatwg.org/
cite.Ambient Light Sensor:~AMBIENT-LIGHT
	https://www.w3.org/TR/ambient-light/
cite.Accelerometer:~ACCELEROMETER
	https://www.w3.org/TR/accelerometer/
cite.Gyroscope:~GYROSCOPE
	https://www.w3.org/TR/gyroscope/
cite.Magnetometer:~MAGNETOMETER
	https://www.w3.org/TR/magnetometer/
cite.Screen Capture:https://www.w3.org/TR/screen-capture/
cite.Web NFC API:https://w3c.github.io/web-nfc/
cite.WebXR Device API:https://www.w3.org/TR/webxr/

cite.Permissions Automation:https://w3c.github.io/permissions-automation/

●●words_table1
APPMANIFEST:appmanifest-ja.html
MEDIACAPTURE:https://www.w3.org/TR/mediacapture-streams/
	MEDIACAPTURE:https://w3c.github.io/mediacapture-main/
AMBIENT-LIGHT:ambient-light-ja.html
ACCELEROMETER:accelerometer-ja.html
GYROSCOPE:gyroscope-ja.html
MAGNETOMETER:magnetometer-ja.html
permissions0:permissions
name0:name

●●words_table

	●仕様
下位型:subtype::~
	による:reason
意向:intention:~
推定-:infer:~
曖昧:vague:~
末端利用者:end user:~:::エンドユーザ
枠組み:framework:~
略記:shorthand:~
選択的:selective:~
選択肢:option:~
見越して:anticipateして:~
集成-:aggregate:~
探求-:explore:~
学習-:learn:~
解決策:solution:~
申請-:file:~
仲介-:mediate:~
重合する:overlapする:重なり合う
同意:consent:~
維持-:retain:~
処する:dealする:~
別個:distinct:~
専ら:exclusiveに:~
協調-:coordinate:~
突止める:ascertainする:突き止める

	用例:Examples of usage
	とされる:marked as
	~web~site:website
	視点で:notion
	視点による:impression
	責を負う:responsible
	裁定を下した:made 〜 decision
	至る:lead
	満た:satisfy
	〜も満たす:taking into account
	-:aware
	~~判明する:the client knows
	収まらな:fit
	~~伝える:contact
	処する:deal with
	どちらにせよ:be it 〜 or
	だとしても:nevertheless
	いつでも:at any time
	ようになる:ever become
	組み込む:subsume
	注意点:note
	最後に:finally
	目立たない:discreet
	指す:refer
	類別される:class
	選ぶ:choose
	選んだもの:choice
	~~策定者たち:us
	ある仮の:hypothetical
	関心事:interesting
	~Web~IDL:WebIDL

	●IDL／event／処理
列挙型:enum::~
列挙値:enum value:enum 値:~
main::::メイン

	~call元:caller
	~call元:calling
	invocation
	設定群:target

	%根~記述子:rootDesc
	-:previousResult
	%有型~記述子:typedDescriptor
	%許可~記述子:permissionDesc
	記述子 %A:descriptorA
	記述子 %B:descriptorB

	●許可／保安
revokeされ::取り消され
revocation::取り消し
	~revokeされたとき:revoking
PermissionStatus:
結果型:result type::~
指紋:fingerprint::~
敵対者:adversary:~
兆候:signals::~
頻繁:frequent:~
	frequency
近過去:recent:~
extra::追加の
持続性:persistence::~
持続的:persistent::~

	recency
	可能性が高い:more likely to
	勧める:advised
	~~注意深くあたる:exercise caution

	●許可対象
display-capture:display capture:::ディスプレイキャプチャ

Permissions:
background:
bluetooth:
MIDI:
wake::::ウェイク
NFC:
XR:
地理所在:geolocation:~
環境光:ambient light:~
camera::::カメラ
磁力計:magnetometer::~
gyroscope::::ジャイロスコープ
加速度計:accelerometer::~
sensor::::センサ
地域news:local news:::地域ニュース:ローカルニュース
空間的:spatial::~

	●未分類
自動化-:automate::~
prompt:
退ける:dismissする:~
半順序:partial order:~

food:
taste:
smell:
sense:
検出器:detector::~

	モノ:thing
	続ける:keep
	在る:exist
	-:contain
	-:made
	-:client
	-:parameter
	読取n法:reading
	渡-:pass

	GitHub:
	geolocation
	midi
	-:moment

	●指示語
	一つ:one
	いくつも:many
	当の:relevant
	この時点で:now has
	後続の:subsequent
	数多の:lots of
	前もって:beforehand
	他の部分:any other parts
	最後に:latest

●●ref_data
APPMANIFEST=副     ~/appmanifest-ja.html

●●ref_normative

[accelerometer]
    ＜Accelerometer＞. Anssi Kostiainen; Alexander Shalamov.  W3C. 2 September 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/accelerometer/
[ambient-light]
    ＜Ambient Light Sensor＞. Anssi Kostiainen; Rijubrata Bhaumik; Tobie Langel.  W3C. 3 September 2021. W3C Working Draft. URL: https://www.w3.org/TR/ambient-light/
[audio-output]
    ＜Audio Output Devices API＞. Justin Uberti; Guido Urdaneta; youenn fablet.  W3C. 6 July 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/audio-output/
[background-fetch]
    ＜Background Fetch＞.  WICG. cg-draft. URL: https://wicg.github.io/background-fetch/
[dom]
    ＜DOM Standard＞. Anne van Kesteren.  WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞.  Ecma International. URL: https://tc39.es/ecma262/multipage/
[generic-sensor]
    ＜Generic Sensor API＞. Rick Waldron; Mikhail Pozdnyakov; Alexander Shalamov; Tobie Langel.  W3C. 29 July 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/generic-sensor/
[Geolocation]
    ＜Geolocation API＞. Marcos Caceres.  W3C. 12 October 2021. W3C Working Draft. URL: https://www.w3.org/TR/geolocation/
[GETUSERMEDIA]
    ＜Media Capture and Streams＞. Cullen Jennings; Bernard Aboba; Jan-Ivar Bruaroey; Henrik Boström; youenn fablet; Daniel Burnett; Adam Bergkvist; Anant Narayanan.  W3C. 21 October 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/mediacapture-streams/
[gyroscope]
    ＜Gyroscope＞. Anssi Kostiainen; Mikhail Pozdnyakov.  W3C. 2 September 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/gyroscope/
[HTML]
    ＜HTML Standard＞. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters.  WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[infra]
    ＜Infra Standard＞. Anne van Kesteren; Domenic Denicola.  WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/
[magnetometer]
    ＜Magnetometer＞. Anssi Kostiainen; Rijubrata Bhaumik.  W3C. 2 September 2021. W3C Working Draft. URL: https://www.w3.org/TR/magnetometer/
[notifications]
    ＜Notifications API Standard＞. Anne van Kesteren.  WHATWG. Living Standard. URL: https://notifications.spec.whatwg.org/
[Permissions-Policy]
    ＜Permissions Policy＞. Ian Clelland.  W3C. 16 July 2020. W3C Working Draft. URL: https://www.w3.org/TR/permissions-policy-1/
[push-api]
    ＜Push API＞. Peter Beverloo; Martin Thomson.  W3C. 25 October 2021. W3C Working Draft. URL: https://www.w3.org/TR/push-api/
[RFC2119]
    ＜Key words for use in RFCs to Indicate Requirement Levels＞. S. Bradner.  IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119
[RFC8174]
    ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞. B. Leiba.  IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174
[screen-capture]
    ＜Screen Capture＞. Martin Thomson; Keith Griffin; Suhas Nandakumar; Henrik Boström; Jan-Ivar Bruaroey; Elad Alon.  W3C. 2 September 2021. W3C Working Draft. URL: https://www.w3.org/TR/screen-capture/
[screen-wake-lock]
    ＜Screen Wake Lock API＞. Kenneth Christiansen; Marcos Caceres; Raphael Kubo da Costa; Ilya Bogdanovich; Andrey Logvinov.  W3C. 30 September 2021. W3C Working Draft. URL: https://www.w3.org/TR/screen-wake-lock/
[storage]
    ＜Storage Standard＞. Anne van Kesteren.  WHATWG. Living Standard. URL: https://storage.spec.whatwg.org/
[web-background-sync]
    ＜Web Background Synchronization＞.  WICG. cg-draft. URL: https://wicg.github.io/background-sync/spec/
[web-bluetooth]
    ＜Web Bluetooth＞. Jeffrey Yasskin.  W3C Web Bluetooth Community Group. Draft Community Group Report. URL: https://webbluetoothcg.github.io/web-bluetooth/
[web-nfc]
    ＜Web NFC API＞.  W3C. W3C Editor's Draft. URL: https://w3c.github.io/web-nfc/
[WEBIDL]
    ＜Web IDL Standard＞. Edgar Chen; Timothy Gu.  WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/
[webmidi]
    ＜Web MIDI API＞. Chris Wilson; Jussi Kalliokoski.  W3C. 17 March 2015. W3C Working Draft. URL: https://www.w3.org/TR/webmidi/
[webxr]
    ＜WebXR Device API＞. Brandon Jones; Manish Goregaokar; Rik Cabanier; Nell Waliczek.  W3C. 26 October 2021. W3C Working Draft. URL: https://www.w3.org/TR/webxr/

●●ref_informative

[appmanifest]
    ＜Web Application Manifest＞. Marcos Caceres; Kenneth Christiansen; Anssi Kostiainen; Matt Giuca; Aaron Gustafson.  W3C. 7 October 2021. W3C Working Draft. URL: https://www.w3.org/TR/appmanifest/
[Gamepad]
    ＜Gamepad＞. Steve Agoston; James Hollyer; Matthew Reynolds; Brandon Jones; Scott Graham; Theodore Mielczarek.  W3C. 5 August 2021. W3C Working Draft. URL: https://www.w3.org/TR/gamepad/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Permissions</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/permissions/
編集者草案
	https://w3c.github.io/permissions/
発行履歴
	https://www.w3.org/standards/history/permissions
commit 履歴
	https://github.com/w3c/permissions/commits/main
編集
	<a href="https://www.w3.org/">Marcos Cáceres</a> (W3C)
	<a href="https://miketaylr.com/posts/">Mike Taylor</a> (Google LLC)
前任編集者
	Mounir Lamouri (Google LLC)
	Jeffrey Yasskin (Google LLC)

フィードバック
	<a href="https://github.com/w3c/permissions/">GitHub w3c/permissions</a> (<a href="https://github.com/w3c/permissions/pulls/">pull requests</a>, <a href="https://github.com/w3c/permissions/issues/new/choose">new issue</a>, <a href="https://github.com/w3c/permissions/issues/">open issues</a>)

発行者
	<a href="https://www.w3.org/2011/webappsec/">Web Application Security Working Group</a>

</script>

<body>

<header>
	<hgroup>
<h1>許可 — Permissions</h1>
<h2 title="Interacting with Permissions for Powerful Features">強力な特能のための許可とのやりとり</h2>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
~ABSTRACT

<p>
この仕様 `Permissions API^cite （許可~API）は、
他の仕様が~browser許可
— ~web~platformの強力な特能への~accessを［
許容する／否認する
］許可 —
とヤリトリするために利用できる共通な基盤を定義する。
この仕様はまた，開発者~用には、強力な特能に対する許可の［
状態を~queryする／
状態が変化したとき通知されるようにする
］ための~APIを定義する。
◎
The Permissions API specification defines common infrastructure that other specifications can use to interact with browser permissions that allow or deny access to powerful features on the web platform. For developers, the specification defines an API to query the permission state of a powerful feature, or be notified if a permission for a powerful feature changes state.
</p>

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下，この節の他の内容は、<a href="w3c-common-ja.html#status">W3C 日本語訳~共通~page</a>／冒頭の仕様~metadataに移譲。】
</p>

<p>
この仕様における一部の特能は、
それを~supportする~UAが一つしかないため，`~risk下$にあるとされる。
◎
Some features in this specification are supported by only one user agent, and as such, are marked as at risk.
</p>

	</section>

<main id="MAIN0">

	<section id="examples">
<h2 title="Examples of usage">1. 用例</h2>

~INFORMATIVE

<div class="example" id="example-using-state-attribute">
<p>
次の例は、 `Permissions API^cite を利用して，［
`Geolocation API^cite を利用して地域newsを示すべき
］か, または［
当の特能を追加する~buttonを提供する
］かどうかを裁定する。
◎
This example uses the Permissions API to decide whether local news should be shown using the Geolocation API or with a button offering to add the feature.
◎
Example 1: Using .state attribute
</p>

<pre class="lang-js">
const { %state } = await navigator.permissions.query({
  name: "geolocation"
});
switch (%state) {
  case `granted$pS:
    showLocalNewsWithGeolocation();
    break;
  case `prompt$pS:
    showButtonToEnableLocalNews();
    break;
  case `denied$pS:
    showNationalNews();
    break;
}
</pre>
</div>

<div class="example" id="example-checking-the-state-of-multiple-permissions">
<p>
次の例は、~pageは［
`geolocation$pN, `notifications$pN
］両~許可を有するかどうかを検査する：
◎
This example is checking whether the page has the "geolocation" and the "notifications" permissions:
◎
Example 2: Checking the state of multiple permissions
</p>

<pre class="lang-js">
const %queryPromises = ["geolocation", "notifications"].map(%name =&gt; {
  return navigator.permissions.query({ %name });
});
for await (const %status of %queryPromises) {
  console.log(``^${%status.name}: ${%status.state}``^);
}
</pre>

</div>

<div class="example" id="example-3">

<p>
次の例は、可用な各~cameraの許可~状態を検査する。
◎
This example is checking the permission state of the available cameras.
◎
Example 3
</p>

<pre class="lang-js">
const %devices = await navigator.mediaDevices.enumerateDevices();

/* <span class="comment">
動画~入力のみに~filterしてから，~query~objに対応付ける
◎
filter on video inputs, and map to query object
</span>
const %queries = %devices
  .filter(({ %kind }) =&gt; %kind === "videoinput")
  .map(({ %deviceId }) =&gt; ({ name: "camera", %deviceId }));

const %promises = %queries.map((%queryObj) =&gt;
  navigator.permissions.query(%queryObj)
);

try {
  const %results = await Promise.all(%promises);
  /* <span class="comment">
状態や各~cameraの~logをとる
◎
log the state of each camera
</span>
  %results.forEach(({ %state }, %i) =&gt; console.log("Camera", %i, %state));
} catch (%error) {
  console.error(%error);
}
</pre>
</div>

	</section>
	<section id="model">
<h2 title="Model">2. ~model</h2>
<p>
この節は、［
~Web~platformの`強力な特能$を利用する`許可$
］用の~modelを指定する。
◎
This section specifies a model for permissions to use powerful features on the Web platform.
</p>

		<section id="permissions">
<h3 title="Permissions">2.1. 許可</h3>

<p>
`許可@
は、［
利用者による，`強力な特能$への~accessを~web~appに許容する裁定
］を表現する。
◎
A permission represents a user's decision to allow a web application to access a powerful feature.
</p>

<div class="note" id="issue-container-generatedID">
<p>注記（制限）：
現在の~Web~APIには、いくつかの異なる［
許可を処する仕方
］がある。
例えば `notifications$r ~APIは、
開発者が明示的に許可を要請して，許可~状態sを検査できるようにする。
~APIを利用しようと試行したときに限り，許可~状態sを~web~pageに公開するものもある。
例えば `Geolocation$r は、開発者が前もって検査するのを許容することなく，許可が是認されていなければ失敗する。
◎
Note: Limitations
◎
Current Web APIs have different ways to deal with permissions. For example, the [notifications] API allows developers to request a permission and check the permission status explicitly. Others expose the status to web pages when they try to use the API, like the [Geolocation] which fails if the permission was not granted without allowing the developer to check beforehand.
</p>

<p>
この文書に述べる解決策は，拡張できるように意味されているが、
~web~platformにて可用な［
現在の／将来の
］許可すべてに適用-可能になるとは期待されてはいない。
許可~modelを孕む仕様を策定している~WGは、
その~modelが この文書に述べる~modelに収まらないときには，
<a href="https://github.com/w3c/permissions/issues">課題を申請して</a>
そのことを編集者に~~伝えるべきである。
◎
The solution described in this document is meant to be extensible, but isn't expected to be applicable to all the current and future permissions available in the web platform. Working Groups that are creating specifications whose permission model doesn't fit in the model described in this document should contact the editors by filing an issue.
</p>
</div>

<p>
`許可$は、概念的には，次に挙げるいずれかの
`状態@
をとり得る：
◎
Conceptually, a permission can be in one of the following states:
</p>
<dl>
	<dt>
`~prompt@
◎
Prompt:
</dt>
	<dd>
この状態は、［
利用者はまだ裁定を下していない
（すなわち，`否認-$されたのと同じ）
］ことを表現する
— `~UA$は、［
~call元が当の特能に~accessしようと試行した場合には，利用者に許可を依頼する
］ことになる。
対して，利用者は、そのような要請を［
是認することも,
否認することも,
無視することも,
退けることも
］ある。
◎
The prompt state represents that the user has not made a decision (i.e., it's the same a denied), and the user agent will be asking the user for permission if the caller tries to access the feature. The user might then grant, deny, ignore, or dismiss the request.
</dd>

	<dt>
`是認-@
された
（ `granted$pS ）
◎
Granted:
</dt>
	<dd>
この状態は、［
`~UA$が許可を利用者に依頼することなく，~call元が成功裡に当の特能に~accessできる
］ことを表現する。
◎
The granted state represents that the caller will be able to successfully access the feature without having the user agent asking the user's permission.
</dd>

	<dt>
`否認-@
された（ `denied$pS ）
◎
Denied:
</dt>
	<dd>
この状態は、［
~call元は，当の特能に~accessできない
］ことを表現する。
◎
The denied state represents that the caller will not be able to access the feature.
</dd>
</dl>

<p>
~UAは、
`利用者の意図についての新たな情報@
を突止めるときは，
利用者の意向についての情報を収集してもヨイ。
この情報は、次を集成して得ることができる
⇒＃
利用者による明示的な動作,
当の利用者や他の利用者たちの挙動,
この仕様が見越していない`暗黙的な兆候@
◎
To ascertain new information about the user's intent, a user agent MAY collect information about a user's intentions. This information can come from explicit user action, aggregate behavior of both the relevant user and other users, or implicit signals this specification hasn't anticipated.
</p>

<p class="note">注記：
`暗黙的な兆候$には，例えば、
どの~web~appが`~installされ$ていて, どの程度［
頻繁／近過去
］に訪問しているか，などが挙げられる
— 利用者が自身が~installした~web~appを より［
近過去／頻繁
］に利用しているほど，それを信用している可能性が高い。
実装には、暗黙的な兆候に依拠するときには，~~注意深くあたることを勧める。
◎
Note: Implicit signals
The implicit signals could be, for example, the install status of a web application or frequency and recency of visits. A user that has installed a web application and used it frequently and recently is more likely to trust it. Implementations are advised to exercise caution when relying on implicit signals.
</p>

		</section>
		<section id="powerful-features">
<h3 title="Powerful features">2.2. 強力な特能</h3>

<p>
`強力な特能@
は、［
それを利用できるようになる前に，利用者が`許可を表出する$必要がある
］ような，~web~platform特能である（通例的に~APIである）。
当の特能への~accessは、
次のいずれかにより決定される
⇒＃
利用者が~UIを介して許可を`是認-$した`環境~設定群~obj$により／
許可が`是認-$されたのと等価な何らかの判定基準を満たすことにより。
◎
A powerful feature is a web platform feature (usually an API) for which a user gives express permission before the feature can be used. Access to the feature is determined by the environment settings object by the user having granted permission via UI, or by satisfying some criteria that is equivalent to a permission grant.
</p>

<p>
`許可を表出する@
とは、それを通して［
~web応用に当の特能を利用する`許可$
］を`是認-$する，利用者による動作-を指す
（例：［
~UI／~host機器の~platform特能
］を介して）。
◎
Express permission refers to an act by the user, e.g. via user interface or host device platform features, through which the user grants permission the use of the feature by the web application.
</p>

<p>
`強力な特能$は、
文字列（例： `geolocation^l ）として与えられる
`名前@
により識別される。
所与の`名前$で
`識別される特能@
とは、そのように識別される`強力な特能$を指す
【この用語は、明確化するための，この訳による追加】
。
◎
A powerful feature is identified by its name, which is a string literal (e.g., "geolocation").
</p>

<p>
~UAは、［
利用者が、`強力な特能$のうち，どれに利用する`許可$を与えているか
］を，各`~realm$ごとに追跡する責を負う。
他の仕様は、この節に定義する各種 演算を利用して，どの許可が~UA視点で［
是認-／否認-
］されているかを検索取得でき，利用者に更なる許可を［
是認するか否認するか
］依頼することができる。
◎
The user agent is responsible for tracking what powerful features each realm has the user's permission to use. Other specifications can use the operations defined in this section to retrieve the UA's notion of what permissions are granted or denied, and to ask the user to grant or deny more permissions.
</p>

			<section id="specifying-a-powerful-feature">
<h4 title="Specifying a powerful feature">2.2.1. 強力な特能の指定-法</h4>

<p class="note">注記：
新たな`強力な特能$を追加したいと求める仕様には、
GitHub を介して，この仕様に対し~~策定者たちと協調することが奨励される。
◎
Specifications wanting to add a new powerful feature are encouraged to coordinate with us on this specification via GitHub.
</p>

<p>
各 `強力な特能$ %特能 は、
次に挙げる，許可に関係する各種［
~flag, ~algo, 型
］を備える。
これらの各［
~flag／~algo／型
］のいずれかについて，既定のそれが特定0の`強力な特能$用には相応でないときは、
当の仕様は，それを上書きしてもヨイ。
◎
Each powerful feature has the following permission-related flags, algorithms, and types. When the defaults are not suitable for a particular powerful feature, a specification MAY override below flags, algorithms, and types below.
</p>
<dl>
	<dt>
`~secureでない文脈にて許容されるか@
◎
An allowed in non-secure contexts flag:
</dt>
	<dd>
~T にされている場合
— 以下では、
“`~secureでない文脈にて許容されて$いる”
とも記される —
~UAは，`~secureな文脈$enVでなくても %特能 への~accessを是認してヨイ。
◎
By default, only secure contexts can use powerful features. If this flag is set for a feature, the UA may grant access to it in non-secure contexts too.
</dd>
	<dd>
未指定な場合の既定は、
~F をとるとする
— すなわち， %特能 を利用できるのは、
`~secureな文脈$enVに限られる。
◎
↑</dd>

	<dt>
`許可~記述子~型@
◎
A permission descriptor type:
</dt>
	<dd>
`PermissionDescriptor$I, または その下位型。
◎
PermissionDescriptor or one of its subtypes.＼
</dd>
	<dd>
未指定な場合の既定は、 `PermissionDescriptor$I とする。
◎
If unspecified, this defaults to PermissionDescriptor.
</dd>
	<dd>
<p>
%特能 は、記述子の各~instance間において
`より強い@
と称される
<a href="https://en.wikipedia.org/wiki/Partially_ordered_set">半順序</a>
を定義できる。
［
記述子 %A は記述子 %B `より強い$
］ならば、次が満たされなければナラナイ：
</p>
		<ul>
			<li>
［
`許可~状態$( %A ) ~EQ `granted$pS
］ならば［
`許可~状態$( %B ) ~EQ  `granted$pS
］
</li>
			<li>
［
`許可~状態$( %B ) ~EQ `denied$pS
］ならば［
`許可~状態$( %A ) ~EQ  `denied$pS
］
</li>
		</ul>
◎
The feature can define a partial order on descriptor instances. If descriptorA is stronger than descriptorB, then if descriptorA's permission state is "granted", descriptorB's permission state must also be "granted", and if descriptorB's permission state is "denied", descriptorA's permission state must also be "denied".
</dd>
	<dd class="example">
<samp>{name: `midi$pN, sysex: true}</samp>
— “sysex ありの~MIDI” —
は
<samp>{name: `midi$pN, sysex: false}</samp>
— “sysex なしの~MIDI” —
`より強い$ので、利用者が
“sysex なしの~MIDI” への~accessを否認した場合、
~UAは
“sysex ありの~MIDI” への~accessも否認しなければならない。
同様に，利用者が
“sysex ありの~MIDI” への~accessを是認した場合、
~UAは
“sysex なしの~MIDI” への~accessも是認しなければならない。
◎
{name: "midi", sysex: true} ("midi-with-sysex") is stronger than {name: "midi", sysex: false} ("midi-without-sysex"), so if the user denies access to midi-without-sysex, the UA must also deny access to midi-with-sysex, and similarly if the user grants access to midi-with-sysex, the UA must also grant access to midi-without-sysex.
</dd>

	<dt>
`許可~状態~拘束@
◎
Optional permission state constraints:
</dt>
	<dd>
~UAが`許可~状態$( 記述子 ) として返せる値を拘束する。
◎
Constraints on the values that the UA can return as a descriptor's permission state.＼
</dd>
	<dd>
既定では（省略時）、利用者の意図を超える拘束はないとする。
◎
Defaults to no constraints beyond the user's intent.
</dd>

	<dt>
`~extra許可~data型@
◎
An optional extra permission data type:
</dt>
	<dd>
一部の`強力な特能$には、 `PermissionState$I 以外の情報も結付けられる。
例えば， `getUserMedia()$m は、［
利用者が、`どの~camera^emに~accessする許可を，`現在の~realm$に是認しているか
］を決定する必要がある。
そのような各~特能は、`~extra許可~data型$を定義する。
◎
Some powerful features have more information associated with them than just a PermissionState. For example, getUserMedia() needs to determine which cameras the user has granted the current realm permission to access. Each of these features defines an extra permission data type.＼
</dd>
	<dd class="algo">
<p>
ある `PermissionName$I 列挙~値 %名前 で`識別される特能$ %特能 用の
`~extra許可~data@
は、所与の`環境~設定群~obj$ %設定群 （省略時は ε ）に対し，次を走らせた結果で与えられる：
◎
If a PermissionName name names one of these features, then name's extra permission data for an optional environment settings object settings is the result of the following algorithm:
</p>
		<ol>
			<li>
~IF［
%設定群 ~EQ ε
］
⇒
%設定群 ~SET `現在の設定群~obj$
◎
If settings wasn't passed, set it to the current settings object.
</li>
			<li>
~IF［
この~algoは、以前に，同じ
( %名前, %設定群 )
で呼出されている
］~AND［
~UAは まだ 以前の時点から`利用者の意図についての新たな情報$を受取ってない
］
⇒
~RET 以前の時点における結果
◎
If there was a previous invocation of this algorithm with the same name and settings, returning previousResult, and the UA has not received new information about the user's intent since that invocation, return previousResult.
</li>
			<li>
~RET ［
~UA視点による利用者の意図に合致しつつ,
%特能 の`~extra許可~data拘束$も満たす
］ような，［
%特能 `~extra許可~data型$
］の~instance
◎
Return the instance of name's extra permission data type that matches the UA's impression of the user's intent, taking into account any extra permission data constraints for name.
</li>
		</ol>
	</dd>
	<dd>
指定された場合、 %特能 用の`~extra許可~data$を利用-可能になる。
◎
If specified, the extra permission data algorithm is usable for this feature.
</dd>
	<dd class="trans-note">【
すなわち，既定では（省略時）、`~extra許可~data$はない。
】【
この “型” には、何らかの~IDLが含意されるわけではないようだ。
】</dd>

	<dt>
`~extra許可~data拘束@
◎
Optional extra permission data constraints:
</dt>
	<dd>
~UAが %特能 用の`~extra許可~data$として返せる値を拘束する。
◎
Constraints on the values that the UA can return as a PermissionName's extra permission data.＼
</dd>
	<dd>
既定では（省略時）、利用者の意図を超える拘束はないとする。
◎
Defaults to no constraints beyond the user's intent.
</dd>

	<dt>
`許可~結果型@
◎
A permission result type:
</dt>
	<dd>
`PermissionStatus$I
または，その下位型。
◎
PermissionStatus or one of its subtypes.＼
</dd>
	<dd>
未指定な場合の既定は、 `PermissionStatus$I とする。
◎
If unspecified, this defaults to PermissionStatus.
</dd>

	<dt>
`許可~query~algo@
◎
A permission query algorithm:
</dt>
	<dd>
2 つの引数
⇒＃
%特能 の`許可~記述子~型$の~instance,
%特能 の`許可~結果型$の 新たな または既存の~instance
◎終
による~queryの結果で，後者の引数を更新する。
［
`Permissions$I の `query()$m ~method ／
`~PermissionStatus更新~手続き$
］で利用される。
◎
Takes an instance of the permission descriptor type and a new or existing instance of the permission result type, and updates the permission result type instance with the query result. Used by Permissions' query(permissionDesc) method and the PermissionStatus update steps.＼
</dd>
	<dd>
未指定な場合の既定は、`既定の許可を~queryする~algo$とする。
◎
If unspecified, this defaults to the default permission query algorithm.
</dd>
	<dd class="algo">
<p>
`既定の許可を~queryする~algo@
は、所与の
( `PermissionDescriptor$I %許可~記述子, `PermissionStatus$I %状態s )
に対し，次の手続きを走らす：
◎
The default permission query algorithm, given a PermissionDescriptor permissionDesc and a PermissionStatus status, runs the following steps:
</p>
		<ol>
			<li>
%状態s の `state$m ~SET `許可~状態$( %許可~記述子 )
◎
Set status.state to permissionDesc's permission state.
</li>
		</ol>
	</dd>

	<dt>
`許可~revocation~algo@
◎
A permission revocation algorithm:
</dt>
	<dd>
引数はとらない。
それは，`利用者により許可が~revokeされたとき反応する$が、
その前に，実装における他の部分
— ［
`許可~状態$ ／ `~extra許可~data$
］の結果における変化と同期cさせ続ける必要があるもの —
があれば それを更新する。
◎
Takes no arguments. Updates any other parts of the implementation that need to be kept in sync with changes in the results of permission states or extra permission data, and then react to the user revoking permission.
</dd>
	<dd>
未指定な場合の既定は、`利用者により許可が~revokeされたとき反応する$。
◎
If unspecified, this defaults to running react to the user revoking permission.
</dd>
</dl>

<p>
`既定の強力な特能@
とは、`強力な特能$のうち，上の各種［
型／~algo
］すべて†が既定のそれらにされたものをいう。
【†~flag（`~secureでない文脈にて許容されるか$）は除外されていることに注意。】
◎
A default powerful feature is a powerful feature with all of the above types and algorithms defaulted.
</p>

			</section>
			<section id="aspects">
<h4 title="Aspects">2.2.2. 側面</h4>

<p>
各 `強力な特能$は、
0 個以上の追加的な
`側面@
— ~web~siteが~accessするための許可を要請できる側面 —
を定義できる。
◎
Each powerful feature can define zero or more additional aspects that websites can request permission to access.
</p>

<p>
`側面$を述べるためには，当の仕様は、
当の`強力な特能$の`許可~記述子~型$として，
`PermissionDescriptor$I を`継承-$diCする~Web~IDL`辞書$を定義しなければナラナイ。
◎
To describe an aspect, a specification MUST define a WebIDL dictionary that inherits from PermissionDescriptor, and have that interface be its permission descriptor type.
</p>

<div class="example" id="example-defining-your-own-permission-descriptor-type">
<p>
自前の`許可~記述子~型$を定義する例。
ある仮の`強力な特能$ “~food検出器~API” が，
2 つの`側面$
— ［
~taste, ~smell
］を~senseする†ことを許容する側面 —
を伴うとする
【すなわち、この~APIは，名前 `sense^l で`識別される特能$であるとする】。
当の仕様は、［
`PermissionDescriptor$I を`継承-$diCする新たな辞書
］として，次を定義することになろう：
◎
Example 4: Defining your own permission descriptor type
◎
A hypothetical powerful feature "food detector API" has two aspects that allow sensing taste and smell. So, a specification would define a new WebIDL interface that inherits PermissionDescriptor:
</p>

<pre>
dictionary SensesPermissionDescriptor : PermissionDescriptor {
  boolean canSmell = false;
  boolean canTaste = false;
}
</pre>

<p>
それは、次の仕方で，~APIを介して~queryされることになろう：
◎
Which would then be queried via the API in the following way:
</p>

<pre class="lang-js">
/* <span class="comment">
強力な特能 `sense^l には，モノを~smellすることは許容されるか否か検査する
◎
Check if the "sense" powerful feature is allowed to smell things
</span> */
const %status = await navigator.permissions.query({
  name: "senses",
  canSmell: true,
});
/* <span class="comment">
%status について何か関心事を行う。
◎
Do something interesting with the status.
</span> */
</pre>

<p>
利用者は、強力な特能 `sense^l を `taste^l に限るよう制約し得る
— その事例では、
上の `PermissionStatus$I 【すなわち %status 】の `state$m は `denied$pS になる。
◎
A user can restrict the "sense" powerful feature to only "taste", in which case the PermissionStatus's state above would be "denied" .
</p>
</div>

			</section>
		</section>
		<section id="reading-current-states">
<h3 title="Reading the current permission state">2.3. 現在の許可~状態の読取n法</h3>

<div class="algo">
<p>
`許可~状態@
は、所与の
( `PermissionDescriptor$I %記述子, `環境~設定群~obj$ %設定群 （省略時は ε ） )
に対し，次を走らせた結果で与えられる
— それは［
`granted$pS,
`prompt$pS,
`denied$pS
］のいずれかを返す：
◎
A descriptor's permission state for an optional environment settings object settings is the result of the following algorithm, which returns one of "granted", "prompt", or "denied":
</p>
<ol>
	<li>
~IF［
%設定群 ~EQ ε
］
⇒
%設定群 ~SET `現在の設定群~obj$
◎
If settings wasn't passed, set it to the current settings object.
</li>
	<li>
%特能 ~LET %記述子 の `name$m で`識別される特能$
◎
↓</li>
	<li>
~IF［
%設定群 は`~secureな文脈$enVでない
］~AND［
%特能 は，`~secureでない文脈にて許容されて$いない
］
⇒
~RET `denied$pS
◎
If settings is a non-secure context and descriptor.name isn't allowed in non-secure contexts, then return "denied".
</li>
	<li>
~IF［
%特能 は`施策により制御される特能$である
］~AND［
%設定群 【の`大域~obj$enV】に`結付けられている文書$は在って†、その文書に %特能 の`利用は許容されて$いない
【† 大域~objは~windowでない場合、そのような文書は定義されない】
］
⇒
~RET `denied$pS
◎
If there exists a policy-controlled feature identified by descriptor.name and settings has an associated Document named document, run the following step:
• If document is not allowed to use the feature identified by descriptor.name return "denied".
</li>
	<li>
~IF［
この~algoは、以前に，同じ
( %記述子, %設定群 )
で呼出されている
］~AND［
~UAは、まだ 以前の時点から`利用者の意図についての新たな情報$を受取ってない
］
⇒
~RET 以前の時点における結果
◎
If there was a previous invocation of this algorithm with the same descriptor and settings, returning previousResult, and the UA has not received new information about the user's intent since that invocation, return previousResult.
</li>
	<li>
<p>
~RET 次に挙げる選択肢のうち，~call元の~algoに対し［
利用者の意図を最も正確aに反映しつつ，
%特能 の`許可~状態~拘束$も満たす
］もの：
◎
Return whichever of the following options most accurately reflects the user's intent for the calling algorithm, taking into account any permission state constraints for descriptor.name:
</p>
		<dl class="switch">
			<dt>
利用者に~promptすることなく成功する
◎
succeed without prompting the user
</dt>
			<dd>`granted$pS</dd>

			<dt>
利用者に~promptを示して，成功するかどうか裁定してもらう
◎
show the user a prompt to decide whether to succeed
</dt>
			<dd>`prompt$pS</dd>

			<dt>
利用者に~promptすることなく失敗する
◎
fail without prompting the user
</dt>
			<dd>`denied$pS</dd>
		</dl>
	</li>
</ol>

<p class="issue">
<a href="https://github.com/w3c/permissions/issues/278">課題 #278</a>：
Safari のみが、［
この~algoが、同じ生成元に属する異なる設定群~objに対し，異なる結果を返す
］ような，既知な~UAである。
`いくつかアリな設定群~obj$のうち，どれを利用するか~testするべきである。
◎
Issue 278: Safari returns different results for current permission state
◎
Safari is the only known UA that returns different results from this algorithm for different settings objects with the same origin. We should test which of the several possible settings objects it uses.
</p>

<p>
所与の `PermissionName$I 列挙~値 %名前 に対する`許可~状態$は、次の略記である
⇒
`許可~状態$( `name$m ~memberが %名前 に設定された`PermissionDescriptor$I )
◎
As a shorthand, a PermissionName name's permission state is the permission state of a PermissionDescriptor with its name member set to name.
</p>

</div>

		</section>
		<section id="requesting-more-permission">
<h3 title="Requesting permission to use a powerful feature">2.4. 強力な特能を利用する更なる許可の要請-法</h3>

<p class="note">注記：
仕様の策定者は、この節に与える~algoが 利用者からの入力を待機し得ることに注意されたし
— ~main~threadで走っている~algoからは利用されるべきでない。
◎
Spec authors, please note that algorithms in this section can wait for user input; so they shouldn't be used from other algorithms running on the main thread.
</p>

<div class="algo">
<p>
所与の %記述子 を
`利用する許可を要請する@
ときは、次の手続きを遂行するモノトスル
— この~algoは［
`granted$pS ／ `denied$pS
］を返す：
◎
To request permission to use a descriptor, the UA must perform the following steps. This algorithm returns either "granted" or "denied".
</p>
<ol>
	<li>
%現~状態 ~LET `許可~状態$( %記述子 )
◎
Let current state be the descriptor's permission state.
</li>
	<li>
~IF［
%現~状態 ~NEQ `prompt$pS
］
⇒
~RET %現~状態
◎
If current state is not "prompt", return current state and abort these steps.
</li>
	<li>
<p>
［
~call元の~algoが［
%記述子 が述べる`強力な特能$
］を利用する
］ための許可を利用者に依頼する
⇒
~RET 利用者からの~~回答に応じて
⇒＃
是認したならば `granted$pS ／
~ELSE_ `denied$pS
◎
Ask the user's permission for the calling algorithm to use the powerful feature described by descriptor.
◎
If the user grants permission, return "granted"; otherwise return "denied".＼
</p>

<p>
この~~回答は、［［
この`~realm$,
および`同一-生成元$に属する他の`~realm$
］用の，`利用者の意図についての新たな情報$
］を供するものとしてヨイ。
◎
The user's interaction may provide new information about the user's intent for this realm and other realms with the same origin.
</p>

<div class="note">
<p>注記：
ここでの［
許可~UI ／ ~UAが利用者の意図をどう推定するか
］の詳細については、意図的に曖昧にしてある。
~UAは、この枠組みの下で数多の~UIを探求するべきである。
◎
This is intentionally vague about the details of the permission UI and how the UA infers user intent. UAs should be able to explore lots of UI within this framework.
</p>
<p class="trans-note">【
例えば，利用者が是認せず，明示的に否認することもなく~UIを退けた場合、`利用者の意図についての新たな情報$としては扱わないことも考えられる。
あるいは，利用者により予め為された環境設定により、
利用者からの~~回答を待機することなく，即時に結果を返すこともあるかもしれない。
】</p>
</div>
	</li>
</ol>

<p>
`PermissionName$I %名前 を`利用する許可を要請する$とは、次の略記である
⇒
［
`name$m ~memberが %名前 に設定された `PermissionDescriptor$I
］を`利用する許可を要請する$
◎
As a shorthand, requesting permission to use a PermissionName name, is the same as requesting permission to use a PermissionDescriptor with its name member set to name.
</p>
</div>

		</section>
		<section id="prompt-the-user-to-choose">
<h3 title="Prompt the user to choose">2.5. 何かを選ぶよう利用者に~promptする</h3>

<div class="algo">
<p>
%記述子 に結付けられている %選択肢~群 の中から一つを
`選ぶよう利用者に~promptする@
ときは、~UAは，次の手続きを遂行するモノトスル
— この~algoは［
`denied$pS ／ %選択肢~群 を成す選択肢のうち一つ
］を返す：
◎
To prompt the user to choose one of several options associated with a descriptor, the UA must perform the following steps. This algorithm returns either "denied" or one of the options.
</p>
<ol>
	<li>
~IF［
`許可~状態$( %記述子 ) ~EQ `denied$pS
］
⇒
~RET `denied$pS
◎
If descriptor's permission state is "denied", return "denied" and abort these steps.
</li>
	<li>
任意選択で
⇒
~IF［
`許可~状態$( %記述子 ) ~EQ `granted$pS
］
⇒
~RET %選択肢~群 を成す選択肢のうち一つ
— 利用者に~promptすることなく
⇒
この場合，~UAは、後続の同じ
( %記述子, 選択肢の集合 )
から`選ぶよう利用者に~promptする$ときも、~UAが`利用者の意図についての新たな情報$を受取っていない限り，同じ選択肢を返すモノトスル。
◎
If descriptor's permission state is "granted", the UA may return one of options and abort these steps. If the UA returns without prompting, then subsequent prompts for the user to choose from the same set of options with the same descriptor must return the same option, unless the UA receives new information about the user's intent.
</li>
	<li>
<p>
利用者に［
%選択肢~群 から一つの選択肢を選ぶか, 許可を否認するか
］依頼した上で
— ~call元の~algoが［
~prompt内に含める~extra情報
］を指定した場合は，それも含めた上で —
選ばれるまで待機する：
◎
Ask the user to choose one of the options or deny permission, and wait for them to choose. If the calling algorithm specified extra information to include in the prompt, include it.
</p>
		<ul>
			<li>
~RET ［
利用者は ある選択肢を選んだならば それ ／
~ELSE_ `denied$pS
］
◎
If the user chose an option, return it; otherwise return "denied".＼
</li>
			<li>
利用者から［
選んだものを，他の~realmにも適用するよう意図する
］ことが指示された場合は、それを，［
この~realm,
および`同一-生成元$に属する他の`~realm$
］用の`利用者の意図についての新たな情報$として扱うとする。
◎
If the user's interaction indicates they intend this choice to apply to other realms, then treat this this as new information about the user's intent for other realms with the same origin.
</li>
		</ul>
<p class="note">注記：
ここでの［
許可~UI ／
~UAが利用者の意図をどう推定するか
］についての詳細は、意図的に曖昧にしてある。
~UAは、この枠組みの下で数多の~UIを探求するべきである。
◎
This is intentionally vague about the details of the permission UI and how the UA infers user intent. UAs should be able to explore lots of UI within this framework.
</p>
	</li>
</ol>

<p>
`PermissionName$I %名前 に結付けられている選択肢~群から一つを`選ぶよう利用者に~promptする$とは、次の略記である
⇒
［
`name$m ~memberが %名前 に設定された`PermissionDescriptor$I 
］に結付けられている選択肢~群から`選ぶよう利用者に~promptする$
◎
As a shorthand, prompting the user to choose from options associated with a PermissionName name, is the same as prompting the user to choose from those options associated with a PermissionDescriptor with its name member set to name.
</p>
</div>

		</section>
		<section id="reacting-to-revocation">
<h3 title="Reacting to users revoking permission">2.6. 利用者から許可が~revokeされたときの反応-法</h3>

<div class="algo">
<p>
~UAは，［
利用者が［
ある`~realm$ %~Realm において，`強力な特能$ %特能 を利用する許可を是認する
］ことを，もはや意図しない
］ことを学習したときは、次に従って
`利用者により許可が~revokeされたとき反応する@
とする：
◎
When the UA learns that the user no longer intends to grant permission for a realm to use a feature, react to the user revoking permission by:
</p>
<ol>
	<li>
`~taskを~queueする$(
【`~task源$が指定されていない（`許可~task源$？）】,
%特能 の`許可~revocation~algo$,
%~Realm の`設定群~obj$の`担当の~event~loop$enV
)
◎
Queue a task on the Realm's settings object's responsible event loop to run that feature's permission revocation algorithm.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="navigator-and-workernavigator-extension">
<h2 title="Extensions to the Navigator and WorkerNavigator interfaces">3. `Navigator^I, `WorkerNavigator^I ~interfaceに対する拡張</h2>

<pre class="idl">
[`Exposed$=(Window)]
partial interface `Navigator$I {
  [`SameObject$] readonly attribute `Permissions$I `permissions@m;
};
</pre>

<pre class="idl">
[`Exposed$=(Worker)]
partial interface `WorkerNavigator$I {
  [`SameObject$] readonly attribute `Permissions$I `~permissions0@m;
};
</pre>

	</section>
	<section id="permissions-interface">
<h2 title="Permissions interface">4. `Permissions^I ~interface</h2>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `Permissions@I {
  `Promise$&lt;`PermissionStatus$I&gt; `query$m(`object$ %permissionDesc);
};

dictionary `PermissionDescriptor@I {
  required `PermissionName$I `name@m;
};
</pre>

<div class="algo" id="query-method">
`query(permissionDesc)@m
~method手続きは
⇒
`許可を~queryする$( %permissionDesc )
◎
4.1. query() method
◎
When the query() method is invoked, the user agent MUST run the following＼
</div>

<div class="algo">
<p>
`許可を~queryする@
ときは、所与の
( %許可~記述子 )
に対し：
◎
query a permission algorithm, passing the parameter permissionDesc:
</p>
<ol>
	<li>
<p>
%有型~記述子 ~LET 次の下位手続きを走らせた結果：
</p>
		<ol>
			<li>
%根~記述子 ~LET %許可~記述子 を `PermissionDescriptor$I 型の`~IDL値に変換-$した結果
</li>
			<li>
%特能 ~LET %根~記述子 の `name$m 値で`識別される特能$
</li>
			<li>
~RET %許可~記述子 を［
%特能 の`許可~記述子~型$
］の`~IDL値に変換-$した結果
</li>
		</ol>
<p>
この段で例外が投出されたときは
⇒
~RET その例外で`却下される~promise$
</p>

◎
Let rootDesc be the object permissionDesc refers to, converted to an IDL value of type PermissionDescriptor. If this throws an exception, return a promise rejected with that exception and abort these steps.
◎
Let typedDescriptor be the object permissionDesc refers to, converted to an IDL value of rootDesc.name's permission descriptor type. If this throws an exception, return a promise rejected with that exception and abort these steps.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a newly-created Promise.
</li>
	<li>
~RET %~promise
— ただし、以降の手続きも`並列的$に走らす
◎
Return promise and continue the following steps asynchronously.
</li>
	<li>
%状態s ~LET `~PermissionStatusを作成する$( %有型~記述子 )
◎
Run the steps to create a PermissionStatus for typedDescriptor, and let status be the result.
</li>
	<li>
%名前 ~LET %状態s の `query$sl[ "`name$m" ]
◎
↓</li>
	<li>
%名前 で`識別される特能$の`許可~query~algo$( %名前, %状態s )
◎
Run status.[[query]].name's permission query algorithm, passing status.[[query]] and status.
</li>
	<li>
%状態s で %~promise を`解決する$
◎
Resolve promise with status.
</li>
</ol>
</div>

		</section>
	
	<section id="permissionstatus-interface">
<h2 title="PermissionStatus interface">5. `PermissionStatus^I ~interface</h2>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PermissionStatus@I : `EventTarget$I {
  readonly attribute `PermissionState$I `state$m;
  readonly attribute `PermissionName$I `~name0$m;
  attribute `EventHandler$I `onchange$m;
};

enum `PermissionState@I {
  `granted$pS,
  `denied$pS,
  `prompt$pS,
};
</pre>

<p>
`PermissionStatus$I の各~instanceは、
`query@sl
内部~slotを伴って作成される。
それは、［
ある`強力な特能$の`許可~記述子~型$
］の~instanceを~~保持する。
◎
PermissionStatus instances are created with a [[query]] internal slot, which is an instance of a feature's permission descriptor type.
</p>

<p>
この~APIを利用してときの各~列挙値［
`granted@pS
は`是認-$された／
`denied@pS
は`否認-$された／
`prompt@pS
は`~prompt$する
］ことの概念を表現する。
◎
When using the API, the "granted", "denied", and "prompt" enum values represent the concepts of granted, denied, and prompt respectively.
</p>

<div class="algo">
<p id="creating-instances">
`~PermissionStatusを作成する@
ときは、所与の
( `PermissionDescriptor$I %許可~記述子 )
に対し，次を走らす：
</p>
<ol>
	<li>
%名前 ~LET %許可~記述子 の `name$m 値
</li>
	<li>
%特能 ~LET %名前 で`識別される特能$
</li>
	<li>
%結果 ~LET 新たな［
%特能 の`許可~結果型$
］の~instance
</li>
	<li>
%結果 の `query$sl 内部~slot ~SET %許可~記述子
</li>
	<li>
%結果 の `~name0$m ~SET %名前
</li>
	<li>
~RET %結果
</li>
</ol>
◎
5.1. Creating instances
◎
To create a PermissionStatus for a given PermissionDescriptor permissionDesc, return a new instance of the permission result type for the feature named by permissionDesc.name, with the [[query]] internal slot initialized to permissionDesc, and name initialized to permissionDesc.name.
</div>

<div class="algo" id="name-attribute">
`~name0@m
取得子~手続きは、初期化~時の値を返す。
◎
5.2. name attribute
◎
The name attribute returns the value it was initialized to.
</div>

<div class="algo" id="state-attribute">
`state@m
取得子~手続きは、最後に設定された値を返す。
◎
5.3. state attribute
◎
The state attribute returns the latest value that was set on the current instance.
</div>

<p id="onchange-attribute">
`onchange@m
属性は、`~event~handler~event型$ `change^et に対応する`~event~handler$である。
◎
5.4. onchange attribute
◎
The onchange attribute is an event handler whose corresponding event handler event type is change.
</p>

<div class="algo">
<p id="PermissionStatus-update">
`~UA$は， `PermissionStatus$I ~instance %状態s の状態が変化したことに自覚したときは、
いつでも，次の
`~PermissionStatus更新~手続き@
を非同期的に走らすモノトスル：
◎
Whenever the user agent is aware that the state of a PermissionStatus instance status has changed, it asynchronously runs the PermissionStatus update steps:
</p>
<ol>
	<li>
%名前 ~LET %状態s の `query$sl[ "`name$m" ]
◎
↓</li>
	<li>
%名前 で`識別される特能$の`許可~query~algo$( %名前, %状態s )
◎
Run status.[[query]].name's permission query algorithm, passing status.[[query]] and status.
</li>
	<li>
次を走らす`~taskを~queueする$(
`許可~task源@
)
⇒
`~eventを発火する$( %状態s, `change^et )
◎
Queue a task on the permissions task source to fire an event named change at status.
</li>
</ol>
</div>

		<section id="permissionstatus-gc">
<h3 title="Garbage collection">5.1. ~garbage収集</h3>

<div class="p">
<p>
`PermissionStatus$I ~obj %P が次のいずれかを満たす間は、
%P に`関連な大域~obj$（ `Window$I ／ `WorkerGlobalScope$I ）
【！Window or WorkerGlobalScope object that the PermissionStatus object's constructor was invoked from】
から %P への強い参照があるモノトスル：
</p>
<ul>
	<li>
%P には `change^et ~event用の~event~listenerが 1 個以上は登録されている。
</li>
	<li>
`許可~task源$から %P により~queueされた~taskが在る
</li>
</ul>
◎
While an PermissionStatus object has one or more event listeners registered for "change", there must be a strong reference from the Window or WorkerGlobalScope object that the PermissionStatus object's constructor was invoked from to the PermissionStatus object itself.
◎
While there is a task queued by an PermissionStatus object on the permissions task source, there must be a strong reference from the Window or WorkerGlobalScope object that the PermissionStatus object's constructor was invoked from to that PermissionStatus object.
</div>

		</section>
	</section>
	<section id="powerful-features-registry">
<h2 title="Powerful features registry">6. 強力な特能~群の~registry</h2>

<pre class="idl">
enum `PermissionName@I {
  `accelerometer$pN,
  `ambient-light-sensor$pN,
  `background-fetch$pN,
  `background-sync$pN,
  `bluetooth$pN,
  `camera$pN,
  `display-capture$pN,
  `geolocation$pN,
  `gyroscope$pN,
  `magnetometer$pN,
  `microphone$pN,
  `midi$pN,
  `nfc$pN,
  `notifications$pN,
  `persistent-storage$pN,
  `push$pN,
  `screen-wake-lock$pN,
  `speaker-selection$pN,
  `xr-spatial-tracking$pN,
};
</pre>

<p>
`PermissionName$I の各~列挙~値は、ある`強力な特能$を識別する。
◎
Each enumeration value in the PermissionName enum identifies a powerful feature.
</p>

		<section id="geolocation">
<h3 title="Geolocation">6.1. 地理所在（ `geolocation^l ）</h3>

<p>
`geolocation@pN
列挙値は、
`Geolocation API$cite `Geolocation$r
による`強力な特能$を識別する。
それは、`既定の強力な特能$である。
◎
The geolocation enum value identifies the Geolocation API powerful feature. It is a default powerful feature.
</p>

		</section>
		<section id="notifications">
<h3 title="Notifications">6.2. 通知（ `notifications^l ）</h3>

<p>
`notifications@pN
列挙値は、
`Notifications API Standard$cite `notifications$r
による`強力な特能$を識別する。
それは、`既定の強力な特能$であり，
`~secureでない文脈にて許容されて$いる。
◎
The notifications enum value identifies the Notifications API Standard powerful feature. It is a default powerful feature with its allowed in non-secure contexts flag set.
</p>

		</section>
		<section id="push">
<h3 title="Push">6.3. ~push（ `push^l ）</h3>

<p>
`push@pN
列挙値は、
`Push API$cite `push-api$r
による`強力な特能$を識別する。
◎
The push enum value identifies the Push API powerful feature.
</p>

<dl>
	<dt>
`許可~記述子~型$
◎
permission descriptor type
</dt>
	<dd>
<pre class="idl">
dictionary `PushPermissionDescriptor@I : `PermissionDescriptor$I {
 `boolean$ `userVisibleOnly@m = false;
};
</pre>
	</dd>
	<dd>
<samp>{name: `push$pN, userVisibleOnly: false}</samp>
は
<samp>{name: `push$pN, userVisibleOnly: true}</samp>
`より強い$とする。
◎
{name: "push", userVisibleOnly: false} is stronger than {name: "push", userVisibleOnly: true}.
</dd>
</dl>

		</section>
		<section id="midi">
<h3 title="Midi">6.4. ~MIDI（ `midi^l ）</h3>

<p>
`midi@pN
列挙値は、
`Web MIDI API$cite `webmidi$r
による`強力な特能$を識別する。
◎
The midi enum value identifies the Web MIDI API powerful feature.
</p>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, is at risk.
</p>

<dl>
	<dt>
`許可~記述子~型$
◎
permission descriptor type
</dt>
	<dd>
<pre class="idl">
dictionary `MidiPermissionDescriptor@I : `PermissionDescriptor$I {
 `boolean$ `sysex@m = false;
};
</pre>
	</dd>
	<dd>
<samp>{name: `midi$pN, sysex: true}</samp>
は
<samp>{name: `midi$pN, sysex: false}</samp>
`より強い$とする。
◎
{name: "midi", sysex: true} is stronger than {name: "midi", sysex: false}.
</dd>
</dl>

		</section>
		<section id="screen-wake-lock">
<h3 title="Screen wake lock">6.5. ~screen~wake~lock（ `screen-wake-lock^l ）</h3>

<p>
`screen-wake-lock@pN
列挙値は、
`Screen Wake Lock API$cite `screen-wake-lock$r
による`強力な特能$を識別する。
それは、`既定の強力な特能$である。
◎
The screen-wake-lock enum value identifies the Screen Wake Lock API API powerful feature. It is a default powerful feature.
</p>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

		</section>
		<section id="media-devices">
<h3 title="Media Devices">6.6. 各種~media機器</h3>

<p>
［
`camera@pN
／
`microphone@pN
／
`speaker-selection@pN
］で`識別される特能$に対する許可は、
`GETUSERMEDIA$r, `audio-output$r
に指定される~media機器の用-法に結付けられている。
◎
The camera, microphone , and speaker-selection permissions are associated with permission to use media devices as specified in [GETUSERMEDIA] and [audio-output].
</p>

<p class="issue">
これらの許可いずれも，その実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
These permissions only have a single implementation, and therefore, as per the W3C Process, are at risk.
</p>
<dl>
	<dt>
`許可~記述子~型$
◎
permission descriptor type
</dt>
	<dd>
<pre class="idl">
dictionary `DevicePermissionDescriptor@I : `PermissionDescriptor$I {
  `DOMString$ `deviceId@m;
};

dictionary `CameraDevicePermissionDescriptor@I : `DevicePermissionDescriptor$I {
  `boolean$ `panTiltZoom@m = false;
};
</pre>
</dd>
	<dd>
許可は、記述子に与えられた機器への~accessを受持つ。
◎
A permission covers access to the device given in the associated descriptor.
</dd>
	<dd>
<p>
記述子が `deviceId$m を伴わない場合、記述子の `name$m で`識別される特能$に類別される すべての機器への~accessを~queryすることになる。
したがって， `camera$pN で`識別される特能$に対する `deviceId$m を伴わない許可~queryに対しては：
◎
If the descriptor does not have a deviceId, its semantic is that it queries for access to all devices of that class. Thus, if a query for the "camera" permission with no deviceId＼
</p>
		<ul>
			<li>
結果が `granted$pS ならば、~camera用の許可~promptは決して生じないことが~~判明することになる。
◎
returns "granted", the client knows that there will never be a permission prompt for a camera, and＼
</li>
			<li>
結果が `denied$pS ならば、~camera用に `getUserMedia()$m で要請しても成功しないことが~~判明することになる。
◎
if "denied" is returned, it knows that no getUserMedia request for a camera will succeed.
</li>
			<li>
~accessに対する許可~状態が一部の~cameraのみに在る場合、
`prompt$pS が返されることになる。
◎
If a permission state is present for access to some, but not all, cameras, a query without the deviceId will return "prompt".
</li>
			<li>
~accessに対する許可~状態が一部の~cameraのみに在る場合、
`prompt$pS が返されることになる。
◎
If a permission state is present for access to some, but not all, cameras, a query without the deviceId will return "prompt".
</li>
		</ul>
	</dd>
	<dd>
<samp>{name: `camera$pN, panTiltZoom: true}</samp>
は
<samp>{name: `camera$pN, panTiltZoom: false}</samp>
`より強い$とする。
◎
{name: "camera", panTiltZoom: true} is stronger than {name: "camera", panTiltZoom: false}.
</dd>
	<dd>
結果が `granted$pS であっても， `getUserMedia()$m の成功-が保証されるわけではないことに注意。
保証されるのは、許可を得る際に利用者に~promptされないことに限られる。
`getUserMedia()^m を失敗させ得るものは，他にいくつもある（利用-中にある~cameraに対する拘束など）。
【！constraints or = constraints on＊？】
◎
Note that a "granted" permission is no guarantee that getUserMedia will succeed. It only guarantees that the user will not be prompted for permission. There are many other things (such as constraints or the camera being in use) that can cause getUserMedia to fail.
</dd>

	<dt>
`~extra許可~data型$
◎
extra permission data type
</dt>
	<dd>
利用者が~accessに関して既定でない裁定を下した各 機器に対応する `deviceId$c 値からなる~list。
◎
A list of deviceId values for the devices the user has made a non-default decision on access to.
</dd>
	<dt>
`許可~query~algo$
◎
permission query algorithm
</dt>
	<dd class="algo">
<p>
次の手続きを走らす：
◎
The permission query algorithm runs the following steps:
</p>
		<ol>
			<li>
<p>
~IF［
`~extra許可~data$内に %許可~記述子 の `deviceId^m は在る
］：
</p>

<ol><li>%状態s の `state$m ~SET `許可~状態$( %許可~記述子 )
</li><li>~RET
</li></ol>
◎
If permissionDesc.deviceId exists in the extra permission data, set status.state to permissionDesc's permission state and terminate these steps.
</li>
			<li>
%大域~記述子 ~LET %許可~記述子 の複製から `deviceId$m ~memberを除去した結果
◎
Let global be a copy of permissionDesc with the deviceId member removed.
</li>
			<li>
%状態s の `state$m ~SET `許可~状態$( %大域~記述子 )
◎
Set status.state to global's permission state.
</li>
		</ol>
	</dd>
	<dt>
`許可~revocation~algo$
◎
permission revocation algorithm
</dt>
	<dd>
これは、`機器~許可~revocation~algo$に引数
( 記述子の `name$m, 記述子の `deviceId$m （無い場合は `undefined^c ） )
を渡して~callした結果になる。
◎
This is the result of calling the device permission revocation algorithm passing name and deviceId as arguments. If the descriptor does not have a deviceId, then undefined is passed in place of deviceId.
</dd>
</dl>

		</section>
		<section id="background-fetch">
<h3 title="Background Fetch">6.7. ~background~fetch（ `background-fetch^l ）</h3>

<p>
`background-fetch@pN
列挙値は、
`Background Fetch$cite `background-fetch$r
による`強力な特能$を識別する。
◎
The background-fetch enum value identifies the Background Fetch powerful feature.
</p>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

		</section>
		<section id="background-sync">
<h3 title="Background Sync">6.8. ~background~同期c~API（ `background-sync^l ）</h3>

<p>
`background-sync@pN
列挙値は、
`Web Background Synchronization$cite `web-background-sync$r
による`強力な特能$を識別する。
◎
The background-sync enum value identifies the Web Background Synchronization powerful feature.
</p>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

		</section>
		<section id="bluetooth">
<h3 title="Bluetooth">6.9. ~bluetooth（ `bluetooth^l ）</h3>

<p>
`bluetooth@pN
列挙値は、
`Web Bluetooth$cite `web-bluetooth$r
による`強力な特能$を識別する。
◎
The bluetooth enum value identifies the Web Bluetooth powerful feature.
</p>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

		</section>
		<section id="persistent-storage">
<h3 title="Persistent Storage">6.10. 持続的~storage（ `persistent-storage^l ）</h3>

<p>
`persistent-storage@pN
列挙値は、
`Storage Standard$cite `storage$r
による`強力な特能$を識別する。
◎
The persistent-storage is enum value identifies the Storage Standard powerful feature.
</p>

		</section>
		<section id="ambient-light-sensor">
<h3 title="Ambient Light Sensor">6.11. 環境光~sensor（ `ambient-light-sensor^l ）</h3>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

<p>
`ambient-light-sensor@pN
列挙値は、
`Ambient Light Sensor$cite `ambient-light$r
~APIによる`強力な特能$を識別する。
◎
The ambient-light-sensor enum value identifies the Ambient Light Sensor API powerful feature.
</p>

<dl>
	<dt>
`許可~revocation~algo$
◎
Its permission revocation algorithm is＼
</dt>
	<dd>
次を走らす
⇒
`汎用~sensor許可~revocation~algo$( `ambient-light-sensor$pN )
◎
the result of calling generic sensor permission revocation algorithm passing it "ambient-light-sensor" as argument.
</dd>
</dl>

		</section>
		<section id="accelerometer">
<h3 title="Accelerometer">6.12. 加速度計（ `accelerometer^l ）</h3>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

<p>
`accelerometer@pN
列挙値は、
`Accelerometer$cite `accelerometer$r
~APIによる`強力な特能$を識別する。
◎
The accelerometer enum value identifies the Accelerometer API powerful feature.
</p>

<dl>
	<dt>
`許可~revocation~algo$
◎
Its permission revocation algorithm is＼
</dt>
	<dd>
次を走らす
⇒
`汎用~sensor許可~revocation~algo$( `accelerometer$pN )
◎
the result of calling generic sensor permission revocation algorithm passing it "accelerometer" as argument.
</dd>
</dl>

		</section>
		<section id="gyroscope">
<h3 title="Gyroscope">6.13. ~gyroscope（ `gyroscope^l ）</h3>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

<p>
`gyroscope@pN
列挙値は、
`Gyroscope$cite `gyroscope$r
~APIによる`強力な特能$を識別する。
◎
The gyroscope enum value identifies the Gyroscope API powerful feature.
</p>

<dl>
	<dt>
`許可~revocation~algo$
◎
Its permission revocation algorithm is＼
</dt>
	<dd>
次を走らす
⇒
`汎用~sensor許可~revocation~algo$( `gyroscope$pN )
◎
the result of calling generic sensor permission revocation algorithm passing it "gyroscope" as argument.
</dd>
</dl>

		</section>
		<section id="magnetometer">
<h3 title="Magnetometer">6.14. 磁力計（ `magnetometer^l ）</h3>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

<p>
`magnetometer@pN
列挙値は、
`Magnetometer$cite `magnetometer$r
~APIによる`強力な特能$を識別する。
◎
The magnetometer enum value identifies the Magnetometer API powerful feature.
</p>

<dl>
	<dt>
`許可~revocation~algo$
◎
Its permission revocation algorithm is＼
</dt>
	<dd>
次を走らす
⇒
`汎用~sensor許可~revocation~algo$( `magnetometer$pN )
◎
the result of calling generic sensor permission revocation algorithm passing it "magnetometer" as argument.
</dd>
</dl>

		</section>
		<section id="display-capture">
<h3 title="Display Capture">6.15. ~display-capture（ `display-capture^l ）</h3>

<p>
`display-capture@pN
列挙値は、
`Screen Capture$cite `screen-capture$r
による`強力な特能$を識別する。
◎
The display-capture enum value identifies the Screen Capture powerful feature.
</p>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

<dl>
	<dt>
`許可~状態~拘束$
◎
permission state constraints
</dt>
	<dd>
この記述子の`許可~状態$用の妥当な値は［
`prompt$pS ／ `denied$pS
］に限るとする。
~UAは、この記述子の`許可~状態$を `granted$pS に設定しないモノトスル。
◎
Valid values for this descriptor's permission state are "prompt" and "denied". The user agent MUST NOT ever set this descriptor's permission state to "granted".
</dd>
</dl>

		</section>
		<section id="nfc">
<h3 title="NFC">6.16. ~NFC（ `nfc^l ）</h3>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

<p>
`nfc@pN
列挙値は、
`Web NFC API$cite `web-nfc$r
による`強力な特能$を識別する。
◎
The nfc enum value identifies the Web NFC API powerful feature.
</p>

		</section>
		<section id="xr-api">
<h3 title="XR Spatial tracking">6.17. ~XR空間的~追跡（ `xr-spatial-tracking^l ）</h3>

<p>
`xr-spatial-tracking@pN
列挙値は、
`WebXR Device API$cite `webxr$r
による`強力な特能$を識別する。
【~XRは AR, VR, 等々の総称（ “〜~~現実” ）。】
◎
The xr-spatial-tracking enum value identifies the WebXR Device API Device API powerful feature.
</p>

		</section>
	</section>
	<section id="relationship-to-permissions-policy">
<h2 title="Relationship to the Permissions Policy specification">許可~施策~仕様との関係性</h2>

~INFORMATIVE

<p>
この仕様, 許可~施策~仕様（ `Permissions Policy^cite, `Permissions-Policy$r ）どちらも，技術的には一連の “許可” を処するものであるが、
それぞれ，~platformにおける別個な目的を~serveする。
だとしても、この 2 つの仕様には，重合する所も明示的にある。
◎
Although technically this specification and the Permissions Policy specification ([Permissions-Policy]) deal with "permissions", each specification serves a distinct purpose in the platform. Nevertheless, the two specifications do explicitly overlap.
</p>

<p>
この仕様が専ら懸念する`強力な特能$は、
その~accessが~UAが仲介する許可~UIを通して管理されるものである
（すなわち、
利用者の同意は，［
当の特能が利用されようとする前に，利用者が許可を与える
］ことにより表出され、
どの利用者も，理由を問わず その許可をいつでも否認する能を維持する）。
これらの強力な特能は、この仕様の `PermissionName$I 列挙型により明示的に識別される。
◎
On the one hand, this specification exclusively concerns itself with powerful features whose access is managed through a user-agent mediated permissions UI (i.e., permissions where the user gives express consent before that feature can be used, and where the user retains the ability to deny that permission at any time for any reason). These powerful features are explicitly identified by this specification's PermissionName enum.
</p>

<p>
他方，許可~施策~仕様は、`許可~施策$【！`許可~施策$doc】を通して，`強力な特能$を選択的に［
可能化する／不能化する
］ことを開発者に許容する（~HTTP~header, `allow$a 属性どちらにせよ）。
許可~施策~仕様が視野に入れる~APIや特能は、
この仕様の `PermissionName$I 列挙型により識別されるものを超える（例： `sync-xhr^pN ／ `gamepad^pN ）。
許可~施策は、このイミにおいて，この仕様を組み込むものであり、
ある特能が可用になるかどうかを，この仕様とは まったく独立に統治する。
◎
On the other hand, the Permissions Policy specification allows developers to selectively enable and disable powerful features through a "permissions policy" (be it a HTTP header or a the allow attribute). The APIs and features in scope for the Permissions Policy specification go beyond those identified in this specification's PermissionName enum (e.g., "sync-xhr" and "gamepad"). In that sense, the Permissions Policy subsumes this specification in that Permissions Policy governs whether a feature is available at all, independently of this specification.
</p>

<p>
許可~施策~仕様により不能化される`強力な特能$は、
この仕様においては，その`許可~状態$は常に`否認-$されるものとして反映される。
このことは、［
現在の`許可~状態$の読取りが，
`HTML$r の “`利用は許容されて$いるかどうか” の検査に依拠する
］ことから生じる
— この検査~自体も，許可~施策~仕様の中へ~callする。
ここでの重要な注意点は、
許可の名前が両~仕様にて共有されることである。
この仕様は `PermissionName$I 列挙型を備える一方で、
許可~施策~仕様は，許可の名前を定義している他の仕様に依拠する
（例： 許可 `gamepad^pN は、 `Gamepad$r 内に定義される, 等々）。
◎
A powerful feature that has been disabled by the Permissions Policy specification always has its permission state reflected as "denied" by this specification. This occurs because reading the current permission state relies on [HTML]'s "allowed to use" check, which itself calls into the Permissions Policy specification. Important to note here is the sharing of permission names across both specifications. Where this specification has the PermissionName enum, the Permissions Policy specification relies on other specifications defining the names of the permissions (e.g., the permission "gamepad" is defined in [Gamepad], and so on).
</p>

<p>
最後に，ある強力な特能が［
許可~施策~仕様が供する手段を通して`是認-$されるようになる
］ことはアリでない。
是認され得る仕方は、~UAが供する許可~UIを通すか，他の何らかの~UA施策による他にない。
◎
Finally, it's not possible for a powerful feature to ever become "granted" through any means provided by the Permissions Policy specification. The only way that a powerful feature can be "granted" is through a user-agent provided permission UI, or by some other user agent policy.
</p>

	</section>
	<section id="automation">
<h2 title="B. Automated testing">自動化された~test法</h2>
~INFORMATIVE

<p>
この仕様の自動化された~test法は、
`Permissions Automation$cite
文書に供される~APIを利用して遂行される。
◎
Automated testing of this specification is performed using the API provided by the Permissions Automation document.
</p>

	</section>
	<section id="privacy-considerations">
<h2 title="C. Security and privacy considerations">~security／~privacyの考慮点</h2>
~INFORMATIVE

<p>
ある敵対者は、末端利用者に対応する “指紋” を作成するための要素として，`許可~状態$も利用できる。
敵対者は，実際に~APIを利用して すでに許可の状態を決定できるが、それは，末端利用者に対し許可~要請~UIが呈示される結果に至ることが多い（その許可が すでに是認されている（ `granted$pS ）場合は除き）。
したがって，この~APIは、~web~siteに新たな指紋収集~情報を公開することはないが，敵対者にとって この情報への目立たない~accessを容易にする。
したがって，実装には、`許可~状態$を~queryするのを（大域的に, または選択的に）阻止する選択肢を，利用者に与えることが奨励される。
◎
An adversary could use a permission state as an element in creating a "fingerprint" corresponding to an end-user. Although an adversary can already determine the state of a permission by actually using the API, that often leads to a permission request UI being presented to the end-user (if the permission was not already "granted"). Thus, even though this API doesn't expose new fingerprinting information to websites, it makes it easier for an adversary to have discreet access to this information. Thus, implementations are encouraged to have an option for users to block (globally or selectively) the querying of permission states.
</p>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

~INFORMATIVE

<div>
<p>
~API設計と編集上の作業に助力された、次の方々に：
</p>
<div lang="en">
Adrienne Porter Felt, Anne van Kesteren, Domenic Denicola, Jake Archibald and Wendy Seltzer
</div>
◎
The editors would like to thank Adrienne Porter Felt, Anne van Kesteren, Domenic Denicola, Jake Archibald and Wendy Seltzer for their help with the API design and editorial work.
</div>

	</section>
</main></div>

