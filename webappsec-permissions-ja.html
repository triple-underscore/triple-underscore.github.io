<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Permissions（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style>
samp {
	white-space: nowrap;
	background: #F0F0F0;
	margin-left: 0.5em;
	margin-right: 0.5em;
}

i {
	text-decoration: underline;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // 文献
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l': //literal
case 'pS':
case 'pN':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl': // js slot
	text = `[[${key}]]`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Permissions
spec_date:2021-12-07
trans_update:2021-12-09
source_checked:210831
page_state_key:WEBAPPSEC
original_url:https://w3c.github.io/permissions/
	abbr_url:PERMISSIONS
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
conformance:w3c
copyright:2021,permissive
trans_1st_pub:2017-03-14


●●class_map
et:event-type
e:element
a:attr
sl:js-slot

●●tag_map
p:var
a:code
I:code
m:code
et:code
sl:span
e:code
c:code
i:i
cite:cite

●●original_id_map

●●mdn_urls
dom-permissions:API/Permissions
dom-permissionstatus:API/PermissionStatus
	dom-permissiondescriptor:API/PermissionDescriptor
	dom-permissionname:API/PermissionName
	dom-permissionstate:API/PermissionState

●●link_map

	●IDL
SameObject:~WEBIDLjs#SameObject
Exposed:~WEBIDLjs#Exposed

object:~WEBIDL#idl-object
Promise:~WEBIDL#idl-promise

I.Window:~WINDOW#window
I.WorkerGlobalScope:~WORKERS#workerglobalscope

I.Permissions:#dom-permissions
I.PermissionDescriptor:#dom-permissiondescriptor
I.PermissionName:#dom-permissionname
I.PermissionState:#dom-permissionstate
I.PermissionStatus:#dom-permissionstatus

I.EventHandler:~WAPI#eventhandler
I.EventTarget:~DOM4#eventtarget
I.Navigator:~HTMLnavigator#navigator
I.WorkerNavigator:~WORKERS#workernavigator

pN.accelerometer:#dom-permissionname-accelerometer
pN.ambient-light-sensor:#dom-permissionname-ambient-light-sensor
pN.background-fetch:#dom-permissionname-background-fetch
pN.background-sync:#dom-permissionname-background-sync
pN.bluetooth:#dom-permissionname-bluetooth
pN.camera:#dom-permissionname-camera
pN.display-capture:#dom-permissionname-display-capture
pN.geolocation:#dom-permissionname-geolocation
pN.gyroscope:#dom-permissionname-gyroscope
pN.magnetometer:#dom-permissionname-magnetometer
pN.microphone:#dom-permissionname-microphone
pN.midi:#dom-permissionname-midi
pN.nfc:#dom-permissionname-nfc
pN.notifications:#dom-permissionname-notifications
pN.persistent-storage:#dom-permissionname-persistent-storage
pN.push:#dom-permissionname-push
pN.screen-wake-lock:#dom-permissionname-screen-wake-lock
pN.speaker-selection:#dom-permissionname-speaker-selection
pN.xr-spatial-tracking:#dom-permissionname-xr-spatial-tracking

pS.denied:#dom-permissionstate-denied
pS.granted:#dom-permissionstate-granted
pS.prompt:#dom-permissionstate-prompt

m.getUserMedia:~MEDIACAPTURE#dom-mediadevices-getusermedia
m.name:#dom-permissiondescriptor-name
m.~name0:#dom-permissionstatus-name
m.onchange:#dom-permissionstatus-onchange
m.query:#dom-permissions-query
m.state:#dom-permissionstatus-state

m.permissions:#dom-navigator-permissions
m.~permissions0:#dom-workernavigator-permissions

sl.query:#dfn-query
c.deviceId:~MEDIACAPTURE#dom-mediadeviceinfo-deviceid

a.allow:~HEembed#attr-iframe-allow

	●用語
~risk下:w3c-common-ja.html#at-risk
	~risk下:#dfn-at-risk

許可:#dfn-permission
名前:#dfn-name
側面:#dfn-aspects
状態:#dfn-states
~prompt:#dfn-prompt
是認-:#dfn-granted
否認-:#dfn-denied
許可を表出する:#dfn-express-permission

許可~記述子~型:#dfn-permission-descriptor-type
許可~query~algo:#dfn-permission-query-algorithm
許可~結果型:#dfn-permission-result-type
許可~revocation~algo:#dfn-permission-revocation-algorithm
許可~状態~拘束:#dfn-permission-state-constraints
許可~状態:#dfn-permission-state
許可~存続期間:#dfn-lifetime
存続期間:#dfn-lifetime
現在の許可~状態を取得する:#dfn-getting-the-current-permission-state
~extra許可~data拘束:#dfn-extra-permission-data-constraints
~extra許可~data型:#dfn-extra-permission-data-type
~extra許可~data:#dfn-extra-permission-data
強力な特能:#dfn-powerful-feature
既定の強力な特能:#dfn-default-powerful-feature
識別される特能:#_powerful-feature-by-name
選ぶよう利用者に~promptする:#dfn-prompt-the-user-to-choose
利用する許可を要請する:#dfn-request-permission-to-use
暗黙的な兆候:#dfn-implicit-signals

既定の許可を~queryする~algo:#dfn-default-permission-query-algorithm
~PermissionStatusを作成する:#dfn-create-a-permissionstatus
利用者の意図についての新たな情報:#dfn-new-information-about-the-user-s-intent
より強い:#dfn-stronger-than
利用者により許可が~revokeされたとき反応する:#dfn-react-to-the-user-revoking-permission
~PermissionStatus更新~手続き:#dfn-permissionstatus-update-steps

許可~task源:#dfn-permissions-task-source
許可を~queryする:#dfn-query-a-permission

	●用語（外部

~UA:~INFRA#user-agent

現在の~realm:~TC39#current-realm

辞書:~WEBIDL#dfn-dictionary
diC.継承-:~WEBIDL#dfn-inherit-dictionary
~IDL値に変換-:~WEBIDLjs#dfn-convert-ecmascript-to-idl-value
新たな~promise:~WEBIDLjs#a-new-promise
却下される~promise:~WEBIDLjs#a-promise-rejected-with
解決する:~WEBIDLjs#resolve

~eventを発火する:~DOM4#concept-event-fire

許可~施策:~PERMISSIONS-POLICY#permissions-policy
	doc.許可~施策:~HTMLdom#concept-document-permissions-policy

利用は許容されて:~HEembed#allowed-to-use
並列的:~HTMLINFRA#in-parallel

同一-生成元:~ORIGIN#same-origin
結付けられている文書:~WINDOW#concept-document-window
閲覧文脈:~BROWSERS#browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context

~realm:~WAPI#concept-global-object-realm
設定群~obj:~WAPI#concept-realm-settings-object
現在の設定群~obj:~WAPI#current-settings-object
環境~設定群~obj:~WAPI#environment-settings-object
いくつかアリな設定群~obj:~WAPI#realms-settings-objects-global-objects
大域~obj:~WAPI#global-object
関連な大域~obj:~WAPI#concept-relevant-global
enV.大域~obj:~WAPI#concept-settings-object-global
enV.担当の~event~loop:~WAPI#responsible-event-loop
enV.~secureな文脈:~WAPI#secure-context
	enV.~secureでない文脈:~WAPI#non-secure-context
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler:~WAPI#event-handlers
~task源:~WAPI#task-source
~taskを~queueする:~WAPI#queue-a-task
大域~taskを~queueする:~WAPI#queue-a-global-task

施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature

~installされ:~APPMANIFEST#dfn-installed-web-application

cite.Geolocation API:~TR/geolocation/
cite.Notifications API Standard:~NOTIFICATIONS
	https://notifications.spec.whatwg.org/
cite.Push API:~TR/push-api/
cite.Web MIDI API:~TR/webmidi/
cite.Screen Wake Lock API:~TR/screen-wake-lock/
cite.Background Fetch:https://wicg.github.io/background-fetch/
cite.Web Background Synchronization:https://wicg.github.io/background-sync/spec/
cite.Web Bluetooth:https://webbluetoothcg.github.io/web-bluetooth/
cite.Media Capture and Streams:~TR/mediacapture-streams/
cite.Storage Standard:~STORAGE
	https://storage.spec.whatwg.org/
cite.Ambient Light Sensor:~AMBIENT-LIGHT
	~TR/ambient-light/
cite.Accelerometer:~ACCELEROMETER
	~TR/accelerometer/
cite.Gyroscope:~GYROSCOPE
	~TR/gyroscope/
cite.Magnetometer:~MAGNETOMETER
	~TR/magnetometer/
cite.Screen Capture:~TR/screen-capture/
cite.Web NFC API:https://w3c.github.io/web-nfc/
cite.WebXR Device API:~TR/webxr/
cite.Audio Output Devices API:~TR/audio-output/

cite.Permissions Automation:https://w3c.github.io/permissions-automation/

	:https://www.w3.org/Privacy/IG/

●●words_table1
APPMANIFEST:appmanifest-ja.html
MEDIACAPTURE:https://www.w3.org/TR/mediacapture-streams/
	MEDIACAPTURE:https://w3c.github.io/mediacapture-main/
AMBIENT-LIGHT:ambient-light-ja.html
ACCELEROMETER:accelerometer-ja.html
GYROSCOPE:gyroscope-ja.html
MAGNETOMETER:magnetometer-ja.html
permissions0:permissions
name0:name

●●words_table

	●仕様
下位型:subtype::~
	による:reason
意向:intention:~
推定-:infer:~
曖昧:vague:~
末端利用者:end user:~:::エンドユーザ
枠組み:framework:~
略記:shorthand:~
選択的:selective:~
選択肢:option:~
	~~選択肢:choice
見越して:anticipateして:~
集成-:aggregate:~
探求-:explore:~
学習-:learn:~
解決策:solution:~
申請-:file:~
仲介-:mediate:~
重合する:overlapする:重なり合う
同意:consent:~
維持-:retain:~
処する:dealする:~
別個:distinct:~
専ら:exclusiveに:~
協調-:coordinate:~
突止める:ascertainする:突き止める
思考:thought:~
試験結果:experimentation:~
尊重-:respect:~
不確か:unsure:~
発展-:evolve:~
team::::チーム
適当:right:~
balance::::バランス

	用例:Examples of usage
	とされる:marked as
	~web~site:website
	視点で:notion
	視点による:impression
	責を負う:responsible
	裁定を下した:made 〜 decision
	至る:lead
	満た:satisfy
	〜も満たす:taking into account
	-:aware
	収まらな:fit
	~~伝える:contact
	処する:deal with
	どちらにせよ:be it 〜 or
	だとしても:nevertheless
	いつでも:at any time
	ようになる:ever become
	組み込む:subsume
	注意点:note
	最後に:finally
	目立たない:discreet
	指す:refer
	類別される:class
	選ぶ:choose
	選んだもの:choice
	~~策定者たち:us
	ある仮の:hypothetical
	関心事:interesting
	~Web~IDL:WebIDL
	たくさんの:a lot of
	何年か経つうち:over a period of years
	覚える:remember
	容易さ:ease of
	できるようにする:making
	適する:suited
	仰がれ:contact
	特に〜重視-:with strong emphasis

	●IDL／event／処理
列挙型:enum::~
列挙値:enum value:enum 値:~
main::::メイン

	~call元:caller
	~call元:calling
	invocation
	設定群:target

	%根~記述子:rootDesc
	-:previousResult
	%有型~記述子:typedDescriptor
	%許可~記述子:permissionDesc
	記述子 %A:descriptorA
	記述子 %B:descriptorB

	●許可／保安
revokeされ::取り消され
revokeする::取り消す
revocation::取り消し
	~revokeされたとき:revoking
PermissionStatus:
結果型:result type::~
指紋:fingerprint::~
敵対者:adversary:~
兆候:signals::~
頻繁:frequent:~
近過去:recent:~
	frequency and recency
extra::追加の

新聞社:newspaper:~
正当:legitimate:~
広告主:advertiser:~
広告:advertisement:~
広告-:advertise:~
通告:notice:~
濫用:abuse:~
個人:person:~
	当人:the person
	者:people
黙して:silentに:~
component::::コンポーネント

	recency
	可能性が高い:more likely to
	勧める:advised
	~~注意深くあたる:exercise caution
	高める:increase
	信用-度が様々な:more- and less- trusted
	信用-度がより低い:less trusted
	^e:iframe

	●許可対象

Permissions:
bluetooth:
MIDI:
wake::::ウェイク
NFC:
地理所在:geolocation:~
環境光:ambient light:~
camera::::カメラ
microphone::::マイク
地域news:local news:::地域ニュース:ローカルニュース

	●存続期間
存続期間:lifetime::~
	期間:duration
失効-:expire:~
不定:indefinite:~
	不定な間:indefinitely
	日:day
	され次第:as soon as
	戻す:back

	●UI
prompt:
退ける:dismissする:~
聴覚的:auditory:~
復帰-:revert:~
閉じら:closeさ:~
UX:

	●未分類
自動化-:automate::~
半順序:partial order:~

food:
taste:
smell:
sense:
検出器:detector::~
量:amount:~

	モノ:thing
	続ける:keep
	在る:exist
	-:contain
	-:made
	-:client
	-:parameter
	読取n法:reading
	渡-:pass

	GitHub:
	geolocation
	midi
	-:moment

	●指示語
	回数:number of
	一つ:one
	いくつも:many
	当の:relevant
	この時点で:now has
	後続の:subsequent
	数多の:lots of
	前もって:beforehand
	他の部分:any other parts
	最後に:latest

●●ref_data
APPMANIFEST=副     ~/appmanifest-ja.html

●●ref_normative

[dom]
    ＜DOM Standard＞. Anne van Kesteren.  WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞.  Ecma International. URL: https://tc39.es/ecma262/multipage/
[HTML]
    ＜HTML Standard＞. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters.  WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[infra]
    ＜Infra Standard＞. Anne van Kesteren; Domenic Denicola.  WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/
[mediacapture-streams]
    ＜Media Capture and Streams＞. Cullen Jennings; Bernard Aboba; Jan-Ivar Bruaroey; Henrik Boström; youenn fablet.  W3C. 3 December 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/mediacapture-streams/
[Permissions-Policy]
    ＜Permissions Policy＞. Ian Clelland.  W3C. 16 July 2020. W3C Working Draft. URL: https://www.w3.org/TR/permissions-policy-1/
[RFC2119]
    ＜Key words for use in RFCs to Indicate Requirement Levels＞. S. Bradner.  IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119
[RFC8174]
    ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞. B. Leiba.  IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174
[screen-wake-lock]
    ＜Screen Wake Lock API＞. Kenneth Christiansen; Marcos Caceres; Raphael Kubo da Costa.  W3C. 7 December 2021. W3C Working Draft. URL: https://www.w3.org/TR/screen-wake-lock/
[web-nfc]
    ＜Web NFC API＞.  W3C. W3C Editor's Draft. URL: https://w3c.github.io/web-nfc/
[WEBIDL]
    ＜Web IDL Standard＞. Edgar Chen; Timothy Gu.  WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[accelerometer]
    ＜Accelerometer＞. Anssi Kostiainen.  W3C. 4 December 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/accelerometer/
[ambient-light]
    ＜Ambient Light Sensor＞. Anssi Kostiainen; Rijubrata Bhaumik.  W3C. 3 December 2021. W3C Working Draft. URL: https://www.w3.org/TR/ambient-light/
[appmanifest]
    ＜Web Application Manifest＞. Marcos Caceres; Kenneth Christiansen; Matt Giuca; Aaron Gustafson; Daniel Murphy; Anssi Kostiainen.  W3C. 10 November 2021. W3C Working Draft. URL: https://www.w3.org/TR/appmanifest/
[audio-output]
    ＜Audio Output Devices API＞. Justin Uberti; Guido Urdaneta; youenn fablet.  W3C. 15 November 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/audio-output/
[background-fetch]
    ＜Background Fetch＞.  WICG. cg-draft. URL: https://wicg.github.io/background-fetch/
[Gamepad]
    ＜Gamepad＞. Steve Agoston; James Hollyer; Matthew Reynolds; Brandon Jones; Scott Graham; Theodore Mielczarek.  W3C. 5 August 2021. W3C Working Draft. URL: https://www.w3.org/TR/gamepad/
[Geolocation]
    ＜Geolocation API＞. Marcos Caceres.  W3C. 24 November 2021. W3C Working Draft. URL: https://www.w3.org/TR/geolocation/
[GETUSERMEDIA]
    ＜Media Capture and Streams＞. Cullen Jennings; Bernard Aboba; Jan-Ivar Bruaroey; Henrik Boström; youenn fablet.  W3C. 3 December 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/mediacapture-streams/
[gyroscope]
    ＜Gyroscope＞. Anssi Kostiainen.  W3C. 4 December 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/gyroscope/
[magnetometer]
    ＜Magnetometer＞. Anssi Kostiainen; Rijubrata Bhaumik.  W3C. 4 December 2021. W3C Working Draft. URL: https://www.w3.org/TR/magnetometer/
[notifications]
    ＜Notifications API Standard＞. Anne van Kesteren.  WHATWG. Living Standard. URL: https://notifications.spec.whatwg.org/
[push-api]
    ＜Push API＞. Peter Beverloo; Martin Thomson.  W3C. 3 November 2021. W3C Working Draft. URL: https://www.w3.org/TR/push-api/
[screen-capture]
    ＜Screen Capture＞. Martin Thomson; Keith Griffin; Suhas Nandakumar; Henrik Boström; Jan-Ivar Bruaroey; Elad Alon.  W3C. 2 December 2021. W3C Working Draft. URL: https://www.w3.org/TR/screen-capture/
[storage]
    ＜Storage Standard＞. Anne van Kesteren.  WHATWG. Living Standard. URL: https://storage.spec.whatwg.org/
[web-background-sync]
    ＜Web Background Synchronization＞.  WICG. cg-draft. URL: https://wicg.github.io/background-sync/spec/
[web-bluetooth]
    ＜Web Bluetooth＞. Jeffrey Yasskin.  W3C Web Bluetooth Community Group. Draft Community Group Report. URL: https://webbluetoothcg.github.io/web-bluetooth/
[webmidi]
    ＜Web MIDI API＞. Chris Wilson; Jussi Kalliokoski.  W3C. 17 March 2015. W3C Working Draft. URL: https://www.w3.org/TR/webmidi/
[webxr]
    ＜WebXR Device API＞. Brandon Jones; Manish Goregaokar; Rik Cabanier; Nell Waliczek.  W3C. 26 October 2021. W3C Working Draft. URL: https://www.w3.org/TR/webxr/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Permissions</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/permissions/
編集者草案
	https://w3c.github.io/permissions/
発行履歴
	https://www.w3.org/standards/history/permissions
commit 履歴
	https://github.com/w3c/permissions/commits/main
編集
	<a href="https://www.w3.org/">Marcos Cáceres</a> (W3C)
	<a href="https://miketaylr.com/posts/">Mike Taylor</a> (Google LLC)
前任編集者
	Mounir Lamouri (Google LLC)
	Jeffrey Yasskin (Google LLC)

フィードバック
	<a href="https://github.com/w3c/permissions/">GitHub w3c/permissions</a> (<a href="https://github.com/w3c/permissions/pulls/">pull requests</a>, <a href="https://github.com/w3c/permissions/issues/new/choose">new issue</a>, <a href="https://github.com/w3c/permissions/issues/">open issues</a>)

発行者
	<a href="https://www.w3.org/groups/wg/webappsec">Web Application Security Working Group</a>

</script>

<body>

<header>
	<hgroup>
<h1>許可 — Permissions</h1>
<h2 title="Interacting with Permissions for Powerful Features">強力な特能用の許可とのやりとり</h2>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
~ABSTRACT

<p>
この仕様 `Permissions API^cite （許可~API）は、
他の仕様が~browser許可
— ~web~platformの強力な特能への~accessを［
許容する／否認する
］許可 —
とヤリトリするために利用できる共通な基盤を定義する。
この仕様はまた，開発者~用には、強力な特能に対する許可の［
状態を~queryする／
状態が変化したとき通知されるようにする
］ための~APIを定義する。
◎
The Permissions API specification defines common infrastructure that other specifications can use to interact with browser permissions that allow or deny access to powerful features on the web platform. For developers, the specification defines an API to query the permission state of a powerful feature, or be notified if a permission for a powerful feature changes state.
</p>

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下，この節の他の内容は、<a href="w3c-common-ja.html#status">W3C 日本語訳~共通~page</a>／冒頭の仕様~metadataに移譲。】
</p>

<p>
この仕様における一部の特能は、
それを~supportする~UAが一つしかないため，`~risk下$にあるとされる。
◎
Some features in this specification are supported by only one user agent, and as such, are marked as at risk.
</p>

	</section>

<main id="MAIN0">

	<section id="examples">
<h2 title="Examples of usage">1. 用例</h2>

~INFORMATIVE

<div class="example" id="example-using-state-attribute">
<p>
次の例は、 `Permissions API^cite を利用して，［
`Geolocation API^cite を利用して地域newsを示すべき
］か, または［
当の特能を追加する~buttonを提供する
］かどうかを裁定する。
◎
This example uses the Permissions API to decide whether local news should be shown using the Geolocation API or with a button offering to add the feature.
◎
Example 1: Using .state attribute
</p>

<pre class="lang-js">
const { %state } = await navigator.permissions.query({
  name: "geolocation"
});
switch (%state) {
  case `granted$pS:
    showLocalNewsWithGeolocation();
    break;
  case `prompt$pS:
    showButtonToEnableLocalNews();
    break;
  case `denied$pS:
    showNationalNews();
    break;
}
</pre>
</div>

<div class="example" id="example-checking-the-state-of-multiple-permissions">
<p>
次の例は、~pageは［
`geolocation$pN, `notifications$pN
］両~許可を有するかどうかを検査する：
◎
This example is checking whether the page has the "geolocation" and the "notifications" permissions:
◎
Example 2: Checking the state of multiple permissions
</p>

<pre class="lang-js">
const %queryPromises = ["geolocation", "notifications"].map(%name =&gt; {
  return navigator.permissions.query({ %name });
});
for await (const %status of %queryPromises) {
  console.log(``^${%status.name}: ${%status.state}``^);
}
</pre>

</div>

<div class="example" id="example-3">

<p>
次の例は、可用な各~cameraの許可~状態を検査する。
◎
This example is checking the permission state of the available cameras.
◎
Example 3
</p>

<pre class="lang-js">
const %devices = await navigator.mediaDevices.enumerateDevices();

/* <span class="comment">
動画~入力のみに~filterしてから，~query~objに対応付ける
◎
filter on video inputs, and map to query object
</span>
const %queries = %devices
  .filter(({ %kind }) =&gt; %kind === "videoinput")
  .map(({ %deviceId }) =&gt; ({ name: "camera", %deviceId }));

const %promises = %queries.map((%queryObj) =&gt;
  navigator.permissions.query(%queryObj)
);

try {
  const %results = await Promise.all(%promises);
  /* <span class="comment">
状態や各~cameraの~logをとる
◎
log the state of each camera
</span>
  %results.forEach(({ %state }, %i) =&gt; console.log("Camera", %i, %state));
} catch (%error) {
  console.error(%error);
}
</pre>
</div>

	</section>
	<section id="model">
<h2 title="Model">2. ~model</h2>
<p>
この節は、［
~Web~platformの`強力な特能$を利用する`許可$
］用の~modelを指定する。
◎
This section specifies a model for permissions to use powerful features on the Web platform.
</p>

		<section id="permissions">
<h3 title="Permissions">2.1. 許可</h3>

<p>
`許可@
は、［
利用者による，`強力な特能$への~accessを~web~appに許容する裁定
］を表現する。
◎
A permission represents a user's decision to allow a web application to access a powerful feature.
</p>

<div class="note" id="issue-container-generatedID">
<p>注記（制限）：
現在の~Web~APIには、いくつかの異なる［
許可を処する仕方
］がある。
例えば `notifications$r ~APIは、
開発者が明示的に許可を要請して，許可~状態sを検査できるようにする。
~APIを利用しようと試行したときに限り，許可~状態sを~web~pageに公開するものもある。
例えば `Geolocation$r は、開発者が前もって検査するのを許容することなく，許可が是認されていなければ失敗する。
◎
Note: Limitations
◎
Current Web APIs have different ways to deal with permissions. For example, the [notifications] API allows developers to request a permission and check the permission status explicitly. Others expose the status to web pages when they try to use the API, like the [Geolocation] which fails if the permission was not granted without allowing the developer to check beforehand.
</p>

<p>
この文書に述べる解決策は，拡張できるように意味されているが、
~web~platformにて可用な［
現在の／将来の
］許可すべてに適用-可能になるとは期待されてはいない。
許可~modelを孕む仕様を策定している~WGは、
その~modelが この文書に述べる~modelに収まらないときには，
<a href="https://github.com/w3c/permissions/issues">課題を申請して</a>
そのことを編集者に~~伝えるべきである。
◎
The solution described in this document is meant to be extensible, but isn't expected to be applicable to all the current and future permissions available in the web platform. Working Groups that are creating specifications whose permission model doesn't fit in the model described in this document should contact the editors by filing an issue.
</p>
</div>

<p>
`許可$は、概念的には，次に挙げるいずれかの
`状態@
をとり得る：
◎
Conceptually, a permission can be in one of the following states:
</p>
<dl>
	<dt>
`~prompt@
◎
Prompt:
</dt>
	<dd>
この状態は、［
利用者はまだ裁定を下していない
（すなわち，`否認-$されたのと同じ）
］ことを表現する
— `~UA$は、［
~call元が当の特能に~accessしようと試行した場合には，利用者に許可を依頼する
］ことになる。
対して，利用者は、そのような要請を［
是認することも,
否認することも,
無視することも,
退けることも
］ある。
◎
The prompt state represents that the user has not made a decision (i.e., it's the same a denied), and the user agent will be asking the user for permission if the caller tries to access the feature. The user might then grant, deny, ignore, or dismiss the request.
</dd>

	<dt>
`是認-@
された
（ `granted$pS ）
◎
Granted:
</dt>
	<dd>
この状態は、［
`~UA$が許可を利用者に依頼することなく，~call元が成功裡に当の特能に~accessできる
］ことを表現する。
◎
The granted state represents that the caller will be able to successfully access the feature without having the user agent asking the user's permission.
</dd>

	<dt>
`否認-@
された（ `denied$pS ）
◎
Denied:
</dt>
	<dd>
この状態は、［
~call元は，当の特能に~accessできない
］ことを表現する。
◎
The denied state represents that the caller will not be able to access the feature.
</dd>
</dl>

<p>
~UAは、所与の［
~realm／生成元
］に結付けられている`強力な特能$に対し，
その`許可$の`状態$【！`許可~状態$】を［
考査する, 更新する, 設定し直す
］ための手段を利用者~向けに供するベキである。
◎
A user agent SHOULD provide a means for the user to review, update, and reset the permission state of powerful features associated with a realm or origin.
</p>

<p>
~UAは、
`利用者の意図についての新たな情報@
を突止めるときは，
利用者の意向についての情報を収集してもヨイ。
この情報は、［
利用者による明示的な動作
］から来ることもあれば，［
当の利用者や他の利用者たちの挙動,
この仕様が見越していない
`暗黙的な兆候@
］を集成して得られることもある。
◎
To ascertain new information about the user's intent, a user agent MAY collect information about a user's intentions. This information can come from explicit user action, aggregate behavior of both the relevant user and other users, or implicit signals this specification hasn't anticipated.
</p>

<p class="note">注記：
`暗黙的な兆候$には，例えば、
どの~web~appが`~installされ$ていて, どの程度［
頻繁／近過去
］に訪問しているか，などが挙げられる
— 利用者が自身が~installした~web~appを より［
近過去／頻繁
］に利用しているほど，それを信用している可能性が高い。
実装には、暗黙的な兆候に依拠するときには，~~注意深くあたることを勧める。
◎
Note: Implicit signals
The implicit signals could be, for example, the install status of a web application or frequency and recency of visits. A user that has installed a web application and used it frequently and recently is more likely to trust it. Implementations are advised to exercise caution when relying on implicit signals.
</p>

		</section>
		<section id="powerful-features">
<h3 title="Powerful features">2.2. 強力な特能</h3>

<p>
`強力な特能@
は、［
それを利用できるようになる前に，利用者が`許可を表出する$必要がある
］ような，~web~platform特能である（通例的に~APIである）。
当の特能への~accessは、
次のいずれかにより決定される
⇒＃
利用者が~UIを介して許可を`是認-$した`環境~設定群~obj$により／
許可が`是認-$されたのと等価な何らかの判定基準を満たすことにより。
◎
A powerful feature is a web platform feature (usually an API) for which a user gives express permission before the feature can be used. Access to the feature is determined by the environment settings object by the user having granted permission via UI, or by satisfying some criteria that is equivalent to a permission grant.
</p>

<p>
`許可を表出する@
とは、それを通して［
~web~appに当の特能を利用する`許可$
］を`是認-$する，利用者による動作-を指す
（例：［
~UI／~host機器の~platform特能
］を介して）。
◎
Express permission refers to an act by the user, e.g. via user interface or host device platform features, through which the user grants permission the use of the feature by the web application.
</p>

<p>
`強力な特能$は、
文字列（例： `geolocation^l ）として与えられる
`名前@
により識別される。
所与の`名前$で
`識別される特能@
とは、そのように識別される`強力な特能$を指す
【この用語は、明確化するための，この訳による追加】
。
◎
A powerful feature is identified by its name, which is a string literal (e.g., "geolocation").
</p>

<p>
~UAは、［
利用者が、`強力な特能$のうち，どれに利用する`許可$を与えているか
］を，各`~realm$ごとに追跡する責を負う。
他の仕様は、この節に定義する各種 演算を利用して，どの許可が~UA視点で［
是認-／否認-
］されているかを検索取得でき，利用者に更なる許可を［
是認するか否認するか
］依頼することができる。
◎
The user agent is responsible for tracking what powerful features each realm has the user's permission to use. Other specifications can use the operations defined in this section to retrieve the UA's notion of what permissions are granted or denied, and to ask the user to grant or deny more permissions.
</p>

			<section id="specifying-a-powerful-feature">
<h4 title="Specifying a powerful feature">2.2.1. 強力な特能の指定-法</h4>

<p class="note">注記：
新たな`強力な特能$を追加したいと求める仕様には、
GitHub を介して，この仕様に対し~~策定者たちと協調することが奨励される。
◎
Specifications wanting to add a new powerful feature are encouraged to coordinate with us on this specification via GitHub.
</p>

<p>
各 `強力な特能$ %特能 は、
次に挙げる，許可に関係する各種［
~algo, 型
］を備える。
これらの各［
~algo／型
］のいずれかについて，既定のそれが特定0の`強力な特能$用には相応でないときは、
当の仕様は，それを上書きしてもヨイ。
◎
Each powerful feature has the following permission-related algorithms and types. When the defaults are not suitable for a particular powerful feature, a specification MAY override below algorithms and types below. 
</p>
<dl>
	<dt>
`許可~記述子~型@
◎
A permission descriptor type:
</dt>
	<dd>
`PermissionDescriptor$I, または その下位型。
◎
PermissionDescriptor or one of its subtypes.＼
</dd>
	<dd>
未指定な場合の既定は、 `PermissionDescriptor$I とする。
◎
If unspecified, this defaults to PermissionDescriptor.
</dd>
	<dd>
<p>
%特能 は、記述子の各~instance間において
`より強い@
と称される
<a href="https://en.wikipedia.org/wiki/Partially_ordered_set">半順序</a>
を定義できる。
［
記述子 %A は記述子 %B `より強い$
］ならば、次が満たされなければナラナイ：
</p>
		<ul>
			<li>
［
`許可~状態$( %A ) ~EQ `granted$pS
］ならば［
`許可~状態$( %B ) ~EQ  `granted$pS
］
</li>
			<li>
［
`許可~状態$( %B ) ~EQ `denied$pS
］ならば［
`許可~状態$( %A ) ~EQ  `denied$pS
］
</li>
		</ul>
◎
The feature can define a partial order on descriptor instances. If descriptorA is stronger than descriptorB, then if descriptorA's permission state is "granted", descriptorB's permission state must also be "granted", and if descriptorB's permission state is "denied", descriptorA's permission state must also be "denied".
</dd>
	<dd class="example">
<samp>{name: `midi$pN, sysex: true}</samp>
— “sysex ありの~MIDI” —
は
<samp>{name: `midi$pN, sysex: false}</samp>
— “sysex なしの~MIDI” —
`より強い$ので、利用者が
“sysex なしの~MIDI” への~accessを否認した場合、
~UAは
“sysex ありの~MIDI” への~accessも否認しなければならない。
同様に，利用者が
“sysex ありの~MIDI” への~accessを是認した場合、
~UAは
“sysex なしの~MIDI” への~accessも是認しなければならない。
◎
{name: "midi", sysex: true} ("midi-with-sysex") is stronger than {name: "midi", sysex: false} ("midi-without-sysex"), so if the user denies access to midi-without-sysex, the UA must also deny access to midi-with-sysex, and similarly if the user grants access to midi-with-sysex, the UA must also grant access to midi-without-sysex.
</dd>

	<dt>
`許可~状態~拘束@
◎
Optional permission state constraints:
</dt>
	<dd>
~UAが`許可~状態$( 記述子 ) として返せる値を拘束する。
◎
Constraints on the values that the UA can return as a descriptor's permission state.＼
</dd>
	<dd>
既定では（省略時）、利用者の意図を超える拘束はないとする。
◎
Defaults to no constraints beyond the user's intent.
</dd>

	<dt>
`~extra許可~data型@
◎
An optional extra permission data type:
</dt>
	<dd>
一部の`強力な特能$には、 `PermissionState$I 以外の情報も結付けられる。
例えば， `getUserMedia()$m は、［
利用者が、`どの~camera^emに~accessする許可を，`現在の~realm$に是認しているか
］を決定する必要がある。
そのような各~特能は、`~extra許可~data型$を定義する。
◎
Some powerful features have more information associated with them than just a PermissionState. For example, getUserMedia() needs to determine which cameras the user has granted the current realm permission to access. Each of these features defines an extra permission data type.＼
</dd>
	<dd class="algo">
<p>
ある `PermissionName$I 列挙~値 %名前 で`識別される特能$ %特能 用の
`~extra許可~data@
は、所与の`環境~設定群~obj$ %設定群 （省略時は ε ）に対し，次を走らせた結果で与えられる：
◎
If a PermissionName name names one of these features, then name's extra permission data for an optional environment settings object settings is the result of the following algorithm:
</p>
		<ol>
			<li>
~IF［
%設定群 ~EQ ε
］
⇒
%設定群 ~SET `現在の設定群~obj$
◎
If settings wasn't passed, set it to the current settings object.
</li>
			<li>
~IF［
この~algoは、以前に，同じ
( %名前, %設定群 )
で呼出されている
］~AND［
~UAは、以前の時点から［
`利用者の意図についての新たな情報$
］をまだ受取ってない
］
⇒
~RET 以前の時点における結果
◎
If there was a previous invocation of this algorithm with the same name and settings, returning previousResult, and the UA has not received new information about the user's intent since that invocation, return previousResult.
</li>
			<li>
~RET 次を満たす［
%特能 の`~extra許可~data型$の~instance
］
⇒
［
~UA視点による利用者の意図に合致する
］~AND［
%特能 の`~extra許可~data拘束$を満たす
］
◎
Return the instance of name's extra permission data type that matches the UA's impression of the user's intent, taking into account any extra permission data constraints for name.
</li>
		</ol>
	</dd>
	<dd>
指定された場合、 %特能 用の`~extra許可~data$を利用-可能になる。
◎
If specified, the extra permission data algorithm is usable for this feature.
</dd>
	<dd class="trans-note">【
すなわち，既定では（省略時）、`~extra許可~data$はない。
】【
この “型” に何らかの~IDLが含意されるかどうかは、定かでない
（この用語を利用している他の仕様を見なければ判明しない）。
】</dd>

	<dt>
`~extra許可~data拘束@
◎
Optional extra permission data constraints:
</dt>
	<dd>
~UAが %特能 用の`~extra許可~data$として返せる値を拘束する。
◎
Constraints on the values that the UA can return as a PermissionName's extra permission data.＼
</dd>
	<dd>
既定では（省略時）、利用者の意図を超える拘束はないとする。
◎
Defaults to no constraints beyond the user's intent.
</dd>

	<dt>
`許可~結果型@
◎
A permission result type:
</dt>
	<dd>
`PermissionStatus$I
または，その下位型。
◎
PermissionStatus or one of its subtypes.＼
</dd>
	<dd>
未指定な場合の既定は、 `PermissionStatus$I とする。
◎
If unspecified, this defaults to PermissionStatus.
</dd>

	<dt>
`許可~query~algo@
◎
A permission query algorithm:
</dt>
	<dd>
2 つの引数
⇒＃
%特能 の`許可~記述子~型$の~instance,
%特能 の`許可~結果型$の 新たな または既存の~instance
◎終
による~queryの結果で，後者の引数を更新する。
［
`Permissions$I の `query()$m ~method ／
`~PermissionStatus更新~手続き$
］で利用される。
◎
Takes an instance of the permission descriptor type and a new or existing instance of the permission result type, and updates the permission result type instance with the query result. Used by Permissions' query(permissionDesc) method and the PermissionStatus update steps.＼
</dd>
	<dd>
未指定な場合の既定は、`既定の許可を~queryする~algo$とする。
◎
If unspecified, this defaults to the default permission query algorithm.
</dd>
	<dd class="algo">
<p>
`既定の許可を~queryする~algo@
は、所与の
( `PermissionDescriptor$I %許可~記述子, `PermissionStatus$I %状態s )
に対し，次の手続きを走らす：
◎
The default permission query algorithm, given a PermissionDescriptor permissionDesc and a PermissionStatus status, runs the following steps:
</p>
		<ol>
			<li>
%状態s の `state$m ~SET `許可~状態$( %許可~記述子 )
◎
Set status.state to permissionDesc's permission state.
</li>
		</ol>
	</dd>

	<dt>
`許可~revocation~algo@
◎
A permission revocation algorithm:
</dt>
	<dd>
引数はとらない。
それは，`利用者により許可が~revokeされたとき反応する$が、
その前に，実装における他の部分
— ［
`許可~状態$ ／ `~extra許可~data$
］の結果における変化と同期cさせ続ける必要があるもの —
があれば それを更新する。
◎
Takes no arguments. Updates any other parts of the implementation that need to be kept in sync with changes in the results of permission states or extra permission data, and then react to the user revoking permission.
</dd>
	<dd>
未指定な場合の既定は、`利用者により許可が~revokeされたとき反応する$。
◎
If unspecified, this defaults to running react to the user revoking permission.
</dd>

	<dt>
`許可~存続期間@
◎
A permission lifetime:
</dt>
	<dd>
どの`許可$にも，`存続期間$がある
— それは、
特定0の許可が［
既定の`状態$【！`許可~状態$】へ復帰する前に，`是認-$された状態であり続ける期間
］である。
`存続期間$は、［
特定0の~Realmが破壊されるまで／
特定0の`~top-level閲覧文脈$が破壊されるまで／
ある量の時間／
無限
］いずれにもなり得る。
存続期間は、
末端利用者が
— 通例的に，何らかの許可［
~UI／施策
］を介して —
`強力な特能$を利用する`許可を表出する$ときに，
当の利用者と`~UA$の間で折衝される。
◎
Every permission has a lifetime, which is the duration for which a particular permission remains granted before it reverts back to its default permission state. A lifetime could be until a particular Realm is destroyed, until a particular top-level browsing context is destroyed, an amount of time, or infinite. The lifetime is negotiated between the end-user and the user agent when the user gives express permission to use a feature - usually via some permission UI or policy.
</dd>
	<dd>
`強力な特能$を定義する仕様は、
当の特能に対する`許可$の`存続期間$として，
最良に適するものを示唆するベキである。
下に、許可~存続期間の決定-法に関する指導を
— 特に，利用者の~privacyを重視して —
いくつか注記する。
`存続期間$が指定されない場合、
~UAが，それを供することになる。
◎
Specifications that define one or more powerful features SHOULD suggest a permission lifetime that is best suited for the particular feature. Some guidance on determining the lifetime of a permission is noted below, with a strong emphasis on user privacy. If no lifetime is specified, the user agent provides one.
</dd>
	<dd class="algo">
<p>
所与の`強力な特能$に対する［
ある生成元~用の許可
］の`存続期間$が失効したときは：
◎
When the permission lifetime expires for an origin:
</p>
		<ol>
			<li>
当の許可を，当の特能の既定の許可`状態$【！`許可~状態$】（例：`~prompt$）に設定して戻す
◎
Set the permission back to its default permission state (e.g. setting it back to "prompt").
</li>
			<li>
当の生成元に属する
~EACH( `閲覧文脈$ %閲覧文脈 )
に対し
⇒
`大域~taskを~queueする$( `許可~task源$, %閲覧文脈 の`大域~obj$, 当の特能の`許可~revocation~algo$ )
◎
For each browsing context associated with the origin (if any), queue a global task on the permissions task source with the browsing context's global object to run the permission revocation algorithm.
</li>
		</ol>
	</dd>
	<dd class="note">
<p>
注記：
許可の存続期間の決定-法
— `存続期間$は、当の`強力な特能$や~UAに応じて様々になる：
◎
Note: Determining the lifetime of a permission
</p>
<ul>
	<li>
`Media Capture and Streams$cite など
（それは、利用者の［
~camera, ~microphone
］への~accessを~web~appに供し得る），
特に~privacyに敏感な特能に対しては、
一部の~UAは，
~browser~UItabが閉じられるか~navigateされ次第，
許可に対する`是認-$を失効させる。
◎
For particularly privacy-sensitive features, such as Media Capture and Streams, which can provide a web application access to a user's camera and microphone, some user agents expire a permission grant as soon as a browser tab is closed or navigated.＼
</li>
	<li>
`Geolocation API$cite の様な他の特能に対しては、
~UAは，当の許可を［
当の~session ／ 1 日
］に限り是認する~~選択肢を提供することが知られている。
◎
For other features, like the Geolocation API, user agents are known to offer a choice of only granting the permission for the session, or for one day.＼
</li>
	<li>
［
`Notifications API Standard$cite,
`Push API$cite
］の様な他のものに対しては、
~UAは，利用者の裁定を［
不定な間／
利用者が当の許可を手動で~revokeするまで
］覚える。
◎
Others, like the Notifications API Standard and Push API APIs, remember a user's decision indefinitely or until the user manually revokes the permission.＼
</li>
</ul>

<p>
許可の`存続期間$は、~UAごとに有意に変わり得ることに注意。
◎
Note that permission lifetimes can vary significantly between user agents.
</p>

<p>
ある許可の存続期間~用に適当な~balanceを見出すことは、
たくさんの思考と試験結果が要求され，
何年か経つうちに発展することが多い。
実装者には、次が奨励される：
◎
Finding the right balance for the lifetime of a permission requires a lot of thought and experimentation, and often evolves over a period of years. Implementers are encouraged＼
</p>
<ul>
	<li>
~UX~security~teamとともに作業して，［
`強力な特能$への~accessの容易さと
（すなわち，許可~promptの回数を抑制すること）,
利用者の~privacyを尊重すること
］との適当な~balanceを見出すこと。
◎
to work with their UX security teams to find the right balance between ease of access to a powerful feature (i.e., reducing the number of permission prompts), respecting a user's privacy,＼
</li>
	<li>
ある~web~appが 特定0の強力~特能を用立てたときは、
そのことを利用者が自覚できるようにすること
（例：何らかの［
視覚的／聴覚的
］~UI指示子を介して）。
◎
and making users aware when a web application is making use of a particular powerful feature (e.g., via some visual or auditory UI indicator).
</li>
</ul>

<p>
ある`強力な特能$用に示唆する`存続期間$が不確かな場合、
<a href="https://www.w3.org/Privacy/IG/">`Privacy Interest Group^en</a>
から指導を仰がれたし。
◎
If you are unsure about what lifetime to suggest for a powerful feature, please contact the Privacy Interest Group for guidance.
</p>
	</dd>
</dl>

<p>
`既定の強力な特能@
とは、`強力な特能$のうち，上の各種［
型／~algo
］すべてが既定のそれらにされたものをいう。
◎
A default powerful feature is a powerful feature with all of the above types and algorithms defaulted.
</p>

			</section>
			<section id="aspects">
<h4 title="Aspects">2.2.2. 側面</h4>

<p>
各 `強力な特能$は、
0 個以上の追加的な
`側面@
— ~web~siteが~accessするための許可を要請できる側面 —
を定義できる。
◎
Each powerful feature can define zero or more additional aspects that websites can request permission to access.
</p>

<p>
`側面$を述べるためには，当の仕様は、
当の`強力な特能$の`許可~記述子~型$として，
`PermissionDescriptor$I を`継承-$diCする~Web~IDL`辞書$を定義しなければナラナイ。
◎
To describe an aspect, a specification MUST define a WebIDL dictionary that inherits from PermissionDescriptor, and have that interface be its permission descriptor type.
</p>

<div class="example" id="example-defining-your-own-permission-descriptor-type">
<p>
自前の`許可~記述子~型$を定義する例。
ある仮の`強力な特能$ “~food検出器~API” が，
2 つの`側面$
— ［
~taste, ~smell
］を~senseすることを許容する側面 —
を伴うとする
【すなわち、この~APIは，名前 `sense^l で`識別される特能$であるとする】。
当の仕様は、［
`PermissionDescriptor$I を`継承-$diCする新たな辞書
］として，次を定義することになろう：
◎
Example 4: Defining your own permission descriptor type
◎
A hypothetical powerful feature "food detector API" has two aspects that allow sensing taste and smell. So, a specification would define a new WebIDL interface that inherits PermissionDescriptor:
</p>

<pre>
dictionary SensesPermissionDescriptor : PermissionDescriptor {
  boolean canSmell = false;
  boolean canTaste = false;
}
</pre>

<p>
それは、次の仕方で，~APIを介して~queryされることになろう：
◎
Which would then be queried via the API in the following way:
</p>

<pre class="lang-js">
/* <span class="comment">
強力な特能 `sense^l には，モノを~smellすることは許容されるか否か検査する
◎
Check if the "sense" powerful feature is allowed to smell things
</span> */
const %status = await navigator.permissions.query({
  name: "senses",
  canSmell: true,
});
/* <span class="comment">
%status について何か関心事を行う。
◎
Do something interesting with the status.
</span> */
</pre>

<p>
利用者は、強力な特能 `sense^l を `taste^l に限るよう制約し得る
— その事例では、
上の `PermissionStatus$I 【すなわち %status 】の `state$m は `denied$pS になる。
◎
A user can restrict the "sense" powerful feature to only "taste", in which case the PermissionStatus's state above would be "denied" .
</p>
</div>

			</section>
		</section>
		<section id="reading-current-states">
<h3 title="Reading the current permission state">2.3. 現在の許可~状態の読取n法</h3>

<div class="algo">
<p>
`現在の許可~状態を取得する@
ときは、所与の
( `名前$ %名前, `環境~設定群~obj$ %設定群 （省略時は ε ） )
に対し：
◎
To get the current permission state, given a name name and an optional environment settings object settings:
</p>
<ol>
	<li>
%記述子 ~LET 
次のように初期化された新たな `PermissionDescriptor$I
⇒＃
`name$m ~SET %名前
◎
Let descriptor be a newly-created PermissionDescriptor whose name is initialized with name.
</li>
	<li>
~RET `許可~状態$( %記述子, %設定群 )
◎
Return the permission state of descriptor and settings.
</li>
</ol>
</div>

<div class="algo">
<p>
`許可~状態@
は、所与の
( `PermissionDescriptor$I %記述子, `環境~設定群~obj$ %設定群 （省略時は ε ） )
に対し，次を走らせた結果で与えられる
— それは［
`granted$pS,
`prompt$pS,
`denied$pS
］のいずれかを返す：
◎
A descriptor's permission state for an optional environment settings object settings is the result of the following algorithm, which returns one of "granted", "prompt", or "denied":
</p>
<ol>
	<li>
~IF［
%設定群 ~EQ ε
］
⇒
%設定群 ~SET `現在の設定群~obj$
◎
If settings wasn't passed, set it to the current settings object.
</li>
	<li>
%特能 ~LET %記述子[ "`name$m" ] で`識別される特能$
◎
↓</li>
	<li>
~IF［
%設定群 は`~secureな文脈$enVでない
］
⇒
~RET `denied$pS
◎
If settings is a non-secure context, return "denied".
</li>
	<li>
~IF［
%特能 は`施策により制御される特能$である
］~AND［
%設定群 【の`大域~obj$enV】に`結付けられている文書$は在って†、その文書に %特能 の`利用は許容されて$いない
【† 大域~objは~windowでない場合、そのような文書は定義されない】
］
⇒
~RET `denied$pS
◎
If there exists a policy-controlled feature identified by descriptor's name and settings has an associated Document named document, run the following step:
• If document is not allowed to use the feature identified by descriptor's name return "denied".
</li>
	<li>
~IF［
この~algoは、以前に，同じ
( %記述子, %設定群 )
で呼出されている
］~AND［
~UAは、まだ 以前の時点から`利用者の意図についての新たな情報$を受取ってない
］
⇒
~RET 以前の時点における結果
◎
If there was a previous invocation of this algorithm with the same descriptor and settings, returning previousResult, and the UA has not received new information about the user's intent since that invocation, return previousResult.
</li>
	<li>
<p>
~RET 次に挙げる選択肢のうち，~call元の~algoに対し［
利用者の意図を最も正確aに反映しつつ，
%特能 の`許可~状態~拘束$も満たす
］もの：
◎
Return whichever of the following options most accurately reflects the user's intent for the calling algorithm, taking into account any permission state constraints for descriptor's name:
</p>
		<dl class="switch">
			<dt>
利用者に~promptすることなく成功する
◎
succeed without prompting the user
</dt>
			<dd>`granted$pS</dd>

			<dt>
利用者に~promptを示して，成功するかどうか裁定してもらう
◎
show the user a prompt to decide whether to succeed
</dt>
			<dd>`prompt$pS</dd>

			<dt>
利用者に~promptすることなく失敗する
◎
fail without prompting the user
</dt>
			<dd>`denied$pS</dd>
		</dl>
	</li>
</ol>

<p class="issue">
<a href="https://github.com/w3c/permissions/issues/278">課題 #278</a>：
Safari のみが、［
この~algoが、同じ生成元に属する異なる設定群~objに対し，異なる結果を返す
］ような，既知な~UAである。
`いくつかアリな設定群~obj$のうち，どれを利用するか~testするべきである。
◎
Issue 278: Safari returns different results for current permission state
◎
Safari is the only known UA that returns different results from this algorithm for different settings objects with the same origin. We should test which of the several possible settings objects it uses.
</p>

<p>
所与の `PermissionName$I 列挙~値 %名前 に対する`許可~状態$は、次の略記である
⇒
`許可~状態$( `name$m ~memberが %名前 に設定された`PermissionDescriptor$I )
◎
As a shorthand, a PermissionName name's permission state is the permission state of a PermissionDescriptor with its name member set to name.
</p>

</div>

		</section>
		<section id="requesting-more-permission">
<h3 title="Requesting permission to use a powerful feature">2.4. 強力な特能を利用する更なる許可の要請-法</h3>

<p class="note">注記：
仕様の策定者は、この節に与える~algoが 利用者からの入力を待機し得ることに注意されたし
— ~main~threadで走っている~algoからは利用されるべきでない。
◎
Spec authors, please note that algorithms in this section can wait for user input; so they shouldn't be used from other algorithms running on the main thread.
</p>

<div class="algo">
<p>
所与の %記述子 を
`利用する許可を要請する@
ときは、次の手続きを遂行するモノトスル
— この~algoは［
`granted$pS ／ `denied$pS
］を返す：
◎
To request permission to use a descriptor, the UA must perform the following steps. This algorithm returns either "granted" or "denied".
</p>
<ol>
	<li>
%現~状態 ~LET `許可~状態$( %記述子 )
◎
Let current state be the descriptor's permission state.
</li>
	<li>
~IF［
%現~状態 ~NEQ `prompt$pS
］
⇒
~RET %現~状態
◎
If current state is not "prompt", return current state and abort these steps.
</li>
	<li>
<p>
［
~call元の~algoが［
%記述子 が述べる`強力な特能$
］を利用する
］ための`許可を表出する$よう利用者に依頼する
⇒
~RET 利用者からの~~回答に応じて
⇒＃
是認したならば `granted$pS ／
~ELSE_ `denied$pS
◎
Ask the user for express permission for the calling algorithm to use the powerful feature described by descriptor.
◎
If the user grants permission, return "granted"; otherwise return "denied".＼
</p>

<p>
この~~回答は、［［
この`~realm$,
および`同一-生成元$に属する他の`~realm$
］用の，`利用者の意図についての新たな情報$
］を供するものとしてヨイ。
◎
The user's interaction may provide new information about the user's intent for this realm and other realms with the same origin.
</p>

<div class="note">
<p>注記：
ここでの［
許可~UI ／ ~UAが利用者の意図をどう推定するか
］の詳細については、意図的に曖昧にしてある。
~UAは、この枠組みの下で数多の~UIを探求するべきである。
◎
This is intentionally vague about the details of the permission UI and how the UA infers user intent. UAs should be able to explore lots of UI within this framework.
</p>
<p class="trans-note">【
例えば，利用者が是認せず，明示的に否認することもなく~UIを退けた場合、`利用者の意図についての新たな情報$としては扱わないことも考えられる。
あるいは，利用者により予め為された環境設定により、
利用者からの~~回答を待機することなく，即時に結果を返すこともあるかもしれない。
】</p>
</div>
	</li>
</ol>

<p>
`PermissionName$I %名前 を`利用する許可を要請する$とは、次の略記である
⇒
［
`name$m ~memberが %名前 に設定された `PermissionDescriptor$I
］を`利用する許可を要請する$
◎
As a shorthand, requesting permission to use a PermissionName name, is the same as requesting permission to use a PermissionDescriptor with its name member set to name.
</p>
</div>

		</section>
		<section id="prompt-the-user-to-choose">
<h3 title="Prompt the user to choose">2.5. 何かを選ぶよう利用者に~promptする</h3>

<div class="algo">
<p>
%記述子 に結付けられている %選択肢~群 の中から一つを
`選ぶよう利用者に~promptする@
ときは、~UAは，次の手続きを遂行するモノトスル
— この~algoは［
`denied$pS ／ %選択肢~群 を成す選択肢のうち一つ
］を返す：
◎
To prompt the user to choose one of several options associated with a descriptor, the UA must perform the following steps. This algorithm returns either "denied" or one of the options.
</p>
<ol>
	<li>
~IF［
`許可~状態$( %記述子 ) ~EQ `denied$pS
］
⇒
~RET `denied$pS
◎
If descriptor's permission state is "denied", return "denied" and abort these steps.
</li>
	<li>
任意選択で
⇒
~IF［
`許可~状態$( %記述子 ) ~EQ `granted$pS
］
⇒
~RET %選択肢~群 を成す選択肢のうち一つ
— 利用者に~promptすることなく
⇒
この場合，~UAは、後続の同じ
( %記述子, 選択肢の集合 )
から`選ぶよう利用者に~promptする$ときも、~UAが`利用者の意図についての新たな情報$を受取っていない限り，同じ選択肢を返すモノトスル。
◎
If descriptor's permission state is "granted", the UA may return one of options and abort these steps. If the UA returns without prompting, then subsequent prompts for the user to choose from the same set of options with the same descriptor must return the same option, unless the UA receives new information about the user's intent.
</li>
	<li>
<p>
利用者に［
%選択肢~群 から一つの選択肢を選ぶか, 許可を否認するか
］依頼した上で
— ~call元の~algoが［
~prompt内に含める~extra情報
］を指定した場合は，それも含めた上で —
選ばれるまで待機する：
◎
Ask the user to choose one of the options or deny permission, and wait for them to choose. If the calling algorithm specified extra information to include in the prompt, include it.
</p>
		<ul>
			<li>
~RET ［
利用者は ある選択肢を選んだならば それ ／
~ELSE_ `denied$pS
］
◎
If the user chose an option, return it; otherwise return "denied".＼
</li>
			<li>
利用者から［
選んだものを，他の~realmにも適用するよう意図する
］ことが指示された場合は、それを，［
この~realm,
および`同一-生成元$に属する他の`~realm$
］用の`利用者の意図についての新たな情報$として扱うとする。
◎
If the user's interaction indicates they intend this choice to apply to other realms, then treat this this as new information about the user's intent for other realms with the same origin.
</li>
		</ul>
<p class="note">注記：
ここでの［
許可~UI ／
~UAが利用者の意図をどう推定するか
］についての詳細は、意図的に曖昧にしてある。
~UAは、この枠組みの下で数多の~UIを探求するべきである。
◎
This is intentionally vague about the details of the permission UI and how the UA infers user intent. UAs should be able to explore lots of UI within this framework.
</p>
	</li>
</ol>

<p>
`PermissionName$I %名前 に結付けられている選択肢~群から一つを`選ぶよう利用者に~promptする$とは、次の略記である
⇒
［
`name$m ~memberが %名前 に設定された`PermissionDescriptor$I 
］に結付けられている選択肢~群から`選ぶよう利用者に~promptする$
◎
As a shorthand, prompting the user to choose from options associated with a PermissionName name, is the same as prompting the user to choose from those options associated with a PermissionDescriptor with its name member set to name.
</p>
</div>

		</section>
		<section id="reacting-to-revocation">
<h3 title="Reacting to users revoking permission">2.6. 利用者から許可が~revokeされたときの反応-法</h3>

<div class="algo">
<p>
~UAは，［
利用者が［
ある`~realm$ %~Realm において，`強力な特能$ %特能 を利用する許可を是認する
］ことを，もはや意図しない
］ことを学習したときは、次に従って
`利用者により許可が~revokeされたとき反応する@
とする：
◎
When the UA learns that the user no longer intends to grant permission for a realm to use a feature, react to the user revoking permission by:
</p>
<ol>
	<li>
`~taskを~queueする$(
【`~task源$が指定されていない（`許可~task源$？）】,
%特能 の`許可~revocation~algo$,
%~Realm の`設定群~obj$の`担当の~event~loop$enV
)
◎
Queue a task on the Realm's settings object's responsible event loop to run that feature's permission revocation algorithm.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="navigator-and-workernavigator-extension">
<h2 title="Extensions to the Navigator and WorkerNavigator interfaces">3. `Navigator^I, `WorkerNavigator^I ~interfaceに対する拡張</h2>

<pre class="idl">
[`Exposed$=(Window)]
partial interface `Navigator$I {
  [`SameObject$] readonly attribute `Permissions$I `permissions@m;
};
</pre>

<pre class="idl">
[`Exposed$=(Worker)]
partial interface `WorkerNavigator$I {
  [`SameObject$] readonly attribute `Permissions$I `~permissions0@m;
};
</pre>

	</section>
	<section id="permissions-interface">
<h2 title="Permissions interface">4. `Permissions^I ~interface</h2>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `Permissions@I {
  `Promise$&lt;`PermissionStatus$I&gt; `query$m(`object$ %permissionDesc);
};

dictionary `PermissionDescriptor@I {
  required `PermissionName$I `name@m;
};
</pre>

<div class="algo" id="query-method">
`query(permissionDesc)@m
~method手続きは
⇒
`許可を~queryする$( %permissionDesc )
◎
4.1. query() method
◎
When the query() method is invoked, the user agent MUST run the following＼
</div>

<div class="algo">
<p>
`許可を~queryする@
ときは、所与の
( %許可~記述子 )
に対し：
◎
query a permission algorithm, passing the parameter permissionDesc:
</p>
<ol>
	<li>
<p>
%有型~記述子 ~LET 次の下位手続きを走らせた結果：
</p>
		<ol>
			<li>
%根~記述子 ~LET %許可~記述子 を `PermissionDescriptor$I 型の`~IDL値に変換-$した結果
</li>
			<li>
%特能 ~LET %根~記述子[ "`name$m" ] で`識別される特能$
</li>
			<li>
~RET %許可~記述子 を［
%特能 の`許可~記述子~型$
］の`~IDL値に変換-$した結果
</li>
		</ol>
<p>
この段で例外が投出されたときは
⇒
~RET その例外で`却下される~promise$
</p>

◎
Let rootDesc be the object permissionDesc refers to, converted to an IDL value of type PermissionDescriptor. If this throws an exception, return a promise rejected with that exception and abort these steps.
◎
Let typedDescriptor be the object permissionDesc refers to, converted to an IDL value of rootDesc's name's permission descriptor type. If this throws an exception, return a promise rejected with that exception and abort these steps.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a newly-created Promise.
</li>
	<li>
~RET %~promise
— ただし、以降の手続きも`並列的$に走らす
◎
Return promise and continue the following steps asynchronously.
</li>
	<li>
%状態s ~LET `~PermissionStatusを作成する$( %有型~記述子 )
◎
Run the steps to create a PermissionStatus for typedDescriptor, and let status be the result.
</li>
	<li>
%~query ~LET %状態s の `query$sl
◎
Let query be status's [[query]] internal slot.
</li>
	<li>
%~query[ "`name$m" ] で`識別される特能$の`許可~query~algo$( %~query, %状態s )
◎
Run query's name's permission query algorithm, passing query and status.
</li>
	<li>
%状態s で %~promise を`解決する$
◎
Resolve promise with status.
</li>
</ol>
</div>

		</section>
	
	<section id="permissionstatus-interface">
<h2 title="PermissionStatus interface">5. `PermissionStatus^I ~interface</h2>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PermissionStatus@I : `EventTarget$I {
  readonly attribute `PermissionState$I `state$m;
  readonly attribute `PermissionName$I `~name0$m;
  attribute `EventHandler$I `onchange$m;
};

enum `PermissionState@I {
  `granted$pS,
  `denied$pS,
  `prompt$pS,
};
</pre>

<p>
`PermissionStatus$I の各~instanceは、
`query@sl
内部~slotを伴って作成される。
それは、［
ある`強力な特能$の`許可~記述子~型$
］の~instanceを~~保持する。
◎
PermissionStatus instances are created with a [[query]] internal slot, which is an instance of a feature's permission descriptor type.
</p>

<p>
この~APIを利用しているときの各~列挙値［
`granted@pS
は`是認-$された／
`denied@pS
は`否認-$された／
`prompt@pS
は`~prompt$する
］ことの概念を表現する。
◎
When using the API, the "granted", "denied", and "prompt" enum values represent the concepts of granted, denied, and prompt respectively.
</p>

<div class="algo">
<p id="creating-instances">
`~PermissionStatusを作成する@
ときは、所与の
( `PermissionDescriptor$I %許可~記述子 )
に対し，次を走らす：
</p>
<ol>
	<li>
%名前 ~LET %許可~記述子[ "`name$m" ]
</li>
	<li>
%特能 ~LET %名前 で`識別される特能$
</li>
	<li>
%結果 ~LET 新たな［
%特能 の`許可~結果型$
］の~instance
</li>
	<li>
%結果 の `query$sl 内部~slot ~SET %許可~記述子
</li>
	<li>
%結果 の `~name0$m ~SET %名前
</li>
	<li>
~RET %結果
</li>
</ol>
◎
5.1. Creating instances
◎
To create a PermissionStatus for a given PermissionDescriptor permissionDesc, return a new instance of the permission result type for the feature named by permissionDesc's name, with the [[query]] internal slot initialized to permissionDesc, and name initialized to permissionDesc's name.
</div>

<div class="algo" id="name-attribute">
`~name0@m
取得子~手続きは、初期化~時の値を返す。
◎
5.2. name attribute
◎
The name attribute returns the value it was initialized to.
</div>

<div class="algo" id="state-attribute">
`state@m
取得子~手続きは、最後に設定された値を返す。
◎
5.3. state attribute
◎
The state attribute returns the latest value that was set on the current instance.
</div>

<p id="onchange-attribute">
`onchange@m
属性は、`~event~handler~event型$ `change^et に対応する`~event~handler$である。
◎
5.4. onchange attribute
◎
The onchange attribute is an event handler whose corresponding event handler event type is change.
</p>

<div class="algo">
<p id="PermissionStatus-update">
`~UA$は， `PermissionStatus$I ~instance %状態s の状態が変化したことに自覚したときは、
いつでも，次の
`~PermissionStatus更新~手続き@
を非同期的に走らすモノトスル：
◎
Whenever the user agent is aware that the state of a PermissionStatus instance status has changed, it asynchronously runs the PermissionStatus update steps:
</p>
<ol>
	<li>
%~query ~LET %状態s の `query$sl
◎
Let query be status's [[query]] internal slot.
</li>
	<li>
%~query[ "`name$m" ] で`識別される特能$の`許可~query~algo$( %~query, %状態s )
◎
Run query's name's permission query algorithm, passing query and status.
</li>
	<li>
次を走らす`~taskを~queueする$(
`許可~task源@
)
⇒
`~eventを発火する$( %状態s, `change^et )
◎
Queue a task on the permissions task source to fire an event named change at status.
</li>
</ol>
</div>

		<section id="permissionstatus-gc">
<h3 title="Garbage collection">5.1. ~garbage収集</h3>

<div class="p">
<p>
`PermissionStatus$I ~obj %P が次のいずれかを満たす間は、
%P に`関連な大域~obj$（ `Window$I ／ `WorkerGlobalScope$I ）
【！Window or WorkerGlobalScope object that the PermissionStatus object's constructor was invoked from】
から %P への強い参照があるモノトスル：
</p>
<ul>
	<li>
%P には `change^et ~event用の~event~listenerが 1 個以上は登録されている。
</li>
	<li>
`許可~task源$から %P により~queueされた~taskが在る
</li>
</ul>
◎
While an PermissionStatus object has one or more event listeners registered for "change", there must be a strong reference from the Window or WorkerGlobalScope object that the PermissionStatus object's constructor was invoked from to the PermissionStatus object itself.
◎
While there is a task queued by an PermissionStatus object on the permissions task source, there must be a strong reference from the Window or WorkerGlobalScope object that the PermissionStatus object's constructor was invoked from to that PermissionStatus object.
</div>

		</section>
	</section>
	<section id="powerful-features-registry">
<h2 title="Powerful features registry">6. 強力な特能~群の~registry</h2>

<pre class="idl">
enum `PermissionName@I {
  `accelerometer$pN,
  `ambient-light-sensor$pN,
  `background-fetch$pN,
  `background-sync$pN,
  `bluetooth$pN,
  `camera$pN,
  `display-capture$pN,
  `geolocation$pN,
  `gyroscope$pN,
  `magnetometer$pN,
  `microphone$pN,
  `midi$pN,
  `nfc$pN,
  `notifications$pN,
  `persistent-storage$pN,
  `push$pN,
  `screen-wake-lock$pN,
  `speaker-selection$pN,
  `xr-spatial-tracking$pN,
};
</pre>

<p>
`PermissionName$I の各~列挙~値は、
ある`強力な特能$を識別する
— これらの値のうち，次の表の 1 列目に挙げるものは、
同じ行の 2 列目に挙げる~APIによる`強力な特能$を識別する：
◎
Each enumeration value in the PermissionName enum identifies a powerful feature.
</p>

<div>
<table><thead><tr>
<th>列挙値
<th>`強力な特能$を定義する仕様／~API
</thead><tbody>

<tr><td>`accelerometer@pN
<td>`Accelerometer$cite `accelerometer$r

<tr><td>`ambient-light-sensor@pN
<td>`Ambient Light Sensor$cite `ambient-light$r

<tr><td>`background-fetch@pN
<td>`Background Fetch$cite `background-fetch$r

<tr><td>`background-sync@pN
<td>`Web Background Synchronization$cite `web-background-sync$r

<tr><td>`bluetooth@pN
<td>`Web Bluetooth$cite `web-bluetooth$r

<tr><td>`camera@pN
<td>`Media Capture and Streams$cite `mediacapture-streams$r

<tr><td>`microphone@pN
<td>`Media Capture and Streams$cite `mediacapture-streams$r

<tr><td>`display-capture@pN
<td>`Screen Capture$cite `screen-capture$r

<tr><td>`geolocation@pN
<td>`Geolocation API$cite `Geolocation$r

<tr><td>`gyroscope@pN
<td>`Gyroscope$cite `gyroscope$r

<tr><td>`magnetometer@pN
<td>`Magnetometer$cite `magnetometer$r

<tr><td>`midi@pN
<td>`Web MIDI API$cite `webmidi$r

<tr><td>`notifications@pN
<td>`Notifications API Standard$cite `notifications$r

<tr><td>`persistent-storage@pN
<td>`Storage Standard$cite `storage$r

<tr><td>`push@pN
<td>`Push API$cite `push-api$r

<tr><td>`speaker-selection@pN
<td>`Audio Output Devices API$cite `audio-output$r

<tr><td>`xr-spatial-tracking@pN
<td>`WebXR Device API$cite `webxr$r

</tbody></table>

◎
The accelerometer enum value identifies the Accelerometer API powerful feature.
◎
The ambient-light-sensor enum value identifies the Ambient Light Sensor powerful feature.
◎
The background-fetch enum value identifies the Background Fetch powerful feature.
◎
The background-sync enum value identifies the Web Background Synchronization powerful feature.
◎
The bluetooth enum value identifies the Web Bluetooth powerful feature.
◎
The camera and microphone enum values identify the Media Capture and Streams powerful features.
◎
The display-capture enum value identifies the Screen Capture powerful feature.
◎
The geolocation enum value identifies the Geolocation API powerful feature.
◎
The gyroscope enum value identifies the Gyroscope API powerful feature.
◎
The magnetometer enum value identifies the Magnetometer API powerful feature.
◎
The midi enum value identifies the Web MIDI API powerful feature.
◎
The notifications enum value identifies the Notifications API Standard powerful feature.
◎
The persistent-storage enum value identifies the Storage Standard powerful feature.
◎
The push enum value identifies the Push API powerful feature.
◎
The speaker-selection enum value identifies the Audio Output Devices API powerful feature.
◎
The xr-spatial-tracking enum value identifies the WebXR Device API Device API powerful feature. 
</div>

		<section id="screen-wake-lock">
<h3 title="Screen wake lock">6.1. ~screen~wake~lock（ `screen-wake-lock^l ）</h3>

<p>
`screen-wake-lock@pN
列挙値は、
`Screen Wake Lock API$cite `screen-wake-lock$r
による`強力な特能$を識別する。
それは、`既定の強力な特能$である。
◎
The screen-wake-lock enum value identifies the Screen Wake Lock API powerful feature. It is a default powerful feature.
</p>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

		</section>
		<section id="nfc">
<h3 title="NFC">6.2. ~NFC（ `nfc^l ）</h3>

<p class="issue">
この`強力な特能$の実装は一つしかないので、
`W3C Process^en に則り，`~risk下$にある。
◎
This powerful feature only has a single implementation, and therefore, as per the W3C Process, it is at risk.
</p>

<p>
`nfc@pN
列挙値は、
`Web NFC API$cite `web-nfc$r
による`強力な特能$を識別する。
◎
The nfc enum value identifies the Web NFC API powerful feature.
</p>

		</section>
	</section>
	<section id="relationship-to-permissions-policy">
<h2 title="Relationship to the Permissions Policy specification">許可~施策~仕様との関係性</h2>

~INFORMATIVE

<p>
この仕様, 許可~施策~仕様（ `Permissions Policy^cite, `Permissions-Policy$r ）どちらも，技術的には一連の “許可” を処するものであるが、
それぞれ，~platformにおける別個な目的を~serveする。
だとしても、この 2 つの仕様には，重合する所も明示的にある。
◎
Although technically this specification and the Permissions Policy specification ([Permissions-Policy]) deal with "permissions", each specification serves a distinct purpose in the platform. Nevertheless, the two specifications do explicitly overlap.
</p>

<p>
この仕様が専ら懸念する`強力な特能$は、
その~accessが~UAが仲介する許可~UIを通して管理されるものである
（すなわち、
利用者の同意は，［
当の特能が利用されようとする前に，利用者が許可を与える
］ことにより表出され、
どの利用者も，理由を問わず その許可をいつでも否認する能を維持する）。
これらの強力な特能は、この仕様の `PermissionName$I 列挙型により明示的に識別される。
◎
On the one hand, this specification exclusively concerns itself with powerful features whose access is managed through a user-agent mediated permissions UI (i.e., permissions where the user gives express consent before that feature can be used, and where the user retains the ability to deny that permission at any time for any reason). These powerful features are explicitly identified by this specification's PermissionName enum.
</p>

<p>
他方，許可~施策~仕様は、`許可~施策$【！`許可~施策$doc】を通して，`強力な特能$を選択的に［
可能化する／不能化する
］ことを開発者に許容する（~HTTP~header, `allow$a 属性どちらにせよ）。
許可~施策~仕様が視野に入れる~APIや特能は、
この仕様の `PermissionName$I 列挙型により識別されるものを超える（例： `sync-xhr^pN ／ `gamepad^pN ）。
許可~施策は、このイミにおいて，この仕様を組み込むものであり、
ある特能が可用になるかどうかを，この仕様とは まったく独立に統治する。
◎
On the other hand, the Permissions Policy specification allows developers to selectively enable and disable powerful features through a "permissions policy" (be it a HTTP header or a the allow attribute). The APIs and features in scope for the Permissions Policy specification go beyond those identified in this specification's PermissionName enum (e.g., "sync-xhr" and "gamepad"). In that sense, the Permissions Policy subsumes this specification in that Permissions Policy governs whether a feature is available at all, independently of this specification.
</p>

<p>
許可~施策~仕様により不能化される`強力な特能$は、
この仕様においては，その`許可~状態$は常に`否認-$されるものとして反映される。
このことは、［
現在の`許可~状態$の読取りが，
`HTML$r の “`利用は許容されて$いるかどうか” の検査に依拠する
］ことから生じる
— この検査~自体も，許可~施策~仕様の中へ~callする。
ここでの重要な注意点は、
許可の名前が両~仕様にて共有されることである。
この仕様は `PermissionName$I 列挙型を備える一方で、
許可~施策~仕様は，許可の名前を定義している他の仕様に依拠する
（例： 許可 `gamepad^pN は、 `Gamepad$r 内に定義される, 等々）。
◎
A powerful feature that has been disabled by the Permissions Policy specification always has its permission state reflected as "denied" by this specification. This occurs because reading the current permission state relies on [HTML]'s "allowed to use" check, which itself calls into the Permissions Policy specification. Important to note here is the sharing of permission names across both specifications. Where this specification has the PermissionName enum, the Permissions Policy specification relies on other specifications defining the names of the permissions (e.g., the permission "gamepad" is defined in [Gamepad], and so on).
</p>

<p>
最後に，ある強力な特能が［
許可~施策~仕様が供する手段を通して`是認-$されるようになる
］ことはアリでない。
是認され得る仕方は、~UAが供する許可~UIを通すか，他の何らかの~UA施策による他にない。
◎
Finally, it's not possible for a powerful feature to ever become "granted" through any means provided by the Permissions Policy specification. The only way that a powerful feature can be "granted" is through a user-agent provided permission UI, or by some other user agent policy.
</p>

	</section>
	<section id="automation">
<h2 title="B. Automated testing">自動化された~test法</h2>
~INFORMATIVE

<p>
この仕様の自動化された~test法は、
`Permissions Automation$cite
文書に供される~APIを利用して遂行される。
◎
Automated testing of this specification is performed using the API provided by the Permissions Automation document.
</p>

	</section>
	<section id="privacy-considerations">
<h2 title="C. Security and privacy considerations">~security／~privacyの考慮点</h2>

~INFORMATIVE

<p>
~web~pageは、信用-度が様々な~componentを同一-生成元の下で走らすことが多い。
例えば，ある新聞社は、
広告-用の~codeを非同一-生成元 `iframe^e の中へ~sandbox化することなく走らすこともある。
当の新聞社に，ある個人の所在を利用する正当な理由がある場合、
それは，所在への~accessを信用-度がより低い広告主に是認するときにも起こる。
この仕様における `query()$m 関数を経ることなく，当人の所在を読取るためには、
広告は~promptを示す~riskを負う必要があり，そのことの検出を公開する。
この関数を経る場合、
広告が黙して追跡できる者は，自身の所在をすでに新聞社に是認した者だけになる。
~UAは、~page上で ある許可が利用-中にあるとき，通告を供することもできる
— それは、濫用の可視性を高めることになろう。
◎
Web pages often run more- and less-trusted components as the same origin. For example, a newspaper may run advertising code without sandboxing it into a cross-origin iframe. If the newspaper has a legitimate reason to use a person's location, that also happens to grant access to the less trusted advertiser. Without the query() function in this specification, to read the person's location, an advertisement needs to risk showing a prompt, which exposes it to detection. With this function, the advertisement can silently track just the people who've already granted their location to the newspaper. The UA might provide notice of when permissions are in use on a page which might increase the visibility of abuse.
</p>

<p>
ある敵対者は、末端利用者に対応する “指紋” を作成するための要素として，`許可~状態$も利用できる。
敵対者は，実際に~APIを利用して すでに許可の状態を決定できるが、それは，末端利用者に対し許可~要請~UIが呈示される結果に至ることが多い（その許可が すでに是認されている（ `granted$pS ）場合は除き）。
したがって，この~APIは、~web~siteに新たな指紋収集~情報を公開することはないが，敵対者にとって この情報への目立たない~accessを容易にする。
したがって，実装には、`許可~状態$を~queryするのを（大域的に, または選択的に）阻止する選択肢を，利用者に与えることが奨励される。
◎
An adversary could use a permission state as an element in creating a "fingerprint" corresponding to an end-user. Although an adversary can already determine the state of a permission by actually using the API, that often leads to a permission request UI being presented to the end-user (if the permission was not already "granted"). Thus, even though this API doesn't expose new fingerprinting information to websites, it makes it easier for an adversary to have discreet access to this information. Thus, implementations are encouraged to have an option for users to block (globally or selectively) the querying of permission states.
</p>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

~INFORMATIVE

<div>
<p>
~API設計と編集上の作業に助力された、次の方々に：
</p>
<div lang="en">
Adrienne Porter Felt, Anne van Kesteren, Domenic Denicola, Jake Archibald and Wendy Seltzer
</div>
◎
The editors would like to thank Adrienne Porter Felt, Anne van Kesteren, Domenic Denicola, Jake Archibald and Wendy Seltzer for their help with the API design and editorial work.
</div>

	</section>
</main></div>

