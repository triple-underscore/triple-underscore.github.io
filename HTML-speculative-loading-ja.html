<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Speculative loading（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
case 'hH':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'h':
	text = `\`<code class="header">${key}</code>\``;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2025-09-18
trans_update:2025-09-24
	source_checked:
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/speculative-loading.html
	abbr_url:HTMLlifecycle
site_nav:browsers,network,html
nav_prev:HTMLlifecycle
nav_next:WAPI
trans_1st_pub:2025-09-24


●●class_map
e:element
a:attr
et:event-type
sc:scheme
h:header
E:error
jv:js-value
t:type
st:attr-state
U:code-point
dir:directive

●●tag_map
I:code
c:code
e:code
a:code
et:code
sc:code
E:code
h:code
mt:code
st:i
dir:code
U:span
t:var
i:i
cite:cite
	em:em

●●original_urls

●●words_table

	●名称
Infra:
Speculation-Rules:
X-Frame-Options:
No-Vary-Search:
IP:
TLS:
VPN:
XSS:
POST:

	~CSP:Content Security Policy

	●投機
投機的:speculative::~
投機:speculation::~
投機-:speculate::~
候補:candidate:~
search::::クエリ
多様度:variance::~
早急:eager::~
早急度:eagerness::~
prefetch:
	~prefetch法:prefetching
prerender:
	~prerender用の:prerendering
	~prerender法:prerendering
述部:predicate::~
条項:clause:~
論理積:conjunction:~
論理和:disjunction:~
否定:negation:~
冗長:redundant:~
要件:requirement:~

	に先立って:ahead of
	事前に:ahead of time
	速くする:make faster
	そうな兆し:sign
	当の候補の~URL:this URL

	●network／navi
ok:
HTTP_S:HTTP(S)
発行-:issue:~
naviな:navigational:::ナビな
provider::::プロバイダ
subscriber:
新鮮:fresh:~
処置先:disposition::~
読込直す:reloadする::読み込み直す::リロードする
差分:delta:~
refresh:

	^en:virtual private network

	●UI
手入力:enter:~
打込んで:typeして:打ち込んで
注視-:watch:~
hover:
battery::::バッテリー
閉じる:closeする::~
操作o:operation:操作
確認-:confirm:~
隠さな:hideしな:~
popup::::ポップアップ

	~URL~bar:address bar
	一瞬でも:even momentarily
	~~目立つもの:prominent
	近い:near
	節約:-saver
	~data節約:data-saver
	~data節約~mode:data-saver
	~battery節約:battery-saver
	~battery節約~mode:battery-saver
	長押し:long-press
	押した:press
	閉じるよう強制する:force-closing

	●一般処理
小task:microtask::小 task:小タスク
昇順:ascending-order:~
警告:warning:~
同値:equivalence:~

	●変数
A:
B:
生の:raw:~

	%A:A
	%B:B
	%C:C
	%要素:el
	%匿名~化~施策:anonymizationPolicy
	%基底~URL:基底~URL
	%本体~byte列:bodyBytes
	%本体~text:bodyText
	%候補:candidate
	%候補~A:candidateA
	%候補~B:candidateB
	%候補~群:candidates
	%条項:clause
	%条項~群:clauses
	%子孫:descendant
	%文書:document
	%~group:group
	%入力:input
	%~item:item
	%~link:link
	%~link群:links
	%~No-Vary-Search~hint:noVarySearchHint
	%構文解析-済み:parsed
	%構文解析-済み~list:parsedList
	%構文解析-済み選択子~list:parsedSelectorList
	%構文解析-済み~URL:parsedURL
	%~pattern:pattern
	%~pattern群:patterns
	%述部:predicate
	%述部~種別:%predicateType
	%~prefetch候補:-
	%~prefetch候補:prefetchCandidate
	%~prefetch候補~群:prefetchCandidates
	%~prefetch候補~group群:prefetchCandidateGroups
	%~prefetch~record:prefetchRecord
	%生の条項:rawClause
	%生の~pattern:rawPattern
	%生の~pattern群:rawPatterns
	%生の選択子:rawSelector
	%生の選択子~群:rawSelectors
	%~referrer施策:referrerPolicy
	%要請:request
	%要件:requirement
	%要件~群:requirements
	%応答:%応答
	%結果:result
	%規則:rule
	%規則~群:-
	%規則~集合:ruleSet
	%規則~集合~levelの~tag:rulesetLevelTag
	%選択子:selector
	%選択子~群:selectors
	%~source:source
	%~tag:tag
	%~tag~A:tagA
	%~tag~B:tagB
	%~tag群:tags
	%送信する~tag群:tagsToSend
	%種別:type
	%~prefetchとして扱う種別~群:typesToTreatAsPrefetch
	%~URL:url
	%~URL文字列:urlString
	%~URL群:urls
	%早急度:eagerness
	%~MIME型:-
	%応答:response
	%~navigable:navigable
	%~CSP~list:cspList
	%行先~生成元:destinationOrigin
	%施策:policy
	%~X-Frame-Options:rawXFrameOptions
	%~frame~option群:xFrameOptions
	%容器~文書:containerDocument
	%利用者-関与i
	%~source文書
	%値:value


	●security/privacy
ambient:
権限:authority::~
仕掛ける:mountする:~
持続的:persistent:~
濫用-:abuse:~
協調-:coordinate:~
発生-:arise:~
防御:defense::~
経路:path::~
経路上の:on-path::~
多層防御:defense-in-depth::~
表口:surface::口
防止:prevention:~
不可欠:crucial:~
消去-:erase:~
拡げる:expandする:~
活動:activity:~
危険:dangerous:~
分析:analysis:~
遭遇-:encounter:~
措置:measure:~
特質:property:~
log-out:log out:::ログアウト
面倒事:trouble:~
実体:entity:~
出生-:originate:~
出口:egress:~
地理所在:geolocation::~
所在-:locate:~
管轄:jurisdiction:~
漏出-:exfiltrate:~
濫用:abuse:~
偽り:spurious:~

	匿名~化:anonymization
	危険~性は〜より低い:less dangerous
	意図nに反して:unintentionally
	用心する:be cautious
	〜しか許容しないようにする:allowlist
	分断-:break out
	罠に嵌める:letting 〜 trap

	●仕様
推定-:infer:~
捕捉-:capture:~
策:strategy::~
保守的:conservative::~
運用者:operator:~
理論的:theoretical:~
動作化-:enact:~
追求-:seek:~
増補:enhancement:~
余計:extra:~
有益:beneficial:~
推移的:transitive:~
優先-:prioritize:~
優先度:priority:~
	優先度を低くする:give low priority
指図-:instruct:~
balance::::バランス
関心:interest:~
本物の:realな:~
参照r:refer:参照
反生産的:counterproductive:~
細やか:granular:~
克服-:overcome:~
設置-:place:~
先進的:novel:~
仔細:nuanced:~
必要最小限:minimal:~
固守:adherence:~
翻訳-:translate:~

	効率を悪くする:make 〜 less efficient
	良い:good
	~~分類され:categories
	にもなり得る:potentially
	に関して:regard
	〜ない見込みが高い:unlikely
	ほぼ〜見込まれる:very likely to be
	相応に:fairly
	任意選択で:may
	~web~platform:platform
	より重要~度は低い:less important
	今の所は:As of now,
	今の所は:For now,
	~call元:call site
	に価する:worthwhile
	に価する:worth
	価し得る:trustworthy
	それでも:That said,
	と引き換えに:tradeoff
	誤って解釈する:misinterpret
	環境設定に誤りがある場合:misconfiguration
	~~寛容~lenient
	書いて:writing
	原因になる:cause
	に従って:per
	少しでも示唆されたなら:even a slight suggestion that
	見込みが高い:likely
	選ぶ:chooseする
	よりも安全:safer
	認識されない:unrecognized
	倣う:in line with
	~~付随する:attendant
	利用者が暗黙的に表出したものも含む:express or implied
	~~特有:particular
	勧める:it is advisable
	どの~optionをとり得るか:the options open to 
	〜場合には:to the extent
	少なくとも:at a minimum
	紛らわしく:confused
	~~検討:contemplate
	取って代わる:supersede

	●未分類
essence:
給-:supply:~
競合-:conflict:~
漸進的:progressive:~
早期:early:~
為され:makeされ:~
為す:makeする:~
為した:makeした:~
transaction::::トランザクション
database::::データベース
購入:purchase:~
route::::ルート
stateless:

	になる限り早く:as soon as
	示す:show
	妥当でない:invalid
	含む:include
	アリ性:possibility
	まだ:not-yet-
	へ向けて:toward
	し始めた:begun
	~escape法:escaping
	何もしない:to do nothing
	上の~loopにおける 2 回目の反復:The second pass through
	一部でも:some or all of
	時間だけ:amount of time
	lead^en 時間:lead time
	時点:at 〜 time
	時点までに:by the time
	時々:time to time
	同時に:at the same time
	何秒か:some time
	進行中な:going on
	以外の:apart from
	いずれかの〜識別子に一致する:drawn form
	少ない:small
	し直す:re-
	以前の:previous
	~escapeされてない:unescaped
	終了~tag:closing 〜 tag
	詰め込む:stuff
	戻る:back
	進む:forward
	奥へ進む選択肢:choice as to whether to go down
	再~計算:recalculation

●●words_table1
CONSOLE:console-ja.html
URLPATTERN:urlpattern-ja.html
HTTPnvs:https://httpwg.org/http-extensions/draft-ietf-httpbis-no-vary-search.html
PREFETCH:https://wicg.github.io/nav-speculation/prefetch.html

sf:<sub>sf-</sub>

●●original_id_map

	nav-traversal-ui:history-notes

●●mdn_urls

●●link_map

	●code
E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror

I.URLPatternInit:~URLPATTERN#dictdef-urlpatterninit
	I.Document:~HTMLdom#document → 文書

c.fetch():~FETCH#dom-global-fetch

e.a:~HEtextlevel#the-a-element
e.area:~HEimages#the-area-element
e.iframe:~HEembed#the-iframe-element
e.meta:~HEmetadata#the-meta-element
e.script:~HEscripting#the-script-element

a.href:~HTMLlinks#attr-hyperlink-href
a.http-equiv:~HEmetadata#attr-meta-http-equiv
a.type:~HEscripting#attr-script-type

v.no-referrer:~REFERRER-POLICY#referrer-policy-no-referrer

et.pointerdown:~POINTEREVENTS#the-pointerdown-event

h.Refresh:#refresh
h.Speculation-Rules:#speculation-rules-2
h.Sec-Speculation-Tags:#sec-speculation-tags
h.X-Frame-Options:#x-frame-options
h.No-Vary-Search:~HTTPnvs#name-http-header-field-definitio
h.Sec-Purpose:~FETCH#sec-purpose-header

dir.script-src:~CSP3#script-src
dir.default-src:~CSP3#default-src
dir.frame-ancestors:~CSP3#frame-ancestors

mt.application/speculationrules+json:~HTMLiana#application/speculationrules+json

l.immediate:#sr-eagerness-immediate
l.eager:#sr-eagerness-eager
l.moderate:#sr-eagerness-moderate
l.conservative:#sr-eagerness-conservative

	●用語
投機~規則~集合の著作~要件:#speculation-rule-set-authoring-requirements

妥当な投機~規則:#valid-speculation-rule
妥当な文書~規則~述部:#valid-document-rule-predicate
妥当な~URL~pattern入力:#valid-url-pattern-input

srs.~prefetch規則~群:#sr-set-prefetch

投機~規則:#speculation-rule
sr.~URL群:#sr-urls
sr.述部:#sr-predicate
sr.早急度:#sr-eagerness
sr.~referrer施策:#sr-referrer-policy
sr.~tag群:#sr-tags
sr.要件~群:#sr-requirements
sr.~No-Vary-Search~hint:#sr-nvs-hint

文書~規則~述部:#document-rule-predicate
文書~規則~論理積:#document-rule-conjunction
文書~規則~論理和:#document-rule-disjunction
文書~規則~否定:#document-rule-negation
文書~規則~URL~pattern述部:#document-rule-url-pattern-predicate
文書~規則~選択子~述部:#document-rule-selector-predicate

drC.条項~群:#sr-dr-c-clauses
drD.条項~群:#sr-dr-d-clauses
drN.条項:#sr-dr-n-clause
~pattern群:#sr-dr-urlpattern-patterns
選択子~群:#sr-dr-cssselector-selectors
投機~規則~早急度:#speculation-rule-eagerness

	~less早急:#sr-eagerness-less-eager → 以上に早急$でない
以上に早急:#sr-eagerness-at-least-as-eager

合致している~linkたちを見出す:#find-matching-links
投機~規則~tag:#speculation-rule-tag
投機~規則~要件:#speculation-rule-requirement
投機~規則~集合~文字列を構文解析する:#parse-a-speculation-rule-set-string
投機~規則を構文解析する:#parse-a-speculation-rule
文書~規則~述部を構文解析する:#parse-a-document-rule-predicate
投機~規則~集合:#speculation-rule-set
投機的な読込nを考慮する:#consider-speculative-loads
投機的な読込nの候補:#speculative-load-candidate
slC.~URL:#sl-candidate-url
slC.~No-Vary-Search~hint:#sl-candidate-nvs-hint
slC.早急度:#sl-candidate-eagerness
slC.~referrer施策:#sl-candidate-referrer-policy
slC.~tag群:#sl-candidate-tags
~prefetch候補:#prefetch-candidate
匿名~化~施策:#sl-candidate-anonymization-policy
~prefetch~IP匿名~化~施策:#prefetch-ip-anonymization-policy
非同一-生成元~prefetch~IP匿名~化~施策:#cross-origin-prefetch-ip-anonymization-policy
copiap.生成元:#copiap-origin
互いに冗長:#sl-candidate-redundant-with
doc.投機~規則~集合~群:#document-sr-sets
~queueされた投機的な読込n小taskを考慮するか:#consider-speculative-loads-microtask-queued
投機的な読込nを考慮する内縁~手続き:#inner-consider-speculative-loads-steps
投機的な読込nの~referrer施策を算出する:#compute-a-speculative-load-referrer-policy
投機的な読込nの候補たちから~tag群を収集する:#collect-tags-from-speculative-load-candidates
	述部は要素に合致するか否か:
合致-:#dr-predicate-matches
投機~規則~群~task~source:#speculation-rules-task-source
~Speculation-Rules~headerを処理する:#process-the-speculation-rules-header
~navi応答の~X-Frame-Optionsに対する固守を検査する:#check-a-navigation-response's-adherence-to-x-frame-options


	＠#note-speculation-rules-parse-prerender-as-prefetch
	＠#note-speculation-rules-parse-target-hint
	＠~HTTPnvs#section-6
	＠#step-prefetch-record-cancel-and-discard
	＠~HTMLissue/11123
	＠#speculative-loading-state-partitioning

	●用語（HTML
並列的:~HTMLINFRA#in-parallel

文書:~HTMLdom#the-document-object

st.~refresh:~HEmetadata#attr-meta-http-equiv-refresh

el.~URL:~HTMLlinks#concept-hyperlink-url
~hyperlink:~HTMLlinks#hyperlink
~hyperlink~referrer施策:~HTMLlinks#hyperlink-referrer-policy


生成元:~ORIGIN#concept-origin
~site:~ORIGIN#site
同一-生成元:~ORIGIN#same-origin

~navigable:~HTMLds#navigable
辿可能な~navigable:~HTMLds#traversable-navigable
nav.容器~文書:~HTMLds#nav-container-document
nav.作動中な~entry:~HTMLds#nav-active-history-entry
~node~navigable:~HTMLds#node-navigable
~top-level辿可能:~HTMLds#top-level-traversable
子~navigable:~HTMLds#child-navigable
全部的に作動中:~HTMLds#fully-active
doc.容器~文書:~HTMLds#doc-container-document
~top-level辿可能~集合:~HTMLds#top-level-traversable-set
新鮮な~top-level辿可能を作成する:~HTMLds#create-a-fresh-top-level-traversable
~top-level辿可能を閉じる:~HTMLds#close-a-top-level-traversable
~top-level辿可能を破壊する:~HTMLds#destroy-a-top-level-traversable
tn.~session履歴~entry群:~HTMLds#tn-session-history-entries
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context
bc.~popupか:~HTMLds#is-popup

~navigateする:~HTMLnav#navigate
読込直す:~HTMLnav#reload
履歴を差分だけ辿る:~HTMLnav#traverse-the-history-by-a-delta
素片へ~navigateする:~HTMLnav#navigate-fragid
dS.資源:~HTMLnav#document-state-resource
~POST資源:~HTMLnav#post-resource
i.~browser~UI:~HTMLnav#uni-browser-ui
shE.文書~状態:~HTMLnav#she-document-state

文書を作成して初期化する:~HTMLlifecycle#initialise-the-document-object
読込ngを停止する:~HTMLlifecycle#nav-stop

~task~source:~WAPI#task-source
~task:~WAPI#concept-task
小taskを~queueする:~WAPI#queue-a-microtask
大域~taskを~queueする:~WAPI#queue-a-global-task
関連な大域~obj:~WAPI#concept-relevant-global

具現化されて:~HTMLrendering#being-rendered

	●用語（外部

実装定義:~INFRA#implementation-defined
文字列:~INFRA#string
~scalar値~文字列:~INFRA#scalar-value-string
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
~list:~INFRA#list
有順序~集合:~INFRA#ordered-set
	集合:~INFRA#ordered-set
~ASCII文字列:~INFRA#ascii-string
~ASCII小文字~化する:~INFRA#ascii-lowercase
文字:~INFRA#code-point
制御~文字:~INFRA#control
~JSON文字列を~Infra値に構文解析する:~INFRA#parse-a-json-string-to-an-infra-value
有順序~map:~INFRA#ordered-map
付加する:~INFRA#list-append
map.~key:~INFRA#map-key
map.~key群:~INFRA#map-getting-the-keys
set.付加する:~INFRA#set-append
空:~INFRA#list-is-empty
~size:~INFRA#list-size
拡張する:~INFRA#list-extend
~item:~INFRA#list-item
~listを昇順に~sortする:~INFRA#list-sort-in-ascending-order
未満の符号単位~列:~INFRA#code-unit-less-than
~byte列:~INFRA#byte-sequence
	~NEQ ε:~INFRA#map-exists
	~EACH:~INFRA#list-iterate
	~CONTINUE:~INFRA#iteration-continue
	~Assert:~INFRA#assert
	~IN:~INFRA#list-contain

~node文書:~DOM4#concept-node-document
doc.生成元:~DOM4#concept-document-origin
~shadowも含めた子孫:~DOM4#concept-shadow-including-descendant
~shadowも含めた~tree順序:~DOM4#concept-shadow-including-tree-order
根:~DOM4#concept-tree-root
子~text内容:~DOM4#concept-child-text-content

~URL:~URL1#concept-url
妥当な~URL文字列:~URL1#valid-url-string
文書~基底~URL:~HTMLurl#document-base-url
~URL構文解析する:~URL1#concept-url-parser
url.~scheme:~URL1#concept-url-scheme

~ABNF:~FETCH#abnf
~ok状態s:~FETCH#ok-status
~header~listから~MIME型を抽出する:~FETCH#concept-header-extract-mime-type
要請:~FETCH#concept-request
rs.状態s:~FETCH#concept-response-status
rs.~URL:~FETCH#concept-response-url
rs.~header~list:~FETCH#concept-response-header-list
rq.~URL:~FETCH#concept-request-url
rq.行先:~FETCH#concept-request-destination
rq.~mode:~FETCH#concept-request-mode
応答:~FETCH#concept-response
rq.資格証~mode:~FETCH#concept-request-credentials-mode
資格証:~FETCH#credentials
~HTTP_S~scheme:~FETCH#http-scheme
有構造~field値を取得する:~FETCH#concept-header-list-get-structured-header
~fetchする:~FETCH#concept-fetch
~header~listから値を取得して復号して分割する:~FETCH#concept-header-list-get-decode-split

~referrerにより起動された~naviな~prefetchを開始する:~PREFETCH#start-a-referrer-initiated-navigational-prefetch
	:#start-a-referrer-initiated-navigational-prefetch
~prefetch~record:~PREFETCH#prefetch-record
	:#prefetch-record
pfR.~source:~PREFETCH#prefetch-record-source
	:#prefetch-record-source
pfR.~URL:~PREFETCH#prefetch-record-url
	:#prefetch-record-url
pfR.匿名~化~施策:~PREFETCH#prefetch-record-anonymization-policy
	:#prefetch-record-anonymization-policy
pfR.~No-Vary-Search~hint:~PREFETCH#prefetch-record-no-vary-search-hint
	:#prefetch-record-nvs-hint
pfR.~referrer施策:~PREFETCH#prefetch-record-referrer-policy
	:#prefetch-record-referrer-policy
pfR.~tag群:~PREFETCH#prefetch-record-tags
	:#prefetch-record-tags
pfR.状態:~PREFETCH#prefetch-record-state
	:#prefetch-record-state
取消して破棄する:~PREFETCH#prefetch-record-cancel-and-discard
	:#prefetch-record-cancel-and-discard
doc.~prefetch~record群:~PREFETCH#document-prefetch-records
	:#document-prefetch-records
依然として投機されている:~PREFETCH#prefetch-record-still-being-speculated
	:#still-being-speculated

有構造~header:~STRUCTURED-FIELDS#structured-header
~sf~list:~STRUCTURED-FIELDS#list
~sf文字列:~STRUCTURED-FIELDS#string
~sf~token:~STRUCTURED-FIELDS#token

t.selector-list:~SELECTORS4#typedef-selector-list
要素に対し選択子を照合する:~SELECTORS4#match-a-selector-against-an-element
選択子として構文解析する:~SELECTORS4#parse-a-selector
	視野ng根:~SELECTORS4#scoping-root
選択子:~SELECTORS4#selector

飛ばされた内容:~CSSCONTAIN#skips-its-contents

閲覧~文脈の特能を設定しておく:~CSSOMVIEW#set-up-browsing-context-features

既定の~URL~search多様度:~HTTPnvs#name-data-model
~URL~search多様度:~HTTPnvs#name-data-model
下で等価:~HTTPnvs#name-comparing
~URL~search多様度を構文解析する:~HTTPnvs#parse-a-url-search-variance

	＠~URLPATTERN#parse-a-constructor-string
~URL~pattern:~URLPATTERN#url-pattern
~Infra値から~URL~patternを築く:~URLPATTERN#build-a-url-pattern-from-an-infra-value
~URL~patternを照合する:~URLPATTERN#url-pattern-match

信用に価し得る~URL:~SECURE-CONTEXT#potentially-trustworthy-url

~referrer施策:~REFERRER-POLICY#referrer-policy
既定の~referrer施策:~REFERRER-POLICY#default-referrer-policy

~CSP~list:~CSP3#csp-list
処置先:~CSP3#policy-disposition
指令~集合:~CSP3#policy-directive-set

~UTF-8復号する:~ENCODING#utf-8-decode

~consoleに警告を報告する:~CONSOLE#report-a-warning-to-the-console

~essence:~MIMESNIFF#mime-type-essence

~storage~key:~STORAGE#storage-key



●●trans_metadata
<p>
~THIS_PAGEは、
~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ Speculation rules</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>HTML — 投機的な読み込み</h1>
<p>Speculative loading</p>

	</hgroup>
</header>

<hr>

<main id="MAIN" hidden>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号
		</section>
		<section id="speculative-loading">
<h3 title="Speculative loading">7.6. 投機的な読込ng</h3>

<p>
投機的な読込ngは、
~navi動作を遂行する実施である
— ~naviを開始するに先立って，~prefetchするなど。
これは、
後続な~naviを速くする。
◎
Speculative loading is the practice of performing navigation actions, such as prefetching, ahead of navigation starting. This makes subsequent navigations faster.
</p>

<p>
開発者は、
`投機~規則~集合$を利用することにより，
投機的な読込nを起動できる。
~UAも，ある種の`実装定義$な局面
— ~URL~barの中へ打込んでいるときなど —
において投機的な読込nを遂行するかもしれない。
◎
Developers can initiate speculative loads by using speculation rules. User agents might also perform speculative loads in certain implementation-defined scenarios, such as typing into the address bar.
</p>

			<section id="speculation-rules">
<h4 title="Speculation rules">7.6.1. 投機~規則</h4>

<p>
開発者は、
`投機~規則~集合$により［
自身が有益になるものと予見する投機的な読込ng演算
］について~browserに指図する。
この集合は、
次に挙げるいずれか を介した~JSON文書として送達される：
◎
Speculation rules are how developers instruct the browser about speculative loading operations that the developer believes will be beneficial. They are delivered as JSON documents, via either:
</p>

<ul>
	<li>
~inlineな `script$e 要素のうち，
`type$a 属性が `speculationrules^l に設定されたもの。
◎
inline script elements with their type attribute set to "speculationrules"; or
</li>
	<li>
`Speculation-Rules$h ~HTTP応答~header内に指定された~URLから~fetchされる資源。
◎
resources fetched from a URL specified in the `Speculation-Rules` HTTP response header.
</li>
</ul>

<div id="example-speculation-rules-simple" class="example">
<p>
次の~JSON文書は、
`投機~規則~集合$に構文解析される
— それは、
~UAが`~referrerにより起動された~naviな~prefetchを開始する$ために欲されるいくつかの条件を指定する：
◎
The following JSON document is parsed into a speculation rule set specifying a number of desired conditions for the user agent to start a referrer-initiated navigational prefetch:
</p>

<pre class="lang-json">
{
  "prefetch": [
    {
      "urls": ["/chapters/5"]
    },
    {
      "eagerness": "moderate",
      "where": {
        "and": [
          { "href_matches": "/*" },
          { "not": { "selector_matches": ".no-prefetch" } }
        ]
      }
    }
  ]
}
</pre>
</div>

<p>
`投機~規則~集合$を表現している~JSON文書は、
`投機~規則~集合の著作~要件@
— ~AND ↓ —
を満たさなければナラナイ：
◎
A JSON document representing a speculation rule set must meet the following speculation rule set authoring requirements:
</p>
<ul>
	<li>
妥当な~JSONである
`JSON$r
◎
It must be valid JSON. [JSON]
</li>
	<li>
<p>
当の~JSONは ~AND↓ を満たす~JSON~objを表現している：
◎
The JSON must represent a JSON object,＼
</p>
		<ul>
			<li>
<p>
次に挙げるもの以外の~keyを伴わない
⇒＃
`tag^l,
`prefetch^l,
`prerender^l
◎
with at most three keys "tag", "prefetch" and "prerender".
</p>

<p class="note">注記：
この標準においては、
`prerender^l は，`構文解析-時点＠#note-speculation-rules-parse-prerender-as-prefetch$に任意選択で `prefetch^l へ変換される。
一部の実装は、
~prerender用には異なる挙動を
— `PRERENDERING-REVAMPED$r にて指定されとおりに —
実装するかもしれない。
◎
In this standard, "prerender" is optionally converted to "prefetch" at parse time. Some implementations might implement different behavior for prerender, as specified in Prerendering Revamped. [PRERENDERING-REVAMPED]
</p>
			</li>
			<li>
~key `tag^l を伴うならば、
対応する値は`投機~規則~tag$である
◎
The value corresponding to the "tag" key, if present, must be a speculation rule tag.
</li>
			<li>
~key［
`prefetch^l, `prerender^l
］いずれに対しても，それを伴うならば、
対応する値は`妥当な投機~規則$たちが成す配列である
◎
The values corresponding to the "prefetch" and "prerender" keys, if present, must be arrays of valid speculation rules.
</li>
		</ul>
	</li>
</ul>

<p>
`妥当な投機~規則@
は、
~AND↓ を満たす~JSON~objでなければナラナイ：
◎
A valid speculation rule is a JSON object that meets the following requirements:
</p>
<ul>
	<li>
<p>
次に挙げるもの以外の~keyを伴わない
⇒＃
`source^l,
`urls^l,
`where^l,
`relative_to^l,
`eagerness^l,
`referrer_policy^l,
`tag^l,
`requires^l,
`expects_no_vary_search^l,
`target_hint^l
◎
It must have at most the following keys: "source", "urls", "where", "relative_to", "eagerness", "referrer_policy", "tag", "requires", "expects_no_vary_search", or "target_hint".
</p>

<p class="note">注記：
この標準においては、
`target_hint^l は`無視される＠#note-speculation-rules-parse-target-hint$。
◎
In this standard, "target_hint" is ignored.
</p>
	</li>
	<li>
~key `source^l を伴うならば、
対応する値は［
`list^l, `document^l
］いずれかである
◎
The value corresponding to the "source" key, if present, must be either "list" or "document".
</li>
	<li>
~key `source^l に対応する値 ~EQ `list^l ならば、
次が満たされる
⇒
［
~key `urls^l を伴う
］~AND［
~key `where^l を伴わない
］
◎
If the value corresponding to the "source" key is "list", then the "urls" key must be present, and the "where" key must be absent.
</li>
	<li>
~key `source^l に対応する値 ~EQ `document^l ならば、
~key `urls^l を伴わない
◎
If the value corresponding to the "source" key is "document", then the "urls" key must be absent.
</li>
	<li>
~key［
`urls^l, `where^l 
］のうち，どちらかを伴わない
◎
The "urls" and "where" keys must not both be present.
</li>
	<li>
［
~key `source^l に対応する値 ~EQ `document^l
］~OR［
~key `where^l を伴う
］ならば、
~key `relative_to^l を伴わない
◎
If the value corresponding to the "source" key is "document" or the "where" key is present, then the "relative_to" key must be absent.
</li>
	<li>
~key `urls^l を伴うならば、
対応する値は`妥当な~URL文字列$たちが成す配列である
◎
The value corresponding to the "urls" key, if present, must be an array of valid URL strings.
</li>
	<li>
~key `where^l を伴うならば、
対応する値は`妥当な文書~規則~述部$である
◎
The value corresponding to the "where" key, if present, must be a valid document rule predicate.
</li>
	<li>
~key `relative_to^l を伴うならば、
対応する値は［
`ruleset^l, `document^l
］いずれかである
◎
The value corresponding to the "relative_to" key, if present, must be either "ruleset" or "document".
</li>
	<li>
~key `eagerness^l を伴うならば、
対応する値は`投機~規則~早急度$である
◎
The value corresponding to the "eagerness" key, if present, must be a speculation rule eagerness.
</li>
	<li>
~key `referrer_policy^l を伴うならば、
対応する値は`~referrer施策$である
◎
The value corresponding to the "referrer_policy" key, if present, must be a referrer policy.
</li>
	<li>
~key `tag^l を伴うならば、
対応する値は`投機~規則~tag$である
◎
The value corresponding to the "tag" key, if present, must be a speculation rule tag.
</li>
	<li>
~key `requires^l を伴うならば、
対応する値は`投機~規則~要件$たちが成す配列である
◎
The value corresponding to the "requires" key, if present, must be an array of speculation rule requirements.
</li>
	<li>
~key `expects_no_vary_search^l を伴うならば、
次の結果は`文字列$になる
⇒
`~URL~search多様度を構文解析する$( 当の~keyに対応する値 )
（すなわち、
当の値を `No-Vary-Search$h ~header値として構文解析する）
◎
The value corresponding to the "expects_no_vary_search" key, if present, must be a string that is parseable as a `No-Vary-Search` header value.
</li>
</ul>

<p>
`妥当な文書~規則~述部@
は、
~AND↓ を満たす~JSON~objでなければナラナイ：
◎
A valid document rule predicate is a JSON object that meets the following requirements:
</p>
<ul>
	<li>
次に挙げる~keyのうち，どれか一つだけを伴う
⇒＃
`and^l,
`or^l,
`not^l,
`href_matches^l ,
`selector_matches^l
◎
It must contain exactly one of the keys "and", "or", "not", "href_matches", or "selector_matches".
</li>
	<li>
［
前項に挙げたもの, `relative_to^l
］以外の~keyを伴わない
◎
It must not contain any keys apart from the above or "relative_to".
</li>
	<li>
~key `relative_to^l に対応する値が在るならば、
~key `href_matches^l に対応する値も在る
◎
If it contains the key "relative_to", then it must also contain the key "href_matches".
</li>
	<li>
~key `relative_to^l を伴うならば、
対応する値は［
`ruleset^l, `document^l
］いずれかである
◎
The value corresponding to the "relative_to" key, if present, must be either "ruleset" or "document".
</li>
	<li>
~key［
`and^l, `or^l
］いずれに対しても，それを伴うならば、
対応する値は`妥当な文書~規則~述部$たちが成す配列である
◎
The value corresponding to the "and" or "or" keys, if present, must be arrays of valid document rule predicates.
</li>
	<li>
~key `not^l を伴うならば、
対応する値は`妥当な文書~規則~述部$である。
◎
The value corresponding to the "not" key, if present, must be a valid document rule predicate.
</li>
	<li>
~key `href_matches^l を伴うならば、
対応する値は次に挙げるいずれかである
⇒＃
`妥当な~URL~pattern入力$／
`妥当な~URL~pattern入力$たちが成す配列
◎
The value corresponding to the "href_matches" key, if present, must be either a valid URL pattern input or an array of valid URL pattern inputs.
</li>
	<li>
~key `selector_matches^l を伴うならば、
対応する値は次に挙げるいずれかである
⇒＃
`selector-list$t に合致している`文字列$／
`selector-list$t に合致している`文字列$たちが成す配列
◎
The value corresponding to the "selector_matches" key, if present, must be either a string matching &lt;selector-list&gt; or an array of strings that match &lt;selector-list&gt;.
</li>
</ul>

<p>
`妥当な~URL~pattern入力@
は、
次に挙げるいずれかである：
◎
A valid URL pattern input is either:
</p>
<ul>
	<li>
<p>
次を満たす`~scalar値~文字列$である
⇒
成功裡に`~URL~pattern構築子~文字列として構文解析できる＠~URLPATTERN#parse-a-constructor-string$
◎
a scalar value string that can be successfully parsed as a URL pattern constructor string, or;
</p>

<p class="trans-note">【
参照された~algoは、
ほとんど（~protocol成分~以外）においては “失敗しない” 。
本当は、
“等価な `URLPatternInit$I を `URLPattern^I の構築子に渡したとするとき，例外を投出しない”
と解釈するべき？
】</p>
	</li>
	<li>
次を満たす~JSON~objである
⇒
［
各~keyは、
`URLPatternInit$I 辞書を成す いずれかの~memberの識別子に一致する
］~AND［
各~keyに対応する値は`~scalar値~文字列$である
］
◎
a JSON object whose keys are drawn from the members of the URLPatternInit dictionary and whose values are scalar value strings.
</li>
</ul>

				<section id="speculation-rules-data-model">
<h5 title="Data model">7.6.1.1. ~data~model</h5>

<p>
`投機~規則~集合@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A speculation rule set is a struct with the following items:
</p>
<ul>
	<li>
`~prefetch規則~群@srs
⇒
`投機~規則$たちが成す`~list$
— 初期~時は空とする。
◎
prefetch rules, a list of speculation rules, initially empty
</li>
</ul>

<p class="note">注記：
将来においては、
他の規則
— 例： ~prerender規則 —
もアリになる。
そのような まだ受容されていない拡張については、
`PRERENDERING-REVAMPED$r を見よ。
◎
In the future, other rules will be possible, e.g., prerender rules. See Prerendering Revamped for such not-yet-accepted extensions. [PRERENDERING-REVAMPED]
</p>

<p>
`投機~規則@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A speculation rule is a struct with the following items:
</p>
<ul>
	<li>
`~URL群@sr
⇒
`~URL$たちが成す`有順序~集合$
◎
URLs, an ordered set of URLs
</li>
	<li>
`述部@sr
⇒
~NULL ／ある`文書~規則~述部$
◎
predicate, a document rule predicate or null
</li>
	<li>
`早急度@sr
⇒
ある`投機~規則~早急度$
◎
eagerness, a speculation rule eagerness
</li>
	<li>
`~referrer施策@sr
⇒
ある`~referrer施策$
◎
referrer policy, a referrer policy
</li>
	<li>
`~tag群@sr
⇒
`投機~規則~tag$たちが成す`有順序~集合$
◎
tags, an ordered set of speculation rule tags
</li>
	<li>
`要件~群@sr
⇒
`投機~規則~要件$たちが成す`有順序~集合$
◎
requirements, an ordered set of speculation rule requirements
</li>
	<li>
`~No-Vary-Search~hint@sr
⇒
ある`~URL~search多様度$
◎
No-Vary-Search hint, a URL search variance
</li>
</ul>

<hr>

<p>
`文書~規則~述部@
は、
次に挙げるいずれかである
⇒＃
`文書~規則~論理積$／
`文書~規則~論理和$／
`文書~規則~否定$／
`文書~規則~URL~pattern述部$／
`文書~規則~選択子~述部$
◎
A document rule predicate is one of the following:
• a document rule conjunction;
• a document rule disjunction;
• a document rule negation;
• a document rule URL pattern predicate; or
• a document rule selector predicate.
</p>

<p>
`文書~規則~論理積@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A document rule conjunction is a struct with the following items:
</p>
<ul>
	<li>
`条項~群@drC
⇒
`文書~規則~述部$たちが成す`~list$
◎
clauses, a list of document rule predicates
</li>
</ul>

<p>
`文書~規則~論理和@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A document rule disjunction is a struct with the following items:
</p>
<ul>
	<li>
`条項~群@drD
⇒
`文書~規則~述部$たちが成す`~list$
◎
clauses, a list of document rule predicates
</li>
</ul>

<p>
`文書~規則~否定@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A document rule negation is a struct with the following items:
</p>
<ul>
	<li>
`条項@drN
⇒
ある`文書~規則~述部$
◎
clause, a document rule predicate
</li>
</ul>

<p>
`文書~規則~URL~pattern述部@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A document rule URL pattern predicate is a struct with the following items:
</p>
<ul>
	<li>
`~pattern群@
⇒
`~URL~pattern$たちが成す`~list$
◎
patterns, a list of URL patterns
</li>
</ul>

<p>
`文書~規則~選択子~述部@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A document rule selector predicate is a struct with the following items:
</p>
<ul>
	<li>
`選択子~群@
⇒
`選択子$たちが成す`~list$
◎
selectors, a list of selectors
</li>
</ul>

<hr>

<p>
`投機~規則~早急度@
は、
次に挙げるいずれかの`文字列$である
— 以下の記述における “当の候補” は、
所与の［
投機的な読込n候補
【投機的な読込nの対象になる~link】
］を意味する：
◎
A speculation rule eagerness is one of the following strings:
</p>

  <dl>
	<dt>
`immediate@l
【 “~~即時” 】
</dt>
	<dd>
開発者は、［
当の候補に結付けられた投機的な読込nは，ほぼ遂行するに価するものと見込まれる
］ものと予見している
— 加えて，［
読込nを完了するまで有意な `lead^en 時間が要求される
］ものと予期しているかもしれない。
~UAは、
通例的に［
当の候補を実用的になる限り早く動作化する
］ベキである
— 実用的か否かを裁定する際に考慮する~subjectは、［
利用者-選好, 機器~条件, 資源~制限s
］などに限るとする。
◎
The developer believes that performing the associated speculative loads is very likely to be worthwhile, and they might also expect that load to require significant lead time to complete. User agents should usually enact the speculative load candidate as soon as practical, subject only to considerations such as user preferences, device conditions, and resource limits.
</dd>

	<dt>
`eager@l
【 “~~早急” 】
</dt>
	<dd>
~UAは、［
利用者は，未来に当の候補の~URLへ~navigateし得る
］ことが少しでも示唆されたなら，当の候補を動作化するベキである。
一例として、
利用者が，ある~linkに対し［
そこへ向けて一瞬でも~cursorを移動した／
そこで一瞬でも~cursorを~hoverした／
それが表示域~内で他の~linkより~~目立つものであるとき，そこで~scrollすることを静止した
］とき。
作者は、
アリな限り多くの~naviをアリな限り早期に捕捉するよう追求している。
◎
User agents should enact the speculative load candidate on even a slight suggestion that the user may navigate to this URL in the future. For instance, the user might have moved the cursor toward a link or hovered it, even momentarily, or paused scrolling when the link is one of the more prominent ones in the viewport. The author is seeking to capture as many navigations as possible, as early as possible.
</dd>

	<dt>
`moderate@l
【 “~~中庸” 】
</dt>
	<dd>
~UAは、
利用者の挙動により［
利用者は，近い未来に当の候補の~URLへ~navigateし得る
］ことが示唆された場合には，当の候補を動作化するベキである。
一例として、
利用者は，ある~linkに対し［
それを表示域の中へ~scrollして，それを~clickする見込みが高そうな兆しを
— 例：そこに何秒か~cursorを移動することにより —
示した
］とき。
開発者は、
`eager$l と `conservative$l の間で~balanceを追求している。
◎
User agents should enact the candidate if user behavior suggests the user may navigate to this URL in the near future. For instance, the user might have scrolled a link into the viewport and shown signs of being likely to click it, e.g., by moving the cursor over it for some time. The developer is seeking a balance between "eager" and "conservative".
</dd>

	<dt>
`conservative@l
【 “~~保守的” 】
</dt>
	<dd>
~UAは、［
利用者は，ほぼ当の候補の~URLへ~navigateするものと見込まれる
］ときに限り，当の候補を動作化するベキである。
一例として，利用者が ある~linkとヤリトリし始めたとき。
開発者は、
投機的な読込ngの便益を成す一部を相応に少ない資源と引き換えに捕捉するよう追求している。
◎
User agents should enact the candidate only when the user is very likely to navigate to this URL at any moment. For instance, the user might have begun to interact with a link. The developer is seeking to capture some of the benefits of speculative loading with a fairly small tradeoff of resources.
</dd>
</dl>

<p>
所与の`投機~規則~早急度$ %A, %B に対し，
%A は %B
`以上に早急@
であるとは、［
上の~listにおいて %A は %B に後続して挙げられられたものではない
］ことをいう。
◎
A speculation rule eagerness A is less eager than another speculation rule eagerness B if A follows B in the above list.
◎
A speculation rule eagerness A is at least as eager as another speculation rule eagerness B if A is not less eager than B.
</p>

<p class="trans-note">【
原文には，この用語の否定を意味する用語も定義されているが、
この訳では利用しない（単に， “以上に早急でない” と記すことにする）。
】</p>
<hr>

<p>
`投機~規則~tag@
は、［
~NULL／
次を満たす`~ASCII文字列$
］である
⇒
それを成す各`文字$は範囲 { `0020^U 〜 `007E^U } に入る
【すなわち，`制御~文字$でない】
◎
A speculation rule tag is either an ASCII string whose code points are all in the range U+0020 to U+007E inclusive, or null.
</p>

<p class="note">注記：
符号位置~範囲に関するこの制約は、［
値を~HTTP~header内に~escape法や改変を伴わずに送信できる
］ことを確保する。
◎
This code point range restriction ensures the value can be sent in an HTTP header with no escaping or modification.
</p>

<hr>

<p>
`投機~規則~要件@
は、
文字列 `anonymous-client-ip-when-cross-origin^l である。
◎
A speculation rule requirement is the string "anonymous-client-ip-when-cross-origin".
</p>

<p class="note">注記：
将来においては、
アリな要件が もっと定義されるかもしれない。
◎
In the future, more possible requirements might be defined.
</p>

				</section>
				<section id="speculation-rules-parsing">
<h5 title="Parsing">7.6.1.2. 構文解析-法</h5>

<div class="note">
<p>注記：
投機的な読込ngは漸進的な増補なので、
この標準は，その構文解析の挙動において相応に保守的である。
特に，未知な~keyや妥当でない値は、
通例的に，構文解析を失敗させる
— 何もしない方が［
場合によっては，投機~規則を誤って解釈する
］よりも安全なので。
◎
Since speculative loading is a progressive enhancement, this standard is fairly conservative in its parsing behavior. In particular, unknown keys or invalid values usually cause parsing failure, since it is safer to do nothing than to possibly misinterpret a speculation rule.
</p>

<p>
それでも、
ある投機~規則に対する構文解析に失敗しても，他の投機~規則の処理は許容される。
投機~規則~集合の全体が破棄される事例は、
~top-levelの環境設定に誤りがある場合に限られる。
◎
That said, parsing failure for a single speculation rule still allows other speculation rules to be processed. It is only in the case of top-level misconfiguration that the entire speculation rule set is discarded.
</p>
</div>

<div class="algo">
<p>
`投機~規則~集合~文字列を構文解析する@
~algoは、
所与の
( `文字列$ %入力, `文書$ %文書, `~URL$ %基底~URL )
に対し：
◎
To parse a speculation rule set string given a string input, a Document document, and a URL baseURL:
</p>
<ol>
	<li>
%構文解析-済み ~LET `~JSON文字列を~Infra値に構文解析する$( %入力 )
◎
Let parsed be the result of parsing a JSON string to an Infra value given input.
</li>
	<li>
~IF［
%構文解析-済み は`有順序~map$でない
］
⇒
~THROW `TypeError$E
— 次を指示するような
⇒
“~top-levelの値は~JSON~objである必要がある”
◎
If parsed is not a map, then throw a TypeError indicating that the top-level value needs to be a JSON object.
</li>
	<li>
%結果 ~LET 新たな`投機~規則~集合$
◎
Let result be a new speculation rule set.
</li>
	<li>
%~tag ~LET %構文解析-済み[ `tag^l ] ~DF ~NULL
◎
Let tag be null.
</li>
	<li>
<p>
~IF［
%~tag ~NEQ ~NULL
］：
◎
If parsed["tag"] exists:
</p>
		<ol>
			<li>
~IF［
%~tag は`投機~規則~tag$でない
］
⇒
~THROW `TypeError$E
— 次を指示するような
⇒
当の投機~規則~tagは妥当でない
◎
If parsed["tag"] is not a speculation rule tag, then throw a TypeError indicating that the speculation rule tag is invalid.
◎
↑ Set tag to parsed["tag"].
</li>
		</ol>
	</li>
	<li>
%~prefetchとして扱う種別~群 ~LET « `prefetch^l »
◎
Let typesToTreatAsPrefetch be « "prefetch" ».
</li>
	<li>
<p>
任意選択で【！may】
⇒
%~prefetchとして扱う種別~群 に `prerender^l を`付加する$
◎
The user agent may append "prerender" to typesToTreatAsPrefetch.
</p>

<p class="note" id="note-speculation-rules-parse-prerender-as-prefetch">注記：
この仕様は，~prefetch法しか含まないので、
この段は，［
~prerenderするための要請を~prefetchするための要請として扱う
］ことを~UAに許容する。
~prerender法を実装する~UAは、
`PRERENDERING-REVAMPED$r 仕様に従って，
`prerender^l を~prerender要請として解釈することになる。
◎
Since this specification only includes prefetching, this allows user agents to treat requests for prerendering as requests for prefetching. User agents which implement prerendering, per the Prerendering Revamped specification, will instead interpret these as prerender requests. [PRERENDERING-REVAMPED]
</p>
	</li>
	<li>
<p>
%~prefetchとして扱う種別~群 を成す
~EACH( %種別 )
に対し：
◎
For each type of typesToTreatAsPrefetch:
</p>
		<ol>
			<li>
%規則~群 ~LET %構文解析-済み[ %種別 ]
◎
↓</li>
			<li>
<p>
~IF［
%規則~群 ~NEQ ε
］：
◎
If parsed[type] exists:
</p>
				<ol>
					<li>
<p>
~IF［
%規則~群 は`~list$である
］
⇒
%規則~群 を成す
~EACH( %規則 )
に対し：
◎
If parsed[type] is a list, then for each rule of parsed[type]:
</p>
						<ol>
							<li>
%規則 ~LET `投機~規則を構文解析する$( %規則, %~tag, %文書, %基底~URL )
◎
Let rule be the result of parsing a speculation rule given rule, tag, document, and baseURL.
</li>
							<li>
~IF［
%規則 ~NEQ ~NULL
］
⇒
%結果 の`~prefetch規則~群$srsに %規則 を`付加する$
◎
If rule is null, then continue.
◎
Append rule to result's prefetch rules.
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “%種別 用の規則~listは~JSON配列にする必要がある” )
◎
Otherwise, the user agent may report a warning to the console indicating that the rules list for type needs to be a JSON array.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`投機~規則を構文解析する@
~algoは、
所与の
( `有順序~map$ %入力, `投機~規則~tag$ %規則~集合~levelの~tag, `文書$ %文書, `~URL$ %基底~URL )
に対し：
◎
To parse a speculation rule given a map input, a speculation rule tag rulesetLevelTag, a Document document, and a URL baseURL:
</p>
<ol>
	<li>
<p>
~IF［
%入力 は`有順序~map$でない
］：
◎
If input is not a map:
</p>
		<ol>
			<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “当の規則は~JSON~objにする必要がある” )
◎
The user agent may report a warning to the console indicating that the rule needs to be a JSON object.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li>
<p>
%入力 の`~key群$mapを成す
~EACH( %~key )
に対し：
◎
If input has any key＼
</p>
		<ol>
			<li>
~IF［
%~key ~IN {
`source^l,
`urls^l,
`where^l,
`relative_to^l,
`eagerness^l,
`referrer_policy^l,
`tag^l,
`requires^l,
`expects_no_vary_search^l,
`target_hint^l
}
］
⇒
~CONTINUE
◎
other than "source", "urls", "where", "relative_to", "eagerness", "referrer_policy", "tag", "requires", "expects_no_vary_search", or "target_hint":
</li>
			<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “当の規則は認識されない~keyを有する” )
◎
The user agent may report a warning to the console indicating that the rule has unrecognized keys.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>

<p class="note" id="note-speculation-rules-parse-target-hint">注記：
`target_hint^l は、
この標準においては処理~modelに対する影響iは何も無いが，
`PRERENDERING-REVAMPED$r の実装においては~prerender用の規則~用に利用され得る。
なので、
そのような規則の構文解析に失敗するよう~UAに要求することは，反生産的になる。
◎
"target_hint" has no impact on the processing model in this standard. However, implementations of Prerendering Revamped can use it for prerendering rules, and so requiring user agents to fail parsing such rules would be counterproductive. [PRERENDERING-REVAMPED].
</p>
			</li>
			<li>
%~source ~LET %入力[ `source^l ]
◎
Let source be null.
◎
If input["source"] exists, then set source to input["source"].
</li>
			<li>
<p>
~IF［
%~source ~EQ ε
］：
</p>
				<ol>
					<li>
~IF［
%入力[ `urls^l ] ~NEQ ε
］~AND［
%入力[ `where^l ] ~EQ ε
］
⇒
%~source ~SET `list^l
</li>
					<li>
~ELIF［
%入力[ `urls^l ] ~EQ ε
］~AND［
%入力[ `where^l ] ~NEQ ε
］
⇒
%~source ~SET `document^l
</li>
				</ol>
◎
Otherwise, if input["urls"] exists and input["where"] does not exist, then set source to "list".
◎
Otherwise, if input["where"] exists and input["urls"] does not exist, then set source to "document".
</li>
			<li>
<p>
~IF［
%~source ~NIN { `list^l, `document^l }
］：
◎
If source is neither "list" nor "document":
</p>
		<ol>
			<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “~sourceを推定できないか妥当でない~sourceが指定された” )
◎
The user agent may report a warning to the console indicating that a source could not be inferred or an invalid source was specified.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li>
%~URL群 ~LET 新たな`~list$
◎
Let urls be an empty list.
</li>
	<li>
%述部 ~LET ~NULL
◎
Let predicate be null.
</li>
	<li>
<p>
~IF［
%~source ~EQ `list^l
］：
◎
If source is "list":
</p>
		<ol>
			<li>
<p>
~IF［
%入力[ `where^l ] ~NEQ ε
］：
◎
If input["where"] exists:
</p>
				<ol>
					<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “この規則~用には競合している~sourceたちが在る” )
◎
The user agent may report a warning to the console indicating that there were conflicting sources for this rule.
</li>
					<li>
~RET ~NULL
◎
Return null.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%入力[ `relative_to^l ] ~NEQ ε
］：
◎
If input["relative_to"] exists:
</p>
				<ol>
					<li>
<p>
~IF［
%入力[ `relative_to^l ] ~NIN { `ruleset^l, `document^l }
］：
◎
If input["relative_to"] is neither "ruleset" nor "document":
</p>

						<ol>
							<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “`relative-to^c に給された値は妥当でない” )
◎
The user agent may report a warning to the console indicating that the supplied relative-to value was invalid.
</li>
							<li>
~RET ~NULL
◎
Return null.
</li>
						</ol>
					</li>
					<li>
~IF［
%入力[ `relative_to^l ] ~EQ `document^l
］
⇒
%基底~URL ~SET %文書 の`文書~基底~URL$
◎
If input["relative_to"] is "document", then set baseURL to document's document base URL.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%入力[ `urls^l ] は`~list$でない
］：
◎
If input["urls"] does not exist or is not a list:
</p>
				<ol>
					<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “給された~URL~listは妥当でない” )
◎
The user agent may report a warning to the console indicating that the supplied URL list was invalid.
</li>
					<li>
~RET ~NULL
◎
Return null.
</li>
				</ol>
			</li>
			<li>
<p>
%入力[ `urls^l ] を成す
~EACH( %~URL文字列 )
に対し：
◎
For each urlString of input["urls"]:
</p>
				<ol>
					<li>
<p>
~IF［
%~URL文字列 は文字列でない
］：
◎
If urlString is not a string:
</p>

						<ol>
							<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “給された~URLは文字列でなければならない” )
◎
The user agent may report a warning to the console indicating that the supplied URL must be a string.
</li>
							<li>
~RET ~NULL
◎
Return null.
</li>
						</ol>
					</li>
					<li>
%構文解析-済み~URL ~LET `~URL構文解析する$( %~URL文字列, %基底~URL )
◎
Let parsedURL be the result of URL parsing urlString with baseURL.
</li>
					<li>
<p>
~IF［
%構文解析-済み~URL ~EQ `失敗^i
］~OR［
%構文解析-済み~URL の`~scheme$urlは`~HTTP_S~scheme$でない
］：
◎
If parsedURL is failure, or parsedURL's scheme is not an HTTP(S) scheme:
</p>

						<ol>
							<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “給された~URL文字列は構文解析-不能である” )
◎
The user agent may report a warning to the console indicating that the supplied URL string was unparseable.
</li>
							<li>
~CONTINUE
◎
Continue.
</li>
						</ol>
					</li>
					<li>
%~URL群 に %構文解析-済み~URL を`付加する$
◎
Append parsedURL to urls.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~source ~EQ `document^l
］：
◎
If source is "document":
</p>
		<ol>
			<li>
<p>
~IF［
%入力[ `urls^l ] ~NEQ ε
~OR
%入力[ `relative_to^l ] ~NEQ ε
］：
◎
If input["urls"] or input["relative_to"] exists:
</p>
				<ol>
					<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “この規則~用には競合している~sourceたちが在る” )
◎
The user agent may report a warning to the console indicating that there were conflicting sources for this rule.
</li>
					<li>
~RET ~NULL
◎
Return null.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%入力[ `where^l ] ~EQ ε
］
⇒
%述部 ~SET 新たな`文書~規則~論理積$
— その
⇒＃
`条項~群$drC ~SET 新たな`~list$
◎
If input["where"] does not exist, then set predicate to a document rule conjunction whose clauses is an empty list.
</p>

<p class="note">注記：
そのような述部は、
すべての~linkに合致することになる。
◎
Such a predicate will match all links.
</p>
			</li>
			<li>
~ELSE
⇒
%述部 ~SET `文書~規則~述部を構文解析する$( %入力[ `where^l ], %文書, %基底~URL )
◎
Otherwise, set predicate to the result of parsing a document rule predicate given input["where"], document, and baseURL.
</li>
			<li>
~IF［
%述部 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If predicate is null, then return null.
</li>
		</ol>
	</li>
	<li>
%早急度 ~LET %~source に応じて
⇒＃
`list^l ならば `immediate$l ／
`document^l ならば【！~ELSE_ 】 `conservative$l
◎
Let eagerness be "immediate" if source is "list"; otherwise, "conservative".
</li>
	<li>
%早急度 ~SET %入力[ `eagerness^l ] ~DF %早急度
◎
↓</li>
	<li>
<p>
~IF［
%早急度 は`投機~規則~早急度$でない
］：
</p>
		<ol>
			<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “早急度は妥当でない” )
</li>
			<li>
~RET ~NULL
</li>
		</ol>
◎
If input["eagerness"] exists:
• If input["eagerness"] is not a speculation rule eagerness:
•• The user agent may report a warning to the console indicating that the eagerness was invalid.
•• Return null.
• Set eagerness to input["eagerness"].
</li>
	<li>
%~referrer施策 ~LET %入力[ `referrer_policy^l ] ~DF 空~文字列
◎
Let referrerPolicy be the empty string.
◎
↓</li>
	<li>
<p>
~IF［
%~referrer施策 は`~referrer施策$でない
］：
</p>
		<ol>
			<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “~referrer施策は妥当でない” )
</li>
			<li>
~RET ~NULL
</li>
		</ol>
◎
If input["referrer_policy"] exists:
• If input["referrer_policy"] is not a referrer policy:
•• The user agent may report a warning to the console indicating that the referrer policy was invalid.
•• Return null.
• Set referrerPolicy to input["referrer_policy"].
</li>
	<li>
%~tag群 ~LET 新たな`有順序~集合$
◎
Let tags be an empty ordered set.
</li>
	<li>
~IF［
%規則~集合~levelの~tag ~NEQ ~NULL
］
⇒
%~tag群 に %規則~集合~levelの~tag を`付加する$set
◎
If rulesetLevelTag is not null, then append rulesetLevelTag to tags.
</li>
	<li>
%~tag ~LET %入力[ `tag^l ] ~DF ~NULL
◎
↓</li>
	<li>
<p>
~IF［
%~tag は`投機~規則~tag$でない
］：
</p>
		<ol>
			<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “~tagは妥当でない” )
</li>
			<li>
~RET ~NULL
</li>
		</ol>
◎
If input["tag"] exists:
• If input["tag"] is not a speculation rule tag:
•• The user agent may report a warning to the console indicating that the tag was invalid.
•• Return null.
• Append input["tag"] to tags.
◎
If tags is empty, then append null to tags.
</li>
	<li>
%~tag群 に %~tag を`付加する$set
◎
↑</li>
	<li>
~Assert：
%~tag群 の`~size$ ~IN { 1, 2 }
◎
Assert: tags's size is either 1 or 2.
</li>
	<li>
%要件~群 ~LET 新たな`有順序~集合$
◎
Let requirements be an empty ordered set.
</li>
	<li>
<p>
~IF［
%入力[ `requires^l ] ~NEQ ε
］：
◎
If input["requires"] exists:
</p>
		<ol>
			<li>
<p>
~IF［
%入力[ `requires^l ] は`~list$でない
］：
◎
If input["requires"] is not a list:
</p>
				<ol>
					<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “要件は解されなかった” )
◎
The user agent may report a warning to the console indicating that the requirements were not understood.
</li>
					<li>
~RET ~NULL
◎
Return null.
</li>
				</ol>
			</li>
			<li>
<p>
%入力[ `requires^l ] を成す
~EACH( %要件 )
に対し：
◎
For each requirement of input["requires"]:
</p>
				<ol>
					<li>
<p>
~IF［
%要件 は`投機~規則~要件$でない
］：
◎
If requirement is not a speculation rule requirement:
</p>
						<ol>
							<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “要件は解されなかった” )
◎
The user agent may report a warning to the console indicating that the requirement was not understood.
</li>
							<li>
~RET ~NULL
◎
Return null.
</li>
						</ol>
					</li>
					<li>
%要件~群 に %要件 を`付加する$set
◎
Append requirement to requirements.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%~No-Vary-Search~hint ~LET `既定の~URL~search多様度$
◎
Let noVarySearchHint be the default URL search variance.
</li>
	<li>
<p>
~IF［
%入力[ `expects_no_vary_search^l ] ~NEQ ε
］：
◎
If input["expects_no_vary_search"] exists:
</p>
		<ol>
			<li>
<p>
~IF［
%入力[ `expects_no_vary_search^l ] は`文字列$でない
］：
◎
If input["expects_no_vary_search"] is not a string:
</p>
				<ol>
					<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “`No-Vary-Search$h ~hintは妥当でない” )
◎
The user agent may report a warning to the console indicating that the `No-Vary-Search` hint was invalid.
</li>
					<li>
~RET ~NULL
◎
Return null.
</li>
				</ol>
			</li>
			<li>
%~No-Vary-Search~hint ~SET `~URL~search多様度を構文解析する$( %入力[ `expects_no_vary_search^l ] )
◎
Set noVarySearchHint to the result of parsing a URL search variance given input["expects_no_vary_search"].
</li>
		</ol>
	</li>
	<li>
~RET 新たな`投機~規則$
— その
⇒＃
`~URL群$sr ~SET %~URL群,
`述部$sr ~SET %述部,
`早急度$sr ~SET %早急度,
`~referrer施策$sr ~SET %~referrer施策,
`~tag群$sr ~SET %~tag群,
`要件~群$sr ~SET %要件~群,
`~No-Vary-Search~hint$sr ~SET %~No-Vary-Search~hint
◎
Return a speculation rule with:
• URLs
•• urls
• predicate
•• predicate
• eagerness
•• eagerness
• referrer policy
•• referrerPolicy
• tags
•• tags
• requirements
•• requirements
• No-Vary-Search hint
•• noVarySearchHint
</li>
</ol>
</div>

<div class="algo">
<p>
`文書~規則~述部を構文解析する@
~algoは、
所与の
( 値 %入力, `文書$ %文書, `~URL$ %基底~URL )
に対し：
◎
To parse a document rule predicate given a value input, a Document document, and a URL baseURL:
</p>
<ol>
	<li>
<p>
~IF［
%入力 は`有順序~map$でない
］：
◎
If input is not a map:
</p>
		<ol>
			<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “文書~規則~述部は妥当でない” )
◎
The user agent may report a warning to the console indicating that the document rule predicate was invalid.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li>
%述部~種別 ~LET ε
◎
↓</li>
	<li>
<p>
« `and^l, `or^l, `not^l, `href_matches^l, `selector_matches^l »
を成す
~EACH( %~key )
に対し：
</p>
		<ol>
			<li>
~IF［
%入力[ %~key ] ~EQ ε
］
⇒
~CONTINUE
</li>
			<li>
~IF［
%述部~種別 ~NEQ ε
］
⇒＃
%述部~種別 ~SET ε；
~BREAK
</li>
			<li>
%述部~種別 ~SET %入力[ %~key ]
</li>
		</ol>
◎
↓</li>
	<li>
<p>
~IF［
%述部~種別 ~EQ ε
］：
</p>
		<ol>
			<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “文書~規則~述部は空であるか多義的である” )
</li>
			<li>
~RET ~NULL
</li>
		</ol>
◎
If input does not contain exactly one of "and", "or", "not", "href_matches", or "selector_matches":
• The user agent may report a warning to the console indicating that the document rule predicate was empty or ambiguous.
• Return null.
◎
↑ Let predicateType be the single key found in the previous step.
</li>
	<li>
<p>
%入力 の`~key群$mapを成す
~EACH( %~key )
に対し：
</p>
		<ol>
			<li>
~IF［
%~key ~EQ %述部~種別
］
⇒
~CONTINUE
</li>
			<li>
~IF［
%~key ~EQ `relative_to^l
］~AND［
%述部~種別 ~EQ `href_matches^l
］
⇒
~CONTINUE
</li>
			<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “文書~規則~述部には期待されない余計な~optionが有る” )
</li>
			<li>
~RET ~NULL
</li>
		</ol>
<p class="trans-note">【
この訳では、
以下の各所における検査を この段の中へ集約することにする。
】</p>
	</li>
	<li>
<p>
~IF［
%述部~種別 ~IN { `and^l, `or^l }
］：
◎
If predicateType is "and" or "or":
◎
• ↑↑ If input has any key other than predicateType:
•• The user agent may report a warning to the console indicating that the document rule predicate had unexpected extra options.
•• Return null.
</p>
		<ol>
			<li>
<p>
~IF［
%入力[ %述部~種別 ] は`~list$でない
］：
◎
If input[predicateType] is not a list:
</p>
				<ol>
					<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “文書~規則~述部には妥当でない条項~listが有る” )
◎
The user agent may report a warning to the console indicating that the document rule predicate had an invalid clause list.
</li>
					<li>
~RET ~NULL
◎
Return null.
</li>
				</ol>
			</li>
			<li>
%条項~群 ~LET 新たな`~list$
◎
Let clauses be an empty list.
</li>
			<li>
<p>
%入力[ %述部~種別 ] を成す
~EACH( %生の条項 )
に対し：
◎
For each rawClause of input[predicateType]:
</p>
				<ol>
					<li>
%条項 ~LET `文書~規則~述部を構文解析する$( %生の条項, %文書, %基底~URL )
◎
Let clause be the result of parsing a document rule predicate given rawClause, document, and baseURL.
</li>
					<li>
~IF［
%条項 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If clause is null, then return null.
</li>
					<li>
%条項~群 に %条項 を`付加する$
◎
Append clause to clauses.
</li>
				</ol>
			</li>
			<li>
<p>
%述部~種別 に応じて：
</p>
				<ul class="switch">
					<li>
`and^l
⇒
~RET 新たな`文書~規則~論理積$
— その
⇒＃
`条項~群$drC ~SET %条項~群
</li>
					<li>
`or^l
⇒
~RET 新たな`文書~規則~論理和$
— その
⇒＃
`条項~群$drD ~SET %条項~群
</li>
				</ul>
◎
If predicateType is "and", then return a document rule conjunction whose clauses is clauses.
◎
Return a document rule disjunction whose clauses is clauses.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%述部~種別 ~EQ `not^l
］：
◎
If predicateType is "not":
• ↑↑ If input has any key other than "not":
•• The user agent may report a warning to the console indicating that the document rule predicate had unexpected extra options.
•• Return null.
</p>
		<ol>
			<li>
%条項 ~LET `文書~規則~述部を構文解析する$( %入力[ %述部~種別 ], %文書, %基底~URL )
◎
Let clause be the result of parsing a document rule predicate given input[predicateType], document, and baseURL.
</li>
			<li>
~IF［
%条項 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If clause is null, then return null.
</li>
			<li>
~RET 新たな`文書~規則~否定$
— その
⇒＃
`条項$drN ~SET %条項
◎
Return a document rule negation whose clause is clause.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%述部~種別 ~EQ `href_matches^l
］：
◎
If predicateType is "href_matches":
• ↑↑ If input has any key other than "href_matches" or "relative_to":
•• The user agent may report a warning to the console indicating that the document rule predicate had unexpected extra options.
•• Return null.
</p>
		<ol>
			<li>
<p>
~IF［
%入力[ `relative_to^l ] ~NEQ ε
］：
◎
If input["relative_to"] exists:
</p>
				<ol>
					<li>
<p>
~IF［
%入力[ `relative_to^l ] ~NIN { `ruleset^l, `document^l }
］：
◎
If input["relative_to"] is neither "ruleset" nor "document":
</p>

						<ol>
							<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “給された `relative-to^c 値は妥当でない” )
◎
The user agent may report a warning to the console indicating that the supplied relative-to value was invalid.
</li>
							<li>
~RET ~NULL
◎
Return null.
</li>
						</ol>
					</li>
					<li>
~IF［
%入力[ `relative_to^l ] ~EQ `document^l
］
⇒
%基底~URL ~SET %文書 の`文書~基底~URL$
◎
If input["relative_to"] is "document", then set baseURL to document's document base URL.
</li>
				</ol>
			</li>
			<li>
%生の~pattern群 ~LET %入力[ `href_matches^l ]
◎
Let rawPatterns be input["href_matches"].
</li>
			<li>
~IF［
%生の~pattern群 は`~list$でない
］
⇒
%生の~pattern群 ~SET « %生の~pattern群 »
◎
If rawPatterns is not a list, then set rawPatterns to « rawPatterns ».
</li>
			<li>
%~pattern群 ~LET 新たな`~list$
◎
Let patterns be an empty list.
</li>
			<li>
<p>
%生の~pattern群 を成す
~EACH( %生の~pattern )
に対し：
◎
For each rawPattern of rawPatterns:
</p>
				<ol>
					<li>
<p>
%~pattern ~LET `~Infra値から~URL~patternを築く$( %生の~pattern, %基底~URL )
</p>

<p>
例外が投出された場合，~catchして
⇒
%~pattern ~SET ~NULL
</p>
◎
Let pattern be the result of building a URL pattern from an Infra value given rawPattern and baseURL. If this step throws and exception, catch the exception and set pattern to null.
</li>
					<li>
<p>
~IF［
%~pattern ~EQ ~NULL
］：
◎
If pattern is null:
</p>
						<ol>
							<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “給された~URL~patternは妥当でない” )
◎
The user agent may report a warning to the console indicating that the supplied URL pattern was invalid.
</li>
							<li>
~RET ~NULL
◎
Return null.
</li>
						</ol>
					</li>
					<li>
%~pattern群 に %~pattern を`付加する$
◎
Append pattern to patterns.
</li>
				</ol>
			</li>
			<li>
~RET 新たな`文書~規則~URL~pattern述部$
— その
⇒＃
`~pattern群$ ~SET %~pattern群
◎
Return a document rule URL pattern predicate whose patterns is patterns.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%述部~種別 ~EQ `selector_matches^l
］：
◎
If predicateType is "selector_matches":
• ↑↑ If input has any key other than "selector_matches":
•• The user agent may report a warning to the console indicating that the document rule predicate had unexpected extra options.
•• Return null.
</p>
		<ol>
			<li>
%生の選択子~群 ~LET %入力[ `selector_matches^l ]
◎
Let rawSelectors be input["selector_matches"].
</li>
			<li>
~IF［
%生の選択子~群 は`~list$でない
］
⇒
%生の選択子~群 ~SET « %生の選択子~群 »
◎
If rawSelectors is not a list, then set rawSelectors to « rawSelectors ».
</li>
			<li>
%選択子~群 ~LET 新たな`~list$
◎
Let selectors be an empty list.
</li>
			<li>
<p>
%生の選択子~群 を成す
~EACH( %生の選択子 )
に対し：
◎
For each rawSelector of rawSelectors:
</p>
				<ol>
					<li>
%構文解析-済み選択子~list ~LET `失敗^i
◎
Let parsedSelectorList be failure.
</li>
					<li>
~IF［
%生の選択子 は文字列である
］
⇒
%構文解析-済み選択子~list ~SET `選択子として構文解析する$( %生の選択子 )
◎
If rawSelector is a string, then set parsedSelectorList to the result of parsing a selector given rawSelector.
</li>
					<li>
<p>
~IF［
%構文解析-済み選択子~list ~EQ `失敗^i
］：
◎
If parsedSelectorList is failure:
</p>

						<ol>
							<li>
任意選択で【！may】
⇒
`~consoleに警告を報告する$( “給された選択子~listは妥当でない” )
◎
The user agent may report a warning to the console indicating that the supplied selector list was invalid.
</li>
							<li>
~RET ~NULL
◎
Return null.
</li>
						</ol>
					</li>
					<li>
%構文解析-済み選択子~list を成す
~EACH( %選択子 )
に対し
⇒
%選択子~群 に %選択子 を`付加する$
◎
For each selector of parsedSelectorList, append selector to selectors.
</li>
				</ol>
			</li>
			<li>
~RET 新たな`文書~規則~選択子~述部$
— その
⇒＃
`選択子~群$ ~SET %選択子~群
◎
Return a document rule selector predicate whose selectors is selectors.
</li>
		</ol>
	</li>
	<li>
~Assert：
この段に達することは決してない。
◎
Assert: this step is never reached, as one of the previous branches was taken.
</li>
</ol>
</div>

				</section>
				<section id="speculation-rules-processing-model">
<h5 title="Processing model">7.6.1.3. 処理~model</h5>

<p>
`投機的な読込nの候補@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A speculative load candidate is a struct with the following items:
</p>
<ul>
	<li>
`~URL@slC
⇒
ある`~URL$
◎
URL, a URL
</li>
	<li>
`~No-Vary-Search~hint@slC
⇒
ある`~URL~search多様度$
◎
No-Vary-Search hint, a URL search variance
</li>
	<li>
`早急度@slC
⇒
ある`投機~規則~早急度$
◎
eagerness, a speculation rule eagerness
</li>
	<li>
`~referrer施策@slC
⇒
ある`~referrer施策$
◎
referrer policy, a referrer policy
</li>
	<li>
`~tag群@slC
⇒
`投機~規則~tag$たちが成す`有順序~集合$
◎
tags, an ordered set of speculation rule tags
</li>
</ul>

<p>
`~prefetch候補@
は、
次に挙げる追加的な`~item$sctを伴う`投機的な読込nの候補$である：
◎
A prefetch candidate is a speculative load candidate with the following additional item:
</p>
<ul>
	<li>
`匿名~化~施策@
⇒
ある`~prefetch~IP匿名~化~施策$
◎
anonymization policy, a prefetch IP anonymization policy
</li>
</ul>

<p>
`~prefetch~IP匿名~化~施策@
は［
~NULL／`非同一-生成元~prefetch~IP匿名~化~施策$
］である。
◎
A prefetch IP anonymization policy is either null or a cross-origin prefetch IP anonymization policy.
</p>

<div>
<p>
`非同一-生成元~prefetch~IP匿名~化~施策@
は、
次に挙げる`~item$sctを伴う`構造体$である：
</p>
<ul>
	<li>
`生成元@copiap
⇒
ある`生成元$
</li>
</ul>
◎
A cross-origin prefetch IP anonymization policy is a struct whose single item is its origin, an origin.
</div>

<hr>

<div>
<p>
所与の
( `投機的な読込nの候補$ %候補~A, `投機的な読込nの候補$ %候補~B )
が
`互いに冗長@
であるとは、
~AND↓ が満たされることをいう：
</p>
<ol>
	<li>
( %候補~A の`~No-Vary-Search~hint$slC, %候補~B の`~No-Vary-Search~hint$slC )
は等しい
【この同等性が，どう定義されるか はっきりしない。】
</li>
	<li>
( %候補~A の`~URL$slC, %候補~B の`~URL$slC ) は
`~URL~search多様度$ %候補~A の`~No-Vary-Search~hint$slC の`下で等価$である
</li>
</ol>
◎
A speculative load candidate candidateA is redundant with another speculative load candidate candidateB if the following steps return true:
• If candidateA's No-Vary-Search hint is not equal to candidateB's No-Vary-Search hint, then return false.
• If candidateA's URL is not equivalent modulo search variance to candidateB's URL given candidateA's No-Vary-Search hint, then return false.
• Return true.
</div>

<div class="note" id="note-sl-candidate-redundant-with-nvs-strictness">
<p>注記：
`~No-Vary-Search~hint$slCも等価であるよう要求することは、
いくぶん厳密である。
それは、
一部の［
理論的には合致しているものと扱える事例
］を，そのように扱わないことを意味する。
したがって，冗長な投機的な読込nが起こることもある。
◎
The requirement that the No-Vary-Search hints be equivalent is somewhat strict. It means that some cases which could theoretically be treated as matching, are not treated as such. Thus, redundant speculative loads could happen.
</p>

<p>
しかしながら、
より~~寛容な照合を許容すると，
この検査は もはや同値~関係にならなくなり、
そのような合致-を生産することは、
【`~cache~key＠~HTTPcache#cache-key$として】より単純な正規化された~URL~keyを利用する代わりに，全部的な比較を行う実装~策を要求することになる。
このことは、
`NOVARYSEARCH$r `§ 6＠~HTTPnvs#section-6$ 【§ 7？】内の［
~server運用者~向けの最善な実施
］および［
~~付随する~HTTP~cache実装~注記
］に倣う。
◎
However, allowing more lenient matching makes the check no longer an equivalence relation, and producing such matches would require an implementation strategy that does a full comparison, instead of a simpler one using normalized URL keys. This is in line with the best practices for server operators, and attendant HTTP cache implementation notes, in No Vary Search § 6 Comparing.
</p>

<p>
実施においては、
これが冗長な投機的な読込nの原因になるものとは予期されない
— ［
~server運用者,
対応している投機~規則を書いている~web開発者
］は、
最善な実施に従って，静的な［
`No-Vary-Search$h ~header値／投機~規則~hint
］を利用することになるので。
◎
In practice, we do not expect this to cause redundant speculative loads, since server operators and the corresponding speculation rules-writing web developers will follow best practices and use static `No-Vary-Search` header values/speculation rule hints.
</p>
</div>

<div id="example-sl-candidate-reundant-with-nvs-strictness" class="example">
<p>
次に挙げる`投機的な読込nの候補$
— %A, %B, %C —
を考える：
◎
Consider three speculative load candidates:
</p>
<ol>
	<li>
%A は次を有する
⇒＃
`~URL$slC として `https://example.com?a=1&amp;b=1^c,
`~No-Vary-Search~hint$slCとして `params=("a")^c を構文解析した結果
◎
A has a URL of https://example.com?a=1&amp;b=1 and a No-Vary-Search hint parsed from params=("a").
</li>
	<li>
%B は次を有する
⇒＃
`~URL$slC として `https://example.com?a=2&amp;b=1^c,
`~No-Vary-Search~hint$slCとして `params=("b")^c を構文解析した結果
◎
B has a URL of https://example.com?a=2&amp;b=1 and a No-Vary-Search hint parsed from params=("b").
</li>
	<li>
%C は次を有する
⇒＃
`~URL$slC として `https://example.com?a=2&amp;b=2^c,
`~No-Vary-Search~hint$slCとして `params=("a")^c を構文解析した結果
◎
C has a URL of https://example.com?a=2&amp;b=2 and a No-Vary-Search hint parsed from params=("a").
</li>
</ol>

<p>
`互いに冗長$を成す現在の定義では、
これらの候補は，どれも互いに冗長でない
— これら各`投機~規則~集合$は、
別々な投機的な読込nを生じさせ得る。
◎
With the current definition of redundant with, none of these candidates are redundant with each other. A speculation rule set which contained all three could cause three separate speculative loads.
</p>

<p>
等価な`~No-Vary-Search~hint$slCを要求しない定義では、
( %A, %B ) は合致する
（ %A の`~No-Vary-Search~hint$slCを利用する下で）,
( %B, %C ) は合致する
（ %B の`~No-Vary-Search~hint$slCを利用する下で）
と見なすが，
( %A, %C ) は合致しないものと見なすので、
推移的でない
— したがって，同値~関係にならない。
◎
A definition which did not require equivalent No-Vary-Search hints could consider A and B to match (using A's No-Vary-Search hint), and B and C to match (using B's No-Vary-Search hint). But it could not consider A and C to match, so it would not be transitive, and thus not an equivalence relation.
</p>
</div>

<hr>

<p>
各`文書$は、
次に挙げるものを有する：
◎
↓</p>
<ul>
	<li>
`投機~規則~集合~群@doc
⇒
`投機~規則~集合$たちが成す`~list$
— 初期~時は空とする。
◎
Every Document has speculation rule sets, a list of speculation rule sets, initially empty.
</li>
	<li>
`~queueされた投機的な読込n小taskを考慮するか@
⇒
ある真偽値
— 初期~時は ~F とする。
◎
Every Document has a consider speculative loads microtask queued, a boolean, initially false.
</li>
</ul>

<div class="algo">
<p>
`投機的な読込nを考慮する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To consider speculative loads for a Document document:
</p>
<ol>
	<li id="step-consider-speculative-loads-top-level-only">
<p>
~IF［
%文書 の`~node~navigable$は`~top-level辿可能$でない
］
⇒
~RET
◎
If document's node navigable is not a top-level traversable, then return.
</p>

<p class="note">注記：
投機的な読込nを`子~navigable$の中でも~supportすることには、
何らかの複階性が有り，現時点では定義されない
— 将来には定義することがアリになるかもしれない。
◎
Supporting speculative loads into child navigables has some complexities and is not currently defined. It might be possible to define it in the future.
</p>
	</li>
	<li>
~IF［
%文書 の`~queueされた投機的な読込n小taskを考慮するか$ ~EQ ~T
］
⇒
~RET
◎
If document's consider speculative loads microtask queued is true, then return.
</li>
	<li>
%文書 の`~queueされた投機的な読込n小taskを考慮するか$ ~SET ~T
◎
Set document's consider speculative loads microtask queued to true.
</li>
	<li>
<p>
`小taskを~queueする$( %文書, 次の手続き )
◎
Queue a microtask given document to run＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li>
%文書 の`~queueされた投機的な読込n小taskを考慮するか$ ~SET ~F
◎
Set document's consider speculative loads microtask queued to false.
</li>
			<li>
`投機的な読込nを考慮する内縁~手続き$( %文書 )
◎
Run the inner consider speculative loads steps for document.
</li>
		</ol>
</div>
	</li>
</ol>

<p>
この標準においては、
明示的に与えられた~call元に加えて，~UAは：
◎
In addition to the call sites explicitly given in this standard:
</p>
<ul>
	<li>
~styleの再~計算に伴い選択子の照合~結果が変化するときには、
関連な`文書$用に`投機的な読込nを考慮する$モノトスル。
◎
When style recalculation would cause selector matching results to change, the user agent must consider speculative loads for the relevant Document.
</li>
	<li>
<p>
利用者が`~hyperlink$に対する関心を指示したときには、
いずれかの［
`投機~規則~早急度$用の経験則を実装するために利用する`実装定義$な仕方
］で［
当の~hyperlinkの`~node文書$用に`投機的な読込nを考慮する$
］ようにしてもヨイ。
◎
When the user indicates interest in hyperlinks, in one of the implementation-defined ways that the user agent uses to implement the speculation rule eagerness heuristics, the user agent may consider speculative loads for the hyperlink's node document.
</p>

<p class="example">
例えば，
`pointerdown$et ~eventを注視することにより `conservative$l な早急度を実装する~UAは、［
そのような~eventに反応することを成す一部として`投機的な読込nを考慮する$
］よう求めることになろう。
◎
For example, a user agent which implements "conservative" eagerness by watching for pointerdown events would want to consider speculative loads as part of reacting to such events.
</p>
	</li>
</ul>

<div class="note" id="note-consider-speculative-loads-stateless">
<p>注記：
この標準においては、
`投機的な読込nを考慮する$各~callには，`文書$だけが与えられる
— 当の~algoは、
アリなすべての候補を~statelessな仕方で算出し直す。
本物の実装は、
もっと効率的に更新するため，
以前の算出を~cacheした上で~call元からの情報も渡す見込みが高い。
例えば， `a$e 要素の `href$a 属性が変化した場合、
関係する`投機的な読込nの候補$のみを更新するよう，当の要素も渡すこともできる。
◎
In this standard, every call to consider speculative loads is given just a Document, and the algorithm re-computes all possible candidates in a stateless way. A real implementation would likely cache previous computations, and pass along information from the call site to make updates more efficient. For example, if an a element's href attribute is changed, that specific element could be passed along in order to update only the related speculative load candidate.
</p>

<p>
`投機的な読込nを考慮する$~algoは，
小taskを~queueすることにより`投機的な読込nを考慮する内縁~手続き$を走らすので、
それが走る時点までに複数の更新
（または`取消n＠#step-prefetch-record-cancel-and-discard$）
が，一緒に処理されるかもしれないことに注意。
◎
Note that because of how consider speculative loads queues a microtask, by the time the inner consider speculative loads steps are run, multiple updates (or cancelations) might be processed together.
</p>
</div>
</div>

<div class="algo">
<p>
`投機的な読込nを考慮する内縁~手続き@
は、
所与の
( `文書$ %文書 )
に対し：
◎
The inner consider speculative loads steps for a Document document are:
</p>
<ol>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET
◎
If document is not fully active, then return.
</li>
	<li>
%~prefetch候補~群 ~LET 新たな`~list$
◎
Let prefetchCandidates be an empty list.
</li>
	<li>
<p>
%文書 の`投機~規則~集合~群$docを成す
~EACH( %規則~集合 )
に対し：
◎
For each ruleSet of document's speculation rule sets:
</p>
		<ol>
			<li>
<p>
%規則~集合 の`~prefetch規則~群$srsを成す
~EACH( %規則 )
に対し：
◎
For each rule of ruleSet's prefetch rules:
</p>
				<ol>
					<li>
%匿名~化~施策 ~LET ~NULL
◎
Let anonymizationPolicy be null.
</li>
					<li>
~IF［
`anonymous-client-ip-when-cross-origin^l ~IN %規則 の`要件~群$sr
］
⇒
%匿名~化~施策 ~SET 新たな`非同一-生成元~prefetch~IP匿名~化~施策$
— その
⇒＃
`生成元$copiap ~SET %文書 の`生成元$doc
◎
If rule's requirements contains "anonymous-client-ip-when-cross-origin", then set anonymizationPolicy to a cross-origin prefetch IP anonymization policy whose origin is document's origin.
</li>
					<li>
<p>
%規則 の`~URL群$srを成す
~EACH( %~URL )
に対し：
◎
For each url of rule's URLs:
</p>
						<ol>
							<li>
%~referrer施策 ~LET `投機的な読込nの~referrer施策を算出する$( %規則, ~NULL )
◎
Let referrerPolicy be the result of computing a speculative load referrer policy given rule and null.
</li>
							<li>
%~prefetch候補 ~LET 新たな`~prefetch候補$
— その
⇒＃
`~URL$slC ~SET %~URL,
`~No-Vary-Search~hint$slC ~SET %規則 の`~No-Vary-Search~hint$sr,
`早急度$slC ~SET %規則 の`早急度$sr,
`~referrer施策$slC ~SET %~referrer施策,
`~tag群$slC ~SET %規則 の`~tag群$sr,
`匿名~化~施策$ ~SET %匿名~化~施策
◎
Append a new prefetch candidate with
• URL
•• url
• No-Vary-Search hint
•• rule's No-Vary-Search hint
• eagerness
•• rule's eagerness
• referrer policy
•• referrerPolicy
• tags
•• rule's tags
• anonymization policy
•• anonymizationPolicy
to prefetchCandidates.
</li>
							<li>
%~prefetch候補~群 に %~prefetch候補 を`付加する$
◎
↑</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%規則 の`述部$sr ~NEQ ~NULL
］：
◎
If rule's predicate is not null:
</p>

						<ol>
							<li>
%~link群 ~LET `合致している~linkたちを見出す$( %文書, %規則 の`述部$sr )
◎
Let links be the result of finding matching links given document and rule's predicate.
</li>
							<li>
<p>
%~link群 を成す
~EACH( %~link )
に対し：
◎
For each link of links:
</p>

								<ol>
									<li>
%~referrer施策 ~LET `投機的な読込nの~referrer施策を算出する$( %規則, %~link )
◎
Let referrerPolicy be the result of computing a speculative load referrer policy given rule and link.
</li>
									<li>
%~prefetch候補 ~LET 新たな`~prefetch候補$
— その
⇒＃
`~URL$slC ~SET %~link の`~URL$el,
`~No-Vary-Search~hint$slC ~SET %規則 の`~No-Vary-Search~hint$sr,
`早急度$slC ~SET %規則 の`早急度$sr,
`~referrer施策$slC ~SET %~referrer施策,
`~tag群$slC ~SET %規則 の`~tag群$sr,
`匿名~化~施策$ ~SET %匿名~化~施策
◎
Append a new prefetch candidate with
• URL
•• link's url
• No-Vary-Search hint
•• rule's No-Vary-Search hint
• eagerness
•• rule's eagerness
• referrer policy
•• referrerPolicy
• tags
•• rule's tags
• anonymization policy
•• anonymizationPolicy
to prefetchCandidates.
</li>
									<li>
%~prefetch候補~群 に %~prefetch候補 を`付加する$
◎
↑</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li id="step-prefetch-record-cancel-and-discard">
<p>
%文書 の`~prefetch~record群$docを成す
~EACH( %~prefetch~record )
に対し：
◎
For each prefetchRecord of document's prefetch records:
</p>
		<ol>
			<li>
~IF［
%~prefetch~record の`~source$pfR ~NEQ `speculation rules^l
］
⇒
~CONTINUE
◎
If prefetchRecord's source is not "speculation rules", then continue.
</li>
			<li>
~Assert：
%~prefetch~record の`状態$pfR ~NEQ `canceled^l
◎
Assert: prefetchRecord's state is not "canceled".
</li>
			<li>
~IF［
`依然として投機されている$( %~prefetch~record, %~prefetch候補~群 ) ~EQ ~F
］
⇒
`取消して破棄する$( %~prefetch~record, %文書 )
◎
If prefetchRecord is not still being speculated given prefetchCandidates, then cancel and discard prefetchRecord given document.
</li>
		</ol>
	</li>
	<li>
%~prefetch候補~group群 ~LET 新たな`~list$
◎
Let prefetchCandidateGroups be an empty list.
</li>
	<li>
<p>
%~prefetch候補~群 を成す
~EACH( %~item )
に対し：
◎
For each candidate of prefetchCandidates:
</p>
		<ol>
			<li>
%~group ~LET « %候補 »
◎
Let group be « candidate ».
</li>
			<li>
【！`拡張する$】
%~prefetch候補~群 を成す
~EACH( %候補 )
に対し
⇒
~IF［
%~item ~NEQ %候補
］~AND［
( %候補, %~item ) は`互いに冗長$である
］~AND［
%~item の`早急度$slCは %候補 の`早急度$slC`以上に早急$である
］
⇒
%~group に %~item を`付加する$
◎
Extend group with all items in prefetchCandidates, apart from candidate itself, which are redundant with candidate and whose eagerness is at least as eager as candidate's eagerness.
</li>
			<li>
%~prefetch候補~group群 を成す
~EACH( %別の~group )
に対し
⇒
~IF［
%別の~group と %~group は順序を無視して同じ`~item$たちからなる
【！~itemどうしの同等性が定義されていない】
］
⇒
~CONTINUE
◎
If prefetchCandidateGroups contains another group whose items are the same as group, ignoring order, then continue.
</li>
			<li>
%~prefetch候補~group群 に %~group を`付加する$
◎
Append group to prefetchCandidateGroups.
</li>
		</ol>
<div id="example-redundant-speculation-rules" class="example">
<p>
次の投機~規則は、
2 個の`互いに冗長$な`~prefetch候補$を生成する：
◎
The following speculation rules generate two redundant prefetch candidates:
</p>

<pre class="lang-json">
{
  "prefetch": [
    {
      "tag": "a",
      "urls": ["next.html"]
    },
    {
      "tag": "b",
      "urls": ["next.html"],
      "referrer_policy": "no-referrer"
    }
  ]
}
</pre>

<p>
この段は，それら両者を所与の順序で包含している 1 個の~groupを作成することになる。
（上の~loopにおける 2 回目の反復は~groupを作成しないことになる
— その内容は順序が異なるだけで 1 個目の~groupと同じになるので）。
このことは、
~UAが［
以下の “任意選択な”【！may】 段で当の~groupを動作化することを実行することを選ぶ場合
］には［
1 個目の候補を動作化して， 2 個目を無視する
］ようになることを意味する。
したがって，当の要請は［
`no-referrer$v を利用する代わりに`既定の~referrer施策$
］を伴って為されることになる。
◎
This step will create a single group containing them both, in the given order. (The second pass through will not create a group, since its contents would be the same as the first group, just in a different order.) This means that if the user agent chooses to execute the "may" step below to enact the group, it will enact the first candidate, and ignore the second. Thus, the request will be made with the default referrer policy, instead of using "no-referrer".
</p>

<p>
しかしながら、
`投機的な読込nの候補たちから~tag群を収集する$~algoは，
当の~group内の両~候補から~tagたちを収集するので、
`Sec-Speculation-Tags$h ~headerの値は `"a", "b"^bl になる。
このことは、［
どちらの規則も投機的な読込nを生じさせ得たこと
］を~server運用者に指示する。
◎
However, the collect tags from speculative load candidates algorithm will collect tags from both candidates in the group, so the `Sec-Speculation-Tags` header value will be `"a", "b"`. This indicates to server operators that either rule could have caused the speculative load.
</p>
</div>
	</li>
	<li>
<p>
%~prefetch候補~group群 を成す
~EACH( %~group )
に対し：
◎
For each group of prefetchCandidateGroups:
</p>
		<ol>
			<li>
<p>
任意選択で【！may】：
◎
The user agent may run the following steps:
</p>
				<ol>
					<li>
%~prefetch候補 ~LET %~group[ 0 ]
◎
Let prefetchCandidate be group[0].
</li>
					<li>
%送信する~tag群 ~LET `投機的な読込nの候補たちから~tag群を収集する$( %~group )
◎
Let tagsToSend be the result of collecting tags from speculative load candidates given group.
</li>
					<li>
%~prefetch~record ~LET 新たな`~prefetch~record$
— その
⇒＃
`~source$pfR ~SET `speculation rules^l,
`~URL$pfR ~SET %~prefetch候補 の`~URL$slC,
`~No-Vary-Search~hint$pfR ~SET %~prefetch候補 の`~No-Vary-Search~hint$slC,
`~referrer施策$pfR ~SET %~prefetch候補 の`~referrer施策$slC,
`匿名~化~施策$pfR ~SET %~prefetch候補 の`匿名~化~施策$,
`~tag群$pfR ~SET %送信する~tag群
◎
Let prefetchRecord be a new prefetch record with
• source
•• "speculation rules"
• URL
•• prefetchCandidate's URL
• No-Vary-Search hint
•• prefetchCandidate's No-Vary-Search hint
• referrer policy
•• prefetchCandidate's referrer policy
• anonymization policy
•• prefetchCandidate's anonymization policy
• tags
•• tagsToSend
</li>
					<li>
`~referrerにより起動された~naviな~prefetchを開始する$( %~prefetch~record, %文書 )
◎
Start a referrer-initiated navigational prefetch given prefetchRecord and document.
</li>
				</ol>
<p>
~UAは、
この “任意選択な”【！may】 段を実行するかどうか裁定するときは，
%~prefetch候補 の`早急度$slCを［
利用者の現在の挙動, 各種`投機~規則~早急度$の定義
］に則って考慮するベキである。
◎
When deciding whether to execute this "may" step, user agents should consider prefetchCandidate's eagerness, in accordance to the current behavior of the user and the definitions of speculation rule eagerness.
</p>

<p>
%~prefetch候補 の`~No-Vary-Search~hint$slCは、
`投機~規則~早急度$値~用に定義される経験則を実装する際にも有用になり得る。
例えば，利用者が ある~linkを~hoverしていて，［
( 当の~linkの`~URL$el, %~prefetch候補 の`~URL$slC )
は %~prefetch候補 の`~No-Vary-Search~hint$slC の`下で等価$である
］ならば、
この段を遂行することが有用になることも~UAに指示し得る。
◎
prefetchCandidate's No-Vary-Search hint can also be useful in implementing the heuristics defined for the speculation rule eagerness values. For example, a user hovering of a link whose URL is equivalent modulo search variance to prefetchCandidate's URL given prefetchCandidate's No-Vary-Search hint could indicate to the user agent that performing this step would be useful.
</p>

<p>
~UAは、
この “任意選択な”【！may】 段を実行するかどうか裁定するときは，
利用者~選好
（~data節約~modeや~battery節約~modeなど，利用者が暗黙的に表出したものも含む）
を~web開発者により給された早急度よりも優先するベキである。
◎
When deciding whether to execute this "may" step, user agents should prioritize user preferences (express or implied, such as data-saver or battery-saver modes) over the eagerness supplied by the web developer.
</p>
			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`投機的な読込nの~referrer施策を算出する@
~algoは、
所与の
( `投機~規則$ %規則, ［
`a$e 要素 ／ `area$e 要素 ／ ~NULL
］ %~link )
に対し：
◎
To compute a speculative load referrer policy given a speculation rule rule and an a element, area element, or null link:
</p>
<ol>
	<li>
~IF［
%規則 の`~referrer施策$sr ~NEQ 空~文字列
］
⇒
~RET %規則 の`~referrer施策$sr
◎
If rule's referrer policy is not the empty string, then return rule's referrer policy.
</li>
	<li>
~IF［
%~link ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If link is null, then return the empty string.
</li>
	<li>
~RET %~link の`~hyperlink~referrer施策$
◎
Return link's hyperlink referrer policy.
</li>
</ol>
</div>

<div class="algo">
<p>
`投機的な読込nの候補たちから~tag群を収集する@
~algoは、
所与の
( `投機的な読込nの候補$たちが成す`~list$ %候補~群 )
に対し：
◎
To collect tags from speculative load candidates given a list of speculative load candidates candidates:
</p>
<ol>
	<li>
%~tag群 ~LET 新たな`有順序~集合$
◎
Let tags be an empty ordered set.
</li>
	<li>
<p>
%候補~群 を成す
~EACH( %候補 )
に対し：
◎
For each candidate of candidates:
</p>
		<ol>
			<li>
%候補 の`~tag群$slCを成す
~EACH( %~tag )
に対し
⇒
%~tag群 に %~tag を`付加する$set
◎
For each tag of candidate's tags: append tag to tags.
</li>
		</ol>
	</li>
	<li>
<p>
`~listを昇順に~sortする$( %~tag群, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
~RET ~IS
［［
%~tag~A ~EQ ~NULL
］~AND［
%~tag~B ~NEQ ~NULL
【この条件は，この訳による補完】
］］~OR［
%~tag~A は %~tag~B `未満の符号単位~列$である
］
</div>
◎
Sort in ascending order tags, with tagA being less than tagB if tagA is null, or if tagA is code unit less than tagB.
</li>
	<li>
~RET %~tag群
◎
Return tags.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`合致している~linkたちを見出す@
~algoは、
所与の
( `文書$ %文書, `文書~規則~述部$ %述部 )
に対し：
◎
To find matching links given a Document document and a document rule predicate predicate:
</p>
<ol>
	<li>
%~link群 ~LET 新たな`~list$
◎
Let links be an empty list.
</li>
	<li>
<p>
%文書 を成す
~EACH( `~shadowも含めた子孫$ %子孫 )
に対し，`~shadowも含めた~tree順序$で：
◎
For each shadow-including descendant descendant of document, in shadow-including tree order:
</p>
		<ol>
			<li>
~IF［
%子孫 は［
`a$e ／ `area$e
］要素でない
］~OR［
%子孫 は `href$a 属性を有さない
］
⇒
~CONTINUE
◎
If descendant is not an a or area element with an href attribute, then continue.
</li>
			<li>
<p>
~IF［
%子孫 は`具現化されて$いない
］~OR［
%子孫 は`飛ばされた内容$の一部を成す
］
⇒
~CONTINUE
◎
If descendant is not being rendered or is part of skipped contents, then continue.
</p>

<p class="note">注記：
そのような~linkは、
%文書 内には在るが，利用者がヤリトリするものとしては可用でない
— したがって，良い候補にならない見込みが高い。
加えて，それらの［
~styleや~layout
］は まだ算出されていないかもしれず，［
これらの要素~用の作業を一部でも飛ばす~UA
］における選択子~照合の効率を悪くするかもしれない。
◎
Such links, though present in document, aren't available for the user to interact with, and thus are unlikely to be good candidates. In addition, they might not have their style or layout computed, which might make selector matching less efficient in user agents which skip some or all of that work for these elements.
</p>
	</li>
	<li>
~IF［
%子孫 の`~URL$el ~EQ ~NULL
］~OR［
%子孫 の`~URL$elの`~scheme$urlは`~HTTP_S~scheme$でない
］
⇒
~CONTINUE
◎
If descendant's url is null, or its scheme is not an HTTP(S) scheme, then continue.
</li>
	<li>
~IF［
%述部 は %子孫 に`合致-$する
］
⇒
%~link群 に %子孫 を`付加する$
◎
If predicate matches descendant, then append descendant to links.
</li>
		</ol>
	</li>
	<li>
~RET %~link群
◎
Return links.
</li>
</ol>
</div>

<div class="algo">
<p>
所与の
( `文書~規則~述部$ %述部, ［
`a$e ／ `area$e
］要素 %要素 )
に対し，
%述部 は %要素 に
`合致-@
するとは、
%述部 に応じて，次に挙げる手続きが ~T を返すことをいう：
◎
A document rule predicate predicate matches an a or area element el if the following steps return true, switching on predicate's type:
</p>
<ul class="switch">
	<li>
<p>
`文書~規則~論理積$：
◎
document rule conjunction
</p>
		<ol>
			<li>
%述部 の`条項~群$drCを成す
~EACH( %条項 )
に対し
⇒
~IF［
%条項 は %要素 に`合致-$しない
］
⇒
~RET ~F
◎
For each clause of predicate's clauses:
• If clause does not match el, then return false.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</li>

	<li>
<p>
`文書~規則~論理和$：
◎
document rule disjunction
</p>
		<ol>
			<li>
%述部 の`条項~群$drDを成す
~EACH( %条項 )
に対し
⇒
~IF［
%条項 は %要素 に`合致-$する
］
⇒
~RET ~T
◎
For each clause of predicate's clauses:
• If clause matches el, then return true.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</li>
	<li>
`文書~規則~否定$
⇒
~RET ~IS［
%述部 の`条項$drN は %要素 に`合致-$しない
］
◎
document rule negation
• If predicate's clause matches el, then return false.
• Return true.
</li>
	<li>
<p>
`文書~規則~URL~pattern述部$：
◎
document rule URL pattern predicate
</p>
		<ol>
			<li>
%述部 の`~pattern群$を成す
~EACH( %~pattern )
に対し
⇒
~IF［
`~URL~patternを照合する$( %~pattern, %要素 の`~URL$el ) の結果 ~NEQ ~NULL
］
⇒
~RET ~T
◎
For each pattern of predicate's patterns:
• If performing a match given pattern and el's url gives a non-null value, then return true.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</li>
	<li>
<p>
`文書~規則~選択子~述部$：
◎
document rule selector predicate
</p>
		<ol>
			<li>
%述部 の`選択子~群$を成す
~EACH( %選択子 )
に対し
⇒
~IF［
`要素に対し選択子を照合する$( %選択子, %要素, { %要素 の`根$ } ) の結果 ~EQ `成功^i
］
⇒
~RET ~T
◎
For each selector of predicate's selectors:
• If performing a match given selector and el with the scoping root set to el's root returns sucess, then return true.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</li>
</ul>
</div>

<hr>

<p>
投機~規則~特能は、
`~task~source$として
`投機~規則~群~task~source@
を利用する。
◎
Speculation rules features use the speculation rules task source, which is a task source.
</p>

<p class="note">注記：
一般に，［
投機的な読込ngの重要~度は，現在の文書の目的~用の処理~taskよりも低い
］ので、
実装は，ここで~enqueueされる`~task$の優先度をとりわけ低くするかもしれない。
◎
Because speculative loading is generally less important than processing tasks for the purpose of the current document, implementations might give tasks enqueued here an especially low priority.
</p>

				</section>
			</section>
			<section id="navigational-prefetching">
<h4 title="Navigational prefetching">7.6.2. ~naviな~prefetch法</h4>

<p>
~naviな~prefetch法の処理nは、
今の所は `PREFETCH$r 内に定義される。
それをこの標準の中へ移動することは、
`課題 #11123＠~HTMLissue/11123$
において追跡される。
◎
For now, the navigational prefetching process is defined in the Prefetch specification. Moving it into this standard is tracked in issue #11123. [PREFETCH]
</p>

<p>
この標準は、
そこに定義される次に挙げる概念を参照rする：
◎
This standard refers to the following concepts defined there:
</p>

<ul>
	<li id="prefetch-record">
<p>
`~prefetch~record$, およびそれを成す次に挙げる~item：
</p>
		<ul>
			<li id="prefetch-record-source">`~source$pfR
			<li id="prefetch-record-url">`~URL$pfR
			<li id="prefetch-record-nvs-hint">`~No-Vary-Search~hint$pfR
			<li id="prefetch-record-referrer-policy">`~referrer施策$pfR 
			<li id="prefetch-record-anonymization-policy">`匿名~化~施策$pfR 
			<li id="prefetch-record-tags">`~tag群$pfR
			<li id="prefetch-record-state">`状態$pfR
		</ul>
◎
prefetch record, and its items source, URL, No-Vary-Search hint, referrer policy, anonymization policy, tags, and state
</li>
	<li id="prefetch-record-cancel-and-discard">
`取消して破棄する$
◎
cancel and discard
</li>
	<li id="still-being-speculated">
`依然として投機されている$
◎
still being speculated
</li>
	<li id="document-prefetch-records">
`~prefetch~record群$doc
◎
prefetch records
</li>
	<li id="start-a-referrer-initiated-navigational-prefetch">
`~referrerにより起動された~naviな~prefetchを開始する$
◎
start a referrer-initiated navigational prefetch
</li>
</ul>

			</section>
			<section id="the-speculation-rules-header">
<h4 title="The Speculation-Rules header">7.6.3. `Speculation-Rules^h ~header</h4>

<p>
`Speculation-Rules@h
~HTTP応答~headerは、［
所与の`投機~規則~集合$を~fetchして現在の`文書$に適用するよう~UAに要請する
］ことを開発者に許容する。
◎
The `Speculation-Rules` HTTP response header allows the developer to request that the user agent fetch and apply a given speculation rule set to the current Document.＼
</p>

<p>
この~headerは，`有構造~header$であり、
その値は，次を満たさなければナラナイ
⇒
`~sf~list$であって，
それを成す各~itemの値は次を満たす`~sf文字列$である
⇒
`妥当な~URL文字列$である
◎
It is a structured header whose value must be a list of strings that are all valid URL strings.
</p>

<div class="algo">
<p>
`~Speculation-Rules~headerを処理する@
~algoは、
所与の
( `文書$ %文書, `応答$ %応答 )
に対し：
◎
To process the `Speculation-Rules` header given a Document document and a response response:
</p>
<ol>
	<li>
%構文解析-済み~list ~LET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Speculation-Rules$h, `~list^i )
◎
Let parsedList be the result of getting a structured field value given `Speculation-Rules` and "list" from response's header list.
</li>
	<li>
~IF［
%構文解析-済み~list ~EQ ~NULL
］
⇒
~RET
◎
If parsedList is null, then return.
</li>
	<li>
<p>
%構文解析-済み~listを成す
~EACH( %~item )
に対し：
◎
For each item of parsedList:
</p>
		<ol>
			<li>
~IF［
%~item は`文字列$【`~sf文字列$】でない
］
⇒
~CONTINUE
◎
If item is not a string, then continue.
</li>
			<li>
%~URL ~LET `~URL構文解析する$( %~item, %文書 の`文書~基底~URL$ )
◎
Let url be the result of URL parsing item with document's document base URL.
</li>
			<li>
~IF［
%~URL ~EQ `失敗^i
］
⇒
~CONTINUE
◎
If url is failure, then continue.
</li>
			<li class="algo">
<p>
この段は`並列的$に遂行する：
◎
In parallel:
</p>
				<ol>
					<li>
<p>
任意選択で【！may】
⇒
`実装定義$な時間だけ待機する
◎
Optionally, wait for an implementation-defined amount of time.
</p>

<p class="note">注記：
これは、［
投機~規則~群の読込ngに先立って，他の作業を優先する
］ことを実装に許容する
— とりわけ［
`文書$の作成, ~header処理
］の間は，もっと重要な多くのものが進行中なことが多いので。
◎
This allows the implementation to prioritize other work ahead of loading speculation rules, as especially during Document creation and header processing, there are often many more important things going on.
</p>
					</li>
					<li>
<p>
`大域~taskを~queueする$( `投機~規則~群~task~source$, %文書 の`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the speculation rules task source given document's relevant global object to perform＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
						<ol>
							<li>
%要請 ~LET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET %~URL,
`行先$rq ~SET `speculationrules^l,
`~mode$rq ~SET `cors^l
◎
Let request be a new request whose URL is url, destination is "speculationrules", and mode is "cors".
</li>
							<li>
<p>
%要請 を`~fetchする$
— 次を与える下で：
◎
Fetch request with the following＼
</p>
								<ul>
									<li>
<p>
`応答の本体を消費する処理n^i は、
所与の
( `応答$ %応答, ［
~NULL ／ `失敗^i ／ `~byte列$
］ %本体~byte列 )
に対し：
◎
processResponseConsumeBody steps given response response and null, failure, or a byte sequence bodyBytes:
</p>
										<ol>
											<li>
~IF［
%本体~byte列 ~IN { ~NULL, `失敗^i }
］
⇒
~RET
◎
If bodyBytes is null or failure, then abort these steps.
</li>
											<li>
~IF［
%応答 の`状態s$rsは`~ok状態s$でない
］
⇒
~RET
◎
If response's status is not an ok status, then abort these steps.
</li>
											<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %応答 の`~header~list$rs )
◎
↓</li>
											<li>
~IF［
%~MIME型 の`~essence$ ~NEQ `application/speculationrules+json$mt
］
⇒
~RET
◎
If the result of extracting a MIME type from response's header list does not have an essence of "application/speculationrules+json", then abort these steps.
</li>
											<li>
%本体~text ~LET `~UTF-8復号する$( %本体~byte列 )
◎
Let bodyText be the result of UTF-8 decoding bodyBytes.
</li>
											<li>
<p>
%規則~集合 ~LET `投機~規則~集合~文字列を構文解析する$( %本体~text, %文書, %応答 の`~URL$rs )
</p>

<p>
例外が投出された場合，~catchして
⇒
~RET
</p>
◎
Let ruleSet be the result of parsing a speculation rule set string given bodyText, document, and response's URL. If this throws an exception, then abort these steps.
</li>
											<li>
%文書 の`投機~規則~集合~群$docに %規則~集合 を`付加する$
◎
Append ruleSet to document's speculation rule sets.
</li>
											<li>
`投機的な読込nを考慮する$( %文書 )
◎
Consider speculative loads for document.
</li>
										</ol>
									</li>
								</ul>
							</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="the-sec-speculation-tags-header">
<h4 title="The Sec-Speculation-Tags header">7.6.4. `Sec-Speculation-Tags$h ~header</h4>

<p>
`Sec-Speculation-Tags@h
~HTTP要請~headerは、
~web開発者が供した［
投機的な~navi要請に結付けられた~tagたち
］を指定する。
それは、
投機的な~navi要請と投機的な下位資源~要請を判別するためにも利用され得る
— どちらに~~分類される要請も， `Sec-Purpose$h を送信し得るので。
◎
The `Sec-Speculation-Tags` HTTP request header specifies the web developer-provided tags associated with the speculative navigation request. It can also be used to distinguish speculative navigation requests from speculative subresource requests, since `Sec-Purpose` can be sent by both categories of requests.
</p>

<div>
<p>
この~headerは，`有構造~header$であり、
その値は，`~sf~list$でなければナラナイ。
この~listは，次に挙げるいずれかを値にとる~itemを包含し得る：
</p>
<ul>
	<li>
`~sf文字列$
⇒
開発者が供した~tagを表現する。
</li>
	<li>
`~sf~token$
⇒
定義済みな~tagを表現する。
定義済みな~tagは，今の所は `null^c しかない
— それは、
開発者~定義な~tagを伴わない投機的な~navi要請を指示する。
</li>
</ul>

<p class="trans-note">【
他の型の~itemは［
許容されないのか，単に無視されるのか
］は、
はっきりしない。
】</p>
◎
The header is a structured header whose value must be a list. The list can contain either token or string values. String values represent developer-provided tags, whereas token values represent predefined tags. As of now, the only predefined tag is null, which indicates a speculative navigation request with no developer-defined tag.
</div>

			</section>
			<section id="speculative-loading-security">
<h4 title="Security considerations">7.6.5. ~securityの考慮点</h4>

				<section id="speculative-loading-cross-site-requests">
<h5 title="Cross-site requests">7.6.5.1. 非同一-~siteな要請</h5>

<p>
~web~pageは、
非同一-~siteな行先へ向けても投機的な読込nを起動し得る。
しかしながら、
そのような非同一-~siteな投機的な読込nは
— `以下＠#speculative-loading-state-partitioning$に説明されるとおり —
常に`資格証$を伴わずに行われるので，
~ambientな権限は［
~web~platformを成す他の仕組みを介して，すでにアリな要請
］に制限される。
◎
Speculative loads can be initiated by web pages to cross-site destinations. However, because such cross-site speculative loads are always done without credentials, as explained below, ambient authority is limited to requests that are already possible via other mechanisms on the platform.
</p>

<p>
`Speculation-Rules$h ~headerは、
~JSON文書
— その本体が`投機~規則~集合~文字列として構文解析される＠#parse-a-speculation-rule-set-string$ことになるそれ —
への要請を発行するためにも利用され得る。
しかしながら、
そのような要請は［
`資格証~mode$rqには `same-origin^l,
`~mode$rqには `cors^l
］を利用することに加え，
対する応答が【~MIME型の】`~essence$として `application/speculationrules+json$mt を利用しない場合には無視されるので、
攻撃を仕掛けることにおいては有用にならない。
◎
The `Speculation-Rules` header can also be used to issue requests, for JSON documents whose body will be parsed as a speculation rule set string. However, they use the "same-origin" credentials mode, the "cors" mode, and responses which do not use the application/speculationrules+json MIME type essence are ignored, so they are not useful in mounting attacks.
</p>

				</section>
				<section id="speculative-loading-injected-content">
<h5 title="Injected content">7.6.5.2. 注入される内容</h5>

<p>
文書~内の各~linkは，
`文書~規則~述部$を介して投機的な読込ng用に選定され得るので、
開発者は，［
そのような~linkが利用者が生成した~markupを包含するかもしれない場合
］について用心する必要がある。
例えば，［
ある~linkの `href$a が ある利用者により手入力され，他のすべての利用者へ表示される
］場合、
悪意的な利用者は `/logout^l の様な値を選ぶかもしれない
— その~linkが投機的に読込まれたとき，
他の利用者の~browserが~siteから自動的に~log-outさせるよう。
このことに関して有用な技法として，次が挙げられる
⇒＃
`文書~規則~選択子~述部$を利用して，そのような危険にもなり得る~linkを除外する。
`文書~規則~URL~pattern述部$を利用して，既知な安全な~linkしか許容しないようにする。
◎
Because links in a document can be selected for speculative loading via document rule predicates, developers need to be cautious if such links might contain user-generated markup. For example, if the href of a link can be entered by one user and displayed to all other users, a malicious user might choose a value like "/logout", causing other users' browsers to automatically log out of the site when that link is speculatively loaded. Using a document rule selector predicate to exclude such potentially-dangerous links, or using a document rule URL pattern predicate to allowlist known-safe links, are useful techniques in this regard.
</p>

<p>
`script$e 要素のすべての利用と同じく，
開発者は、［
利用者が供した内容を［
`type$a 属性が `speculationrules^l に設定された `script$e 要素
］の`子~text内容$の中へ挿入すること
］について用心する必要がある。
特に，~escapeされない終了~tag `&lt;/script&gt;^c の挿入は、
`script$e 要素~文脈を分断して，攻撃者により制御される~markupを注入するためにも利用され得る。
◎
As with all uses of the script element, developers need to be cautious about inserting user-provided content into &lt;script type=speculationrules&gt;'s child text content. In particular, the insertion of an unescaped closing &lt;/script&gt; tag could be used to break out of the script element context and inject attacker-controlled markup.
</p>

<p>
`&lt;script type=speculationrules&gt;^c 特能は，
文書~内に見出された内容に呼応して活動を生じさせるので、
~escapeされてない~HTMLを注入-可能な攻撃者が どの~optionをとり得るかは，考慮するに価する。
そのような攻撃者は、
すでに［
~JS ／ `iframe$e 要素
］を注入-可能である。
一般に，投機的な読込nの危険~性は任意な~script実行よりも低い。
しかしながら、
`文書~規則~述部$の利用は，文書~内の~linkを投機的に読込むためにも利用され得る
— それらの読込nの存在は、
それらの~linkについての情報を漏出する行路も供し得る。
このアリ性に抗する多層防御は、
~CSP `CSP$r により供される。
特に， `script-src$dir 指令は、
投機~規則~群を伴う `script$e 要素の構文解析を制約するために利用できる。
また， `default-src$dir 指令は、
そのような投機~規則~群から発生している~naviな~prefetch要請に適用される。
追加的な防御は［
投機的な読込nは`信用に価し得る~URL$に限り遂行される
］とする要件により供されるので、
経路上の攻撃者は，~metadataと流通~分析にしか~accessし得ず, ~URLを直に見ることはできない。
◎
The &lt;script type=speculationrules&gt; feature causes activity in response to content found in the document, so it is worth considering the options open to an attacker able to inject unescaped HTML. Such an attacker is already able to inject JavaScript or iframe elements. Speculative loads are generally less dangerous than arbitrary script execution. However, the use of document rule predicates could be used to speculatively load links in the document, and the existence of those loads could provide a vector for exfiltrating information about those links. Defense-in-depth against this possibility is provided by Content Security Policy. In particular, the script-src directive can be used to restrict the parsing of speculation rules script elements, and the default-src directive applies to navigational prefetch requests arising from such speculation rules. Additional defense is provided by the requirement that speculative loads are only performed to potentially-trustworthy URLs, so an on-path attacker would only have access to metadata and traffic analysis, and could not see the URLs directly. [CSP]
</p>

<p>
一般に，［
利用者が生成した内容が任意な応答~headerとして追加されること
］は予期されない
— これがアリな場合、
~server運用者は，すでに有意な面倒事に遭遇しているはずである。
したがって、
`Speculation-Rules$h ~headerが~XSS攻撃~表口を有意義に拡げる見込みは，およそない。
この理由から、
~CSPは，この~headerを介した規則~集合~群の読込ngには適用されない。
◎
It's generally not expected that user-generated content will be added as arbitrary response headers: server operators are already going to encounter significant trouble if this is possible. It is therefore unlikely that the `Speculation-Rules` header meaningfully expands the XSS attack surface. For this reason, Content Security Policy does not apply to the loading of rule sets via that header.
</p>

				</section>
				<section id="speculative-loading-ip-anonymization">
<h5 title="IP anonymization">7.6.5.3. ~IP匿名~化</h5>

<p>
この標準は、［
~naviな~prefetchを［
~UAにより供される~IP匿名~化~技術
］を利用して遂行するよう要請する
］ことを開発者に許容する。
この匿名~化の詳細は，指定されないが、
いくつかの一般な~security原則が適用される。
◎
This standard allows developers to request that navigational prefetches are performed using IP anonymization technology provided by the user agent. The details of this anonymization are not specified, but some general security principles apply.
</p>

<p>
~IP匿名~化は、
ある~proxy~serviceを利用して実装される場合には，~network経路~上の［
~service運用者や他の実体
］に可用な情報を最小~化することを勧める。
これは、
少なくとも［
当の接続~用には~TLSを利用する
］ことを孕む見込みが高い。
◎
To the extent IP anonymization is implemented using a proxy service, it is advisable to minimize the information available to the service operator and other entities on the network path. This likely involves, at a minimum, the use of TLS for the connection.
</p>

<p>
~site運用者は、
~HTTP~serverから見える~client~IP~addressは
— ~VPN（ `virtual private network^en ）技術と類似に —
［
利用者の実際の［
~network~providerや所在
］には正確に対応しないかもしれず，
同じ~client~IP~addressから複数の別個な~subscriber用の流通が出生することもある
］ことを自覚する必要がある。
このことは、
~site運用者の~securityと濫用~防止~措置に影響し得る。
~IP匿名~化~措置は，出口~IP~addressとして［
利用者と類似な地理所在にあるもの／
利用者が属する管轄~内に所在するもの
］を利用する労を為すかもしれないが、
そのような挙動は，~UAに~~特有なので保証されない。
◎
Site operators need to be aware that, similar to virtual private network (VPN) technology, the client IP address seen by the HTTP server might not exactly correspond to the user's actual network provider or location, and a traffic for multiple distinct subscribers could originate from a single client IP address. This can affect site operators' security and abuse prevention measures. IP anonymization measures might make an effort to use an egress IP address which has a similar geolocation or is located in the same jurisdiction as the user, but any such behavior is particular to the user agent and not guaranteed.
</p>

				</section>
			</section>
			<section id="speculative-loading-privacy">
<h4 title="Privacy considerations">7.6.6. ~privacyの考慮点</h4>

<span id="speculative-loading-state-partitioning"></span>
<p class="trans-note">【
この節を成す内容は未訳。
】</p>

			</section>
		</section>
		<section id="the-x-frame-options-header">
<h3 title="The X-Frame-Options header">7.7. `X-Frame-Options^h ~header</h3>

<p>
`X-Frame-Options@h
~HTTP応答~headerは、［
`文書$は`子~navigable$の内側に どう読込まれてもよいか
］を制御する仕方である。
~CSPを利用している~site用には、
`frame-ancestors$dir 指令の方が，同じ状況に対し細やかな制御を供する。
この~headerは，元々は `RFC7034$r にて定義されたが、
ここでの定義と処理~modelは，その文書に取って代わる。
◎
The `X-Frame-Options` HTTP response header is a way of controlling whether and how a Document may be loaded inside of a child navigable. For sites using CSP, the frame-ancestors directive provides more granular control over the same situations. It was originally defined in HTTP Header Field X-Frame-Options, but the definition and processing model here supersedes that document. [CSP] [RFC7034]
</p>

<p class="note">注記：
特に， `RFC7034$r は、
その~header値~用の変種として `ALLOW-FROM^bl も指定したが，
それは実装されていない。
◎
In particular, HTTP Header Field X-Frame-Options specified an `ALLOW-FROM` variant of the header, but that is not to be implemented.
</p>

<p class="note">注記：
以下に与える処理~modelにより、
`X-Frame-Options$h ~headerは，
同じ`応答$内に~CSP `frame-ancestors$dir 指令も利用された場合には無視される。
◎
Per the below processing model, if both a CSP frame-ancestors directive and an `X-Frame-Options` header are used in the same response, then `X-Frame-Options` is ignored.
</p>

<p>
［
~web開発者／適合性~検査器
］向けとして，その値の`~ABNF$は：
◎
For web developers and conformance checkers, its value ABNF is:
</p>

<pre class="bnf">
X-Frame-Options
	= "DENY"
	/ "SAMEORIGIN"
</pre>

<div class="algo">
<p>
`~navi応答の~X-Frame-Optionsに対する固守を検査する@
~algoは、
所与の
( `応答$ %応答, `~navigable$ %~navigable, `~CSP~list$ %~CSP~list, `生成元$ %行先~生成元 )
に対し：
◎
To check a navigation response's adherence to `X-Frame-Options`, given a response response, a navigable navigable, a CSP list cspList, and an origin destinationOrigin:
</p>
<ol>
	<li>
~IF［
%~navigable は`子~navigable$でない
］
⇒
~RET ~T
◎
If navigable is not a child navigable, then return true.
</li>
	<li>
<p>
%~CSP~list を成す
~EACH( %施策 )
に対し：
◎
For each policy of cspList:
</p>
		<ol>
			<li>
~IF［
%施策 の`処置先$ ~NEQ `enforce^l
］
⇒
~CONTINUE
◎
If policy's disposition is not "enforce", then continue.
</li>
			<li>
~IF［
`frame-ancestors$dir 指令 ~IN %施策 の`指令~集合$
］
⇒
~RET ~T
◎
If policy's directive set contains a frame-ancestors directive, then return true.
</li>
		</ol>
	</li>
	<li>
%~X-Frame-Options ~LET `~header~listから値を取得して復号して分割する$( %応答 の`~header~list$rs, `X-Frame-Options$h )
◎
Let rawXFrameOptions be the result of getting, decoding, and splitting `X-Frame-Options` from response's header list.
</li>
	<li>
<p>
~IF［
%~X-Frame-Options ~EQ ~NULL
］
⇒
~RET ~T
</p>
<p class="trans-note">【
この段は、
この訳による補完
（応答~内に `X-Frame-Options$h は無い）。
】</p>
	</li>
	<li>
%~frame~option群 ~LET 新たな`有順序~集合$
◎
Let xFrameOptions be a new set.
</li>
	<li>
%~X-Frame-Options を成す
~EACH( %値 )
に対し
⇒
%~frame~option群 に次の結果を`付加する$set
⇒
`~ASCII小文字~化する$( %値 ) 
◎
For each value of rawXFrameOptions, append value, converted to ASCII lowercase, to xFrameOptions.
</li>
	<li>
<p>
~IF［
%~frame~option群 の`~size$ ~GT 1
］：
◎
↓</p>
		<ol>
			<li>
<p>
%~frame~option群 を成す
~EACH( %値 )
に対し
⇒
~IF［
%値 ~IN { `deny^l, `allowall^l, `sameorigin^l }
］
⇒
~RET ~F
◎
If xFrameOptions's size is greater than 1, and xFrameOptions contains any of "deny", "allowall", or "sameorigin", then return false.
</p>

<p class="note">注記：
ここでの意図nは、
`X-Frame-Options$h が［
妥当な何かを行おうと試行しているが，紛らわしく現れる
］場合には，それを適用する際に 【埋込もうとする】どの試みも阻止することにある。
◎
The intention here is to block any attempts at applying `X-Frame-Options` which were trying to do something valid, but appear confused.
</p>

<p class="note">注記：
旧来の `ALLOWALL^bl 値による処理~modelに対する影響iは、
ここに限られる。
◎
This is the only impact of the legacy `ALLOWALL` value on the processing model.
</p>
			</li>
			<li>
<p>
~RET ~T
◎
If xFrameOptions's size is greater than 1, then return true.
</p>

<p class="note">注記：
~headerは、
複数個の妥当でない値を包含している
— この場合、
~headerが まるごと省略されていたときと同じ仕方で扱う。
◎
This means it contains multiple invalid values, which we treat the same way as if the header was omitted entirely.
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%~frame~option群[ 0 ] ~EQ `deny^l
］
⇒
~RET ~F
◎
If xFrameOptions[0] is "deny", then return false.
</li>
	<li>
<p>
~IF［
%~frame~option群[ 0 ] ~EQ `sameorigin^bl
］：
◎
If xFrameOptions[0] is "sameorigin", then:
</p>
		<ol>
			<li>
%容器~文書 ~LET %~navigable の`容器~文書$nav
◎
Let containerDocument be navigable's container document.
</li>
			<li>
<p>
~WHILE［
%容器~文書 ~NEQ ~NULL
］：
◎
While containerDocument is not null:
</p>
				<ol>
					<li>
~IF［
( %容器~文書 の`生成元$doc, %行先~生成元 )
は`同一-生成元$でない
］
⇒
~RET ~F
◎
If containerDocument's origin is not same origin with destinationOrigin, then return false.
</li>
					<li>
%容器~文書 ~SET %容器~文書 の`容器~文書$doc
◎
Set containerDocument to containerDocument's container document.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~RET ~T
◎
Return true.
</p>

<p class="note">注記：
ここまで達した場合、
妥当でない 1 個の値からなる（旧来の［
`ALLOWALL^bl ／ `ALLOW-FROM^bl
］形も該当する）
— この場合、
~headerは まるごと省略されていたかのように扱う。
◎
If we've reached this point then we have a lone invalid value (which could potentially be one the legacy `ALLOWALL` or `ALLOW-FROM` forms). These are treated as if the header were omitted entirely.
</p>
	</li>
</ol>
</div>

<hr>

<div class="example">
<p>
この~header用の様々な値の処理を
— 不適合tなものも含め —
次の表tに示す：
◎
The following table illustrates the processing of various values for the header, including non-conformant ones:
</p>

<div>
<table><thead>
<tr><th>`X-Frame-Options$h
<th>妥当か？
<th>結果
<tbody>

<tr><td>`DENY^bl
<td>✅
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN^bl
<td>✅
<td>同一-生成元なら埋込みは許容される

<tr><td>`INVALID^bl
<td>❌
<td>埋込みは許容される

<tr><td>`ALLOWALL^bl
<td>❌
<td>埋込みは許容される

<tr><td>`ALLOW-FROM=https://example.com/^bl
<td>❌
<td>埋込みは許容される（どこからでも）

</table>
◎
`X-Frame-Options`｜Valid｜Result
`DENY`｜✅｜embedding disallowed
`SAMEORIGIN`｜✅｜same-origin embedding allowed
`INVALID`｜❌｜embedding allowed
`ALLOWALL`｜❌｜embedding allowed
`ALLOW-FROM=https://example.com/`｜❌｜embedding allowed (from anywhere)
</div>
</div>


<div class="example">
<p>
複数の値を孕んでいる，様々な不適合tな事例がどう処理されるかを，次の表tに示す：
◎
The following table illustrates how various non-conformant cases involving multiple values are processed:
</p>

<div>
<table><thead>
<tr><th>`X-Frame-Options$h
<th>結果
<tbody>

<tr><td>`SAMEORIGIN, SAMEORIGIN^bl
<td>同一-生成元なら埋込みは許容される

<tr><td>`SAMEORIGIN, DENY^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN,^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN, ALLOWALL^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN, INVALID^bl
<td>埋込みは許容されない

<tr><td>`ALLOWALL, INVALID^bl
<td>埋込みは許容されない

<tr><td>`ALLOWALL,^bl
<td>埋込みは許容されない

<tr><td>`INVALID, INVALID^bl
<td>埋込みは許容される
</table>

◎
`X-Frame-Options`｜Result
`SAMEORIGIN, SAMEORIGIN`｜same-origin embedding allowed
`SAMEORIGIN, DENY`｜embedding disallowed
`SAMEORIGIN,`｜embedding disallowed
`SAMEORIGIN, ALLOWALL`｜embedding disallowed
`SAMEORIGIN, INVALID`｜embedding disallowed
`ALLOWALL, INVALID`｜embedding disallowed
`ALLOWALL,`｜embedding disallowed
`INVALID, INVALID`｜embedding allowed
</div>

<p>
値たちが［
~commaで区切られた値を伴う 1 個の~header,
複数個の~header
］どちらで送達されようが，得される結果は同じになる。
◎
The same results are obtained whether the values are delivered in a single header whose value is comma-delimited, or in multiple headers.
</p>
</div>

		</section>
		<section id="the-refresh-header">
<h3 title="The Refresh header">7.8. `Refresh$h ~header</h3>

<p>
`Refresh@h
~HTTP応答~headerは、［
`meta$e 要素のうち，その `http-equiv$a 属性は `~refresh$st 状態にあるもの
］を~HTTPにおいて等価に~~表現するものである。
それは，
`同じ値＠~HEmetadata#conformance-attr-meta-http-equiv-refresh$をとり，ほとんど同じに働く。
その処理~modelの詳細は、
`文書を作成して初期化する$にて与えられる。
◎
The `Refresh` HTTP response header is the HTTP-equivalent to a meta element with an http-equiv attribute in the Refresh state. It takes the same value and works largely the same. Its processing model is detailed in create and initialize a Document object.
</p>

		</section>
		<section id="nav-traversal-ui">
<h3 title="Browser user interface considerations">7.9. ~browser~UIの考慮点</h3>

<p>
~browser~UAは、
自身の`~top-level辿可能~集合$に属する どの`~top-level辿可能$に対しても，
次に挙げる能を【利用者~向けに（以下同様）】供するベキである
⇒
`~navigateする$／
`読込直す$／
`読込ngを停止する$
◎
Browser user agents should provide the ability to navigate, reload, and stop loading any top-level traversable in their top-level traversable set.
</p>

<p class="example">
例えば、［
~URL~bar／
“読込直す” ~button／
“停止する” ~button
］などの~UIを介して。
◎
For example, via a location bar and reload/stop button UI.
</p>

<p>
~browser~UAは、
自身の`~top-level辿可能~集合$に属する どの`~top-level辿可能$に対しても，
`履歴を差分だけ辿る$能を供するベキである。
◎
Browser user agents should provide the ability to traverse by a delta any top-level traversable in their top-level traversable set.
</p>

<p class="example">
例えば、［
戻る／進む
］~buttonを介して
— 場合によっては、
長押しにより差分を変更する能も含めて。
◎
For example, via back and forward buttons, possibly including long-press abilities to change the delta.
</p>

<p>
そのような~UAは、
2 以上の差分による辿りも許容することが示唆される
— ~pageが［
~session履歴に偽りな~entryを
（例えば，［
`history.pushState()＠~WINDOW#dom-history-pushstate$c の~callや`素片へ~navigateする$こと
］を繰返すことを介して）
詰め込む
］ことにより，利用者を “罠に嵌める” のを避けるため。
◎
It is suggested that such user agents allow traversal by deltas greater than one, to avoid letting a page "trap" the user by stuffing the session history with spurious entries. (For example, via repeated calls to history.pushState() or fragment navigations.)
</p>

<p class="note">注記：
一部の~UAは、
特定的にそのような濫用を克服するために，［
“戻る” ／ “進む”
］~buttonが 1 回だけ押されたとき より大きい差分に翻訳する経験則を備える。
`課題 #7832＠~HTMLissue/7832$ にて，
これらの経験則を指定することが~~検討されている。
◎
Some user agents have heuristics for translating a single "back" or "forward" button press into a larger delta, specifically to overcome such abuses. We are contemplating specifying these heuristics in issue #7832.
</p>

<p>
~browser~UAは、
`新鮮な~top-level辿可能を作成する$能を利用者に提供するベキである
— ［
利用者が供した／~UAにより決定される
］初期`~URL$を与えて。
◎
Browser user agents should offer users the ability to create a fresh top-level traversable, given a user-provided or user agent-determined initial URL.
</p>

<p class="example">
例えば［
“新たな~UItab” ／ “新たな~UIwindow”
］~buttonを介して。
◎
For example, via a "new tab" or "new window" button.
</p>

<p>
~browser~UAは、
自身の`~top-level辿可能~集合$に属する どの`~top-level辿可能$に対しても，
利用者が任意に`~top-level辿可能を閉じる$能を提供するベキである。
◎
Browser user agents should offer users the ability to arbitrarily close any top-level traversable in their top-level traversable set.
</p>

<p class="example">
例えば、
“~UItabを閉じる” ~buttonを~clickすることにより。
◎
For example, by clicking a "close tab" button.
</p>

<hr>

<p>
~browser~UAは、
利用者~向けに，`~navigable$（`~top-level辿可能$に限らず）を明示的に［
`~navigateする$／`読込直す$／`読込ngを停止する$
］仕方を供してもヨイ。
◎
Browser user agents may provide ways for the user to explicitly cause any navigable (not just a top-level traversable) to navigate, reload, or stop loading.
</p>

<p class="example">
例えば，文脈~menuを介して。
◎
For example, via a context menu.
</p>

<p>
~browser~UAは、
利用者~向けに，`~top-level辿可能を破壊する$能を供してもヨイ。
◎
Browser user agents may provide the ability for users to destroy a top-level traversable.
</p>

<p class="example">
例えば、［
そのような`~top-level辿可能$を複数~個 包含している~UIwindowを閉じる
］よう強制することにより。
◎
For example, by force-closing a window containing one or more such top-level traversables.
</p>

<hr>

<p>
利用者から`~navigable$を`読込直す$よう要請されたとき，
その`作動中な~entry$navの`文書~状態$shEの`資源$dSが`~POST資源$である場合には、
~UAは，先ず利用者に その操作oを確認してもらうよう~promptするベキである
— さもなければ、
~transaction（例：購入や~database改変）が繰返され得るので。
◎
When a user requests a reload of a navigable whose active session history entry's document state's resource is a POST resource, the user agent should prompt the user to confirm the operation first, since otherwise transactions (e.g., purchases or database modifications) could be repeated.
</p>

<p>
~UAは，利用者から`~navigable$を`読込直す$よう要請されたときは、
読込直す際に~cacheを無視するための仕組みを供してもヨイ。
◎
When a user requests a reload of a navigable, user agents may provide a mechanism for ignoring any caches when reloading.
</p>

<hr>

<p>
`~navigateする$~callが上で言及した仕組みにより起動される場合、
その引数 %利用者-関与i に `~browser~UI$i を渡すモノトスル。
◎
All calls to navigate initiated by the mechanisms mentioned above must have the userInvolvement argument set to "browser UI".
</p>

<p>
`読込直す$~callが上で言及した仕組みにより起動される場合、
その引数 %利用者-関与i に `~browser~UI$i を渡すモノトスル。
◎
All calls to reload initiated by the mechanisms mentioned above must have the userInvolvement argument set to "browser UI".
</p>

<p>
`履歴を差分だけ辿る$
~callが上で言及した仕組みにより起動される場合、
その引数 %~source文書 には値を渡さないモノトスル。
◎
All calls to traverse the history by a delta initiated by the mechanisms mentioned above must not pass a value for the sourceDocument argument.
</p>

<hr>

<p>
上に挙げた推奨, および
この仕様における~data構造には、［
~UAが利用者に~session履歴をどう表現するかに対し制約を設置する
］ことは意味されない。
◎
The above recommendations, and the data structures in this specification, are not meant to place restrictions on how user agents represent the session history to the user.
</p>

<p>
例えば、
`~top-level辿可能$の`~session履歴~entry群$tnは，
~listとして［
格納され, 保守される
］
— ~UAには、
`履歴を差分だけ辿る$ための~UIを与えることが推奨される —
が、
先進的な~UAは，それに［
代えて／加えて
］~treeの様な~viewを呈示して，［
各~pageが複数の “進む” ~pageを備えていて，利用者がそれらを選べる
］ようにすることもできる。
◎
For example, although a top-level traversable's session history entries are stored and maintained as a list, and the user agent is recommended to give an interface for traversing that list by a delta, a novel user agent could instead or in addition present a tree-like view, with each page having multiple "forward" pages that the user can choose between.
</p>

<p>
類似に、
`辿可能な~navigable$内には，［
そのすべての子孫`~navigable$
］用の~session履歴が格納されるが、
~UAは，もっと仔細に［
`~navigable$ごとに，~session履歴の~viewを利用者に呈示する
］こともできる。
◎
Similarly, although session history for all descendant navigables is stored in their traversable navigable, user agents could present the user with a more nuanced per-navigable view of the session history.
</p>

<hr>

<p>
~browser~UAは、
`~top-level閲覧~文脈$の`~popupか$bcを次に挙げる目的に利用してもヨイ：
◎
Browser user agents may use a top-level browsing context's is popup boolean for the following purposes:
</p>
<ul>
	<li>
対応している`~top-level辿可能$用に必要最小限な~web~browser~UIを供するかどうかを裁定する。
◎
Deciding whether or not to provide a minimal web browser user interface for the corresponding top-level traversable.
</li>
	<li>
`閲覧~文脈の特能を設定しておく$とき，その中の任意選択な各~段を遂行する所。
◎
Performing the optional steps in set up browsing context features.
</li>
</ul>

<p>
どちらの事例においても、
~UAは，それに加えて［
利用者-選好を組入れる／
~popup~routeを奥へ進む選択肢を呈示する
］こともできよう。
◎
In both cases user agents might additionally incorporate user preferences, or present a choice as to whether to go down the popup route.
</p>

<p>
~UAは、［
そのような~popup用に必要最小限な~UIを供する場合でも，
~browserの~URL~barは隠さない
］ことが奨励される。
◎
User agents that provide a minimal user interface for such popups are encouraged to not hide the browser's location bar.
</p>

		</section>
</main>
