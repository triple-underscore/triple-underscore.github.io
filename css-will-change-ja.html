<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Will Change Module Level 1 （日本語訳）</title>


<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	return this.html.replace(
		/`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Will Change Module Level 1
spec_date:2022-04-29
trans_update:2022-04-30
source_checked:200918
page_state_key:CSS
original_url:https://drafts.csswg.org/css-will-change-1/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-ux,css
conformance:css
copyright:2022,permissive
trans_1st_pub:2015-01-30


●●class_map
p:property
t:type
css:css
v:value

●●tag_map
p:code
t:var
css:code
v:code
V:var
em:em

●●original_id_map

●●mdn_urls
propdef-will-change:CSS/will-change

●●link_map


p.will-change:#propdef-will-change
p.background:~CSSBG#propdef-background
p.opacity:~CSSCOLOR#propdef-opacity
p.transform:~TRANSFORM#propdef-transform
p.image-rendering:~CSSIMAGE#propdef-image-rendering
t.animateable-feature:#typedef-animateable-feature
v.auto:#valdef-will-change-auto
v.scroll-position:#valdef-will-change-scroll-position
v.contents:#valdef-will-change-contents
t.custom-ident:~CSSVAL#identifier-value
	t.custom-ident:#valdef-will-change-custom-ident
	~CSSVAL#identifier-value

下位prop:~CASCADE#longhand
略式~prop:~CASCADE#shorthand
包含塊:~CSSDISP#containing-block
固定的に位置され:~CSSPOS#fixed-position
絶対的に位置され:~CSSPOS#absolute-position
積層~文脈:~CSS2J#stacking-context

~custom~prop:~CSSVAR#custom-property
~ASCII大小無視:~INFRA#ascii-case-insensitive

●●words_table1


●●words_table



	●will change
GPU:
caching:::キャッシュ処理
	描画し直す:re-render
	再~描画-:rerender
	再~描画:rerendering
	~scroll可能:scrollable
	~scroll時:scrolling
窓:window:~::ウィンドウ

復帰-:revert:~
応答性:responsiveness:~
変化ng:changing:変化
定期的:constant:~
定常的:regular:~
持続的:persistent:~
断続的:continual:~
毎回:continualに:~

滑らか:smooth:~
	~~専用の:own:~
過利用-:overuse:濫用
枯渇-:exhaust:~
浪費:waste:~
準備:preparation:~
	準備:preparing
節約:saving:~
省力化:skip:~
高価:expensive:~
請求-:claim:~
	設定しておく:set up
素早く:quickに:~
機敏:snappy:~
急な:sudden:~
速さ:speed:~
	より速く:faster
遅く:slowに:~
遅いの:slowなの:~
滑らす:slideする:~
始動-:start-up:~
カクつき:jank:~
時機:time:~
新規:fresh:~
止めた:stopした:~
目立って:noticeableに:~
害:harm:~

	され続け:kept
	事前に:ahead-of-time
	前まで:ahead of time
	一呼吸おいて:few moments away
	設置／撤去する:flipped on and off
	何分の一秒か:fraction of a second
	予定にある:will
	猶予:lead time／:time to／:time to work
	後で:eventual
	秒間に何度も:many times per second
	先行して／とにかく:go ahead
	ずっと長く:much longer
	より長く:longer

	●CSS
	~animate不可:not animatable
	animating:::
hover:::
hovering:::
積層:stacking:~
変形:transform::~
変形n:transformation::変形
発話:speech::~::スピーチ
固定的:fixed::~

	●仕様
控えめ:sparing:~
一から:scratchから:~
本当:real:~
上手:well:~
事実:fact:~
学ぶ:learnする:~
自明:trivial:~
	自明でない:non-trivial
悪い:bad:~
稀:rare:~
助ける:helpする:~
助け:help:~
昇格-:promote:~
指図-:tell:~
	~~適用:make
束ねら:tieさ:~
提起-:raise:~
説明的:explanatory:~
為す:makeする:~
積極的:aggressive:~
策:strategy:~

	〜に:simply
	だろ？:right?
	否。:wrong
	良さそう:good idea
	役に立たない:useless
	〜べく:meant
	と見込まれる:likely
	まず見込まれない:very unlikely
	~hintを与える:hinting
	ある面:aspects
	であろう:hopefully
	地位を高める:high up
	~~原則:“Dos and Don’ts”
	やれる限りの労力を費や:tries as hard as
	必要になる:need
	~~方式:strategy
	ばら撒く:spam
	申し分ない:fine
	かまわない:fine
	-:manner
	because
	though
	since
	about
	you
	your
	用-法:how to use
	しないよう:avoid
	伴う-:involve
	忘れ:forget
	直感を養う:develop a good intuition
	織り込む:count する
	思える:assume
	一見すると:A common initial response to seeing
	~~問題:hurt
	~security:Security
	~privacy:Privacy
	小さな:minor

	●未分類
crash::::クラッシュ
組成-:composite:~
回復-:recover:~
延長-:expand:~
移動:movements:~
anti-aliasing::::アンチエイリアシング
capacity:::
machine::::マシン
	milliseconds:::ミリ秒
種類:kind:~
旧い:old:~

	~web~page:webpage
	始ま:begin
	はみ出す:past
	伝え:inform
	限-:limit
	make
	begin
	going
	using
	do
	cause
	take
	end up
	他の:down-level
	JS
	見栄え:look nice
	対応する下位~prop:the longhands the shorthand expands 
	~prop定義:propdef
	欄:entry

	●指示語

	ある種の:certain types
	同じことに:identical
	〜の類:sort of
	残り:rest
	に足る:sufficient な
	異なる:differ
	違える:difference
	こともある:sometime
	周囲:around
	全く:at all
	近い:near
	ほぼ:nearly
	少しばかり:slightly
	少なくとも:least
	最初に:originally
	何しろ:After all,
	多い／頻繁:often
	およそ:more-or-less
	あらゆるもの:everything
	少数の:small number of
	ごく限られる:has very little, if any
	薄い／少ない:little
	later
	引っ張る要因:very bad
	さほど:very much
	大きく／まず／さほど〜:very
	高い:high
	only
	which
	末端:bottom
	~~主に:mostly
	より強い:stronger
	大きな／多量に／たくさんの:a lot of
	所がある:somewhat
	like
	when
	where
	these
	that
	they
	them
	their
	thing
	those
	between
	some
	very
	there
	every
	much
	-otherwise
	such
	-:whenever
	-:whatever
	many
	less
	just
	most
	down
	even
	soon
	against
	away


●●ref_normative

[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. 16 December 2021. WD. URL: https://www.w3.org/TR/css-values-4/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS21/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119

●●ref_informative

[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. 26 July 2021. CR. URL: https://www.w3.org/TR/css-backgrounds-3/
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley; Lea Verou. ＜CSS Color Module Level 4＞. 15 December 2021. WD. URL: https://www.w3.org/TR/css-color-4/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Will Change Module Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-will-change-1/
公表履歴
	https://www.w3.org/standards/history/css-will-change-1/

実装報告
	https://wpt.fyi/results/css/css-will-change
テスト一式
	https://wpt.fyi/results/css/css-will-change
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-will-change-1">CSSWG Issues Repository</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-will-change-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-will-change-1

</script>

</head>
<body>

<header>
	<hgroup>
<h1>CSS Will Change Module Level 1</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は `will-change$p ~CSS~propを定義する。
それは、［
要素に対し為すものと見込まれる変更の種類を事前に~UAに伝える
］ことを作者に許容する。
これは、
当の要素の取扱いを事前に最適化すること
— ~animationが実際に始まる前に，高価になり得る準備~作業を遂行しておくなど —
を~UAに許容する。
◎
This document defines the will-change CSS property, which allows an author to inform the UA ahead of time of what kinds of changes they are likely to make to an element. This allows the UA to optimize how they handle the element ahead of time, performing potentially-expensive work preparing for an animation before the animation actually begins.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">
	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
現代の~CSS描画器は、
~web~pageを素早く効率的に描画する†ために，いくつもの複階的な最適化を遂行する。
あいにく，これらの最適化を使役する下では、
~pageの応答性に負な影響iを及ぼし得るような自明でない始動~costを要することが多い。
◎
Modern CSS renderers perform a number of complex optimizations in order to render webpages quickly and efficiently. Unfortunately, employing these optimizations often has a non-trivial start-up cost, which can have a negative impact on the responsiveness of a page.
</p>

<p class="trans-note">【†
`render^en する
（より一般には，具現化する）
— 発話~媒体であれば “音声化する”, 等々
（以下，単に “描画” と記す）。
が、
すべての内容が “同時に” 表示される視覚-媒体と違って，
この仕様を成す大部分は，発話~媒体には［
効果がない／関連しない
］であろう。
】</p>

<div class="example">
<p>
例えば，要素を~screenのあちこちへ移動させるために~CSS 3D 変形を利用するとき、
要素とその内容は，一つの “層” に昇格される
— ~pageの残りから独立に描画しておいて，後から組成できるよう。
これは、
各~frame間で変化するものが要素の変形に限られるならば，
~pageの残りを再~描画せずに済むよう内容の描画を隔離するので、
速さの便益を有意に供することが多い。
◎
For example, when using CSS 3D Transforms to move an element around the screen, the element and its contents might be promoted to a “layer”, where they can render independently from the rest of the page and be composited in later. This isolates the rendering of the content so that the rest of the page doesn’t have to be rerendered if the element’s transform is the only thing that changes between frames, and often provides significant speed benefits.
</p>

<p>
しかしながら、
要素を新規な層に設定しておくことは，相対的に高価な演算である
— その結果，
`transform$p ~animationの開始が何分の一秒か目立って遅延することもある。
◎
However, setting up the element in a fresh layer is a relatively expensive operation, which can delay the start of a transform animation by a noticeable fraction of a second.
</p>
</div>

<p>
この仕様にて定義される `will-change$p ~propは、［
どの~propが未来に変化すると見込まれるかを事前に宣言する
］ことを作者に許容する
— なので、
~UAは，必要になる前に適切な最適化を設定しておけるようになる。
このようにして、
実際に変化が起きたときには，~pageは機敏に更新される。
◎
The will-change property defined in this specification allows an author to declare ahead-of-time what properties are likely to change in the future, so the UA can set up the appropriate optimizations some time before they’re needed. This way, when the actual change happens, the page updates in a snappy manner.
</p>

		<section id="values">
<h3 title="Value Definitions">1.1. 値~定義</h3>

<p class="trans-note">【
この節を成す内容は、
`~CSS日本語訳 共通~page＠~CSScommon#values$に移譲。
】</p>

		</section>
		<section id="using">
<h3 title="Using will-change Well">1.2. `will-change$p の上手な利用-法</h3>

<p>
他の処理能~hintと同様に、
`will-change$p ~propも，その “適正な” 用-法を学ぶには困難な所がある
— 作者が直に検出できる効果は，ごく限られるので。
しかしながら、
`will-change$p の上手な用-法について直感を養う助けになるであろう，
単純な~~原則がいくつかある。
◎
The will-change property, like all performance hints, can be somewhat difficult to learn how to use “properly”, particularly since it has very little, if any, effect an author can directly detect. However, there are several simple “Dos and Don’ts” which hopefully will help develop a good intuition about how to use will-change well.
</p>

			<section id="dont-global">
<h4 title="Don’t Spam will-change Across Too Many Properties or Elements">`will-change^p を多数の~propや要素にばら撒かないこと</h4>

<p>
一見すると、
次の様な~codeで `will-change$p を用いれば良さそうに思えるかもしれない：
◎
A common initial response to seeing will-change is to assume that code like this is a good idea:
</p>

<pre class="lang-css">
* { will-change: transform, opacity /* , ... */; }
</pre>

<p>
何しろこれは、
~browserに，とにかくあらゆるものを最適化せよと指図する
— これで良い筈だろ？
◎
After all, this tells the browser to go ahead and optimize everything, which has to be good right?
</p>

<p>
否。
~browserは `すでに^em，あらゆるものを最適化するよう やれる限りの労力を費やしている。
明示的にそうするよう指図した所で、
何の助けにもならない
— 事実，かえって大きな害になる~~可能性もある。
`will-change$p に束ねられると見込まれる，より強い最適化には、
~machineの資源を多量に利用させるものもあり、
この様に過利用された場合，~pageが遅くなったり, ~crashすることすらある。
◎
Wrong. The browser already tries as hard as it can to optimize everything. Telling it to do so explicitly doesn’t help anything, and in fact has the capacity to do a lot of harm; some of the stronger optimizations that are likely to be tied to will-change end up using a lot of a machine’s resources, and when overused like this can cause the page to slow down or even crash.
</p>

<p>
加えて， `will-change$p には、
<strong>ある副作用</strong>がある
— ~page内の要素すべてが実際にその副作用を求めることは，まず見込まれない。
◎
In addition, will-change does have some side-effects, and it’s very unlikely that pages actually want all those side-effects on every element.
</p>

			</section>
			<section id="css-sparingly">
<h4 title="Use will-change Sparingly In Stylesheets">~stylesheet内では `will-change^p を控えめに利用すること</h4>

<p>
~stylesheet内で `will-change$p を直に利用することは、
~targetにされた要素は，常に一呼吸おいてから変化することを含意する。
作者が実際にそう~~意図することは、
`通例的^emにはない
— `will-change$p は、
通例的には，変化が生じる［
前／後
］に~scriptingを介して［
設置／撤去
］されるべきである
（`§ 変化ngを止めた要素には，資源を浪費させないこと＠#dont-waste$
を見よ）。
しかしながら、
~stylesheet内で `will-change$p を直に利用することが適切になるような，
共通的な状況下もある。
◎
Using will-change directly in a stylesheet implies that the targeted elements are always a few moments away from changing. This is usually not what you actually mean; instead, will-change should usually be flipped on and off via scripting before and after the change occurs (see Don’t Waste Resources On Elements That Have Stopped Changing). However, there are some common circumstances in which it is appropriate to use will-change directly in a stylesheet.
</p>

<div class="example">
<p>
例えば，［
利用者に対し機敏に反応すべきような，~page内の少数の持続的な~UI要素
］用に `will-change$p を指定することは、
適切になる：
◎
For example, specifying will-change for a small number of persistent UI elements in a page which should react snappily to the user is appropriate:
</p>

<pre class="lang-css">
body &gt; .sidebar {
   will-change: transform;
   /* <span class="comment">
利用者から要請され次第 要素を外へ滑らす `transform^p を利用する予定にある。
◎
Will use 'transform' to slide it out when the user requests.
</span> */
}
</pre>

<p>
これは，少数の要素に限られているので、
最適化が実際には稀にしか利用されないとしても，さほど~~問題にならない。
◎
Because this is limited to a small number of elements, the fact that the optimization is rarely actually used doesn’t hurt very much.
</p></div>

<div class="example">

<p>
要素の~propは、
`本当に^em，ほぼ定期的に変化することもある。
たぶん、［
利用者による~mouse移動／単に定常的に行われる何らかの動作
］に応答して，~animationを生じさせるような。
そのような事例では、
~stylesheet内に `will-change$p 値を宣言するだけで申し分ない
— それは、［
要素は［
定常的／定期的
］に変化する予定にあるので，最適化され続けるべきである
］ことを正確aに述べているので。
◎
Sometimes an element really does change a property nearly constantly. Perhaps it responds to the user’s mouse movements, or just regularly takes some action that causes an animation. In this case, just declaring the will-change value in the stylesheet is fine, as it accurately describes that the element will regularly/constantly change, and so should be kept optimized.
</p>

<pre class="lang-css">
.cats-flying-around-the-screen {
  will-change: left, top;
}
</pre>

</div>

			</section>
			<section id="give-time">
<h4 title="Give will-change Sufficient Time To Work">`will-change^p が働くに足る猶予を与えること</h4>

<p>
要素の［
~animation／~prop変化
］を助けるべく，それが開始される`直前に^em `will-change$p を適用することも、
別の共通的な悪い~patternである。
あいにく，この種の最適化のほとんどは、
適用されるまで時間を要する
— このようにした場合、
設定しておく十分な猶予がないので， `will-change$p の効果は薄い。
代わりに、
少なくとも何かが変化する`少し前まで^emに
— それを予測するような何らかの仕方を見出した上で —
`will-change$p を設定すること。
◎
Another common bad pattern is to apply will-change to an element immediately before starting the animation or property change that it’s meant to help with. Unfortunately, most of those optimizations need time to be applied, and so they don’t have enough time to set-up when this is done, and the will-change has little to no effect. Instead, find some way to predict at least slightly ahead of time that something will change, and set will-change then.
</p>

<div class="example">
<p>
例えば，利用者が~clickしたとき要素が変化するのであれば、
~hover時に `will-change$p を設定することで，
最適化を設定しておく猶予として通例的には 200 ミリ秒~以上が与えられる
— ヒトの反応~時間は相対的に遅いので。
これは、
~scriptingを介して, あるいは単純に~CSS規則でも行える：
◎
For example, if an element is going to change when a user clicks on it, setting will-change on hover will usually give at least 200 milliseconds for the optimizations to be set up, as human reaction time is relatively slow. This can be done either via scripting, or rather simply with a CSS rule:
</p>

<pre class="lang-css">
.element { transition: opacity .2s; opacity: 1; }
.element:hover { will-change: opacity; }
.element:active { opacity: .3; }
</pre>

<p>
しかしながら，この様な規則は、
当の効果が~hover時に起こる場合には，役に立たない。
そのような場合でも、
動作が生じる前に予測する仕方を見出せることは多いが。
この事例では、
要素の先祖~上に~hoverしたとき設定することで，十分な猶予を与え得る：
◎
However, a rule like that is useless if the effect is going to happen on hover. In cases like these, it is often still possible to find some way to predict the action before it occurs. For example, hovering an ancestor may give enough lead time:
</p>

<pre class="lang-css">
.element { transition: opacity .2s; opacity: 1; }
.container:hover &gt; .element { will-change: opacity; }
.element:hover { opacity: .3; }
</pre>

</div>

			</section>
			<section id="dont-waste">
<h4 title="Don’t Waste Resources On Elements That Have Stopped Changing">変化ngを止めた要素には，資源を浪費させないこと</h4>

<p>
一部の~propは，変化するときに~browserが利用する最適化が高価になるので、
通常の状況下では，~browserは できるだけ早く それらを除去して通常の挙動に復帰しようとする。
しかしながら， `will-change$p は、
一般に，この挙動を上書きして最適化をずっと長く保守させる。
◎
Because the optimizations browsers use for changing some properties are expensive, browsers remove them and revert to normal behavior as soon as they can in normal circumstances. However, will-change will generally override this behavior, maintaining the optimizations for much longer than the browser would otherwise do.
</p>

<p>
そのようなわけで，とりわけ~scriptingを介して要素に `will-change$p を追加するときは、
最適化から請求された資源を~browserが回復できるよう，
要素が変化し終えた後には `will-change$p を`除去し忘れない^emこと。
◎
As such, whenever you add will-change to an element, especially via scripting, don’t forget to remove it after the element is done changing, so the browser can recover whatever resources the optimizations are claiming.
</p>

			</section>
		</section>
	</section>
	<section id="will-change">
<h2 title="Hinting at Future Behavior: the will-change property">2. 未来の挙動について~hintを与える： `will-change^p ~prop</h2>

<div>
◎名 `will-change@p
◎値 `auto$v | `animateable-feature$t#
◎初 `auto$v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア ~animate不可
◎表終
◎
Name: 	will-change
Value: 	auto | &lt;animateable-feature&gt;#
Initial: 	auto
Applies to: 	all elements
Inherited: 	no
Percentages: 	n/a
Computed value: 	specified value
Canonical order: 	per grammar
Animation type: 	not animatable
</div>

<pre class="prod">
`animateable-feature@t
	= `scroll-position$v
	| `contents$v
	| `custom-ident$t
</pre>

<p>
`will-change$p ~propは、
~UAに描画~hintを供する
— それは、
作者が要素~上で遂行するものと予期する変化の種類を言明する。
これは、［
その変化ngの滑らかな描画に必要yな最適化を事前に遂行しておくこと
］を~UAに許容することにより，
作者が当の特能を［
変化させ／~animateさせ
］始めたときの “カクつき” を避けれるようにする。
◎
The will-change property provides a rendering hint to the user agent, stating what kinds of changes the author expects to perform on the element. This allows the user agent to perform ahead-of-time any optimizations necessary for rendering those changes smoothly, avoiding “jank” when the author does begin changing or animating that feature.
</p>

<p class="note">
`will-change$p からの情報を利用する仕方は，~browserごとに異なる。
同じ~browserであっても，時機によって利用する仕方が異なることすらある。
例えば，要素の `will-change$p に `transform^v が指定されたときは、
~browserは，要素を~~専用の “~GPU層” に昇格させるが、
そのように宣言された要素が`多過ぎる^emときは，
~GPU~memoryが枯渇しないよう それを避けることもある。
◎
Different browsers can use the information from will-change in different ways, and even a single browser might use it in different ways at different time. For example, a browser that promotes elements to their own “GPU layer” when they have will-change: transform specified might avoid doing that when there are too many elements declaring that, to avoid exhausting GPU memory.
</p>

<p>
各種 値の意味は：
◎
Values have the following meanings:
</p>

<dl>
	<dt>`auto@v</dt>
	<dd>
特に意図は無いことを表出する
— ~UAは、
通常に行う［
経験則／最適化
］を適用するべきである。
◎
Expresses no particular intent; the user agent should apply whatever heuristics and optimizations it normally does.
</dd>

	<dt>`scroll-position@v</dt>
	<dd>
作者が次を予期していることを指示する
⇒
近い未来に要素の~scroll位置を［
~animate／変化-
］させる。
◎
Indicates that the author expects to animate or change the scroll position of the element in the near future.
</dd>
	<dd class="example">
例えば，~browserは、
~scroll可能な要素~上の［
“~scroll窓” 内にある内容と, その窓をはみ出る一部の内容
］のみを描画することが多い
— 描画の省力化による［
~memory／時間
］の節約と~scroll時の見栄えを天秤にかけながら。
この値は、［
~scrollがより［
長く／速く
］行われても滑らかになる
］よう［
描画する内容の範囲を~scroll窓の周囲から延長する
］べきであることを~browserに通達する。
◎
For example, browsers often only render the content in the "scroll window" on a scrollable element, and some of the content past that window, balancing memory and time savings from the skipped rendering against making scrolling look nice. A browser might take this value as a signal to expand the range of content around the scroll window that is rendered, so that longer/faster scrolls can be done smoothly.
</dd>

	<dt>`contents@v</dt>
	<dd>
作者が次を予期していることを指示する
⇒
近い未来に要素の何らかの内容を［
~animate／変化-
］させる。
◎
Indicates that the author expects to animate or change something about the element’s contents in the near future.
</dd>
	<dd class="example">
<p>
例えば、
~browserは，要素の描画を時間~越しに “~cacheする” ことが多い
— 大抵の場合、
要素はさほど~~頻繁には変化しないか, 変化するとしても位置に限られるので。
しかしながら，要素の内容が `断続的に変化する^em 場合、
この~cacheを生産して保守することは，時間の浪費になる。
この値は、［
要素の描画を積極的には~cacheしないか，
まったく~cacheせずに毎回 要素を一から描画し直す
］べきであることを~browserに通達する。
◎
For example, browsers often “cache” rendering of elements over time, because most things don’t change very often, or only change their position. However, if an element does change its contents continually, producing and maintaining this cache is a waste of time. A browser might take this value as a signal to cache less aggressively on the element, or avoid caching at all and just continually re-render the element from scratch.
</p>

<p>
この値は、［
要素の内容を成すある側面が秒間に何度も変化するような，
~JSに基づく内容の~animation
］に対する~browserによる最適化を助けることが~~主に意図される。
~browserによる この種の最適化は、
宣言的~animationに対しては，すでにアリな限り自動的に行われている
【そのように`規定されてもいる＠~WANIM#side-effects-section$】。
◎
This value is mostly intended to help browsers optimize JS-based animations of content, which change aspects of an element’s contents many times per second. This kind of optimization, when possible, is already done automatically by browsers when declarative animations are used.
</p>
	</dd>
	<dd class="note">注記：
この値は、
およそ［
それが宣言された要素を根とする下位tree全体
］に適用される
— それは、［
何らかの仕方で変化する子孫は，`何であれ^em 織り込むべきである
］ことを~browserに指示するので。
これを利用すると、
文書における要素の “地位が高められる” 結果，
~pageの処理能を引っ張る~~要因になり得る。
よって、
アリな限り文書の少ない部分を包含するような，
文書~treeの “末端” に近い要素のみに利用することを~~勧める。
◎
Note: This value more-or-less applies to the entire subtree of the element its declared on, as it indicates the browser should count on *any* of the descendants changing in some way. Using this on an element “high up” in your document might be very bad for your page’s performance; try to only use this on elements near the “bottom” of your document tree, containing as little of the document as possible.
</dd>

	<dt id="valdef-will-change-custom-ident">`custom-ident$t</dt>
	<dd>
所与の `custom-ident^t が ある組込みの~CSS~prop
— 以下， `~prop^V と記す —
の名前に`~ASCII大小無視$で合致する場合、
作者が次を予期していることを指示する
⇒
近い未来に当の要素の `~prop^V を［
~animate／変化-
］させる。
◎
If the &lt;custom-ident&gt; is an ASCII case-insensitive match for the name of a built-in CSS property, it indicates that the author expects to animate or change the property with the given name on the element in the near future.＼
</dd>
	<dd>
<p>
`~prop^V が`略式~prop$である場合、
対応するすべての`下位prop$に対する予期を指示する。
◎
If the property given is a shorthand, it indicates the expectation for all the longhands the shorthand expands to.
</p>

<p class="example">
例えば，
`will-change$p に `background^v を設定することは、
`background$p の`下位prop$すべてに渡るよう
`will-change$p に `background-image, background-position, ...^v
を設定することと同じことになる。
◎
For example, setting will-change: background; is identical to setting will-change: background-image, background-position, ... for all the properties that background expands into.
</p>
	</dd>
	<dd>
ここでの `custom-ident^t 生成規則からは、
`custom-ident$t から通常に除外される~keywordに加えて，
次に挙げる~keywordも除外される
⇒＃
`will-change^v,
`none^v,
`all^v,
`auto$v,
`scroll-position$v,
`contents$v
◎
The &lt;custom-ident&gt; production used here excludes the keywords will-change, none, all, auto, scroll-position, and contents, in addition to the keywords normally excluded from &lt;custom-ident&gt;.
</dd>
	<dd class="note">注記：
ほとんどの~propは、
指定されたとしても効果はない
— ~UAは、
ほとんどの~propに対しては，
その変化に際し特別な最適化を遂行しないので。
指定したとしても，`安全である^emが、
単純に効果がないことになる。
◎
Note: Note that most properties will have no effect when specified, as the user agent doesn’t perform any special optimizations for changes in most properties. It is still safe to specify them, though; it’ll simply have no effect.
</dd>
	<dd>
`~prop^V として`~custom~prop$が指定された場合には、
効果を及ぼしてはならない
— すなわち，~custom~propを通して生じる効果は、［
下に与える，［
`~prop^V が，何かを生じさせるような非~初期~値をとり得ること
］を条件とする規則
］には織り込まれない。
◎
Specifying a custom property must have no effect, which means that effects that happen through custom properties do not count for the rules below that are conditioned on any non-initial value of a property causing something.
</dd>
	<dd class="note">注記：
~propとして認識されない値を指定してもかまわない
— それは，単純に効果がないことになる。
これは、［
一部の~UAにしか存在しない新たな~propを安全に
— その~propを知らない他の~UAには影響することなく —
指定する
］ことを作者に許容する。
◎
Note: Specifying a value that’s not recognized as a property is fine; it simply has no effect. This allows you to safely specify new properties that exist in some user agents without negatively affecting down-level user agents that don’t know about that property.
</dd>
	<dd class="example">
例えば，非~初期~値に設定された `transform$p を伴う要素に対する ~browserによる取扱いは、
通常の要素と大きく異なることが多い
— たぶん，［
`transform$p が生産し得るような変形nの類
］を~~専用の仕組み（ “~GPU層” など）を利用して より［
容易に／素早く
］描画するために。
値 `transform^v は、［
旧い／新たな
］層の再~描画に伴う遅延を避けるため，［
要素の変形が開始されるに先行して即時に，要素を そのような~~専用の層に昇格させるべきである
］ことを~browserに通達する。
◎
For example, browsers often handle elements with transform set to a non-initial value very differently from normal elements, perhaps rendering them to their own “GPU layer” or using other mechanisms to make it easier to quickly make the sort of transformations that transform can produce. A browser might take a value of transform as a signal that it should go ahead and promote the element to its own layer immediately, before the element starts to be transformed, to avoid any delay involved in rerendering the old and new layers.
</dd>
	<dd>
<p>
`~prop^V がとり得る非~初期~値として：
◎
↓</p>
		<ul>
			<li>
要素に`積層~文脈$を作成させる値がある場合、
要素に積層~文脈を作成させるモノトスル。
◎
If any non-initial value of a property would create a stacking context on the element, specifying that property in will-change must create a stacking context on the element.
</li>
			<li>
`絶対的に位置され$た要素（`固定的に位置され$たものも含む）用に`包含塊$を生成させる値がある場合、
そのような要素があるときには，それ用の包含塊を生成させるモノトスル。
◎
If any non-initial value of a property would cause the element to generate a containing block for absolutely positioned elements, specifying that property in will-change must cause the element to generate a containing block for absolutely positioned elements.
◎
If any non-initial value of a property would cause the element to generate a containing block for fixed positioned elements, specifying that property in will-change must cause the element to generate a containing block for fixed positioned elements.
</li>
			<li>
<p>
要素の描画を違えさせる値がある場合
（~text描画に異なる【より高品質な】~anti-aliasing策を利用させるなど）、
~UAは，
後で~propが変化したときに描画が急に違えられるのを避けるため，
それで代替する描画を利用するべきである。
</p>

<p class="trans-note">【
そのような値が複数あって（例： `image-rendering$p ），どれが “最高” か自明でない場合、
どの値~用の描画を利用するべきかは，指定されていない。
】</p>
◎
If any non-initial value of a property would cause rendering differences on the element (such as using a different anti-aliasing strategy for text), the user agent should use that alternate rendering when the property is specified in will-change, to avoid sudden rendering differences when the property is eventually changed.
</li>
		</ul>

<p class="example">
例えば，要素の `opacity$p に `1^v 未満の値が設定された場合、
要素は`積層~文脈$を作成する。
したがって、
要素の `will-change$p に `opacity^v を設定したときも，
積層~文脈が作成されることになる
— `opacity$p の値が `現在は^em `1^v に等しいとしても。
◎
For example, setting opacity to any value other than 1 creates a stacking context on the element. Thus, setting will-change: opacity also creates a stacking context, even if opacity is currently still equal to 1.
</p>
	</dd>
</dl>

<p>
要素に `will-change$p ~propが指定されても、
上で指定した［
`積層~文脈$や`包含塊$の作成
］を超えるような`直な効果は無い^em。
それは、
もっぱら，~UA向けの描画~hintである
— ある種の変化に対し［
それが実際に生じ~~始める前に，高価になり得る最適化を設定しておく
］ことを許容するための。
◎
The will-change property has no direct effect on the element it is specified on, beyond the creation of stacking contexts and containing blocks as specified above. It is solely a rendering hint to the user agent, allowing it set up potentially-expensive optimizations for certain types of changes before the changes actually start occurring.
</p>

	</section>
	<section id="security">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
この文書に対し提起された~securityの懸念は無い。
◎
No Security concerns have been raised against this document
</p>

	</section>
	<section id="privacy">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この文書に対し提起された~privacyの懸念は無い。
◎
No Privacy concerns have been raised against this document
</p>

	</section>
	<section id="acks">
<h2 title="Acknowledgements">謝辞</h2>

<p>
最初に `will-animate^p ~propを示唆され，たくさんの初期~設計~作業を行われた `Benoit Girard^en 氏に。
◎
Thanks to Benoit Girard for originally suggesting the will-animate property, and doing a lot of the initial design work.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>


<dl>
	<dt>
<a href="~TR/2015/CR-css-will-change-1-20151203/">2015年 12月 3日 勧告候補</a>
からの変更点
◎
Since the 03 December 2015 CR:
</dt>
	<dd>
［
§ ~security, § ~privacy
］を追加した。
◎
Added Security and Privacy sections
</dd>
	<dd>
`will-change$p に未知な値を指定してもかまわないこと，その場合には効果は無いことを明確化した。
◎
Clarified that unknown values are fine, and have no effect
</dd>
	<dd>
`will-change$p に指定された~prop名は、
~ASCII大小無視で照合するものと指定した。
◎
Specified that ASCII Case-Insensitive matching is used against property names
</dd>
	<dd>
`will-change$p ~propの~animation型を~animate不可に変更した。
◎
Changed the animation type of the will-change property to not animatable
</dd>
	<dd>
他の~CSS仕様と同じく、
~prop定義~表tから “媒体（ `Media:^en ）” 欄を落とした。
◎
Dropped the "Media:" entry from propdef tables, as with other CSS specifications
</dd>
	<dd>
小さな編集上の明確化, ~markupの改善。
◎
Minor editorial clarifications, markup improvements
</dd>

	<dt>
<a href="~TR/2014/WD-css-will-change-1-20140429/">2014年 4月 29日 作業草案</a>
からの変更点
◎
Since the April 29 2014 Working Draft:
</dt>
	<dd>
`will-change$p を上手に利用する方法について指導を与える説明的な節を追加した。
◎
Added an explanatory section giving guidance on how to use will-change well.
</dd>
	<dd>
略式~prop【の名前が指定されたとき】の挙動を指定した。
◎
Specified the behavior of shorthands
</dd>
</dl>

	</section>
</main></div>
