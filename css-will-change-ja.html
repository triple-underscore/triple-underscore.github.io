<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Will Change Module Level 1 （日本語訳）</title>


<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	return this.html.replace(
		/`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Will Change Module Level 1
spec_date:2022-04-29
trans_update:2022-04-30
source_checked:200918
page_state_key:CSS
original_url:https://drafts.csswg.org/css-will-change-1/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-ux,css
conformance:css
copyright:2022,permissive
trans_1st_pub:2015-01-30


●●class_map
p:property
t:type
css:css
v:value

●●tag_map
p:code
t:var
css:code
v:code
V:var
em:em

●●original_id_map

●●mdn_urls
propdef-will-change:CSS/will-change

●●link_map


p.will-change:#propdef-will-change
p.background:~CSSBG#propdef-background
p.opacity:~CSSCOLOR#propdef-opacity
p.transform:~TRANSFORM#propdef-transform
p.image-rendering:~CSSIMAGE#propdef-image-rendering
t.animateable-feature:#typedef-animateable-feature
v.auto:#valdef-will-change-auto
v.scroll-position:#valdef-will-change-scroll-position
v.contents:#valdef-will-change-contents
t.custom-ident:#valdef-will-change-custom-ident
	~CSSVAL#identifier-value

下位prop:~CASCADE#longhand
略式~prop:~CASCADE#shorthand
包含塊:~CSSDISP#containing-block
固定的に位置され:~CSSPOS#fixed-position
絶対的に位置され:~CSSPOS#absolute-position
積層~文脈:~CSS2J#stacking-context

~custom~prop:~CSSVAR#custom-property
~ASCII大小無視:~INFRA#ascii-case-insensitive

●●words_table1


●●words_table



	●will change
GPU:
caching:::キャッシュ処理
	描画し直す:re-render
	再~描画-:rerender
	再~描画:rerendering
描画状態:rendering::~
	~scroll可能:scrollable
	~scroll時:scrolling
窓:window:~::ウィンドウ

復帰-:revert:~
応答性:responsiveness:~
変化ng:changing:変化
定期的:constant:~
定常的:regular:~
持続的:persistent:~
断続的:continual:~
毎回:continualに:~

滑らか:smooth:~
	~~専用の:own:~
過利用-:overuse:濫用
枯渇-:exhaust:~
浪費:waste:~
準備:preparation:~
	準備:preparing
節約:saving:~
省力化:skip:~
高価:expensive:~
請求-:claim:~
	設定しておく:set up
素早く:quickに:~
機敏:snappy:~
急な:sudden:~
速さ:speed:~
	より速く:faster
遅く:slowに:~
遅いの:slowなの:~
滑出-:slide out:滑り出
始動-:start-up:~
カクつき:jank:~
時機:time:~
新規:fresh:~
保たれ:keepされ:~
止めた:stopした:~
目立って:noticeableに:~
害:harm:~
悪影響:negative impact:~
	早め:ahead-of-time
	前まで:ahead of time
	一呼吸おいて:few moments away
	設置／撤去する:flipped on and off
	何分の一秒か:fraction of a second
	予定にある:will
	猶予:lead time／:time to／:time to work
	後で:eventual
	秒間に何度も:many times per second
	先行して／とにかく:go ahead
	ずっと長く:much longer
	より長く:longer

	●CSS
	~animate不可:not animatable
	animating:::
hover:::
hovering:::
積層:stacking:~
変形:transform::~
変形n:transformation::変形
発話:speech::~::スピーチ
固定的:fixed::~

	●仕様
控えめ:sparing:~
一から:scratchから:~
本当:real:~
上手:well:~
事実:fact:~
学ぶ:learnする:~
自明:trivial:~
	自明でない:non-trivial
悪い:bad:~
稀:rare:~
助ける:helpする:~
助け:help:~
昇格-:promote:~
指図-:tell:~
	~~適用:make
束ねら:tieさ:~
提起-:raise:~
説明的:explanatory:~

	〜に:simply
	だろ？:right?
	否。:wrong
	良さそう:good idea
	役に立たない:useless
	〜べく:meant
	と見込まれる:likely
	まず見込まれない:very unlikely
	~hintを与える:hinting
	~~抑制する:less aggressive
	ある面:aspects
	であろう:hopefully
	地位を高める:high up
	~~原則:“Dos and Don’ts”
	やれる限りの労力を費や:tries as hard as
	必要になる:need
	~~方式:strategy
	ばら撒く:spam
	申し分ない:fine
	かまわない:fine
	-:manner
	because
	though
	since
	about
	you
	your
	用-法:how to use
	しないよう:avoid
	伴う-:involve
	忘れ:forget
	直感を養う:develop a good intuition
	織り込む:count する
	思える:assume
	一見すると:A common initial response to seeing
	~~問題:hurt
	~security:Security
	~privacy:Privacy
	小さな:minor

	●未分類
crash::::クラッシュ
組成-:composite:~
回復-:recover:~
延長-:expand:~
移動:movements:~
加える:addする:~
anti-aliasing::::アンチエイリアシング
capacity:::
machine::::マシン
	milliseconds:::ミリ秒
種類:kind:~
旧い:old:~

	~web~page:webpage
	始ま:begin
	はみ出す:past
	対象の:targeted
	伝え:inform
	限-:limit
	make
	begin
	going
	using
	do
	cause
	take
	end up
	他の:down-level
	JS
	見栄え:look nice
	対応する下位~prop:the longhands the shorthand expands 
	~prop定義:propdef
	欄:entry

	●指示語

	一定の:certain types
	同じことに:identical
	〜の類:sort of
	残り:rest
	に足る:sufficient な
	異なる:differ
	違える:difference
	こともある:sometime
	周囲:around
	全く:at all
	近い:near
	ほぼ:nearly
	少しばかり:slightly
	少なくとも:least
	最初に:originally
	何しろ:After all,
	多い／頻繁:often
	およそ:more-or-less
	あらゆるもの:everything
	少数の:small number of
	薄い／少ない／わずか:little
	later
	引っ張る要因:very bad
	さほど:very much
	大きく／まず／さほど〜:very
	高い:high
	only
	which
	末端:bottom
	~~主に:mostly
	より強い:stronger
	大きな／多量に／たくさんの:a lot of
	所がある:somewhat
	like
	when
	where
	these
	that
	they
	them
	their
	thing
	those
	between
	some
	very
	there
	every
	much
	-otherwise
	such
	-:whenever
	-:whatever
	many
	less
	just
	most
	down
	even
	soon
	against
	away


●●ref_normative

[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. 16 December 2021. WD. URL: https://www.w3.org/TR/css-values-4/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS21/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119

●●ref_informative

[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. 26 July 2021. CR. URL: https://www.w3.org/TR/css-backgrounds-3/
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley; Lea Verou. ＜CSS Color Module Level 4＞. 15 December 2021. WD. URL: https://www.w3.org/TR/css-color-4/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Will Change Module Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-will-change-1/
公表履歴
	https://www.w3.org/standards/history/css-will-change-1/

実装報告
	https://wpt.fyi/results/css/css-will-change
テスト一式
	https://wpt.fyi/results/css/css-will-change
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-will-change-1">CSSWG Issues Repository</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-will-change-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-will-change-1

</script>

</head>
<body>

<header>
	<hgroup>
<h1>CSS Will Change Module Level 1</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は `will-change$p ~CSS~propを定義する。
これにより，作者は、要素に~~適用されると見込まれる変更の種類を，早めに~UAに伝えられるようになる。
その結果，~UAは、~animationが実際に始まる前に，その準備として高価になり得る作業を遂行しておき、要素の取扱いを早めに最適化できるようになる。
◎
This document defines the will-change CSS property, which allows an author to inform the UA ahead of time of what kinds of changes they are likely to make to an element. This allows the UA to optimize how they handle the element ahead of time, performing potentially-expensive work preparing for an animation before the animation actually begins.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">
	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
現代の~CSS 描画器は、~web~pageを素早く効率的に描画する†ために，いくつもの複階的な最適化を遂行する。
あいにく，これらの最適化を使役する下では、~pageの応答性に悪影響を及ぼし得るような自明でない始動~costを要することが多い。
◎
Modern CSS renderers perform a number of complex optimizations in order to render webpages quickly and efficiently. Unfortunately, employing these optimizations often has a non-trivial start-up cost, which can have a negative impact on the responsiveness of a page.
</p>

<p class="trans-note">【†
`render^en する（より一般には、具現化する）
— 発話~媒体であれば “音声化する”, 等々
（以下，単に “描画” と記す）。
が、すべての内容が “同時に” 表示される視覚-媒体と異なり，この仕様の大部分は、発話~媒体には効果がないか，ずれた記述になるであろう。
】
</p>

<div class="example">
<p>
例えば，要素を~screenのあちこちに移動させるために CSS 3D 変形を利用するとき、~pageの残りから独立に描画しておいて 後から組成できるように，要素とその内容は 一つの “層” に昇格される。
これは、各~frame間で変化するものが要素の変形のみである場合には、~pageの残りを再~描画せずに済むように 内容の描画を隔離するので，速さの便益を有意に供することが多い。
◎
For example, when using CSS 3D Transforms to move an element around the screen, the element and its contents might be promoted to a “layer”, where they can render independently from the rest of the page and be composited in later. This isolates the rendering of the content so that the rest of the page doesn’t have to be rerendered if the element’s transform is the only thing that changes between frames, and often provides significant speed benefits.
</p>
<p>
しかしながら，要素を新規な層に設定しておくことは 相対的に高価な演算であり、`transform$p ~animationの開始を何分の一秒か目立って遅延させることもある。
◎
However, setting up the element in a fresh layer is a relatively expensive operation, which can delay the start of a transform animation by a noticeable fraction of a second.
</p></div>

<p>
この仕様にて定義される `will-change$p ~propにより、作者は，未来に変化すると見込まれる~propを早めに宣言しておけるようになり、~UAは，必要になるより早めに，適切な最適化を設定しておくことが可能になる。
このようにして、実際に変化が起きたときには，~pageは機敏に更新される。
◎
The will-change property defined in this specification allows an author to declare ahead-of-time what properties are likely to change in the future, so the UA can set up the appropriate optimizations some time before they’re needed. This way, when the actual change happens, the page updates in a snappy manner.
</p>

		<section id="values">
<h3 title="Value Definitions">1.1. 値~定義</h3>

<p class="trans-note">【
この節の内容は <a href="~CSScommon#values">~CSS日本語訳 共通~page</a>に移譲。
】</p>

		</section>
		<section id="using">
<h3 title="Using will-change Well">1.2. `will-change$p の上手な利用-法</h3>

<p>
他の処理能~hintと同様に、
`will-change$p ~propも，その “適正な” 用-法を学ぶには困難な所がある
— 作者が直に検出できる効果は，あっても ごくわずかなので。
しかしながら、
`will-change$p の上手な用-法について直感を養う助けになるであろう，単純な~~原則がいくつかある。
◎
The will-change property, like all performance hints, can be somewhat difficult to learn how to use “properly”, particularly since it has very little, if any, effect an author can directly detect. However, there are several simple “Dos and Don’ts” which hopefully will help develop a good intuition about how to use will-change well.
</p>

			<section id="dont-global">
<h4 title="Don’t Spam will-change Across Too Many Properties or Elements">`will-change^p を多数の~propや要素にばら撒かないこと</h4>

<p>
一見すると、次の様な~codeで `will-change$p を用いれば良さそうに思えるかもしれない：
◎
A common initial response to seeing will-change is to assume that code like this is a good idea:
</p>

<pre class="lang-css">
* { will-change: transform, opacity /* , ... */; }
</pre>

<p>
何しろこれは、~browserに，とにかくあらゆるものを最適化せよと指図する
— これで良い筈だろ？
◎
After all, this tells the browser to go ahead and optimize everything, which has to be good right?
</p>

<p>
否。
~browserは `すでに^em，あらゆるものを最適化しようと やれる限りの労力を費やしている。
明示的にそうするように指図した所で、何の助けにもならない
— 事実，かえって大きな害になる可能性もある。
`will-change$p に束ねられると見込まれる，より強い最適化には、~machineの資源を多量に利用させるものもあり、この様に過利用された場合，~pageが遅くなったり, ~crashすることすらある。
◎
Wrong. The browser already tries as hard as it can to optimize everything. Telling it to do so explicitly doesn’t help anything, and in fact has the capacity to do a lot of harm; some of the stronger optimizations that are likely to be tied to will-change end up using a lot of a machine’s resources, and when overused like this can cause the page to slow down or even crash.
</p>

<p>
加えて， `will-change$p には、<strong>ある副作用</strong>がある
— ~page内の要素すべてが実際にその副作用を求めるとは，まず見込まれない。
◎
In addition, will-change does have some side-effects, and it’s very unlikely that pages actually want all those side-effects on every element.
</p>

			</section>
			<section id="css-sparingly">
<h4 title="Use will-change Sparingly In Stylesheets">~stylesheet内での `will-change^p の利用は，控えめにすること</h4>

<p>
~stylesheet内で `will-change$p を直に利用することは、対象の要素が変化するのは，常に一呼吸おいてからであることを含意する。
作者が実際にそう~~意図することは、`通例的^emにはない
— `will-change$p は、通例的には，変化が生じる［
前／後
］に~scriptingを介して［
設置／撤去
］されるべきである（
<a href="#dont-waste">変化ngを止めた要素には，資源を浪費させないこと</a>
を見よ）。
しかしながら、~stylesheet内で `will-change$p を直に利用するのが適切になるような，共通的な状況下もある。
◎
Using will-change directly in a stylesheet implies that the targeted elements are always a few moments away from changing. This is usually not what you actually mean; instead, will-change should usually be flipped on and off via scripting before and after the change occurs (see Don’t Waste Resources On Elements That Have Stopped Changing). However, there are some common circumstances in which it is appropriate to use will-change directly in a stylesheet.
</p>

<div class="example">
<p>
例えば、［
利用者に対し機敏に反応すべきような，~page内の少数の持続的~UI要素
］用に， `will-change$p を指定することは、適切になる：
◎
For example, specifying will-change for a small number of persistent UI elements in a page which should react snappily to the user is appropriate:
</p>

<pre class="lang-css">
body &gt; .sidebar {
   will-change: transform;
   /* <span class="comment">
利用者から要請され次第 要素を滑出させるような `transform^p を利用する予定にある。
◎
Will use 'transform' to slide it out when the user requests.
</span> */
}
</pre>

<p>
これは，少数の要素に限られているので、最適化が実際には稀にしか利用されないとしても，さほど~~問題にならない。
◎
Because this is limited to a small number of elements, the fact that the optimization is rarely actually used doesn’t hurt very much.
</p></div>

<div class="example">

<p>
要素の~propは、`本当に^em，ほぼ定期的に変化することもある。
たぶん、利用者による
~mouse移動／あるいは単に定常的に行われる何らかの動作
に応答して，~animationを生じさせるような。
そのような事例では、単に~stylesheet内に
`will-change$p 値を宣言することで申し分ない
— それは［
要素は 定常的に／定期的に変化する予定にあるので，最適化が保たれるべきである
］ことについて、正確aに述べているので。
◎
Sometimes an element really does change a property nearly constantly. Perhaps it responds to the user’s mouse movements, or just regularly takes some action that causes an animation. In this case, just declaring the will-change value in the stylesheet is fine, as it accurately describes that the element will regularly/constantly change, and so should be kept optimized.
</p>

<pre class="lang-css">
.cats-flying-around-the-screen {
  will-change: left, top;
}
</pre>

</div>

			</section>
			<section id="give-time">
<h4 title="Give will-change Sufficient Time To Work">`will-change^p が働くに足る猶予を与えること</h4>

<p>
要素の
~animation／~prop変化
を助けるべく，それが開始される`直前に^em `will-change$p を適用することも，また別の共通的な悪い~patternである。
あいにく，この種の最適化のほとんどは、適用されるまで時間を要する
— このようにした場合、設定しておく十分な猶予がないので， `will-change$p の効果は薄い。
代わりに、少なくとも何かが変化する`少し前まで^emに，それを予測するような何らかの仕方を見出した上で、 `will-change$p を設定することが~~求められる。
◎
Another common bad pattern is to apply will-change to an element immediately before starting the animation or property change that it’s meant to help with. Unfortunately, most of those optimizations need time to be applied, and so they don’t have enough time to set-up when this is done, and the will-change has little to no effect. Instead, find some way to predict at least slightly ahead of time that something will change, and set will-change then.
</p>

<div class="example">
<p>
例えば，利用者が~clickしたとき要素が変化するのであれば、~hover時に `will-change$p を設定することで，最適化を設定しておく猶予として 通例的には 200 ミリ秒~以上が与えられる
— ヒトの反応~時間は相対的に遅いので。
これは、~scriptingを介して, あるいは 単純に~CSS規則でも行える：
◎
For example, if an element is going to change when a user clicks on it, setting will-change on hover will usually give at least 200 milliseconds for the optimizations to be set up, as human reaction time is relatively slow. This can be done either via scripting, or rather simply with a CSS rule:
</p>

<pre class="lang-css">
.element { transition: opacity .2s; opacity: 1; }
.element:hover { will-change: opacity; }
.element:active { opacity: .3; }
</pre>

<p>
しかしながら，この様な規則は、効果が~hover時に起こるような場合には役に立たない。
そのような場合でも、動作が生じる前に予測する仕方を見出せることは多いが。
この事例の場合、要素の先祖~上に~hoverしたとき設定することで，十分な猶予を与え得る：
◎
However, a rule like that is useless if the effect is going to happen on hover. In cases like these, it is often still possible to find some way to predict the action before it occurs. For example, hovering an ancestor may give enough lead time:
</p>

<pre class="lang-css">
.element { transition: opacity .2s; opacity: 1; }
.container:hover &gt; .element { will-change: opacity; }
.element:hover { opacity: .3; }
</pre>

</div>

			</section>
			<section id="dont-waste">
<h4 title="Don’t Waste Resources On Elements That Have Stopped Changing">変化ngを止めた要素には，資源を浪費させないこと</h4>

<p>
一部の~propは，変化するときに~browserが利用する最適化が高価になるので、通常の状況下では，~browserは できるだけ早く それらを除去して通常の挙動に復帰しようとする。
しかしながら， `will-change$p は、一般に，この挙動を上書きして最適化をずっと長く保守させる。
◎
Because the optimizations browsers use for changing some properties are expensive, browsers remove them and revert to normal behavior as soon as they can in normal circumstances. However, will-change will generally override this behavior, maintaining the optimizations for much longer than the browser would otherwise do.
</p>

<p>
そのようなわけで，とりわけ~scriptingを介して要素に  `will-change$p を加えるときは、最適化から請求された資源を~browserが回復できるよう，要素が変化し終えた後に `will-change$p を`除去し忘れない^emこと。
◎
As such, whenever you add will-change to an element, especially via scripting, don’t forget to remove it after the element is done changing, so the browser can recover whatever resources the optimizations are claiming.
</p>

			</section>
		</section>
	</section>
	<section id="will-change">
<h2 title="Hinting at Future Behavior: the will-change property">2. 未来の挙動について~hintを与える： `will-change^p ~prop</h2>

<div>
◎名 `will-change@p
◎値 `auto$v | `animateable-feature$t#
◎初 `auto$v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア ~animate不可
◎表終
◎
Name: 	will-change
Value: 	auto | &lt;animateable-feature&gt;#
Initial: 	auto
Applies to: 	all elements
Inherited: 	no
Percentages: 	n/a
Computed value: 	specified value
Canonical order: 	per grammar
Animation type: 	not animatable
</div>

<pre class="prod">
`animateable-feature@t
	= `scroll-position$v
	| `contents$v
	| `custom-ident$t
</pre>

<p>
`will-change$p ~propは、~UAに描画~hintを供する
— それは、作者が 要素~上で遂行するものと予期する変化の種類を言明する。
これにより、~UAは，［
その変化ngの滑らかな描画に必要yな最適化
］を早めに遂行しておけるようになり、作者が~~実際に その特能を
変化させ／~animateさせ
始めたときの “カクつき” を避けれるようになる。
◎
The will-change property provides a rendering hint to the user agent, stating what kinds of changes the author expects to perform on the element. This allows the user agent to perform ahead-of-time any optimizations necessary for rendering those changes smoothly, avoiding “jank” when the author does begin changing or animating that feature.
</p>

<p class="note">
`will-change$p からの情報を利用する仕方は，~browserごとに異なる。
同じ~browserであっても，時機によって利用する仕方が異なることすらある。
例えば，~browserは、要素に
<samp class="css">`will-change$p: `transform^v;</samp>
が指定されたときには，要素を~~専用の “~GPU層” に昇格させるが、それが宣言された要素が`多過ぎる^emときは，~GPU~memoryが枯渇しないよう それを避けることもある。
◎
Different browsers can use the information from will-change in different ways, and even a single browser might use it in different ways at different time. For example, a browser that promotes elements to their own “GPU layer” when they have will-change: transform specified might avoid doing that when there are too many elements declaring that, to avoid exhausting GPU memory.
</p>

<p>
各種 値の意味は：
◎
Values have the following meanings:
</p>

<dl>
	<dt>`auto@v</dt>
	<dd>
特に意図は無いことを表出する
— ~UAは、通常に行う経験則／最適化があれば，それを適用するべきである。
◎
Expresses no particular intent; the user agent should apply whatever heuristics and optimizations it normally does.
</dd>

	<dt>`scroll-position@v</dt>
	<dd>
［
作者は，近い未来に 要素の~scroll位置を［
~animateさせる ／ 変化させる
］ものと予期している
］ことを指示する。
◎
Indicates that the author expects to animate or change the scroll position of the element in the near future.
</dd>
	<dd class="example">
例えば，~browserは、~scroll可能な要素~上の［
“~scroll窓” 内にある内容と, その窓をはみ出る一部の内容
］のみを描画することが多い
— 描画の省力化による~memory／時間の節約と, ~scroll時の見栄えとを，天秤にかけながら。
この値は、［
~scrollがより 長く／速く 行われても滑らかになるよう，描画する内容の範囲を~scroll窓の周囲から延長すべきである
］ことを~browserに通達する。
◎
For example, browsers often only render the content in the "scroll window" on a scrollable element, and some of the content past that window, balancing memory and time savings from the skipped rendering against making scrolling look nice. A browser might take this value as a signal to expand the range of content around the scroll window that is rendered, so that longer/faster scrolls can be done smoothly.
</dd>

	<dt>`contents@v</dt>
	<dd>
［
作者は，近い未来に 要素の何らかの内容を［
~animateさせる ／ 変化させる
］ものと予期している
］ことを指示する。
◎
Indicates that the author expects to animate or change something about the element’s contents in the near future.
</dd>
	<dd class="example">
<p>
例えば，
~browserは，要素の描画状態を時間~越しに “~cacheする” ことが多い
— 大抵の場合、要素はさほど~~頻繁には変化しないか, 変化するとしても位置に限られるので。
しかしながら，要素の内容が `断続的に変化する^em 場合、この~cacheを生産して保守することは，時間の浪費になる。
この値は、［
要素~描画の~cachingを~~抑制するか，全く~cacheせず毎回 要素を一から描画し直す
］べきであることを~browserに通達する。
◎
For example, browsers often “cache” rendering of elements over time, because most things don’t change very often, or only change their position. However, if an element does change its contents continually, producing and maintaining this cache is a waste of time. A browser might take this value as a signal to cache less aggressively on the element, or avoid caching at all and just continually re-render the element from scratch.
</p>
<p>
この値は~~主に、［［
要素~内容のある面が秒間に何度も変化する
］ような， JS に基づく内容の~animation
］に対する，~browserによる最適化を助けるためにある。
~browserによるこの種の最適化は、宣言的~animationに対しては，すでにアリな限り自動的に行われている。
【そのように<a href="~WANIM#side-effects-section">規定されてもいる</a>。】
◎
This value is mostly intended to help browsers optimize JS-based animations of content, which change aspects of an element’s contents many times per second. This kind of optimization, when possible, is already done automatically by browsers when declarative animations are used.
</p>
</dd>
	<dd class="note">注記：
この値は、およそ それが宣言された要素を根とする下位tree全体に適用されることに注意
— それは、~browserに，［
`どの子孫であれ^em，何らかの仕方で変化するもの
］を織り込むべきであることを指示するので。
これを利用すると、文書における要素の “地位が高められる” 結果，~pageの処理能を引っ張る~~要因になり得る。
よって、アリな限り文書の少ない部分を包含するような，文書~treeの “末端” に近い要素のみに利用することを~~勧める。
◎
Note: This value more-or-less applies to the entire subtree of the element its declared on, as it indicates the browser should count on *any* of the descendants changing in some way. Using this on an element “high up” in your document might be very bad for your page’s performance; try to only use this on elements near the “bottom” of your document tree, containing as little of the document as possible.
</dd>

	<dt id="valdef-will-change-custom-ident"><a href="~CSSVAL#identifier-value">`custom-ident^t</a></dt>
	<dd>
所与の `custom-ident^t が ある組込みの~CSS~prop
— 以下， `~prop^V と記す —
の名前に`~ASCII大小無視$で合致する場合、［
作者は，近い未来に 要素~上の `~prop^V を［
~animateさせる／変化させる
］ことを予期している
］ことを指示する。
`~prop^V が`略式~prop$である場合、対応するすべての`下位prop$に対する予期を指示する。
◎
If the &lt;custom-ident&gt; is an ASCII case-insensitive match for the name of a built-in CSS property, it indicates that the author expects to animate or change the property with the given name on the element in the near future. If the property given is a shorthand, it indicates the expectation for all the longhands the shorthand expands to.
</dd>
	<dd class="example">
例えば，
<samp class="css">`will-change$p: `background^v;</samp>
を設定することは、
`background$p の各種 `下位prop$すべてに渡り，
<samp class="css">`will-change$p: `background-image, background-position, ...^v;</samp>
を設定するのと同じことになる。
◎
For example, setting will-change: background; is identical to setting will-change: background-image, background-position, ... for all the properties that background expands into.
</dd>
	<dd>
ここでの `custom-ident$t 生成規則からは、
`custom-ident$t から通常に除外される~keywordに加えて，次の~keywordも除外される：
`will-change^v, `none^v, `all^v, `auto$v, `scroll-position$v, `contents$v
◎
The &lt;custom-ident&gt; production used here excludes the keywords will-change, none, all, auto, scroll-position, and contents, in addition to the keywords normally excluded from &lt;custom-ident&gt;.
</dd>
	<dd class="note">注記：
ほとんどの~propは、指定されたとしても効果はない
— ~UAは，ほとんどの~propに対しては、その変化に際し，特別な最適化は遂行しないので。
指定しても，依然として`安全である^emが
— それは，単純に効果がないことになる。
◎
Note: Note that most properties will have no effect when specified, as the user agent doesn’t perform any special optimizations for changes in most properties. It is still safe to specify them, though; it’ll simply have no effect.
</dd>
	<dd>
`~prop^V として`~custom~prop$が指定されても、効果を及ぼしてはならない
— すなわち，~custom~propを通して生じる効果は、［
下に与える，［
`~prop^V が，何かを生じさせるような非~初期~値をとり得ること
］を条件とする規則
］には、織り込まれない。
◎
Specifying a custom property must have no effect, which means that effects that happen through custom properties do not count for the rules below that are conditioned on any non-initial value of a property causing something.
</dd>
	<dd class="note">注記：
~propとして認識されない値を指定してもかまわない
— それは，単純に効果がないことになる。
これにより、一部の~UAにしか存在しない新たな~propを，安全に
— その~propを知らない他の~UAには影響することなく —
指定できるようになる。
◎
Note: Specifying a value that’s not recognized as a property is fine; it simply has no effect. This allows you to safely specify new properties that exist in some user agents without negatively affecting down-level user agents that don’t know about that property.
</dd>
	<dd class="example">
例えば，非~初期~値に設定された `transform$p を伴う要素に対する ~browserによる取扱いは、通常の要素と大きく異なることが多い
— たぶん， `transform$p が生産し得るような変形nの類を，~~専用の “~GPU層” などの仕組みを利用して より容易に／より素早く 描画するために。
値 `transform^v は、［
旧い／新たな層の再~描画に伴う遅延を避けるため，要素の変形が開始されるに先行して即時に，要素を その~~専用の層に昇格させるべきである
］ことを~browserに通達する。
◎
For example, browsers often handle elements with transform set to a non-initial value very differently from normal elements, perhaps rendering them to their own “GPU layer” or using other mechanisms to make it easier to quickly make the sort of transformations that transform can produce. A browser might take a value of transform as a signal that it should go ahead and promote the element to its own layer immediately, before the element starts to be transformed, to avoid any delay involved in rerendering the old and new layers.
</dd>
	<dd>
<p>
`~prop^V がとり得る非~初期~値として：
◎
↓</p>

<ul>
	<li>
要素に`積層~文脈$を作成させる値がある場合、要素に積層~文脈を作成させるモノトスル。
◎
If any non-initial value of a property would create a stacking context on the element, specifying that property in will-change must create a stacking context on the element.
</li>
	<li>
`絶対的に位置され$た要素（`固定的に位置され$たものも含む）用に`包含塊$を生成させる値がある場合、そのような要素があるときには，それ用の包含塊を生成させるモノトスル。
◎
If any non-initial value of a property would cause the element to generate a containing block for absolutely positioned elements, specifying that property in will-change must cause the element to generate a containing block for absolutely positioned elements.
◎
If any non-initial value of a property would cause the element to generate a containing block for fixed positioned elements, specifying that property in will-change must cause the element to generate a containing block for fixed positioned elements.
</li>
	<li>
要素の描画を違えさせる値がある場合（例：~text描画に異なる【より高品質な】~anti-aliasing~~方式を利用させるなど）、~UAは，後で~propが変化したときに描画が急に違えられるのを避けるため，それで代替する描画を利用するべきである。
【そのような値が複数あって（例： `image-rendering$p ），どれが “最高” か自明でない場合、どの値~用の描画を利用することになる？】
◎
If any non-initial value of a property would cause rendering differences on the element (such as using a different anti-aliasing strategy for text), the user agent should use that alternate rendering when the property is specified in will-change, to avoid sudden rendering differences when the property is eventually changed.
</li>
</ul>

<p class="example">
例えば，要素~上の `opacity$p に `1^v 未満の値が設定された場合、要素は`積層~文脈$を作成する。
したがって、要素~上に
<samp class="css">`will-change$p: `opacity^v</samp>
を設定したときも，積層~文脈が作成されることになる
— `opacity$p の値が `現在は^em `1^v に等しいとしても。
◎
For example, setting opacity to any value other than 1 creates a stacking context on the element. Thus, setting will-change: opacity also creates a stacking context, even if opacity is currently still equal to 1.
</p>

	</dd>
</dl>

<p>
要素~上に `will-change$p ~propが指定されても、上で指定された
`積層~文脈$／`包含塊$
の作成を超えるような，`直接的な効果はない^em。
それはもっぱら，~UA向けの描画~hintである
— 一定の型の変化に対し、その変化が実際に生じ~~始める前に，高価になり得る最適化を設定しておけるようにするための。
◎
The will-change property has no direct effect on the element it is specified on, beyond the creation of stacking contexts and containing blocks as specified above. It is solely a rendering hint to the user agent, allowing it set up potentially-expensive optimizations for certain types of changes before the changes actually start occurring.
</p>

	</section>
	<section id="security">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
この文書に対し提起された~securityの懸念は無い。
◎
No Security concerns have been raised against this document
</p>

	</section>
	<section id="privacy">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この文書に対し提起された~privacyの懸念は無い。
◎
No Privacy concerns have been raised against this document
</p>

	</section>
	<section id="acks">
<h2 title="Acknowledgements">謝辞</h2>

<p>
最初に `will-animate^p ~propを示唆され，たくさんの初期~設計~作業を行われた `Benoit Girard^en 氏に。
◎
Thanks to Benoit Girard for originally suggesting the will-animate property, and doing a lot of the initial design work.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>


<dl>
	<dt>
<a href="~TR/2015/CR-css-will-change-1-20151203/">2015年 12月 3日 勧告候補</a>
からの変更点
◎
Since the 03 December 2015 CR:
</dt>
	<dd>
［
§ ~security, § ~privacy
］を追加した。
◎
Added Security and Privacy sections
</dd>
	<dd>
`will-change$p に未知な値を指定してもかまわないこと，その場合には効果は無いことを明確化した。
◎
Clarified that unknown values are fine, and have no effect
</dd>
	<dd>
`will-change$p に指定された~prop名は、
~ASCII大小無視で照合するものと指定した。
◎
Specified that ASCII Case-Insensitive matching is used against property names
</dd>
	<dd>
`will-change$p ~propの~animation型を~animate不可に変更した。
◎
Changed the animation type of the will-change property to not animatable
</dd>
	<dd>
他の~CSS仕様と同じく、
~prop定義~表tから “媒体（ `Media:^en ）” 欄を落とした。
◎
Dropped the "Media:" entry from propdef tables, as with other CSS specifications
</dd>
	<dd>
小さな編集上の明確化, ~markupの改善。
◎
Minor editorial clarifications, markup improvements
</dd>

	<dt>
<a href="~TR/2014/WD-css-will-change-1-20140429/">2014年 4月 29日 作業草案</a>
からの変更点
◎
Since the April 29 2014 Working Draft:
</dt>
	<dd>
`will-change$p を上手に利用する方法について指導を与える説明的な節を追加した。
◎
Added an explanatory section giving guidance on how to use will-change well.
</dd>
	<dd>
略式~propの挙動を指定した。
◎
Specified the behavior of shorthands
</dd>
</dl>

	</section>
</main></div>
