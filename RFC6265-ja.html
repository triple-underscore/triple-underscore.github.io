<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>RFC 6265 — HTTP State Management Mechanism （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="RFC-common.css" type="text/css" />

<style type="text/css">
span[lang="en"] {
	white-space: pre-line;
}

/* cookie 属性 */
.cookie-attr {
	font-weight: normal;
	color: #053;
}
/* cookie フィールド名 */
.cookie-filed {
	color: #521;
}

.hex-value {
	font-family: sans-serif0, sans-serif;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	var source_data = {
		toc_main: 'MAIN0',
		generate: expand,
		populate: populate,
		section_id_map: Util.get_mapping(PAGE_DATA.section_id_map),
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170815 spec

	function populate(){
		var section_id_map = source_data.section_id_map;
		repeat('section[id]', supply_sec_id);
		function supply_sec_id(e){
			var h = e.firstElementChild;
			if(!h) return;
			var id = section_id_map[e.id.replace(/^(section-)/, '')];
			if(id) h.id = id;
		}
	}
}

function expand(){

	var class_map = {
		f: 'cookie-filed',
		a: 'cookie-attr',
		P: 'production',
		X: 'hex-value',
		h: 'header',
	};

	var tag_map = {
		f: 'code',
		a: 'code',
		h: 'code',
		P: 'code',
		c: 'code',
		s: 'samp',
		X: 'span',
		i: 'i',
	};

	var link_map = this.link_map;
	var section_id_map = this.section_id_map;


	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#ref-' + key;//.toLowerCase();
	break;
case 'l': // octet literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'f':
	href = '#f.' + key;
	break;
case 'h':
	href = '#h.' + key;
	break;
case 'P':
	href = '#p.' + key;
	break;
case 'ch':
	return(
'<span class="hex-value">%x'
+ (key.charCodeAt(0)).toString(16).toUpperCase() + '</span>'
+ '（ "<code class="literal">' + key + '</code>" ）'
	);
	break;
case 'sec':
	var m1 = key.match(/^(\d+)-([\d\.]+)$/);
	if(m1){
		text = 'RFC' + m1[1] + ', ' + m1[2] + ' 節';
		href = '~IETF/rfc' + m1[1] + '#section-' + m1[2];
	} else {
		text = ' ' + key + ' 節'
		href = '#' + section_id_map[key];
	}

	break;
case 'X': // byte value
	text = '%x' + text;
	break;
case 'smb': //
	text = '(<span class="char-symbol">' + text + '</span>)'
	break;
case 'en': // english words
	return '<span lang="en-x-a0">' + key + '</span>'
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

trans_update:2017-10-22
original_url:https://httpwg.org/specs/rfc6265.html
spec_status:IETFPR
no_original_dfn:true
ref_id_prefix:ref-
site_nav:network,http
trans_1st_pub:2012-07-17

●●section_id_map

	rfc.section. + num
	rfc.title:＊
	rfc.abstract:＊
	＊:rfc.status
	＊:rfc.copyrightnotice
1:intro
2:conventions
2.1:conformance-criteria
2.2:syntax-notation
2.3:terminology
3:overview
3.1:rfc.section.3.1
4:sane-profile
4.1:sane-set-cookie
4.1.1:sane-set-cookie-syntax
4.1.2:sane-set-cookie-semantics
4.1.2.1:sane-expires
4.1.2.2:sane-max-age
4.1.2.3:sane-domain
4.1.2.4:sane-path
4.1.2.5:sane-secure
4.1.2.6:sane-httponly
4.2:sane-cookie
4.2.1:sane-cookie-syntax
4.2.2:sane-cookie-semantics
5:ua-requirements
5.1:algorithms
5.1.1:cookie-date
5.1.2:cookie-domain-canonicalize
5.1.3:cookie-domain
5.1.4:cookie-path
5.2:set-cookie
5.2.1:expires-attribute
5.2.2:max-age-attribute
5.2.3:domain-attribute
5.2.4:path-attribute
5.2.5:secure-attribute
5.2.6:httponly-attribute
5.3:storage-model
5.4:cookie
6:implementation-considerations
6.1:implementation-limits
6.2:implementation-apis
6.3:idna-migration
7:privacy-considerations
7.1:third-party-cookies
7.2:user-controls
7.3:expiration-dates
8:security-considerations
8.1:section-overview
8.2:ambient-authority
8.3:clear-text
8.4:session-identifiers
8.5:weak-confidentiality
8.6:weak-integrity
8.7:reliance-on-dns
9:iana-considerations
9.1:rfc.section.9.1
9.2:rfc.section.9.2
9.3:rfc.section.9.3
9.4:rfc.section.9.4
	10:rfc.references
	10.1:rfc.references.1
	10.2:rfc.references.2
	A:rfc.section.A
	rfc.authors


●●original_id_map

references:rfc.references

●●link_map

P.IMF-fixdate:~RFC7231#p.IMF-fixdate

a.Expires:#expires-attribute
a.Max-Age:#max-age-attribute
a.Domain:#domain-attribute
a.Path:#path-attribute
a.Secure:#secure-attribute
a.HttpOnly:#httponly-attribute


非HTTP~API:#dfn-non-HTTP


分割-:#split
要請~host:#dfn-request-host
正準化-済み要請~host:#dfn-canonicalized-request-host
正準化-:#dfn-canonicalized

文字列:#dfn-string
既定の~path:#dfn-default-path
~domain合致-:#dfn-domain-match
~domain合致する:#dfn-domain-match
~path合致する:#dfn-patrh-match
文字大小無視で合致する:#dfn-case-insensitively-match
~cookie文字列:#dfn-cookie-string

~cookieを受信した:#dfn-receive-a-cookie
	別々に扱われる:#_-store-cookie
失効した:#dfn-expired
属性:#dfn-attributes

第三者主体:#section-7.1

ambient 権限:#dfn-ambient-authority
~public~suffix:#dfn-public-suffix


●●words_table1
errata6265:https://www.rfc-editor.org/errata_search.php?rfc=6265&amp;eid

MUST:なければ<em class="rfc2119">ならない</em>
MUST_NOT:<em class="rfc2119">ならない</em>
REQUIRED:<em class="rfc2119">要求される</em>
SHOULD:<em class="rfc2119">べき</em>
	RECOMMENDED:<em class="rfc2119">推奨される</em>
MAY:<em class="rfc2119">よい</em>

●●words_table


	●仕様
well-behaved-profile:well-behaved profile
algo:algorithm:::アルゴリズム
UI:user interface::UI
	application programming interface:アプリケーションプログラミングインタフェース
platform::::プラットフォーム
library::::ライブラリ
system::::システム
bug::::バグ
variation::::バリエーション
software::::ソフトウェア
programmer::::プログラマ
model::::モデル
正誤表:errata:~
互換性:compatibility:~
UA:user agent:UA
厳密さ:strictness:~
歴史的:historical:~
慣行:common practice:~
実施:practice:~
実用的:practical:~
相互運用性:interoperability:~
相互運用-:interoperate:~
	~~寛容:liberal／permissive
意味論:semantics:~:::セマンティクス
意味論的:semantic:~:::セマンティック
概観:overview:~
能:ability:~
恒久的:permanent:~
判定基準:criteria:~
独立:independent:~
等価:equivalent:~
等価性:equivalence:~

本質的:essential:~
有用:useful:~
各種用語:terminology:~
利用局面:usage scenarios:~
便益:benefits:~
理由:reason:~
文脈:context:~
抽象:abstract:~
特定0の:particular:ある特定の
位置付け:status:~
可用:available:~

手動:manual:~
精確:precise:~
機能性:functionality:~
代表的:typical:~
概して:typical に:~
一般用の:general-use:~
効果的:effective:~
	効果的でない:ineffective
仕方:way:~
目的:purpose:~
目標:goal:~
仕組み:mechanism:~
適切:appropriate:~
実際:actual:~
実際の:actual な:~
共通的な:common な:よくある
共通的に:common に:よく
単純:simple:~
	単純~化:simlify
不変則:invariant:~
複雑さ:complexities:~
通例的:usual:~
通例の:usual な:~
表記規約:conventions:~
	ほぼ無意味と化す:largely moot
正しく:correct に:~
	正しく〜ない:incorrect
処理能:performance:~:::パフォーマンス
	performant
有意:significant:~
条件:condition:~
序論:introduction:~
作変更管理者:Author/Change controller:作者／変更管理者
改善-:improve:~
	~~向上させ:promote:~
際立つ:salient な:~
	差異:difference
広範:wide:~
feedback::::フィードバック
	普及している:popular な
	あいにく、:Unfortunately,
	想定する読者:audiences
	今日:today
	万能:panacea
	しかしながら:however
	足る:sufficient
	不足:insufficient
	併用:in conjunction with
	事実、:In fact
	依然:still
	可能
	可能性がある:possibly
	ある程度の移行期間:some time during
	下位節:subsections
	無用に:gratuitously
	必要:needs
	参考:Non-Normative／Informative
	参照文献:References
	詳細:details／more information
	特に，:In particular,
	明らかな:clear
	形をとる:in the form of
	一見:seemingly
	作者／変更管理者:Author/Change controller
	観点
	関連:In relation to, related, associated
	何をもって:notion
	何十年:multiple decades
	概略的:Informally,
	顕著:most apparent
	表記
	though
	In addition
	additional
	although
	because
	consider
	denoted
	due
	example
	normative
	note
	notice
	publication
	well
	●仕様（動詞
app:application:::アプリケーション
support::::サポート
action::::アクション
実装-:implement:~
実装:implementation:~
	実装-時:implementation:~
	実装により定義される:implementation-defined
要件:requirements:~
要求-:require:~
	要-:require
保守-:maintain:~
推奨:recommendation:~
推奨-:recommend:~
判別-:distinguish:~
禁止-:forbid:~
検分-:examine:~
指図-:instruct:~
解釈-:interpret:~
解釈:interpretation:~
衝突-:conflict:~
競合:race condition:~
許可-:permit:~
是認-:grant:~
増補-:enhance:~
保証-:guarantee:~
登録-:register:~
登録:registrations:~
期待-:expect:~
	期待されない:unexpectedly
選好-:prefer:~
指示-:indicate:~
仕様:spec:~
特有の:specific な:~
特定の:specific な:~
指定-:specify:~
指名-:designate::~
指名:designation::~
反映-:reflect:~
創出-:create:~
受容-:accept:~
避ける:avoid する:~
不能化-:disable:~
誘発-:trigger:~
利用者:user:~
運用者:operator:~
開発者:developer:~
制御:control:~
制御-:control:~
情報:information:~
適合-:conform:~
適合性:conformance:~
却下-:reject:~
依拠-:rely:~
依拠:reliance:~
依存-:depend:~
依存関係:dependency:~
無視-:ignore:~
制約-:restrict:~
制約:restriction:~
決定-:determine:~
廃用に:obsolete:~
廃用-:obsolete:~
非推奨に:deprecate:~
設計:design:~
approach::::アプローチ
定義-:define:~
	定義されない:undefined
	定義:definition
供-:provide:~
供さな:provide しな:~
給-:supply:~
適用-:apply:~
	適用-可能:applicable
管理-:manage:~
管理:management:~
協調-:collaborate:~
承認-:endorse:~
考慮点:considerations:~
見なす:consider する:~
考える:consider する:~
考えて:consider して:~
述べる:describe する:~
述べた:describe した:~
行使-:exercise:~
既存の:existing:~
要旨する:outline する:要旨を述べる
意図-:intend:~

理解-:understand:~
処理-:process:~
処理:processing:~
	-:unprocessed
言語:language:~
適度:reasonable:~
	:reasonably
手続き:steps:~
段:step:~
使役-:employ:~
説明-:explain:~
	see
望む:wish する:~
欲する:desire する:~
	妨げる:preclude する:~
	もたらす:lead to
	放任:let
	未知:not know
利用-:use:~
利用:use:~
用立てる:use を make する:~
参照-:reference:~
既知の:known な:~
達成-:achieve:~

	呼ばれる／知られ:known as
	再-利用:reusing
	移行:transition, moving, Migration
	注意:Note that
	注記:note
	容易にする:facilitate
	促す:facilitate their
	犠牲にするであろう:reduces the likelihood
	経験的に知られて:experiments have shown
	思慮深く応用:judicious application
	資料:references
	基づく:based on
	行為:actions:~
	最小限に抑える:minimize
	最大限に得る:maximize
	呼ばれ:called
	模倣:impersonating
	~~指示:order
	意味-:mean／
	意味:meaning／

	●network
DNS:
TLS:
SSL:
HTTP:
HTTPS:
URL:
URI:
非HTTP: “non-HTTP” :: “非 HTTP” 
punycode:
uri:

registry::::レジストリ
public:
suffix:
internet::::インターネット
network::::ネットワーク
port::::ポート
protocol::::プロトコル
redirect::::リダイレクト
資源:resource::~::リソース
scheme::::スキーム
中継点:intermediary::~
server::::サーバ
service::::サービス
session::::セッション
site::::サイト
status-code:status code:::状態コード:ステータスコード
transport::::トランスポート
	トランスポート層:transport-layer
	アプリケーション層:application-layer
層:layer::~
socket::::ソケット
proxy::::プロキシ
cache::::キャッシュ
接続:connection::~
帯域幅:bandwidth::~
client::::クライアント
header::::ヘッダ
	header field::::ヘッダフィールド
field::::フィールド
listen::::リッスン
message::::メッセージ
address::::アドレス
	ヘッダ名:header field name
要請:request::~::リクエスト
応答:response::~::レスポンス
受信-:receive::~
受信:receiving::~
送信-:send::~
送信:sending::~
伝送-:transmit::~
	transmission
訪問-:visit::~
通信-:communicate::~
発行:issue::~
発行-:make::~


	●cookie
cookie:::::クッキー
	-:flag
access::::アクセス
host::::ホスト
domain::::ドメイン
下位domain:subdomain::下位 domain:下位ドメイン
	ドメイン名:domain name
	下位ディレクトリ:subdirectory
directory::::ディレクトリ
label::::ラベル
path::::パス
query::::クエリ

視野:scope::~::スコープ
属性:attribute::~
添付-:attach::~
削除-:delete::~
抹消-:evict::~
超過:excess::~
超過-:exceed::~
有効期限:expiration date::~
	expiry date
有効期間:expiration period::~
失効:expire::~
失効日時:expiry-time::~
	期限切れ
付加-:append::~
内包-:include::~
制限-:limit::~
制限:limits::~
list::::リスト
	素材:material
	複数の:multiple
置換-:replace::~
除去-:remove::~
除去:removing::~
挿入-:insert::~
	-:removal priority
状態:state::~
	状態管理:state management mechanisms
	状態情報
保管:storage::~::ストレージ
保管庫:store::~::ストア
格納-:store::~::ストア
維持-:retain::~
	上限:upper bound
	容量
	総容量
	記憶容量の制限:memory pressure

持続的:persistent::~
持続-:persist::~
存続期間:lifetime::~
有効:valid::~

読取れる:read できる:読み取れる
書込める:write できる:書き込める
書込み:write:書き込み

	読み取:read
	モード:mode
	組:pair
	総数:number of
	期間:duration
	期間内:time period
	期限
	最長:maximum
	終了
	終了時:at the end
	〜週間:weeks
	少なくかつ小容量:few and as small
	対象範囲:scope
	未来:future, later
	過去:past
	最も過去:earliest
	優先:has precedence
	優先順位:priority order
	集合:set
	経過
	総和:sum of
設定-:set::~
設定:setting::~
環境設定-:configure::~
共有-:share::~
	sharing
達-:reach:~
呈示:presentation:~
	在る:present
算出-:compute::~
更新-:update::~
	-:output
	分割:split
作成-:create:~
	-:creation
	~CONTINUE:continue
	現れる:appear
	再起動:restarts

	●構文
ABNF:
文字大小無視:case-insensitive::~
文字:character::~
合致-:match::~::マッチ
照合:matching::~::マッチング
	~~照合:collation
順序:order::~
整列:sort::~
正準化-:canonicalize::~
生成規則:production::~
生産-:produce::~
生成-:generate::~
生成:generation::~
文法:grammar:~
文法記号:grammatical term:~
文法記法:grammatical notation:~
表記
記法:notation::~
中核:core:~
規則:rule:~
	0:zero
名:name::~
名前:name::~
値:value::~
妥当:valid::~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
octet::::オクテット
key::::キー
keyword::::キーワード
byte::::バイト
	letters
space::::スペース
comma::::カンマ
semicolon::::セミコロン
backslash::::バックスラッシュ
区切子:separator::~
	区切って:separate して::~
	-:boolean
空:empty::~
文字列:string::~
	下位:sub::~
空白:whitespace::~
成分:component::~
識別子:identifier::~
変換-:convert::~
変換:conversion::~
小文字:lower case::~
構文:syntax::~
下位成分:subcomponent::~
絶対:absolute::~
size::::サイズ
認識-:recognize::~
	認識されない／できない:unrecognized
整数:integer::~
数字:digit::~

日付:date::~
日時:date and time::~
年t:year::年
月t:month::月
日t:day::日
時t:hour::時
分t:minute::分
秒t:second::秒
閏秒:leap seconds::うるう秒
秒差:delta-seconds:~
	秒t数:number of seconds
	数:number
	制御文字:controls::~
	桁:digit::~
	桁表記:

	-:型
形式:format::~
	データ形式
	二重引用符:double quote
	日付形式: 1
	日付~文字列:date string
	10 進数字:decimal
	部位:portion::~
	文字列:string::~
	並び:sequence
直列化-:serialize::~::シリアル化
直列化:serialization::~::シリアル化
連結-:concatenate::~
失敗-:fail::~
失敗:failure::~
	-:abort
畳込む:fold する::畳み込む
成功-:success:~
	successful
省略-:omit::~
	外す:omit
	組:pair::~::ペア

	●保安
policy::::ポリシー
	:ambient
security::::セキュリティ
私的閲覧:private browsing::~::プライベートブラウジング
remote::::リモート
識別情報:identifying information::~
	クロスサイト リクエストフォージェリ:cross-site request forgery
nonce::::ナンス
注入-:inject::~
防ぐ:prevent する:~
防がれ:prevent され:~
第三者主体:third-party::~
主体:party::~
	~~主体:entity::~
被害者:victim::~
被害:damage::~
懸念:concern::~
拒否-:refuse::~
軽減-:mitigate::~
再現:replay::~
追跡-:track::~
追跡:tracking::~
攻撃:attack::~
攻撃者:attacker::~
能動的:active::~::アクティブ
阻止-:block::~
阻止:blocking::~
認証:authentication::~
真正の:authentic な:~
権限:authority::~
権限付与:authorization::~
弱体化-:compromise::~
機密性:confidentiality::~
機密:confidential::~
復号-:decode::~
符号化-:encode::~
暗号化-:encrypt::~
暗号化:encryption::~
暗号:cryptography::~
署名-:sign::~
完全性:integrity::~
傍受-:intercept::~
隔離-:isolate::~
隔離:isolation::~
侵害-:disrupt::~
固定化:fixation:~
欠陥:infelicities::~
生成元:origin::~::オリジン
同一生成元:same-origin::~::同一オリジン
privacy::::プライバシー
	~privacy意識の高い:privacy-conscious
secure::::セキュア
channel::::チャンネル
敏感:sensitive::~
保護-:protect::~
保護:protection::~
秘匿情報:secret::~
脆弱性:vulnerabilities::~
強制-:force::~
	セッション強制:session fixation
risk::::リスク
堅牢:robust::~
平文:clear::~
上品:graceful::~
退行-:degrade::~
原理:principles:~
	資格証明:credentials
改めれ:alter でき:~
予測-:predict:~
	予測-不能:unpredictable
	批判の対象に挙がる:criticized
課題:issue:~
問題:problem:~
盗聴者:eavesdropper:~
悪意的な:malicious:悪意のある
上書き:overwrite:~
絡めた:entangle した:~
検索-:look up:~
直に:direct に:~
稼働-:run:~
陥穽:pitfall:落とし穴
仕掛ける:mount する:~
信用-:trust:~
	互いに信用し合っていない:mutually distrusting

	根本から払拭する:mitigate 〜 completely 
	厄介:worrisome
	弱点:weak
	混乱した使節の問題:confused deputy
	最悪:the worst
	分離:separate
	欠如:lack
	見分ける:recognize
	読み取-:learns
	偽造:forgery


	●未分類（動詞
検索取得-:retrieve:~
消費-:consume:~
表現-:represent:~
	表現-可能:representable
結付けら:associate さ:結び付けら
入力指示:prompt:~
	以外の, 除く:except
変更-:change:~
	含む:contain
対話-:interact:やりとり
対話:interaction:やりとり
	:omit, exclude

	●未分類
HTML:
API:
視野:scope::~::スコープ
web::::ウェブ
site::::サイト
browser::::ブラウザ
	~web~mail:webmail
text::::テキスト
subset::::サブセット
metadata::::メタデータ
token::::トークン
script::::スクリプト
obj:object:::オブジェクト
mode::::モード
同胞:sibling:~
具現化:rendering:~
排他的:exclusive:~
動的:dynamic:~
option::::オプション
	オプションの:optional
公開-:expose:~
内容:content:~
既定:default:~:::デフォルト
既定の:default:~:::デフォルト
挙動:behavior:ふるまい
文書:document:~
data::::データ
balance::::バランス
form::::フォーム
可視:visible:~
level::::レベル
mail::::メール
整数:integer
相違点:differences:~
	異なる:different
	期日:date
	-based:に基づく
	
	~web解析:web analytics
割当分:quota::割り当て分::クォータ
	会社:companies:~
	開始
	位置
	一致
	一定
	一度
	一方
	一連
	警告:warning
	呼称:names
	広告~network:advertising networks
	協定世界時
	初期値:initially
	是非
	成立
	相手
	存在
	存在下
	段階:step
	一致する:identical
	同様に:Similarly
	〜番台:-level
	範囲
	不在:absent
	普通
	別名
	方向:direction
	名称:name
	連続
	~GTE:greater than or equal to
	~LTE:less than or equal to

	●指示語
部分的:partial:~
全部的:full:~
全部的な:full:~
現在の:current:~
	現在:current
	後続
	後続の:subsequent
	場合:if, case ...
	場所
	多数
	以下
	以前
	内部:internal
	先頭
	全部で:total
	同時
	任意
	一形態:a form of
	一部
	他の場合:otherwise
	まるごと:in its entirety／entirely／entire
	複数
	直前
	結果:result
	結果の:resulting
	個々の:individual
	個以上
	最後の:last
	最初の:first
	時点
	自身
	自体
	少数:a few of
新たな:new:~
	新たに:newly
	唯一:the only
	両方:both
	頭部:leading
	尾部:suffix
	尾部:trailing
	末尾:trailing
	残りの部分:remainder
	残りの:remaining
	同じ:same
	別:another
	別の:another
	対応
	対象
	1 個／単独:single
	before
	below
	between
	during
	次の:the following
	次の様に:as follows
	instead
	itself
	少なくとも／いずれか:at least
	intended: 3
	most: 7
	next: 5
	non: 22
	many: 6
	後:later

●●ref_normative

[RFC1034]
    Mockapetris, P., “Domain names - concepts and facilities”, STD 13, RFC 1034, November 1987.  URL: https://tools.ietf.org/html/rfc1034

[RFC1123]
    Braden, R., “Requirements for Internet Hosts - Application and Support”, STD 3, RFC 1123, October 1989.  URL: https://tools.ietf.org/html/rfc1123

[RFC2119]
    Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, RFC 2119, March 1997.  URL: https://tools.ietf.org/html/bcp14

[RFC2616]
    Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, “Hypertext Transfer Protocol -- HTTP/1.1”, RFC 2616, June 1999.  URL: https://tools.ietf.org/html/rfc2616

[RFC3490]
    Faltstrom, P., Hoffman, P., and A. Costello, “Internationalizing Domain Names in Applications (IDNA)”, RFC 3490, March 2003. See Section 6.3 for an explanation why the normative reference to an obsoleted specification is needed.  URL: https://tools.ietf.org/html/rfc3490

[RFC4790]
    Newman, C., Duerst, M., and A. Gulbrandsen, “Internet Application Protocol Collation Registry”, RFC 4790, March 2007.  URL: https://tools.ietf.org/html/rfc4790

[RFC5234]
    Crocker, D., Ed. and P. Overell, “Augmented BNF for Syntax Specifications: ABNF”, STD 68, RFC 5234, January 2008.  URL: https://tools.ietf.org/html/rfc5234

[RFC5890]
    Klensin, J., “Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework”, RFC 5890, August 2010.  URL: https://tools.ietf.org/html/rfc5890

[USASCII]
    American National Standards Institute, “Coded Character Set -- 7-bit American Standard Code for Information Interchange”, ANSI X3.4, 1986. 


●●ref_informative

[RFC2109]
    Kristol, D. and L. Montulli, “HTTP State Management Mechanism”, RFC 2109, February 1997.  URL: https://tools.ietf.org/html/rfc2109

[RFC2965]
    Kristol, D. and L. Montulli, “HTTP State Management Mechanism”, RFC 2965, October 2000.  URL: https://tools.ietf.org/html/rfc2965

[RFC2818]
    Rescorla, E., “HTTP Over TLS”, RFC 2818, May 2000.  URL: https://tools.ietf.org/html/rfc2818

[Netscape]
    Netscape Communications Corp., “Persistent Client State -- HTTP Cookies”, 1999, URL: http://web.archive.org/web/20020803110822/http://wp.netscape.com/newsref/std/cookie_spec.html
    URL: http://curl.haxx.se/rfc/cookie_spec.html

[Kri2001]
    Kristol, D., “HTTP Cookies: Standards, Privacy, and Politics”, ACM Transactions on Internet Technology Vol. 1, #2, November 2001, URL: http://arxiv.org/abs/cs.SE/0105018

[RFC3629]
    Yergeau, F., “UTF-8, a transformation format of ISO 10646”, STD 63, RFC 3629, November 2003.  URL: https://tools.ietf.org/html/rfc3629

[RFC4648]
    Josefsson, S., “The Base16, Base32, and Base64 Data Encodings”, RFC 4648, October 2006.  URL: https://tools.ietf.org/html/rfc4648

[RFC3864]
    Klyne, G., Nottingham, M., and J. Mogul, “Registration Procedures for Message Header Fields”, BCP 90, RFC 3864, September 2004.  URL: https://tools.ietf.org/html/bcp90

[RFC5895]
    Resnick, P. and P. Hoffman, “Mapping Characters for Internationalized Domain Names in Applications (IDNA) 2008”, RFC 5895, September 2010.  URL: https://tools.ietf.org/html/rfc5895

[UTS46]
    Davis, M. and M. Suignard, “Unicode IDNA Compatibility Processing”, Unicode Technical Standards # 46, 2010, URL: https://unicode.org/reports/tr46/

[CSRF]
    Barth, A., Jackson, C., and J. Mitchell, “Robust Defenses for Cross-Site Request Forgery”, 2008, URL: http://portal.acm.org/citation.cfm?id=1455770.1455782

[Aggarwal2010]
    Aggarwal, G., Burzstein, E., Jackson, C., and D. Boneh, “An Analysis of Private Browsing Modes in Modern Browsers”, 2010, URL: http://www.usenix.org/events/sec10/tech/full_papers/Aggarwal.pdf


●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.ietf.org/">IETF</a>
による
<a href="https://www.ietf.org/rfc/rfc6265.txt">RFC 6265</a>
“HTTP State Management Mechanism”
（<a href="~SPEC_URL">HTML 版</a>）
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

発行
	Internet Engineering Task Force (IETF)
RFC
	6265
廃用
	<a href="https://tools.ietf.org/html/rfc2965">RFC 2965</a>
分類
	Standards Track
ISSN
	2070-1721
編集
	A. Barth, U.C. Berkeley
日付
	2011 年 4 月
著作者アドレス
	Adam Barth, University of California, Berkeley
	EMail: abarth@eecs.berkeley.edu
	http://www.adambarth.com/
現在の位置付け, 正誤表, フィードバックの方法
	https://www.rfc-editor.org/info/rfc6265

</script>

</head>

<body>


<header>
	<hgroup>
<h1>HTTP 状態管理の仕組み（ “HTTP cookie” ）</h1>
<h2>RFC 6265, HTTP State Management Mechanism</h2>
	</hgroup>

</header>


<div id="MAIN" style="display:none;">

	<section id="rfc.abstract">
<h2 title="Abstract">要約</h2>
<p>
この文書は~HTTP `Cookie^h と `Set-Cookie^h ~headerを定義する。
これらの~headerは、（~cookieと呼ばれる）状態~情報を~HTTP~UA側に格納させるために，~HTTP~serverにより利用され得るものであり、ほぼ状態~情報がない~HTTP~protocol越しに，~serverが状態を保つ~sessionを保守できるようにする。
~cookieには，~securityと~privacyを退行させる 多くの歴史的な欠陥があるが、 `Cookie^h と `Set-Cookie^h ~headerは~internet上で広範に利用されている。
この文書は `RFC2965$r を廃用にする。
◎
This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol. Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet. This document obsoletes RFC 2965.
</p>

	</section>
	<section id="rfc.status">
<h2 title="Status of This Memo／Copyright Notice">このメモの位置付け／著作権の告知</h2>
<p class="trans-note">【
これらの節の内容は、<a href="RFC723X-ja.html#status">RFC723X 共通ページ</a>に委譲。
ただし、著作権の年度は除く：
】</p>

<p lang="en-x-a0">
Copyright © 2011 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

	</section>

<main id="MAIN0">

	<section id="section-1">
<h2 title="Introduction">1. 序論</h2>

<p>
この文書は、~HTTPの `Cookie^h と `Set-Cookie^h ~headerを定義する。
~HTTP~serverは、 `Set-Cookie^h ~headerを用いて，~cookieと呼ばれる［
( 名前, 値 ) の組と, それに結付けられた~metadata
］を~UAに渡すことができる。
~UAは、~serverへ後続の要請を発行する際に，その~metadataと他の情報を利用して
( 名前, 値 ) の組を `Cookie^h ~header内に返すかどうか決める。
◎
This document defines the HTTP Cookie and Set-Cookie header fields. Using the Set-Cookie header field, an HTTP server can pass name/value pairs and associated metadata (called cookies) to a user agent. When the user agent makes subsequent requests to the server, the user agent uses the metadata and other information to determine whether to return the name/value pairs in the Cookie header.
</p>

<p class="trans-note">【
“~header” ：
正式には
“~header~field（ `header field^en ）”
だが、当訳では一律に “~header” と略記する。
】【
“UA”： ~UA（ `user agent^en ） — 当訳ではこの略記に統一する。
】</p>

<p>
見かけの単純さに反し、~cookieはいくつかの複雑さを孕んでいる。
例えば，~serverは、~UAに向けて送信するそれぞれの~cookieについて，その視野を指示する。
この視野は、［
~UAが~cookieを返すべき期間,
~UAが~cookieを返すべき~server,
~cookieを適用-可能な~URI~scheme
］を指示する。
◎
Although simple on their surface, cookies have a number of complexities. For example, the server indicates a scope for each cookie when sending it to the user agent. The scope indicates the maximum amount of time in which the user agent should return the cookie, the servers to which the user agent should return the cookie, and the URI schemes for which the cookie is applicable.
</p>

<p>
歴史的な理由から、~cookieは，~securityと~privacyに関わる いくつかの欠陥を孕んでいる。
例えば~serverは、 `Secure$a 属性により［
当の~cookieは “~secure” 接続~用に意図されている
］ことを指示できるが、それは，能動的~network攻撃者の存在下において完全性を供するものではない。
同様に、~web~browserに利用される通例の “同一生成元~policy” （ `same-origin policy^en ）により，異なる~portを介して検索取得される内容は互いに隔離されるにも関わらず、所与の~host用の~cookieは，同じ~host上のすべての~portにわたって共有される。
◎
For historical reasons, cookies contain a number of security and privacy infelicities. For example, a server can indicate that a given cookie is intended for "secure" connections, but the Secure attribute does not provide integrity in the presence of an active network attacker. Similarly, cookies for a given host are shared across all the ports on that host, even though the usual "same-origin policy" used by web browsers isolates content retrieved via different ports.
</p>

<p>
この仕様が想定する読者は、~cookieを生成する~serverの開発者と~cookieを消費する~UAの開発者である。
◎
There are two audiences for this specification: developers of cookie-generating servers and developers of cookie-consuming user agents.
</p>

<p>
~UAとの相互運用性を最大限に得るため、~serverは，`4$secに定義される~well-behaved-profileに従って，~cookieを生成する~SHOULDである。
◎
To maximize interoperability with user agents, servers SHOULD limit themselves to the well-behaved profile defined in Section 4 when generating cookies.
</p>

<p>
~UAは、`4$secに定義される~well-behaved-profileに適合しない既存の~serverとの相互運用性を最大限に得るため、`5$secに定義される より~~寛容な処理~規則を実装し~MUST。
◎
User agents MUST implement the more liberal processing rules defined in Section 5, in order to maximize interoperability with existing servers that do not conform to the well-behaved profile defined in Section 4.
</p>

<p>
この文書は、これらの~headerの構文と意味論を，~internetにおける実際の利用に沿う形で指定する。
特に、この文書は，今日の利用を超えた新たな構文や意味論を創出するものではない。
`4$sec に与えた，~cookie生成についての推奨は、現在の~serverの挙動の好ましい~subsetを表現する。
`5$secにて与える，より~~寛容な~cookie処理~algoは、今日~利用されている構文や意味論の~variationについて，そのすべてを推奨するものではない。
この文書では、一部の既存の~softwareにおける，推奨される~protocolとの有意な差異についても説明される。
◎
This document specifies the syntax and semantics of these headers as they are actually used on the Internet. In particular, this document does not create new syntax or semantics beyond those in use today. The recommendations for cookie generation provided in Section 4 represent a preferred subset of current server behavior, and even the more liberal cookie processing algorithm provided in Section 5 does not recommend all of the syntactic and semantic variations in use today. Where some existing software differs from the recommended protocol in significant ways, the document contains a note explaining the difference.
</p>

<p>
この文書~以前に、少なくとも 3 つの，~cookieについて述べた文書がある：
いわゆる "Netscape ~cookie仕様"
`Netscape$r,
`RFC2109$r,
`RFC2965$r
。
しかしながら、これらのどの文書も `Cookie^h ~headerと `Set-Cookie^h ~headerが~internet上で実際にどう利用されているかについて述べていない（歴史的~文脈については `Kri2001$r を見よ）。
~HTTP状態~管理の仕組みについて述べている，以前の IETF 仕様に関連して、この文書は以下の~actionを要請する：
◎
Prior to this document, there were at least three descriptions of cookies: the so-called "Netscape cookie specification" [Netscape], RFC 2109 [RFC2109], and RFC 2965 [RFC2965]. However, none of these documents describe how the Cookie and Set-Cookie headers are actually used on the Internet (see [Kri2001] for historical context). In relation to previous IETF specifications of HTTP state management mechanisms, this document requests the following actions:
</p>

<ol>
	<li>
`RFC2109$r
の位置付けを Historic （歴史的）に変更する（これは
`RFC2965$r
により，すでに廃用にされている）。
◎
Change the status of [RFC2109] to Historic (it has already been obsoleted by [RFC2965]).
</li>
	<li>
`RFC2965$r
の位置付けを Historic に変更する。
◎
Change the status of [RFC2965] to Historic.
</li>
	<li>
`RFC2965$r
は、この文書により廃用にされる。
◎
Indicate that [RFC2965] has been obsoleted by this document.
</li>
</ol>

<p>
特に、 `RFC 2965$r を Historic に移行して廃用するに伴い、この文書は
`Cookie2^h, `Set-Cookie2^h
両~headerを非推奨にする。
◎
In particular, in moving RFC 2965 to Historic and obsoleting it, this document deprecates the use of the Cookie2 and Set-Cookie2 header fields.
</p>

	</section>
	<section id="section-2">
<h2 title="Conventions">2. 表記規約</h2>

		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoの記述に利用されている各種記号（ ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>
		</section>
		<section id="section-2.1">
<h3 title="Conformance Criteria">2.1. 適合性の判定基準</h3>

<p>
この文書における次の~keywordは、 `RFC2119$r に則って解釈されるものとする
⇒＃
“〜しなければ（〜しては）~MUST_NOT” = “MUST (NOT)”,
“〜する~SHOULDである（でない）” = “SHOULD (NOT)”,
“〜しても~MAY” = “MAY”
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
</p>

<!-- 
“要求される” = REQUIRED,
“推奨される” = “RECOMMENDED”,
“任意選択 ” = “OPTIONAL”,
-->


<p>
~algoの中の命令的言い回しによる要件（例えば “頭部の~space文字並びを剥ぎ取る”, “~RET ~F ” など）は、~algoを引用する際に利用されている~keyword（ “〜し~MUST”, “〜する~SHOULD”, “〜しても~MAY”, 等々）の意味の下に解釈されることになる。
◎
Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the key word ("MUST", "SHOULD", "MAY", etc.) used in introducing the algorithm.
</p>

<p>
~algoまたは特定の手続きとして記される適合性の要件は、最終的な結果が等価になるのであれば，どう実装されてもよい。
特に、この仕様で定義される~algoは理解し易くなるように記述されており，処理能は~~考慮されていない。
◎
Conformance requirements phrased as algorithms or specific steps can be implemented in any manner, so long as the end result is equivalent. In particular, the algorithms defined in this specification are intended to be easy to understand and are not intended to be performant.
</p>

		</section>
		<section id="section-2.2">
<h3 title="Syntax Notation">2.2. 構文の記法</h3>

<p>
この仕様は
`RFC5234$r
による~ABNF（ Augmented Backus-Naur Form ）記法を用いる。
◎
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234].
</p>

<p>
次の中核~規則が
<a href="~IETF/rfc5234#appendix-B.1">RFC 5234, Appendix B.1</a>
【<a href="http://www.cam.hi-ho.ne.jp/mendoxi/rfc/rfc5234j.html#sB" >和訳</a>】
にて定義されるものとして，参照される
⇒＃
`ALPHA^P （ `letters^en ）,
`CR^P （ `carriage return^en ）,
`CRLF^P （ CR LF ）,
`CTL^P （制御文字）,
`DIGIT^P （ 10 進数字 0-9 ）,
`DQUOTE^P （二重引用符）,
`HEXDIG^P （ 16 進数字 0-9/A-F/a-f ）,
`LF^P （ `line feed^en ）,
`NUL^P （ null ~octet ）,
`OCTET^P （ `NUL^P 以外の任意の 8-bit 並びの~data）,
`SP^P （ `space^en ）,
`HTAB^P （ `horizontal tab^en ）,
`CHAR^P （【 `NUL^P 以外の】任意の `USASCII$r 文字）,
`VCHAR^P （任意の可視 `USASCII$r 文字）,
`WSP^P （空白【 `SP^P と `HTAB^P 】）
◎
The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTLs (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), NUL (null octet), OCTET (any 8-bit sequence of data except NUL), SP (space), HTAB (horizontal tab), CHAR (any [USASCII] character), VCHAR (any visible [USASCII] character), and WSP (whitespace).
</p>


<p>
`OWS$P （~optionの空白）規則は、 0 個以上の連続する空白が現れても~MAY場所に利用される：
◎
The OWS (optional whitespace) rule is used where zero or more linear whitespace characters MAY appear:
</p>

<pre class="ABNF">
`OWS@P            = *( [ `obs-fold$P ] WSP )
                 ; <span title="optional whitespace"
>"~optionの" 空白</span>
`obs-fold@P       = CRLF
</pre>

<p>
`OWS$P は、空（生産されない）または 1 個の `SP^P 文字として生産される~SHOULDである。
◎
OWS SHOULD either not be produced or be produced as a single SP character.
</p>

		</section>
		<section id="section-2.3">
<h3 title="Terminology">2.3. 各種用語</h3>

<p>
語［
UA,
~client,
~server,
~proxy,
生成元~server
］の意味は、 HTTP/1.1 仕様（ `2616-1.3$sec `RFC2616$r ）に従う。
【 <a href="~RFC7230#section-2.1">RFC7230, 2.1 節</a> 】
【 “~proxy” は利用されていない】
◎
The terms user agent, client, server, proxy, and origin server have the same meaning as in the HTTP/1.1 specification ([RFC2616], Section 1.3).
</p>

<p>
`要請~host@
とは、~UAに既知の~host名 —
~UAが~HTTP要請を送信している相手,
あるいは~UAが~HTTP応答を受信した相手（すなわち，~UAが対応する~HTTP要請を送信した相手）の~host名
— を意味する。
◎
The request-host is the name of the host, as known by the user agent, to which the user agent is sending an HTTP request or from which it is receiving an HTTP response (i.e., the name of the host to which it sent the corresponding HTTP request).
</p>

<p>
語
`request-uri@P
は、 `2616-5.1.2$sec にて定義される。
【 <a href="~RFC7230#section-5.3">RFC7230, 5.3 節</a> 】
◎
The term request-uri is defined in Section 5.1.2 of [RFC2616].
</p>


<p>
2 個の［
~octet並び
］は、 `RFC4790$r にて定義される
<a href="~IETF/rfc4790#section-9.2.1">i;ascii-casemap ~~照合</a>
の下に等価であるとき, そのときに限り，
`文字大小無視で合致する@
とされる。
【 ASCII 範囲の~octetの， a-z, A-Z の範囲の文字のみ、文字の大小を区別せずに，対応する文字を同一視する。】
◎
Two sequences of octets are said to case-insensitively match each other if and only if they are equivalent under the i;ascii-casemap collation defined in [RFC4790].
</p>

<p>
`文字列@
とは、非 `NUL^P の~octetからなる並びを意味する。
【したがって、語 “文字” も，特に断らない限り，（非 NUL の） 1 個の~octetを意味する。また、空~文字列（長さ 0 の`文字列$）の略記として，語 “空” が用いられる。】
◎
The term string means a sequence of non-NUL octets.
</p>

		</section>
	</section>
	<section id="section-3">
<h2 title="Overview">3. 概観</h2>

<p>
この節では、生成元~serverが状態~情報を~UAに向けて送信する仕方,
および~UAがその状態~情報を生成元~serverに返す仕方，について要旨する。
◎
This section outlines a way for an origin server to send state information to a user agent and for the user agent to return the state information to the origin server.
</p>

<p>
生成元~serverは、~UAに状態を格納させるために，~HTTP応答に `Set-Cookie^h ~headerを内包させる。
~UAによる後続の要請においては、~UAは，以前に `Set-Cookie^h ~headerで受信した~cookieを含ませた `Cookie^h 要請~headerを，生成元~serverに返す。
生成元~serverが、その `Cookie^h ~headerを無視するのも, その内容を~appが定義する目的に利用するのも，任意である。
◎
To store state, the origin server includes a Set-Cookie header in an HTTP response. In subsequent requests, the user agent returns a Cookie request header to the origin server. The Cookie header contains cookies the user agent received in previous Set-Cookie headers. The origin server is free to ignore the Cookie header or use its contents for an application-defined purpose.
</p>

<p>
生成元~serverは、任意の応答に `Set-Cookie^h 応答~headerを送信して~MAY。
~UAは 100 番台の~status-codeを伴う応答に対しては，その中の `Set-Cookie^h ~headerを無視しても~MAYが、他の応答（ 400 番台, および 500 番台の~status-codeを伴う応答も含む）の中の `Set-Cookie^h ~headerについては，処理し~MUST。
生成元~serverは、単独の応答に複数の `Set-Cookie^h ~headerを内包させられる。
`Cookie^h や `Set-Cookie^h ~headerの存在は、~HTTP~cacheにより応答を格納したり再-利用することを妨げるものではない。
◎
Origin servers MAY send a Set-Cookie response header with any response. User agents MAY ignore Set-Cookie headers contained in responses with 100-level status codes but MUST process Set-Cookie headers contained in other responses (including responses with 400- and 500-level status codes). An origin server can include multiple Set-Cookie header fields in a single response. The presence of a Cookie or a Set-Cookie header field does not preclude HTTP caches from storing and reusing a response.
</p>

<p>
生成元~serverは、単独の~header内に，複数の `Set-Cookie^h ~header値を畳込む~SHOULDでない。
~HTTP~headerを畳込む通例的な仕組み（ `RFC2616$r にて定義される）は、
`Set-Cookie^h における `,^ch の利用と衝突するので， `Set-Cookie^h ~headerの意味論を変更し得る。
◎
Origin servers SHOULD NOT fold multiple Set-Cookie header fields into a single header field. The usual mechanism for folding HTTP headers fields (i.e., as defined in [RFC2616]) might change the semantics of the Set-Cookie header field because the %x2C (",") character is used by Set-Cookie in a way that conflicts with such folding.
</p>

		<section id="section-3.1">
<h3 title="Examples">3.1. 例</h3>

<p>
~serverは、~UAへの~HTTP応答に `Set-Cookie^h ~headerを利用して，短い`文字列$を送信できる
— ~UAは、その~cookieの視野に入る未来の~HTTP要請において，その文字列を返すことになる。
例えば，~serverは、
( 名前 `SID^s, 値 `31d4d96e407aad42^s )
の “~session識別子” を，~UAに向けて送信できる。
~UAは、後続の要請にて，その~session識別子を返すことになる：
◎
Using the Set-Cookie header, a server can send the user agent a short string in an HTTP response that the user agent will return in future HTTP requests that are within the scope of the cookie. For example, the server can send the user agent a "session identifier" named SID with the value 31d4d96e407aad42. The user agent then returns the session identifier in subsequent requests.
</p>

<!-- 
Server -&gt; User Agent
User Agent -&gt; Server
 -->

<pre class="example">
<span>== ~server → ~UA ==</span>

Set-Cookie: SID=31d4d96e407aad42

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42
</pre>


<p>
~serverは、
`Path$a, `Domain$a
属性を用いて，~cookieの既定の視野を改めれる。
例えば~serverは、［
`example.com^s のどの~pathに対しても, あるいはどの下位domainに対しても，その~cookieを返す
］よう，~UAに指図できる：
◎
The server can alter the default scope of the cookie using the Path and Domain attributes. For example, the server can instruct the user agent to return the cookie to every path and every subdomain of example.com.
</p>

<pre class="example">
<span>== ~server → ~UA ==</span>

Set-Cookie: SID=31d4d96e407aad42; Path=/; Domain=example.com

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42
</pre>


<p>
次の例に示されるように、~serverは，複数の~cookieを~UA側に格納できる。
例えば，~serverは、 2 個の `Set-Cookie^h ~headerを返すことにより、~session識別子と同時に，利用者が選好する言語も格納できる。
~serverは、より~securityに敏感な~session識別子に対しては，追加の保護を供する
`Secure$a, `HttpOnly$a
`属性$を利用することに注意（ `4.1.2$secを見よ）：
◎
As shown in the next example, the server can store multiple cookies at the user agent. For example, the server can store a session identifier as well as the user's preferred language by returning two Set-Cookie header fields. Notice that the server uses the Secure and HttpOnly attributes to provide additional security protections for the more sensitive session identifier (see Section 4.1.2.)
</p>

<pre class="example">
<span>== ~server → ~UA ==</span>

Set-Cookie: SID=31d4d96e407aad42; Path=/; Secure; HttpOnly
Set-Cookie: lang=en-US; Path=/; Domain=example.com

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42; lang=en-US
</pre>


<p>
上の `Cookie^h ~headerには、
2 個の~cookie
— 名前 `SID^l, および名前 `lang^l の~cookie —
が含まれていることに注意。
~UAの “複数~session” に渡って（例えば~UAの再起動を挟んで）~cookieを持続させたいと望むなら、~serverは，
`Expires$a 属性にその有効期限を指定できる。
~UAは、自身の~cookie保管庫の総容量が割当分を超過した場合や，利用者が手動で~serverの~cookieを削除した場合など、有効期限が過ぎる前に~cookieを削除し得ることに注意。
◎
Notice that the Cookie header above contains two cookies, one named SID and one named lang. If the server wishes the user agent to persist the cookie over multiple "sessions" (e.g., user agent restarts), the server can specify an expiration date in the Expires attribute. Note that the user agent might delete the cookie before the expiration date if the user agent's cookie store exceeds its quota or if the user manually deletes the server's cookie.
</p>

<pre class="example">
<span>== ~server → ~UA ==</span>

Set-Cookie: lang=en-US; Expires=Wed, 09 Jun 2021 10:18:14 GMT

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42; lang=en-US
</pre>

<p>
最後に，~cookieを除去するためには、~serverは，有効期限を過去にした `Set-Cookie^h ~headerを返す。
この除去が成功するのは、
`Set-Cookie^h ~headerの中の［
`Path$a, `Domain$a
］両~属性とも，~cookieの作成-時に利用された値に合致するときに限られる。
◎
Finally, to remove a cookie, the server returns a Set-Cookie header with an expiration date in the past. The server will be successful in removing the cookie only if the Path and the Domain attribute in the Set-Cookie header match the values used when the cookie was created.
</p>

<pre class="example">
<span>== ~server → ~UA ==</span>

Set-Cookie: lang=; Expires=Sun, 06 Nov 1994 08:49:37 GMT

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42
</pre>


		</section>
	</section>
	<section id="section-4">
<h2 title="Server Requirements">4. ~serverに課される要件</h2>

<p>
この節では
`Cookie^h と `Set-Cookie^h ~headerの構文と意味論の
~well-behaved-profileについて述べる。
◎
This section describes the syntax and semantics of a well-behaved profile of the Cookie and Set-Cookie headers.
</p>

		<section id="section-4.1">
<h3 title="Set-Cookie">4.1. `Set-Cookie^h ~header</h3>

<p>
`Set-Cookie^h ~HTTP応答~headerは、~serverから~UAへ~cookieを送信するときに利用される。
◎
The Set-Cookie HTTP response header is used to send cookies from the server to the user agent.
</p>

			<section id="section-4.1.1">
<h4 title="Syntax">4.1.1. 構文</h4>

<div >
<p>
概略的には、
`Set-Cookie^h 応答~headerは，次の並びで与えられる
⇒＃
~header名 `Set-Cookie^l,
文字 `:^ch,
1 個の~cookie
</p>

<p>
ここで、~cookieは，次の並びで与えられる：
</p>

<ol>
	<li>
( ~cookieの名前（ `cookie-name$P ）, ~cookieの値（ `cookie-value$P ） )
の組（ `cookie-pair$P ）
</li>
	<li>
0 個~以上の`属性$（ `cookie-av$P ）
— そのそれぞれは組
( 属性~名, 属性~値 )
を与える
</li>
</ol>

<p>
~serverは、次の文法に適合しない `Set-Cookie^h ~headerを送信する~SHOULDでない：
</p>
◎
Informally, the Set-Cookie response header contains the header name "Set-Cookie" followed by a ":" and a cookie. Each cookie begins with a name-value-pair, followed by zero or more attribute-value pairs. Servers SHOULD NOT send Set-Cookie headers that fail to conform to the following grammar:
</div>

<pre class="ABNF">
`set-cookie-header@P
      = "Set-Cookie:" SP `set-cookie-string$P
`set-cookie-string@P
      = `cookie-pair$P *( ";" SP `cookie-av$P )
`cookie-pair@P
      = `cookie-name$P "=" `cookie-value$P
`cookie-name@P
      = `token$P
`cookie-value@P
      = *`cookie-octet$P
      / ( DQUOTE *`cookie-octet$P DQUOTE )
`cookie-octet@P
      = `%x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E^_
      ; <span class="comment">
`CTL^P, 空白, `DQUOTE^P, ~comma, ~semicolon, ~backslash を除く US-ASCII 文字
◎
US-ASCII characters excluding CTLs, whitespace DQUOTE, comma, semicolon, and backslash
</span>

`token@P
      = &lt;`token^P&gt;
      ; <span class="comment">
`2616-2.2$secにて定義される
【<a href="~RFC7230#section-3.2.6">RFC7230, 3.2.6 節</a>】
◎
defined in [RFC2616], Section 2.2
</span>

`cookie-av@P
      = `expires-av$P
      / `max-age-av$P
      / `domain-av$P
      / `path-av$P
      / `secure-av$P
      / `httponly-av$P
      / `extension-av$P
`expires-av@P
      = "Expires=" `sane-cookie-date$P
`sane-cookie-date@P
      = &lt;`rfc1123-date^P&gt;
      ; <span class="comment">
`2616-3.3.1$secにて定義される
【閏秒は許容されないことを除いて、 RFC7231, `IMF-fixdate$P に一致する】
◎
defined in [RFC2616], Section 3.3.1
</span>

`max-age-av@P
      = "Max-Age=" `non-zero-digit$P *DIGIT
      ; <span class="comment">
実施においては、 `expires-av$P, `max-age-av$P とも，~UAが表現-可能な日付の~~範囲に制限される。
◎
In practice, both expires-av and max-age-av are limited to dates representable by the user agent.
</span>

`non-zero-digit@P
      = `%x31-39^_
      ; <span class="comment">
数字 1 〜 9
◎
digits 1 through 9
</span>

`domain-av@P
      = "Domain=" `domain-value$P
`domain-value@P
      = &lt;subdomain&gt;
      ; <span class="comment">
`1034-3.5$secにて定義され， `1123-2.1$secにて増補される
◎
defined in [RFC1034], Section 3.5, as enhanced by [RFC1123], Section 2.1
</span>

`path-av@P
      = "Path=" `path-value$P
`path-value@P
      = <ins >*</ins>&lt;<span class="comment">
`CTL^P, `;^ch 以外の任意の `CHAR^P
◎
any CHAR except CTLs or ";"
</span>&gt;
`secure-av@P
      = "Secure"
`httponly-av@P
      = "HttpOnly"
`extension-av@P
      = <ins >*</ins>&lt;<span class="comment">
`CTL^P, `;^ch 以外の任意の `CHAR^P
◎
any CHAR except CTLs or ";"
</span>&gt;
</pre>

<p class="trans-note">【
`path-value$P と `extension-av$P の先頭の `*^P は、
<a href="~errata6265=3444">正誤表</a>による修正（ Verified ）による。
】</p>

<p>
上の中の一部の文法記号は、この文書の文法記法（ ~ABNF `RFC5234$r ）とは異なる記法を利用する文書を参照していることに注意。
◎
Note that some of the grammatical terms above reference documents that use different grammatical notations than this document (which uses ABNF from [RFC5234]).
</p>

<p>
`cookie-value$P の意味論は、この文書では定義されない。
◎
The semantics of the cookie-value are not defined by this document.
</p>

<p>
`cookie-value$P の中に任意の~dataを格納したいと望む~serverは、~UAとの互換性を最大限に得るためには，その~dataを符号化する~SHOULDである（例えば， Base64 `RFC4648$r を用いて）。
◎
To maximize compatibility with user agents, servers that wish to store arbitrary data in a cookie-value SHOULD encode that data, for example, using Base64 [RFC4648].
</p>

<p>
`set-cookie-string$P の中で，文法記号 `cookie-av$P が生産する部位は、
`属性@
と呼ばれる。
~UAとの互換性を最大限に得るためには、~serverは，同じ `set-cookie-string$P の中に同じ名前の 2 個の属性を生産する~SHOULDでない。
（~UAがこの場合をどう扱うかについては、 `5.3$secを見よ）
◎
The portions of the set-cookie-string produced by the cookie-av term are known as attributes. To maximize compatibility with user agents, servers SHOULD NOT produce two attributes with the same name in the same set-cookie-string. (See Section 5.3 for how user agents handle this case.)
</p>


<p>
~serverは、同じ応答~内に同じ `cookie-name$P の複数の `Set-Cookie^h ~headerを内包する~SHOULDでない。
（~UAがこの場合をどう扱うかについては、 `5.2$secを見よ。）
◎
Servers SHOULD NOT include more than one Set-Cookie header field in the same response with the same cookie-name. (See Section 5.2 for how user agents handle this case.)
</p>


<p>
~serverが `Set-Cookie^h ~headerを含んでいる複数の応答を，同時に~UAに送信した場合（例えば，複数の~socket越しに~UAと通信するとき）、これらの応答は “競合” を生じさせ、予測-不能な挙動がもたらされ得る。
◎
If a server sends multiple responses containing Set-Cookie headers concurrently to the user agent (e.g., when communicating with the user agent over multiple sockets), these responses create a "race condition" that can lead to unpredictable behavior.
</p>

<p class="note">注記：
一部の既存の~UAは、 2 桁表記の年tの解釈が他と異なる。
互換性の課題を避けるため、~serverは，
`RFC1123$r に則り，年tの表記に 4 桁を要する `rfc1123-date^P 形式を利用する~SHOULDである。
◎
NOTE: Some existing user agents differ in their interpretation of two-digit years. To avoid compatibility issues, servers SHOULD use the rfc1123-date format, which requires a four-digit year.
</p>

<p class="note">注記：
一部の~UAは、~cookie内の日付を 32-bit の UNIX `time_t^c 型の値として格納し, 処理する。
一部の~systemには， `time_t^c 処理を~supportする~libraryに実装~bugがあり、その種の~UAでは， 2038 年より後の日付が正しく処理されないかもしれない。
◎
NOTE: Some user agents store and process dates in cookies as 32-bit UNIX time_t values. Implementation bugs in the libraries supporting time_t processing on some systems might cause such user agents to process dates after the year 2038 incorrectly.
</p>

			</section>
			<section id="section-4.1.2">
<h4 title="Semantics (Non-Normative)">4.1.2. 意味論（参考）</h4>

<p>
この節では、 `Set-Cookie^h ~headerの意味論を単純~化して述べる。
これらの意味論は、~serverにおける~cookieの最も共通的な利用を理解するには十分なものである。
全部的な意味論は `5$secにて述べる。
◎
This section describes simplified semantics of the Set-Cookie header. These semantics are detailed enough to be useful for understanding the most common uses of cookies by servers. The full semantics are described in Section 5.
</p>

<p>
~UAが `Set-Cookie^h ~headerを受信した際は、その~cookieを，その属性もひっくるめて格納する。
~UAは、後続して~HTTP要請を発行する際には、適用-可能, かつ まだ失効していない~cookieを `Cookie^h ~headerに内包させる。
◎
When the user agent receives a Set-Cookie header, the user agent stores the cookie together with its attributes. Subsequently, when the user agent makes an HTTP request, the user agent includes the applicable, non-expired cookies in the Cookie header.
</p>

<p id="_-store-cookie">
~UAが，すでに格納されている~cookieと同じ［
`cookie-name$P,
`domain-value$P,
`path-value$P
］の，新たな`~cookieを受信した$場合、既存の~cookieは抹消され，新たな~cookieに置換される。
~serverは、新たな~cookieを
— その `Expires$a 属性の値を過去に設定した上で —
~UAに送信することにより，~cookieを削除できることに注意。
◎
If the user agent receives a new cookie with the same cookie-name, domain-value, and path-value as a cookie that it has already stored, the existing cookie is evicted and replaced with the new cookie. Notice that servers can delete cookies by sending the user agent a new cookie with an Expires attribute with a value in the past.
</p>

<p>
~cookieの属性により指示されない限り、~cookieは、（例えば，下位domainではなく）生成元~serverに対してのみ返され，現在の~sessionの終了時に失効する（ “~sessionの終了” は~UAにより定義される）。
~UAは、認識できない~cookie属性は，無視する（~cookieまるごと，ではなく）。
◎
Unless the cookie's attributes indicate otherwise, the cookie is returned only to the origin server (and not, for example, to any subdomains), and it expires at the end of the current session (as defined by the user agent). User agents ignore unrecognized cookie attributes (but not the entire cookie).
</p>





				<section id="section-4.1.2.1">
<h5 title="The Expires Attribute">4.1.2.1. `Expires^a 属性</h5>

<p>
`Expires$a 属性は、~cookieの最長の存続期間を指示するものであり，~cookieが失効する日時により表現される。
~UAには、指定された期日まで~cookieを維持することは，要求されない。
事実、~UAは，記憶容量上限や~privacy懸念の観点から，~cookieを抹消することが多い。
◎
The Expires attribute indicates the maximum lifetime of the cookie, represented as the date and time at which the cookie expires. The user agent is not required to retain the cookie until the specified date has passed. In fact, user agents often evict cookies due to memory pressure or privacy concerns.
</p>

				</section>
				<section id="section-4.1.2.2">
<h5 title="The Max-Age Attribute">4.1.2.2. `Max-Age^a 属性</h5>

<p>
`Max-Age$a 属性もまた、~cookieの最長の存続期間を指示するものであり，~cookieが失効するまでの秒t数で表現される。
~UAには、指定された期間が経過するまで~cookieを維持することは要求されない。
事実、~UAは，記憶容量上限や~privacy懸念の観点から，~cookieを抹消することが多い。
◎
The Max-Age attribute indicates the maximum lifetime of the cookie, represented as the number of seconds until the cookie expires. The user agent is not required to retain the cookie for the specified duration. In fact, user agents often evict cookies due to memory pressure or privacy concerns.
</p>

<p class="note">注記：
一部の既存の~UAは `Max-Age$a 属性を~supportしない。
`Max-Age$a 属性を~supportしない~UAはこの属性を無視する。
◎
NOTE: Some existing user agents do not support the Max-Age attribute. User agents that do not support the Max-Age attribute ignore the attribute.
</p>

<p>
~cookieに `Max-Age$a, `Expires$a のいずれの属性も与えられている場合、
`Max-Age$a 属性が優先され，~cookieの有効期限を制御する。
~cookieに `Max-Age$a と `Expires$a のいずれの属性も与えられていない場合、
~UAは（~UAにより定義される） “現在の~sessionの終了” まで，~cookieを維持することになる。
◎
If a cookie has both the Max-Age and the Expires attribute, the Max-Age attribute has precedence and controls the expiration date of the cookie. If a cookie has neither the Max-Age nor the Expires attribute, the user agent will retain the cookie until "the current session is over" (as defined by the user agent).
</p>

				</section>
				<section id="section-4.1.2.3">
<h5 title="The Domain Attribute">4.1.2.3. `Domain^a 属性</h5>

<p>
`Domain$a 属性は、~cookieが送信されることになる~hostを指定する。
例えば， `Domain$a 属性の値が
"`example.com^s"
なら、
~UAは，
`example.com^s ／
`www.example.com^s ／
`www.corp.example.com^s
へ向けて~HTTP要請を送信する際に、その~cookieを `Cookie^h ~headerに内包させることになる（
先頭の `.^ch は（もし在れば），その文字が許可されていなくても無視されるが、末尾に `.^ch が在る場合，~UAはその属性を無視することになることに注意）。
~serverが `Domain$a 属性を省略した場合、
~UAは生成元~serverに向けてのみ~cookieを返すことになる。
◎
The Domain attribute specifies those hosts to which the cookie will be sent. For example, if the value of the Domain attribute is "example.com", the user agent will include the cookie in the Cookie header when making HTTP requests to example.com, www.example.com, and www.corp.example.com. (Note that a leading %x2E ("."), if present, is ignored even though that character is not permitted, but a trailing %x2E ("."), if present, will cause the user agent to ignore the attribute.) If the server omits the Domain attribute, the user agent will return the cookie only to the origin server.
</p>

<p class="warning"><strong>警告：</strong>
一部の既存の~UAは、 `Domain$a 属性が不在であっても， `Domain$a 属性が在って，現在の~host名を含んでいるかのように扱う。
例えば，
`example.com^s
が `Domain$a 属性の無い `Set-Cookie^h ~headerを返した場合、これらの~UAは，その~cookieを
`www.example.com^s
にも誤って送信することになる。
◎
WARNING: Some existing user agents treat an absent Domain attribute as if the Domain attribute were present and contained the current host name. For example, if example.com returns a Set-Cookie header without a Domain attribute, these user agents will erroneously send the cookie to www.example.com as well.
</p>


<p>
~UAは、~cookieの `Domain$a 属性が，その~cookieの生成元~serverを内包する視野を指定していない限り、その~cookieを却下することになる。
例えば、
`foo.example.com^s
から受信された~cookieの `Domain$a 属性の値が
"`example.com^s"
や
"`foo.example.com^s"
であれば，その~cookieは受容されることになる一方、
`Domain$a 属性の値が
"`bar.example.com^s"
や
"`baz.foo.example.com^s"
であれば，その~cookieは受容されないことになる。
◎
The user agent will reject cookies unless the Domain attribute specifies a scope for the cookie that would include the origin server. For example, the user agent will accept a cookie with a Domain attribute of "example.com" or of "foo.example.com" from foo.example.com, but the user agent will not accept a cookie with a Domain attribute of "bar.example.com" or of "baz.foo.example.com".
</p>

<p class="note">注記：
~security上の理由から、多くの~UAでは，`~public~suffix$に対応する `Domain$a 属性は却下するように環境設定されている。
例えば、一部の~UAは
"`com^s" や "`co.uk^s"
などの `Domain$a 属性を却下することになる。
（詳細は `5.3$secに。）
◎
NOTE: For security reasons, many user agents are configured to reject Domain attributes that correspond to "public suffixes". For example, some user agents will reject Domain attributes of "com" or "co.uk". (See Section 5.3 for more information.)
</p>

				</section>
				<section id="section-4.1.2.4">
<h5 title="The Path Attribute">4.1.2.4. `Path^a 属性</h5>

<p>
それぞれの~cookieの視野は、［
その
`Path$a 属性で制御される，~pathの集合
］に制限される。
~serverが `Path$a 属性を省略した場合、~UAは， `request-uri$P の~path成分の “~directory” を，既定の値として利用することになる（詳細は `5.1.4$sec）。
◎
The scope of each cookie is limited to a set of paths, controlled by the Path attribute. If the server omits the Path attribute, the user agent will use the "directory" of the request-uri's path component as the default value. (See Section 5.1.4 for more details.)
</p>

<p>
~UAは、 `request-uri$P の~path部位が~cookieの `Path$a 属性に合致する（またはその下位~directoryになっている）場合に限り，その~cookieを~HTTP要請に内包させることになる
— ここで， `/^ch は、~directory区切子として解釈される。
◎
The user agent will include the cookie in an HTTP request only if the path portion of the request-uri matches (or is a subdirectory of) the cookie's Path attribute, where the %x2F ("/") character is interpreted as a directory separator.
</p>

<p>
所与の~hostの中で，~pathが異なる~cookieを互いに隔離することは、一見 有用であるが，~securityは `Path$a 属性に依存できない（ `8$secを見よ）。
◎
Although seemingly useful for isolating cookies between different paths within a given host, the Path attribute cannot be relied upon for security (see Section 8).
</p>

				</section>
				<section id="section-4.1.2.5">
<h5 title="The Secure Attribute">4.1.2.5. `Secure^a 属性</h5>

<p>
`Secure$a 属性は、~cookieの視野を “~secure” ~channel
に制限する（“~secure” の意味は~UAにより定義される）。
~cookieが `Secure$a 属性を持つとき、~UAは~HTTP要請が~secure~channel（概して~TLS — HTTP over Transport Layer Security `RFC2818$r
）越しに伝送される場合に限り、要請~内にその~cookieを内包させることになる。
◎
The Secure attribute limits the scope of the cookie to "secure" channels (where "secure" is defined by the user agent). When a cookie has the Secure attribute, the user agent will include the cookie in an HTTP request only if the request is transmitted over a secure channel (typically HTTP over Transport Layer Security (TLS) [RFC2818]).
</p>

<p>
能動的~network攻撃者から~cookieを保護することは，一見 有用であるが、
`Secure$a 属性が保護するのは~cookieの機密性に限られる。
能動的~network攻撃者は、~secureでない~channelから `Secure$a ~cookieを上書きして，それらの完全性を侵害できる（詳細は `8.6$secに）。
◎
Although seemingly useful for protecting cookies from active network attackers, the Secure attribute protects only the cookie's confidentiality. An active network attacker can overwrite Secure cookies from an insecure channel, disrupting their integrity (see Section 8.6 for more details).
</p>

				</section>
				<section id="section-4.1.2.6">
<h5 title="The HttpOnly Attribute">4.1.2.6. `HttpOnly^a 属性</h5>

<p>
`HttpOnly$a 属性は、~cookieの視野を~HTTP要請に制限する。
特に，この属性は、当の~cookieを［
`非HTTP~API$を介して~accessする対象
］から外すことを~UAに指図する。
`非HTTP~API@
とは、~scriptに~cookieを公開する~web~browser~APIなどの，~UAにより定義される~cookieに~accessするための~APIを指す。
◎
The HttpOnly attribute limits the scope of the cookie to HTTP requests. In particular, the attribute instructs the user agent to omit the cookie when providing access to cookies via "non-HTTP" APIs (such as a web browser API that exposes cookies to scripts).
</p>

<p>
`HttpOnly$a 属性と `Secure$a 属性とは互いに独立であることに注意：
同じ~cookieが `HttpOnly$a, `Secure$a 両`属性$を持てる。
◎
Note that the HttpOnly attribute is independent of the Secure attribute: a cookie can have both the HttpOnly and the Secure attribute.
</p>

				</section>
			</section>
		</section>
		<section id="section-4.2">
<h3 title="Cookie">4.2. `Cookie^h ~header</h3>

			<section id="section-4.2.1">
<h4 title="Syntax">4.2.1. 構文</h4>

<p>
~UAは、格納されている一連の~cookieを `Cookie^h ~headerに入れて，生成元~serverへ送信する。
~serverが `4.1$secの要件に適合する場合（かつ~UAが `5$secの要件に適合する場合）、~UAは次の文法に適合する `Cookie^h ~headerを，送信することになる：
◎
The user agent sends stored cookies to the origin server in the Cookie header. If the server conforms to the requirements in Section 4.1 (and the user agent conforms to the requirements in Section 5), the user agent will send a Cookie header that conforms to the following grammar:
</p>

<pre class="ABNF">
`cookie-header@P
      = "Cookie:" `OWS$P `cookie-string$P `OWS$P
`cookie-string@P
      = `cookie-pair$P *( ";" SP `cookie-pair$P )
</pre>

			</section>
			<section id="section-4.2.2">
<h4 title="Semantics">4.2.2. 意味論</h4>

<p>
それぞれの `cookie-pair$P が~UAに格納されている~cookieを表現する。
`cookie-pair$P は，~UAが `Set-Cookie^h ~header内に受信した `cookie-name$P と `cookie-value$P を含む。
◎
Each cookie-pair represents a cookie stored by the user agent. The cookie-pair contains the cookie-name and cookie-value the user agent received in the Set-Cookie header.
</p>

<p>
~cookieの`属性$は、~UAから~serverへは返されないことに注意。
特に，~serverは、単独の `Cookie^h ~headerからは，~cookieが［
いつ失効するのか？／
どの~hostに対して有効なのか？／
どの~pathに対して有効なのか？／
`Secure$a や `HttpOnly$a 属性を伴って設定されたものかどうか？
］を決定できない。
◎
Notice that the cookie attributes are not returned. In particular, the server cannot determine from the Cookie header alone when a cookie will expire, for which hosts the cookie is valid, for which paths the cookie is valid, or whether the cookie was set with the Secure or HttpOnly attributes.
</p>

<p>
`Cookie^h ~header内の個々の~cookieの意味論については、この文書では定義されない。
これらの~cookieに対する~appに特有の意味論は、~serverごとに指定されることが期待されている。
◎
The semantics of individual cookies in the Cookie header are not defined by this document. Servers are expected to imbue these cookies with application-specific semantics.
</p>

<p>
~cookieは `Cookie^h ~headerにて直列化されるが、~serverは，その直列化の順序に依拠する~SHOULDでない。
特に， `Cookie^h ~header内に同じ名前の 2 個の~cookieが含まれている場合（例えば、異なる `Path$a や `Domain$a 属性を伴って設定されているもの）、~serverは，これらの~cookieが~header内に現れる順序に依拠する~SHOULDでない。
◎
Although cookies are serialized linearly in the Cookie header, servers SHOULD NOT rely upon the serialization order. In particular, if the Cookie header contains two cookies with the same name (e.g., that were set with different Path or Domain attributes), servers SHOULD NOT rely upon the order in which these cookies appear in the header.
</p>


			</section>
		</section>
	</section>
	<section id="section-5">
<h2 title="User Agent Requirements">5. ~UAに課される要件</h2>

<p>
この節では、 `Cookie^h と `Set-Cookie^h ~headerについて、これらの要件を精確に実装する~UAが（~serverが `4$sec にて述べた~well-behaved-profileに適合しなくても），既存の~serverと相互運用できるに足る詳細を指定する。
◎
This section specifies the Cookie and Set-Cookie headers in sufficient detail that a user agent implementing these requirements precisely can interoperate with existing servers (even those that do not conform to the well-behaved profile described in Section 4).
</p>

<p>
~UAは、ここで指定されるものより強い制約を課し得る（例えば，~securityを改善するための）。
しかしながら，その種の厳密さは、既存の~serverとの相互運用性を犠牲にするであろうことが経験的に知られている。
◎
A user agent could enforce more restrictions than those specified herein (e.g., for the sake of improved security); however, experiments have shown that such strictness reduces the likelihood that a user agent will be able to interoperate with existing servers.
</p>

		<section id="section-5.1">
<h3 title="Subcomponent Algorithms">5.1. 下位成分~algo</h3>

<p>
この節では、［
`Cookie^h ／ `Set-Cookie^h
］~headerを成す特定の下位成分を処理するために~UAが利用する，いくつかの~algoを定義する。
【これらの~algoは、後続の節から参照される。】
◎
This section defines some algorithms used by user agents to process specific subcomponents of the Cookie and Set-Cookie headers.
</p>

			<section id="section-5.1.1">
<h4 title="Dates">5.1.1. 日付</h4>

<p class="algo-head">
~UAは，`文字列$ `cookie-date$P を構文解析するときは、次と等価な~algoを利用し~MUST：
◎
The user agent MUST use an algorithm equivalent to the following algorithm to parse a cookie-date.＼
</p>

<ol>
	<li>
( %年t値, %月t値, %日t値, %時t値, %分t値, %秒t値 ) ~LET ( ε, ε, ε, ε, ε, ε )
◎
Note that the various boolean flags defined as a part of the algorithm (i.e., found-time, found-day-of-month, found-month, found-year) are initially "not set".
</li>
	<li>
<p>
%~token~list ~LET ［
下の文法を用いて， `cookie-date$P を一連の `date-token$P に分割した結果
］で与えられる，出現順による~list
◎
Using the grammar below, divide the cookie-date into date-tokens.
</p>


<pre class="ABNF">
`cookie-date@P
      = *`delimiter$P `date-token-list$P *`delimiter$P
`date-token-list@P
      = `date-token$P *( 1*`delimiter$P `date-token$P )
`date-token@P
      = 1*`non-delimiter$P

`delimiter@P
      = `%x09 / %x20-2F / %x3B-40 / %x5B-60 / %x7B-7E^_
`non-delimiter@P
      = `%x00-08 / %x0A-1F / DIGIT / ":" / ALPHA / %x7F-FF^_
`non-digit@P
      = `%x00-2F / %x3A-FF^_

`day-of-month@P
      = 1*2DIGIT [ `non-digit$P *OCTET ]
`month@P
      = ( "jan" / "feb" / "mar" / "apr" /
          "may" / "jun" / "jul" / "aug" /
          "sep" / "oct" / "nov" / "dec" ) *OCTET
`year@P
      = 2*4DIGIT [ `non-digit$P *OCTET ]
`time@P
      = `hms-time$P [ `non-digit$P *OCTET ]
`hms-time@P
      = `time-field$P ":" `time-field$P ":" `time-field$P
`time-field@P
      = 1*2DIGIT
</pre>

<p class="trans-note">【
`day-of-month$P, `year$P, `time$P
の右辺の
<code >[ `non-digit$P *OCTET ]</code>
を括る角括弧（任意選択を表す）は、
<a href="~errata6265=4148" >正誤表</a>（ Verified ）による修正（元々は丸括弧：
<code >( `non-digit$P *OCTET )</code>
）。
】</p>

	</li>
	<li>
~IF［
前~段の構文解析に失敗した
］
⇒
~RET `失敗^i
【この段は、この訳による補完】
</li>
	<li>
<p>
%~token~list 内の ~EACH( `date-token$P %日付~token ) に対し：
◎
Process each date-token sequentially in the order the date-tokens appear in the cookie-date:
</p>

		<ol>
			<li>
~IF［
%時t値 ~EQ ε
］~AND［
%日付~token は生成規則 `time$P に合致する
］
⇒＃
( %時t値, %分t値, %秒t値 ) ~SET 順に %日付~token の中の各~数字~列が表す数；
~CONTINUE
◎
If the found-time flag is not set and the token matches the time production, set the found-time flag and set the hour-value, minute-value, and second-value to the numbers denoted by the digits in the date-token, respectively. Skip the remaining sub-steps and continue to the next date-token.
</li>
			<li>
~IF［
%日t値 ~EQ ε
］~AND［
%日付~token は生成規則 `day-of-month$P に合致する
］
⇒＃
%日t値 ~SET %日付~token が表す数；
~CONTINUE
◎
If the found-day-of-month flag is not set and the date-token matches the day-of-month production, set the found-day-of-month flag and set the day-of-month-value to the number denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.
</li>
			<li>
~IF［
%月t値 ~EQ ε
］~AND［
%日付~token は生成規則 `month$P に合致する
］
⇒＃
%月t値 ~SET %日付~token が表す月t；
~CONTINUE
◎
If the found-month flag is not set and the date-token matches the month production, set the found-month flag and set the month-value to the month denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.
</li>
			<li>
~IF［
%年t値 ~EQ ε
］~AND［
%日付~token は生成規則 `year$P に合致する
］
⇒＃
%年t値 ~SET %日付~token が表す数；
~CONTINUE
◎
If the found-year flag is not set and the date-token matches the year production, set the found-year flag and set the year-value to the number denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.
</li>
		</ol>
	</li>
	<li>
~IF［
ε ~IN { %日t値, %月t値, %年t値, %時t値 }
］
⇒
~RET `失敗^i
◎
↓↓</li>
	<li>
~IF［
%年t値 ~GTE 70
］~AND［
%年t値 ~LTE 99
］
⇒
%年t値 ~INCBY 1900
◎
If the year-value is greater than or equal to 70 and less than or equal to 99, increment the year-value by 1900.
</li>
	<li>
<p>
~IF［
%年t値 ~GTE 0
］~AND［
%年t値 ~LTE 69
］
⇒
%年t値 ~INCBY 2000
◎
If the year-value is greater than or equal to 0 and less than or equal to 69, increment the year-value by 2000.
</p>

<p class="note">注記：
一部の既存の~UAは、 2 桁表記の年tを他と異なるように解釈する。
◎
NOTE: Some existing user agents interpret two-digit years differently.
</p>
	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `失敗^i ：
◎
Abort these steps and fail to parse the cookie-date if:
◎
↑at least one of the found-day-of-month, found-month, found-year, or found-time flags is not set,
</p>
		<ul>
			<li>
［
%日t値 ~LT 1
］~OR［
%日t値 ~GT 31
］
◎
the day-of-month-value is less than 1 or greater than 31,
</li>
			<li>
%年t値 ~LT 1601
◎
the year-value is less than 1601,
</li>
			<li>
%時t値 ~GT 23
◎
the hour-value is greater than 23,
</li>
			<li>
%分t値 ~GT 59
◎
the minute-value is greater than 59, or
</li>
			<li>
%秒t値 ~GT 59
◎
the second-value is greater than 59.
</li>
		</ul>
<p>
（閏秒はこの構文では表現できないことに注意。）
◎
(Note that leap seconds cannot be represented in this syntax.)
</p>
	</li>
	<li>
%~cookie日付 ~SET UTC （協定世界時）［
年t: %年t値,
月t: %月t値,
日t: %日t値,
時t: %時t値,
分t: %分t値,
秒t: %秒t値
］で与えられる日付
◎
Let the parsed-cookie-date be the date whose day-of-month, month, year, hour, minute, and second (in UTC) are the day-of-month-value, the month-value, the year-value, the hour-value, the minute-value, and the second-value, respectively.＼
</li>
	<li>
~IF［
%~cookie日付 で与えられる日付は存在しない
］
⇒
~RET `失敗^i

◎
If no such date exists, abort these steps and fail to parse the cookie-date.
</li>
	<li>
~RET %~cookie日付
◎
Return the parsed-cookie-date as the result of this algorithm.
</li>
</ol>


			</section>
			<section id="section-5.1.2">
<h4 title="Canonicalized Host Names">5.1.2. 正準化された~host名</h4>

<p>
`正準化-済み要請~host@
は、`要請~host$を`正準化-$した結果とする。
【この定義は、この訳による追加 — この仕様では，`要請~host$は常に正準化されるので。】
</p>

<p class="algo-head">
~host名 %~host名 を
`正準化-@
するときは、次の~algoにより生成される`文字列$を返す：
◎
A canonicalized host name is the string generated by the following algorithm:
</p>

<ol>
	<li>
%~label~list ~LET %~host名 を個々の~domain名~labelの並びに変換した結果
◎
Convert the host name to a sequence of individual domain name labels.
</li>
	<li>
<p>
%~label~list 内の
Non-Reserved LDH （ NR-LDH ）~labelでない各~labelを，次のうち適切な方に変換する（ `6.3$sec を見よ）：
</p>

		<ul>
			<li>
A-label （ `5890-2.3.2.1$sec ），または
</li>
			<li>
“~punycode~label” （ `3490-4$sec による， “ToASCII” 変換による結果の~label）
</li>
		</ul>

◎
Convert each label that is not a Non-Reserved LDH (NR-LDH) label, to an A-label (see Section 2.3.2.1 of [RFC5890] for the former and latter), or to a "punycode label" (a label resulting from the "ToASCII" conversion in Section 4 of [RFC3490]), as appropriate (see Section 6.3 of this specification).
</li>
	<li>
~RET %~label~list 内のすべての~labelを，文字 `.^ch で区切って順に連結した結果
◎
Concatenate the resulting labels, separated by a %x2E (".") character.
</li>
</ol>

			</section>
			<section id="section-5.1.3">
<h4 title="Domain Matching">5.1.3. ~domain照合</h4>

<p>
`文字列$ %文字列 は、次のいずれかの条件が満たされるならば，所与の %~domain文字列 に
`~domain合致する@
とされる：
◎
A string domain-matches a given domain string if at least one of the following conditions hold:
</p>

<ul>
	<li>
%~domain文字列 ~EQ %文字列
（この時点では、 %~domain文字列 と %文字列 のいずれも，小文字に正準化されていることに注意。）
◎
The domain string and the string are identical. (Note that both the domain string and the string will have been canonicalized to lower case at this point.)
</li>
	<li>
<p>
次のいずれの条件も満たされる：
◎
All of the following conditions hold:
</p>

		<ul>
			<li>
%~domain文字列 は %文字列 の尾部に一致する。
◎
The domain string is a suffix of the string.
</li>
			<li>
［
%文字列 の中で， %~domain文字列 に含まれない部分
］の最後の文字 ~EQ `.^ch
◎
The last character of the string that is not included in the domain string is a %x2E (".") character.
</li>
			<li>
%文字列 は~host名である（すなわち， IP ~addressではない）。
◎
The string is a host name (i.e., not an IP address).
</li>
		</ul>
	</li>
</ul>

			</section>
			<section id="section-5.1.4">
<h4 title="Paths and Path-Match">5.1.4. ~pathと~path合致-</h4>

<p class="algo-head">
~UAは、~cookieの
`既定の~path@
を算出するときは、次と等価な~algoを利用し~MUST：
◎
The user agent MUST use an algorithm equivalent to the following algorithm to compute the default-path of a cookie:
</p>

<ol>
	<li>
<p>
%~uri~path ~SET `request-uri$P が~path部位を［
含むならば その部位 ／
含まないならば 空
］
</p>

<p class="example">
例えば、 `request-uri$P が ~path部位（および~optionの~query文字列）のみを含むならば，
%~uri~path は `?^ch や~query文字列を除いた）その~pathになり、全部的な絶対~URIであるならば，
%~uri~path はその~URIの~path成分になる。
</p>

◎
Let uri-path be the path portion of the request-uri if such a portion exists (and empty otherwise). For example, if the request-uri contains just a path (and optional query string), then the uri-path is that path (without the %x3F ("?") character or query string), and if the request-uri contains a full absoluteURI, the uri-path is the path component of that URI.
</li>
	<li>
~IF［
次のいずれかが満たされる
］…
⇒＃
%~uri~path ~EQ 空,
%~uri~path の最初の文字 ~NEQ `/^ch,
%~uri~path に含まれる `/^ch は 1 個 以下である
◎終
…ならば
⇒
~RET `/^ch
◎
If the uri-path is empty or if the first character of the uri-path is not a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
◎
If the uri-path contains no more than one %x2F ("/") character, output %x2F ("/") and skip the remaining step.
</li>
	<li>
~RET
%~uri~path の最初の文字から最後の `/^ch の直前までの文字列
◎
Output the characters of the uri-path from the first character up to, but not including, the right-most %x2F ("/").
</li>
</ol>

<p>
`文字列$ %要請~path は、次のいずれかの条件が満たされるとき，所与の`文字列$ %~cookie~path に
`~path合致する@
とされる：
◎
A request-path path-matches a given cookie-path if at least one of the following conditions holds:
</p>


<ul>
	<li>
<p>
%~cookie~path ~EQ %要請~path
◎
The cookie-path and the request-path are identical.
</p>

<p class="trans-note">【
<a href="~errata6265=3663" >正誤表</a>による注釈あり（ Held for Document Update ）：
<ins>
これは RFC 3986 による~path成分の<em >等価性</em>の規則とは，異なることに注意 — 従って、その意味で<em >等価</em>な 2 つの~pathは，異なる~cookieを持つことがあり得る。
</ins>
】
◎
Note that this differs from the rules in RFC 3986 for equivalence of the path
component, and hence two equivalent paths can have different cookies.
</li>
	<li>
［
%~cookie~path は %要請~path の頭部に一致する
］~AND［
%~cookie~path の最後の文字 ~EQ `/^ch
］
◎
The cookie-path is a prefix of the request-path, and the last character of the cookie-path is %x2F ("/").
</li>
	<li>
［
%~cookie~path は %要請~path の頭部に一致する
］~AND［
%要請~path の中で %~cookie~path に含まれない部分の最初の文字 ~EQ `/^ch
］
◎
The cookie-path is a prefix of the request-path, and the first character of the request-path that is not included in the cookie-path is a %x2F ("/") character.
</li>
</ul>

			</section>
		</section>
		<section id="section-5.2">
<h3 title="The Set-Cookie Header">5.2. `Set-Cookie^h ~header</h3>

<p>
~UAは、~HTTP応答にて受信された `Set-Cookie^h ~headerを，まるごと無視して~MAY。
例えば~UAは、 “`第三者主体$” への要請に対する応答による，~cookieの設定に対し、阻止したいと望むかもしれない（ `7.1$secを見よ）。
◎
When a user agent receives a Set-Cookie header field in an HTTP response, the user agent MAY ignore the Set-Cookie header field in its entirety. For example, the user agent might wish to block responses to "third-party" requests from setting cookies (see Section 7.1).
</p>

<p>
~UAは `Set-Cookie^h ~headerをまるごと無視しない場合、
`Set-Cookie^h ~headerの値を `set-cookie-string$P として，以下で定義されるように，構文解析し~MUST。
◎
If the user agent does not ignore the Set-Cookie header field in its entirety, the user agent MUST parse the field-value of the Set-Cookie header field as a set-cookie-string (defined below).
</p>

<p class="note">注記：
以下に与える~algoは、 `4.1$sec の文法よりも~~寛容である。
例えば、~algoでは，~cookieの名前と値から頭部と尾部の空白が剥ぎ取られる（内部の空白は保守される）一方、
`4.1$sec の文法では，そのような空白は禁止されている。
~UAは、 `4$secの推奨に従わない~serverと相互運用するために，この~algoを利用する。
◎
NOTE: The algorithm below is more permissive than the grammar in Section 4.1. For example, the algorithm strips leading and trailing whitespace from the cookie name and value (but maintains internal whitespace), whereas the grammar in Section 4.1 forbids whitespace in these positions. User agents use this algorithm so as to interoperate with servers that do not follow the recommendations in Section 4.
</p>

<p class="algo-head">
~UAは `set-cookie-string$P を構文解析するときは、次と等価な~algoを利用し~MUST：
◎
A user agent MUST use an algorithm equivalent to the following algorithm to parse a "set-cookie-string":
</p>

<ol>
	<li>
( %名~値~組, %属性~list文字列 ) ~SET `set-cookie-string$P を文字 `;^ch で`分割-$した結果
◎
If the set-cookie-string contains a %x3B (";") character:
• The name-value-pair string consists of the characters up to, but not including, the first %x3B (";"), and the unparsed-attributes consist of the remainder of the set-cookie-string (including the %x3B (";") in question).
◎
Otherwise:
• The name-value-pair string consists of all the characters contained in the set-cookie-string, and the unparsed-attributes is the empty string.
</li>
	<li>
~IF［
%名~値~組 に文字 `=^ch は含まれていない
］
⇒
~RET
— この `set-cookie-string$P はまるごと無視する
◎
If the name-value-pair string lacks a %x3D ("=") character, ignore the set-cookie-string entirely.
</li>
	<li>
( %~cookie名, %~cookie値 ) ~SET %名~値~組 を文字 `=^ch で`分割-$した結果
◎
The (possibly empty) name string consists of the characters up to, but not including, the first %x3D ("=") character, and the (possibly empty) value string consists of the characters after the first %x3D ("=") character.
</li>
	<li>
%~cookie名, %~cookie値 
それぞれに対し，その頭部と尾部の `WSP^P 文字~並びを除去する
◎
Remove any leading or trailing WSP characters from the name string and the value string.
</li>
	<li>
~IF［
%~cookie名 ~EQ 空
］
⇒
~RET
— この `set-cookie-string$P はまるごと無視する
◎
If the name string is empty, ignore the set-cookie-string entirely.
◎
The cookie-name is the name string, and the cookie-value is the value string.
</li>
<!-- 
	<li>
%~cookie名 が名前~文字列,
%~cookie値 が値~文字列を与える。
</li>
 -->
	<li>
%~cookie属性~list ~LET 空~list
— ( 名前, 値 ) の組で表現される`属性$からなる~list
◎
The user agent MUST use an algorithm equivalent to the following algorithm to parse the unparsed-attributes:
</li>
	<li>
<p>
~WHILE［
%属性~list文字列 ~NEQ 空
］：
◎
If the unparsed-attributes string is empty, skip the rest of these steps.
</p>
		<ol>
			<li>
( %~cookie属性~文字列, %属性~list文字列 ) ~SET %属性~list文字列 を文字 `;^ch で`分割-$した結果
◎
Discard the first character of the unparsed-attributes (which will be a %x3B (";") character).
◎
If the remaining unparsed-attributes contains a %x3B (";") character:
• Consume the characters of the unparsed-attributes up to, but not including, the first %x3B (";") character.
◎
Otherwise:
• Consume the remainder of the unparsed-attributes.
◎
Let the cookie-av string be the characters consumed in this step.
</li>
			<li>
( %属性~名, %属性~値 ) ~SET %~cookie属性~文字列 を文字 `=^ch で`分割-$した結果
◎
If the cookie-av string contains a %x3D ("=") character:
• The (possibly empty) attribute-name string consists of the characters up to, but not including, the first %x3D ("=") character, and the (possibly empty) attribute-value string consists of the characters after the first %x3D ("=") character.
◎
Otherwise:
• The attribute-name string consists of the entire cookie-av string, and the attribute-value string is empty.
</li>
			<li>
%属性~名, %属性~値
それぞれに対し，その頭部と尾部の `WSP^P 文字~並びを除去する
◎
Remove any leading or trailing WSP characters from the attribute-name string and the attribute-value string.
</li>
			<li>
<p>
この節の後続の各 下位~節の要件に従って，
%属性~名, %属性~値
を処理する（ %属性~名 が下位~節のどの~algoからも認識されない属性は無視する）
</p>
【その結果， %~cookie属性~list に属性が追加されることになる】
◎
Process the attribute-name and attribute-value according to the requirements in the following subsections. (Notice that attributes with unrecognized attribute-names are ignored.)
◎
Return to Step 1 of this algorithm.
</li>
		</ol>
	</li>
	<li>
この段に達した時点で、~UAは，
`request-uri$P から
( 名前: %~cookie名, 値: %~cookie値, 属性~list: %~cookie属性~list )
を伴う
`~cookieを受信した@
とされる
（~cookieの受信により誘発される追加の要件については、`5.3$secにて述べる。）
◎
When the user agent finishes parsing the set-cookie-string, the user agent is said to "receive a cookie" from the request-uri with name cookie-name, value cookie-value, and attributes cookie-attribute-list. (See Section 5.3 for additional requirements triggered by receiving a cookie.)
</li>
</ol>


<p class="algo-head">
上の~algoにおいて、`文字列$ %S を文字 %c で
`分割-@
するときは、次で与えられる 2 個の`文字列$の（順序付けられた）組を返すとする：
</p>

<ol>
	<li>
%S の先頭から連続する， %c でない文字からなる，最長の`文字列$（ %S が空，または %S の先頭が %c であれば，空）
</li>
	<li>
前段の残りの部分の`文字列$から，（もしあれば）先頭の %c は除外した`文字列$（残りの部分が空, または %c 1 個のみであれば，空）
</li>
</ol>

<p class="trans-note">【
この定義は、記述を簡潔かつ簡明にするために，この訳に導入している。
】</p>


			<section id="section-5.2.1">
<h4 title="The Expires Attribute">5.2.1. `Expires^a 属性</h4>

<p class="algo-head">
~UAは、［
%属性~名 が`文字列$ `Expires^l に`文字大小無視で合致する$
］`属性$を，次に従って処理し~MUST：
◎
If the attribute-name case-insensitively matches the string "Expires", the user agent MUST process the cookie-av as follows.
</p>

<ol>
	<li>
%失効日時 ~LET 
`5.1.1$secに従って，
%属性~値 を `cookie-date$P として構文解析した結果
◎
Let the expiry-time be the result of parsing the attribute-value as cookie-date (see Section 5.1.1).
</li>
	<li>
~IF［
%失効日時 ~EQ `失敗^i
］
⇒
~RET
— この`属性$は無視する
◎
If the attribute-value failed to parse as a cookie date, ignore the cookie-av.
</li>
	<li>
~IF［
%失効日時 は ~UAが表現-可能な最も未来の日付より後
］
⇒
~UAは次をしても~MAY
⇒
%失効日時 ~SET ~UAが表現-可能な最も未来の日付
◎
If the expiry-time is later than the last date the user agent can represent, the user agent MAY replace the expiry-time with the last representable date.
</li>
	<li>
~IF［
%失効日時 は ~UAが表現-可能な最も過去の日付より前
］
⇒
~UAは次をしても~MAY
⇒
%失効日時 ~SET ~UAが表現-可能な最も過去の日付
◎
If the expiry-time is earlier than the earliest date the user agent can represent, the user agent MAY replace the expiry-time with the earliest representable date.
</li>
	<li>
%~cookie属性~list に
( 名前: `Expires$a, 値: %失効日時 )
の属性を付加する
◎
Append an attribute to the cookie-attribute-list with an attribute-name of Expires and an attribute-value of expiry-time.
</li>
</ol>

			</section>
			<section id="section-5.2.2">
<h4 title="The Max-Age Attribute">5.2.2. `Max-Age^a 属性</h4>

<p class="algo-head">
~UAは、［
%属性~名 が`文字列$ `Max-Age^l に`文字大小無視で合致する$
］`属性$を，次に従って処理し~MUST：
◎
If the attribute-name case-insensitively matches the string "Max-Age", the user agent MUST process the cookie-av as follows.
</p>

<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
%属性~値 の最初の文字は `DIGIT^P でも文字 `-^ch でもない
</li>
			<li>
%属性~値 の最初の文字~以外の文字に `DIGIT^P でない文字がある
</li>
		</ul>

<p>
…ならば
⇒
~RET
— この`属性$は無視する
</p>

【 文字 `-^ch のみからなる場合も受容されることになる（本当か？）。】
◎
If the first character of the attribute-value is not a DIGIT or a "-" character, ignore the cookie-av.
◎
If the remainder of attribute-value contains a non-DIGIT character, ignore the cookie-av.
</li>
	<li>
%秒差 ~SET %属性~値 を整数に変換した結果
◎
Let delta-seconds be the attribute-value converted to an integer.
</li>
	<li>
%失効日時 ~LET ［
%秒差 ~LTE 0 ならば ~UAが表現-可能な最も過去の日付 ／
~ELSE_ 現在の日時から %秒差 秒~後の日時
］
◎
If delta-seconds is less than or equal to zero (0), let expiry-time be the earliest representable date and time. Otherwise, let the expiry-time be the current date and time plus delta-seconds seconds.
</li>
	<li>
%~cookie属性~list に
( 名前: `Max-Age$a, 値: %失効日時 )
の属性を付加する
◎
Append an attribute to the cookie-attribute-list with an attribute-name of Max-Age and an attribute-value of expiry-time.
</li>
</ol>

			</section>
			<section id="section-5.2.3">
<h4 title="The Domain Attribute">5.2.3. `Domain^a 属性</h4>

<p class="algo-head">
~UAは、［
%属性~名 が`文字列$ `Domain^l に`文字大小無視で合致する$
］`属性$を，次に従って処理し~MUST：
◎
If the attribute-name case-insensitively matches the string "Domain", the user agent MUST process the cookie-av as follows.
</p>

<p>
［
%属性~値 ~EQ 空
］の場合の挙動は定義されない。
しかしながら、~UAは`属性$をまるごと無視する~SHOULDである。
◎
If the attribute-value is empty, the behavior is undefined. However, the user agent SHOULD ignore the cookie-av entirely.
</p>


<ol>
	<li >
%~cookie~domain ~LET ［
%属性~値 の最初の文字 ~EQ `.^ch ならば %属性~値 から最初の文字を除いた値 ／
~ELSE_ %属性~値
］
◎
If the first character of the attribute-value string is %x2E ("."):
• Let cookie-domain be the attribute-value without the leading %x2E (".") character.
◎
Otherwise:
• Let cookie-domain be the entire attribute-value.
</li>
	<li>
%~cookie~domain ~SET %~cookie~domain を小文字~化した結果
◎
Convert the cookie-domain to lower case.
</li>
	<li>
%~cookie属性~list に
( 名前: `Domain$a, 値: %~cookie~domain )
の属性を付加する
◎
Append an attribute to the cookie-attribute-list with an attribute-name of Domain and an attribute-value of cookie-domain.
</li>
</ol>


			</section>
			<section id="section-5.2.4">
<h4 title="The Path Attribute">5.2.4. `Path^a 属性</h4>

<p class="algo-head">
~UAは、［
%属性~名 が`文字列$ `Path^l に`文字大小無視で合致する$
］`属性$を，次に従って処理し~MUST：
◎
If the attribute-name case-insensitively matches the string "Path", the user agent MUST process the cookie-av as follows.
</p>

<ol>
	<li>
%~cookie~path ~LET %属性~値
◎
↓</li>
	<li>
~IF［
%~cookie~path ~EQ 空
］~OR［
%~cookie~path の最初の文字 ~NEQ `/^ch
］
⇒
%~cookie~path ~SET `既定の~path$
◎
If the attribute-value is empty or if the first character of the attribute-value is not %x2F ("/"):
• Let cookie-path be the default-path.
◎
Otherwise:
• Let cookie-path be the attribute-value.
</li>
	<li>
%~cookie属性~list に
( 名前: `Path$a, 値: %~cookie~path )
の属性を付加する
◎
Append an attribute to the cookie-attribute-list with an attribute-name of Path and an attribute-value of cookie-path.
</li>
</ol>


			</section>
			<section id="section-5.2.5">
<h4 title="The Secure Attribute">5.2.5. `Secure^a 属性</h4>

<p>
~UAは、［
%属性~名 が`文字列$ `Secure^l に`文字大小無視で合致する$
］`属性$に対しては，
%~cookie属性~list に
( 名前: `Secure$a, 値: 空 )
の属性を付加し~MUST。
◎
If the attribute-name case-insensitively matches the string "Secure", the user agent MUST append an attribute to the cookie-attribute-list with an attribute-name of Secure and an empty attribute-value.
</p>

			</section>
			<section id="section-5.2.6">
<h4 title="The HttpOnly Attribute">5.2.6. `HttpOnly^a 属性</h4>

<p>
~UAは、［
%属性~名 が`文字列$ `HttpOnly^l に`文字大小無視で合致する$
］`属性$に対しては，
%~cookie属性~list に
( 名前: `HttpOnly$a, 値: 空 )
の属性を付加し~MUST。
◎
If the attribute-name case-insensitively matches the string "HttpOnly", the user agent MUST append an attribute to the cookie-attribute-list with an attribute-name of HttpOnly and an empty attribute-value.
</p>

			</section>
		</section>
		<section id="section-5.3">
<h3 title="Storage Model">5.3. 保管~model</h3>

<p>
~UAは、各~cookieに対し，次の~fieldを格納する
⇒＃
`name@f,
`value@f,
`expiry-time@f,
`domain@f,
`path@f,
`creation-time@f,
`last-access-time@f,
`persistent-flag@f,
`host-only-flag@f,
`secure-only-flag@f,
`http-only-flag@f
◎
The user agent stores the following fields about each cookie: name, value, expiry-time, domain, path, creation-time, last-access-time, persistent-flag, host-only-flag, secure-only-flag, and http-only-flag.
</p>

<p class="algo-head">
~UAは、 `request-uri$P から
( 名前: %~cookie名, 値: %~cookie値, 属性~list: %~cookie属性~list )
を伴う`~cookieを受信した$ときは、その~cookieを，次に従って処理し~MUST：
◎
When the user agent "receives a cookie" from a request-uri with name cookie-name, value cookie-value, and attributes cookie-attribute-list, the user agent MUST process the cookie as follows:
</p>

<ol>
	<li>
~UAは次をしても~MAY
⇒
~RET
— ~UAは、受信した~cookieをまるごと無視して~MAY。
例えば~UAは、 “`第三者主体$” による応答で受信される~cookieを阻止したいと望んだり，一定~sizeを超える~cookieを格納したいと望まないかもしれない。
◎
A user agent MAY ignore a received cookie in its entirety. For example, the user agent might wish to block receiving cookies from "third-party" responses or the user agent might not wish to store cookies that exceed some size.
</li>
	<li>
%新~cookie ~LET 新たな~cookie
— その各種~fieldは、以下に従って設定される
◎
Create a new cookie＼
</li>
	<li>
%新~cookie の
⇒＃
`name$f ~SET %~cookie名,
`value$f ~SET %~cookie値,
`creation-time$f ~SET 現在の日時,
`last-access-time$f ~SET 現在の日時,
◎
with name cookie-name, value cookie-value. Set the creation-time and the last-access-time to the current date and time.
</li>
	<li>
~IF［
%~cookie属性~list 内に［
名前 ~EQ `Max-Age^l
］の属性はある
］
⇒＃
%新~cookie の `persistent-flag$f ~SET ~T；
%新~cookie の `expiry-time$f ~SET ［ 該当する属性のうち %~cookie属性~list 内で最後のもの ］の値
◎
If the cookie-attribute-list contains an attribute with an attribute-name of "Max-Age":
• Set the cookie's persistent-flag to true.
• Set the cookie's expiry-time to attribute-value of the last attribute in the cookie-attribute-list with an attribute-name of "Max-Age".
</li>
	<li>
~ELIF［
%~cookie属性~list 内に［
名前 ~EQ `Expires^l
］の属性はある
］
⇒＃
%新~cookie の `persistent-flag$f ~SET ~T；
%新~cookie の `expiry-time$f ~SET ［ 該当する属性のうち %~cookie属性~list 内で最後のもの ］の値
◎
Otherwise, if the cookie-attribute-list contains an attribute with an attribute-name of "Expires" (and does not contain an attribute with an attribute-name of "Max-Age"):
• Set the cookie's persistent-flag to true.
• Set the cookie's expiry-time to attribute-value of the last attribute in the cookie-attribute-list with an attribute-name of "Expires".
</li>
	<li>
~ELSE
⇒＃
%新~cookie の `persistent-flag$f ~SET ~F；
%新~cookie の `expiry-time$f ~SET ~UAが表現-可能な最も未来の日付
◎
Otherwise:
• Set the cookie's persistent-flag to false.
• Set the cookie's expiry-time to the latest representable date.
</li>
	<li>
%~domain属性 ~LET 空
◎
↓</li>
	<li>
~IF［
%~cookie属性~list 内に［
名前 ~EQ `Domain^l
］の属性はある
］
⇒
%~domain属性 ~SET ［ 該当する属性のうち %~cookie属性~list 内で最後のもの ］の値
◎
If the cookie-attribute-list contains an attribute with an attribute-name of "Domain":
• Let the domain-attribute be the attribute-value of the last attribute in the cookie-attribute-list with an attribute-name of "Domain".
◎
Otherwise:
• Let the domain-attribute be the empty string.
</li>
	<li>
<p>
~IF［
~UAは`~public~suffix$を却下するように環境設定されている
］~AND［
%~domain属性 は`~public~suffix$である
］：
◎
If the user agent is configured to reject "public suffixes" and the domain-attribute is a public suffix:
</p>

				<ol>
					<li>
~IF［
%~domain属性 ~EQ `正準化-済み要請~host$
］
⇒
%~domain属性 ~SET 空
◎
If the domain-attribute is identical to the canonicalized request-host:
• Let the domain-attribute be the empty string.
</li>
					<li>
~ELSE
⇒
~RET
— この~cookieはまるごと無視する
◎
Otherwise:
• Ignore the cookie entirely and abort these steps.
</li>
				</ol>

<p class="note">注記：
"`com^s",
"`co.uk^s",
"`pvt.k12.wy.us^s"
などの，
`~public~suffix@
は、~public~registryにて制御されている~domainである。
この段は、 `attacker.com^s （攻撃者）が値 "`com^s" の `Domain$a 属性を伴う~cookieを設定することにより，
"`example.com^s"
の完全性を侵害することを防ぐのに本質的である。
あいにく、`~public~suffix$の集合（ “`registry controlled domains^en” （~registryにより制御されている~domain）としても知られている）は、年々変化している。
引き合うのであれば、~UAは Mozilla project ：
<a href="http://publicsuffix.org/">http://publicsuffix.org/</a>
にて保守されているもののような，日々更新される`~public~suffix$の~listを利用する~SHOULDである。
【 “年々”, “日々”：雰囲気訳。実際の変化頻度を確かめたわけではない。例えば毎分, 毎秒レベルの頻度（になる）かもしれない。】
◎
NOTE: A "public suffix" is a domain that is controlled by a public registry, such as "com", "co.uk", and "pvt.k12.wy.us". This step is essential for preventing attacker.com from disrupting the integrity of example.com by setting a cookie with a Domain attribute of "com". Unfortunately, the set of public suffixes (also known as "registry controlled domains") changes over time. If feasible, user agents SHOULD use an up-to-date public suffix list, such as the one maintained by the Mozilla project at &lt;http://publicsuffix.org/&gt;.
</li>
	<li>
<p>
~IF［
%~domain属性 ~NEQ 空
］：
◎
If the domain-attribute is non-empty:
</p>
		<ol>
			<li>
~IF［
`正準化-済み要請~host$は %~domain属性 に`~domain合致-$しない
］
⇒
~RET
— この~cookieはまるごと無視する
◎
If the canonicalized request-host does not domain-match the domain-attribute:
• Ignore the cookie entirely and abort these steps.
</li>
			<li>
%新~cookie の `host-only-flag$f ~SET ~F
◎
Otherwise:
• Set the cookie's host-only-flag to false.
</li>
			<li>
%新~cookie の `domain$f ~SET %~domain属性
◎
• Set the cookie's domain to the domain-attribute.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
⇒＃
%新~cookie の `host-only-flag$f ~SET ~T；
%新~cookie の `domain$f ~SET `正準化-済み要請~host$
◎
Otherwise:
• Set the cookie's host-only-flag to true.
• Set the cookie's domain to the canonicalized request-host.
</li>
	<li>
~IF［
%~cookie属性~list 内に［
名前 ~EQ `Path^l
］の属性はある
］
⇒
%新~cookie の `path$f ~SET ［ 該当する属性のうち %~cookie属性~list 内で最後のもの ］の値
◎
If the cookie-attribute-list contains an attribute with an attribute-name of "Path", set the cookie's path to attribute-value of the last attribute in the cookie-attribute-list with an attribute-name of "Path".＼
</li>
	<li>
~ELSE
⇒
%新~cookie の `path$f ~SET `request-uri$P の`既定の~path$
◎
Otherwise, set the cookie's path to the default-path of the request-uri.
</li>
	<li>
%新~cookie の `secure-only-flag$f ~SET %~cookie属性~list 内に［
名前 ~EQ `Secure^l
］の属性は［
あるならば ~T ／
ないならば ~F
］
◎
If the cookie-attribute-list contains an attribute with an attribute-name of "Secure", set the cookie's secure-only-flag to true. Otherwise, set the cookie's secure-only-flag to false.
</li>
	<li>
%新~cookie の `http-only-flag$f ~SET %~cookie属性~list 内に［
名前 ~EQ `HttpOnly^l
］の属性は［
あるならば ~T ／
ないならば ~F
］
◎
If the cookie-attribute-list contains an attribute with an attribute-name of "HttpOnly", set the cookie's http-only-flag to true. Otherwise, set the cookie's http-only-flag to false.
</li>
	<li>
~IF［
~cookieは`非HTTP~API$から受信されている
］~AND［
%新~cookie の `http-only-flag$f ~EQ ~T
］
⇒
~RET
— この~cookieはまるごと無視する
◎
If the cookie was received from a "non-HTTP" API and the cookie's http-only-flag is set, abort these steps and ignore the cookie entirely.
</li>
	<li>
<p>
~IF［
%新~cookie と［
`name$f, `domain$f, `path$f
］がいずれも同じ~cookieが~cookie保管庫~内にある
］：
◎
If the cookie store contains a cookie with the same name, domain, and path as the newly created cookie:
</p>
		<ol>
			<li>
%旧~cookie ~SET その既存の~cookie
（この~algoは、そのような~cookieは高々 1 個に限られる，という不変則を、常に保守することに注意。）
◎
Let old-cookie be the existing cookie with the same name, domain, and path as the newly created cookie. (Notice that this algorithm maintains the invariant that there is at most one such cookie.)
</li>
			<li>
~IF［
~cookieは`非HTTP~API$から受信されている
］~AND［
%旧~cookie の `http-only-flag$f ~EQ ~T
］
⇒
~RET
— この~cookieはまるごと無視する
◎
If the newly created cookie was received from a "non-HTTP" API and the old-cookie's http-only-flag is set, abort these steps and ignore the newly created cookie entirely.
</li>
			<li>
%新~cookie の `creation-time$f ~SET %旧~cookie の `creation-time$f
◎
Update the creation-time of the newly created cookie to match the creation-time of the old-cookie.
</li>
			<li>
~cookie保管庫から %旧~cookie を除去する
◎
Remove the old-cookie from the cookie store.
</li>
		</ol>
	</li>
	<li>
~cookie保管庫に %新~cookie を挿入する
◎
Insert the newly created cookie into the cookie store.
</li>
</ol>



<p>
~cookieの有効期限が過去である／そうなったとき、その~cookieは
`失効した@
（ `expired^en ）とされる。
◎
A cookie is "expired" if the cookie has an expiry date in the past.
</p>

<p>
どの時点であれ，~UAは、~cookie保管庫~内の~cookieのうち`失効した$ものすべてを保管庫から抹消し~MUST。
◎
The user agent MUST evict all expired cookies from the cookie store if, at any time, an expired cookie exists in the cookie store.
</p>

<p>
~UAは、 `domain$f ~fieldを共有する~cookieの総数が，実装により定義される何らかの上限（例えば 50 ~cookie）を超えたときは，いつでも、~cookie保管庫から “超過~cookieを除去して” ~MAY
◎
At any time, the user agent MAY "remove excess cookies" from the cookie store if the number of cookies sharing a domain field exceeds some implementation-defined upper bound (such as 50 cookies).
</p>

<p>
~UAは、~cookie保管庫の容量が，実装により定義される何らかの上限（例えば 3000 ~cookie）を超えたときは，いつでも、~cookie保管庫から “超過~cookieを除去して” ~MAY
◎
At any time, the user agent MAY "remove excess cookies" from the cookie store if the cookie store exceeds some predetermined upper bound (such as 3000 cookies).
</p>

<p>
~UAが，~cookie保管庫から超過~cookieを除去するときは、次の優先順位により，~cookieを抹消し~MUST：
◎
When the user agent removes excess cookies from the cookie store, the user agent MUST evict cookies in the following priority order:
</p>


<ol>

	<li>
`失効した$~cookie
◎
Expired cookies.
</li>
	<li>
同じ `domain$f ~fieldを共有する~cookieのうち、決められた~cookie数を超えた分
◎
Cookies that share a domain field with more than a predetermined number of other cookies.
</li>
	<li>
`last-access-time$f が最も過去の~cookie
◎
↓</li>
	<li>
すべての~cookie
◎
All cookies.
◎
If two cookies have the same removal priority, the user agent MUST evict the cookie with the earliest last-access date first.
</li>
</ol>


<p>
~UAは、現在の~sessionが終了したときは（ “~sessionの終了” は~UAにより定義される）、~cookie保管庫から［
`persistent-flag$f ~EQ ~F
］なる，すべての~cookieを除去し~MUST。
◎
When "the current session is over" (as defined by the user agent), the user agent MUST remove from the cookie store all cookies with the persistent-flag set to false.
</p>

		</section>
		<section id="section-5.4">
<h3 title="The Cookie Header">5.4. `Cookie^h ~header</h3>

<p>
~UAは格納されている~cookieを `Cookie^h ~HTTP要請~headerに内包させる。
◎
The user agent includes stored cookies in the Cookie HTTP request header.
</p>

<p>
~UAは~HTTP要請を生成する際に、複数の `Cookie^h ~headerを添付しては~MUST_NOT。
◎
When the user agent generates an HTTP request, the user agent MUST NOT attach more than one Cookie header field.
</p>

<p>
~UAは `Cookie^h ~headerをまるごと省略して~MAY。
例えば、~UAは “`第三者主体$” 要請の間，~cookieの送信を~cookieの設定から阻止したいと望むかもしれない（ `7.1$sec を見よ）。
<!--  -->
◎
A user agent MAY omit the Cookie header in its entirety. For example, the user agent might wish to block sending cookies during "third-party" requests from setting cookies (see Section 7.1).
</p>

<p>
~UAは~HTTP要請に `Cookie^h ~headerを添付するときは、その~header値として（下に定義する）`~cookie文字列$を送信し~MUST。
◎
If the user agent does attach a Cookie header field to an HTTP request, the user agent MUST send the cookie-string (defined below) as the value of the header field.
</p>

<p class="algo-head">
~UAは
( ~cookie保管庫と `request-uri$P )
から
`~cookie文字列@
を算出するときは、次と等価な~algoを利用し~MUST：
◎
The user agent MUST use an algorithm equivalent to the following algorithm to compute the "cookie-string" from a cookie store and a request-uri:
</p>

<ol>
	<li>
<p>
%~cookie~list ~LET
~cookie保管庫の中で，次に挙げる要件すべてを満たす~cookieの集合：
◎
Let cookie-list be the set of cookies from the cookie store that meets all of the following requirements:
</p>
		<ul>
			<li>
<p>
次のいずれかが満たされる：
</p>
				<ul>
					<li>
［
~cookieの `host-only-flag$f ~EQ ~T
］~AND［
`正準化-済み要請~host$ ~EQ ~cookieの `domain$f
］
</li>
					<li>
［
~cookieの `host-only-flag$f ~EQ ~F
］~AND［
`正準化-済み要請~host$は~cookieの `domain$f に`~domain合致する$
］
</li>
				</ul>
◎
Either: The cookie's host-only-flag is true and the canonicalized request-host is identical to the cookie's domain.
Or:
The cookie's host-only-flag is false and the canonicalized request-host domain-matches the cookie's domain.
</li>
			<li>
`request-uri$P の~pathは~cookieの `path$f に`~path合致する$
◎
The request-uri's path path-matches the cookie's path.
</li>
			<li>
<p>
次のいずれかが満たされる：
</p>
				<ul>
					<li>
~cookieの `secure-only-flag$f ~EQ ~F
</li>
					<li>
<p>
`request-uri$P の~schemeは（~UAにより定義される）“~secure” ~protocolを示すものである
</p>

<p class="note">注記：
何をもって “~secure” ~protocolとするかは、この文書では定義されない。
概して、~UAは，~protocolが~SSLや~TLSなどの~transport層の~securityを用立てるものであれば、それを~secureであるものと見なす。
例えば、ほとんどの~UAは "https" を~secure~protocolを示す~schemeと見なす。
</p>
					</li>
				</ul>

◎
If the cookie's secure-only-flag is true, then the request-uri's scheme must denote a "secure" protocol (as defined by the user agent).
◎
NOTE: The notion of a "secure" protocol is not defined by this document. Typically, user agents consider a protocol secure if the protocol makes use of transport-layer security, such as SSL or TLS. For example, most user agents consider "https" to be a scheme that denotes a secure protocol.
</li>
			<li>
<p>
次のいずれかが満たされる：
</p>
				<ul>
					<li>
~cookieの `http-only-flag$f ~EQ ~F
</li>
					<li>
~cookie文字列は`非HTTP~API$により生成された~cookieではない
</li>
				</ul>

◎
If the cookie's http-only-flag is true, then exclude the cookie if the cookie-string is being generated for a "non-HTTP" API (as defined by the user agent).
</li>
		</ul>
	</li>
	<li>
<p>
%~cookie~list は、次を満たす順序に整列される~SHOULDである：
◎
The user agent SHOULD sort the cookie-list in the following order:
</p>
		<ul>
			<li>
`path$f が長い~cookieほど，前に現れる
◎
Cookies with longer paths are listed before cookies with shorter paths.
</li>
			<li>
`path$f の長さが互いに等しい~cookieに対しては、
`creation-time$f がより過去のものほど，前に現れる
◎
Among cookies that have equal-length path fields, cookies with earlier creation-times are listed before cookies with later creation-times.
</li>
		</ul>

<p class="note">注記：
すべての~UAが %~cookie~list をこの順序に整列するわけではないが、この順序は，この文書が書かれた時点での慣行を反映するものである。
歴史的には、（誤って）この順序に依存する~serverが存在してきた。
◎
NOTE: Not all user agents sort the cookie-list in this order, but this order reflects common practice when this document was written, and, historically, there have been servers that (erroneously) depended on this order.
</p>

	</li>
	<li>
%~cookie~list 内の ~EACH( %~cookie ) に対し
⇒
%~cookie の `last-access-time$f ~SET 現在の日時
◎
Update the last-access-time of each cookie in the cookie-list to the current date and time.
</li>
	<li>
%~cookie文字列 ~LET 空
◎
↓</li>
	<li>
<p>
%~cookie~list 内の ~EACH( %~cookie ) に対し：
◎
Serialize the cookie-list into a cookie-string by processing each cookie in the cookie-list in order:
</p>
		<ol>
			<li>
%~cookie文字列 に次を順に付加する
⇒＃
~cookieの `name$f,
`=^ch,
~cookieの `value$f
◎
Output the cookie's name, the %x3D ("=") character, and the cookie's value.
</li>
			<li>
~IF［
%~cookie は %~cookie~list 内の最後の~cookieでない
］
⇒
%~cookie文字列 に次を順に付加する
⇒＃
`;^ch,
` ^ch
◎
If there is an unprocessed cookie in the cookie-list, output the characters %x3B and %x20 ("; ").
</li>
		</ol>
	</li>
	<li>
~RET %~cookie文字列
◎
↑</li>
</ol>


<p class="note">注記：
その名称に反し，`~cookie文字列$は、実際には，~octet並びである
— （普通の）文字~並びではなく。
~UAは、 `~cookie文字列$（またはその成分）を（例えば，利用者~向けの呈示~用に）文字~並びに変換する際に，`RFC3629$r を利用して ~octet並びを復号したいと望むかもしれない。
しかしながら，すべての~octet並びが妥当な UTF-8 になるとは限らないので、この復号-は失敗することもある。
◎
NOTE: Despite its name, the cookie-string is actually a sequence of octets, not a sequence of characters. To convert the cookie-string (or components thereof) into a sequence of characters (e.g., for presentation to the user), the user agent might wish to try using the UTF-8 character encoding [RFC3629] to decode the octet sequence. This decoding might fail, however, because not every sequence of octets is valid UTF-8.
</p>


		</section>
	</section>
	<section id="section-6">
<h2 title="Implementation Considerations">6. 実装-時の考慮点</h2>

		<section id="section-6.1">
<h3 title="Limits">6.1. 制限</h3>

<p>
実用的な~UA実装には，格納-可能な~cookieの総数と~sizeに制限がある。
一般用の~UAは、少なくとも次に示す容量は供する~SHOULDである：
◎
Practical user agent implementations have limits on the number and size of cookies that they can store. General-use user agents SHOULD provide each of the following minimum capabilities:
</p>

<ul>
	<li>
1 ~cookieあたり，少なくとも 4096 ~byte（~cookieの［
名前, 値, 属性たち
］の長さの総和で）
◎
At least 4096 bytes per cookie (as measured by the sum of the length of the cookie's name, value, and attributes).
</li>
	<li>
1 ~domainあたり，少なくとも 50 個の~cookie
◎
At least 50 cookies per domain.
</li>
	<li>
全部で少なくとも 3000 個の~cookie
◎
At least 3000 cookies total.
</li>
</ul>

<p>
~serverは、なるべく，実装によるこれらの制限に達しないように, かつ
それぞれの要請に `Cookie^h ~headerが内包されることによる，~network帯域幅を最小限に抑えるために、できるだけ，少数かつ小容量の~cookieを利用する~SHOULDである。
◎
Servers SHOULD use as few and as small cookies as possible to avoid reaching these implementation limits and to minimize network bandwidth due to the Cookie header being included in every request.
</p>

<p>
~UAは利用者からの~~指示により~cookieを抹消し得るので、~serverは、
~UAが `Cookie^h ~header内に 1 個以上の~cookieを返すことに失敗したときには，
“上品に退行する（ `gracefull degrade^en ）”~SHOULDである。
◎
Servers SHOULD gracefully degrade if the user agent fails to return one or more cookies in the Cookie header because the user agent might evict any cookie at any time on orders from the user.
</p>

		</section>
		<section id="section-6.2">
<h3 title="Application Programming Interfaces">6.2. ~API</h3>

<p>
`Cookie^h と `Set-Cookie^h ~headerが，このような込み入った構文を利用する理由の一つは、多くの~platform（~serverと~UAのいずれも）が、~cookieに対する文字列に基づく~API（ `application programming interface^en ）を供し，~app層の~programmerたちに［
`Cookie^h と `Set-Cookie^h
~headerに利用される構文を生成して構文解析する
］ことを要求するからである。
その結果、多くの~programmerから正しく実装されず，相互運用性の問題が生じている。
◎
One reason the Cookie and Set-Cookie headers use such esoteric syntax is that many platforms (both in servers and user agents) provide a string-based application programming interface (API) to cookies, requiring application-layer programmers to generate and parse the syntax used by the Cookie and Set-Cookie headers, which many programmers have done incorrectly, resulting in interoperability problems.
</p>

<p>
~platformが、~cookieに対する文字列に基づく~APIを供する代わりに，より意味論的な~APIを供するなら、より使い易いものになるであろう。
特定の~API設計を推奨することは，この文書の視野を超えるが、直列化された日付~文字列に代えて，抽象 “Date” ~objを受容することには、明らかな便益がある。
◎
Instead of providing string-based APIs to cookies, platforms would be well-served by providing more semantic APIs. It is beyond the scope of this document to recommend specific API designs, but there are clear benefits to accepting an abstract "Date" object instead of a serialized date string.
</p>

		</section>
		<section id="section-6.3">
<h3 title="IDNA Dependency and Migration">6.3. IDNA への依存関係と移行</h3>

<p>
IDNA2008 `RFC5890$r は IDNA2003 に `RFC3490$r 取って代わる。
しかしながら，この 2 つの仕様には相違点があるため、一方の下に登録された~domain名~labelと，もう一方の下に登録されたそれとの間で、処理に違いが生じ得る（例えば変換）。
IDNA2003 に基づく~domain名~labelが残り続ける間，ある程度の移行期間を要する。
~UAは、その IDNA の移行を促すために，
IDNA2008 `RFC5890$r を実装する~SHOULDであり、また，
`UTS46$r または `RFC5895$r を実装しても~MAY。
IDNA2008 を実装しない~UAは，
IDNA2003 `RFC3490$r を実装し~MUST。
◎
IDNA2008 [RFC5890] supersedes IDNA2003 [RFC3490]. However, there are differences between the two specifications, and thus there can be differences in processing (e.g., converting) domain name labels that have been registered under one from those registered under the other. There will be a transition period of some time during which IDNA2003-based domain name labels will exist in the wild. User agents SHOULD implement IDNA2008 [RFC5890] and MAY implement [UTS46] or [RFC5895] in order to facilitate their IDNA transition. If a user agent does not implement IDNA2008, the user agent MUST implement IDNA2003 [RFC3490].
</p>

		</section>
	</section>
	<section id="section-7">
<h2 title="Privacy Considerations">7. ~privacyに関する考慮点</h2>

<p>
~cookieは，~serverによる利用者の追跡にも用いられることから、批判の対象に挙がることも多い。
例えば，いくつもの “~web解析” 会社が、利用者がいつ~web~siteに戻って来て，いつ別の~web~siteを訪問したかを見分けるために、~cookieを利用する。
~cookieは，複数の~HTTP要請に渡って利用者を追跡するために~serverが利用できる唯一の仕組みではないが、
~UAの~sessionに渡って持続的であり，かつ~host間で共有し得ることから、追跡を容易にするものではある。
◎
Cookies are often criticized for letting servers track users. For example, a number of "web analytics" companies use cookies to recognize when a user returns to a web site or visits another web site. Although cookies are not the only mechanism servers can use to track users across HTTP requests, cookies facilitate tracking because they are persistent across user agent sessions and can be shared between hosts.
</p>

		<section id="section-7.1">
<h3 title="Third-Party Cookies">7.1. 第三者主体（ `third-party^en ）による~cookie</h3>

<p>
とりわけ厄介なものは、“第三者主体” ~cookieと呼ばれるものである。
~HTML文書の具現化に際し、~UA，他の~server（広告~networkなど）からの資源を要請することが多い。
これらの第三者主体~serverは、利用者が~serverを直に訪問したことが一度もなくても，利用者の追跡に~cookieを利用できる。
例えば、利用者が第三者主体が~~供する内容を含んでいる~siteを訪問した後，同じ第三者主体が~~供する内容を含んでいる別~siteを訪問した場合、その第三者主体は， 2 つの~site間で利用者を追跡できる。
◎
Particularly worrisome are so-called "third-party" cookies. In rendering an HTML document, a user agent often requests resources from other servers (such as advertising networks). These third-party servers can use cookies to track the user even if the user never visits the server directly. For example, if a user visits a site that contains content from a third party and then later visits another site that contains content from the same third party, the third party can track the user between the two sites.
</p>

<p>
一部の~UAは、第三者主体~cookieの挙動を制約する。
例えば、第三者主体へ向けた要請~内の `Cookie^h ~headerの送信を拒否する, あるいは、第三者主体への要請に対する応答~内の `Set-Cookie^h ~headerの処理を拒否する~UAもある。
そのような，~UAによる第三者主体~cookie用の~policyは、広範に渡る。
この文書は、利用者の~privacyと互換性の必要との~balanceをとるための，
~UAによる第三者主体~cookieに対する~policyの試みに対し，~~寛容さをもって是認するが、特定0のいかなる第三者主体~cookie~policyも，承認するものではない。
◎
Some user agents restrict how third-party cookies behave. For example, some of these user agents refuse to send the Cookie header in third-party requests. Others refuse to process the Set-Cookie header in responses to third-party requests. User agents vary widely in their third-party cookie policies. This document grants user agents wide latitude to experiment with third-party cookie policies that balance the privacy and compatibility needs of their users. However, this document does not endorse any particular third-party cookie policy.
</p>

<p>
第三者主体~cookieの阻止~policyは、利用者の追跡にかけられた制約を~serverがすり抜ける試みに対しては，その~privacy目標を達成するには効果的でないことが多い。
特に，協調する 2 つの~serverは、識別情報を動的~URLに注入することにより，~cookieを全く利用せずに利用者を追跡できることが多い。
◎
Third-party cookie blocking policies are often ineffective at achieving their privacy goals if servers attempt to work around their restrictions to track users. In particular, two collaborating servers can often track users without using cookies at all by injecting identifying information into dynamic URLs.
</p>

		</section>
		<section id="section-7.2">
<h3 title="User Controls">7.2. 利用者による制御</h3>

<p>
~UAは、~cookie保管庫に格納されている~cookieを管理するための仕組みを，利用者に供する~SHOULDである。
例えば、~cookieのうち，［
指定された期間内に受信されたもの ／
特定0の~domainに関連するもの
］すべてを，利用者が削除できるようにするなど。
多くの~UAは、利用者が~cookie保管庫に格納されている~cookieを検分できるような~UIを備えている。
◎
User agents SHOULD provide users with a mechanism for managing the cookies stored in the cookie store. For example, a user agent might let users delete all cookies received during a specified time period or all the cookies related to a particular domain. In addition, many user agents include a user interface element that lets users examine the cookies stored in their cookie store.
</p>

<p>
~UAは、~cookieを不能化する仕組みを，利用者に供する~SHOULDである。
~cookieが不能化されている場合、~UAは outbound†（~server向け）~HTTP要請に `Cookie^h ~headerを内包しては~MUST_NOT，また
inbound† ~HTTP応答の `Set-Cookie^h ~headerを処理しては~MUST_NOT。
◎
User agents SHOULD provide users with a mechanism for disabling cookies. When cookies are disabled, the user agent MUST NOT include a Cookie header in outbound HTTP requests and the user agent MUST NOT process Set-Cookie headers in inbound HTTP responses.
</p>

<p class="trans-note">【†
~HTTP仕様（ RFC2616 ）と，語の用法が正反対（~UA視点）になっている。
】</p>


<p>
一部の~UAは、複数~sessionにわたる~cookieの持続的な保管を防ぐ~optionを，利用者に供する。
そのように環境設定されている場合、~UAは，受信されたすべての~cookieを，
`persistent-flag$f が ~F にされたかのように，扱わ~MUST。
一部の普及している~UAは、この機能性を “私的閲覧~mode” を介して公開している
`Aggarwal2010$r
。
◎
Some user agents provide users the option of preventing persistent storage of cookies across sessions. When configured thusly, user agents MUST treat all received cookies as if the persistent-flag were set to false. Some popular user agents expose this functionality via "private browsing" mode [Aggarwal2010].
</p>

<p>
一部の~UAは、~cookie保管庫への個々の書込みについて，その是非を設定する能を、利用者に供する。
共通的な多くの利用局面において、これらの制御は，多数の入力指示を生成する。
それでもなお、~privacy意識の高い一部の利用者は，これらの制御に有用さを見いだす。
◎
Some user agents provide users with the ability to approve individual writes to the cookie store. In many common usage scenarios, these controls generate a large number of prompts. However, some privacy-conscious users find these controls useful nonetheless.
</p>

		</section>
		<section id="section-7.3">
<h3 title="Expiration Dates">7.3. 有効期限</h3>

<p>
~serverは，~cookieの有効期限を遠い未来に設定できるが、ほとんどの~UAは，実際に~cookieを何十年も維持することはない。
~serverは、無用に長い有効期間を設定せずに，~cookieの目的に基づく，適度な有効期間にすることにより、利用者~privacyを~~向上させる~SHOULDである。
例えば、~session識別子の代表的な期限は， 2 週間くらいが適度であろう。
◎
Although servers can set the expiration date for cookies to the distant future, most user agents do not actually retain cookies for multiple decades. Rather than choosing gratuitously long expiration periods, servers SHOULD promote user privacy by selecting reasonable cookie expiration periods based on the purpose of the cookie. For example, a typical session identifier might reasonably be set to expire in two weeks.
</p>

		</section>
	</section>
	<section id="section-8">
<h2 title="Security Considerations">8. ~security上の考慮点</h2>

		<section id="section-8.1">
<h3 title="Overview">8.1. 概観</h3>

<p>
~cookieには、~security上の陥穽がいくつかある。
この節では、その中で少数の，特に際立つ課題を概観する。
◎
Cookies have a number of security pitfalls. This section overviews a few of the more salient issues.
</p>

<p>
~cookieは特に、認証における`ambient 権限$に依拠するよう開発者に促す結果，~siteをまたがる要請の偽造（ Cross-Site Request Forgery ）`CSRF$r
のような攻撃に対する脆弱性に転じることが多い。
また，~session識別子を~cookieに格納する際に、開発者は，~session固定化（
session fixation 
【<a href="https://en.wikipedia.org/wiki/Session_fixation">参考</a>】
）の脆弱性を生み出すことが多い。
<!-- 
http://security.c-inf.com/index.php?Session%20Fixation
-->
◎
In particular, cookies encourage developers to rely on ambient authority for authentication, often becoming vulnerable to attacks such as cross-site request forgery [CSRF]. Also, when storing session identifiers in cookies, developers often create session fixation vulnerabilities.
</p>

<p>
~cookie~protocolには，それ自体に種々の脆弱性があるので（下の
<a href="#section-8.5" >機密性の弱点</a>,
<a href="#section-8.6" >完全性の弱点</a>
を見よ）、
~HTTPSに使役されるような~transport層の暗号化は，~network攻撃者が被害者の~cookieを得る／改めるのを防ぐには不足である。
加えて，既定では、~cookieは，たとえ~HTTPSと併用されていたとしても，~network攻撃者に抗する機密性や完全性を供さない。
◎
Transport-layer encryption, such as that employed in HTTPS, is insufficient to prevent a network attacker from obtaining or altering a victim's cookies because the cookie protocol itself has various vulnerabilities (see "Weak Confidentiality" and "Weak Integrity", below). In addition, by default, cookies do not provide confidentiality or integrity from network attackers, even when used in conjunction with HTTPS.
</p>

		</section>
		<section id="section-8.2">
<h3 title="Ambient Authority">8.2. Ambient 権限</h3>

<!-- 
https://en.wikipedia.org/wiki/Ambient_authority
 -->

<p>
利用者の認証に~cookieを利用する~serverは、一部の~UAが，~remote主体による［
~UAからの（例えば, ~HTTP~redirectや~HTML~formを介した）~HTTP要請の発行
］を放任するので、~security脆弱性に悩まされることになる。
そのような~UAは、それらの要請の発行に際し，~remote主体がその~cookieの内容について未知であっても、~cookieを添付してしまう。
その結果、騙され易い~serverは，~remote主体から権限を行使され得ることになる。
【~remote主体 — おそらく，`第三者主体$と同義。】
◎
A server that uses cookies to authenticate users can suffer security vulnerabilities because some user agents let remote parties issue HTTP requests from the user agent (e.g., via HTTP redirects or HTML forms). When issuing those requests, user agents attach cookies even if the remote party does not know the contents of the cookies, potentially letting the remote party exercise authority at an unwary server.
</p>

<p>
この~securityの懸念には，いくつかの呼称があるが（例えば、
“`cross-site request forgery^en”【†1】 や “`confused deputy^en”【†2】 ）、その課題は，~cookieが
`ambient 権限@
【†3】 の一形態である所から端を発する。
~cookieは、（~URLの形をとる）対象の指名（ `designation^en ）と（~cookieの形をとる）対象への権限付与（ `authorization^en ）との分離を，~serverの運用者たちに促してしまう。
その結果、~UAは，攻撃者が指名する資源に権限を給してしまい、~serverや~clientは，攻撃者により指名された行為を
— 彼らが利用者から権限を与えられたかのように —
引き受けてしまう可能性がある。
◎
Although this security concern goes by a number of names (e.g., cross-site request forgery, confused deputy), the issue stems from cookies being a form of ambient authority. Cookies encourage server operators to separate designation (in the form of URLs) from authorization (in the form of cookies). Consequently, the user agent might supply the authorization for a resource designated by the attacker, possibly causing the server or its clients to undertake actions designated by the attacker as though they were authorized by the user.
</p>

<p>
~serverの運用者たちは、権限付与に~cookieを用いる代わりに，~URLを能力（ `capabilities^en ）【†4】 として扱うことにより、対象の指名と対象への権限付与とを絡めたいと考えるかもしれない。
この~approachは、秘匿情報を~cookieに格納する代わりに~URLに格納して，~remote~~主体が秘匿情報~自体を給することを要求する。
この~approachは万能ではないが、この原理を思慮深く応用すれば，より堅牢な~securityをもたらし得る。
◎
Instead of using cookies for authorization, server operators might wish to consider entangling designation and authorization by treating URLs as capabilities. Instead of storing secrets in cookies, this approach stores secrets in URLs, requiring the remote entity to supply the secret itself. Although this approach is not a panacea, judicious application of these principles can lead to more robust security.
</p>


<ul class="trans-note">
	<li>†1
“`cross-site request forgery^en” 
（ <abbr>CSRF</abbr>, ~siteをまたがる要請の偽造） —
<a href="https://ja.wikipedia.org/wiki/Cross_site_request_forgery" >参考</a>
</li>
	<li>†2
“`confused deputy^en”
（混乱した使節の~~問題） —
<a href="https://ja.wikipedia.org/wiki/Confused_deputy_problem" >参考</a>
</li>
	<li>†3
環境から暗黙的に与えられる権限 —
<a href="https://en.wikipedia.org/wiki/Ambient_authority" >参考</a>
<!-- （参考からの抜粋の和訳）：例えば今日主流の Unix 系／ Windows におけるログインユーザ別の権限付与は ambient 権限の一例になる。~appのどの操作にも<em >一律に</em>，必要以上の高い権限が付与されてしまう，などの欠点がある。 -->
</li>
	<li>†4
<a href="https://ja.wikipedia.org/wiki/Capability-based_security" >参考：能力（ `capability^en ）に基づく~security</a> （ `ambient^en 権限に対立する概念）
</li>
</ul>

		</section>
		<section id="section-8.3">
<h3 title="Clear Text">8.3. 平文~text</h3>

<p>
~secure~channel（ ~TLSなど）越しに送信されていない限り、 `Cookie^h と `Set-Cookie^h ~header内の情報は，平文のまま伝送される。
◎
Unless sent over a secure channel (such as TLS), the information in the Cookie and Set-Cookie headers is transmitted in the clear.
</p>

<ol>
	<li>
これらの~headerにより運ばれる，~securityに敏感な情報すべてが、盗聴者に公開される。
◎
All sensitive information conveyed in these headers is exposed to an eavesdropper.
</li>
	<li>
悪意的な中継点は，いずれの方向へ流れる~headerも改めれるため、予測-不能な結果になる。
◎
A malicious intermediary could alter the headers as they travel in either direction, with unpredictable results.
</li>
	<li>
悪意的な~clientは， `Cookie^h ~headerを その伝送-前に改めれるため、予測-不能な結果になる。
◎
A malicious client could alter the Cookie header before transmission, with unpredictable results.
</li>
</ol>

<p>
~serverは、~UAに向けて~cookieの内容を伝送する際には（~cookieを~secure~channel越しに送信するときでも）、（自身が欲する何らかの形式で）暗号化して署名する~SHOULDである。
しかしながら，それだけでは、攻撃者による，
~UAから別の~UAへの~cookieの植え付け（ `transplanting^en ）や,
後の時点における~cookieの再現を防ぐことにはならない。
◎
Servers SHOULD encrypt and sign the contents of cookies (using whatever format the server desires) when transmitting them to the user agent (even when sending the cookies over a secure channel). However, encrypting and signing cookie contents does not prevent an attacker from transplanting a cookie from one user agent to another or from replaying the cookie at a later time.
</p>

<p>
各~cookieごとに内容を暗号化して署名することに加えて、高~levelの~securityを要する~serverは、~secure~channel越しに限り `Cookie^h, `Set-Cookie^h ~headerを利用した上で，どの~cookieにも `Secure$a 属性（ `4.1.2.5$sec）を設定する~SHOULDである。
~serverが `Secure$a 属性を設定しない場合、~secure~channelにより供される保護は，ほぼ無意味と化すことになる。
◎
In addition to encrypting and signing the contents of every cookie, servers that require a higher level of security SHOULD use the Cookie and Set-Cookie headers only over a secure channel. When using cookies over a secure channel, servers SHOULD set the Secure attribute (see Section 4.1.2.5) for every cookie. If a server does not set the Secure attribute, the protection provided by the secure channel will be largely moot.
</p>

<p>
例えば、~cookieの中に~session識別子を格納する~web~mail~serverがあって，概して ~HTTPS越しに~accessされるとする。
~serverがその~cookieに `Secure$a 属性を設定しなかった場合、能動的~network攻撃者は、~UAからの任意の outbound ~HTTP要請を傍受して，~web~mail~serverに向けて，その要請を~HTTP越しに~redirectさせることが可能になる。
~web~mail~serverが~HTTP接続を~listenしていなくても、依然として，~UAは
【~redirectにおける】
要請の中に~cookieを内包させることになる。
能動的~network攻撃者は、これらの~cookieを傍受して，~serverに向けてそれらを再現することにより、利用者の~mail内容を読み取ることが可能になる。
~serverが `Secure$a 属性をその~cookieに設定していたなら、
~UAはその~cookieを平文~textの要請の中に内包させはしないであろう。
◎
For example, consider a webmail server that stores a session identifier in a cookie and is typically accessed over HTTPS. If the server does not set the Secure attribute on its cookies, an active network attacker can intercept any outbound HTTP request from the user agent and redirect that request to the webmail server over HTTP. Even if the webmail server is not listening for HTTP connections, the user agent will still include cookies in the request. The active network attacker can intercept these cookies, replay them against the server, and learn the contents of the user's email. If, instead, the server had set the Secure attribute on its cookies, the user agent would not have included the cookies in the clear-text request.
</p>

		</section>
		<section id="section-8.4">
<h3 title="Session Identifiers">8.4. ~session識別子</h3>

<p>
~serverが、~session情報を（攻撃者に公開されたり, 再現され得る）~cookieに直に格納する代わりに，~nonce （
“`number used once^en （使い捨ての番号）”
— 別名 “~session識別子”
）を~cookieに格納することが、共通的に行われている。
~serverは、~nonceを伴う~HTTP要請を受信したとき，その~nonceを~keyに，その~cookieに結付けられている状態~情報を検索できる。
◎
Instead of storing session information directly in a cookie (where it might be exposed to or replayed by an attacker), servers commonly store a nonce (or "session identifier") in a cookie. When the server receives an HTTP request with a nonce, the server can look up state information associated with the cookie using the nonce as a key.
</p>

<p>
~nonceが有用になるのは，（それ自身が~securityに敏感である，非~nonceの~cookieを成す内容と違って）~serverと対話するときに限られるので、~session識別子~cookieの利用-下では，攻撃者に~cookieの内容を~~読み取られたときの被害が制限される。
更に，使い捨て~nonceを利用することで、攻撃者が，~serverとの 2 回の対話から~cookieの内容を “継ぎ接ぎ” して，~serverの挙動を期待されないものにすることは、防がれる。
◎
Using session identifier cookies limits the damage an attacker can cause if the attacker learns the contents of a cookie because the nonce is useful only for interacting with the server (unlike non-nonce cookie content, which might itself be sensitive). Furthermore, using a single nonce prevents an attacker from "splicing" together cookie content from two interactions with the server, which could cause the server to behave unexpectedly.
</p>

<p>
~session識別子の利用には~riskが伴う。
例えば、~serverは， “~session固定化（~session強制）” の脆弱性を避けるべく，注意を払う~SHOULDである。
~session固定化の攻撃は 3 段階を経て行われる。
最初の段階では、攻撃者は，~session識別子を自身の~UAで取得してから，被害者の~UAに植え付ける。
次の段階では、被害者がその~session識別子を~serverとの対話に利用する（~session識別子には，利用者の資格証明（ `credentials^en ）や機密（ `confidential^en ）に関する情報も伴われている可能性がある）。
最後の段階では、攻撃者は，その~session識別子を利用して~serverと直に対話する（利用者の権限（ `authority^en ）や機密に関する情報が奪われる可能性がある）。
◎
Using session identifiers is not without risk. For example, the server SHOULD take care to avoid "session fixation" vulnerabilities. A session fixation attack proceeds in three steps. First, the attacker transplants a session identifier from his or her user agent to the victim's user agent. Second, the victim uses that session identifier to interact with the server, possibly imbuing the session identifier with the user's credentials or confidential information. Third, the attacker uses the session identifier to interact with server directly, possibly obtaining the user's authority or confidential information.
</p>

<p class="trans-note">【
植え付ける — transplant ：
（訳者による解釈）何らかの方法（具体的な方法は<a href="https://www.google.co.jp/search?q=session+fixation" >多岐にわたる</a>）で、被害者を “攻撃者が~session識別子により，一定の権限を持った状態で~serverに~accessできる状況”
と同一の状況に誘導する（しかる後，“体を入れ替える”
— 攻撃者が用意した “合鍵” を被害者に利用させ、しかる後，同じ鍵で侵入する —
したがって、 “ログイン” 時に鍵を別のに交換することが~~有効な対策になると考えられる）。
】</p>

		</section>
		<section id="section-8.5">
<h3 title="Weak Confidentiality">8.5. 機密性の弱点</h3>

<p>
~cookieは~portによる隔離を供さない。
~cookieが，ある~port上で動作する~serviceで読取れるならば、その~cookieは，同じ~serverの別~port上の~serviceでも読取れる。
~cookieが，ある~port上の~serviceで書込めるならば、その~cookieは，同じ~serverの別~port上の~serviceでも書込める。
この理由から、~serverは、同じ~hostの異なる~port上で，互いに信用し合っていない~serviceを同時に稼働しているときは、~securityに敏感な情報を~cookieを利用して格納する~SHOULDでない。
◎
Cookies do not provide isolation by port. If a cookie is readable by a service running on one port, the cookie is also readable by a service running on another port of the same server. If a cookie is writable by a service on one port, the cookie is also writable by a service running on another port of the same server. For this reason, servers SHOULD NOT both run mutually distrusting services on different ports of the same host and use cookies to store security-sensitive information.
</p>

<p>
~cookieは~schemeによる隔離を供さない。
~cookieは `http^c と `https^c ~schemeで最も共通的に利用されるが、所与の~host用の~cookieは， `ftp^c や `gopher^c などの他の~schemeでも可用になり得る。
この，~schemeによる隔離の欠如は、~cookieへの~accessを許可する`非HTTP~API$（例えば~HTMLの `document.cookie^c ~API）において顕著に見られるが、~schemeによる隔離の欠如はまた，~cookieの処理~要件にも実際に在る（例えば、~HTTPを介して `gopher^c ~scheme~URIから検索取得することを考えてみよ）。
◎
Cookies do not provide isolation by scheme. Although most commonly used with the http and https schemes, the cookies for a given host might also be available to other schemes, such as ftp and gopher. Although this lack of isolation by scheme is most apparent in non-HTTP APIs that permit access to cookies (e.g., HTML's document.cookie API), the lack of isolation by scheme is actually present in requirements for processing cookies themselves (e.g., consider retrieving a URI with the gopher scheme via HTTP).
</p>

<p>
~cookieは~pathによる隔離を常に供するものではない。
~network~levelの~protocolでは、ある~pathに対応して格納された~cookieが，別の~pathに向けて送信されることはないが、一部の~UAは，
~HTMLの `document.cookie^c ~APIなどの`非HTTP~API$を介して，~cookieを公開する。
これらの~UAの一部（例えば，~web~browserなど）は，異なる~pathから受信された資源を隔離しないので、ある~pathから検索取得された資源から，別の~pathに対応して格納された~cookieに~accessし得る。
◎
Cookies do not always provide isolation by path. Although the network-level protocol does not send cookies stored for one path to another, some user agents expose cookies via non-HTTP APIs, such as HTML's document.cookie API. Because some of these user agents (e.g., web browsers) do not isolate resources received from different paths, a resource retrieved from one path might be able to access cookies stored for another path.
</p>

		</section>
		<section id="section-8.6">
<h3 title="Weak Integrity">8.6. 完全性の弱点</h3>

<p>
~cookieは、同胞~domain（およびそれらの下位domain）に対する完全性（ `integrity^en ）を保証しない。
例えば, `foo.example.com^s と `bar.example.com^s を考える。
`foo.example.com^s の~serverは、 `Domain$a 属性 "`example.com^s" の~cookieを設定できる（既存の "`example.com^s" ~cookieを上書きする可能性もある）。
~UAは、その~cookieを `bar.example.com^s へ向けた~HTTP要請に内包することになる。
最悪の場合、
`bar.example.com^s は，この~cookieと自身が設定した~cookieとを判別できなくなる。
`foo.example.com^s ~serverは、この能を利用して `bar.example.com^s への攻撃を仕掛けるかもしれない。
◎
Cookies do not provide integrity guarantees for sibling domains (and their subdomains). For example, consider foo.example.com and bar.example.com. The foo.example.com server can set a cookie with a Domain attribute of "example.com" (possibly overwriting an existing "example.com" cookie set by bar.example.com), and the user agent will include that cookie in HTTP requests to bar.example.com. In the worst case, bar.example.com will be unable to distinguish this cookie from a cookie it set itself. The foo.example.com server might be able to leverage this ability to mount an attack against bar.example.com.
</p>


<p>
`Set-Cookie^h ~headerが `Path$a 属性を~supportしていても，
~UAは `Set-Cookie^h ~header内の任意の `Path$a 属性を受容するので、
`Path$a 属性は，いかなる完全性の保護も供さない。
例えば，
`http://example.com/foo/bar^s
に向けた要請に対する~HTTP応答は、
`Path$a 属性 "`/qux^s" の~cookieを設定できる。
したがって~serverは、同じ~hostの異なる~path上で，互いに信用し合っていない~serviceを同時に稼働しているときは、~securityに敏感な情報を~cookieを利用して格納する~SHOULDでない。
◎
Even though the Set-Cookie header supports the Path attribute, the Path attribute does not provide any integrity protection because the user agent will accept an arbitrary Path attribute in a Set-Cookie header. For example, an HTTP response to a request for http://example.com/foo/bar can set a cookie with a Path attribute of "/qux". Consequently, servers SHOULD NOT both run mutually distrusting services on different paths of the same host and use cookies to store security-sensitive information.
</p>

<p>
能動的~network攻撃者は、
`http://example.com/^s
からの応答を模倣して `Set-Cookie^h ~headerを注入することにより，
`https://example.com/^s
に向けて送信される `Cookie^h ~headerに~cookieを注入できる。
`example.com^s
にある~HTTPS~serverは、~HTTPS応答の中のこれらの~cookieと自身が設定した~cookieとを，判別できない。
`example.com^s が~HTTPSを排他的に利用していたとしても、能動的~network攻撃者は，この能を利用して `example.com^s への攻撃を仕掛けるかもしれない。
◎
An active network attacker can also inject cookies into the Cookie header sent to https://example.com/ by impersonating a response from http://example.com/ and injecting a Set-Cookie header. The HTTPS server at example.com will be unable to distinguish these cookies from cookies that it set itself in an HTTPS response. An active network attacker might be able to leverage this ability to mount an attack against example.com even if example.com uses HTTPS exclusively.
</p>

<p>
~serverは、自身の~cookieの内容を暗号化して署名することにより，これらの攻撃を部分的に軽減できる。
しかしながら，攻撃者は、自身が真正の `example.com^s ~serverから受信した~cookieを，利用者の~sessionの中で再現できるので、暗号の利用は この課題を根本から払拭するものではなく，予測-不能な結果になる。
◎
Servers can partially mitigate these attacks by encrypting and signing the contents of their cookies. However, using cryptography does not mitigate the issue completely because an attacker can replay a cookie he or she received from the authentic example.com server in the user's session, with unpredictable results.
</p>

<p>
最後に、攻撃者は、多数の~cookieを格納させることにより，~cookieを削除するよう~UAに強制するかもしれない。
~UAは，自身の保管~上限に達したとき、何らかの~cookieを抹消するよう強制されることになる。
~serverは、~UAが~cookieを維持することに依拠する~SHOULDでない。
◎
Finally, an attacker might be able to force the user agent to delete cookies by storing a large number of cookies. Once the user agent reaches its storage limit, the user agent will be forced to evict some cookies. Servers SHOULD NOT rely upon user agents retaining cookies.
</p>

		</section>
		<section id="section-8.7">
<h3 title="Reliance on DNS">8.7. ~DNSへの依拠</h3>

<p>
~cookieの~securityは、~DNS（ Domain Name System ）に依拠する。
~DNSが部分的または全部的に弱体化された場合、~cookie~protocolは，~appが要する~securityを供するのに失敗するであろう。
◎
Cookies rely upon the Domain Name System (DNS) for security. If the DNS is partially or fully compromised, the cookie protocol might fail to provide the security properties required by applications.
</p>

		</section>
	</section>
	<section id="section-9">
<h2 title="IANA Considerations">9. IANA Considerations</h2>

<p>
恒久的~message~header ~registry（ `RFC3864$r を見よ）
は以下の登録により更新された。
◎
The permanent message header field registry (see [RFC3864]) has been updated with the following registrations.
</p>

		<section id="section-9.1">
<h3 title="Cookie">9.1. `Cookie^h</h3>

<div >
<table><tbody><tr><th>~header名
<td>`Cookie^h

<tr><th>適用できる~protocol
<td>http

<tr><th>位置付け
<td>standard

<tr><th>作変更管理者
<td>IETF

<tr><th>仕様~文書
<td>この仕様（`5.4$sec）
</tbody></table>

◎
Header field name: Cookie
Applicable protocol: http
Status: standard
Author/Change controller: IETF
Specification document: this specification (Section 5.4)
</div>


		</section>
		<section id="section-9.2">
<h3 title="Set-Cookie">9.2. `Set-Cookie^h</h3>

<div >
<table><tbody><tr><th>~header名
<td>`Set-Cookie^h

<tr><th>適用できる~protocol
<td>http

<tr><th>位置付け
<td>standard

<tr><th>作変更管理者
<td>IETF

<tr><th>仕様~文書
<td>この仕様（`5.2$sec）
</tbody></table>

◎
Header field name: Set-Cookie
Applicable protocol: http
Status: standard
Author/Change controller: IETF
Specification document: this specification (Section 5.2)
</div>


		</section>
		<section id="section-9.3">
<h3 title="Cookie2">9.3. `Cookie2^h</h3>

<div >
<table><tbody><tr><th>~header名
<td>`Cookie2^h

<tr><th>適用できる~protocol
<td>http

<tr><th>位置付け
<td>obsoleted

<tr><th>作変更管理者
<td>IETF

<tr><th>仕様~文書
<td>`RFC2965$r
</tbody></table>

◎
Header field name: Cookie2
Applicable protocol: http
Status: obsoleted
Author/Change controller: IETF
Specification document: [RFC2965]
</div>


		</section>
		<section id="section-9.4">
<h3 title="Set-Cookie2">9.4. `Set-Cookie2^h</h3>

<div >
<table><tbody><tr><th>~header名
<td>`Set-Cookie2^h

<tr><th>適用できる~protocol
<td>http

<tr><th>位置付け
<td>obsoleted

<tr><th>作変更管理者
<td>IETF

<tr><th>仕様~文書
<td>`RFC2965$r
</tbody></table>

◎
Header field name: Set-Cookie2
Applicable protocol: http
Status: obsoleted
Author/Change controller: IETF
Specification document: [RFC2965]
</div>

		</section>
	</section>
	<section>
<h2 title="Acknowledgements">Appendix A. 謝辞</h2>

<p>
この文書は `RFC2109$r から多くの部分を借りている。
`David M. Kristol^en 氏と `Lou Montulli^en 氏，彼らの cookies 仕様にかけた労に感謝する。
特に `David M. Kristol^en 氏による, IETF プロセスの進行に関する貴重なアドバイスに。
また、次の方々からの，この文書への有益な~feedbackに感謝する：
◎
This document borrows heavily from RFC 2109 [RFC2109]. We are indebted to David M. Kristol and Lou Montulli for their efforts to specify cookies. David M. Kristol, in particular, provided invaluable advice on navigating the IETF process. We would also like to thank＼
</p>

<p lang="en-x-a0">
Thomas Broyer, Tyler Close, Alissa Cooper, Bil Corry, corvid, Lisa Dusseault, Roy T. Fielding, Blake Frantz, Anne van Kesteren, Eran Hammer-Lahav, Jeff Hodges, Bjoern Hoehrmann, Achim Hoffmann, Georg Koppen, Dean McNamee, Alexey Melnikov, Mark Miller, Mark Pauley, Yngve N. Pettersen, Julian Reschke, Peter Saint-Andre, Mark Seaborn, Maciej Stachowiak, Daniel Stenberg, Tatsuhiro Tsujikawa, David Wagner, Dan Winship, and Dan Witte for their valuable feedback on this document.
</p>
	</section>

</main></div>
