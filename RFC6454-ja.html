<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>RFC 6454 - The Web Origin Concept （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const section_id_map = this.section_id_map;


	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#ref-${key}`;//.toLowerCase();
	break;
case 'l': // octet literal
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'X': // byte value
	text = `%x${text}`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">

●●options

trans_update:2018-10-26
original_url:https://www.rfc-editor.org/rfc/rfc6454
spec_status:IETFPR
no_original_dfn:true
no_index:true
toc:toc
ref_id_prefix:ref-
ref_rfc:true
site_nav:security,network
trans_1st_pub:2012-10-06


●●class_map
e:element
sc:scheme
P:production
X:hex-value
h:header
U:code-point

●●tag_map
h:code
P:code
c:code
e:code
sc:code
s:samp
X:span
U:span
i:i

●●mdn_urls
section-7:HTTP/Headers/Origin

●●link_map
~GUID:#globally-unique-identifier
成分組~生成元:#tuple-origin

●●ref_data
SNIFF=副   ~/mimesniff-ja.html●MIME sniffing 日本語訳

●●words_table1

ナラナイ:<em class="rfc2119">ならない</em>
ベキ:<em class="rfc2119">べき</em>
ヨイ:<em class="rfc2119">よい</em>
student:~student

●●words_table

	●network
DNS:
TLS:
IDNA:
firewall::::ファイアウォール
配備状況:deployment::~
	~headerヘッダフィールド:header field
首体:principal::主体
directory::::ディレクトリ
	異なる生成元 間の

端点:endpoint::~
公共:public::~
完全修飾:fully qualified::~
実体:entity::~
発行-:issue::発行

	●構文
URI:
成分組:tuple::~
	成分組:triple
	Unicode:unicode
	-label
GUID:
dot::::ドット
	成分:part
妥当性検証:validation::~
照合:collation::~
並び:sequence::~
	小文字~化:converted to lowercase

	●保安
特権:privilege::~
	~risk:risk にさらす
ambient:
XSS:cross-site scripting:XSS
公開鍵:public-key::~
password::::パスワード
	~security~model:security model
信頼関係:trust relationship::~
	信用-済みでない:untrusted
	互いに信用できない:mutually distrusting
能動的:active::~
受動的:passive::~
権限:authority::~
侵害-:disrupt::~
証明書:certificate::~
汚染:compromise::~
弱体化-:compromise::~
機密性:confidentiality::~
隔離単位:unit of isolation::~

命名機関:naming authority::~
	一定範囲に封じ込める:contain
善意的:benign::~
正直:honest::~
防止:prevention::~
抵抗力:resistant::~
差止めれ:withholdすれ:差し止めれ
差止めて:withholdして:差し止めて
差止める:withholdする:差し止める
迂回-:bypass::~
危険:dangerous::~
陥穽:pitfall:落とし穴
外来:foreign::~
弱点:weaknesses::~
秘匿:secret::~
	に至らせ:lead
偽造:forgery:~
描直す:redrawする:描き直す
敷いた:erectした:~
有害:detrimental:~
sniff:

	もたらし:rise
	最悪:At worst
	細工を施す:corrupt
	分け隔てて:divided
	絶たれる:disentangling
	~~区分:discriminating
	拡大:Expanding／
	拡大させ
	段階的な拡大 escalation

	●仕様
opt-in::::オプトイン
idea::::アイデア
恒久的:permanent:~
特質:property:~:::プロパティ
原理的には:principleにおいては:~
原理:principle:~
体系上の:systemicな:~
発展-:evolve:~
組織的:organical:~
側面f:facet:側面
中心的:central:~
体系的:systemic:~
根幹:cornerstones:~
所産:artifact:~
粒度:granularity:~
通例:usual:~
背後:behind:~
不可欠:crucial:~
兼合い:balance:兼ね合い
種類:kind:~
基礎部品:nuts and bolts:~

	~~全般:landscape
	~~主要な:key
	あるイミ:In some sense
	~~考えられ
	なぜ:Why
	なぜなら:because
	望ましくない:worse
	良くて:At best
	表記
	通称:colloquially
	過大:tremendous amount of
	確保-:make sure
	~~指示:instruction／
	あり続け:remain
	万能:one-size-fits-all
	代案:Instead
	人による
	今も:today
	ほぼ確実:likely to be
	参考
	善意による:well-meaning
	沿える:align
	無論:Of course
	不整合を孕む:incoherent
	細心な注意:great care
	総体として:as a whole
	一例:an example
	可否:-
	易くなる
	最近になって:has been recent
	略して
	見慣れない
	区別:distinction
	十分長い:sufficiently long
	結局は:anyway
	要約:Abstract／Conclusion
	何であれ:irrespective of
	度合い:how much
	当時:at the time
	利する:on behalf of
	謝意
	までの範囲内:extent

	●status／適合性／謝辞／規約
同意:consent:~
メモ:memo:~
	IETF
	IESG
	推奨され:RECOMMENDED
表記法:notation:~
単調増加-:monotonic に increase:~
	句:phrased
	頭部の:leading
	最終結果:end result
	~~連続して:linear
	貴重
	寄せら

	●仕様（動詞
登録制:registry-controlled:~
委任関係:delegation:~
指名-:designate:~
指名:designation:~
	cause
収束-:converge:~
依拠:reliance:~
助言:advice:~:::アドバイス
寄与-:contribute:~
手助け:facilitate:~
採用-:adopt:~
移行-:migrate:~
移行:migration:~
給-:supply:~
試して:tryして:~
請負う:undertakeする:請け負う
運用者:operators:~
依存:dependency:~
保つ:keepする:~
完璧:perfect:~
自由:free:~
厄介:cumbersome:~
招く:inviteする:~
判明した:proveされた:~
関心:interest:~
開示-:export:~
分岐:divergent:~
復活:reviving:~
役割:role:~
課す:imposeする:~
機能:function:~
	課され:-
	大雑把に言えば:Roughly speaking
	ことになる:mean
	備わる:afforded by
	~~協同して:in concert
	広く:widely／largely
	広範:wide
	意味する
	~~評価:Evaluating
	良さそう:tempting
	呼ばれ／:called／:known as／-
	委ねられ:left to
	優位を得る:gain any advantage
	先行して:pre-date
	要する
	-:則って
	-:定めら
	占めて:plays
	対応する
	備えて
	備える
	取り巻く:surrounding
	従って
	従わ
	満たせ
	見られる:available
	言う:-
	取り払って:tearing down

	●未分類（動詞
運用:operation::~

読取らせ:readさせ::読み取らせ
提示-:present:~
	RET:abort
取込む:importする::取り込む
取込まれ:importされ::取り込まれ
内包-:include:~

	算出し直す:recomputing
	仕分け:grouping
	仕分ける:group
	含む:include
	~~運用され:run
	記され
	そこに居れば:potential
	追えなく:following
	有する:carries
	受け:received
	出せて
	加え
	属して
	属する
	持-:have
	生じ
	見える
	続けて
	行う
	行わ

	●未分類
	en:cross-site request forgery
	en:cross-site scripting
MIME
新規の:freshな:~
深い:deepな::~
	逆順:reverse
	部品:pieces
	-区切り
	十進表記:base ten
	参照する:by reference
	同様:Likewise／Similarly
	最新状態:up to date
	連続して／連続する:consecutive
	寸法:height and width
	示し
	^en:大域的に一意な識別子
	^en:taint tracking
	^en:exfiltration
	医療記録:medical records
	地方自治体:municipalities
	生成結果:productions
	一学生:student
	学生:students
	年月:Over time
	成績管理用:managing grades
	教育機関:educational institutions

	●指示語
全-:full:~
	部分的にでも:partially or fully

	ある
	一握りの:handful of
	このようにして:In this way,
	これらの
	すなわち，:in essence／
	いくつかの:a number of
	多い／多く:often
	上
	下
	中には
	中の
	互いに
	他と
	他の
	他方
	代わって
	代わりに
	以下
	伴う
	伴に
	何ら:no
	そういった:-
	その
	そのとき
	それ
	それら
	どの
	どう
	より
	一つ
	個
	個目
	内
	別
	単に／単なる:just
	各:each／
	向けて:to
	回ごと:each time
	場合
	〜によっては:In some
	対し
	対する
	一度だけ:once
	一方
	一部
	指す:-
	成す
	成り
	挙げる:-
	既に
	時には
	更なる
	最も
	有さない
	有する
	末尾に
	極めて
	様
	様に
	次
	次節
	最後
	超えて:across
	越し:over
	通して
	部分
	長い
	異なって
	異なる
	等
	自体
	自身
	間
	限ら
	限り
	限る
	際に
	非
	２つ:two
	沿う:align
	一致するidentical

	高-:high-
	低-:low-
	法
	現在の
	番号
	種の
	箇所
	結果
	無い
	複数の
	複数個の
	複数回
	より小さい:less
	そのまま:verbatim
	後者の:-
	無数:a large number of

	●訳注
	追跡-:track
	暗黙的
	対訳
	和訳
	同程度
	通常の
	高機能
	比較
	訳語
	用語
	語
	実質的
	一文
	優先させ
	当訳
	選定して
	統一する
	環境から
	普通
	~~推定
	由来する
	~~指定
	必要
	忘れない
	新たに
	略記に
	順序
	単純
	標識
	染まって
	内部
	外部
	裏口
	転送-
	入力
	見なす
	記述
	置換-
	段落
	規約
	決して

●●ref_normative

[RFC20]
    Cerf, V., "ASCII format for network interchange", ~RFC20, October 1969. 
[RFC2119]
    Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, ~RFC2119, March 1997. 
[RFC2616]
    Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext Transfer Protocol -- HTTP/1.1", ~RFC2616, June 1999. 
[RFC3864]
    Klyne, G., Nottingham, M., and J. Mogul, "Registration Procedures for Message Header Fields", BCP 90, ~RFC3864, September 2004. 
[RFC3986]
    Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform Resource Identifier (URI): Generic Syntax", STD 66, ~RFC3986, January 2005. 
[RFC4790]
    Newman, C., Duerst, M., and A. Gulbrandsen, "Internet Application Protocol Collation Registry", ~RFC4790, March 2007. 
[RFC5234]
    Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax Specifications: ABNF", STD 68, ~RFC5234, January 2008. 
[RFC5890]
    Klensin, J., "Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework", ~RFC5890, August 2010. 
[RFC5891]
    Klensin, J., "Internationalized Domain Names in Applications (IDNA): Protocol", ~RFC5891, August 2010. 
[Unicode6]
    The Unicode Consortium, "The Unicode Standard, Version 6.0.0", 2011
    URL: http://www.unicode.org/versions/Unicode6.0.0/

●●ref_informative

[BOFGO]
    Jackson, C. and A. Barth, "Beware of Finer-Grained Origins", 2008
    URL: http://w2spconf.com/2008/papers/s2p1.pdf
[CORS]
    van Kesteren, A., "Cross-Origin Resource Sharing", W3C Working Draft WD-cors-20100727, July 2010
    URL: https://www.w3.org/TR/2010/WD-cors-20100727/
    URL: https://www.w3.org/TR/cors/
[CRX]
    Barth, A., Felt, A., Saxena, P., and A. Boodman, "Protecting Browsers from Extension Vulnerabilities", 2010
    URL: http://www.isoc.org/isoc/conferences/ndss/10/pdf/04.pdf
[CSRF]
    Barth, A., Jackson, C., and J. Mitchell, "Robust Defenses for Cross-Site Request Forgery", 2008
    URL: http://portal.acm.org/citation.cfm?id=1455770.1455782
[HTML]
    Hickson, I., "HTML5", W3C Working Draft WD-html5-20110525, May 2011
    URL: http://www.w3.org/TR/2011/WD-html5-20110525/
    URL: http://www.w3.org/TR/html5/
[RFC2397]
    Masinter, L., "The "data" URL scheme", ~RFC2397, August 1998. 
[RFC2817]
    Khare, R. and S. Lawrence, "Upgrading to TLS Within HTTP/1.1", ~RFC2817, May 2000. 
[RFC3490]
    Faltstrom, P., Hoffman, P., and A. Costello, "Internationalizing Domain Names in Applications (IDNA)", ~RFC3490, March 2003. 
[RFC5246]
    Dierks, T. and E. Rescorla, "The Transport Layer Security (TLS) Protocol Version 1.2", ~RFC5246, August 2008. 
[RFC6265]
    Barth, A., "HTTP State Management Mechanism", ~RFC6265, April 2011. 
[RFC6455]
    Fette, I. and A. Melnikov, "The WebSocket Protocol", ~RFC6455, December 2011. 
[SNIFF]
    Barth, A. and I. Hickson, "Media Type Sniffing", Work in Progress, May 2011. 
    URL: http://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Media+Type+Sniffing%22


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により PROPOSED STANDARD として公表された，
RFC 6454
<a href="~SPEC_URL">The Web Origin Concept</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

公表者
	Internet Engineering Task Force (IETF)
RFC
	6454
分類
	Standards Track
ISSN
	2070-1721
編集
	A. Barth, Google, Inc.
日付
	2011 年 12 月
現在の位置付け, 正誤表, フィードバックの方法
	https://www.rfc-editor.org/info/rfc6454

</script>

</head>

<body>

<header>
	<hgroup>
<h1>Web 生成元の概念</h1>
<p>RFC 6454 — The Web Origin Concept</p>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section>
◎要約

<p>
この文書は、
~UA（ `user agent^en ）により，［
権限／特権
］の視野としてよく利用される語，
<em>“生成元（ `origin^en ）”</em>
の概念を定義する。
概して、
~UAは，［
悪意的な~web~siteの運用者が，善意的な~web~siteの運用に干渉する
］ことを防止するために［
異なる生成元から検索取得された内容
］を互いに隔離する。
この文書は、［
生成元の概念の~~下層にある原理を要旨する
］ことに加え，［
~URIの生成元を決定する方法,
生成元を文字列に直列化する方法
］についても詳細を与える。
また、
"`Origin^h" と命名される~HTTP~headerも定義する
— それは、［
所与の~HTTP要請に，どの生成元が結付けられるか
］を指示する。
◎
This document defines the concept of an "origin", which is often used as the scope of authority or privilege by user agents. Typically, user agents isolate content retrieved from different origins to prevent malicious web site operators from interfering with the operation of benign web sites. In addition to outlining the principles that underlie the concept of origin, this document details how to determine the origin of a URI and how to serialize an origin into a string. It also defines an HTTP header field, named "Origin", that indicates which origins are associated with an HTTP request.
</p>

<p class="trans-note">【
“生成元” ：
この訳語は、
（おそらく）~HTTP仕様の用語
“`生成する＠~HTTPinfra#generate$（ `generate^en ）”
に由来する。
通例的に、
“`生成元~server＠~HTTPinfra#origin-server$が，~HTTP応答を新たに “生成する”。
】</p>

	</section>
	<section>
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status$に移譲。
】</p>

	</section>
	<section>
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、
この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="section-1">
<h2 title="Introduction">1. 序論</h2>

<p>
~UAは、
無数の作者により作成された内容とヤリトリする。
それらのうち ほとんどは善意によるものだが、
中には悪意的なものもあるかもしれない。
~UAの実装者は、
~UAが処理する内容に基づいて動作を請負うまでの範囲内で，悪意的な作者が［
他の内容, あるいは~server
］の機密性（ `confidentiality^en ）や完全性（ `integrity^en 【`参考＠https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E5%AE%8C%E5%85%A8%E6%80%A7$】）
を侵害する能を制約するよう望むであろう。
◎
User agents interact with content created by a large number of authors. Although many of those authors are well-meaning, some authors might be malicious. To the extent that user agents undertake actions based on content they process, user agent implementors might wish to restrict the ability of malicious authors to disrupt the confidentiality or integrity of other content or servers.
</p>

<p>
例として、
様々な~serverから検索取得される~HTML内容を具現化する~HTTP~UAを考える。
~UAの実装者は、
~UAが そのような文書に包含された~scriptを実行する際に，
悪意的な~serverから検索取得された~scriptが（例えば，~firewallの背後にある）正直な~serverに格納された文書を読取ることを防止するよう望むであろう。
◎
As an example, consider an HTTP user agent that renders HTML content retrieved from various servers. If the user agent executes scripts contained in those documents, the user agent implementor might wish to prevent scripts retrieved from a malicious server from reading documents stored on an honest server, which might, for example, be behind a firewall.
</p>

<p>
伝統的に，~UAは、
内容をその “生成元” に則って分け隔ててきた。
より特定的には、
~UAは［
同じ生成元から検索取得された 2 つの内容が互いにヤリトリする
］ことは自由に許容する一方で，［
異なる生成元から検索取得された 2 つの内容が 互いにどうヤリトリするか
］については制約する。
◎
Traditionally, user agents have divided content according to its "origin". More specifically, user agents allow content retrieved from one origin to interact freely with other content retrieved from that origin, but user agents restrict how that content can interact with content from another origin.
</p>

<p>
この文書は、
いわゆる同一-生成元~施策の背後にある原理について，および生成元を［
比較する／直列化する
］ための “基礎部品” について述べる。
この文書は、
同一-生成元~施策を成すすべての側面fを述べるものではない。
そういった詳細は、
応用に特有なことが多く，他の仕様
— ~HTML `HTML$r や WebSockets `RFC6455$r など —
に委ねられる。
◎
This document describes the principles behind the so-called same- origin policy as well as the "nuts and bolts" of comparing and serializing origins. This document does not describe all the facets of the same-origin policy, the details of which are left to other specifications, such as HTML [HTML] and WebSockets [RFC6455], because the details are often application-specific.
</p>

	</section>
	<section id="section-2">
<h2 title="Conventions">2. 表記規約</h2>

<h3>【この訳に特有な表記規約】</h3>

◎表記記号

		<section id="section-2.1">
<h3 title="Conformance Criteria">2.1. 適合性の判定基準</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
</p>

<p class="trans-note">【
以下、
この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#conformance-criteria$に移譲。
】</p>

		</section>
		<section id="section-2.2">
<h3 title="Syntax Notation">2.2. 構文の表記法</h3>

<p>
この仕様は `RFC5234$r による ABNF （ `Augmented Backus Naur Form^en ）記法を利用する。
◎
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234].
</p>

<p>
中核~規則［
`SP^P（ `space^en ）,
`HTAB^P,
`CRLF^P
］は、
`RFC5234$r `§ B.1＠~RFCx/rfc5234#appendix-B.1$
による定義を参照する。
◎
The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), HTAB (horizontal tab), CHAR (any US- ASCII character), VCHAR (any visible US-ASCII character), and WSP (whitespace).
</p>

<p>
`OWS^P 規則は、
0 個以上の空白~octetが~~連続して現れ得る所に利用される。
【以下、この段落の内容は，次の一文に集約する：】
`OWS^P は、
`~HTTPの規約＠~HTTPinfra#whitespace$に則って取扱うとする。
◎
The OWS rule is used where zero or more linear whitespace octets might appear. OWS SHOULD either not be produced or be produced as a single SP. Multiple OWS octets that occur within field-content SHOULD either be replaced with a single SP or transformed to all SP octets (each octet other than SP replaced with SP) before interpreting the field value or forwarding the message downstream.
◎
</p>

<pre class="bnf">
OWS
	= *( SP / HTAB / obs-fold )
	; "optional" whitespace
obs-fold
	= CRLF ( SP / HTAB )
	; obsolete line folding
</pre>

		</section>
		<section id="section-2.3">
<h3 title="Terminology">2.3. 各種用語</h3>

<p>
語 “~UA”, “~server” は、
`~HTTP仕様によるそれ＠~HTTPinfra#terminology$と同じ意味を表すとする。
【！ 未利用：~client／~proxy／生成元~server】
◎
The terms "user agent", "client", "server", "proxy", and "origin server" have the same meaning as in the HTTP/1.1 specification ([RFC2616], Section 1.3).
</p>

<p>
`~GUID@
（ `globally unique identifier^en, “大域的に一意な識別子” ）
は、
他のどの既存の値とも異なる値である。
十分長い~randomな文字列は、
ほぼ確実に~GUIDになる。
`If the origin value never leaves the user agent,^en
【~UAが生成元の値を決して忘れないならば？】、
~UAに局所的な単調増加する~counterでも，~GUIDとして~serveし得る。
◎
A globally unique identifier is a value that is different from all other previously existing values. For example, a sufficiently long random string is likely to be a globally unique identifier. If the origin value never leaves the user agent, a monotonically increasing counter local to the user agent can also serve as a globally unique identifier.
</p>

		</section>
	</section>
	<section id="section-3">
<h2 title="Principles of the Same-Origin Policy">3. 同一-生成元~施策の原理</h2>

<p>
多くの~UAは、
~remote主体に成り代わって動作を請負う。
例えば：
~HTTP~UAは、
~remote~serverから~~指示される~redirectに追従する。
~HTML~UAは、
~remote~serverから検索取得された~scriptに対し，文書~obj~model（ ~DOM ）~interfaceを公開する。
◎
Many user agents undertake actions on behalf of remote parties. For example, HTTP user agents follow redirects, which are instructions from remote servers, and HTML user agents expose rich Document Object Model (DOM) interfaces to scripts retrieved from remote servers.
</p>

<p>
~security~modelがなければ、
~UAは，利用者その他の主体にとって有害な動作も請負うかもしれない。
年月と伴に，~webに関係する多くの技術は、
通称 “同一-生成元~施策” として知られる，共通な~security~modelに収束してきた。
この［
同一-生成元~施策による~security~model
］は、
広く組織的に発展してきたものだが，一握りの~~主要な概念から理解できる。
この節では、
その概念を提示して，それを~secureに利用する方法について助言を供する。
◎
Without any security model, user agents might undertake actions detrimental to the user or to other parties. Over time, many web- related technologies have converged towards a common security model, known colloquially as the "same-origin policy". Although this security model evolved largely organically, the same-origin policy can be understood in terms of a handful of key concepts. This section presents those concepts and provides advice about how to use these concepts securely.
</p>

		<section id="section-3.1">
<h3 title="Trust">3.1. 信頼関係</h3>

<p>
同一-生成元~施策は、
~URIにより，信頼関係を指定する。
例えば，~HTML文書は、
どの~scriptを走らすかを~URIで指名する：
◎
The same-origin policy specifies trust by URI. For example, HTML documents designate which script to run with a URI:
</p>

<pre class="example lang-html">
&lt;script src="https://example.com/library.js"&gt;&lt;/script&gt;
</pre>

<p class="trans-note">【
指名-（ `designate^en ）：
普通は “~~指定” と対訳されるが、
“選定して~~役割をあてがう” 含みも込めて。
この和訳では
（この段落に限らず
— やや見慣れない表現になるかもしれないが）、
“`specify^en” を~~意味する~~指定との区別を優先する。
】</p>

<p>
~UAは、
この~protocol要素を処理する際に，［
その~URIにより指名された~scriptを~fetchして，
当の~scriptを文書が有する特権の下で実行する
］ことになる。
このようにして、
文書は，自身が有するすべての特権を~URIにより指名された資源に是認する。
本質的には、
文書は，［
その~URIから検索取得された情報の完全性を信用する
］ことを宣言している。
◎
When a user agent processes this element, the user agent will fetch the script at the designated URI and execute the script with the privileges of the document. In this way, the document grants all the privileges it has to the resource designated by the URI. In essence, the document declares that it trusts the integrity of information retrieved from that URI.
</p>

<p>
~URIから~library【~scriptなど】を取込むことに加えて、
~UAは，~URIにより指名された~remote主体へ向けて情報を送信する。
例えば、
~HTMLの `form^e 要素を考える：
◎
In addition to importing libraries from URIs, user agents also send information to remote parties designated by URI. For example, consider the HTML form element:
</p>

<pre class="example lang-html">
&lt;form method="POST" action="https://example.com/login"&gt;
 ... &lt;input type="password"&gt; ...
&lt;/form&gt;
</pre>

<p>
利用者が自身の~passwordを手入力して~formを提出するとき、
~UAは，その~URIにより指名された~network端点へ向けて~passwordを送信する。
このようにして、
文書は，自身の秘匿~dataをその~URIに開示する。
すなわち、［
その~URIへ向けて送信される情報の機密性を信用する
］ことを宣言する。
◎
When the user enters his or her password and submits the form, the user agent sends the password to the network endpoint designated by the URI. In this way, the document exports its secret data to that URI, in essence declaring that it trusts the confidentiality of information sent to that URI.
</p>

			<section id="section-3.1.1">
<h4 title="Pitfalls">3.1.1. 陥穽</h4>

<p>
同一-生成元~施策を利用する新たな~protocolを設計する際には、
重要な信用の区別が~URIにおいて必ず可視になるようにする必要がある。
例えば，［
~TLS（ `Transport Layer Security^en ）で保護される資源, そうでない資源
］がどちらも "`http^sc" ~URI~schemeを利用した場合（ `RFC2817$r のように）、
文書は，［
~TLS越しに限り，~scriptを検索取得する
］よう望むことを指定-不能になる。
"`https^sc" ~URI~schemeを利用することにより、
文書は，［
~network攻撃者から保護された資源とヤリトリする
］よう望むことを指示-可能になる。
◎
When designing new protocols that use the same-origin policy, make sure that important trust distinctions are visible in URIs. For example, if both Transport Layer Security (TLS) and non-TLS protected resources use the "http" URI scheme (as in [RFC2817]), a document would be unable to specify that it wishes to retrieve a script only over TLS. By using the "https" URI scheme, documents are able to indicate that they wish to interact with resources that are protected from active network attackers.
</p>

			</section>
		</section>
		<section id="section-3.2">
<h3 title="Origin">3.2. 生成元（ `origin^en ）</h3>

<p>
原理的には、
~UAがどの~URIも別々な保護~domainとして扱って，ある~URI, 別の~URIから検索取得された内容どうしがヤリトリすることに明示的な同意を要求することもできる。
あいにく、
~web応用は，~~協同して動作するいくつもの資源からなることが多いので、
この設計は開発者には厄介なものになる。
◎
In principle, user agents could treat every URI as a separate protection domain and require explicit consent for content retrieved from one URI to interact with another URI. Unfortunately, this design is cumbersome for developers because web applications often consist of a number of resources acting in concert.
</p>

<p>
代案として、
~UAは，~URIたちを “生成元” と呼ばれる保護~domainに~group分けする。
大雑把に言えば、
2 つの~URIは，互いに同じ［
~scheme, ~host, ~port
］を有するならば同じ生成元に属する
（すなわち，同じ首体を表現する）。
（全部的な詳細は `§ 4＠#section-4$ を見よ。）
◎
Instead, user agents group URIs together into protection domains called "origins". Roughly speaking, two URIs are part of the same origin (i.e., represent the same principal) if they have the same scheme, host, and port. (See Section 4 for full details.)
</p>

<p>
<b>Q</b>：
~host名だけ利用しても十分ではありませんか？
◎
Q: Why not just use the host?
</p>

<p>
<b>A</b>：
生成元に~schemeも含めることは、
~securityにとって本質的です。
~UAが~schemeを含めなかったなら、
`http://example.com^s
と
`https://example.com^s
は同じ~hostを有することになり，隔離されなくなります。
しかしながら，この隔離がなければ、
能動的な~network攻撃者は，
【 ~TLSなどにより保護されない，】
`http://example.com^s
から検索取得される内容に細工を施すことにより，その内容から
`https://example.com^s
から検索取得される内容の機密性と完全性を弱体化させる~~指示を~UAに出せてしまいます。
その結果、
~TLS `RFC5246$r に備わる保護は迂回されてしまいます。
◎
A: Including the scheme in the origin tuple is essential for security. If user agents did not include the scheme, there would be no isolation between http://example.com and https://example.com because the two have the same host. However, without this isolation, an active network attacker could corrupt content retrieved from http://example.com and have that content instruct the user agent to compromise the confidentiality and integrity of content retrieved from https://example.com, bypassing the protections afforded by TLS [RFC5246].
</p>

<p>
<b>Q</b>：
なぜ、
単に “~top-levelの” ~domainではなく，完全修飾~host名を利用するのですか？
◎
Q: Why use the fully qualified host name instead of just the "top-level" domain?
</p>

<p>
<b>A</b>：
~DNSは階層的な委任を備えていますが、
~host名どうしの信頼関係は、
配備状況により様々です。
例えば，多くの教育機関では、
学生たちは
`https://example.edu/~student/^s
の下に内容を~hostできますが、
一学生が作成した文書と
`https://grades.example.edu/^s
の下に~hostされている成績管理用の~web応用とが，同じ生成元に属する
（すなわち，同じ保護~domain下にある）
ことになるべきではないでしょう。
◎
A: Although the DNS has hierarchical delegation, the trust relationships between host names vary by deployment. For example, at many educational institutions, students can host content at https://example.edu/~student/, but that does not mean a document authored by a student should be part of the same origin (i.e., inhabit the same protection domain) as a web application for managing grades hosted at https://grades.example.edu/.
</p>

<p>
`example.edu^s の配備~例は、
生成元による資源の仕分けが，どの配備状況にも常に完璧に沿えるわけでないことを示してもいます。
この配備においては、
どの学生の~web~siteも同じ生成元に属するようになり，望ましくないかもしれません。
生成元の粒度は、
あるイミにおいて，~security~modelが発展する中で生じた歴史的な所産です。
◎
The example.edu deployment illustrates that grouping resources by origin does not always align perfectly with every deployment scenario. In this deployment, every student's web site inhabits the same origin, which might not be desirable. In some sense, the origin granularity is a historical artifact of how the security model evolved.
</p>

			<section id="section-3.2.1">
<h4 title="Examples">3.2.1. 例</h4>

<p>
次に挙げる資源の生成元は、
どれも同じになる：
◎
All of the following resources have the same origin:
</p>

<pre class="example">
http://example.com/
http://example.com:80/
http://example.com/path/file
</pre>

<p>
各~URIは、［
~scheme, ~host, ~port
］いずれの成分も，互いに同じなので。
【 `http^sc ~schemeの既定の~port番号は 80 と定められている。】
◎
Each of the URIs has the same scheme, host, and port components.
</p>

<p>
次に挙げる資源の生成元は、
どれも互いに異なる：
◎
Each of the following resources has a different origin from the others.
</p>

<pre class="example">
http://example.com/
http://example.com:8080/
http://www.example.com/
https://example.com:80/
https://example.com/
http://example.org/
http://ietf.org/
</pre>

<p>
どれも、
少なくとも［
~scheme, ~host, ~port
］いずれかの成分が，他のものと異なっている。
◎
In each case, at least one of the scheme, host, and port component will differ from the others in the list.
</p>

			</section>
		</section>
		<section id="section-3.3">
<h3 title="Authority">3.3. 権限</h3>

<p>
~UAは~URIを生成元により仕分けるが、
同じ生成元に属するどの資源も同じ権限（ “authority” — 
`RFC3986$r によるイミの “`authority^en”† ではなく，~securityのイミで）を有するとは限らない。
例えば，画像は受動的な内容なので、
何ら権限を有さない††。
すなわち，画像は、
その生成元にて可用な~objや資源へ~accessすることはない。
対して、
~HTML文書は，その生成元に対する全-権限を有し、
その文書~内の（またはその中に取込まれた）~scriptは，その生成元に属するどの資源にも~accessし得る。
◎
Although user agents group URIs into origins, not every resource in an origin carries the same authority (in the security sense of the word "authority", not in the [RFC3986] sense). For example, an image is passive content and, therefore, carries no authority, meaning the image has no access to the objects and resources available to its origin. By contrast, an HTML document carries the full authority of its origin, and scripts within (or imported into) the document can access every resource in its origin.
</p>

<p class="trans-note">【†
~URI構文の一部を成す `authority^P
】【††
同じ画像でも，~SVGのような~HTMLと同程度な能を有し得る画像は、
通常の画像と同程度に低~riskなものと見なすためには，その能動的な能を制約する必要があることになる。
】</p>

<p>
~UAは，資源の~MIME型（ `Internet media type^en ）を精査することにより、
資源に是認する権限の度合いを決定する。
例えば、
~MIME型 `image/png^s の資源は画像として扱われ，~MIME型 `text/html^s の資源は~HTML文書として扱われる。
◎
User agents determine how much authority to grant a resource by examining its media type. For example, resources with a media type of image/png are treated as images, and resources with a media type of text/html are treated as HTML documents.
</p>

<p>
~web応用は、
信用-済みでない内容（利用者により生成された内容など）を~hostする際に、
その~MIME型を制約することにより，内容の権限を制限できる。
例えば、
利用者により生成された内容を `image/png^s として~serveする~riskは， `text/html^s として~serveする~riskより小さい。
無論、
多くの~web応用は，信用-済みでない内容を自身の~HTML文書に組入れるが、
注意深く行わなければ，応用は［
自身の生成元の権限
］を信用-済みでない内容に漏洩する~riskにさらすことになる。
これは、
~XSS（ `cross-site scripting^en ）として共通的に知られる脆弱性である。
◎
When hosting untrusted content (such as user-generated content), web applications can limit that content's authority by restricting its media type. For example, serving user-generated content as image/png is less risky than serving user-generated content as text/html. Of course, many web applications incorporate untrusted content in their HTML documents. If not done carefully, these applications risk leaking their origin's authority to the untrusted content, a vulnerability commonly known as cross-site scripting.
</p>

			<section id="section-3.3.1">
<h4 title="Pitfalls">3.3.1. 陥穽</h4>

<p>
~web~platformを成す新たな部品を設計する際には、
その~MIME型が何であれ，当の部品を~serveする資源に権限を是認しないよう気を付けるべきである。
多くの~web応用は、
信用-済みでない内容を，限られた~MIME型に制約して~serveする。
~web~platformを成す新たな特能が，これらの内容を成す部品に権限を是認すると、
既存の応用に脆弱性を導入する~riskがある。
代わりに、［
すでに生成元に対する全-権限を有する~MIME型
］または［
新たな権限を有するよう特定的に設計された，新たな~MIME型
］に対し是認する方を選好すること。
◎
When designing new pieces of the web platform, be careful not to grant authority to resources irrespective of media type. Many web applications serve untrusted content with restricted media types. A new web platform feature that grants authority to these pieces of content risks introducing vulnerabilities into existing applications. Instead, prefer to grant authority to media types that already possess the origin's full authority or to new media types designed specifically to carry the new authority.
</p>

<p>
一部の~UAは、
【~HTTP~headerを通して】不正な~MIME型を~serveする~serverと互換であり続けるために，
“内容~sniff法” `SNIFF$r を使役して，その内容を［
~serverから給される~MIME型とは異なる~MIME型を有する
］かのように扱う。
“内容~sniff法” は、
注意深く行われなければ，~securityの脆弱性に至らせ得る。
なぜなら、
~UAは［
画像など，低~権限な~MIME型
］に［
~HTML文書など，高~権限な~MIME型
］の特権を是認することにもなりかねないからである。
◎
In order to remain compatible with servers that supply incorrect media types, some user agents employ "content sniffing" and treat content as if it had a different media type than the media type supplied by the server. If not done carefully, content sniffing can lead to security vulnerabilities because user agents might grant low-authority media types, such as images, the privileges of high-authority media types, such as HTML documents [SNIFF].
</p>

			</section>
		</section>
		<section id="section-3.4">
<h3 title="Policy">3.4. 施策</h3>

<p>
一般に，~UAは、
異なる生成元を隔離しつつ，生成元どうしの通信を制御される下で許可する。
~UAが隔離と通信をどう供するかについての詳細は、
いくつかの要因に依存して様々になる。
◎
Generally speaking, user agents isolate different origins and permit controlled communication between origins. The details of how user agents provide isolation and communication vary depending on several factors.
</p>

			<section id="section-3.4.1">
<h4 title="Object Access">3.4.1. ~obj~access</h4>

<p>
~UAにより公開されるほとんどの~obj
（ `application programming interfaces^en，略して~APIとも呼ばれる）
は、
同じ生成元に属する場合に限り可用になる。
特定的には、［
ある~URIから検索取得された内容
］が［
別の~URIから検索取得された内容に結付けられた~obj
］に~accessし得るのは，
2 つの~URIが同じ生成元に属するとき
— すなわち，互いの［
~scheme, ~host, ~port
］がどれも同じとき
— そのときに限られる。
◎
Most objects (also known as application programming interfaces or APIs) exposed by the user agent are available only to the same origin. Specifically, content retrieved from one URI can access objects associated with content retrieved from another URI if, and only if, the two URIs belong to the same origin, e.g., have the same scheme, host, and port.
</p>

<p>
この一般~規則には、
いくつか例外もある。
例えば，~HTMLの `Location^c ~interfaceの一部は、
生成元を超えて可用になる
（例：他の閲覧~文脈（ `browsing context^en ）を~navigateすることを許容するため）。
別の例として、
~HTMLの `postMessage^c ~interfaceは、
非同一-生成元な【 `cross-origin ^en, 異なる生成元どうしの】通信を手助けするために，生成元を超えて明示的に可視にされている。
外来な生成元に~objを公開することは、
そこに居る攻撃者にも当の~objを公開するので危険であり，細心な注意の下で行われるべきである。
◎
There are some exceptions to this general rule. For example, some parts of HTML's Location interface are available across origins (e.g., to allow for navigating other browsing contexts). As another example, HTML's postMessage interface is visible across origins explicitly to facilitate cross-origin communication. Exposing objects to foreign origins is dangerous and should be done only with great care because doing so exposes these objects to potential attackers.
</p>

			</section>
			<section id="section-3.4.2">
<h4 title="Network Access">3.4.2. ~network~access</h4>

<p>
~network資源への~accessの可否は、［
その資源は、
~accessを試みている内容と同じ生成元に属しているかどうか
］に依存する。
◎
Access to network resources varies depending on whether the resources are in the same origin as the content attempting to access them.
</p>

<p>
一般に、
別の生成元から情報を読取ることは禁止される。
しかしながら，一部の種類の資源を利用することは、
他の生成元から検索取得する場合でも許可される。
例えば生成元には、
どの生成元からの［
~scriptを実行する／画像を描画する／~stylesheetを適用する
］ことも許可されている†。
同様に生成元は、
別の生成元からの内容
— ~HTMLの~frame内の~HTML文書など —
を表示できる。
~network資源には、
他の生成元に自身の情報を読取らせる~opt-inを備えるものもある
— 例えば `Cross-Origin Resource Sharing^en `CORS$r を利用して。
これらの事例で~accessが是認されるかどうかは、
概して生成元ごとに基づく。
◎
Generally, reading information from another origin is forbidden. However, an origin is permitted to use some kinds of resources retrieved from other origins. For example, an origin is permitted to execute script, render images, and apply style sheets from any origin. Likewise, an origin can display content from another origin, such as an HTML document in an HTML frame. Network resources can also opt into letting other origins read their information, for example, using Cross-Origin Resource Sharing [CORS]. In these cases, access is typically granted on a per-origin basis.
</p>

<p class="trans-note">【†
この文書が書かれた頃までは
— 現在はもっと制約されている／
制約するための仕組みが数多く追加されている。
】</p>

<p>
別の生成元へ情報を送信することは許可されている。
しかしながら、
任意な形式による，~network越しの情報の送信は危険である。
この理由から，~UAは、
文書による情報の送信を，特定0の~protocol
— ~custom~headerが無い~HTTP要請など —
の利用-時に限るように制約している。
許容される~protocolの集合を拡大することは
— 例えば、
 WebSockets `RFC6455$r 用の~supportを追加するなど — 
脆弱性が導入されないよう，注意深く行われなければならない。
◎
Sending information to another origin is permitted. However, sending information over the network in arbitrary formats is dangerous. For this reason, user agents restrict documents to sending information using particular protocols, such as in an HTTP request without custom headers. Expanding the set of allowed protocols, for example, by adding support for WebSockets, must be done carefully to avoid introducing vulnerabilities [RFC6455].
</p>

			</section>
			<section id="section-3.4.3">
<h4 title="Pitfalls">3.4.3. 陥穽</h4>

<p>
~UAが［
異なる生成元に属する資源~間でヤリトリを許容する
］ことは、
~securityの課題を招く。
例えば、
別の生成元からの画像を表示する能は，その縦幅や横幅を漏洩する。
同様に、
別の生成元へ~network要請を送信する能は，
`CSRF$r
【 `cross-site request forgery^en — ~site（生成元）をまたがる要請の偽造】
の脆弱性をもたらし得る。
しかしながら、
~UAの実装者は，これらの~riskと［
非同一-生成元なヤリトリを許容することで得られる便益
］との兼合いをとることが多い。
例えば，~HTML~UAが非同一-生成元な~network要請を阻止すると、
利用者は［
~webの中核を成す特能である~hyperlink
］を追えなくなってしまう。
◎
Whenever user agents allow one origin to interact with resources from another origin, they invite security issues. For example, the ability to display images from another origin leaks their height and width. Similarly, the ability to send network requests to another origin gives rise to cross-site request forgery vulnerabilities [CSRF]. However, user agent implementors often balance these risks against the benefits of allowing the cross-origin interaction. For example, an HTML user agent that blocked cross-origin network requests would prevent its users from following hyperlinks, a core feature of the web.
</p>

<p>
~web~platformに新たな機能性を追加する際には、
一方の資源に特権を是認しつつ，
同じ生成元に属する別の資源に対してはその特権を差止めれば良さそうに見える。
しかしながら、
このような方法で特権を差止めても，~UAは同じ生成元に属する資源を隔離しないので、
特権がない資源も結局は通例的に特権を得ることになり，効果的でない。
代わりに，特権は、
（生成元に属する個々の資源ごとに~~区分するのでなく）
一つの生成元に総体として是認するか差止めるべきである
`BOFGO$r
。
◎
When adding new functionality to the web platform, it can be tempting to grant a privilege to one resource but to withhold that privilege from another resource in the same origin. However, withholding privileges in this way is ineffective because the resource without the privilege can usually obtain the privilege anyway because user agents do not isolate resources within an origin. Instead, privileges should be granted or withheld from origins as a whole (rather than discriminating between individual resources within an origin) [BOFGO].
</p>

			</section>
		</section>
		<section id="section-3.5">
<h3 title="Conclusion">3.5. ~~要約</h3>

<p>
同一-生成元~施策は、
~URIを利用して信頼関係を指名する。
~URIたちは、
生成元ごとに~group分けされ，保護~domainを表現する。
ある生成元に属する資源のうち、
一部（例：能動的な内容）には当の生成元の全-権限が是認される一方で，
他のもの（例：受動的な内容）には当の生成元の権限は是認されない。
ある生成元の権限を有する内容は、
当の生成元に属する［
~obj／~network資源
］への~accessが是認される。
この内容には，他の生成元に属する［
~obj／~network資源
］への制限された~accessも是認されるが、
そのような非同一-生成元な特権は，~security脆弱性を避けるよう注意深く設計されなければならない。
◎
The same-origin policy uses URIs to designate trust relationships. URIs are grouped together into origins, which represent protection domains. Some resources in an origin (e.g., active content) are granted the origin's full authority, whereas other resources in the origin (e.g., passive content) are not granted the origin's authority. Content that carries its origin's authority is granted access to objects and network resources within its own origin. This content is also granted limited access to objects and network resources of other origins, but these cross-origin privileges must be designed carefully to avoid security vulnerabilities.
</p>

		</section>
	</section>
	<section id="section-4">
<h2 title="Origin of a URI">4. ~URIの生成元</h2>

<p>
所与の~URI %~URI の生成元は、
次の~algoにより算出される：
◎
The origin of a URI is the value computed by the following algorithm:
</p>
<ol>
	<li>
<p>
~IF［
%~URI は命名機関（ `naming authority^en ）として階層的な~protocol要素を利用していない
（ `RFC3986$r `§ 3.2＠~RFCx/rfc3986#section-3.2$ を見よ）
］~OR［
%~URI は絶対~URIでない
］
⇒
~RET 新規に生成される`~GUID$
<!-- 
https://docs.oracle.com/cd/E13212_01/wles/docs42/programmersguide/namingauth.html
 -->
◎
1. If the URI does not use a hierarchical element as a naming authority (see [RFC3986], Section 3.2) or if the URI is not an absolute URI, then generate a fresh globally unique identifier and return that value.
</p>

<p class="note">注記：
この~algoは、
同じ~URIに対し複数回~走らせた場合，回ごとに異なる値を生成し得る。
概して，~UAは、
生成元を
— 例えば，~HTML文書の生成元を —
各~security検査ごとに算出し直すのでなく，一度だけ算出して、
後続な~security検査にその生成元を利用する。
◎
NOTE: Running this algorithm multiple times for the same URI can produce different values each time. Typically, user agents compute the origin of, for example, an HTML document once and use that origin for subsequent security checks rather than recomputing the origin for each security check.
</p>
	</li>
	<li>
%~URI~scheme ~LET %~URI の~scheme成分を小文字~化した結果
◎
2. Let uri-scheme be the scheme component of the URI, converted to lowercase.
</li>
	<li>
%~protocol ~LET %~URI~scheme で与えられる~protocol
◎
↓</li>
	<li>
~IF［
実装は %~protocol を~supportしない
］
⇒
~RET 新規に生成される`~GUID$
◎
3. If the implementation doesn't support the protocol given by uri- scheme, then generate a fresh globally unique identifier and return that value.
</li>
	<li>
<p>
~IF［
%~URI~scheme ~EQ "`file^sc"
］
⇒
<em class="rfc2119">任意選択で</em>
⇒
~RET 実装定義な値
◎
4. If uri-scheme is "file", the implementation MAY return an implementation-defined value.
</p>

<p class="note">注記：
歴史的に、
~UAは `file^sc ~schemeからの内容に過大な特権を是認してきた。
しかしながら、
すべての局所~fileにそのような広範な特権を是認することは、
段階的な特権~拡大~攻撃につながるおそれがある。
局所~file~directoryに基づいて特権を是認することにより成功を得た~UAも中にはあるが、
この~approachは広く採用されてはいない。
別の~UAは、
各 "`file^sc" ~URIごとに`~GUID$をあてがう。
これは、
最も~secureな~optionである。
◎
NOTE: Historically, user agents have granted content from the file scheme a tremendous amount of privilege. However, granting all local files such wide privileges can lead to privilege escalation attacks. Some user agents have had success granting local files directory-based privileges, but this approach has not been widely adopted. Other user agents use globally unique identifiers for each file URI, which is the most secure option.
</p>
	</li>
	<li>
<p>
%~URI~host ~LET %~URI の~host成分を（ `RFC4790$r にて定義される i;ascii-casemap 照合を利用して）小文字~化した結果
◎
5. Let uri-host be the host component of the URI, converted to lower case (using the i;ascii-casemap collation defined in [RFC4790]).
</p>

<p class="note">注記：
この文書は、
~UAが~URIを構築するにあたり，~IDNA（
`Internationalized Domain Names in Applications^en
— 応用における国際-化~domain名）の処理と妥当性検証を遂行するものと見做している。
特に，この文書は、
%~URI~host が LDH ~labelのみを包含するものと見做している
— ~UAはどの非~ASCII~labelも，対応する A-label に変換-済みにすることになるので（ `RFC5890$r を見よ）。
この理由から、
生成元に基づく~security施策は， ~UAに使役されている~IDNA~algoに敏感である。
更なる論点は、
`§ 8.4＠#section-8.4$ を見よ。
◎
NOTE: This document assumes that the user agent performs Internationalizing Domain Names in Applications (IDNA) processing and validation when constructing the URI. In particular, this document assumes the uri-host will contain only LDH labels because the user agent will have already converted any non-ASCII labels to their corresponding A-labels (see [RFC5890]). For this reason, origin-based security policies are sensitive to the IDNA algorithm employed by the user agent. See Section 8.4 for further discussion.
</p>
	</li>
	<li>
%~URI~port ~LET %~URI に~port成分は［
在るならば それ【が表現する整数】 ／
無いならば %~protocol 用の既定~port
］
◎
6. If there is no port component of the URI:
• 1. Let uri-port be the default port for the protocol given by uri-scheme.
Otherwise:
• Let uri-port be the port component of the URI.
</li>
	<li>
~RET ( %~URI~scheme, %~URI~host, %~URI~port )
◎
7. Return the triple (uri-scheme, uri-host, uri-port).
</li>
</ol>

	</section>
	<section id="section-5">
<h2 title="Comparing Origins">5. 生成元の比較-法</h2>

<p>
2 つの生成元が “同じ” であるとは、
それらが一致することを言う。
特に：
◎
Two origins are "the same" if, and only if, they are identical. In particular:
</p>
<ul>
	<li>
どちらの生成元も
`成分組~生成元@
— ( ~scheme, ~host, ~port )
の組が成す生成元 —
である場合、
互いの［
~scheme, ~host, ~port
］が いずれも一致するとき, そのときに限り，同じとされる。
◎
If the two origins are scheme/host/port triples, the two origins are the same if, and only if, they have identical schemes, hosts, and ports.
</li>
	<li>
`~GUID$である生成元は、
`成分組~生成元$と同じにはなり得ない。
◎
An origin that is a globally unique identifier cannot be the same as an origin that is a scheme/host/port triple.
</li>
</ul>

<p class="trans-note">【
`~HTMLが定義する生成元＠~ORIGIN#concept-origin-tuple$には、
~web~platformに特有な~security~modelに因り， “~domain” 成分も追加されている
— ~web~platformにおいては、
一般に，それが利用される。
】</p>

<p>
2 つの~URIは、
互いの生成元が同じであるとき， “同一-生成元（ `same-origin^en ）” と呼ばれる。
◎
Two URIs are same-origin if their origins are the same.
</p>

<p class="note">注記：
~URIは、
自身と同じ生成元になるとは限らない。
例えば， `data^sc ~URI `RFC2397$r は、
~serverに基づく命名機関を利用しないので，生成元として`~GUID$を有する
— その生成元は自身と同じにならない。
【~URIから生成元を算出する度に，異なる~GUIDが返される。】
◎
NOTE: A URI is not necessarily same-origin with itself. For example, a data URI [RFC2397] is not same-origin with itself because data URIs do not use a server-based naming authority and therefore have globally unique identifiers as origins.
</p>

	</section>
	<section id="section-6">
<h2 title="Serializing Origins">6. 生成元の直列化-法</h2>

<p>
この節では、
生成元を~Unicode `Unicode6$r 文字列に直列化する方法, および~ASCII `RFC20$r 文字列に直列化する方法を定義する。
◎
This section defines how to serialize an origin to a unicode [Unicode6] string and to an ASCII [RFC20] string.
</p>

		<section id="section-6.1">
<h3 title="Unicode Serialization of an Origin">6.1. 生成元の~Unicode直列化</h3>

<p>
所与の生成元 %生成元 の~Unicode直列化とは、
次の~algoが返す値である：
◎
The unicode-serialization of an origin is the value returned by the following algorithm:
</p>

<ol>
	<li>
<p>
~IF［
%生成元 は`成分組~生成元$である
］：
</p>
		<ol>
			<li>
%生成元 ~SET %生成元 の複製；
</li>
			<li>
%生成元 の~host成分 ~SET %生成元 の~host成分を［
それを成す各~成分のうち， A-label を与えるもの
］を対応する U-label に~~置換した結果
</li>
		</ol>
◎
↓</li>
	<li>
~RET %生成元 の~ASCII直列化（次節）
【この訳では、~ASCII直列化を利用して，原文の記述を簡略化する】
◎
1. If the origin is not a scheme/host/port triple, then return the string null (i.e., the code point sequence U+006E, U+0075, U+006C, U+006C) and abort these steps.
◎
2. Otherwise, let result be the scheme part of the origin triple.
◎
3. Append the string "://" to result.
◎
4. Append each component of the host part of the origin triple (converted as follows) to the result, separated by U+002E FULL STOP code points ("."):
• 1. If the component is an A-label, use the corresponding U-label instead (see [RFC5890] and [RFC5891]).
• 2. Otherwise, use the component verbatim.
◎
5. If the port part of the origin triple is different from the default port for the protocol given by the scheme part of the origin triple:
• 1. Append a U+003A COLON code point (":") and the given port, in base ten, to result.
◎
6. Return result.
</li>
</ol>

		</section>
		<section id="section-6.2">
<h3 title="ASCII Serialization of an Origin">6.2. 生成元の~ASCII直列化</h3>

<p>
所与の生成元 %生成元 の~ASCII直列化とは、
次の~algoが返す値である：
◎
The ascii-serialization of an origin is the value returned by the following algorithm:
</p>
<ol>
	<li>
~IF［
%生成元 は`成分組~生成元$でない
］
⇒
~RET 文字列 `null^c
（すなわち，符号位置~並び `006E^U, `0075^U, `006C^U, `006C^U ）
◎
1. If the origin is not a scheme/host/port triple, then return the string null (i.e., the code point sequence U+006E, U+0075, U+006C, U+006C) and abort these steps.
</li>
	<li>
( %~scheme, %~host, %~port ) ~LET %生成元 の ( ~scheme, ~host, ~port ) 成分
◎
↓</li>
	<li>
%結果 ~LET %~scheme
◎
2. Otherwise, let result be the scheme part of the origin triple.
</li>
	<li>
%結果 に［
文字列 "`://^c"
］を付加する
◎
3. Append the string "://" to result.
</li>
	<li>
%結果 に %~host を付加する
◎
4. Append the host part of the origin triple to result.
</li>
	<li>
~IF［
%~port は %~scheme で与えられる~protocol用の既定~portでない
］
⇒
%結果 に次を順に付加する
⇒＃
符号位置 `003A^U COLON（ "`:^c" ）,
%~port の十進表記
◎
5. If the port part of the origin triple is different from the default port for the protocol given by the scheme part of the origin triple:
• 1. Append a U+003A COLON code point (":") and the given port, in base ten, to result.
</li>
	<li>
~RET %結果
◎
2. Return result.
</li>
</ol>

		</section>
	</section>
	<section id="section-7">
<h2 title="The HTTP Origin Header Field">7. ~HTTP `Origin^h ~header</h2>

<p>
この節では、
~HTTP `Origin^h ~headerを定義する。
◎
This section defines the HTTP Origin header field.
</p>

		<section id="section-7.1">
<h3 title="Syntax">7.1. 構文</h3>

<p>
`Origin^h ~headerの構文は：
◎
The Origin header field has the following syntax:
</p>

<pre class="bnf">
origin
	= "Origin:" OWS origin-list-or-null OWS
origin-list-or-null
	= `%x6E %x75 %x6C %x6C^_ / origin-list
origin-list
	= serialized-origin *( SP serialized-origin )
serialized-origin
	= scheme "://" host [ ":" port ]
</pre>

<p>
`scheme^P, `host^P, `port^P は `RFC3986$r に定義される。
◎
; &lt;scheme&gt;, &lt;host&gt;, &lt;port&gt; from RFC 3986
</p>

<p class="trans-note">【
この構文では，~header値は複数個の生成元を内包し得るが、
~web~platformにおいては， 1 個に限るように`制約される＠~FETCH#origin-header$。
したがって、
以下の § 7.2, § 7.3 の記述は，実質的には もっと単純になるであろう。
】</p>

		</section>
		<section id="section-7.2">
<h3 title="Semantics">7.2. 意味論</h3>

<p>
~HTTP要請に内包される `Origin^h ~headerは、
~UAに要請を発行- “させる” よう（~UAが~~供する~APIの定義に従って）誘発した生成元（たち）を指示する。
◎
When included in an HTTP request, the Origin header field indicates the origin(s) that "caused" the user agent to issue the request, as defined by the API that triggered the user agent to issue the request.
</p>

<p>
例えば、
ある生成元（たち）に利する~scriptを実行する~UAを考える。
そのような~scriptが，~UAに~HTTP要請を発行させたときは、
~UAは
`Origin^h ~headerを利用して，~scriptを実行している~security文脈を~serverに伝えてもヨイ。
◎
For example, consider a user agent that executes scripts on behalf of origins. If one of those scripts causes the user agent to issue an HTTP request, the user agent MAY use the Origin header field to inform the server of the security context in which the script was executing when it caused the user agent to issue the request.
</p>

<p>
事例によっては、
複数の生成元が寄与して，~UAに~HTTP要請を発行させることもある。
そのような事例では、
~UAは `Origin^h ~header内にそれらの生成元すべてを~listしてもヨイ†。
例えば、
初期~時は ある生成元により~HTTP要請が発行されていて，後で別の生成元により~redirectされた場合、
~UAは，自身に要請を発行させた生成元が 2 つ孕まれていることを~serverに伝えてもヨイ。
【† 次節最後の要件も考慮するなら，寄与した順序も有意とされるかもしれない。】
◎
In some cases, a number of origins contribute to causing the user agents to issue an HTTP request. In those cases, the user agent MAY list all the origins in the Origin header field. For example, if the HTTP request was initially issued by one origin but then later redirected by another origin, the user agent MAY inform the server that two origins were involved in causing the user agent to issue the request.
</p>

		</section>
		<section id="section-7.3">
<h3 title="User Agent Requirements">7.3. ~UAに課される要件</h3>

<p>
~UAは、
どの~HTTP要請にも `Origin^h ~headerを内包してもヨイ。
◎
The user agent MAY include an Origin header field in any HTTP request.
</p>

<p>
~UAは、
どの~HTTP要請にも複数個の `Origin^h ~headerを内包してはナラナイ。
◎
The user agent MUST NOT include more than one Origin header field in any HTTP request.
</p>

<p>
~UAは、
“~privacyに敏感な” 文脈から~HTTP要請を発行するときは，
常に `Origin^h ~header内には値 “`null^c” を送信しなければナラナイ。
◎
Whenever a user agent issues an HTTP request from a "privacy- sensitive" context, the user agent MUST send the value "null" in the Origin header field.
</p>

<p class="note">注記：
この文書は、
何が “~privacyに敏感な文脈” の観念を成すかを定義しない。
~HTTP要請を生成する応用は、
文脈を~privacyに敏感であるものと指名して，
~UAが `Origin^h ~headerを生成する方法に制約を課せる。
◎
NOTE: This document does not define the notion of a privacy- sensitive context. Applications that generate HTTP requests can designate contexts as privacy-sensitive to impose restrictions on how user agents generate Origin header fields.
</p>

<p>
~UAは、
`Origin^h ~headerを生成するときには，次に挙げる要件に従わなければナラナイ。
◎
When generating an Origin header field, the user agent MUST meet the following requirements:
</p>
<ul>
	<li>
その文法~内の `serialized-origin^P 生成規則は、
ある生成元の~ASCII直列化を成していなければナラナイ。
◎
Each of the serialized-origin productions in the grammar MUST be the ascii-serialization of an origin.
</li>
	<li>
連続するどの 2 つの生成結果も，一致することはない。
特に，~UAが【同じ？】生成結果を連続して生成することになる場合、
2 個目を生成してはナラナイ。
◎
No two consecutive serialized-origin productions in the grammar can be identical. In particular, if the user agent would generate two consecutive serialized-origins, the user agent MUST NOT generate the second one.
</li>
</ul>

		</section>
	</section>
	<section id="section-8">
<h2 title="Security Considerations">8. ~securityの考慮点</h2>

<p>
同一-生成元~施策は、
~web~browserを含む多くの~UAにとり，~securityの根幹を成す一つである。
歴史的に、
一部の~UAは `taint tracking^en †や `exfiltration^en ††の防止を含む他の~security~modelを試してきたが、
それらの~modelは当時においては，実装が困難であることが判明した
（最近になって、
これらのうちの一部の~ideaの復活に関心が呼ばれつつあるが）。
◎
The same-origin policy is one of the cornerstones of security for many user agents, including web browsers. Historically, some user agents tried other security models, including taint tracking and exfiltration prevention, but those models proved difficult to implement at the time (although there has been recent interest in reviving some of these ideas).
</p>

<p class="trans-note">【†
外からの（安全でないかもしれない）入力には、
何かに “染まっている（ `tainted^en ）” ことを指示する
 “標識” を付け，追跡する（ `tracking^en ）。
】【††
内部から外部へ “裏口” から~dataを転送する。
】</p>

<p>
同一-生成元~施策の~securityを評価することは、
生成元の概念~自体が~security~~全般における中心的な役割を占めているため，【他との比較は】困難である。
生成元は、
観念としては単なる隔離単位でしかなく，万能ではない。
それには、
以下に論じられる，ある種の体系的な弱点がある。
◎
Evaluating the security of the same-origin policy is difficult because the origin concept itself plays such a central role in the security landscape. The notional origin itself is just a unit of isolation, imperfect as are most one-size-fits-all notions. That said, there are some systemic weaknesses, discussed below.
</p>

		<section id="section-8.1">
<h3 title="Reliance on DNS">8.1. ~DNSへの依拠</h3>

<p>
実施においては、
共通的に利用される~URI~scheme
— `http^sc など —
の多くが~DNS（ `Domain Name System^en ）に基づく命名機関を利用しているので、
同一-生成元~施策の~securityは，~DNSに依拠することになる。
~DNSが部分的にでも弱体化された場合、
同一-生成元~施策は，応用が要求する~securityの特質を満たせなくなるであろう。
◎
In practice, the same-origin policy relies upon the Domain Name System (DNS) for security because many commonly used URI schemes, such as http, use DNS-based naming authorities. If the DNS is partially or fully compromised, the same-origin policy might fail to provide the security properties required by applications.
</p>

<p>
一部の~URI~scheme
— `https^sc など —
は、
~UAが，他の仕組み
— 証明書など —
を使役して［
これらの~URIから検索取得された内容の~sourceを検証yする
］ので、
~DNS汚染に対し，より抵抗力がある。
他の~URI~schemeには、
公開鍵に基づく命名機関を利用するもの
— `chrome-extension^sc ~URI~scheme（ `CRX$r § 4.3 を見よ）など —
もあり，~DNS汚染に対し全部的に~secureである。
◎
Some URI schemes, such as https, are more resistant to DNS compromise because user agents employ other mechanisms, such as certificates, to verify the source of content retrieved from these URIs. Other URI schemes, such as the chrome-extension URI scheme (see Section 4.3 of [CRX]), use a public-key-based naming authority and are fully secure against DNS compromise.
</p>

<p>
~web生成元の概念は、
異なる~URI~schemeから検索取得された内容を隔離する。
これは、
~DNS汚染による効果を一定範囲に封じ込めることに本質的である。
◎
The web origin concept isolates content retrieved from different URI schemes; this is essential to containing the effects of DNS compromise.
</p>

		</section>
		<section id="section-8.2">
<h3 title="Divergent Units of Isolation">8.2. 隔離単位の分岐</h3>

<p>
これまで，いくつもの技術が、
簡便な隔離単位として，~web生成元の概念に収束してきた。
しかしながら、
現代の~web生成元の概念に先行して，多くの技術
— ~cookie `RFC6265$r など —
が今も利用-中にある。
これらの技術における隔離単位は、
生成元と異なることが多いため，脆弱性に至らせている。
◎
Over time, a number of technologies have converged on the web origin concept as a convenient unit of isolation. However, many technologies in use today, such as cookies [RFC6265], pre-date the modern web origin concept. These technologies often have different isolation units, leading to vulnerabilities.
</p>

<p>
代替として、
隔離単位に FQDN（ `fully qualified domain name^en, 完全修飾~domain名）ではなく，
“登録制（ `registry-controlled^en ）” による~domainのみを利用することも挙げられるが
（例： "`www.example.com^s" の代わりに "`example.com^s" ）、
この実施は いくつもの理由から問題になり得るため，<em class="rfc2119">推奨されない</em>：
◎
One alternative is to use only the "registry-controlled" domain rather than the fully qualified domain name as the unit of isolation (e.g., "example.com" instead of "www.example.com"). This practice is problematic for a number of reasons and is NOT RECOMMENDED:
</p>

<ol>
	<li>
“登録制” ~domainは，観念としては、
~DNS自体の特質ではなく，~DNSを取り巻くヒトによる実施が成す機能になる。
例えば、
日本における多数の地方自治体の公共~registryは，極めて深い~DNS階層で~~運用されている。
広く利用されている “公共~接尾辞~list（ `public suffix lists^en ）” があるが、
これらの~listを各~実装が揃って最新状態に保つことは困難である。
◎
1. The notion of a "registry-controlled" domain is a function of human practice surrounding the DNS rather than a property of the DNS itself. For example, many municipalities in Japan run public registries quite deep in the DNS hierarchy. There are widely used "public suffix lists", but these lists are difficult to keep up to date and vary between implementations.
</li>
	<li>
この実施は、
~DNSに基づく命名機関を利用しない~URI~schemeと互換でない。
例えば，命名機関として公開鍵を利用する~URI~schemeの場合、
“登録制” 公開鍵の観念は，どこかに不整合を~~孕む。
加えて，
~URI~schemeには、
`nntp^sc など，委任関係に~DNSとは逆順な~dot区切りを利用するもの
（例： `alt.usenet.kooks^s ）も，
~DNSを利用するが通例とは逆順に~labelを提示するもの
（例： `com.example.www^s ）
もある。
◎
2. This practice is incompatible with URI schemes that do not use a DNS-based naming authority. For example, if a given URI scheme uses public keys as naming authorities, the notion of a "registry-controlled" public key is somewhat incoherent. Worse, some URI schemes, such as nntp, use dotted delegation in the opposite direction from DNS (e.g., alt.usenet.kooks), and others use the DNS but present the labels in the reverse of the usual order (e.g., com.example.www).
</li>
</ol>

<p>
“登録制” ~domainを利用することは、
良くても~URI~schemeと実装に特有である。
最悪な場合、
~URI~schemeと実装との相違点から脆弱性に至らせ得る。
◎
At best, using "registry-controlled" domains is URI-scheme- and implementation-specific. At worst, differences between URI schemes and implementations can lead to vulnerabilities.
</p>

		</section>
		<section id="section-8.3">
<h3 title="Ambient Authority">8.3. ~ambient権限</h3>

<p>
同一-生成元~施策が利用される下では、
~UAは，内容に対し［
それは，どの~objを指名し得るかではなく，その~URI
］に基づいて権限を是認する。
この［
指名が権限から絶たれること
］は、
~ambient権限の一例であり，脆弱性に至らせ得る。
◎
When using the same-origin policy, user agents grant authority to content based on its URI rather than based on which objects the content can designate. This disentangling of designation from authority is an example of ambient authority and can lead to vulnerabilities.
</p>

<p class="trans-note">【
~ambient権限：
環境から暗黙的に与えられる権限
— `参考＠https://en.wikipedia.org/wiki/Ambient_authority$
】</p>

<p>
例えば~HTML文書における~XSSを考える。
攻撃者が~HTML文書~内に~script内容を注入できたなら、［
それらの~scriptは，文書の生成元の権限を有する下で走る
］ことになり，たぶん［
敏感な情報
— 利用者の医療記録など —
への~script~accessが許容される
］ことになる。
しかしながら，［
~scriptの権限が，~scriptが指名し得る~objに制限される
］ならば、攻撃者が［
第三者-主体に~hostされている~HTML文書に~scriptを注入する
］ことで優位を得ることもなくなろう。
◎
Consider, for example, cross-site scripting in HTML documents. If an attacker can inject script content into an HTML document, those scripts will run with the authority of the document's origin, perhaps allowing the script access to sensitive information, such as the user's medical records. If, however, the script's authority were limited to those objects that the script could designate, the attacker would not gain any advantage by injecting the script into an HTML document hosted by a third party.
</p>

		</section>
		<section id="section-8.4">
<h3 title="IDNA Dependency and Migration">8.4. ~IDNAへの依存とその移行</h3>

<p>
同一-生成元~施策の~securityの特質は、
~UAに使役されている~IDNA~algoの詳細~に不可欠に依存し得る。
特に，一部の国際-化~domain名（例えば `00DF^U 文字を含むもの ）については、
~UAが［
IDNA2003 `RFC3490$r, IDNA2008 `RFC5890$r
］のどちらを利用しているかに依存して，異なる~ASCII表現に対応付けられ得る。
◎
The security properties of the same-origin policy can depend crucially on details of the IDNA algorithm employed by the user agent. In particular, a user agent might map some international domain names (for example, those involving the U+00DF character) to different ASCII representations depending on whether the user agent uses IDNA2003 [RFC3490] or IDNA2008 [RFC5890].
</p>

<p>
~IDNA~algoを別のものへ移行すると、
いくつかの~security境界を描直すかもしれない：
新たな~security境界を敷いたり、
もっと悪いことに，互いに信用できない複数の実体~間の~security境界を取り払ってしまうなど。
特に後者の場合，一方が他方を攻撃することが許容されるので、
~security境界を変更することには~riskを伴う。
◎
Migrating from one IDNA algorithm to another might redraw a number of security boundaries, potentially erecting new security boundaries or, worse, tearing down security boundaries between two mutually distrusting entities. Changing security boundaries is risky because combining two mutually distrusting entities into the same origin might allow one to attack the other.
</p>

		</section>
	</section>
	<section id="section-9">
<h2 title="IANA Considerations">9. IANA Considerations</h2>

<p>
恒久的~message~header~registry（ `RFC3864$r を見よ）は、
次の登録で更新された：
◎
The permanent message header field registry (see [RFC3864]) has been updated with the following registration:
</p>

<table><tbody>

<tr><th>
~header名
◎
Header field name
<td>`Origin^h

<tr><th>
適用-可能な~protocol
◎
Applicable protocol
<td>http

<tr><th>
位置付け
◎
Status
<td>standard

<tr><th>
著作者／変更~制御者
◎
Author/Change controller
<td>IETF

<tr><th>
仕様~文書
◎
Specification document(s)
<td>
この仕様（ `§ 7＠#section-7$ ）
</table>

	</section>
	<section id="appendix-A">
<h2 title="Appendix A. Acknowledgements">Appendix A. 謝辞</h2>

<p>
この文書への貴重な~feedbackを寄せられた次の方々に：
◎
We would like to thank
</p>

<p lang="en">
Lucas Adamski, Stephen Farrell, Miguel A. Garcia, Tobias Gondrom, Ian Hickson, Anne van Kesteren, Jeff Hodges, Collin Jackson, Larry Masinter, Alexey Melnikov, Mark Nottingham, Julian Reschke, Peter Saint-Andre, Jonas Sicking, Sid Stamm, Daniel Veditz, and Chris Weber for their valuable feedback on this document.
</p>

	</section>
</main></div>
