<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Media Queries Level 4 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>
dl.changes > dd {
	display: list-item;
}
</style>

<style>
@namespace svg url(http://www.w3.org/2000/svg);

svg|svg {
	background-color:hsl(30,20%,95%);
}
svg|path{
	stroke-width:3;
	stroke:black;
	fill:rgba(0,0,0,0);
}
svg|text{
	font:bold 14px monospace;
	text-anchor:middle;
}
svg|text.label{
	text-anchor:start;
}
svg|text.comment{
	font:italic 12px monospace;
}
svg|rect{
	stroke-width:3;
	stroke:black;
	fill:hsl(120,100%,90%);
}

.event-type {
	color: purple;
}

</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}


function expand(){
	const link_map = this.link_map;
	const class_map = {
		d: 'descriptor',
		p: 'property',
		at: 'at-rule',
		u: 'unit',
		prod: 'production',
		v: 'value',
		vm: 'value',
		f: 'func',
		t: 'type',
		e: 'element',
		a: 'attr',
		et: 'event-type',
		css: 'css'
	}

	const tag_map = {
		d: 'code',
		p: 'code',
		at: 'code',
		u: 'code',
		prod: 'var',
		v: 'code',
		vm: 'code',
		I: 'code',
		m: 'code',
		f: 'func',
		e: 'code',
		a: 'code',
		c: 'code',
		et: 'code',
		t: 'var',
		V: 'var',
		css: 'code'
	}

	let context_desc = '';

	return this.html.replace(
		/`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 't': // types
	href = '#typedef-' + key;
	text = '&lt;' + text + '&gt;';
	break;
case 'd': // descripter
	href = '#descdef-media-' + key;
	if(indicator === '@'){
		context_desc = '#valdef-media-' + key + '-'
	}
	break;
case 'v': // value
	href = context_desc + key;
	break;
case 'vm':
	href = '#valdef-media-' + key;
	break;
case 'at': //
	href = '#at-ruledef-' + key;
	text = '@' + text;
	break;
}

if(tag) {
	text = '<' + tag +
		(classname ? ' class="' + classname + '">' : '>') +
		text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;
	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Media Queries Level 4
spec_date:2018-07-01
trans_update:2018-07-23
source_checked:180616
page_state_key:CSS
original_url:https://drafts.csswg.org/mediaqueries-4/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2018,permissive
trans_1st_pub:2015-01-22


●●original_id_map


mq-plain-context:
plain-context:
testing-value:
real-value:
zero-value:

range-type:
discrete-type:
range-form:
plain-form:
boolean-form:


●●link_map



真偽~文脈:#boolean-context
素~文脈:#plain-context
範囲~文脈:#range-context
範囲:#range-type
範囲~型:#range-type
離散:#discrete-type
離散~型:#discrete-type
素~形:#plain-form
真偽~形:#boolean-form
範囲~形:#range-form
媒体~特能:#media-feature
媒体~条件:#media-condition
媒体~照会~list:#media-query-list
媒体~照会~改変子:#media-query-modifier
媒体~照会:#media-query
媒体~型:#media-type

~test値:#testing-value
実~値:#real-value
ゼロ値:#zero-value
~min-max接頭辞:#mq-min-max
負の範囲は偽になる:#false-in-the-negative-range
	§:#mq-boolean-context
	§:#units
	§:#error-handling
	§:#mq-min-max
	§:#mq-range-context
	§:#mq-syntax

	●value
v.portrait:#valdef-media-orientation-portrait
v.landscape:#valdef-media-orientation-landscape
v.paged:#valdef-media-overflow-block-paged
v.~p_none:#valdef-media-pointer-none
v.coarse:#valdef-media-pointer-coarse
v.fine:#valdef-media-pointer-fine
v.~h_none:#valdef-media-hover-none
v.on-demand:#valdef-media-hover-on-demand
v.hover:#valdef-media-hover-hover

	●value types
t.any-value:~CSSSYN#typedef-any-value
t.delim-token:~CSSSYN#typedef-delim-token
t.function-token:~CSSSYN#typedef-function-token
t.extension-name:~CSSWG/css-extensions-1/#typedef-extension-name

t.length:~CSSVAL#length-value
t.number:~CSSVAL#number-value
t.resolution:~CSSVAL#resolution-value
t.integer:~CSSVAL#integer-value
t.dimension:~CSSVAL#typedef-dimension
t.ident:~CSSVAL#typedef-ident

	t.media-query:#typedef-media-query
	t.media-type:#typedef-media-type
	t.media-condition:#typedef-media-condition
	t.media-condition-without-or:#typedef-media-condition-without-or
	t.media-not:#typedef-media-not
	t.media-and:#typedef-media-and
	t.media-or:#typedef-media-or
	t.media-in-parens:#typedef-media-in-parens
	t.media-feature:#typedef-media-feature
	t.mf-plain:#typedef-mf-plain
	t.mf-boolean:#typedef-mf-boolean
	t.mf-range:#typedef-mf-range
	t.mf-name:#typedef-mf-name
	t.mf-value:#typedef-mf-value
	t.mf-lt:#typedef-mf-lt
	t.mf-gt:#typedef-mf-gt
	t.mf-eq:#typedef-mf-eq
	t.mf-comparison:#typedef-mf-comparison
	t.general-enclosed:#typedef-general-enclosed


	●property
p.break-inside:~CSSBREAK#propdef-break-inside
p.font-size:~CSSFONT#propdef-font-size

	●at-rule
at.import:~CASCADE#at-ruledef-import
	css-conditional-3
at.media:~CSSCOND#at-ruledef-media
at.viewport:~CSSWG/css-device-adapt-1/#at-ruledef-viewport

	●unit
u.cm:~CSSVAL#cm
u.em:~CSSVAL#em
u.px:~CSSVAL#px
u.in:~CSSVAL#in
	|:~CSSVAL#comb-one
	height:~CSSWM#height
	width:~CSSWM#width





成分~値を構文解析-:~CSSSYN#parse-a-component-value
識別子:~CSSSYN#identifier
~comma区切りの成分~値~listを構文解析-:~CSSSYN#parse-a-comma-separated-list-of-component-values

塊-軸:~CSSWM#block-axis
行内-軸:~CSSWM#inline-axis
次元:~CSSVAL#dimension
相対~長さ:~CSSVAL#relative-length

	cssom-view-1
頁~zoom:~CSSOMVIEW#page-zoom
~pinch~zoom:~CSSOMVIEW#pinch-zoom
~Webに公開される~screen区画:~CSSOMVIEW#web-exposed-screen-area

初期~値:~CASCADE#initial-value

~ASCII大小無視:~INFRA#ascii-case-insensitive

	●追補
表示域:~CSS2VISUREN#viewport
頁~box:~CSS22/page.html#page-box
初期~包含塊:~CSSDISP#initial-containing-block


●●words_table1

min-max: "<code class="descriptor">min-</code>"／"<code class="descriptor">max-</code>" 

p_none:none
h_none:none


●●words_table


	●特能
特能:feature::~:フィーチャ
特色機能:feature::~
媒体:media::~:メディア
媒体依存:media-dependent::~:メディア依存
照会:query::クエリ

素:plain::~
型:type::~
範囲:range::~
離散:discrete::~
離散的:discrete::~
文脈:context::~
評価-:evaluate::~
評価:evaluation::~
	評価-法:evaluating
	再~評価:re-evaluate
条件:condition::~
首:primary::~
ゼロ:zero::~
test::テスト
接頭辞:prefix::~
接頭:prefix::~

真偽値:boolean::~
真偽:boolean::~
真偽0:truth::真偽
真:true::~
偽:false::~
論理式:logical expression:~
論理的:logical:~
論理:logic:~
三値:3-valued:3 値
二値:2-valued:2 値
Kleene:::クリーネ
未知:unknown:~
未知の:unknown:~

式:expression::~
下位式:subexpression::~
形:form::~
値:value:~
否定:negation::~
否定形にな:negate され::~
否定形に:negate::~
否定形:negating:~

改変子:modifier::~
表示域:viewport::~:ビューポート
疑似属性:pseudo-attribute:~
疑似類:pseudo class::疑似クラス
要素:element:~
規則:rule::~
視覚:visual:~
解像度:resolution:~
解決:resolution:~
解決-:resolve:~

代数:algebra:~
近似的:approximate:~

反転-:invert:~
入子に:nest:入れ子に
混在-:mix:~
	区切ってつなげる〜一体化:can be chained together,

負の:negative:~
正の:positive:~
長さ:length:~
項:term:~
等価:equivalent:~
特性:characteristics:~
比率:ratio:~
比較-:compare:~
比較:comparison:~
演算子:operator:~
display:::ディスプレイ
profile:::プロファイル
装置:device:~
組合せる:combine する:組み合せる
組合せて:combine して:組み合せて
組合せ:combination:組み合せ


	●CSS
CSS:
行内:inline:~::インライン
行内-:inline-::~:インライン
塊:block::ブロック
塊-:block-::ブロック
block::ブロック
軸:axis::~
overflow:::過フロー:オーバーフロー
UA:user agent:UA
hover:
選択子:selector:~
許容-:allow:~
	許容されない:disallowed
省略-:omit:~
	スペース:space:~
	render:::レンダー
具現化-:render:~::レンダー
	具現化した結果:rendition
具現化:rendering:~::レンダリング
描画-:render:~
描画:rendering:~
描画面:rendering surface:~
	二次元:2D
音声化:audio rendition:~
音声:audio:~
colon:::コロン
semicolon:::セミコロン
comma:::カンマ
区切りの:-separated:~
区切って:separate して:~
区切られ:separate され:~
support:::サポート
import:
interface:::インタフェース
prop:property::プロパティ
box:::ボックス
size:::サイズ
object:::オブジェクト
error:::エラー
custom:::カスタム
keyword:::キーワード
style:::スタイル
	スタイル付け:styling:~
stylesheet:::スタイルシート
sheet:::シート
分断:break:~
寸法:dimension:~
次元:dimension:~
宣言-:declare:~
宣言:declaration:~
妥当:valid:~
子:child:~
単位:unit:~
初期:initial:~
包含塊:containing block:包含ブロック
For:for:用途
呈示-:present:~
縦幅:height:~
縦:vertical:~
縦方向:vertical:~
横幅:width:~
横:horizontal:~
横方向:horizontal:~
縦横比:aspect ratio:~
対話:interaction:~
対話-:interact:~
対話的:interactive:~

無効:invalid:~
不能化-:disable:~
可能化-:enable:~
構文:syntax:~
構文的:syntactic:~
構文解析-:parse:~::パース
構文解析:parsing:~::パース処理

無視-:ignore:~
成分:component:~
属性:attribute:~

下線:underline:~
group:::グループ

list:::リスト
layout:::レイアウト

animation:::アニメーション

	●装置／UI
click:::クリック
scroll:::スクロール
scrollbar:scroll bar::スクロールバー
紙:paper:~
mode:::モード
pointing:::ポインタ指示
pointer:::ポインタ
携帯機器:mobile device:~
screen:::スクリーン
screenreader:::スクリーンリーダ
interlaced:::インターレースによる
computer:::コンピュータ
grayscale:::グレイスケール
plasma:::プラズマ
progressive:::プログレッシブ
controller:::コントローラ
desktop:::デスクトップ
smartphone:::スマホ
touch:::タッチ
	~touch操作可能:touch-enabled
pad:::パッド
	~touch~screen:touchscreen／touch screen
	~touch~pad:touchpad
motion:::モーション
sensor:::センサ
	周辺機器:peripheral
stylus:::スタイラス
digitizer:::デジタイザ
controller:::コントローラ
control:::コントロール
手描き:drawing:~
mouse:::マウス
monitor:::モニタ
monochrome:::モノクロ
reader:::リーダ
hardware:::ハードウェア
buffer:::バッファ
system:::システム
host:::ホスト
console:::コンソール
video:::ビデオ
frame:::フレーム
vector-graphics:vector graphics::ベクターグラフィックス
keyboard:::キーボード
十字key:d-pad::十字キー
bitmap:::ビットマップ
browser:::ブラウザ
slideshow:::スライドショー
serif:::セリフ
font:::フォント
zoom:::ズーム
pinch:::ピンチ
focus-navigation:focus navigation::フォーカスナビ
物理的:physical:~
物理:physical:~
電子書籍:ebook:~
走査法:scanning process:~
高解像度:high-resolution:~
画素:pixel:~
環境:environment:~
方位:orientation:~
印刷:print:~::プリント
印刷ed:printed:印刷::プリント
印刷機:printer:~::プリンタ
網点:screening:~
script:::スクリプト
scripting:::スクリプト処理
櫛形残像:combing:~
入力機構:input mechanism:~
色域:gamut:~
色:color:~
	純色度:chromaticity
白色点:white point:~
深度:depth:~
検索表:lookup table:~
有色:color:~
原色:primary color:~
有index:indexed:有 index
	項目
横長:landscape::~
縦長:portrait::~
回転-:rotate:~
発話:speech:読み上げ
頁:page::ページ
頁媒体:paged media::ページ媒体:ページメディア
連続的:continuous:~
端末:terminal:~
帯域幅:bandwidth:~
幅狭な:narrow:~
入替える:invert する:入れ替える
直立:upright:~
stylus-based::ペン入力
平均的な:norm of a full-featured:標準的な
携帯電話:phone:~
横転-:tilt:~
遅い:slow な:~
頻度:frequency:~
品質:quality:~
密度:density:~
速度:speed:~
	速い:fast:~
運動:movement:~
動き:motion:~
滑らか:smooth:~
高速:quick:~
	~~簡素:basic:~
交替的:alternate:~
逐次的:sequential:~
空間的:spatial:~
移動-:move:~
欠く:lack する:~
	~~機器:laptop
密度:density:~
拡縮-:scale:~
	high-dpi
	整数でない:fractional
基本的な:basic:~
高度な:advanced:~

	●仕様（動詞
推奨-:recommend:~
非推奨に:deprecate:~
	でも:option::オプション
実装:implementation:~
変更点:changes:~
拡張-:extend:~
拡張0-:expand:拡張
拡張0:expansion:拡張
書直し:rewrite:~
再編成:reorgization:~
予期-:expect:~
期待-:expect:~
	expectation is that
依存-:depend:~
依存:dependent:~
依拠-:rely:~
模倣-:simulate:~
決定-:determine:~
由来-:originate:~
要求-:require:~
解釈-:interpret:~
述べら:describe さ:~
述べる:describe する:~
設計-:design:~
適合-:conform:~
適応-:adapt:~
適用-:apply:~
選好:preference:~
取扱い:handling:取り扱い
	扱って:treating:~
扱われ:treat され:~
扱わ:treat し:~
扱い:treatment:~
	受け持:cover する:~
	記し方:write する:~
記す:write する:~
記した:write した:~
記せる:write できる:~
見做-:assume:~
見做さな:assume しな:~
見做す:assume する:~
見なさ:consider さ:~
表され:express され:~
試みる:attempt する:~
試み:attempt:~
試みて:attemptし:~
避ける:avoid する:~
影響-:affect:~
意図-:intend:~
	意図されない:unintended
意図的:intentional:~
制約-:restrict:~
拘束-:constrain:~
拘束:constraints:~
制限-:limit:~
抑制-:reduce:~
受容-:accept:~
定義-:define:~
定義:definition:~
未定義の:undefined:~
導入-:introduce:~
木目細か:fine-grained:~
論じら:discuss さ:~
表層:superficial:~
挙動:behavior:ふるまい
働く:work する:~
捉える:capture する:~
改める:alter する:~
well-defined:
孕む:involve する:~
既知:known:~
既知の:known な:~
判明-:prove:~
採用-:adopt:~
主張-:claim:~
確保-:ensure:~
指定-:specify:~
指示-:indicate:~
供-:provide:~
供せ:provide でき:~
	~~供せる:serve
提供-:offer:~
供与-:contribute:~
意味:meaning:~
意味-:mean:~
裁定:decision:~
解され:understand され:~
判別-:discriminate:~
考慮点:considerations:~
考案-:invent:~
関係-:relate:~
無関係:irrelevant:~
関係性:relationship:~
却下-:reject:~
禁止-:forbid:~
対処-:work around:~
approach:::アプローチ
判断-:deem:~
明確化-:clarify:~
修正-:fix:~
喚起-:remind:~
	伝える:inform
	しようと:try

	●仕様
任意選択:optional:~
省略可:optional:~
	副 optional
作者:author:~
互換:compatible:~
互換性:compatibility:~
前方互換:forward-compatible:~
後方互換性:backward compatibility:~
仕様:spec:~
特定の:specific:~
	詳細化された~specific
特定的:specifical:具体的
特別:special:~
module:::モジュール
model:::モデル
level:::レベル
将来:future:~
将来的に:later stage で:~
	将来の互換性future-compatibility
旧来の:legacy:~
利用者:user:~
技術:technologies:~
標準の:standard な:~
注釈文:prose:~
付録:Appendix:~
編集上の:editorial:~
違法:illegal:~
不明瞭:unclear:~
明瞭:clear:~
仕組み:mechanism:~
事例:case:~
代表的:typical:~
公式的:formal:~
非公式的:informal:~
手動:manual:~
効果:effect:~
可用:available:~
明示的:explicit:~
有用:useful:~
概念:concept:~
機能性:functionality:~
	節:section:~
知識:knowledge:~
独立:independent:~
理由:reason:~
目的:purpose:~
簡便:convenient:~
要件:requirements:~
詳細:details:~
適切:appropriate:~
不適切:inappropriate:~
適正:proper:~
有意:significant:~
容易:easy:~
極めて:extreme に:~
稀:rare:~
概して:typical に:~
適度:reasonable:~
適度な:reasonable:~
課題:issue:~
能:ability:~
	通例:usual:~
通常:normal:~
通常の:normal:~
通常は:normal には:~
重要:important:~
困難:difficult:~
注意深く:careful に:~
側面:aspect:~
不一致:mismatch:~
不可能:impossible:~
有意義:meaningful:~
通例の:usual:~
通例:usually:~
能力:capabilities:~
能力有りの:-capable である:~
能力無しの:-capable でない:~
	能力があ:capable であ:~
問題ある:problematic な:問題のある
外的:external:~
	発行時点:publishing 時:~
主要な:major:~
不足:insufficient:~
	足る:sufficient な:~
不意に:accidental に:~
不便:inconvenient:~
利便性:convenience:~
仕方:way:~
主途の:main:~
用意:prepare:~
新機能:function:~
技法:technique:~
堅牢:robust:~
実際:actual:~
方式:manner:~
相互作用:interaction:~
	やりとり:interact
	~~問題ない:fine to have
注記:Note:~
便益:benefit:~
一般:general:~
	可能:possible
伝統的:traditional:~
利点:advantage:~
	~~限界がある:limiting in
概念的:conceptual:~
解決策:solution:~
可能性:possibility:~
	~~可能性:potential presence
	具体例として、:For instance,
状況:situation:~
	元来:by very nature
	編集者草案
作業草案:Working Draft:~
勧告候補:Candidate Recomendation:~
勧告:Recomendation:~
多彩:rich:~
意味論:semantics:~
関連する:relevant な:~
直感:intuition:~
	~~実際に~in reality,
直に:direct に:~
問題:problem:~
純粋:pure:~
強く:strong に:~

	●未分類（動詞
参照-:refer:~
反映-:reflect:~
合致-:match:~
	matching
命名-:name:~
回復-:recover:~
回復:recovery:~
変化-:change:~
変化:changes:~
変更-:change:~
変更:change:~
生産-:produce:~
操作-:manipulate:~
操作:manipulating:~
記述:description:~
記述-:describe:~
計算:calculation:~
検出-:detect:~
	検出-法:detecting
検出:detection:~
置換-:replace:~
表現-:represent:~
表現:representation:~
表示:display:~
認識-:recognize:~
誘発-:trigger:~
追加-:add:~
追加:addition:~
選定-:select:~
選抜-:qualify:~
除去-:remove:~
返-:return:~
返す:return する:~
改変-:modify:~
	利用:use:~
切替える:switch する:切り替える
切詰めら:truncate さ:切り詰めら
読上げる:read out する:読み上げる
作動化-:activate:~
稼働-:run:~
稼働中の:run している:~
	running
一掃-:wipe out:~
設定-:set:~
調節-:calibrate:~
失敗-:fail:~
転換-:turn into:~
遭遇-:encounter:~
更新-:update:~
常時更新:regularly-updating:~
描画更新:updating:~
対応付ける:map する:~
対応付けら:map さ:~
対応付け:mapping:~
終端-:end:~
握って:hold して:~
後続の:following:~
後続する:follow する:~
操作0-:operate:操作
是認-:grant:~
強化-:enhance:~
精査-:examine:~
知覚-:perceive:~
再現-:reproduce:~
制御:control:~
結付けら:associate され:結び付けら
表す:express する:~
報告-:report:~
増やす:increase する:~
token:::トークン
ASCII:
大小無視:case-insensitive:~

	~~保たれるretain
	少しずらす:offset
	ことにする:decide

上書き:override:~
	消す:eliminate する
	付きの:tagged
	適-:suit
	小さくたたむ:compactly hiding
	受け取った:receiveした
	挙げていく:enumerating
	隠して:hide して:~
	存在-:present
	存在:presence
	存在-:exist／
	含まれ:contain され／involving／include され
	までの部分:consume
	与-:give
	挟まれ:nested
	加えて，:additionally
	得られ:obtain
	括られ:wrapped
	丸括弧で括られたparenthesized
	示して:showing
	終端／了／止／点:end
	行う:perform
	見えなくする:hide, hiding
	呼応して:in response to
	得られる:transforming
	〜からなる:consists
	-:accordingly
	あてがわれ:assign
	含め:including
	-:compared
	-:sure
	-:made

	●未分類
HTML:
JS:JavaScript
Web:
grid:::グリッド
check-box:check box::チェックボックス
radio-button:radio button::ラジオボタン
drop-down-menu:drop down menu::ドロップダウンメニュー
text:::テキスト
dot:::ドット
version:::バージョン
link:::リンク
solidus:::スラッシュ
cost::コスト
top-level::トップレベル
bit:::ビット
preview:::プレビュー
smart:::スマート
cursor:::カーソル
controller:::コントローラ
bluetooth:
green:
	手法:method:~
項目:entry::~:エントリ

順序:order:~
順序付けた:order した:~
順序付けれ:order でき:~

入力:input:~
出力:output:~
	全体:entire:~
公式:formula:~
公開-:expose:~
露わに:expose:~
内容:content:~
内的:internal:~
内側:inside:~
処理:process:~
動的:dynamic:~
区画:area:~
単純:simple:~
名前:name:~
名:name:~
	identical:~
図式:diagram:~
基本:basic:~
	箇所:place:~
情報:information:~

数学的:mathematical:~
数的:numeric:~

整数:integer:~
文:statement:~
文字:character:~
文字列:string:~
文法:grammar:~
生成規則:production:~
空:empty:~
空白:whitespace:~
丸括弧:parentheses:~
符号:code:~
略記:shorthand:~
線路:railroad:~
英数字:alphanumeric:~
識別-:identify:~
識別子:identifier:~
英数字:alphanumeric:~
構成子:constructs:~

文書:document:~
最小:minimum:~
幾何:geometry:~
相対的:relative:~
相対:relative:~
相違:difference:~
背景:background:~
自動的:automatic:~
複雑:complex:~
言語:language:~
選択肢:branch:~
単純:simple:~
	点:point:~
	結果:result:~

空間:space:~

	精確
不正確:inacurate:~
正確1:accurate:正確
正確さ:accuracy:~
	~accurateでない~inaccurate
正確0:exact:正確
	~inaccurately
accessibility:::アクセス性:アクセシビリティ
放送:broadcast:~
広告欄:billboard:~

正方形:square:~

等幅:fixed:~
集合:set:~
分類:category:~
条件付きで:conditional に:~
代替:alternative:~
	代替になる:alternative

副次:secondary:副
排他的:exclusive:~
	排他的な~mutually~exclusive

長押し:long press:~
	改善する:help ameliorate する:~
代用1:proxy:代用
摘む:pick する:~
細部:details:~
外観:apearance:~

和集合:union:~
区間:section:~
普通の:ordinary:~
現れる:appear する:~
選ばれ:choose され:~
新たな:new:~
古い:older:~
幅広:wide:~
code::コード
保たれ:keep され:~

偶数:even:~
奇数:odd:~
余分の:extra:~
使用感:experience:使い勝手
同時:simultaneous:~
境目:breakpoint:~
精度:precision:~

privacy:::プライバシー
保安:security::~::セキュリティ
risk:::リスク
偽装:spoofing:~
	危める hazard
推定-:infer:~
	推定-可能:inferrable
指紋収集:fingerprinting::~
情報量:entropy:~
画像:image:~


	●指示語
単独の:single:~
全部的:full:~
全部的な:full:~
現在の:current:~
	両者:both
	常に:always
	いくつかの:several
	最初の:first
	個目:first／second
	今や:now
	大幅な:large
	別の:another
	-:latter
	-:additional
	最小の:smallest:
	異なる:different
	合間:between
	回／時点:time
	第一に:firstly
	第二に
	他の:other
	他の場合:otherwise
	複数の:multiple
	複数の:two or more
	0 〜 1 個の an optional
	個の:two／one
	単に:simple に／just
	大部分の:vast majority
	最終 final 
	ごと:per
	どこでも:everywhere
	残りの部分:the rest
	個々の:individual
	ある特定の:particular
	元々:original
	各:each
	更なる:further
	最も:most
	次の:following
	次の:next
	残り:remainder
	残りの:remaining
	同じ:same
	種々の:various
	〜の間:during
	〜の前に:before
	〜の後に:after
	この:this
	これらの:these
	すべての:all
	その他:others
	その:that
	それら:they
	それらの:their
	それらを:them
	自身:itself
	もの:ones
	ほぼ:almost
	ほぼ:nearly-
	まるごと:altogether
	まるごと:entirely
	一定の:certain
	上:above
	下:below
	多種多様:a lot of different
	ばらつき:a lot of differences in
	同様に:similarly
	同様の:similar
	様々になり得る:vary
	決して:never
	十分:enough
	そのような:such
	対象の:targeted

	高／高い:high
	~~最小:smallest
	より大きい:greater
	より長い:longer
	より高い:higher
	高:hight
	狭い:lower
	より広い:larger
	近く:close
	広い:large
	広く:widely 
	低:low

●●
	他の語
すき間に入り込む:fall between the cracks
~~認識できるaware
対照的:By contrast
難い:difficult
考える:consider する
可能性が高い:likely to
事実:fact
驚かせ:surprise させ
意味をなさない:make much sense
依然として:still
求める:want する:~
求めら:want さ:~
留意:remember
織り込む／織り込んで:takes into account
望ましくない:undesirable
便宜を図る:affordance
改善:help ameliorate
悩まさ:suffer され
いわゆる:common
の点で共通する:common factor
取って代わる:supersedes
従う:follow
従って，:therefore
必要する:need
必要とする:necessary
手間を要する:inconvenient
に基づく:-based
あいにく:unfortunately
決める:take this decision
~~境目が~~曖昧になって:blended significantly
もっと良い:better
への~~反応:react
~~適応し得るよう:accommodated
〜を除く:except
〜得る:potentially
〜過ぎる:exceptionally
おおまかな分類:broad category
に関して異なる:differ in
より高い:taller
一方で on the other hand
きちんと:well
任意の:arbitrary／any
備える:equipped
先行する:preceding
利用可能:usable
大きくする:larger
定義~表:definition table
対応-:correspond
~~対応して:respond
対象になる:subject to
対象:target
残念ながら:unfortunately
混同され易い:confusing
特に〜なく:not unusually
現今の:modern
生じさせる:provoke
留意:remember
要する:necessitate
言及する:regarding
確実に:reliable に
関する:respective
〜に注意。:note
〜に基づいて:based
〜に則って:according
あつらえられ:tailored
おそらく:probably
しかしながら，:however
なければならない:must
べき:should
長大になり過ぎる:tedious

昇格式に "ascending" fashion
	参照文献:ref
	~~真に広いlarger than and includes
	最適:best
	基底:base
	~fashion

	ごく:extra
	そうやって:that way

手の届かない所:out of reach
ごく:fairly
ときには:occasional

TV
screen上のon-screen
mouse
quite
hidden
cushion
sofa


視覚的にスッキリさせ:reduce visual clutter
	比較的:relatively
	粗い:coarse
~~適用target
より~~適切に~better
	用途:use
	類する:similar
	-:resemble
大小関係:which is lesser and which is greater
等しい／等しく:equal
~~等価:identical
有無:about the presence／complete absence／presence
~~開始from that point
閉じ括弧:-
単なる／単に:just
走査線:line
線が細くvery small features
~~単語:letters
	部分:part
隣接する:adjacent
~~特定の〜:only one 〜
電力が厳しいseverely under-powered
~~割付ける
選択可能にするopt into
不快:uncomfortable
R, G, B:red green blue
例:example
優先される:precedence
内在されない:no intrinsic
年月:years
~~同じに:identical

数:number
方法:how
正:positive
用語:term
表示~用~区画:targeted display area
要-:require
全く異なっていた:quite distinct
人の知覚による画像補正~能を利用:exploiting various automatic mental image-correction abilities
コメント:comment
暗い:dim
暗く:dimly

渡って／渡る:across
片:snippet
起こりにくい:less chance
可能:color-capable
~hoverにより作動される:hover-activated
成果:product
難しく／困難:difficulties
動き:very fast movement

クリック操作:clicking to be operated
表示 可能:capable
1 行のコード:line of code
〜することになる:will／would

〜の代わりに:instead
〜の場合:if
または:or


●●ref_normative

[COLORIMETRY]
    Colorimetry, Third Edition. CIE 15:2004. ISBN 978-3-901906-33-6. URL: http://www.cie.co.at/publ/abst/15-2004.html 
[CSS-CASCADE-3]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 3. 19 May 2016. CR. URL: https://www.w3.org/TR/css-cascade-3/ 
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 14 January 2016. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-CONDITIONAL-3]
    CSS Conditional Rules Module Level 3 URL: https://www.w3.org/TR/css3-conditional/ 
[CSS-VALUES-4]
    CSS Values and Units Module Level 4 URL: https://drafts.csswg.org/css-values-4/ 
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 4. 24 May 2018. CR. URL: https://www.w3.org/TR/css-writing-modes-4/ 
[CSS21]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS3SYN]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 20 February 2014. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS3VAL]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 29 September 2016. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSSOM-VIEW-1]
    Simon Pieters. CSSOM View Module. 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-view-1/ 
[MEDIAQ]
    Florian Rivoal; Tab Atkins Jr.. Media Queries Level 4. 5 September 2017. CR. URL: https://www.w3.org/TR/mediaqueries-4/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 

●●ref_informative

[CSS-BREAK-3]
    Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 3. 9 February 2017. CR. URL: https://www.w3.org/TR/css-break-3/ 
[CSS-DEVICE-ADAPT]
    Rune Lillesveen; Florian Rivoal; Matt Rakow. CSS Device Adaptation Module Level 1. 29 March 2016. WD. URL: https://www.w3.org/TR/css-device-adapt-1/ 
[CSS-FONTS-3]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 3. 26 June 2018. CR. URL: https://www.w3.org/TR/css-fonts-3/
[HTML401]
    Dave Raggett; Arnaud Le Hors; Ian Jacobs. HTML 4.01 Specification. 27 March 2018. REC. URL: https://www.w3.org/TR/html401/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[ITU-R-BT-2020-2]
    Parameter values for ultra-high definition television systems for production and international programme exchange. October 2015. URL: https://www.itu.int/rec/R-REC-BT.2020/en 
[RFC2879]
    G. Klyne; L. McIntyre. Content Feature Schema for Internet Fax (V2). August 2000. Proposed Standard. URL: https://tools.ietf.org/html/rfc2879 
[SMPTE-EG-432-1-2010]
    SMPTE Engineering Guideline - Digital Source Processing — Color Processing for D-Cinema. 2010. URL: http://ieeexplore.ieee.org/document/7289763/ 
[SMPTE-RP-431-2-2011]
    SMPTE Recommended Practice - D-Cinema Quality — Reference Projector and Environment. 2011. URL: http://ieeexplore.ieee.org/document/7290729/ 
[SRGB]
    Multimedia systems and equipment - Colour measurement and management - Part 2-1: Colour management - Default RGB colour space - sRGB. URL: https://webstore.iec.ch/publication/6169 
[XMLSTYLE]
    James Clark. Associating Style Sheets with XML documents. 29 June 1999. REC. URL: https://www.w3.org/1999/06/REC-xml-stylesheet-19990629/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Media Queries Level 4</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/mediaqueries-4/

編集者草案
	https://drafts.csswg.org/mediaqueries-4/

以前のバージョン
	https://www.w3.org/TR/2017/CR-mediaqueries-4-20170905/

最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/mediaqueries-4">GitHub Issues</a>

編集
	<a href="http://florian.rivoal.net">Florian Rivoal</a> (Invited Expert)
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)

前任編集者
	<a href="mailto:howcome@opera.com">Håkon Wium Lie</a> (Opera)
	<a href="mailto:tantek@cs.standard.edu">Tantek Çelik</a> (Mozilla)
	<a href="mailto:daniel@glazman.org">Daniel Glazman</a> (Disruptive Innovations)
	<a href="mailto:annevk@annevk.nl">Anne van Kesteren</a> (Mozilla)


</script>

</head>
<body>

<header>


	<hgroup>
<h1>媒体クエリ — Media Queries Level 4</h1>
	</hgroup>
</header>

<div id="MAIN" style="display: none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
`媒体~照会$により、作者は，具現化されている文書とは独立に，
~UAや表示~装置の 値や特能を~testして照会できるようになる。
それらは、文書に~styleを条件付きで適用する~CSS `media^at 規則や,
~HTMLや~JSなどの種々の他の文脈や言語において利用される。
◎
Media Queries allow authors to test and query values or features of the user agent or display device, independent of the document being rendered. They are used in the CSS @media rule to conditionally apply styles to a document, and in various other contexts and languages, such as HTML and JavaScript.
</p>

<p>
Media Queries Level 4 は
媒体~照会, 媒体~型, 媒体~特能
についての仕組みと構文を述べる。
それは、 Media Queries Level 3 にて定義された特能を拡張し, それに取って代わる。
◎
Media Queries Level 4 describes the mechanism and syntax of media queries, media types, and media features. It extends and supersedes the features defined in Media Queries Level 3.
</p>

~CSSisaLANG

<p>
次の特色機能は、~risk下にあり，勧告候補の期間に落とされるかもしれません：
◎
The following features are at-risk, and may be dropped during the CR period:
</p>

<ul>
	<li>
次に挙げる媒体~特能：
`hover$d,
`any-hover$d,
`pointer$d,
`any-pointer$d
◎
the hover, any-hover, pointer, and any-pointer media features 
</li>
</ul>


	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<!-- 
この節では、発行時点における…
-->
【以下，この節の他の内容は <a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>に委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
HTML4 `HTML401$r は、異なる`媒体~型$ごとにあつらえられた，媒体依存の~stylesheetを~supportする仕組みを定義している。
例えば、文書は，~screen用と印刷~用に異なる~stylesheetを利用し得る。
~HTMLにおいては，これは次の様に記せる：
◎
HTML4 [HTML401] defined a mechanism to support media-dependent style sheets, tailored for different media types. For example, a document may use different style sheets for screen and for print. In HTML, this can be written as:
</p>


<div class="example">

<pre class="lang-ml">
&lt;link
    rel="stylesheet"
    type="text/css"
    media="screen"
    href="style.css"
&gt;
&lt;link
    rel="stylesheet"
    type="text/css"
    media="print"
    href="print.css"
&gt;
</pre>

</div>

<p>
~CSSは、 `media$at, `import$at 規則により，個々の~特能の値を照会する能を追加して、この機能性に適応し, それを拡張している：
◎
CSS adapted and extended this functionality with its @media and @import rules, adding the ability to query the value of individual features:
</p>

<div class="example">

<p>
~CSS~stylesheetの内側では、一定の`媒体~型$に適用される区間を宣言できる：
◎
Inside a CSS style sheet, one can declare that sections apply to certain media types:
</p>

<pre class="lang-css">
@media screen {
  * { font-family: sans-serif }
}
</pre>

<p>
同様に、次の様にすれば，媒体~照会に基づいて条件付きで~stylesheetが~importされる：
◎
Similarly, stylesheets can be conditionally imported based on media queries:
</p>

<pre class="lang-css">
@import "print-styles.css" print;
</pre>

</div>

<p>
`媒体~照会$は、
HTML, XHTML, XML `XMLSTYLE$r
に加え，
~CSSの `import$at ／ `media$at 規則と伴にも利用できる。
◎
Media queries can be used with HTML, XHTML, XML [XMLSTYLE] and the @import and @media rules of CSS.
</p>

<div class="example">

<p>
以下に， HTML, XHTML, XML, `import^at, `media^at にて記される等価な例を同順に挙げる：
◎
Here is the same example written in HTML, XHTML, XML, @import and @media:
</p>

<pre class="lang-ml">
&lt;link
    media="screen and (color), projection and (color)"
    rel="stylesheet"
    href="example.css"
&gt;

&lt;link
    media="screen and (color), projection and (color)"
    rel="stylesheet"
    href="example.css"
/&gt;

&lt;?xml-stylesheet
    media="screen and (color), projection and (color)"
    rel="stylesheet"
    href="example.css"
?&gt;

@import url(example.css) screen and (color), projection and (color);

@media screen and (color), projection and (color) { … }
</pre>

<p class="note">注記：
`XMLSTYLE$r 仕様は、まだ， <code>media</code> 疑似属性において媒体~照会を利用するように 更新されていない。
◎
Note: The [XMLSTYLE] specification has not yet been updated to use media queries in the media pseudo-attribute.
</p>

</div>



		<section id="placement">
<h3 title="Module interactions">1.1. ~module間の相互作用</h3>

<p>
この~moduleは、
`CSS21$r の 7 章, および `MEDIAQ$r にて定義される
Media Queries, Media Type, Media Features
（媒体~照会, 媒体~型, 媒体~特能）
を置換し，拡張する。
◎
This module replaces and extends the Media Queries, Media Type and Media Features defined in [CSS21] sections 7 and in [MEDIAQ].
</p>



		</section>
		<section id="values">
<h3 title="Values">1.2. 値</h3>

<p>
この~仕様にて定義されない
`integer$t, `number$t, `resolution$t
などの値~型は
`CSS3VAL$r にて定義される。
他の~CSS~moduleは，これらの~値~型の定義を拡張0してよい。
◎
Value types not defined in this specification, such as &lt;integer&gt;, &lt;number&gt; or &lt;resolution&gt;, are defined in [CSS3VAL]. Other CSS modules may expand the definitions of these value types.
</p>

		</section>
		<section id="units">
<h3 title="Units">1.3. 単位</h3>

<p>
媒体~照会にて利用される単位は、~CSSの他所と同じであり，`CSS3VAL$r にて定義される。
例えば，画素~単位（ `px$u ）は、物理的~画素ではなく，~CSS画素を表現する。
◎
The units used in media queries are the same as in other parts of CSS, as defined in [CSS3VAL]. For example, the pixel unit represents CSS pixels and not physical pixels.
</p>

<p>
媒体~照会における`相対~長さ$単位は、`初期~値$に基づく
— すなわち、単位は，決して宣言の結果に基づくものではないことを意味する。
◎
Relative length units in media queries are based on the initial value, which means that units are never based on results of declarations.＼
</p>

<p class="note">
例えば，~HTMLにおける `em$u 単位は、［
~UAあるいは利用者の選好により定義される， `font-size$p の`初期~値$
］に相対的になり，頁~上の~style付けは関わらない。
◎
For example, in HTML, the em unit is relative to the initial value of font-size, defined by the user agent or the user’s preferences, not any styling on the page.
</p>



		</section>
	</section>
	<section id="media">
<h2 title="Media Queries">2. 媒体~照会</h2>

<p>
`媒体~照会@
とは、文書を表示している~UAや装置の一定の側面を~testするための手法である。
`媒体~照会$は、（ほぼ）常に［
文書の内容,
その~style付け,
他の~内的~側面
］から独立であり、 “外的な” 情報のみに依存する
— 別の特色機能が， Media Queries の解決に影響するものを明示的に指定しない限り（例えば `viewport$at 規則）。
◎
A media query is a method of testing certain aspects of the user agent or device that the document is being displayed in. Media queries are (almost) always independent of the contents of the document, its styling, or any other internal aspect; they’re only dependent on “external” information unless another feature explicitly specifies that it affects the resolution of Media Queries, such as the @viewport rule.
</p>

<p class="trans-note">【
装置 — この仕様の文脈では、何らかの特徴的な側面を有する物理的な装置と,
その挙動を~~模倣（ emulate ）する~UA／環境に，論理的な差異は無い。
例えば~UAによる印刷~previewは，物理的な印刷機と論理的に同じと見なされる。
】
</p>

<div >

<p>
`媒体~照会$の構文（ `media-query$t に合致）は、次のものからなる
【括弧内は訳者補足】：
</p>

<ul>
	<li>0 〜 1 個の`媒体~照会~改変子$（ `not^v または `only^v ）</li>
	<li>0 〜 1 個の`媒体~型$（ `media-type$t に合致）</li>
	<li>0 個~以上の`媒体~特能$（ `媒体~条件$（ `media-condition$t に合致）に含まれる， `media-feature$t に合致）</li>
</ul>

◎
The syntax of a media query consists of an optional media query modifier, an optional media type, and zero or more media features:
</div>

<figure class="railroad">

<svg class="railroad-diagram" height="132" viewBox="0 0 576 132" width="576">
 <g transform="translate(.5 .5)">
  <path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
  <g>
   <path d="M40 31h20"></path>
   <g class="non-terminal">
    <path d="M60 31h158"></path>
    <path d="M358 31h158"></path>
    <rect height="22" width="140" x="218" y="20"></rect>
     <text x="288" y="35">媒体~条件</text>
   </g>
   <path d="M516 31h20"></path>
   <path d="M40 31a10 10 0 0 1 10 10v30a10 10 0 0 0 10 10"></path>
   <g>
    <g>
     <path d="M60 81a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
     <g class="terminal">
      <rect height="22" rx="10" ry="10" width="52" x="80" y="50"></rect>
       <text x="106" y="65">only</text>
     </g>
     <path d="M132 61a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
     <path d="M60 81h20"></path>
     <g>
      <path d="M80 81h52"></path>
     </g>
     <path d="M132 81h20"></path>
     <path d="M60 81a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
     <g class="terminal">
      <path d="M80 101h4"></path>
      <path d="M128 101h4"></path>
      <rect height="22" rx="10" ry="10" width="44" x="84" y="90"></rect>
       <text x="106" y="105">not</text>
     </g>
     <path d="M132 101a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
    </g>
    <path d="M152 81h10"></path>
    <g class="non-terminal">
     <rect height="22" width="100" x="162" y="70"></rect>
      <text x="212" y="85">媒体~型</text>
    </g>
    <path d="M262 81h10"></path>
    <g>
     <path d="M272 81a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
     <g>
      <path d="M292 61h204"></path>
     </g>
     <path d="M496 61a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
     <path d="M272 81h20"></path>
     <g>
      <g class="terminal">
       <rect height="22" rx="10" ry="10" width="44" x="292" y="70"></rect>
        <text x="314" y="85">and</text>
      </g>
      <path d="M336 81h10"></path>
      <path d="M346 81h10"></path>
      <g class="non-terminal">
       <rect height="22" width="140" x="356" y="70"></rect>
        <text x="426" y="85">媒体~条件</text>
      </g>
     </g>
     <path d="M496 81h20"></path>
    </g>
   </g>
   <path d="M516 81a10 10 0 0 0 10 -10v-30a10 10 0 0 1 10 -10"></path>
  </g>
  <path d="M 536 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
 </g>
</svg>

</figure>


<p>
`媒体~照会$は、真または偽に評価される，論理式である。
媒体~照会が真に評価されるのは、次の両者とも満たされるときである：
◎
A media query is a logical expression that is either true or false. A media query is true if:
</p>

<ul>
	<li>
`媒体~型$が指定されている場合は、<!-- 
＊~UAがその媒体~型の装置を備えている, かつ
 -->その媒体~型が~UAが稼働中の装置の媒体~型に合致する。
◎
the media type, if specified, matches the media type of the device where the user agent is running, and
</li>
	<li>
`媒体~条件$が，真に評価される。
◎
the media condition is true.
</li>
</ul>

<p>
この節において，媒体~照会について言及する文は、<a href="#mq-syntax">構文の節</a>に従っていると見做す。
構文に適合しない媒体~照会については，
<a href="#error-handling">~error取扱い節</a>
にて論じられる。
すなわち、構文は，この節による要件よりも優先される。
◎
Statements regarding media queries in this section assume the syntax section is followed. Media queries that do not conform to the syntax are discussed in §3.2 Error Handling. I.e. the syntax takes precedence over requirements in this section.
</p>

<div class="example">

<p>
ここに~HTMLで記される単純な例を示す：
◎
Here is a simple example written in HTML:
</p>

<pre class="lang-ml">
&lt;link
    rel="stylesheet"
    media="screen and (color)"
    href="example.css"
/&gt;
</pre>

<p>
この例は、一定の~stylesheet（ <code>example.css</code> ）を，一定の（有色~screenであることを要する）特能を伴う, 一定の媒体~型（ `screen$vm ）の装置に，適用することを表す。
◎
This example expresses that a certain style sheet (example.css) applies to devices of a certain media type (screen) with certain feature (it must be a color screen).
</p>

<p>
同じ媒体~照会を~CSSの `import^at 規則で記した例：
◎
Here is the same media query written in an @import-rule in CSS:
</p>

<pre class="lang-css">
@import url(example.css) screen and (color);
</pre>

</div>

<p>
~UAは、利用者~環境の変化に呼応して，自身が~~認識できる`媒体~照会$を再~評価し~MUST。
例えば、装置の方位（ `orientation$d ）が横長（ `landscape$v ）から縦長（ `portrait$v ）に横転されたときは、それに応じて，
`orientation$d を用いる`媒体~照会$に依存する どの構成子の挙動も変化する。
<!-- tiled tiltedの誤記  -->
◎
User agents must re-evaluate media queries in response to changes in the user environment that they’re aware of, for example if the device is tiled from landscape to portrait orientation, and change the behavior of any constructs dependent on those media queries accordingly.
</p>

<p>
別の特色機能が Media Queries の解決に影響するものと明示的に~指定しない限り、式を評価するために~stylesheetを適用する必要は，決して生じない。
◎
Unless another feature explicitly specifies that it affects the resolution of Media Queries, it is never necessary to apply a style sheet in order to evaluate expressions.
</p>

<p class="note">注記：
CSS Device Adaptation
`CSS-DEVICE-ADAPT$r
の `viewport$at 規則が Media Queries とやりとりする方法を定義する。
◎
Note: CSS Device Adaptation [CSS-DEVICE-ADAPT]] defines how @viewport rules interact with Media Queries.
</p>



		<section id="mq-list">
<h3 title="Combining Media Queries">2.1. 媒体~照会を組合せるとき</h3>

<p>
いくつかの`媒体~照会$を，~commaで区切って組合せることができる。
`媒体~照会~list@
とは、 0 個~以上の`媒体~照会$からなる並びである：
◎
Several media queries can be combined into a comma-separated media query list.
</p>

<figure class="railroad">

<svg class="railroad-diagram" height="101" viewBox="0 0 248 101" width="248">
 <g transform="translate(.5 .5)">
  <path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
  <g>
   <path d="M40 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
   <g>
    <path d="M60 20h128"></path>
   </g>
   <path d="M188 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
   <path d="M40 40h20"></path>
   <g>
    <path d="M60 40h10"></path>
    <g class="non-terminal">
     <rect height="22" width="108" x="70" y="29"></rect>
      <text x="124" y="44">媒体~照会</text>
    </g>
    <path d="M178 40h10"></path>
    <path d="M70 40a10 10 0 0 0 -10 10v10a10 10 0 0 0 10 10"></path>
    <g class="terminal">
     <path d="M70 70h40"></path>
     <path d="M138 70h40"></path>
     <rect height="22" rx="10" ry="10" width="28" x="110" y="59"></rect>
      <text x="124" y="74">,</text>
    </g>
    <path d="M178 70a10 10 0 0 0 10 -10v-10a10 10 0 0 0 -10 -10"></path>
   </g>
   <path d="M188 40h20"></path>
  </g>
  <path d="M 208 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
 </g>
</svg>

</figure>

<p>
`媒体~照会~list$は、その <em>いずれかの</em> `媒体~照会$ 成分が真に評価されるとき，真に評価され、他の場合，すなわち その <em>すべての</em> 成分が偽に評価されるとき，偽に評価される。
◎
A media query list is true if any of its component media queries are true, and false only if all of its component media queries are false.
</p>


<div class="example">

<p>
例えば、次の`媒体~照会~list$は，［［
`媒体~型$は `screen$vm である, かつ有色~装置である
］, <strong>または</strong>［
`媒体~型$は `projection$vm である, かつ有色~装置である
］］場合に，真になる:
◎
For example, the following media query list is true if either the media type is screen and it’s a color device, or the media type is projection and it’s a color device:
</p>

<pre class="lang-css">
@media screen and (color), projection and (color) { … }
</pre>

</div>

<p>
空の`媒体~照会~list$は、真に評価される。
◎
An empty media query list evaluates to true.
</p>

<div class="example">

<p>
例えば，次の 2 つは、等価になる：
◎
For example, these are equivalent:
</p>

<pre class="lang-css">
@media all { … }
@media { … }
</pre>

</div>



		</section>
		<section id="mq-prefix">
<h3 title="Media Query Modifiers">2.2. 媒体~照会~改変子</h3>

<p>
`媒体~照会$には、任意選択で，単独の
`媒体~照会~改変子@
が接頭されてもよい。
それは、単独の~keywordであり，後続の`媒体~照会$の意味を改める。
◎
A media query may optionally be prefixed by a single media query modifier, which is a single keyword which alters the meaning of the following media query.
</p>



			<section id="mq-not">
<h4 title="Negating a Media Query: the not keyword">2.2.1. 媒体~照会の否定形： `not^v ~keyword</h4>

<p>
`媒体~照会$は、~keyword `not@vm を接頭することで，否定形になる
— ［
真／偽
］に評価される`媒体~照会$は，［
偽／真
］に評価されるようになる。
◎
An individual media query can have its result negated by prefixing it with the keyword not. If the media query would normally evaluate to true, prefixing it with not makes it evaluate to false, and vice versa.
</p>

<div class="example">

<p>
例えば，次のものは、［
~screenであって，有色~表示も可能であるもの
］を除く，何にでも適用されることになる。
`媒体~型$のみではなく，媒体~照会~全体として否定形にされることに注意。
◎
For example, the following will apply to everything except color-capable screens. Note that the entire media query is negated, not just the media type.
</p>

<pre class="lang-ml">
&lt;link
    rel="stylesheet"
    media="not screen and (color)"
    href="example.css"
/&gt;
</pre>

</div>



			</section>
			<section id="mq-only">
<h4 title="Hiding a Media Query From Legacy User Agents: the only keyword">2.2.2. 媒体~照会を旧来の~UAからは見えなくさせる： `only^v ~keyword</h4>

<p>
`媒体~照会$の概念は
HTML4 `HTML401$r に由来する。
その仕様は、`媒体~型$のみが定義されつつ，`媒体~特能$のような将来の概念の追加にも~~適応し得るような，前方互換な構文を備えている：
それは、`媒体~照会$の文字を，最初の非~英数字までの部分を`媒体~型$として解釈し、残りの部分は無視する。
例えば`媒体~照会$
`screen and (color)^css
は、単に `screen$vm に切詰められることになる。
◎
The concept of media queries originates from HTML4 [HTML401]. That specification only defined media types, but had a forward-compatible syntax that accommodated the addition of future concepts like media features: it would consume the characters of a media query up to the first non-alphanumeric character, and interpret that as a media type, ignoring the rest. For example, the media query screen and (color) would be truncated to just screen.
</p>

<p>
あいにくこれは、旧来の~UAが，`媒体~照会$の中のどの`媒体~特能$も
— それが`媒体~型$よりずっと重要であったとしても — 
この~errorの取扱いを利用して無視することになることを意味する。
その結果、不適切な状況~下で，不意に~styleが適用され得る。
◎
Unfortunately, this means that legacy user agents using this error-handling behavior will ignore any media features in a media query, even if they’re far more important than the media type in the query. This can result in styles accidentally being applied in inappropriate situations.
</p>

<p>
これらの`媒体~照会$を，旧来の~UAからは見えなくさせるため、`媒体~照会$には，~keyword
`only@vm
も接頭できる。
~keyword `only$vm は，`媒体~照会$の結果には<strong>効果を持たない</strong>が、旧来の~UAにおいては，その`媒体~照会$に 未知の`媒体~型$ "`only^c" が指定されていたかのように構文解析され，無視されるようになる。
◎
To hide these media queries from legacy user agents, the media query can be prefixed with the keyword only. The only keyword has no effect on the media query’s result, but will cause the media query to be parsed by legacy user agents as specifying the unknown media type “only”, and thus be ignored.
</p>

<div class="example">

<p>
次の例の `link^e 要素に指定された~stylesheetは、旧来の~UAからは利用されなくなる
— それが，通常は`媒体~型$ `screen$vm に合致するとしても。
◎
In this example, the stylesheet specified by the &lt;link&gt; element will not be used by legacy user agents, even if they would normally match the screen media type.
</p>

<pre class="lang-ml">
&lt;link
    rel="stylesheet"
    media="only screen and (color)" href="example.css"
/&gt;
</pre>

</div>

<p class="note">注記：
`only$vm ~keywordが利用できる所は、`媒体~型$の前に限られる。
［
`媒体~特能$のみからなる, あるいは `not$vm などの別の`媒体~照会~改変子$がある
］ような`媒体~照会$は、旧来の~UAからは，自動的に偽として扱われるので。
◎
Note: Note that the only keyword can only be used before a media type. A media query consisting only of media features, or one with another media query modifier like not, will be treated as false by legacy user agents automatically.
</p>

<p class="note">注記：
この~仕様の発行時点では，その種の旧来の~UAは極めて稀なので、
`only$vm 改変子が必要になることも稀である。
◎
Note: At the time of publishing this specification, such legacy user agents are extremely rare, and so using the only modifier is rarely, if ever, necessary.
</p>



			</section>
		</section>
		<section id="media-types">
<h3 title="Media Types">2.3. 媒体~型</h3>

<p>
`媒体~型@
は、文書を表示し得る~UA~装置の おおまかな分類である。
`媒体~型$の 元々の集合は、 HTML4 にて， `link^e 要素~上の `media^a 属性に対し定義されていた。
◎
A media type is a broad category of user-agent devices on which a document may be displayed. The original set of media types were defined in HTML4, for the media attribute on &lt;link&gt; elements.
</p>

<p>
残念ながら，`媒体~型$は、異なる~style付けを要する~装置を判別するには 不足であることが判明している。
`screen$vm と `handheld$vm の様な，元々は全く異なっていた一部の分類は、それらが考案されて以来，年月と伴に~~境目が~~曖昧になってきている。
`tty$vm や `tv$vm などの他のものも，平均的な~computer~monitorからの相違を露わにさせ，異なる~style付けを~~適用するために有用になり得るが、`媒体~型$の定義が排他的なので，適度な方式で利用するのは難しくなっている
— それらの排他的~側面は、
`grid$d や `scan$d などの`媒体~特能$として，より~~適切に表される。
◎
Unfortunately, media types have proven insufficient as a way of discriminating between devices with different styling needs. Some categories which were originally quite distinct, such as screen and handheld, have blended significantly in the years since their invention. Others, such as tty or tv, expose useful differences from the norm of a full-featured computer monitor, and so are potentially useful to target with different styling, but the definition of media types as mutually exclusive makes it difficult to use them in a reasonable manner; instead, their exclusive aspects are better expressed as media features such as grid or scan.
</p>

<p>
そのようなわけで、次の`媒体~型$が，`媒体~照会$用途に定義される：
◎
As such, the following media types are defined for use in media queries:
</p>


<dl>
	<dt>`all@vm</dt>
	<dd>
すべての装置に合致する。
◎
Matches all devices.
</dd>

	<dt>`print@vm</dt>
	<dd>
印刷機, あるいは印刷ed~表示の再現に意図されている装置（文書を “印刷~preview” で~~表示する Web~browserなど）に合致する。
◎
Matches printers, and devices intended to reproduce a printed display, such as a web browser showing a document in “Print Preview”.
</dd>

	<dt>`screen@vm</dt>
	<dd>
`print$vm にも `speech$vm にも合致しない，すべての装置に合致する。
◎
Matches all devices that aren’t matched by print or speech.
</dd>

	<dt>`speech@vm</dt>
	<dd>
頁を “読上げる” ものに類する装置に合致する。
◎
Matches devices that similar devices that “read out” a page.
</dd>
	<dd class="note">注記：
頁の視覚~layoutに基づいて発話を具現化する~screenreaderには、代わりに `screen$vm に合致させることが期待される。
この媒体~型は、二次元~視覚~layoutに基づかずに文書の音声化を生産する~UA用にある。
◎
Screen readers that produce a speech rendering based on the the visual layout of the page are expected to match screen instead. This media type is for user agents that produce an audio rendition of the document, without any reference to a 2D visual layout.
</dd>
	<dd class="issue">
そのような~UAはあるのか？
そうであれば、それらはこの媒体~型に合致するのか？
そうでないなら、これは非推奨にされるべきである。
<a href="~CSSissue/1751">issues#1751</a>
◎
Is there any such UA, and if so do they match this media type? If not, it should be deprecated. &lt;https://github.com/w3c/csswg-drafts/issues/1751&gt;
</dd>
</dl>

<p>
加えて、下に挙げる<strong>非推奨にされ</strong>た`媒体~型$が定義される
— 作者は、これらの`媒体~型$を利用してはならない。
代わりに、~style付けを試みている装置の側面を，より適切に表現する`媒体~特能$を選定することが推奨される。
◎
In addition, the following deprecated media types are defined. Authors must not use these media types; instead, it is recommended that they select appropriate media features that better represent the aspect of the device that they are attempting to style against.
</p>

<p>
~UAは、これらの`媒体~型$を妥当なものとして認識した上で，何にも合致しないものと扱わ~MUST。
◎
User agents must recognize the following media types as valid, but must make them match nothing.
</p>

<ul>
	<li>`tty@vm</li>
	<li>`tv@vm</li>
	<li>`projection@vm</li>
	<li>`handheld@vm</li>
	<li>`braille@vm</li>
	<li>`embossed@vm</li>
	<li>`aural@vm</li>
</ul>

<p class="note">注記：
どの媒体~型についても、時を経て，より重要な相違を捉える適切な`媒体~特能$が定義されるに伴い，非推奨にされ得るものと予期されている。
◎
Note: It is expected that all of the media types will also be deprecated in time, as appropriate media features are defined which capture their important differences.
</p>




		</section>
		<section id="mq-features">
<h3 title="Media Features">2.4. 媒体~特能</h3>

<p>
`媒体~特能@
は、~UAや表示~装置に備わる，単独の, 特定の特能【 feature, ~~特色機能 】を~testするような、`媒体~型$より木目細かな~testである。
◎
A media feature is a more fine-grained test than media types, testing a single, specific feature of the user agent or display device.
</p>

<div >

<p>
`媒体~特能$（ `media-feature$t に合致）には、次の 3 通りの記し方がある
【括弧内は訳者補足】：
</p>


<dl class="def-list">
	<dt>`素~形@（ `mf-plain$t ）</dt>
	<dd>
［
特能~名,
1 個の~colon,
`~test値$
］の並び。
</dd>
	<dd class="trans-note">【
“素~形” という語は、記述し易くするため，この訳にて導入した非公式な用語である。
】</dd>

	<dt>`真偽~形@（ `mf-boolean$t ）</dt>
	<dd>
特能~名のみ。
</dd>

	<dt>`範囲~形@（ `mf-range$t ）</dt>
	<dd>
後述する比較~演算子を伴うもの。
</dd>
</dl>
◎
Syntactically, media features resemble CSS properties: they consist of a feature name, a colon, and a value to test for. They may also be written in boolean form as just a feature name, or in range form with a comparison operator.
</div>


<figure class="railroad">

<svg class="railroad-diagram" height="122" viewBox="0 0 524 122" width="524">
 <g transform="translate(.5 .5)">
  <path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
  <path d="M40 31h10"></path>
  <g class="terminal">
   <rect height="22" rx="10" ry="10" width="28" x="50" y="20"></rect>
    <text x="64" y="35">(</text>
  </g>
  <path d="M78 31h10"></path>
  <g>
   <path d="M88 31h20"></path>
   <g>
    <g class="non-terminal">
     <rect height="22" width="116" x="108" y="20"></rect>
      <text x="166" y="35">特能~名</text>
    </g>
    <path d="M224 31h10"></path>
    <path d="M234 31h10"></path>
    <g class="terminal">
     <rect height="22" rx="10" ry="10" width="28" x="244" y="20"></rect>
      <text x="258" y="35">:</text>
    </g>
    <path d="M272 31h10"></path>
    <path d="M282 31h10"></path>
    <g class="non-terminal">
     <rect height="22" width="124" x="292" y="20"></rect>
      <text x="354" y="35">特能~値</text>
    </g>
   </g>
   <path d="M416 31h20"></path>
   <path d="M88 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
   <g class="non-terminal">
    <path d="M108 61h96"></path>
    <path d="M320 61h96"></path>
    <rect height="22" width="116" x="204" y="50"></rect>
     <text x="262" y="65">特能~名</text>
   </g>
   <path d="M416 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
   <path d="M88 31a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
   <g>
    <path d="M108 91h50"></path>
    <path d="M365 91h50"></path>
    <g class="non-terminal">
     <rect height="22" width="100" x="158" y="80"></rect>
      <text x="208" y="95">範囲~形</text>
    </g>
    <path d="M258 91h10"></path>
    <path d="M268 91h10"></path>
    <g>
      <text class="comment" x="321" y="96">(~~記述を見よ)</text>
    </g>
   </g>
   <path d="M416 91a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
  </g>
  <path d="M436 31h10"></path>
  <g class="terminal">
   <path d="M446 31h0"></path>
   <path d="M474 31h0"></path>
   <rect height="22" rx="10" ry="10" width="28" x="446" y="20"></rect>
    <text x="460" y="35">)</text>
  </g>
  <path d="M474 31h10"></path>
  <path d="M 484 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
 </g>
</svg>
</figure>

<p>
特に`素~形$は，構文的に~CSS~propに類似するが、~propと媒体~特能には，いくつか点で重要な相違がある：
◎
There are, however, several important differences between properties and media features:
</p>

	<ul>
		<li>
~propは，文書をどう呈示するかについての情報を与えるものである一方、媒体~特能は，出力~装置の要件を述べるためのものである。
◎
Properties are used to give information about how to present a document. Media features are used to describe requirements of the output device.
</li>
	<li>
媒体~特能は、常に丸括弧で括られる
— ~propのように~semicolonでは区切られず，次の様に `and^vm や `or^vm ~keywordを用いて組合せることもできる：
`(color) and (min-width: 600px)^css
◎
Media features are always wrapped in parentheses and combined with the and or or keywords, like (color) and (min-width: 600px), rather than being separated with semicolons.
</li>
	<li>
媒体~特能は、（~colonと値を省略して）その名前<em>のみ</em>としても与え得る
— その場合、その特能は `真偽~文脈$の下で評価される。
これにより、`実~値$として`ゼロ値$をとり得る特能~用の，簡便な略記が~~可能になる。
例えば
`(color)^css
は、 `color$d `媒体~特能$の`実~値$が`ゼロ値$でないとき，真になる。
◎
A media feature may be given with only its name (omitting the colon and value) to evaluate the feature in a boolean context. This is a convenient shorthand for features that have a reasonable value representing 0 or “none”. For example, (color) is true is the color media feature is non-zero.
</li>
	<li>
`範囲~文脈$の下では、`媒体~特能$を`範囲$で記すこともできる
— それは~colonではなく，標準の~数学的 比較~演算子を用いて, あるいは 特能~名に`~min-max接頭辞$を付与して記すこともできる。
◎
Media features with “range” type can be written in a range context, which uses standard mathematical comparison operators rather than a colon, or have their feature names prefixed with “min-” or “max-”.
</li>
	<li>
~propには、例えば 他のいくつかの値の計算も孕むような複雑な値を受容するものもある。
`媒体~特能$が`~test値$に受容するのは、［
1 個の~keyword, 1 個の数, 等々の，単独の値
］に限られる。
◎
Properties sometimes accept complex values, e.g., calculations that involve several other values. Media features only accept single values: one keyword, one number, etc.
</li>
</ul>

<p id="_not-exist">
`媒体~特能$が，~UAが稼働中の装置~上に存在しない概念を参照する場合（例えば，発話~UAは “横幅” の概念を備えない）、常に偽に評価され~MUST。
◎
If a media feature references a concept which does not exist on the device where the UA is running (for example, speech UAs do not have a concept of “width”), the media feature must always evaluate to false.
</p>

<div class="example">

<p>
媒体~特能
`device-aspect-ratio$d
は、視覚~装置のみに適用される。
従って， `speech$vm ~装置においては、
`device-aspect-ratio^d
が含まれた式は，常に偽になる：
◎
The media feature device-aspect-ratio only applies to visual devices. On an speech device, expressions involving device-aspect-ratio will therefore always be false:
</p>

<pre class="lang-ml">
&lt;link
    media="speech and (device-aspect-ratio: 16/9)"
    rel="stylesheet"
    href="example.css"
&gt;
</pre>

</div>

			<section id="mq-ranges">
<h4 title="Media Feature Types: “range” and “discrete”">2.4.1. 媒体~特能の型： 範囲~型と離散~型</h4>

<p>
どの媒体~特能も，その定義~表の中で その “型” を次のいずれかとして定義する：
◎
Every media feature defines its “type” as either “range” or “discrete” in its definition table.
</p>

<dl class="def-list">
	<dt>`離散~型@</dt>
	<dd>
この型の媒体~特能は，いくつかの~keywordや, 真偽値（ `0^v または `1^v で記される）からなる集合に属する値をとり、それら値の間には順序（大小関係）は内在されない点で共通する。
例えば `pointer$d 。
◎
“Discrete” media features, like pointer take their values from a set. The values may be keywords or boolean numbers (0 and 1), but the common factor is that there’s no intrinsic “order” to them—none of the values are “less than” or “greater than” each other.
</dd>

	<dt>`範囲~型@</dt>
	<dd>
この型の媒体~特能がとり得る値~集合は，全順序を備える範囲であり、どの２つの値も，大小関係を比較できる。
例えば `width$d 。
◎
“Range” media features like width, on the other hand, take their values from a range. Any two values can be compared to see which is lesser and which is greater.
</dd>

</dl>


<p>
この２つの型の唯一かつ有意な相違は、`範囲~型$の`媒体~特能$が，［
`範囲~文脈$の下でも評価できるものであり，その名前に`~min-max接頭辞$を受容する
］ことである。
これらの接頭辞はいずれも，特能の意味を変える
— ［
`媒体~特能$の`実~値$が`~test値$に正確0に合致するとき，真に評価される
【すなわち，素~文脈】
］のではなく、［
`実~値$が`~test値$［
より大きい／より小さい／等しい
］範囲に合致する
］とき，真に評価される。
◎
The only significant difference between the two types is that “range” media features can be evaluated in a range context and accept “min-” and “max-” prefixes on their name. Doing either of these changes the meaning of the feature—rather than the media feature being true when the feature exactly matches the given value, it matches when the feature is greater than/less than/equal to the given value.
</p>

<div class="example">

<p>
`媒体~特能$
`(width &gt;= 600px)^css
は、表示域の横幅が `600px^v  <em>以上</em> のとき真になる。
◎
A ''(width >= 600px)'' media feature is true when the viewport’s width is 600px or more.
</p>

<p>
一方で `(width: 600px)^css それ自体は、表示域の横幅が <em>正確0に</em> `600px^v のときに限り真になり， `600px^v より小さい／大きいときには偽になる。
◎
On the other hand, (width: 600px) by itself is only true when the viewport’s width is exactly 600px. If it’s less or greater than 600px, it’ll be false.
</p>

</div>


			</section>
			<section id="mq-plain-context">
<h4>2.4.X. 素~文脈~下での媒体~特能の評価-法</h4>

<p class="trans-note">【
この節は、原文には存在しない，訳者による補完である。
仕様が定義する~modelを明確化する／整理するため、以下の非公式な用語を導入する。
】</p>

<p>
媒体~特能の
`~test値@
とは、その特能の値の構文に従って，作者が指定した値を意味する。
媒体~特能の
`実~値@
とは、［
その特能が参照する，~UAが稼働する環境に備わる装置
］の現在の状態／機能を反映する値を意味する。
【原文では、明示的な区別なく，単に（媒体~特能の） “値” と記される所も多々あり、そのまま和訳すると紛らわしくなるので。】
</p>

<p>
次に挙げる値は、所与の媒体~特能の
`ゼロ値@
とされる：
</p>

<ul>
	<li>
~keyword `none^v
</li>
	<li>
`number$t 値 `0^v
</li>
	<li>
`dimension$t 値 `0^v
</li>
	<li>
<p>
その媒体特能により、`ゼロ値$であるものと明示的に定義された値
</p>

<p class="trans-note">【
そのように定義される値は、この~level 4 の仕様には現れないが，~level 5 から利用される。
】</p>

	</li>
</ul>

<p>
`実~値$が`ゼロ値$であることは、一般に，その特能が参照する装置に その特能が備わっていない（または，装置そのものがない†）ことを指示する。
</p>

<p class="trans-note">【†
ただし、特能の中には，構文として（`~test値$として）`ゼロ値$をとり得ないものもある
— ~UAが その特能を備えていない場合に，その特能の`実~値$は（仮想の）`ゼロ値$をとると見なすのか，
<a href="#_not-exist">存在しない概念を参照する</a>場合に従うものと解釈するのか，はっきりしないが、
<a href="#_apply-to-the-device">どちらに解釈しようが結果は同じになる</a>と見受けられる。
】</p>

<p>
`素~形$のうち，`~min-max接頭辞$を伴わない媒体~特能は、
`素~文脈@
の下で評価される
— すなわち：
`~test値$が`実~値$に正確0に合致するとき，真に評価され、他の場合は，偽に評価される。
</p>

<p>
ただし，媒体~特能には、いくつかの装置の和集合を表現するものもある（ `any-pointer$d など）。
この場合の`実~値$は，それらの各~装置の`実~値$からなる和集合になり、`~test値$は，そのいずれかの値に合致するとき 真に評価されることになる。
</p>

			</section>
			<section id="mq-boolean-context">
<h4 title="Evaluating Media Features in a Boolean Context">2.4.2. 真偽~文脈~下での媒体~特能の評価-法</h4>

<p>
`媒体~特能$の通常の構文は，~CSS~propと同様（`素~形$）であるが、
`(color)^css のように，より単純に 特能~名のみ（`真偽~形$）として記すこともできる。
◎
While media features normally have a syntax similar to CSS properties, they can also be written more simply as just the feature name, like (color).
</p>

<p>
このように記された`媒体~特能$は、
`真偽~文脈@
の下で評価される：
すなわち、ある`ゼロ値$以外の値 `V^V が存在して，その`媒体~特能$を［
`素~文脈$の下で， `V^V を`~test値$として評価したときの結果
］が真になる
— 言い換えれば，`実~値$が`ゼロ値$でない —
ならば、真に評価される。
他の場合、偽に評価される。
◎
When written like this, the media feature is evaluated in a boolean context. If the feature would be true for any value other than the number 0, a &lt;dimension&gt; with the value 0, or the keyword none, the media feature evaluates to true. Otherwise, it evaluates to false.
</p>

<div class="example">

<p>
一部の`媒体~特能$は、このような記され方を念頭に置いて設計されている。
◎
Some media features are designed to be written like this.
</p>

<p>
例えば `update$d は，概して、何らかの描画更新が可用である（あるいは可用でない）かどうかを~testするために、 `(update)^css （あるいは `not (update)^css ）として，記される。
◎
For example, update is typically written as (update) to test if any kind of updating is available, or not (update) to check for the opposite.
</p>

<p>
`~test値$を明示的に与える`素~形$による記し方も，依然として可能である
—
`(update: fast) or (update: slow)^css は `(update)^css に等しく，
`(update: none)^css は `not (update)^css に等しい。
◎
It can still be given an explicit value as well, with (update: fast) or (update: slow) equal to (update), and (update: none) equal to not (update).
</p>

</div>

<p class="example">
`width$d のような数的な`媒体~特能$が `真偽~文脈$下の評価において有用になることは、稀である
— それらの`実~値$は，ほぼ常にゼロより大きいので。
`color$d などの他のものは、有意義な`ゼロ値$をとり得る：
`(color)^css は `(color &gt; 0)^css と~~等価であり，装置は有色~表示 能力があることを指示する。
◎
Some numeric media features, like width, are rarely if ever useful to evaluate in a boolean context, as their values are almost always greater than zero. Others, like color, have meaningful zero values: (color) is identical to (color &gt; 0), indicating that the device is capable of displaying color at all.
</p>

<div class="example">

<p>
~keywordを受容する`媒体~特能$のうち，`真偽~文脈$下で有意義になるものは、一部に限られる。
◎
Only some of the media features that accept keywords are meaningful in a boolean context.
</p>

<p id="_apply-to-the-device">
例えば
`(pointer)^css
は、 `pointer$d が［
装置~上に~pointing装置を備えていないことを指示する値 `none^v
］をとり得るので有用になる。
一方で
`(scan)^css は、
`scan$d の値が`ゼロ値$をとり得ないので、（それが装置に適用されるか否かに依存して†）常に真か偽になる。
◎
For example, (pointer) is useful, as pointer has a none value to indicate there’s no pointing device at all on the device. On the other hand, (scan) is just always true or always false (depending on whether it applies at all to the device), as there’s no value that means “false”.
</p>

<p class="trans-note">【†
すなわち，~UAが `scan$d に対応する装置を備えるならば、その`実~値$が何であれ真，そうでなければ偽になる、と思われる。
ここでの “値” が `実~値$, `~test値$のいずれを指すのかはっきりしないが、当の装置を備えない場合， 2 つの解釈が考えられる：
(1) <a href="#_not-exist">存在しない概念を参照する</a>ものと見なされる結果、偽とされる。
(2) 実~値は，~test値がとり得ない`ゼロ値$をとっているものと見なされる結果、偽とされる。
】</p>

</div>

			</section>
			<section id="mq-range-context">
<h4 title="Evaluating Media Features in a Range Context">2.4.3. 範囲~文脈~下での媒体~特能の評価-法</h4>


<p>
`範囲~型$の`媒体~特能$は、`範囲~形$として記すこともできる
—
それは、特能がとり得る値が，普通の数学的な比較~演算子を利用して順序付けれる利点を活かすように，
`範囲~文脈@
の下で評価される：
◎
Media features with a “range” type can be alternately written in a range context that takes advantage of the fact that their values are ordered, using ordinary mathematical comparison operators:
</p>

<figure class="railroad">

<svg class="railroad-diagram" height="302" viewBox="0 0 644 302" width="644">
 <g transform="translate(.5 .5)">
  <path d="M 20 141 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
  <path d="M40 151h10"></path>
  <g class="terminal">
   <rect height="22" rx="10" ry="10" width="28" x="50" y="140"></rect>
    <text x="64" y="155">(</text>
  </g>
  <path d="M78 151h10"></path>
  <g>
   <path d="M88 151h20"></path>
   <g>
    <path d="M108 151h2"></path>
    <path d="M534 151h2"></path>
    <g class="non-terminal">
     <rect height="22" width="164" x="110" y="140"></rect>
      <text x="192" y="155">特能~名／値</text>
    </g>
    <path d="M274 151h10"></path>
    <g>
     <path d="M284 151a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
     <g class="terminal">
      <path d="M304 121h4"></path>
      <path d="M336 121h4"></path>
      <rect height="22" rx="10" ry="10" width="28" x="308" y="110"></rect>
       <text x="322" y="125">&gt;</text>
     </g>
     <path d="M340 121a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
     <path d="M284 151a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
     <g class="terminal">
      <rect height="22" rx="10" ry="10" width="36" x="304" y="80"></rect>
       <text x="322" y="95">&lt;=</text>
     </g>
     <path d="M340 91a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
     <path d="M284 151a10 10 0 0 0 10 -10v-70a10 10 0 0 1 10 -10"></path>
     <g class="terminal">
      <path d="M304 61h4"></path>
      <path d="M336 61h4"></path>
      <rect height="22" rx="10" ry="10" width="28" x="308" y="50"></rect>
       <text x="322" y="65">&lt;</text>
     </g>
     <path d="M340 61a10 10 0 0 1 10 10v70a10 10 0 0 0 10 10"></path>
     <path d="M284 151a10 10 0 0 0 10 -10v-100a10 10 0 0 1 10 -10"></path>
     <g class="terminal">
      <path d="M304 31h4"></path>
      <path d="M336 31h4"></path>
      <rect height="22" rx="10" ry="10" width="28" x="308" y="20"></rect>
       <text x="322" y="35">=</text>
     </g>
     <path d="M340 31a10 10 0 0 1 10 10v100a10 10 0 0 0 10 10"></path>
     <path d="M284 151h20"></path>
     <g class="terminal">
      <rect height="22" rx="10" ry="10" width="36" x="304" y="140"></rect>
       <text x="322" y="155">&gt;=</text>
     </g>
     <path d="M340 151h20"></path>
    </g>
    <path d="M360 151h10"></path>
    <g class="non-terminal">
     <rect height="22" width="164" x="370" y="140"></rect>
      <text x="452" y="155">特能~値／名</text>
    </g>
   </g>
   <path d="M536 151h20"></path>
   <path d="M88 151a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
   <g>
    <g class="non-terminal">
     <rect height="22" width="60" x="108" y="170"></rect>
      <text x="138" y="185">値</text>
    </g>
    <path d="M168 181h10"></path>
    <g>
     <path d="M178 181h20"></path>
     <g class="terminal">
      <path d="M198 181h4"></path>
      <path d="M230 181h4"></path>
      <rect height="22" rx="10" ry="10" width="28" x="202" y="170"></rect>
       <text x="216" y="185">&lt;</text>
     </g>
     <path d="M234 181h20"></path>
     <path d="M178 181a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
     <g class="terminal">
      <rect height="22" rx="10" ry="10" width="36" x="198" y="200"></rect>
       <text x="216" y="215">&lt;=</text>
     </g>
     <path d="M234 211a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
    </g>
    <path d="M254 181h10"></path>
    <g class="non-terminal">
     <rect height="22" width="116" x="264" y="170"></rect>
      <text x="322" y="185">特能~名</text>
    </g>
    <path d="M380 181h10"></path>
    <g>
     <path d="M390 181h20"></path>
     <g class="terminal">
      <path d="M410 181h4"></path>
      <path d="M442 181h4"></path>
      <rect height="22" rx="10" ry="10" width="28" x="414" y="170"></rect>
       <text x="428" y="185">&lt;</text>
     </g>
     <path d="M446 181h20"></path>
     <path d="M390 181a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
     <g class="terminal">
      <rect height="22" rx="10" ry="10" width="36" x="410" y="200"></rect>
       <text x="428" y="215">&lt;=</text>
     </g>
     <path d="M446 211a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
    </g>
    <path d="M466 181h10"></path>
    <g class="non-terminal">
     <rect height="22" width="60" x="476" y="170"></rect>
      <text x="506" y="185">値</text>
    </g>
   </g>
   <path d="M536 181a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
   <path d="M88 151a10 10 0 0 1 10 10v70a10 10 0 0 0 10 10"></path>
   <g>
    <g class="non-terminal">
     <rect height="22" width="60" x="108" y="230"></rect>
      <text x="138" y="245">値</text>
    </g>
    <path d="M168 241h10"></path>
    <g>
     <path d="M178 241h20"></path>
     <g class="terminal">
      <path d="M198 241h4"></path>
      <path d="M230 241h4"></path>
      <rect height="22" rx="10" ry="10" width="28" x="202" y="230"></rect>
       <text x="216" y="245">&gt;</text>
     </g>
     <path d="M234 241h20"></path>
     <path d="M178 241a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
     <g class="terminal">
      <rect height="22" rx="10" ry="10" width="36" x="198" y="260"></rect>
       <text x="216" y="275">&gt;=</text>
     </g>
     <path d="M234 271a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
    </g>
    <path d="M254 241h10"></path>
    <g class="non-terminal">
     <rect height="22" width="116" x="264" y="230"></rect>
      <text x="322" y="245">特能~名</text>
    </g>
    <path d="M380 241h10"></path>
    <g>
     <path d="M390 241h20"></path>
     <g class="terminal">
      <path d="M410 241h4"></path>
      <path d="M442 241h4"></path>
      <rect height="22" rx="10" ry="10" width="28" x="414" y="230"></rect>
       <text x="428" y="245">&gt;</text>
     </g>
     <path d="M446 241h20"></path>
     <path d="M390 241a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
     <g class="terminal">
      <rect height="22" rx="10" ry="10" width="36" x="410" y="260"></rect>
       <text x="428" y="275">&gt;=</text>
     </g>
     <path d="M446 271a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
    </g>
    <path d="M466 241h10"></path>
    <g class="non-terminal">
     <rect height="22" width="60" x="476" y="230"></rect>
      <text x="506" y="245">値</text>
    </g>
   </g>
   <path d="M536 241a10 10 0 0 0 10 -10v-70a10 10 0 0 1 10 -10"></path>
  </g>
  <path d="M556 151h10"></path>
  <g class="terminal">
   <rect height="22" rx="10" ry="10" width="28" x="566" y="140"></rect>
    <text x="580" y="155">)</text>
  </g>
  <path d="M594 151h10"></path>
  <path d="M 604 151 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
 </g>
</svg>

</figure>

<p class="note">注記：
この構文は、この仕様のこの~level（ Mediaqueries Level 4 ）による新たなものなので、現時点では，`~min-max接頭辞$ほどには広く~supportされていない。
◎
Note: This syntax is new to Level 4 of Mediaqueries, and thus is not as widely supported at the moment as the min-/max- prefixes.
</p>

<p>
［
特能~名, 比較~演算子, 値
］からなる基本~形に対しては、［
特能~名をその特能の`実~値$, 値を`~test値$
］に解釈した下で、関係性が真になる場合に真を返す。
◎
The basic form, consisting of a feature name, a comparison operator, and a value, returns true if the relationship is true.
</p>

<p class="example">
例えば
`(height &gt; 600px)^css
（あるいは
`(600px &lt; height)^css
）は、表示域の縦幅が `600px^v より大きい場合に真を返す。
◎
For example, (height &gt; 600px) (or (600px &lt; height)) returns true if the viewport height is greater than 600px.
</p>

<p>
残りの，特能~名が 2 つの比較~演算子の間に挟まれた形では、 2 つの比較がいずれも真になる場合に，真を返す。
◎
The remaining forms, with the feature name nested between two value comparisons, returns true if both comparisons are true.
</p>

<p class="example">
例えば
`(400px &lt; width &lt; 1000px)^css
は、表示域の横幅を反映する`実~値$が
`400px^v 〜 `1000px^v
の間にある（両端の値は含まない）場合に真を返す。
◎
For example, (400px &lt; width &lt; 1000px) returns true if the viewport width is between 400px and 1000px (but not equal to either).
</p>

<div class="p">
<p>
`範囲~型$の媒体~特能には、
`負の範囲は偽になる@
とされるものもある。
これは、次を意味する：
</p>

<ul>
	<li>
`~test値$が負であっても妥当であり、構文解析され~MUST。
</li>
	<li>
<p>
`実~値$が負の`~test値$［
に等しい／以下／より小さい
］かどうか照会した結果は、偽に評価され~MUST。
【これは、実質的に，単に “`実~値$は負になり得ない” とする要件と等価になる。】
</p>
<p>
`実~値$が負の`~test値$［
以上／より大きい
］かどうか照会した結果は、その関係性が真ならば真に評価されることになる。
【関係性は常に真になるはずなので、 “ならば” という言い回しはおかしい。】
</p>
	</li>
</ul>

◎
Some media features with a "range" type are said to be false in the negative range. This means that negative values are valid and must be parsed, and that querying whether the media feature is equal to, less than, or less or equal than any such negative value must evaluate to false. Querying whether the media feature is greater, or greater or equal, than a negative value evaluates to true if the relationship is true.
</div>


<p class="note">注記：
代わりに，負の`~test値$が 構文解析する時点で却下された場合、当の照会は，~error取扱い規則に基づいて “未知” として扱われることになる。
しかしながら，ある装置における［
`resolution$d の`実~値$は `-300dpi^v かどうか
］が~~実際に “未知” でなくとも、偽になるのは既知である。
同様に、どの視覚~装置であれ，［
表示~用~区画の `width$d の`実~値$は `-200px^v より大きい
］のは既知である。
上の規則は、~UAが何を行うかの直感に合致するよう，それを反映する。
◎
Note: If negative values had been rejected at parse time instead, they would be treated as unknown based on the error handling rules. However, in reality, whether a device’s resolution is -300dpi is not unknown, it is known to be false. Similarly, for any visual device, the width of the targeted display area is known to be greater than -200px The above rule reflects that, making intuition match what UAs do.
</p>

<div class="example">

<p>
次のいずれの例に対しても、すべての視覚~装置における背景は，~greenになる：
◎
The following examples result in a green background on all visual devices:
</p>


<pre class="lang-css">
@media not (width &lt;= -100px) {
  body { background: green; }
}
</pre>

<pre class="lang-css">
@media (height &gt; -100px) {
  body { background: green; }
}
</pre>

<pre class="lang-css">
@media not (resolution: -300dpi) {
  body { background: green; }
}
</pre>
</div>

<p class="advisement">
この挙動は、~level 3 `MEDIAQ$r からの変更である。
~level 3 においては、これらの~propに対する負の`~test値$に対しては，禁止された値も含め構文~errorとされ、当の`媒体~照会$はまるごと偽にされていた
— この~levelに定義される “未知” 扱いでなく。
~level 3 から更新する実装は，［
<a href="#media-conditions">媒体~特能を組合せて</a>
定義される より多彩な構文
］の~supportを追加するときには、意図されない意味論が導入されないよう，関連する~propに対する負の値の取扱いを変更すること。
◎
This is a behavior change compared to Media Queries Level 3 [MEDIAQ], where negative values on these properties caused a syntax error. In level 3, syntax errors—including forbidden values—resulted in the entire media query being false, rather than the unknown treatment defined in this level. Implementations updating from level 3 should make sure to change the handling of negative values for the relevant properties when they add support for the richer syntax defined in §2.5 Combining Media Features, to avoid introducing unintended semantics.
</p>

			</section>
			<section id="mq-min-max">
<h4 title="Using “min-” and “max-” Prefixes On Range Features">2.4.4. 範囲~型の特能における~min-maxの用法</h4>

<p>
`範囲~型$の特能に対しては、上述の，範囲~文脈の下での`媒体~特能$の評価-法に代えて，
特能~名に~min-max接頭辞を付与して，`素~形$による`媒体~特能$の記し方もできる。
◎
Rather than evaluating a “range” type media feature in a range context, as described above, the feature may be written as a normal media feature, but with a “min-” or “max-” prefix on the feature name.
</p>

<p>
これは、次の様な，`範囲~文脈$の下での特能の評価-法に等価になる：
◎
This is equivalent to evaluating the feature in a range context, as follows:
</p>

	<ul>
		<li>
特能~名に対する "`min-^d" 接頭辞の利用は、 "`&gt;=^css" 演算子の利用に等価になる。
例えば
`(min-height: 600px)^css
は、
`(height &gt;= 600px)^css
に等価になる。
◎
Using a “min-” prefix on a feature name is equivalent to using the “&gt;=” operator. For example, (min-height: 600px) is equivalent to ''(height &gt;= 600px)''.
</li>
	<li>
特能~名に対する "`max-^d" 接頭辞の利用は、
"`&lt;=^css" ~演算子の利用に等価になる。
例えば
`(max-width: 40em)^css
は、
`(width &lt;= 40em)^css
に等価になる。
◎
Using a “max-” prefix on a feature name is equivalent to using the “&lt;=” operator. For example, (max-width: 40em) is equivalent to ''(width &lt;= 40em)''.
</li>
</ul>


<p class="note">注記：
~min-maxによる比較は，その範囲が当の`~test値$も<strong>含む</strong>ので、状況によっては~~限界もある。
◎
Note: because “min-” and “max-” both equate to range comparisons that include the value, they may be limiting in certain situations.
</p>

<div class="example">
<p>
具体例として、~min-maxを用いて，表示域~横幅の ある境目の前後で異なる~styleを定義しようとしている作者は、両~照会とも同時に真に評価されないことを確保するため、一般に，比較している値を少しずらす。
境目が `320px^v にあると見做すなら、作者は，概念的に次を利用するであろう：
◎
For instance, authors trying to define different styles based on a breakpoint in the viewport width using “min-” and “max-” would generally offset the values they’re comparing, to ensure that both queries don’t evaluate to true simultaneously. Assuming the breakpoint is at 320px, authors would conceptually use:
</p>

<pre class="lang-css">
@media (max-width: 320px) { /* <span class="comment">
表示域 ~LTE `320px^v 用の~style
◎
styles for viewports &lt;= 320px
</span> */ }
@media (min-width: 321px) { /* <span class="comment">
表示域 ~GTE `321px^v 用の~style
◎
styles for viewports &gt;= 321px
</span> */ }
</pre>

<p>
これは，表示域の横幅が `320px^v のときに両~styleとも同時に適用されないことを確保しているが、表示域の~sizeが整数でない可能性を織り込んでいない
— それは、画素~密度が整数でないときに生じ得る（例：
高 dpi の~displayや，~zoom／拡縮したとき）。
表示域の横幅が `320px^v 〜 `321px^v の合間に入る場合、両~styleとも適用されないことになる。
◎
While this ensures that the two sets of styles don’t apply simultaneously when the viewport width is 320px, it does not take into account the possibility of fractional viewport sizes which can occur as a result of non-integer pixel densities (e.g. on high-dpi displays or as a result of zooming/scaling). Any viewport widths that fall between 320px and 321px will result in none of the styles being applied.
</p>

<p>
この問題に対処する~approachとして、比較~用に利用される値の精度を増やすことが挙げられる。
上の例で， 2 個目の比較~値を `320.01px^v に変更すれば、その装置~上の表示域~横幅がすき間に入り込むような変化は，有意に抑制される。
◎
One approach to work around this problem is to increase the precision of the values used for the comparison. Using the example above, changing the second comparison value to 320.01px significantly reduces the change that a viewport width on a device would fall between the cracks.
</p>

<pre class="lang-css">
@media (max-width: 320px) { /* <span class="comment">
表示域 ~LTE `320px^v 用の~style
◎
styles for viewports &lt;= 320px
</span> */ }
@media (min-width: 320.01px) { /* <span class="comment">
表示域 ~GTE `320.01px^v 用の~style
◎
styles for viewports &gt;= 320.01px
</span> */ }
</pre>

<p>
しかしながら，このような状況では、（
`&gt;=^css, `&lt;=^css
以外による比較も可能な）`範囲~文脈$による照会が，より適切な解決策を提供する：
◎
However, in these situations, range context queries (which are not limited to “&gt;=” and “&lt;=” comparisons) offer a more appropriate solution:
</p>

<pre class="lang-css">
@media (width &lt;= 320px) { /* <span class="comment">
表示域 ~LTE `320px^v 用の~style
◎
styles for viewports &lt;= 320px
</span> */ }
@media (width &gt; 320px) { /* <span class="comment">
表示域 ~GT `320px^v 用の~style
◎
styles for viewports &gt; 320px
</span> */ }
</pre>
</div>



<p>
`離散~型$の媒体~特能は、`~min-max接頭辞$を受容しない。
その種の接頭辞が付与された媒体~特能は、単純に未知の特能~名と見なされる。
◎
“Discrete” type properties do not accept “min-” or “max-” prefixes. Adding such a prefix to a “discrete” type media feature simply results in an unknown feature name.
</p>

<p class="example">
例えば
`(min-grid: 1)^css
は、無効になる
— `grid$d は`離散~型$の`媒体~特能$であり, 接頭辞を受容しないので（ `grid$d は数的な`~test値$ `0^v ／ `1^v を受容するが，それは真偽値を意味する）。
◎
For example, (min-grid: 1) is invalid, because grid is a “discrete” media feature, and so doesn’t accept the prefixes. (Even though the grid media feature appears to be numeric, as it accepts the values 0 and 1.)
</p>


<p>
`~min-max接頭辞$が付与された`媒体~特能$を，`真偽~文脈$の下で評価させようとする試みは、無効であり，構文~errorである。
◎
Attempting to evaluate a min/max prefixed media feature in a boolean context is invalid and a syntax error.
</p>

			</section>
		</section>
		<section id="media-conditions">
<h3 title="Combining Media Features">2.5. 媒体~特能を組合せるとき</h3>

<p>
真偽値~代数（ `not^vm, `and^vm, `or^vm ）を用いれば、複数の`媒体~特能$を組合せて，一つの
`媒体~条件@
にまとめることができる。
◎
Multiple media features can be combined together into a media condition using full boolean algebra (not, and, or).
</p>

<ul>
	<li>
媒体~特能に `not$vm を前置すれば、否定形にできる。
例えば
`not (color)^css
は、
`(color)^css
の意味を反転する
— `(color)^css は，任意の種類の有色~display装置に合致するので、
`not (color)^css は，有色~displayを除く任意の種類の装置に合致する。
◎
Any media feature can be negated by placing not before it. For example, not (color) inverts the meaning of (color)—since (color) matches a device with any kind of color display, not (color) matches a device without any kind of color display.
</li>
	<li>
複数の媒体~特能を， `and^vm で区切ってつなげることで一体化させれる。
そうして得られた照会は、各 媒体~特能<em>すべて</em>が真になる場合に限り，真になる。
例えば
`(width &lt; 600px) and (height &lt; 600px)^css
は、両~次元とも `600px^css より狭い~screen装置にのみ合致する。
◎
Two or more media features can be chained together, such that the query is only true if all of the media features are true, by placing and between them. For example, (width &lt; 600px) and (height &lt; 600px) only matches devices whose screens are smaller than 600px wide in both dimensions.
</li>
	<li>
また、複数の媒体~特能を，
`or^vm で区切ってつなげることで一体化させれる。
そうして得られた照会は、各 媒体~特能のうち<em>いずれか</em>が真ならば，真になる。
例えば
`(update: slow) or (hover: none)^css
は、［
~screenの更新が遅い（電子書籍~readerなど）か,
<em>または</em>
首~pointing装置が~hover能力を有さない
］ときに合致する
— おそらく、利用者が~hoverするまで小さくたたんでおくような~layoutに代えて，当初から より多く情報を表示する~layoutを利用するべきことを指示する。
◎
Alternately, two or more media features can be chained together, such that the query is true if any of the media features are true, by placing or between them. For example, (update: slow) or (hover: none) matches if the device is slow to update the screen (such as an e-reader) or the primary pointing device has no hover capability, perhaps indicating that one should use a layout that displays more information rather than compactly hiding it until the user hovers.
</li>
	<li>
複数の`媒体~条件$を丸括弧 `()^css で括って~group化すれば、単独の媒体~照会と同じように，条件の中に入子にできる。
例えば
`(not (color)) or (hover)^css
は、~monochromeまたは~hover能力を有する装置に対し，真になる。
~monochrome, かつ~hover能力を<em>有さない</em>装置を照会したいと求めるならば、代わりに
`not ((color) or (hover))^css
と記さ~MUST（あるいは，
`(not (color)) and (not (hover)))^css
でも等価になる）。
◎
Media conditions can be grouped by wrapping them in parentheses () which can then be nested within a condition the same as a single media query. For example, (not (color)) or (hover) is true on devices that are monochrome and/or that have hover capabilities. If one instead wanted to query for a device that was monochrome and didn’t have hover capabilities, it must instead be written as not ((color) or (hover)) (or, equivalently, as (not (color)) and (not (hover))).
</li>
</ul>

<p>
［
`and^vm, `or^vm, `not^vm
］を媒体~照会の同じ “~level” に混在させるのは<em>無効になる</em>。
例えば
`(color) and (pointer) or (hover)^css
は、~~意図が不明瞭なので違法になる。
代わりに、丸括弧を利用して，個々の~keywordごとに~group化する必要がある
— 
`(color) and ((pointer) or (hover))^css,
あるいは
`((color) and (pointer)) or (hover)^css
のように。
これらの 2 つの意味は異なる
— 例えば `(hover)^css のみが真であれば、前者は偽, 後者は真に評価される。
◎
It is invalid to mix and and or and not at the same “level” of a media query. For example, (color) and (pointer) or (hover) is illegal, as it’s unclear what was meant. Instead, parentheses can be used to group things using a particular joining keyword, yielding either (color) and ((pointer) or (hover)) or ((color) and (pointer)) or (hover). These two have very different meanings: if only (hover) is true, the first one evaluates to false but the second evaluates to true.
</p>

		</section>
	</section>
	<section id="mq-syntax">
<h2 title="Syntax">3. 構文</h2>

<p>
前~節に示した 注釈文や線路~図式に現れる媒体~照会の構文は，非公式的~記述であり、公式的な構文は，この節にて `CSS3SYN$r , `CSS3VAL$r にて定義される［
規則／~prop
］文法の構文を用いて述べられる。
◎
Informal descriptions of the media query syntax appear in the prose and railroad diagrams in previous sections. The formal media query syntax is described in this section, with the rule/property grammar syntax defined in [CSS3SYN] and [CSS3VAL].
</p>

<p>
`media-query-list@t
生成規則を構文解析するためには、`~comma区切りの成分~値~listを構文解析-$した結果の各~項目を， `media-query$t として構文解析する。
生産される結果の値は、 `media-query$t の~listになる。
◎
To parse a &lt;media-query-list&gt; production, parse a comma-separated list of component values, then parse each entry in the returned list as a &lt;media-query&gt;. Its value is the list of &lt;media-query&gt;s so produced.
</p>

<p class="note">注記：
この `media-query-list$t の構文解析の明示的な定義は、`媒体~照会~list$の~error回復の挙動が well-defined である【？】ことを必要とする。
◎
Note: This explicit definition of &lt;media-query-list&gt; parsing is necessary to make the error-recovery behavior of media query lists well-defined.
</p>

<p class="note">注記：
この `media-query-list$t 構文解析の定義は、意図的に，空~listも受容するようにされている。
◎
Note: This definition of &lt;media-query-list&gt; parsing intentionally accepts an empty list.
</p>

<p class="note">注記：
`CSS3SYN$r に従って、~tokenは`~ASCII大小無視$である。
◎
Note: As per [CSS3SYN], tokens are ASCII case-insensitive.
</p>

<pre class="prod">
`media-query@t
        = `media-condition$t
        | [ not | only ]? `media-type$t
          [ and `media-condition-without-or$t ]?

`media-type@t
        = `ident$t

`media-condition@t
        = `media-not$t
        | `media-in-parens$t
        | [ `media-and$t* | `media-or$t* ]

`media-condition-without-or@t
        = `media-not$t
        | `media-in-parens$t `media-and$t*

`media-not@t
        = not `media-in-parens$t
`media-and@t
        = and `media-in-parens$t
`media-or@t
        = or `media-in-parens$t

`media-in-parens@t
        = ( `media-condition$t )
        | `media-feature$t
        | `general-enclosed$t

`media-feature@t
        = ( [ `mf-plain$t | `mf-boolean$t | `mf-range$t ] )

`mf-plain@t
        = `mf-name$t : `mf-value$t
`mf-boolean@t
        = `mf-name$t

`mf-range@t
        = `mf-name$t `mf-comparison$t `mf-value$t
        | `mf-value$t `mf-comparison$t `mf-name$t
        | `mf-value$t `mf-lt$t `mf-name$t `mf-lt$t `mf-value$t
        | `mf-value$t `mf-gt$t `mf-name$t `mf-gt$t `mf-value$t

`mf-name@t
        = `ident$t
`mf-value@t
        = `number$t | `dimension$t | `ident$t | `ratio$t

`mf-lt@t
        = '&lt;' '='?
`mf-gt@t
        = '&gt;' '='?
`mf-eq@t
        = '='
`mf-comparison@t
        = `mf-lt$t | `mf-gt$t | `mf-eq$t

`general-enclosed@t
        = [ `function-token$t `any-value$t ) ]
        | ( `ident$t `any-value$t )
</pre>

<p>
`media-type$t 生成規則は、~keyword［
`only$vm, `not$vm, `and^vm, `or^vm
］を含まない。
◎
The &lt;media-type&gt; production does not include the keywords only, not, and, and or.
</p>

<p>
`delim-token$t である［［
"`&lt;^css" ／ "`&gt;^css"
］と, 直後の "`=^css"（もし在れば）
］の合間には、空白は許容されない。
◎
No whitespace is allowed between the “&lt;” or “&gt;” &lt;delim-token&gt;s and the following “=” &lt;delim-token&gt;, if it’s present.
</p>

<p class="note">注記：
~keyword［
`not$vm ／ `and^vm ／ `or^vm
］と後続の文字 "`(^css" との合間には、空白が要求される。
そうでないと `function-token$t に構文解析されるので。
これは、すでに上の文法が受け持っているので明示的に無効にされる【？】ことはない。
一方で、 "`)^css" と後続の~keywordとの合間の空白は，~~問題ない。
◎
Note: Whitespace is required between a not, and, or or keyword and the following ( character, because without it that would instead parse as a &lt;function-token&gt;. This is not made explicitly invalid because it’s already covered by the above grammar. It’s fine to have whitespace between a ) and a following keyword, however.
</p>



<p>
生成規則 `media-in-parens$t の構文解析~時における選択肢 `general-enclosed$t は、入力が先行する選択肢のいずれにも合致しない場合にのみ，選ばれ~MUST。
<span class="note">
`general-enclosed$t は、適度に互換な仕方で，将来における文法の拡張0を許容するために存在する。
</span>
◎
When parsing the &lt;media-in-parens&gt; production, the &lt;general-enclosed&gt; branch must only be chosen if the input does not match either of the preceding branches. &lt;general-enclosed&gt; exists to allow for future expansion of the grammar in a reasonably compatible way.
</p>

		</section>
		<section id="evaluating">
<h3 title="Evaluating Media Queries">3.1. 媒体~照会の評価-法</h3>

<p>
`media-condition$t ／ `media-condition-without-or$t
を成す主要な各 下位式は、以下に挙げる規則に従って，真偽値に評価される：
◎
Each of the major subexpression of &lt;media-condition&gt; or &lt;media-condition-without-or&gt; is associated with a boolean result, as follows:
</p>

<dl class="def-list">
	<dt>`media-condition$t</dt>
	<dt>`media-condition-without-or$t</dt>
	<dd>
子 下位式の結果。
◎
The result is the result of the child subexpression. 
</dd>
	<dt>`media-in-parens$t</dt>
	<dd>
結果は、子~項の結果。
◎
The result is the result of the child term.
</dd>

	<dt>`media-not$t</dt>
	<dd>
結果は、子 `media-in-parens$t 項の否定。
未知の否定は未知とする【下の注記を見よ】。
◎
The result is the negation of the &lt;media-in-parens&gt; term. The negation of unknown is unknown.
</dd>

	<dt class="production">`media-in-parens$t `media-and$t*</dt>
	<dd>
結果は、次に挙げる項が［
すべて真ならば 真 ／
いずれかが偽ならば 偽 ／
他の場合は未知
］
⇒＃
子 `media-in-parens$t 項,
すべての子 `media-and$t 項の子 `media-in-parens$t 項
◎
The result is true if the &lt;media-in-parens&gt; child term and all of the &lt;media-in-parens&gt; children of the &lt;media-and&gt; child terms are true, false if at least one of these &lt;media-in-parens&gt; terms are false, and unknown otherwise.
</dd>

	<dt class="production">`media-in-parens$t `media-or$t*</dt>
	<dd>
結果は、次に挙げる項が［
すべて偽ならば 偽 ／
いずれかが真ならば 真 ／
他の場合は未知
］
⇒＃
子 `media-in-parens$t 項,
すべての子 `media-and$t 項の子 `media-in-parens$t 項
◎
The result is false if the &lt;media-in-parens&gt; child term and all of the &lt;media-in-parens&gt; children of the &lt;media-or&gt; child terms are false, true if at least one of these &lt;media-in-parens&gt; terms are true, and unknown otherwise.
</dd>

	<dt>`general-enclosed$t</dt>
	<dd>
結果は、未知。
◎
The result is unknown.
</dd>
	<dd>
作者は、~stylesheetに `general-enclosed$t を利用してはならない。
◎
↓</dd>
	<dd class="note">
これは，将来の互換性を保つためのみにあり、新たな構文が追加されたときに，古い~UAにおいて `media-condition$t が不能化されないようにするためにある。
◎
Authors must not use &lt;general-enclosed&gt; in their stylesheets. It exists only for future-compatibility, so that new syntax additions do not invalidate too much of a &lt;media-condition&gt; in older user agents.
</dd>

	<dt>`media-feature$t</dt>
	<dd>
<p>
結果は、指定された媒体~特能に対し，前~節にて~~述べた評価-法から与えられる：
</p>

<ul class="trans-note"
	><li>~min-maxなしの `mf-plain$t に対しては
<a href="#mq-plain-context">素~文脈~下での媒体~特能の評価-法</a>
</li><li>`mf-boolean$t に対しては
<a href="#mq-boolean-context">真偽~文脈~下での媒体~特能の評価-法</a>
</li><li>`mf-range$t に対しては
<a href="#mq-range-context">範囲~文脈~下での媒体~特能の評価-法</a>
</li><li>~min-max付きの `mf-plain$t に対しては
<a href="#mq-min-max">範囲~型の特能における~min-maxの用法</a>
</li></ul>

◎
The result is the result of evaluating the specified media feature.
</dd>

</dl>

<p>
上のいずれかの生成規則の結果が，二値~真偽値を期待する文脈で利用される場合、 “未知” は “偽” に変換され~MUST。
◎
If the result of any of the above productions is used in any context that expects a two-valued boolean, “unknown” must be converted to “false”.
</p>

<p class="note">注記：
これは例えば、
`media$at 規則にて`媒体~照会$が利用されるとき、
“未知” に解決されるものは “偽” として扱われ，合致しなくなることを意味する。
◎
Note: This means that, for example, when a media query is used in a @media rule, if it resolves to “unknown” it’s treated as “false” and fails to match.
</p>


<div class="note">注記：
<p>
Media Queries では、各~項が［
“真” , “偽”, “未知”
］のいずれかをとる論理
— 特定的には，
<a href="https://en.wikipedia.org/wiki/Three-valued_logic#Kleene_and_Priest_logics">~Kleeneの三値~論理</a>
【`<a href="https://ja.wikipedia.org/wiki/3%E5%80%A4%E8%AB%96%E7%90%86#.E3.82.AF.E3.83.AA.E3.83.BC.E3.83.8D.E3.81.AE3.E5.80.A4.E8.AB.96.E7.90.86">日本語版</a>^_】
—
を利用する。
この論理における “未知” は、
“真か偽のどちらかだが，まだわからない”
ことを意味する。
◎
Media Queries use a three-value logic where terms can be “true”, “false”, or “unknown”. Specifically, it uses the Kleene 3-valued logic. In this logic, “unknown” means “either true or false, but we’re not sure which yet”.
</p>

<p>
一般に，公式が未知~値を含む場合、その結果は未知になる
— 未知を “真” に置き換えた場合と “偽” に置き換えた場合とで異なるので。
未知~値を消せるのは、未知を真, 偽いずれに置換しようが同じ結果になるとき
— すなわち
“偽 AND 未知” （いずれにせよ偽に評価される）,
“真 OR 未知” （いずれにせよ真に評価される）
—
に限られる。
◎
In general, an unknown value showing up in a formula will cause the formula to be unknown as well, as substituting “true” for the unknown will give the formula a different result than substituting “false”. The only way to eliminate an unknown value is to use it in a formula that will give the same result whether the unknown is replaced with a true or false value. This occurs when you have “false AND unknown” (evaluates to false regardless) and “true OR unknown” (evaluates to true regardless).
</p>

<p>
この論理が採用されている~~理由は、
`general-enclosed$t
に本当の（ truth ）値をあてがう必要があるためである。
標準の真偽~論理で，理に適う値は “偽” に限られるが、これは
<samp class="css">not <mark>未知</mark>(function)</samp>
が真になることを意味し、望ましくない, あるいは混乱を呼ぶ。
~Kleeneの三値~論理は、［
未知~のものは，その値が最終~結果に無関係にならない限り，`媒体~照会$に合致させない
］ことを確保する。
◎
This logic was adopted because &lt;general-enclosed&gt; needs to be assigned a truth value. In standard boolean logic, the only reasonable value is “false”, but this means that not unknown(function) is true, which can be confusing and unwanted. Kleen’s 3-valued logic ensures that unknown things will prevent a media query from matching, unless their value is irrelevant to the final result.
</p>


</div>


		<section id="error-handling">
<h3 title="Error Handling">3.2. ~errorの取扱い</h3>

<p>
前~節の文法に合致しない媒体~照会は、構文解析-時に
`not all^v に置換され~MUST。
◎
A media query that does not match the grammar in the previous section must be replaced by not all during parsing.
</p>

<p class="note">注記：
`媒体~照会~list$における，文法との不一致に際しては、問題ある`媒体~照会$のみが `not all^v に置換される
— ~list全体が一掃されるわけ<strong>ではない</strong>。
また、上で定義される構文解析の挙動は，次に~~現れる~top-levelの~commaで自動的に回復する。
◎
Note: Note that a grammar mismatch does not wipe out an entire media query list, just the problematic media query. The parsing behavior defined above automatically recovers at the next top-level comma.
</p>

<div class="example">

<pre class="lang-css">
@media (example, all,), speech { /* <span class="comment">
発話~装置に限り適用-可能
◎
only applicable to speech devices
</span> */ }
@media &amp;test, speech           { /* <span class="comment">
同上
◎
only applicable to speech devices
</span> */ }
</pre>

<p>
上の`媒体~照会~list$の両者とも，構文解析-時には
`not all, speech^css に転換され、単なる `speech$vm と同じ真偽0値をとる。
◎
Both of the above media query lists are turned into not all, speech during parsing, which has the same truth value as just speech.
</p>


<p>
~error回復は、`媒体~照会$の~top-levelのみに限られることに注意。
括弧で括られた無効な~block内のものは，どれも、単に~groupとして `not all^css に転換される。
例えば：
◎
Note that error-recovery only happens at the top-level of a media query; anything inside of an invalid parenthesized block will just get turned into not all as a group. For example:
</p>

<pre class="lang-css">
@media (example, speech { /* <span class="comment">
発話~装置~用の規則
◎
rules for speech devices
</span> */ }
</pre>

<p>
"`(^c" から~~開始する~blockは閉じられていないので、閉じ括弧 "`)^c" に遭遇するまでの，~stylesheetの残り全部が `not all^css `媒体~照会$に転換される。
◎
Because the parenthesized block is unclosed, it will contain the entire rest of the stylesheet from that point (unless it happens to encounter an unmatched “)” character somewhere in the stylesheet), and turn the entire thing into a not all media query.
</p>

</div>

<p>
未知の `media-type$t は、どの`媒体~型$にも合致しないものと扱わ~MUST。
◎
An unknown &lt;media-type&gt; must be treated as not matching.
</p>

<div class="example">

<p>
例えば，媒体~照会 `unknown^css は、 `unknown^v が未知の`媒体~型$なので，偽になる。
◎
For example, the media query unknown is false, as unknown is an unknown media type.
</p>

<p>
一方 `not unknown^css は、 `not$vm が偽の`媒体~型$を否定形にするので，真になる。
◎
But not unknown is true, as the not negates the false media type.
</p>

</div>

<p class="example">
~keywordには、 `media-type$t として許容されない【すなわち，媒体~型と見なされない】ものもあることに留意。
それは構文解析をまるごと失敗させる：
`or and (color)^css のような媒体~照会は、構文解析-時には，単に `or^vm が未知の`媒体~型$に扱われるのではなく， `not all^css に転換される。
◎
Remember that some keywords aren’t allowed as &lt;media-type&gt;s and cause parsing to fail entirely: the media query or and (color) is turned into not all during parsing, rather than just treating the or as an unknown media type.
</p>

<p>
未知の `mf-name$t ／ `mf-value$t や, 許容されない `mf-value$t に対する結果の値は、 “未知” になる。
値 “未知” をとる `media-query$t は、 `not all^css に置換され~MUST。
◎
An unknown &lt;mf-name&gt; or &lt;mf-value&gt;, or disallowed &lt;mf-value&gt;, results in the value “unknown”. A &lt;media-query&gt; whose value is “unknown” must be replaced with not all.
</p>

<div class="example">

<pre class="lang-ml">
&lt;link
    media="screen and (max-weight: 3kg) and (color), (color)"
    rel="stylesheet"
    href="example.css"
/&gt;
</pre>

<p>
`max-weight^v は，未知の`媒体~特能$なので、この`媒体~照会~list$は， `not all, (color)^css に転換され，単なる `(color)^css に~等価になる。
◎
As max-weight is an unknown media feature, this media query list is turned into not all, (color), which is equivalent to just (color).
</p>

</div>

<div class="example">

<pre class="lang-css">
@media (min-orientation:portrait) { … }
</pre>

<p>
`orientation$d 特能は，接頭辞を受容しないので，
`min-orientation^d は 未知の`媒体~特能$と見なされ，
`not all^css に転換される。
◎
The orientation feature does not accept prefixes, so this is considered an unknown media feature, and turned into not all.
</p>

</div>

<p class="example">
媒体~照会 `(color:20example)^css は、媒体~特能 `color$d に未知の`~test値$を指定するので，
`not all^css に転換される。
◎
The media query (color:20example) specifies an unknown value for the color media feature and is therefore turned into not all.
</p>


<div class="note">

<p>
`媒体~照会$は、~host言語による構文解析~規則の対象になることに注意。
例えば、次の~CSS片：
◎
Note that media queries are also subject to the parsing rules of the host language. For example, take the following CSS snippet:
</p>

<pre class="lang-css">
@media test;,all { body { background:lime } }
</pre>

<p>
において、［
媒体~照会 `test;,all^css 自体を構文解析した結果は， `not all, all^css に等価になり、常に真になる
］が、［
~CSSの構文解析~規則により， `media$at 規則, 従って`媒体~照会$は ~semicolonで終端する
］ので、［
~semicolonより~~後の部分は，無効な［
選択子と内容
］を伴う~style規則として扱われる
］ことになる。
◎
The media query test;,all is, parsed by itself, equivalent to not all, all, which is always true. However, CSS’s parsing rules cause the @media rule, and thus the media query, to end at the semicolon. The remainder of the text is treated as a style rule with an invalid selector and contents.
</p>

</div>

		</section>
	</section>
	<section id="mf-dimensions">
<h2 title="Viewport/Page Dimensions Media Features">4. 表示域や頁の寸法に関する媒体~特能</h2>



		<section id="width">
<h3 title="Width: the width feature">4.1. 横幅： `width^d</h3>

◎述 `width@d
◎用 `media$at
◎値 `length$t
◎型 `範囲$
◎表終

<p>
媒体~特能 `width$d は、出力~装置の表示~対象~区画の横幅を述べる。
連続的~媒体に対しては、これは，`表示域$ `CSS21$r の横幅を意味し，~scrollbarが描画されていれば その~sizeも含まれる。
頁媒体に対しては、これは，`頁~box$の横幅を~~表す（ `CSS21$r 13.2 節にて述べられるように）。
◎
The width media feature describes the width of the targeted display area of the output device. For continuous media, this is the width of the viewport (as described by CSS2, section 9.1.1 [CSS21]) including the size of a rendered scroll bar (if any). For paged media, this is the width of the page box (as described by CSS2, section 13.2 [CSS21]).
</p>

<p>
`length$t は、
<a href="#units">単位 節</a>
に則って解釈される。
◎
&lt;length&gt;s are interpreted according to §1.3 Units.
</p>

<p>
`width$d に対する`負の範囲は偽になる$。
◎
width is false in the negative range.
</p>

<div class="example">

<p>
例えば，次の媒体~照会は、印刷ed出力が 25cm より幅広なときにのみ，~stylesheetが利用されることを表す：
◎
For example, this media query expresses that the style sheet is used on printed output wider than 25cm:
</p>

<pre class="lang-ml">
&lt;link
    rel="stylesheet"
    media="print and (min-width: 25cm)"
    href="http://…"
/&gt;
</pre>

</div>

<div class="example">

<p>
次の媒体~照会は、表示域（~screenや紙に文書が描画される部分）の横幅が 400 〜 700 画素の装置~上にのみ，~stylesheetが利用されることを表す：
◎
This media query expresses that the style sheet is used on devices with viewport (the part of the screen/paper where the document is rendered) widths between 400 and 700 pixels:
</p>

<pre class="lang-css">
@media (400px &lt;= width &lt;= 700px) { … }
</pre>

</div>

<div class="example">

<p>
次の媒体~照会は、表示域の横幅が 20em より大きいときにのみ，~stylesheetが利用されることを表す：
◎
This media query expresses that style sheet is used if the width of the viewport is greater than 20em.
</p>

<pre class="lang-css">
@media (min-width: 20em) { … }
</pre>

<p>
`em$u 単位の値は、 `font-size$p の`初期~値$に相対的になる。
◎
The em value is relative to the initial value of font-size.
</p>

</div>

		</section>
		<section id="height">
<h3 title="Height: the height feature">4.2. 縦幅： `height^d</h3>

◎述 `height@d
◎用 `media$at
◎値 `length$t
◎型 `範囲$
◎表終

<p>
媒体~特能 `height$d は、出力~装置の表示~用~区画の縦幅を述べる。
連続的~媒体に対しては、これは，`表示域$ `CSS21$r の縦幅を意味し，~scrollbarが描画されていれば その~sizeも含まれる。
頁媒体に対しては、これは，頁~boxの縦幅を~~表す（ CSS2, ~節 13.2
`CSS21$r にて述べられるように）。
◎
The height media feature describes the height of the targeted display area of the output device. For continuous media, this is the height of the viewport including the size of a rendered scroll bar (if any). For paged media, this is the height of the page box.
</p>

<p>
`length$t は、
<a href="#units">単位 節</a>
に則って解釈される。
◎
&lt;length&gt;s are interpreted according to §1.3 Units.
</p>

<p>
`height$d に対する`負の範囲は偽になる$。
◎
height is false in the negative range.
</p>

		</section>
		<section id="aspect-ratio">
<h3 title="Aspect-Ratio: the aspect-ratio feature">4.3. 縦横比： `aspect-ratio^d</h3>

◎述 `aspect-ratio@d
◎用 `media$at
◎値 `ratio$t
◎型 `範囲$
◎表終

<p>
媒体~特能 `aspect-ratio$d の`実~値$は、［
媒体~特能 `width$d の`実~値$
］の［
媒体~特能 `height$d の`実~値$
］に対する比率として定義される。
◎
The aspect-ratio media feature is defined as the ratio of the value of the width media feature to the value of the height media feature.
</p>

<div class="p">
<p>
値~型
`ratio@t
は、次の並びで記される：
</p>

<ol ><li>正の `integer$t
</li><li>0 個以上の空白
</li><li>~solidus （ "/" ）
</li><li>0 個以上の空白
</li><li>正の `integer$t
</li></ol>

<p>
`ratio$t は、その 1 個目の `integer$t を 2 個目の `integer$t で割って得られる数により，順序付けたり, 互いに比較できるようになる。
【おそらく、横幅, 縦幅の順】
</p>
◎
The &lt;ratio&gt; value type is a positive (not zero or negative) &lt;integer&gt; followed by optional whitespace, followed by a solidus ('/'), followed by optional whitespace, followed by a positive &lt;integer&gt;. &lt;ratio&gt;s can be ordered or compared by transforming them into the number obtained by dividing their first &lt;integer&gt; by their second &lt;integer&gt;.
</div>



		</section>
		<section id="orientation">
<h3 title="Orientation: the orientation feature">4.4. 方位： `orientation^d</h3>

◎述 `orientation@d
◎用 `media$at
◎値 `portrait$v | `landscape$v
◎型 `離散$
◎表終

<dl>
	<dt>`portrait@v</dt>
	<dd>
媒体~特能 `orientation$d の`実~値$は、［
媒体~特能 `height$d の`実~値$
］が［
媒体~特能 `width$d の`実~値$
］以上ならば，
`portrait^v になる。
◎
The orientation media feature is portrait when the value of the height media feature is greater than or equal to the value of the width media feature. </dd>

	<dt>`landscape@v</dt>
	<dd>
他の場合，
`landscape^v になる。
◎
Otherwise orientation is landscape.
</dd>

</dl>

<div class="example">

<p>
次の~媒体~照会は方位が “縦長” かどうか~testする。
携帯電話を直立に握っているときのように。
◎
The following media query tests for “portrait” orientation, like a phone held upright.
</p>

<pre class="lang-css">
@media (orientation:portrait) { … }
</pre>

</div>

		</section>
	</section>
	<section id="mf-display-quality">
<h2 title="Display Quality Media Features">5. 表示~品質に関する媒体~特能</h2>

		<section id="resolution">
<h3 title="Display Resolution: the resolution feature">5.1. ~display解像度： `resolution^d</h3>

◎述 `resolution@d
◎用 `media$at
◎値 `resolution$t | `infinite$v
◎型 `範囲$
◎表終

<p>
媒体~特能 `resolution$d は、出力~装置の解像度を述べる。
すなわち，`頁~zoom$は織り込みつつ, `~pinch~zoom$は 1.0 と見做した下での画素の密度。
◎
The resolution media feature describes the resolution of the output device, i.e. the density of the pixels, taking into account the page zoom but assuming a pinch zoom of 1.0.
</p>

<p>
`resolution$d に対する`負の範囲は偽になる$。
◎
The resolution media feature is false in the negative range.
</p>

<p>
画素が正方形でない装置を照会する際には、 `resolution$d は，縦~次元の密度を照会する
◎
When querying media with non-square pixels, resolution queries the density in the vertical dimension.
</p>

<p>
印刷機に対しては、これは網点~解像度（任意の有色~dotを印刷するための解像度）に対応する。
この解像度は、~grayscale印刷に対しては異なり得る。
◎
For printers, this corresponds to the screening resolution (the resolution for printing dots of arbitrary color). Printers might have a different resolution for grayscale printing.
</p>

<p>
解像度に物理的な拘束のない出力~媒体（~vector-graphicsを出力するときなど）に対しては、この特能は`~test値$
`infinite@v
に合致し~MUST。
`範囲~文脈$の下でこの媒体~特能を評価する目的においては、
`infinite$v は，可能などの `resolution$t よりも大きいものと扱われ~MUST（すなわち、
`(resolution &gt; 1000dpi)^css
の様な照会は，`実~値$ `infinite$v の媒体に対しては真になる）
◎
For output mediums that have no physical constraints on resolution (such as outputting to vector graphics), this feature must match the infinite value. For the purpose of evaluating this media feature in the range context, infinite must be treated as larger than any possible &lt;resolution&gt;. (That is, a query like (resolution &gt; 1000dpi) will be true for an infinite media.)
</p>


<div class="example">

<p>
次の媒体~照会は、単純に “高解像度” ~screen（~hardware~画素から~CSS `px$u への比率が 2 以上のもの）を検出する：
◎
This media query simply detects “high-resolution” screens (those with a hardware pixel to CSS px ratio of at least 2):
</p>

<pre class="lang-css">
@media (resolution &gt;= 2dppx)
</pre>

</div>

<div class="example">

<p>
例えば，次の媒体~照会は、装置の解像度が 1 ~CSS `in$u あたり 300 ~dot以上のときにのみ，~stylesheetが利用されることを表す：
◎
For example, this media query expresses that a style sheet is used on devices with resolution greater than 300 dots per CSS in:
</p>

<pre class="lang-css">
@media print and (min-resolution: 300dpi) { … }
</pre>

<p>
~CSS `cm$u 単位を利用する，上の例と等価な媒体~照会：
◎
This media query is equivalent, but uses the CSS cm unit:
</p>


<pre class="lang-css">
@media print and (min-resolution: 118dpcm) { … }
</pre>

</div>

<div class="note">
<p>
`resolution$t は、物理的 長さ単位あたりの装置~画素~数ではなく，1 ~CSS画素あたりの装置~画素~数を参照する。
この対応付けは，~UAが決めるので、常に~UAに既知である。
◎
&lt;resolution&gt; does not refer to the number of device pixels per physical length unit, but the number of device pixels per css unit. This mapping is done by the user agent, so it is always known to the user agent.
</p>

<p>
~UAが，物理~画素の幾何について知識を持たない, または
物理~画素の幾何が正方形である（またはそれに十分に近い）ことを知っている場合、~CSS画素あたりの装置~画素~数が，縦~軸と横~軸で異なる数に対応付けられることはない。
したがって、縦, 横いずれの解像度にも違いは生じない。
◎
If the user agent either has no knowledge of the geometry of physical pixels, or knows about the geometry physical pixels and they are (close enough to) square, it would not map a different number of device pixels per css pixels along each axis, and the would therefore be no difference between the vertical and horizontal resolution.
</p>

<p>
他の場合、すなわち，~UAが縦~軸と横~軸で異なる数に対応付けるのは、物理~画素が正方形でないことに呼応してであろう。
~UAがこの知識を得る方法については，この仕様の対象外であるが、装置が 90 度~回転されたものと決めるに十分な情報があれば，対応付けを入替えることができる。
◎
Otherwise, if the UA choses to map a different number along each axis, this would be to respond to physical pixels not being square either. How the UA comes to this knowledge is out of scope, but having enough information to take this decision, it can invert the mapping should the device be rotated 90 degrees.
</p>

</div>





		</section>
		<section id="scan">
<h3 title="Display Type: the scan feature">5.2. ~display型： `scan^d</h3>

◎述 `scan@d
◎用 `media$at
◎値 `interlace$v | `progressive$v
◎型 `離散$
◎表終

<p>
媒体~特能 `scan$d は、一部の出力~装置の走査法を述べる。
◎
The scan media feature describes the scanning process of some output devices.
</p>

<dl data-dfn-for="@media/scan" data-dfn-type="value">
	<dt>`interlace@v</dt>
	<dd>
CRT や一部の~plasma TV ~screenでは、 “~interlaced” 描画が利用されている：
~videoの各~frameに対し、~screen上の “偶数”, “奇数” 走査線を交替的に描画することで，人の知覚における種々の画像補正~能を利用して滑らかな動きを生産する。
これは、半分の帯域幅~costで，より高い FPS 放送を模倣-可能にする。
◎
CRT and some types of plasma TV screens used “interlaced” rendering, where video frames alternated between specifying only the “even” lines on the screen and only the “odd” lines, exploiting various automatic mental image-correction abilities to produce smooth motion. This allowed them to simulate a higher FPS broadcast at half the bandwidth cost.
</dd>
	<dd>
~interlaced~screen上に表示されるときは、作者は， “櫛形残像” を避けるため，~frame間の速い運動を避けるべきである。
また，
<a href="https://en.wikipedia.org/wiki/Interlaced_video#Interline_twitter">“twitter”</a>
【モアレの一種】
を避けるため，~screen上の細部が `1px^v より幅広になることを確保するべきである。
◎
When displaying on interlaced screens, authors should avoid very fast movement across the screen to avoid “combing”, and should ensure that details on the screen are wider than 1px to avoid “twitter”.
</dd>

	<dt>`progressive@v</dt>
	<dd>
“~progressive” 描画を利用する~screenは、各~screenを全部的に表示するような 特別な扱いを要しない。
◎
A screen using “progressive” rendering displays each screen fully, and needs no special treatment.
</dd>
	<dd>
現今の大多数の~screenや, すべての~computer~screenは、~progressive描画を利用する。
◎
Most modern screens, and all computer screens, use progressive rendering.
</dd>

</dl>

<div class="example">

<p>
例えば、~serif~fontによる~~単語 “feet” は、線が細く，~interlaced装置~上では “twitter” を生じさせ得る。
媒体~特能 `scan$d は，これを検出するために利用され、 “twitter” が起こりにくい代替~fontを利用する：
◎
For example, the “feet” of letters in serif fonts are very small features that can provoke “twitter” on interlaced devices. The scan media feature can be used to detect this, and use an alternative font with less chance of “twitter”:
</p>

<pre class="lang-css">
@media (scan: interlace) { body { font-family: sans-serif; } }
</pre>

</div>

<p class="note">注記：
これを書いている時点では、既知の どの実装も，
`scan^d に対しては `interlace^v ではなく `progressive^v に合致する。
◎
Note: At the time of writing, all known implementations match scan: progressive rather than scan: interlace.
</p>

		</section>
		<section id="grid">
<h3 title="Detecting Console Displays: the grid feature">5.3. ~console~displayの検出-法： `grid^d</h3>

◎述 `grid@d
◎用 `media$at
◎値 `mq-boolean$t
◎型 `離散$
◎表終

<p>
媒体~特能 `grid$d は、出力~装置が［
~grid, ~bitmap
］のいずれであるかを照会するために利用される。
出力~装置が~gridに基づく場合（例えば “tty” 端末や, ~~特定の等幅~fontで表示する携帯電話）の`実~値$は `1^v になり、他の場合は `0^v になる。
◎
The grid media feature is used to query whether the output device is grid or bitmap. If the output device is grid-based (e.g., a “tty” terminal, or a phone display with only one fixed font), the value will be 1. Otherwise, the value will be 0.
</p>


<p>
値~型
`mq-boolean@t
は、［
`0^v か `1^v
］のみをとり得る `integer$t 値である。
他のどの整数~値も無効にされる。
<span class="note">注記：
~CSSにおいては， `-0^v は常に `0^v に等価であり,
妥当な `mq-boolean$t 値として受容される。</span>
◎
The &lt;mq-boolean&gt; value type is an &lt;integer&gt; with the value 0 or 1. Any other integer value is invalid. Note that -0 is always equivalent to 0 in CSS, and so is also accepted as a valid &lt;mq-boolean&gt; value.
</p>

<p class="note">注記：
`mq-boolean$t 型は、旧来の目的においてのみ存在する。
今，この特能を設計するなら、それぞれの`実~値$に対応する適正な名前の~keywordを利用するであろう。
◎
Note: The &lt;mq-boolean&gt; type exists only for legacy purposes. If this feature were being designed today, it would instead use proper named keywords for its values.
</p>


<div class="example">

<p>
幅狭な~console~screenを検出する例：
◎
Here is an example that detects a narrow console screen:
</p>

<pre class="lang-css">
@media (grid) and (max-width: 15em) { … }
</pre>

</div>

<p class="note">注記：
これを書いている時点では、既知の どの実装も，
`grid^d に対しては `1^v ではなく `0^v に合致する。
◎
Note: At the time of writing, all known implementations match grid: 0 rather than grid: 1.
</p>

		</section>
		<section id="update">
<h3 title="Display Update Frequency: the update feature">5.4. ~display更新~頻度： `update^d</h3>

◎述 `update@d
◎用 `media$at
◎値 `none$v | `slow$v | `fast$v
◎型 `離散$
◎表終

<p>
媒体~特能 `update$d は、出力~装置が，すでに描画された内容の外観を改変する能を備えているかどうかを 照会するために利用される。
これは、次に挙げる値を受容する：
◎
The update media feature is used to query the ability of the output device to modify the apearance of content once it has been rendered. It accepts the following values:
</p>

<dl data-dfn-for="@media/update" data-dfn-type="value">
	<dt>`none@v</dt>
	<dd>
いったん描画された~layoutは更新されない。
例：紙~上に印刷された文書
◎
Once it has been rendered, the layout can no longer be updated. Example: documents printed on paper.
</dd>

	<dt>`slow@v</dt>
	<dd>
~layoutは~CSSによる通例の規則に則って動的に変化し得るが、出力~装置は，その変化を，滑らかな~animationとして知覚される程 十分~高速に描画する／表示することはできない。
例：
E-ink ~screenや
電力が厳しい装置。
【“描画” — 原語の “render” は他の媒体にも用い得る語であるが、この特能が例えば聴覚~媒体で~~意味をなすとはちょっと考えにくい。】
◎
The layout may change dynamically according to the usual rules of CSS, but the output device is not able to render or display changes quickly enough for them to be perceived as a smooth animation. Example: E-ink screens or severely under-powered devices.
</dd>

	<dt>`fast@v</dt>
	<dd>
~layoutは，~CSSによる通例の規則に則って動的に変化でき、出力~装置にも速度~面で~~特に拘束されることなく， CSS Animations などによる常時更新にも利用できる。
例：~computer~screen。
◎
The layout may change dynamically according to the usual rules of CSS, and the output device is not unusually constrained in speed, so regularly-updating things like CSS Animations can be used. Example: computer screens.
</dd>

</dl>

<div class="example">

<p>
例えば、頁の~styleが~linkに対し ~hover時にのみ下線を引くときでも、印刷されるときは，常に下線を表示するよう求められることもある：
◎
For example, if a page styles its links to only add underlines on hover, it may want to always display underlines when printed:
</p>

<pre class="lang-css">
@media (update) {
  a { text-decoration: none; }
  a:hover, a:focus { text-decoration: underline; }
}
/* <span class="comment">
更新がない~UAにおいては常に、~linkに対する既定の下線が引かれる。
◎
In non-updating UAs, the links get their default underline at all times.
</span> */
</pre>

</div>

		</section>
		<section id="mf-overflow-block">
<h3 title="Block-Axis Overflow: the overflow-block feature">5.5. 塊-軸~方向の~overflow： `overflow-block^d</h3>

◎述 `overflow-block@d
◎用 `media$at
◎値 `none$v | `scroll$v | `optional-paged$v | `paged$v
◎型 `離散$
◎表終

<p>
媒体~特能 `overflow-block$d は、内容が`初期~包含塊$を`塊-軸$方向に~overflowするときの，装置の挙動を述べる。
◎
The overflow-block media feature describes the behavior of the device when content overflows the initial containing block in the block axis.
</p>

<dl data-dfn-for="@media/overflow-block" data-dfn-type="value">
	<dt>`none@v</dt>
	<dd>
`塊-軸$方向の~overflowに対し，便宜を図ることはない
— ~overflowした内容は，単に表示されない。
例：広告欄
◎
There is no affordance for overflow in the block axis; any overflowing content is simply not displayed. Examples: billboards
</dd>

	<dt>`scroll@v</dt>
	<dd>
`塊-軸$方向に~overflowした内容を，利用者による~scrollで露わにできるようにする。
例：~computer~screen
◎
Overflowing content in the block axis is exposed by allowing users to scroll to it. Examples: computer screens
</dd>

	<dt>`optional-paged@v</dt>
	<dd>
`塊-軸$方向に ~overflowしている内容を，利用者による~scrollで露わにできるようにするが、頁~分断を（ `break-inside$p 等を通して）手動で誘発させ，後続の内容を次~頁~以降に表示させ得る。
例：~slideshow
◎
Overflowing content in the block axis is exposed by allowing users to scroll to it, but page breaks can be manually triggered (such as via break-inside, etc) to cause the following content to display on the following page. Examples: slideshows
</dd>

	<dt>`paged@v</dt>
	<dd>
内容は、離散的な頁に分断される
— ある頁~内から`塊-軸$に~overflowする内容は，次の頁~上に表示される。
例：印刷機, 電子書籍~reader。
◎
Content is broken up into discrete pages; content that overflows one page in the block axis is displayed on the following page. Examples: printers, ebook readers
</dd>

</dl>

		</section>
		<section id="mf-overflow-inline">
<h3 title="Inline-Axis Overflow: the overflow-inline feature">5.6. 行内-軸~方向の~overflow： `overflow-inline^d</h3>

◎述 `overflow-inline@d
◎用 `media$at
◎値 `none$v | `scroll$v
◎型 `離散$
◎表終

<p>
媒体~特能 `overflow-inline$d は、［
内容が`初期~包含塊$の`行内-軸$方向に~overflowするとき
］の，装置の挙動を述べる。
◎
The overflow-inline media feature describes the behavior of the device when content overflows the initial containing block in the inline axis.
</p>

<dl data-dfn-for="@media/overflow-inline" data-dfn-type="value">
	<dt>`none@v</dt>
	<dd>
`行内-軸$方向の~overflowに対し，便宜を図ることはない
— ~overflowした内容は，単に表示されない。
◎
There is no affordance for overflow in the inline axis; any overflowing content is simply not displayed.
</dd>

	<dt>`scroll@v</dt>
	<dd>
`行内-軸$方向に~overflowした内容を，利用者による~scrollで露わにできるようにする。
◎
Overflowing content in the inline axis is exposed by allowing users to scroll to it.
</dd>

</dl>

<p class="note">注記：
行内~方向へ~overflowする内容に対し，頁を~~割付けるような既知の実装は無く，概念そのものが~~意味をなさないので、
`overflow-inline$d は，意図的に値 `paged$v をとれないようにされている。
◎
Note: There are no known implementations of paged overflow of inline-overflowing content, and the very concept doesn’t seem to make much sense, so there is intentionally no paged value for overflow-inline.
</p>

		</section>
	</section>
	<section id="mf-colors">
<h2 title="Color Media Features">6. 色に関する媒体~特能</h2>

		<section id="color">
<h3 title="Color Depth: the color feature">6.1. 色~深度 `color^d</h3>

◎述 `color@d
◎用 `media$at
◎値 `integer$t
◎型 `範囲$
◎表終

<p>
媒体~特能は `color$d は、出力~装置における各~色~成分あたりの~bit数を述べる。
非~有色~装置に対する`実~値$は、 `0^v になる。
◎
The color media feature describes the number of bits per color component of the output device. If the device is not a color device, the value is zero.
</p>

<p>
`color$d に対する`負の範囲は偽になる$。
◎
color is false in the negative range.
</p>

<div class="example">

<p>
例えば，次の２つの媒体~照会は、~stylesheetが適用されるのは，装置が有色であるときに限られることを表す：
◎
For example, these two media queries express that a style sheet applies to all color devices:
</p>

<pre class="lang-css">
@media (color) { … }
@media (min-color: 1) { … }
</pre>

</div>

<div class="example">

<p>
次の媒体~照会は、~stylesheetが適用されるのは，装置が有色で, 色の各~成分あたり 8 ~bit以上のときに限られることを表す：
◎
This media query expresses that a style sheet applies to color devices with at least 8 bits per color component:
</p>

<pre class="lang-css">
@media (color &gt;= 8) { … }
</pre>

</div>

<p>
色~成分ごとに~bit数が異なる場合、~~最小の数が利用される。
◎
If different color components are represented by different number of bits, the smallest number is used.
</p>

<p class="example">
例えば ( R, G, B ) 成分を順に ( 3, 3, 2 ) ~bitで表現する 8 ~bit色~systemの場合、 `color$d 媒体~特能の`実~値$は `2^v になる。
◎
For instance, if an 8-bit color system represents the red component with 3 bits, the green component with 3 bits, and the blue component with 2 bits, the color media feature will have a value of 2.
</p>

<p>
有index色~装置に対しては、色~検索表の中の各~色あたりの最小の~bit数が利用される。
◎
In a device with indexed colors, the minimum number of bits per color component in the lookup table is used.
</p>

<p class="note">注記：
上述の機能性が述べ得る色の能力は，表層~levelに限られる。
一般には、 `color-gamut$d の方が作者の必要に~~関連する。
更なる機能性が要求される場合、 `RFC2879$r が、より詳細化された媒体~特能を供する
— 将来的に~supportされ得る。
◎
Note: The described functionality is only able to describe color capabilities at a superficial level. color-gamut, is generally more relevant to authors’ needs. If further functionality is required, RFC2879 [RFC2879] provides more specific media features which may be supported at a later stage.
</p>


		</section>
		<section id="color-index">
<h3 title="Paletted Color Screens: the color-index feature">6.2. 有index色~screen： `color-index^d</h3>

◎述 `color-index@d
◎用 `media$at
◎値 `integer$t
◎型 `範囲$
◎表終

<p>
媒体~特能 `color-index$d は、出力~装置の色~検索表に含まれる色~数を述べる。
色~検索表を利用しない装置に対する`実~値$は、 `0^v になる。
◎
The color-index media feature describes the number of entries in the color lookup table of the output device. If the device does not use a color lookup table, the value is zero.
</p>

<p>
`color-index$d に対する`負の範囲は偽になる$。
◎
color-index is false in the negative range.
</p>


<div class="example">

<p>
例えば，次の２ついずれも、有index色~装置であれば，~stylesheetを適用させることを表す：
◎
For example, here are two ways to express that a style sheet applies to all color index devices:
</p>

<pre class="lang-css">
@media (color-index) { … }
@media (color-index &gt;= 1) { … }
</pre>

</div>


<div class="example">

<p>
次の媒体~照会は、~stylesheetが適用されるのは， 256 色~以上の有index色~装置に限られることを表す：
◎
This media query expresses that a style sheet applies to a color index device with 256 or more entries:
</p>

<pre class="lang-ml">
&lt;?xml-stylesheet
    media="(min-color-index: 256)"
    href="http://www.example.com/…"
?&gt;
</pre>

</div>



		</section>
		<section id="monochrome">
<h3 title="Monochrome Screens: the monochrome feature">6.3. ~monochrome~screen： `monochrome^d</h3>

◎述 `monochrome@d
◎用 `media$at
◎値 `integer$t
◎型 `範囲$
◎表終

<p>
媒体~特能 `monochrome$d は、~monochrome~frame~buffer内の画素あたりの~bit数を述べる。
~monochromeでない出力~装置に対する`実~値$は、 `0^v になる。
◎
The monochrome media feature describes the number of bits per pixel in a monochrome frame buffer. If the device is not a monochrome device, the output device value will be 0.
</p>

<p>
`monochrome$d に対する`負の範囲は偽になる$。
◎
monochrome is false in the negative range.
</p>

<div class="example">

<p>
例えば，次のものは、すべての~monochrome装置に，~stylesheetを適用させることを表す：
◎
For example, this is how to express that a style sheet applies to all monochrome devices:
</p>

<pre class="lang-css">
@media (monochrome) { … }
</pre>

</div>

<div class="example">

<p>
次のものは、画素あたり 2 ~bit以上の~monochrome装置に対し，~stylesheetを適用させること表す。
◎
Express that a style sheet applies to monochrome devices with more than 2 bits per pixels:
</p>

<pre class="lang-css">
@media (monochrome &gt;= 2) { … }
</pre>

</div>


<div class="example">

<p>
有色~頁~用の~stylesheetと
~monochrome用の別の~stylesheetを表す：
◎
Express that there is one style sheet for color pages and another for monochrome:
</p>

<pre class="lang-ml">
&lt;link
    rel="stylesheet"
    media="print and (color)"
    href="http://…"
/&gt;
&lt;link
    rel="stylesheet"
    media="print and (monochrome)"
    href="http://…"
/&gt;
</pre>

</div>

		</section>
		<section id="color-gamut">
<h3 title=" Color Display Quality: the color-gamut feature">6.4. 有色~displayの色域： `color-gamut^d</h3>


◎述 `color-gamut@d
◎用 `media$at
◎値 `srgb$v | `p3$v | `rec2020$v
◎型 `離散$
◎表終

<p>
`color-gamut$d 媒体~特能は、~UAと出力~装置が~supportする色の近似的な範囲を記述する。
すなわち、~UAが指定された色~空間を伴う内容を受け取った場合に、出力~装置に適切な色で，またはそれに十分~近くなるように描画させられる。
◎
The color-gamut media feature describes the approximate range of colors that are supported by the UA and output device. That is, if the UA receives content with colors in the specified space it can cause the output device to render the appropriate color, or something appropriately close enough.
</p>

<p class="note">注記：
この照会は、いくつかの理由から，近似的な範囲を利用するようにされている。
第一に、表示~hardwareには，ばらつきがある。
例えば， "Rec. 2020" を~supportするものと主張する装置であっても、実際には全部的な色域より有意に狭い範囲で描画するものもある。
第二に、~supportされる色~範囲は 装置ごとに多種多様であり，それらすべてを挙げていっては長大になり過ぎる。
ほとんどの事例では、作者は~displayの正確0な能力を知る必要はなく，
sRGB 以上か, または sRGB より有意に良いかを区別するだけで済む。
そうやって，色~profile付きの適切な画像を利用者に~~供せる。
◎
Note: The query uses approximate ranges for a few reasons. Firstly, there are a lot of differences in display hardware. For example, a device might claim to support "Rec. 2020", but actually renders a significantly lower range of the full gamut. Secondly, there are a lot of different color ranges that different devices support, and enumerating them all would be tedious. In most cases the author does not need to know the exact capabilities of the display, just whether it is better than sRGB, or significantly better than sRGB. That way they can serve appropriate images, tagged with color profiles, to the user.
</p>

<dl>
	<dt>`srgb@v</dt>
	<dd>
出力~装置は、
sRGB
に指定されるもの以上の色域を，近似的に~supportできる。
◎
The output device can support approximately the sRGB gamut or more.
</dd>
	<dd class="note">注記：
大部分の有色~displayは、この型の照会に対し真を返せるものと期待できる。
◎
Note: It is expected that the vast majority of color displays will be able to return true to a query of this type.
</dd>

	<dt>`p3@v</dt>
	<dd>
出力~装置は、
DCI P3 Color Space
に指定されるもの以上の色域を，近似的に~supportできる。
◎
The output device can support approximately the gamut specified by the DCI P3 Color Space or more.
</dd>
	<dd class="note">注記：
`p3$v 色域は `srgb$v より~~真に広い。
◎
Note: The p3 gamut is larger than and includes the srgb gamut.
</dd>

	<dt>`rec2020@v</dt>
	<dd>
出力~装置は、
ITU-R Recommendation BT.2020 Color Space
に指定されるもの以上の色域を，近似的に~supportできる。
◎
The output device can support approximately the gamut specified by the ITU-R Recommendation BT.2020 Color Space or more.
 </dd>
	<dd class="note">注記：
`rec2020$v 色域は `p3$v 色域より~~真に広い。
◎
Note: The rec2020 gamut is larger than and includes the p3 gamut.
</dd>
</dl>

<p>
次の表に、これらの色~空間の原色を挙げる
— 各 色は、 `COLORIMETRY$r に定義される，色~空間における純色度（ chromaticity ）座標で表されている：
◎
The following table lists the primary colors of these color spaces in terms of their color space chromaticity coordinates, as defined in [COLORIMETRY].
</p>

<table class="data">
<colgroup span="1"></colgroup>
<colgroup span="2"></colgroup>
<colgroup span="2"></colgroup>
<colgroup span="2"></colgroup>
<colgroup span="2"></colgroup>

<thead>
<tr ><th rowspan="3">色~空間◎ Color Space
</th><th colspan="2" rowspan="2">白色点◎ White Point
</th><th colspan="6">原色◎ Primaries
</th></tr>

<tr ><th colspan="2">Red
</th><th colspan="2">Green
</th><th colspan="2">Blue
</th></tr>

<tr><th>x<sub>W</sub>
</th><th>y<sub>W</sub>
</th><th>x<sub>R</sub>
</th><th>y<sub>R</sub>
</th><th>x<sub>G</sub>
</th><th>y<sub>G</sub>
</th><th>x<sub>B</sub>
</th><th>y<sub>B</sub>
</th></tr></thead>

<tbody>

<tr><td>`srgb$v
</td><td>0.3127
</td><td>0.3290
</td><td>0.640
</td><td>0.330
</td><td>0.300
</td><td>0.600
</td><td>0.150
</td><td>0.060
</td></tr>

<tr><td>`p3$v
</td><td>0.3127
</td><td>0.3290
</td><td>0.680
</td><td>0.320
</td><td>0.265
</td><td>0.690
</td><td>0.150
</td><td>0.060
</td></tr>

<tr><td>`rec2020$v
</td><td>0.3127
</td><td>0.3290
</td><td>0.708
</td><td>0.292
</td><td>0.170
</td><td>0.797
</td><td>0.131
</td><td>0.046
</td></tr></tbody></table>

<p class="note">注記：
上の表に与えた情報は、色~空間を全部的に述べるには十分でないが，出力~装置が当の色域を近似的に受け持てるかどうか決定するには足る。
更なる情報は、［
sRGB については `SRGB$r ／
DCI P3 については `SMPTE-EG-432-1-2010$r, `SMPTE-RP-431-2-2011$r ／
ITU-R Recommendation BT.2020 については `ITU-R-BT-2020-2$r
］を見よ。
◎
Note: The table above does not contains enough information to fully describe the color spaces, but is sufficient to determine whether an output device approximately covers their respective gamuts. See [SRGB] for more information on sRGB, [SMPTE-EG-432-1-2010] and [SMPTE-RP-431-2-2011] for more information on DCI P3, and [ITU-R-BT-2020-2] for more information on ITU-R Recommendation BT.2020.
</p>


<div class="example">

<p>
例えば，次の媒体~照会は、~displayが DCI P3 による色~範囲を~supportするときに適用される：
◎
For example, this media query applies when the display supports colors in the range of DCI P3:
</p>

<pre class="lang-css">
@media (color-gamut: p3) { … }
</pre>

</div>

<p class="note">注記：
出力~装置は、その全部的な出力~色域が十分~広いときや，~supportする色域がある色域を含むならば、この媒体~特能に対する複数の値に対し，真を返し得る。
その結果、この特能は “昇格式に” 利用するのが最適になる
— まず，
`(color-gamut: srgb)^css が真になるならば，基底となる値を設定した上で、
`(color-gamut: p3)^css が真になるならば，それを上書きする，等々。
◎
Note: An output device can return true for multiple values of this media feature, if its full output gamut is large enough, or one gamut is a subset of another supported gamut. As a result, this feature is best used in an "ascending" fashion—set a base value when (color-gamut: srgb) is true, then override it if (color-gamut: p3) is true, etc.
</p>

<p class="note">注記：
~monochrome~displayなど，一部の出力~装置は `srgb$v 色域でさえ~supportし得ない。
これらの装置を~testするときは、この特能を，真偽~文脈の下で
`not (color-gamut)^css のように否定形にして利用できる。
◎
Note: Some output devices, such as monochrome displays, cannot support even the srgb gamut. To test for these devices, you can use this feature in a negated boolean-context fashion: not (color-gamut).
</p>


		</section>
	</section>
	<section id="mf-interaction">
<h2 title="Interaction Media Features">7. 対話~媒体に関する特能</h2>

<p class="note">注記：
次に挙げる媒体~特能は~risk下にある：
`hover$d,
`any-hover$d,
`pointer$d,
`any-pointer$d,
◎
Note: the hover, any-hover, pointer, and any-pointer media features are at risk.
</p>

<p>
“対話” 媒体~特能は、利用者が頁と対話する方法についての種々の側面を反映する。
◎
The “interaction” media features reflect various aspects of how the user interacts with the page.
</p>


<div class="note">

<p>
`pointer$d と `hover$d の種々の組合せに合致する，代表的な装置の例：
◎
Typical examples of devices matching combinations of pointer and hover:
</p>

<table>
<thead><tr><td>
<th>`pointer$d: `~p_none$v
<th>`pointer$d: `coarse$v
<th>`pointer$d: `fine$v
</thead><tbody>

<tr><th>`hover$d: `~h_none$v
<td>
~keyboardのみの制御,
逐次的／空間的 （十字key）~focus-navigation
◎
keyboard-only controls, sequential/spatial (d-pad) focus navigation
<td>
~smartphone, ~touch~screen
◎
smartphones, touch screens
<td>
基本的な~stylus~digitizer（
Cintiq, Wacom,
等々）
◎
basic stylus digitizers (Cintiq, Wacom, etc)

<tr><th>`hover$d: `hover$v
<td>
<td>
Nintendo Wii ~controller, Xbox Kinect
◎
Nintendo Wii controller, Kinect
<td>
~mouse, ~touch~pad, 高度な~stylus~digitizer（
Surface, Samsung Note, Wacom Intuos Pro,
等々）
◎
mouse, touch pad, advanced stylus digitizers (Surface, Samsung Note, Wacom Intuos Pro, etc) 

</tbody></table>

</div>

<p>
［
`pointer$d ／ `hover$d
］特能は “首” ~pointing装置の特性に関係する一方で、［
`any-pointer$d ／ `any-hover$d
］は，可用になり得るすべての~pointing装置の~propを照会するときに利用できる。
◎
The pointer and hover features relate to the characteristics of the “primary” pointing device, while any-pointer and any-hover can be used to query the properties of all potentially available pointing devices.
</p>

<p class="note">注記：
この仕様は，~UAが “首” ~pointing装置が何であるかをどう決めるべきかは 定義しないが、~UAには，［
稼働している装置や環境についての知識,
可用な~pointing装置の個数や型,
これらのどの入力を［
一般に あるいは現在
］利用しているか
］を組合せて，これを決定するべき、と期待されている。
首~入力機構の装置は~pointing装置でないが，利用~頻度がより少ない副次~入力~用の~pointing装置はある状況では、~UAは~pointing装置でないそれを首と扱うことにしてよい（その結果、 `pointer$d の`実~値$は `none$v になる）。
~UAは、利用者~環境や利用者が~UAと対話する仕方の変化に呼応して，どの型の~pointing装置が首と判断されるか 動的に変更することにしてよい。
◎
Note: While this specification does not define how user agents should decide what the “primary” pointing device is, the expectation is that user agents should make this determination by combining knowledge about the device/environment they are running on, the number and type of pointing devices available, and a notion of which of these is generally and/or currently being used. In situations where the primary input mechanism for a device is not a pointing device, but there is a secondary – and less frequently used – input that is a pointing devices, the user agent may decide to treat the non-pointing device as the primary (resulting in 'pointer: none'). user agents may also decide to dynamically change what type of pointing device is deemed to be primary, in response to changes in the user environment or in the way the user is interacting with the UA.
</p>

<p class="note">注記：
［
`pointer$d ／ `hover$d ／ `any-pointer$d ／ `any-hover$d
］特能が関係するのは，~pointing装置の特性や それらの有無に限られ、~keyboardなどの~pointing装置でない入力機構の有無を検出することには利用できない。
作者は、これらの特能を照会した結果に関わらず，~pointing装置でない入力の~~可能性も織り込むべきである。
◎
Note: The pointer, hover, any-pointer and any-hover features only relate to the characteristics, or the complete absence, of pointing devices, and can not be used to detect the presence of non-pointing device input mechanisms such as keyboards. Authors should take into account the potential presence of non-pointing device inputs, regardless of which values are matched when querying these features.
</p>

<p class="note">注記：
［
`pointer$d ／ `hover$d
］は，［
頁の主途の［
~styleと対話~mode
］を（首~pointing装置の特性や有無に基づいて）首~入力機構に適するように設計する
］ために利用できるが、作者は［
`any-pointer$d ／ `any-hover$d
］を利用して，検出され得るすべての型の~pointing装置を織り込むことを強く考慮するべきである。
◎
While pointer and hover can be used to design the main style and interaction mode of the page to suit the primary input mechanism (based on the characteristics, or complete absence, of the primary pointing device), authors should strongly consider using any-pointer and any-hover to take into account all possible types of pointing devices that have been detected.
</p>

		<section id="pointer">
<h3 title="Pointing Device Quality: the pointer feature">7.1. ~pointing装置の品質： `pointer^d</h3>

<p class="note">注記：
この特色機能は~risk下にある。
◎
Note: This feature is at risk.
</p>

◎述 `pointer@d
◎用 `media$at
◎値 `~p_none$v | `coarse$v | `fine$v
◎型 `離散$
◎表終

<p>
媒体~特能 `pointer$d は、~mouseなどの~pointing装置の存在, その正確さを照会するために利用される。
複数の~pointing装置が在る場合、媒体~特能 `pointer$d は，［
~UAにより決定される “首” ~pointing装置
］の特性を反映し~MUST。
（可用な<em>すべての</em>~pointing装置の能力を照会する方法については、媒体~特能 `any-pointer$d を見よ。）
◎
The pointer media feature is used to query the presence and accuracy of a pointing device such as a mouse. If multiple pointing devices are present, the pointer media feature must reflect the characteristics of the “primary” pointing device, as determined by the user agent. (To query the capabilities of any available pointing devices, see the any-pointer media feature.)
</p>

<dl data-dfn-for="@media/pointer" data-dfn-type="value">
	<dt>`~p_none@v</dt>
	<dd>
首~入力機構の装置には、~pointing装置は含まれていない。
◎
The primary input mechanism of the device does not include a pointing device.
</dd>

	<dt>`coarse@v</dt>
	<dd>
首~入力機構の装置には，~pointing装置も含まれているが、その正確さは制限されている。
例として、~touch~screenや~motion検出~sensor（ Xbox の周辺機器 Kinect の様な）が挙げられる。
◎
The primary input mechanism of the device includes a pointing device of limited accuracy. Examples include touchscreens and motion-detection sensors (like the Kinect peripheral for the Xbox.) 
</dd>

	<dt>`fine@v</dt>
	<dd>
首~入力機構の装置には，正確1な~pointing装置も含まれている。
例として、~mouse, ~touch~pad, 手描き~stylusが挙げられる。
◎
The primary input mechanism of the device includes an accurate pointing device. Examples include mice, touchpads, and drawing styluses.
</dd>

</dl>

<p>
`coarse$v, `fine$v のいずれも~pointing装置の存在を指示するが、正確さに関して異なる。
~zoom係数 1 の下で，隣接する小さな対象を確実に摘むことが困難または不可能な~pointing装置では、 `coarse$v が選抜されることになる。
~zoom~levelが変化しても、この媒体~特能の`実~値$には影響しない。
◎
Both coarse and fine indicate the presence of a pointing device, but differ in accuracy. A pointing device with which it would be difficult or impossible to reliably pick one of several small adjacent targets at a zoom factor of 1 would qualify as coarse. Changing the zoom level does not affect the value of this media feature.
</p>

<p class="note">注記：
~UAは、利用者に~zoom能や正確さが異なる副次~pointing装置も供し得るので、この媒体~特能の`実~値$が `coarse$v であっても，利用者が正確1な~clickを行えることはあり得る。
この値は、利用者が決して正確1に~clickできないことを指示するものではなく，多少の手間を要することのみを指示する。
作者には、 `coarse$v 値への~~反応として，正確1な~click操作に依拠しない頁を設計することが期待されている。
◎
Note: As the UA may provide the user with the ability to zoom, or as secondary pointing devices may have a different accuracy, the user may be able to perform accurate clicks even if the value of this media feature is coarse. This media feature does not indicate that the user will never be able to click accurately, only that it is inconvenient for them to do so. Authors are expected to react to a value of coarse by designing pages that do not rely on accurate clicking to be operated.
</p>

<p>
~accessibilityの理由から、装置が備える~pointing装置が `fine$v として記述できるとしても、~UAは，利用者が~pointing装置の正確1な操作が困難あるいは全く操作できないことを指示するためとして，この媒体~照会の`実~値$に［
`coarse$v ／ `~p_none$v
］を与えてよい。
加えて、首~pointing装置の正確さが `fine$v であっても，正確さが `coarse$v の~pointing装置も追加で利用者に可用にされ得るので、そのような装置があり得ることも織り込むため，媒体~特能 `any-pointer$d を照会したいと望むこともあろう。
◎
For accessibility reasons, even on devices whose pointing device can be described as fine, the UA may give a value of coarse or none to this media query, to indicate that the user has difficulties manipulating the pointing device accurately or at all. In addition, even if the primary pointing device has fine pointing accuracy, there may be additional coarse pointing devices available to the user. Authors may wish to query the any-pointer media feature to take these other coarse potential pointing devicess into account.
</p>

<div class="example">

<pre class="lang-css">
/* <span class="comment">
正確1でない首~pointing装置の下では，~radio-buttonや~check-boxを大きくする
◎
Make radio buttons and check boxes larger if we have an inaccurate primary pointing device
</span> */
@media (pointer:coarse) {
  input[type="checkbox"], input[type="radio"] {
    min-width:30px;
    min-height:40px;
    background:transparent;
  }
}
</pre>

</div>



		</section>
		<section id="hover">
<h3 title="Hover Capability: the hover feature">7.2. ~hover能力： `hover^d</h3>

<p class="note">注記：
この特色機能は~risk下にある。
◎
Note: This feature is at risk.
</p>

◎述 `hover@d
◎用 `media$at
◎値 `~h_none$v | `hover$v
◎型 `離散$
◎表終

<p>
媒体~特能 `hover$d は、［
頁~上の要素に対する首~pointing装置による~hover能
］を照会するために利用される。
複数の~pointing装置が在る場合、媒体~特能 `hover$d は，［
~UAにより決定される “首” ~pointing装置
］の特性を反映し~MUST。
（可用な~pointing装置 <em>すべて</em> の能力を照会する方法については、媒体~特能 `any-hover$d を見よ。）
◎
The hover media feature is used to query the user’s ability to hover over elements on the page with the primary pointing device. If a device has multiple pointing devices, the hover media feature must reflect the characteristics of the “primary” pointing device, as determined by the user agent. (To query the capabilities of any available pointing devices, see the any-hover media feature.)
</p>

<dl data-dfn-for="@media/hover" data-dfn-type="value">
	<dt>`~h_none@v</dt>
	<dd>
首~pointing装置は［
無い, または それは~hoverできない
］ことを指示する。
例として、［
~touch~screen ／
基本的な手描き~stylusを利用する~screen
］が挙げられる。
◎
Indicates that the primary pointing device can’t hover, or that there is no pointing device. Examples include touchscreens and screens that use a basic drawing stylus.
</dd>
	<dd>
~hoverはできるが，通常の利用の仕方の一部でなく不便であるような~pointing装置も、この値に合致する。
例えば，長押しが~hoverに扱われるような~touch~screenは、
`hover$d: `none^v に合致することになる。
◎
Pointing devices that can hover, but for which doing so is inconvenient and not part of the normal way they are used, also match this value. For example, a touchscreen where a long press is treated as hovering would match hover: none.
</dd>

	<dt>`hover@v</dt>
	<dd>
首~pointing装置は、頁の各~所で容易に~hoverできることを指示する。
例として、 Nintendo Wii ~controllerの様な，~mouse, ~screen上の点を物理的に指す装置などが挙げられる。
◎
Indicates that the primary pointing device can easily hover over parts of the page. Examples include mice and devices that physically point at the screen, like the Nintendo Wii controller.
</dd>

</dl>

<div class="example">

<p>
例えば，~touch~screen装置では、~mouseでも制御できるとしても，首~pointing装置（~touch~screen）では利用者は~hoverできないので，`hover$d `媒体~特能$は `~h_none$v に合致するべきである。
◎
For example, on a touch screen device that can also be controlled by an optional mouse, the hover media feature should match hover: none, as the primary pointing device (the touch screen) does not allow the user to hover.
</p>

<p>
しかしながら、利用者は副~mouseでは~hoverできる。
従って，作者は、［
`hover$d: `none^v が真に評価される装置~上では， `:hover^css 疑似類は決して合致しない
］と見做さないよう注意深くなるべきであるが、~hoverできなくても全部的に利用可能になるように~layoutを設計するべきである。
◎
However, despite this, the optional mouse does allow users to hover. Authors should therefore be careful not to assume that the ':hover' pseudo class will never match on a device where 'hover:none' is true, but they should design layouts that do not depend on hovering to be fully usable.
</p>

</div>

<p>
~accessibilityの理由から、~UAは，装置が~hoverを~supportするときでも、それなしでもきちんと働く~layoutも選択可能にするために， `hover$d の`実~値$に `~h_none$v を与えてよい。
また，首~入力機構の `hover$d の`実~値$が `hover$v のときでも、利用者には~hover能力のない入力機構も追加で可用にされ得ることに注意。
◎
For accessibility reasons, even on devices that do support hovering, the UA may give a value of hover: none to this media query, to opt into layouts that work well without hovering. Note that even if the primary input mechanism has 'hover: hover' capability, there may be additional input mechanisms available to the user that do not provide hover capabilities.
</p>

<div class="example">

<pre class="lang-css">
/* <span class="comment">
簡便に~hover可能な装置~上でのみ，~hoverで作動化される~drop-down-menuを用いる
◎
Only use a hover-activated drop down menu on devices that can conveniently hover.
</span> */
@media (hover) {
  .menu &gt; li        {display:inline-block;}
  .menu ul          {display:none; position:absolute;}
  .menu li:hover ul {display:block; list-style:none; padding:0;}
  /* ... */
}
</pre>

</div>



		</section>
		<section id="any-input">
<h3 title="All Available Interaction Capabilities: the any-pointer and any-hover features">7.3. 可用なすべての対話~能力： `any-pointer^d, `any-hover^d</h3>

<p class="note">注記：
この特色機能は~risk下にある。
◎
Note: This feature is at risk.
</p>

◎述 `any-pointer@d
◎用 `media$at
◎値 `~p_none$v | `coarse$v | `fine$v
◎型 `離散$
◎表終

◎述 `any-hover@d
◎用 `media$at
◎値 `~h_none$v | `hover$v
◎型 `離散$
◎表終

<p>
媒体~特能 `any-pointer$d ／ `any-hover$d は、利用者に可用なすべての~pointing装置の能力の和集合に対応することを除いて，媒体~特能 `pointer$d ／ `hover$d と~~同じになる。
`any-pointer$d の事例では、~pointing装置ごとに特性が異なる場合には，合致する`~test値$は複数あり得る。
◎
The any-pointer and any-hover media features are identical to the pointer and hover media features, but they correspond to the union of capabilities of all the pointing devices available to the user. In the case of any-pointer, more than one of the values can match, if different pointing devices have different characteristics.
</p>

<p>
`any-pointer$d ／ `any-hover$d
に対する`~test値$ `none^v が合致するのは、どの~pointing装置の`実~値$も `none^v に合致するか，~pointing装置は皆無のときに限られ~MUST。
◎
any-pointer and any-hover must only match none if all of the pointing devices would match none for the corresponding query, or there are no pointing devices at all.
</p>


<p class="note">注記：
`any-pointer$d は、~pointing装置の存在, および その正確さを照会するために利用される。
それは、~pointing装置でない入力は織り込まない
— すなわち、~screen上の~pointerを移動しない［
十字key／~keyboard
］のみによる~controlなどの，他の入力機構の存在を~testするときには利用できない。
`any-pointer$d に対する`~test値$ `none^v が真に評価されるのは、~pointing装置は皆無の場合に限られる。
◎
any-pointer is used to query the presence and accuracy of pointing devices. It does not take into account any additional non-pointing device inputs, and can not be used to test for the presence of other input mechanisms, such as d-pads or keyboard-only controls, that don’t move an on-screen pointer. 'any-pointer:none' will only evaluate to true if there are no pointing devices at all present.
</p>

<p class="example">
~mouseと~keyboardを備える伝統的な~desktop環境においては、
`any-pointer$d に対する`~test値$ `none^v は，非~pointer入力（~keyboard）が在っても（~mouseの存在に因り）偽になる。
◎
On a traditional desktop environment with a mouse and keyboard, 'any-pointer:none' will be false (due to the presence of the mouse), even though a non-pointer input (the keyboard) is also present.
</p>

<p class="note">注記：
`any-hover$d に対する`~test値$ `none^v が真に評価されるのは、どの~pointing装置も~hover能力を欠くか，~pointing装置は皆無の場合に限られる。
そのようなわけで、~hover能力無しの~pointing装置が 一つでも在るかどうかではなく，~hover能力有りの~pointing装置が 一つでも在るかどうかを~testする照会として，解されるべきである。
前者については、現時点では `any-hover$d その他の対話~用の媒体~特能を用いては決定できない。
加えて、元来~hover能力無しの［
十字key／~keyboard
］のみによる制御など，~pointing装置でない入力は織り込まれない。
◎
'any-hover:none' will only evaluate to true if there are no pointing devices, or if all the pointing devices present lack hover capabilities. As such, it should be understood as a query to test if any hover-capable pointing devices are present, rather than whether or not any of the pointing devices is hover-incapable. The latter scenario can currently not be determined using any-hover or any other interaction media feature. Additionally, it does not take into account any non-pointing device inputs, such as d-pads or keyboard-only controls, which by their very nature are also not hover-capable.
</p>

<p class="example">
~mouseや~touch~screenを備える~touch操作可能な機器においては、
`any-hover$d に対する`~test値$ `none^v は、~hover能力無しの~pointing装置 （~touch~screen）が在っても（~hover能力有りの~mouseが在ることに因り）偽に評価されることになる。
現時点では、~pointing装置ごとに~hover能力が異なる事例において，異なる~styleを供することは可能でない。
◎
On a touch-enabled laptop with a mouse and a touchscreen, 'any-hover:none' will evaluate to false (due to the presence of the hover-capable mouse), even though a non-hover-capable pointing device (the touchscreen) is also present. It is currently not possible to provide different styles for cases where different pointing devices have different hover capabilities.
</p>

<p class="note">注記：
［
`any-hover$d ／ `any-pointer$d
が，これらの能力を備える入力機構が 1 つ以上は可用であることを指示する
］ことに基づいて，［
~hover, あるいは正確1な~pointing
］のみに依拠するような頁を設計しても、使用感が悪くなる可能性が高い。
しかしながら，作者は、この情報を利用して，［
利用者に可用な追加の~pointing装置に基づいて，供したいと望む~styleと機能性についての裁定を伝える
］こともできる。
◎
Designing a page that relies on hovering or accurate pointing only because any-hover or any-pointer indicate that at least one of the available input mechanisms has these capabilities is likely to result in a poor experience. However, authors may use this information to inform their decision about the style and functionality they wish to provide based on any additional pointing devices that are available to the user.
</p>

<div class="example">
<p>
~screen上で~cursorを制御できる~smart TV は，いくつもあるが、正確1には操作0し難い ~~簡素な~controllerであることが多い。
◎
A number of smart TVs come with a way to control an on-screen cursor, but it is often fairly basic controller which is difficult to operate accurately.
</p>

<p>
そのような~smart TV における~browserでは、
`pointer$d, `any-pointer$d
のいずれも `coarse$v を`実~値$にとり、作者は，対象が大きく~clickし易い~layoutを供せるようになる。
◎
A browser in such a smart TV would have coarse as the value of both pointer and any-pointer, allowing authors to provide a layout with large and easy to reach click targets.
</p>

<p>
利用者は，~bluetooth~mouseを備えた TV を持っていて，ときには余分の利便性のためにそれを利用することもあるが、そのような~mouseは， TV を操作0する主途の仕方ではない。
`pointer$d は依然として `coarse$v に合致する一方で，
`any-pointer$d は今度は `coarse$v, `fine$v の両者に合致する。
【`実~値$は、これら 2 つの値からなる集合になる。】

◎
The user may also have paired a Bluetooth mouse with the TV, and occasionally use it for extra convenience, but this mouse is not the main way the TV is operated. pointer still matches coarse, while any-pointer now both matches coarse and fine.
</p>

<p>
<code class="css">(`any-pointer^d: `fine^v)</code>
が今度は真になる事実に基づいて，小さい~click対象に切替えるのは、適切にならないであろう。
それは、 TV に期待される使用感を逸脱して利用者を驚かせるだけでなく、ごく不便にもなり得る：
普段 TV の制御に使わない~mouseは、手の届かない，ソファのクッションの下に隠れているかもしれない…
◎
Switching to small click targets based on the fact that (any-pointer: fine) is now true would not be appropriate. It would not only surprise the user by providing an experience out of line with what they expect on a TV, but may also be quite inconvenient: the mouse, not being the primary way to control the TV, may be out of reach, hidden under one of the cushions on the sofa...
</p>

<p>
対照的に、同じ TV 上で~scrollすることを考える。
~scrollbarは、正確1な~pointing装置でなければ操作し難い。
<code class="css">(`pointer^d: `coarse^v)</code>
が真になることに基づいて、［
見れる内容が更にあることを指示する，代替になる仕方
］も用意された下では、作者は，依然として［
<code class="css">(`pointer^d: `fine^v)</code>
が真のときは，追加で~scrollbarを示し、偽のときは，まるごと隠して視覚的にスッキリさせる
］ことを求めることができる。
◎
By contrast, consider scrolling on the same TV. Scrollbars are difficult to manipulate without an accurate pointing device. Having prepared an alternative way to indicate that there is more content to be seen based on (pointer: coarse) being true, an author may want to still show the scrollbars in addition if (any-pointer: fine) is true, or to hide them altogether to reduce visual clutter if (any-pointer: fine) is false.
</p>

</div>

		</section>
	</section>
	<section id="mf-deprecated">
<h2 title="Appendix A: Deprecated Media Features">8. 非推奨にされた媒体~特能</h2>

<p>
以下の`媒体~特能$は <strong>非推奨にされた</strong>。
それらの後方互換性は保たれるが、新たに記される~stylesheetには適切でない。
作者は、それらを利用してはならない。
~UAは、それらを指定された通りに~supportし~MUST。
◎
The following media features are deprecated. They kept for backward compatibility, but are not appropriate for newly written style sheets. Authors must not use them. User agents must support them as specified.
</p>

<p class="note">
表示域（頁媒体の場合は頁~box）の~sizeを照会する場合は、`媒体~特能$［
`width$d, `height$d, `aspect-ratio$d
］が利用されるべきである
— ［
`device-width$d, `device-height$d, `device-aspect-ratio$d
］ではなく
— これらは、~layoutされている文書に可用な空間の大きさに関わらず，装置の物理的~sizeを参照するので。
`device-*^d `媒体~特能$は、携帯機器かどうか検出するための代用1として用いられることもあるが、作者は代わりに、~style付けを試みる装置の側面を より良く表現する`媒体~特能$を，利用するべきである。
◎
To query for the size of the viewport (or the page box on page media), the width, height and aspect-ratio media features should be used, rather than device-width, device-height and device-aspect-ratio, which refer to the physical size of the the device regardless of how much space is available for the document being laid out. The device-* media features are also sometimes used as a proxy to detect mobile devices. Instead, authors should use media features that better represent the aspect of the device that they are attempting to style against.
</p>

		<section id="device-width">
<h3>`device-width^d</h3>

◎述 `device-width@d
◎用 `media$at
◎値 `length$t
◎型 `範囲$
◎表終

<p>
媒体~特能 `device-width$d は、出力~装置の描画面の横幅を述べる。
この特能の`実~値$は、連続的~媒体に対しては，`~Webに公開される~screen区画$の横幅になり、頁媒体に対しては，頁~sheet~sizeの横幅になる。
◎
The device-width media feature describes the width of the rendering surface of the output device. For continuous media, this is the width of the Web-exposed screen area. For paged media, this is the width of the page sheet size.
</p>

<p>
`device-width$d に対する`負の範囲は偽になる$。
◎
device-width is false in the negative range.
</p>


<div class="example">

<pre class="lang-css">
@media (device-width &lt; 800px) { … }
</pre>

<p>
上の例の~stylesheetは、長さ `800px^v より小さい~screenにのみ適用されることになる。
<a href="#units">単位</a> 節にて述べられるように、
`px$u 単位は，物理的~画素ではなく論理的なものによる。
◎
In the example above, the style sheet will apply only to screens less than 800px in length. The px unit is of the logical kind, as described in the Units section.
</p>

</div>

<p class="note">注記：
縦長／横長など，複数の方位で利用できる装置に対しては、媒体~特能 `device-*^d は，現在の方位も反映する。
◎
Note: If a device can be used in multiple orientations, such as portrait and landscape, the device-* media features reflect the current orientation.
</p>

		</section>
		<section id="device-height">
<h3>`device-height^d</h3>

◎述 `device-height@d
◎用 `media$at
◎値 `length$t
◎型 `範囲$
◎表終

<p>
媒体~特能 `device-height$d は、出力~装置の描画面の縦幅を述べる。
この特能の`実~値$は、連続的~媒体に対しては，`~Webに公開される~screen区画$の縦幅になり、頁媒体に対しては，頁~sheet~sizeの縦幅になる。
◎
The device-height media feature describes the height of the rendering surface of the output device. For continuous media, this is the height of the Web-exposed screen area. For paged media, this is the height of the page sheet size.
</p>

<p>
`device-height$d に対する`負の範囲は偽になる$。
◎
device-height is false in the negative range.
</p>

<div class="example">

<pre class="lang-ml">
&lt;link
    rel="stylesheet"
    media="(device-height &gt; 600px)"
/&gt;
</pre>

<p>
上の例では、~stylesheetは，縦方向に 600 画素より高い~screenのみに適用されることになる。
`px$u 単位の定義は~CSSの他の部分と同じであることに注意。
◎
In the example above, the style sheet will apply only to screens taller than 600 vertical pixels. Note that the definition of the px unit is the same as in other parts of CSS.
</p>

</div>

		</section>
		<section id="device-aspect-ratio">
<h3>`device-aspect-ratio^d</h3>

◎述 `device-aspect-ratio@d
◎用 `media$at
◎値 `ratio$t
◎型 `範囲$
◎表終

<p>
媒体~特能 `device-aspect-ratio$d の`実~値$は、媒体~特能 `device-width$d の`実~値$から媒体~特能 `device-height$d の`実~値$への比率として定義される。
◎
The 'device-aspect-ratio media feature is defined as the ratio of the value of the device-width media feature to the value of the 'device-height media feature.
</p>

<div class="example">

<p>
例えば、［
画素が正方形で，横 × 縦が 1280 × 720 画素
］の~screen装置（いわゆる “16:9” ）に対しては、次に挙げるどの媒体~照会も合致することになる：
◎
For example, if a screen device with square pixels has 1280 horizontal pixels and 720 vertical pixels (commonly referred to as “16:9”), the following media queries will all match the device:
</p>

<pre class="lang-css">
@media (device-aspect-ratio: 16/9) { … }
@media (device-aspect-ratio: 32/18) { … }
@media (device-aspect-ratio: 1280/720) { … }
@media (device-aspect-ratio: 2560/1440) { … }
</pre>

</div>

		</section>
	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<dl class="changes">
	<dt id="changes-2017-9">
<a href="https://www.w3.org/TR/2017/CR-mediaqueries-4-20170905/">2017 年 9 月 5 日付 勧告候補</a>
からの変更点：
◎
Changes since the 5 Septemper 2017 Candidate Recommendation
◎
The following changes were made to this specification since the 5 September 2017 Candidate Recommendation: 
</dt>
	<dd>
`speech$vm 媒体~型は、純粋な音声~UA用にあり，~screenreader
— その名が指示するように，~screenに具現化した結果に基づいて働く~UA —
用ではないことを明確化した。
◎
Clarify that the speech media type is for pure audio UAs, not screen readers, which as their name indicates, work based on a screen rendition.
</dd>
	<dd>
`CSS3SYN^r を参照して，~tokenの構文解析は ~ASCII大小無視であることを喚起する注記を追加した。
◎
Add note referencing the syntax spec to remind that token parsing is ascii case insensitive
</dd>
	<dd>
比較を伴わない `(width 500px)^v の様な形を不意に許容していた文法を修正した。
◎
Fix a bug in the grammar that accidentally allowed forms like (width 500px), without any comparison
</dd>

	<dt id="changes-2017">
<a href="https://www.w3.org/TR/2017/WD-mediaqueries-4-20170519/">2017 年 5 月 19 日付 作業草案</a>
からの変更点：
◎
Changes since the 19 May 2017 Working Draft
◎
The following changes were made to this specification since the 19 May 2017 Working Draft :
</dt>
	<dd>
`範囲~型$の媒体~特能に対する負の値は、構文解析に失敗するのでなく，`負の範囲は偽になる$よう変更した。
◎
Changed range media features to be false in the negative range instead of failing to parse negative values.
</dd>
	<dd>
色域に必要な色~空間についての十分な情報を，仕様の中に直に含ませた。
◎
Included enough informaton about the color spaces needed by color-gamut directly into the specification.
</dd>

	<dt id="changes-2012">
<a href="https://www.w3.org/TR/css3-mediaqueries/">2012 年 6 月 19 日付 勧告 Media Queries Level 3</a>
からの変更点：
◎
Changes Since Media Queries Level 3
◎
The following changes were made to this specification since the 19 June 2012 Recomendation of Media Queries Level 3:
</dt>
	<dd>
大幅な，編集上の書直しと再編成。
◎
Large editorial rewrite and reorgization of the document.
</dd>
	<dd>
<a href="#mq-boolean-context">真偽~文脈</a>下での`媒体~特能$は、今や，`素~文脈$の下で`~test値$が~keyword `none^v であるとき真に評価される場合も，偽に評価される。
◎
Boolean-context media features are now additionally false if they would be true for the keyword none.
</dd>
	<dd>
数的な値をとる`媒体~特能$は、今や
<a href="#mq-range-context">範囲~文脈</a>
の下で評価されるように記せる。
◎
Media features with numeric values can now be written in a range context.
</dd>
	<dd>
次に挙げる媒体~特能が追加された
⇒
`pointer$d,
`any-pointer$d,
`hover$d,
`any-hover$d,
`update$d,
`color-gamut$d,
`overflow-block$d,
`overflow-inline$d
◎
The pointer, any-pointer, hover, any-hover, update, color-gamut, overflow-block, and overflow-inline media features were added.
</dd>
	<dd>
`or^vm, `and^vm, `only$vm, `not$vm
は、`媒体~型$として認識されなくされた
— 無効な`媒体~型$としても（代わりに構文~errorを誘発する）。
◎
or, and, only and not are disallowed from being recognized as media types, even invalid ones. (They’ll trigger a syntax error instead.)
</dd>
	<dd>
`screen$vm,
`print$vm,
`speech$vm,
`all$vm
を除くすべての`媒体~型$は、非推奨にされた。
◎
All media types except for screen, print, speech, and all are deprecated.
</dd>
	<dd>
`device-width$d,
`device-height$d,
`device-aspect-ratio$d
は、非推奨にされた。
加えて，~privacyと保安~上の理由から、それらは，~screenに代えて`~Webに公開される~screen区画$を指すようにされた。
◎
Deprecated device-width, device-height, device-aspect-ratio, and made them refer to the Web-exposed screen area instead of the screen for privacy and security reasons.
</dd>
	<dd>
一部の事例では、 Mediaqueries は~stylesheetの評価に依存する。
【？】
◎
Mediaqueries may depend on the evaluation of style sheets in some cases
</dd>
</dl>


	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様は、 W3C Working Group による，
Cascading Style Sheets における成果である。
<span lang="en">
This specification is the product of the W3C Working Group on Cascading Style Sheets.
</span></p>

<p>
この仕様の向上に寄与するコメントを寄せられた次の方々に：
</p>

<p lang="en-x-a0">
Comments from

Arve Bersvendsen,
Björn Höhrmann,
Chris Lilley,
Christoph Päper,
L. David Baron,
Elika J. Etemad,
François Remy,
Melinda Grant,
Nicholas C. Zakas
Patrick H. Lauke,
Philipp Hoschka,
Rick Byers,
Rijk van Geijtenbeek,
Roger Gimson,
Sigurd Lerstad,
Simon Kissane,
Simon Pieters,
Steven Pemberton,
and Susan Lesch

improved this specification.
</p>


	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">9. ~privacyと保安~上の考慮点</h2>

<p>
この仕様により，新たな保安~上の考慮点が導入されることはない。
◎
This specification introduces no new security considerations.
</p>

<p>
Media Queries は、~scriptingからは見出すのが困難または不可能なものも含め，頁~環境の種々の側面を~CSSから照会することを可能化する。
これは、利用者からの指紋収集を強化して，~privacyを危める要因になるが、その~riskは一般に低い。
同じ情報は、少なくとも~scriptingにより User Agent 文字列を精査することを介して <em>推定-可能</em> になるはずなので。
しかしながら， UA 文字列の偽装は Media Queries には影響しないので、検出~技法をいくぶん堅牢にするものにはなる。
◎
Media Queries enable CSS to query various aspects of the page’s environment, including things that can be difficult or impossible to find via scripting. This is potentially a privacy hazard, allowing enhanced fingerprinting of a user, but the risk is generally low. At minimum, the same information should be inferrable via scripting by examining the User Agent string. However, UA string spoofing does not affect Media Queries, making this a somewhat more robust detection technique.
</p>

<p>
それでも、 Media Queries により是認される情報は比較的 粗く，これに関して多くの情報量を供与するものではない。
◎
That said, the information granted by Media Queries is relatively coarse, and does not contribute much entropy in this regard.
</p>


<p>
少数の旧来の媒体~特能（
`device-width$d, `device-height$d, `device-aspect-ratio$d
）は、そうすることに明瞭な便益はないのに，~UAが稼働している環境についての情報を公開する。
それらは互換性の理由から~~保たれるが、~privacyと保安のため，~UAには不正確な情報を報告することも許容される。
◎
A few legacy Media Features (device-width, device-height, and device-aspect-ratio) expose information about the environment in which the UA is running without any clear benefit to doing so. They are retained for compatibility reasons, but for the sake of privacy and security, UAs have been allowed to report inacurate information.
</p>

<p>
<a href="http://www.w3.org/2001/tag/">TAG</a>
は、編集者と Working Group が自身の仕様により導入される~riskを評価するための
<a href="https://www.w3.org/TR/security-privacy-questionnaire/">自己評価質問票</a>
を開発した。
その回答は下に与えられる：
◎
The TAG has developed a self-review questionaire to help editors and Working Groups evaluate the risks introduced by their specifications. Answers are provided below.
</p>

<p class="trans-note">【
以下、この節の内容の和訳は省略する。
】</p>


	</section>

</main></div><!-- MAIN0, MAIN -->
