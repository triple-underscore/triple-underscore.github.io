<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Spatial Navigation Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<style>
.key {
	padding: 0 0.2em;
	color: black;
	border-radius: 3px;
	background-color: #B0E0E6;
}

#_ex-TV-program table {
	border-collapse: collapse;
	border: solid black 1px;
}
#_ex-TV-program td,
#_ex-TV-program th {
	border: solid black 1px;
	width: 2em;
	text-align: center;
	white-space: nowrap;
}

#_ex-TV-program {
	display: flex;
}
#_ex-TV-program > button {
	align-self: center;
}

</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>


Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}


function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'vt':
	text = `&lt;${key}&gt;`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'ft':
	text = `&lt;<code class="func">${key}()</code>&gt;`;
	klass='f';
	break;
case 'mc':
	text = 'constructor'
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`
	break;
case 'kY': // key event .key value
	href = `~UIEVENTS-KEY#key-${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	href = `~CSSissue/${key}`;
	text = `課題 #${key}`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}


</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Spatial Navigation Level 1
spec_date:2020-09-18
trans_update:2020-08-19
source_checked:191126
page_state_key:CSS
original_url:https://drafts.csswg.org/css-nav-1/
	abbr_url:CSSNAV
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-ux,css
conformance:css
copyright:2020,permissive
trans_1st_pub:2019-04-23

●●navs
イベント:.eventdef

●●class_map
p:property
css:css
e:element
a:attr
et:event-type
v:value
t:type
vt:type
kY:key


●●tag_map
p:code
t:var
vt:var
css:code
e:code
a:code
et:code
v:code
I:code
m:code
c:code
kY:code
nEI:code
mSO:code
i:i
em:em

●●original_id_map

●●mdn_urls
	propdef-spatial-navigation-contain:CSS/spatial-navigation-contain
	propdef-spatial-navigation-action:CSS/spatial-navigation-action
	propdef-spatial-navigation-function:CSS/spatial-navigation-function

●●link_map

	●idl
Exposed:~WEBIDLjs#Exposed

undefined:~WEBIDL#idl-undefined
DOMString:~WEBIDL#idl-DOMString
sequence:~WEBIDL#idl-sequence

I.FocusableAreaSearchMode:#enumdef-focusableareasearchmode
I.FocusableAreasOption:#dictdef-focusableareasoption
I.NavigationEvent:#navigationevent
I.NavigationEventInit:#dictdef-navigationeventinit
I.SpatialNavigationDirection:#enumdef-spatialnavigationdirection
I.SpatialNavigationSearchOptions:#dictdef-spatialnavigationsearchoptions

I.Document:~DOM4#concept-document
I.Element:~DOM4#element
I.Event:~DOM4#event
I.EventTarget:~DOM4#eventtarget
	~node:~DOM4#boundary-point-node
I.Node:~DOM4#node
I.KeyboardEvent:~UIEVENTS#keyboardevent
I.UIEvent:~UIEVENTS#uievent
I.UIEventInit:~UIEVENTS#dictdef-uieventinit
I.Window:~WINDOW#window

l.up:#dom-spatialnavigationdirection-up
l.down:#dom-spatialnavigationdirection-down
l.left:#dom-spatialnavigationdirection-left
l.right:#dom-spatialnavigationdirection-right

l.visible:#dom-focusableareasearchmode-visible
l.all:#dom-focusableareasearchmode-all

m.focus:~HTMLinteraction#dom-focus
m.key:~UIEVENTS#dom-keyboardevent-key
m.preventDefault:~DOM4#dom-event-preventdefault

m.navigate:#dom-window-navigate
m.getSpatialNavigationContainer:#dom-element-getspatialnavigationcontainer
m.focusableAreas:#dom-element-focusableareas
m.spatialNavigationSearch:#dom-element-spatialnavigationsearch

mc.NavigationEvent:#dom-navigationevent-navigationevent
m.target:~DOM4#dom-event-target
m.relatedTarget:#dom-navigationevent-relatedtarget
m.dir:#dom-navigationevent-dir

m.mode:#dom-focusableareasoption-mode
	m.id:~DOM4#dom-element-id → a.id

mSO.candidates:#dom-spatialnavigationsearchoptions-candidates
mSO.container:#dom-spatialnavigationsearchoptions-container

nEI.relatedTarget:#dom-navigationeventinit-relatedtarget
nEI.dir:#dom-navigationeventinit-dir


	%:#dom-window-navigate-dir-dir
	%:#dom-element-focusableareas-option-option
	%:#dom-element-spatialnavigationsearch-dir-options-options
	%:#dom-element-spatialnavigationsearch-dir-options-dir
	%:#dom-navigationevent-navigationevent-type-eventinitdict-type
	%:#dom-navigationevent-navigationevent-type-eventinitdict-eventinitdict

	●a

a.tabindex:~HTMLinteraction#attr-tabindex
a.inert:https://github.com/WICG/inert
	不活:#inert

	●p
p.spatial-navigation-action:#propdef-spatial-navigation-action
p.spatial-navigation-contain:#propdef-spatial-navigation-contain
p.spatial-navigation-function:#propdef-spatial-navigation-function
p.overscroll-behavior:~CSSOVERSCROLL#propdef-overscroll-behavior

	p.all:~CASCADE#propdef-all
p.overflow-x:~CSSOVERFLOW3#propdef-overflow-x
p.overflow-y:~CSSOVERFLOW3#propdef-overflow-y

	●v
	v.auto:#valdef-spatial-navigation-contain-auto
v.contain:#valdef-spatial-navigation-contain-contain

v.auto:#valdef-spatial-navigation-action-auto
v.focus:#valdef-spatial-navigation-action-focus
v.scroll:#valdef-spatial-navigation-action-scroll

v.hidden:~CSSOVERFLOW3#valdef-overflow-hidden
v.mandatory:~CSSSCROLLSNAP#valdef-scroll-snap-type-mandatory

v.normal:#valdef-spatial-navigation-function-normal
v.grid:#valdef-spatial-navigation-function-grid

	●et
et.navbeforefocus:#eventdef-navigationevent-navbeforefocus
et.navnotarget:#eventdef-navigationevent-navnotarget
et.keydown:~UIEVENTS#keydown
et.focusin:~UIEVENTS#focusin
et.focus:~UIEVENTS#focus

	●用語
空間的~navi:#spatial-navigation
~risk下:#at-risk
境界~box:#boundary-box
手動で~scrollできる:#can-be-manually-scrolled
要素をある方向へ~scrollする:#directionally-scroll-an-element
要素の中で~focus可能な区画を見出す:#find-focusable-areas
最短~距離を見出す:#find-the-shortest-distance
l.navigation-override:#navigation-override
~navi上書き:#navigation-override
最良な候補を選定-:#select-the-best-candidate
最良な候補を選定する:#select-the-best-candidate
空間的~navi容器:#spatial-navigation-containers
空間的~navi始点:#spatial-navigation-starting-point
空間的~navi手続き:#spatial-navigation-steps
内側~区画:#inside-area
探索~起点:#search-origin
探索~起点を設定する:#set-the-search-origin
探索~起点を更新する:#update-the-search-origin
空間的~navi~eventを配送する:#_dispatches-nav-event
	#dispatches-navnotarget-event
	#dispatches-navbeforefocus-event

	●§
	§:#overview
	§:#js-api
	§:#events-navigationevent
	§:#events-nav-type
	§:#processing-model
	§:#grouping
§ ~navi:#nav
	§:#declarative
	§:#container

	●他
拡張-可能な~Web:https://github.com/extensibleweb/manifesto
	Extensible Web:https://github.com/extensibleweb/manifesto
	:https://wicg.github.io/spatial-navigation/tests/ux/list.html
	old WICD Spec:https://www.w3.org/TR/WICD/#focus-handling
	:https://github.com/WICG/overscroll-behavior

	●用語 css
留め位置:~CSSSCROLLSNAP#scroll-snap-position

	すべての要素:https://drafts.csswg.org/css-pseudo/#generated-content
~border~box:~CSSBOX#border-box
~box断片:~CSSBREAK#box-fragment
~box:~CSSDISP#box
最適な~view用~領域:~CSSSCROLLSNAP#optimal-viewing-region
~CSS塗ng順序:~CSS22/zindex.html#painting-order
首要~box:~CSSDISP#principal-box
相対~位置決め:~CSSPOS#relative-position
要素を~scrollする:~CSSOMVIEW#scroll-an-element
~scroll境界:~CSSOVERSCROLL#scroll-boundary
~scroll容器:~CSSOVERFLOW3#scroll-container
~scrollport:~CSSOVERFLOW3#scrollport

~box~tree:~CSSDISP#box-tree

	●用語 HTML
実際に不能化され:~HTMLselectors#concept-element-disabled
	~HTMLinteraction#concept-element-disabled
明に不活:~HTMLinteraction#expressly-inert
具現化され:~HTMLrendering#being-rendered
除去された:~HTMLINFRA#nodes-are-removed

作動中の文書:~BROWSERS#active-document
属する閲覧文脈:~BROWSERS#concept-document-bc
bc.容器:~BROWSERS#bc-container
閲覧文脈:~BROWSERS#browsing-context
入子な閲覧文脈:~BROWSERS#nested-browsing-context
生成元:~ORIGIN#concept-origin
	誤）~HTMLINFRA#concept-request-origin
~body要素:~HTMLdom#the-body-element-2
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context

~DOM~anchor:~HTMLinteraction#dom-anchor
~tabindex値:~HTMLinteraction#tabindex-value

~top-level閲覧文脈の現在の被focus区画:~HTMLinteraction#currently-focused-area-of-a-top-level-browsing-context
~focus可能な区画:~HTMLinteraction#focusable-area
~objを~focusする:~HTMLinteraction#focusing-steps
逐次的~focus~navi順序:~HTMLinteraction#sequential-focus-navigation-order
逐次的~focus~naviの始点:~HTMLinteraction#sequential-focus-navigation-starting-point

	●用語 infra
	~Assert:~INFRA#assert
~clone:~INFRA#list-clone
空:~INFRA#list-is-empty
~size:~INFRA#list-size
除去する:~INFRA#list-remove
有順序~集合:~INFRA#ordered-set


	●用語 DOM
ev.取消されたか:~DOM4#canceled-flag
文書~要素:~DOM4#document-element
文書:~DOM4#concept-document
~eventを発火する:~DOM4#concept-event-fire
~node文書:~DOM4#concept-node-document
~node:~DOM4#boundary-point-node

	●用語 他
既定の許容list:~PERMISSIONS-POLICY#default-allowlist
施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature

~event序列:~UIEVENTS#event-order
~event標的:~UIEVENTS#event-target


●●words_table1

CSSOVERSCROLL:css-overscroll-ja.html
	https://drafts.csswg.org/css-overscroll-1/
UIEVENTS-KEY:uievents-key-ja.html


●●words_table

	●幾何

空間的:spatial::~
限界:bounding::~
形状付け:shaping::~
幾何-:geometric::~
	幾何-:geometrical
point::点
変形n:transformation::変形
面積:area:~
重合する:overlapする:重なり合う
重合しな:overlapしな:重なり合わな
重合して:overlapして:重なり合って
隅:corner:~
横方向:horizontal::~
縦方向:vertical::~
横:horizontal::~
縦:vertical::~
	各~辺が軸に平行な／限界~boxの各~辺は軸に平行:axis-aligned
	右:right
始点:starting point:~
起点:origin::~
領域:region::~
平方根:square root:~
射影:projection::~
度合い:degree:~
直交-:orthogonal:~
直交な:orthogonalな:直交する

重み:weight:~
転移:displacement:~
偏り:bias:~
euclidean::::ユークリッド
	x
	y
	一部でも:partially

	●layout
整列-:align::~
整列:alignment::~
格子:grid::~::グリッド
	格子~状の:grid-like
一次元的:linear::~
	およそ一次元的でない:predominantly non linear
	上層にある:higher

	●nav
	移動-:moving
動き:movement:~
候補:candidate:~
基準:reference:~
留め:snap::~::スナップ
留めら:snapさ::~::スナップさ
スカスカ:quite sparse::~
側:side:~
遮られ:obscureされ:~
隠れて:hideされて:~

	ある方向へ:directionally／:directional
	ある方向へ
	方向を表す:directional
	~loopして戻る:loop-back
	外:out
	下へ:down
	下に:under
	反対:opposite
	~~反対:the other
	最も近い:nearest
	最も近い:closest
	近く:closely
	より近い:closer
	探して:looking for
	一部でも入らない:at least partly within
	巡って:around
	上下左右:4-way
	に来てはいない:not at
	来る:come
	行く／通る:goes／:going
	遡る:climb
	遡る:going up
	遡って:up
	優先度を下げる:down-prioritize
	最優先:at first
	優先的に:prioritize

	し切った:maximum
	~~現れ:uncover

	●UI
UI:
UX:::利用者体験
anchor::::アンカー
不活:inert::~
remote-control:remote control:::リモコン
scroller::::スクローラ
	~scroll容器:scroller
scrollport::::スクロール域
矢印:arrow:~
	十字キー:D-pad／:directional pad
修飾key:modifier key::修飾キー
controller::::コントローラ
desktop::::デスクトップ
game::::ゲーム
	~game用:gaming
	scroll可能:scrollable
scrolling::::スクロール処理
caret::::キャレット
被focus:focused:::被フォーカス
	focusされ:focused
	focus可能な:focusable
	~click可能:clickable
pressする::押す
pressして::押して
pressした::押した
pressされ::押され
	~screen上の:on-screen
	~screenから外れて:off-screen／:offscreen
操作o-:operate:操作
逐次的:sequential::~
feature-phone:feature phone:::スマホ
写真展示:photo gallery:~

外見的:apparent:~
	前週:previous week
	次週:next week
	外へ出た:becomes out of
	消え失せた:vanished
	到達-不能になる:unreachability

	●構造
	~group化:grouping
body:
序列:order::~
先祖上の:ancestry::~
	下位集合~化:sub-setting

	●処理／IDL
再帰的:recursive:~
未設定:unset::~
	ε に設定する:unset
	同じ値に設定する:not be set differently

	~method~手続きは:called
	member:attribute


	%可視のみか:visibleOnly
	%探索~起点:searchOrigin
	%~focus可能~集合:focusables
	%可視~集合:visibles
	%最良な候補:bestCandidate
	%候補たち:candidates
	%候補たち:areas
	%方向:dir
	%~anchorたち:anchors
	%要素:e
	%方向:d
	%距離:d
	%基準:reference
	%~event標的:eventTarget
	%内側にあるもの:insiders
	%最も近いものたち:closest subset
	%転移:displacement
	%~euclidean距離:euclidean
	%直交-偏り:orthogonalBias
	%直交-重み:orthogonalWeight
	%整列-偏り:alignBias
	%整列-重み:alignWeight
	%射影が重合する長さ:projectedOverlap
	%重合する面積の平方根:sqrt(Overlap)

	-:Else, fallback to the next step.
	項:term


	●CSS
塗ng:painting:塗り
	~graphicな:graphical
首要:principal::主要


	●保安
許容list:allowlist::許容 list:許容リスト
	~~無為にする:lost cause
	~~価値はある:worthwhile
乗取る:hijackする:乗っ取る
質問票:questionnaire:~
降格:downgrading:~

	●仕様
Event:
	program的:programmatic／:programmatically
	risk下にある:at-risk
	あり得る:may choose 〜possible
必要十分:adequate:~
可用性:availability:~
直感:intuition:~
精神:spirit:~
面:surface:~
上流:upstream:~
可能性:possibility:~
回答:answer:~
答え:answer:~
複雑:complicated:~
論題:topic:~
適格:eligible:~
rightな::当を得た
捕える:trapする:~
良さげ:plausible:~
即座に:outrightに:~
適度:reasonable:~
用語集:glossary:~
本当の:realな:~
最大化する:maximizeする:最大限に得る

	精確でない:imprecise
	するための:in order to
	-:sufficiently
	どう:how
	きちんと:well
	と同時に:at the same time,
	これまで無かった:no previous
	委ねられ:left for
	備考:Notes
	とされる:mark
	次に従って:as follows
	不都合:bad
	逆にconversely
	にもかかわらず:despite that
	伏せている:gloss over
	し易く／~~促して:help
	頭の中:mental
	~~目的に:objectively
	ため:the sake of
	寄せてほしい:welcome
	ぜひ:very
	〜し易く:easy
	必要に迫られ:out of necessity
	適する:suited to
	主要な:key
	-:potential
	:per
	〜の違い:differently

	●仕様（動詞

目指す:aimする:~
分岐:divergence:~
精緻化:refinement:~
解決策:solution:~
切替える:switchする:切り替える
保つ:keepする:~
希望-:hope:~
排他的:exclusive:~
探求-:explore:~
	書く:write
獲得-:acquire:~
築き:buildし:~
覆す:breakする:~
選ばれ:chooseされ:~
選ん:chooseし:~
	:chosen
着想-:inspire:~
惑わす:confuseさせる:~
拡げる:expandする:~
選取って:pickして:選び取って
選取られ:pickされ:選び取られ
誂えれ:tailorでき:あつらえれ
欲求:desire:~

	予測-不能:unpredictable
	論の最中:under discussion
	制御を司る:take control over
	見做す下で:assuming
	感じ:we feel
	必ず備えるようにするため:in order to make sure
	関わる:associate
	任意選択で~~選ぶ:opt into
	もたらし:cause
	自前の~algoを与える:roll our own
	微調整:fine tune
	ずれ:amount
	見える:seem
	-:identified
	言えよう:as far as the editors can tell
	~~任意選択する:opt into

	●未分類（動詞
編集-:edit:~
	行なった:done
	書く:write

	●未分類
	JS:Javascript
	Chrome
	WICD
iframe:
標的:target::~:ターゲット
	~view用:viewing
TV:
tabindex:
公式:formula:~
数量的:numerical:~
断片:fragment::~
早期の:earlier:~

	ε:unset
	図:figure
	増やさな:increase しな
	無い:none
	TAG
	Working Group
	HTML Standard
	来たる:upcoming
	番組表:program schedule or calendar
	番組:TV shows or calendar entries
	成すように:made into
	~~反映する:mirror
	高:high
	低:low
	-:(in alphabetical order)
	Bar:#
	Baz:#
	Foo:#
	属する文書:Document
	~member:attribute
	~NEQ ~NULL:available

	●指示語
	旧:old
	それ以上:further
	何回も:many times
	方々:individual
	別個のもの:separately
	一部:part of
	／:later
	何個かの:several
	それ以上:any further
	-:at least
	〜以前にpredating:#1
	様々な:various
	一連の:series of
	次回に:next time
	次にある:next
	さらにもう一回:additionalに
	もう一回:next
	周りに:around
	それまで:previously
	それまでは:until then
	何もない:nothing／:there isn’t any
	上に:onto
	箇所:point
	~among

●●images
＠css-nav/
gallery-app｜width: 500px;｜｜gallery-app.png
spatnav-scroll-visible-1｜width:10em; height:23.75em;｜＋｜.png
spatnav-scroll-visible-2｜width:10em; height:23.75em;｜＋｜.png
spatnav-scroll-invisible-1｜width:10em; height:23.75em;｜＋｜.png
spatnav-scroll-invisible-2｜width:10em; height:23.75em;｜＋｜.png
spatnav-scroll-invisible-3｜width:10em; height:23.75em;｜＋｜.png
spatnav-scroll-invisible-4｜width:10em; height:23.75em;｜＋｜.png
focusableareas-visible-example｜width:30em; height:13.8em;｜｜.png
navnotarget-example-1｜width:13em; height:21.2em;｜｜.png
navnotarget-example-2｜width:13em; height:21.2em;｜｜.png
	spatnav_processing_model_diagram｜width:971px; height:1730px;｜An image of the result about navnotarget｜.svg
projected_overlap｜width:32em; height:16em｜＋｜.svg
spatnav-action｜width:32.5em; height:26.5em｜＋｜.png
spatnav-function｜width: 326px; height:450px｜｜.png

●●ref_normative

[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 4. 18 December 2018. WD. URL: https://www.w3.org/TR/css-break-4/ 
[CSS-CASCADE-5]
    CSS Cascading and Inheritance Level 5 URL: https://www.w3.org/TR/css-cascade-5/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 19 May 2020. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-OVERFLOW-3]
    David Baron; Elika Etemad; Florian Rivoal. CSS Overflow Module Level 3. 3 June 2020. WD. URL: https://www.w3.org/TR/css-overflow-3/ 
[CSS-POSITION-3]
    Elika Etemad; et al. CSS Positioned Layout Module Level 3. 19 May 2020. WD. URL: https://www.w3.org/TR/css-position-3/ 
[CSS-SCROLL-SNAP-1]
    Matt Rakow; et al. CSS Scroll Snap Module Level 1. 19 March 2019. CR. URL: https://www.w3.org/TR/css-scroll-snap-1/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 31 January 2019. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSSOM-VIEW-1]
    Simon Pieters. CSSOM View Module. 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-view-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FEATURE-POLICY]
    Ian Clelland. Permissions Policy. 16 July 2020. WD. URL: https://www.w3.org/TR/permissions-policy-1/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead; Doug Schepers. UI Events. 30 May 2019. WD. URL: https://www.w3.org/TR/uievents/ 
[WebIDL]
    Boris Zbarsky. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[CSS-TRANSFORMS-1]
    Simon Fraser; et al. CSS Transforms Module Level 1. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/ 
[EXTENSIBLE]
    The Extensible Web Manifesto. 10 June 2013. URL: https://extensiblewebmanifesto.org/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Spatial Navigation Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-nav-1/
以前のバージョン
	https://www.w3.org/TR/2019/WD-css-nav-1-20190423/ 
	https://www.w3.org/TR/2019/WD-css-nav-1-20191126/ 

フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-nav-1">CSSWG Issues Repository</a>

編集
	<a href="mailto:jh.hong@lge.com">Jihye Hong</a> (LG Electronics)
	<a href="https://florian.rivoal.net">Florian Rivoal</a> (Invited Expert)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-nav-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-nav-1

</script>

</head>
<body>

<header>
	<hgroup>
<h1>CSS Spatial Navigation Level 1</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT


<p>
この仕様は、矢印~Keyを利用して~focusを~navigateするための一般~model, および関係する［
~CSS, ~JS特能, ~Event
］を定義する。
◎
This specification defines a general model for navigating the focus using the arrow keys, as well as related CSS, JavaScript features and Events.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下、この節の他の内容は，~SOTD-CSSに移譲。】
</p>

<p>
次に挙げる特能は~risk下にあり，勧告候補~期間に落とされるかもしれません：
◎
The following features are at-risk, and may be dropped during the CR period:
</p>

<ul ><li>`getSpatialNavigationContainer()$m
</li><li>`focusableAreas()$m
</li><li>`spatial-navigation-contain$p
</li><li>`spatial-navigation-action$p 用の値 `scroll^v
</li><li>`spatial-navigation-function$p
</li></ul>


	</section>

<main id="MAIN0">

<!-- 
<p>
This specification is rather long.
To make it easier to read and focus on a particular area,
a few checkboxes are provided below.
Checking them hides part of the specification.
This is only meant as a reading aid,
the specification remains the full document.
</p>

<input id="api-check" type="checkbox">
<label for="api-check">Hide JavaScript APIs, including events</label>
<br> 
<input id="cssapi-check" type="checkbox">
<label for="cssapi-check">Hide CSS properties that enable selecting behavior variants, and related information</label>
<br> 
<input id="verbose-check" type="checkbox">
<label for="verbose-check">Hide informative sections that explain and summarize normative sections without adding more information</label>

 -->

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
歴史的に，ほとんどの~browserは、~focusをある方向へ移動する特能を利用者に提供していなかった。
~TV~browserなど，一部のものは、必要に迫られ，利用者が矢印~Keyを利用して~focusを移動するのを可能化する
— 典型的な~TV~remote-controlには可用な入力の仕組みが他にないので。
◎
Historically, most browsers have not offered features to let the user move the focus directionally. Some, such as TV browsers, have enabled the user to move the focus using the arrow keys out of necessity, since no other input mechanism is available on a typical TV remote control.
</p>

<p>
その他ものは、空間的~naviを制御するための，異なる~Key組合nを可能化していた
— `Shift$kY ~Keyと矢印~Keyを一緒に~pressするなど。
◎
Others, have enabled different key combinations to control spatial navigation, such as pressing the Shift key together with arrow keys.
</p>

<p>
ある方向へ，~pageを巡って移動するこの能は、
`空間的~navi@
（ `spatial navigation^en ）と呼ばれる。
◎
This ability to move around the page directionally is called spatial navigation.
</p>

<p>
`空間的~navi$は、格子~状の~layoutその他のおよそ一次元的でない~layoutを利用して築かれた~web~page用に有用になり得る。
下の図は、格子~layoutに配列された写真展示を表現する。
利用者が `Tab$kY ~Keyを~pressして各~画像~間で~focusを移動する場合、欲される画像~要素へ到達するまで，~Keyを何回も~pressする必要がある。
◎
Spatial navigation can be useful for a web page built using a grid-like layout, or other predominantly non linear layouts. The figure below represents a photo gallery arranged in a grid layout. If the user presses the Tab key to move focus around the images, they need to press the key many times to reach the desired image element.
</p>

<figure>
<p class="alt" hidden id="_dgm-gallery-app">
一群の要素が格子~patternに~lay-outされるとき、
空間的~naviは，~focusをどこへ移動するべきか［
予測する／制御する
］のをずっと容易にする。
◎
When elements are laid out in a grid pattern, spatial navigation makes it much easier to predict and control where focus should move to.
</p>
<figcaption>
格子~layoutを利用している写真展示~appの例
◎
Photo gallery application example using a grid layout
</figcaption></figure>

<p>
`空間的~navi$による~focusの移動-先は、利用者にとって予測-可能にもなる
— それは、~focus可能な各~要素~間で，要素の位置に依存するように~focusを移動するので。
~page上の要素は，~source順序とは独立に配列されることもあり、その場合，
`Tab$kY ~Keyを利用する逐次的~naviによる~focus~naviは
— 空間的~naviと違って —
予測-不能になる。
◎
Also, spatial navigation moves the focus to the predictable element for users because it moves the focus among focusable elements depending on their position. Sometimes elements on the page aren’t arranged independently of their source order. Therefore unlike spatial navigation, sequential navigation using the Tab key makes focus navigation unpredictable.
</p>

<p>
矢印~Keyは，空間的~naviを制御するには自然に適するが、それがどう働くベキで, どう制御されてヨイか／できるかを述べる仕様は，これまで無かった。
この仕様は、［
空間的~navi用の処理~model
］, および［
空間的~naviがどう働くかを，作者が［
制御する／上書きする
］ことを可能化する~API
］を導入する。
◎
While arrow keys are naturally suited to control spatial navigation, no previous specification describes how that should work, or how it may be controlled. This specification introduces a processing model for spatial navigation, as well as APIs enabling the author to control and override how spatial navigation works.
</p>

<p class="note">注記：
この仕様を成す一部の側面
— ~JS［
~Event／~API
］など —
は、逐次的~naviにも拡張できる
— ~keyboard~naviが一般に，一貫した, かつ きちんと定義された~modelを必ず備えるようにするための。
◎
Note: Some aspects of this specification, such as the JavaScript Events and APIs could also be extended to sequential navigation, in order to make sure that keyboard navigation has a consistent and well defined model in general.
</p>

<p class="note">注記：
一般~原則として、~keyboard~navi, 特に空間的~naviは，~JSなしに利用したり制御することがアリになるベキであり、したがって宣言的な解決策が選好される。
空間的~naviは~layoutに依存するので、概して，~CSSが空間的~naviに関係する制御-を定義するための~rightな仕組みになることを意味する。
しかしながら，`拡張-可能な~Web$ `EXTENSIBLE$r の精神においては、~rightな~JS~primitiveを供して，作者に問題~空間を試験して探求してもらうことが重要であると感じられる。
後には、そのような~JS用法を通して獲得された~feedbackと経験に基づいて，より宣言的な特能が追加されるであろう。
◎
Note: As a general principle, keyboard navigation, and spatial navigation in particular, should be possible to use and control without JavaScript, and declarative solutions are therefore preferred. Since spatial navigation depends on layout, that means CSS is typically the right mechanism to define spatial navigation related controls. However, in the spirit of the Extensible Web Manifesto [EXTENSIBLE], we feel it is important to provide the right JavaScript primitives to let the author experiment and explore the problem space. More declarative features may be added later, based on feedback and experience acquired through such JavaScript usage.
</p>

<p class="note">注記：
少数の特能は、
`~risk下@
にあるとされる。
編集者は、それらが［
この仕様に定義される特能の利用者や作者による体験
］を成す重要な一部を表現すると予見している。
と同時に、この仕様を成す中核の機能性は，これらを実装せずに実装できるので、最初の実装の視野を抑制するため，実装者は それらの優先度を下げることもあり得ると見受けられる。
これらの特能は
— 実装されることになると希望されているが —
最優先でないかもしれない認識の下で，~risk下にあるとされる。
◎
Note: A few features are marked at-risk. The editors of this specification believe they represent an important part of the user or author experience of the features defined in the specification. At the same time, the core functionality of this specification can be implemented without implementing these so it seems possible that implementers may choose to down-prioritize them to reduce the scope of the first implementation. While it is hoped that these features will be implemented as well, they are marked at-risk in recognition that they might not be at first.
</p>

	</section>
	<section id="interaction">
<h2 title="Module interaction">2. ~module間の相互作用</h2>

<p>
この文書は `infra$r に依存する。
◎
This document depends on the Infra Standard [infra].
</p>

<p>
【以下略：<a href="index.html#rfc2119-phrase">RFC 2119 が規定する句に利用される対訳</a>を参照されたし。】
◎
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" are to be interpreted as described in RFC 2119. [RFC2119]
</p>

		<section id="values">
<h3 title="Value Definitions">2.1. 値~定義</h3>

<p class="trans-note">【
この節の内容は <a href="~CSScommon#values">~CSS日本語訳 共通~page</a>に移譲。
】</p>

		</section>
		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, コレ, ε, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
	</section>
	<section id="overview" class="verbose">
<h2 title="Overview">3. 概観</h2>

~INFORMATIVE

<p>
~UAにより定義される仕組みを利用して（概して矢印~Key，場合によっては `Shift$kY や `Control$kY の様な修飾keyとの組合nで）、利用者は特定0の方向へ~navigateするよう~UAに依頼することもある。
これは、その現在の所在から要請された方向に~focus可能な新たな~itemが在れば，そこへ~focusを移動し、適切な~itemが無ければ~scrollすることになる。
◎
Using a UA-defined mechanism (typically arrow keys, possibly in combination with modifier keys like Shift or Control), the user may ask the user agent to navigate in a particular direction. This will either move the focus from its current location to a new focusable item in the direction requested, or scroll if there is no appropriate item.
</p>

<p>
より特定的には、~UAは先ず，［
現在の`空間的~navi容器$の中で指示された方向にある，可視かつ~focus可能な~item
］を探索することになる
（`空間的~navi容器$は、既定では，［
根~要素, ~scroll可能な要素, ~iframe
］いずれかであるが、
`spatial-navigation-contain$p ~propを利用すれば，他の要素も`空間的~navi容器$を成すようにできる）。
◎
More specifically, the user agent will first search for visible and focusable items in the direction indicated within the current spatial navigation container (by default, the root element, scrollable elements, and iframes, but other elements can be made into spatial navigation containers using the spatial-navigation-contain property).
</p>

<p>
何かが見出された場合、その方向にある最良な 1 つを選取って，~focusをそこへ移動することになる。
◎
If it finds any, it will pick the best one for that direction, and move the focus there.
</p>

<p>
何も見出されなかった場合、~focusを移動する代わりに，要請された方向へ`空間的~navi容器$を~scrollすることになる。
その結果，~focus可能な要素が~~現れ得る
— その場合、次回に同じ方向へ空間的~naviが要請されたとき，それが~focusを移動する適格な標的になるであろう。
◎
If it does not, it will scroll the spatial navigation container in the requested direction instead of moving focus. Doing so may uncover focusable elements which would then be eligible targets to move the focus to next time spatial navigation in the same direction is requested.
</p>

<p>
［
~scroll可能な要素でないか，すでにその方向へ~scrollし切った
］ため，`空間的~navi容器$を~scrollできない場合、~UAは先祖上の連鎖†を遡って次にある`空間的~navi容器$を選定して，何らかの［
~focus／~scroll
］可能な要素を見出すか，根~要素に到達するまで，上の処理-を再帰的に繰返すことになる。
◎
If the spatial navigation container cannot be scrolled, either because it is not a scrollable element or because it is already scrolled to the maximum in that direction, the user agent will select the next spatial navigation container up the ancestry chain, and recursively repeat the above process until it finds some element to focus or scroll, or reaches the root element.
</p>

<p class="trans-note">【†
この仕様に現れる “先祖” は、~APIも含め，`~box~tree$に基づく先祖と解釈すべきように思われる。
】</p>

<p class="note">注記：
この処理~modelの帰結として、逐次的~naviにより到達-可能な要素たちは，空間的~naviにより到達-可能なものとほぼ同じになる。
現在~scroll可能な要素の表示域の外側にある要素へは、空間的~naviにより~viewの中へ~scrollされたときに限り到達できる。
したがって，~viewの中へ~scrollできない要素は、既定では，空間的~naviでも到達できない。
◎
Note: As a consequence of this processing model, the elements that are reachable by sequential navigation and by spatial navigation are almost the same. Elements that are currently outside of the viewport of a scrollable element can only be reached by spatial navigation once they have been scrolled into view. Therefore, elements that cannot be scrolled into view by default.
</p>

<div class="api">

<p>
この［
空間的~navi要請に対し適切な応答を得るため，探索する間
］の主要な箇所にて，~UAは~eventを発火することになる。
これらは、作者が来たる動作を防止すること（ `preventDefault()$m を~callして），および
欲されるなら代替-動作
— 作者が選んだ異なる要素に対し `focus()$m ~methodを利用するなど —
を供することを可能化する。
◎
At key points during this search for the appropriate response to the spatial navigation request, the user agent will fire events. These enable the author to prevent the upcoming action (by calling preventDefault()), and if desired to provide an alternate action, such as using the focus() method on a different element of the author’s choosing.
</p>

<p>
作者がそのような代替-動作を書き易くするため、および`拡張-可能な~Web$ `EXTENSIBLE$r の原則の下に，下層の~platform~primitiveを公開する一部として、この仕様は，下層の~modelの主要な構成子を公開する~JS~APIも定義する。
◎
To help the author write such alternate actions, and as part of exposing underlying platform primitives as per the Extensible Web principles, this specification also defines JavaScript APIs that expose key constructs of the underlying model.
</p>

<p>
~JS~APIについての詳細は
<a href="#js-api">§ ~JS~API</a> ／
様々な~eventについての詳細は
<a href="#events-nav-type">§ ~navi~event型</a> ／
~CSS~propについての詳細は
<a href="#declarative">§ 宣言的な手段による空間的~naviの制御-法</a>
を見よ。
◎
See § 5 JavaScript API for details about the JavaScript API, § 6.2 Navigation Event Types for details about the various events, and § 9 Controlling spatial navigation through declarative means for details about the CSS properties.
</p>

</div>

<div class="example">

<p>
この例は、~scroll可能な要素~内に配列された一連の~focus可能な要素が，空間的~naviを利用して どう~navigateされるかを示す。
記述を単純に保つため、この例の空間的~naviは，矢印~Keyを利用して誘発されるものと見做す。
【！user agent where】
◎
This example shows how a series of focusable elements arranged in a scrollable element would be navigated when using spatial navigation. For the sake of keeping the description simple, this example assumes a user agent where spatial navigation is triggered using arrow keys.
</p>

<figure>
`spatnav-scroll-visible-1^dgm
`spatnav-scroll-visible-2^dgm
<figcaption>
`空間的~navi容器$内の可視な要素へ，~focusを移動する。
◎
Moving focus to the visible element in the spatial navigation container.
</figcaption></figure>

<p>
上の図では、左端にある "Box 2" が~focusされている。
`ArrowDown$kY ~Keyを~pressすると、~scrollすることなく，~focusは "Box 3" へ移動する
— "Box 3" は`空間的~navi容器$の`~scrollport$内に可視なので。
◎
On the left of figure 2, "Box 2" is focused. Pressing the ArrowDown key moves the focus to "Box 3" without scrolling because "Box 3" is visible in the scrollport of the spatial navigation container.
</p>


<figure>
`spatnav-scroll-invisible-1^dgm
`spatnav-scroll-invisible-2^dgm
`spatnav-scroll-invisible-3^dgm
`spatnav-scroll-invisible-4^dgm
<figcaption>
`空間的~navi容器$内にある，隠れていた要素へ~focusを移動する様子。
◎
Moving focus to the hidden element in the spatial navigation container.
</figcaption></figure>

<p>
上の 1 個目の図において、`~scrollport$内には， "Box 3" の下には可視な要素は無い。
したがって， `ArrowDown$kY を~pressしたときの効果は、 2 個目の図に示されるように下へ~scrollする。
もう一回 `ArrowDown^kY ~Keyが~pressされると `~scrollport$の中へ "Box 4" が来るようになり（ 3 個目の図）、さらにもう一回 `ArrowDown^kY が~pressされると，~focusは そこへ移動することになる（ 4 個目の図）。
◎
On the first of figure 3, under "Box 3", there isn’t any visible element in the scrollport. Therefore, the effect of pressing the ArrowDown is to scroll down, as shown in the second. The next press of the ArrowDown key makes "Box 4" come into the scrollport, and the focus will move to it when there is additional pressing the ArrowDown, as the fourth.
</p>

<p>
この例では、次の~markupが利用されている：
◎
This example uses the markup as follows:
</p>

<pre class="lang-css">
#scroller {
    width: 700px;
    height: 700px;
    overflow-x: hidden;
    overflow-y: auto;
}

.box {
    width: 150px;
    height: 110px;
    background-color: blue;
}

.box:focus {
    background-color: red;
}
</pre>

<pre class="lang-html">
&lt;div id="scroller"&gt;
    &lt;div class="box" tabindex="0"&gt;Box 1&lt;/div&gt;
    &lt;div class="box" tabindex="0"&gt;Box 2&lt;/div&gt;
    &lt;div class="box" tabindex="0"&gt;Box 3&lt;/div&gt;
    &lt;div class="box" tabindex="0"&gt;Box 4&lt;/div&gt;
&lt;/div&gt;
</pre>

</div>

	</section>
	<section id="triggering">
<h2 title="Triggering Spatial Navigation">4. 空間的~naviの誘発-法</h2>

<p>
利用者が所与の方向への空間的~naviを誘発するとき、~UAは，その方向への`空間的~navi手続き$を走らすモノトスル。
◎
When the user triggers spatial navigation in a given direction, the user agent must run the spatial navigation steps in that direction.
</p>

<p>
この仕様は、~UAが［
空間的~naviを誘発する~UIの仕組み
］として何を利用者に提供するベキかは，定義しない。
これは、意図的に~UAの裁定に委ねられている。
◎
This specification does not define what UI mechanism user agents should offer to users to trigger spatial navigation. This intentionally left for user agents to decide.
</p>

<p class="note">注記：
［
~remote-controlで操作oされる~TV,
~feature-phone,
~game~controllerで操作oされている機器
］など，入力~能力が制限された機器~上の~UAは、首な, または排他的な~naviの仕組みとして，空間的~naviを利用することになるものと期待される。
◎
Note: It is expected that user agents on devices with limited input capabilities, such as TVs operated with a remote control, feature phones, or devices operated with a game controller, will use spatial navigation as their primary or exclusive navigation mechanism.
</p>

<p>
~UAは，この仕様が定義する［
処理~model, ~API
］を実装できるが、~UAには，［
~APIを利用することなく，直に空間的~naviを誘発する手段
］を利用者に【！should】提供することが推奨される。
◎
Although user agents can implement the processing model and APIs defined by the specification, this specification recommends that user agents should offer a means for users to trigger spatial navigation directly, without having to use the APIs.
</p>

<p class="note">注記：
逆に，作者は、~APIを呼出さないときでも［
空間的~naviは、利用者~動作に呼応して，~UAにより誘発され得る
］ものと見做すベキである。
◎
Note: Conversely, the author should assume that spatial navigation may be triggered by the user agent in response to user actions even if the author has not invoked any of the APIs.
</p>

<p>
空間的~naviを誘発するために選ばれる実際の仕組みに関わらず，次に挙げる要件が適用される：
◎
Regardless of the actual mechanism chosen to trigger spatial navigation, the following requirements apply:
</p>

<ul>
	<li>
<p>
空間的~naviを誘発するために利用者が利用しなければナラナイ仕組みが，通常は `UIEvent$I を発火する場合
⇒
`空間的~navi手続き$を走らすに先立って，その~eventを発火した上で、その~eventの`取消されたか$evが ~T にされた場合には，この手続きを走らせないモノトスル。
◎
If the mechanism the user must use to trigger spatial navigation would normally fire a UIEvent, the event must be fired prior to running the spatial navigation steps and these steps must not be run if that event’s canceled flag gets set.
<p>

<div class="example">

<p>
~game用~機器の十字キーが~pressされたとき、空間的~naviを誘発し得る。
これは、~Keyが［
`ArrowDown$kY, `ArrowLeft$kY, `ArrowRight$kY, `ArrowUp$kY
］いずれかに設定された `keydown$et ~eventを発火する結果になる。
これが取消されなかった場合、`空間的~navi手続き$を走らす
— 関連な `NavigationEvent$I を発火することも含め。
◎
Gaming devices may trigger spatial navigation based on pressing the D-pad. This would result in firing a keydown event with the key set to one of ArrowDown, ArrowLeft, ArrowRight, or ArrowUp, followed if not canceled by running the spatial navigation steps, including firing the relevant NavigationEvents.
</p>

<p>
~keyboardの矢印~Keyを利用して空間的~naviを誘発する，~desktop~computer上の~UAは、同じ連列に従うことになる。
◎
A user agent on a desktop computer that triggers spatial navigation using the arrow keys of the keyboard would follow the same sequence.
</p>

</div>

	</li>
	<li>
<p>
空間的~naviを誘発するために利用者が利用しなければナラナイ仕組みが，何らかの文脈においては他の動作を遂行することになる場合、~UAは［
そのような文脈においては，それら他の動作に優先度を与えて、空間的~naviの代わりに，それらを実行する
］ベキであり，両者とも誘発しないモノトスル。
◎
If the mechanism the user must use to trigger spatial navigation would also perform other actions in some contexts, the user agents should in these contexts give priority to these other actions and execute them instead of spatial navigation. It must not trigger both.
<p>

<p class="example">
修飾keyなしの矢印~Key利用して，空間的~naviを誘発し，同じ矢印~Keyを~text挿入~caretを移動するためにも利用する~UAにおいて、編集-可能な要素に~focusされたときは，矢印~Keyは，既定では~caretを移動するベキである。
空間的~naviは、~focusされた要素が［
編集-可能でない／
編集-可能であるが，要請された方向へは それ以上~caretを移動できないとき
］に限り，矢印~Keyにより誘発されることになる。
◎
In a user agent that triggers spatial navigation using the arrow keys without modifier keys, and uses these same arrow keys to move the text insertion caret when an editable element is focused, the arrow keys should by default to moving the caret. Spatial navigation would only be triggered by the arrow keys when the focused element is not editable or when it is editable, but the caret cannot move any further in the requested direction.
</p>

<p>
ただし、~scrollingには例外がある：
空間的~navi自体は（~focusを移動することに加えて）~scrollingも取扱うので、~UAは，同じ仕組みを［
空間的~navi, 空間的~naviとは別々の~scrollingの挙動
］の両者を誘発するものとして提供するベキでない。
しかしながら，~UAは、［
それらの間で異なる~modeに切替える仕方，あるいは
異なる~UIの仕組みに基づいて両者
］を利用者に提供してもヨイ。
◎
An exception is made for scrolling: since spatial navigation itself handles scrolling (in addition to moving the focus) user agents should not offer the same mechanism to trigger both spatial navigation and the scrolling behavior separate from spatial navigation. However, user agents may offer a way for the user to switch between different modes, or offer both based on different UI mechanisms.
</p>

<p class="example">
~UAは、［
空間的~navi用, ~scrolling用
］のどちらに修飾keyなしの矢印~Keyを利用するか，利用者に選んでもらう設定を備えることもあろう。
別の~UAは、［
~scroll用には修飾keyなしの矢印~Key
］,
空間的~navi用には［
矢印~Keyが `Shift$kY ~Keyと一緒に~pressされたとき，あるいは［
`W^kY `A^kY `S^kY `D^kY
］~Key
］を提供することもあろう。
矢印~Keyを~pressしたときに［
空間的~navi, ~scrolling
］どちらかのみを応答として提供する可能性もある。
◎
A user agent may have a setting to let the user choose between using the arrow keys without modifier keys for spatial navigation or for scrolling. Another one may offer scrolling on arrow keys without modifiers, and spatial navigation on arrow keys when pressed together with the Shift key, or on the W A S D keys. Offering only spatial navigation or only scrolling as responses to pressing arrow keys would also be possibilities.
</p>
	</li>
</ul>

	</section>
	<section id="js-api" class="api">
<h2 title="JavaScript API">5. ~JS~API</h2>

		<section id="high-level-api">
<h3 title="Triggering Navigation Programmatically">5.1. ~program的な~naviの誘発-法</h3>
<p>
`navigate()$m ~methodは、空間的~naviを~program的に誘発することを作者に可能化する
— 利用者が手動でそれを行なったかのように（一例として，矢印~Keyが空間的~naviを誘発する仕方である~browser内で矢印~Keyを~pressすることにより）。
◎
The navigate() method enables the author to trigger spatial navigation programmatically, as if the user had done so manually (for instance, by pressing the arrow keys in a browser where that is the way to trigger spatial navigation).
</p>

<p class="note">注記：
これは，手動~naviと同じ処理~modelを誘発するので、まったく同じ結果
— 同じ~eventの連鎖が発火され，同じ要素が［
~scroll／~focus
］されるよう —
になるベキと期待される。
◎
Note: As this triggers the same processing model as manual navigation, all the same results should be expected: the same chain of events will be fired and the same element will be scrolled or focused.
</p>

<p class="note">注記：
これを利用すれば、作者は，~UAがアテガうものと異なる~UIの仕組みに基づいて空間的~naviを誘発できる
— ［
異なる~Keyに対応付ける ／
~screen上の~click可能な十字キーから空間的~naviを誘発する ／
~UI以外の~eventに対する反応において
］など。
それはまた、作者が［
~naviを中断して，何らかの非同期的な演算を行って（例：無限~scroller内にもっと内容を読込む），取消した所から~naviを再開したい
］と求めるときにも利用できる。
◎
Note: The author can use this to trigger spatial navigation based on a different UI mechanism than the one assigned by the user agent, such as mapping to different keys, or triggering spatial navigation from a clickable on-screen directional pad, or in reaction to other events than UI ones. It could also be used when an author wants to interrupt navigation to do some asynchronous operation (e.g. load more content in an infinite scroller) then resume the navigation where they canceled.
</p>

<p class="note">注記：
この~APIは、~testする目的にも有用になる
— ~vendorに特有な~UI規約に依存しなければ，空間的~naviを誘発するのは困難なので。
◎
Note: This API is also useful for testing purposes, as there it is difficult to trigger spatial navigation that does not depend on vendor specific UI conventions.
</p>

<pre class="idl">
enum `SpatialNavigationDirection@I {
    `up@l,
    `down@l,
    `left@l,
    `right@l,
};

partial interface `Window$I {
    `undefined$ `navigate$m(`SpatialNavigationDirection$I %dir);
};
</pre>

<div class="algo">
<p>
`navigate(dir)@m
~method~手続きは
⇒
~IF［
%dir ~IN { `up^l, `down^l, `left^l, `right^l }
］
⇒
`空間的~navi手続き$( %dir )
◎
When the navigate(dir) method is called, the user agent must run the following step:
• If direction dir is "up", "down", "left", or "right", run the spatial navigation steps in dir.
</p>

<p class="issue">
この~APIの名前は、論の最中にある
`3387$issue
◎
The name of this API is under discussion &lt;https://github.com/w3c/csswg-drafts/issues/3387&gt;
</p>
</div>

		</section>
		<section id="low-level-api">
<h3 title="Low level APIs">5.2. 低~levelな~API</h3>

<p>
これらの~APIは、処理~modelに近く従っている低~levelな構成子として設計されている。
そのようなわけで、それらは空間的~naviが働く仕方を拡張したり上書きしたいと求める作者に利用し易くあるベキである。
◎
These APIs are designed to be low level constructs following the processing model closely. As such, they should be easy to use by the author who wants to extend or override the way spatial navigation works.
</p>

<pre class="idl">
enum `FocusableAreaSearchMode@I {
    `visible@l,
    `all@l
};

dictionary `FocusableAreasOption@I {
    `FocusableAreaSearchMode$I `mode@m;
};

dictionary `SpatialNavigationSearchOptions@I {
    `sequence$&lt;`Node$I&gt;? `candidates@mSO;
    `Node$I? `container@mSO;
};

partial interface `Element$I {
    `Node$I `getSpatialNavigationContainer$m();
    `sequence$&lt;`Node$I&gt; `focusableAreas$m(optional `FocusableAreasOption$I %option = {});
    `Node$I? `spatialNavigationSearch$m(`SpatialNavigationDirection$I %dir, optional `SpatialNavigationSearchOptions$I %options = {});
};
</pre>

<p class="note">注記：
方向を表出する仕方は、必要とされれば，後で上下左右~naviより拡げることも許容するようにしてある。
方向を表す~keywordや数量的な角度もさらに追加され得る。
◎
Note: The way the direction is expressed allows us to expand to more than 4-way navigation later if this is found necessary. More directional keywords or a numerical angle could be added.
</p>

<p class="note">注記：
`focusableAreas()$m,
`getSpatialNavigationContainer()$m
~methodは`~risk下$にある。
◎
Note: the focusableAreas() and getSpatialNavigationContainer() methods are at-risk.
◎
When these methods are called, the user agent must run the steps described below:
</p>

<div class="algo">
<p>
`getSpatialNavigationContainer()@m
~method~手続きは：
◎
getSpatialNavigationContainer()
</p>
<ol>
	<li>
~EACH( コレの先祖 %先祖 )
に対し，コレに近いものから順に
⇒
~IF［
%先祖 は`空間的~navi容器$である
］
⇒
~RET %先祖
◎
Return the nearest ancestor of the element that is a spatial navigation container, or＼
</li>
	<li>
~RET `文書$【コレの`~node文書$】
◎
the document if the nearest spatial navigation container is the viewport.
</li>
</ol>

<p class="note">注記：
この要素~自身が`空間的~navi容器$であっても、先祖（または文書）を返す。
◎
Note: If the element is a spatial navigation container, getSpatialNavigationContainer() also returns the nearest spatial navigation container, not the element itself.
</p>
</div>

<div class="algo">
<p>
`focusableAreas(option)@m
~method~手続きは：
◎
focusableAreas(option)
</p>
<ol>
	<li>
%可視のみか ~LET ［
%option ~EQ `all$l ならば ~F ／
~ELSE_ ~T
］
◎
Let visibleOnly be false if option is present and its value is equal to all, or true otherwise.
</li>
	<li>
%区画たち ~LET `要素の中で~focus可能な区画を見出す$( コレ, %可視のみか )
◎
Let areas be the result of finding focusable areas within the element with visibleOnly as argument.
</li>
	<li>
~RET %区画たち 【を成す各~区画の`~DOM~anchor$からなる同順の~list】
◎
Return areas
</li>
</ol>
</div>

<div class="example" id="focusAreas-visible">
<p>
次の~codeは、
`focusableAreas()$m を利用して，現在の~page内の可視かつ~focus可能な要素~すべてを取得する方法を示す。
~methodが`空間的~navi容器$を見出した場合、その内側にある`~focus可能な区画$たちを再帰的に見出す。
この~methodに渡す %option の `mode$m ~memberは `visible^l に設定されているので、`~scrollport$の内側にない要素は，~focus可能であっても結果から除外される。
◎
The following code shows how to get all the visible focusable elements in the current page using focusableAreas(). If the method finds a spatial navigation container, it recursively finds focusable areas inside it. Because the value of the mode attribute in this method is visible, the focusable elements which aren’t inside the scrollport are excluded from the result.
</p>

<pre class="lang-html">
&lt;body&gt;
    &lt;button&gt;&lt;/button&gt;
    &lt;div style="width:300px; height:200px; overflow-x: scroll;"&gt;
        &lt;button style="left:25px;"&gt;&lt;/button&gt;
        &lt;button style="left:150px;"&gt;&lt;/button&gt;
        &lt;button style="left:350px;"&gt;&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
</pre>

<pre class="lang-js">
const %focusableAreas = document.body.focusableAreas({mode: 'visible'});
%focusableAreas &amp;&amp; %focusableAreas.forEach(%focusable =&gt; {
  %focusable.style.outline = '5px solid red';
});
</pre>

<p>
この~codeの結果を下の図に示す：
◎
The figure below is the result of this code.
</p>

<figure>
<p class="alt" hidden id="_dgm-focusableareas-visible-example">
`focusableAreas()^m に関する画像
◎
An image about focusableAreas()
</p>
<figcaption>
文書の内側にあるすべての可視かつ`~focus可能な区画$たちを見出す。
◎
Find all visible focusable areas inside the document.
</figcaption></figure>

</div>

<div class="algo">
<p>
`spatialNavigationSearch(dir, options)@m
~method~手続きは：
◎
spatialNavigationSearch(dir, options)
• Let direction be the value of dir.
</p>
<ol>
	<li>
%容器 ~LET %options の `container$mSO ~member
◎
↓</li>
	<li>
<p>
~IF［
%容器 は`空間的~navi容器$でない
］：
</p>
		<ol>
			<li>
~IF［
%容器 ~EQ ~NULL
］
⇒
%容器 ~SET コレ
</li>
			<li>
%容器 ~SET %容器 の先祖の`空間的~navi容器$のうち %容器 に最も近いもの
</li>
		</ol>
◎
Let container be
• if the value of container attribute of options is not null,
•• itself, if it is spatial navigation container.
•• its nearest spatial navigation container ancestor, otherwise.
• else the element’s nearest spatial navigation container ancestor.
</li>
	<li>
%候補たち ~LET %options の `candidates$mSO ~memberに応じて
⇒＃
~NULL でないならば その値 ／
~ELSE_ `要素の中で~focus可能な区画を見出す$( %容器 )
◎
Let areas be
• the value of candidates attribute of options if it is not null,
• result of finding focusable areas within container otherwise.
</li>
	<li>
~RET `最良な候補を選定する$( %候補たち, %dir, コレ )
【！within %容器 】
◎
Return the result of selecting the best candidate among areas within container in direction from the element.
</li>
</ol>

<p class="note">注記：
容器（ `container$mSO ）も候補の~list（ `candidates$mSO ）も供されていないとき、これは，［
先祖の`空間的~navi容器$のうち最も近いもの
］に限り，可視かつ`~focus可能な区画$たちを探索する。
`何もない場合、先祖上の連鎖を更に遡ることはなく，結果は ~NULL になる。^em
◎
Note: When neither a container nor a list of candidates is provided, this only searches through the visible focusable areas of the nearest spatial navigation container ancestor. If there isn’t any, this does not climb further up the ancestry chain, and the result will be null.
</p>
</div>

		</section>
	</section>
	<section id="events-navigationevent" class="api">
<h2 title="Navigation Events">6. ~navi~event</h2>

		<section id="interface-focusevent">
<h3 title="Interface NavigationEvent">6.1. ~interface `NavigationEvent^I</h3>

<p>
`NavigationEvent$I ~interfaceは、空間的~naviに特有な文脈~上の情報を供する。
◎
The NavigationEvent interface provides specific contextual information associated with spatial navigation.
</p>

<p>
`NavigationEvent$I ~interfaceの~instanceを作成するときは、
`NavigationEvent$I 構築子を利用する
— `NavigationEventInit$I 辞書（省略可能）を渡して。
◎
To create an instance of the NavigationEvent interface, use the NavigationEvent constructor, passing an optional NavigationEventInit dictionary.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `NavigationEvent@I : `UIEvent$I {
    `NavigationEvent@mc(`DOMString$ %type, optional `NavigationEventInit$I %eventInitDict = {});
    readonly attribute `SpatialNavigationDirection$I `dir@m;
    readonly attribute `EventTarget$I? `relatedTarget@m;
};

dictionary `NavigationEventInit@I : `UIEventInit$I {
    `SpatialNavigationDirection$I `dir@nEI;
    `EventTarget$I? `relatedTarget@nEI = null;
};
</pre>

		</section>
		<section id="events-nav-type">
<h3 title="Navigation Event Types">6.2. ~navi~event型</h3>

<p>
`この節とその下位節は規範的でない。^em
◎
This section and its subsections are not normative.
</p>

<p>
~navi~event型は、以下に要約される。
規範的かつ全部的な詳細は、
<a href="#processing-model">§ 処理~model</a>
を見よ。
◎
The Navigation event types are summarized below. For full normative details, see § 8 Processing Model.
</p>

			<section id="event-type-navbeforefocus">
<h4 title="navbeforefocus">6.2.1. `navbeforefocus@et</h4>

<p>
この~eventは、`最良な候補を選定-$した結果が妥当であるときに生じる。
◎
This event occurs when there is a valid result of selecting the best candidate.
</p>

◎イ型 `navbeforefocus^et
◎界面 `NavigationEvent$I
◎浮上 する
◎取消 可
◎文脈

<ul>
	<li>
`Event$I の `target$m
⇒＃
~focusされた要素は在るならば それ／
~ELSE_ `~body要素$ ~NEQ ~NULL ならば それ／
~ELSE_ 根~要素
◎
Event.target
• The focused element or if no element focused, then the body element if available, otherwise the root element
</li>
	<li>
`NavigationEvent$I の `relatedTarget$m
⇒
~focusされることになる`~focus可能な区画$の`~DOM~anchor$。
◎
NavigationEvent.relatedTarget
• The DOM anchor of the focusable area that will be focused
</li>
	<li>
`NavigationEvent$I の `dir$m
⇒
利用者から要請された~naviの方向。
◎
NavigationEvent.dir
• The direction of the navigation as requested by the user
</li>
</ul>
◎表終

<p id="dispatches-navbeforefocus-event">
~UAは，空間的~naviが~focusを移動する前に、~focusを得ていた要素に向けて，名前 `navbeforefocus$et の`空間的~navi~eventを配送する$ことになる
— その `relatedTarget$m は、~focusを受取ることになる要素に初期化される。
◎
The user agent dispatches navbeforefocus event before spatial navigation moves the focus. The event target is the element which has focus and the relatedTarget is the element which is about to receive focus.
</p>

<p>
%~event標的 の`~node文書$において，`~navi上書き$は［
`~top-level閲覧文脈$にて`作動中の文書$の`生成元$
］に対し不能化されている場合、この~eventは配送されない。
◎
If navigation-override is disabled in the node document of eventTarget for the origin of the active document of the top-level browsing context, this event won’t be dispatched.
</p>

<div class="example">

<p>
この例は、 `ArrowRight$kY ~Keyを~pressしたときの`~event序列$を示す。
記述を単純に保つため、この例の空間的~naviは，矢印~Keyを利用して誘発されるものと見做す。
◎
This example shows the UI Events §event-order when pressing the ArrowRight key. For the sake of keeping the description simple, this example assumes a user agent where spatial navigation is triggered using arrow keys.
</p>

<table class="complex data">

<thead>

<tr><th>
<th>~event型
<th>`KeyboardEvent$I.`key$m
<th>備考
</thead>

<tbody>

<tr><td>1
<td>`keydown$et
<td>`ArrowRight$kY
<td>
矢印~Keyなどの，空間的~naviを作動化できる~Keyでなければナラナイ。
他の場合、空間的~naviは作動化されない。
◎
MUST be a key which can activate spatial navigation, such as the arrow keys, or spatial navigation is not activated.

<tr><td>2
<td>`navbeforefocus$et
<td>
<td>
空間的~navi用の候補が無い【！ is not null】の場合に送信される。
他の場合、これは生成されない。
◎
Sent if the candidates for spatial navigation is not null, or this is not generated.

<tr><td>3
<td>`focusin$et
<td>
<td>
標的~要素が~focusを受取る前に送信される。
◎
Sent before the target element receives focus.

<tr><td>4
<td>`focus$et
<td>
<td>
標的~要素が~focusを受取った後に送信される。
◎
Sent after the target element receives focus.

</tbody></table>

</div>

<div class="example" id="delegation">

<p>
次の~codeは、空間的~naviの挙動を変更する
— ~scroll容器が~focusを取得したとき，可視かつ~focus可能な子孫が 1 個~以上あるならば、~focusは自動的にそこへ転送されるよう，再帰的に。
◎
The following code changes the behavior of spatial navigation so that when a scroll container would get focused, if it has at least one visible focusable descendant, the focus is automatically transferred to it, recursively.
</p>

<pre class="lang-js">
document.addEventListener('navbeforefocus', %e =&gt; {
    %e.preventDefault();

    let %nextTarget = %e.relatedTarget;
    if (isSpatialNavigationContainer(%nextTarget)) {
        const %areas = %nextTarget.focusableAreas();

        if (%areas.length &gt; 0) {
            %nextTarget = %nextTarget.spatialNavigationSearch(%e.dir, { candidates: %areas });
        }
    }
    %nextTarget.focus();
});

function isSpatialNavigationContainer(%element) {
    return (!%element.parentElement) ||
        (%element.nodeName === 'IFRAME') ||
        (isScrollContainer(%element)) ||
        (isCSSSpatNavContain(%element));
}
</pre>
</div>

			</section>
			<section id="event-type-navnotarget">
<h4 title="navnotarget">6.2.2. `navnotarget@et</h4>

<p>
この~eventは、空間的~naviが［
現在の`空間的~navi容器$の中の候補を見出すのに失敗した ／
`空間的~navi容器$は~scroll可能である所で更に~scrollできない
］とき，［
先祖の`空間的~navi容器$のうち最も近いもの内で候補たちを探索する
］ために~treeを遡ろうとする前に生じる。
◎
This event occurs before going up the tree to search candidates in the nearest ancestor spatial navigation container when spatial navigation has failed to find any candidate within the current spatial navigation container, and in cases where the spatial navigation container is scrollable, when it cannot be scrolled further.
</p>

◎イ型 `navnotarget$et
◎界面 `NavigationEvent$I
◎浮上 する
◎取消 可
◎文脈

<ul>
	<li>
`Event$I の `target$m
⇒＃
~focusされた要素は在るならば それ／
~ELSE_ `~body要素$ ~NEQ ~NULL ならば それ／
~ELSE_ 根~要素
◎
Event.target
• The focused element or if no element focused, then the body element if available, otherwise the root element
</li>
	<li>
`NavigationEvent$I の `relatedTarget$m
⇒
~~内部が探索された`空間的~navi容器$。
◎
NavigationEvent.relatedTarget
• The spatial navigation container that was searched in.
</li>
	<li>
`NavigationEvent$I の `dir$m
⇒
利用者から要請された~naviの方向。
◎
NavigationEvent.dir
• The direction of the navigation as requested by the user
</li>
</ul>
◎表終

<p id="dispatches-navnotarget-event">
~UAは、~focusを得ている要素に向けて，名前 `navnotarget$et の`空間的~navi~eventを配送する$ことになる
— その `relatedTarget$m は、`~event標的$の`空間的~navi容器$に初期化される。
◎
The user agent dispatches navnotarget event with initializing the event target as the element which has focus and the relatedTarget as spatial navigation container of the event target.
</p>

<p>
%~event標的 の`~node文書$において，`~navi上書き$は［
`~top-level閲覧文脈$にて`作動中の文書$の`生成元$
］に対し不能化されている場合、この~eventは配送されない。
◎
If navigation-override is disabled in the node document of eventTarget for the origin of the active document of the top-level browsing context, this event won’t be dispatched.
</p>


<div class="example">

<p>
この例は、次の図の様な状況において
`ArrowDown$kY ~Keyが~pressされたときの`~event序列$を示す。
記述を単純に保つため、この例の空間的~naviは，矢印~Keyを利用して誘発されるものと見做す。
◎
This example shows the UI Events §event-order when pressing the ArrowDown key in the situation like the following figure. For the sake of keeping the description simple, this example assumes a user agent where spatial navigation is triggered using arrow keys.
</p>

<figure>
<p class="alt" hidden id="_dgm-navnotarget-example-1">
`navnotarget^et ~eventに関する画像
◎
An image about navnotarget
</p>
<figcaption>
`~scroll容器$内に候補が無いときに、~focusを移動する様子。
◎
Moving focus when there isn’t any candidate in the scroll container.
</figcaption></figure>

<table class="complex data">
<thead><tr><th>
<th>~event型
<th>~event標的
<th>`relatedTarget^m
<th>備考
</thead>

<tbody>
<tr><td>1
<td>`keydown$et
<td>`#box2^c
<td>N/A
<td>
矢印~Keyなどの空間的~naviを作動化できる~Keyでなければナラナイ。
他の場合、空間的~naviは誘発されない。
◎
MUST be a key which can activate spatial navigation, such as the arrow keys, otherwise spatial navigation is not triggered.

<tr><td>2
<td>`navnotarget$et
<td>`#box2^c
<td>`#scrollContainer^c
<td>
`#scrollContainer^c が候補を包含しないかつ~scrollできない場合に送信される。
他の場合、これは生成されない。
◎
Sent if #scrollContainer doesn’t contain any candidate and cannot be scrolled, otherwise this would not be generated.

<tr><td>3
<td>`navbeforefocus$et
<td>`#box2^c
<td>`#box3^c
<td>
`#container^c 内に候補が無い【！ is not null】場合に送信される。
他の場合、これは発火されない。
◎
Sent if the candidates in #container is not null, otherwise this would not be fired.

<tr><td>4
<td>`focusin$et
<td>`#box3^c
<td>`#box2^c
<td>
標的~要素が~focusを受取る前に送信される。
◎
Sent before the target element receives focus.

<tr><td>5
<td>`focus$et
<td>`#box3^c
<td>`#box2^c
<td>
標的~要素が~focusを受取った後に送信される。
◎
Sent after the target element receives focus.
</tbody></table>

<p>
この例の結果は、次のような図になる：
◎
The result of this example is the figure as follows:
</p>

<figure>
<p class="alt" hidden id="_dgm-navnotarget-example-2">
`navnotarget^et ~eventの結果に関する画像
◎
An image of the result about navnotarget
</p>
<figcaption>
`~scrollport$内に候補が無く，`~scroll容器$も~scrollできないときには、~focusを移動する結果になる。
◎
The result of moving focus when there isn’t any candidate in the scrollport and scroll container cannot be scrolled.
</figcaption></figure>

<p>
この例では、次の~markupが利用されている：
◎
This example uses the markup as follows:
</p>

<pre class="lang-css">
#container {
    width: 900px;
    height: 1400px;
}

#scrollContainer {
    width: 700px;
    height: 700px;
    overflow-x: hidden;
    overflow-y: auto;
}

.item {
    width: 150px;
    height: 110px;
    background-color: blue;
}

.item:focus {
    background-color: red;
}
</pre>

<pre class="lang-html">
&lt;div id="container"&gt;
    &lt;div id="scrollContainer"&gt;
        &lt;div id="box1" class="item" tabindex="0"&gt;Box 1&lt;/div&gt;
        &lt;div id="box2" class="item" tabindex="0"&gt;Box 2&lt;/div&gt;
    &lt;/div&gt;
    &lt;div id="box3" class="item" tabindex="0"&gt;Box 3&lt;/div&gt;
&lt;/div&gt;
</pre>

</div>


<div class="example" id="loop">
<p>
次の~codeは、`空間的~navi容器$の中の~focusを捕えるよう，縦方向に~scroll可能な空間的~naviの挙動を変更する
— ［
要請された方向には，~focus可能な要素はそれ以上~見出されない
］かつ［
`空間的~navi容器$はそれ以上~scrollできない
］ときは、~focusを容器の外側へ移動する代わりに，~~反対~側へ~loopして戻るようにする。
◎
The following code changes the behavior of spatial navigation to trap the focus within a spatial navigation container which is vertically scrollable. When no further focusable elements can be found in the requested direction and the spatial navigation container cannot be scrolled any further, the focus loops back to the other side instead of moving outside of it.
</p>

<p>
しかしながら、~focusは［
逐次的~navi／
~mouseによるヤリトリ ／
`focus()$m を~program的に~callする
］などにより，依然として外側へ移動できる。
◎
However, the focus can still be moved outside by sequential navigation, mouse interaction, or programmatic calls to focus().
</p>

<pre class="lang-js">
%scrollContainer.addEventListener('navnotarget', %e => {
    let %nextTarget = null;
    const %verticalDir = ['up', 'down'];
    const %candidates = %e.relatedTarget.focusableAreas({'mode': 'all'});

	/* <span class="comment">
~navi方向が y 軸~上にあるときに限り， `preventDefault()^m する。
◎
Prevent default only when navigation direction is on y-axis
</span> */
    if (%verticalDir.includes(%e.dir) && (%candidates.length > 0)) {
        %e.preventDefault();

        if (%e.dir === 'down') {
            %nextTarget = %candidates[0];
        } else if (%e.dir === 'up') {
            %nextTarget = %candidates[%candidates.length-1];
        }
        %nextTarget.focus();
    }
});
</pre>

</div>

			</section>
		</section>
	</section>
	<section id="policy-feature">
<h2 title="The navigation-override policy-controlled feature">7. ~navi上書き 施策により制御される特能</h2>

<p>
`~navi上書き@
（ `navigation-override^en ）は，`施策により制御される特能$であり、［
~page作者が［
空間的~naviの挙動に対する制御を司る／空間的~naviを即座に取消す
］ことを可能化する仕組み
］の可用性を制御する。
◎
The navigation-override policy-controlled feature controls the availability of mechanisms that enables the page author to take control over the behavior of spatial navigation, or to cancel it outright.
</p>

<ul>
	<li>
この特能の名前は、`navigation-override^l とする。
◎
The feature name is "navigation-override"
</li>
	<li>
`~navi上書き$用の`既定の許容list$は、 `'self'^l とする。
◎
The default allowlist for navigation-override is "self"
</li>
</ul>

<p>
`§ ~navi$にて更なる詳細が定義されるように、ある文書~内で`~navi上書き$が不能化された場合，~navi~event（
<a href="#events-navigationevent">§ ~navi~event</a>
を見よ）は発火されないことになる。
◎
As defined in further details in § 8.3 Navigation, if navigation-override is disabled in a document, the navigation events (see § 6 Navigation Events) will not be fired.
</p>

<p class="note">注記：
これは、敵対的な~iframeがこれらの~eventを利用して~focusを乗取ることを防止する。
空間的~navi以前に、悪意的な作者が［
~focusがどこへ行くか制御する，利用者の能
］に干渉することにも利用できるような他の仕組みが存在することは認識されている。
にもかかわらず、この攻撃~面を増やさない試みに~~価値はあると見受けられる
— そのような攻撃は、この試みを~~無為にするほど，すでに容易に遂行することがアリだが。
この論題に対し，実装の経験やそのような攻撃の軽減-法に基づく更なる~feedbackがあれば、ぜひ寄せてほしい。
◎
Note: This is to prevent a hostile iframe from using these events in order to hijack the focus. We recognize that there exist other mechanisms predating spatial navigation that malicious the author could use to interfere with the user’s ability to control where the focus goes. Despite that, it seems worthwhile to attempt not to increase this attack surface, although it is possible that such attacks are already sufficiently easy to perform that this is a lost cause. Further feedback on this topic, based on experience with implementation or with mitigating such attacks, is very welcome.
</p>

	</section>
	<section id="processing-model">
<h2 title="Processing Model">8. 処理~model</h2>

<div class="verbose">

<p>
<a href="#overview">§ 概観</a>
では、空間的~naviがどう働くか, および
この仕様の読者が頭の中に一般的な~modelを築き易くするための，高~levelな案を与えた。
それは，直感的だが精確でない各種用語を利用し、可読性のため多くの詳細を伏せていた。
◎
The § 3 Overview section gives a high level idea of how spatial navigation works, to help readers of this specification build a general mental model. It uses intuitive but imprecise terminology, and glosses over many details for the sake of readability.
</p>

<p>
この節では、対応する規範的な挙動を定義し，その挙動を全部的に定義するために必要とされる詳細を与えることを目指す。
◎
This section defines the corresponding normative behavior and aims for as much detail as necessary to fully define the behavior.
</p>

</div>

		<section id="glossary">
<h3 title="Glossary">8.1. 用語集</h3>

<p>
空間的~navi用の処理~modelを説明するため、以下に与える用語が定義される。
更なる情報は、定義の中の~linkを見よ。
◎
The following term definitions have been specified to explain the processing model for spatial navigation. See the links within the definitions for more information.
</p>

<p>
~objの
`境界~box@
（ `boundary box^en ）は、次に従って定義される：
◎
The boundary box of an object is defined as follows:
</p>

<ul>
	<li>
~objは~pointである場合
⇒
その~point
◎
if the object is a point, the boundary box is that point
</li>
	<li>
~objは［
`~box$／`~box断片$
］である場合
⇒
~objの`~border~box$
◎
if the object is a box or box fragment, the boundary box is the border box of that box or fragment
</li>
	<li>
~objは`~focus可能な区画$であって要素でない場合
⇒
~objの限界~box
— その各~辺は軸に平行な
◎
if the object is a focusable area which is not an element, the boundary box is the axis-aligned the bounding box of that focusable area
</li>
</ul>

<p>
~objの
`内側~区画@
（ `inside area^en ）は、次に従って定義される：
◎
The inside area of an object is defined as follows:
</p>

<ul>
	<li>
~objは`~scroll容器$である場合
⇒
~objの`最適な~view用~領域$
◎
if the object is a scroll container, its optimal viewing region
</li>
	<li>
~objは`文書$である場合
⇒
~objが`属する閲覧文脈$の表示域
【！＊属する閲覧文脈 ~EQ ~NULL の場合にどうなるかは述べられていない。】
◎
if the object is a document, the viewport of its browsing context
</li>
	<li>
~objは［
`~box$／`~box断片$
］である場合
⇒
その`境界~box$
◎
if the object is a box or box fragment, its boundary box
</li>
	<li>
他の場合
⇒
［
~objに最も近い，先祖`~scroll容器$
］の`最適な~view用~領域$
◎
otherwise, the optimal viewing region of its nearest ancestor scroll container
</li>
</ul>

<p class="note">注記：
~objが~screenから外れている場合、`内側~区画$は，可視な先祖~容器のうち最も近いものになるべきである。
◎
NOTE: If an object is offscreen, the inside area should be the nearest visible ancestor container.
</p>

<p class="issue">
~CSSには
“`border-radius^p の様な隅~形状付け~propを織り込んだ~border~box”
用の用語があるベキである。
`2324$issue
◎
CSS should have a term for “border box taking into account corner shaping properties like border-radius”. &lt;https://github.com/w3c/csswg-drafts/issues/2324&gt;
</p>

<p>
`探索~起点@
（ `search origin^en ）は、次にある標的を探索するための起点である。
◎
The search origin is the origin for searching next target.
</p>

<p>
`空間的~navi始点@
（ `spatial navigation starting point^en ）は、次にある標的を探索するために~UAが設定した起点である。
それは、初期~時には ε であり，要素にも~pointにもなり得る。
◎
The spatial navigation starting point is the origin for searching next target which is set by the user agent. It is initially unset and it can be element or point.
</p>

<p class="note">注記：
例えば~UAは、［
利用者が文書~内容~上で~clickしたときは ~clickした位置に設定する ／
（空間的~naviその他の手段により）~focusが移動されたときは ε に設定する
］こともできる。
◎
Note: For example, the user agent could set it to the position of the user’s click if the user clicks on the document contents, and unset when the focus is moved (by spatial navigation or any other means).
</p>

<p>
~UAは、［
`空間的~navi始点$,
`逐次的~focus~naviの始点$
］両者とも【非 ε に】設定する場合，それらを同じ値に設定するモノトスル。
◎
If the user agent sets both a spatial navigation starting point and a sequential focus navigation starting point, they must not be set differently.
</p>

<div class="algo">
<p>
`空間的~navi~eventを配送する@
ときは、所与の
( %標的, %~event名, %方向, %関係する標的 )
に対し
⇒
`~eventを発火する$( %標的, %~event名, `NavigationEvent$I )
— 次のように初期化して
⇒＃
`dir$m ~SET %方向,
`relatedTarget$m ~SET %関係する標的,
`bubbles^m 属性 ~SET ~T,
`cancelable^m 属性 ~SET ~T
</p>

<p class="trans-note">【
この手続きは、他所の記述を集約する／明確化するために，この訳に導入している。
】</p>
</div>

		</section>
		<section id="grouping">
<h3 title="Groupings of elements">8.2. 要素の~group化</h3>

<p>
空間的~navi用の処理~modelは［
文書の~layout, ~focus可能な要素の相対的~位置
］から働くが、~UAには，局所的かつ論理的な~group化から優先的に要素を見出すことが要求される
— ~group化の内側で探してから、相応しいものを見出せなかったときに限り，外側で~focus可能な要素を探すように（詳細は`§ ~navi$を見よ）。
◎
While the processing model for spatial navigation is to work from the layout of the document and the relative position of focusable elements, the user agent is required to prioritize finding elements from a local logical grouping, only looking for focusable elements outside of the grouping if a suitable one cannot be found inside it (see § 8.3 Navigation for details).
</p>

<p>
そのような~group化は、
`空間的~navi容器@
（ `spatial navigation container^en ）と呼ばれる。
◎
Such groupings are called spatial navigation containers.
</p>

<p>
既定では、`空間的~navi容器$は，次により確立される：
◎
By default, spatial navigation containers are established by:
</p>

<ul>
	<li>
`閲覧文脈$の表示域（`~top-level閲覧文脈$に制限されない）
◎
The viewport of a browsing context (not limited to the top-level browsing context)
</li>
	<li>
`~scroll容器$
◎
scroll containers
</li>
</ul>

<p>
`spatial-navigation-contain$p ~propを利用すれば、`空間的~navi容器$を追加的に作成できる
（
<a href="#container">§ 追加的な空間的~navi容器の作成-法</a>
を見よ）。
◎
Additional spatial navigation containers can be created using the spatial-navigation-contain property (see § 9.1 Creating additional spatial navigation containers: the spatial-navigation-contain property).
</p>

		</section>
		<section id="nav">
<h3 title="Navigation">8.3. ~navi</h3>

<p>
空間的~navi用の処理~modelは、空間的~naviが一般にどう働くかを述べる。
◎
The processing model for spatial navigation describes how spatial navigation works in general.
</p>

<figure class="verbose non-normative">

<figcaption>
次の図は、規範的でない。
それは、この節に定義される更なる処理~modelの概観を与える
— `spatial-navigation-action$p ~propは初期~値 `auto$v をとると見做す下で。
◎
Overview of the Spatial navigation processing model
◎
This figure is not normative. It gives an overview of the processing model further defined in this section, assuming that the spatial-navigation-action property has its initial value of auto.
</figcaption>
<p class="trans-note">【
下の`空間的~navi手続き$の概略的な流れ図。
この図は未訳なので、
<a href="~CSSWG/css-nav-1/images/spatnav_processing_model_diagram.svg">原文の図式</a>
を参照されたし。
】</p>
【！spatnav_processing_model_diagram】
</figure>

<div class="algo">
<p>
`空間的~navi手続き@
（ `spatial navigation steps^en ）は、所与の
( %方向 )
に対し，次を走らす：
◎
To run the spatial navigation steps in direction, do the following:
</p>
<ol>
	<li>
%探索~起点 ~LET `探索~起点を設定する$()
◎
Let searchOrigin be the result of setting the search origin.
</li>
	<li>
%~event標的 ~LET %探索~起点
◎
↓</li>
	<li>
<p>
~IF［
%探索~起点 は`~node$でない（位置である【`空間的~navi始点$を見よ】）
］
⇒
%~event標的 ~SET %探索~起点 を包含する`~node$
</p>

<p class="trans-note">【
%~event標的 は、~text~nodeにもなり得ることになる（どの~nodeも `EventTarget$I を実装する）。
】</p>

◎
If searchOrigin is an node, let eventTarget be searchOrigin
◎
else (assert: searchOrigin is a position) let eventTarget be the node which contains searchOrigin
</li>
	<li>
%文書 ~LET %~event標的 の`~node文書$
◎
↓</li>
	<li>
~IF［
%~event標的 は［
`文書$／`文書~要素$
］である
］
⇒
%~event標的 ~SET ［
%文書 の`~body要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %文書 の`文書~要素$
］
◎
If eventTarget is the Document or the document element, set eventTarget be the body element if it is not null or to the document element otherwise.
</li>
	<li>
~IF［
%~event標的 は`手動で~scrollできる$
【！ 不要：%~event標的 は`~scroll容器$である】
］~AND［
%~event標的 上の `spatial-navigation-action$p ~propの算出d値 ~EQ `scroll$v
］
⇒＃
`要素をある方向へ~scrollする$( %~event標的, %方向 )；
~RET
◎
If eventTarget is scroll container and the computed value of the spatial-navigation-action property on eventTarget is scroll and eventTarget can be manually scrolled, then directionally scroll the element eventTarget and return.
</li>
	<li>
<p>
~IF［
%~event標的 は［
`~scroll容器$ ／ `文書$
］である
］：
◎
Else, if eventTarget is either a scroll container or the document
<p>
		<ol>
			<li>
%可視のみか ~LET %~event標的 上の `spatial-navigation-action$p ~propの算出d値に応じて
⇒＃
`focus$v ならば ~F ／
~ELSE_ ~T
◎
↓</li>
			<li>
%候補たち ~LET `要素の中で~focus可能な区画を見出す$( %~event標的, %可視のみか )
◎
Let candidates be the result of finding focusable areas within eventTarget with the argument visibleOnly set to false if computed value of the spatial-navigation-action property on eventTarget is focus or to true otherwise.
</li>
			<li>
<p>
~IF［
%~event標的 上の `spatial-navigation-action$p ~propの算出d値 ~NEQ `focus$v
］~AND［
%~event標的 は`手動で~scrollできる$
］：
</p>
				<ol>
					<li>
`要素をある方向へ~scrollする$( %~event標的, %方向 )；
</li>
					<li>
~RET
</li>
				</ol>
◎
If the computed value of the spatial-navigation-action property on eventTarget is not focus and eventTarget can be manually scrolled, then directionally scroll the element eventTarget in direction and return.
</li>
			<li>
<p>
~IF［
%候補たち は空でない
］：
◎
Else if candidates contains at least 1 item:
<p>
				<ol>
					<li>
%最良な候補 ~LET `最良な候補を選定する$( %候補たち, %方向, %探索~起点 )
◎
Let bestCandidate be the result of selecting the best candidate within candidates in direction starting from searchOrigin
</li>
					<li>
`空間的~navi~eventを配送する$( %~event標的, `navbeforefocus$et, %方向, %最良な候補 )
【！#dispatches-navbeforefocus-event】
◎
Dispatches navbeforefocus event at eventTarget with direction and bestCandidate.
</li>
					<li>
`~objを~focusする$( %最良な候補 )
◎
Run the focusing steps for bestCandidate and＼
</li>
					<li>
~RET
◎
return
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%容器 ~LET ［
%~event標的 の先祖である`空間的~navi容器$のうち， %~event標的 に最も近いもの
］
◎
（前段の一部 — 不要）
•• Else, fall back to the next step.
• Else, fall back to the next step.
◎
Let container be the nearest ancestor of eventTarget that is a spatial navigation container.
</li>
	<li>
%候補たち ~LET ε
◎
↓</li>
	<li>
<p>
~WHILE 無条件：
◎
Loop:＼
</p>
		<ol>
			<li>
%可視のみか ~LET %容器 上の `spatial-navigation-action$p ~propの算出d値に応じて
⇒＃
`focus$v ならば ~F ／
~ELSE_ ~T
◎
↓</li>
			<li>
%候補たち ~SET `要素の中で~focus可能な区画を見出す$( %容器, %可視のみか )
【！excluding eventTarget 不要？】
◎
Let candidates be the result of finding focusable areas within container with the argument visibleOnly set to false if computed value of the spatial-navigation-action property on container is focus or to true otherwise, excluding eventTarget
</li>
			<li>
~IF［
%候補たち は空でない
］
⇒
~BREAK
◎
If candidates is empty:
</li>
			<li>
<p>
~IF［
%可視のみか ~EQ ~T
］~AND［
%容器 は`手動で~scrollできる$
【！不要`~scroll容器$である】
］：
</p>
				<ol>
					<li>
`要素をある方向へ~scrollする$( %容器, %方向 )；
</li>
					<li>
~RET
</li>
				</ol>
◎
If the computed value of the spatial-navigation-action property on container is not focus and container is a scroll container that can be manually scrolled, directionally scroll the element container in direction and return.
◎
Else,
</li>
			<li>
`空間的~navi~eventを配送する$( %~event標的, `navnotarget$et, %方向, %容器 )
【！#dispatches-navnotarget-event】
◎
Dispatches navnotarget event at eventTarget with direction and container.
</li>
			<li>
<p>
~IF［
%容器 は`文書~要素$である
］：
</p>
				<ol>
					<li>
%B ~LET %容器 の`~node文書$が`属する閲覧文脈$
</li>
					<li>
~IF［
%B は`~top-level閲覧文脈$である
］
⇒
~RET
— ~UAは、 %方向 を尊守しつつ，自前の~controlがあれば ~focusをそこへ転送してもヨイ。
</li>
					<li>
%探索~起点 ~SET %B の`容器$bc
</li>
					<li>
%~event標的 ~SET %探索~起点
</li>
					<li>
%容器 ~SET %探索~起点
</li>
				</ol>
◎
If container is the document element of the top-level browsing context, then return. The user agent may transfer focus to its own controls (if any) honouring direction.
◎
Else, if container is the document element of a nested browsing context then:
• Set searchOrigin to container’s browsing context container
• Set eventTarget be searchOrigin
◎
↓</li>
			<li>
%容器 ~SET %容器 の先祖である`空間的~navi容器$のうち %容器 に最も近いもの
◎
• Set container to the nearest ancestor of eventTarget that is a spatial navigation container.
• Return to the step labeled loop.
◎
Else, set container to its closest ancestor that is itself a spatial navigation container and return to the step labeled loop.
</li>
		</ol>
	</li>
	<li>
%最良な候補 ~LET `最良な候補を選定する$( %候補たち, %方向, %~event標的 )
◎
Let bestCandidate be the result of selecting the best candidate within candidates in direction starting from eventTarget.
</li>
	<li>
`空間的~navi~eventを配送する$( %~event標的, `navbeforefocus$et, %方向, %最良な候補 )
◎
Dispatches navbeforefocus event at eventTarget with direction and bestCandidate.
</li>
	<li>
`~objを~focusする$( %最良な候補 )
◎
Run the focusing steps for bestCandidate and return.
</li>
</ol>

</div>

		</section>
		<section id="heuristics">
<h3 title="Focus Navigation Heuristics">8.4. ~focus~naviの経験則</h3>

<p class="note">注記：
次の~algoは、 Chrome の実装, および
<a href="https://www.w3.org/TR/WICD/#focus-handling">旧 WICD 仕様</a>
から着想されている。
これらの~approachより良い~approachや精緻化を見出した実装者には
— この仕様の改善を~~促して，相互運用能を最大化するため —
~feedbackを供することが強く奨励される。
特に，~UAが`要素の中で~focus可能な区画を見出す$方法に分岐があると、何らかの要素が~focus可能かどうかが~UAごとにまちまちになり，利用者にとって不都合になる。
◎
Note: The following algorithms are inspired from Chrome’s implementation as well as from the old WICD Spec. Implementors who find better approaches or refinements to these approaches are strongly encouraged to provide feedback and help improve this specification in order to maximize interoperability. In particular, divergences in how user agents find focusable areas may cause some elements to be focusable in some user agents but not in others, which would be bad for users.
</p>

<p>
この節における幾何-演算は、すべて，~CSS~layoutの結果に対し働くよう定義される
— `相対~位置決め$や `CSS-TRANSFORMS-1$r などの すべての~graphicな変形nも含めて。
◎
All geometrical operations in this section are defined to work on the result of CSS layout, including all graphical transformations, such as relative positioning or [CSS-TRANSFORMS-1].
</p>

<div class="algo">
<p>
`探索~起点を設定する@
（ `set the search origin^en ）ときは、次の手続きを走らす
— 加えて，`探索~起点$をその結果に設定する：
◎
To set the search origin, run the following steps:
</p>
<ol>
	<li>
%探索~起点 ~LET `~top-level閲覧文脈の現在の被focus区画$の`~DOM~anchor$
◎
Let searchOrigin be the DOM anchor of the currently focused area of a top-level browsing context.
</li>
	<li>
%始点 ~LET `空間的~navi始点$
◎
↓</li>
	<li>
~IF［
%始点 ~NEQ ε【！~NULL】
］~AND［
%始点 は %探索~起点 の内側にある
］
⇒
~RET %始点
◎
If the spatial navigation starting point is not null and it is inside searchOrigin, then return it.
</li>
	<li>
~RET %探索~起点
◎
Otherwise, return searchOrigin.
</li>
</ol>

<p>
%~focus標的 の状態sが［
~focusを移動する以外の何か
］により変化したときは、
`探索~起点を更新する@
— `探索~起点$を %~focus標的 に応じて次の結果に設定する：
◎
If the status of focus target changed not by moving the focus, update the search origin as following:
</p>

<p class="trans-note">【
これは他所にどう影響する？ 上の~algoの最初の段における %探索~起点 の設定を以下に改めるのか？それとも結果を以下に改めるのか？
】【
以下に与える条件は、おそらく 2, 3, 1 個目の順に優先されるべきであろう（例えば， “除去された” なら、必然的に “具現化されていない” ことになる）。
】</p>

<ol class="switch">
	<li>
%~focus標的 は［
`実際に不能化され$た／
`明に不活$になった／
`具現化され$なくなった
］
⇒
%~focus標的 の`境界~box$
◎
If focus target becomes actually disabled or expressly inert or not being rendered, then let searchOrigin be the boundary box of focus target.
</li>
	<li>
%~focus標的 は`除去された$
⇒
除去される直前における， %~focus標的 の`境界~box$
◎
If focus target is removed, then let searchOrigin be the boundary box of focus target with the position of focus target when it existed.
</li>
	<li>
%~focus標的 は完全に~screenから外れている
⇒
［
可視な`空間的~navi容器$のうち，
%~focus標的 に最も近い【先祖である？】もの
］の表示域
◎
If focus target is completely off-screen, then let searchOrigin be the viewport of focus target’s nearest visible spatial navigation container.
</li>
	<li>
他の場合
⇒
【更新しない？ “変化したとき” は上に挙げたもので網羅されている？】
◎
↑</li>
</ol>

<p class="note">注記：
~UAは、例えば，~focusされている要素が［
~mouseにより~scrollされた／表示域から消え失せた
］とき，`探索~起点を更新する$ベキである。
◎
NOTE: The user agent should update the search origin, for example, when the focused element was scrolled out by mouse scrolling or vanished from the viewport.
</p>

</div>

<div class="algo">
<p>
`要素の中で~focus可能な区画を見出す@
（ `find focusable areas within a containing element^en ）ときは、所与の
( 要素 %C, 真偽値 %可視のみか （省略時は ~T ）)
に対し，次の手続きを走らす：
◎
To find focusable areas within a containing element C, with an optional visibleOnly argument that defaults to true, run the following steps:
</p>
<ol>
	<li>
%~focus可能~集合 ~LET ［
`~focus可能な区画$のうち，その`~DOM~anchor$は %C の子孫であるもの
］からなる`有順序~集合$
— ただし、`~box$が何個かの`~box断片$からなる事例では，各`~box断片$を別個のものと見なす。
◎
Let focusables be the set of all the focusable areas whose DOM anchor are descendants of C. In the case of boxes with several box fragments, each box fragment is considered separately.
</li>
	<li>
<p>
~UAは、次を行うベキである
⇒
%~focus可能~集合 から次を満たす~itemを`除去する$
⇒
~itemの`~DOM~anchor$の `tabindex$a 属性は負な値に設定されている
◎
The user agent should remove from focusables items that have a DOM anchor whose tabindex attribute is set to a negative value.
<p>

<p class="note">注記：
これが、 “ベキ” とされているのは、［
`逐次的~focus~navi順序$からは，負な~tabindexを伴う要素を除外する “ベキ”
］ものと `tabindex^a にて定義されているからである。
【`~tabindex値$を見よ。】
◎
Note: This is a "SHOULD" in order to mirror the exclusion of elements with negative tabindex from the sequential focus navigation order as defined in tabindex.
</p>

	</li>
	<li>
<p>
~IF［
%可視のみか ~EQ ~F
］
⇒
~RET %~focus可能~集合
◎
If visibleOnly is false, return focusables.
<p>

<p class="note">注記：
%~focus可能~集合 は空になることもある。
◎
Note: focusables may be empty
</p>
	</li>
	<li>
<p>
%可視~集合 ~LET %~focus可能~集合 から次に該当する~itemを除去した結果
⇒
その`境界~box$は %C の`内側~区画$に一部でも入らないもの
◎
Let visibles be the subset of items in focusables whose boundary box is at least partly within the inside area of C.
<p>

<p class="advisement non-normative">
~scroll容器~内で現在~可視でない要素は除き、空間的~naviは，~clickできない要素
— 例えば，他の要素により遮られていることに因り —
を自動的に除外しない。
［
利用者が そのような要素を実際に~focusして作動化した場合に，~app~logicにおける前提を覆す
］のを避けるため，および［
不可視あるいは外見的に到達-不能な要素に~focusして，利用者を惑わす
］のを避けるためには、作者は［
要素を逐次的~naviから到達-不能にするのと同じ最善な実施
］を利用して，これらの要素を空間的~naviから到達-不能にするベキである
— `tab-index="-1"^c や `inert$a 属性 などを利用して。
◎
Except for elements that are in the currently non visible part of a scroller, spatial navigation does not automatically exclude elements which cannot be clicked on, for example, due to being obscured by some other element. To avoid breaking assumptions in the application logic if a user actually focuses and activates such an element, and to avoid confusing users by focusing invisible or apparently unreachable elements, the author should use make these elements unreachable to spatial navigation using the same best practices as for making elements unreachable to sequential navigation, such as using tab-index="-1" or the inert attribute.
</p>

	</li>
	<li>
<p>
~RET %可視~集合
◎
Return visibles.
<p>

<p class="note">注記：
%可視~集合 は空になることもある。
◎
Note: visibles may be empty
</p>
	</li>
</ol>

</div>

<div class="algo">
<p>
`最良な候補を選定する@
（ `select the best candidate^en ）ときは、所与の
( `有順序~集合$ %候補たち, 方向 %方向, %探索~起点 )
に対し，次の手続きを走らす：
◎
To select the best candidate within a set of candidates in a direction dir, starting from searchOrigin, run the following steps:
</p>
<ol>
	<li>
~IF［
%候補たち は`空$である
］
⇒
~RET ~NULL
◎
If candidates is empty, return null
</li>
	<li>
~IF［
%候補たち は 1 個の~itemのみからなる
］
⇒
~RET その~item
◎
If candidates contains a single item, return that item
</li>
	<li>
%内側~区画 ~LET %探索~起点 の`内側~区画$
◎
↓</li>
	<li>
%境界~box ~LET %探索~起点 の`境界~box$
◎
↓</li>
	<li>
<p>
%内側にあるものたち ~LET ［
%候補たち を成す~itemのうち，その`境界~box$は次のいずれかを満たすもの
］からなる下位集合：
◎
Let insiders be the subset of candidates
<p>
		<ul>
			<li>
%内側~区画 に全部的に重合する
【 %内側~区画 に入りきる？（完全に覆うのではなく）】
◎
whose boundary box fully overlaps with inside area of searchOrigin
</li>
			<li>
<p>
%内側~区画 に部分的に
— %方向 に応じて次を満たすように —
重合する：
◎
whose boundary box partially overlaps with inside area of searchOrigin as
</p>
				<ul class="switch">
					<li>
`down$l
⇒
上端~辺は %境界~box の上端~辺より下にある
◎
top edge is below the top edge of searchOrigin’s boundary box if dir is down
</li>
					<li>
`up$l
⇒
下端~辺は %境界~box の下端~辺より上にある
◎
bottom edge is above the bottom edge of searchOrigin’s boundary box if dir is up
</li>
					<li>
`left$l
⇒
右端~辺は %境界~box の右端~辺より左にある
◎
right edge is left of the right edge of searchOrigin’s boundary box if dir is left
</li>
					<li>
`right$l
⇒
左端~辺は %境界~box の左端~辺より右にある
◎
left edge is right of the left edge of searchOrigin’s boundary box if dir is right
</li>
				</ul>

<p class="note">注記：
要素【~item】が %探索~起点 とどう重合するかについての より詳細な条件【何を指す？】は、
~focusの動きが成す連列【`逐次的~focus~navi順序$？】に影響する。
この連列は、~UXに関係するので，~UA定義な仕組みに依存する。
◎
NOTE: More detail condition about how the element is overlapped with the search origin affects the sequence of focus movement. The sequence of focus movement is related to UX, so it depends on the UA-defined mechanism.
</p>
			</li>
		</ul>

<p class="note">注記：
この下位集合~化は、要請された方向の反対へ行くのを避けるために必要とされる。
◎
Note: this sub-setting is necessary to avoid going in the opposite direction than the one requested.
</p>
	</li>
	<li>
<p>
~IF［
%内側にあるものたち は空でない
］
⇒
◎
If insiders is non empty,
<p>
		<ol>
			<li>
<p>
%最も近いものたち ~LET 
%内側にあるものたち を成す~itemのうち［
その`境界~box$は %方向 に応じて次を満たすもの
］からなる下位集合：
◎
Let closest subset be the subset of insiders whose boundary box’s
<p>

				<ul>
					<li>
`down$l
⇒
上端~辺は %内側~区画 の上端~辺に最も近い
◎
top edge is closest to the top edge of inside area of searchOrigin if dir is down
</li>
					<li>
`up$l
⇒
下端~辺は %内側~区画 の下端~辺に最も近い
◎
bottom edge is closest to the bottom edge of inside area of searchOrigin if dir is up
</li>
					<li>
`left$l
⇒
右端~辺は %内側~区画 の右端~辺に最も近い
◎
right edge is closest to the right edge of inside area of searchOrigin if dir is left
</li>
					<li>
`right$l
⇒
左端~辺は %内側~区画 の左端~辺に最も近い
◎
left edge is closest to the left edge of inside area of searchOrigin if dir is right
</li>
				</ul>
			</li>
			<li>
%最も近いものたち から次を満たす~item %A をすべて除去する†
⇒
%最も近いものたち 内に別の~item %B が在って，次を満たす
⇒
［
%A, %B の`境界~box$は重合する
］~AND［
%A より %B の方が`~CSS塗ng順序$において上層にある
］
◎
If closest subset contains a single item, return that item, else return the first item of closest subset in document order, unless its boundary box overlaps with the boundary box of another item and that item is higher in the CSS painting order. In that case, return that item instead, unless it too is overlapped with another higher item, recursively.
</li>
			<li>
~RET %最も近いものたち 内の文書~順序で最初の~item
◎
↑</li>
		</ol>

<p class="trans-note">【†
原文の再帰を孕む記述は，解りにくい（そのまま訳すと条件の適用-順序が不明瞭になる）ので、この訳では等価に変形している。
下に現れる似た記述も同様。
】</p>

	</li>
	<li>
<p>
~ELSE：
◎
Else
<p>
		<ol>
			<li>
<p>
%候補たち ~SET %候補たち を成す~itemのうち，その`境界~box$ %~item~box が［
%境界~box と重合しない
］~AND［
%方向 に応じて次を満たす
］ものからなる下位集合：
◎
Set candidates be the subset of its items which satisfies one of the following conditions:
• the item doesn’t overlap with searchOrigin and its boundary box’s
</p>
				<ul class="switch">
					<li>
`down$l
⇒
上端~辺は %境界~box の下端~辺より下にある
◎
top edge is below the bottom edge of searchOrigin’s boundary box if dir is down
</li>
					<li>
`up$l
⇒
下端~辺は %境界~box の上端~辺より上にある
◎
bottom edge is above the top edge of searchOrigin’s boundary box if dir is up
</li>
					<li>
`left$l
⇒
右端~辺は %境界~box の左端~辺より左にある
◎
right edge is left of the left edge of searchOrigin’s boundary box if dir is left
</li>
					<li>
`right$l
⇒
左端~辺は %境界~box の右端~辺より右にある
◎
left edge is right of the right edge of searchOrigin’s boundary box if dir is right
</li>
				</ul>
			</li>
			<li>
%候補たち を成す
~EACH( %候補 )
に対し
⇒
%候補 の `距離^i ~SET `最短~距離を見出す$( %探索~起点【, %候補, %方向 】)
【！＊ "and candidate in direction dir" を削除したのは何故？】
◎
For each candidate in candidates, find the shortest distance between searchOrigin.
</li>
			<li>
%候補たち から次を満たす~itemをすべて除去する
⇒
%候補たち 内の別の~itemより `距離^i が長い
◎
Return the item of the candidates set that has the smallest distance.＼
</li>
			<li>
%候補たち から次を満たす~item %A をすべて除去する
⇒
%候補たち 内に別の~item %B が在って，次を満たす
⇒
［
%A, %B の`境界~box$は重合する
］~AND［
%A より %B の方が`~CSS塗ng順序$において上層にある
］
◎
If several have the same distance, return the first one in document order, unless its boundary box overlaps with the boundary box of another item at the same distance, and that item is higher in the CSS painting order. In that case, return that item instead, unless it too is overlapped with another higher item at the same distance, recursively.
</li>
			<li>
~RET %候補たち 内の文書~順序で最初の~item
◎
↑</li>
		</ol>
	</li>
</ol>

</div>

<div class="algo">
<p>
`最短~距離を見出す@
（ `find the shortest distance^en ）ときは、所与の
( %基準, %候補, %方向 )
に対し，［
%基準 の境界~box ／ %候補 の境界~box
］の中にある~point［
%P1 ／ %P2
］を見出す
— 次に定義される %距離 を最小~化するような
⇒
%距離 ~EQ %~euclidean距離 ~PLUS %転移 ~MINUS %整列 ~MINUS %重合する面積の平方根
◎
To find the shortest distance between a reference and a candidate in direction dir, find the points P1 and P2, respectively within the boundary boxes of the reference and of the candidate, that minimize the distance as defined as below:
• distance = euclidean + displacement - alignment - sqrt(Overlap)
</p>

<p>
各~項の意味は、以下に従う：
◎
The meaning of each term is as follows:
</p>

<dl class="def-list">
	<dt>%~euclidean距離</dt>
	<dd>
%P1 から %P2 までの~euclidean距離
◎
The euclidean distance between P1 and P2
</dd>

	<dt>%転移</dt>
	<dd>
［
%基準, %候補
］どうしの %方向 における転移の度合い【直交-方向におけるずれ】
⇒
%転移 ~EQ ( ( %方向 に直交な軸における %P1 から %P2 までの絶対~距離 )
~PLUS %直交-偏り ) ~MUL %直交-重み
◎
The degree of displacement in dir between the reference and the candidate, defined as
◎
displacement = (absolute distance on the axis orthogonal to dir between P1 and P2 + orthogonalBias) * orthogonalWeight
</dd>

	<dt>%直交-偏り</dt>
	<dd>
<p>
%方向 に応じて：
</p>
		<ul class="switch">
			<li>
`left$l ／ `right$l
⇒
%基準 の限界~boxの縦幅 ~DIV 2 
</li>
			<li>
`up$l ／ `down$l
⇒
%基準 の限界~boxの横幅 ~DIV 2 
</li>
		</ul>

<p>
限界~boxの各~辺は、軸に平行とする
</p>

◎
If the dir is left or right, the height of the axis-aligned bounding box of reference / 2
◎
Else if the dir is up or down, the width of the axis-aligned bounding box of reference / 2
</dd>

	<dt>%直交-重み</dt>
	<dd>
<p>
%方向 に応じて：
</p>
		<ul class="switch">
			<li>
`left$l ／ `right$l
⇒
30
</li>
			<li>
`up$l ／ `down$l
⇒
2
</li>
		</ul>

【この相違が何に由来するのかは不明。仮に，横組みにおける行の方向に起因するならば、縦組みの下では入れ替える必要があろう。】
【！https://github.com/w3c/csswg-drafts/issues/3384#issuecomment-459628932】

◎
If the dir is left or right, 30
◎
Else if the dir is up or down, 2
</dd>

	<dt>%整列</dt>
	<dd>
%方向 における %基準, %候補 どうしの整列の度合い
⇒
%整列 ~EQ %整列-偏り ~MUL %整列-重み
◎
The degree of alignment in dir between the reference and the candidate, defined as:
• alignment = alignBias * alignWeight
</dd>

	<dt>%整列-偏り</dt>
	<dd>
<p>
%方向 に応じて：
</p>
		<ul class="switch">
			<li>
`left$l ／ `right$l
⇒
%射影が重合する長さ ~DIV %基準 の限界~boxの縦幅
</li>
			<li>
`up$l ／ `down$l
⇒
%射影が重合する長さ ~DIV %基準 の限界~boxの横幅
</li>
		</ul>
<p>
限界~boxの各~辺は、軸に平行とする
</p>

◎
If the dir is left or right, projectedOverlap / height of the axis-aligned bounding box of reference
◎
Else if the dir is up or down, projectedOverlap / width of the axis-aligned bounding box of reference
</dd>

	<dt>%射影が重合する長さ</dt>
	<dd>
<p>
%方向 に応じて：
</p>
		<ul class="switch">
			<li>
`left$l ／ `right$l
⇒
［
%基準, %候補
］の横方向への射影が縦~軸~上で重合する長さ
</li>
			<li>
`up$l ／ `down$l
⇒
［
%基準, %候補
］の縦方向への射影が横~軸~上で重合する長さ
</li>
		</ul>
◎
If the dir is left or right, the length of the overlap between the horizontal projections onto the vertical axis of the reference and the candidate
◎
Else if the dir is up or down, the length of the overlap between the vertical projections onto the horizontal axis of the reference and the candidate
</dd>

	<dd>
<figure>`projected_overlap^dgm
<figcaption>
%射影が重合する長さ
◎
projectedOverlap
</figcaption></figure>
	</dd>

	<dt>%整列-重み</dt>
	<dd>5</dd>

	<dt>%重合する面積の平方根</dt>
	<dd>
%基準, %候補 が［
重合するならば その面積の平方根 ／
重合しないならば 0
］
◎
The square root of area of overlap between the reference and the candidate, or 0 if they do not overlap.
</dd>
</dl>

<p class="note">注記：
この一般~公式は、いくつかの，良さげな代替から選取られた
— 一連の
<a href="https://wicg.github.io/spatial-navigation/tests/ux/list.html">~UX~test事例</a>
にて、最良な候補を選定するために利用されるとき，最も直感に合致するものに基づいて。
同様に，
%整列-重み, %直交-重み
の値も同じ~test事例に基づいて試験的に決定された。
結果の公式は、いくぶん複雑ではあるが，良い答えを与えるように見受けられる。
改善や単純~化の示唆があれば寄せてほしい。
◎
Note: This general formula was picked from several plausible alternatives, based on which one most often matches intuition when used to select the best candidate in a series of UX test cases. Similarly, the values of alignWeight and orthogonalWeight were also determined experimentally based on the same test cases. The resulting formula is somewhat complicated, but seems to give good answers. Suggestions for improvements or simplifications are welcome.
</p>

</div>

		</section>
	</section>
	<section id="declarative">
<h2 title="Controlling spatial navigation through declarative means">9. 宣言的な手段による空間的~naviの制御-法</h2>

		<section id="container">
<h3 title="Creating additional spatial navigation containers: the spatial-navigation-contain property">9.1. 追加的な空間的~navi容器の作成-法： `spatial-navigation-contain^p ~prop</h3>

◎名 `spatial-navigation-contain@p
◎値 `auto^v | `contain$v
◎初 `auto^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定d値
◎順 文法に従う
◎ア 離散的
◎表終

<dl>
	<dt><dfn id="valdef-spatial-navigation-contain-auto">`auto^v</dfn></dt>
	<dd>
当の要素は`~scroll容器$である場合に限り，`空間的~navi容器$を確立する
◎
If the element is a scroll container then it establishes a spatial navigation container, otherwise it does not.
</dd>

	<dt>`contain@v</dt>
	<dd>
当の要素は`空間的~navi容器$を確立する
◎
The element establishes a spatial navigation container
</dd>
</dl>

<p class="note">注記：
加えて、<a href="#grouping">§ 要素の~group化</a>に従い，`閲覧文脈$（`~top-level閲覧文脈$に制限されない）の表示域も`空間的~navi容器$を確立する。
◎
Note: In addition, as per § 8.2 Groupings of elements, the viewport of a browsing context (not limited to the top-level browsing context) also establishes a spatial navigation container.
</p>

<div class="example">

<p>
次の例は、単純~化された~TV番組表を示す。
それは、番組を表現している要素たちが成す格子があり，その周りにいくつか~UI~buttonを備える。
◎
The following example shows a simplified TV program schedule or calendar. It has a grid of elements representing TV shows or calendar entries and some UI buttons around it.
</p>

<p>
この事例では，格子の中はスカスカである。
なので、利用者が "Foo" から下へ移動しようと試行した場合、~focusは "次週" へ移動することになる
— それが下~方向において~~目的により近いので。
同じことは "Bar" から 下へ行くときも該当し、~focusは "前週" へ移動することになる。
◎
In this case, the grid is quite sparse, so if the user tries to move down from "Foo", focus would be moved to "Next Week", as it is objectively closer in the down direction. The same is true for going down from "Bar": the focus would be moved to "Previous Week".
</p>

<div id="_ex-TV-program">
<button>前週</button>
<table><tbody><tr><td><th>月<th>火<th>水<th>木<th>金<th>土<th>日
  <tr><td>0 〜 6時<td><td><td><td><td><td><td><a href="#">Foo</a>
  <tr><td>6 〜 9時<td><a href="#">Bar</a><td><td><td><td><td><td>
  <tr><td>9 〜 12時<td><td><a href="#">Bat</a><td><td><td><td><td>
  <tr><td>12 〜 18時<td><td><td><td><td><td><td>
  <tr><td>18 〜 21時<td><td><td><td><td><td><td><a href="#">Woo</a>
  <tr><td>21 〜 24時<td><td><td><td><td><td><a href="#">Baz</a><td>
</tbody></table>
<button>次週</button>
</div>

<!-- 
same is true for going down from "Bar": the focus would be moved to "Previous Week".
 	M 	T 	W 	T 	F 	S 	S
0-6 							Foo
6-9 	Bar 						
9-12 		Bat 					
12-18 							
18-21 							Woo
21-24 						Baz 	
-->

<pre class="lang-html">
&lt;div&gt;
&lt;button&gt;前週&lt;/button&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;th&gt;月&lt;th&gt;火&lt;th&gt;水&lt;th&gt;木&lt;th&gt;金&lt;th&gt;土&lt;th&gt;日
  &lt;tr&gt;&lt;td&gt;0 〜 6時&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;a href="#"&gt;Foo&lt;/a&gt;
  &lt;tr&gt;&lt;td&gt;6 〜 9時&lt;td&gt;&lt;a href="#"&gt;Bar&lt;/a&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;
  &lt;tr&gt;&lt;td&gt;9 〜 12時&lt;td&gt;&lt;td&gt;&lt;a href="#"&gt;Bat&lt;/a&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;
  &lt;tr&gt;&lt;td&gt;12 〜 18時&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;
  &lt;tr&gt;&lt;td&gt;18 〜 21時&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;a href="#"&gt;Woo&lt;/a&gt;
  &lt;tr&gt;&lt;td&gt;21 〜 24時&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;a href="#"&gt;Baz&lt;/a&gt;&lt;td&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;button&gt;次週&lt;/button&gt;
&lt;/div&gt;
</pre>

<p>
しかしながら，~table内の要素たちは互いが意味論的に関係するので、作者は，［
格子~内の~itemが~focusされるときの，格子の内側における動き
］に優先度を与えて，異なる~navi体験を供したいと求めることもあろう。
◎
However, the author may want to provide a different navigation experience giving priority to movements inside the grid once you have focused one of its items because the elements in the table are semantically related to each other.
</p>

<p>
~stylesheetに
`table { spatial-navigation-contain: contain; }^css
を追加すれば、そのような挙動になる
— その結果、~focusは，［
"Foo" から下へは "次週" に代えて "Woo" ／
"Bar" から下へは "前週" に代えて "Bat"
］へ移動することになる。
◎
Adding table { spatial-navigation-contain: contain; } to the stylesheet would result this behavior.
◎
After that, the focus would move down from "Foo" to "Woo" instead of "Next Week", and from "Bar" to "Bat" instead of "Previous Week".
</p>

<p>
~focusを~tableの外へ移動することも，依然としてアリになる。
例えば， "Foo" から右へ行くことにより，~focusは "次週" へ移動することになる
— 格子~内には、 "Foo" の右には何もないので。
◎
It would still be possible to move the focus out of the table. For example, the focus would be move to "Next week" by going right from "Foo" since there is nothing in the grid that is to the right.
</p>

</div>

<p class="note">注記：
`spatial-navigation-contain$p ~propは`~risk下$にある。
◎
Note: the spatial-navigation-contain property is at-risk.
</p>

		</section>
		<section id="css-property-spatialnavigationaction">
<h3 title="Controlling the interaction with scrolling: the spatial-navigation-action property">9.2. ~scrollingとの相互作用の制御-法： `spatial-navigation-action$p property</h3>

◎名 `spatial-navigation-action@p
◎値 `auto$v | `focus$v | `scroll$v
◎初 `auto^v
◎適 `~scroll容器$
◎継 されない
◎百 受容しない
◎算 指定d値
◎順 文法に従う
◎ア 離散的
◎表終

<p>
~focusが~scroll容器の内側にあって，
利用者が空間的~naviを誘発したとき、利用者が
— ~focusをその方向へ移動するのか, 文書をその方向へ~scrollするのか —
どちらを要請しているのか，いくぶん多義的になる。
これは，既定では自動的に決定されるが、この~propは，
~focusするのか, ~scrollするのか裁定することを作者に許容する。
◎
When the focus is inside of a scroll container and the user triggers spatial navigation, it is somewhat ambiguous whether they are requesting that the focus be moved in that direction, or whether the document should be scrolled in that direction. By default, this is automatically determined, but this property allows the author to decide between focusing or scrolling.
</p>

<p>
精確な挙動は`§ ~navi$に定義されるが、各~値による効果の高~levelな記述は下に供される。
◎
The precise behavior is defined in § 8.3 Navigation, but a high level description of the effect of each value is provided below.
</p>

<p>
空間的~naviが誘発されたときの挙動は、［
現在~focusされている要素, またはその先祖
］のうち要素に最も近い`~scroll容器$の `spatial-navigation-action$p の値に依存する。
◎
When spatial navigation is triggered, the behavior depends on the value of the spatial-navigation-action on the currently focused element if that element is a scroll container, or of its nearest scroll container ancestor if it isn’t.
</p>

<dl>
	<dt>`auto@v</dt>
	<dd>
`~scroll容器$の中の要請された方向に，可視かつ~focus可能な要素が在る場合、それらのうち最も近いものが~focusされるようになる。
他の場合、`~scroll容器$は要請された方向へ~scrollされる。
◎
If there are visible focusable elements within the scroll container in the direction requested, the closest one becomes focused. Otherwise, the scroll container is scrolled in the direction requested.
</dd>

	<dt>`focus@v</dt>
	<dd>
`~scroll容器$の中【の要請された方向】に，~focus可能な要素が在れば
— それが可視かどうかに関わらず —
~focusは，それらのうち最も近いものへ移動される。
無い場合、~scroll容器は`~scrollされない^emことに加え、探索は先祖上の連鎖へ遡るように継続される。
◎
The focus is moved to the nearest focusable element within the scroll container, regardless of whether it is visible. If there are none, the scroll container is not scrolled, and the search continues up the ancestry chain instead.
</dd>
	<dd class="note">注記：
`~scroll容器$は、それまで~viewに入ってなかった要素を~focusすることによる副作用として，~scrollされ得るが、<a href="#directionally-scroll-an-element">ある方向へ~scrollされる</a>ことはない。
◎
Note: The scroll container may be scrolled as a side effect of focusing an element which was previously not in view, but it will not be directionally scrolled.
</dd>
	<dd class="note">注記：
`spatial-navigation-action$p に `focus$v 値を与えた場合、`空間的~navi容器$の表示域の中で，所与の方向に可視な候補が無いときは， `navnotarget$et ~eventが生じる
— 当の容器をもっと~scrollできるときでも。
◎
Note: If the focus value is given to spatial-navigation-action, navnotarget event occurs when there isn’t any visible candidate in the given direction within the viewport of the spatial navigation container even if the container can be scrolled more.
</dd>

	<dt>`scroll@v</dt>
	<dd>
現在~focusされている要素が`~scroll容器$でない場合、先祖`~scroll容器$上のこの値は `auto$v と同じ効果になる。
◎
If the currently focused element is not itself a scroll container, this value on an ancestor scroll container has the same effect as auto.
</dd>
	<dd>
現在~focusされている要素が`~scroll容器$である場合、~focus可能な子孫の有無に関わらず，要請された方向に~scrollされ、どの要素が~focusされているかは変更しない。
◎
If the currently focused element is a scroll container, it is scrolled in the direction requested without changing which element is in focus, regardless of the presence of focusable descendants.
</dd>
	<dd class="note">注記：
このことは、［
~focusを`~scroll容器$へ移動して，そこへ~scrollしつつ、その子孫へは~focusを移動しない
］ことに，空間的~naviを利用できることを意味する。
しかしながら，~focusが他の何らかの手段（
`Tab$kY ~Keyを~pressしたり， `focus()$m ~methodを利用するなど
）により子孫に移動された場合は、空間的~naviは，~focusを他の~focus可能な子孫へ移動することに利用され得る。
◎
Note: This means that spatial navigation can be used to move the focus to a scroll container and to scroll it, but not to move the focus to its descendants. However, if the focus is moved to a descendant by some other mean (such as pressing the Tab key or using the &lt;focus()&gt; method) spatial navigation can be used to move the focus to other focusable descendants.
</dd>
	<dd class="note">注記：
`scroll^v 値は`~risk下$にある。
◎
Note: The scroll value is at-risk.
</dd>
</dl>

<p class="note">注記：
この仕様の早期の~versionは、［
`focus$v により定義される挙動を任意選択で~~選ぶための宣言的な仕方
］を提供していなかった代わりに，作者がその挙動を自身で実装できるよう［
~scrollする前に発火される取消~可能な~event
］を提供していた。
しかしながら，~scrollingに関係する取消~可能な~eventは処理能の問題をもたらし得るので、この~eventは除去され，代わりに `spatial-navigation-action$p ~propが導入された。
◎
Note: Earlier version of this specification did not offer a declarative way to opt into the behavior defined by focus, and instead offered a cancellable event that would be fired before scrolling, so that the author could implement that behavior themselves. However, cancellable events related to scrolling can cause performance problems, so this event was removed and the spatial-navigation-action property was introduced instead.
</p>

<div class="example">

<p>
この例においては、ある~scroll可能な容器の `spatial-navigation-action$p に `focus^v が指定されている。
容器の内側には、`~scrollport$の中の~viewの外に要素がある。
下~矢印~Keyを~pressすると，~focusは直にそこへ移動する
— 手動で~scrollしなくとも。
◎
In this example, a scrollable container is specified with spatial-navigation-action: focus. Inside the container, there is an element which is out of the view within a scrollport. Pressing the down arrow key moves the focus directly to it without scrolling manually.
</p>

<figure>`spatnav-action^dgm
<figcaption>
手動で~scrollすることなく，~focusを "Box 2" から "Box 3" へ移動する
◎
Moving focus from "Box 2" to "Box 3" without manually scrolling
</figcaption></figure>

<pre class="lang-html">
&lt;div class='scroller'&gt;
    &lt;button class='item'&gt;Box 1&lt;/button&gt;
    &lt;button class='item'&gt;Box 2&lt;/button&gt;
    &lt;button class='item'&gt;Box 3&lt;/button&gt;
&lt;/div&gt;
</pre>

<pre class="lang-css">
.scroller {
    display: grid;
    grid-template-columns: repeat(1, 1fr);
    height: 300px;
    width: 200px;
    overflow-y: scroll;
    spatial-navigation-action: focus;
}
.item {
    height: 100px;
    width: 100px;
    margin: 50px auto;
    background-color: blue;
}
:focus {
    background-color: red;
}
</pre>

</div>

	</section>
		<section id="css-property-spatialnavigationfunction">
<h3 title="Selecting the navigation algorithm: the spatial-navigation-function property">9.3. ~navi~algoの選定-法： `spatial-navigation-function^p ~prop</h3>

◎名 `spatial-navigation-function@p
◎値 `normal$v | `grid$v
◎初 `normal^v
◎適 `空間的~navi容器$
◎継 されない
◎算 指定d値
◎百 受容しない
◎順 文法に従う
◎ア 離散的
◎表終

<p>
<a href="#processing-model">§ 処理~model</a>
にて指定された空間的~naviの既定の~algoは、~layout種別に依存して微調整が必要になり得る。
この~propは、［
どの~navi~algoが，空間的~naviの挙動~用に適度になるか
］指示することを，作者に許容する。
◎
The default algorithm of spatial navigation specified in the § 8 Processing Model may need the fine tune depending on the layout types. This property allows the author to indicate which navigation algorithm is reasonable for spatial navigation behavior.
</p>

<p>
各種 値は、次に従って定義される：
◎
Its values are defined as follows:
</p>

<dl>
	<dt>`normal@v</dt>
	<dd>
~UAが定義する既定の~focus~navi~algoにより、~focusを移動する。
◎
Moves the focus with the default focus navigation algorithm defined by UA.
</dd>
	<dd>
一般に，~focusは、`最短~距離を見出す$ことで計算される最も近い距離にある要素へ移動する。
◎
In general, the focus moves to the element with the closest distance calculated by finding the shortest distance.
</dd>

	<dt>`grid@v</dt>
	<dd>
<p>
~navi方向に最も整列する要素へ~focusを移動する。
◎
Moves the focus to the element which is aligned most in the navigation direction.
</p>
		<ul>
			<li>
~navi方向に整列している候補が 1 個~以上ある場合、~navi方向の軸に沿って最も近い距離にある要素を選定する。
複数の要素が同じ距離にある事例では、整列のずれが最小になる要素を選定する。
◎
If there are more than one aligned candidates in the navigation direction, select the element with the closest distance along the axis which corresponds to the navigation direction. In case of multiple elements with the same distance, select the element with the minimum amount of alignment.
</li>
			<li>
他の場合、~navi方向の軸に沿って最も近い距離にある要素を選定する。
複数の要素が同じ距離にある事例では、~navi方向に直交な軸において整列のずれが最小になる要素を選定する。
◎
Else if there isn’t any aligned candidate in a given direction, select the element with the closest distance along the axis which corresponds to the navigation direction. In case of multiple elements with the same distance, select the element with the minimum distance along the axis which is orthogonal to the navigation direction.
</li>
		</ul>
	</dd>
</dl>

<p class="note">注記：
これらの値は、当の~page用の空間的~naviの挙動が自然に見えるよう，利用者の選好と折衝される。
◎
NOTE: These values are negotiated with the users' preferences which seems natural spatial navigation behavior for their pages.
</p>

<div class="example">
<p>
`spatial-navigation-function^p の値に応じて，~focusがどう移動するかの違いを、次の例に示す。
◎
This example shows how the focus moves differently by the value of spatial-navigation-function.
</p>

<figure>
<p class="alt" hidden id="_dgm-spatnav-function">
~focusを得ている要素 A の下方には要素 B, C がある。
B は A から近いが左にずれている。
C は A から遠いが真下にある。
</p>

<figcaption>
"A" から候補を成すいずれかの要素へ~focusを移動する
◎
Moving focus from "A" to one of the candidate elements
</figcaption></figure>

<p>
要素は、
"A", "B", "C"
を包含する`空間的~navi容器$で，
"A" に~focusされているとする。
◎
Let the element which contains "A", "B" and "C" is the spatial navigation container.
</p>

<p>
利用者が 下~矢印~Keyを~pressしたとする。
~focusの移動-先は、要素の `spatial-navigation-function$p に指定された値に応じて［
`normal^v ならば "B" ／
`grid^v ならば "C"
］になる。
◎
When the user presses the down arrow key, if normal value is given to spatial-navigation-function of the element, the focus will move to "B". Otherwise, grid value was specified to the element, the focus will move to "C".
</p>

</div>

		</section>
	</section>
	<section id="scrolling">
<h2 title="Appendix A. Scroll extensions">付録 A. ~scroll拡張</h2>

<p>
この節は、~CSSに対する少数の拡張を提案する。
それは，上流~仕様に統合されるベキであるが、それまでは，ここに~hostされる。
◎
This section proposes a few extensions to CSS that should be integrated in upstream specifications, but are hosted here until then.
</p>

<div class="algo">
<p class="issue">
この様な各種用語は、
`CSSOM-VIEW-1$r,
`CSS-OVERFLOW-3$r,
`CSS-SCROLL-SNAP-1$r
にて与えられる~ベキである。
`2322$issue
◎
Terminology like this should be in [CSSOM-VIEW-1], [CSS-OVERFLOW-3], [CSS-SCROLL-SNAP-1]. &lt;https://github.com/w3c/csswg-drafts/issues/2322&gt;
</p>

<p>
次をすべて満たす要素 %要素 は、所与の方向 %方向 へ
`手動で~scrollできる@
（ `can be manually scrolled^en ）とされる：
◎
An element e can be manually scrolled in a given direction d if:
</p>

<ul>
	<li>
%要素 が確立する`首要~box$ %~box は、`~scroll容器$である
◎
The principal box established by e is a scroll container, and
</li>
	<li>
<p>
%方向 に応じて，次が満たされる：
</p>
		<ul class="switch">
			<li>
`up^l ／ `down^l
⇒
%要素 の `overflow-y$p ~propの算出d値 ~NEQ `hidden$v
◎
if d is up or down, the computed value of the overflow-y property is not hidden, and
</li>
			<li>
`left^l ／ `right^l
⇒
%要素 の `overflow-x$p ~propの算出d値 ~NEQ `hidden$v
◎
if d is left or right, the computed value of the overflow-x property is not hidden, and
</li>
		</ul>
	</li>
	<li>
%~box は
%方向 において`~scroll境界$に来てはいない
◎
e is not at the scroll boundary in the direction d
</li>
	<li>
%~box は
%方向 において最後の `mandatory$v `留め位置$に留められてはいない
◎
e is not snapped to the last mandatory snap point in direction d
</li>
</ul>

</div>

<div class="algo">
<p class="issue">
`CSSOM-VIEW-1$r は、おそらく［
明示的な位置を伴わずに所与の方向へ~scrollを遂行する方法
］を定義するベキである。
それまでは、ここに自前の~algoを与える。
`2323$issue
◎
[CSSOM-VIEW-1] should probably define how to perform a scroll in a given direction without an explicit position. Until then, we roll our own. &lt;https://github.com/w3c/csswg-drafts/issues/2323&gt;
</p>

<p>
`要素をある方向へ~scrollする@
（ `directionally scroll an element^en ）ときは、所与の
( %要素, %方向 )
に対し：
◎
To directionally scroll an element e in direction dir:
</p>
<ol>
	<li>
%距離 ~LET ~UAにより定義される距離
◎
Let d be a user agent defined distance.
</li>
	<li>
%x ~LET x 軸における， %要素 の現在の~scroll位置
◎
Let x be e’s current scroll position on the x axis.
</li>
	<li>
%y ~LET y 軸における， %要素 の現在の~scroll位置
◎
Let y be e’s current scroll position on the y axis.
</li>
	<li>
%位置 ~LET %方向 に応じて
⇒＃
`up^l ならば ( %x, %y ~MINUS %距離 ) ／
`down^l ならば ( %x, %y ~PLUS %距離 ) ／
`left^l ならば ( %x ~MINUS %距離, %y ) ／
`right^l ならば ( %x ~PLUS %距離, %y )
◎
↓</li>
	<li>
`要素を~scrollする$( %要素, %位置 )
`CSSOM-VIEW-1$r
◎
Use the scroll an element algorithm from [CSSOM-VIEW-1] on e to
• (x, y - d) if dir is up
• (x, y + d) if dir is down
• (x - d, y) if dir is left
• (x + d, y) if dir is right
</li>
</ol>

</div>

	</section>
	<section id="privsec">
<h2 title=" Appendix B. Privacy and Security Considerations">付録 B. ~privacyと~securityの考慮点</h2>

<p>
この仕様の貢献者たちは、この仕様に関わる既知な~security~riskは，すべて必要十分に取組まれたものと予見している。
更なる詳細は、下に供される。
◎
The specification contributors believe that all known potential security risks associated with this specification have been adequately addressed. Further details are provided below.
</p>

<p>
TAG 【 `W3C Technical Architecture Group^en 】は、各［
編集者／ Working Group
］が~~策定する仕様により導入され得る~riskを評価し易くするための
<a href="~SECQ">自己-考査~質問票</a>
を開発した。
その回答は、以下に供される
【この訳では、~~影響があるものだけ挙げる（他の質問に対する回答は “いいえ” 等）】：
◎
The TAG has developed a self-review questionnaire to help editors and Working Groups evaluate the risks introduced by their specifications. Answers are provided below.
</p>

<dl>
	<dt>
この仕様は、これまで~accessし得なかった他の~dataを生成元に公開するか？
◎
Does this specification expose any other data to an origin that it doesn’t currently have access to? 
</dt>
	<dd>
ほぼ無い。
◎
Mostly, no.
</dd>
	<dd>
唯一の例外は、~focusが非同一-生成元~iframe内にある間に，作者が `window.navigate^c を利用する局面においてある：
~eventがまっく取得されないことは、~iframeの中に［
~scroll可能／~focus可能
］な何かが在ったことを意味することになる
— それらが~eventを取得する唯一の事例は，~treeを遡って探索しても何も見出されなかったときに限られるので。
◎
The one exception identified would be in the following scenario: if the author uses `window.navigate` while the focus is in a cross origin iframe, if they don’t get an event at all it means that either there was something scrollable or focusable within the iframe, as the only case where they’d get an event is when the search didn’t find anything at all goes up the tree.
</dd>
	<dd>
これは，そのように制限された情報なので、本当の~security~riskを導入するとは見受けられないが、作者が他では取得できなかった情報を取得できるとは言えよう。
◎
This is so limited information that it does not seem it would introduces real a security risk, but it is as far as the editors can tell information that the author could not get could not get otherwise.
</dd>

	<dt>
この仕様は、~UAの~native~UIに対する何らかの制御を生成元に許容するか？
◎
Does this specification allow an origin some measure of control over a user agent’s native UI?
</dt>
	<dd>
~UAの~UIの外観に対する制御は与えられないが、~UAが空間的~naviをどう遂行するかには，いくぶんの制御を与える
— それは、~UIの一部を成すものと見なされ得る。
これは、作者が自身の~pageにおける空間的~naviの挙動を誂えれるよう，意図的である。
利用者の［
~focusを制御する／文書を~navigateする
］欲求に悪意的な作者が干渉するのを防止するため、この上書きする仕組みは，非同一-生成元~iframe用には既定で不能化される。
<a href="#policy-feature">§ ~navi上書き 施策により制御される特能</a>を見よ。
◎
No control is given over the appearance of the user agent’s UI. Some control is given over how the user agent performs spatial navigation, which may be considered part of its user interface. This is intentional, to let the author tailor the behavior of spatial navigation to their pages. To prevent malicious the author to interfere with the users' desire to control focus and navigate the document, this overriding mechanism is disabled by default for cross-origin iframes. See § 7 The navigation-override policy-controlled feature.
</dd>

	<dt>
この仕様は、既定の~security特徴の降格を許容するか？
◎
Does this specification allow downgrading default security characteristics?
</dt>
	<dd>
無関係な~securityの仕組みに対しては、降格を許容しない。
◎
It does not allow downgrading any unrelated security mechanism.
</dd>
	<dd>
［
非同一-生成元~iframe内の空間的~naviの既定の挙動を上書きするために必要な~eventを許容すること
］を，作者が信用する `feature-policy$r を利用して~~任意選択することを作者に`許容する^em。
<a href="#policy-feature">§ ~navi上書き 施策により制御される特能</a>を見よ。
◎
It **does** allow the author to opt into allowing the events needed to override the default behavior of spatial navigation in cross origin iframes they trust using [feature-policy]. See § 7 The navigation-override policy-controlled feature.
</dd>
</dl>

	</section>
	<section id="ack">
<h2 title="Acknowledgements">謝辞</h2>

<p>
編集者は、この仕様に~feedbackを寄せられ，貢献された次の方々に感謝したい：
◎
The editors of this specification would like to thank the following individuals for their feedback and contributions (in alphabetical order):
</p>

<div lang="en">
Alice Boxhall,
Brian Kardell,
Elika Etemad,
Hugo Holgersson,
Hyojin Song,
Jeonghee Ahn,
Junho Seo,
Rob Dodson,
Seungcheon Baek
</div>
	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

~INFORMATIVE

<p>
<a href="https://www.w3.org/TR/2019/WD-css-nav-1-20190423/">2019年 4 月 23日 最初の公な作業草案</a>
から，以下に挙げる変更が為された。
◎
The following changes were made since the 23 April 2019 First Public Working Draft.
</p>

<ul>
	<li>
`getSpatialNavigationContainer()$m を、最も近い先祖の`空間的~navi容器$を返すよう，変更した。
◎
Changed the result of getSpatialNavigationContainer() to return the nearest spatial navigation container ancestor
</li>
	<li>
`spatial-navigation-function$p を追加した。
◎
Added spatial-navigation-function
</li>
	<li>
`探索~起点を更新する$段を追加した。
◎
Added updating the search origin step
</li>
	<li>
`spatialNavigationSearch()$m の~IDLを，
`SpatialNavigationSearchOptions$I から `dir^m 属性を分離するように変更した。
◎
Changed the IDL of spatialNavigationSearch() as separating the dir attribute from SpatialNavigationSearchOptions
</li>
	<li>
到達-不能になるのを修正するため、探索~起点に全部的に重合している~focus可能な要素は，`空間的~navi容器$でなくとも候補になるようにした。
◎
Made the focusable element fully overlapped with search origin which is not the spatial navigation container as a candidate for fixing the unreachability
</li>
</ul>

	</section>
</main></div>

