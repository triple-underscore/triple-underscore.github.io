<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — APIs related to navigation and session history （ 日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
.xattr {
	font-family: monospace0, monospace;
	color: var(--K-color);
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
case 'hH':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'm0':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'xA': // xattr
	text = `[${key}]`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${key}</span>)`
	break;
case 'bP': //
	text = `${key}<code>BarProp</code> ~obj`;
	break;
case 'uST': 
	text = `${text} <small>state</small>`;
	break;
case 'bK':
	text = `"<code class="literal">${text}</code>"`;
	href = `#blocking-${key}`
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2025-04-22
trans_update:2025-04-23
source_checked:240620
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/nav-history-apis.html
	abbr_url:WINDOW
nav_prev:ORIGIN
nav_next:HTMLnavAPI
site_nav:browsers,html
trans_1st_pub:2016-07-12


●●class_map
E:error
sl:js-slot
jA:abstract
e:element
a:attr
aF:attr
et:event-type
sc:scheme
E:error
sl:js-slot
jA:abstract
xA:xattr
U:code-point
v:value
jv:js-value
h:header
M:method

●●tag_map
I:code
E:code
m:code
m0:code
mb:code
c:code
e:code
a:code
aF:code
sc:code
et:code
v:code
jv:code
sl:span
jA:span
xA:code
h:code
M:code
i:i
U:span
cite:cite

●●original_urls

●●words_table1
WEBLOCKS:https://w3c.github.io/web-locks/
MEDIACAPTURE:https://w3c.github.io/mediacapture-main
WEBSHARE:web-share-ja.html
WEBTRANSPORT:webtransport-ja.html

about_blank:about:blank
navigate_ev: <code class="event-type">navigate</code> 

●●words_table

	●名称
MIDI:
	^cite:WebHID API
	^cite:Storage Access API
	^cite:Web Share API

	●network
unload:
load:
HTTP_S:HTTP(S) 
username::::ユーザ名
password::::パスワード
hostname::::ホスト名
抹消-:evict::~
	eviction
ok:

	●navi/session
opener:::open 元
入口:entry::~
現在:currently:~
現任:incumbent:~
	予約-済み:reserved
補助:auxiliary::~
読込直す:reloadする::読み込み直す::リロードする
回復-:salvage:~
閉じる:closeする::~
閉じら:closeさ::~
閉じれ:closeでき::~
閉中:is closing::閉じかけ
開く:openする::~
開いた:openした::~
開いて:openして::~
書直せ:rewriteでき::書き直せ
復旧-:restore:~
復旧:restoration:~
差分:delta:~
近しい:familiar:~

	前へ進む:go forward
	後へ戻る:go back
	戻る:back
	進む:forward

	●UI
popup:
scrollbar:
toolbar:
location-bar:
menu-bar:
personal-bar:
status-bar:
	~UItab付き:tabbed
pointing::::ポインタ指示
隠す:hideする::~
bookmark:
一過:transient::~

	~UI:interface

	●構文
読飛ばす:skipする:読み飛ばす
直列形の:serialized::~::シリアル形の
逆直列化-:deserialize::~::逆シリアル化

	過ぎない所:past
	先頭の:leading
	数:number

	●IDL／js
exotic:
agent:
WindowProxy:
Location:
prototype-chain:prototype chain

	●処理一般
上書state:state override:上書き state
state:
timer::::タイマー
持続-:persist:~
普通の:ordinary:~
起点:origin::~
timer::::タイマー
params::::パラメタ群
素通り:bypass:~
再読込み:reload::再読み込み::リロード
back:
BF:
shut-down:shut down
未登録に:unregister:~
処理待ち:pending:~
応答待ち:outstanding:~
noopener:
blob:
	合致しない:mismatch
	渡-:pass
	渡して:pass
	FIFO
	LIFO
	-:reprocess
	後で／:later


	●変数
	%B
	%B:browsing context
	%L:-
	%~navigable:-
	%N:current
	%location:location
	%menubar:menubar
	%noopener
	-:noopener
	-:blobOrigin
	-:topLevelOrigin
	%noreferrer
	%resizable:resizable
	%scrollbars:scrollbars
	%status:status
	%toolbar:toolbar
	%~URL:url
	%~URL~record:urlRecord
	%~data:data
	%~host文字列
	%~navigable:
	%~navigable:navigable
	%~obj群:objects
	%~protocol文字列:
	%~realm:realm
	%~referrer施策:referrerPolicy
	%~source~snapshot~params:sourceSnapshotParams
	%~source文書:sourceDocument
	%~target:target
	%~target~URL:targetURL
	%~target~navigable:targetNavigable
	%~top-level作成時の~URL:topLevelCreationURL
	%~top-level生成元:topLevelOrigin
	%~window:-
	%~window:window
	%~window種別:windowType
	%この辿可能:thisTraversable
	%予約-済み環境:reservedEnvironment
	%位置:position
	%作成時の~URL:creationURL
	%値:value
	%入力:input
	%出力:output
	%名前:name
	%名前~群:names
	%失敗かも:possibleFailure
	%子~群:children
	%実行~文脈:execution context
	%容器:container
	%履歴:history
	%履歴~取扱い:historyHandling
	%差分:delta
	%L:location
	%文書 document
	%文書:document
	%文書~URL: documentURL
	%新たな~URL:newURL
	%既定~値:defaultValue
	%有名~子~群:firstNamedChildren
	%特能~map:tokenizedFeatures
	%特能~名:featureName
	%特能~群:features
	%現~文書:-
	%現在の文書:current
	%直列形の~data:serializedData
	%複製~URL:copyURL
	%設定群~obj:settings object
	%閲覧~文脈:browsingContext
	%~navi:navigation
	%継続するか:continue

	%子:child
	%~backしている構造体:backingStruct
	%~realm:realm
	%O:notRestoredReasonDetails
	%O:-
	%~URL:-
	%復旧されない事由~群:notRestoredReasons
	%事由~群~配列:reasonsArray
	%事由:reason
	%子~事由~群~配列:childrenArray

	●仕様
活動:activity::~::アクティビティ
適格:eligible:~
必要最小限:minimal:~
確認:confirmation:~
上限:limit:~
冗長:redundant:~
脱出措置:bailout:~
推定-:infer:~

	素朴:naïve
	早く:as soon as
	配備-済み:deployed
	抵触-:hit
	させ易く:help
	慣習:traditional
	問われ:matter
	~codeは壊れやすくなる:lead to brittle code
	~~実際，:Indeed
	選ぶ:choose する
	選ばな:chosen
	事実:fact
	表す:signify
	し得なくなった:never

	●未分類
open:
作成時の:creation::~
確定的:definite:~
sensor::::センサー
捕捉-:capture::~
認証:authentication::~
内包-:include:~

	getting
	設定し直-:reset
	総合的:overall

	変わる:vary
	“お気に入り”:favorite
	~force-close
	非:non
	指して:point at

	まったく別の:completely different
	-:later
	直上や直下:immediately below or after
	所与の任意の時点:at any moment
	~NULL化:nulled out
	様なもの:look like
	次:next
	全体:whole
	直後:immediately after
game::::ゲーム
	あてがわれ:prefill
	~Location~objにより:Location-object
	-:duplicate
	ずっと高速:much faster
	と違って:contrary to
	更には:furthermore
	線:line
	非:non-
	-:per
	point
	立て続けに:rapid succession
	相違することになる:leads to different
	^en:inbound

	完遂しなかった:unfinished
	~source:src


●●original_id_map
dom-window-document:dom-document-2
dom-window-frameelement:dom-frameelement
dom-window-frames:dom-frames
dom-window-history:dom-history
dom-window-length:dom-length
dom-window-location:dom-location
dom-window-name:dom-name
dom-window-open:dom-open
dom-window-opener:dom-opener
dom-window-parent:dom-parent
dom-window-self:dom-self
dom-window-top:dom-top
dom-window-window:dom-window


	dom-window-length:number-of-document-tree-child-browsing-contexts
	document-tree-child-navigable-target-name-property-set:document-tree-child-browsing-context-name-property-set
	document-tree-child-navigable-target-name-property-set:child-browsing-context-name-property-set


●●mdn_urls
beforeunloadevent:API/BeforeUnloadEvent
hashchangeevent:API/HashChangeEvent
history-3:API/History
location:API/Location
popstateevent:API/PopStateEvent
scrollrestoration:
window:API/Window
notrestoredreasons:API/NotRestoredReasons


●●link_map

	●IDL
LegacyNullToEmptyString:~WEBIDLjs#LegacyNullToEmptyString
LegacyUnenumerableNamedProperties:~WEBIDLjs#LegacyUnenumerableNamedProperties
LegacyUnforgeable:~WEBIDLjs#LegacyUnforgeable
xA.Global:~WEBIDLjs#Global

E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror

object:~WEBIDL#idl-object

I.BarProp:#barprop
I.BeforeUnloadEvent:#beforeunloadevent
I.BroadcastChannel:~HTMLcomms#broadcastchannel
I.CustomElementRegistry:~HEcustom#customelementregistry
I.DOMStringList:~HTMLcdom#domstringlist
I.Document:~HTMLdom#document
文書:~HTMLdom#the-document-object
I.Element:~DOM4#element
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.GlobalEventHandlers:~WAPI#globaleventhandlers
I.HTMLCollection:~DOM4#interface-htmlcollection
I.HashChangeEvent:#hashchangeevent
I.HashChangeEventInit:#hashchangeeventinit
I.History:#history-3
I.Location:#location
I.Navigation:~HTMLnavAPI#navigation
I.NavigateEvent:~HTMLnavAPI#navigateevent
I.NavigationHistoryBehavior:~HTMLnavAPI#navigationhistorybehavior
I.Navigator:~HTMLnavigator#navigator
I.NotRestoredReasonDetails:#notrestoredreasondetails
I.NotRestoredReasons:#notrestoredreasons
I.PopStateEvent:#popstateevent
I.PopStateEventInit:#popstateeventinit
I.ScrollRestoration:#scrollrestoration
I.ServiceWorker:~SW1#serviceworker
I.SharedWorkerGlobalScope:~WORKERS#sharedworkerglobalscope
I.StructuredSerializeOptions:~HTMLcomms#structuredserializeoptions
I.WebSocket:~WEBSOCKET#websocket
I.WebTransport:~WEBTRANSPORT#webtransport
I.Window:#window
~window:#the-window-object
I.WindowEventHandlers:~WAPI#windoweventhandlers
I.WindowPostMessageOptions:#windowpostmessageoptions
I.WindowProxy:~HTMLWPROXY#windowproxy


	getter:#dom-window-nameditem
	getter:#dom-nameditem

m.alert:~HTMLGAPI#dom-window-alert
m0.alert:~HTMLGAPI#dom-window-alert-noargs
m.ancestorOrigins:#dom-location-ancestororigins
m.assign:#dom-location-assign
m.back:#dom-history-back
m.blur:~HTMLinteraction#dom-window-blur
m.children:#dom-not-restored-reasons-children
m.clientInformation:~HTMLnavigator#dom-window-clientinformation
m.close:#dom-window-close
m.closed:#dom-window-closed
m.confirm:~HTMLGAPI#dom-window-confirm
m.customElements:~HEcustom#dom-window-customelements
m.defaultView:#dom-document-defaultview
m.document:#dom-window-document
m.focus:~HTMLinteraction#dom-window-focus
m.forward:#dom-history-forward
m.frameElement:#dom-window-frameelement
m.frames:#dom-window-frames
m.go:#dom-history-go
m.hash:#dom-location-hash
m.hasUAVisualTransition:#dom-popstateevent-hasuavisualtransition
m.history:#dom-window-history
m.host:#dom-location-host
m.hostname:#dom-location-hostname
m.href:#dom-location-href
m.id:#dom-not-restored-reasons-id
m.length:#dom-window-length
m0.length:#dom-history-length
m.location:#dom-window-location
m0.location:#dom-document-location
m.locationbar:#dom-window-locationbar
m.menubar:#dom-window-menubar
m.name:#dom-window-name
m0.name:#dom-not-restored-reasons-name
m.navigation:~HTMLnavAPI#dom-window-navigation
m.navigator:~HTMLnavigator#dom-window-navigator
m.newURL:#dom-hashchangeevent-newurl
m.oldURL:#dom-hashchangeevent-oldurl
m.open:#dom-window-open
m.opener:#dom-window-opener
m.origin:#dom-location-origin
m.originAgentCluster:~ORIGIN#dom-originagentcluster
m.parent:#dom-window-parent
m.pathname:#dom-location-pathname
m.personalbar:#dom-window-personalbar
m.port:#dom-location-port
m.postMessage:~HTMLcomms#dom-window-postmessage
m0.postMessage:~HTMLcomms#dom-window-postmessage-options
m.preventDefault:~DOM4#dom-event-preventdefault
m.print:~HTMLGAPI#dom-window-print
m.prompt:~HTMLGAPI#dom-window-prompt
m.protocol:#dom-location-protocol
m.pushState:#dom-history-pushstate
m.reason:#dom-not-restored-reason-details-reason
m.reasons:#dom-not-restored-reasons-reasons
m.reload:#dom-location-reload
m.replace:#dom-location-replace
m.replaceState:#dom-history-replacestate
m.returnValue:#dom-beforeunloadevent-returnvalue
m.scrollRestoration:#dom-history-scroll-restoration
m.scrollbars:#dom-window-scrollbars
m.search:#dom-location-search
m.self:#dom-window-self
m.src:#dom-not-restored-reasons-src
m.state:#dom-history-state
m0.state:#dom-popstateevent-state
m.status:#dom-window-status
m.statusbar:#dom-window-statusbar
m.stop:#dom-window-stop
m.targetOrigin:#dom-windowpostmessageoptions-targetorigin
m.toolbar:#dom-window-toolbar
m.top:#dom-window-top
m.url:#dom-not-restored-reasons-url
m.visible:#dom-barprop-visible
m.window:#dom-window-window

mb.state:#dom-popstateeventinit-state
mb.hasUAVisualTransition:#dom-popstateeventinit-hasuavisualtransition

e.a:~HEtextlevel#the-a-element
e.area:~HEimages#the-area-element
e.form:~HEforms#the-form-element
e.embed:~HEembed#the-embed-element
e.img:~HEimages#the-img-element
e.object:~HEembed#the-object-element
e.head:~HEmetadata#the-head-element
e.iframe:~HEembed#the-iframe-element
e.script:~HEscripting#the-script-element

a.id:~HTMLdom#the-id-attribute
aF.name:~HEembed#attr-iframe-name
aF.src:~HEembed#attr-iframe-src

l.HTMLDocument:#htmldocument
l.concrete:~HTMLds#cross-origin-isolation-concrete
l.cross-origin-isolated:~HTMLINFRA#cross-origin-isolated-feature
l.auto:~HTMLnav#dom-scrollrestoration-auto
l.manual:~HTMLnav#dom-scrollrestoration-manual

v.noopener:~HTMLlinks#link-type-noopener
v.noreferrer:~HTMLlinks#link-type-noreferrer

et.message:~HTMLindex#event-message
et.unload:~HTMLindex#event-unload

sl.GetOwnProperty:~HTMLWPROXY#windowproxy-getownproperty

sc.~about_blank:~HTMLdep#about:blank

bP.~location-bar:#the-location-bar-barprop-object
bP.~menu-bar:#the-menu-bar-barprop-object
bP.~personal-bar:#the-personal-bar-barprop-object
bP.~scrollbar:#the-scrollbar-barprop-object
bP.~status-bar:#the-status-bar-barprop-object
bP.~toolbar:#the-toolbar-barprop-object

jA.DefinePropertyOrThrow:~TC39#sec-definepropertyorthrow
jA.StructuredSerializeForStorage:~HTMLcloning#structuredserializeforstorage

h.Cache-Control:~HTTPcache#field.cache-control
h.Keep-Alive:~HTTPv1#compatibility.with.http.1.0.persistent.connections

	●用語
有名~要素:#_named-element
要素~名:#_element-name
生成元~domainを検査する:#_location-security-check

有名~obj:#dom-window-nameditem-filter
~Location~objにより~navigateする:#location-object-navigate
先祖~生成元~list:#concept-location-ancestor-origins-list
結付けられた文書:#concept-document-window
対応する閲覧~文脈:#window-bc
対応する~navigable:#window-navigable
書直せ:#can-have-its-url-rewritten
文書の~URLは書直せるか:#can-have-its-url-rewritten
~popup~windowが要請されたか否か検査する:#popup-window-is-requested
~window特能は設定されたか否か検査する:#window-feature-is-set
差分だけ辿る:#delta-traverse

文書~treeに属する子~navigable~target名~prop集合:#document-tree-child-navigable-target-name-property-set
特能~分離子:#feature-separator

履歴~obj:#doc-history
hsT.~index:#concept-history-index
hsT.長さ:#concept-history-length
hsT.状態:#concept-history-state

特能~名として正規化する:#normalizing-the-feature-name
真偽-特能を構文解析する:#concept-window-open-features-parse-boolean
Loc.~URL:#concept-location-url
Loc.関連な文書:#relevant-document
~scriptから閉じれる:#script-closable
~window用に環境~設定群~objを設定しておく:#set-up-a-window-environment-settings-object
履歴に状態を~pushするか履歴の状態を置換する:#shared-history-push/replace-state-steps
特能~群を~token化する:#concept-window-open-features-tokenize
~window~open手続き:#window-open-steps
~window~open用の~noopenerを取得する:#get-noopener-for-window-open

	●用語（navi API
~navi~API:~HTMLnavAPI#window-navigation-api
~push／置換-／再読込み用の~navigate_ev~eventを発火する:~HTMLnavAPI#fire-a-push/replace/reload-navigate-event
	i.~navi種別:~HTMLnavAPI#fire-navigate-prr-navigationtype
	i.同じ文書か:~HTMLnavAPI#fire-navigate-prr-issamedocument
	i.行先~URL:~HTMLnavAPI#fire-navigate-prr-destinationurl
	i.古典~履歴~API用の状態:~HTMLnavAPI#fire-navigate-prr-classichistoryapistate

	●用語（nrr


	bK.*:#blocking-*

	bK.fetch:#blocking-fetch
	bK.navigation-failure:#blocking-navigation-failure
	bK.parser-aborted:#blocking-parser-aborted
	bK.websocket:#blocking-websocket
	bK.lock:#blocking-weblock
	bK.masked:#blocking-masked

	bK.audio-capture:#blocking-audio-capture
	bK.background-work:#blocking-background-work
	bK.broadcastchannel-message:#blocking-broadcastchannel-message
	bK.idb-event:#blocking-idb-event
	bK.idledetector:#blocking-idledetector
	bK.keyboard-lock:#blocking-keyboard-lock
	bK.mediastream:#blocking-mediastream
	bK.midi:#blocking-midi
	bK.modals:#blocking-modals
	bK.navigating:#blocking-navigating
	bK.navigation-canceled:#blocking-navigation-canceled
	bK.non-trivial-bcg:#blocking-non-trivial-bcg
	bK.blocking-otp:#blocking-otp
	bK.outstanding-network-request:#blocking-outstanding-network-request
	bK.payment:#blocking-payment
	bK.picture-in-picture:#blocking-picture-in-picture
	bK.plugins:#blocking-plugins
	bK.method-not-get:#blocking-method-not-get
	bK.auth-required:#blocking-auth-required
	bK.ccns:#blocking-ccns
	bK.ccnc:#blocking-ccnc
	bK.keepalive:#blocking-keepalive
	bK.not-http-https:#blocking-not-http-https
	bK.response-not-ok:#blocking-response-not-ok
	bK.rtc:#blocking-rtc
	bK.sensors:#blocking-sensors
bK.serviceworker-added:#sw-added
bK.serviceworker-claimed:#sw-claimed
	bK.sw-message:#blocking-sw-message
	bK.sw-activation:#blocking-sw-activation
	bK.sw-unregistered:#blocking-sw-unregistered
	bK.sharedworker:#blocking-sharedworker
	bK.smartcard:#blocking-smartcard
	bK.speech-reco:#blocking-speech-reco
	bK.storage:#blocking-storage
	bK.unload:#blocking-unload
	bK.video-capture:#blocking-video-capture
	bK.webhid:#blocking-webhid
	bK.webshare:#blocking-webshare
	bK.webtransport:#blocking-webtransport
	bK.webxr:#blocking-webxr

dS.復旧されない事由~群:~HTMLnav#document-state-not-restored-reasons
文書の復旧されない事由~群:#concept-document-nrr
doc.~BF~cacheを阻んでいる詳細:~HTMLdom#concept-document-bfcache-blocking-details
~UAに特有な阻んでいる事由:#ua-specific-blocking-reasons

復旧されない事由の詳細:#nrr-details-struct
nrrd.事由~文字列:#nrr-details-reason

NRRD.作成する:#create-a-notrestoredreasondetails-object
NRRD.~backしている構造体:#concept-not-restored-reason-details-backing-struct

NRR.~backしている構造体:#concept-not-restored-reasons-backing-struct
NRR.事由~群~配列:#concept-not-restored-reasons-reasons
NRR.子~事由~群~配列:#concept-not-restored-reasons-children
NRR.作成する:#create-a-notrestoredreasons-object

復旧されない事由~群:#nrr-struct
nrr.~source:#nrr-src
nrr.~ID:#nrr-id
nrr.名前:#nrr-name
nrr.~URL:#nrr-url
nrr.事由~群:#nrr-reasons
nrr.子~事由~群:#nrr-children

	~BF~cache:~HTMLnav#note-bfcache
~BF~cache:~HTMLnav#_bf-cache

~lock:~WEBLOCKS#lock-concept
~lock要請:~WEBLOCKS#lock-request

	＠~MEDIACAPTURE/getusermedia.html#dom-mediadevices-getusermedia
	＠https://wicg.github.io/background-sync/spec/#syncmanager
	＠https://wicg.github.io/background-sync/spec/#dom-syncmanager-register
	＠https://wicg.github.io/periodic-background-sync/#periodicsyncmanager
	＠https://wicg.github.io/periodic-background-sync/#dom-periodicsyncmanager-register
	＠https://wicg.github.io/background-fetch/#backgroundfetchmanager
	＠https://wicg.github.io/background-fetch/#dom-backgroundfetchmanager-fetch
	＠~INDEXEDDB#idbversionchangeevent
	＠https://wicg.github.io/idle-detection/#idledetector
	＠https://wicg.github.io/keyboard-lock/#keyboard
	＠https://wicg.github.io/keyboard-lock/#dom-keyboard-lock
	＠~MEDIACAPTURE/getusermedia.html#mediastreamtrack
	＠~MEDIACAPTURE/getusermedia.html#idl-def-MediaStreamTrackState.live
	＠https://webaudio.github.io/web-midi-api/#dom-navigator-requestmidiaccess
	＠https://wicg.github.io/web-otp/#otpcredential
	＠https://w3c.github.io/payment-request/#dom-paymentrequest
	＠https://w3c.github.io/picture-in-picture/#pictureinpicturewindow
	＠https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection
	＠https://w3c.github.io/webrtc-pc/#dom-rtcdatachannel
	＠~SENSORS#request-sensor-access
	＠~SW1#dfn-control
	＠~SW1#navigator-service-worker-unregister
	＠https://wicg.github.io/web-smart-card/#dom-smartcardconnection
	＠https://wicg.github.io/speech-api/#speechrecognition
	＠~MEDIACAPTURE/getusermedia.html#dom-mediadevices-getusermedia
	＠https://wicg.github.io/webhid/#requestdevice-method
	＠~WEBSHARE#share-method
	＠https://immersive-web.github.io/webxr/#xrsystem

	●用語（HTML

enV.~API用~基底~URL:~WAPI#api-base-url
enV.~ID:~WAPI#concept-environment-id
enV.~module~map:~WAPI#concept-settings-object-module-map
enV.~realm実行~文脈:~WAPI#realm-execution-context
enV.~target閲覧~文脈:~WAPI#concept-environment-target-browsing-context
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.作動中な~sw:~WAPI#concept-environment-active-service-worker
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.施策~容器:~WAPI#concept-settings-object-policy-container
enV.時刻~起点:~WAPI#concept-settings-object-time-origin
enV.生成元:~WAPI#concept-settings-object-origin
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability

tK.文書:~WAPI#concept-task-document
~event~loop:~WAPI#event-loop
~taskを~queueする:~WAPI#queue-a-task
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
入口~大域~obj:~WAPI#entry-global-object
入口~設定群~obj:~WAPI#entry-settings-object
rM.大域~obj:~WAPI#concept-realm-global
現任な大域~obj:~WAPI#concept-incumbent-global
現在の設定群~obj:~WAPI#current-settings-object
環境:~WAPI#environment
環境~設定群~obj:~WAPI#environment-settings-object
関連な~realm:~WAPI#concept-relevant-realm
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
agC.非同一-生成元~隔離~mode:~WAPI#agent-cluster-cross-origin-isolation

同じ生成元~domain:~ORIGIN#same-origin-domain
同じ~site:~ORIGIN#same-site
同一-生成元:~ORIGIN#same-origin
生成元:~ORIGIN#concept-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

~navigable:~HTMLds#navigable
nav.~target名:~HTMLds#nav-target
nav.作動中な閲覧~文脈:~HTMLds#nav-bc
nav.容器:~HTMLds#nav-container
nav.作動中な文書:~HTMLds#nav-document
nav.作動中な~WindowProxy:~HTMLds#nav-wp
nav.閉中か:~HTMLds#is-closing
nav.~top-level辿可能:~HTMLds#nav-top
親~navigable:~HTMLds#nav-parent
nav.親:~HTMLds#nav-parent
nav.辿可能な~navigable:~HTMLds#nav-traversable
nav.作動中な~session履歴~entry:~HTMLds#nav-active-history-entry
nav.~session履歴~entry群:~HTMLds#tn-session-history-entries
nav.作動中な~entry:~HTMLds#nav-active-history-entry
nav.~web内容により作成されたか:~HTMLds#is-created-by-web-content
先祖~navigable群:~HTMLds#ancestor-navigables
~top-level辿可能:~HTMLds#top-level-traversable
~top-level辿可能を確定的に閉じる:~HTMLds#definitely-close-a-top-level-traversable
文書~treeに属する子~navigable群:~HTMLds#document-tree-child-navigables
~node~navigable:~HTMLds#node-navigable
~navigable容器:~HTMLds#navigable-container
~navigableを選ぶ規則:~HTMLds#the-rules-for-choosing-a-navigable
閲覧~文脈:~HTMLds#browsing-context
閲覧~文脈~group:~HTMLds#browsing-context-group
bc.~popupか:~HTMLds#is-popup
bc.作動中な文書:~HTMLds#active-document
bc.~top-level閲覧~文脈:~HTMLds#bc-tlbc
bc.開いた閲覧~文脈:~HTMLds#opener-browsing-context
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context
先祖~閲覧~文脈:~HTMLds#ancestor-browsing-context
全部的に作動中:~HTMLds#fully-active
属する閲覧~文脈:~HTMLds#concept-document-bc
補助~閲覧~文脈:~HTMLds#auxiliary-browsing-context
近しい:~HTMLds#familiar-with
内容~navigable:~HTMLds#content-navigable
doc.容器~文書:~HTMLds#doc-container-document
辿可能な~navigable:~HTMLds#traversable-navigable

hH.auto:~HTMLnav#navigationhistorybehavior-auto
hH.push:~HTMLnav#navigationhistorybehavior-push
hH.replace:~HTMLnav#navigationhistorybehavior-replace
~navigableを~URLへ~navigateする:~HTMLnav#navigate
	i.~referrer施策:~HTMLnav#navigation-referrer-policy
	i.例外を可能化するか:~HTMLnav#exceptions-enabled
	i.履歴~取扱い:~HTMLnav#navigation-hh
~navigate:~HTMLnav#navigate
~navi~algo:~HTMLnav#navigate
~navigableを読込直す:~HTMLnav#reload
	読込直す:~HTMLnav#reload
~navigateすることは~sandbox法により許容される:~HTMLnav#allowed-to-navigate
~URLと履歴を更新する:~HTMLnav#url-and-history-update-steps
	i.直列形の~data:~HTMLnav#uhus-serializeddata
	i.履歴~取扱い:~HTMLnav#uhus-historyhandling
~session履歴~entry:~HTMLnav#session-history-entry
~scroll復旧~mode:~HTMLnav#scroll-restoration-mode
dS.~navigable名:~HTMLnav#document-state-nav-target-name
履歴~取扱いの挙動:~HTMLnav#history-handling-behavior
履歴を差分だけ辿る:~HTMLnav#traverse-the-history-by-a-delta
	sourceDocument:~HTMLnav#traverse-sourcedocument
shE.文書~状態:~HTMLnav#she-document-state
shE.~scroll復旧~mode:~HTMLnav#she-scroll-restoration-mode
shE.古典~履歴~API用の状態:~HTMLnav#she-classic-history-api-state
shE.~URL:~HTMLnav#she-url
~source~snapshot~paramsを~snapshotする:~HTMLnav#snapshotting-source-snapshot-params
~unloadは取消されたか否か検査する:~HTMLnav#checking-if-unloading-is-canceled

終了n入子ng~level:~HTMLlifecycle#termination-nesting-level
読込ngを停止する:~HTMLlifecycle#nav-stop
完全に読込まれ:~HTMLlifecycle#completely-loaded
~unloadして:~HTMLlifecycle#unload-a-document

~HTML要素:~HTMLINFRA#html-elements
~plugin:~HTMLINFRA#plugin

~commaで分離された~token集合:~HTMLcms#set-of-comma-separated-tokens
整数として構文解析する:~HTMLcms#rules-for-parsing-integers
~URLを符号化法の下で相対的に構文解析する:~HTMLurl#encoding-parsing-a-url
~about_blank に合致して:~HTMLurl#matches-about:blank

doc.基底~URL:~HTMLurl#document-base-url

初期~about_blank な文書:~HTMLdom#is-initial-about:blank
doc.~module~map:~HTMLdom#concept-document-module-map
doc.施策~容器:~HTMLdom#concept-document-policy-container
doc.~load計時~報:~HTMLdom#load-timing-info
~navi開始~時刻:~HTMLdom#navigation-start-time

~hyperlink:~HTMLlinks#hyperlink
一過な作動化を有して:~HTMLinteraction#transient-activation
利用は許容されて:~HEembed#allowed-to-use

wG.所有者~集合:~WORKERS#concept-WorkerGlobalScope-owner-set

	●用語（外部

~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII空白:~INFRA#ascii-whitespace
~scalar値~文字列:~INFRA#scalar-value-string
~list:~INFRA#list
~size:~INFRA#list-size
付加する:~INFRA#list-append
set.付加する:~INFRA#set-append
位置~変数:~INFRA#string-position-variable
実装定義:~INFRA#implementation-defined
有順序~集合:~INFRA#ordered-set
有順序~map:~INFRA#ordered-map
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
map.空:~INFRA#map-is-empty
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item

~realm:~TC39#sec-code-realms

~supportする~prop名:~WEBIDL#dfn-supported-property-names
有名~propを~supportする:~WEBIDL#dfn-support-named-properties
有名~propの値を決定する手続き:~WEBIDL#dfn-determine-the-value-of-a-named-property
旧来の~platform~obj:~WEBIDL#dfn-legacy-platform-object
有名~prop群~obj:~WEBIDLjs#dfn-named-properties-object
新たな~obj:~WEBIDLjs#new
`新たな:~WEBIDLjs#new
凍結d配列:~WEBIDL#dfn-frozen-array-type
凍結d配列を作成する:~WEBIDLjs#dfn-create-frozen-array

~HTTP_S~scheme:~FETCH#http-scheme
rq.~method:~FETCH#concept-request-method
rs.~URL:~FETCH#concept-response-url
rs.状態s:~FETCH#concept-response-status
~ok状態s:~FETCH#ok-status

~URL:~URL1#concept-url
~URL~record:~URL1#concept-url
url.~host:~URL1#concept-url-host
url.~password:~URL1#concept-url-password
url.~path:~URL1#concept-url-path
url.~port:~URL1#concept-url-port
url.~query:~URL1#concept-url-query
url.~scheme:~URL1#concept-url-scheme
url.~username:~URL1#concept-url-username
url.生成元:~URL1#concept-url-origin
url.素片:~URL1#concept-url-fragment
url.既定の~port:~URL1#default-port
url.~blob~URL~entry:~URL1#concept-url-blob-entry
~URLを直列化する:~URL1#concept-url-serializer
~hostを直列化する:~URL1#concept-host-serializer
~username／~password／~portを有し得ない:~URL1#cannot-have-a-username-password-port
整数を直列化する:~URL1#serialize-an-integer
不透明な~path:~URL1#url-opaque-path
~URL~pathを直列化する:~URL1#url-path-serializer
~API用に~URL構文解析する:~URL1#_api-url-parser
uST.~host:~URL1#host-state
uST.~hostname:~URL1#hostname-state
uST.~path開始:~URL1#path-start-state
uST.~port:~URL1#port-state
uST.~query:~URL1#query-state
uST.~scheme開始:~URL1#scheme-start-state
uST.素片:~URL1#fragment-state

~node文書:~DOM4#concept-node-document
子孫:~DOM4#concept-tree-descendant
~tree順序:~DOM4#concept-tree-order
文書~tree内:~DOM4#in-a-document-tree
根:~DOM4#concept-tree-root
doc.生成元:~DOM4#concept-document-origin
doc.~URL:~DOM4#concept-document-url
doc.符号化法:~DOM4#concept-document-encoding
~event~listener:~DOM4#concept-event-listener

~JS実行~文脈:~TC39#sec-execution-contexts
~agent~cluster:~TC39#sec-agent-clusters

閲覧~文脈の特能を設定しておく:~CSSOMVIEW#set-up-browsing-context-features

~sw~client:~SW1#serviceworkercontainer-service-worker-client
~sw登録:~SW1#dfn-service-worker-registration

bU.環境:~FILEAPI#blob-url-entry-environment

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ APIs related to navigation and session history</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>HTML — ナビとセッション履歴に関係する API</h1>
<p>APIs related to navigation and session history</p>
	</hgroup>
</header>

<main id="MAIN" hidden>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

		</section>
		<section id="nav-traversal-apis">
<h3 title="APIs related to navigation and session history">7.2. ~naviと~session履歴に関係する~API</h3>

			<section id="cross-origin-objects">
<h4 title="Security infrastructure for Window, WindowProxy, and Location objects">7.2.1 `Window^I, `WindowProxy^I, `Location^I ~obj用の~security基盤</h4>

<p class="trans-note">【
この節を成す内容は、
`別~page＠~HTMLWPROXY#cross-origin-objects$にて。
】</p>

			</section>
			<section id="the-window-object">
<h4 title="The Window object">7.2.2. `Window^I ~obj</h4>

<p class="trans-note">【
以下，この訳では、
`Window$I ~interfaceを実装する~objを単に
<dfn>~window</dfn>
とも略記する。
この略記は、
この~pageに限らず，この仕様の他の~pageの和訳でも利用される
— この節を指す~linkが付与された “`~window$” は、
`Window$I ~objを表すとする。
】</p>

<pre class="idl">
[Global=Window,
 Exposed=Window,
 `LegacyUnenumerableNamedProperties$]
interface `Window@I : `EventTarget$I {
  /* <span class="comment">
現在の閲覧~文脈
◎
the current browsing context
</span> */
  [`LegacyUnforgeable$] readonly attribute `WindowProxy$I `window$m;
  [Replaceable] readonly attribute `WindowProxy$I `self$m;
  [`LegacyUnforgeable$] readonly attribute `Document$I `document$m;
  attribute DOMString `name$m;
  [PutForwards=`href$m, `LegacyUnforgeable$] readonly attribute `Location$I `location$m;
  readonly attribute `History$I `history$m;
  readonly attribute `Navigation$I `navigation$m;
  readonly attribute `CustomElementRegistry$I `customElements$m;
  [Replaceable] readonly attribute `BarProp$I `locationbar$m;
  [Replaceable] readonly attribute `BarProp$I `menubar$m;
  [Replaceable] readonly attribute `BarProp$I `personalbar$m;
  [Replaceable] readonly attribute `BarProp$I `scrollbars$m;
  [Replaceable] readonly attribute `BarProp$I `statusbar$m;
  [Replaceable] readonly attribute `BarProp$I `toolbar$m;
  attribute DOMString `status$m;
  undefined `close$m();
  readonly attribute boolean `closed$m;
  undefined `stop$m();
  undefined `focus$m();
  undefined `blur$m();

  /* <span class="comment">
他の閲覧~文脈
◎
other browsing contexts
</span> */
  [Replaceable] readonly attribute `WindowProxy$I `frames$m;
  [Replaceable] readonly attribute unsigned long `length$m;
  [`LegacyUnforgeable$] readonly attribute `WindowProxy$I? `top$m;
  attribute any `opener$m;
  [Replaceable] readonly attribute `WindowProxy$I? `parent$m;
  readonly attribute `Element$I? `frameElement$m;
  `WindowProxy$I? `open$m(
      optional USVString %url = "",
      optional DOMString %target = "_blank",
      optional [`LegacyNullToEmptyString$] DOMString %features = ""
  );

  /* <span class="comment">
これは大域~objなので、
~IDL有名~prop取得子は，~prototype-chain上に `NamedPropertiesObject^I ~exotic~objを追加する。
~~実際、
これが大域~objを~exotic~objにすることはない。
~indexによる~accessは `WindowProxy$I ~exotic~objが引き受ける。
◎
Since this is the global object, the IDL named getter adds a NamedPropertiesObject exotic object on the prototype chain. Indeed, this does not make the global object an exotic object. Indexed access is taken care of by the WindowProxy exotic object.
</span> */
  `getter＠#dom-window-nameditem$ `object$ (DOMString %name);

  /* <span class="comment">
~UA
◎
the user agent
</span> */
  readonly attribute `Navigator$I `navigator$m;
  [Replaceable] readonly attribute `Navigator$I `clientInformation$m; /* <span class="comment">
`navigator^m の旧来の別名
◎
legacy alias of .navigator
</span> */
  readonly attribute boolean `originAgentCluster$m;
  /* <span class="comment">
利用者~向けの~prompt
◎
user prompts
</span> */
  undefined `alert$m0();
  undefined `alert$m(DOMString %message);
  boolean `confirm$m(optional DOMString %message = "");
  DOMString? `prompt$m(optional DOMString %message = "", optional DOMString %default = "");
  undefined `print$m();

  undefined `postMessage$m(any %message, USVString %targetOrigin, optional sequence&lt;`object$&gt; %transfer = []);
  undefined `postMessage$m0(any %message, optional `WindowPostMessageOptions$I %options = {});

  /* <span class="comment">
`廃用にされた~memberもある＠~HTMLLS/obsolete.html#Window-partial$
</span> */
};
`Window$I includes `GlobalEventHandlers$I;
`Window$I includes `WindowEventHandlers$I;

dictionary `WindowPostMessageOptions@I : `StructuredSerializeOptions$I {
  USVString `targetOrigin@m = "/";
};
</pre>

<dl class="domintro">
	<dt>%window.`window$m</dt>
	<dt>%window.`frames$m</dt>
	<dt>%window.`self$m</dt>
	<dd>
これらの属性はいずれも %window を返す。
◎
These attributes all return window.
</dd>

	<dt>%window.`document$m</dt>
	<dd>
%window に`結付けられた文書$を返す。
◎
Returns the Document associated with window.
</dd>

	<dt>%document.`defaultView$m</dt>
	<dd>
作動中な文書を`結付けている~window＠#concept-document-window$が［
在るならばそれ／
無いならば ~NULL
］を返す。
◎
Returns the Window associated with document, if there is one, or null otherwise.
</dd>
</dl>

<p>
各`~window$には、
それに
`結付けられた文書@
と呼ばれる，ある`文書$が結付けられる。
それは，当の`~window$の作成-時に`初期~about_blank な文書$に設定され、
変化するのは，そこから`~navigate$する間に限られる。
◎
The Window object has an associated Document, which is a Document object. It is set when the Window object is created, and only ever changed during navigation from the initial about:blank Document.
</p>

<p>
`~window$ %~window に
`対応する閲覧~文脈@
とは、
%~window に`結付けられた文書$が`属する閲覧~文脈$を指す
（これは、［
~NULL ／`閲覧~文脈$
］になる）。
◎
A Window's browsing context is its associated Document's browsing context. It is either null or a browsing context.
</p>

<p>
`~window$ %~window に
`対応する~navigable@
は、
次を満たす`~navigable$は［
在るならば それ／
無いならば ~NULL
］とする
⇒
それにて`作動中な文書$nav ~EQ %~window に`結付けられた文書$
◎
A Window's navigable is the navigable whose active document is the Window's associated Document's, or null if there is no such navigable.
</p>

<p class="trans-note">【
該当するものは、
一つに限られることになる。
】</p>

<div class="algo">
［
`window@m
／
`frames@m
／
`self@m
］取得子~手続きは、
いずれも
⇒
~RET コレに`関連な~realm$.`GlobalEnv^sl.`GlobalThisValue^sl
◎
The window, frames, and self getter steps are to return this's relevant realm.[[GlobalEnv]].[[GlobalThisValue]].
</div>

<div class="algo">
<p>
`document@m
取得子~手続きは
⇒
~RET コレに`結付けられた文書$
◎
The document getter steps are to return this's associated Document.
</p>

<p class="note">注記：
`~window$に`結付けられた文書$が変化し得る事例は、
唯一，［
`~navi~algo$が，`閲覧~文脈$内に最初の~pageを読込むために`新たな文書を作成する＠~HTMLlifecycle#initialise-the-document-object$とき
］に限られる。
その事例では、
`初期~about_blank な文書$【！~page】の`~window$が再利用され，新たな`文書$を取得する。
◎
The Document object associated with a Window object can change in exactly one case: when the navigate algorithm creates a new Document object for the first page loaded in a browsing context. In that specific case, the Window object of the initial about:blank page is reused and gets a new Document object.
</p>
</div>

<div class="algo">
`Document$I の
`defaultView@m
取得子~手続きは
⇒
~RET コレが`属する閲覧~文脈$ %B に応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ %B の `WindowProxy$I ~obj
◎
The defaultView getter steps are:
• If this's browsing context is null, then return null.
• Return this's browsing context's WindowProxy object.
</div>

<hr>

<div class="p">
<p>
歴史的な理由から、
各`~window$は，次の特性を備える~propを有するモノトスル：
</p>
<ul>
	<li>
`writable, configurable, non-enumerable^en
【 { `Writable^sl: ~T, `Configurable^sl: ~T, `Enumerable^sl: ~F } 】
</li>
	<li>
名前： `HTMLDocument@l
</li>
	<li>
値： `Document$I interface object
</li>
</ul>
◎
For historical reasons, Window objects must also have a writable, configurable, non-enumerable property named HTMLDocument whose value is the Document interface object.
</div>

				<section id="apis-for-creating-and-navigating-browsing-contexts-by-name">
<h5 title="Opening and closing windows">7.2.2.1. ~windowを開く／閉じる~API</h5>


<dl class="domintro">
	<dt>%window = %window.`open([ url [, target [, features ] ] ])$m</dt>
	<dd>
%url （省略時は "`~about_blank$sc" ）を示す~windowを開いて、
それを返す。
◎
Opens a window to show url (defaults to "about:blank"), and returns it.＼
</dd>
	<dd>
%target （省略時は `_blank^l ）は、
新たな~windowの名前を与える。
その名前の~windowがすでに存在する場合、
それが再利用される。
◎
target (defaults to "_blank") gives the name of the new window. If a window already exists with that name, it is reused.＼
</dd>
	<dd>
<p>
%features 引数は、
`~commaで分離された~token集合$を包含し得る：
◎
The features argument can contain a set of comma-separated tokens:
</p>
		<dl>
			<dt>`noopener^l</dt>
			<dt>`noreferrer^l</dt>
			<dd>
これらは順に，`~hyperlink$の~link型［
`noopener$v, `noreferrer$v
］と等価に挙動する。
◎
These behave equivalently to the noopener and noreferrer link types on hyperlinks.
</dd>
			<dt>`popup^l</dt>
			<dd>
新たな~window用には必要最小限な~web~browser~UIを供するよう，
~UAに奨励する。
（すべての `BarProp$I ~objの `visible$m 取得子にも影響iする。）
◎
Encourages user agents to provide a minimal web browser user interface for the new window. (Impacts the visible getter on all BarProp objects as well.)
</dd>
		</dl>
	</dd>
	<dd class="example">
<pre>
globalThis.open("https://email.example/message/CAOOOkFcWW97r8yg=SsWg7GgCmp4suVX9o85y8BvNRqMjuc5PXg", undefined, "noopener,popup");
</pre>
	</dd>

	<dt>%window.`name$m [ = %value ]</dt>
	<dd>
この~windowの名前を返す。
◎
Returns the name of the window.
</dd>
	<dd>
設定して，名前を変更できる。
◎
Can be set, to change the name.
</dd>

	<dt>%window.`close()$m</dt>
	<dd>
この~windowを閉じる。
◎
Closes the window.
</dd>

	<dt>%window.`closed$m</dt>
	<dd>
この~windowは［
すでに閉じられたなら ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the window has been closed, false otherwise.
</dd>

	<dt>%window.`stop()$m</dt>
	<dd>
文書の読込nを取消す。
◎
Cancels the document load.
</dd>
</dl>

<div class="algo">
<p>
`~window~open用の~noopenerを取得する@
~algoは、
所与の
( `文書$ %~source文書, `有順序~map$ %特能~map, ［`~URL~record$ ／ ~NULL ］ %~URL )
に対し：
◎
To get noopener for window open, given a Document sourceDocument, an ordered map tokenizedFeatures, and a URL record-or-null url, perform the following steps.＼
</p>
<ol>
	<li>
<p>
~RET ~IS ~OR↓：
◎
They return a boolean.
</p>
		<ul>
			<li>
［
%~URL ~NEQ ~NULL
］~AND［
%~URL の`~blob~URL~entry$url ~NEQ ~NULL
］~AND［
次の 2 つは`同じ~site$でない
］
⇒＃
%~URL の`~blob~URL~entry$urlの`環境$bUの`生成元$enV,
%~source文書 に`関連な設定群~obj$の`~top-level生成元$enV
◎
If url is not null and url's blob URL entry is not null:
• Let blobOrigin be url's blob URL entry's environment's origin.
• Let topLevelOrigin be sourceDocument's relevant settings object's top-level origin.
• If blobOrigin is not same site with topLevelOrigin, then return true.
</li>
			<li>
［
%特能~map[ `noopener^l ] ~NEQ ε
］~AND［
次の結果 ~EQ ~T
］
⇒
`真偽-特能を構文解析する$( %特能~map[ `noopener^l ] )
◎
Let noopener be false.
◎
If tokenizedFeatures["noopener"] exists, then set noopener to the result of parsing tokenizedFeatures["noopener"] as a boolean feature.
◎
Return noopener.
</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~window~open手続き@
は、
所与の
( 文字列 %~URL, 文字列 %~target, 文字列 %特能~群 )
に対し：
◎
The window open steps, given a string url, a string target, and a string features, are as follows:
</p>
<ol>
	<li>
~IF［
当の`~event~loop$の`終了n入子ng~level$ ~NEQ 0
］
⇒
~RET ~NULL
◎
If the event loop's termination nesting level is nonzero, then return null.
</li>
	<li>
%~source文書 ~LET `入口~大域~obj$に`結付けられた文書$
◎
Let sourceDocument be the entry global object's associated Document.
</li>
	<li>
%~URL~record ~LET ~NULL
◎
Let urlRecord be null.
</li>
	<li>
<p>
~IF［
%~URL ~NEQ 空~文字列
］：
◎
If url is not the empty string, then:
</p>
		<ol>
			<li>
%~URL~record ~LET `~URLを符号化法の下で相対的に構文解析する$( %~URL, %~source文書 )
◎
Set urlRecord to the result of encoding-parsing a URL given url, relative to sourceDocument.
</li>
			<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If urlRecord is failure, then throw a "SyntaxError" DOMException.
</li>
		</ol>
	</li>
	<li>
~IF［
%~target ~EQ 空~文字列
］
⇒
%~target ~SET `_blank^l
◎
If target is the empty string, then set target to "_blank".
</li>
	<li>
%特能~map ~LET `特能~群を~token化する$( %特能~群 )
◎
Let tokenizedFeatures be the result of tokenizing features.
</li>
	<li>
%noreferrer ~LET ~F
◎
Let noreferrer be false.
</li>
	<li>
~IF［
%特能~map[ `noreferrer^l ] ~NEQ ε
］
⇒
%noreferrer ~SET `真偽-特能を構文解析する$( %特能~map[ `noreferrer^l ] )
◎
If tokenizedFeatures["noreferrer"] exists, then set noreferrer to the result of parsing tokenizedFeatures["noreferrer"] as a boolean feature.
</li>
	<li>
%noopener ~LET `~window~open用の~noopenerを取得する$( %~source文書, %特能~map, %~URL~record )
◎
Let noopener be the result of getting noopener for window open with sourceDocument, tokenizedFeatures, and urlRecord.
</li>
	<li>
%特能~map[ `noopener^l ] ~SET ε
◎
Remove tokenizedFeatures["noopener"]＼
</li>
	<li>
%特能~map[ `noreferrer^l ] ~SET ε
◎
and tokenizedFeatures["noreferrer"].
</li>
	<li>
%~referrer施策 ~LET 空~文字列
◎
Let referrerPolicy be the empty string.
</li>
	<li>
~IF［
%noreferrer ~EQ ~T
］
⇒＃
%noopener ~SET ~T；
%~referrer施策 ~SET `no-referrer^l
◎
If noreferrer is true, then set noopener to true and set referrerPolicy to "no-referrer".
</li>
	<li>
<p>
( %~target~navigable, %~window種別 ) ~LET
`~navigableを選ぶ規則$を適用する( %~target, %~source文書 の`~node~navigable$, %noopener )
◎
Let targetNavigable and windowType be the result of applying the rules for choosing a navigable given target, sourceDocument's node navigable, and noopener.
</p>

<p class="example">
例えば、
~UAが［
<kbd>control</kbd>＋~clickにより，~linkを新たな~UItabに開く
］ことを~supportしていて，利用者が［
要素に対し それを行った
］とき，対する `onclick^m ~handlerは［
`iframe$e 内に~pageを開くために `window.open()＠#dom-window-open$c ~APIを利用していた
］場合、
~UAは［
~target閲覧~文脈の選定を上書きして，新たな~UItabを~targetにする
］こともできる。
◎
If there is a user agent that supports control-clicking a link to open it in a new tab, and the user control-clicks on an element whose onclick handler uses the window.open() API to open a page in an iframe element, the user agent could override the selection of the target browsing context to instead target a new tab.
</p>
	</li>
	<li>
~IF［
%~target~navigable ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If targetNavigable is null, then return null.
</li>
	<li>
<p>
~IF［
%~window種別 ~IN { `制約されない新たな^i, `~openerが無い新たな^i }
］：
◎
If windowType is either "new and unrestricted" or "new with no opener", then:
</p>
		<ol>
			<li>
%~target~navigable にて`作動中な閲覧~文脈$navの`~popupか$bc ~SET 
`~popup~windowが要請されたか否か検査する$( %特能~map )
◎
Set targetNavigable's active browsing context's is popup to the result of checking if a popup window is requested, given tokenizedFeatures.
</li>
			<li>
`閲覧~文脈の特能を設定しておく$( %~target~navigable にて`作動中な閲覧~文脈$nav, %特能~map )
`CSSOMVIEW$r
◎
Set up browsing context features for targetNavigable's active browsing context given tokenizedFeatures. [CSSOMVIEW]
</li>
			<li>
~IF［
%~URL~record ~EQ ~NULL
］
⇒
%~URL~record ~SET `~about_blank$sc を表現する`~URL~record$
◎
If urlRecord is null, then set urlRecord to a URL record representing about:blank.
</li>
			<li>
<p>
~IF［
%~URL~record は`~about_blank に合致して$いる
］
⇒
`~URLと履歴を更新する$( %~target~navigable にて`作動中な文書$nav, %~URL~record )
◎
If urlRecord matches about:blank, then perform the URL and history update steps given targetNavigable's active document and urlRecord.
</p>

<p class="note">注記：
この段は、
%~URL が `about:blank?foo^l の様な何かである事例で必要yである。
%~URL は単に素な `~about_blank^sc の場合、
この段は何もしない。
◎
This is necessary in case url is something like about:blank?foo. If url is just plain about:blank, this will do nothing.
</p>
			</li>
			<li>
~ELSE
⇒
`~navigableを~URLへ~navigateする$( %~target~navigable, %~URL~record, %~source文書 )
— 次も与える下で
⇒＃
`~referrer施策^i ~SET %~referrer施策,
`例外を可能化するか^i ~SET ~T
◎
Otherwise, navigate targetNavigable to urlRecord using sourceDocument, with referrerPolicy set to referrerPolicy and exceptionsEnabled set to true.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
~IF［
%~URL~record ~NEQ ~NULL
］
⇒
`~navigableを~URLへ~navigateする$(  %~target~navigable, %~URL~record, %~source文書 )
— 次も与える下で
⇒＃
`~referrer施策^i ~SET %~referrer施策,
`例外を可能化するか^i ~SET ~T
◎
If urlRecord is not null, then navigate targetNavigable to urlRecord using sourceDocument, with referrerPolicy set to referrerPolicy and exceptionsEnabled set to true.
</li>
			<li>
~IF［
%noopener ~EQ ~F
］
⇒
%~target~navigable にて`作動中な閲覧~文脈$navを`開いた閲覧~文脈$bc ~SET %~source文書 が`属する閲覧~文脈$
◎
If noopener is false, then set targetNavigable's active browsing context's opener browsing context to sourceDocument's browsing context.
</li>
		</ol>
	</li>
	<li>
~IF［
%noopener ~EQ ~T
］~OR［
%~window種別 ~EQ `~openerが無い新たな^i
］
⇒
~RET ~NULL
◎
If noopener is true or windowType is "new with no opener", then return null.
</li>
	<li>
~RET %~target~navigable にて`作動中な~WindowProxy$nav
◎
Return targetNavigable's active WindowProxy.
</li>
</ol>
</div>

<div class="algo">
<p>
`open(url, target, features)@m
~method手続きは
⇒
`~window~open手続き$( %url, %target, %features )
◎
The open(url, target, features) method steps are to run the window open steps with url, target, and features.
</p>

<p class="note">注記：
この~methodは、［
既存の`閲覧~文脈$を`~navigate$する ／
`補助~閲覧~文脈$を開いて~navigateする
］ための仕組みを供する。
◎
The method provides a mechanism for navigating an existing browsing context or opening and navigating an auxiliary browsing context.
</p>
</div>

<hr>

<div class="algo">
<p>
`特能~群を~token化する@
~algoは、
所与の
( 文字列 %特能~群 )
に対し：
◎
To tokenize the features argument:
</p>
<ol>
	<li>
%特能~map ~LET 新たな`有順序~map$
◎
Let tokenizedFeatures be a new ordered map.
</li>
	<li>
%位置 ~LET %特能~群 の最初の符号位置を指している`位置~変数$
◎
Let position point at the first code point of features.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of features:
</p>
		<ol>
			<li>
%名前 ~LET 空~文字列
◎
Let name be the empty string.
</li>
			<li>
%値 ~LET 空~文字列
◎
Let value be the empty string.
</li>
			<li>
%特能~群 内の %位置 から，`特能~分離子$である`符号位置~並びを収集する$
— これは、
特能~名より前に現れる分離子を読飛ばす
◎
Collect a sequence of code points that are feature separators from features given position. This skips past leading separators before the name.
</li>
			<li>
%名前 ~SET %特能~群 内の %位置 から，`特能~分離子$でない`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not feature separators from features given position.＼
</li>
			<li>
%名前 ~SET `~ASCII小文字~化する$( %名前 )
◎
Set name to the collected characters, converted to ASCII lowercase.
</li>
			<li>
%名前 ~SET `特能~名として正規化する$( %名前 )
◎
Set name to the result of normalizing the feature name name.
</li>
			<li>
<p>
~WHILE［
%位置↗ ~NIN { ε, `003D^U `=^smb }
］
◎
While position is not past the end of features and the code point at position in features is not U+003D (=):
</p>
				<ol>
					<li>
~IF［
%位置↗ ~EQ `002C^U `,^smb
］~OR［
%位置↗ ~NIN { `特能~分離子$ }
］
⇒
~BREAK
◎
If the code point at position in features is U+002C (,), or if it is not a feature separator, then break.
</li>
					<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
				</ol>

<p class="note">注記：
これは、
最初の `003D^U `=^smb まで, かつ［
`002C^U `,^smb ／ 非~分離子
］を過ぎない所まで読飛ばす
◎
This skips to the first U+003D (=) but does not skip past a U+002C (,) or a non-separator.
</p>
			</li>
			<li>
<p>
~IF［
%位置↗ ~IN { `特能~分離子$ }
］：
◎
If the code point at position in features is a feature separator:
</p>

				<ol>
					<li>
<p>
~WHILE［
%位置↗ ~IN { `特能~分離子$ }
］：
◎
While position is not past the end of features and the code point at position in features is a feature separator:
</p>

						<ol>
							<li>
~IF［
%位置↗ ~EQ `002C^U `,^smb
］
⇒
~BREAK
◎
If the code point at position in features is U+002C (,), then break.
</li>
							<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
						</ol>

<p class="note">注記：
これは、
最初の非~分離子まで, かつ `002C^U `,^smb を過ぎない所まで読飛ばす
◎
This skips to the first non-separator but does not skip past a U+002C (,).
</p>
					</li>
					<li>
%値 ~SET %特能~群 内の %位置 から，`特能~分離子$でない`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not feature separators code points from features given position.＼
</li>
					<li>
%値 ~SET `~ASCII小文字~化する$( %値 )
◎
Set value to the collected code points, converted to ASCII lowercase.
</li>
				</ol>
			</li>
			<li>
~IF［
%名前 ~NEQ 空~文字列
］
⇒
%特能~map[ %名前 ] ~SET %値
◎
If name is not the empty string, then set tokenizedFeatures[name] to value.
</li>
		</ol>
	</li>
	<li>
~RET %特能~map
◎
Return tokenizedFeatures.
</li>
</ol>
</div>


<div class="algo">
<p>
`~window特能は設定されたか否か検査する@
~algoは、
所与の
( %特能~map, %特能~名, %既定~値 )
に対し：
◎
To check if a window feature is set, given tokenizedFeatures, featureName, and defaultValue:
</p>
<ol>
	<li>
~IF［
%特能~map[ %特能~名 ] ~NEQ ε
］
⇒
~RET `真偽-特能を構文解析する$( %特能~map[ %特能~名 ] )
◎
If tokenizedFeatures[featureName] exists, then return the result of parsing tokenizedFeatures[featureName] as a boolean feature.
</li>
	<li>
~RET %既定~値
◎
Return defaultValue.
</li>
</ol>
</div>

<div class="algo">
<p>
`~popup~windowが要請されたか否か検査する@
~algoは、
所与の
( %特能~map )
に対し：
◎
To check if a popup window is requested, given tokenizedFeatures:
</p>
<ol>
	<li>
~IF［
%特能~map は`空$mapである
］
⇒
~RET ~F
◎
If tokenizedFeatures is empty, then return false.
</li>
	<li>
~IF［
%特能~map[ `popup^l ] ~NEQ ε
］
⇒
~RET `真偽-特能を構文解析する$( %特能~map[ `popup^l ] )
◎
If tokenizedFeatures["popup"] exists, then return the result of parsing tokenizedFeatures["popup"] as a boolean feature.
</li>
	<li>
%location ~LET `~window特能は設定されたか否か検査する$( %特能~map, `location^l, ~F )
◎
Let location be the result of checking if a window feature is set, given tokenizedFeatures, "location", and false.
</li>
	<li>
%toolbar ~LET `~window特能は設定されたか否か検査する$( %特能~map, `toolbar^l, ~F )
◎
Let toolbar be the result of checking if a window feature is set, given tokenizedFeatures, "toolbar", and false.
</li>
	<li>
~IF［
%location ~EQ ~F
］~AND［
%toolbar ~EQ ~F
］
⇒
~RET ~T
◎
If location and toolbar are both false, then return true.
</li>
	<li>
%menubar ~LET `~window特能は設定されたか否か検査する$( %特能~map, `menubar^l, ~F )
◎
Let menubar be the result of checking if a window feature is set, given tokenizedFeatures, "menubar", and false.
</li>
	<li>
~IF［
%menubar ~EQ ~F
］
⇒
~RET ~T
◎
If menubar is false, then return true.
</li>
	<li>
%resizable ~LET `~window特能は設定されたか否か検査する$( %特能~map, `resizable^l, ~T )
◎
Let resizable be the result of checking if a window feature is set, given tokenizedFeatures, "resizable", and true.
</li>
	<li>
~IF［
%resizable ~EQ ~F
］
⇒
~RET ~T
◎
If resizable is false, then return true.
</li>
	<li>
%scrollbars ~LET `~window特能は設定されたか否か検査する$( %特能~map, `scrollbars^l, ~F )
◎
Let scrollbars be the result of checking if a window feature is set, given tokenizedFeatures, "scrollbars", and false.
</li>
	<li>
~IF［
%scrollbars ~EQ ~F
］
⇒
~RET ~T
◎
If scrollbars is false, then return true.
</li>
	<li>
%status ~LET `~window特能は設定されたか否か検査する$( %特能~map, `status^l, ~F )
◎
Let status be the result of checking if a window feature is set, given tokenizedFeatures, "status", and false.
</li>
	<li>
~IF［
%status ~EQ ~F
］
⇒
~RET ~T
◎
If status is false, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<p>
次に挙げる符号位置は、
`特能~分離子@
とされる
⇒＃
`~ASCII空白$,
`003D^U `=^smb,
`002C^U `,^smb
◎
A code point is a feature separator if it is ASCII whitespace, U+003D (=), or U+002C (,).
</p>

<p>
旧来の理由から、
一部の特能~名には別名がある
— それらは、
次の~algoにより正規化される。
◎
For legacy reasons, there are some aliases of some feature names.＼
</p>

<div class="algo">
`特能~名として正規化する@
~algoは、
所与の
( %名前 )
に対し
⇒
~RET %名前 に応じて
⇒＃
`screenx^l ならば `left^l ／
`screeny^l ならば `top^l ／
`innerwidth^l ならば `width^l ／
`innerheight^l ならば `height^l ／
~ELSE_  %名前
◎
To normalize a feature name name, switch on name:
◎
"screenx"
• Return "left".
"screeny"
• Return "top".
"innerwidth"
• Return "width".
"innerheight"
• Return "height".
Anything else
• Return name.
</div>

<div class="algo">
<p>
`真偽-特能を構文解析する@
~algoは、
所与の
( 文字列 %値 )
に対し
⇒
~RET ~IS ~OR↓：
◎
To parse a boolean feature given a string value:
</p>
<ul>
	<li>
%値 ~IN【！identical】 { 空~文字列, `yes^l, `true^l }
◎
If value is the empty string, then return true.
◎
If value is "yes", then return true.
◎
If value is "true", then return true.
</li>
	<li>
次の結果 ~NIN { `失敗^i, 0 }
⇒
`整数として構文解析する$( %値 )
◎
Let parsed be the result of parsing value as an integer.
◎
If parsed is an error, then set it to 0.
◎
Return false if parsed is 0, and true otherwise.
</li>
</ul>
</div>

<p>
`name@m
属性の：
◎
↓</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET コレに`対応する~navigable$ %N に応じて
⇒＃
~NULL ならば 空~文字列 ／
~ELSE_ %N の`~target名$nav
◎
The name getter steps are:
• If this's navigable is null, then return the empty string.
• Return this's navigable's target name.
</li>
	<li class="algo">
<p>
設定子~手続きは
◎
The name setter steps are:
</p>
		<ol>
			<li>
~IF［
コレに`対応する~navigable$ ~EQ ~NULL
］
⇒
~RET
◎
If this's navigable is null, then return.
</li>
			<li>
コレに`対応する~navigable$にて`作動中な~session履歴~entry$navの`文書~状態$shEの`~navigable名$dS ~SET 所与の値
◎
Set this's navigable's active session history entry's document state's navigable target name to the given value.
</li>
		</ol>

<p class="note">注記：
名前は、
~navigable が別の`生成元$へ`~navigate$されたときは，
`設定し直される＠~HTMLnav#resetBCName$。
◎
The name gets reset when the navigable is navigated to another origin.
</p>
	</li>
</ul>

<div class="algo">
<p>
`close()@m
~method手続きは：
◎
The close() method steps are:
</p>
<ol>
	<li>
%この辿可能 ~LET コレに`対応する~navigable$
◎
Let thisTraversable be this's navigable.
</li>
	<li>
~IF［
%この辿可能 は`~top-level辿可能$でない
］
⇒
~RET
◎
If thisTraversable is not a top-level traversable, then return.
</li>
	<li>
~IF［
%この辿可能 の`閉中か$nav ~EQ ~T
］
⇒
~RET
◎
If thisTraversable's is closing is true, then return.
</li>
	<li>
%閲覧~文脈 ~LET %この辿可能 にて`作動中な閲覧~文脈$nav
◎
Let browsingContext be thisTraversable's active browsing context.
</li>
	<li>
%~source~snapshot~params ~LET `~source~snapshot~paramsを~snapshotする$( %この辿可能 にて`作動中な文書$nav )
◎
Let sourceSnapshotParams be the result of snapshotting source snapshot params given thisTraversable's active document.
</li>
	<li>
<p>
~IF［
~AND↓
］…
◎
If all the following are true:
</p>
		<ul>
			<li>
%この辿可能 は`~scriptから閉じれる$
◎
thisTraversable is script-closable;
</li>
			<li>
`現任な大域~obj$に`対応する閲覧~文脈$は %閲覧~文脈 に`近しい$
◎
the incumbent global object's browsing context is familiar with browsingContext; and
</li>
			<li id="sandboxClose">
`現任な大域~obj$に`対応する~navigable$が %この辿可能 を`~navigateすることは~sandbox法により許容される$( %~source~snapshot~params )
◎
the incumbent global object's navigable is allowed by sandboxing to navigate thisTraversable, given sourceSnapshotParams,
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
%この辿可能 の`閉中か$nav ~SET ~T
◎
Set thisTraversable's is closing to true.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~top-level辿可能を確定的に閉じる$( %この辿可能 )
</div>
◎
Queue a task on the DOM manipulation task source to definitely close thisTraversable.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
所与の`~navigable$が
`~scriptから閉じれる@
とは、
~OR↓ を満たす`~top-level辿可能$であることをいう：
◎
A navigable is script-closable if it is a top-level traversable, and any of the following are true:
</p>
<ul>
	<li>
その`~web内容により作成されたか$nav ~EQ ~T
◎
its is created by web content is true; or
</li>
	<li>
その`~session履歴~entry群$navの`~size$ ~EQ 1
◎
its session history entries's size is 1.
</li>
</ul>

<div class="algo">
`closed@m
取得子~手続きは
⇒
~RET ~IS［
コレに`対応する閲覧~文脈$ %B は次を満たす
］
⇒
［
%B ~EQ ~NULL
］~OR［
%B の`閉中か$nav ~EQ ~T
］
◎
The closed getter steps are to return true if this's browsing context is null or its is closing is true; otherwise false.
</div>

<div class="algo">
<p>
`stop()@m
~method手続きは：
◎
The stop() method steps are:
</p>
<ol>
	<li>
%~navigable ~LET コレに`対応する~navigable$
◎
↓</li>
	<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
~RET
◎
If this's navigable is null, then return.
</li>
	<li>
`読込ngを停止する$( %~navigable )
◎
Stop loading this's navigable.
</li>
</ol>
</div>

				</section>
				<section id="accessing-other-browsing-contexts">
<h5 title="Indexed access on the Window object">7.2.2.2. `Window^I ~obj上の有index~access</h5>

<dl class="domintro">
	<dt>%window.`length$m</dt>
	<dd>
`文書~treeに属する子~navigable群$の~size【！the number of】を返す。
◎
Returns the number of document-tree child navigables.
</dd>

	<dt>%window[%index]</dt>
	<dd>
%index で指示される［
`文書~treeに属する子~navigable群$内の~navigable
］に対応している `WindowProxy$I を返す。
◎
Returns the WindowProxy corresponding to the indicated document-tree child navigables.
</dd>
</dl>

<div class="algo">
<p>
`length@m
取得子~手続きは
⇒
~RET コレに`結付けられた文書$の`文書~treeに属する子~navigable群$の`~size$
◎
The length getter steps are to return this's associated Document's document-tree child navigables's size.
</p>

<p class="note">注記：
~indexによる`文書~treeに属する子~navigable群$への~accessは、
`WindowProxy$I ~objの `GetOwnProperty$sl 内部~methodを通して定義される。
◎
Indexed access to document-tree child navigables is defined through the [[GetOwnProperty]] internal method of the WindowProxy object.
</p>
</div>

				</section>
				<section id="named-access-on-the-window-object">
<h5 title="Named access on the Window object">7.2.2.3. `Window^I ~objに対する名前による~access</h5>

<dl class="domintro">
	<dt>%window[%name]</dt>
	<dd>
指示された要素（たち）の~collectionを返す。
◎
Returns the indicated element or collection of elements.
</dd>
	<dd>
一般に、
これに依拠すると，~codeは壊れやすくなる。
例えば、［
~web~platformに新たな特能が追加されるに伴い，
どの~IDがこの~APIに対応付けられるか
］は，時を経れば変わり得るので。
代わりに，
`document.getElementById()^m ／
`document.querySelector()^m
を利用すること。
◎
As a general rule, relying on this will lead to brittle code. Which IDs end up mapping to this API can vary over time, as new features are added to the web platform, for example. Instead of this, use document.getElementById() or document.querySelector().
</dd>
</dl>

<div class="algo">
<p>
所与の`~window$ %~window の
`文書~treeに属する子~navigable~target名~prop集合@
は、
次の手続きが返す結果で与えられる：
◎
The document-tree child navigable target name property set of a Window object window is the return value of running these steps:
</p>
<ol>
	<li>
%子~群 ~LET %~window に`結付けられた文書$の`文書~treeに属する子~navigable群$
◎
Let children be the document-tree child navigables of window's associated Document.
</li>
	<li>
<p>
%有名~子~群 ~LET 新たな`有順序~map$
◎
Let firstNamedChildren be an empty ordered set.
</p>

<p class="trans-note">【
原文では`有順序~集合$を利用しているが、
`有順序~map$の方が簡潔に述べれるので，改めている。
】</p>
	</li>
	<li>
<p>
%子~群 を成す
~EACH( %~navigable )
に対し：
◎
For each navigable of children:
</p>
		<ol>
			<li>
%名前 ~LET %~navigable の`~target名$nav
◎
Let name be navigable's target name.
</li>
			<li>
~IF［
%名前 ~NEQ 空~文字列
］~AND［
%有名~子~群[ %名前 ] ~EQ ε
］
⇒
%有名~子~群[ %名前 ] ~SET %~navigable
◎
If name is the empty string, then continue.
◎
If firstNamedChildren contains a navigable whose target name is name, then continue.
◎
Append navigable to firstNamedChildren.
</li>
		</ol>
	</li>
	<li>
%名前~群 ~LET 新たな`有順序~集合$
◎
Let names be an empty ordered set.
</li>
	<li>
%有名~子~群 を成す
~EACH( %名前 → %~navigable )
に対し
⇒
~IF［
( %~navigable の`作動中な文書$navの`生成元$doc, %~window に`関連な設定群~obj$の`生成元$enV )
は`同一-生成元$である
］
⇒
%名前~群 に %名前 を`付加する$set【！#list-append】
◎
For each navigable of firstNamedChildren:
• Let name be navigable's target name.
• If navigable's active document's origin is same origin with window's relevant settings object's origin, then append name to names.
</li>
	<li>
~RET %名前~群
◎
Return names.
</li>
</ol>
</div>

<div class="example">
<p>
上の手続きにおける 2 つの別々な反復は、
次を意味する：
例えば次の~pageが
`https://example.org/^c
にて~hostされていて，
`https://elsewhere.example/^c
の `iframe^e の `name$m が `spices^l に設定されたとするとき、［
すべてが読込まれた後に `window.spices^c を評価した結果
］は `undefined^jv 【すなわち， `spices^l ~NIN %名前~群 】になる：
◎
The two seperate iterations mean that in the following example, hosted on https://example.org/, assuming https://elsewhere.example/ sets window.name to "spices", evaluating window.spices after everything has loaded will yield undefined:
</p>

<pre class="lang-html">
&lt;iframe src=https://elsewhere.example.com/&gt;&lt;/iframe&gt;
&lt;iframe name=spices&gt;&lt;/iframe&gt;
</pre>
</div>

<p>
各`~window$は、
`有名~propを~supportする$。
所与の任意の時点における`~window$ %~window が`~supportする~prop名$は、
次に挙げるものからなる：
◎
The Window object supports named properties. The supported property names of a Window object window at any moment consist of the following, in tree order according to the element that contributed them, ignoring later duplicates:
</p>

<ul>
	<li>
%~window の`文書~treeに属する子~navigable~target名~prop集合$
◎
window's document-tree child navigable target name property set;
</li>
	<li>
<p>
%~window 内にある`有名~要素$の`要素~名$
— `要素~名$が同じものが複数あるときは、
`~tree順序$で最初のもの以外は無視する。
</p>

<p>
%~window 内にある
`有名~要素@,
およびその
`要素~名@
は、［
%~window に`結付けられた文書$を`根$とする`文書~tree内$にある`~HTML要素$
］のうち，次のいずれかに該当する要素, および 対応する名前である：
</p>
		<ul>
			<li>
［
`embed$e, `form$e, `img$e, `object$e
］要素のうち，［
`name^a 内容~属性を有していて，その値 ~NEQ 空~文字列
］を満たすもの
— その属性~値が`要素~名$を与える
</li>
			<li>
［
`id$a 内容~属性を有していて，その値 ~NEQ 空~文字列
］を満たすもの
— その属性~値が`要素~名$を与える
</li>
		</ul>

<p class="trans-note">【
`有名~要素$, `要素~名$は、
記述を論理的に集約するためにこの訳に導入した用語であり，この節でしか利用されない。
】</p>

◎
the value of the name content attribute for all embed, form, img, and object elements that have a non-empty name content attribute and are in a document tree with window's associated Document as their root; and
◎
the value of the id content attribute for all HTML elements that have a non-empty id content attribute and are in a document tree with window's associated Document as their root.
</li>
</ul>

<div class="algo">
<p id="dom-window-nameditem">
`~window$ %~window 用の`有名~propの値を決定する手続き$は、
所与の
( %~window が`~supportする~prop名$ %名前 )
に対し：
◎
To determine the value of a named property name in a Window object window, the user agent must return the value obtained using the following steps:
</p>
<ol>
	<li>
%~obj群 ~LET %~window の［
名前 %名前 を伴う`有名~obj$
］たちが成す~list
◎
Let objects be the list of named objects of window with the name name.
</li>
	<li>
~Assert【！Note → Assert】：
%~obj群 は空でない
◎
There will be at least one such object, since the algorithm would otherwise not have been invoked by Web IDL.
</li>
	<li>
<p>
~IF［
%~obj群 を成す ある~itemは`~navigable$である
］：
◎
If objects contains a navigable, then:
</p>
		<ol>
			<li>
%容器 ~LET %~window に`結付けられた文書$の`子孫$のうち次を満たす最初のもの
⇒
［
`~navigable容器$である
］~AND［
その`内容~navigable$ ~IN %~obj群
］
【`有名~obj$の定義により，条件を満たすものは常に在る。】
◎
Let container be the first navigable container in window's associated Document's descendants whose content navigable is in objects.
</li>
			<li>
~RET %容器 の`内容~navigable$にて`作動中な~WindowProxy$nav
◎
Return container's content navigable's active WindowProxy.
</li>
		</ol>
	</li>
	<li>
~Assert：
%~obj群 は要素のみからなる
◎
↓</li>
	<li>
~IF［
%~obj群 は 1 個の要素のみからなる
］
⇒
~RET その要素
◎
Otherwise, if objects has only one element, return that element.
</li>
	<li>
~RET 次のようにされた `HTMLCollection$I
⇒＃
根： %~window に`結付けられた文書$,
~filter： %~obj群 内にある要素のみに合致する
◎
Otherwise, return an HTMLCollection rooted at window's associated Document, whose filter matches only named objects of window with the name name. (By definition, these will all be elements.)
</li>
</ol>
</div>

<p>
`~window$ %~window の［
名前 %名前 を伴う
`有名~obj@
］は、
次に挙げるものからなる：
◎
Named objects of Window object window with the name name, for the purposes of the above algorithm, consist of the following:
</p>

<ul>
	<li>
%~window に`結付けられた文書$の`文書~treeに属する子~navigable群$のうち，［
その`~target名$nav ~EQ %名前
］を満たすもの
◎
document-tree child navigables of window's associated Document whose target name is name;
</li>
	<li>
%~window 内にある`有名~要素$のうち，［
その`要素~名$ ~EQ %名前
］を満たすもの
◎
embed, form, img, or object elements that have a name content attribute whose value is name and are in a document tree with window's associated Document as their root; and
◎
HTML elements that have an id content attribute whose value is name and are in a document tree with window's associated Document as their root.
</li>
</ul>

<p class="note">注記：
`Window$I ~interfaceは，
`Global$xA 拡張d属性を伴うので、
その有名~propたちは，［
`旧来の~platform~obj$ではなく，`有名~prop群~obj$
］用の規則に従う。
◎
Since the Window interface has the [Global] extended attribute, its named properties follow the rules for named properties objects rather than legacy platform objects.
</p>

				</section>
				<section id="navigating-nested-browsing-contexts-in-the-dom">
<h5 title="Accessing related windows">7.2.2.4. 関係する~windowへの~access法</h5>

<dl class="domintro">
	<dt>%window.`top$m</dt>
	<dd>
`~top-level辿可能$用の `WindowProxy$I を返す。
◎
Returns the WindowProxy for the top-level traversable.
</dd>

	<dt>%window.`opener$m [ = %value ]</dt>
	<dd>
`開いた閲覧~文脈$bc用の `WindowProxy$I を返す。
◎
Returns the WindowProxy for the opener browsing context.
</dd>
	<dd>
そのような閲覧~文脈は無い, あるいは ~NULL に設定された場合、
~NULL を返す。
◎
Returns null if there isn't one or if it has been set to null.
</dd>
	<dd>
~NULL に設定できる。
◎
Can be set to null.
</dd>

	<dt>%window.`parent$m</dt>
	<dd>
`親~navigable$用の `WindowProxy$I を返す。
◎
Returns the WindowProxy for the parent navigable.
</dd>

	<dt>%window.`frameElement$m</dt>
	<dd>
`~navigable容器$を与えている要素を返す。
◎
Returns the navigable container element.
</dd>
	<dd>
そのようなものがない, または “非同一-生成元 状況” にある場合、
~NULL を返す。
◎
Returns null if there isn't one, and in cross-origin situations.
</dd>
</dl>

<div class="algo">
<p>
`top@m
取得子~手続きは：
◎
The top getter steps are:
</p>
<ol>
	<li>
%~navigable ~LET コレに`対応する~navigable$
◎
↓</li>
	<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If this's navigable is null, then return null.
</li>
	<li>
~RET %~navigable の`~top-level辿可能$navにて`作動中な~WindowProxy$nav
◎
Return this's navigable's top-level traversable's active WindowProxy.
</li>
</ol>
</div>

<p>
`opener@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The opener getter steps are:
</p>
		<ol>
			<li>
%B ~LET コレに`対応する閲覧~文脈$
◎
Let current be this's browsing context.
</li>
			<li>
~IF［
%B ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If current is null, then return null.
</li>
			<li>
~IF［
%B を`開いた閲覧~文脈$bc ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If current's opener browsing context is null, then return null.
</li>
			<li>
~RET %B を`開いた閲覧~文脈$bcの `WindowProxy$I ~obj
◎
Return current's opener browsing context's WindowProxy object.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The opener setter steps are:
</p>
		<ol>
			<li>
~IF［
所与の値 ~NEQ ~NULL
］
⇒
~ABRUPT `DefinePropertyOrThrow$jA( コレ, `opener^l, {
`Value^sl: 所与の値,
`Writable^sl: ~T,
`Enumerable^sl: ~T,
`Configurable^sl: ~T
}
)
</li>
			<li>
~ELIF［
コレに`対応する閲覧~文脈$ ~NEQ ~NULL
］
⇒＃
コレに`対応する閲覧~文脈$を`開いた閲覧~文脈$bc ~SET ~NULL
</li>
		</ol>
◎
The opener setter steps are:
• If the given value is null and this's browsing context is non-null, then set this's browsing context's opener browsing context to null.
• If the given value is non-null, then perform ? DefinePropertyOrThrow(this, "opener", { [[Value]]: the given value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }).
</li>
</ul>

<div class="note">
<p>注記：
`~window$の `opener$m を ~NULL に設定すると，
それを`開いた閲覧~文脈$bc %B への参照を~clearする。
これは，実施においては、
~scriptが未来に %B に対応する`~window$へ~accessすることを防止する。
◎
Setting window.opener to null clears the opener browsing context reference. In practice, this prevents future scripts from accessing their opener browsing context's Window object.
</p>

<p>
既定では，~scriptは、
`opener$m 取得子を通して，
%B に対応する`~window$へ~accessできる
— 例：
~scriptは、
`window.opener.location^c を設定でき，
%B を~navigateさせれる。
◎
By default, scripts can access their opener browsing context's Window object through the window.opener getter. E.g., a script can set window.opener.location, causing the opener browsing context to navigate.
</p>
</div>

<div class="algo">
<p>
`parent@m
取得子~手続きは：
◎
The parent getter steps are:
</p>
<ol>
	<li>
%~navigable ~LET コレに`対応する~navigable$
◎
Let navigable be this's navigable.
</li>
	<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If navigable is null, then return null.
</li>
	<li>
~IF［
%~navigable の`親$nav ~NEQ ~NULL
］
⇒
%~navigable ~SET %~navigable の`親$nav
◎
If navigable's parent is not null, then set navigable to navigable's parent.
</li>
	<li>
~RET %~navigable にて`作動中な~WindowProxy$nav
◎
Return navigable's active WindowProxy.
</li>
</ol>
</div>

<div class="algo">
<p>
`frameElement@m
取得子~手続きは：
◎
The frameElement getter steps are:
</p>
<ol>
	<li>
%N ~LET コレの`~node~navigable$
◎
Let current be this's node navigable.
</li>
	<li>
~IF［
%N ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If current is null, then return null.
</li>
	<li>
%容器 ~LET %N の`容器$nav
◎
Let container be current's container.
</li>
	<li>
~IF［
%容器 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If container is null, then return null.
</li>
	<li>
~IF［
( %容器 の`~node文書$の`生成元$doc, `現在の設定群~obj$の`生成元$enV )
は`同じ生成元~domain$でない
］
⇒
~RET ~NULL
◎
If container's node document's origin is not same origin-domain with the current settings object's origin, then return null.
</li>
	<li>
~RET %容器
◎
Return container.
</li>
</ol>
</div>

<div class="example">
<p>
これらの~propが ~NULL を返し得る例：
◎
An example of when these properties can return null is as follows:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;iframe&gt;&lt;/iframe&gt;

&lt;script&gt;
"use strict";
const %element = document.querySelector("iframe");
const %iframeWindow = %element.contentWindow;
%element.remove();

console.assert(%iframeWindow.top === null);
console.assert(%iframeWindow.parent === null);
console.assert(%iframeWindow.frameElement === null);
&lt;/script&gt;
</pre>

<p>
この例の %iframeWindow に対応する`閲覧~文脈$は、
%element が文書から除去されたとき，
`~NULL化＠~HTMLlifecycle#destroy-a-document$される。
◎
Here the browsing context corresponding to iframeWindow was nulled out when element was removed from the document.
</p>
</div>

				</section>
				<section id="browser-interface-elements">
<h5 title="Historical browser interface element APIs">7.2.2.5. 歴史的な~browser~UI要素~API</h5>

<p>
歴史的な理由から、
`Window$I ~interfaceには，
ある種の~web~browser~UI要素の可視性を表現していた いくつかの~propがある。
◎
For historical reasons, the Window interface had some properties that represented the visibility of certain web browser interface elements.
</p>

<p>
~privacyと相互運用能の理由から、
それらの~propは，
今や `Window$I に`対応する閲覧~文脈$の`~popupか$bcを表現する真偽-値を返す。
◎
For privacy and interoperability reasons, those properties now return values that represent whether the Window's browsing context's is popup property is true or false.
</p>

<p>
各~UI要素は、
`BarProp$I ~objにより表現される：
◎
Each interface element is represented by a BarProp object:
</p>

<pre class="idl">
[Exposed=Window]
interface `BarProp@I {
  readonly attribute boolean `visible$m;
};
</pre>

<dl class="domintro">
	<dt>%window.`locationbar$m.`visible$m</dt>
	<dt>%window.`menubar$m.`visible$m</dt>
	<dt>%window.`personalbar$m.`visible$m</dt>
	<dt>%window.`scrollbars$m.`visible$m</dt>
	<dt>%window.`statusbar$m.`visible$m</dt>
	<dt>%window.`toolbar$m.`visible$m</dt>
	<dd>
［
%window は~popupでないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the Window is not a popup; otherwise, returns false.
</dd>
</dl>

<div class="algo">
<p>
`visible@m
取得子~手続きは：
◎
The visible getter steps are:
</p>
<ol>
	<li>
%閲覧~文脈 ~LET コレに`関連な大域~obj$に`対応する閲覧~文脈$
◎
Let browsingContext be this's relevant global object's browsing context.
</li>
	<li>
~IF［
%閲覧~文脈 ~EQ ~NULL
］
⇒
~RET ~F
◎
If browsingContext is null, then return true.
</li>
	<li>
~RET ~IS［
%閲覧~文脈 の`~top-level閲覧~文脈$bcの`~popupか$bc ~EQ ~F
］
◎
Return the negation of browsingContext's top-level browsing context's is popup.
</li>
</ol>
</div>

<p>
以下に挙げる各種 `BarProp$I ~objは、
各 `Window$I ~obj用に存在するモノトスル：
◎
The following BarProp objects must exist for each Window object:
</p>
<dl class="def-list">
	<dt>
`~location-bar@bP
◎
The location bar BarProp object
</dt>
	<dd>
歴史的に，［
~browserの~URL~barを表示する~control
］を包含する~UI要素を表現していた。
◎
Historically represented the user interface element that contains a control that displays the browser's location bar.
</dd>

	<dt>
`~menu-bar@bP
◎
The menu bar BarProp object
</dt>
	<dd>
歴史的に，［
~menu~form内の~commandの~list, またはそれに類似な~UI概念
］を包含する~UI要素を表現していた。
◎
Historically represented the user interface element that contains a list of commands in menu form, or some similar interface concept.
</dd>

	<dt>
`~personal-bar@bP
◎
The personal bar BarProp object
</dt>
	<dd>
歴史的に，［
利用者の “お気に入り（ `favorite^en ）” ~pageを指す~link, またはそれに類似な~UI概念
］を包含する~UI要素を表現していた。
◎
Historically represented the user interface element that contains links to the user's favorite pages, or some similar interface concept.
</dd>

	<dt>
`~scrollbar@bP
◎
The scrollbar BarProp object
</dt>
	<dd>
歴史的に，［
~scrollするための仕組み, またはそれに類似な~UI概念
］を包含する~UI要素を表現していた。
◎
Historically represented the user interface element that contains a scrolling mechanism, or some similar interface concept.
</dd>

	<dt>
`~status-bar@bP
◎
The status bar BarProp object
</dt>
	<dd>
歴史的に，［
利用者の媒体に応じて適切に，文書の直上や直下に見出される~UI要素
］を表現していた。
それは概して，［
進行中な~network活動や, 利用者の~pointing装置が現在~指示している要素
］についての情報を供していた。
◎
Historically represented a user interface element found immediately below or after the document, as appropriate for the user's media, which typically provides information about ongoing network activity or information about elements that the user's pointing device is currently indicating.
</dd>

	<dt>
`~toolbar@bP
◎
The toolbar BarProp object
</dt>
	<dd>
歴史的に，［
利用者の媒体に応じて適切に，文書の直上や直下に見出される~UI要素
］を表現していた。
それは概して，`~session履歴~辿り＠~HTMLnav#apply-the-traverse-history-step$用の~control（戻る／進む／読込直す, 等々の~button）を供していた。
◎
Historically represented the user interface element found immediately above or before the document, as appropriate for the user's media, which typically provides session history traversal controls (back and forward buttons, reload buttons, etc.).
</dd>
</dl>

<div class="algo">
`locationbar@m
取得子~手続きは、
コレの`~location-bar$bPを返す。
◎
The locationbar attribute must return the location bar BarProp object.
</div>

<div class="algo">
`menubar@m
取得子~手続きは、
コレの`~menu-bar$bPを返す。
◎
The menubar attribute must return the menu bar BarProp object.
</div>

<div class="algo">
`personalbar@m
取得子~手続きは、
コレの`~personal-bar$bPを返す。
◎
The personalbar attribute must return the personal bar BarProp object.
</div>

<div class="algo">
`scrollbars@m
取得子~手続きは、
コレの`~scrollbar$bPを返す。
◎
The scrollbars attribute must return the scrollbar BarProp object.
</div>

<div class="algo">
`statusbar@m
取得子~手続きは、
コレの`~status-bar$bPを返す。
◎
The statusbar attribute must return the status bar BarProp object.
</div>

<div class="algo">
`toolbar@m
取得子~手続きは、
コレの`~toolbar$bPを返す。
◎
The toolbar attribute must return the toolbar BarProp object.
</div>

<div class="p">
<p>
`status@m
属性は、
歴史的な理由から存在する
— 次に従うモノトスル：
</p>
<ul>
	<li>
取得子は、
最後に設定された文字列を返す。
</li>
	<li>
設定子は、
自身を所与の値に設定する。
</li>
	<li>
`~window$の作成-時には、
空~文字列に設定する。
</li>
</ul>
<p>
この属性は、
他には何もしない。
</p>
◎
For historical reasons, the status attribute on the Window object must, on getting, return the last string it was set to, and on setting, must set itself to the new value. When the Window object is created, the attribute must be set to the empty string. It does not do anything else.
</div>

				</section>
				<section id="script-settings-for-window-objects">
<h5 title="Script settings for Window objects">7.2.2.6. `Window^I ~obj用の~script設定群</h5>

<div class="algo">
<p>
`~window用に環境~設定群~objを設定しておく@
~algoは、
所与の
⇒＃
`~URL$ %作成時の~URL,
`~JS実行~文脈$ %実行~文脈,
~NULL または`環境$ %予約-済み環境,
`~URL$ %~top-level作成時の~URL,
`生成元$ %~top-level生成元
◎終
に対し：
◎
To set up a window environment settings object, given a URL creationURL, a JavaScript execution context execution context, null or an environment reservedEnvironment, a URL topLevelCreationURL, and an origin topLevelOrigin, run these steps:
</p>
<ol>
	<li>
%~realm ~LET %実行~文脈 の~Realm成分の値
◎
Let realm be the value of execution context's Realm component.
</li>
	<li>
%~window ~LET %~realm の`大域~obj$rM
◎
Let window be realm's global object.
</li>
	<li>
<p>
%設定群~obj ~LET 新たな`環境~設定群~obj$
— その各種	
以下に従って定義される。
以下における %現~文書 は、
~algoが呼出された時点で %~window に`結付けられた文書$を表すとする：
◎
Let settings object be a new environment settings object whose algorithms are defined as follows:
</p>
		<ul>
			<li class="algo">
`~realm実行~文脈$enV
⇒
~RET %実行~文脈
◎
The realm execution context
• Return execution context.
</li>
			<li class="algo">
`~module~map$enV
⇒
~RET %現~文書 の`~module~map$doc
◎
The module map
• Return the module map of window's associated Document.
</li>
			<li class="algo">
`~API用~基底~URL$enV
⇒
~RET %現~文書 の現在の`基底~URL$doc
◎
The API base URL
• Return the current base URL of window's associated Document.
</li>
			<li class="algo">
`生成元$enV
⇒
~RET %現~文書 の`生成元$doc
◎
The origin
• Return the origin of window's associated Document.
</li>
			<li class="algo">
`施策~容器$enV
⇒
~RET %現~文書 の`施策~容器$doc
◎
The policy container
• Return the policy container of window's associated Document.
</li>
			<li class="algo">
`非同一-生成元~能力は隔離されるか？$enV
⇒
~RET ~IS［
%~realm の`~agent~cluster$の`非同一-生成元~隔離~mode$agC ~EQ `concrete$l
］~AND［
%現~文書 には `cross-origin-isolated$l 特能の`利用は許容されて$いる
］
◎
The cross-origin isolated capability
• Return true if both of the following hold, and false otherwise:
•• realm's agent cluster's cross-origin-isolation mode is "concrete", and
•• window's associated Document is allowed to use the "cross-origin-isolated" feature.
</li>
			<li class="algo">
`時刻~起点$enV
⇒
~RET %現~文書 の`~load計時~報$docの`~navi開始~時刻$
◎
The time origin
• Return window's associated Document's load timing info's navigation start time.
</li>
		</ul>
	</li>
	<li>
<p>
~IF［
%予約-済み環境 ~NEQ ~NULL
］：
◎
If reservedEnvironment is non-null, then:
</p>
		<ol>
			<li>
%設定群~obj の
⇒＃
`~ID$enV ~SET %予約-済み環境 の`~ID$enV,
`~target閲覧~文脈$enV ~SET %予約-済み環境 の`~target閲覧~文脈$enV,
`作動中な~sw$enV ~SET %予約-済み環境 の`作動中な~sw$enV
◎
Set settings object's id to reservedEnvironment's id, target browsing context to reservedEnvironment's target browsing context, and active service worker to reservedEnvironment's active service worker.
</li>
			<li>
<p>
%予約-済み環境 の`~ID$enV ~SET 空~文字列
◎
Set reservedEnvironment's id to the empty string.
</p>

<p class="note">注記：
この時点から， %予約-済み環境 の~ID（ `identity^en ）は %設定群~obj に全部的に転送されたものと見なされ、
%予約-済み環境 は`環境$の`~ID$enVにより探索-可能にならなくなる。
◎
The identity of the reserved environment is considered to be fully transferred to the created environment settings object. The reserved environment is not searchable by the environment’s id from this point on.
</p>
 			</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%設定群~obj の
⇒＃
`~ID$enV ~SET 新たな一意かつ不透明な文字列,
`~target閲覧~文脈$enV ~SET ~NULL,
`作動中な~sw$enV ~SET ~NULL
◎
Otherwise, set settings object's id to a new unique opaque string, settings object's target browsing context to null, and settings object's active service worker to null.
</li>
	<li>
%設定群~obj の
⇒＃
`作成時の~URL$enV ~SET %作成時の~URL,
`~top-level作成時の~URL$enV ~SET %~top-level作成時の~URL,
`~top-level生成元$enV ~SET %~top-level生成元
◎
Set settings object's creation URL to creationURL, settings object's top-level creation URL to topLevelCreationURL, and settings object's top-level origin to topLevelOrigin.
</li>
	<li>
%~realm の `HostDefined^sl ~field ~SET %設定群~obj
◎
Set realm's [[HostDefined]] field to settings object.
</li>
	<li>
<p>
~RET %設定群~obj
</p>

<p class="trans-note">【
この段は、
この訳による追加
— 他所において，この %設定群~obj を参照している箇所があるので。
】</p>
	</li>
</ol>
</div>

				</section>
			</section>
			<section id="the-windowproxy-exotic-object">
<h4 title="The WindowProxy exotic object">7.2.3. `WindowProxy^I ~exotic~obj</h4>

<p class="trans-note">【
この節を成す内容は、
`別~page＠~HTMLWPROXY#the-windowproxy-exotic-object$にて。
】</p>

			</section>
			<section id="the-location-interface">
<h4 title="The Location interface">7.2.4. `Location^I ~interface</h4>

<p>
各 `~window$には、
その作成-時に，新たな `Location$I ~objが結付けられる。
【！＊ unique instance of 〜 allocated】
</p>

<p class="trans-note">【
以下，ここでは、
この節を成す内容のうち，~APIに関する部分のみ述べる。
他の内容は、
`別~page＠~HTMLWPROXY#the-location-interface$にて。
】</p>

<dl class="domintro">
	<dt>%document.`location$m0 [ = %value ]</dt>
	<dt>%window.`location$m [ = %value ]</dt>
	<dd>
現在の~pageの所在を伴う `Location$I ~objを返す。
◎
Returns a Location object with the current page's location.
</dd>
	<dd>
設定して，別の~pageへ~navigateできる。
◎
Can be set, to navigate to another page.
</dd>
</dl>

<div class="algo">
<p>
`Document$I の
`location@m0
取得子~手続きは
◎
The Document object's location getter steps are＼
</p>
<ol>
	<li>
~IF［
コレは`全部的に作動中$である
］
⇒
~RET コレに`関連な大域~obj$の `Location$I ~obj
◎
to return this's relevant global object's Location object, if this is fully active,＼
</li>
	<li>
~RET ~NULL
◎
and null otherwise.
</li>
</ol>
</div>

<div class="algo">
`Window$I の
`location@m
取得子~手続きは
⇒
~RET コレの `Location$I ~obj
◎
The Window object's location getter steps are to return this's Location object.
</div>

<p>
`Location$I ~objは、［
それに結付けられた`文書$の`~URL$docの表現
］および［
それに結付けられた`~navigable$を［
`~navigate$する／`読込直す＠~HTMLnav#reload$
］ための~method
］を供する。
◎
Location objects provide a representation of the URL of their associated Document, as well as methods for navigating and reloading the associated navigable.
</p>

<pre class="idl">
[Exposed=Window]
interface `Location@I { /* <span class="comment">
ただし、［
`追加的な作成~手続き＠~HTMLWPROXY#the-location-interface$,
`上書きされた内部~method＠~HTMLWPROXY#location-internal-methods$
］も見よ。
◎
but see also additional creation steps and overridden internal methods
</span> */

  [`LegacyUnforgeable$] stringifier attribute USVString `href$m;
  [`LegacyUnforgeable$] readonly attribute USVString `origin$m;
  [`LegacyUnforgeable$] attribute USVString `protocol$m;
  [`LegacyUnforgeable$] attribute USVString `host$m;
  [`LegacyUnforgeable$] attribute USVString `hostname$m;
  [`LegacyUnforgeable$] attribute USVString `port$m;
  [`LegacyUnforgeable$] attribute USVString `pathname$m;
  [`LegacyUnforgeable$] attribute USVString `search$m;
  [`LegacyUnforgeable$] attribute USVString `hash$m;

  [`LegacyUnforgeable$] undefined `assign$m(USVString %url);
  [`LegacyUnforgeable$] undefined `replace$m(USVString %url);
  [`LegacyUnforgeable$] undefined `reload$m();

  [`LegacyUnforgeable$, SameObject] readonly attribute `DOMStringList$I `ancestorOrigins$m;
};
</pre>

<dl class="domintro">
	<dt>%location.`toString()^m</dt>
	<dt>%location.`href$m</dt>
	<dd>
`~URL$Locを返す。
◎
Returns the Location object's URL.
</dd>
	<dd>
設定して，所与の~URLへ~navigateできる。
◎
Can be set, to navigate to the given URL.
</dd>

	<dt>%location.`origin$m</dt>
	<dd>
`~URL$Locの生成元を返す。
◎
Returns the Location object's URL's origin.
</dd>

	<dt>%location.`protocol$m</dt>
	<dd>
`~URL$Locの~schemeを返す。
◎
Returns the Location object's URL's scheme.
</dd>
	<dd>
設定して，`~URL$Locの~schemeだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed scheme.
</dd>

	<dt>%location.`host$m</dt>
	<dd>
`~URL$Locの［
~host,
~port（~scheme用の`既定の~port$urlと異なるならば）
］を返す。
◎
Returns the Location object's URL's host and port (if different from the default port for the scheme).
</dd>
	<dd>
設定して，`~URL$Locの
~host, ~port
だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host and port.
</dd>

	<dt>%location.`hostname$m</dt>
	<dd>
`~URL$Locの~hostを返す。
◎
Returns the Location object's URL's host.
</dd>
	<dd>
設定して，`~URL$Locの~hostだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host.
</dd>

	<dt>%location.`port$m</dt>
	<dd>
`~URL$Locの~port を返す。
◎
Returns the Location object's URL's port.
</dd>
	<dd>
設定して，`~URL$Locの~portだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed port.
</dd>

	<dt>%location.`pathname$m</dt>
	<dd>
`~URL$Locの~path を返す。
◎
Returns the Location object's URL's path.
</dd>
	<dd>
設定して，`~URL$Locの~pathだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed path.
</dd>

	<dt>%location.`search$m</dt>
	<dd>
`~URL$Locの~queryを返す
（空でないならば 先頭の `?^l も含む）。
◎
Returns the Location object's URL's query (includes leading "?" if non-empty).
</dd>
	<dd>
設定して，`~URL$Locの~query（先頭の `?^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed query (ignores leading "?").
</dd>

	<dt>%location.`hash$m</dt>
	<dd>
`~URL$Locの素片を返す（空でないならば 先頭の `#^l を含む）。
◎
Returns the Location object's URL's fragment (includes leading "#" if non-empty).
</dd>
	<dd>
設定して，`~URL$Locの素片（先頭の `#^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").
</dd>

	<dt>%location.`assign(url)$m</dt>
	<dd>
%url へ~navigateする。
◎
Navigates to the given URL.
</dd>

	<dt>%location.`replace(url)$m</dt>
	<dd>
~session履歴から現在の~pageを除去した上で，所与の %url へ~navigateする。
◎
Removes the current page from the session history and navigates to the given URL.
</dd>

	<dt>%location.`reload()$m</dt>
	<dd>
現在の~pageを読込直す。
◎
Reloads the current page.
</dd>

	<dt>%location.`ancestorOrigins$m</dt>
	<dd>
`DOMStringList$I ~objを返す
— それは、
`先祖~navigable群$を成す各`~navigable$にて`作動中な文書$navの生成元からなる。
◎
Returns a DOMStringList object listing the origins of the ancestor navigables' active documents.
</dd>
</dl>

<p>
各 `Location$I ~obj %L には、
次が定義される：
◎
↓</p>

<dl class="def-list">
	<dt>`関連な文書@Loc</dt>
	<dd>
%L に`関連な大域~obj$に`対応する閲覧~文脈$ %B に応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ %B にて`作動中な文書$bc
◎
A Location object has an associated relevant Document, which is its relevant global object's browsing context's active document, if this Location object's relevant global object's browsing context is non-null, and null otherwise.
</dd>

	<dt>`~URL@Loc</dt>
	<dd>
%L に`関連な文書$Loc %文書 に応じて
⇒＃
~NULL ならば `~about_blank$sc ／
~ELSE_ %文書 の`~URL$doc
◎
A Location object has an associated url, which is this Location object's relevant Document's URL, if this Location object's relevant Document is non-null, and about:blank otherwise.
</dd>

	<dt>`先祖~生成元~list@</dt>
	<dd class="algo">
<p>
%L の作成-時に、［
次の手続きの結果で与えられる文字列の~list
］が結付けられた `DOMStringList$I ~objに設定するモノトスル：
◎
A Location object has an associated ancestor origins list. When a Location object is created, its ancestor origins list must be set to a DOMStringList object whose associated list is the list of strings that the following steps would produce:
</p>
		<ol>
			<li>
%出力 ~LET 新たな`~list$
◎
Let output be a new list of strings.
</li>
			<li>
%現在の文書 ~LET %L に`関連な文書$Loc
◎
Let current be the Location object's relevant Document.
</li>
			<li>
<p>
~WHILE［
%現在の文書 の`容器~文書$doc ~NEQ ~NULL
］
◎
While current's container document is non-null:
</p>
				<ol>
					<li>
%現在の文書 ~SET %現在の文書 の`容器~文書$doc
◎
Set current to current's container document.
</li>
					<li>
%出力 に次の結果を`付加する$
⇒
`生成元を直列化する$( %現在の文書 の`生成元$doc )
◎
Append the serialization of current's origin to output.
</li>
				</ol>
			</li>
			<li>
~RET %出力
◎
Return output.
</li>
		</ol>
	</dd>
	<dd class="trans-note">【
この仕様の中では、
`ancestorOrigins$m のみから利用される。
~swからも利用されている。
】</dd>
</dl>

<div class="algo">
<p>
`~Location~objにより~navigateする@
~algoは、
所与の
( `Location$I ~obj %L,
`~URL$ %~URL,
`NavigationHistoryBehavior$I %履歴~取扱い （省略時は `auto$hH ） )
に対し：
◎
To Location-object navigate a Location object location to a URL url, optionally given a NavigationHistoryBehavior historyHandling (default "auto"):
</p>
<ol>
	<li>
%~navigable ~LET %L に`関連な大域~obj$に`対応する~navigable$
◎
Let navigable be location's relevant global object's navigable.
</li>
	<li>
%~source文書 ~LET `現任な大域~obj$に`結付けられた文書$
◎
Let sourceDocument be the incumbent global object's associated Document.
</li>
	<li>
~IF［
%L に`関連な文書$Locは まだ`完全に読込まれ$ていない
］~AND［
`現任な大域~obj$は`一過な作動化を有して$いない
］
⇒
%履歴~取扱い ~SET `replace$hH
◎
If location's relevant Document is not yet completely loaded, and the incumbent global object does not have transient activation, then set historyHandling to "replace".
</li>
	<li>
`~navigableを~URLへ~navigateする$( %~navigable, %~URL, %~source文書 )
— 次も与える下で
⇒＃
`例外を可能化するか^i ~SET ~T,
`履歴~取扱い^i ~SET %履歴~取扱い
◎
Navigate navigable to url using sourceDocument, with exceptionsEnabled set to true and historyHandling set to historyHandling.
</li>
</ol>
</div>

<div class="algo">
<p>
`Location$I ~obj %L の
`生成元~domainを検査する@
~algoは：
</p>
<ol>
	<li>
%文書 ~LET %L に`関連な文書$Loc
</li>
	<li>
~IF［
%文書 ~NEQ ~NULL
］~AND［
( %文書 の`生成元$doc, `入口~設定群~obj$の`生成元$enV )
は`同じ生成元~domain$でない
］
⇒
~THROW `SecurityError$E
<!-- 
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException. 
／
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

If document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

-->
</li>
</ol>

<p class="trans-note">【
この手続きは、
以下を簡潔に記すためにこの訳に導入している。
】</p>
</div>

<p>
`href@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The href getter steps are:
</p>
		<ol>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET `~URLを直列化する$( コレが指す`~URL$Loc )
◎
Return this's url, serialized.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The href setter steps are:
</p>
		<ol>
			<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
			<li>
%~URL ~LET `~URLを符号化法の下で相対的に構文解析する$( 所与の値, `入口~設定群~obj$ )
◎
Let url be the result of encoding-parsing a URL given the given value, relative to the entry settings object.
</li>
			<li>
~IF［
%~URL ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If url is failure, then throw a "SyntaxError" DOMException.
s</li>
			<li>
`~Location~objにより~navigateする$( コレ, %~URL )
◎
Location-object navigate this to url.
</li>
		</ol>

<p class="note">注記：
`href$m 設定子に対しては、
意図的に~security検査は行われない。
◎
The href setter intentionally has no security check.
</p>
	</li>
</ul>

<div class="algo">
<p>
`origin@m
取得子~手続きは：
◎
The origin getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET `生成元を直列化する$( コレが指す`~URL$Locの`生成元$url )
◎
Return the serialization of this's url's origin.
</li>
</ol>
</div>

<p>
`protocol@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The protocol getter steps are:
</p>
		<ol>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET 次を順に連結した結果
⇒＃
コレが指す`~URL$Locの`~scheme$url,
`:^l
◎
Return this's url's scheme, followed by ":".
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The protocol setter steps are:
</p>
		<ol>
			<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
			<li>
%~protocol文字列 ~LET 次を順に連結した結果
⇒＃
所与の値,
`:^l
◎
↓</li>
			<li>
<p>
%失敗かも ~LET
`~API用に~URL構文解析する$( %~protocol文字列, %複製~URL, `~scheme開始$uST )
◎
Let possibleFailure be the result of basic URL parsing the given value, followed by ":", with copyURL as url and scheme start state as state override.
</p>

<p class="note">注記：
~URL構文解析器は，連続する~colonを無視するので、
値に `https:^l を与えても
（あるいは `https::::^l でさえ），
`https^l を与えるのと同じことになる。
◎
Because the URL parser ignores multiple consecutive colons, providing a value of "https:" (or even "https::::") is the same as providing a value of "https".
</p>
			</li>
			<li>
~IF［
%失敗かも ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If possibleFailure is failure, then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%複製~URL の `~scheme$urlは`~HTTP_S~scheme$である
］
⇒
~RET
◎
If copyURL's scheme is not an HTTP(S) scheme, then terminate these steps.
</li>
			<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
		</ol>
	</li>
</ul>

<p>
`host@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The host getter steps are:
</p>
		<ol>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%~URL ~LET コレが指す`~URL$Loc
◎
Let url be this's url.
</li>
			<li>
~IF［
%~URL の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If url's host is null, return the empty string.
</li>
			<li>
%~host文字列 ~LET `~hostを直列化する$( %~URL の`~host$url )
◎
↓</li>
			<li>
~IF［
%~URL の`~port$url ~EQ ~NULL
］
⇒
~RET %~host文字列
◎
If url's port is null, return url's host, serialized.
</li>
			<li>
~RET 次を順に連結した結果
⇒＃
%~host文字列,
`:^l,
`整数を直列化する$( %~URL の`~port$url )
◎
Return url's host, serialized, followed by ":" and url's port, serialized.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The host setter steps are:
</p>
		<ol>
			<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
			<li>
~IF［
%複製~URL は`不透明な~path$を有する
］
⇒
~RET
◎
If copyURL has an opaque path, then return.
</li>
			<li>
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~host$uST )
◎
Basic URL parse the given value, with copyURL as url and host state as state override.
</li>
			<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
		</ol>
	</li>
</ul>

<p>
`hostname@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The hostname getter steps are:
</p>
		<ol>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
コレが指す`~URL$Locの
`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this's url's host is null, return the empty string.
</li>
			<li>
~RET `~hostを直列化する$( コレが指す`~URL$Locの`~host$url )
◎
Return this's url's host, serialized.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The hostname setter steps are:
</p>
		<ol>
			<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
			<li>
~IF［
%複製~URL は`不透明な~path$を有する
］
⇒
~RET
◎
If copyURL has an opaque path, then return.
</li>
			<li>
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~hostname$uST )
◎
Basic URL parse the given value, with copyURL as url and hostname state as state override.
</li>
			<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
		</ol>
	</li>
</ul>

<p>
`port@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The port getter steps are:
</p>
		<ol>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
コレが指す`~URL$Locの`~port$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this's url's port is null, return the empty string.
</li>
			<li>
~RET `整数を直列化する$( コレが指す`~URL$Locの`~port$url )
◎
Return this's url's port, serialized.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The port setter steps are:
</p>
		<ol>
			<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
			<li>
~IF［
%複製~URL は `~username／~password／~portを有し得ない$
］
⇒
~RET
◎
If copyURL cannot have a username/password/port, then return.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~port$url ~SET ~NULL
◎
If the given value is the empty string, then set copyURL's port to null.
</li>
			<li>
~ELSE
⇒
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~port$uST )
◎
Otherwise, basic URL parse the given value, with copyURL as url and port state as state override.
</li>
			<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
		</ol>
	</li>
</ul>

<p>
`pathname@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The pathname getter steps are:
</p>
		<ol>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET `~URL~pathを直列化する$( コレが指す`~URL$Loc )
◎
Return the result of URL path serializing this Location object's url.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The pathname setter steps are:
</p>
		<ol>
			<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
			<li>
~IF［
%複製~URL は`不透明な~path$を有する
］
⇒
~RET
◎
If copyURL has an opaque path, then return.
</li>
			<li>
%複製~URL の`~path$url ~SET 空~list
◎
Set copyURL's path to the empty list.
</li>
			<li>
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~path開始$uST )
◎
Basic URL parse the given value, with copyURL as url and path start state as state override.
</li>
			<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
		</ol>
	</li>
</ul>

<p>
`search@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The search getter steps are:
</p>
		<ol>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
コレが指す`~URL$Locの`~query$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this's url's query is either null or the empty string, return the empty string.
</li>
			<li>
~RET 次を順に連結した結果
⇒＃
`?^l,
コレが指す`~URL$Locの`~query$url
◎
Return "?", followed by this's url's query.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The search setter steps are:
</p>
		<ol>
			<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~query$url ~SET ~NULL
◎
If the given value is the empty string, set copyURL's query to null.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise, run these substeps:
</p>
				<ol>
					<li>
%入力 ~LET 所与の値
◎
↓</li>
					<li>
~IF［
%入力 の最初の文字 ~EQ `?^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "?" removed, if any.
</li>
					<li>
%複製~URL の`~query$url ~SET 空~文字列
◎
Set copyURL's query to the empty string.
</li>
					<li>
`~API用に~URL構文解析する$( %入力, %複製~URL, `~query$uST, 【コレに】`関連な文書$Locの`符号化法$doc )
◎
Basic URL parse input, with null, the relevant Document's document's character encoding, copyURL as url, and query state as state override.
</li>
				</ol>
			</li>
			<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
		</ol>
	</li>
</ul>

<p>
`hash@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The hash getter steps are:
</p>
		<ol>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
コレが指す`~URL$Locの`素片$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this's url's fragment is either null or the empty string, return the empty string.
</li>
			<li>
~RET 次を順に連結した結果
⇒＃
`#^l,
コレが指す`~URL$Locの`素片$url
◎
Return "#", followed by this's url's fragment.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The hash setter steps are:
</p>
		<ol>
			<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
			<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
			<li>
%入力 ~LET 所与の値
◎
↓</li>
			<li>
~IF［
%入力 の最初の文字 ~EQ `#^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "#" removed, if any.
</li>
			<li>
%複製~URL の`素片$url ~SET 空~文字列
◎
Set copyURL's fragment to the empty string.
</li>
			<li>
`~API用に~URL構文解析する$( %入力, %複製~URL, `素片$uST )
◎
Basic URL parse input, with copyURL as url and fragment state as state override.
</li>
			<li>
<p>
~IF［
%複製~URL の`素片$url ~EQ コレの`~URL$Locの`素片$url
］
⇒
~RET
◎
If copyURL's fragment is this's url's fragment, then return.
</p>

<p class="note">注記：
この脱出措置は、
配備-済みな内容のうち［
~scrollに対し `location.hash^c を`冗長に設定するもの＠https://bugzilla.mozilla.org/show_bug.cgi?id=1733797#c2$
］との互換性に必要yである。
それは、
素片~naviを成す他の仕組み
— `href$m 設定子や `assign()$m など —
には適用されない。
◎
This bailout is necessary for compatibility with deployed content, which redundantly sets location.hash on scroll. It does not apply to other mechanisms of fragment navigation, such as the location.href setter or location.assign().
</p>
			</li>
			<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
		</ol>

<p class="note">注記：
`a$e, `area$e 要素~用の等価な~APIと違って，
`hash$m 設定子は、［
空~文字列を，配備-済みな~scriptと互換にするよう特別に扱う
］ことはない。
◎
Unlike the equivalent API for the a and area elements, the hash setter does not special case the empty string, to remain compatible with deployed scripts.
</p>
	</li>
</ul>

<div class="algo">
<p>
`assign(url)@m
~method手続きは：
◎
The assign(url) method steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%~URL~record ~LET `~URLを符号化法の下で相対的に構文解析する$( %url, `入口~設定群~obj$ )
◎
Let urlRecord be the result of encoding-parsing a URL given url, relative to the entry settings object.
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If urlRecord is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %~URL~record )
◎
Location-object navigate this to urlRecord.
</li>
</ol>
</div>

<div class="algo">
<p>
`replace(url)@m
~method手続きは：
◎
The replace(url) method steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
%~URL~record ~LET `~URLを符号化法の下で相対的に構文解析する$( %url, `入口~設定群~obj$ )
◎
Let urlRecord be the result of encoding-parsing a URL given url, relative to the entry settings object.
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If urlRecord is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %~URL~record, `replace$hH )
◎
Location-object navigate this to urlRecord given "replace".
</li>
</ol>

<p class="note">注記：
`replace()$m ~methodに対しては、
~security検査は意図的に行われない。
◎
The replace() method intentionally has no security check.
</p>
</div>

<div class="algo">
<p>
`reload()@m
~method手続きは：
◎
The reload() method steps are:
</p>
<ol>
	<li>
%文書 ~LET コレに`関連な文書$Loc
◎
Let document be this's relevant Document.
</li>
	<li>
~IF［
%文書 ~EQ ~NULL
］
⇒
~RET
◎
If document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
`~navigableを読込直す$( %文書 の`~node~navigable$ )
◎
Reload document's node navigable.
</li>
</ol>
</div>

<div class="algo">
<p>
`ancestorOrigins@m
取得子~手続きは：
◎
The ancestorOrigins getter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET 空`~list$†
◎
If this's relevant Document is null, then return an empty list.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET コレの`先祖~生成元~list$
◎
Otherwise, return this's ancestor origins list.
</li>
</ol>

<p class="warning">
`ancestorOrigins$m 属性がどう働くかの詳細は、
まだ異論があり，変更され得る。
更なる情報は、
`課題 #1918＠~HTMLissue/1918$ 
を見よ。
◎
The details of how the ancestorOrigins attribute works are still controversial and might change. See issue #1918 for more information.
</p>

<p class="trans-note">【†
常に同じ~objを返すはずなので（ [SameObject] ）、
実際には，コレに`関連な大域~obj$に`対応する閲覧~文脈$が破棄される時点で，
`先祖~生成元~list$が空にされるのかもしれない。
】</p>
</div>

<hr>

<p class="trans-note">【
以下，この節, およびその各 下位節の内容は、
`別~page＠~HTMLWPROXY#the-location-interface$にて。
】</p>

			</section>
			<section id="the-history-interface">
<h4 title="The History interface">7.2.5. `History^I ~interface</h4>

<pre class="idl">
enum `ScrollRestoration@I { `auto$l, `manual$l };

[Exposed=Window]
interface `History@I {
  readonly attribute unsigned long `length$m0;
  attribute `ScrollRestoration$I `scrollRestoration$m;
  readonly attribute any `state$m;
  undefined `go$m(optional long %delta = 0);
  undefined `back$m();
  undefined `forward$m();
  undefined `pushState$m(any %data, DOMString %unused, optional USVString? %url = null);
  undefined `replaceState$m(any %data, DOMString %unused, optional USVString? %url = null);
};
</pre>

<dl class="domintro">
	<dt>`history$m.`length$m0</dt>
	<dd>
現在の`辿可能な~navigable$用の総合的な`~session履歴~entry群$navの~size【！the number of】を返す。
◎
Returns the number of overall session history entries for the current traversable navigable.
</dd>

	<dt>`history$m.`scrollRestoration$m</dt>
	<dd>
`作動中な~session履歴~entry$navの`~scroll復旧~mode$shEを返す。
◎
Returns the scroll restoration mode of the active session history entry.
</dd>

	<dt>`history$m.`scrollRestoration$m = %value</dt>
	<dd>
`作動中な~session履歴~entry$navの`~scroll復旧~mode$shEを
%value に設定する。
◎
Set the scroll restoration mode of the active session history entry to value.
</dd>

	<dt>`history$m.`state$m</dt>
	<dd>
`作動中な~session履歴~entry$navの`古典~履歴~API用の状態$shEを~JS値に逆直列化した結果を返す。
◎
Returns the classic history API state of the active session history entry, deserialized into a JavaScript value.
</dd>

	<dt>`history$m.`go()$m</dt>
	<dd>
現在の~pageを読込直す。
◎
Reloads the current page.
</dd>

	<dt>`history$m.`go(delta)$m</dt>
	<dd>
現在の`辿可能な~navigable$用の総合的な`~session履歴~entry群$navが成す~listを指定された段~数だけ［
後へ戻る／前へ進む
］。
◎
Goes back or forward the specified number of steps in the overall session history entries list for the current traversable navigable.
</dd>
	<dd>
%delta ~EQ 0 の場合、
現在の~pageを読込直すことになる。
◎
A zero delta will reload the current page.
</dd>
	<dd>
%delta が範囲~外を指す場合は何もしない。
◎
If the delta is out of range, does nothing.
</dd>

	<dt>`history$m.`back()$m</dt>
	<dd>
現在の`辿可能な~navigable$用の総合的な`~session履歴~entry群$navが成す~list内で 1 段だけ後へ戻る。
◎
Goes back one step in the overall session history entries list for the current traversable navigable.
</dd>
	<dd>
前~pageが無い場合、
何もしない。
◎
If there is no previous page, does nothing.
</dd>

	<dt>`history$m.`forward()$m</dt>
	<dd>
現在の`辿可能な~navigable$用の総合的な`~session履歴~entry群$navが成す~listを 1 段だけ前へ進む。
◎
Goes forward one step in the overall session history entries list for the current traversable navigable.
</dd>
	<dd>
次~pageが無い場合、
何もしない。
◎
If there is no next page, does nothing.
</dd>

	<dt>`history$m.`pushState(data, "")$m</dt>
	<dd>
~session履歴の中へ新たな~entryを追加する
— その`古典~履歴~API用の状態$shEには %data の直列化 が設定される。
この~entryの~URLには、
`作動中な~session履歴~entry$navの`~URL$shEが複製された上で利用されることになる。
◎
Adds a new entry into session history with its classic history API state set to a serialization of data. The active history entry's URL will be copied over and used for the new entry's URL.
</dd>
	<dd>
（ 2 個目の~parameterは、
歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、
慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>

	<dt>`history$m.`pushState(data, "", url)$m</dt>
	<dd>
~session履歴の中へ新たな~entryを追加する
— その［
`古典~履歴~API用の状態$shEには %data の直列化,
`~URL$shEには %url
］が設定される。
◎
Adds a new entry into session history with its classic history API state set to a serialization of data, and with its URL set to url.
</dd>
	<dd>
現在の`文書$の~URLを %url で`書直せ$ない場合、
`SecurityError$E 例外が投出されることになる。
◎
If the current Document cannot have its URL rewritten to url, a "SecurityError" DOMException will be thrown.
</dd>
	<dd>
（ 2 個目の~parameterは、
歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、
慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>

	<dt>`history$m.`replaceState(data, "")$m</dt>
	<dd>
`作動中な~session履歴~entry$navの`古典~履歴~API用の状態$shEを
%data の有構造~cloneに更新する。
◎
Updates the classic history API state of the active session history entry to a structured clone of data.
</dd>
	<dd>
（ 2 個目の~parameterは、
歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、
慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>

	<dt>`history$m.`replaceState(data, "", url)$m</dt>
	<dd>
`作動中な~session履歴~entry$navの［
`古典~履歴~API用の状態$shEを %data の有構造~clone,
`~URL$shEを %url
］に更新する。
◎
Updates the classic history API state of the active session history entry to a structured clone of data, and its URL to url.
</dd>
	<dd>
現在の`文書$の~URLを %url で`書直せ$ない場合、
`SecurityError$E 例外が投出されることになる。
◎
If the current Document cannot have its URL rewritten to url, a "SecurityError" DOMException will be thrown.
</dd>
	<dd>
（ 2 個目の~parameterは、
歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、
慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>
</dl>

<p>
各 `文書$は、
`History$I ~objを与える
`履歴~obj@
を有する。
【一対一に対応する。】
◎
A Document has a history object, a History object.
</p>

<div class="algo">
<p>
`history@m
取得子~手続きは
⇒
~RET コレに`結付けられた文書$の`履歴~obj$
◎
The history getter steps are to return this's associated Document's history object.
</p>
</div>

<hr>

<p>
各 `History$I ~objは、
次に挙げるものを有する：
◎
↓</p>
<ul>
	<li>
`状態@hsT
⇒
初期~時は ~NULL とする。
【~IDL `any＠~WEBIDL#idl-any$c 型の値。】
◎
Each History object has state, initially null.
</li>
	<li>
`長さ@hsT
⇒
負でない整数
— 初期~時は 0 とする。
◎
Each History object has a length, a non-negative integer, initially 0.
</li>
	<li>
`~index@hsT
⇒
負でない整数
— 初期~時は 0 とする。
◎
Each History object has an index, a non-negative integer, initially 0.
</li>
</ul>

<p class="note">注記：
`~index$hsT は直に公開されないが、
同期的~naviの間における`長さ$hsTの変化から推定され得る。
事実、
長さは，そのために利用される。
◎
Although the index is not directly exposed, it can be inferred from changes to the length during synchronous navigations. In fact, that is what it's used for.
</p>

<div class="algo">
<p>
`length@m0
取得子~手続きは：
◎
The length getter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な大域~obj$に`結付けられた文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's relevant global object's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET コレの`長さ$hsT
◎
Return this's length.
</li>
</ol>
</div>

<p>
`scrollRestoration@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The scrollRestoration getter steps are:
</p>
		<ol>
			<li>
~IF［
コレに`関連な大域~obj$に`結付けられた文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's relevant global object's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET コレに`関連な大域~obj$に`対応する~navigable$にて`作動中な~session履歴~entry$navの`~scroll復旧~mode$shE
◎
Return this's relevant global object's navigable's active session history entry's scroll restoration mode.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The scrollRestoration setter steps are:
</p>
		<ol>
			<li>
~IF［
コレに`関連な大域~obj$に`結付けられた文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's relevant global object's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
			<li>
コレに`関連な大域~obj$に`対応する~navigable$にて`作動中な~session履歴~entry$navの`~scroll復旧~mode$shE ~SET 所与の値
◎
Set this's relevant global object's navigable's active session history entry's scroll restoration mode to the given value.
</li>
		</ol>
	</li>
</ul>

<div class="algo">
<p>
`state@m
取得子~手続きは：
◎
The state getter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な大域~obj$に`結付けられた文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's relevant global object's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET コレの`状態$hsT
◎
Return this's state.
</li>
</ol>
</div>

<div class="algo">
<p>
`go(delta)@m
~method手続きは
⇒
`差分だけ辿る$( コレ, %delta )
◎
The go(delta) method steps are to delta traverse this given delta.
</p>
</div>

<div class="algo">
<p>
`back()@m
~method手続きは
⇒
`差分だけ辿る$( コレ, −1 )
◎
The back() method steps are to delta traverse this given −1.
</p>
</div>

<div class="algo">
<p>
`forward()@m
~method手続きは
⇒
`差分だけ辿る$( コレ, 1 )
◎
The forward() method steps are to delta traverse this given +1.
</p>
</div>

<div class="algo">
<p>
`差分だけ辿る@
~algoは、
所与の
( `History$I ~obj %履歴, 整数 %差分 )
に対し：
◎
To delta traverse a History object history given an integer delta:
</p>
<ol>
	<li>
%文書 ~LET %履歴 に`関連な大域~obj$に`結付けられた文書$
◎
Let document be history's relevant global object's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
%差分 ~EQ 0
］
⇒＃
`~navigableを読込直す$( %文書 の`~node~navigable$ )；
~RET
◎
If delta is 0, then reload document's node navigable, and return.
</li>
	<li>
`履歴を差分だけ辿る$( %文書 の`~node~navigable$の`辿可能な~navigable$nav, %差分, %文書 )
◎
Traverse the history by a delta given document's node navigable's traversable navigable, delta, and with sourceDocument set to document.
</li>
</ol>
</div>

<div class="algo">
<p>
`pushState(data, unused, url)@m
~method手続きは
⇒
`履歴に状態を~pushするか履歴の状態を置換する$( コレ, %data, %url, `push$hH )
◎
The pushState(data, unused, url) method steps are to run the shared history push/replace state steps given this, data, url, and "push".
</p>
</div>

<div class="algo">
<p>
`replaceState(data, unused, url)@m
~method手続きは
⇒
`履歴に状態を~pushするか履歴の状態を置換する$( コレ, %data, %url, `replace$hH )
◎
The replaceState(data, unused, url) method steps are to run the shared history push/replace state steps given this, data, url, and "replace".
</p>
</div>

<div class="algo">
<p>
`履歴に状態を~pushするか履歴の状態を置換する@
~algoは、
所与の
⇒＃
`History$I ~obj %履歴,
値 %~data,
`~scalar値~文字列$または ~NULL %~URL,
`履歴~取扱いの挙動$ %履歴~取扱い
◎終
に対し：
◎
The shared history push/replace state steps, given a History history, a value data, a scalar value string-or-null url, and a history handling behavior historyHandling, are:
</p>
<ol>
	<li>
%文書 ~LET %履歴 に`関連な大域~obj$に`結付けられた文書$
◎
Let document be history's relevant global object's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
<p>
任意選択で
⇒
~THROW `SecurityError$E
◎
Optionally, throw a "SecurityError" DOMException.＼
</p>

<p>
（例えば~UAは、
この手続きを呼出す~methodが［
~timer ／
明瞭な利用者-動作に呼応して誘発されたものではない~event~listener
］から~callされた場合や, 立て続けに呼出された場合には，許容しないかもしれない。）
◎
(For example, the user agent might disallow calls to these methods that are invoked on a timer, or from event listeners that are not triggered in response to a clear user action, or that are invoked in rapid succession.)
</p>
	</li>
	<li>
%直列形の~data ~LET `StructuredSerializeForStorage$jA( %~data )
— 例外は投出し直す
◎
Let serializedData be StructuredSerializeForStorage(data). Rethrow any exceptions.
</li>
	<li>
%新たな~URL ~LET %文書 の`~URL$doc
◎
Let newURL be document's URL.
</li>
	<li>
<p>
~IF［
%~URL ~NIN { ~NULL, 空~文字列 }
］：
◎
If url is not null or the empty string, then:
</p>
		<ol>
			<li>
%新たな~URL ~SET `~URLを符号化法の下で相対的に構文解析する$( %~URL, %履歴 に`関連な設定群~obj$ )
◎
Set newURL to the result of encoding-parsing a URL given url, relative to the relevant settings object of history.
</li>
			<li>
~IF［
%新たな~URL ~EQ `失敗^i
］
⇒
~THROW `SecurityError$E
◎
If newURL is failure, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
`文書の~URLは書直せるか$( %文書, %新たな~URL ) ~EQ ~F
］
⇒
~THROW `SecurityError$E
◎
If document cannot have its URL rewritten to newURL, then throw a "SecurityError" DOMException.
</li>
		</ol>

<p class="note">注記：
ここで空~文字列の事例を特別に外しているのは、
歴史的な~~理由による
— そのため、
<code>location.`href$m = ""</code>
と
<code>history.`pushState$m(null, "", "")</code>
などの~codeを比較したとき，結果の~URLは相違することになる
（前者は，空~文字列に対し~URL構文解析を遂行する一方で、
後者は，それを素通りするので）。
◎
The special case for the empty string here is historical, and leads to different resulting URLs when comparing code such as location.href = "" (which performs URL parsing on the empty string) versus history.pushState(null, "", "") (which bypasses it).
</p>
	</li>
	<li>
%~navi ~LET %履歴 に`関連な大域~obj$の`~navi~API$
◎
Let navigation be history's relevant global object's navigation API.
</li>
	<li>
%継続するか ~LET `~push／置換-／再読込み用の~navigate_ev~eventを発火する$( %~navi )
— 次も与える下で
⇒＃
`~navi種別^i ~SET %履歴~取扱い,
`同じ文書か^i ~SET ~T,
`行先~URL^i ~SET %新たな~URL,
`古典~履歴~API用の状態^i ~SET %直列形の~data
◎
Let continue be the result of firing a push/replace/reload navigate event at navigation with navigationType set to historyHandling, isSameDocument set to true, destinationURL set to newURL, and classicHistoryAPIState set to serializedData.
</li>
	<li>
~IF［
%継続するか ~EQ ~F
］
⇒
~RET
◎
If continue is false, then return.
</li>
	<li>
`~URLと履歴を更新する$( %文書, %新たな~URL )
— 次も与える下で
⇒＃
`直列形の~data^i ~SET %直列形の~data
`履歴~取扱い^i ~SET %履歴~取扱い
◎
Run the URL and history update steps given document and newURL, with serializedData set to serializedData and historyHandling set to historyHandling.
</li>
</ol>
</div>

<p>
~UAは、
~pageごとに，その~session履歴に追加される状態~objの個数を制限してもヨイ。
~pageが この`実装定義$な上限に抵触した場合、
~UAは，新たな~entryが追加された後に，［
当の`文書$用の~session履歴を成す最初の~entry
］の直後の~entryを除去するモノトスル
（したがって，状態~履歴は、
先に入れたものから抹消されるように動作する（ FIFO ）一方で、
~naviに対しては，先に入れたものが最後に残るように動作する（ LIFO ））。
◎
User agents may limit the number of state objects added to the session history per page. If a page hits the implementation-defined limit, user agents must remove the entry immediately after the first entry for that Document object in the session history after having added the new entry. (Thus the state history acts as a FIFO buffer for eviction, but as a LIFO buffer for navigation.)
</p>

<div class="algo">
<p>
`文書の~URLは書直せるか@
どうかは、
所与の
( `文書$ %文書, `~URL$ %~target~URL )
に対し，次の~algoに従う
（結果が ~T ならば %~target~URL で “書直せる” ）：
◎
A Document document can have its URL rewritten to a URL targetURL if the following algorithm returns true:
</p>
<ol>
	<li>
%文書~URL ~LET %文書 の`~URL$doc
◎
Let documentURL be document's URL.
</li>
	<li>
<p>
~IF［［
%~target~URL, %文書~URL
］は、
次に挙げる ある成分において相違する
］…
⇒＃
`~scheme$url,
`~username$url,
`~password$url,
`~host$url,
`~port$url
</p>

<p>
…ならば
⇒
~RET ~F
</p>
◎
If targetURL and documentURL differ in their scheme, username, password, host, or port components, then return false.
</li>
	<li>
<p>
%~target~URL の`~scheme$urlに応じて：
◎
↓</p>
		<ul class="switch">
			<li>
<p>
`~HTTP_S~scheme$
⇒
~RET ~T
◎
If targetURL's scheme is an HTTP(S) scheme, then return true.
</p>

<p class="note">注記：
［
`https:＠~HTTPinfra#https.uri$sc, `http:＠~HTTPinfra#http.uri$sc
］~URL用には、
【！~RFCx/rfc7230#section-2.7.1／~RFCx/rfc7230#section-2.7.2】
［
`~path$url ／ `~query$url ／ `素片$url
］における相違は許容される。
◎
Differences in path, query, and fragment are allowed for http: and https: URLs.
</p>
			</li>
			<li>
<p>
`file^l
⇒
~RET ~IS［［
%~target~URL, %文書~URL
］は、
`~path$url 成分において相違しない
］
◎
If targetURL's scheme is "file", then:
• If targetURL and documentURL differ in their path component, then return false.
• Return true.
</p>

<p class="note">注記：
`file:^sc ~URL用には、［
`~query$url ／ `素片$url
］における相違は許容される。
◎
Differences in query and fragment are allowed for file: URLs.
</p>
			</li>
			<li>
<p>
その他
⇒
~RET ~IS［［
%~target~URL, %文書~URL
］は、［
`~path$url,
`~query$url
］成分において相違しない
］
◎
If targetURL and documentURL differ in their path component or query components, then return false.
</p>

<p class="note">注記：
`素片$urlにおける相違に限り許容される。
◎
Only differences in fragment are allowed for other types of URLs.
◎
↑ Return true.
</p>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="example">
<div>
<table><thead>
<tr><th>%文書~URL
<th>%~target~URL
<th>`文書の~URLは書直せるか$
<tbody>

<tr><td>`https://example.com/home^c
<td>`https://example.com/home#about^c
<td>✅

<tr><td>`https://example.com/home^c
<td>`https://example.com/home?page=shop^c
<td>✅

<tr><td>`https://example.com/home^c
<td>`https://example.com/shop^c
<td>✅

<tr><td>`https://example.com/home^c
<td><code>https://user:pass@example.com/home</code>
<td>❌

<tr><td>`https://example.com/home^c
<td>`http://example.com/home^c
<td>❌

<tr><td>`file:///path/to/x^c
<td>`file:///path/to/x#hash^c
<td>✅

<tr><td>`file:///path/to/x^c
<td>`file:///path/to/x?search^c
<td>✅

<tr><td>`file:///path/to/x^c
<td>`file:///path/to/y^c
<td>❌

<tr><td>`about:blank^c
<td>`about:blank#hash^c
<td>✅

<tr><td>`about:blank^c
<td>`about:blank?search^c
<td>❌

<tr><td>`about:blank^c
<td>`about:srcdoc^c
<td>❌

<tr><td>`data:text/html,foo^c
<td>`data:text/html,foo#hash^c
<td>✅

<tr><td>`data:text/html,foo^c
<td>`data:text/html,foo?search^c
<td>❌

<tr><td>`data:text/html,foo^c
<td>`data:text/html,bar^c
<td>❌

<tr><td>`data:text/html,foo^c
<td>`data:bar^c
<td>❌

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43#hash^c
<td>✅

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43?search^c
<td>❌

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:https://example.com/anything^c
<td>❌

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:path^c
<td>❌
</table>
◎
document's URL 	targetURL 	can have its URL rewritten
https://example.com/home 	https://example.com/home#about 	✅
https://example.com/home 	https://example.com/home?page=shop 	✅
https://example.com/home 	https://example.com/shop 	✅
https://example.com/home 	https://user:pass@example.com/home 	❌
https://example.com/home 	http://example.com/home 	❌
file:///path/to/x 	file:///path/to/x#hash 	✅
file:///path/to/x 	file:///path/to/x?search 	✅
file:///path/to/x 	file:///path/to/y 	❌
about:blank 	about:blank#hash 	✅
about:blank 	about:blank?search 	❌
about:blank 	about:srcdoc 	❌
data:text/html,foo 	data:text/html,foo#hash 	✅
data:text/html,foo 	data:text/html,foo?search 	❌
data:text/html,foo 	data:text/html,bar 	❌
data:text/html,foo 	data:bar 	❌
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43#hash 	✅
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43?search 	❌
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:https://example.com/anything 	❌
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:path 	❌
</div>

<p>
ここでは、
`文書$の`生成元$docは問われないことに注意。
それは、
次に挙げる様な事例では，文書の`~URL$docの`生成元$urlと合致しないこともある
⇒＃
生成元を他から継承した初期 `~about_blank$sc 文書／
~sandbox化された `iframe$e ／
`document.domain＠~ORIGIN#dom-document-domain$c 設定子が利用されたとき
◎
Note how only the URL of the Document matters, and not its origin. They can mismatch in cases like about:blank Documents with inherited origins, in sandboxed iframes, or when the document.domain setter has been used.
</p>
</div>

<div class="example">

<p>
~gameを考える：
利用者は，常に，ある “線” 上のある座標に居て、
線に沿って~navigateでき，特定0の座標に対応する~pageを~bookmarkすれば後でそこへ戻れるとする。
◎
Consider a game where the user can navigate along a line, such that the user is always at some coordinate, and such that the user can bookmark the page corresponding to a particular coordinate, to return to it later.
</p>

<p>
そのような~gameの，位置 x=5 を実装している静的な~pageとして、
次の様なものがあるとする：
◎
A static page implementing the x=5 position in such a game could look like the following:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 5 に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"&gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"&gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
</pre>
<!-- 
<!DOCTYPE HTML>
<!-&45; this is https://example.com/line?x=5 -&45;>
<title>Line Game - 5</title>
<p>You are at coordinate 5 on the line.</p>
<p>
 <a href="?x=6">Advance to 6</a> or
 <a href="?x=4">retreat to 4</a>?
</p>
-->
<p>
そのような~systemにおいて問題になるのは、
利用者が~clickするたびに，~page全体を読込直す必要が生じることである。
次に、
~scriptを利用して同じことをする別の仕方を示す：
◎
The problem with such a system is that each time the user clicks, the whole page has to be reloaded. Here instead is another way of doing it, using script:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 &lt;span id="coord"&gt;5&lt;/span&gt; に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"
   onclick="go(1); return false;"
 &gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"
   onclick="go(-1); return false;"
 &gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
&lt;script&gt;
 var %currentPage = 5; /* <span class="comment"
>~serverからあてがわれる
◎
prefilled by server
</span> */
 function go(%d) {
   setupPage(%currentPage + %d);
   history.pushState(%currentPage, '', '?x=' + %currentPage);
 }
 onpopstate = function(%event) {
   setupPage(%event.state);
 }
 function setupPage(%page) {
   %currentPage = %page;
   document.title = 'Line Game - ' + %currentPage;
   document.getElementById('coord').textContent = %currentPage;
   document.links[0].href = '?x=' + (%currentPage + 1);
   document.links[0].textContent = 'Advance to ' + (%currentPage + 1);
   document.links[1].href = '?x=' + (%currentPage - 1);
   document.links[1].textContent = 'retreat to ' + (%currentPage - 1);
 }
&lt;/script&gt;
</pre>

<!-- 
<!DOCTYPE HTML>
&lt;!-&45; this starts off as https://example.com/line?x=5 &45;-&gt;
<title>Line Game - 5</title>
<p>You are at coordinate <span id="coord">5</span> on the line.</p>
<p>
 <a href="?x=6" onclick="go(1); return false;">Advance to 6</a> or
 <a href="?x=4" onclick="go(-1); return false;">retreat to 4</a>?
</p>
<script>
 var currentPage = 5; // prefilled by server

-->

<p>
これは、
~scriptの~supportを切っている~systemにおいても，依然として先掲の例の様に働くが、
`切っていない^em利用者は，ずっと高速に~navigateできるようになる
— 同じ体験に対し~network~accessはないので。
更には、
~scriptに基づく素朴な~approachによる利用者~体験と違って，~session履歴を［
~bookmarkする／~navigateする
］のも依然として働く。
◎
In systems without script, this still works like the previous example. However, users that do have script support can now navigate much faster, since there is no network access for the same experience. Furthermore, contrary to the experience the user would have with just a naïve script-based approach, bookmarking and navigating the session history still work.
</p>

<p>
上の例において，
`pushState()$m ~methodに対する %data 引数は、［
~serverへ送信されることになる情報と同じになる
］が［
利用者が~navigateするたびに~scriptが~URLを構文解析しなくとも済むような，より簡便な形
］になる。
◎
In the example above, the data argument to the pushState() method is the same information as would be sent to the server, but in a more convenient form, so that the script doesn't have to parse the URL each time the user navigates.
</p>
</div>

<div class="example">
<p>
ほとんどの~appは、
自身の履歴~entryすべてに対し，それらの`~scroll復旧~mode$用に同じ値を利用したいと求める。
そのためには、
アリな限り早く `scrollRestoration$m 属性を設定して
（例えば、
文書の `head$e 要素~内の `script$e 要素で），［
履歴~sessionに追加された~entryが，欲される~scroll復旧~modeを取得する
］ことを確保することにより，達成できる。
◎
Most applications want to use the same scroll restoration mode value for all of their history entries. To achieve this they can set the scrollRestoration attribute as soon as possible (e.g., in the first script element in the document's head element) to ensure that any entry added to the history session gets the desired scroll restoration mode.
</p>

<pre class="lang-html">
&lt;head&gt;
  &lt;script&gt;
       if ('scrollRestoration' in history)
            history.scrollRestoration = 'manual';
  &lt;/script&gt;
&lt;/head&gt;
</pre>
</div>

			</section>
			<section id="navigation-api">
<h4 title="The navigation API">7.2.6. ~navi~API</h4>

<p class="trans-note">【
この節を成す内容は、
`別~page＠~HTMLnavAPI$にて。
】</p>

			</section>
			<section id="nav-traversal-event-interfaces">
<h4 title="Event interfaces">7.2.7. ~event~interface</h4>

<p class="note">
`NavigateEvent$I ~interfaceは、
その複階性に因り，
`自前の専用な節＠~HTMLnavAPI#the-navigate-event$にて与えられる。
◎
The NavigateEvent interface has its own dedicated section, due to its complexity.
</p>

				<section id="the-navigationcurrententrychangeevent-interface">
<h5 title="The NavigationCurrentEntryChangeEvent interface">7.2.7.1. `NavigationCurrentEntryChangeEvent^I ~interface</h5>

<p class="trans-note">【
この節を成す内容は、
`別~page＠~HTMLnavAPI#the-navigationcurrententrychangeevent-interface$にて。
】</p>

				</section>
				<section id="the-popstateevent-interface">
<h5 title="The PopStateEvent interface">7.2.7.2. `PopStateEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `PopStateEvent@I : `Event$I {
  constructor(DOMString %type, optional `PopStateEventInit$I %eventInitDict = {});

  readonly attribute any `state$m0;
  readonly attribute boolean `hasUAVisualTransition$m;
};

dictionary `PopStateEventInit@I : `EventInit$I {
  any `state@mb = null;
  boolean `hasUAVisualTransition@mb = false;
};
</pre>

<dl class="domintro">
	<dt>%event.`state$m0</dt>
	<dd>
`pushState()$m ／ `replaceState()$m
に供された情報の複製を返す。
◎
Returns a copy of the information that was provided to pushState() or replaceState().
</dd>

	<dt>%event.`hasUAVisualTransition$m</dt>
	<dd>
~UAが［
この~eventを配送する前に，この~navi用に視覚的な遷移を遂行した
【おそらく， `CSSVIEWTRANSITIONS$r を指す】
］ならば ~T を返す。
~T の場合、
作者は，［
~navi後の状態と同期的に~DOMを更新する
］ならば最良な利用者~体験を与えることになる。
◎
Returns true if the user agent performed a visual transition for this navigation before dispatching this event. If true, the best user experience will be given if the author synchronously updates the DOM to the post-navigation state.
</dd>
</dl>

<dl class="idl-def">
	<dt>
`state@m0
◎
The state attribute＼
</dt>
	<dd>
取得子は、
初期化-時の値を返すモノトスル。
◎
must return the value it was initialized to.＼
</dd>
	<dd>
この~event用の文脈~情報を表現する。
表現される状態が`文書$の初期~状態の場合は ~NULL になる。
◎
It represents the context information for the event, or null, if the state represented is the initial state of the Document.
</dd>

	<dt>
`hasUAVisualTransition@m
◎
The hasUAVisualTransition attribute＼
</dt>
	<dd>
取得子は、
初期化-時の値を返すモノトスル。
◎
must return the value it was initialized to.
</dd>
</dl>

				</section>
				<section id="the-hashchangeevent-interface">
<h5 title="The HashChangeEvent interface">7.2.7.3. `HashChangeEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `HashChangeEvent@I : `Event$I {
  constructor(DOMString %type, optional `HashChangeEventInit$I %eventInitDict = {});

  readonly attribute USVString `oldURL$m;
  readonly attribute USVString `newURL$m;
};

dictionary `HashChangeEventInit@I : `EventInit$I {
  USVString oldURL = "";
  USVString newURL = "";
};
</pre>

<dl class="domintro">
	<dt>%event.`oldURL$m</dt>
	<dd>
履歴を辿る直前の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that was previously current.
</dd>
	<dt>%event.`newURL$m</dt>
	<dd>
履歴を辿った直後の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that is now current.
</dd>
</dl>

<dl class="idl-def">
	<dt>
`oldURL@m
◎
The oldURL attribute＼
</dt>
	<dd>
取得子は、
初期化-時の値を返すモノトスル。
◎
must return the value it was initialized to.＼
</dd>
	<dd>
これは、
この~event用の文脈~情報
— 特定的には、
履歴を辿る直前の`~session履歴~entry$の~URL —
を表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed from.
</dd>

	<dt>
`newURL@m
◎
The newURL attribute＼
</dt>
	<dd>
取得子は、
初期化-時の値を返すモノトスル。
◎
must return the value it was initialized to.＼
</dd>
	<dd>
これは、
この~event用の文脈~情報
— 特定的には、
履歴を辿った直後の`~session履歴~entry$の~URL —
を表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed to.
</dd>
</dl>

				</section>
				<section id="the-pageswapevent-interface">
<h5 title="The PageSwapEvent interface">7.2.7.4. `PageSwapEvent^I ~interface</h5>

<p class="trans-note">【
この節を成す内容は、
`別~page＠~HTMLnavAPI#the-pageswapevent-interface$にて。
】</p>

				</section>
				<section id="the-pagerevealevent-interface">
<h5 title="The PageRevealEvent interface">7.2.7.5. `PageRevealEvent^I ~interface</h5>

<p class="trans-note">【
この節を成す内容は、
`別~page＠~HTMLnavAPI#the-pagerevealevent-interface$にて。
】</p>

				</section>
				<section id="the-pagetransitionevent-interface">
<h5 title="The PageTransitionEvent interface">7.2.7.6. `PageTransitionEvent^I ~interface</h5>

<p class="trans-note">【
この節を成す内容は、
`別~page＠~HTMLnavAPI#the-pagetransitionevent-interface$にて。
】</p>

				</section>
				<section id="the-beforeunloadevent-interface">
<h5 title="The BeforeUnloadEvent interface">7.2.7.7. `BeforeUnloadEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `BeforeUnloadEvent@I : `Event$I {
  attribute DOMString `returnValue$m;
};
</pre>

<p class="note">注記：
`BeforeUnloadEvent$I に特有な初期化~methodはない。
◎
There are no BeforeUnloadEvent-specific initialization methods.
</p>

<p>
`BeforeUnloadEvent$I ~interfaceは、
旧来の~interfaceである
— それは、［
~eventを取消すのみならず，
`returnValue$m 属性を空~文字列でない値に設定する
］ことにより，
`~unloadは取消されたか否か検査する$ことを許容する。
作者は `returnValue$m を利用する代わりに `preventDefault()$m ~method, または~eventを取消す他の手段を利用するベキである。
◎
The BeforeUnloadEvent interface is a legacy interface which allows checking if unloading is canceled to be controlled not only by canceling the event, but by setting the returnValue attribute to a value besides the empty string. Authors should use the preventDefault() method, or other means of canceling events, instead of using returnValue.
</p>

<dl class="idl-def">
	<dt>
`returnValue@m
◎
The returnValue attribute＼
</dt>
	<dd>
この属性は、
`~unloadは取消されたか否か検査する$処理nを制御する。
◎
controls the process of checking if unloading is canceled.＼
</dd>
	<dd>
~eventの作成-時には、
この属性は空~文字列に設定するモノトスル。
◎
When the event is created, the attribute must be set to the empty string.＼
</dd>
	<dd>
取得子は、
この属性に最後に設定された値を返すモノトスル。
◎
On getting, it must return the last value it was set to.＼
</dd>
	<dd>
設定子は、
この属性を所与の値に設定するモノトスル。
◎
On setting, the attribute must be set to the new value.
</dd>
	<dd class="note">注記：
この属性が `DOMString^I にされているのは、
もっぱら歴史的な理由による。
空~文字列~以外のどの値も，利用者に確認をとるよう要請するものと扱われる。
◎
This attribute is a DOMString only for historical reasons. Any value besides the empty string will be treated as a request to ask the user for confirmation.
</dd>
</dl>

				</section>
			</section>
			<section id="the-notrestoredreasons-interface">
<h4 title="The NotRestoredReasons interface">7.2.8. `NotRestoredReasons^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `NotRestoredReasonDetails@I {
  readonly attribute DOMString `reason$m;
  [Default] object toJSON();
};

[Exposed=Window]
interface `NotRestoredReasons@I {
  readonly attribute USVString? `src$m;
  readonly attribute DOMString? `id$m;
  readonly attribute DOMString? `name$m0;
  readonly attribute USVString? `url$m;
  readonly attribute FrozenArray&lt;`NotRestoredReasonDetails$I&gt;? `reasons$m;
  readonly attribute FrozenArray&lt;`NotRestoredReasons$I&gt;? `children$m;
  [Default] object toJSON();
};
</pre>

<p class="trans-note">【
以下に現れる “当の文書” は、
これらの~interfaceを実装している~objに`関連な~realm$の`大域~obj$rMに`結付けられた文書$を指す。
】</p>

<dl class="domintro">
	<dt>%notRestoredReasonDetails.`reason$m</dt>
	<dd>
［
当の文書が`~BF~cache$から~serveされるのを防止した事由
］を説明する文字列を返す。
アリな値は、
`事由~文字列$nrrd【！`~BF~cacheを阻んでいる詳細$docの定義】を見よ。
◎
Returns a string that explains the reason that prevented the document from being served from back/forward cache. See the definition of bfcache blocking details for the possible string values.
</dd>

	<dt>%notRestoredReasons.`src$m</dt>
	<dd>
当の文書の`~node~navigable$の`容器$navは［
`iframe$e 要素であって， `src$aF 属性を有する
］ならば，その値を返す。
他の場合は ~NULL を返す。
◎
Returns the src attribute of the document's node navigable's container if it is an iframe element. This can be null if not set or if it is not an iframe element.
</dd>

	<dt>%notRestoredReasons.`id$m</dt>
	<dd>
当の文書の`~node~navigable$の`容器$navは［
`iframe$e 要素であって， `id$a 属性を有する
］ならば、
その値を返す。
他の場合は ~NULL を返す。
◎
Returns the id attribute of the document's node navigable's container if it is an iframe element. This can be null if not set or if it is not an iframe element.
</dd>

	<dt>%notRestoredReasons.`name$m0</dt>
	<dd>
当の文書の`~node~navigable$の`容器$navは［
`iframe$e 要素であって， `name$aF 属性を有する
］ならば、
その値を返す。
他の場合は ~NULL を返す。
◎
Returns the name attribute of the document's node navigable's container if it is an iframe element. This can be null if not set or if it is not an iframe element.
</dd>

	<dt>%notRestoredReasons.`url$m</dt>
	<dd>
当の文書の`~URL$docを返す。
ただし、
当の文書は非同一-生成元な `iframe$e 内にある場合は ~NULL を返す。
これは、
`src$m に加えて報告される
— `iframe$e は元の `src$aF が設定された後に~navigateされることもアリなので。
◎
Returns the document's URL, or null if the document is in a cross-origin iframe. This is reported in addition to src because it is possible iframe navigated since the original src was set.
</dd>

	<dt>%notRestoredReasons.`reasons$m</dt>
	<dd>
当の文書~用の `NotRestoredReasonDetails$I たちが成す配列を返す。
ただし、
当の文書は非同一-生成元な `iframe$e 内にある場合は ~NULL を返す。
◎
Returns an array of NotRestoredReasonDetails for the document. This is null if the document is in a cross-origin iframe.
</dd>

	<dt>%notRestoredReasons.`children$m</dt>
	<dd>
当の文書の子~群~用の `NotRestoredReasons$I たちが成す配列を返す。
ただし、
当の文書は非同一-生成元な `iframe$e 内にある場合は ~NULL を返す。
◎
Returns an array of NotRestoredReasons that are for the document’s children. This is null if the document is in a cross-origin iframe.
</dd>
</dl>

<p>
各 `NotRestoredReasonDetails$I ~objは、
それを
`~backしている構造体@NRRD
を有する
— それは、［
~NULL ／`復旧されない事由の詳細$
］であり，初期~時は~NULLとする。
◎
A NotRestoredReasonDetails object has a backing struct, a not restored reason details or null, initially null.
</p>

<div class="algo">
`reason@m
取得子~手続きは
⇒
~RET コレを`~backしている構造体$NRRDの`事由~文字列$nrrd
◎
The reason getter steps are to return this's backing struct's reason.
</div>

<div class="algo">
<p>
`NotRestoredReasonDetails$I ~objを
`作成する@NRRD
~algoは、
所与の
( `復旧されない事由の詳細$ %~backしている構造体, `~realm$ %~realm )
に対し：
◎
To create a NotRestoredReasonDetails object given a not restored reason details backingStruct and a realm realm:
</p>
<ol>
	<li>
%O ~LET `新たな~obj$( `NotRestoredReasonDetails$I, %~realm )
◎
Let notRestoredReasonDetails be a new NotRestoredReasonDetails object created in realm.
</li>
	<li>
%O を`~backしている構造体$NRRD ~SET %~backしている構造体
◎
Set notRestoredReasonDetails's backing struct to backingStruct.
</li>
	<li>
~RET %O
◎
Return notRestoredReasonDetails.
</li>
</ol>
</div>

<p>
`復旧されない事由の詳細@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A not restored reason details is a struct with the following items:
</p>
<ul>
	<li>
`事由~文字列@nrrd
⇒
ある文字列
— 初期~時は空~文字列とする。
◎
reason, a string, initially empty.
</li>
</ul>

<p>
`事由~文字列$nrrdは、［
当の~pageを`~BF~cache$から復旧することを防止した事由
］を表現する。
この文字列は、
次に挙げるいずれかになる：
◎
The reason is a string that represents the reason that prevented the page from being restored from back/forward cache. The string is one of the following:
</p>

<dl>
	<dt>`fetch@bK</dt>
	<dd>
`~unloadして$いる間に［
当の`文書$により起動された~fetchは、
依然として進行中であったが，取消された
］ので、
当の~pageは［
`~BF~cache$内に格納することもできた状態
］にはなかった。
◎
While unloading, a fetch initiated by this Document was still ongoing and was canceled, so the page was not in a state that could be stored in the back/forward cache.
</dd>

	<dt>`navigation-failure@bK</dt>
	<dd>
［
当の`文書$を作成した元の~naviは，~errorした
］ので、［
結果の~error文書を`~BF~cache$内に格納する
］ことは防止された。
◎
The original navigation that created this Document errored, so storing the resulting error document in the back/forward cache was prevented.
</dd>

	<dt>`parser-aborted@bK</dt>
	<dd>
［
当の`文書$は，その初期~HTML構文解析を完遂し得なくなった
］ので、［
完遂しなかった文書を`~BF~cache$内に格納する
］ことは防止された。
◎
The Document never finished its initial HTML parsing, so storing the unfinished document in the back/forward cache was prevented.
</dd>

	<dt>`websocket@bK</dt>
	<dd>
`~unloadして$いる間に［
ある~openな `WebSocket$I 接続が~shut-downされた
］ので、
当の~pageは［
`~BF~cache$内に格納することもできた状態
］にはなかった。
`WEBSOCKETS$r
◎
While unloading, an open WebSocket connection was shut down, so the page was not in a state that could be stored in the back/forward cache. [WEBSOCKETS]
</dd>

	<dt>`lock@bK</dt>
	<dd>
`~unloadして$いる間に［
保持された`~lock$と`~lock要請$が終了された
］ので、
当の~pageは［
`~BF~cache$内に格納することもできた状態
］にはなかった。
`WEBLOCKS$r
◎
While unloading, held locks and lock requests were terminated, so the page was not in a state that could be stored in the back/forward cache. [WEBLOCKS]
</dd>

	<dt>`masked@bK</dt>
	<dd>
<p>
次のいずれかにより，当の`文書$を`~BF~cache$内に格納できなかった：
</p>
		<ul>
			<li>
当の`文書$内の非同一-生成元な子 `iframe$e により防止された。
</li>
			<li>
~UAに特有な事由
— ただし、
~UAが［
いずれかの`~UAに特有な阻んでいる事由$を利用する
］ことを選ばなかった場合に限る。
</li>
		</ul>
◎
This Document has children that are in a cross-origin iframe, and they prevented back/forward cache; or this Document could not be back/forward cached for user agent-specific reasons, and the user agent has chosen not to use one of the more specific reasons from the list of user-agent specific blocking reasons.
</dd>
</dl>

<p>
上に挙げたものに加えて、
~UAは，
`~UAに特有な阻んでいる事由@
により［
当の~pageが`~BF~cache$から復旧されることを防止した事由
］を
【`事由~文字列$nrrdにて】
— 以下に挙げるいずれかの文字列として —
公開することを選ぶかもしれない：
◎
In addition to the list above, a user agent might choose to expose a reason that prevented the page from being restored from back/forward cache for user-agent specific blocking reasons. These are one of the following strings:
</p>
<dl>
	<dt>`audio-capture@bK</dt>
	<dd>
当の`文書$は、
`MEDIASTREAM$r の `getUserMedia()＠~MEDIACAPTURE/getusermedia.html#dom-mediadevices-getusermedia$m を音声と伴に利用して，
音声を捕捉する許可を要請した。
◎
The Document requested audio capture permission by using Media Capture and Streams's getUserMedia() with audio. [MEDIASTREAM]
</dd>

	<dt>`background-work@bK</dt>
	<dd>
当の`文書$は、
次に挙げるいずれかの~methodを~callすることにより，背景~作業を要請した
⇒＃
`SyncManager＠https://wicg.github.io/background-sync/spec/#syncmanager$I の `register()＠https://wicg.github.io/background-sync/spec/#dom-syncmanager-register$m,
`PeriodicSyncManager＠https://wicg.github.io/periodic-background-sync/#periodicsyncmanager$I の `register()＠https://wicg.github.io/periodic-background-sync/#dom-periodicsyncmanager-register$m,
`BackgroundFetchManager＠https://wicg.github.io/background-fetch/#backgroundfetchmanager$I の `fetch()＠https://wicg.github.io/background-fetch/#dom-backgroundfetchmanager-fetch$m
◎
The Document requested background work by calling SyncManager's register() method, PeriodicSyncManager's register() method, or BackgroundFetchManager's fetch() method.
</dd>

	<dt>`broadcastchannel-message@bK</dt>
	<dd>
当の~pageが`~BF~cache$内に格納されている間に，
当の~page上の `BroadcastChannel$I 接続が~messageを受信したことにより
`message$et ~eventが発火された。
◎
While the page was stored in back/forward cache, a BroadcastChannel connection on the page received a message and message event was fired.
</dd>

	<dt>`idb-event@bK</dt>
	<dd>
`~unloadして$いる間に，当の`文書$は処理待ちな `IDBVersionChangeEvent＠~INDEXEDDB#idbversionchangeevent$I を有していた。
`INDEXEDDB$r
◎
The Document had a pending IDBVersionChangeEvent while unloading. [INDEXEDDB]
</dd>

	<dt>`idledetector@bK</dt>
	<dd>
`~unloadして$いる間に，
当の`文書$は作動中な `IdleDetector＠https://wicg.github.io/idle-detection/#idledetector$I を有していた。
◎
The Document had an active IdleDetector while unloading.
</dd>

	<dt>`keyboard-lock@bK</dt>
	<dd>
`Keyboard＠https://wicg.github.io/keyboard-lock/#keyboard$I の `lock()＠https://wicg.github.io/keyboard-lock/#dom-keyboard-lock$m
~methodが~callされたため、
`~unloadして$いる間も~keyboard~lockは依然として作動中であった。
◎
While unloading, keyboard lock was still active because Keyboard's lock() method was called.
</dd>

	<dt>`mediastream@bK</dt>
	<dd>
当の`文書を~unloadする＠~HTMLlifecycle#unload-a-document$際に，
`MediaStreamTrack＠~MEDIACAPTURE/getusermedia.html#mediastreamtrack$I は`~live状態＠~MEDIACAPTURE/getusermedia.html#idl-def-MediaStreamTrackState.live$にあった。
`MEDIASTREAM$r
◎
A MediaStreamTrack was in the live state upon unloading. [MEDIASTREAM]
</dd>

	<dt>`midi@bK</dt>
	<dd>
当の`文書$は、
`navigator.requestMIDIAccess()＠https://webaudio.github.io/web-midi-api/#dom-navigator-requestmidiaccess$c を~callすることにより，
~MIDI許可を要請した。
◎
The Document requested a MIDI permission by calling navigator.requestMIDIAccess().
</dd>

	<dt>`modals@bK</dt>
	<dd>
`~unloadして$いる間に，`利用者~向けの~prompt＠~HTMLGAPI#user-prompts$が示された。
◎
User prompts were shown while unloading.
</dd>

	<dt>`navigating@bK</dt>
	<dd>
`~unloadして$いる間も読込ngは依然として進行中にあったので、
当の`文書$は［
`~BF~cache$内に格納することもできた状態
］にはなかった。
◎
While unloading, loading was still ongoing, and so the Document was not in a state that could be stored in back/forward cache.
</dd>

	<dt>`navigation-canceled@bK</dt>
	<dd>
当の~navi要請は `stop()$m を~callすることにより取消されたため、
当の~pageは［
`~BF~cache$内に格納できる状態
］にはなかった。
◎
The navigation request was canceled by calling window.stop() and the page was not in a state to be stored in back/forward cache.
</dd>

	<dt>`non-trivial-bcg@bK</dt>
	<dd>
当の`文書$が属する`閲覧~文脈~group$は、
複数個の`~top-level閲覧~文脈$を有していた。
◎
The browsing context group of this Document had more than one top-level browsing context.
</dd>

	<dt>`blocking-otp@bK</dt>
	<dd>
当の`文書$は、
`OTPCredential＠https://wicg.github.io/web-otp/#otpcredential$I を作成した。
◎
The Document created an OTPCredential.
</dd>

	<dt>`outstanding-network-request@bK</dt>
	<dd>
`~unloadして$いる間に，
当の`文書$は応答待ちな~network要請を有していたため、［
`~BF~cache$内に格納することもできた状態
］にはなかった。
◎
While unloading, the Document had outstanding network requests and was not in a state that could be stored in back/forward cache.
</dd>

	<dt>`payment@bK</dt>
	<dd>
`~unloadして$いる間に，
当の`文書$は作動中な `PaymentRequest＠https://w3c.github.io/payment-request/#dom-paymentrequest$I を有していた。
`PAYMENTREQUEST$r
◎
The Document had an active PaymentRequest while unloading. [PAYMENTREQUEST]
</dd>

	<dt>`picture-in-picture@bK</dt>
	<dd>
`~unloadして$いる間に，当の`文書$は作動中な `PictureInPictureWindow＠https://w3c.github.io/picture-in-picture/#pictureinpicturewindow$I を有していた。
`PICTUREINPICTURE$r
◎
The Document had an active PictureInPictureWindow while unloading. [PICTUREINPICTURE]
</dd>

	<dt>`plugins@bK</dt>
	<dd>
当の`文書$は、
ある`~plugin$を包含していた。
◎
The Document contained plugins.
</dd>

	<dt>`method-not-get@bK</dt>
	<dd>
当の`文書$は、
次を満たす~HTTP要請から作成された
⇒
その`~method$rq ~NEQ `GET^M
`FETCH$r
◎
The Document was created from an HTTP request whose method was not `GET`. [FETCH]
</dd>

	<dt>`auth-required@bK</dt>
	<dd>
当の`文書$は、
~HTTP認証を要求する~HTTP応答から作成された。
◎
The Document was created from an HTTP response that required HTTP authentication.
</dd>

	<dt>`ccns@bK</dt>
	<dd>
当の`文書$は、
次を満たす~HTTP応答から作成された
⇒
`Cache-Control$h ~headerを包含していて，
その値は `no-store^v ~tokenを内包している
`HTTP$r
◎
The Document was created from an HTTP response whose `Cache-Control` header included the "no-store" token. [HTTP]
</dd>

	<dt>`ccnc@bK</dt>
	<dd>
当の`文書$は、
次を満たす~HTTP応答から作成された
⇒
`Cache-Control$h ~headerを包含していて，
その値は `no-cache^v ~tokenを内包している
`HTTP$r
◎
The Document was created from an HTTP response whose `Cache-Control` header included the "no-cache" token. [HTTP]
</dd>

	<dt>`keepalive@bK</dt>
	<dd>
当の`文書$は、
次を満たす~HTTP応答から作成された
⇒
`Keep-Alive$h ~headerを包含している
◎
The Document was created from an HTTP response that contained a `Keep-Alive` header.
</dd>

	<dt>`not-http-https@bK</dt>
	<dd>
当の`文書$は、
次を満たす応答から作成された
⇒
その`~URL$rsの`~scheme$urlは`~HTTP_S~scheme$でない
`FETCH$r
◎
The Document was created from a response whose URL's scheme was not an HTTP(S) scheme. [FETCH]
</dd>

	<dt>`response-not-ok@bK</dt>
	<dd>
当の`文書$は、
次を満たす~HTTP応答から作成された
⇒
その`状態s$rsは`~ok状態s$でない
`FETCH$r
◎
The Document was created from an HTTP response whose status was not an ok status. [FETCH]
</dd>

	<dt>`rtc@bK</dt>
	<dd>
`~unloadして$いる間に［
`RTCPeerConnection＠https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection$I ／
`RTCDataChannel＠https://w3c.github.io/webrtc-pc/#dom-rtcdatachannel$I
］が~shut-downされたので、
当の~pageは［
`~BF~cache$内に格納することもできた状態
］にはなかった。
`WEBRTC$r
◎
While unloading, a RTCPeerConnection or RTCDataChannel was shut down, so the page was not in a state that could be stored in the back/forward cache. [WEBRTC]
</dd>

	<dt>`sensors@bK</dt>
	<dd>
当の`文書$は、
`~sensor~accessを要請した＠~SENSORS#request-sensor-access$。
◎
The Document requested sensor access.
</dd>

	<dt>`serviceworker-added@bK</dt>
	<dd>
当の~pageが`~BF~cache$内にある間に，
当の`文書$の`~sw~client$は，ある `ServiceWorker$I により`制御され＠~SW1#dfn-control$るように開始された。
`SW$r
◎
The Document's service worker client started to be controlled by a ServiceWorker while the page was in back/forward cache. [SW]
</dd>

	<dt>`serviceworker-claimed@bK</dt>
	<dd>
当の~pageが`~BF~cache$内にある間に，
当の`文書$の`~sw~client$にて`作動中な~sw$enVが `claim^en された【 `claim()＠~SW1#dom-clients-claim$m が~callされた？】。
`SW$r
◎
The Document's service worker client's active service worker was claimed while the page was in back/forward cache. [SW]
</dd>

	<dt>`sw-message@bK</dt>
	<dd>
当の~pageが`~BF~cache$内にある間に，
当の`文書$の`~sw~client$にて`作動中な~sw$enVが~messageを受信した。
`SW$r
◎
The Document's service worker client's active service worker received a message while the page was in back/forward cache. [SW]
</dd>

	<dt>`sw-activation@bK</dt>
	<dd>
当の~pageが`~BF~cache$内にある間に，
当の`文書$の`~sw~client$にて`作動中な~sw$enVの~version【？】が作動化された。
`SW$r
◎
The Document's service worker client's active service worker's version was activated while the page was in back/forward cache. [SW]
</dd>

	<dt>`sw-unregistered@bK</dt>
	<dd>
当の~pageが`~BF~cache$内にある間に，
当の`文書$の`~sw~client$にて`作動中な~sw$enVの`~sw登録$が`未登録にされた＠~SW1#navigator-service-worker-unregister$。
`SW$r
◎
The Document's service worker client's active service worker's service worker registration was unregistered while the page was in back/forward cache. [SW]
</dd>

	<dt>`sharedworker@bK</dt>
	<dd>
当の`文書$は、
ある `SharedWorkerGlobalScope$I の`所有者~集合$wG内に在った。
◎
This Document was in the owner set of a SharedWorkerGlobalScope.
</dd>

	<dt>`smartcard@bK</dt>
	<dd>
`~unloadして$いる間に，
当の`文書$は作動中な `SmartCardConnection＠https://wicg.github.io/web-smart-card/#dom-smartcardconnection$I を有していた。
◎
The Document had an active SmartCardConnection while unloading.
</dd>

	<dt>`speech-reco@bK</dt>
	<dd>
`~unloadして$いる間に，
当の`文書$は作動中な `SpeechRecognition＠https://wicg.github.io/speech-api/#speechrecognition$I を有していた。
◎
The Document had an active SpeechRecognition while unloading.
</dd>

	<dt>`storage@bK</dt>
	<dd>
当の`文書$は、
`Storage Access API^cite を利用して~storage~access許可を要請した。
◎
The Document requested storage access permission by using the Storage Access API.
</dd>

	<dt>`unload@bK</dt>
	<dd>
当の`文書$は、
`unload$et ~event用の`~event~listener$を登録した。
◎
The Document registered an event listener for the unload event.
</dd>

	<dt>`video-capture@bK</dt>
	<dd>
当の`文書$は、
`MEDIASTREAM$r の `getUserMedia()＠~MEDIACAPTURE/getusermedia.html#dom-mediadevices-getusermedia$m を動画と伴に利用して，
動画を捕捉する許可を要請した。
◎
The Document requested video capture permission by using Media Capture and Streams's getUserMedia() with video. [MEDIASTREAM]
</dd>

	<dt>`webhid@bK</dt>
	<dd>
当の`文書$は、
`WebHID API^cite の `requestDevice()＠https://wicg.github.io/webhid/#requestdevice-method$m ~methodを~callした。
◎
The Document called the WebHID API's requestDevice() method.
</dd>

	<dt>`webshare@bK</dt>
	<dd>
当の`文書$は、
`Web Share API^cite の `navigator.share()＠~WEBSHARE#share-method$m ~methodを利用した。
◎
The Document used the Web Share API's navigator.share() method.
</dd>

	<dt>`webtransport@bK</dt>
	<dd>
`~unloadして$いる間に，~openな `WebTransport$I 接続が~shut-downされたので、
当の~pageは［
`~BF~cache$内に格納することもできた状態
］にはなかった。
`WEBTRANSPORT$r
◎
While unloading, an open WebTransport connection was shut down, so the page was not in a state that could be stored in the back/forward cache. [WEBTRANSPORT]
</dd>

	<dt>`webxr@bK</dt>
	<dd>
当の`文書$は、
`XRSystem＠https://immersive-web.github.io/webxr/#xrsystem$I を作成した。
◎
The Document created a XRSystem.
</dd>
</dl>

<hr>

<p>
各 `NotRestoredReasons$I ~objは、
次に挙げるものを有する：
◎
↓</p>
<ul>
	<li>
`~backしている構造体@NRR
⇒
~NULL ／
`復旧されない事由~群$
— 初期~時は ~NULL とする。
◎
A NotRestoredReasons object has a backing struct, a not restored reasons or null, initially null.
</li>
	<li>
`事由~群~配列@NRR
⇒
~NULL ／
`NotRestoredReasonDetails$I ~objたちが成す`凍結d配列$
— 初期~時は ~NULL とする。
◎
A NotRestoredReasons object has a reasons array, a FrozenArray&lt;NotRestoredReasonDetails&gt; or null, initially null.
</li>
	<li>
`子~事由~群~配列@NRR
⇒
~NULL ／
`NotRestoredReasons$I ~objたちが成す`凍結d配列$
— 初期~時は ~NULL とする。
◎
A NotRestoredReasons object has a children array, a FrozenArray&lt;NotRestoredReasons&gt; or null, initially null.
</li>
</ul>

<div class="algo">
`src@m
取得子~手続きは
⇒
~RET コレを`~backしている構造体$NRRの`~source$nrr
◎
The src getter steps are to return this's backing struct's src.
</div>

<div class="algo">
`id@m
取得子~手続きは
⇒
~RET コレを`~backしている構造体$NRRの`~ID$nrr
◎
The id getter steps are to return this's backing struct's id.
</div>

<div class="algo">
`name@m0
取得子~手続きは
⇒
~RET コレを`~backしている構造体$NRRの`名前$nrr
◎
The name getter steps are to return this's backing struct's name.
</div>

<div class="algo">
<p>
`url@m
取得子~手続きは：
◎
The url getter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレを`~backしている構造体$NRRの`~URL$nrr
◎
↓</li>
	<li>
~IF［
%~URL ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If this's backing struct's URL is null, then return null.
</li>
	<li>
~RET `~URLを直列化する$( %~URL )
◎
Return this's backing struct's URL, serialized.
</li>
</ol>
</div>

<div class="algo">
`reasons@m
取得子~手続きは
⇒
~RET コレの`事由~群~配列$NRR
◎
The reasons getter steps are to return this's reasons array.
</div>

<div class="algo">
`children@m
取得子~手続きは
⇒
~RET コレの`子~事由~群~配列$NRR
◎
The children getter steps are to return this's children array.
</div>

<div class="algo">
<p>
`NotRestoredReasons$I ~objを
`作成する@NRR
~algoは、
所与の
( `復旧されない事由~群$ %~backしている構造体, `~realm$ %~realm )
に対し：
◎
To create a NotRestoredReasons object given a not restored reasons backingStruct and a realm realm:
</p>
<ol>
	<li>
%復旧されない事由~群 ~LET `新たな~obj$( `NotRestoredReasons$I, %~realm )
◎
Let notRestoredReasons be a new NotRestoredReasons object created in realm.
</li>
	<li>
%復旧されない事由~群 を`~backしている構造体$NRR ~SET %~backしている構造体
◎
Set notRestoredReasons's backing struct to backingStruct.
</li>
	<li>
~IF［
%~backしている構造体 の`事由~群$nrr ~EQ ~NULL
］
⇒
%復旧されない事由~群 の`事由~群~配列$NRR ~SET ~NULL
◎
If backingStruct's reasons is null, set notRestoredReasons's reasons array to null.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%事由~群~配列 ~LET 新たな`~list$
◎
Let reasonsArray be an empty list.
</li>
			<li>
<p>
%~backしている構造体 の`事由~群$nrrを成す
~EACH( %事由 )
に対し：
◎
For each reason of backingStruct's reasons:
</p>
				<ol>
					<li>
%O ~LET 
`NotRestoredReasonDetails^I ~objを`作成する$NRRD( %事由, %~realm )
◎
Create a NotRestoredReasonDetails object given reason and realm,＼
</li>
					<li>
%事由~群~配列 に %O を`付加する$
◎
and append it to reasonsArray.
</li>
				</ol>
			</li>
			<li>
%復旧されない事由~群 の`事由~群~配列$NRR ~SET `凍結d配列を作成する$( %事由~群~配列 )
◎
Set notRestoredReasons's reasons array to the result of creating a frozen array given reasonsArray.
</li>
		</ol>
	</li>
	<li>
~IF［
%~backしている構造体 の`子~事由~群$nrr ~EQ ~NULL
］
⇒
%復旧されない事由~群 の`子~事由~群~配列$NRR ~SET ~NULL
◎
If backingStruct's children is null, set notRestoredReasons's children array to null.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%子~事由~群~配列 ~LET 新たな`~list$
◎
Let childrenArray be an empty list.
</li>
			<li>
<p>
%~backしている構造体 の`子~事由~群$nrrを成す
~EACH( %子 )
に対し：
◎
For each child of backingStruct's children:
</p>
				<ol>
					<li>
%O ~LET `NotRestoredReasons^I ~objを`作成する$NRR( %子, %~realm )
◎
Create a NotRestoredReasons object given child＼
</li>
					<li>
%子~事由~群~配列 に %O を`付加する$
◎
and realm and append it to childrenArray.
</li>
				</ol>
			</li>
			<li>
%復旧されない事由~群 の`子~事由~群~配列$NRR ~SET `凍結d配列を作成する$( %子~事由~群~配列 )
◎
Set notRestoredReasons's children array to the result of creating a frozen array given childrenArray.
</li>
		</ol>
	</li>
	<li>
~RET %復旧されない事由~群
◎
Return notRestoredReasons.
</li>
</ol>
</div>

<p>
`復旧されない事由~群@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A not restored reasons is a struct with the following items:
</p>
<ul>
	<li>
`~source@nrr
⇒
~NULL ／
ある`~scalar値~文字列$
— 初期~時は ~NULL とする。
◎
src, a scalar value string or null, initially null.
</li>
	<li>
`~ID@nrr
⇒
~NULL ／
ある文字列
— 初期~時は ~NULL とする。
◎
id, a string or null, initially null.
</li>
	<li>
`名前@nrr
⇒
~NULL ／
ある文字列
— 初期~時は ~NULL とする。
◎
name, a string or null, initially null.
</li>
	<li>
`~URL@nrr
⇒
~NULL ／
ある`~URL~record$
— 初期~時は ~NULL とする。
◎
url, a URL or null, initially null.
</li>
	<li>
`事由~群@nrr
⇒
~NULL ／
`復旧されない事由の詳細$たちが成す`~list$
— 初期~時は ~NULL とする。
◎
reasons, null or a list of not restored reason details, initially null.
</li>
	<li>
`子~事由~群@nrr
⇒
~NULL ／
`復旧されない事由~群$たちが成す`~list$
— 初期~時は ~NULL とする。
◎
children, null or a list of not restored reasons, initially null.
</li>
</ul>


<div class="algo">
<p>
`文書の復旧されない事由~群@
は、
所与の
( `文書$ %文書 )
に対し：
◎
A Document's not restored reasons is＼
</p>
<ol>
	<li>
%~navigable ~LET %文書 の`~node~navigable$
◎
↓</li>
	<li>
~IF［
%~navigable は`~top-level辿可能$である
］
⇒
~RET %~navigable にて`作動中な~entry$navの`文書~状態$shEの`復旧されない事由~群$dS
◎
its node navigable's active session history entry's document state's not restored reasons, if Document's node navigable is a top-level traversable;＼
</li>
	<li>
~RET ~NULL
◎
otherwise null.
</li>
</ol>
</div>

			</section>
		</section>
</main>
