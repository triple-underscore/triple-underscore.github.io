<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — APIs related to navigation and session history （ 日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
.xattr {
	font-family: monospace0, monospace;
	color: black;
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'm0':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'xA': // xattr
	text = `[${key}]`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${key}</span>)`
	break;
case 'bP': //
	text = `${key}<code>BarProp</code> ~obj`;
	break;
case 'uST': 
	text = `${text} <small>state</small>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2023-03-29
trans_update:2023-03-30
source_checked:221101
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/nav-history-apis.html
	abbr_url:WINDOW
nav_prev:ORIGIN
nav_next:HTMLWPROXY
site_nav:browsers,html
trans_1st_pub:2016-07-12


●●class_map
E:error
sl:js-slot
jA:abstract
e:element
a:attr
et:event-type
sc:scheme
E:error
sl:js-slot
jA:abstract
xA:xattr
U:code-point
v:value
jv:js-value

●●tag_map
I:code
E:code
m:code
m0:code
c:code
e:code
a:code
sc:code
et:code
v:code
jv:code
sl:span
jA:span
xA:code
V:var
i:i
U:span
V:var
uuhs:i
i:i


●●original_urls

●●words_table


	●network
unload:
load:
HTTP_S:HTTP(S) 
username::::ユーザ名
password::::パスワード
hostname::::ホスト名
抹消-:evict::~
	eviction

	●navi/session
opener:::open 元
入口:entry::~
現在:currently:~
現任:incumbent:~
	予約-済み:reserved
補助:auxiliary::~
読込直す:reloadする::読み込み直す::リロードする
辿る:traverseする::~
辿った:traverseした::~
辿られ:traverseされ::~
辿り:traversal::~
辿可能:traversable::辿り可能
回復-:salvage:~
閉じる:closeする::~
閉じら:closeさ::~
閉じれ:closeでき::~
閉中:is closing::閉じかけ
開く:openする::~
開いた:openした::~
開いて:openして::~
書直せ:rewriteでき::書き直せ
復旧-:restore:~
復旧:restoration:~
回復可能:salvage 可能:~
差分:delta:~
近しい:familiar:~

	前へ進む:go forward
	後へ戻る:go back
	戻る:back
	進む:forward

	●UI
popup:
bar::::バー
scrollbar:
toolbar:
location-bar:
menu-bar:
personal-bar:
status-bar:
prompt:
	~UItab付き:tabbed
pointing::::ポインタ指示
隠す:hideする::~
bookmark:
一過:transient::~

	~UI:interface

	●構文
読飛ばす:skipする:読み飛ばす
直列形の:serialized::~::シリアル形の
逆直列化-:deserialize::~::逆シリアル化

	過ぎない所:past
	先頭の:leading
	数:number

	●IDL／js
exotic:
agent:
WindowProxy:
Location:
prototype-chain:prototype chain
拡張属性:extended attribute::~

	●処理一般
上書state:state override:上書き state
state:
timer::::タイマー
進行中の:ongoingな:~
持続-:persist:~
普通の:ordinary:~
起点:origin::~
timer::::タイマー
params::::パラメタ群

	合致しない:mismatch
	渡-:pass
	渡して:pass
	FIFO
	LIFO
	-:reprocess
	後で／:later


	●変数
	%B
	%B:browsing context
	%L:-
	%~navigable:-
	%N:current
	%location:location
	%menubar:menubar
	%noopener
	%noreferrer
	%resizable:resizable
	%scrollbars:scrollbars
	%status:status
	%toolbar:toolbar
	%~URL:url
	%~URL~record:urlRecord
	%~data:data
	%~event名 eventName
	%~host文字列
	%~navigable:
	%~navigable:navigable
	%~obj群:objects
	%~protocol文字列:
	%~realm:realm
	%~referrer施策:referrerPolicy
	%~source~snapshot~params:sourceSnapshotParams
	%~source文書:sourceDocument
	%~target:target
	%~target~URL:targetURL
	%~target~navigable:targetNavigable
	%~top-level作成時の~URL:topLevelCreationURL
	%~top-level生成元:topLevelOrigin
	%~window:-
	%~window:window
	%~window種別:windowType
	%この辿可能:thisTraversable
	%予約-済み環境:reservedEnvironment
	%位置:position
	%作成時の~URL:creationURL
	%値:value
	%入力:input
	%出力:output
	%名前:name
	%名前~群:names
	%失敗かも:possibleFailure
	%子~群:children
	%実行~文脈:execution context
	%容器:container
	%履歴:history
	%履歴~取扱い:historyHandling
	%差分:delta
	%L:location
	%持続されるか persisted
	%文書 document
	%文書:document
	%文書~URL: documentURL
	%新たな~URL:newURL
	%既定~値:defaultValue
	%有名~子~群:firstNamedChildren
	%特能~map:tokenizedFeatures
	%特能~名:featureName
	%特能~群:features
	%現~文書:-
	%現在の文書:current
	%直列形の~data:serializedData
	%複製~URL:copyURL
	%設定群~obj:settings object
	%辿可能:traversable
	%閲覧~文脈:browsingContext

	●仕様
活動:activity::~::アクティビティ
適格:eligible:~
必要最小限:minimal:~
確認:confirmation:~
上限:limit:~
冗長:redundant:~
脱出措置:bailout:~
推定-:infer:~

	素朴:naïve
	早く:as soon as
	配備-済み:deployed
	抵触-:hit
	させ易く:help
	慣習:traditional
	関わらない:matter
	~codeは壊れやすくなる:lead to brittle code
	~~実際，:Indeed
	選ぶ:choose する
	事実:fact

	●未分類
open:
作成時の:creation::~
	getting
	設定し直-:reset
	総合的:overall

	変わる:vary
	“お気に入り”:favorite
	~force-close
	非:non
	指して:point at

	まったく別の:completely different
	-:later
	直上や直下:immediately below or after
	所与の任意の時点:at any moment
	~NULL化:nulled out
	様なもの:look like
	次:next
	全体:whole
	直後:immediately after
game::::ゲーム
	あてがわれ:prefill
	~Location~objにより:Location-object
	-:duplicate
	ずっと高速:much faster
	と違って:contrary to
	更には:furthermore
	線:line
	非:non-
	-:per
	point
	立て続けに:rapid succession
	%失敗かも:possibleFailure



●●original_id_map
dom-window-document:dom-document-2
dom-window-frameelement:dom-frameelement
dom-window-frames:dom-frames
dom-window-history:dom-history
dom-window-length:dom-length
dom-window-location:dom-location
dom-window-name:dom-name
dom-window-open:dom-open
dom-window-opener:dom-opener
dom-window-parent:dom-parent
dom-window-self:dom-self
dom-window-top:dom-top
dom-window-window:dom-window

	dom-window-length:number-of-document-tree-child-browsing-contexts
	document-tree-child-navigable-target-name-property-set:document-tree-child-browsing-context-name-property-set
	document-tree-child-navigable-target-name-property-set:child-browsing-context-name-property-set


●●words_table1
about_blank:about:blank

●●mdn_urls
beforeunloadevent:API/BeforeUnloadEvent
hashchangeevent:API/HashChangeEvent
history-3:API/History
location:API/Location
pagetransitionevent:API/PageTransitionEvent
popstateevent:API/PopStateEvent
scrollrestoration:
window:API/Window


●●link_map

	●IDL
LegacyNullToEmptyString:~WEBIDLjs#LegacyNullToEmptyString
LegacyUnenumerableNamedProperties:~WEBIDLjs#LegacyUnenumerableNamedProperties
LegacyUnforgeable:~WEBIDLjs#LegacyUnforgeable
xA.Global:~WEBIDLjs#Global

E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror

object:~WEBIDL#idl-object

I.BarProp:#barprop
I.BeforeUnloadEvent:#beforeunloadevent
I.CustomElementRegistry:~HEcustom#customelementregistry
I.DOMStringList:~HTMLcdom#domstringlist
I.Document:~HTMLdom#document
文書:~HTMLdom#the-document-object
I.Element:~DOM4#element
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.GlobalEventHandlers:~WAPI#globaleventhandlers
I.HTMLCollection:~DOM4#interface-htmlcollection
I.HashChangeEvent:#hashchangeevent
I.HashChangeEventInit:#hashchangeeventinit
I.History:#history-3
I.Location:#location
I.Navigator:~HTMLnavigator#navigator
I.PageTransitionEvent:#pagetransitionevent
I.PageTransitionEventInit:#pagetransitioneventinit
I.PopStateEvent:#popstateevent
I.PopStateEventInit:#popstateeventinit
I.ScrollRestoration:#scrollrestoration
I.StructuredSerializeOptions:~HTMLcomms#structuredserializeoptions
I.WebSocket:~WEBSOCKET#websocket
I.Window:#window
~window:#the-window-object
I.WindowEventHandlers:~WAPI#windoweventhandlers
I.WindowPostMessageOptions:#windowpostmessageoptions
I.WindowProxy:~HTMLWPROXY#windowproxy


	getter:#dom-window-nameditem
	getter:#dom-nameditem

m.alert:~HTMLGAPI#dom-window-alert
m0.alert:~HTMLGAPI#dom-window-alert-noargs
m.ancestorOrigins:#dom-location-ancestororigins
m.assign:#dom-location-assign
m.back:#dom-history-back
m.blur:~HTMLinteraction#dom-window-blur
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.clientInformation:~HTMLnavigator#dom-window-clientinformation
m.close:#dom-window-close
m.closed:#dom-window-closed
m.confirm:~HTMLGAPI#dom-window-confirm
m.customElements:~HEcustom#dom-window-customelements
m.defaultView:#dom-document-defaultview
m.document:#dom-window-document
m.focus:~HTMLinteraction#dom-window-focus
m.forward:#dom-history-forward
m.frameElement:#dom-window-frameelement
m.frames:#dom-window-frames
m.go:#dom-history-go
m.hash:#dom-location-hash
m.history:#dom-window-history
m.host:#dom-location-host
m.hostname:#dom-location-hostname
m.href:#dom-location-href
m.length:#dom-window-length
m0.length:#dom-history-length
m.location:#dom-window-location
m0.location:#dom-document-location
m.locationbar:#dom-window-locationbar
m.menubar:#dom-window-menubar
m.name:#dom-window-name
m.navigator:~HTMLnavigator#dom-window-navigator
m.newURL:#dom-hashchangeevent-newurl
m.oldURL:#dom-hashchangeevent-oldurl
m.open:#dom-window-open
m.opener:#dom-window-opener
m.origin:#dom-location-origin
m.originAgentCluster:~ORIGIN#dom-originagentcluster
m.parent:#dom-window-parent
m.pathname:#dom-location-pathname
m.persisted:#dom-pagetransitionevent-persisted
m.personalbar:#dom-window-personalbar
m.port:#dom-location-port
m.postMessage:~HTMLcomms#dom-window-postmessage
m0.postMessage:~HTMLcomms#dom-window-postmessage-options
m.preventDefault:~DOM4#dom-event-preventdefault
m.print:~HTMLGAPI#dom-window-print
m.prompt:~HTMLGAPI#dom-window-prompt
m.protocol:#dom-location-protocol
m.pushState:#dom-history-pushstate
m.reload:#dom-location-reload
m.replace:#dom-location-replace
m.replaceState:#dom-history-replacestate
m.returnValue:#dom-beforeunloadevent-returnvalue
m.scrollRestoration:#dom-history-scroll-restoration
m.scrollbars:#dom-window-scrollbars
m.search:#dom-location-search
m.self:#dom-window-self
m.state:#dom-history-state
m0.state:#dom-popstateevent-state
m.status:#dom-window-status
m.statusbar:#dom-window-statusbar
m.stop:#dom-window-stop
m.targetOrigin:#dom-windowpostmessageoptions-targetorigin
m.toolbar:#dom-window-toolbar
m.top:#dom-window-top
m.visible:#dom-barprop-visible
m.window:#dom-window-window

et.load:~HTMLindex#event-load
et.pagehide:~HTMLindex#event-pagehide
et.pageshow:~HTMLindex#event-pageshow

e.a:~HEtextlevel#the-a-element
e.area:~HEimages#the-area-element
e.form:~HEforms#the-form-element
e.embed:~HEembed#the-embed-element
e.img:~HEimages#the-img-element
e.object:~HEembed#the-object-element
e.head:~HEmetadata#the-head-element
e.iframe:~HEembed#the-iframe-element
e.script:~HEscripting#the-script-element

a.id:~HTMLdom#the-id-attribute

l.HTMLDocument:#htmldocument
l.concrete:~HTMLds#cross-origin-isolation-concrete
l.cross-origin-isolated:~HTMLINFRA#cross-origin-isolated-feature
l.auto:~HTMLnav#dom-scrollrestoration-auto
l.manual:~HTMLnav#dom-scrollrestoration-manual

v.noopener:~HTMLlinks#link-type-noopener
v.noreferrer:~HTMLlinks#link-type-noreferrer

sl.GetOwnProperty:~HTMLWPROXY#windowproxy-getownproperty

sc.~about_blank:~HTMLdep#about:blank

bP.~location-bar:#the-location-bar-barprop-object
bP.~menu-bar:#the-menu-bar-barprop-object
bP.~personal-bar:#the-personal-bar-barprop-object
bP.~scrollbar:#the-scrollbar-barprop-object
bP.~status-bar:#the-status-bar-barprop-object
bP.~toolbar:#the-toolbar-barprop-object

jA.OrdinaryDefineOwnProperty:~TC39#sec-ordinarydefineownproperty
jA.StructuredSerializeForStorage:~HTMLcloning#structuredserializeforstorage

	●用語
有名~要素:#_named-element
要素~名:#_element-name
生成元~domainを検査する:#_location-security-check

有名~obj:#dom-window-nameditem-filter
~Location~objにより~navigateする:#location-object-navigate
先祖~生成元~list:#concept-location-ancestor-origins-list
結付けられている文書:#concept-document-window
対応する閲覧~文脈:#window-bc
対応する~navigable:#window-navigable
書直せ:#can-have-its-url-rewritten
文書の~URLは書直せるか:#can-have-its-url-rewritten
~popup~windowが要請されたか否か検査する:#popup-window-is-requested
~window特能は設定されたか否か検査する:#window-feature-is-set
差分だけ辿る:#delta-traverse

文書~treeに属する子~navigable~target名~prop集合:#document-tree-child-navigable-target-name-property-set
特能~分離子:#feature-separator
~page遷移~eventを発火する:#fire-a-page-transition-event

履歴~obj:#doc-history
hsT.~index:#concept-history-index
hsT.長さ:#concept-history-length
hsT.状態:#concept-history-state

特能~名として正規化する:#normalizing-the-feature-name
真偽-特能を構文解析する:#concept-window-open-features-parse-boolean
Loc.~URL:#concept-location-url
Loc.関連な文書:#relevant-document
~scriptから閉じれる:#script-closable
~window用に環境~設定群~objを設定しておく:#set-up-a-window-environment-settings-object
履歴に状態を~pushするか履歴の状態を置換する:#shared-history-push/replace-state-steps
特能~群を~token化する:#concept-window-open-features-tokenize
~window~open手続き:#window-open-steps

	●用語（HTML

enV.~API用~URL文字~符号化法:~WAPI#api-url-character-encoding
enV.~API用~基底~URL:~WAPI#api-base-url
enV.~ID:~WAPI#concept-environment-id
enV.~module~map:~WAPI#concept-settings-object-module-map
enV.~realm実行~文脈:~WAPI#realm-execution-context
enV.~target閲覧~文脈:~WAPI#concept-environment-target-browsing-context
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.作動中の~sw:~WAPI#concept-environment-active-service-worker
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.施策~容器:~WAPI#concept-settings-object-policy-container
enV.時刻~起点:~WAPI#concept-settings-object-time-origin
enV.生成元:~WAPI#concept-settings-object-origin
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability

tK.文書:~WAPI#concept-task-document
~event~loop:~WAPI#event-loop
~taskを~queueする:~WAPI#queue-a-task
~DOM操作~task源:~WAPI#dom-manipulation-task-source
入口~大域~obj:~WAPI#entry-global-object
入口~設定群~obj:~WAPI#entry-settings-object
rM.大域~obj:~WAPI#concept-realm-global
現任な大域~obj:~WAPI#concept-incumbent-global
現在の設定群~obj:~WAPI#current-settings-object
環境:~WAPI#environment
環境~設定群~obj:~WAPI#environment-settings-object
関連な~realm:~WAPI#concept-relevant-realm
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
agC.非同一-生成元~隔離~mode:~WAPI#agent-cluster-cross-origin-isolation

同じ生成元~domain:~ORIGIN#same-origin-domain
同一-生成元:~ORIGIN#same-origin
生成元:~ORIGIN#concept-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

~navigable:~HTMLds#navigable
nav.~target名:~HTMLds#nav-target
nav.作動中の閲覧~文脈:~HTMLds#nav-bc
nav.容器:~HTMLds#nav-container
nav.作動中の文書:~HTMLds#nav-document
nav.作動中の~WindowProxy:~HTMLds#nav-wp
nav.閉中か:~HTMLds#is-closing
nav.~top-level辿可能:~HTMLds#nav-top
親~navigable:~HTMLds#nav-parent
nav.親:~HTMLds#nav-parent
nav.辿可能な~navigable:~HTMLds#nav-traversable
nav.作動中の~session履歴~entry:~HTMLds#nav-active-history-entry
nav.~session履歴~entry群:~HTMLds#tn-session-history-entries
先祖~navigable群:~HTMLds#ancestor-navigables
~top-level辿可能:~HTMLds#top-level-traversable
~top-level辿可能~集合:~HTMLds#top-level-traversable-set
~top-level辿可能を閉じる:~HTMLds#close-a-top-level-traversable
文書~treeに属する子~navigable群:~HTMLds#document-tree-child-navigables
~node~navigable:~HTMLds#node-navigable
~navigable容器:~HTMLds#navigable-container
~navigableを選ぶ規則:~HTMLds#the-rules-for-choosing-a-navigable
閲覧~文脈:~HTMLds#browsing-context
bc.~popupか:~HTMLds#is-popup
bc.作動中の文書:~HTMLds#active-document
bc.~top-level閲覧~文脈:~HTMLds#bc-tlbc
bc.開いた閲覧~文脈:~HTMLds#opener-browsing-context
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context
先祖~閲覧~文脈:~HTMLds#ancestor-browsing-context
全部的に作動中:~HTMLds#fully-active
属する閲覧~文脈:~HTMLds#concept-document-bc
補助~閲覧~文脈:~HTMLds#auxiliary-browsing-context
近しい:~HTMLds#familiar-with
内容~navigable:~HTMLds#content-navigable
doc.容器~文書:~HTMLds#doc-container-document
辿可能な~navigable:~HTMLds#traversable-navigable

i.置換-:~HTMLnav#hh-replace
i.~referrer施策:~HTMLnav#navigation-referrer-policy
i.例外を可能化するか:~HTMLnav#exceptions-enabled
i.~push:~HTMLnav#hh-push
i.履歴~取扱い:~HTMLnav#navigation-hh
uuhs.直列形の~data:~HTMLnav#uhus-serializeddata
uuhs.履歴~取扱い:~HTMLnav#uhus-historyhandling
~navigableを~URLへ~navigateする:~HTMLnav#navigate
~navigate:~HTMLnav#navigate
~navi~algo:~HTMLnav#navigate
~navigableを読込直す:~HTMLnav#reload
	読込直す:~HTMLnav#reload
~navigateすることは~sandbox法により許容される:~HTMLnav#allowed-to-navigate
~URLと履歴を更新する:~HTMLnav#url-and-history-update-steps
~session履歴~entry:~HTMLnav#session-history-entry
~scroll復旧~mode:~HTMLnav#scroll-restoration-mode
dS.~navigable名:~HTMLnav#document-state-nav-target-name
履歴~取扱いの挙動:~HTMLnav#history-handling-behavior
履歴を差分だけ辿る:~HTMLnav#traverse-the-history-by-a-delta
shE.文書~状態:~HTMLnav#she-document-state
shE.~scroll復旧~mode:~HTMLnav#she-scroll-restoration-mode
shE.直列形の状態:~HTMLnav#she-serialized-state
shE.~URL:~HTMLnav#she-url
~source~snapshot~paramsを~snapshotする:~HTMLnav#snapshotting-source-snapshot-params
利用者が~unloadするのを取消したか否か検査する:~HTMLnav#checking-if-unloading-is-user-canceled

終了n入子ng~level:~HTMLlifecycle#termination-nesting-level
doc.回復可能~状態:~HTMLlifecycle#concept-document-salvageable
読込ngを停止する:~HTMLlifecycle#nav-stop
完全に読込まれ:~HTMLlifecycle#completely-loaded

~HTML要素:~HTMLINFRA#html-elements
~commaで分離された~token集合:~HTMLcms#set-of-comma-separated-tokens
整数として構文解析する:~HTMLcms#rules-for-parsing-integers
相対的に~URL構文解析する:~HTMLurl#parse-a-url
~about_blank に合致して:~HTMLurl#matches-about:blank

doc.基底~URL:~HTMLurl#document-base-url

初期~about_blank な文書:~HTMLdom#is-initial-about:blank
doc.~module~map:~HTMLdom#concept-document-module-map
doc.施策~容器:~HTMLdom#concept-document-policy-container
doc.~load計時~情報:~HTMLdom#load-timing-info
~navi開始~時刻:~HTMLdom#navigation-start-time

~hyperlink:~HTMLlinks#hyperlink
一過な作動化？:~HTMLinteraction#transient-activation
利用は許容されて:~HEembed#allowed-to-use

	●用語（外部

~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII空白:~INFRA#ascii-whitespace
~scalar値~文字列:~INFRA#scalar-value-string
~list:~INFRA#list
~size:~INFRA#list-size
付加する:~INFRA#list-append
位置~変数:~INFRA#string-position-variable
実装定義:~INFRA#implementation-defined
有順序~集合:~INFRA#ordered-set
有順序~map:~INFRA#ordered-map
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
map.空:~INFRA#map-is-empty

~supportする~prop名:~WEBIDL#dfn-supported-property-names
有名~propを~supportする:~WEBIDL#dfn-support-named-properties
有名~propの値を決定する:~WEBIDL#dfn-determine-the-value-of-a-named-property
旧来の~platform~obj:~WEBIDL#dfn-legacy-platform-object
有名~prop群~obj:~WEBIDLjs#dfn-named-properties-object

~HTTP_S~scheme:~FETCH#http-scheme

~URL:~URL1#concept-url
~URL~record:~URL1#concept-url
url.~host:~URL1#concept-url-host
url.~password:~URL1#concept-url-password
url.~path:~URL1#concept-url-path
url.~port:~URL1#concept-url-port
url.~query:~URL1#concept-url-query
url.~scheme:~URL1#concept-url-scheme
url.~username:~URL1#concept-url-username
url.生成元:~URL1#concept-url-origin
url.素片:~URL1#concept-url-fragment
url.既定の~port:~URL1#default-port
~URLを直列化する:~URL1#concept-url-serializer
~hostを直列化する:~URL1#concept-host-serializer
~username／~password／~portを持てない:~URL1#cannot-have-a-username-password-port
整数を直列化する:~URL1#serialize-an-integer
不透明な~path:~URL1#url-opaque-path
~URL~pathを直列化する:~URL1#url-path-serializer
~API用に~URL構文解析する:~URL1#_api-url-parser
uST.~host:~URL1#host-state
uST.~hostname:~URL1#hostname-state
uST.~path開始:~URL1#path-start-state
uST.~port:~URL1#port-state
uST.~query:~URL1#query-state
uST.~scheme開始:~URL1#scheme-start-state
uST.素片:~URL1#fragment-state

~node文書:~DOM4#concept-node-document
子孫:~DOM4#concept-tree-descendant
~tree順序:~DOM4#concept-tree-order
文書~tree内:~DOM4#in-a-document-tree
根:~DOM4#concept-tree-root
doc.生成元:~DOM4#concept-document-origin
doc.~URL:~DOM4#concept-document-url
doc.符号化法:~DOM4#concept-document-encoding
~eventを発火する:~DOM4#concept-event-fire

~JS実行~文脈:~TC39#sec-execution-contexts
~agent~cluster:~TC39#sec-agent-clusters

閲覧~文脈の特能を設定しておく:~CSSOMVIEW#set-up-browsing-context-features



●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ APIs related to navigation and session history</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>HTML — ナビとセッション履歴に関係する API</h1>
<p>APIs related to navigation and session history</p>
	</hgroup>
</header>

<main id="MAIN" hidden>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="nav-traversal-apis">
<h3 title="APIs related to navigation and session history">7.2. ~naviと~session履歴に関係する~API</h3>

			<section id="cross-origin-objects">
<h4 title="Security infrastructure for Window, WindowProxy, and Location objects">7.2.1 `Window^I, `WindowProxy^I, `Location^I ~obj用の~security基盤</h4>

<p class="trans-note">【
この節を成す内容は、
`別~page＠~HTMLWPROXY#cross-origin-objects$にて。
】</p>

			</section>
			<section id="the-window-object">
<h4 title="The Window object">7.2.2. `Window^I ~obj</h4>

<p class="trans-note">【
以下，この訳では、
`Window$I ~interfaceを実装する~objを単に
<dfn>~window</dfn>
とも略記する。
この略記は、
この~pageに限らず，この仕様の他の~pageの和訳でも利用される
— この節を指す~linkが付与された “`~window$” は、
`Window$I ~objを表すとする。
】</p>

<pre class="idl">
[Global=Window,
 Exposed=Window,
 `LegacyUnenumerableNamedProperties$]
interface `Window@I : `EventTarget$I {
  /* <span class="comment">
現在の閲覧~文脈
◎
the current browsing context
</span> */
  [`LegacyUnforgeable$] readonly attribute `WindowProxy$I `window$m;
  [Replaceable] readonly attribute `WindowProxy$I `self$m;
  [`LegacyUnforgeable$] readonly attribute `Document$I `document$m;
  attribute DOMString `name$m;
  [PutForwards=`href$m, `LegacyUnforgeable$] readonly attribute `Location$I `location$m;
  readonly attribute `History$I `history$m;
  readonly attribute `CustomElementRegistry$I `customElements$m;
  [Replaceable] readonly attribute `BarProp$I `locationbar$m;
  [Replaceable] readonly attribute `BarProp$I `menubar$m;
  [Replaceable] readonly attribute `BarProp$I `personalbar$m;
  [Replaceable] readonly attribute `BarProp$I `scrollbars$m;
  [Replaceable] readonly attribute `BarProp$I `statusbar$m;
  [Replaceable] readonly attribute `BarProp$I `toolbar$m;
  attribute DOMString `status$m;
  undefined `close$m();
  readonly attribute boolean `closed$m;
  undefined `stop$m();
  undefined `focus$m();
  undefined `blur$m();

  /* <span class="comment">
他の閲覧~文脈
◎
other browsing contexts
</span> */
  [Replaceable] readonly attribute `WindowProxy$I `frames$m;
  [Replaceable] readonly attribute unsigned long `length$m;
  [`LegacyUnforgeable$] readonly attribute `WindowProxy$I? `top$m;
  attribute any `opener$m;
  [Replaceable] readonly attribute `WindowProxy$I? `parent$m;
  readonly attribute `Element$I? `frameElement$m;
  `WindowProxy$I? `open$m(
      optional USVString %url = "",
      optional DOMString %target = "_blank",
      optional [`LegacyNullToEmptyString$] DOMString %features = ""
  );

  /* <span class="comment">
これは大域~objなので、
~IDL有名~prop取得子は，~prototype-chain上に `NamedPropertiesObject^I ~exotic~objを追加する。
~~実際、
これが大域~objを~exotic~objにすることはない。
~indexによる~accessは `WindowProxy$I ~exotic~objが引き受ける。
◎
Since this is the global object, the IDL named getter adds a NamedPropertiesObject exotic object on the prototype chain. Indeed, this does not make the global object an exotic object. Indexed access is taken care of by the WindowProxy exotic object.
</span> */
  `getter＠#dom-window-nameditem$ `object$ (DOMString %name);

  /* <span class="comment">
~UA
◎
the user agent
</span> */
  readonly attribute `Navigator$I `navigator$m;
  readonly attribute `Navigator$I `clientInformation$m; /* <span class="comment">
`navigator^m の旧来の別名
◎
legacy alias of .navigator
</span> */
  readonly attribute boolean `originAgentCluster$m;
  /* <span class="comment">
利用者~向けの~prompt
◎
user prompts
</span> */
  undefined `alert$m0();
  undefined `alert$m(DOMString %message);
  boolean `confirm$m(optional DOMString %message = "");
  DOMString? `prompt$m(optional DOMString %message = "", optional DOMString %default = "");
  undefined `print$m();

  undefined `postMessage$m(any %message, USVString %targetOrigin, optional sequence&lt;`object$&gt; %transfer = []);
  undefined `postMessage$m0(any %message, optional `WindowPostMessageOptions$I %options = {});

  /* <span class="comment">
`廃用にされた~memberもある＠~HTMLLS/obsolete.html#Window-partial$
</span> */
};
`Window$I includes `GlobalEventHandlers$I;
`Window$I includes `WindowEventHandlers$I;

dictionary `WindowPostMessageOptions@I : `StructuredSerializeOptions$I {
  USVString `targetOrigin@m = "/";
};
</pre>

<dl class="domintro">
	<dt>%window.`window$m</dt>
	<dt>%window.`frames$m</dt>
	<dt>%window.`self$m</dt>
	<dd>
これらの属性はいずれも %window を返す。
◎
These attributes all return window.
</dd>

	<dt>%window.`document$m</dt>
	<dd>
%window に`結付けられている文書$を返す。
◎
Returns the Document associated with window.
</dd>

	<dt>%document.`defaultView$m</dt>
	<dd>
作動中の文書を`結付けている~window＠#concept-document-window$が［
在るならばそれ／
無いならば ~NULL
］を返す。
◎
Returns the Window associated with document, if there is one, or null otherwise.
</dd>
</dl>

<p>
各`~window$には、
それに
`結付けられている文書@
と呼ばれる，ある`文書$が結付けられる。
それは，`~window$の作成-時に`初期~about_blank な文書$に設定され、
変化するのは，そこから`~navigate$する間に限られる。
◎
The Window object has an associated Document, which is a Document object. It is set when the Window object is created, and only ever changed during navigation from the initial about:blank Document.
</p>

<p>
`~window$ %~window に
`対応する閲覧~文脈@
とは、
%~window に`結付けられている文書$が`属する閲覧~文脈$を指す
（これは、
~NULL または`閲覧~文脈$になる）。
◎
A Window's browsing context is its associated Document's browsing context. It is either null or a browsing context.
</p>

<p>
`~window$ %~window に
`対応する~navigable@
は、
次を満たす`~navigable$は［
在るならば それ／
無いならば ~NULL
］とする
⇒
その`作動中の文書$nav ~EQ %~window に`結付けられている文書$
◎
A Window's navigable is the navigable whose active document is the Window's associated Document's, or null if there is no such navigable.
</p>

<div class="algo">
［
`window@m
／
`frames@m
／
`self@m
］取得子~手続きは、
いずれも
⇒
~RET コレに`関連な~realm$.`GlobalEnv^sl.`GlobalThisValue^sl
◎
The window, frames, and self getter steps are to return this's relevant realm.[[GlobalEnv]].[[GlobalThisValue]].
</div>

<div class="algo">
<p>
`document@m
取得子~手続きは
⇒
~RET コレに`結付けられている文書$
◎
The document getter steps are to return this's associated Document.
</p>

<p class="note">注記：
`~window$に`結付けられている文書$が変化し得る事例は、
唯一，［
`~navi~algo$が，`閲覧~文脈$内に最初の~pageを読込むために`新たな文書を作成する＠~HTMLlifecycle#initialise-the-document-object$とき
］に限られる。
その事例では、
`初期~about_blank な文書$【！~page】の`~window$が再利用され，新たな`文書$を取得する。
◎
The Document object associated with a Window object can change in exactly one case: when the navigate algorithm creates a new Document object for the first page loaded in a browsing context. In that specific case, the Window object of the initial about:blank page is reused and gets a new Document object.
</p>
</div>

<div class="algo">
`Document$I の
`defaultView@m
取得子~手続きは
⇒
~RET コレが`属する閲覧~文脈$ %B に応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ %B の `WindowProxy$I ~obj
◎
The defaultView getter steps are:
• If this's browsing context is null, then return null.
• Return this's browsing context's WindowProxy object.
</div>

<hr>

<div class="p">
<p>
歴史的な理由から、
各`~window$は，次の特徴を備える~propを持つモノトスル：
</p>

<ul ><li>writable, configurable, 非 enumerable
</li><li>名前： `HTMLDocument@l
</li><li>値： `Document$I interface object
</li></ul>
◎
For historical reasons, Window objects must also have a writable, configurable, non-enumerable property named HTMLDocument whose value is the Document interface object.
</div>

				<section id="apis-for-creating-and-navigating-browsing-contexts-by-name">
<h5 title="Opening and closing windows">7.2.2.1. ~windowを開く／閉じる~API</h5>


<dl class="domintro">
	<dt>%window = %window.`open([ url [, target [, features ] ] ])$m</dt>
	<dd>
%url （省略時は "`~about_blank$sc" ）を示す~windowを開いて、
それを返す。
◎
Opens a window to show url (defaults to "about:blank"), and returns it.＼
</dd>
	<dd>
%target （省略時は `_blank^l ）は、
新たな~windowの名前を与える。
その名前の~windowがすでに存在する場合、
それが再利用される。
◎
target (defaults to "_blank") gives the name of the new window. If a window already exists with that name, it is reused.＼
</dd>
	<dd>
<p>
%features 引数は、
`~commaで分離された~token集合$を包含し得る：
◎
The features argument can contain a set of comma-separated tokens:
</p>
		<dl>
			<dt>`noopener^l</dt>
			<dt>`noreferrer^l</dt>
			<dd>
これらは順に，`~hyperlink$の~link型［
`noopener$v, `noreferrer$v
］と等価に挙動する。
◎
These behave equivalently to the noopener and noreferrer link types on hyperlinks.
</dd>
			<dt>`popup^l</dt>
			<dd>
新たな~window用には必要最小限な~web~browser~UIを供するよう，
~UAに奨励する。
（すべての `BarProp$I ~objの `visible$m 取得子にも影響iする。）
◎
Encourages user agents to provide a minimal web browser user interface for the new window. (Impacts the visible getter on all BarProp objects as well.)
</dd>
		</dl>
	</dd>
	<dd class="example">
<pre>
globalThis.open("https://email.example/message/CAOOOkFcWW97r8yg=SsWg7GgCmp4suVX9o85y8BvNRqMjuc5PXg", undefined, "noopener,popup");
</pre>
	</dd>

	<dt>%window.`name$m [ = %value ]</dt>
	<dd>
この~windowの名前を返す。
◎
Returns the name of the window.
</dd>
	<dd>
設定して，名前を変更できる。
◎
Can be set, to change the name.
</dd>

	<dt>%window.`close()$m</dt>
	<dd>
この~windowを閉じる。
◎
Closes the window.
</dd>

	<dt>%window.`closed$m</dt>
	<dd>
この~windowは［
すでに閉じられたなら ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the window has been closed, false otherwise.
</dd>

	<dt>%window.`stop()$m</dt>
	<dd>
文書の読込nを取消す。
◎
Cancels the document load.
</dd>
</dl>

<div class="algo">
<p>
`~window~open手続き@
は、
所与の
( 文字列 %~URL, 文字列 %~target, 文字列 %特能~群 )
に対し，次を走らす：
◎
The window open steps, given a string url, a string target, and a string features, are as follows:
</p>
<ol>
	<li>
~IF［
当の`~event~loop$の`終了n入子ng~level$ ~NEQ 0
］
⇒
~RET ~NULL
◎
If the event loop's termination nesting level is nonzero, return null.
</li>
	<li>
%~source文書 ~LET `入口~大域~obj$に`結付けられている文書$
◎
Let sourceDocument be the entry global object's associated Document.
</li>
	<li>
~IF［
%~target ~EQ 空~文字列
］
⇒
%~target ~SET `_blank^l
◎
If target is the empty string, then set target to "_blank".
</li>
	<li>
%特能~map ~LET `特能~群を~token化する$( %特能~群 )
◎
Let tokenizedFeatures be the result of tokenizing features.
</li>
	<li>
( %noopener, %noreferrer ) ~LET ( ~F, ~F )
◎
Let noopener and noreferrer be false.
</li>
	<li>
~IF［
%特能~map[ `noopener^l ] ~NEQ ε
］
⇒＃
%noopener ~SET `真偽-特能を構文解析する$( %特能~map[ `noopener^l ] )；
%特能~map[ `noopener^l ] ~SET ε
◎
If tokenizedFeatures["noopener"] exists, then:
• Set noopener to the result of parsing tokenizedFeatures["noopener"] as a boolean feature.
• Remove tokenizedFeatures["noopener"].
</li>
	<li>
~IF［
%特能~map[ `noreferrer^l ] ~NEQ ε
］
⇒＃
%noreferrer ~SET `真偽-特能を構文解析する$( %特能~map[ `noreferrer^l ] )；
%特能~map[ `noreferrer^l ] ~SET ε
◎
If tokenizedFeatures["noreferrer"] exists, then:
• Set noreferrer to the result of parsing tokenizedFeatures["noreferrer"] as a boolean feature.
• Remove tokenizedFeatures["noreferrer"].
</li>
	<li>
%~referrer施策 ~LET 空~文字列
◎
Let referrerPolicy be the empty string.
</li>
	<li>
~IF［
%noreferrer ~EQ ~T
］
⇒＃
%noopener ~SET ~T；
%~referrer施策 ~SET `no-referrer^l
◎
If noreferrer is true, then set noopener to true and set referrerPolicy to "no-referrer".
</li>
	<li>
<p>
( %~target~navigable, %~window種別 ) ~LET
`~navigableを選ぶ規則$を適用する( %~target, %~source文書 の`~node~navigable$, %noopener )
◎
Let targetNavigable and windowType be the result of applying the rules for choosing a navigable given target, sourceDocument's node navigable, and noopener.
</p>

<p class="example">
例えば、
~UAが［
<kbd>control</kbd>＋~clickにより，~linkを新たな~UItabに開く
］ことを~supportしていて，利用者が［
要素に対し それを行った
］とき，対する `onclick^m ~handlerは［
`iframe$e 内に~pageを開くために `window.open()＠#dom-window-open$c ~APIを利用していた
］場合、
~UAは［
~target閲覧~文脈の選定を上書きして，新たな~UItabを~targetにする
］こともできる。
◎
If there is a user agent that supports control-clicking a link to open it in a new tab, and the user control-clicks on an element whose onclick handler uses the window.open() API to open a page in an iframe element, the user agent could override the selection of the target browsing context to instead target a new tab.
</p>
	</li>
	<li>
~IF［
%~target~navigable ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If targetNavigable is null, then return null.
</li>
	<li>
<p>
~IF［
%~window種別 ~IN { `制約されない新たな^i, `~openerが無い新たな^i }
］：
◎
If windowType is either "new and unrestricted" or "new with no opener", then:
</p>
		<ol>
			<li>
%~target~navigable にて`作動中の閲覧~文脈$navの`~popupか$bc ~SET 
`~popup~windowが要請されたか否か検査する$( %特能~map )
◎
Set targetNavigable's active browsing context's is popup to the result of checking if a popup window is requested, given tokenizedFeatures.
</li>
			<li>
`閲覧~文脈の特能を設定しておく$( %~target~navigable にて`作動中の閲覧~文脈$nav, %特能~map )
`CSSOMVIEW$r
◎
Set up browsing context features for targetNavigable's active browsing context given tokenizedFeatures.[CSSOMVIEW]
</li>
			<li>
%~URL~record ~LET `~URL~record$ `~about_blank$sc
◎
Let urlRecord be the URL record about:blank.
</li>
			<li>
<p>
~IF［
%~URL ~NEQ 空~文字列
］：
◎
If url is not the empty string, then＼
</p>
				<ol>
					<li>
%~URL~record ~LET `相対的に~URL構文解析する$( %~URL, `入口~設定群~obj$ )
◎
parse url relative to the entry settings object, and set urlRecord to the resulting URL record, if any.＼
</li>
					<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If the parse a URL algorithm failed, then throw a "SyntaxError" DOMException.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~URL~record は`~about_blank に合致して$いる
］
⇒
`~URLと履歴を更新する$( %~target~navigable にて`作動中の文書$nav, %~URL~record )
◎
If urlRecord matches about:blank, then perform the URL and history update steps given targetNavigable's active document and urlRecord.
</p>

<p class="note">注記：
この段は、
%~URL が `about:blank?foo^l の様な何かである事例で必要とされる。
%~URL は単に素な `~about_blank^sc の場合、
この段は何もしない。
◎
This is necessary in case url is something like about:blank?foo. If url is just plain about:blank, this will do nothing.
</p>
			</li>
			<li>
~ELSE
⇒
`~navigableを~URLへ~navigateする$( %~target~navigable, %~URL~record, %~source文書 )
— 次も与える下で
⇒＃
`~referrer施策$i ~SET %~referrer施策,
`例外を可能化するか$i ~SET ~T
◎
Otherwise, navigate targetNavigable to urlRecord using sourceDocument, with referrerPolicy set to referrerPolicy and exceptionsEnabled set to true.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
<p>
~IF［
%~URL ~NEQ 空~文字列
］：
◎
If url is not the empty string, then:
</p>
				<ol>
					<li>
%~URL~record ~LET `~URL~record$ `~about_blank$sc
◎
Let urlRecord be the URL record about:blank.
</li>
					<li>
%~URL~record ~SET `相対的に~URL構文解析する$( %~URL, `入口~設定群~obj$ )
◎
Parse url relative to the entry settings object, and set urlRecord to the resulting URL record, if any.＼
</li>
					<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If the parse a URL algorithm failed, then throw a "SyntaxError" DOMException.
</li>
					<li>
`~navigableを~URLへ~navigateする$(  %~target~navigable, %~URL~record, %~source文書 )
— 次も与える下で
⇒＃
`~referrer施策$i ~SET %~referrer施策,
`例外を可能化するか$i ~SET ~T
◎
Navigate targetNavigable to urlRecord using sourceDocument, with referrerPolicy set to referrerPolicy and exceptionsEnabled set to true.
</li>
				</ol>
			</li>
			<li>
~IF［
%noopener ~EQ ~F
］
⇒
%~target~navigable にて`作動中の閲覧~文脈$navを`開いた閲覧~文脈$bc ~SET %~source文書 が`属する閲覧~文脈$
◎
If noopener is false, then set targetNavigable's active browsing context's opener browsing context to sourceDocument's browsing context.
</li>
		</ol>
	</li>
	<li>
~IF［
%noopener ~EQ ~T
］~OR［
%~window種別 ~EQ `~openerが無い新たな^i
］
⇒
~RET ~NULL
◎
If noopener is true or windowType is "new with no opener", then return null.
</li>
	<li>
~RET %~target~navigable にて`作動中の~WindowProxy$nav
◎
Return targetNavigable's active WindowProxy.
</li>
</ol>
</div>

<div class="algo">
<p>
`open(url, target, features)@m
~method手続きは
⇒
`~window~open手続き$( %url, %target, %features )
◎
The open(url, target, features) method steps are to run the window open steps with url, target, and features.
</p>

<p class="note">注記：
この~methodは、［
既存の`閲覧~文脈$を`~navigate$する ／
`補助~閲覧~文脈$を開いて~navigateする
］ための仕組みを供する。
◎
The method provides a mechanism for navigating an existing browsing context or opening and navigating an auxiliary browsing context.
</p>
</div>

<hr>

<div class="algo">
<p>
`特能~群を~token化する@
ときは、
所与の
( 文字列 %特能~群 )
に対し，次を走らす：
◎
To tokenize the features argument:
</p>
<ol>
	<li>
%特能~map ~LET 新たな`有順序~map$
◎
Let tokenizedFeatures be a new ordered map.
</li>
	<li>
%位置 ~LET %特能~群 の最初の符号位置を指している`位置~変数$
◎
Let position point at the first code point of features.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of features:
</p>
		<ol>
			<li>
%名前 ~LET 空~文字列
◎
Let name be the empty string.
</li>
			<li>
%値 ~LET 空~文字列
◎
Let value be the empty string.
</li>
			<li>
%特能~群 内の %位置 から，`特能~分離子$である`符号位置~並びを収集する$
— これは、
特能~名より前に現れる分離子を読飛ばす
◎
Collect a sequence of code points that are feature separators from features given position. This skips past leading separators before the name.
</li>
			<li>
%名前 ~SET %特能~群 内の %位置 から，`特能~分離子$でない`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not feature separators from features given position.＼
</li>
			<li>
%名前 ~SET `~ASCII小文字~化する$( %名前 )
◎
Set name to the collected characters, converted to ASCII lowercase.
</li>
			<li>
%名前 ~SET `特能~名として正規化する$( %名前 )
◎
Set name to the result of normalizing the feature name name.
</li>
			<li>
<p>
~WHILE［
%位置↗ ~NIN { ε, `003D^U `=^smb }
］
◎
While position is not past the end of features and the code point at position in features is not U+003D (=):
</p>
				<ol>
					<li>
~IF［
%位置↗ ~EQ `002C^U `,^smb
］~OR［
%位置↗ ~NIN { `特能~分離子$ }
］
⇒
~BREAK
◎
If the code point at position in features is U+002C (,), or if it is not a feature separator, then break.
</li>
					<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
				</ol>

<p class="note">注記：
これは、
最初の `003D^U `=^smb まで, かつ［
`002C^U `,^smb ／ 非~分離子
］を過ぎない所まで読飛ばす
◎
This skips to the first U+003D (=) but does not skip past a U+002C (,) or a non-separator.
</p>
			</li>
			<li>
<p>
~IF［
%位置↗ ~IN { `特能~分離子$ }
］：
◎
If the code point at position in features is a feature separator:
</p>

				<ol>
					<li>
<p>
~WHILE［
%位置↗ ~IN { `特能~分離子$ }
］：
◎
While position is not past the end of features and the code point at position in features is a feature separator:
</p>

						<ol>
							<li>
~IF［
%位置↗ ~EQ `002C^U `,^smb
］
⇒
~BREAK
◎
If the code point at position in features is U+002C (,), then break.
</li>
							<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
						</ol>

<p class="note">注記：
これは、
最初の非~分離子まで, かつ `002C^U `,^smb を過ぎない所まで読飛ばす
◎
This skips to the first non-separator but does not skip past a U+002C (,).
</p>
					</li>
					<li>
%値 ~SET %特能~群 内の %位置 から，`特能~分離子$でない`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not feature separators code points from features given position.＼
</li>
					<li>
%値 ~SET `~ASCII小文字~化する$( %値 )
◎
Set value to the collected code points, converted to ASCII lowercase.
</li>
				</ol>
			</li>
			<li>
~IF［
%名前 ~NEQ 空~文字列
］
⇒
%特能~map[ %名前 ] ~SET %値
◎
If name is not the empty string, then set tokenizedFeatures[name] to value.
</li>
		</ol>
	</li>
	<li>
~RET %特能~map
◎
Return tokenizedFeatures.
</li>
</ol>
</div>


<div class="algo">
<p>
`~window特能は設定されたか否か検査する@
ときは、
所与の
( %特能~map, %特能~名, %既定~値 )
に対し：
◎
To check if a window feature is set, given tokenizedFeatures, featureName, and defaultValue:
</p>
<ol>
	<li>
~IF［
%特能~map[ %特能~名 ] ~NEQ ε
］
⇒
~RET `真偽-特能を構文解析する$( %特能~map[ %特能~名 ] )
◎
If tokenizedFeatures[featureName] exists, then return the result of parsing tokenizedFeatures[featureName] as a boolean feature.
</li>
	<li>
~RET %既定~値
◎
Return defaultValue.
</li>
</ol>
</div>

<div class="algo">
<p>
`~popup~windowが要請されたか否か検査する@
ときは、
所与の
( %特能~map )
に対し：
◎
To check if a popup window is requested, given tokenizedFeatures:
</p>
<ol>
	<li>
~IF［
%特能~map は`空$mapである
］
⇒
~RET ~F
◎
If tokenizedFeatures is empty, then return false.
</li>
	<li>
~IF［
%特能~map[ `popup^l ] ~NEQ ε
］
⇒
~RET `真偽-特能を構文解析する$( %特能~map[ `popup^l ] )
◎
If tokenizedFeatures["popup"] exists, then return the result of parsing tokenizedFeatures["popup"] as a boolean feature.
</li>
	<li>
%location ~LET `~window特能は設定されたか否か検査する$( %特能~map, `location^l, ~F )
◎
Let location be the result of checking if a window feature is set, given tokenizedFeatures, "location", and false.
</li>
	<li>
%toolbar ~LET `~window特能は設定されたか否か検査する$( %特能~map, `toolbar^l, ~F )
◎
Let toolbar be the result of checking if a window feature is set, given tokenizedFeatures, "toolbar", and false.
</li>
	<li>
~IF［
%location ~EQ ~F
］~AND［
%toolbar ~EQ ~F
］
⇒
~RET ~T
◎
If location and toolbar are both false, then return true.
</li>
	<li>
%menubar ~LET `~window特能は設定されたか否か検査する$( %特能~map, `menubar^l, ~F )
◎
Let menubar be the result of checking if a window feature is set, given tokenizedFeatures, menubar", and false.
</li>
	<li>
~IF［
%menubar ~EQ ~F
］
⇒
~RET ~T
◎
If menubar is false, then return true.
</li>
	<li>
%resizable ~LET `~window特能は設定されたか否か検査する$( %特能~map, `resizable^l, ~T )
◎
Let resizable be the result of checking if a window feature is set, given tokenizedFeatures, "resizable", and true.
</li>
	<li>
~IF［
%resizable ~EQ ~F
］
⇒
~RET ~T
◎
If resizable is false, then return true.
</li>
	<li>
%scrollbars ~LET `~window特能は設定されたか否か検査する$( %特能~map, `scrollbars^l, ~F )
◎
Let scrollbars be the result of checking if a window feature is set, given tokenizedFeatures, "scrollbars", and false.
</li>
	<li>
~IF［
%scrollbars ~EQ ~F
］
⇒
~RET ~T
◎
If scrollbars is false, then return true.
</li>
	<li>
%status ~LET `~window特能は設定されたか否か検査する$( %特能~map, `status^l, ~F )
◎
Let status be the result of checking if a window feature is set, given tokenizedFeatures, "status", and false.
</li>
	<li>
~IF［
%status ~EQ ~F
］
⇒
~RET ~T
◎
If status is false, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<p>
次に挙げる符号位置は、
`特能~分離子@
とされる
⇒＃
`~ASCII空白$,
`003D^U `=^smb,
`002C^U `,^smb
◎
A code point is a feature separator if it is ASCII whitespace, U+003D (=), or U+002C (,).
</p>

<div class="algo">
<p>
旧来の理由から、
一部の特能~名には別名がある。
所与の %名前 を
`特能~名として正規化する@
ときは、
%名前 に応じて，次の表の 2 列目に与える結果を返す：
</p>

<table>
<thead><tr><th>%名前
<th>結果
</thead><tbody>

<tr><td>`screenx^l
<td>`left^l
<tr><td>`screeny^l
<td>`top^l
<tr><td>`innerwidth^l
<td>`width^l
<tr><td>`innerheight^l
<td>`height^l
<tr><td>その他
<td>%名前
</tbody></table>

◎
For legacy reasons, there are some aliases of some feature names. To normalize a feature name name, switch on name:
◎
"screenx"
• Return "left".
"screeny"
• Return "top".
"innerwidth"
• Return "width".
"innerheight"
• Return "height".
Anything else
• Return name.
</div>

<div class="algo">
<p>
`真偽-特能を構文解析する@
ときは、
所与の
( 文字列 %値 )
に対し，［
次のいずれかが満たされるならば ~T ／
~ELSE_ ~F
］を返す：
◎
To parse a boolean feature given a string value:
</p>
<ul>
	<li>
%値 ~IN【！identical】 { 空~文字列, `yes^l, `true^l }
◎
If value is the empty string, then return true.
◎
If value is "yes", then return true.
◎
If value is "true", then return true.
</li>
	<li>
次の結果 ~NIN { `失敗^i, 0 }
⇒
`整数として構文解析する$( %値 )
◎
Let parsed be the result of parsing value as an integer.
◎
If parsed is an error, then set it to 0.
◎
Return false if parsed is 0, and true otherwise.
</li>
</ul>
</div>

<div class="algo">
`name@m
取得子~手続きは
⇒
~RET コレに`対応する~navigable$ %N に応じて
⇒＃
~NULL ならば 空~文字列 ／
~ELSE_ %N の`~target名$nav
◎
The name getter steps are:
• If this's navigable is null, then return the empty string.
• Return this's navigable's target name.
</div>

<div class="algo">
<p>
`name$m 設定子~手続きは
◎
The name setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`対応する~navigable$ ~EQ ~NULL
］
⇒
~RET
◎
If this's navigable is null, then return.
</li>
	<li>
コレに`対応する~navigable$にて`作動中の~session履歴~entry$navの`文書~状態$shEの`~navigable名$dS ~SET 所与の値
◎
Set this's navigable's active session history entry's document state's navigable target name to the given value.
</li>
</ol>

<p class="note">注記：
名前は、
~navigable が別の`生成元$へ`~navigate$されたときは，
`設定し直される＠~HTMLnav#resetBCName$。
◎
The name gets reset when the navigable is navigated to another origin.
</p>
</div>

<div class="algo">
<p>
`close()@m
~method手続きは：
◎
The close() method steps are:
</p>
<ol>
	<li>
%この辿可能 ~LET ~NULL
◎
Let thisTraversable be null.
</li>
	<li>
~UAの`~top-level辿可能~集合$を成す
~EACH( `~top-level辿可能$ %辿可能 )
に対し
⇒
~IF［
%辿可能 にて`作動中の文書$navの`関連な大域~obj$ ~EQ コレ
］
⇒
%この辿可能 ~SET %辿可能；
~BREAK
◎
For each top-level traversable traversable of the user agent's top-level traversable set: if traversable's active document's relevant global object equals this, then set thisTraversable to traversable and break.
</li>
	<li>
<p>
~IF［
%この辿可能 ~EQ ~NULL
］
⇒
~RET
◎
If thisTraversable is null, then return.
</p>

<p class="note">注記
この事例では、
この~methodは［
`~top-level辿可能$に対応しない`~window$
］上で~callされているので，閉じるのは許容されない。
◎
In this case the method is being called on a Window that does not correspond to a top-level traversable, and so closing is not allowed.
</p>
	</li>
	<li>
~IF［
%この辿可能 の`閉中か$nav ~EQ ~T
］
⇒
~RET
◎
If thisTraversable's is closing is true, then return.
</li>
	<li>
%閲覧~文脈 ~LET %この辿可能 にて`作動中の閲覧~文脈$nav
◎
Let browsingContext be thisTraversable's active browsing context.
</li>
	<li>
%~source~snapshot~params ~LET `~source~snapshot~paramsを~snapshotする$( %この辿可能 にて`作動中の文書$nav )
◎
Let sourceSnapshotParams be the result of snapshotting source snapshot params given thisTraversable's active document.
</li>
	<li>
<p>
~IF［
次がいずれも満たされる
］…：
◎
If all the following are true:
</p>
		<ul>
			<li>
%この辿可能 は`~scriptから閉じれる$
◎
thisTraversable is script-closable;
</li>
			<li>
`現任な大域~obj$に`対応する閲覧~文脈$は %閲覧~文脈 に`近しい$
◎
the incumbent global object's browsing context is familiar with browsingContext; and
</li>
			<li id="sandboxClose">
`現任な大域~obj$の`~node~navigable$が %この辿可能 を`~navigateすることは~sandbox法により許容される$( %~source~snapshot~params )
◎
the incumbent global object's node navigable is allowed by sandboxing to navigate thisTraversable, given sourceSnapshotParams
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
%この辿可能 の`閉中か$nav ~SET ~T
◎
Set thisTraversable's is closing to true.
</li>
			<li class="algo">
次を走らす`~taskを~queueする$( `~DOM操作~task源$ )
⇒
`~top-level辿可能を閉じる$( %この辿可能 )
◎
Queue a task on the DOM manipulation task source to close thisTraversable.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
次のいずれかを満たす`~navigable$は、
`~scriptから閉じれる@
とされる：
◎
A navigable is script-closable if＼
</p>
<ul>
	<li>
それにて`作動中の閲覧~文脈$navは、
~scriptが作成した`補助~閲覧~文脈$である
（利用者による動作ではなく）
◎
its active browsing context is an auxiliary browsing context that was created by a script (as opposed to by an action of the user),＼
</li>
	<li>
次を満たす`~top-level辿可能$である
⇒
その`~session履歴~entry群$navの`~size$ ~EQ 1
◎
or if it is a top-level traversable whose session history entries's size is 1.
</li>
</ul>

<div class="algo">
`closed@m
取得子~手続きは
⇒
~RET ［
コレに`対応する閲覧~文脈$ %B が次を満たすならば ~T ／
~ELSE_ ~F
］
⇒
［
%B ~EQ ~NULL
］~OR［
%B の`閉中か$nav ~EQ ~T
］
◎
The closed getter steps are to return true if this's browsing context is null or its is closing is true; otherwise false.
</div>

<div class="algo">
<p>
`stop()@m
~method手続きは：
◎
The stop() method steps are:
</p>
<ol>
	<li>
%~navigable ~LET コレに`対応する~navigable$
◎
↓</li>
	<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
~RET
◎
If this's navigable is null, then return.
</li>
	<li>
`読込ngを停止する$( %~navigable )
◎
Stop loading this's navigable.
</li>
</ol>
</div>

				</section>
				<section id="accessing-other-browsing-contexts">
<h5 title="Indexed access on the Window object">7.2.2.2. `Window^I ~obj上の有index~access</h5>

<dl class="domintro">
	<dt>%window.`length$m</dt>
	<dd>
`文書~treeに属する子~navigable群$の~size【！the number of】を返す。
◎
Returns the number of document-tree child navigables.
</dd>

	<dt>%window[%index]</dt>
	<dd>
%index で指示される［
`文書~treeに属する子~navigable群$内の~navigable
］に対応している `WindowProxy$I を返す。
◎
Returns the WindowProxy corresponding to the indicated document-tree child navigables.
</dd>
</dl>

<div class="algo">
<p>
`length@m
取得子~手続きは
⇒
~RET コレに`結付けられている文書$の`文書~treeに属する子~navigable群$の`~size$
◎
The length getter steps are to return this's associated Document's document-tree child navigables's size.
</p>

<p class="note">注記：
~indexによる`文書~treeに属する子~navigable群$への~accessは、
`WindowProxy$I ~objの `GetOwnProperty$sl 内部~methodを通して定義される。
◎
Indexed access to document-tree child navigables is defined through the [[GetOwnProperty]] internal method of the WindowProxy object.
</p>
</div>

				</section>
				<section id="named-access-on-the-window-object">
<h5 title="Named access on the Window object">7.2.2.3. `Window^I ~objに対する名前による~access</h5>

<dl class="domintro">
	<dt>%window[%name]</dt>
	<dd>
指示された要素（たち）の~collectionを返す。
◎
Returns the indicated element or collection of elements.
</dd>
	<dd>
一般に、
これに依拠すると，~codeは壊れやすくなる。
例えば、［
~web~platformに新たな特能が追加されるに伴い，
どの~IDがこの~APIに対応付けられるか
］は，時を経れば変わり得るので。
代わりに，
`document.getElementById()^m ／
`document.querySelector()^m
を利用すること。
◎
As a general rule, relying on this will lead to brittle code. Which IDs end up mapping to this API can vary over time, as new features are added to the web platform, for example. Instead of this, use document.getElementById() or document.querySelector().
</dd>
</dl>

<div class="algo">
<p>
所与の`~window$ %~window の
`文書~treeに属する子~navigable~target名~prop集合@
は、
次の手続きが返す結果で与えられる：
◎
The document-tree child navigable target name property set of a Window object window is the return value of running these steps:
</p>
<ol>
	<li>
%子~群 ~LET %~window に`結付けられている文書$の`文書~treeに属する子~navigable群$
◎
Let children be the document-tree child navigables of window's associated Document.
</li>
	<li>
<p>
%有名~子~群 ~LET 新たな`有順序~map$
◎
Let firstNamedChildren be an empty ordered set.
</p>

<p class="trans-note">【
原文では`有順序~集合$を利用しているが、
`有順序~map$の方がずっと~logicが簡潔になるので，改めている。
】</p>
	</li>
	<li>
<p>
%子~群 を成す
~EACH( %~navigable )
に対し：
◎
For each navigable of children:
</p>
		<ol>
			<li>
%名前 ~LET %~navigable の`~target名$nav
◎
Let name be navigable's target name.
</li>
			<li>
~IF［
%名前 ~NEQ 空~文字列
］~AND［
%有名~子~群[ %名前 ] ~EQ ε
］
⇒
%有名~子~群[ %名前 ] ~SET %~navigable
◎
If name is the empty string, then continue.
◎
If firstNamedChildren contains a navigable whose target name is name, then continue.
◎
Append navigable to firstNamedChildren.
</li>
		</ol>
	</li>
	<li>
%名前~群 ~LET 新たな`有順序~集合$
◎
Let names be an empty ordered set.
</li>
	<li>
%有名~子~群 を成す
~EACH( %名前 → %~navigable )
に対し
⇒
~IF［
( %~navigable の`作動中の文書$navの`生成元$doc, %~window に`関連な設定群~obj$の`生成元$enV )
は`同一-生成元$である
］
⇒
%名前~群 に %名前 を`付加する$
◎
For each navigable of firstNamedChildren:
• Let name be navigable's target name.
• If navigable's active document's origin is same origin with window's relevant settings object's origin, then append name to names.
</li>
	<li>
~RET %名前~群
◎
Return names.
</li>
</ol>
</div>

<div class="example">
<p>
上の手続きにおける 2 つの別々な反復は、
次を意味する：
例えば次の~pageが
`https://example.org/^c
にて~hostされていて，
`https://elsewhere.example/^c
の `iframe^e の `name$m が `spices^l に設定されたとするとき、［
すべてが読込まれた後に `window.spices^c を評価した結果
］は `undefined^jv 【すなわち， `spices^l ~NIN %名前~群 】になる：
◎
The two seperate iterations mean that in the following example, hosted on https://example.org/, assuming https://elsewhere.example/ sets window.name to "spices", evaluating window.spices after everything has loaded will yield undefined:
</p>

<pre class="lang-html">
&lt;iframe src=https://elsewhere.example.com/&gt;&lt;/iframe&gt;
&lt;iframe name=spices&gt;&lt;/iframe&gt;
</pre>
</div>

<p>
各`~window$は、
`有名~propを~supportする$。
所与の任意の時点における`~window$ %~window が`~supportする~prop名$は、
次に挙げるものからなる：
◎
The Window object supports named properties. The supported property names of a Window object window at any moment consist of the following, in tree order according to the element that contributed them, ignoring later duplicates:
</p>

<ul>
	<li>
%~window の`文書~treeに属する子~navigable~target名~prop集合$
◎
window's document-tree child navigable target name property set;
</li>
	<li>
<p>
%~window 内にある`有名~要素$の`要素~名$
— `要素~名$が同じものが複数あるときは、
`~tree順序$で最初のもの以外は無視する。
</p>

<p>
%~window 内にある
`有名~要素@,
およびその
`要素~名@
は、［
%~window に`結付けられている文書$を`根$とする`文書~tree内$にある`~HTML要素$
］のうち，次のいずれかに該当する要素, および 対応する名前である：
</p>
		<ul>
			<li>
［
`embed$e, `form$e, `img$e, `object$e
］要素のうち，［
`name^a 内容~属性を有していて，その値 ~NEQ 空~文字列
］なるもの
— その属性~値が`要素~名$を与える
</li>
			<li>
［
`id$a 内容~属性を有していて，その値 ~NEQ 空~文字列
］なるもの
— その属性~値が`要素~名$を与える
</li>
		</ul>

<p class="trans-note">【
`有名~要素$, `要素~名$は、
記述を論理的に集約するためにこの訳に導入した用語であり，この節でしか利用されない。
】</p>

◎
the value of the name content attribute for all embed, form, img, and object elements that have a non-empty name content attribute and are in a document tree with window's associated Document as their root; and
◎
the value of the id content attribute for all HTML elements that have a non-empty id content attribute and are in a document tree with window's associated Document as their root.
</li>
</ul>

<div class="algo">
<p id="dom-window-nameditem">
`~window$ %~window において，所与の %名前 に対し`有名~propの値を決定する$ときは、
次の手続きの結果を返すモノトスル：
◎
To determine the value of a named property name in a Window object window, the user agent must return the value obtained using the following steps:
</p>
<ol>
	<li>
~Assert：
%名前 は %~window が`~supportする~prop名$である
【この段は、この訳による補完。】
</li>
	<li>
%~obj群 ~LET %~window の［
名前 %名前 を伴う`有名~obj$
］からなる~list
◎
Let objects be the list of named objects of window with the name name.
</li>
	<li>
~Assert【！Note → Assert】：
%~obj群 は空でない
— 空ならば、
この~algoが`~Web~IDLにより呼出され＠~WEBIDLjs#named-properties-object-getownproperty$ることはないので。
◎
There will be at least one such object, since the algorithm would otherwise not have been invoked by Web IDL.
</li>
	<li>
<p>
~IF［
%~obj群 を成す ある~itemは`~navigable$である
］：
◎
If objects contains a navigable, then:
</p>
		<ol>
			<li>
%容器 ~LET %~window に`結付けられている文書$の`子孫$のうち次を満たす最初のもの
⇒
［
`~navigable容器$である
］~AND［
%容器 の`内容~navigable$ ~IN %~obj群
］
◎
Let container be the first navigable container in window's associated Document's descendants whose content navigable is in objects.
</li>
			<li>
~RET %容器 の`内容~navigable$にて`作動中の~WindowProxy$nav
◎
Return container's content navigable's active WindowProxy.
</li>
		</ol>
	</li>
	<li>
~Assert：
%~obj群 は要素のみからなる
◎
↓</li>
	<li>
~IF［
%~obj群 は 1 個の要素のみからなる
］
⇒
~RET その要素
◎
Otherwise, if objects has only one element, return that element.
</li>
	<li>
~RET 次のようにされた `HTMLCollection$I
⇒＃
根： %~window に`結付けられている文書$,
~filter： %~obj群 内にある要素のみに合致する
◎
Otherwise return an HTMLCollection rooted at window's associated Document, whose filter matches only named objects of window with the name name. (By definition, these will all be elements.)
</li>
</ol>
</div>

<p>
`~window$ %~window の［
名前 %名前 を伴う
`有名~obj@
］は、
次に挙げるものからなる：
◎
Named objects of Window object window with the name name, for the purposes of the above algorithm, consist of the following:
</p>

<ul>
	<li>
%~window に`結付けられている文書$の
`文書~treeに属する子~navigable群$のうち，［
その`~target名$nav ~EQ %名前
］なるもの
◎
document-tree child navigables of window's associated Document whose target name is name;
</li>
	<li>
%~window 内にある`有名~要素$のうち，［
その`要素~名$ ~EQ %名前
］なるもの
◎
embed, form, img, or object elements that have a name content attribute whose value is name and are in a document tree with window's associated Document as their root; and
◎
HTML elements that have an id content attribute whose value is name and are in a document tree with window's associated Document as their root.
</li>
</ul>

<p class="note">注記：
`Window$I ~interfaceは，
`Global$xA 拡張属性を伴うので、
その有名~propたちは，［
`旧来の~platform~obj$ではなく，`有名~prop群~obj$
］用の規則に従う。
◎
Since the Window interface has the [Global] extended attribute, its named properties follow the rules for named properties objects rather than legacy platform objects.
</p>

				</section>
				<section id="navigating-nested-browsing-contexts-in-the-dom">
<h5 title="Accessing related windows">7.2.2.4. 関係する~windowへの~access法</h5>

<dl class="domintro">
	<dt>%window.`top$m</dt>
	<dd>
`~top-level辿可能$用の `WindowProxy$I を返す。
◎
Returns the WindowProxy for the top-level traversable.
</dd>

	<dt>%window.`opener$m [ = %value ]</dt>
	<dd>
`開いた閲覧~文脈$bc用の `WindowProxy$I を返す。
◎
Returns the WindowProxy for the opener browsing context.
</dd>
	<dd>
そのような閲覧~文脈は無い, あるいは ~NULL に設定された場合、
~NULL を返す。
◎
Returns null if there isn't one or if it has been set to null.
</dd>
	<dd>
~NULL に設定できる。
◎
Can be set to null.
</dd>

	<dt>%window.`parent$m</dt>
	<dd>
`親~navigable$用の `WindowProxy$I を返す。
◎
Returns the WindowProxy for the parent navigable.
</dd>

	<dt>%window.`frameElement$m</dt>
	<dd>
`~navigable容器$を与えている要素を返す。
◎
Returns the navigable container element.
</dd>
	<dd>
そのようなものがない, または “非同一-生成元 状況” にある場合、
~NULL を返す。
◎
Returns null if there isn't one, and in cross-origin situations.
</dd>
</dl>

<div class="algo">
<p>
`top@m
取得子~手続きは：
◎
The top getter steps are:
</p>
<ol>
	<li>
%~navigable ~LET コレに`対応する~navigable$
◎
↓</li>
	<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If this's navigable is null, then return null.
</li>
	<li>
~RET %~navigable の`~top-level辿可能$navにて`作動中の~WindowProxy$nav
◎
Return this's navigable's top-level traversable's active WindowProxy.
</li>
</ol>
</div>

<div class="algo">
<p>
`opener@m
取得子~手続きは：
◎
The opener getter steps are:
</p>
<ol>
	<li>
%B ~LET コレに`対応する閲覧~文脈$
◎
Let current be this's browsing context.
</li>
	<li>
~IF［
%B ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If current is null, then return null.
</li>
	<li>
~IF［
%B を`開いた閲覧~文脈$bc ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If current's opener browsing context is null, then return null.
</li>
	<li>
~RET %B を`開いた閲覧~文脈$bcの `WindowProxy$I ~obj
◎
Return current's opener browsing context's WindowProxy object.
</li>
</ol>
</div>

<div class="algo">
<p>
`opener$m
設定子~手続きは：
◎
The opener setter steps are:
</p>
<ol>
	<li>
~IF［
所与の値 ~NEQ ~NULL
］
⇒
【！return】
~ABRUPT `OrdinaryDefineOwnProperty$jA( コレ, `opener^l, {
`Value^sl: 所与の値,
`Writable^sl: ~T,
`Enumerable^sl: ~T,
`Configurable^sl: ~T
}
)
</li>
	<li>
~ELIF［
コレに`対応する閲覧~文脈$ ~NEQ ~NULL
］
⇒＃
コレに`対応する閲覧~文脈$を`開いた閲覧~文脈$bc ~SET ~NULL
</li>
</ol>
◎
The opener setter steps are:
• If the given value is null and this's browsing context is non-null, then set this's browsing context's opener browsing context to null.
• If the given value is non-null, then return ? OrdinaryDefineOwnProperty(this, "opener", { [[Value]]: the given value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }).
</div>

<div class="note">
<p>注記：
`~window$の `opener$m を ~NULL に設定すると，
それを`開いた閲覧~文脈$bc %B への参照を~clearする。
これは，実施においては、
~scriptが未来に %B に対応する`~window$へ~accessすることを防止する。
◎
Setting window.opener to null clears the opener browsing context reference. In practice, this prevents future scripts from accessing their opener browsing context's Window object.
</p>

<p>
既定では，~scriptは、
`opener$m 取得子を通して，
%B に対応する`~window$へ~accessできる
— 例：
~scriptは、
`window.opener.location^c を設定でき，
%B を~navigateさせれる。
◎
By default, scripts can access their opener browsing context's Window object through the window.opener getter. E.g., a script can set window.opener.location, causing the opener browsing context to navigate.
</p>
</div>

<div class="algo">
<p>
`parent@m
取得子~手続きは：
◎
The parent getter steps are:
</p>
<ol>
	<li>
%~navigable ~LET コレに`対応する~navigable$
◎
Let navigable be this's navigable.
</li>
	<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If navigable is null, then return null.
</li>
	<li>
~IF［
%~navigable の`親$nav ~NEQ ~NULL
］
⇒
%~navigable ~SET %~navigable の`親$nav
◎
If navigable's parent is not null, then set navigable to navigable's parent.
</li>
	<li>
~RET %~navigable にて`作動中の~WindowProxy$nav
◎
Return navigable's active WindowProxy.
</li>
</ol>
</div>

<div class="algo">
<p>
`frameElement@m
取得子~手続きは：
◎
The frameElement getter steps are:
</p>
<ol>
	<li>
%N ~LET コレの`~node~navigable$
◎
Let current be this's node navigable.
</li>
	<li>
~IF［
%N ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If current is null, then return null.
</li>
	<li>
%容器 ~LET %N の`容器$nav
◎
Let container be current's container.
</li>
	<li>
~IF［
%容器 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If container is null, then return null.
</li>
	<li>
~IF［
( %容器 の`~node文書$の`生成元$doc, `現在の設定群~obj$の`生成元$enV )
は`同じ生成元~domain$でない
］
⇒
~RET ~NULL
◎
If container's node document's origin is not same origin-domain with the current settings object's origin, then return null.
</li>
	<li>
~RET %容器
◎
Return container.
</li>
</ol>
</div>

<div class="example">
<p>
これらの~propが ~NULL を返し得る例：
◎
An example of when these properties can return null is as follows:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;iframe&gt;&lt;/iframe&gt;

&lt;script&gt;
"use strict";
const %element = document.querySelector("iframe");
const %iframeWindow = %element.contentWindow;
%element.remove();

console.assert(%iframeWindow.top === null);
console.assert(%iframeWindow.parent === null);
console.assert(%iframeWindow.frameElement === null);
&lt;/script&gt;
</pre>

<p>
この例の %iframeWindow に対応する`閲覧~文脈$は、
%element が文書から除去されたとき，
`~NULL化＠~HTMLlifecycle#destroy-a-document$される。
◎
Here the browsing context corresponding to iframeWindow was nulled out when element was removed from the document.
</p>
</div>

				</section>
				<section id="browser-interface-elements">
<h5 title="Historical browser interface element APIs">7.2.2.5. 歴史的な~browser~UI要素~API</h5>

<p>
歴史的な理由から、
`Window$I ~interfaceには，
ある種の~web~browser~UI要素の可視性を表現していた いくつかの~propがある。
◎
For historical reasons, the Window interface had some properties that represented the visibility of certain web browser interface elements.
</p>

<p>
~privacyと相互運用能の理由から、
それらの~propは，
今や `Window$I に`対応する閲覧~文脈$の`~popupか$bcを表現する真偽-値を返す。
◎
For privacy and interoperability reasons, those properties now return values that represent whether the Window's browsing context's is popup property is true or false.
</p>

<p>
各~UI要素は、
`BarProp$I ~objにより表現される：
◎
Each interface element is represented by a BarProp object:
</p>

<pre class="idl">
[Exposed=Window]
interface `BarProp@I {
  readonly attribute boolean `visible$m;
};
</pre>

<dl class="domintro">
	<dt>%window.`locationbar$m.`visible$m</dt>
	<dt>%window.`menubar$m.`visible$m</dt>
	<dt>%window.`personalbar$m.`visible$m</dt>
	<dt>%window.`scrollbars$m.`visible$m</dt>
	<dt>%window.`statusbar$m.`visible$m</dt>
	<dt>%window.`toolbar$m.`visible$m</dt>
	<dd>
［
%window は~popupでないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the Window is not a popup; otherwise, returns false.
</dd>
</dl>

<div class="algo">
<p>
`visible@m
取得子~手続きは：
◎
The visible getter steps are:
</p>
<ol>
	<li>
%閲覧~文脈 ~LET コレに`関連な大域~obj$に`対応する閲覧~文脈$
◎
Let browsingContext be this's relevant global object's browsing context.
</li>
	<li>
~IF［
%閲覧~文脈 ~EQ ~NULL
］
⇒
~RET ~F
◎
If browsingContext is null, then return true.
</li>
	<li>
~RET %閲覧~文脈 の`~top-level閲覧~文脈$bcの`~popupか$bcに応じて
⇒＃
~T ならば ~F ／
~F ならば ~T
◎
Return the negation of browsingContext's top-level browsing context's is popup.
</li>
</ol>
</div>

<p>
以下に挙げる各種 `BarProp$I ~objは、
各 `Window$I ~obj用に存在するモノトスル：
◎
The following BarProp objects must exist for each Window object:
</p>
<dl class="def-list">
	<dt>
`~location-bar@bP
◎
The location bar BarProp object
</dt>
	<dd>
歴史的に，［
~browserの所在~barを表示する~control
］を包含する~UI要素を表現していた。
◎
Historically represented the user interface element that contains a control that displays the browser's location bar.
</dd>

	<dt>
`~menu-bar@bP
◎
The menu bar BarProp object
</dt>
	<dd>
歴史的に，［
~menu~form内の~commandの~list, またはそれに類似な~UI概念
］を包含する~UI要素を表現していた。
◎
Historically represented the user interface element that contains a list of commands in menu form, or some similar interface concept.
</dd>

	<dt>
`~personal-bar@bP
◎
The personal bar BarProp object
</dt>
	<dd>
歴史的に，［
利用者の “お気に入り（ `favorite^en ）” ~pageを指す~link, またはそれに類似な~UI概念
］を包含する~UI要素を表現していた。
◎
Historically represented the user interface element that contains links to the user's favorite pages, or some similar interface concept.
</dd>

	<dt>
`~scrollbar@bP
◎
The scrollbar BarProp object
</dt>
	<dd>
歴史的に，［
~scrollするための仕組み, またはそれに類似な~UI概念
］を包含する~UI要素を表現していた。
◎
Historically represented the user interface element that contains a scrolling mechanism, or some similar interface concept.
</dd>

	<dt>
`~status-bar@bP
◎
The status bar BarProp object
</dt>
	<dd>
歴史的に，［
利用者の媒体に応じて適切に，文書の直上や直下に見出される~UI要素
］を表現していた。
それは概して，［
進行中の~network活動や, 利用者の~pointing装置が現在~指示している要素
］についての情報を供していた。
◎
Historically represented a user interface element found immediately below or after the document, as appropriate for the user's media, which typically provides information about ongoing network activity or information about elements that the user's pointing device is currently indicating.
</dd>

	<dt>
`~toolbar@bP
◎
The toolbar BarProp object
</dt>
	<dd>
歴史的に，［
利用者の媒体に応じて適切に，文書の直上や直下に見出される~UI要素
］を表現していた。
それは概して，`~session履歴~辿り＠~HTMLnav#apply-the-history-step$用の~control（戻る／進む／読込直す, 等々の~button）を供していた。
◎
Historically represented the user interface element found immediately above or before the document, as appropriate for the user's media, which typically provides session history traversal controls (back and forward buttons, reload buttons, etc.).
</dd>
</dl>

<div class="algo">
`locationbar@m
取得子~手続きは、
コレの`~location-bar$bPを返す。
◎
The locationbar attribute must return the location bar BarProp object.
</div>

<div class="algo">
`menubar@m
取得子~手続きは、
コレの`~menu-bar$bPを返す。
◎
The menubar attribute must return the menu bar BarProp object.
</div>

<div class="algo">
`personalbar@m
取得子~手続きは、
コレの`~personal-bar$bPを返す。
◎
The personalbar attribute must return the personal bar BarProp object.
</div>

<div class="algo">
`scrollbars@m
取得子~手続きは、
コレの`~scrollbar$bPを返す。
◎
The scrollbars attribute must return the scrollbar BarProp object.
</div>

<div class="algo">
`statusbar@m
取得子~手続きは、
コレの`~status-bar$bPを返す。
◎
The statusbar attribute must return the status bar BarProp object.
</div>

<div class="algo">
`toolbar@m
取得子~手続きは、
コレの`~toolbar$bPを返す。
◎
The toolbar attribute must return the toolbar BarProp object.
</div>

<div class="p">
<p>
`status@m
属性は、
歴史的な理由から存在する
— 次に従うモノトスル：
</p>
<ul>
	<li>
取得子は、
最後に設定された文字列を返す。
</li>
	<li>
設定子は、
自身を所与の値に設定する。
</li>
	<li>
`~window$の作成-時には、
空~文字列に設定する。
</li>
</ul>
<p>
この属性は、
他には何もしない。
</p>
◎
For historical reasons, the status attribute on the Window object must, on getting, return the last string it was set to, and on setting, must set itself to the new value. When the Window object is created, the attribute must be set to the empty string. It does not do anything else.
</div>

				</section>
				<section id="script-settings-for-window-objects">
<h5 title="Script settings for Window objects">7.2.2.6. `Window^I ~obj用の~script設定群</h5>

<div class="algo">
<p>
`~window用に環境~設定群~objを設定しておく@
ときは、
所与の
⇒＃
`~URL$ %作成時の~URL,
`~JS実行~文脈$ %実行~文脈,
~NULL または`環境$ %予約-済み環境,
`~URL$ %~top-level作成時の~URL,
`生成元$ %~top-level生成元
◎終
に対し，次を走らす：
◎
To set up a window environment settings object, given a URL creationURL, a JavaScript execution context execution context, null or an environment reservedEnvironment, a URL topLevelCreationURL, and an origin topLevelOrigin, run these steps:
</p>
<ol>
	<li>
%~realm ~LET %実行~文脈 の~Realm成分の値
◎
Let realm be the value of execution context's Realm component.
</li>
	<li>
%~window ~LET %~realm の`大域~obj$rM
◎
Let window be realm's global object.
</li>
	<li>
<p>
%設定群~obj ~LET 新たな`環境~設定群~obj$
— その各種~algoは、
以下に従って定義される。
以下における %現~文書 は、
~algoが呼出された時点で %~window に`結付けられている文書$を表すとする：
◎
Let settings object be a new environment settings object whose algorithms are defined as follows:
</p>
		<ul>
			<li class="algo">
`~realm実行~文脈$enV
⇒
~RET %実行~文脈
◎
The realm execution context
• Return execution context.
</li>
			<li class="algo">
`~module~map$enV
⇒
~RET %現~文書 の`~module~map$doc
◎
The module map
• Return the module map of window's associated Document.
</li>
			<li class="algo">
`~API用~URL文字~符号化法$enV
⇒
~RET %現~文書 の現在の`符号化法$doc
◎
The API URL character encoding
• Return the current character encoding of window's associated Document.
</li>
			<li class="algo">
`~API用~基底~URL$enV
⇒
~RET %現~文書 の現在の`基底~URL$doc
◎
The API base URL
• Return the current base URL of window's associated Document.
</li>
			<li class="algo">
`生成元$enV
⇒
~RET %現~文書 の`生成元$doc
◎
The origin
• Return the origin of window's associated Document.
</li>
			<li class="algo">
`施策~容器$enV
⇒
~RET %現~文書 の`施策~容器$doc
◎
The policy container
• Return the policy container of window's associated Document.
</li>
			<li class="algo">
`非同一-生成元~能力は隔離されるか？$enV
⇒
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%~realm の`~agent~cluster$の`非同一-生成元~隔離~mode$agC ~EQ `concrete$l
］~AND［
%現~文書 には `cross-origin-isolated$l 特能の`利用は許容されて$いる
］
◎
The cross-origin isolated capability
• Return true if both of the following hold, and false otherwise:
•• realm's agent cluster's cross-origin-isolation mode is "concrete", and
•• window's associated Document is allowed to use the "cross-origin-isolated" feature.
</li>
			<li class="algo">
`時刻~起点$enV
⇒
~RET %現~文書 の`~load計時~情報$docの`~navi開始~時刻$
◎
The time origin
• Return window's associated Document's load timing info's navigation start time.
</li>
		</ul>
	</li>
	<li>
<p>
~IF［
%予約-済み環境 ~NEQ ~NULL
］：
◎
If reservedEnvironment is non-null, then:
</p>
		<ol>
			<li>
%設定群~obj の
⇒＃
`~ID$enV ~SET %予約-済み環境 の`~ID$enV,
`~target閲覧~文脈$enV ~SET %予約-済み環境 の`~target閲覧~文脈$enV,
`作動中の~sw$enV ~SET %予約-済み環境 の`作動中の~sw$enV
◎
Set settings object's id to reservedEnvironment's id, target browsing context to reservedEnvironment's target browsing context, and active service worker to reservedEnvironment's active service worker.
</li>
			<li>
<p>
%予約-済み環境 の`~ID$enV ~SET 空~文字列
◎
Set reservedEnvironment's id to the empty string.
</p>

<p class="note">注記：
この時点から， %予約-済み環境 の~ID（ `identity^en ）は %設定群~obj に全部的に転送されたものと見なされ、
%予約-済み環境 は`環境$の`~ID$enVにより探索-可能にならなくなる。
◎
The identity of the reserved environment is considered to be fully transferred to the created environment settings object. The reserved environment is not searchable by the environment’s id from this point on.
</p>
 			</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%設定群~obj の
⇒＃
`~ID$enV ~SET 新たな一意かつ不透明な文字列,
`~target閲覧~文脈$enV ~SET ~NULL,
`作動中の~sw$enV ~SET ~NULL
◎
Otherwise, set settings object's id to a new unique opaque string, settings object's target browsing context to null, and settings object's active service worker to null.
</li>
	<li>
%設定群~obj の
⇒＃
`作成時の~URL$enV ~SET %作成時の~URL,
`~top-level作成時の~URL$enV ~SET %~top-level作成時の~URL,
`~top-level生成元$enV ~SET %~top-level生成元
◎
Set settings object's creation URL to creationURL, settings object's top-level creation URL to topLevelCreationURL, and settings object's top-level origin to topLevelOrigin.
</li>
	<li>
%~realm の `HostDefined^sl ~field ~SET %設定群~obj
◎
Set realm's [[HostDefined]] field to settings object.
</li>
	<li>
<p>
~RET %設定群~obj
</p>

<p class="trans-note">【
この段は、
この訳による追加
— 他所において，この %設定群~obj を参照している箇所があるので。
】</p>
	</li>
</ol>
</div>

				</section>
			</section>
			<section id="the-windowproxy-exotic-object">
<h4 title="The WindowProxy exotic object">7.2.3. `WindowProxy^I ~exotic~obj</h4>

<p class="trans-note">【
この節を成す内容は、
`別~page＠~HTMLWPROXY#the-windowproxy-exotic-object$にて。
】</p>

			</section>
			<section id="the-location-interface">
<h4 title="The Location interface">7.2.4. `Location^I ~interface</h4>

<p>
各 `~window$には、
その作成-時に，新たな `Location$I ~objが結付けられる。
【！＊ unique instance of 〜 allocated】
</p>

<p class="trans-note">【
以下，ここでは、
この節を成す内容のうち，~APIに関する部分のみ述べる。
他の内容は、
`別~page＠~HTMLWPROXY#the-location-interface$にて。
】</p>

<dl class="domintro">
	<dt>%document.`location$m0 [ = %value ]</dt>
	<dt>%window.`location$m [ = %value ]</dt>
	<dd>
現在の~pageの所在を伴う `Location$I ~objを返す。
◎
Returns a Location object with the current page's location.
</dd>
	<dd>
設定して，別の~pageへ~navigateできる。
◎
Can be set, to navigate to another page.
</dd>
</dl>

<div class="algo">
<p>
`Document$I の
`location@m0
取得子~手続きは
◎
The Document object's location getter steps are＼
</p>
<ol>
	<li>
~IF［
コレは`全部的に作動中$である
］
⇒
~RET コレに`関連な大域~obj$の `Location$I ~obj
◎
to return this's relevant global object's Location object, if this is fully active,＼
</li>
	<li>
~RET ~NULL
◎
and null otherwise.
</li>
</ol>
</div>

<div class="algo">
`Window$I の
`location@m
取得子~手続きは
⇒
~RET コレの `Location$I ~obj
◎
The Window object's location getter steps are to return this's Location object.
</div>

<p>
`Location$I ~objは、［
それに結付けられた`文書$の`~URL$docの表現
］および［
それに結付けられた`~navigable$を［
`~navigate$する／`読込直す＠~HTMLnav#reload$
］ための~method
］を供する。
◎
Location objects provide a representation of the URL of their associated Document, as well as methods for navigating and reloading the associated navigable.
</p>

<pre class="idl">
[Exposed=Window]
interface `Location@I { /* <span class="comment">
ただし、［
`追加的な作成~手続き＠~HTMLWPROXY#the-location-interface$,
`上書きされた内部~method＠~HTMLWPROXY#location-internal-methods$
］も見よ。
◎
but see also additional creation steps and overridden internal methods
</span> */

  [`LegacyUnforgeable$] stringifier attribute USVString `href$m;
  [`LegacyUnforgeable$] readonly attribute USVString `origin$m;
  [`LegacyUnforgeable$] attribute USVString `protocol$m;
  [`LegacyUnforgeable$] attribute USVString `host$m;
  [`LegacyUnforgeable$] attribute USVString `hostname$m;
  [`LegacyUnforgeable$] attribute USVString `port$m;
  [`LegacyUnforgeable$] attribute USVString `pathname$m;
  [`LegacyUnforgeable$] attribute USVString `search$m;
  [`LegacyUnforgeable$] attribute USVString `hash$m;

  [`LegacyUnforgeable$] undefined `assign$m(USVString %url);
  [`LegacyUnforgeable$] undefined `replace$m(USVString %url);
  [`LegacyUnforgeable$] undefined `reload$m();

  [`LegacyUnforgeable$, SameObject] readonly attribute `DOMStringList$I `ancestorOrigins$m;
};
</pre>

<dl class="domintro">
	<dt>%location.`toString()^m</dt>
	<dt>%location.`href$m</dt>
	<dd>
`~URL$Locを返す。
◎
Returns the Location object's URL.
</dd>
	<dd>
設定して，所与の~URLへ~navigateできる。
◎
Can be set, to navigate to the given URL.
</dd>

	<dt>%location.`origin$m</dt>
	<dd>
`~URL$Locの生成元を返す。
◎
Returns the Location object's URL's origin.
</dd>

	<dt>%location.`protocol$m</dt>
	<dd>
`~URL$Locの~schemeを返す。
◎
Returns the Location object's URL's scheme.
</dd>
	<dd>
設定して，`~URL$Locの~schemeだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed scheme.
</dd>

	<dt>%location.`host$m</dt>
	<dd>
`~URL$Locの［
~host,
~port（~scheme用の`既定の~port$urlと異なるならば）
］を返す。
◎
Returns the Location object's URL's host and port (if different from the default port for the scheme).
</dd>
	<dd>
設定して，`~URL$Locの
~host, ~port
だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host and port.
</dd>

	<dt>%location.`hostname$m</dt>
	<dd>
`~URL$Locの~hostを返す。
◎
Returns the Location object's URL's host.
</dd>
	<dd>
設定して，`~URL$Locの~hostだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host.
</dd>

	<dt>%location.`port$m</dt>
	<dd>
`~URL$Locの~port を返す。
◎
Returns the Location object's URL's port.
</dd>
	<dd>
設定して，`~URL$Locの~portだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed port.
</dd>

	<dt>%location.`pathname$m</dt>
	<dd>
`~URL$Locの~path を返す。
◎
Returns the Location object's URL's path.
</dd>
	<dd>
設定して，`~URL$Locの~pathだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed path.
</dd>

	<dt>%location.`search$m</dt>
	<dd>
`~URL$Locの~queryを返す
（空でないならば 先頭の `?^l も含む）。
◎
Returns the Location object's URL's query (includes leading "?" if non-empty).
</dd>
	<dd>
設定して，`~URL$Locの~query（先頭の `?^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed query (ignores leading "?").
</dd>

	<dt>%location.`hash$m</dt>
	<dd>
`~URL$Locの素片を返す（空でないならば 先頭の `#^l を含む）。
◎
Returns the Location object's URL's fragment (includes leading "#" if non-empty).
</dd>
	<dd>
設定して，`~URL$Locの素片（先頭の `#^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").
</dd>

	<dt>%location.`assign(url)$m</dt>
	<dd>
%url へ~navigateする。
◎
Navigates to the given URL.
</dd>

	<dt>%location.`replace(url)$m</dt>
	<dd>
~session履歴から現在の~pageを除去した上で，所与の %url へ~navigateする。
◎
Removes the current page from the session history and navigates to the given URL.
</dd>

	<dt>%location.`reload()$m</dt>
	<dd>
現在の~pageを読込直す。
◎
Reloads the current page.
</dd>

	<dt>%location.`ancestorOrigins$m</dt>
	<dd>
`DOMStringList$I ~objを返す
— それは、
`先祖~navigable群$を成す各`~navigable$にて`作動中の文書$navの生成元からなる。
◎
Returns a DOMStringList object listing the origins of the ancestor navigables' active documents.
</dd>
</dl>

<p>
各 `Location$I ~obj %L には、
次が定義される：
◎
↓</p>

<dl class="def-list">
	<dt>`関連な文書@Loc</dt>
	<dd>
%L に`関連な大域~obj$に`対応する閲覧~文脈$ %B に応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ %B にて`作動中の文書$bc
◎
A Location object has an associated relevant Document, which is its relevant global object's browsing context's active document, if this Location object's relevant global object's browsing context is non-null, and null otherwise.
</dd>

	<dt>`~URL@Loc</dt>
	<dd>
%L に`関連な文書$Loc %文書 に応じて
⇒＃
~NULL ならば `~about_blank$sc ／
~ELSE_ %文書 の`~URL$doc
◎
A Location object has an associated url, which is this Location object's relevant Document's URL, if this Location object's relevant Document is non-null, and about:blank otherwise.
</dd>

	<dt>`先祖~生成元~list@</dt>
	<dd class="algo">
<p>
%L の作成-時に、［
次の手続きの結果で与えられる文字列の~list
］が結付けられた `DOMStringList$I ~objに設定するモノトスル：
◎
A Location object has an associated ancestor origins list. When a Location object is created, its ancestor origins list must be set to a DOMStringList object whose associated list is the list of strings that the following steps would produce:
</p>
		<ol>
			<li>
%出力 ~LET 新たな`~list$
◎
Let output be a new list of strings.
</li>
			<li>
%現在の文書 ~LET %L に`関連な文書$Loc
◎
Let current be the Location object's relevant Document.
</li>
			<li>
<p>
~WHILE［
%現在の文書 の`容器~文書$doc ~NEQ ~NULL
］
◎
While current's container document is non-null:
</p>
				<ol>
					<li>
%現在の文書 ~SET %現在の文書 の`容器~文書$doc
◎
Set current to current's container document.
</li>
					<li>
%出力 に次の結果を`付加する$
⇒
`生成元を直列化する$( %現在の文書 の`生成元$doc )
◎
Append the serialization of current's origin to output.
</li>
				</ol>
			</li>
			<li>
~RET %出力
◎
Return output.
</li>
		</ol>
	</dd>
	<dd class="trans-note">【
この仕様の中では、
`ancestorOrigins$m のみから利用される。
~swからも利用されている。
】</dd>
</dl>

<div class="algo">
<p>
`~Location~objにより~navigateする@
ときは、
所与の
( `Location$I ~obj %L,
`~URL$ %~URL,
`履歴~取扱いの挙動$ %履歴~取扱い （省略時は `~push$i ）
に対し：
◎
To Location-object navigate a Location object location to a URL url, optionally given a history handling behavior historyHandling (default "push"):
</p>
<ol>
	<li>
%~navigable ~LET %L に`関連な大域~obj$に`対応する~navigable$
◎
Let navigable be location's relevant global object's navigable.
</li>
	<li>
%~source文書 ~LET `現任な大域~obj$に`結付けられている文書$
◎
Let sourceDocument be the incumbent global object's associated Document.
</li>
	<li>
~IF［
%L に`関連な文書$Locは まだ`完全に読込まれ$ていない
］~AND［
`現任な大域~obj$の`一過な作動化？$ ~EQ ~F
］
⇒
%履歴~取扱い ~SET `置換-$i
◎
If location's relevant Document is not yet completely loaded, and the incumbent global object does not have transient activation, then set historyHandling to "replace".
</li>
	<li>
`~navigableを~URLへ~navigateする$( %~navigable, %~URL, %~source文書 )
— 次も与える下で
⇒＃
`例外を可能化するか$i ~SET ~T,
`履歴~取扱い$i ~SET %履歴~取扱い
◎
Navigate navigable to url using sourceDocument, with exceptionsEnabled set to true and historyHandling set to historyHandling.
</li>
</ol>
</div>

<div class="algo">
<p>
`Location$I ~obj %L の
`生成元~domainを検査する@
ときは、
次を走らす：
</p>
<ol>
	<li>
%文書 ~LET %L に`関連な文書$Loc
</li>
	<li>
~IF［
%文書 ~NEQ ~NULL
］~AND［
( %文書 の`生成元$doc, `入口~設定群~obj$の`生成元$enV )
は`同じ生成元~domain$でない
］
⇒
~THROW `SecurityError$E
<!-- 
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException. 
／
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

If document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

-->
</li>
</ol>

<p class="trans-note">【
この手続きは、
以下を簡潔に記すためにこの訳に導入している。
】</p>
</div>

<div class="algo">
<p>
`href@m
取得子~手続きは：
◎
The href getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET `~URLを直列化する$( コレが指す`~URL$Loc )
◎
Return this's url, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`href$m 設定子~手続きは：
◎
The href setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
%~URL ~LET `相対的に~URL構文解析する$( 所与の値, `入口~設定群~obj$ )
◎
Parse the given value relative to the entry settings object.＼
</li>
	<li>
~IF［
%~URL ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If that failed, throw a "SyntaxError" DOMException.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %~URL )
◎
Location-object navigate this to the resulting URL record.
</li>
</ol>

<p class="note">注記：
`href$m 設定子に対しては、
意図的に~security検査は行われない。
◎
The href setter intentionally has no security check.
</p>
</div>

<div class="algo">
<p>
`origin@m
取得子~手続きは：
◎
The origin getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET `生成元を直列化する$( コレが指す`~URL$Locの`生成元$url )
◎
Return the serialization of this's url's origin.
</li>
</ol>
</div>

<div class="algo">
<p>
`protocol@m
取得子~手続きは：
◎
The protocol getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
コレが指す`~URL$Locの`~scheme$url,
`:^l
◎
Return this's url's scheme, followed by ":".
</li>
</ol>
</div>

<div class="algo">
<p>
`protocol$m 設定子~手続きは：
◎
The protocol setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
%~protocol文字列 ~LET 次を順に連結した結果
⇒＃
所与の値,
`:^l
◎
↓</li>
	<li>
<p>
%失敗かも ~LET
`~API用に~URL構文解析する$( %~protocol文字列, %複製~URL, `~scheme開始$uST )
◎
Let possibleFailure be the result of basic URL parsing the given value, followed by ":", with copyURL as url and scheme start state as state override.
</p>

<p class="note">注記：
~URL構文解析器は，連続する~colonを無視するので、
値に `https:^l を与えても
（あるいは `https::::^l でさえ），
`https^l を与えるのと同じことになる。
◎
Because the URL parser ignores multiple consecutive colons, providing a value of "https:" (or even "https::::") is the same as providing a value of "https".
</p>
	</li>
	<li>
~IF［
%失敗かも ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If possibleFailure is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
~IF［
%複製~URL の `~scheme$urlは`~HTTP_S~scheme$である
］
⇒
~RET
◎
If copyURL's scheme is not an HTTP(S) scheme, then terminate these steps.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`host@m
取得子~手続きは：
◎
The host getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%~URL ~LET コレが指す`~URL$Loc
◎
Let url be this's url.
</li>
	<li>
~IF［
%~URL の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If url's host is null, return the empty string.
</li>
	<li>
%~host文字列 ~LET `~hostを直列化する$( %~URL の`~host$url )
◎
↓</li>
	<li>
~IF［
%~URL の`~port$url ~EQ ~NULL
］
⇒
~RET %~host文字列
◎
If url's port is null, return url's host, serialized.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
%~host文字列,
`:^l,
`整数を直列化する$( %~URL の`~port$url )
◎
Return url's host, serialized, followed by ":" and url's port, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`host$m 設定子~手続きは：
◎
The host setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
~IF［
%複製~URL は`不透明な~path$を持つ
］
⇒
~RET
◎
If copyURL has an opaque path, then return.
</li>
	<li>
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~host$uST )
◎
Basic URL parse the given value, with copyURL as url and host state as state override.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`hostname@m
取得子~手続きは：
◎
The hostname getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~URL$Locの
`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this's url's host is null, return the empty string.
</li>
	<li>
~RET `~hostを直列化する$( コレが指す`~URL$Locの`~host$url )
◎
Return this's url's host, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`hostname$m 設定子~手続きは：
◎
The hostname setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
~IF［
%複製~URL は`不透明な~path$を持つ
］
⇒
~RET
◎
If copyURL has an opaque path, then return.
</li>
	<li>
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~hostname$uST )
◎
Basic URL parse the given value, with copyURL as url and hostname state as state override.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`port@m
取得子~手続きは：
◎
The port getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~URL$Locの`~port$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this's url's port is null, return the empty string.
</li>
	<li>
~RET `整数を直列化する$( コレが指す`~URL$Locの`~port$url )
◎
Return this's url's port, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`port$m 設定子~手続きは：
◎
The port setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
~IF［
%複製~URL は `~username／~password／~portを持てない$
］
⇒
~RET
◎
If copyURL cannot have a username/password/port, then return.
</li>
	<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~port$url ~SET ~NULL
◎
If the given value is the empty string, then set copyURL's port to null.
</li>
	<li>
~ELSE
⇒
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~port$uST )
◎
Otherwise, basic URL parse the given value, with copyURL as url and port state as state override.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`pathname@m
取得子~手続きは：
◎
The pathname getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET `~URL~pathを直列化する$( コレが指す`~URL$Loc )
◎
Return the result of URL path serializing this Location object's url.
</li>
</ol>
</div>

<div class="algo">
<p>
`pathname$m 設定子~手続きは：
◎
The pathname setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
~IF［
%複製~URL は`不透明な~path$を持つ
］
⇒
~RET
◎
If copyURL has an opaque path, then return.
</li>
	<li>
%複製~URL の`~path$url ~SET 空~list
◎
Set copyURL's path to the empty list.
</li>
	<li>
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~path開始$uST )
◎
Basic URL parse the given value, with copyURL as url and path start state as state override.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`search@m
取得子~手続きは：
◎
The search getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~URL$Locの`~query$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this's url's query is either null or the empty string, return the empty string.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`?^l,
コレが指す`~URL$Locの`~query$url
◎
Return "?", followed by this's url's query.
</li>
</ol>
</div>

<div class="algo">
<p>
`search$m 設定子~手続きは：
◎
The search setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~query$url ~SET ~NULL
◎
If the given value is the empty string, set copyURL's query to null.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise, run these substeps:
</p>

		<ol>
			<li>
%入力 ~LET 所与の値
◎
↓</li>
			<li>
~IF［
%入力 の最初の文字 ~EQ `?^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "?" removed, if any.
</li>
			<li>
%複製~URL の`~query$url ~SET 空~文字列
◎
Set copyURL's query to the empty string.
</li>
			<li>
`~API用に~URL構文解析する$( %入力, %複製~URL, `~query$uST, 【コレに】`関連な文書$Locの`符号化法$doc )
◎
Basic URL parse input, with null, the relevant Document's document's character encoding, copyURL as url, and query state as state override.
</li>
		</ol>
	</li>
	<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`hash@m
取得子~手続きは：
◎
The hash getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~URL$Locの`素片$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this's url's fragment is either null or the empty string, return the empty string.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`#^l,
コレが指す`~URL$Locの`素片$url
◎
Return "#", followed by this's url's fragment.
</li>
</ol>
</div>

<div class="algo">
<p>
`hash$m 設定子~手続きは：
◎
The hash setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
%入力 ~LET 所与の値
◎
↓</li>
	<li>
~IF［
%入力 の最初の文字 ~EQ `#^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "#" removed, if any.
</li>
	<li>
%複製~URL の`素片$url ~SET 空~文字列
◎
Set copyURL's fragment to the empty string.
</li>
	<li>
`~API用に~URL構文解析する$( %入力, %複製~URL, `素片$uST )
◎
Basic URL parse input, with copyURL as url and fragment state as state override.
</li>
	<li>
<p>
~IF［
%複製~URL の`素片$url ~EQ コレの`~URL$Locの`素片$url
］
⇒
~RET
◎
If copyURL's fragment is this's url's fragment, then return.
</p>

<p class="note">注記：
この脱出措置は、
配備-済みな内容のうち［
~scrollに対し `location.hash^c を`冗長に設定するもの＠https://bugzilla.mozilla.org/show_bug.cgi?id=1733797#c2$
］との互換性に必要とされる。
それは、
素片~naviを成す他の仕組み
— `href$m 設定子や `assign()$m など —
には適用されない。
◎
This bailout is necessary for compatibility with deployed content, which redundantly sets location.hash on scroll. It does not apply to other mechanisms of fragment navigation, such as the location.href setter or location.assign().
</p>
	</li>
	<li>
`~Location~objにより~navigateする$( コレ, %複製~URL )
◎
Location-object navigate this to copyURL.
</li>
</ol>

<p class="note">注記：
`a$e, `area$e 要素~用の等価な~APIと違って，
`hash$m 設定子は、［
空~文字列を，配備-済みの~scriptと互換にするよう特別に扱う
］ことはない。
◎
Unlike the equivalent API for the a and area elements, the hash setter does not special case the empty string, to remain compatible with deployed scripts.
</p>
</div>

<div class="algo">
<p>
`assign(url)@m
~method手続きは：
◎
The assign(url) method steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%~URL~record ~LET `相対的に~URL構文解析する$( %url, `入口~設定群~obj$ )
◎
Parse url relative to the entry settings object.＼
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If that failed, throw a "SyntaxError" DOMException.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %~URL~record )
◎
Location-object navigate this to the resulting URL record.
</li>
</ol>
</div>

<div class="algo">
<p>
`replace(url)@m
~method手続きは：
◎
The replace(url) method steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
%~URL~record ~LET `相対的に~URL構文解析する$( %url, `入口~設定群~obj$ )
◎
Parse url relative to the entry settings object.＼
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If that failed, throw a "SyntaxError" DOMException.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %~URL~record, `置換-$i )
◎
Location-object navigate this to the resulting URL record given "replace".
</li>
</ol>

<p class="note">注記：
`replace()$m ~methodに対しては、
~security検査は意図的に行われない。
◎
The replace() method intentionally has no security check.
</p>
</div>

<div class="algo">
<p>
`reload()@m
~method手続きは：
◎
The reload() method steps are:
</p>
<ol>
	<li>
%文書 ~LET コレに`関連な文書$Loc
◎
Let document be this's relevant Document.
</li>
	<li>
~IF［
%文書 ~EQ ~NULL
］
⇒
~RET
◎
If document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
`~navigableを読込直す$( %文書 の`~node~navigable$ )
◎
Reload document's node navigable.
</li>
</ol>
</div>

<div class="algo">
<p>
`ancestorOrigins@m
取得子~手続きは：
◎
The ancestorOrigins getter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET 空`~list$†
◎
If this's relevant Document is null, then return an empty list.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET コレの`先祖~生成元~list$
◎
Otherwise, return this's ancestor origins list.
</li>
</ol>

<p class="warning">
`ancestorOrigins$m 属性がどう働くかの詳細は、
まだ異論があり，変更され得る。
更なる情報は、
`課題 #1918＠~HTMLissue/1918$ 
を見よ。
◎
The details of how the ancestorOrigins attribute works are still controversial and might change. See issue #1918 for more information.
</p>

<p class="trans-note">【†
常に同じ~objを返すはずなので（ [SameObject] ）、
実際には，コレに`関連な大域~obj$に`対応する閲覧~文脈$が破棄される時点で，
`先祖~生成元~list$が空にされるのかもしれない。
】</p>
</div>

<hr>

<p class="trans-note">【
以下，この節, およびその各 下位節の内容は、
`別~page＠~HTMLWPROXY#the-location-interface$にて。
】</p>

			</section>
			<section id="the-history-interface">
<h4 title="The History interface">7.2.5. `History^I ~interface</h4>

<pre class="idl">
enum `ScrollRestoration@I { `auto$l, `manual$l };

[Exposed=Window]
interface `History@I {
  readonly attribute unsigned long `length$m0;
  attribute `ScrollRestoration$I `scrollRestoration$m;
  readonly attribute any `state$m;
  undefined `go$m(optional long %delta = 0);
  undefined `back$m();
  undefined `forward$m();
  undefined `pushState$m(any %data, DOMString %unused, optional USVString? %url = null);
  undefined `replaceState$m(any %data, DOMString %unused, optional USVString? %url = null);
};
</pre>

<dl class="domintro">
	<dt>`history$m.`length$m0</dt>
	<dd>
現在の`辿可能な~navigable$用の総合的な`~session履歴~entry群$navの~size【！the number of】を返す。
◎
Returns the number of overall session history entries for the current traversable navigable.
</dd>

	<dt>`history$m.`scrollRestoration$m</dt>
	<dd>
`作動中の~session履歴~entry$navの`~scroll復旧~mode$shEを返す。
◎
Returns the scroll restoration mode of the active session history entry.
</dd>

	<dt>`history$m.`scrollRestoration$m = %value</dt>
	<dd>
`作動中の~session履歴~entry$navの`~scroll復旧~mode$shEを
%value に設定する。
◎
Set the scroll restoration mode of the active session history entry to value.
</dd>

	<dt>`history$m.`state$m</dt>
	<dd>
`作動中の~session履歴~entry$navの`直列形の状態$shEを
~JS値に逆直列化した結果を返す。
◎
Returns the serialized state of the active session history entry, deserialized into a JavaScript value.
</dd>

	<dt>`history$m.`go()$m</dt>
	<dd>
現在の~pageを読込直す。
◎
Reloads the current page.
</dd>

	<dt>`history$m.`go(delta)$m</dt>
	<dd>
現在の`辿可能な~navigable$用の総合的な`~session履歴~entry群$navが成す~listを指定された段~数だけ［
後へ戻る／前へ進む
］。
◎
Goes back or forward the specified number of steps in the overall session history entries list for the current traversable navigable.
</dd>
	<dd>
%delta ~EQ 0 の場合、
現在の~pageを読込直すことになる。
◎
A zero delta will reload the current page.
</dd>
	<dd>
%delta が範囲~外を指す場合は何もしない。
◎
If the delta is out of range, does nothing.
</dd>

	<dt>`history$m.`back()$m</dt>
	<dd>
現在の`辿可能な~navigable$用の総合的な`~session履歴~entry群$navが成す~list内で 1 段だけ後へ戻る。
◎
Goes back one step in the overall session history entries list for the current traversable navigable.
</dd>
	<dd>
前~pageが無い場合、
何もしない。
◎
If there is no previous page, does nothing.
</dd>

	<dt>`history$m.`forward()$m</dt>
	<dd>
現在の`辿可能な~navigable$用の総合的な`~session履歴~entry群$navが成す~listを 1 段だけ前へ進む。
◎
Goes forward one step in the overall session history entries list for the current traversable navigable.
</dd>
	<dd>
次~pageが無い場合、
何もしない。
◎
If there is no next page, does nothing.
</dd>

	<dt>`history$m.`pushState(data, "")$m</dt>
	<dd>
~session履歴の中へ新たな~entryを追加する
— その`直列形の状態$shEには %data の直列化 が設定される。
この~entryの~URLには、
`作動中の~session履歴~entry$navの`~URL$shEが複製された上で利用されることになる。
◎
Adds a new entry into session history with its serialized state set to a serialization of data. The active history entry's URL will be copied over and used for the new entry's URL.
</dd>
	<dd>
（ 2 個目の~parameterは、
歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、
慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>

	<dt>`history$m.`pushState(data, "", url)$m</dt>
	<dd>
~session履歴の中へ新たな~entryを追加する
— その［
`直列形の状態$shEには %data の直列化,
`~URL$shEには %url
］が設定される。
◎
Adds a new entry into session history with its serialized state set to a serialization of data, and with its URL set to url.
</dd>
	<dd>
現在の`文書$の~URLを %url で`書直せ$ない場合、
`SecurityError$E 例外が投出されることになる。
◎
If the current Document cannot have its URL rewritten to url, a "SecurityError" DOMException will be thrown.
</dd>
	<dd>
（ 2 個目の~parameterは、
歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、
慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>

	<dt>`history$m.`replaceState(data, "")$m</dt>
	<dd>
`作動中の~session履歴~entry$navの`直列形の状態$shEを
%data の有構造~cloneに更新する。
◎
Updates the serialized state of the active session history entry to a structured clone of data.
</dd>
	<dd>
（ 2 個目の~parameterは、
歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、
慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>

	<dt>`history$m.`replaceState(data, "", url)$m</dt>
	<dd>
`作動中の~session履歴~entry$navの［
`直列形の状態$shEを %data の有構造~clone,
`~URL$shEを %url
］に更新する。
◎
Updates the serialized state of the active session history entry to a structured clone of data, and its URL to url.
</dd>
	<dd>
現在の`文書$の~URLを %url で`書直せ$ない場合、
`SecurityError$E 例外が投出されることになる。
◎
If the current Document cannot have its URL rewritten to url, a "SecurityError" DOMException will be thrown.
</dd>
	<dd>
（ 2 個目の~parameterは、
歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、
慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>
</dl>

<p>
各 `文書$は、
`History$I ~objを与える
`履歴~obj@
を有する。
【一対一に対応する。】
◎
A Document has a history object, a History object.
</p>

<div class="algo">
<p>
`history@m
取得子~手続きは
⇒
~RET コレに`結付けられている文書$の`履歴~obj$
◎
The history getter steps are to return this's associated Document's history object.
</p>
</div>

<hr>

<p>
各 `History$I ~objは、
次に挙げるものを有する：
</p>
<ul>
	<li>
`状態@hsT
⇒
初期~時は ~NULL
◎
Each History object has state, initially null.
</li>
	<li>
`長さ@hsT
⇒
負でない整数
— 初期~時は 0
◎
Each History object has a length, a non-negative integer, initially 0.
</li>
	<li>
`~index@hsT
⇒
負でない整数
— 初期~時は 0
◎
Each History object has an index, a non-negative integer, initially 0.
</li>
</ul>

<p class="note">注記：
`~index$hsT は直に公開されないが、
同期的~naviの間における`長さ$hsTの変化から推定され得る。
事実、
長さは，そのために利用される。
◎
Although the index is not directly exposed, it can be inferred from changes to the length during synchronous navigations. In fact, that is what it's used for.
</p>

<div class="algo">
<p>
`length@m0
取得子~手続きは：
◎
The length getter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な大域~obj$に`結付けられている文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's relevant global object's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET コレの`長さ$hsT
◎
Return this's length.
</li>
</ol>
</div>

<div class="algo">
<p>
`scrollRestoration@m
取得子~手続きは：
◎
The scrollRestoration getter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な大域~obj$に`結付けられている文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's relevant global object's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET コレの`~node~navigable$にて`作動中の~session履歴~entry$navの`~scroll復旧~mode$shE
◎
Return this's node navigable's active session history entry's scroll restoration mode.
</li>
</ol>
</div>

<div class="algo">
<p>
`scrollRestoration$m
設定子~手続きは：
◎
The scrollRestoration setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な大域~obj$に`結付けられている文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's relevant global object's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
コレの`~node~navigable$にて`作動中の~session履歴~entry$navの`~scroll復旧~mode$shE ~SET 所与の値
◎
Set this's node navigable's active session history entry's scroll restoration mode to the given value.
</li>
</ol>
</div>

<div class="algo">
<p>
`state@m
取得子~手続きは：
◎
The state getter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な大域~obj$に`結付けられている文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's relevant global object's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET コレの`状態$hsT
◎
Return this's state.
</li>
</ol>
</div>

<div class="algo">
<p>
`go(delta)@m
~method手続きは
⇒
`差分だけ辿る$( コレ, %delta )
◎
The go(delta) method steps are to delta traverse this given delta.
</p>
</div>

<div class="algo">
<p>
`back()@m
~method手続きは
⇒
`差分だけ辿る$( コレ, −1 )
◎
The back() method steps are to delta traverse this given −1.
</p>
</div>

<div class="algo">
<p>
`forward()@m
~method手続きは
⇒
`差分だけ辿る$( コレ, 1 )
◎
The forward() method steps are to delta traverse this given +1.
</p>
</div>

<div class="algo">
<p>
`差分だけ辿る@
ときは、
所与の
( `History$I ~obj %履歴, 整数 %差分 )
に対し：
◎
To delta traverse a History object history given an integer delta:
</p>
<ol>
	<li>
%文書 ~LET %履歴 に`関連な大域~obj$に`結付けられている文書$
◎
Let document be history's relevant global object's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
%差分 ~EQ 0
］
⇒
`~navigableを読込直す$( %文書 の`~node~navigable$ )
◎
If delta is 0, then reload document's node navigable.
</li>
	<li>
`履歴を差分だけ辿る$( %文書 の`~node~navigable$の`辿可能な~navigable$nav, %差分, %文書 )
◎
Traverse the history by a delta given document's node navigable's traversable navigable, delta, and document.
</li>
</ol>
</div>

<div class="algo">
<p>
`pushState(data, unused, url)@m
~method手続きは
⇒
`履歴に状態を~pushするか履歴の状態を置換する$( コレ, %data, %url, `~push$i )
◎
The pushState(data, unused, url) method steps are to run the shared history push/replace state steps given this, data, url, and "push".
</p>
</div>

<div class="algo">
<p>
`replaceState(data, unused, url)@m
~method手続きは
⇒
`履歴に状態を~pushするか履歴の状態を置換する$( コレ, %data, %url, `置換-$i )
◎
The replaceState(data, unused, url) method steps are to run the shared history push/replace state steps given this, data, url, and "replace".
</p>
</div>

<div class="algo">
<p>
`履歴に状態を~pushするか履歴の状態を置換する@
ときは、
所与の
⇒＃
`History$I ~obj %履歴,
値 %~data,
`~scalar値~文字列$または ~NULL %~URL,
`履歴~取扱いの挙動$ %履歴~取扱い
◎終
に対し：
◎
The shared history push/replace state steps, given a History history, a value data, a scalar value string-or-null url, and a history handling behavior historyHandling, are:
</p>
<ol>
	<li>
%文書 ~LET %履歴 を有する`文書$
◎
Let document be history's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
<p>
任意選択で
⇒
~RET
◎
Optionally, return.＼
</p>

<p>
（例えば~UAは、
この手続きを呼出す~methodが［
~timer ／
利用者による明瞭な動作に呼応して誘発されたものではない~event~listener
］から~callされた場合や, 立て続けに呼出された場合には，許容しないかもしれない。）
◎
(For example, the user agent might disallow calls to these methods that are invoked on a timer, or from event listeners that are not triggered in response to a clear user action, or that are invoked in rapid succession.)
</p>
	</li>
	<li>
%直列形の~data ~LET `StructuredSerializeForStorage$jA( %~data )
— 例外は投出し直す
◎
Let serializedData be StructuredSerializeForStorage(data). Rethrow any exceptions.
</li>
	<li>
%新たな~URL ~LET %文書 の`~URL$doc
◎
Let newURL be document's URL.
</li>
	<li>
<p>
~IF［
%~URL ~NEQ ~NULL
］：
◎
If url is not null, then:
</p>
		<ol>
			<li>
%新たな~URL ~SET `相対的に~URL構文解析する$( %~URL, %履歴 に`関連な設定群~obj$ )
◎
Parse url, relative to the relevant settings object of history.
</li>
			<li>
~IF［
%新たな~URL ~EQ `失敗^i
］
⇒
~THROW `SecurityError$E
◎
If that fails, then throw a "SecurityError" DOMException.
◎
Set newURL to the resulting URL record.
</li>
			<li>
~IF［
`文書の~URLは書直せるか$( %文書, %新たな~URL ) ~EQ ~F
］
⇒
~THROW `SecurityError$E
◎
If document cannot have its URL rewritten to newURL, then throw a "SecurityError" DOMException.
</li>
		</ol>
	</li>
	<li>
`~URLと履歴を更新する$( %文書, %新たな~URL )
— 次も与える下で
⇒＃
`直列形の~data$uuhs ~SET %直列形の~data
`履歴~取扱い$uuhs ~SET %履歴~取扱い
◎
Run the URL and history update steps given document and newURL, with serializedData set to serializedData and historyHandling set to historyHandling.
</li>
</ol>
</div>

<p>
~UAは、
~pageごとに，その~session履歴に追加される状態~objの個数を制限してもヨイ。
~pageが この`実装定義$な上限に抵触した場合、
~UAは，新たな~entryが追加された後に，［
当の`文書$用の~session履歴を成す最初の~entry
］の直後の~entryを除去するモノトスル
（したがって，状態~履歴は、
先に入れたものから抹消されるように動作する（ FIFO ）一方で、
~naviに対しては，先に入れたものが最後に残るように動作する（ LIFO ））。
◎
User agents may limit the number of state objects added to the session history per page. If a page hits the implementation-defined limit, user agents must remove the entry immediately after the first entry for that Document object in the session history after having added the new entry. (Thus the state history acts as a FIFO buffer for eviction, but as a LIFO buffer for navigation.)
</p>

<div class="algo">
<p>
`文書の~URLは書直せるか@
どうかは、
所与の
( `文書$ %文書, `~URL$ %~target~URL )
に対し，次の~algoに従う
（結果が ~T ならば %~target~URL で “書直せる” ）：
◎
A Document document can have its URL rewritten to a URL targetURL if the following algorithm returns true:
</p>
<ol>
	<li>
%文書~URL ~LET %文書 の`~URL$doc
◎
Let documentURL be document's URL.
</li>
	<li>
<p>
~RET ［
次がいずれも満たされるならば ~T ／
~ELSE_ ~F
］：
</p>
		<ul>
			<li>
［
%~target~URL, %文書~URL
］は、
次に挙げるどの成分においても一致する
⇒＃
`~scheme$url,
`~username$url,
`~password$url,
`~host$url,
`~port$url
</li>
			<li>
<p>
［
%~target~URL, %文書~URL
］は、
%~target~URL の`~scheme$urlに応じて，次に挙げるどの成分においても一致する：
</p>
			<dl class="switch">
					<dt>
`~HTTP_S~scheme$
</dt>
					<dd>
なし
</dd>
					<dd>
（［
`https:＠~HTTPinfra#https.uri$sc, `http:＠~HTTPinfra#http.uri$sc
］~URL用には、
【！~RFCx/rfc7230#section-2.7.1／~RFCx/rfc7230#section-2.7.2】
［
`~path$url ／ `~query$url ／ `素片$url
］における相違は許容される。）
</dd>

					<dt>
`file^l
</dt>
					<dd>
`~path$url
</dd>
					<dd>
（ `file:^sc ~URL用には、［
`~query$url ／ `素片$url
］における相違は許容される。）
</dd>

					<dt>
その他
</dt>
					<dd>
`~path$url,
`~query$url
</dd>
					<dd>
（`素片$urlにおける相違に限り許容される。）
</dd>
				</dl>
			</li>
		</ul>
◎
If targetURL and documentURL differ in their scheme, username, password, host, or port components, then return false.
◎
If targetURL's scheme is an HTTP(S) scheme, then return true. (Differences in path, query, and fragment are allowed for http: and https: URLs.)
◎
If targetURL's scheme is "file", and targetURL and documentURL differ in their path component, then return false. (Differences in query and fragment are allowed for file: URLs.)
◎
If targetURL and documentURL differ in their path component or query components, then return false. (Only differences in fragment are allowed for other types of URLs.)
◎
Return true.
</li>
</ol>
</div>

<div class="example">
<div>
<table><thead><tr><th>%文書~URL
<th>%~target~URL
<th>`文書の~URLは書直せるか$
</thead><tbody>

<tr><td>`https://example.com/home^c
<td>`https://example.com/home#about^c
<td>✅

<tr><td>`https://example.com/home^c
<td>`https://example.com/home?page=shop^c
<td>✅

<tr><td>`https://example.com/home^c
<td>`https://example.com/shop^c
<td>✅

<tr><td>`https://example.com/home^c
<td><code>https://user:pass@example.com/home</code>
<td>❌

<tr><td>`https://example.com/home^c
<td>`http://example.com/home^c
<td>❌

<tr><td>`file:///path/to/x^c
<td>`file:///path/to/x#hash^c
<td>✅

<tr><td>`file:///path/to/x^c
<td>`file:///path/to/x?search^c
<td>✅

<tr><td>`file:///path/to/x^c
<td>`file:///path/to/y^c
<td>❌

<tr><td>`about:blank^c
<td>`about:blank#hash^c
<td>✅

<tr><td>`about:blank^c
<td>`about:blank?search^c
<td>❌

<tr><td>`about:blank^c
<td>`about:srcdoc^c
<td>❌

<tr><td>`data:text/html,foo^c
<td>`data:text/html,foo#hash^c
<td>✅

<tr><td>`data:text/html,foo^c
<td>`data:text/html,foo?search^c
<td>❌

<tr><td>`data:text/html,foo^c
<td>`data:text/html,bar^c
<td>❌

<tr><td>`data:text/html,foo^c
<td>`data:bar^c
<td>❌

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43#hash^c
<td>✅

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43?search^c
<td>❌

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:https://example.com/anything^c
<td>❌

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:path^c
<td>❌
</tbody></table>
◎
document's URL 	targetURL 	can have its URL rewritten
https://example.com/home 	https://example.com/home#about 	✅
https://example.com/home 	https://example.com/home?page=shop 	✅
https://example.com/home 	https://example.com/shop 	✅
https://example.com/home 	https://user:pass@example.com/home 	❌
https://example.com/home 	http://example.com/home 	❌
file:///path/to/x 	file:///path/to/x#hash 	✅
file:///path/to/x 	file:///path/to/x?search 	✅
file:///path/to/x 	file:///path/to/y 	❌
about:blank 	about:blank#hash 	✅
about:blank 	about:blank?search 	❌
about:blank 	about:srcdoc 	❌
data:text/html,foo 	data:text/html,foo#hash 	✅
data:text/html,foo 	data:text/html,foo?search 	❌
data:text/html,foo 	data:text/html,bar 	❌
data:text/html,foo 	data:bar 	❌
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43#hash 	✅
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43?search 	❌
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:https://example.com/anything 	❌
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:path 	❌
</div>

<p>
ここでは、
`文書$の`生成元$docは関わらないことに注意。
それは、
次に挙げる様な事例では，文書の`~URL$docの`生成元$urlと合致しないこともある
⇒＃
生成元を他から継承した初期 `~about_blank$sc 文書／
~sandbox化された `iframe$e ／
`document.domain＠~ORIGIN#dom-document-domain$c 設定子が利用されたとき
◎
Note how only the URL of the Document matters, and not its origin. They can mismatch in cases like about:blank Documents with inherited origins, in sandboxed iframes, or when the document.domain setter has been used.
</p>
</div>

<div class="example">

<p>
~gameを考える：
利用者は，常に，ある “線” 上のある座標に居て、
線に沿って~navigateでき，特定0の座標に対応する~pageを~bookmarkすれば後でそこへ戻れるとする。
◎
Consider a game where the user can navigate along a line, such that the user is always at some coordinate, and such that the user can bookmark the page corresponding to a particular coordinate, to return to it later.
</p>

<p>
そのような~gameの，位置 x=5 を実装している静的な~pageとして、
次の様なものがあるとする：
◎
A static page implementing the x=5 position in such a game could look like the following:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 5 に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"&gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"&gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
</pre>
<!-- 
<!DOCTYPE HTML>
<!-&45; this is https://example.com/line?x=5 -&45;>
<title>Line Game - 5</title>
<p>You are at coordinate 5 on the line.</p>
<p>
 <a href="?x=6">Advance to 6</a> or
 <a href="?x=4">retreat to 4</a>?
</p>
-->
<p>
そのような~systemにおいて問題になるのは、
利用者が~clickするたびに，~page全体を読込直す必要が生じることである。
次に、
~scriptを利用して同じことをする別の仕方を示す：
◎
The problem with such a system is that each time the user clicks, the whole page has to be reloaded. Here instead is another way of doing it, using script:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 &lt;span id="coord"&gt;5&lt;/span&gt; に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"
   onclick="go(1); return false;"
 &gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"
   onclick="go(-1); return false;"
 &gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
&lt;script&gt;
 var %currentPage = 5; /* <span class="comment"
>~serverからあてがわれる
◎
prefilled by server
</span> */
 function go(%d) {
   setupPage(%currentPage + %d);
   history.pushState(%currentPage, '', '?x=' + %currentPage);
 }
 onpopstate = function(%event) {
   setupPage(%event.state);
 }
 function setupPage(%page) {
   %currentPage = %page;
   document.title = 'Line Game - ' + %currentPage;
   document.getElementById('coord').textContent = %currentPage;
   document.links[0].href = '?x=' + (%currentPage + 1);
   document.links[0].textContent = 'Advance to ' + (%currentPage + 1);
   document.links[1].href = '?x=' + (%currentPage - 1);
   document.links[1].textContent = 'retreat to ' + (%currentPage - 1);
 }
&lt;/script&gt;
</pre>

<!-- 
<!DOCTYPE HTML>
&lt;!-&45; this starts off as https://example.com/line?x=5 &45;-&gt;
<title>Line Game - 5</title>
<p>You are at coordinate <span id="coord">5</span> on the line.</p>
<p>
 <a href="?x=6" onclick="go(1); return false;">Advance to 6</a> or
 <a href="?x=4" onclick="go(-1); return false;">retreat to 4</a>?
</p>
<script>
 var currentPage = 5; // prefilled by server

-->

<p>
これは、
~scriptの~supportを切っている~systemにおいても，依然として先掲の例の様に働くが、
`切っていない^em利用者は，ずっと高速に~navigateできるようになる
— 同じ体験に対し~network~accessはないので。
更には、
~scriptに基づく素朴な~approachによる利用者~体験と違って，~session履歴を［
~bookmarkする／~navigateする
］のも依然として働く。
◎
In systems without script, this still works like the previous example. However, users that do have script support can now navigate much faster, since there is no network access for the same experience. Furthermore, contrary to the experience the user would have with just a naïve script-based approach, bookmarking and navigating the session history still work.
</p>

<p>
上の例において，
`pushState()$m ~methodに対する %data 引数は、［
~serverへ送信されることになる情報と同じになる
］が［
利用者が~navigateするたびに~scriptが~URLを構文解析しなくとも済むような，より簡便な形
］になる。
◎
In the example above, the data argument to the pushState() method is the same information as would be sent to the server, but in a more convenient form, so that the script doesn't have to parse the URL each time the user navigates.
</p>
</div>

<div class="example">
<p>
ほとんどの~appは、
自身の履歴~entryすべてに対し，それらの`~scroll復旧~mode$用に同じ値を利用したいと求める。
そのためには、
アリな限り早く `scrollRestoration$m 属性を設定して
（例えば、
文書の `head$e 要素~内の `script$e 要素で），［
履歴~sessionに追加された~entryが，欲される~scroll復旧~modeを取得する
］ことを確保することにより，達成できる。
◎
Most applications want to use the same scroll restoration mode value for all of their history entries. To achieve this they can set the scrollRestoration attribute as soon as possible (e.g., in the first script element in the document's head element) to ensure that any entry added to the history session gets the desired scroll restoration mode.
</p>

<pre class="lang-html">
&lt;head&gt;
  &lt;script&gt;
       if ('scrollRestoration' in history)
            history.scrollRestoration = 'manual';
  &lt;/script&gt;
&lt;/head&gt;
</pre>
</div>

			</section>
			<section id="nav-traversal-event-interfaces">
<h4 title="Event interfaces">7.2.6. ~event~interface</h4>

				<section id="the-popstateevent-interface">
<h5 title="The PopStateEvent interface">7.2.6.1. `PopStateEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `PopStateEvent@I : `Event$I {
  constructor(DOMString %type, optional `PopStateEventInit$I %eventInitDict = {});

  readonly attribute any `state$m0;
};

dictionary `PopStateEventInit@I : `EventInit$I {
  any state = null;
};
</pre>

<dl class="domintro">
	<dt>%event.`state$m0</dt>
	<dd>
`pushState()$m ／ `replaceState()$m
に供された情報の複製を返す。
◎
Returns a copy of the information that was provided to pushState() or replaceState().
</dd>
</dl>

<dl class="idl-def">
	<dt>`state@m0</dt>
	<dd>
取得子は、
初期化-時の値を返すモノトスル。
◎
The state attribute must return the value it was initialized to.＼
</dd>
	<dd>
この~event用の文脈~情報を表現する。
表現される状態が`文書$の初期~状態の場合は ~NULL になる。
◎
It represents the context information for the event, or null, if the state represented is the initial state of the Document.
</dd>
</dl>

				</section>
				<section id="the-hashchangeevent-interface">
<h5 title="The HashChangeEvent interface">7.2.6.2. `HashChangeEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `HashChangeEvent@I : `Event$I {
  constructor(DOMString %type, optional `HashChangeEventInit$I %eventInitDict = {});

  readonly attribute USVString `oldURL$m;
  readonly attribute USVString `newURL$m;
};

dictionary `HashChangeEventInit@I : `EventInit$I {
  USVString oldURL = "";
  USVString newURL = "";
};
</pre>

<dl class="domintro">
	<dt>%event.`oldURL$m</dt>
	<dd>
履歴を辿る直前の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that was previously current.
</dd>
	<dt>%event.`newURL$m</dt>
	<dd>
履歴を辿った直後の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that is now current.
</dd>
</dl>

<dl class="idl-def">
	<dt>`oldURL@m</dt>
	<dd>
取得子は、
初期化-時の値を返すモノトスル。
◎
The oldURL attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、
この~event用の文脈~情報
— 特定的には、
履歴を辿る直前の`~session履歴~entry$の~URL —
を表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed from.
</dd>

	<dt>`newURL@m</dt>
	<dd>
取得子は、
初期化-時の値を返すモノトスル。
◎
The newURL attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、
この~event用の文脈~情報
— 特定的には、
履歴を辿った直後の`~session履歴~entry$の~URL —
を表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed to.
</dd>
</dl>

				</section>
				<section id="the-pagetransitionevent-interface">
<h5 title="The PageTransitionEvent interface">7.2.6.3. `PageTransitionEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `PageTransitionEvent@I : `Event$I {
  constructor(DOMString %type, optional `PageTransitionEventInit$I %eventInitDict = {});

  readonly attribute boolean `persisted$m;
};

dictionary `PageTransitionEventInit@I : `EventInit$I {
  boolean persisted = false;
};
</pre>

<dl class="domintro">
	<dt>%event.`persisted$m</dt>
	<dd>
`pageshow$et ~eventに対しては、［
当の~pageが新たに読込まれつつある（したがって `load$et ~eventが発火されることになる）ならば ~F ／
~ELSE_ ~T
］を返す。
◎
For the pageshow event, returns false if the page is newly being loaded (and the load event will fire). Otherwise, returns true.
</dd>
	<dd>
`pagehide$et ~eventに対しては、［
当の~pageが最後に消え去るときには ~F ／
~ELSE_ ~T
］を返す。
~T は、
この~pageは，利用者がこの~pageに~navigateして戻った場合に
（かつ，当の`文書$の`回復可能~状態$docが ~T のままであれば）
再利用され得ることを意味する。
◎
For the pagehide event, returns false if the page is going away for the last time. Otherwise, returns true, meaning that the page might be reused if the user navigates back to this page (if the Document's salvageable state stays true).
</dd>
	<dd>
<p>
~pageを回復可能でなくするものには、
次が含まれる：
◎
Things that can cause the page to be unsalvageable include:
</p>
		<ul>
			<li>
~UAは、
当の`文書を~unload＠~HTMLlifecycle#unload-a-document$した後に，［
その文書は，`~session履歴~entry$内で生存し続けない
］ものと裁定した
◎
The user agent decided to not keep the Document alive in a session history entry after unload
</li>
			<li>
`回復可能＠~HTMLlifecycle#concept-document-salvageable$でない `iframe$e があるとき
◎
Having iframes that are not salvageable
</li>
			<li>
作動中の `WebSocket$I ~objがあるとき
◎
Active WebSocket objects
</li>
			<li>
`文書を中止した＠~HTMLlifecycle#abort-a-document$とき
◎
Aborting a Document
</li>
		</ul>
	</dd>
</dl>

<dl class="idl-def">
	<dt>`persisted@m</dt>
	<dd>
取得子は、
初期化-時の値を返すモノトスル。
◎
The persisted attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは~eventの文脈~情報を表現する。
◎
It represents the context information for the event.
</dd>
</dl>

<div class="algo">
<p>
`~page遷移~eventを発火する@
ときは、
所与の
( `Window$I %~window, %~event名, 真偽値 %持続されるか )
に対し
⇒
`~eventを発火する$( %~window, %~event名, `PageTransitionEvent$I )
— `~targetを上書きする^i 下で，および次のように初期化して
⇒＃
`persisted$m 属性 ~SET %持続されるか,
`cancelable$m 属性 ~SET ~T,
`bubbles$m 属性 ~SET ~T
◎
To fire a page transition event named eventName at a Window window with a boolean persisted, fire an event named eventName at window, using PageTransitionEvent, with the persisted attribute initialized to persisted, the cancelable attribute initialized to true, the bubbles attribute initialized to true, and legacy target override flag set.
</p>

<p class="note">注記：
`cancelable$m, `bubbles$m 用の値は、
イミを成さない
— 当の~eventを取消しても何もしないし，
`Window$I ~objを過ぎて浮上することはアリでないので。
これらが ~T に設定されるのは、
歴史的な理由による。
◎
The values for cancelable and bubbles don't make any sense, since canceling the event does nothing and it's not possible to bubble past the Window object. They are set to true for historical reasons.
</p>
</div>

				</section>
				<section id="the-beforeunloadevent-interface">
<h5 title="The BeforeUnloadEvent interface">7.2.6.4. `BeforeUnloadEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `BeforeUnloadEvent@I : `Event$I {
  attribute DOMString `returnValue$m;
};
</pre>

<p class="note">注記：
`BeforeUnloadEvent$I に特有な初期化~methodはない。
◎
There are no BeforeUnloadEvent-specific initialization methods.
</p>

<p>
`BeforeUnloadEvent$I
~interfaceは、
旧来の~interfaceである
— それは、［
~eventを取消すのみならず，
`returnValue$m 属性を空~文字列でない値に設定する
］ことにより，
`利用者が~unloadするのを取消したか否か検査する$ことを許容する。
作者は `returnValue$m を利用する代わりに `preventDefault()$m ~method, または~eventを取消す他の手段を利用するベキである。
◎
The BeforeUnloadEvent interface is a legacy interface which allows checking if unloading is user-canceled to be controlled not only by canceling the event, but by setting the returnValue attribute to a value besides the empty string. Authors should use the preventDefault() method, or other means of canceling events, instead of using returnValue.
</p>

<dl class="idl-def">
	<dt>`returnValue@m</dt>
	<dd>
この属性は、
`利用者が~unloadするのを取消したか否か検査する$処理nを制御する。
◎
The returnValue attribute controls the process of checking if unloading is user-canceled.＼
</dd>
	<dd>
~eventの作成-時には、
この属性は空~文字列に設定するモノトスル。
◎
When the event is created, the attribute must be set to the empty string.＼
</dd>
	<dd>
取得子は、
この属性に最後に設定された値を返すモノトスル。
◎
On getting, it must return the last value it was set to.＼
</dd>
	<dd>
設定子は、
この属性を所与の値に設定するモノトスル。
◎
On setting, the attribute must be set to the new value.
</dd>
	<dd class="note">注記：
この属性が `DOMString^I にされているのは、
もっぱら歴史的な理由による。
空~文字列~以外のどの値も，利用者に確認をとるよう要請するものと扱われる。
◎
This attribute is a DOMString only for historical reasons. Any value besides the empty string will be treated as a request to ask the user for confirmation.
</dd>
</dl>

				</section>
			</section>
		</section>
</main>
