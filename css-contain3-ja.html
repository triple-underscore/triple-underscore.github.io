<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Containment Module Level 3 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'p':
	{
		const i = key.indexOf(':');
		if(i > 0) {
			key = text.slice(0, i);
			text = `${key}: <code class="value">${text.slice(i + 1)}</code>`;
		}
	}
	break;
case 'tp': // property value type
	text = `&lt;'<code class="property">${key}</code>'&gt;`;
	href = link_map[`p.${key}`];
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 'at': 
	text = `@${key}`;
	break;
case 'f': 
	text = `${key}()`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'm':
	{
		const n = text.indexOf('(');
		if(n > 0){
			key = text.slice(0, n);
			text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
		}
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Containment Module Level 3
spec_date:2024-03-15
trans_update:2024-03-16
source_checked:230807
page_state_key:CSS
original_url:https://drafts.csswg.org/css-contain-3/
	abbr_url:CSSCONTAIN3
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-ux,css
conformance:css
copyright:2024,permissive
trans_1st_pub:2023-11-06


●●class_map
p:property
d:descriptor
pe:pseudo
css:css
at:at-rule
e:element
t:type
tp:type
f:func
v:value
u:unit
vC:value
et:event-type

●●tag_map
p:code
d:code
pe:code
at:code
t:var
tp:var
u:code
css:code
e:code
I:code
m:code
c:code
et:code
v:code
f:code
vC:code
V:var
i:i
em:em
cite:cite

●●original_id_map

●●mdn_urls
propdef-contain:CSS/contain
propdef-content-visibility:CSS/content-visibility

●●link_map



	●IDL
CSSOMString:~CSSOM1#cssomstring
Exposed:~WEBIDLjs#Exposed
I.CSSConditionRule:~CSSCOND#cssconditionrule
I.CSSContainerRule:#csscontainerrule
I.MediaQueryList:~CSSOMVIEW#mediaquerylist
m.matchMedia:~CSSOMVIEW#dom-window-matchmedia
m.conditionText:~CSSCOND#dom-cssconditionrule-conditiontext
m.containerName:#dom-csscontainerrule-containername
m.containerQuery:#dom-csscontainerrule-containerquery

	●css
at.container:#at-ruledef-container
at.font-face:~CSSFONT#at-font-face-rule
	at.font-face:~CSSFONT5#at-font-face-rule
at.keyframes:~CSSANIM#at-ruledef-keyframes
at.layer:~CASCADE#at-ruledef-layer
at.supports:~CSSCOND#at-ruledef-supports

d.aspect-ratio:#descdef-container-aspect-ratio
d.block-size:#descdef-container-block-size
d.height:#descdef-container-height
d.inline-size:#descdef-container-inline-size
d.orientation:#descdef-container-orientation
d.width:#descdef-container-width

p.aspect-ratio:~SIZING#propdef-aspect-ratio
	p.aspect-ratio:~SIZING4#propdef-aspect-ratio
p.contain:~CSSCONTAIN#propdef-contain
p.container-name:#propdef-container-name
p.container-type:#propdef-container-type
p.container:#propdef-container
p.content-visibility:#propdef-content-visibility
p.display:~CSSDISP#propdef-display
p.font-size:~CSSFONT#propdef-font-size
p.line-height:~CSS2J#propdef-line-height
p.min-width:~SIZING#propdef-min-width
p.visibility:~CSSDISP#propdef-visibility
pe.after:~CSSPSEUDO#selectordef-after
pe.backdrop:~CSSPOS4#selectordef-backdrop
pe.before:~CSSPSEUDO#selectordef-before
pe.file-selector-button:~CSSPSEUDO#selectordef-file-selector-button
pe.first-letter:~CSSPSEUDO#selectordef-first-letter
pe.first-line:~CSSPSEUDO#selectordef-first-line
pe.marker:~CSSPSEUDO#selectordef-marker
pe.part():~CSSSHADOWPARTS#selectordef-part
pe.placeholder:~CSSPSEUDO#selectordef-placeholder
pe.slotted():~CSSSCOPING#selectordef-slotted

t.block-contents:~CSSSYN#typedef-block-contents
t.container-condition:#typedef-container-condition
t.container-name:#typedef-container-name
t.container-query:#typedef-container-query
t.custom-ident:~CSSVAL#identifier-value
t.custom-property-name:~CSSVAR#typedef-custom-property-name
t.general-enclosed:~MQ5#typedef-general-enclosed
t.length:~CSSVAL#length-value
t.query-in-parens:#typedef-query-in-parens
t.ratio:~CSSVAL#ratio-value
t.size-feature:#typedef-size-feature
t.string:~CSSVAL#string-value
t.style-feature:#typedef-style-feature
t.style-in-parens:#typedef-style-in-parens
t.style-query:#typedef-style-query

u.em:~CSSVAL#em

v.size:#valdef-container-type-size
v.inline-size:#valdef-container-type-inline-size
v.~inline-size0:#valdef-contain-inline-size
v.normal:#valdef-container-type-normal
v.none:#valdef-container-name-none
v.portrait:#valdef-container-orientation-portrait
v.landscape:#valdef-container-orientation-landscape

v.not:~MQ5#valdef-media-not
v.revert-layer:~CASCADE#valdef-all-revert-layer
v.revert:~CASCADE#valdef-all-revert
v.table:~CSSDISP#valdef-display-table
v.hidden:~CSSCONTAIN#valdef-content-visibility-hidden

f.var:~CSSVAR#funcdef-var

	●用語
~query容器:#query-container
~query容器~名:#query-container-name
~size特能:#size-features
~style特能:#style-features
容器~query:#container-query
容器~query長さ:#container-query-length
容器~query長さ単位:#container-query-length
容器~size~query:#container-size-query
容器~style~query:#container-style-query
容器~特能:#container-feature
行内-~size封込め:#inline-size-containment

	●用語（2
~level 2:#biblio-css-contain-2

~size封込め:~CSSCONTAIN#size-containment
~style封込め:~CSSCONTAIN#style-containment
封込め:~CSSCONTAIN#containment
~layout封込め:~CSSCONTAIN#layout-containment
~layout封込め~box:~CSSCONTAIN#layout-containment-box

	●用語（CSS
~CSS全域~keyword:~CSSVAL#css-wide-keywords
~CSS識別子:~CSSVAL#css-css-identifier
小さい表示域~size:~CSSVAL#small-viewport-size
相対~長さ単位:~CSSVAL#relative-length
比率:~CSSVAL#ratio

~at-規則:~CSSSYN#at-rule
~style規則:~CSSSYN#style-rule
宣言:~CSSSYN#declaration

~cascadeに依存する~keyword:~CASCADE#cascade-dependent-keyword
~prop:~CASCADE#css-property
下位prop:~CASCADE#longhand
初期~値:~CASCADE#initial-value
略式~prop:~CASCADE#shorthand-property
算出d値:~CASCADE#computed-value
算出-:~CASCADE#computed-value

条件付き~group規則:~CSSCOND#conditional-group-rule
~CSS特能~query:~CSSCOND#css-feature-queries

範囲~文脈:~MQ5#range-context
媒体~query:~MQ5#media-query
媒体~特能:~MQ5#media-feature

離散的:~WANIM#discrete
	＠~WANIM#effect-value
~animation型:~WANIM#animation-type
~style変化~event:~TRANSITION#style-change-event

不可分な行内:~CSSDISP#atomic-inline
内縁~表示~型:~CSSDISP#inner-display-type
内部~ruby~box:~CSSDISP#internal-ruby-box
内部~table~box:~CSSDISP#internal-table-box
整形~文脈:~CSSDISP#formatting-context
行内~level:~CSSDISP#inline-level
首要~box:~CSSDISP#principal-box

内容~box:~CSSBOX#content-box

~size:~SIZING#size
縦幅:~SIZING#height
横幅:~SIZING#width
内在的~size:~SIZING#intrinsic-size
最小-内容~size:~SIZING#min-content

塊-軸:~CSSWM#block-axis
塊~size:~CSSWM#block-size
行内-軸:~CSSWM#inline-axis
行内~size:~CSSWM#inline-size

~supportされる~CSS~prop:~CSSOM1#supported-css-property

仮想の~tag列:~CSSPSEUDO#fictional-tag-sequence
疑似-複合~選択子:~SELECTORS4#pseudo-compound
断片化-:~CSSBREAK#fragmentation

最終的な出自の要素:~SELECTORS4#ultimate-originating-element
出自の要素:~SELECTORS4#originating-element

~custom~prop:~CSSVAR#custom-property


	●用語（他
~shadowも含めた子孫:~DOM4#concept-shadow-including-descendant
~shadowも含めた広義-先祖:~DOM4#concept-shadow-including-inclusive-ancestor
~shadow~host:~DOM4#element-shadow-host
~shadow~tree:~DOM4#concept-shadow-tree

連結する:~INFRA#string-concatenate


●●words_table1
CSSSHADOWPARTS:css-shadow-parts-ja.html
inline-size0:inline-size

●●words_table

	●layout
封込め:containment::封じ込め
首要:principal::主要
不可分:atomic::~
ruby::::ルビ
浮動体:float::~
浮動-:float::~
	浮動体:floating boxes
	浮動体:floated div
	3 個の浮動体:the floated boxes
縦横比:aspect-ratio::~
縦方向:vertical::~
横方向:horizontal::~
断片化-:fragment::~
ズラす:shiftする:ずらす
ズラさ:shiftさ:ずらさ
押出され:pushされ:押し出され
押出す:pushする:押し出す
接合-:flush:~
衝突-:collide:~
収まる:fitする:~

	●MQ
条件付けら:conditionさ::~
真:true::~
偽:false::~
	`真^i:true
	`偽^i:false
	`未知^i:unknown
比較子:comparator:~
論理:logic:~
	真偽-条件:boolean
比率:ratio::~

	●CSS
For:for:用途
広義-:inclusive:~
出自の:originating::~
疑似-:pseudo-::~
複合:compound::~
全域:wide-:~
代用:substitution::~
代用-:substitute::~

	●仕様
差分:diff:~
探求段階:exploratory:~
	探求段階:Exploratory
安定的:stable:~
	勧告候補:CR
仮想の:fictionalな:~
素朴:naive:~
分析:analysis:~
	に依存するようになる:create a dependency
目指す:aimする:~
収容-:accommodate:~
適格:eligible:~
誤記:typo:~
誤り:error:~
解明-:figure out:~
伝えら:informさ:~

	規範的でない:informative
	得るため:for the sake
	上手に:well
	その帰結として:consequent
	能力がある:capable
	問題になり得る:problematic
	問題になり得ることが既知な:known-problematic
	応答-可能:responsive
	不要な:unneeded
	~~強力:heavy
	取って代わる:supersede
	注記-:note
	~~起因する:caused by

	●言い換え
	~~縮約-:reduce
	評価が変化したとき:starts (or stops) applying
	種別~選定~用の:type-selection
	容器~query:Container Query
	ResizeObserver:resizeObserver
	~~前進する:moves forward
	~typographic~style:typographic concerns
	上に挙げたものでない:remaining
	3 個目の:final
	そうでない場合には，:but to the extent that they don’t
	種別~選定:type-selection
	~shadow~DOM:shadow-DOM
	連結する$:join
	^p:font-size
	^p:container-type
	`main^e main
	`aside^e:sidebar
	`.my-component^css の行内~size:width of 〜 inline-container
	塊~size:height

	●未分類
重複:duplicate:~
併合-:merge:~
component::::コンポーネント
typography::::タイポグラフィ
typographic::::タイポグラフィック
復帰-:revert:~
単調:monotonic:~
循環:cycle:~
正方形:square:~

	し続ける:continue
	右:right
	左上隅, 右上隅:left and right corners
	オンに:turn on
	下げられ:cleared down
	居座る:sitting
	~~十分な幅:plenty wide enough
	側方:beside
	時点:point
	過ぎる:past
	つなげる:string
	寸法に関する:dimensional
	逆に:reverse
	括弧:parentheses
	評価-時の:on evaluating
	無かった:present
	十分:enough
	残り:rest
	戻る:back
	にも:back
	それまでの:previously
	これまでの:earlier
	そのときの:previous
	これまでの:previous
	小さく:small
	より低く:lower-
	短く:short
	幅が広過ぎる:too wide
	幅の:wide
	高さ:tall
	狭い:narrow
	大き過ぎる:too large
	隣に:next to
	一部:part
	を~~基準に:with respect
	小さい方:smaller
	大きい方:larger
	来て:come
	最も近い:nearest
	上下に:up and down
	満たす:meet
	上回る:above


●●ref_normative

[CSS-ANIMATIONS-1]
    David Baron; et al. ＜CSS Animations Level 1＞. URL: https://drafts.csswg.org/css-animations/
[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-BREAK-3]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 3＞. URL: https://drafts.csswg.org/css-break/
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 4＞. URL: https://drafts.csswg.org/css-cascade-4/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-CONDITIONAL-3]
    David Baron; Elika Etemad; Chris Lilley. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/
[CSS-CONTAIN-1]
    Tab Atkins Jr.; Florian Rivoal. ＜CSS Containment Module Level 1＞. URL: https://drafts.csswg.org/css-contain-1/
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. ＜CSS Containment Module Level 2＞. URL: https://drafts.csswg.org/css-contain-2/
[CSS-DISPLAY-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Display Module Level 3＞. URL: https://drafts.csswg.org/css-display/
[CSS-DISPLAY-4]
    ＜CSS Display Module Level 4＞. Editor's Draft. URL: https://drafts.csswg.org/css-display-4/
[CSS-FONTS-5]
    Myles Maxfield; Chris Lilley. ＜CSS Fonts Module Level 5＞. URL: https://drafts.csswg.org/css-fonts-5/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-TRANSITIONS-1]
    David Baron; et al. ＜CSS Transitions＞. URL: https://drafts.csswg.org/css-transitions/
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. URL: https://drafts.csswg.org/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-VARIABLES-2]
    ＜CSS Custom Properties for Cascading Variables Module Level 2＞. Editor's Draft. URL: https://drafts.csswg.org/css-variables-2/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. URL: https://drafts.csswg.org/css-writing-modes-4/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[CSSOM-VIEW-1]
    Simon Pieters. ＜CSSOM View Module＞. URL: https://drafts.csswg.org/cssom-view/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[MEDIAQUERIES-5]
    Dean Jackson; et al. ＜Media Queries Level 5＞. URL: https://drafts.csswg.org/mediaqueries-5/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[WEB-ANIMATIONS-1]
    Brian Birtles; et al. ＜Web Animations＞. URL: https://drafts.csswg.org/web-animations-1/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-FONTS-4]
    John Daggett; Myles Maxfield; Chris Lilley. ＜CSS Fonts Module Level 4＞. URL: https://drafts.csswg.org/css-fonts-4/
[CSS-POSITION-4]
    ＜CSS Positioned Layout Module Level 4＞. Editor's Draft. URL: https://drafts.csswg.org/css-position-4/
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. ＜CSS Pseudo-Elements Module Level 4＞. URL: https://drafts.csswg.org/css-pseudo-4/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. URL: https://drafts.csswg.org/css-scoping/
[CSS-SHADOW-PARTS-1]
    Tab Atkins Jr.; Fergal Daly. ＜CSS Shadow Parts＞. URL: https://drafts.csswg.org/css-shadow-parts/
[CSS-SIZING-4]
    Tab Atkins Jr.; Elika Etemad; Jen Simmons. ＜CSS Box Sizing Module Level 4＞. URL: https://drafts.csswg.org/css-sizing-4/
[CSS22]
    Bert Bos. ＜Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification＞. URL: https://drafts.csswg.org/css2/

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Containment Module Level 3</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-contain-3/
公表履歴
	https://www.w3.org/standards/history/css-contain-3/
テスト一式
	https://test.csswg.org/harness/results/css-contain-1_dev/
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-contain-3">CSSWG Issues Repository</a>
編集
	<a href="http://xanthir.com/contact/">Tab Atkins</a> (Google)
	<a href="https://florian.rivoal.net/">Florian Rivoal</a> (On behalf of Bloomberg)
	<a href="https://www.miriamsuzanne.com/who/">Miriam E. Suzanne</a> (Invited Expert)
Suggest an Edit for this Spec:
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-contain-3/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-contain-3

</script>

</head>
<body>


<header>
	<hgroup>
<h1>CSS による封じ込め — CSS Containment Module Level 3</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この~CSS~moduleは、
`contain$p ~propを述べる
— それは、
要素の下位treeが~pageを成す残りとは独立であることを指示する。
これは、
上手に利用すれば，~UAによる~~強力な最適化を可能化する。
◎
This CSS module describes the contain property, which indicates that the element’s subtree is independent of the rest of the page. This enables heavy optimizations by user agents when used well.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p class="issue">
これは、
`~level 2$ に対する差分~仕様であり，
現時点では探求段階な作業草案である。
実装者は、
`~level 2$ を参照として利用されたし。
`~level 2$ が勧告候補に達したなら、
その~textは，この草案の中に併合されることになる。
◎
This is a diff spec over CSS Containment Level 2. It is currently an Exploratory Working Draft: if you are implementing anything, please use Level 2 as a reference. We will merge the Level 2 text into this draft once it reaches CR.
</p>

		<section id="interaction">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
この文書は、
これまでの仕様には無かった新たな特能を定義する。
加えて、
安定的になったときは，
`CSS-CONTAIN-1$r 【 `CSS-CONTAIN-2$r 】 を置換して それに取って代わることを目指す。
◎
This document defines new features not present in earlier specifications. In addition, it aims to replace and supersede [CSS-CONTAIN-1] once stable.
</p>

		</section>
		<section id="values">
<h3 title="Value Definitions">1.2. 値~定義</h3>

<p class="trans-note">【
この節の内容は `~CSS日本語訳 共通~page＠~CSScommon#values$に移譲。
】</p>

		</section>
	</section>
	<section id="contain-property">
<h2 title="Strong Containment: the contain property">2. 強い封込め： `contain^p ~prop</h2>

<p class="issue">
`~level 2$ の `§ 強い封込め＠~CSSCONTAIN#contain-property$
をここに併合する。
◎
CSS Containment 2 § 2 Strong Containment: the contain property
</p>

◎名 `contain$p
◎値 `none^v | `strict^v | `content^v | [ [`size^v | `inline-size^v] || `layout^v || `style^v || `paint^v ]
◎表終

<dl class="valdef">
	<dt>`~inline-size0@v</dt>
	<dd>
この値は、
当の要素~用に`行内-~size封込め$をオンにする。
これは、
要素の`首要~box$の`行内~size$が要素の内容に直に依存することを防止する。
◎
This value turns on inline-size containment for the element. This prevents the inline-size of its principal box from directly depending on its contents.
</dd>
	<dd class="note">注記：
それでも、
間接的な依存関係は あり得る
— `§ 行内-~size封込め＠#containment-inline-size$
を見よ。
◎
Note: There can still be indirect dependencies, see § 3.1 Inline-Size Containment.
</dd>
</dl>

	</section>
	<section id="containment-types">
<h2 title="Types of Containment">3. 封込めの種別</h2>

<p class="issue">
`~level 2$ の `§ 封込めの種別＠~CSSCONTAIN#containment-types$
をここに併合する。
◎
CSS Containment 2 § 3 Types of Containment
</p>

		<section id="containment-inline-size">
<h3 title="Inline-Size Containment">3.1. 行内-~size封込め</h3>

<p>
要素に
`行内-~size封込め@
を与えることは、
要素の`首要~box$の`行内-軸$の~sizingに`~size封込め$を適用する。
このことは、［
`首要~box$の`行内-軸$`内在的~size$は，要素の内容は無かったかのように決定される
］ことを意味する。
しかしながら、
内容は，当の~boxの`塊-軸$における`内在的~size$には通例通り影響iし続ける
— 当の~boxを`塊-軸$において`断片化-$することは、
通常に許容される。
◎
Giving an element inline-size containment applies size containment to the inline-axis sizing of its principal box. This means the inline-axis intrinsic sizes of the principal box are determined as if the element had no content. However, content continues to impact the box’s block-axis intrinsic sizes as usual, and the box is allowed to fragment normally in the block axis.
</p>

<div class="note">
<p>
注記：
~boxの`塊-軸$における`内在的~size$は、
当の~boxの`行内~size$に影響する仕方で，親`整形~文脈$における~layoutに影響iし得る事例もある（例：ある先祖~要素にて，【塊-軸~方向の】~scrollbarを誘発することにより）
— それに伴い、
当の~boxの`行内~size$は，自身の内容に依存するようになる。
`行内~size$における この変化による結果，`塊~size$が変化する場合、
その変化は，親~整形~文脈に更に影響iし得るよう~loopすることになるが、
それまでの問題になり得る~layoutへ復帰することはない。
◎
Note: In some cases, a box’s block-axis intrinsic sizes can impact layout in the parent formatting context in ways that affect the box’s inline size (e.g. by triggering scrollbars on an ancestor element), creating a dependency of the box’s inline size on its own content. If this changed inline size results in a different block size, that new block size can loop into further impacting the parent formatting context, but not in a way that reverts it to the previously-problematic layout.
</p>

<p>
例えば，~scrollbarが導入された場合、
その帰結として［
`塊~size$が~scrollbarを必要としないほど十分に小さくなった場合
］でも†，当の~scrollbarは除去されない。
あるいは、［
~boxの論理-縦幅が より低く配置された浮動体に衝突して，
~boxが もっと可用な行内~空間がある所まで下げられ、
その結果，論理-縦幅が衝突しなくなるほど十分に短くなった場合
］でも
【下の例を見よ】、
それまでの問題になり得る~sizeと位置まで戻るよう移動されることは無い。
◎
For example, if scrollbars were introduced, they are not then removed, even if the consequent block size is small enough to not need them; or if a box’s logical height collides with a lower-placed float and is cleared down to where it also has more available inline space and thus becomes short enough to not have collided, it is not them moved back up to its previous problematic size and position.
</p>

<p class="trans-note">【†
通例的には，~scrollbarにより行内~sizeが減れば塊~sizeは自動的に増えることになるが、
ここでは， `aspect-ratio$p により両~sizeが相関していることが前提にあると思われる。
】</p>

<p>
したがって、
`行内-~size封込め$は［
当の~boxの内容が，
自身の`行内-軸$における`内在的~size$を通して自身の`行内~size$に直に影響する
］ことは防止するが，それでも、
当の~boxの`行内~size$は，［
自身の`塊~size$に対する効果
］により自身の内容に間接的に依存し得る。
◎
Thus, although inline-size containment prevents the box’s content from directly affecting its inline size through its inline-axis intrinsic sizes, its inline size can still indirectly depend on its contents by their effect on its block size.
</p>
</div>

<p class="issue">
要素の行内~sizeと塊~sizeの関係性は、
一般に，予測-不能であり単調ではない
— 行内~sizeが変化するに伴い、
塊~sizeを任意に上下へズラす能力がある。
無限な循環は、［
~layoutが，それまでの（問題になり得ることが既知な）状態へは復帰しない
］ことを
— 拘束の素朴な分析が，そのようなものを許容することになる場合でも —
確保することにより防止される。
言い換えれば、
~layoutは，常に “~~前進する” 。
現在の~CSS~layout仕様は，そのような規則を組入れるものと予見されているが、
そうでない場合，誤りが正されるよう`~CSS~WGへ伝えられたし＠https://github.com/w3c/csswg-drafts/issues$。
◎
In general, the relationship between an element’s inline size and it’s block size is unpredictable and non-monotonic, with the block size capable of shifting up and down arbitrarily as the inline size is changed. Infinite cycles are prevented by ensuring that layout does not revert to a previous (known-problematic) state, even if a naive analysis of the constraints would allow for such; in other words, layout always “moves forward”. We believe that current CSS layout specifications incorporate such rules, but to the extent that they don’t, please inform the CSSWG so that these errors can be corrected.
</p>

<div class="example">
<p>
次の例を考える。
そこでは、
浮動体の配置は，塊~sizeの行内~sizeに依存するようになる：
◎
Consider this example, where float placement creates a dependency of block sizes on inline sizes:
</p>
<pre class="lang-html">
&lt;section style="width: 200px; border: solid; display: flow-root;"&gt;
  &lt;!-- <span class="comment">
可用な空間に影響iする浮動された要素たち
◎
floated elements that impact the available space
</span> --&gt;
  &lt;div style="float: left; width: 50px; height: 80px; background: blue;"&gt;&lt;/div&gt;
  &lt;div style="float: right; width: 50px; height: 80px; background: blue;"&gt;&lt;/div&gt;
  &lt;div style="float: left; width: 160px; height: 80px; background: navy;"&gt;&lt;/div&gt;

  &lt;!-- <span class="comment">
文脈を決定している親~layout
◎
parent layout, determining context
</span> --&gt;
  &lt;article style="border: solid orangered; display: flow-root; min-width: min-content"&gt;
    &lt;div style="background: orange; aspect-ratio: 1/1;"&gt;
      Article
    &lt;/div&gt;
  &lt;/article&gt;
&lt;/section&gt;
</pre>

<figure style="float: left; margin: 1em 0.5em">
<section style="width: 200px; border: solid; display: flow-root;">
<div style="float: left; width: 50px; height: 80px; background: blue;"></div>
<div style="float: right; width: 50px; height: 80px; background: blue;"></div>
<div style="float: left; width: 160px; height: 80px; background: navy;"></div>
<article style="border: solid orangered; display: flow-root; min-width: 50px">
<div style="background: orange; aspect-ratio: 1/1;">Article</div>
</article>
</section>
</figure>

<p>
塊~layout~algoは、
まず，浮動体たちを配置する。
最初の 2 個は容器の［
左上隅, 右上隅
］に居座る。
3 個目は、
それらの合間に収まるには幅が広過ぎるので下へ押出される。
◎
The block layout algorithm will first place the floating boxes, with the first two sitting in the left and right corners of the container, and the third, being too wide to fit between, being pushed below them.
</p>

<p>
後続している `article^e
— 以下 %A と記す —
は、
それから~lay-outされることになる。
%A の `display$p は `flow-root^v なので、
どの浮動体とも交差し得ない。
したがって、
%A を~sizeして位置する方法を解明するときには，それらを織り込む必要がある。
◎
The following article will then be laid out. Because it is display: flow-root, it cannot intersect any floats, and thus must take them into account when figuring out how to size and position itself.
</p>

<p>
~layout~engineは、
まず， %A を当の容器の上端に接合するように配置することを試みる。
残された
— したがって結果の —
横幅は `100px^v であり、
%A の`最小-内容~size$を収容するには~~十分な幅がある。
しかしながら，
%A の子の `aspect-ratio$p に因り %A の高さも `100px^v になり、
80px 下にある 3 個目の浮動体に交差するので，この~layout機会は破棄される。
◎
The layout engine first attempts to place the article flush with the top of the container, resulting a 100px width, plenty wide enough to accommodate its min-content size. However, due to the aspect-ratio of its child, this would cause the article to be 100px tall as well, which would intersect the third float 80px below, so this layout opportunity is discarded.
</p>

<p>
次に、
%A を［
2 個目の浮動体の下端と 3 個目の浮動体の右端
］に接合するよう位置することを試みる。
しかしながら、
3 個目の浮動体の側方にある狭い `40px^v 幅の空間~内に %A 【の内容 "Article" 】が収まるには， %A の `min-width$p は大き過ぎた
— その結果、
%A は それよりさらに下へズラされ，
3 個の浮動体~すべてより下に 200px の正方形を形成する。
◎
It then attempts to position the article flush with the top of the third float, in the narrow 40px-wide space to its right. However, since the article’s min-width makes it too large to fit in the 40px-wide space beside the third float, it shifts below that one as well, forming a 200px square below all the floated boxes.
</p>

<figure style="float: right; margin: 1em 0.5em">
<section style="width: 200px; border: solid; display: flow-root;">
<div style="float: left; width: 50px; height: 80px; background: blue;"></div>
<div style="float: right; width: 50px; height: 80px; background: blue;"></div>
<div style="float: left; width: 160px; height: 80px; background: navy;"></div>
<article style="border: solid orangered; display: flow-root;">
<div style="background: orange; aspect-ratio: 1/1;"> Article</div>
</article>
</section>
</figure>

<p>
%A から `min-width$p が除去されるか［
%A または その~header【 "Article" 】
］に`行内-~size封込め$が追加された場合
（後者は、
`min-width^p に指定された `min-content^v を 0 に解決させる）、
%A は 3 個目の浮動体の隣に 40px 正方形として収まることになる
（場合によっては、
その内容を成す一部は~overflowする）。
◎
If the min-width is removed from the article, or if inline-size containment is added to either the article or header (causing min-width: min-content to resolve to zero), then the article will fit as a 40px square next to the final floated div (possibly with some of its content overflowing).
</p>

<p>
この時点で，
%A の横幅と縦幅（いずれも `40px^v ）は［
最初に考慮した当の容器の上端に接合する空間
］内にも`収まるようになる^emが、
%A がそのときの位置へ戻されることはない
— ~layout~engineは、
この位置による結果が妥当でない~layoutになることをすでに知っているので。
◎
At this point, the width and height of the article (40px each) would fit back in the first considered space, flush with the top of the container. However, the box is not returned to the previous position, because the layout engine knows already that this position would result in an invalid layout.
</p>
</div>

<p>
次に挙げるいずれかが満たされる場合、
要素に`行内-~size封込め$を与えても，効果は無い：
◎
Giving an element inline-size containment has no effect if any of the following are true:
</p>
<ul>
	<li>
要素は`首要~box$を生成しない
（要素の `display$p が［
`contents^v ／ `none^v
］をとる事例など）
◎
if the element does not generate a principal box (as is the case with display: contents or display: none)
</li>
	<li>
要素の`内縁~表示~型$は `table$v
◎
if its inner display type is table
</li>
	<li>
要素の`首要~box$は、
次に挙げるいずれかである
⇒＃
`内部~table~box$／
`内部~ruby~box$／
`行内~level$の~boxのうち`不可分な行内$でないもの
◎
if its principal box is an internal table box
◎
if its principal box is an internal ruby box or a non-atomic inline-level box
</li>
</ul>

		</section>
	</section>
	<section id="container-queries">
<h2 title="Container Queries">4. 容器~query</h2>

<p>
`媒体~query$は，
当の文書を表示している~UAや機器~環境を成す側面（表示域~寸法や利用者~選好など）を~queryするための~methodを供するが、
`容器~query$は，
当の文書の中で要素を成す側面（~box寸法や算出された~styleなど）を~testすることを許容する。
◎
While media queries provide a method to query aspects of the user agent or device environment that a document is being displayed in (such as viewport dimensions or user preferences), container queries allow testing aspects of elements within the document (such as box dimensions or computed styles).
</p>

<p>
すべての要素は、
既定では，`容器~style~query$の目的において`~query容器$になる。
さらには、［
`container-type$p ~prop（または `container$p `略式~prop$）を利用して，追加的な~query種別を指定する
］ことにより，`容器~size~query$用の`~query容器$も確立し得る。
`~query容器$の`~shadowも含めた子孫$に適用されている~style規則は、［
当の容器に対し， `container$at `条件付き~group規則$を利用して~queryする
］ことにより，条件付けられ得る。
◎
By default, all elements are query containers for the purpose of container style queries, and can be established as query containers for container size queries by specifying the additional query types using the container-type property (or the container shorthand). Style rules applying to a query container’s shadow-including descendants can be conditioned by querying against it, using the @container conditional group rule.
</p>

<div class="example">
<p>
例えば、
`main^e や `aside^e 用の区画を容器として定義してから，
`.media-object^css を［
自身が属する容器の~sizeに依存して~layoutを縦方向から横方向へ変更する
］ものとして記述できる：
◎
For example, we can define the main content area and sidebar as containers, and then describe a .media-object that changes from vertical to horizontal layout depending on the size of its container:
</p>

<pre class="lang-css">
main, aside {
  container: my-layout / inline-size;
}

.media-object {
  display: grid;
  grid-template: 'img' auto 'content' auto / 100%;
}

@container my-layout (inline-size &gt; 45em) {
  .media-object {
    grid-template: 'img content' auto / auto 1fr;
  }
}
</pre>

<p>
［
`main^e ／ `aside^e
］用の区画~内の各 `.media-object^css は、
各自の自前の容器~文脈に応答することになる。
◎
Media objects in the main and sidebar areas will each respond to their own container context.
</p>
</div>

<p>
疑似要素を伴う選択子~用には、
`~query容器$は，［
その`最終的な出自の要素$の`~shadowも含めた広義-先祖$
］により確立され得る。
◎
For selectors with pseudo elements, query containers can be established by the shadow-including inclusive ancestors of the ultimate originating element.
</p>

<div class="note">
<p>注記：
従って：
◎
It follows that:
</p>
<p class="trans-note">【
以下に現れる`出自の要素$は、
実際には`最終的な出自の要素$を意味することになる。
】</p>
<ul>
	<li>
疑似要素~自体は、
~query容器にはなり得ない。
◎
Pseudo elements themselves can not be query containers
</li>
	<li>
［
`before$pe,
`after$pe,
`marker$pe,
`backdrop$pe
］は、
各自の出自の要素を~queryする。
◎
::before, ::after, ::marker, and ::backdrop query their originating elements
</li>
	<li>
［
`first-letter$pe,
`first-line$pe
］は、
各自の出自の要素を~queryする
— 継承と描画の目的において，
`仮想の~tag列$が `first-line$pe を他の要素を過ぎるよう押出す場合でも。
◎
::first-letter and ::first-line query their originating elements, even if the fictional tag sequence may push the ::first-line past other elements for the purpose of inheritance and rendering
</li>
	<li>
【同じ`疑似-複合~選択子$内に】
疑似要素が複数あっても、
疑似要素は他の疑似要素~用の~query容器になることを許容しない。
例：
`part()$pe 選択子は、
`host::part()::before^css 内の `before^pe 用には，~query容器になり得ない
— `host^e は、そうなり得るが。
類似に，
`before^pe は、
`div::before::marker^css 内の `marker^pe 用の~query容器にはなり得ない。
◎
Multiple pseudo elements do not allow pseudo elements to be query containers for other pseudo elements. E.g., the host, but not the ::part(), can be the query container for ::before in host::part()::before. Similarly, ::before can not be the query container for the ::marker in div::before::marker
</li>
	<li>
`slotted()$pe 選択子は、
~slot自身も含めて，`~shadow~tree$の内側にある容器たちを~queryできる。
◎
::slotted() selectors can query containers inside the shadow tree, including the slot itself
</li>
	<li>
`part()$pe 選択子は、
出自の~host【その出自の要素である`~shadow~host$】を~queryできるが，
【それが~hostしている】`~shadow~tree$の内側にある内部~query容器を~queryできない。
◎
::part() selectors can query its originating host, but not internal query containers inside the shadow tree
</li>
	<li>
［
`placeholder$pe,
`file-selector-button$pe
］は，入力~要素を~queryできるが、
当の入力~要素が`~shadow~tree$を利用して実装された場合，それは内部の容器を公開しない。
◎
::placeholder and ::file-selector-button can query the input element, but do not expose any internal containers if the input element is implemented using a shadow tree
</li>
</ul>
</div>

<div class="example">
<p>
次の `before^pe 選択子は、
出自の要素の~sizeを~queryしている：
◎
A ::before selector querying the size of the originating element:
</p>
<pre class="lang-html">
&lt;style&gt;
  #container {
    width: 100px;
    container-type: inline-size;
  }
  @container (inline-size &lt; 150px) {
    #inner::before {
      content: "BEFORE";
    }
  }
&lt;/style&gt;
&lt;div id=container&gt;
  &lt;span id=inner&gt;&lt;/span&gt;
&lt;/div&gt;
</pre>
</div>

<div class="example">
<p>
`~shadow~host$の【ある~slotにアテガわれることになる】子を~styleするための `slotted()$pe 選択子は、
当の`~shadow~tree$内の容器を~queryできる：
◎
A ::slotted() selector for styling a shadow host child can query a container in the shadow tree:
</p>
<pre class="lang-html">
&lt;div id=host style="width:200px"&gt;
  &lt;template `shadowrootmode＠~HEscripting#attr-template-shadowrootmode$【！shadowroot】=open&gt;
    &lt;style&gt;
      #container {
        width: 100px;
        container-type: inline-size;
      }
      @container (inline-size &lt; 150px) {
        ::slotted(span) {
          color: green;
        }
      }
    &lt;/style&gt;
    &lt;div id=container&gt;
      &lt;slot&gt;&lt;/slot&gt;【！&lt;slot /&gt;】
    &lt;/div&gt;
  &lt;/template&gt;
  &lt;span id=slotted&gt;Green&lt;/span&gt;
&lt;/div&gt;
</pre>
</div>

		<section id="container-type">
<h3 title="Creating Query Containers: the container-type property">4.1. ~query容器の作成-法： `container-type^p ~prop</h3>

◎名 `container-type@p
◎値 `normal^v | `size^v | `inline-size^v
◎初 `normal^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア ~animate不可
◎表終

<p>
`container-type$p ~propは、
明示的な封込めを要求する`容器~query$（`容器~size~query$など）の目的において，
要素を
`~query容器@
として確立する
— それは、［
要素の子孫を~styleしている`~style規則$
］が［
要素の~sizingと~layoutを成す様々な側面
］を~queryして［
その結果に則って応答する
］ことを許容する。
◎
The container-type property establishes the element as a query container for the purpose of container queries that require explicit containment (such as container size queries), allowing style rules styling its descendants to query various aspects of its sizing and layout, and respond accordingly.
</p>

<p>
他が注記されない限り、
すべての要素は，明示的な`封込め$を要求しない`容器~query$
— `容器~style~query$など —
の目的においては`~query容器$になる
— `container-type$p に何が指定されようが。
◎
Unless otherwise noted, all elements are query containers for the purpose of container queries that do not require explicit containment (such as container style queries), regardless of the specified container-type.
</p>

<p>
各種~値の意味は：
◎
Values have the following meanings:
</p>
<dl class="valdef">
	<dt>`size@v</dt>
	<dd>
`容器~size~query$用に`~query容器$を確立する
— ［
`行内-軸$, `塊-軸$
］どちらに対しても。
`首要~box$に［
`~layout封込め$,
`~style封込め$,
`~size封込め$
］を適用する。
◎
Establishes a query container for container size queries on both the inline and block axis. Applies layout containment, style containment, and size containment to the principal box.
</dd>

	<dt>`inline-size@v</dt>
	<dd>
当の容器の自前の`行内-軸$に対し，`容器~size~query$用に`~query容器$を確立する。
要素の`首要~box$に［
`~layout封込め$,
`~style封込め$,
`行内-~size封込め$
］を適用する。
◎
Establishes a query container for container size queries on the container’s own inline axis. Applies layout containment, style containment, and inline-size containment to the principal box.
</dd>

	<dt>`normal@v</dt>
	<dd>
要素は、
`容器~size~query$用の`~query容器$にはならないが，
`容器~style~query$用の`~query容器$であり続ける。
◎
The element is not a query container for any container size queries, but remains a query container for container style queries.
</dd>
</dl>

<div class="example">
<p>
例えば，作者は、
容器に応答-可能な~typographyを作成できる
— 容器の~sizeに基づいて，［
`font-size$p や `line-height$p その他の~typographic~style
］を調整するような：
◎
For example, authors can create container-responsive typography, adjusting font-size, line-height, and other typographic concerns based on the size of a container:
</p>
<pre class="lang-css">
aside, main {
  container-type: inline-size;
}

h2 { font-size: 1.2em; }

@container (width &gt; 40em) {
  h2 { font-size: 1.5em; }
}
</pre>

<p>
~query条件~内で利用される値 `40em^v は、
関連な`~query容器$の `font-size$p の`算出d値$に相対的になる。
◎
The 40em value used in the query condition is relative to the computed value of font-size on the relevant query container.
</p>
</div>

<div class="example">
<p>
容器は、
~queryされる~styleの算出d値も公開できる。
これは、
複数の~propに わたって挙動を~toggleするときに有用になり得る：
◎
Containers can also expose computed style values for querying. This can be useful for toggling behavior across multiple properties:
</p>

<pre class="lang-css">
section {
  container-type: style;
}

@container style(--cards: small) {
  article {
    border: thin solid silver;
    border-radius: 0.5em;
    padding: 1em;
  }
}
</pre>
</div>

		</section>
		<section id="container-name">
<h3 title="Naming Query Containers: the container-name property">4.2. ~query容器の命名-法： `container-name^p ~prop</h3>

◎名 `container-name@p
◎値 `none^v | `custom-ident$t+
◎初 `none^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 ~keyword `none$v ／ `~CSS識別子$たちが成す有順序~list
◎順 文法に従う
◎ア ~animate不可
◎表終

<p>
`container-name$p ~propは、
`~query容器~名@
たちが成す~listを指定する。
これらの名前は、
`container$at 規則により，
どの`~query容器$を~targetにするか~filterするために利用できる。
◎
The container-name property specifies a list of query container names. These names can be used by @container rules to filter which query containers are targeted.
</p>

<dl class="valdef">
	<dt>`none@v</dt>
	<dd>
`~query容器$には`~query容器~名$は無い。
◎
The query container has no query container name.
</dd>

	<dt id="valdef-container-name-custom-ident">`custom-ident$t</dt>
	<dd>
`~query容器~名$を`~CSS識別子$として指定する。
この `custom-ident$t からは、
~keyword［
`none$v, `and^v, `not$v, `or^v
］は除外される。
◎
Specifies a query container name as an identifier. The keywords none, and, not, and or are excluded from this &lt;custom-ident&gt;.
</dd>
</dl>

<div class="example">
<p>
一部の事例では、
特定の容器を成す側面を~queryすることが求まれる
— それが【この例では `.card^css の】最も近い先祖~容器でない場合でも。
例えば、［
`main^e 内容~区画の塊~size／
より入子にされた `.my-component^css の行内~size
］を~queryするよう求まれるかもしれない。
◎
In some cases, we want to query aspects of a specific container, even if it’s not the nearest ancestor container. For example, we might want to query the height of a main content area, and the width of a more nested inline-container.
</p>
<pre class="lang-css">
main {
  container-type: size;
  container-name: my-page-layout;
}

.my-component {
  container-type: inline-size;
  container-name: my-component-library;
}

@container my-page-layout (block-size &gt; 12em) {
  .card { margin-block: 2em; }
}

@container my-component-library (inline-size &gt; 30em) {
  .card { margin-inline: 2em; }
}
</pre>
</div>

		</section>
		<section id="container-shorthand">
<h3 title="Creating Named Containers: the container shorthand">4.3. 有名~容器の作成-法： `container^p 略式~prop</h3>

◎名 `container@p
◎値 `container-name$tp [ / `container-type$tp ]?
◎初 個々の~propを見よ
◎適 個々の~propを見よ
◎継 個々の~propを見よ
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎ア 個々の~propを見よ
◎順 文法に従う
◎表終

<p>
`container$p `略式~prop$は、
同じ宣言で［
`container-type$p, `container-name$p
］両者を設定する。
`container-type$tp が省略された場合、
`container-type$p は，その`初期~値$に設定し直される。
◎
The container shorthand property sets both container-type and container-name in the same declaration. If &lt;'container-type'&gt; is omitted, it is reset to its initial value.
</p>

<div class="example">
<p>
略式~構文を利用して，［
`container-type$p, `container-name$p
］両者を定義できる：
◎
We can define both a container-type and container-name using the shorthand syntax:
</p>
<pre class="lang-css">
main {
  container: my-layout / size;
}

.grid-item {
  container: my-component / inline-size;
}
</pre>
</div>

		</section>
		<section id="container-rule">
<h3 title="Container Queries: the @container rule">4.4. 容器~query： `container^at 規則</h3>

<p>
`container@at
規則は，`条件付き~group規則$であり、
その条件【 `container-condition$t 】は，
`容器~query@
【 `container-query$t 】を包含する。
それは、［
個々の［
`容器~size~query$／`容器~style~query$
］による真偽-条件
］たちが成す組合nである。
`container$at 規則の `block-contents$t ~blockの中の~style宣言たちは、
規則の条件により，［
所与の要素~用の`~query容器$に対し`容器~query$が `真^i に評価されるときに限り，
要素に適用される【！match】
］よう`~filterされる＠~CASCADE#filtering$。
◎
The @container rule is a conditional group rule whose condition contains a container query, which is a boolean combination of container size queries and/or container style queries. Style declarations within the &lt;block-contents&gt; block of an @container rule are filtered by its condition to only match when the container query is true for their element’s query container.
</p>

<p>
`container$at 規則の構文は：
◎
The syntax of the @container rule is:
</p>

<pre class="prod">
@container `container-condition$t {
  `block-contents$t
}
</pre>

<p>
ここで：
◎
where:
</p>

<pre class="prod">
`container-condition@t
	= [ `container-name$t ]? `container-query$t
`container-name@t
	= `custom-ident$t
`container-query@t
	= not `query-in-parens$t
	| `query-in-parens$t
		[ [ and `query-in-parens$t ]*
		| [ or `query-in-parens$t ]* ]
`query-in-parens@t
	= ( `container-query$t )
	| ( `size-feature$t )
	| style( `style-query$t )
	| `general-enclosed$t
`style-query@t
	= not `style-in-parens$t
	| `style-in-parens$t
		[ [ and `style-in-parens$t ]*
		| [ or `style-in-parens$t ]* ]
	| `style-feature$t
`style-in-parens@t
	= ( `style-query$t )
	| ( `style-feature$t )
	| `general-enclosed$t
</pre>

<p>
~keyword［
`none$v, `and^v, `not$v, `or^v
］は、
上の `custom-ident$t からは除外される。
◎
The keywords none, and, not, and or are excluded from the &lt;custom-ident&gt; above.
</p>

<p>
各~要素に対し、
~queryされることになる`~query容器$は，
当の要素の先祖である`~query容器$のうち［
`container-query$t 内のすべての`容器~特能$に対し妥当な`~query容器$として確立されたもの
］から選定される。
`container-query$t が［
未知な／~supportされない
］`容器~特能$を包含する場合、
選定される`~query容器$は無い。
省略可能な `container-name$t は、
`~query容器$たちが成す集合を［
合致している`~query容器~名$を伴うもの
］だけが考慮されるよう~filterする。
◎
For each element, the query container to be queried is selected from among the element’s ancestor query containers that are established as a valid query container for all the container features in the &lt;container-query&gt;. If the &lt;container-query&gt; contains unknown or unsupported container features, no query container will be selected. The optional &lt;container-name&gt; filters the set of query containers considered to just those with a matching query container name.
</p>

<p>
要素~用に適格な`~query容器$が選定されたなら、
`container-query$t 内の各`容器~特能$は，
その`~query容器$に対し評価される。
どの先祖も適格な`~query容器$でない場合、
当の要素に対しては，`容器~query$の結果は `未知^i になる。
媒体~queryと同じく、
`general-enclosed$t は `未知^i に評価される。
◎
Once an eligible query container has been selected for an element, each container feature in the &lt;container-query&gt; is evaluated against that query container. If no ancestor is an eligible query container, then the container query is unknown for that element. As for media queries, &lt;general-enclosed&gt; evaluates to unknown.
</p>

<div class="example">
<p>
`媒体~query$と同じく、
複数の条件を単独の~query~list内に一緒につなげれる：
◎
As with media queries, we can string together multiple conditions in a single query list:
</p>
<pre class="lang-css">
@container card (inline-size &gt; 30em) and style(--responsive: true) {
  /* <span class="comment">
~style群
◎
styles
</span> */
}
</pre>

<p>
上の~style群は、
次を満たす先祖~容器が在る場合に限り，適用されることになる
⇒
［
【`container-name$p により】 "`card^v" と命名された
］~AND［
`inline-size$d 条件を満たす
］~AND［
`style()＠#container-style-query$css 条件を満たす
］
◎
The styles above will only be applied if there is an ancestor container named "card" that meets both the inline-size and style conditions.
</p>
</div>

<p>
複数に【複数の `container^at を通して】入子にされた`容器~query$の内側に在る［
ある要素に定義された~style規則
］は、［
それを包装しているすべての【 `container^at の】`容器~query$
］が［
当の要素【用の`~query容器$】に対し `真^i に評価される
］とき適用される。
◎
Style rules defined on an element inside multiple nested container queries apply when all of the wrapping container queries are true for that element.
</p>

<p class="note">注記：
入子な`容器~query$は，［
その親とは異なる容器との関係
］において評価されることもあるので、
複数の `container-condition$t を単独の~queryに併合することは，常にアリになるとは限らない。
◎
Note: Nested container queries can evaluate in relation to different containers, so it is not always possible to merge the individual &lt;container-condition&gt;s into a single query.
</p>

<div class="example">
<p>
複数の容器に対し~queryすることは、
単独の`容器~query$ではアリでないが，
複数の~queryを入子にすることにより達成できる：
◎
While it is not possible to query multiple containers in a single container query, that can be achieved by nesting multiple queries:
</p>
<pre class="lang-css">
@container card (inline-size &gt; 30em) {
  @container style(--responsive: true) {
    /* <span class="comment">
~style群
◎
styles
</span> */
  }
}
</pre>

<div>
<p>
上の~style群は、
~AND↓ が満たされる場合に限り，適用されることになる：
</p>
<ul>
	<li>
次を満たす先祖~容器が在る
⇒
［
【`container-name$p により】 "`card^v" と命名された
］~AND［
`inline-size$d 条件を満たす
］
</li>
	<li>
`style()＠#container-style-query$css 条件を満たす先祖~容器が在る
</li>
</ul>
◎
The styles above will only be applied if there is an ancestor container named "card" that meets the inline-size condition, as well as an ancestor container meeting style condition.
</div>
</div>

<p>
大域的な名前を定義している`~at-規則$
— `keyframes$at／ `font-face$at ／ `layer$at など —
は、
`容器~query$の内側で定義された場合でも，当の~query条件により拘束されない。
◎
Global, name-defining at-rules such as @keyframes or @font-face or @layer that are defined inside container queries are not constrained by the container query conditions.
</p>

		</section>
		<section id="animated-containers">
<h3 title="Animated Containers">4.5. ~animateされる容器</h3>

<p>
`容器~query$の評価における変化は、
`~style変化~event$の一部を成すモノトスル
— 当の変化が`~animation効果により生じた＠~WANIM#effect-value$ときでも。
◎
A change in the evaluation of a container query must be part of a style change event, even when the change occurred because of animation effects.
</p>

<div class="example">
<p>
容器
【この例では `#container^css 】
の同胞である要素
【この例では `#sibling^css 】
に対する遷移は、
当の容器の~sizeに間接的に影響し得る
— その結果，容器~queryの評価が変化すると、
【容器~内の要素（この例では `#inner^css ）に対し】
`~style変化~event$を誘発する：
◎
A transition on a sibling element can indirectly affect the size of a container, triggering style change events whenever container queries change their evaluation as a result:
</p>

<pre class="lang-html">
&lt;main&gt;
  &lt;div id=container&gt;
    &lt;div id=inner&gt;Inner&lt;/div&gt;
  &lt;/div&gt;
  &lt;div id=sibling&gt;Sibling&lt;/div&gt;
&lt;/main&gt;
</pre>

<pre class="lang-css">
main {
  display: flex;
  width: 300px;
}

#container {
  container-type: inline-size;
  flex: 1;
}

/* <span class="comment">
`width^p の解決d値は初期~時は 200px になるが、
`#sibling^css に対する遷移が進捗するに伴い変化する。
◎
Resolved width is initially 200px, but changes as the transition on #sibling progresses.
</span> */
#inner {
  transition: 1s background-color;
  background-color: tomato;
}

/* <span class="comment">
この容器~queryの評価が変化したときは、
`#inner^css の `background-color^p に対する遷移を開始させる【！must】。
◎
When this container query starts (or stops) applying, a transition must start on background-color on #inner.
</span> */
@container (width &lt;= 150px) {
  #inner {
    background-color: skyblue;
  }
}

#sibling {
  width: 100px;
  transition: width 1s;
}

#sibling:hover {
  width: 200px;
}
</pre>

<div>
◎
&lt;main&gt;
  &lt;div id=container&gt;
    &lt;div id=inner&gt;Inner&lt;/div&gt;
  &lt;/div&gt;
  &lt;div id=sibling&gt;Sibling&lt;/div&gt;
&lt;/main&gt;
</div>
</div>

<p>
`容器~query長さ単位$に~~起因する`算出d値$における変化も，
`~style変化~event$の一部を成すモノトスル。
◎
Changes in computed values caused by container query length units must also be part of a style change event.
</p>

		</section>
	</section>
	<section id="container-features">
<h2 title="Container Features">5. 容器~特能</h2>

<p>
`容器~特能@
は、
`~query容器$を成す特有な側面を~queryする。
◎
A container feature queries a specific aspect of a query container.
</p>

		<section id="size-container">
<h3 title="Size Container Features">5.1. ~size容器~特能</h3>

<p>
`容器~size~query@
は、
`~query容器$の`首要~box$の~sizeを~queryすることを許容する。
それは、［
個々の`~size特能$による真偽-条件
］たちが成す組合nである。
個々の
`~size特能@
（ `size-feature$t ）は、
当の`~query容器$を成す単独の［
特定の［
寸法に関する特能
］］を~queryする。
`size-feature@t
の構文は、
`媒体~特能$ `mediaqueries-5$r 用のそれと同じであり，［
特能~名, 比較子, 値
］からなる。
各`~size特能$を`容器~size~query$に組合せる真偽-［
構文, 論理
］は、
`~CSS特能~query$用のそれと同じである。
（ `supports$at を見よ。 `CSS-CONDITIONAL-3$r ）
◎
A container size query allows querying the size of the query container’s principal box. It is a boolean combination of individual size features (&lt;size-feature&gt;) that each query a single, specific dimensional feature of the query container. The syntax of a &lt;size-feature&gt; is the same as for a media feature: a feature name, a comparator, and a value. [mediaqueries-5] The boolean syntax and logic combining size features into a size query is the same as for CSS feature queries. (See @supports. [CSS-CONDITIONAL-3])
</p>

<div>
<p>
所与の`~query容器$ %容器 用に`~size特能$ %特能 を評価した結果は、
%容器 が ~AND↓ を満たさない場合には， `未知^i になる：
</p>
<ul>
	<li>
%容器 の`首要~box$は、
`~layout封込め~box$である
</li>
	<li>
%容器 は、
%特能 【！`容器~size~query$】に関連な軸において %特能 【が~queryする寸法】を~supportする
</li>
</ul>
◎
If the query container does not have a principal box, or the principal box is not a layout containment box, or the query container does not support container size queries on the relevant axes, then the result of evaluating the size feature is unknown.
</div>

<p>
`容器~query$を成す各~条件~内の［
`相対~長さ単位$（`容器~query長さ単位$を含む）／
`~custom~prop$【を参照する `var$f 】
］は、
当の`~query容器$における［
当の単位を伴う値／当の~prop
］の`算出d値$に基づいて評価される。
◎
Relative length units (including container query length units) and custom properties in container query conditions are evaluated based on the the computed values of the query container.
</p>

<p class="note">注記：
これは、
`媒体~query$内の相対~単位に対する取扱いとは異なる。
◎
Note: This is different from the handling of relative units in media queries.
</p>

<p class="note">注記：
`~custom~prop$による代用の結果が当の`~size特能$用には妥当でない値になる場合、
他の妥当でない特能~値と同じに取扱われ，当の~size特能を評価した結果は `未知^i になる。
◎
Note: If custom property substitution results in an invalid value for the size feature, it is handled the same as other invalid feature values, and the result of the size feature is unknown.
</p>

<p class="trans-note">【
この代用は、
~propの値の中で利用された `var^f に対する`代用＠~CSSVAR#substitute-a-var$と同様に解決される。
】</p>

<div class="example">
<p>
例えば， `font-size^p が互いに異なる`~query容器$たちは、
`em$u 単位に基づく~queryを各自の自前の `font-size^p に相対的に評価することになる：
◎
For example, query containers with different font-sizes will evaluate em-based queries relative to their own font sizes:
</p>

<pre class="lang-css">
aside, main {
  container-type: inline-size;
}

aside { font-size: 16px; }
main { font-size: 24px; }

@container (width &gt; 40em) {
  h2 { font-size: 1.5em; }
}
</pre>

<p>
この~query条件~内で利用された値 `40em^v は、
関連な`~query容器$の `font-size$p の`算出d値$に相対的になる
— この~query条件は：
◎
The 40em value used in the query condition is relative to the computed value of font-size on the relevant query container:
</p>
<ul>
	<li>
`aside^e の内側にある `h2^e 用には、
容器の `width$d が `640px^v を上回るとき `真^i になる。
◎
For any h2 inside aside, the query condition will be true above 640px.
</li>
	<li>
`main^e の内側にある `h2^e 用には、
容器の `width$d が `960px^v を上回るとき `真^i になる。
◎
For any h2 inside main, the query condition will be true above 960px.
</li>
</ul>
</div>

<div class="example">
<p>
類似に，`~query容器$は、
`var$f に基づく~queryを自前の`~custom~prop$の`算出d値$に相対的に評価することになる：
◎
Similarly, query containers will evaluate var()-based queries relative to their own computed value of the custom property:
</p>

<pre class="lang-css">
aside, main {
  container-type: inline-size;
}

aside { --query: 300px; }
main { --query: 500px; }

@container (width &gt; var(--query)) {
  h2 { font-size: 1.5em; }
}
</pre>

<p>
この~query条件に利用された `var(--query)^v は、
関連な`~query容器$の `--query^p `~custom~prop$の`算出d値$で代用される
— この~query条件は：
◎
The var(--query) value used in the query condition is substituted with the computed value of the --query custom property on the relevant query container:
</p>

<ul>
	<li>
`aside^e の内側にある `h2^e 用には、
算出d値が `300px^v を上回るとき `真^i になる。
◎
For any h2 inside aside, the query condition will be true above 300px.
</li>
	<li>
`main^e の内側にある `h2^e 用には、
算出d値が `500px^v を上回るとき `真^i になる。
◎
For any h2 inside main, the query condition will be true above 500px.
</li>
</ul>
</div>

			<section id="width">
<h4 title="Width: the width feature">5.1.1. 横幅： `width^d 特能</h4>

◎述 `width@d
◎用 `container$at
◎値 `length$t
◎型 範囲
◎表終

<p>
`容器~特能$ `width$d は、
`~query容器$の`内容~box$の`横幅$を~queryする。
◎
The width container feature queries the width of the query container’s content box.
</p>

			</section>
			<section id="height">
<h4 title="Height: the height feature">5.1.2. 縦幅： `height^d 特能</h4>

◎述 `height@d
◎用 `container$at
◎値 `length$t
◎型 範囲
◎表終

<p>
`容器~特能$ `height$d は、
`~query容器$の`内容~box$の`縦幅$を~queryする。
◎
The height container feature queries the height of the query container’s content box.
</p>

			</section>
			<section id="inline-size">
<h4 title="Inline-size: the inline-size feature">5.1.3. 行内-~size： `inline-size^d 特能</h4>

◎述 `inline-size@d
◎用 `container$at
◎値 `length$t
◎型 範囲
◎表終

<p>
`容器~特能$ `inline-size$d は、［
`~query容器$の`行内-軸$における，
`~query容器$の`内容~box$の`~size$
］を~queryする。
◎
The inline-size container feature queries the size of the query container’s content box in the query container’s inline axis.
</p>

			</section>
			<section id="block-size">
<h4 title="Block-size: the block-size feature">5.1.4. 塊~size： `block-size^d 特能</h4>

◎述 `block-size@d
◎用 `container$at
◎値 `length$t
◎型 範囲
◎表終

<p>
`容器~特能$ `block-size$d は、［
`~query容器$の`塊-軸$における，`~query容器$の`内容~box$の`~size$
］を~queryする。
◎
The block-size container feature queries the size of the query container’s content box in the query container’s block axis.
</p>

			</section>
			<section id="aspect-ratio">
<h4 title="Aspect-ratio: the aspect-ratio feature">5.1.5. 縦横比： `aspect-ratio^d 特能</h4>

◎述 `aspect-ratio@d
◎用 `container$at
◎値 `ratio$t
◎型 範囲
◎表終

<p>
`容器~特能$ `aspect-ratio$d は、［
`容器~特能$ `width$d の値
］が成す［
`容器~特能$ `height$d の値
］に対する比率†を~queryする【！is defined as】。
◎
The aspect-ratio container feature is defined as the ratio of the value of the width container feature to the value of the height container feature.
</p>

<p class="trans-note">【†
`範囲~文脈$においては、
~CSSの`比率$と同様に，前者を後者で除算した結果に基づいて比較されよう。
】</p>

			</section>
			<section id="orientation">
<h4 title="Orientation: the orientation feature">5.1.6. 方位： `orientation^d 特能</h4>

◎述 `orientation@d
◎用 `container$at
◎値 `portrait^v | `landscape^v
◎型 離散的
◎表終

<p>
`容器~特能$ `orientation$d は、［
次が満たされるならば
`portrait@v
／
~ELSE_
`landscape@v
］になる
⇒
`容器~特能$ `height$d の値 ~GTE `容器~特能$ `width$d の値
◎
portrait
• The orientation container feature is portrait when the value of the height container feature is greater than or equal to the value of the width container feature.
◎
landscape
• Otherwise orientation is landscape.
</p>

			</section>
		</section>
		<section id="style-container">
<h3 title="Style Container Features">5.2. ~style容器~特能</h3>

<p>
`容器~style~query@
は、
`~query容器$の`算出d値$を~queryすることを許容する。
それは、［
個々の`~style特能$による真偽-条件
］たちが成す組合nである。
各
`~style特能@
（ `style-feature$t ）は、
`~query容器$の単独の特定の~propを~queryする。
`style-feature@t
の構文は、
次に挙げるいずれかと同じになる
⇒＃
妥当な`宣言$ `CSS-SYNTAX-3$r 用のそれ／
`~supportされる~CSS~prop$／
`custom-property-name$t
◎
A container style query allows querying the computed values of the query container. It is a boolean combination of individual style features (&lt;style-feature&gt;) that each query a single, specific property of the query container. The syntax of a &lt;style-feature&gt; is either the same as for a valid declaration [CSS-SYNTAX-3], a supported CSS property, or a &lt;custom-property-name&gt;.
</p>

<p>
各`~style特能$による【！Its】~queryは、［
次が満たされるならば `真^i ／
~ELSE_ `偽^i
］に評価される
⇒
`~query容器$の［
所与の~prop
］の`算出d値$
（それも，`~query容器$を~~基準に`算出-$される）
は、
所与の値に合致する
◎
Its query evaluates to true if the computed value of the given property on the query container matches the given value (which is also computed with respect to the query container), and false otherwise.
</p>

<p>
値を伴わない`~style特能$は、［
次が満たされるならば `真^i 【／~ELSE_ `偽^i】
］に評価される
⇒
所与の`~prop$用の`算出d値$は，それ用の`初期~値^とは異なる
◎
A style feature without a value evaluates to true if the computed value is different from the initial value for the given property.
</p>

<p>
`容器~style~query$の中で組合された`~style特能$たちに対する真偽-［
構文, 論理
］は、
`~CSS特能~query$用のそれと同じである。 
（ `supports$at を見よ。 `CSS-CONDITIONAL-3$r ）
◎
The boolean syntax and logic combining style features into a style query is the same as for CSS feature queries. (See @supports. [CSS-CONDITIONAL-3])
</p>

<p>
`略式~prop$を~queryする`~style特能$は、［
次が満たされるならば `真^i ／
~ELSE_ `偽^i
］に評価される
⇒
各`下位prop$に対し，その`算出d値$は
【所与の値から導出される各~下位prop用の算出d値に】
合致する
◎
Style features that query a shorthand property are true if the computed values match for each of its longhand properties, and false otherwise.
</p>

<p>
`~cascadeに依存する~keyword$
— `revert$v, `revert-layer$v など —
は、
`~style特能$内の値としては妥当でなく，
`容器~style~query$は `偽^i になる。
◎
Cascade-dependent keywords, such as revert and revert-layer, are invalid as values in a style feature, and cause the container style query to be false.
</p>

<p class="note">注記：
上に挙げたものでない，`~cascadeに依存する~keyword$ではない`~CSS全域~keyword$は、
他の値と同じく，当の`~query容器$を~~基準に`算出d値$される。
◎
Note: The remaining non-cascade-dependent CSS-wide keywords are computed with respect to the query container, the same as other values.
</p>

		</section>
	</section>
	<section id="container-lengths">
<h2 title="Container Relative Lengths: the cqw, cqh, cqi, cqb, cqmin, cqmax units">6. 容器に相対的な長さ単位： `cqw^u, `cqh^u, `cqi^u, `cqb^u, `cqmin^u, `cqmax^u</h2>

<p>
`容器~query長さ単位@
は、
`~query容器$の寸法に相対的な長さを指定する。
~stylesheetにて`容器~query長さ単位$を利用すれば、
~componentを ある`~query容器$から別のそれへ移動するのも容易になる。
◎
Container query length units specify a length relative to the dimensions of a query container. Style sheets that use container query length units can more easily move components from one query container to another.
</p>

<p>
`容器~query長さ単位$は：
◎
The container query length units are:
</p>

<div>
<table class="data">
<caption>
容器~単位たちの規範的でない要約
</caption>
<thead>
<tr><th>単位
<th>何に相対的か
</thead><tbody>

<tr><td>`cqw^u
<td>`~query容器$の`横幅$の 1%

<tr><td>`cqh^u
<td>`~query容器$の`縦幅$の 1%

<tr><td>`cqi^u
<td>`~query容器$の`行内~size$の 1%

<tr><td>`cqb^u
<td>`~query容器$の`塊~size$の 1%

<tr><td>`cqmin^u
<td>`cqi^u, `cqb^u のうち小さい方の値

<tr><td>`cqmax^u
<td>`cqi^u, `cqb^u のうち大きい方の値
</tbody></table>
◎
Informative Summary of Container Units unit 	relative to
cqw 	1% of a query container’s width
cqh 	1% of a query container’s height
cqi 	1% of a query container’s inline size
cqb 	1% of a query container’s block size
cqmin 	The smaller value of cqi or cqb
cqmax 	The larger value of cqi or cqb
</div>

<p>
各~要素に対し，
`容器~query長さ単位$は、
当の単位に関連な軸（たち）に対する`容器~size~query$として評価される。
各~軸に対し、
`~query容器$は，
当の軸において当の`容器~size~query$を受容する先祖~容器のうち最も近いものになる。
適格な`~query容器$として可用なものは無い場合、
当の軸~用には`小さい表示域~size$を利用する。
◎
For each element, container query length units are evaluated as container size queries on the relevant axis (or axes) described by the unit. The query container for each axis is the nearest ancestor container that accepts container size queries on that axis. If no eligible query container is available, then use the small viewport size for that axis.
</p>

<p class="note">注記：
事例によっては、
同じ要素~上の［
`cqi^u 単位, `cqb^u 単位
］は，異なる関係にある`~query容器$に対し評価されることになる。
類似に，［
`cqmin^u 単位／ `cqmax^u 単位
］は、［
`cqi^u, `cqb^u
］単位が異なる`~query容器$から来ているときでも，それらの寸法のうち［
小さい方／大きい方
］を表現する。
◎
Note: In some cases cqi and cqb units on the same element will evaluate in relation to different query containers. Similarly, cqmin and cqmax units represent the larger or smaller of the cqi and cqb units, even when those dimensions come from different query containers.
</p>

<p>
子~要素が継承するのは、
その親に指定されたとおりの相対的な値ではなく，`算出d値$である。
◎
Child elements do not inherit the relative values as specified for their parent; they inherit the computed values.
</p>

<div class="example">
<p>
作者は、
`容器~query長さ単位$に対し適切な`~query容器$が有ることを確保できる
— それを［
同じ `container-type$p に依拠する`容器~query$
］の内側で適用することにより。
~customな~fallback値は、
`容器~query$の外側で定義できる：
◎
Authors can ensure that container query length units have an appropriate query container by applying them inside a container query that relies on the same container-type. Custom fallback values can be defined outside the container query:
</p>
<pre class="lang-css">
/* <span class="comment">
~fallback値は、
封込めには依拠しない
◎
The fallback value does not rely on containment
</span> */
h2 { font-size: 1.2em; }

@container (inline-size &gt;= 0px) {
  /* <span class="comment">
`inline-size$d 容器が可用なときに限り適用する
◎
only applies when an inline-size container is available
</span> */
  h2 { font-size: calc(1.2em + 1cqi); }
}
</pre>
</div>

	</section>
	<section id="apis">
<h2 title="APIs">7. ~API</h2>

		<section id="the-csscontainerrule-interface">
<h3 title="The CSSContainerRule interface">7.1. `CSSContainerRule^I ~interface</h3>

<p>
`CSSContainerRule$I ~interfaceは、
ある `container$at 規則を表現する。
◎
The CSSContainerRule interface represents a @container rule.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSContainerRule@I : `CSSConditionRule$I {
    readonly attribute `CSSOMString$ `containerName$m;
    readonly attribute `CSSOMString$ `containerQuery$m;
};
</pre>

<div class="algo">
<p>
`CSSContainerRule$I に特有な［
`CSSConditionRule^I の `conditionText$m 取得子~手続き
］は、次に従うものと定義される：
</p>
<ol>
	<li>
%名前 ~LET コレの `containerName$m 属性の値
</li>
	<li>
%~query ~LET コレの `containerQuery$m 属性の値
</li>
	<li>
~IF［
%名前 ~EQ 空~文字列
］
⇒
~RET %~query
</li>
	<li>
~RET « %名前, %~query » を~spaceで`連結する$
</li>
</ol>
◎
conditionText of type CSSOMString (CSSContainerRule-specific definition for attribute on CSSConditionRule)
• The conditionText attribute (defined on the CSSConditionRule parent rule), on getting, must return a value as follows:
•• The @container rule has an associated &lt;container-name&gt;
•••  The result of getting the containerName and containerQuery attributes, joined by a single whitespace.
•• Otherwise
••• The result of getting the containerQuery attribute.
</div>

<div class="algo">
`containerName@m
取得子~手続き
⇒
~RET ［
コレが表現する `container$at 規則に `container-name$t は指定されたならば それを直列化した結果 ／
~ELSE_ 空~文字列
］
◎
containerName of type CSSOMString
• The containerName attribute, on getting, must return a value as follows:
• The @container rule has an associated &lt;container-name&gt;
•• The result of serializing that &lt;container-name&gt;.
• Otherwise
•• An empty string.
</div>

<div class="algo">
`containerQuery@m
取得子~手続きは
⇒
~RET コレが表現する `container$at 規則に指定された `container-query$t
— この結果は、［
この仕様の適合t実装
（［
この仕様~内の `general-enclosed$t 拡張能の仕組みにより許容される将来の拡張
］を実装する実装も含む）
において，指定された~queryと同じ結果に評価される
］よう，論理的な単純~化を伴わないとする
— 言い換えれば、
~token~streamの単純~化は許容されるが
（空白~列は［
省略可能であることが既知な事例では省略する／
他の場合は 1 個の~spaceに~~縮約する
］），
論理的な単純~化
（不要な括弧の除去, 評価-時の結果に基づく単純~化など）は、
許容されない。
◎
containerQuery of type CSSOMString
• The containerQuery attribute, on getting, must return the &lt;container-query&gt; that was specified, without any logical simplifications, so that the returned query will evaluate to the same result as the specified query in any conformant implementation of this specification (including implementations that implement future extensions allowed by the &lt;general-enclosed&gt; extensibility mechanism in this specification). In other words, token stream simplifications are allowed (such as reducing whitespace to a single space or omitting it in cases where it is known to be optional), but logical simplifications (such as removal of unneeded parentheses, or simplification based on evaluating results) are not allowed.
</div>

<p class="issue">
容器~queryは、
`matchContainer()^m ~methodを有するべきである。
これは、［
`matchMedia()$m, `MediaQueryList$I ~interface
］上で~model化されることになるが、
`Window^I ではなく `Element^I に適用される。
それは、
~layout~sizeを測定するときは `ResizeObserver＠~CSSWG/resize-observer-1/#resizeobserver$I と類似に挙動するが，追加的な容器~query構文と特能を供する。
`6205$issue
◎
Container Queries should have a matchContainer method. This will be modeled on matchMedia() and the MediaQueryList interface, but applied to Elements rather than the Window. When measuring layout sizes, it behaves Similar to resizeObserver, but it provides the additional Container Query syntax and features. [Issue #6205]
</p>

		</section>
	</section>
	<section id="content-visibility">
<h2 title="Suppressing An Element’s Contents Entirely: the content-visibility property">8. 要素~内容のまるごと抑止-法： `content-visibility^p ~prop</h2>

◎名 `content-visibility@p
◎値 `visible^v | `auto^v | `hidden^v
◎初 `visible^v
◎適 `~size封込め$を適用できる要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア <a href="#content-visibility-animation">§ `content-visibility^p の~animate法と補間-法</a> を見よ
◎表終

<p class="issue">
`~level 2$ の `§ 要素~内容のまるごと抑止-法＠~CSSCONTAIN#content-visibility$
をここに併合する。
◎
CSS Containment 2 § 4 Suppressing An Element’s Contents Entirely: the content-visibility property
</p>

		<section id="content-visibility-animation">
<h3 title="Animating and Interpolating content-visibility">8.1. `content-visibility^p の~animate法と補間-法</h3>

<p>
`content-visibility$p ~propの`~animation型$は、
一般には`離散的$になる。
しかしながら，
`visibility$p の補間と類似に
（ `WEB-ANIMATIONS-1$r 
<a href="~WANIM#animating-visibility">§ `visibility^p の~animation</a>
を見よ）、
値 `hidden$v と他の `content-visibility^p 用の値の補間においては，［
0 ~LT %p ~LT 1
］を満たす %p 値は `hidden$v でない方の値に対応付けられる。
◎
In general, the content-visibility property’s animation type is discrete. However, similar to interpolation of visibility (see Web Animations § Animation of visibility), during interpolation between hidden and any other content-visibility value, p values between 0 and 1 map to the non-hidden value.
</p>

		</section>
	</section>
	<section id="privacy">
<h2 title="Privacy Considerations">9. ~privacyの考慮点</h2>

<p class="issue">
`~level 2$ の `§ ~privacyの考慮点＠~CSSCONTAIN#privacy$
をここに併合する。
◎
CSS Containment 2 § 5 Privacy Considerations
</p>

	</section>
	<section id="security">
<h2 title="Security Considerations">10. ~securityの考慮点</h2>

<p class="issue">
`~level 2$ の `§ ~securityの考慮点＠~CSSCONTAIN#security$
をここに併合する。
◎
CSS Containment 2 § 6 Security Considerations
</p>

	</section>
	<section id="changes">
<h2 title="Appendix A. Changes">変更点</h2>

◎非規範的

<dl>
	<dt id="changes-2022-08">
`2022年 8月 18日 作業草案＠~TR/2022/WD-css-contain-3-20220818/$
からの有意な変更点
◎
Changes since the 18 August 2022 Working Draft
◎
Significant changes since the 18 August 2022 Working Draft include:
</dt>
	<dd>
直列化~順序を明確化するするため、
`contain$p 用の値すべてを~listした。
（ `8600$issue ）
◎
List all values of contain in order to clarify serialization order (Issue 8600)
</dd>
	<dd>
`containerName$m, `containerQuery$m 属性を追加した。
（ `7033$issue ）
◎
Add the containerName and containerQuery attributes. (Issue 7033)
</dd>
	<dd>
`container-type$p 構文~内の誤記を正して，
`normal$v は他の値と組合できないことを明確化した。
（ `7669$issue ）
◎
Correct typo in container-type syntax, to clarify that normal cannot be combined with other values. (Issue 7669)
</dd>
	<dd>
`content-visibility$p ~propを~animate可能にした。
（ `8627$issue ）
◎
Make the content-visibility property animatable. (Issue 8627)
</dd>

	<dt id="changes-2021-12">
`2021年 12月 21日 最初の公な作業草案＠~TR/2021/WD-css-contain-3-20211221/$
からの有意な変更点
◎
Changes since the 21 December 2021 First Public Working Draft
◎
Significant changes since the 21 December 2021 First Public Working Draft include:
</dt>

	<dd>
`container-name$p の算出d値が重複な識別子を含むことを許容した。
（ `7181$issue ）
◎
Allow the computed value of container-name to include duplicate identifiers. (Issue 7181)
</dd>
	<dd>
`container$p 略式~内の `container-name$tp は、
要求されるものとした。
（ `7142$issue ）
◎
Make the &lt;'container-name'&gt; in the container shorthand required. (Issue 7142)
</dd>
	<dd>
`容器~style~query$内の`略式~prop$の取扱いを明確化した。
（ `7095$issue ）
◎
Clarify handling of shorthand properties in container style queries. (Issue 7095)
</dd>
	<dd>
`~cascadeに依存する~keyword$は、
`~style特能$内の値としては許容されず，
当の`容器~style~query$を `偽^i に評価させるようにした。
（ `7080$issue ）
◎
Cascade-dependent keywords are not allowed as values in a style feature, and cause the container style query to be false. (Issue 7080)
</dd>
	<dd>
`container-type$p の初期~値を `normal$v に変更した
— それは、
要素を`~style特能$用の容器として確立する。
（ `6393$issue, `7066$issue, `7402$issue ）
◎
Change the initial value of container-type to be normal, which establishes elements as containers for style features. (Issue 6393, Issue 7066, Issue 7402)
</dd>
	<dd>
`container-type$p から `block-size^v 値を除去した
— 単-軸な塊~sizeの封込めは、
現時点ではアリではないので。
（ `1031$issue ）
◎
Remove the block-size value from container-type, since single-axis block-size containment is not currently possible. (Issue 1031)
</dd>
	<dd>
`container-name$p 構文から `string$t ~optionを除去した。
容器~名は、
`custom-ident$t でなければならないものとした。
（ `6405$issue ）
◎
Remove the &lt;string&gt; option from the container-name syntax. Container names must be &lt;custom-ident&gt;s. (Issue 6405)
</dd>
	<dd>
`container$p 略式~propにおける［
`container-name$tp と `container-type$tp
］の順序を逆にして，どちらも省略可能とした。
（ `6393$issue ）
◎
Reverse the order of &lt;'container-name'&gt; and &lt;'container-type'&gt; in the container shorthand property, with both being optional. (Issue 6393)
</dd>
	<dd>
前方-互換性を得るため、
`container-condition$t 内に `general-enclosed$t 構文を許容した。
（ `6396$issue ）
◎
Allow &lt;general-enclosed&gt; syntax in &lt;container-condition&gt;s, for the sake of forward compatibility. (Issue 6396)
</dd>
	<dd>
`size-feature$t ~queryから~size関数~構文を除去した
（ `6870$issue ）
◎
Remove the size function syntax from &lt;size-feature&gt; queries. (Issue 6870)
</dd>
	<dd>
`~query容器$の選定~処理nを必要yな `container-type$p を織り込むよう更新して，
明示的な種別~選定~用の構文を除去した。
（ `6644$issue ）
◎
Update the query container selection process to account for necessary container-types, and removed the explicit type-selection syntax. (Issue 6644)
</dd>
	<dd>
先送りされていた状態~query特能を除去した。
（ `6402$issue ）
◎
Remove state query features, which have been deferred. (Issue 6402)
</dd>
	<dd>
疑似要素と~shadow~DOM周りの容器~選定を明確化した。
（ `5984$issue, `6711$issue ）
◎
Clarify container selection around pseudo-elements and the shadow-DOM. (Issue 5984 and Issue 6711)
</dd>

	<dt id="l3-changes">
`~level 2$ からの変更点
◎
Changes from CSS Containment Level 2
</dt>
	<dd>
`行内-~size封込め$を導入した。
◎
Introduces inline-size containment.
</dd>
	<dd>
`容器~query$用に必要な各種［
用語, ~prop, 単位, ~at-規則
］を定義した。
◎
Defines the terms, properties, units, and at-rule needed for Container Queries
</dd>
</dl>

<p class="issue">
`~level 2$ の `§ 変更点＠~CSSCONTAIN#changes$
をここに併合する。
◎
CSS Containment 2 § A Changes
</p>

		</section>
	
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
次に挙げる方々からの~commentや これまでの作業に，
および，この仕様に貢献された他の多くの方々に。
◎
</p>

<div lang="en">
Comments and previous work from Adam Argyle, Amelia Bellamy-Royds, Anders Hartvoll Ruud, Brian Kardell, Chris Coyier, Christopher Kirk-Nielsen, David Herron, Elika J. Etemad (fantasai), Eric Portis, Ethan Marcotte, Geoff Graham, Gregory Wild-Smith, Ian Kilpatrick, Jen Simmons, Kenneth Rohde Christiansen, L. David Baron, Lea Verou, Martin Auswöger, Martine Dowden, Mike Riethmuller, Morten Stenshorne, Nicole Sullivan, Rune Lillesveen, Scott Jehl Scott Kellum, Stacy Kvernmo, Theresa O’Connor, Una Kravets, and many others have contributed to this specification.
</div>

	</section>
</main></div>
