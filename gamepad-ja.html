<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Gamepad （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<style>
table {
	border-style: hidden hidden none hidden;
}

table thead {
	border-bottom: medium solid var(--table-rule-color);
}

table td, table th {
	border: solid thin var(--table-rule-color);
	border-top: none;
}
</style>



<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	let current_ifc = '';

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'm' :
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>



<script type="text/plain" id="_source_data">


●●options
spec_title:Gamepad
spec_date:2023-03-10
trans_update:2022-10-11
source_checked:210709
page_state_key:UIEVENTS
original_url:https://w3c.github.io/gamepad/
	abbr_url:GAMEPAD
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
conformance:w3c
copyright:2021,permissive
trans_1st_pub:2019-07-08


●●class_map
E:error
et:event-type
e:element
jv:js-value
sl:js-slot

●●tag_map
c:code
I:code
E:code
m:code
mb:code
sl:span
et:code
e:code
jv:code
i:i
cite:cite
V:var

●●original_id_map

●●mdn_urls
dom-gamepad:API/Gamepad
dom-gamepadbutton:API/GamepadButton
dom-gamepadevent:API/GamepadEvent
	dom-gamepadeventinit:API/GamepadEventInit
	dom-gamepadmappingtype:API/GamepadMappingType

dfn-gamepadconnected:API/Window/gamepadconnected_event
dfn-gamepaddisconnected:API/Window/gamepaddisconnected_event

●●link_map

Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject
SecureContext:~WEBIDLjs#SecureContext

boolean:~WEBIDL#idl-boolean
long:~WEBIDL#idl-long
unsigned long:~WEBIDL#idl-unsigned-long
double:~WEBIDL#idl-double
sequence:~WEBIDL#idl-sequence

c.unsigned long:~WEBIDL#idl-unsigned-long
c.double:~WEBIDL#idl-double

連列:~WEBIDL#idl-sequence
DOMString:~WEBIDL#idl-DOMString
FrozenArray:~WEBIDL#idl-frozen-array

E.SecurityError:~WEBIDL#securityerror

	I.DOMException:~WEBIDL#idl-DOMException
I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
I.EventHandler:~WAPI#eventhandler
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.Gamepad:#dom-gamepad
I.GamepadButton:#dom-gamepadbutton
I.GamepadEvent:#dom-gamepadevent
I.GamepadEventInit:#dom-gamepadeventinit
I.GamepadMappingType:#dom-gamepadmappingtype
I.Navigator:~HTMLnavigator#navigator
	I.Navigator:#dom-navigator
I.Window:~WINDOW#window
I.WindowEventHandlers:~WAPI#windoweventhandlers

m.axes:#dom-gamepad-axes
m.buttons:#dom-gamepad-buttons
m.connected:#dom-gamepad-connected
m.id:#dom-gamepad-id
m.index:#dom-gamepad-index
m.mapping:#dom-gamepad-mapping
m.timestamp:#dom-gamepad-timestamp

m.pressed:#dom-gamepadbutton-pressed
m.touched:#dom-gamepadbutton-touched
m.value:#dom-gamepadbutton-value

constructor:~DOM4#concept-event-constructor
	#dom-gamepadevent-constructor
m.gamepad:#dom-gamepadevent-gamepad
m.getGamepads:#dom-navigator-getgamepads

m.ongamepadconnected:#dom-windoweventhandlers-ongamepadconnected
m.ongamepaddisconnected:#dom-windoweventhandlers-ongamepaddisconnected

mb.gamepad:#dom-gamepadeventinit-gamepad

m.requestAnimationFrame:~HTMLGAPI#dom-animationframeprovider-requestanimationframe

l.standard:#dom-gamepadmappingtype-standard
	#dfn-standard
l.xr-standard:#dom-gamepadmappingtype-xr-standard
	#dfn-xr-standard
	空~文字列:#dom-gamepadmappingtype-the-empty-string

l.gamepad:#dfn-gamepad

et.gamepadconnected:#dfn-gamepadconnected
et.gamepaddisconnected:#dfn-gamepaddisconnected


sl.connected:#dfn-connected
sl.timestamp:#dfn-timestamp
sl.axes:#dfn-axes
sl.buttons:#dfn-buttons
sl.hasGamepadGesture:#dfn-hasgamepadgesture
sl.gamepads:#dfn-gamepads
sl.exposed:#dfn-exposed
sl.axisMapping:#dfn-axismapping
sl.axisMinimums:#dfn-axisminimums
sl.axisMaximums:#dfn-axismaximums
sl.buttonMapping:#dfn-buttonmapping
sl.buttonMinimums:#dfn-buttonminimums
sl.buttonMaximums:#dfn-buttonmaximums
sl.value:#dfn-value
sl.pressed:#dfn-pressed
sl.touched:#dfn-touched


	●用語
~gamepad~task源:#dfn-gamepad-task-source
~gamepad利用者~gestureを包含する:#dfn-gamepad-user-gesture
~gamepad利用者~gesture:#dfn-gamepad-user-gesture
新たな［~button／軸］入力~値を受信-:#dfn-receives-new-button-or-axis-input-values
新たな~gamepad:#dfn-a-new-gamepad
~gamepad状態を更新する:#dfn-update-gamepad-state
各~軸を対応付けて正規化する:#dfn-map-and-normalize-axes
各~buttonを対応付けて正規化する:#dfn-map-and-normalize-buttons
未利用な~gamepad~indexを選定する:#dfn-selecting-an-unused-gamepad-index
対応付けを選定する:#dfn-selecting-a-mapping
各~軸を初期化する:#dfn-initializing-axes
各~buttonを初期化する:#dfn-initializing-buttons
~button押圧~閾値:#dfn-button-press-threshold

標準~gamepad:#dfn-standard-gamepad
標準~gamepad~buttonを表現する:#dfn-represents-a-standard-gamepad-button
標準~gamepad軸を表現する:#dfn-represents-a-standard-gamepad-axis
正準的~index:#dfn-canonical-index


	Best Practice 1:#practice-timing
	Example 1:#example-1
	Example 2:#example-2

	●用語（外部
~UA:~INFRA#user-agent
範囲:~INFRA#the-range
有順序~map:~INFRA#ordered-map
~list:~INFRA#list
~size:~INFRA#list-size
付加する:~INFRA#list-append
空:~INFRA#list-is-empty
~item:~INFRA#list-item
除去する:~INFRA#list-remove
	~IN:~INFRA#list-contain
	~EACH:~INFRA#list-iterate

新たな:~WEBIDLjs#new

~taskを~queueする:~WAPI#queue-a-task
環境~設定群~obj:~WAPI#environment-settings-object
結付けられている文書:~WINDOW#concept-document-window
現在の大域~obj:~WAPI#current-global-object
関連な大域~obj:~WAPI#concept-relevant-global
enV.大域~obj:~WAPI#concept-settings-object-global
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes

結付けられている~Navigator:~HTMLnavigator#associated-navigator

結付けられている文書:~WINDOW#concept-document-window
全部的に作動中:~HTMLds#fully-active

利用は許容され:~HEembed#allowed-to-use
利用は許容されて:~HEembed#allowed-to-use

doc.許可~施策:~HTMLdom#concept-document-permissions-policy

文書:~DOM4#concept-document
~eventを発火する:~DOM4#concept-event-fire

既定の許容list:~PERMISSIONS-POLICY#policy-controlled-feature-default-allowlist
施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature

現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time

	:~XRGAMEPAD#xr-standard-gamepad-mapping
	:~XRGAMEPAD


●●words_table1
XRGAMEPAD:https://www.w3.org/TR/webxr-gamepads-module-1/
	https://immersive-web.github.io/webxr-gamepads-module/

●●words_table

	●Gamepad／hardware
Gamepad:
USB:
2D:
X:
Y:
XR:
WebXR:
controller::::コントローラ
game::::ゲーム
gamepad::::ゲームパッド
gaming::::ゲーミング
プレゼン:presentation:::~
sensor::::センサー
switch::::スイッチ
touch::::タッチ
viewer::::ビューア
stick::::スティック
joystick::::ジョイスティック
thumbstick::::親指スティック
ハンドルペダルアクセル:driving wheel, pedal, accelerometer::::ハンドル, ペダル, アクセル
方向-:directional::~
押す:pressする::~
押圧:press::~
押され:pressされ::~
	押されていない:unpressed
	pressed$m:pressed
	に一体化された:pressed
放され:releaseされ::~
analog::::アナログ
digital::::デジタル
toggle::::トグル
引金:trigger:引き金
製品:product:~
製造元:manufacturer:~
動き:motion::~
動かし:moveし:~
運動:movement:~
変位:displacement::~
方位:orientation::~
奥行き:depth::~
感知:sensing::~
装着-:attach:~
切断-:disconnect::~
切断:disconnection::~
電源:power:~
	電源が切られた:powered off

対応付直す:remapする::対応付け直す
対応付直法:remap 法::対応付け直し法

水平-:horizontal::~
垂直-:vertical::~
線形:linear::~
閾値:threshold::~
中立:neutral::~
serial::::シリアル
番号:number:~
Bluetooth:
揺らぎ:jitter::~

	^en:self-center
	上:top
	下:bottom
	上:up
	下:down
	右:right
	左:left
	中央:center
	左上:top left
	右上:top right
	左下:bottom left
	右下:bottom right
	上下:up-down
	左右:left-right
	左側は負:negative left／
	右側は正:positive right
	上側は負:negative up
	下側は正:positive down
	前方:forward
	後方:backward
	左方:left
	右方:right
	天を指して:perpendicular to the ground with 〜 pointing up
	前面:front
	~~前方に面した:front facing
	~~前方に面し，左右各側に 2 個ずつある:pair of front facing buttons on the left and right side
	左右各側にある:a pair of 〜 one on the left and one on the right
	所在は〜とほぼ同じ:located in approximately the same location
	〜どちらかのみ:pure 〜


	●処理
標本化-:sample::~::サンプル
稼働-:run::~
	稼働している:running
更新周期:frequency:~
rate::::レート

高分解能:high resolution::~
分解能:resolution::~
micro::::マイクロ
	~micro秒~以上:minimum 〜 microseconds
時計:clock:~
近過去:recent:~
unmapped:::元の
Navigator:
navigator:
未利用:unused:~

	正規化-:scale
	%今:now
	%~button~list:buttons
	%~button~index:buttonIndex
	%~button~list~size:buttonsSize
	%~button値~list:buttonValues
	%~gamepad~index:gamepadIndex
	%~navigator:navigator
	%~unmapped入力~index~list:unmappedInputList
	%入力~個数:inputCount
	%対応付けた~index:mappedIndex
	%対応付けた~index~list:mappedIndexList
	%接続-済み~gamepad:connectedGamepad
	%最大~gamepad~index:maxGamepadIndex
	%最大な生の~button~index:maxRawButtonIndex
	%最大な生の軸~index:maxRawAxisIndex
	%正準的~index:canonicalIndex
	%正規化した値:normalizedValue
	%生の~button~index:rawButtonIndex
	%生の入力~index:rawInputIndex
	%生の軸~index:rawAxisIndex
	%論理-値:logicalValue
	%論理-最大~値:logicalMaximum
	%論理-最小~値:logicalMinimum
	%軸~index:axisIndex
	%軸~list:axes
	%軸~list~size:axesSize
	%軸~値~list:axisValues
	%文書:doc
	%文書:document

	●S／P
能動的:active::~
表口:surface::口

	●仕様
協調-:coordinate:~
協調:coordination:~
模倣-:emulate:~
模倣:emulation:~
一般性:generality:~
事実上の:de-facto:~
解決策:solution:~
第一:primary:~
第二:secondary:~
第三:tertiary:~
brand::::ブランド
	デモ:demo
poll:
転がす:rollする:~
失う:loseする:~
適度:reasonable:~
選ぶ:chooseする:~
手助け:facilitate:~

	-:trying to be a
	~interface法:interfacing
	可用でなくなった:becomes unavailable
	に基づいて:basis
	利用-不能:unusable
	片:snippet
	広くから:widely
	おそれ:potential
	~~普及した:have been made popular
	その一方、~meanwhile:#1
	広く:broadly
	代表する呼称:exemplary:#1
	手に負えなく:intractable
	多少:somewhat
	能力がある／ない:capable of
	望ましい:desirable
	巨大:large
	種:type
	の様になる:look like
	適する:suited
	も含めるかどうか，〜 含める場合、:whether to include or exclude
	絞る:choose to narrow
	指定されない:left unspecified
	表:table
	能力がある:capable

	●未分類
分析:analysis:~
生の:raw:~
一定量:certain amount:~
アテガい:assignし::あてがい
現れる:appearする:~
現れな:appearしな:~
許容list:allowlist::許容 list:許容リスト

	~index:indice
	〜中の:continue
	変化-用:changed
	取り出され:drawn
	列挙:enum
	-:mirror
	-:present

	●指示語
	0 でない:greater than 0
	交互に:next to each other
	現在:currently
	現時点:currently
	てから:subsequently
	から:starting
	それまでに／以前に:previously
	上回る:above
	下回る:below
	低~level:low-level
	近く／近くに:closely
	表:table
	範囲をとる:ranging from
	~~固有の:unique
	最初に来たものから順に:first-come first-serve
	高いものから順:decreasing order／:decreasing
	最低:lowest

●●images
＠gamepad/
standard_gamepad｜height:22rem｜｜.svg

●●ref_normative

[dom]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FINGERPRINTING-GUIDANCE]
    Mitigating Browser Fingerprinting in Web Specifications. Nick Doty. W3C. 28 March 2019. W3C Working Group Note. URL: https://www.w3.org/TR/fingerprinting-guidance/ 
[HR-TIME]
    High Resolution Time. Yoav Weiss. W3C. 16 February 2023. W3C Working Draft. URL: https://www.w3.org/TR/hr-time-3/ 
[html]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[infra]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/ 
[permissions-policy]
    Permissions Policy. Ian Clelland. W3C. 22 February 2023. W3C Working Draft. URL: https://www.w3.org/TR/permissions-policy-1/ 
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119 
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174 
[WEBIDL]
    Web IDL Standard. Edgar Chen; Timothy Gu. WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/ 
[webxr-gamepads-module-1]
    WebXR Gamepads Module - Level 1. Brandon Jones; Manish Goregaokar; Rik Cabanier. W3C. 26 April 2022. W3C Working Draft. URL: https://www.w3.org/TR/webxr-gamepads-module-1/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Gamepad</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/gamepad/
公表履歴
	https://www.w3.org/standards/history/gamepad
編集者草案
	https://w3c.github.io/gamepad/
commit 履歴
	https://github.com/w3c/gamepad/commits/
テスト一式
	https://wpt.live/gamepad/
実装報告
	https://wpt.fyi/results/gamepad
編集
	Steve Agoston (Sony)
	Matt Reynolds (Google)
前任編集者
	James Hollyer (Google)
	<a href="http://tojicode.com/">Brandon Jones</a> (Google)
	<a href="http://h4ck3r.net/">Scott Graham</a> (Google)
	<a href="http://ted.mielczarek.org/">Ted Mielczarek</a> (Mozilla)
フィードバック
	<a href="https://github.com/w3c/gamepad/">GitHub w3c/gamepad</a> (<a href="https://github.com/w3c/gamepad/pulls/">pull requests</a>, <a href="https://github.com/w3c/gamepad/issues/new/choose">new issue</a>, <a href="https://github.com/w3c/gamepad/issues/">open issues</a>)
ブラウザサポート
	https://caniuse.com/gamepad
公表者
	<a href="https://www.w3.org/groups/wg/webapps">Web Applications WG</a>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>Gamepad</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
~Gamepad仕様は、~gamepad装置を表現する低~levelな~interfaceを定義する。
◎
The Gamepad specification defines a low-level interface that represents gamepad devices.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
`この節では、公表~時点における…^em
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
`~UA$には、~gamepad装置が接続されるものもある。
これらの装置は、~gaming~app用の入力や
“数歩先の” ~UI
【<a href="https://en.wikipedia.org/wiki/10-foot_user_interface">10 foot UI</a>】
（プレゼン, ~media~viewerなど）
に望ましい, かつ適する。
◎
Some user agents have connected gamepad devices. These devices are desirable and suited to input for gaming applications, and for "10 foot" user interfaces (presentations, media viewers).
</p>

<p>
~gamepadを入力として利用する仕方は、現時点では，［
~mouse／~keyboard
］~eventで模倣する他にない。
しかしながら，これは、情報を失うことに加え，［
模倣を成遂げるためには，`~UA$の外側に追加的な~softwareを要求する
］ことになる。
◎
Currently, the only way for a gamepad to be used as input would be to emulate mouse or keyboard events, however this would lose information and require additional software outside of the user agent to accomplish emulation.
</p>

<p>
その一方，~native~appには、
~system~APIを介してこれらの装置へ~accessする能力がある。
◎
Meanwhile, native applications are capable of accessing these devices via system APIs.
</p>

<p>
~Gamepad~APIは、［
~gamepad~data上で直に動作することを~web~appに許容する~interface
］を指定することにより，この問題への解決策を供する。
◎
The Gamepad API provides a solution to this problem by specifying interfaces that allow web applications to directly act on gamepad data.
</p>

	</section>
	<section id="scope">
<h2 title="Scope">2. 視野</h2>

<p>
~gameの制御-用に設計された外部~装置との~interface法は、
全部的な一般性に向かって~approachすると，巨大で手に負えなくなるおそれがある。
この仕様では、明示的に視野を絞って，そのような機能性のうち［
広くから実装でき，広く有用になる下位集合
］を供する。
◎
Interfacing with external devices designed to control games has the potential to become large and intractable if approached in full generality. In this specification we explicitly choose to narrow scope to provide a useful subset of functionality that can be widely implemented and broadly useful.
</p>

<p>
特定的には，ここでは、
~gamepadを~supportするために要求される機能性に限り~supportする。
~gamepad用の~supportは、
2 種の入力
— ~button, 軸（ `axis^en ） —
を要求する。
両者とも~analog値として報告され、
各~buttonは［
0 以上, 1 以下
］の範囲を,
各~軸は［
−1 以上, 1 以下
］の範囲をとる。
◎
Specifically, we choose to only support the functionality required to support gamepads. Support for gamepads requires two input types: buttons and axes. Both buttons and axes are reported as analog values, buttons ranging from [0..1], and axes ranging from [-1..1].
</p>

<p>
首な目標は，~gamepad装置~用の~supportであるが、
この 2 種の~analog入力を~supportすることで，［
現在の~gaming~systemに共通な，他の類似な装置
］
— ~joystick, ハンドルペダルアクセル, 等々も含む —
用の~supportも許容する。
そのようなわけで、
“~gamepad” という名前は
— この仕様が取組む装置の集合~全体を汎用に表すものではなく —
それらを~~代表する呼称である。
◎
While the primary goal is support for gamepad devices, supporting these two types of analog inputs allows support for other similar devices common to current gaming systems including joysticks, driving wheels, pedals, and accelerometers. As such, the name "gamepad" is exemplary rather than trying to be a generic name for the entire set of devices addressed by this specification.
</p>

<p>
特定的には、
一部の~gaming文脈で利用され得る，より複階的な装置
— ［
動き感知／
奥行き感知／
動画~分析／
~gesture認識
］等々を行うもの —
の~supportは除外される。
◎
We specifically exclude support for more complex devices that may also be used in some gaming contexts, including those that that do motion sensing, depth sensing, video analysis, gesture recognition, and so on.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
	<section id="gamepad-interface">
<h2 title="Gamepad interface">3. `Gamepad^I ~interface</h2>

<p>
この~interfaceは、
個々の~gamepad装置を定義する。
◎
This interface defines an individual gamepad device.
</p>

<pre class="idl">
[`Exposed$=Window, `SecureContext$]
interface `Gamepad@I {
  readonly attribute `DOMString$ `id$m;
  readonly attribute `long$ `index$m;
  readonly attribute `boolean$ `connected$m;
  readonly attribute `DOMHighResTimeStamp$I `timestamp$m;
  readonly attribute `GamepadMappingType$I `mapping$m;
  readonly attribute `FrozenArray$&lt;`double$&gt; `axes$m;
  readonly attribute `FrozenArray$&lt;`GamepadButton$I&gt; `buttons$m;
};
</pre>

<p>
~systemと通信するために利用される各種~algoは、概して，
`~gamepad~task源@
に対し~queueするように働くことにより，非同期に完了する。
◎
The algorithms used to communicate with the system typically complete asynchronously, queuing work on the gamepad task source.
</p>

<p>
`Gamepad$I の各~instance %~gamepad は、
次の表に述べる内部~slot群を伴って作成される：
◎
Instances of Gamepad are created with the internal slots described in the following table:
</p>

<table><thead>
<tr><th>
内部~slot
◎
Internal slot
<th>
初期~値
◎
Initial value
<th>
記述 （規範的でない）
◎
Description (non-normative)
<tbody>

<tr><td>
`connected@sl
<td>
~F
<td>
［
当の装置は~systemに接続されているかどうか
］を指示する~flag。
◎
A flag indicating that the device is connected to the system

<tr><td>
`timestamp@sl
<td>`undefined^jv
<td>
%~gamepad 用の~dataが最後に更新された時刻。
◎
The last time data for this Gamepad was updated

<tr><td>
`axes@sl
<td>
空な`~list$【！sequence】
◎
An empty sequence
<td>
［
この装置により公開される各~軸の現在の状態
］を表現している，一連の `double$c 値からなる`~list$【！sequence】。
◎
A sequence of double values representing the current state of axes exposed by this device

<tr><td>
`buttons@sl
<td>
空な`~list$【！sequence】
◎
An empty sequence
<td>
［
この装置により公開される各~buttonの現在の状態
］を表現している一連の `GamepadButton$I ~objからなる`~list$【！sequence】。
◎
A sequence of GamepadButton objects representing the current state of buttons exposed by this device

<tr><td>
`exposed@sl
<td>~F
<td>
%~gamepad は~scriptに公開されたかどうかを指示する~flag。
◎
A flag indicating that the Gamepad object has been exposed to script

<tr><td>
`axisMapping@sl
<td>
空な`有順序~map$
◎
An empty ordered map
<td>
~unmapped軸~indexから `axes$m 配列~内を指す~indexへの対応付け。
◎
Mapping from unmapped axis index to an index in the axes array

<tr><td>
`axisMinimums@sl
<td>
空な`~list$
◎
An empty list
<td>
各~軸~用の最小な論理-値を包含している`~list$。
◎
A list containing the minimum logical value for each axis

<tr><td>
`axisMaximums@sl
<td>
空な`~list$
◎
An empty list
<td>
各~軸~用の最大な論理-値を包含している`~list$。
◎
A list containing the maximum logical value for each axis

<tr><td>
`buttonMapping@sl
<td>
空な`有順序~map$
◎
An empty ordered map
<td>
~unmapped~button~indexから `buttons$m 配列~内を指す~indexへの対応付け。
◎
Mapping from unmapped button index to an index in the buttons array

<tr><td>
`buttonMinimums@sl
<td>
空な`~list$
◎
An empty list
<td>
各~button用の最小な論理-値を包含している`~list$。
◎
A list containing the minimum logical value for each button.

<tr><td>
`buttonMaximums@sl
<td>
空な`~list$
◎
An empty list
<td>
各~button用の最大な論理-値を包含している`~list$。
◎
A list containing the maximum logical value for each button
</table>

<p>
`id@m
属性は：
◎
id attribute
</p>
<ul>
	<li>
~gamepad用の識別~文字列を指示する
— それは、接続された~gamepad装置の~brandや~styleを識別する。
◎
An identification string for the gamepad. This string identifies the brand or style of connected gamepad device.
</li>
	<li>
識別~文字列の正確な形式は、指定されない。
`~UA$には、［
製品を識別する文字列
］として［
装置を一意に識別しないもの
］を選定することが推奨される。
例えば，~USB~gamepadは、その［
`idVendor^c, `idProduct^c
］値により識別され得る。
識別~文字列には、［
~serial番号や~Bluetooth装置~addressの様な，
【各~装置，したがって各~利用者に】一意な識別子
］は含めないモノトスル。
◎
The exact format of the id string is left unspecified. It is RECOMMENDED that the user agent select a string that identifies the product without uniquely identifying the device. For example, a USB gamepad may be identified by its idVendor and idProduct values. Unique identifiers like serial numbers or Bluetooth device addresses MUST NOT be included in the id string.
</li>
</ul>

<p>
`index@m
属性は：
◎
index attribute
</p>
<ul>
	<li>
`Navigator$I
【の `getGamepads()$m が返す配列】
における，この~gamepadの~indexを指示する。
◎
The index of the gamepad in the Navigator.＼
</li>
	<li>
<p>
`~UA$は、各~gamepadに~indexをアテガうときには，次に従うモノトスル：
</p>
		<ul>
			<li>
接続されている~gamepadが複数ある場合、
最初に接続されたものから順に， 0 から~indexをアテガう。
</li>
			<li>
ある~gamepadが切断されても、
それにアテガわれていた~indexを接続-中の~gamepadにはアテガい直さない。
【接続-中のどの~gamepadも，その~indexは変化しない。】
</li>
			<li>
~gamepadが切断されてから，同じまたは異なる~gamepadが接続された場合、
それまでに利用された【かつ接続-中の~gamepadにアテガっていない】最低な~indexを再利用する。
</li>
		</ul>
◎
When multiple gamepads are connected to a user agent, indices MUST be assigned on a first-come, first-serve basis, starting at zero. If a gamepad is disconnected, previously assigned indices MUST NOT be reassigned to gamepads that continue to be connected. However, if a gamepad is disconnected, and subsequently the same or a different gamepad is then connected, the lowest previously used index MUST be reused.
</li>
</ul>

<p>
`connected@m
属性は：
◎
connected attribute
</p>
<ul>
	<li>
この~objにより表現される物理的な装置は、
依然として~systemに接続されているかどうかを指示する。
◎
Indicates whether the physical device represented by this object is still connected to the system.＼
</li>
	<li>
~gamepadが可用でなくなったとき
— 物理的に切断された, 電源が切られた, その他~利用-不能になったなど —
この属性は、 ~F に設定するモノトスル。
◎
When a gamepad becomes unavailable, whether by being physically disconnected, powered off or otherwise unusable, the connected attribute MUST be set to false.
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ.`connected$sl
◎
The connected getter steps are:
• Return this.[[connected]].
</li>
</ul>

<p>
`timestamp@m
属性は：
◎
timestamp attribute
</p>
<ul>
	<li>
次を決定することを作者に許容する
⇒
この~gamepad用の［
`axes$m ／ `buttons$m
］属性が最後に更新された時刻
◎
The timestamp allows the author to determine the last time the axes or buttons attribute for this gamepad was updated.＼
</li>
	<li>
<p>
値は、次に挙げる各~時点に，その時点における`現在の高分解能~時刻$に設定するモノトスル：
◎
The value MUST be set to the current high resolution time＼
</p>
		<ul>
			<li>
~systemが装置から`新たな［~button／軸］入力~値を受信-$した各回
◎
each time the system receives new button or axis input values from the device.＼
</li>
			<li>
~hardwareから まだ何も~dataを受信していない間は、
この `Gamepad$I が~scriptに最初に可用された時点
◎
If no data has been received from the hardware, timestamp MUST be the current high resolution time at the time when the Gamepad was first made available to script.
</li>
		</ul>

<p class="warning" id="issue-container-generatedID">
`~UA$は、 `HR-TIME$r による時計~分解能の推奨に従って，
%~gamepad の `timestamp$m 属性の分解能を 5 ~micro秒~以上に設定するベキである。
◎
Warning
User agents SHOULD set a minimum resolution of gamepad's timestamp attribute to 5 microseconds, following [HR-TIME]'s clock resolution recommendation.
</p>
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ.`timestamp$sl
◎
The timestamp getter steps are:
◎
Return this.[[timestamp]].
</li>
</ul>

<p>
`mapping@m
属性は：
◎
mapping attribute
</p>
<ul>
	<li>
この装置~用に利用-中の~layout対応付けを指示する。
◎
The mapping in use for this device.＼
</li>
	<li>
`~UA$は，装置の~layoutについて知識がある場合、この属性を［
当の~layoutに対応している `GamepadMappingType$I 値
］に設定することにより，対応付けが利用-中にあることを指示するベキである。
◎
If the user agent has knowledge of the layout of the device, then it SHOULD indicate that a mapping is in use by setting mapping to the corresponding GamepadMappingType value.
</li>
	<li class="algo">
<p>
~gamepad装置~用の
`対応付けを選定する@
ときは、次の手続きを走らす：
◎
To select a mapping for a gamepad device, run the following steps:
</p>
		<ol>
			<li>
~IF［
当の~gamepad装置の［
~button, 軸
］の~layoutは、`標準~gamepad$の~layoutに対応する
］
⇒
~RET `standard$l
◎
If the button and axis layout of the gamepad device corresponds with the Standard Gamepad layout, then return "standard".
</li>
			<li>
~RET <a href="#dom-gamepadmappingtype-the-empty-string">空~文字列</a>
◎
Return "".
</li>
		</ol>
	</li>
</ul>


<p>
`axes@m
属性は：
◎
axes attribute
</p>
<ul>
	<li>
この~gamepadを成す すべての軸の値たちからなる配列を返す。
◎
Array of values for all axes of the gamepad.＼
</li>
	<li>
すべての軸~値は［
−1.0 以上 1.0 以下
］の範囲に線形に正規化するモノトスル。
~controllerの方向-~stickは天を指しているならば、
−1.0 は［
“前方” ／ “左方”
］に対応し，
1.0 は［
“後方” ／ “右方”
］に対応するベキである。
◎
All axis values MUST be linearly normalized to the range [-1.0 .. 1.0].＼
If the controller is perpendicular to the ground with the directional stick pointing up, -1.0 SHOULD correspond to "forward" or "left", and 1.0 SHOULD correspond to "backward" or "right".＼
</li>
	<li>
~2D入力~装置から取り出される軸は、配列~内で［
~X軸, ~Y軸
］の順に，交互に現れるベキである。
軸たちは、重要度の高いものから順に
— 概して，［
0 番, 1 番
］の要素が順に，方向-~stickの［
~X軸, ~Y軸
］を表現するように —
現れることが推奨される。
◎
Axes that are drawn from a 2D input device SHOULD appear next to each other in the axes array, X then Y. It is RECOMMENDED that axes appear in decreasing order of importance, such that element 0 and 1 typically represent the X and Y axis of a directional stick.＼
</li>
	<li>
この属性は、異なる値たちを返す（あるいは値たちを異なる順序にする）必要があるときまで，同じ~objを返すモノトスル。
◎
The same object MUST be returned until the user agent needs to return different values (or values in a different order).
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ.`axes$sl
◎
The axes getter steps are:
• Return this.[[axes]].
</li>
</ul>

<p>
`buttons@m
属性は：
◎
buttons attribute
</p>
<ul>
	<li>
この~gamepadを成す すべての~buttonの状態からなる配列を返す。
◎
Array of button states for all buttons of the gamepad.＼
</li>
	<li>
各~buttonは、重要度の高いものから順に現れる
— ［
第一~button, 第二~button, 第三~button, 等々
］が配列~内で［
0, 1, 2, …
］番の要素として現れる —
ことが推奨される。
◎
It is RECOMMENDED that buttons appear in decreasing importance such that the primary button, secondary button, tertiary button, and so on appear as elements 0, 1, 2, ... in the buttons array.＼
</li>
	<li>
この属性は、異なる値たちを返す（あるいは値たちを異なる順序にする）必要があるときまで，同じ~objを返すモノトスル。
◎
The same object MUST be returned until the user agent needs to return different values (or values in a different order).
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ.`buttons$sl
◎
The buttons getter steps are:
• Return this.[[buttons]].
</li>
</ul>

		<section id="receiving-inputs">
<h3 title="Receiving inputs">3.1. 入力の受信-法</h3>

<div class="algo">
<p>
~systemの %装置 から
`新たな［~button／軸］入力~値を受信-@
したときは、次の手続きを走らす：
◎
When the system receives new button or axis input values, run the following steps:
</p>
<ol>
	<li>
%~gamepad ~LET %装置 を表現している `Gamepad$I ~obj
◎
Let gamepad be the Gamepad object representing the device that received new button or axis input values.
</li>
	<li>
次を走らす`~taskを~queueする$( `~gamepad~task源$ )
⇒
`~gamepad状態を更新する$( %~gamepad )
◎
Queue a task on the gamepad task source to update gamepad state for gamepad.
</li>
</ol>
</div>

<div class="algo">
<p>
%~gamepad 用に
`~gamepad状態を更新する@
ときは、次の手続きを走らす：
◎
To update gamepad state for gamepad, run the following steps:
</p>
<ol>
	<li>
%今 ~LET `現在の高分解能~時刻$
◎
Let now be the current high resolution time.
</li>
	<li>
%~gamepad.`timestamp$sl ~SET %今
◎
Set gamepad.[[timestamp]] to now.
</li>
	<li>
%~gamepad 用に`各~軸を対応付けて正規化する$()
◎
Run the steps to map and normalize axes for gamepad.
</li>
	<li>
%~gamepad 用に`各~buttonを対応付けて正規化する$()
◎
Run the steps to map and normalize buttons for gamepad.
</li>
	<li>
%~navigator ~LET %~gamepad に`関連な大域~obj$に`結付けられている~Navigator$
◎
Let navigator be gamepad's relevant global object's Navigator object.
</li>
	<li>
<p>
~IF［
%~navigator.`hasGamepadGesture$sl ~EQ ~F
］~AND［
%~gamepad は`~gamepad利用者~gestureを包含する$
］：
◎
If navigator.[[hasGamepadGesture]] is false and gamepad contains a gamepad user gesture:
</p>
		<ol>
			<li>
%~navigator.`hasGamepadGesture$sl ~SET ~T
◎
Set navigator.[[hasGamepadGesture]] to true.
</li>
			<li>
<p>
%~navigator.`gamepads$sl を成す
~EACH( %接続-済み~gamepad )
に対し：
◎
For each connectedGamepad of navigator.[[gamepads]]:
</p>
				<ol>
					<li>
~IF［
%接続-済み~gamepad ~EQ ~NULL
］
⇒
~CONTINUE
◎
If connectedGamepad is not equal to null:
</li>
					<li>
%接続-済み~gamepad.`exposed$sl ~SET ~T
◎
Set connectedGamepad.[[exposed]] to true.
</li>
					<li>
%接続-済み~gamepad.`timestamp$sl ~SET %今
◎
Set connectedGamepad.[[timestamp]] to now.
</li>
					<li>
%文書 ~LET %~gamepad に`関連な大域~obj$に`結付けられている文書$
— 他の場合【？】は ~NULL
◎
Let document be gamepad's relevant global object's associated Document; otherwise null.
</li>
					<li>
~IF［
%文書 ~EQ ~NULL
］~OR［
%文書 は`全部的に作動中$でない
］
⇒
~CONTINUE
◎
↓</li>
					<li>
次を走らす`~taskを~queueする$( `~gamepad~task源$ )
⇒
`~eventを発火する$( %~gamepad に`関連な大域~obj$, `gamepadconnected$et, `GamepadEvent$I )
— 次のように初期化して
⇒
`gamepad$m 属性 ~SET %接続-済み~gamepad
◎
If document is not null and is fully active, then queue a task on the gamepad task source to fire an event named gamepadconnected at gamepad's relevant global object using GamepadEvent with its gamepad attribute initialized to connectedGamepad.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
%~gamepad 用に
`各~軸を対応付けて正規化する@
ときは、次の手続きを走らす：
◎
To map and normalize axes for gamepad, run the following steps:
</p>
<ol>
	<li>
<p>
%軸~値~list ~LET 次を表現している一連の `unsigned long$c† 値が成す`~list$
⇒
［
%~gamepad により表現される装置
］の［
各~軸~入力
］用の［
最も近過去な論理-軸~入力~値
］たち
◎
Let axisValues be a list of unsigned long values representing the most recent logical axis input values for each axis input of the device represented by gamepad.
</p>

<p class="trans-note">【
これらの値は~APIには直に公開されないにもかかわらず、
なぜ `unsigned long$c 型とされているのかは不明（他所の `unsigned long^c も同様）。
~USBなどの何らかの標準~規格の都合かもしれない。
】</p>


	</li>
	<li>
%最大な生の軸~index ~LET %軸~値~list の`~size$ ~MINUS 1
◎
Let maxRawAxisIndex be the size of axisValues − 1.
</li>
	<li>
<p>
`範囲$ { 0 〜 %最大な生の軸~index } を成す
~EACH( %生の軸~index )
に対し：
◎
For each rawAxisIndex of the range from 0 to maxRawAxisIndex:
</p>
		<ol>
			<li>
%対応付けた~index ~LET %~gamepad.`axisMapping$sl[ %生の軸~index ]
◎
Let mappedIndex be gamepad.[[axisMapping]][rawAxisIndex].
</li>
			<li>
%論理-値 ~LET %軸~値~list[ %生の軸~index ]
◎
Let logicalValue be axisValues[rawAxisIndex].
</li>
			<li>
%論理-最小~値 ~LET %~gamepad.`axisMinimums$sl[ %生の軸~index ]
◎
Let logicalMinimum be gamepad.[[axisMinimums]][rawAxisIndex].
</li>
			<li>
%論理-最大~値 ~LET %~gamepad.`axisMaximums$sl[ %生の軸~index ]
◎
Let logicalMaximum be gamepad.[[axisMaximums]][rawAxisIndex].
</li>
			<li>
%正規化した値 ~LET
2 ~MUL
( %論理-値 ~MINUS %論理-最小~値 )
~DIV
( %論理-最大~値 ~MINUS %論理-最小~値 )
~MINUS 1
◎
Let normalizedValue be 2 (logicalValue − logicalMinimum) / (logicalMaximum − logicalMinimum) − 1.
</li>
			<li>
%~gamepad.`axes$sl[ %軸~index ] ~SET %正規化した値
◎
Set gamepad.[[axes]][axisIndex] to be normalizedValue.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
%~gamepad 用に
`各~buttonを対応付けて正規化する@
ときは、次の手続きを走らす：
◎
To map and normalize buttons for gamepad, run the following steps:
</p>
<ol>
	<li>
%~button値~list ~LET 次を表現している `unsigned long$c 値が成す`~list$
⇒
［
%~gamepad により表現される装置
］の［
各~button入力
］用の［
最も近過去な論理-~button入力~値
］たち
◎
Let buttonValues be a list of unsigned long values representing the most recent logical button input values for each button input of the device represented by gamepad.
</li>
	<li>
%最大な生の~button~index ~LET %~button値~list の`~size$ ~MINUS 1
◎
Let maxRawButtonIndex be the size of buttonValues − 1.
</li>
	<li>
<p>
`範囲$ { 0 〜 %最大な生の~button~index } を成す
~EACH( %生の~button~index )
に対し：
◎
For each rawButtonIndex of the range from 0 to maxRawButtonIndex:
</p>
		<ol>
			<li>
%対応付けた~index ~LET %~gamepad.`buttonMapping$sl[ %生の~button~index ]
◎
Let mappedIndex be gamepad.[[buttonMapping]][rawButtonIndex].
</li>
			<li>
%論理-値 ~LET %~button値~list[ %生の~button~index ]
◎
Let logicalValue be buttonValues[rawButtonIndex].
</li>
			<li>
%論理-最小~値 ~LET %~gamepad.`buttonMinimums$sl[ %生の~button~index ]
◎
Let logicalMinimum be gamepad.[[buttonMinimums]][rawButtonIndex].
</li>
			<li>
%論理-最大~値 ~LET %~gamepad.`buttonMaximums$sl[ %生の~button~index ]
◎
Let logicalMaximum be gamepad.[[buttonMaximums]][rawButtonIndex].
</li>
			<li>
%正規化した値 ~LET
( %論理-値 ~MINUS %論理-最小~値 )
~DIV
( %論理-最大~値 ~MINUS %論理-最小~値 )
◎
Let normalizedValue be (logicalValue − logicalMinimum) / (logicalMaximum − logicalMinimum).
</li>
			<li>
%~button ~LET %~gamepad.`buttons$sl[ %対応付けた~index ]
◎
Let button be gamepad.[[buttons]][mappedIndex].
</li>
			<li>
%~button.`value$sl ~SET %正規化した値
◎
Set button.[[value]] to normalizedValue.
</li>
			<li>
~IF［
当の~buttonは、［
押された状態, 放された状態
］どちらかのみを指示する~digital~switchを備えている
］
⇒
%~button.`pressed$sl ~SET 当の~buttonは押されて［
いるならば ~T ／
いないならば ~F
］
◎
If the button has a digital switch to indicate a pure pressed or released state, set button.[[pressed]] to true if the button is pressed or false if it is not pressed.
</li>
			<li>
<p>
~ELSE
⇒
%~button.`pressed$sl ~SET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
当の値は`~button押圧~閾値$を上回る
</p>

<p class="trans-note">【
“当の値” は［
%論理-値 ／ %正規化した値
］どちらかを表す
（ `~button押圧~閾値$がどちらと比較されるかは，明示的に指定されていない）。
】</p>
◎
Otherwise, set button.[[pressed]] to true if the value is above the button press threshold or false if it is not above the threshold.
</li>
			<li>
~IF［
当の~buttonは ~touchを検出する能力がある
］
⇒
%~button.`touched$sl ~SET 
当の~buttonは現在~touchされて［
いるならば ~T ／
【いないならば ~F 】
］
◎
If the button is capable of detecting touch, set button.[[touched]] to true if the button is currently being touched.
</li>
			<li>
~ELSE
⇒
%~button.`touched$sl ~SET %~button.`pressed$sl
◎
Otherwise, set button.[[touched]] to button.[[pressed]].
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="constructing-a-gamepad">
<h3 title="Constructing a Gamepad">3.2. `Gamepad^c の構築-法</h3>

<div class="algo">
<p>
接続された~gamepad装置 %~gamepad装置 を表現している
`新たな~gamepad@
は、次の手続きを遂行することにより構築される：
◎
A new Gamepad representing a connected gamepad device is constructed by performing the following steps:
</p>
<ol>
	<li>
<p>
%~gamepad ~LET 新たな `Gamepad$I ~instance
— 以下に従って， %~gamepad を初期化する：
◎
Let gamepad be a newly created Gamepad instance:
</p>
		<ol>
			<li>
%~gamepad の `id$m 属性 ~SET %~gamepad装置 用の識別~文字列
◎
Initialize gamepad's id attribute to an identification string for the gamepad.
</li>
			<li>
%~gamepad の `index$m 属性 ~SET %~gamepad 用に`未利用な~gamepad~indexを選定する$()
◎
Initialize gamepad's index attribute to the result of selecting an unused gamepad index for gamepad.
</li>
			<li>
%~gamepad の `mapping$m 属性 ~SET %~gamepad装置 用に`対応付けを選定する$()
◎
Initialize gamepad's mapping attribute to the result of selecting a mapping for the gamepad device.
</li>
			<li>
%~gamepad.`connected$sl ~SET ~T
◎
Initialize gamepad.[[connected]] to true.
</li>
			<li>
%~gamepad.`timestamp$sl ~SET `現在の高分解能~時刻$
◎
Initialize gamepad.[[timestamp]] to the current high resolution time.
</li>
			<li>
%~gamepad.`axes$sl ~SET %~gamepad 用に`各~軸を初期化する$()
◎
Initialize gamepad.[[axes]] to the result of initializing axes for gamepad.
</li>
			<li>
%~gamepad.`buttons$sl ~SET %~gamepad 用に`各~buttonを初期化する$()
◎
Initialize gamepad.[[buttons]] to the result of initializing buttons for gamepad.
</li>
		</ol>
	</li>
	<li>
~RET %~gamepad
◎
Return gamepad.
</li>
</ol>

</div>

<div class="algo">
<p>
%~gamepad 用に
`未利用な~gamepad~indexを選定する@
ときは、次の手続きを走らす：
◎
To select an unused gamepad index for gamepad, run the following steps:
</p>
<ol>
	<li>
%~navigator ~LET %~gamepad に`関連な大域~obj$に`結付けられている~Navigator$
◎
Let navigator be gamepad's relevant global object's Navigator object.
</li>
	<li>
%最大~gamepad~index ~LET %~navigator.`gamepads$sl の`~size$ ~MINUS 1
◎
Let maxGamepadIndex be the size of navigator.[[gamepads]] − 1.
</li>
	<li>
<p>
`範囲$ { 0 〜 %最大~gamepad~index } を成す
~EACH( %~gamepad~index )
に対し
⇒
~IF［
%~navigator.`gamepads$sl[ %~gamepad~index ] ~EQ ~NULL
］
⇒
~RET %~gamepad~index
◎
For each gamepadIndex of the range from 0 to maxGamepadIndex:
• If navigator.[[gamepads]][gamepadIndex] is null, then return gamepadIndex.
</p></li>
	<li>
%~navigator.`gamepads$sl に ~NULL を`付加する$
◎
Append null to navigator.[[gamepads]].
</li>
	<li>
~RET %~navigator.`gamepads$sl の`~size$ ~MINUS 1
◎
Return the size of navigator.[[gamepads]] − 1.
</li>
</ol>
</div>

<div class="algo">
<p>
%~gamepad 用に
`各~軸を初期化する@
ときは、次の手続きを走らす：
◎
To initialize axes for gamepad, run the following steps:
</p>
<ol>
	<li>
%装置 ~LET %~gamepad により表現される装置
◎
↓</li>
	<li>
%入力~個数 ~LET %装置 により公開される軸~入力の個数
◎
Let inputCount be the number of axis inputs exposed by the device represented by gamepad.
</li>
	<li>
%~gamepad.`axisMinimums$sl ~SET 新たな`~list$
◎
↓</li>
	<li>
%~gamepad.`axisMaximums$sl ~SET 新たな`~list$
◎
↓</li>
	<li>
<p>
~EACH( %~index ~IN { 0 〜 %入力~個数 ~MINUS 1 } )
に対し，昇順に：
</p>
		<ol>
			<li>
%~gamepad.`axisMinimums$sl に次を`付加する$
⇒
%装置 の %~index 番の軸~入力~用の最小な論理-値を与える `unsigned long$c 値
</li>
			<li>
%~gamepad.`axisMaximums$sl に次を`付加する$
⇒
%装置 の %~index 番の軸~入力~用の最大な論理-値を与える `unsigned long$c 値
</li>
		</ol>
◎
Set gamepad.[[axisMinimums]] to a list of unsigned long values with size equal to inputCount containing minimum logical values for each of the axis inputs.
◎
Set gamepad.[[axisMaximums]] to a list of unsigned long values with size equal to inputCount containing maximum logical values for each of the axis inputs.
</li>
	<li>
%~unmapped入力~index~list ~LET 空な`~list$
◎
Initialize unmappedInputList to be an empty list.
</li>
	<li>
%対応付けた~index~list ~LET 空な`~list$
◎
Initialize mappedIndexList to be an empty list.
</li>
	<li>
%軸~list~size ~LET 0
◎
Initialize axesSize to be 0.
</li>
	<li>
<p>
~EACH( %生の入力~index ~IN { 0 〜 %入力~個数 ~MINUS 1 } )
に対し：
</p>
		<ol>
			<li>
%正準的~index ~LET %装置 の %生の入力~index 番の軸~用の`正準的~index$
</li>
			<li>
<p>
~IF［
%正準的~index ~NEQ ε
］~AND［
%正準的~index ~NIN %対応付けた~index~list
］：
</p>
				<ol>
					<li>
%~gamepad.`axisMapping$sl[ %生の入力~index ] ~SET %正準的~index
</li>
					<li>
%対応付けた~index~list に %正準的~index を`付加する$
</li>
					<li>
~IF［
%正準的~index ~PLUS 1 ~GT %軸~list~size
］
⇒
%軸~list~size ~SET %正準的~index ~PLUS 1
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%~unmapped入力~index~list に %生の入力~index を`付加する$
</li>
		</ol>
◎
For each rawInputIndex of the range from 0 to inputCount − 1:
• If the the gamepad axis at index rawInputIndex represents a Standard Gamepad axis:
•• Let canonicalIndex be the canonical index for the axis.
•• If mappedIndexList contains canonicalIndex, then append rawInputIndex to unmappedInputList.
•• Otherwise:
••• Set gamepad.[[axisMapping]][rawInputIndex] to canonicalIndex.
••• Append canonicalIndex to mappedIndexList.
••• If canonicalIndex + 1 is greater than axesSize, then set axesSize to canonicalIndex + 1.
• Otherwise, append rawInputIndex to unmappedInputList.
</li>
	<li>
%軸~index ~LET 0
◎
Initialize axisIndex to be 0.
</li>
	<li>
<p>
%~unmapped入力~index~list を成す
~EACH( %生の入力~index )
に対し：
◎
For each rawInputIndex of unmappedInputList:
</p>
		<ol>
			<li>
~WHILE［
%軸~index ~IN %対応付けた~index~list
］
⇒
%軸~index ~INCBY 1
◎
While mappedIndexList contains axisIndex:
• Increment axisIndex.
</li>
			<li>
%~gamepad.`axisMapping$sl[ %生の入力~index ] ~SET %軸~index
◎
Set gamepad.[[axisMapping]][rawInputIndex] to axisIndex.
</li>
			<li>
%対応付けた~index~list に %軸~index を`付加する$
◎
Append axisIndex to mappedIndexList.
</li>
			<li>
~IF［
%軸~index ~PLUS 1 ~GT %軸~list~size
］
⇒
%軸~list~size ~SET %軸~index ~PLUS 1
◎
If axisIndex + 1 is greater than axesSize, then set axesSize to axisIndex + 1.
</li>
		</ol>
	</li>
	<li>
%軸~list ~LET 空な`~list$
◎
Initialize axes to be an empty list.
</li>
	<li>
`範囲$ { 0 〜 %軸~list~size ~MINUS 1 } を成す
~EACH( %軸~index )
に対し
⇒
%軸~list に 0 を`付加する$
◎
For each axisIndex of the range from 0 to axesSize − 1, append 0 to axes.
</li>
	<li>
~RET %軸~list
◎
Return axes.
</li>
</ol>

</div>

<div class="algo">
<p>
%~gamepad 用に
`各~buttonを初期化する@
ときは、次の手続きを走らす：
◎
To initialize buttons for a gamepad, run the following steps:
</p>
<ol>
	<li>
%装置 ~LET %~gamepad により表現される装置
◎
↓</li>
	<li>
%入力~個数 ~LET %~gamepad により表現される装置により公開される~button入力の個数
◎
Let inputCount be the number of button inputs exposed by the device represented by gamepad.
</li>
	<li>
%~gamepad.`buttonMinimums$sl ~SET 新たな`~list$
◎
↓</li>
	<li>
%~gamepad.`buttonMaximums$sl ~SET 新たな`~list$
◎
↓</li>
	<li>
<p>
~EACH( %~index ~IN { 0 〜 %入力~個数 ~MINUS 1 } )
に対し，昇順に：
</p>
		<ol>
			<li>
%~gamepad.`buttonMinimums$sl に次を`付加する$
⇒
%装置 の %~index 番の~button入力~用の最小な論理-値を与える `unsigned long$c 値
</li>
			<li>
%~gamepad.`buttonMaximums$sl に次を`付加する$
⇒
%装置 の %~index 番の~button入力~用の最大な論理-値を与える `unsigned long$ 値
</li>
		</ol>
◎
Set gamepad.[[buttonMinimums]] to be a list of unsigned long values with size equal to inputCount containing minimum logical values for each of the button inputs.
◎
Set gamepad.[[buttonMaximums]] to be a list of unsigned long values with size equal to inputCount containing maximum logical values for each of the button inputs.
</li>
	<li>
%~unmapped入力~index~list ~LET 空な`~list$
◎
Initialize unmappedInputList to be an empty list.
</li>
	<li>
%対応付けた~index~list ~LET 空な`~list$
◎
Initialize mappedIndexList to be an empty list.
</li>
	<li>
%~button~list~size ~LET 0
◎
Initialize buttonsSize to be 0.
</li>
	<li>
<p>
~EACH( %生の入力~index ~IN { 0 〜 %入力~個数 ~MINUS 1 })
に対し：
</p>
		<ol>
			<li>
%正準的~index ~LET %装置 の %生の入力~index 番の~button用の`正準的~index$
</li>
			<li>
<p>
~IF［
%正準的~index ~NEQ ε
］~AND［
%正準的~index ~NIN %対応付けた~index~list
］
</p>
				<ol>
					<li>
%~gamepad.`buttonMapping$sl[ %生の入力~index ] ~SET %正準的~index
◎
Set gamepad.[[buttonMapping]][rawInputIndex] to canonicalIndex.
</li>
					<li>
%対応付けた~index~list に %正準的~index を`付加する$
◎
Append canonicalIndex to mappedIndexList.
</li>
					<li>
~IF［
%正準的~index ~PLUS 1 ~GT %~button~list~size
］
⇒
%~button~list~size ~SET %正準的~index ~PLUS 1
◎
If canonicalIndex + 1 is greater than buttonsSize, then set buttonsSize to canonicalIndex + 1.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
⇒
%~unmapped入力~index~list に %生の入力~index を`付加する$
</p>
		</ol>

◎
For each rawInputIndex of the range from 0 to inputCount − 1:
• If the the gamepad button at index rawInputIndex represents a Standard Gamepad button:
•• Let canonicalIndex be the canonical index for the button.
•• If mappedIndexList contains canonicalIndex, then append rawInputIndex to unmappedInputList.
•• Otherwise:
••• Set gamepad.[[buttonMapping]][rawInputIndex] to canonicalIndex.
••• Append canonicalIndex to mappedIndexList.
••• If canonicalIndex + 1 is greater than buttonsSize, then set buttonsSize to canonicalIndex + 1.
• Otherwise, append rawInputIndex to unmappedInputList.
• Increment rawInputIndex.（意味不明
</li>
	<li>
%~button~index ~LET 0
◎
Initialize buttonIndex to be 0.
</li>
	<li>
<p>
%~unmapped入力~index~list を成す
~EACH( %生の入力~index )
に対し：
◎
For each rawInputIndex of unmappedInputList:
</p>
		<ol>
			<li>
~WHILE［
%~button~index ~IN %対応付けた~index~list
］
⇒
%~button~index ~INCBY 1
◎
While mappedIndexList contains buttonIndex:
• Increment buttonIndex.
</li>
			<li>
%~gamepad.`buttonMapping$sl[ %生の入力~index ] ~SET %~button~index
◎
Set gamepad.[[buttonMapping]][rawInputIndex] to buttonIndex.
</li>
			<li>
%対応付けた~index~list に %~button~index を`付加する$
◎
Append buttonIndex to mappedIndexList.
</li>
			<li>
~IF［
%~button~index ~PLUS 1 ~GT %~button~list~size
］
⇒
%~button~list~size ~SET %~button~index ~PLUS 1
◎
If buttonIndex + 1 is greater than buttonsSize, then set buttonsSize to buttonIndex + 1.
</li>
		</ol>
	</li>
	<li>
%~button~list ~LET 空な`~list$
◎
Initialize buttons to be an empty list.
</li>
	<li>
`範囲$ { 0 〜 %~button~list~size ~MINUS 1 } を成す
~EACH( %~button~index )
に対し
⇒
%~button~list に `新たな$ `GamepadButton$I を`付加する$
◎
For each buttonIndex of the range from 0 to buttonsSize − 1, append a new GamepadButton to buttons.
</li>
	<li>
~RET %~button~list
◎
Return buttons.
</li>
</ol>

		</div></section>
	</section>
	<section id="gamepadbutton-interface">
<h2 title="GamepadButton Interface">4. `GamepadButton^I ~interface</h2>

<p>
この~interfaceは、~gamepad装置~上の個々の~buttonの状態を定義する。
◎
This interface defines the state of an individual button on a gamepad device.
</p>

<pre class="idl">
[`Exposed$=Window, `SecureContext$]
interface `GamepadButton@I {
  readonly attribute `boolean$ `pressed$m;
  readonly attribute `boolean$ `touched$m;
  readonly attribute `double$ `value$m;
};
</pre>

<p>
`GamepadButton$I の各~instanceは、
次の表に述べる内部~slot群を伴って作成される：
◎
Instances of GamepadButton are created with the internal slots described in the following table:
</p>

<table><thead>
<tr><th>
内部~slot
◎
Internal slot
<th>
初期~値
◎
Initial value
<th>
記述 （規範的でない）
◎
Description (non-normative)
<tbody>

<tr><td>
`pressed@sl
<td>~F
<td>
当の~buttonは押されたかどうかを指示する~flag。
◎
A flag indicating that the button is pressed

<tr><td>
`touched@sl
<td>~F
<td>
当の~buttonは~touchされたかどうか指示する~flag。
◎
A flag indicating that the button is touched

<tr><td>
`value@sl
<td>0.0
<td>
当の~button値を表現する，
0.0 以上 1.0 以下に【！~scale】正規化された `double$c 値。
◎
A double representing the button value scaled to the range [0.0 .. 1.0]
</table>

<p>
`pressed@m
属性は：
◎
pressed attribute
</p>
<ul>
	<li>
~buttonが押されたかどうかの状態を指示する。
~buttonが現在~押されて［
いるならば~T／
いないならば ~F
］になるモノトスル。
◎
The pressed state of the button.＼
This property MUST be true if the button is currently pressed, and false if it is not pressed.＼
</li>
	<li>
~buttonのうち，［
押された状態, 放された状態
］どちらかのみを指示する~digital~switchを備えていないもの用には、
`~UA$は［
~buttonの値が一定量を上回るとき押されたもの
］と指示する，
`~button押圧~閾値@
を選ぶモノトスル。
`~UA$は、~platform~APIから閾値として推奨される値が与えられて［
いるならば それを利用する／
いないならば 他の何らかの適度な値を選ぶ
］ベキである。
◎
For buttons which do not have a digital switch to indicate a pure pressed or released state, the user agent MUST choose a button press threshold to indicate the button as pressed when its value is above a certain amount. If the platform API gives a recommended value, the user agent SHOULD use that. In other cases, the user agent SHOULD choose some other reasonable value.
</li>
	<li class="algo">
<p>
その取得子~手続きは
⇒
~RET コレ.`pressed$sl
◎
The pressed getter steps are:
• Return this.[[pressed]].
</li>
</ul>

<p>
`touched@m
属性は：
◎
touched attribute
</p>
<ul>
	<li>
<p>
~buttonが~touchされた状態を指示する。
この~propは、次に従って決定される値をとるモノトスル：
◎
The touched state of the button.＼
</p>
		<ol>
			<li>
当の~buttonには~touchを検出する能力はある場合
⇒
当の~buttonは現在~touchされて［
いるならば ~T ／
いないならば ~F
］
◎
If the button is capable of detecting touch, this property MUST be true if the button is currently being touched, and false otherwise.＼
</li>
			<li>
他の場合、当の~buttonには~analog値を報告する能力はある場合
⇒
コレの `value$m は［
0 でないならば ~T ／
0 ならば ~F
］
◎
If the button is not capable of detecting touch and is capable of reporting an analog value, this property MUST be true if the value property is greater than 0, and false if the value is 0.＼
</li>
			<li>
他の場合
⇒
コレの `pressed$m 属性の値
◎
If the button is not capable of detecting touch and can only report a digital value, this property MUST mirror the pressed attribute.
</li>
		</ol>
	</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ.`touched$sl
◎
The touched getter steps are:
• Return this.[[touched]].
</li>
</ul>

<p>
`value@m
属性は：
◎
value attribute
</p>
<ul>
	<li>
~buttonが~analog~sensorを備える場合、
押されている量【~~押圧など】を表現するモノトスル。
~button値は［
0.0 以上, 1.0 以下
］に線形に正規化し，［
0.0 ／ 1.0
］は全部的に［
押されていない／押されている
］ことを意味するモノトスル。
◎
For buttons that have an analog sensor, this property MUST represent the amount which the button has been pressed. All button values MUST be linearly normalized to the range [0.0 .. 1.0]. 0.0 MUST mean fully unpressed, and 1.0 MUST mean fully pressed.＼
</li>
	<li>
~buttonが~analog~sensorを備えない場合、
押されているかどうかに応じて，値［
0.0 ／ 1.0
］のみを供するモノトスル。
◎
For buttons without an analog sensor, only the values 0.0 and 1.0 for fully unpressed and fully pressed respectively, MUST be provided.
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ.`value$sl
◎
The value getter steps are:
• Return this.[[value]].
</li>
</ul>

	</section>
	<section id="gamepadmappingtype-enum">
<h2 title="GamepadMappingType enum">5. `GamepadMappingType^I 列挙</h2>

<p>
この列挙は、~Gamepad用の既知な対応付けからなる集合を定義する。
◎
This enum defines the set of known mappings for a Gamepad.
</p>

<pre class="idl">
enum `GamepadMappingType@I {
  <a href="#dom-gamepadmappingtype-the-empty-string">""</a>,
  `standard$l,
  `xr-standard$l,
};
</pre>

<dl class="idl-def">
	<dt id="dom-gamepadmappingtype-the-empty-string">""</dt>
	<dd>
空~文字列は、この~gamepad用に利用-中にある対応付けは無いことを指示する。
◎
The empty string indicates that no mapping is in use for this gamepad.
</dd>

	<dt id="dfn-standard">`standard@l</dt>
	<dd>
~gamepadを成す各~controlは、`標準~gamepad$の~layoutに対応付けられている。
◎
The Gamepad's controls have been mapped to the Standard Gamepad layout.
</dd>

	<dt id="dfn-xr-standard">`xr-standard@l</dt>
	<dd>
~gamepadを成す各~controlは、
<a href="~XRGAMEPAD#xr-standard-gamepad-mapping">`xr-standard^l ~gamepad対応付け</a>
に対応付けられている。
この対応付けは、
<a href="~XRGAMEPAD">`~WebXR~gamepad~module^cite</a>【！~level 1】
の利用~用に予約されている。
`getGamepads()$m が返す値を成す各 `Gamepad$I は、
`xr-standard^l の対応付けを報告してはナラナイ。
◎
The Gamepad's controls have been mapped to the "xr-standard" gamepad mapping. This mapping is reserved for use by the WebXR Gamepads Module - Level 1. Gamepads returned by getGamepads() MUST NOT report a mapping of "xr-standard".
</dd>
</dl>

	</section>
	<section id="extensions-to-the-navigator-interface">
<h2 title="Extensions to the Navigator interface">6. `Navigator^I ~interfaceに対する拡張</h2>

<pre class="idl">
[`Exposed$=Window]
partial interface `Navigator$I {
  `sequence$&lt;`Gamepad$I?&gt; `getGamepads$m();
};
</pre>

<p>
`Navigator$I の各~instanceは、
次の表に述べる内部~slot群を伴って作成される：
◎
Instances of Navigator are created with the internal slots described in the following table:
</p>

<table><thead>
<tr><th>
内部~slot
◎
Internal slot
<th>
初期~値
◎
Initial value
<th>
記述 （規範的でない）
◎
Description (non-normative)
<tbody>

<tr><td>`hasGamepadGesture@sl
<td>~F
<td>
`~gamepad利用者~gesture$は観測されたかどうかを指示する~flag。
◎
A flag indicating that a gamepad user gesture has been observed

<tr><td>
`gamepads@sl
<td>
空な`連列$
◎
[]
<td>
一連の［
`Gamepad$I ／ ~NULL
］からなる`連列$
— この %連列 を成す各 `Gamepad$I %~gamepad は、次を満たすことになる
⇒
%連列[ %~gamepad の `index$m 属性 ] ~EQ %~gamepad
◎
A sequence&lt;Gamepad?&gt; with each Gamepad present at the index specified by its index attribute, or null for unassigned indices.
</table>

		<section id="getgamepads-method">
<h3 title="getGamepads() method">6.1. `getGamepads()@m ~method</h3>

<p class="note">注記：
この~methodが返す~gamepad状態は、［
`gamepaddisconnected$et ／ `gamepadconnected$et
］~eventが発火されるまで，切断か接続かを反映しない。
◎
The gamepad state returned from getGamepads() does not reflect disconnection or connection until after the gamepaddisconnected or gamepadconnected events have fired.
</p>

<p class="note">注記：
指紋収集を軽減するため、
`getGamepads()$m が返す`連列$を成す~gamepadは、［
`~gamepad利用者~gesture$が一回以上は生じたもの
］に限られる。
`FINGERPRINTING-GUIDANCE$r
◎
To mitigate fingerprinting, getGamepads() returns an empty list before a gamepad user gesture has been seen. [FINGERPRINTING-GUIDANCE]
</p>

<div class="example" id="example-1">
<p>
`getGamepads()$m は、［
現在，接続されていて, ヤリトリしている各~gamepad用の~data
］が成す~snapshotを返す。
ある~gamepad %~gamepad が接続されなくなったときは、
この~methodが返す連列を成す［
%~gamepad の~index
］番の~itemは ~NULL になるべきである。
次の~code片にて、［
接続された~gamepadが 1 個だけあって，その~index ~EQ 1 の場合
］に期待される挙動を述べる：
◎
Example 1
getGamepads() returns a snapshot of the data for the currently connected and interacted-with gamepads. When a gamepad is no longer connected, its index in the array should return null. If there is one connected gamepad with an index of 1, then the following code snippet describes the expected behavior:
</p>

<pre class="lang-js">/* <span class="comment">
%gamepads は `[null, [object Gamepad]]^c の様になるベキである。
◎
gamepads should look like [null, [object Gamepad]]
</span> */
var %gamepads = navigator.getGamepads();
/* <span class="comment">
次のどの言明も， ~T に評価されるべきである：
◎
The following statements should all evaluate to true.
</span> */
%gamepads[0] == null;
%gamepads[1].index == 1;
%gamepads.length == 2;
</pre>
</div>

<div class="algo">
<p>
`getGamepads()$m ~method手続きは：
◎
The getGamepads() method steps are:
</p>
<ol>
	<li>
%文書 ~LET `現在の大域~obj$に`結付けられている文書$
◎
Let doc be the current global object's associated Document. 
</li>
	<li>
~IF［
%文書 ~EQ ~NULL
］~OR［
%文書 は`全部的に作動中$でない
］
⇒
~RET 空な`~list$
◎
If doc is null or doc is not fully active, then return an empty list.
</li>
	<li>
~IF［
%文書 には `gamepad$l 特能【！permission】の`利用は許容されて$いない
］
⇒
~THROW `SecurityError$E
◎
If doc is not allowed to use the "gamepad" permission, then throw a "SecurityError" DOMException and abort these steps.
</li>
	<li>
~IF［
コレ.`hasGamepadGesture$sl ~EQ ~F
］
⇒
~RET 空な`~list$
◎
If this.[[hasGamepadGesture]] is false, then return an empty list.
</li>
	<li>
%今 ~LET `現在の高分解能~時刻$
◎
Let now be the current high resolution time.
</li>
	<li>
<p>
コレ.`gamepads$sl を成す
~EACH( %~gamepad )
に対し：
◎
For each gamepad of this.[[gamepads]]:
</p>
		<ol>
			<li>
<p>
~IF［
%~gamepad ~NEQ ~NULL
］~AND［
%~gamepad.`exposed$sl ~EQ ~F
］：
◎
If gamepad is not null and gamepad.[[exposed]] is false:
</p>
				<ol>
					<li>
%~gamepad.`exposed$sl ~SET ~T
◎
Set gamepad.[[exposed]] to true.
</li>
					<li>
%~gamepad.`timestamp$sl ~SET %今
◎
Set gamepad.[[timestamp]] to now.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET コレ.`gamepads$sl【！gamepads】
◎
Return gamepads.
</li>
</ol>
</div>

<p>
%~gamepad は、［
現在の入力~状態は、利用者は当の~gamepadと現在ヤリトリしていることを指示する
］ならば
`~gamepad利用者~gestureを包含する@
とされる。
`~UA$は［
当の入力~状態が ある~gamepad利用者~gestureを包含するかどうか
］を検査する~algoを供するモノトスル：
◎
A gamepad contains a gamepad user gesture if the current input state indicates that the user is currently interacting with the gamepad.＼
The user agent MUST provide an algorithm to check if the input state contains a gamepad user gesture.＼
</p>
<ul>
	<li>
次に該当する~buttonにおける `pressed$m 値 ~T は、ヤリトリと見なされるベキである
⇒
中立な既定の値を~supportしていて†、
`pressed$m 値 ~F を 1 回でも報告したもの。
【† 利用者がヤリトリしていない間は、放された状態（ ~F ）になるもの。】
◎
For buttons that support a neutral default value and have reported a pressed value of false at least once, a pressed value of true SHOULD be considered interaction.＼
</li>
	<li>
<p>
次のいずれかに該当する~buttonにおける `pressed$m 値 ~T は、ヤリトリと見なされるベキでない：
</p>
		<ul>
			<li>
中立な既定の値を~supportしないもの（例えば，~toggle~switch ）
【利用者がヤリトリしていなくても、押された状態／放された状態が持続するもの。】
</li>
			<li>
`pressed$m 値 ~F を 1 回も報告していないもの
</li>
		</ul>
◎
If a button does not support a neutral default value (for example, a toggle switch), then a pressed value of true SHOULD NOT be considered interaction. If a button has never reported a pressed value of false then it SHOULD NOT be considered interaction.＼
</li>
	<li>
軸の運動は、次が満たされるならば，ヤリトリと見なされるベキである
⇒
［
当の軸は中立な既定の値を~supportする
］~AND［
中立からの現在の変位は`~UA$が選んだ閾値を超える
］~AND［
当の軸は， 1 回は閾値を下回る値を報告した
］
◎
Axis movements SHOULD be considered interaction if the axis supports a neutral default value, the current displacement from neutral is greater than a threshold chosen by the user agent, and the axis has reported a value below the threshold at least once.＼
</li>
	<li>
<p>
次のいずれかに該当する軸は、ヤリトリの有無を検査する際に考慮しないベキである：
</p>
		<ul>
			<li>
中立な既定の値を~supportしないもの
（例：~joystick用の軸であって `self-center^en でないもの【中心に戻らないもの】）
</li>
			<li>
閾値を下回る値を 1 回も報告していないもの
</li>
		</ul>
<p>
軸~gesture用の閾値は、［
~randomな揺らぎはヤリトリと見なされないような，十分な大きさ
］にするベキである。
</p>
◎
If an axis does not support a neutral default value (for example, an axis for a joystick that does not self-center), or an axis has never reported a value below the axis gesture threshold, then the axis SHOULD NOT be considered when checking for interaction.＼
The axis gesture threshold SHOULD be large enough that random jitter is not considered interaction.
</li>
</ul>

		</section>
	</section>
	<section id="gamepadevent-interface">
<h2 title="GamepadEvent Interface">7. `GamepadEvent^I ~interface</h2>

<pre class="idl">
[`Exposed$=Window, `SecureContext$]
interface `GamepadEvent@I: `Event$I {
  `constructor$(`DOMString$ %type, `GamepadEventInit$I %eventInitDict);
  [`SameObject$] readonly attribute `Gamepad$I `gamepad$m;
};
</pre>

<p>
`gamepad@m
属性は、この~event用に結付けらている~gamepad~dataへの~accessを供する。
◎
gamepad
• The gamepad attribute provides access to the associated gamepad data for this event.
</p>

		<section id="gamepadeventinit-dictionary">
<h3 title="GamepadEventInit dictionary">7.1. `GamepadEventInit^I 辞書</h3>

<pre class="idl">
dictionary `GamepadEventInit@I : `EventInit$I {
  required `Gamepad$I `gamepad$mb;
};
</pre>

<p>
`gamepad@mb
~memberは、当の~eventに結付けられる `Gamepad$I を与える。
◎
gamepad member
• The gamepad associated with this event.
</p>

		</section>
	</section>
	<section id="remapping">
<h2 title="Remapping">8. 対応付直法</h2>

<p>
各~装置の製造元は、多くの異なる製品を作成する
— そのそれぞれが、［
~button／軸
］の［
~style, ~layout
］として~~固有のものを備える。
`~UA$は、これらのうち，アリな限り多くを~supportするものと意図される。
◎
Each device manufacturer creates many different products and each has unique styles and layouts of buttons and axes. It is intended that the user agent support as many of these as possible.
</p>

<p>
加えて、~game~consoleにより~~普及し，`事実上の標準^emになった~layoutがある。
`~UA$は、装着された装置を認識するときは，［
アリなときは，正準的な順序付けへ対応付直す／
認識できない装置であっても，生の形で公開する
］ことが推奨される。
◎
Additionally there are de facto standard layouts that have been made popular by game consoles. When the user agent recognizes the attached device, it is RECOMMENDED that it be remapped to a canonical ordering when possible. Devices that are not recognized should still be exposed in their raw form.
</p>

<p>
正準的な~layoutは、現時点では
`標準~gamepad@
（ `Standard Gamepad^en ）
1 つしかない。
対応付直すときは、［
`axes$m, `buttons$m
］内の各~indexは，
下に与える図式における物理的な所在にアリな限り近く対応するベキである。
加えて、 `mapping$m を `standard$l に設定するベキである。
◎
There is currently one canonical layout, the Standard Gamepad. When remapping, the indices in axes and buttons should correspond as closely as possible to the physical locations in the diagram below. Additionally, mapping SHOULD be set to "standard".
</p>

<p>
`標準~gamepad$を成す各~buttonは、次に挙げるものに~lay-outされる：
◎
The Standard Gamepad buttons are laid out in＼
</p>
<ul>
	<li>
左~clusterを成す 4 個の~button
◎
a left cluster of four buttons,＼
</li>
	<li>
右~clusterを成す 4 個の~button
◎
a right cluster of four buttons,＼
</li>
	<li>
中央~clusterを成す 3 個の~button
◎
a center cluster of three buttons,＼
</li>
	<li>
~gamepadの~~前方に面した【利用者から見て奥側】, 左右各側に 2 個ずつある~button
◎
and a pair of front facing buttons on the left and right side of the gamepad.＼
</li>
</ul>

<p>
`標準~gamepad$を成す 4 個の軸は、
左右各側にある~analog~stickに 2 軸ずつ結付けられる。
◎
The four axes of the "Standard Gamepad" are associated with a pair of analog sticks, one on the left and one on the right.＼
</p>

<p>
下の表に、`標準~gamepad$を成す各［
~button ／ 軸
］, その物理的な所在を述べる。
◎
The following table describes the buttons/axes and their physical locations.
</p>

<p>
所与の［
軸／~button
］入力の
`正準的~index@
は、当の［
軸／~button
］が`標準~gamepad$の ある［
軸／~button
］を “表現する” ならば，後者の［
軸／~button
］の~index（下の表を見よ）、
他の場合は ε とする†。
ここでの “表現する” かどうかは、次に従う：
◎
↓</p>
<ul>
	<li>
<p>
軸~入力は、次を満たすならば，
`標準~gamepad軸を表現する@
とされる
⇒
ある~thumbstick軸【すなわち，物理的な~stick】用の入力~値を報告していて、［
当の~thumbstickの所在は，対応している`標準~gamepad$の ある軸とほぼ同じである（下の図）
］かつ［
当の軸の方位（上下／左右）は`標準~gamepad$の軸の方位に合致する
］
</p>

<p>
`標準~gamepad$の同じ軸を表現する軸が複数ある場合、`~UA$は，［
それらのうち一つを`標準~gamepad$の軸として選定した上で，
他の軸には異なる~indexをアテガう
］ベキである。
◎
An axis input represents a Standard Gamepad axis if it reports the input value for a thumbstick axis, the thumbstick is located in approximately the same location as the corresponding Standard Gamepad thumbstick, and the orientation of the axis (up-down or left-right) matches the orientation of the Standard Gamepad axis. If there are multiple axes that represent the same Standard Gamepad axis, then the user agent SHOULD select one to be the Standard Gamepad axis and assign a different index to the other axis.
</li>
	<li>
<p>
~button入力は、次を満たすならば
`標準~gamepad~buttonを表現する@
とされる
⇒
ある~button（あるいは引金）用の入力~値を報告していて，
当の~buttonの所在は、対応する`標準~gamepad$の ある~buttonとほぼ同じである（下の図）。
◎
A button input represents a Standard Gamepad button if it reports the input value for a button or trigger, and the button or trigger is located in approximately the same location as the corresponding Standard Gamepad button.
◎
↑If an axis or button input represents a Standard Gamepad axis or button, then its canonical index is the index of the corresponding Standard Gamepad axis or button.
</li>
</ul>

<p class="trans-note">【†
“他の場合は ε” は、他所を簡潔に述べるための，この訳による追加。
】</p>


<div>
<table><thead>
<tr><th>~button／軸
<th>所在
<tbody>

<tr><td>`buttons[0]^c
<td>右~cluster内の下~button

<tr><td>`buttons[1]^c
<td>右~cluster内の右~button

<tr><td>`buttons[2]^c
<td>右~cluster内の左~button

<tr><td>`buttons[3]^c
<td>右~cluster内の上~button

<tr><td>`buttons[4]^c
<td>前面~左上~button

<tr><td>`buttons[5]^c
<td>前面~右上~button

<tr><td>`buttons[6]^c
<td>前面~左下~button

<tr><td>`buttons[7]^c
<td>前面~右下~button

<tr><td>`buttons[8]^c
<td>中央~cluster内の左~button（ “select” ／ “back” ）

<tr><td>`buttons[9]^c
<td>中央~cluster内の右~button（ “start” ／ “forward” ）

<tr><td>`buttons[10]^c
<td>左~stickに一体化された~button

<tr><td>`buttons[11]^c
<td>右~stickに一体化された~button

<tr><td>`buttons[12]^c
<td>左~cluster内の上~button

<tr><td>`buttons[13]^c
<td>左~cluster内の下~button

<tr><td>`buttons[14]^c
<td>左~cluster内の左~button

<tr><td>`buttons[15]^c
<td>左~cluster内の右~button

<tr><td>`buttons[16]^c
<td>中央~cluster内の中央~button

<tr><td>`axes[0]^c
<td>左~stick用の水平-軸（左側は負／右側は正）

<tr><td>`axes[1]^c
<td>左~stick用の垂直-軸（上側は負／下側は正）

<tr><td>`axes[2]^c
<td>右~stick用の水平-軸（左側は負／右側は正）

<tr><td>`axes[3]^c
<td>右~stick用の垂直-軸（上側は負／下側は正）
</table>

◎
buttons[0] 	Bottom button in right cluster
buttons[1] 	Right button in right cluster
buttons[2] 	Left button in right cluster
buttons[3] 	Top button in right cluster
buttons[4] 	Top left front button
buttons[5] 	Top right front button
buttons[6] 	Bottom left front button
buttons[7] 	Bottom right front button
buttons[8] 	Left button in center cluster
buttons[9] 	Right button in center cluster
buttons[10] 	Left stick pressed button
buttons[11] 	Right stick pressed button
buttons[12] 	Top button in left cluster
buttons[13] 	Bottom button in left cluster
buttons[14] 	Left button in left cluster
buttons[15] 	Right button in left cluster
buttons[16] 	Center button in center cluster
axes[0] 	Horizontal axis for left stick (negative left/positive right)
axes[1] 	Vertical axis for left stick (negative up/positive down)
axes[2] 	Horizontal axis for right stick (negative left/positive right)
axes[3] 	Vertical axis for right stick (negative up/positive down) 
</div>

<figure id="fig-visual-representation-of-a-standard-gamepad-layout">
<figcaption id="_dgm-standard_gamepad">
`標準~gamepad$の~layoutの視覚的な表現。
角括弧付き~~数字は、~button~index。
丸囲み~~数字は、軸~index
— 黒塗り（白抜き）は負側／その逆塗りは正側。
◎
Figure 1
Visual representation of a Standard Gamepad layout.
</figcaption></figure>

		<section id="fingerprinting-mitigation">
<h3 title="Fingerprinting mitigation">8.1. 指紋収集の軽減</h3>

<p>
`Gamepad$I ~objの能力を検分することは、
能動的な指紋収集の手段として利用され得る。
~UAは、
~APIを通して公開される装置~情報を，指紋収集~表口を抑制するよう改めてもヨイ。
例えば，実装は、
`Gamepad$I ~objが有する［
~button, 軸
］の個数を`標準~gamepad$の~layoutにて定義されるものと正確に同じにするよう要求できる
— 当の接続された装置に在る入力は，もっと［
多い／少ない
］場合でも。
`FINGERPRINTING-GUIDANCE$r
◎
Inspecting the capabilities of Gamepad objects can be used as a means of active fingerprinting. The user agent MAY alter the device information exposed through the API to reduce the fingerprinting surface. As an example, an implementation can require that a Gamepad object have exactly the number of buttons and axes defined in the Standard Gamepad layout even if more or fewer inputs are present on the connected device. [FINGERPRINTING-GUIDANCE]
</p>

		</section>
	</section>
	<section id="usage-examples">
<h2 title="Usage Examples">9. 用法~例</h2>

◎非規範的

<div class="example" id="example-2">

<p>
代表的な~gamepadへの~accessを，次の例にデモる。
`requestAnimationFrame()$m ~methodとの関係性に注意。
◎
The example below demonstrates typical access to gamepads. Note the relationship with the requestAnimationFrame() method.
◎
Example 2
</p>

<pre class="lang-js">function %runAnimation() {
    window.requestAnimationFrame(%runAnimation);
    for (const %pad of navigator.getGamepads()) {
      /* <span class="issue comment">
%pad`.axes^c, %pad`.buttons^c を表示する単純なデモをここに記す
◎
todo; simple demo of displaying pad.axes and pad.buttons
</span> */
      console.log(%pad);
    }
}

window.requestAnimationFrame(%runAnimation);
</pre>
</div>

<div class="practice advisement" id="practice-timing">
<p>
最善な実施：
`requestAnimationFrame()^m との協調
◎
Best Practice 1： Coordination with requestAnimationFrame()
</p>
<p class="practicedesc">
`requestAnimationFrame()$m ~methodを利用している対話的な~appは、
概して，~animationを駆動して，~animationを利用者の~gamepad入力と協調したいと求めることになる。
そのようなわけで，~gamepad~dataは、
アリな限り~animation~callbackが実行される直前近くに~pollして，
~animationの更新周期に合致させるベキである。
すなわち，~animation~callbackが 60Hz で稼働しているなら、
~gamepad入力も，その~rateで標本化されるベキである。
◎
Interactive applications will typically be using the requestAnimationFrame() method to drive animation, and will want coordinate animation with user gamepad input. As such, the gamepad data should be polled as closely as possible to immediately before the animation callbacks are executed, and with frequency matching that of the animation. That is, if the animation callbacks are running at 60Hz, the gamepad inputs should also be sampled at that rate.
</p>
</div>

	</section>
	<section id="the-gamepadconnected-event">
<h2 id="event-gamepadconnected" title="The gamepadconnected event">10. `gamepadconnected@et ~event</h2>

<div class="algo">
<p>
ある~gamepad装置 %~gamepad装置 が~system上で可用になったときは、次の手続きを走らす：
◎
When a gamepad becomes available on the system, run the following steps:
</p>
<ol>
	<li>
%文書 ~LET `現在の大域~obj$に`結付けられている文書$
— 他の場合【？】は ~NULL
◎
Let document be the current global object's associated Document; otherwise null.
</li>
	<li>
~IF［
%文書 ~NEQ ~NULL
］~AND［
%文書 には `gamepad$l 特能【！permission】の`利用は許容されて$いない
］
⇒
~RET
◎
If document is not null and is not allowed to use the "gamepad" permission, then abort these steps.
</li>
	<li>
<p>
次の手続きを遂行する`~taskを~queueする$( `~gamepad~task源$ )：
◎
Queue a task on the gamepad task source to perform the following steps:
</p>
		<ol>
			<li>
%~gamepad ~LET %~gamepad装置 を表現している`新たな~gamepad$()
◎
Let gamepad be a new Gamepad representing the gamepad.
</li>
			<li>
%~navigator ~LET %~gamepad に`関連な大域~obj$に`結付けられている~Navigator$
◎
Let navigator be gamepad's relevant global object's Navigator object.
</li>
			<li>
%~navigator.`gamepads$sl[ %~gamepad.`index$m ] ~SET %~gamepad
◎
Set navigator.[[gamepads]][gamepad.index] to gamepad.
</li>
			<li>
<p>
~IF［
%~navigator.`hasGamepadGesture$sl ~EQ ~T
］：
◎
If navigator.[[hasGamepadGesture]] is true:
</p>
				<ol>
					<li>
%~gamepad.`exposed$sl ~SET ~T
◎
Set gamepad.[[exposed]] to true.
</li>
					<li>
~IF［
%文書 ~NEQ ~NULL
］~AND［
%文書 は`全部的に作動中$である
］
⇒
`~eventを発火する$( %~gamepad に`関連な大域~obj$, `gamepadconnected$et, `GamepadEvent$I )
— 次のように初期化して
⇒
`gamepad$m 属性 ~SET %~gamepad
◎
If document is not null and is fully active, then fire an event named gamepadconnected at gamepad's relevant global object using GamepadEvent with its gamepad attribute initialized to gamepad.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

<p>
この仕様を実装している~UAは、
`gamepadconnected$et と命名される新たな~DOM~eventを供するモノトスル。
対応する~eventは、［
`GamepadEvent$I ~interfaceを利用する, および
`Window$I ~objに向けて発火する
］モノトスル。
◎
User agents implementing this specification must provide a new DOM event, named gamepadconnected. The corresponding event MUST be of type GamepadEvent and MUST fire on the Window object.
</p>

<p>
`~UA$は，利用者が~gamepadを接続したときは、
`gamepadconnected$et ~eventを配送して，それを指示するモノトスル。
~pageが読込まれた時点で，~gamepadはすでに接続されていた場合、
利用者が~buttonを押すか軸を動かしたとき，この~eventを配送するベキである。
◎
A user agent MUST dispatch this event type to indicate the user has connected a gamepad. If a gamepad was already connected when the page was loaded, the gamepadconnected event SHOULD be dispatched when the user presses a button or moves an axis.
</p>

	</section>
	<section id="the-gamepaddisconnected-event">
<h2 id="event-gamepaddisconnected" title="The gamepaddisconnected event">11. `gamepaddisconnected@et ~event</h2>

<div class="algo">
<p>
ある~gamepadが~system上で可用でなくなったときは、次の手続きを走らす：
◎
When a gamepad becomes unavailable on the system, run the following steps:
</p>
<ol>
	<li>
%~gamepad ~LET 可用でなくなった装置を表現している `Gamepad$I
◎
Let gamepad be the Gamepad representing the unavailable device.
</li>
	<li>
<p>
次の手続きを遂行する`~taskを~queueする$( `~gamepad~task源$ )：
◎
Queue a task on the gamepad task source to perform the following steps:
</p>
		<ol>
			<li>
%~gamepad.`connected$sl ~SET ~F
◎
Set gamepad.[[connected]] to false.
</li>
			<li>
%文書 ~LET %~gamepad に`関連な大域~obj$に`結付けられている文書$
— 他の場合【？】は ~NULL
◎
Let document be gamepad's relevant global object's associated Document; otherwise null.
</li>
			<li>
~IF［
%~gamepad.`exposed$sl ~EQ ~T
］~AND［
%文書 ~NEQ ~NULL
］~AND［
%文書 は`全部的に作動中$である
］
⇒
`~eventを発火する$( %~gamepad に`関連な大域~obj$, `gamepaddisconnected$et, `GamepadEvent$I )
— 次のように初期化して
⇒
`gamepad$m 属性 ~SET %~gamepad
◎
If gamepad.[[exposed]] is true and document is not null and is fully active, then fire an event named gamepaddisconnected at gamepad's relevant global object using GamepadEvent with its gamepad attribute initialized to gamepad.
</li>
			<li>
%~navigator ~LET %~gamepad に`関連な大域~obj$に`結付けられている~Navigator$
◎
Let navigator be gamepad's relevant global object's Navigator object.
</li>
			<li>
%~navigator.`gamepads$sl[ %~gamepad.`index$m ] ~SET ~NULL
◎
Set navigator.[[gamepads]][gamepad.index] to null.
</li>
			<li>
~WHILE［
%~navigator.`gamepads$sl は`空$でない
］~AND［
%~navigator.`gamepads$sl を成す最後の`~item$ ~EQ ~NULL
］
⇒
%~navigator.`gamepads$sl から最後の`~item$を`除去する$
◎
While navigator.[[gamepads]] is not empty and the last item of navigator.[[gamepads]] is null, remove the last item of navigator.[[gamepads]].
</li>
		</ol>
	</li>
</ol>
</div>

<p>
この仕様を実装している~UAは、
`gamepaddisconnected$et と命名される新たな~DOM~eventを供するモノトスル。
対応する~eventは、［
`GamepadEvent$I ~interfaceを利用する, および
`Window$I ~objに向けて発火する
］モノトスル。
◎
User agents implementing this specification must provide a new DOM event, named gamepaddisconnected. The corresponding event MUST be of type GamepadEvent and MUST fire on the Window object.
</p>

<p>
`~UA$は，~gamepadが切断されたときは、［
以前に，その~gamepad用の `gamepadconnected$et ~eventを `Window$I に向けて配送していた
］ならば，同じ `Window$I に向けて `gamepaddisconnected$et ~eventを配送するモノトスル。
◎
When a gamepad is disconnected from the user agent, if the user agent has previously dispatched a gamepadconnected event for that gamepad to a Window, a gamepaddisconnected event MUST be dispatched to that same Window.
</p>

	</section>
	<section id="other-events">
<h2 title="Other events">12. 他の~event</h2>

<p>
軸や~buttonの変化-用の~eventも含めるかどうか，もっと論が必要である。
含める場合、それらを一緒に転がすか（ `gamepadchanged^et ？），または［
多少，あるいは［
軸／~button
］ごとに個別に
］分離するか（ `gamepadaxischanged^et ？）についても。
◎
More discussion needed, on whether to include or exclude axis and button changed events, and whether to roll them more together ("gamepadchanged"?), separate somewhat ("gamepadaxischanged"?), or separate by individual axis and button.
</p>

	</section>
	<section id="extensions-to-the-windoweventhandlers-interface-mixin">
<h2 title="Extensions to the WindowEventHandlers Interface Mixin">13. `WindowEventHandlers^I ~interface~mixinに対する拡張</h2>

<p>
この仕様は、~HTMLの `WindowEventHandlers$I ~interface~mixinを拡張して，
~event~handlerの登録を手助けするための`~event~handler~IDL属性$を追加する。
◎
This specification extends the WindowEventHandlers interface mixin from HTML to add event handler IDL attributes to facilitate the event handler registration.
</p>

<pre class="idl">
partial interface mixin `WindowEventHandlers$I {
  attribute `EventHandler$I `ongamepadconnected@m;
  attribute `EventHandler$I `ongamepaddisconnected@m;
};
</pre>

<p class="trans-note">【
名前から明らかなように、順に［
`gamepadconnected$et, `gamepaddisconnected$et
］~event用。
】</p>

	</section>
	<section id="permission-policy">
<h2 title="Integration with Permissions Policy">14. 許可~施策との統合</h2>

<p>
この仕様は、文字列
`gamepad@l
で識別される`施策により制御される特能$を定義する。
その`既定の許容list$は、 `'self'^l とする。
◎
This specification defines a policy-controlled feature identified by the string "gamepad". Its default allowlist is 'self'.
</p>

<p class="note">注記：
`文書$ %文書 の`許可~施策$docは、［
%文書 内の内容には、 `getGamepads()$m への~accessは許容されるかどうか
］を決定する。
%文書 内で不能化された場合、 %文書 内のどの内容にも
`getGamepads()$m の`利用は許容され$ないことに加え，［
`gamepadconnected$et ／ `gamepaddisconnected$et
］~eventは発火されない。
◎
Note
A document’s permissions policy determines whether any content in that document is allowed to access getGamepads(). If disabled in any document, no content in the document will be allowed to use getGamepads(), nor will the gamepadconnected and gamepaddisconnected events fire.
</p>

	</section>
	<section id="a-acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

◎非規範的

<p>
この文書の開発に貢献された次に挙げる方々に：
◎
The following people contributed to the development of this document.
</p>

<ul lang="en">
<li>David Humphrey
<li>Gregg Tavares
<li>Marcin Wichary
<li>Jason Orendorff
<li>Olli Pettay
<li>Rick Waldron
<li><a href="https://github.com/anssiko">Anssi Kostiainen</a>
<li><a href="https://github.com/AFBarstow">Arthur Barstow</a>
<li><a href="https://github.com/autokagami">autokagami</a>
<li><a href="https://github.com/toji">Brandon Jones</a>
<li><a href="https://github.com/cwilso">Chris Wilson</a>
<li><a href="https://github.com/cvan">Christopher Robert Van Wiemeersch</a>
<li><a href="https://github.com/ddorwin">ddorwin</a>
<li><a href="https://github.com/fernando-80">fernando-80</a>
<li><a href="https://github.com/fernando-sony">fernando-sony</a>
<li><a href="https://github.com/JamesHollyer">James</a>
<li><a href="https://github.com/Johanna-hub">Johanna</a>
<li><a href="https://github.com/saschanaz">Kagami Sascha Rosylight</a>
<li><a href="https://github.com/kri">Kai Riemann</a>
<li><a href="https://github.com/knyg">Kelvin Yong</a>
<li><a href="https://github.com/marcoscaceres">Marcos Cáceres</a>
<li><a href="https://github.com/mkeblx">Michael Blix</a>
<li><a href="https://github.com/foolip">Philip Jägenstedt</a>
<li><a href="https://github.com/plehegar">Philippe Le Hegaret</a>
<li><a href="https://github.com/rakuco">Raphael Kubo da Costa</a>
<li><a href="https://github.com/sgraham">Scott Graham</a>
<li><a href="https://github.com/sidvishnoi">Sid Vishnoi</a>
<li><a href="https://github.com/niedzielski">Stephen Niedzielski</a>
<li><a href="https://github.com/luser">Ted Mielczarek</a>
<li><a href="https://github.com/scheib">Vincent Scheib</a>
<li><a href="https://github.com/siusin">Xiaoqian Wu</a>
<li><a href="https://github.com/ylafon">Yves Lafon</a>
</ul>

	</section>
</main></div>
