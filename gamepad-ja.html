<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Gamepad （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
table {
	border-style: hidden hidden none hidden;
}

table thead {
	border-bottom: medium solid var(--table-rule-color);
}

table td, table th {
	border: solid thin var(--table-rule-color);
	border-top: none;
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'm' :
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options
spec_title:Gamepad
spec_date:2025-02-14
trans_update:2025-02-18
source_checked:240124
page_state_key:UIEVENTS
original_url:https://w3c.github.io/gamepad/
	abbr_url:GAMEPAD
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
conformance:w3c
copyright:2024,permissive
trans_1st_pub:2019-07-08

●●class_map
E:error
et:event-type
e:element
sl:js-slot

●●tag_map
c:code
I:code
E:code
m:code
mb:code
sl:span
et:code
e:code
i:i
cite:cite
V:var

●●original_id_map

●●mdn_urls
dom-gamepad:API/Gamepad
dom-gamepadbutton:API/GamepadButton
dom-gamepadevent:API/GamepadEvent
	dom-gamepadeventinit:API/GamepadEventInit
	dom-gamepadmappingtype:API/GamepadMappingType

dfn-gamepadconnected:API/Window/gamepadconnected_event
dfn-gamepaddisconnected:API/Window/gamepaddisconnected_event

●●link_map

Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject

boolean:~WEBIDL#idl-boolean
long:~WEBIDL#idl-long
octet:~WEBIDL#idl-octet
unsigned long:~WEBIDL#idl-unsigned-long
unsigned long long:~WEBIDL#idl-unsigned-long-long
double:~WEBIDL#idl-double
sequence:~WEBIDL#idl-sequence
Promise:~WEBIDL#idl-promise

c.unsigned long:~WEBIDL#idl-unsigned-long
c.double:~WEBIDL#idl-double

連列:~WEBIDL#idl-sequence
DOMString:~WEBIDL#idl-DOMString
FrozenArray:~WEBIDL#idl-frozen-array

E.TypeError:~WEBIDL#exceptiondef-typeerror
E.SecurityError:~WEBIDL#securityerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotSupportedError:~WEBIDL#notsupportederror

I.Gamepad:#dom-gamepad
I.GamepadButton:#dom-gamepadbutton
I.GamepadEvent:#dom-gamepadevent
I.GamepadEventInit:#dom-gamepadeventinit
I.GamepadMappingType:#dom-gamepadmappingtype
I.GamepadHapticActuator:#dom-gamepadhapticactuator
I.GamepadEffectParameters:#dom-gamepadeffectparameters
I.GamepadHapticEffectType:#dom-gamepadhapticeffecttype
I.GamepadHapticsResult:#dom-gamepadhapticsresult
I.GamepadTouch:#dom-gamepadtouch

	I.DOMException:~WEBIDL#idl-DOMException
I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
I.EventHandler:~WAPI#eventhandler
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp

I.Navigator:~HTMLnavigator#navigator
	I.Navigator:#dom-navigator
I.Window:~WINDOW#window
I.WindowEventHandlers:~WAPI#windoweventhandlers

I.DOMPointReadOnly:~GEOMETRY#dompointreadonly
I.DOMRectReadOnly:~GEOMETRY#domrectreadonly

m.axes:#dom-gamepad-axes
m.buttons:#dom-gamepad-buttons
m.connected:#dom-gamepad-connected
m.id:#dom-gamepad-id
m.index:#dom-gamepad-index
m.mapping:#dom-gamepad-mapping
m.timestamp:#dom-gamepad-timestamp
m.touches:#dom-gamepad-touches
m.vibrationActuator:#dom-gamepad-vibrationactuator

m.pressed:#dom-gamepadbutton-pressed
m.touched:#dom-gamepadbutton-touched
m.value:#dom-gamepadbutton-value

	constructor:~DOM4#concept-event-constructor
	constructor:#dom-gamepadevent-constructor
m.gamepad:#dom-gamepadevent-gamepad
m.getGamepads:#dom-navigator-getgamepads

m.ongamepadconnected:#dom-windoweventhandlers-ongamepadconnected
m.ongamepaddisconnected:#dom-windoweventhandlers-ongamepaddisconnected

m.effects:#dom-gamepadhapticactuator-effects
m.playEffect:#dom-gamepadhapticactuator-playeffect
m.reset:#dom-gamepadhapticactuator-reset

m.touchId:#dom-gamepadtouch-touchid
m.surfaceId:#dom-gamepadtouch-surfaceid
m.position:#dom-gamepadtouch-position
m.surfaceDimensions:#dom-gamepadtouch-surfacedimensions

mb.gamepad:#dom-gamepadeventinit-gamepad

mb.startDelay:#dom-gamepadeffectparameters-startdelay
mb.duration:#dom-gamepadeffectparameters-duration
mb.strongMagnitude:#dom-gamepadeffectparameters-strongmagnitude
mb.weakMagnitude:#dom-gamepadeffectparameters-weakmagnitude
mb.leftTrigger:#dom-gamepadeffectparameters-lefttrigger
mb.rightTrigger:#dom-gamepadeffectparameters-righttrigger

m.requestAnimationFrame:~HTMLGAPI#dom-animationframeprovider-requestanimationframe

m.width:~GEOMETRY#dom-domrectreadonly-width
m.height:~GEOMETRY#dom-domrectreadonly-height
m.x:~GEOMETRY#dom-dompointreadonly-x
m.y:~GEOMETRY#dom-dompointreadonly-y
m.z:~GEOMETRY#dom-dompointreadonly-z
m.w:~GEOMETRY#dom-dompointreadonly-w

l.standard:#dom-gamepadmappingtype-standard
	#dfn-standard
l.xr-standard:#dom-gamepadmappingtype-xr-standard
	#dfn-xr-standard
	空~文字列:#dom-gamepadmappingtype-the-empty-string

l.gamepad:#dfn-gamepad

l.dual-rumble:#dom-gamepadhapticeffecttype-dual-rumble
l.trigger-rumble:#dom-gamepadhapticeffecttype-trigger-rumble
l.complete:#dom-gamepadhapticsresult-complete
l.preempted:#dom-gamepadhapticsresult-preempted

et.gamepadconnected:#dfn-gamepadconnected
et.gamepaddisconnected:#dfn-gamepaddisconnected


sl.connected:#dfn-connected
sl.timestamp:#dfn-timestamp
sl.axes:#dfn-axes
sl.buttons:#dfn-buttons
sl.hasGamepadGesture:#dfn-hasgamepadgesture
sl.gamepads:#dfn-gamepads
sl.exposed:#dfn-exposed
sl.axisMapping:#dfn-axismapping
sl.axisMinimums:#dfn-axisminimums
sl.axisMaximums:#dfn-axismaximums
sl.buttonMapping:#dfn-buttonmapping
sl.buttonMinimums:#dfn-buttonminimums
sl.buttonMaximums:#dfn-buttonmaximums
sl.touches:#dfn-touches
sl.nextTouchId:#dfn-nexttouchid
sl.vibrationActuator:#dfn-vibrationactuator
sl.value:#dfn-value
sl.pressed:#dfn-pressed
sl.touched:#dfn-touched
sl.effects:#dfn-effects
sl.playingEffectPromise:#dfn-playingeffectpromise


	●用語
~gamepad~task~source:#dfn-gamepad-task-source
~gamepad利用者~gestureを包含する:#dfn-gamepad-user-gesture
~gamepad利用者~gesture:#dfn-gamepad-user-gesture
新たな［~button／軸］入力~値を受信-:#dfn-receives-new-button-or-axis-input-values
新たな~gamepad:#dfn-a-new-gamepad
~gamepad状態を更新する:#dfn-update-gamepad-state
各~軸を対応付けて正規化する:#dfn-map-and-normalize-axes
各~buttonを対応付けて正規化する:#dfn-map-and-normalize-buttons
各~touchを記録する:#dfn-record-touches
未利用な~gamepad~indexを選定する:#dfn-selecting-an-unused-gamepad-index
対応付けを選定する:#dfn-selecting-a-mapping
各~軸を初期化する:#dfn-initializing-axes
各~buttonを初期化する:#dfn-initializing-buttons
~button押圧~閾値:#dfn-button-press-threshold

標準~gamepad:#dfn-standard-gamepad
標準~gamepad~buttonを表現する:#dfn-represents-a-standard-gamepad-button
標準~gamepad軸を表現する:#dfn-represents-a-standard-gamepad-axis
正準的~index:#dfn-canonical-indices

hA.構築する:#dfn-constructing-a-gamepadhapticactuator
効果を再生でき:#dfn-play-effects-with-type
妥当な効果:#dfn-valid-effect
妥当な効果を述べるか否か検査する:#dfn-valid-effect
	妥当な~dual-rumble効果:#dfn-valid-dual-rumble-effect
触覚-効果を発行する:#dfn-issue-a-haptic-effect
触覚-効果を停止する:#dfn-stop-haptic-effects

	Best Practice 1:#practice-timing
	Example 1:#example-1
	Example 2:#example-2

	●用語（外部
~UA:~INFRA#user-agent
8 ~bitな無符号~整数:~INFRA#8-bit-unsigned-integer
32 ~bitな無符号~整数:~INFRA#32-bit-unsigned-integer
範囲:~INFRA#the-range
有順序~map:~INFRA#ordered-map
~list:~INFRA#list
~size:~INFRA#list-size
付加する:~INFRA#list-append
空:~INFRA#list-is-empty
	誤）空にする:~INFRA#list-empty
~item:~INFRA#list-item
除去する:~INFRA#list-remove
	~IN:~INFRA#list-contain
	~EACH:~INFRA#list-iterate

新たな~obj:~WEBIDLjs#new
却下される~promise:~WEBIDLjs#a-promise-rejected-with
~promiseを解決する:~WEBIDLjs#resolve
新たな~promise:~WEBIDLjs#a-new-promise

文書:~DOM4#concept-document
~eventを発火する:~DOM4#concept-event-fire

並列的:~HTMLINFRA#in-parallel

doc.可視性~状態:~HTMLinteraction#visibility-state

~taskを~queueする:~WAPI#queue-a-task
大域~taskを~queueする:~WAPI#queue-a-global-task
環境~設定群~obj:~WAPI#environment-settings-object
現在の設定群~obj:~WAPI#current-settings-object
現在の大域~obj:~WAPI#current-global-object
関連な大域~obj:~WAPI#concept-relevant-global
enV.大域~obj:~WAPI#concept-settings-object-global
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes

結付けられた~Navigator:~HTMLnavigator#associated-navigator
結付けられた文書:~WINDOW#concept-document-window
全部的に作動中:~HTMLds#fully-active

利用は許容され:~HEembed#allowed-to-use
利用は許容されて:~HEembed#allowed-to-use

doc.許可~施策:~HTMLdom#concept-document-permissions-policy

既定の許容list:~PERMISSIONS-POLICY#policy-controlled-feature-default-allowlist
施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature
i.全~生成元:~PERMISSIONS-POLICY#default-allowlist

現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time

	:~XRGAMEPAD#xr-standard-gamepad-mapping
	:~XRGAMEPAD

点を初期化する:~GEOMETRY#_initialize-dompoint
矩形を初期化する:~GEOMETRY#_initialize-domrect

●●words_table1
XRGAMEPAD:https://www.w3.org/TR/webxr-gamepads-module-1/
	https://immersive-web.github.io/webxr-gamepads-module/

●●words_table

	●Gamepad／hardware
Gamepad:
USB:
XR:
WebXR:
controller::::コントローラ
game::::ゲーム
gamepad::::ゲームパッド
gaming::::ゲーミング
プレゼン:presentation:::~
sensor::::センサー
switch::::スイッチ
touch::::タッチ
viewer::::ビューア
stick::::スティック
joystick::::ジョイスティック
thumbstick::::親指スティック
ハンドルペダルアクセル:driving wheel, pedal, accelerometer::::ハンドル, ペダル, アクセル
handle::::ハンドル
spring-loaded::バネ式の
rumble:
force:
ERM:
	^en, 偏心回転質量:eccentric rotating mass
方向-:directional::~
押す:pressする::~
押圧:press::~
押され:pressされ::~
	押されていない:unpressed
	pressed$m:pressed
	に一体化された:pressed
放され:releaseされ::~
analog::::アナログ
digital::::デジタル
引金:trigger:引き金
製品:product:~
製造元:manufacturer:~
動き:motion::~
	動きが無い:motionless
動かし:moveし:~
運動:movement:~
変位:displacement::~
方位:orientation::~
奥行き:depth::~
感知:sensing::~
装着-:attach:~
切断-:disconnect::~
切断:disconnection::~
電源:power:~
	電源が切られた:powered off
振動-:vibrate::~
振動:vibration::~
波形:waveform::~
対応付直す:remapする::対応付け直す
対応付直法:remap 法::対応付け直し法

水平-:horizontal::~
垂直-:vertical::~
線形:linear::~
閾値:threshold::~
中立:neutral::~
serial::::シリアル
番号:number:~
Bluetooth:
揺らぎ:jitter::~
触覚-:haptic::~
	触覚-効果:haptics
作動器:actuator::~::アクチュエータ
	駆動器:actuator
motor::::モーター
再生-:play::~
再生:playing::~
再生n:playback::再生
強度:intensity:~
頻度:frequency:~
一定量:certain amount:~
一定:constant:~
	強度が一定な:constant-intensity
固定的:fixed:~

	●幾何
2D:
X:
Y:
x:
y:
z:
w:
変形-:transform::~
矩形:rectangle::~
点:point::~
表面:surface::~
二次元な:2-dimensional:~
視座:perspective::~
	^en:self-center
	上:top
	下:bottom
	上:up
	下:down
	右:right
	左:left
	中央:center
	~touch表面の~~左端:leftmost
	~touch表面の~~右端:rightmost
	~touch表面の~~上端:topmost
	~touch表面の~~下端:bottommost
	左上:top left
	右上:top right
	左下:bottom left
	右下:bottom right
	左下／右下:left and right bottom
	左下, 右下:each of the bottom
	上下:up-down
	左右:left-right
	左側は負:negative left／
	右側は正:positive right
	上側は負:negative up
	下側は正:positive down
	前方:forward
	後方:backward
	左方:left
	右方:right
	天を指して:perpendicular to the ground with 〜 pointing up
	前面:front
	~~前方に面した:front facing
	~~前方に面し，左右各側に 2 個ずつある:pair of front facing buttons on the left and right side
	左右各側にある:a pair of 〜 one on the left and one on the right
	所在は〜とほぼ同じ:located in approximately the same location
	〜どちらかのみ:pure 〜

	●UI
手指:finger:指
stylus::::スタイラス
接触:contact::~
接触-:contact::~
	接触-:makes contact
	接触しなくなる:no longer making contact

	●処理
標本化-:sample::~::サンプル
稼働-:run::~
	稼働している:running
更新周期:frequency:~
rate::::レート

高分解能:high resolution::~
分解能:resolution::~
micro::::マイクロ
	~micro秒~以上:minimum 〜 microseconds
時計:clock:~
近過去:recent:~
unmapped:::元の
Navigator:
navigator:
未利用:unused:~
	利用されない:unused
素早く:quickに:~
発行-:issue::~
先取り:preempt:~

	正規化-:scale

	●変数
params::::パラメタ群
reset:
	%~params:params
	%今:now
	%~button~list:buttons
	%~button~index:buttonIndex
	%~button~list~size:buttonsSize
	-:buttonValues
	%~gamepad:gamepad
	%~gamepad群:gamepads
	%~gamepad~index:gamepadIndex
	%~navigator:navigator
	%~unmapped入力~index~list:unmappedInputList
	%入力~個数:inputCount
	%対応付けた~index:mappedIndex
	%対応付けた~index~list:mappedIndexList
	%接続-済み~gamepad:connectedGamepad
	-:maxGamepadIndex
	-:maxRawButtonIndex
	-:maxRawAxisIndex
	%正準的~index:canonicalIndex
	%正規化した値:normalizedValue
	%装置~button:the button
	%生の~button~index:rawButtonIndex
	%生の入力~index:rawInputIndex
	%生の軸~index:rawAxisIndex
	%論理-値:logicalValue
	%論理-最大~値:logicalMaximum
	%論理-最小~値:logicalMinimum
	%軸~index:axisIndex
	%軸~list:axes
	%軸~list~size:axesSize
	-:axisValues
	%文書:doc
	%文書:document
	%効果~promise:effectPromise
	%再生-効果~時刻印:playEffectTimestamp
	%~reset結果~promise:resetResultPromise
	%~gamepad触覚-作動器:~gamepadHapticActuator
	%~supportされる効果~群:supportedEffectsList
	%~touch表面:touch surface
	%~touch表面:current touch surface
	%表面~ID:surfaceId
	%~touch点:active touch point
	%~touch:touch
	%寸法~矩形:-
	%~X寸法:-
	%~Y寸法:-
	%~touch~ID:-

	●S／P
能動的:active::~
表口:surface::口

	●仕様
協調-:coordinate:~
協調:coordination:~
模倣-:emulate:~
模倣:emulation:~
一般性:generality:~
事実上の:de-facto:~
解決策:solution:~
第一:primary:~
第二:secondary:~
第三:tertiary:~
brand::::ブランド
	デモ:demo
poll:
転がす:rollする:~
失う:loseする:~
選ぶ:chooseする:~
手助け:facilitate:~
欠如-:lack:~

	-:trying to be a
	~interface法:interfacing
	可用でなくなった:becomes unavailable
	に基づいて:basis
	利用-不能:unusable
	片:snippet
	広くから:widely
	おそれ:potential
	~~普及した:have been made popular
	その一方、~meanwhile:#1
	広く:broadly
	代表する呼称:exemplary:#1
	手に負えなく:intractable
	多少:somewhat
	能力がある／ない:capable of
	望ましい:desirable
	巨大:large
	種:type
	の様になる:look like
	適する:suited
	も含めるかどうか，〜 含める場合、:whether to include or exclude
	絞る:choose to narrow
	指定されない:left unspecified
	能力がある:capable
	無用に:unwanted
	〜に対応する:reference

	●未分類
分析:analysis:~
生の:raw:~
アテガい:assignし::あてがい
現れる:appearする:~
現れな:appearしな:~
許容list:allowlist::許容 list:許容リスト
milli::::ミリ
	~milli秒数:milliseconds
無符号:unsigned::~

	~index:indice
	〜中の:continue
	変化-用:changed
	取り出され:drawn
	列挙:enum
	-:mirror
	-:present
	接続-中にある:continue to be connected
	0 でない:greater than 0
	交互に:next to each other
	現在:currently
	現時点:currently
	てから:subsequently
	から:starting
	それまでに／以前に:previously
	上回る:above
	下回る:below
	低~level:low-level
	近く／近くに:closely
	範囲をとる:ranging from
	~~固有の:unique
	最初に来たものから順に:first-come first-serve
	高いものから順:decreasing order／:decreasing
	最低:lowest
	低-:low-
	低-:low
	高-:high-
	高-:high
	高める:increase
	効果の:effected
	互いに異なる:unequal
	長く稼働する:long-running
	遅延されている間:delay interval
	大きさ:magnitude
	所要時間:the total effect duration
	0 以上 1 以下:[0,1]
	全体:whole
	対応-:correspond
	局所~化:localize
	次回の:next incoming


●●images
＠gamepad/
standard_gamepad｜height:22rem｜｜.svg

●●ref_normative

[dom]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FINGERPRINTING-GUIDANCE]
    Mitigating Browser Fingerprinting in Web Specifications. Nick Doty. W3C. 28 March 2019. W3C Working Group Note. URL: https://www.w3.org/TR/fingerprinting-guidance/ 
[geometry-1]
    Geometry Interfaces Module Level 1. Simon Pieters; Chris Harrelson. W3C. 4 December 2018. W3C Candidate Recommendation. URL: https://www.w3.org/TR/geometry-1/ 
[HR-TIME]
    High Resolution Time. Yoav Weiss. W3C. 7 November 2024. W3C Working Draft. URL: https://www.w3.org/TR/hr-time-3/ 
[html]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Dominic Farolino; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[infra]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/ 
[permissions-policy]
    Permissions Policy. Ian Clelland. W3C. 10 February 2025. W3C Working Draft. URL: https://www.w3.org/TR/permissions-policy-1/ 
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119 
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174 
[WEBIDL]
    Web IDL Standard. Edgar Chen; Timothy Gu. WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/ 
[webxr-gamepads-module-1]
    WebXR Gamepads Module - Level 1. Brandon Jones; Manish Goregaokar; Rik Cabanier. W3C. 9 April 2024. W3C Working Draft. URL: https://www.w3.org/TR/webxr-gamepads-module-1/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Gamepad</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/gamepad/
公表履歴
	https://www.w3.org/standards/history/gamepad/
編集者草案
	https://w3c.github.io/gamepad/
commit 履歴
	https://github.com/w3c/gamepad/commits/
テスト一式
	https://wpt.live/gamepad/
実装報告
	https://wpt.fyi/results/gamepad
編集
	Steve Agoston (Sony)
	Matt Reynolds (Google)
前任編集者
	James Hollyer (Google)
	<a href="http://tojicode.com/">Brandon Jones</a> (Google)
	<a href="http://h4ck3r.net/">Scott Graham</a> (Google)
	<a href="http://ted.mielczarek.org/">Ted Mielczarek</a> (Mozilla)
フィードバック
	<a href="https://github.com/w3c/gamepad/">GitHub w3c/gamepad</a> (<a href="https://github.com/w3c/gamepad/pulls/">pull requests</a>, <a href="https://github.com/w3c/gamepad/issues/new/choose">new issue</a>, <a href="https://github.com/w3c/gamepad/issues/">open issues</a>)
ブラウザサポート
	https://caniuse.com/gamepad
公表者
	<a href="https://www.w3.org/groups/wg/webapps">Web Applications WG</a>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>Gamepad</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
~Gamepad仕様は、
~gamepad装置を表現する低~levelな~interfaceを定義する。
◎
The Gamepad specification defines a low-level interface that represents gamepad devices.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
`この節では、公表~時点における…^em
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
`~UA$には、
~gamepad装置が接続されるものもある。
これらの装置は、
~gaming~app用の入力や
“数歩先の” ~UI
【`10 foot UI＠https://en.wikipedia.org/wiki/10-foot_user_interface$en】
（プレゼン, ~media~viewerなど）
に望ましい, かつ適する。
◎
Some user agents have connected gamepad devices. These devices are desirable and suited to input for gaming applications, and for "10 foot" user interfaces (presentations, media viewers).
</p>

<p>
~gamepadを入力として利用する仕方は、
現時点では，［
~mouse／~keyboard
］~eventで模倣する他にない。
しかしながら，これは、
情報を失うことに加え，［
模倣を成遂げるためには，`~UA$の外側に追加的な~softwareを要求する
］ことになる。
◎
Currently, the only way for a gamepad to be used as input would be to emulate mouse or keyboard events, however this would lose information and require additional software outside of the user agent to accomplish emulation.
</p>

<p>
その一方，~native~appには、
~system~APIを介してこれらの装置へ~accessする能力がある。
◎
Meanwhile, native applications are capable of accessing these devices via system APIs.
</p>

<p>
~Gamepad~APIは、［
~gamepad~data上で直に動作することを~web~appに許容する~interface
］を指定することにより，この問題への解決策を供する。
◎
The Gamepad API provides a solution to this problem by specifying interfaces that allow web applications to directly act on gamepad data.
</p>

	</section>
	<section id="scope">
<h2 title="Scope">2. 視野</h2>

<p>
~gameの制御-用に設計された外部~装置との~interface法は、
全部的な一般性に向かって~approachすると，巨大で手に負えなくなるおそれがある。
この仕様では、
明示的に視野を絞って，そのような機能性のうち［
広くから実装でき，広く有用になる下位集合
］を供する。
◎
Interfacing with external devices designed to control games has the potential to become large and intractable if approached in full generality. In this specification we explicitly choose to narrow scope to provide a useful subset of functionality that can be widely implemented and broadly useful.
</p>

<p>
特定的には，ここでは、
~gamepadを~supportするために要求される機能性に限り~supportする。
~gamepad用の~supportは、
2 種の入力
— ~button, 軸（ `axis^en ） —
を要求する。
両者とも~analog値として報告され、
各~buttonは［
0 以上, 1 以下
］の範囲を,
各~軸は［
−1 以上, 1 以下
］の範囲をとる。
◎
Specifically, we choose to only support the functionality required to support gamepads. Support for gamepads requires two input types: buttons and axes. Both buttons and axes are reported as analog values, buttons ranging from [0..1], and axes ranging from [-1..1].
</p>

<p>
首な目標は，~gamepad装置~用の~supportであるが、
この 2 種の~analog入力を~supportすることで，［
現在の~gaming~systemに共通な，他の類似な装置
］
— ~joystick, ハンドルペダルアクセル, 等々も含む —
用の~supportも許容する。
そのようなわけで、
“~gamepad” という名前は
— この仕様が取組む装置の集合~全体を汎用に表すものではなく —
それらを~~代表する呼称である。
◎
While the primary goal is support for gamepad devices, supporting these two types of analog inputs allows support for other similar devices common to current gaming systems including joysticks, driving wheels, pedals, and accelerometers. As such, the name "gamepad" is exemplary rather than trying to be a generic name for the entire set of devices addressed by this specification.
</p>

<p>
特定的には、
一部の~gaming文脈で利用され得る，より複階的な装置
— ［
動き感知／
奥行き感知／
動画~分析／
~gesture認識
］等々を行うもの —
の~supportは除外される。
◎
We specifically exclude support for more complex devices that may also be used in some gaming contexts, including those that that do motion sensing, depth sensing, video analysis, gesture recognition, and so on.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
	<section id="gamepad-interface">
<h2 title="Gamepad interface">3. `Gamepad^I ~interface</h2>

<p>
この~interfaceは、
個々の~gamepad装置を定義する。
◎
This interface defines an individual gamepad device.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `Gamepad@I {
  readonly attribute `DOMString$ `id$m;
  readonly attribute `long$ `index$m;
  readonly attribute `boolean$ `connected$m;
  readonly attribute `DOMHighResTimeStamp$I `timestamp$m;
  readonly attribute `GamepadMappingType$I `mapping$m;
  readonly attribute `FrozenArray$&lt;`double$&gt; `axes$m;
  readonly attribute `FrozenArray$&lt;`GamepadButton$I&gt; `buttons$m;
  readonly attribute `FrozenArray$&lt;`GamepadTouch$I&gt; `touches$m;
  [`SameObject$] readonly attribute `GamepadHapticActuator$I `vibrationActuator$m;
};
</pre>

<p>
~systemと通信するために利用される各種~algoは、
概して，
`~gamepad~task~source@
に対し~queueするように働くことにより，非同期に完了する。
◎
The algorithms used to communicate with the system typically complete asynchronously, queuing work on the gamepad task source.
</p>

<p>
`Gamepad$I の各~instance %~gamepad は、
次に挙げる内部~slotを伴って作成される
（値~型と初期~値~以外の記述は規範的でない）：
◎
Instances of Gamepad are created with the internal slots described in the following table:
◎
Internal slot｜Initial value｜Description (non-normative)
</p>

<dl>
	<dt>`connected@sl</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
false｜A flag＼
</dd>
	<dd>
当の装置は~systemに接続されているかどうかを指示する。
◎
indicating that the device is connected to the system
</dd>

	<dt>`timestamp@sl</dt>
	<dd>
`DOMHighResTimeStamp$I 値
— 初期~時は未定義【~objの作成-時に設定される】。
◎
undefined
</dd>
	<dd>
%~gamepad 用の~dataが最後に更新された時刻。
◎
The last time data for this Gamepad was updated
</dd>

	<dt>`axes@sl</dt>
	<dd>
`double$c 値たちが成す`~list$【！sequence】
— 初期~時は空とする。
◎
An empty sequence｜A sequence of double values＼
</dd>
	<dd>
この装置により公開される各~軸の現在の状態を表現する。
◎
representing the current state of axes exposed by this device
</dd>

	<dt>`buttons@sl</dt>
	<dd>
`GamepadButton$I ~objたちが成す`~list$【！sequence】
— 初期~時は空とする。
◎
An empty sequence｜A sequence of GamepadButton objects＼
</dd>
	<dd>
この装置により公開される各~buttonの現在の状態を表現する。
◎
representing the current state of buttons exposed by this device
</dd>

	<dt>`exposed@sl</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
false｜A flag＼
</dd>
	<dd>
%~gamepad は~scriptに公開されたかどうかを指示する。
◎
indicating that the Gamepad object has been exposed to script
</dd>

	<dt>`axisMapping@sl</dt>
	<dd>
`有順序~map$
— 初期~時は空とする。
◎
An empty ordered map｜＼
</dd>
	<dd>
~unmapped軸~indexから `axes$m 配列~内を指す~indexへの対応付け。
◎
Mapping from unmapped axis index to an index in the axes array
</dd>

	<dt>`axisMinimums@sl</dt>
	<dd>
`~list$
— 初期~時は空とする。
◎
An empty list｜A list＼
</dd>
	<dd>
各~軸~用の最小な論理-値を包含する。
◎
containing the minimum logical value for each axis
</dd>

	<dt>`axisMaximums@sl</dt>
	<dd>
`~list$
— 初期~時は空とする。
◎
An empty list｜A list＼
</dd>
	<dd>
各~軸~用の最大な論理-値を包含する。
◎
containing the maximum logical value for each axis
</dd>

	<dt>`buttonMapping@sl</dt>
	<dd>
`有順序~map$
— 初期~時は 空とする。
◎
An empty ordered map｜＼
</dd>
	<dd>
~unmapped~button~indexから `buttons$m 配列~内を指す~indexへの対応付け。
◎
Mapping from unmapped button index to an index in the buttons array
</dd>

	<dt>`buttonMinimums@sl</dt>
	<dd>
`~list$
— 初期~時は空とする。
◎
An empty list｜A list＼
</dd>
	<dd>
各~button用の最小な論理-値を包含する。
◎
containing the minimum logical value for each button.
</dd>

	<dt>`buttonMaximums@sl</dt>
	<dd>
`~list$
— 初期~時は空とする。
◎
An empty list｜A list＼
</dd>
	<dd>
各~button用の最大な論理-値を包含する。
◎
containing the maximum logical value for each button
</dd>

	<dt>`touches@sl</dt>
	<dd>
`~list$
— 初期~時は空とする。
◎
Initialize to an is empty list＼
</dd>
	<dd>
利用者が生成した~touchたちが成す~listを保持する。
◎
Holds the list of user-generated touches, if any.＼
</dd>
	<dd>
当の~gamepadが~touch表面を~supportしない場合、
空であり続ける。
◎
If the gamepad does not support touch surfaces, then the list will remain empty.
</dd>

	<dt>`nextTouchId@sl</dt>
	<dd>
整数
— 初期~時は 0 とする。
◎
Initialize to 0＼
</dd>
	<dd>
次回の~touch用に利用される~touch~ID。
◎
Touch id to use for the next incoming touch.
</dd>

	<dt>`vibrationActuator@sl</dt>
	<dd>
ある `GamepadHapticActuator$I ~obj
— 初期~時は未定義【~objの作成-時に設定される】。
◎
undefined｜A GamepadHapticActuator object＼
</dd>
	<dd>
~gamepad全体を振動する触覚-効果を生成する能力がある~obj。
◎
capable of generating a haptic effect that vibrates the entire gamepad 
</dd>
</dl>

<p>
`id@m
属性は：
◎
id attribute
</p>
<ul>
	<li>
~gamepad用の識別~文字列を指示する
— それは、
接続された~gamepad装置の~brandや~styleを識別する。
◎
An identification string for the gamepad. This string identifies the brand or style of connected gamepad device.
</li>
	<li>
識別~文字列の正確な形式は、
指定されない。
`~UA$には、［
製品を識別する文字列
］として［
装置を一意に識別しないもの
］を選定することが推奨される。
例えば，~USB~gamepadは、
その［
`idVendor^c, `idProduct^c
］値により識別され得る。
識別~文字列には、［
~serial番号や~Bluetooth装置~addressの様な，
【各~装置，したがって各~利用者に】一意な識別子
］は含めないモノトスル。
◎
The exact format of the id string is left unspecified. It is RECOMMENDED that the user agent select a string that identifies the product without uniquely identifying the device. For example, a USB gamepad may be identified by its idVendor and idProduct values. Unique identifiers like serial numbers or Bluetooth device addresses MUST NOT be included in the id string.
</li>
</ul>

<p>
`index@m
属性は：
◎
index attribute
</p>
<ul>
	<li>
`Navigator$I
【の `getGamepads()$m が返す配列】
における，この~gamepadの~indexを指示する。
◎
The index of the gamepad in the Navigator.＼
</li>
	<li>
<p>
`~UA$は、
各~gamepadに~indexをアテガうときには，次に従うモノトスル：
</p>
		<ul>
			<li>
接続されている~gamepadが複数ある場合、
最初に接続されたものから順に， 0 から~indexをアテガう。
</li>
			<li>
ある~gamepadが切断されても、
それにアテガわれていた~indexを接続-中にある~gamepadにはアテガい直さない。
【接続-中にある どの~gamepadも，その~indexは変化しない。】
</li>
			<li>
~gamepadが切断されてから，同じまたは異なる~gamepadが接続された場合、
それまでに利用された【かつ接続-中にある~gamepadにアテガっていない】最低な~indexを再利用する。
</li>
		</ul>
◎
When multiple gamepads are connected to a user agent, indices MUST be assigned on a first-come, first-serve basis, starting at zero. If a gamepad is disconnected, previously assigned indices MUST NOT be reassigned to gamepads that continue to be connected. However, if a gamepad is disconnected, and subsequently the same or a different gamepad is then connected, the lowest previously used index MUST be reused.
</li>
</ul>

<p>
`connected@m
属性は：
◎
connected attribute
</p>
<ul>
	<li>
この~objにより表現される物理的な装置は、
依然として~systemに接続されているかどうかを指示する。
◎
Indicates whether the physical device represented by this object is still connected to the system.＼
</li>
	<li>
~gamepadが可用でなくなったとき
— 物理的に切断された, 電源が切られた, その他~利用-不能になったなど —
には、
~F に設定するモノトスル。
◎
When a gamepad becomes unavailable, whether by being physically disconnected, powered off or otherwise unusable, the connected attribute MUST be set to false.
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ . `connected$sl
◎
The connected getter steps are:
• Return this.[[connected]].
</li>
</ul>

<p>
`timestamp@m
属性は：
◎
timestamp attribute
</p>
<ul>
	<li>
次を決定することを作者に許容する
⇒
この~gamepad用の［
`axes$m ／ `buttons$m
］属性が最後に更新された時刻
◎
The timestamp allows the author to determine the last time the axes or buttons attribute for this gamepad was updated.＼
</li>
	<li>
<p>
値は、
次に挙げる各~時点に，その時点における`現在の高分解能~時刻$に設定するモノトスル：
◎
The value MUST be set to the current high resolution time＼
</p>
		<ul>
			<li>
~systemが装置から`新たな［~button／軸］入力~値を受信-$した各回
◎
each time the system receives new button or axis input values from the device.＼
</li>
			<li>
~hardwareから まだ何も~dataを受信していない間は、
この `Gamepad$I が~scriptに最初に可用された時点
◎
If no data has been received from the hardware, timestamp MUST be the current high resolution time at the time when the Gamepad was first made available to script.
</li>
		</ul>

<p class="warning" id="issue-container-generatedID">
`~UA$は、
`HR-TIME$r による時計~分解能の推奨に従って，
%~gamepad の `timestamp$m 属性の分解能を 5 ~micro秒~以上に設定するベキである。
◎
Warning
User agents SHOULD set a minimum resolution of gamepad's timestamp attribute to 5 microseconds, following [HR-TIME]'s clock resolution recommendation.
</p>
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ . `timestamp$sl
◎
The timestamp getter steps are:
◎
Return this.[[timestamp]].
</li>
</ul>

<p>
`mapping@m
属性は：
◎
mapping attribute
</p>
<ul>
	<li>
この装置~用に利用-中にある~layout対応付けを指示する。
◎
The mapping in use for this device.＼
</li>
	<li>
`~UA$は，装置の~layoutについて知識がある場合、
この属性を［
当の~layoutに対応している `GamepadMappingType$I 値
］に設定することにより，対応付けが利用-中にあることを指示するベキである。
◎
If the user agent has knowledge of the layout of the device, then it SHOULD indicate that a mapping is in use by setting mapping to the corresponding GamepadMappingType value.
</li>
	<li class="algo">
<p>
~gamepad装置~用の
`対応付けを選定する@
~algoは：
◎
To select a mapping for a gamepad device, run the following steps:
</p>
		<ol>
			<li>
~IF［
当の~gamepad装置の［
~button, 軸
］の~layoutは、
`標準~gamepad$の~layoutに対応する
］
⇒
~RET `standard$l
◎
If the button and axis layout of the gamepad device corresponds with the Standard Gamepad layout, then return "standard".
</li>
			<li>
~RET `空~文字列＠#dom-gamepadmappingtype-the-empty-string$
◎
Return "".
</li>
		</ol>
	</li>
</ul>


<p>
`axes@m
属性は：
◎
axes attribute
</p>
<ul>
	<li>
この~gamepadを成す すべての軸の値たちが成す配列を返す。
◎
Array of values for all axes of the gamepad.＼
</li>
	<li>
すべての軸~値は［
−1.0 以上 1.0 以下
］の範囲に線形に正規化するモノトスル。
~controllerの方向-~stickは天を指しているならば、
−1.0 は［
“前方” ／ “左方”
］に対応し，
1.0 は［
“後方” ／ “右方”
］に対応するベキである。
◎
All axis values MUST be linearly normalized to the range [-1.0 .. 1.0].＼
If the controller is perpendicular to the ground with the directional stick pointing up, -1.0 SHOULD correspond to "forward" or "left", and 1.0 SHOULD correspond to "backward" or "right".＼
</li>
	<li>
~2D入力~装置から取り出される軸は、
配列~内で［
~X軸, ~Y軸
］の順に，交互に現れるベキである。
軸たちは、
重要度の高いものから順に
— 概して，［
0 番, 1 番
］の要素が順に，方向-~stickの［
~X軸, ~Y軸
］を表現するように —
現れることが推奨される。
◎
Axes that are drawn from a 2D input device SHOULD appear next to each other in the axes array, X then Y. It is RECOMMENDED that axes appear in decreasing order of importance, such that element 0 and 1 typically represent the X and Y axis of a directional stick.＼
</li>
	<li>
この属性は、
異なる値たちを返す（あるいは値たちを異なる順序にする）必要があるときまで，
同じ~objを返すモノトスル。
◎
The same object MUST be returned until the user agent needs to return different values (or values in a different order).
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ . `axes$sl
◎
The axes getter steps are:
• Return this.[[axes]].
</li>
</ul>

<p>
`buttons@m
属性は：
◎
buttons attribute
</p>
<ul>
	<li>
この~gamepadを成す すべての~buttonの状態たちが成す配列を返す。
◎
Array of button states for all buttons of the gamepad.＼
</li>
	<li>
各~buttonは、
重要度の高いものから順に現れる
— ［
第一~button, 第二~button, 第三~button, 等々
］が配列~内で［
0, 1, 2, …
］番の要素として現れる —
ことが推奨される。
◎
It is RECOMMENDED that buttons appear in decreasing importance such that the primary button, secondary button, tertiary button, and so on appear as elements 0, 1, 2, ... in the buttons array.＼
</li>
	<li>
この属性は、
異なる値たちを返す（あるいは値たちを異なる順序にする）必要があるときまで，
同じ~objを返すモノトスル。
◎
The same object MUST be returned until the user agent needs to return different values (or values in a different order).
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ . `buttons$sl
◎
The buttons getter steps are:
• Return this.[[buttons]].
</li>
</ul>

<p>
`touches@m
属性は：
◎
touches attribute
</p>
<ul>
	<li>
すべての~touch表面から生成された `GamepadTouch$I ~objたちが成す~listを返す。
◎
A list of GamepadTouch objects generated from all touch surfaces.
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ . `touches$sl
◎
The touches getter steps are:
• Return this.[[touches]].
</li>
</ul>

<p>
`vibrationActuator@m
属性は：
◎
vibrationActuator attribute
</p>
<ul>
	<li>
当の装置の首な振動~作動器を表現する `GamepadHapticActuator$I ~objを返す。
◎
A GamepadHapticActuator object that represents the device's primary vibration actuator.
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ . `vibrationActuator$sl
◎
The vibrationActuator getter steps are:
• Return this.[[vibrationActuator]].
</li>
</ul>

		<section id="receiving-inputs">
<h3 title="Receiving inputs">3.1. 入力の受信-法</h3>

<div class="algo">
<p>
~systemの %装置 から
`新たな［~button／軸］入力~値を受信-@
したときは、
次の手続きを走らす：
◎
When the system receives new button or axis input values, run the following steps:
</p>
<ol>
	<li>
%~gamepad ~LET %装置 を表現している `Gamepad$I ~obj
◎
Let gamepad be the Gamepad object representing the device that received new button or axis input values.
</li>
	<li>
<p>
`~taskを~queueする$( `~gamepad~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~gamepad状態を更新する$( %~gamepad )
</div>
◎
Queue a task on the gamepad task source to update gamepad state for gamepad.
</li>
</ol>
</div>

<div class="algo">
<p>
%~gamepad 用に
`~gamepad状態を更新する@
~algoは：
◎
To update gamepad state for gamepad, run the following steps:
</p>
<ol>
	<li>
%今 ~LET `現在の高分解能~時刻$( 【 %~gamepad に`関連な大域~obj$】 )
◎
Let now be the current high resolution time.
</li>
	<li>
%~gamepad . `timestamp$sl ~SET %今
◎
Set gamepad.[[timestamp]] to now.
</li>
	<li>
%~gamepad 用に`各~軸を対応付けて正規化する$()
◎
Run the steps to map and normalize axes for gamepad.
</li>
	<li>
%~gamepad 用に`各~buttonを対応付けて正規化する$()
◎
Run the steps to map and normalize buttons for gamepad.
</li>
	<li>
%~gamepad 用に`各~touchを記録する$()
◎
Run the steps to record touches for gamepad.
</li>
	<li>
%~navigator ~LET %~gamepad に`関連な大域~obj$に`結付けられた~Navigator$
◎
Let navigator be gamepad's relevant global object's Navigator object.
</li>
	<li>
<p>
~IF［
%~navigator . `hasGamepadGesture$sl ~EQ ~F
］~AND［
%~gamepad は`~gamepad利用者~gestureを包含する$
］：
◎
If navigator.[[hasGamepadGesture]] is false and gamepad contains a gamepad user gesture:
</p>
		<ol>
			<li>
%~navigator . `hasGamepadGesture$sl ~SET ~T
◎
Set navigator.[[hasGamepadGesture]] to true.
</li>
			<li>
<p>
%~navigator . `gamepads$sl を成す
~EACH( %接続-済み~gamepad )
に対し：
◎
For each connectedGamepad of navigator.[[gamepads]]:
</p>
				<ol>
					<li>
~IF［
%接続-済み~gamepad ~EQ ~NULL
］
⇒
~CONTINUE
◎
If connectedGamepad is not equal to null:
</li>
					<li>
%接続-済み~gamepad . `exposed$sl ~SET ~T
◎
Set connectedGamepad.[[exposed]] to true.
</li>
					<li>
%接続-済み~gamepad . `timestamp$sl ~SET %今
◎
Set connectedGamepad.[[timestamp]] to now.
</li>
					<li>
%文書 ~LET %~gamepad に`関連な大域~obj$に`結付けられた文書$
— 他の場合【？】は ~NULL
◎
Let document be gamepad's relevant global object's associated Document; otherwise null.
</li>
					<li>
~IF［
%文書 ~EQ ~NULL【！余計？】
］~OR［
%文書 は`全部的に作動中$でない
］
⇒
~CONTINUE
◎
↓</li>
					<li>
<p>
`~taskを~queueする$( `~gamepad~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~eventを発火する$( %~gamepad に`関連な大域~obj$, `gamepadconnected$et, `GamepadEvent$I )
— 次のように初期化して
⇒
`gamepad$m 属性 ~SET %接続-済み~gamepad
</div>
◎
If document is not null and is fully active, then queue a task on the gamepad task source to fire an event named gamepadconnected at gamepad's relevant global object using GamepadEvent with its gamepad attribute initialized to connectedGamepad.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
%~gamepad 用に
`各~軸を対応付けて正規化する@
~algoは：
◎
To map and normalize axes for gamepad, run the following steps:
</p>
<ol>
	<li>
<p>
%~gamepad . `axisMapping$sl を成す
~EACH( %生の軸~index → %対応付けた~index )
に対し：
◎
↓ Let axisValues be a list of unsigned long values representing the most recent logical axis input values for each axis input of the device represented by gamepad.
◎
Let maxRawAxisIndex be the size of axisValues − 1.
◎
For each rawAxisIndex of the range from 0 to maxRawAxisIndex:
• Let mappedIndex be gamepad.[[axisMapping]][rawAxisIndex].
</p>
		<ol>
			<li>
<p>
%論理-値 ~LET 【！%軸~値~list[ %生の軸~index ]】［
%~gamepad により表現される装置
］を成す［
%生の軸~index 番の軸
］用の［
最も近過去な論理-軸~入力 `unsigned long$c† 値
］
</p>

<p class="trans-note">【†
%論理-値 は~APIには直に公開されないにもかかわらず、
なぜ `unsigned long$c 型とされているのかは不明
（他所の `unsigned long^c も同様）。
~USBなどの何らかの標準~規格の都合かもしれない。
】</p>
◎
Let logicalValue be axisValues[rawAxisIndex].
</li>
			<li>
%論理-最小~値 ~LET %~gamepad . `axisMinimums$sl[ %生の軸~index ]
◎
Let logicalMinimum be gamepad.[[axisMinimums]][rawAxisIndex].
</li>
			<li>
%論理-最大~値 ~LET %~gamepad . `axisMaximums$sl[ %生の軸~index ]
◎
Let logicalMaximum be gamepad.[[axisMaximums]][rawAxisIndex].
</li>
			<li>
%正規化した値 ~LET
2 ~MUL
( %論理-値 ~MINUS %論理-最小~値 )
~DIV
( %論理-最大~値 ~MINUS %論理-最小~値 )
~MINUS 1
◎
Let normalizedValue be 2 (logicalValue − logicalMinimum) / (logicalMaximum − logicalMinimum) − 1.
</li>
			<li>
%~gamepad . `axes$sl[ %対応付けた~index【！%軸~index】 ] ~SET %正規化した値
◎
Set gamepad.[[axes]][axisIndex] to be normalizedValue.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
%~gamepad 用に
`各~buttonを対応付けて正規化する@
~algoは：
◎
To map and normalize buttons for gamepad, run the following steps:
</p>
<ol>
	<li>
<p>
%~gamepad . `buttonMapping$sl を成す
~EACH( %生の~button~index → %対応付けた~index )
に対し：
◎
↓ Let buttonValues be a list of unsigned long values representing the most recent logical button input values for each button input of the device represented by gamepad.
◎
Let maxRawButtonIndex be the size of buttonValues − 1.
◎
For each rawButtonIndex of the range from 0 to maxRawButtonIndex:
• Let mappedIndex be gamepad.[[buttonMapping]][rawButtonIndex].
</p>
		<ol>
			<li>
%装置~button ~LET ［
%~gamepad により表現される装置
］を成す［
%生の~button~index 番の~button
］
◎
↑</li>
			<li>
%論理-値 ~LET %装置~button 用の［
最も近過去な論理-~button入力 `unsigned long$c 値
］
◎
↑
◎
Let logicalValue be buttonValues[rawButtonIndex].
</li>
			<li>
%論理-最小~値 ~LET %~gamepad . `buttonMinimums$sl[ %生の~button~index ]
◎
Let logicalMinimum be gamepad.[[buttonMinimums]][rawButtonIndex].
</li>
			<li>
%論理-最大~値 ~LET %~gamepad . `buttonMaximums$sl[ %生の~button~index ]
◎
Let logicalMaximum be gamepad.[[buttonMaximums]][rawButtonIndex].
</li>
			<li>
%正規化した値 ~LET
( %論理-値 ~MINUS %論理-最小~値 )
~DIV
( %論理-最大~値 ~MINUS %論理-最小~値 )
◎
Let normalizedValue be (logicalValue − logicalMinimum) / (logicalMaximum − logicalMinimum).
</li>
			<li>
%~button ~LET %~gamepad . `buttons$sl[ %対応付けた~index ]
◎
Let button be gamepad.[[buttons]][mappedIndex].
</li>
			<li>
%~button . `value$sl ~SET %正規化した値
◎
Set button.[[value]] to normalizedValue.
</li>
			<li>
~IF［
%装置~button は、［
押された状態, 放された状態
］どちらかのみを指示する~digital~switchを有している
］
⇒
%~button . `pressed$sl ~SET ~IS［
%装置~button は押されている
］
◎
If the button has a digital switch to indicate a pure pressed or released state, set button.[[pressed]] to true if the button is pressed or false if it is not pressed.
</li>
			<li>
<p>
~ELSE
⇒
%~button . `pressed$sl ~SET ~IS［
当の値は`~button押圧~閾値$を上回る
］
</p>

<p class="trans-note">【
“当の値” は［
%論理-値 ／ %正規化した値
］どちらかを表す
（ `~button押圧~閾値$がどちらと比較されるかは，明示的に指定されていない）。
】</p>
◎
Otherwise, set button.[[pressed]] to true if the value is above the button press threshold or false if it is not above the threshold.
</li>
			<li>
~IF［
%装置~button は、
~touchを検出する能力がある
］
⇒
%~button . `touched$sl ~SET ~IS［
%装置~button は現在~touchされている
］
◎
If the button is capable of detecting touch, set button.[[touched]] to true if the button is currently being touched.
</li>
			<li>
~ELSE
⇒
%~button . `touched$sl ~SET %~button . `pressed$sl
◎
Otherwise, set button.[[touched]] to button.[[pressed]].
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
%~gamepad 用に
`各~touchを記録する@
~algoは：
◎
To record touches for gamepad, run the following steps:
</p>
<ol>
	<li>
~Assert：
%~gamepad【！`Gamepad$I】 . `touches$sl は`空$である
◎
Assert: Gamepad.[[touches]] is empty.
</li>
	<li>
<p>
%~gamepad に可用な
~EACH( ~touch表面 %~touch表面 )
に対し，
~touch表面の列挙~順序で
【この順序は，この仕様には定義されていない】：
◎
Repeat the following steps for each touch surface on gamepad in touch surface enumeration order:
</p>
		<ol>
			<li>
%表面~ID ~LET %~touch表面 の列挙~index
◎
Let surfaceId be the current surface enumeration index.
</li>
			<li>
<p>
（この段は %~touch の `surfaceDimensions$m を初期化する）：
</p>

<p class="trans-note">【
この段は、
実際には次の段を成す~loop~blockの中へ入子にされるべきであろう
（その~blockの中で宣言される変数 %~touch を利用している）。
】</p>
				<ol>
					<li>
<p>
~IF［
%~touch表面 は［
装置~単位による最大な寸法
］を公開している
］：
</p>
						<ol>
							<li>
%寸法~矩形 ~LET `新たな~obj$( `DOMRectReadOnly$I )
</li>
							<li>
%~X寸法 ~LET %~touch表面 の装置~単位による最大な~X寸法
</li>
							<li>
%~Y寸法 ~LET %~touch表面 の装置~単位による最大な~Y寸法
</li>
							<li>
`矩形を初期化する$( %寸法~矩形, %~X寸法, %~Y寸法 )
</li>
							<li>
%~touch . `surfaceDimensions$m ~SET %寸法~矩形
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%~touch . `surfaceDimensions$m ~SET【 ~NULL ？（原文には指定されていない）】
</li>
				</ol>
◎
If the touch surface exposes maximum surface dimensions in device units, then set touch.surfaceDimensions to a DOMRectReadOnly with width and height initialized to the maximum X and Y dimensions on the touch surface in device units.
</li>
			<li>
<p>
%~gamepad から %~touch表面 用に報告された
~EACH( 作動中な~touch点 %~touch点 )
に対し【順序は指定されていない】：
◎
Repeat the following steps for each active touch point reported by the gamepad for the current touch surface.
</p>
				<ol>
					<li>
%~touch ~LET `新たな~obj$( `GamepadTouch$I )
◎
Let touch be a newly created GamepadTouch object.
</li>
					<li>
%~touch . `surfaceId$m ~SET %表面~ID
◎
Set touch.surfaceId to be surfaceId.
</li>
					<li>
<p>
（この段は %~touch の `touchId$m を初期化する）：
</p>
						<ol>
							<li>
%~touch~ID ~LET ε
</li>
							<li>
~IF［
%~touch点 は~UAが追跡している既存の作動中な~touch点である
］
⇒
%~touch~ID ~SET この~algoにより以前に設定された %~touch点 の~touch~ID
</li>
							<li>
<p>
~ELSE：
</p>
								<ol>
									<li>
%~touch~ID ~SET %~gamepad . `nextTouchId$sl
</li>
									<li>
%~gamepad . `nextTouchId$sl ~INCBY 1
</li>
								</ol>
</p>

<p class="note">注記：
%~gamepad が複数の~touch表面を有する場合、
~touch~IDは，それら表面にわたって一意になる。
</p>
							</li>
							<li>
%~touch . `touchId$m ~SET %~touch~ID
</li>
						</ol>
◎
If the touch data is part of an existing active touch point tracked by the user agent:
• Set touch.touchId to the touchId of the active touch point.
• Otherwise, set touchId to nextTouchId and increment nextTouchId.
•• Note: Touch ids are relative to the Gamepad
•• If the Gamepad has multiple touch surfaces the touch id will be unique across surfaces.
</li>
					<li>
<p>
（この段は %~touch の `position$m を初期化する）：
</p>
						<ol>
							<li>
%~touch点 ~LET `新たな~obj$( `DOMPointReadOnly$I )
</li>
							<li>
%~x ~LET 2 ~MUL ( %~touch点 の~X座標 ~DIV %~touch表面 の最大な~X寸法 ) ~MINUS 1
</li>
							<li>
%~y ~LET 2 ~MUL ( %~touch点 の~Y座標 ~DIV %~touch表面 の最大な~Y寸法 ) ~MINUS 1
</li>
							<li>
%~z ~LET 0 †
</li>
							<li>
%~w ~LET 1 †
</li>
							<li>
`点を初期化する$( %~touch点, %~x, %~y, %~z, %~w )
</li>
							<li>
%~touch . `position$m ~SET %~touch点
</li>
						</ol>

<p class="trans-note">【†
%~z, %~w 用の値
（二次元な点の~z座標, ~w視座）
は、
この訳による補完。
】</p>
◎
Set touch.position to a new DOMPointReadOnly with x initialized to device X coordinate relative to the device touch surface and normalized to [-1.0,1.0] where -1.0 is the leftmost coordinate and 1.0 is the rightmost coordinate and y initialized to the device touch surface and normalized to [-1.0,1.0] where -1.0 is the leftmost coordinate and 1.0 is the rightmost coordinate.
◎
Note: Possible implementation (if surfaceDimensions are available)
◎
x = (2.0 * touchData.x / surfaceDimensions.width) - 1
◎
Note: Possible implementation (if surfaceDimensions are available)
◎
y = (2.0 * touchData.y / surfaceDimensions.height) - 1
</li>
					<li>
%~gamepad . `touches$sl に %~touch を`付加する$
◎
Add touch to Gamepad.[[touches]].
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="constructing-a-gamepad">
<h3 title="Constructing a Gamepad">3.2. `Gamepad^c の構築-法</h3>

<div class="algo">
<p>
接続された~gamepad装置 %~gamepad装置 を表現している
`新たな~gamepad@
は、
次の手続きを遂行することにより構築される：
◎
A new Gamepad representing a connected gamepad device is constructed by performing the following steps:
</p>
<ol>
	<li>
<p>
%~gamepad ~LET 新たな `Gamepad$I ~instance
— 以下に従って， %~gamepad を初期化する：
◎
Let gamepad be a newly created Gamepad instance:
</p>
		<ol>
			<li>
%~gamepad の `id$m 属性 ~SET %~gamepad装置 用の識別~文字列
◎
Initialize gamepad's id attribute to an identification string for the gamepad.
</li>
			<li>
%~gamepad の `index$m 属性 ~SET %~gamepad 用に`未利用な~gamepad~indexを選定する$()
◎
Initialize gamepad's index attribute to the result of selecting an unused gamepad index for gamepad.
</li>
			<li>
%~gamepad の `mapping$m 属性 ~SET %~gamepad装置 用に`対応付けを選定する$()
◎
Initialize gamepad's mapping attribute to the result of selecting a mapping for the gamepad device.
</li>
			<li>
%~gamepad . `connected$sl ~SET ~T
◎
Initialize gamepad.[[connected]] to true.
</li>
			<li>
%~gamepad . `timestamp$sl ~SET `現在の高分解能~時刻$( 【 %~gamepad に`関連な大域~obj$】 )
◎
Initialize gamepad.[[timestamp]] to the current high resolution time.
</li>
			<li>
%~gamepad . `axes$sl ~SET %~gamepad 用に`各~軸を初期化する$()
◎
Initialize gamepad.[[axes]] to the result of initializing axes for gamepad.
</li>
			<li>
%~gamepad . `buttons$sl ~SET %~gamepad 用に`各~buttonを初期化する$()
◎
Initialize gamepad.[[buttons]] to the result of initializing buttons for gamepad.
</li>
			<li>
%~gamepad . `vibrationActuator$sl ~SET `GamepadHapticActuator$I を`構築する$hA
◎
Initialize gamepad.[[vibrationActuator]] following the steps of constructing a GamepadHapticActuator for gamepad.
</li>
		</ol>
	</li>
	<li>
~RET %~gamepad
◎
Return gamepad.
</li>
</ol>

</div>

<div class="algo">
<p>
%~gamepad 用に
`未利用な~gamepad~indexを選定する@
~algoは：
◎
To select an unused gamepad index for gamepad, run the following steps:
</p>
<ol>
	<li>
%~navigator ~LET %~gamepad に`関連な大域~obj$に`結付けられた~Navigator$
◎
Let navigator be gamepad's relevant global object's Navigator object.
</li>
	<li>
%~gamepad群 ~LET %~navigator . `gamepads$sl
◎
↓</li>
	<li>
<p>
`範囲$ { 0 〜 %~gamepad群 の`~size$ ~MINUS 1 } を成す
~EACH( %~gamepad~index )
に対し
⇒
~IF［
%~gamepad群[ %~gamepad~index ] ~EQ ~NULL
］
⇒
~RET %~gamepad~index
◎
Let maxGamepadIndex be the size of navigator.[[gamepads]] − 1.
◎
For each gamepadIndex of the range from 0 to maxGamepadIndex:
• If navigator.[[gamepads]][gamepadIndex] is null, then return gamepadIndex.
</p></li>
	<li>
%~gamepad群 に ~NULL を`付加する$
◎
Append null to navigator.[[gamepads]].
</li>
	<li>
~RET %~gamepad群 の`~size$ ~MINUS 1
◎
Return the size of navigator.[[gamepads]] − 1.
</li>
</ol>
</div>

<div class="algo">
<p>
%~gamepad 用に
`各~軸を初期化する@
~algoは：
◎
To initialize axes for gamepad, run the following steps:
</p>
<ol>
	<li>
%装置 ~LET %~gamepad により表現される装置
◎
↓</li>
	<li>
%入力~個数 ~LET %装置 により公開される軸~入力の個数
◎
Let inputCount be the number of axis inputs exposed by the device represented by gamepad.
</li>
	<li>
%~gamepad . `axisMinimums$sl ~SET 新たな`~list$
◎
↓</li>
	<li>
%~gamepad . `axisMaximums$sl ~SET 新たな`~list$
◎
↓</li>
	<li>
<p>
~EACH( %~index ~IN { 0 〜 %入力~個数 ~MINUS 1 } )
に対し，昇順に：
</p>
		<ol>
			<li>
%~gamepad . `axisMinimums$sl に次を`付加する$
⇒
%装置 の %~index 番の軸~入力~用の最小な論理-値を与える `unsigned long$c 値
</li>
			<li>
%~gamepad . `axisMaximums$sl に次を`付加する$
⇒
%装置 の %~index 番の軸~入力~用の最大な論理-値を与える `unsigned long$c 値
</li>
		</ol>
◎
Set gamepad.[[axisMinimums]] to a list of unsigned long values with size equal to inputCount containing minimum logical values for each of the axis inputs.
◎
Set gamepad.[[axisMaximums]] to a list of unsigned long values with size equal to inputCount containing maximum logical values for each of the axis inputs.
</li>
	<li>
%~unmapped入力~index~list ~LET 新たな`~list$
◎
Initialize unmappedInputList to be an empty list.
</li>
	<li>
%対応付けた~index~list ~LET 新たな`~list$
◎
Initialize mappedIndexList to be an empty list.
</li>
	<li>
%軸~list~size ~LET 0
◎
Initialize axesSize to be 0.
</li>
	<li>
<p>
~EACH( %生の入力~index ~IN { 0 〜 %入力~個数 ~MINUS 1 } )
に対し：
◎
For each rawInputIndex of the range from 0 to inputCount − 1:
</p>
		<ol>
			<li>
%正準的~index ~LET %装置 の %生の入力~index 番の軸~用の`正準的~index$
◎
↓</li>
			<li>
<p>
~IF［
%正準的~index ~NEQ ε
］~AND［
%正準的~index ~NIN %対応付けた~index~list
］：
◎
If the the gamepad axis at index rawInputIndex represents a Standard Gamepad axis:
• Let canonicalIndex be the canonical index for the axis.
• ↓↓ If mappedIndexList contains canonicalIndex, then append rawInputIndex to unmappedInputList.
• Otherwise:
</p>
				<ol>
					<li>
%~gamepad . `axisMapping$sl[ %生の入力~index ] ~SET %正準的~index
◎
Set gamepad.[[axisMapping]][rawInputIndex] to canonicalIndex.
</li>
					<li>
%対応付けた~index~list に %正準的~index を`付加する$
◎
Append canonicalIndex to mappedIndexList.
</li>
					<li>
~IF［
%軸~list~size ~LTE %正準的~index
］
⇒
%軸~list~size ~SET %正準的~index ~PLUS 1
◎
If canonicalIndex + 1 is greater than axesSize, then set axesSize to canonicalIndex + 1.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%~unmapped入力~index~list に %生の入力~index を`付加する$
◎
Otherwise, append rawInputIndex to unmappedInputList.
</li>
		</ol>
	</li>
	<li>
%軸~index ~LET 0
◎
Initialize axisIndex to be 0.
</li>
	<li>
<p>
%~unmapped入力~index~list を成す
~EACH( %生の入力~index )
に対し：
◎
For each rawInputIndex of unmappedInputList:
</p>
		<ol>
			<li>
~WHILE［
%軸~index ~IN %対応付けた~index~list
］
⇒
%軸~index ~INCBY 1
◎
While mappedIndexList contains axisIndex:
• Increment axisIndex.
</li>
			<li>
%~gamepad . `axisMapping$sl[ %生の入力~index ] ~SET %軸~index
◎
Set gamepad.[[axisMapping]][rawInputIndex] to axisIndex.
</li>
			<li>
%対応付けた~index~list に %軸~index を`付加する$
◎
Append axisIndex to mappedIndexList.
</li>
			<li>
~IF［
%軸~list~size ~LTE %軸~index
］
⇒
%軸~list~size ~SET %軸~index ~PLUS 1
◎
If axisIndex + 1 is greater than axesSize, then set axesSize to axisIndex + 1.
</li>
		</ol>
	</li>
	<li>
%軸~list ~LET 新たな`~list$
◎
Initialize axes to be an empty list.
</li>
	<li>
`範囲$ { 0 〜 %軸~list~size ~MINUS 1 } を成す
~EACH( %軸~index )
に対し
⇒
%軸~list に 0 を`付加する$
◎
For each axisIndex of the range from 0 to axesSize − 1, append 0 to axes.
</li>
	<li>
~RET %軸~list
◎
Return axes.
</li>
</ol>

</div>

<div class="algo">
<p>
%~gamepad 用に
`各~buttonを初期化する@
~algoは：
◎
To initialize buttons for a gamepad, run the following steps:
</p>
<ol>
	<li>
%装置 ~LET %~gamepad により表現される装置
◎
↓</li>
	<li>
%入力~個数 ~LET %~gamepad により表現される装置により公開される~button入力の個数
◎
Let inputCount be the number of button inputs exposed by the device represented by gamepad.
</li>
	<li>
%~gamepad . `buttonMinimums$sl ~SET 新たな`~list$
◎
↓</li>
	<li>
%~gamepad . `buttonMaximums$sl ~SET 新たな`~list$
◎
↓</li>
	<li>
<p>
~EACH( %~index ~IN { 0 〜 %入力~個数 ~MINUS 1 } )
に対し，昇順に：
</p>
		<ol>
			<li>
%~gamepad . `buttonMinimums$sl に次を`付加する$
⇒
%装置 の %~index 番の~button入力~用の最小な論理-値を与える `unsigned long$c 値
</li>
			<li>
%~gamepad . `buttonMaximums$sl に次を`付加する$
⇒
%装置 の %~index 番の~button入力~用の最大な論理-値を与える `unsigned long$c 値
</li>
		</ol>
◎
Set gamepad.[[buttonMinimums]] to be a list of unsigned long values with size equal to inputCount containing minimum logical values for each of the button inputs.
◎
Set gamepad.[[buttonMaximums]] to be a list of unsigned long values with size equal to inputCount containing maximum logical values for each of the button inputs.
</li>
	<li>
%~unmapped入力~index~list ~LET 新たな`~list$
◎
Initialize unmappedInputList to be an empty list.
</li>
	<li>
%対応付けた~index~list ~LET 新たな`~list$
◎
Initialize mappedIndexList to be an empty list.
</li>
	<li>
%~button~list~size ~LET 0
◎
Initialize buttonsSize to be 0.
</li>
	<li>
<p>
~EACH( %生の入力~index ~IN { 0 〜 %入力~個数 ~MINUS 1 })
に対し：
◎
For each rawInputIndex of the range from 0 to inputCount − 1:
</p>
		<ol>
			<li>
%正準的~index ~LET %装置 の %生の入力~index 番の~button用の`正準的~index$
◎
↓</li>
			<li>
<p>
~IF［
%正準的~index ~NEQ ε
］~AND［
%正準的~index ~NIN %対応付けた~index~list
］
◎
If the the gamepad button at index rawInputIndex represents a Standard Gamepad button:
• Let canonicalIndex be the canonical index for the button.
• ↓↓ If mappedIndexList contains canonicalIndex, then append rawInputIndex to unmappedInputList.
◎
• Otherwise:
</p>
				<ol>
					<li>
%~gamepad . `buttonMapping$sl[ %生の入力~index ] ~SET %正準的~index
◎
Set gamepad.[[buttonMapping]][rawInputIndex] to canonicalIndex.
</li>
					<li>
%対応付けた~index~list に %正準的~index を`付加する$
◎
Append canonicalIndex to mappedIndexList.
</li>
					<li>
~IF［
%~button~list~size ~LTE %正準的~index
］
⇒
%~button~list~size ~SET %正準的~index ~PLUS 1
◎
If canonicalIndex + 1 is greater than buttonsSize, then set buttonsSize to canonicalIndex + 1.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
⇒
%~unmapped入力~index~list に %生の入力~index を`付加する$
◎
Otherwise, append rawInputIndex to unmappedInputList.
◎
Increment rawInputIndex.（意味不明
</p>
		</ol>
	</li>
	<li>
%~button~index ~LET 0
◎
Initialize buttonIndex to be 0.
</li>
	<li>
<p>
%~unmapped入力~index~list を成す
~EACH( %生の入力~index )
に対し：
◎
For each rawInputIndex of unmappedInputList:
</p>
		<ol>
			<li>
~WHILE［
%~button~index ~IN %対応付けた~index~list
］
⇒
%~button~index ~INCBY 1
◎
While mappedIndexList contains buttonIndex:
• Increment buttonIndex.
</li>
			<li>
%~gamepad . `buttonMapping$sl[ %生の入力~index ] ~SET %~button~index
◎
Set gamepad.[[buttonMapping]][rawInputIndex] to buttonIndex.
</li>
			<li>
%対応付けた~index~list に %~button~index を`付加する$
◎
Append buttonIndex to mappedIndexList.
</li>
			<li>
~IF［
%~button~list~size ~LTE %~button~index
］
⇒
%~button~list~size ~SET %~button~index ~PLUS 1
◎
If buttonIndex + 1 is greater than buttonsSize, then set buttonsSize to buttonIndex + 1.
</li>
		</ol>
	</li>
	<li>
%~button~list ~LET 新たな`~list$
◎
Initialize buttons to be an empty list.
</li>
	<li>
`範囲$ { 0 〜 %~button~list~size ~MINUS 1 } を成す
~EACH( %~button~index )
に対し
⇒
%~button~list に次の結果を`付加する$
⇒
`新たな~obj$( `GamepadButton$I )
◎
For each buttonIndex of the range from 0 to buttonsSize − 1, append a new GamepadButton to buttons.
</li>
	<li>
~RET %~button~list
◎
Return buttons.
</li>
</ol>

		</div></section>
	</section>
	<section id="gamepadbutton-interface">
<h2 title="GamepadButton Interface">4. `GamepadButton^I ~interface</h2>

<p>
この~interfaceは、
~gamepad装置~上の個々の~buttonの状態を定義する。
◎
This interface defines the state of an individual button on a gamepad device.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `GamepadButton@I {
  readonly attribute `boolean$ `pressed$m;
  readonly attribute `boolean$ `touched$m;
  readonly attribute `double$ `value$m;
};
</pre>

<p>
`GamepadButton$I の各~instanceは、
次に挙げる内部~slotを伴って作成される
（値~型と初期~値~以外の記述は規範的でない）：
◎
Instances of GamepadButton are created with the internal slots described in the following table:
◎
Internal slot｜Initial value｜Description (non-normative)
</p>
<dl>
	<dt>`pressed@sl</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
false｜A flag＼
</dd>
	<dd>
当の~buttonは押されたかどうかを指示する。
◎
indicating that the button is pressed
</dd>

	<dt>`touched@sl</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
false｜A flag＼
</dd>
	<dd>
当の~buttonは~touchされたかどうか指示する。
◎
indicating that the button is touched
</dd>

	<dt>`value@sl</dt>
	<dd>
`double$c 値
— 初期~時は 0.0 とする。
◎
0.0｜A double＼
</dd>
	<dd>
当の~button値を表現する。
0.0 以上 1.0 以下に【！~scale】正規化される。
◎
representing the button value scaled to the range [0.0 .. 1.0]
</dd>
</dl>

<p>
`pressed@m
属性は：
◎
pressed attribute
</p>
<ul>
	<li>
~buttonが押されたかどうかの状態を指示する。
~buttonが現在~押されて［
いるならば~T／
いないならば ~F
］になるモノトスル。
◎
The pressed state of the button.＼
This property MUST be true if the button is currently pressed, and false if it is not pressed.＼
</li>
	<li>
~buttonのうち，［
押された状態, 放された状態
］どちらかのみを指示する~digital~switchを有していないもの用には、
`~UA$は［
~buttonの値が一定量を上回るとき押されたもの
］と指示する，
`~button押圧~閾値@
を選ぶモノトスル。
`~UA$は、
~platform~APIから閾値として推奨される値が与えられて［
いるならば それを利用する／
いないならば 他の何らかの適度な値を選ぶ
］ベキである。
◎
For buttons which do not have a digital switch to indicate a pure pressed or released state, the user agent MUST choose a button press threshold to indicate the button as pressed when its value is above a certain amount. If the platform API gives a recommended value, the user agent SHOULD use that. In other cases, the user agent SHOULD choose some other reasonable value.
</li>
	<li class="algo">
<p>
その取得子~手続きは
⇒
~RET コレ . `pressed$sl
◎
The pressed getter steps are:
• Return this.[[pressed]].
</li>
</ul>

<p>
`touched@m
属性は：
◎
touched attribute
</p>
<ul>
	<li>
<p>
~buttonが~touchされた状態を指示する。
この~propは、
次に従って決定される値をとるモノトスル：
◎
The touched state of the button.＼
</p>
		<ol>
			<li>
当の~buttonには~touchを検出する能力はある場合
⇒
~IS［
当の~buttonは現在~touchされている
］
◎
If the button is capable of detecting touch, this property MUST be true if the button is currently being touched, and false otherwise.＼
</li>
			<li>
他の場合、
当の~buttonには~analog値を報告する能力はある場合
⇒
~IS［
コレの `value$m ~NEQ 0
］
◎
If the button is not capable of detecting touch and is capable of reporting an analog value, this property MUST be true if the value property is greater than 0, and false if the value is 0.＼
</li>
			<li>
他の場合
⇒
コレの `pressed$m 属性の値
◎
If the button is not capable of detecting touch and can only report a digital value, this property MUST mirror the pressed attribute.
</li>
		</ol>
	</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ . `touched$sl
◎
The touched getter steps are:
• Return this.[[touched]].
</li>
</ul>

<p>
`value@m
属性は：
◎
value attribute
</p>
<ul>
	<li>
~buttonが~analog~sensorを有する場合、
押されている量【~~押圧など】を表現するモノトスル。
~button値は［
0.0 以上, 1.0 以下
］に線形に正規化し，［
0.0 ／ 1.0
］は全部的に［
押されていない／押されている
］ことを意味するモノトスル。
◎
For buttons that have an analog sensor, this property MUST represent the amount which the button has been pressed. All button values MUST be linearly normalized to the range [0.0 .. 1.0]. 0.0 MUST mean fully unpressed, and 1.0 MUST mean fully pressed.＼
</li>
	<li>
~buttonが~analog~sensorを有さない場合、
押されているかどうかに応じて，値［
0.0 ／ 1.0
］のみを供するモノトスル。
◎
For buttons without an analog sensor, only the values 0.0 and 1.0 for fully unpressed and fully pressed respectively, MUST be provided.
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ . `value$sl
◎
The value getter steps are:
• Return this.[[value]].
</li>
</ul>

	</section>
	<section id="gamepadtouch-interface">
<h2 title="GamepadTouch Interface ">5. `GamepadTouch^I ~interface</h2>

<p>
この~interfaceは、
~touchを~supportする~gamepadの~touch表面~上の ある~touchを定義する。
この~objの `touchId$m 属性は、
入力~媒体（例： 手指, ~stylus, 等々）が接触した時点から接触しなくなる時点まで，当の~touch点を一意に識別する。
◎
This interface defines a touch on a gamepad's touch surface that supports such input. The object consists of a touch touchId that uniquely identifies the touch point from the time the input medium (e.g. finger, stylus, etc) makes contact with the touch device, up to the time the input medium is no longer making contact with the touch device.
</p>

<p class="trans-note">【
言い換えれば，~touchとは入力~媒体の 1 回の接触であり、
同じ~touchから生成される `GamepadTouch$I ~objたちは，同じ `touchId^m 値を共有する。
】</p>

<pre class="idl">
interface【！dictionary】 `GamepadTouch@I {
  `unsigned long$ `touchId$m;
  `octet$ `surfaceId$m;
  `DOMPointReadOnly$I `position$m;
  `DOMRectReadOnly$I? `surfaceDimensions$m;
};
</pre>

<dl>
	<dt>
`touchId@m
◎
touchId attribute 
</dt>
	<dd>
当の~touchを一意に識別する~ID
— `32 ~bitな無符号~整数$。
◎
Unique id of the touch. Range is [0, 4294967295].
</dd>
	<dt>
`surfaceId@m
◎
surfaceId
</dt>
	<dd>
当の~touchを生成した表面を一意に識別する~ID
— `8 ~bitな無符号~整数$。
◎
Unique id of the surface that generated the touch.
</dd>

	<dt>
`position@m
◎
position
</dt>
	<dd>
<p>
当の~touch点の座標を保持する `DOMPointReadOnly$I ~obj
— その：
</p>
		<ul>
			<li>
［
`x$m, `y$m
］属性は、
範囲 −1.0 以上, 1.0 以下に正規化される。
~x軸における［
−1.0 ／ 1.0
］は当の~touch表面の［
~~左端／~~右端
］の座標に対応する。
~y軸における［
−1.0 ／ 1.0
］は当の~touch表面の［
~~上端／~~下端
］の座標に対応する。
</li>
			<li>
［
`z$m, `w$m
］属性は、
現時点では利用されない。
</li>
		</ul>
◎
A DOMPointReadOnly which holds the x, y coordinates of the touch.＼
The z and w value are currently unused.＼
The range of each coordinate is normalized to [-1.0, 1.0]. Along the x-axis, -1.0 references the leftmost coordinate and 1.0 references the rightmost coordinate. Along the y-axis, -1.0 references the topmost coordinate and 1.0 references the bottommost coordinate.
</dd>

	<dt>
`surfaceDimensions@m
◎
surfaceDimensions
</dt>
	<dd>
当の~touch表面の寸法を保持する `DOMRectReadOnly$I ~obj
— その［
`width$m ／ `height$m
］は、
当の~touch表面の整数~単位による［
横幅／縦幅
］で初期化される。
◎
A DOMRectReadOnly initialized with the width and height of the touch surface in integer units.＼
</dd>
	<dd>
可用でない場合は ~NULL になる。
◎
If not available then null.
</dd>
</dl>

	</section>
	<section id="gamepadmappingtype-enum">
<h2 title="GamepadMappingType enum">6. `GamepadMappingType^I 列挙</h2>

<p>
この列挙は、
~Gamepad用の既知な対応付けたちが成す集合を定義する。
◎
This enum defines the set of known mappings for a Gamepad.
</p>

<pre class="idl">
enum `GamepadMappingType@I {
  `""＠#dom-gamepadmappingtype-the-empty-string$,
  `standard$l,
  `xr-standard$l,
};
</pre>

<dl class="idl-def">
	<dt id="dom-gamepadmappingtype-the-empty-string">""</dt>
	<dd>
空~文字列は、
この~gamepad用に利用-中にある対応付けは無いことを指示する。
◎
The empty string indicates that no mapping is in use for this gamepad.
</dd>

	<dt id="dfn-standard">`standard@l</dt>
	<dd>
~gamepadを成す各~controlは、
`標準~gamepad$の~layoutに対応付けられている。
◎
The Gamepad's controls have been mapped to the Standard Gamepad layout.
</dd>

	<dt id="dfn-xr-standard">`xr-standard@l</dt>
	<dd>
~gamepadを成す各~controlは、［
`xr-standard^l ~gamepad用の`対応付け＠~XRGAMEPAD#xr-standard-gamepad-mapping$
］に対応付けられている。
この対応付けは、
`~WebXR~gamepad~module＠~XRGAMEPAD$cite【！~level 1】
による利用~用に予約される。
`getGamepads()$m が返す値を成す各 `Gamepad$I は、
`xr-standard^l の対応付けを報告してはナラナイ。
◎
The Gamepad's controls have been mapped to the "xr-standard" gamepad mapping. This mapping is reserved for use by the WebXR Gamepads Module - Level 1. Gamepads returned by getGamepads() MUST NOT report a mapping of "xr-standard".
</dd>
</dl>

	</section>
	<section id="gamepadhapticactuator-interface">
<h2 title="GamepadHapticActuator Interface">7. `GamepadHapticActuator^I ~interface</h2>

<p>
`GamepadHapticActuator$I は、［
触覚-~feedbackの目的で~forceを適用できる~motorその他の作動器
］の環境設定に対応する。
◎
A GamepadHapticActuator corresponds to a configuration of motors or other actuators that can apply a force for the purposes of haptic feedback.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `GamepadHapticActuator@I {
  [`SameObject$] readonly attribute `FrozenArray$&lt;`GamepadHapticEffectType$I&gt; `effects$m;
  `Promise$&lt;`GamepadHapticsResult$I&gt; `playEffect$m(
      `GamepadHapticEffectType$I type,
      optional `GamepadEffectParameters$I params = {}
  );
  `Promise$&lt;`GamepadHapticsResult$I&gt; `reset$m();
};
</pre>

<p>
`GamepadHapticActuator$I の各~instanceは、
次に挙げる内部~slotを伴って作成される
（値~型と初期~値~以外の記述は規範的でない）：
◎
Instances of GamepadHapticActuator are created with the internal slots described in the following table:
◎
Internal slot｜Initial value｜Description (non-normative)
</p>

<dl>
	<dt>`effects@sl</dt>
	<dd>
`GamepadHapticEffectType$I たちが成す`~list$
— 初期~時は空とする。
◎
An empty list of GamepadHapticEffectType.
</dd>
	<dd>
当の作動器が~supportする効果たちを表現する。
◎
Represents the effects supported by the actuator.
</dd>

	<dt>`playingEffectPromise@sl</dt>
	<dd>
~promise ／
~NULL
— 初期~時は ~NULL とする。
◎
null｜The Promise＼
</dd>
	<dd>
何らかの効果を再生するための~promise。
そのような効果は無い場合は ~NULL になる。
◎
to play some effect, or null if no effect is playing.
</dd>
</dl>

<p>
`effects@m
属性は：
◎
effects attribute
</p>
<ul>
	<li>
`GamepadHapticEffectType$I 値たちが成す配列を返す
— それは、［
当の作動器が~supportする触覚-効果のうち，その再生を`~UA$が~supportするもの
］すべての種別を表現する。
◎
Array of GamepadHapticEffectType values representing all the types of haptic effects that the actuator supports. This property lists the GamepadHapticEffectType values that the actuator supports, unless the user agent does not support playing effects of that type.
</li>
	<li class="algo">
その取得子~手続きは
⇒
~RET コレ . `effects$sl
◎
The effects getter steps are:
• Return this.[[effects]].
</li>
</ul>

<div class="algo">
<p>
`playEffect(type, params)@m
~method手続きは：
◎
playEffect() method
• The playEffect() method steps, called with GamepadHapticEffectType type and GamepadEffectParameters params, are:
</p>
<ol>
	<li>
~IF［
%type 用に`妥当な効果を述べるか否か検査する$( %params ) ~EQ ~F
］
⇒
~RET `却下される~promise$( `TypeError$E )
◎
If params does not describe a valid effect of type type, return a promise rejected with a TypeError.
</li>
	<li>
%文書 ~LET `現在の設定群~obj$に`関連な大域~obj$に`結付けられた文書$
◎
Let document be the current settings object's relevant global object's associated Document.
</li>
	<li>
~IF［
%文書 ~EQ ~NULL【！余計？】
］~OR［
%文書 は`全部的に作動中$でない
］~OR［
%文書 の`可視性~状態$doc ~EQ `hidden^l
］
⇒
~RET `却下される~promise$( `InvalidStateError$E 例外 )
◎
If document is null or document is not fully active or document's visibility state is "hidden", return a promise rejected with an "InvalidStateError" DOMException.
</li>
	<li>
%効果~promise ~LET コレ . `playingEffectPromise$sl
◎
↓</li>
	<li>
<p>
~IF［
%効果~promise ~NEQ ~NULL
］：
◎
If this.[[playingEffectPromise]] is not null:
• Let effectPromise be this.[[playingEffectPromise]].
</p>
		<ol>
			<li>
コレ . `playingEffectPromise$sl ~SET ~NULL
◎
Set this.[[playingEffectPromise]] to null.
</li>
			<li>
<p>
`大域~taskを~queueする$( `~gamepad~task~source$, コレに`関連な大域~obj$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %効果~promise, `preempted$l )
</div>
◎
Queue a global task on the relevant global object of this using the gamepad task source to resolve effectPromise with "preempted".
</li>
		</ol>
	</li>
	<li>
~IF［
%type ~NIN コレ . `effects$sl
【！コレの~gamepadの作動器は %type による`効果を再生でき$ない】
］
⇒
~RET `却下される~promise$( `NotSupportedError$E 例外 )
◎
If this's gamepad's actuator cannot play effects with type type, return a promise rejected with reason NotSupportedError.
</li>
	<li>
`playingEffectPromise$sl ~LET `新たな~promise$()
◎
Let [[playingEffectPromise]] be a new promise.
</li>
	<li>
%再生-効果~時刻印 ~LET `現在の高分解能~時刻$( %文書 に`関連な大域~obj$ )
◎
Let playEffectTimestamp be the current high resolution time given the document's relevant global object.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Do the following steps in parallel:
</p>
		<ol>
			<li>
当の作動器に対し，`触覚-効果を発行する$( %type, %params, %再生-効果~時刻印 )
◎
Issue a haptic effect to the actuator with type, params, and the playEffectTimestamp.
</li>
			<li>
効果が完了するまで待機する
◎
When the effect completes,＼
</li>
			<li>
<p>
~IF［
コレ . `playingEffectPromise$sl ~NEQ ~NULL
］
⇒
`大域~taskを~queueする$( `~gamepad~task~source$, コレに`関連な大域~obj$, 次の手続き )
◎
if this.[[playingEffectPromise]] is not null, queue a global task on the relevant global object of this using the gamepad task source to run＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
				<ol>
					<li>
~IF［
コレ . `playingEffectPromise$sl ~EQ ~NULL
］
⇒
~RET
◎
If this.[[playingEffectPromise]] is null, abort these steps.
</li>
					<li>
`~promiseを解決する$( コレ . `playingEffectPromise$sl, `complete$l )
◎
Resolve this.[[playingEffectPromise]] with "complete".
</li>
					<li>
コレ . `playingEffectPromise$sl ~SET ~NULL
◎
Set this.[[playingEffectPromise]] to null.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET `playingEffectPromise$sl
◎
Return [[playingEffectPromise]].
</li>
</ol>
</div>

<div class="algo">
<p>
`reset()@m
~method手続きは：
◎
reset() method
• The reset() method steps are:
</p>
<ol>
	<li>
%文書 ~LET `現在の設定群~obj$に`関連な大域~obj$に`結付けられた文書$
◎
Let document be the current settings object's relevant global object's associated Document.
</li>
	<li>
~IF［
%文書 ~EQ ~NULL【！余計？】
］~OR［
%文書 は`全部的に作動中$でない
］~OR［
%文書 の`可視性~状態$doc ~EQ `hidden^l
］
⇒
~RET `却下される~promise$( `InvalidStateError$E 例外 )
◎
If document is null or document is not fully active or document's visibility state is "hidden", return a promise rejected with an "InvalidStateError" DOMException.
</li>
	<li>
%~reset結果~promise ~LET `新たな~promise$()
◎
Let resetResultPromise be a new promise.
</li>
	<li>
<p>
~IF［
コレ . `playingEffectPromise$sl ~NEQ ~NULL
］
⇒
次の手続きを`並列的$に遂行する
◎
If this.[[playingEffectPromise]] is not null, do the following steps in parallel:
</p>
<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li>
%効果~promise ~LET コレ . `playingEffectPromise$sl
◎
Let effectPromise be this.[[playingEffectPromise]].
</li>
			<li>
コレの~gamepadの作動器に対し，`触覚-効果を停止する$ 
◎
Stop haptic effects on this's gamepad's actuator.
</li>
			<li>
<p>
~IF［
当の効果は成功裡に停止された
］：
◎
If the effect has been successfully stopped, do:
</p>
				<ol>
					<li>
~IF［
%効果~promise ~EQ コレ . `playingEffectPromise$sl
］
⇒
コレ . `playingEffectPromise$sl ~SET ~NULL
◎
If effectPromise and this.[[playingEffectPromise]] are still the same, set this.[[playingEffectPromise]] to null.
</li>
					<li>
<p>
`大域~taskを~queueする$( `~gamepad~task~source$, コレに`関連な大域~obj$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %効果~promise, `preempted$l )
</div>
◎
Queue a global task on the relevant global object of this using the gamepad task source to resolve effectPromise with "preempted".
</li>
				</ol>
			</li>
			<li>
`~promiseを解決する$( %~reset結果~promise, `complete$l )
◎
Resolve resetResultPromise with "complete"
</li>
		</ol>
</div>
	</li>
	<li>
~RET %~reset結果~promise
◎
Return resetResultPromise.
</li>
</ol>
</div>

<p>
`GamepadHapticActuator$I %作動器 が
所与の %種別 による
`効果を再生でき@
るとは、
次が満たされることをいう
⇒
%種別 ~IN %作動器. `effects$sl
◎
A GamepadHapticActuator can play effects with type type if type can be found in the [[effects]] list.
</p>

<p class="trans-note">【
この訳では、
この用語を利用せず，
単に “%種別 ~IN %作動器. `effects$sl” と記すことにする。
】</p>


<p>
各 `GamepadHapticEffectType$I 用には、
~parameter群が
`妥当な効果を述べるか否か検査する@
手続きが定義される
— それは、
所与の
( `GamepadEffectParameters$I %~params )
に対し，真偽値を返す。
◎
To check if an effect with GamepadHapticEffectType type and GamepadEffectParameters params describes a valid effect, run the following steps:
↓↓ • Given the value of GamepadHapticEffectType type, switch on:
•• "dual-rumble"
••• If params does not describe a valid dual-rumble effect, return false.
•• "trigger-rumble"
••• If params does not describe a valid trigger-rumble effect, return false.
• Return true
</p>

<p>
`~UA$は，作動器に対し
`触覚-効果を発行する@
~algoは、
所与の
( %種別, %~params, %再生-効果~時刻印 )
に対し：
◎
To issue a haptic effect on an actuator,＼
</p>
<ul>
	<li>
%種別 が成す効果を具現化するための~commandを装置へ送信するモノトスル
— それに伴い， %~params を利用させるよう試行するモノトスル。
◎
the user agent MUST send a command to the device to render an effect of type and try to make it use the provided params.＼
</li>
	<li>
［
%~params［ "`startDelay$mb" ］ ~NEQ 0.0
］ならば、
より精確な再生n計時~用に %再生-効果~時刻印 を利用するベキである。
◎
The user agent SHOULD use the provided playEffectTimestamp for more precise playback timing when params.startDelay is not 0.0.＼
</li>
	<li>
互換性を高めるためとして，当の効果を改変してもヨイ。
例えば、［
~rumble~motorを欠如するが，波形~触覚-効果を~supportする装置
］用には，~rumble~motor用に意図された効果を波形に基づく効果に変形してもよい。
◎
The user agent MAY modify the effect to increase compatibility. For example, an effect intended for a rumble motor may be transformed into a waveform-based effect for a device that supports waveform haptics but lacks rumble motors.
</li>
</ul>

<p>
`~UA$は，
作動器に対し
`触覚-効果を停止する@
~algoは：
◎
To stop haptic effects on an actuator,＼
</p>
<ul>
	<li>
現在~再生している効果がある場合、
それを中止する~commandを当の装置へ送信するモノトスル。
◎
the user agent MUST send a command to the device to abort any effects currently being played.＼
</li>
	<li>
当の作動器は、
触覚-効果が中断された場合には，アリな限り素早く動きが無い状態へ返るベキである。
◎
If a haptic effect was interrupted, the actuator SHOULD return to a motionless state as quickly as possible.
</li>
</ul>

		<section id="handling-visibility-change">
<h3 title="Handling visibility change">7.1 可視性~変化の取扱い</h3>

<div class="algo">
<p>
%文書 の`可視性~状態$docが `hidden^l になったときは、
~EACH( `GamepadHapticActuator$I %作動器 )
に対し，次の手続きを走らす：
◎
When the document's visibility state becomes "hidden", run these steps for each GamepadHapticActuator actuator:
</p>
<ol>
	<li>
~IF［
%作動器 . `playingEffectPromise$sl ~EQ ~NULL
］
⇒
~RET
◎
If actuator.[[playingEffectPromise]] is null, abort these steps.
</li>
	<li>
<p>
`大域~taskを~queueする$( `~gamepad~task~source$, %作動器 に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the relevant global object of actuator using the gamepad task source to run＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li>
~IF［
%作動器 . `playingEffectPromise$sl ~EQ ~NULL
］
⇒
~RET
◎
If actuator.[[playingEffectPromise]] is null, abort these steps.
</li>
			<li>
`~promiseを解決する$( %作動器 . `playingEffectPromise$sl, `preempted$l )
◎
Resolve actuator.[[playingEffectPromise]] with "preempted".
</li>
			<li>
%作動器 . `playingEffectPromise$sl ~SET ~NULL
◎
Set actuator.[[playingEffectPromise]] to null.
</li>
		</ol>
</div>
	</li>
	<li>
`触覚-効果を停止する$( %作動器 )
◎
Stop haptic effects on actuator.
</li>
</ol>
</div>

		</section>
		<section id="constructing-a-gamepadhapticactuator">
<h3 title="Constructing a GamepadHapticActuator">7.2. `GamepadHapticActuator^I の構築-法</h3>

<div class="algo">
<p>
`Gamepad$I の首な振動~作動器 %作動器 を表現している新たな `GamepadHapticActuator$I
を
`構築する@hA
~algoは：
◎
A new gamepadHapticActuator representing a Gamepad's primary vibration actuator is constructed by performing the following steps:
</p>
<ol>
	<li>
%~gamepad触覚-作動器 ~LET `新たな~obj$( `GamepadHapticActuator$I )
◎
Let gamepadHapticActuator be a newly created GamepadHapticActuator instance.
</li>
	<li>
%~supportされる効果~群 ~LET 新たな`~list$
◎
Let supportedEffectsList be an empty list.
</li>
	<li>
`GamepadHapticEffectType$I を成す
~EACH( 列挙~値 %種別 )
に対し
⇒
~IF［
`~UA$は %作動器 に対し %種別 用の効果を起動する~commandを送信できる
］
⇒
%~supportされる効果~群 に %種別 を`付加する$
◎
For each enum value type of GamepadHapticEffectType, if the user agent can send a command to initiate effects of that type on that actuator, append type to supportedEffectsList.
</li>
	<li>
%~gamepad触覚-作動器 . `effects$sl ~SET %~supportされる効果~群
◎
Set gamepadHapticActuator.[[effects]] to supportedEffectsList.
</li>
</ol>
</div>


		</section>
	</section>
	<section id="gamepadhapticsresult-enum">
<h2 title="GamepadHapticsResult Enum">8. `GamepadHapticsResult^I 列挙</h2>

<pre class="idl">
enum `GamepadHapticsResult@I {
  `complete@l,
  `preempted@l
};
</pre>
<dl>
	<dt>`complete$l</dt>
	<dd>
触覚-効果の再生を完了した。
◎
The haptic effected completed playing.
</dd>
	<dt>`preempted@l
</dt>
	<dd>
現在の効果は、
停止されたか，別の効果により置換された（すなわち “先取りされた” ）。
◎
The current effect was stopped or replaced (i.e., "preempted") by another effect.
</dd>
</dl>

	</section>
	<section id="gamepadhapticeffecttype-enum">
<h2 title="GamepadHapticEffectType enum">9. `GamepadHapticEffectType^I 列挙</h2>

<p>
効果~種別は、［
効果~parameterが作動器によりどう解釈されるか
］を定義する。
◎
The effect type defines how the effect parameters are interpreted by the actuator.
</p>

<pre class="idl">
enum `GamepadHapticEffectType@I {
  `dual-rumble$l,
  `trigger-rumble$l
};
</pre>

<dl>
	<dt>
`dual-rumble@l
◎
"dual-rumble" effect type
</dt>
	<dd>
触覚-環境設定を［
標準~gamepadを成す各~handleにおける~ERM
（ `eccentric rotating mass^en, 偏心回転質量）
振動~motor
］で述べる。
この環境設定においては，［
どちらの~motorも，~gamepad全体を振動させる能力があるが、
作成される振動~効果は，それぞれに異なる
］ので、
組合せることで，より複階的な触覚-効果を作成できる。
◎
"dual-rumble" describes a haptic configuration with an eccentric rotating mass (ERM) vibration motor in each handle of a standard gamepad. In this configuration, either motor is capable of vibrating the whole gamepad. The vibration effects created by each motor are unequal so that the effects of each can be combined to create more complex haptic effects.
</dd>
	<dd>
<p>
`dual-rumble$l 効果は、［
ある固定的な所要時間において，強度が一定
］な［
この種別の作動器~用に意図された振動~効果
］であり，［
`startDelay$mb,
`duration$mb,
`strongMagnitude$mb,
`weakMagnitude$mb
］により定義される
— これらは：
◎
A "dual-rumble" effect is a fixed-duration, constant-intensity vibration effect intended for an actuator of this type. "dual-rumble" effects are defined by startDelay, duration, strongMagnitude, and weakMagnitude,＼
</p>
		<ul>
			<li>
既定では 0 をとるので，要求されない。
◎
none of which are required because they default to 0.
</li>
			<li>
うち［
`strongMagnitude$mb ／ `weakMagnitude$mb
］は、［
低-頻度／高-頻度
］な振動~用に強度~levelを設定する
— それは、
範囲 0 以上 1 以下に正規化され，
既定では 0 になる。
◎
strongMagnitude and weakMagnitude set the intensity levels for the low-frequency and high-frequency vibrations, normalized to the range [0,1], defaulting to 0.
</li>
		</ul>
	</dd>
	<dd class="algo" id="dfn-valid-dual-rumble-effect">
<p>
`dual-rumble$l 用に`妥当な効果を述べるか否か検査する$ときは、
所与の
( `GamepadEffectParameters$I %~params )
に対し
⇒
~RET ~IS ~AND↓：
</p>
		<ul>
			<li>
%~params[ "`duration$mb" ] は妥当である†
</li>
			<li>
%~params[ "`startDelay$mb" ] は妥当である†
</li>
			<li>
%~params[ "`strongMagnitude$mb" ] は 0 以上 1 以下である
</li>
			<li>
%~params[ "`weakMagnitude$mb" ] は 0 以上 1 以下である
</li>
		</ul>

<p class="trans-note">【†
これらの “妥当” が何を意味するかは、
原文には述べられていない
（原文では、
`妥当な効果を述べるか否か検査する$を参照していて，循環している）。
実際には、
次節に述べられる “最大” 以下を意味すると思われる。
】</p>
◎
Given GamepadEffectParameters params, a valid dual-rumble effect must have a valid duration, a valid startDelay, and both the strongMagnitude and the weakMagnitude must be in the range [0,1].
</dd>

	<dt>
`trigger-rumble@l
◎
"trigger-rumble" effect type
</dt>
	<dd>
触覚-環境設定を［
`dual-rumble$l 用に利用される 2 個の~handle~motorに加えて，
標準~gamepadを成す［
左下, 右下
］前面~button（`正準的~index$ 6, 7 ）における振動~motor
］で述べる。
これらの~buttonに最も共通的な形は、
~spring-loaded引金である。
この環境設定においては、
どちらの~motorも，~button表面に局所~化された触覚-~feedbackを供する能力がある。
◎
"trigger-rumble" describes a haptics configuration with a vibration motor in each of the bottom front buttons of a Standard Gamepad (buttons with canonical indices 6 and 7) in addition to the two handle motors used for "dual-rumble". These buttons most commonly take the form of spring-loaded triggers. In this configuration, either motor is capable of providing localized haptic feedback on the button's surface.
</dd>
	<dd>
<p>
`trigger-rumble$l 効果は、［
ある固定的な所要時間において，強度が一定
］な［
この種別の作動器~用に意図された振動~効果
］であり，［
`startDelay$mb,
`duration$mb,
`strongMagnitude$mb,
`weakMagnitude$mb,
`leftTrigger$mb,
`rightTrigger$mb
］により定義される
— これらは：
◎
A "trigger-rumble" effect is a fixed-duration, constant-intensity vibration effect intended for an actuator of this type. "trigger-rumble" effects are defined by startDelay, duration, strongMagnitude, weakMagnitude, leftTrigger, and rightTrigger,＼
</p>
		<ul>
			<li>
いずれも、
既定では 0 をとるので，要求されない。
◎
none of which are required because they default to 0.
</li>
			<li>
うち［
`startDelay$mb ／ `duration$mb ／ `strongMagnitude$mb ／ `weakMagnitude$mb
］は、
`dual-rumble$l と同じ定義を共有する。
◎
startDelay, duration, strongMagnitude, weakMagnitude share the same definition with "dual-rumble".＼
</li>
			<li>
うち［
`leftTrigger$mb ／ `rightTrigger$mb
］は、［
左下／右下
］前面~buttonの振動~用に強度~levelを設定する
— それは、
範囲 0 以上 1 以下に正規化され，
既定では 0 になる。
◎
leftTrigger and rightTrigger, respectively, set the intensity levels for the left and right bottom front buttons vibrations, normalized to the range [0,1], defaulting to 0.
</li>
		</ul>
	</dd>
	<dd class="algo" id="dfn-valid-trigger-rumble-effect">
<p>
`trigger-rumble$l 用に`妥当な効果を述べるか否か検査する$ときは、
所与の
( `GamepadEffectParameters$I %~params )
に対し
⇒
~RET ~IS ~AND↓：
</p>
		<ul>
			<li>
%~params[ "`duration$mb" ] は妥当である†
</li>
			<li>
%~params[ "`startDelay$mb" ] は妥当である†
</li>
			<li>
%~params[ "`strongMagnitude$mb" ] は 0 以上 1 以下である
</li>
			<li>
%~params[ "`weakMagnitude$mb" ] は 0 以上 1 以下である
</li>
			<li>
%~params[ "`leftTrigger$mb" ] は 0 以上 1 以下である
</li>
			<li>
%~params[ "`rightTrigger$mb" ] は 0 以上 1 以下である
</li>
		</ul>

<p class="trans-note">【†
これらの “妥当” が何を意味するかは、
`dual-rumble$l のときと同じく，原文には述べられていない。
】</p>
◎
Given GamepadEffectParameters params, a valid trigger-rumble effect must have a valid duration, a valid startDelay, and the strongMagnitude, weakMagnitude, leftTrigger, and rightTrigger must be in the range [0,1].
</dd>
</dl>

	</section>
	<section id="gamepadeffectparameters-dictionary">
<h2 title="GamepadEffectParameters Dictionary">10. `GamepadEffectParameters^I 辞書</h2>

<p>
`GamepadEffectParameters^I 辞書は、
触覚-効果に利用される~parameter用の~keyたちを包含する。
各~keyの意味は、
当の触覚-効果【の種別】により定義される。
一部の~keyは、
利用されないこともある。
◎
A GamepadEffectParameters dictionary contains keys for parameters used by haptic effects. The meaning of each key is defined by the haptic effect, and some keys may be unused.
</p>

<p>
無用に長く稼働する効果を軽減するため、
`~UA$は，`妥当な効果＠#dfn-valid-effect$用の所要時間を何らかの最大までに制限してもヨイ。
`~UA$には、
最大として 5 秒を利用することが推奨される。
◎
To mitigate unwanted long-running effects, the user agent MAY limit the total effect duration for a valid effect to some maximum duration. It is RECOMMENDED that the user agent use a maximum of 5 seconds.
</p>

<pre class="idl">
dictionary `GamepadEffectParameters@I {
    `unsigned long long$ `duration$mb = 0;
    `unsigned long long$ `startDelay$mb = 0;
    `double$ `strongMagnitude$mb = 0.0;
    `double$ `weakMagnitude$mb = 0.0;
    `double$ `leftTrigger$mb = 0.0;
    `double$ `rightTrigger$mb = 0.0;
};
</pre>
<dl>
	<dt>
`duration@mb
◎
duration member
</dt>
	<dd>
当の振動~効果の所要時間を~milli秒数で設定する。
◎
duration sets the duration of the vibration effect in milliseconds.
</dd>
	<dt>
`startDelay@mb
◎
startDelay member
</dt>
	<dd>
［
`playEffect()$m が~callされてから振動が開始されるまで
］の遅延を成す所要時間を~milli秒数で設定する。
当の作動器は、
遅延されている間は，振動するベキでない。
◎
startDelay sets the duration of the delay after playEffect() is called until vibration is started, in milliseconds. During the delay interval, the actuator SHOULD NOT vibrate.
</dd>
	<dt>
`strongMagnitude@mb
◎
strongMagnitude member
</dt>
	<dd>
［
`dual-rumble$l ／ `trigger-rumble$l
］効果における低-頻度な~rumble用の振動の大きさ。
◎
The vibration magnitude for the low frequency rumble in a "dual-rumble" or "trigger-rumble" effect.
</dd>
	<dt>
`weakMagnitude@mb
◎
weakMagnitude member
</dt>
	<dd>
［
`dual-rumble$l ／ `trigger-rumble$l
］効果における高-頻度な~rumble用の振動の大きさ。
◎
The vibration magnitude for the high frequency rumble in a "dual-rumble" or "trigger-rumble" effect.
</dd>

	<dt>
`leftTrigger@mb
◎
leftTrigger member
</dt>
	<dd>
`trigger-rumble$l 効果における［
左下~前面~button（`正準的~index$ 6 ）の~rumble
］用の振動の大きさ。
◎
The vibration magnitude for the bottom left front button (canonical index 6) rumble in a "trigger-rumble" effect.
</dd>

	<dt>
`rightTrigger@mb
◎
rightTrigger member
</dt>
	<dd>
`trigger-rumble$l 効果における［
右下~前面~button（`正準的~index$ 7 ）の~rumble
］用の振動の大きさ。
◎
The vibration magnitude for the bottom right front button (canonical index 6) rumble in a "trigger-rumble" effect.
</dd>
</dl>

	</section>
	<section id="extensions-to-the-navigator-interface">
<h2 title="Extensions to the Navigator interface">11. `Navigator^I ~interfaceに対する拡張</h2>

<pre class="idl">
[`Exposed$=Window]
partial interface `Navigator$I {
  `sequence$&lt;`Gamepad$I?&gt; `getGamepads$m();
};
</pre>

<p>
`Navigator$I の各~instanceは、
次に挙げる内部~slotを伴って作成される
（値~型と初期~値~以外の記述は規範的でない）：
◎
Instances of Navigator are created with the internal slots described in the following table:
◎
Internal slot｜Initial value｜Description (non-normative)
</p>

<dl>
	<dt>`hasGamepadGesture@sl</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
false｜A flag＼
</dd>
	<dd>
`~gamepad利用者~gesture$は観測されたかどうかを指示する。
◎
indicating that a gamepad user gesture has been observed
</dd>

	<dt>`gamepads@sl</dt>
	<dd>
［
`Gamepad$I ／ ~NULL
］たちが成す`連列$
— 初期~時は空とする。
◎
A empty sequence of Gamepad? objects｜＼
</dd>
	<dd>
この %連列 を成す各 `Gamepad$I %~gamepad は、
次を満たすことになる
⇒
%連列[ %~gamepad の `index$m 属性 ] ~EQ %~gamepad
◎
Each Gamepad present at the index specified by its index attribute, or null for unassigned indices.
</dd>
</dl>

		<section id="getgamepads-method">
<h3 title="getGamepads() method">11.1. `getGamepads()@m ~method</h3>

<p class="note">注記：
この~methodが返す~gamepad状態は、［
`gamepaddisconnected$et ／ `gamepadconnected$et
］~eventが発火されるまで，切断か接続かを反映しない。
◎
The gamepad state returned from getGamepads() does not reflect disconnection or connection until after the gamepaddisconnected or gamepadconnected events have fired.
</p>

<p class="note">注記：
指紋収集を軽減するため、
`getGamepads()$m が返す`連列$を成す~gamepadは、［
`~gamepad利用者~gesture$が一回以上は生じたもの
］に限られる。
`FINGERPRINTING-GUIDANCE$r
◎
To mitigate fingerprinting, getGamepads() returns an empty list before a gamepad user gesture has been seen. [FINGERPRINTING-GUIDANCE]
</p>

<div class="example" id="example-1">
<p>
`getGamepads()$m は、［
現在，接続されていて, ヤリトリしている各~gamepad用の~data
］が成す~snapshotを返す。
ある~gamepad %~gamepad が接続されなくなったときは、
この~methodが返す連列を成す［
%~gamepad の~index
］番の~itemは ~NULL になるべきである。
次の~code片にて、［
接続された~gamepadが 1 個だけあって，その~index ~EQ 1 の場合
］に期待される挙動を述べる：
◎
Example 1
getGamepads() returns a snapshot of the data for the currently connected and interacted-with gamepads. When a gamepad is no longer connected, its index in the array should return null. If there is one connected gamepad with an index of 1, then the following code snippet describes the expected behavior:
</p>

<pre class="lang-js">/* <span class="comment">
%gamepads は `[null, [object Gamepad]]^c の様になるベキである。
◎
gamepads should look like [null, [object Gamepad]]
</span> */
var %gamepads = navigator.getGamepads();
/* <span class="comment">
次のどの言明も， ~T に評価されるべきである：
◎
The following statements should all evaluate to true.
</span> */
%gamepads[0] == null;
%gamepads[1].index == 1;
%gamepads.length == 2;
</pre>
</div>

<div class="algo">
<p>
`getGamepads()$m ~method手続きは：
◎
The getGamepads() method steps are:
</p>
<ol>
	<li>
%文書 ~LET `現在の大域~obj$に`結付けられた文書$
◎
Let doc be the current global object's associated Document. 
</li>
	<li>
~IF［
%文書 ~EQ ~NULL【！余計？】
］~OR［
%文書 は`全部的に作動中$でない
］
⇒
~RET 新たな`~list$
◎
If doc is null or doc is not fully active, then return an empty list.
</li>
	<li>
~IF［
%文書 には `gamepad$l 特能【！permission】の`利用は許容されて$いない
］
⇒
~THROW `SecurityError$E
◎
If doc is not allowed to use the "gamepad" permission, then throw a "SecurityError" DOMException and abort these steps.
</li>
	<li>
~IF［
コレ . `hasGamepadGesture$sl ~EQ ~F
］
⇒
~RET 新たな`~list$
◎
If this.[[hasGamepadGesture]] is false, then return an empty list.
</li>
	<li>
%今 ~LET `現在の高分解能~時刻$( 【 %文書 に`関連な大域~obj$】 )
◎
Let now be the current high resolution time.
</li>
	<li>
%~gamepad群 ~LET 新たな`~list$
◎
Let gamepads be an empty list.
</li>
	<li>
<p>
コレ . `gamepads$sl を成す
~EACH( %~gamepad )
に対し：
◎
For each gamepad of this.[[gamepads]]:
</p>
		<ol>
			<li>
<p>
~IF［
%~gamepad ~NEQ ~NULL
］~AND［
%~gamepad . `exposed$sl ~EQ ~F
］：
◎
If gamepad is not null and gamepad.[[exposed]] is false:
</p>
				<ol>
					<li>
%~gamepad . `exposed$sl ~SET ~T
◎
Set gamepad.[[exposed]] to true.
</li>
					<li>
%~gamepad . `timestamp$sl ~SET %今
◎
Set gamepad.[[timestamp]] to now.
</li>
				</ol>
			</li>
			<li>
%~gamepad群 に %~gamepad を`付加する$
◎
Append gamepad to gamepads.
</li>
		</ol>
	</li>
	<li>
~RET %~gamepad群
◎
Return gamepads.
</li>
</ol>
</div>

<p>
%~gamepad は、［
現在の入力~状態は、
利用者は当の~gamepadと現在ヤリトリしていることを指示する
］ならば
`~gamepad利用者~gestureを包含する@
とされる。
`~UA$は［
当の入力~状態が ある~gamepad利用者~gestureを包含するかどうか
］を検査する~algoを供するモノトスル：
◎
A gamepad contains a gamepad user gesture if the current input state indicates that the user is currently interacting with the gamepad.＼
The user agent MUST provide an algorithm to check if the input state contains a gamepad user gesture.＼
</p>
<ul>
	<li>
次に該当する~buttonにおける `pressed$m 値 ~T は、
ヤリトリと見なされるベキである
⇒
中立な既定の値を~supportしていて†、
`pressed$m 値 ~F を 1 回でも報告したもの。
【† 利用者がヤリトリしていない間は、放された状態（ ~F ）になるもの。】
◎
For buttons that support a neutral default value and have reported a pressed value of false at least once, a pressed value of true SHOULD be considered interaction.＼
</li>
	<li>
<p>
次のいずれかに該当する~buttonにおける `pressed$m 値 ~T は、
ヤリトリと見なされるベキでない：
</p>
		<ul>
			<li>
中立な既定の値を~supportしないもの（例えば，~toggle~switch ）
【利用者がヤリトリしていなくても、押された状態／放された状態が持続するもの。】
</li>
			<li>
`pressed$m 値 ~F を 1 回も報告していないもの
</li>
		</ul>
◎
If a button does not support a neutral default value (for example, a toggle switch), then a pressed value of true SHOULD NOT be considered interaction. If a button has never reported a pressed value of false then it SHOULD NOT be considered interaction.＼
</li>
	<li>
軸の運動は、
次が満たされるならば，ヤリトリと見なされるベキである
⇒
［
当の軸は中立な既定の値を~supportする
］~AND［
中立からの現在の変位は`~UA$が選んだ閾値を超える
］~AND［
当の軸は， 1 回は閾値を下回る値を報告した
］
◎
Axis movements SHOULD be considered interaction if the axis supports a neutral default value, the current displacement from neutral is greater than a threshold chosen by the user agent, and the axis has reported a value below the threshold at least once.＼
</li>
	<li>
<p>
次のいずれかに該当する軸は、
ヤリトリの有無を検査する際に考慮しないベキである：
</p>
		<ul>
			<li>
中立な既定の値を~supportしないもの
（例：~joystick用の軸であって `self-center^en でないもの【中心に戻らないもの】）
</li>
			<li>
閾値を下回る値を 1 回も報告していないもの
</li>
		</ul>
<p>
軸~gesture用の閾値は、［
~randomな揺らぎはヤリトリと見なされないような，十分な大きさ
］にするベキである。
</p>
◎
If an axis does not support a neutral default value (for example, an axis for a joystick that does not self-center), or an axis has never reported a value below the axis gesture threshold, then the axis SHOULD NOT be considered when checking for interaction.＼
The axis gesture threshold SHOULD be large enough that random jitter is not considered interaction.
</li>
</ul>

		</section>
	</section>
	<section id="gamepadevent-interface">
<h2 title="GamepadEvent Interface">12. `GamepadEvent^I ~interface</h2>

<pre class="idl">
[`Exposed$=Window]
interface `GamepadEvent@I: `Event$I {
  `constructor＠~DOM4#concept-event-constructor$(`DOMString$ %type, `GamepadEventInit$I %eventInitDict);
  [`SameObject$] readonly attribute `Gamepad$I `gamepad$m;
};
</pre>

<p>
`gamepad@m
属性は、
この~event用に結付けらている~gamepad~dataへの~accessを供する。
◎
gamepad
• The gamepad attribute provides access to the associated gamepad data for this event.
</p>

		<section id="gamepadeventinit-dictionary">
<h3 title="GamepadEventInit dictionary">12.1. `GamepadEventInit^I 辞書</h3>

<pre class="idl">
dictionary `GamepadEventInit@I : `EventInit$I {
  required `Gamepad$I `gamepad$mb;
};
</pre>

<p>
`gamepad@mb
~memberは、
当の~eventに結付けられる `Gamepad$I を与える。
◎
gamepad member
• The gamepad associated with this event.
</p>

		</section>
	</section>
	<section id="remapping">
<h2 title="Remapping">13. 対応付直法</h2>

<p>
各~装置の製造元は、
多くの異なる製品を作成する
— そのそれぞれが、［
~button／軸
］の［
~style, ~layout
］として~~固有のものを有する。
`~UA$は、
これらのうち，アリな限り多くを~supportするものと意図される。
◎
Each device manufacturer creates many different products and each has unique styles and layouts of buttons and axes. It is intended that the user agent support as many of these as possible.
</p>

<p>
加えて、
~game~consoleにより~~普及し，`事実上の標準^emになった~layoutがある。
`~UA$は、
装着された装置を認識するときは，［
アリなときは，正準的な順序付けへ対応付直す／
認識できない装置であっても，生の形で公開する
］ことが推奨される。
◎
Additionally there are de facto standard layouts that have been made popular by game consoles. When the user agent recognizes the attached device, it is RECOMMENDED that it be remapped to a canonical ordering when possible. Devices that are not recognized should still be exposed in their raw form.
</p>

<p>
正準的な~layoutは、
現時点では
`標準~gamepad@
（ `Standard Gamepad^en ）
1 つしかない。
対応付直すときは、［
`axes$m, `buttons$m
］内の各~indexは，
下に与える図式における物理的な所在にアリな限り近く対応するベキである。
加えて、
`mapping$m を `standard$l に設定するベキである。
◎
There is currently one canonical layout, the Standard Gamepad. When remapping, the indices in axes and buttons should correspond as closely as possible to the physical locations in the diagram below. Additionally, mapping SHOULD be set to "standard".
</p>

<p>
`標準~gamepad$を成す各~buttonは、
次に挙げるものに~lay-outされる：
◎
The Standard Gamepad buttons are laid out in＼
</p>
<ul>
	<li>
左~clusterを成す 4 個の~button
◎
a left cluster of four buttons,＼
</li>
	<li>
右~clusterを成す 4 個の~button
◎
a right cluster of four buttons,＼
</li>
	<li>
中央~clusterを成す 3 個の~button
◎
a center cluster of three buttons,＼
</li>
	<li>
~gamepadの~~前方に面した【利用者から見て奥側】, 左右各側に 2 個ずつある~button
◎
and a pair of front facing buttons on the left and right side of the gamepad.＼
</li>
</ul>

<p>
`標準~gamepad$を成す 4 個の軸は、
左右各側にある~analog~stickに 2 軸ずつ結付けられる。
◎
The four axes of the "Standard Gamepad" are associated with a pair of analog sticks, one on the left and one on the right.＼
</p>

<p>
下の表tに、
`標準~gamepad$を成す各［
~button ／ 軸
］, その物理的な所在を述べる。
◎
The following table describes the buttons/axes and their physical locations.
</p>

<p>
所与の［
軸／~button
］入力の
`正準的~index@
は、
当の［
軸／~button
］が`標準~gamepad$の ある［
軸／~button
］を “表現する” ならば，後者の［
軸／~button
］の~index（下の表tを見よ）、
他の場合は ε とする†。
ここでの “表現する” かどうかは、
次に従う：
◎
↓</p>
<ul>
	<li>
<p>
軸~入力は、
次を満たすならば，
`標準~gamepad軸を表現する@
とされる
⇒
ある~thumbstick軸【すなわち，物理的な~stick】用の入力~値を報告していて、［
当の~thumbstickの所在は，対応している`標準~gamepad$の ある軸とほぼ同じである（下の図）
］かつ［
当の軸の方位（上下／左右）は`標準~gamepad$の軸の方位に合致する
］
◎
An axis input represents a Standard Gamepad axis if it reports the input value for a thumbstick axis, the thumbstick is located in approximately the same location as the corresponding Standard Gamepad thumbstick, and the orientation of the axis (up-down or left-right) matches the orientation of the Standard Gamepad axis.＼
</p>

<p>
`標準~gamepad$の同じ軸を表現する軸が複数ある場合、
`~UA$は，［
それらのうち一つを`標準~gamepad$の軸として選定した上で，
他の軸には異なる~indexをアテガう
］ベキである。
◎
If there are multiple axes that represent the same Standard Gamepad axis, then the user agent SHOULD select one to be the Standard Gamepad axis and assign a different index to the other axis.
</p>
	</li>
	<li>
<p>
~button入力は、
次を満たすならば
`標準~gamepad~buttonを表現する@
とされる
⇒
ある~button（あるいは引金）用の入力~値を報告していて，
当の~buttonの所在は、
対応する`標準~gamepad$の ある~buttonとほぼ同じである（下の図）。
◎
A button input represents a Standard Gamepad button if it reports the input value for a button or trigger, and the button or trigger is located in approximately the same location as the corresponding Standard Gamepad button.
◎
↑If an axis or button input represents a Standard Gamepad axis or button, then its canonical index is the index of the corresponding Standard Gamepad axis or button.
</li>
</ul>

<p class="trans-note">【†
“他の場合は ε” は、
他所を簡潔に述べるための，この訳による追加。
】</p>

<div>
<table><thead>
<tr><th>種別
<th>~index
<th>所在
<tbody>

<tr><td rowspan="17">~button
<td>0
<td>右~cluster内の下~button

<tr><td>1
<td>右~cluster内の右~button

<tr><td>2
<td>右~cluster内の左~button

<tr><td>3
<td>右~cluster内の上~button

<tr><td>4
<td>前面~左上~button

<tr><td>5
<td>前面~右上~button

<tr><td>6
<td>前面~左下~button

<tr><td>7
<td>前面~右下~button

<tr><td>8
<td>中央~cluster内の左~button（ “select” ／ “back” ）

<tr><td>9
<td>中央~cluster内の右~button（ “start” ／ “forward” ）

<tr><td>10
<td>左~stickに一体化された~button

<tr><td>11
<td>右~stickに一体化された~button

<tr><td>12
<td>左~cluster内の上~button

<tr><td>13
<td>左~cluster内の下~button

<tr><td>14
<td>左~cluster内の左~button

<tr><td>15
<td>左~cluster内の右~button

<tr><td>16
<td>中央~cluster内の中央~button

<tr><td rowspan="4">軸
<td>0
<td>左~stick用の水平-軸（左側は負／右側は正）

<tr><td>1
<td>左~stick用の垂直-軸（上側は負／下側は正）

<tr><td>2
<td>右~stick用の水平-軸（左側は負／右側は正）

<tr><td>3
<td>右~stick用の垂直-軸（上側は負／下側は正）
</table>

◎
Button｜0｜Bottom button in right cluster
｜1｜Right button in right cluster
｜2｜Left button in right cluster
｜3｜Top button in right cluster
｜4｜Top left front button
｜5｜Top right front button
｜6｜Bottom left front button
｜7｜Bottom right front button
｜8｜Left button in center cluster
｜9｜Right button in center cluster
｜10｜Left stick pressed button
｜11｜Right stick pressed button
｜12｜Top button in left cluster
｜13｜Bottom button in left cluster
｜14｜Left button in left cluster
｜15｜Right button in left cluster
｜16｜Center button in center cluster
axes｜0｜Horizontal axis for left stick (negative left/positive right)
｜1｜Vertical axis for left stick (negative up/positive down)
｜2｜Horizontal axis for right stick (negative left/positive right)
｜3｜Vertical axis for right stick (negative up/positive down) 
</div>

<figure id="fig-visual-representation-of-a-standard-gamepad-layout">
<figcaption id="_dgm-standard_gamepad">
`標準~gamepad$の~layoutの視覚的な表現。
角括弧付き~~数字は、
~button~index。
丸囲み~~数字は、
軸~index
— 黒塗り（白抜き）は負側／その逆塗りは正側。
◎
Figure 1
Visual representation of a Standard Gamepad layout.
</figcaption></figure>

		<section id="fingerprinting-mitigation">
<h3 title="Fingerprinting mitigation">13.1. 指紋収集の軽減</h3>

<p>
`Gamepad$I ~objの能力を検分することは、
能動的な指紋収集の手段として利用され得る。
~UAは、
~APIを通して公開される装置~情報を，指紋収集~表口を抑制するよう改めてもヨイ。
例えば，実装は、
`Gamepad$I ~objが有する［
~button, 軸
］の個数を`標準~gamepad$の~layoutにて定義されるものと正確に同じにするよう要求できる
— 当の接続された装置に在る入力は，もっと［
多い／少ない
］場合でも。
`FINGERPRINTING-GUIDANCE$r
◎
Inspecting the capabilities of Gamepad objects can be used as a means of active fingerprinting. The user agent MAY alter the device information exposed through the API to reduce the fingerprinting surface. As an example, an implementation can require that a Gamepad object have exactly the number of buttons and axes defined in the Standard Gamepad layout even if more or fewer inputs are present on the connected device. [FINGERPRINTING-GUIDANCE]
</p>

		</section>
	</section>
	<section id="usage-examples">
<h2 title="Usage Examples">14. 用法~例</h2>

◎非規範的

<div class="example" id="example-2">

<p>
代表的な~gamepadへの~accessを，次の例にデモる。
`requestAnimationFrame()$m ~methodとの関係性に注意。
◎
The example below demonstrates typical access to gamepads. Note the relationship with the requestAnimationFrame() method.
◎
Example 2
</p>

<pre class="lang-js">function %runAnimation() {
    window.requestAnimationFrame(%runAnimation);
    for (const %pad of navigator.getGamepads()) {
      /* <span class="issue comment">
%pad`.axes^c, %pad`.buttons^c を表示する単純なデモをここに記す
◎
todo; simple demo of displaying pad.axes and pad.buttons
</span> */
      console.log(%pad);
    }
}

window.requestAnimationFrame(%runAnimation);
</pre>
</div>

<div class="practice advisement" id="practice-timing">
<p>
最善な実施：
`requestAnimationFrame()^m との協調
◎
Best Practice 1： Coordination with requestAnimationFrame()
</p>
<p class="practicedesc">
`requestAnimationFrame()$m ~methodを利用しているヤリトリありな~appは、
概して，~animationを駆動して，~animationを利用者の~gamepad入力と協調したいと求めることになる。
そのようなわけで，~gamepad~dataは、
アリな限り~animation~callbackが実行される直前近くに~pollして，
~animationの更新周期に合致させるベキである。
すなわち，~animation~callbackが 60Hz で稼働しているなら、
~gamepad入力も，その~rateで標本化されるベキである。
◎
Interactive applications will typically be using the requestAnimationFrame() method to drive animation, and will want coordinate animation with user gamepad input. As such, the gamepad data should be polled as closely as possible to immediately before the animation callbacks are executed, and with frequency matching that of the animation. That is, if the animation callbacks are running at 60Hz, the gamepad inputs should also be sampled at that rate.
</p>
</div>

	</section>
	<section id="the-gamepadconnected-event">
<h2 id="event-gamepadconnected" title="The gamepadconnected event">15. `gamepadconnected@et ~event</h2>

<div class="algo">
<p>
ある~gamepad装置 %~gamepad装置 が~system上で可用になったときは、
次の手続きを走らす：
◎
When a gamepad becomes available on the system, run the following steps:
</p>
<ol>
	<li>
%文書 ~LET `現在の大域~obj$に`結付けられた文書$
— 他の場合【？】は ~NULL
◎
Let document be the current global object's associated Document; otherwise null.
</li>
	<li>
~IF［
%文書 ~NEQ ~NULL
］~AND［
%文書 には `gamepad$l 特能【！permission】の`利用は許容されて$いない
］
⇒
~RET
◎
If document is not null and is not allowed to use the "gamepad" permission, then abort these steps.
</li>
	<li>
<p>
`~taskを~queueする$( `~gamepad~task~source$, 次の手続き )
◎
Queue a task on the gamepad task source to perform the following steps:
</p>

<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
%~gamepad ~LET %~gamepad装置 を表現している`新たな~gamepad$()
◎
Let gamepad be a new Gamepad representing the gamepad.
</li>
			<li>
%~navigator ~LET %~gamepad に`関連な大域~obj$に`結付けられた~Navigator$
◎
Let navigator be gamepad's relevant global object's Navigator object.
</li>
			<li>
%~navigator . `gamepads$sl[ %~gamepad . `index$m ] ~SET %~gamepad
◎
Set navigator.[[gamepads]][gamepad.index] to gamepad.
</li>
			<li>
<p>
~IF［
%~navigator . `hasGamepadGesture$sl ~EQ ~T
］：
◎
If navigator.[[hasGamepadGesture]] is true:
</p>
				<ol>
					<li>
%~gamepad . `exposed$sl ~SET ~T
◎
Set gamepad.[[exposed]] to true.
</li>
					<li>
~IF［
%文書 ~NEQ ~NULL
］~AND［
%文書 は`全部的に作動中$である
］
⇒
`~eventを発火する$( %~gamepad に`関連な大域~obj$, `gamepadconnected$et, `GamepadEvent$I )
— 次のように初期化して
⇒
`gamepad$m 属性 ~SET %~gamepad
◎
If document is not null and is fully active, then fire an event named gamepadconnected at gamepad's relevant global object using GamepadEvent with its gamepad attribute initialized to gamepad.
</li>
				</ol>
			</li>
		</ol>
</div>
	</li>
</ol>
</div>

<p>
この仕様を実装している~UAは、
`gamepadconnected$et と命名される新たな~DOM~eventを供するモノトスル。
対応する~eventは、［
`GamepadEvent$I ~interfaceを利用する, および
`Window$I ~objに向けて発火する
］モノトスル。
◎
User agents implementing this specification must provide a new DOM event, named gamepadconnected. The corresponding event MUST be of type GamepadEvent and MUST fire on the Window object.
</p>

<p>
`~UA$は，利用者が~gamepadを接続したときは、
`gamepadconnected$et ~eventを配送して，それを指示するモノトスル。
~pageが読込まれた時点で，~gamepadはすでに接続されていた場合、
利用者が~buttonを押すか軸を動かしたとき，この~eventを配送するベキである。
◎
A user agent MUST dispatch this event type to indicate the user has connected a gamepad. If a gamepad was already connected when the page was loaded, the gamepadconnected event SHOULD be dispatched when the user presses a button or moves an axis.
</p>

	</section>
	<section id="the-gamepaddisconnected-event">
<h2 id="event-gamepaddisconnected" title="The gamepaddisconnected event">16. `gamepaddisconnected@et ~event</h2>

<div class="algo">
<p>
ある~gamepadが~system上で可用でなくなったときは、
次の手続きを走らす：
◎
When a gamepad becomes unavailable on the system, run the following steps:
</p>
<ol>
	<li>
%~gamepad ~LET 可用でなくなった装置を表現している `Gamepad$I
◎
Let gamepad be the Gamepad representing the unavailable device.
</li>
	<li>
<p>
`~taskを~queueする$( `~gamepad~task~source$, 次の手続き )
◎
Queue a task on the gamepad task source to perform the following steps:
</p>

<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
%~gamepad . `connected$sl ~SET ~F
◎
Set gamepad.[[connected]] to false.
</li>
			<li>
%文書 ~LET %~gamepad に`関連な大域~obj$に`結付けられた文書$
— 他の場合【？】は ~NULL
◎
Let document be gamepad's relevant global object's associated Document; otherwise null.
</li>
			<li>
~IF［
%~gamepad . `exposed$sl ~EQ ~T
］~AND［
%文書 ~NEQ ~NULL
］~AND［
%文書 は`全部的に作動中$である
］
⇒
`~eventを発火する$( %~gamepad に`関連な大域~obj$, `gamepaddisconnected$et, `GamepadEvent$I )
— 次のように初期化して
⇒
`gamepad$m 属性 ~SET %~gamepad
◎
If gamepad.[[exposed]] is true and document is not null and is fully active, then fire an event named gamepaddisconnected at gamepad's relevant global object using GamepadEvent with its gamepad attribute initialized to gamepad.
</li>
			<li>
%~navigator ~LET %~gamepad に`関連な大域~obj$に`結付けられた~Navigator$
◎
Let navigator be gamepad's relevant global object's Navigator object.
</li>
			<li>
%~gamepad群 ~LET %~navigator . `gamepads$sl
◎
↓</li>
			<li>
%~gamepad群[ %~gamepad . `index$m ] ~SET ~NULL
◎
Set navigator.[[gamepads]][gamepad.index] to null.
</li>
			<li>
~WHILE［
%~gamepad群 は`空$でない
］~AND［
%~gamepad群 を成す最後の`~item$ ~EQ ~NULL
］
⇒
%~gamepad群 から最後の`~item$を`除去する$
◎
While navigator.[[gamepads]] is not empty and the last item of navigator.[[gamepads]] is null, remove the last item of navigator.[[gamepads]].
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<p>
この仕様を実装している~UAは、
`gamepaddisconnected$et と命名される新たな~DOM~eventを供するモノトスル。
対応する~eventは、［
`GamepadEvent$I ~interfaceを利用する, および
`Window$I ~objに向けて発火する
］モノトスル。
◎
User agents implementing this specification must provide a new DOM event, named gamepaddisconnected. The corresponding event MUST be of type GamepadEvent and MUST fire on the Window object.
</p>

<p>
`~UA$は，~gamepadが切断されたときは、［
以前に，その~gamepad用の `gamepadconnected$et ~eventを `Window$I に向けて配送していた
］ならば，同じ `Window$I に向けて `gamepaddisconnected$et ~eventを配送するモノトスル。
◎
When a gamepad is disconnected from the user agent, if the user agent has previously dispatched a gamepadconnected event for that gamepad to a Window, a gamepaddisconnected event MUST be dispatched to that same Window.
</p>

	</section>
	<section id="other-events">
<h2 title="Other events">17. 他の~event</h2>

<p>
軸や~buttonの変化-用の~eventも含めるかどうか，もっと論が必要である。
含める場合、
それらを一緒に転がすか（ `gamepadchanged^et ？），または［
多少，あるいは［
軸／~button
］ごとに個別に
］分離するか（ `gamepadaxischanged^et ？）についても。
◎
More discussion needed, on whether to include or exclude axis and button changed events, and whether to roll them more together ("gamepadchanged"?), separate somewhat ("gamepadaxischanged"?), or separate by individual axis and button.
</p>

	</section>
	<section id="extensions-to-the-windoweventhandlers-interface-mixin">
<h2 title="Extensions to the WindowEventHandlers Interface Mixin">18. `WindowEventHandlers^I ~interface~mixinに対する拡張</h2>

<p>
この仕様は、
~HTMLの `WindowEventHandlers$I ~interface~mixinを拡張して，
~event~handlerの登録を手助けするための`~event~handler~IDL属性$を追加する。
◎
This specification extends the WindowEventHandlers interface mixin from HTML to add event handler IDL attributes to facilitate the event handler registration.
</p>

<pre class="idl">
partial interface mixin `WindowEventHandlers$I {
  attribute `EventHandler$I `ongamepadconnected@m;
  attribute `EventHandler$I `ongamepaddisconnected@m;
};
</pre>

<p class="trans-note">【
名前から明らかなように、
順に［
`gamepadconnected$et, `gamepaddisconnected$et
］~event用。
】</p>

	</section>
	<section id="permission-policy">
<h2 title="Integration with Permissions Policy">19. 許可~施策との統合</h2>

<p>
この仕様は、
文字列
`gamepad@l
で識別される`施策により制御される特能$を定義する。
その`既定の許容list$は、
`全~生成元$i とする。
◎
This specification defines a policy-controlled feature identified by the string "gamepad". Its default allowlist is *.
</p>

<p class="note">注記：
`文書$ %文書 の`許可~施策$docは、［
%文書 内の内容には、
`getGamepads()$m への~accessは許容されるかどうか
］を決定する。
%文書 内で不能化された場合、［
%文書 内のどの内容にも `getGamepads()$m の`利用は許容され$ない
］ことに加え，［
`gamepadconnected$et ／ `gamepaddisconnected$et
］~eventは発火されない。
◎
Note
A document’s permissions policy determines whether any content in that document is allowed to access getGamepads(). If disabled in any document, no content in the document will be allowed to use getGamepads(), nor will the gamepadconnected and gamepaddisconnected events fire.
</p>

	</section>
	<section id="a-acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

◎非規範的

<p>
この文書の開発に貢献された次に挙げる方々に：
◎
The following people contributed to the development of this document.
</p>

<div lang="en">
David Humphrey,
Gregg Tavares,
Marcin Wichary,
Jason Orendorff,
Olli Pettay,
Rick Waldron,
Anssi Kostiainen,
Arthur Barstow,
autokagami,
Bradley Needham,
Brandon Jones,
Chris Wilson,
Christopher Van,
ddorwin,
fernando-80,
fernando-sony,
James,
Johanna,
Kagami Sascha Rosylight,
Kelvin Yong,
kri,
Marcos Cáceres,
Michael Blix,
Mike Taylor,
Philip Jägenstedt,
Philippe Le Hegaret,
Raphael Kubo da Costa,
Scott Graham,
Sid Vishnoi,
Stephen Niedzielski,
Ted Mielczarek,
Vincent Scheib,
Xiaoqian Wu,
Yves Lafon
</div>

<p class="trans-note">【
各氏に伴われる~link先は、
省略する（原文を参照されたし）。
】</p>

	</section>
</main></div>
