<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Painting API Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[~\w\-一-鿆あ-ん]+|`(.+?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'm': // IDL member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 't': // type
	text = `&lt;${key}&gt;`;
	break;
case 'f': // 
	text = `${key}()`;
	break;
case 'l':
	return `"<code class="literal">${text}</code>"`;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'sl': // internal slot
	text = `[[${key}]]`;
	break;
case 'issue':
	return(
`<a href="https://github.com/w3c/css-houdini-drafts/issues/${key}">課題 #${key}</a>`
	);
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return text;

	}
}
</script>


<script type="text/plain" id="_source_data">

●●options
spec_title:CSS Painting API Level 1
spec_date:2020-12-15
trans_update:2020-12-18
source_checked:101016
original_url:https://drafts.css-houdini.org/css-paint-api-1/
page_state_key:CSS
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:cssom,css
conformance:css
copyright:2020,permissive
trans_1st_pub:2019-01-02


●●class_map
p:property
v:value
u:unit
f:func
t:type
u:unit
css:css
e:element
a:attr
E:error
sl:js-slot
jv:js-value
jC:js-class
jA:abstract

●●tag_map
p:code
f:code
u:code
v:code
t:var
I:code
m:code
E:code
e:code
u:code
a:code
css:code
c:code
sl:span
jC:span
jv:code
jA:span
i:i
em:em
V:var

●●original_id_map

●●mdn_urls
funcdef-paint:CSS/image/paint()

	paintworkletglobalscope:API/PaintWorkletGlobalScope
	paintrenderingcontext2d:API/PaintRenderingContext2D
	dictdef-paintrenderingcontext2dsettings:API/PaintRenderingContext2DSettings
	paintsize:API/PaintSize

●●link_map
	●IDL

undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
double:~WEBIDL#idl-double
unrestricted double:~WEBIDL#idl-unrestricted-double
VoidFunction:~WEBIDL#VoidFunction
DOMString:~WEBIDL#idl-DOMString
I.Function:~WEBIDL#Function

Exposed:~WEBIDLjs#Exposed
Global:~WEBIDLjs#Global
SameObject:~WEBIDLjs#SameObject

E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror
E.InvalidModificationError:~WEBIDL#invalidmodificationerror

I.PaintWorkletGlobalScope:#paintworkletglobalscope
I.PaintRenderingContext2DSettings:#dictdef-paintrenderingcontext2dsettings
I.PaintRenderingContext2D:#paintrenderingcontext2d
I.PaintSize:#paintsize

I.CSS:~CSSOM1#namespacedef-css
I.CSSImageValue:~CSSTOM1#cssimagevalue
I.CanvasCompositing:~HEcanvas#canvascompositing
I.CanvasDrawImage:~HEcanvas#canvasdrawimage
I.CanvasDrawPath:~HEcanvas#canvasdrawpath
I.CanvasFillStrokeStyles:~HEcanvas#canvasfillstrokestyles
I.CanvasImageData:~HEcanvas#canvasimagedata
I.CanvasImageSmoothing:~HEcanvas#canvasimagesmoothing
I.CanvasImageSource:~HEcanvas#canvasimagesource
I.CanvasPath:~HEcanvas#canvaspath
I.CanvasPathDrawingStyles:~HEcanvas#canvaspathdrawingstyles
I.CanvasRect:~HEcanvas#canvasrect
I.CanvasRenderingContext2D:~HEcanvas#canvasrenderingcontext2d
I.CanvasRenderingContext2DSettings:~HEcanvas#canvasrenderingcontext2dsettings
I.CanvasShadowStyles:~HEcanvas#canvasshadowstyles
I.CanvasState:~HEcanvas#canvasstate
I.CanvasText:~HEcanvas#canvastext
I.CanvasTextDrawingStyles:~HEcanvas#canvastextdrawingstyles
I.CanvasTransform:~HEcanvas#canvastransform
I.CanvasUserInterface:~HEcanvas#canvasuserinterface
I.StylePropertyMap:~CSSTOM1#stylepropertymap
I.StylePropertyMapReadOnly:~CSSTOM1#stylepropertymapreadonly
I.Worklet:~WORKLETS#worklet
I.WorkletGlobalScope:~WORKLETS#workletglobalscope
I.DOMException:~WEBIDL#idl-DOMException


m.paintWorklet:#dom-css-paintworklet
m.devicePixelRatio:#dom-paintworkletglobalscope-devicepixelratio
m.alpha:#dom-paintrenderingcontext2dsettings-alpha
m.registerPaint:#dom-paintworkletglobalscope-registerpaint
m.width:#dom-paintsize-width
m.height:#dom-paintsize-height

	m.devicePixelRatio:~CSSOMVIEW#dom-window-devicepixelratio
m.drawImage:~HEcanvas#dom-context-2d-drawimage
m.clip:~HEcanvas#dom-context-2d-clip

	name:#dom-paintworkletglobalscope-registerpaint-name-paintctor-name
	paintCtor:#dom-paintworkletglobalscope-registerpaint-name-paintctor-paintctor

m.registerProperty:~CSSPV1#dom-css-registerproperty
m.addModule:~WORKLETS#dom-worklet-addmodule

	●p
p.border-image:~CSSBG#propdef-border-image
p.cursor:~CSSUI#propdef-cursor

f.paint:#funcdef-paint
t.declaration-value:~CSSSYN#typedef-declaration-value
t.ident:~CSSVAL#typedef-ident
t.image:~CSSIMAGE#typedef-image

	●CSSPAINT
その時点の具象-~obj~size:#_snapped-concrete-object-size

塗り定義:#paint-definition
塗り定義~map:#paint-definitions
pD.~class構築子:#paint-definition-class-constructor
pD.塗り関数:#paint-definition-paint-function
pD.構築子は妥当か:#paint-definition-constructor-valid-flag
pD.入力~prop~list:#paint-definition-input-properties
pD.塗り~2D描画~文脈~設定群:#paint-definition-paintrenderingcontext2dsettings-object
pD.塗り~class~instance~map:#paint-class-instances

文書~塗り定義:#document-paint-definition
文書~塗り定義~map:#document-paint-definitions
dPD.入力~prop~list:#document-paint-definition-input-properties
dPD.入力~引数~構文:#document-paint-definition-input-argument-syntaxes
dPD.塗り~2D描画~文脈~設定群:#document-paint-definition-paintrenderingcontext2dsettings-object

出力~bitmap:#paintrenderingcontext2d-output-bitmap
~alpha~flag:#paintrenderingcontext2d-alpha
塗り~2D描画~文脈を作成する:#create-a-paintrenderingcontext2d-object
塗り関数の画像を描く:#draw-a-paint-image
塗り~callbackを呼出す:#invoke-a-paint-callback

	#global-scope-selection

	●外部

~list:~INFRA#list
空にする:~INFRA#list-empty
空:~INFRA#list-is-empty
付加する:~INFRA#list-append
有順序~map:~INFRA#ordered-map
構造体:~INFRA#struct

jA.Construct:~TC39#sec-construct
jA.Get:~TC39#sec-get-o-p
jA.IsConstructor:~TC39#sec-isconstructor
jA.Type:~TC39#sec-ecmascript-data-types-and-values
~class構築子:~TC39#sec-constructor
	jA.get:~TC39#sec-get-o-p

~IDL値に変換する:~WEBIDLjs#dfn-convert-javascript-to-idl-value
	誤:~WEBIDLjs#web-idl-arguments-list-converting
	誤:~WEBIDLjs#dfn-convert-idl-to-javascript-value
~callback関数を呼出す:~WEBIDLjs#invoke-a-callback-function
~callback関数:~WEBIDL#dfn-callback-function
	~callback this 値:~WEBIDLjs#dfn-callback-this-value
	~THROW:~WEBIDL#dfn-throw

文書:~DOM4#concept-document

sl.declarations:~CSSTOM1#dom-stylepropertymapreadonly-declarations-slot

~worklet大域~scopeを作成する:~WORKLETS#create-a-worklet-global-scope
~worklet大域~scope型:~WORKLETS#worklet-global-scope-type
wL.大域~scope~list:~WORKLETS#concept-worklet-global-scopes
wL.~worklet行先~種別:~WORKLETS#worklet-destination-type

構文~定義:~CSSPV1#syntax-definition
構文~定義を消費する:~CSSPV1#consume-a-syntax-definition
~supportされる構文~文字列:~CSSPV1#supported-syntax-strings

~taskを~queueする:~WAPI#queue-a-task
並列的:~HTMLINFRA#in-parallel

無効な画像:~CSSIMAGE4#invalid-image
具象-~obj~size:~CSSIMAGE#concrete-object-size
生来な寸法:~CSSIMAGE#natural-dimensions
~obj~size折衝~algo:~CSSIMAGE#object-size-negotiation

~box:~CSSDISP#box

算出d値:~CASCADE#computed-value

~custom~prop:~CSSVAR#custom-property

~supportされる~CSS~prop:~CSSOM1#supported-css-property

透明な黒:~CSSCOLOR#transparent-black
不透明な黒:~CSSCOLOR#opaque-black

~bitmap寸法を設定する:~HEcanvas#concept-canvas-set-bitmap-dimensions
既定の状態に設定し直す:~HEcanvas#reset-the-rendering-context-to-its-default-state

	https://github.com/w3c/css-houdini-drafts/blob/main/css-paint-api/EXPLAINER.md
	~CSSIMAGE#object-sizing-examples
	~WORKLETS#worklets-idempotent
	https://drafts.css-houdini.org/css-paint-api-1/issues-list-2018-04-10

●●words_table1

SeqDS:<code>sequence&lt;DOMString&gt;</code>

●●words_table

	●データ型／操作
換算-:convert::~

	^en:dispose
	初期化-:initialise
	取り除く:filter
	絞り込む:filter

	●IDL
prototype:
typedef:
worklet:

WebGL:
WebAnimations:Web Animations
WorkletGlobalScope:
PaintRenderingContext2DSettings:
PaintRenderingContext2D:

	●一般処理
無力化-:neuter::~
冪等性:idempotence::~
例外投出あり:exception が throw され得る::~
	例外投出あり:If an exception is thrown, rethrow the exception and abort all these steps
	生成し直せない:non-regeneratable

	●塗り／layout
anti-alias:
2D:
3D:
alpha::::アルファ
bitmap::::ビットマップ
塗ng:painting::塗り
塗らな:paintしな::~
塗り:paint::~
塗る:paintする::~
描く:drawする::~
描ける:drawできる::~
描法:drawing::~
真円:circle::~
積層:stacking::~
背後:behind::~
	色~付きの~colored
解像度:resolution::~
黒:black:::~
矩形:rectangle::~
	矩形:rectange
切抜き:clipping::切り抜き
	切抜き領域:clip
ベタな:solidな:ベタ塗りの
縦横比:aspect ratio::~
fill:
半径:radius:~
線幅:line width:~
	縦横比を保つように:proportional change
面:surface:~
透明度:transparency::~
生来:natural::~

	●呈示／CSS
	~access可能:accessible:
zoom::::ズーム
強調:highlight::~

	●保安
帯域幅:bandwidth:~

	●仕様
高品質:high-quality::~
	〜品質:-quality
複雑:complicated:~
段階:stage:~
事実:fact:~
高価:expensive:~
黙って:silentに:~
不変:unchanged:~
取戻す:reclaimする:取り戻す
投機-:speculate:~
投機的:speculative:~
計画-:plan:~
説明書き:expainer:~
	説明書き:EXPLAINER
根本的:fundamental:~

	担当する:responsible
	最も高い~~見積もり:picked as high upper bound
	~JS:javascript
	~debug用:debugging
	拘束-:under 〜 constraints
	適合する:are conformant
	~supportされない:unsupported
	~~形をとる:shape
	にするため:in order for
	のみならず:limit
	も:still
	従って:following
	必要なら:potentially
	~~仕掛け:tooling
	勧告候補:CR publication
	現時点で:at this time

	●未分類
clear:
丸めた:roundした::~
固定-:fix::~
繰返し:repeatably:繰り返し
現れな:appearしな:~
検索-:look up:~
上限:limit::~
	不変で:unchanged
円弧:arc::~
可視域:visual viewport::~
部位:portion::~
	その時点の:snapped
残念顔:sad face:~

	~~仮の:placeholder
	応答-不能:unresponsive
	高-:high-

	●変数
	塗り~2D描画~文脈:PaintRenderingContext2D object
	塗り~2D描画~文脈:paintRenderingContext2D
	塗り~2D描画~文脈~設定群:PaintRenderingContext2DSettings object
	塗り~2D描画~文脈~設定群:paintRenderingContext2DSettings

	塗り定義~map:paintDefinitionMap
	入力~prop~list:inputProperties
	-:inputPropertiesIterable
	入力~引数~list:inputArguments
	-:inputArgumentsIterable
	入力~引数~list構文~list:inputArgumentSyntaxes
	構文解析した構文:parsedSyntax
	-:paintValue
	文書~塗り定義~map:documentPaintDefinitionMap
	文書~塗り定義:documentDefinition
	既存の文書~塗り定義:existingDocumentDefinition
	%具象-~obj~size:snappedConcreteObjectSize
		その時点の具象-~obj~size:snappedConcreteObjectSize
	-:concreteObjectSize
	塗り関数:paintFunction
	塗り関数~callback:paintFunctionCallback
	塗り~class~instance~map:paintClassInstanceMap
	塗り~instance:paintInstance
	~style~map:styleMap
	描画~文脈:renderingContext
	塗り~size:paintSize
	-:contextOptionsValue
	塗り構築子:paintCtor
	:paintCtor
	~worklet大域~scope:workletGlobalScope

	●指示語

	時間~内:within 〜 time
	その次:next
	だけに:just
	一連の:sequence
	一部:part-of
	以前の:previous
	各~変化:changes
	多過ぎる:too many
	時点:at 〜 time
	最終的:eventual:
	次回:next time
	続けて:in a row:
	任意の時点:at any time
	任意の時点に:at any point
	後続して:subsequently
	一度だけ:once

●●ref_normative

[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 17 October 2017. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS-CASCADE-5]
    CSS Cascading and Inheritance Level 5 URL: https://www.w3.org/TR/css-cascade-5/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 19 May 2020. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-IMAGES-3]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. CSS Images Module Level 3. 10 October 2019. CR. URL: https://www.w3.org/TR/css-images-3/ 
[CSS-IMAGES-4]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. CSS Image Values and Replaced Content Module Level 4. 13 April 2017. WD. URL: https://www.w3.org/TR/css-images-4/ 
[CSS-PROPERTIES-VALUES-API-1]
    Tab Atkins Jr.; et al. CSS Properties and Values API Level 1. 13 October 2020. WD. URL: https://www.w3.org/TR/css-properties-values-api-1/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 16 July 2019. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS-TYPED-OM-1]
    Shane Stephens; Tab Atkins Jr.; Naina Raisinghani. CSS Typed OM Level 1. 10 April 2018. WD. URL: https://www.w3.org/TR/css-typed-om-1/ 
[CSS-UI-4]
    Florian Rivoal. CSS Basic User Interface Module Level 4. 24 January 2020. WD. URL: https://www.w3.org/TR/css-ui-4/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 31 January 2019. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS-VARIABLES-1]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[CSSOM-1]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[CSSOM-VIEW-1]
    Simon Pieters. CSSOM View Module. 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-view-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[WebIDL]
    Boris Zbarsky. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 


●●trans_metadata
<p>
~THIS_PAGEは、 W3C により
編集者草案として公開された
<a href="~SPEC_URL">CSS Painting API Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-paint-api-1/
公表履歴
	https://www.w3.org/standards/history/css-paint-api-1/

フィードバック
	<a href="mailto:public-houdini@w3.org?subject=%5Bcss-paint-api%5D%20YOUR%20TOPIC%20HERE">public-houdini@w3.org</a> with subject line “<kbd>[css-paint-api] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-houdini/" rel="discussion">archives</a>)
課題追跡
	https://github.com/w3c/css-houdini-drafts/issues/
	https://github.com/w3c/css-houdini-drafts/labels/css-paint-api-1

編集
	<a href="mailto:ikilpatrick@chromium.org">Ian Kilpatrick</a>
	<a href="mailto:dino@apple.com">Dean Jackson</a>
前任編集者
	<a href="mailto:shanestephens@google.com">Shane Stephens</a>

commit 履歴
	https://github.com/w3c/css-houdini-drafts/commits/main/css-paint-api

</script>


</head><body>

<header>
	<hgroup>
<h1>CSS Painting API Level 1</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この仕様は、~JSにより，~custom~CSS `image$t を定義する~APIを述べる。
それは、~style, ~sizeの各~変化に応答することを，~web開発者に許容する。
<a href="https://github.com/w3c/css-houdini-drafts/blob/main/css-paint-api/EXPLAINER.md">説明書き</a>
を見よ。
◎
An API for allowing web developers to define a custom CSS &lt;image&gt; with javascript, which will respond to style and size changes. See EXPLAINER.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~CSSの塗り段階は、~boxの［
（~layout段階で生成される）~size【言い換えれば，~sizeの使用~値】,
算出d~style【各種~propの算出d値】
］に基づく，~boxの［
背景, 内容, 強調
］の塗ngを担当する。
◎
The paint stage of CSS is responsible for painting the background, content and highlight of a box based on that box’s size (as generated by the layout stage) and computed style.
</p>

<p>
この仕様は、［
追加的な `image$t 関数で［
~size／算出d~style
］の各~変化に呼応して，~boxの一部を塗る
］ことを開発者に許容する~APIを述べる。
◎
This specification describes an API which allows developers to paint a part of a box in response to size / computed style changes with an additional &lt;image&gt; function.
</p>

<p class="note">注記：
この仕様の将来~versionでは、~boxのある部位に対する（例えば，背景~層に対する）［
切抜き領域, 大域~alpha, ~filter
］の定義-法の~supportも追加され得る。
◎
Note: In a future version of the spec, support could be added for defining the clip, global alpha, filter on a portion of a box (for example on the background layers).
</p>

	</section>
	<section id="paint-worklet">
<h2 title="Paint Worklet">2. 塗り~worklet</h2>

<p>
`paintWorklet$m 属性は、塗ngに関係するすべての~classを担当する `Worklet$I に~accessできるようにする。
◎
The paintWorklet attribute allows access to the Worklet responsible for all the classes which are related to painting.
</p>

<p>
`paintWorklet$m の`~worklet大域~scope型$は、
`PaintWorkletGlobalScope$I である。
◎
The paintWorklet's worklet global scope type is PaintWorkletGlobalScope.
</p>

<p>
`paintWorklet$m の`~worklet行先~種別$wLは、
`paintworklet^l である。
◎
The paintWorklet's worklet destination type is "paintworklet".
</p>

<pre class="idl">
partial namespace `CSS$I {
    [`SameObject$] readonly attribute `Worklet$I `paintWorklet@m;
};
</pre>

<p>
`PaintWorkletGlobalScope$I は `paintWorklet$m の大域~実行~文脈である。
◎
A PaintWorkletGlobalScope is a global execution context of the paintWorklet.
</p>

<p>
各 `PaintWorkletGlobalScope$I は `devicePixelRatio$m ~propを持つ
— それは
`Window^I 上の
<a href="~CSSOMVIEW#dom-window-devicepixelratio">`devicePixelRatio^m</a>
~propに一致する。
◎
A PaintWorkletGlobalScope has a devicePixelRatio property which is identical to the Window.devicePixelRatio property.
</p>

<pre class="idl">
[`Global$=(Worklet,PaintWorklet),`Exposed$=PaintWorklet]
interface `PaintWorkletGlobalScope@I : `WorkletGlobalScope$I {
    `undefined$ `registerPaint$m(`DOMString$ %name, `VoidFunction$ %paintCtor);
    readonly attribute `unrestricted double$ `devicePixelRatio@m;
};
</pre>

<p>
`PaintRenderingContext2DSettings$I は、塗り~canvasに結付けられる描画~文脈~用の設定群を包含する。
`PaintRenderingContext2DSettings$I は、~canvas描画~文脈の~2D設定群
【 `CanvasRenderingContext2DSettings$I 】
が~supportするものの下位集合を供する。
将来には、塗り~canvasにおける色~管理も~supportするよう，拡張され得る。
◎
The PaintRenderingContext2DSettings contains the settings for the rendering context associated with the paint canvas. The PaintRenderingContext2DSettings provides a supported subset of canvas rendering context 2D settings. In the future, it may be extended to support color management in paint canvas.
</p>

<pre class="idl">
dictionary `PaintRenderingContext2DSettings@I {
    `boolean$ `alpha@m = true;
};
</pre>

<div class="note">

<p>注記：
当の~classは、次のような~~形をとるベキである：
◎
Note: The shape of the class should be:
</p>
<pre class="lang-js">
class MyPaint {
    static get inputProperties() { return ['--foo']; }
    static get inputArguments() { return ['&lt;color&gt;']; }
    static get contextOptions() { return {alpha: true}; }

    paint(%ctx, %size, %styleMap) {
        /* <span class="comment">
塗り~codeはここに。
◎
Paint code goes here.
</span> */
    }
}
</pre>

</div>

	</section>
	<section id="concepts">
<h2 title="Concepts">3. 各種~概念</h2>

<p>
`塗り定義@
は、［
`PaintWorkletGlobalScope$I に必要になる，作者が定義する `image$t についての情報
］を述べる`構造体$であり（ `paint$f 関数により参照され得る），次に挙げるものからなる：
◎
A paint definition is a struct which describes the information needed by the PaintWorkletGlobalScope about the author defined &lt;image&gt; (which can be referenced by the &lt;paint()&gt; function). It consists of:
</p>

<ul>
	<li>
`~class構築子@pD
⇒
~JS `~class構築子$
◎
class constructor which is the class constructor.
</li>
	<li>
`塗り関数@pD
⇒
`Function$I 型の `~callback関数$
【原文の参照先 <a href="~CSSWG/css-syntax-3/#function">Function</a> （~CSS関数~記法）は誤りであろう。】
◎
paint function which is the paint Function callback function type.
</li>
	<li>
`構築子は妥当か@pD
⇒
真偽値
◎
constructor valid flag.
</li>
	<li>
`入力~prop~list@pD
⇒
0 個以上の文字列からなる`~list$（ ~SeqDS 型の値）
◎
input properties which is a list of DOMStrings.
</li>
	<li>
`塗り~2D描画~文脈~設定群@pD
⇒
`PaintRenderingContext2DSettings$I ~obj
◎
A PaintRenderingContext2DSettings object.
</li>
</ul>

<p>
`文書~塗り定義@
は、［
`文書$に必要になる，作者が定義する `image$t についての情報
］を述べる`構造体$であり（ `paint$f 関数により参照され得る），次に挙げるものからなる：
◎
A document paint definition is a struct which describes the information needed by the document about the author defined &lt;image&gt; function (which can be referenced by the paint function). It consists of:
</p>
<ul>
	<li>
`入力~prop~list@dPD
⇒
0 個以上の文字列からなる`~list$（ ~SeqDS 型の値）
◎
A input properties which is a list of DOMStrings.
</li>
	<li>
`入力~引数~構文@dPD
⇒
`構文~定義$の`~list$
◎
A input argument syntaxes which is a list of syntax definitions.
</li>
	<li>
`塗り~2D描画~文脈~設定群@dPD
⇒
`PaintRenderingContext2DSettings$I ~obj
◎
A PaintRenderingContext2DSettings object.
</li>
</ul>

	</section>
	<section id="registering-custom-paint">
<h2 title="Registering Custom Paint">4. ~customな塗りの登録-法</h2>

<p>
各 `文書$は、
`文書~塗り定義~map@
を持つ。
それは、`有順序~map$であり，初期~時には空とする。
この~mapは、 `registerPaint()$m が~callされたときに拡充される。
◎
The document has a map of document paint definitions. Initially this map is empty; it is populated when registerPaint(name, paintCtor) is called.
</p>

<p>
各 `PaintWorkletGlobalScope$I ~objは、次に挙げるものを持つ：
◎
↓</p>

<dl class="def-list">
	<dt>`塗り定義~map@</dt>
	<dd>
`有順序~map$であり，初期~時には空とする。
この~mapは、 `registerPaint()$m が~callされたときに拡充される。
◎
A PaintWorkletGlobalScope has a map of paint definitions. Initially this map is empty; it is populated when registerPaint(name, paintCtor) is called.
</dd>

	<dt>`塗り~class~instance~map@pD</dt>
	<dd>
`有順序~map$であり，初期~時には空とする。
この~mapは、~UAが`塗り関数の画像を描く$を呼出したときに拡充される。
◎
A PaintWorkletGlobalScope has a map of paint class instances. Initially this map is empty; it is populated when draw a paint image is invoked by the user agent.
</dd>
	<dd>
~UAは、任意の時点に，この~map内の塗り~classの~instanceを `dispose^en する
【別~threadへ移動する？】
か除去してもヨイ。
これは、［
`paint$f 関数がもはや利用されなくなった／~memoryを取戻す必要がある
］ときに行なわれ得る。
◎
Instances of paint classes in the paint class instances map may be disposed and removed from the map by the user agent at any time. This may be done when a &lt;paint()&gt; function no longer is used, or the user agent needs to reclaim memory.
</dd>
</dl>

<div class="algo">
<p>
`registerPaint(name, paintCtor)@m
~method手続きは：
◎
When the registerPaint(name, paintCtor) method is called, the user agent must run the following steps:
</p>
<ol>
	<li>
~IF［
%name ~EQ 空~文字列
］
⇒
~THROW `TypeError$E
◎
If the name is an empty string, throw a TypeError and abort all these steps.
</li>
	<li>
%塗り定義~map ~LET `PaintWorkletGlobalScope$I の`塗り定義~map$
◎
Let paintDefinitionMap be PaintWorkletGlobalScope's paint definitions map.
</li>
	<li>
~IF［
%塗り定義~map[ %name ] ~NEQ ε
］
⇒
~THROW `InvalidModificationError$E
◎
If paintDefinitionMap[name] exists throw a "InvalidModificationError" DOMException and abort all these steps.
</li>
	<li>
%入力~prop~list ~LET `Get$jA( %paintCtor, `inputProperties^l ) の結果に応じて
⇒＃
`undefined^jv ならば空な ~SeqDS ／
~ELSE_ `~IDL値に変換する$( 結果, ~SeqDS )（例外投出あり）
◎
Let inputProperties be an empty sequence&lt;DOMString&gt;.
◎
Let inputPropertiesIterable be the result of Get(paintCtor, "inputProperties").
◎
If inputPropertiesIterable is not undefined, then set inputProperties to the result of converting inputPropertiesIterable to a sequence&lt;DOMString&gt;. If an exception is thrown, rethrow the exception and abort all these steps.
</li>
	<li>
<p>
%入力~prop~list から［
`~supportされる~CSS~prop$, `~custom~prop$
］以外の~itemを取り除く
◎
Filter inputProperties so that it only contains supported CSS properties and custom properties.
</p>

<p class="note">注記：
入力~prop~list取得子
【 `get inputProperties()^c 】
が供する~CSS~propの~listは、~custom~prop, 略式~propも含めれることに加え、塗り画像~classを前方-互換にするため，~UAにとって現在~妥当でない~prop（例： `margin-nanjasorya-property^p ）も含めれる。
◎
Note: The list of CSS properties provided by the input properties getter can either be custom or native CSS properties.
◎
Note: The list of CSS properties may contain shorthands.
◎
Note: In order for a paint image class to be forwards compatible, the list of CSS properties can also contains currently invalid properties for the user agent. For example margin-bikeshed-property.
</p>

	</li>
	<li>
%入力~引数~list ~LET `Get$jA( %paintCtor, `inputArguments^l ) の結果に応じて
⇒＃
`undefined^jv ならば空な ~SeqDS ／
~ELSE_ `~IDL値に変換する$( 結果, ~SeqDS )（例外投出あり）
◎
Let inputArguments be an empty sequence&lt;DOMString&gt;.
◎
Let inputArgumentsIterable be the result of Get(paintCtor, "inputArguments").
◎
If inputArgumentsIterable is not undefined, then set inputArguments to the result of converting inputArgumentsIterable to a sequence&lt;DOMString&gt;. If an exception is thrown, rethrow the exception and abort all these steps.
</li>
	<li>
%入力~引数~list構文~list ~LET 新たな`~list$
<!-- ＊空にする$ -->
◎
Let inputArgumentSyntaxes be an empty list.
</li>
	<li>
<p>
%入力~引数~list 内の
~EACH( %~item )
に対し：
◎
For each item in inputArguments perform the following substeps:
</p>
		<ol>
			<li>
%構文解析した構文 ~LET `構文~定義を消費する$( %~item )
◎
Attempt to consume a syntax definition from item.＼
</li>
			<li>
~IF［
%構文解析した構文 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If failure was returned, throw a TypeError and abort all these steps. Otherwise, let parsedSyntax be the returned syntax definition.
</li>
			<li>
%入力~引数~list構文~list に %構文解析した構文 を`付加する$
◎
Append parsedSyntax to inputArgumentSyntaxes.
</li>
		</ol>
	</li>
	<li>
<p>
%塗り~2D描画~文脈~設定群 ~LET `~IDL値に変換する$( `Get$jA( %paintCtor, `contextOptions^l ), `PaintRenderingContext2DSettings$I )（例外投出あり）
◎
Let contextOptionsValue be the result of Get(paintCtor, "contextOptions").
◎
Let paintRenderingContext2DSettings be the result of converting contextOptionsValue to a PaintRenderingContext2DSettings. If an exception is thrown, rethrow the exception and abort all these steps.
</p>

<p class="note">注記：
%塗り~2D描画~文脈~設定群 の `alpha$m を ~F に設定した場合、~textに対する “可視性” の最適化を遂行する（例：塗り画像が不透明なときには、その背後にある画像を塗らない）ことに加え，~anti-aliasすることを~UAに許容する。
◎
Note: Setting paintRenderingContext2DSettings.alpha is false allows user agents to anti-alias text in addition to performing "visibility" optimizations, e.g. not painting an image behind the paint image as the paint image is opaque.
</p>
	</li>
	<li>
~IF［
`IsConstructor$jA( %paintCtor ) ~EQ ~F
］
⇒
~THROW `TypeError$E
◎
If the result of IsConstructor(paintCtor) is false, throw a TypeError and abort all these steps.
</li>
	<li>
%~prototype ~LET
`Get$jA( %paintCtor, `prototype^l )
◎
Let prototype be the result of Get(paintCtor, "prototype").
</li>
	<li>
~IF［
`Type$jA( %~prototype ) ~NEQ `Object^jC
］
⇒
~THROW `TypeError$E
◎
If the result of Type(prototype) is not Object, throw a TypeError and abort all these steps.
</li>
	<li>
%塗り関数 ~LET `~IDL値に変換する$( `Get$jA( %~prototype, `paint^l ), `Function$I )（例外投出あり）
◎
Let paintValue be the result of Get(prototype, "paint").
◎
Let paint be the result of converting paintValue to the Function callback function type. Rethrow any exceptions from the conversion.
</li>
	<li>
%定義 ~LET 次のようにされた新たな`塗り定義$
⇒＃
`~class構築子$pD ~SET %paintCtor,
`塗り関数$pD ~SET %塗り関数,
`構築子は妥当か$pD ~SET ~T,
`入力~prop~list$pD ~SET %入力~prop~list,
`塗り~2D描画~文脈~設定群$pD ~SET %塗り~2D描画~文脈~設定群
◎
Let definition be a new paint definition with:
• class constructor being paintCtor.
• paint function being paint.
• constructor valid flag being true.
• input properties being inputProperties.
• PaintRenderingContext2DSettings object being paintRenderingContext2DSettings.
</li>
	<li>
%塗り定義~map[ %name ] ~SET %定義
◎
Set paintDefinitionMap[name] to definition.
</li>
	<li>
<p>
次を走らす`~taskを~queueする$
◎
Queue a task to run the following steps:
</p>
		<ol>
			<li>
%文書~塗り定義~map ~LET 結付けられた`文書$【！＊】の`文書~塗り定義~map$
◎
Let documentPaintDefinitionMap be the associated document’s document paint definitions map.
</li>
			<li>
%文書~塗り定義 ~LET 次のようにされた新たな`文書~塗り定義$
⇒＃
`入力~prop~list$dPD ~SET %入力~prop~list,
`入力~引数~構文$dPD ~SET %入力~引数~list構文~list,
`塗り~2D描画~文脈~設定群$dPD ~SET %塗り~2D描画~文脈~設定群
◎
Let documentDefinition be a new document paint definition with:
• input properties being inputProperties.
• input argument syntaxes being inputArgumentSyntaxes.
• PaintRenderingContext2DSettings object being paintRenderingContext2DSettings.
</li>
			<li>
<p>
~IF［
%文書~塗り定義~map[ %name ] ~NEQ ε
］：
◎
If documentPaintDefinitionMap[name] exists, run the following steps:
</p>
				<ol>
					<li>
%既存の文書~塗り定義 ~LET %文書~塗り定義~map[ %name ]
◎
Let existingDocumentDefinition be the result of get documentPaintDefinitionMap[name].
</li>
					<li>
<p>
~IF［
%既存の文書~塗り定義 ~NEQ `invalid^l
］~AND［
［
%既存の文書~塗り定義, %文書~塗り定義
］は等価でない（すなわち，［
`入力~prop~list$dPD,
`入力~引数~構文$dPD,
`塗り~2D描画~文脈~設定群$dPD
］【のいずれか】が異なる)
］：
◎
If existingDocumentDefinition is "invalid", abort all these steps.
◎
If existingDocumentDefinition and documentDefinition are not equivalent, (that is input properties, input argument syntaxes, and PaintRenderingContext2DSettings object are different), then:
</p>
						<ol>
							<li>
%文書~塗り定義~map[ %name ] ~SET `invalid^l
◎
Set documentPaintDefinitionMap[name] to "invalid".
</li>
							<li>
同じ~classが等価でない`文書~塗り定義$で登録されようとしたことを言明する~errorを，~debug用~consoleに~logする
◎
Log an error to the debugging console stating that the same class was registered with different inputProperties, inputArguments, or paintRenderingContext2DSettings.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%文書~塗り定義~map[ %name ] ~SET %文書~塗り定義
◎
Otherwise, set documentPaintDefinitionMap[name] to documentDefinition.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
入力~prop~listは、一度だけ検索されるベキである
— 当の~classが、その入力~prop~listを動的に変更する機会を得ないよう。
◎
Note: The list of input properties should only be looked up once, the class doesn’t have the opportunity to dynamically change its input properties.
</p>
</div>

<p class="note">注記：
この仕様の将来~versionにおいては、作者は，異なる型の描画~文脈（ `RenderingContext^en ）を受取る能を持てるようにされ得る。
特に、~3D効果の描画-用として~WebGL描画~文脈が求まれるであろう。
`PaintSize$I, `StylePropertyMap$I を入力にとるため、~WebGL描画~文脈を設定しておくときに複階性がある。
◎
Note: In a future version of the spec, the author could have the ability to receive a different type of RenderingContext. In particular the author may want a WebGL rendering context to render 3D effects. There are complexities in setting up a WebGL rendering context to take the PaintSize and StylePropertyMap as inputs.
</p>

	</section>
	<section id="paint-notation">
<h2 title="Paint Notation">5. 塗り記法</h2>

<pre class="prod">
`paint@f
	= paint( `ident$t, `declaration-value$t? )
</pre>

<p>
`paint$f 関数は、 `image$t 型が~supportする追加的な記法である。
◎
The &lt;paint()&gt; function is an additional notation to be supported by the &lt;image&gt; type.
</p>

<div class="example">

<pre class="lang-html">
&lt;style&gt;
    .logo { background-image: paint(company-logo); }
    .chat-bubble { background-image: paint(chat-bubble, blue); }
&lt;/style&gt;
</pre>

</div>

<p>
`cursor$p ~propに対しては、 `paint$f 関数は`無効な画像$として扱った上で，その次に~supportされる `image$t に~fallbackするベキである。
◎
For the cursor property, the &lt;paint()&gt; function should be treated as an invalid image and fallback to the next supported &lt;image&gt;.
</p>

<p>
`paint$f 関数は、`算出d値$の時点では， `registerPaint()$m により登録された文法と照合する`必要はない^em。
合致しない場合、代わりに，`塗り関数の画像を描く$の内側で構文解析が生じるときに`無効な画像$になる。
◎
At computed value time the &lt;paint()&gt; function does not need to match the grammar registered by registerPaint(). Instead this will result in an invalid image when the parsing occurs inside draw a paint image.
</p>

	</section>
	<section id="2d-rendering-context">
<h2 title="The 2D rendering context">6. ~2D描画~文脈</h2>

<pre class="idl">
[`Exposed$=PaintWorklet]
interface `PaintRenderingContext2D@I {
};
`PaintRenderingContext2D$I includes `CanvasState$I;
`PaintRenderingContext2D$I includes `CanvasTransform$I;
`PaintRenderingContext2D$I includes `CanvasCompositing$I;
`PaintRenderingContext2D$I includes `CanvasImageSmoothing$I;
`PaintRenderingContext2D$I includes `CanvasFillStrokeStyles$I;
`PaintRenderingContext2D$I includes `CanvasShadowStyles$I;
`PaintRenderingContext2D$I includes `CanvasRect$I;
`PaintRenderingContext2D$I includes `CanvasDrawPath$I;
`PaintRenderingContext2D$I includes `CanvasDrawImage$I;
`PaintRenderingContext2D$I includes `CanvasPathDrawingStyles$I;
`PaintRenderingContext2D$I includes `CanvasPath$I;
</pre>

<p class="note">注記：
`PaintRenderingContext2D$I は、 `CanvasRenderingContext2D$I ~APIの下位集合を実装する。
特定的には，次に挙げる~APIは実装しない
⇒＃
`CanvasImageData$I,
`CanvasUserInterface$I,
`CanvasText$I,
`CanvasTextDrawingStyles$I
◎
Note: The PaintRenderingContext2D implements a subset of the CanvasRenderingContext2D API. Specifically it doesn’t implement the CanvasImageData, CanvasUserInterface, CanvasText, or CanvasTextDrawingStyles APIs.
</p>

<p>
各 `PaintRenderingContext2D$I ~objは、次に挙げるものを持つ：
◎
↓</p>
<ul>
	<li>
`出力~bitmap@
⇒
~objの作成-時に初期化される。
`出力~bitmap$の~sizeは、その描画-先~objの`具象-~obj~size$になる。
◎
A PaintRenderingContext2D object has a output bitmap. This is initialised when the object is created. The size of the output bitmap is the concrete object size of the object it is rendering to.
</li>
	<li>
`~alpha~flag@
⇒
真偽値
— ~objの作成-時には ~T に設定されるモノトスル。
この~flagが ~F に設定された場合、~objの~alpha~channelはすべての画素に対し 1.0 （全部的に不透明）に固定し、ある画素の~alpha成分を変更しようと試みられたときは，黙って無視するモノトスル。
◎
A PaintRenderingContext2D object also has an alpha flag, which can be set to true or false. Initially, when the context is created, its alpha flag must be set to true. When a PaintRenderingContext2D object has its alpha flag set to false, then its alpha channel must be fixed to 1.0 (fully opaque) for all pixels, and attempts to change the alpha component of any pixel must be silently ignored.
</li>
</ul>

<p>
`出力~bitmap$の~sizeは、~UAが［
内部的／描画の間
］に利用することになる実際の~bitmapの~sizeを表現するとは限らない。
例えば，可視域が~zoomされた場合、~UAは，結果の描画が高品質になるよう座標~空間~内の機器~画素~数に対応する~bitmapを内部的に利用してもヨイ。
◎
The size of the output bitmap does not necessarily represent the size of the actual bitmap that the user agent will use internally or during rendering. For example, if the visual viewport is zoomed the user agent may internally use bitmaps which correspond to the number of device pixels in the coordinate space, so that the resulting rendering is of high quality.
</p>

<p>
加えて，~UAは、`出力~bitmap$に適用された一連の描法~演算を，後続して機器~bitmap上に正しい解像度で描けるよう記録してもヨイ。
これはまた
— 例えば可視域が~zoomされている間に —
`出力~bitmap$の同じ出力を繰返し再利用できるようにもする。
◎
Additionally the user agent may record the sequence of drawing operations which have been applied to the output bitmap such that the user agent can subsequently draw onto a device bitmap at the correct resolution. This also allows user agents to re-use the same output of the output bitmap repeatably while the visual viewport is being zoomed for example.
</p>

<p>
`PaintRenderingContext2D$I ~APIにて，色として `currentColor^l が利用されたときは、`不透明な黒$として扱われる。
◎
Whenever "currentColor" is used as a color in the PaintRenderingContext2D API, it is treated as opaque black.
</p>

<div class="example">

<p>
次の~codeは、黒ベタな矩形を生産することになる。
◎
The code below will produce a solid black rectange.
</p>

<pre class="lang-js">
`registerPaint$m('currentcolor', class {
    paint(%ctx, %size) {
        %ctx.fillStyle = 'currentColor';
        %ctx.fillRect(0, 0, %size.width, %size.height);
    }
});
</pre>

</div>

<div class="algo">
<p>
`塗り~2D描画~文脈を作成する@
ときは、所与の
( %~size, %塗り~2D描画~文脈~設定群 )
に対し，次の手続きを走らすモノトスル：
◎
When the user agent is to create a PaintRenderingContext2D object for a given width, height, and paintRenderingContext2DSettings, it must run the following steps:
</p>
<ol>
	<li>
%文脈 ~LET 新たな `PaintRenderingContext2D$I
◎
Create a new PaintRenderingContext2D.
</li>
	<li>
%文脈 の`出力~bitmap$用の`~bitmap寸法を設定する$( %~size の横幅, 縦幅を丸めた結果 )
◎
Set bitmap dimensions for the context’s output bitmap to the rounded values of width and height.
</li>
	<li>
`PaintRenderingContext2D$I の`~alpha~flag$ ~SET %塗り~2D描画~文脈~設定群 の `alpha$m
◎
Set the PaintRenderingContext2D's alpha flag to paintRenderingContext2DSettings’s alpha.
</li>
	<li>
~RET %文脈
◎
Return the new PaintRenderingContext2D.
</li>
</ol>

<p class="note">注記：
描画~文脈の初期~状態は、`~bitmap寸法を設定する$ ~algoの内側で設定され、それに伴い
描画~文脈を`既定の状態に設定し直す$ことに加え，`出力~bitmap$を【`透明な黒$に】~clearする。
◎
Note: The initial state of the rendering context is set inside the set bitmap dimensions algorithm, as it invokes reset the rendering context to its default state and clears the output bitmap.
</p>

</div>

		<section id="drawing-a-cssimagevalue">
<h3 title="Drawing a CSSImageValue">6.1. `CSSImageValue^I の描法</h3>

<p>
`CanvasImageSource$I ~typedefは、画像~sourceとして利用される `CSSImageValue$I 型も含むよう拡張される。
◎
The CanvasImageSource typedef is extended to also include the CSSImageValue type to be used as an image source.
</p>

<p>
`CanvasDrawImage$I ~mixinを利用する~interface用には：
◎
For interfaces which use the CanvasDrawImage mixin:
</p>

<ul>
	<li>
`CanvasImageSource$I ~objが，ある `CSSImageValue$I を表現するときは、
— `drawImage()$m の目的においては —
~source画像として，値の下層の画像~algoを呼出した結果を利用するモノトスル。
◎
When a CanvasImageSource object represents an CSSImageValue, the result of invoking the value’s underlying image algorithm must be used as the source image for the purposes of drawImage.
</li>
</ul>

<p class="note">注記：
これは、最終的には~HTML仕様の~canvas節へ移動されるベキである。
`819$issue を見よ。
◎
Note: This should eventually be moved to the canvas section of the HTML specification. See Issue 819.
</p>

		</section>
	</section>
	<section id="drawing-an-image">
<h2 title="Drawing an image">7. 画像の描法</h2>

<p>
`~box$用の `paint$f 関数~画像【の描画-先】が可視域の中にある場合、~UAは，`塗り関数の画像を描く$を呼出した結果の画像~出力を表示するモノトスル。
◎
If a &lt;paint()&gt; function image for a box is within the visual viewport, the user agent must display an image output from an invocation of the draw a paint image algorithm.
</p>

<p class="note">注記：
~UAは、可視域の中で `paint$f 関数~用に各~frameごとに`塗り関数の画像を描く$を走らす必要はない。
~cacheした結果で，正しい画像~出力を表示できる（必要なら追加的な無効~化~手続きも利用して）。
◎
Note: The user agent doesn’t have to run draw a paint image each frame for a &lt;paint()&gt; function within the visual viewport. It can cache results, (potentially using additional invalidation steps) to display the correct image output.
</p>

<p class="note">注記：
~UAは、可視域の外側にある画像に対しては，任意選択で描くのを先送りできる。
◎
Note: The user agent can optionally defer drawing images which are outside the visual viewport.
</p>

<div class="example">

<p>
作者が `requestAnimationFrame()^m の内側で~styleを更新した場合の例：
◎
If an author updates a style inside a requestAnimationFrame, e.g.
</p>

<pre class="lang-js">
requestAnimationFrame(function() {
    %element.styleMap.set('--custom-prop-invalidates-paint', 42);
});
</pre>

<p>
%element が可視域の内側にある場合、~UAには次が要求される
⇒＃
`塗り関数の画像を描く$,
現在の~frame用の結果を表示する
◎
And the element is inside the visual viewport, the user agent is required to draw a paint image and display the result for the current frame.
</p>

</div>

<p>
`塗り関数の画像を描く$は、`~obj~size折衝~algo$の間に~UAにより呼出される。
それは、通例的には`~box$の`具象-~obj~size$と同じ~sizeとして定義される，
`その時点の具象-~obj~size@
による `image$t の描画を担当する。
しかしながら，~UAは、画素~境界を塗るようこの~sizeを調整してもヨイ。
そうする場合、元の~sizeの縦横比を保つように，`その時点の具象-~obj~size$を調整するベキである
— それに則って `paint$f 関数が描法を調整できるよう。
◎
The draw a paint image function is invoked by the user agent during the object size negotiation algorithm which is responsible for rendering an &lt;image&gt;, with snappedConcreteObjectSize defined as follows. Let concreteObjectSize be the concrete object size of the box. The snappedConcreteObjectSize is usually the same as the concreteObjectSize. However, the user agent may adjust the size such that it paints to pixel boundaries. If it does, the user agent should adjust the snappedConcreteObjectSize by the proportional change from its original size such that the &lt;paint()&gt; function can adjust the drawing accordingly.
</p>

<p>
`~obj~size折衝~algo$の目的においては、塗り画像には`生来な寸法$は無い。
◎
For the purposes of the object size negotiation algorithm, the paint image has no natural dimensions.
</p>

<p class="note">注記：
この仕様の将来~versionでは、作者には，塗り画像の`生来な寸法$を指定する能も与えられ得る。
これはおそらく，作者に次を許容するような~callbackとして公開されることになる
⇒
静的な`生来な寸法$を定義する／
算出d~style, ~sizeの各~変化に基づいて`生来な寸法$を動的に更新する
◎
Note: In a future version of the spec, the author could have the ability to specify the natural dimensions of the paint image. This will probably be exposed as a callback allowing the author to define static natural dimensions or dynamically updating the natural dimensions based on computed style and size changes.
</p>

<p>
`PaintSize$I ~objは、作者が描くベキ画像の~sizeを表現する。
これは、~UAが与える`その時点の具象-~obj~size$を表す。
◎
The PaintSize object represents the size of the image that the author should draw. This is the snappedConcreteObjectSize given by the user agent.
</p>

<p class="note">注記：
`具象-~obj~size$がどう計算されるかの例は、
<a href="~CSSIMAGE#object-sizing-examples">§ ~CSS~obj~sizingの例</a>
を見よ。
◎
Note: See CSS Images 3 §4.4 Examples of CSS Object Sizing for examples on how the concrete object size is calculated.
</p>

<p>
~UAは、`塗り関数の画像を描く$を任意の時点に任意の`その時点の具象-~obj~size$で投機的に呼出せる。
結果の画像は表示されない。
◎
The draw a paint image function may be speculatively invoked by the user agent at any point, with any snappedConcreteObjectSize. The resulting image is not displayed.
</p>

<p class="note">注記：
~UAは、経験則を利用して，未来の`その時点の具象-~obj~size$用にアリな値を投機してもヨイ
— 例えば，~sizeは不変であり続けることを投機するなど。
◎
Note: User agents may use any heuristic to speculate a possible future value for snappedConcreteObjectSize, for example speculating that the size remains unchanged.
</p>

<p class="note">注記：
画像は、表示されなくとも~cacheしてヨイ
— 後続な `paint$f の呼出nは~cacheした画像を利用してヨイ。
◎
Note: Although the image is not displayed, it may still be cached, and subsequent invocations of &lt;paint()&gt; may use the cached image.
</p>

<pre class="idl">
[`Exposed$=PaintWorklet]
interface `PaintSize@I {
    readonly attribute `double$ `width@m;
    readonly attribute `double$ `height@m;
};
</pre>

<div class="algo">
<p>
~UAは，
`塗り関数の画像を描く@
ときは、所与の
( %~box, `その時点の具象-~obj~size$ %具象-~obj~size )
に対し，次の手続きを走らせて生産される画像~出力を［
%~box 用に適切な積層~level（ %~box の~CSS~propにより定義される）の中へ描く
］モノトスル：
◎
When the user agent wants to draw a paint image of a &lt;paint()&gt; function for a box into its appropriate stacking level (as defined by the property the CSS property its associated with), given snappedConcreteObjectSize it must run the following steps:
</p>
<ol>
	<li>
%塗り関数 ~LET %~box 上の `paint$f 関数
◎
Let paintFunction be the &lt;paint()&gt; function on the box which the user agent wants to draw.
</li>
	<li>
%名前 ~LET %塗り関数 の最初の引数
◎
Let name be the first argument of the paintFunction.
</li>
	<li>
%文書~塗り定義~map ~LET 結付けられた`文書$【 %~box が生成される文書】の`文書~塗り定義~map$
◎
Let documentPaintDefinitionMap be the associated document’s document paint definitions map.
</li>
	<li>
~IF［
%文書~塗り定義~map[ %名前 ] ~EQ ε
］
⇒＃
画像~出力は`無効な画像$；
~RET
◎
If documentPaintDefinitionMap[name] does not exist, let the image output be an invalid image and abort all these steps.
</li>
	<li>
%文書~塗り定義 ~LET %文書~塗り定義~map[ %名前 ]
◎
Let documentDefinition be the result of get documentPaintDefinitionMap[name].
</li>
	<li>
~IF［
%文書~塗り定義 ~EQ `invalid^l
］
⇒＃
画像~出力は`無効な画像$；
~RET
◎
If documentDefinition is "invalid", let the image output be an invalid image and abort all these steps.
</li>
	<li>
%入力~引数~list構文~list ~LET %文書~塗り定義 の`入力~引数~構文$dPD
◎
Let inputArgumentSyntaxes be documentDefinition’s input argument syntaxes.
</li>
	<li>
%入力~引数~list ~LET %塗り関数 の `declaration-value$t 引数を成す成分たちからなる`~list$
◎
Let inputArguments be the list of all the paintFunction arguments after the "paint name" argument.
</li>
	<li>
<p>
~IF［
%入力~引数~list は %入力~引数~list構文~list に与えられた登録-済み文法に合致しない
］
⇒＃
画像~出力は`無効な画像$；
~RET
◎
If inputArguments do not match the registered grammar given by inputArgumentSyntaxes, let the image output be an invalid image and abort all these steps.
</p>

<div class="example">

<p>
この段は、次の事例では失敗し得る：
◎
This step may fail in the following cases:
</p>

<pre class="lang-js">
// paint.js
`registerPaint$m('failing-argument-syntax', class {
    static get inputArguments() { return ['&lt;length&gt;']; }
    paint(%ctx, %size, %styleMap, %args) { /* paint code here. */ }
});
</pre>

<pre class="lang-html">
&lt;style&gt;
    .example-1 {
        background-image: paint(failing-argument-syntax, red);
    }
    .example-2 {
        background-image: paint(failing-argument-syntax, 1px, 2px);
    }
&lt;/style&gt;
&lt;div class=example-1&gt;&lt;/div&gt;
&lt;div class=example-2&gt;&lt;/div&gt;
&lt;script&gt;
    CSS.`paintWorklet$m.`addModule$m('paint.js');
&lt;/script&gt;
</pre>

<p>
`example-1^c は`無効な画像$を生産する
— `red^l は登録-済み文法に合致しないので。
◎
example-1 produces an invalid image as "red" does not match the registered grammar.
</p>

<p>
`example-2^c は`無効な画像$を生産する
— 関数の引数が多過ぎるので。
◎
example-2 produces an invalid image as there are too many function arguments.
</p>
</div>
	</li>
	<li>
<p>
%~worklet大域~scope ~LET 
<a href="#global-scope-selection">§ 大域~scopeの選定</a>に定義される規則に従って，
塗り `Worklet$I の`大域~scope~list$wLから選んだ `PaintWorkletGlobalScope$I ~obj
◎
Let workletGlobalScope be a PaintWorkletGlobalScope from the paint Worklet's global scopes, following the rules defined in § 7.1 Global Scope Selection.
</p>

<p>
~UAは、この時点で次を行っても`ヨイ^em
⇒
`~worklet大域~scopeを作成する$( 塗り `Worklet$I【！＊】 )
◎
The user agent may also create a worklet global scope at this time, given the paint Worklet.
</p>
	</li>
	<li>
<p>
この段は、任意選択で`並列的$に, または同期的に走らす
⇒
`塗り~callbackを呼出す$( %名前, %入力~引数~list, %具象-~obj~size, %~worklet大域~scope )
◎
Run invoke a paint callback given name, inputArguments, snappedConcreteObjectSize, workletGlobalScope optionally in parallel.
</p>

<p class="note">注記：
`並列的$な~thread内で`塗り~callbackを呼出す$場合、~UAは，その~thread上で利用できる塗り~worklet大域~scopeを選定するベキである。
◎
Note: If the user agent runs invoke a paint callback on a thread in parallel, it should select a paint worklet global scope which can be used on that thread.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`塗り~callbackを呼出す@
ときは、所与の
( %名前, %入力~引数~list, %具象-~obj~size, %~worklet大域~scope )
に対し，次の手続きを走らすモノトスル：
◎
When the user agent wants to invoke a paint callback given name, inputArguments, snappedConcreteObjectSize, and workletGlobalScope, it must run the following steps:
</p>
<ol>
	<li>
%塗り定義~map ~LET %~worklet大域~scope の`塗り定義~map$
◎
Let paintDefinitionMap be workletGlobalScope’s paint definitions map.
</li>
	<li>
%定義 ~LET %塗り定義~map[ %名前 ]
<!-- Get -->
◎
↓</li>
	<li>
<p>
~IF［
%定義 ~EQ ε
］：
◎
If paintDefinitionMap[name] does not exist, run the following steps:
</p>
		<ol>
			<li>
<p>
次を走らす`~taskを~queueする$：
◎
Queue a task to run the following steps:
</p>
				<ol>
					<li>
%文書~塗り定義~map ~LET 結付けられた`文書$【！＊】の`文書~塗り定義~map$
◎
Let documentPaintDefinitionMap be the associated document's document paint definitions map.
</li>
					<li>
%文書~塗り定義~map[ %名前 ] ~SET `invalid^l
◎
Set documentPaintDefinitionMap[name] to "invalid".
</li>
					<li>
~UAは、~debug用~consoleに次を~logする`ベキ^emである
⇒
どの `PaintWorkletGlobalScope$I にも~classは登録されていないことを言明する~error
◎
The user agent should log an error to the debugging console stating that a class wasn’t registered in all PaintWorkletGlobalScopes.
</li>
				</ol>
			</li>
			<li>
画像~出力は`無効な画像$
◎
Let the image output be an invalid image and＼
</li>
			<li>
~RET
◎
abort all these steps.
</li>
		</ol>

<p class="note">注記：
塗り~worklet大域~scopeには、
%名前 用の `registerPaint()$m を受取らなかったものもある（しかしながら，受取った大域~scopeもある）かもしれない
— これは、そのような事例を取扱う。
他の大域~scope上で呼出された塗り~callbackは成功したとしても、後続な~frameでは，`塗り関数の画像を描く$が~callされても成功しないことになる。
◎
Note: This handles the case where there could be a paint worklet global scope which didn’t receive the registerPaint(name, paintCtor) for name (however another global scope did). A paint callback which is invoked on the other global scope could succeed, but wont succeed on a subsequent frame when draw a paint image is called.
</p>
	</li>
	<li>
%塗り~class~instance~map ~LET %~worklet大域~scope の`塗り~class~instance~map$pD
◎
↑Let definition be the result of get paintDefinitionMap[name].
◎
Let paintClassInstanceMap be workletGlobalScope’s paint class instances map.
</li>
	<li>
%塗り~instance ~LET %塗り~class~instance~map[ %名前 ]
◎
Let paintInstance be the result of get paintClassInstanceMap[|name]|.＼
</li>
	<li>
<p>
~IF［
%塗り~instance ~EQ ε
］：
◎
If paintInstance is null, run the following steps:
</p>
		<ol>
			<li>
~IF［
%定義 の`構築子は妥当か$pD ~EQ ~F
］
⇒＃
画像~出力は`無効な画像$；
~RET
◎
If the constructor valid flag on definition is false, let the image output be an invalid image and abort all these steps.
</li>
			<li>
%塗り構築子 ~LET %定義 上の`~class構築子$pD
◎
Let paintCtor be the class constructor on definition.
</li>
			<li>
%塗り~instance ~SET `Construct$jA( %塗り構築子 )
◎
Let paintInstance be the result of Construct(paintCtor).
</li>
			<li>
~IF［
前~段にて例外が投出された
］
⇒＃
%定義 の`構築子は妥当か$pD ~SET ~F；
画像~出力は`無効な画像$；
~RET
◎
If construct throws an exception, set the definition’s constructor valid flag to false, let the image output be an invalid image and abort all these steps.
</li>
			<li>
%塗り~class~instance~map[ %名前 ] ~SET %塗り~instance
◎
Set paintClassInstanceMap[name] to paintInstance.
</li>
		</ol>
	</li>
	<li>
%入力~prop~list ~LET %定義 の`入力~prop~list$pD
◎
Let inputProperties be definition’s input properties.
</li>
	<li>
%~style~map ~LET 新たな `StylePropertyMapReadOnly$I
◎
Let styleMap be a new StylePropertyMapReadOnly＼
</li>
	<li>
%~style~map
の `declarations$sl 内部~slot
を［
%入力~prop~list 内に~listされた~prop用の`算出d値$
］`のみ^emで拡充する
◎
populated with only the computed value's for properties listed in inputProperties.
</li>
	<li>
<p>
%描画~文脈 ~LET `塗り~2D描画~文脈を作成する$( %具象-~obj~size, %定義 の`塗り~2D描画~文脈~設定群$pD )：
◎
Let renderingContext be the result of create a PaintRenderingContext2D object given:
• "width" - The width given by snappedConcreteObjectSize.
• "height" - The height given by snappedConcreteObjectSize.
• "paintRenderingContext2DSettings" - The PaintRenderingContext2DSettings object given by definition.
</p>

<p class="note">注記：
%描画~文脈 は、塗りの各~呼出nの間で再利用されることはない。
これは、各~呼出nの間では %描画~文脈 上に格納-済みな~dataや状態は無いことを暗黙的に意味する。
例えば， %描画~文脈 上で `clip()$m により切抜き領域を設定しておいても、次回に塗り~methodが~callされるとき同じ切抜き領域が適用されることは，期待できない。
◎
Note: The renderingContext is not be re-used between invocations of paint. Implicitly this means that there is no stored data, or state on the renderingContext between invocations. For example you can’t setup a clip on the context, and expect the same clip to be applied next time the paint method is called.
</p>

<p class="note">注記：
これは、［
%描画~文脈 は実質的に塗り~methodが完了した後に “無力化される”
］ことを暗黙的に意味する。
作者~codeは %描画~文脈 への参照を保持して，それに対し~methodを呼出すこともできるが、［
現在の画像／後続な画像
］に対する効果は無い。
◎
Note: Implicitly this also means that renderingContext is effectively "neutered" after a paint method is complete. The author code may hold a reference to renderingContext and invoke methods on it, but this will have no effect on the current image, or subsequent images.
</p>
	</li>
	<li>
%塗り~size ~LET 次のように初期化された新たな `PaintSize$I ~obj
⇒＃
`width$m ~SET %具象-~obj~size の横幅,
`height$m ~SET %具象-~obj~size の縦幅
◎
Let paintSize be a new PaintSize initialized to the width and height defined by snappedConcreteObjectSize.
</li>
	<li>
<p>
~UAは、この段階で以前の呼出nからの画像を再利用してもヨイ
— ［
%塗り~size, %~style~map, %入力~引数~list
］は以前の呼出nに等価であるならば
— その場合
⇒＃
画像~出力はその~cache済み画像；
~RET
◎
At this stage the user agent may re-use an image from a previous invocation if paintSize, styleMap, inputArguments are equivalent to that previous invocation. If so let the image output be that cached image and abort all these steps.
</p>

<div class="example">

<p>
下の例では， `div-1^css, `div-2^css の両者とも等価な~JS引数~listをとる塗り関数を持つ。
~UAは、ある回の呼出nの結果を~cacheして，それを両~要素~用に利用できる。
◎
In the example below, both div-1 and div-2 have paint functions which have equivalent javascript arguments. A user-agent can cache the result of one invocation and use it for both elements.
</p>
<pre class="lang-js">
// paint.js
`registerPaint$m('simple', class {
    paint(%ctx, %size) {
        %ctx.fillStyle = 'green';
        %ctx.fillRect(0, 0, %size.width, %size.height);
    }
});
</pre>

<pre class="lang-html">
&lt;style&gt;
    .div-1 {
        width: 50px;
        height: 50px;
        background-image: paint(simple);
    }
    .div-2 {
        width: 100px;
        height: 100px;

        background-size: 50% 50%;
        background-image: paint(simple);
    }
&lt;/style&gt;
&lt;div class=div-1&gt;&lt;/div&gt;
&lt;div class=div-2&gt;&lt;/div&gt;
&lt;script&gt;
    CSS.`paintWorklet$m.`addModule$m('paint.js');
&lt;/script&gt;
</pre>
</div>
	</li>
	<li>
%塗り関数~callback ~LET %定義 の`塗り関数$pD
◎
Let paintFunctionCallback be definition’s paint function.
</li>
	<li>
<p>
`~callback関数を呼出す$( %塗り関数~callback, 次に与える~list, %塗り~instance )
⇒
« %描画~文脈, %塗り~size, %~style~map, %入力~引数~list »
◎
Invoke paintFunctionCallback with arguments «renderingContext, paintSize, styleMap, inputArguments», and with paintInstance as the callback this value.
</p>
		<ul>
			<li>
<p>
~IF［
%塗り関数~callback は （~UAが決定する）受容-可能な時間~内に完了しなかった（すなわち， “~scriptは長い間~走っている”）
］
⇒＃
~UAは~scriptを終了しても`ヨイ^em；
画像~出力は`無効な画像$；
~RET
◎
If paintFunctionCallback does not complete within an acceptable time (as determined by the user agent, i.e. it is a "long running script") the user agent may terminate the script, let the image output be an invalid image, and abort all these steps.
</p>

<p class="note">注記：
~UAは、自身の~debug用~toolの中で，それらの塗り~classがどう高価か作者に示す~~仕掛けを供することもできる。
この事例では，~UAは、適切になるならば，
“~scriptは応答-不能である”
様子を~dialogに示すこともできる。
◎
Note: User agents could provide tooling within their debugging tools to show authors how expensive their paint classes are. User agents could also how an "unresponsive script" dialog in this case if appropriate.
</p>
			</li>
			<li>
~IF［
%塗り関数~callback から例外が投出された
］
⇒＃
画像~出力は`無効な画像$；
~RET
◎
↓
</li>
		</ul>
	</li>
	<li>
画像~出力は前~段により %描画~文脈 から生産されたそれ
◎
The image output is to be produced from the renderingContext given to the method.
◎
If an exception is thrown the let the image output be an invalid image.
</li>
</ol>

<p class="note">注記：
結果の画像の内容は、~access可能になるものと設計されていない。
作者は、有用な情報があれば，標準な~accessibility~APIを通して通信できる。
◎
Note: The contents of the resulting image are not designed to be accessible. Authors can communicate any useful information through the standard accessibility APIs.
</p>

</div>

		<section id="global-scope-selection">
<h3 title="Global Scope Selection">7.1. 大域~scopeの選定</h3>

<p>
~UAは、塗り `Worklet$I の`大域~scope~list$wLから `PaintWorkletGlobalScope$I を選定する必要があるときは，次に従うモノトスル：
◎
When the user agent needs to select a PaintWorkletGlobalScope from the paint Worklet's global scopes list it must:
</p>

<ul>
	<li>
`2 個~以上の^em  `PaintWorkletGlobalScope$I を選定する
— ~UAの~memoryが拘束されていない限り。
◎
Select from at least two PaintWorkletGlobalScopes, unless the user agent is under memory constraints.
</li>
	<li>
<p>
同じ `PaintWorkletGlobalScope$I を続けて再利用するのは、 `1000 回まで^emにすること。
◎
Not re-use the same PaintWorkletGlobalScope more than 1000 times in a row.
</p>

<p class="note">注記：
上限の 1000 回は、最も高い~~見積もりであり，時を経れば下方へ改善され得る。
◎
Note: The 1000 limit was picked as a high upper bound, this limit may improve (downwards) over time.
</p>
	</li>
</ul>

<p class="note">注記：
これらの規則は、［
状態を大域~obj上に格納できる ／
生成し直せない状態を~class上に格納できる
］ことに作者が依拠しないことを確保するために存在する。
~worklet仕様~内の
<a href="~WORKLETS#worklets-idempotent">§ ~codeの冪等性</a>
についての論点を見よ。
◎
Note: These rules exist to ensure that authors do not rely on being able to store state on the global object or non-regeneratable state on the class. See the discussion in the worklets specification about code idempotence.
</p>

		</section>
	</section>
	<section id="examples" class="example">
<h2 title="Examples">8. 例</h2>

		<section>
<h3 title="Example 1: Colored Circle">8.1. 色~付きの真円</h3>

<p>
下の例は、 `paint$f 関数は~animate可能である事実を用立てる。
例えば `textarea^e が~focusされたとき、
`--circle-color^p ~propは， `deepskyblue^v から `purple^v へ遷移することになる。
◎
The example below makes use of the fact that &lt;paint()&gt; functions are able to be animated. E.g. when the textarea is focused in the example below, the --circle-color property will transition from deepskyblue to purple.
</p>

<p>
この能は、遷移のみならず，~CSS~animationや~WebAnimations~APIにも適用される。
◎
This ability isn’t limited to just transitions, it also applies to CSS animations, and the Web Animations API.
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;style&gt;
  #example {
    --circle-color: deepskyblue;

    background-image: paint(circle);
    font-family: sans-serif;
    font-size: 36px;
    transition: --circle-color 1s;
  }

  #example:focus {
    --circle-color: purple;
  }
&lt;/style&gt;

&lt;textarea id="example"&gt;
  CSS is awesome.
&lt;/textarea&gt;

&lt;script&gt;
    CSS.`registerProperty$m({
      name: '--circle-color',
      syntax: '&lt;color&gt;',
      initialValue: 'black',
      inherits: false
    });
    CSS.`paintWorklet$m.`addModule$m('circle.js');
&lt;/script&gt;
</pre>

<pre class="lang-js">
// circle.js
`registerPaint$m('circle', class {
  static get inputProperties() { return ['--circle-color']; }
  paint(%ctx, %geom, %properties) {
    /* <span class="comment">
~fill色を変更する。
◎
Change the fill color.
</span> */
    const %color = %properties.get('--circle-color');
    %ctx.fillStyle = %color.cssText;

    /* <span class="comment">
中心点と半径を決定する。
◎
Determine the center point and radius.
</span> */
    const %x = %geom.width / 2;
    const %y = %geom.height / 2;
    const %radius = Math.min(%x, %y);

    /* <span class="comment">
真円を描く
◎
Draw the circle \o/
</span> */
    %ctx.beginPath();
    %ctx.arc(%x, %y, %radius, 0, 2 * Math.PI, false);
    %ctx.fill();
  }
});
</pre>

		</section>
		<section>
<h3 title="Example 2: Image Placeholder">8.2. ~~仮の画像</h3>

<p>
作者は、画像が読込n中にある間，~~仮の画像を描く塗りを利用することもアリである。
◎
It is possible for an author to use paint to draw a placeholder image while an image is being loaded.
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;style&gt;
#example {
    --image: url('#someUrlWhichIsLoading');
    background-image: paint(image-with-placeholder);
}
&lt;/style&gt;

&lt;div id="example"&gt;&lt;/div&gt;

&lt;script&gt;
    CSS.`registerProperty$m({
        name: '--image',
        syntax: '&lt;image&gt; | none',
        initialValue: 'none',
    });
    CSS.`paintWorklet$m.`addModule$m('image-placeholder.js');
&lt;/script&gt;
</pre>

<pre class="lang-js">
// image-placeholder.js
`registerPaint$m('image-with-placeholder', class {
    static get inputProperties() { return ['--image']; }
    paint(%ctx, %geom, %properties) {
        const %img = %properties.get('--image');

        switch (%img.state) {
            case 'ready':
                /* <span class="comment">
読込まれた画像を描く。
◎
The image is loaded! Draw the image.
</span> */
                %ctx.drawImage(%img, 0, 0, %geom.width, %geom.height);
                break;
            case 'pending':
                /* <span class="comment">
画像は読込n中。
何か山を描く
◎
The image is loading, draw some mountains.
</span> */
                drawMountains(%ctx);
                break;
            case 'invalid':
            default:
                /* <span class="comment">
無効な画像（例：読込まれなかった）。
残念顔を描く。
◎
The image is invalid (e.g. it didn’t load), draw a sad face.
</span> */
                drawSadFace(%ctx);
                break;
        }
    }
});
</pre>

		</section>
		<section>
<h3 title="Example 3: Arcs">8.3. 円弧</h3>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;style&gt;
#example {
  width: 200px;
  height: 200px;

  background-image:
    paint(arc, purple, 0.4turn, 0.8turn, 40px, 15px),
    paint(arc, blue, -20deg, 170deg, 30px, 20px),
    paint(arc, red, 45deg, 220deg, 50px, 10px);
}
&lt;/style&gt;

&lt;div id="example"&gt;&lt;/div&gt;

&lt;script&gt;
    CSS.`paintWorklet$m.`addModule$m('arc.js');
&lt;/script&gt;
</pre>

<pre class="lang-js">
// arc.js
`registerPaint$m('arc', class {
  static get inputArguments() {
    return [
      '&lt;color&gt;',
      '&lt;angle&gt;',  // 始端~角度
      '&lt;angle&gt;',  // 終端~角度
      '&lt;length&gt;', // 半径
      '&lt;length&gt;', // 線幅
    ];
  }

  paint(%ctx, %geom, _, %args) {
    %ctx.strokeStyle = %args[0].cssText;

    /* <span class="comment">
中心点を決定する。
◎
Determine the center point.
</span> */
    const %x = %geom.width / 2;
    const %y = %geom.height / 2;

    /* <span class="comment">
始端~角度, 終端~角度 を `rad^css 単位に換算する
◎
Convert the start and end angles to radians.
</span> */
    const %startAngle = this.convertAngle(%args[1]) - Math.PI / 2;
    const %endAngle = this.convertAngle(%args[2]) - Math.PI / 2;

    /* <span class="comment">
半径と線幅を `px^css 単位に換算する
◎
Convert the radius and lineWidth to px.
</span> */
    const %radius = this.convertLength(%args[3]);
    const %lineWidth = this.convertLength(%args[4]);

    %ctx.lineWidth = lineWidth;

    %ctx.beginPath();
    %ctx.arc(%x, %y, %radius, %startAngle, %endAngle, false);
    %ctx.stroke();
  }

  convertAngle(%angle) {
    switch (%angle.unit) {
      case 'deg':
        return %angle.value * Math.PI / 180;
      case 'rad':
        return %angle.value;
      case 'grad':
        return %angle.value * Math.PI / 200;
      case 'turn':
        return %angle.value * Math.PI / 0.5;
      default:
        throw Error(``^未知な角度~単位: ${%angle.unit}``^);
    }
  }

  convertLength(%length) {
    switch (%length.type) {
      case 'px':
        return %length.value;
      default:
        throw Error(``^未知な長さ型: ${%length.type}``^);
    }
  }
});
</pre>

		</section>
		<section>
<h3 title="Example 4: Different Colors (based on size)">8.4. 色を（~sizeに応じて）違える</h3>

<pre class="lang-html">
&lt;h1&gt;
    Heading 1
&lt;/h1&gt;
&lt;h1&gt;
    Another heading
&lt;/h1&gt;

&lt;style&gt;
h1 {
    background-image: paint(heading-color);
}
&lt;/style&gt;

&lt;script&gt;
    CSS.`paintWorklet$m.`addModule$m('heading-color.js');
&lt;/script&gt;
</pre>

<pre class="lang-js">
// heading-color.js
`registerPaint$m('heading-color', class {
    static get inputProperties() { return []; }
    paint(%ctx, %geom, %properties) {
        /* <span class="comment">
画像の~sizeに基づいて色を選定する。
◎
Select a color based on the width and height of the image.
</span> */
        const %width = %geom.width;
        const %height = %geom.height;
        const %color = colorArray[(%width * %height) % colorArray.length];

        /* <span class="comment">
ベタな画像を描く。
◎
Draw just a solid image.
</span> */
        %ctx.fillStyle = color;
        %ctx.fillRect(0, 0, %width, %height);
    }
});
</pre>

		</section>
		<section>
<h3 title="Example 5: Drawing outside an element’s area">8.5. 要素の区画の外側への描法</h3>

<p>
`border-image$p ~propを利用すれば、要素の区画の外側に描くこともアリである。
◎
It is possible to draw outside an element’s area by using the border-image property.
</p>

<pre class="lang-html">
&lt;style&gt;
#overdraw {
    --border-width: 10;

    border-style: solid;
    border-width: calc(var(--border-width) * 1px);

    border-image-source: paint(overdraw);
    border-image-slice: 0 fill;
    border-image-outset: calc(var(--border-width) * 1px);

    width: 200px;
    height: 200px;
}
&lt;/style&gt;
&lt;div id="overdraw"&gt;&lt;/div&gt;
&lt;script&gt;
    CSS.`paintWorklet$m.`addModule$m('overdraw.js');
&lt;/script&gt;
</pre>

<pre class="lang-js">
// overdraw.js
`registerPaint$m('overdraw', class {
    static get inputProperties() { return ['--border-width']; }
    paint(%ctx, %geom, %properties) {
        const %borderWidth = parseInt(%properties.get('--border-width'));
        %ctx.shadowColor = 'rgba(0,0,0,0.25)';
        %ctx.shadowBlur = %borderWidth;

        %ctx.fillStyle = 'rgba(255, 255, 255, 1)';
        %ctx.fillRect(%borderWidth,
                     %borderWidth,
                     %geom.width - 2 * %borderWidth,
                     %geom.height - 2 * %borderWidth);
    }
});
</pre>

		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">9. ~securityの考慮点</h2>

<p>
これらの特能により導入される既知な~securityの課題は無い。
◎
There are no known security issues introduced by these features.
</p>

	</section>
	<section id="privacy-considerations">
<h2 title="Privacy Considerations">10. ~privacyの考慮点</h2>

<p>
塗り~callbackの計時は、~linkに対する “訪問-済み” 状態を検出するための高-帯域幅な~channelとして利用し得る（詳細は `791$issue に）。
これは，根本的には新たな~privacy漏洩ではないが（訪問-済み状態は多くのヤリトリから漏洩するので）、更なる軽減策が無い下では，情報を成す 特に高-帯域幅な~channelになる。
◎
The timing of paint callbacks can be used as a high-bandwidth channel for detecting "visited" state for links. (details) This is not a fundamentally new privacy leak, as visited state leaks from many interactions, but absent any further mitigations, this is a particularly high-bandwidth channel of the information.
</p>

<p>
現時点で計画されている公式的な軽減策は無い。
この~privacy漏洩は、そのような~channelすべてを修正することへ向けて，もっと直に取組まれる必要があるので。
◎
No official mitigations are planned at this time, as this privacy leak needs to be addressed more directly to fix all such channels.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">11. 変更点</h2>

<p>
<a href="~TR/2018/CR-css-paint-api-1-20180809/">2018年 8月 9日 勧告候補</a>
からの変更点は：
◎
Changes since the 9 August 2018 CR publication:
</p>

<ul>
	<li>
塗り~workletへの入力~prop~listを［
既知／~custom
］な~propに絞り込むようにした。
◎
Filtered the list of input properties to a paint worklet to be only known or custom properties.
</li>

	<li>
描画~面に対し［
不透明に強制するか透明度を許容するか
］を制御するためとして、
`PaintRenderingContext2D$I に`~alpha~flag$を追加した。
◎
Added alpha flag to PaintRenderingContext2D to control whether the rendering surface is forced opaque or allows transparency.
</li>
	<li>
出力~bitmapの~size用の定義を修正した。
◎
Fix definition for the size of the output bitmap:
◎
（引用文は略）
The size of the output bitmap is the 
+ concrete object size of the object it is rendering to
- size of the fragment it is rendering
.
</li>
</ul>

	</section>
</main></div>
