<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard â€” Scriptingï¼ˆæ—¥æœ¬èªè¨³ï¼‰</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">
<style>
#_script-allowed-attrs {
	> thead > tr > th {
		writing-mode: sideways-rl;
	}
	td.yes {
		background-color: var(--O-bg);
	}
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~ä¸€-é¿†ã‚-ã‚“]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('ï¼ ');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'a': // 
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case '0x': // ABNF char code %x escape
	return `%x${key}`;
	break;
case 'AA':
	return `<a href="~HTMLARIA#el-${key}">ä½œè€…~å‘ã‘</a>ï¼<a href="~HTMLAAM#el-${key}">å®Ÿè£…è€…~å‘ã‘</a>`;
	break;
case 'obsMb':
	text = 'å»ƒç”¨ã«ã•ã‚ŒãŸ~memberã‚‚ã‚ã‚‹';
	href= `~HTMLLS/obsolete.html#${key}-partial`;
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">ï¼Š</a>`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


â—â—options

spec_date:2025-05-29
trans_update:2025-05-29
source_checked:240415
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/scripting.html
	abbr_url:HEscripting
nav_prev:HEinteractive
nav_next:HEcanvas
trans_1st_pub:2016-04-27


â—â—class_map
e:element
a:attr
et:event-type
P:production
st:attr-state
v:value
E:error
sl:js-slot
obsMb:comment

â—â—tag_map
I:code
m:code
E:code
c:code
e:code
a:code
et:code
st:i
P:code
s:samp
v:code
sl:span
V:var
i:i
cite:cite
obsMb:span
em:em

â—â—original_id_map

	the-script-element:script
	execute-the-script-element:execute-the-script-block
	prepare-the-script-element:prepare-a-script
	script-force-async:non-blocking
	concept-script-result:concept-script-script

â—â—mdn_urls
the-noscript-element:HTML/Element/noscript
the-script-element:HTML/Element/script
the-slot-element:HTML/Element/slot
the-template-element:HTML/Element/template

	assignednodesoptions:API/AssignedNodesOptions
htmlscriptelement:API/HTMLScriptElement
htmlslotelement:API/HTMLSlotElement
htmltemplateelement:API/HTMLTemplateElement

â—â—link_map

	â—e
e.script:#the-script-element
e.slot:#the-slot-element
e.template:#the-template-element
e.noscript:#the-noscript-element

e.p:~HEgrouping#the-p-element
e.figure:~HEgrouping#the-figure-element

e.head:~HEmetadata#the-head-element
e.link:~HEmetadata#the-link-element
e.meta:~HEmetadata#the-meta-element
e.style:~HEmetadata#the-style-element


e.colgroup:~HEtables#the-colgroup-element
e.details:~HEinteractive#the-details-element

	â—attr
a.async:#attr-script-async
a.blocking:#attr-script-blocking
a.charset:~HTMLobs#attr-script-charset
a.crossorigin:#attr-script-crossorigin
a.defer:#attr-script-defer
a.event:~HTMLobs#attr-script-event
a.fetchpriority:#attr-script-fetchpriority
a.for:~HTMLobs#attr-script-for
a.language:~HTMLobs#attr-script-language
a.nomodule:#attr-script-nomodule
a.name:#attr-slot-name
a.integrity:#attr-script-integrity
a.referrerpolicy:#attr-script-referrerpolicy
a.span:~HEtables#attr-colgroup-span
a.src:#attr-script-src
a.type:#attr-script-type
a.shadowrootclonable:#attr-template-shadowrootclonable
a.shadowrootcustomelementregistry:#attr-template-shadowrootcustomelementregistry
a.shadowrootserializable:#attr-template-shadowrootserializable
a.shadowrootdelegatesfocus:#attr-template-shadowrootdelegatesfocus
a.shadowrootmode:#attr-template-shadowrootmode
a.slot:~HTMLdom#attr-slot

	â—IDL 
CEReactions:~HEcustom#cereactions
HTMLConstructor:~HTMLdom#htmlconstructor

I.AssignedNodesOptions:#assignednodesoptions
I.DOMParser:~HTMLdynamic#domparser
I.Document:~HTMLdom#document
I.DocumentFragment:~DOM4#interface-documentfragment
I.DOMTokenList:~DOM4#interface-domtokenlist
I.Element:~DOM4#interface-element
I.HTMLElement:~HTMLdom#htmlelement
I.HTMLScriptElement:#htmlscriptelement
I.HTMLSlotElement:#htmlslotelement
I.HTMLTemplateElement:#htmltemplateelement
I.ShadowRoot:~DOM4#interface-shadowroot
I.Text:~DOM4#interface-text
I.Window:~WINDOW#window
I.WorkerType:~WORKERS#workertype
I.XMLHttpRequest:~XHR#xmlhttprequest
I.XSLTProcessor:~HTMLdep#xsltprocessor

æ–‡æ›¸ç‰‡:#_documentfragment
æ–‡æ›¸:~HTMLdom#the-document-object

	â—m

m.append:~DOM4#dom-parentnode-append
	èª¤ï¼‰m.append:~DOM4#dom-node-append
m.appendChild:~DOM4#dom-node-appendchild
m.assign:#dom-slot-assign
m.assignedNodes:#dom-slot-assignednodes
m.assignedElements:#dom-slot-assignedelements

m.async:#dom-script-async
m.blocking:#dom-script-blocking
m.cloneNode:~DOM4#dom-node-clonenode
m.content:#dom-template-content
m.createDocument:~DOM4#dom-domimplementation-createdocument
m.crossOrigin:#dom-script-crossorigin
m.currentScript:~HTMLdom#dom-document-currentscript
m.defer:#dom-script-defer
m.document.createElementNS:~DOM4#dom-document-createelementns
m.document.importNode:~DOM4#dom-document-importnode
m.document.write:~HTMLdynamic#dom-document-write
m.fetchPriority:#dom-script-fetchpriority
m.flatten:#dom-assignednodesoptions-flatten
m.innerHTML:~HTMLdynamic#dom-element-innerhtml
m.outerHTML:~HTMLdynamic#dom-element-outerhtml
m.noModule:#dom-script-nomodule
m.name:#dom-slot-name
m.integrity:#dom-script-integrity
m.referrerPolicy:#dom-script-referrerpolicy
m.responseXML:~XHR#dom-xmlhttprequest-responsexml
m.shadowRootClonable:#dom-template-shadowrootclonable
m.shadowRootSerializable:#dom-template-shadowrootserializable
m.shadowRootCustomElementRegistry:#dom-template-shadowrootcustomelementregistry
m.shadowRootDelegatesFocus:#dom-template-shadowrootdelegatesfocus
m.shadowRootMode:#dom-template-shadowrootmode
m.src:#dom-script-src
m.supports:#dom-script-supports
	m.supports:~DOM4#dom-domtokenlist-supports
m.text:#dom-script-text
	m.textContent:~DOM4#dom-node-textcontent
m.transformToDocument:~HTMLdep#dom-xsltprocessor-transformtodocument
m.transformToFragment:~HTMLdep#dom-xsltprocessor-transformtofragment
m.type:#dom-script-type
m.value:~DOM4#dom-domtokenlist-value

m.new Worker:~WORKERS#dom-worker

	â—code ä»–
c.text/javascript:~HTMLindex#text/javascript

et.load:~HTMLindex#event-load
et.error:~HTMLindex#event-error

sl.CryptographicNonce:~HTMLurl#cryptographicnonce

v.open:#attr-shadowrootmode-open
v.closed:#attr-shadowrootmode-closed

st.é–‹ãª:#attr-shadowrootmode-open-state
st.é–‰ãª:#attr-shadowrootmode-closed-state
st.ãªã—:#attr-shadowrootmode-none-state

	â—ç”¨èª

scE.æ§‹æ–‡è§£æå™¨~æ–‡æ›¸:#parser-document
scE.æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸:#preparation-time-document
scE.å¤–éƒ¨~fileã‹:#concept-script-external
scE.æ§‹æ–‡è§£æå™¨ã«ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã«æº–å‚™æ¸ˆã¿ã‹:#ready-to-be-parser-executed
scE.ç¨®åˆ¥:#concept-script-type
scE.~load~eventã‚’é…å»¶ã—ã¦ã„ã‚‹ã‹:#concept-script-delay-load
scE.çµæœ:#concept-script-result
scE.çµæœã¯æº–å‚™æ¸ˆã¿æ™‚ã®æ‰‹ç¶šã:#steps-to-run-when-the-result-is-ready
scE.éåŒæœŸcã‚’å¼·åˆ¶ã™ã‚‹ã‹:#script-force-async
scE.ã™ã§ã«é–‹å§‹ã—ãŸã‹:#already-started

æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸ:#parser-inserted
~data~block:#data-block

~scriptè¦ç´ ã‚’å®Ÿè¡Œã™ã‚‹:#execute-the-script-element
~scriptè¦ç´ ã‚’æº–å‚™ã™ã‚‹:#prepare-the-script-element
æº–å‚™-:#prepare-the-script-element
~scriptè¦ç´ ã‚’æº–å‚™æ¸ˆã¿ã«ã™ã‚‹:#mark-as-ready

æ–‡æ›¸ã®æ§‹æ–‡è§£æã‚’å®Œé‚ã—ãŸã¨ãå®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹~scriptãŸã¡ãŒæˆã™~list:#list-of-scripts-that-will-execute-when-the-document-has-finished-parsing
ã‚¢ãƒªãªé™ã‚Šã™ãã«é †ã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptãŸã¡ãŒæˆã™~list:#list-of-scripts-that-will-execute-in-order-as-soon-as-possible
ã‚¢ãƒªãªé™ã‚Šã™ãã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptãŸã¡ãŒæˆã™é›†åˆ:#set-of-scripts-that-will-execute-as-soon-as-possible

æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹~script:#pending-parsing-blocking-script

~templateå†…å®¹:#template-contents
~templateå†…å®¹ã‚’æ‰€æœ‰ã™ã‚‹é©åˆ‡ãªæ–‡æ›¸:#appropriate-template-contents-owner-document
	é©åˆ‡ãª~templateå†…å®¹~æ‰€æœ‰è€…~æ–‡æ›¸
ä¸æ´»~templateæ–‡æ›¸:#associated-inert-template-document

~formæå‡º:~HTMLforms#form-submission

~scriptå†…å®¹~åˆ¶ç´„:#restrictions-for-contents-of-script-elements
~scriptæ–‡æ›¸åŒ–:#inline-documentation-for-external-scripts

æ‰‹å‹•ã§å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤:#manually-assigned-nodes

	â—ç”¨èª DOM
~nodeã‚’å—å…¥ã™ã‚‹:~DOM4#concept-node-adopt
~HTMLæ–‡æ›¸:~DOM4#html-document
~XMLæ–‡æ›¸:~DOM4#xml-document
doc.ç¨®åˆ¥:~DOM4#concept-document-type
å—å…¥-æ™‚ã®æ‰‹ç¶šã:~DOM4#concept-node-adopt-ext
~nodeã‚’~cloneã™ã‚‹:~DOM4#concept-node-clone
~cloneæ™‚ã®æ‰‹ç¶šã:~DOM4#concept-node-clone-ext
å­~ç¾¤~å¤‰æ›´-æ™‚ã®æ‰‹ç¶šã:~DOM4#concept-node-children-changed-ext
æŒ¿å…¥-æ™‚ã®æ‰‹ç¶šã:~DOM4#concept-node-insert-ext
å±æ€§~å¤‰æ›´-æ™‚ã®æ‰‹ç¶šã:~DOM4#concept-element-attributes-change-ext
~host:~DOM4#concept-documentfragment-host
æ–‡æ›¸~treeå†…:~DOM4#in-a-document-tree
æ¥ç¶šã•ã‚Œã¦:~DOM4#connected
~nodeæ–‡æ›¸:~DOM4#concept-node-document
~shadow~tree:~DOM4#concept-shadow-tree
å­~ç¾¤:~DOM4#concept-tree-child
sR.~focusã‚’å§”ä»»ã™ã‚‹ã‹:~DOM4#shadowroot-delegates-focus
sR.~mode:~DOM4#shadowroot-mode
sR.~cloneå¯èƒ½ã‹:~DOM4#shadowroot-clonable
sR.ç›´åˆ—åŒ–-å¯èƒ½ã‹:~DOM4#shadowroot-serializable

~slot:~DOM4#concept-slot
~slotã«å‰²å½“ã™ã‚‹:~DOM4#assign-a-slot
~slotå:~DOM4#slot-name
~slotç”¨ã«å¹³å¦~åŒ–ã•ã‚ŒãŸ~slotå¯èƒ½ãªã‚‚ã®ã‚’è¦‹å‡ºã™:~DOM4#find-flattened-slotables
~treeã«~slotå¯èƒ½ãªã‚‚ã®ã‚’å‰²å½“ã™ã‚‹:~DOM4#assign-slotables-for-a-tree
~slotå¯èƒ½:~DOM4#concept-slotable
æ‰‹å‹•~å‰²å½“-å…ˆ~slot:~DOM4#slottable-manual-slot-assignment
å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤:~DOM4#slot-assigned-nodes

doc.ç¬¦å·åŒ–æ³•:~DOM4#concept-document-encoding
~treeé †åº:~DOM4#concept-tree-order
æ ¹:~DOM4#concept-tree-root
~shadowæ ¹:~DOM4#concept-shadow-root
~eventã‚’ç™ºç«ã™ã‚‹:~DOM4#concept-event-fire
å­~textå†…å®¹:~DOM4#concept-child-text-content
å­å­«~textå†…å®¹:~DOM4#concept-descendant-text-content
å…¨~å†…å®¹ã‚’æ–‡å­—åˆ—ã«ç½®æ›ã™ã‚‹:~DOM4#string-replace-all

~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹:~INFRA#ascii-lowercase
~ASCIIå¤§å°ç„¡è¦–:~INFRA#ascii-case-insensitive
å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã:~INFRA#strip-leading-and-trailing-ascii-whitespace
~scalarå€¤:~INFRA#scalar-value
æœ‰é †åº~é›†åˆ:~INFRA#ordered-set
set.ä»˜åŠ ã™ã‚‹:~INFRA#set-append
~list:~INFRA#list
é™¤å»ã™ã‚‹:~INFRA#list-remove
ä»˜åŠ ã™ã‚‹:~INFRA#list-append

	â—HTMLINFRA

å³æ™‚:~HTMLINFRA#immediately
æ¥ç¶šã•ã‚Œ:~HTMLINFRA#becomes-connected
ä¸¦åˆ—çš„:~HTMLINFRA#in-parallel
æ–‡æ›¸ã®ä¸­ã¸æŒ¿å…¥ã•ã‚ŒãŸ:~HTMLINFRA#insert-an-element-into-a-document
~HTMLè¦ç´ ~æ¥ç¶š~å¾Œã®æ‰‹ç¶šã:~HTMLINFRA#html-element-post-connection-steps

çœŸå½-å±æ€§:~HTMLcms#boolean-attribute
åˆ—æŒ™då±æ€§:~HTMLcms#enumerated-attribute
å¦¥å½“ã§ãªã„å€¤~ç”¨ã®æ—¢å®šã®çŠ¶æ…‹:~HTMLcms#invalid-value-default
æ¬ è½~å€¤~ç”¨ã®æ—¢å®šã®çŠ¶æ…‹:~HTMLcms#missing-value-default
åæ˜ ã™ã‚‹:~HTMLcdom#reflect
æ—¢çŸ¥ãªå€¤ã®ã¿ã«åˆ¶é™ã•ã‚Œ:~HTMLcdom#limited-to-only-known-values

~CORSè¨­å®šç¾¤~å±æ€§:~HTMLurl#cors-settings-attribute
~referreræ–½ç­–~å±æ€§:~HTMLurl#referrer-policy-attribute
~CORSè¨­å®šç¾¤~å±æ€§ã®è³‡æ ¼è¨¼~mode:~HTMLurl#cors-settings-attribute-credentials-mode
~Content-Type~header:~HTMLurl#content-type
~URLã‚’ç¬¦å·åŒ–æ³•ã®ä¸‹ã§ç›¸å¯¾çš„ã«æ§‹æ–‡è§£æã™ã‚‹:~HTMLurl#encoding-parsing-a-url
æ–‡æ›¸~åŸºåº•~URL:~HTMLurl#document-base-url
å‰å¾Œ~ç©ºç™½~å¯ã®å¦¥å½“ã‹ã¤ç©ºã§ãªã„~URL:~HTMLurl#valid-non-empty-url-potentially-surrounded-by-spaces
å…·ç¾åŒ–ã‚’é˜»ã‚€èƒ½æ€§:~HTMLurl#potentially-render-blocking
æš—é»™çš„ã«å…·ç¾åŒ–ã‚’é˜»ã‚€èƒ½æ€§:~HTMLurl#implicitly-potentially-render-blocking
ä»–ã‚’é˜»ã‚€å±æ€§:~HTMLurl#blocking-attribute
~fetchå„ªå…ˆåº¦~å±æ€§:~HTMLurl#fetch-priority-attribute


	â—HTMLdom
åˆ†é¡:~HTMLdom#concept-element-categories
å†…å®¹~å±æ€§:~HTMLdom#concept-element-attributes
å†…å®¹~model:~HTMLdom#concept-element-content-model
ãªã—:~HTMLdom#concept-content-nothing
ã“ã®è¦ç´ ã‚’åˆ©ç”¨ã§ãã‚‹æ–‡è„ˆ:~HTMLdom#concept-element-contexts
~accessibilityã®è€ƒæ…®ç‚¹:~HTMLdom#concept-element-accessibility-considerations
~DOM~interface:~HTMLdom#concept-element-dom
~flowå†…å®¹:~HTMLdom#flow-content-2
å¤§åŸŸ~å±æ€§:~HTMLdom#global-attributes
~metadataå†…å®¹:~HTMLdom#metadata-content-2
å¥ngå†…å®¹:~HTMLdom#phrasing-content-2
~scriptã‚’~supportã™ã‚‹è¦ç´ :~HTMLdom#script-supporting-elements-2
text/html ã«ãŠã‘ã‚‹~tagçœç•¥:~HTMLdom#concept-element-tag-omission
é€éçš„:~HTMLdom#transparent
è¡¨ç¾-:~HTMLdom#represents
å…·ç¾åŒ–ã‚’é˜»ã¾ãªãã™ã‚‹:~HTMLdom#unblock-rendering
å…·ç¾åŒ–ã‚’é˜»ã‚€:~HTMLdom#block-rendering
å…·ç¾åŒ–ã‚’é˜»ã‚“ã§:~HTMLdom#render-blocking


	â—WAPI
~script:~WAPI#concept-script
å¤å…¸~script:~WAPI#classic-script
å¤å…¸~scriptã‚’~fetchã™ã‚‹:~WAPI#fetch-a-classic-script
å¤å…¸~scriptã‚’èµ°ã‚‰ã™:~WAPI#run-a-classic-script
å¤å…¸~scriptã‚’ä½œæˆã™ã‚‹:~WAPI#creating-a-classic-script
~inline~module~script~graphã‚’~fetchã™ã‚‹:~WAPI#fetch-an-inline-module-script-graph
ç ´å£Šçš„ãªæ›¸è¾¼nã¯ç„¡è¦–ã™ã‚‹~counter:~HTMLdynamic#ignore-destructive-writes-counter

~module~script:~WAPI#module-script
~JS~module~script:~WAPI#javascript-module-script
~JSON~module~script:~WAPI#json-module-script
~CSS~module~script:~WAPI#css-module-script
~module~scriptã‚’èµ°ã‚‰ã™:~WAPI#run-a-module-script
å¤–éƒ¨~module~script~graphã‚’~fetchã™ã‚‹:~WAPI#fetch-a-module-script-tree
~moduleæŒ‡å®šå­ã‚’è§£æ±ºã™ã‚‹:~WAPI#resolve-a-module-specifier
~moduleå®Œå…¨æ€§~metadataã‚’è§£æ±ºã™ã‚‹:~WAPI#resolving-a-module-integrity-metadata
è¦ç´ ~taskã‚’~queueã™ã‚‹:~WAPI#queue-an-element-task
~DOMæ“ä½œ~task~source:~WAPI#dom-manipulation-task-source
~networkç”¨~task~source:~WAPI#networking-task-source
~scripting:~WAPI#scripting
	ï¼ ~WAPI#concept-environment-noscript
~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦:~WAPI#concept-n-noscript
~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦:~WAPI#concept-n-script
é–¢é€£ãªè¨­å®šç¾¤~obj:~WAPI#relevant-settings-object
å¤§åŸŸ~obj:~WAPI#global-object
é–¢é€£ãªå¤§åŸŸ~obj:~WAPI#concept-relevant-global

~script~fetch~optionç¾¤:~WAPI#script-fetch-options
sfO.æš—å·ç”¨~nonce:~WAPI#concept-script-fetch-options-nonce
sfO.å®Œå…¨æ€§~metadata:~WAPI#concept-script-fetch-options-integrity
sfO.æ§‹æ–‡è§£æå™¨~metadata:~WAPI#concept-script-fetch-options-parser
sfO.è³‡æ ¼è¨¼~mode:~WAPI#concept-script-fetch-options-credentials
sfO.~referreræ–½ç­–:~WAPI#concept-script-fetch-options-referrer-policy
sfO.~fetchå„ªå…ˆåº¦:~WAPI#concept-script-fetch-options-fetch-priority
sfO.å…·ç¾åŒ–ã‚’é˜»ã‚“ã§ã„ã‚‹ã‹:~WAPI#concept-script-fetch-options-render-blocking

~import~map:~WAPI#import-map
~import~mapæ§‹æ–‡è§£æ-çµæœ:~WAPI#import-map-parse-result
~import~mapæ§‹æ–‡è§£æ-çµæœã‚’ä½œæˆã™ã‚‹:~WAPI#create-an-import-map-parse-result
~import~mapã‚’ç™»éŒ²ã™ã‚‹:~WAPI#register-an-import-map
~import~mapè‘—ä½œ~è¦ä»¶:~WAPI#import-map-authoring-requirements


	â—HTML
æ§‹æ–‡è§£æ-~error:~HTMLparsing#parse-errors
~load~eventã‚’é…å»¶ã™ã‚‹:~HTMLparsing#delay-the-load-event
~HTMLç´ ç‰‡~æ§‹æ–‡è§£æ~algo:~HTMLparsing#html-fragment-parsing-algorithm
~HTMLæ§‹æ–‡è§£æå™¨:~HTMLparsing#html-parser
V.æ–‡è„ˆ~è¦ç´ :~HTMLparsing#concept-frag-parse-context
	~end:~HTMLparsing#scriptEndTag
~scriptå…¥å­ng~level:~HTMLparsing#script-nesting-level

~XMLæ§‹æ–‡è§£æå™¨:~HTMLxml#xml-parser

é–²è¦§~æ–‡è„ˆ:~HTMLds#browsing-context
å±ã™ã‚‹é–²è¦§~æ–‡è„ˆ:~HTMLds#concept-document-bc

ç”Ÿæˆå…ƒ:~ORIGIN#concept-origin
~scriptã‚’é˜»ã‚“ã§ã„ã‚‹~stylesheetã¯åœ¨ã‚‹ã‹ï¼Ÿ:~HEmetadata#has-a-style-sheet-that-is-blocking-scripts

~HTMLæ§‹æ–‡:~HTMLwriting#syntax
~XMLæ§‹æ–‡:~HTMLxml#the-xhtml-syntax


	â—others
~CORS~protocol:~FETCH#http-cors-protocol
rq.è³‡æ ¼è¨¼~mode:~FETCH#concept-request-credentials-mode
rq.å®Œå…¨æ€§~metadata:~FETCH#concept-request-integrity-metadata
rq.å„ªå…ˆåº¦:~FETCH#request-priority
~fetch:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch

ç¬¦å·åŒ–æ³•:~ENCODING#encoding
~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹:~ENCODING#concept-encoding-get

~URL:~URL1#concept-url

~referreræ–½ç­–:~REFERRER-POLICY#referrer-policy

~MIMEå‹:~MIMESNIFF#mime-type
å¦¥å½“ãª~MIMEå‹~æ–‡å­—åˆ—:~MIMESNIFF#valid-mime-type
~JS~MIMEå‹:~MIMESNIFF#javascript-mime-type
~JSON~MIMEå‹:~MIMESNIFF#json-mime-type
~JS~MIMEå‹ã«~essenceåˆè‡´-:~MIMESNIFF#javascript-mime-type-essence-match

P.Module:~TC39#prod-Module
P.Script:~TC39#prod-Script

è¦ç´ ã«ãŠã‘ã‚‹~inlineå‹ã®æŒ™å‹•ã¯~CSPã«ã‚ˆã‚Šé˜»æ­¢ã•ã‚Œã‚‹ã¹ãã‹ï¼Ÿ:~CSP3#should-block-inline


â—â—words_table1

â—â—words_table


	â—æ–‡å­—åˆ—ï¼æ§‹æ–‡
	mark:
å‰¥ã:stripã™ã‚‹:~
æ­£è¦è¡¨ç¾:regular expression::~
å¼:expression::~
çœç•¥:omission:~
çœç•¥ä¸å¯:omissibleã§ãªã„:~
æ–‡:statement:~
	`import^c æ–‡:statement

	â—slot
slot:
å‰²å½“-:assign::ã‚ã¦ãŒã„
å‰²å½“ã•ã‚Œ:assignã•ã‚Œ::ã‚ã¦ãŒã‚ã‚Œ
å‰²å½“ã™ã‚‹:assignã™ã‚‹::ã‚ã¦ãŒã†

	â—å‡¦ç†
	-:entry
å—å…¥-:adopt::~
	-:unset
å½¢å¼å¤‰æ›-:transform::~
å½¢å¼å¤‰æ›:transformation::~
	~scriptãªã—ã‚’å‰æã«:scriptless
ä¸æ´»:inert::~
import:
é˜»ã¿:blockã—::~::ãƒ–ãƒ­ãƒƒã‚¯ã—
	é˜»ã¾ãªããªã‚‹:unblocked
	ä»–ã‚’é˜»ã¾ãªã„:non-blocking
	-:pending
	parser-executed
	parser-inserted
	parsing-blocking
ç ´å£Šçš„:destructive::~
æ›¸è¾¼n:write::æ›¸ãè¾¼ã¿
	ç ´å£Šçš„ãªæ›¸è¾¼n:destructive-writes
æœªåˆæœŸåŒ–:uninitialized:~
å®Ÿè¡Œng:executing::å®Ÿè¡Œ
å„ªå…ˆåº¦:priority::~
ç¶šè¡Œ-:proceed:~
ä¸å¯åˆ†:atomic::~
	ä¸å¯åˆ†ã«:atomically
æ—§-:old:~

	è©•ä¾¡-:evaluation
	çŸ¥ã‚‰ã›ã‚‹:let ã€œ know
	ãã®ã¾ã¾:onward
	æ‰‹ç¶šã:series of steps
	ã®ã¾ã¾:left as

	â—å¤‰æ•°
	%~nodeé›†åˆ:nodesSet
	Â§ #script-processing-model
	%S:el
	%çµæœ:result
	%~node:node
	%è¤‡è£½:copy
	-:subtree
	%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸:parser document
	%~source~text:source text
	%~script~blockã®ç¨®åˆ¥~æ–‡å­—åˆ—:the script block's type string
	%å¤å…¸~script~CORSè¨­å®š:classic script CORS setting:#1
	%~module~scriptè³‡æ ¼è¨¼~mode:module script credentials mode
	%æš—å·ç”¨~nonce:cryptographic nonce
	%å®Œå…¨æ€§~metadata:integrity metadata
	%~referreræ–½ç­–:referrer policy
	%æ§‹æ–‡è§£æå™¨~metadata:parser metadata
	%~optionç¾¤:options 
	%è¨­å®šç¾¤~obj:settings object
	%src:src
	%~URL:url
	%åŸºåº•~URL:base URL
	%~scriptç¾¤:scripts
	%æ–‡æ›¸:document 
	%ç¬¦å·åŒ–æ³•:encoding
	%~scriptç¨®åˆ¥:-
	%type:-
	%language:-
	%å®Œäº†-æ™‚ã®æ‰‹ç¶šã:onComplete
	%~fetchå„ªå…ˆåº¦:fetch priority
	%æŒ¿å…¥ã•ã‚ŒãŸ~node:insertedNode
	%è¦ç´ :element
	%å±€æ‰€~å:localName
	%æ—§-å€¤:oldValue
	%å€¤:value
	%åå‰ç©ºé–“:namespace

	â—fetchï¼networkï¼ä¿å®‰
	äº‹å‰~fetching:prefetching
Content-Type:
nonce::::ãƒŠãƒ³ã‚¹
load:
æš—å·ç”¨:cryptographic::~
	é˜»æ­¢ã•ã‚Œã‚‹^i:Blocked
	~streamæ³•:streaming

	â—å†…å®¹model
å¥ng:phrasing::å¥::ãƒ•ãƒ¬ãƒ¼ã‚¸ãƒ³ã‚°
é€éçš„:transparent::~
å¤–æ¥:foreign::~
åˆ†é¡:category:~
	categories

	â—ä»•æ§˜

ä¸Šå“:graceful:~
å†—é•·:redundant:~
å›³å¼:schematic diagram:~

è‡ªæ˜:trivial:~
ä¸ç”¨æ„:accidental:~
å¤‰å‰‡çš„:strange:~
è¡çª:collision:~

ä»£ç†:proxy::~
ä¾å­˜ç‰©:dependencies:~
æç¤º-:present:~
é™¥ç©½:pitfall:è½ã¨ã—ç©´
é€€è¡Œ-:degrade:~
	-:relate
æµªè²»-:waste:~
é¸æŠçš„:selective:~
ç«¶åˆ-:conflict:~
æ¡ç”¨-:adopt:~
å…ã‚Œã‚‹:exemptã™ã‚‹:~
æœ¬ç‰©ã®:realãª:~
æƒã†:alignã™ã‚‹:~
èª¬æ˜æ›¸ã:explainer:~
èƒ½æ€§:potential:~
æµå„€:fashion:~
æ¦‚ç•¥çš„:brief:~
æ—§ã„:older:~

	è§£é‡ˆã—ç›´ã™:reinterpret
	ã»ã¼å®šç¾©ã•ã‚Œã¦ã„ãªã„:poorly-defined
	å¼·èª¿è¡¨ç¤º:highlight
	~~èª¬æ˜:illustrate
	hope
	interesting
	likely
	æ³¨ç›®ã™ã¹ã:notable
	potential
	put
	æ•£ã‚‰ã°ã£ã¦:scattered
	æ˜“ã:help
	é¢ã—ãŸ-:face:
	refer
	ã¡ã‚‡ã£ã¨ã—ãŸã“ã¨ã§æŠµè§¦ã—æ˜“ã:prone to triggering:
	ã“ã“ã§èµ·ãã¦ã„ã‚‹ã“ã¨:What is going on here 
	ã‘ã£ãŸã„ãªèª­ã¿ç‰©ã«å¤‰ãˆã¦ã—ã¾ã†more interesting reading experience
	chosen
	using
	-:Suppose
	è¨˜ã•ã‚Œ:put
	è¦‹ã‹ã‘ï¼æ§˜ã«è¦‹ãˆã‚‹:look 
	åˆ‡ã‚‹:turning off
	ãµã‚‹ã¾ã„:act
	-:encountered therein
	ã‚ˆã‚Šæ˜ç¢ºã«ã¯:for clarification
	ã‚¢ãƒªãªé™ã‚Šã™ãã«:as soon as possible
	å¯èƒ½æ€§ã‚‚ã‚ã‚‹:possible
	é€†ã«:conversely
	~~ç›´ã«è¨˜ã—ã¦:hard-coded
	accordingly
	ã²ã­ãã‚ŒãŸå–æ‰±ã„:contortion
	é¢¨å¤‰ã‚ã‚Šãª:exotic:
	å¾—ã‚‰ã‚Œã‚‹:gain
	no longer
	modulo
	namely
	ã–ã‚‹ã‚’å¾—ãªã:by necessity
	å½“é¢ã®é–“:meantimeï¼meanwhile
	~~ç†è§£ã—ãŒãŸã„:weird
	ãã®å ´ã§:on-the-fly
	ç›´æ„Ÿã«åã™ã‚‹:unintuitive
	éƒ¨åˆ†ã‚‚ã‚ã‚‹:somewhat
	é•ã„:distinction
	maybe
	ä¸€æ–¹ã§:however
	ã«ãªã‚‹ã“ã¨ã‚‚ã‚ã‚‹:potentially
	note
	ãªã¾ãã‚‰:blunt instrument
	~codeç‰‡:snippet
	é–¢å¿ƒäº‹ã«ãªã‚‹:interesting
	è¡¨ã™:denote
	~~æŒ‡ç¤º:denote

	â—æœªåˆ†é¡
XSLT:
XPath:
essence:
game::::ã‚²ãƒ¼ãƒ 
license::::ãƒ©ã‚¤ã‚»ãƒ³ã‚¹
strict:
template:
print:
video::::ãƒ“ãƒ‡ã‚ª
ä»£ç”¨-:substitute::~
	ä»£ç”¨-:substitution
é€£çµ-:concatenate:~
	concatenation
çµè¾¼ã‚“ã :filterã—ãŸ:çµã‚Šè¾¼ã‚“ã 
å‡¦ç†å‘½ä»¤:processing instruction:~
ãƒ‹ãƒ¥ãƒ¼ã‚¹ã‚µã‚¤ãƒˆ:news site::~
å¼±ã„:weakãª:~
é–‰ãª:closed::é–‰ã˜ãŸ
é–‹ãª:open::é–‹ã„ãŸ
æŒ‡ç¤ºæ›¸ã:instruction:~
	å­ãŸã¡:children
	owning
	-:destination
	å¢—æ¸›
	calling
	~cloneæ™‚ã®:cloning
	go
	going
	remain
	having
	labeled
	made
	marked
	é–‰ã˜ã‚‰ã‚ŒãŸ:closing
	å¯¾ã«:balance
	è¡Œã:go
	æ¢ã—ã¦look for
	æˆ»-:back 
	æ›¸-:write 
	ç¾ã‚Œ:appear 
	è©³ç´°è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹:show or hide
	ãªããªã‚‹:stop
	ç¯€:section 
	å¢—åˆ†:increment
	ã‚ˆã‚Šå¤§ããª:bigger
	direct-to-DOM
	non-empty
	earlier
	ç•°ãªã‚‹:differently
	å´:side
	end
	left
	è¡Œ:line
	fifth
	forth
	four-column
	piece
	mostly
	nonetheles
	previously
	ä»Š:now
	å†’é ­:top
	å¾Œã§:later
	ä»–æ‰€:other parts
	ä¸€éƒ¨:part of
	ever
	entire
	amongst
	ã‚‚ã®:thing
	ä¸»ãªï¼ä¸»:main 
	2 :two 
	å°½ãã‚‹ã¾ã§ï¼Œthere are no ã€œ left
	neither
	part
	somehow
	sometime
	until:
	-å¤–:outside
	åŒæ§˜:similar
	åºƒã:wide
	å‘¨ã‚Šã§:around
	~F ã®ã¾ã¾:not marked
	ã‚ˆã†ã«ãªã‚‹:get ã€œ
	å…ˆã«:earlier-
	å¾Œã‹ã‚‰:later-
	æ™‚ç‚¹ã¾ã§:by the time
	ã‚‚ã†ä¸€ã¤ã®:the second

â—â—html_code_list

â– script-2
<ï¼…script src="game-engine.js"><ï¼…/script>
<ï¼…script type="text/x-game-map">
........U.........e
o............A....e
.....A.....AAA....e
.A..AAA...AAAAA...e
<ï¼…/script>

â– script-3
<ï¼…script>
 function calculate(%form) {
   var %price = 832000;
   if (%form.elements.brakes.checked)
     %price += 160000;
   if (%form.elements.radio.checked)
     %price += 400000;
   if (%form.elements.turbo.checked)
     %price += 800000;
   if (%form.elements.sticker.checked)
     %price += 40000;
   %form.elements.result.value = price;
 }
<ï¼…/script>
<form
   name="pricecalc"
   onsubmit="return false"
   onchange="calculate(this)"
>
 <fieldset>
  <legend>è»Šä½“ä¾¡æ ¼ã‚’å†è¨ˆç®—ã™ã‚‹</legend>
  <p>åŸºæœ¬ä¾¡æ ¼ï¼š83 ä¸‡ 2000 å††</p>
  <p>è¿½åŠ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼š</p>
  <ul>
   <li><label><input type=checkbox name=brakes>
      ã‚»ãƒ©ãƒŸãƒƒã‚¯ãƒ–ãƒ¬ãƒ¼ã‚­ï¼ˆ 16 ä¸‡å††ï¼‰</label></li>
   <li><label><input type=checkbox name=radio>
      è¡›æ˜Ÿãƒ©ã‚¸ã‚ªï¼ˆ 40 ä¸‡å††ï¼‰</label></li>
   <li><label><input type=checkbox name=turbo>
      ã‚¿ãƒ¼ãƒœãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆ 80 ä¸‡å††ï¼‰</label></li>
   <li><label><input type=checkbox name=sticker>
      "XZ" ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ï¼ˆ 4 ä¸‡å††ï¼‰</label></li>
  </ul>
  <p>åˆè¨ˆä¾¡æ ¼ï¼š <output name=result></output> å††</p>
 </fieldset>
 <ï¼…script>
  calculate(document.forms.pricecalc);
 <ï¼…/script>
</form>

â– script-4
<ï¼…script type="module" src="app.mjs"><ï¼…/script>

â– script-5
<ï¼…script type="module" src="app.mjs"><ï¼…/script>
<ï¼…script nomodule defer src="classic-app-bundle.js"><ï¼…/script>

â– script-6
<ï¼…script type="module">
 import { walkAllTextNodeDescendants } from "./dom-utils.mjs";
ï¼…
 function substitute(%textNode) {
   %textNode.data = %textNode.data.replace( /ã€‚/g, "ã£ã½ã„ã€‚" );
 }
ï¼…
 walkAllTextNodeDescendants(document.body, substitute);
<ï¼…/script>

â– 
script-restrictions-1
script-restrictions-2
script-restrictions-3

â– script-processing-model-1
<ï¼…script>
const %script1 = document.createElement('script');
%script1.innerText = `
  document.querySelector('#script2').remove();
`;
ï¼…
const %script2 = document.createElement('script');
%script2.id = 'script2';
%script2.textContent = `console.log('script#2 running')`;
ï¼…
document.body.append(%script1, %script2);
<ï¼…/script>

â– script-processing-model-2
<ï¼…script id=outer-script><ï¼…/script>
ï¼…
<ï¼…script>
  const %outerScript = document.querySelector('#outer-script');
ï¼…
  const %start = new Text('console.log(1);');
  const %innerScript = document.createElement('script');
  %innerScript.textContent = `console.log('inner script executing')`;
  const %end = new Text('console.log(2);');
ï¼…
  %outerScript.append(%start, %innerScript, %end);
ï¼…
  // Logs:
  // 1
  // 2
  // inner script executing
<ï¼…/script>

â– inline-documentation-1
<ï¼…script src="cool-effects.js">
 // æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ï¼š
 //    var %e = new Effect();
 // åŠ¹æœã‚’é–‹å§‹ã™ã‚‹ï¼åœæ­¢ã™ã‚‹ã¨ãã¯ã€ .play() ï¼ .stop() ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ï¼š
 //    %e.play();
 //    %e.stop();
<ï¼…/script>

 // create new instances using:
 //    var e = new Effect();
 // start the effect using .play, stop using .stop:

â– noscript-1
<form action="calcSquare.php">
 <p>
  <label for=x>æ•°å€¤</label>:
  <input id="x" name="x" type="number">
 </p>
 <ï¼…script>
  var %x = document.getElementById('x');
  var %output = document.createElement('p');
  %output.textContent = 'æ•°å€¤ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚äºŒä¹—ã—ãŸçµæœãŒè¿”ã•ã‚Œã¾ã™ã€‚';
  %x.form.appendChild(%output);
  %x.form.onsubmit = function () { return false; }
  %x.oninput = function () {
    var %v = %x.valueAsNumber;
    %output.textContent = %v + ' ã®äºŒä¹—ã¯ ' + %v * %v ' ã§ã™ã€‚';
  };
 <ï¼…/script>
 <ï¼…noscript>
  <input type=submit value="äºŒä¹—ã‚’è¨ˆç®—ã™ã‚‹">
 <ï¼…/noscript>
</form>

Number
  output.textContent = 'Type a number; it will be squared right then!';


â– noscript-2
<form action="calcSquare.php">
 <p>
  <label for=x>æ•°å€¤</label>:
  <input id="x" name="x" type="number">
 </p>
 ï¼œ<input id="submit" type=submit value="äºŒä¹—ã‚’è¨ˆç®—ã™ã‚‹">ï¼
 <ï¼…script>
  var %x = document.getElementById('x');
  var %output = document.createElement('p');
  %output.textContent = 'æ•°å€¤ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚äºŒä¹—ã—ãŸçµæœãŒè¿”ã•ã‚Œã¾ã™ã€‚';
  %x.form.appendChild(%output);
  %x.form.onsubmit = function () { return false; }
  %x.oninput = function () {
    var %v = %x.valueAsNumber;
    %output.textContent = %v + ' ã®äºŒä¹—ã¯ ' + %v * %v ' ã§ã™ã€‚';
  };
  ï¼œvar %submit = document.getElementById('submit');ï¼
  ï¼œ%submit.parentNode.removeChild(%submit);ï¼
 <ï¼…/script>
</form>

â– template-1
<!doctype html>
<html lang="ja">
 <head>
  <title>å®¿é¡Œ</title>
 <body>
  <template id="template"><p>ğŸ˜€</p></template>
  <ï¼…script>
   let %num = 3;
   const %fragment =
      document.getElementById('template').content.cloneNode(true);
   while (%num -- > 1) {
     %fragment.firstChild.before(%fragment.firstChild.cloneNode(true));
     %fragment.firstChild.textContent += %fragment.lastChild.textContent;
   }
   document.body.appendChild(%fragment);
  <ï¼…/script>
</html>

â– template-2
<!DOCTYPE html>
<html lang='en'>
<title>Cat data</title>
<ï¼…script>
 // ã“ã“ã§ã¯ãƒ‡ãƒ¼ã‚¿ã‚’ç›´ã«è¨˜ã—ã¦ã„ã‚‹ãŒã€ã‚µãƒ¼ãƒã‹ã‚‰å¾—ã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
 var %data = [
   {
      name: 'Pillar',
      color: 'Ticked Tabby',
      sex: 'Female (neutered)',
      legs: 3
   },
   {
      name: 'Hedral',
      color: 'Tuxedo',
      sex: 'Male (neutered)',
      legs: 4
   },
 ];
<ï¼…/script>
<table>
 <thead>
  <tr>
   <th>Name <th>Colour <th>Sex <th>Legs
 <tbody>
  <template id="row">
   <tr><td><td><td><td>
  </template>
</table>
<ï¼…script>
 var %template = document.querySelector('#row');
 for (var %i = 0; %i < %data.length; %i += 1) {
   var %cat = data[%i];
   var %clone = %template.content.cloneNode(true);
   var %cells = %clone.querySelectorAll('td');
   %cells[0].textContent = %cat.name;
   %cells[1].textContent = %cat.color;
   %cells[2].textContent = %cat.sex;
   %cells[3].textContent = %cat.legs;
   %template.parentNode.appendChild(%clone);
 }
<ï¼…/script>

â—â—images
ï¼ HTML-resources/
asyncdeferï½œmin-width:720px; min-height:220px;ï½œï½œ.svg

â—â—trans_metadata
<p>
~THIS_PAGEã¯ã€~WHATWGã«ã‚ˆã‚‹
HTML ä»•æ§˜ã®ï¼ˆ Â§ The elements of HTML å†…ã®ï¼‰
<a href="~SPEC_URL">Â§ Scripting</a>
ã‚’æ—¥æœ¬èªã«ç¿»è¨³ã—ãŸã‚‚ã®ã§ã™ã€‚
~PUB
</p>

</script>

</head>

<body>

<header>
	<hgroup>
<h1>HTML â€” ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®åˆ©ç”¨</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="scripting-3">
<h3 title="Scripting">4.12. ~scriptã®åˆ©ç”¨</h3>

<p>
~scriptã¯ã€
æ–‡æ›¸ã«ãƒ¤ãƒªãƒˆãƒª-~~èƒ½ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã‚’ä½œè€…ã«è¨±å®¹ã™ã‚‹ã€‚
â—
Scripts allow authors to add interactivity to their documents.
</p>

<p>
ä½œè€…ã«ã¯ã€
ã‚¢ãƒªãªæ‰€ã§ã¯ï¼Œ
~scriptingã‚’ä»£æ›¿ã™ã‚‹å®£è¨€çš„ãªä»•çµ„ã¿ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹
â€” ãã†ã—ãŸæ–¹ãŒä¿å®ˆã—æ˜“ããªã‚‹ã“ã¨ãŒå¤šãã€
ã¾ãŸï¼Œ~scriptingã‚’ä¸èƒ½åŒ–ã—ã¦ã„ã‚‹åˆ©ç”¨è€…ã‚‚å¤šãã„ã‚‹ã€‚
â—
Authors are encouraged to use declarative alternatives to scripting where possible, as declarative mechanisms are often more maintainable, and many users disable scripting.
</p>

<div class="example">
<p>
ä¾‹ãˆã°ã€
~scriptã‚’åˆ©ç”¨ã—ã¦ï¼Œã‚ã‚‹ä¸€ç¯€ã®è©³ç´°è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹ä»£ã‚ã‚Šã«ã€
`details$e è¦ç´ ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
â—
For example, instead of using a script to show or hide a section to show more details, the details element could be used.
</p>
</div>

<p>
ä½œè€…ã«ã¯ï¼Œã¾ãŸã€ï¼»
~scripting~supportãŒç„¡ã„ä¸‹ã§ã¯ï¼Œè‡ªèº«ã®~appã‚’ä¸Šå“ã«é€€è¡Œã•ã›ã‚‹
ï¼½ã“ã¨ã‚‚å¥¨åŠ±ã•ã‚Œã‚‹ã€‚
â—
Authors are also encouraged to make their applications degrade gracefully in the absence of scripting support.
</p>

<div class="example">
<p>
ä¾‹ãˆã°ä½œè€…ã¯ã€
~tableã®~headerå†…ã«ï¼Œ~tableã‚’å‹•çš„ã«~sortã—ç›´ã™ã‚ˆã†ãª~linkã‚’ä¾›ã—ã¦ã„ã‚‹å ´åˆã€
~serverã«~sortæ¸ˆã¿ãª~tableã‚’è¦è«‹ã™ã‚‹ã“ã¨ã§ï¼Œ~scriptãªã—ã«~linkã‚’æ©Ÿèƒ½ã•ã›ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
â—
For example, if an author provides a link in a table header to dynamically resort the table, the link could also be made to function without scripts by requesting the sorted table from the server.
</p>
</div>

		<section id="_conventions">
<h4>ã€ã“ã®è¨³ã«ç‰¹æœ‰ãªè¡¨è¨˜è¦ç´„ã€‘</h4>

â—è¡¨è¨˜è¨˜å·

<p>
ç”¨èª
`æ–‡æ›¸ç‰‡@
ã¯ã€
`DocumentFragment$I ~objã®ç•¥è¨˜ã§ã‚ã‚‹ã€‚
</p>

		</section>
		<section id="the-script-element">
<h4 title="The script element">4.12.1. `script^e è¦ç´ </h4>

<dl class="element-def">
	<dt>`åˆ†é¡$ï¼š</dt>
	<dd>
`~metadataå†…å®¹$ ï¼ `~flowå†…å®¹$ ï¼ `å¥ngå†…å®¹$ ï¼ `~scriptã‚’~supportã™ã‚‹è¦ç´ $
â—
Metadata content.
â—
Flow content.
â—
Phrasing content.
â—
Script-supporting element.
</dd>

	<dt>`ã“ã®è¦ç´ ã‚’åˆ©ç”¨ã§ãã‚‹æ–‡è„ˆ$ï¼š</dt>
	<dd>
`~metadataå†…å®¹$ ï¼
`å¥ngå†…å®¹$ ï¼
`~scriptã‚’~supportã™ã‚‹è¦ç´ $
ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€ã€‚
â—
Where metadata content is expected.
â—
Where phrasing content is expected.
â—
Where script-supporting elements are expected.
</dd>

	<dt>`å†…å®¹~model$ï¼š</dt>
	<dd>
`src$a å±æ€§ã‚’æœ‰ã•ãªã„å ´åˆã€
`type$a å±æ€§ã®å€¤ã«ã‚‚ä¾å­˜ã™ã‚‹ãŒï¼Œ`~scriptå†…å®¹~åˆ¶ç´„$ã«åˆè‡´ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
If there is no src attribute, depends on the value of the type attribute, but must match script content restrictions.
</dd>
	<dd>
`src$a å±æ€§ã‚’æœ‰ã™ã‚‹å ´åˆã€
è¦ç´ ã¯ç©ºã«ã•ã‚Œã¦ã„ã‚‹ã‹, ã¾ãŸã¯
`~scriptå†…å®¹~åˆ¶ç´„$ã«ã‚‚åˆè‡´ã™ã‚‹ã‚ˆã†ãª`~scriptæ–‡æ›¸åŒ–$ã®ã¿ã‚’åŒ…å«ã—ã¦ã„ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
If there is a src attribute, the element must be either empty or contain only script documentation that also matches script content restrictions.
</dd>

	<dt>`text/html ã«ãŠã‘ã‚‹~tagçœç•¥$ï¼š</dt>
	<dd>
ä¸¡~tagã¨ã‚‚çœç•¥ä¸å¯ã€‚
â—
Neither tag is omissible.
</dd>

	<dt>`å†…å®¹~å±æ€§$ï¼š</dt>
	<dd>
`å¤§åŸŸ~å±æ€§$
â—
Global attributes
</dd>
	<dd>
`type$a
â€” ~scriptã®ç¨®åˆ¥
â—
type â€” Type of script
</dd>
	<dd>
`src$a
â€” è³‡æºã®~address
â—
src â€” Address of the resource
</dd>
	<dd>
`nomodule$a
â€” `~module~script$ã‚’~supportã™ã‚‹~UAã«ãŠã‘ã‚‹å®Ÿè¡Œã‚’é˜²æ­¢ã™ã‚‹
â—
nomodule â€” Prevents execution in user agents that support module scripts
</dd>
	<dd>
`async$a
â€” ~scriptãŒå¯ç”¨ã«ãªã£ãŸã‚‰å®Ÿè¡Œã™ã‚‹
â€” ~fetchã—ã¦ã„ã‚‹é–“ã¯ä»–ã‚’é˜»ã‚€ã“ã¨ãªã
â—
async â€” Execute script when available, without blocking while fetching
</dd>
	<dd>
`defer$a
â€” ~scriptå®Ÿè¡Œã‚’å…ˆé€ã‚Šã™ã‚‹
â—
defer â€” Defer script execution
</dd>
	<dd>
`blocking$a
â€” è¦ç´ ã«`å…·ç¾åŒ–ã‚’é˜»ã‚€èƒ½æ€§$ãŒã‚ã‚‹ã‹ã©ã†ã‹ã€‚
â—
blocking â€” Whether the element is potentially render-blocking
</dd>
	<dd>
`crossorigin$a
â€” è¦ç´ ã¯éåŒä¸€-ç”Ÿæˆå…ƒ è¦è«‹ã‚’ã©ã†å–æ‰±ã†ã‹
â—
crossorigin â€” How the element handles crossorigin requests
</dd>
	<dd>
`referrerpolicy$a
â€” è¦ç´ ã«ã‚ˆã‚Šèµ·å‹•ã•ã‚ŒãŸ`~fetch$ç”¨ã®`~referreræ–½ç­–$
â—
referrerpolicy â€” Referrer policy for fetches initiated by the element
</dd>
	<dd>
`integrity$a
â€” `Subresource Integrity^cite `SRI$rï¼ˆä¸‹ä½è³‡æºã®å®Œå…¨æ€§ï¼‰æ¤œæŸ»ã«åˆ©ç”¨ã•ã‚Œã‚‹å®Œå…¨æ€§~metadata
â—
integrity â€” Integrity metadata used in Subresource Integrity checks [SRI]
</dd>
	<dd>
`fetchpriority$a
â€” è¦ç´ ã«ã‚ˆã‚Šèµ·å‹•ã•ã‚Œã‚‹`~fetch$ç”¨ã®`å„ªå…ˆåº¦$rqã‚’è¨­å®šã™ã‚‹ã€‚
â—
fetchpriority â€” Sets the priority for fetches initiated by the element
</dd>

	<dt>`~accessibilityã®è€ƒæ…®ç‚¹$</dt>
	<dd>
`script$AA
â—
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
<pre class="idl">
[Exposed=Window]
interface `HTMLScriptElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute DOMString `type$m;
  [`CEReactions$] attribute USVString `src$m;
  [`CEReactions$] attribute boolean `noModule$m;
  [`CEReactions$] attribute boolean `async$m;
  [`CEReactions$] attribute boolean `defer$m;
  [SameObject, PutForwards=`value$m] readonly attribute `DOMTokenList$I `blocking$m;
  [`CEReactions$] attribute DOMString? `crossOrigin$m;
  [`CEReactions$] attribute DOMString `referrerPolicy$m;
  [`CEReactions$] attribute DOMString `integrity$m;
  [`CEReactions$] attribute DOMString `fetchPriority$m;

  [`CEReactions$] attribute DOMString `text$m;

  static boolean `supports$m(DOMString %type);

  // `HTMLScriptElement$obsMb
};
</pre>
	</dd>
</dl>

<p>
`script$e è¦ç´ ã¯ã€
æ–‡æ›¸~å†…ã«ï¼»
å‹•çš„~scriptï¼
~UAã«å¯¾ã™ã‚‹æŒ‡ç¤ºæ›¸ãï¼
~data~block
ï¼½ã‚’å«ã‚ã‚‹ã“ã¨ã‚’ä½œè€…ã«è¨±å®¹ã™ã‚‹ã€‚
ã“ã®è¦ç´ ã¯ã€
åˆ©ç”¨è€…~å‘ã‘ã®å†…å®¹ã¯`è¡¨ç¾-$ã—ãªã„ã€‚
â—
The script element allows authors to include dynamic script, instructions to the user agent, and data blocks in their documents. The element does not represent content for the user.
</p>

<p>
`script$e è¦ç´ ã«ã¯ã€
2 ã¤ã®ä¸­æ ¸~å±æ€§ãŒæœ‰ã‚‹ã€‚
ã†ã¡ï¼Œ
`type@a
å±æ€§ã¯ã€ï¼»
å½“ã®è¦ç´ ãŒè¡¨ç¾ã™ã‚‹~scriptã®ç¨®åˆ¥
ï¼½ã®~customåŒ–ã‚’è¨±å®¹ã™ã‚‹
â€” ã“ã®å±æ€§ã‚’ï¼š
â—
The script element has two core attributes. The type attribute allows customization of the type of script represented:
</p>

<ul>
	<li>
<p>
çœç•¥ã™ã‚‹, ã‚ã‚‹ã„ã¯ï¼»
`~JS~MIMEå‹ã«~essenceåˆè‡´-$ã™ã‚‹ã‚‚ã®
ï¼½ã«è¨­å®šã™ã‚‹ã“ã¨ã¯ã€
æ¬¡ã‚’æ„å‘³ã™ã‚‹
â‡’
å½“ã®~scriptã¯ã€
`å¤å…¸~script$ã«ãªã‚Šï¼Œ
~JSã® `Script$P ~top-levelç”Ÿæˆè¦å‰‡ã«å‰‡ã£ã¦è§£é‡ˆã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
Omitting the attribute, setting it to the empty string, or setting it to a JavaScript MIME type essence match means that the script is a classic script, to be interpreted according to the JavaScript Script top-level production.ï¼¼
</p>

<p>
å¾Œè€…ã®ã‚ˆã†ã«è¨­å®šã™ã‚‹ã“ã¨ã¯å†—é•·ã§ã‚ã‚Šã€
ä½œè€…ã¯ï¼Œä»£ã‚ã‚Šã« `type$a å±æ€§ã‚’çœç•¥ã™ã‚‹ã¹ãã§ã‚ã‚‹ã€‚
â—
Authors should omit the type attribute instead of redundantly setting it.
</p>
	</li>
	<li>
ï¼»
`~ASCIIå¤§å°ç„¡è¦–$ã§ `module^l ã«åˆè‡´ã™ã‚‹æ–‡å­—åˆ—
ï¼½ã«è¨­å®šã™ã‚‹ã“ã¨ã¯ã€
æ¬¡ã‚’æ„å‘³ã™ã‚‹
â‡’
å½“ã®~scriptã¯ã€
`~JS~module~script$ã«ãªã‚Šï¼Œ
~JSã® `Module$P ~top-levelç”Ÿæˆè¦å‰‡ã«å‰‡ã£ã¦è§£é‡ˆã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
Setting the attribute to an ASCII case-insensitive match for "module" means that the script is a JavaScript module script, to be interpreted according to the JavaScript Module top-level production.
</li>
	<li>
ï¼»
`~ASCIIå¤§å°ç„¡è¦–$ã§ `importmap^l ã«åˆè‡´ã™ã‚‹æ–‡å­—åˆ—
ï¼½ã«è¨­å®šã™ã‚‹ã“ã¨ã¯ã€
æ¬¡ã‚’æ„å‘³ã™ã‚‹
â‡’
å½“ã®~scriptã¯ã€
`~import~map$ã«ãªã‚Šï¼Œï¼»
`~moduleæŒ‡å®šå­ã‚’è§£æ±ºã™ã‚‹$ã¨ãã®æŒ™å‹•
ï¼½ã‚’åˆ¶å¾¡ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹~JSONã‚’åŒ…å«ã™ã‚‹ã€‚
â—
Setting the attribute to an ASCII case-insensitive match for "importmap" means that the script is an import map, containing JSON that will be used to control the behavior of module specifier resolution.
</li>
	<li>
<p>
ä»–ã®å€¤ã«è¨­å®šã™ã‚‹ã“ã¨ã¯ã€
æ¬¡ã‚’æ„å‘³ã™ã‚‹
â‡’
å½“ã®~scriptã¯ã€
`~data~block@
ã«ãªã‚Šï¼Œ~UAã«ã‚ˆã‚Šå‡¦ç†ã•ã‚Œãªã„ä»£ã‚ã‚Šã«ä½œè€…~scriptãã®ä»–ã®~toolã«ã‚ˆã‚Šå‡¦ç†ã•ã‚Œã‚‹ã€‚
â—
Setting the attribute to any other value means that the script is a data block, which is not processed by the user agent, but instead by author script or other tools.ï¼¼
</p>

<p>
ä½œè€…ã¯ã€
~data~blockã‚’~~æŒ‡ç¤ºã™ã‚‹ã¨ãã¯ï¼Œ
`~JS~MIMEå‹ã«~essenceåˆè‡´-$ã—ãªã„`å¦¥å½“ãª~MIMEå‹~æ–‡å­—åˆ—$ã‚’åˆ©ç”¨ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
Authors must use a valid MIME type string that is not a JavaScript MIME type essence match to denote data blocks.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®è¦ä»¶ã¯ã€
å°†æ¥ã«èµ·ã“ã‚Šå¾—ã‚‹è¡çªã‚’é¿ã‘ã‚‹ãŸã‚ã«ã‚ã‚‹ã€‚
`type$a å±æ€§~ç”¨ã®~MIMEå‹ã§ãªã„å€¤
â€” `module^l ã‚„ `importmap^l ãªã© â€”
ã¯ã€ï¼»
~UAã«ãŠã„ã¦ç‰¹åˆ¥ãªæŒ™å‹•ã‚’æœ‰ã™ã‚‹~script
ï¼½ã®ç¨®åˆ¥ã‚’è¡¨ã™ãŸã‚ã«ï¼Œã“ã®æ¨™æº–ã«ã‚ˆã‚Šåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
ä»Šï¼Œå¦¥å½“ãª~MIMEå‹~æ–‡å­—åˆ—ã‚’åˆ©ç”¨ã—ã¦ãŠã‘ã°ã€ï¼»
å½“ã®~data~blockã¯ã€
å°†æ¥ã®~UAã‹ã‚‰ã‚‚ï¼Œä½•ã‹åˆ¥ã®~scriptç¨®åˆ¥ã«è§£é‡ˆã—ç›´ã•ã‚Œãªã„
ï¼½ã“ã¨ã‚’ç¢ºä¿ã§ãã‚‹ã€‚
â—
The requirement that data blocks must be denoted using a valid MIME type string is in place to avoid potential future collisions. Values for the type attribute that are not MIME types, like "module" or "importmap", are used by the standard to denote types of scripts which have special behavior in user agents. By using a valid MIME type string now, you ensure that your data block will not ever be reinterpreted as a different script type, even in future user agents.
</p>
	</li>
</ul>

<p>
ã‚‚ã†ä¸€ã¤ã®ä¸­æ ¸~å±æ€§
`src@a
å±æ€§ã¯ã€ï¼»
`å¤å…¸~script$ï¼
`~JS~module~script$
ï¼½ä»¥å¤–ã«ã¯æŒ‡å®šã—ã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ã€‚
ãã‚Œã¯ã€ï¼»
~scriptå†…å®¹ã¨ã—ã¦å½“ã®è¦ç´ ã®`å­~textå†…å®¹$ã‚’åˆ©ç”¨ã™ã‚‹
ï¼½ä»£ã‚ã‚Šã«ï¼»
å½“ã®~scriptã¯ã€
æŒ‡å®šã—ãŸ`~URL$ã‹ã‚‰~fetchã•ã‚Œã‚‹
ï¼½ã‚ˆã†ã«ãªã‚‹ã“ã¨ã‚’è¡¨ã™ã€‚
`src$a ã«æŒ‡å®šã™ã‚‹å€¤ã¯ã€
`å‰å¾Œ~ç©ºç™½~å¯ã®å¦¥å½“ã‹ã¤ç©ºã§ãªã„~URL$ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The second core attribute is the src attribute. It must only be specified for classic scripts and JavaScript module scripts, and denotes that instead of using the element's child text content as the script content, the script will be fetched from the specified URL. If src is specified, it must be a valid non-empty URL potentially surrounded by spaces.
</p>

<p>
æ‰€ä¸ã® `script$e è¦ç´ ã«å¯¾ã—ï¼Œ
ä»–ã®å±æ€§ã®ã†ã¡ã©ã‚Œã‚’æŒ‡å®šã—ã¦ã‚‚ãƒ¨ã‚¤ã‹ã¯ã€
æ¬¡ã®è¡¨tã«ã‚ˆã‚Šæ±ºå®šã•ã‚Œã‚‹ï¼š
â—
Which other attributes may be specified on a given script element is determined by the following table:
</p>
<div>
<table class="yesno" id="_script-allowed-attrs"><thead>
<tr><th>
<th>`nomodule$a
<th>`async$a
<th>`defer$a
<th>`blocking$a
<th>`crossorigin$a
<th>`referrerpolicy$a
<th>`integrity$a
<th>`fetchpriority$a
<tbody>
<tr><th>å¤–éƒ¨~å¤å…¸~script
<td class="yes">å¯
<td class="yes">å¯
<td class="yes">å¯
<td class="yes">å¯
<td class="yes">å¯
<td class="yes">å¯
<td class="yes">å¯
<td class="yes">å¯

<tr><th>~inlineãªå¤å…¸~script
<td class="yes">å¯
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
<td class="yes">å¯â€ 1
<td class="yes">å¯â€ 1
<td class="no">Â·
<td class="no">Â·â€ 2

<tr><th>å¤–éƒ¨~module~script
<td class="no">Â·
<td class="yes">å¯
<td class="no">Â·
<td class="yes">å¯
<td class="yes">å¯
<td class="yes">å¯
<td class="yes">å¯
<td class="yes">å¯

<tr><th>~inlineãª~module~script
<td class="no">Â·
<td class="yes">å¯
<td class="no">Â·
<td class="no">Â·
<td class="yes">å¯â€ 1
<td class="yes">å¯â€ 1
<td class="no">Â·
<td class="no">Â·â€ 2

<tr><th>~import~map
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·

<tr><th>~data~block
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
<td class="no">Â·
</tbody></table>
â—
ï½œnomoduleï½œasyncï½œdeferï½œblockingï½œcrossoriginï½œreferrerpolicyï½œintegrityï½œfetchpriority
External classic scriptsï½œYesï½œYesï½œYesï½œYesï½œYesï½œYesï½œYesï½œYes
Inline classic scriptsï½œYesï½œÂ·ï½œÂ·ï½œÂ·ï½œYes*ï½œYes*ï½œÂ·ï½œÂ·â€ 
External module scriptsï½œÂ·ï½œYesï½œÂ·ï½œYesï½œYesï½œYesï½œYesï½œYes
Inline module scriptsï½œÂ·ï½œYesï½œÂ·ï½œÂ·ï½œYes*ï½œYes*ï½œÂ·ï½œÂ·â€ 
Import mapsï½œÂ·ï½œÂ·ï½œÂ·ï½œÂ·ï½œÂ·ï½œÂ·ï½œÂ·ï½œÂ·
Data blocksï½œÂ·ï½œÂ·ï½œÂ·ï½œÂ·ï½œÂ·ï½œÂ·ï½œÂ·ï½œÂ·
</div>

<p class="tablenote"><small>â€ 1
~inlineãª~scriptã«ã¯åˆæœŸ~fetchã¯ç„¡ã„ãŒã€
ãã®ï¼»
`crossorigin$a, `referrerpolicy$a
ï¼½å±æ€§ã¯ï¼Œ~module~import
â€” å‹•çš„ãª `import()ï¼ ~TC39#sec-import-calls$c ã‚‚å«ã‚€ â€”
ã«ã‚ˆã‚Šåˆ©ç”¨ã•ã‚Œã‚‹ï¼»
`è³‡æ ¼è¨¼~mode$rq, `~referreræ–½ç­–$
ï¼½ã«å½±éŸ¿ã™ã‚‹ã€‚
</small>
â—
* Although inline scripts have no initial fetches, the crossorigin and referrerpolicy attribute on inline scripts affects the credentials mode and referrer policy used by module imports, including dynamic import().
</p>

<p class="tablenote"><small>â€ 2
`crossorigin$a, `referrerpolicy$a ã¨é•ã£ã¦ã€
`fetchpriority$a ã¯ï¼Œ~module~importã«ã¯å½±éŸ¿ã—ãªã„ã€‚
`èª²é¡Œ #10276ï¼ ~HTMLissue/10276$ ã«ãŠã‘ã‚‹è«–ç‚¹ã‚’è¦‹ã‚ˆã€‚
</small>
â—
â€  Unlike crossorigin and referrerpolicy, fetchpriority does not affect module imports. See some discussion in issue #10276.
</p>

<hr>

<p>
ï¼»
~inlineãª `script$e è¦ç´ ï¼å¤–éƒ¨~scriptè³‡æº
ï¼½ã®å†…å®¹ã¯ã€ï¼»
`å¤å…¸~script$ç”¨ã«ã¯ï¼Œ~JSä»•æ§˜ `JAVASCRIPT$r ã® `Script$P ç”Ÿæˆè¦å‰‡ï¼
`~JS~module~script$ç”¨ã«ã¯ï¼ŒåŒ~ä»•æ§˜ã® `Module$P ç”Ÿæˆè¦å‰‡
ï¼½ã®è¦ä»¶ã«é©åˆã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The contents of inline script elements, or the external script resource, must conform with the requirements of the JavaScript specification's Script or Module productions, for classic scripts and JavaScript module scripts respectively. [JAVASCRIPT]
</p>

<p>
`~import~map$ç”¨ã®~inlineãª `script$e è¦ç´ ã®å†…å®¹ã¯ã€
`~import~mapè‘—ä½œ~è¦ä»¶$ã«é©åˆã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The contents of inline script elements for import maps must conform with the import map authoring requirements.
</p>

<p>
`script$e è¦ç´ ã‚’`~data~block$ã‚’å«ã‚ã‚‹ãŸã‚ã«åˆ©ç”¨ã™ã‚‹å ´åˆã€
~ANDâ†“ ãŒæº€ãŸã•ã‚Œãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
When used to include data blocks,ï¼¼
</p>
<ul>
	<li>
å½“ã®~dataã¯ã€
ã€å½“ã®è¦ç´ ã®å†…å®¹ã¨ã—ã¦ã€‘~inlineã«åŸ‹è¾¼ã¾ã‚Œã¦ã„ã‚‹ã€‚
â—
the data must be embedded inline,ï¼¼
</li>
	<li>
`type$a å±æ€§ã‚’åˆ©ç”¨ã—ã¦ï¼Œå½“ã®~dataã®å½¢å¼ãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹ã€‚
â—
the format of the data must be given using the type attribute, andï¼¼
</li>
	<li>
å½“ã®è¦ç´ ã®å†…å®¹ã¯ã€
åˆ©ç”¨ã•ã‚Œã‚‹å½¢å¼~ç”¨ã«å®šç¾©ã•ã‚Œã‚‹è¦ä»¶ã«é©åˆã—ã¦ã„ã‚‹ã€‚
â—
the contents of the script element must conform to the requirements defined for the format used.
</li>
</ul>

<hr>

<p>
`nomodule@a
å±æ€§ã¯ï¼Œ`çœŸå½-å±æ€§$ã§ã‚ã‚Šã€ï¼»
`~module~script$ã‚’~supportã™ã‚‹~UAã«ãŠã„ã¦~scriptãŒå®Ÿè¡Œã•ã‚Œã‚‹
ï¼½ã“ã¨ã‚’é˜²æ­¢ã™ã‚‹ã€‚
ã“ã‚Œã¯ã€
`ä¸‹ã®ä¾‹ã«ç¤ºã™ï¼ #script-nomodule-example$ã¨ãŠã‚Šï¼Œï¼»
ç¾ä»£ã®~UAã«ã¯`~module~script$ï¼
æ—§ã„~UAã«ã¯`å¤å…¸~script$
ï¼½ã‚’é¸æŠçš„ã«å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’è¨±å®¹ã™ã‚‹ã€‚
â—
The nomodule attribute is a boolean attribute that prevents a script from being executed in user agents that support module scripts. This allows selective execution of module scripts in modern user agents and classic scripts in older user agents, as shown below.
</p>

<p>
`async@a,
`defer@a
å±æ€§ã¯ï¼Œ`çœŸå½-å±æ€§$ã§ã‚ã‚Šã€
å½“ã®~scriptãŒã©ã†è©•ä¾¡ã•ã‚Œã‚‹ã¹ãã‹ã‚’æŒ‡ç¤ºã™ã‚‹ã€‚
ã“ã‚Œã‚‰ã®å±æ€§ã‚’åˆ©ç”¨ã—ã¦é¸å®šã§ãã‚‹ã‚¢ãƒªãª~modeã¯ã€
~scriptã®ç¨®åˆ¥ã«ä¾å­˜ã—ã¦ï¼Œã„ãã¤ã‹ã‚ã‚‹ï¼š
â—
The async and defer attributes are boolean attributes that indicate how the script should be evaluated. There are several possible modes that can be selected using these attributes, depending on the script's type.
</p>
<ul>
	<li>
<p>
å¤–éƒ¨`å¤å…¸~script$ç”¨ã«ã¯ï¼š
â—
For external classic scripts,ï¼¼
</p>
		<ul>
			<li>
å½“ã®è¦ç´ ã¯ `async$a å±æ€§ã‚’æœ‰ã™ã‚‹å ´åˆ
â‡’
~scriptã¯ï¼Œ~pageã®æ§‹æ–‡è§£æã¨`ä¸¦åˆ—çš„$ã«~fetchã•ã‚Œã€
å¯ç”¨ã«ãªã‚Šæ¬¡ç¬¬ï¼Œè©•ä¾¡ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹
ï¼ˆæ§‹æ–‡è§£æãŒå®Œäº†ã™ã‚‹å‰ã«ã‚‚ãªã‚Šå¾—ã‚‹ï¼‰ã€‚
â—
if the async attribute is present, then the classic script will be fetched in parallel to parsing and evaluated as soon as it is available (potentially before parsing completes).ï¼¼
</li>
			<li>
ä»–ã®å ´åˆï¼Œ
å½“ã®è¦ç´ ã¯ `defer$a å±æ€§ã‚’æœ‰ã™ã‚‹ãªã‚‰ã°
â‡’
~scriptã¯`ä¸¦åˆ—çš„$ã«~fetchã•ã‚Œï¼Œ~pageã®æ§‹æ–‡è§£æã‚’å®Œé‚ã—ãŸæ™‚ç‚¹ã§è©•ä¾¡ã•ã‚Œã‚‹ã€‚
â—
If the async attribute is not present but the defer attribute is present, then the classic script will be fetched in parallel and evaluated when the page has finished parsing.ï¼¼
</li>
			<li>
ä»–ã®å ´åˆ
â‡’
~scriptã¯ï¼Œå³æ™‚ã«~fetchã•ã‚ŒãŸä¸Šã§è©•ä¾¡ã•ã‚Œã€
ä¸¡è€…ã¨ã‚‚å®Œäº†ã™ã‚‹ã¾ã§~pageã®æ§‹æ–‡è§£æã‚’é˜»ã‚€ã“ã¨ã«ãªã‚‹ã€‚
â—
If neither attribute is present, then the script is fetched and evaluated immediately, blocking parsing until these are both complete.
</li>
		</ul>
	</li>
	<li>
<p>
`~module~script$ç”¨ã«ã¯ï¼š
â—
For module scripts,ï¼¼
</p>

		<ul>
			<li>
å½“ã®è¦ç´ ã¯ `async$a å±æ€§ã‚’æœ‰ã™ã‚‹å ´åˆ
â‡’
~scriptã¨ãã®ã™ã¹ã¦ã®ä¾å­˜ç‰©
ã€~scriptãŒ~importã™ã‚‹ä»–ã®~scriptã€‘
ã¯ï¼Œ~pageã®æ§‹æ–‡è§£æã¨`ä¸¦åˆ—çš„$ã«~fetchã•ã‚Œã€
å¯ç”¨ã«ãªã‚Šæ¬¡ç¬¬ï¼Œè©•ä¾¡ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹
ï¼ˆæ§‹æ–‡è§£æãŒå®Œäº†ã™ã‚‹å‰ã«ã‚‚ãªã‚Šå¾—ã‚‹ï¼‰ã€‚
â—
if the async attribute is present, then the module script and all its dependencies will be fetched in parallel to parsing, and the module script will be evaluated as soon as it is available (potentially before parsing completes).ï¼¼
</li>
			<li>
ä»–ã®å ´åˆ
â‡’
~scriptã¨ãã®ä¾å­˜ç‰©ã¯ï¼Œæ§‹æ–‡è§£æã¨`ä¸¦åˆ—çš„$ã«~fetchã•ã‚Œã€
~pageã®æ§‹æ–‡è§£æã‚’å®Œé‚ã—ãŸæ™‚ç‚¹ã§è©•ä¾¡ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
Otherwise, the module script and its dependencies will be fetched in parallel to parsing and evaluated when the page has finished parsing.ï¼¼
</li>
		</ul>
<p>
ï¼ˆ `defer$a å±æ€§ã«ã‚ˆã‚‹åŠ¹æœã¯ã€
~module~scriptã«ã¯ç„¡ã„ã€‚ï¼‰
â—
(The defer attribute has no effect on module scripts.)
</p>
	</li>
</ul>

<p>
ã“ã‚Œã‚‰ã™ã¹ã¦ã¯ã€
æ¬¡ã®å›³å¼ã«è¦ç´„ã•ã‚Œã‚‹ï¼š
â—
This is all summarized in the following schematic diagram:
</p>

<figure>
<figcaption id="_dgm-asyncdefer">
<ul>
	<li>
å˜ã«
`&lt;script&gt;^s
ã¨è¨˜ã—ãŸå ´åˆ
â‡’
æ§‹æ–‡è§£æã¯~fetchingã¨å®Ÿè¡Œã«ã‚ˆã‚Šä¸­æ–­ã•ã‚Œã‚‹ã€‚
</li>
	<li>
`&lt;script defer&gt;^s
ã¨è¨˜ã—ãŸå ´åˆ
â‡’
æ§‹æ–‡è§£æã¨ä¸¦åˆ—çš„ã«~fetchã•ã‚Œï¼Œ
ã™ã¹ã¦ã®æ§‹æ–‡è§£æã‚’å®Œé‚ã—ãŸå¾Œã«å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
</li>
	<li>
`&lt;script async&gt;^s
ã¨è¨˜ã—ãŸå ´åˆ
â‡’
~fetchingã¯æ§‹æ–‡è§£æã¨ä¸¦åˆ—çš„ã«ãªã‚‹ãŒï¼Œ
æ§‹æ–‡è§£æã¯~scriptã®å®Ÿè¡Œã«ã‚ˆã‚Šä¸­æ–­ã•ã‚Œã‚‹ã€‚
</li>
	<li>
`&lt;script type="module"&gt;^s
ã¨è¨˜ã—ãŸå ´åˆ
â‡’
`&lt;script defer&gt;^s
ã¨è¨˜ã—ãŸå ´åˆã¨é¡ä¼¼ã™ã‚‹ãŒï¼Œ
ä¾å­˜ç‰©ã‚‚~fetchã•ã‚Œã‚‹ã€‚
</li>
	<li>
`&lt;script type="module" async&gt;^s
ã¨è¨˜ã—ãŸå ´åˆ
â‡’
ä¾å­˜ç‰©ã®~fetchingã‚’ä¼´ã†ã“ã¨ã‚’é™¤ã„ã¦ï¼Œ
`&lt;script async&gt;^s
ã¨è¨˜ã—ãŸå ´åˆã¨é¡ä¼¼ã™ã‚‹ã€‚
</li>
</ul>
â—
With &lt;script&gt;, parsing is interrupted by fetching and execution. With &lt;script defer&gt;, fetching is parallel to parsing and execution takes place after all parsing has finished. And with &lt;script async&gt;, fetching is parallel to parsing but once it finishes parsing is interrupted to execute the script. The story for &lt;script type="module"&gt; is similar to &lt;script defer&gt;, but the dependencies will be fetched as well, and the story for &lt;script type="module" async&gt; is similar to &lt;script async&gt; with the extra dependency fetching.
</figcaption></figure>

<div class="note">
<p>æ³¨è¨˜ï¼š
ã“ã‚Œã‚‰ã®å±æ€§ã«å¯¾ã™ã‚‹æ­£ç¢ºãªå‡¦ç†ã®è©³ç´°ã¯ã€
ã»ã¨ã‚“ã©ãŒæ­´å²çš„ãªç†ç”±ã«ã‚ˆã‚‹ã‚‚ã®ã§ã‚ã‚Šï¼Œ~HTMLã®ï¼»
ã„ãã¶ã‚“è‡ªæ˜ã§ãªã„ï¼Œã„ãã¤ã‚‚ã®å´é¢
ï¼½ãŒå­•ã¾ã‚Œã¦ã„ã‚‹ã€‚
ã—ãŸãŒã£ã¦ï¼Œå®Ÿè£…ã®è¦ä»¶ã¯ã€
ã“ã®ä»•æ§˜~å…¨ä½“ã«æ•£ã‚‰ã°ã‚‰ã–ã‚‹ã‚’å¾—ãªããªã£ã¦ã„ã‚‹ã€‚
`Â§ å‡¦ç†~modelï¼ #script-processing-model$ã«ã¦ä¸ãˆã‚‹å„ç¨®~algoã¯ï¼Œã“ã®å‡¦ç†ã®ä¸­æ ¸ã‚’è¿°ã¹ã‚‹ãŒã€
ãã‚Œã‚‰ã®~algoã¯ï¼Œæ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ç­‰ã€…ã¨ç›¸äº’ã«å‚ç…§ã—åˆã†ï¼š
</p>
<ul>
	<li>
ï¼»
~HTMLå†… ï¼
`å¤–æ¥ãªå†…å®¹~å†…ï¼ ~HTMLparsing#scriptForeignEndTag$ ï¼
`~XMLå†…ï¼ ~HTMLxml#scriptTagXML$
ï¼½ã«ãŠã‘ã‚‹ï¼»
`script$e ã®
`é–‹å§‹~tagï¼ ~HTMLparsing#scriptTag$,
`çµ‚äº†~tagï¼ ~HTMLparsing#scriptEndTag$
ï¼½ã«å¯¾ã™ã‚‹å„ç¨® æ§‹æ–‡è§£æ~è¦å‰‡
</li>
	<li>
`document.write()$m ~methodã®è¦å‰‡
</li>
	<li>
`~scripting$ã®å–æ‰±ã„
</li>
</ul>
â—
The exact processing details for these attributes are, for mostly historical reasons, somewhat non-trivial, involving a number of aspects of HTML. The implementation requirements are therefore by necessity scattered throughout the specification. The algorithms below describe the core of this processing, but these algorithms reference and are referenced by the parsing rules for script start and end tags in HTML, in foreign content, and in XML, the rules for the document.write() method, the handling of scripting, etc.
</div>

<p class="note">æ³¨è¨˜ï¼š
`document.write()$m ~methodã‚’åˆ©ç”¨ã—ã¦æŒ¿å…¥ã•ã‚ŒãŸ `script$e è¦ç´ ã¯ã€
`é€šä¾‹çš„ã«ã¯ï¼ ~HTMLparsing#document-written-scripts-intervention$å®Ÿè¡Œã•ã‚Œã‚‹
ï¼ˆæ¦‚ã—ã¦ï¼Œãã®é–“ã¯ã€
æ›´ãªã‚‹ï¼»
~scriptå®Ÿè¡Œï¼~HTMLæ§‹æ–‡è§£æ
ï¼½ã¯é˜»ã¾ã‚Œã‚‹ï¼‰ã€‚
ï¼»
`innerHTML$m ï¼ `outerHTML$m
ï¼½å±æ€§ã‚’åˆ©ç”¨ã—ã¦æŒ¿å…¥ã•ã‚ŒãŸã‚‚ã®ã¯ã€
ã¾ã£ãŸãå®Ÿè¡Œã•ã‚Œãªã„ã€‚
â—
When inserted using the document.write() method, script elements usually execute (typically blocking further script execution or HTML parsing). When inserted using the innerHTML and outerHTML attributes, they do not execute at all.
</p>

<p>
`async$a å±æ€§ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ä¸‹ã§ã‚‚ï¼Œ `defer$a å±æ€§ãŒæŒ‡å®šã•ã‚Œã¦ãƒ¨ã‚¤
â€” ãã†ã™ã‚‹ã“ã¨ã§ã€ï¼»
`defer$a ã¯~supportã™ã‚‹ãŒ `async$a ã¯~supportã—ãªã„ã‚ˆã†ãªï¼Œæ—§æ¥ã®~web~browser
ï¼½ã«ãŠã„ã¦ã‚‚ã€
æ—¢å®šã§ã‚ã‚‹ä»–ã‚’é˜»ã‚€æŒ™å‹•ã«ä»£ãˆã¦ï¼Œ
`defer$a ã«ã‚ˆã‚‹æŒ™å‹•ã«~fall-backã™ã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
The defer attribute may be specified even if the async attribute is specified, to cause legacy web browsers that only support defer (and not async) to fall back to the defer behavior instead of the blocking behavior that is the default.
</p>

<p>
`blocking@a
å±æ€§ã¯ã€
`ä»–ã‚’é˜»ã‚€å±æ€§$ã§ã‚ã‚‹ã€‚
â—
The blocking attribute is a blocking attribute.
</p>

<p>
`crossorigin@a
å±æ€§ã¯ã€
`~CORSè¨­å®šç¾¤~å±æ€§$ã§ã‚ã‚‹ã€‚
ã“ã®å±æ€§ã¯ã€
æ¬¡ã‚’åˆ¶å¾¡ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ï¼š
â—
The crossorigin attribute is a CORS settings attribute.ï¼¼
</p>
<ul>
	<li>
å¤–éƒ¨`å¤å…¸~script$ç”¨ã«ã¯
â‡’
ä»–ã®`ç”Ÿæˆå…ƒ$ã‹ã‚‰å¾—ã•ã‚ŒãŸ~scriptã«ã‚ˆã‚‹~erroræƒ…å ±ãŒå…¬é–‹ã•ã‚Œã‚‹ã‹ã©ã†ã‹
â—
For external classic scripts, it controls whether error information will be exposed, when the script is obtained from other origins.ï¼¼
</li>
	<li>
å¤–éƒ¨`~module~script$ç”¨ã«ã¯
â‡’
~module~sourceã®åˆæœŸ~fetchãŒéåŒä¸€-ç”Ÿæˆå…ƒã§ã‚ã‚‹å ´åˆã«ï¼Œãã‚Œç”¨ã«åˆ©ç”¨ã•ã‚Œã‚‹`è³‡æ ¼è¨¼~mode$rq
â—
For external module scripts, it controls the credentials mode used for the initial fetch of the module source, if cross-origin.ï¼¼
</li>
	<li>
ï¼»
`å¤å…¸~script$, `~module~script$
ï¼½ç”¨ã«ã¯
â‡’
éåŒä¸€-ç”Ÿæˆå…ƒãª~module~importç”¨ã®`è³‡æ ¼è¨¼~mode$rq
â—
For both classic and module scripts, it controls the credentials mode used for cross-origin module imports.
</li>
</ul>

<p class="note">æ³¨è¨˜ï¼š
`å¤å…¸~script$ã¨é•ã£ã¦ï¼Œ`~module~script$ã§ã¯ã€
éåŒä¸€-ç”Ÿæˆå…ƒã¸~fetchã™ã‚‹ã¨ãã«ã¯ï¼Œ`~CORS~protocol$ã®åˆ©ç”¨ãŒè¦æ±‚ã•ã‚Œã‚‹ã€‚
â—
Unlike classic scripts, module scripts require the use of the CORS protocol for cross-origin fetching.
</p>

<p>
`referrerpolicy@a
å±æ€§ã¯ã€
`~referreræ–½ç­–~å±æ€§$ã§ã‚ã‚‹ã€‚
ãã‚Œã¯ã€
å¤–éƒ¨~scriptã®åˆæœŸ~fetchç”¨ã«, ãŠã‚ˆã³ï¼»
~importã•ã‚Œã‚‹~module~scriptãŒã‚ã‚‹ãªã‚‰ã°ï¼Œãã‚Œã‚‰ã‚’~fetchã™ã‚‹ã¨ã
ï¼½ã«åˆ©ç”¨ã•ã‚Œã‚‹`~referreræ–½ç­–$ã‚’è¨­å®šã™ã‚‹ã€‚
`REFERRERPOLICY$r
â—
The referrerpolicy attribute is a referrer policy attribute. Its sets the referrer policy used for the initial fetch of an external script, as well as the fetching of any imported module scripts. [REFERRERPOLICY]
</p>

<div class="example">
<p>
ä»–ã®ä¸‹ä½è³‡æºã§ã¯ãªãï¼Œ~importã•ã‚Œã‚‹~scriptã‚’~fetchã™ã‚‹ã¨ãã«åˆ©ç”¨ã•ã‚Œã‚‹ `script^e è¦ç´ ã®~referreræ–½ç­–ã®ä¾‹ï¼š
â—
An example of a script element's referrer policy being used when fetching imported scripts but not other subresources:
</p>

<pre class="lang-html">
&lt;script referrerpolicy="origin"&gt;
  fetch('/api/data');   /* <span class="comment">
`script^e ã®~referreræ–½ç­–ã§ã¯~fetchã•ã‚Œãªã„ã€‚
â—
not fetched with &lt;script&gt;'s referrer policy
</span> */
  import('./utils.mjs'); /* <span class="comment">
`script^e ã®~referreræ–½ç­–ï¼ˆã“ã®äº‹ä¾‹ã§ã¯ `origin^l ï¼‰ã§~fetchã•ã‚Œã‚‹ã€‚
â—
is fetched with &lt;script&gt;'s referrer policy ("origin" in this case)
</span> */
&lt;/script&gt;
</pre>
</div>

<p>
`integrity@a
å±æ€§ã¯ã€
å¤–éƒ¨~scriptã®åˆæœŸ~fetchç”¨ã«åˆ©ç”¨ã•ã‚Œã‚‹`å®Œå…¨æ€§~metadata$rqã‚’è¨­å®šã™ã‚‹ã€‚
ãã®å€¤ã¯ã€
`å®Œå…¨æ€§~å±æ€§ã®è¦ä»¶ï¼ ~SRI#the-integrity-attribute$ã«åˆè‡´ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
`SRI$r
â—
The integrity attribute sets the integrity metadata used for the initial fetch of an external script. The value must match the requirements of the integrity attribute. [SRI]
</p>

<p>
`fetchpriority@a
å±æ€§ã¯ã€
`~fetchå„ªå…ˆåº¦~å±æ€§$ã§ã‚ã‚‹ã€‚
ãã‚Œã¯ã€
å¤–éƒ¨~scriptã®åˆæœŸ~fetchç”¨ã«åˆ©ç”¨ã•ã‚Œã‚‹`å„ªå…ˆåº¦$rqã‚’è¨­å®šã™ã‚‹ã€‚
â—
The fetchpriority attribute is a fetch priority attribute. Its sets the priority used for the initial fetch of an external script.
</p>

<p>
ã“ã‚Œã‚‰ã®å†…å®¹~å±æ€§ã‚’å‹•çš„ã«å¤‰æ›´ã—ã¦ã‚‚ï¼Œç›´ãªåŠ¹æœã¯ç„¡ã„
â€” ã“ã‚Œã‚‰ã¯ã€
`Â§ å‡¦ç†~modelï¼ #script-processing-model$ã«ã¦è¿°ã¹ã‚‹ç‰¹å®šã®æ™‚ç‚¹ã«é™ã‚Šåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
Changing any of these attributes dynamically has no direct effect; these attributes are only used at specific times described in the processing model.
</p>

<hr>

<div>
<p>
`src@m
~IDLå±æ€§ã¯ã€
`src$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
</p>

<p>
`type@m
~IDLå±æ€§ã¯ã€
`type$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
</p>

<p>
`defer@m
~IDLå±æ€§ã¯ã€
`defer$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
</p>

<p>
`integrity@m
~IDLå±æ€§ã¯ã€
`integrity$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
</p>

<p>
`blocking@m
~IDLå±æ€§ã¯ã€
`blocking$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
</p>
â—
The IDL attributes src, type, defer, integrity, and blocking must each reflect the respective content attributes of the same name.
</div>

<p>
`noModule@m
~IDLå±æ€§ã¯ã€
`nomodule$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The noModule IDL attribute must reflect the nomodule content attribute.
</p>

<p>
`crossOrigin@m
~IDLå±æ€§ã¯ã€
`æ—¢çŸ¥ãªå€¤ã®ã¿ã«åˆ¶é™ã•ã‚Œ$ã‚‹ä¸‹ã§ï¼Œ
`crossorigin$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.
</p>

<p>
`referrerPolicy@m
~IDLå±æ€§ã¯ã€
`æ—¢çŸ¥ãªå€¤ã®ã¿ã«åˆ¶é™ã•ã‚Œ$ã‚‹ä¸‹ã§ï¼Œ
`referrerpolicy$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.
</p>

<p>
`fetchPriority@m
~IDLå±æ€§ã¯ã€
`æ—¢çŸ¥ãªå€¤ã®ã¿ã«åˆ¶é™ã•ã‚Œ$ã‚‹ä¸‹ã§ï¼Œ
`fetchpriority$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The fetchPriority IDL attribute must reflect the fetchpriority content attribute, limited to only known values.
</p>

<div class="algo">
`async@m
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ~ISï¼»
ã‚³ãƒ¬ã®`éåŒæœŸcã‚’å¼·åˆ¶ã™ã‚‹ã‹$scE ~EQ ~T
ï¼½~ORï¼»
ã‚³ãƒ¬ã¯ `async$a å†…å®¹~å±æ€§ã‚’æœ‰ã™ã‚‹
ï¼½
â—
The async getter steps are:
â€¢ If this's force async is true, then return true.
â€¢ If this's async content attribute is present, then return true.
â€¢ Return false.
</div>

<div class="algo">
<p>
`async$m è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
â—
The async setter steps are:
</p>
<ol>
	<li>
ã‚³ãƒ¬ã®`éåŒæœŸcã‚’å¼·åˆ¶ã™ã‚‹ã‹$scE ~SET ~F
â—
Set this's force async to false.
</li>
	<li>
~IFï¼»
æ‰€ä¸ã®å€¤ ~EQ ~T
ï¼½
â‡’
ã‚³ãƒ¬ã® `async$a å†…å®¹~å±æ€§ ~SET ç©º~æ–‡å­—åˆ—
â—
If the given value is true, then set this's async content attribute to the empty string.
</li>
	<li>
~ELSE
â‡’
ã‚³ãƒ¬ã® `async$a å†…å®¹~å±æ€§ã‚’é™¤å»ã™ã‚‹
â—
Otherwise, remove this's async content attribute.
</li>
</ol>
</div>

<dl class="domintro">
	<dt>%script.`text$m [ = %value ]</dt>
	<dd>
è¦ç´ ã®`å­~textå†…å®¹$ã‚’è¿”ã™ã€‚
â—
Returns the child text content of the element.
</dd>

	<dt>%script.`text$m = %value</dt>
	<dd>
è¦ç´ ã®å­~ç¾¤ã‚’æ‰€ä¸ã® %value ã‚’æˆã™~textã§ç½®æ›ã™ã‚‹ã€‚
â—
Replaces the element's children with the text given by value.
</dd>

	<dt>`HTMLScriptElement$I.`supports(type)$m</dt>
	<dd>
æ‰€ä¸ã® %type ã¯~UAãŒ~supportã™ã‚‹~scriptç¨®åˆ¥ã§ã‚ã‚‹ãªã‚‰ã° ~T ã‚’è¿”ã™ã€‚
â—
Returns true if the given type is a script type supported by the user agent.ï¼¼
</dd>
	<dd>
ã“ã®ä»•æ§˜ã«ãŠã„ã¦ã‚¢ãƒªãª~scriptç¨®åˆ¥ã¯ï¼»
`classic^l, `module^l, `importmap^l
ï¼½ã«é™ã‚‰ã‚Œã‚‹ãŒã€
å°†æ¥ã«ã¯ï¼Œä»–ã®ç¨®åˆ¥ã‚‚è¿½åŠ ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„
ã€`èª¬æ˜æ›¸ãï¼ https://github.com/horo-t/explainers/blob/main/script_element_supports.md$ã€‘
ã€‚
â—
The possible script types in this specification are "classic", "module", and "importmap", but others might be added in the future.
</dd>
</dl>

<div class="algo">
`text@m
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`å­~textå†…å®¹$
â—
The text getter steps are to return this's child text content.
</div>

<div class="algo">
`text$m è¨­å®šå­~æ‰‹ç¶šãã¯
â‡’
ã‚³ãƒ¬ã®`å…¨~å†…å®¹ã‚’æ–‡å­—åˆ—ã«ç½®æ›ã™ã‚‹$( æ‰€ä¸ã®å€¤ )
â—
The text setter steps are to string replace all with the given value within this.
</div>

<div class="algo">
<p>
`supports(type)@m
é™çš„~methodæ‰‹ç¶šãã¯ï¼š
â—
The static supports(type) method steps are:
</p>
<ol>
	<li>
~IFï¼»
%type ~IN { `classic^l, `module^l, `importmap^l }
ï¼½
â‡’
~RET ~T
â—
If type is "classic", then return true.
â—
If type is "module", then return true.
â—
If type is "importmap", then return true.
</li>
	<li>
~RET ~F
â—
Return false.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
%type å¼•æ•°ã¯æŒ™ã’ã‚‰ã‚ŒãŸå€¤ã«æ­£ç¢ºã«åˆè‡´ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
â€” `~ASCIIå¤§å°ç„¡è¦–$ã§ç…§åˆã•ã‚Œã‚‹ã“ã¨ã¯ãªã„ã€‚
ã“ã‚Œã¯ã€ï¼»
`type$a å†…å®¹~å±æ€§~å€¤ã©ã†æ‰±ã‚ã‚Œã‚‹ã‹ ï¼
`DOMTokenList$I ã® `supports()ï¼ ~DOM4#dom-domtokenlist-supports$m ~methodãŒã©ã†åƒãã‹
ï¼½ã¨ã¯ç•°ãªã‚‹ãŒï¼Œ
`new Worker()$m æ§‹ç¯‰å­ã«ã¦åˆ©ç”¨ã•ã‚Œã‚‹ `WorkerType$I åˆ—æŒ™ã«æƒã†ã€‚
â—
The type argument has to exactly match these values; we do not perform an ASCII case-insensitive match. This is different from how type content attribute values are treated, and how DOMTokenList's supports() method works, but it aligns with the WorkerType enumeration used in the Worker() constructor.
</p>
</div>

<hr>

<div class="example">
<p>
æ¬¡ã®ä¾‹ã«ã¯ã€
2 å€‹ã® `script$e è¦ç´ 
â€” å¤–éƒ¨`å¤å…¸~script$ã‚’åŸ‹è¾¼ã‚€ã‚‚ã®, ãŠã‚ˆã³
`~data~block$ã¨ã—ã¦ä½•ã‚‰ã‹ã®~dataã‚’å«ã‚€ã‚‚ã® â€”
ãŒåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
In this example, two script elements are used. One embeds an external classic script, and the other includes some data as a data block.
</p>

`script-2^xCode

<p>
ã“ã®äº‹ä¾‹ã«ãŠã‘ã‚‹~dataã¯ã€
ãã®~scriptã«ã‚ˆã‚Šï¼Œ~video~gameã®~mapã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ã§ã‚ã‚ã†
â€” ãŒã€
ã“ã®ä»•æ–¹ã§åˆ©ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‚ã‘ã§ã¯ãªã„ï¼š
å®Ÿéš›ã®~map~dataã¯~pageã®ä»–æ‰€ã«åŸ‹è¾¼ã¾ã‚Œã¦ã„ã¦ã€
ã“ã®~data~blockã¯ï¼Œå˜ã«ï¼»
åˆ©ç”¨è€…ãŒ~game~mapã®ç‰¹å®š0ã®ç‰¹èƒ½ã‚’æ¢ã—æ˜“ãã™ã‚‹ãŸã‚
ï¼½ã¨ã—ã¦ï¼»
~siteã®æ¢ç´¢~engineå‘ã‘ã«~~ç”¨æ„ã•ã‚ŒãŸã‚‚ã®
ï¼½ã‹ã‚‚ã—ã‚Œãªã„ã€‚
â—
The data in this case might be used by the script to generate the map of a video game. The data doesn't have to be used that way, though; maybe the map data is actually embedded in other parts of the page's markup, and the data block here is just used by the site's search engine to help users who are looking for particular features in their game maps.
</p>
</div>

<div class="example">
<p>
æ¬¡ã®è¦‹æœ¬ã«ã€
`script$e è¦ç´ ã‚’åˆ©ç”¨ã—ã¦ï¼Œ
æ–‡æ›¸ã®ä»–æ‰€ã‹ã‚‰åˆ©ç”¨ã•ã‚Œã‚‹é–¢æ•°ã‚’ `å¤å…¸~script$ã®ä¸€éƒ¨ã¨ã—ã¦å®šç¾©ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã™ã€‚
åŒæ™‚ã«ï¼Œåˆ¥ã® `script$e è¦ç´ ã‚’åˆ©ç”¨ã—ã¦ã€
æ–‡æ›¸ãŒæ§‹æ–‡è§£æã•ã‚Œã¦ã„ã‚‹é–“ã«~scriptã‚’å‘¼å‡ºã™æ–¹æ³•ã‚‚ç¤ºã™
â€” ã“ã®äº‹ä¾‹ã§ã¯ã€
~formã®å‡ºåŠ›ã‚’åˆæœŸåŒ–ã™ã‚‹ã€‚
â—
The following sample shows how a script element can be used to define a function that is then used by other parts of the document, as part of a classic script. It also shows how a script element can be used to invoke script while the document is being parsed, in this case to initialize the form's output.
</p>

`script-3^xCode
</div>

<div id="script-type-module-example-1" class="example">

<p>
æ¬¡ã®è¦‹æœ¬ã§ã¯ã€
`script$e è¦ç´ ã‚’åˆ©ç”¨ã—ã¦ï¼Œå¤–éƒ¨`~JS~module~script$ã‚’å«ã‚ã‚‹æ–¹æ³•ã‚’ç¤ºã™ã€‚
â—
The following sample shows how a script element can be used to include an external JavaScript module script.
</p>

`script-4^xCode

<p>
ã“ã®~module, ãŠã‚ˆã³ãã®ã™ã¹ã¦ã®ä¾å­˜ç‰©
ï¼ˆ~source~fileå†…ã® ~JS `import^c æ–‡ã‚’é€šã—ã¦è¡¨å‡ºã•ã‚Œã‚‹ï¼‰ã¯ã€
~fetchã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
çµæœã®~module~graphå…¨ä½“ãŒ~importã•ã‚Œï¼Œæ–‡æ›¸ã®æ§‹æ–‡è§£æã‚’å®Œé‚ã—ãŸãªã‚‰ã€
`app.mjs^s ã®å†…å®¹ã¯è©•ä¾¡ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
This module, and all its dependencies (expressed through JavaScript import statements in the source file), will be fetched. Once the entire resulting module graph has been imported, and the document has finished parsing, the contents of app.mjs will be evaluated.
</p>

<p>
åŠ ãˆã¦ï¼ŒåŒã˜ `Window$I å†…ã®åˆ¥ã® `script$e è¦ç´ ã‹ã‚‰ã®~codeãŒ
`app.mjs^s ã‹ã‚‰ã®~moduleã‚’~importã™ã‚‹å ´åˆï¼ˆä¾‹ï¼š `import "./app.mjs";^s ã‚’ä»‹ã—ã¦ï¼‰ã€
å‰è€…ã® `script$e è¦ç´ ã«ã‚ˆã‚Šä½œæˆã•ã‚ŒãŸåŒã˜`~JS~module~script$ãŒ~importã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
Additionally, if code from another script element in the same Window imports the module from app.mjs (e.g. via import "./app.mjs";), then the same JavaScript module script created by the former script element will be imported.
</p>
</div>

<div id="script-nomodule-example" class="example">
<p>
ç¾ä»£ã®~UAç”¨ã«ã¯`~JS~module~script$,
æ—§ã„~UAç”¨ã«ã¯`å¤å…¸~script$ã‚’å«ã‚ã‚‹ä¾‹ã‚’ç¤ºã™ï¼š
â—
This example shows how to include a JavaScript module script for modern user agents, and a classic script for older user agents:
</p>

`script-5^xCode

<p>
`~JS~module~script$ã‚’~supportã™ã‚‹ç¾ä»£ã®~UAã§ã¯ã€
å‰è€…ã® `script$e è¦ç´ ï¼ˆ `type$a å±æ€§ã¯ `module^l ï¼‰ã¯ï¼Œ
~fetchã•ã‚ŒãŸä¸Šã§ ï¼ˆ`~JS~module~script$ã¨ã—ã¦ï¼‰è©•ä¾¡ã•ã‚Œã‚‹ä¸€æ–¹ã§ã€
å¾Œè€…ã® `script$e è¦ç´ ï¼ˆ `nomodule$a å±æ€§ã‚’æœ‰ã™ã‚‹ï¼‰ã¯ç„¡è¦–ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
é€†ã«ï¼Œæ—§ã„~UAã«ã¨ã£ã¦ã¯ã€
å‰è€…ã¯ï¼ŒæœªçŸ¥ãª~scriptå‹ãªã®ã§ç„¡è¦–ã™ã‚‹ã“ã¨ã«ãªã‚‹
â€” ãŒã€
`nomodule$a å±æ€§ã¯å®Ÿè£…ã—ã¦ã„ãªã„ã®ã§ï¼Œ
å¾Œè€…ã‚’ï¼ˆ`å¤å…¸~script$ã¨ã—ã¦ï¼‰~fetchã—ã¦è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã¯å•é¡Œã¯ãªã„ã€‚
â—
In modern user agents that support JavaScript module scripts, the script element with the nomodule attribute will be ignored, and the script element with a type of "module" will be fetched and evaluated (as a JavaScript module script). Conversely, older user agents will ignore the script element with a type of "module", as that is an unknown script type for them â€” but they will have no problem fetching and evaluating the other script element (as a classic script), since they do not implement the nomodule attribute.
</p>
</div>

<div id="script-type-module-example-2" class="example">

<p>
æ¬¡ã®è¦‹æœ¬ã«ã€
`script$e è¦ç´ ã‚’åˆ©ç”¨ã—ã¦ï¼Œï¼»
ï¼ˆä¾‹ãˆã°ï¼Œãƒ‹ãƒ¥ãƒ¼ã‚¹ã‚µã‚¤ãƒˆä¸Šã®ï¼‰æ–‡æ›¸~å†…ã®~textã‚’æ›–æ˜§ãªèª­ã¿ç‰©ã§ä»£ç”¨ã—ã¦ã—ã¾ã†ã‚ˆã†ãªï¼Œ
~inlineãª`~JS~module~script$
ï¼½ã‚’æ›¸ãæ–¹æ³•ã‚’ç¤ºã™ï¼š
ã€ï¼[XKCD1288]ã€‘
â—
The following sample shows how a script element can be used to write an inline JavaScript module script that performs a number of substitutions on the document's text, in order to make for a more interesting reading experience (e.g. on a news site): [XKCD1288]
</p>

`script-6^xCode

<div class="p">
<p>
~JS~module~scriptã‚’åˆ©ç”¨ã—ã¦å¾—ã‚‰ã‚Œã‚‹ç‰¹èƒ½ã®ã†ã¡ï¼Œæ³¨ç›®ã™ã¹ãã‚‚ã®ã«ã¯ã€
æ¬¡ãŒæŒ™ã’ã‚‰ã‚Œã‚‹ï¼š
</p>
<ul>
	<li>
ä»–ã®~JS~moduleã‹ã‚‰é–¢æ•°ã‚’~importã™ã‚‹èƒ½ã€‚
</li>
	<li>
æ—¢å®šã§~strict~modeã«ãªã‚‹ã€‚
</li>
	<li>
~top-levelå®£è¨€ã§ã‚ã£ã¦ã‚‚ï¼Œ`å¤§åŸŸ~obj$ä¸Šã«æ–°ãŸãª~propã‚’å°å…¥ã—ãªã„ã€‚
</li>
</ul>
â—
Some notable features gained by using a JavaScript module script include the ability to import functions from other JavaScript modules, strict mode by default, and how top-level declarations do not introduce new properties onto the global object.ï¼¼
</div>

<p>
ã¾ãŸï¼Œã“ã® `script$e è¦ç´ ãŒæ–‡æ›¸~å†…ã®ã©ã“ã«ç¾ã‚Œã‚ˆã†ãŒã€ï¼»
æ–‡æ›¸~æ§‹æ–‡è§£æãŒå®Œäº†ã—ã¦ï¼ŒãªãŠã‹ã¤
ãã®ä¾å­˜ç‰©ï¼ˆã“ã®ä¾‹ã§ã¯ `dom-utils.mjs^s ï¼‰ãŒ~fetchã•ã‚Œ, è©•ä¾¡ã•ã‚Œã‚‹
ï¼½ã¾ã§ã¯ï¼Œè©•ä¾¡ã•ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã€‚
â—
Also note that no matter where this script element appears in the document, it will not be evaluated until both document parsing has complete and its dependency (dom-utils.mjs) has been fetched and evaluated.
</p>
</div>

<div class="example" id="json-module-script-example">
<p>
æ¬¡ã®è¦‹æœ¬ã«ï¼Œ`~JS~module~script$ã®å†…å´ã‹ã‚‰`~JSON~module~script$ã‚’ ã©ã†~importã§ãã‚‹ã‹ã‚’ç¤ºã™ï¼š
â—
The following sample shows how a JSON module script can be imported from inside a JavaScript module script:
</p>

<pre class="lang-html">
&lt;script type="module"&gt;
 import peopleInSpace from "http://api.open-notify.org/astros.json" with { type: "json" };

 const %list = document.querySelector("#people-in-space");
 for (const { %craft, %name } of peopleInSpace.people) {
   const %li = document.createElement("li");
   %li.textContent = ``^${name} / ${craft}``^;
   %list.append(%li);
 }
&lt;/script&gt;
</pre>

<p>
~module~scriptç”¨ã®~MIMEå‹ã«å¯¾ã™ã‚‹æ¤œæŸ»-æ³•ã¯å³å¯†ã§ã‚ã‚‹ã€‚
`~JSON~module~script$ã®~fetchãŒæˆåŠŸã™ã‚‹ãŸã‚ã«ã¯ã€
~HTTPå¿œç­”ã®~MIMEå‹ã¯`~JSON~MIMEå‹$
â€” ä¾‹ï¼š `Content-Type: text/json^c â€”
ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚
ä»–æ–¹ï¼Œ`import^c æ–‡ã‚’æˆã™ `with { type: "json" }^c ã®éƒ¨åˆ†ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã€
ãã®æ„å›³ã¯`~JS~module~script$ã‚’~importã™ã‚‹ã‚‚ã®ã¨è¦‹åšã•ã‚Œã€
~HTTPå¿œç­”ã®~MIMEå‹ãŒ`~JS~MIMEå‹$ã§ãªã„å ´åˆï¼Œ~fetchã¯å¤±æ•—ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
MIME type checking for module scripts is strict. In order for the fetch of the JSON module script to succeed, the HTTP response must have a JSON MIME type, for example Content-Type: text/json. On the other hand, if the with { type: "json" } part of the statement is omitted, it is assumed that the intent is to import a JavaScript module script, and the fetch will fail if the HTTP response has a MIME type that is not a JavaScript MIME type.
</p>
</div>
			<section id="script-processing-model">
<h5 title="Processing model">4.12.1.1. å‡¦ç†~model</h5>

<p>
å„ `script$e è¦ç´ ã«ã¯ã€
ãã®å„ç¨® çŠ¶æ…‹ã‚’~~ä¿æŒã™ã‚‹ã‚‚ã®ã¨ã—ã¦ï¼Œæ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
A script element has several associated pieces of state.
</p>

<dl class="def-list">
	<dt>
`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸@scE
â—
A script element has a parser document,ï¼¼
</dt>
	<dd>
~NULL ï¼`æ–‡æ›¸$
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
which is either null or a Document, initially null.ï¼¼
</dd>
	<dd>
ã“ã‚Œã¯ã€ï¼»
`~HTMLæ§‹æ–‡è§£æå™¨$ ï¼ `~XMLæ§‹æ–‡è§£æå™¨$
ï¼½ã«ã‚ˆã‚Š `script$e è¦ç´ ãŒæŒ¿å…¥ã•ã‚Œã‚‹ã¨ãè¨­å®šã•ã‚Œï¼Œãã‚Œã‚‰ã®è¦ç´ ã®å‡¦ç†ã«å½±éŸ¿ã™ã‚‹ã€‚
~NULL ã§ãªã„ã¨ãã€
å½“ã®è¦ç´ ã¯
`æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸ@
ã¨ã‚‚ã„ã†ã€‚
â—
It is set by the HTML parser and the XML parser on script elements they insert, and affects the processing of those elements. script elements with non-null parser documents are known as parser-inserted.
</dd>

	<dt>
`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸@scE
â—
A script element has a preparation-time document,ï¼¼
</dt>
	<dd>
~NULL ï¼`æ–‡æ›¸$
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
which is either null or a Document, initially null.ï¼¼
</dd>
	<dd>
ã“ã‚Œã¯ã€
å½“ã®è¦ç´ ãŒ`~scriptè¦ç´ ã‚’æº–å‚™ã™ã‚‹$é–“ã«ä»–ã®æ–‡æ›¸ã¸ç§»å‹•ã•ã‚ŒãŸå ´åˆã«ï¼Œ
`~scriptè¦ç´ ã‚’å®Ÿè¡Œã™ã‚‹$ã®ã‚’é˜²æ­¢ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
It is used to prevent scripts that move between documents during preparation from executing.
</dd>

	<dt>
`éåŒæœŸcã‚’å¼·åˆ¶ã™ã‚‹ã‹@scE
â—
A script element has a force asyncï¼¼
</dt>
	<dd>
çœŸå½å€¤
â€” åˆæœŸ~æ™‚ã¯ ~T ã¨ã™ã‚‹ã€‚
â—
boolean, initially true.ï¼¼
</dd>
	<dd>
<p>
æ¬¡ã®ã¨ãã¯ã€
~F ã«ã•ã‚Œã‚‹ï¼š
</p>
		<ul>
			<li>
å½“ã®è¦ç´ ãŒï¼»
`~HTMLæ§‹æ–‡è§£æå™¨$ ï¼ `~XMLæ§‹æ–‡è§£æå™¨$
ï¼½ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸã¨ã
</li>
			<li>
å½“ã®è¦ç´ ã« `async$a å†…å®¹~å±æ€§ãŒè¿½åŠ ã•ã‚ŒãŸã¨ã
</li>
		</ul>
â—
It is set to false by the HTML parser and the XML parser on script elements they insert, and when the element gets an async content attribute added.
</dd>

	<dt>
`å¤–éƒ¨~fileã‹@scE
â—
A script element has a from an external fileï¼¼
</dt>
	<dd>
çœŸå½å€¤
â€” åˆæœŸ~æ™‚ã¯ ~F ã¨ã™ã‚‹ã€‚
â—
boolean, initially false.ï¼¼
</dd>
	<dd>
ã“ã‚Œã¯ã€
`~scriptè¦ç´ ã‚’æº–å‚™ã™ã‚‹$æ™‚ç‚¹ã§ï¼Œå½“ã®è¦ç´ ã® `src$a å±æ€§ã«åŸºã¥ã„ã¦æ±ºå®šã•ã‚Œã‚‹ã€‚
â—
It is determined when the script is prepared, based on the src attribute of the element at that time.
</dd>

	<dt>
`æ§‹æ–‡è§£æå™¨ã«ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã«æº–å‚™æ¸ˆã¿ã‹@scE
â—
A script element has a ready to be parser-executedï¼¼
</dt>
	<dd>
çœŸå½å€¤
â€” åˆæœŸ~æ™‚ã¯ ~F ã¨ã™ã‚‹ã€‚
â—
boolean, initially false.ï¼¼
</dd>
	<dd>
ã“ã‚Œã¯ï¼Œæ§‹æ–‡è§£æå™¨ã«å½“ã®~scriptãŒã„ã¤å®Ÿè¡Œã•ã‚Œã‚‹ã‹çŸ¥ã‚‰ã›ã‚‹ãŸã‚ã«ã‚ã‚Šã€
å½“ã®è¦ç´ ãŒ`æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸ$å ´åˆã«é™ã‚Šï¼Œåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
This is used only used for elements that are also parser-inserted, to let the parser know when to execute the script.
</dd>

	<dt>
`ã™ã§ã«é–‹å§‹ã—ãŸã‹@scE
â—
A script element has an already startedï¼¼
</dt>
	<dd>
çœŸå½å€¤
â€” åˆæœŸ~æ™‚ã¯ ~F ã¨ã™ã‚‹ã€‚
â—
boolean, initially false.
</dd>

	<dt>
`~load~eventã‚’é…å»¶ã—ã¦ã„ã‚‹ã‹@scE
â—
A script element has a delaying the load eventï¼¼
</dt>
	<dd>
çœŸå½å€¤
â€” åˆæœŸ~æ™‚ã¯ ~F ã¨ã™ã‚‹ã€‚
â—
boolean, initially false.
</dd>

	<dt>
`ç¨®åˆ¥@scE
â—
A script element has a type,ï¼¼
</dt>
	<dd>
æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹
â‡’ï¼ƒ
~NULL,
`classic^l,
`module^l,
`importmap^l
â—
which is either null, "classic", "module", or "importmap", initially null.ï¼¼
</dd>
	<dd>
ã“ã‚Œã¯ã€
`~scriptè¦ç´ ã‚’æº–å‚™ã™ã‚‹$æ™‚ç‚¹ã§ï¼Œå½“ã®è¦ç´ ã® `type$a å±æ€§ã«åŸºã¥ã„ã¦æ±ºå®šã•ã‚Œã‚‹ã€‚
â—
It is determined when the element is prepared, based on the type attribute of the element at that time.
</dd>

	<dt>
`çµæœ@scE
â—
A script element has a result,ï¼¼
</dt>
	<dd>
æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹
â€” åˆæœŸ~æ™‚ã¯ `æœªåˆæœŸåŒ–^i ã¨ã™ã‚‹
â‡’ï¼ƒ
`æœªåˆæœŸåŒ–^i,
~NULL ï¼ˆ~errorã‚’è¡¨ç¾ã™ã‚‹ï¼‰,
`~script$,
`~import~mapæ§‹æ–‡è§£æ-çµæœ$
â—
which is either "uninitialized", null (representing an error), a script, or an import map parse result. It is initially "uninitialized".
</dd>

	<dt id="the-script-is-ready">
`çµæœã¯æº–å‚™æ¸ˆã¿æ™‚ã®æ‰‹ç¶šã@scE
â—
A script element has steps to run when the result is ready,ï¼¼
</dt>
	<dd>
æ‰‹ç¶šã ï¼ ~NULL
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
which are a series of steps or null, initially null.ï¼¼
</dd>
</dl>

<div class="algo">
<p>
`~scriptè¦ç´ ã‚’æº–å‚™æ¸ˆã¿ã«ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `script$e è¦ç´  %S, %çµæœ )
ã«å¯¾ã—
â—
To mark as ready a script element el given a script, import map parse result, or null result:
</p>
<ol>
	<li>
~Assertï¼š
%çµæœ ã¯æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹ã§ã‚ã‚‹
â‡’ï¼ƒ
`~script$ï¼
`~import~mapæ§‹æ–‡è§£æ-çµæœ$ï¼
~NULL
â—
â†‘</li>
	<li>
%S ã®`çµæœ$scE ~SET %çµæœ
â—
Set el's result to result.
</li>
	<li>
~IFï¼»
%S ã®`çµæœã¯æº–å‚™æ¸ˆã¿æ™‚ã®æ‰‹ç¶šã$scE ~NEQ ~NULL
ï¼½
â‡’
%S ã®`çµæœã¯æº–å‚™æ¸ˆã¿æ™‚ã®æ‰‹ç¶šã$scE()
â—
If el's steps to run when the result is ready are not null, then run them.
</li>
	<li>
%S ã®`çµæœã¯æº–å‚™æ¸ˆã¿æ™‚ã®æ‰‹ç¶šã$scE ~SET ~NULL
â—
Set el's steps to run when the result is ready to null.
</li>
	<li>
%S ã®`~load~eventã‚’é…å»¶ã—ã¦ã„ã‚‹ã‹$scE ~SET ~F
â—
Set el's delaying the load event to false.
</li>
</ol>
</div>

<hr>

<p>
`script$e è¦ç´  %S ã¯ã€
æ¬¡ã‚’æº€ãŸã™ãªã‚‰ã°ï¼Œ
`æš—é»™çš„ã«å…·ç¾åŒ–ã‚’é˜»ã‚€èƒ½æ€§$ãŒã‚ã‚‹ã¨ã™ã‚‹
â‡’
ï¼»
%S ã®`ç¨®åˆ¥$scE ~EQ `classic^l
ï¼½~ANDï¼»
%S ã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$scE ~NEQ ~NULL
ï¼½~ANDï¼»
%S ã¯ï¼»
`async$a, `defer$a
ï¼½ã©ã¡ã‚‰ã®å±æ€§ã‚‚æœ‰ã•ãªã„
ï¼½
â—
A script element el is implicitly potentially render-blocking if el's type is "classic", el is parser-inserted, and el does not have an async or defer attribute.
</p>

<p class="algo">
`script$e è¦ç´ ~ç”¨ã®`~cloneæ™‚ã®æ‰‹ç¶šã$ã¯ã€
æ‰€ä¸ã®
( %~node, %è¤‡è£½, â€¦ )
ã«å¯¾ã—
â‡’
%è¤‡è£½ ã®`ã™ã§ã«é–‹å§‹ã—ãŸã‹$scE ~SET %~node ã®`ã™ã§ã«é–‹å§‹ã—ãŸã‹$scE
â—
The cloning steps for script elements given node, copy, and subtree are to set copy's already started to node's already started.
</p>

<p>
`script$e è¦ç´  %S ã« `async$a å±æ€§ãŒè¿½åŠ ã•ã‚ŒãŸã¨ãã¯ã€
%S ã®`éåŒæœŸcã‚’å¼·åˆ¶ã™ã‚‹ã‹$scEã‚’ ~F ã«è¨­å®šã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
When an async attribute is added to a script element el, the user agent must set el's force async to false.
</p>

<p>
`script$e è¦ç´  %S ãŒï¼»
ãã®`~load~eventã‚’é…å»¶ã—ã¦ã„ã‚‹ã‹$scE ~EQ ~T
ï¼½ã‚’æº€ãŸã—ã¦ã„ã‚‹é–“ã¯ã€
%S ã®`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸$scEã®`~load~eventã‚’é…å»¶ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
Whenever a script element el's delaying the load event is true, the user agent must delay the load event of el's preparation-time document.
</p>

<hr>

<div class="algo">
<p>
`script$e ç”¨ã®`~HTMLè¦ç´ ~æ¥ç¶š~å¾Œã®æ‰‹ç¶šã$ã¯ã€
æ‰€ä¸ã®
( %æŒ¿å…¥ã•ã‚ŒãŸ~node )
ã«å¯¾ã—ï¼š
â—
The script HTML element post-connection steps, given insertedNode, are:
</p>
<ol>
	<li>
<p>
~IFï¼»
%æŒ¿å…¥ã•ã‚ŒãŸ~node ã¯`æ¥ç¶šã•ã‚Œã¦$ã„ãªã„
ï¼½
â‡’
~RET
â—
If insertedNode is not connected, then return.
</p>

<div class="example">
<p>
ã“ã‚Œã¯ã€
å…ˆã«æŒ¿å…¥ã•ã‚ŒãŸ `script$e ãŒå¾Œã‹ã‚‰æŒ¿å…¥ã•ã‚ŒãŸ `script$e ï¼ˆ %æŒ¿å…¥ã•ã‚ŒãŸ~node ï¼‰ã‚’é™¤å»ã™ã‚‹äº‹ä¾‹ã§èµ·ã“ã‚Šå¾—ã‚‹ã€‚
ä¸€ä¾‹ã¨ã—ã¦ï¼š
â—
This can happen in the case where an earlier-inserted script removes a later-inserted script. For instance:
</p>

`script-processing-model-1^xCode

<p>
ã“ã®ä¾‹ã§ã¯ã€
~consoleã¸ã¯ä½•ã‚‚~printã•ã‚Œãªã„ã€‚
2 å€‹ã® `script$e %script1, %script2 ã¯ï¼Œ
`append()$m ã«ã‚ˆã‚Šä¸å¯åˆ†ã«æŒ¿å…¥ã•ã‚Œã‚‹ãŒã€
%script1 ã¯ï¼»
%script1 ç”¨ã«`~HTMLè¦ç´ ~æ¥ç¶š~å¾Œã®æ‰‹ç¶šã$ã‚’èµ°ã‚‰ã™æ™‚ç‚¹
ï¼½ã¾ã§ã«ï¼»
%script2 ãŒ~DOMã¸`æ¥ç¶šã•ã‚Œã¦$ã„ã‚‹ã“ã¨
ï¼½ã‚’è¦³æ¸¬ã§ãï¼Œï¼»
<em>%script2 ç”¨</em>ã«`~HTMLè¦ç´ ~æ¥ç¶š~å¾Œã®æ‰‹ç¶šã$ã‚’èµ°ã‚‰ã™æ™‚ç‚¹
ï¼½ã¾ã§ã« %script2 ã‚’é™¤å»ã™ã‚‹
â€” ãã®çµæœã€
%script2 ã¯ï¼Œãã®æ™‚ç‚¹ã§ã¯`æ¥ç¶šã•ã‚Œã¦$ã„ãªããªã‚Šã€
%script2 ç”¨ã«`~scriptè¦ç´ ã‚’æº–å‚™ã™ã‚‹$ã“ã¨ã‚‚ãªããªã‚‹ã€‚
â—
Nothing is printed to the console in this example. By the time the HTML element post-connection steps run for the first script that was atomically inserted by append(), it can observe that the second script is already connected to the DOM. It removes the second script, so that by the time its HTML element post-connection steps run, it is no longer connected, and does not get prepared.
</p>
</div>
	</li>
	<li>
~IFï¼»
%æŒ¿å…¥ã•ã‚ŒãŸ~node ã¯`æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸ$
ï¼½
â‡’
~RET
â—
If insertedNode is parser-inserted, then return.
</li>
	<li>
`~scriptè¦ç´ ã‚’æº–å‚™ã™ã‚‹$( %æŒ¿å…¥ã•ã‚ŒãŸ~node )
â—
Prepare the script element given insertedNode.
</li>
</ol>
</div>

<div class="algo">
`script$e è¦ç´  %è¦ç´  ç”¨ã®`å­~ç¾¤~å¤‰æ›´-æ™‚ã®æ‰‹ç¶šã$ã¯
â‡’
`script$e ç”¨ã®`~HTMLè¦ç´ ~æ¥ç¶š~å¾Œã®æ‰‹ç¶šã$( %è¦ç´  )
â—
The script children changed steps are:
â€¢ Run the script HTML element post-connection steps, given the script element.
</div>

<div class="example">
<p>
ã“ã‚Œã«ã¯ã€ï¼»
ã‚ã‚‹ `script$e è¦ç´ , æ–°ãŸã«æŒ¿å…¥ã•ã‚Œã‚‹å­ `script$e è¦ç´ ãŸã¡
ï¼½ã®å®Ÿè¡Œ~é †åºã«ã¤ã„ã¦é–¢å¿ƒäº‹ã«ãªã‚‹å«æ„ãŒã‚ã‚‹ã€‚
æ¬¡ã®~codeç‰‡ã‚’è€ƒãˆã‚‹ï¼š
â—
This has an interesting implication on the execution order of a script element and any newly-inserted child script elements. Consider the following snippet:
</p>

`script-processing-model-2^xCode

<p>
1 å€‹ç›®ã®~script~blockï¼ˆ `id=outer-script^c ï¼ %outerScript ï¼‰ã¯ã€
2 å€‹ç›®ã®~script~blockãŒå®Ÿè¡Œã•ã‚Œã‚‹æ™‚ç‚¹ã¾ã§ã«ã¯`æº–å‚™-$æ¸ˆã¿ã«ãªã‚‹ãŒï¼Œ
ã¾ã ç©ºãªã®ã§å®Ÿè¡Œã•ã‚Œãªã„
â€” ã—ãŸãŒã£ã¦ï¼Œãã®`ã™ã§ã«é–‹å§‹ã—ãŸã‹$scEã¯ ~F ã®ã¾ã¾ã«ãªã‚‹ã€‚
â—
By the time the second script block executes, the outer-script has already been prepared, but because it is empty, it did not execute and therefore is not marked as already started.ï¼¼
</p>

<p>
2 å€‹ç›®ã®~script~blockãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ãã€
%outerScript ã®å­ã¨ã—ã¦ï¼»
`Text$I ~node %start,
å…¥å­ãª `script$e è¦ç´  %innerScript,
ã‚‚ã†ä¸€ã¤ã® `Text$I ~node %end
ï¼½ã‚’ä¸å¯åˆ†ã«æŒ¿å…¥ã™ã‚‹ã“ã¨ã«ã‚ˆã‚‹åŠ¹æœã¯ï¼š
â—
The atomic insertion of the Text nodes and nested script element have the following effects:
â€¢ All three child nodes get atomically inserted as children of outer-script;ï¼¼
</p>
<ol>
	<li>
æŒ¿å…¥ã•ã‚ŒãŸå„~nodeç”¨ã«`æŒ¿å…¥-æ™‚ã®æ‰‹ç¶šã$ãŒèµ°ã‚‹
â€” ã“ã®äº‹ä¾‹ã§ã¯ã€
ãã‚Œã‚‰ã«ã¯è¦³æ¸¬-å¯èƒ½ãªå¸°çµã¯ç„¡ã„ã€‚
â—
all of their insertion steps run, which have no observable consequences in this case.
</li>
	<li>
%outerScript ç”¨ã«`å­~ç¾¤~å¤‰æ›´-æ™‚ã®æ‰‹ç¶šã$ãŒèµ°ã‚‹ã€‚
ãã‚Œã«ä¼´ã„ï¼Œ %outerScript ãŒ`æº–å‚™-$ã•ã‚Œã‚‹
â€” ãã®æœ¬ä½“ã¯ä»Šã‚„ç©ºã§ãªã„ã®ã§ã€
%start, %end ã®å†…å®¹ãŒé †ã«å®Ÿè¡Œã•ã‚Œã‚‹ã€‚
ã€ %innerScript ã®å†…å®¹ã¯ %outerScript ã®`å­~textå†…å®¹$ã‚’æˆã•ãªã„ã®ã§ç„¡è¦–ã•ã‚Œã‚‹ã€‚ã€‘
â—
The outer-script's children changed steps run, which prepares that script; because its body is now non-empty, this executes the contents of the two Text nodes, in order.
</li>
	<li>
%innerScript ç”¨ã« `script$e ç”¨ã®`~HTMLè¦ç´ ~æ¥ç¶š~å¾Œã®æ‰‹ç¶šã$ãŒèµ°ã‚‹ã€‚
ãã®çµæœã€
%innerScript ã®æœ¬ä½“ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã€‚
â—
The script HTML element post-connection steps finally run for innerScript, causing its body to execute.
</li>
</ol>
</div>

<div class="algo">
æ¬¡ã«å®šç¾©ã™ã‚‹`å±æ€§~å¤‰æ›´-æ™‚ã®æ‰‹ç¶šã$ã¯ã€
ã™ã¹ã¦ã® `script$e è¦ç´  %è¦ç´  ç”¨ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
ãã‚Œã¯ã€
æ‰€ä¸ã®
( %å±€æ‰€~å, %æ—§-å€¤, %å€¤, %åå‰ç©ºé–“ )
ã«å¯¾ã—
â‡’
~IFï¼»
%åå‰ç©ºé–“ ~EQ ~NULL
ï¼½~ANDï¼»
%å±€æ‰€~å ~EQ "`src$a"
ï¼½
â‡’
`script$e ç”¨ã®`~HTMLè¦ç´ ~æ¥ç¶š~å¾Œã®æ‰‹ç¶šã$( %è¦ç´  )
â—
The following attribute change steps, given element, localName, oldValue, value, and namespace, are used for all script elements:
â€¢ If namespace is not null, then return.
â€¢ If localName is src, then run the script HTML element post-connection steps, given element.
</div>

<div class="algo">
<p>
`~scriptè¦ç´ ã‚’æº–å‚™ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `script$e è¦ç´  %S )
ã«å¯¾ã—ï¼š
â—
To prepare the script element given a script element el:
</p>
<ol>
	<li>
~IFï¼»
%S ã®`ã™ã§ã«é–‹å§‹ã—ãŸã‹$scE ~EQ ~T
ï¼½
â‡’
~RET
â—
If el's already started is true, then return.
</li>
	<li>
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~LET %S ã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$scE
â—
Let parser document be el's parser document.
</li>
	<li>
<p>
%S ã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$scE ~SET ~NULL
â—
Set el's parser document to null.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ®µã¯ã€ï¼»
`æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸ$ `script$e è¦ç´ ã‚’å½“ã®æ§‹æ–‡è§£æå™¨ãŒèµ°ã‚‰ã›ã‚ˆã†ã¨è©¦è¡Œã—ã¦å¤±æ•—ã—ãŸå ´åˆ
ï¼ˆä¾‹ï¼š ç©ºã‚ã‚‹ã„ã¯, æœª~supportãª~scriptingè¨€èªã‚’æŒ‡å®šã—ã¦ã„ãŸï¼‰
ï¼½ã«ï¼Œå¾Œã§ï¼»
åˆ¥ã®~scriptãŒãã‚Œã‚’å¤‰ç•°ã•ã›ã¦å†åº¦~èµ°ã‚‰ã™
ï¼½ã“ã¨ã‚’å¯èƒ½ã«ã™ã‚‹ãŸã‚ã«è¡Œã‚ã‚Œã‚‹ã€‚
â—
This is done so that if parser-inserted script elements fail to run when the parser tries to run them, e.g. because they are empty or specify an unsupported scripting language, another script can later mutate them and cause them to run again.
</p>
	</li>
	<li>
<p>
~IFï¼»
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~NEQ ~NULL
ï¼½~ANDï¼»
%S ã¯ `async$a å±æ€§ã‚’æœ‰ã•ãªã„
ï¼½
â‡’
%S ã®`éåŒæœŸcã‚’å¼·åˆ¶ã™ã‚‹ã‹$scE ~SET ~T
â—
If parser document is non-null and el does not have an async attribute, then set el's force async to true.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ®µã¯ã€ï¼»
`æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸ$ `script$e è¦ç´ ã‚’å½“ã®æ§‹æ–‡è§£æå™¨ãŒèµ°ã‚‰ã›ã‚ˆã†ã¨è©¦è¡Œã—ã¦å¤±æ•—ã—ãŸãŒã€
ä»–ã®~scriptãŒå‹•çš„ã«ãã‚Œã‚’æ›´æ–°ã—ãŸå¾Œã«ï¼Œå¾Œã§å®Ÿè¡Œã•ã‚ŒãŸå ´åˆ
ï¼½ã«ï¼»
`async$a å±æ€§ãŒè¨­å®šã•ã‚Œã¦ã„ãªãã¨ã‚‚ï¼Œ
éåŒæœŸcãªæµå„€ã§å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
ï¼½ãŸã‚ã«è¡Œã‚ã‚Œã‚‹ã€‚
â—
This is done so that if a parser-inserted script element fails to run when the parser tries to run it, but it is later executed after a script dynamically updates it, it will execute in an async fashion even if the async attribute isn't set.
</p>
	</li>
	<li>
%~source~text ~LET %S ã®`å­~textå†…å®¹$
â—
Let source text be el's child text content.
</li>
	<li>
%src ~LET ï¼»
%S ã¯ `src$a å±æ€§ã‚’æœ‰ã™ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
~ELSE_ Îµ
ï¼½
â—
â†“</li>
	<li id="script-processing-empty">
~IFï¼»
%src ~EQ Îµ
ï¼½~ANDï¼»
%~source~text ~EQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’
~RET
â—
If el has no src attribute, and source text is the empty string, then return.
</li>
	<li>
~IFï¼»
%S ã¯`æ¥ç¶šã•ã‚Œã¦$ã„ãªã„
ï¼½
â‡’
~RET
â—
If el is not connected, then return.
</li>
	<li>
<div>
<p id="script-processing-prepare">
%~script~blockã®ç¨®åˆ¥~æ–‡å­—åˆ— ~LET æ¬¡ã«ä¸ãˆã‚‹ï¼»
%type, %language
ï¼½ãŒæº€ãŸã™æ¡ä»¶ã«å¿œã˜ã¦ã€
ä¸‹ã®è¡¨tã® 3 åˆ—ç›®ã«ä¸ãˆã‚‰ã‚Œã‚‹å€¤ï¼š
</p>
		<ul>
			<li>
%type ~LETï¼»
%S ã¯ `type$a å±æ€§ã‚’æœ‰ã™ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
~ELSE_ Îµ
ï¼½
</li>
			<li>
%language ~LETï¼»
%S ã¯ `language$a å±æ€§ã‚’æœ‰ã™ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
~ELSE_ Îµ
ï¼½
</li>
		</ul>

<table><thead>
<tr><th>%type
<th>%language
<th>%~script~blockã®ç¨®åˆ¥~æ–‡å­—åˆ—
<tbody>

<tr><td>Îµ
<td>Îµ
<td>`text/javascript^l

<tr><td>Îµ
<td>ç©º~æ–‡å­—åˆ—
<td>`text/javascript^l

<tr><td>Îµ
<td>ç©ºã§ãªã„æ–‡å­—åˆ—
<td>ï¼»
`text/^l, %language
ï¼½ã‚’é€£çµã—ãŸçµæœ

<tr><td>ç©º~æ–‡å­—åˆ—
<td>ä»»æ„
<td>`text/javascript^l

<tr><td>ç©ºã§ãªã„æ–‡å­—åˆ—
<td>ä»»æ„
<td>`å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã$( %type )
</table>

â—
If any of the following are true:
â€¢ el has a type attribute whose value is the empty string;
â€¢ el has no type attribute but it has a language attribute and that attribute's value is the empty string; or
â€¢ el has neither a type attribute nor a language attribute,
â—
then let the script block's type string for this script element be "text/javascript".
â—
Otherwise, if el has a type attribute, then let the script block's type string be the value of that attribute with leading and trailing ASCII whitespace stripped.
â—
Otherwise, el has a non-empty language attribute; let the script block's type string be the concatenation of "text/" and the value of el's language attribute.
</div>

<p class="note">æ³¨è¨˜ï¼š
`language$a å±æ€§ã¯ã€
æ±ºã—ã¦é©åˆã›ãšï¼Œ
`type$a å±æ€§ãŒåœ¨ã‚‹ã¨ãã¯å¸¸ã«ç„¡è¦–ã•ã‚Œã‚‹ã€‚
â—
The language attribute is never conforming, and is always ignored if there is a type attribute present.
</p>
	</li>
	<li>
~IFï¼»
%~script~blockã®ç¨®åˆ¥~æ–‡å­—åˆ— ã¯`~JS~MIMEå‹ã«~essenceåˆè‡´-$ã™ã‚‹
ï¼½
â‡’
%S ã®`ç¨®åˆ¥$scE ~SET `classic^l
â—
If the script block's type string is a JavaScript MIME type essence match, then set el's type to "classic".
</li>
	<li>
~ELIFï¼»
%~script~blockã®ç¨®åˆ¥~æ–‡å­—åˆ— ã¯ `module^l ã«`~ASCIIå¤§å°ç„¡è¦–$ã§åˆè‡´ã™ã‚‹
ï¼½
â‡’
%S ã®`ç¨®åˆ¥$scE ~SET `module^l
â—
Otherwise, if the script block's type string is an ASCII case-insensitive match for the string "module", then set el's type to "module".
</li>
	<li>
~ELIFï¼»
%~script~blockã®ç¨®åˆ¥~æ–‡å­—åˆ— ã¯ `importmap^l ã«`~ASCIIå¤§å°ç„¡è¦–$ã§åˆè‡´ã™ã‚‹
ï¼½
â‡’
%S ã®`ç¨®åˆ¥$scE ~SET `importmap^l
â—
Otherwise, if the script block's type string is an ASCII case-insensitive match for the string "importmap", then set el's type to "importmap".
</li>
	<li>
~ELSE
â‡’
~RET
ï¼ˆå®Ÿè¡Œã•ã‚Œã‚‹~scriptã¯ãªãï¼Œ %S ã®`ç¨®åˆ¥$scEã¯ ~NULL ã®ã¾ã¾ã€‚ï¼‰
â—
Otherwise, return. (No script is executed, and el's type is left as null.)
</li>
	<li>
~IFï¼»
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~NEQ ~NULL
ï¼½
â‡’ï¼ƒ
%S ã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$scE ~SET %æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ï¼›
%S ã®`éåŒæœŸcã‚’å¼·åˆ¶ã™ã‚‹ã‹$scE ~SET ~F
â—
If parser document is non-null, then set el's parser document back to parser document and set el's force async to false.
</li>
	<li>
~Assertï¼š
%S ã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$scE ~EQ %æ§‹æ–‡è§£æå™¨~æ–‡æ›¸
ã€ã“ã®æ®µã¯ã€ã“ã®è¨³ã«ã‚ˆã‚‹è£œå®Œã€‚ã€‘
</li>
	<li id="script-processing-start">
%S ã®`ã™ã§ã«é–‹å§‹ã—ãŸã‹$scE ~SET ~T
â—
Set el's already started to true.
</li>
	<li>
%æ–‡æ›¸ ~LET %S ã®`~nodeæ–‡æ›¸$
â—
â†“</li>
	<li>
%S ã®`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸$scE ~SET %æ–‡æ›¸
â—
Set el's preparation-time document to its node document.
</li>
	<li>
~IFï¼»
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~NIN { ~NULL, %æ–‡æ›¸ã€ï¼%S ã®`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸$scEã€‘ }
ï¼½
â‡’
~RET
â—
If parser document is non-null, and parser document is not equal to el's preparation-time document, then return.
</li>
	<li id="script-processing-noscript">
<p>
~IFï¼»
%S ç”¨ã®`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹
ï¼½
â‡’
~RET
â—
If scripting is disabled for el, then return.
</p>

<div class="note">
<p>æ³¨è¨˜ï¼š
`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹ï¼Œã®å®šç¾©ã«ã‚ˆã‚Šã€
æ¬¡ã«è©²å½“ã™ã‚‹~scriptã¯ï¼Œå®Ÿè¡Œã•ã‚Œãªã„ï¼š
</p>
		<ul>
			<li>
`XMLHttpRequest$I ã® `responseXML$m æ–‡æ›¸~å†…ã®~scriptã€‚
`XHR$r
</li>
			<li>
`DOMParser$I ãŒä½œæˆã—ãŸæ–‡æ›¸~å†…ã®~scriptã€‚
`DOMPARSING$r
</li>
			<li>
`XSLTProcessor$I ã® `transformToDocument()$m ç‰¹èƒ½ã«ã‚ˆã‚Šä½œæˆã•ã‚ŒãŸæ–‡æ›¸~å†…ã®~scriptã€‚
`XSLTP$r
</li>
			<li>
ï¼»
`createDocument()$m ~APIã‚’åˆ©ç”¨ã—ã¦ä½œæˆã•ã‚ŒãŸ`æ–‡æ›¸$
ï¼½ã®ä¸­ã«ï¼Œã‚ã‚‹~scriptã«ã‚ˆã‚Šå…ˆãšæŒ¿å…¥ã•ã‚ŒãŸ~scriptã€‚
`DOM$r
ã€ï¼ ï¼Šå…ˆãšã€‘
</li>
		</ul>
â—
The definition of scripting is disabled means that, amongst others, the following scripts will not execute: scripts in XMLHttpRequest's responseXML documents, scripts in DOMParser-created documents, scripts in documents created by XSLTProcessor's transformToDocument feature, and scripts that are first inserted by a script into a Document that was created using the createDocument() API. [XHR] [DOMPARSING] [XSLTP] [DOM]
</div>

	</li>
	<li>
%ç¨®åˆ¥ ~LET %S ã®`ç¨®åˆ¥$scE
â—
â†“</li>
	<li>
<p>
~IFï¼»
%S ã¯ `nomodule$a å†…å®¹~å±æ€§ã‚’æœ‰ã™ã‚‹
ï¼½~ANDï¼»
%ç¨®åˆ¥ ~EQ `classic^l
ï¼½
â‡’
~RET
â—
If el has a nomodule content attribute and its type is "classic", then return.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€ï¼»
`~module~script$ã«å¯¾ã— `nomodule$a ã‚’æŒ‡å®šã—ã¦ã‚‚åŠ¹æœã¯ãªãï¼Œ
~algoã¯ãã®ã¾ã¾ç¶™ç¶šã•ã‚Œã‚‹
ï¼½ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
â—
This means specifying nomodule on a module script has no effect; the algorithm continues onward.
</p>
	</li>
	<li id="script-processing-csp">
~IFï¼»
%src ~EQ Îµ
ï¼½
â‡’
~IFï¼»
`è¦ç´ ã«ãŠã‘ã‚‹~inlineå‹ã®æŒ™å‹•ã¯~CSPã«ã‚ˆã‚Šé˜»æ­¢ã•ã‚Œã‚‹ã¹ãã‹ï¼Ÿ$( %S, `script^l, %~source~text )
`CSP$r
ã®çµæœ ~EQ `é˜»æ­¢ã•ã‚Œã‚‹^i
ï¼½
â‡’
~RET
â—
If el does not have a src content attribute, and the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when given el, "script", and source text, then return. [CSP]
</li>
	<li id="script-processing-for">
<p>
~IFï¼»
%ç¨®åˆ¥ ~EQ `classic^l
ï¼½~ANDï¼»
%S ã¯ `event$a å±æ€§ã‚’æœ‰ã™ã‚‹
ï¼½~ANDï¼»
%S ã¯ `for$a å±æ€§ã‚’æœ‰ã™ã‚‹
ï¼½ï¼š
</p>
		<ol>
			<li>
%event ~LET `~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹$( `å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã$( %S ã® `event$a å±æ€§ã®å€¤ ) )
</li>
			<li>
~IFï¼»
%event ~NIN { `onload^l, `onload()^l }
ï¼½
â‡’
~RET
</li>
			<li>
%for ~LET `~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹$( `å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã$( %S ã® `for$a å±æ€§ã®å€¤ ) )
</li>
			<li>
~IFï¼»
%for ~NEQ `window^l
ï¼½
â‡’
~RET
</li>
		</ol>
â—
If el has an event attribute and a for attribute, and el's type is "classic", then:
â€¢ Let for be the value of el's for attribute.
â€¢ Let event be the value of el's event attribute.
â€¢ Strip leading and trailing ASCII whitespace from event and for.
â€¢ If for is not an ASCII case-insensitive match for the string "window", then return.
â€¢ If event is not an ASCII case-insensitive match for either the string "onload" or the string "onload()", then return.
</li>
	<li id="script-processing-encoding">
<p>
%ç¬¦å·åŒ–æ³• ~LET ï¼»ï¼»
%S ã¯ `charset$a å±æ€§ã‚’æœ‰ã—ã¦ã„ã¦ï¼»
`~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹$( ãã®å±æ€§~å€¤ ) ã®çµæœ ~NEQ `å¤±æ•—^i
ï¼½ï¼½ãªã‚‰ã° ãã®çµæœ ï¼
~ELSE_ %æ–‡æ›¸ ã®`ç¬¦å·åŒ–æ³•$doc
ï¼½
â—
If el has a charset attribute, then let encoding be the result of getting an encoding from the value of the charset attribute.
â—
If el does not have a charset attribute, or if getting an encoding failed, then let encoding be el's node document's the encoding.
</p>

<p class="note">æ³¨è¨˜ï¼š
ï¼»
%ç¨®åˆ¥ ~EQ `module^l
ï¼½ã®å ´åˆã€
ã“ã®ç¬¦å·åŒ–æ³•ã¯ç„¡è¦–ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
If el's type is "module", this encoding will be ignored.
</p>
	</li>
	<li>
%å¤å…¸~script~CORSè¨­å®š ~LET %S ã® `crossorigin$a å†…å®¹~å±æ€§ã®ç¾åœ¨ã®çŠ¶æ…‹
â—
Let classic script CORS setting be the current state of el's crossorigin content attribute.
</li>
	<li>
%~module~scriptè³‡æ ¼è¨¼~mode ~LET
%S ã® `crossorigin$a å†…å®¹~å±æ€§~ç”¨ã®`~CORSè¨­å®šç¾¤~å±æ€§ã®è³‡æ ¼è¨¼~mode$
â—
Let module script credentials mode be the CORS settings attribute credentials mode for el's crossorigin content attribute.
</li>
	<li>
%æš—å·ç”¨~nonce ~LET %S ã® `CryptographicNonce$sl å†…éƒ¨~slotã®å€¤
â—
Let cryptographic nonce be el's [[CryptographicNonce]] internal slot's value.
</li>
	<li>
%å®Œå…¨æ€§~metadata ~LET ï¼»
%S ã¯ `integrity$a å±æ€§ã‚’æœ‰ã™ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
~ELSE_ ç©º~æ–‡å­—åˆ—
ï¼½
â—
If el has an integrity attribute, then let integrity metadata be that attribute's value.
â—
Otherwise, let integrity metadata be the empty string.
</li>
	<li>
%~referreræ–½ç­– ~LET %S ã® `referrerpolicy$a å†…å®¹~å±æ€§ã®ç¾åœ¨ã®çŠ¶æ…‹
â—
Let referrer policy be the current state of el's referrerpolicy content attribute.
</li>
	<li>
%~fetchå„ªå…ˆåº¦ ~LET %S ã® `fetchpriority$a å†…å®¹~å±æ€§ã®ç¾åœ¨ã®çŠ¶æ…‹
â—
Let fetch priority be the current state of el's fetchpriority content attribute.
</li>
	<li>
%æ§‹æ–‡è§£æå™¨~metadata ~LET ï¼»
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~NEQ ~NULL ãªã‚‰ã° `parser-inserted^l ï¼
~ELSE_ `not-parser-inserted^l
ï¼½
â—
Let parser metadata be "parser-inserted" if el is parser-inserted, and "not-parser-inserted" otherwise.
</li>
	<li>
%~optionç¾¤ ~LET æ–°ãŸãª`~script~fetch~optionç¾¤$
â€” ãã®
â‡’ï¼ƒ
`æš—å·ç”¨~nonce$sfO ~SET %æš—å·ç”¨~nonce,
`å®Œå…¨æ€§~metadata$sfO ~SET %å®Œå…¨æ€§~metadata,
`æ§‹æ–‡è§£æå™¨~metadata$sfO ~SET %æ§‹æ–‡è§£æå™¨~metadata,
`è³‡æ ¼è¨¼~mode$sfO ~SET %~module~scriptè³‡æ ¼è¨¼~mode,
`~referreræ–½ç­–$sfO ~SET %~referreræ–½ç­–,
`~fetchå„ªå…ˆåº¦$sfO ~SET %~fetchå„ªå…ˆåº¦
â—
Let options be a script fetch options whose cryptographic nonce is cryptographic nonce, integrity metadata is integrity metadata, parser metadata is parser metadata, credentials mode is module script credentials mode, referrer policy is referrer policy, and fetch priority is fetch priority.
</li>
	<li>
%è¨­å®šç¾¤~obj ~LET %æ–‡æ›¸ ã«`é–¢é€£ãªè¨­å®šç¾¤~obj$
â—
Let settings object be el's node document's relevant settings object.
</li>
	<li id="script-processing-src-prepare">
<p>
~IFï¼»
%src ~NEQ Îµ
ï¼½ï¼š
â—
If el has a src content attribute, then:
</p>
		<ol>
			<li>
<p>
~IFï¼»
%S ã®`ç¨®åˆ¥$scE ~EQ `importmap^l
ï¼½ï¼š
â—
If el's type is "importmap", thenï¼¼
</p>
				<ol>
					<li>
<p>
`è¦ç´ ~taskã‚’~queueã™ã‚‹$( `~DOMæ“ä½œ~task~source$, %S, æ¬¡ã®æ‰‹ç¶šã )
â—
queue an element task on the DOM manipulation task source given el toï¼¼
</p>

<div class="algo">
æ‰‹ç¶šãã¯
â‡’
`~eventã‚’ç™ºç«ã™ã‚‹$( %S, `error$et )
â—
fire an event named error at el,ï¼¼
</div>
					</li>
					<li>
~RET
â—
and return.
</li>
				</ol>

<p class="note">æ³¨è¨˜ï¼š
ç¾æ™‚ç‚¹ã§ã¯ã€
å¤–éƒ¨~import~map~scriptã¯ï¼Œ~supportã•ã‚Œãªã„ã€‚
~supportã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã«ã¤ã„ã¦ã®è«–ç‚¹ã¯ã€
`WICG/import-maps èª²é¡Œ #235ï¼ https://github.com/WICG/import-maps/issues/235$
ã‚’è¦‹ã‚ˆã€‚
â—
External import map scripts are not currently supported. See WICG/import-maps issue #235 for discussions on adding support.
</p>
			</li>
			<li>
<p>
~IFï¼»
%src ~EQ ç©º~æ–‡å­—åˆ—
ï¼½ï¼š
â—
â†‘â†‘Let src be the value of el's src attribute.
â—
If src is the empty string, thenï¼¼
</p>
				<ol>
					<li>
<p>
`è¦ç´ ~taskã‚’~queueã™ã‚‹$( `~DOMæ“ä½œ~task~source$, %S, æ¬¡ã®æ‰‹ç¶šã )
â—
queue an element task on the DOM manipulation task source given el toï¼¼
</p>

<div class="algo">
æ‰‹ç¶šãã¯
â‡’
`~eventã‚’ç™ºç«ã™ã‚‹$( %S, `error$et )
â—
fire an event named error at el,ï¼¼
</div>
					</li>
					<li>
~RET
â—
and return.
</li>
				</ol>
			</li>
			<li>
%S ã®`å¤–éƒ¨~fileã‹$scE ~SET ~T
â—
Set el's from an external file to true.
</li>
			<li>
%~URL ~LET `~URLã‚’ç¬¦å·åŒ–æ³•ã®ä¸‹ã§ç›¸å¯¾çš„ã«æ§‹æ–‡è§£æã™ã‚‹$( %src, %æ–‡æ›¸ )
â—
Let url be the result of encoding-parsing a URL given src, relative to el's node document.
</li>
			<li>
<p>
~IFï¼»
%~URL ~EQ `å¤±æ•—^i
ï¼½ï¼š
â—
If url is failure, thenï¼¼
</p>
				<ol>
					<li>
<p>
`è¦ç´ ~taskã‚’~queueã™ã‚‹$( `~DOMæ“ä½œ~task~source$, %S, æ¬¡ã®æ‰‹ç¶šã )
â—
queue an element task on the DOM manipulation task source given el toï¼¼
</p>

<div class="algo">
æ‰‹ç¶šãã¯
â‡’
`~eventã‚’ç™ºç«ã™ã‚‹$( %S, `error$et )
â—
fire an event named error at el,ï¼¼
</div>
					</li>
					<li>
~RET
â—
and return.
</li>
				</ol>
			</li>
			<li>
~IFï¼»
%S ã«ã¯`å…·ç¾åŒ–ã‚’é˜»ã‚€èƒ½æ€§$ãŒã‚ã‚‹
ï¼½
â‡’
`å…·ç¾åŒ–ã‚’é˜»ã‚€$( %S )
â—
If el is potentially render-blocking, then block rendering on el.
</li>
			<li>
%S ã®`~load~eventã‚’é…å»¶ã—ã¦ã„ã‚‹ã‹$scE ~SET ~T
â—
Set el's delaying the load event to true.
</li>
			<li>
~IFï¼»
%S ã¯ç¾åœ¨`å…·ç¾åŒ–ã‚’é˜»ã‚“ã§$ã„ã‚‹
ï¼½
â‡’
%~optionç¾¤ ã®`å…·ç¾åŒ–ã‚’é˜»ã‚“ã§ã„ã‚‹ã‹$sfO ~SET ~T
â—
If el is currently render-blocking, then set options's render-blocking to true.
</li>
			<li class="algo">
%å®Œäº†-æ™‚ã®æ‰‹ç¶šã ~LET
æ‰€ä¸ã®
( %çµæœ )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™æ‰‹ç¶šã
â‡’
`~scriptè¦ç´ ã‚’æº–å‚™æ¸ˆã¿ã«ã™ã‚‹$( %S, %çµæœ )
â—
Let onComplete given result be the following steps:
â€¢ Mark as ready el given result.
</li>
			<li>
<p>
%ç¨®åˆ¥ ã«å¿œã˜ã¦ï¼š
â—
Switch on el's type:
</p>
				<ul class="switch">
					<li>
`classic^l
â‡’
`å¤å…¸~scriptã‚’~fetchã™ã‚‹$( â†“ )
â‡’ï¼ƒ
%~URL,
%è¨­å®šç¾¤~obj,
%~optionç¾¤,
%å¤å…¸~script~CORSè¨­å®š,
%ç¬¦å·åŒ–æ³•,
%å®Œäº†-æ™‚ã®æ‰‹ç¶šã
â—
"classic"
â€¢ Fetch a classic script given url, settings object, options, classic script CORS setting, encoding, and onComplete.
</li>
					<li>
<p>
`module^lï¼š
</p>
						<ol>
							<li>
~IFï¼»
%S ã¯ `integrity$a å±æ€§ã‚’æœ‰ã•ãªã„
ï¼½
â‡’
%~optionç¾¤ ã®`å®Œå…¨æ€§~metadata$sfO ~SET `~moduleå®Œå…¨æ€§~metadataã‚’è§£æ±ºã™ã‚‹$( %~URL, %è¨­å®šç¾¤~obj )
â—
If el does not have an integrity attribute, then set options's integrity metadata to the result of resolving a module integrity metadata with url and settings object.
</li>
							<li>
`å¤–éƒ¨~module~script~graphã‚’~fetchã™ã‚‹$( â†“ )
â‡’ï¼ƒ
%~URL,
%è¨­å®šç¾¤~obj,
%~optionç¾¤,
%å®Œäº†-æ™‚ã®æ‰‹ç¶šã
â—
"module"
â€¢ Fetch an external module script graph given url, settings object, options, and onComplete.
</li>
						</ol>
					</li>
				</ul>
<p>
å‡¦ç†èƒ½ã®ç†ç”±ã‹ã‚‰ã€
~UAã¯ï¼š
â—
For performance reasons, user agentsï¼¼
</p>
				<ul>
					<li>
%S ã® `src$a å±æ€§ãŒè¨­å®šã•ã‚Œæ¬¡ç¬¬ï¼Œã™ãã«ï¼»
å¤å…¸~scriptï¼~module~graph
ï¼½ã®~fetchingã‚’ï¼ˆä¸Šã«å®šç¾©ã—ãŸã¨ãŠã‚Šã«ï¼‰é–‹å§‹ã—ã¦ã‚‚ãƒ¨ã‚¤
â€” ~~å®Ÿéš›ã« %S ãŒ`æ¥ç¶šã•ã‚Œ$ã‚‹
ï¼ˆã‹ã¤ï¼Œãã‚Œã¾ã§ã¯ %S ã® `crossorigin$a å±æ€§ã®å€¤ã¯å¤‰æ›´ã•ã‚Œãªã„ï¼‰
ã¾ã§å¾…ã¤ã“ã¨ãªãã€‚
ã„ãšã‚Œã«ã›ã‚ˆï¼Œ
%S ãŒ`æ¥ç¶šã•ã‚Œ$ãŸãªã‚‰ã€
ã“ã®æ®µã«è¿°ã¹ãŸã¨ãŠã‚Šã«ï¼Œèª­è¾¼nã‚’é–‹å§‹ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
may start fetching the classic script or module graph (as defined above) as soon as the src attribute is set, instead, in the hope that el will become connected (and that the crossorigin attribute won't change value in the meantime). Either way, once el becomes connected, the load must have started as described in this step.ï¼¼
</li>
					<li>
<p>
å‰é …ã®ã‚ˆã†ãªäº‹å‰~fetchingã‚’é‚è¡Œã™ã‚‹ä¸‹ã§ï¼Œæ¬¡ã®ã„ãšã‚Œã‹ã«è©²å½“ã™ã‚‹å ´åˆâ€¦ï¼š
</p>
						<ul>
							<li>
%S ã¯ã€
~~å®Ÿéš›ã«ã¯ï¼Œ`æ¥ç¶šã•ã‚Œ$ãªã‹ã£ãŸ
</li>
							<li>
%S ã¯æ–‡æ›¸~å†…ã«æŒ¿å…¥ã•ã‚ŒãŸãŒã€
ãã‚Œã¾ã§ã« %S ã®ï¼»
`src$a ï¼ `crossorigin$a
ï¼½å±æ€§ãŒå‹•çš„ã«å¤‰æ›´ã•ã‚ŒãŸ
</li>
						</ul>
<p>
â€¦å ´åˆã€
ãã®ã‚ˆã†ã«å¾—ã•ã‚ŒãŸ~scriptã¯å®Ÿè¡Œã—ãªã„ã¨ã™ã‚‹
â€” ~fetchingã¯ã€
å®Ÿè³ªçš„ã«æµªè²»ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
</p>
â—
If the UA performs such prefetching, but el never becomes connected, or the src attribute is dynamically changed, or the crossorigin attribute is dynamically changed, then the user agent will not execute the script so obtained, and the fetching process will have been effectively wasted.
</li>
				</ul>
			</li>
		</ol>
   </li>
	<li id="establish-script-block-source">
<p>
~ELSE ï¼ˆ %src ~EQ Îµ ï¼‰ï¼š
â—
If el does not have a src content attribute:
</p>
		<ol>
			<li>
%åŸºåº•~URL ~LET %æ–‡æ›¸ ã®`æ–‡æ›¸~åŸºåº•~URL$
â—
Let base URL be el's node document's document base URL.
</li>
			<li>
<p>
%ç¨®åˆ¥ ã«å¿œã˜ã¦ï¼š
â—
Switch on el's type:
</p>
				<ul class="switch">
					<li>
<p>
`classic^lï¼š
â—
"classic"
</p>
						<ol>
							<li>
%~script ~LET `å¤å…¸~scriptã‚’ä½œæˆã™ã‚‹$( â†“ )
â‡’ï¼ƒ
%~source~text,
%è¨­å®šç¾¤~obj,
%åŸºåº•~URL,
%~optionç¾¤
â—
Let script be the result of creating a classic script using source text, settings object, base URL, and options.
</li>
							<li>
`~scriptè¦ç´ ã‚’æº–å‚™æ¸ˆã¿ã«ã™ã‚‹$( %S, %~script )
â—
Mark as ready el given script.
</li>
						</ol>
					</li>
					<li>
<p>
`module^lï¼š
â—
"module"
</p>
						<ol>
							<li>
%S ã®`~load~eventã‚’é…å»¶ã—ã¦ã„ã‚‹ã‹$scE ~SET ~T
â—
Set el's delaying the load event to true.
</li>
							<li>
<p>
~IFï¼»
%S ã«ã¯`å…·ç¾åŒ–ã‚’é˜»ã‚€èƒ½æ€§$ãŒã‚ã‚‹
ï¼½ï¼š
â—
If el is potentially render-blocking, then:
</p>
								<ol>
									<li>
`å…·ç¾åŒ–ã‚’é˜»ã‚€$( %S )
â—
Block rendering on el.
</li>
									<li>
%~optionç¾¤ ã®`å…·ç¾åŒ–ã‚’é˜»ã‚“ã§ã„ã‚‹ã‹$sfO ~SET ~T
â—
Set options's render-blocking to true.
</li>
								</ol>
							</li>
							<li>
<p>
`~inline~module~script~graphã‚’~fetchã™ã‚‹$( â†“ )
â‡’ï¼ƒ
%~source~text,
%åŸºåº•~URL,
%è¨­å®šç¾¤~obj,
%~optionç¾¤,
æ¬¡ã®æ‰‹ç¶šã
â—
Fetch an inline module script graph, given source text, base URL, settings object, options, and withï¼¼
</p>

<div class="algo">
<p>
æ‰‹ç¶šãã¯ã€
æ‰€ä¸ã®
( %çµæœ )
ã«å¯¾ã—
â‡’
`è¦ç´ ~taskã‚’~queueã™ã‚‹$( `~networkç”¨~task~source$, %S, æ¬¡ã®æ‰‹ç¶šã )
â—
the following steps given result:
â€¢ Queue an element task on the networking task source given el to performï¼¼
</p>

<div class="algo">
æ‰‹ç¶šãã¯
â‡’
`~scriptè¦ç´ ã‚’æº–å‚™æ¸ˆã¿ã«ã™ã‚‹$( %S, %çµæœ )
â—
the following steps:
â€¢ Mark as ready el given result.
</div>

<p class="note">æ³¨è¨˜ï¼š
ã“ã“ã§~taskã‚’~queueã™ã‚‹ã“ã¨ã¯ã€
å½“ã®~inlineãª~module~scriptã¯ï¼»
ä¾å­˜ç‰©ãŒç„¡ã„ï¼
ãã®çµæœãŒåŒæœŸçš„ã«æ§‹æ–‡è§£æ-~errorã«ãªã‚‹
ï¼½å ´åˆã§ã‚‚ï¼Œ
`~scriptè¦ç´ ã‚’å®Ÿè¡Œã™ã‚‹$æ‰‹ç¶šãã‚’åŒæœŸçš„ã«ç¶šè¡Œã—ãªã„ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
â—
Queueing a task here means that, even if the inline module script has no dependencies or synchronously results in a parse error, we won't proceed to execute the script element synchronously.
</p>
</div>
							</li>
						</ol>
					</li>
					<li>
<p>
`importmap^lï¼š
â—
"module"
</p>
						<ol>
							<li>
%çµæœ ~LET `~import~mapæ§‹æ–‡è§£æ-çµæœã‚’ä½œæˆã™ã‚‹$( %~source~text, %åŸºåº•~URL )
â—
Let result be the result of creating an import map parse result given source text and base URL.
</li>
							<li>
`~scriptè¦ç´ ã‚’æº–å‚™æ¸ˆã¿ã«ã™ã‚‹$( %S, %çµæœ )
â—
Mark as ready el given result.
</li>
						</ol>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»ï¼»
%ç¨®åˆ¥ ~EQ `classic^l
ï¼½~ANDï¼»
%src ~NEQ Îµ
ï¼½ï¼½~ORï¼»
%ç¨®åˆ¥ ~EQ `module^l
ï¼½ï¼š
â—
If el's type is "classic" and el has a src attribute, or el's type is "module":
</p>
		<ol>
			<li>
~Assertï¼š
%S ã®`çµæœ$scE ~EQ `æœªåˆæœŸåŒ–^i
â—
Assert: el's result is "uninitialized".
</li>
			<li id="script-processing-src">
<p id="script-processing-module-async">
~IFï¼»
%S ã¯ `async$a å±æ€§ã‚’æœ‰ã™ã‚‹
ï¼½~ORï¼»
%S ã®`éåŒæœŸcã‚’å¼·åˆ¶ã™ã‚‹ã‹$scE ~EQ ~T
ï¼½ï¼š
â—
If el has an async attribute or el's force async is true:
</p>
				<ol>
					<li>
%~scriptç¾¤ ~LET %S ã®`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸$scEã®`ã‚¢ãƒªãªé™ã‚Šã™ãã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptãŸã¡ãŒæˆã™é›†åˆ$
â—
Let scripts be el's preparation-time document's set of scripts that will execute as soon as possible.
</li>
					<li>
%~scriptç¾¤ ã« %S ã‚’`ä»˜åŠ ã™ã‚‹$set
â—
Append el to scripts.
</li>
					<li class="algo">
<p>
%S ã®`çµæœã¯æº–å‚™æ¸ˆã¿æ™‚ã®æ‰‹ç¶šã$scE ~SET æ¬¡ã‚’èµ°ã‚‰ã™æ‰‹ç¶šãï¼š
â—
Set el's steps to run when the result is ready to the following:
</p>
						<ol>
							<li>
`~scriptè¦ç´ ã‚’å®Ÿè¡Œã™ã‚‹$( %S )
â—
Execute the script element el.
</li>
							<li>
%~scriptç¾¤ ã‹ã‚‰ %S ã‚’`é™¤å»ã™ã‚‹$
â—
Remove el from scripts.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li id="script-processing-src-sync">
<p id="script-processing-module-noasync">
~ELIFï¼»
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~EQ ~NULL
ï¼½ï¼š
â—
Otherwise, if el is not parser-inserted:
</p>
				<ol>
					<li>
%~scriptç¾¤ ~LET %S ã®`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸$scEã®`ã‚¢ãƒªãªé™ã‚Šã™ãã«é †ã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptãŸã¡ãŒæˆã™~list$
â—
Let scripts be el's preparation-time document's list of scripts that will execute in order as soon as possible.
</li>
					<li>
%~scriptç¾¤ ã« %S ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Append el to scripts.
</li>
					<li class="algo">
<p>
%S ã®`çµæœã¯æº–å‚™æ¸ˆã¿æ™‚ã®æ‰‹ç¶šã$scE ~SET æ¬¡ã‚’èµ°ã‚‰ã™æ‰‹ç¶šãï¼š
â—
Set el's steps to run when the result is ready to the following:
</p>
						<ol>
							<li>
~IFï¼»
%~scriptç¾¤[ 0 ] ~NEQ %S
ï¼½
â‡’
~RET
â—
If scripts[0] is not el, then abort these steps.
</li>
							<li>
<p>
~WHILEï¼»
%~scriptç¾¤ ã¯ç©ºã§ãªã„
ï¼½~ANDï¼»
%~scriptç¾¤[ 0 ] ã®`çµæœ$scE ~NEQ `æœªåˆæœŸåŒ–^i
ï¼½ï¼š
â—
While scripts is not empty, and scripts[0]'s result is not "uninitialized":
</p>
								<ol>
									<li>
`~scriptè¦ç´ ã‚’å®Ÿè¡Œã™ã‚‹$( %~scriptç¾¤[ 0 ] )
â—
Execute the script element scripts[0].
</li>
									<li>
%~scriptç¾¤ ã‹ã‚‰ %~scriptç¾¤[ 0 ] ã‚’`é™¤å»ã™ã‚‹$
â—
Remove scripts[0].
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li id="script-processing-defer">
<p id="script-processing-module-noasync-parser-inserted">
~ELIFï¼»
%S ã¯ `defer$a å±æ€§ã‚’æœ‰ã™ã‚‹
ï¼½~ORï¼»
%ç¨®åˆ¥ ~EQ `module^l
ï¼½ï¼š
â—
Otherwise, if el has a defer attribute or el's type is "module":
</p>
				<ol>
					<li>
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ã®`æ–‡æ›¸ã®æ§‹æ–‡è§£æã‚’å®Œé‚ã—ãŸã¨ãå®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹~scriptãŸã¡ãŒæˆã™~list$ã« %S ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Append el to its parser document's list of scripts that will execute when the document has finished parsing.
</li>
					<li class="algo">
%S ã®`çµæœã¯æº–å‚™æ¸ˆã¿æ™‚ã®æ‰‹ç¶šã$scE ~SET æ¬¡ã‚’èµ°ã‚‰ã™æ‰‹ç¶šã
â‡’
%S ã®`æ§‹æ–‡è§£æå™¨ã«ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã«æº–å‚™æ¸ˆã¿ã‹$scE ~SET ~T
ï¼ˆå½“ã®æ§‹æ–‡è§£æå™¨ãŒï¼Œã“ã®~scriptã®å®Ÿè¡Œngã‚’å–æ‰±ã†ã“ã¨ã«ãªã‚‹ã€‚ï¼‰
â—
Set el's steps to run when the result is ready to the following: set el's ready to be parser-executed to true. (The parser will handle executing the script.)
</li>
				</ol>
			</li>
			<li id="script-processing-parser-inserted">
<p>
~ELSEï¼š
â—
Otherwise:
</p>
				<ol>
					<li>
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ã®`æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹~script$ ~SET %S
â—
Set el's parser document's pending parsing-blocking script to el.
</li>
					<li>
`å…·ç¾åŒ–ã‚’é˜»ã‚€$( %S )
â—
Block rendering on el.
</li>
					<li class="algo">
%S ã®`çµæœã¯æº–å‚™æ¸ˆã¿æ™‚ã®æ‰‹ç¶šã$scE ~SET æ¬¡ã‚’èµ°ã‚‰ã™æ‰‹ç¶šã
â‡’
%S ã®`æ§‹æ–‡è§£æå™¨ã«ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã«æº–å‚™æ¸ˆã¿ã‹$scE ~SET ~T
ï¼ˆå½“ã®æ§‹æ–‡è§£æå™¨ãŒï¼Œã“ã®~scriptã®å®Ÿè¡Œngã‚’å–æ‰±ã†ã“ã¨ã«ãªã‚‹ã€‚ï¼‰
â—
Set el's steps to run when the result is ready to the following: set el's ready to be parser-executed to true. (The parser will handle executing the script.)
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSEï¼š
â—
Otherwise:
</p>
		<ol>
			<li>
~Assertï¼š
%S ã®`çµæœ$scE ~NEQ `æœªåˆæœŸåŒ–^i
â—
Assert: el's result is not "uninitialized".
</li>
			<li id="script-processing-style-delayed">
<p>
~IFï¼»
~ANDâ†“
ï¼½â€¦
â—
If all of the following are true:
</p>
				<ul>
					<li>
%S ã®`ç¨®åˆ¥$scE ~EQ `classic^l
â—
el's type is "classic";
</li>
					<li>
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~NEQ ~NULL
â—
el is parser-inserted;
</li>
					<li>
`~scriptã‚’é˜»ã‚“ã§ã„ã‚‹~stylesheetã¯åœ¨ã‚‹ã‹ï¼Ÿ$( %æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ) ~EQ ~T
â—
el's parser document has a style sheet that is blocking scripts; and
</li>
					<li>
<p>
%S ã‚’ä½œæˆã—ãŸæ§‹æ–‡è§£æå™¨ã¯ ~ORâ†“ ã‚’æº€ãŸã™ï¼š
</p>
						<ul>
							<li>
`~XMLæ§‹æ–‡è§£æå™¨$ã§ã‚ã‚‹
</li>
							<li>
ï¼»
`~HTMLæ§‹æ–‡è§£æå™¨$ã§ã‚ã‚‹
ï¼½~ANDï¼»
ãã®`~scriptå…¥å­ng~level$ ~LTE 1
ï¼½
</li>
						</ul>
â—
either the parser that created el is an XML parser, or it's an HTML parser whose script nesting level is not greater than one,
</li>
				</ul>
<p>
â€¦ãªã‚‰ã°ï¼š
â—
then:
</p>
				<ol>
					<li>
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ã®`æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹~script$ ~SET %S
â—
Set el's parser document's pending parsing-blocking script to el.
</li>
					<li>
%S ã®`æ§‹æ–‡è§£æå™¨ã«ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã«æº–å‚™æ¸ˆã¿ã‹$scE ~SET ~T
ï¼ˆå½“ã®æ§‹æ–‡è§£æå™¨ãŒï¼Œã“ã®~scriptã®å®Ÿè¡Œngã‚’å–æ‰±ã†ã“ã¨ã«ãªã‚‹ã€‚ï¼‰
â—
Set el's ready to be parser-executed to true. (The parser will handle executing the script.)
</li>
				</ol>
			</li>
			<li id="script-processing-inline">
~ELSE
â‡’
`~scriptè¦ç´ ã‚’å®Ÿè¡Œã™ã‚‹$( %S )
â€” ä»–ã®~scriptãŒã™ã§ã«å®Ÿè¡Œ-ä¸­ã«ã‚ã£ã¦ã‚‚ï¼Œ`å³æ™‚$ã«
â—
Otherwise, immediately execute the script element el, even if other scripts are already executing.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
å„ `æ–‡æ›¸$ã«ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
â†“</p>

<dl class="def-list">
	<dt>
`æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹~script@
â—
Each Document has a pending parsing-blocking script,ï¼¼
</dt>
	<dd>
`script$e è¦ç´  ï¼ ~NULL
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
which is a script element or null, initially null.
â—
</dd>

	<dt>
`ã‚¢ãƒªãªé™ã‚Šã™ãã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptãŸã¡ãŒæˆã™é›†åˆ@
â—
Each Document has a set of scripts that will execute as soon as possible,ï¼¼
</dt>
	<dd>
`script$e è¦ç´ ãŸã¡ãŒæˆã™`æœ‰é †åº~é›†åˆ$
â€” åˆæœŸ~æ™‚ã¯ç©ºã¨ã™ã‚‹ã€‚
â—
which is a set of script elements, initially empty.
â—
</dd>

	<dt>
`ã‚¢ãƒªãªé™ã‚Šã™ãã«é †ã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptãŸã¡ãŒæˆã™~list@
â—
Each Document has a list of scripts that will execute in order as soon as possible,ï¼¼
</dt>
	<dd>
`script$e è¦ç´ ãŸã¡ãŒæˆã™`~list$
â€” åˆæœŸ~æ™‚ã¯ç©ºã¨ã™ã‚‹ã€‚
â—
which is a list of script elements, initially empty.
</dd>

	<dt>
`æ–‡æ›¸ã®æ§‹æ–‡è§£æã‚’å®Œé‚ã—ãŸã¨ãå®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹~scriptãŸã¡ãŒæˆã™~list@
â—
Each Document has a list of scripts that will execute when the document has finished parsing,ï¼¼
</dt>
	<dd>
`script$e è¦ç´ ãŸã¡ãŒæˆã™`~list$
â€” åˆæœŸ~æ™‚ã¯ç©ºã¨ã™ã‚‹ã€‚
â—
which is a list of script elements, initially empty.
â—
</dd>
</dl>

<p class="note">æ³¨è¨˜ï¼š
ã‚ã‚‹æ§‹æ–‡è§£æå™¨ %æ§‹æ–‡è§£æå™¨ ã‚’é˜»ã‚“ã§ã„ã‚‹ `script$e è¦ç´  %~script ãŒï¼»
é€šå¸¸ã« %æ§‹æ–‡è§£æå™¨ ã‚’é˜»ã¾ãªããªã‚‹
ï¼½å‰ã«åˆ¥ã®`æ–‡æ›¸$ã¸ç§»å‹•ã•ã‚ŒãŸå ´åˆã§ã‚‚ã€ï¼»
%æ§‹æ–‡è§£æå™¨ ã‚’é˜»ã‚“ã§ã„ã‚‹æ¡ä»¶ãŒï¼Œãã‚Œä»¥ä¸Š~é©ç”¨ã•ã‚Œãªããªã‚‹
ï¼½ã¾ã§ï¼Œ %æ§‹æ–‡è§£æå™¨ ã‚’é˜»ã¿ç¶šã‘ã‚‹
ï¼ˆä¾‹ï¼š
%~script ãŒï¼Œæ§‹æ–‡è§£æ-æ™‚ã«ã¯ï¼»
å…ƒã®`æ–‡æ›¸$ã«`~scriptã‚’é˜»ã‚“ã§ã„ã‚‹~stylesheetãŒåœ¨ã‚‹ï¼ ~HEmetadata#has-a-style-sheet-that-is-blocking-scripts$
ï¼½ã“ã¨ã«ã‚ˆã‚Š
`æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹~script$ã§ã‚ã£ãŸå ´åˆã€ï¼»
é˜»ã‚“ã§ã„ã‚‹~stylesheetãŸã¡ãŒèª­è¾¼ã¾ã‚Œã‚‹å‰ã«ï¼Œ
%~script ãŒåˆ¥ã®`æ–‡æ›¸$ã¸ç§»å‹•ã•ã‚ŒãŸ
ï¼½ã¨ã—ã¦ã‚‚ï¼Œ
%~script ã¯ï¼»
ãã‚Œã‚‰ã®~stylesheetã™ã¹ã¦ãŒèª­è¾¼ã¾ã‚Œã‚‹
ï¼½ã¾ã§ %æ§‹æ–‡è§£æå™¨ ã‚’é˜»ã‚€
â€” ãã®æ™‚ç‚¹ã§ã€
%~script ã¯å®Ÿè¡Œã•ã‚Œï¼Œ %æ§‹æ–‡è§£æå™¨ ã‚’é˜»ã¾ãªããªã‚‹ï¼‰ã€‚
â—
If a script element that blocks a parser gets moved to another Document before it would normally have stopped blocking that parser, it nonetheless continues blocking that parser until the condition that causes it to be blocking the parser no longer applies (e.g., if the script is a pending parsing-blocking script because the original Document has a style sheet that is blocking scripts when it was parsed, but then the script is moved to another Document before the blocking style sheet(s) loaded, the script still blocks the parser until the style sheets are all loaded, at which time the script executes and the parser is unblocked).
</p>

<div class="algo">
<p>
`~scriptè¦ç´ ã‚’å®Ÿè¡Œã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `script$e è¦ç´  %S )
ã«å¯¾ã—ï¼š
â—
To execute the script element given a script element el:
</p>
<ol>
	<li>
%æ–‡æ›¸ ~LET %S ã®`~nodeæ–‡æ›¸$
â—
Let document be el's node document.
</li>
	<li>
~IFï¼»
%S ã®`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸$scE ~NEQ %æ–‡æ›¸
ï¼½
â‡’
~RET
â—
If el's preparation-time document is not equal to document, then return.
</li>
	<li>
`å…·ç¾åŒ–ã‚’é˜»ã¾ãªãã™ã‚‹$( %S )
â—
Unblock rendering on el.
</li>
	<li>
~IFï¼»
%S ã®`çµæœ$scE ~EQ ~NULL
ï¼½
â‡’
`~eventã‚’ç™ºç«ã™ã‚‹$( %S, `error$et )ï¼›
~RET
â—
If el's result is null, then fire an event named error at el, and return.
</li>
	<li>
%~counterã‚’å¢—æ¸›ã™ã‚‹ã‹ ~LET ~ISï¼»
%S ã®`å¤–éƒ¨~fileã‹$scE ~EQ ~T
ï¼½~ORï¼»
%ç¨®åˆ¥ ~EQ `module^l
ï¼½
â—
â†“</li>
	<li>
~IFï¼»
%~counterã‚’å¢—æ¸›ã™ã‚‹ã‹
ï¼½
â‡’
%æ–‡æ›¸ ã®`ç ´å£Šçš„ãªæ›¸è¾¼nã¯ç„¡è¦–ã™ã‚‹~counter$ ~INCBY 1
â—
If el's from an external file is true, or el's type is "module", then increment document's ignore-destructive-writes counter.
</li>
	<li>
<p>
%ç¨®åˆ¥ ã«å¿œã˜ã¦ï¼š
â—
Switch on el's type:
</p>
		<ul class="switch">
			<li>
<p>
`classic^lï¼š
â—
"classic"
</p>
				<ol>
					<li>
%æ—§-~scriptè¦ç´  ~LET %æ–‡æ›¸ ã® `currentScript$m å±æ€§ã®å€¤
ã€ï¼object was most recently setã€‘
â—
Let oldCurrentScript be the value to which document's currentScript object was most recently set.
</li>
					<li>
<p>
%æ–‡æ›¸ ã®`currentScript$m å±æ€§ ~SET ï¼»
%S ã®`æ ¹$ã¯`~shadowæ ¹$ã§ãªã„ãªã‚‰ã° %S ï¼
~ELSE_ ~NULL
ï¼½
â—
If el's root is not a shadow root, then set document's currentScript attribute to el. Otherwise, set it to null.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã“ã§ã¯ã€
%S ãŒ`æ–‡æ›¸~treeå†…$ã«ã‚ã‚‹ã‹ã©ã†ã‹ã¯æ¤œæŸ»ã—ãªã„
â€” `script$e è¦ç´ ã¯ï¼Œå®Ÿè¡Œã«å…ˆç«‹ã£ã¦æ–‡æ›¸ã‹ã‚‰é™¤å»ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã€
ãã®å±€é¢ã§ã‚‚ä¾ç„¶ã¨ã—ã¦ï¼Œ `currentScript$m ã¯ ãã‚Œã‚’æŒ‡ã™å¿…è¦ãŒã‚ã‚‹ã®ã§ã€‚
â—
This does not use the in a document tree check, as el could have been removed from the document prior to execution, and in that scenario currentScript still needs to point to it.
</p>
					</li>
					<li>
`å¤å…¸~scriptã‚’èµ°ã‚‰ã™$( %S ã®`çµæœ$scE )
â—
Run the classic script given by el's result.
</li>
					<li>
%æ–‡æ›¸ ã®`currentScript$m å±æ€§ ~SET %æ—§-~scriptè¦ç´ 
â—
Set document's currentScript attribute to oldCurrentScript.
</li>
					<li>
<p>
`module^lï¼š
â—
"module"
</p>
						<ol>
							<li>
~Assert:
%æ–‡æ›¸ ã®`currentScript$m å±æ€§ ~EQ ~NULL
â—
Assert: document's currentScript attribute is null.
</li>
							<li>
`~module~scriptã‚’èµ°ã‚‰ã™$( %S ã®`çµæœ$scE )
â—
Run the module script given by el's result.
</li>
						</ol>
					</li>
					<li>
`importmap^l
â‡’
`~import~mapã‚’ç™»éŒ²ã™ã‚‹$( %S ã«`é–¢é€£ãªå¤§åŸŸ~obj$, %S ã®`çµæœ$scE )
â—
"importmap"
â€¢ Register an import map given el's relevant global object and el's result.
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
~IFï¼»
%~counterã‚’å¢—æ¸›ã™ã‚‹ã‹ ~EQ ~T
ï¼½
â‡’
%æ–‡æ›¸ ã®`ç ´å£Šçš„ãªæ›¸è¾¼nã¯ç„¡è¦–ã™ã‚‹~counter$ ~DECBY 1
â—
Decrement the ignore-destructive-writes counter of document, if it was incremented in the earlier step.
</li>
	<li>
~IFï¼»
%S ã®`å¤–éƒ¨~fileã‹$scE ~EQ ~T
ï¼½
â‡’
`~eventã‚’ç™ºç«ã™ã‚‹$( %S, `load$et )
â—
If el's from an external file is true, then fire an event named load at el.
</li>
</ol>
</div>

			</section>
			<section id="scriptingLanguages">
<h5 title="Scripting languages">4.12.1.2. ~scriptingè¨€èª</h5>

<p>
~UAã«ã¯ã€
~JSã‚’~supportã™ã‚‹ã“ã¨ã¯è¦æ±‚ã•ã‚Œãªã„ã€‚
ã“ã®æ¨™æº–ã¯ã€
~JSä»¥å¤–ã®è¨€èªãŒ~JSåŒæ§˜ã«~web~browserã«åºƒãæ¡ç”¨ã•ã‚ŒãŸãªã‚‰ã°ï¼Œ
æ›´æ–°ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
~JSä»¥å¤–ã®è¨€èªã‚’å®Ÿè£…ã™ã‚‹ã®ã¯ã€
ãã®ã¨ããŒæ¥ãªã„é™ã‚Šï¼Œ
ã“ã®æ¨™æº–ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ `script$e è¦ç´ ~ç”¨ã®å‡¦ç†~modelã¨ç«¶åˆã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
User agents are not required to support JavaScript. This standard needs to be updated if a language other than JavaScript comes along and gets similar wide adoption by web browsers. Until such a time, implementing other languages is in conflict with this standard, given the processing model defined for the script element.
</p>

<div class="p">
<p>
~serverã¯ã€
~JSè³‡æºã«å¯¾ã—ã¦ã¯ï¼š
</p>
<ul>
	<li>
ï¼»
`Updates to ECMAScript Media Types^cite
ï¼ˆ~JS~MIMEå‹ã«å¯¾ã™ã‚‹æ›´æ–°ï¼‰
`RFC9239$r
ï¼½ã«å‰‡ã£ã¦ï¼Œ
`text/javascript$c ã‚’åˆ©ç”¨ã™ã‚‹ã¹ãã§ã‚ã‚‹
â€” ä»–ã®`~JS~MIMEå‹$ã¯åˆ©ç”¨ã™ã‚‹ã¹ãã§ãªã„ã€‚
</li>
	<li>
é`~JS~MIMEå‹$ã‚’åˆ©ç”¨ã—ã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ã€‚
</li>
</ul>
â—
Servers should use text/javascript for JavaScript resources, in accordance with Updates to ECMAScript Media Types. Servers should not use other JavaScript MIME types for JavaScript resources, and must not use non-JavaScript MIME types. [RFC9239]
</div>

<p>
å¤–éƒ¨~JSè³‡æºã«å¯¾ã—ã¦ã¯ã€
ãã® `~Content-Type~header$å†…ã®~MIMEå‹~parameterã¯ï¼Œä¸€èˆ¬ã«ç„¡è¦–ã•ã‚Œã‚‹
ï¼ˆ `charset^c ~parameterã«ã¤ã„ã¦ã¯ã€åŠ¹æœãŒã‚ã‚‹äº‹ä¾‹ã‚‚ã‚ã‚‹ï¼‰ã€‚
ä¸€æ–¹ã§ï¼Œ `script$e è¦ç´ ã® `type$a å±æ€§~å†…ã®ãã‚Œã¯ã€
æœ‰æ„ã«ãªã‚‹
â€” `~JS~MIMEå‹ã«~essenceåˆè‡´-$ã®æ¦‚å¿µã‚’åˆ©ç”¨ã™ã‚‹ã®ã§ã€‚
â—
For external JavaScript resources, MIME type parameters in `Content-Type` headers are generally ignored. (In some cases the `charset` parameter has an effect.) However, for the script element's type attribute they are significant; it uses the JavaScript MIME type essence match concept.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä¾‹ãˆã°ã€
`type$a å±æ€§ãŒ `text/javascript; charset=utf-8^l ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹~scriptã¯ï¼Œ
è©•ä¾¡ã•ã‚Œãªã„ã“ã¨ã«ãªã‚‹
â€” æ§‹æ–‡è§£æ-æ™‚ã«ã¯å¦¥å½“ãª`~JS~MIMEå‹$ã§ã‚ã£ãŸã¨ã—ã¦ã‚‚ã€‚
â—
For example, scripts with their type attribute set to "text/javascript; charset=utf-8" will not be evaluated, even though that is a valid JavaScript MIME type when parsed.
</p>

<p>
å¤–éƒ¨~JSè³‡æºã«å¯¾ã—ã¦ã¯ã€
ãã®`~Content-Type~header$ã®å‡¦ç†~å‘¨ã‚Šã«ã‚‚ï¼Œç‰¹åˆ¥ãªè€ƒæ…®ç‚¹ãŒé©ç”¨ã•ã‚Œã‚‹
â€” è©³ç´°ã¯ã€
`~scriptè¦ç´ ã‚’æº–å‚™ã™ã‚‹$~algo, ãŠã‚ˆã³
`Fetch^cite `FETCH$r
ã‚’è¦‹ã‚ˆã€‚
â—
Furthermore, again for external JavaScript resources, special considerations apply around `Content-Type` header processing as detailed in the prepare the script element algorithm and Fetch. [FETCH] 
</p>

			</section>
			<section id="restrictions-for-contents-of-script-elements">
<h5 title="Restrictions for contents of script elements">4.12.1.3. `script^e è¦ç´ ã®å†…å®¹ã«èª²ã•ã‚Œã‚‹åˆ¶ç´„</h5>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®ç¯€ã«è¿°ã¹ã‚‹å¤‰å‰‡çš„ãªåˆ¶ç´„ã‚’é¿ã‘ã‚‹æœ€ã‚‚å®¹æ˜“ã‹ã¤å®‰å…¨ãªä»•æ–¹ã¯ã€
~scriptå†…ã«ï¼ˆä¾‹ãˆã° æ–‡å­—åˆ—, æ­£è¦è¡¨ç¾, ~comment ã¨ã—ã¦ï¼‰~literalã§ç¾ã‚Œã‚‹ã‚‚ã®ã®ã†ã¡ï¼»
`&lt;!--^l ï¼ `&lt;script^l ï¼ `&lt;/script^l
ï¼½ã«~ASCIIå¤§å°ç„¡è¦–ã§åˆè‡´ã™ã‚‹ã‚‚ã®ã¯ï¼Œå¸¸ã«ï¼»
`\x3C!--^l ï¼ `\x3Cscript^l ï¼ `\x3C/script^l
ï¼½ã«~escapeã—ã¦ã€
å¼ã®ä¸­ã§ãã®ã‚ˆã†ãªæ§‹æˆå­ã‚’åˆ©ç”¨ã™ã‚‹ã‚ˆã†ãª~codeã‚’æ›¸ãã®ã¯ï¼Œé¿ã‘ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã“ã®ç¯€ã«ãŠã‘ã‚‹åˆ¶ç´„ã¯ï¼Œã¡ã‚‡ã£ã¨ã—ãŸã“ã¨ã§æŠµè§¦ã—æ˜“ãã€
ãã†ã™ã‚‹ã“ã¨ã§ï¼Œé™¥ç©½ã¯é¿ã‘ã‚‰ã‚Œã‚‹ã€‚
ã™ãªã‚ã¡ï¼Œ~HTMLå†…ã® `script$e ~blockã®æ§‹æ–‡è§£æã¯ã€
æ­´å²çš„ãªç†ç”±ã‹ã‚‰ï¼Œï¼»
ã“ã‚Œã‚‰ã®æ–‡å­—~ä¸¦ã³ã«é¢ã—ãŸéš›ã®ãµã‚‹ã¾ã„ãŒç›´æ„Ÿã«åã™ã‚‹
ï¼½ã‚ˆã†ãªï¼»
å¤‰å‰‡çš„ã§é¢¨å¤‰ã‚ã‚Šãªå®Ÿæ–½
ï¼½ã«ãªã£ã¦ã„ã‚‹ã€‚
â—
The easiest and safest way to avoid the rather strange restrictions described in this section is to always escape an ASCII case-insensitive match for "&lt;!--" as "\x3C!--", "&lt;script" as "\x3Cscript", and "&lt;/script" as "\x3C/script" when these sequences appear in literals in scripts (e.g. in strings, regular expressions, or comments), and to avoid writing code that uses such constructs in expressions. Doing so avoids the pitfalls that the restrictions in this section are prone to triggering: namely, that, for historical reasons, parsing of script blocks in HTML is a strange and exotic practice that acts unintuitively in the face of these sequences.
</p>

<p>
`script$e è¦ç´ ã®`å­å­«~textå†…å®¹$ã¯ã€
æ¬¡ã®~ABNFã§ä¸ãˆã‚‰ã‚Œã‚‹ `script^P ç”Ÿæˆè¦å‰‡ã«åˆè‡´ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤
â€” ã“ã® ABNF ã®æ–‡å­—~é›†åˆã¯~Unicodeã¨ã™ã‚‹ `ABNF$rï¼š
â—
The script element's descendant text content must match the script production in the following ABNF, the character set for which is Unicode. [ABNF]
</p>

<!-- 
any string that doesn't contain a substring that matches
	not-in-outer|not-in-inner
-->

<pre class="bnf">
script
	= outer *( comment-open inner comment-close outer )

outer
	= &lt; not-in-outer ã«åˆè‡´ã™ã‚‹æ–‡å­—åˆ—ã¯å«ã¾ãªã„ä»»æ„ã®æ–‡å­—åˆ— &gt;
not-in-outer
	= comment-open
inner
	= &lt; not-in-inner ã«åˆè‡´ã™ã‚‹æ–‡å­—åˆ—ã¯å«ã¾ãªã„ä»»æ„ã®æ–‡å­—åˆ— &gt;
not-in-inner
	= comment-close
	/ script-open

comment-open
	= "&lt;!--"
comment-close
	= "--&gt;"
script-open
	= "&lt;" s c r i p t tag-end

s
	= `0053^0x ; U+0053 LATIN CAPITAL LETTER S
	/ `0073^0x ; U+0073 LATIN SMALL LETTER S
c
	= `0043^0x ; U+0043 LATIN CAPITAL LETTER C
	/ `0063^0x ; U+0063 LATIN SMALL LETTER C
r
	= `0052^0x ; U+0052 LATIN CAPITAL LETTER R
	/ `0072^0x ; U+0072 LATIN SMALL LETTER R
i
	= `0049^0x ; U+0049 LATIN CAPITAL LETTER I
	/ `0069^0x ; U+0069 LATIN SMALL LETTER I
p
	= `0050^0x ; U+0050 LATIN CAPITAL LETTER P
	/ `0070^0x ; U+0070 LATIN SMALL LETTER P
t
	= `0054^0x ; U+0054 LATIN CAPITAL LETTER T
	/ `0074^0x ; U+0074 LATIN SMALL LETTER T

tag-end
	= `0009^0x ; U+0009 CHARACTER TABULATION (tab)
	/ `000A^0x ; U+000A LINE FEED (LF)
	/ `000C^0x ; U+000C FORM FEED (FF)
	/ `0020^0x ; U+0020 SPACE
	/ `002F^0x ; U+002F SOLIDUS (/)
	/ `003E^0x ; U+003E GREATER-THAN SIGN (&gt;)
</pre>

<p>
`script$e è¦ç´ ãŒ`~scriptæ–‡æ›¸åŒ–$ã‚’åŒ…å«ã™ã‚‹å ´åˆã€
è¦ç´ ã®å†…å®¹ã«ã‚‚ï¼Œä¸‹ã®ç¯€ã§è¿°ã¹ã‚‹åˆ¶ç´„ãŒæ›´ã«èª²ã•ã‚Œã‚‹ã€‚
â—
When a script element contains script documentation, there are further restrictions on the contents of the element, as described in the section below.
</p>

<div class="example">
<p>
ã“ã®~~å•é¡Œã‚’ï¼Œæ¬¡ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã‚’åŒ…å«ã—ã¦ã„ã‚‹~scriptã§~~èª¬æ˜ã™ã‚‹ï¼š
â—
The following script illustrates this issue. Suppose you have a script that contains a string, as in:
</p>

<pre class="lang-js">
const %example = 'Consider this string: &lt;!-- &lt;script&gt;';
console.log(%example);
</pre>

<p>
ä»®ã«ï¼Œã“ã®æ–‡å­—åˆ—ãŒ `script$e ~blockå†…ã«ç›´ã«è¨˜ã•ã‚ŒãŸå ´åˆã€
ä¸Šã®åˆ¶ç´„ã«é•åã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
If one were to put this string directly in a script block, it would violate the restrictions above:
</p>

<pre class="lang-html">
&lt;script&gt;
  const %example = 'Consider this string: &lt;!-- &lt;script&gt;';
  console.log(%example);
&lt;/script&gt;
</pre>

<p>
ã‚ˆã‚Šå¤§ããªå•é¡Œã§ã‚ã‚Šï¼Œãªãœãã‚ŒãŒåˆ¶ç´„ã«é•åã™ã‚‹ã“ã¨ã«ãªã‚‹ã‹ã®ç†ç”±ã¯ã€
ä¸Šã®~script~blockãŒï¼Œ`å®Ÿéš›ã«ã¯çµ‚äº†ã—ã¦ã„ãªã„^emã“ã¨ã«ã‚ã‚‹ã€‚
ã“ã®~scriptã«å¯¾ã™ã‚‹æ§‹æ–‡è§£æã•ã‚Œæ–¹ã¯~~ç†è§£ã—ãŒãŸã„ã‚‚ã®ã§ã‚ã‚Šï¼Œ
çµ‚äº†~tagã®æ§˜ã«è¦‹ãˆã‚‹ `&lt;/script&gt;^l ã¯ã€
å®Ÿéš›ã«ã¯ï¼Œä¾ç„¶ã¨ã—ã¦ `script$e ~blockã®ä¸€éƒ¨ã‚’æˆã™ã€‚
~scriptã¯ï¼ˆçµ‚ç«¯ã—ã¦ã„ãªã„ã®ã§ï¼‰å®Ÿè¡Œã•ã‚Œãªã„ãŒã€
ã©ã†ã«ã‹ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ãŸå ´åˆ
â€” ä¾‹ãˆã°ï¼Œ~markupãŒæ¬¡ã®ã‚ˆã†ã«ãªã£ã¦ã„ãŸå ´åˆ â€”
~scriptï¼ˆ<mark>å¼·èª¿è¡¨ç¤º</mark>ã•ã‚Œã¦ã„ã‚‹éƒ¨åˆ†ï¼‰ã¯ã€
å¦¥å½“ãª~JSã§ãªã„ã®ã§ï¼Œå¤±æ•—ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
The bigger problem, though, and the reason why it would violate those restrictions, is that actually the script would get parsed weirdly: the script block above is not terminated. That is, what looks like a "&lt;/script&gt;" end tag in this snippet is actually still part of the script block. The script doesn't execute (since it's not terminated); if it somehow were to execute, as it might if the markup looked as follows, it would fail because the script (highlighted here) is not valid JavaScript:
</p>

<pre class="lang-html">
&lt;script&gt;<mark>
  const %example = 'Consider this string: &lt;!-- &lt;script&gt;';
  console.log(%example);
&lt;/script&gt;
&lt;!-- è¦‹ã‹ã‘ã«åã—ã€å®Ÿéš›ã«ã¯ï¼Œã“ã“ã‚‚~scriptã®ä¸€éƒ¨ã«ãªã‚‹ã€‚ --&gt;
&lt;script&gt;
 ... // ã“ã“ã‚‚ã¾ã åŒã˜~script~blockå†…ã«ã‚ã‚‹...
</mark>&lt;/script&gt;
</pre>

<!-- 
  const example = 'Consider this string: ...';

despite appearances, this is actually part of the script still!

 ... // this is the same script block still...
 -->

<p>
ã“ã“ã§èµ·ãã¦ã„ã‚‹ã“ã¨ã¯ã€
æ—§æ¥ã®ç†ç”±ã‹ã‚‰ï¼Œ
`script$e è¦ç´ ~å†…ã®æ–‡å­—åˆ—ï¼»
`&lt;!--^l ï¼ `&lt;script^l
ï¼½ã‚’å¯¾ã«ã—ãªã‘ã‚Œã°ã€
~HTMLã®æ§‹æ–‡è§£æå™¨ã‹ã‚‰ã¯ï¼Œ~blockãŒé–‰ã˜ãŸã‚‚ã®ã¨è¦‹ãªã•ã‚Œãªããªã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
â—
What is going on here is that for legacy reasons, "&lt;!--" and "&lt;script" strings in script elements in HTML need to be balanced in order for the parser to consider closing the block.
</p>

<p>
ã“ã®ç¯€ã®å†’é ­ã§è¨€åŠã—ãŸã‚ˆã†ã«ã€
å•é¡Œã«ãªã‚Šå¾—ã‚‹æ–‡å­—åˆ—ã‚’~escapeã™ã‚Œã°ï¼Œã“ã®å•é¡Œã‚’ã¾ã‚‹ã”ã¨é¿ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
By escaping the problematic strings as mentioned at the top of this section, the problem is avoided entirely:
</p>

<pre class="lang-html">
&lt;script&gt;
  /* <span class="comment">
`\x3C^l ã¯ `&lt;^l ç”¨ã®~escapeåˆ—ã‚’ä¸ãˆã‚‹ã“ã¨ã«æ³¨æ„ã€‚
â—
Note: `\x3C` is an escape sequence for `&lt;`.
</span> */<mark>
  const %example = 'Consider this string: \x3C!-- \x3Cscript&gt;';
  console.log(%example);
</mark>&lt;/script&gt;
&lt;!-- ã“ã“ã¯å˜ã« 2 ã¤ã®~script~blockã®åˆé–“ã«ã‚ã‚‹~commentã«ãªã‚‹ --&gt;
&lt;script&gt;<mark>
 ... // æ–°ãŸãª~script~block
</mark>&lt;/script&gt;
</pre>
<!-- 
this is just a comment between script blocks
 -->
<p>
ã“ã‚Œã‚‰ã®æ–‡å­—~ä¸¦ã³ãŒ~scriptã®å¼ã®ä¸­ã«è‡ªç„¶ã«ç”Ÿã˜ã‚‹å¯èƒ½æ€§ã‚‚ã‚ã‚‹
â€” æ¬¡ã®ä¾‹ã®ã‚ˆã†ã«ï¼š
â—
It is possible for these sequences to naturally occur in script expressions, as in the following examples:
</p>

<pre class="lang-js">
if (x&lt;!--y) { ... }
if ( player&lt;script ) { ... }
</pre>

<p>
ã“ã®ã‚ˆã†ãªäº‹ä¾‹ã§ã¯ï¼Œæ–‡å­—ãŸã¡ã¯~escapeã§ããªã„ãŒã€
ã“ã®å¼ã¯ï¼Œãã®ã‚ˆã†ãªæ–‡å­—~ä¸¦ã³ãŒç”Ÿã˜ãªã„ã‚ˆã†ã«æ›¸ãç›´ã›ã‚‹ï¼š
â—
In such cases the characters cannot be escaped, but the expressions can be rewritten so that the sequences don't occur, as in:
</p>

<pre class="lang-js">
if (x &lt; !--y) { ... }
if (!--y &gt; x) { ... }
if (!(--y) &gt; x) { ... }
if (player &lt; script) { ... }
if (script &gt; player) { ... }
</pre>

<p>
ã“ã†ã™ã‚‹ã“ã¨ã§ï¼Œåˆ¥ã®é™¥ç©½
â€” æ­´å²çš„ãªç†ç”±ã‹ã‚‰ã€
`å¤å…¸~script$å†…ã®æ–‡å­—åˆ— `&lt;!--^l ã¯ï¼Œ
å®Ÿéš›ã«ã¯ï¼»
`//^l ã¨åŒã˜ãï¼Œ
è¡Œ~commentã®é–‹å§‹ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹
ï¼½ã“ã¨ â€”
ã‚‚é¿ã‘ã‚‰ã‚Œã‚‹ã€‚
â—
Doing this also avoids a different pitfall as well: for related historical reasons, the string "&lt;!--" in classic scripts is actually treated as a line comment start, just like "//".
</p>
</div>

			</section>
			<section id="inline-documentation-for-external-scripts">
<h5 title="Inline documentation for external scripts">4.12.1.4. å¤–éƒ¨~scriptã«å¯¾ã™ã‚‹~inlineãªæ–‡æ›¸åŒ–</h5>

<p>
`script$e è¦ç´ ã« `src$a å±æ€§ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€
è¦ç´ ã®å†…å®¹ã¯ï¼Œï¼»
å†…å®¹ã‹ã‚‰å°å‡ºã•ã‚Œã‚‹ `text$m ~IDLå±æ€§ã®å€¤ãŒï¼Œ
æ¬¡ã®~ABNFã«ã‚ˆã‚‹ `documentation^P ç”Ÿæˆè¦å‰‡ã«åˆè‡´ã™ã‚‹
ï¼½ã‚ˆã†ã«ãªã‚‰ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤
â€” ã“ã® ABNF ã®æ–‡å­—~é›†åˆã¯~Unicodeã¨ã™ã‚‹ï¼š
`ABNF$r
â—
If a script element's src attribute is specified, then the contents of the script element, if any, must be such that the value of the text IDL attribute, which is derived from the element's contents, matches the documentation production in the following ABNF, the character set for which is Unicode. [ABNF]
</p>

<pre class="bnf">
documentation
	= *( *( space / tab / comment ) [ line-comment ] newline )
comment
	= slash star *( not-star / star not-slash ) 1*star slash
line-comment
	= slash slash *not-newline

; characters
tab
	= `0009^0x ; U+0009 CHARACTER TABULATION (tab)
newline
	= `000A^0x ; U+000A LINE FEED (LF)
space
	= `0020^0x ; U+0020 SPACE
star
	= `002A^0x ; U+002A ASTERISK (*)
slash
	= `002F^0x ; U+002F SOLIDUS (/)
not-newline
	= `0000-0009^0x / `000B-10FFFF^0x
	; U+000A LINE FEED (LF) ä»¥å¤–ã® `~scalarå€¤$
not-star
	= `0000-0029^0x / `002B-10FFFF^0x
	; U+002A ASTERISK (*) ä»¥å¤–ã® `~scalarå€¤$
not-slash
	= `0000-002E^0x / `0030-10FFFF^0x
	; U+002F SOLIDUS (/) ä»¥å¤–ã® `~scalarå€¤$
</pre>

<!-- 
a Unicode character other than
 -->

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
è¦ç´ ã®å†…å®¹ã‚’ ~JS~commentå†…ã«ç½®ãã“ã¨ã«å¯¾å¿œã™ã‚‹ã€‚
â—
This corresponds to putting the contents of the element in JavaScript comments.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®è¦ä»¶ã¯ã€ï¼»
å‰ç¯€ã«è¿°ã¹ãŸï¼Œ
`script$e è¦ç´ ã®å†…å®¹ã®æ§‹æ–‡ã«èª²ã•ã‚Œã‚‹åˆ¶ç´„
ï¼½ã«å¯¾ã™ã‚‹è¿½åŠ ã§ã‚ã‚‹ã€‚
â—
This requirement is in addition to the earlier restrictions on the syntax of contents of script elements.
</p>

<div class="example">
<p>
ã“ã‚Œã«ã‚ˆã‚Šï¼Œä½œè€…ã¯ã€
ä¾ç„¶ã¨ã—ã¦å¤–éƒ¨~script~fileã‚’æŒ‡ã—ã¤ã¤ï¼Œï¼»
æ–‡æ›¸ã®å†…å´ã«ã‚‚ï¼Œ~licenseæƒ…å ±ã‚„~APIæƒ…å ±ãªã©ã®æ–‡æ›¸åŒ–ã‚’å«ã‚ã‚‹
ï¼½ã“ã¨ãŒå¯èƒ½ã«ãªã‚‹ã€‚
ã“ã®æ§‹æ–‡ã§ã¯ã€ï¼»
`src$a å±æ€§ã‚‚ä¾›ã—ã¦ã„ã‚‹ä½œè€…ãŒï¼Œ
å¦¥å½“ãª~scriptã®æ§˜ã«è¦‹ãˆã‚‹~dataã‚’ä¸ç”¨æ„ã«å«ã‚ã‚‹ã“ã¨ãŒãªã„
ï¼½ã‚ˆã†æ‹˜æŸã•ã‚Œã‚‹ã€‚
â—
This allows authors to include documentation, such as license information or API information, inside their documents while still referring to external script files. The syntax is constrained so that authors don't accidentally include what looks like valid script while also providing a src attribute.
</p>

`inline-documentation-1^xCode
</div>

			</section>
			<section id="scriptTagXSLT">
<h5 title="Interaction of script elements and XSLT">4.12.1.5. `script$e è¦ç´ ã¨ XSLT ã¨ã®ç›¸äº’ä½œç”¨</h5>

â—éè¦ç¯„çš„

<p>
ã“ã®ä»•æ§˜ã¯ã€
~XSLTã¨ `script$e è¦ç´ ã¨ãŒï¼Œã©ã†ç›¸äº’ä½œç”¨ã™ã‚‹ã‹ã¯å®šç¾©ã—ãªã„ã€‚
ã—ã‹ã—ãªãŒã‚‰ï¼Œã“ã“ã§ã¯ã€ï¼»
ã“ã‚Œã‚’å®Ÿéš›ã«å®šç¾©ã—ã¦ã„ã‚‹åˆ¥ã®ä»•æ§˜ãŒç„¡ã„ä¸‹ã§ã®ï¼Œ
æ—¢å­˜ã®å®Ÿè£…ã«åŸºã¥ãå®Ÿè£…è€…~å‘ã‘ã®æŒ‡é‡
ï¼½ã‚’ ã„ãã¤ã‹è¿°ã¹ã‚‹ï¼š
â—
This specification does not define how XSLT interacts with the script element. However, in the absence of another specification actually defining this, here are some guidelines for implementers, based on existing implementations:
</p>
<ul>
	<li>
~browserãŒ~DOMã¸ã®ç›´ãªå½¢å¼å¤‰æ›ã‚’å®Ÿè£…ã™ã‚‹ä¸‹ã§ï¼Œ
`&lt;?xml-stylesheet?&gt;^c å‡¦ç†å‘½ä»¤ã«ã‚ˆã‚Š ~XSLTå½¢å¼å¤‰æ›~programãŒèª˜ç™ºã•ã‚ŒãŸå ´åˆã€
~XSLTå‡¦ç†å™¨ã«ã‚ˆã‚Šä½œæˆã•ã‚Œã‚‹å„ `script$e è¦ç´ ã¯ï¼Œ
ãã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$scEã‚’æ­£ã—ãè¨­å®šã—ãŸä¸Šã§ï¼Œ
å½¢å¼å¤‰æ›ãŒç”Ÿã˜ã‚‹ã«ä¼´ã£ã¦`å³æ™‚$ã«, æ–‡æ›¸~é †åºã§
ï¼ˆãŸã ã—ï¼Œï¼»
`defer$a ï¼ `async$a
ï¼½ã«ã‚ˆã‚‹é †åºã¯é™¤ãï¼‰
èµ°ã‚‰ã™å¿…è¦ãŒã‚ã‚‹ã€‚
â—
When an XSLT transformation program is triggered by an &lt;?xml-stylesheet?&gt; processing instruction and the browser implements a direct-to-DOM transformation, script elements created by the XSLT processor need to have its parser document set correctly, and run in document order (modulo scripts marked defer or async), immediately, as the transformation is occurring.
</li>
	<li>
<p>
`XSLTProcessor$I ã® `transformToDocument()$m ~methodã¯ã€ï¼»
`å±ã™ã‚‹é–²è¦§~æ–‡è„ˆ$ ~EQ ~NULL
ï¼½ãªã‚‹`æ–‡æ›¸$ã«è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã€‚
ãã‚Œã«å‰‡ã‚Šã€
ä½œæˆã•ã‚Œã‚‹ ã©ã® `script$e è¦ç´ ã‚‚ï¼Œæ¬¡ã®ã‚ˆã†ã«ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹ï¼š
</p>
		<ul>
			<li>
`~scriptè¦ç´ ã‚’æº–å‚™ã™ã‚‹$~algoã®ä¸­ã§ï¼Œãã®`ã™ã§ã«é–‹å§‹ã—ãŸã‹$scEã‚’ ~T ã«è¨­å®šã—ã¦ã€
æ±ºã—ã¦å®Ÿè¡Œã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹
ï¼ˆ`~scriptingã¯ä¸èƒ½åŒ–-ï¼ ~WAPI#concept-environment-noscript$ã•ã‚Œã‚‹ï¼‰ã€‚
</li>
			<li>
è¦ç´ ã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$scEã‚’è¨­å®šã™ã‚‹ã€‚
</li>
			<li>
è¦ç´ ã® `async$m ~IDLå±æ€§ã¯ã€ï¼»
è¦ç´ ãŒ `async$a å†…å®¹~å±æ€§ã‚’æœ‰ã•ãªã„ã¨ãã¯ ~F ã‚’è¿”ã™
ï¼½ã‚ˆã†ã«ã™ã‚‹ã€‚
</li>
		</ul>

â—
The XSLTProcessor transformToDocument() method adds elements to a Document object with a null browsing context, and, accordingly, any script elements they create need to have their already started set to true in the prepare the script element algorithm and never get executed (scripting is disabled). Such script elements still need to have their parser document set, though, such that their async IDL attribute will return false in the absence of an async content attribute.
</li>
	<li>
`XSLTProcessor$I ã® `transformToFragment()$m ~methodã¯ã€ï¼»
`document.createElementNS()$m ã‚’åˆ©ç”¨ã—ã¦è¦ç´ ã‚’ä½œæˆã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šï¼Œ
æ‰‹å‹•ã§ç¯‰ã‹ã‚ŒãŸ`æ–‡æ›¸ç‰‡$
ï¼½ã¨ç­‰ä¾¡ãªã‚‚ã®ã‚’ä½œæˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
ä¸€ä¾‹ã¨ã—ã¦ã€
`script$e è¦ç´ ã‚’ä½œæˆã™ã‚‹éš›ã«ã¯ï¼Œãã®ï¼»
`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$scEã¯ ~NULL,
`ã™ã§ã«é–‹å§‹ã—ãŸã‹$scEã¯ ~F
ï¼½ã«è¨­å®šã—ãŸä¸Šã§ï¼»
å½“ã®`æ–‡æ›¸ç‰‡$ãŒæ–‡æ›¸~å†…ã«æŒ¿å…¥ã•ã‚ŒãŸæ™‚ç‚¹ã§å®Ÿè¡Œã•ã‚Œã‚‹
ï¼½ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
The XSLTProcessor transformToFragment() method needs to create a fragment that is equivalent to one built manually by creating the elements using document.createElementNS(). For instance, it needs to create script elements with null parser document and with their already started set to false, so that they will execute when the fragment is inserted into a document.
</li>
</ul>

<p>
ä¸Šã® 1, 2 ç•ªç›®ã®äº‹ä¾‹ã¨, 3 ç•ªç›®ã®äº‹ä¾‹ã¨ã®é–“ã®ä¸»ãªé•ã„ã¯ã€
å‰è€…ã¯`æ–‡æ›¸$ã«å¯¾ã—æ¼”ç®—ã™ã‚‹ä¸€æ–¹ã§ï¼Œ
å¾Œè€…ã¯`æ–‡æ›¸ç‰‡$ã«å¯¾ã—æ¼”ç®—ã™ã‚‹ã“ã¨ã«ã‚ã‚‹ã€‚
â—
The main distinction between the first two cases and the last case is that the first two operate on Documents and the last operates on a fragment.
</p>

			</section>
		</section>
		<section id="the-noscript-element">
<h4 title="The noscript element">4.12.2. `noscript^e è¦ç´ </h4>

<dl class="element-def">

	<dt>`åˆ†é¡$ï¼š</dt>
	<dd>
`~metadataå†…å®¹$ ï¼ `~flowå†…å®¹$ ï¼ `å¥ngå†…å®¹$
â—
Metadata content.
â—
Flow content.
â—
Phrasing content.
</dd>

	<dt>`ã“ã®è¦ç´ ã‚’åˆ©ç”¨ã§ãã‚‹æ–‡è„ˆ$ï¼š</dt>
	<dd>
`~HTMLæ–‡æ›¸$ã® `head$e è¦ç´ ~å†…, ã¾ãŸã¯
`~HTMLæ–‡æ›¸$å†…ã® `å¥ngå†…å®¹$ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€
â€” ãŸã ã—ã€ã„ãšã‚Œã«ã›ã‚ˆï¼Œå…ˆç¥–ã« `noscript$e è¦ç´ ãŒã‚ã‚‹æ‰€ã¯é™¤ãã€‚
â—
In a head element of an HTML document, if there are no ancestor noscript elements.
â—
Where phrasing content is expected in HTML documents, if there are no ancestor noscript elements.
</dd>

	<dt>`å†…å®¹~model$ï¼š</dt>
	<dd>
<p>
è¦ç´ ~ç”¨ã®`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆï¼š
</p>
		<ul>
			<li>
è¦ç´ ãŒ `head$e è¦ç´ ~å†…ã«ã‚ã‚‹å ´åˆã€
é †åºã¯å•ã‚ãšï¼Œãã‚Œãã‚ŒãŒï¼»
`link$e, `style$e, `meta$e
ï¼½ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹ã‚ˆã†ãªï¼Œ 0 å€‹ä»¥ä¸Šã®è¦ç´ ã€‚
</li>
			<li>
è¦ç´ ãŒ `head$e è¦ç´ ~å¤–ã«ã‚ã‚‹å ´åˆã€
`é€éçš„$ã«ãªã‚‹
â€” ãŸã ã—ã€å­å­«ã« `noscript$e è¦ç´ ãŒã‚ã£ã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ã€‚
</li>
		</ul>

â—
When scripting is disabled, in a head element: in any order, zero or more link elements, zero or more style elements, and zero or more meta elements.
â—
When scripting is disabled, not in a head element: transparent, but there must be no noscript element descendants.
</dd>
	<dd>
ä»–ã®å ´åˆã€ä¸‹ã®æ³¨é‡ˆæ–‡ã«ä¸ãˆã‚‹è¦ä»¶ã«é©åˆã™ã‚‹ã‚ˆã†ãª~textã€‚
â—
Otherwise: text that conforms to the requirements given in the prose.
</dd>

	<dt>`text/html ã«ãŠã‘ã‚‹~tagçœç•¥$ï¼š</dt>
	<dd>
ä¸¡~tagã¨ã‚‚çœç•¥ä¸å¯ã€‚
â—
Neither tag is omissible.
</dd>

	<dt>`å†…å®¹~å±æ€§$ï¼š</dt>
	<dd>
`å¤§åŸŸ~å±æ€§$
â—
Global attributes
</dd>

	<dt>`~accessibilityã®è€ƒæ…®ç‚¹$</dt>
	<dd>
`noscript$AA
â—
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
`HTMLElement$I ã‚’åˆ©ç”¨ã™ã‚‹
â—
Uses HTMLElement.
</dd></dl>

<p>
`noscript$e è¦ç´ ã¯ã€ï¼»
`~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆã¯ï¼Œä½•ã‚‚`è¡¨ç¾-$ã—ãªã„ï¼
`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆã¯ï¼Œãã®å­ãŸã¡ã‚’`è¡¨ç¾-$ã™ã‚‹
ï¼½ã€‚
ãã‚Œã¯ã€ï¼»
~UAãŒ~scriptingã‚’~supportã™ã‚‹ã‹ã©ã†ã‹ã«å¿œã˜ã¦ï¼Œæ–‡æ›¸ãŒã©ã†æ§‹æ–‡è§£æã•ã‚Œã‚‹ã‹ã‚’é•ãˆã‚‹
ï¼½ã“ã¨ã«ã‚ˆã‚Šï¼Œ~UAã«ç•°ãªã‚‹~markupã‚’æç¤ºã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
The noscript element represents nothing if scripting is enabled, and represents its children if scripting is disabled. It is used to present different markup to user agents that support scripting and those that don't support scripting, by affecting how the document is parsed.
</p>

<p>
`noscript$e è¦ç´  %noscript ãŒ
`~HTMLæ–‡æ›¸$ã«åˆ©ç”¨ã•ã‚Œã‚‹å ´åˆã«è¨±å®¹ã•ã‚Œã‚‹å†…å®¹~modelã¯ã€æ¬¡ã«å¾“ã†ï¼š
â—
When used in HTML documents, the allowed content model is as follows:
</p>

<dl class="switch">
	<dt>
%noscript ã¯ `head$e è¦ç´ ~å†…ã«ã‚ã‚‹å ´åˆï¼š
â—
â†“</dt>
	<dd>
		<dl class="switch">
			<dt>
`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆï¼š
â—
In a head element, if scripting is disabled for the noscript element
</dt>
			<dd>
%noscript ã¯ï¼»
`link$e, `style$e, `meta$e
ï¼½è¦ç´ ã®ã¿ã‚’åŒ…å«ã—ã¦ã„ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The noscript element must contain only link, style, and meta elements.
</dd>

			<dt>
`~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆï¼š
â—
In a head element, if scripting is enabled for the noscript element
</dt>
			<dd>
<p>
%noscript ã¯ã€~textã®ã¿ã‚’åŒ…å«ã™ã‚‹ã‹, ã¾ãŸã¯æ¬¡ã‚’æº€ãŸã•ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
</p>
				<ul>
					<li>
<p>
`~HTMLç´ ç‰‡~æ§‹æ–‡è§£æ~algo$ã‚’
( `æ–‡è„ˆ~è¦ç´ $V, %å…¥åŠ› )
ã¨ã—ã¦
( %noscript, %noscript ã®~textå†…å®¹ )
ã‚’ä¸ãˆã‚‹ä¸‹ã§å‘¼å‡ºã—ãŸã¨ãã€
~ANDâ†“ ã‚’æº€ãŸã™ï¼š
</p>
						<ul>
							<li>
`æ§‹æ–‡è§£æ-~error$ã¯ç”Ÿã˜ãªã„
</li>
							<li>
~algoã®çµæœã¯ã€
~nodeãŸã¡ãŒæˆã™~listã§ã‚ã‚Šï¼Œæ¬¡ã«æŒ™ã’ã‚‹è¦ç´ ã®ã¿ã‹ã‚‰ãªã‚‹
â‡’
`link$e, `style$e, `meta$e
</li>
							<li>
å‰é …ã®~listãŒ %noscript ã®å­ãŸã¡ã§ã‚ã£ãŸã¨ã™ã‚‹ã¨ãï¼Œé©åˆã™ã‚‹
</li>
						</ul>
					</li>
				</ul>

â—
The noscript element must contain only text, except that invoking the HTML fragment parsing algorithm with the noscript element as the context element and the text contents as the input must result in a list of nodes that consists only of link, style, and meta elements that would be conforming if they were children of the noscript element, and no parse errors.
</dd>
		</dl>
	</dd>

	<dt>
%noscript ã¯ `head$e è¦ç´ ~å¤–ã«ã‚ã‚‹å ´åˆï¼š
â—
â†“</dt>
	<dd>
		<dl class="switch">
			<dt>
`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆï¼š
â—
Outside of head elements, if scripting is disabled for the noscript element
</dt>
			<dd>
%noscript ã®å†…å®¹~modelã¯`é€éçš„$ã«ãªã‚‹
â€” ãŸã ã—ï¼Œ %noscript ã®å…ˆç¥–ã« `noscript$e è¦ç´ ãŒã‚ã£ã¦ã¯ãƒŠãƒ©ãƒŠã‚¤
ï¼ˆã™ãªã‚ã¡ï¼Œ `noscript$e ã¯å…¥å­ã«ã§ããªã„ï¼‰ã€‚
â—
The noscript element's content model is transparent, with the additional restriction that a noscript element must not have a noscript element as an ancestor (that is, noscript can't be nested).
<dd>

			<dt>
`~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆï¼š
â—
Outside of head elements, if scripting is enabled for the noscript element
</dt>
			<dd>
<p>
%noscript ã¯ã€
~textã®ã¿ã‚’åŒ…å«ã™ã‚‹ã‹, ã¾ãŸã¯æ¬¡ã‚’æº€ãŸã•ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
</p>
				<ul>
					<li>
<p>
ä¸‹ã«ä¸ãˆã‚‹~algoã‚’èµ°ã‚‰ã›ãŸã¨ãã€
~ANDâ†“ ã‚’æº€ãŸã™ï¼š
</p>
						<ul>
							<li>
ä¾‹å¤–ã¯æŠ•å‡ºã•ã‚Œãªã„
</li>
							<li>
çµæœã®æ–‡æ›¸ã¯ã€ï¼»
`noscript$e, `script$e
ï¼½è¦ç´ ã‚’å«ã¾ãªã„ï¼Œé©åˆ~æ–‡æ›¸ã«ãªã‚‹
</li>
							<li>
`~HTMLæ§‹æ–‡è§£æå™¨$ã«ãŠã„ã¦ï¼Œ`æ§‹æ–‡è§£æ-~error$ã¯ç”Ÿã˜ãªã„
</li>
						</ul>
					</li>
				</ul>
â—
The noscript element must contain only text, except that the text must be such that running the following algorithm results in a conforming document with no noscript elements and no script elements, and such that no step in the algorithm throws an exception or causes an HTML parser to flag a parse error:
</dd>
			<dd class="algo">
<p>
~algoã¯ã€
æ¬¡ã«å¾“ã†ï¼š
â—
â†‘</p>
				<ol>
					<li>
å½“ã®æ–‡æ›¸ã‹ã‚‰ã™ã¹ã¦ã® `script$e è¦ç´ ã‚’é™¤å»ã™ã‚‹
â—
Remove every script element from the document.
</li>
					<li>
<p>
å½“ã®æ–‡æ›¸~å†…ã®
~EACH( `noscript$e è¦ç´  %è¦ç´  )
ã«å¯¾ã—
â‡’
%è¦ç´  ã® `outerHTML$m å±æ€§ ~SET %è¦ç´  ã®`å­~textå†…å®¹$
â—
Make a list of every noscript element in the document. For every noscript element in that list, perform the following steps:
â€¢ Let s be the child text content of the noscript element.
â€¢ Set the outerHTML attribute of the noscript element to the value of s.ï¼¼
</p>

<p>
ï¼ˆã“ã‚Œã«ã‚ˆã‚‹å‰¯ä½œç”¨ã¨ã—ã¦ï¼Œ %è¦ç´  ã¯å½“ã®æ–‡æ›¸ã‹ã‚‰é™¤å»ã•ã‚Œã‚‹ã€‚ï¼‰
â—
(This, as a side-effect, causes the noscript element to be removed from the document.)
</p>
					</li>
				</ol>
			</dd>
		</dl>
	</dd>
</dl>

<p class="note">æ³¨è¨˜ï¼š
ä¸Šè¿°ã® ã²ã­ãã‚ŒãŸå–æ‰±ã„ã™ã¹ã¦ãŒè¦æ±‚ã•ã‚Œã‚‹
â€” æ­´å²çš„ãªç†ç”±ã‹ã‚‰ã€
`~HTMLæ§‹æ–‡è§£æå™¨$ã«ã‚ˆã‚‹ `noscript$e è¦ç´ ã«å¯¾ã™ã‚‹å–æ‰±ã„ã¯ï¼Œï¼»
æ§‹æ–‡è§£æå™¨ãŒå‘¼å‡ºã•ã‚ŒãŸã¨ãï¼Œ
å½“ã®è¦ç´ ~ç”¨ã®`~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦ã„ãŸã‹ã©ã†ã‹ï¼ ~HTMLparsing#scripting-flag$
ï¼½ã«å¿œã˜ã¦ç•°ãªã‚‹ã®ã§ã€‚
â—
All these contortions are required because, for historical reasons, the noscript element is handled differently by the HTML parser based on whether scripting was enabled or not when the parser was invoked.
</p>

<p>
`~XMLæ–‡æ›¸$ã«ã¯ã€
`noscript$e è¦ç´ ã‚’åˆ©ç”¨ã—ã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The noscript element must not be used in XML documents.
</p>

<p class="note">æ³¨è¨˜ï¼š
`noscript$e è¦ç´ ã«ã‚ˆã‚‹åŠ¹æœãŒã‚ã‚‹ã®ã¯ã€
`~HTMLæ§‹æ–‡$ã«é™ã‚‰ã‚Œã‚‹
â€” `~XMLæ§‹æ–‡$ã«å¯¾ã™ã‚‹åŠ¹æœã¯ç„¡ã„ã€‚
ã“ã®è¦ç´ ã¯ã€
~scriptãŒå¯èƒ½åŒ–ã•ã‚Œã¦ã„ã‚‹ä¸‹ã§ã¯ï¼Œ
æœ¬è³ªçš„ã«æ§‹æ–‡è§£æå™¨ã‚’ â€œåˆ‡ã‚‹â€ ã‚ˆã†ã«åƒã
â€” ã™ãªã‚ã¡ã€
è¦ç´ ã®å†…å®¹ã¯ï¼»
æœ¬ç‰©ã®è¦ç´ ãŸã¡ã§ã¯ãªãï¼Œç´”ç²‹ãª~text
ï¼½ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ â€”
ãŒã€
~XMLã«ã¯ï¼Œã“ã‚Œã‚’è¡Œã†ä»•çµ„ã¿ã¯å®šç¾©ã•ã‚Œã¦ã„ãªã„ã®ã§ã€‚
â—
The noscript element is only effective in the HTML syntax, it has no effect in the XML syntax. This is because the way it works is by essentially "turning off" the parser when scripts are enabled, so that the contents of the element are treated as pure text and not as real elements. XML does not define a mechanism by which to do this.
</p>

<p>
`noscript$e è¦ç´ ã«ã¯ã€
ä»–ã®è¦ä»¶ã¯ç„¡ã„ã€‚
ç‰¹ã«ï¼Œå½“ã®è¦ç´ ~ç”¨ã®`~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹ã¨ãã§ã‚‚ã€
`noscript$e è¦ç´ ã®å„~å­ãŒ
`~formæå‡º$, ~scripting, ç­‰ã€…, ã‹ã‚‰å…ã‚Œã‚‹ã“ã¨ã¯ãªã„ã€‚
â—
The noscript element has no other requirements. In particular, children of the noscript element are not exempt from form submission, scripting, and so forth, even when scripting is enabled for the element.
</p>

<div class="example">
<p>
æ¬¡ã®ä¾‹ã§ã¯ã€
ã‚ã‚‹~scriptç”¨ã®~fallbackã‚’ä¾›ã™ã‚‹ãŸã‚ã«
`noscript$e è¦ç´ ãŒåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ï¼š
â—
In the following example, a noscript element is used to provide fallback for a script.
</p>

`noscript-1^xCode

<p>
~scriptãŒä¸èƒ½åŒ–ã•ã‚Œã¦ã„ã‚‹ä¸‹ã§ã¯ã€
~serverå´ã§è¨ˆç®—ã‚’è¡Œã‚ã›ã‚‹ã‚ˆã†ãª~buttonãŒç¾ã‚Œã‚‹ã€‚
ä¸€æ–¹ã§ï¼Œ~scriptãŒå¯èƒ½åŒ–ã•ã‚Œã¦ã„ã‚‹ä¸‹ã§ã¯ã€
ãã®å ´ã§å€¤ãŒç®—å‡ºã•ã‚Œã‚‹ã€‚
â—
When script is disabled, a button appears to do the calculation on the server side. When script is enabled, the value is computed on-the-fly instead.
</p>

<p>
`noscript$e è¦ç´ ã¯ã€
â€œãªã¾ãã‚‰â€ ã§ã‚ã‚‹ã€‚
~pageã®~scriptãŒå¯èƒ½åŒ–ã•ã‚Œã¦ã„ã¦ã‚‚ï¼Œä½•ã‚‰ã‹ã®ç†ç”±ã§å¤±æ•—ã™ã‚‹ã“ã¨ã¯ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ã€
ä¸€èˆ¬ã«ï¼Œ
`noscript$e ã®åˆ©ç”¨ã¯é¿ã‘ã‚‹æ–¹ãŒè‰¯ã„
â€” æ¬¡ã®ä¾‹ã®ã‚ˆã†ã«ã€
ã¾ãš~scriptãªã—ãŒ~~å‰æã®~pageã«ã—ãŸä¸Šã§ï¼Œï¼»
~scriptãŒæˆåŠŸã—ãŸãªã‚‰ã€
ãã®çµæœã‚’ ãã®å ´ã§åˆ©ç”¨ã™ã‚‹ã‚ˆã†ï¼Œ~pageã‚’å¤‰æ›´ã™ã‚‹
ï¼½ã‚ˆã†è¨­è¨ˆã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šï¼š
â—
The noscript element is a blunt instrument. Sometimes, scripts might be enabled, but for some reason the page's script might fail. For this reason, it's generally better to avoid using noscript, and to instead design the script to change the page from being a scriptless page to a scripted page on the fly, as in the next example:
</p>

`noscript-2^xCode

<p>
ã“ã®æŠ€æ³•ã¯ã€
`noscript$e ãŒè¨±å®¹ã•ã‚Œãªã„`~XMLæ–‡æ›¸$ã«ãŠã„ã¦ã‚‚æœ‰ç”¨ã«ãªã‚‹ã€‚
â—
The above technique is also useful in XML documents, since noscript is not allowed there.
</p>
</div>

		</section>
		<section id="the-template-element">
<h4 title="The template element">4.12.3. `template^e è¦ç´ </h4>

<dl class="element-def">
	<dt>`åˆ†é¡$ï¼š</dt>
	<dd>
`~metadataå†…å®¹$ ï¼ `~flowå†…å®¹$ ï¼ `å¥ngå†…å®¹$ ï¼ `~scriptã‚’~supportã™ã‚‹è¦ç´ $
â—
Metadata content.
â—
Flow content.
â—
Phrasing content.
â—
Script-supporting element.
</dd>

	<dt>`ã“ã®è¦ç´ ã‚’åˆ©ç”¨ã§ãã‚‹æ–‡è„ˆ$ï¼š</dt>
	<dd>
`~metadataå†…å®¹$ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€ã€‚
â—
Where metadata content is expected.
</dd>
	<dd>
`å¥ngå†…å®¹$ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€ã€‚
â—
Where phrasing content is expected.
</dd>
	<dd>
`~scriptã‚’~supportã™ã‚‹è¦ç´ $ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€ã€‚
â—
Where script-supporting elements are expected.
</dd>
	<dd>
`span$a å±æ€§ã‚’æœ‰ã•ãªã„ `colgroup$e è¦ç´ ã®å­ã¨ã—ã¦ã€‚
â—
As a child of a colgroup element that doesn't have a span attribute.
</dd>

	<dt>`å†…å®¹~model$ï¼š</dt>
	<dd>
`ãªã—$ï¼ˆã‚ˆã‚Šæ˜ç¢ºã«ã¯ï¼Œ
`ä¾‹ã‚’è¦‹ã‚ˆï¼ #template-example$ã€‚
ï¼‰
â—
Nothing (for clarification, see example).
</dd>

	<dt>`text/html ã«ãŠã‘ã‚‹~tagçœç•¥$ï¼š</dt>
	<dd>
ä¸¡~tagã¨ã‚‚çœç•¥ä¸å¯ã€‚
â—
Neither tag is omissible.
</dd>

	<dt>`å†…å®¹~å±æ€§$ï¼š</dt>
	<dd>
`å¤§åŸŸ~å±æ€§$
â—
Global attributes
</dd>
	<dd>
<p>
`shadowrootmode$a
â€” å®£è¨€çš„ãª~shadowæ ¹ã«ã‚ˆã‚‹~streamæ³•ã‚’å¯èƒ½åŒ–ã™ã‚‹
</p>

<p class="trans-note">ã€
â€œ~streamæ³•â€ ã¨ã¯ã€
`~serverå´~å…·ç¾åŒ–ï¼ https://github.com/mfreed7/declarative-shadow-dom/blob/master/README.md#motivation$
ï¼ˆç•¥ç§° SSRï¼‰
â€” ~JSã‚’åˆ©ç”¨ã›ãšã«~shadow~DOMã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ â€”
ã‚’æŒ‡ã™ã¨æ€ã‚ã‚Œã‚‹ã€‚
ã€‘</p>
â—
shadowrootmode â€” Enables streaming declarative shadow roots
</dd>
	<dd>
`shadowrootdelegatesfocus$a
â€” å®£è¨€çš„ãª~shadowæ ¹ã«å¯¾ã—ï¼Œãã®`~focusã‚’å§”ä»»ã™ã‚‹ã‹$sRã‚’ ~T ã«è¨­å®šã™ã‚‹
â—
shadowrootdelegatesfocus â€” Sets delegates focus on a declarative shadow root
</dd>
	<dd>
`shadowrootclonable$a
â€” å®£è¨€çš„ãª~shadowæ ¹ã«å¯¾ã—ï¼Œãã®`~cloneå¯èƒ½ã‹$sRã‚’ ~T ã«è¨­å®šã™ã‚‹
â—
shadowrootclonable â€” Sets clonable on a declarative shadow root
</dd>
	<dd>
`shadowrootserializable$a
â€” å®£è¨€çš„ãª~shadowæ ¹ã«å¯¾ã—ï¼Œãã®`ç›´åˆ—åŒ–-å¯èƒ½ã‹$sRã‚’ ~T ã«è¨­å®šã™ã‚‹
â—
shadowrootserializable â€” Sets serializable on a declarative shadow root
</dd>
	<dd>
`shadowrootcustomelementregistry$a
â€” å®£è¨€çš„ãª~shadowæ ¹ãŒï¼»
~customè¦ç´ ~registryã‚’åˆ©ç”¨ã™ã‚‹ã‚ˆã†æŒ‡ç¤ºã™ã‚‹
ï¼½ã“ã¨ã‚’å¯èƒ½åŒ–ã™ã‚‹ã€‚
â—
shadowrootcustomelementregistry â€” Enables declarative shadow roots to indicate they will use a custom element registry
</dd>

	<dt>`~accessibilityã®è€ƒæ…®ç‚¹$</dt>
	<dd>
`template$AA
â—
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
<pre class="idl">
[Exposed=Window]
interface `HTMLTemplateElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  readonly attribute `DocumentFragment$I `content$m;
  [`CEReactions$] attribute DOMString `shadowRootMode$m;
  [`CEReactions$] attribute boolean `shadowRootDelegatesFocus$m;
  [`CEReactions$] attribute boolean `shadowRootClonable$m;
  [`CEReactions$] attribute boolean `shadowRootSerializable$m;
  [`CEReactions$] attribute DOMString `shadowRootCustomElementRegistry$m;
};
</pre>
</dd>
</dl>

<p>
`template$e è¦ç´ ã¯ã€ï¼»
~scriptã«ã‚ˆã‚Šï¼»
~cloneã§ãã‚‹ï¼æ–‡æ›¸~å†…ã«æŒ¿å…¥ã§ãã‚‹
ï¼½~HTMLç´ ç‰‡
ï¼½ã‚’å®£è¨€ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
The template element is used to declare fragments of HTML that can be cloned and inserted in the document by script.
</p>

<p>
å…·ç¾åŒ–ã«ãŠã„ã¦ã¯ã€
`template$e è¦ç´ ã¯ä½•ã‚‚`è¡¨ç¾-$ã—ãªã„ã€‚
â—
In a rendering, the template element represents nothing.
</p>

<p>
`shadowrootmode@a
å†…å®¹~å±æ€§ã¯ã€
`åˆ—æŒ™då±æ€§$ã§ã‚ã‚Šï¼Œ
æ¬¡ã«æŒ™ã’ã‚‹~keyword, ã¨ã‚Šå¾—ã‚‹çŠ¶æ…‹, ãã‚Œã‚‰ã®å¯¾å¿œä»˜ã‘ãŒå®šç¾©ã•ã‚Œã‚‹ï¼š
â—
The shadowrootmode content attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead><tr><th>~keyword
<th>çŠ¶æ…‹
<th>æ¦‚ç•¥çš„ãªè¨˜è¿°
</thead><tbody>

<tr><td>`open@v
<td>`é–‹ãª@st
<td>å½“ã® `template^e è¦ç´ ã¯ã€
é–‹ãªå®£è¨€çš„~shadowæ ¹ã‚’è¡¨ç¾ã™ã‚‹ã€‚

<tr><td>`closed@v
<td>`é–‰ãª@st
<td>å½“ã® `template^e è¦ç´ ã¯ã€
é–‰ãªå®£è¨€çš„~shadowæ ¹ã‚’è¡¨ç¾ã™ã‚‹ã€‚

<tr><td>ï¼ˆãªã—ï¼‰
<td>`ãªã—@st
<td>ã€å½“ã® `template^e è¦ç´ ã¯ã€å®£è¨€çš„ãª~shadowæ ¹ã‚’è¡¨ç¾ã—ãªã„ã€‚ã€‘
</tbody></table>

<p class="trans-note">ã€
ï¼»
`open^v, `closed^v
ï¼½ã¯ã€
`~shadowæ ¹$ã®`~mode$sRç”¨ã®å€¤ã‚’`æŒ‡ç¤ºã™ã‚‹ï¼ ~HTMLparsing#_template-shadowrootmode$ã€‚
ã€‘</p>
â—
Keywordï½œStateï½œBrief description
openï½œOpenï½œThe template element represents an open declarative shadow root.
closedï½œClosedï½œThe template element represents a closed declarative shadow root.
</div>

<p>
`shadowrootmode$a å±æ€§ã®ï¼»
`æ¬ è½~å€¤~ç”¨ã®æ—¢å®šã®çŠ¶æ…‹$, `å¦¥å½“ã§ãªã„å€¤~ç”¨ã®æ—¢å®šã®çŠ¶æ…‹$
ï¼½ã¯ã€
ã„ãšã‚Œã‚‚ `ãªã—$st ã¨ã™ã‚‹ã€‚
â—
The shadowrootmode attribute's invalid value default and missing value default are both the None state.
</p>

<p>
`shadowrootdelegatesfocus@a
å†…å®¹~å±æ€§ã¯ã€
`çœŸå½-å±æ€§$ã§ã‚ã‚‹ã€‚
â—
The shadowrootdelegatesfocus content attribute is a boolean attribute.
</p>

<p>
`shadowrootclonable@a
å†…å®¹~å±æ€§ã¯ã€
`çœŸå½-å±æ€§$ã§ã‚ã‚‹ã€‚
â—
The shadowrootclonable content attribute is a boolean attribute.
</p>

<p>
`shadowrootserializable@a
å†…å®¹~å±æ€§ã¯ã€
`çœŸå½-å±æ€§$ã§ã‚ã‚‹ã€‚
â—
The shadowrootserializable content attribute is a boolean attribute.
</p>

<p>
`shadowrootcustomelementregistry@a
å†…å®¹~å±æ€§ã¯ã€
`çœŸå½-å±æ€§$ã§ã‚ã‚‹ã€‚
â—
The shadowrootcustomelementregistry content attribute is a boolean attribute.
</p>

<p>
`template$e è¦ç´ ã®`~templateå†…å®¹$ã¯ã€
è¦ç´ ~è‡ªèº«ã®å­ã§ã¯ãªã„ã€‚
â—
The template contents of a template element are not children of the element itself.
</p>

<p class="note">æ³¨è¨˜ï¼š
~DOMæ“ä½œã®çµæœã¨ã—ã¦ï¼Œï¼»
`template$e è¦ç´ ãŒ `Text$I ~nodeã‚„è¦ç´ ~nodeã‚’åŒ…å«ã™ã‚‹
ï¼½ã“ã¨ã‚‚ã‚¢ãƒªã ãŒã€
`template$e è¦ç´ ã®å†…å®¹~modelã¯`ãªã—$ã¨å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã®ã§ï¼Œãã‚Œã¯é•åã«ãªã‚‹ã€‚
â—
It is also possible, as a result of DOM manipulation, for a template element to contain Text nodes and element nodes; however, having any is a violation of the template element's content model, since its content model is defined as nothing.
</p>

<div class="example" id="template-example">

<p>
ä¾‹ãˆã°ã€æ¬¡ã®æ–‡æ›¸ã‚’è€ƒãˆã‚‹ï¼š
â—
For example, consider the following document:
</p>

`template-1^xCode

<p>
`template$e å†…ã® `p$e è¦ç´ ã¯ã€
~DOMå†…ã§ã¯ `template$e ã®å­`ã§ã¯ãªã„^em
â€” ãã‚Œã¯ã€
`template$e è¦ç´ ã® `content$m ~IDLå±æ€§ã‹ã‚‰è¿”ã•ã‚Œã‚‹`æ–‡æ›¸ç‰‡$ã®å­ã§ã‚ã‚‹ã€‚
â—
The p element in the template is not a child of the template in the DOM; it is a child of the DocumentFragment returned by the template element's content IDL attribute.
</p>

<p>
~scriptãŒ `template$e è¦ç´ ã«å¯¾ã— `appendChild()$m ã‚’~callã—ãŸå ´åˆã€
`template$e è¦ç´ ã«å­ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã«ãªã‚‹
ï¼ˆä»–ã®è¦ç´ ã«å¯¾ã™ã‚‹ã¨ãã¨åŒæ§˜ã«ï¼‰
â€” ã—ã‹ã—ãªãŒã‚‰ã€
ãã†ã™ã‚‹ã¨ï¼Œ `template$e è¦ç´ ã®å†…å®¹~modelã«é•åã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
If the script were to call appendChild() on the template element, that would add a child to the template element (as for any other element); however, doing so is a violation of the template element's content model.
</p>
</div>

<dl class="domintro">
	<dt>%~template.`content$m</dt>
	<dd>
`~templateå†…å®¹$ï¼ˆ `æ–‡æ›¸ç‰‡$ ï¼‰ã‚’è¿”ã™ã€‚
â—
Returns the template contents (a DocumentFragment).
</dd>
</dl>

<p>
å„ `template$e è¦ç´ ã«ã¯ã€
ã‚ã‚‹`æ–‡æ›¸ç‰‡$ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â€” ãã‚ŒãŒã€
å½“ã®è¦ç´ ã®
`~templateå†…å®¹@
ã«ãªã‚‹ã€‚
`~templateå†…å®¹$ã«ã¯
ã€æ§‹æ–‡~ä»¥å¤–ã«ã€‘
`é©åˆæ€§~è¦ä»¶ã¯ç„¡ã„ï¼ ~HTMLdom#no-browsing-context$ã€‚
â—
Each template element has an associated DocumentFragment object that is its template contents. The template contents have no conformance requirements.ï¼¼
</p>

<div class="algo">
<p>
~UAã¯ï¼Œ
`template$e è¦ç´  %è¦ç´  ã‚’ä½œæˆã—ãŸã¨ãã¯ã€
%è¦ç´  ã®`~templateå†…å®¹$ã‚’ç¢ºç«‹ã™ã‚‹ãŸã‚ã«ï¼Œ
æ¬¡ã®æ‰‹ç¶šãã‚’èµ°ã‚‰ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
When a template element is created, the user agent must run the following steps to establish the template contents:
</p>

<ol>
	<li>
%æ–‡æ›¸ ~LET %è¦ç´  ã®`~nodeæ–‡æ›¸$ã®`~templateå†…å®¹ã‚’æ‰€æœ‰ã™ã‚‹é©åˆ‡ãªæ–‡æ›¸$
â—
Let doc be the template element's node document's appropriate template contents owner document.
</li>
	<li>
%æ–‡æ›¸ç‰‡ ~LET æ–°ãŸãª`æ–‡æ›¸ç‰‡$
â€” ãã®
â‡’ï¼ƒ
`~nodeæ–‡æ›¸$ ~SET %æ–‡æ›¸,
`~host$ ~SET %è¦ç´ 
â—
Create a DocumentFragment object whose node document is doc and host is the template element.
</li>
	<li>
%è¦ç´  ã®`~templateå†…å®¹$ ~SET %æ–‡æ›¸ç‰‡
â—
Set the template element's template contents to the newly created DocumentFragment object.
</li>
</ol>
</div>

<div class="algo">
<p>
`æ–‡æ›¸$ %æ–‡æ›¸ ã®
`~templateå†…å®¹ã‚’æ‰€æœ‰ã™ã‚‹é©åˆ‡ãªæ–‡æ›¸@
ã¯ã€
æ¬¡ã®~algoãŒè¿”ã™`æ–‡æ›¸$ã¨ã—ã¦å®šç¾©ã•ã‚Œã‚‹ï¼š
</p>
<ol>
	<li>
<p>
~IFï¼»
%æ–‡æ›¸ ã¯ã€
ã‚ã‚‹`æ–‡æ›¸$ã®`ä¸æ´»~templateæ–‡æ›¸$ã§ã‚ã‚‹
ï¼½
</p>
		<ol>
			<li>
~Assertï¼š
%æ–‡æ›¸ ã¯ã€
ã“ã®~algoã®ä¸­ã§ä½œæˆã•ã‚ŒãŸã‚‚ã®ã§ã‚ã‚‹ã€‚
</li>
			<li>
~RET %æ–‡æ›¸
</li>
		</ol>
	</li>
	<li>
%ä¸æ´»~æ–‡æ›¸ ~LET %æ–‡æ›¸ ã®`ä¸æ´»~templateæ–‡æ›¸$
</li>
	<li>
~IFï¼»
%ä¸æ´»~æ–‡æ›¸ ~NEQ Îµ
ï¼½
â‡’
~RET %ä¸æ´»~æ–‡æ›¸
</li>
	<li>
%ä¸æ´»~æ–‡æ›¸ ~LET æ–°ãŸãª`æ–‡æ›¸$
ï¼ˆãã‚ŒãŒ`å±ã™ã‚‹é–²è¦§~æ–‡è„ˆ$ ~EQ ~NULL ï¼‰
</li>
	<li>
~IFï¼»
%æ–‡æ›¸ ã¯`~HTMLæ–‡æ›¸$ã§ã‚ã‚‹
ï¼½
â‡’
%ä¸æ´»~æ–‡æ›¸ ã®`ç¨®åˆ¥$doc ~SET `html^l
ï¼ˆ %ä¸æ´»~æ–‡æ›¸ ã‚‚~HTMLæ–‡æ›¸ã«ã™ã‚‹ï¼‰
</li>
	<li>
%æ–‡æ›¸ ã®`ä¸æ´»~templateæ–‡æ›¸$ ~SET %ä¸æ´»~æ–‡æ›¸
</li>
	<li>
~RET %ä¸æ´»~æ–‡æ›¸
</li>
</ol>

<p>
ã“ã®~algoã®ç›®çš„ã«ãŠã„ã¦ã¯ã€
å„`æ–‡æ›¸$ã«ã¯ï¼Œ
`ä¸æ´»~templateæ–‡æ›¸@
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
ã€ãã®ç”¨é€”ã¯ï¼Œæ¬¡ã®æ³¨è¨˜ã‚’è¦‹ã‚ˆã€‘
â€” ãã‚Œã¯ã€ï¼»
Îµï¼`æ–‡æ›¸$
ï¼½ã§ã‚ã‚Šï¼ŒåˆæœŸ~æ™‚ã¯ Îµ ï¼ˆ~~å­˜åœ¨ã—ãªã„ï¼‰ã¨ã™ã‚‹ï¼ˆå¿…è¦ã«å¿œã˜ã¦ä½œæˆã•ã‚Œã‚‹ï¼‰ã€‚
</p>

<p class="note">æ³¨è¨˜ï¼š
ã—ãŸãŒã£ã¦ï¼Œã“ã®~algoã®ä¸­ã§ä½œæˆã•ã‚ŒãŸã‚‚ã®ä»¥å¤–ã®å„`æ–‡æ›¸$ã¯ã€ï¼»
è‡ªèº«ã® `template$e è¦ç´ ã™ã¹ã¦ã®`~templateå†…å®¹$
ï¼½ã‚’ï¼»
ãã‚Œã‚‰ãŒ ã©ã®`é–²è¦§~æ–‡è„ˆ$ã«ã‚‚å±ã•ãšï¼Œä¸æ´»ã§ã‚ã‚Šç¶šã‘ã‚‹ï¼ˆä¾‹ï¼š ~scriptã‚’èµ°ã‚‰ã›ãªã„ï¼‰ã‚ˆã†ã«ã™ã‚‹
ï¼½ãŸã‚ã«æ‰€æœ‰ã™ã‚‹ãŸã‚ã®ï¼»
ä»£ç†ã¨ã—ã¦å‹•ä½œã™ã‚‹å˜ç‹¬ã®`æ–‡æ›¸$
ï¼½ã‚’`ä¸æ´»~templateæ–‡æ›¸$ã¨ã—ã¦å–å¾—ã™ã‚‹ã€‚
`ä¸æ´»~templateæ–‡æ›¸$ã®å†…å´ã«ã‚ã‚‹ `template$e è¦ç´ ã¯ã€
å½“é¢ã®é–“ã¯ã€ä¸æ´»ã§ãªããªã‚‹ã¾ã§ã¯ã€‘ï¼Œ
å˜ã«åŒã˜`æ–‡æ›¸$ã‚’ ãã®`~templateå†…å®¹$ã®æ‰€æœ‰è€…ã¨ã—ã¦å†åˆ©ç”¨ã™ã‚‹ã“ã¨ã«ãªã‚‹
ã€ä¸Šã®~algoã®æœ€åˆã®æ®µã€‘ã€‚
</p>

â—
A Document doc's appropriate template contents owner document is the Document returned by the following algorithm:
â€¢ If doc is not a Document created by this algorithm, then:
â€¢â€¢ If doc does not yet have an associated inert template document, then:
â€¢â€¢â€¢ Let new doc be a new Document (whose browsing context is null). This is "a Document created by this algorithm" for the purposes of the step above.
â€¢â€¢â€¢ If doc is an HTML document, mark new doc as an HTML document also.
â€¢â€¢â€¢ Set doc's associated inert template document to new doc.
â€¢â€¢ Set doc to doc's associated inert template document.
â€¢ Each Document not created by this algorithm thus gets a single Document to act as its proxy for owning the template contents of all its template elements, so that they aren't in a browsing context and thus remain inert (e.g. scripts do not run). Meanwhile, template elements inside Document objects that are created by this algorithm just reuse the same Document owner for their contents.
â€¢ Return doc.
</div>

<div class="algo">
<p id="template-adopting-steps">
`template$e è¦ç´ ~ç”¨ã®`å—å…¥-æ™‚ã®æ‰‹ç¶šã$ã¯ã€
æ‰€ä¸ã®
( %~node, %æ—§-æ–‡æ›¸ )
ã«å¯¾ã—ï¼š
â—
The adopting steps (with node and oldDocument as parameters) for template elements are the following:
</p>

<ol>
	<li>
<p>
%æ–‡æ›¸ ~LET %~node ã®`~nodeæ–‡æ›¸$ã®`~templateå†…å®¹ã‚’æ‰€æœ‰ã™ã‚‹é©åˆ‡ãªæ–‡æ›¸$
â—
Let doc be node's node document's appropriate template contents owner document.
</p>

<p class="note">æ³¨è¨˜ï¼š
%~node ã®`~nodeæ–‡æ›¸$ã¯ã€
ç›´å‰ã« %~node ã‚’å—å…¥ã—ãŸ`æ–‡æ›¸$ã§ã‚ã‚‹ã€‚
ã€ %æ—§-æ–‡æ›¸ ã§ã¯ãªãï¼ˆ %æ—§-æ–‡æ›¸ ã¯ã€ã“ã®æ‰‹ç¶šãã«ãŠã„ã¦ã¯åˆ©ç”¨ã•ã‚Œãªã„ï¼‰ã€‚ã€‘
â—
node's node document is the Document object that node was just adopted into.
</p>
	</li>
	<li>
%æ–‡æ›¸ ã«`~nodeã‚’å—å…¥ã™ã‚‹$( %~node ã®ï¼ˆ`æ–‡æ›¸ç‰‡$ã§ã‚ã‚‹ï¼‰`~templateå†…å®¹$ )
â—
Adopt node's template contents (a DocumentFragment object) into doc.
</li>
</ol>
</div>

<div class="algo">
<p>
`content@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
</p>
<ol>
	<li>
%~templateå†…å®¹ ~LET ã‚³ãƒ¬ã®`~templateå†…å®¹$
</li>
	<li>
~IFï¼»
%~templateå†…å®¹ ã¯ `ShadowRoot$I ~nodeã§ãªã„
ï¼½
â‡’
~RET %~templateå†…å®¹
</li>
	<li>
~RET ~NULL
</li>
</ol>
â—
The content getter steps are to return template's template contents, if the template contents is not a ShadowRoot node; otherwise null.
</div>

<p>
`shadowRootMode@m
~IDLå±æ€§ã¯ã€
`æ—¢çŸ¥ãªå€¤ã®ã¿ã«åˆ¶é™ã•ã‚Œ$ã‚‹ä¸‹ã§ï¼Œ
`shadowrootmode$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The shadowRootMode IDL attribute must reflect the shadowrootmode content attribute, limited to only known values.
</p>

<p>
`shadowRootDelegatesFocus@m
~IDLå±æ€§ã¯ã€
`shadowrootdelegatesfocus$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The shadowRootDelegatesFocus IDL attribute must reflect the shadowrootdelegatesfocus content attribute.
</p>

<p>
`shadowRootClonable@m
~IDLå±æ€§ã¯ã€
`shadowrootclonable$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The shadowRootClonable IDL attribute must reflect the shadowrootclonable content attribute.
</p>

<p>
`shadowRootSerializable@m
~IDLå±æ€§ã¯ã€
`shadowrootserializable$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The shadowRootSerializable IDL attribute must reflect the shadowrootserializable content attribute.
</p>

<p>
`shadowRootCustomElementRegistry@m
~IDLå±æ€§ã¯ã€
`shadowrootcustomelementregistry$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The shadowRootCustomElementRegistry IDL attribute must reflect the shadowrootcustomelementregistry content attribute.
</p>

<p>
ã“ã®~IDLå±æ€§ã®å‹ãŒ `boolean^c ã§ãªã„ã®ã¯ã€
æ„å›³çš„ã§ã‚ã‚‹
â€” å¾Œã§æ‹¡å¼µã§ãã‚‹ã‚ˆã†ã€‚
â—
The IDL attribute does intentionally not have a boolean type so it can be extended.
</p>

<hr>

<div class="algo">
<p>
`template$e è¦ç´ ~ç”¨ã®`~cloneæ™‚ã®æ‰‹ç¶šã$ã¯ã€
æ‰€ä¸ã®
( %~node, %è¤‡è£½, %ä¸‹ä½treeã‹ )
ã«å¯¾ã—ï¼š
â—
The cloning steps for template elements given node, copy, and subtree are:
</p>
<ol>
	<li>
~IFï¼»
%ä¸‹ä½treeã‹ ~EQ ~F
ï¼½
â‡’
~RET
â—
If subtree is false, then return.
</li>
	<li>
%~node ã®`~templateå†…å®¹$ã®`å­~ç¾¤$ã‚’æˆã™
~EACH( %å­ )
ã«å¯¾ã—ï¼Œ`~treeé †åº$ã§
â‡’
`~nodeã‚’~cloneã™ã‚‹$( %å­, ~T, %è¤‡è£½ ã®`~templateå†…å®¹$ã®`~nodeæ–‡æ›¸$, %è¤‡è£½ ã®`~templateå†…å®¹$ )
â—
For each child of node's template contents's children, in tree order:ï¼¼
clone a node given child with document set to copy's template contents's node document, subtree set to true, and parent set to copy's template contents.
</li>
</ol>
</div>

<div class="example">
<p>
æ¬¡ã®ä¾‹ã®~scriptã¯ã€
è¦ç´ ~æ§‹é€ ã‚’ä¾›ã™ã‚‹ `template$e ã‚’åˆ©ç”¨ã—ã¦ï¼Œ
4 ~colã‹ã‚‰ãªã‚‹~tableã‚’ ã‚ã‚‹~dataæ§‹é€ ã‹ã‚‰ã®~dataã§æ‹¡å……ã™ã‚‹
â€” æ‰‹å‹•ã§~markupã—ã¦æ§‹é€ ã‚’ç”Ÿæˆã™ã‚‹ä»£ã‚ã‚Šã«ï¼š
â—
In this example, a script populates a table four-column with data from a data structure, using a template to provide the element structure instead of manually generating the structure from markup.
</p>

`template-2^xCode

<p>
ã“ã®ä¾‹ã§ã¯ã€
`template$e ã®å†…å®¹~ä¸Šã§ `cloneNode()$m ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ãŒï¼ŒåŒã˜ã“ã¨ã‚’è¡Œã†
`document.importNode()$m ã‚’åˆ©ç”¨ã—ã¦ã‚‚ç­‰ä¾¡ã«ãªã‚‹ã€‚
ã“ã‚Œã‚‰ã®~APIã®å”¯ä¸€ã®ç›¸é•ã¯ã€
ã„ã¤`~nodeæ–‡æ›¸$ãŒæ›´æ–°ã•ã‚Œã‚‹ã‹ã«ãªã‚‹
â€” ï¼»
`cloneNode()$m ã§ã¯ï¼Œ `appendChild()$m ã§~nodeãŒä»˜åŠ ã•ã‚Œã‚‹ã¨ãï¼
`document.importNode()$m ã§ã¯ï¼Œ~nodeãŒ~cloneã•ã‚Œã‚‹ã¨ã
ï¼½ã«æ›´æ–°ã•ã‚Œã‚‹ã€‚
â—
This example uses cloneNode() on the template's contents; it could equivalently have used document.importNode(), which does the same thing. The only difference between these two APIs is when the node document is updated: with cloneNode() it is updated when the nodes are appended with appendChild(), with document.importNode() it is updated when the nodes are cloned.
</p>
</div>

			<section id="template-XSLT-XPath">
<h5 title="Interaction of template elements with XSLT and XPath">4.12.3.1. `template$e è¦ç´ ã¨~XSLT, ~XPathã¨ã®ç›¸äº’ä½œç”¨</h5>

â—éè¦ç¯„çš„

<p>
ã“ã®ä»•æ§˜ã¯ã€
~XSLTã¨ `template$e è¦ç´ ã¨ãŒï¼Œã©ã†ç›¸äº’ä½œç”¨ã™ã‚‹ã‹ã¯å®šç¾©ã—ãªã„ã€‚
ã—ã‹ã—ãªãŒã‚‰ï¼Œã“ã“ã§ã¯ã€ï¼»
ã“ã‚Œã‚’å®Ÿéš›ã«å®šç¾©ã—ã¦ã„ã‚‹åˆ¥ã®ä»•æ§˜ãŒç„¡ã„ä¸‹ã§ã®ï¼Œ
æ—¢å­˜ã®å®Ÿè£…ã«åŸºã¥ãå®Ÿè£…è€…~å‘ã‘ã®æŒ‡é‡
ï¼½ã‚’ ã„ãã¤ã‹è¿°ã¹ã‚‹
â€” ã“ã‚Œã‚‰ã®æŒ‡é‡ã¯ã€
ã“ã®ä»•æ§˜ã«è¿°ã¹ã‚‹ä»–ã®å‡¦ç†ã¨æ•´åˆã™ã‚‹ã‚ˆã†ã«æ„å›³ã•ã‚Œã¦ã„ã‚‹ï¼š
â—
This specification does not define how XSLT and XPath interact with the template element. However, in the absence of another specification actually defining this, here are some guidelines for implementers, which are intended to be consistent with other processing described in this specification:
</p>
<ul>
	<li>
~XSLTå‡¦ç†å™¨ã¯ã€ï¼»
ã“ã®ä»•æ§˜ã«è¿°ã¹ã‚‹ã¨ãŠã‚Šã«å‹•ä½œã™ã‚‹`~XMLæ§‹æ–‡è§£æå™¨$
ï¼½ã«åŸºã¥ããªã‚‰ã°ï¼Œå½¢å¼å¤‰æ›-ã®ç›®çš„ã«ãŠã„ã¦ã¯ï¼»
`template$e è¦ç´ ãŒ ãã®`~templateå†…å®¹$ã®å­å­«ã‚’åŒ…å«ã—ã¦ã„ãŸ
ï¼½ã‹ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
An XSLT processor based on an XML parser that acts as described in this specification needs to act as if template elements contain as descendants their template contents for the purposes of the transform.
</li>
	<li>
~DOMã‚’å‡ºåŠ›ã™ã‚‹~XSLTå‡¦ç†å™¨ã¯ã€ï¼»
`template$e è¦ç´ ã®ä¸­ã¸è¡Œã~nodeãŒï¼Œè¦ç´ ã®`~templateå†…å®¹$ã®ä¸­ã«ç½®ã‹ã‚Œã‚‹
ï¼½ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
An XSLT processor that outputs a DOM needs to ensure that nodes that would go into a template element are instead placed into the element's template contents.
</li>
	<li>
~XPath~DOM~APIã‚’åˆ©ç”¨ã—ã¦~XPathå¼ã‚’è©•ä¾¡ã™ã‚‹éš›ã«ã¯ã€
ã“ã®ä»•æ§˜ã«è¿°ã¹ã‚‹ï¼»
`~HTMLæ§‹æ–‡è§£æå™¨$ï¼`~XMLæ§‹æ–‡è§£æå™¨$
ï¼½ã‚’åˆ©ç”¨ã—ã¦æ§‹æ–‡è§£æã•ã‚ŒãŸ`æ–‡æ›¸$ã«é©ç”¨ã™ã‚‹ã¨ãã¯ï¼Œ
`~templateå†…å®¹$ã‚’ç„¡è¦–ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
XPath evaluation using the XPath DOM API when applied to a Document parsed using the HTML parser or the XML parser described in this specification needs to ignore template contents.
</li>
</ul>

			</section>
		</section>
		<section id="the-slot-element">
<h4 title="The slot element">4.12.4. `slot^e è¦ç´ </h4>

<dl class="element-def">

	<dt>`åˆ†é¡$ï¼š</dt>
	<dd>
`~flowå†…å®¹$ ï¼ `å¥ngå†…å®¹$
â—
Flow content.
â—
Phrasing content.
</dd>

	<dt>`ã“ã®è¦ç´ ã‚’åˆ©ç”¨ã§ãã‚‹æ–‡è„ˆ$ï¼š</dt>
	<dd>
`å¥ngå†…å®¹$ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€ã€‚
â—
Where phrasing content is expected.
</dd>

	<dt>`å†…å®¹~model$ï¼š</dt>
	<dd>
`é€éçš„$
â—
Transparent
</dd>

	<dt>`text/html ã«ãŠã‘ã‚‹~tagçœç•¥$ï¼š</dt>
	<dd>
ä¸¡~tagã¨ã‚‚çœç•¥ä¸å¯ã€‚
â—
Neither tag is omissible.
</dd>

	<dt>`å†…å®¹~å±æ€§$ï¼š</dt>
	<dd>
`å¤§åŸŸ~å±æ€§$
â—
Global attributes
</dd>
	<dd>
`name$a
â€” `~shadow~tree$ã®`~slot$ã®`~slotå$
â—
name â€” Name of shadow tree slot
</dd>

	<dt>`~accessibilityã®è€ƒæ…®ç‚¹$</dt>
	<dd>
`slot$AA
â—
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLSlotElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute DOMString `name$m;
  sequence&lt;Node&gt; `assignedNodes$m(optional `AssignedNodesOptions$I %options = {});
  sequence&lt;Element&gt; `assignedElements$m(optional `AssignedNodesOptions$I %options = {});
  undefined `assign$m((`Element$I or `Text$I)... %nodes);
};

dictionary `AssignedNodesOptions@I {
  boolean `flatten@m = false;
};
</pre>
	</dd>
</dl>

<p>
`slot$e è¦ç´ ã¯ã€
`~slot$ã‚’å®šç¾©ã™ã‚‹ã€‚
ãã‚Œã¯æ¦‚ã—ã¦ï¼Œ`~shadow~tree$ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
`slot$e è¦ç´ ã¯ã€ï¼»
ãã‚Œã«`å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤$ã¯ç©ºã§ãªã„ãªã‚‰ã° ãã‚Œã‚‰ã®~node ï¼
~ELSE_ è‡ªèº«ã®å†…å®¹
ï¼½ã‚’`è¡¨ç¾-$ã™ã‚‹ã€‚
â—
The slot element defines a slot. It is typically used in a shadow tree. A slot element represents its assigned nodes, if any, and its contents otherwise.
</p>

<p>
`name@a
å†…å®¹~å±æ€§ãŒåŒ…å«ã™ã‚‹å€¤ã¯ã€
ã©ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã§ã‚‚ãƒ¨ã‚¤ã€‚
ãã‚Œã¯ã€
`~slot$ã®`~slotå$ã‚’è¡¨ç¾ã™ã‚‹ã€‚
â—
The name content attribute may contain any string value. It represents a slot's name.
</p>

<p class="note">æ³¨è¨˜ï¼š
`name$a å±æ€§ã¯ã€
ä»–ã®è¦ç´ ã‚’ï¼Œã“ã®è¦ç´ ãŒå®šç¾©ã™ã‚‹`~slotã«å‰²å½“ã™ã‚‹$ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ï¼š
`name$a å±æ€§ã‚’æœ‰ã™ã‚‹ `slot$e è¦ç´  %slot ã¯ã€
ãã®å±æ€§~å€¤ã‚’`~slotå$ã¨ã™ã‚‹`~slot$ã‚’ä½œæˆã—ï¼Œ
æ¬¡ã‚’æº€ãŸã™ã‚ˆã†ãªä»–ã®è¦ç´ ã‚’ ãã®`~slotã«å‰²å½“ã™ã‚‹$ã“ã¨ãŒå¯èƒ½ã«ãªã‚‹
â‡’
ï¼»
è¦ç´ ã® `slot$a å±æ€§ã®å€¤ã¯~slotåã«åˆè‡´ã™ã‚‹
ï¼½~ANDï¼»
%slot ã‚’å­ã¨ã™ã‚‹`~shadow~tree$ã®`æ ¹$ã®`~host$ãŒï¼Œå¯¾å¿œã™ã‚‹ `slot$a å±æ€§~å€¤ã‚’æŒã¤ã€ï¼Ÿã€‘
ï¼½
ã€ï¼è¦ç´ ã¯ slot ã®~shadowæ ¹ã®~hostã®å­ï¼å­å­«ã§ã‚ã‚‹ï¼Ÿã€‘
â—
The name attribute is used to assign slots to other elements: a slot element with a name attribute creates a named slot to which any element is assigned if that element has a slot attribute whose value matches that name attribute's value, and the slot element is a child of the shadow tree whose root's host has that corresponding slot attribute value.
</p>

<dl class="domintro">
	<dt>%slot.`name$m</dt>
	<dd>
%slot ã®`~slotå$ã‚’å–å¾—ã—ãŸã‚Šè¨­å®šã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã§ãã‚‹ã€‚
â—
Can be used to get and set slot's name.
</dd>

	<dt>%slot.`assignedNodes(options)$m</dt>
	<dd>
<p>
%options ã® `flatten^m ~memberå€¤ã«å¿œã˜ã¦ï¼š
</p>
		<ul>
			<li>
~F ï¼ˆ %options ã®çœç•¥æ™‚ã‚‚å«ã‚€ï¼‰ãªã‚‰ã°
â‡’
%slot ã«`å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤$ã‚’è¿”ã™ã€‚
</li>
			<li>
~T ãªã‚‰ã°
â‡’
%slot ã«`å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤$ã¯ï¼»
ç©ºã§ãªã„ãªã‚‰ã° ãã‚Œã‚’æˆã™~nodeãŸã¡ ï¼
ç©ºãªã‚‰ã° %slot ã®å­ãŸã¡
ï¼½ã«åŠ ãˆã¦ã€
ãã‚Œã‚‰ã«å«ã¾ã‚Œã‚‹å„ `slot$e è¦ç´ ã«å¯¾ã—ã¦ã‚‚ï¼Œ
`slot$e è¦ç´ ãŒå°½ãã‚‹ã¾ã§ï¼Œå†å¸°çš„ã«åŒã˜ã“ã¨ã‚’ã—ã¦å¾—ã‚‰ã‚Œã‚‹~nodeç¾¤ã‚’è¿”ã™ã€‚
</li>
		</ul>
â—
Returns slot's assigned nodes.
â—
slot . assignedNodes({ flatten: true })
â—
Returns slot's assigned nodes, if any, and slot's children otherwise, and does the same for any slot elements encountered therein, recursively, until there are no slot elements left.
</dd>

	<dt>%slot.`assignedElements(options)$m</dt>
	<dd>
`assignedNodes(options)$m
ã¨åŒã˜çµæœã‚’ï¼Œè¦ç´ ã®ã¿ã«åˆ¶é™ã—ãŸä¸Šã§è¿”ã™ã€‚
â—
Returns slot's assigned nodes, limited to elements.
â—
slot . assignedElements({ flatten: true })
â—
Returns the same as assignedNodes({ flatten: true }), limited to elements.
</dd>

	<dt>%slot.`assign(...nodes)$m</dt>
	<dd>
%~slot ã«`æ‰‹å‹•ã§å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤$ã‚’æ‰€ä¸ã® %nodes ã«è¨­å®šã™ã‚‹ã€‚
â—
Sets slot's manually assigned nodes to the given nodes.
</dd>
</dl>

<p>
`name@m
~IDLå±æ€§ã¯ã€
`name$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The name IDL attribute must reflect the content attribute of the same name.
</p>

<p>
å„ `slot$e è¦ç´ ã«ã¯
`æ‰‹å‹•ã§å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤@
ãŒã‚ã‚‹
â€” ãã‚Œã¯ã€
`~slotå¯èƒ½$ãŸã¡ãŒæˆã™`æœ‰é †åº~é›†åˆ$ã§ã‚ã‚Šï¼ŒåˆæœŸ~æ™‚ã¯ç©ºã¨ã™ã‚‹ã€‚
ã“ã®é›†åˆã¯ã€
`assign()$m ã«ã‚ˆã‚Šè¨­å®šã•ã‚Œã‚‹ã€‚
â—
The slot element has manually assigned nodes, which is an ordered set of slottables set by assign(). This set is initially empty.
</p>

<p class="note">æ³¨è¨˜ï¼š
`æ‰‹å‹•ã§å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤$ã¯ã€
~scriptã‹ã‚‰ã¯ç›´ã«~accesså¯èƒ½ã§ãªã„ã®ã§ï¼Œ
`~slotå¯èƒ½$ã¸ã®å¼±ã„å‚ç…§ã‚’åˆ©ç”¨ã—ã¦å®Ÿè£…ã§ãã‚‹ï¼ã•ã‚Œå¾—ã‚‹ã€‚
â—
The manually assigned nodes set can be implemented using weak references to the slottables, because this set is not directly accessible from script.
</p>

<div class="algo">
<p>
`assignedNodes(options)@m
~methodæ‰‹ç¶šãã¯ï¼š
â—
The assignedNodes(options) method steps are:
</p>
<ol>
	<li>
~RET %options[ "`flatten$m" ] ã«å¿œã˜ã¦
â‡’ï¼ƒ
~F ãªã‚‰ã° ã‚³ãƒ¬ã«`å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤$ ï¼
~T ãªã‚‰ã° `~slotç”¨ã«å¹³å¦~åŒ–ã•ã‚ŒãŸ~slotå¯èƒ½ãªã‚‚ã®ã‚’è¦‹å‡ºã™$( ã‚³ãƒ¬ )
â—
If options["flatten"] is false, then return this's assigned nodes.
â—
Return the result of finding flattened slottables with this.
</li>
</ol>
</div>

<div class="algo">
<p>
`assignedElements(options)@m
~methodæ‰‹ç¶šãã¯ï¼š
â—
The assignedElements(options) method steps are:
</p>

<ol>
	<li>
%çµæœ ~LET %options[ "`flatten$m" ] ã«å¿œã˜ã¦
â‡’ï¼ƒ
~F ãªã‚‰ã° ã‚³ãƒ¬ã«`å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤$ ï¼
~T ãªã‚‰ã° `~slotç”¨ã«å¹³å¦~åŒ–ã•ã‚ŒãŸ~slotå¯èƒ½ãªã‚‚ã®ã‚’è¦‹å‡ºã™$( ã‚³ãƒ¬ )
â—
If options["flatten"] is false, then return this's assigned nodes, filtered to contain only Element nodes.
â—
Return the result of finding flattened slottables with this, filtered to contain only Element nodes.
</li>
	<li>
~RET %çµæœ ã‚’ `Element$I ~nodeã®ã¿ã‚’åŒ…å«ã™ã‚‹ã‚ˆã†ã«çµè¾¼ã‚“ã çµæœ
â—
â†‘</li>
</ol>
</div>

<div class="algo">
<p>
`assign(...nodes)@m
~methodæ‰‹ç¶šãã¯ï¼š
â—
The assign(...nodes) method steps are:
</p>
<ol>
	<li>
ã‚³ãƒ¬ã«`æ‰‹å‹•ã§å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤$ã‚’æˆã™
~EACH( %~node )
ã«å¯¾ã—
â‡’
%~node ã®`æ‰‹å‹•~å‰²å½“-å…ˆ~slot$ ~SET ~NULL
â—
For each node of this's manually assigned nodes, set node's manual slot assignment to null.
</li>
	<li>
%~nodeé›†åˆ ~LET æ–°ãŸãª`æœ‰é †åº~é›†åˆ$
â—
Let nodesSet be a new ordered set.
</li>
	<li>
<p>
%nodes ã‚’æˆã™
~EACH( %~node )
ã«å¯¾ã—ï¼š
â—
For each node of nodes:
</p>
		<ol>
			<li>
%~slot ~LET %~node ã®`æ‰‹å‹•~å‰²å½“-å…ˆ~slot$
</li>
			<li>
~IFï¼»
%~slot ~NEQ ~NULL
ï¼½
â‡’
%~slot ã«`æ‰‹å‹•ã§å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤$ã‹ã‚‰ %~node ã‚’é™¤å»ã™ã‚‹
â—
If node's manual slot assignment refers to a slot, then remove node from that slot's manually assigned nodes.
</li>
			<li>
%~node ã®`æ‰‹å‹•~å‰²å½“-å…ˆ~slot$ ~SET ã‚³ãƒ¬
â—
Set node's manual slot assignment to this.
</li>
			<li>
%~nodeé›†åˆ ã« %~node ã‚’`ä»˜åŠ ã™ã‚‹$set
â—
Append node to nodesSet.
</li>
		</ol>
	</li>
	<li>
ã‚³ãƒ¬ã«`æ‰‹å‹•ã§å‰²å½“ã•ã‚ŒãŸ~nodeç¾¤$ ~SET %~nodeé›†åˆ
â—
Set this's manually assigned nodes to nodesSet.
</li>
	<li>
`~treeã«~slotå¯èƒ½ãªã‚‚ã®ã‚’å‰²å½“ã™ã‚‹$( ã‚³ãƒ¬ã®`æ ¹$ )
â—
Run assign slottables for a tree for this's root.
</li>
</ol>
</div>

		</section>
	</section>
</main>

