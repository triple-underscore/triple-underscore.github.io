<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard â€” Scriptingï¼ˆæ—¥æœ¬èªè¨³ï¼‰</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		persisted_parts: Util.collectHtmlCodeList(),
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~ä¸€-é¿†ã‚-ã‚“]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'a': // 
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case '0x': // ABNF char code %x escape
	return `%x${key}`;
	break;
case 'AA':
	return `<a href="~HTMLARIA#el-${key}">ä½œè€…~å‘ã‘</a>ï¼<a href="~HTMLAAM#el-${key}">å®Ÿè£…è€…~å‘ã‘</a>`;
	break;
case 'obsMb':
	text = 'å»ƒç”¨ã«ã•ã‚ŒãŸ~memberã‚‚ã‚ã‚‹';
	href= `~HTMLLS/obsolete.html#${key}-partial`;
	break;
case 'xCode':
	return `<pre class="lang-html" id="_ex-${key}">ï¼Š</pre>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


â—â—options

spec_date:2020-07-14
trans_update:2020-07-16
source_checked:191126
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/scripting.html
	abbr_url:HEscripting
nav_prev:HEinteractive
nav_next:HEcanvas
trans_1st_pub:2016-04-27


â—â—class_map
e:element
a:attr
et:event-type
P:production
st:attr-state
v:value
E:error
sl:js-slot
obsMb:comment

â—â—tag_map
I:code
m:code
E:code
c:code
e:code
a:code
et:code
st:span
P:code
s:samp
v:code
sl:span
V:var
i:i
cite:cite
obsMb:span

â—â—original_id_map

	the-script-element:script

â—â—mdn_urls
the-noscript-element:HTML/Element/noscript
the-script-element:HTML/Element/script
the-slot-element:HTML/Element/slot
the-template-element:HTML/Element/template

	assignednodesoptions:API/AssignedNodesOptions
htmlscriptelement:API/HTMLScriptElement
htmlslotelement:API/HTMLSlotElement
htmltemplateelement:API/HTMLTemplateElement

â—â—link_map

	â—e
e.script:#the-script-element
e.slot:#the-slot-element
e.template:#the-template-element
e.noscript:#the-noscript-element

e.p:~HEgrouping#the-p-element
e.figure:~HEgrouping#the-figure-element

e.head:~HEmetadata#the-head-element
e.link:~HEmetadata#the-link-element
e.meta:~HEmetadata#the-meta-element
e.style:~HEmetadata#the-style-element


e.colgroup:~HEtables#the-colgroup-element
e.details:~HEinteractive#the-details-element

	â—attr
a.async:#attr-script-async
a.charset:~HTMLobs#attr-script-charset
a.crossorigin:#attr-script-crossorigin
a.defer:#attr-script-defer
a.event:~HTMLobs#attr-script-event
a.for:~HTMLobs#attr-script-for
a.language:~HTMLobs#attr-script-language
a.nomodule:#attr-script-nomodule
a.name:#attr-slot-name
a.integrity:#attr-script-integrity
a.referrerpolicy:#attr-script-referrerpolicy
a.span:~HEtables#attr-colgroup-span
a.src:#attr-script-src
a.type:#attr-script-type
a.slot:~HTMLdom#attr-slot

	â—IDL 
CEReactions:~HEcustom#cereactions
HTMLConstructor:~HTMLdom#htmlconstructor

I.AssignedNodesOptions:#assignednodesoptions
I.DOMParser:~HTMLdynamic#domparser
I.Document:~HTMLdom#document
I.DocumentFragment:~DOM4#interface-documentfragment
I.HTMLElement:~HTMLdom#htmlelement
I.HTMLScriptElement:#htmlscriptelement
I.HTMLSlotElement:#htmlslotelement
I.HTMLTemplateElement:#htmltemplateelement
I.Text:~DOM4#interface-text
I.Window:~WINDOW#window
I.XMLHttpRequest:~XHR#xmlhttprequest
I.XSLTProcessor:~HTMLdep#xsltprocessor
I.Element:~DOM4#interface-element

æ–‡æ›¸ç‰‡:#_documentfragment
æ–‡æ›¸:~HTMLdom#the-document-object

	â—m

m.appendChild:~DOM4#dom-node-appendchild
m.assignedNodes:#dom-slot-assignednodes
m.assignedElements:#dom-slot-assignedelements

m.async:#dom-script-async
m.cloneNode:~DOM4#dom-node-clonenode
m.content:#dom-template-content
m.createDocument:~DOM4#dom-domimplementation-createdocument
m.crossOrigin:#dom-script-crossorigin
m.currentScript:~HTMLdom#dom-document-currentscript
m.defer:#dom-script-defer
m.document.createElementNS:~DOM4#dom-document-createelementns
m.document.importNode:~DOM4#dom-document-importnode
m.document.write:~HTMLdynamic#dom-document-write
m.innerHTML:~DOM-Parsing#dom-innerhtml-innerhtml
m.outerHTML:~DOM-Parsing#dom-element-outerhtml
m.noModule:#dom-script-nomodule
m.name:#dom-slot-name
m.integrity:#dom-script-integrity
m.referrerPolicy:#dom-script-referrerpolicy
m.responseXML:~XHR#dom-xmlhttprequest-responsexml
m.src:#dom-script-src
m.text:#dom-script-text
	m.textContent:~DOM4#dom-node-textcontent
m.transformToDocument:~HTMLdep#dom-xsltprocessor-transformtodocument
m.transformToFragment:~HTMLdep#dom-xsltprocessor-transformtofragment

m.type:#dom-script-type

	â—mime
c.text/javascript:~HTMLindex#text/javascript

	â—et
et.load:~HTMLindex#event-load
et.error:~HTMLindex#event-error


V.async:#_val-async
V.charset:#_val-charset
V.defer:#_val-defer
V.language:#_val-language
V.src:#_val-src
V.type:#_val-type

sl.CryptographicNonce:~HTMLurl#cryptographicnonce


	â—l
é–‹å§‹æ¸ˆã¿~flag:#already-started
	l.already started:#already-started
æ§‹æ–‡è§£æå™¨~æ–‡æ›¸:#parser-document
æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸ:#parser-inserted
	l.parser-inserted:#parser-inserted
é˜»ã¾ãš~flag:#non-blocking
	l.non-blocking:#non-blocking
è§£æå™¨å®Ÿè¡Œæº–å‚™æ¸ˆã¿~flag:#ready-to-be-parser-executed
	l.ready to be parser-executed:#ready-to-be-parser-executed
æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸:#preparation-time-document

å¤–éƒ¨~file~flag:#concept-script-external
å¤–éƒ¨~fileã‹ã‚‰:#concept-script-external


	â—terms
~data~block:#data-block
~scriptç¨®åˆ¥:#concept-script-type
~script:#concept-script-script
	~scriptè¦ç´ ã®~script:#concept-script-script

~scriptã¯æº–å‚™æ¸ˆã¿:#the-script-is-ready
æº–å‚™æ¸ˆã¿:#the-script-is-ready
æº–å‚™-:#prepare-a-script
~scriptã‚’æº–å‚™ã™ã‚‹:#prepare-a-script

æ–‡æ›¸ã‚’æ§‹æ–‡è§£æã—çµ‚ãˆãŸã¨ãã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptã®~list:#list-of-scripts-that-will-execute-when-the-document-has-finished-parsing
ã‚¢ãƒªãªé™ã‚Šã™ãã«é †ã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptã®~list:#list-of-scripts-that-will-execute-in-order-as-soon-as-possible
ã‚¢ãƒªãªé™ã‚Šã™ãã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptã®é›†åˆ:#set-of-scripts-that-will-execute-as-soon-as-possible

æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹~script:#pending-parsing-blocking-script
~script~blockã‚’å®Ÿè¡Œã™ã‚‹:#execute-the-script-block

~templateå†…å®¹:#template-contents
~templateå†…å®¹ã‚’æ‰€æœ‰ã™ã‚‹é©åˆ‡ãªæ–‡æ›¸:#appropriate-template-contents-owner-document
	é©åˆ‡ãª~templateå†…å®¹~æ‰€æœ‰è€…~æ–‡æ›¸
ä¸æ´»~templateæ–‡æ›¸:#associated-inert-template-document


~data~block:#data-block
~formæå‡º:~HTMLforms#form-submission

~scriptå†…å®¹~åˆ¶ç´„:#restrictions-for-contents-of-script-elements
~scriptæ–‡æ›¸åŒ–:#inline-documentation-for-external-scripts

	â—terms DOM4
~nodeã‚’å—å…¥ã™ã‚‹:~DOM4#concept-node-adopt
~HTMLæ–‡æ›¸:~DOM4#html-document
~XMLæ–‡æ›¸:~DOM4#xml-document
	æ–‡æ›¸ç¨®åˆ¥:~DOM4#concept-document-type
å—å…¥-æ™‚ã®æ‰‹ç¶šã:~DOM4#concept-node-adopt-ext
å‰²å½“ã•ã‚ŒãŸ~nodeãŸã¡:~DOM4#slot-assigned-nodes
~slotã«å‰²å½“ã™ã‚‹:~DOM4#assign-a-slot

~nodeã‚’~cloneã™ã‚‹:~DOM4#concept-node-clone
~cloneæ™‚ã®æ‰‹ç¶šã:~DOM4#concept-node-clone-ext
~slotç”¨ã«å¹³å¦~åŒ–ã•ã‚ŒãŸ~slottableãŸã¡ã‚’è¦‹å‡ºã™:~DOM4#find-flattened-slotables
~host:~DOM4#concept-documentfragment-host
æ–‡æ›¸~treeå†…:~DOM4#in-a-document-tree
æ¥ç¶šã•ã‚Œã¦:~DOM4#connected
~slotå:~DOM4#slot-name
~nodeæ–‡æ›¸:~DOM4#concept-node-document
~shadow~tree:~DOM4#concept-shadow-tree
~slot:~DOM4#concept-slot
doc.ç¬¦å·åŒ–æ³•:~DOM4#concept-document-encoding
~treeé †åº:~DOM4#concept-tree-order
æ ¹:~DOM4#concept-tree-root
~shadowæ ¹:~DOM4#concept-shadow-root
~eventã‚’ç™ºç«ã™ã‚‹:~DOM4#concept-event-fire
å­~textå†…å®¹:~DOM4#concept-child-text-content
å­å­«~textå†…å®¹:~DOM4#concept-descendant-text-content
å…¨~å†…å®¹ã‚’æ–‡å­—åˆ—ã«ç½®æ›ã™ã‚‹:~DOM4#string-replace-all

~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹:~INFRA#ascii-lowercase
~ASCIIå¤§å°ç„¡è¦–:~INFRA#ascii-case-insensitive
å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã:~INFRA#strip-leading-and-trailing-ascii-whitespace
~scalarå€¤:~INFRA#scalar-value

	â—HTMLINFRA

å³æ™‚:~HTMLINFRA#immediately
æ¥ç¶šã•ã‚ŒãŸ:~HTMLINFRA#becomes-connected
ä¸¦åˆ—çš„:~HTMLINFRA#in-parallel
éåŒæœŸã«å®Œäº†ã—ãŸ:~HTMLINFRA#_asynchronously-complete
æ–‡æ›¸ã®ä¸­ã¸æŒ¿å…¥ã•ã‚ŒãŸ:~HTMLINFRA#insert-an-element-into-a-document
node.æŒ¿å…¥ã•ã‚ŒãŸ:~HTMLINFRA#nodes-are-inserted

çœŸå½-å±æ€§:~HTMLcms#boolean-attribute
åæ˜ ã™ã‚‹:~HTMLcdom#reflect
æ—¢çŸ¥ãªå€¤ã®ã¿ã«åˆ¶é™ã•ã‚Œ:~HTMLcdom#limited-to-only-known-values

~CORSè¨­å®šç¾¤~å±æ€§:~HTMLurl#cors-settings-attribute
~referreræ–½ç­–~å±æ€§:~HTMLurl#referrer-policy-attribute
~CORSè¨­å®šç¾¤~å±æ€§ã®è³‡æ ¼è¨¼~mode:~HTMLurl#cors-settings-attribute-credentials-mode
~Content-Type~header:~HTMLurl#content-type
ç›¸å¯¾çš„ã«æ§‹æ–‡è§£æ-:~HTMLurl#parse-a-url
æ–‡æ›¸~åŸºåº•~URL:~HTMLurl#document-base-url
çµæœã®~URL~record:~HTMLurl#resulting-url-record
å‰å¾Œ~ç©ºç™½~å¯ã®å¦¥å½“ã‹ã¤ç©ºã§ãªã„~URL:~HTMLurl#valid-non-empty-url-potentially-surrounded-by-spaces



	â—HTMLdom
åˆ†é¡:~HTMLdom#concept-element-categories
å†…å®¹~å±æ€§:~HTMLdom#concept-element-attributes
å†…å®¹~model:~HTMLdom#concept-element-content-model
ãªã—:~HTMLdom#concept-content-nothing
ã“ã®è¦ç´ ã‚’åˆ©ç”¨ã§ãã‚‹æ–‡è„ˆ:~HTMLdom#concept-element-contexts
~accessibilityã®è€ƒæ…®ç‚¹:~HTMLdom#concept-element-accessibility-considerations
~DOM~interface:~HTMLdom#concept-element-dom
~flowå†…å®¹:~HTMLdom#flow-content-2
å¤§åŸŸ~å±æ€§:~HTMLdom#global-attributes
~metadataå†…å®¹:~HTMLdom#metadata-content-2
å¥ngå†…å®¹:~HTMLdom#phrasing-content-2
~scriptã‚’~supportã™ã‚‹è¦ç´ :~HTMLdom#script-supporting-elements-2
text/html ã«ãŠã‘ã‚‹~tagçœç•¥:~HTMLdom#concept-element-tag-omission
é€éçš„:~HTMLdom#transparent
è¡¨ç¾-:~HTMLdom#represents

	â—WAPI
x.~script:~WAPI#concept-script
å¤å…¸~script:~WAPI#classic-script
å¤å…¸~scriptã‚’~fetchã™ã‚‹:~WAPI#fetch-a-classic-script
å¤å…¸~scriptã‚’èµ°ã‚‰ã™:~WAPI#run-a-classic-script
å¤å…¸~scriptã‚’ä½œæˆã™ã‚‹:~WAPI#creating-a-classic-script
~inline~script~graphã‚’~fetchã™ã‚‹:~WAPI#fetch-an-inline-module-script-graph
ç ´å£Šçš„æ›¸è¾¼ã¯ç„¡è¦–ã™ã‚‹~counter:~HTMLdynamic#ignore-destructive-writes-counter

~module~script:~WAPI#module-script
~module~scriptã‚’èµ°ã‚‰ã™:~WAPI#run-a-module-script
å¤–éƒ¨~module~script~graphã‚’~fetchã™ã‚‹:~WAPI#fetch-a-module-script-tree
~taskã‚’~queueã™ã‚‹:~WAPI#queue-a-task
~scripting:~WAPI#scripting
~scriptingã¯ä¸èƒ½åŒ–-:~WAPI#concept-environment-noscript
~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦:~WAPI#concept-n-noscript
~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦:~WAPI#concept-n-script
é–¢é€£ãªè¨­å®šç¾¤~obj:~WAPI#relevant-settings-object

~script~fetch~options:~WAPI#script-fetch-options
sfO.æš—å·ç”¨~nonce:~WAPI#concept-script-fetch-options-nonce
sfO.å®Œå…¨æ€§~metadata:~WAPI#concept-script-fetch-options-integrity
sfO.æ§‹æ–‡è§£æå™¨~metadata:~WAPI#concept-script-fetch-options-parser
sfO.è³‡æ ¼è¨¼~mode:~WAPI#concept-script-fetch-options-credentials
sfO.~referreræ–½ç­–:~WAPI#concept-script-fetch-options-referrer-policy

å¤§åŸŸ~obj:~WAPI#global-object



	â—HTML
æ§‹æ–‡è§£æ-~error:~HTMLparsing#parse-errors
~load~eventã‚’é…å»¶-:~HTMLparsing#delay-the-load-event
~HTMLç´ ç‰‡~æ§‹æ–‡è§£æ~algo:~HTMLparsing#html-fragment-parsing-algorithm
~HTMLæ§‹æ–‡è§£æå™¨:~HTMLparsing#html-parser
V.æ–‡è„ˆ~è¦ç´ :~HTMLparsing#concept-frag-parse-context
	~end:~HTMLparsing#scriptEndTag
~scriptå…¥å­ng~level:~HTMLparsing#script-nesting-level
	å¤–æ¥ã®å†…å®¹:~HTMLparsing#scriptForeignEndTag
~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦ã„ãŸã‹ã©ã†ã‹:~HTMLparsing#scripting-flag

~XMLæ§‹æ–‡è§£æå™¨:~HTMLxml#xml-parser

é–²è¦§æ–‡è„ˆ:~BROWSERS#browsing-context
å±ã™ã‚‹é–²è¦§æ–‡è„ˆ:~BROWSERS#concept-document-bc

ç”Ÿæˆå…ƒ:~ORIGIN#concept-origin

~scriptã‚’é˜»ã‚“ã§ã„ã‚‹~stylesheet:~HEmetadata#a-style-sheet-that-is-blocking-scripts

	~in~XML:~HTMLxml#scriptTagXML
	~start:~HTMLparsing#scriptTag
~HTMLæ§‹æ–‡:~HTMLwriting#syntax
~XMLæ§‹æ–‡:~HTMLxml#the-xhtml-syntax


	â—others
~CORS~protocol:~FETCH#http-cors-protocol
è³‡æ ¼è¨¼~mode:~FETCH#concept-request-credentials-mode
rq.å®Œå…¨æ€§~metadata:~FETCH#concept-request-integrity-metadata
~fetch:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch

ç¬¦å·åŒ–æ³•:~ENCODING#encoding
~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹:~ENCODING#concept-encoding-get

~URL:~URL1#concept-url

~referreræ–½ç­–:~REFERRER-POLICY#referrer-policy

~MIMEå‹:~MIMESNIFF#mime-type
å¦¥å½“ãª~MIMEå‹~æ–‡å­—åˆ—:~MIMESNIFF#valid-mime-type
~JS~MIMEå‹:~MIMESNIFF#javascript-mime-type
~JSON~MIMEå‹:~MIMESNIFF#json-mime-type
~JS~MIMEå‹ã«~essenceåˆè‡´-:~MIMESNIFF#javascript-mime-type-essence-match

P.Module:~TC39#prod-Module
P.Script:~TC39#prod-Script

è¦ç´ ã«ãŠã‘ã‚‹~inlineå‹ã®æŒ™å‹•ã¯~CSPã«ã‚ˆã‚Šé˜»æ­¢ã•ã‚Œã‚‹ã¹ãã‹ï¼Ÿ:~CSP3#should-block-inline


â—â—words_table1

â—â—words_table

	â—ãƒ‡ãƒ¼ã‚¿ï¼æ“ä½œï¼IDL
scalar::::ã‚¹ã‚«ãƒ©ãƒ¼
	-:entry
å—å…¥-:adopt::~
	-:unset
å½¢å¼å¤‰æ›-:transform::~
å½¢å¼å¤‰æ›:transformation::~

	â—æ§‹é€ 
	å­ãŸã¡:children
å¹³å¦:flat:~
	å¹³å¦~åŒ–:flatten
	owning

	â—æ–‡å­—åˆ—ï¼æ§‹æ–‡
	mark:
å‰¥ã:stripã™ã‚‹:~
æ­£è¦è¡¨ç¾:regular expression::~
å¼:expression::~
çœç•¥:omission:~
çœç•¥ä¸å¯:omissibleã§ãªã„:~
é–‹å§‹tag:start tag::é–‹å§‹ tag:é–‹å§‹ã‚¿ã‚°
çµ‚äº†tag:end tag::çµ‚äº† tag:çµ‚äº†ã‚¿ã‚°
æ–‡:statement:~

	â—slot
shadow:
slot:
slottable:
	ã‚¹ãƒ­ãƒƒãƒˆ
å‰²å½“ã•ã‚Œ:assignã•ã‚Œ::ã‚ã¦ãŒã‚ã‚Œ
å‰²å½“ã™ã‚‹:assignã™ã‚‹::ã‚ã¦ãŒã†
å‰²å½“æ¸ˆã¿:assign æ¸ˆã¿::ã‚ã¦ãŒã„æ¸ˆã¿

	â—å‡¦ç†
	~scriptãªã—ã‚’å‰æã«:scriptless
ä¸æ´»:inert::~
	import:
å¤å…¸:classic::~::ã‚¯ãƒ©ã‚·ãƒƒã‚¯
å–è¾¼ã‚€:importã™ã‚‹::å–ã‚Šè¾¼ã‚€
å–è¾¼ã¾ã‚Œ:importã•ã‚Œ::å–ã‚Šè¾¼ã¾ã‚Œ
å–è¾¼ã‚ã‚‹:importã§ãã‚‹::å–ã‚Šè¾¼ã‚ã‚‹
é˜»ã¾ãš:non-blocking::~::éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°
é˜»ã¿:blockã—::~::ãƒ–ãƒ­ãƒƒã‚¯ã—
	é˜»ã¾ãªããªã‚‹:unblocked
	ä»–ã‚’é˜»ã¾ãªã„:non-blocking
	~~æ–¹å¼:fashion
	-:pending
é–‹å§‹æ¸ˆã¿:already started::~
æº–å‚™-:prepare::~
æº–å‚™:preparation::~
è§£æå™¨å®Ÿè¡Œæº–å‚™æ¸ˆã¿:ready to be parser-executed::è§£æå™¨å®Ÿè¡Œ æº–å‚™æ¸ˆã¿::ãƒ‘ãƒ¼ã‚µå®Ÿè¡Œ æº–å‚™æ¸ˆã¿
	parser-executed
	parser-inserted
	parsing-blocking
ç ´å£Šçš„æ›¸è¾¼:destructive-writes::ç ´å£Šçš„ãªæ›¸ãè¾¼ã¿

å®Ÿè¡Œng:executing::å®Ÿè¡Œ

	è©•ä¾¡-:evaluation
	ãã®ã¾ã¾:onward

	â—fetchï¼networkï¼ä¿å®‰
	äº‹å‰~fetching:prefetching
Content-Type:
nonce::::ãƒŠãƒ³ã‚¹
load:
æš—å·ç”¨:cryptographic::~
	é˜»æ­¢ã•ã‚Œã‚‹^i:Blocked

	â—å†…å®¹model
å¥ng:phrasing::å¥::ãƒ•ãƒ¬ãƒ¼ã‚¸ãƒ³ã‚°
é€éçš„:transparent::~
å¤–æ¥ã®:foreign::~
åˆ†é¡:category:~
	categories
æ–‡æ›¸åŒ–:documentation::~

	â—ä»•æ§˜

ä¸Šå“:graceful:~
å†—é•·:redundant:~
å›³å¼:schematic diagram:~

è‡ªæ˜:trivial:~
ä¸ç”¨æ„:accidental:~
å¤‰å‰‡çš„:strange:~
è¡çª:collision:~

ä»£ç†:proxy::~
ä¾å­˜ç‰©:dependencies:~
æç¤º-:present:~
é™¥ç©½:pitfall:~
é€€è¡Œ-:degrade:~
	-:relate
æµªè²»-:waste:~
é¸æŠçš„:selective:~
ç«¶åˆ-:conflict:~
æ¡ç”¨-:adopt:~
å…ã‚Œã‚‹:exemptã™ã‚‹:~

	è§£é‡ˆã—ç›´ã™:reinterpret
	ã»ã¼å®šç¾©ã•ã‚Œã¦ã„ãªã„:poorly-defined
	å¼·èª¿è¡¨ç¤º:highlight
	~~èª¬æ˜:illustrate
	hope
	interesting
	likely
	æ³¨ç›®ã™ã¹ã:notable
	potential
	put
	æ•£ã‚‰ã°ã£ã¦:scattered
	æ˜“ã:help
	é¢ã—ãŸ-:face:
	refer
	ã¡ã‚‡ã£ã¨ã—ãŸã“ã¨ã§æŠµè§¦ã—æ˜“ã:prone to triggering:
	ã“ã“ã§èµ·ãã¦ã„ã‚‹ã“ã¨:What is going on here 
	ã‘ã£ãŸã„ãªèª­ã¿ç‰©ã«å¤‰ãˆã¦ã—ã¾ã†more interesting reading experience
	chosen
	using
	-:Suppose
	è¨˜ã•ã‚Œ:put
	çµ‚ãˆ:finish 
	è¦‹ã‹ã‘ï¼æ§˜ã«è¦‹ãˆã‚‹:look 
	åˆ‡ã‚‹:turning off
	ãµã‚‹ã¾ã„:act
	-:encountered therein
	ã‚ˆã‚Šæ˜ç¢ºã«ã¯:for clarification
	ã‚¢ãƒªãªé™ã‚Šã™ãã«:as soon as possible
	å¯èƒ½æ€§ã‚‚ã‚ã‚‹:possible
	é€†ã«:conversely
	~~ç›´ã«è¨˜ã—ã¦:hard-coded
	accordingly
	ã²ã­ãã‚ŒãŸå–æ‰±ã„:contortion
	é¢¨å¤‰ã‚ã‚Šãª:exotic:
	å¾—ã‚‰ã‚Œã‚‹:gain
	no longer
	modulo
	namely
	ã–ã‚‹ã‚’å¾—ãªã:by necessity
	å½“é¢ã®é–“:meantimeï¼meanwhile
	å…·ä½“çš„ã«ã¯:for instance
	~~ç†è§£ã—ãŒãŸã„:weird
	ãã®å ´ã§:on-the-fly
	ç›´æ„Ÿã«åã™ã‚‹:unintuitive
	éƒ¨åˆ†ã‚‚ã‚ã‚‹:somewhat
	é•ã„:distinction
	maybe
	ä¸€æ–¹ã§:however
	ã«ãªã‚‹ã“ã¨ã‚‚ã‚ã‚‹:potentially
	note
	ãªã¾ãã‚‰:blunt instrument
	~codeç‰‡:snippet


	â—æœªåˆ†é¡
XSLT:
XPath:
essence:
column::::ã‚«ãƒ©ãƒ 
game::::ã‚²ãƒ¼ãƒ 
	jump::::
license::::ãƒ©ã‚¤ã‚»ãƒ³ã‚¹
	option
strict:
template:
table::::ãƒ†ãƒ¼ãƒ–ãƒ«
video::::ãƒ“ãƒ‡ã‚ª
ä»£ç”¨-:substitute::~
	ä»£ç”¨-:substitution
çµ‚äº†-:terminate:~
é€£çµ-:concatenate:~
	concatenation
é¸æŠ-:select:~
çµè¾¼ã‚“ã :filterã—ãŸ:çµã‚Šè¾¼ã‚“ã 
å‡¦ç†å‘½ä»¤:processing instruction:~
æ¢ç´¢:search::æ¤œç´¢
ãƒ‹ãƒ¥ãƒ¼ã‚¹ã‚µã‚¤ãƒˆ:news site::~

	-:destination
	å¢—æ¸›
	calling
	~cloneæ™‚ã®:cloning
	go
	going
	remain
	having
	labeled
	made
	marked
	é–‰ã˜ã‚‰ã‚ŒãŸ:closing
	å¯¾ã«:balance
	è¡Œã:go
	æ¢ã—ã¦look for
	æˆ»-:back 
	æ›¸-:write 
	ç¾ã‚Œ:appear 
	è©³ç´°è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹:show or hide
	ãªããªã‚‹:stop
	ç¯€:section 
	å¢—åˆ†:increment
	ã‚ˆã‚Šå¤§ããª:bigger
	direct-to-DOM
	non-empty

	â—æŒ‡ç¤ºèª
æ—§-:old:~
	æ—§-:older
	earlier
	ç•°ãªã‚‹:differently
	å´:side
	end
	left
	è¡Œ:line
	fifth
	forth
	four-column
	piece
	mostly
	nonetheles
	previously
	ä»Š:now
	å†’é ­:top
	å¾Œã§:later
	ä»–æ‰€:other parts
	ä¸€éƒ¨:part of
	ever
	entire
	amongst
	ã‚‚ã®:thing
	ä¸»ãªï¼ä¸»:main 
	2 :two 
	å°½ãã‚‹ã¾ã§ï¼Œthere are no ã€œ left
	neither
	part
	somehow
	sometime
	until:
	-å¤–:outside
	æœ«å°¾:the end
	åŒæ§˜:similar
	åºƒã:wide
	å‘¨ã‚Šã§:around
	å§‹ã‚è¿‘ã:near the beginning

â—â—html_code_list

â– script-2
<ï¼…script src="game-engine.js"><ï¼…/script>
<ï¼…script type="text/x-game-map">
........U.........e
o............A....e
.....A.....AAA....e
.A..AAA...AAAAA...e
<ï¼…/script>

â– script-3
<ï¼…script>
 function calculate(%form) {
   var %price = 832000;
   if (%form.elements.brakes.checked)
     %price += 160000;
   if (%form.elements.radio.checked)
     %price += 400000;
   if (%form.elements.turbo.checked)
     %price += 800000;
   if (%form.elements.sticker.checked)
     %price += 40000;
   %form.elements.result.value = price;
 }
<ï¼…/script>
<form
   name="pricecalc"
   onsubmit="return false"
   onchange="calculate(this)"
>
 <fieldset>
  <legend>è»Šä½“ä¾¡æ ¼ã‚’å†è¨ˆç®—ã™ã‚‹</legend>
  <p>åŸºæœ¬ä¾¡æ ¼ï¼š83 ä¸‡ 2000 å††</p>
  <p>è¿½åŠ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼š</p>
  <ul>
   <li><label><input type=checkbox name=brakes>
      ã‚»ãƒ©ãƒŸãƒƒã‚¯ãƒ–ãƒ¬ãƒ¼ã‚­ï¼ˆ 16 ä¸‡å††ï¼‰</label></li>
   <li><label><input type=checkbox name=radio>
      è¡›æ˜Ÿãƒ©ã‚¸ã‚ªï¼ˆ 40 ä¸‡å††ï¼‰</label></li>
   <li><label><input type=checkbox name=turbo>
      ã‚¿ãƒ¼ãƒœãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆ 80 ä¸‡å††ï¼‰</label></li>
   <li><label><input type=checkbox name=sticker>
      "XZ" ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ï¼ˆ 4 ä¸‡å††ï¼‰</label></li>
  </ul>
  <p>åˆè¨ˆä¾¡æ ¼ï¼š <output name=result></output> å††</p>
 </fieldset>
 <ï¼…script>
  calculate(document.forms.pricecalc);
 <ï¼…/script>
</form>

â– script-4
<ï¼…script type="module" src="app.mjs"><ï¼…/script>

â– script-5
<ï¼…script type="module" src="app.mjs"><ï¼…/script>
<ï¼…script nomodule defer src="classic-app-bundle.js"><ï¼…/script>

â– script-6
<ï¼…script type="module">
 import { walkAllTextNodeDescendants } from "./dom-utils.mjs";
ï¼…
 function substitute(%textNode) {
   %textNode.data = %textNode.data.replace( /ã€‚/g, "ã£ã½ã„ã€‚" );
 }
ï¼…
 walkAllTextNodeDescendants(document.body, substitute);
<ï¼…/script>

â– 
script-restrictions-1
script-restrictions-2
script-restrictions-3

â– inline-documentation-1
<ï¼…script src="cool-effects.js">
 // æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ï¼š
 //    var %e = new Effect();
 // åŠ¹æœã‚’é–‹å§‹ã™ã‚‹ï¼åœæ­¢ã™ã‚‹ã¨ãã¯ã€ .play() ï¼ .stop() ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ï¼š
 //    %e.play();
 //    %e.stop();
<ï¼…/script>

 // create new instances using:
 //    var e = new Effect();
 // start the effect using .play, stop using .stop:

â– noscript-1
<form action="calcSquare.php">
 <p>
  <label for=x>æ•°å€¤</label>:
  <input id="x" name="x" type="number">
 </p>
 <ï¼…script>
  var %x = document.getElementById('x');
  var %output = document.createElement('p');
  %output.textContent = 'æ•°å€¤ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚äºŒä¹—ã—ãŸçµæœãŒè¿”ã•ã‚Œã¾ã™ã€‚';
  %x.form.appendChild(%output);
  %x.form.onsubmit = function () { return false; }
  %x.oninput = function () {
    var %v = %x.valueAsNumber;
    %output.textContent = %v + ' ã®äºŒä¹—ã¯ ' + %v * %v ' ã§ã™ã€‚';
  };
 <ï¼…/script>
 <ï¼…noscript>
  <input type=submit value="äºŒä¹—ã‚’è¨ˆç®—ã™ã‚‹">
 <ï¼…/noscript>
</form>

Number
  output.textContent = 'Type a number; it will be squared right then!';


â– noscript-2
<form action="calcSquare.php">
 <p>
  <label for=x>æ•°å€¤</label>:
  <input id="x" name="x" type="number">
 </p>
 ï¼œ<input id="submit" type=submit value="äºŒä¹—ã‚’è¨ˆç®—ã™ã‚‹">ï¼
 <ï¼…script>
  var %x = document.getElementById('x');
  var %output = document.createElement('p');
  %output.textContent = 'æ•°å€¤ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚äºŒä¹—ã—ãŸçµæœãŒè¿”ã•ã‚Œã¾ã™ã€‚';
  %x.form.appendChild(%output);
  %x.form.onsubmit = function () { return false; }
  %x.oninput = function () {
    var %v = %x.valueAsNumber;
    %output.textContent = %v + ' ã®äºŒä¹—ã¯ ' + %v * %v ' ã§ã™ã€‚';
  };
  ï¼œvar %submit = document.getElementById('submit');ï¼
  ï¼œ%submit.parentNode.removeChild(%submit);ï¼
 <ï¼…/script>
</form>

â– template-1
<!doctype html>
<html lang="ja">
 <head>
  <title>å®¿é¡Œ</title>
 <body>
  <template id="template"><p>ğŸ˜€</p></template>
  <ï¼…script>
   let %num = 3;
   const %fragment =
      document.getElementById('template').content.cloneNode(true);
   while (%num -- > 1) {
     %fragment.firstChild.before(%fragment.firstChild.cloneNode(true));
     %fragment.firstChild.textContent += %fragment.lastChild.textContent;
   }
   document.body.appendChild(%fragment);
  <ï¼…/script>
</html>

â– template-2
<!DOCTYPE html>
<html lang='en'>
<title>Cat data</title>
<ï¼…script>
 // ã“ã“ã§ã¯ãƒ‡ãƒ¼ã‚¿ã‚’ç›´ã«è¨˜ã—ã¦ã„ã‚‹ãŒã€ã‚µãƒ¼ãƒã‹ã‚‰å¾—ã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
 var %data = [
   {
      name: 'Pillar',
      color: 'Ticked Tabby',
      sex: 'Female (neutered)',
      legs: 3
   },
   {
      name: 'Hedral',
      color: 'Tuxedo',
      sex: 'Male (neutered)',
      legs: 4
   },
 ];
<ï¼…/script>
<table>
 <thead>
  <tr>
   <th>Name <th>Colour <th>Sex <th>Legs
 <tbody>
  <template id="row">
   <tr><td><td><td><td>
  </template>
</table>
<ï¼…script>
 var %template = document.querySelector('#row');
 for (var %i = 0; %i < %data.length; %i += 1) {
   var %cat = data[%i];
   var %clone = %template.content.cloneNode(true);
   var %cells = %clone.querySelectorAll('td');
   %cells[0].textContent = %cat.name;
   %cells[1].textContent = %cat.color;
   %cells[2].textContent = %cat.sex;
   %cells[3].textContent = %cat.legs;
   %template.parentNode.appendChild(%clone);
 }
<ï¼…/script>


â—â—trans_metadata
<p>
~THIS_PAGEã¯ã€~WHATWGã«ã‚ˆã‚‹
HTML ä»•æ§˜ã®ï¼ˆ Â§ The elements of HTML å†…ã®ï¼‰
<a href="~SPEC_URL">Â§ Scripting</a>
ã‚’æ—¥æœ¬èªã«ç¿»è¨³ã—ãŸã‚‚ã®ã§ã™ã€‚
~PUB
</p>

</script>

</head>

<body>

<header id="head">
	<hgroup>
<h1>ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®åˆ©ç”¨ â€” Scripting</h1>

	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="scripting-3">
<h2 title="Scripting">4.12. ~scriptã®åˆ©ç”¨</h2>

<p>
~scriptã«ã‚ˆã‚Šã€ä½œè€…ã¯ï¼Œæ–‡æ›¸ã«å¯¾è©±æ€§ã‚’è¿½åŠ ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
Scripts allow authors to add interactivity to their documents.
</p>

<p>
ä½œè€…ã«ã¯ã€ã‚¢ãƒªãªæ‰€ã§ã¯ï¼Œ~scriptingã‚’ä»£æ›¿ã™ã‚‹å®£è¨€çš„ãªä»•çµ„ã¿ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹
â€” ãã†ã—ãŸæ–¹ãŒä¿å®ˆã—æ˜“ããªã‚‹ã“ã¨ãŒå¤šãã€ã¾ãŸï¼Œ~scriptingã‚’ä¸èƒ½åŒ–ã—ã¦ã„ã‚‹åˆ©ç”¨è€…ã‚‚å¤šãã„ã‚‹ã€‚
â—
Authors are encouraged to use declarative alternatives to scripting where possible, as declarative mechanisms are often more maintainable, and many users disable scripting.
</p>

<div class="example">
<p>
ä¾‹ãˆã°ã€~scriptã‚’åˆ©ç”¨ã—ã¦ï¼Œã‚ã‚‹ä¸€ç¯€ã®è©³ç´°è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹ä»£ã‚ã‚Šã«ã€
`details$e è¦ç´ ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
â—
For example, instead of using script to show or hide a section to show more details, the details element could be used.
</p>

</div>

<p>
ä½œè€…ã«ã¯ã¾ãŸã€~scripting~supportãŒç„¡ã„ä¸‹ã§ã¯ï¼Œè‡ªèº«ã®~appã‚’ä¸Šå“ã«é€€è¡Œã•ã›ã‚‹ã“ã¨ã‚‚å¥¨åŠ±ã•ã‚Œã‚‹ã€‚
â—
Authors are also encouraged to make their applications degrade gracefully in the absence of scripting support.
</p>

<div class="example">

<p>
ä¾‹ãˆã°ä½œè€…ã¯ã€~tableã®~headerå†…ã«ï¼Œ~tableã‚’å‹•çš„ã«~sortã—ç›´ã™ã‚ˆã†ãª~linkã‚’ä¾›ã—ã¦ã„ã‚‹å ´åˆã€~serverã«~sortæ¸ˆã¿ã®~tableã‚’è¦è«‹ã™ã‚‹ã“ã¨ã§ï¼Œ~scriptãªã—ã«~linkã‚’æ©Ÿèƒ½ã•ã›ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
â—
For example, if an author provides a link in a table header to dynamically resort the table, the link could also be made to function without scripts by requesting the sorted table from the server.
</p>

</div>

		<section id="_conventions">
<h3>ã€ã“ã®è¨³ã«å›ºæœ‰ã®è¡¨è¨˜è¦ç´„ã€‘</h3>

<p>
ã“ã®è¨³ã®ï¼Œ~algoã‚„å®šç¾©ã®è¨˜è¿°ã«åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹å„ç¨®è¨˜å·ï¼ˆ ~LET, Îµ, ~IF, ~THROW, ç­‰ã€…ï¼‰ã®æ„å‘³ã‚„å®šç¾©ã®è©³ç´°ã¯ã€~SYMBOL_DEF_REFã‚’~~å‚ç…§ã•ã‚ŒãŸã—ã€‚
</p>

<p>
`æ–‡æ›¸ç‰‡@
ã¯ã€ `DocumentFragment$I ~objã®ç•¥è¨˜ã§ã‚ã‚‹ã€‚
</p>

		</section>

		<section id="the-script-element">
<h3 title="The script element">4.12.1. `script^e è¦ç´ </h3>

<dl class="element-def">
	<dt>`åˆ†é¡$ï¼š</dt>
	<dd>
`~metadataå†…å®¹$ ï¼ `~flowå†…å®¹$ ï¼ `å¥ngå†…å®¹$ ï¼ `~scriptã‚’~supportã™ã‚‹è¦ç´ $
â—
Metadata content.
â—
Flow content.
â—
Phrasing content.
â—
Script-supporting element.
</dd>

	<dt>`ã“ã®è¦ç´ ã‚’åˆ©ç”¨ã§ãã‚‹æ–‡è„ˆ$ï¼š</dt>
	<dd>
`~metadataå†…å®¹$ ï¼
`å¥ngå†…å®¹$ ï¼
`~scriptã‚’~supportã™ã‚‹è¦ç´ $
ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€ã€‚
â—
Where metadata content is expected.
â—
Where phrasing content is expected.
â—
Where script-supporting elements are expected.
</dd>

	<dt>`å†…å®¹~model$ï¼š</dt>
	<dd>
`src$a å±æ€§ã‚’æœ‰ã•ãªã„å ´åˆã€ `type$a å±æ€§ã®å€¤ã«ã‚‚ä¾å­˜ã™ã‚‹ãŒï¼Œ`~scriptå†…å®¹~åˆ¶ç´„$ã«åˆè‡´ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
If there is no src attribute, depends on the value of the type attribute, but must match script content restrictions.
</dd>
	<dd>
`src$a å±æ€§ã‚’æœ‰ã™ã‚‹å ´åˆã€è¦ç´ ã¯ç©ºã«ã•ã‚Œã¦ã„ã‚‹ã‹, ã¾ãŸã¯
`~scriptå†…å®¹~åˆ¶ç´„$ã«ã‚‚åˆè‡´ã™ã‚‹ã‚ˆã†ãª`~scriptæ–‡æ›¸åŒ–$ã®ã¿ã‚’åŒ…å«ã—ã¦ã„ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
If there is a src attribute, the element must be either empty or contain only script documentation that also matches script content restrictions.
</dd>

	<dt>`text/html ã«ãŠã‘ã‚‹~tagçœç•¥$ï¼š</dt>
	<dd>
ä¸¡~tagã¨ã‚‚çœç•¥ä¸å¯ã€‚
â—
Neither tag is omissible.
</dd>

	<dt>`å†…å®¹~å±æ€§$ï¼š</dt>
	<dd>`å¤§åŸŸ~å±æ€§$
â—
Global attributes
</dd>
	<dd>
`src$a
â€” è³‡æºã®~address
â—
src â€” Address of the resource
</dd>
	<dd>
`type$a
â€” ~scriptã®ç¨®åˆ¥
â—
type â€” Type of script
</dd>
	<dd>
`nomodule$a
â€” `~module~script$ã‚’~supportã™ã‚‹~UAã«ãŠã‘ã‚‹å®Ÿè¡Œã‚’é˜²æ­¢ã™ã‚‹
â—
nomodule â€” Prevents execution in user agents that support module scripts
</dd>
	<dd>
`async$a
â€” ~scriptãŒå¯ç”¨ã«ãªã£ãŸã‚‰å®Ÿè¡Œã™ã‚‹
â€” ~fetchã—ã¦ã„ã‚‹é–“ã¯ä»–ã‚’é˜»ã‚€ã“ã¨ãªã
â—
async â€” Execute script when available, without blocking while fetching
</dd>
	<dd>
`defer$a
â€” ~scriptå®Ÿè¡Œã‚’å…ˆé€ã‚Šã™ã‚‹
â—
defer â€” Defer script execution
</dd>
	<dd>
`crossorigin$a
â€” è¦ç´ ãŒéåŒä¸€-ç”Ÿæˆå…ƒ è¦è«‹ã‚’ã©ã†å–æ‰±ã†ã‹
â—
crossorigin â€” How the element handles crossorigin requests
</dd>
	<dd>
`integrity$a
â€” `Subresource Integrity^cite `SRI$rï¼ˆä¸‹ä½è³‡æºã®å®Œå…¨æ€§ï¼‰æ¤œæŸ»ã«åˆ©ç”¨ã•ã‚Œã‚‹å®Œå…¨æ€§~metadata
â—
integrity â€” Integrity metadata used in Subresource Integrity checks [SRI]
</dd>

	<dd>
`referrerpolicy$a
â€” è¦ç´ ã«ã‚ˆã‚Šèµ·å‹•ã•ã‚ŒãŸ`~fetch$ç”¨ã®`~referreræ–½ç­–$
â—
referrerpolicy â€” Referrer policy for fetches initiated by the element
</dd>

	<dt>`~accessibilityã®è€ƒæ…®ç‚¹$</dt>
	<dd>
`script$AA
â—
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
<pre class="idl">
[Exposed=Window]
interface `HTMLScriptElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute USVString `src$m;
  [`CEReactions$] attribute DOMString `type$m;
  [`CEReactions$] attribute boolean `noModule$m;
  [`CEReactions$] attribute boolean `async$m;
  [`CEReactions$] attribute boolean `defer$m;
  [`CEReactions$] attribute DOMString? `crossOrigin$m;
  [`CEReactions$] attribute DOMString `text$m;
  [`CEReactions$] attribute DOMString `integrity$m;
  [`CEReactions$] attribute DOMString `referrerPolicy$m;

  // `HTMLScriptElement$obsMb
};
</pre>
	</dd>
</dl>

<p>
`script$e è¦ç´ ã«ã‚ˆã‚Šã€ä½œè€…ã¯ï¼Œæ–‡æ›¸~å†…ã«ï¼»
å‹•çš„~script ï¼ ~data~block
ï¼½ã‚’å«ã¾ã›ã‚‹ã“ã¨ãŒå¯èƒ½ã«ãªã‚‹ã€‚
ã“ã®è¦ç´ ã¯ã€åˆ©ç”¨è€…~å‘ã‘ã®å†…å®¹ã¯`è¡¨ç¾-$ã—ãªã„ã€‚
â—
The script element allows authors to include dynamic script and data blocks in their documents. The element does not represent content for the user.
</p>

<p>
`type@a
å±æ€§ã¯ã€è¡¨ç¾ã•ã‚Œã‚‹~scriptç¨®åˆ¥ã‚’~customåŒ–ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼š
â—
The type attribute allows customization of the type of script represented:
</p>

<ul>
	<li>
ã“ã®å±æ€§ã‚’çœç•¥ã—ãŸå ´åˆ, ã‚ã‚‹ã„ã¯
`~JS~MIMEå‹ã«~essenceåˆè‡´-$ã™ã‚‹ã‚‚ã®ã«è¨­å®šã—ãŸå ´åˆã€å½“ã®~scriptã¯`å¤å…¸~script$ã§ã‚ã‚‹ã¨ã•ã‚Œï¼Œ~JSã® `Script$P ~top-levelç”Ÿæˆè¦å‰‡ã«å‰‡ã£ã¦è§£é‡ˆã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
å¤å…¸~scriptã¯ã€
`src$a å±æ€§ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã«é™ã‚Šï¼Œï¼»
`async$a, `defer$a
ï¼½å±æ€§ã«å½±éŸ¿ã•ã‚Œã‚‹ã€‚
`type$a å±æ€§ã‚’è¨­å®šã™ã‚‹ã®ã¯å†—é•·ã§ã‚ã‚Šã€ä½œè€…ã¯ï¼Œä»£ã‚ã‚Šã«çœç•¥ã™ã‚‹ã¹ãã§ã‚ã‚‹ã€‚
â—
Omitting the attribute, setting it to the empty string, or setting it to a JavaScript MIME type essence match, means that the script is a classic script, to be interpreted according to the JavaScript Script top-level production. Classic scripts are affected by the async and defer attributes, but only when the src attribute is set. Authors should omit the type attribute instead of redundantly setting it.
</li>
	<li>
ã“ã®å±æ€§~å€¤ã‚’ï¼»
`~ASCIIå¤§å°ç„¡è¦–$ã§ `module^l ã«åˆè‡´ã™ã‚‹æ–‡å­—åˆ—
ï¼½ã«è¨­å®šã™ã‚‹ã“ã¨ã¯ã€å½“ã®~scriptãŒ`~module~script$ã«ãªã‚Šï¼Œ~JSã® `Module$P ~top-levelç”Ÿæˆè¦å‰‡ã«å‰‡ã£ã¦è§£é‡ˆã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
~module~scriptã¯ã€ `defer$a å±æ€§ã‹ã‚‰ã¯å½±éŸ¿ã•ã‚Œãªã„ãŒï¼Œ
`async$a å±æ€§ã‹ã‚‰ã¯å½±éŸ¿ã•ã‚Œã‚‹ï¼ˆ `src$a å±æ€§ã®çŠ¶æ…‹ã«é–¢ã‚ã‚‰ãšï¼‰ã€‚
â—
Setting the attribute to an ASCII case-insensitive match for the string "module" means that the script is a module script, to be interpreted according to the JavaScript Module top-level production. Module scripts are not affected by the defer attribute, but are affected by the async attribute (regardless of the state of the src attribute).
</li>
	<li>
ã“ã®å±æ€§~å€¤ã‚’ä»–ã®å€¤ã«è¨­å®šã—ãŸå ´åˆã€~scriptã¯
`~data~block@
ã§ã‚ã‚‹ã¨ã•ã‚Œï¼Œå‡¦ç†ã•ã‚Œãªããªã‚‹ã€‚
ã©ã® `script$e å±æ€§ã‚‚ï¼Œ~data~blockã«åŠ¹æœã‚’åŠã¼ã™ã“ã¨ã¯ãªã„ï¼ˆ `type$a è‡ªèº«ã¯é™¤ã„ã¦ï¼‰ã€‚
ä½œè€…ã¯ã€~data~blockã‚’~~æŒ‡ç¤ºã™ã‚‹ã¨ãã¯ï¼Œ`~JS~MIMEå‹ã«~essenceåˆè‡´-$ã—ãªã„`å¦¥å½“ãª~MIMEå‹~æ–‡å­—åˆ—$ã‚’åˆ©ç”¨ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
Setting the attribute to any other value means that the script is a data block, which is not processed. None of the script attributes (except type itself) have any effect on data blocks. Authors must use a valid MIME type string that is not a JavaScript MIME type essence match to denote data blocks.
</li>
</ul>

<p class="note">æ³¨è¨˜ï¼š
`~data~block$ã«ï¼Œ`å¦¥å½“ãª~MIMEå‹~æ–‡å­—åˆ—$ã‚’åˆ©ç”¨ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã¨ã™ã‚‹è¦ä»¶ã¯ã€å°†æ¥ã«èµ·ã“ã‚Šå¾—ã‚‹è¡çªã‚’é¿ã‘ã‚‹ãŸã‚ã«ã‚ã‚‹ã€‚
ã•ã‚‚ãªã‘ã‚Œã°ã€ã“ã®ä»•æ§˜ãŒï¼Œã„ã¤ã‹`~script$xã«è¿½åŠ çš„ãªç¨®åˆ¥ã‚’è¿½åŠ ã—ãŸå ´åˆã«ã€ãã‚Œã‚‰ãŒ
â€” å€¤ `module^l ãŒ`~module~script$ã‚’~~æŒ‡ç¤ºã™ã‚‹ã®ã¨åŒæ§˜ã« â€”
ä½•ã‹ã‚’èª˜ç™ºã—å¾—ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
ä»Šï¼Œå¦¥å½“ãª~MIMEå‹~æ–‡å­—åˆ—ã‚’åˆ©ç”¨ã—ã¦ãŠã‘ã°ã€~data~blockã¯ï¼Œå°†æ¥ã®~UAã‹ã‚‰ã‚‚ä½•ã‹åˆ¥ã®~scriptç¨®åˆ¥ã«è§£é‡ˆã—ç›´ã•ã‚Œãªã„ã“ã¨ã‚’ç¢ºä¿ã§ãã‚‹ã€‚
â—
The requirement that data blocks must be denoted using a valid MIME type string is in place to avoid potential future collisions. If this specification ever adds additional types of script, they will be triggered by setting the type attribute to something which is not a MIME type, like how the "module" value denotes module scripts. By using a valid MIME type string now, you ensure that your data block will not ever be reinterpreted as a different script type, even in future user agents.
</p>

<p>
ï¼»
`å¤å…¸~script$,
`~module~script$
ï¼½ä¸¡è€…ã¨ã‚‚ã€~inlineã«åŸ‹è¾¼ã‚€ã“ã¨ã‚‚ï¼Œ
`src@a
å±æ€§ã‚’æŒ‡å®šã—ã¦ å¤–éƒ¨~fileã‹ã‚‰å–è¾¼ã‚€ã“ã¨ã‚‚ã§ãã‚‹ã€‚
ã“ã® `src^a å±æ€§~å€¤ã¯ã€åˆ©ç”¨ã™ã‚‹å¤–éƒ¨~scriptè³‡æºã®`~URL$ã‚’ä¸ãˆã‚‹
â€” ãã®å€¤ã¯ã€`å‰å¾Œ~ç©ºç™½~å¯ã®å¦¥å½“ã‹ã¤ç©ºã§ãªã„~URL$ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
Classic scripts and module scripts can be embedded inline, or be imported from an external file using the src attribute, which if specified gives the URL of the external script resource to use. If src is specified, it must be a valid non-empty URL potentially surrounded by spaces.ï¼¼
</p>

<p>
ï¼»
~inline `script$e è¦ç´  ï¼ å¤–éƒ¨~scriptè³‡æº
ï¼½ã®å†…å®¹ã¯ã€ï¼»
`å¤å…¸~script$ã®å ´åˆã¯ ~JSä»•æ§˜ `JAVASCRIPT$r ã® `Script$P ç”Ÿæˆè¦å‰‡ï¼
`~module~script$ã®å ´åˆã¯ åŒ~ä»•æ§˜ã® `Module$P ç”Ÿæˆè¦å‰‡
ï¼½ã«ã‚ˆã‚‹è¦ä»¶ã«é©åˆã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The contents of inline script elements, or the external script resource, must conform with the requirements of the JavaScript specification's Script or Module productions, for classic scripts and module scripts respectively. [JAVASCRIPT]
</p>

<p>
`script$e è¦ç´ ã‚’ï¼Œ`~data~block$ã‚’å«ã¾ã›ã‚‹ãŸã‚ã«åˆ©ç”¨ã™ã‚‹å ´åˆï¼š
â—
When used to include data blocks,ï¼¼
</p>

<ul>
	<li>
~dataã¯ã€~inlineã«åŸ‹è¾¼ã¾ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
the data must be embedded inline,ï¼¼
</li>
	<li>
`type$a å±æ€§ã‚’åˆ©ç”¨ã—ã¦ï¼Œ~dataã®å½¢å¼ã‚‚ä¸ãˆãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
the format of the data must be given using the type attribute, andï¼¼
</li>
	<li>
è¦ç´ ã®å†…å®¹ã¯ã€åˆ©ç”¨ã•ã‚Œã‚‹å½¢å¼ã«å®šç¾©ã•ã‚Œã‚‹è¦ä»¶ã«é©åˆã—ã¦ã„ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
the contents of the script element must conform to the requirements defined for the format used.ï¼¼
</li>
	<li>
æ¬¡ã«æŒ™ã’ã‚‹å±æ€§ã¯ã€è¦ç´ ã«æŒ‡å®šã•ã‚Œã¦ã¯ãƒŠãƒ©ãƒŠã‚¤
â‡’
`src$a, `async$a, `nomodule$a, `defer$a, `crossorigin$a, `integrity$a, `referrerpolicy$a
â—
The src, async, nomodule, defer, crossorigin, integrity, and referrerpolicy attributes must not be specified.
</li>
</ul>

<p>
`nomodule@a
å±æ€§ã¯ï¼Œ`çœŸå½-å±æ€§$ã§ã‚ã‚Šã€`~module~script$ã‚’~supportã™ã‚‹~UAã«ãŠã„ã¦~scriptãŒå®Ÿè¡Œã•ã‚Œã‚‹ã®ã‚’é˜²æ­¢ã™ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€
<a href="#script-nomodule-example">ä¸‹ã®ä¾‹ã«ç¤ºã™</a>ã‚ˆã†ã«ï¼Œï¼»
ç¾ä»£ã®~UAã«ã¯`~module~script$,
æ—§-~UAã«ã¯`å¤å…¸~script$
ï¼½ã‚’é¸æŠçš„ã«å®Ÿè¡Œã•ã›ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
`nomodule$a å±æ€§ã¯ã€`~module~script$ä¸Šã«æŒ‡å®šã•ã‚Œã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ï¼ˆã¾ãŸï¼ŒæŒ‡å®šã•ã‚Œã¦ã‚‚ç„¡è¦–ã•ã‚Œã‚‹ï¼‰ã€‚
â—
The nomodule attribute is a boolean attribute that prevents a script from being executed in user agents that support module scripts. This allows selective execution of module scripts in modern user agents and classic scripts in older user agents, as shown below. The nomodule attribute must not be specified on module scripts (and will be ignored if it is).
</p>

<p>
`async@a,
`defer@a
å±æ€§ã¯ï¼Œ`çœŸå½-å±æ€§$ã§ã‚ã‚Šã€å½“ã®~scriptãŒã©ã†è©•ä¾¡ã•ã‚Œã‚‹ã¹ãã‹ã‚’æŒ‡ç¤ºã™ã‚‹ã€‚
`å¤å…¸~script$ã«å¯¾ã—ã¦ã¯ã€ä¸¡~å±æ€§ã¨ã‚‚æŒ‡å®šã—ã¦ãƒ¨ã‚¤
â€” ãŒã€ `src$a å±æ€§ã‚’æœ‰ã—ã¦ã„ãªã„å ´åˆã¯ï¼Œã©ã¡ã‚‰ã‚‚æŒ‡å®šã—ã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ã€‚
`~module~script$ã«å¯¾ã—ã¦ã¯ã€
`async$a å±æ€§ã¯æŒ‡å®šã—ã¦ã‚‚ãƒ¨ã‚¤ãŒï¼Œ
`defer$a å±æ€§ã¯æŒ‡å®šã—ã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The async and defer attributes are boolean attributes that indicate how the script should be evaluated. Classic scripts may specify defer or async, but must not specify either unless the src attribute is present. Module scripts may specify the async attribute, but must not specify the defer attribute.
</p>

<p>
ã“ã‚Œã‚‰ã®å±æ€§ã‚’åˆ©ç”¨ã—ã¦é¸æŠã•ã‚Œå¾—ã‚‹ï¼ã§ãã‚‹~modeã¨ã—ã¦ã‚¢ãƒªãªã‚‚ã®ã¯ã€~scriptç¨®åˆ¥ã«ä¾å­˜ã—ã¦ï¼Œã„ãã¤ã‹ã‚ã‚‹ï¼š
â—
There are several possible modes that can be selected using these attributes, and depending on the script's type.
</p>

<ul>
	<li>
<p>
`å¤å…¸~script$ã«å¯¾ã—ã¦ã¯ï¼š
â—
For classic scripts,ï¼¼
</p>

		<ul>
			<li>
è¦ç´ ã¯ `async$a å±æ€§ã‚’æœ‰ã™ã‚‹å ´åˆ
â‡’
~scriptã¯ï¼Œ~pageã®æ§‹æ–‡è§£æã¨`ä¸¦åˆ—çš„$ã«~fetchã•ã‚Œã€å¯ç”¨ã«ãªã‚Šæ¬¡ç¬¬ï¼Œè©•ä¾¡ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ï¼ˆæ§‹æ–‡è§£æãŒå®Œäº†ã™ã‚‹å‰ã«ã‚‚ãªã‚Šå¾—ã‚‹ï¼‰ã€‚
â—
if the async attribute is present, then the classic script will be fetched in parallel to parsing and evaluated as soon as it is available (potentially before parsing completes).ï¼¼
</li>
			<li>
è¦ç´ ã¯ `async$a å±æ€§ã‚’æœ‰ã•ãªã„ãŒï¼Œ `defer$a å±æ€§ã¯æœ‰ã™ã‚‹å ´åˆ
â‡’
~scriptã¯`ä¸¦åˆ—çš„$ã«~fetchã•ã‚Œï¼Œ~pageãŒæ§‹æ–‡è§£æã‚’çµ‚ãˆãŸæ™‚ç‚¹ã§è©•ä¾¡ã•ã‚Œã‚‹ã€‚
â—
If the async attribute is not present but the defer attribute is present, then the classic script will be fetched in parallel and evaluated when the page has finished parsing.ï¼¼
</li>
			<li>
è¦ç´ ã¯ä¸¡~å±æ€§ã¨ã‚‚æœ‰ã•ãªã„å ´åˆ
â‡’
~scriptã¯ï¼Œå³æ™‚ã«~fetchã•ã‚ŒãŸä¸Šã§è©•ä¾¡ã•ã‚Œã€ä¸¡è€…ã¨ã‚‚å®Œäº†ã™ã‚‹ã¾ã§~pageã®æ§‹æ–‡è§£æã‚’é˜»ã‚€ã“ã¨ã«ãªã‚‹ã€‚
â—
If neither attribute is present, then the script is fetched and evaluated immediately, blocking parsing until these are both complete.
</li>
		</ul>
	</li>
	<li>
<p>
`~module~script$ã«å¯¾ã—ã¦ã¯ï¼š
â—
For module scripts,ï¼¼
</p>

		<ul>
			<li>
è¦ç´ ã¯ `async$a å±æ€§ã‚’æœ‰ã™ã‚‹å ´åˆ
â‡’
~scriptã¨ãã®ã™ã¹ã¦ã®ä¾å­˜ç‰©
ã€~scriptãŒå–è¾¼ã‚€ä»–ã®~scriptã€‘
ã¯ï¼Œ~pageã®æ§‹æ–‡è§£æã¨`ä¸¦åˆ—çš„$ã«~fetchã•ã‚Œã€å¯ç”¨ã«ãªã‚Šæ¬¡ç¬¬ï¼Œè©•ä¾¡ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ï¼ˆæ§‹æ–‡è§£æãŒå®Œäº†ã™ã‚‹å‰ã«ã‚‚ãªã‚Šå¾—ã‚‹ï¼‰ã€‚
â—
if the async attribute is present, then the module script and all its dependencies will be fetched in parallel to parsing, and the module script will be evaluated as soon as it is available (potentially before parsing completes).ï¼¼
</li>
			<li>
ä»–ã®å ´åˆ
â‡’
~scriptã¨ãã®ä¾å­˜ç‰©ã¯ï¼Œæ§‹æ–‡è§£æã¨`ä¸¦åˆ—çš„$ã«~fetchã•ã‚Œã€~pageãŒæ§‹æ–‡è§£æã‚’çµ‚ãˆãŸæ™‚ç‚¹ã§è©•ä¾¡ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
Otherwise, the module script and its dependencies will be fetched in parallel to parsing and evaluated when the page has finished parsing.ï¼¼
</li>
			<li>
ï¼ˆ `defer$a å±æ€§ã«ã‚ˆã‚‹åŠ¹æœã¯ã€~module~scriptã«ã¯ãªã„ã€‚ï¼‰
â—
(The defer attribute has no effect on module scripts.)
</li>
		</ul>
	</li>
</ul>

<p>
ã“ã‚Œã‚‰ã™ã¹ã¦ã¯ã€æ¬¡ã®å›³å¼ã«è¦ç´„ã•ã‚Œã‚‹ï¼š
â—
This is all summarized in the following schematic diagram:
</p>

<figure>
<img
	src="HTML-resources/asyncdefer.svg"
	alt=""
	style="min-width:720px; min-height:220px;"
>
<figcaption style="font-size:smaller;">
å˜ã«
`&lt;script&gt;^s
ã¨è¨˜ã—ãŸå ´åˆã€æ§‹æ–‡è§£æã¯~fetchingã¨å®Ÿè¡Œã«ã‚ˆã‚Šä¸­æ–­ã•ã‚Œã‚‹ã€‚
`&lt;script defer&gt;^s
ã¨ã—ãŸå ´åˆã€æ§‹æ–‡è§£æã¨ä¸¦åˆ—çš„ã«~fetchã•ã‚Œï¼Œã™ã¹ã¦ã®æ§‹æ–‡è§£æã‚’çµ‚ãˆãŸå¾Œã«å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
`&lt;script async&gt;^s
ã¨ã—ãŸå ´åˆã€~fetchingã¯æ§‹æ–‡è§£æã¨ä¸¦åˆ—çš„ã«ãªã‚‹ãŒï¼Œæ§‹æ–‡è§£æã¯~scriptã®å®Ÿè¡Œã«ã‚ˆã‚Šä¸­æ–­ã•ã‚Œã‚‹ã€‚
`&lt;script type="module"&gt;^s
ã¨ã—ãŸå ´åˆã€
`&lt;script defer&gt;^s
ã¨ã—ãŸå ´åˆã¨é¡ä¼¼ã™ã‚‹ãŒï¼Œä¾å­˜ç‰©ã‚‚~fetchã•ã‚Œã‚‹ã€‚
`&lt;script type="module" async&gt;^s
ã¨ã—ãŸå ´åˆã€ä¾å­˜ç‰©ã®~fetchingã‚’ä¼´ã†ã“ã¨ã‚’é™¤ã„ã¦ï¼Œ
`&lt;script async&gt;^s
ã¨ã—ãŸå ´åˆã¨é¡ä¼¼ã™ã‚‹ã€‚
â—
With &lt;script&gt;, parsing is interrupted by fetching and execution. With &lt;script defer&gt;, fetching is parallel to parsing and execution takes place after all parsing has finished. And with &lt;script async&gt;, fetching is parallel to parsing but once it finishes parsing is interrupted to execute the script. The story for &lt;script type="module"&gt; is similar to &lt;script defer&gt;, but the dependencies will be fetched as well, and the story for &lt;script type="module" async&gt; is similar to &lt;script async&gt; with the extra dependency fetching.
</figcaption></figure>

<p></p>

<div class="note">
<p>æ³¨è¨˜ï¼š
ã“ã‚Œã‚‰ã®å±æ€§ã«å¯¾ã™ã‚‹æ­£ç¢ºãªå‡¦ç†ã®è©³ç´°ã®ã»ã¨ã‚“ã©ã¯ï¼Œæ­´å²çš„ãªç†ç”±ã«ã‚ˆã‚‹ã‚‚ã®ã§ã‚ã‚Šã€è‡ªæ˜ã§ãªã„éƒ¨åˆ†ã‚‚ã‚ã‚‹ï¼Œ~HTMLã®ã„ãã¤ã‚‚ã®å´é¢ãŒå­•ã¾ã‚Œã¦ã„ã‚‹ã€‚
ã—ãŸãŒã£ã¦ï¼Œå®Ÿè£…ã®è¦ä»¶ã¯ã€ã“ã®ä»•æ§˜~å…¨ä½“ã«æ•£ã‚‰ã°ã‚‰ã–ã‚‹ã‚’å¾—ãªããªã£ã¦ã„ã‚‹ã€‚
ï¼ˆã“ã®ç¯€ã®ï¼‰ä¸‹ã«ç¤ºã™å„ç¨®~algoã¯ï¼Œã“ã®å‡¦ç†ã®ä¸­æ ¸ã‚’è¿°ã¹ã‚‹ãŒã€ãã‚Œã‚‰ã®~algoã¨, æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ç­‰ã€…ã¨ã¯ï¼Œç›¸äº’ã«å‚ç…§ã—åˆã†ï¼š
</p>

<ul><li>
ï¼»
~HTMLå†… ï¼
<a href="~HTMLparsing#scriptForeignEndTag">å¤–æ¥ã®å†…å®¹~å†…</a> ï¼
<a href="~HTMLxml#scriptTagXML">~XMLå†…</a>
ï¼½ã«ãŠã‘ã‚‹ï¼»
`script$e ã®
<a href="~HTMLparsing#scriptTag">é–‹å§‹tag</a>,
<a href="~HTMLparsing#scriptEndTag">çµ‚äº†tag</a>
ï¼½ã«å¯¾ã™ã‚‹å„ç¨® æ§‹æ–‡è§£æ~è¦å‰‡
</li><li>`document.write()$m ~methodã®è¦å‰‡
</li><li>`~scripting$ ã®å–æ‰±ã„
</li></ul>
â—
The exact processing details for these attributes are, for mostly historical reasons, somewhat non-trivial, involving a number of aspects of HTML. The implementation requirements are therefore by necessity scattered throughout the specification. The algorithms below (in this section) describe the core of this processing, but these algorithms reference and are referenced by the parsing rules for script start and end tags in HTML, in foreign content, and in XML, the rules for the document.write() method, the handling of scripting, etc.
</div>

<p>
`async$a å±æ€§ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ä¸‹ã§ã‚‚ï¼Œ `defer$a å±æ€§ãŒæŒ‡å®šã•ã‚Œã¦ãƒ¨ã‚¤
â€” ãã†ã™ã‚‹ã“ã¨ã§ã€ï¼»
`defer$a ã¯~supportã™ã‚‹ãŒ `async$a ã¯~supportã—ãªã„ã‚ˆã†ãªï¼Œæ—§æ¥ã®~web~browser
ï¼½ã«ãŠã„ã¦ã‚‚ã€æ—¢å®šã§ã‚ã‚‹ä»–ã‚’é˜»ã‚€æŒ™å‹•ã«ä»£ãˆã¦ï¼Œ `defer$a ã«ã‚ˆã‚‹æŒ™å‹•ã«~fall-backã™ã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
The defer attribute may be specified even if the async attribute is specified, to cause legacy web browsers that only support defer (and not async) to fall back to the defer behavior instead of the blocking behavior that is the default.
</p>

<p>
`crossorigin@a
å±æ€§ã¯ã€`~CORSè¨­å®šç¾¤~å±æ€§$ã§ã‚ã‚‹ã€‚
ã“ã®å±æ€§ã¯ã€`å¤å…¸~script$ã«å¯¾ã—ã¦ã¯ï¼»
ä»–ã®`ç”Ÿæˆå…ƒ$ã‹ã‚‰å¾—ã•ã‚ŒãŸ~scriptã«ã‚ˆã‚‹~erroræƒ…å ±ãŒå…¬é–‹ã•ã‚Œã‚‹ã‹ã©ã†ã‹
ï¼½ã‚’åˆ¶å¾¡ã—ï¼Œ`~module~script$ã«å¯¾ã—ã¦ã¯ï¼»
éåŒä¸€-ç”Ÿæˆå…ƒ è¦è«‹ã«åˆ©ç”¨ã•ã‚Œã‚‹`è³‡æ ¼è¨¼~mode$
ï¼½ã‚’åˆ¶å¾¡ã™ã‚‹ã€‚
â—
The crossorigin attribute is a CORS settings attribute. For classic scripts, it controls whether error information will be exposed, when the script is obtained from other origins. For module scripts, it controls the credentials mode used for cross-origin requests.
</p>

<p class="note">æ³¨è¨˜ï¼š
`å¤å…¸~script$ã¨é•ã£ã¦ï¼Œ`~module~script$ã§ã¯ã€éåŒä¸€-ç”Ÿæˆå…ƒã¸~fetchã™ã‚‹ã¨ãã«ã¯ï¼Œ`~CORS~protocol$ã®åˆ©ç”¨ãŒè¦æ±‚ã•ã‚Œã‚‹ã€‚
â—
Unlike classic scripts, module scripts require the use of the CORS protocol for cross-origin fetching.
</p>

<p>
`integrity@a
å±æ€§ã¯ã€ï¼»
ã“ã®è¦ç´ ãŒæ‹…å½“ã™ã‚‹è¦è«‹
ï¼½ã®`å®Œå…¨æ€§~metadata$rqã‚’è¡¨ç¾ã™ã‚‹ã€‚
å€¤ã¯~textã§ã‚ã‚‹ã€‚
ã“ã®å±æ€§ã¯ã€ `src$a å±æ€§ã‚’æŒ‡å®šã—ã¦ã„ãªã„å ´åˆã«ã¯ï¼ŒæŒ‡å®šã—ã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ã€‚
`SRI$r
â—
The integrity attribute represents the integrity metadata for requests which this element is responsible for. The value is text. The integrity attribute must not be specified when the src attribute is not specified. [SRI]
</p>

<p>
`referrerpolicy@a å±æ€§ã¯`~referreræ–½ç­–~å±æ€§$ã§ã‚ã‚‹ã€‚
ãã®ç›®çš„ã¯ã€ï¼»
~script, ãŠã‚ˆã³
ãã‚ŒãŒå–è¾¼ã‚€~script
ï¼½ã‚’`~fetch$ã™ã‚‹ã¨ãã«åˆ©ç”¨ã•ã‚Œã‚‹`~referreræ–½ç­–$ã‚’è¨­å®šã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
`REFERRERPOLICY$r
â—
The referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when fetching the script, as well as any scripts imported from it. [REFERRERPOLICY]
</p>

<div class="example">
<p>
ä»–ã®ä¸‹ä½è³‡æºã§ã¯ãªãï¼Œå–è¾¼ã¾ã‚Œã‚‹~scriptã‚’~fetchã™ã‚‹ã¨ãã«åˆ©ç”¨ã•ã‚Œã‚‹ `script^e è¦ç´ ã®~referreræ–½ç­–ã®ä¾‹ï¼š
â—
An example of a script element's referrer policy being used when fetching imported scripts but not other subresources:
</p>

<pre class="lang-html">
&lt;script referrerpolicy="origin"&gt;
  fetch('/api/data');   /* <span class="comment">
`script^e ã®~referreræ–½ç­–ã§ã¯~fetchã•ã‚Œãªã„ã€‚
â—
not fetched with &lt;script&gt;'s referrer policy
</span> */
  import('./utils.mjs'); /* <span class="comment">
`script^e ã®~referreræ–½ç­–ï¼ˆã“ã®äº‹ä¾‹ã§ã¯ `origin^l ï¼‰ã§~fetchã•ã‚Œã‚‹ã€‚
â—
is fetched with &lt;script&gt;'s referrer policy ("origin" in this case)
</span> */
&lt;/script&gt;
</pre>

</div>

<p>
æ¬¡ã«æŒ™ã’ã‚‹å†…å®¹~å±æ€§ã‚’å‹•çš„ã«å¤‰æ›´ã—ã¦ã‚‚ï¼Œç›´æ¥çš„ãªåŠ¹æœã¯ãªã„
â€” ã“ã‚Œã‚‰ã®å±æ€§ã¯ã€ä¸‹ã«è¿°ã¹ã‚‹ç‰¹å®šã®æ™‚ç‚¹ã«é™ã‚Šåˆ©ç”¨ã•ã‚Œã‚‹
â‡’
`src$a,
`type$a,
`nomodule$a,
`async$a,
`defer$a,
`crossorigin$a,
`integrity$a,
`referrerpolicy$a
â—
Changing the src, type, nomodule, async, defer, crossorigin, integrity, and referrerpolicy attributes dynamically has no direct effect; these attributes are only used at specific times described below.
</p>

<div>
<p>
`src@m
~IDLå±æ€§ã¯ã€
`src$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
</p>

<p>
`type@m
~IDLå±æ€§ã¯ã€
`type$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
</p>

<p>
`defer@m
~IDLå±æ€§ã¯ã€
`defer$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
</p>

<p>
`integrity@m
~IDLå±æ€§ã¯ã€
`integrity$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
</p>
â—
The IDL attributes src, type, defer, and integrity, must each reflect the respective content attributes of the same name.
</div>

<p>
`referrerPolicy@m
~IDLå±æ€§ã¯ã€`æ—¢çŸ¥ãªå€¤ã®ã¿ã«åˆ¶é™ã•ã‚Œ$ã‚‹ä¸‹ã§ï¼Œ
`referrerpolicy$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.
</p>

<p>
`crossOrigin@m
~IDLå±æ€§ã¯ã€`æ—¢çŸ¥ãªå€¤ã®ã¿ã«åˆ¶é™ã•ã‚Œ$ã‚‹ä¸‹ã§ï¼Œ
`crossorigin$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.
</p>

<p>
`noModule@m
~IDLå±æ€§ã¯ã€
`nomodule$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The noModule IDL attribute must reflect the nomodule content attribute.
</p>

<p>
`async@m
~IDLå±æ€§ã¯ã€è¦ç´ ãŒéåŒæœŸã«å®Ÿè¡Œã•ã‚Œã‚‹ã‹ã©ã†ã‹ã‚’åˆ¶å¾¡ã™ã‚‹ï¼š
â—
The async IDL attribute controls whether the element will execute asynchronously or not.ï¼¼
</p>
<ul class="switch">
	<li>
<p>
ï¼»
ã‚³ãƒ¬ã®`é˜»ã¾ãš~flag$ ~EQ ~T
ï¼½ã®ä¸‹ã§ã¯ï¼š
â—
If the element's "non-blocking" flag is set, then,ï¼¼
</p>
		<ul>
			<li class="algo">
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ~T
â—
on getting, the async IDL attribute must return true, andï¼¼
</li>
			<li class="algo">
<p>
è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
</p>
				<ol>
					<li>
ã‚³ãƒ¬ã®`é˜»ã¾ãš~flag$ ~SET ~F
</li>
					<li>
~IFï¼»
æ‰€ä¸ã®å€¤ ~EQ ~F
ï¼½
â‡’
ã‚³ãƒ¬ã® `async$a å†…å®¹~å±æ€§ã‚’é™¤å»ã™ã‚‹
</li>
					<li>
~ELSE
â‡’
ã‚³ãƒ¬ã® `async$a å†…å®¹~å±æ€§ ~SET ç©º~æ–‡å­—åˆ—
</li>
				</ol>
â—
on setting, the "non-blocking" flag must first be unset, and then the content attribute must be removed if the IDL attribute's new value is false, and must be set to the empty string if the IDL attribute's new value is true.ï¼¼
</li>
		</ul>
	</li>
	<li>
ï¼»
ã‚³ãƒ¬ã®`é˜»ã¾ãš~flag$ ~EQ ~F
ï¼½ã®ä¸‹ã§ã¯
â‡’
`async$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
If the element's "non-blocking" flag is not set, the IDL attribute must reflect the async content attribute.
</li>
</ul>

<dl class="domintro">
	<dt>%script . `text$m [ = %value ]</dt>
	<dd>
è¦ç´ ã®`å­~textå†…å®¹$ã‚’è¿”ã™ã€‚
â—
Returns the child text content of the element.
</dd>
	<dd>
è¨­å®šã—ã¦ï¼Œè¦ç´ ã®å­ãŸã¡ã‚’æ‰€ä¸ã®å€¤ã«ç½®æ›ã§ãã‚‹ã€‚
â—
Can be set, to replace the element's children with the given value.
</dd>
</dl>

<div class="algo">
`text@m
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`å­~textå†…å®¹$
â—
The text attribute's getter must return this script element's child text content.
</div>

<div class="algo">
`text$m è¨­å®šå­~æ‰‹ç¶šãã¯
â‡’
ã‚³ãƒ¬ã®`å…¨~å†…å®¹ã‚’æ–‡å­—åˆ—ã«ç½®æ›ã™ã‚‹$( æ‰€ä¸ã®å€¤ )
â—
The text attribute's setter must string replace all with the given value within this script element.
</div>

<p class="note">æ³¨è¨˜ï¼š
`document.write()$m ~methodã‚’åˆ©ç”¨ã—ã¦æŒ¿å…¥ã•ã‚ŒãŸ `script$e è¦ç´ ã¯ã€
<a href="~HTMLparsing#document-written-scripts-intervention">é€šä¾‹çš„ã«ã¯</a>
å®Ÿè¡Œã•ã‚Œã‚‹ï¼ˆæ¦‚ã—ã¦ï¼Œãã®é–“ã¯ã€æ›´ãªã‚‹~scriptå®Ÿè¡Œã‚„~HTMLæ§‹æ–‡è§£æã¯ï¼Œé˜»ã¾ã‚Œã‚‹ï¼‰ã€‚ï¼»
`innerHTML$m ï¼ `outerHTML$m
ï¼½å±æ€§ã‚’åˆ©ç”¨ã—ã¦æŒ¿å…¥ã•ã‚ŒãŸã‚‚ã®ã¯ã€å…¨ãå®Ÿè¡Œã•ã‚Œãªã„ã€‚
â—
When inserted using the document.write() method, script elements usually execute (typically blocking further script execution or HTML parsing). When inserted using the innerHTML and outerHTML attributes, they do not execute at all.
</p>

<div class="example">

<p>
æ¬¡ã®ä¾‹ã«ã¯ã€ 2 å€‹ã® `script$e è¦ç´ 
â€” å¤–éƒ¨`å¤å…¸~script$ã‚’åŸ‹è¾¼ã‚€ã‚‚ã®, ãŠã‚ˆã³
`~data~block$ã¨ã—ã¦ä½•ã‚‰ã‹ã®~dataã‚’å«ã‚€ã‚‚ã® â€”
ãŒåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
In this example, two script elements are used. One embeds an external classic script, and the other includes some data as a data block.
</p>

`script-2^xCode

<p>
ã“ã®äº‹ä¾‹ã«ãŠã‘ã‚‹~dataã¯ã€ãã®~scriptã«ã‚ˆã‚Šï¼Œ~video~gameã®~mapã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ã§ã‚ã‚ã†
â€” ãŒã€ã“ã®ä»•æ–¹ã§åˆ©ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‚ã‘ã§ã¯ãªã„ï¼š
å®Ÿéš›ã®~map~dataã¯~pageã®ä»–æ‰€ã«åŸ‹è¾¼ã¾ã‚Œã¦ã„ã¦ã€ã“ã®~data~blockã¯ï¼Œå˜ã«åˆ©ç”¨è€…ãŒ ~game~mapã®ç‰¹å®š0ã®ç‰¹èƒ½ã‚’æ¢ã—æ˜“ãã™ã‚‹ãŸã‚ã¨ã—ã¦ï¼Œ~siteã®æ¢ç´¢~engineå‘ã‘ã«~~ç”¨æ„ã•ã‚ŒãŸã‚‚ã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚
â—
The data in this case might be used by the script to generate the map of a video game. The data doesn't have to be used that way, though; maybe the map data is actually embedded in other parts of the page's markup, and the data block here is just used by the site's search engine to help users who are looking for particular features in their game maps.
</p>

</div>

<div class="example">

<p>
æ¬¡ã®è¦‹æœ¬ã«ã€ `script$e è¦ç´ ã‚’åˆ©ç”¨ã—ã¦ã€æ–‡æ›¸ã®ä»–æ‰€ã‹ã‚‰åˆ©ç”¨ã•ã‚Œã‚‹é–¢æ•°ã‚’ `å¤å…¸~script$ã®ä¸€éƒ¨ã¨ã—ã¦å®šç¾©ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã™ã€‚
åŒæ™‚ã«ï¼Œåˆ¥ã® `script$e è¦ç´ ã‚’åˆ©ç”¨ã—ã¦ã€æ–‡æ›¸ãŒæ§‹æ–‡è§£æã•ã‚Œã¦ã„ã‚‹é–“ã«~scriptã‚’å‘¼å‡ºã™æ–¹æ³•ã‚‚ç¤ºã™
â€” ã“ã®äº‹ä¾‹ã§ã¯ã€~formã®å‡ºåŠ›ã‚’åˆæœŸåŒ–ã™ã‚‹ã€‚
â—
The following sample shows how a script element can be used to define a function that is then used by other parts of the document, as part of a classic script. It also shows how a script element can be used to invoke script while the document is being parsed, in this case to initialize the form's output.
</p>

`script-3^xCode

</div>

<div id="script-type-module-example-1" class="example">

<p>
æ¬¡ã®è¦‹æœ¬ã§ã¯ã€ `script$e è¦ç´ ã‚’åˆ©ç”¨ã—ã¦ï¼Œå¤–éƒ¨`~module~script$ã‚’å«ã¾ã›ã‚‹æ–¹æ³•ã‚’ç¤ºã™ã€‚
â—
The following sample shows how a script element can be used to include an external module script.
</p>

`script-4^xCode

<p>
ã“ã®~module, ãŠã‚ˆã³ãã®ã™ã¹ã¦ã®ä¾å­˜ç‰©ï¼ˆ~source~fileå†…ã® ~JS `import^c æ–‡ã‚’é€šã—ã¦è¡¨å‡ºã•ã‚Œã‚‹ï¼‰ã¯ã€~fetchã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
çµæœã®~module~graphå…¨ä½“ãŒå–è¾¼ã¾ã‚Œï¼Œæ–‡æ›¸ãŒæ§‹æ–‡è§£æã‚’çµ‚ãˆãŸãªã‚‰ã€
`app.mjs^s ã®å†…å®¹ã¯è©•ä¾¡ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
This module, and all its dependencies (expressed through JavaScript import statements in the source file), will be fetched. Once the entire resulting module graph has been imported, and the document has finished parsing, the contents of app.mjs will be evaluated.
</p>

<p>
åŠ ãˆã¦ï¼ŒåŒã˜ `Window$I å†…ã®åˆ¥ã® `script$e è¦ç´ ã‹ã‚‰ã®~codeãŒ
`app.mjs^s ã‹ã‚‰ã®~moduleã‚’å–è¾¼ã‚€å ´åˆï¼ˆä¾‹ï¼š `import "./app.mjs";^s ã‚’ä»‹ã—ã¦ï¼‰ã€å‰è€…ã® `script$e è¦ç´ ã«ã‚ˆã‚Šä½œæˆã•ã‚ŒãŸåŒã˜`~module~script$ãŒå–è¾¼ã¾ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
Additionally, if code from another script element in the same Window imports the module from app.mjs (e.g. via import "./app.mjs";), then the same module script created by the former script element will be imported.
</p>

</div>

<div id="script-nomodule-example" class="example">
<p>
ç¾ä»£ã®~UAç”¨ã«ã¯`~module~script$,
æ—§-~UAç”¨ã«ã¯`å¤å…¸~script$ã‚’å«ã¾ã›ã‚‹ä¾‹ã‚’ç¤ºã™ï¼š
â—
This example shows how to include a module script for modern user agents, and a classic script for older user agents:
</p>

`script-5^xCode

<p>
`~module~script$ã‚’~supportã™ã‚‹ç¾ä»£ã®~UAã§ã¯ã€å‰è€…ã® `script$e è¦ç´ ï¼ˆ `type$a å±æ€§ã¯ `module^l ï¼‰ã¯ï¼Œ~fetchã•ã‚ŒãŸä¸Šã§ ï¼ˆ`~module~script$ã¨ã—ã¦ï¼‰è©•ä¾¡ã•ã‚Œã‚‹ä¸€æ–¹ã§ã€å¾Œè€…ã® `script$e è¦ç´ ï¼ˆ `nomodule$a å±æ€§ã‚’æœ‰ã™ã‚‹ï¼‰ã¯ç„¡è¦–ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
é€†ã«ï¼Œæ—§-~UAã«ã¨ã£ã¦ã¯ã€å‰è€…ã¯ï¼ŒæœªçŸ¥ãª~scriptå‹ãªã®ã§ç„¡è¦–ã™ã‚‹ã“ã¨ã«ãªã‚‹
â€” ãŒã€ `nomodule$a å±æ€§ã¯å®Ÿè£…ã—ã¦ã„ãªã„ã®ã§ï¼Œå¾Œè€…ã‚’ï¼ˆ`å¤å…¸~script$ã¨ã—ã¦ï¼‰~fetchã—ã¦è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã¯å•é¡Œã¯ãªã„ã€‚
â—
In modern user agents that support module scripts, the script element with the nomodule attribute will be ignored, and the script element with a type of "module" will be fetched and evaluated (as a module script). Conversely, older user agents will ignore the script element with a type of "module", as that is an unknown script type for them â€” but they will have no problem fetching and evaluating the other script element (as a classic script), since they do not implement the nomodule attribute.
</p>
</div>

<div id="script-type-module-example-2" class="example">

<p>
æ¬¡ã®è¦‹æœ¬ã«ã€`script$e è¦ç´ ã‚’åˆ©ç”¨ã—ã¦ã€ï¼ˆä¾‹ãˆã°ï¼Œãƒ‹ãƒ¥ãƒ¼ã‚¹ã‚µã‚¤ãƒˆä¸Šã®ï¼‰æ–‡æ›¸~å†…ã®~textã‚’æ›–æ˜§ãªèª­ã¿ç‰©ã§ä»£ç”¨ã—ã¦ã—ã¾ã†ã‚ˆã†ãªï¼Œ~inlineãª`~module~script$ã‚’æ›¸ãæ–¹æ³•ã‚’ç¤ºã™ï¼š
ã€ï¼[XKCD1288]ã€‘
â—
The following sample shows how a script element can be used to write an inline module script that performs a number of substitutions on the document's text, in order to make for a more interesting reading experience (e.g. on a news site): [XKCD1288]
</p>

`script-6^xCode

<div class="p">

<p>
~JS~module~scriptã‚’åˆ©ç”¨ã—ã¦å¾—ã‚‰ã‚Œã‚‹ç‰¹èƒ½ã®ã†ã¡ï¼Œæ³¨ç›®ã™ã¹ãã‚‚ã®ã«ã¯ã€æ¬¡ãŒæŒ™ã’ã‚‰ã‚Œã‚‹ï¼š
</p>

<ul><li>ä»–ã®~JS~moduleã‹ã‚‰é–¢æ•°ã‚’å–è¾¼ã‚€èƒ½ã€‚
</li><li>æ—¢å®šã§~strict~modeã«ãªã‚‹ã€‚
</li><li>~top-levelå®£è¨€ã§ã‚ã£ã¦ã‚‚ï¼Œ`å¤§åŸŸ~obj$ä¸Šã«æ–°ãŸãª~propã‚’å°å…¥ã—ãªã„ã€‚
</li></ul>
â—
Some notable features gained by using a module script include the ability to import functions from other JavaScript modules, strict mode by default, and how top-level declarations do not introduce new properties onto the global object. ï¼¼
</div>

<p>
ã¾ãŸï¼Œã“ã® `script$e è¦ç´ ãŒæ–‡æ›¸~å†…ã®ã©ã“ã«ç¾ã‚Œã‚ˆã†ãŒã€ï¼»
æ–‡æ›¸~æ§‹æ–‡è§£æãŒå®Œäº†ã—ã¦ï¼ŒãªãŠã‹ã¤
ãã®ä¾å­˜ç‰©ï¼ˆã“ã®ä¾‹ã§ã¯ `dom-utils.mjs^s ï¼‰ãŒ~fetchã•ã‚Œ, è©•ä¾¡ã•ã‚Œã‚‹
ï¼½ã¾ã§ã¯ï¼Œè©•ä¾¡ã•ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã€‚
â—
Also note that no matter where this script element appears in the document, it will not be evaluated until both document parsing has complete and its dependency (dom-utils.mjs) has been fetched and evaluated.
</p>

</div>

			<section id="script-processing-model">
<h4 title="Processing model">4.12.1.1. å‡¦ç†~model</h4>

<p>
`script$e è¦ç´ ã«ã¯ã€ãã®å„ç¨® çŠ¶æ…‹ã‚’~~ä¿æŒã™ã‚‹ã‚‚ã®ã¨ã—ã¦ï¼Œæ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â€” åˆæœŸ~æ™‚ã«ã¯ã€ãã‚Œãã‚Œï¼Œæ‹¬å¼§å†…ã«ç¤ºã•ã‚Œã‚‹å€¤ã«ãªã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
A script element has several associated pieces of state.
</p>

<p class="trans-note">ã€
åˆæœŸ~æ™‚ã®å€¤ãŒç„¡ã„ã‚‚ã®ã¯ã€~scriptãŒå®Ÿè¡Œã•ã‚Œãªã„å ´åˆï¼Œè¨­å®šã•ã‚Œã‚‹ã¨ã¯é™ã‚‰ãªã„ï¼ˆ `type$a å±æ€§ã®å€¤ãŒå¦¥å½“ã§ãªã„å ´åˆã®`~scriptç¨®åˆ¥$ãªã©ï¼‰ã€‚
ã€‘</p>

<dl>
	<dt>`é–‹å§‹æ¸ˆã¿~flag@ ï¼ˆ ~F ï¼‰</dt>
	<dd>
ã“ã®~flagã¯ã€~script~blockã®å®Ÿè¡Œã¯ï¼Œã™ã§ã«é–‹å§‹ã•ã‚ŒãŸã‹ã©ã†ã‹ã‚’æŒ‡ç¤ºã™ã‚‹ã€‚
ï¼ˆ~script~blockã®ä½œæˆ-æ™‚ã«ã¯ â€œé–‹å§‹æ¸ˆã¿â€ ã§ãªã„ï¼‰ã€‚
ï¼»
`script$e è¦ç´ ~ç”¨ã®`~cloneæ™‚ã®æ‰‹ç¶šã$ã‹ã‚‰å¾—ã‚‰ã‚Œã‚‹è¤‡è£½
ï¼½ã®`é–‹å§‹æ¸ˆã¿~flag$ã¯ã€~cloneå…ƒ~ã®è¦ç´ ã®ãã‚Œã‚’å¼•ãç¶™ããƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The first is a flag indicating whether or not the script block has been "already started". Initially, script elements must have this flag unset (script blocks, when created, are not "already started"). The cloning steps for script elements must set the "already started" flag on the copy if it is set on the element being cloned.
</dd>

	<dt>`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸@ï¼ˆ ~NULL ï¼‰</dt>
	<dd>
~NULL ã¾ãŸã¯`æ–‡æ›¸$ã€‚
ã“ã‚Œã¯ã€ï¼»
`~HTMLæ§‹æ–‡è§£æå™¨$ ï¼ `~XMLæ§‹æ–‡è§£æå™¨$
ï¼½ã«ã‚ˆã‚Šè¦ç´ ãŒæŒ¿å…¥ã•ã‚Œã‚‹ã¨ãè¨­å®šã•ã‚Œã€è¦ç´ ã®å‡¦ç†ã«å½±éŸ¿ã™ã‚‹ã€‚
~NULL ã§ãªã„ã¨ãã€å½“ã® `script$e è¦ç´ ã¯
`æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸ@
ã¨ã‚‚ã„ã†ã€‚
â—
A script element has a parser document, which is either null or a Document. Initially, its value must be null. It is set by the HTML parser and the XML parser on script elements they insert, and affects the processing of those elements. script elements with non-null parser documents are known as "parser-inserted".
</dd>

	<dt>`é˜»ã¾ãš~flag@ ï¼ˆ ~T ï¼‰</dt>
	<dd>
ã“ã®~flagã¯ã€è¦ç´ ãŒ â€œä»–ã‚’é˜»ã¾ãªããªã‚‹â€ ã‹ã©ã†ã‹ã‚’æŒ‡ç¤ºã™ã‚‹ã€‚
ï¼»
`~HTMLæ§‹æ–‡è§£æå™¨$ ï¼ `~XMLæ§‹æ–‡è§£æå™¨$
ï¼½ã¯ã€è‡ªèº«ãŒæŒ¿å…¥ã™ã‚‹ `script$e è¦ç´ ã«å¯¾ã—ï¼Œã“ã®~flagã‚’ ~F ã«ã™ã‚‹ã€‚
åŠ ãˆã¦ã€ã“ã®~flagãŒ ~T ã«ã•ã‚ŒãŸ `script$e è¦ç´ ã«
`async$a å†…å®¹~å±æ€§ãŒè¿½åŠ ã•ã‚ŒãŸã¨ãã¯ã€ãã®è¦ç´ ã®`é˜»ã¾ãš~flag$ã‚’ ~F ã«ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
A script element has a flag indicating whether the element will be "non-blocking". Initially, script elements must have this flag set. It is unset by the HTML parser and the XML parser on script elements they insert. In addition, whenever a script element whose "non-blocking" flag is set has an async content attribute added, the element's "non-blocking" flag must be unset.
</dd>
	<dd class="trans-note">ã€
â€œé˜»ã¾ãšï¼ˆ `non-blocking^en ï¼‰â€
ä½•ãŒä½•ã‚’é˜»ã¾ãªã„ã‹ãŒå¤šç¾©çš„ã§ã€æ›–æ˜§ãªç”¨èªã§ã‚‚ã‚ã‚‹ã€‚
{ å½“ã®~scriptã®~fetching, å½“ã®~scriptã®å®Ÿè¡Œng }
ã¨
{ ~pageã®æ§‹æ–‡è§£æ, ä»–ã®è³‡æºã®~fetching, ä»–ã®~scriptã®å®Ÿè¡Œng }
ã¨ã®é–“ã§ç¨®ã€…ã®çµ„ã¿åˆã‚ã›ãŒè€ƒãˆã‚‰ã‚Œã‚‹ã€‚
ã€‘</dd>

	<dt>`è§£æå™¨å®Ÿè¡Œæº–å‚™æ¸ˆã¿~flag@ ï¼ˆ ~F ï¼‰</dt>
	<dd>
ã“ã®~flagã¯ã€ï¼»
æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚Šï¼Œ~script~blockã‚’å®Ÿè¡Œã™ã‚‹ç”¨æ„ãŒæ•´ã£ãŸ
ï¼½ã‹ã©ã†ã‹ã‚’æŒ‡ç¤ºã™ã‚‹ã€‚
ï¼ˆ~script~blockã®ä½œæˆ-æ™‚ã«ã¯ã€ â€œå®Ÿè¡Œã™ã‚‹ç”¨æ„ã¯æ•´ã£ã¦â€ ã„ãªã„ï¼‰ã€‚
ã“ã®~flagã¯ï¼Œæ§‹æ–‡è§£æå™¨ãŒå½“ã®~scriptã‚’ã„ã¤å®Ÿè¡Œã™ã‚‹ã‹çŸ¥ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã‚ã‚Šã€è¦ç´ ãŒ`æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸ$å ´åˆã«é™ã‚Šï¼Œåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
A script element has a flag indicating whether or not the script block is "ready to be parser-executed". Initially, script elements must have this flag unset (script blocks, when created, are not "ready to be parser-executed"). This flag is used only for elements that are also "parser-inserted", to let the parser know when to execute the script.
</dd>

	<dt>`~scriptç¨®åˆ¥@</dt>
	<dd>
`classic^l, `module^l
ã®ã„ãšã‚Œã‹ã€‚
ã“ã‚Œã¯ã€`~scriptã‚’æº–å‚™ã™ã‚‹$ã¨ãã«ï¼Œè¦ç´ ã® `type$a å±æ€§ã«åŸºã¥ã„ã¦æ±ºå®šã•ã‚Œã‚‹ã€‚
â—
The script's type for a script element is either "classic" or "module". It is determined when the script is prepared, based on the type attribute of the element at that time.
</dd>

	<dt>`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸@</dt>
	<dd>
`~scriptã‚’æº–å‚™ã™ã‚‹$~algoã®å§‹ã‚è¿‘ãã§æ±ºå®šã•ã‚Œã‚‹`æ–‡æ›¸$ã€‚
ã“ã‚Œã¯ã€ãã®~algoã®é–“ã«ä»–ã®æ–‡æ›¸ã¸ç§»å‹•ã—ãŸ~scriptãŒï¼Œ`~script~blockã‚’å®Ÿè¡Œã™ã‚‹$ã®ã‚’é˜²æ­¢ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
A script element has a preparation-time document, which is a Document determined near the beginning of the prepare a script algorithm. It is used to prevent scripts that move between documents during preparation from executing.
</dd>

	<dt>`å¤–éƒ¨~file~flag@</dt>
	<dd>
ã“ã®~flagã¯ã€~scriptãŒå¤–éƒ¨~fileã‹ã‚‰ã®ã‚‚ã®ã‹ã©ã†ã‹ã‚’æŒ‡ç¤ºã™ã‚‹ã€‚
ã“ã®~flagã¯ã€`~scriptã‚’æº–å‚™ã™ã‚‹$ã¨ãã«ï¼Œè¦ç´ ã® `src$a å±æ€§ã«åŸºã¥ã„ã¦æ±ºå®šã•ã‚Œã‚‹ã€‚
â—
A script element has a flag indicating whether or not the script is from an external file. It is determined when the script is prepared, based on the src attribute of the element at that time.
</dd>

	<dt>`~script@</dt>
	<dd>
~NULL ã¾ãŸã¯ `script$e è¦ç´ ã‚’`æº–å‚™-$ã—ãŸçµæœã®`~script$xã€‚
ã“ã‚Œã¯ã€ï¼»
`å¤å…¸~script$ï¼~module~graph
ï¼½ãŒéåŒæœŸã«~fetchã•ã‚ŒãŸå¾Œã«ï¼Œãã‚ŒãŒï¼»
æˆåŠŸã—ãŸå ´åˆã¯ `~script$x ï¼
å¤±æ•—ã—ãŸå ´åˆã¯ ~NULL
ï¼½ã«è¨­å®šã•ã‚Œã‚‹ã€‚
ãã®æ™‚ç‚¹ã§ã€ `script^e ã¯ï¼Œ~fetching~algoã«ã‚ˆã‚Š
`æº–å‚™æ¸ˆã¿@
ã«ã•ã‚Œã€ä»–ã®å‹•ä½œã‚’èª˜ç™ºã—å¾—ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
~UAã¯ã€ `script^e è¦ç´ ãŒ`æº–å‚™æ¸ˆã¿$ã«ãªã‚‹ã¾ã§ï¼Œãã®`~nodeæ–‡æ›¸$ã®`~load~eventã‚’é…å»¶-$ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The script's script for a script element is either null or a script resulting from preparing the element. This is set asynchronously after the classic script or module graph is fetched. Once it is set, either to a script in the case of success or to null in the case of failure, the fetching algorithms will note that the script is ready, which can trigger other actions. The user agent must delay the load event of the element's node document until the script is ready.
</dd>
	<dd class="trans-note">ã€
åŸæ–‡ã§ã¯ â€œscript's scriptâ€
ï¼ˆ ~scriptã®~script ï¼ˆãŠãã‚‰ãï¼Œ â€œ`script$e è¦ç´ ã®`~script$xâ€ ã®æ„ï¼‰ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŒã€è¡¨è¨˜~ä¸Šã®éƒ½åˆã«ã‚ˆã‚Šï¼Œã“ã“ã§ã¯å˜ã« â€œã€œã®~scriptâ€ ã¨è¡¨è¨˜ã™ã‚‹ï¼ˆ â€œã€œâ€ ã«ã¯å¸¸ã«ï¼Œã‚ã‚‹ `script^e è¦ç´ ãŒè¨˜ã•ã‚Œã‚‹ï¼‰ã€‚
ã€‘</dd>

</dl>

<hr>

<p>
`script$e è¦ç´  %S ãŒï¼»
ãã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$ ~NEQ ~NULL
ï¼½ã‚’æº€ãŸã™ä¸‹ã§ï¼Œæ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹ãŒç”Ÿã˜ãŸã¨ãã¯ï¼Œ~UAã¯ `å³æ™‚$ã« %S ã‚’`æº–å‚™-$ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
When a script element that is not "parser-inserted" experiences one of the events listed in the following list, the user agent must immediately prepare the script element:
</p>

<ul>
	<li>
%S ãŒ`æ¥ç¶šã•ã‚ŒãŸ$ã¨ãã€‚
â—
The script element becomes connected.
</li>
	<li>
%S ã¯`æ¥ç¶šã•ã‚Œã¦$ã„ã‚‹ä¸‹ã§ã€
%S ã®ä¸­ã«ï¼Œä½•ã‚‰ã‹ã®~nodeã‹`æ–‡æ›¸ç‰‡$ãŒ`æŒ¿å…¥ã•ã‚ŒãŸ$nodeæ™‚ç‚¹ã€‚
ãŸã ã—ï¼Œä»–ã® `script$e è¦ç´ ãŒåŒæ™‚ã«`æŒ¿å…¥ã•ã‚ŒãŸ$nodeå ´åˆã¯ã€ãã‚Œã‚‰ã‚ˆã‚Šå¾Œã®æ™‚ç‚¹ã¨ã™ã‚‹ã€‚
â—
The script element is connected and a node or document fragment is inserted into the script element, after any script elements inserted at that time.
</li>
	<li>
%S ã¯`æ¥ç¶šã•ã‚Œã¦$ã„ã‚‹, ã‹ã¤
%S ã¯ `src$a å±æ€§ã‚’æœ‰ã—ã¦ã„ãªã„ä¸‹ã§ã€ãã®å±æ€§ãŒ %S ä¸Šã«è¨­å®šã•ã‚ŒãŸæ™‚ç‚¹ã€‚
â—
The script element is connected and has a src attribute set where previously the element had no such attribute.
</li>
</ul>

<!--%æº–å‚™ -->

<div class="algorithm">
<p>
`~scriptã‚’æº–å‚™ã™ã‚‹@
ã¨ãã¯ã€~UAã¯æ¬¡ã«å¾“ã£ã¦å‹•ä½œã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
To prepare a script, the user agent must act as follows:
</p>

<ol>
	<li>
<p>
å„ç¨® å¤‰æ•°ï¼š
</p>
		<ol>
			<li>
%S ~LET å½“ã® `script$e è¦ç´ 
</li>
			<li>
%æ–‡æ›¸ ~LET %S ã®`~nodeæ–‡æ›¸$
</li>
			<li>
`async@V ~LET ï¼»
%S ã¯ `async$a å±æ€§ã‚’æœ‰ã™ã‚‹ãªã‚‰ã° ~T ï¼
~ELSE_ ~F
ï¼½
</li>
			<li>
`src@V ~LET ï¼»
%S ã¯ `src$a å±æ€§ã‚’æœ‰ã™ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
~ELSE_ Îµ
ï¼½
</li>
		</ol>
â—
â†“</li>
	<li>
~IFï¼»
%S ã®`é–‹å§‹æ¸ˆã¿~flag$ ~EQ ~T
ï¼½
â‡’
~RET
â€” ~scriptã¯å®Ÿè¡Œã•ã‚Œãªã„
â—
If the script element is marked as having "already started", then return. The script is not executed.
</li>
	<li>
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~LET %S ã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$
â—
Let parser document be the element's parser document.
</li>
	<li>
<p>
%S ã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$ ~SET ~NULL
â—
Set the element's parser document to null.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ®µã¯ã€ï¼»
`æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸ$ `script$e è¦ç´ ã‚’å½“ã®æ§‹æ–‡è§£æå™¨ãŒèµ°ã‚‰ã›ã‚ˆã†ã¨è©¦è¡Œã—ã¦å¤±æ•—ã—ãŸå ´åˆï¼ˆä¾‹ï¼š ç©ºã‚ã‚‹ã„ã¯, æœª~supportãª~scriptingè¨€èªã‚’æŒ‡å®šã—ã¦ã„ãŸï¼‰
ï¼½ã«ï¼Œå¾Œã§ï¼»
åˆ¥ã®~scriptãŒãã‚Œã‚’å¤‰ç•°ã•ã›ã¦å†åº¦~èµ°ã‚‰ã™
ï¼½ã“ã¨ã‚’å¯èƒ½ã«ã™ã‚‹ãŸã‚ã«è¡Œã‚ã‚Œã‚‹ã€‚
â—
This is done so that if parser-inserted script elements fail to run when the parser tries to run them, e.g. because they are empty or specify an unsupported scripting language, another script can later mutate them and cause them to run again.
</p>
	</li>
	<li>
<p>
~IFï¼»
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~NEQ ~NULL
ï¼½~ANDï¼»
`async$V ~EQ ~F
ï¼½
â‡’
%S ã®`é˜»ã¾ãš~flag$ ~SET ~T
â—
If parser document is non-null and the element does not have an async attribute, then set the element's "non-blocking" flag to true.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ®µã¯ã€ï¼»
`æ§‹æ–‡è§£æå™¨ã«ã‚ˆã‚ŠæŒ¿å…¥ã•ã‚ŒãŸ$ `script$e è¦ç´ ã‚’å½“ã®æ§‹æ–‡è§£æå™¨ãŒèµ°ã‚‰ã›ã‚ˆã†ã¨è©¦è¡Œã—ã¦å¤±æ•—ã—ãŸãŒã€ä»–ã®~scriptãŒå‹•çš„ã«ãã‚Œã‚’æ›´æ–°ã—ãŸå¾Œã«ï¼Œå¾Œã§å®Ÿè¡Œã•ã‚ŒãŸå ´åˆ
ï¼½ã«ï¼Œï¼»
`async$a å±æ€§ãŒè¨­å®šã•ã‚Œã¦ã„ãªãã¨ã‚‚ï¼Œ â€œä»–ã‚’é˜»ã¾ãªã„â€ ~~æ–¹å¼ã§å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
ï¼½ãŸã‚ã«è¡Œã‚ã‚Œã‚‹ã€‚
â—
This is done so that if a parser-inserted script element fails to run when the parser tries to run it, but it is later executed after a script dynamically updates it, it will execute in a non-blocking fashion even if the async attribute isn't set.
</p>
	</li>
	<li>
%~source~text ~LET %S ã®`å­~textå†…å®¹$
â—
Let source text be the element's child text content.
</li>
	<li id="script-processing-empty">
~IFï¼»
`src$V ~EQ Îµ
ï¼½~ANDï¼»
%~source~text ~EQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’
~RET
â€” ~scriptã¯å®Ÿè¡Œã•ã‚Œãªã„ã€‚
â—
If the element has no src attribute, and source text is the empty string, then return. The script is not executed.
</li>
	<li>
~IFï¼»
%S ã¯ `æ¥ç¶šã•ã‚Œã¦$ã„ãªã„
ï¼½
â‡’
~RET
â€” ~scriptã¯å®Ÿè¡Œã•ã‚Œãªã„ã€‚
â—
If the element is not connected, then return. The script is not executed.
</li>
	<li>
<div>
<p id="script-processing-prepare">
%~script~blockç¨®åˆ¥~æ–‡å­—åˆ— ~LET æ¬¡ã«ä¸ãˆã‚‹ï¼»
%ç¨®åˆ¥, %è¨€èª
ï¼½ãŒæº€ãŸã™æ¡ä»¶ã«å¿œã˜ã¦ã€ä¸‹ã®è¡¨ã®å³ç«¯åˆ—ã«ä¸ãˆã‚‰ã‚Œã‚‹å€¤ï¼š
</p>
		<ul>
			<li>
%ç¨®åˆ¥ ~LETï¼»
%S ã¯ `type$a å±æ€§ã‚’æœ‰ã™ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
~ELSE_ Îµ
ï¼½
</li>
			<li>
%è¨€èª ~LETï¼»
%S ã¯ `language$a å±æ€§ã‚’æœ‰ã™ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
~ELSE_ Îµ
ï¼½
</li>
		</ul>

<table><thead><tr><th>%ç¨®åˆ¥
<th>%è¨€èª
<th>%~script~blockç¨®åˆ¥~æ–‡å­—åˆ—
</thead><tbody>

<tr><td>Îµ
<td>Îµ ã¾ãŸã¯ ç©º~æ–‡å­—åˆ—
<td>`text/javascript^l

<tr><td>Îµ
<td>ç©ºã§ãªã„æ–‡å­—åˆ—
<td>ï¼»
`text/^l, %è¨€èª
ï¼½ã‚’é€£çµã—ãŸçµæœ

<tr><td>ç©º~æ–‡å­—åˆ—
<td>ä»»æ„
<td>`text/javascript^l

<tr><td>ç©ºã§ãªã„æ–‡å­—åˆ—
<td>ä»»æ„
<td>`å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã$( %ç¨®åˆ¥ )

</tbody></table>

â—
If either:
â€¢ the script element has a type attribute and its value is the empty string, or
â€¢ the script element has no type attribute but it has a language attribute and that attribute's value is the empty string, or
â€¢ the script element has neither a type attribute nor a language attribute, then
...let the script block's type string for this script element be "text/javascript".

Otherwise, if the script element has a type attribute, let the script block's type string for this script element be the value of that attribute with leading and trailing ASCII whitespace stripped.

Otherwise, the element has a non-empty language attribute; let the script block's type string for this script element be the concatenation of the string "text/" followed by the value of the language attribute.
</div>

<p class="note">æ³¨è¨˜ï¼š
`language$a å±æ€§ã¯ã€æ±ºã—ã¦é©åˆã›ãšï¼Œ
`type$a å±æ€§ãŒåœ¨ã‚‹ã¨ãã¯å¸¸ã«ç„¡è¦–ã•ã‚Œã‚‹ã€‚
â—
The language attribute is never conforming, and is always ignored if there is a type attribute present.
</p>

	</li>
	<li>
%S ã®`~scriptç¨®åˆ¥$ ~SET
`~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹$( %~script~blockç¨®åˆ¥~æ–‡å­—åˆ— ) ã®çµæœã«å¿œã˜ã¦
â‡’ï¼ƒ
`~JS~MIMEå‹ã«~essenceåˆè‡´-$ã™ã‚‹ãªã‚‰ã° `classic^l ï¼
`module^l ãªã‚‰ã° `module^l ï¼
~ELSE_ Îµ
â—
Determine the script's type as follows:
â€¢ If the script block's type string is a JavaScript MIME type essence match, the script's type is "classic".
â€¢ If the script block's type string is an ASCII case-insensitive match for the string "module", the script's type is "module".
</li>
	<li>
~IFï¼»
%S ã®`~scriptç¨®åˆ¥$ ~EQ Îµ
ï¼½
â‡’
~RET
â€” å®Ÿè¡Œã•ã‚Œã‚‹~scriptã¯ãªã„ã€‚
â—
If neither of the above conditions are true, then return. No script is executed.
</li>
	<li>
~IFï¼»
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~NEQ ~NULL
ï¼½
â‡’ï¼ƒ
%S ã®`é˜»ã¾ãš~flag$ ~SET ~Fï¼›
%S ã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$ ~SET %æ§‹æ–‡è§£æå™¨~æ–‡æ›¸
â—
If parser document is non-null, then set the element's parser document back to parser document and set the element's "non-blocking" flag to false.
</li>
	<li id="script-processing-start">
%S ã®`é–‹å§‹æ¸ˆã¿~flag$ ~SET ~T
â—
Set the element's "already started" flag.
</li>
	<li>
%S ã®`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸$ ~SET %S ã®`~nodeæ–‡æ›¸$
â—
Set the element's preparation-time document to its node document.
</li>
	<li>
~IFï¼»
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~NIN { ~NULL, %S ã®`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸$ }
ï¼½
â‡’
~RET
â—
If parser document is non-null, and parser document is not equal to the element's preparation-time document, then return.
</li>
	<li id="script-processing-noscript">
<p>
~IFï¼»
%S ç”¨ã®`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹
ï¼½
â‡’
~RET
â€” ~scriptã¯å®Ÿè¡Œã•ã‚Œãªã„ã€‚
â—
If scripting is disabled for the script element, then return. The script is not executed.
</p>

<div class="note">

<p>æ³¨è¨˜ï¼š
`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹ï¼Œã®å®šç¾©ã«ã‚ˆã‚Šã€æ¬¡ã«è©²å½“ã™ã‚‹~scriptã¯ï¼Œå®Ÿè¡Œã•ã‚Œãªã„ï¼š
</p>

<ul>
	<li>
`XMLHttpRequest$I ã® `responseXML$m æ–‡æ›¸~å†…ã®~scriptã€‚
`XHR$r
</li>
	<li>
`DOMParser$I ãŒä½œæˆã—ãŸæ–‡æ›¸~å†…ã®~scriptã€‚
`DOMPARSING$r
</li>
	<li>
`XSLTProcessor$I ã® `transformToDocument()$m ç‰¹èƒ½ã«ã‚ˆã‚Šä½œæˆã•ã‚ŒãŸæ–‡æ›¸~å†…ã®~scriptã€‚
`XSLTP$r
</li>
	<li>
ï¼»
`createDocument()$m ~APIã‚’åˆ©ç”¨ã—ã¦ä½œæˆã•ã‚ŒãŸ`æ–‡æ›¸$
ï¼½ã®ä¸­ã«ï¼Œã‚ã‚‹~scriptã«ã‚ˆã‚Šå…ˆãšæŒ¿å…¥ã•ã‚ŒãŸ~scriptã€‚
`DOM$r
ã€ï¼ ï¼Šå…ˆãšã€‘
</li>
</ul>

â—
The definition of scripting is disabled means that, amongst others, the following scripts will not execute: scripts in XMLHttpRequest's responseXML documents, scripts in DOMParser-created documents, scripts in documents created by XSLTProcessor's transformToDocument feature, and scripts that are first inserted by a script into a Document that was created using the createDocument() API. [XHR] [DOMPARSING] [XSLTP] [DOM]
</div>

	</li>
	<li>
<p>
~IFï¼»
%S ã¯ `nomodule$a å†…å®¹~å±æ€§ã‚’æœ‰ã™ã‚‹
ï¼½~ANDï¼»
%S ã®`~scriptç¨®åˆ¥$ ~EQ `classic^l
ï¼½
â‡’
~RET
â€” ~scriptã¯å®Ÿè¡Œã•ã‚Œãªã„ã€‚
â—
If the script element has a nomodule content attribute and the script's type is "classic", then return. The script is not executed.
</p>

<p class="note">
ã“ã‚Œã¯ã€`~module~script$ã«å¯¾ã— `nomodule$a ã‚’æŒ‡å®šã—ã¦ã‚‚åŠ¹æœã¯ãªãï¼Œ~algoã¯ãã®ã¾ã¾ç¶™ç¶šã•ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
â—
This means specifying nomodule on a module script has no effect; the algorithm continues onward.
</p>
	</li>
	<li id="script-processing-csp">
~IFï¼»
`src$V ~EQ Îµ
ï¼½
â‡’
~IFï¼»
( %S , `script^l , %~source~text )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
`è¦ç´ ã«ãŠã‘ã‚‹~inlineå‹ã®æŒ™å‹•ã¯~CSPã«ã‚ˆã‚Šé˜»æ­¢ã•ã‚Œã‚‹ã¹ãã‹ï¼Ÿ$
`CSP$r
ã‚’å®Ÿè¡Œã—ãŸçµæœ ~EQ `é˜»æ­¢ã•ã‚Œã‚‹^i
ï¼½
â‡’
~RET
â€” ~scriptã¯å®Ÿè¡Œã•ã‚Œãªã„ã€‚
â—
If the script element does not have a src content attribute, and the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the script element, "script", and source text, then return. The script is not executed. [CSP]
</li>
	<li id="script-processing-for">
<p>
~IFï¼»
%S ã®`~scriptç¨®åˆ¥$ ~EQ `classic^l
ï¼½~ANDï¼»
%S ã¯ï¼»
`event$a, `for$a
ï¼½å±æ€§ã¨ã‚‚æœ‰ã—ã¦ã„ã¦ï¼Œãã‚Œã‚‰ã®å€¤ï¼»
%event, %for
ï¼½ï¼ˆåŒé †ï¼‰ã¯æ¬¡ã®ã„ãšã‚Œã‹ã‚’æº€ãŸã•ãªã„
ï¼½
â‡’
~RET
â€” ~scriptã¯å®Ÿè¡Œã•ã‚Œãªã„ï¼š
</p>
		<ul>
			<li>
`~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹$( `å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã$( %event ) ) ~IN { `onload^l, `onload()^l }
</li>
			<li>
`~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹$( `å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã$( %for ) ) ~EQ `window^l
</li>
		</ul>

â—
If the script element has an event attribute and a for attribute, and the script's type is "classic", then:
â€¢ Let for be the value of the for attribute.
â€¢ Let event be the value of the event attribute.
â€¢ Strip leading and trailing ASCII whitespace from event and for.
â€¢ If for is not an ASCII case-insensitive match for the string "window", then return. The script is not executed.
â€¢ If event is not an ASCII case-insensitive match for either the string "onload" or the string "onload()", then return. The script is not executed.
</li>
	<li id="script-processing-encoding">
<p>
%ç¬¦å·åŒ–æ³• ~LET ï¼»ï¼»
%S ã¯ `charset$a å±æ€§ã‚’æœ‰ã—ã¦ã„ã¦ï¼»
`~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹$( ãã®å±æ€§~å€¤ ) ã®çµæœ ~NEQ `å¤±æ•—^i
ï¼½ï¼½ãªã‚‰ã° ãã®çµæœ ï¼
~ELSE_ %æ–‡æ›¸ ã®`ç¬¦å·åŒ–æ³•$doc
ï¼½
â—
If the script element has a charset attribute, then let encoding be the result of getting an encoding from the value of the charset attribute.
â—
If the script element does not have a charset attribute, or if getting an encoding failed, let encoding be the same as the encoding of the script element's node document.
</p>

<p class="note">æ³¨è¨˜ï¼š
ï¼»
%S ã®`~scriptç¨®åˆ¥$ ~EQ `module^l
ï¼½ã®å ´åˆã€ã“ã®ç¬¦å·åŒ–æ³•ã¯ç„¡è¦–ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
If the script's type is "module", this encoding will be ignored.
</p>
	</li>
	<li>
%å¤å…¸~script~CORSè¨­å®š ~LET %S ã® `crossorigin$a å†…å®¹~å±æ€§ã®ç¾åœ¨ã®çŠ¶æ…‹
â—
Let classic script CORS setting be the current state of the element's crossorigin content attribute.
</li>
	<li>
%~module~scriptè³‡æ ¼è¨¼~mode ~LET
%S ã® `crossorigin$a å†…å®¹~å±æ€§~ç”¨ã®`~CORSè¨­å®šç¾¤~å±æ€§ã®è³‡æ ¼è¨¼~mode$
â—
Let module script credentials mode be the CORS settings attribute credentials mode for the element's crossorigin content attribute.
</li>
	<li>
%æš—å·ç”¨~nonce ~LET %S ã® `CryptographicNonce$sl å†…éƒ¨~slotã®å€¤
â—
Let cryptographic nonce be the element's [[CryptographicNonce]] internal slot's value.
</li>
	<li>
%å®Œå…¨æ€§~metadata ~LET ï¼»
%S ã¯ `integrity$a å±æ€§ã‚’æœ‰ã™ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
~ELSE_ ç©º~æ–‡å­—åˆ—
ï¼½
â—
If the script element has an integrity attribute, then let integrity metadata be that attribute's value.
â—
Otherwise, let integrity metadata be the empty string.
</li>
	<li>
%~referreræ–½ç­– ~LET %S ã® `referrerpolicy$a å†…å®¹~å±æ€§ã®ç¾åœ¨ã®çŠ¶æ…‹
â—
Let referrer policy be the current state of the element's referrerpolicy content attribute.
</li>
	<li>
%æ§‹æ–‡è§£æå™¨~metadata ~LET ï¼»
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~NEQ ~NULL ãªã‚‰ã° `parser-inserted^l ï¼
~ELSE_  `not-parser-inserted^l
ï¼½
â—
Let parser metadata be "parser-inserted" if the script element is "parser-inserted", and "not-parser-inserted" otherwise.
</li>
	<li>
%~options ~LET æ¬¡ã®ã‚ˆã†ã«ã•ã‚ŒãŸ`~script~fetch~options$
â‡’ï¼ƒ
`æš—å·ç”¨~nonce$sfO ~SET %æš—å·ç”¨~nonce,
`å®Œå…¨æ€§~metadata$sfO ~SET %å®Œå…¨æ€§~metadata,
`æ§‹æ–‡è§£æå™¨~metadata$sfO ~SET %æ§‹æ–‡è§£æå™¨~metadata,
`è³‡æ ¼è¨¼~mode$sfO ~SET %~module~scriptè³‡æ ¼è¨¼~mode,
`~referreræ–½ç­–$sfO ~SET %~referreræ–½ç­–
â—
Let options be a script fetch options whose cryptographic nonce is cryptographic nonce, integrity metadata is integrity metadata, parser metadata is parser metadata, credentials mode is module script credentials mode, and referrer policy is referrer policy.
</li>
	<li>
%è¨­å®šç¾¤~obj ~LET %æ–‡æ›¸ ã«`é–¢é€£ãªè¨­å®šç¾¤~obj$
â—
Let settings object be the element's node document's relevant settings object.
</li>
	<li id="script-processing-src-prepare">
<p>
~IFï¼»
`src$V ~NEQ Îµ
ï¼½ï¼š
â—
If the element has a src content attribute, then:
</p>
		<ol>
			<li>
<p>
~IFï¼»
`src$V ~EQ ç©º~æ–‡å­—åˆ—
ï¼½ï¼š
</p>
				<ol>
					<li>
æ¬¡ã‚’èµ°ã‚‰ã™`~taskã‚’~queueã™ã‚‹$
â‡’
%S ã«å‘ã‘ã¦ï¼Œåå‰ `error$et ã®`~eventã‚’ç™ºç«ã™ã‚‹$
</li>
					<li>
~RET
</li>
				</ol>

â—
Let src be the value of the element's src attribute.
â—
If src is the empty string, queue a task to fire an event named error at the element, and return.
</li>
			<li>
%S ã®`å¤–éƒ¨~file~flag$ ~SET ~T
â—
Set the element's from an external file flag.
</li>
			<li>
%~url ~LET 
`src$V ã‚’ %æ–‡æ›¸ ã«`ç›¸å¯¾çš„ã«æ§‹æ–‡è§£æ-$ã—ãŸ`çµæœã®~URL~record$
â—
Parse src relative to the element's node document.
</li>
			<li>
<p>
~IFï¼»
%~url ~EQ `å¤±æ•—^i
ï¼½ï¼š
</p>
				<ol>
					<li>
æ¬¡ã‚’èµ°ã‚‰ã™`~taskã‚’~queueã™ã‚‹$
â‡’
%S ã«å‘ã‘ã¦ï¼Œåå‰ `error$et ã®`~eventã‚’ç™ºç«ã™ã‚‹$
</li>
					<li>
~RET
</li>
				</ol>
â—
If the previous step failed, queue a task to fire an event named error at the element, and return. Otherwise, let url be the resulting URL record.
</li>
			<li>
<p>
%S ã®`~scriptç¨®åˆ¥$ã«å¿œã˜ã¦ï¼š
â—
Switch on the script's type:
</p>

				<dl class="switch">
					<dt>`classic^l</dt>
					<dd>
`å¤å…¸~scriptã‚’~fetchã™ã‚‹$(
%~url,
%è¨­å®šç¾¤~obj,
%~options,
%å¤å…¸~script~CORSè¨­å®š,
%ç¬¦å·åŒ–æ³•
)
â—
Fetch a classic script given url, settings object, options, classic script CORS setting, and encoding.
</dd>

					<dt>`module^l</dt>
					<dd>
`å¤–éƒ¨~module~script~graphã‚’~fetchã™ã‚‹$(
%~url,
%è¨­å®šç¾¤~obj,
%~options
)
â—
Fetch an external module script graph given url, settings object, and options.
</dd>
			</dl>

<div class="p">
<p>
~fetchã™ã‚‹~algoãŒ`éåŒæœŸã«å®Œäº†ã—ãŸ$ã¨ãã¯ï¼š
</p>

<ol ><li>%S ã®`~script$ ~SET ãã®çµæœ
</li><li>%S ã‚’`æº–å‚™æ¸ˆã¿$ã«ã™ã‚‹
</li></ol>
â—
When the chosen algorithm asynchronously completes, set the script's script to the result. At that time, the script is ready.
</div>

<p>
å‡¦ç†èƒ½~ä¸Šã®ç†ç”±ã‹ã‚‰ã€~UAã¯ï¼š
â—
For performance reasons, user agentsï¼¼
</p>
				<ul>
					<li>
%S ã® `src$a å±æ€§ãŒè¨­å®šã•ã‚Œæ¬¡ç¬¬ï¼Œã™ãã«ï¼ˆä¸Šã«å®šç¾©ã•ã‚Œã‚‹ã‚ˆã†ã«ï¼‰ï¼»
å¤å…¸~scriptï¼~module~graph
ï¼½ã®~fetchingã‚’é–‹å§‹ã—ã¦ã‚‚ãƒ¨ã‚¤
â€” ~~å®Ÿéš›ã« %S ãŒæ–‡æ›¸ã®ä¸­ã¸æŒ¿å…¥ã•ã‚Œã‚‹ï¼ˆã‹ã¤ï¼Œãã‚Œã¾ã§ã¯
%S ã® `crossorigin$a å±æ€§ã®å€¤ã¯å¤‰æ›´ã•ã‚Œãªã„ï¼‰ã®ã‚’å¾…ã¤ã“ã¨ãªãã€‚
ã„ãšã‚Œã«ã›ã‚ˆï¼Œ
%S ãŒ`æ–‡æ›¸ã®ä¸­ã¸æŒ¿å…¥ã•ã‚ŒãŸ$ãªã‚‰ã€ã“ã®æ®µã«è¿°ã¹ãŸã‚ˆã†ã«ï¼Œèª­è¾¼nã‚’é–‹å§‹ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
may start fetching the classic script or module graph (as defined above) as soon as the src attribute is set, instead, in the hope that the element will be inserted into the document (and that the crossorigin attribute won't change value in the meantime). Either way, once the element is inserted into the document, the load must have started as described in this step.ï¼¼
</li>
					<li>
<p>
å‰é …ã®ã‚ˆã†ãªäº‹å‰~fetchingã‚’é‚è¡Œã™ã‚‹ä¸‹ã§ï¼Œæ¬¡ã®ã„ãšã‚Œã‹ã«è©²å½“ã™ã‚‹å ´åˆâ€¦ï¼š
</p>

<ul><li>%S ã¯ã€~~å®Ÿéš›ã«ã¯ï¼Œæ–‡æ›¸~å†…ã«æŒ¿å…¥ã•ã‚Œãªã‹ã£ãŸ
</li><li>%S ã¯æ–‡æ›¸~å†…ã«æŒ¿å…¥ã•ã‚ŒãŸãŒã€ãã‚Œã¾ã§ã« %S ã®ï¼»
`src$a ï¼ `crossorigin$a
ï¼½å±æ€§ãŒå‹•çš„ã«å¤‰æ›´ã•ã‚ŒãŸ
</li></ul>

<p>
â€¦å ´åˆã€ãã®ã‚ˆã†ã«å¾—ã•ã‚ŒãŸ~scriptã¯å®Ÿè¡Œã—ãªã„ã¨ã™ã‚‹
â€” ~fetchingã¯ã€å®Ÿè³ªçš„ã«æµªè²»ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
</p>

â—
If the UA performs such prefetching, but the element is never inserted in the document, or the src attribute is dynamically changed, or the crossorigin attribute is dynamically changed, then the user agent will not execute the script so obtained, and the fetching process will have been effectively wasted.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li id="establish-script-block-source">
<p>
~ELSE ï¼ˆ `src$V ~EQ Îµ ï¼‰ï¼š
â—
If the element does not have a src content attribute, run these substeps:
</p>
		<ol>
			<li>
%åŸºåº•~URL ~LET %æ–‡æ›¸ ã®`æ–‡æ›¸~åŸºåº•~URL$
â—
Let base URL be the script element's node document's document base URL.
</li>
			<li>
<p>
%S ã®`~scriptç¨®åˆ¥$ã«å¿œã˜ã¦ï¼š
â—
Switch on the script's type:
</p>
				<dl class="switch">
					<dt>`classic^l</dt>
					<dd>
						<ol>
							<li>
%S ã®`~script$ ~SET
`å¤å…¸~scriptã‚’ä½œæˆã™ã‚‹$( %~source~text, %è¨­å®šç¾¤~obj, %åŸºåº•~URL, %~options  )
â—
Let script be the result of creating a classic script using source text, settings object, base URL, and options.
â—
Set the script's script to script.
</li>
							<li>
%S ã‚’`æº–å‚™æ¸ˆã¿$ã«ã™ã‚‹
â—
The script is ready.
</li>
						</ol>
					</dd>

					<dt>`module^l</dt>
					<dd>
						<ol>
							<li>
<p>
`~inline~script~graphã‚’~fetchã™ã‚‹$(
%~source~text,
%åŸºåº•~URL,
%è¨­å®šç¾¤~obj,
%~options
)
</p>
<p>
ã“ã‚ŒãŒ %çµæœ ã‚’çµæœã¨ã—ã¦`éåŒæœŸã«å®Œäº†ã—ãŸ$ã¨ãã¯
â‡’ï¼ƒ
%S ã®`~script$ ~SET %çµæœï¼›
%S ã‚’`æº–å‚™æ¸ˆã¿$ã«ã™ã‚‹
</p>
â—
Fetch an inline module script graph, given source text, base URL, settings object, and options. When this asynchronously completes, set the script's script to the result. At that time, the script is ready.
</li>
						</ol>
					</dd>
				</dl>
			</li>
		</ol>
	</li>
	<li>
%defer ~LET ï¼»
%S ã¯ `defer$a å±æ€§ã‚’æœ‰ã™ã‚‹ãªã‚‰ã° ~T ï¼
~ELSE_ ~F
ï¼½
â—
â†“</li>
	<li>
%æŒ¿å…¥ã•ã‚ŒãŸ ~LET ï¼»
%æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~NEQ ~NULL ãªã‚‰ã° ~T ï¼
~ELSE_ ~F
ï¼½
â—
â†“</li>
	<li>
%æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸ ~LET %S ã®`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸$
ï¼ˆ %æ§‹æ–‡è§£æå™¨~æ–‡æ›¸ ~NEQ ~NULL ãªã‚‰ã° ãã‚Œã«ä¸€è‡´ã™ã‚‹ï¼‰
â—
â†“</li>
	<li>
<p>
æ¬¡ã®è¡¨ã«ãŠã„ã¦ï¼Œ %S ãŒæº€ãŸã™å„ç¨®æ¡ä»¶ã«å¿œã˜ã¦ã€åŒã˜è¡Œã® â€œãµã‚‹ã¾ã„â€ åˆ—ï¼ˆå³ç«¯ï¼‰ã«ä¸ãˆã‚‹~labelãŒä»˜ä¸ã•ã‚ŒãŸï¼»
è¡¨ã«å¾Œç¶šã™ã‚‹æ®µ
ï¼½ã«å¾“ã†ï¼š
â—
Then, follow the first of the following options that describes the situation:
</p>

<table>
<caption>ç©ºæ¬„ã¯ç„¡æ¡ä»¶ã‚’è¡¨ã™ã€‚</caption>
<thead><tr><th>`~scriptç¨®åˆ¥$
<th>`src$V
<th>`async$V
<th>%æŒ¿å…¥ã•ã‚ŒãŸ
<th>`é˜»ã¾ãš~flag$
<th>%defer
<th>ãµã‚‹ã¾ã„
</thead><tbody>

<tr><td>`classic^l
<td>é Îµ
<td>~F
<td>~T
<td>
<td>~T
<td id="script-processing-defer">`æ§‹æ–‡è§£æ-å¾Œ^i

<tr><td>`classic^l
<td>é Îµ
<td>~F
<td>~T
<td>
<td>~F
<td id="script-processing-parser-inserted">`æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚€^i

<tr><td>`classic^l
<td>é Îµ
<td>~F
<td>~F
<td>~F
<td>
<td id="script-processing-src-sync">`ã™ãã«é †ã«^i

<tr><td>`classic^l
<td>é Îµ
<td>~F
<td>~F
<td>~T
<td>
<td rowspan="2" id="script-processing-src">`ã™ãã«^i

<tr><td>`classic^l
<td>é Îµ
<td>~T
<td>
<td>
<td>

<tr><td>`classic^l
<td>Îµ
<td>
<td>~T
<td>
<td>
<td>`~stylesheetã®å¾Œ^i

<tr><td>`classic^l
<td>Îµ
<td>
<td>~F
<td>
<td>
<td>`å³æ™‚ã«^i

<tr><td>`module^l
<td>
<td>~F
<td>~T
<td>
<td>
<td id="script-processing-module-noasync-parser-inserted">`æ§‹æ–‡è§£æ-å¾Œ^i

<tr><td>`module^l
<td>
<td>~F
<td>~F
<td>~F
<td>
<td id="script-processing-module-noasync">`ã™ãã«é †ã«^i

<tr><td>`module^l
<td>
<td>~F
<td>~F
<td>~T
<td>
<td rowspan="2" id="script-processing-module-async">`ã™ãã«^i

<tr><td>`module^l
<td>
<td>~T
<td>
<td>
<td>

</tbody></table>

<p class="trans-note">ã€
åŸæ–‡ã®æ¡ä»¶è¨˜è¿°ãŒç…©é›‘ãªã®ã§ã€ã“ã®è¨³ã§ã¯ï¼Œè¡¨ã®å½¢ã«, å„è¡ŒãŒæ’ä»–çš„ã«ãªã‚‹ã‚ˆã†æ•´ç†ã—ã¦ã„ã‚‹ã€‚
ã€‘</p>

		<dl class="switch">
			<dt>
`æ§‹æ–‡è§£æ-å¾Œ^i
ã€ï¼id="script-processing-defer"ã€‘
ã€ï¼id="script-processing-module-noasync-parser-inserted"ã€‘
â—
If the script's type is "classic", and the element has a src attribute, and the element has a defer attribute, and the element is "parser-inserted", and the element does not have an async attribute
â—
If the script's type is "module", and the element is "parser-inserted", and the element does not have an async attribute
</dt>
			<dd>
%æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸ ã«çµä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹
`æ–‡æ›¸ã‚’æ§‹æ–‡è§£æã—çµ‚ãˆãŸã¨ãã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptã®~list@
ã®æœ«å°¾ã« %S ã‚’è¿½åŠ ã™ã‚‹
â—
Add the element to the end of the list of scripts that will execute when the document has finished parsing associated with the Document of the parser that created the element.
</dd>
			<dd>
</dd>
			<dd>
<p>
%S ãŒ`æº–å‚™æ¸ˆã¿$ã«ãªã£ãŸã¨ãã¯
â‡’
%S ã®`è§£æå™¨å®Ÿè¡Œæº–å‚™æ¸ˆã¿~flag$ ~SET ~T
â€” å½“ã®æ§‹æ–‡è§£æå™¨ãŒï¼Œã“ã®~scriptã®å®Ÿè¡Œngã‚’å–æ‰±ã†ã“ã¨ã«ãªã‚‹ã€‚
â—
When the script is ready, set the element's "ready to be parser-executed" flag. The parser will handle executing the script.
</dd>
			<dt>
ã€ï¼id="script-processing-parser-inserted"ã€‘
`æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚€^i
â—
If the script's type is "classic", and the element has a src attribute, and the element is "parser-inserted", and the element does not have an async attribute
</dt>
			<dd>
%æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸ ã®`æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹~script$ ~SET %S
â—
The element is the pending parsing-blocking script of the Document of the parser that created the element. (There can only be one such script per Document at a time.)
</dd>
			<dd>
%S ãŒ`æº–å‚™æ¸ˆã¿$ã«ãªã£ãŸã¨ãã¯
â‡’
%S ã®`è§£æå™¨å®Ÿè¡Œæº–å‚™æ¸ˆã¿~flag$ ~SET ~T
â€” å½“ã®æ§‹æ–‡è§£æå™¨ãŒï¼Œã“ã®~scriptã®å®Ÿè¡Œngã‚’å–æ‰±ã†ã“ã¨ã«ãªã‚‹ã€‚
â—
When the script is ready, set the element's "ready to be parser-executed" flag. The parser will handle executing the script.
</dd>

			<dt>
`ã™ãã«é †ã«^i
ã€ï¼id="script-processing-src-sync"ã€‘
ã€ï¼id="script-processing-module-noasync"ã€‘
ã€ï¼A2ã€‘
â—
If the script's type is "classic", and the element has a src attribute, and the element does not have an async attribute, and the element does not have the "non-blocking" flag set
â—
If the script's type is "module", and the element does not have an async attribute, and the element does not have the "non-blocking" flag set
</dt>
			<dd>
%æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸ ã«çµä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹
`ã‚¢ãƒªãªé™ã‚Šã™ãã«é †ã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptã®~list@
â€” ä»¥ä¸‹ï¼Œå˜ã« %~list ã¨è¨˜ã™ â€”
å†…ã®ï¼»
ã“ã®~algoã®é–‹å§‹-æ™‚ã«ãŠã‘ã‚‹æœ«å°¾ä½ç½®
ï¼½ã« %S ã‚’æŒ¿å…¥ã™ã‚‹
â—
Add the element to the end of the list of scripts that will execute in order as soon as possible associated with the element's preparation-time document.
</dd>
			<dd>
<p>
%S ãŒ`æº–å‚™æ¸ˆã¿$ã«ãªã£ãŸã¨ãã¯ï¼Œæ¬¡ã®æ‰‹ç¶šãã‚’èµ°ã‚‰ã™ï¼š
â—
When the script is ready, run the following steps:
</p>

				<ol>
<!-- If the element is not now... ã¯ä¸è¦ -->

					<li>
<p>
~WHILE %~list ã¯ç©ºã§ãªã„
</p>
						<ol>
							<li>
%~scriptè¦ç´  ~LET %~list å†…ã®æœ€åˆã® `script^e è¦ç´ 
</li>
							<li>
~IFï¼»
%~scriptè¦ç´  ã¯`æº–å‚™æ¸ˆã¿$ã§ãªã„
ï¼½
â‡’
~BREAK
</li>
							<li>
%~scriptè¦ç´  ã«å¯¾å¿œã™ã‚‹`~script~blockã‚’å®Ÿè¡Œã™ã‚‹$
</li>
							<li>
%~list ã‹ã‚‰ %~scriptè¦ç´  ã‚’é™¤å»ã™ã‚‹
</li>
						</ol>
â—
If the element is not now the first element in the list of scripts that will execute in order as soon as possible to which it was added above, then mark the element as ready but return without executing the script yet.
â—
Execution: Execute the script block corresponding to the first script element in this list of scripts that will execute in order as soon as possible.
â—
Remove the first element from this list of scripts that will execute in order as soon as possible.
â—
If this list of scripts that will execute in order as soon as possible is still not empty and the first entry has already been marked as ready, then jump back to the step labeled execution.
</li>
				</ol>
			</dd>
			<dt>
ã€ï¼id="script-processing-src"ã€‘
ã€ï¼id="script-processing-module-async"ã€‘
`ã™ãã«^i
â—
If the script's type is "classic", and the element has a src attribute
â—
If the script's type is "module"
</dt>
			<dd>
%æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸ ã«çµä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹
`ã‚¢ãƒªãªé™ã‚Šã™ãã«å®Ÿè¡Œã•ã‚Œã‚‹~scriptã®é›†åˆ@
â€” ä»¥ä¸‹ï¼Œå˜ã« %é›†åˆ ã¨è¨˜ã™ â€”
ã« %S ã‚’è¿½åŠ ã™ã‚‹
â—
The element must be added to the set of scripts that will execute as soon as possible of the element's preparation-time document.
</dd>
			<dd>
<p>
%S ãŒ`æº–å‚™æ¸ˆã¿$ã«ãªã£ãŸã¨ãã¯ï¼š
</p>
<ol>
	<li>
%S ã«å¯¾å¿œã™ã‚‹`~script~blockã‚’å®Ÿè¡Œã™ã‚‹$
</li>
	<li>
%é›†åˆ ã‹ã‚‰ %S ã‚’é™¤å»ã™ã‚‹
</li>
</ol>

â—
When the script is ready, execute the script block and then remove the element from the set of scripts that will execute as soon as possible.
</dd>

			<dt>
ã€ï¼id="script-processing-style-delayed"ã€‘
`~stylesheetã®å¾Œ^i
â—
If the element does not have a src attribute, and the element is "parser-inserted",ï¼¼
</dt>
			<dd>
				<ol>
					<li>
<p>
~IFï¼»
æ¬¡ã®ã„ãšã‚Œã‚‚æº€ãŸã•ã‚Œã‚‹
ï¼½â€¦ï¼š
â—
andï¼¼
</p>

						<ul>
							<li>
ï¼»
å½“ã®æ§‹æ–‡è§£æå™¨ã¯`~XMLæ§‹æ–‡è§£æå™¨$ã§ã‚ã‚‹
ï¼½~ORï¼»
å½“ã®æ§‹æ–‡è§£æå™¨ã¯`~HTMLæ§‹æ–‡è§£æå™¨$ã§ã‚ã£ã¦ï¼Œãã®
`~scriptå…¥å­ng~level$ ~LTE 1
ï¼½
â—
either the parser that created the script is an XML parser or it's an HTML parser whose script nesting level is not greater than one, andï¼¼
</li>
							<li>
%æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸ ã«ã¯`~scriptã‚’é˜»ã‚“ã§ã„ã‚‹~stylesheet$ã¯åœ¨ã‚‹
â—
the element's parser document has a style sheet that is blocking scripts
</li>
						</ul>
<p>
â€¦ãªã‚‰ã°ï¼š
</p>
						<ol id="script-processing-style-delayed">
							<li>
%æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸ ã®`æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹~script$ ~SET %S
â—
The element is the pending parsing-blocking script of its parser document. (There can only be one such script per Document at a time.)
</li>
							<li>
%S ã®`è§£æå™¨å®Ÿè¡Œæº–å‚™æ¸ˆã¿~flag$ ~SET ~T
â€” å½“ã®æ§‹æ–‡è§£æå™¨ãŒï¼Œã“ã®~scriptã®å®Ÿè¡Œngã‚’å–æ‰±ã†ã“ã¨ã«ãªã‚‹ã€‚
â—
Set the element's "ready to be parser-executed" flag. The parser will handle executing the script.
</li>
						</ol>
					</li>
					<li>
~ELSE
â‡’
~GOTO `å³æ™‚ã«^i
</li>
				</ol>
			</dd>

			<dt>`å³æ™‚ã«^i</dt>
			<dd id="script-processing-inline">
`å³æ™‚$ã«`~script~blockã‚’å®Ÿè¡Œã™ã‚‹$
â€” ä»–ã®~scriptãŒã™ã§ã«å®Ÿè¡Œ-ä¸­ã«ã‚ã£ã¦ã‚‚
ã€ä»–ã®~scriptã®å®Ÿè¡Œã«å‰²ã‚Šè¾¼ã‚€ï¼Ÿã€‘
â—
Otherwise
â—
Immediately execute the script block, even if other scripts are already executing.
</dd>
		</dl>
	</li>
</ol>
</div>

<p>
å„ `æ–‡æ›¸$ã«ã¯ï¼Œ
`æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹~script@
ãŒçµä»˜ã‘ã‚‰ã‚Œã€åˆæœŸ~æ™‚ã¯ Îµ ï¼ˆãªã—ï¼‰ã¨ã™ã‚‹ï¼ˆåŒã˜æ–‡æ›¸ã«å¯¾ã—ï¼Œãã®ã‚ˆã†ãª~scriptãŒåŒæ™‚ã«è¤‡æ•°~ç”Ÿã˜ã‚‹ã“ã¨ã¯ãªã„ï¼‰ã€‚
ãã‚Œã¯ã€`æ–‡æ›¸$ã®æ§‹æ–‡è§£æå™¨ï¼ˆãŸã¡ï¼‰ã«ã‚ˆã‚Šåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
The pending parsing-blocking script of a Document is used by the Document's parser(s).
</p>

<p class="note">æ³¨è¨˜ï¼š
æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹ `script$e è¦ç´ ãŒ
â€” é€šå¸¸ã¯ãã®æ§‹æ–‡è§£æå™¨ã‚’é˜»ã¾ãªããªã‚‹ãŒã€ãã®å‰ã« â€”
åˆ¥ã®`æ–‡æ›¸$ã¸ç§»å‹•ã•ã‚ŒãŸå ´åˆã§ã‚‚ã€ï¼»
æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹æ¡ä»¶ãŒï¼Œãã‚Œä»¥ä¸Š~é©ç”¨ã•ã‚Œãªããªã‚‹
ï¼½ã¾ã§ï¼Œãã®æ§‹æ–‡è§£æå™¨ã‚’é˜»ã¿ç¶šã‘ã‚‹ï¼ˆä¾‹ï¼š
å…ƒã®`æ–‡æ›¸$ã«`~scriptã‚’é˜»ã‚“ã§ã„ã‚‹~stylesheet$ãŒåœ¨ã‚‹ãŸã‚ã«ï¼Œå½“ã®~scriptã¯æ§‹æ–‡è§£æ-æ™‚ã«`æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚“ã§ã„ã‚‹~script$ã§ã‚ã£ãŸå ´åˆï¼Œï¼»
é˜»ã‚“ã§ã„ã‚‹~stylesheetãŸã¡ãŒèª­è¾¼ã¾ã‚Œã‚‹å‰ã« ~scriptãŒåˆ¥ã®`æ–‡æ›¸$ã¸ç§»å‹•ã•ã‚ŒãŸ
ï¼½ã¨ã—ã¦ã‚‚ã€~scriptã¯ï¼Œãã‚Œã‚‰ã®~stylesheetãŒã™ã¹ã¦èª­è¾¼ã¾ã‚Œã‚‹ã¾ã§ï¼Œä¾ç„¶ã¨ã—ã¦æ§‹æ–‡è§£æå™¨ã‚’é˜»ã‚€
â€” ãã®æ™‚ç‚¹ã§ã€~scriptã¯å®Ÿè¡Œã•ã‚Œï¼Œæ§‹æ–‡è§£æå™¨ã‚’é˜»ã¾ãªããªã‚‹ï¼‰ã€‚
â—
If a script element that blocks a parser gets moved to another Document before it would normally have stopped blocking that parser, it nonetheless continues blocking that parser until the condition that causes it to be blocking the parser no longer applies (e.g., if the script is a pending parsing-blocking script because the original Document has a style sheet that is blocking scripts when it was parsed, but then the script is moved to another Document before the blocking style sheet(s) loaded, the script still blocks the parser until the style sheets are all loaded, at which time the script executes and the parser is unblocked).
</p>

<div class="algorithm">
<p>
`~script~blockã‚’å®Ÿè¡Œã™ã‚‹@
ã¨ãã¯ã€æ‰€ä¸ã®
( `script$e è¦ç´  %S )
ã«å¯¾ã—ï¼š
â—
To execute a script block given a script element scriptElement:
</p>

<ol>
	<li>
%æ–‡æ›¸ ~LET %S ã®`~nodeæ–‡æ›¸$
â—
Let document be scriptElement's node document.
</li>
	<li>
~IFï¼»
%S ã®`æº–å‚™~æ™‚ç‚¹ã®æ–‡æ›¸$ ~NEQ %æ–‡æ›¸
ï¼½
â‡’
~RET
â—
If scriptElement's preparation-time document is not equal to document, then return.
</li>
	<li>
~IFï¼»
%S ã®`~script$ ~EQ ~NULL
ï¼½
â‡’ï¼ƒ
%S ã«å‘ã‘ã¦ï¼Œåå‰ `error$et ã®`~eventã‚’ç™ºç«ã™ã‚‹$ï¼›
~RET
â—
If the script's script is null for scriptElement, then fire an event named error at scriptElement, and return.
</li>
	<li>
%~counterå¢—æ¸› ~LET ï¼»
æ¬¡ãŒæº€ãŸã•ã‚Œã‚‹ãªã‚‰ã° ~T ï¼
~ELSE_ ~F
ï¼½
â‡’
ï¼»
%S ã®`å¤–éƒ¨~file~flag$ ~EQ ~T
ï¼½~ORï¼»
%S ã®`~scriptç¨®åˆ¥$ ~EQ `module^l
ï¼½
â—
â†“</li>
	<li>
~IFï¼»
%~counterå¢—æ¸› ~EQ ~T
ï¼½
â‡’
%æ–‡æ›¸ ã®`ç ´å£Šçš„æ›¸è¾¼ã¯ç„¡è¦–ã™ã‚‹~counter$ ~INCBY 1
â—
If scriptElement is from an external file, or the script's type for scriptElement is "module", then increment document's ignore-destructive-writes counter.
</li>
	<li>
<p>
%S ã®`~scriptç¨®åˆ¥$ã«å¿œã˜ã¦ï¼š
â—
Switch on the script's type for scriptElement:
</p>
		<dl class="switch">
			<dt>`classic^l</dt>
			<dd>
				<ol>
					<li>
%æ—§-~scriptè¦ç´  ~LET %æ–‡æ›¸ ã® `currentScript$m å±æ€§~å€¤
ã€ï¼object was most recently setã€‘
â—
Let oldCurrentScript be the value to which document's currentScript object was most recently set.
</li>
					<li>
<p>
%æ–‡æ›¸ ã®`currentScript$m å±æ€§ ~SET ï¼»
%S ã®`æ ¹$ã¯`~shadowæ ¹$ã§ãªã„ãªã‚‰ã° %S ï¼
~ELSE_ ~NULL
ï¼½
â—
If scriptElement's root is not a shadow root, then set document's currentScript attribute to scriptElement. Otherwise, set it to null.
</p>

<p class="note">
ã“ã“ã§ã¯ã€ %S ãŒ`æ–‡æ›¸~treeå†…$ã«ã‚ã‚‹ã‹ã©ã†ã‹ã¯æ¤œæŸ»ã—ãªã„
â€” `script$e è¦ç´ ã¯ã€å®Ÿè¡Œã«å…ˆç«‹ã£ã¦æ–‡æ›¸ã‹ã‚‰é™¤å»ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã€ãã®å±€é¢ã§ã‚‚ä¾ç„¶ã¨ã—ã¦ï¼Œ `currentScript$m ã¯ ãã‚Œã‚’æŒ‡ã™å¿…è¦ãŒã‚ã‚‹ã®ã§ã€‚
â—
This does not use the in a document tree check, as scriptElement could have been removed from the document prior to execution, and in that scenario currentScript still needs to point to it.
</p>
					</li>
					<li>
`å¤å…¸~scriptã‚’èµ°ã‚‰ã™$( %S ã®`~script$ )
â—
Run the classic script given by the script's script for scriptElement.
</li>
					<li>
%æ–‡æ›¸ ã®`currentScript$m å±æ€§ ~SET %æ—§-~scriptè¦ç´ 
â—
Set document's currentScript attribute to oldCurrentScript.
</li>
				</ol>
			</dd>

			<dt>`module^l</dt>
			<dd>
				<ol>
					<li>
~Assert:
%æ–‡æ›¸ ã®`currentScript$m å±æ€§ ~EQ ~NULL
â—
Assert: document's currentScript attribute is null.
</li>
					<li>
`~module~scriptã‚’èµ°ã‚‰ã™$( %S ã®`~script$ )
â—
Run the module script given by the script's script for scriptElement.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~IFï¼»
%~counterå¢—æ¸› ~EQ ~T
ï¼½
â‡’
%æ–‡æ›¸ ã®`ç ´å£Šçš„æ›¸è¾¼ã¯ç„¡è¦–ã™ã‚‹~counter$ ~DECBY 1
â—
Decrement the ignore-destructive-writes counter of document, if it was incremented in the earlier step.
</li>
	<li>
~IFï¼»
%S ã®`å¤–éƒ¨~file~flag$ ~EQ ~T
ï¼½
â‡’
%S ã«å‘ã‘ã¦ï¼Œåå‰ `load$et ã®`~eventã‚’ç™ºç«ã™ã‚‹$
â—
If scriptElement is from an external file, then fire an event named load at scriptElement.
</li>
</ol>
</div>

			</section>
			<section id="scriptingLanguages">
<h4 title="Scripting languages">4.12.1.2. ~scriptingè¨€èª</h4>

<p>
~UAã«ã¯ã€~JSã‚’~supportã™ã‚‹ã“ã¨ã¯è¦æ±‚ã•ã‚Œãªã„ã€‚
ã“ã®æ¨™æº–ã¯ã€~JSä»¥å¤–ã®è¨€èªãŒ~JSåŒæ§˜ã«~web~browserã«åºƒãæ¡ç”¨ã•ã‚ŒãŸãªã‚‰ã°ï¼Œæ›´æ–°ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
ãã®ã¨ããŒæ¥ãªã„é™ã‚Šã€ä»–ã®è¨€èªã‚’å®Ÿè£…ã™ã‚‹ã®ã¯ï¼Œã“ã®æ¨™æº–ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ `script$e è¦ç´ ~ç”¨ã®å‡¦ç†~modelã«ç«¶åˆã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
User agents are not required to support JavaScript. This standard needs to be updated if a language other than JavaScript comes along and gets similar wide adoption by web browsers. Until such a time, implementing other languages is in conflict with this standard, given the processing model defined for the script element.
</p>

<div class="p">
<p>
~serverã¯ã€~JSè³‡æºã«å¯¾ã—ã¦ã¯ï¼š
</p>

<ul>
	<li>
`text/javascript$c ã‚’åˆ©ç”¨ã™ã‚‹ã¹ãã§ã‚ã‚‹
â€” ä»–ã®`~JS~MIMEå‹$ã¯åˆ©ç”¨ã™ã‚‹ã¹ãã§ãªã„ã€‚
</li>
	<li>
é`~JS~MIMEå‹$ã‚’åˆ©ç”¨ã—ã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ã€‚
</li>
</ul>

â—
Servers should use text/javascript for JavaScript resources. Servers should not use other JavaScript MIME types for JavaScript resources, and must not use non-JavaScript MIME types.
</div>

<p>
å¤–éƒ¨~JSè³‡æºã«å¯¾ã—ã¦ã¯ã€ãã® `~Content-Type~header$å†…ã®~MIMEå‹~parameterã¯ï¼Œä¸€èˆ¬ã«ç„¡è¦–ã•ã‚Œã‚‹ï¼ˆ `charset^c ~parameterã«ã¤ã„ã¦ã¯ã€åŠ¹æœãŒã‚ã‚‹äº‹ä¾‹ã‚‚ã‚ã‚‹ï¼‰ã€‚
ä¸€æ–¹ã§ï¼Œ `script$e è¦ç´ ã® `type$a å±æ€§~å†…ã®ãã‚Œã¯ã€æœ‰æ„ã«ãªã‚‹
â€” `~JS~MIMEå‹ã«~essenceåˆè‡´-$ã®æ¦‚å¿µã‚’åˆ©ç”¨ã™ã‚‹ã®ã§ã€‚
â—
For external JavaScript resources, MIME type parameters in `Content-Type` headers are generally ignored. (In some cases the `charset` parameter has an effect.) However, for the script element's type attribute they are significant; it uses the JavaScript MIME type essence match concept.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä¾‹ãˆã°ã€ `type$a å±æ€§ãŒ `text/javascript; charset=utf-8^l ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹~scriptã¯ï¼Œè©•ä¾¡ã•ã‚Œãªã„ã“ã¨ã«ãªã‚‹
â€” æ§‹æ–‡è§£æ-æ™‚ã«ã¯å¦¥å½“ãª`~JS~MIMEå‹$ã§ã‚ã£ãŸã¨ã—ã¦ã‚‚ã€‚
â—
For example, scripts with their type attribute set to "text/javascript; charset=utf-8" will not be evaluated, even though that is a valid JavaScript MIME type when parsed.
</p>

<p>
å¤–éƒ¨~JSè³‡æºã«å¯¾ã—ã¦ã¯ã€ã¾ãŸï¼Œãã®`~Content-Type~header$ã®å‡¦ç†~å‘¨ã‚Šã§ç‰¹åˆ¥ãªè€ƒæ…®ç‚¹ãŒé©ç”¨ã•ã‚Œã‚‹
â€” è©³ç´°ã¯ã€`~scriptã‚’æº–å‚™ã™ã‚‹$~algo, ãŠã‚ˆã³
`Fetch^cite `FETCH$r
ã‚’è¦‹ã‚ˆã€‚
â—
Furthermore, again for external JavaScript resources, special considerations apply around `Content-Type` header processing as detailed in the prepare a script algorithm and Fetch. [FETCH]
</p>

			</section>
			<section id="restrictions-for-contents-of-script-elements">
<h4 title="Restrictions for contents of script elements">4.12.1.3. `script^e è¦ç´ ã®å†…å®¹ã«èª²ã•ã‚Œã‚‹åˆ¶ç´„</h4>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®ç¯€ã«è¿°ã¹ã‚‹å¤‰å‰‡çš„ãªåˆ¶ç´„ã‚’é¿ã‘ã‚‹æœ€ã‚‚å®¹æ˜“ã‹ã¤å®‰å…¨ãªä»•æ–¹ã¯ã€~scriptå†…ã«ï¼ˆä¾‹ãˆã° æ–‡å­—åˆ—, æ­£è¦è¡¨ç¾, ~comment ã¨ã—ã¦ï¼‰~literalã§ç¾ã‚Œã‚‹ã‚‚ã®ã®ã†ã¡ï¼»
`&lt;!--^l ï¼ `&lt;script^l ï¼ `&lt;/script^l
ï¼½ã«~ASCIIå¤§å°ç„¡è¦–ã§åˆè‡´ã™ã‚‹ã‚‚ã®ã¯ï¼Œå¸¸ã«ï¼»
`&lt;\!--^l ï¼ `&lt;\script^l ï¼ `&lt;\/script^l
ï¼½ã«~escapeã—ã¦ã€å¼ã®ä¸­ã§ãã®ã‚ˆã†ãªæ§‹æˆå­ã‚’åˆ©ç”¨ã™ã‚‹ã‚ˆã†ãª~codeã‚’æ›¸ãã®ã¯ï¼Œé¿ã‘ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã“ã®ç¯€ã«ãŠã‘ã‚‹åˆ¶ç´„ã¯ï¼Œã¡ã‚‡ã£ã¨ã—ãŸã“ã¨ã§æŠµè§¦ã—æ˜“ãã€ãã†ã™ã‚‹ã“ã¨ã§ï¼Œé™¥ç©½ã¯é¿ã‘ã‚‰ã‚Œã‚‹ã€‚
ã™ãªã‚ã¡ã€æ­´å²çš„ãªç†ç”±ã‹ã‚‰ï¼Œ~HTMLå†…ã® `script$e ~blockã®æ§‹æ–‡è§£æã§ã¯ã€ã“ã‚Œã‚‰ã®æ–‡å­—~ä¸¦ã³ã«é¢ã—ãŸéš›ã®ãµã‚‹ã¾ã„ãŒç›´æ„Ÿã«åã™ã‚‹ã‚ˆã†ãªï¼Œå¤‰å‰‡çš„ã§é¢¨å¤‰ã‚ã‚Šãªå®Ÿæ–½ã«ãªã£ã¦ã„ã‚‹ã€‚
â—
The easiest and safest way to avoid the rather strange restrictions described in this section is to always escape an ASCII case-insensitive match for "&lt;!--" as "&lt;\!--", "&lt;script" as "&lt;\script", and "&lt;/script" as "&lt;\/script" when these sequences appear in literals in scripts (e.g. in strings, regular expressions, or comments), and to avoid writing code that uses such constructs in expressions. Doing so avoids the pitfalls that the restrictions in this section are prone to triggering: namely, that, for historical reasons, parsing of script blocks in HTML is a strange and exotic practice that acts unintuitively in the face of these sequences.
</p>

<p>
`script$e è¦ç´ ã®`å­å­«~textå†…å®¹$ã¯ã€æ¬¡ã®~ABNFã§ä¸ãˆã‚‰ã‚Œã‚‹ `script^P ç”Ÿæˆè¦å‰‡ã«åˆè‡´ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤
â€” ã“ã® ABNF ã®æ–‡å­—~é›†åˆã¯~Unicodeã¨ã™ã‚‹ `ABNF$rï¼š
â—
The script element's descendant text content must match the script production in the following ABNF, the character set for which is Unicode. [ABNF]
</p>

<!-- 
any string that doesn't contain a substring that matches
	not-in-outer|not-in-inner
-->

<pre class="bnf">
script        = outer *( comment-open inner comment-close outer )

outer         = &lt; not-in-outer ã«åˆè‡´ã™ã‚‹æ–‡å­—åˆ—ã¯å«ã¾ãªã„ä»»æ„ã®æ–‡å­—åˆ— &gt;
not-in-outer  = comment-open
inner         = &lt; not-in-inner ã«åˆè‡´ã™ã‚‹æ–‡å­—åˆ—ã¯å«ã¾ãªã„ä»»æ„ã®æ–‡å­—åˆ— &gt;
not-in-inner  = comment-close / script-open

comment-open  = "&lt;!--"
comment-close = "--&gt;"
script-open   = "&lt;" s c r i p t tag-end

s             =  `0053^0x ; U+0053 LATIN CAPITAL LETTER S
s             =/ `0073^0x ; U+0073 LATIN SMALL LETTER S
c             =  `0043^0x ; U+0043 LATIN CAPITAL LETTER C
c             =/ `0063^0x ; U+0063 LATIN SMALL LETTER C
r             =  `0052^0x ; U+0052 LATIN CAPITAL LETTER R
r             =/ `0072^0x ; U+0072 LATIN SMALL LETTER R
i             =  `0049^0x ; U+0049 LATIN CAPITAL LETTER I
i             =/ `0069^0x ; U+0069 LATIN SMALL LETTER I
p             =  `0050^0x ; U+0050 LATIN CAPITAL LETTER P
p             =/ `0070^0x ; U+0070 LATIN SMALL LETTER P
t             =  `0054^0x ; U+0054 LATIN CAPITAL LETTER T
t             =/ `0074^0x ; U+0074 LATIN SMALL LETTER T

tag-end       =  `0009^0x ; U+0009 CHARACTER TABULATION (tab)
tag-end       =/ `000A^0x ; U+000A LINE FEED (LF)
tag-end       =/ `000C^0x ; U+000C FORM FEED (FF)
tag-end       =/ `0020^0x ; U+0020 SPACE
tag-end       =/ `002F^0x ; U+002F SOLIDUS (/)
tag-end       =/ `003E^0x ; U+003E GREATER-THAN SIGN (&gt;)
</pre>

<p>
`script$e è¦ç´ ãŒ`~scriptæ–‡æ›¸åŒ–$ã‚’åŒ…å«ã™ã‚‹å ´åˆã€è¦ç´ ã®å†…å®¹ã«ã‚‚ï¼Œä¸‹ã®ç¯€ã§è¿°ã¹ã‚‹åˆ¶ç´„ãŒæ›´ã«èª²ã•ã‚Œã‚‹ã€‚
â—
When a script element contains script documentation, there are further restrictions on the contents of the element, as described in the section below.
</p>

<div class="example">

<p>
ã“ã®~~å•é¡Œã‚’ï¼Œæ¬¡ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã‚’åŒ…å«ã—ã¦ã„ã‚‹~scriptã§~~èª¬æ˜ã™ã‚‹ï¼š
â—
The following script illustrates this issue. Suppose you have a script that contains a string, as in:
</p>

<pre class="lang-js">
var %example = 'Consider this string: &lt;!-- &lt;script&gt;';
console.log(%example);
</pre>

<p>
ä»®ã«ï¼Œã“ã®æ–‡å­—åˆ—ãŒ `script$e ~blockå†…ã«ç›´ã«è¨˜ã•ã‚ŒãŸå ´åˆã€ä¸Šã®åˆ¶ç´„ã«é•åã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
If one were to put this string directly in a script block, it would violate the restrictions above:
</p>

<pre class="lang-html">
&lt;script&gt;
  var %example = 'Consider this string: &lt;!-- &lt;script&gt;';
  console.log(%example);
&lt;/script&gt;
</pre>

<p>
ã‚ˆã‚Šå¤§ããªå•é¡Œã§ã‚ã‚Šï¼Œãªãœãã‚ŒãŒåˆ¶ç´„ã«é•åã™ã‚‹ã“ã¨ã«ãªã‚‹ã‹ã®ç†ç”±ã¯ã€ä¸Šã®~script~blockãŒï¼Œ<em>å®Ÿéš›ã«ã¯çµ‚äº†ã—ã¦ã„ãªã„</em>ç‚¹ã«ã‚ã‚‹ã€‚
ã“ã®~scriptã«å¯¾ã™ã‚‹æ§‹æ–‡è§£æã•ã‚Œæ–¹ã¯~~ç†è§£ã—ãŒãŸã„ã‚‚ã®ã§ã‚ã‚Šï¼Œçµ‚äº†tagã®æ§˜ã«è¦‹ãˆã‚‹
`&lt;/script&gt;^l
ã¯ã€å®Ÿéš›ã«ã¯ï¼Œä¾ç„¶ã¨ã—ã¦ `script$e ~blockã®ä¸€éƒ¨ã«ãªã‚‹ã€‚
~scriptã¯ï¼ˆçµ‚ç«¯ã—ã¦ã„ãªã„ã®ã§ï¼‰å®Ÿè¡Œã•ã‚Œãªã„ãŒã€ã©ã†ã«ã‹ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ãŸå ´åˆ
â€” ä¾‹ãˆã°~markupãŒæ¬¡ã®ã‚ˆã†ã«ãªã£ã¦ã„ãŸå ´åˆ â€”
~scriptï¼ˆ<mark>å¼·èª¿è¡¨ç¤º</mark>ã•ã‚Œã¦ã„ã‚‹éƒ¨åˆ†ï¼‰ã¯ã€å¦¥å½“ãª~JSã§ãªã„ã®ã§ï¼Œå¤±æ•—ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
The bigger problem, though, and the reason why it would violate those restrictions, is that actually the script would get parsed weirdly: the script block above is not terminated. That is, what looks like a "&lt;/script&gt;" end tag in this snippet is actually still part of the script block. The script doesn't execute (since it's not terminated); if it somehow were to execute, as it might if the markup looked as follows, it would fail because the script (highlighted here) is not valid JavaScript:
</p>

<pre class="lang-html">
&lt;script&gt;<mark>
  var %example = 'Consider this string: &lt;!-- &lt;script&gt;';
  console.log(%example);
&lt;/script&gt;
&lt;!-- è¦‹ã‹ã‘ã«åã—ã€å®Ÿéš›ã«ã¯ï¼Œã“ã“ã‚‚~scriptã®ä¸€éƒ¨ã«ãªã‚‹ã€‚ --&gt;
&lt;script&gt;
 ... // ã“ã“ã‚‚ã¾ã åŒã˜~script~blockå†…ã«ã‚ã‚‹...
</mark>&lt;/script&gt;
</pre>

<!-- 
  var example = 'Consider this string: ...';

despite appearances, this is actually part of the script still!

 ... // this is the same script block still...
 -->

<p>
ã“ã“ã§èµ·ãã¦ã„ã‚‹ã“ã¨ã¯ã€æ—§æ¥ã®ç†ç”±ã‹ã‚‰ï¼Œ
`script$e è¦ç´ ~å†…ã®æ–‡å­—åˆ—ï¼»
`&lt;!--^l ï¼ `&lt;script^l
ï¼½ã‚’å¯¾ã«ã—ãªã‘ã‚Œã°ã€~HTMLã®æ§‹æ–‡è§£æå™¨ã‹ã‚‰ã¯ï¼Œ~blockãŒé–‰ã˜ãŸã‚‚ã®ã¨è¦‹ãªã•ã‚Œãªããªã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
â—
What is going on here is that for legacy reasons, "&lt;!--" and "&lt;script" strings in script elements in HTML need to be balanced in order for the parser to consider closing the block.
</p>

<p>
ã“ã®ç¯€ã®å†’é ­ã§è¨€åŠã—ãŸã‚ˆã†ã«ã€å•é¡Œã«ãªã‚Šå¾—ã‚‹æ–‡å­—åˆ—ã‚’~escapeã™ã‚Œã°ï¼Œã“ã®å•é¡Œã‚’ã¾ã‚‹ã”ã¨é¿ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
By escaping the problematic strings as mentioned at the top of this section, the problem is avoided entirely:
</p>

<pre class="lang-html">
&lt;script&gt;
  /* <span class="comment">
`\s^c ã¯ `s^c ç”¨ã®~escapeåˆ—ã‚’ä¸ãˆã‚‹ã“ã¨ã«æ³¨æ„ã€‚
â—
Note: `\s` is an escape sequence for `s`.
</span> */<mark>
  var %example = 'Consider this string: &lt;\!-- &lt;\script&gt;';
  console.log(%example);
</mark>&lt;/script&gt;
&lt;!-- ã“ã“ã¯å˜ã« 2 ã¤ã®~script~blockã®åˆé–“ã«ã‚ã‚‹~commentã«ãªã‚‹ --&gt;
&lt;script&gt;<mark>
 ... // æ–°ãŸãª~script~block
</mark>&lt;/script&gt;
</pre>
<!-- 
this is just a comment between script blocks
 -->
<p>
ã“ã‚Œã‚‰ã®æ–‡å­—~ä¸¦ã³ãŒ~scriptã®å¼ã®ä¸­ã«è‡ªç„¶ã«ç”Ÿã˜ã‚‹å¯èƒ½æ€§ã‚‚ã‚ã‚‹
â€” æ¬¡ã®ä¾‹ã®ã‚ˆã†ã«ï¼š
â—
It is possible for these sequences to naturally occur in script expressions, as in the following examples:
</p>

<pre class="lang-js">
if (x&lt;!--y) { ... }
if ( player&lt;script ) { ... }
</pre>

<p>
ã“ã®ã‚ˆã†ãªäº‹ä¾‹ã§ã¯ã€æ–‡å­—ãŸã¡ã¯~escapeã§ããªã„ãŒã€ã“ã®å¼ã¯ï¼Œãã®ã‚ˆã†ãªæ–‡å­—~ä¸¦ã³ãŒç”Ÿã˜ãªã„ã‚ˆã†ã«æ›¸ãç›´ã›ã‚‹ï¼š
â—
In such cases the characters cannot be escaped, but the expressions can be rewritten so that the sequences don't occur, as in:
</p>

<pre class="lang-js">
if (x &lt; !--y) { ... }
if (!--y &gt; x) { ... }
if (!(--y) &gt; x) { ... }
if (player &lt; script) { ... }
if (script &gt; player) { ... }
</pre>

<p>
ã“ã†ã™ã‚‹ã“ã¨ã§ï¼Œåˆ¥ã®é™¥ç©½
â€” æ­´å²çš„ãªç†ç”±ã‹ã‚‰ã€`å¤å…¸~script$å†…ã®æ–‡å­—åˆ— 
`&lt;!--^l
ã¯ï¼Œå®Ÿéš›ã«ã¯
`//^l
ã¨åŒã˜ãï¼Œè¡Œ~commentã®é–‹å§‹ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã“ã¨ â€”
ã‚‚é¿ã‘ã‚‰ã‚Œã‚‹ã€‚
â—
Doing this also avoids a different pitfall as well: for related historical reasons, the string "&lt;!--" in classic scripts is actually treated as a line comment start, just like "//".
</p>

</div>

			</section>
			<section id="inline-documentation-for-external-scripts">
<h4 title="Inline documentation for external scripts">4.12.1.4. å¤–éƒ¨~scriptã«å¯¾ã™ã‚‹~inlineæ–‡æ›¸åŒ–</h4>

<p>
`src$a å±æ€§ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ `script$e è¦ç´ ã«å¯¾ã—ã¦ã¯ã€è¦ç´ ã®å†…å®¹ã¯ï¼Œï¼»
å†…å®¹ã‹ã‚‰å°å‡ºã•ã‚Œã‚‹ `text$m ~IDLå±æ€§ã®å€¤ãŒï¼Œæ¬¡ã®~ABNFã«ã‚ˆã‚‹ `documentation^P ç”Ÿæˆè¦å‰‡ã«åˆè‡´ã™ã‚‹
ï¼½ã‚ˆã†ã«ãªã‚‰ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤
â€” ã“ã® ABNF ã®æ–‡å­—~é›†åˆã¯~Unicodeã¨ã™ã‚‹ï¼š
`ABNF$r
â—
If a script element's src attribute is specified, then the contents of the script element, if any, must be such that the value of the text IDL attribute, which is derived from the element's contents, matches the documentation production in the following ABNF, the character set for which is Unicode. [ABNF]
</p>

<pre class="bnf">
documentation = *( *( space / tab / comment ) [ line-comment ] newline )
comment       = slash star *( not-star / star not-slash ) 1*star slash
line-comment  = slash slash *not-newline

; characters
tab           = `0009^0x ; U+0009 CHARACTER TABULATION (tab)
newline       = `000A^0x ; U+000A LINE FEED (LF)
space         = `0020^0x ; U+0020 SPACE
star          = `002A^0x ; U+002A ASTERISK (*)
slash         = `002F^0x ; U+002F SOLIDUS (/)
not-newline   = `0000-0009^0x / `000B-10FFFF^0x
                ; U+000A LINE FEED (LF) ä»¥å¤–ã® `~scalarå€¤$
not-star      = `0000-0029^0x / `002B-10FFFF^0x
                ; U+002A ASTERISK (*) ä»¥å¤–ã® `~scalarå€¤$
not-slash     = `0000-002E^0x / `0030-10FFFF^0x
                ; U+002F SOLIDUS (/) ä»¥å¤–ã® `~scalarå€¤$
</pre>

<!-- 
a Unicode character other than
 -->

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€è¦ç´ ã®å†…å®¹ã‚’ ~JS~commentå†…ã«ç½®ãã“ã¨ã«å¯¾å¿œã™ã‚‹ã€‚
â—
This corresponds to putting the contents of the element in JavaScript comments.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®è¦ä»¶ã¯ã€å‰ç¯€ã«è¿°ã¹ãŸ `script$e è¦ç´ ã®å†…å®¹ã®æ§‹æ–‡ã«èª²ã•ã‚Œã‚‹åˆ¶ç´„ã«å¯¾ã™ã‚‹è¿½åŠ ã§ã‚ã‚‹ã€‚
â—
This requirement is in addition to the earlier restrictions on the syntax of contents of script elements.
</p>

<div class="example">

<p>
ã“ã‚Œã«ã‚ˆã‚Šï¼Œä½œè€…ã¯ã€ä¾ç„¶ã¨ã—ã¦å¤–éƒ¨~script~fileã‚’æŒ‡ã—ã¤ã¤ï¼Œæ–‡æ›¸ã®å†…å´ã«ã‚‚~licenseæƒ…å ±ã‚„~APIæƒ…å ±ãªã©ã®æ–‡æ›¸åŒ–ã‚’å«ã¾ã›ã‚‹ã“ã¨ã‚‚å¯èƒ½ã«ãªã‚‹ã€‚
ã“ã®æ§‹æ–‡ã§ã¯ã€ `src$a å±æ€§ã‚‚ä¾›ã—ã¦ã„ã‚‹ä½œè€…ãŒï¼Œä¸ç”¨æ„ã«å¦¥å½“ãª~scriptã®æ§˜ã«è¦‹ãˆã‚‹~dataã‚’å«ã‚ã‚‹ã“ã¨ãŒãªã„ã‚ˆã†ã«ï¼Œæ‹˜æŸã•ã‚Œã‚‹ã€‚
â—
This allows authors to include documentation, such as license information or API information, inside their documents while still referring to external script files. The syntax is constrained so that authors don't accidentally include what looks like valid script while also providing a src attribute.
</p>

`inline-documentation-1^xCode

</div>

			</section>
			<section id="scriptTagXSLT">
<h4 title="Interaction of script elements and XSLT">4.12.1.5.  `script$e è¦ç´ ã¨ XSLT ã¨ã®ç›¸äº’ä½œç”¨</h4>

~INFORMATIVE

<p>
ã“ã®ä»•æ§˜ã¯ã€~XSLTã¨ `script$e è¦ç´ ã¨ãŒï¼Œã©ã†ç›¸äº’ä½œç”¨ã™ã‚‹ã‹ã¯å®šç¾©ã—ãªã„ã€‚
ã—ã‹ã—ãªãŒã‚‰ã€ã“ã‚Œã‚’å®Ÿéš›ã«å®šç¾©ã—ã¦ã„ã‚‹åˆ¥ã®ä»•æ§˜ãŒç„¡ã„ä¸‹ã§ã®ã€æ—¢å­˜ã®å®Ÿè£…ã«åŸºã¥ãå®Ÿè£…è€…~å‘ã‘ã®æŒ‡é‡ã‚’ï¼Œã„ãã¤ã‹ã“ã“ã«è¿°ã¹ã‚‹ï¼š
â—
This specification does not define how XSLT interacts with the script element. However, in the absence of another specification actually defining this, here are some guidelines for implementers, based on existing implementations:
</p>

<ul>
	<li>
~browserãŒ~DOMã¸ã®ç›´æ¥çš„ãªå½¢å¼å¤‰æ›ã‚’å®Ÿè£…ã™ã‚‹ä¸‹ã§ï¼Œ
`&lt;?xml-stylesheet?&gt;^c
å‡¦ç†å‘½ä»¤ã«ã‚ˆã‚Š ~XSLTå½¢å¼å¤‰æ›~programãŒèª˜ç™ºã•ã‚ŒãŸå ´åˆã€~XSLTå‡¦ç†å™¨ã«ã‚ˆã‚Šä½œæˆã•ã‚Œã‚‹å„ `script$e è¦ç´ ã¯ï¼Œãã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$ã‚’æ­£ã—ãè¨­å®šã—ãŸä¸Šã§ï¼Œå½¢å¼å¤‰æ›ãŒç”Ÿã˜ã‚‹ã«ä¼´ã£ã¦ï¼Œ`å³æ™‚$ã«, æ–‡æ›¸~é †åºã§ï¼ˆãŸã ã—ï¼Œï¼»
`defer$a ï¼ `async$a
ï¼½ã«ã‚ˆã‚‹é †åºã¯é™¤ãï¼‰èµ°ã‚‰ã™å¿…è¦ãŒã‚ã‚‹ã€‚
â—
When an XSLT transformation program is triggered by an &lt;?xml-stylesheet?&gt; processing instruction and the browser implements a direct-to-DOM transformation, script elements created by the XSLT processor need to have its parser document set correctly, and run in document order (modulo scripts marked defer or async), immediately, as the transformation is occurring.
</li>
	<li>
<p>
`XSLTProcessor$I ã® `transformToDocument()$m ~methodã¯ã€ï¼»
`å±ã™ã‚‹é–²è¦§æ–‡è„ˆ$ ~EQ ~NULL
ï¼½ãªã‚‹`æ–‡æ›¸$ã«è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã€‚
ãã‚Œã«å‰‡ã‚Šã€ä½œæˆã•ã‚Œã‚‹ã©ã® `script$e è¦ç´ ã‚‚æ¬¡ã®ã‚ˆã†ã«ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹ï¼š
</p>
		<ul>
			<li>
`~scriptã‚’æº–å‚™ã™ã‚‹$~algoã®ä¸­ã§ï¼Œãã®`é–‹å§‹æ¸ˆã¿~flag$ã‚’ ~T ã«ã—ã¦ã€æ±ºã—ã¦å®Ÿè¡Œã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹ï¼ˆ`~scriptingã¯ä¸èƒ½åŒ–-$ã•ã‚Œã‚‹ï¼‰ã€‚
</li>
			<li>
è¦ç´ ã®`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$ã‚’è¨­å®šã™ã‚‹ã€‚
</li>
			<li>
è¦ç´ ã® `async$m ~IDLå±æ€§ã¯ã€è¦ç´ ãŒ `async$a å†…å®¹~å±æ€§ã‚’æœ‰ã•ãªã„ã¨ãã¯ ~F ã‚’è¿”ã™ã‚ˆã†ã«ã™ã‚‹ã€‚
</li>
		</ul>

â—
The XSLTProcessor transformToDocument() method adds elements to a Document object with a null browsing context, and, accordingly, any script elements they create need to have their "already started" flag set in the prepare a script algorithm and never get executed (scripting is disabled). Such script elements still need to have their parser document set, though, such that their async IDL attribute will return false in the absence of an async content attribute.
</li>
	<li>
`XSLTProcessor$I ã® `transformToFragment()$m ~methodã¯ã€ï¼»
`document.createElementNS()$m
ã‚’åˆ©ç”¨ã—ã¦è¦ç´ ã‚’ä½œæˆã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šï¼Œæ‰‹å‹•ã§ç¯‰ã‹ã‚ŒãŸ`æ–‡æ›¸ç‰‡$
ï¼½ã¨ç­‰ä¾¡ãªã‚‚ã®ã‚’ä½œæˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
å…·ä½“çš„ã«ã¯ã€ `script$e è¦ç´ ã‚’ä½œæˆã™ã‚‹éš›ã«ã¯ï¼Œãã®ï¼»
`æ§‹æ–‡è§£æå™¨~æ–‡æ›¸$ã¯ ~NULL,
`é–‹å§‹æ¸ˆã¿~flag$ã¯ ~F 
ï¼½ã«è¨­å®šã—ãŸä¸Šã§ï¼Œãã®`æ–‡æ›¸ç‰‡$ãŒæ–‡æ›¸~å†…ã«æŒ¿å…¥ã•ã‚ŒãŸæ™‚ç‚¹ã§å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
The XSLTProcessor transformToFragment() method needs to create a fragment that is equivalent to one built manually by creating the elements using document.createElementNS(). For instance, it needs to create script elements with null parser document and that don't have their "already started" flag set, so that they will execute when the fragment is inserted into a document.
</li>
</ul>

<p>
ä¸Šã® 1, 2 ç•ªç›®ã®äº‹ä¾‹ã¨, 3 ç•ªç›®ã®äº‹ä¾‹ã¨ã®é–“ã®ä¸»ãªé•ã„ã¯ã€å‰è€…ã¯`æ–‡æ›¸$ã«å¯¾ã—æ¼”ç®—ã™ã‚‹ä¸€æ–¹ã§ï¼Œå¾Œè€…ã¯`æ–‡æ›¸ç‰‡$ã«å¯¾ã—æ¼”ç®—ã™ã‚‹ç‚¹ã«ã‚ã‚‹ã€‚
â—
The main distinction between the first two cases and the last case is that the first two operate on Documents and the last operates on a fragment.
</p>

			</section>
		</section>
		<section id="the-noscript-element">
<h3 title="The noscript element">4.12.2. `noscript^e è¦ç´ </h3>

<dl class="element-def">

	<dt>`åˆ†é¡$ï¼š</dt>
	<dd>
`~metadataå†…å®¹$ ï¼ `~flowå†…å®¹$ ï¼ `å¥ngå†…å®¹$
â—
Metadata content.
â—
Flow content.
â—
Phrasing content.
</dd>

	<dt>`ã“ã®è¦ç´ ã‚’åˆ©ç”¨ã§ãã‚‹æ–‡è„ˆ$ï¼š</dt>
	<dd>
`~HTMLæ–‡æ›¸$ã® `head$e è¦ç´ ~å†…, ã¾ãŸã¯
`~HTMLæ–‡æ›¸$å†…ã® `å¥ngå†…å®¹$ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€
â€” ãŸã ã—ã€ã„ãšã‚Œã«ã›ã‚ˆï¼Œå…ˆç¥–ã« `noscript$e è¦ç´ ãŒã‚ã‚‹æ‰€ã¯é™¤ãã€‚
â—
In a head element of an HTML document, if there are no ancestor noscript elements.
â—
Where phrasing content is expected in HTML documents, if there are no ancestor noscript elements.
</dd>

	<dt>`å†…å®¹~model$ï¼š</dt>
	<dd>
<p>
è¦ç´ ~ç”¨ã®`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆï¼š
</p>
		<ul>
			<li>
è¦ç´ ãŒ `head$e è¦ç´ ~å†…ã«ã‚ã‚‹å ´åˆã€é †åºã¯å•ã‚ãšï¼Œãã‚Œãã‚ŒãŒï¼»
`link$e, `style$e, `meta$e
ï¼½ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹ã‚ˆã†ãªï¼Œ 0 å€‹ä»¥ä¸Šã®è¦ç´ ã€‚
</li>
			<li>
è¦ç´ ãŒ `head$e è¦ç´ ~å¤–ã«ã‚ã‚‹å ´åˆã€`é€éçš„$ã«ãªã‚‹
â€” ãŸã ã—ã€å­å­«ã« `noscript$e è¦ç´ ãŒã‚ã£ã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ã€‚
</li>
		</ul>

â—
When scripting is disabled, in a head element: in any order, zero or more link elements, zero or more style elements, and zero or more meta elements.
â—
When scripting is disabled, not in a head element: transparent, but there must be no noscript element descendants.
</dd>
	<dd>
ä»–ã®å ´åˆã€ä¸‹ã®æ³¨é‡ˆæ–‡ã«ä¸ãˆã‚‹è¦ä»¶ã«é©åˆã™ã‚‹ã‚ˆã†ãª~textã€‚
â—
Otherwise: text that conforms to the requirements given in the prose.
</dd>

	<dt>`text/html ã«ãŠã‘ã‚‹~tagçœç•¥$ï¼š</dt>
	<dd>
ä¸¡~tagã¨ã‚‚çœç•¥ä¸å¯ã€‚
â—
Neither tag is omissible.
</dd>

	<dt>`å†…å®¹~å±æ€§$ï¼š</dt>
	<dd>
`å¤§åŸŸ~å±æ€§$
â—
Global attributes
</dd>

	<dt>`~accessibilityã®è€ƒæ…®ç‚¹$</dt>
	<dd>
`noscript$AA
â—
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
`HTMLElement$I ã‚’åˆ©ç”¨ã™ã‚‹
â—
Uses HTMLElement.
</dd></dl>

<p>
`noscript$e è¦ç´ ã¯ã€`~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆã¯ï¼Œä½•ã‚‚`è¡¨ç¾-$ã›ãšã€`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆã¯ï¼Œãã®å­ãŸã¡ã‚’`è¡¨ç¾-$ã™ã‚‹ã€‚
ãã‚Œã¯ã€~UAãŒ~scriptingã‚’~supportã™ã‚‹ã‹ã©ã†ã‹ã«å¿œã˜ã¦ï¼Œæ–‡æ›¸ãŒã©ã†æ§‹æ–‡è§£æã•ã‚Œã‚‹ã‹ã‚’é•ãˆã‚‹ã“ã¨ã«ã‚ˆã‚Šã€~UAã«ç•°ãªã‚‹~markupã‚’æç¤ºã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
The noscript element represents nothing if scripting is enabled, and represents its children if scripting is disabled. It is used to present different markup to user agents that support scripting and those that don't support scripting, by affecting how the document is parsed.
</p>

<p>
`noscript$e è¦ç´  %noscript ãŒ
`~HTMLæ–‡æ›¸$ã«åˆ©ç”¨ã•ã‚Œã‚‹å ´åˆã«è¨±å®¹ã•ã‚Œã‚‹å†…å®¹~modelã¯ã€æ¬¡ã«å¾“ã†ï¼š
â—
When used in HTML documents, the allowed content model is as follows:
</p>

<dl class="switch">
	<dt>
%noscript ã¯ `head$e è¦ç´ ~å†…ã«ã‚ã‚‹å ´åˆï¼š
â—
â†“</dt>
	<dd>
		<dl class="switch">
			<dt>
`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆï¼š
â—
In a head element, if scripting is disabled for the noscript element
</dt>
			<dd>
%noscript ã¯ï¼»
`link$e, `style$e, `meta$e
ï¼½è¦ç´ ã®ã¿ã‚’åŒ…å«ã—ã¦ã„ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The noscript element must contain only link, style, and meta elements.
</dd>

			<dt>
`~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆï¼š
â—
In a head element, if scripting is enabled for the noscript element
</dt>
			<dd>
<p>
%noscript ã¯ã€~textã®ã¿ã‚’åŒ…å«ã™ã‚‹ã‹, ã¾ãŸã¯æ¬¡ã‚’æº€ãŸã•ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
</p>

				<ul>
					<li>
<p>
( `æ–‡è„ˆ~è¦ç´ $V, %å…¥åŠ› )
ã¨ã—ã¦
( %noscript, %noscript ã®~textå†…å®¹ )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ`~HTMLç´ ç‰‡~æ§‹æ–‡è§£æ~algo$ã‚’å‘¼å‡ºã—ãŸã¨ãã«ï¼Œæ¬¡ã‚’ã™ã¹ã¦æº€ãŸã™ï¼š
</p>

<ul ><li>`æ§‹æ–‡è§£æ-~error$ã¯ç”Ÿã˜ãªã„
</li><li>~algoã®çµæœã¯ï¼»
`link$e, `style$e, `meta$e
ï¼½è¦ç´ ã®ã¿ã‹ã‚‰ãªã‚‹~nodeã®~listã§ã‚ã‚‹
</li><li>å‰é …ã®~listãŒ %noscript ã®å­ãŸã¡ã§ã‚ã£ãŸã¨ã™ã‚‹ã¨ãï¼Œé©åˆã™ã‚‹
</li></ul>
					</li>
				</ul>

â—
The noscript element must contain only text, except that invoking the HTML fragment parsing algorithm with the noscript element as the context element and the text contents as the input must result in a list of nodes that consists only of link, style, and meta elements that would be conforming if they were children of the noscript element, and no parse errors.
</dd>

		</dl>
	</dd>

	<dt>
%noscript ã¯ `head$e è¦ç´ ~å¤–ã«ã‚ã‚‹å ´åˆï¼š
â—
â†“</dt>
	<dd>
		<dl class="switch">
			<dt>
`~scriptingã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆï¼š
â—
Outside of head elements, if scripting is disabled for the noscript element
</dt>
			<dd>
%noscript ã®å†…å®¹~modelã¯`é€éçš„$ã«ãªã‚‹
â€” ãŸã ã—ï¼Œ %noscript ã®å…ˆç¥–ã« `noscript$e è¦ç´ ãŒã‚ã£ã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ï¼ˆã™ãªã‚ã¡ï¼Œ
`noscript$e ã¯å…¥å­ã«ã§ããªã„ï¼‰ã€‚
â—
The noscript element's content model is transparent, with the additional restriction that a noscript element must not have a noscript element as an ancestor (that is, noscript can't be nested).
<dd>

			<dt>
`~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆï¼š
â—
Outside of head elements, if scripting is enabled for the noscript element
</dt>
			<dd>
<p>
%noscript ã¯ã€~textã®ã¿ã‚’åŒ…å«ã™ã‚‹ã‹, ã¾ãŸã¯æ¬¡ã‚’æº€ãŸã•ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
</p>

				<ul>
					<li>
<p>
ä¸‹ã®~algoã‚’èµ°ã‚‰ã›ãŸã¨ãã«ï¼Œæ¬¡ã‚’ã™ã¹ã¦æº€ãŸã™ï¼š
</p>

<ul ><li>ä¾‹å¤–ã¯æŠ•å‡ºã•ã‚Œãªã„
</li><li>çµæœã®æ–‡æ›¸ã¯ã€ï¼»
`noscript$e, `script$e
ï¼½è¦ç´ ã‚’å«ã¾ãªã„ï¼Œé©åˆ~æ–‡æ›¸ã«ãªã‚‹
</li><li>`~HTMLæ§‹æ–‡è§£æå™¨$ã«ãŠã„ã¦ï¼Œ`æ§‹æ–‡è§£æ-~error$ã¯ç”Ÿã˜ãªã„
</li></ul>
					</li>
				</ul>

â—
The noscript element must contain only text, except that the text must be such that running the following algorithm results in a conforming document with no noscript elements and no script elements, and such that no step in the algorithm throws an exception or causes an HTML parser to flag a parse error:
</dd>
			<dd>
<p>
~algoã¯ã€æ¬¡ã§ä¸ãˆã‚‰ã‚Œã‚‹ï¼š
â—
â†‘</p>
				<ol>
					<li>
å½“ã®æ–‡æ›¸ã‹ã‚‰ã™ã¹ã¦ã® `script$e è¦ç´ ã‚’é™¤å»ã™ã‚‹
â—
Remove every script element from the document.
</li>
					<li>
<p>
å½“ã®æ–‡æ›¸~å†…ã®~EACH ( `noscript$e è¦ç´  %E ) ã«å¯¾ã—ï¼š
â—
Make a list of every noscript element in the document. For every noscript element in that list, perform the following steps:
</p>

						<ol>
							<li>
%E ã® `outerHTML$m å±æ€§ ~SET %E ã®`å­~textå†…å®¹$
ï¼ˆã“ã‚Œã«ã‚ˆã‚‹å‰¯ä½œç”¨ã¨ã—ã¦ï¼Œ %E ã¯å½“ã®æ–‡æ›¸ã‹ã‚‰é™¤å»ã•ã‚Œã‚‹ã€‚ï¼‰
`DOMPARSING$r
â—
Let s be the child text content of the noscript element.
â—
Set the outerHTML attribute of the noscript element to the value of s. (This, as a side-effect, causes the noscript element to be removed from the document.) [DOMPARSING]
</li>
						</ol>
					</li>
				</ol>
			</dd>
		</dl>
	</dd>
</dl>

<p class="note">æ³¨è¨˜ï¼š
ä¸Šè¿°ã® ã²ã­ãã‚ŒãŸå–æ‰±ã„ã™ã¹ã¦ãŒè¦æ±‚ã•ã‚Œã‚‹
â€” æ­´å²çš„ãªç†ç”±ã‹ã‚‰ï¼Œ`~HTMLæ§‹æ–‡è§£æå™¨$ã«ã‚ˆã‚‹ `noscript$e è¦ç´ ã«å¯¾ã™ã‚‹å–æ‰±ã„ã¯ã€ï¼»
æ§‹æ–‡è§£æå™¨ãŒå‘¼å‡ºã•ã‚ŒãŸã¨ãã«ï¼Œãã®è¦ç´ ~ç”¨ã®`~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦ã„ãŸã‹ã©ã†ã‹$
ï¼½ã«å¿œã˜ã¦ï¼Œç•°ãªã‚‹ã®ã§ã€‚
â—
All these contortions are required because, for historical reasons, the noscript element is handled differently by the HTML parser based on whether scripting was enabled or not when the parser was invoked.
</p>

<p>
`~XMLæ–‡æ›¸$ã«ã¯ã€ `noscript$e è¦ç´ ã¯åˆ©ç”¨ã•ã‚Œã¦ã¯ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The noscript element must not be used in XML documents.
</p>

<p class="note">æ³¨è¨˜ï¼š
`noscript$e è¦ç´ ãŒåŠ¹æœã‚’åŠã¼ã™ã®ã¯ï¼Œ`~HTMLæ§‹æ–‡$ã«é™ã‚‰ã‚Œã€`~XMLæ§‹æ–‡$ã«ã¯åŠ¹æœã¯åŠã°ãªã„ã€‚
ãã‚Œã¯ï¼Œ~scriptãŒå¯èƒ½åŒ–ã•ã‚Œã¦ã„ã‚‹ä¸‹ã§ã¯ã€æœ¬è³ªçš„ã«ï¼»
è¦ç´ ã®å†…å®¹ã‚’æœ¬å½“ã®è¦ç´ ã¨ã—ã¦ã§ã¯ãªãï¼Œç´”ç²‹ãª~textã¨ã—ã¦æ‰±ã†
ï¼½ã‚ˆã†ã«ï¼Œæ§‹æ–‡è§£æå™¨ã‚’ â€œåˆ‡ã‚‹â€ ã‚ˆã†ã«åƒããŒã€~XMLã«ã¯ï¼Œã“ã‚Œã‚’è¡Œã†ä»•çµ„ã¿ã¯å®šç¾©ã•ã‚Œã¦ã„ãªã„ã®ã§ã€‚
â—
The noscript element is only effective in the HTML syntax, it has no effect in the XML syntax. This is because the way it works is by essentially "turning off" the parser when scripts are enabled, so that the contents of the element are treated as pure text and not as real elements. XML does not define a mechanism by which to do this.
</p>

<p>
`noscript$e è¦ç´ ã«ã¯ã€ä»–ã®è¦ä»¶ã¯ãªã„ã€‚
ç‰¹ã«ï¼Œè¦ç´ ~ç”¨ã®`~scriptingã¯å¯èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹ã¨ãã§ã‚‚ã€
`noscript$e è¦ç´ ã®å­ãŸã¡ãŒ
`~formæå‡º$, ~scripting, ç­‰ã€…, ã‹ã‚‰å…ã‚Œã‚‹ã“ã¨ã¯ãªã„ã€‚
â—
The noscript element has no other requirements. In particular, children of the noscript element are not exempt from form submission, scripting, and so forth, even when scripting is enabled for the element.
</p>

<div class="example">

<p>
æ¬¡ã®ä¾‹ã§ã¯ã€~scriptã«å¯¾ã™ã‚‹~fallbackã‚’ä¾›ã™ã‚‹ãŸã‚ã«
`noscript$e è¦ç´ ãŒåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ï¼š
â—
In the following example, a noscript element is used to provide fallback for a script.
</p>

`noscript-1^xCode

<p>
~scriptãŒä¸èƒ½åŒ–ã•ã‚Œã¦ã„ã‚‹ä¸‹ã§ã¯ã€~serverå´ã§è¨ˆç®—ã‚’è¡Œã‚ã›ã‚‹ã‚ˆã†ãª~buttonãŒç¾ã‚Œã‚‹ã€‚
ä¸€æ–¹ã§ï¼Œ~scriptãŒå¯èƒ½åŒ–ã•ã‚Œã¦ã„ã‚‹ä¸‹ã§ã¯ã€ãã®å ´ã§å€¤ãŒç®—å‡ºã•ã‚Œã‚‹ã€‚
â—
When script is disabled, a button appears to do the calculation on the server side. When script is enabled, the value is computed on-the-fly instead.
</p>

<p>
`noscript$e è¦ç´ ã¯ã€ â€œãªã¾ãã‚‰â€ ã§ã‚ã‚‹ã€‚
~pageã®~scriptãŒå¯èƒ½åŒ–ã•ã‚Œã¦ã„ã¦ã‚‚ï¼Œä½•ã‚‰ã‹ã®ç†ç”±ã§å¤±æ•—ã™ã‚‹ã“ã¨ã¯ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ï¼Œä¸€èˆ¬ã«ã€ `noscript$e ã®åˆ©ç”¨ã¯é¿ã‘ã‚‹æ–¹ãŒè‰¯ã„
â€” æ¬¡ã®ä¾‹ã®ã‚ˆã†ã«ã€ã¾ãšï¼Œ~scriptãªã—ãŒ~~å‰æã®~pageã«ã—ãŸä¸Šã§ã€ï¼»
~scriptãŒæˆåŠŸã—ãŸãªã‚‰ï¼Œãã®å ´ã§ ãã®çµæœã‚’åˆ©ç”¨ã™ã‚‹ã‚ˆã†ã«~pageã‚’å¤‰æ›´ã™ã‚‹
ï¼½ã‚ˆã†ã«ï¼Œè¨­è¨ˆã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šï¼š
â—
The noscript element is a blunt instrument. Sometimes, scripts might be enabled, but for some reason the page's script might fail. For this reason, it's generally better to avoid using noscript, and to instead design the script to change the page from being a scriptless page to a scripted page on the fly, as in the next example:
</p>

`noscript-2^xCode

<p>
ã“ã®æŠ€æ³•ã¯ã€ `noscript$e ãŒè¨±å®¹ã•ã‚Œãªã„`~XMLæ–‡æ›¸$ã«ãŠã„ã¦ã‚‚æœ‰ç”¨ã«ãªã‚‹ã€‚
â—
The above technique is also useful in XML documents, since noscript is not allowed there.
</p>

</div>

		</section>
		<section id="the-template-element">
<h3 title="The template element">4.12.3. `template^e è¦ç´ </h3>

<dl class="element-def">
	<dt>`åˆ†é¡$ï¼š</dt>
	<dd>
`~metadataå†…å®¹$ ï¼ `~flowå†…å®¹$ ï¼ `å¥ngå†…å®¹$ ï¼ `~scriptã‚’~supportã™ã‚‹è¦ç´ $
â—
Metadata content.
â—
Flow content.
â—
Phrasing content.
â—
Script-supporting element.
</dd>

	<dt>`ã“ã®è¦ç´ ã‚’åˆ©ç”¨ã§ãã‚‹æ–‡è„ˆ$ï¼š</dt>
	<dd>
`~metadataå†…å®¹$ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€ã€‚
â—
Where metadata content is expected.
</dd>
	<dd>
`å¥ngå†…å®¹$ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€ã€‚
â—
Where phrasing content is expected.
</dd>
	<dd>
`~scriptã‚’~supportã™ã‚‹è¦ç´ $ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€ã€‚
â—
Where script-supporting elements are expected.
</dd>
	<dd>
`span$a å±æ€§ã‚’æœ‰ã•ãªã„ `colgroup$e è¦ç´ ã®å­ã¨ã—ã¦ã€‚
â—
As a child of a colgroup element that doesn't have a span attribute.
</dd>

	<dt>`å†…å®¹~model$ï¼š</dt>
	<dd>
`ãªã—$ï¼ˆã‚ˆã‚Šæ˜ç¢ºã«ã¯ï¼Œ
<a href="#template-example">ä¾‹ã‚’è¦‹ã‚ˆ</a>ã€‚
ï¼‰
â—
Nothing (for clarification, see example).
</dd>

	<dt>`text/html ã«ãŠã‘ã‚‹~tagçœç•¥$ï¼š</dt>
	<dd>
ä¸¡~tagã¨ã‚‚çœç•¥ä¸å¯ã€‚
â—
Neither tag is omissible.
</dd>

	<dt>`å†…å®¹~å±æ€§$ï¼š</dt>
	<dd>
`å¤§åŸŸ~å±æ€§$
â—
Global attributes
</dd>

	<dt>`~accessibilityã®è€ƒæ…®ç‚¹$</dt>
	<dd>
`template$AA
â—
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
<pre class="idl">
[Exposed=Window]
interface `HTMLTemplateElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  readonly attribute `DocumentFragment$I `content$m;
};
</pre>
</dd>

</dl>

<p>
`template$e è¦ç´ ã¯ã€~scriptã«ã‚ˆã‚Šï¼Œ~cloneã—ãŸã‚Šæ–‡æ›¸~å†…ã«æŒ¿å…¥ã§ãã‚‹ã‚ˆã†ãªï¼Œ~HTMLç´ ç‰‡ã‚’å®£è¨€ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
The template element is used to declare fragments of HTML that can be cloned and inserted in the document by script.
</p>

<p>
å…·ç¾åŒ–ã«ãŠã„ã¦ã¯ã€ `template$e è¦ç´ ã¯ä½•ã‚‚`è¡¨ç¾-$ã—ãªã„ã€‚
â—
In a rendering, the template element represents nothing.
</p>

<p>
`template$e è¦ç´ ã®`~templateå†…å®¹$ã¯ã€è¦ç´ ~è‡ªèº«ã®å­ã§ã¯ãªã„ã€‚
â—
The template contents of a template element are not children of the element itself.
</p>

<p class="note">æ³¨è¨˜ï¼š
~DOMæ“ä½œã®çµæœã¨ã—ã¦ï¼Œ `template$e è¦ç´ ãŒ `Text$I ~nodeã‚„è¦ç´ ~nodeã‚’åŒ…å«ã™ã‚‹ã“ã¨ã‚‚ã‚¢ãƒªã ãŒã€ `template$e è¦ç´ ã®å†…å®¹~modelã¯`ãªã—$ã¨å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã®ã§ï¼Œãã‚Œã¯é•åã«ãªã‚‹ã€‚
â—
It is also possible, as a result of DOM manipulation, for a template element to contain Text nodes and element nodes; however, having any is a violation of the template element's content model, since its content model is defined as nothing.
</p>

<div class="example" id="template-example">

<p>
ä¾‹ãˆã°ã€æ¬¡ã®æ–‡æ›¸ã‚’è€ƒãˆã‚‹ï¼š
â—
For example, consider the following document:
</p>

`template-1^xCode

<p>
`template$e å†…ã® `p$e è¦ç´ ã¯ã€
~DOMå†…ã§ã¯ `template$e ã®å­<em>ã§ã¯ãªã„</em>
â€” ãã‚Œã¯ã€ `template$e è¦ç´ ã® `content$m ~IDLå±æ€§ã‹ã‚‰è¿”ã•ã‚Œã‚‹`æ–‡æ›¸ç‰‡$ã®å­ã§ã‚ã‚‹ã€‚
â—
The p element in the template is not a child of the template in the DOM; it is a child of the DocumentFragment returned by the template element's content IDL attribute.
</p>

<p>
~scriptãŒ `template$e è¦ç´ ~ä¸Šã® `appendChild()$m ã‚’~callã—ãŸå ´åˆã€
ï¼ˆä»–ã®è¦ç´ ã«å¯¾ã™ã‚‹ã¨ãã¨åŒæ§˜ã«ï¼‰ `template$e è¦ç´ ã«å­ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã«ãªã‚‹
â€” ã—ã‹ã—ãªãŒã‚‰ï¼Œãã†ã™ã‚‹ã¨ã€
`template$e è¦ç´ ã®å†…å®¹~modelã«é•åã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
If the script were to call appendChild() on the template element, that would add a child to the template element (as for any other element); however, doing so is a violation of the template element's content model.
</p>

</div>

<dl class="domintro">
	<dt>%~template . `content$m</dt>
	<dd>
`~templateå†…å®¹$ï¼ˆ `æ–‡æ›¸ç‰‡$ ï¼‰ã‚’è¿”ã™ã€‚
â—
Returns the template contents (a DocumentFragment).
</dd>
</dl>

<div class="algorithm">
<p>
å„ `template$e è¦ç´ ã«ã¯ï¼Œ`æ–‡æ›¸ç‰‡$ãŒçµä»˜ã‘ã‚‰ã‚Œã€ãã‚ŒãŒ è¦ç´ ã®
`~templateå†…å®¹@
ã«ãªã‚‹ã€‚
`~templateå†…å®¹$ã«ã¯ã€
<a href="~HTMLdom#no-browsing-context">é©åˆæ€§~è¦ä»¶ã¯ãªã„</a>
ã€‚
~UAã¯ã€ `template$e è¦ç´  %è¦ç´  ã‚’ä½œæˆã™ã‚‹ã¨ãã¯ï¼Œæ¬¡ã®æ‰‹ç¶šãã‚’èµ°ã‚‰ã›ã¦ï¼Œ %è¦ç´  ã®`~templateå†…å®¹$ã‚’ç¢ºç«‹ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
Each template element has an associated DocumentFragment object that is its template contents. The template contents have no conformance requirements. When a template element is created, the user agent must run the following steps to establish the template contents:
</p>

<ol>
	<li>
%æ–‡æ›¸ ~LET %è¦ç´  ã®`~nodeæ–‡æ›¸$ã®`~templateå†…å®¹ã‚’æ‰€æœ‰ã™ã‚‹é©åˆ‡ãªæ–‡æ›¸$
â—
Let doc be the template element's node document's appropriate template contents owner document.
</li>
	<li>
%æ–‡æ›¸ç‰‡ ~LET æ¬¡ã®ã‚ˆã†ã«ã•ã‚ŒãŸï¼Œæ–°ãŸãª`æ–‡æ›¸ç‰‡$
â‡’ï¼ƒ
`~nodeæ–‡æ›¸$ ~SET %æ–‡æ›¸,
`~host$ ~SET %è¦ç´ 
â—
Create a DocumentFragment object whose node document is doc and host is the template element.
</li>
	<li>
%è¦ç´  ã®`~templateå†…å®¹$ ~SET %æ–‡æ›¸ç‰‡
â—
Set the template element's template contents to the newly created DocumentFragment object.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`æ–‡æ›¸$ %æ–‡æ›¸ ã®
`~templateå†…å®¹ã‚’æ‰€æœ‰ã™ã‚‹é©åˆ‡ãªæ–‡æ›¸@
ã¯ã€æ¬¡ã®~algoã‹ã‚‰è¿”ã•ã‚Œã‚‹`æ–‡æ›¸$ã¨ã—ã¦å®šç¾©ã•ã‚Œã‚‹ï¼š
â—
A Document doc's appropriate template contents owner document is the Document returned by the following algorithm:
</p>
<ol>
	<li>
~IFï¼»
%æ–‡æ›¸ ã¯ã€ã‚ã‚‹`æ–‡æ›¸$ã®`ä¸æ´»~templateæ–‡æ›¸$ã§ã‚ã‚‹
ï¼½
â‡’
~RET %æ–‡æ›¸
â—
If doc is not a Document created by this algorithm, then:
</li>
	<li>
%ä¸æ´»~æ–‡æ›¸ ~LET %æ–‡æ›¸ ã®`ä¸æ´»~templateæ–‡æ›¸$
â—
</li>
	<li>
~IFï¼»
%ä¸æ´»~æ–‡æ›¸ ~NEQ Îµ
ï¼½
â‡’
~RET %ä¸æ´»~æ–‡æ›¸
â—
If doc does not yet have an associated inert template document, then:
</li>
	<li>
%ä¸æ´»~æ–‡æ›¸ ~LET æ–°ãŸãª`æ–‡æ›¸$ï¼ˆãã‚ŒãŒ`å±ã™ã‚‹é–²è¦§æ–‡è„ˆ$ ~EQ ~NULL ï¼‰
â—
Let new doc be a new Document (whose browsing context is null). This is "a Document created by this algorithm" for the purposes of the step above.
</li>
	<li>
~IFï¼»
%æ–‡æ›¸ ã¯`~HTMLæ–‡æ›¸$ã§ã‚ã‚‹
ï¼½
â‡’
%ä¸æ´»~æ–‡æ›¸ ã‚‚`~HTMLæ–‡æ›¸$ã«ã™ã‚‹
â—
If doc is an HTML document, mark new doc as an HTML document also.
</li>
	<li>
%æ–‡æ›¸ ã®`ä¸æ´»~templateæ–‡æ›¸$ ~SET %ä¸æ´»~æ–‡æ›¸
â—
Let doc's associated inert template document be new doc.
</li>
	<li>
~RET %ä¸æ´»~æ–‡æ›¸
â—
Set doc to doc's associated inert template document.
</li>
</ol>

<p>
ã“ã®~algoã®ç›®çš„ã«ãŠã„ã¦ã¯ã€å„ `æ–‡æ›¸$ã«ã¯ï¼Œè‡ªèº«ã®`~templateå†…å®¹$ã‚’ä¿æŒã™ã‚‹ãŸã‚ã®
`ä¸æ´»~templateæ–‡æ›¸@
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â€” ãã‚Œã¯ã€`æ–‡æ›¸$ã¾ãŸã¯ Îµ ï¼ˆ~~å­˜åœ¨ã—ãªã„ï¼‰ã§ã‚ã‚Šï¼Œå¿…è¦ã«å¿œã˜ã¦ä½œæˆã•ã‚Œã‚‹ã€‚
â—
â†‘</p>

<p class="note">æ³¨è¨˜ï¼š
ã—ãŸãŒã£ã¦ï¼Œã“ã®~algoã«ã‚ˆã‚Šä½œæˆã•ã‚ŒãŸã‚‚ã®ã§ãªã„å„ `æ–‡æ›¸$ã¯ã€ï¼»
è‡ªèº«ã® `template$e è¦ç´ ã™ã¹ã¦ã®`~templateå†…å®¹$
ï¼½ã‚’ï¼Œï¼»
ãã‚Œã‚‰ãŒ ã©ã®`é–²è¦§æ–‡è„ˆ$ã«ã‚‚å±ã•ãšï¼Œä¸æ´»ã§ã‚ã‚Šç¶šã‘ã‚‹ï¼ˆä¾‹ï¼š ~scriptã¯èµ°ã‚‰ã›ãªã„ï¼‰ã‚ˆã†ã«ã™ã‚‹
ï¼½ãŸã‚ã«æ‰€æœ‰ã™ã‚‹ãŸã‚ã®ã€ä»£ç†ã¨ã—ã¦å‹•ä½œã™ã‚‹ã‚ˆã†ãªå˜ç‹¬ã®`æ–‡æ›¸$
â€” `ä¸æ´»~templateæ–‡æ›¸$ â€”
ã‚’å–å¾—ã™ã‚‹ã€‚
`ä¸æ´»~templateæ–‡æ›¸$ã®å†…å´ã«ã‚ã‚‹ `template$e è¦ç´ ã¯ã€å½“é¢ã®é–“ã¯
ã€ä¸æ´»ã§ãªããªã‚‹ã¾ã§ã¯ã€‘
å˜ã«åŒã˜`æ–‡æ›¸$ã‚’ï¼Œãã®å†…å®¹ã®æ‰€æœ‰è€…ã¨ã—ã¦å†åˆ©ç”¨ã™ã‚‹ã€‚
â—
Each Document not created by this algorithm thus gets a single Document to act as its proxy for owning the template contents of all its template elements, so that they aren't in a browsing context and thus remain inert (e.g. scripts do not run). Meanwhile, template elements inside Document objects that are created by this algorithm just reuse the same Document owner for their contents.
â—
Return doc.
</p>
</div>

<div class="algorithm">
<p id="template-adopting-steps">
`template$e è¦ç´ ã«å¯¾ã™ã‚‹`å—å…¥-æ™‚ã®æ‰‹ç¶šã$ã¯ã€æ‰€ä¸ã®
( %~node, %æ—§-æ–‡æ›¸ )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
The adopting steps (with node and oldDocument as parameters) for template elements are the following:
</p>

<ol>
	<li>
<p>
%æ–‡æ›¸ ~LET %~node ã®`~nodeæ–‡æ›¸$ã®`~templateå†…å®¹ã‚’æ‰€æœ‰ã™ã‚‹é©åˆ‡ãªæ–‡æ›¸$
â—
Let doc be node's node document's appropriate template contents owner document.
</p>

<p class="note">æ³¨è¨˜ï¼š
%~node ã®`~nodeæ–‡æ›¸$ã¯ã€ç›´å‰ã« %~node ã‚’å—å…¥ã—ãŸ`æ–‡æ›¸$ã§ã‚ã‚‹ã€‚
ã€ %æ—§-æ–‡æ›¸ ã§ã¯ãªãï¼ˆ %æ—§-æ–‡æ›¸ ã¯ã“ã®æ‰‹ç¶šãã®ä¸­ã§ã¯åˆ©ç”¨ã•ã‚Œã¦ã„ãªã„ï¼‰ã€‚ã€‘
â—
node's node document is the Document object that node was just adopted into.
</p>
	</li>
	<li>
%æ–‡æ›¸ ã«`~nodeã‚’å—å…¥ã™ã‚‹$( %~node ã®ï¼ˆ`æ–‡æ›¸ç‰‡$ã§ã‚ã‚‹ï¼‰`~templateå†…å®¹$ )
â—
Adopt node's template contents (a DocumentFragment object) into doc.
</li>
</ol>
</div>

<div class="algo">
`content@m
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`~templateå†…å®¹$
â—
The content IDL attribute must return the template element's template contents.
</div>

<hr>

<div class="algorithm">
<p>
`template$e è¦ç´ ~ç”¨ã®`~cloneæ™‚ã®æ‰‹ç¶šã$ã¯ã€æ‰€ä¸ã®
( %è¤‡è£½, %~node, %æ–‡æ›¸, %å­ã‚‚~cloneã™ã‚‹~flag )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
The cloning steps for a template element node being cloned to a copy copy must run the following steps:
</p>
<ol>
	<li>
~IFï¼»
%å­ã‚‚~cloneã™ã‚‹~flag ~EQ Îµ
ï¼½
â‡’
~RET
â—
If the clone children flag is not set in the calling clone algorithm, return.
</li>
	<li>
<p>
%~node ã®`~templateå†…å®¹$ã® ~EACH ( å­ %å­ ) ã«å¯¾ã—ï¼š
</p>
		<ol>
			<li>
%~clone ~LET `~nodeã‚’~cloneã™ã‚‹$( %å­, %è¤‡è£½ ã®`~templateå†…å®¹$ã®`~nodeæ–‡æ›¸$, `å­ã‚‚~cloneã™ã‚‹^i )
</li>
			<li>
%è¤‡è£½ ã®`~templateå†…å®¹$ã« %~clone ã‚’ä»˜åŠ ã™ã‚‹
</li>
		</ol>

â—
Let copied contents be the result of cloning all the children of node's template contents, with document set to copy's template contents's node document, and with the clone children flag set.
â—
Append copied contents to copy's template contents.
</li>
</ol>
</div>

<div class="example">

<p>
æ¬¡ã®ä¾‹ã®~scriptã¯ã€è¦ç´ ~æ§‹é€ ã‚’ä¾›ã™ã‚‹ `template$e ã‚’åˆ©ç”¨ã—ã¦ï¼Œ
4 ~columnã‹ã‚‰ãªã‚‹~tableã‚’ ã‚ã‚‹~dataæ§‹é€ ã‹ã‚‰ã®~dataã§æ‹¡å……ã™ã‚‹
â€” æ‰‹å‹•ã§~markupã—ã¦æ§‹é€ ã‚’ç”Ÿæˆã™ã‚‹ä»£ã‚ã‚Šã«ï¼š
â—
In this example, a script populates a table four-column with data from a data structure, using a template to provide the element structure instead of manually generating the structure from markup.
</p>

`template-2^xCode

<p>
ã“ã®ä¾‹ã§ã¯ã€
`template$e ã®å†…å®¹~ä¸Šã§ `cloneNode()$m ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ãŒï¼ŒåŒã˜ã“ã¨ã‚’è¡Œã†
`document.importNode()$m ã‚’åˆ©ç”¨ã—ã¦ã‚‚ç­‰ä¾¡ã«ãªã‚‹ã€‚
ã“ã‚Œã‚‰ã®~APIã®å”¯ä¸€ã®ç›¸é•ã¯ã€ã„ã¤`~nodeæ–‡æ›¸$ãŒæ›´æ–°ã•ã‚Œã‚‹ã‹ã«ãªã‚‹ï¼š
`cloneNode()$m ã§ã¯ï¼Œ `appendChild()$m ã§~nodeãŒä»˜åŠ ã•ã‚Œã‚‹ã¨ã ï¼
`document.importNode()$m ã§ã¯ï¼Œ~nodeãŒ~cloneã•ã‚Œã‚‹ã¨ãã«æ›´æ–°ã•ã‚Œã‚‹ã€‚
â—
This example uses cloneNode() on the template's contents; it could equivalently have used document.importNode(), which does the same thing. The only difference between these two APIs is when the node document is updated: with cloneNode() it is updated when the nodes are appended with appendChild(), with document.importNode() it is updated when the nodes are cloned.
</p>

</div>

			<section id="template-XSLT-XPath">
<h4 title="Interaction of template elements with XSLT and XPath">4.12.3.1. `template$e è¦ç´ ã¨~XSLT, ~XPathã¨ã®ç›¸äº’ä½œç”¨</h4>

~INFORMATIVE

<p>
ã“ã®ä»•æ§˜ã¯ã€~XSLTã¨ `template$e è¦ç´ ã¨ãŒï¼Œã©ã†ç›¸äº’ä½œç”¨ã™ã‚‹ã‹ã¯å®šç¾©ã—ãªã„ã€‚
ã—ã‹ã—ãªãŒã‚‰ã€ã“ã‚Œã‚’å®Ÿéš›ã«å®šç¾©ã—ã¦ã„ã‚‹åˆ¥ã®ä»•æ§˜ãŒç„¡ã„ä¸‹ã§ã®ã€æ—¢å­˜ã®å®Ÿè£…ã«åŸºã¥ãï¼Œå®Ÿè£…è€…ã«å¯¾ã™ã‚‹ã„ãã¤ã‹ã®æŒ‡é‡ã‚’ã“ã“ã«è¿°ã¹ã‚‹ã€‚
ã“ã‚Œã‚‰ã®æŒ‡é‡ã¯ã€ã“ã®ä»•æ§˜ã«è¿°ã¹ã‚‹ä»–ã®å‡¦ç†ã¨æ•´åˆã™ã‚‹ã‚ˆã†ã«æ„å›³ã•ã‚Œã¦ã„ã‚‹ï¼š
â—
This specification does not define how XSLT and XPath interact with the template element. However, in the absence of another specification actually defining this, here are some guidelines for implementers, which are intended to be consistent with other processing described in this specification:
</p>

  <ul>
	<li>
ï¼»
ã“ã®ä»•æ§˜ã«è¿°ã¹ã‚‹ã‚ˆã†ã«å‹•ä½œã™ã‚‹`~XMLæ§‹æ–‡è§£æå™¨$
ï¼½ã«åŸºã¥ã~XSLTå‡¦ç†å™¨ã¯ã€å½¢å¼å¤‰æ›-ã®ç›®çš„ã«ãŠã„ã¦ã¯ï¼Œï¼»
`template$e è¦ç´ ãŒ ãã®`~templateå†…å®¹$ã®å­å­«ã‚’åŒ…å«ã—ã¦ã„ãŸ
ï¼½ã‹ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
An XSLT processor based on an XML parser that acts as described in this specification needs to act as if template elements contain as descendants their template contents for the purposes of the transform.
</li>
	<li>
~DOMã‚’å‡ºåŠ›ã™ã‚‹~XSLTå‡¦ç†å™¨ã¯ã€ï¼»
`template$e è¦ç´ ã®ä¸­ã¸è¡Œã~nodeãŒï¼Œè¦ç´ ã®`~templateå†…å®¹$ã®ä¸­ã«ç½®ã‹ã‚Œã‚‹
ï¼½ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
An XSLT processor that outputs a DOM needs to ensure that nodes that would go into a template element are instead placed into the element's template contents.
</li>
	<li>
~XPath~DOM~APIã‚’åˆ©ç”¨ã™ã‚‹~XPathå¼ã‚’è©•ä¾¡ã™ã‚‹éš›ã«ã¯ã€ã“ã®ä»•æ§˜ã«è¿°ã¹ã‚‹ï¼»
`~HTMLæ§‹æ–‡è§£æå™¨$ ï¼ `~XMLæ§‹æ–‡è§£æå™¨$
ï¼½ã‚’åˆ©ç”¨ã—ã¦æ§‹æ–‡è§£æã•ã‚ŒãŸ`æ–‡æ›¸$ã«é©ç”¨ã•ã‚Œã‚‹ã¨ãã¯ï¼Œ`~templateå†…å®¹$ã‚’ç„¡è¦–ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
XPath evaluation using the XPath DOM API when applied to a Document parsed using the HTML parser or the XML parser described in this specification needs to ignore template contents.
</li>
</ul>

			</section>
		</section>
		<section id="the-slot-element">
<h3 title="The slot element">4.12.4. `slot^e è¦ç´ </h3>

<dl class="element-def">

	<dt>`åˆ†é¡$ï¼š</dt>
	<dd>
`~flowå†…å®¹$ ï¼ `å¥ngå†…å®¹$
â—
Flow content.
â—
Phrasing content.
</dd>

	<dt>`ã“ã®è¦ç´ ã‚’åˆ©ç”¨ã§ãã‚‹æ–‡è„ˆ$ï¼š</dt>
	<dd>
`å¥ngå†…å®¹$ãŒæœŸå¾…ã•ã‚Œã‚‹æ‰€ã€‚
â—
Where phrasing content is expected.
</dd>

	<dt>`å†…å®¹~model$ï¼š</dt>
	<dd>
`é€éçš„$
â—
Transparent
</dd>

	<dt>`text/html ã«ãŠã‘ã‚‹~tagçœç•¥$ï¼š</dt>
	<dd>
ä¸¡~tagã¨ã‚‚çœç•¥ä¸å¯ã€‚
â—
Neither tag is omissible.
</dd>

	<dt>`å†…å®¹~å±æ€§$ï¼š</dt>
	<dd>
`å¤§åŸŸ~å±æ€§$
â—
Global attributes
</dd>
	<dd>
`name$a
â€” `~shadow~tree$ã®`~slot$ã®`~slotå$
â—
name â€” Name of shadow tree slot
</dd>

	<dt>`~accessibilityã®è€ƒæ…®ç‚¹$</dt>
	<dd>
`slot$AA
â—
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLSlotElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute DOMString `name$m;
  sequence&lt;Node&gt; `assignedNodes$m(optional `AssignedNodesOptions$I %options = {});
  sequence&lt;Element&gt; `assignedElements$m(optional `AssignedNodesOptions$I %options = {});
};

dictionary `AssignedNodesOptions@I {
  boolean flatten = false;
};
</pre>
	</dd>
</dl>

<p>
`slot$e è¦ç´ ã¯ã€`~slot$ã‚’å®šç¾©ã™ã‚‹ã€‚
ãã‚Œã¯æ¦‚ã—ã¦ï¼Œ`~shadow~tree$ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
`slot$e è¦ç´ ã¯ã€ãã‚Œã«`å‰²å½“ã•ã‚ŒãŸ~nodeãŸã¡$ãŒï¼»
ã‚ã‚Œã° ãã‚Œã‚‰ ï¼
ãªã‘ã‚Œã°è‡ªèº«ã®å†…å®¹
ï¼½ã‚’`è¡¨ç¾-$ã™ã‚‹ã€‚
â—
The slot element defines a slot. It is typically used in a shadow tree. A slot element represents its assigned nodes, if any, and its contents otherwise.
</p>

<p>
`name@a
å†…å®¹~å±æ€§ãŒåŒ…å«ã™ã‚‹å€¤ã¯ã€ã©ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã§ã‚‚ãƒ¨ã‚¤ã€‚
ãã‚Œã¯ã€`~slot$ã®`~slotå$ã‚’è¡¨ç¾ã™ã‚‹ã€‚
â—
The name content attribute may contain any string value. It represents a slot's name.
</p>

<p class="note">æ³¨è¨˜ï¼š
`name$a å±æ€§ã¯ã€ä»–ã®è¦ç´ ã‚’ï¼Œã“ã®è¦ç´ ãŒå®šç¾©ã™ã‚‹`~slotã«å‰²å½“ã™ã‚‹$ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ï¼š
`name$a å±æ€§ã‚’æœ‰ã™ã‚‹ `slot$e è¦ç´  %slot ã¯ã€ãã®å±æ€§~å€¤ã‚’`~slotå$ã¨ã™ã‚‹`~slot$ã‚’ä½œæˆã—ï¼Œæ¬¡ã‚’æº€ãŸã™ã‚ˆã†ãªä»–ã®è¦ç´ ã‚’ ãã®`~slotã«å‰²å½“ã™ã‚‹$ã“ã¨ãŒå¯èƒ½ã«ãªã‚‹
â‡’
ï¼»
è¦ç´ ã® `slot$a å±æ€§ã®å€¤ã¯~slotåã«åˆè‡´ã™ã‚‹
ï¼½~ANDï¼»
%slot ã‚’å­ã¨ã™ã‚‹`~shadow~tree$ã®`æ ¹$ã®`~host$ãŒï¼Œå¯¾å¿œã™ã‚‹ `slot$a å±æ€§~å€¤ã‚’æŒã¤ã€ï¼Ÿã€‘
ï¼½
ã€ï¼è¦ç´ ã¯ slot ã®~shadowæ ¹ã®~hostã®å­ï¼å­å­«ã§ã‚ã‚‹ï¼Ÿã€‘
â—
The name attribute is used to assign slots to other elements: a slot element with a name attribute creates a named slot to which any element is assigned if that element has a slot attribute whose value matches that name attribute's value, and the slot element is a child of the shadow tree whose root's host has that corresponding slot attribute value.
</p>

<dl class="domintro">
	<dt>%slot . `name$m</dt>
	<dd>
%slot ã®`~slotå$ã‚’å–å¾—ã—ãŸã‚Šè¨­å®šã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã§ãã‚‹ã€‚
â—
Can be used to get and set slot's name.
</dd>

	<dt>%slot . `assignedNodes(options)$m</dt>
	<dd>
<p>
%options ã® `flatten^m ~memberå€¤ã«å¿œã˜ã¦ï¼š
</p>
		<ul>
			<li>
~F ï¼ˆ %options ã®çœç•¥æ™‚ã‚‚å«ã‚€ï¼‰ãªã‚‰ã°
â‡’
%slot ã«`å‰²å½“ã•ã‚ŒãŸ~nodeãŸã¡$ã‚’è¿”ã™ã€‚
</li>
			<li>
~T ãªã‚‰ã°
â‡’
%slot ã«`å‰²å½“ã•ã‚ŒãŸ~nodeãŸã¡$ãŒï¼»
ã‚ã‚Œã° ãã‚Œã‚‰ ï¼
ãªã‘ã‚Œã° %slot ã®å­ãŸã¡
ï¼½ã«åŠ ãˆã¦ã€ãã‚Œã‚‰ã«å«ã¾ã‚Œã‚‹å„ `slot$e è¦ç´ ã«å¯¾ã—ã¦ã‚‚ï¼Œ
`slot$e è¦ç´ ãŒå°½ãã‚‹ã¾ã§ï¼Œå†å¸°çš„ã«åŒã˜ã“ã¨ã‚’ã—ã¦å¾—ã‚‰ã‚Œã‚‹~nodeãŸã¡ã‚’è¿”ã™ã€‚
</li>
		</ul>
â—
Returns slot's assigned nodes.
â—
slot . assignedNodes({ flatten: true })
â—
Returns slot's assigned nodes, if any, and slot's children otherwise, and does the same for any slot elements encountered therein, recursively, until there are no slot elements left.
</dd>

	<dt>%slot . `assignedElements(options)$m</dt>
	<dd>
`assignedNodes(options)$m
ã¨åŒã˜çµæœã‚’ï¼Œè¦ç´ ã®ã¿ã«åˆ¶é™ã—ãŸä¸Šã§è¿”ã™ã€‚
â—
Returns slot's assigned nodes, limited to elements.
â—
slot . assignedElements({ flatten: true })
â—
Returns the same as assignedNodes({ flatten: true }), limited to elements.
</dd>
</dl>

<p>
`name@m
~IDLå±æ€§ã¯ã€
`name$a å†…å®¹~å±æ€§ã‚’`åæ˜ ã™ã‚‹$ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The name IDL attribute must reflect the content attribute of the same name.
</p>

<div class="algo">
<p>
`assignedNodes(options)@m
~method~æ‰‹ç¶šãã¯ï¼š
â—
The assignedNodes(options) method, when invoked, must run these steps:
</p>
<ol>
	<li>
~RET %options ã® `flatten^m ~memberå€¤ã«å¿œã˜ã¦
â‡’ï¼ƒ
~F ãªã‚‰ã° ã‚³ãƒ¬ã«`å‰²å½“ã•ã‚ŒãŸ~nodeãŸã¡$ ï¼
~T ãªã‚‰ã° `~slotç”¨ã«å¹³å¦~åŒ–ã•ã‚ŒãŸ~slottableãŸã¡ã‚’è¦‹å‡ºã™$( ã‚³ãƒ¬ )
â—
If the value of options's flatten member is false, then return this element's assigned nodes.
â—
Return the result of finding flattened slottables with this element.
</li>
</ol>
</div>

<div class="algo">
<p>
`assignedElements(options)@m
~method~æ‰‹ç¶šãã¯ï¼š
</p>
<ol>
	<li>
%çµæœ ~LET %options ã® `flatten^m ~memberå€¤ã«å¿œã˜ã¦
â‡’ï¼ƒ
~F ãªã‚‰ã° ã‚³ãƒ¬ã«`å‰²å½“ã•ã‚ŒãŸ~nodeãŸã¡$ ï¼
~T ãªã‚‰ã° `~slotç”¨ã«å¹³å¦~åŒ–ã•ã‚ŒãŸ~slottableãŸã¡ã‚’è¦‹å‡ºã™$( ã‚³ãƒ¬ )
</li>
	<li>
~RET
%çµæœ ã‚’ `Element$I ~nodeã®ã¿ã‚’åŒ…å«ã™ã‚‹ã‚ˆã†ã«çµè¾¼ã‚“ã çµæœ
</li>
</ol>
â—
The assignedElements(options) method, when invoked, must run these steps:
â€¢ If the value of options's flatten member is false, then return this element's assigned nodes, filtered to contain only Element nodes.
â€¢ Return the result of finding flattened slottables with this element, filtered to contain only Element nodes.
</div>

		</section>
	</section>
</main>

