<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Touch Events — Level 2 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<style>
img {
	background: white;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	return this.html.replace(
		/%\w+|`(.*?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key}`;//.toLowerCase();
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'v':
	href = `#valdef-touch-action-${key}`;
	break;
case 'commit':
	return `（ <a href="https://github.com/w3c/touch-events/commit/${key}">commit</a> ）`;
	break;
case 'pull':
	return `（ <a href="https://github.com/w3c/touch-events/pull/${key}">pull</a> ）`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>


<!-- 
	chorded-button-interactions:dfn-chorded-buttons

~mouse~event:#_mouse-event
	#chorded-button-interactions
発火する:~DOM4#concept-event-fire
~event連列:#_event-sequence
~Window:~UIEVENTS#window

m.target:~DOM4#dom-event-target
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.isTrusted:~DOM4#dom-event-istrusted
m.preventDefault():~DOM4#dom-Event-preventDefault


-->

<script type="text/plain" id="_source_data">


●●options

spec_date:2022-06-29
trans_update:2022-12-09
source_checked:150823
page_state_key:UIEVENTS
original_url:https://w3c.github.io/touch-events/
spec_status:EDCG
ref_id_prefix:bib-
conformance:w3c
trans_1st_pub:2016-02-19


●●class_map
E:error
et:event-type
css:css

●●tag_map
c:code
I:code
E:code
m:code
et:code
css:code
cite:cite

●●ref_key_map
DOMLEVEL3EVENTS:UIEVENTS

●●original_id_map

	event-touchstart:dfn-touchstart
	event-touchend:dfn-touchend
	event-touchmove:dfn-touchmove
	event-touchcancel:dfn-touchcancel
dfn-touch-surface:

normative:normative-references
informative:informative-references

●●mdn_urls
idl-def-touch:API/Touch
idl-def-touchevent:API/TouchEvent
idl-def-touchlist:API/TouchList
	dom-touchtype:API/TouchType
	idl-def-touchtype:API/TouchType
	idl-def-toucheventinit:API/TouchEventInit
	idl-def-touchinit:API/TouchInit

event-touchstart:API/Element/touchstart_event
event-touchend:API/Element/touchend_event
event-touchmove:API/Element/touchmove_event
event-touchcancel:API/Element/touchcancel_event

●●link_map

Exposed:~WEBIDLjs#Exposed
boolean:~WEBIDL#idl-boolean
long:~WEBIDL#idl-long
double:~WEBIDL#idl-double
float:~WEBIDL#idl-float
DOMString:~WEBIDL#idl-DOMString
sequence:~WEBIDL#idl-sequence

I.UIEvent:~UIEVENTS#uievent
I.EventModifierInit:~UIEVENTS#dictdef-eventmodifierinit
I.KeyboardEvent:~UIEVENTS#keyboardevent
I.EventTarget:~DOM4#eventtarget
I.GlobalEventHandlers:~WAPI#globaleventhandlers
I.EventHandler:~WAPI#eventhandler

I.Touch:#idl-def-touch
I.TouchEvent:#idl-def-touchevent
I.TouchEventInit:#idl-def-toucheventinit
I.TouchInit:#idl-def-touchinit
I.TouchList:#idl-def-touchlist
I.TouchType:#dom-touchtype
	I.TouchType:#idl-def-touchtype

m.identifier:#dom-touch-identifier
m.target:#dom-touch-target
m.screenX:#dom-touch-screenx
m.screenY:#dom-touch-screeny
m.clientX:#dom-touch-clientx
m.clientY:#dom-touch-clienty
m.pageX:#dom-touch-pagex
m.pageY:#dom-touch-pagey
m.radiusX:#dom-touch-radiusx
m.radiusY:#dom-touch-radiusy
m.rotationAngle:#dom-touch-rotationangle
m.force:#dom-touch-force
m.altitudeAngle:#dom-touch-altitudeangle
m.azimuthAngle:#dom-touch-azimuthangle
m.touchType:#dom-touch-touchtype

m.touches:#dom-touchevent-touches
m.targetTouches:#dom-touchevent-targettouches
m.changedTouches:#dom-touchevent-changedtouches
m.altKey:#dom-touchevent-altkey
m.metaKey:#dom-touchevent-metakey
m.ctrlKey:#dom-touchevent-ctrlkey
m.shiftKey:#dom-touchevent-shiftkey
m.getModifierState:#dom-touchevent-getmodifierstate

m.ontouchstart:#dom-globaleventhandlers-ontouchstart
m.ontouchend:#dom-globaleventhandlers-ontouchend
m.ontouchmove:#dom-globaleventhandlers-ontouchmove
m.ontouchcancel:#dom-globaleventhandlers-ontouchcancel

m.length:#dom-touchlist-length
m.item:#dom-touchlist-item

m.Touch.target:#dom-touch-target
m.TouchList.length:#dom-touchlist-length

	mb.identifier:#dom-touchinit-identifier
	mb.target:#dom-touchinit-target
	mb.screenX:#dom-touchinit-screenx
	mb.screenY:#dom-touchinit-screeny
	mb.clientX:#dom-touchinit-clientx
	mb.clientY:#dom-touchinit-clienty
	mb.pageX:#dom-touchinit-pagex
	mb.pageY:#dom-touchinit-pagey
	mb.radiusX:#dom-touchinit-radiusx
	mb.radiusY:#dom-touchinit-radiusy
	mb.rotationAngle:#dom-touchinit-rotationangle
	mb.force:#dom-touchinit-force
	mb.altitudeAngle:#dom-touchinit-altitudeangle
	mb.azimuthAngle:#dom-touchinit-azimuthangle
	mb.touchType:#dom-touchinit-touchtype

	mb.changedTouches:#dom-toucheventinit-changedtouches
	mb.targetTouches:#dom-toucheventinit-targettouches
	mb.touches:#dom-toucheventinit-touches


l.direct:#dom-touchtype-direct
l.stylus:#dom-touchtype-stylus

et.touchstart:#event-touchstart
et.touchend:#event-touchend
et.touchmove:#event-touchmove
et.touchcancel:#event-touchcancel

et.click:~UIEVENTS#event-type-click
	et.dblclick:~UIEVENTS#event-type-dblclick
	et.focus:~UIEVENTS#event-type-focus
	et.blur:~UIEVENTS#event-type-blur
et.mousedown:~UIEVENTS#event-type-mousedown
et.mouseup:~UIEVENTS#event-type-mouseup
	et.mouseover:~UIEVENTS#event-type-mouseover
	et.mouseout:~UIEVENTS#event-type-mouseout
	et.mouseenter:~UIEVENTS#event-type-mouseenter
	et.mouseleave:~UIEVENTS#event-type-mouseleave
et.mousemove:~UIEVENTS#event-type-mousemove

	●用語
作動中:#dfn-active-touch-point
作動中な:#dfn-active-touch-point
作動中な~touch点:#dfn-active-touch-point
~touch点:#dfn-touch-point
~touch面:#dfn-touch-surface
文脈依存:#cancelability
取消された~event:#dfn-canceled-event
取消され:#dfn-canceled-event
取消した:#dfn-canceled-event
取消す:#dfn-canceled-event
旧来の~touch~event~APIを公開するか:#dfn-expose-legacy-touch-event-apis

	●用語（外部
実装定義:~INFRA#implementation-defined

同期c:~UIEVENTS#sync-async
同期的:~UIEVENTS#sync-async
浮上-:~UIEVENTS#bubble-phase
浮上相:~UIEVENTS#bubble-phase
	#bubbling-phase
伝播~経路:~UIEVENTS#propagation-path
取消~可能？:~UIEVENTS#event-flow-default-cancel
	_cancelable
既定~動作:~UIEVENTS#default-action

~supportする~prop~index:~WEBIDL#dfn-supported-property-indices

css.px:~CSSVAL#px
内容~文書:~HTMLds#concept-bcc-content-document
	廃）子~閲覧~文脈:~BROWSERS#child-browsing-context → 内容~文書
~trusted:~UIEVENTS#trusted-events
要素:~DOM4#concept-element
文書:~DOM4#concept-document
~touch~target~list:~DOM4#event-touch-target-list

~event~handler~IDL属性:~WAPI#event-handler-idl-attributes


●●words_table1

●●words_table


	API
	DOM
	HTML5
	Touch
	W3C
	WebIDL
	WebKit


	●IDL／型／構造
prototype::::プロトタイプ
accessor::::アクセサ
初期化子:initializer::~
解放-:release::~

	~index:indice
	ordering
	変異-不能:immutable

	●処理一般／event 
合成な:syntheticな::~
trusted:
passive:
composed:

retarget:
浮上相:bubbling phase::~

	取消~可能:cancelable
	取消~可否:cancelability
	取消~不可:uncancelable


稼働-:run::~
排他的:exclusive::~
	以外を受け付け-exclusive
	identification

	●UI
pen::::ペン
cap:::頭頂
tablet::::タブレット
tap::::タップ

絵描き:drawing:~
digital::::デジタル
drag::::ドラッグ
transducer:
stylus::::スタイラス
laptop::::ノートパソコン
携帯電話:phone:~
touchscreen::::タッチスクリーン
trackpad::::トラックパッド
scrolling::::スクロール処理
端末:terminal:~
	紙片:piece of paper

	能力を有する:capable
対話域:interactive area::~
長押し:long press:~

	●touch
touch::::タッチ
	複-~touch:multi-touch
	~touch可能:touchable
	~touch点:touch point
	~touch面:touch surface
	~touch面:touch-sensitive surface
	~touching
	~touch作動中な:touch-active
面:surface::~
点:point::~
接点:point of contact:~
感知-:sense::~
感度:sensitivity::~
押圧:pressure::~
動かし:moveし:~
動かさ:moveさ:~
動いた:moveした:~
動き:movement:~
不精確さ:imprecision:~
粗い:coarseな:~

持上げら:liftさ:~
	指:finger
	外へ出た:into a non-〜
	離れた:leave
	leaving
	感知し得ない場合:if no value is known

	●幾何
radian:
degree:
真円な:circularな::真円の
楕円:ellipse::~
	-:center
接する:intersectする:~
半径:radius::~
垂直:perpendicular::~
	垂直:perfectly perpendicular
平行:parallel::~
仰角:altitude::~
方位角:azimuth angle::~
外接-:circumscribe:~
区域:area:~
時計回り:clockwise:~
	rotated clockwise
横方向:horizontal::~
縦方向:vertical::~
	-:the same scale as
平面:plane::~
頻度:rate::~
傾き:tilt::~
	時:o'clock
	指す:point to
	真上から見て:looking straight down

	●仕様
唐突な:sudden:~
基礎:basis:~
技術者:engineer:~
有用性:utility:~
用語集:glossary:~
一式:suite:~
仕様化-:specify:~
合格-:pass:~
改善点:improvements:~
昇格-:upgrade:~
組入れま:incorporateし:組み入れま
解決策:solution:~
説明図:illustration:~

	条件に応じて:conditional
	低~level
	一覧:List of
	傾向にある:tend
	主要な:major
	その一方:meanwhile
	揺るぎない:steady
	多少:slightly
	便宜のため:facilitate
	至る:proceed する
	変わり:vary
	-:additional
	異なる:distinct
	書かれ:written
	最適とは言えない:suboptimal
	至らせ:leadする
	揃うよう:in line with
	書き直-:reword
	note
	notion
	thank
	working
	acknowledge
	writing
	publishing
	-:If we inadvertently omitted your name, please let me know

	●未分類
mobile::::モバイル
片:fragment:~
参照r:refer:参照
出現:appearance:~
呈-:exhibit:~
増える:increaseする:~
	十分近付けるには制限がある:tend to have limitations on deliver
	~plugin:plug-in
	-:interaction
	px:pixel
	-:contribute
	working group
	true
	~~保持-:maintain a notion of
	以上:greater than or equal to
	文脈依存:varies
	最初に生じた所:started when it was first
	生じ:place
	-:clear
	became
	become
	co-ordinates
	から生じたとき:originating from
	に伴って生じることになる that would be a consequential result of the prevented
	consideration
	contributor
	わたる:cover する
	含まない:excluding
	進むに伴い:progressively 〜 going
	give
	know
	led
	long
	made
	remain
	with respect to
	return
	screenX
	screenY
	started

	●指示語
現在:currently:~

	以前に:previously
	以前の:previous
	残され:left on
	数:number
	最高:highest
	近く:closely
	最も早期の:earliest
	entirely
	following
	further
	least
	two
	until
	Among

●●images
＠pointerevents/
altitudeAngle｜height:30em;｜｜.png
azimuthAngle｜height:30em;｜｜.png


●●ref_normative

[CSS-VALUES]
    CSS Values and Units Module Level 3. Tab Atkins Jr.; Elika Etemad. W3C. 6 June 2019. W3C Candidate Recommendation. URL: https://www.w3.org/TR/css-values-3/ 
[DOM-LEVEL-2-EVENTS]
    Document Object Model (DOM) Level 2 Events Specification. Tom Pixley. W3C. 3 November 2020. W3C Recommendation. URL: https://www.w3.org/TR/DOM-Level-2-Events/ 
[DOM-LEVEL-3-EVENTS]
    UI Events. Gary Kacmarcik; Travis Leithead. W3C. 13 September 2022. W3C Working Draft. URL: https://www.w3.org/TR/uievents/ 
[DOM4]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/ 
[html]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[HTML5]
    HTML5. Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Theresa O'Connor; Silvia Pfeiffer. W3C. 27 March 2018. W3C Recommendation. URL: https://www.w3.org/TR/html5/ 
[infra]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119 
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174 
[WEBIDL]
    Web IDL Standard. Edgar Chen; Timothy Gu. WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/ 

●●ref_informative

[POINTEREVENTS]
    Pointer Events. Jacob Rossi; Matt Brubeck. W3C. 4 April 2019. W3C Recommendation. URL: https://www.w3.org/TR/pointerevents/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより Draft Community Group Report として公開された
<a href="~SPEC_URL">Touch Events — Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/touch-events/
公表履歴
	https://www.w3.org/standards/history/touch-events/
編集者草案
	https://w3c.github.io/touch-events/

編集
	Doug Schepers, W3C
	Sangwhan Moon, Opera Software ASA
	Matt Brubeck, Mozilla
	Arthur Barstow, Invited Expert
	Rick Byers, Google
	Patrick H. Lauke (TetraLogical)

リポジトリ
	<a href="https://github.com/w3c/touch-events">We are on github.</a>
	<a href="https://github.com/w3c/touch-events/issues">File a bug/issue.</a>
	<a href="https://github.com/w3c/touch-events/commits">Commit history.</a>
	<a href="https://lists.w3.org/Archives/Public/public-touchevents/">Mailing list.</a>

公表者
	<a href="https://www.w3.org/groups/cg/touchevents">Touch Events Community Group</a>

</script>

</head>

<body>

<header>
	<hgroup>
<h1>Touch Events — Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<div class="p">
<p>
Touch Events 仕様は、次を定義する：
</p>

<ul>
	<li>
`~touch面$上の 1 個以上の接点を表現する低~levelな各種~event, および
</li>
	<li>
~touch面, および
その上の DOM `要素$†における`~touch点$の変化。
（†例：
~touch~screen用には，~touch面に表示されている要素 ／
表示を備えない絵描き~tablet用には，~touch面に対応する~~位置にある要素）
</li>
</ul>

<p>
加えて、絵描き~tabletなどの~pen~tablet装置の~stylus能力に向けても取組む。
</p>
◎
The Touch Events specification defines a set of low-level events that represent one or more points of contact with a touch-sensitive surface, and changes of those points with respect to the surface and any DOM elements displayed upon it (e.g. for touch screens) or associated with it (e.g. for drawing tablets without displays). It also addresses pen-tablet devices, such as drawing tablets, with consideration toward stylus capabilities.
</div>

	</section>
	<section id="sotd">
◎位置付け

<p>
<em>この節では、公表~時点における…</em>
【以下、この節の他の内容は，~SOTD-W3Cに移譲。】
</p>

<p>
W3C は、この勧告の公表にあたり，この仕様に指定される機能性は，［
HTML5 ／ WebIDL
］仕様が勧告に至るまでの変更点からは影響されないものと予期しています。
WG は、この仕様の
`~test一式＠http://w3c-test.org/webevents/tests/touch-events-v1/approved/$
を完了し, 認可しました。
また、二つ以上の独立する実装が，各~testに合格したことを示す
`実装~報告＠http://www.w3.org/2010/webevents/wiki/TEv1ImplReport$を作成しました。
この~versionの仕様は、
`Level 1＠~TR/touch-events/$ に対する修正点と改善点を含み，
以前に `Touch Event 拡張＠~TR/touch-events-extensions/$として公表された特能も組入れます。
◎
By publishing this Recommendation, W3C expects that the functionality specified in this Touch Interface Recommendation will not be affected by changes to HTML5 or Web IDL as those specifications proceed to Recommendation. The WG has completed and approved this specification's Test Suite and created an Implementation Report that shows that two or more independent implementations pass each test. This version of the specification includes fixes and improvements to Level 1, and incorporates the features previously published as Touch Event Extensions.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
~touch入力を供する端末~上で稼働する~UAは、~web~appを利用するとき，概して、利用者が対話的~web~appに~accessできるようにするため，入力を~mouse~eventに解釈した結果を利用する。
しかしながら、このように解釈され，物理的~touch入力に基づいて正規化された~dataを伴う~eventでは、意図される利用者~体験に十分近付けるには制限がある。
加えて，装置~能力に関わらず、［
~system~levelの制限, および旧来の互換性
］に関する~mouse~eventの拘束があるため、複数の同時並行な入力【すなわち，複-~touch】を取扱うことも，アリでない。
◎
User Agents that run on terminals which provide touch input to use web applications typically use interpreted mouse events to allow users to access interactive web applications. However, these interpreted events, being normalized data based on the physical touch input, tend to have limitations on delivering the intended user experience. Additionally, it is not possible to handle concurrent input regardless of device capability, due to constraints of mouse events: both system level limitations and legacy compatibility.
</p>

<p>
その一方、~native~appは，~systemから供される API により，両~事例を取扱える能力を有する。
◎
Meanwhile, native applications are capable of handling both cases with the provided system APIs.
</p>

<p>
この仕様は、~web~appが，能力を有する装置~用に［
~touch~event, 複数の`~touch点$
］を直に取扱えるようにする~interfaceを仕様化して、上述の問題に対する解決策を供する。
◎
The Touch Events specification provides a solution to this problem by specifying interfaces to allow web applications to directly handle touch events, and multiple touch points for capable devices.
</p>

	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>

<!-- 
As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.

This specification defines conformance criteria that apply to a single product: the user agent that implements the interfaces that it contains.

WindowProxy is defined in [HTML5]. 
-->

<p class="trans-note">【
以下、この節, および次節の他の内容は
`~W3C日本語訳 共通~page＠~W3Ccommon#conformance$
に移譲。
】</p>

<p>
この仕様への適合性の判定基準が適用されるのは、
この仕様の~interfaceを実装する~UAのみである。
◎
This specification defines conformance criteria that apply to a single product: the user agent that implements the interfaces that it contains.
◎
WindowProxy is defined in [HTML5].
</p>


		<section id="webidl-conform">
<h3 title="WebIDL Conformance">WebIDL への適合性</h3>

<!-- 
The IDL blocks in this specification are conforming IDL fragments as defined by the WebIDL specification [WEBIDL].

A conforming user agent must also be a conforming ECMAScript implementation of this IDL fragments in this specification, with the following exception:
-->

<p>
適合~UAは、
この仕様の この~IDL片の`適合 ECMAScript 実装＠~WEBIDL#dfn-conforming-javascript-implementation$になるモノトスルが，
次の例外は除く：
◎
A conforming user agent must also be a conforming ECMAScript implementation of this IDL fragments in this specification, with the following exception:
</p>

<ul>
	<li>
WebIDL の
`§ ~IDL属性＠~WEBIDLjs#js-attributes$では、
~IDL属性は，~interface~prototype~obj上の~accessor~propとして反映されることが要求されている。
この代わりに，~UAは、
~IDL属性を［
関連な~interfaceを実装する~platform~obj上の~data~prop
］として反映してもヨイ。
これらの~data~propに対する［
被~取得-時／被~設定-時
］の挙動は、その~platform~obj上の~accessor~propの［
取得子／設定子
］を呼出したときに呈する挙動と同じになるモノトスル。
◎
section 4.4.6 of Web IDL requires that IDL attributes are reflected as accessor properties on interface prototype objects. Instead of this, the user agent may reflect IDL attributes as data properties on the platform objects that implement the relevant interface. These data properties must have the same behavior when getting and setting as would be exhibited when invoking the getter and setter of the accessor properties on the platform object.
</li>
</ul>

<p class="note">注記：
~IDL属性を いずれの仕方で反映しても、単純に~platform~obj上の~propを［
取得する／設定する
］ものとして働けるようにする。
例えば，所与の `Touch$I ~obj %aTouch に対し %aTouch.`target^m が評価されたときは、その `Touch$I ~objに対する `EventTarget$I を返すことになる。
~UAが~IDL属性を~accessor~propとして実装する場合、~propへの~accessは，
`EventTarget$I を返す取得子を呼出す。
~UAが~IDL属性を［
~accessor~propにて見出されるものと同じ挙動を伴うような，~platform~obj上の~data~prop
］として実装する場合、その~objは，自前の［
名前 `target^m, 値 `EventTarget$I ~obj
］にされた~propを持つように現れ、その~propへの~accessは，この値を返すことになる。
◎
Note: Both ways of reflecting IDL attributes allow for simply getting and setting the property on the platform object to work. For example, given a Touch object aTouch, evaluating aTouch.target would return the EventTarget for the Touch object. If the user agent implements IDL attributes as accessor properties, then the property access invokes the getter which returns the EventTarget. If the user agent implements IDL attributes as data properties on the platform object with the same behavior as would be found with the accessor properties, then the object would appear to have an own property named target whose value is an EventTarget object, and the property access would return this value.
</p>

		</section>
	</section>
	<section id="touch-interface">
<h2 title="Touch Interface">3. `Touch^I ~interface</h2>

<p>
この~interfaceは、~touch~eventを成す個々の`~touch点$を~~表現する。
`Touch$I ~objは変異-不能であり、作成されて以降は，その属性は変化しないモノトスル。
◎
This interface describes an individual touch point for a touch event. Touch objects are immutable; after one is created, its attributes must not change.
</p>

<pre class="idl">
enum `TouchType$I {
    `direct$l,
    `stylus$l
};

dictionary `TouchInit@I {
    required `long$        `identifier^m;
    required `EventTarget$I `target^m;
             `double$      `clientX^m = 0;
             `double$      `clientY^m = 0;
             `double$      `screenX^m = 0;
             `double$      `screenY^m = 0;
             `double$      `pageX^m = 0;
             `double$      `pageY^m = 0;
             `float$       `radiusX^m = 0;
             `float$       `radiusY^m = 0;
             `float$       `rotationAngle^m = 0;
             `float$       `force^m = 0;
             `double$      `altitudeAngle^m = 0;
             `double$      `azimuthAngle^m = 0;
             `TouchType$I   `touchType^m = "direct";
};

[`Exposed$=Window]
interface `Touch@I {
    constructor(`TouchInit$I %touchInitDict);
    readonly    attribute `long$        `identifier$m;
    readonly    attribute `EventTarget$I `target$m;
    readonly    attribute `double$      `screenX$m;
    readonly    attribute `double$      `screenY$m;
    readonly    attribute `double$      `clientX$m;
    readonly    attribute `double$      `clientY$m;
    readonly    attribute `double$      `pageX$m;
    readonly    attribute `double$      `pageY$m;
    readonly    attribute `float$       `radiusX$m;
    readonly    attribute `float$       `radiusY$m;
    readonly    attribute `float$       `rotationAngle$m;
    readonly    attribute `float$       `force$m;
    readonly    attribute `float$       `altitudeAngle$m;
    readonly    attribute `float$       `azimuthAngle$m;
    readonly    attribute `TouchType$I   `touchType$m;
};
</pre>


<dl class="idl-def" data-merge="TouchInit">
	<dt>long `identifier@m</dt>
	<dd>
この`~touch点$を識別する整数。
各`~touch点$には、`作動中$になった時点で，他のどの`作動中な~touch点$とも異なる識別子をアテガうモノトスル。
~touch点が`作動中$であり続ける間は、それを参照rするすべての~eventに，同じ識別子をアテガうモノトスル。
◎
An identification number for each touch point.
◎
When a touch point becomes active, it must be assigned an identifier that is distinct from any other active touch point. While the touch point remains active, all events that refer to it must assign it the same identifier.
</dd>

	<dt>`EventTarget$I `target@m</dt>
	<dd>
当の`~touch点$が~touch面~上に最初に生じた所の `EventTarget$I
— `~touch点$がその時点から当の要素の対話域の外側に動かされたとしても。
◎
The EventTarget on which the touch point started when it was first placed on the surface, even if the touch point has since moved outside the interactive area of that element.
</dd>
	<dd class="note">注記：
一部の実装には、粗い入力の不精確さを正すために，~target要素を改めるものもある。
したがって，~target要素は、~eventの座標に直にある要素になるとは限らない。
粗い入力を［
~targetにする／一義化する
］ために利用される手法は、この仕様の視野~外である。
◎
Some implementations alter the target element to correct for the imprecision of coarse input. Therefore, the target element may not necessarily be the element directly at the coordinates of the event. The methods used to target/disambiguate coarse input are out of scope for this specification.
</dd>

	<dt>double `screenX@m</dt>
	<dt>double `screenY@m</dt>
	<dd>
順に、~screenに相対的な，`~touch点$の［
横方向, 縦方向
］座標（ `px$css 単位）。
◎
The horizontal coordinate of point relative to the screen in pixels
◎
The vertical coordinate of point relative to the screen in pixels
</dd>

	<dt>double `clientX@m</dt>
	<dt>double `clientY@m</dt>
	<dd>
順に、`~touch点$の，~scroll~offsetは含まない, 表示域に相対的な［
横方向, 縦方向
］座標（ `px$css 単位）。
◎
The horizontal coordinate of point relative to the viewport in pixels, excluding any scroll offset
◎
The vertical coordinate of point relative to the viewport in pixels, excluding any scroll offset
</dd>

	<dt>double `pageX@m</dt>
	<dt>double `pageY@m</dt>
	<dd>
順に、`~touch点$の，~scroll~offsetも含む, 表示域に相対的な［
横方向, 縦方向
］座標（ `px$css 単位）。
◎
The horizontal coordinate of point relative to the viewport in pixels, including any scroll offset
◎
The vertical coordinate of point relative to the viewport in pixels, including any scroll offset
</dd>

	<dt>float `radiusX@m</dt>
	<dt>float `radiusY@m</dt>
	<dd>
順に、［
~touchしている区域（例：指, ~stylus）に外接する最~小な楕円
］の［
X 軸, Y 軸
］半径（ `px$css 単位）
— ここで、楕円の `rotationAngle$m 方向の半径が，楕円の X 軸~半径と~~見なされる。
~touch装置がこの区域を感知し得ない場合は 0 になる。
値は負にならないモノトスル。
◎
The radius of the ellipse which most closely circumscribes the touching area (e.g. finger, stylus) along the axis indicated by rotationAngle, in CSS pixels (as defined by [CSS-VALUES]) of the same scale as screenX; 0 if no value is known. The value must not be negative.
◎
The radius of the ellipse which most closely circumscribes the touching area (e.g. finger, stylus) along the axis perpendicular to that indicated by rotationAngle, in CSS pixels (as defined by [CSS-VALUES]) of the same scale as screenY; 0 if no value is known. The value must not be negative.
</dd>

	<dt>float `rotationAngle@m</dt>
	<dd>
表示域の X 軸から，時計回りに［
~touchしている区域に外接する最~小な楕円
］の半径までの角度（~degree単位）。
値は 0° 以上かつ 90° 未満になるモノトスル
— すなわち、角度を測る楕円の半径は，角度がこの範囲に入るように選ばれる。
~touch装置が角度を感知し得ない場合は 0 になる。
◎
The angle (in degrees) that the ellipse described by radiusX and radiusY is rotated clockwise about its center; 0 if no value is known. The value must be greater than or equal to 0 and less than 90.
</dd>
	<dd>
楕円が真円な場合、この属性は~~意味を持たない
— その場合、~UAは，許容される範囲~内のどの値を利用してもヨイ
（例えば~UAは、
唐突な変化を避けるために，以前の~touch~eventの `rotationAngle$m 値を利用してもヨイ）。
◎
If the ellipse described by radiusX and radiusY is circular, then rotationAngle has no effect. The user agent may use 0 as the value in this case, or it may use any other value in the allowed range. (For example, the user agent may use the rotationAngle value from the previous touch event, to avoid sudden changes.)
</dd>

	<dt>float `force@m</dt>
	<dd>
範囲［
0 〜 1
］に正規化された，感知された押圧~値。
0 は押圧なし， 1 は［
~touch装置が感知し得る最高~levelの押圧
］を表す。
感知し得ない場合は 0 になる。
押圧を感知し得る環境において，この属性が表現している~~物理的な押圧, および 押圧~levelの感度は、様々になり得る。
◎
force of type float, readonly
◎
A relative value of pressure applied, in the range 0 to 1, where 0 is no pressure, and 1 is the highest level of pressure the touch device is capable of sensing; 0 if no value is known. In environments where force is known, the absolute pressure represented by the force attribute, and the sensitivity in levels of pressure, may vary.
</dd>

	<dt>float `altitudeAngle@m</dt>
	<dd>
~transducer（例：~pen／~stylus）の仰角を表す，範囲［
0 〜 π/2 
］に入る値（~radian単位）
— 0 は面（ X-Y 平面）に平行, π/2 は面に垂直を表す。
傾きや角度を報告しない［
~hardware／~platform
］用には、
値は 0 になるモノトスル。
◎
The altitude (in radians) of the transducer (e.g. pen/stylus), in the range [0,π/2] — where 0 is parallel to the surface (X-Y plane), and π/2 is perpendicular to the surface. For hardware and platforms that do not report tilt or angle, the value MUST be 0.
</dd>
	<dd class="note">注記：
ここに定義される `altitudeAngle^m 用の既定の値は 0 であり、
`POINTEREVENTS$r 仕様による
`altitudeAngle＠~POINTEREVENTS#dom-pointerevent-altitudeangle$m
用の定義とは相違する
— 後者は π/2 が既定の値であり，~transducerの位置は面に垂直になる。
◎
The default value defined here for altitudeAngle is 0. This differs from the Pointer Events - Level 3 [POINTEREVENTS] specification's definition for the altitudeAngle property, which has a default value of π/2, which positions the transducer as being perpendicular to the surface.
</dd>
	<dd><figure>
<p class="alt" hidden id="_dgm-altitudeAngle">
`altitudeAngle^m を説明する図式
◎
altitudeAngle explanation diagram
</p>
<figcaption>
`altitudeAngle^m が π/4 をとるとき（ X-Y 平面から 45° ）。
◎
Figure 1＼
Example altitudeAngle of π/4 (45 degrees from the X-Y plane).
</figcaption></figure></dd>

	<dt>float `azimuthAngle@m</dt>
	<dd>
~transducer（例：~pen／~stylus）の方位角を表す，範囲［
0 〜 2π
］に入る値（~radian~~単位）
— 値 0 は、
~transducerの~capが X-Y 平面~上で X 値が増える方向を指している（真上から見て “3 時” を指す）ことを表現する。
値は時計回りに進むに伴い増える
（ π/2 は “6 時”, π は “9 時”, 3π/2 at “12 時” を指す）。
~transducerが面に垂直なときは（ `altitudeAngle$m は π/2 ）、
値は 0 になるモノトスル。
傾きや角度を報告しない［
~hardware／~platform
］用には、
値は 0 になるモノトスル。
◎
The azimuth angle (in radians) of the transducer (e.g. pen/stylus), in the range [0, 2π] — where 0 represents a transducer whose cap is pointing in the direction of increasing X values (point to "3 o'clock" if looking straight down) on the X-Y plane, and the values progressively increase when going clockwise (π/2 at "6 o'clock", π at "9 o'clock", 3π/2 at "12 o'clock"). When the transducer is perfectly perpendicular to the surface (altitudeAngle of π/2), the value MUST be 0. For hardware and platforms that do not report tilt or angle, the value MUST be 0.
</dd>
	<dd>
<figure id="figure_azimuthAngle">
<p class="alt" hidden id="_dgm-azimuthAngle">
`azimuthAngle^m を説明する図式
◎
azimuthAngle explanation diagram
</p>
<figcaption>
`azimuthAngle^m が π/6 をとるとき（ “4 時” を指す ）。
◎
Figure 2＼
Example azimuthAngle of π/6 ("4 o'clock").
</figcaption></figure></dd>


	<dt>`TouchType$I `touchType@m</dt>
	<dd>
~touchを誘発している装置の型を表す。
◎
The type of device used to trigger the touch.
</dd>
	<dd>
<p>
アリな~touch入力の型は、次に挙げる
`TouchType@I
列挙~値で表現される：
◎
An enumeration representing the different types of possible touch input.
</p>

		<dl>
			<dt>`direct@l</dt>
			<dd>
指による~screenへの直接的な~touch。
◎
A direct touch from a finger on the screen.
</dd>

			<dt>`stylus@l</dt>
			<dd>
~stylusまたは~pen装置による~touch。
◎
A touch from a stylus or pen device.
</dd>
		</dl>
	</dd>
</dl>

	</section>
	<section id="touchlist-interface">
<h2 title="TouchList Interface">4. `TouchList^I ~interface</h2>

<p>
この~interfaceは、~touch~eventを成す個々の接点からなる~listを定義する。
`TouchList$I ~objは変異-不能であり，作成された後は その内容は変化しないモノトスル。
◎
This interface defines a list of individual points of contact for a touch event. TouchList objects are immutable; after one is created, its contents must not change.
</p>

<p>
`TouchList$I ~objが`~supportする~prop~index$
`WEBIDL$r
は、
0 以上 ~listの長さ未満とする。
◎
A TouchList object's supported property indices ([WEBIDL]) are the numbers in the range 0 to one less than the length of the list.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `TouchList@I {
    readonly    attribute unsigned long `length$m;
    getter Touch? `item$m(unsigned long %index);
};
</pre>

<dl class="idl-def">
	<dt>unsigned long `length@m</dt>
	<dd>
~list内の `Touch$I ~objの個数を返す。
◎
Returns the number of Touch objects in the list
</dd>

	<dt>getter `Touch$I? `item@m(%index)</dt>
	<dd>
~list内の指定された~indexに~~位置する `Touch$I ~objを返す。
~indexが~listの長さ以上の場合は ~NULL を返す。
◎
Returns the Touch at the specified index in the list or null if the index is not less than the length of the list.
</dd>
</dl>

	</section>
	<section id="touchevent-interface">
<h2 title="TouchEvent Interface">5. `TouchEvent^I ~interface</h2>

<p>
この~interfaceは、［
`touchstart$et,
`touchend$et,
`touchmove$et,
`touchcancel$et
］~event型を定義する。
`TouchEvent$I ~objは変異-不能であり、作成され初期化された後は その どの属性も変化しないモノトスル。
`TouchEvent$I は、 `DOM-LEVEL-3-EVENTS$r に定義される `UIEvent$I ~interfaceを継承する。
◎
This interface defines the touchstart, touchend, touchmove, and touchcancel event types. TouchEvent objects are immutable; after one is created and initialized, its attributes must not change. TouchEvent inherits from the UIEvent interface defined in [DOM-LEVEL-3-EVENTS].
</p>

<p >
`TouchEventInit$I  辞書~型は、
`TouchEvent$I ~interfaceの構築子に利用され，
~trustedでない（合成な） ~touch~eventを構築する仕組みを供する。
それは、 `DOM-LEVEL-3-EVENTS$r に定義される `EventModifierInit$I 辞書~型を継承する。
~eventを構築する手続きは `DOM4$r に定義される。
`見本~code例＠#firing-a-synthetic-touchevent-from-script$
にて、~trustedでない~touch~eventを発火する方法をデモる。
◎
The TouchEventInit dictionary is used by the TouchEvent interface's constructor to provide a mechanism by which to construct untrusted (synthetic) touch events. It inherits from the EventModifierInit dictionary defined in [DOM-LEVEL-3-EVENTS]. The steps for constructing an event are defined in [DOM4]. See the example for sample code demonstrating how to fire an untrusted touch event.
</p>

<pre class="idl">
dictionary `TouchEventInit@I : `EventModifierInit$I {
             `sequence$&lt;`Touch$I&gt; touches = [];
             `sequence$&lt;`Touch$I&gt; targetTouches = [];
             `sequence$&lt;`Touch$I&gt; changedTouches = [];
};

[`Exposed$=Window]
interface `TouchEvent@I : `UIEvent$I {
    constructor(`DOMString$ %type, optional `TouchEventInit$I %eventInitDict = {});
    readonly    attribute `TouchList$I `touches$m;
    readonly    attribute `TouchList$I `targetTouches$m;
    readonly    attribute `TouchList$I `changedTouches$m;
    readonly    attribute `boolean$   `altKey$m;
    readonly    attribute `boolean$   `metaKey$m;
    readonly    attribute `boolean$   `ctrlKey$m;
    readonly    attribute `boolean$   `shiftKey$m;
    getter `boolean$ `getModifierState$m(`DOMString$ %keyArg);
};
</pre>

<dl class="idl-def">
	<dt>`TouchList$I `touches@m</dt>
	<dd>
現在~~touch面に~touchしている各~接点に対応する `Touch$I ~objからなる~list。
◎
A list of Touch objects for every point of contact currently touching the surface.
</dd>

	<dt>`TouchList$I `targetTouches@m</dt>
	<dd>
`touches$m 内の `Touch$I ~objのうち，［
`Touch.target$m ~EQ 現在の~event~target（すなわち，この~event~objの `target^m ）
］なるものからなる~list。
◎
A list of Touch objects for every point of contact that is touching the surface and started on the element that is the target of the current event.
</dd>

	<dt>`TouchList$I `changedTouches@m</dt>
	<dd>
<p>
`touches$m 内の `Touch$I ~objのうち，［
~event型（すなわち，この~event~objの `type^m ）に応じて，次に該当する`~touch点$
］に対応するものからなる~list：
</p>

		<dl class="switch">
			<dt>`touchstart$et</dt>
			<dd>
現在の~eventにより`作動中$になった`~touch点$。
</dd>
			<dt>`touchmove$et</dt>
			<dd>
最後の~eventから動いた`~touch点$。
</dd>
<!-- 
			<dd class="trans-note">【
複数の`~touch点$をほぼ同時に動かしたとき、個別に~eventが生じるのか？集約されて生じるのか？
】</dd>
 -->

			<dt>`touchend$et</dt>
			<dt>`touchcancel$et</dt>
			<dd>
直前に~touch面から除去された`~touch点$
— その座標は、除去される直前におけるものとする。
</dd>

		</dl>
◎
A list of Touch objects for every point of contact which contributed to the event.
◎
For the touchstart event this must be a list of the touch points that just became active with the current event. For the touchmove event this must be a list of the touch points that have moved since the last event. For the touchend and touchcancel events this must be a list of the touch points that have just been removed from the surface, with the last known coordinates of the touch points before they were removed.
</dd>

	<dt>boolean `altKey@m</dt>
	<dt>boolean `metaKey@m</dt>
	<dt>boolean `ctrlKey@m</dt>
	<dt>boolean `shiftKey@m</dt>
	<dd>
これらは、
`KeyboardEvent$I `UIEvents$r の同~名の属性と同じに挙動する【ので、和訳は省略する】。
◎
altKey
◎
true if the alt (Alternate) key modifier is activated; otherwise false
◎
metaKey
◎
true if the meta (Meta) key modifier is activated; otherwise false. On some platforms this attribute may map to a differently-named key modifier.
◎
ctrlKey
◎
true if the ctrl (Control) key modifier is activated; otherwise false
◎
shiftKey
◎
true if the shift (Shift) key modifier is activated; otherwise false
</dd>

	<dt>boolean `getModifierState(keyArg)@m</dt>
	<dd>
`KeyboardEvent$I `UIEvents$r の
`getModifierState()＠~UIEVENTS#dom-keyboardevent-getmodifierstate$m
~methodと同じに挙動する【ので、和訳は省略する】。
◎
Queries the state of a modifier using a key value. Returns true if it is a modifier key and the modifier is activated, false otherwise.

</dd>
</dl>

		<section id="touchevent-implementer-s-note">
<h2 title="TouchEvent Implementer's Note">5.1. `TouchEvent^I 実装者に向けての注記</h2>

◎非規範的

<div class="note">
<p>注記：
~UAは、［
所与の `TouchEvent$I から可用な `Touch$I ~obj
］すべてが， `TouchEvent$I の配送-先と同じ文書に結付けられることを確保するべきである。
これを実装するためには、~UAは，［
最初の~touchに対し、それが生じた所の~target文書 %D
］を，現在の
“~touch作動中な文書”
として［
`作動中な~touch点$すべてが解放される
］まで~~保持した上で、
%D を~~保持している間は：
</p>

<ul>
	<li>
すべての `TouchEvent$I は、 %D へ配送する。
</li>
	<li>
配送される~eventが包含する各 `Touch$I ~objの `target$m は、
%D 内の DOM 要素のみを参照rする。
【！ ＊and co-ordinates する】
</li>
	<li>
%D の外側から開始される~touchは、まるごと無視する。
</li>
</ul>

◎
User agents should ensure that all Touch objects available from a given TouchEvent are all associated to the same document that the TouchEvent was dispatched to. To implement this, user agents should maintain a notion of the current touch-active document. On first touch, this is set to the target document where the touch was created. When all active touch points are released, the touch-active document is cleared. All TouchEvents are dispatched to the current touch-active document, and each Touch object it contains refers only to DOM elements (and co-ordinates) in that document. If a touch starts entirely outside the currently touch-active document, then it is ignored entirely.
</div>

		</section>
		<section id="usage-examples">
<h2 title="Usage Examples">5.2. 用例</h2>

◎非規範的

<p>
`TouchEvent$I に定義される異なる `TouchList$I ~member間の関係を，下の例にデモる：
◎
The examples below demonstrate the relations between the different TouchList members defined in a TouchEvent.
</p>

			<section id="touches-and-targettouches-of-a-touchevent">
<h3 title="touches and targetTouches of a TouchEvent">5.2.1. `TouchEvent^I の `touches^m, `targetTouches^m 属性</h3>

<p>
`TouchEvent$I ~interfaceに定義される
`touches$m, `targetTouches$m 各~memberの有用性とそれらの関係を，次の例にデモる。
◎
This example demonstrates the utility and relations between the touches and targetTouches members defined in the TouchEvent interface. The following code will generate different output based on the number of touch points on the touchable element and the document:
</p>

<div class="example">
<p>
次の~codeは、［
文書と~touch可能な要素
］上の`~touch点$の個数に基づいて，異なる出力を生成する：
</p>

<pre class="lang-html">
&lt;div id='touchable'&gt;この要素は~touch可能。&lt;/div&gt;

&lt;script&gt;
document
.getElementById('touchable')
.addEventListener('touchstart', function(%ev){

    if (%ev.touches.item(0) == %ev.targetTouches.item(0)){
        // (A)
        document.write('~touch~eventにようこそ。');
    }

    if (%ev.touches.length == %ev.targetTouches.length){
        // (B)
        document.write('すべての~touch点は~target要素~上にあります。');
    }

    if (%ev.touches.length &gt; 1){
        // (C)
        document.write('複-~touchも~supportされています。');
    }

}, false);
&lt;/script&gt;
</pre>

<ul>
	<li>(A)
この~codeは、~touch面に対する最初の~touchが `touchable^l 要素も~targetにしている場合には，実行されるべきである。
`targetTouches$m は，~touch面~全体にわたる~touchたちの部分集合なので、常に［
%ev.`touches.length^m &gt;= %ev.`targetTouches.length^m
］になる。
</li>
	<li>(B)
`作動中な~touch点$すべてが `touchable^l 要素~上にある場合、
`TouchList.length$m ~propは同じになるべきである。
</li>
	<li>(C)
この~codeは、端末が複-~touchを~supportするときのみ実行される
— 単独の~touchのみ~supportする入力~装置~上では，~touch面~上の接点は一つだけなので。
</li>
</ul>

<pre lang="en" class="_en">
&lt;div id='touchable'&gt;This element is touchable.&lt;/div&gt;

&lt;script&gt;
document.getElementById('touchable').addEventListener('touchstart', function(ev) {

    if (ev.touches.item(0) == ev.targetTouches.item(0))
    {
        /**
         * If the first touch on the surface is also targeting the
         * "touchable" element, the code below should execute.
         * Since targetTouches is a subset of touches which covers the
         * entire surface, TouchEvent.touches &gt;= TouchEvents.targetTouches
         * is always true.
         */

        document.write('Hello Touch Events!');
    }

    if (ev.touches.length == ev.targetTouches.length)
    {
        /**
         * If all of the active touch points are on the "touchable"
         * element, the length properties should be the same.
         */

        document.write('All points are on target element')
    }

    if (ev.touches.length &gt; 1)
    {
        /**
         * On a single touch input device, there can only be one point
         * of contact on the surface, so the following code can only
         * execute when the terminal supports multiple touches.
         */

        document.write('Hello Multiple Touch!');
    }

}, false);
&lt;/script&gt;
</pre>
</div>

			</section>
			<section id="changedtouches-of-a-touchevent">
<h3 title="changedTouches of a TouchEvent">5.2.2. `TouchEvent^I の `changedTouches^m 属性</h3>

<p>
`changedTouches$m の有用性とその `TouchEvent$I ~interfaceの他の `TouchList$I ~memberとの関係を，次の例にデモる。
◎
This example demonstrates the utility of changedTouches and it's relation with the other TouchList members of the TouchEvent interface. The code is a example which triggers whenever a touch point is removed from the defined touchable element:
</p>

<div class="example">
<p>
次の~codeは、~touch可能として定義された要素から`~touch点$が除去される度に~eventを発火する：
</p>

<pre class="lang-html">
&lt;div id='touchable'&gt;この要素は~touch可能。&lt;/div&gt;
【！This element is touchable.】
&lt;script&gt;
document
.getElementById('touchable')
.addEventListener('touchend', function(%ev){
    document.write(
       %ev.changedTouches.length
       + ' 個の~touch点が除去されました。'
    );
    document.write(
       '要素~上には '
       + %ev.targetTouches.length
       + ' 個の~touch点が残されています。'
    );
    document.write(
       '文書~上には '
       + %ev.touches.length
       + ' 個の~touch点が残されています。'
    );
}, false);
&lt;/script&gt;
</pre>

<p>
~touch面に 3 個の`~touch点$があって、うち 2 個は `touchable^l 要素~上にあり， `touchable^l 要素~内の 1 個の~touch点が~touch面から持上げられたとするとき、［
除去される~touch点は 1 個 ／
要素に残される~touch点は 1 個 ／
文書に残される~touch点は 2 個
］になる。
</p>

<pre lang="en" class="_en">
&lt;div id='touchable'&gt;This element is touchable.&lt;/div&gt;

&lt;script&gt;
document.getElementById('touchable').addEventListener('touchend', function(ev) {

    /**
     * Example output when three touch points are on the surface,
     * two of them being on the "touchable" element and one point
     * in the "touchable" element is lifted from the surface:
     *
     * Touch points removed: 1
     * Touch points left on element: 1
     * Touch points left on document: 2
     */

    document.write('Touch points removed: ' + ev.changedTouches.length);
    document.write('Touch points left on element: ' + ev.targetTouches.length);
    document.write('Touch points left on document: ' + ev.touches.length);

}, false);
&lt;/script&gt;
</pre>
</div>

<!-- 
    document.write(
       'Touch points removed: ' + ev.changedTouches.length
    );
    document.write(
       'Touch points left on element: ' + ev.targetTouches.length
    );
    document.write(
       'Touch points left on document: ' + ev.touches.length
    );
-->

			</section>
          <section id="firing-a-synthetic-touchevent-from-script">
<h3 title="Firing a synthetic TouchEvent from script">5.2.3. ~scriptから合成な `TouchEvent^I を発火する</h3>

<div class="example">
<p>
~scriptから `TouchEvent$I を作成して発火する方法を，次の例にデモる：
◎
This example demonstrates how to create and fire a TouchEvent from script.
</p>

<pre class="lang-js">
if (Touch.length &lt; 1 || TouchEvent.length &lt; 1)
  throw "TouchEvent 構築子は~supportされていません";
【！TouchEvent constructors not supported"】
var %touch = new Touch({
    identifier: 42,
    target: document.body,
    clientX: 200,
    clientY: 200,
    screenX: 300,
    screenY: 300,
    pageX: 200,
    pageY: 200,
    radiusX: 5,
    radiusY: 5
});

var %touchEvent = new TouchEvent("touchstart", {
    cancelable: true,
    bubbles: true,
    composed: true,
    touches: [%touch],
    targetTouches: [%touch],
    changedTouches: [%touch]
});

document.body.dispatchEvent(%touchEvent);
</pre>
</div>

			</section>
		</section>
		<section id="#list-of-touchevent-types">
<h2 title="List of TouchEvent types">5.3. 各種~touch~eventの一覧</h2>

◎非規範的

<p>
この仕様に定義される各種 `TouchEvent$I ~event型を，次の表tに要約する。
これらのどの~eventも［
`浮上相$を成遂げる, かつ
~composed~event `DOM4$r になる
］べきである：
◎
The following table provides a summary of the TouchEvent event types defined in this specification. All events should accomplish the bubbling phase. All events should be composed [WHATWG-DOM] events.
</p>

<div>

<table id="table-event-summary"><thead>
<tr style="white-space:nowrap;"><th>~event型
<th>`取消~可能？$
<th>`既定~動作$

<tbody><tr><td>`touchstart$et
<td>`文脈依存$
<td>未定義

<tr><td>`touchend$et
<td>`文脈依存$
<td>文脈依存：
~UAは、
`~mouse＆~click~event＠#mouse-events$を配送してもヨイ
<tr><td>`touchmove$et
<td>`文脈依存$
<td>未定義

<tr><td>`touchcancel$et
<td>不可
<td>なし
</table>

<p>
これらのどの~eventも：
</p>

<ul><li>`TouchEvent$I ~interfaceを利用する
</li><li>`同期c$あり
</li><li>`浮上-$する
</li><li>~composedになる
</li><li>`~trusted$~event~target型は、`文書$または`要素$
</li></ul>

<div lang="en" class="_en">
<table><thead>
<tr><th>Event Type
<th>Sync / Async
<th>Bubbling phase
<th>Composed
<th>Trusted proximal event target types
<th>interface
<th>Cancelable
<th>Default Action
<tbody>

<tr><td>touchstart
<td>Sync
<td>Yes
<td>Yes
<td>Document, Element
<td>TouchEvent
<td>Varies
<td>undefined

<tr><td>touchend
<td>Sync
<td>Yes
<td>Yes
<td>Document, Element
<td>TouchEvent
<td>Varies
<td>
Varies: user agents may dispatch mouse and click events

<tr><td>touchmove
<td>Sync
<td>Yes
<td>Yes
<td>Document, Element
<td>TouchEvent
<td>Varies
<td>undefined

<tr><td>touchcancel
<td>Sync
<td>Yes
<td>Yes
<td>Document, Element
<td>TouchEvent
<td>No
<td>none
</table>
</div>
</div>

		</section>
		<section id="cancelability">
<h3 title="Cancelability of touch events">5.4. ~touch~eventの取消~可否</h3>

<p>
~touch~eventを`取消した$場合、~scrollingは防止-／中断され得る（~script実行と並列的に起こり得る）。
~scroll処理能を最大にするため、~UAは，~scrollに結付けられた各~touch~eventに対しては，取消されるかどうか見る処理-が済むまで待機しなくともヨイ。
加えて，そのような~eventを生成する際には、 `cancelable^m 属性を ~F にして，［
`preventDefault()^m を利用して~scrollingを防止-／中断すること
］はできないことを指示するべきである。
他の場合、 `cancelable^m は ~T になる。
◎
Canceling a touch event can prevent or otherwise interrupt scrolling (which could be happening in parallel with script execution). For maximum scroll performance, a user agent may not wait for each touch event associated with the scroll to be processed to see if it will be canceled. In such cases the user agent should generate touch events whose cancelable property is false, indicating that preventDefault cannot be used to prevent or interrupt scrolling. Otherwise cancelable will be true.
</p>

<p>
特に，~UAは、
当の~event用の`~passiveでない~listenerは無いことが観測された＠~DOM4#observing-event-listeners$ときは、
取消~不可な~touch~eventのみを生成するベキである。
◎
In particular, a user agent should generate only uncancelable touch events when it observes that there are no non-passive listeners for the event.
</p>

		</section>
		<section id="event-touchstart">
<h3 title="The touchstart event">5.5. `touchstart^et ~event</h3>
<p>
~UAは、［
利用者が，~touch面~上に`~touch点$を生じさせた
］とき，この~event型を配送するモノトスル。
◎
A user agent must dispatch this event type to indicate when the user places a touch point on the touch surface.
</p>

<p>
この~eventの~targetは`要素$になるモノトスル。
`~touch点$が~frameの中にある場合、
~eventは，その~frameの`内容~文書$【！子~閲覧~文脈】内の要素に配送されるべきである。
◎
The target of this event must be an Element. If the touch point is within a frame, the event should be dispatched to an element in the child browsing context of that frame.
</p>

<p>
この~eventが`取消され$た場合、同じ`作動中な~touch点$に結付けられた，どの~touch~eventに対しても，それにより生じる 既定~動作~すべてを
— ~mouse~eventや~scrollingも含め —
防止するべきである。
◎
If this event is canceled, it should prevent any default actions caused by any touch events associated with the same active touch point, including mouse events or scrolling.
</p>

		</section>
		<section id="event-touchend">
<h3 title="The touchend event">5.6. `touchend^et ~event</h3>

<p>
~UAは、［
利用者が，~touch面から`~touch点$を除去した
］とき，この~event型を配送するモノトスル。
これには、~drag中に~screenから外れたときなど，`~touch点$が~touch面から物理的に離れたときも含まれる。
◎
A user agent must dispatch this event type to indicate when the user removes a touch point from the touch surface, also including cases where the touch point physically leaves the touch surface, such as being dragged off of the screen.
</p>

<p>
この~eventの~targetは、当の`~touch点$が~touch面~上に最初に生じた所の`要素$と同じになるモノトスル
— `~touch点$がそこから~target要素の対話域の外側へ動かされたとしても。
◎
The target of this event must be the same Element on which the touch point started when it was first placed on the surface, even if the touch point has since moved outside the interactive area of the target element.
</p>

<p class="trans-note">【
`touchstart$et が生じてから `touchend$et が生じるまでの間に，~event~targetが~DOM~treeから除去された場合の挙動はどうなる？
】</p>

<div class="p">
<p>
生じた／除去された各`~touch点$は、 `TouchEvent$I の：
</p>

<ul>
	<li>
`changedTouches$m 属性に含めるモノトスル。
</li>
	<li>
`touches$m ／ `targetTouches$m
属性には含めないモノトスル。
</li>
</ul>

◎
The touch point or points that were removed must be included in the changedTouches attribute of the TouchEvent, and must not be included in the touches and targetTouches attributes.
</div>

<p>
この~eventが`取消され$た場合、
この~eventを含む~touch~event連列に属するどの~touch~eventも
`~clickには解釈しない＠#click-events$モノトスル。
◎
If this event is canceled, any sequence of touch events that includes this event must not be interpreted as a click.
</p>

		</section>
		<section id="event-touchmove">
<h3 title="The touchmove event">5.7. `touchmove^et ~event</h3>

<p>
~UAは、［
利用者が，`~touch点$を~touch面~上で動かした
］とき，この~event型を配送するモノトスル。
◎
A user agent must dispatch this event type to indicate when the user moves a touch point along the touch surface.
</p>

<p>
この~eventの~targetは、当の`~touch点$が~touch面~上に最初に生じた所の`要素$と同じになるモノトスル
— `~touch点$がそこから~target要素の対話域の外側へ動かされたとしても。
◎
The target of this event must be the same Element on which the touch point started when it was first placed on the surface, even if the touch point has since moved outside the interactive area of the target element.
</p>

<p>
~UAが `touchmove$et ~eventを送信する頻度は、実装により定義され，~hardware能力や他の実装の詳細~に依存し得ることに注意。
◎
Note that the rate at which the user agent sends touchmove events is implementation-defined, and may depend on hardware capabilities and other implementation details.
</p>

<p>
~UAは、［
同じ`作動中な~touch点$に結付けられた `touchmove$et ~event
］のうち，`取消され$なかったものが生じた時点までは，
`touchmove$et ~eventにより生じる既定~動作を抑止するべきである。
その時点~以降の `touchmove$et ~eventに対し，既定~動作が抑止されるかどうかは、実装に依存する。
◎
A user agent should suppress the default action caused by any touchmove event until at least one touchmove event associated with the same active touch point is not canceled. Whether the default action is suppressed for touchmove events after at least one touchmove event associated with the same active touch point is not canceled is implementation dependent.
</p>

		</section>
		<section id="event-touchcancel">
<h3 title="The touchcancel event">5.8. `touchcancel^et ~event</h3>

<div class="p">
<p>
~UAは、［
`~touch点$が実装に特有な方式で~~中断された
］とき，この~event型を配送するモノトスル。
次の様なときが該当する：
</p>

<ul>
	<li>
~touchを取消すような［
同期的~event／動作
］が~UAから生じたとき。
</li>
	<li>
`~touch点$が文書~UIwindowの中の［
利用者-ヤリトリを取扱う能力がある文書~域
］から外へ出たとき（例：
~UAの~native~UIや, 文書~内の~pluginが管理する区画へ入ったなど）。
</li>
</ul>

<p>
~UAは、［
利用者が，~touch面に［
装置または実装にて，格納するよう環境設定されている個数
］より多い`~touch点$を生じさせた
］とき，この~event型を配送してもヨイ
— この事例では、
`TouchList$I 内の最も早期の `Touch$I ~objから除去されるべきである。
</p>
◎
A user agent must dispatch this event type to indicate when a touch point has been disrupted in an implementation-specific manner, such as a synchronous event or action originating from the UA canceling the touch, or the touch point leaving the document window into a non-document area which is capable of handling user interactions (e.g. the UA's native user interface, or an area of the document which is managed by a plug-in). A user agent may also dispatch this event type when the user places more touch points on the touch surface than the device or implementation is configured to store, in which case the earliest Touch object in the TouchList should be removed.
</div>


<p>
この~eventの~targetは、当の`~touch点$が~touch面~上に最初に生じた所の`要素$と同じになるモノトスル
— `~touch点$がそこから~target要素の対話域の外側へ動かされたとしても。
◎
The target of this event must be the same Element on which the touch point started when it was first placed on the surface, even if the touch point has since moved outside the interactive area of the target element.
</p>

<div class="p">
<p>
除去された各`~touch点$は：
</p>

<ul>
	<li>
`TouchEvent$I の `changedTouches$m 属性に含めるモノトスル。
</li>
	<li>
`touches$m ／ `targetTouches$m
属性には含めないモノトスル。
</li>
</ul>

◎
The touch point or points that were removed must be included in the changedTouches attribute of the TouchEvent, and must not be included in the touches and targetTouches attributes.
</div>

		</section>
	</section>
	<section id="retargeting">
<h2 title="Retargeting">6. ~retarget法</h2>

<p>
この節では、 “~retargetする手続き” `DOM4$r を与える。
◎
The following section describes retargeting steps, defined in [[!WHATWG-DOM]].
◎
…
</p>

<p class="trans-note">【
“~retargetする手続き” は，
`その仕様から除去された＠https://github.com/whatwg/dom/commit/fc165642b437c548a11222c85ddda0094ed40ea5$
（それに相当する`~touch~target~list$に置換された）ので、
この節の内容の和訳は省略する
（それに伴い、この仕様も近いうちに更新されるであろう）。
】</p>

	</section>
	<section id="conditionally-exposing-legacy-touch-event-apis">
<h2 title="Conditionally exposing legacy touch event APIs">7. 旧来の~touch~event ~APIの条件付き公開-法</h2>

<p>
各~UAには、
真偽値をとる
`旧来の~touch~event~APIを公開するか@
が結付けられる
— その値は、
`実装定義$とする。
◎
User agents have an associated boolean expose legacy touch event APIs whose value is implementation-defined.
</p>

<p class="note">注記：
既存の~web内容は、
~touch~event~APIの存在を［
~UAは、
~touchが可能化された “~mobile” 機器で~~稼働している
］ことの通達として利用することが多い
— したがって，
これらの~APIを~mobileでない機器に公開すると、
~touchが可能化されていたとしても，
そのような~web内容における利用者~体験を最適とは言えないものに至らせ得る。
◎
Existing web content often use the existence of these APIs as a signal that the user agent is a touch-enabled "mobile" device, and therefore exposing these APIs on non-mobile devices, even if they are touch-enabled, could lead to a suboptimal user experience for such web content.
</p>

	</section>
	<section id="extensions-to-the-globaleventhandlers-interface">
<h2 title="Extensions to the GlobalEventHandlers interface">8. `GlobalEventHandlers^I ~mixinに対する拡張</h2>

<p>
この節では、
`HTML5$r に定義される既存の `GlobalEventHandlers$I ~mixinに対する拡張を述べる
— ~event~handler登録の便宜のための。
~UAのうち［
`旧来の~touch~event~APIを公開するか$ ~EQ ~F
］なるものは、
この~mixinを実装してはナラナイ。
◎
The following section describes extensions to the existing GlobalEventHandlers mixin, defined in [HTML5], to facilitate the event handler registration. For user agents where expose legacy touch event APIs is false, this mixin must not be implemented.
</p>

<pre class="idl">
partial interface mixin `GlobalEventHandlers$I {
                attribute EventHandler `ontouchstart$m;
                attribute EventHandler `ontouchend$m;
                attribute EventHandler `ontouchmove$m;
                attribute EventHandler `ontouchcancel$m;
};
</pre>

<dl class="idl-def">

	<dt>`EventHandler$I `ontouchstart@m</dt>
	<dt>`EventHandler$I `ontouchend@m</dt>
	<dt>`EventHandler$I `ontouchmove@m</dt>
	<dt>`EventHandler$I `ontouchcancel@m</dt>
	<dd>
順に，［
`touchstart$et,
`touchend$et,
`touchmove$et,
`touchcancel$et
］~event型に対する
`~event~handler~IDL属性$（ `HTML5$r ）。
◎
ontouchstart
◎
The event handler IDL attribute (see [HTML5]) for the touchstart event type.
◎
ontouchend
◎
The event handler IDL attribute (see [HTML5]) for the touchend event type.
◎
ontouchmove
◎
The event handler IDL attribute (see [HTML5]) for the touchmove event type.
◎
ontouchcancel
◎
The event handler IDL attribute (see [HTML5]) for the touchcancel event type.
</dd>
</dl>

	</section>
	<section id="mouse-events">

<h2 title="Interaction with Mouse Events and click">9. ~mouse~event ／ `click^et との相互作用</h2>

<p>
~UAは、同じ利用者~入力に呼応して
~touch~event, ［
~mouse~event
`DOM-LEVEL-2-EVENTS$r
］の両者を（~touch用に設計されていない~web内容との互換性のために）配送してもヨイ。
単独の利用者~動作に対し，この両者とも配送する~UAは、その動作に対するどの~mouse~event型よりも先に `touchstart$et ~event型を配送するモノトスル。
［
`touchstart$et,
`touchmove$et,
`touchend$et
］のいずれかが`取消され$た場合、~UAは，~touch~eventに伴って生じることになる どの~mouse~eventも配送するべきでない。
◎
The user agent may dispatch both touch events and (for compatibility with web content not designed for touch) mouse events [DOM-LEVEL-2-EVENTS] in response to the same user input. If the user agent dispatches both touch events and mouse events in response to a single user action, then the touchstart event type must be dispatched before any mouse event types for that action. If touchstart, touchmove, or touchend are canceled, the user agent should not dispatch any mouse event that would be a consequential result of the prevented touch event.
</p>

<p class="note">
~touch~eventを処理できる~Web~appは、その~eventを`取消す$こともできる
— その場合、~UAは，対応する~mouse~eventを配送する必要はない。
特に~touch入力~装置~用に書かれてはいない~Web~appは、代わりに後続な~mouse~eventに反応することになる。
◎
If a Web application can process touch events, it can cancel the events, and no corresponding mouse events would need to be dispatched by the user agent. If the Web application is not specifically written for touch input devices, it will react to the subsequent mouse events instead.
</p>

<p class="note">
~UAは、概して，（~tapや長押しの様な）一本指による作動化~gestureに限り［
~mouse／~click
］~eventを配送することになる。
~touch点の動きや複-~touchによる対話を孕むような~gesture
— 複数の`作動中な~touch点$を孕むような複-~touch —
は、通例的には，~touch~eventのみを生成することになる。
◎
User agents will typically dispatch mouse and click events only for single-finger activation gestures (like tap and long press). Gestures involving movement of the touch point or multi-touch interactions – with two or more active touch points – will usually only generate touch events.
</p>

<p id="click-events">
ある~touch~event連列を~tap~gestureとして解釈する~UAは、［
`mousemove$et,
`mousedown$et,
`mouseup$et,
`click$et
］~eventを（この順序で），対応する~touch入力に対する `touchend$et ~eventの~targetに配送するべきである。
~touch~event処理の間に文書の内容が変化した場合、~UAはそれらの~mouse~eventを~touch~eventと異なる~targetへ配送してもヨイ。
◎
If the user agent interprets a sequence of touch events as a tap gesture, then it should dispatch mousemove, mousedown, mouseup, and click events (in that order) at the location of the touchend event for the corresponding touch input. If the contents of the document have changed during processing of the touch events, then the user agent may dispatch the mouse events to a different target than the touch events.
</p>

<p>
［
~touch／~mouse
］~eventによる，更なる既定~動作の順序は、他所で指定されない限り，実装により定義される。
◎
The default actions and ordering of any further touch and mouse events are implementation-defined, except as specified elsewhere.
</p>

<div class="note">

<p>注記：
要素の作動化（例： 一部の実装における~tap）は、概して，次の~event連列を生産することになる（これは、~UAに特有な挙動に依存して，多少変わり得るが）：
◎
The activation of an element (e.g., in some implementations, a tap) would typically produce the following event sequence (though this may vary slightly, depending on specific user agent behavior):
</p>

<ol ><li>`touchstart$et
</li><li>0 回以上の `touchmove$et ~event（回数は指の動きに依存する）
◎
Zero or more touchmove events, depending on movement of the finger
</li><li>`touchend$et
</li><li>`mousemove$et （~mouseに特有な旧来の~codeとの互換性のため）
◎
mousemove (for compatibility with legacy mouse-specific code)
</li><li>`mousedown$et
</li><li>`mouseup$et
</li><li>`click$et
</li></ol>

<p>
上の~~過程で［
`touchstart$et,
`touchmove$et,
`touchend$et
］~eventのいずれかが`取消され$た場合、［
~mouse／~click
］~eventは，発火されないことになり、結果の~event連列は単純に次の様になるであろう：
◎
If, however, either the touchstart, touchmove or touchend event has been canceled during this interaction, no mouse or click events will be fired, and the resulting sequence of events would simply be:
</p>

<ol ><li>`touchstart$et
</li><li>0 回~以上の `touchmove$et ~event（回数は指の動きに依存する）
◎
Zero or more touchmove events, depending on movement of the finger
</li><li>`touchend$et
</li></ol>
</div>

<div class="note">
<p>注記：
~UAが Touch Event を~supportするとしても、利用者に可用な入力の仕組みは，~touchscreenだけとは限らない。
特に、~touchが可能化されている~laptopや, 伝統的に “~touchのみ” の機器（携帯電話や~tablet）に外部~入力~装置が~~装着されている事例では、利用者は，~touchscreenに加えて，
~trackpad, ~mouseや~keyboard
— 以下，~mouse等と略記する —
を利用することもある。
この理由から，開発者は、~event~listenerを排他的に
“~touchか~mouse等のどちらか”
に束縛するのは避けるべきである
— そうすると，~siteや~appは ~touch以外を受け付けなくなり、利用者は他の入力の仕組みを利用できなくなるので。
◎
Even if a user agent supports Touch Events, this does not necessarily mean that a touchscreen is the only input mechanism available to users. Particularly in the case of touch-enabled laptops, or traditional "touch only" devices (such as phones and tablets) with paired external input devices, users may use the touchscreen in conjunction with a trackpad, mouse or keyboard. For this reason, developers should avoid binding event listeners with "either touch or mouse/keyboard" conditional code, as this results in sites/application that become touch-exclusive, preventing users from being able to use any other input mechanism.
</p>

<pre class="example lang-js">
/* <span class="comment">
~eventを条件に応じて
“~touch, ~mouse等の片方”
に束縛する~code
— <strong>これは行わないこと</strong>
— そうすると、機器が~touch, ~mouse等の両者を備えていても、~touch以外を受け付けなくなるので：
◎
conditional "touch OR mouse/keyboard" event binding DON'T DO THIS, as it makes interactions touch-exclusive on devices that have both touch and mouse/keyboard
</span>*/

if ('ontouchstart' in window) {
  /* <span class="comment">
~touchに対する~event~listenerを設定しておく
◎
set up event listeners for touch
</span>*/
  target.addEventListener('touchend', ...);
  ...
} else {
  /* <span class="comment">
~mouse等に対する~event~listenerを設定しておく
◎
set up event listeners for mouse/keyboard
</span>*/
  target.addEventListener('click', ...);
  ...
}
</pre>

<p>
開発者は代わりに，入力を同時並行に取扱う形にするべきである。
◎
Instead, developers should handle different forms of input concurrently.
</p>


<pre class="example lang-js">
/* <span class="comment">
~eventを同時並行に
“~touch, および~mouse等”
に束縛する~code：
◎
concurrent "touch AND mouse/keyboard" event binding
</span>*/

/* <span class="comment">
~touchに対する~event~listenerを設定しておく
◎
set up event listeners for touch
</span>*/
target.addEventListener('touchend', function(e) {
  /* <span class="comment">
互換性~mouse~eventや~clickは防止する
◎
prevent compatibility mouse events and click
</span>*/
  e.preventDefault();
  ...
});
...

/* <span class="comment">
~mouse等に対する~event~listenerを設定しておく
◎
set up event listeners for mouse/keyboard
</span>*/
target.addEventListener('click', ...);
...
</pre>
<p>
~touchに対し，同じヤリトリを重ねて処理する（ ~touch~event用に一回, 互換性~mouse~event用に一回）のを避けるため、開発者は，
~touch~eventを必ず`取消して＠#dfn-canceled-event$
~mouse／~click ~eventが更に生成されないようにするべきである。 
あるいは、~mouse~eventが~touch~eventから生成されたものかどうかを検出する仕方もある
— `InputDeviceCapabilities API＠http://wicg.github.io/InputDeviceCapabilities/$cite を見よ。
◎
To avoid processing the same interaction twice for touch (once for the touch event, and once for the compatibility mouse events), developers should make sure to cancel the touch event, suppressing the generation of any further mouse or click events. Alternatively, see the InputDeviceCapabilities API for a way to detect mouse events that were generated as a result of touch events.
</p>
</div>

	</section>
	<section id="glossary">
<h2 title="Glossary">10. 用語集</h2>

<dl>
	<dt>`作動中な~touch点@</dt>
	<dd>
現在~screen上にあって, かつ ~UAが追跡している`~touch点$。
`~touch点$は、~UAが［
その出現を指示する `touchstart$et ~eventを最初に配送し始める時点
］から，［
~touch点が，~touch面から除去されたか, もはや追跡されなくなったことを指示する［
`touchend$et ／ `touchcancel$et
］~eventを配送し終えた時点
］まで、`作動中$とされる。
◎
A touch point which is currently on the screen and is being tracked by the user agent. The touch point becomes active when the user agent first dispatches a touchstart event indicating its appearance. It ceases to be active after the user agent dispatches a touchend or touchcancel event indicating that the touch point is removed from the surface or no longer tracked.
</dd>

	<dt>`~touch面@</dt>
	<dd>
~touch入力を感知する物理的な面。
</dd>

	<dt>`~touch点@</dt>
	<dd>
装置~interfaceの~touch面に，~pointer（例：指や~stylusなど）が接する所の座標。
これを適用し得るのは、~touch~screenに~touchしている指や, 紙片上で書いている~digital~penである。
◎
The coordinate point at which a pointer (e.g finger or stylus) intersects the target surface of an interface. This may apply to a finger touching a touch-screen, or an digital pen writing on a piece of paper.
</dd>

	<dt>`取消された~event@</dt>
	<dd>
［
`preventDefault()^m ~event~handlerにて ~F を返す, その他の手段
］により、既定~動作が防止された~event。
`DOM-LEVEL-3-EVENTS$r `HTML5$r
◎
An event whose default action was prevented by means of preventDefault(), returning false in an event handler, or other means as defined by [DOM-LEVEL-3-EVENTS] and [HTML5].
</dd>
</dl>

	</section>
	<section id="acknowledgements">

<h2 title="Acknowledgements">謝辞</h2>

◎非規範的

<p>
この仕様の基礎に利用されている~modelを開発した WebKit 技術者たちに：
WebKit ~touch~eventを要約された `Neil Roberts^en 氏 (SitePen)，
示唆を寄せられた `Peter-Paul Koch^en 氏 (PPK)，
`ReSpec.js 仕様~著作~tool＠http://dev.w3.org/2009/dap/ReSpec.js/documentation.html$を開発された `Robin Berjon^en 氏。
多くの貢献を寄せられた WebEvents WG に。
◎
Many thanks to the WebKit engineers for developing the model used as a basis for this spec, Neil Roberts (SitePen) for his summary of WebKit touch events, Peter-Paul Koch (PPK) for his write-ups and suggestions, Robin Berjon for developing the ReSpec.js spec authoring tool, and the WebEvents WG for their many contributions.
</p>

<p>
仕様が開発されるに伴い、~commentを寄せられ，揺るぎない改善点へ導いた，他の多くの方々に：
</p>

<p lang="en">
Many others have made additional comments as the spec developed, which have led to steady improvements. Among them are Matthew Schinckel, Andrew Grieve, Cathy Chan, Boris Zbarsky, Patrick H. Lauke, and Simon Pieters. If we inadvertently omitted your name, please let me know.
</p>

<p>
この仕様の~test一式に貢献された次の方々に：
</p>

<p lang="en">
The group acknowledges the following contributors to this specification's test suite: Matt Brubeck, Olli Pettay, Art Barstow, Cathy Chan and Rick Byers.
</p>

	</section>
	<section id="changes-since-last-publication">
<h2 title="Changes Since Last Publication">最後の公表からの変更点</h2>

◎非規範的

<p>
この節では、
`2013年 10月 10日 勧告＠~TR/touch-events/$が公表されて以降の，主要な変更点を要約する。
`全部的な commit 履歴＠https://github.com/w3c/touch-events/compare/v1...gh-pages$も可用である。
◎
This is a summary of the major changes made since the 10 October 2013 Recommendation was published. Full commit history is also available.
</p>
<ul>
	<li>
［
`altitudeAngle$m / `azimuthAngle$m
］の記述を `POINTEREVENTS$r に揃うよう書き直して，説明図を追加した。
`125^pull
◎
Reword altitudeAngle/azimuthAngle descriptions in line with PointerEvents, add illustrations
</li>
	<li>
`getModifierState()$m の定義を追加した。
`120^pull
◎
Add getModifierState definition
</li>
	<li>
`force$m 属性を `Touch$I に追加した。
`303b36e1d188a380f9bc0861b175438e596a34b1^commit
◎
Added force attribute to Touch
</li>
	<li>
`radiusX$m, `radiusY$m
属性を `Touch$I に追加した。
`6d222fb7f106273bef847ad1d1d7a23569841954^commit
◎
Added radiusX and radiusY attributes to Touch
</li>
	<li>
`rotationAngle$m
属性を `Touch$I に追加した。
`487f6815a9590b72779d4820ff43c2b58d798f92^commit
◎
Added rotationAngle attribute to Touch
</li>
	<li>
座標を long 型から double 型に昇格した。
`006274ffada14de504f731afdb5ec1581ff327ca^commit
◎
Upgraded co-ordinates to double type instead of long
</li>
	<li>
`preventDefault()^m に対する
`touchmove$et の挙動を更新した
`df620100e48111cf7a30592f344606f8c8b7fe22^commit
◎
Update touchmove behavior on preventDefault
</li>
	<li>
`touchend$et ~eventの取消した場合の効果を明確化した。
`54a3d1668c4f727d9c6f6d729b28a036041e301f^commit
◎
Clarify effect of canceling touchend event
</li>
	<li>
`TouchEvent$I, `Touch$I
に構築子を追加した。
`219546b80cd148543a5ece656d81ba3c901d2106^commit
◎
Add constructor for TouchEvent and Touch
</li>
	<li>
旧来の~event初期化子 `initTouchEvent()^m を追加した。
`50f51ccacb0d5ad06f9cf6ed44f853d6a3616d10^commit
◎
Added legacy event initializer initTouchEvent
</li>
	<li>
`~touch~eventの取消~可否＠#cancelability$用の~supportを追加した。
加えて、~scroll処理能による含意について述べた。
`59^pull
◎
Added support for uncancelable touch events and described scroll performance implications.
</li>
	<li>
すべての~eventについて， “~composed” になるべきものと指示した。
`67^pull
◎
Indicate that all events should be "composed".
</li>
	<li>
~eventを条件に応じて
“~touch, ~mouse等の片方”
に束縛するのは避けることについての注記。
`72^pull
◎
Note about avoiding conditional "touch OR mouse/keyboard" event handling
</li>
	<li>
`TouchEvent$I を~retargetする手続きを追加した。
`73^pull
◎
Added TouchEvent's retargeting steps
</li>
	<li>
`touchType^m, `altitudeAngle^m, `azimuthAngle^m を追加した（ Safari iOS 10.3 による，~stylus用の拡張）。
`81^pull
◎
Add touchType, altitudeAngle, azimuthAngle (Safari iOS 10.3 extensions for stylus)
</li>
	<li>
構築子に [Exposed=Window] を追加した。
`88^pull
◎
Add [Exposed=Window] to Constructor 
</li>
	<li>
~touch~targetを調整する~UAもあることについての注記を追加した。
`95^pull
◎
Add note to mention UA might adjusting touch target
</li>
	<li>
旧来の~event初期化子（ `createTouch()^m, `createTouchList()^m ）を除去した
`96^pull。
`initTouchEvent()^m, `createTouchList()^m
についての注記も除去した
`100^pull。
◎
Remove Legacy Event Initializers (createTouch and createTouchList) and the note about initTouchEvent / createTouchList
</li>
	<li>
旧来の~touch~event~APIを条件付きで公開するようにした。
`111^pull
◎
Conditionally expose legacy touch events API
</li>
	<li>
`getModifierState()$m の定義を `TouchEvent$I に追加した。
`91^pull
◎
Add getModifierState definition to TouchEvent
</li>
</ul>

	</section>
</main></div>

