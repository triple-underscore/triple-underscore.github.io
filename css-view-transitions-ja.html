<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8">
<title>CSS View Transitions Module Level 2（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">
<style>
._example-video {
	display: block;
	width: 100%;
	max-height: 369px;
	height: auto;
	margin: 0;
	aspect-ratio: 1404/738
}

.side-by-side {
	colmun-width: 20em;
	column-count: 2;
	column-rule-width: 1em;
}


#_phases-diagram {
	overflow-x: auto;
}
#_phases-diagram button {
	min-width: 4em;
	white-space: nowrap;
}
#_vt-slide {
	display: flex;
}
#_vt-slide > div {
	padding: 0.3em;
}

._vt-box {
	font-size: 1.5em;
	border: solid thin var(--K-color);
	width: 8em;
	height: 8em;
	position: relative;
}

._vt-state1,
._vt-state2 {
	width: 5em;
	text-align: center;
	border-radius: 0.4em;
}
._vt-state1 {
	background: var(--G-color);
	color: var(--W-color);
	position: absolute;
	top: 0;
	left: 0;
}
._vt-state2 {
	background: var(--O-bg);
	color: var(--K-color);
	position: absolute;
	top: 5em;
	left: 3em;
}
._vt-comment {
	position: absolute;
	bottom: 0;
	right: 0.3em;
	font-size: 0.7em;
	color: var(--dim-color);
}

._vt-a1 {
	animation-name: _vt-a1;
	animation-duration: 1s;
	animation-fill-mode: forwards;
}
._vt-a2 {
	animation-name: _vt-a2;
	animation-duration: 1s;
	animation-fill-mode: forwards;
}

@keyframes _vt-a1 {
	from {
		left: 0px;
		top: 0px;
		opacity: 1;
	}
	to {
		left: 3em;
		top: 5em;
		opacity: 0;
	}
}
@keyframes _vt-a2 {
	from {
		left: 0px;
		top: 0px;
		opacity: 0;
	}
	to {
		left: 3em;
		top: 5em;
		opacity: 1;
	}
}
</style>

<style id="_vt-phase_style">
._vt-phase:not(*[data-phases~="1"]){
	display: none;
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
const initPhaseSlide = () => {
	let current_phase = 1;
	const phase_min = 1;
	const phase_max = 9;

	const update_pahse = (pahse) => {
		E('_vt-phase_style').textContent = `
		._vt-phase:not(*[data-phases~="${pahse}"]){
			display: none;
		}`;
		E("_vt-buttons-prev").disabled = (pahse===phase_min);
		E("_vt-buttons-next").disabled = (pahse===phase_max);
	}
	update_pahse(1);

	E("_vt-buttons-prev").onclick = () => {
		if(current_phase === phase_min) { return; }
		current_phase--;
		update_pahse(current_phase);
	}
	E("_vt-buttons-next").onclick = () => {
		if(current_phase === phase_max) { return; }
		current_phase++;
		update_pahse(current_phase);
	}
}

Util.ready = function(){
	const source_data = {
		populate: () => {initPhaseSlide()},
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'at':
	text = `@${key}`;
	break;
case 'p':
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'pe':
	text = `::${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'm1':
	let n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}"></a>`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:CSS View Transitions Module Level 2
spec_date:2025-11-25
trans_update:2025-11-26
source_checked:250205
page_state_key:CSS
original_url:https://drafts.csswg.org/css-view-transitions-2/
	abbr_url:CSSVT
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-anim,css
conformance:css
copyright:2025,permissive
trans_1st_pub:2023-12-21

●●class_map
p:property
d:descriptor
ps:pseudo
pe:pseudo
t:type
css:css
at:at-rule
f:func
u:unit
v:value
vN:value
et:event-type
e:element
a:attr
aL:attr
E:error
jv:js-value

●●tag_map
p:code
pe:code
ps:code
t:var
at:code
css:code
f:code
d:code
u:code
et:code
e:code
a:code
aL:code
I:code
m:code
m1:code
mb:code
E:code
v:code
vN:code
jv:code
c:code
V:var
em:em
i:i
cite:cite

●●original_id_map
	descdef-view-transition-types:view-transition-types
view-transition-name-match-element:

●●mdn_urls
view-transitions:API/View_Transitions_API
viewtransition:API/ViewTransition
	viewtransitiontypeset:API/ViewTransitionTypeSet
	cssviewtransitionrule:API/CSSViewTransitionRule
dom-document-startviewtransition:API/Document/startViewTransition
dom-viewtransition-updatecallbackdone:API/ViewTransition/updateCallbackDone
dom-viewtransition-finished:API/ViewTransition/finished
dom-viewtransition-ready:API/ViewTransition/ready
dom-viewtransition-skiptransition:API/ViewTransition/skipTransition
at-view-transition-rule:CSS/@view-transition
propdef-view-transition-name:CSS/view-transition-name
	propdef-view-transition-group:CSS/view-transition-group
	propdef-view-transition-class:CSS/view-transition-class
selectordef-view-transition:CSS/::view-transition
selectordef-view-transition-group:CSS/::view-transition-group
selectordef-view-transition-image-pair:CSS/::view-transition-image-pair
selectordef-view-transition-new:CSS/::view-transition-new
selectordef-view-transition-old:CSS/::view-transition-old

	active-view-transition-pseudo:CSS/:active-view-transition
	active-view-transition-type-pseudo:CSS/active-view-transition-type()

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject

any:~WEBIDL#idl-any
undefined:~WEBIDL#idl-undefined
unrestricted double:~WEBIDL#idl-unrestricted-double
c.unrestricted double:~WEBIDL#idl-unrestricted-double
Promise:~WEBIDL#idl-promise
~promise:~WEBIDL#idl-promise
sequence:~WEBIDL#idl-sequence
DOMString:~WEBIDL#idl-DOMString
CSSOMString:~CSSOM1#cssomstring
FrozenArray:~WEBIDL#idl-frozen-array

E.AbortError:~WEBIDL#aborterror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.TimeoutError:~WEBIDL#timeouterror

I.CSSRule:~CSSOM1#cssrule
I.CSSKeyframesRule:~CSSANIM#csskeyframesrule
I.CSSStyleRule:~CSSOM1#cssstylerule
I.CSSViewTransitionRule:#cssviewtransitionrule
I.Document:~DOM4#document
	I.Document → 文書
	I.DOMException:~WEBIDL#idl-DOMException → 例外
I.Element:~DOM4#element
	I.Element:~DOM4#element → 要素
I.IntersectionObserver:~INTERSECTIONOBSERVER#intersectionobserver
I.NavigateEvent:~HTMLnavAPI#navigateevent
I.NavigationType:~HTMLnavAPI#navigationtype
I.PageRevealEvent:~HTMLnavAPI#pagerevealevent
I.PageSwapEvent:~HTMLnavAPI#pageswapevent
I.StartViewTransitionOptions:#dictdef-startviewtransitionoptions
I.ViewTransition:#viewtransition
I.ViewTransitionTypeSet:#viewtransitiontypeset
I.ViewTransitionUpdateCallback:#callbackdef-viewtransitionupdatecallback
	I.HTMLLinkElement:~HEmetadata#htmllinkelement → e.link

	%callbackOptions:#dom-document-startviewtransition-callbackoptions-callbackoptions
	＠#dom-document-startviewtransition

V.更新~callback:#callbackdef-viewtransitionupdatecallback
V.viewTransition:#viewtransition

m.activation:~HTMLnavAPI#dom-pageswapevent-activation
m.activeViewTransition:#dom-document-activeviewtransition
m1.activeViewTransition:#dom-element-activeviewtransition
m.finished:#dom-viewtransition-finished
m.height:~GEOMETRY#dom-domrect-height
m.navigation:#dom-cssviewtransitionrule-navigation
m.ready:#dom-viewtransition-ready
m.sessionStorage:~WEBSTORAGE#dom-sessionstorage
m.signal:~HTMLnavAPI#dom-navigateevent-signal
m.skipTransition:#dom-viewtransition-skiptransition
m.startViewTransition:#dom-document-startviewtransition
m1.startViewTransition:#dom-element-startviewtransition
m.transitionRoot:#dom-viewtransition-transitionroot
m.types:#dom-viewtransition-types
m1.types:#dom-cssviewtransitionrule-types
m.updateCallbackDone:#dom-viewtransition-updatecallbackdone
m.viewTransition:~HTMLnavAPI#dom-pagerevealevent-viewtransition
m1.viewTransition:~HTMLnavAPI#dom-pageswapevent-viewtransition
m.waitUntil:#dom-viewtransition-waituntil
m.width:~GEOMETRY#dom-domrect-width

	m.blocking:~HEscripting#dom-script-blocking → a.blocking
	m1.blocking:~HEmetadata#dom-style-blocking → aL.blocking


mb.update:#dom-startviewtransitionoptions-update
mb.types:#dom-startviewtransitionoptions-types

l.reload:~HTMLnavAPI#dom-navigationtype-reload
l.traverse:~HTMLnavAPI#dom-navigationtype-traverse
l.push:~HTMLnavAPI#dom-navigationtype-push
l.replace:~HTMLnavAPI#dom-navigationtype-replace

	●CSS code

p.backdrop-filter:https://drafts.fxtf.org/filter-effects-2/#propdef-backdrop-filter
p.border-radius:~CSSBORDER#propdef-border-radius
p.border-width:~CSSBORDER#propdef-border-width
p.clip-path:~MASKING1#propdef-clip-path
p.color-scheme:~CSSCOLORADJUST#propdef-color-scheme
p.contain:~CSSCONTAIN#propdef-contain
p.direction:~CSSWM#propdef-direction
p.filter:~FILTERS#propdef-filter
p.height:~SIZING#propdef-height
p.isolation:~COMPOSITING#propdef-isolation
p.mask-image:~MASKING1#propdef-mask-image
p.mix-blend-mode:~COMPOSITING#propdef-mix-blend-mode
p.opacity:~CSSCOLOR#propdef-opacity
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.perspective:~TRANSFORM2#propdef-perspective
p.pointer-events:~CSSUI#propdef-pointer-events
p.text-orientation:~CSSWM#propdef-text-orientation
p.transform-style:~TRANSFORM2#propdef-transform-style
p.transform:~TRANSFORM#propdef-transform
p.view-transition-class:#propdef-view-transition-class
p.view-transition-group:#propdef-view-transition-group
p.view-transition-name:#propdef-view-transition-name
p.visibility:~CSSDISP#propdef-visibility
p.width:~SIZING#propdef-width
p.writing-mode:~CSSWM#propdef-writing-mode
p.z-index:~CSS2J#propdef-z-index

et.pagereveal:~HTMLindex#event-pagereveal
et.pageswap:~HTMLindex#event-pageswap
et.unhandledrejection:~HTMLindex#event-unhandledrejection

t.blend-mode:~COMPOSITING#ltblendmodegt
t.custom-ident:~CSSVAL#identifier-value
	t.custom-ident:#valdef-view-transition-class-custom-ident
	t.custom-ident:#valdef-view-transition-name-custom-ident
t.declaration-list:~CSSSYN#typedef-declaration-list
t.pt-name-and-class-selector:#typedef-pt-name-and-class-selector
t.pt-class-selector:#typedef-pt-class-selector
t.pt-name-selector:#typedef-pt-name-selector
t.transform-function:~TRANSFORM2#typedef-transform-function

vN.auto:#valdef-view-transition-navigation-auto
vN.none:#valdef-view-transition-navigation-none

v.~noneC:#valdef-view-transition-class-none

v.none:#valdef-view-transition-name-none
v.auto:#view-transition-name-auto
v.match-element:#view-transition-name-match-element

v.normal:#valdef-view-transition-group-normal
v.nearest:#valdef-view-transition-group-nearest
v.contain:#valdef-view-transition-group-contain
	t.custom-ident:#valdef-view-transition-group-custom-ident

v.view-transition:#_valdef-contain-view-transition

v.border-box:~SIZING#valdef-box-sizing-border-box
v.plus-lighter:~COMPOSITING#plus-lighter

at.media:~CSSCOND#at-ruledef-media
at.supports:~CSSCOND#at-ruledef-supports
at.view-transition:#at-view-transition-rule
d.navigation:#descdef-view-transition-navigation
	d.navigation:#view-transition-navigation
d.types:#descdef-view-transition-types
	d.types:#view-transition-types

ps.active-view-transition:#active-view-transition-pseudo
ps.active-view-transition-type():#active-view-transition-type-pseudo
ps.only-child:~SELECTORS4#only-child-pseudo
ps.root:~SELECTORS4#root-pseudo
pe.view-transition:#selectordef-view-transition
pe.view-transition-group():#selectordef-view-transition-group
pe.view-transition-group-children():#selectordef-view-transition-group-children
pe.view-transition-image-pair():#selectordef-view-transition-image-pair
pe.view-transition-old():#selectordef-view-transition-old
pe.view-transition-new():#selectordef-view-transition-new
pe.part():~CSSSHADOWPARTS#selectordef-part

	●code 他
e.link:~HEmetadata#the-link-element
e.script:~HEscripting#the-script-element
e.style:~HEmetadata#the-style-element
e.iframe:~HEembed#the-iframe-element

a.class:~HTMLdom#classes
	a.class:~DOM4#concept-class
a.blocking:~HEscripting#attr-script-blocking
aL.blocking:~HEmetadata#attr-link-blocking

v.expect:~HTMLlinks#link-type-expect

	●用語
~view遷移:#view-transitions
大域的な~view遷移:#global-view-transitions
視野~付き~view遷移:#scoped-view-transitions
~view遷移~名:#view-transition-name
~view遷移~名~封込め:#view-transition-name-containment
文書~視野な~view遷移~名:#document-scoped-view-transition-name
疑似要素~tree:#pseudo-element-tree
疑似要素~根:#pseudo-element-root
~view遷移~tree:#view-transition-tree
~view遷移~疑似要素:#view-transition-pseudo-elements
有名~view遷移~疑似要素:#named-view-transition-pseudo-elements

~snapshot包含塊:#snapshot-containing-block
~snapshot包含塊の原点:#snapshot-containing-block-origin
~snapshot包含塊の~size:#snapshot-containing-block-size
~view遷移~層:#view-transition-layer
大域的な~view遷移~UA~stylesheet:#global-view-transition-user-agent-style-sheet

vT.有名~要素~群:#viewtransition-named-elements
vT.相:#viewtransition-phase
vT.更新~callback:#viewtransition-update-callback
vT.準備済み時の~promise:#viewtransition-ready-promise
vT.更新~callback済み時の~promise:#viewtransition-update-callback-done-promise
vT.完遂-時の~promise:#viewtransition-finished-promise
vT.遷移~根~疑似要素:#viewtransition-transition-root-pseudo-element
vT.初期~snapshot包含塊~size:#viewtransition-initial-snapshot-containing-block-size
vT.作動中な型~群:#viewtransition-active-types
vT.~inboundな非同一-文書な遷移か:#viewtransition-is-inbound-cross-document-transition
vT.外へ出る捕捉-後の手続き:#viewtransition-outbound-post-capture-steps
vT.根~要素:#viewtransition-root-element

i.捕捉-待ち:#_pending-capture
i.~animate中:#_animating
i.更新~callbackは~call済み:#_update-callback-called
i.済み:#_done

doc.作動中な~view遷移:#document-active-view-transition
doc.~view遷移~用の描画を抑止するか:#document-rendering-suppression-for-view-transitions
doc.動的な~view遷移~stylesheet:#document-dynamic-view-transition-style-sheet
doc.~view遷移~treeを示すか:#document-show-view-transition-tree
doc.更新~callback~queue:#document-update-callback-queue
doc.決着するまで待機する~promise数:#document-wait-until-promise-count

el.作動中な~view遷移:#_element-active-view-transition
el.ある~view遷移~内に捕捉されたか:#captured-in-a-view-transition

捕捉された要素:#captured-element
cE.旧-画像:#captured-element-old-image
cE.旧-横幅:#captured-element-old-width
cE.旧-縦幅:#captured-element-old-height
cE.旧-変形:#captured-element-old-transform
cE.旧-書字~mode:#captured-element-old-writing-mode
cE.旧-方向:#captured-element-old-direction
cE.旧-~text方位:#captured-element-old-text-orientation
cE.旧-混色~mode:#captured-element-old-mix-blend-mode
cE.旧-後景~filter:#captured-element-old-backdrop-filter
cE.旧-色~scheme:#captured-element-old-color-scheme
cE.新-要素:#captured-element-new-element
cE.~style定義~群:#captured-element-style-definitions
cE.~group~keyframe群:#captured-element-group-keyframes
cE.~group~animation名~規則:#captured-element-group-animation-name-rule
cE.~group~style規則:#captured-element-group-styles-rule
cE.画像~pair隔離~規則:#captured-element-image-pair-isolation-rule
cE.画像~animation名~規則:#captured-element-image-animation-name-rule
cE.~class~list:#captured-element-class-list
cE.包含ng~group名:#captured-element-containing-group-name
cE.~snapshot包含塊からの変形:#captured-element-transform-from-snapshot-containing-block
cE.旧-~border幅:#captured-element-old-border-width

処理待ち遷移~演算を遂行する:#perform-pending-transition-operations
~view遷移を設定しておく:#setup-view-transition
~view遷移を作動化する:#activate-view-transition
旧-状態を捕捉する:#capture-the-old-state
新-状態を捕捉する:#capture-the-new-state
遷移~疑似要素たちを設定しておく:#setup-transition-pseudo-elements
更新~callbackを~callする:#call-the-update-callback
~view遷移を飛ばす:#skip-the-view-transition
飛ばされ:#skip-the-view-transition
画像を捕捉する:#capture-the-image
描画~特性を捕捉する:#capture-rendering-characteristics
遷移の完遂-を遅延する~promiseを追加する:#delay-finish-for-promise
遷移~frameを取扱う:#handle-transition-frame
疑似要素~styleを更新する:#update-pseudo-element-styles
~view遷移を~clearする:#clear-view-transition
~view遷移の~page可視性~変化-時の手続き:#view-transition-page-visibility-change-steps
更新~callbackを~scheduleする:#schedule-the-update-callback
更新~callback~queueを一掃する:#flush-the-update-callback-queue

~view遷移~params:#view-transition-params
doc.内へ来る~view遷移~params:#document-inbound-view-transition-params
doc.外へ出る~view遷移を起動できるか:#document-can-initiate-outbound-view-transition
vTP.有名~要素:#view-transition-params-named-elements
vTP.初期~snapshot包含塊~size:#view-transition-params-initial-snapshot-containing-block-size

内へ来る非同一-文書な~view遷移を解決する:#resolve-inbound-cross-document-view-transition
~view遷移~規則を解決する:#resolve-view-transition-rule
非同一-文書な~view遷移を設定しておく:#setup-cross-document-view-transition
~naviは非同一-文書な~view遷移を誘発し得るか？:#navigation-can-trigger-a-cross-document-view-transition
外へ出る遷移~用の~opt-in状態を更新する:#update-the-opt-in-state-for-outbound-transitions

文書~視野な~view遷移~group:#document-scoped-view-transition-group
最も近い包含ng~group名:#nearest-containing-group-name
使用~group名:#used-group-name
入子な~view遷移~groupの変形を調整する:#adjust-nested-view-transition-group-transform

~level 1:#biblio-css-view-transitions-1

	●用語（CSS

要素:#_element
	要素:~CSSDISP#elements
	要素:~CSS2J#element

~stylesheet:~CSSSNAPSHOT#style-sheet

~cascaded値:~CASCADE#cascaded-value
算出d値:~CASCADE#computed-value
使用~値:~CASCADE#used-value
~UA出自:~CASCADE#cascade-origin-ua

詳細度:~SELECTORS4#specificity
選択子:~SELECTORS4#selector
~class選択子:~SELECTORS4#class-selector
全称~選択子:~SELECTORS4#universal-selector
型~選択子:~SELECTORS4#type-selector
	https://drafts.csswg.org/selectors-3/#x
疑似要素:~SELECTORS4#pseudo-element
	疑似要素:~TR/CSS21/selector.html#x22
関数形~疑似要素:~SELECTORS4#functional-pseudo-element
出自の要素:~SELECTORS4#originating-element
出自の疑似要素:~SELECTORS4#originating-pseudo-element
最終的な出自の要素:~SELECTORS4#ultimate-originating-element

条件付き~group規則:~CSSCOND#conditional-group-rule
~tree視野な名前:~CSSSCOPING#css-tree-scoped-name
平坦~tree:~CSSSCOPING#flat-tree

~treeに留まる疑似要素:~CSSPSEUDO#tree-abiding

首要~box:~CSSDISP#principal-box
行内~box:~CSSDISP#inline-box
	~TR/CSS2/visuren.html#inline-boxes
包含塊:~CSSDISP#containing-block
初期~包含塊:~CSSDISP#initial-containing-block
置換され:~CSSDISP#replaced-element
置換d要素:~CSSDISP#replaced-element
根~要素:~CSSDISP#root-element

行l~box:~CSSINLINE#line-box
	~TR/CSS2/visuren.html#line-box

~border~box:~CSSBOX#border-box
内容~box:~CSSBOX#content-box

~animation:~WANIM#concept-animation
離散的:~WANIM#discrete
時列線:~WANIM#timeline
An.時列線:~WANIM#_animation-timeline
結付けられた効果:~WANIM#animation-associated-effect
文書~時列線:~WANIM#document-timeline
	属する時列線:~WANIM#timeline-associated-with-a-document
効果~target:~WANIM#keyframe-effect-effect-target
i.静止中:~WANIM#play-state-paused
i.稼働中:~WANIM#play-state-running
処理待ち~animation~event~queue:~WANIM#pending-animation-event-queue
再生-状態:~WANIM#animation-play-state
対応する~event~target:~WANIM#_event-target

~scroll駆動な~animation:~SCROLL-ANIM#scroll-driven-animations

~box断片:~CSSBREAK#box-fragment
	＠~CSSBREAK#fragment

~size:~SIZING#size

恒等~変形-関数:~TRANSFORM#identity-transform-function

~canvas背景:~CSSBG#canvas-background
~ink~overflow区画:~CSSOVERFLOW3#ink-overflow-region
~ink~overflow矩形:~CSSOVERFLOW3#ink-overflow-rectangle
~ink~overflow:~CSSOVERFLOW3#ink-overflow
~scrollbar側溝:~CSSOVERFLOW3#scrollbar-gutter

生来な寸法:~CSSIMAGE#natural-dimensions
生来な~size:~CSSIMAGE#natural-size
描画され:~CSSIMAGE4#element-not-rendered

内容を飛ばす:~CSSCONTAIN#skips-its-contents
	＠~CSSCONTAIN#skips-its-contents
要素~内容:~CSSCONTAIN#element-contents
~layout封込め:~CSSCONTAIN#layout-containment

上端~層:~CSSPOS4#document-top-layer
塗り順序:~CSSPOS4#painting-order
	塗り順序:~CSSWG/css2/#painting-order
絶対~位置決め包含塊:~CSSPOS#absolute-positioning-containing-block
固定d位置決め包含塊:~CSSPOS#fixed-positioning-containing-block
固定的に位置され:~CSSPOS#fixed-position

~layout表示域:~CSSOMVIEW#layout-viewport
~scrollされる~box:~CSSOMVIEW#scrolling-box
積層~文脈:~CSS2J#stacking-context
表示域:~CSS2J#viewport

	●用語（他
実装定義:~INFRA#implementation-defined
~list:~INFRA#list
付加する:~INFRA#list-append
~listから集合を作成する:~INFRA#set-create
	~clone:~INFRA#list-clone
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
~cloneする:~INFRA#list-clone
	~IN:~INFRA#list-contain
空にする:~INFRA#list-empty
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
有順序~map:~INFRA#ordered-map
map.~key群:~INFRA#map-getting-the-keys
map.値~群:~INFRA#map-getting-the-values
map.~cloneする:~INFRA#map-clone
~tuple:~INFRA#tuple
集合:~INFRA#ordered-set
	map.~EACH:~INFRA#map-iterate
	包含-:~INFRA#list-contain
	~Assert:~INFRA#assert
	~CONTINUE:~INFRA#iteration-continue
	~EACH:~INFRA#list-iterate
	~NEQ ε:~INFRA#map-exists

取得子~手続き:~WEBIDL#getter-steps
~method手続き:~WEBIDL#method-steps
~callback関数を呼出す:~WEBIDLjs#invoke-a-callback-function
新たな~obj:~WEBIDLjs#new
新たな~promise:~WEBIDLjs#a-new-promise
解決される~promise:~WEBIDLjs#a-promise-resolved-with
~promiseを解決する:~WEBIDLjs#resolve
~promiseに反応する:~WEBIDLjs#dfn-perform-steps-once-promise-is-settled
~promiseを却下する:~WEBIDLjs#reject
充足-時:~WEBIDLjs#upon-fulfillment
却下-時:~WEBIDLjs#upon-rejection
~promiseを取扱済みとして~markする:~WEBIDLjs#mark-a-promise-as-handled
取扱済みとして~markされ:~WEBIDLjs#mark-a-promise-as-handled
	コレ:~WEBIDL#this
eX.名前:~WEBIDL#domexception-name
例外:~WEBIDL#dfn-exception

文書:~DOM4#concept-document
~node文書:~DOM4#concept-node-document
~tree順序:~DOM4#concept-tree-order
根:~DOM4#concept-tree-root
親:~DOM4#concept-tree-parent
子:~DOM4#concept-tree-child
同胞:~DOM4#concept-tree-sibling
先祖:~DOM4#concept-tree-ancestor
広義-先祖:~DOM4#concept-tree-inclusive-ancestor
子孫:~DOM4#concept-tree-descendant
広義-子孫:~DOM4#concept-tree-inclusive-descendant
~shadowも含めた子孫:~DOM4#concept-shadow-including-descendant
文書~要素:~DOM4#document-element
doc.生成元:~DOM4#concept-document-origin
~class群:~DOM4#concept-class
~ID:~DOM4#concept-id
	子~群:~DOM4#concept-tree-child
~tree:~DOM4#concept-tree
関与-:~DOM4#concept-tree-participate
接続されて:~DOM4#connected


並列的:~HTMLINFRA#in-parallel

doc.非同一-生成元~redirectを介して作成されたか:~HTMLdom#was-created-via-cross-origin-redirects

doc.可視性~状態:~HTMLinteraction#visibility-state

同一-生成元:~ORIGIN#same-origin
生成元:~ORIGIN#concept-origin

全部的に作動中:~HTMLds#fully-active
~navigable:~HTMLds#navigable
nav.作動中な~window:~HTMLds#nav-window
子~navigable:~HTMLds#child-navigable

cnC.更新のみか:~HTMLnav#changing-nav-continuation-update-only
~BF~cache:~HTMLnav#_bf-cache
作動化し直され:~HTMLnav#reactivate-a-document
露呈され:~HTMLnav#reveal
~naviに対する利用者-関与i:~HTMLnav#user-navigation-involvement
i.~browser~UI:~HTMLnav#uni-browser-ui
doc.露呈されたか:~HTMLnav#has-been-revealed
最近の~entry:~HTMLnav#latest-entry

結付けられた文書:~WINDOW#concept-document-window

描画~機会:~WAPI#rendering-opportunity
~task:~WAPI#concept-task
大域~taskを~queueする:~WAPI#queue-a-global-task
関連な設定群~obj:~WAPI#relevant-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
関連な~realm:~WAPI#concept-relevant-realm
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability

行列:~GEOMETRY#matrix
乗算する:~GEOMETRY#multiply

所要時間:~HRTIME#dfn-duration

●●words_table1
SCROLL-ANIM:https://drafts.csswg.org/scroll-animations-1/
CSSVT1:https://drafts.csswg.org/css-view-transitions-1/
BQん:`
noneC:none
●●words_table

	●遷移／animation
静止-:pause::~
共存-:co-exist:~
静止中:paused::~
稼働中:running::~
再生-:play::~
新-:new:~
旧-:old:~
相:phase::~::フェーズ
捕捉-:capture::~
捕捉:capture::~
滑らか:smooth:~
cross-fade::::クロスフェード
	~cross-fade:crossfade
unload:
keyframe:
	~keyframe群:keyframes
切替わる:swapされる:切り替わる
	~view遷移:view-transition
	内へ来る:inbound
	外へ出る:outbound
	外へ出る~view遷移~用の:exiting
	内へ来る~view遷移~用の:entering
	~animateして:animating
	~animation:animating

	●layout／幾何
矩形:rectangle:~
幾何:geometry:~
幅:width::~
首要:principal::主要
固定d:fixed::固定
固定的:fixed::~
限界域:bounds:~
隅:corner:~
部位:portion:~
側溝:gutter::~


	●塗り／効果
積層:stacking::~
塗ng:painting:塗り
塗り:paint:~
塗る:paintする:~
塗られ:paintされ:~
ink:
切取っ:clipし::切り取っ
切取り:clipping::切り取り
切取られ:clipされ::切り取られ
	切取られたもの:clip
	その部分:the clipping
raster::::ラスター
	~raster化:rasterize
mask::::マスク
	~mask法:masking
cross-fade::::クロスフェード
覆う:coverする:~
縦横比:aspect ratio::~
品質:quality:~
後景:backdrop::~
	後景:back-drop
横:horizontal::~
縦:vertical::~
見かけ:look:~
描く:drawする:~
強調-:highlight:~
	視覚-化:visualization
混色:blend::~
混色-:blend::~
bitmap::::ビットマップ

	層を重ねる:layer on top of one another
	層の重ね方:layering
	上層:on top of

	●UI／呈示
sidebar::::サイドバー
接触判定:hit-testing::~
desktop::::デスクトップ
mobile::::モバイル
virtual-keyboard::::ソフトウエアキーボード
示す:showする:~
示して:showして:~
浮動-:float:~
素早く:quickに:~
遅く:slowに:~
	より遅く:slower
motion::::モーション
支援技術:assistive technology:~
明滅:flash:~
露呈-:reveal:露わに
bookmark::::ブックマーク
	~URL~bar:URL address bar
打込んだ:typeした:打ち込んだ
	%thumbnail:thumbnail
非可視:hidden:~
滑らす:slideする:~
滑らせ:slideさせ:~
drag::::ドラッグ
目障り:jarring:~
見出し:heading:~
揺れ:judder:~

	遠くへ:away
	消えたり:disappear
	現れな:appearしな
	“戻る” :back
	“新-” 状態が円形に広がる:create a circular reveal from
	~scrollbar:scroll bar
	離れて:away
	近い:close
	利用者~体験:UX
	示す:show
	押す:press
	“戻る”:back
	履歴を前後へ辿る:back/forward
	~scroll法:scrolling

	●CSS
CSSOM:
For:for:用途
詳細度:specificity::~
全称:universal:~
cascaded::::カスケード
視野な:scopedな::~
	視野な:-scoped
	視野~付き:scoped
	を視野に入れる:scoped to
	視野~法:scoping
選択-:select::~
書字:writing::~
出自の:originating::~
出自:origin::~
出自-:originate:出自に
関数形:functional:~
恒等:identity::~
生来:natural::~
封込め:containment::封じ込め

	~style法:styling
	`px^u :pixel

	●処理
lifecycle:
取扱済み:handled:取り扱い済み
schedule::::スケジュール
決着-:settle::~
切替えて:switchして:切り替えて
瞬時:instantaneous:~
片付けら:clean upさ:~
一掃-:flush::~
時間切れ:timeout::~
続行-:proceed:~
処理待ち:pending:~
為され:makeされ:~
params::::パラメタ群
安定:stable:~
	安定~化:stabilize
適格:eligible:~
	適格~性:eligibility
片付ける:clean-upする:~
	片付ける:cleanup
	片付けるため:cleaning up
復旧-:restore:~
修繕:fixup:~
修繕-:fix up:~
適時:timely:~
連結-:concatenate::~

	何もしない:no-op
	静止されなく:unpause
	設定しておく:set up
	補間-可能:interpolatable
	開始~時の:starting
	終了~時の:ending
	逆順に:out of sequence
	期間:period
	しつつ:about to
	時点:moment
	時点:point
	途中:in between
	始まり:begin
	始まる:begin
	同時に:at the same time
	時点:at the time
	〜間は:at any time
	経ていく:goes through
	読み戻される:read back
	直前:right before
	直前に:currently
	いつでも:At any given time
	順に経る:goes through
	経る:has
	以降:From this point forward
	渡した／渡す:pass
	~~処理され:seen
	同時に:simultaneously
	全体を通して:throughout the entire course of
	その場を占める:take place
	間際の:last minute
	まるごと:altogether
	設定しておく:setup
	具現化を阻む:render-blocking
	具現化を阻んで:render-blocking
	~~最新:up to date
	見つけられ:seen
	ときが来た:it’s time to
	再-作動化:reactivation
	-:accepting
	設定-法:setting up
	次回の:the next

	●変数
	%~view遷移:-
	%疑似要素:pseudo
	%新-要素:capturedElement
	%捕捉~要素~群:captureElements
	%有名~要素~群:namedElements
	%遷移~名~群:usedTransitionNames
	%捕捉:capture
	%元の矩形:originalRect
	%~group:group
	%画像~pair:imagePair
	%旧-:old
	%新-:new
	%新-矩形:newRect
	%横幅:width
	%縦幅:height
	%~callback~promise:callbackPromise
	%事由:reason
	%作動中な~animationはあるか:hasActiveAnimations
	%書字~mode:writingMode
	%方向:direction
	%~text方位:textOrientation
	%混色~mode:mixBlendMode
	%成否:-
	%結果:-
	%~animation群:-
	%~event:-
	%混色~mode:mixBlendMode
	%後景~filter:backdropFilter
	%色~scheme:colorScheme
	%充足-手続き:fulfillSteps
	%却下-手続き:rejectSteps
	%視野~付き~view遷移~名:scopedViewTransitionName
	%解決-済み規則:resolvedRule
	%~view遷移:viewTransition
	%外へ出る遷移:outboundTransition
	%~navi種別:navigationType
	%~browser~UIによる~naviか:isBrowserUINavigation
	%旧-文書:oldDocument
	%新-文書:newDocument
	%更新~callback:updateCallback
	%文書:document
	%~view遷移~params:viewTransitionParams
	%内へ来る~view遷移~params:inboundViewTransitionParams
	%~naviで続行する手続き:proceedWithNavigation
	%規則からの遷移~型~群:~transitionTypesFromRule
	%~token:-
	%変形:transform
	%変形:childrenTransform
	%子~群~変形:childrenTransform
	-:groupContainerElement
	%子~群~容器~group:childrenContainerGroup
	%先祖:nearestAncestorWithContain
	%先祖:-
	%捕捉:capturedElement
	-:capturedElement
	%捕捉された要素:capturedElement
	%遷移~名:transitionName
	%遷移:transition
	%包含ng~group名:containingGroupName
	%要素:element
	%算出d値:computed
	%算出d~group:computedGroup
	%~ID:-
	-:ancestorGroup
	%型~群:-
	%~promise:-
	%~promise:p


	●保安
脅威:threat:~
潜在的:potential:~
提起-:raise:~
安全性:safety:~
軽微:minor:~

	第三者-主体:3rd-party
	生じさせ:causing
	その場を占めて:taken place
	事実:fact
	ぼやかす:obfuscate
	これまで:so far

	●仕様
opt-in:
opt-out:
monkey:
patch::::パッチ
	~monkey~patch:monkey-patch
厄介:troublesome:~
規定-:dictate:~
理想的:ideal:~
馴染み:familiar:~
正当化-:justify:~
説明的:explanatory:~
増補:enhancement:~
心配-:worry:~
準拠-:comply:~
	準拠する:compliant
全体的:holistic:~
	より全体的に捉える:has a more holistic view
誤記:typo:~
実現可能:feasible:~
譲歩-:compromise:~
参照r:refer:参照
利用度:usage:~
保つ:keepする:~
保たれ:keepされ:~
併合-:merge:~
責務:responsibility:~
	責務〜ある:responsible
流儀:fashion:~
冗漫:verbose:~
普通は:ordinaryには:~
無視r:disregard:無視することに
競合-:conflict:~
偶発的:accidental:~

	要点:key part
	より高い~levelでは:at a higher level
	より高い:higher
	紛らわしくもなり得る:may be confusing
	必要yでない:not necessarily
	~view遷移^cite:View Transition
	選べる:chooseでき
	譲歩させられ:compromiseされ
	織り込む:account for
	事実:in fact,
	誤った環境設定:misconfiguration
	事前に判明した:it’s known in advance
	委ねる:left to
	だけ:alone
	まず:firstly
	真中:middle
	最も遠い:furthest
	前と同じ:the previous
	~custom化できる:customizations can be made
	通常でない:non-normal
	〜な限り:insofar as
	所までを除いて:insofar as
	ようになり得る:potentially
	すべて:everything
	左上:top left
	ときもある:sometimes
	問われない:does not matter
	場合もある:may
	はず:should
	あったとする:Taking 〜 already
	と称される:known as
	されないようにする／されなくなる:prevent
	判明した:it’s known
	担当しない:not responsible
	〜より〜見込みが高く:makes it likely to be
	が:despite
	事例によっては:not 〜 for all cases
	~~正しいとは言えない:not right
	~level 1:L1
	意図されない:unintended
	現時点では:at this point
	まずは:to begin with
	関わる:around
	^en:learn
	おかげで:thank
	書かれ:written
	熟した:graduate
	選んだ:chosen
	選ぶ:chooseする
	特定に:specifically
	~~便利:handy
	ようにするため:to make sure
	併せて:alongside
	はず:should be
	見られるとおり／に従って／倣い:as per
	勧める:advised
	足る:sufficient
	~prop:CSS property
	^en:mismatch
	まだこれから:TBD
	長々しく:tedious
	やめた:stop
	初期~仕様:Initial spec
	初期~仕様:First pass
	織り込む:fold
	〜が在る場合，:potentially

	●言い換え
	`文書$:Document
	`捕捉-待ち$i:"pending-capture"
	`更新~callbackは~call済み$i:"update-callback-called"
	`~animate中$i:"animating"
	`済み$i:"done"

	いつ:timing
	0.25 秒間の:quarter-second
	伴われる:featuring
	-:type
	~sidebarが内へ来る:entry
	~sidebarが外へ出る:exit
	全体の:things
	遷移-中な:transitional
	文書~要素:documentElement
	疑似要素~tree:pseudo-tree
	疑似要素:pseudo
	常に:not prevent
	その後:then
	決着するに伴い決着する:fulfill or reject along with
	~tag付け:tagging
	~textは変わらない:identical text
	上の例に引き続き、:Building on the previous example
	上の例から~~改めて、:Not building from previous examples this time
	先立つ:earlier
	~HTML:html
	重複している:duplicate
	重複して発火-:duplicate
	重複して発火-:provide 〜 duplicate
	発火させ:cause
	がその根になる:under a rooted
	^en:incoming
	^en:jump:#1
	^en:retarget:#1
	^en:texture read back in
	$v:plus-lighter
	^p:content-visibility
	併せた領域:union of 〜 with
	でも〜利用者~体験は壊れないよう:avoid a broken experience
	効率を高める:efficiency
	pull:PR
	文書$:Document
	要素$:Element
	~BF~cache:BFCache
	互いの~page間の~link:link from page 1 to or from page 2
	`遷移を飛ばす^i:`skip transition^l
	手続き %手続き に代えて，次を遂行する:Prepend a step at the beginning of
	^e:iframe
	^e:script
	^e:style
	^e:HTMLLinkElement
	`~view遷移^cite:View Transitions
	~level 1$:previously
	~level 1$:L1
	~level 1$:css-view-transitions-1
	~~本当は:in fact
	利用し過ぎる:overusing
	空白:white space
	真っ先に挙がる:most prominent
	ある先祖:ancestor chain
	新たな:In addition to the existing values
	次の~CSS:the next string
	の一覧:table of
	になれるよう:making it potentially
	ちょっとした:minor
	同一-文書:single-document
	同一-文書:single same-document

	●未分類
main::::メイン
集成:consolidation:~
構成-:compose:~
循環依存:circular dependency:~
超過-:exceed:~
余分:extra:~
component::::コンポーネント
映出す:mirrorする:映し出す
スマホ:phone:::~
実体:entity:~
再現-:replicate:~
入口:entry:~
出口:exit:~
選択的:selective::~
step:
set:
側:side:~
	側:-side
BF:
横取-:intercept:横取り
実数:number:~
為す:makeする:~
2D:
3D:
変形-:transform::~
変形:transform::~
並進-:translate::~
並進:translation::~
行列:matrix::~
逆-:inverse::~
	逆-行列:inverse matrix
包含ng:containing::包含
存続期間:lifetime:~
最近の:latest:~
同一性:identity:~
不可分:atomic::~

	最終的:ultimate
	対応-:correspond
	含め:including
	含む:include
	含まな:includeしな
	起こ:happen
	起き:happen
	~~保ちながら:without breaking
	残り:the rest
	無い:absent
	指す／指して:refer
	内／外:in or out
	の外:out of
	〜周り:around
	の下に:beneath 〜
	奥にある:beneath
	奥にある:underneath
	の下で:underneath
	少なくとも:at the very least
	広い:large
	~pairにされ:paired
	結局は〜になった:ends up becoming
	低-:low-
	現れる:appearする
	文書:Document
	残りの:remaining
	ある種の:certain
	より多く:more
	~~設置-:put
	来る:come
	~~地点:location
	後戻りする:back
	以外:apart from
	一箇所で:once
	全体:whole
	この時点で:now
	より大きい:greater than
	十分:enough
	失われ:lose
	崩れる:broken
	伴に:in conjuction with
	最も近い:nearest
	~EACH 〜 近いものから順に:nearest
	親を〜に~~改める:reparent
	まるごと:entirety
	紫色:purple

●●images
＠css-view-transitions/
phone-browser｜height:21em｜｜.svg
phone-browser-snapshot-root｜height:21em｜｜.svg
desktop-browser｜height:279px｜｜.svg
desktop-browser-snapshot-root｜height:279px｜｜.svg
phone-browser-with-url｜height:297px｜｜.svg
phone-browser-without-url｜height:297px｜｜.svg
phone-browser-scrolled-to-top-with-url｜height:297px｜｜.svg
phone-browser-scrolled-to-top-without-url｜height:297px｜｜.svg

●●ref_normative

[COMPOSITING-2]
    ＜Compositing and Blending Level 2＞. Editor's Draft. URL: https://drafts.fxtf.org/compositing-2/
[CSS-2025]
    Chris Lilley; et al. ＜CSS Snapshot 2025＞. URL: https://drafts.csswg.org/css-2025/
[CSS-ANIMATIONS-1]
    David Baron; et al. ＜CSS Animations Level 1＞. URL: https://drafts.csswg.org/css-animations/
[CSS-BACKGROUNDS-3]
    Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-BORDERS-4]
    Elika Etemad; et al. ＜CSS Borders and Box Decorations Module Level 4＞. URL: https://drafts.csswg.org/css-borders-4/
[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 4＞. URL: https://drafts.csswg.org/css-break-4/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-COLOR-4]
    Chris Lilley; Tab Atkins Jr.; Lea Verou. ＜CSS Color Module Level 4＞. URL: https://drafts.csswg.org/css-color-4/
[CSS-COLOR-ADJUST-1]
    Elika Etemad; et al. ＜CSS Color Adjustment Module Level 1＞. URL: https://drafts.csswg.org/css-color-adjust-1/
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. ＜CSS Containment Module Level 2＞. URL: https://drafts.csswg.org/css-contain-2/
[CSS-DISPLAY-4]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Display Module Level 4＞. URL: https://drafts.csswg.org/css-display-4/
[CSS-IMAGES-3]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. ＜CSS Images Module Level 3＞. URL: https://drafts.csswg.org/css-images-3/
[CSS-IMAGES-4]
    Elika Etemad; Tab Atkins Jr.; Lea Verou. ＜CSS Images Module Level 4＞. URL: https://drafts.csswg.org/css-images-4/
[CSS-MASKING-1]
    Dirk Schulze; Brian Birtles; Tab Atkins Jr.. ＜CSS Masking Module Level 1＞. URL: https://drafts.fxtf.org/css-masking-1/
[CSS-OVERFLOW-3]
    Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-POSITION-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 3＞. URL: https://drafts.csswg.org/css-position-3/
[CSS-POSITION-4]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 4＞. URL: https://drafts.csswg.org/css-position-4/
[CSS-PSEUDO-4]
    Elika Etemad; Alan Stearns. ＜CSS Pseudo-Elements Module Level 4＞. URL: https://drafts.csswg.org/css-pseudo-4/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. URL: https://drafts.csswg.org/css-scoping/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. URL: https://drafts.csswg.org/css-transforms/
[CSS-TRANSFORMS-2]
    Tab Atkins Jr.; et al. ＜CSS Transforms Module Level 2＞. URL: https://drafts.csswg.org/css-transforms-2/
[CSS-UI-4]
    Florian Rivoal. ＜CSS Basic User Interface Module Level 4＞. URL: https://drafts.csswg.org/css-ui-4/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-VIEW-TRANSITIONS-1]
    Tab Atkins Jr.; Jake Archibald; Khushal Sagar. ＜CSS View Transitions Module Level 1＞. URL: https://drafts.csswg.org/css-view-transitions-1/
[CSS-VIEWPORT-1]
    Florian Rivoal; Emilio Cobos Álvarez. ＜CSS Viewport Module Level 1＞. URL: https://drafts.csswg.org/css-viewport/
[CSS-WRITING-MODES-3]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 3＞. URL: https://drafts.csswg.org/css-writing-modes-3/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. URL: https://drafts.csswg.org/css-writing-modes-4/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[CSSOM-VIEW-1]
    Simon Fraser; Emilio Cobos Álvarez. ＜CSSOM View Module＞. URL: https://drafts.csswg.org/cssom-view/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[FILTER-EFFECTS-1]
    Dirk Schulze; Dean Jackson. ＜Filter Effects Module Level 1＞. URL: https://drafts.fxtf.org/filter-effects-1/
[FILTER-EFFECTS-2]
    ＜Filter Effects Module Level 2＞. Editor's Draft. URL: https://drafts.fxtf.org/filter-effects-2/
[GEOMETRY-1]
    Simon Pieters; Chris Harrelson. ＜Geometry Interfaces Module Level 1＞. URL: https://drafts.fxtf.org/geometry/
[HR-TIME-3]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[INTERSECTION-OBSERVER]
    Stefan Zager; Emilio Cobos Álvarez; Traian Captan. ＜Intersection Observer＞. URL: https://w3c.github.io/IntersectionObserver/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-3]
    Tantek Çelik; et al. ＜Selectors Level 3＞. URL: https://drafts.csswg.org/selectors-3/
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[WEB-ANIMATIONS-1]
    Brian Birtles; et al. ＜Web Animations＞. URL: https://drafts.csswg.org/web-animations-1/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-CONDITIONAL-3]
    Chris Lilley; David Baron; Elika Etemad. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/
[CSS-SHADOW-PARTS-1]
    Tab Atkins Jr.; Fergal Daly. ＜CSS Shadow Parts＞. URL: https://drafts.csswg.org/css-shadow-parts/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[POINTEREVENTS3]
    Patrick Lauke; Robert Flack. ＜Pointer Events＞. URL: https://w3c.github.io/pointerevents/
[SCROLL-ANIMATIONS-1]
    Brian Birtles; et al. ＜Scroll-driven Animations＞. URL: https://drafts.csswg.org/scroll-animations-1/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS View Transitions Module Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-view-transitions-2/
公表履歴
	https://www.w3.org/standards/history/css-view-transitions-2/
フィードバック
	https://github.com/w3c/csswg-drafts/labels/css-view-transitions-2
編集
	Noam Rosenthal (Google)
	Khushal Sagar (Google)
	Vladimir Levin (Google)
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-view-transitions-2/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-view-transitions-2
</script>

</head>
<body>
<template id="_persisted_parts">
<video
	id="_dgm-video-default"
	class="_example-video"
	controls loop muted playsinline
	preload="none"
	src="https://drafts.csswg.org/css-view-transitions-2/diagrams/videos/default.mp4"
></video>

<video
	id="_dgm-video-slow"
	class="_example-video"
	controls loop muted playsinline
	preload="none"
	src="https://drafts.csswg.org/css-view-transitions-2/diagrams/videos/slow.mp4"
></video>

<video
	id="_dgm-video-slide"
	class="_example-video"
	controls loop muted playsinline
	preload="none"
	src="https://drafts.csswg.org/css-view-transitions-2/diagrams/videos/slide.mp4"
></video>

<video
	id="_dgm-video-header"
	class="_example-video"
	controls loop muted playsinline
	preload="none"
	src="https://drafts.csswg.org/css-view-transitions-2/diagrams/videos/header.mp4"
></video>

<video
	id="_dgm-video-bad-sidebar"
	class="_example-video"
	controls loop muted playsinline
	preload="none"
	src="https://drafts.csswg.org/css-view-transitions-2/diagrams/videos/bad-sidebar.mp4"
></video>

<video
	id="_dgm-video-good-sidebar"
	class="_example-video"
	controls loop muted playsinline
	preload="none"
	src="https://drafts.csswg.org/css-view-transitions-2/diagrams/videos/good-sidebar.mp4"
></video>

<video
	id="_dgm-video-circle"
	class="_example-video"
	controls loop muted playsinline
	preload="none"
	src="https://drafts.csswg.org/css-view-transitions-2/diagrams/videos/circle.mp4"
></video>
</template>

<header>
	<hgroup>
<h1>CSS ビュー遷移 — CSS View Transitions Module Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この~moduleは、
`~view遷移^cite（ `View Transition^en ）~API,
それに結付けられる各種［
~prop, 疑似要素
］を定義する。
それは、
`~view遷移$
— 文書~状態における変化を~animateされる視覚的な遷移として表現するもの —
を作成することを開発者に許容する。
◎
This module defines the View Transition API, along with associated properties and pseudo-elements, which allows developers to create animated visual transitions representing changes in the document state.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
この仕様は、［
`~view遷移$を作成することを開発者に許容する
］ための［
~DOM~API, それに結付けられる~CSS特能
］を導入する。
`~view遷移@
（ `view transition^en ）とは、［
［
`文書$／`要素$
］を成す ある状態から異なる状態
］あるいは［
文書から同一-生成元な別個な文書
］へ~animateされる視覚的な遷移である。
◎
This specification introduces a DOM API and associated CSS features that allow developers to create animated visual transitions, called view transitions between different states of a document or an element, or between distinct same-origin documents.
</p>

		<section id="intro-l2">
<h3 title="Level 2 Updates">1.1. ~level 2 による更新</h3>

<p>
~level 2 は、
`CSS-VIEW-TRANSITIONS-1$r における~modelを拡張して，
次に挙げるものを定義する：
◎
Level 2 defines the following, extending the model in [CSS-VIEW-TRANSITIONS-1]:
</p>
<ul>
	<li>
`§ 非同一-文書な~view遷移＠#cross-document-view-transitions$
⇒
`view-transition$at 規則,
非同一-文書な~view遷移の~lifecycleを可能化する~algoなど。
◎
Cross-document view transitions, including the @view-transition rule and the algorithms that enable the cross-document view transition lifecycle.
</li>
	<li>
`§ 選択的な~view遷移＠#selective-vt$
⇒
~styleを［
`作動中な~view遷移$docの存在に基づいて照合する
］および［
ある種の型を成している作動中な~view遷移に基づいて，より特定に照合する
］ための仕方。
◎
Selective view transitions, a way to match styles based on the existence of an active view transition, and more specifically based on the active view transition being of a certain type.
</li>
	<li>
`§ ~view遷移~疑似要素たちの~styleの共有-法＠#shared-style-with-vt-classes$
⇒
~styleを一箇所で宣言して，それを複数の~view遷移~疑似要素で利用するための仕方。
これは、
`view-transition-class$p ~prop,
`§ 有名~疑似要素に対する追加＠#pseudo-element-class-additions$
も含む。
◎
Sharing styles between view transition pseudo-elements, a way to declare a style once, and use it for multiple view transition pseudo-elements. This includes the view-transition-class property, and additions to named pseudo-elements
</li>
	<li>
`§ 視野~付き~view遷移＠#scoped-vt$
⇒
~DOM下位treeが成す視野の中で~view遷移を遂行するための仕方。
◎
Scoped view transitions, a way to perform view transitions within the scope of a DOM subtree.
</li>
</ul>

		</section>
		<section id="separating-transitions">
<h3 title="Separating Visual Transitions from DOM Updates">1.2. ~DOM更新と視覚的な遷移の分離-法</h3>

<p>
伝統的に，
2 つの文書~状態の間で視覚的な遷移を作成することには、
~DOMにおいて両~状態が同時に在るような期間が要求されていた。
事実，それは、
通例的には，両~状態を表現し得る特有な~DOM構造を作成することを孕んでいた。
例えば，ある要素が容器から容器へ “移動する” 場合、
要素は，当の遷移を成す期間において［
どちらかの容器 または それらの先祖~要素【の限界域】で切取られるのを避ける
］ため［
両~容器の外側に存在する必要がある
］ことが多い。
◎
Traditionally, creating a visual transition between two document states required a period where both states were present in the DOM at the same time. In fact, it usually involved creating a specific DOM structure that could represent both states. For example, if one element was “moving” between containers, that element often needed to exist outside of either container for the period of the transition, to avoid clipping from either container or their ancestor elements.
</p>

<p>
この余分な途中-状態は、
利用者~体験と~accessibilityの課題になることが多い
— ~DOMを成す構造が，純粋に視覚的な効果~用に譲歩させられるので。
◎
This extra in-between state often resulted in UX and accessibility issues, as the structure of the DOM was compromised for a purely-visual effect.
</p>

<p>
`~view遷移$は、
次を許容することにより，この厄介な途中-状態を避ける：
~DOMを 2 つの状態の間で瞬時に切替えてから、
別の層において 2 つの状態の間で［
旧-状態を成す静的な視覚的な捕捉,
新-状態を成す~liveな捕捉
］を利用して，~custom化~可能な視覚的な遷移を遂行することにより。
これらの捕捉は、
`疑似要素$たちが成す~treeとして表現される
（詳細は、
`§ ~view遷移~用の疑似要素＠#view-transition-pseudos$にて）
— それは、［
旧-, 新-
］両~視覚的な状態が共存するようにして，［
~size, 位置
］を旧-から新-へ~animateしている間に［
~cross-fadeするなどの効果
］を許容する。
◎
View Transitions avoid this troublesome in-between state by allowing the DOM to switch between states instantaneously, then performing a customizable visual transition between the two states in another layer, using a static visual capture of the old state, and a live capture of the new state. These captures are represented as a tree of pseudo-elements (detailed in § 3.2 View Transition Pseudo-elements), where the old visual state co-exists with the new state, allowing effects such as cross-fading while animating from the old to new size and position.
</p>

		</section>
		<section id="customizing">
<h3 title="View Transition Customization">1.3. ~view遷移の~custom化</h3>

<p>
［
`Element$I の `startViewTransition()$m1 ／
`Document$I の `startViewTransition()$m
］は、
既定では，
`根~要素$vT全体に対する`~view遷移$を作成する
— この遷移は、
2 つの~DOM状態の間で~cross-fadeすることからなる。
◎
By default, element.startViewTransition() and document.startViewTransition() create a view transition consisting of a cross-fade of the entire root element between the two DOM states.
</p>

<p>
開発者は、
`view-transition-name$p ~CSS~propを利用して，代わりに［
どの子孫~要素が独立に捕捉されるか
］を選べる
— それは、
それらの要素が~pageを成す残りとは独立に~animateされることを許容する。
遷移-中な状態
（そこでは、旧-, 新- 両~視覚的な捕捉が存在する）
は，疑似要素たちとして表現されるので、
開発者は，馴染みな特能
— `~CSS~animation＠~CSSANIM$cite, `~Web~animation＠~WANIM$cite など —
を利用して各~遷移を~custom化できる。
◎
Developers can instead choose which descendant elements are captured independently using the view-transition-name CSS property, allowing these to be animated independently of the rest of the page. Since the transitional state (where both old and new visual captures exist) is represented as pseudo-elements, developers can customize each transition using familiar features such as CSS Animations and Web Animations.
</p>

		</section>
		<section id="lifecycle">
<h3 title="View Transition Lifecycle">1.4. ~view遷移の~lifecycle</h3>

<p>
成功裡な`~view遷移$は、
順に，次に挙げる相を経ていく：
◎
A successful view transition goes through the following phases:
</p>
<ol>
	<li>
開発者は、［
<code>document.`startViewTransition()$m</code> ／
<code>%element.`startViewTransition()$m1</code>
］を~callする
— それは、
ある `ViewTransition$I %~view遷移 を返す。
◎
Developer calls document.startViewTransition(updateCallback) or element.startViewTransition(updateCallback), which returns a ViewTransition, viewTransition.
</li>
	<li>
文書の現在の状態が “旧-” 状態として捕捉される。
◎
Current state captured as the “old” state.
</li>
	<li>
%~view遷移 の`根~要素$vTの中の描画は静止される。
◎
Rendering paused within the root element.
</li>
	<li>
`startViewTransition()^m の引数に `更新~callback$V が供されたならば，それが~callされる
— それが，文書~状態を更新する。
◎
Developer’s updateCallback function, if provided, is called, which updates the document state.
</li>
	<li>
%~view遷移 の `updateCallbackDone$m が充足される。
◎
viewTransition.updateCallbackDone fulfills.
</li>
	<li>
現在の状態が “新-” 状態 として捕捉される。
◎
Current state captured as the “new” state.
</li>
	<li>
遷移~疑似要素たちが作成される。
これらが成す構造の概観は、
`§ ~view遷移~用の疑似要素＠#view-transition-pseudos$
を見よ。
◎
Transition pseudo-elements created. See § 3.2 View Transition Pseudo-elements for an overview of this structure.
</li>
	<li>
描画は静止されなくなり，遷移~疑似要素が露呈される。
◎
Rendering unpaused, revealing the transition pseudo-elements.
</li>
	<li>
%~view遷移 の `ready$m が充足される。
◎
viewTransition.ready fulfills.
</li>
	<li>
完遂するまで，疑似要素たちを~animateする。
◎
Pseudo-elements animate until finished.
</li>
	<li>
遷移~疑似要素たちが除去される。
◎
Transition pseudo-elements removed.
</li>
	<li>
%~view遷移 の `finished$m が充足される。
◎
viewTransition.finished fulfills.
</li>
</ol>

<div id="_phases-diagram">
	<div id="_vt-slide">
		<div>
~main~DOM
			<div class="_vt-box">
<span class="_vt-phase _vt-state1" data-phases="1 2 3">状態 1</span>
<span class="_vt-phase _vt-state2" data-phases="4 5 6 7 8 9">状態 2</span>
			</div>
		</div>
		<div>
遷移~根
			<div class="_vt-box">
<span class="_vt-phase _vt-state1" data-phases="6 7">状態 1</span>
<span class="_vt-a1 _vt-phase _vt-state1" data-phases="8">状態 1</span>
<span class="_vt-a2 _vt-phase _vt-state2" data-phases="8">状態 2</span>
			</div>
		</div>
		<div>
利用者が見るもの
			<div class="_vt-box">
<span class="_vt-phase _vt-state1" data-phases="1 2 3 4 5 6 7">状態 1</span>
<span class="_vt-phase _vt-state2" data-phases="9">状態 2</span>
<span class="_vt-a1 _vt-phase _vt-state1" data-phases="8">状態 1</span>
<span class="_vt-a2 _vt-phase _vt-state2" data-phases="8">状態 2</span>
<div class="_vt-phase _vt-comment" data-phases="1 2">~main~DOM</div>
<div class="_vt-phase _vt-comment" data-phases="3 4 5 6">描画は静止される</div>
<div class="_vt-phase _vt-comment" data-phases="7 8">遷移~根</div>
<div class="_vt-phase _vt-comment" data-phases="9">~main~DOM</div>
			</div>
		</div>
	</div>
	<div>
<span class="_vt-phase" data-phases="1">1.
開発者は、 `document.startViewTransition()^c を~callする
【！Developer calls document.startViewTransition()】
</span>
<span class="_vt-phase" data-phases="2">2.
現在の状態が “旧-” 状態として捕捉される。
【！Current state captured as the "old" state】
</span>
<span class="_vt-phase" data-phases="3">3.
描画は静止される。
【！Rendering paused】
</span>
<span class="_vt-phase" data-phases="4">4.
開発者は文書~状態を更新する。
【！Developer updates document state】
</span>
<span class="_vt-phase" data-phases="5">6.
現在の状態が “新-” 状態 として捕捉される。
【！Current state captured as the "new" state】
</span>
<span class="_vt-phase" data-phases="6">7.
遷移~疑似要素たちが作成される。
【！Transition pseudo-elements created】
</span>
<span class="_vt-phase" data-phases="7">8.
描画は静止されなくなり，遷移~疑似要素が露呈される。
【！Rendering unpaused, revealing the transition pseudo-elements】
</span>
<span class="_vt-phase" data-phases="8">10.
疑似要素たちを~animateする。
【！Pseudo-elements animate】
</span>
<span class="_vt-phase" data-phases="9">11.
遷移~疑似要素たちが除去される。
【！Transition pseudo-elements removed】
</span>
	</div>
	<div>
<button id="_vt-buttons-prev">前</button>
<button id="_vt-buttons-next">次</button>
	</div>
</div>

		</section>
		<section id="transitions-as-enhancements">
<h3 title="Transitions as an enhancement">1.5. 増補としての遷移</h3>

<p>
`~view遷移^cite ~APIの設計においては、［
~animateされる遷移は、
下層の文書~状態~変化に対する視覚的な`増補^emである
］ことが要点を成す。
すなわち、
誤った環境設定や機器~拘束などに因り［
視覚的な遷移を作成することに失敗して、
遷移~animationは起こり得ないことが事前に判明した場合
］でも，開発者の `更新~callback$V【！ViewTransitionUpdateCallback】 は常に~callされる。
◎
A key part of the View Transition API design is that an animated transition is a visual enhancement to an underlying document state change. That means a failure to create a visual transition, which can happen due to misconfiguration or device constraints, will not prevent the developer’s ViewTransitionUpdateCallback being called, even if it’s known in advance that the transition animations cannot happen.
</p>

<p>
例えば，開発者が`~view遷移~lifecycle＠#lifecycle$の開始~時に
`skipTransition()$m を~callした場合、
~animateされる遷移に関係している段
— `~view遷移~tree$を作成するなど —
は起こらなくなる。
しかしながら，
`更新~callback$V 【！ViewTransitionUpdateCallback】 は依然として~callされる
— 飛ばされるのは、
下層の状態~変更ではなく，視覚的な遷移に限られる。
◎
For example, if the developer calls skipTransition() at the start of the view transition lifecycle, the steps relating to the animated transition, such as creating the view transition tree, will not happen. However, the ViewTransitionUpdateCallback will still be called. It’s only the visual transition that’s skipped, not the underlying state change.
</p>

<p class="note">注記：
~DOM変更も飛ばされるべきである場合、
別の特能により取扱われる必要がある。
`NavigateEvent$I の `signal$m は、
そのような特能の開発者が これを取扱うためにも利用できる例である。
◎
Note: If the DOM change should also be skipped, then that needs to be handled by another feature. navigateEvent.signal is an example of a feature developers could use to handle this.
</p>

<p>
`~view遷移^cite ~APIは、［
`更新~callback$V を介して，~DOMを非同期的に変更する
］ことを許容するが，~DOM変更を［
遷移~自身に必要な~schedule法
］を超えて［
~queueする／~scheduleする
］ことは担当しない。
非同期的な~DOM変更には、
同時並行に起こり得るものもあれば
（例：それらが独立な~componentの中で起きている場合），［
他を~queueする／先立つ変更を中止する
］必要があるものもある。
これは、
当の~appを より全体的に捉える［
特能／~framework
］に委ねるのが最善である。
◎
Although the View Transition API allows DOM changes to be asynchronous via the ViewTransitionUpdateCallback, the API is not responsible for queuing or otherwise scheduling DOM changes beyond any scheduling needed for the transition itself. Some asynchronous DOM changes can happen concurrently (e.g if they’re happening within independent components), whereas others need to queue, or abort an earlier change. This is best left to a feature or framework that has a more holistic view of the application.
</p>

		</section>
		<section id="rendering-model">
<h3 title="Rendering Model">1.6. 描画~model</h3>

<p>
`~view遷移^cite ~APIは、
~UAが生成した疑似要素を利用して，
所与の要素が描画された状態を【画像として】再現することにより働く。
［
要素, その子孫
］に適用される［
要素の描画を成す側面
］
— 例えば［
`filter$p や `opacity$p 様な視覚的な効果／
`overflow$p や `clip-path$p による切取り
］ —
は、
その`画像を捕捉する$中で画像を生成するときに適用される。
◎
View Transition works by replicating an element’s rendered state using UA generated pseudo-elements. Aspects of the element’s rendering which apply to the element itself or its descendants, for example visual effects like filter or opacity and clipping from overflow or clip-path, are applied when generating its image in Capture the image.
</p>

<p>
しかしながら，そのように生成される画像には、
`mix-blend-mode$p の様な［
要素が埋込まれたとき，それをどう描くかを定義する~prop
］は適用できない。
そのような~propは、
当の要素に対応している `view-transition-group()$pe 疑似要素
— 当の要素に等価な~boxを生成するよう意味された疑似要素 —
に適用される。
◎
However, properties like mix-blend-mode which define how the element draws when it is embedded can’t be applied to its image. Such properties are applied to the element’s corresponding ::view-transition-group() pseudo-element, which is meant to generate a box equivalent to the element.
</p>

<p>
`view-transition-group()$pe に対応している要素が “新-” 状態~内に在る場合、
~browserは、
“新-” 状態~内にある~DOM要素との同期cを保つよう，
各~propを `view-transition-group()^pe へ複製する。
`view-transition-group()^pe に対応している要素が “旧-”, “新-” 両~状態~内に在って，
複製された~propは補間-可能な場合、
~browserは，［
当の~propを滑らかに~animateするための既定の~animation
］も設定しておくことになる。
◎
If the ::view-transition-group() has a corresponding element in the "new" states, the browser keeps the properties copied over to the ::view-transition-group() in sync with the DOM element in the "new" state. If the ::view-transition-group() has corresponding elements both in the "old" and "new" state, and the property being copied is interpolatable, the browser also sets up a default animation to animate the property smoothly.
</p>

		</section>
		<section id="examples">
<h3 title="Examples">1.7. 例</h3>

<div class="example">
<p>
次の様な~patternを利用して，内容を更新する~pageがあったとする：
◎
Taking a page that already updates its content using a pattern like this:
</p>

<pre class="lang-js">
function spaNavigate(%data) {
  updateTheDOMSomehow(%data);
}
</pre>

<p>
それには、
次の様に`~view遷移$を追加することもできる：
◎
A view transition could be added like this:
</p>

<pre class="lang-js">
function spaNavigate(%data) {
  /* <span class="comment">
この~APIを~supportしない~browser用の~fallback：
◎
Fallback for browsers that don't support this API:
</span> */
  if (!document.startViewTransition) {
    updateTheDOMSomehow(%data);
    return;
  }

  /* <span class="comment">
遷移を伴わせる：
◎
With a transition:
</span> */
  document.startViewTransition(() =&gt; updateTheDOMSomehow(%data));
}
</pre>

<p>
結果は、
素早く~cross-fadeする，既定の遷移になる：
◎
This results in the default transition of a quick cross-fade:
</p>

<figure>`video-default^dgm
</figure>

<p>
この~cross-fadeは、
`疑似要素たちが成す~tree＠#view-transition-pseudos$上の~CSS~animationを利用して達成される。
なので、
~CSSを利用して~custom化できる。
例えば：
◎
The cross-fade is achieved using CSS animations on a tree of pseudo-elements, so customizations can be made using CSS. For example:
</p>

<pre class="lang-css">
::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 5s;
}
</pre>

<p>
その結果、
より遅く遷移するようになる：
◎
This results in a slower transition:
</p>

<figure>`video-slow^dgm
</figure>
</div>

<div class="example">
<p>
上の例に引き続き、
~motionを追加できる：
◎
Building on the previous example, motion can be added:
</p>

<pre class="lang-css">
@keyframes fade-in {
  from { opacity: 0; }
}

@keyframes fade-out {
  to { opacity: 0; }
}

@keyframes slide-from-right {
  from { transform: translateX(30px); }
}

@keyframes slide-to-left {
  to { transform: translateX(-30px); }
}

::view-transition-old(root) {
  animation: 90ms cubic-bezier(0.4, 0, 1, 1) both fade-out,
    300ms cubic-bezier(0.4, 0, 0.2, 1) both slide-to-left;
}

::view-transition-new(root) {
  animation: 210ms cubic-bezier(0, 0, 0.2, 1) 90ms both fade-in,
    300ms cubic-bezier(0.4, 0, 0.2, 1) both slide-from-right;
}
</pre>

<p>
その結果は：
◎
Here’s the result:
</p>
<figure>`video-slide^dgm
</figure>
</div>

<div class="example">
<p>
上の例による単純な “文書~一体な” 遷移では、
見出し~bar（紫色）内に可視な揺れが表示され，
見出し~textを常に左へ滑らせていた
— それが~page 1 から ~page 2 への遷移において右へ “移動していた” としても。
これらの課題を修正するためとして、
当の遷移~用に，［
~header, ~headerの中の~text
］に自前の `view-transition-group()$pe を与えれる：
◎
Building on the previous example, the simple "whole document" transition displayed a visible judder in the purple heading bar, and had the heading text always slide to the left even when it was "moving" to the right in the 1-&gt;2 transition. To fix these issues, the header and text within the header can be given their own ::view-transition-group()s for the transition:
</p>

<pre class="lang-css">
.main-header {
  view-transition-name: main-header;
}

.main-header-text {
  view-transition-name: main-header-text;
  /* <span class="comment">
要素の~sizeを一貫させる
— ~textは変わらないと見做して：
◎
Give the element a consistent size, assuming identical text:
</span> */
  width: fit-content;
}
</pre>

<p>
既定では、
これら各~groupの［
~size，位置
］は、
視覚的な状態が~cross-fadeする間に，
“旧-” 状態から “新-” 状態へ遷移することになる：
◎
By default, these groups will transition size and position from their “old” to “new” state, while their visual states cross-fade:
</p>

<figure>`video-header^dgm
</figure>
</div>

<div class="example">
<p>
上の例に引き続き、
一部の~pageには，~sidebarがあるとする：
◎
Building on the previous example, let’s say some pages have a sidebar:
</p>

<figure>`video-bad-sidebar^dgm
</figure>

<p>
この事例では、
~sidebarが［
“旧-”, “新-”
］両~状態~内にある場合は，
~sidebarは静的にした方が全体の見かけは良くなる。
他の場合，~sidebarは［
内／外
］へ~animateするべきである。
◎
In this case, things would look better if the sidebar was static if it was in both the “old” and “new” states. Otherwise, it should animate in or out.
</p>

<p>
`only-child$ps 疑似類を利用すれば、
これらの状態~用に特定的に~animationを作成できる：
◎
The :only-child pseudo-class can be used to create animations specifically for these states:
</p>

<pre class="lang-css">
.sidebar {
  view-transition-name: sidebar;
}

@keyframes slide-to-right {
  to { transform: translateX(30px); }
}

/* <span class="comment">
~sidebarが内へ来る遷移
◎
Entry transition
</span> */
::view-transition-new(sidebar):only-child {
  animation: 300ms cubic-bezier(0, 0, 0.2, 1) both fade-in,
    300ms cubic-bezier(0.4, 0, 0.2, 1) both slide-from-right;
}

/* <span class="comment">
~sidebarが外へ出る遷移
◎
Exit transition
</span> */
::view-transition-old(sidebar):only-child {
  animation: 150ms cubic-bezier(0.4, 0, 1, 1) both fade-out,
    300ms cubic-bezier(0.4, 0, 0.2, 1) both slide-to-right;
}
</pre>

<p>
既定の~animationは、［
~sidebarに “旧-”, “新-” 両~状態がある事例
］用には正しくなる。
◎
For cases where the sidebar has both an “old” and “new” state, the default animation is correct.
</p>

<figure>`video-good-sidebar^dgm
</figure>
</div>

<div class="example">
<p id="_example-5">
上の例から~~改めて、
利用者の~cursorを中心に “新-” 状態が円形に広がることが求まれたとする。
これは、
~CSSだけでは行えない。
◎
Not building from previous examples this time, let’s say we wanted to create a circular reveal from the user’s cursor. This can’t be done with CSS alone.
</p>

<p>
まず，~CSSにおいては、［
“旧-” 状態, “新-” 状態
］用の層を
— 既定の混色-法を伴わず，既定の~cross-fade~animationを防止する下で —
重ねることを許容する：
◎
Firstly, in the CSS, allow the “old” and “new” states to layer on top of one another without the default blending, and prevent the default cross-fade animation:
</p>

<pre class="lang-css">
::view-transition-image-pair(root) {
  isolation: auto;
}

::view-transition-old(root),
::view-transition-new(root) {
  animation: none;
  mix-blend-mode: normal;
}
</pre>

<p>
~JS~codeは：
◎
Then, the JavaScript:
</p>

<pre class="lang-js">
/* <span class="comment">
最後の~click~eventを格納する
◎
Store the last click event
</span> */
let %lastClick;
addEventListener('click', %event =&gt; (%lastClick = %event));

function spaNavigate(%data) {
  /* <span class="comment">
この~APIを~supportしない~browser用の~fallback：
◎
Fallback for browsers that don't support this API:
</span> */
  if (!document.startViewTransition) {
    updateTheDOMSomehow(%data);
    return;
  }

  /* <span class="comment">
~click位置を取得する
— できない場合、~screenの真中に~fall-backする：
◎
Get the click position, or fallback to the middle of the screen
</span> */
  const %x = %lastClick?.clientX ?? window.innerWidth / 2;
  const %y = %lastClick?.clientY ?? window.innerHeight / 2;
  /* <span class="comment">
最も遠い隅までの距離を取得する：
◎
Get the distance to the furthest corner
</span> */
  const %endRadius = Math.hypot(
    Math.max(%x, innerWidth - %x),
    Math.max(%y, innerHeight - %y)
  );

  /* <span class="comment">
遷移を作成する：
◎
Create a transition:
</span> */
  const %transition = document.startViewTransition(() =&gt; {
    updateTheDOMSomehow(%data);
  });

  /* <span class="comment">
疑似要素たちが作成されるまで待機する：
◎
Wait for the pseudo-elements to be created:
</span> */
  %transition.ready.then(() =&gt; {
    /* <span class="comment">
根の新たな~viewを~animateする：
◎
Animate the root's new view
</span> */
    document.documentElement.animate(
      {
        clipPath: [
          ``^`circle^(0 at ${%x}px ${%y}px)``^,
          ``^`circle^(${%endRadius}px at ${%x}px ${%y}px)``^,
        ],
      },
      {
        duration: 500,
        easing: 'ease-in',
        /* <span class="comment">
どの疑似要素を~animateするか指定する：
◎
Specify which pseudo-element to animate
</span> */
        pseudoElement: '::view-transition-new(root)',
      }
    );
  });
}
</pre>

<p>
その結果は：
◎
And here’s the result:
</p>

<figure>`video-circle^dgm
</figure>
</div>

		</section>
	</section>
	<section id="css-properties">
<h2 title="CSS properties">2. ~CSS~prop</h2>

		<section id="view-transition-name-prop">
<h3 title="Tagging Individually Transitioning Subtrees: the view-transition-name property">2.1. 個別に遷移している下位treeの~tag付け： `view-transition-name^p ~prop</h3>

<div>
◎名 `view-transition-name@p
◎値 `none$v | `custom-ident$t
◎初 `none^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終
◎
Name: 	view-transition-name
Value: 	none | &lt;custom-ident&gt;
Initial: 	none
Applies to: 	all elements
Inherited: 	no
Percentages: 	n/a
Computed value: 	as specified
Canonical order: 	per grammar
Animation type: 	discrete
</div>

<p class="note">注記：
`view-transition-name$p は`離散的$に~animate可能であるが、
~animateしても，稼働中な~view遷移には影響しない。
そうではなく、［
時間~越しに／`時列線$に基づいて
］変化し得る仕方で，その値を設定する仕方を与える。
例えば、
`~scroll駆動な~animation$に基づいて `view-transition-name$p を変更することに利用できよう。
◎
Note: though view-transition-name is discretely animatable, animating it doesn’t affect the running view transition. Rather, it’s a way to set its value in a way that can change over time or based on a timeline. An example for using this would be to change the view-transition-name based on scroll-driven animations.
</p>

<p>
`view-transition-name$p ~propは、
`~view遷移~内に捕捉され＠#captured-in-a-view-transition$た要素に対し，
指定された
`~view遷移~名@
の下で［
`~view遷移~tree$内で独立に追跡する
］ために， “~tag” を付与する。
捕捉された要素は、
当の~pageを成す残りとは独立に~animateされる。
◎
The view-transition-name property “tags” an element for capture in a view transition, tracking it independently in the view transition tree under the specified view transition name. An element so captured is animated independently of the rest of the page.
</p>

<dl class="valdef">
	<dt>`none@v</dt>
	<dd>
当の`要素$は、
~view遷移において独立に関与することはない。
◎
The element will not participate independently in a view transition.
</dd>

	<dt id="valdef-view-transition-name-custom-ident">`custom-ident$t</dt>
	<dd>
当の`要素$は、
~view遷移において，
指定された`~view遷移~名$を伴う［
旧-／新-
］`要素$として独立に関与する。
◎
The element participates independently in a view transition—as either an old or new element—with the specified view transition name.
</dd>
	<dd>
各`~view遷移~名$は、
`~tree視野な名前$である。
◎
Each view transition name is a tree-scoped name.
</dd>
	<dd>
この `custom-ident^t においては、
値［
`none^v, `auto^v, `match-element^v
］は除外される。
◎
The values none, auto, and match-element are excluded from &lt;custom-ident&gt; here.
</dd>
	<dd class="note">注記：
この名前が一意でない場合
（すなわち、
同じ `~view遷移~名$が複数の要素に同時に指定された場合）、
`~view遷移$は中止されることになる。
◎
Note: If this name is not unique (i.e. if two elements simultaneously specify the same view transition name) then the view transition will abort.
</dd>
</dl>

<p class="note">注記：
この~APIの目的においては、［
旧-状態~内にある要素, 新-状態~内にある別の要素
］に同じ`~view遷移~名$ `foo^v が付与された場合、
それらは［
同じ要素の異なる視覚-状態を表現している
］ものとして扱われ，`~view遷移~tree$内で~pairにされることになる。
それらの要素が同じ~objを指すことは必要yでないので，これは紛らわしくもなり得るが、
それらを［
同じ概念的な~page実体を成す，視覚的な状態
］であると見なすことは、
~modelとして有用になる。
◎
Note: For the purposes of this API, if one element has view transition name foo in the old state, and another element has view transition name foo in the new state, they are treated as representing different visual states of the same element, and will be paired in the view transition tree. This may be confusing, since the elements themselves are not necessarily referring to the same object, but it is a useful model to consider them to be visual states of the same conceptual page entity.
</p>

<p>
要素の`首要~box$が［
`断片化された＠~CSSBREAK#fragment$／
`飛ばされた＠~CSSCONTAIN#skips-its-contents$／
`描画され$ない
］場合、
この~propによる効果は無い。
正確な詳細は
`§ ~algo＠#algorithms$
を見よ。
◎
If the element’s principal box is fragmented, skipped, or not rendered, this property has no effect. See § 13 Algorithms for exact details.
</p>

<div class="algo">
<p>
所与の %要素【！`Element$I】 の
`文書~視野な~view遷移~名@
を取得するときは：
◎
To get the document-scoped view transition name for an Element element:
</p>
<ol>
	<li>
%視野~付き~view遷移~名 ~LET %要素 の `view-transition-name$p の`算出d値$
◎
Let scopedViewTransitionName be the computed value of view-transition-name for element.
</li>
	<li>
~RET ［
次が満たされるならば %視野~付き~view遷移~名 ／
~ELSE_ `none$v
］
⇒
［
%視野~付き~view遷移~名 ~NEQ `none$v
］~AND［
%視野~付き~view遷移~名 は %要素 の`~node文書$に結付けられている
【~shadow~treeではなく，~node文書に結付けられた`~tree視野な名前$である】
］
◎
If scopedViewTransitionName is associated with element’s node document, then return scopedViewTransitionName.
◎
Otherwise, return none.
</li>
</ol>
</div>

			<section id="named-and-transitioning">
<h4 title="Rendering Consolidation">2.1.1. 描画の集成</h4>

<p>
`要素$は、
~OR↓を満たす間は…
◎
Elements＼
</p>
<ul>
	<li>
`ある~view遷移~内に捕捉されたか$el ~EQ ~T
◎
captured in a view transition during a view transition＼
</li>
	<li>
`view-transition-name$p の`算出d値$ ~NEQ `none$v
◎
or whose view-transition-name computed value is not none＼
</li>
</ul>

<p>
…間は：
◎
(at any time):
</p>

<ul>
	<li>
`積層~文脈$を形成する。
◎
Form a stacking context.
</li>
	<li>
`~3D変形において平坦~化される＠~TRANSFORM2#grouping-property-values$。
◎
Are flattened in 3D transforms.
</li>
	<li>
`後景~根＠https://drafts.fxtf.org/filter-effects-2/#backdrop-root$を形成する。
◎
Form a backdrop root.
</li>
</ul>

			</section>
		</section>
		<section id="contain-view-transition">
<h3 title="Isolating Scoped View Transition Names: the view-transition containment value">2.2. 視野~付き~view遷移~名どうしの隔離-法： `view-transition^v 封込め値</h3>

◎名 `contain$p
◎新値 `view-transition$v
◎表終

<p>
`contain$p 用の値
`view-transition@v
は、
要素に対し，
`~view遷移~名~封込め@
を確立する。
これは、
所与の`文書~視野な~view遷移~名$が可視になる`~view遷移$は［
当の要素または そのいずれかの子孫
］を視野に入れるものに限るようにする。
◎
The contain: view-transition value establishes view transition name containment on an element. This causes any document-scoped view transition names to only be visible for view transitions scoped to this element or its descendants.
</p>

<p class="trans-note">【
この~keywordが `contain$p 用の構文において，どこに位置するかは、
指定されていない。
】【
“視野に入れる（ `scoped to^en ）” とは、
正確には何を意味する？
】</p>

<p class="note">注記：
`視野~付き~view遷移$を走らせているほとんどの要素は、
各自の`文書~視野な~view遷移~名$が他の`視野~付き~view遷移$に偶発的に干渉しないことを確保するため，`~view遷移~名~封込め$を利用するべきである。
さもなければ、
2 個の類似な要素
— 同じ`視野~付き~view遷移$を走らせていて，同じ名前【`~view遷移~名$】を伴う子孫を期待しているそれら —
は、
互いの名前が見えるので，中止されることになる
（`~view遷移$たちは、
複数の要素が同じ `view-transition-name$p を有することを許容しないので）。
◎
Note: Most elements running a scoped view transition should use view transition name containment, to ensure that their document-scoped view transition names don’t accidentally interfere with other scoped view transitions. Otherwise, two similar elements running the same scoped view transition, expecting the same-named descendants, will see each other’s names and abort (since view transitions don’t allow multiple elements to have the same view-transition-name).
</p>

		</section>
	</section>
	<section id="pseudo">
<h2 title="Pseudo-elements">3. 疑似要素</h2>

		<section id="pseudo-root">
<h3 title="Pseudo-element Trees">3.1. 疑似要素~tree</h3>

<p class="note">注記：
これは、
疑似要素たちが成す~tree用の一般な定義である。
他の特能にもこの挙動が必要になった場合、
これらの定義は `css-pseudo-4$r へ移動されることになる。
◎
Note: This is a general definition for trees of pseudo-elements. If other features need this behavior, these definitions will be moved to [css-pseudo-4].
</p>

<p>
`疑似要素~根@
とは、
`疑似要素~tree$における`根$を指す，`~treeに留まる疑似要素$である。
◎
A pseudo-element root is a type of tree-abiding pseudo-element that is the root in＼
</p>

<p>
`疑似要素~tree@
とは、
`~treeに留まる疑似要素$たちが成す`~tree$である。
◎
a tree of tree-abiding pseudo-elements, known as the pseudo-element tree.
</p>

<p>
`疑似要素~tree$は、
その`子孫$たちの文書~順序を定義する。
◎
The pseudo-element tree defines the document order of its descendant tree-abiding pseudo-elements.
</p>

<p>
`疑似要素$ %要素 が ある`疑似要素~tree$に`関与-$しているときは、
%要素 の`親$が %要素 の`出自の疑似要素$になる。
◎
When a pseudo-element participates in a pseudo-element tree, its originating pseudo-element is its parent.
</p>

<p>
`疑似要素~根$のある`子孫$ %疑似要素 に自身以外に`同胞$は無い場合、
`only-child$ps は， %疑似要素 に合致する。
◎
If a descendant pseudo of a pseudo-element root has no other siblings, then :only-child matches that pseudo.
</p>

<p class="note">注記：
このことは、
`::view-transition-new(ident):only-child^css が
`view-transition-new(ident)^pe を選択するのは、
親である `view-transition-image-pair(ident)^pe の`子$は 1 つしかない
— すなわち，`同胞$である `view-transition-old(ident)^pe は無い —
場合に限られることを意味する。
◎
Note: This means that ::view-transition-new(ident):only-child will only select ::view-transition-new(ident) if the parent ::view-transition-image-pair(ident) contains a single child. As in, there is no sibling ::view-transition-old(ident).
</p>

		</section>
		<section id="view-transition-pseudos">
<h3 title="View Transition Pseudo-elements">3.2. ~view遷移~用の疑似要素</h3>

<p>
`~view遷移$の視覚-化は、
`~view遷移~tree@
と呼ばれる`疑似要素~tree$として表現される
— この~treeは：
◎
The visualization of a view transition is represented as a pseudo-element tree called the view transition tree＼
</p>
<ul>
	<li>
以下に定義される
`~view遷移~疑似要素@
たちから構成される。
◎
composed of the view transition pseudo-elements defined below.＼
</li>
	<li>
`遷移~疑似要素たちを設定しておく$間に築かれる。
◎
This tree is built during the setup transition pseudo-elements step,＼
</li>
	<li>
その根は、
`view-transition$pe 疑似要素である。
◎
and is rooted under a ::view-transition pseudo-element＼
</li>
	<li>
その根の`出自の要素$は、
当の【`~view遷移$を表現する】 `ViewTransition$I の`根~要素$vTになる。
◎
originating from the ViewTransition’s root element.＼
</li>
	<li>
それを成す すべての`~view遷移~疑似要素$は、［
それらの`最終的な出自の要素$である，前項の根~要素
］から【下の例に述べられるとおり直に】選択される。
◎
All of the view transition pseudo-elements are selected from their ultimate originating element, the ViewTransition’s root element.
</li>
	<li>
~accessibility~treeには公開されない。
◎
The view transition tree is not exposed to the accessibility tree.
</li>
</ul>

<div class="example">
<p>
例えば、
ある `view-transition-group()$pe 疑似要素が~style付けと~layoutの目的で，
その親 `view-transition$pe 疑似要素の下で入子にされていても、
それは，当の `ViewTransition$I を~hostしている要素~上で直に選択される
— 作者は、
`.foo::view-transition^css を利用する場合には，
`.foo::view-transition-group()^css も利用することになる
— `.foo::view-transition::view-transition-group()^css は、
不正であり，何も選択されないことになる。
◎
For example, even though a ::view-transition-group() pseudo-element is nested underneath its parent ::view-transition pseudo-element for styling and layout purposes, it’s selected directly on the element hosting the ViewTransition: if you’d use .foo::view-transition, you’ll also use .foo::view-transition-group().
◎
Doing .foo::view-transition::view-transition-group() is incorrect, and won’t select anything.
</p>
</div>

<div class="note">
<p>注記：
~UAは、
文書の “旧-”, “新-” 両~状態を捕捉したなら，
次の様な疑似要素たちが成す構造を作成する：
◎
Once the user-agent has captured both the “old” and “new” states of the document, it creates a structure of pseudo-elements like the following:
</p>

<pre class="presentation">
::view-transition
├─ ::view-transition-group(%name)
│  └─ ::view-transition-image-pair(%name)
│     ├─ ::view-transition-old(%name)
│     └─ ::view-transition-new(%name)
└─ …他の~groupたち…
</pre>

<p>
`view-transition-name$p を伴う各~要素は、
別々に捕捉され，
各~一意な `view-transition-name$p 用に `view-transition-group()$pe が作成される。
◎
Each element with a view-transition-name is captured separately, and a ::view-transition-group() is created for each unique view-transition-name.
</p>

<p>
`文書~要素$には、
`~UA~stylesheet＠#ua-styles$内で，
`view-transition-name$p として `root^v が便利~用に与えられる。
◎
For convenience, the document element is given the view-transition-name "root" in the user-agent style sheet.
</p>

<p>
［
“旧-” ／ “新-”
］状態~内に捕捉が無い事例では、［
`view-transition-old()$pe ／ `view-transition-new()$pe
］も無い。
◎
Either ::view-transition-old() or ::view-transition-new() are absent in cases where the capture does not have an “old” or “new” state.
</p>

<p>
生成された各~疑似要素に対しては、
~CSSにより，その［
外観／挙動
］を~custom化でき, ~animationを追加できる。
これは、
遷移に対する全部的な~custom化を可能化する。
◎
Each of the pseudo-elements generated can be targeted by CSS in order to customize its appearance, behavior and/or add animations. This enables full customization of the transition.
</p>
</div>

			<section id="named-view-transition-pseudo">
<h4 title="Named View Transition Pseudo-elements">3.2.1. 有名~view遷移~疑似要素</h4>

<p>
`~view遷移~疑似要素$のうちいくつかは、
`有名~view遷移~疑似要素@
でもある
— それは、
`~treeに留まる疑似要素$であり，
ある`~view遷移~名$が結付けられる。
◎
Several of the view transition pseudo-elements are named view transition pseudo-elements, which are functional tree-abiding view transition pseudo-elements associated with a view transition name.＼
</p>

<p>
`選択子$としての`~view遷移~疑似要素$は、
`関数形~疑似要素$であり，
その構文は次の~patternに従う
【すなわち，名前を成す %pseudo は可変】：
◎
These pseudo-elements take a &lt;pt-name-selector&gt; as their argument, and their syntax follows the pattern:
</p>

<pre class="prod">
::view-transition-%pseudo(`pt-name-selector$t)
</pre>

<p>
引数 `pt-name-selector$t は、
ある`~view遷移~名$を選択する。
その構文は、
次で定義される：
◎
where &lt;pt-name-selector&gt; selects a view transition name, and has the following syntax definition:
</p>

<pre class="prod">
`pt-name-selector@t
	= '*'
	| `custom-ident$t
</pre>

<p>
`選択子$としての`有名~view遷移~疑似要素$は、
対応している`疑似要素$
【すなわち，`~view遷移~tree$内に生成される同じ名前の疑似要素】
のうち，
`pt-name-selector$t に応じて
⇒＃
`*^v ならば どれにも合致する。
`custom-ident$t ならば，それと同じ`~view遷移~名$を伴うものに限り合致する。
◎
A named view transition pseudo-element selector only matches a corresponding pseudo-element if its &lt;pt-name-selector&gt; matches that pseudo-element’s view transition name, i.e. if it is either * or a matching &lt;custom-ident&gt;.
</p>

<p class="note">注記：
`~view遷移~疑似要素$の`~view遷移~名$は、
その作成を誘発した `view-transition-name$p の値に設定される。
◎
Note: The view transition name of a view transition pseudo-element is set to the view-transition-name that triggered its creation.
</p>

<p>
`選択子$としての`有名~view遷移~疑似要素$の`詳細度$は、
その引数に応じて
⇒＃
`custom-ident$t をとる場合，`型~選択子$と等価【(0, 0, 1)】になるとする。
`*^v をとる場合， 0 【(0, 0, 0)】になるとする。
◎
The specificity of a named view transition pseudo-element selector with a &lt;custom-ident&gt; argument is equivalent to a type selector. The specificity of a named view transition pseudo-element selector with a * argument is zero.
</p>

			</section>
			<section id="view-transition-pseudo">
<h4 title="View Transition Tree Root: the ::view-transition pseudo-element">3.2.2. ~view遷移~tree根： `view-transition^pe 疑似要素</h4>

<p>
`view-transition@pe
`疑似要素$は：
◎
The ::view-transition pseudo-element＼
</p>
<ul>
	<li>
`~treeに留まる疑似要素$である。
◎
is a tree-abiding pseudo-element＼
</li>
	<li>
`疑似要素~根$である。
◎
that is also a pseudo-element root.＼
</li>
	<li>
その`出自の要素$は、
当の文書の`文書~要素$である。
◎
Its originating element is the document’s document element,＼
</li>
	<li>
その`包含塊$は、
`~snapshot包含塊$である。
◎
and its containing block is the snapshot containing block.
</li>
</ul>

<p class="note">注記：
この要素は、
すべての `view-transition-group()$pe 疑似要素の`親$として~serveする。
◎
Note: This element serves as the parent of all ::view-transition-group() pseudo-elements.
</p>

			</section>
			<section id="::view-transition-group">
<h4 title="View Transition Named Subtree Root: the ::view-transition-group() pseudo-element">3.2.3. ~view遷移~有名~下位tree根： `view-transition-group()^pe 疑似要素</h4>

<p>
`view-transition-group()@pe
`疑似要素$は：
◎
The ::view-transition-group() pseudo-element＼
</p>
<ul>
	<li>
`有名~view遷移~疑似要素$である。
◎
is a named view transition pseudo-element＼
</li>
	<li>
引数に合致している有名`~view遷移$の捕捉を表現する。
◎
that represents a matching named view transition capture.＼
</li>
	<li>
各`~view遷移~名$用に `view-transition$pe `疑似要素$の`子$として生成される。
◎
A ::view-transition-group() pseudo-element is generated for each view transition name as a child of the ::view-transition pseudo-element,＼
</li>
	<li>
対応している `view-transition-image-pair()$pe を包含する。
◎
and contains a corresponding ::view-transition-image-pair().
</li>
</ul>

<div class="note">
<p>注記：
この要素は、
初期~時は，
“旧-” 要素は［
在るならば それ／
無いならば “新-” 要素
］の［
~size, 位置
］を映出す。
◎
This element initially mirrors the size and position of the “old” element, or the “new” element if there isn’t an “old” element.
</p>

<p>
要素~用に “旧-”, “新-” 両~状態が在る場合、
`動的な~view遷移~stylesheet$doc内の~styleは，この疑似要素の［
`width$p, `height$p
］を［
旧-要素の`~border~box$の~size
］から［
新-要素の`~border~box$の~size
］へ~animateする。
◎
If there’s both an “old” and “new” state, styles in the dynamic view transition style sheet animate this pseudo-element’s width and height from the size of the old element’s border box to that of the new element’s border box.
</p>

<p>
要素の `transform$p は、
旧-要素の~screen空間~変形から
新-要素の~screen空間~変形へ~animateされる。
◎
Also the element’s transform is animated from the old element’s screen space transform to the new element’s screen space transform.
</p>

<p>
この~styleは、
~animateされる~propたちの値が遷移が始まる時点に決定されてから，
動的に生成される。
◎
This style is generated dynamically since the values of animated properties are determined at the time that the transition begins.
</p>
</div>

			</section>
			<section id="::view-transition-image-pair">
<h4 title="View Transition Image Pair Isolation: the ::view-transition-image-pair() pseudo-element">3.2.4. ~view遷移~画像~pair隔離： `view-transition-image-pair()^pe 疑似要素</h4>

<p>
`view-transition-image-pair()@pe
`疑似要素$は：
◎
The ::view-transition-image-pair() pseudo-element＼
</p>
<ul>
	<li>
`有名~view遷移~疑似要素$である。
◎
is a named view transition pseudo-element＼
</li>
	<li>
対応している［
旧-, 新-
］`~view遷移$の捕捉が成す~pairを表現する。
◎
that represents a pair of corresponding old/new view transition captures.＼
</li>
	<li>
対応している `view-transition-group()$pe 疑似要素の`子$である
◎
This pseudo-element is a child of the corresponding ::view-transition-group() pseudo-element and＼
</li>
	<li>
対応している［
`view-transition-old()$pe ／
`view-transition-new()$pe 
］疑似要素を（挙げられた順序で）包含する。
◎
contains a corresponding ::view-transition-old() pseudo-element and/or a corresponding ::view-transition-new() pseudo-element (in that order).
</li>
</ul>

<div class="note">
<p>注記：
この要素は、
各~子~用に
<code class="css">`isolation$p: `isolate^v</code>
を供するために存在する。
この要素は、
各 `view-transition-group()$pe の`子$として，常に在る。
この隔離（ `isolation^en ）は、
当の画像~pairが［
他の視覚的な出力に影響することなく，
通常でない混色-~mode
【 `normal^v 以外の `blend-mode$t 】
で混色される
］ことを許容する。
◎
This element exists to provide isolation: isolate for its children, and is always present as a child of each ::view-transition-group(). This isolation allows the image pair to be blended with non-normal blend modes without affecting other visual outputs.＼
</p>

<p>
そのようなわけで，開発者は、
概して，
`view-transition-image-pair()$pe 疑似要素に~customな~styleを追加する必要は無い。
代わりに，代表的な設計は、
次に挙げる疑似要素の~style付けを孕むことになろう
⇒＃
`view-transition-group()$pe,
`view-transition-old()$pe,
`view-transition-new()$pe
◎
As such, the developer would typically not need to add custom styles to the ::view-transition-image-pair() pseudo-element. Instead, a typical design would involve styling the ::view-transition-group(), ::view-transition-old(), and ::view-transition-new() pseudo-elements.
</p>
</div>

			</section>
			<section id="::view-transition-old">
<h4 title="View Transition Old State Image: the ::view-transition-old() pseudo-element">3.2.5. ~view遷移の旧-状態~画像： `view-transition-old()^pe 疑似要素</h4>

<p>
`view-transition-old()@pe
`疑似要素$は、
空な`有名~view遷移~疑似要素$であり，
“旧-” 状態を成す視覚的~snapshotを`置換d要素$として表現する
— 表現する “旧-” 状態が無い場合、
それは，省略される。
各 `view-transition-old()$pe 疑似要素には、
その`子$として，
対応する `view-transition-image-pair()$pe 疑似要素が在る。
◎
The ::view-transition-old() pseudo-element is an empty named view transition pseudo-element that represents a visual snapshot of the “old” state as a replaced element; it is omitted if there’s no “old” state to represent. Each ::view-transition-old() pseudo-element is a child of the corresponding ::view-transition-image-pair() pseudo-element.
</p>

<div class="note">
<p>注記：
`only-child$ps を［
この要素が `view-transition-image-pair()$pe 内の唯一の要素である事例
］で合致する選択子として利用できる。
◎
:only-child can be used to match cases where this element is the only element in the ::view-transition-image-pair().
</p>

<p>
この要素の外観は、
`object-*^p ~propにより，他の置換d要素と同じ仕方で操作できる。
◎
The appearance of this element can be manipulated with object-* properties in the same way that other replaced elements can be.
</p>
</div>

<p class="note">注記：
画像の［
内容, `生来な寸法$
］は
⇒＃
`画像を捕捉する$ときに捕捉される。
`遷移~疑似要素たちを設定しておく$ときに設定される。
◎
Note: The content and natural dimensions of the image are captured in capture the image, and set in setup transition pseudo-elements.
</p>

<p class="note">注記：
これらの疑似要素を~animateするための~styleは、
`動的な~view遷移~stylesheet$docに追加される。
詳細は、［
`遷移~疑似要素たちを設定しておく$／
`疑似要素~styleを更新する$
］にて。
◎
Note: Additional styles in the dynamic view transition style sheet added to animate these pseudo-elements are detailed in setup transition pseudo-elements and update pseudo-element styles.
</p>

			</section>
			<section id="::view-transition-new">
<h4 title="View Transition New State Image: the ::view-transition-new() pseudo-element">3.2.6. ~view遷移の新-状態~画像： `view-transition-new()^pe 疑似要素</h4>

<p>
`view-transition-new()@pe
`疑似要素$は、
（ `view-transition-old()$pe 疑似要素と相似的に）
空な`有名~view遷移~疑似要素$であり，
“新-” 状態を成す視覚的~snapshotを`置換d要素$として表現する
— 表現する “新-” 状態が無い場合、
各 `view-transition-new()$pe 疑似要素には、
その`子$として対応する `view-transition-image-pair()$pe 疑似要素が在る。
◎
The ::view-transition-new() pseudo-element (like the analogous ::view-transition-old() pseudo-element) is an empty named view transition pseudo-element that represents a visual snapshot of the “new” state as a replaced element; it is omitted if there’s no “new” state to represent. Each ::view-transition-new() pseudo-element is a child of the corresponding ::view-transition-image-pair() pseudo-element.
</p>

<p class="note">注記：
画像の［
内容, `生来な寸法$
］は
⇒＃
`画像を捕捉する$ときに捕捉される。
`遷移~疑似要素たちを設定しておく$ときに設定される。
`疑似要素~styleを更新する$ときに更新される。
◎
Note: The content and natural dimensions of the image are captured in capture the image, then set and updated in setup transition pseudo-elements and update pseudo-element styles.
</p>

			</section>
		</section>
	</section>
	<section id="scoped-vt">
<h2 title="Scoped View Transitions">4. 視野~付き~view遷移</h2>

<p>
`大域的な~view遷移@
— `文書$に対し誘発される`~view遷移$ —
に加えて，
個々の`要素$も自前の
`視野~付き~view遷移@
を~hostできる。
これは、
同じ~page上で複数の`~view遷移$を同時に走らすことを可能化する
— それぞれが当の文書を成す異なる下位treeを~animateするよう。
それは、
各`~view遷移$が各自の下位treeの~layoutと描画
— ［
~scroll法, ~filter, `z-index$p, 等々
］により影響されているそれら —
により影響されるようになることも可能化する
（ “大域的” な`~view遷移$は、
常に，当の文書を成す残りより高い別々な描画~層に描画される。）
◎
In addition to view transitions triggered on the document itself (global view transitions), individual elements can host their own scoped view transitions. This enables multiple view transitions to run on a page at the same time, with each animating a different subtree of the document. It also enables a view transition to be affected by the layout and rendering of its subtree, being affected by scrolling, filters, z-index, etc. ("Global" view transitions are always rendered on a separate, higher rendering layer than the rest of the document.)
</p>

<p>
要素が`視野~付き~view遷移$を~hostするためには、
それにより塗られた出力を不可分な単位として捕捉できるよう，
`~layout封込め$を有していなければならない。
◎
In order to host a scoped view transition, an element must have layout containment, so its painted output can be captured as an atomic unit.
</p>

<p>
`~view遷移$の`根~要素$vTは`文書~要素$である場合、
それは`大域的な~view遷移$であり，`視野~付き~view遷移$では`ない^em。
◎
View transitions whose root element is the document element are not scoped view transitions. They’re global view transitions.
</p>

	</section>
	<section id="view-transition-rendering">
<h2 title="View Transition Layout">5. ~view遷移の~layout</h2>

<p>
`~view遷移~疑似要素$は、
通常の要素と同様に，
~styleされ, ~lay-outされ, 描画される。
`大域的な~view遷移$は、
`初期~包含塊$ではなく`~snapshot包含塊$内から出自することに加え，
当の文書を成す残りより上にある`~view遷移~層$内に塗られる。
`視野~付き~view遷移$は、
単純に［
その`根~要素$vTの他のすべての子より後, かつ それらの上
］に描画される。
◎
The view transition pseudo-elements are styled, laid out, and rendered like normal elements. Global view transitions originate in the snapshot containing block rather than the initial containing block and are painted in the view transition layer above the rest of the document; scoped view transitions are simply rendered after and above all other children of their root element.
</p>

		<section id="snapshot-containing-block-concept">
<h3 title="The Snapshot Containing Block">5.1. ~snapshot包含塊</h3>

<p>
`~snapshot包含塊@
は、［
~UIwindowを成す~page内容を表示するようになり得るもの
］が成す すべての区画を覆う矩形であり，
（したがって［
根~scrollbarや
`ヤリトリありな~widget＠https://drafts.csswg.org/css-viewport/#interactive-widget$
］に関わらず一貫する）。
これにより、
`文書~要素$の［
`旧-画像$cE, `新-要素$cE
］が一貫する見込みが高くなる。
◎
The snapshot containing block is a rectangle that covers all areas of the window that could potentially display page content (and is therefore consistent regardless of root scrollbars or interactive widgets). This makes it likely to be consistent for the document element’s old image and new element.
</p>

<p>
`子~navigable$の中の`~snapshot包含塊$は、
当の~navigableの`表示域$に`~scrollbar側溝$（もしあれば）を併せた領域になる。
◎
Within a child navigable, the snapshot containing block is the union of the navigable’s viewport with any scrollbar gutters.
</p>

<figure>
<div class="side-by-side">
<p class="alt" hidden id="_dgm-phone-browser">
あるスマホ~screenを成す図式。
上端に 状態s~bar,
その下に ~browserの~URL~bar，
下端に ~OS “戻る” ~buttonを伴う~barがある。
それらの合間を~web内容~用の区画が占めていて，［
浮動している~scrollbar,
~virtual-keyboard
］を伴う。
◎
A diagram of a phone screen, including a top status bar, a browser URL bar, web-content area with a floating scrollbar, a virtual keyboard, and a bottom bar with an OS back button＼
</p>
<p class="alt" hidden id="_dgm-phone-browser-snapshot-root">
前と同じ図式だが、
~snapshot包含塊を成す区画が強調されている
— それは、［
上端にある状態s~bar,
下端にある~OS “戻る” ~buttonを伴う~bar
］を除く，すべてを含む。
◎
The previous diagram, but highlights the area that's the 'snapshot containing block', which includes everything except the top status bar and the bottom bar with the OS back button
</p>
</div>

<figcaption>
ある~mobile~OS上の`~snapshot包含塊$を成す例。
［
~URL~bar, ~keyboard
］は、
この包含塊に含まれる
— ［
前者は，遠くへ~scrollされ得る／
後者は，現れたり消えたりする
］ので。
［
上端, 下端
］にある~barは、
~browserではなく~OSの一部を成すので，
この包含塊には含まれない。
◎
An example of the snapshot containing block on a mobile OS. The snapshot includes the URL bar, as this can be scrolled away. The keyboard is included as this appears and disappears. The top and bottom bars are part of the OS rather than the browser, so they’re not included in the snapshot containing block.
</figcaption></figure>

<figure>
<div class="side-by-side">
<p class="alt" hidden id="_dgm-desktop-browser">
ある~desktop~browserの~UIwindowを成す図式。
上端には~UItab~bar，
その下に~browserの~URL~barがある。
それらの下を~web内容~区画が占めていて，［
横, 縦
］~scrollbarも伴われる。
◎
A diagram of a desktop browser window, including a tab bar, a URL bar, and a web-content area featuring both horizontal and vertical scrollbars
</p>
<p class="alt" hidden id="_dgm-desktop-browser-snapshot-root">
前と同じ図式だが、
~snapshot包含塊が成す区画が強調されている
— それは、
~web内容~区画と両~scrollbarを含んでいる。
◎
The previous diagram, but highlights the area that's the 'snapshot containing block', which includes the web content area and the scrollbars
</p>
</div>

<figcaption>
ある~desktop~OS上の`~snapshot包含塊$を成す例。
これは，［
横, 縦
］~scrollbarを含むが、
~URL~barを含まない
— その区画~内には~web内容は決して現れないので。
◎
An example of the snapshot containing block on a desktop OS. This includes the scrollbars, but does not include the URL bar, as web content never appears in that area.
</figcaption></figure>

<p>
`~snapshot包含塊の原点@
は、
`~snapshot包含塊$の左上~隅を指す。
◎
The snapshot containing block origin refers to the top-left corner of the snapshot containing block.
</p>

<p>
`~snapshot包含塊の~size@
は、
`~snapshot包含塊$の［
横幅, 縦幅
］を順に与える，
2 個の実数が成す`~tuple$。
◎
The snapshot containing block size refers to the width and height of the snapshot containing block as a tuple of two numbers.
</p>

<p>
`~snapshot包含塊$は、［
`view-transition$pe, その各~子孫
］用の［
`絶対~位置決め包含塊$,
`固定d位置決め包含塊$
］を与えるものと見なされる。
◎
The snapshot containing block is considered to be an absolute positioning containing block and a fixed positioning containing block for ::view-transition and its descendants.
</p>

		</section>
		<section id="view-transition-stacking-layer">
<h3 title="View Transition Painting Order">5.2. ~view遷移における塗ng順序</h3>

<p>
この仕様は、
`CSS2$r `§ 積層~文脈の詳しい記述＠~CSS22/zindex.html#elaborate-stacking-contexts$
にて確立される塗ng順序の終端に，
新たな積層~層として`~view遷移~層$を導入する。
◎
This specification introduces a new stacking layer, the view transition layer, to the end of the painting order established in CSS2§E Elaborate Description of Stacking Contexts. [CSS2]
</p>

<p class="issue">
これを `CSS-POSITION-4$r の中へ織り込む
— `上端~層$との相互作用を指定する必要があるので。
◎
Fold this into [CSS-POSITION-4], as the interaction with top layers needs to be specified.
</p>

<p>
`view-transition$pe 疑似要素は、
`大域的な~view遷移$用には，
`~view遷移~層@
と呼ばれる新たな積層~文脈を生成する。
それは、
文書を成す他のすべての内容（`上端~層$内に描画される内容も含む）より後に塗られる
— そのような内容に適用された~filterその他の効果があれば，それらより後に。
（それは、
そのような効果の~subjectにならない
— 効果は、［［
`view-transition-old()$pe, `view-transition-new()$pe
］疑似要素を成す描画される内容
］に影響する所までに限られる。）
◎
For a global view transition, the ::view-transition pseudo-element generates a new stacking context, called the view transition layer, which paints after all other content of the document (including any content rendered in the top layer), after any filters and effects that are applied to such content. (It is not subject to such filters or effects, except insofar as they affect the rendered contents of the ::view-transition-old() and ::view-transition-new() pseudo-elements.)
</p>

<p class="note">注記：
この特能の意図は、
~pageを成す内容を［
上端~層~内の要素を含めて捕捉-可能にする
］ことにある。
それを成遂げるため、
`~view遷移~層$は，捕捉された積層~文脈の一部を成し得ない
— そうすると循環依存になるので。
したがって、
`~view遷移~層$は，他のすべての内容の同胞になる。
◎
Note: The intent of the feature is to be able to capture the contents of the page, which includes the top layer elements. In order to accomplish that, the view transition layer cannot be a part of the captured stacking contexts, since that results in a circular dependency. Therefore, the view transition layer is a sibling of all other content.
</p>

<p>
［
`文書$ %文書 にて`作動中な~view遷移$docの`相$vT ~EQ `~animate中$i
］の間は、［
%文書 内の要素のうち`~view遷移~内に捕捉され＠#captured-in-a-view-transition$たもの
］により生成される~box，および その`要素~内容$は、
`遷移~根~疑似要素$vTの`広義-子孫$を除いて
⇒＃
塗られない（要素の `visibility$p は `hidden^v であったかのように）／
接触判定に応答しない（要素の `pointer-events$p は `none^v であったかのように）
◎
When a Document’s active view transition’s phase is "animating", the boxes generated by any element in that Document with captured in a view transition and its element contents, except transition root pseudo-element’s inclusive descendants, are not painted (as if they had visibility: hidden) and do not respond to hit-testing (as if they had pointer-events: none).
</p>

<p class="note">注記：
遷移に関与している要素は、
その~DOM内での所在における塗ngを飛ばす必要がある
— それらの画像は、
代わりに，対応している `view-transition-new()$pe 疑似要素~内に塗られるので。
類似に，接触判定も飛ばされる
— 要素の~DOM内での所在は、
その内容が描画される所には対応しないので。
しかしながら、
これらの要素が［
支援技術／~accessibility~tree
］により どう~accessされるかは変化しない。
◎
Note: Elements participating in a transition need to skip painting in their DOM location because their image is painted in the corresponding ::view-transition-new() pseudo-element instead. Similarly, hit-testing is skipped because the element’s DOM location does not correspond to where its contents are rendered. However, there is no change in how these elements are accessed by assistive technologies or the accessibility tree.
</p>

		</section>
	</section>
	<section id="ua-styles">
<h2 title="User Agent Stylesheet">6.~UA~stylesheet</h2>

<p>
`大域的な~view遷移~UA~stylesheet@
は、
`~UA出自$に属する~stylesheetであり，次の規則を包含する：
◎
The global view transition user agent style sheet is a user-agent origin style sheet containing the following rules:
</p>

<pre class="lang-css">
:root {
  view-transition-name: root;
}

:root::view-transition {
  position: fixed;
  inset: 0;
}

:root::view-transition-group(*) {
  position: absolute;
  top: 0;
  left: 0;

  animation-duration: 0.25s;
  animation-fill-mode: both;
}

:root::view-transition-image-pair(*) {
  position: absolute;
  inset: 0;
}

:root::view-transition-old(*),
:root::view-transition-new(*) {
  position: absolute;
  inset-block-start: 0;
  inline-size: 100%;
  block-size: auto;
}

:root::view-transition-image-pair(*),
:root::view-transition-old(*),
:root::view-transition-new(*) {
  animation-duration: inherit;
  animation-fill-mode: inherit;
  animation-delay: inherit;
  animation-timing-function: inherit;
  animation-iteration-count: inherit;
  animation-direction: inherit;
  animation-play-state: inherit;
}

:root::view-transition-group-children(*) {
  position: absolute;
  inset: 0;
  border-style: solid;
  border-color: transparent;
}

/* <span class="comment">
既定の~cross-fade遷移
◎
Default cross-fade transition
</span> */
@keyframes -ua-view-transition-fade-out {
  to { opacity: 0; }
}
@keyframes -ua-view-transition-fade-in {
  from { opacity: 0; }
}

/* <span class="comment">
【新-, 旧-】2 つの画像が在るとき，それらを混色するための~keyframe
◎
Keyframes for blending when there are 2 images
</span> */
@keyframes -ua-mix-blend-mode-plus-lighter {
  from { mix-blend-mode: plus-lighter }
  to { mix-blend-mode: plus-lighter }
}
</pre>
<details class="note">
<summary>
説明的な要約
◎
Explanatory Summary
</summary>
<p>
この~UA~stylesheetは、
次に挙げるものを行う：
◎
This UA style sheet does several things:
</p>
<ul>
	<li>
`view-transition$pe を`~snapshot包含塊$全体を覆うように~lay-outする
— 各~子である `view-transition-group()^pe【！:view-transition-group()】を，
それに相対的に~lay-outできるよう。
◎
Lay out ::view-transition to cover the entire snapshot containing block so that each :view-transition-group() child can lay out relative to it.
</li>
	<li>
`根~要素$に既定の`~view遷移~名$を与える
— それが独立に選択されることを許容するため。
◎
Give the root element a default view transition name, to allow it to be independently selected.
</li>
	<li>
`view-transition-image-pair()$pe 疑似要素による~layoutに対する干渉を抑制する
— ほとんどの目的において、
作者が［
`view-transition-old()$pe ／ `view-transition-new()$pe
］を本質的に `view-transition-group()$pe の直な子として扱えるよう。
◎
Reduce layout interference from the ::view-transition-image-pair() pseudo-element so that authors can essentially treat ::view-transition-old() and ::view-transition-new() as direct children of ::view-transition-group() for most purposes.
</li>
	<li>
~treeを通して，~animation計時を継承する
— 既定では、
`view-transition-group()$pe に設定された~animation計時が，
すべての子孫の~animation計時を規定することになるよう。
◎
Inherit animation timing through the tree so that by default, the animation timing set on a ::view-transition-group() will dictate the animation timing of all its descendants.
</li>
	<li>
要素の各~捕捉［
`view-transition-old()$pe,
`view-transition-new()$pe
］を~styleする
— それらを補間するに伴い，
`view-transition-group()$pe に設定された［
~size, 位置
］に合致するよう
（アリな限り，それらの縦横比を~~保ちながら）。
これらの要素の~sizingは［
論理-~prop, 物理-~prop
］による座標どうしの対応付けに依存するので、
`動的な~view遷移~stylesheet$docは，
~DOM要素たちから関連な~styleを複製する。
◎
Style the element captures ::view-transition-old() and ::view-transition-new() to match the size and position set on ::view-transition-group() (insofar as possible without breaking their aspect ratios) as it interpolates between them. Since the sizing of these elements depends on the mapping between logical and physical coordinates, dynamic view transition style sheet copies relevant styles from the DOM elements.
</li>
	<li>
各 `view-transition-group()$pe 用に，
既定の［
0.25 秒間の~cross-fade~animation
］を設定しておく。
◎
Set up a default quarter-second cross-fade animation for each ::view-transition-group().
</li>
</ul>
</details>

<p>
追加的な~styleは、
`~view遷移$の間に，`動的な~view遷移~stylesheet$docを通して`~UA出自$に動的に追加される。
◎
Additional styles are dynamically added to the user-agent origin during a view transition through the dynamic view transition style sheet.
</p>

	</section>
	<section id="cross-document-view-transitions">
<h2 title="Cross-document view transitions">7. 非同一-文書な~view遷移</h2>

		<section id="cross-doc-overview">
<h3 title="Overview">7.1. 概観</h3>

◎非規範的

			<section id="activating-cross-document-view-transition">
<h4 title="Activation">7.1.1. 作動化</h4>

<p>
同一-文書な~view遷移では、
作者は，~JSを利用して
— `startViewTransition()$m を~callすることにより —
~view遷移を開始する。
非同一-文書な~view遷移において，~view遷移を誘発するものは、
文書から他の文書への~naviである
— ~AND↓ が満たされる限り：
◎
With same-document view transitions, the author starts a view transition using JavaScript, by calling startViewTransition. In cross-document view transition, what triggers a view transition is a navigation between two documents, as long as the following conditions are met:
</p>
<ul>
	<li>
双方の文書は`同一-生成元$である。
◎
Both documents are of the same origin;
</li>
	<li>
当の~pageは、
当の~navi全体を通して可視である。
◎
The page is visible throughout the entire course of the navigation;
</li>
	<li>
当の~naviは、
利用者が［
当の~pageとヤリトリする
（例：~linkを~clickする／~formを提出する）／
`traverse$l する（履歴を前後へ辿る）ために~browser~UIとヤリトリする
］ことにより起動された。
これには、
例えば，~URL~barにより起動される~navi
【言い換えれば、新-文書への~naviは旧-文書とは独立に起動されたとき】
は除外される。
◎
The user initiates the navigation by interacting with the page, e.g. by clicking a link or submitting a form; or by interacting with the browser UI to do a traverse navigation (back/forward). This excludes, for example, navigations initiated by the URL bar;
</li>
	<li>
当の~naviには非同一-生成元な~redirectは生じなかった。
◎
the navigation didn’t include cross-origin redirects; and
</li>
	<li>
両~文書とも、
`view-transition$at 規則を利用して，
非同一-文書な~view遷移を~opt-inした。
◎
both documents opted in to cross-document view transitions, using the @view-transition rule.
</li>
</ul>

<p>
より詳細は、
`§ ~lifecycle＠#cross-doc-lifecycle$【！#lifecycle】
を見よ。
◎
See the lifecycle section for more details.
</p>

			</section>
			<section id="waiting-for-stable-state">
<h4 title="Waiting for the new state to stabilize">7.1.2. 新-状態が安定~化するまでの待機-法</h4>

<p>
同一-文書な~view遷移においては、
作者は，
当の遷移の新-状態が いつ安定~状態になるかを
— `startViewTransition()$m に渡した~callback利用することにより —
指示できる。
非同一-文書な~view遷移は，宣言的なので、
そのような明示的な~promiseは無い。
代わりに，~UAは、［
当の文書がいつ安定~状態に達したか
］を`具現化を阻む仕組み＠~HTMLdom#render-blocking-mechanism$に依拠して裁定する。
この仕方においては、
作者は，当の遷移を次に挙げるときまで
— そこに挙げるものを利用することにより —
遅延できる：
◎
In same-document view transitions, the author can indicate when the new state of the transition is in a stable state by using the callback passed to startViewTransition. Since cross-document view transitions are declarative, there is no such explicit promise. Instead, the user agent relies on the render-blocking mechanism to decide when the document has reached a stable state. In this way, the author can use the blocking attribute, to delay the transition until:
</p>
<ul>
	<li>
期待されるすべての~scriptは、
実行された
⇒
該当する各 `script$e 要素の `blocking$a 属性
◎
All expected scripts are executed, by using the script’s blocking attribute on required scripts.
</li>
	<li>
期待されるすべての~styleは、
実行された
⇒
該当する各 `style$e 要素の `blocking$aL 属性
◎
All expected styles are executed, by using the style or link’s blocking attribute on required styles.
</li>
	<li>
期待されるすべての~HTML要素は、
構文解析器により~~処理された
⇒
`link$e 要素の【 `rel^a 属性~用の~keyword】 `expect$v
◎
All expected HTML elements are seen by the parser, using an expect HTMLLinkElement element.
</li>
</ul>

<p class="note">注記：
具現化を阻む仕組みを利用し過ぎると、
旧-状態が長い時間~凍結され続ける結果，目障りな利用者~体験にもなり得る。
これを避けるためには、［
具現化を阻んでいる要素が適時な方式で可用になる
］ことを確保することを勧める。
◎
Note: overusing the render-blocking mechanism could make it so that the old state remains frozen for a long time, resulting in a jarring user experience. To avoid this, it’s advised to ensure that the render-blocking elements are available in a timely manner.
</p>

<div class="example">
<p>
この例では、
旧-文書の最後の~frameが示されてから，
~AND↓ が満たされるまで~animationは遅延されることになる：
◎
In this example, the last frame of the old document will be shown, and the animation will be delayed, until all the following conditions are met:
</p>

<ul>
	<li>
~stylesheet `style.css^v は適用された
— 新-状態が正しい~styleを有することを確保するため
◎
style.css is applied, to ensure the new state has the correct styles
</li>
	<li>
~script `fixup.js^v は走った
— 当の呈示が，それに基づく修繕に伴って~~最新になることを確保するため。
◎
fixup.js is run, to ensure the presentation is up to date with script-based fixups.
</li>
	<li>
要素 `main-article^v は、
見つけられ, 構文解析された
— 当の遷移を続行する前に，十分な内容が読込まれることを確保するため。
◎
The main-article section is seen and parsed, to ensure enough of the content is loaded before allowing the transition to proceed.
</li>
</ul>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!-- <span class="comment">
次の~stylesheetは、
既定では具現化を阻むことになる：
◎
This will be render-blocking by default
</span> --&gt;
    &lt;link rel="stylesheet" href="style.css"&gt;

    &lt;!-- <span class="comment">
次の~scriptは、
~layoutを修繕する。
それは、
【 `blocking^a 属性により】具現化を阻むものとして~markされ、
その結果，~view遷移が作動化される前に走ることが確保される：
◎
Since this script fixes up the layout, marking it as render blocking will ensure it's run before the view transition is activated
</span> --&gt;
    &lt;script async href="fixup.js" blocking="render"&gt;&lt;/script&gt;

    &lt;!-- <span class="comment">
遷移を作動化する前に，
`main-article^v 要素が見つけられ, 全部的に構文解析されるまで待機するようにする：
◎
Wait until the main-article element is seen and fully parsed before activating the transition
</span> --&gt;
    &lt;link rel="expect" href="#main-article" blocking="render"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;header&gt;...&lt;/header&gt;
    &lt;main&gt;
      &lt;article id="main-article"&gt;...&lt;/article&gt;
    &lt;/main&gt;
    &lt;article id="secondary-article"&gt;...&lt;/article&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

			</section>
			<section id="customizing-cross-document-view-transitions">
<h4 title="Customization">7.1.3. ~custom化</h4>

<p>
`ViewTransition$I ~objは、
~scriptにより遷移を~custom化することを可能化する。
~view遷移の~lifecycle全体にわたって利用される `ViewTransition$I ~objは、
同一-文書な~view遷移~用には `startViewTransition()$m の~callから返された 1 個だけであり，
非同一-文書な~view遷移~用には 2 個
— 旧-文書~内のそれ, 新-文書~内のそれ —
ある。
◎
The ViewTransition object enables customizing the transition in script. Same-document view transitions use a single ViewTransition object returned from the startViewTransition call for the entire lifecycle. Cross-document view transitions have two ViewTransition objects, one in the old document and one in the new document.
</p>

				<section id="old-doc-event">
<h5 title="Handling the view transition in the old document">7.1.3.1. 旧-文書における~view遷移の取扱い</h5>

<p>
`pageswap$et ~eventは、［
文書が~unloadされつつあり，別の文書に切替わる前
］における最後の時点に発火される。
それ【を表現する `PageSwapEvent$I ~obj】は、［
当の~view遷移が その場を占めつつあるかどうかを見出す
］ために利用でき，
当の~view遷移に対し次を行うためにも利用できる
⇒＃
`types$m を利用して~custom化する／
【`有名~要素~群$vTを成す】`捕捉された要素$たちに対し間際の変更を為す／
必要yなら飛ばす
◎
The pageswap event is fired at the last moment before a document is about to be unloaded and swapped by another document. It can be used to＼
find out whether a view transition is about to take place,＼
customize it using types,＼
make last minute changes to the captured elements,＼
or skip it if necessary.＼
</p>

<div>
<p>
`PageSwapEvent$I ~interfaceの：
</p>
<ul>
	<li>
`viewTransition$m1 は、
当の~naviが~view遷移に適格なときには ~NULL 以外になり，
`ViewTransition$I ~objを返す。
その~objの `finished$m ~promiseは、
当の文書が後で`~BF~cache$から復旧される事例において，
遷移の後に片付けるために利用できる。
</li>
	<li>
`activation$m は、
~redirect後の~URLの様な，当の~naviについての~~便利な情報を供する~objを返す。
</li>
</ul>
◎
The PageSwapEvent interface has a viewTransition object, which would be non-null when the navigation is eligible to a view transition, and a activation object, providing handy information about the navigation, like the URL after redirects. The transition’s finished promise can be used for cleaning up after the transition, in case the document is later restored from BFCache.
</div>

				</section>
				<section id="new-doc-event">
<h5 title="Handling the view transition in the new document">7.1.3.2. 新-文書における~view遷移の取扱い</h5>

<p>
`pagereveal$et ~eventは、［
新-文書を成す最初の~frameを呈示する直前
］に発火される。
それ【を表現する `PageRevealEvent$I ~obj】は、
`viewTransition$m 属性を~queryすることにより，［
当の~view遷移は依然として妥当であるか否か
］を見出すために利用できる。
同一-文書な~view遷移と類似に、
この時点で作者は，当の~view遷移に対し次を行うためにも
それ【~queryして返された `ViewTransition$I ~obj】を利用できる
⇒＃
異なる `types$m を選定する／
【`有名~要素~群$vTを成す】`捕捉された要素$たちに対し間際の変更を為す／
それを~animateするために それが準備済みになる（ `ready$m ~promiseが解決される）まで待機する／
まるごと飛ばす
◎
The pagereveal event is fired right before presenting the first frame of the new document. It can be used to find out if the view transition is still valid, by querying the viewTransition attribute. Similar to a same-document view transition, the author can now＼
select different types,＼
make last minute changes to the captured elements,＼
wait for the transition to be ready in order to animate it,＼
or skip it altogether.
</p>

				</section>
			</section>
			<section id="cross-doc-lifecycle">
<h4 title="Lifecycle">7.1.4. ~lifecycle</h4>

◎非規範的

<p>
`文書$ %旧-文書 から`文書$ %新-文書 への成功裡な［
非同一-文書な~view遷移
］は、
次に挙げる相を順に経る：
◎
A successful cross-document view transition goes through the following phases:
</p>

<ol>
	<li>
<p>
%旧-文書 においては：
◎
In the old Document:
</p>
		<ol>
			<li>
<p>
利用者は、［
~linkを~clickする／
~formを提出する／
~browserの “戻る” ~buttonを押す
］などにより，~naviを起動する。
◎
The user initiates a navigation, by clicking a link, submitting a form, pressing the browser’s back button, etc.
</p>

<p class="note">注記：
~naviには，~view遷移を誘発しないものもある
— 例：~URL~bar内に新たな~addressを打込んだとき。
◎
Note: some navigations do not trigger a view-transition, e.g. typing a new address in the URL bar.
</p>
			</li>
			<li>
%新-文書 は作動化されるに準備済みになったとき、
【 %旧-文書 に向けて】
`pageswap$et ~event %~event が発火される。
◎
When the new Document is ready to be activated, the pageswap event is fired.
</li>
			<li>
%~event の `viewTransition$m1 属性は、
次が満たされるならば `ViewTransition$I ~obj %遷移 になる
⇒
［
当の~naviは`同一-生成元$である
］~AND［
非同一-生成元な~redirectは無い
］~AND［
%旧-文書 は`非同一-文書な~view遷移を~opt-inした＠#cross-doc-opt-in$
］
◎
If the navigation is same origin, has no cross-origin redirects, and the old Document has opted in to cross-document view transitions, the event’s viewTransition attribute would be a ViewTransition object.
</li>
			<li>
作者は、
今や， %遷移 を~custom化できる
（例：
`types$m を用いて %遷移 にて`作動中な型~群$vTを変異させる／
`skipTransition()$m を用いて %遷移 を まるごと飛ばす）。
◎
The author can now customize the transition, e.g. by mutating its types, or skip it altogether.
</li>
			<li>
%遷移 が飛ばされなかった場合、
%旧-文書 の`状態が捕捉される＠#capture-the-old-state$。
◎
If the ViewTransition is not skipped, the state of the old document is captured.
</li>
			<li>
当の~naviを続行する
— %旧-文書 が~unloadされ，
%新-文書 が今や作動中になる。
◎
The navigation proceeds: the old Document is unloaded, and the new Document is now active.
</li>
		</ol>
	</li>
	<li>
<p>
次に，
%新-文書 においては：
◎
Then, in the new Document:
</p>
		<ol>
			<li>
%新-文書 が最初の`描画~機会$用に準備済みになったとき、
%新-文書 に向けて `pagereveal$et ~event %~event が発火される。

◎
When the new Document is ready for its first rendering opportunity, an event named pagereveal is fired on the new Document, with a viewTransition attribute.
</li>
			<li>
%~event の `viewTransition$m 属性が返す `ViewTransition$I ~obj %遷移 の `updateCallbackDone$m ~promiseは、
すでに解決-済みであり，
その`捕捉された要素$は %旧-文書 から拡充される。
◎
This ViewTransition’s updateCallbackDone promise is already resolved, and its captured elements are populated from the old Document.
</li>
			<li>
ここでは、
作者には， %遷移 を~custom化する別の機会が与えられる
（例：
`types$m により %遷移 にて`作動中な型~群$vTを変異させる／
`skipTransition()$m により %遷移 を まるごと飛ばす）。
◎
This is another opportunity for the author to customize the transition, e.g. by mutating its types, or skip it altogether.
</li>
			<li>
%遷移 の “新-” 状態として
%新-文書 の`状態が捕捉される＠#capture-the-new-state$。
◎
The state of the new document is captured as the "new" state of the transition.
</li>
			<li>
以降， %遷移 は、
同一-文書な遷移と類似な流儀で
— `~view遷移を作動化する$手続きに従って —
継続する。
◎
From this point forward, the transition continues in a similar fashion to a same-document transition, as per activate view transition.
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
		<section id="cross-doc-examples">
<h3 title="Examples">7.2. 例</h3>

<div class="example">
<p>
`§ 例＠#examples$【！`~level 1$ の `§ 例＠~CSSVT1#examples$】
における最初の例と同じ~cross-fadeを生成するが、
複数の文書にまたがる【 “非同一-文書である” 】
— ~JSは必要ない。
◎
To generate the same cross-fade as in the first example CSS View Transitions 1 § 1.6 Examples, but across documents, we don’t need JavaScript.
</p>

<p>
代わりに，~page 1, ~page 2 両者において
~naviに対し~view遷移を誘発することを~opt-inする：
◎
Instead, we opt in to triggering view-transitions on navigation in both page 1 and page 2:
</p>

<pre class="lang-css">
/* <span class="comment">
両~文書において：
◎
in both documents:
</span> */
@view-transition {
  navigation: auto;
}
</pre>

<p>
互いの~page間の~linkは、
例 1 による~cross-fade遷移を生成する。
例 2, 3, 4 による効果を達成するためには、
単純に両~文書~内に疑似要素~用の~CSSを~~設置する。
◎
A link from page 1 to or from page 2 would generate a crossfade transition for example 1. To achieve the effect examples 2, 3 &amp; 4, simply put the CSS for the pseudo-elements in both documents.
</p>
</div>

<div class="example">
<p>
`view-transition$at 規則は、
媒体~queryと一緒に利用できることに注意。
例えば，次は、
~screenの横幅が 【`600px^v 】より大きいときに限り遷移を遂行することになる：
◎
Note that the @view-transition rule can be used together with media queries. For example, this would only perform the transition when the screen width is greater than:
</p>

<pre class="lang-css">
@view-transition {
  navigation: auto;
}

@media (max-width: 600px) {
  navigation: none;
}
</pre>
</div>

<div class="example">
<p>
`例 5＠#_example-5$ 【！`例 5＠~CSSVT1#_example-5$】の効果を達成するためには、
次を行う必要がある：
◎
To achieve the effect in example 5, we have to do several things:
</p>
<ul>
	<li>
両~pageにおいて，~naviにより誘発される~view遷移を~opt-inする。
◎
Opt-in to navigation-triggered view-transitions in both pages.
</li>
	<li>
新-文書に~click~~地点を渡す
— 例： `sessionStorage$m を介して。
◎
Pass the click location to the new document, e.g. via sessionStorage.
</li>
	<li>
`pagereveal$et を利用して，
新-文書~内の `ViewTransition$I ~objを横取する。
◎
Intercept the ViewTransition object in the new document, using the pagereveal event.
</li>
</ul>

<p>
両~page内には次がある：
◎
In both pages:
</p>

<pre class="lang-css">
@view-transition {
  navigation: auto;
}
</pre>

<p>
旧-~page内には次がある：
◎
In the old page:
</p>

<pre class="lang-js">
addEventListener('click', %event =&gt; {
  sessionStorage.setItem("lastClickX", %event.clientX);
  sessionStorage.setItem("lastClickY", %event.clientY);
});
</pre>

<p>
新-~page内には次がある：
◎
In the new page:
</p>

<pre class="lang-js">
/* <span class="comment">
これは、
初期~読込nと再-作動化どちらに対しても，
`~BF~cache$から走らすことになろう。
◎
This would run both on initial load and on reactivation from BFCache.
</span> */
addEventListener("pagereveal", async %event =&gt; {
  if (!%event.viewTransition)
    return;

  const %x = sessionStorage.getItem("lastClickX") ?? window.innerWidth / 2;
  const %y = sessionStorage.getItem("lastClickY") ?? window.innerHeight / 2;

  const %endRadius = Math.hypot(
    Math.max(%x, window.innerWidth - %x),
    Math.max(%y, window.innerHeight - %y)
  );

  await event.viewTransition.ready;

  /* <span class="comment">
新-文書の~viewを~animateする
◎
Animate the new document's view
</span> */
  document.documentElement.animate(
    {
      clipPath: [
        ~BQんcircle(0 at ${%x}px ${%y}px)~BQん,
        ~BQんcircle(${%endRadius}px at ${%x}px ${%y}px)~BQん,
      ],
    },
    {
      duration: 500,
      easing: 'ease-in',
      pseudoElement: '::view-transition-new(%root)'
    }
  );
})
</pre>
</div>

<div class="example">
<p>
［
~naviの~propたちに基づいて，どの要素が捕捉されるか
］および［
ある種の画像が読込まれるかどうか
］を選ぶためには：
◎
To choose which elements are captured based on properties of the navigation, and whether certain images are loaded:
</p>

<p>
旧-~pageにおいては：
◎
In the old page:
</p>

<pre class="lang-js">
window.addEventListener("pageswap", %event =&gt; {
  /* <span class="comment">
例えば［
当の~pageは非可視であった／非同一-文書な~naviである
］とき：
◎
For example, the page was hidden, or the navigation is cross-document.
</span> */
  if (!%event.viewTransition)
    return;

  /* <span class="comment">
履歴を前後へ辿る~navi用には、
~view遷移は求まれない場合：
◎
If you don't want view transition for back/forward navigations...
</span> */
  if (%event.activation.navigationType === "traverse") {
    %event.viewTransition.skipTransition();
  }

  const %newURL = new URL(%event.activation.entry.url);
  if (%newURL.pathname === "/details" &amp;&amp; %thumbnail.complete) {
    %thumbnail.classList.add("transition-to-hero");

    /* <span class="comment">
~pageが`~BF~cache$から復旧された場合には、
状態を片付ける：
◎
This will cleanup the state if the page is restored from BFCache.
</span> */
    %event.viewTransition.finished.then(() =&gt; {
      %thumbnail.classList.remove("transition-to-hero");
    });
  }

});
</pre>

<p>
新-~pageにおいては：
◎
In the new page:
</p>

<pre class="lang-js">
window.addEventListener("pagereveal", %event =&gt; {
  /* <span class="comment">
例えば［
~pageは非可視であった／
非同一-文書な~naviである／
旧-文書における遷移は飛ばされた
］とき：
◎
For example, the page was hidden, the navigation is cross-document, or the transition was skipped in the old document.
</span> */
  if (!%event.viewTransition)
    return;

  const %oldURL = new URL(navigation.activation.from.url);
  if (%newURL.pathname === "/list") {
    %event.viewTransition.types.add("coming-from-list");

    /* <span class="comment">
当の~view遷移が完遂するまで， %thumbnail を示す：
◎
This will show the thumbnail until the view transition is finished.
</span> */
    if (!%hero.complete) {
      setToThumbnail(%hero);
      %event.viewTransition.finished.then(() =&gt; {
        setToFullResolution(%hero);
      })
    }
  }
});
</pre>
</div>

		</section>
		<section id="cross-doc-opt-in">
<h3 title="Opting in to cross-document view transitions">7.3. 非同一-文書な~view遷移の~opt-in法</h3>

			<section id="view-transition-rule">
<h4 title="The @view-transition rule">7.3.1. `view-transition^at 規則</h4>

<p>
`view-transition@at
~at-規則は、
次を指示するために利用される
⇒
非同一-文書~naviは、
`ViewTransition$I を設定しておいて作動化するベキである
【順に，`非同一-文書な~view遷移を設定しておく$, `~view遷移を作動化する$】
◎
The @view-transition rule is used by a document to indicate that cross-document navigations should setup and activate a ViewTransition.
</p>

<p>
`view-transition$at 規則の構文は：
◎
The @view-transition rule has the following syntax:
</p>

<pre class="prod">
@view-transition {
  `declaration-list$t
}
</pre>

<p>
`view-transition$at 規則は、
次に挙げる記述子を受容する
⇒＃
`navigation$d,
`types$d
◎
The @view-transition rule accepts the navigation and types descriptors.
</p>

<p class="note">注記：
既定の挙動に倣い、
`view-transition$at 規則は，`条件付き~group規則$
— `media$at や `supports$at など —
の内側に入子にできる。
◎
Note: as per default behavior, the @view-transition rule can be nested inside a conditional group rule such as @media or @supports.
</p>

<p>
`文書$ %文書 用の `view-transition$at 規則が変化したときは、
~UAは，次を遂行するとする
⇒
`外へ出る遷移~用の~opt-in状態を更新する$( %文書 )
◎
When the @view-transition rule changes for Document document, the user agent must update the opt-in state for outbound transitions given document.
</p>

<p class="note">注記：
これ【どれ？】は、
真偽値をとる何かに~cacheする必要がある
— 結果【何の？】は、
~navigateするとき，`並列的$に読取る必要があるので。
◎
Note: this needs to be cached in the boolean because the result needs to be read in parallel, when navigating.
</p>

			</section>
			<section id="view-transition-navigation-descriptor">
<h4 title="The navigation descriptor">7.3.2. `navigation^d 記述子</h4>

◎述 `navigation@d
◎用 `view-transition$at
◎値 `auto$vN | `none$vN
◎初 `none$vN
◎表終

<p>
`navigation$d 記述子は、［
ある種の種別の~naviを遂行する
］ときに［
ある~view遷移を自動的に開始する
］ことを~opt-inする。
それは、［
旧-文書, 新-文書
］どちらにも在ることが要求される【！Must be present】。
◎
The 'navigation' descriptor opts in to automatically starting a view transition when performing a navigation of a certain type. Must be present on both the old and new document.
</p>

<dl class="valdef">
	<dt>`none@vN</dt>
	<dd>
遷移は無い。
◎
There will be no transition.
</dd>

	<dt>`auto@vN</dt>
	<dd>
<p>
遷移は、
当の~naviが ~AND↓ を満たす場合には可能化されることになる：
</p>
		<ul>
			<li>
同一-生成元である
</li>
			<li>
非同一-生成元な~redirectを伴わない
</li>
			<li>
<p>
~OR↓
</p>
				<ul>
					<li>
その `NavigationType$I ~EQ `traverse$l
</li>
					<li>
［
その `NavigationType$I ~IN { `push$l, `replace$l }
］~AND［
`~naviに対する利用者-関与i$ ~NEQ `~browser~UI$i
］
</li>
				</ul>

<p class="trans-note">【
`NavigationType^I は、
`window.navigation＠~HTMLnavAPI#dom-window-navigation$m の［
`transition＠~HTMLnavAPI#dom-navigation-transition$m,
`activation＠~HTMLnavAPI#dom-navigation-activation$m
］どちらかの `navigationType^m を指すと思われるが、
どちらかは，はっきりしない（どちらでも同じかもしれない）。
】</p>

			</li>
		</ul>
◎
The transition will be enabled if the navigation is same-origin, without cross-origin redirects, and whose NavigationType is
• traverse, or
• push or replace, with user navigation involvement not equal to "browser UI".
</dd>
	<dd class="note">注記：
`auto$vN から除外される~naviは、
例えば，次を介して~navigateすることである
⇒＃
~URL~bar／
~bookmarkを~clickすること
利用者や~scriptが起動した `reload$l
◎
Note: Navigations excluded from auto are for example, navigating via the URL address bar or clicking a bookmark, as well as any form of user or script initiated reload.
</dd>
</dl>

<div>
<p>
`view-transition$at ~at-規則は、
~CSSの前方-互換な構文解析~要件に適合する
— この規則を解さない適合t構文解析器は、
~errorを伴うことなく，それを無視することになる。
~UAは、［
この規則を成す記述子のうち，次のいずれかに該当するもの
］をまるごと無視するモノトスル
— そのような記述子は、
当の~at-規則を無効にすることはない：
</p>
<ul>
	<li>
自身が［
認識しない／実装していない
］
</li>
	<li>
その値は、
この仕様
— その将来の~versionも含む —
にて与えられる文法に合致しない
</li>
</ul>
◎
This at-rule conforms with the forward-compatible parsing requirement of CSS; conformant parsers that don’t understand these rules will ignore them without error. Any descriptors that are not recognized or implemented by a given user agent, or whose value does not match the grammars given here or in a future version of this specification, must be ignored in their entirety; they do not make the @view-transition rule invalid.
</div>

			</section>
			<section id="cssom">
<h4 title="Accessing the @view-transition rule using CSSOM">7.3.3. ~CSSOMによる `view-transition$at 規則への~access法</h4>

<p>
`CSSViewTransitionRule$I は、
ある `view-transition$at 規則を表現する。
◎
The CSSViewTransitionRule represents a @view-transition rule.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSViewTransitionRule@I : `CSSRule$I {
  readonly attribute `CSSOMString$ `navigation$m;
  [`SameObject$] readonly attribute `FrozenArray$&lt;`CSSOMString$&gt; `types$m1;
};
</pre>

<div class="algo">
`navigation@m
取得子~手続きは
⇒
~RET ［
コレが表現する `view-transition$at 規則に `navigation$d 記述子は存在するならば，その値／
~ELSE_ 空~文字列
］
◎
The navigation getter step is to return the value of the corresponding navigation descriptor if one exists, otherwise the empty string.
</div>

<div class="algo">
`types@m1
取得子~手続きは
⇒
~RET ［
コレが表現する `view-transition$at 規則に `types$d 記述子は存在するならば，その値／
~ELSE_ 空な`~list$
］
◎
The types getter steps is to return the value of the corresponding types descriptor if one exists, otherwise an empty list.
</div>

			</section>
		</section>
	</section>
	<section id="selective-vt">
<h2 title="Selective view transitions">8. 選択的な~view遷移</h2>

		<section id="selective-vt-overview">
<h3 title="Overview">8.1. 概観</h3>

◎非規範的

<p>
~page用の~view遷移が 1 つしかない単純な局面においては、
関与している各~要素に `view-transition-name$p ~propを設定することで足るはずである。
しかしながら，より複階的な局面においては、
作者は，様々な~view遷移を宣言して，うち 1 つだけを同時に走らすよう求めることもあろう。
例えば、
~navi~barを~clickしたときは，~page全体を滑らす一方で、
~listを成すいずれかの~itemが~dragされたときは，~listを~sortするなど。
◎
For simple pages, with a single view transition, setting the view-transition-name property on participating elements should be sufficient. However, in more complex scenarios, the author might want to declare various view transitions, and only run one of them simultaneously. For example, sliding the whole page when clicking on the navigation bar, and sorting a list when one of its items is dragged.
</p>

<p>
［
各~view遷移が必要なものに限り捕捉すること
］および［
異なる遷移どうしが互いに干渉しない
］ようにするため、
この仕様は，`作動中な型~群$vTの概念を
— ［
`active-view-transition$ps, `active-view-transition-type()$ps
］疑似類と併せて —
導入する。
◎
To make sure each view transition only captures what it needs to, and different transitions don’t interfere with each other, this spec introduces the concept of active types, alongside the :active-view-transition and :active-view-transition-type() pseudo-classes.
</p>

<p>
［
`active-view-transition$ps,
`active-view-transition-type()$ps
］は，どちらも［
`文書$にて`作動中な~view遷移$doc %遷移 ~NEQ ~NULL
］のときに限り，`文書$の`文書~要素$に合致するが、
`active-view-transition-type()$ps が合致するのは，さらに［
その引数を成す【いずれかの】型が %遷移 にて`作動中な型~群$vTに合致する場合
］に限られる。
◎
:active-view-transition matches the document element when it has an active view transition,＼
and :active-view-transition-type() matches the document element if the types in the selectors match the active view transition’s active types.
</p>

<p>
`ViewTransition$I にて`作動中な型~群$vTを拡充するためには、
次に挙げる仕方がある：
◎
The ViewTransition’s active types are populated in one of the following ways:
</p>
<ol>
	<li>
`startViewTransition()$m
に対する引数の一部【 `StartViewTransitionOptions$I の `types$mb 】として渡す。
◎
Passed as part of the arguments to startViewTransition(callbackOptions)
</li>
	<li>
いつでも、
当の遷移の `types$m を利用して変異する。
◎
Mutated at any time, using the transition’s types
</li>
	<li>
非同一-文書な~view遷移~用には、
`types$d 記述子を利用して宣言する。
◎
Declared for a cross-document view transition, using the types descriptor.
</li>
</ol>

		</section>
		<section id="active-view-transition-pseudo-examples">
<h3 title="Examples">8.2. 例</h3>

<div class="example">
<p>
例えば、
開発者は，次の方式で遷移を開始するかもしれない：
◎
For example, the developer might start a transition in the following manner:
</p>

<pre class="lang-js">
document.startViewTransition({update: %updateTheDOMSomehow, types: ["slide-in", "reverse"]});
</pre>

<p>
これは、
次に挙げる選択子をいずれも作動化することになる：
◎

This will activate any of the following selectors:
</p>

<pre class="lang-css">
:root:active-view-transition-type(slide-in) {}
:root:active-view-transition-type(reverse) {}
:root:active-view-transition-type(slide-in, reverse) {}
:root:active-view-transition-type(slide-in, something-else) {}
:root:active-view-transition {}
</pre>

<p>
一方で，遷移~型を供することなく遷移を開始した場合、
`active-view-transition^ps に限り，
作動化することになる：
◎
While starting a transition without providing transition types, would only activate :active-view-transition:
</p>

<pre class="lang-js">
document.startViewTransition(%updateTheDOMSomehow);
/* <span class="comment">
または
◎
or
</span> */
document.startViewTransition({update: %updateTheDOMSomehow});
</pre>

<pre class="lang-css">
/* <span class="comment">
次に挙げるものは、
作動中になる：
◎
This would be active
</span> */
:root { }
:root:active-view-transition {}

/* <span class="comment">
次に挙げるものは、
作動中にならない：

◎
This would not be active
</span> */
:root:active-view-transition-type(slide-in) {}
:root:active-view-transition-type(any-type-at-all-except-star) {}
</pre>
</div>

		</section>
		<section id="pseudo-classes-for-selective-vt">
<h3 title="Selecting based on the active view transition">8.3. 作動中な~view遷移に基づく選定-法</h3>

			<section id="the-active-view-transition-pseudo">
<h4 title="The :active-view-transition pseudo-class">8.3.1. `active-view-transition^ps 疑似類</h4>

<p>
`active-view-transition@ps
疑似類は、
当の文書にて`作動中な~view遷移$docは ~NULL でないならば，
当の文書の根~要素に適用される。
◎
The :active-view-transition pseudo-class applies to the root element of the document, if it has an active view transition.
</p>

<p>
`active-view-transition$ps の`詳細度$は、
1 個の疑似類~選択子と同じになる。
◎
The specificity of an :active-view-transition is one pseudo-class selector.
</p>

<p>
`active-view-transition$ps 疑似類は、
次を満たす`文書~要素$に合致する
⇒
その`~node文書$にて`作動中な~view遷移$doc ~NEQ ~NULL
◎
An :active-view-transition pseudo-class matches the document element when its node document has an non-null active view transition.
</p>

			</section>
			<section id="the-active-view-transition-type-pseudo">
<h4 title="The :active-view-transition-type() pseudo-class">8.3.2. `active-view-transition-type()^ps 疑似類</h4>

<p>
`active-view-transition-type()@ps
疑似類は、
当の文書にて`作動中な~view遷移$docは［
~NULL でない, かつ【いずれかの引数に】合致している
］ならば，
当の文書の根~要素に適用される。
その構文は：
◎
The :active-view-transition-type() pseudo-class applies to the root element of the document, if it has a matching active view transition. It has the following syntax definition:
</p>

<pre class="prod">
:active-view-transition-type(`custom-ident$t#)
</pre>

<p>
`active-view-transition-type()$ps の`詳細度$は、
1 個の疑似類~選択子と同じになる。
◎
The specificity of an :active-view-transition-type() is one pseudo-class selector.
</p>

<p>
`active-view-transition-type()$ps 疑似類は、
~AND↓ を満たす`文書~要素$に合致する：
◎
An :active-view-transition-type() pseudo-class matches the document element when＼
</p>
<ul>
	<li>
その`~node文書$にて`作動中な~view遷移$doc %~view遷移 ~NEQ ~NULL
◎
its node document has an non-null active view transition,＼
</li>
	<li>
引数を成す ある `custom-ident$t ~IN %~view遷移 にて`作動中な型~群$vT
◎
whose active types contains at least one of the &lt;custom-ident&gt; arguments.
</li>
</ul>

			</section>
		</section>
		<section id="types-cross-doc">
<h3 title="Activating the transition type for cross-document view transitions＼The types descriptor">8.4. 非同一-文書な~view遷移~用の遷移~型の作動化-法： `types^d 記述子</h3>

◎述 `types@d
◎用 `view-transition$at
◎値 `none^v | `custom-ident$t+
◎初 `none^v
◎表終

<p>
`types$d 記述子は、
~view遷移を［
捕捉する／遂行する
］ときに，当の遷移にて`作動中な型~群$vTを設定する
— それは、
`startViewTransition(callbackOptions)$m を
— %callbackOptions の `types$mb に その値を与える下で —
~callすることに等価になる。
◎
The 'types' descriptor sets the active types for the transition when capturing or performing the transition, equivalent to calling startViewTransition(callbackOptions) with that types.
</p>

<p class="note">注記：
`types$d 記述子が適用されるのは、
それを定義した`文書$に限られる。
作者が選んだ型たちが成す集合を新-旧-両~文書~内で利用する責務は、
作者にある。
◎
Note: the types descriptor only applies to the Document in which it is defined. The author is responsible for using their chosen set of types in both documents.
</p>

		</section>
	</section>
	<section id="shared-style-with-vt-classes">
<h2 title="Sharing styles between view transition pseudo-elements">9. ~view遷移~疑似要素たちの~styleの共有-法</h2>

		<section id="shared-style-overview">
<h3 title="Overview">9.1. 概観</h3>

◎非規範的

<p>
~DOM内にある複数の要素を類似な仕方で~styleするときには、
`class$a 属性が共通的に利用される：
複数の要素にまたがって共有される名前を設定してから、
`~class選択子$を利用して共有される~styleを宣言するよう。
◎
When styling multiple elements in the DOM in a similar way, it is common to use the class attribute: setting a name that’s shared across multiple elements, and then using the class selector to declare the shared style.
</p>

<p>
`有名~view遷移~疑似要素$
（例： `view-transition-group()$pe ）は、
~DOM内には定義されず，
`view-transition-name$p ~propを利用して定義される。
`view-transition-class$p ~propは、
その目的~用に，~HTMLの`~class群$に等価なものを~view遷移に供する。
`view-transition-name$p を伴う ある要素が
`view-transition-class$p も有するときは、
その値を成す各~classが疑似要素により選定-可能になる
— 下の`例＠#vt-class-example$に見られるとおり。
◎
The view transition pseudo-elements (e.g. view-transition-group()) are not defined in the DOM, but rather by using the view-transition-name property. For that purpose, the view-transition-class' CSS property provides view transitions with the equivalent of HTML classes. When an element with a view-transition-name also has a view-transition-class value, that class would be selectable by the pseudo-elements, as per the examples.
</p>

		</section>
		<section id="vt-class-example">
<h3 title="Examples">9.2. 例</h3>

<div class="example">
<p>
この例が作成する遷移では、
各~boxは，自前の名前の下で遷移に関与する一方で，
すべての~boxの~animationに所要時間 1 秒を適用する：
◎
This example creates a transition with each box participating under its own name, while applying a 1-second duration to the animation of all the boxes:
</p>

<pre class="lang-html">
&lt;div class="box" id="red-box"&gt;&lt;/div&gt;
&lt;div class="box" id="green-box"&gt;&lt;/div&gt;
&lt;div class="box" id="yellow-box"&gt;&lt;/div&gt;
</pre>

<pre class="lang-css">
div.box {
  view-transition-class: any-box;
  width: 100px;
  height: 100px;
}
#red-box {
  view-transition-name: red-box;
  background: red;
}
#green-box {
  view-transition-name: green-box;
  background: green;
}
#yellow-box {
  view-transition-name: yellow-box;
  background: yellow;
}

/* <span class="comment">
次の~styleは、
`view-transition-class$p のおかげで，すべての~boxに適用されることになる：
◎
The following style would apply to all the boxes, thanks to 'view-transition-class'
</span> */
::view-transition-group(*.any-box) {
  animation-duration: 1s;
}
</pre>
</div>

		</section>
		<section id="view-transition-class-prop">
<h3 title="The view-transition-class property">9.3. `view-transition-class^p ~prop</h3>

<div>
◎名 `view-transition-class@p
◎値 `~noneC$v | `custom-ident$t+
◎初 `none^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終
◎
Name: 	view-transition-class
Value: 	none | &lt;custom-ident&gt;+
Initial: 	none
Applies to: 	all elements
Inherited: 	no
Percentages: 	n/a
Computed value: 	as specified
Canonical order: 	per grammar
Animation type: 	discrete
</div>

<p>
`view-transition-class$p を利用すれば、
複数の`有名~view遷移~疑似要素$に対し，
`view-transition-name$p 【により指定された`~view遷移~名$】が異なっていても同じ~style規則を適用できる。
`view-transition-name$p は，
旧-状態~内にある要素と新-状態~内にある対応している要素どうしを照合するために利用されるが、
`view-transition-class$p は，
~view遷移~疑似要素
（ `view-transition-group()$pe,
`view-transition-image-pair()$pe,
`view-transition-old()$pe,
`view-transition-new()$pe ）
を利用して~styleを適用するために限り利用される。
◎
The view-transition-class can be used to apply the same style rule to multiple named view transition pseudo-elements which may have a different view-transition-name. While view-transition-name is used to match between the element in the old state with its corresponding element in the new state, view-transition-class is used only to apply styles using the view transition pseudo-elements (::view-transition-group(), ::view-transition-image-pair(), ::view-transition-old(), ::view-transition-new()).
</p>

<p>
`view-transition-class$p は、
要素を捕捉するために~markするものではないことに注意
— その利用は、［
すでに `view-transition-name$p を有する要素を~styleする
］ための追加的な仕方に限られる。
◎
Note that view-transition-class by itself doesn’t mark an element for capturing, it is only used as an additional way to style an element that already has a view-transition-name.
</p>
<dl class="valdef">
	<dt>`~noneC@v</dt>
	<dd>
当の要素~用に生成される`有名~view遷移~疑似要素$に適用される~classは無い。
◎
No class would apply to the named view transition pseudo-elements generated for this element.
</dd>

	<dt id="valdef-view-transition-class-custom-ident">`custom-ident$t+</dt>
	<dd>
指定された `custom-ident$t 値（ `none^v 以外）すべてが、
`有名~view遷移~疑似要素$`選択子$内で利用されるときに適用される。
`none^v は、
この~prop用の `custom-ident^t としては妥当でない
— 別の `custom-ident^t と組合されたときでも。
◎
All of the specified &lt;custom-ident&gt; values (apart from none) are applied when used in named view transition pseudo-element selectors. none is an invalid &lt;custom-ident&gt; for view-transition-class, even when combined with another &lt;custom-ident&gt;.
</dd>
	<dd>
各 “~view遷移~class” 【これら各 `custom-ident^t 】は、
`~tree視野な名前$である。
◎
Each 'view transition class' is a tree-scoped name.
</dd>
	<dd class="note">注記：
同じ `view-transition-name$p が，遷移を成す［
旧-, 新-
］両~状態~内にある要素~用に指定された場合、
`view-transition-class$p の値は，新-状態~用のものに限り適用される。
このことは、
非同一-文書な~view遷移~用にも適用される：
旧-文書~内で指定された~classは、
対応する `view-transition-name$p が新-文書~内に指定されなかった場合に限り，
適用されることになる。
◎
Note: If the same view-transition-name is specified for an element both in the old and new states of the transition, only the view-transition-class values from the new state apply. This also applies for cross-document view transitions: classes from the old document would only apply if their corresponding view-transition-name was not specified in the new document.
</dd>
</dl>

		</section>
		<section id="pseudo-element-class-additions">
<h3 title="Additions to named view transition pseudo-elements">9.4. 有名~view遷移~疑似要素に対する追加</h3>


<p>
`有名~view遷移~疑似要素$
（ `view-transition-group()$pe,
`view-transition-image-pair()$pe,
`view-transition-old()$pe,
`view-transition-new()$pe ）
は、
次の構文を~supportするよう拡張される：
◎
The named view transition pseudo-elements (view-transition-group(), view-transition-image-pair(), view-transition-old(), view-transition-new()) are extended to support the following syntax:
</p>

<pre class="prod">
::view-transition-group(`pt-name-and-class-selector$t)
::view-transition-image-pair(`pt-name-and-class-selector$t)
::view-transition-old(`pt-name-and-class-selector$t)
::view-transition-new(`pt-name-and-class-selector$t)
</pre>

<p>
`pt-name-and-class-selector$t の構文は：
◎
where &lt;pt-name-selector&gt; works as previously defined,＼
and &lt;pt-name-and-class-selector&gt; has the following syntax definition:
</p>

<pre class="prod">
`pt-name-and-class-selector@t
	= `pt-name-selector$t `pt-class-selector$t?
	| `pt-class-selector$t
`pt-class-selector@t
	= ['.' `custom-ident$t]+
</pre>

<p>
上の文法は、［
次に挙げる箇所においては，空白は禁止される
］ものと解釈される：
◎
When interpreting the above grammar, white space is forbidden:
</p>
<ul>
	<li>
`pt-name-selector$t, `pt-class-selector$t の合間
◎
Between &lt;pt-name-selector&gt; and &lt;pt-class-selector&gt;
</li>
	<li>
`pt-class-selector$t を成す各~成分の合間
◎
Between any of the components of &lt;pt-class-selector&gt;.
</li>
</ul>

<p>
`有名~view遷移~疑似要素$`選択子$に合致する要素は、
`pt-class-selector$t 空であったとするとき合致する要素 %疑似要素 のうち，
次を満たすものに合致する
⇒
`pt-class-selector$t を成す どの `custom-ident^t も次を満たす
⇒
`custom-ident^t ~IN 当の~view遷移の`有名~要素~群$vT[ %疑似要素 の`~view遷移~名$【！ `view-transition-name$p】 ] の`~class~list$cE
◎
A named view transition pseudo-element selector which has one or more &lt;custom-ident&gt; values in its &lt;pt-class-selector&gt; would only match an element if the class list value in named elements for the pseudo-element’s view-transition-name contains all of those values.
</p>

<div>
<p>
`有名~view遷移~疑似要素$`選択子$の`詳細度$は：
</p>
<ul>
	<li>
次を満たす場合は `zero^en 【すなわち ( 0, 0, 0 ) 】になる
⇒
［
`pt-name-selector$t は `*^css （`全称~選択子$）をとる
］~OR［
`pt-class-selector$t は空である
］
</li>
	<li>
~ELSE_ `型~選択子$と等価【すなわち ( 0, 0, 1 ) 】になる
</li>
</ul>
◎
The specificity of a named view transition pseudo-element selector with either:
• a &lt;pt-name-selector&gt; with a &lt;custom-ident&gt;; or
• a &lt;pt-class-selector&gt; with at least one &lt;custom-ident&gt;,
◎
is equivalent to a type selector.
◎
The specificity of a named view transition pseudo-element selector with a * argument and with an empty &lt;pt-class-selector&gt; is zero.
</div>

		</section>
	</section>
	<section id="api">
<h2 title="API">10. ~API</h2>

		<section id="additions-to-document-api">
<h3 title="Additions to Document">10.1. `Document^I に対する追加</h3>

<pre class="idl">
partial interface `Document$I {
  `ViewTransition$I `startViewTransition$m(optional (`ViewTransitionUpdateCallback$I or `StartViewTransitionOptions$I) %callbackOptions = {});
  readonly attribute `ViewTransition$I? `activeViewTransition$m;
};

callback `ViewTransitionUpdateCallback@I = `Promise$&lt;`any$&gt; ();

dictionary `StartViewTransitionOptions@I {
  `ViewTransitionUpdateCallback$I? `update@mb = null;
  `sequence$&lt;`DOMString$&gt;? `types@mb = null;
};
</pre>

<dl class="domintro">
	<dt>
`viewTransition$V = document.`startViewTransition(callbackOptions)$m
◎
viewTransition = document.startViewTransition(updateCallback)
</dt>
	<dd>
新たな`~view遷移$を開始する
（`文書$に既存の`作動中な~view遷移$docがある場合、
それを取消した上で）。
◎
Starts a new view transition (canceling the document’s existing active view transition, if any).
</dd>
	<dd>
%callbackOptions により `更新~callback$V が供された場合、
それは，非同期的に
— 当の文書の現在の状態が捕捉されたなら —
~callされる。
その後，
%更新~callback が返した~promiseが充足されるとき、
当の文書の新-状態が捕捉され，当の遷移が起動される。
◎
updateCallback, if provided, is called asynchronously, once the current state of the document is captured. Then, when the promise returned by updateCallback fulfills, the new state of the document is captured and the transition is initiated.
</dd>
	<dd>
%更新~callback は、
供された場合は，遷移が起こり得ない場合でも
（例：重複な `view-transition-name^p 値に因り），
`常に^em ~callされることに注意。
遷移は，状態~変更~周りの増補なので、
遷移を作成することに失敗しても，
【 %更新~callback による】状態~変更は決して防止されない。
この原則についての詳細は、
`§ 増補としての遷移＠#transitions-as-enhancements$
を見よ。
◎
Note that updateCallback, if provided, is always called, even if the transition cannot happen (e.g. due to duplicate view-transition-name values). The transition is an enhancement around the state change, so a failure to create a transition never prevents the state change. See § 1.5 Transitions as an enhancement for more details on this principle.
</dd>
	<dd>
%更新~callback が返した~promiseが却下された場合、
当の遷移は飛ばされる。
◎
If the promise returned by updateCallback rejects, the transition is skipped.
</dd>
</dl>

<div class="algo" id="ViewTransition-prepare">
<p>
`startViewTransition(callbackOptions)@m
`~method手続き$は
⇒
~RET コレの`根~要素$上の `startViewTransition$m1 `~method手続き$( %callbackOptions )
◎
10.1.1. startViewTransition() Method Steps
◎
The method steps for startViewTransition(callbackOptions) are as follows:
• Perform the Element startViewTransition() method steps given callbackOptions, but for the root element, and return the result.
</p>
</div>

<div class="algo" id="doc-activeviewtransition">
<p>
`activeViewTransition@m
取得子~手続きは
⇒
~RET コレにて`作動中な~view遷移$doc
◎
10.1.2. activeViewTransition Property
◎
In order to provide ergonomic behavior, the active view transition is exposed to script via a document property.
◎
activeViewTransition, of type ViewTransition, readonly, nullable
• Returns the active view transition for the document, or null if there is no active view transition.
</p>

<p class="note">注記：
`要素$の `startViewTransition()$m1 を~callしても，
`文書$の `activeViewTransition$m は更新されないが、
当の要素の `activeViewTransition$m1 は更新される。
◎
Note: An element.startViewTransition() call does not update document.activeViewTransition, but will update activeViewTransition on the element.
</p>
</div>

		</section>
		<section id="additions-to-element-api">
<h3 title="Additions to Element">10.2. `Element^I に対する追加</h3>

<pre class="idl">
partial interface `Element$I {
  `ViewTransition$I `startViewTransition$m1(
    optional (`ViewTransitionUpdateCallback$I or `StartViewTransitionOptions$I) %callbackOptions = {}
  );
  readonly attribute `ViewTransition$I? `activeViewTransition$m1;
};
</pre>

<dl class="domintro">
	<dt>
`viewTransition$V = %element.`startViewTransition(callbackOptions)$m1
◎
viewTransition = el.startViewTransition(updateCallback)
</dt>
	<dd>
新たな`~view遷移$を開始する
（競合している`~view遷移$が在る場合，それを取消す）。
◎
Starts a new view transition (potentially canceling a conflicting view transition).
</dd>
	<dd>
%callbackOptions により `更新~callback$V が供された場合、
それは，非同期的に
— ［
当の要素, その下位tree
］の現在の状態が捕捉されたなら —
~callされる。
その後，
%更新~callback が返した~promiseが充足されるとき、［
当の要素, その下位tree
］の新-状態が捕捉され，当の遷移が起動される。
◎
updateCallback, if provided, is called asynchronously, once the current state of the element and its subtree is captured. Then, when the promise returned by updateCallback fulfills, the new state of the element and its subtree is captured and the transition is initiated.
</dd>
	<dd>
%更新~callback は、
供された場合は，遷移が起こり得ない場合でも
（例：重複な `view-transition-name^p 値に因り），
`常に^em ~callされることに注意。
遷移は，状態~変更~周りの増補なので、
遷移を作成することに失敗しても，
【 %更新~callback による】状態~変更は決して防止されない。
この原則についての詳細は、
`§ 増補としての遷移＠#transitions-as-enhancements$
を見よ。
◎
Note that updateCallback, if provided, is always called, even if the transition cannot happen (e.g. due to duplicate view-transition-name values). The transition is an enhancement around the state change, so a failure to create a transition never prevents the state change. See § 1.5 Transitions as an enhancement for more details on this principle.
</dd>
	<dd>
%更新~callback が返した~promiseが却下された場合、
当の遷移は飛ばされる。
◎
If the promise returned by updateCallback rejects, the transition is skipped.
</dd>

	<dt>
`viewTransition$V = %element.`activeViewTransition$m1
◎
↓↓</dt>
	<dd>
%element にて`作動中な~view遷移$elを返す。
◎
↓↓</dd>

</dl>

<div class="algo">
<p id="Element-ViewTransition-prepare">
`startViewTransition(callbackOptions)@m1
`~method手続き$は：
◎
10.2.1. startViewTransition() Method Steps
◎
The method steps for startViewTransition(callbackOptions) are as follows:
</p>
<ol>
	<li>
%文書 ~LET コレに`関連な大域~obj$に`結付けられた文書$
◎
Let document be this’s relevant global object’s associated document.
</li>
	<li>
%~view遷移 ~LET `新たな~obj$( `ViewTransition$I, %文書 に`関連な~realm$ )
— その
⇒＃
`根~要素$vT ~SET コレ
◎
Let viewTransition be a new ViewTransition object in document’s relevant Realm, with root element set to this.
</li>
	<li>
%~view遷移 の`更新~callback$vT ~SET %callbackOptions に応じて
⇒＃
`ViewTransitionUpdateCallback$I であるならば %callbackOptions ／
`StartViewTransitionOptions$I であるならば %callbackOptions[ "`update$mb" ]
◎
If callbackOptions is a ViewTransitionUpdateCallback, set viewTransition’s update callback to callbackOptions.
◎
Otherwise, if callbackOptions is a StartViewTransitionOptions, then set viewTransition’s update callback to callbackOptions’s update.
</li>
	<li>
~IF［
コレは`~layout封込め$を有していない
］
⇒＃
`~view遷移を飛ばす$( %~view遷移, "`InvalidStateError$E" )；
~RET %~view遷移
◎
If this doesn’t have layout containment, skip viewTransition with an "InvalidStateError" DOMException, and return viewTransition.
</li>
	<li>
<p>
~IF［
%文書 にて`作動中な~view遷移$doc ~NEQ ~NULL
］~AND［
%文書 にて`作動中な~view遷移$docの`外へ出る捕捉-後の手続き$vT ~NEQ ~NULL
］：
◎
If document’s active view transition is not null and its outbound post-capture steps is not null, then:
</p>
		<ol>
			<li>
<p>
`~view遷移を飛ばす$( %~view遷移, "`InvalidStateError$E" )
◎
Skip viewTransition with an "InvalidStateError" DOMException.
</p>

<p class="note">注記：
ここでは、
%~view遷移 にて`作動中な型~群$vT【！`types$m 】は無視される
— 当の遷移は決して作動化されないので。
◎
Note: The viewTransition’s types are ignored here because the transition is never activated.
</p>
			</li>
			<li>
~RET %~view遷移
◎
Return viewTransition.
</li>
		</ol>

<p class="note">注記：
この段は、［
`pageswap$et を発火した後に開始された同一-文書な遷移
］は飛ばされることを確保する。
◎
Note: This ensures that a same-document transition that started after firing pageswap is skipped.
</p>
	</li>
	<li>
<p>
~IF［
コレにて`作動中な~view遷移$el ~NEQ ~NULL
］
⇒
`~view遷移を飛ばす$( コレ, "`AbortError$E" )
◎
If this’s active view transition is not null, then skip that view transition with an "AbortError" DOMException in this’s relevant Realm.
</p>

<p class="note">注記：
これは、
2 つの非同期的な`更新~callback$vT
— コレにて現在`作動中な~view遷移$el用のそれ, %~view遷移 用のそれ —
を同時並行に
（したがって、場合によっては逆順に）
走らす結果にもなり得る。
`この特能の設計＠#transitions-as-enhancements$により、
これらによる~DOM変更は，開発者が別の［
特能／~framework
］を利用して正しく~scheduleするものと見做される。
◎
Note: This can result in two asynchronous update callbacks running concurrently (and therefore possibly out of sequence): one for the this’s current active view transition, and another for this viewTransition. As per the design of this feature, it’s assumed that the developer is using another feature or framework to correctly schedule these DOM changes.
</p>
	</li>
	<li>
<p>
コレにて`作動中な~view遷移$el ~SET %~view遷移
◎
Set this’s active view transition to viewTransition.
</p>

<p class="note">注記：
当の`~view遷移$の処理nは、
`~view遷移を設定しておく$中で，
`処理待ち遷移~演算を遂行する$ことを介して継続される。
◎
Note: The view transition process continues in setup view transition, via perform pending transition operations.
</p>
	</li>
	<li>
<p>
~IF［
%callbackOptions は `StartViewTransitionOptions$I である
］：
</p>
		<ol>
			<li>
%型~群 ~LET %callbackOptions[ "`types$mb" ]
</li>
			<li>
~IF［
%型~群 ~NEQ ~NULL
］
⇒
%~view遷移 にて`作動中な型~群$vT ~SET `~listから集合を作成する$( %型~群 )
</li>
		</ol>
◎
If callbackOptions is a StartViewTransitionOptions, set viewTransition’s active types to a clone of types as a set.
</li>
	<li>
~RET %~view遷移
◎
Return viewTransition.
</li>
</ol>
</div>

<div class="algo" id="element-activeviewtransition">
`activeViewTransition@m1
取得子~手続きは
⇒
~RET コレにて`作動中な~view遷移$el【！`作動中な~view遷移$doc】
◎
10.2.2. activeViewTransition Property
◎
Similar to Document.activeViewTransition, the active view transition of an element is exposed to script via a property on the element.
◎
activeViewTransition, of type ViewTransition, readonly, nullable
• Returns the active view transition for the element, or null if there is no active view transition.
</div>

		</section>
		<section id="the-domtransition-interface">
<h3 title="The ViewTransition interface">10.3. `ViewTransition^I ~interface</h3>

<pre class="idl">
[`Exposed$=Window]
interface `ViewTransition@I {
  readonly attribute `Promise$&lt;`undefined$&gt; `updateCallbackDone$m;
  readonly attribute `Promise$&lt;`undefined$&gt; `ready$m;
  readonly attribute `Promise$&lt;`undefined$&gt; `finished$m;
  `undefined$ `skipTransition$m();
  [`SameObject$] attribute `ViewTransitionTypeSet$I `types$m;
  readonly attribute `Element$I `transitionRoot$m;
  `undefined$ `waitUntil$m(`Promise$&lt;`any$&gt; %promise);
};
</pre>

<p>
`ViewTransition$I ~interfaceは、
同一-文書な`~view遷移$
— すなわち、［
開始~時の文書, 終了~時の文書
］が同じで，場合によっては文書の~DOM構造に対する変更を伴う遷移 —
を表現し，それを制御する。
◎
The ViewTransition interface represents and controls a single same-document view transition, i.e. a transition where the starting and ending document are the same, possibly with changes to the document’s DOM structure.
</p>

<p class="trans-note">【
この記述は、
いくぶん語弊がある
— 非同一-文書な`~view遷移$においても，
遷移-時に生じる適切な~event~objを介して返される
— `§ ~custom化＠#customizing-cross-document-view-transitions$ を見よ。
】</p>

<dl class="domintro">
	<dt>`viewTransition$V.`updateCallbackDone$m</dt>
	<dd>
この~promiseは、
`更新~callback$V が返した~promiseが充足されたとき充足され，
却下されたとき却下される。
◎
A promise that fulfills when the promise returned by updateCallback fulfills, or rejects when it rejects.
</dd>
	<dd class="note">注記：
`~view遷移^cite ~APIは，
~DOM変更を包装して視覚的な遷移を作成するが、
遷移~animationの［
成功／失敗
］について~careすることなく，当の~DOM変更が［
起きたか否か, いつ起きたか
］を知ることだけ求まれるときもある。
`updateCallbackDone$m は、
そのような利用事例~用にある。
◎
Note: The View Transition API wraps a DOM change and creates a visual transition. However, sometimes you don’t care about the success/failure of the transition animation, you just want to know if and when the DOM change happens. updateCallbackDone is for that use-case.)
</dd>

	<dt>`viewTransition$V.`ready$m</dt>
	<dd>
<p>
この~promiseは：
◎
↓</p>
		<ul>
			<li>
遷移~用の疑似要素たちが作成され，~animationが開始しつつあるとき充足する。
◎
A promise that fulfills once the pseudo-elements for the transition are created, and the animation is about to start.
</li>
			<li>
遷移が始まり得ない場合には却下される。
`view-transition-name$p が重複しているなど，誤った環境設定に因り／
`updateCallbackDone$m が却下される~promiseを返した場合など。
◎
It rejects if the transition cannot begin. This can be due to misconfiguration, such as duplicate view-transition-names, or if updateCallbackDone returns a rejected promise.
</li>
		</ul>
	</dd>
	<dd>
`ready$m が充足される時点は、
`~view遷移~疑似要素$を `~Web~animation~API＠~WANIMapi#extensions-to-the-element-interface$cite で~animateする理想的な機会である。
◎
The point that ready fulfills is the ideal opportunity to animate the view transition pseudo-elements with the Web Animation API.
</dd>

	<dt>`viewTransition$V.`finished$m</dt>
	<dd>
<p>
この~promiseは：
◎
↓</p>
		<ul>
			<li>
終了~状態が全部的に可視になり，利用者がヤリトリありになったなら充足される。
◎
A promise that fulfills once the end state is fully visible and interactive to the user.
</li>
			<li>
<p>
却下されるのは、
`更新~callback$V が却下される~promiseを返す場合に限られる
— それは、
終了~状態が作成されなかったことを指示するので。
◎
It only rejects if updateCallback returns a rejected promise, as this indicates the end state wasn’t created.
</p>

<p>
他の場合、［
遷移が始まるのに失敗したか
（ `skipTransition()$m により）飛ばされた
］場合でも，
終了~状態には到達するので充足する。
◎
Otherwise, if a transition fails to begin, or is skipped (by skipTransition()), the end state is still reached, so finished fulfills.
</p>
			</li>
		</ul>
	</dd>

	<dt>`viewTransition$V.`skipTransition$m()</dt>
	<dd>
遷移が開始されたなら即時に完遂させ，まだなら開始されないようにする。
◎
Immediately finish the transition, or prevent it starting.
</dd>
	<dd>
これにより `更新~callback$V が~callされなくなることは決してない
— ~DOM変更は、
遷移とは独立なので。
この原則についての詳細は、
`§ 増補としての遷移＠#transitions-as-enhancements$
見よ。
◎
This never prevents updateCallback being called, as the DOM change is independent of the transition. See § 1.5 Transitions as an enhancement for more details on this principle.
</dd>
	<dd>
`ready$m が解決される前に これが~callされた場合、
`ready$m は却下されることになる。
◎
If this is called before ready resolves, ready will reject.
</dd>
	<dd>
`finished$m が解決される前に これが~callされた場合、
`finished$m は `updateCallbackDone$m が決着するに伴い決着することになる。
◎
If finished hasn’t resolved, it will fulfill or reject along with updateCallbackDone.
</dd>

	<dt>
`viewTransition$V.`transitionRoot$m
</dt>
	<dd>
`viewTransition$V の`根~要素$vTを返す。
◎
The ViewTransition’s root element.
</dd>
	<dd>
`文書$上で開始された`~view遷移$用には、
これは，`文書~要素$になる。
◎
For view transitions started on the Document, this is the document element.
</dd>

	<dt>
`viewTransition$V.`waitUntil(promise)$m
viewTransition.waitUntil()
</dt>
	<dd>
~view遷移の完遂-を所与の~promiseが決着するまで遅延する。
◎
Delays view transition finish until the given promise is settled
◎
↓ When invoked with Promise p, run delay finish for promise steps with p.
</dd>
</dl>

<p>
各 `ViewTransition$I %~view遷移 は、
次に挙げるものを有する：
◎
A ViewTransition has the following:
</p>
<dl class="def-list">
	<dt>
`有名~要素~群@vT
◎
named elements
</dt>
	<dd>
ある`有順序~map$
— 各~entryの
⇒＃
~keyは，`~view遷移~名$を与える。
値は，`捕捉された要素$を与える。
◎
a map, whose keys are view transition names and whose values are captured elements.＼
</dd>
	<dd>
初期~時は，新たな`有順序~map$とする。
◎
Initially a new map.＼
</dd>
	<dd class="note">注記：
これは、
`ViewTransition$I に結付けられるので，
`~view遷移を~clearする$が~callされたとき片付けられることになる。
◎
Note: Since this is associated to the ViewTransition, it will be cleaned up when Clear view transition is called.
</dd>

	<dt>
`相@vT
◎
phase
</dt>
	<dd>
次に挙げるいずれかをとり，
挙げられた順に（場合によっては，一部を飛ばして）進捗する
— 初期~時は `捕捉-待ち$i とする
⇒＃
`捕捉-待ち@i,
`更新~callbackは~call済み@i,
`~animate中@i,
`済み@i
◎
One of the following ordered phases, initially "pending-capture":
• "pending-capture".
• "update-callback-called".
• "animating".
• "done".
</dd>
	<dd class="note">注記：
これらの相は，自動的に進捗するので、
この~APIを利用している開発者【作者】は，
ほとんどにおいて どの相にあるか心配する必要はない。
しかしながら，どの手続きが どの相で起こるか
— ~snapshotは いつ捕捉され, 疑似要素~DOMは いつ作成されるか, 等々 —
を理解することは、
重要になる。
以下に与える各~相を成す記述は、［
仕様に準拠する実装を生産するために従うべき一義的な手続きが成す集合
］を実装者~向けに供する意図をもって，アリな限り精確であろうと試行する。
◎
Note: For the most part, a developer using this API does not need to worry about the different phases, since they progress automatically. It is, however, important to understand what steps happen in each of the phases: when the snapshots are captured, when pseudo-element DOM is created, etc. The description of the phases below tries to be as precise as possible, with an intent to provide an unambiguous set of steps for implementors to follow in order to produce a spec-compliant implementation.
</dd>

	<dt>
`更新~callback@vT
◎
update callback
</dt>
	<dd>
~NULL ／
ある `ViewTransitionUpdateCallback$I
◎
a ViewTransitionUpdateCallback or null.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
Initially null.
</dd>

	<dt>
`準備済み時の~promise@vT
◎
ready promise
</dt>
	<dd>
ある`~promise$
◎
a Promise.＼
</dd>
	<dd>
初期~時は，次を遂行した結果になるとする
⇒
`新たな~promise$( %~view遷移 に`関連な~realm$ )
◎
Initially a new promise in this’s relevant Realm.
</dd>

	<dt>
`更新~callback済み時の~promise@vT
◎
update callback done promise
</dt>
	<dd>
ある`~promise$
◎
a Promise.＼
</dd>
	<dd>
初期~時は，次を遂行した結果になるとする
⇒
`新たな~promise$( %~view遷移 に`関連な~realm$ )
◎
Initially a new promise in this’s relevant Realm.
</dd>
	<dd class="note">注記：
［
`準備済み時の~promise$vT,
`更新~callback済み時の~promise$vT
］は即時に作成されるので、
却下は
— `取扱済みとして~markされ$ない限り，
`updateCallbackDone$m などの取得子に~accessされなかった場合でも —
`unhandledrejection$et を発火させることになる。
◎
Note: The ready promise and update callback done promise are immediately created, so rejections will cause unhandledrejections unless they’re handled, even if the getters such as updateCallbackDone are not accessed.
</dd>

	<dt>
`完遂-時の~promise@vT
◎
finished promise
</dt>
	<dd>
ある`~promise$
◎
a Promise.＼
</dd>
	<dd class="algo">
<p>
初期~時は，次を遂行した結果になるとする：
</p>
		<ol>
			<li>
%~promise ~LET `新たな~promise$( %~view遷移 に`関連な~realm$ )
</li>
			<li>
`~promiseを取扱済みとして~markする$( %~promise )
</li>
			<li>
~RET %~promise
</li>
		</ol>
◎
Initially a new promise in this’s relevant Realm, marked as handled.
</dd>
	<dd class="note">注記：
`unhandledrejection$et が重複して発火されるのを防止するため、
これは，`取扱済みとして~markされ$る。
この~promiseが却下されるのは、
`更新~callback済み時の~promise$vTが却下されるときに限られるので。
◎
Note: This is marked as handled to prevent duplicate unhandledrejections, as this promise only ever rejects along with the update callback done promise.
</dd>

	<dt>
`遷移~根~疑似要素@vT
◎
transition root pseudo-element
</dt>
	<dd>
ある `view-transition$pe
◎
a ::view-transition.＼
</dd>
	<dd>
初期~時は新たな `view-transition^pe とする。
◎
Initially a new ::view-transition.
</dd>

	<dt>
`初期~snapshot包含塊~size@vT
◎
initial snapshot containing block size
</dt>
	<dd>
~NULL ／［
横幅, 縦幅
］を順に与える 2 個の実数が成す`~tuple$
◎
a tuple of two numbers (width and height), or null.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
Initially null.
</dd>
	<dd class="note">注記：
これは、
`~snapshot包含塊の~size$における変化を検出するために利用される
— そのような変化が生じた場合、
遷移は`飛ばされ$る。
この挙動の論点は、
`8045$issue にある。
◎
Note: This is used to detect changes in the snapshot containing block size, which causes the transition to skip. Discussion of this behavior.
</dd>

	<dt>
`作動中な型~群@vT
◎
active types
</dt>
	<dd>
ある `ViewTransitionTypeSet$I
— 【それが表現する`~set~entry群＠~WEBIDL#dfn-set-entries$は】初期~時は空とする。
◎
A ViewTransitionTypeSet, initially empty.
</dd>

	<dt>
`外へ出る捕捉-後の手続き@vT
◎
outbound post-capture steps
</dt>
	<dd>
~NULL ／ ある手続き
— 初期~時は ~NULL とする。
◎
Null or a set of steps, initially null.
</dd>

	<dt>
`根~要素@vT
◎
root element
</dt>
	<dd>
ある `Element$I
— どの要素が %~view遷移 を~hostしているかを指示する。
◎
An Element, indicating which element is hosting the ViewTransition.
</dd>
</dl>

<div class="algo">
`finished@m
`取得子~手続き$は
⇒
~RET コレの`完遂-時の~promise$vT
◎
The finished getter steps are to return this’s finished promise.
</div>

<div class="algo">
`ready@m
`取得子~手続き$は
⇒
~RET コレの`準備済み時の~promise$vT
◎
The ready getter steps are to return this’s ready promise.
</div>

<div class="algo">
`updateCallbackDone@m
`取得子~手続き$は
⇒
~RET コレの`更新~callback済み時の~promise$vT
◎
The updateCallbackDone getter steps are to return this’s update callback done promise.
</div>

<div class="algo">
`types@m
`取得子~手続き$は
⇒
~RET コレにて`作動中な型~群$vT
◎
The types getter steps are to return this’s active types.
</div>

<div class="algo">
`transitionRoot@m
`取得子~手続き$は
⇒
~RET コレの`根~要素$vT
◎
The transitionRoot getter steps are to return this’s root element.
</div>

<div class="algo">
`waitUntil(promise)@m
~method手続きは
⇒
`遷移の完遂-を遅延する~promiseを追加する$( %promise )
◎
↑</div>

			<section id="the-viewtransitiontypeset-interface">
<h4 title="The ViewTransitionTypeSet Interface">10.3.1. `ViewTransitionTypeSet^I ~interface</h4>

<pre class="idl">
[`Exposed$=Window]
interface `ViewTransitionTypeSet@I {
  setlike&lt;`DOMString$&gt;;
};
</pre>

<p>
`ViewTransitionTypeSet$I ~objは、［
特別な意味論を伴わない文字列
］たちが成す`有順序~集合$を表現する。
◎
The ViewTransitionTypeSet object represents a set of strings, without special semantics.
</p>

<p class="note">注記：
`ViewTransitionTypeSet$I は、
`active-view-transition-type()$ps 用には妥当でない文字列を包含し得る
— 例： `custom-ident$t でない文字列。
◎
Note: a ViewTransitionTypeSet can contain strings that are invalid for :active-view-transition-type, e.g. strings that are not a &lt;custom-ident&gt;.
</p>

			</section>
			<section id="ViewTransition-skipTransition">
<h4 title="skipTransition() Method Steps">10.3.2. `skipTransition()^m ~method手続き</h4>

<div class="algo">
<p>
`skipTransition()@m
`~method手続き$は：
◎
The method steps for skipTransition() are:
</p>
<ol>
	<li>
~IF［
コレの`相$vT ~NEQ `済み$i
］
⇒
`~view遷移を飛ばす$( コレ, "`AbortError$E" )
◎
If this’s phase is not "done", then skip the view transition for this with an "AbortError" DOMException.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="auto-vt-name">
<h2 title="Determining view-transition-name automatically">11. `view-transition-name$p の自動的な決定-法</h2>

		<section id="auto-vt-name-overview">
<h3 title="Overview">11.1. 概観</h3>

◎非規範的

<p>
要素が ある`~view遷移$に関与するためには、
一意な`~view遷移~名$【！ `view-transition-name$p 】を受取る必要がある。
これは、
同じ~view遷移~内に複数の要素が孕まれるときに，長々しく冗漫になり得る
— とりわけ、
それらのうち多くが同一-要素な遷移であって．［
旧-状態, 新-状態
］における`~view遷移~名$【！ `view-transition-name$p 】が同じである事例では。
◎
For an element to participate in a view transition, it needs to receive a unique view-transition-name. This can be tedious and verbose when multiple elements are involved in the same view transition, especially in cases where many of those are same-element transitions, as in, the element has the same view-transition-name in the old and new state.
</p>

<p>
これは、
`view-transition-name$p を `auto$v に設定することで，もっと容易になる
— 要素~用の`~view遷移~名$【！ `view-transition-name$p 】は、
要素の`~ID$からとられるか，~IDが無い場合は【自動的に】生成される。
◎
To make this easier, setting the view-transition-name to auto would generate a view-transition-name for the element, or take it from the element’s id if present.
</p>

		</section>
		<section id="auto-vt-name-example">
<h3 title="Examples">11.2. 例</h3>

<div class="example">
<p>
この例では、
~listを~sortするときに~animateするための仕方として，
~view遷移が利用される：
◎
In this example, view transition is used to sort a list in an animated way:
</p>

<pre class="lang-html">
&lt;ul&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2&lt;/li&gt;
  &lt;li&gt;Item 3&lt;/li&gt;
  &lt;li&gt;Item 4&lt;/li&gt;
  ...
&lt;/ul&gt;
</pre>

<p>
~listを成す各~itemの `view-transition-name$p は、
普通は，一意な`~view遷移~名$を受取るようにする必要があろう：
◎
Ordinarily, each of these items would have to receive a unique view-transition-name:
</p>

<pre class="lang-css">
li:nth-child(1) { view-transition-name: item1; }
li:nth-child(2) { view-transition-name: item2; }
li:nth-child(3) { view-transition-name: item3; }
li:nth-child(4) { view-transition-name: item4; }
...
</pre>

<p>
が、［
`auto$v ／ `match-element$v
］を伴う次の~CSSでも，働くことになる：
◎
With auto or match-element, this CSS would work:
</p>

<pre class="lang-css">
li {
  view-transition-name: auto;
  /* <span class="comment">
あるいは
◎
or
</span> */
  view-transition-name: match-element;
}
</pre>

<p>
~keyword［
`auto$v, `match-element$v
］には、
ちょっとした相違がある：
◎
The auto and match-element keywords have a minor difference, where＼
</p>
<ul>
	<li>
`auto^v は、
当の要素の`~ID$が存在するならば，それを `view-transition-name$p として利用する
— それが［
旧-文書, 新-文書【！文書たち】
］にまたがって働くものになれるよう。
【~IDが無い場合は `match-element^v と同じに挙動する。】
◎
auto would use the element’s id as the view-transition-name if it exists, making it potentially work across documents,＼
</li>
	<li>
`match-element^v は、
要素の同一性のみに基づいて合致するようにする。
◎
while match-element only matches based on element identity.
</li>
</ul>
</div>

		</section>
		<section id="additions-to-vt-name">
<h3 title="Additions to view-transition-name">11.3. `view-transition-name^p に対する追加</h3>

<p>
`view-transition-name$p ~propは、
新たな~keyword
`auto@v
【および `match-element@v 】
も受容する。
◎
In addition to the existing values, the view-transition-name also accepts an auto keyword.＼
</p>

<div class="algo">
<p>
%要素 の `view-transition-name$p の`使用~値$を解決する~algoは、
その`算出d値$ %算出d値 に応じて：
◎
To resolve the used value of view-transition-name for element:
◎
• Let computed be the computed value of view-transition-name.
</p>
<ul class="switch">
	<li>
`none$v
⇒
~RET ~NULL
【 %要素 には`~view遷移~名$は無い】
◎
If computed is none, return null.
</li>
	<li>
`custom-ident$t である
⇒
~RET %算出d値
◎
If computed is a &lt;custom-ident&gt;, return computed.
</li>
	<li>
<p>
`auto$v ：
</p>
		<ol>
			<li>
<p>
~IF［
%要素 の`~ID$ ~NEQ ε
］~AND［
%算出d値 に`結付けられた根＠~CSSSCOPING#css-tree-scoped-name$ ~EQ %要素 の`根$
］
⇒
~RET ある一意な `-ua-^l から開始する文字列
— 同じ`~ID$を伴う 2 個の要素は、
それらの`~node文書$が異なっていても，同じ文字列を返すモノトスル。
</p>

<p class="note">注記：
このことは、
`part()$pe 疑似要素に対しては，それに合致している要素の`~ID$
【それを介して公開される要素の~IDに対応する文字列】
には解決されないことを意味する。
</p>
			</li>
			<li>
`match-element$v であった場合に従う
</li>
		</ol>
◎
Assert: computed is auto or match-element.
◎
If computed is auto, element has an associated id, and computed is associated with the same root as element’s root, then return a unique string starting with "-ua-". Two elements with the same id must return the same string, regardless of their node document.
◎
Note: this means that a ::part() pseudo-element wouldn’t resolve to its matching element’s id.
</li>
	<li>
<p>
`match-element$v
⇒
~RET ある一意な `-ua-^l から開始する文字列
— この文字列は、
少なくとも［
%要素 の`~node文書$ %文書 にて`作動中な~view遷移$docの存続期間
］においては，［
%要素 用に一貫する
］かつ［
%文書 内で一意であり続ける
］ベキである。
◎
Return a unique string starting with "-ua-". The string should remain consistent and unique for this element and Document, at least for the lifetime of element’s node document’s active view transition.
</p>

<p class="note">注記：
非同一-文書な~view遷移において利用されるときには、
【旧-文書, 新-文書において】これ【！`auto$v 値】により生成される名前どうしは，決して合致しない
— その結果、
外へ出る~view遷移~用の `view-transition-group()$pe 疑似要素は，
内へ来る~view遷移~用のそれとは別々になる。
◎
Note: When used in a cross-document view transition, generated auto values never match, resulting in separate ::view-transition-group() pseudo-elements, one exiting and one entering.
</p>
	</li>
</ul>
</div>

<p>
`auto$v により生成される`~view遷移~名$【！ `view-transition-name$p 】は、
`~tree視野な名前$である。
◎
A view-transition-name generated by auto is a tree-scoped name.
</p>

		</section>
	</section>
	<section id="nested-view-transition-groups">
<h2 title="Nested view-transition groups">12. 入子な~view遷移~group</h2>

		<section id="nested-overview">
<h3 title="Overview">12.1. 概観</h3>

◎非規範的

<p>
既定では、
複数の要素に `view-transition-name^p を設定したときは，
平坦な`~view遷移~tree$が生成される
— すなわち、
すべての `view-transition-group()$pe 疑似要素は，
`view-transition$pe 疑似要素の子になる。
これは，多くの単純な利用事例~用には足るが、
平坦な~treeでは達成できない~style法の利用事例もある。
真っ先に挙がる利用事例は、
【~overflowなどによる】切取りである：
平坦な~treeでは，すべての疑似要素は`~snapshot包含塊$で切取られるので、
通常の~treeにおいて要素が切取られると，その部分が~view遷移の間に失われ、
その結果，視覚-効果が崩れる。
次に挙げる効果は、
平坦な~treeにおいて期待されない視覚-効果を伴い得る：
◎
By default, setting view-transition-name on multiple elements generates a flat view transition tree, where all the ::view-transition-group() pseudo-elements are children of the ::view-transition pseudo-element. This is sufficient for many simple use-cases, but there are some styling use-cases that cannot be achieved with a flat tree. The most prominent use-case is clipping: with a flat tree, all pseudo-elements are clipped to the snapshot containing block, so clipping elements in the normal tree would lose their clipping during the view-transition, resulting in a broken visual effect. The effects that have can have an unexpected visual effect in a flat tree:
</p>

<ul>
	<li>
切取り
（ `overflow$p, `clip-path$p, `border-radius$p ）
⇒
切取りは、
当の要素の子たちに影響する。
◎
Clipping (overflow, clip-path, border-radius): clipping affects the children of the element.
</li>
	<li>
`opacity$p,
`mask-image$p,
`filter$p
⇒
これらの効果は、
~tree【これらを利用する要素を根とする下位tree】を全部的に~raster化した画像に対し，働くよう設計される
— 各~itemに対し個別に働くのではなく。
◎
opacity, mask-image and filter: These effects that are designed to work on a fully rasterized image of a tree, rather than on each item individually.
</li>
	<li>
~3D変形
（ `transform-style$p, `transform$p, `perspective$p ）
⇒
~3D変形の~animationを成す全部的な範囲を表示するためには、
何らかの階層が保たれる必要がある。
◎
3D transforms (transform-style, transform, perspective): to display the full range of 3D transform animations, some hierarchy needs to be kept.
</li>
</ul>

<p>
これらの利用事例を可能化するため、
この仕様は，［
~view遷移~疑似要素たちを入子にすること
］が成す概念を導入する。
作者は、
`view-transition-group$p ~propを利用して［
生成される `view-transition-group()$pe 疑似要素~用に “親~group” をアテガう
］ことにより，`~view遷移~tree$内に階層を作成できる。
◎
To enable these use cases, this specification introduces the concept of nesting view-transition pseudo-elements. By using the view-transition-group CSS property, the author can assign a "parent group" for a generated ::view-transition-group() pseudo-element, creating a hierarchy in the view transition tree.
</p>

		</section>
		<section id="nested-vt-example">
<h3 title="Examples">12.2. 例</h3>

<div class="example">
<p>
この例で作成される遷移の`~view遷移~tree$は、
平坦になる代わりに入子にされる：
◎
This example creates a transition where the view transition tree is nested instead of flat:
</p>

<pre class="lang-html">
&lt;section class="container"&gt;
  &lt;article&gt;Content&lt;/article&gt;
&lt;/section&gt;
</pre>

<pre class="lang-css">
.container {
  view-transition-name: container;
}

.container,
::view-transition-group-children(container) {
  clip-path: circle();
}

article {
  view-transition-name: article;
  view-transition-group: container;
}
</pre>

<p>
これ用の疑似要素~treeは、
次のようになる：
◎
The pseudo-element tree for this would be as follows:
</p>
<div>
<ol>
	<li>
`view-transition^pe
		<ol>
			<li>
`view-transition-group(container)^pe
				<ol>
					<li>
`view-transition-image-pair(container)^pe
						<ol>
							<li>
`view-transition-old(container)^pe
</li>
							<li>
`view-transition-new(container)^pe
</li>
						</ol>
					</li>
					<li>
`view-transition-group-children(container)^pe
						<ol>
							<li>
`view-transition-group(article)^pe
								<ol>
									<li>
`view-transition-old(article)^pe
</li>
									<li>
`view-transition-new(article)^pe
</li>
								</ol>
							</li>
							<li>
…
（他の入子な~group）
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
…
（他の~group）
</li>
		</ol>
	</li>
</ol>

<pre class="_en">
::view-transition
├─ ::view-transition-group(container)
│  ├─ ::view-transition-image-pair(container)
│  |  ├─ ::view-transition-old(container)
│  |  └─ ::view-transition-new(container)
│  └─ ::view-transition-group-children(container)
│     ├─ ::view-transition-group(article)
│     |  ├─ ::view-transition-old(article)
│     |  └─ ::view-transition-new(article)
│     └─ ...other nested groups...
└─ …other groups…
</pre>
</div>


<p>
`clip-path$p を［
包含している要素【 `.container^css 】,
それ用に生成された `view-transition-group-children()$pe 疑似要素
］両者に適用することにより，
切取られたものは遷移の間も保全され、［
当の容器【 `.container^css 】を参照している `view-transition-group$p を当の内部~要素【 `article^e 】に適用する
］ことにより，［
この切取りを適用することになる仕方
］で当の~treeを “入子に” する。
◎
By applying the clip-path to both the containing element and its generated ::view-transition-group-children() pseudo-element, we preserve the clip during the transition, and by applying view-transition-group to the internal element referencing the container, we make the tree "nested" in a way that would apply this clipping.
</p>
</div>

		</section>
		<section id="view-transition-group-prop">
<h3 title="The view-transition-group property">12.3. `view-transition-group^p ~prop</h3>

<div>
◎名 `view-transition-group@p
◎値 `normal$v | `contain$v | `nearest$v | `custom-ident$t
◎初 `normal$v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終
◎
Name: 	view-transition-group
Value: 	normal | contain | nearest | &lt;custom-ident&gt;
Initial: 	normal
Applies to: 	all elements
Inherited: 	no
Percentages: 	n/a
Computed value: 	as specified
Canonical order: 	per grammar
Animation type: 	discrete
</div>

<p>
`view-transition-group$p ~propは、
`view-transition-name$p と伴に利用することで，
`有名~view遷移~疑似要素$たちが成す階層を生成できる。
◎
The view-transition-group property can be used in conjuction with view-transition-name to generate a hierarchy of named view transition pseudo-element.
</p>

<p>
`要素$ %要素 の `view-transition-group$p の`使用~値$は、［
%要素 の ある先祖の `view-transition-name$p の値
］ %名前 または `none$v に解決される。
`有名~view遷移~疑似要素$を生成するとき、
【`~view遷移~名$として】 %名前 を伴う `view-transition-group()$pe は，
【その子として】 `view-transition-group-children()$pe 疑似要素を作成することになり、
それは［
%要素 の `view-transition-name$p 用に生成される `view-transition-group()$pe
］の親になる。
◎
The used value for view-transition-group resolves to a view-transition-name in its ancestor chain, or to none. When generating the named view transition pseudo-element, the ::view-transition-group() with that name would create a ::view-transition-group-children() pseudo-element, which would be the parent of the ::view-transition-group() generated for this element’s view-transition-name.
</p>

			<section id="view-transition-group-children-pseudo">
<h4 title="View Transition Tree Root: the ::view-transition-group-children pseudo-element">12.3.1. ~view遷移~treeの根： `view-transition-group-children^pe 疑似要素</h4>

<p>
`view-transition-group-children()@pe
`疑似要素$は、
それに合致している有名`~view遷移$の捕捉を表現する`有名~view遷移~疑似要素$である。
この疑似要素は、［
それに対応する `view-transition-group()$pe 疑似要素の子【！`子~群$】
］として `view-transition-group$p ~propに基づいて生成され，
入子にされた各~groupに対応する 1 個以上の `view-transition-group()$pe 疑似要素【！要素】を包含する。
`使用~group名$を解決する~algo, それに関係する各種~algoを見よ。
◎
The ::view-transition-group-children() pseudo-element is a named view transition pseudo-element that represents a matching named view transition capture. A ::view-transition-group-children() pseudo-element is generated based on the view-transition-group property, as a child of the corresponding ::view-transition-group() pseudo-element, and contains one or more ::view-transition-group() elements, corresponding to the nested groups. See the used group name and related algorithms.
</p>

<p>
`view-transition-group-children()$pe `疑似要素$は、
その同胞である `view-transition-image-pair()$pe より後に位置する。
それは、
入子にされた子~群の［
切取りや~mask法
］の様な効果を制御するために利用される。
◎
The ::view-transition-group-children() pseudo-element is positioned after its sibling view-transition-image-pair(). It is used to control effects like clipping or masking of nested children.
</p>

			</section>
		</section>
	</section>
	<section id="algorithms">
<h2 title="Algorithms">13. ~algo</h2>

		<section id="concepts">
<h3 title="Data Structures">13.1. ~data構造</h3>

<p>
各~要素は、
`作動中な~view遷移@el
を有する
— それは、［
~NULL ／
ある `ViewTransition$I
］であり，
初期~時は ~NULL とする。
</p>

<p class="trans-note">【
この定義は、
この訳による補完。
原文は、
`文書$用に定義された`作動中な~view遷移$docを参照している。
加えて，`文書$にて`作動中な~view遷移$docは、
実際には，`文書~要素$にて`作動中な~view遷移$elを参照するべきに思われる。
`startViewTransition()$m ~methodは、
そのようになるよう更新されたので。
】</p>

			<section id="additions-to-document">
<h4 title="Additions to Document">13.1.1. 文書に対する追加</h4>

<p>
各`文書$は、
次に挙げるものを追加的に有する：
◎
A Document additionally has:
</p>

<dl class="def-list">
	<dt>
`作動中な~view遷移@doc
◎
active view transition
</dt>
	<dd>
~NULL ／
ある `ViewTransition$I
◎
a ViewTransition or null.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
Initially null.
</dd>

	<dt>
`~view遷移~用の描画を抑止するか@doc
◎
rendering suppression for view transitions
</dt>
	<dd>
ある真偽値
◎
a boolean.＼
</dd>
	<dd>
初期~時は ~F とする。
◎
Initially false.
</dd>
	<dd>
~T をとる間は、
すべての~pointer接触判定は，
%文書 の`文書~要素$を~targetにするモノトスル
— 他の`要素$をすべて無視して。
◎
While a Document’s rendering suppression for view transitions is true, all pointer hit testing must target its document element, ignoring all other elements.
</dd>
	<dd class="note">注記：
これは、
`~pointer捕捉＠~POINTEREVENTS#dfn-pointer-capture$には影響しない。
◎
Note: This does not affect pointers that are captured.
</dd>
	<dd class="trans-note">【
何が “接触判定” を成すかは，
いくつかの仕様に言及されているが（`例＠~POINTEREVENTS#dfn-hit-test$）、
いずれも正式には定義していない。
】</dd>

	<dt>
`動的な~view遷移~stylesheet@doc
◎
dynamic view transition style sheet
</dt>
	<dd>
ある`~stylesheet＠~CSSSNAPSHOT#style-sheet$
◎
a style sheet.＼
</dd>
	<dd>
初期~時は、
`~UA出自$に属する新たな~stylesheetとする
— これは、
`大域的な~view遷移~UA~stylesheet$より後に順序されるとする。
◎
Initially a new style sheet in the user-agent origin, ordered after the global view transition user agent style sheet.
</dd>
	<dd class="note">注記：
これは、
遷移に関係している動的な~styleを保持するために利用される。
◎
Note: This is used to hold dynamic styles relating to transitions.
</dd>

	<dt>
`~view遷移~treeを示すか@doc
◎
show view transition tree
</dt>
	<dd>
ある真偽値
◎
A boolean.＼
</dd>
	<dd>
初期~時は ~F とする。
◎
Initially false.
</dd>
	<dd>
~T のときは、
%文書 にて`作動中な~view遷移$docの`遷移~根~疑似要素$vT %根 は、
その`出自の要素$である［
%文書 の`文書~要素$
］の`子$として描画される。
◎
When this is true, this’s active view transition’s transition root pseudo-element renders as a child of this’s document element, with this’s document element is its originating element.
</dd>
	<dd class="note">注記：
`文書~要素$の中での %根 の位置は問われない
— %根 の`包含塊$は，`~snapshot包含塊$になるので。
◎
Note: The position of the transition root pseudo-element within the document element does not matter, as the transition root pseudo-element’s containing block is the snapshot containing block.
</dd>

	<dt>
`更新~callback~queue@doc
◎
update callback queue
</dt>
	<dd>
ある`~list$
◎
A list,＼
</dd>
	<dd>
初期~時は空とする。
◎
initially empty.
</dd>

	<dt>
`内へ来る~view遷移~params@doc
◎
inbound view transition params
</dt>
	<dd>
~NULL ／ある`~view遷移~params$
◎
a view transition params, or null.＼
</dd>
	<dd>
初期~時は~NULLとする。
◎
Initially null.
</dd>

	<dt>
`外へ出る~view遷移を起動できるか@doc
◎
can initiate outbound view transition
</dt>
	<dd>
ある真偽値
◎
a boolean.＼
</dd>
	<dd>
初期~時は ~F とする。
◎
Initially false.
</dd>
	<dd class="note">注記：
この値は、
~navigateしている間に`並列的$に読取られ得る。
◎
Note: this value can be read in parallel while navigating.
</dd>

	<dt>
`決着するまで待機する~promise数@doc
◎
wait until promise count
</dt>
	<dd>
ある整数
◎
an integer,＼
</dd>
	<dd>
初期~時は 0 とする。
◎
initially 0.
</dd>
	<dd>
`waitUntil()$m ~method【！function】を介して追加された~promiseのうち決着-済みでないものの個数を表現する
◎
Represents the count of promises that have been added via waitUntil function and have not settled.
</dd>
</dl>

<p class="trans-note">【
［
“内へ来る（ `inbound^en ）〜” ／
“外へ出る（ `outbound^en ）〜”
］は、
非同一-文書な遷移に利用される概念であり，
“〜 は［
新-文書／旧-文書
］に結付けられたものである”
ことを意味する。
】</p>

			</section>
			<section id="elements-concept">
<h4 title="Additions to Elements">13.1.2. 要素に対する追加</h4>

<p>
各 `要素$は、
`ある~view遷移~内に捕捉されたか@el
を有する
— それは、
真偽値をとり，初期~時は ~F とする。
◎
Elements have a captured in a view transition boolean, initially false.
</p>

<p class="note">注記：
この仕様は、
~CSSによる
`要素@
の定義を利用する
— それは、
`疑似要素$も含む†。
◎
Note: This spec uses CSS’s definition of element, which includes pseudo-elements.
</p>

<p class="trans-note">【†
これを書いた時点で、
実際に，疑似要素を含むものと明示的に定義している仕様は無い
（各~仕様の中で，暗黙的に含んでいる箇所は、
いくつかあるとしても）
— `CSS2$r に定義される`要素＠https://drafts.csswg.org/css2/#element$,
`CSS-DISPLAY-4$r に定義される`要素＠~CSSDISP#elements$
どちらも，
そのように定義されていない。
】【
本物の要素~用には定義されているが，
疑似要素~用には定義されていない概念（例：`~node文書$）は、
`最終的な出自の要素$に基づくものと解釈することになろう。
】</p>

			</section>
			<section id="captured-elements">
<h4 title="Captured elements">13.1.3. 捕捉された要素</h4>

<p>
`捕捉された要素@
は、
次に挙げる`~item$sctからなる`構造体$である：
◎
A captured element is a struct with the following:
</p>
<dl class="def-list">
	<dt>
`旧-画像@cE
◎
old image
</dt>
	<dd>
~NULL ／
ある~2D~bitmap
◎
an 2D bitmap or null.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
Initially null.
</dd>

	<dt>
`旧-横幅@cE
◎
old width
</dt>
	<dt>
`旧-縦幅@cE
◎
old height
</dt>
	<dd>
ある `unrestricted double$c
【有限でない場合（ `NaN^jv や `Infinity^jv ）の挙動は指定されていない。】
◎
an unrestricted double,＼
</dd>
	<dd>
初期~時は 0 とする。
◎
initially zero.
</dd>

	<dt>
`旧-変形@cE
◎
old transform
</dt>
	<dd>
ある `transform-function$t
◎
a &lt;transform-function&gt;,＼
</dd>
	<dd>
初期~時は`恒等~変形-関数$とする。
◎
initially the identity transform function.
</dd>

	<dt>
`旧-書字~mode@cE
◎
old writing-mode
</dt>
	<dd>
~NULL ／
`writing-mode$p 用の値
◎
Null or a writing-mode,＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
initially null.
</dd>

	<dt>
`旧-方向@cE
◎
old direction
</dt>
	<dd>
~NULL ／
`direction$p 用の値
◎
Null or a direction,＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
initially null.
</dd>

	<dt>
`旧-~text方位@cE
◎
old text-orientation
</dt>
	<dd>
~NULL ／
`text-orientation$p 用の値
◎
Null or a text-orientation,＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
initially null.
</dd>

	<dt>
`旧-混色~mode@cE
◎
old mix-blend-mode
</dt>
	<dd>
~NULL ／
`mix-blend-mode$p 用の値
◎
Null or a mix-blend-mode,＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
initially null.
</dd>

	<dt>
`旧-後景~filter@cE
◎
old backdrop-filter
</dt>
	<dd>
~NULL ／ `backdrop-filter$p 用の値
◎
Null or a backdrop-filter,＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
initially null.
</dd>

	<dt>
`旧-色~scheme@cE
◎
old color-scheme
</dt>
	<dd>
~NULL ／ `color-scheme$p 用の値
◎
Null or a color-scheme,＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
initially null.
</dd>
	<dt>
`新-要素@cE
◎
new element
</dt>
	<dd>
~NULL ／
ある`要素$
◎
an element or null.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
Initially null.
</dd>

	<dt>
`~class~list@cE
◎
class list
</dt>
	<dd>
文字列たちが成す`~list$
◎
a list of strings,＼
</dd>
	<dd>
初期~時は空とする。
◎
initially empty.
</dd>

	<dt>
`包含ng~group名@cE
◎
containing group name
</dt>
	<dd>
~NULL ／ある文字列
◎
Null or a string,＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
initially null.
</dd>

	<dt>
`~snapshot包含塊からの変形@cE
◎
transform from snapshot containing block
</dt>
	<dd>
~NULL ／ある`行列$
◎
A matrix or null,＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
initially null.
</dd>

	<dt>
`旧-~border幅@cE
◎
old border width
</dt>
	<dd>
~NULL ／
`border-width$p の`使用~値$として与えられる `px^u 単位による ( 上端, 右端, 下端, 左端 ) 値が成す~tuple
◎
border-width used value (top, right, bottom and left pixel values) or null,＼
</dd>
	<dd>
初期~時は~NULL とする。
◎
initially null.
</dd>
</dl>

<p>
各`捕捉された要素$は、
`~style定義~群@cE
と総称される，次に挙げる~itemも伴う：
◎
In addition, a captured element has the following style definitions:
</p>
<dl class="def-list">
	<dt>
`~group~keyframe群@cE
◎
group keyframes
</dt>
	<dd>
~NULL ／
ある `CSSKeyframesRule$I
◎
A CSSKeyframesRule or null.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
Initially null.
</dd>

	<dt>
`~group~animation名~規則@cE
◎
group animation name rule
</dt>
	<dd>
~NULL ／
ある `CSSStyleRule$I
◎
A CSSStyleRule or null.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
Initially null.
</dd>

	<dt>
`~group~style規則@cE
◎
group styles rule
</dt>
	<dd>
~NULL ／
ある `CSSStyleRule$I
◎
A CSSStyleRule or null.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
Initially null.
</dd>

	<dt>
`画像~pair隔離~規則@cE
◎
image pair isolation rule
</dt>
	<dd>
~NULL ／
ある `CSSStyleRule$I
◎
A CSSStyleRule or null.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
Initially null.
</dd>

	<dt>
`画像~animation名~規則@cE
◎
image animation name rule
</dt>
	<dd>
~NULL ／
ある `CSSStyleRule$I
◎
A CSSStyleRule or null.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
Initially null.
</dd>
</dl>

<p class="note">注記：
これらは、
`文書$の`動的な~view遷移~stylesheet$docを［
更新するため／
後でそこから~styleを除去するため
］に利用される。
◎
Note: These are used to update, and later remove styles from a document’s dynamic view transition style sheet.
</p>

			</section>
			<section id="cross-doc-data-structure-serialization">
<h4 title="Serializable view transition params">13.1.4. 直列化-可能な~view遷移~params</h4>

<p>
`~view遷移~params@
は、
次に挙げる`~item$sctからなる`構造体$である。
その目的は、
文書たちにまたがって，~view遷移~情報を直列化する
【旧-文書から新-文書へ情報を渡す】
ことにある：
◎
A view transition params is a struct whose purpose is to serialize view transition information across documents. It has the following items:
</p>

<dl class="def-list">
	<dt>
`有名~要素@vTP
◎
named elements
</dt>
	<dd>
`有順序~map$
— 各~entryの［
~keyは文字列／
値は`捕捉された要素$
］を与える。
◎
a map, whose keys are strings and whose values are captured elements.
</dd>

	<dt>
`初期~snapshot包含塊~size@vTP
◎
initial snapshot containing block size
</dt>
	<dd>
2 個の実数 ( 横幅, 縦幅 ) が成す`~tuple$
◎
a tuple of two numbers (width and height).
</dd>
</dl>

			</section>
		</section>
		<section id="perform-pending-transition-operations-algorithm">
<h3 title="Perform pending transition operations">13.2. 処理待ち遷移~演算を遂行する</h3>

<p class="note">注記：
この~algoは、
`描画を更新する段＠~WAPI#update-the-rendering$ `HTML$r の中から呼出される。
◎
This algorithm is invoked as a part of update the rendering loop in the html spec.
</p>

<div class="algo">
<p>
`処理待ち遷移~演算を遂行する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To perform pending transition operations given a Document document, perform the following steps:
</p>
<ol>
	<li>
%~view遷移 ~LET %文書 にて`作動中な~view遷移$doc
◎
↓</li>
	<li>
<p>
~IF［
%~view遷移 ~NEQ ~NULL
］：
◎
If document’s active view transition is not null, then:
</p>
		<ol>
			<li>
~IF［
%~view遷移 の`相$vT ~EQ `捕捉-待ち$i
］
⇒
`~view遷移を設定しておく$( %~view遷移 )
◎
If document’s active view transition’s phase is "pending-capture", then setup view transition for document’s active view transition.
</li>
			<li>
~ELIF［
%~view遷移 の`相$vT ~EQ `~animate中$i
］
⇒
`遷移~frameを取扱う$( %~view遷移 )
◎
Otherwise, if document’s active view transition’s phase is "animating", then handle transition frame for document’s active view transition.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="vt-rule-algo">
<h3 title="Resolving the @view-transition rule">13.3. `view-transition$at 規則の解決-法</h3>

<div class="algo">
<p>
`~view遷移~規則を解決する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To resolve @view-transition rule for a Document document: 
</p>

<p class="note">注記：
これは、
旧-文書, 新-文書どちらからも~callされる。
◎
Note: this is called in both the old and new document.
</p>

<ol>
	<li>
~IF［
%文書 の`可視性~状態$doc ~EQ `hidden^l
］
⇒
~RET `遷移を飛ばす^i
◎
If document’s visibility state is "hidden", then return "skip transition".
</li>
	<li>
<p>
%合致している規則 ~LET %文書 内に `view-transition$at 規則は［
在るならば それらのうち最後のもの／
無いならば ε
］
</p>

<p class="trans-note">【
`条件付き~group規則$内に入子にされ，条件が満たされないため無視される規則は、
この段の目的においては，無かったものと見なされよう。
】</p>
◎
Let matchingRule be the last @view-transition rule in document.
</li>
	<li>
~IF［
%合致している規則 ~EQ ε
］
⇒
~RET `遷移を飛ばす^i
◎
If matchingRule is not found, then return "skip transition".
</li>
	<li>
~IF［
%合致している規則 の `navigation$d 記述子の`算出d値$ ~EQ `none$vN
］
⇒
~RET `遷移を飛ばす^i
◎
If matchingRule’s navigation descriptor’s computed value is none, then return "skip transition".
</li>
	<li>
~Assert：
%合致している規則 の `navigation$d 記述子の`算出d値$ ~EQ `auto$vN
◎
Assert: matchingRule’s navigation descriptor’s computed value is auto.
</li>
	<li>
%型~群~記述子 ~LET %合致している規則 の `types$d 記述子の`算出d値$
◎
Let typesDescriptor be matchingRule’s types descriptor.
</li>
	<li>
~IF［
%型~群~記述子 ~EQ `none^v
］
⇒
~RET 新たな`有順序~集合$
◎
If typesDescriptor’s computed value is none, then return a set « ».
</li>
	<li>
<p>
~RET %型~群~記述子 を成す文字列たちが成す`有順序~集合$
◎
Return a set of strings corresponding to typesDescriptor’s computed value.
</p>

<p class="trans-note">【
集合なので、
重複する文字列たちは，一つ（おそらく，最初のそれ）だけ残して他は除去されることになる。
】</p>

	</li>
</ol>
</div>

		</section>
		<section id="setup-view-transition-algorithm">
<h3 title="Setup single-document view transition">13.4. 同一-文書な~view遷移を設定しておく</h3>

<div class="algo">
<p>
`~view遷移を設定しておく@
~algoは、
所与の
( `ViewTransition$I %遷移 )
に対し：
◎
To setup view transition for a ViewTransition transition, perform the following steps:
</p>

<p class="note">注記：
この~algoは、
次を順に行う
⇒＃
文書を成す現在の状態を捕捉する,
%遷移 の`更新~callback$vT【！ViewTransitionUpdateCallback】を~callする,
文書を成す新-状態を捕捉する
◎
Note: This algorithm captures the current state of the document, calls the transition’s ViewTransitionUpdateCallback, then captures the new state of the document.
</p>
<ol>
	<li>
%文書 ~LET %遷移 に`関連な大域~obj$に`結付けられた文書$
◎
Let document be transition’s relevant global object’s associated document.
</li>
	<li>
<p>
`更新~callback~queueを一掃する$( 【 %文書 】 )
◎
Flush the update callback queue.
</p>

<p class="note">注記：
これは、
次を確保する
⇒
他の飛ばされた遷移により~scheduleされた~DOMに対する変更は、
この遷移~用の旧-状態が捕捉される前に行われる。
◎
Note: this ensures that any changes to the DOM scheduled by other skipped transitions are done before the old state for this transition is captured.
</p>
	</li>
	<li>
%成否 ~LET `旧-状態を捕捉する$( %遷移 )
◎
Capture the old state for transition.
</li>
	<li>
~IF［
%成否 ~EQ `失敗^i
］
⇒＃
`~view遷移を飛ばす$( %遷移, "`InvalidStateError$E" )；
~RET
◎
If failure is returned, then skip the view transition for transition with an "InvalidStateError" DOMException in transition’s relevant Realm, and return.
</li>
	<li>
%文書 の`~view遷移~用の描画を抑止するか$doc ~SET ~T
◎
Set document’s rendering suppression for view transitions to true.
</li>
	<li>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %遷移 に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the DOM manipulation task source, given transition’s relevant global object,＼
↓ to perform the following steps:
</p>

<p class="note">注記：
ここで~taskを~queueするのは、［
`画像を捕捉する$ときに読み戻される `texture^en
］は，非同期cである場合もあるからである
— ~HTML仕様における描画-手続きは、
それは同期的であったかのように動作するが。
◎
Note: A task is queued here because the texture read back in capturing the image may be async, although the render steps in the HTML spec act as if it’s synchronous.
</p>
<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
<p>
~IF［
%遷移 の`相$vT ~EQ `済み$i
］
⇒
~RET
◎
If transition’s phase is "done", then abort these steps.
</p>

<p class="note">注記：
これは、
この時点より前に %遷移 が`飛ばされ$た場合に起こる。
◎
Note: This happens if transition was skipped before this point.
</p>
			</li>
			<li>
`更新~callbackを~scheduleする$( %遷移 )
◎
schedule the update callback for transition.
</li>
			<li>
`更新~callback~queueを一掃する$( 【 %文書 】 )
◎
Flush the update callback queue.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~view遷移を作動化する@
~algoは、
所与の
( `ViewTransition$I %遷移 )
に対し：
◎
To activate view transition for a ViewTransition transition, perform the following steps:
</p>
<ol>
	<li>
<p>
~IF［
%遷移 の`相$vT ~EQ `済み$i
］
⇒
~RET
◎
If transition’s phase is "done", then return.
</p>

<p class="note">注記：
これは、
この時点より前に %遷移 が`飛ばされ$た場合に起こる。
◎
Note: This happens if transition was skipped before this point.
</p>
	</li>
	<li>
%遷移 に`関連な大域~obj$に`結付けられた文書$の`~view遷移~用の描画を抑止するか$doc ~SET ~F
◎
Set transition’s relevant global object’s associated document’s rendering suppression for view transitions to false.
</li>
	<li>
~IF［
%遷移 の`初期~snapshot包含塊~size$vT ~NEQ `~snapshot包含塊の~size$
］
⇒＃
`~view遷移を飛ばす$( %遷移, "`InvalidStateError$E" )；
~RET
◎
If transition’s initial snapshot containing block size is not equal to the snapshot containing block size, then skip transition with an "InvalidStateError" DOMException in transition’s relevant Realm, and return.
</li>
	<li>
%成否 ~LET `新-状態を捕捉する$( %遷移 )
◎
Capture the new state for transition.
</li>
	<li>
~IF［
%成否 ~EQ `失敗^i
］
⇒＃
`~view遷移を飛ばす$( %遷移, "`InvalidStateError$E" )；
~RET
◎
If failure is returned, then skip transition with an "InvalidStateError" DOMException in transition’s relevant Realm, and return.
</li>
	<li>
<p>
%遷移 の`有名~要素~群$vTの`値~群$mapを成す
~EACH( %捕捉された要素 )
に対し：
</p>
		<ol>
			<li>
%新-要素 ~LET %捕捉された要素 の`新-要素$cE
</li>
			<li>
~IF［
%新-要素 ~EQ ~NULL
］
⇒
~CONTINUE
</li>
			<li>
%新-要素 の`ある~view遷移~内に捕捉されたか$el ~SET ~T
</li>
		</ol>
◎
For each capturedElement of transition’s named elements' values:
• If capturedElement’s new element is not null, then set capturedElement’s new element’s captured in a view transition to true.
</li>
	<li>
`遷移~疑似要素たちを設定しておく$( %遷移 )
◎
Setup transition pseudo-elements for transition.
</li>
	<li>
%成否 ~LET `疑似要素~styleを更新する$( %遷移 )
◎
Update pseudo-element styles for transition.
</li>
	<li>
<p>
~IF［
%成否 ~EQ `失敗^i
］
⇒＃
`~view遷移を飛ばす$( %遷移, "`InvalidStateError$E" )；
~RET
◎
If failure is returned, then skip the view transition for transition with an "InvalidStateError" DOMException in transition’s relevant Realm, and return.
</p>

<p class="note">注記：
上の手続きは、［
~style／~layout
］の間に計算される情報を算出するため，
文書~lifecycle相を走らす【？】ことを要求することになる。
◎
Note: The above steps will require running document lifecycle phases, to compute information calculated during style/layout.
</p>
	</li>
	<li>
%遷移 の`相$vT ~SET `~animate中$i
◎
Set transition’s phase to "animating".
</li>
	<li>
`~promiseを解決する$( %遷移 の`準備済み時の~promise$vT )
◎
Resolve transition’s ready promise.
</li>
</ol>
</div>

			<section id="capture-old-state-algorithm">
<h4 title="Capture the old state">13.4.1. 旧-状態を捕捉する</h4>

<div class="algo">
<p>
`旧-状態を捕捉する@
~algoは、
所与の
( `ViewTransition$I %遷移 )
に対し：
◎
To capture the old state for ViewTransition transition:
</p>
<ol>
	<li>
%文書 ~LET %遷移 に`関連な大域~obj$に`結付けられた文書$
◎
Let document be transition’s relevant global object’s associated document.
</li>
	<li>
%有名~要素~群 ~LET %遷移 の`有名~要素~群$vT
◎
Let namedElements be transition’s named elements.
</li>
	<li>
%捕捉~要素~群 ~LET 新たな`有順序~map$
◎
Let usedTransitionNames be a new set of strings.
◎
Let captureElements be a new list of elements.
</li>
	<li>
~IF［
`~snapshot包含塊の~size$は`実装定義$な最大を超過する
］
⇒
~RET `失敗^i
◎
If the snapshot containing block size exceeds an implementation-defined maximum, then return failure.
</li>
	<li>
%遷移 の`初期~snapshot包含塊~size$vT ~SET `~snapshot包含塊の~size$
◎
Set transition’s initial snapshot containing block size to the snapshot containing block size.
</li>
	<li>
<div>
<p>
~AND↓ を満たす
~EACH( `要素$ %要素 )
に対し…
◎
For each element of every element＼
</p>
		<ul>
			<li>
`接続されて$いる
◎
that is connected,＼
</li>
			<li>
その`~node文書$ ~EQ %文書
◎
and has a node document equal to document,＼
↓ in paint order:
◎
↓ Note: We iterate in paint order to ensure that this order is cached in namedElements. This defines the DOM order for ::view-transition-group pseudo-elements, such that the element at the bottom of the paint stack generates the first pseudo child of ::view-transition.
</li>
			<li>
`平坦~tree$における その先祖として`内容を飛ばす$ものは無い
◎
If any flat tree ancestor of this element skips its contents, then continue.
</li>
			<li>
`平坦~tree$における その`広義-先祖$として次を満たすものは無い
⇒
［
`平坦~tree$における %遷移 の`根~要素$vTの子孫である
］~AND［
その `contain$p ~propは `view-transition$v を含んでいない
］
◎
If any flat tree inclusive ancestor of this element, up to but not including transition’s root element, has contain: view-transition, continue.
</li>
			<li>
<p>
複数個の`~box断片$を有さない
◎
If element has more than one box fragment, then continue.
</p>

<p class="note">注記：
将来~versionにおいては、
断片化された要素~用にも遷移を可能化するよう求まれるかもしれない。
`8900$issue を見よ。
◎
Note: We might want to enable transitions for fragmented elements in future versions. See #8900.
</p>

<p class="note">注記：
ここでの`~box断片$は、
複数の`行l~box$にまたがる`行内~box$の断片化も参照rするものではない。
そのような行内は、
遷移に関与し得る。
◎
Note: box fragment here does not refer to fragmentation of inline boxes across line boxes. Such inlines can participate in a transition.
</p>
			</li>
			<li>
その`文書~視野な~view遷移~名$ ~NEQ `none$v
◎
Let transitionName be the element’s document-scoped view transition name.
◎
If transitionName is none,＼
</li>
			<li>
`描画され$る
◎
or element is not rendered, then continue.
</li>
		</ul>
<p>
…に対し，`塗り順序$で：
◎
↑</p>

<p class="note">注記：
塗り順序で反復するのは、［
その順序が【 %捕捉~要素~群 を介して】 %有名~要素~群 に~cacheされる
］ことを確保するためである。
この順序は、
`view-transition-group^pe 疑似要素~用の~DOM順序を定義する
— 塗り~stackの下端にある要素が，
`view-transition^pe の最初の子である疑似要素を生成するよう。
◎
↑</p>
</div>
		<ol>
			<li>
%遷移~名 ~LET %要素 の`文書~視野な~view遷移~名$
◎
↑</li>
			<li>
<p>
~IF［
%捕捉~要素~群[ %遷移~名 ] ~NEQ ε
］：
◎
If usedTransitionNames contains transitionName, then:
</p>
				<ol>
					<li>
%捕捉~要素~群 の`値~群$mapを成す
~EACH( %値 )
に対し
⇒
%値 の`ある~view遷移~内に捕捉されたか$el ~SET ~F
◎
For each element in captureElements:
• Set element’s captured in a view transition to false.
</li>
					<li>
~RET `失敗^i
◎
Return failure.
</li>
				</ol>
			</li>
			<li>
［
%文書 にて`作動中な~view遷移$doc,
%文書 内の各~要素にて`作動中な~view遷移$elたち
］のうち ~NULL でないものたちを成す
~EACH( %~view遷移 )
に対し，それらの`根~要素$vTの`~tree順序$で
⇒
~IF［
%~view遷移 ~NEQ %遷移
］~AND［
%~view遷移 は その`捕捉された要素$内に %要素 を包含する
【 “包含する” とは、たぶん，`捕捉された要素$の`新-要素$cE ~EQ %要素 を意味する】
］
⇒
`~view遷移を飛ばす$( %~view遷移, "`AbortError$E" )
◎
If any other active view transition contains element in its captured elements, then for each such active view transition, in tree order of their corresponding root elements, skip that view transition with an "AbortError" DOMException in document’s relevant Realm.
</li>
			<li>
%要素 の`ある~view遷移~内に捕捉されたか$el ~SET ~T
◎
↓ Append transitionName to usedTransitionNames.
◎
Set element’s captured in a view transition to true.
</li>
			<li>
%捕捉~要素~群[ %遷移~名 ] ~SET %要素
◎
Append element to captureElements.
</li>
		</ol>

<p class="note">注記：
以下において，この~algoを別々な~loop内で継続するのは、
この捕捉に関与しているすべての要素に対し［
それらの`ある~view遷移~内に捕捉されたか$elが，
後の段において
【`画像を捕捉する$中で`描画~特性を捕捉する$ときに】
読取られる前に設定される
］ことを確保するためである。
◎
The algorithm continues in a separate loop to ensure that captured in a view transition is set on all elements participating in this capture before it is read by future steps in the algorithm.
</p>
	</li>
	<li>
<p>
%捕捉~要素~群 を成す
~EACH( %遷移~名 → %要素 )
に対し：
◎
For each element in captureElements:
</p>
		<ol>
			<li>
%捕捉 ~LET 新たな`捕捉された要素$
◎
Let capture be a new captured element struct.
</li>
			<li>
%捕捉 の`旧-画像$cE ~SET `画像を捕捉する$( %要素 )
◎
Set capture’s old image to the result of capturing the image of element.
</li>
			<li>
%元の矩形 ~LET ［
%要素 ~EQ %文書 の`文書~要素$ならば`~snapshot包含塊$／
~ELSE_ %要素 の`~border~box$
］
◎
Let originalRect be snapshot containing block if element is the document element, otherwise, the element’s border box.
</li>
			<li>
%捕捉 の`旧-横幅$cE ~SET %元の矩形 の `width$m
◎
Set capture’s old width to originalRect’s width.
</li>
			<li>
%捕捉 の`旧-縦幅$cE ~SET %元の矩形 の `height$m
◎
Set capture’s old height to originalRect’s height.
</li>
			<li>
%捕捉 の`旧-変形$cE ~SET 次を満たす変形を与える `transform-function$t
⇒
%要素 の`~border~box$を`~snapshot包含塊の原点$から `its^en【？】 現在の視覚的な位置へ対応付けることになる
◎
Set capture’s old transform to a &lt;transform-function&gt; that would map element’s border box from the snapshot containing block origin to its current visual position.
</li>
			<li>
%捕捉 の`旧-書字~mode$cE ~SET %要素 の `writing-mode$p の`算出d値$
◎
Set capture’s old writing-mode to the computed value of writing-mode on element.
</li>
			<li>
%捕捉 の`旧-方向$cE ~SET %要素 の `direction$p の`算出d値$
◎
Set capture’s old direction to the computed value of direction on element.
</li>
			<li>
%捕捉 の`旧-~text方位$cE ~SET %要素 の `text-orientation$p の`算出d値$
◎
Set capture’s old text-orientation to the computed value of text-orientation on element.
</li>
			<li>
%捕捉 の`旧-混色~mode$cE ~SET %要素 の `mix-blend-mode$p の`算出d値$
◎
Set capture’s old mix-blend-mode to the computed value of mix-blend-mode on element.
</li>
			<li>
%捕捉 の`旧-後景~filter$cE ~SET %要素 の `backdrop-filter$p の`算出d値$
◎
Set capture’s old backdrop-filter to the computed value of backdrop-filter on element.
</li>
			<li>
%捕捉 の`旧-色~scheme$cE ~SET %要素 の `color-scheme$p の`算出d値$
◎
Set capture’s old color-scheme to the computed value of color-scheme on element.
</li>
			<li>
%有名~要素~群[ %遷移~名 ] ~SET %捕捉
◎
Let transitionName be the computed value of view-transition-name for element.
◎
Set namedElements[transitionName] to capture.
</li>
		</ol>
	</li>
	<li>
%捕捉~要素~群 の`値~群$mapを成す
~EACH( %要素 )
に対し
⇒
%要素 の`ある~view遷移~内に捕捉されたか$el ~SET ~F
◎
For each element in captureElements:
• Set element’s captured in a view transition to false.
</li>
	<li>
~RET `成功^i
◎
↑↑</li>
</ol>
</div>

			</section>
			<section id="capture-new-state-algorithm">
<h4 title="Capture the new state">13.4.2. 新-状態を捕捉する</h4>

<div class="algo">
<p>
`新-状態を捕捉する@
~algoは、
所与の
( `ViewTransition$I %遷移 )
に対し：
◎
To capture the new state for ViewTransition transition:
</p>
<ol>
	<li>
%文書 ~LET %遷移 に`関連な大域~obj$に`結付けられた文書$
◎
Let document be transition’s relevant global object’s associated document.
</li>
	<li>
%有名~要素~群 ~LET %遷移 の`有名~要素~群$vT
◎
Let namedElements be transition’s named elements.
</li>
	<li>
%遷移~名~群 ~LET 新たな`集合$【！ of strings】
◎
Let usedTransitionNames be a new set of strings.
</li>
	<li>
<div>
<p>
~AND↓ を満たす
~EACH( `要素$ %要素 )
に対し…
</p>
		<ul>
			<li>
`接続されて$いる
</li>
			<li>
その`~node文書$ ~EQ %文書
</li>
			<li>
`平坦~tree$における その先祖として`内容を飛ばす$ものは無い
</li>
			<li>
その`文書~視野な~view遷移~名$ ~NEQ `none$v
</li>
			<li>
`描画され$る
</li>
			<li>
複数個の`~box断片$を有さない
</li>
		</ul>
<p>
…に対し，`塗り順序$で：
</p>
◎
For each element of every element that is connected, and has a node document equal to document, in paint order:
• If any flat tree ancestor of this element skips its contents, then continue.
• Let transitionName be element’s document-scoped view transition name.
• If transitionName is none, or element is not rendered, then continue.
• If element has more than one box fragment, then continue.
</div>
		<ol>
			<li>
%遷移~名 ~LET %要素 の`文書~視野な~view遷移~名$
◎
↑</li>
			<li>
~IF［
%遷移~名 ~IN %遷移~名~群
］
⇒
~RET `失敗^i
◎
If usedTransitionNames contains transitionName, then return failure.
</li>
			<li>
%遷移~名~群 に %遷移~名 を`付加する$set
◎
Append transitionName to usedTransitionNames.
</li>
			<li>
<p>
~IF［
%有名~要素~群[ %遷移~名 ] ~EQ ε
］
⇒
%有名~要素~群[ %遷移~名 ] ~SET 新たな`捕捉された要素$
◎
If namedElements[transitionName] does not exist, then set namedElements[transitionName] to a new captured element struct.
</p>

<p class="note">注記：
この構造体を %有名~要素~群【！this ordered map】 の終端に追加するのは意図的である。
これは、
新-~DOM内にしか存在しない名前
【† `view-transition-name$p に当の名前を指定した要素（以下同様）】
（入口~animation）たちは，［
旧-~DOM内の名前（出口~animation）,
両~DOM内の名前（~pairにされた~animation）
］すべての上層にしか塗られないことを含意する【！誤 than → that】。
このような層の重ね方は、
事例によっては~~正しいとは言えないかもしれない。
`8941$issue を見よ。
◎
Note: We intentionally add this struct to the end of this ordered map. This implies than names which only exist in the new DOM (entry animations) will be painted on top of names only in the old DOM (exit animations) and names in both DOMs (paired animations). This might not be the right layering for all cases. See issue 8941.
</p>
			</li>
			<li>
%有名~要素~群[ %遷移~名 ] の`新-要素$cE ~SET %要素
◎
Set namedElements[transitionName]'s new element to element.
</li>
		</ol>
	</li>
	<li>
~RET `成功^i
◎
↑↑</li>
</ol>
</div>

			</section>
			<section id="setup-transition-pseudo-elements-algorithm">
<h4 title="Setup transition pseudo-elements">13.4.3. 遷移~疑似要素たちを設定しておく</h4>

<div class="algo">
<p>
`遷移~疑似要素たちを設定しておく@
~algoは、
所与の
( `ViewTransition$I %遷移 )
に対し：
◎
To setup transition pseudo-elements for a ViewTransition transition:
</p>

<p class="note">注記：
この~algoは、
遷移~用に疑似要素~treeを構築して，それらの初期~styleを生成する。
疑似要素~treeを成す構造は、
より高い~levelでは
`§ ~view遷移~用の疑似要素＠#view-transition-pseudos$が受持つ。
◎
Note: This algorithm constructs the pseudo-element tree for the transition, and generates initial styles. The structure of the pseudo-tree is covered at a higher level in § 3.2 View Transition Pseudo-elements.
</p>
<ol>
	<li>
%文書 ~LET コレに`関連な大域~obj$に`結付けられた文書$
◎
Let document be this’s relevant global object’s associated document.
</li>
	<li>
%文書 の`~view遷移~treeを示すか$doc ~SET ~T
◎
Set document’s show view transition tree to true.
</li>
	<li>
<p>
%遷移 の`有名~要素~群$vTを成す
~EACH( %遷移~名 → %捕捉された要素 )
に対し：
◎
For each transitionName → capturedElement of transition’s named elements:
</p>
		<ol>
			<li>
%~group ~LET 新たな `view-transition-group()$pe
— その
⇒＃
`~view遷移~名$ ~SET %遷移~名
◎
Let group be a new ::view-transition-group(), with its view transition name set to transitionName.
</li>
			<li>
%遷移 の`遷移~根~疑似要素$vTに【その子として】 %~group を付加する
◎
Append group to transition’s transition root pseudo-element.
</li>
			<li>
%画像~pair ~LET 新たな `view-transition-image-pair()$pe
— その
⇒＃
`~view遷移~名$ ~SET %遷移~名
◎
Let imagePair be a new ::view-transition-image-pair(), with its view transition name set to transitionName.
</li>
			<li>
%~group に【その子として】 %画像~pair を付加する
◎
Append imagePair to group.
</li>
			<li>
<p>
~IF［
%捕捉された要素 の`旧-画像$cE ~NEQ ~NULL
］：
◎
If capturedElement’s old image is not null, then:
</p>
				<ol>
					<li>
%旧- ~LET 新たな `view-transition-old()$pe
— その
⇒＃
`~view遷移~名$ ~SET %遷移~名,
`置換され$る内容 ~SET %捕捉された要素 の`旧-画像$cE
◎
Let old be a new ::view-transition-old(), with its view transition name set to transitionName, displaying capturedElement’s old image as its replaced content.
</li>
					<li>
%画像~pair に【その子として】 %旧- を付加する
◎
Append old to imagePair.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%捕捉された要素 の`新-要素$cE ~NEQ ~NULL
］：
◎
If capturedElement’s new element is not null, then:
</p>
				<ol>
					<li>
<p>
%新- ~LET 新たな `view-transition-new()$pe
— その
⇒＃
`~view遷移~名$ ~SET %遷移~名
◎
Let new be a new ::view-transition-new(), with its view transition name set to transitionName.
</p>

<p class="note">注記：
この疑似要素の~style付けは、
`疑似要素~styleを更新する$ときに取扱われる。
◎
Note: The styling of this pseudo is handled in update pseudo-element styles.
</p>
					</li>
					<li>
%画像~pair に【その子として】 %新- を付加する
◎
Append new to imagePair.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%捕捉された要素 の`旧-画像$cE ~EQ ~NULL
］：
◎
If capturedElement’s old image is null, then:
</p>
				<ol>
					<li>
~Assert：
%捕捉された要素 の`新-要素$cE ~NEQ ~NULL
◎
Assert: capturedElement’s new element is not null.
</li>
					<li>
%捕捉された要素 の`画像~animation名~規則$cE ~SET ［
下に与える~CSS
］を表現している新たな `CSSStyleRule$I
◎
Set capturedElement’s image animation name rule to a new CSSStyleRule representing the following CSS,＼
</li>
					<li>
%文書 の`動的な~view遷移~stylesheet$docに［
下に与える~CSS
］を付加する
◎
and append it to document’s dynamic view transition style sheet:
</li>
				</ol>
<p>
上で利用される~CSSは：
◎
↑</p>

<pre class="lang-css">
:root::view-transition-new(%遷移~名) {
  animation-name: -ua-view-transition-fade-in;
}
</pre>

<p class="note">注記：
この~CSSは、
置換されることになる変数を包含する。
◎
Note: The above code example contains variables to be replaced.
</p>
			</li>
			<li>
<p>
~IF［
%捕捉された要素 の`新-要素$cE ~EQ ~NULL
］：
◎
If capturedElement’s new element is null, then:
</p>
				<ol>
					<li>
~Assert：
%捕捉された要素 の`旧-画像$cE ~NEQ ~NULL
◎
Assert: capturedElement’s old image is not null.
</li>
					<li>
%捕捉された要素 の`画像~animation名~規則$cE ~SET ［
下に与える~CSS
］を表現している新たな `CSSStyleRule$I
◎
Set capturedElement’s image animation name rule to a new CSSStyleRule representing the following CSS,＼
</li>
					<li>
%文書 の`動的な~view遷移~stylesheet$docに［
下に与える~CSS
］を付加する
◎
and append it to document’s dynamic view transition style sheet:
</li>
				</ol>

<p>
上で利用される~CSSは：
◎
↑</p>

<pre class="lang-css">
:root::view-transition-old(%遷移~名) {
  animation-name: -ua-view-transition-fade-out;
}
</pre>

<p class="note">注記：
この~CSSは、
置換されることになる変数を包含する。
◎
Note: The above code example contains variables to be replaced.
</p>
			</li>
			<li>
<p>
~IF［
%捕捉された要素 の`旧-画像$cE ~NEQ ~NULL
］~AND［
`新-要素$cE ~NEQ ~NULL
］：
◎
If both of capturedElement’s old image and new element are not null, then:
</p>
				<ol>
					<li>
%変形 ~LET %捕捉された要素 の`旧-変形$cE
◎
Let transform be capturedElement’s old transform.
</li>
					<li>
%横幅 ~LET %捕捉された要素 の`旧-横幅$cE
◎
Let width be capturedElement’s old width.
</li>
					<li>
%縦幅 ~LET %捕捉された要素 の`旧-縦幅$cE
◎
Let height be capturedElement’s old height.
</li>
					<li>
%後景~filter ~LET %捕捉された要素 の`旧-後景~filter$cE
◎
Let backdropFilter be capturedElement’s old backdrop-filter.
</li>
					<li>
<p>
：
</p>
						<ol>
							<li>
%捕捉された要素 の`~group~keyframe群$cE ~SET ［
下に与える~CSS
］を表現している新たな `CSSKeyframesRule$I
◎
Set capturedElement’s group keyframes to a new CSSKeyframesRule representing the following CSS,＼
</li>
							<li>
%文書 の`動的な~view遷移~stylesheet$docに［
下に与える~CSS
］を付加する
◎
and append it to document’s dynamic view transition style sheet:
</li>
						</ol>

<p>
上で利用される~CSSは：
◎
↑</p>

<pre class="lang-css">
@keyframes -ua-view-transition-group-anim-%遷移~名 {
  from {
    transform: %変形;
    width: %横幅;
    height: %縦幅;
    backdrop-filter: %後景~filter;
  }
}
</pre>

<p class="note">注記：
この~CSSは、
置換されることになる変数を包含する。
◎
Note: The above code example contains variables to be replaced.
</p>
					</li>
					<li>
<p>
：
</p>
						<ol>
							<li>
%捕捉された要素 の`~group~animation名~規則$cE ~SET ［
下に与える~CSS
］を表現している新たな `CSSStyleRule$I
◎
Set capturedElement’s group animation name rule to a new CSSStyleRule representing the following CSS,＼
</li>
							<li>
%文書 の`動的な~view遷移~stylesheet$docに［
下に与える~CSS
］を付加する
◎
and append it to document’s dynamic view transition style sheet:
</li>
						</ol>

<p>
上で利用される~CSSは：
◎
↑</p>

<pre class="lang-css">
:root::view-transition-group(%遷移~名) {
  animation-name: -ua-view-transition-group-anim-%遷移~名;
}
</pre>

<p class="note">注記：
この~CSSは、
置換されることになる変数を包含する。
◎
Note: The above code example contains variables to be replaced.
</p>
					</li>
					<li>
<p>
：
</p>
						<ol>
							<li>
%捕捉された要素 の`画像~pair隔離~規則$cE ~SET ［
下に与える~CSS
］を表現している新たな `CSSStyleRule$I
◎
Set capturedElement’s image pair isolation rule to a new CSSStyleRule representing the following CSS,＼
</li>
							<li>
%文書 の`動的な~view遷移~stylesheet$docに［
下に与える~CSS
］を付加する
◎
and append it to document’s dynamic view transition style sheet:
</li>
						</ol>
<p>
上で利用される~CSSは：
◎
↑</p>

<pre class="lang-css">
:root::view-transition-image-pair(%遷移~名) {
  isolation: isolate;
}
</pre>

<p class="note">注記：
この~CSSは、
置換されることになる変数を包含する。
◎
Note: The above code example contains variables to be replaced.
</p>
					</li>
					<li>
<p>
：
</p>
						<ol>
							<li>
%捕捉された要素 の`画像~animation名~規則$cE ~SET ［
下に与える~CSS
］を表現している新たな `CSSStyleRule$I
◎
Set capturedElement’s image animation name rule to a new CSSStyleRule representing the following CSS,＼
</li>
							<li>
%文書 の`動的な~view遷移~stylesheet$docに［
下に与える~CSS
］を付加する
◎
and append it to document’s dynamic view transition style sheet:
</li>
						</ol>
<p>
上で利用される~CSSは：
◎
↑</p>

<pre class="lang-css">
:root::view-transition-old(%遷移~名) {
  animation-name: -ua-view-transition-fade-out, -ua-mix-blend-mode-plus-lighter;
}
:root::view-transition-new(%遷移~名) {
  animation-name: -ua-view-transition-fade-in, -ua-mix-blend-mode-plus-lighter;
}
</pre>

<p class="note">注記：
この~CSSは、
置換されることになる変数を包含する。
◎
Note: The above code example contains variables to be replaced.
</p>

<p class="note">注記：
`mix-blend-mode$p 用の値 `plus-lighter$v は、
旧-画像と新-画像において色~値が一致する画素を混色した結果が~~元と同じになり，
“正しい” ~cross-fadeを達成することを確保する。
◎
Note: mix-blend-mode: plus-lighter ensures that the blending of identical pixels from the old and new images results in the same color value as those pixels, and achieves a “correct” cross-fade.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

			</section>
		</section>
		<section id="setup-crossdoc-view-transition-algo">
<h3 title="Setup cross-document view transition">13.5. 非同一-文書な~view遷移を設定しておく</h3>

			<section id="setup-old-document-vt">
<h4 title="Setting up the view transition in the old Document">13.5.1. 旧-文書~内で~view遷移を設定しておく</h4>

				<section id="check-eligibility">
<h5 title="Check eligibility for outbound cross-document view transition">13.5.1.1. 外へ出る非同一-文書な~view遷移の適格~性を検査する</h5>

<div class="algo">
<p>
`~naviは非同一-文書な~view遷移を誘発し得るか？@
検査する~algoは、
所与の
⇒＃
`文書$ %旧-文書,
`文書$ %新-文書,
`NavigationType$I %~navi種別,
真偽値 %~browser~UIによる~naviか
◎終
に対し：
◎
To check if a navigation can trigger a cross-document view-transition? given a Document oldDocument, a Document newDocument, a NavigationType navigationType, and a boolean isBrowserUINavigation:
</p>

<p class="note">注記：
これは、
~naviの間に［
~callされる／`並列的$に~callされる
］。
◎
Note: this is called during navigation, potentially in parallel.
</p>

<ol>
	<li>
任意選択で
⇒
~IF［
~UAは`実装定義$な~navi体験を表示するものと裁定した
（例： ~gestureに基づく後戻りする~navi用の遷移）
］
⇒
~RET ~F
（~UAは作者-定義な~view遷移を無視してもヨイ。）
◎
If the user agent decides to display an implementation-defined navigation experience, e.g. a gesture-based transition for a back navigation, the user agent may ignore the author-defined view transition. If that is the case, return false.
</li>
	<li>
~IF［
%旧-文書 の`外へ出る~view遷移を起動できるか$doc ~EQ ~F
］
⇒
~RET ~F
◎
If oldDocument’s can initiate outbound view transition is false, then return false.
</li>
	<li>
~IF［
%~navi種別 ~EQ `reload$l
］
⇒
~RET ~F
◎
If navigationType is reload, then return false.
</li>
	<li>
~IF［
( %旧-文書 の`生成元$doc, %新-文書 の`生成元$doc )
は`同一-生成元$でない
］
⇒
~RET ~F
◎
If oldDocument’s origin is not same origin as newDocument’s origin, then return false.
</li>
	<li>
<p>
~IF［
%新-文書 の`非同一-生成元~redirectを介して作成されたか$doc ~EQ ~T
］~AND［
%新-文書 の`最近の~entry$ ~EQ ~NULL
］
⇒
~RET ~F
◎
If newDocument was created via cross-origin redirects and newDocument’s latest entry is null, then return false.
</p>

<p class="note">注記：
`最近の~entry$は、
%新-文書 が［
`~BF~cache$から復旧されたものではなく，新たな~naviによるものである場合
］には ~NULL になる。
◎
Note: A Document’s latest entry would be null if this is a new navigation, rather than a restore from BFCache.
</p>
	</li>
	<li>
~IF［
%~navi種別 ~EQ `traverse$l
］
⇒
~RET ~T
◎
If navigationType is traverse, then return true.
</li>
	<li>
~IF［
%~browser~UIによる~naviか ~EQ ~T
］
⇒
~RET ~F
◎
If isBrowserUINavigation is true, then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

				</section>
				<section id="setup-outbound-transition">
<h5 title="Setup the outbound transition when ready to swap pages">13.5.1.2. ~pageが切替わるに準備済みなとき外へ出る遷移を設定しておく</h5>

<div class="algo">
<p>
`非同一-文書な~view遷移を設定しておく@
~algoは、
所与の
⇒＃
`文書$ %旧-文書,
`文書$ %新-文書,
~algo %~naviで続行する手続き
◎終
に対し：
◎
To setup cross-document view-transition given a Document oldDocument, a Document newDocument, and proceedWithNavigation, which is an algorithm accepting nothing: 
</p>

<p class="note">注記：
これは、
~HTML仕様から~callされる。
◎
Note: This is called from the HTML spec.
</p>

<ol>
	<li>
~Assert：
この手続きは、
%旧-文書 に対し~queueされた`~task$を成す一部として走っている。
◎
Assert: These steps are running as part of a task queued on oldDocument.
</li>
	<li>
~IF［
%旧-文書 の`外へ出る~view遷移を起動できるか$doc ~EQ ~F
］
⇒
~RET ~NULL
◎
If oldDocument’s can initiate outbound view transition is false, then return null.
</li>
	<li>
%規則からの遷移~型~群 ~LET `~view遷移~規則を解決する$( %旧-文書 )
◎
Let transitionTypesFromRule be the result of resolving the @view-transition rule for oldDocument.
</li>
	<li>
<p>
~Assert：
%規則からの遷移~型~群 ~NEQ `遷移を飛ばす^i
◎
Assert: transitionTypesFromRule is not "skip transition".
</p>

<p class="note">注記：
%新-文書 は，構文解析-済みでないかもしれないので、
それが~opt-inされたかどうかは，まだ知れない。
%新-文書 用に~opt-inを検査するのは、
`pagereveal$et ~eventが発火されたときになる。
◎
Note: We don’t know yet if newDocument has opted in, as it might not be parsed yet. We check the opt-in for newDocument when we fire the pagereveal event.
</p>
	</li>
	<li>
<p>
~IF［
%旧-文書 にて`作動中な~view遷移$doc ~NEQ~NULL
］
⇒
`~view遷移を飛ばす$( %旧-文書 にて`作動中な~view遷移$doc, %旧-文書 に`関連な~realm$に属する `AbortError$E 例外 )
◎
If oldDocument’s active view transition is not null, then skip oldDocument’s active view transition with an "AbortError" DOMException in oldDocument’s relevant Realm.
</p>

<p class="note">注記：
これは、
当の文書が~unloadするに準備済みなときは，
走っている遷移を飛ばすことを意味する。
◎
Note: this means that any running transition would be skipped when the document is ready to unload.
</p>
	</li>
	<li>
%外へ出る遷移 ~LET %旧-文書 に`関連な~realm$に属する新たな `ViewTransition$I ~obj
◎
Let outboundTransition be a new ViewTransition object in oldDocument’s relevant Realm.
</li>
	<li>
<p>
%外へ出る遷移 にて`作動中な型~群$vT ~SET %規則からの遷移~型~群
◎
Set outboundTransition’s active types to transitionTypesFromRule.
</p>

<p class="note">注記：
`作動中な型~群$vTは、
文書~間では共有されない。
新-文書 【 %旧-文書 ？】内の `types$m を操作しても， %新-文書 内の型たちには影響しない
— それは、
%新-文書 が`露呈され$たなら，
`types$d 記述子から読取られることになる。
◎
Note: the active types are not shared between documents. Manipulating the types in the new document does not affect the types in newDocument, which would be read from the types descriptor once newDocument is revealed.
</p>

<p class="note">注記：
%外へ出る遷移【！the ViewTransition】 は、
%旧-文書 が非可視になったなら飛ばされる。
◎
Note: the ViewTransition is skipped once the old document is hidden.
</p>

	</li>
	<li class="algo">
<p>
%外へ出る遷移 の`外へ出る捕捉-後の手続き$vT ~SET 所与の
( ［
`~view遷移~params$／ ~NULL
］ %~params )
に対し，次を遂行する手続き：
◎
Set outboundTransition’s outbound post-capture steps to the following steps given a view transition params-or-null params:
</p>
		<ol>
			<li>
<p>
%新-文書 の`内へ来る~view遷移~params$doc ~SET %~params
◎
Set newDocument’s inbound view transition params to params.
</p>

<p class="note">注記：
内へ来る遷移は、
`pagereveal$et ~eventを配送した後に作動化される
— この~event【用の~handler】において為された変異が捕捉された新-状態に適用されることを確保するため。
◎
Note: The inbound transition is activated after the dispatch of pagereveal to ensure mutations made in this event apply to the captured new state.
</p>
			</li>
			<li class="algo">
<p>
任意選択で，次の手続きを`並列的$に遂行する
— これは、
時間切れになったとき，当の遷移を飛ばすようにする：
◎
To skip the transition after a timeout, the user agent may perform the following steps in parallel:
</p>
				<ol>
					<li>
`実装定義$な`所要時間$を経るまで待機する
◎
Wait for an implementation-defined duration.
</li>
					<li>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %新-文書 に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the DOM manipulation task source given newDocument’s relevant global object to perform the following step:
</p>

<div class="algo">
手続きは
⇒
~IF［
%新-文書 の`内へ来る~view遷移~params$doc ~EQ %~params
］
⇒
%新-文書 の`内へ来る~view遷移~params$doc ~SET ~NULL
◎
• If newDocument’s inbound view transition params is params, then set newDocument’s inbound view transition params to null.
</div>
					</li>
				</ol>
			</li>
			<li>
%~naviで続行する手続き()
◎
Call proceedWithNavigation.
</li>
		</ol>
	</li>
	<li>
<p>
%旧-文書 にて`作動中な~view遷移$doc ~SET %外へ出る遷移
◎
Set oldDocument’s active view transition to outboundTransition.
</p>

<p class="note">注記：
以降の処理nは、
`処理待ち遷移~演算を遂行する$中で継続される。
◎
Note: The process continues in perform pending transition operations.
</p>
	</li>
	<li>
~RET %外へ出る遷移
◎
↓</li>
</ol>

<p>
~UAは、
【上の手続きを遂行したなら，】
直前に表示していた~frameを次に挙げる いずれか【早い方】までは表示するベキである：
◎
The user agent should display the currently displayed frame until either:
</p>
		<ul>
			<li>
%新-文書 に向けて `pagereveal$et ~eventが発火される時点
◎
The pagereveal event is fired.
</li>
			<li>
%新-文書 にて`作動中な~view遷移$docの`相$vT ~EQ `済み$i になった時点
◎
its active view transition’s phase is "done".
</li>
		</ul>

<p class="note">注記：
これは、［
旧-状態を表示してから新-状態を表示するまでの間、
意図されない明滅は生じない
］ことを確保して，遷移を滑らかに保つためである。
◎
Note: this is to ensure that there are no unintended flashes between displaying the old and new state, to keep the transition smooth.
◎
Return outboundTransition.
</p>
</div>

				</section>
				<section id="update-opt-in">
<h5 title="Update the opt-in flag to reflect the current state">13.5.1.3. 現在の状態を反映するよう~opt-in~flagを更新する</h5>

<div class="algo">
<p>
`外へ出る遷移~用の~opt-in状態を更新する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To update the opt-in state for outbound transitions for a Document document:
</p>
<ol>
	<li>
<p>
%文書 の`外へ出る~view遷移を起動できるか$doc ~SET ~IS ~AND↓：
</p>
		<ul>
			<li>
%文書 の`露呈されたか$doc ~EQ ~T
</li>
			<li>
`~view遷移~規則を解決する$( %文書 ) ~NEQ `遷移を飛ばす^i
</li>
		</ul>
◎
If document has been revealed, and the result of resolving the @view-transition rule is not "skip transition", then set document’s can initiate outbound view transition to true.
◎
Otherwise, set document’s can initiate outbound view transition to false.
</li>
</ol>
</div>

				</section>
				<section id="proceed-if-skipped">
<h5 title="Proceed with navigation if view transition is skipped">13.5.1.4. ~view遷移が飛ばされた場合に~naviと伴に続行する</h5>

<div class="algo">
<p>
`~level 1$ の`~view遷移を飛ばす$ ~algo【今や，この仕様に定義される】の末尾には、
所与の
( `ViewTransition$I %遷移 )
に対し，次を遂行する段を挿入する：
◎
Append the following steps to skip the view transition given a ViewTransition transition:
</p>
<ol>
	<li>
~IF［
%遷移 の`外へ出る捕捉-後の手続き$vT ~NEQ ~NULL
］
⇒
%遷移 の`外へ出る捕捉-後の手続き$vT( ~NULL )
◎
If transition’s outbound post-capture steps is not null, then run transition’s outbound post-capture steps with null.
</li>
</ol>

<p class="note">注記：
これは、
~monkey~patch方式で書かれており，
`~level 1$ 仕様が熟したときには，その~algoの中へ併合されることになる。
◎
Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</p>
</div>

				</section>
				<section id="cross-doc-after-capture">
<h5 title="Proceed with cross-document view transition after capturing the old state">13.5.1.5. 旧-状態を捕捉した後に非同一-文書な~view遷移と伴に続行する</h5>

<div class="algo">
<p>
`~level 1$ の`処理待ち遷移~演算を遂行する$
~algo【今や，この仕様に定義される】の先頭には、
所与の
( `文書$ %文書 )
に対し，次を遂行する段たちを挿入する：
◎
Prepend the following step to the Perform pending transition operations algorithm given a Document document:
</p>
<ol>
	<li>
%~view遷移 ~LET %文書 にて`作動中な~view遷移$doc
◎
↓</li>
	<li>
<p>
~IF［
%~view遷移 ~NEQ ~NULL
］~AND［
%~view遷移 の`外へ出る捕捉-後の手続き$vT ~NEQ ~NULL
］：
◎
If document’s active view transition is not null and its outbound post-capture steps is not null, then:
</p>
		<ol>
			<li>
~Assert：
%~view遷移 の`相$vT ~EQ `捕捉-待ち$i
◎
Assert: document’s active view transition’s phase is "pending-capture".
</li>
			<li>
%~view遷移~params ~LET ~NULL
◎
Let viewTransitionParams be null;
</li>
			<li>
%文書 の`~view遷移~用の描画を抑止するか$doc ~SET ~T
◎
Set document’s rendering suppression for view transitions to true.
</li>
			<li>
<p>
%結果 ~LET `旧-状態を捕捉する$( %遷移 )
</p>

<p class="issue">
ここでは，同期的に`旧-状態を捕捉する$が、
~~本当は，非同期的に行われる
— 要素を画像の中へ描画することは
同期的には行い得ないので。
これは、
`~level 1$ 仕様にて，もっと明示的に指定されるべきである。
</p>

◎
Though capture the old state appears here as a synchronous step, it is in fact an asynchronous step as rendering an element into an image cannot be done synchronously. This should be more explicit in the L1 spec.
◎
Capture the old state for transition.
</li>
			<li>
~IF［
%結果 ~EQ `成功^i
］
⇒
%~view遷移~params ~SET 新たな`~view遷移~params$
— その
⇒＃
`有名~要素$vTP ~SET %遷移 の`有名~要素~群$vTを`~cloneする$map,
`初期~snapshot包含塊~size$vTP ~SET %遷移 の`初期~snapshot包含塊~size$vT
◎
If this succeeded, then set viewTransitionParams to a new view transition params whose named elements is a clone of transition’s named elements, and whose initial snapshot containing block size is transition’s initial snapshot containing block size.
</li>
			<li>
%文書 の`~view遷移~用の描画を抑止するか$doc ~SET ~F
◎
Set document’s rendering suppression for view transitions to false.
</li>
			<li>
`外へ出る捕捉-後の手続き$vT( %~view遷移~params )
◎
Call transition’s outbound post-capture steps given viewTransitionParams.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
これは、
~monkey~patch方式で書かれており，
`~level 1$ 仕様が熟したときには，その~algoの中へ併合されることになる。
◎
Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</p>
</div>

				</section>
			</section>
			<section id="access-view-transition-in-new-doc">
<h4 title="Activating the view transition in the new Document">13.5.2. 新-文書における~view遷移の作動化-法</h4>

<div class="algo">
<p>
`内へ来る非同一-文書な~view遷移を解決する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To resolve inbound cross-document view-transition for Document document:
</p>
<ol>
	<li>
~Assert：
%文書 は`全部的に作動中$である。
◎
Assert: document is fully active.
</li>
	<li>
~Assert：
%文書 の`露呈されたか$doc ~EQ ~T
◎
Assert: document has been revealed is true.
</li>
	<li>
`外へ出る遷移~用の~opt-in状態を更新する$( %文書 )
◎
Update the opt-in state for outbound transitions for document.
</li>
	<li>
%内へ来る~view遷移~params ~LET %文書 の`内へ来る~view遷移~params$doc
◎
Let inboundViewTransitionParams be document’s inbound view transition params.
</li>
	<li>
~IF［
%内へ来る~view遷移~params ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If inboundViewTransitionParams is null, then return null.
</li>
	<li>
%文書 の`内へ来る~view遷移~params$doc ~SET ~NULL
◎
Set document’s inbound view transition params to null.
</li>
	<li>
<p>
~IF［
%文書 にて`作動中な~view遷移$doc ~NEQ ~NULL
］
⇒
~RET ~NULL
◎
If document’s active view transition is not null, then return null.
</p>

<p class="note">注記：
これは、［
非同一-文書な遷移が処理待ちにある下で，
当の文書が露呈される前に同一-文書な遷移が開始された
］ときは，前者の遷移を取消すようにすることを意味する。
◎
Note: this means that starting a same-document transition before revealing the document would cancel a pending cross-document transition.
</p>
	</li>
	<li>
%解決-済み規則 ~LET `~view遷移~規則を解決する$( %文書 )
◎
Resolve @view-transition rule for document and let resolvedRule be the result.
</li>
	<li>
~IF［
%解決-済み規則 ~EQ `遷移を飛ばす^i
］
⇒
~RET ~NULL
◎
If resolvedRule is "skip transition", then return null.
</li>
	<li>
%遷移 ~LET %文書 に`関連な~realm$に属する新たな `ViewTransition$I
— その
⇒＃
`有名~要素~群$vT ~SET %内へ来る~view遷移~params の`有名~要素$vTP,
`初期~snapshot包含塊~size$vT ~SET %内へ来る~view遷移~params の`初期~snapshot包含塊~size$vTP
◎
Let transition be a new ViewTransition in document’s relevant Realm, whose named elements is inboundViewTransitionParams’s named elements, and initial snapshot containing block size is inboundViewTransitionParams’s initial snapshot containing block size.
</li>
	<li>
%文書 にて`作動中な~view遷移$doc ~SET %遷移
◎
Set document’s active view transition to transition.
</li>
	<li>
`~promiseを解決する$( %遷移 の`更新~callback済み時の~promise$vT )
◎
Resolve transition’s update callback done promise with undefined.
</li>
	<li>
%遷移 の`相$vT ~SET `更新~callbackは~call済み$i
◎
Set transition’s phase to "update-callback-called".
</li>
	<li>
%遷移 にて`作動中な型~群$vT ~SET %解決-済み規則
◎
Set transition’s active types to resolvedRule.
</li>
	<li>
~RET %遷移
◎
Return transition.
</li>
</ol>
</div>

			</section>
			<section id="vt-class-algorithms">
<h4 title="Capturing the view-transition-class">13.5.3. `view-transition-class$p の捕捉-法</h4>

<div class="algo">
<p>
`~level 1$ の［
`旧-状態を捕捉する$／
`新-状態を捕捉する$
］~algo【今や，この仕様に定義される】には、
所与の
( `捕捉された要素$ %捕捉, `要素$ %要素 )
に対し，次を遂行する段を挿入する†：
◎
When capturing the old or new state for an element, perform the following steps given a captured element capture and an element element:
</p>
<ol>
	<li>
~IF［
%要素 の `view-transition-class$p ~propには %要素 の`~node文書$が結付けられる††
］
⇒
%捕捉 の`~class~list$cE ~SET %要素 の `view-transition-class$p の`算出d値$
◎
Set capture’s class list to the computed value of element’s view-transition-class, if it is associated with element’s node document.
</li>
</ol>

<p class="trans-note">【†
どこに挿入するか指定されていないが、
“… ~SET 新たな捕捉された要素” と記された段より後のどこかであろう。
】【††
`~tree視野な名前$用の根として
— すなわち， %要素 の `view-transition-class^p ~propの`~cascaded値$を与えた宣言を包含する~stylesheetを~hostしている要素の`根$ ~EQ %要素 の`~node文書$
】</p>

<p class="note">注記：
これは、
~monkey~patch方式で書かれており，
`~level 1$ 仕様が熟したときには，その~algoの中へ併合されることになる。
◎
Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</p>
</div>

			</section>
			<section id="vt-group-algorithm">
<h4 title="Capturing and applying view-transition-group">13.5.4. `view-transition-group$p の捕捉-法と適用-法</h4>

				<section id="vt-group-value-resolve">
<h5 title="Resolving the view-transition-group value">13.5.4.1. `view-transition-group$p 値の解決-法</h5>

<div class="algo">
<p>
`要素$【！`Element$I】 %要素 用の
`文書~視野な~view遷移~group@
を取得する~algoは：
◎
To get the document-scoped view transition group of an Element element, perform the following steps:
</p>
<ol>
	<li>
%算出d~group ~LET %要素 の `view-transition-group$p ~propの`算出d値$
◎
Let computedGroup be the computed value of element’s view-transition-group property.
</li>
	<li>
~IF［
%算出d~group は %要素 の`~node文書$に結付けられている
【~node文書に結付けられた`~tree視野な名前$である】
］
⇒
~RET %算出d~group
◎
If computedGroup is associated with element’s node document, return computedGroup.
</li>
	<li>
~RET `normal$v
◎
Return normal.
</li>
</ol>
</div>

				</section>
				<section id="vt-containing-group-name-resolve">
<h5 title="Resolving the containing group name">13.5.4.2. 包含ng~group名の解決-法</h5>

<div class="algo">
<p>
`要素$【！`Element$I】 %要素 用の
`最も近い包含ng~group名@
を解決する~algoは、
所与の
( `ViewTransition$I %~view遷移 )
に対し：
◎
To resolve the nearest containing group name of an Element element, perform the following steps given a ViewTransition viewTransition:
</p>
<ol>
	<li>
~Assert：
%要素 は %~view遷移 に関与する。
◎
Assert: element participates in viewTransition.
</li>
	<li>
`平坦~tree$における %要素 の
~EACH( `先祖$ %先祖 )
に対し，
%要素 に近いものから順に
⇒
~IF［
%先祖 は %~view遷移 に関与する
］~AND［
%先祖 用の`文書~視野な~view遷移~group$ ~NEQ `normal$v
］
⇒
~RET %先祖 用の`文書~視野な~view遷移~名$
◎
Let ancestorGroup be element’s nearest flat tree ancestor who participates in viewTransition and whose document-scoped view transition group is not normal.
◎
If ancestorGroup exists, return ancestorGroup’s document-scoped view transition name.
</li>
	<li>
~RET `none$v
◎
Return none.
</li>
</ol>
</div>

				</section>
				<section id="vt-group-name-resolve">
<h5 title="Resolving the group name">13.5.4.3. ~group名の解決-法</h5>

<div class="algo">
<p>
`要素$【！`Element$I】 %要素 用の
`使用~group名@
【 `view-transition-group$p の`使用~値$】
を解決する~algoは、
所与の
( `ViewTransition$I %遷移 )
に対し：
◎
To resolve the used group name of an Element element, perform the following steps given a ViewTransition transition:
</p>
<ol>
	<li>
~Assert：
%要素 は %遷移 に関与する。
◎
Assert: element participates in transition.
</li>
	<li>
%~group ~LET %要素 用の`文書~視野な~view遷移~group$
◎
Let group be element’s document-scoped view transition group.
</li>
	<li>
%包含ng~group名 ~LET %要素 用の`最も近い包含ng~group名$( %遷移 )
◎
Let containingGroupName be element’s nearest containing group name given transition.
◎
↓ Return the first matching statement, switching on group:
</li>
	<li>
<p>
~IF［
%~group ~IN {
`normal@v
,
`contain@v
}
］
⇒
~RET %包含ng~group名
◎
normal
contain
• containingGroupName.
</p>

<p class="note">注記：
【`view-transition-group$p に】 `contain$v を伴う要素【の `view-transition-name$p 】は、
その子孫~用の`最も近い包含ng~group名$になる。
◎
• Note: an element with contain becomes the nearest containing group name for its descendants.
</p>
	</li>
	<li>
<p>
~ELIF［
%~group ~EQ
`nearest@v
］：
</p>
		<ol>
			<li>
`平坦~tree$における %要素 の
~EACH( `先祖$ %先祖 )
に対し，
%要素 に近いものから順に
⇒
~IF［
%先祖 は %~view遷移 に関与する
］
⇒
~RET %先祖 用の`文書~視野な~view遷移~名$
</li>
			<li>
~RET 【何を返すか指定されていない（ %包含ng~group名 ？）】
</li>
		</ol>
◎
nearest
• The document-scoped view transition name of the element’s nearest flat tree ancestor which participates in the transition.
</li>
	<li>
<p id="valdef-view-transition-group-custom-ident">
~ELSE（ %~group は `custom-ident$t である）：
</p>
		<ol>
			<li>
`平坦~tree$における %要素 の
~EACH( `先祖$ %先祖 )
に対し，
%要素 に近いものから順に
⇒
~IF［
%先祖 は %~view遷移 に関与する
］~AND［
%先祖 用の`文書~視野な~view遷移~名$ ~EQ %~group
］
⇒
~RET %~group
</li>
			<li>
~RET %包含ng~group名
</li>
		</ol>
◎
&lt;custom-ident&gt;
• group if the element has a flat tree ancestor whose document-scoped view transition name is group and participates in transition; Otherwise containingGroupName.
</li>
</ol>
</div>

				</section>
				<section id="vt-group-capture-old">
<h5 title="Compute the old view-transition-group">13.5.4.4. 旧- `view-transition-group$p を算出する</h5>

<div class="algo">
<p>
`~level 1$ の`旧-状態を捕捉する$
~algo【今や，この仕様に定義される】には、
その［
%捕捉~要素~群 を反復する段
］の中に，次を遂行する段を挿入する：
◎
When capturing the old state for an element, perform the following steps given a captured element capturedElement, a ViewTransition transition, and an element element:
</p>
<ol>
	<li>
%捕捉 の`包含ng~group名$cE ~SET %要素 用の`使用~group名$( %遷移 )
◎
Set capturedElement’s containing group name to element’s used group name given transition.
</li>
	<li>
%捕捉 の`旧-~border幅$cE ~SET %要素 の `border-width$p の`使用~値$
◎
Set capturedElement’s old border width to element’s used border-width.
</li>
</ol>
</div>

				</section>
				<section id="vt-group-capture-new">
<h5 title="Compute the new view-transition-group">13.5.4.5. 新- `view-transition-group$p を算出する</h5>

<div class="algo">
<p>
`~level 1$ の`新-状態を捕捉する$
~algo【今や，この仕様に定義される】には、
その［
各 `要素$ %要素 を反復する段
］の中の最後に，次を遂行する段を挿入する：
◎
When capturing the new state for an element, perform the following steps given a captured element capturedElement a ViewTransition transition, and an element element:
</p>
<ol>
	<li>
%有名~要素~群[ %遷移~名 ] の`包含ng~group名$cE ~SET %要素 用の`使用~group名$( %遷移 )
◎
Set capturedElement’s containing group name to element’s used group name given transition.
</li>
</ol>
</div>

				</section>
				<section id="vt-group-reparent">
<h5 title="Reparent a ::view-transition-group() to its specified containing group">13.5.4.6. `view-transition-group()$pe の親を指定された包含ng~groupに~~改める</h5>

<div class="algo">
<p>
`~level 1$ の`遷移~疑似要素たちを設定しておく$
~algo【今や，この仕様に定義される】に対しては，その中の［
%遷移 の`有名~要素~群$vTを成す
~EACH( %遷移~名 → %捕捉された要素 )
を反復する段
］ %反復~段 に関して：
◎
When setting up the transition pseudo-element for a captured element capturedElement, given a transitionName and a transition:
</p>
<ul>
	<li>
<p>
%反復~段 の前に，次を遂行する段たちを挿入する：
</p>
		<ol>
			<li>
%~group~map ~LET 新たな`有順序~map$
</li>
			<li>
%遷移 の`有名~要素~群$vTの`~key群$mapを成す
~EACH( %遷移~名 )
に対し
⇒
%~group~map[ %遷移~名 ] ~SET 新たな `view-transition-group()$pe
— その
⇒＃
`~view遷移~名$ ~SET %遷移~名
</li>
		</ol>
<p class="trans-note">【
これらの段は、
この訳による補完。
原文は，次項にて %~group~map[ %包含ng~group名 ] が指すものを それが
（ %反復~段 における後続な反復の中で）
作成される前に利用しているので、
ここで予め作成しておく。
】</p>
◎
↓</li>
	<li>
<p>
%反復~段 の中の［
%~group を新たな `view-transition-group()$pe で初期化する段
］に代えて，次を遂行する：
</p>
		<ol>
			<li>
%包含ng~group名 ~LET %捕捉された要素 の`包含ng~group名$cE
</li>
			<li>
<p>
~IF［
%包含ng~group名 ~NEQ ~NULL
］：
</p>

<p class="trans-note">【
原文は， ~NULL の場合に ~RET しているが、
そうすると %反復~段 を成す残りの反復をすべて飛ばすことになるので，誤りに思われる。
】</p>
				<ol>
					<li>
%~group ~LET %~group~map[ %遷移~名 ]
</li>
					<li>
%子~群~容器~group ~LET 次を満たす `view-transition-group-children()$pe は［
在るならばそれ／無いならば ε
］
⇒
その`~view遷移~名$ ~EQ %包含ng~group名
</li>
					<li>
<p>
~IF［
%子~群~容器~group ~EQ ε
］：
</p>
						<ol>
							<li>
%子~群~容器~group ~SET 新たな `view-transition-group-children()$pe
— その
⇒＃
`~view遷移~名$ ~SET %包含ng~group名
</li>
							<li>
%~group~map[ %包含ng~group名 ] に %子~群~容器~group を付加する
</li>
						</ol>
</li>
					<li>
%子~群~容器~group に【その子として】 %~group を付加する
</li>
				</ol>
			</li>
		</ol>
◎
Let containingGroupName be capturedElement’s containing group name.
◎
If containingGroupName is null, return.
◎
↓ Let groupContainerElement be transition’s named elements[containingGroupName].
◎
Let group be the ::view-transition-group(), whose view transition name is set to transitionName.
◎
Let childrenContainerGroup be the ::view-transition-group-children() whose view transition name is set to containingGroupName.
◎
If childrenContainerGroup does not exist: Generate it and append to the ::view-transition-group(), whose view transition name is set to containingGroupName.
◎
Append group to childrenContainerGroup.
</li>
	<li>
%反復~段 の中の %変形 を初期化する段（ `keyframes^at 規則の構築に関与する段）の直後に，次を遂行する段を挿入する
⇒
~IF［
%包含ng~group名 ~NEQ ~NULL
］
⇒
`入子な~view遷移~groupの変形を調整する$( %変形, %遷移 の`有名~要素~群$vT[ %包含ng~group名 ] )
◎
When setting the animation keyframes given transform, adjust transform given groupContainerElement.
</li>
</ul>

<p class="note">注記：
旧-~groupと新-~groupが `mismatch^en なとき，これがどう解決されるかは、
まだこれから。
`10631$issue を見よ。
◎
Note: It is TBD how this is resolved when the old and new groups mismatch. See Issue 10631.
</p>
</div>

				</section>
				<section id="vt-group-transform-adjust">
<h5 title="Adjust the group’s transform to be relative to its containing ::view-transition-group()">13.5.4.7. ~groupの `transform$p を それを包含している `view-transition-group()$pe に相対的に調整する</h5>

<div class="algo">
<p>
`~level 1$ の`疑似要素~styleを更新する$【今や，この仕様に定義される】
~algoには、
%捕捉された要素 用の`~group~style規則$cEを設定する段
］の前に，次を遂行する段を追加する：
◎
When updating the style of the transition pseudo-element, perform the following steps before setting the group styles rule, given a captured element capturedElement, given a transform and a ViewTransition transition:
</p>
<ol>
	<li>
%捕捉された要素 の`~snapshot包含塊からの変形$cE ~SET %変形
◎
Let childrenTransform be transform.
◎
Set capturedElement’s transform from snapshot containing block to transform.
</li>
	<li>
%~group名 ~LET %捕捉された要素 の`包含ng~group名$cE
◎
↓</li>
	<li>
~IF［
%~group名 ~NEQ ~NULL
］
⇒
`入子な~view遷移~groupの変形を調整する$( %変形, %遷移 の`有名~要素~群$vT[ %~group名 ] )
◎
If capturedElement’s containing group name is not null, then:
• Let groupContainerElement be transition’s named elements[capturedElement’s containing group name.
• Adjust transform given groupContainerElement.
</li>
</ol>
</div>

<div class="algo">
<p>
`入子な~view遷移~groupの変形を調整する@
~algoは、
所与の
( %変形, `捕捉された要素$ %~group容器~要素 )
に対し：
◎
To adjust nested view transition group transform given a transform and a captured element groupContainerElement:
</p>
<ol>
	<li>
%子~群~変形 ~LET %~group容器~要素 の`~snapshot包含塊からの変形$cE
◎
Let childrenTransform be groupContainerElement’s transform from snapshot containing block.
</li>
	<li>
~IF［
%子~群~変形 ~EQ ~NULL
］
⇒
%子~群~変形 ~SET %~group容器~要素 の`旧-変形$cE
◎
If childrenTransform is null, set it to groupContainerElement’s old transform.
</li>
	<li>
%子~群~変形 を
%~group容器~要素 の`旧-~border幅$cEの
( 左端~成分, 上端~成分 )
により並進する
【並進を表現する行列を左, 右どちらから乗算するか指定されていない。】
◎
Translate childrenTransform by groupContainerElement’s old border width’s left and top components.
</li>
	<li>
%変形 に %子~群~変形 の逆-行列を`乗算する$
【左, 右どちらから乗算するか指定されていない。】
◎
Multiply transform by the inverse matrix of childrenTransform.
</li>
</ol>
</div>

				</section>
			</section>
		</section>
		<section id="call-dom-update-callback-algorithm">
<h3 title="Call the update callback">13.6. 更新~callbackを~callする</h3>

<div class="algo">
<p>
`更新~callbackを~callする@
~algoは、
所与の
( `ViewTransition$I %遷移 )
に対し：
◎
To call the update callback of a ViewTransition transition:
</p>
<p class="note">注記：
これは、
どの `ViewTransition$I にも起こることが保証される
— 当の遷移が`飛ばされ$た場合でも。
その理由は、
`§ 増補としての遷移＠#transitions-as-enhancements$
にて論じられる。
◎
Note: This is guaranteed to happen for every ViewTransition, even if the transition is skipped. The reasons for this are discussed in § 1.5 Transitions as an enhancement.
</p>
<ol>
	<li>
~Assert：
%遷移 の`相$vT ~IN { `済み$i, `捕捉-待ち$i【！before "update-callback-called"】 }
◎
Assert: transition’s phase is "done", or before "update-callback-called".
</li>
	<li>
~IF［
%遷移 の`相$vT ~NEQ `済み$i
］
⇒
%遷移 の`相$vT ~SET `更新~callbackは~call済み$i
◎
If transition’s phase is not "done", then set transition’s phase to "update-callback-called".
</li>
	<li>
%~callback~promise ~LET ~NULL
◎
Let callbackPromise be null.
</li>
	<li>
~IF［
%遷移 の`更新~callback$vT ~EQ ~NULL
］
⇒
%~callback~promise ~SET `解決される~promise$( `undefined^jv, %遷移 に`関連な~realm$ )
◎
If transition’s update callback is null, then set callbackPromise to a promise resolved with undefined, in transition’s relevant Realm.
</li>
	<li>
~ELSE
⇒
%~callback~promise ~SET `~callback関数を呼出す$( %遷移 の`更新~callback$vT, « » )
◎
Otherwise, set callbackPromise to the result of invoking transition’s update callback.
</li>
	<li class="algo">
<p>
%充足-手続き ~LET 次を走らす手続き：
◎
Let fulfillSteps be to following steps:
</p>
		<ol>
			<li>
`~promiseを解決する$( %遷移 の`更新~callback済み時の~promise$vT )
◎
Resolve transition’s update callback done promise with undefined.
</li>
			<li>
`~view遷移を作動化する$( %遷移 )
◎
Activate transition.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
%却下-手続き ~LET 所与の
( %事由 )
に対し，次を走らす手続き:
◎
Let rejectSteps be the following steps given reason:
</p>
		<ol>
			<li>
`~promiseを却下する$( %遷移 の`更新~callback済み時の~promise$vT, %事由 )
◎
Reject transition’s update callback done promise with reason.
</li>
			<li>
<p>
~IF［
%遷移 の`相$vT ~EQ `済み$i
］
⇒
~RET
◎
If transition’s phase is "done", then return.
</p>

<p class="note">注記：
これは、
この時点より前に %遷移 が`飛ばされ$た場合に起こる。
◎
Note: This happens if transition was skipped before this point.
</p>
			</li>
			<li>
<p>
`~promiseを取扱済みとして~markする$( %遷移 の`準備済み時の~promise$vT )
◎
Mark as handled transition’s ready promise.
</p>

<p class="note">注記：
%遷移 の`更新~callback済み時の~promise$vTは、
`unhandledrejection$et ~eventを発火することになる。
この段は、
この~eventが重複して発火されるのを避ける。
◎
Note: transition’s update callback done promise will provide the unhandledrejection. This step avoids a duplicate.
</p>
			</li>
			<li>
`~view遷移を飛ばす$( %遷移, ~NULL, %事由 )
◎
Skip the view transition transition with reason.
</li>
		</ol>
	</li>
	<li>
`~promiseに反応する$( %~callback~promise )
— 次を与える下で
⇒＃
`充足~手続き^i ~SET %充足-手続き,
`却下~手続き^i ~SET %却下-手続き
◎
React to callbackPromise with fulfillSteps and rejectSteps.
</li>
	<li class="algo">
<p>
時間切れ後に，遷移を飛ばすときは、
~UAは，次の手続きを`並列的$に遂行してもヨイ：
◎
To skip a transition after a timeout, the user agent may perform the following steps in parallel:
</p>
		<ol>
			<li>
実装定義な`所要時間$だけ待機する
◎
Wait for an implementation-defined duration.
</li>
			<li>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %遷移 に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the DOM manipulation task source, given transition’s relevant global object, to perform＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
				<ol>
					<li>
<p>
~IF［
%遷移 の`相$vT ~EQ `済み$i
］
⇒
~RET
◎
If transition’s phase is "done", then return.
</p>

<p class="note">注記：
これは、
この時点より前に %遷移 が`飛ばされ$た場合に起こる。
◎
Note: This happens if transition was skipped before this point.
</p>
					</li>
					<li>
`~view遷移を飛ばす$( %遷移, "`TimeoutError$E" )
◎
Skip transition with a "TimeoutError" DOMException.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`更新~callbackを~scheduleする@
~algoは、
所与の
( `ViewTransition$I %遷移 )
に対し：
◎
To schedule the update callback given a ViewTransition transition:
</p>
<ol>
	<li>
%大域~obj ~LET %遷移 に`関連な大域~obj$
◎
↓</li>
	<li>
%文書 ~LET %大域~obj に`結付けられた文書$
◎
↓</li>
	<li>
<p>
%文書 †の`更新~callback~queue$docに %遷移 を`付加する$
</p>

<p class="trans-note">【†
原文には %文書 に代えて “%遷移 に`関連な設定群~obj$” と記されているが、
更新~callback~queueは`文書$に結付けられるので，誤りであろう。
】</p>
◎
Append transition to transition’s relevant settings object’s update callback queue.
</li>
	<li>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %大域~obj, 次の手続き )
◎
Queue a global task on the DOM manipulation task source, given transition’s relevant global object, to＼
</p>

<div class="algo">
手続きは
⇒
`更新~callback~queueを一掃する$( 【 %文書 】 )
◎
flush the update callback queue.
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
`更新~callback~queueを一掃する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To flush the update callback queue given a Document document:
</p>
<ol>
	<li>
%文書 の`更新~callback~queue$docを成す
~EACH( %遷移 )
に対し
⇒
`更新~callbackを~callする$( %遷移 )
◎
For each transition in document’s update callback queue, call the update callback given transition.
</li>

	<li>
%文書 の`更新~callback~queue$doc ~SET 空な`~list$【を`空にする$？】
◎
Set document’s update callback queue to an empty list.
</li>
</ol>
</div>

		</section>
		<section id="skip-the-view-transition-algorithm">
<h3 title="Skip the view transition">13.7. ~view遷移を飛ばす</h3>

<div class="algo">
<p>
`~view遷移を飛ばす@
~algoは、
所与の
( `ViewTransition$I %遷移, ［
文字列／~NULL
］ %例外~名, %事由 ~DF ε )
に対し：
◎
To skip the view transition for ViewTransition transition with reason reason:
</p>
<ol>
	<li>
<p>
~IF［
%例外~名 ~NEQ ~NULL
］
⇒
%事由 ~SET %遷移 に`関連な~realm$に属する新たな`例外$
— その
⇒＃
`名前$eX ~SET %例外~名
</p>

<p class="trans-note">【
この段と次の段, および %例外~名 引数は、
~realmに関する取扱いを集約するための，この訳による追加。
】</p>
	</li>
	<li>
~Assert：
%事由 ~NEQ ε
</li>
	<li>
%文書 ~LET %遷移 に`関連な大域~obj$に`結付けられた文書$
◎
Let document be transition’s relevant global object’s associated document.
</li>
	<li>
~Assert：
%遷移 の`相$vT ~NEQ `済み$i
◎
Assert: transition’s phase is not "done".
</li>
	<li>
~IF［
%遷移 の`相$vT ~EQ `捕捉-待ち$i【！before "update-callback-called"】
］
⇒
`更新~callbackを~scheduleする$( %遷移 )
◎
If transition’s phase is before "update-callback-called", then schedule the update callback for transition.
</li>
	<li>
`~view遷移~用の描画を抑止するか$doc ~SET ~F
◎
Set rendering suppression for view transitions to false.
</li>
	<li>
~IF［
%文書 にて`作動中な~view遷移$doc ~EQ %遷移
］
⇒
`~view遷移を~clearする$( %遷移 )
◎
If document’s active view transition is transition, Clear view transition transition.
</li>
	<li>
%遷移 の`相$vT ~SET `済み$i
◎
Set transition’s phase to "done".
</li>
	<li>
<p>
`~promiseを却下する$( %遷移 の`準備済み時の~promise$vT, %事由 )
◎
Reject transition’s ready promise with reason.
</p>

<p class="note">注記：
~animationを開始した後に `skipTransition()$m が~callされた場合、
`準備済み時の~promise$vTは，この時点ですでに解決-済みかもしれない。
その事例では、
この段は何もしない。
◎
Note: The ready promise may already be resolved at this point, if skipTransition() is called after we start animating. In that case, this step is a no-op.
</p>
	</li>
	<li>
<p>
%結果 ~LET `~promiseに反応する$( %遷移 の`更新~callback済み時の~promise$vT )
— 次を与える下で：
◎
Resolve transition’s finished promise with the result of reacting to transition’s update callback done promise:
</p>
		<ul>
			<li class="algo">
`充足~手続き^i は
⇒
~RET `undefined^jv
◎
If the promise was fulfilled, then return undefined.
</li>
		</ul>

<p class="note">注記：
%遷移 の`更新~callback済み時の~promise$vTの却下は，ここでは明示的に取扱われないので、
%遷移 の`更新~callback済み時の~promise$vTが却下された場合，
%遷移 の`完遂-時の~promise$vTが同じ事由で却下されることになる。
◎
Note: Since the rejection of transition’s update callback done promise isn’t explicitly handled here, if transition’s update callback done promise rejects, then transition’s finished promise will reject with the same reason.
</p>
	</li>
	<li>
`~promiseを解決する$( %遷移 の`完遂-時の~promise$vT, %結果 )
◎
↑</li>
</ol>
</div>

		</section>
		<section id="page-visibility-change-steps">
<h3 title="View transition page-visibility change steps">13.8. ~view遷移の~page可視性~変化-時の手続き</h3>

<div class="algo">
<p>
`~view遷移の~page可視性~変化-時の手続き@
は、
所与の
( `文書$ %文書 )
に対し：
◎
The view transition page-visibility change steps given Document document are:
</p>
<ol>
	<li>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %文書 に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the DOM manipulation task source, given document’s relevant global object, to perform＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li>
%~view遷移 ~LET %文書 にて`作動中な~view遷移$doc
◎
↓</li>
			<li>
~IF［
%文書 の`可視性~状態$doc ~EQ `hidden^l
］
⇒
~IF［
%~view遷移 ~NEQ ~NULL
］
⇒
`~view遷移を飛ばす$( %~view遷移, "`InvalidStateError$E" )
◎
If document’s visibility state is "hidden", then:
• If document’s active view transition is not null, then skip document’s active view transition with an "InvalidStateError" DOMException.
</li>
			<li>
~ELSE
⇒
~Assert：
%~view遷移 ~EQ ~NULL
◎
Otherwise, assert: active view transition is null.
</li>
			<li>
%文書 の`内へ来る~view遷移~params$doc ~SET ~NULL
◎
Set document’s inbound view transition params to null.
</li>
		</ol>
</div>
	</li>
</ol>

<p class="note">注記：
これは、
~HTML仕様から~callされる。
◎
Note: this is called from the HTML spec.
</p>
</div>

		</section>
		<section id="capture-the-image-algorithm">
<h3 title="Capture the image">13.9. 画像を捕捉する</h3>

<div class="algo">
<p>
`画像を捕捉する@
~algoは、
所与の
( `要素$ %要素 )
に対し，ある画像を返す：
◎
To capture the image given an element element, perform the following steps. They return an image.
</p>
<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
【この段は、以下を明確化するための，この訳による補完。】
</li>
	<li>
<p>
~IF［
%要素 ~EQ %文書 の`文書~要素$
］：
◎
If element is the document element, then:
</p>
		<ol>
			<li>
%~canvas ~LET ~sizeが`~snapshot包含塊$の~sizeに等しい，透明な~canvas
◎
↓</li>
			<li>
<p>
%文書 が成す領域
（ %文書 の［
`~canvas背景$, `上端~層$を成す内容
］も含む）
のうち`~snapshot包含塊$と交差する部分を %~canvas 上に描画する
— ［
%要素 の`描画~特性を捕捉する$
］かつ［
次に挙げる追加的な特性に従う
］下で：
◎
Render the region of document (including its canvas background and any top layer content) that intersects the snapshot containing block, on a transparent canvas the size of the snapshot containing block, following the capture rendering characteristics, and these additional characteristics:
</p>
				<ul>
					<li>
<p>
%要素 の`~scrollされる~box$の外側にある区画は、
`~layout表示域$を［
移動する／~resizeする
］ことなく~scrollされたかのように描画するベキである。
これは、［
~scrollする／~resizeする
］ことに関係する~event
— `IntersectionObserver$I など —
を誘発しないモノトスル。
◎
Areas outside element’s scrolling box should be rendered as if they were scrolled to, without moving or resizing the layout viewport. This must not trigger events related to scrolling or resizing, such as IntersectionObservers.
</p>

<figure>
<div class="side-by-side">
<p class="alt" hidden id="_dgm-phone-browser-with-url">
あるスマホ~browserの~UIwindowは、［
~URL~bar,
その直下に`固定的に位置され$た要素,
その下に~page内容
］を示している。
~scrollbarは、
~pageが有意に~scrollされたことを指示する。
◎
A phone browser window, showing a URL bar, a fixed-position element directly beneath it, and some page content beneath that. A scroll bar indicates the page has been scrolled significantly.
</p>
<p class="alt" hidden id="_dgm-phone-browser-without-url">
捕捉された~snapshot。
それは、
~URL~barの奥にある内容が捕捉~内に含まれたことを示す。
◎
The captured snapshot. It shows that content beneath the URL bar was included in the capture.
</p>
</div>
<figcaption>
捕捉された~snapshotと利用者に見えるものを比較した例。
この例は、
遷移~名を伴う要素は根しか無いと見做す。
◎
An example of what the user sees compared to the captured snapshot. This example assumes the root is the only element with a transition name.
</figcaption></figure>
					</li>
					<li>
<p>
~scrollし得ない区画
（~scroll限界域の外にある区画）
には、
`~canvas背景$を描画するベキである。
◎
Areas that cannot be scrolled to (i.e. they are out of scrolling bounds), should render the canvas background.
</p>

<figure>
<div class="side-by-side">
<p class="alt" hidden id="_dgm-phone-browser-scrolled-to-top-with-url">
あるスマホ~browserの~UIwindowは、
~URL~barと その下にある内容を示している。
~scrollbarは、
~pageが上端へ~scrollされたことを指示する。
◎
A phone browser window, showing a URL bar, and some content beneath. A scroll bar indicates the page is scrolled to the top.
</p>
<p class="alt" hidden id="_dgm-phone-browser-scrolled-to-top-without-url">
捕捉された~snapshotは、
~URL~barの奥にある区画の色は，文書を成す残りと同じであることを示す。
◎
The captured snapshot. It shows the area underneath the URL bar as the same color as the rest of the document.
</p>
</div>

<figcaption>
捕捉された~snapshotと利用者に見えるものを比較した例。
この例は、
遷移~名を伴う要素は根しか無いと見做す。
◎
An example of what the user sees compared to the captured snapshot. This example assumes the root is the only element with a transition name.
</figcaption></figure>
					</li>
				</ul>
			</li>
			<li>
~RET 画像としての %~canvas
— %~canvas の~sizeが，そのまま画像の`生来な~size$になるとする
◎
Return this canvas as an image. The natural size of the image is equal to the snapshot containing block.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~canvas ~LET 広さ無限な透明な~canvas
◎
↓</li>
			<li>
%要素, %要素 の`子孫$を［
%要素 が %文書 内で現れるときと同じ~size
］で［
%要素 の`描画~特性を捕捉する$
］下で %~canvas 上に描画する
◎
Render element and its descendants, at the same size it appears in its node document, over an infinite transparent canvas, following the capture rendering characteristics.
</li>
			<li>
<p>
~RET 画像としての %~canvas の［
%要素 の`~ink~overflow矩形$
］を含む部位。
この画像の［
`生来な寸法$／原点
］は、［
%要素 の`首要~box$を成す`~border~box$
］の［
`~size$になる／
原点に対応する
］モノトスル
— ［
当の画像は、
この`~border~box$の内容を表現する
］かつ［
捕捉された`~ink~overflow$は、
この限界域の外側で表現される
］ように。
◎
Return the portion of this canvas that includes element’s ink overflow rectangle as an image. The natural dimensions of this image must be those of its principal border box, and its origin must correspond to that border box’s origin, such that the image represents the contents of this border box and any captured ink overflow is represented outside these bounds.
</p>

<p class="note">注記：
この画像が`生来な~size$で`置換d要素$として描画されるときは、
次のように表示されることになる
⇒＃
要素の`首要~box$の［ ~size, 内容 ］を伴う。
捕捉された`~ink~overflow$は要素の`内容~box$を~overflowする。
◎
Note: When this image is rendered as a replaced element at its natural size, it will display with the size and contents of element’s principal box, with any captured ink overflow overflowing its content box.
</p>
			</li>
		</ol>
	</li>
</ol>
</div>

			<section id="capture-rendering-characteristics-algorithm">
<h4 title="Capture rendering characteristics">13.9.1. 描画~特性を捕捉する</h4>

<p>
%要素 の
`描画~特性を捕捉する@
~algoは：
◎
The capture rendering characteristics are as follows:
</p>
<ul>
	<li>
<p>
%要素（および その各~先祖）に適用された変形は無視する。
◎
If the referenced element has a transform applied to it (or its ancestors), then the transform is ignored.
</p>

<p class="note">注記：
この変形は、
【！the associated】
`view-transition-group()$pe 疑似要素の `transform$p ~propを利用して，
~snapshotに適用される。
◎
Note: This transform is applied to the snapshot using the transform property of the associated ::view-transition-group pseudo-element.
</p>
	</li>
	<li>
［
%要素, その各~子孫
］に適用された効果
— `opacity$p や `filter$p など —
は、
捕捉に適用する。
%要素 の各~先祖から %要素 に適用された効果は無視する。
◎
Effects applied on the element and its descendants, such as opacity and filter, are applied to the capture. Effects applied to the element from its ancestors are ignored.
</li>
	<li>
実装は、
%要素 の`~ink~overflow矩形$が何らかの`実装定義$な最大を超過する場合には，
描画される内容をそこまでに切取ってもヨイ。
しかしながら、
捕捉される画像には，少なくとも［
%要素 を成す内容のうち`~snapshot包含塊$に交差する部分
］を含めるベキである。
実装は、
%要素 が［
~viewの中へ変形される広い`~ink~overflow区画$
］を伴うときは，それを織り込むときに~raster化の品質を調整してもヨイ。
◎
Implementations may clip the rendered contents if the ink overflow rectangle exceeds some implementation-defined maximum. However, the captured image should include, at the very least, the contents of element that intersect with the snapshot containing block. Implementations may adjust the rasterization quality to account for elements with a large ink overflow area that are transformed into view.
</li>
	<li>
<p>
実装は、
%要素 の`~ink~overflow矩形$が`~snapshot包含塊$と交差しない場合には，
~raster化の品質を調整してもヨイ。
%要素 が結局は可視になった場合でも，利用者~体験は壊れないよう、
捕捉された画像は，少なくとも［
透明な画素ではなく，
%要素 の内容が成す何らかの低-品質な表現
］を含むベキである。
◎
Implementations may also adjust the rasterization quality for elements whose ink overflow rectangle does not intersect with the snapshot containing block. To avoid a broken experience if the element ends up becoming visible, the captured image should include, at the very least, some low-quality representation of the contents rather than transparent pixels.
</p>

<p class="note">注記：
これは、
%要素 が表示域から離れていて，まったく可視ならないかもしれない場合でも、［
作者の意図に十分~近い視覚的~効果
］を保守しつつ［
資源の利用度, ~raster化の処理能
］における効率を高めることを許容する。
◎
Note: This allows efficiency in resource usage and rasterization performance for elements that are away from the viewport and might not become visible at all, while maintaining a visual effect close enough to the author’s intent.
</p>
	</li>
	<li>
<div>
<p>
~AND↓ を満たす各~要素【！`Element$I】（`疑似要素$も含む） %子孫 の塗ngを飛ばす：
</p>
		<ul>
			<li>
%子孫 は %要素 の`~shadowも含めた子孫$である
</li>
			<li>
%子孫 の`ある~view遷移~内に捕捉されたか$el ~EQ ~T
</li>
		</ul>
◎
For each descendant of shadow-including descendant Element and pseudo-element of element, if descendant is captured in a view transition, then skip painting descendant.
</div>

<p class="note">注記：
これが必要yあるのは、
該当する子孫は、
自前の~snapshotを生成して，独立に［
表示され，~animateされる
］ことになるからである。
◎
Note: This is necessary since the descendant will generate its own snapshot which will be displayed and animated independently.
</p>
	</li>
</ul>

<div class="algo">
<p>
`遷移の完遂-を遅延する~promiseを追加する@
~algoは、
所与の
( ~promise %~promise )
に対し：
◎
To delay finish for promise, given promise p:
</p>
<ol>
	<li>
~IF［
%~promise は決着-済みである
］
⇒
~RET
◎
If p is settled, abort the remainder of the steps and return.
</li>
	<li>
コレの`決着するまで待機する~promise数$doc ~INCBY 1
◎
Increment this’s wait until promise count.
</li>
	<li>
<p>
%~promise の［
`充足-時$／`却下-時$
］には、
次の手続きを遂行するようにする
◎
Upon fulfillment or rejection of p:
</p>

<div class="algo">
手続きは
⇒
コレの`決着するまで待機する~promise数$doc ~DECBY 1
◎
• Decrement this’s wait until promise count.
</div>

<p class="note">注記：
コレの`決着するまで待機する~promise数$doc ~EQ 0 の場合、
当の遷移は，次回の`描画~機会$に完遂することになる。
◎
Note: If this’s wait until promise count is 0, the transition will finish at the next rendering opportunity.
</p>
	</li>
</ol>
</div>

			</section>
		</section>
		<section id="handle-transition-frame-algorithm">
<h3 title="Handle transition frame">13.10. 遷移~frameを取扱う</h3>

<div class="algo">
<p>
`遷移~frameを取扱う@
~algoは、
所与の
( `ViewTransition$I %遷移 )
に対し：
◎
To handle transition frame given a ViewTransition transition:
</p>
<ol>
	<li>
%文書 ~LET %遷移 に`関連な大域~obj$に`結付けられた文書$
◎
Let document be transition’s relevant global object’s associated document.
</li>
	<li>
%作動中な~animationはあるか ~LET ~F
◎
Let hasActiveAnimations be a boolean, initially false.
</li>
	<li>
<p>
%遷移 の`遷移~根~疑似要素$vTの`広義-子孫$を成す
~EACH( %要素 )
に対し：
◎
For each element of transition’s transition root pseudo-element’s inclusive descendants:
</p>
		<ol>
			<li>
<p>
~IF［
~AND↓ を満たす`~animation$ %A は在る
］…
</p>
				<ul>
					<li>
%A の`時列線$An ~EQ %文書 に結付けられた`文書~時列線$
</li>
					<li>
%A に`結付けられた効果$ ~NEQ ~NULL
</li>
					<li>
%A に`結付けられた効果$の`効果~target$ ~EQ %要素
</li>
					<li>
<p>
~OR↓ ：
</p>
						<ul>
							<li>
%A の`再生-状態$ ~IN { `静止中$i, `稼働中$i }
</li>
							<li>
%文書 の`処理待ち~animation~event~queue$内に次を満たす %~event が在る
⇒
%~event の`対応する~event~target$ ~EQ %A
</li>
						</ul>
					</li>
				</ul>
<p>
…ならば
⇒＃
%作動中な~animationはあるか ~SET ~T；
~BREAK
</p>
◎
For each animation whose timeline is a document timeline associated with document, and contains at least one associated effect whose effect target is element, set hasActiveAnimations to true if any of the following conditions are true:
• animation’s play state is paused or running.
• document’s pending animation event queue has any events associated with animation.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%作動中な~animationはあるか ~EQ ~F
］：
◎
If hasActiveAnimations is false:
</p>
		<ol>
			<li>
%遷移 の`相$vT ~SET `済み$i
◎
Set transition’s phase to "done".
</li>
			<li>
`~view遷移を~clearする$( %遷移 )
◎
Clear view transition transition.
</li>
			<li>
`~promiseを解決する$( %遷移 の`完遂-時の~promise$vT )
◎
Resolve transition’s finished promise.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~IF［
%遷移 の`初期~snapshot包含塊~size$vT ~NEQ `~snapshot包含塊の~size$
］
⇒＃
`~view遷移を飛ばす$( %遷移, "`InvalidStateError$E" )；
~RET
◎
If transition’s initial snapshot containing block size is not equal to the snapshot containing block size, then skip the view transition for transition with an "InvalidStateError" DOMException in transition’s relevant Realm, and return.
</li>
	<li>
%成否 ~LET `疑似要素~styleを更新する$( %遷移 )
◎
Update pseudo-element styles for transition.
</li>
	<li>
<p>
~IF［
%成否 ~EQ `失敗^i
］
⇒＃
`~view遷移を飛ばす$( %遷移, "`InvalidStateError$E" )；
~RET
◎
If failure is returned, then skip the view transition for transition with an "InvalidStateError" DOMException in transition’s relevant Realm, and return.
</p>

<p class="note">注記：
上は、［
`incoming^en 要素【新-状態~内の要素】の［
~size／位置
］における変化が新たな~keyframeを生成させることになる
］ことを含意する。
これは、
視覚的な `jump^en 【不連続な~animation】をもたらし得る。
滑らかに `retarget^en する【変化~後の状態を反映するよう更新する】こともできたが，
その複階性を正当化する利用事例は，まだ無い。
詳細は `7813$issue を見よ。
◎
Note: The above implies that a change in incoming element’s size or position will cause a new keyframe to be generated. This can cause a visual jump. We could retarget smoothly but don’t have a use-case to justify the complexity. See issue 7813 for details.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="style-transition-pseudo-elements-algorithm">
<h3 title="Update pseudo-element styles">13.11. 疑似要素~styleを更新する</h3>

<div class="algo">
<p>
`疑似要素~styleを更新する@
~algoは、
所与の
( `ViewTransition$I %遷移 )
に対し：
◎
To update pseudo-element styles for a ViewTransition transition:
</p>
<ol>
	<li>
<p>
%遷移 の`有名~要素~群$vTを成す
~EACH( %遷移~名 → %捕捉された要素 )
に対し：
◎
For each transitionName → capturedElement of transition’s named elements:
</p>
		<ol>
			<li>
%新-要素 ~LET %捕捉された要素 の`新-要素$cE
◎
↓</li>
			<li>
⇒＃
%横幅 ~LET ~NULL,
%縦幅 ~LET ~NULL,
%変形 ~LET ~NULL,
%書字~mode ~LET ~NULL,
%方向 ~LET ~NULL,
%~text方位 ~LET ~NULL,
%混色~mode ~LET ~NULL,
%後景~filter ~LET ~NULL,
%色~scheme ~LET ~NULL
◎
Let width, height, transform, writingMode, direction, textOrientation, mixBlendMode, backdropFilter and colorScheme be null.
</li>
			<li>
<p>
~IF［
%新-要素 ~EQ ~NULL
］：
◎
If capturedElement’s new element is null, then:
</p>
				<ol>
					<li>
%横幅 ~SET %捕捉された要素 の`旧-横幅$cE
◎
Set width to capturedElement’s old width.
</li>
					<li>
%縦幅 ~SET %捕捉された要素 の`旧-縦幅$cE
◎
Set height to capturedElement’s old height.
</li>
					<li>
%変形 ~SET %捕捉された要素 の`旧-変形$cE
◎
Set transform to capturedElement’s old transform.
</li>
					<li>
%書字~mode ~SET %捕捉された要素 の`旧-書字~mode$cE
◎
Set writingMode to capturedElement’s old writing-mode.
</li>
					<li>
%方向 ~SET %捕捉された要素 の`旧-方向$cE
◎
Set direction to capturedElement’s old direction.
</li>
					<li>
%~text方位 ~SET %捕捉された要素 の`旧-~text方位$cE
◎
Set textOrientation to capturedElement’s old text-orientation.
</li>
					<li>
%混色~mode ~SET %捕捉された要素 の`旧-混色~mode$cE
◎
Set mixBlendMode to capturedElement’s old mix-blend-mode.
</li>
					<li>
%後景~filter ~SET %捕捉された要素 の`旧-後景~filter$cE
◎
Set backdropFilter to capturedElement’s old backdrop-filter.
</li>
					<li>
%色~scheme ~SET %捕捉された要素 の`旧-色~scheme$cE
◎
Set colorScheme to capturedElement’s old color-scheme.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
<p>
~IF［
~OR↓
］…
◎
Return failure if any of the following conditions are true:
</p>
						<ul>
							<li>
`平坦~tree$における %新-要素 の先祖として`内容を飛ばす$ものがある
◎
capturedElement’s new element has a flat tree ancestor that skips its contents.
</li>
							<li>
%新-要素 は`描画され$ない
◎
capturedElement’s new element is not rendered.
</li>
							<li>
%新-要素 は複数個の`~box断片$を有する
◎
capturedElement has more than one box fragment.
</li>
						</ul>
<p>
…ならば
⇒
~RET `失敗^i
◎
↑</p>

<p class="note">注記：
他の描画~拘束は、［
%新-要素 の`ある~view遷移~内に捕捉されたか$el
］を介して施行される。
◎
Note: Other rendering constraints are enforced via capturedElement’s new element being captured in a view transition.
</p>
					</li>
					<li>
%新-矩形 ~LET %新-要素 に応じて
⇒＃
`文書~要素$であるならば`~snapshot包含塊$／
~ELSE_ %捕捉された要素 の`~border~box$
◎
Let newRect be the snapshot containing block if capturedElement’s new element is the document element, otherwise, capturedElement’s border box.
</li>
					<li>
%横幅 ~SET %新-矩形 の現在の横幅
◎
Set width to the current width of newRect.
</li>
					<li>
%縦幅 ~SET %新-矩形 の現在の縦幅
◎
Set height to the current height of newRect.
</li>
					<li>
%変形 ~SET 次を満たす変形を与える `transform-function$t
⇒
%新-矩形 を`~snapshot包含塊の原点$から `its^en【 %新-矩形 の？】 現在の視覚的な位置へ対応付けることになる
◎
Set transform to a transform that would map newRect from the snapshot containing block origin to its current visual position.
</li>
					<li>
%書字~mode ~SET %新-要素 の `writing-mode$p の`算出d値$
◎
Set writingMode to the computed value of writing-mode on capturedElement’s new element.
</li>
					<li>
%方向 ~SET %新-要素 の `direction$p の`算出d値$
◎
Set direction to the computed value of direction on capturedElement’s new element.
</li>
					<li>
%~text方位 ~SET %新-要素 の `text-orientation$p の`算出d値$
◎
Set textOrientation to the computed value of text-orientation on capturedElement’s new element.
</li>
					<li>
%混色~mode ~SET %新-要素 の`mix-blend-mode$p の`算出d値$
◎
Set mixBlendMode to the computed value of mix-blend-mode on capturedElement’s new element.
</li>
					<li>
%後景~filter ~SET %新-要素 の `backdrop-filter$p の`算出d値$
◎
Set backdropFilter to the computed value of backdrop-filter on capturedElement’s new element.
</li>
					<li>
%色~scheme ~SET %新-要素 の `color-scheme$p の`算出d値$
◎
Set colorScheme to the computed value of color-scheme on capturedElement’s new element.
</li>

				</ol>
			</li>
			<li>
<p>
：
</p>
				<ol>
					<li>
<p>
~IF［
%捕捉された要素 の`~group~style規則$cE ~EQ ~NULL
］：
</p>
						<ol>
							<li>
%遷移 に`関連な大域~obj$に`結付けられた文書$の`動的な~view遷移~stylesheet$docに［
下に与える~CSS
］を付加する
◎
If capturedElement’s group styles rule is null, then set capturedElement’s group styles rule to a new CSSStyleRule representing the following CSS,＼
</li>
							<li>
%捕捉された要素 の`~group~style規則$cE ~SET ［
下に与える~CSS
］を表現している新たな `CSSStyleRule$I
◎
and append it to transition’s relevant global object’s associated document’s dynamic view transition style sheet.
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%捕捉された要素 の`~group~style規則$cEを［
下に与える~CSS
］に合致するよう更新する
◎
Otherwise, update capturedElement’s group styles rule to match the following CSS:
</li>
				</ol>
<p>
上で利用される~CSSは：
◎
↑</p>

<pre class="lang-css">
:root::view-transition-group(%遷移~名) {
  width: %横幅;
  height: %縦幅;
  transform: %変形;
  writing-mode: %書字~mode;
  direction: %方向;
  text-orientation: %~text方位;
  mix-blend-mode: %混色~mode;
  backdrop-filter: %後景~filter;
  color-scheme: %色~scheme;
}
</pre>

<p class="note">注記：
上の~code例は、
置換されることになる変数を包含する。
◎
Note: The above code example contains variables to be replaced.
</p>
			</li>
			<li>
<p>
~IF［
%新-要素 ~NEQ ~NULL
］：
◎
If capturedElement’s new element is not null, then:
</p>
				<ol>
					<li>
%新- ~LET 【新たな？】 `view-transition-new()$pe
— その
⇒
`~view遷移~名$ ~SET %遷移~名
◎
Let new be the ::view-transition-new() with the view transition name transitionName.
</li>
					<li>
%新- の`置換され$る内容 ~SET `画像を捕捉する$( %新-要素 )
◎
Set new’s replaced element content to the result of capturing the image of capturedElement’s new element.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET `成功^i
◎
↑↑</li>
</ol>

<p>
この~algoは、［
`~UA出自$に属する ある~styleによる効果
］が［
ある~web~APIにより観測し得る場合
］には，該当する~styleたちを更新するために実行するモノトスル。
◎
This algorithm must be executed to update styles in user-agent origin if its effects can be observed by a web API.
</p>

<p class="note">注記：
そのような~web~APIの例
⇒
<code>window.getComputedStyle(document.documentElement, `::view-transition^l)</code>
◎
Note: An example of such a web API is window.getComputedStyle(document.documentElement, "::view-transition").
</p>
</div>

		</section>
		<section id="clear-view-transition-algorithm">
<h3 title="Clear view transition">13.12. ~view遷移を~clearする</h3>

<div class="algo">
<p>
`~view遷移を~clearする@
~algoは、
所与の
( `ViewTransition$I %遷移 )
に対し：
◎
To clear view transition of a ViewTransition transition:
</p>
<ol>
	<li>
%文書 ~LET %遷移 に`関連な大域~obj$に`結付けられた文書$
◎
Let document be transition’s relevant global object’s associated document.
</li>
	<li>
~Assert：
%文書 にて`作動中な~view遷移$doc ~EQ %遷移
◎
Assert: document’s active view transition is transition.
</li>
	<li>
<p>
%遷移 の`有名~要素~群$vTの`値~群$mapを成す
~EACH( %捕捉された要素 )
に対し：
◎
For each capturedElement of transition’s named elements' values:
</p>
		<ol>
			<li>
~IF［
%捕捉された要素 の`新-要素$cE ~NEQ ~NULL
］
⇒
%捕捉された要素 の`新-要素$cEの`ある~view遷移~内に捕捉されたか$el ~SET ~F
◎
If capturedElement’s new element is not null, then set capturedElement’s new element’s captured in a view transition to false.
</li>
			<li>
%捕捉された要素 の`~style定義~群$cE【を成す~itemたちを表現する~list】を成す
~EACH(  %~style )
に対し
⇒
~IF［
%~style ~NEQ ~NULL
］~AND［
%~style は %文書 の`動的な~view遷移~stylesheet$doc内にある
］
⇒
%文書 の`動的な~view遷移~stylesheet$docから %~style を除去する
◎
For each style of capturedElement’s style definitions:
• If style is not null, and style is in document’s dynamic view transition style sheet, then remove style from document’s dynamic view transition style sheet.
</li>
		</ol>
	</li>
	<li>
%文書 の`~view遷移~treeを示すか$doc ~SET ~F
◎
Set document’s show view transition tree to false.
</li>
	<li>
%文書 にて`作動中な~view遷移$doc ~SET ~NULL
◎
Set document’s active view transition to null.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="priv">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この仕様が導入する新たな~privacyの考慮点は無い。
◎
This specification introduces no new privacy considerations.
</p>

	</section>
	<section id="sec">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
`画像を捕捉する$~algoを利用して生成される画像は、［
非同一-生成元に属する~data
（当の`文書$が非同一-生成元に属する資源を埋込んでいる場合）／
訪問~済み~linkの様な敏感な情報
］も包含し得る。
実装は、［
そのような~dataには，当の`文書$は~accessし得ない
］ことを確保するモノトスル。
これは、
実現可能なはずである
— そのような~accessは、
当の`文書$の既定の描画においても，すでに防止されるべきなので。
◎
The images generated using capture the image algorithm could contain cross-origin data (if the Document is embedding cross-origin resources) or sensitive information like visited links. The implementations must ensure this data can not be accessed by the Document. This should be feasible since access to this data should already be prevented in the default rendering of the Document.
</p>

<p>
非同一-生成元の課題を防止するため，現時点では、
非同一-文書な~view遷移が可能化され得るのは，同一-生成元な~naviに限られる。
それでも、
`WICG/view-transitions 課題 #200＠https://github.com/WICG/view-transitions/issues/200$
にて論じられたとおり，次に挙げる潜在的な脅威がある：
◎
To prevent cross-origin issues, at this point cross-document view transitions can only be enabled for same-origin navigations. As discussed in WICG/view-transitions#200, this still presents two potential threats:
</p>

<ol>
	<li>
新-文書, 旧-文書における`非同一-生成元~能力は隔離されるか？$enVは、
異なるかもしれない。
これは、［
この~flagが~T をとる文書
］が［
この~flagが ~F をとる文書
］から文書から画像~dataを読取れるような状況を生じさせ得る。
これは、
`~level 1$ `§ ~securityの考慮点＠~CSSVT1#sec$
【今や，この節の最初の段落に述べられる】
にて すでに軽減-済みである
— 同じ制約は、
捕捉された非同一-生成元な `iframe$e 用に適用されるので。
◎
The cross-origin isolated capability in both documents might be different. This can cause a situation where a Document that is cross-origin isolated can read image data from a document that is not cross-origin isolated. This is already mitigated in CSS View Transitions 1 § Security Considerations, as the same restriction applies for captured cross-origin iframes.
</li>
	<li>
<p>
同一-生成元な~naviは、
依然として
非同一-生成元な~redirectを介して生じるかもしれない
例：
`https://example.com^c に在る~pageが
`https://auth-provider.com/^c に在る~pageへ~linkしていて，
それが `https://example.com/loggedin^c へ戻るよう~redirectする場合。
◎
A same-origin navigation might still occur via a cross-origin redirect, e.g. https://example.com links to https://auth-provider.com/ which redirects back to https://example.com/loggedin.
</p>

<p>
これは、
非同一-生成元な主体が［
利用者を期待されない当事者-主体~URLへ~redirectする
］一方で［
期待されない遷移を生じさせる
］ことにより，
~redirectが在った事実
【非同一-生成元な文書が介入した事実】
をぼやかす（軽微な）状況を生じさせ得る。
これを軽減するため、
現時点では［
`文書$の`非同一-生成元~redirectを介して作成されたか$doc ~EQ ~T
］の場合には，~navi用の~view遷移は不能化される。
この検査は、
当の`文書$が`作動化し直され$ているときは，
適用されないことに注意
— その事例では、
非同一-生成元な~redirectが すでにその場を占めているので。
◎
This can cause a (minor) situation where the cross-origin party would redirect the user to an unexpected first-party URL, causing an unexpected transition and obfuscating that fact that there was a redirect. To mitigate this, currently view transitions are disabled for navigations if the Document was created via cross-origin redirects. Note that this check doesn’t apply when the Document is being reactivated, as in that case the cross-origin redirect has already taken place.
</p>

<p class="note">注記：
これが適用されるのは、
~server側による~redirectに限られる。
~client側による~redirect
— 例：
<code>&lt;`meta＠~HEmetadata#the-meta-element$ `http-equiv＠~HEmetadata#attr-meta-http-equiv$=`refresh＠~HEmetadata#attr-meta-http-equiv-keyword-refresh$&gt;</code>
を利用するなどによる —
は、
新たな~naviと等価になる。
◎
Note: this only applies to server-side redirects. A client-side redirect, e.g. using [^meta/http-equiv/refresh^], is equivalent to a new navigation.
</p>
	</li>
	<li>
この特能は、
~CSSに より多く情報を公開する
— これまでの~CSSは、
~naviに関係するものを何も自覚しなかったので。
これは、
第三者-主体に属する~CSSの安全性に関わる懸念を提起し得る。
しかしながら，一般~規則として、
第三者-主体に属する~stylesheetは，まずは信用される~sourceから来るベキである
— ~CSSは、［
文書について `learn^en 【？】し得る／
多くの仕方で文書【の呈示】を変更し得る
］ので。
◎
This feature exposes more information to CSS, as so far CSS was not aware of anything navigation-related. This can raise concerns around safety 3rd-party CSS. However, as a general rule, 3rd-party stylesheets should come from trusted sources to begin with, as CSS can learn about the document or change it in many ways.
</li>
</ol>

<p>
詳細な論点は、
`8684$issue,
`WICG/view-transitions 課題 #200＠https://github.com/WICG/view-transitions/issues/200$
を見よ。
◎
See Issue #8684 and WICG/view-transitions#200 for detailed discussion.
</p>

	</section>
	<section id="changes">
<h2 title="Appendix A. Changes">変更点</h2>

◎非規範的

<dl>
	<dt id="changes-since-2024-05-16">
`2024年 05月 16日 作業草案＠~TR/2024/WD-css-view-transitions-2-20240516/$
からの変更点
◎
Changes from 2024-05-16 Working Draft
</dt>
	<dd>
`waitUntil()$m ~methodを追加した。
（ `9901$issue ）
◎
Add waitUntil() (#9901)
</dd>
	<dd>
層~化~捕捉（ `layered capture^en ）の初期~仕様。
【今や除去された。】
（ `10585$issue ）
◎
First pass at layered capture (#10585)
</dd>
	<dd>
［
非同一-生成元~redirectを利用して作成された文書
］の中へ辿るときの遷移を許容した。
（ `11063$issue ）
◎
Allow transitions when traversing into a document that was created using cross-origin redirects (#11063#11063)
</dd>
	<dd>
入子ngに関する少数の詳細を明確化した。
（ `10780$issue, `10633$issue ）
◎
Clarify a few nesting details (#10780 and #10633)
</dd>
	<dd>
`view-transition-name$p 用の値として~keyword `auto$v を許容した。
（ `8320$issue ）
◎
Allow auto as a keyword for view-transition-name (#8320)
</dd>
	<dd>
内へ来る~view遷移~用の時間切れの挙動を明確化した。
（ `10800$issue ）
◎
Clarify timeout behavior for inbound view transition (#10800)
</dd>
	<dd>
内へ来る非同一-文書な~view遷移は、
当の文書が非可視【 `可視性~状態$doc ~EQ `hidden^l 】なときは，飛ばされるべきであるとした。
（ `9822$issue ）
◎
When hiding the document, and inbound cross-document view transition should be skipped. (#9822)
</dd>
	<dd>
`UpdateCallback^I を もっと特有な何か【 `ViewTransitionUpdateCallback$I 】に改称した。
◎
Rename UpdateCallback to something more specific.
</dd>
	<dd>
`CSSViewTransitionRule$I 【の `navigation$m 取得子】は、
`navigation$d 記述子が［
妥当でない／欠落な
］場合には，空~文字列を返すことを明確化した。
（ `10654$issue ）
◎
Clarify that CSSViewTransitionRule returns an empty string for invalid/missing navigation descriptor (#10654)
</dd>
	<dd>
入子な~view遷移~用の初期~仕様
（ `10334$issue ）
◎
Initial spec for nested view transitions (#10334)
</dd>
	<dd>
`view-transition-class$p 【の `none^v 以外の値】は`~tree視野な名前$になるものとした。
（ `10529$issue ）
◎
view-transition-class is a tree-scoped name (#10529)
</dd>
	<dd>
`CSSRule$I を廃用な~patternで拡張することをやめた。
（ `10606$issue ）
◎
Stop extending CSSRule with obsolete pattern (See #10606)
</dd>
	<dd>
`activeViewTransition$m 属性を追加した。
（ `12407$issue ）
◎
Added activeViewTransition attribute (#12407)
</dd>
</dl>

	</section>
</main></div>
