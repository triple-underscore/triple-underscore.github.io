<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Storage （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}


function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}


let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2020-06-05
trans_update:2020-06-07
source_checked:200515
spec_status:LS
original_url:https://storage.spec.whatwg.org/
	abbr_url:STORAGE1
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:storage
copyright:2020,whatwg
trans_1st_pub:2017-02-15


●●class_map
E:error
h:header

●●tag_map
I:code
m:code
E:code
c:code
h:code
i:i

●●original_id_map
	buckets:boxes

●●mdn_urls
navigatorstorage:API/NavigatorStorage
dictdef-storageestimate:API/StorageEstimate
storagemanager:API/StorageManager

●●link_map


Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject
SecureContext:~WEBIDLjs#SecureContext

boolean:~WEBIDL#idl-boolean
unsigned long long:~WEBIDL#idl-unsigned-long-long

I.Navigator:~WAPI#navigator
I.NavigatorStorage:#navigatorstorage
I.StorageEstimate:#dictdef-storageestimate
I.StorageManager:#storagemanager
I.WorkerNavigator:~WORKERS#workernavigator

E.TypeError:~WEBIDL#exceptiondef-typeerror

m.estimate:#dom-storagemanager-estimate
m.persist:#dom-storagemanager-persist
m.persisted:#dom-storagemanager-persisted
m.quota:#dom-storageestimate-quota
m.storage:#dom-navigatorstorage-storage
m.usage:#dom-storageestimate-usage

l.granted:~PERMISSIONS#dom-permissionstate-granted
l.persistent-storage:#dom-permissionname-persistent-storage

	●用語
~storage~quota:#storage-quota
~storage使用量:#storage-usage

~session~storage:#session-storage
局所~storage:#local-storage

~storage端点:#storage-endpoint
登録-済み~storage端点たち:#registered-storage-endpoints
~storage種別:#storage-type
~storage識別子:#storage-identifier
sE.種別たち:#storage-endpoint-types
sE.識別子:#storage-endpoint-identifier
sE.~quota:#storage-endpoint-quota

~storage~key:#storage-key

~storage倉:#storage-shed
~UA~storage倉:#user-agent-storage-shed
~session~storage倉:#browsing-session-storage-shed

~storage棚:#storage-shelf
~bucket~map:#bucket-map

~storage~bucket:#storage-bucket
~session~storage~bucket:#session-storage-bucket
局所~storage~bucket:#bucket
~mode:#bucket-mode
瓶~map:#bottle-map

~storage瓶:#storage-bottle
sB.~map:#storage-bottle-map
sB.~quota:#storage-bottle-quota

~storage~proxy~map:#storage-proxy-map
裏ng~map:#storage-proxy-map-backing-map
~proxy~map参照~集合:#storage-bottle-proxy-map-reference-set

~storage~keyを得する:#obtain-a-storage-key
閲覧~session~storage倉を旧来~cloneする:#legacy-clone-a-browsing-session-storage-shed
~storage棚を作成する:#create-a-storage-shelf
局所~storage棚を得する:#obtain-a-local-storage-shelf
~storage棚を得する:#obtain-a-storage-shelf
~storage~bucketを作成する:#create-a-storage-bucket
~session~storage瓶~mapを得する:#obtain-a-session-storage-bottle-map
~storage瓶~mapを得する:#obtain-a-storage-bottle-map
局所~storage瓶~mapを得する:#obtain-a-local-storage-bottle-map

	§ 許可:#persistence

	●用語（外部
~UA:~INFRA#user-agent
実装定義:~INFRA#implementation-defined

文字列:~INFRA#string
~ASCII文字列:~INFRA#ascii-string

~map:~INFRA#ordered-map
集合:~INFRA#ordered-set
map.~key:~INFRA#map-key
map.値:~INFRA#map-value
	~map内に存在する:~INFRA#map-exists
map.~cloneする:~INFRA#map-clone
map.空:~INFRA#map-is-empty
map.除去する:~INFRA#map-remove
set.付加する:~INFRA#set-append

並列的:~HTMLINFRA#in-parallel

~agent:~TC39#sec-agents
~agent~cluster:~TC39#sec-agent-clusters

不透明な生成元:~ORIGIN#concept-origin-opaque
生成元:~ORIGIN#concept-origin
同一-生成元:~ORIGIN#same-origin
~scheme無しで同じ~site:~ORIGIN#schemelessly-same-site

~taskを~queueする:~WAPI#queue-a-task
現在の設定群~obj:~WAPI#current-settings-object
環境~設定群~obj:~WAPI#environment-settings-object
enV.生成元:~WAPI#concept-settings-object-origin
関連な設定群~obj:~WAPI#relevant-settings-object

閲覧~session:~HISTORY#browsing-session
enV.閲覧~session:~HISTORY#environment-browsing-session

許可~revocation~algo:~PERMISSIONS#permission-revocation-algorithm
許可~状態:~PERMISSIONS#permission-state
強力な特能:~PERMISSIONS#powerful-feature
利用する許可を要請-:~PERMISSIONS#request-permission-to-use

	https://privacycg.github.io/storage-access/
	https://privacycg.github.io/storage-partitioning/
	https://github.com/whatwg/html/issues/
	https://github.com/whatwg/storage/issues/

●●words_table1

●●words_table

	●storage
Storage:
端点:endpoint::~::エンドポイント
倉:shed::~::シェッド
棚:shelf::~::シェルフ
	棚:shelves
bucket::::バケット
	籠:bucket::
瓶:bottle::~::ボトル
裏ng:backing::裏

~backing:
quota::::クォータ
storage::::ストレージ
clear::::クリア
空き:space::~
使用量:usage::~
区分-:segment:~
	仕切り法:partitioning

持続性:persistence::~
持続ed:persisted::持続？
持続的:persistent::~
見積もり:estimate::~
量:amount:~
	byte数:amount of bytes
重複集約:deduplication:重複の集約
圧縮:compression:~
復活-:revive:~
喪失-:lost:~
	get lost
使果たす:run outする:使い果たす
頻度:frequency:~
bookmark::::ブックマーク
近過去度:recency:~
住まう:liveする:~
縛られ:boundされ:~
上限:limit:~

	●保安／環境
TLS:
offline::::オフライン
password::::パスワード
username::::ユーザ名
証明書:certificate:~
認証:authentication:~
成分組:tuple::~
閲覧:browsing::~
復活:revival:~
閉じら:closeさ:~
開き:openし:~
	開き直す:reopen
	し続ける:continued

	●仕様
統括-:consolidate:~
不便さ:inconvenience:~
	不便さ:inconveniencing
保守的:conservative:~
分離-:separate:~
問い:question:~
回答:answer:~
成長-:grow:~
抑える:reduceする:~
末端利用者:end user:~:::エンドユーザ
介入-:intervene:~
同意t:consent:同意（または黙認）
低level:low-level:低 level::低レベル
瑕疵:fault:~
想定-:suppose:~
尺度:scale:~
多様さ:diversity:~
介在:involvement:~
見越され:anticipateされ:~
支援:assistance:~
申請-:file:~
情勢:lay of the land:~
理想的:ideal:~
拡げら:expandさ:~
欠如:lack:~
優先度:priority:~
	優先度に基づく:prioritizing
指図-:instruct:~

	関わる:concerns
	極めて:extremely
	稀:rare
	生じるものとみなす必要がある:the unexpected does occur.
	何年かにわたり:Over the years
	に利する:on behalf of
	特にparticularly
	もたらす:bring
	享受:enjoy
	不必要に:unannounced
	もう少し込み入った:slightly more involved
	ためのもの:equip
	既定のものになる:defaulted
	はっきりしなくなる:obscure
	ある程度の余裕:some wiggle room
	ある程度まで to some extent
	とされた:marked
	駆使:use
	書ける:can be written
	~~策定者:you
	概ね:roughly
	適する:suit
	見込みが高い:likely
	今後:going forward
	担う:take
	形作られた:carved out
	-:in turn
	-:lastly
	伝え:inform
	勝る:outweigh
	なるべく抑える:least
	必要とされよう:necessarily
	特に:most notably

	●未分類
mebibyte::::メビバイト
kibibyte::::キビバイト
agent:
revocation::取り消し
自動生成-:autogenerate:~
chunk::::チャンク
地理所在:geolocation:~

	time
	%設定群~obj:settingsObject
	%新たな棚:newShelf
	総計:total
	総:total
	総〜数:total amount of
	同時に:simultaneous
	同時期:around the same time
	少なく:less than
	ある:left
	からなる:consists of
	より大きい:larger
	例外を投出-:throw
	追跡し続ける:keep-track
	表:table
	%~proxy~map:proxyMap

	●指示語
	1 個の:one
	何らかの:of some kind
	何種類かの:various kinds of
	まるごと:in its entirety
	ほとんどは:mostly
	重ねて:twice
	およその:rough
	何:how much
	何らかの類の:some kind of
	半-:semi-
	〜側:-side
	初回:first time
	場所:place

●●ref_normative

[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.es/ecma262/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[PERMISSIONS]
    Mounir Lamouri; Marcos Caceres; Jeffrey Yasskin. Permissions. URL: https://w3c.github.io/permissions/ 
[WEBIDL]
    Boris Zbarsky. Web IDL. URL: https://heycam.github.io/webidl/ 

●●
ref_informative


●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.whatwg.org/">WHATWG</a>
による
<a href="~SPEC_URL">Storage Standard</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/storage">GitHub whatwg/storage</a> (<a href="https://github.com/whatwg/storage/issues/new">new issue</a>, <a href="https://github.com/whatwg/storage/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	https://github.com/whatwg/storage/commits
	<a href="https://storage.spec.whatwg.org/commit-snapshots/f696843c13d23f147081c2e87f0c2e52aadde533/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/storagestandard">@storagestandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/storage">web-platform-tests storage/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/storage">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>

<body>

<header>

<a href="https://whatwg.org/"><img style="float: right;" alt="WHATWG" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPHBhdGggZD0iTTAsMEwyMCwwTDIwLDMwTDgwLDMwTDgwLDBMOTAsMEwxMDAsMTBMMTAwLDEwMEw5MCwxMDBMOTAsNDVMMTAsNDVMMTAsOTBMOTAsOTBMOTAsMTAwTDAsMTAwIiBmaWxsPSIjM2M3OTBhIi8+CjxyZWN0IHdpZHRoPSIxNSIgaGVpZ2h0PSIyNSIgeD0iNTcuNSIgeT0iMi41IiBmaWxsPSIjM2M3OTBhIi8+Cjwvc3ZnPgo=" height="100"></a>

	<hgroup>
<h1 id="title">Storage</h1>
   </hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
~Storage標準は、持続的な~storageと~quota見積もり用の~API, および
~platform~storage~architectureを定義する。
◎
The Storage Standard defines an API for persistent storage and quota estimates, as well as the platform storage architecture.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~webは、何年かにわたり~storage用に利用できる様々な~APIを成長させてきた
— 例えば
IndexedDB, `localStorage^c, `showNotification()^c
。
~Storage標準は、次を定義することにより，これらの~APIを統括する：
◎
Over the years the web has grown various APIs that can be used for storage, e.g., IndexedDB, localStorage, and showNotification(). The Storage Standard consolidates these APIs by defining:
</p>

<ul>
	<li>
これらの~APIが~dataを格納するための~primitiveとなる，~bucket。
◎
A bucket, the primitive these APIs store their data in
</li>
	<li>
その~bucketを持続的にする仕方。
◎
A way of making that bucket persistent
</li>
	<li>
与えられた`生成元$に対する使用量と~quota見積もりを取得する仕方。
◎
A way of getting usage and quota estimates for an origin
</li>
</ul>

<p>
伝統的に，これらの~APIにより格納された~dataは、機器~storageの空きを利用者が使果たすに伴い，利用者が介入できることなく喪失されていた。
が、持続的な~bucketは，利用者の同意tなくしては~clearできない。
したがってこれは、利用者が~webに~nativeな~platformで享受した~dataの保証をもたらす。
◎
Traditionally, as the user runs out of storage space on their device, the data stored with these APIs gets lost without the user being able to intervene. However, persistent buckets cannot be cleared without consent by the user. This thus brings data guarantees users have enjoyed on native platforms to the web.
</p>

<div class="example">
<p>
~storageを持続的にする単純な仕方は、
`persist()$m ~methodを呼出すことである。
それは同時に，末端利用者に許可を要請して、是認されれば，~storageを持続的になるよう変更する：
◎
A simple way to make storage persistent is through invoking the persist() method. It simultaneously requests the end user for permission and changes the storage to be persistent once granted:
</p>

<pre class="lang-js">
navigator.storage.persist().then(%persisted =&gt; {
  if (%persisted) {
    /* … */
  }
});
</pre>

<p>
~UAにより駆動される~dialogを 末端利用者に不必要に示さない，もう少し込み入った~codeも書ける：
◎
To not show user-agent-driven dialogs to the end user unannounced slightly more involved code can be written:
</p>

<pre class="lang-js">
Promise.all([
  navigator.storage.persisted(),
  navigator.permissions.query({name: "persistent-storage"})
]).then(([%persisted, %permission]) =&gt; {
  if (!%persisted &amp;&amp; %permission.status == "granted") {
    navigator.storage.persist().then( /* … */ )
  } else if (!%persisted &amp;&amp; %permission.status == "prompt") {
    showPersistentStorageExplanation()
  }
});
</pre>

<p>
`estimate()$m ~methodを利用すれば，~appが格納する内容に十分な空きがあるかどうかも決定できる：
◎
The estimate() method can be used to determine whether there is enough space left to store content for an application:
</p>

<pre class="lang-js">
function retrieveNextChunk(%nextChunkInfo) {
  return navigator.storage.estimate().then(%info =&gt; {
    if (%info.quota - %info.usage &gt; %nextChunkInfo.size) {
      return fetch(%nextChunkInfo.url);
    } else {【！"insufficient space to store next chunk"】
      throw new Error("次の~chunkを格納するための空きが足りません")
    }
  }).then( /* … */ );
}
</pre>

</div>

	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
この仕様は、  Infra 標準 `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様は、次に挙げる各種~標準による各種用語を利用する
⇒＃
`HTML$r
`WEBIDL$r
`PERMISSIONS$r
◎
This specification uses terminology from the HTML, IDL, and Permissions Standards. [HTML] [WEBIDL] [PERMISSIONS]
</p>

	</section>
	<section id="infrastructure">
<h2 title="Lay of the land">3. 情勢</h2>

<p>
`~UA$は、次に挙げるような何種類かの半-持続的な状態を備える：
◎
A user agent has various kinds of semi-persistent state:
</p>

<dl>
	<dt>資格証~storage</dt>
	<dd>
~HTML~formを通して提出された~usernameや~passwordなど，末端利用者の資格証からなる。
◎
End-user credentials, such as username and passwords submitted through HTML forms
</dd>
	<dt>許可~storage</dt>
	<dd>
地理所在など，様々な特能に対する許可からなる。
◎
Permissions for various features, such as geolocation
</dd>

	<dt>~network~storage</dt>
	<dd>
次に挙げるもの, 等々からなる
⇒＃
~HTTP~cache,
~cookie,
認証~entry,
~TLS~client証明書
◎
HTTP cache, cookies, authentication entries, TLS client certificates
</dd>

	<dt id="site-storage">~storage</dt>
	<dd>
次に挙げるもの, 等々からなる
⇒＃
Indexed DB,
Cache API,
~sw登録,
`localStorage^m,
`sessionStorage^m,
~app~cache,
通知
◎
Indexed DB, Cache API, service worker registrations, localStorage, sessionStorage, application caches, notifications, etc.
</dd>
</dl>

<p>
この標準が首に関わるのは、~storageである。
◎
This standard primarily concerns itself with storage.
</p>

	</section>
	<section id="model">
<h2 title="Model">4. ~model</h2>

<p>
［
局所／~session
］~storage~APIを定義している標準は、`~storage端点$を定義して，それを
— この標準を変更することを通して —
`登録-済み~storage端点たち$に登録することになる。
当の標準は、［
`局所~storage瓶~mapを得する$／
`~session~storage瓶~mapを得する$
］いずれかを利用してそれを与えることになる：
◎
Standards defining local or session storage APIs will define a storage endpoint and register it by changing this standard. They will use either obtain a local storage bottle map or obtain a session storage bottle map, which will give them:
</p>
<ul>
	<li>
結果における `失敗^i は、次のいずれかを意味する
⇒＃
当の~APIは、例外を投出する必要があるかもしれない／
当の`環境~設定群~obj$用に可用な~storageは無いことを指示する
◎
Failure, which might mean the API has to throw or otherwise indicate there is no storage available for that environment settings object.
</li>
	<li>
`~storage~proxy~map$は、当の~APIに適する方式で~dataを格納するために利用でき，`~map$と相似的に演算する。
［
当の~APIと他の~APIからの~data／
各`~storage~key$／
各`~storage種別$
］どうしを隔離する~careは、この標準が担う。
◎
A storage proxy map that operates analogously to a map, which can be used to store data in a manner that suits the API. This standard takes care of isolating that data from other APIs, storage keys, and storage types.
</li>
</ul>

<p class="note">注記：
そのような~API用の標準を定義している~~策定者は、この標準に対し課題を申請して，支援と考査を受けることを考慮すること。
◎
If you are defining a standard for such an API, consider filing an issue agains this standard for assistance and review.
</p>

<p>
この~dataを隔離するため、この標準は，次を定義する：
◎
To isolate this data this standard defines＼
</p>

<ul>
	<li>
`~storage倉$は、`~storage~key$により各`~storage棚$を区分する。
◎
a storage shed which segments storage shelves by a storage key.＼
</li>
	<li>
`~storage棚$は、1 個の`~storage~bucket$からなる
— が，将来には、各種~storage施策~用に，複数個の`~storage~bucket$からなることも許容することになる見込みが高い。
◎
A storage shelf in turn consists of a storage bucket and will likely consist of multiple storage buckets in the future to allow for different storage policies.＼
</li>
	<li>
`~storage~bucket$は、
0 個以上の
— 各`~storage端点$ごとに 1 個ある —
`~storage瓶$からなる。
◎
And lastly, a storage bucket consists of storage bottles, one for each storage endpoint.
</li>
</ul>

		<section id="storage-endpoints">
<h3 title="Storage endpoints">4.1. ~storage端点</h3>

<p>
`~storage端点@
（ `storage endpoint^en ）は、その~storageに必要なものを追跡し続けるために，この標準が定義する基盤
— 特に，`~storage瓶$ —
を利用する［
`局所~storage$／`~session~storage$
］~APIである。
◎
A storage endpoint is a local or session storage API that uses the infrastructure defined by this standard, most notably storage bottles, to keep track of its storage needs.
</p>

<p>
各`~storage端点$は、次に挙げるものを有する：
</p>
<ul>
	<li>
`識別子@sE
— ある`~storage識別子$
◎
A storage endpoint has an identifier, which is a storage identifier.
</li>
	<li>
`種別たち@sE
— いくつかの`~storage種別$からなる`集合$
◎
A storage endpoint also has types, which is a set of storage types.
</li>
	<li>
`~quota@sE
— ~NULL または［
この`~storage端点$に対応する すべての`~storage瓶$
］用に推奨される`~quota$sBを（~byte数で）表現する数。
◎
A storage endpoint also has a quota, which is null or a number representing a recommended quota (in bytes) for all storage bottles corresponding to this storage endpoint.
</li>
</ul>

<p>
`~storage識別子@
（ `storage identifier^en ）は、`~ASCII文字列$である。
◎
A storage identifier is an ASCII string.
</p>

<p>
`~storage種別@
（ `storage type^en ）は、［
`local^l ／ `session^l 
］である。
◎
A storage type is "local" or "session".
</p>

<hr>

<p>
`登録-済み~storage端点たち@
（ `egistered storage endpoints^en ）は、次の表により定義される，`~storage端点$からなる`集合$である：
◎
The registered storage endpoints are a set of storage endpoints defined by the following table:
</p>

<div style="overflow:auto;"><table><thead>
<tr><th>
`識別子$sE
<th>
`種別たち$sE
<th>
`~quota$sE
</thead><tbody>

<tr><td>`caches^l
<td>« `local^l »
<td>~NULL

<tr><td>`indexedDB^l
<td>« `local^l »
<td>~NULL

<tr><td>`localStorage^l
<td>« `local^l »
<td>5 ~mebibyte†

<tr><td>`serviceWorkerRegistrations^l
<td>« `local^l »
<td>~NULL

<tr><td>`sessionStorage^l
<td>« `session^l »
<td>5 ~mebibyte†

</tbody></table>

<p>†
1 ~mebibyte ~EQ 2 の 20 乗 （ ~EQ ~kibibyte の 2 乗）
</p>

◎
Identifier｜Type｜Quota
"caches"｜« "local" »｜null
"indexedDB"｜« "local" »｜null
"localStorage"｜« "local" »｜5 × 220 (i.e., 5 mebibytes)
"serviceWorkerRegistrations"｜« "local" »｜null
"sessionStorage"｜« "session" »｜5 × 220 (i.e., 5 mebibytes) 
</div>

<p class="note">注記：
各 標準は，すでに言及したように、これらの`~storage識別子$を利用して［
`局所~storage瓶~mapを得する$／
`~session~storage瓶~mapを得する$
］ことができる。
一部の~APIは、今後，どちらの`~storage種別$にも適用-可能になるものと見越されている。
◎
As mentioned, standards can use these storage identifiers with obtain a local storage bottle map and obtain a session storage bottle map. It is anticipated that some APIs will be applicable to both storage types going forward.
</p>

		</section>
		<section id="storage-keys">
<h3 title="Storage keys">4.2. ~storage~key</h3>

<p>
`~storage~key@
（ `storage key^en ）は、`生成元$である。
`HTML$r
◎
A storage key is an origin. [HTML]
</p>

<p class="XXX">
これは変更されるものと予期される
— <a href="https://privacycg.github.io/storage-partitioning/">~client側~storageの仕切り法</a>
を見よ。
◎
This is expected to change; see Client-Side Storage Partitioning.
</p>

<div class="algo">
<p>
`~storage~keyを得する@
ときは、所与の
( `環境~設定群~obj$ %環境 )
に対し，次の手続きを走らす：
◎
To obtain a storage key, given an environment settings object environment, run these steps:
</p>

<ol>
	<li>
%~key ~LET %環境 の`生成元$enV
◎
Let key be environment’s origin.
</li>
	<li>
~IF［
%~key は`不透明な生成元$である
］
⇒
~RET `失敗^i
◎
If key is an opaque origin, then return failure.
</li>
	<li>
~IF［
利用者は、~storageを不能化した
］
⇒
~RET `失敗^i
◎
If the user has disabled storage, then return failure.
</li>
	<li>
~RET %~key
◎
Return key.
</li>
</ol>
</div>

		</section>
		<section id="storage-sheds">
<h3 title="Storage sheds">4.3. ~storage倉</h3>

<p>
`~storage倉@
（ `storage shed^en ）は、`~storage~key$から`~storage棚$への`~map$であり、初期~時には空とする。
【~keyの比較-法が述べられていないが、`同一-生成元$に基づくであろう。】
◎
A storage shed is a map of storage keys to storage shelves. It is initially empty.
</p>

<hr>

<p>
各`~UA$は、
`~UA~storage倉@
を保持する。
それは、`~storage倉$であり，すべての
`局所~storage@
（ `local storage^en ）~dataを保持する。
◎
A user agent holds a storage shed, which is a storage shed. A user agent’s storage shed holds all local storage data.
</p>

<p>
各 `閲覧~session$は、
`~session~storage倉@
を保持する。
それは、`~storage倉$であり，すべての
`~session~storage@
（ `session storage^en ）~dataを保持する。
◎
A browsing session holds a storage shed, which is a storage shed. A browsing session’s storage shed holds all session storage data.
</p>

<div class="algo">
<p>
`閲覧~session~storage倉を旧来~cloneする@
するときは、所与の
( `閲覧~session$ %A, `閲覧~session$ %B )
に対し，次の手続きを走らす：
◎
To legacy-clone a browsing session storage shed, given a browsing session A and a browsing session B, run these steps:
</p>
<ol>
	<li>
<p>
%A の`~session~storage倉$を成す
~EACH( %~key → %棚 )
に対し：
◎
For each key → shelf of A’s storage shed:
</p>
		<ol>
			<li>
%新たな棚 ~LET `~storage棚を作成する$( `session^l )
◎
Let newShelf be the result of running create a storage shelf with "session".
</li>
			<li>
%新たな棚 の`~bucket~map$[ `default^l ] の`瓶~map$[ `sessionStorage^l ] の`~map$sB ~SET %棚 の`~bucket~map$[ `default^l ] の`瓶~map$[ `sessionStorage^l ] の`~map$sBを`~cloneする$map
◎
Set newShelf’s bucket map["default"]'s bottle map["sessionStorage"]'s map to a clone of shelf’s bucket map["default"]'s bottle map["sessionStorage"]'s map.
</li>
			<li>
%B の`~session~storage倉$[ %~key ] ~SET %新たな棚
◎
Set B’s storage shed[key] to newShelf.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
これは、旧来のものと見なされる
— 便益があるとしても，実装の複階性に勝るものではないので。
したがって、 `HTML$r の外側へ［
拡げられる／利用される
］ことはない。
◎
This is considered legacy as the benefits, if any, do not outweigh the implementation complexity. And therefore it will not be expanded or used outside of HTML. [HTML]
</p>
</div>

		</section>
		<section id="storage-shelves">
<h3 title="Storage shelves">4.4. ~storage棚</h3>

<p>
`~storage棚@
（ `storage shelf^en ）は、`~storage倉$の中の各`~storage~key$に対し存在する。
それは、
`~bucket~map@
— `文字列$から`~storage~bucket$への`~map$ —
を保持する。
◎
A storage shelf exists for each storage key within a storage shed. It holds a bucket map, which is a map of strings to storage buckets.
</p>

<p class="note">注記：
今の所、`~bucket~map$に存在する`~key$mapは `default^l しかない。
<a href="https://github.com/whatwg/storage/issues/2">課題 #2</a>
を見よ。
対応する`値$mapは、初回に<a href="#obtain-a-storage-shelf">~storage棚が得された</a>とき，与えられる。
◎
For now "default" is the only key that exists in a bucket map. See issue #2. It is given a value when a storage shelf is obtained for the first time.
</p>

<div class="algo">
<p>
`~storage棚を得する@
ときは、所与の
( `~storage倉$ %倉, `環境~設定群~obj$ %環境, `~storage種別$ %種別 )
に対し，次の手続きを走らす：
◎
To obtain a storage shelf, given a storage shed shed, an environment settings object environment, and a storage type type, run these steps:
</p>

<ol>
	<li>
%~key ~LET `~storage~keyを得する$( %環境 )
◎
Let key be the result of running obtain a storage key with environment.
</li>
	<li>
~IF［
%~key ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If key is failure, then return failure.
</li>
	<li>
~IF［
%倉[ %~key ] ~EQ ε
］
⇒
%倉[ %~key ] ~SET `~storage棚を作成する$( %種別 )
◎
If shed[key] does not exist, then set shed[key] to the result of running create a storage shelf with type.
</li>
	<li>
~RET %倉[ %~key ]
◎
Return shed[key].
</li>
</ol>
</div>

<div class="algo">
<p>
`局所~storage棚を得する@
ときは、所与の
( `環境~設定群~obj$ %環境 )
に対し，次の結果を返す
⇒
`~storage棚を得する$( `~UA~storage倉$, %環境, `local^l )
◎
To obtain a local storage shelf, given an environment settings object environment, return the result of running obtain a storage shelf with the user agent’s storage shed, environment, and "local".
</p>
</div>

<div class="algo">
<p>
`~storage棚を作成する@
ときは、所与の
( `~storage種別$ %種別 )
に対し，次の手続きを走らす：
◎
To create a storage shelf, given a storage type type, run these steps:
</p>
<ol>
	<li>
%棚 ~LET 新たな`~storage棚$
◎
Let shelf be a new storage shelf.
</li>
	<li>
%棚 の`~bucket~map$[ `default^l ] ~SET `~storage~bucketを作成する$( %種別 )
◎
Set shelf’s bucket map["default"] to the result of running create a storage bucket with type.
</li>
	<li>
~RET %棚
◎
Return shelf.
</li>
</ol>
</div>

		</section>
		<section id="buckets">
<h3 title="Storage buckets">4.5. ~storage~bucket</h3>

<p>
`~storage~bucket@
（ `storage bucket^en ／ “バケツ” ）は、`~storage端点$用の~dataを格納する場所である。
◎
A storage bucket is a place for storage endpoints to store data.
</p>

<p>
各`~storage~bucket$は、`~storage識別子$から`~storage瓶$への
`瓶~map@
（ `bottle map^en ）を有する。
◎
A storage bucket has a bottle map of storage identifiers to storage bottles.
</p>

<hr>

<p>
`局所~storage~bucket@
は、`局所~storage$~API用の`~storage~bucket$である。
◎
A local storage bucket is a storage bucket for local storage APIs.
</p>

<p>
各 `局所~storage~bucket$は
`~mode@
を有する。
それは、［
`best-effort^l, `persistent^l
］のいずれかであり，初期~時には `best-effort^l とする。
◎
A local storage bucket has a mode, which is "best-effort" or "persistent". It is initially "best-effort".
</p>

<hr>

<p>
`~session~storage~bucket@
は、`~session~storage$~API用の`~storage~bucket$である。
◎
A session storage bucket is a storage bucket for session storage APIs.
</p>

<hr>

<div class="algo">
<p>
`~storage~bucketを作成する@
ときは、所与の
( `~storage種別$ %種別 )
に対し，次の手続きを走らす：
◎
To create a storage bucket, given a storage type type, run these steps:
</p>
<ol>
	<li>
%~bucket ~LET %種別 に応じて
⇒＃
`local^l ならば 新たな`局所~storage~bucket$／
`session^l ならば 新たな`~session~storage~bucket$
◎
Let bucket be null.
◎
If type is "local", then set bucket to a new local storage bucket.
◎
Otherwise:
• Assert: type is "session".
• Set bucket to a new session storage bucket.
</li>
	<li>
`登録-済み~storage端点たち$を成す
~EACH( %端点 )
に対し，
⇒
~IF［
%種別 ~IN %端点 の`種別たち$sE
］
⇒
%~bucket の`瓶~map$[ %端点 の`識別子$sE ] ~SET 次のようにされた新たな`~storage瓶$
⇒
`~quota$sB ~SET %端点 の`~quota$sE
◎
For each endpoint of registered storage endpoints whose types contain type, set bucket’s bottle map[endpoint’s identifier] to a new storage bottle whose quota is endpoint’s quota.
</li>
	<li>
~RET %~bucket
◎
Return bucket.
</li>
</ol>
</div>

		</section>
		<section id="storage-bottles">
<h3 title="Storage bottles">4.6. ~storage瓶</h3>

<p>
`~storage瓶@
（ `storage bottle^en ）は、`~storage~bucket$の一部を成すよう，単独の`~storage端点$用に形作られたものである。
◎
A storage bottle is a part of a storage bucket carved out for a single storage endpoint.＼
</p>

<p>
各`~storage瓶$は、次に挙げるものを有する：
◎
↓</p>

<ul>
	<li>
`~map@sB
— 初期~時には空な`~map$とする。
◎
A storage bottle has a map, which is initially an empty map.＼
</li>
	<li>
`~proxy~map参照~集合@
— 初期~時には空な`集合$とする。
◎
A storage bottle also has a proxy map reference set, which is initially an empty set.＼
</li>
	<li>
<p>
`~quota@sB
— ~NULL または［
自身が保持できる総~byte数
］の保守的な見積もりを表現する数。
~NULL は上限の欠如を指示する†。
</p>
<p class="note">†
それでも、包摂している`~storage棚$の`~storage~quota$に縛られる。
</p>
◎
A storage bottle also has a quota, which is null or a number representing a conservative estimate of the total amount of bytes it can hold. Null indicates the lack of a limit. It is still bound by the storage quota of its encompassing storage shelf.
</li>
</ul>

<p>
`~storage瓶$の`~map$sBは、格納するよう意味された実際の~dataが住まう所である。
~UAには
— この標準, この標準を利用している各 標準が当の内容に~accessできるよう —
`実装定義$な方式で［
この~dataを格納して，各`~agent$, さらには`~agent~cluster$の境界にまたがって可用にする
］ことが期待される。
◎
A storage bottle’s map is where the actual data meant to be stored lives. User agents are expected to store this data, and make it available across agent and even agent cluster boundaries, in an implementation-defined manner, so that this standard and standards using this standard can access the contents.
</p>

<hr>

<div class="algo">
<p>
`~storage瓶~mapを得する@
ときは、所与の
( `~storage種別$ %種別, `環境~設定群~obj$ %環境, `~storage識別子$ %識別子 )
に対し，次の手続きを走らす：
◎
To obtain a storage bottle map, given a storage type type, environment settings object environment, and storage identifier identifier, run these steps:
</p>
<ol>
	<li>
%倉 ~LET %種別 に応じて
⇒＃
`local^l ならば `~UA~storage倉$／
`session^l ならば %環境 の`閲覧~session$enVの`~session~storage倉$
◎
Let shed be null.
◎
If type is "local", then set shed to the user agent’s storage shed.
◎
Otherwise:
• Assert: type is "session".
• Set shed to environment’s browsing session’s storage shed.
</li>
	<li>
%棚 ~LET `~storage棚を得する$( %倉, %環境, %種別 )
◎
Let shelf be the result of running obtain a storage shelf, with shed, environment, and type.
</li>
	<li>
~IF［
%棚 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If shelf is failure, then return failure.
</li>
	<li>
%~bucket ~LET %棚 の`~bucket~map$[ `default^l ]
◎
Let bucket be shelf’s bucket map["default"].
</li>
	<li>
%瓶 ~LET %~bucket の`瓶~map$[ %識別子 ]
◎
Let bottle be bucket’s bottle map[identifier].
</li>
	<li>
%~proxy~map ~LET %瓶 の`~map$sBを`裏ng~map$とする，新たな`~storage~proxy~map$
◎
Let proxyMap be a new storage proxy map whose backing map is bottle’s map.
</li>
	<li>
%瓶 の`~proxy~map参照~集合$に %~proxy~map を`付加する$set
◎
Append proxyMap to bottle’s proxy map reference set.
</li>
	<li>
~RET %~proxy~map
◎
Return proxyMap.
</li>
</ol>
</div>

<div class="algo">
<p>
`局所~storage瓶~mapを得する@
ときは、所与の
( `環境~設定群~obj$ %環境, `~storage識別子$ %識別子 )
に対し，次の結果を返す
⇒
`~storage瓶~mapを得する$( `local^l, %環境, %識別子 )
◎
To obtain a local storage bottle map, given an environment settings object environment and storage identifier identifier, return the result of running obtain a storage bottle map with "local", environment, and identifier.
</p>
</div>

<div class="algo">
<p>
`~session~storage瓶~mapを得する@
ときは、所与の
( `環境~設定群~obj$ %環境, `~storage識別子$ %識別子 )
に対し，次の結果を返す
⇒
`~storage瓶~mapを得する$( `session^l, %環境, %識別子 )
◎
To obtain a session storage bottle map, given an environment settings object environment and storage identifier identifier, return the result of running obtain a storage bottle map with "session", environment, and identifier.
</p>
</div>

		</section>
		<section id="storage-proxy-maps">
<h3 title="Storage proxy maps">4.7. ~storage~proxy~map</h3>

<p>
`~storage~proxy~map@
（ `storage proxy map^en ）は、次を除いて，`~map$に等価である
⇒
それに対する演算は、代わりに その
`裏ng~map@
（ `backing map^en ）に対し遂行される
◎
A storage proxy map is equivalent to a map, except that all operations are instead performed on its backing map.
</p>

<p class="XXX">
これは、`裏ng~map$を別の~mapに置換することを許容する。
これは、
<a href="https://github.com/whatwg/storage/issues/4">課題 #4</a>
用に必要になり，
<a href="https://privacycg.github.io/storage-access/">~storage~access~API</a>
用にも必要になり得る。
◎
This allows for the backing map to be replaced. This is needed for issue #4 and potentially the Storage Access API.
</p>

		</section>
	</section>
	<section id="persistence">
<h2 title="Persistence permission">5. 持続性~許可</h2>

<p>
`局所~storage~bucket$の`~mode$が `persistent^l 【 “持続的” 】に変更されるのは、利用者が（または、~UAが，利用者に利するために） `persistent-storage$l 特能を利用する許可を是認したときに限られる。
◎
A local storage bucket can only have its mode change to "persistent" if the user (or user agent on behalf of the user) has granted permission to use the "persistent-storage" feature.
</p>

<p class="note">注記：
`生成元$に是認されたなら、持続性~許可は，［
~UAによる ~storageを~clearするための施策
］から保護するために利用できる。
~UAは、`生成元$や利用者の介在~抜きには，持続的にされた~storageを~clearできない。
これは特に、利用者が~offlineの間に可用にする必要がある資源や, 利用者が局所的に作成した資源に対し，有用になる。
◎
When granted to an origin, the persistence permission can be used to protect storage from the user agent’s clearing policies. The user agent cannot clear storage marked as persistent without involvement from the origin or user. This makes it particularly useful for resources the user needs to have available while offline or resources the user creates locally.
</p>

<p>
この仕様は、`強力な特能$（ `powerful feature^en ）として，
`persistent-storage@l
を定義する。
その許可に関係する各種［
~flag, ~algo, 型
］は、次を除いて既定のものになる：
◎
The "persistent-storage" powerful feature’s permission-related flags, algorithms, and types are defaulted, except for:
</p>

<dl>
	<dt>`許可~状態$（ `permission state^en ）</dt>
	<dd>
`persistent-storage$l の`許可~状態$の値は、同じ`生成元$enVを伴う すべての`環境~設定群~obj$にわたり，同じにするモノトスル。
◎
"persistent-storage"'s permission state must have the same value for all environment settings objects with a given origin.
</dd>

	<dt>`許可~revocation~algo$（ `permission revocation algorithm^en ）</dt>
	<dd>
<p>
次を走らす：
</p>
		<ol>
			<li>
~IF［
`persistent-storage$l の`許可~状態$ ~EQ `granted$l
］
⇒
~RET
◎
If "persistent-storage"'s permission state is "granted", then return.
</li>
			<li>
%棚 ~LET `局所~storage棚を得する$( `現在の設定群~obj$ )
◎
Let shelf be the result of running obtain a local storage shelf with current settings object.
</li>
			<li>
%棚 の`~bucket~map$[ `default^l ] の`~mode$ ~SET `best-effort^l
◎
Set shelf’s bucket map["default"]'s mode to "best-effort".
</li>
		</ol>
</dd>
</dl>

	</section>
	<section id="usage-and-quota">
<h2 title="Usage and quota">6. 使用量と~quota</h2>

<p>
`~storage使用量@
（ `storage usage^en ）とは、およその見積もりによる，`~storage棚$が利用している~byte数である。
◎
The storage usage of a storage shelf is a rough estimate of the amount of bytes used by it.
</p>

<p class="note">注記：
これは正確な量にはなり得ない。
~UAは、`~storage棚$が正確に何~byte利用しているか はっきりしなくなるような，重複集約, 圧縮, その他の技法を駆使してるかもしれず、また~UAには，そうすることが奨励されるので。
◎
This cannot be an exact amount as user agents might, and are encouraged to, use deduplication, compression, and other techniques that obscure exactly how much bytes a storage shelf uses.
</p>

<p>
`~storage~quota@
（ `storage quota^en ）とは、保守的な見積もりによる，`~storage棚$が保持できる総~byte数である。
この量は、利用者に ある程度の余裕を与えるため，機器~storageの可用な空きの総計より少なくなるべきである。
◎
The storage quota of a storage shelf is a conservative estimate of the total amount of bytes it can hold. This amount should be less than the total available storage space on the device to give users some wiggle room.
</p>

<p class="note">注記：
~UAには、~quotaを評価するときには［
~naviの頻度,
訪問の近過去度,
~bookmarkされたかどうか,
`persistent-storage$l に対する<a href="#persistence">許可</a>
］を考慮することが強く奨励される。
◎
User agents are strongly encouraged to consider navigation frequency, recency of visits, bookmarking, and permission for "persistent-storage" when evaluating quotas.
</p>

	</section>
	<section id="management">
<h2 title="Management">7. 管理</h2>

<p>
~UAは、`~storage~bucket$を~clearするときには，まるごと~clearするモノトスル。
~UAは、それらに~access可能な~scriptが走っている間は
— 利用者から他が指図されない限り —
`~storage~bucket$を~clearするのを，避けるベキである。
◎
Whenever a storage bucket is cleared by the user agent, it must be cleared in its entirety. User agents should avoid clearing storage buckets while script that is able to access them is running, unless instructed otherwise by the user.
</p>

<p>
`~storage~bucket$の除去により，それを包摂している`~storage棚$ %棚 の`~bucket~map$が`空$mapになった場合、 %棚 を包摂している`~storage倉$から，対応する`~storage~key$とともに %棚 を`除去する$mapこと。
◎
If removal of storage buckets leaves the encompassing storage shelf’s bucket map empty, then remove that storage shelf and corresponding storage key from the encompassing storage shed.
</p>

		<section id="storage-pressure">
<h3 title="Storage Pressure">7.1. ~storageの逼迫</h3>

<p>
~UAは、~storageが逼迫してきたときは，~network状態, および
`局所~storage~bucket$のうち［
`~mode$ ~EQ `best-effort^l
］なるものを~clearするベキである。
理想的には、利用者への影響iをなるべく抑えるような，優先度に基づく除去~方式で。
◎
A user agent that comes under storage pressure should clear network state and local storage buckets whose mode is "best-effort", ideally prioritizing removal in a manner that least impacts the user.
</p>

<p>
それでもなお，~storageが逼迫している場合、~UAは，そのことを利用者に伝えた上で、残りの`局所~storage~bucket$
— すなわち，`~mode$ ~EQ `persistent^l なるもの —
を~clearする仕方を利用者に提供するべきである。
◎
If a user agent continues to be under storage pressure, then the user agent should inform the user and offer a way to clear the remaining local storage buckets, i.e., those whose mode is "persistent".
</p>

<p>
`閲覧~session$が閉じられたときは、それに伴い，`~session~storage~bucket$も~clearするモノトスル。
◎
Session storage buckets must be cleared as browsing sessions are closed.
</p>

<p class="note">注記：
`閲覧~session$の復活
— 例： `閲覧~session$を開き直すことを通して／
~UAを開始し直した後も，それを利用し続けるなど —
を許容する~UAは、もっと複階的な経験則を孕む~clear法が必要とされよう。
◎
If the user agent allows for revival of browsing sessions, e.g., through reopening browsing sessions or continued use of them after restarting the user agent, then clearing necessarily involves a more complex set of heuristics.
</p>

		</section>
		<section id="ui-guidelines">
<h3 title="User interface guidelines">7.2. ~UI指針</h3>

<p>
~UAは、自身の~UIにおいて~network状態と~storageを判別させるべきでない。
代わりに、各［
`~scheme無しで同じ~site$に属する生成元たちが成す~group
］に対し［
それ用の~storageをすべて~clearする能
］を，利用者に提供するべきである。
これは、ある程度まで，［
~network状態を利用しても，~storageは復活できなくする
］ことを確保する。
これはまた、［
~web~siteが~dataを格納できる種々の仕方について，利用者が知る必要がある量
］を抑える。
◎
User agents should not distinguish between network state and storage in their user interface. Instead user agents should offer users the ability to clear all storage for each group of schemelessly same site origins. This ensures to some extent that network state cannot be used to revive storage. This also reduces the amount users need to know about the different ways in which websites can store data.
</p>

<p>
資格証は、他から分離されるべきである。
資格証は、利用者が復活できないかもしれない~data
— 自動生成された~passwordなど —
を包含するので。
許可~storageも、利用者の不便さを避けるため，分離するのが最善である。
◎
Credentials should be separated as they contain data the user might not be able to revive, such as an autogenerated password. Permissions are best separated too to avoid inconveniencing the user.
</p>

		</section>
	</section>
	<section id="api">
<h2 title="API">8. ~API</h2>

<pre class="idl">
[`SecureContext$]
interface mixin `NavigatorStorage@I {
  [`SameObject$] readonly attribute `StorageManager$I `storage$m;
};

`Navigator$I includes `NavigatorStorage$I;
`WorkerNavigator$I includes `NavigatorStorage$I;
</pre>

<p>
各`環境~設定群~obj$ `HTML$r には、
`StorageManager$I ~objが結付けられる。
◎
Each environment settings object has an associated StorageManager object. [HTML]
</p>

<p class="algo">
`storage@m
取得子~手続きは
⇒
~RET 此れに`関連な設定群~obj$の `StorageManager$I ~obj
◎
The storage getter steps are to return this’s relevant settings object’s StorageManager object.
</p>

<pre class="idl">
[`SecureContext$,
 `Exposed$=(Window,Worker)]
interface `StorageManager@I {
  Promise&lt;boolean&gt; `persisted$m();
  [`Exposed$=Window] Promise&lt;boolean&gt; `persist$m();

  Promise&lt;`StorageEstimate$I&gt; `estimate$m();
};

dictionary `StorageEstimate@I {
  unsigned long long `usage@m;
  unsigned long long `quota@m;
};
</pre>

<div class="algo">
<p>
`persisted()@m
~method~手続きは：
◎
The persisted() method steps are:
</p>
<ol>
	<li>
%~promise ~LET 新たな~promise
◎
Let promise be a new promise.
</li>
	<li>
%棚 ~LET `局所~storage棚を得する$( 此れに`関連な設定群~obj$ )
◎
Let shelf be the result of running obtain a local storage shelf with this’s relevant settings object.
</li>
	<li>
~IF［
%棚 ~EQ `失敗^i
］
⇒
`TypeError$E で %~promise を却下する
◎
If shelf is failure, then reject promise with a TypeError.
</li>
	<li>
<p>
~ELSE
⇒
次の手続きを`並列的$に走らす：
◎
Otherwise, run these steps in parallel:
</p>
		<ol>
			<li>
<p>
%持続ed ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%棚 の`~bucket~map$[ `default^l ] の`~mode$ ~EQ `persistent^l
◎
Let persisted be true if shelf’s bucket map["default"]'s mode is "persistent"; otherwise false.
</p>

<p class="note">注記：
内部~errorが生じたときは ~F になる。
◎
It will be false when there’s an internal error.
</p>
			</li>
			<li>
次を走らす`~taskを~queueする$
⇒
%持続ed で %~promise を解決する
◎
Queue a task to resolve promise with persisted.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`persist()@m
~method~手続きは：
◎
The persist() method steps are:
</p>
<ol>
	<li>
%~promise ~LET 新たな~promise
◎
Let promise be a new promise.
</li>
	<li>
%棚 ~LET `局所~storage棚を得する$( 此れに`関連な設定群~obj$ )
◎
Let shelf be the result of running obtain a local storage shelf with this’s relevant settings object.
</li>
	<li>
~IF［
%棚 ~EQ `失敗^i
］
⇒
`TypeError$E で %~promise を却下する
◎
If shelf is failure, then reject promise with a TypeError.
</li>
	<li>
<p>
~ELSE
⇒
次の手続きを`並列的$に走らす：
◎
Otherwise, run these steps in parallel:
</p>
		<ol>
			<li>
<p>
%許可 ~LET `persistent-storage$l を`利用する許可を要請-$した結果
◎
Let permission be the result of requesting permission to use "persistent-storage".
</p>

<p class="note">注記：
~UAには、同じ`生成元$に対し，同時期に利用者にこの問いに重ねて回答させないことが奨励される。
この【許可を要請する】~algoは、そのような局面を取扱うためのものではない。
◎
User agents are encouraged to not let the user answer this question twice for the same origin around the same time and this algorithm is not equipped to handle such a scenario.
</p>
			</li>
			<li>
%~bucket ~LET %棚 の`~bucket~map$[ `default^l ]
◎
Let bucket be shelf’s bucket map["default"].
</li>
			<li>
<p>
%持続ed ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%~bucket の`~mode$ ~EQ `persistent^l
］
◎
Let persisted be true if bucket’s mode is "persistent"; otherwise false.
</p>

<p class="note">注記：
内部~errorが生じたときは ~F になる。
◎
It will be false when there’s an internal error.
</p>
			</li>
			<li>
<p>
~IF［
%持続ed ~EQ ~F
］~AND［
%許可 ~EQ `granted$l
］：
◎
If persisted is false and permission is "granted", then:
</p>
				<ol>
					<li>
%~bucket の`~mode$ ~SET `persistent^l
◎
Set bucket’s mode to "persistent".
</li>
					<li>
~IF［
内部~errorは生じていない
］
⇒
%持続ed ~SET ~T
◎
If there was no internal error, then set persisted to true.
</li>
				</ol>
			</li>
			<li>
次を走らす`~taskを~queueする$
⇒
%持続ed で %~promise を解決する
◎
Queue a task to resolve promise with persisted.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`estimate()@m
~method~手続きは：
◎
The estimate() method steps are:
</p>
<ol>
	<li>
%~promise ~LET 新たな~promise
◎
Let promise be a new promise.
</li>
	<li>
%棚 ~LET `局所~storage棚を得する$( 此れに`関連な設定群~obj$ )
◎
Let shelf be the result of running obtain a local storage shelf with this’s relevant settings object.
</li>
	<li>
~IF［
%棚 ~EQ `失敗^i
］
⇒
`TypeError$E で %~promise を却下する
◎
If shelf is failure, then reject promise with a TypeError.
</li>
	<li>
<p>
~ELSE
⇒
次の手続きを`並列的$に走らす：
◎
Otherwise, run these steps in parallel:
</p>

		<ol>
			<li>
%使用量 ~LET %棚 の`~storage使用量$
◎
Let usage be storage usage for shelf.
</li>
			<li>
%~quota ~LET %棚 の`~storage~quota$
◎
Let quota be storage quota for shelf.
</li>
			<li>
%辞書 ~LET 次のようにされた新たな `StorageEstimate$I 辞書
⇒＃
`usage$m ~member ~SET %使用量,
`quota$m ~member ~SET %~quota
◎
Let dictionary be a new StorageEstimate dictionary whose usage member is usage and quota member is quota.
</li>
			<li>
<p>
~IF［［
%使用量, %~quota を得する間に何らかの内部~errorが生じた
］
⇒
次を走らす`~taskを~queueする$
⇒
`TypeError$E で %~promise を却下する
◎
If there was an internal error while obtaining usage and quota, then queue a task to reject promise with a TypeError.
</p>

<p class="note">注記：
内部~errorは極めて稀と想定されており，何らかの類の低levelな［
~platform／~hardware
］における瑕疵を指示する。
しかしながら，~webにおける［
実装／~platform
］の多様さの尺度からは、生じるものとみなす必要がある。
◎
Internal errors are supposed to be extremely rare and indicate some kind of low-level platform or hardware fault. However, at the scale of the web with the diversity of implementation and platforms, the unexpected does occur.
</p>
			</li>
			<li>
~ELSE
⇒
次を走らす`~taskを~queueする$
⇒
%辞書 で %~promise を解決する
◎
Otherwise, queue a task to resolve promise with dictionary.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

	</section>
</main></div>

	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
次の方々からの貢献に感謝する：
</p>

<div lang="en-x-a0">

<p>
With that, many thanks to
Adrian Bateman,
Aislinn Grigas,
Alex Russell,
Ali Alabbas,
Andrew Sutherland,
Ben Kelly,
Ben Turner,
Dale Harvey,
David Grogan,
Domenic Denicola,
fantasai,
Jake Archibald,
Jeffrey Yasskin,
Jinho Bang,
Jonas Sicking,
Joshua Bell,
Kenji Baheux,
Kinuko Yasuda,
Luke Wagner,
Michael Nordman,
Mounir Lamouri,
Shachar Zohar,
<span lang="zh">黃強</span> (Shawn Huang),
<span lang="zh">簡冠庭</span> (Timothy Guan-tin Chien), and
Victor Costan
for being awesome!
</p>

<p>This standard is written by <a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a> (<a href="https://www.mozilla.org/">Mozilla</a>, <a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).</p>

<p>Copyright © 2020 WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.</p>

</div>

	</section>
