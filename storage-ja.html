<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Storage （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
x-label {
	position: absolute;
	display: inline-block;
	min-width: 10rem;
	line-height: 1.2rem;
	text-align: center;
	white-space:nowrap;
	z-index: 1;
	background: transparent;
}

x-label > x-box {
	position: absolute;
	display: block;
	z-index: -1;
	top: -1.5rem;
	bottom: -1.5rem;
	left: -0.3rem;
	right: -0.3rem;
	border: solid thin var(--N-color);
	background: var(--bg-color-1);
}
</style>
<style>
@namespace svg url(http://www.w3.org/2000/svg);
#_model-diagram-graph svg|path {
	fill: none;
	stroke: var(--dim-color);
}
</style>


<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		generate: expand
	};
	Util.switchWordsInit(source_data);
}


function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}


let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2023-02-20
trans_update:2023-01-17
source_checked:200515
spec_status:LS
original_url:https://storage.spec.whatwg.org/
	abbr_url:STORAGE
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:storage
copyright:,whatwg
trans_1st_pub:2017-02-15


●●class_map
E:error
h:header

●●tag_map
I:code
m:code
E:code
c:code
h:code
i:i

●●original_id_map
	buckets:boxes

●●mdn_urls
navigatorstorage:API/NavigatorStorage
dictdef-storageestimate:API/StorageEstimate
storagemanager:API/StorageManager

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject
SecureContext:~WEBIDLjs#SecureContext

boolean:~WEBIDL#idl-boolean
unsigned long long:~WEBIDL#idl-unsigned-long-long
Promise:~WEBIDL#idl-promise

I.Navigator:~WAPI#navigator
I.NavigatorStorage:#navigatorstorage
I.StorageEstimate:#dictdef-storageestimate
I.StorageManager:#storagemanager
I.WorkerNavigator:~WORKERS#workernavigator

E.TypeError:~WEBIDL#exceptiondef-typeerror

m.estimate:#dom-storagemanager-estimate
m.persist:#dom-storagemanager-persist
m.persisted:#dom-storagemanager-persisted
m.quota:#dom-storageestimate-quota
m.storage:#dom-navigatorstorage-storage
m.usage:#dom-storageestimate-usage

l.granted:~PERMISSIONS#dom-permissionstate-granted
	l.persistent-storage:

	●用語
~storage~quota:#storage-quota
~storage使用量:#storage-usage

~session~storage:#session-storage
局所~storage:#local-storage

~storage端点:#storage-endpoint
登録-済み~storage端点~群:#registered-storage-endpoints
~storage種別:#storage-type
~storage識別子:#storage-identifier
sE.種別~群:#storage-endpoint-types
sE.識別子:#storage-endpoint-identifier
sE.~quota:#storage-endpoint-quota

~storage~key:#storage-key
stK.生成元:#storage-key-origin
~storage~keyを得する:#obtain-a-storage-key
非~storage目的~用に~storage~keyを得する:#obtain-a-storage-key-for-non-storage-purposes
同等な~storage~key:#storage-key-equal

~storage倉:#storage-shed
~UA~storage倉:#user-agent-storage-shed
~session~storage倉:#traversable-navigable-storage-shed

~storage棚:#storage-shelf
~bucket~map:#bucket-map

~storage~bucket:#storage-bucket
~session~storage~bucket:#session-storage-bucket
局所~storage~bucket:#bucket
~mode:#bucket-mode
瓶~map:#bottle-map

~storage瓶:#storage-bottle
sB.~map:#storage-bottle-map
sB.~quota:#storage-bottle-quota

~storage~proxy~map:#storage-proxy-map
裏ng~map:#storage-proxy-map-backing-map
~proxy~map参照~集合:#storage-bottle-proxy-map-reference-set
辿可能~session~storage倉を旧来~cloneする:#legacy-clone-a-traversable-storage-shed
~storage棚を作成する:#create-a-storage-shelf
局所~storage棚を得する:#obtain-a-local-storage-shelf
~storage棚を得する:#obtain-a-storage-shelf
~storage~bucketを作成する:#create-a-storage-bucket
~session~storage瓶~mapを得する:#obtain-a-session-storage-bottle-map
~storage瓶~mapを得する:#obtain-a-storage-bottle-map
局所~storage瓶~mapを得する:#obtain-a-local-storage-bottle-map

~storage~task~source:#task-source
~storage~taskを~queueする:#queue-a-storage-task

	§ 許可:#persistence

	●用語（外部
~UA:~INFRA#user-agent
実装定義:~INFRA#implementation-defined

文字列:~INFRA#string
~ASCII文字列:~INFRA#ascii-string

~tuple:~INFRA#tuple

~map:~INFRA#ordered-map
集合:~INFRA#ordered-set
map.~key:~INFRA#map-key
map.値:~INFRA#map-value
	~map内に存在する:~INFRA#map-exists
map.~cloneする:~INFRA#map-clone
map.空:~INFRA#map-is-empty
map.除去する:~INFRA#map-remove
set.付加する:~INFRA#set-append

新たな~promise:~WEBIDLjs#a-new-promise
~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve

並列的:~HTMLINFRA#in-parallel

~agent:~TC39#sec-agents
~agent~cluster:~TC39#sec-agent-clusters

url.生成元:~URL1#concept-url-origin

不透明な生成元:~ORIGIN#concept-origin-opaque
生成元:~ORIGIN#concept-origin
同一-生成元:~ORIGIN#same-origin

結付けられた文書:~WINDOW#concept-document-window

辿可能な~navigable:~HTMLds#traversable-navigable
~node~navigable:~HTMLds#node-navigable
nav.辿可能な~navigable:~HTMLds#nav-traversable

~task:~WAPI#concept-task
~task~source:~WAPI#task-source
大域~taskを~queueする:~WAPI#queue-a-global-task
環境:~WAPI#environment
現在の設定群~obj:~WAPI#current-settings-object
環境~設定群~obj:~WAPI#environment-settings-object
enV.生成元:~WAPI#concept-settings-object-origin
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.大域~obj:~WAPI#concept-settings-object-global
関連な設定群~obj:~WAPI#relevant-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
大域~obj:~WAPI#global-object

許可~revocation~algo:~PERMISSIONS#dfn-permission-revocation-algorithm
許可~状態:~PERMISSIONS#dfn-permission-state
強力な特能:~PERMISSIONS#dfn-powerful-feature
利用する許可を要請-:~PERMISSIONS#dfn-request-permission-to-use
現在の許可~状態を取得する:~PERMISSIONS#dfn-getting-the-current-permission-state

	https://privacycg.github.io/storage-access/
	https://privacycg.github.io/storage-partitioning/
	https://github.com/whatwg/html/issues/
	https://github.com/whatwg/storage/issues/

_acks1:#_acks1
_ipr1:#_ipr1

●●words_table1

●●words_table

	●storage
Storage:
端点:endpoint::~::エンドポイント
倉:shed::~::シェッド
棚:shelf::~::シェルフ
	棚:shelves
bucket::::バケット
	籠:bucket::
瓶:bottle::~::ボトル
裏ng:backing::裏

~backing:
quota::::クォータ
空き:space::~
使用量:usage::~
区分-:segment:~
	仕切り法:partitioning

持続性:persistence::~
持続的:persistent::~
持続-:persist::~
見積もり:estimate::~
量:amount:~
	byte数:amount of bytes
重複集約:deduplication:重複の集約
圧縮:compression:~
喪失-:lost:~
	get lost
使果たす:run outする:使い果たす
頻度:frequency:~
bookmark::::ブックマーク
近過去度:recency:~
住まう:liveする:~
縛られ:boundされ:~
上限:limit:~

	●保安／環境
TLS:
offline::::オフライン
password::::パスワード
username::::ユーザ名
証明書:certificate:~
認証:authentication:~
露呈-:reveal:露わに
成分組:tuple::~
復活-:revive:~
復活:revival:~
閉じら:closeさ:~
開き:openし:~
	開き直す:reopen
	し続ける:continued

	●仕様
統括-:consolidate:~
不便さ:inconvenience:~
	不便さ:inconveniencing
保守的:conservative:~
問い:question:~
回答:answer:~
成長-:grow:~
末端利用者:end user:~:::エンドユーザ
介入-:intervene:~
同意:consent:~
低level:low-level:低 level::低レベル
瑕疵:fault:~
想定-:suppose:~
尺度:scale:~
多様さ:diversity:~
介在:involvement:~
見越され:anticipateされ:~
支援:assistance:~
申請-:file:~
情勢:lay of the land:~
理想的:ideal:~
拡げら:expandさ:~
欠如:lack:~
優先度:priority:~
	優先度に基づく:prioritizing
指図-:instruct:~

	関わる:concerns
	極めて:extremely
	稀:rare
	生じるものとみなす必要がある:the unexpected does occur.
	何年かにわたり:Over the years
	に利する:on behalf of
	特にparticularly
	もたらす:bring
	享受:enjoy
	いきなり:unannounced
	もう少し込み入った:slightly more involved
	ためのもの:equip
	既定のものになる:defaulted
	はっきりしなくなる:obscure
	ある程度の余裕:some wiggle room
	とされた:marked
	駆使:use
	書ける:can be written
	~~策定者:you
	概ね:roughly
	適する:suit
	見込みが高い:likely
	今後:going forward
	担う:take
	形作られた:carved out
	-:in turn
	-:lastly
	伝え:inform
	勝る:outweigh
	なるべく抑える:least
	必要とされよう:necessarily
	特に:most notably
	直接間接を問わず:directly or indirectly
	至らせ:lead
	留意しておく:be mindful

	●未分類
mebibyte::::メビバイト
kibibyte::::キビバイト
agent:
revocation::取り消し
自動生成-:autogenerate:~
chunk::::チャンク
地理所在:geolocation:~
作成時の:creation::~

	time
	%設定群~obj:settingsObject
	%新たな棚:newShelf
	総計:total
	総:total
	総〜数:total amount of
	同時に:simultaneous
	同時期:around the same time
	少なく:less than
	ある:left
	からなる:consists of
	より大きい:larger
	例外を投出-:throw
	追跡し続ける:keep-track
	%~proxy~map:proxyMap
	同等:equal
	%持続されるか:persisted
	%大域~obj:global

	●指示語
	1 個の:one
	何らかの:of some kind
	何種類かの:various kinds of
	まるごと:in its entirety
	ほとんどは:mostly
	重ねて:twice
	およその:rough
	何:how much
	何らかの類の:some kind of
	半-:semi-
	〜側:-side
	初回:first time
	場所:place

●●ref_normative

[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[PERMISSIONS]
    Marcos Caceres; Mike Taylor. ＜Permissions＞. URL: https://w3c.github.io/permissions/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●
ref_informative


●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.whatwg.org/">WHATWG</a>
による
<a href="~SPEC_URL">Storage Standard</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/storage">GitHub whatwg/storage</a> (<a href="https://github.com/whatwg/storage/issues/new">new issue</a>, <a href="https://github.com/whatwg/storage/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	https://github.com/whatwg/storage/commits
	<a href="https://storage.spec.whatwg.org/commit-snapshots/5835e143d58bb62b60712080b4df1d8ad717ff68/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/storagestandard">@storagestandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/storage">web-platform-tests storage/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/storage">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>

<body>

<template id="_persisted_parts">

<x-diagram
	aria-describedby="_dgm-model-diagram"
	style="height:46.5rem;"
>
<svg
	id="_model-diagram-graph"
	xmlns="http://www.w3.org/2000/svg"
	viewBox="0 0 434 815"
	height="100%"
>
<defs>
	<marker id="b" markerHeight="18" markerWidth="18" orient="auto" refX="0" refY="9">
<path d="M9 0v18m6-18v18"/>
	</marker>
	<marker id="a" markerHeight="18" markerWidth="18" orient="auto" refX="18" refY="9">
<path d="M3 0v18M9 0v18"/>
	</marker>
	<marker id="d" markerHeight="36" markerWidth="45" orient="auto" refX="27" refY="18">
<path d="M3 9v18m6-9q18-18 36 0-18 18-36 0"/>
	</marker>
	<marker id="c" markerHeight="36" markerWidth="57" orient="auto" refX="39" refY="18">
<circle cx="9" cy="18" r="6" fill="#fff" stroke="var(--dim-color)"/>
<path d="M21 18q18-18 36 0-18 18-36 0"/>
	</marker>
</defs>
	<g>
<path marker-end="url(#a)" marker-start="url(#b)" d="M73.762 95v8.333c0 8.334 0 25 11.765 41.667s35.296 33.333 47.061 41.667L144.353 195"/>
<path marker-end="url(#a)" marker-start="url(#b)" d="M320.832 95v8.333c0 8.334 0 25-11.765 41.667s-35.296 33.333-47.061 41.667L250.24 195"/>
<path marker-end="url(#c)" marker-start="url(#b)" d="M197.297 270v100"/>
<path marker-end="url(#a)" marker-start="url(#b)" d="M197.297 445v100"/>
<path marker-end="url(#d)" marker-start="url(#b)" d="M197.297 620v100"/>
	</g>
</svg>
</x-diagram>

</template>

<header>

<a href="https://whatwg.org/"><img style="float: right;" alt="WHATWG" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPHBhdGggZD0iTTAsMHYxMDBoOTB2LTEwMHoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0wLDBMMjAsMEwyMCwzMEw4MCwzMEw4MCwwTDkwLDBMMTAwLDEwTDEwMCwxMDBMOTAsMTAwTDkwLDQ1TDEwLDQ1TDEwLDkwTDkwLDkwTDkwLDEwMEwwLDEwMFogTTU3LjUsMi41IGgxNSB2MjUgaC0xNXoiIGZpbGw9IiMzYzc5MGEiLz4KPC9zdmc+Cg==" height="100"></a>

	<hgroup>
<h1>Storage</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
~Storage標準は、持続的な~storageと~quota見積もり用の~API, および
~platform~storage~architectureを定義する。
◎
The Storage Standard defines an API for persistent storage and quota estimates, as well as the platform storage architecture.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~webは、何年かにわたり~storage用に利用できる様々な~APIを成長させてきた
— 例えば
IndexedDB, `localStorage^c, `showNotification()^c
。
~Storage標準は、次を定義することにより，これらの~APIを統括する：
◎
Over the years the web has grown various APIs that can be used for storage, e.g., IndexedDB, localStorage, and showNotification(). The Storage Standard consolidates these APIs by defining:
</p>

<ul>
	<li>
これらの~APIが~dataを格納するための~primitiveとなる，~bucket。
◎
A bucket, the primitive these APIs store their data in
</li>
	<li>
その~bucketを持続的にする仕方。
◎
A way of making that bucket persistent
</li>
	<li>
与えられた`生成元$に対する使用量と~quota見積もりを取得する仕方。
◎
A way of getting usage and quota estimates for an origin
</li>
</ul>

<p>
伝統的に，これらの~APIにより格納された~dataは、機器~上の~storage空間を利用者が使果たすに伴い，利用者が介入できることなく喪失されていた。
が、持続的な~bucketは，利用者の同意なくしては~clearできない。
したがってこれは、利用者が~webに~nativeな~platformで享受した~dataの保証をもたらす。
◎
Traditionally, as the user runs out of storage space on their device, the data stored with these APIs gets lost without the user being able to intervene. However, persistent buckets cannot be cleared without consent by the user. This thus brings data guarantees users have enjoyed on native platforms to the web.
</p>

<div class="example">
<p>
~storageを持続的にする単純な仕方は、
`persist()$m ~methodを呼出すことである。
それは同時に，末端利用者に許可を要請して、是認されたなら，~storageを持続的になるよう変更する：
◎
A simple way to make storage persistent is through invoking the persist() method. It simultaneously requests the end user for permission and changes the storage to be persistent once granted:
</p>

<pre class="lang-js">
navigator.storage.persist().then(%persisted =&gt; {
  if (%persisted) {
    /* … */
  }
});
</pre>

<p>
~UAにより駆動される~dialogを末端利用者に いきなり示さないような，
もう少し込み入った~codeも書ける：
◎
To not show user-agent-driven dialogs to the end user unannounced slightly more involved code can be written:
</p>

<pre class="lang-js">
Promise.all([
  navigator.storage.persisted(),
  navigator.permissions.query({name: "persistent-storage"})
]).then(([%persisted, %permission]) =&gt; {
  if (!%persisted &amp;&amp; %permission.state == "granted") {
    navigator.storage.persist().then( /* … */ )
  } else if (!%persisted &amp;&amp; %permission.state == "prompt") {
    showPersistentStorageExplanation()
  }
});
</pre>

<p>
`estimate()$m ~methodを利用すれば，~appが格納する内容に十分な空きがあるかどうかも決定できる：
◎
The estimate() method can be used to determine whether there is enough space left to store content for an application:
</p>

<pre class="lang-js">
function retrieveNextChunk(%nextChunkInfo) {
  return navigator.storage.estimate().then(%info =&gt; {
    if (%info.quota - %info.usage &gt; %nextChunkInfo.size) {
      return fetch(%nextChunkInfo.url);
    } else {【！"insufficient space to store next chunk"】
      throw new Error("次の~chunkを格納するための空きが足りません")
    }
  }).then( /* … */ );
}
</pre>

</div>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
この仕様は、  Infra 標準 `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様は、次に挙げる各種~標準による各種用語を利用する
⇒＃
`HTML$r
`WEBIDL$r
`PERMISSIONS$r
◎
This specification uses terminology from the HTML, IDL, and Permissions Standards. [HTML] [WEBIDL] [PERMISSIONS]
</p>

	</section>
	<section id="infrastructure">
<h2 title="Lay of the land">3. 情勢</h2>

<p>
`~UA$は、次に挙げるような何種類かの半-持続的な状態を備える：
◎
A user agent has various kinds of semi-persistent state:
</p>

<dl>
	<dt>資格証~storage</dt>
	<dd>
~HTML~formを通して提出された~usernameや~passwordなど，末端利用者の資格証からなる。
◎
End-user credentials, such as username and passwords submitted through HTML forms
</dd>
	<dt>許可~storage</dt>
	<dd>
地理所在など，様々な特能に対する許可からなる。
◎
Permissions for various features, such as geolocation
</dd>

	<dt>~network~storage</dt>
	<dd>
次に挙げるもの, 等々からなる
⇒＃
~HTTP~cache,
~cookie,
認証~entry,
~TLS~client証明書
◎
HTTP cache, cookies, authentication entries, TLS client certificates
</dd>

	<dt id="site-storage">~storage</dt>
	<dd>
次に挙げるもの, 等々からなる
⇒＃
Indexed DB,
Cache API,
~sw登録,
`localStorage^m,
`sessionStorage^m,
~app~cache,
通知
◎
Indexed DB, Cache API, service worker registrations, localStorage, sessionStorage, application caches, notifications, etc.
</dd>
</dl>

<p>
この標準が首に関わるのは、~storageである。
◎
This standard primarily concerns itself with storage.
</p>

	</section>
	<section id="model">
<h2 title="Model">4. ~model</h2>

<p>
［
局所／~session
］~storage~APIを定義している標準は、`~storage端点$を定義して，それを
— この標準を変更することを通して —
`登録-済み~storage端点~群$に登録することになる。
当の標準は、［
`局所~storage瓶~mapを得する$／
`~session~storage瓶~mapを得する$
］いずれかの~algoを呼出してそれを与えることになる：
◎
Standards defining local or session storage APIs will define a storage endpoint and register it by changing this standard. They will invoke either the obtain a local storage bottle map or the obtain a session storage bottle map algorithm, which will give them:
</p>
<ul>
	<li>
結果における `失敗^i は、次のいずれかを意味する
⇒＃
当の~APIは、例外を投出する必要があるかもしれない／
当の`環境~設定群~obj$用に可用な~storageは無いことを指示する
◎
Failure, which might mean the API has to throw or otherwise indicate there is no storage available for that environment settings object.
</li>
	<li>
`~storage~proxy~map$は、当の~APIに適する方式で~dataを格納するために利用でき，`~map$と相似的に演算する。
［
当の~APIと他の~APIからの~data／
各`~storage~key$／
各`~storage種別$
］どうしを隔離する~careは、この標準が担う。
◎
A storage proxy map that operates analogously to a map, which can be used to store data in a manner that suits the API. This standard takes care of isolating that data from other APIs, storage keys, and storage types.
</li>
</ul>

<p class="note">注記：
そのような~API用の標準を定義している~~策定者は、この標準に対し課題を申請して，支援と考査を受けることを考慮すること。
◎
If you are defining a standard for such an API, consider filing an issue against this standard for assistance and review.
</p>

<figure>
	<div style="position:relative;left:1.2rem;top:-2.4rem;" role="img">
<x-label style="left:-2rem;top:5rem;">`~UA$<x-box></x-box></x-label>
<x-label style="left:-2rem;top:10rem;">保持する（局所的）</x-label>
<x-label style="left:12rem;top:5rem;">`辿可能な~navigable$<x-box></x-box></x-label>
<x-label style="left:12rem;top:10rem;">保持する（~session）</x-label>
<x-label style="left:5rem;top:15rem;">`~storage倉$<x-box></x-box></x-label>
<x-label style="left:5rem;top:20rem;">各`~storage~key$に対し</x-label>
<x-label style="left:5rem;top:25rem;">`~storage棚$<x-box></x-box></x-label>
<x-label style="left:5rem;top:30rem;">保持する（既定では 1 個）</x-label>
<x-label style="left:5rem;top:35rem;">`~storage~bucket$<x-box></x-box></x-label>
<x-label style="left:5rem;top:40rem;">各`~storage端点$に対し</x-label>
<x-label style="left:5rem;top:45rem;">`~storage瓶$<x-box></x-box></x-label>

<!--
User agent: holds (local)
Traversable navigable: holds (session)
Storage shed: for each storage key
Storage shelf: holds (default)
Storage bucket: for each storage endpoint
Storage bottle
-->
	</div>
<p class="alt" hidden id="_dgm-model-diagram">
~storage~modelの図式
（次の段落にて述べられる）。
◎
Storage model diagram (described in the next paragraph).
</p>
</figure>

<p>
この~dataを隔離するため、この標準は，次を定義する：
◎
To isolate this data this standard defines＼
</p>

<ul>
	<li>
`~storage倉$は、`~storage~key$により各`~storage棚$を区分する。
◎
a storage shed which segments storage shelves by a storage key.＼
</li>
	<li>
`~storage棚$は、1 個の`~storage~bucket$からなる
— が，将来には、各種~storage施策~用に，複数個の`~storage~bucket$からなることも許容することになる見込みが高い。
◎
A storage shelf in turn consists of a storage bucket and will likely consist of multiple storage buckets in the future to allow for different storage policies.＼
</li>
	<li>
`~storage~bucket$は、
0 個以上の
— 各`~storage端点$ごとに 1 個ある —
`~storage瓶$からなる。
◎
And lastly, a storage bucket consists of storage bottles, one for each storage endpoint.
</li>
</ul>

		<section id="storage-endpoints">
<h3 title="Storage endpoints">4.1. ~storage端点</h3>

<p>
`~storage端点@
（ `storage endpoint^en ）は、その~storageに必要なものを追跡し続けるために，この標準が定義する基盤
— 特に，`~storage瓶$ —
を利用する［
`局所~storage$／`~session~storage$
］~APIである。
◎
A storage endpoint is a local or session storage API that uses the infrastructure defined by this standard, most notably storage bottles, to keep track of its storage needs.
</p>

<p>
各`~storage端点$は、次に挙げるものを有する：
</p>
<ul>
	<li>
`識別子@sE
— ある`~storage識別子$
◎
A storage endpoint has an identifier, which is a storage identifier.
</li>
	<li>
`種別~群@sE
— いくつかの`~storage種別$からなる`集合$
◎
A storage endpoint also has types, which is a set of storage types.
</li>
	<li>
`~quota@sE
— ~NULL または［
この`~storage端点$に対応する各`~storage瓶$
］用に推奨される`~quota$sBを（~byte数で）表現する数。
◎
A storage endpoint also has a quota, which is null or a number representing a recommended quota (in bytes) for each storage bottle corresponding to this storage endpoint.
</li>
</ul>

<p>
`~storage識別子@
（ `storage identifier^en ）は、`~ASCII文字列$である。
◎
A storage identifier is an ASCII string.
</p>

<p>
`~storage種別@
（ `storage type^en ）は、［
`local^l ／ `session^l 
］である。
◎
A storage type is "local" or "session".
</p>

<hr>

<p>
`登録-済み~storage端点~群@
（ `egistered storage endpoints^en ）は、次の表tにより定義される，`~storage端点$からなる`集合$である：
◎
The registered storage endpoints are a set of storage endpoints defined by the following table:
</p>

<div style="overflow:auto;"><table><thead>
<tr><th>
`識別子$sE
<th>
`種別~群$sE
<th>
`~quota$sE
<tbody>

<tr><td>`caches^l
<td>« `local^l »
<td>~NULL

<tr><td>`indexedDB^l
<td>« `local^l »
<td>~NULL

<tr><td>`localStorage^l
<td>« `local^l »
<td>5 ~mebibyte†

<tr><td>`serviceWorkerRegistrations^l
<td>« `local^l »
<td>~NULL

<tr><td>`sessionStorage^l
<td>« `session^l »
<td>5 ~mebibyte†
</table>

<p>†
1 ~mebibyte ~EQ 2 の 20 乗~byte （ ~EQ ~kibibyte の 2 乗）
</p>

◎
Identifier｜Type｜Quota
"caches"｜« "local" »｜null
"indexedDB"｜« "local" »｜null
"localStorage"｜« "local" »｜5 × 220 (i.e., 5 mebibytes)
"serviceWorkerRegistrations"｜« "local" »｜null
"sessionStorage"｜« "session" »｜5 × 220 (i.e., 5 mebibytes) 
</div>

<p class="note">注記：
各 標準は，すでに言及したように、これらの`~storage識別子$を利用して［
`局所~storage瓶~mapを得する$／
`~session~storage瓶~mapを得する$
］ことができる。
一部の~APIは、今後，どちらの`~storage種別$にも適用-可能になるものと見越されている。
◎
As mentioned, standards can use these storage identifiers with obtain a local storage bottle map and obtain a session storage bottle map. It is anticipated that some APIs will be applicable to both storage types going forward.
</p>

		</section>
		<section id="storage-keys">
<h3 title="Storage keys">4.2. ~storage~key</h3>

<p>
`~storage~key@
（ `storage key^en ）は、
次に挙げるものからなる`~tuple$である：
◎
A storage key is a tuple consisting of＼
</p>
<ul>
	<li>
`生成元@stK
— `生成元$ `HTML$r
◎
an origin (an origin). [HTML]
</li>
</ul>

<p class="XXX">
これは変更されるものと予期される
— <a href="https://privacycg.github.io/storage-partitioning/">~client側~storageの仕切り法</a>
を見よ。
◎
This is expected to change; see Client-Side Storage Partitioning.
</p>

<div class="algo">
<p>
`~storage~keyを得する@
ときは、所与の
( `環境$ %環境 )
に対し，次の手続きを走らす：
◎
To obtain a storage key, given an environment environment, run these steps:
</p>
<ol>
	<li>
%~key ~LET `非~storage目的~用に~storage~keyを得する$( %環境 )
◎
Let key be the result of running obtain a storage key for non-storage purposes with environment.
</li>
	<li>
~IF［
%~key の`生成元$stKは`不透明な生成元$である
］
⇒
~RET `失敗^i
◎
If key’s origin is an opaque origin, then return failure.
</li>
	<li>
~IF［
利用者は、~storageを不能化した
］
⇒
~RET `失敗^i
◎
If the user has disabled storage, then return failure.
</li>
	<li>
~RET %~key
◎
Return key.
</li>
</ol>
</div>

<div class="algo">
<p>
`非~storage目的~用に~storage~keyを得する@
ときは、所与の
( `環境$ %環境 )
に対し，次の手続きを走らす：
◎
To obtain a storage key for non-storage purposes, given an environment environment, run these steps:
</p>
<ol>
	<li>
%生成元 ~LET %環境 に応じて
⇒＃
`環境~設定群~obj$であるならば %環境 の`生成元$enV／
~ELSE_ %環境 の`作成時の~URL$enVの`生成元$url
◎
Let origin be environment’s origin if environment is an environment settings object; otherwise environment’s creation URL’s origin.
</li>
	<li>
~RET `~tuple$ ( %生成元 )
◎
Return a tuple consisting of origin.
</li>
</ol>
</div>

<div class="algo">
<p>
2 つの`~storage~key$
( %A, %B )
が`同等な~storage~key@
であるとは、
次を満たすことをいう
⇒
( %A の`生成元$stK, %B の`生成元$stK )
は`同一-生成元$である
◎
To determine whether a storage key A equals storage key B, run these steps:
• If A’s origin is not same origin with B’s origin, then return false.
• Return true.
</p>
</div>

		</section>
		<section id="storage-sheds">
<h3 title="Storage sheds">4.3. ~storage倉</h3>

<p>
`~storage倉@
（ `storage shed^en ）は、
`~storage~key$から`~storage棚$への`~map$であり，初期~時には空とする。
【~keyの比較は、`同等な~storage~key$に基づくと思われる。】
◎
A storage shed is a map of storage keys to storage shelves. It is initially empty.
</p>

<hr>

<p>
各`~UA$は、
`~UA~storage倉@
を保持する。
それは、`~storage倉$であり，すべての
`局所~storage@
（ `local storage^en ）~dataを保持する。
◎
A user agent holds a storage shed, which is a storage shed. A user agent’s storage shed holds all local storage data.
</p>

<p>
各 `辿可能な~navigable$は、
`~session~storage倉@
を保持する。
それは、`~storage倉$であり，すべての
`~session~storage@
（ `session storage^en ）~dataを保持する。
◎
A traversable navigable holds a storage shed, which is a storage shed. A traversable navigable’s storage shed holds all session storage data.
</p>

<div class="algo">
<p>
`辿可能~session~storage倉を旧来~cloneする@
するときは、所与の
( `辿可能な~navigable$ %A, `辿可能な~navigable$ %B )
に対し，次の手続きを走らす：
◎
To legacy-clone a traversable storage shed, given a traversable navigable A and a traversable navigable B, run these steps:
</p>
<ol>
	<li>
<p>
%A の`~session~storage倉$を成す
~EACH( %~key → %棚 )
に対し：
◎
For each key → shelf of A’s storage shed:
</p>
		<ol>
			<li>
%新たな棚 ~LET `~storage棚を作成する$( `session^l )
◎
Let newShelf be the result of running create a storage shelf with "session".
</li>
			<li>
%新たな棚 の`~bucket~map$[ `default^l ] の`瓶~map$[ `sessionStorage^l ] の`~map$sB ~SET %棚 の`~bucket~map$[ `default^l ] の`瓶~map$[ `sessionStorage^l ] の`~map$sBを`~cloneする$map
◎
Set newShelf’s bucket map["default"]'s bottle map["sessionStorage"]'s map to a clone of shelf’s bucket map["default"]'s bottle map["sessionStorage"]'s map.
</li>
			<li>
%B の`~session~storage倉$[ %~key ] ~SET %新たな棚
◎
Set B’s storage shed[key] to newShelf.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
これは、旧来のものと見なされる
— 便益があるとしても，実装の複階性に勝るものではないので。
したがって、 `HTML$r の外側へ［
拡げられる／利用される
］ことはない。
◎
This is considered legacy as the benefits, if any, do not outweigh the implementation complexity. And therefore it will not be expanded or used outside of HTML. [HTML]
</p>
</div>

		</section>
		<section id="storage-shelves">
<h3 title="Storage shelves">4.4. ~storage棚</h3>

<p>
`~storage棚@
（ `storage shelf^en ）は、`~storage倉$の中の各`~storage~key$に対し存在する。
それは、
`~bucket~map@
— `文字列$から`~storage~bucket$への`~map$ —
を保持する。
◎
A storage shelf exists for each storage key within a storage shed. It holds a bucket map, which is a map of strings to storage buckets.
</p>

<p class="note">注記：
今の所、`~bucket~map$に存在する`~key$mapは `default^l しかない。
<a href="https://github.com/whatwg/storage/issues/2">課題 #2</a>
を見よ。
対応する`値$mapは、初回に<a href="#obtain-a-storage-shelf">~storage棚が得された</a>とき，与えられる。
◎
For now "default" is the only key that exists in a bucket map. See issue #2. It is given a value when a storage shelf is obtained for the first time.
</p>

<div class="algo">
<p>
`~storage棚を得する@
ときは、所与の
( `~storage倉$ %倉, `環境~設定群~obj$ %環境, `~storage種別$ %種別 )
に対し，次の手続きを走らす：
◎
To obtain a storage shelf, given a storage shed shed, an environment settings object environment, and a storage type type, run these steps:
</p>

<ol>
	<li>
%~key ~LET `~storage~keyを得する$( %環境 )
◎
Let key be the result of running obtain a storage key with environment.
</li>
	<li>
~IF［
%~key ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If key is failure, then return failure.
</li>
	<li>
~IF［
%倉[ %~key ] ~EQ ε
］
⇒
%倉[ %~key ] ~SET `~storage棚を作成する$( %種別 )
◎
If shed[key] does not exist, then set shed[key] to the result of running create a storage shelf with type.
</li>
	<li>
~RET %倉[ %~key ]
◎
Return shed[key].
</li>
</ol>
</div>

<div class="algo">
<p>
`局所~storage棚を得する@
ときは、所与の
( `環境~設定群~obj$ %環境 )
に対し，次の結果を返す
⇒
`~storage棚を得する$( `~UA~storage倉$, %環境, `local^l )
◎
To obtain a local storage shelf, given an environment settings object environment, return the result of running obtain a storage shelf with the user agent’s storage shed, environment, and "local".
</p>
</div>

<div class="algo">
<p>
`~storage棚を作成する@
ときは、所与の
( `~storage種別$ %種別 )
に対し，次の手続きを走らす：
◎
To create a storage shelf, given a storage type type, run these steps:
</p>
<ol>
	<li>
%棚 ~LET 新たな`~storage棚$
◎
Let shelf be a new storage shelf.
</li>
	<li>
%棚 の`~bucket~map$[ `default^l ] ~SET `~storage~bucketを作成する$( %種別 )
◎
Set shelf’s bucket map["default"] to the result of running create a storage bucket with type.
</li>
	<li>
~RET %棚
◎
Return shelf.
</li>
</ol>
</div>

		</section>
		<section id="buckets">
<h3 title="Storage buckets">4.5. ~storage~bucket</h3>

<p>
`~storage~bucket@
（ `storage bucket^en ／ “バケツ” ）は、`~storage端点$用の~dataを格納する場所である。
◎
A storage bucket is a place for storage endpoints to store data.
</p>

<p>
各`~storage~bucket$は、`~storage識別子$から`~storage瓶$への
`瓶~map@
（ `bottle map^en ）を有する。
◎
A storage bucket has a bottle map of storage identifiers to storage bottles.
</p>

<hr>

<p>
`局所~storage~bucket@
は、`局所~storage$~API用の`~storage~bucket$である。
◎
A local storage bucket is a storage bucket for local storage APIs.
</p>

<p>
各 `局所~storage~bucket$は
`~mode@
を有する。
それは、［
`best-effort^l, `persistent^l
］のいずれかであり，初期~時には `best-effort^l とする。
◎
A local storage bucket has a mode, which is "best-effort" or "persistent". It is initially "best-effort".
</p>

<hr>

<p>
`~session~storage~bucket@
は、`~session~storage$~API用の`~storage~bucket$である。
◎
A session storage bucket is a storage bucket for session storage APIs.
</p>

<hr>

<div class="algo">
<p>
`~storage~bucketを作成する@
ときは、所与の
( `~storage種別$ %種別 )
に対し，次の手続きを走らす：
◎
To create a storage bucket, given a storage type type, run these steps:
</p>
<ol>
	<li>
%~bucket ~LET %種別 に応じて
⇒＃
`local^l ならば 新たな`局所~storage~bucket$／
`session^l ならば 新たな`~session~storage~bucket$
◎
Let bucket be null.
◎
If type is "local", then set bucket to a new local storage bucket.
◎
Otherwise:
• Assert: type is "session".
• Set bucket to a new session storage bucket.
</li>
	<li>
`登録-済み~storage端点~群$を成す
~EACH( %端点 )
に対し，
⇒
~IF［
%種別 ~IN %端点 の`種別~群$sE
］
⇒
%~bucket の`瓶~map$[ %端点 の`識別子$sE ] ~SET 次のようにされた新たな`~storage瓶$
⇒
`~quota$sB ~SET %端点 の`~quota$sE
◎
For each endpoint of registered storage endpoints whose types contain type, set bucket’s bottle map[endpoint’s identifier] to a new storage bottle whose quota is endpoint’s quota.
</li>
	<li>
~RET %~bucket
◎
Return bucket.
</li>
</ol>
</div>

		</section>
		<section id="storage-bottles">
<h3 title="Storage bottles">4.6. ~storage瓶</h3>

<p>
`~storage瓶@
（ `storage bottle^en ）は、`~storage~bucket$の一部を成すよう，単独の`~storage端点$用に形作られたものである。
◎
A storage bottle is a part of a storage bucket carved out for a single storage endpoint.＼
</p>

<p>
各`~storage瓶$は、次に挙げるものを有する：
◎
↓</p>

<ul>
	<li>
`~map@sB
— 初期~時には空な`~map$とする。
◎
A storage bottle has a map, which is initially an empty map.＼
</li>
	<li>
`~proxy~map参照~集合@
— 初期~時には空な`集合$とする。
◎
A storage bottle also has a proxy map reference set, which is initially an empty set.＼
</li>
	<li>
<p>
`~quota@sB
— ~NULL または［
自身が保持できる総~byte数
］の保守的な見積もりを表現する数。
~NULL は上限の欠如を指示する†。
</p>
<p class="note">†
それでも、包摂している`~storage棚$の`~storage~quota$に縛られる。
</p>
◎
A storage bottle also has a quota, which is null or a number representing a conservative estimate of the total amount of bytes it can hold. Null indicates the lack of a limit. It is still bound by the storage quota of its encompassing storage shelf.
</li>
</ul>

<p>
`~storage瓶$の`~map$sBは、格納するよう意味された実際の~dataが住まう所である。
~UAには
— この標準, この標準を利用している各 標準が当の内容に~accessできるよう —
`実装定義$な方式で［
この~dataを格納して，各`~agent$, さらには`~agent~cluster$の境界にまたがって可用にする
］ことが期待される。
◎
A storage bottle’s map is where the actual data meant to be stored lives. User agents are expected to store this data, and make it available across agent and even agent cluster boundaries, in an implementation-defined manner, so that this standard and standards using this standard can access the contents.
</p>

<hr>

<div class="algo">
<p>
`~storage瓶~mapを得する@
ときは、所与の
( `~storage種別$ %種別, `環境~設定群~obj$ %環境, `~storage識別子$ %識別子 )
に対し，次の手続きを走らす：
◎
To obtain a storage bottle map, given a storage type type, environment settings object environment, and storage identifier identifier, run these steps:
</p>
<ol>
	<li>
%倉 ~LET %種別 に応じて
⇒＃
`local^l ならば `~UA~storage倉$／
`session^l ならば %環境 の`大域~obj$enV【！大域~obj】に`結付けられた文書$の`~node~navigable$の`辿可能な~navigable$navの`~session~storage倉$
◎
Let shed be null.
◎
If type is "local", then set shed to the user agent’s storage shed.
◎
Otherwise:
• Assert: type is "session".
• Set shed to environment’s global object’s associated Document’s node navigable’s traversable navigable’s storage shed.
Set shed to environment’s browsing session’s storage shed.
</li>
	<li>
%棚 ~LET `~storage棚を得する$( %倉, %環境, %種別 )
◎
Let shelf be the result of running obtain a storage shelf, with shed, environment, and type.
</li>
	<li>
~IF［
%棚 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If shelf is failure, then return failure.
</li>
	<li>
%~bucket ~LET %棚 の`~bucket~map$[ `default^l ]
◎
Let bucket be shelf’s bucket map["default"].
</li>
	<li>
%瓶 ~LET %~bucket の`瓶~map$[ %識別子 ]
◎
Let bottle be bucket’s bottle map[identifier].
</li>
	<li>
%~proxy~map ~LET %瓶 の`~map$sBを`裏ng~map$とする，新たな`~storage~proxy~map$
◎
Let proxyMap be a new storage proxy map whose backing map is bottle’s map.
</li>
	<li>
%瓶 の`~proxy~map参照~集合$に %~proxy~map を`付加する$set
◎
Append proxyMap to bottle’s proxy map reference set.
</li>
	<li>
~RET %~proxy~map
◎
Return proxyMap.
</li>
</ol>
</div>

<div class="algo">
<p>
`局所~storage瓶~mapを得する@
ときは、所与の
( `環境~設定群~obj$ %環境, `~storage識別子$ %識別子 )
に対し，次の結果を返す
⇒
`~storage瓶~mapを得する$( `local^l, %環境, %識別子 )
◎
To obtain a local storage bottle map, given an environment settings object environment and storage identifier identifier, return the result of running obtain a storage bottle map with "local", environment, and identifier.
</p>
</div>

<div class="algo">
<p>
`~session~storage瓶~mapを得する@
ときは、所与の
( `環境~設定群~obj$ %環境, `~storage識別子$ %識別子 )
に対し，次の結果を返す
⇒
`~storage瓶~mapを得する$( `session^l, %環境, %識別子 )
◎
To obtain a session storage bottle map, given an environment settings object environment and storage identifier identifier, return the result of running obtain a storage bottle map with "session", environment, and identifier.
</p>
</div>

		</section>
		<section id="storage-proxy-maps">
<h3 title="Storage proxy maps">4.7. ~storage~proxy~map</h3>

<p>
`~storage~proxy~map@
（ `storage proxy map^en ）は、次を除いて，`~map$に等価である
⇒
それに対する演算は、代わりに その
`裏ng~map@
（ `backing map^en ）に対し遂行される
◎
A storage proxy map is equivalent to a map, except that all operations are instead performed on its backing map.
</p>

<p class="XXX">
これは、`裏ng~map$を別の~mapに置換することを許容する。
これは、
<a href="https://github.com/whatwg/storage/issues/4">課題 #4</a>
用に必要になり，
<a href="https://privacycg.github.io/storage-access/">~storage~access~API</a>
用にも必要になり得る。
◎
This allows for the backing map to be replaced. This is needed for issue #4 and potentially the Storage Access API.
</p>

		</section>
		<section id="storage-task-source">
<h3 title="Storage task source">4.8. ~storage~task~source</h3>

<p>
`~storage~task~source@
は、
`~task~source$であり，`~storage端点$
— 特に，`~storage端点$の`~quota$sE —
に関係する すべての`~task$用に利用される。
◎
The storage task source is a task source to be used for all tasks related to a storage endpoint. In particular those that relate to a storage endpoint’s quota.
</p>

<div class="algo">
<p>
`~storage~taskを~queueする@
ときは、
所与の
( `大域~obj$ %大域~obj, 手続き %手続き )
に対し
⇒
`大域~taskを~queueする$( `~storage~task~source$, %大域~obj, %手続き )
◎
To queue a storage task given a global object global and a series of steps steps, queue a global task on the storage task source with global and steps.
</p>
</div>

		</section>
	</section>
	<section id="persistence">
<h2 title="Persistence permission">5. 持続性~許可</h2>

<p>
`局所~storage~bucket$の`~mode$が `persistent^l 【 “持続的” 】に変更されるのは、
利用者が（または、~UAが，利用者に利するために）
`persistent-storage^l で識別される`強力な特能$を利用する許可を是認したときに限られる。
◎
A local storage bucket can only have its mode change to "persistent" if the user (or user agent on behalf of the user) has granted permission to use the "persistent-storage" powerful feature.
</p>

<p class="note">注記：
`生成元$に是認されたなら、持続性~許可は，［
~UAによる ~storageを~clearするための施策
］から保護するために利用できる。
~UAは、`生成元$や利用者の介在~抜きには，持続的にされた~storageを~clearできない。
これは特に、利用者が~offlineの間に可用にする必要がある資源や, 利用者が局所的に作成した資源に対し，有用になる。
◎
When granted to an origin, the persistence permission can be used to protect storage from the user agent’s clearing policies. The user agent cannot clear storage marked as persistent without involvement from the origin or user. This makes it particularly useful for resources the user needs to have available while offline or resources the user creates locally.
</p>

<p>
`persistent-storage^l で識別される`強力な特能$の許可に関係する各種［
~algo, 型
］は、
次に挙げるものを除いて既定のものになる：
◎
The "persistent-storage" powerful feature’s permission-related algorithms, and types are defaulted, except for:
</p>
<dl>
	<dt>
`許可~状態$
◎
permission state
</dt>
	<dd>
`persistent-storage^l の`許可~状態$の値は、同じ`生成元$enVを伴う すべての`環境~設定群~obj$にわたり，同じにするモノトスル。
◎
"persistent-storage"'s permission state must have the same value for all environment settings objects with a given origin.
</dd>

	<dt>
`許可~revocation~algo$
◎
permission revocation algorithm
</dt>
	<dd class="algo">
<p>
次を走らす：
</p>
		<ol>
			<li>
~IF［
`現在の許可~状態を取得する$( `persistent-storage^l ) ~EQ `granted$l
］
⇒
~RET
◎
If the result of getting the current permission state with "persistent-storage" is "granted", then return.
</li>
			<li>
%棚 ~LET `局所~storage棚を得する$( `現在の設定群~obj$ )
◎
Let shelf be the result of running obtain a local storage shelf with current settings object.
</li>
			<li>
%棚 の`~bucket~map$[ `default^l ] の`~mode$ ~SET `best-effort^l
◎
Set shelf’s bucket map["default"]'s mode to "best-effort".
</li>
		</ol>
	</dd>
</dl>

	</section>
	<section id="usage-and-quota">
<h2 title="Usage and quota">6. 使用量と~quota</h2>

<p>
`~storage使用量@
（ `storage usage^en ）とは、`実装定義$な およその見積もりによる，`~storage棚$が利用している~byte数である。
◎
The storage usage of a storage shelf is an implementation-defined rough estimate of the amount of bytes used by it.
</p>

<p class="note">注記：
これは正確な量にはなり得ない。
~UAは、`~storage棚$が正確に何~byte利用しているか はっきりしなくなるような，重複集約, 圧縮, その他の技法を駆使してるかもしれず、また~UAには，そうすることが奨励されるので。
◎
This cannot be an exact amount as user agents might, and are encouraged to, use deduplication, compression, and other techniques that obscure exactly how much bytes a storage shelf uses.
</p>

<p>
◎追跡路
`~storage~quota@
（ `storage quota^en ）とは、`実装定義$な 保守的な見積もりによる，`~storage棚$が保持できる総~byte数である。
この量は、利用者に ある程度の余裕を与えるため，機器~上の~storage空間の総計より少なくなるべきであるが、機器~上の可用な~storage空間の関数にしないモノトスル。
◎
(This is a tracking vector.)
The storage quota of a storage shelf is an implementation-defined conservative estimate of the total amount of bytes it can hold. This amount should be less than the total storage space on the device. It must not be a function of the available storage space on the device.
</p>

<p class="note">注記：
~UAには、~quotaを評価するときには，次を考慮することが強く奨励される
⇒＃
~naviの頻度,
訪問の近過去度,
~bookmarkされたかどうか,
`persistent-storage^l に対する<a href="#persistence">許可</a>
◎
User agents are strongly encouraged to consider navigation frequency, recency of visits, bookmarking, and permission for "persistent-storage" when evaluating quotas.
</p>

<p class="note">注記：
直接間接を問わず，可用な~storage空間を露呈するのは、指紋収集や孕まれる`生成元$の視野の外側へ情報が漏洩される結果に至らせ得る。
◎
Directly or indirectly revealing available storage space can lead to fingerprinting and leaking information outside the scope of the origin involved.
</p>

	</section>
	<section id="management">
<h2 title="Management">7. 管理</h2>

<p>
~UAは、`~storage~bucket$を~clearするときには，まるごと~clearするモノトスル。
~UAは、`~storage~bucket$に~access可能な~scriptが走っている間は
— 利用者から他が指図されない限り —
それを~clearするのを避けるベキである。
◎
Whenever a storage bucket is cleared by the user agent, it must be cleared in its entirety. User agents should avoid clearing storage buckets while script that is able to access them is running, unless instructed otherwise by the user.
</p>

<p>
`~storage~bucket$の除去により，それを包摂している`~storage棚$ %棚 の`~bucket~map$が`空$mapになった場合、 %棚 を包摂している`~storage倉$から，対応する`~storage~key$とともに %棚 を`除去する$mapこと。
◎
If removal of storage buckets leaves the encompassing storage shelf’s bucket map empty, then remove that storage shelf and corresponding storage key from the encompassing storage shed.
</p>

		<section id="storage-pressure">
<h3 title="Storage Pressure">7.1. ~storageの逼迫</h3>

<p>
~UAは、~storageが逼迫してきたときは，~network状態, および
`局所~storage~bucket$のうち［
`~mode$ ~EQ `best-effort^l
］なるものを~clearするベキである。
理想的には、利用者への影響iをなるべく抑えるような，優先度に基づく除去~方式で。
◎
A user agent that comes under storage pressure should clear network state and local storage buckets whose mode is "best-effort", ideally prioritizing removal in a manner that least impacts the user.
</p>

<p>
それでもなお，~storageが逼迫している場合、
~UAは，そのことを利用者に伝えた上で、
残りの`局所~storage~bucket$
— すなわち，`~mode$ ~EQ `persistent^l なるもの —
を~clearする仕方を利用者に提供するべきである。
◎
If a user agent continues to be under storage pressure, then the user agent should inform the user and offer a way to clear the remaining local storage buckets, i.e., those whose mode is "persistent".
</p>

<p>
`辿可能な~navigable$が閉じられたときは、
それに伴い，`~session~storage~bucket$も~clearするモノトスル。
◎
Session storage buckets must be cleared as traversable navigables are closed.
</p>

<p class="note">注記：
`辿可能な~navigable$の復活
— 例： `辿可能な~navigable$を開き直すことを通して／
~UAを開始し直した後も，それを利用し続けるなど —
を許容する~UAは、もっと複階的な経験則を孕む~clear法が必要とされよう。
◎
If the user agent allows for revival of traversable navigables, e.g., through reopening traversable navigables or continued use of them after restarting the user agent, then clearing necessarily involves a more complex set of heuristics.
</p>

		</section>
		<section id="ui-guidelines">
<h3 title="User interface guidelines">7.2. ~UI指針</h3>

<p>
~UAは、個々の~web~site用に，その~network状態と~storageを~clearする能を利用者に提供するベキである。
~UAは、自身の~UIにおいて~network状態と~storageとを判別させるベキでない。
これは、~network状態は，~storageを復活するために利用され得ないことを確保するとともに、利用者が留意しておく必要がある概念の個数を抑制する。
◎
User agents should offer users the ability to clear network state and storage for individual websites. User agents should not distinguish between network state and storage in their user interface. This ensures network state cannot be used to revive storage and reduces the number of concepts users need to be mindful of.
</p>

<p>
資格証は、他から分離されるべきである。
資格証は、利用者が復活できないかもしれない~data
— 自動生成された~passwordなど —
を包含するので。
許可~storageも、利用者の不便さを避けるため，分離するのが最善である。
◎
Credentials should be separated as they contain data the user might not be able to revive, such as an autogenerated password. Permissions are best separated too to avoid inconveniencing the user.
</p>

		</section>
	</section>
	<section id="api">
<h2 title="API">8. ~API</h2>

<pre class="idl">
[`SecureContext$]
interface mixin `NavigatorStorage@I {
  [`SameObject$] readonly attribute `StorageManager$I `storage$m;
};

`Navigator$I includes `NavigatorStorage$I;
`WorkerNavigator$I includes `NavigatorStorage$I;
</pre>

<p>
各`環境~設定群~obj$ `HTML$r には、
`StorageManager$I ~objが結付けられる。
◎
Each environment settings object has an associated StorageManager object. [HTML]
</p>

<p class="algo">
`storage@m
取得子~手続きは
⇒
~RET コレに`関連な設定群~obj$の `StorageManager$I ~obj
◎
The storage getter steps are to return this’s relevant settings object’s StorageManager object.
</p>

<pre class="idl">
[`SecureContext$,
 `Exposed$=(Window,Worker)]
interface `StorageManager@I {
  `Promise$&lt;`boolean$&gt; `persisted$m();
  [`Exposed$=Window] `Promise$&lt;`boolean$&gt; `persist$m();

  `Promise$&lt;`StorageEstimate$I&gt; `estimate$m();
};

dictionary `StorageEstimate@I {
  `unsigned long long$ `usage@m;
  `unsigned long long$ `quota@m;
};
</pre>

<div class="algo">
<p>
`persisted()@m
~method手続きは：
◎
The persisted() method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%大域~obj ~LET コレに`関連な大域~obj$
◎
Let global be this’s relevant global object.
</li>
	<li>
%棚 ~LET `局所~storage棚を得する$( コレに`関連な設定群~obj$ )
◎
Let shelf be the result of running obtain a local storage shelf with this’s relevant settings object.
</li>
	<li>
~IF［
%棚 ~EQ `失敗^i
］
⇒＃
`~promiseを却下する$( %~promise, `TypeError$E )；
~RET %~promise
◎
If shelf is failure, then reject promise with a TypeError.
◎
Otherwise,＼
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
run these steps in parallel:
</p>
		<ol>
			<li>
<p>
%持続されるか ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%棚 の`~bucket~map$[ `default^l ] の`~mode$ ~EQ `persistent^l
◎
Let persisted be true if shelf’s bucket map["default"]'s mode is "persistent"; otherwise false.
</p>

<p class="note">注記：
内部~errorが生じたときは ~F になる。
◎
It will be false when there’s an internal error.
</p>
			</li>
			<li>
<p>
`~storage~taskを~queueする$( %大域~obj, 次の手続き )
◎
Queue a storage task with global＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise, %持続されるか )
◎
to resolve promise with persisted.
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`persist()@m
~method手続きは：
◎
The persist() method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%大域~obj ~LET コレに`関連な大域~obj$
◎
Let global be this’s relevant global object.
</li>
	<li>
%棚 ~LET `局所~storage棚を得する$( コレに`関連な設定群~obj$ )
◎
Let shelf be the result of running obtain a local storage shelf with this’s relevant settings object.
</li>
	<li>
~IF［
%棚 ~EQ `失敗^i
］
⇒＃
`~promiseを却下する$( %~promise, `TypeError$E )；
~RET %~promise
◎
If shelf is failure, then reject promise with a TypeError.
◎
Otherwise,＼
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
run these steps in parallel:
</p>
		<ol>
			<li>
<p>
%許可 ~LET `persistent-storage^l を`利用する許可を要請-$した結果
◎
Let permission be the result of requesting permission to use "persistent-storage".
</p>

<p class="note">注記：
~UAには、同じ`生成元$に対し，同時期に利用者にこの問いに重ねて回答させないことが奨励される。
この【許可を要請する】~algoは、そのような局面を取扱うためのものではない。
◎
User agents are encouraged to not let the user answer this question twice for the same origin around the same time and this algorithm is not equipped to handle such a scenario.
</p>
			</li>
			<li>
%~bucket ~LET %棚 の`~bucket~map$[ `default^l ]
◎
Let bucket be shelf’s bucket map["default"].
</li>
			<li>
<p>
%持続されるか ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%~bucket の`~mode$ ~EQ `persistent^l
］
◎
Let persisted be true if bucket’s mode is "persistent"; otherwise false.
</p>

<p class="note">注記：
内部~errorが生じたときは ~F になる。
◎
It will be false when there’s an internal error.
</p>
			</li>
			<li>
<p>
~IF［
%持続されるか ~EQ ~F
］~AND［
%許可 ~EQ `granted$l
］：
◎
If persisted is false and permission is "granted", then:
</p>
				<ol>
					<li>
%~bucket の`~mode$ ~SET `persistent^l
◎
Set bucket’s mode to "persistent".
</li>
					<li>
~IF［
内部~errorは生じていない
］
⇒
%持続されるか ~SET ~T
◎
If there was no internal error, then set persisted to true.
</li>
				</ol>
			</li>
			<li>
<p>
`~storage~taskを~queueする$( %大域~obj, 次の手続き )
◎
Queue a storage task with global＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise, %持続されるか )
◎
to resolve promise with persisted.
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`estimate()@m
~method手続きは：
◎
The estimate() method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%大域~obj ~LET コレに`関連な大域~obj$
◎
Let global be this’s relevant global object.
</li>
	<li>
%棚 ~LET `局所~storage棚を得する$( コレに`関連な設定群~obj$ )
◎
Let shelf be the result of running obtain a local storage shelf with this’s relevant settings object.
</li>
	<li>
~IF［
%棚 ~EQ `失敗^i
］
⇒＃
`~promiseを却下する$( %~promise, `TypeError$E )；
~RET %~promise
◎
If shelf is failure, then reject promise with a TypeError.
◎
Otherwise,＼
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
run these steps in parallel:
</p>
		<ol>
			<li>
%使用量 ~LET %棚 の`~storage使用量$
◎
Let usage be storage usage for shelf.
</li>
			<li>
%~quota ~LET %棚 の`~storage~quota$
◎
Let quota be storage quota for shelf.
</li>
			<li>
%辞書 ~LET 次のようにされた新たな `StorageEstimate$I 辞書
⇒＃
`usage$m ~member ~SET %使用量,
`quota$m ~member ~SET %~quota
◎
Let dictionary be a new StorageEstimate dictionary whose usage member is usage and quota member is quota.
</li>
			<li>
<p>
~IF［［
%使用量, %~quota を得する間に何らかの内部~errorが生じた
］
⇒
`~storage~taskを~queueする$( %大域~obj, 次の手続き )
◎
If there was an internal error while obtaining usage and quota, then queue a storage task with global＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `TypeError$E )
◎
to reject promise with a TypeError.
</div>

<p class="note">注記：
内部~errorは極めて稀と想定されており，何らかの類の低levelな［
~platform／~hardware
］における瑕疵を指示する。
しかしながら，~webにおける［
実装／~platform
］の多様さの尺度からは、生じるものとみなす必要がある。
◎
Internal errors are supposed to be extremely rare and indicate some kind of low-level platform or hardware fault. However, at the scale of the web with the diversity of implementation and platforms, the unexpected does occur.
</p>
			</li>
			<li>
<p>
~ELSE
⇒
`~storage~taskを~queueする$( %大域~obj, 次の手続き )
◎
Otherwise, queue a storage task with global＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise, %辞書 )
◎
to resolve promise with dictionary.
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
次の方々からの~~貢献に感謝する：
</p>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main></div>

<div hidden>

<div lang="en" id="_acks1">
<p>
With that, many thanks to
Adrian Bateman,
Aislinn Grigas,
Alex Russell,
Ali Alabbas,
Andrew Sutherland,
Andrew Williams,
Austin Sullivan,
Ben Kelly,
Ben Turner,
Dale Harvey,
David Grogan,
Domenic Denicola,
fantasai,
Jake Archibald,
Jeffrey Yasskin,
Jesse Mykolyn,
Jinho Bang,
Jonas Sicking,
Joshua Bell,
Kenji Baheux,
Kinuko Yasuda,
Luke Wagner,
Michael Nordman,
Mike Taylor,
Mounir Lamouri,
Shachar Zohar,
<span lang="zh">黃強</span> (Shawn Huang),
<span lang="zh">簡冠庭</span> (Timothy Guan-tin Chien), and
Victor Costan
for being awesome!
</p>

<p>This standard is written by <a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a> (<a href="https://www.apple.com/">Apple</a>, <a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).</p>

</div>

<div lang="en" id="_ipr1">
<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://storage.spec.whatwg.org/review-drafts/2023-02/">Living Standard Review Draft</a>.
</p>
</div>

</div>
