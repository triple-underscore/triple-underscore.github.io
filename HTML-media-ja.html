<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML — video, audio, track 要素（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/embedded-content.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};

	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170331 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		E: 'error',
		a: 'attr',
		aM: 'attr',
		aV: 'attr',
		aT: 'attr',
		aS: 'attr',
		et: 'event-type',
		sc: 'scheme',
		st: 'attr-state',
		v: 'value',
		vK: 'value',
		jv: 'js-value',
		css: 'css',
		h: 'header',
		U: 'code-point',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		mM: 'code',
		mV: 'code',
		mT: 'code',
		mE: 'code',
		E: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		aM: 'code',
		aV: 'code',
		aT: 'code',
		aS: 'code',
		et: 'code',
		mt: 'code',
		tag: 'code',
		st: 'span',
		sc: 'code',
		h: 'code',
		css: 'code',
		sub: 'sub',
		U: 'span',
		v: 'code',
		vK: 'code',
		jv: 'code',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
case 'mM':
case 'mV':
case 'mS':
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'tag': //
	text = '&lt;' + text + '&gt;';
	break;
case 'sc': // url scheme
	text = text.replace(/_/, ':');
	break;
case 'U': // 
	text = 'U+' + key;
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">
</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">

	●仕様（動詞
support::::サポート
	未~supportの:unsupported:~
不能化-:disable:~
可能化-:enable:~
	供せる:enable:~
指定-:specify:~
指示-:indicate:~
提供-:provide:~
定義-:define:~
影響-:affect:~
制御:control:~
既存の:existing:~
期待-:expect:~
制限:limitation:~
制限-:limit:~
上限:limit:~
取扱う:handle する:取り扱う
取扱える:handle できる:取り扱える
決定-:determine:~
試行-:try:~
述べる:describe する:~
述べた:describe した:~
述べて:describe して:~
記述:description:~
適用-:apply:~
	-:applicable:~
意図-:intend:~
取組む:address する:取り組む
拘束-:constrain:~
拘束:constraint:~
含意-:imply:~
示唆-:suggest:~
助ける:help する:~
促す:encourage する:~
詳細:details:~
詳細な:detailed:~
認識-:recognize:~
依存-:depend:~
奨励-:encourage:~
実装-:implement:~
実装:implementation:~
実装者:implementor:~
督促-:urge:~
要求-:require:~
見なさ:consider さ:~
考える:consider する:~
考慮-:consider:~
設計-:design:~
見做され:assume され:~
見做す:assume する:~
試験-:test:~
尊守-:honor:~
強制-:force:~
挙動:behavior:ふるまい
欲さな:desire しな:~
欲する:desire する:~
欲され:desire され:~
判別-:distinguish:~
達成-:achieve:~
抑止-:suppress:~
採用-:adopt:~
最小化-:minimize:~
確保-:ensure:~
孕む:involve する:~
解-:understand:~
避ける:avoid する:~
避けれ:avoid でき:~
解釈-:interpret:~
解釈:interpretation:~
意味-:mean:~
順守-:obey:~
改善-:improve:~
	必要:need ／ have to
	利用-:use／using
	利用可能:usable:~
	織り込んだ:taking into account
	~~働く:serve
	加えて:in addition to
	~~損なう:interfere
	決める:decide する:~
	用立て:make use

	●仕様
UA:user agent:UA
API:
Web:
platform::::プラットフォーム
app:application:::アプリ
browser::::ブラウザ
risk::::リスク
model::::モデル

方式:manner:~
既定の:default:~
既定:default:~
旧来の:legacy:~
明示的:explicit:~
利用者:user:~
効果:effect:~
可用:available:~
	可用でない:unavailable:~
手続き:steps:~
下位手続き:substeps:~
段:step:~
概して:typical に:~
注釈文:prose:~
特定0の:particular:ある特定の
特色機能:feature:~
相応しい:suitable な:~
相応しく:suitable に:~
要件:requirements:~
通常の:normal:~
適切:appropriate:~
作者:author:~
規則:rule:~
条件:condition:~
	~~指示
	~~実際:indeed
追加の:additional:~
独立:independent:~
独立的:independent:~
	~~抑制:allow〜affect
	当然ながら:naturally
関連する:relevant な:~
	見込まれる:will likely
概略的な:brief:~
懸念:concern:~
情報:information:~
	伝える:inform する
見当:idea:~
正しく:correct に:~
正しい:correct な:~
共通する:common な:~
単純:simple:~
表向きは:ostensible には:~
一般:general:~
	不必要な:unnecessary:~
	不必要に:unnecessarily
	複雑な:complicated:~
	~~手法:approach::::
不完全:incomplete:~
一様:uniform:~
仕方:way:~
仕様:spec:~
特定の:specific:~
特有の:specific な:~
用語:term:~
診断用の:diagnostic:~
逸脱:deviation:~
否定的:negative:~
架空の:fictional:~
意図的:intentional:~
状況:situation:~
	要約:summary
積極的:aggressive:~
最善の:best:~
最善:best:~
念頭:mind:~
妥協点:compromise:~
適度:reasonable:適切
作者:author:~
保守的:conservative:~
実際:actual:~
課題:issue:~
理由:reason:~
楽観的:optimistic:~
判定基準:criteria:~
些細:negligible:~
仕組み:mechanism:~
有用:useful:~
目的:purpose:~
柔軟:liberal:~
互換:compatible:~
通例的:usual:~
便利:convenient:~
問題:problem:~
直接的:direct:~
手動:manual:~
最適:optimal:~
稀な:rare:~
選択的:selective:~
手段:means:~
原則的:principle:~
特別:special:~

	●仕様（他
	確度:how confident 
	~~相応に~very
	具体例として:for instance
	例外的に:exception could be made
	例:example
	用語を通して／を通して:in terms of
	任意選択で:Optionally
	区別:distinction:~
	何の利得もない:nothing would be gained
	効き始める:kick-in
	~~実際に:really
	関わる／そのこと:matter
	にもかかわらず，:nonetheless
	だいたいは:presumably
	いつでも:ever
	定か:sure
	依然として:still
	代わりに:instead
	しかしながら，:however
	べき:should
	よい:may
	得る:potentially
	可能:possible
	したがって:thus
	特に:in particular
	であっても:to the contrary
	no longer
	方法
	されるべきと:ought
	注記:
	regardless
	原因:why
	度合い:degree:~
	極端な場合:in the extreme
	兼ね合い:balance
	~~適切と~~考えてthinks is advisable

	●network／navi
Content-Type:
URL:
HTTP:
Range:
DNS:
要請:request::~::リクエスト
fetch::::
fetching:::fetch 処理
link::::リンク
network::::ネットワーク
download::::ダウンロード
server::::サーバ
serve::::サービス供与
url::::
protocol::::プロトコル
address::::アドレス
client::::クライアント
record::::レコード
close:
sliding-window:sliding window
相対的:relative:~
行先:destination:~
資源:resource::~:リソース
素片:fragment::~

load:
読込処理:loading::読み込み::ロード処理
読込み:load::読み込み::ロード
読込もう:load しよう::読み込しよう::ロードしよう
読込む:load する::読み込む::ロードする
読込まれ:load され::読み込まれ::ロードされ
読込ませ:load させ::読み込ませ::ロードさせ
読込め:load でき::読み込め::ロードでき
読込んだ:load した::読み込んだ::ロードした
読込んで:load して::読み込んで::ロードして
読込済み:load 済み::読み込み済み::ロード済み
読込中:loading::読み込み中::ロード中
	再度~読込む:reload::~::ロード
未読込み:not-loaded::未読み込み::未ロード
未読込みに:unload::未読み込みに::未ロードに
読込失敗:failed to load::読み込み失敗::ロード失敗

切断-:disconnect:~
受信-:receive:~
接続-:connect:~
接続:connection:~
再接続-:reconnect:~
放送:broadcast:~
放送局:broadcaster:~
送信-:send:~
送達-:deliver:~
運んで:carry して:~

種別:type:~

navi::::ナビ
navigate::::ナビゲート
環境:environment:~
設定群:settings:~
source::::ソース
頁:page:::ページ
補助:auxiliary::~
進捗-:progress:~
遅延-:delay:~

資格証:credential::資格証明情報::クレデンシャル
	~URL資格証~利用:use-URL-credential

減速-:throttle:~
帯域幅:bandwidth:~
接続性:connectivity:~
流通:traffic:~
負荷:load:~
失敗-:fail:~
失敗:failure:~
折衝-:negotiate:~
検索取得:retrieval:~

	●構文
文字列:string:~
構文解析-:parse::~::パース
終了tag:end tag::終了 tag:終了タグ
	開始tag:end tag::開始 tag:開始タグ
省略不可:omissible でない:~
省略-:omit:~
省略:omission:~
合致-:match:~
HTML:
tag::::タグ
error::::エラー
	error含み:erroneous
keyword::::キーワード
空:empty:~
成分:component:~
妥当:valid:~
	前後~空白~
構文:syntax:~

	●内容
flow::::フロー
text::::テキスト
textual::::テキスト的
style::::スタイル
plugin::::プラグイン
frame::::フレーム
	frame刻みの:frame-by-frame

分類:categories:~
透過的:transparent::~
句内容:phrasing content:phrasing 内容:~::フレージング内容
可触:palpable::~

内容:content:~
代替:alternative:~
空内容:blank:~
代表:representative:~
同胞:sibling:~
入子に:nest::入れ子に
入子の:nested::入れ子の
DOM:
親:parent:~
子:child:~
	子たち:children
子孫:descendant:~
文書:document:~
要素:element:~
node::::ノード

media::::メディア
埋込みの:embedded::埋め込みの
埋込める:embed できる::埋め込める
	埋込み:embedding::~
埋込む:embed する::埋め込む
埋込まれ:embed され::埋め込まれ
	埋込んだ:embed し::埋め込んだ
埋込んで:embed して::埋め込んで
	埋込もう:embed しよう::埋め込もう

公告-:announce:~
交差:intersection:~
観測-:observe:~
	叩いた:hit した:~

	●呈示
view::::ビュー
show:
呈示-:present:~
作動中:active::~::アクティブ
作動化:activation::~::アクティブ化
CSS:
pixel::::ピクセル
交差-:intersect:~
可視:visible:~
	読める:readable
	かき消され:drown out

layout::::レイアウト
box::::ボックス

access::::アクセス
	access可能:accessible
	~accessし易い:accessible
accessibility:::access 容易性:アクセス容易性
inline::::インライン
size::::サイズ
resize::::リサイズ
	resize可能:resizable
横幅:width::~
縦幅:height::~
寸法:dimension:~
横:horizontal:~
縦:vertical:~
解像度:resolution::~
内在的:intrinsic::~
表示域:viewport::~
積層する:overlay する::重ねる
積層され:overlay され::重ねられ

塗る:paint する:~
塗り:paint:~
描かれ:draw され:~
干渉-:interfere:~
調整-:adjust:~
調整:adjustment:~
表示-:display::~
表示:display::~
合成-:synthesize::~
合成:synthesis::~
具現化-:render::~
具現化:rendering::~
描画-:render::~
描画:rendering::~
描画済み:rendered::~
収まる:fit する:~
中央:center:~
開閉可能な:closed:~
縦横比:aspect ratio::~
	縦横比:the ratio
区画:area::~

透明:transparent:~
	黒一色:black／blackness
言語:language:~

	●UI／対話
UI:
control::::コントロール
controller::::コントローラ
scrubber:
bar::::バー
click::::クリック
button::::ボタン
key::::キー
menu::::メニュー
remote-control:remote control:::リモコン
window::::ウィンドウ
icon::::アイコン
screen::::スクリーン
	全~screen:fullscreen
screen-reader:screen reader:::スクリーンリーダ
screensaver::::スクリーンセーバ
system::::システム
utility::::ユーティリティ

対話:interaction::~
対話的:interactive::~
対話-:やりとり
選好:preference:~
選択-:select::~
選択:selection::~
未選択に:unselect:~
選定-:select:~
選定:selection:~
操作-:manipulate:~

障害:disabilities:~
難聴:hard-of-hearing:~
遮蔽-:obscure:~
運転-:drive:~
盲目:blind:~
物理的:physical:~
認知的:cognitive:~
	聴覚
	において，部分的または全部的に, 物理的または認知的な障害:the partially sighted, the blind, the hard-of-hearing, the deaf, and those with other physical or cognitive disabilities ／the deaf or to those with other physical or cognitive disabilities
	partially sighted
援助-:aid:~
体験:experience:~
視覚的:visual:~
	視覚:visual:~
	聴覚

視聴-:watch:~
視聴mode:viewing mode:視聴 mode::視聴モード
hint::::ヒント
阻まれ:block され::~::ブロックされ
阻む:block する::~::ブロックする


	●media
型:type:~
	GIF
	JPEG
	MJPEG
	JPEG-push
	TV
Ogg:
MIME:
MP4:
parameter::::パラメタ
容器:container:::コンテナ
profile::::プロファイル
level::::レベル
live-event:live event:::ライブイベント
clip::::クリップ
radio::::ラジオ
poster::::ポスター
bitrate::::ビットレート
codec::::コーデック
rate::::レート
MediaError:
TimeRanges:
WebVTT-file:WebVTT file
WebVTT:
channel::::チャンネル
label::::ラベル
message::::メッセージ
seek:
streaming::::ストリーミング
stream::::ストリーム
title::::タイトル
track::::トラック
caption::::キャプション
chapter::::チャプター
musical:
cue::::キュー
showing:
形式:format::~
画像:image::~
	なし:none
動画:video::~
	動画が占めない部位: letterboxed or pillarboxed

音声:audio::~::オーディオ
音声転写0:transcription::音声転写
音声転写:transcript::~
音述:audio description::~
音響:sound::~
環境音:ambient noise::~
最大音量:loudest::~
聴感音量:loudness::~
無音:silent:~
	無音:quietest
明瞭:clear:~
音量:volume::~
音高:pitch::~
消音-:mute::~::ミュート
	消音されなく:unmute
	低過ぎるか高過ぎる:so low or so high
musical:
発話:speech::~::スピーチ
混合-:mix::~

字幕:subtitle::~
手話:sign language:~
翻訳:translation::~
	聴取でき:audible で
会話:dialogue:~
外観:appearance:~
実効:effective:~
映画:movie::~
位置:position:~


割当され:assign され::あてがわれ
割当でき:assign でき::あてがえ
提供元:provider::~
帯域内:in-band::~
符号化-:encode::~::エンコード


	●範囲／timeline／再生／seek
Date:
	UTC
offset::::オフセット
	時機:timing／when
時間長:duration:~
覆う:cover する:
時間軸:timeline::~
sample::::サンプル
範囲:range:~
断片:fragment:~
終止-:end:~
終端:end:~
開始-:start:~
始端:start:~
重合して:overlap して:重なり合って
重合しな:overlap しな:重なり合わな
	隣接する:adjacent な:~
	起点に:anchored at
日付:date:~
日時:date＆time:~
時刻:time:~
瞬間:moment:~
増加-:increase:~
減少-:decrease:~
原点:origin:~
失効-:expire:~
拡張-:extend:~
	早い:early な:早い
	最も早い:earliest:
時刻印:timestamp:~
time-march-on:time march-on
同期-:synchronize:~
時間同期的な:timed:時間に同期的な
時計:clock:~
無限:infinite:~
計時:timing:~
近似-:approximate:~
近似:approximation:~
過去:past:~
長さ:length:~
	~~集約:fold
無限界:unbounded:~
有限界:bounded:~
	10 月の金曜日の昼過ぎ:sunny Friday afternoon in October
触れて:touch して:~
wall:
realtime:
区分:segment:~

進めた:advance した:~
進めら:advance さ:~
進める:advance する:~
進めれ:advance でき:~

再生-:play::~
再生:playback::~
	再生-中
再生待ち:pending play::~
方向:direction:~
逆方向:backwards:~
順方向:forwards:~
逆行-:reverse:~
早戻し:fast-rewind:~
早送り:fast-forward:~
移動-:move:~
自動再生:autoplay:~
自動:auto:~
自動的:automatic:~
停止-:stop:~
休止-:suspend:~
単調:monotonic:~
地点:point:~
再開-:resume::~
見積もり:estimate:~
見積もっ:estimate し:~
seeking:::seek 処理
seek:
速度優先:approximate-for-speed:~
速度:speed:~
低速:slow:~
高速:fast:~
pause::::一時停止
	~pauseされなく:unpause
	~pauseの切り替え:pausing, and unpausing
motion::::モーション
stall:
精度:precision:~
精確:precise:~
正確0:accurate:正確

	●処理
algo:algorithm:::アルゴリズム
logic::::ロジック
looping::::ループ処理
loop::::ループ
event-loop:event loop:::イベントループ
buffer::::バッファ
buffering:::buffer 処理:バッファ処理
	buffer中:buffering#5
task::::タスク
発火-:fire:~
event::::イベント
listener::::リスナ
listen::::リッスン
call:
callback:
handler::::ハンドラ
live:
promise:
detach:
flag::::フラグ
mode::::モード
pointer::::ポインタ
timeout:
sniff:
cache::::キャッシュ
作成-:create:~
待行列:queue::~::キュー
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ
待入し:queue し::待ち行列に入れ::キューし
誘発-:trigger:~
走らす:run する:~
走らせ:run し:~
走って:run して:~
被呼出時:被 invoke 時:~
呼出す:invoke する:呼び出す
呼出さ:invoke しな:呼び出さ
呼出され:invoke され:呼び出され
遂行-:perform:~
中止-:abort:~
誘発-:trigger:~
活動:activity:~
源:source::~::ソース
初期化-:initialize:~
初期:initial:~
	初期~時には:initially
記録-:record:~
遭遇-:encounter:~
処理-:process:~
処理:processing:~
解決-:resolve::~
却下-:reject::~
待機-:wait:~
復帰-:revert:~
	飛ば:skip
	飛び／飛ぶ:jump
通知:notification:~
通知-:notify:~
待受ける:await する::待ち受ける
完了-:complete:~
実行-:execute:~
実行:execution:~
投出-:throw:~
例外:exception:~
並列的:parallel:~
同期区間:synchronous section:~
静的:static:~
動的:dynamic:~
事前条件:preconditions:~
成功裡:successful:~
致命的:fatal:~
能動的:active:~
状態:state::~
状態s:status::状態
準備状態:ready state::~
準備度:readiness::~
準備済み:ready::~
更新-:update:~
破棄-:discard:~
処理待ち:pending:~
処理待ちの:pending:~
	待ちの:in-flight
忘れる:forget する:~
継続-:continue:~
専用の:dedicated:~
即時:immediate:~
直列化器:serializer::~::シリアライザ
拡充-:populate:~
候補:candidate:~
永続的:permanent:~
尽きた:exhaust した:~
	~~判明した:found by inspection to be
	利用可能:usable:~
中断-:interrupt:~
取消す:cancel する::取り消す::キャンセルする

	●§保安
top-level::::トップレベル
CORS:
SVG:
metadata::::メタデータ
site::::サイト
sandbox:
閲覧文脈:browsing context:~
能:ability:~
試みる:attempt する:~
試みて:attempt して:~
試みな:attempt しな:~
同一生成元:same-origin::~::同一オリジン
非同一生成元:cross-origin::~::クロスオリジン
許容-:allow:~
非安全:unsafe::~

privacy::::プライバシー
security::::セキュリティ
animation::::アニメーション
code::::コード
host::::ホスト
intranet::::イントラネット
敏感:sensitive::~
考慮点:considerations:~
事例:case:~
企業:corporation:~
企業内:corporate:~
処理能:performance:~
判断-:deem:~
制約:restriction:~
受容可能:acceptable:~
含意:implications:~
	呈-:present:~
外縁:outer:~
実施:practice:~
所在:location:~
攻撃:attack:~
攻撃者:attacker:~
敵対的:hostile:~
新製品:new product:~
有意に:significant:~
概念:concept:~
機密性:confidentiality:~
機密的:confidential:~
流れる:flow する:~
深刻:serious:~
漏洩-:leak:~
無関係な:unrelated:~
特徴:characteristic:~
脅威:threat:~
自前の:own:~
被害者:victim:~
視点:perspective:~
計画:plan:~
訪問-:visit:~
読取れる:read できる:読み取れる
読取る:read する:読み取る
騙して:trick して:~
	~~問題になり得る:potentially problematic
	~~由来する:come from
	抜け穴を呈する:present 〜 breach


	●§最善の実施
key-frame:key-frame:::キーフレーム
plane:
保持-:hold:~
hardware::::ハードウェア
software::::ソフトウェア
set-top-box:set-top box:::セットトップボックス
機器:device:~
携帯電話:mobile phone:~
	小さい:small
解放-:release:~
	良い:good:~
	-:very
注意深く:careful に:~
garbage::::ガーベジ
収集-:collect::~
	落とさ:drop
	震え:choppy

不良:bad:~
仕事:job:~
側面:aspect:~
可変:variable:~
品質:quality:~
報告-:report:~
	差分:deltas:~
平均:average:~
復号-:decode:~
拙い:poor な:~
改訂-:revise:~
格納-:store:~
検分-:inspect:~
検分:inspection:~
機会:opportunity:~
	~~機会:chance
素材:material:~
	落とす:drop
	作り込めば:work
	良く
	見れ:view
	足る:sufficient:
	~~活用:take

	●未分類（動詞
保全-:preserve:~
公開-:expose:~
達-:reach:~
参照-:reference:~
	含-:include:~
在する:present する:在る
変化-:change:~
変更-:change:~
所与の:given:与えられた
	得-:obtain:~
	結付ける:associate する:~
結付けら:associate さ:結び付けら
表現-:represent:~
設定-:set:~
設定:setting:~
設定子:setter:~
再設定-:reset:~
開始-:start:~
除去-:remove:~
反映-:reflect:~
識別-:identify:~
挿入-:insert:~
改変-:modify:~
正確:exact:~
既知:known:~
既知の:known:~
既知の:known:~
未知:unknown:~
未知の:unknown:~
	知-:know:~
相違:difference:~
包含-:contain:~
応答:response:~
無視-:ignore:~
確立-:establish:~
確定的:definite:~
等価:equivalent:~
保守-:maintain:~
抑制-:reduce:~
検出-:detect:~
追加-:add:~
正規化済み:normalized:~
正規化-:normalize:~
評価-:evaluate:~
順序付けら:order さ:~
順不同:out-of-order:~
順序:order:~
連結-:concatenate:~
対応付ける:map する:~
上書き:override:~
生成-:generate:~
補間-:interpolate:~
複製:copy:~
	費や:spend
動作-:act:~
完全:complete:~
見出す:find する:~
見出され:find され:~
留めら:anchor さ:~
	留めて:snap 
切替える:switch する:~
切替えた:switch した:~
切替えて:switch して:~
切替わった:switch された:~
	ありに切り替え:turn on
導入-:introduce:~
増大-:increase:~
覚えて:remember して:~
作業:work:~
共有-:share:~
宣言-:declare:~

	遂げる:go through
	呼応して:in response to
	尽きる:overtake
	返す:return
	含めて:including
	増やす:increase
	得-:obtain
	渡-:pass
	示す:show
	変えないまま:leaving the other unchanged
	見れる:view
	選ぶ:choose
	として:form
	対応付けら:map さ
	絶え間なく~~更新され続ける:continuously increasing 
	~~復元
	選び取る:pick
	~~壊れて:corrupted

	●未分類
IDL:
instance::::インスタンス
interface::::インタフェース
method::::メソッド
obj:object:::オブジェクト
factory::::ファクトリ
tainted:
引数:argument:~
構築子:constructor:~
大域:global::~::グローバル
取得子:getter:~
script::::スクリプト
scripting::::スクリプト処理
session::::セッション
fallback::::フォールバック
storage::::ストレージ
下層の:underlying:~
byte::::バイト
data::::データ
file::::ファイル
list::::リスト
surround::::サラウンド
stereo::::ステレオ

真偽:boolean:~
列挙ed:enumerated:列挙
属性:attribute:~
名前:name:~
名:name:~
名前空間:namespace:~
値:value:~
集合:set:~
新たな:new:~

木:tree::~::ツリー
文脈:context:~
不連続:discontinuous:~
	不連続に:discontinuous fashion
	~~不連続に:non-linear fashion


	~~最優先に put 〜 first
	~~安定的な:consistent:~
白紙状態:scratch:~
公式的な:official:~
安定:stable:~
広告:advertisement:~
内部:internal:~
内部的:internal:~
適格:eligible:~
満杯:full:~
一時的:temporal:~
線形:linear:~
出力:output:~
種類:kind:~
小数:fraction:~
	箇所:spot／
中間の:intermediate:~
巨大な:large:~
近過去の:recent:~
	速やかに:promptly
	面白いもの:surprising
忠実:faithful:~
	最終的:eventual

	利用量:usage
	不在:absence／absent
	0:zero
	px:
	表:table
	-:cell
	行:row
	なし:missing
	聴覚に障害がある:deaf
	potentially
	anamorphic
	clean aperture
	数:number
	数値:numeric value
	方法:how to
	量:how much
	単位
	可能
	落とさ
	在して
	狭い:scarce
	直前に:has just
	再生され始めた:no longer
	一環／一部:part of
	最も大きい:largest
	より短くshorter
	~~判明:learn
	一式:set
	任意の:arbitrary:~
	同時:simultaneous
	直近:latest
	~instant
	空に／ ~NULL に:clear
	木を構築する
	不連続に
	近くに:a nearby
	真中:in the middle
	重ねて:over
	実:real
	~~関係
	則って
	代えて:over

	●指示語
外部:external:~
外部の:external:~
内側:inside:~
現在の:current:~
全部的:full:~
部分的:partial:~
	ある種の:certain
	~~追加の:extra
	この:this
	すべての:all
	その:that
	そのような:such
	それら:they
	それらの:those
	それらを:them
	これらの:these
	個の:one／two
	一部:part of
	上:above
	下:below
	与-:give
	両者:both
	他の:other
	他の場合:otherwise
	別の:another
	前:before
	前の:previous
	後:after
	最初の:first
	最後の:last
	各:each
	同じ:same
	結果:result
	結果の:resulting
	自身:itself／themselves
		自身:own:~
	等々:and so forth
	更には、furthermore
	様々な:variety of
	場合によっては:possibly
	いくつかの:several
	〜周りの near
	対応-:correspond:~
	後続の:subsequent
	most
	旧:older
	respective
	もまた:again
	現在:currently
	先立って:prior to
	中途
	部位
	列目
	同様

	個以上
	次第
	時点
	場合
	上述
	自体
	一方
	他方
	同順
	最大
	一例
	未知の
	自身
	個数
	各種
	結果
	対応

	●訳注
	符号化処理
	都合
	ゴミ
	円柱
	レンズ
	縦横
	圧縮-
	撮影-

</script>
<!--%リンク置換データ -->
<script type="text/plain" id="_link_map">

	●IDL
CEReactions:~HEcustom#cereactions
HTMLConstructor:~HTMLdom#htmlconstructor
object:~WEBIDL#idl-object

E.AbortError:~WEBIDL#aborterror
E.IndexSizeError:~WEBIDL#indexsizeerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotAllowedError:~WEBIDL#notallowederror
E.NotFoundError:~WEBIDL#notfounderror
E.NotSupportedError:~WEBIDL#notsupportederror

I.Document:~HTMLdom#document
I.HTMLVideoElement:#htmlvideoelement
I.HTMLAudioElement:#htmlaudioelement
I.HTMLTrackElement:#htmltrackelement
I.HTMLMediaElement:#htmlmediaelement
I.HTMLElement:~HTMLdom#htmlelement

I.CanPlayTypeResult:#canplaytyperesult
I.Blob:~FILEAPI#blob
	I.DOMException:~WEBIDL#dfn-DOMException
I.Date:~TC39#sec-date-objects
I.Event:~DOM4#interface-event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#interface-eventtarget
I.TrackEvent:#trackevent
I.TrackEventInit:#trackeventinit
I.File:~FILEAPI#file
I.MediaError:#mediaerror
I.MediaProvider:#mediaprovider
I.MediaSource:https://w3c.github.io/media-source/#idl-def-MediaSource
I.MediaStream:https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaStream

I.AudioTrackList:~HTMLemb#audiotracklist
I.AudioTrack:~HTMLemb#audiotrack
I.VideoTrackList:~HTMLemb#videotracklist
I.VideoTrack:~HTMLemb#videotrack
I.TextTrack:~HTMLemb#texttrack
I.TextTrackList:~HTMLemb#texttracklist
I.TextTrackKind:~HTMLemb#texttrackkind
I.TextTrackCue:~HTMLemb#texttrackcue
	I.TextTrackCueList:~HTMLemb#texttrackcuelist
	I.TextTrackMode:~HTMLemb#texttrackmode

I.TimeRanges:#timeranges
	I.VTTCue:~WEBVTT#vttcue

I.Window:~BROWSERS#window


mE.MEDIA_ERR_ABORTED:#dom-mediaerror-media_err_aborted
mE.MEDIA_ERR_DECODE:#dom-mediaerror-media_err_decode
mE.MEDIA_ERR_NETWORK:#dom-mediaerror-media_err_network
mE.MEDIA_ERR_SRC_NOT_SUPPORTED:#dom-mediaerror-media_err_src_not_supported
mE.code:#dom-mediaerror-code
mE.message:#dom-mediaerror-message

cP.空~文字列:#dom-canplaytyperesult-nil
l.maybe:#dom-canplaytyperesult-maybe
l.probably:#dom-canplaytyperesult-probably

m.src:#dom-source-src
m.Audio:#dom-audio
m.track:#dom-trackevent-track
m.createElement:~DOM4#dom-document-createelement
m.width:~HEembed#dom-dim-width
m.height:~HEembed#dom-dim-height

m.length:#dom-timeranges-length
m.end:#dom-timeranges-end
m.start:#dom-timeranges-start

mT.ERROR:#dom-track-error
mT.LOADED:#dom-track-loaded
mT.LOADING:#dom-track-loading
mT.NONE:#dom-track-none
mT.default:#dom-track-default
mT.kind:#dom-track-kind
mT.label:#dom-track-label
mT.readyState:#dom-track-readystate
mT.src:#dom-track-src
mT.srclang:#dom-track-srclang
mT.track:#dom-track-track

mV.playsInline:#dom-video-playsinline
mV.poster:#dom-video-poster
mV.videoHeight:#dom-video-videoheight
mV.videoWidth:#dom-video-videowidth

mM.HAVE_CURRENT_DATA:#dom-media-have_current_data
mM.HAVE_ENOUGH_DATA:#dom-media-have_enough_data
mM.HAVE_FUTURE_DATA:#dom-media-have_future_data
mM.HAVE_METADATA:#dom-media-have_metadata
mM.HAVE_NOTHING:#dom-media-have_nothing

mM.NETWORK_EMPTY:#dom-media-network_empty
mM.NETWORK_IDLE:#dom-media-network_idle
mM.NETWORK_LOADING:#dom-media-network_loading
mM.NETWORK_NO_SOURCE:#dom-media-network_no_source

mM.canPlayType:#dom-navigator-canplaytype
mM.addTextTrack:~HTMLemb#dom-media-addtexttrack
mM.audioTracks:~HTMLemb#dom-media-audiotracks
mM.autoplay:#dom-media-autoplay
mM.buffered:#dom-media-buffered
mM.controls:#dom-media-controls
mM.crossOrigin:#dom-media-crossorigin
mM.currentSrc:#dom-media-currentsrc
mM.currentTime:#dom-media-currenttime
mM.defaultMuted:#dom-media-defaultmuted
mM.defaultPlaybackRate:#dom-media-defaultplaybackrate
mM.duration:#dom-media-duration
mM.ended:#dom-media-ended
mM.error:#dom-media-error
mM.fastSeek:#dom-media-fastseek
mM.getStartDate:#dom-media-getstartdate
mM.load:#dom-media-load
mM.loop:#dom-media-loop
mM.muted:#dom-media-muted
mM.networkState:#dom-media-networkstate
mM.pause:#dom-media-pause
mM.paused:#dom-media-paused
mM.play:#dom-media-play
mM.playbackRate:#dom-media-playbackrate
mM.played:#dom-media-played
mM.preload:#dom-media-preload
mM.readyState:#dom-media-readystate
mM.seekable:#dom-media-seekable
mM.seeking:#dom-media-seeking
mM.src:#dom-media-src
mM.srcObject:#dom-media-srcobject
mM.textTracks:~HTMLemb#dom-media-texttracks
mM.videoTracks:~HTMLemb#dom-media-videotracks
mM.volume:#dom-media-volume

et.error:~HTMLindex#event-error
et.~errorM:#event-media-error
et.~errorS:#event-source-error
et.~errorT:#event-track-error
et.abort:#event-media-abort
et.addtrack:#event-media-addtrack
et.canplay:#event-media-canplay
et.canplaythrough:#event-media-canplaythrough
et.change:#event-media-change
et.cuechange:#event-media-cuechange
et.durationchange:#event-media-durationchange
et.emptied:#event-media-emptied
et.ended:#event-media-ended
et.enter:#event-media-enter
et.exit:#event-media-exit
et.load:#event-track-load
et.loadeddata:#event-media-loadeddata
et.loadedmetadata:#event-media-loadedmetadata
et.loadstart:#event-media-loadstart
et.mousedown:~UIEVENTS#event-type-mousedown
et.pause:#event-media-pause
et.play:#event-media-play
et.playing:#event-media-playing
et.progress:#event-media-progress
et.ratechange:#event-media-ratechange
et.removetrack:#event-media-removetrack
et.resize:#event-media-resize
et.seeked:#event-media-seeked
et.seeking:#event-media-seeking
et.stalled:#event-media-stalled
et.suspend:#event-media-suspend
et.timeupdate:#event-media-timeupdate
et.volumechange:#event-media-volumechange
et.waiting:#event-media-waiting


	●要素
e.audio:#the-audio-element
e.canvas:~HEcanvas#the-canvas-element
e.img:~HEimages#the-img-element
e.source:~HEimages#the-source-element
e.track:#the-track-element
e.video:#the-video-element

a.id:~HTMLdom#the-id-attribute
a.itemprop:~HTML5/microdata.html#names:-the-itemprop-attribute
a.lang:~HTMLdom#attr-lang

a.height:~HEembed#attr-dim-height
a.width:~HEembed#attr-dim-width

aS.src:#attr-source-src
aS.srcset:~HEimages#attr-source-srcset
aS.media:~HEimages#attr-source-media
aS.sizes:~HEimages#attr-source-sizes
aS.type:~HEimages#attr-source-type

aV.playsinline:#attr-video-playsinline
aV.poster:#attr-video-poster

aM.src:#attr-media-src
aM.crossorigin:#attr-media-crossorigin
aM.autoplay:#attr-media-autoplay
aM.controls:#attr-media-controls
aM.loop:#attr-media-loop
aM.muted:#attr-media-muted
aM.preload:#attr-media-preload

aT.default:#attr-track-default
aT.kind:#attr-track-kind
aT.label:#attr-track-label
aT.src:#attr-track-src
aT.srclang:#attr-track-srclang

v.none:#attr-media-preload-none
v.auto:#attr-media-preload-auto
v.metadata:#attr-media-preload-metadata

st.なし:#attr-media-preload-none-state
st.自動的:#attr-media-preload-auto-state
st.~metadata:#attr-media-preload-metadata-state

vK.subtitles:#attr-track-kind-keyword-subtitles
vK.captions:#attr-track-kind-keyword-captions
vK.descriptions:#attr-track-kind-keyword-descriptions
vK.chapters:#attr-track-kind-keyword-chapters
vK.metadata:#attr-track-kind-keyword-metadata

st.Captions:#attr-track-kind-captions
st.Chapters:#attr-track-kind-chapters
st.Descriptions:#attr-track-kind-descriptions
st.Metadata:#attr-track-kind-metadata
st.Subtitles:#attr-track-kind-subtitles
	＊audio description:#attr-track-kind-descriptions

mt.multipart/x-mixed-replace:iana.html#multipart/x-mixed-replace
mt.application/octet-stream:~IETF/rfc2046#section-4.5.1

	●用語
~poster~frame:#poster-frame
vD.内在的~縦幅:#concept-video-intrinsic-height
vD.内在的~横幅:#concept-video-intrinsic-width
表示域に交差-:#intersect-the-viewport
~track~URL:#track-url
~track言語:#track-language
~track~label:#track-label

	:#video
	:#audio
	:#dimUpdate

	●~media要素
~media要素:#media-element
~media要素~属性:#media-element-attributes
すべての~media要素に共通する属性:#media-element-attributes
~media~data:#media-data
~media資源:#media-resource
資源:#media-resource
~media要素~event~task源:#media-element-event-task-source

	•error
~message:#concept-mediaerror-message
~code:#concept-mediaerror-code
新たな~MediaError:#creating-a-mediaerror
	~MediaErrorを作成-:#creating-a-mediaerror

	•所在
~media提供元~obj:#media-provider-object
割当されている~media提供元~obj:#assigned-media-provider-object

	:#concept-media-load-algorithm-at-creation

	•MIME
~UAが具現化できないと知る型:#a-type-that-the-user-agent-knows-it-cannot-render

	•読込み
中止-:#_abort-media-load-algorithm
自動再生~可能~flag:#can-autoplay-flag
~load~event遅延-中~flag:#delaying-the-load-event-flag
~media要素~読込み~algo:#media-element-load-algorithm
資源~選定~algo:#concept-media-load-algorithm
専用の~media~source失敗~手続き:#dedicated-media-source-failure-steps
資源~fetch~algo:#concept-media-load-resource
~stall~timeout:#stall-timeout
~media~data処理~手続き~list:#media-data-processing-steps-list
~media資源に特有の~trackを忘れる:#forget-the-media-element's-media-resource-specific-tracks
	'
致命的でない~errorに遭遇-:~HTMLemb#non-fatal-media-error

	:#resourceSuspend
	:#found-another-audio-track
	:#found-another-video-track
	:#getting-media-metadata
	:#fatal-decode-error
	:#non-fatal-media-error
	:#found-a-media-resource-specific-timed-track

	•offset
~media時間軸:#media-timeline
~media時間軸を確立-:#defineTimeline
現在の再生~位置:#current-playback-position
既定の再生~開始-位置:#default-playback-start-position
公式的な再生~位置:#official-playback-position
可能な最も早い位置:#earliest-possible-position
~show~poster~flag:#show-poster-flag
~posterを示して:#show-poster-flag
時間軸~offset:#timeline-offset

	:#durationChange

	•準備状態
	:#fire-loadedmetadata
	:#handling-first-frame-available
	:#fire-loadeddata
	:#fire-waiting-when-waiting

	•再生
阻まれて:#blocked-media-element
再生-中であり得る:#potentially-playing
自動再生に適格:#eligible-for-autoplay
再生は許容され:#allowed-to-play
再生は終止して:#ended-playback
~errorに因り停止され:#stopped-due-to-errors
帯域内~内容のため~pauseされ:#paused-for-in-band-content
利用者~対話のため~pauseされ:#paused-for-user-interaction
再生待ち~promiseの~list:#list-of-pending-play-promises
再生待ち~promiseたちを却下-:#reject-pending-play-promises
再生待ち~promiseたちを解決-:#resolve-pending-play-promises
再生待ち~promiseたちを取り出:#take-pending-play-promises
再生-中について通知-:#notify-about-playing
内部~pause手続き:#internal-pause-steps
再生~方向:#direction-of-playback

新たに導入される~cueの~list:#list-of-newly-introduced-cues
~time-march-on:#time-marches-on
	~eventを準備-:~HTMLemb#prepare-an-event
~media資源の終端に達-:#reaches-the-end

	:#reaches-the-end
	:#rateUpdate
	:#media-playback

	•seek
~seek:#dom-media-seek
~seeking:#dom-media-seek

	:#seekUpdate

	•UI
消音-:#concept-media-muted
~UIを公開-:#expose-a-user-interface-to-the-user
再生~音量:#concept-media-volume
実効~media音量:#effective-media-volume

正規化済み:#normalised-timeranges-object
	正規化済み~TimeRanges~obj

	•track
選定-済みの動画~track:~HTMLemb#dom-videotrack-selected
可能化-済みの音声~track:~HTMLemb#dom-audiotrack-enabled

	•text track
~text~track:~HTMLemb#text-track
~media資源に特有の~text~track:~HTMLemb#media-resource-specific-text-track

tT.準備済み:~HTMLemb#the-text-tracks-are-ready
tT.~showing:~HTMLemb#text-track-showing
tT.種類:~HTMLemb#text-track-kind

tC.終止-時刻:~HTMLemb#text-track-cue-end-time
tC.開始-時刻:~HTMLemb#text-track-cue-start-time

処理待ち~text~trackの~list:~HTMLemb#list-of-pending-text-tracks
処理待ち~text~trackの~listを拡充-:~HTMLemb#populate-the-list-of-pending-text-tracks

~text~trackの~list:~HTMLemb#list-of-text-tracks
~text~track~cue作動中~flag:~HTMLemb#text-track-cue-active-flag
~text~track~cue:~HTMLemb#text-track-cue
~text~track読込失敗:~HTMLemb#text-track-failed-to-load
~text~track読込済み:~HTMLemb#text-track-loaded
~text~track読込中:~HTMLemb#text-track-loading
~text~track未読込み:~HTMLemb#text-track-not-loaded
~text~track準備度:~HTMLemb#text-track-readiness-state

mT.chapters:~HTMLemb#dom-texttrack-kind-chapters
~text~trackから~chapter木を構築する規則:~HTMLemb#rules-for-constructing-the-chapter-tree-from-a-text-track
blocked-on-parser:~HTMLemb#blocked-on-parser
~media資源に特有の~text~trackを公開する手続き:~HTMLemb#steps-to-expose-a-media-resource-specific-text-track


	●HTML
寸法~属性:~HEembed#dimension-attributes


相対的に構文解析-:~HTMLINFRA#parse-a-url
既知の値のみに制限され:~HTMLINFRA#limited-to-only-known-values
反映-:~HTMLINFRA#reflect
挿入され:~HTMLINFRA#nodes-are-inserted
文書から除去され:~HTMLINFRA#remove-an-element-from-a-document
~CORS設定群~属性:~HTMLINFRA#cors-settings-attribute
~CORSになり得る要請を作成-:~HTMLINFRA#create-a-potential-cors-request
~CORS同一生成元:~HTMLINFRA#cors-same-origin
~CORS非同一生成元:~HTMLINFRA#cors-cross-origin
非安全~応答:~HTMLINFRA#unsafe-response
~Content-Type~metadata:~HTMLINFRA#content-type
即時:~HTMLINFRA#immediately
並列的:~HTMLINFRA#in-parallel
新たな~Date~obj:~HTMLINFRA#create-a-date-object
結果の~URL~record:~HTMLINFRA#resulting-url-record
結果の~URL文字列:~HTMLINFRA#resulting-url-string
前後~空白~可の妥当かつ空でない~URL:~HTMLINFRA#valid-non-empty-url-potentially-surrounded-by-spaces

真偽~属性:~HTMLcms#boolean-attribute
列挙ed属性:~HTMLcms#enumerated-attribute
妥当でない値に対する既定の状態:~HTMLcms#invalid-value-default
値なしに対する既定の状態:~HTMLcms#missing-value-default

分類:~HTMLdom#concept-element-categories
内容~属性:~HTMLdom#concept-element-attributes
内容~model:~HTMLdom#concept-element-content-model
この要素を利用できる文脈:~HTMLdom#concept-element-contexts
~DOM~interface:~HTMLdom#concept-element-dom
埋込みの内容:~HTMLdom#embedded-content-category
~flow内容:~HTMLdom#flow-content-2
大域~属性:~HTMLdom#global-attributes
対話的~内容:~HTMLdom#interactive-content-2
なし:~HTMLdom#concept-content-nothing
可触~内容:~HTMLdom#palpable-content-2
句内容:~HTMLdom#phrasing-content-2
text/html における~tag省略:~HTMLdom#concept-element-tag-omission
表現-:~HTMLdom#represents
透過的な内容:~HTMLdom#transparent

結付けられている文書:~BROWSERS#concept-document-window
全部的に作動中:~BROWSERS#fully-active
作動中の~sandbox用~flag集合:~BROWSERS#active-sandboxing-flag-set
閲覧文脈~sandbox化( 自動~特色機能 )~flag:~BROWSERS#sandboxed-automatic-features-browsing-context-flag
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context


具現化され:~HTMLrendering#being-rendered
具現化~節にて示唆される~style規則:~HTMLrendering#video-object-fit

現在の大域~obj:~WAPI#current-global-object
環境~設定群~obj:~WAPI#environment-settings-object
~event-loop:~WAPI#event-loop
最初の段:~WAPI#step1
~task:~WAPI#concept-task
~task源:~WAPI#task-source
~network用~task源:~WAPI#networking-task-source
~task待行列:~WAPI#task-queue
~taskを待入する:~WAPI#queue-a-task
~taskを待入し:~WAPI#queue-a-task
待入され:~WAPI#queue-a-task
同期区間:~WAPI#synchronous-section
安定~状態を待受ける:~WAPI#await-a-stable-state
~scriptingは不能化され:~WAPI#concept-n-noscript

利用者による作動化から誘発されて:~HTMLinteraction#triggered-by-user-activation

終了tag:~HTMLwriting#syntax-end-tag
~load~eventを遅延-:~HTMLsyntax#delay-the-load-event


	●他
~HTML名前空間:~INFRA#html-namespace

~fetch:~FETCH#concept-fetch
要請:~FETCH#concept-request
rq.~client:~FETCH#concept-request-client
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.行先:~FETCH#concept-request-destination
rq.種別:~FETCH#concept-request-type
rq.~url:~FETCH#concept-request-url
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag

文書~内:~DOM4#in-a-document
属性~値を設定-:~DOM4#concept-element-attributes-set-value
新たな要素:~DOM4#concept-create-element
~eventを発火-:~DOM4#concept-event-fire
発火-:~DOM4#concept-event-fire
~node文書:~DOM4#concept-node-document
最初の子:~DOM4#concept-tree-first-child
	木~順序:~DOM4#concept-tree-order
次の同胞:~DOM4#concept-tree-next-sibling
前の同胞:~DOM4#concept-tree-previous-sibling

~URL:~URLSpec#concept-url
~URL直列化器:~URLSpec#concept-url-serializer
url.~obj:~URLSpec#concept-url-object
url.素片:~URLSpec#concept-url-fragment

~chapter~title~textを利用する~WebVTT~file:~WEBVTT#webvtt-file-using-chapter-title-text
~cue~textを利用する~WebVTT~file:~WEBVTT#webvtt-file-using-cue-text
入子の~cueのみを利用する~WebVTT~file:~WEBVTT#webvtt-file-using-only-nested-cues
~WebVTT-file:~WEBVTT#webvtt-file

~detach:https://w3c.github.io/media-source/#mediasource-detach

css.px:~CSSVAL#px
	~CSS~pixel:~CSSVAL#px
既定の~obj~size:~CSSIMAGE#default-object-size
内在的~寸法:~CSS2CONFORM#intrinsic
内在的~横幅:~CSS2CONFORM#intrinsic
内在的~縦幅:~CSS2CONFORM#intrinsic
内在的~size:~CSS2CONFORM#intrinsic
表示域:~CSS2VISUREN#viewport
塗り~source:~CSSIMAGE4#paint-source

	●
~MIME型:~MIMESNIFF#mime-type
音声／動画を特に~sniffする規則:~MIMESNIFF#rules-for-sniffing-audio-and-video-specifically
	妥当な~MIME型:~MIMESNIFF#valid-mime-type
~media素片の構文:https://www.w3.org/TR/media-frags/#media-fragment-syntax
</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
WEBVTT:https://w3c.github.io/webvtt/
此れ:<b>これ°</b>

errorM:error
errorS:error
errorT:error
codecs:<code class="production">codecs</code>

</script>

<!--%style -->
<style type="text/css">

.js-value {
	color: green;
}

</style>

<!--%HTML見本 -->
<script type="text/plain" id="_html_code_list">

</script>

</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML — video, audio, track 要素 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Embedded content</a>
章の， video, audio, track 要素に関係する節を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-05-06</time>
（公開：<time>2017-04-02</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">
	<hgroup>
<h1>video, audio, track 要素</h1>
<h2>HTML Living Standard — 最終更新 2017 年 4 月 18 日</h2>
	</hgroup>

</header>

<main id="MAIN" style="display:none;">

			<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoの記述に利用されている各種記号（ε, 此れ, ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

			</section>
			<section id="the-source-element">
<h3 title="The source element">4.8.2. `source^e 要素</h3>

<p class="trans-note">【
この節では、原文のこの節における`~media要素$のみに関わる部分を述べる。
他の内容は、<a href="~HEimages#the-source-element" >別ページ</a>にて。
】</p>

<p>
`source$e 要素 %source の親が`~media要素$である場合、以下に述べる要件も課される：
◎
The remainder of the requirements depend on whether the parent is a picture element or a media element:
◎
• source element's parent is a media element
</p>

<ul>
	<li>
<p>
%source の
`src@aS
属性は、`~media資源$の`~URL$を与える。
その値は、`前後~空白~可の妥当かつ空でない~URL$で~MUST。
%source はこの属性を有して~MUST。
◎
The src attribute gives the URL of the media resource. The value must be a valid non-empty URL potentially surrounded by spaces. This attribute must be present.
</p>

<p class="note">注記：
%source が
`video$e ／ `audio$e
要素~内にすでに挿入されている場合、
%source とその属性を動的に改変しても，効果はない。
何を再生しているかを変更するためには、`~media要素$上の `src$aM 属性だけを 直接的に利用するか，場合によっては `canPlayType()$mM ~methodを用立てて、可用な資源たちから一つ選び取ること。
一般に，文書が構文解析された後に %source を手動で操作するのは、不必要に複雑な~~手法である。
◎
Dynamically modifying a source element and its attribute when the element is already inserted in a video or audio element will have no effect. To change what is playing, just use the src attribute on the media element directly, possibly making use of the canPlayType() method to pick from amongst available resources. Generally, manipulating source elements manually after the document has been parsed is an unnecessarily complicated approach.
</p>

	</li>
	<li>

<p>
%source の `type$aS 属性は、`~media資源$の型を与える
— それは、~UAが，当の`~media資源$を~fetchする前に再生できるかどうか決定するのを助けるためにある。
ある種の~MIME型は、 `codecs^v ~parameterを定義する
— それは、資源がどう符号化されたかを正確に指定するため，必要とされる場合もある。
`RFC6381$r
◎
The type attribute gives the type of the media resource, to help the user agent determine if it can play this media resource before fetching it. The codecs parameter, which certain MIME types define, might be necessary to specify exactly how the resource is encoded. [RFC6381]
</p>

<div class="example">
<p>
以下に、 `type$aS 属性における `codecs=^v ~MIME~parameterの用例をいくつか挙げる：
◎
The following list shows some examples of how to use the codecs= MIME parameter in the type attribute.
</p>

<dl>
	<dt>
~MP4容器~内の［
H.264 Constrained baseline ~profile動画（ `main^pf, および `extended^pf 動画に互換） ~level 3
＆
Low-Complexity AAC 音声
］
◎
H.264 Constrained baseline profile video (main and extended video compatible) level 3 and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'^tag
</dd>

	<dt>
~MP4容器~内の［
 H.264 Extended~profile動画（ `baseline^pf に互換）~level 3
＆
 Low-Complexity AAC 音声
］
◎
H.264 Extended profile video (baseline-compatible) level 3 and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="avc1.58A01E, mp4a.40.2"'^tag
</dd>

	<dt>
~MP4容器~内の［
 H.264 Main ~profile動画~level 3
＆
 Low-Complexity AAC 音声
］
◎
H.264 Main profile video level 3 and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="avc1.4D401E, mp4a.40.2"'^tag
</dd>

	<dt>
~MP4容器~内の［
 H.264 'High' ~profile動画（［
`main^pf ／ `baseline^pf／ `extended^pf
］~profileとは非~互換）~level 3
＆
Low-Complexity AAC 音声
］
◎
H.264 'High' profile video (incompatible with main, baseline, or extended profiles) level 3 and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="avc1.64001E, mp4a.40.2"'^tag
</dd>

	<dt>
~MP4容器~内の［
MPEG-4 Visual Simple Profile Level 0 動画
＆
Low-Complexity AAC 音声
］
◎
MPEG-4 Visual Simple Profile Level 0 video and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="mp4v.20.8, mp4a.40.2"'^tag
</dd>

	<dt>
~MP4容器~内の［
MPEG-4 Advanced Simple Profile Level 0 動画
＆
Low-Complexity AAC 音声
］
◎
MPEG-4 Advanced Simple Profile Level 0 video and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="mp4v.20.240, mp4a.40.2"'^tag
</dd>

	<dt>
3GPP 容器~内の［
 MPEG-4 Visual Simple Profile Level 0 動画
＆
 AMR 音声
］
◎
MPEG-4 Visual Simple Profile Level 0 video and AMR audio in 3GPP container
</dt>
	<dd>
`source src='video.3gp' type='video/3gpp; codecs="mp4v.20.8, samr"'^tag
</dd>

	<dt>
~Ogg容器~内の［
Theora 動画
＆
Vorbis 音声
］
◎
Theora video and Vorbis audio in Ogg container
</dt>
	<dd>
`source src='video.ogv' type='video/ogg; codecs="theora, vorbis"'^tag
</dd>

	<dt>
~Ogg容器~内の［
Theora 動画
＆
Speex 音声
］
◎
Theora video and Speex audio in Ogg container
</dt>
	<dd>
`source src='video.ogv' type='video/ogg; codecs="theora, speex"'^tag
</dd>

	<dt>
~Ogg容器~内の［
動画なし
＆
Vorbis 音声
］
◎
Vorbis audio alone in Ogg container
</dt>
	<dd>
`source src='audio.ogg' type='audio/ogg; codecs=vorbis'^tag
</dd>

	<dt>
~Ogg容器~内の［
動画なし
＆
Speex 音声
］
◎
Speex audio alone in Ogg container
</dt>
	<dd>
`source src='audio.spx' type='audio/ogg; codecs=speex'^tag
</dd>

	<dt>
~Ogg容器~内の［
動画なし
＆
FLAC 音声
］
◎
FLAC audio alone in Ogg container
</dt>
	<dd>
`source src='audio.oga' type='audio/ogg; codecs=flac'^tag
</dd>

	<dt>
~Ogg容器~内の［
Dirac 動画
＆
 Vorbis 音声
］
◎
Dirac video and Vorbis audio in Ogg container
</dt>
	<dd>
`source src='video.ogv' type='video/ogg; codecs="dirac, vorbis"'^tag
</dd>
</dl>

</div>

	</li>
	<li>
%source は、［
`srcset$aS ／ `sizes$aS ／ `media$aS
］属性を有しては~MUST_NOT。
◎
The srcset, sizes, and media attributes must not be present.
</li>
</ul>

<p>
`source$e 要素 が次を満たす`~media要素$ %M の子として `挿入され$たときは、~UAは， %M の`資源~選定~algo$を呼出さ~MUST
⇒
［
%M は `src$aM 属性を有さない
］~AND［
%M の `networkState$mM の値 ~EQ `NETWORK_EMPTY$mM
］
◎
If a source element is inserted as a child of a media element that has no src attribute and whose networkState has the value NETWORK_EMPTY, the user agent must invoke the media element's resource selection algorithm.
</p>

<dl class="idl-def">
	<dt>`src@m</dt>
	<dd>
対応する同じ名前の内容~属性を`反映-$し~MUST。
◎
The IDL attributes src, type, srcset, sizes and media must reflect the respective content attributes of the same name.
</dd>
</dl>

<div class="example">

<p>
作者は、提供した~media資源すべてを ~UAが具現化できるかどうか定かでない場合には、最後の `source$e 要素~上で `error$et ~eventを~listenすれば，~fallback用の挙動を誘発できる：
◎
If the author isn't sure if user agents will all be able to render the media resources provided, the author can listen to the error event on the last source element and trigger fallback behavior:
</p>

<pre class="html-code">
&lt;script&gt;
 function fallback(%video) {
   /* <span class="comment">
`video$e をその内容に置換する
◎
replace &lt;video&gt; with its contents
</span> */
   while (%video.hasChildNodes()) {
     if (%video.firstChild instanceof HTMLSourceElement)
       %video.removeChild(%video.firstChild);
     else
       %video.parentNode.insertBefore(%video.firstChild, %video);
   }
   %video.parentNode.removeChild(%video);
 }
&lt;/script&gt;
&lt;video controls autoplay&gt;
 &lt;source src='video.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'&gt;
 &lt;source src='video.ogv' type='video/ogg; codecs="theora, vorbis"'
         onerror="fallback(parentNode)"&gt;
 ...
&lt;/video&gt;
</pre>

</div>

			</section>
			<section id="the-video-element">
<h3 title="The video element" id="video">4.8.9. `video^e 要素</h3>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$／`句内容$／`埋込みの内容$／［
要素が `controls$aM 属性を有する場合に限り，
`対話的~内容$
］／`可触~内容$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
If the element has a controls attribute: Interactive content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込みの内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
<p>
次の順による並び：
</p>
<ol ><li>要素が `src$aM 属性を有さない場合に限り， 0 個以上の `source$e 要素
</li><li>0 個以上の `track$e 要素
</li><li>`透過的な内容$
</li></ol>
<p>
ただし，子孫に`~media要素$は含まないとする。
</p>
◎
If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.
◎
If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`src$aM
— 資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`crossorigin$aM
— 要素が非同一生成元~要請をどう取扱うか
◎
crossorigin — How the element handles crossorigin requests
</dd>
	<dd>
`poster$aV
— 動画~再生に先立って示す~poster~frame
◎
poster — Poster frame to show prior to video playback
</dd>
	<dd>
`preload$aM
— `~media資源$に必要と見込まれる~buffer量の~hintを与える
◎
preload — Hints how much buffering the media resource will likely need
</dd>
	<dd>
`autoplay$aM
— 頁が読込まれ次第，`~media資源$を自動的に開始できるかどうかの~hintを与える
◎
autoplay — Hint that the media resource can be started automatically when the page is loaded
</dd>
	<dd>
`playsinline$aV
— 要素の再生~区画の中に動画~内容を表示するよう，~UAに促す
◎
playsinline — Encourage the user agent to display video content within the element's playback area
</dd>
	<dd>
`loop$aM
— `~media資源$を~loopするかどうか
◎
loop — Whether to loop the media resource
</dd>
	<dd>
`muted$aM
— `~media資源$を既定で消音するかどうか
◎
muted — Whether to mute the media resource by default
</dd>
	<dd>
`controls$aM
— ~UA~controlを示す
◎
controls — Show user agent controls
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[`HTMLConstructor$]
interface `HTMLVideoElement@I : `HTMLMediaElement$I {
  [`CEReactions$] attribute unsigned long `width$m;
  [`CEReactions$] attribute unsigned long `height$m;
  readonly attribute unsigned long `videoWidth$mV;
  readonly attribute unsigned long `videoHeight$mV;
  [`CEReactions$] attribute USVString `poster$mV;
  [`CEReactions$] attribute boolean `playsInline$mV;
};
</pre>
	</dd>
</dl>

<p>
`video$e 要素は
動画や映画, および
~captionを伴う音声~file
を再生するために利用される。
◎
A video element is used for playing videos or movies, and audio files with captions.
</p>

<p>
内容
`video$e 要素の内側に提供されてもよい。
~UAは、この内容を利用者に示すべきでない
— それは `video$e を~supportしない旧~Web~browser向けに［
旧来の動画~pluginを試行できるよう，あるいは
その利用者に当の動画~内容に~accessする方法を伝える~textを示す
］ためとして意図されている。
◎
Content may be provided inside the video element. User agents should not show this content to the user; it is intended for older Web browsers which do not support video, so that legacy video plugins can be tried, or to show text to the users of these older browsers informing them of how to access the video contents.
</p>

<p class="note">注記：
特に，この内容は~accessibilityの懸念に取組むために意図されるものではない。
［
視覚／聴覚
において，部分的または全部的に, 物理的または認知的な障害
］を抱える利用者~向けに 動画~内容を~access可能にするための，様々な特色機能が可用である。
［
~caption／手話~track／音述
］は、動画~stream内に埋込める。
~captionは、 `track$e 要素を用いて 外部~fileとして提供することもできる。
音述は、 `track$e 要素を用いて，~UAにより発話に合成される~textを内容とする`~WebVTT-file$を参照して埋込める。
~WebVTTは、~chapter~titleを提供するためにも利用できる。
~media要素をまったく利用しない利用者~向けには、単純に，音声転写その他の~textual代替への~linkを `video$e 要素~周りの注釈文に提供できる。
`WEBVTT$r
◎
In particular, this content is not intended to address accessibility concerns. To make video content accessible to the partially sighted, the blind, the hard-of-hearing, the deaf, and those with other physical or cognitive disabilities, a variety of features are available. Captions can be provided, either embedded in the video stream or as external files using the track element. Sign-language tracks can be embedded in the video stream. Audio descriptions can be embedded in the video stream or in text form using a WebVTT file referenced using the track element and synthesized into speech by the user agent. WebVTT can also be used to provide chapter titles. For users who would rather not use a media element at all, transcripts or other textual alternatives can be provided by simply linking to them in the prose near the video element. [WEBVTT]
</p>

<p>
`video$e 要素は、表向きは動画~dataを`~media~data$とする`~media要素$であり，場合によっては音声~dataが結付けられる。
◎
The video element is a media element whose media data is ostensibly video data, possibly with associated audio data.
</p>

<p>
［
`src$aM ／ `preload$aM ／ `autoplay$aM ／ `loop$aM ／ `muted$aM ／ `controls$aM
］属性は、`すべての~media要素に共通する属性$である。
◎
The src, preload, autoplay, loop, muted, and controls attributes are the attributes common to all media elements.
</p>

<p>
`poster@aV
属性は、動画~dataが可用でない間に~UAが示せる画像~fileの`~URL$を与える。
指定する値は、`前後~空白~可の妥当かつ空でない~URL$で~MUST。
◎
The poster attribute gives the URL of an image file that the user agent can show while no video data is available. The attribute, if present, must contain a valid non-empty URL potentially surrounded by spaces.
</p>

<p class="algo-head">
`video$e 要素 %video に指定された資源が利用されることになる場合、［
%video の作成-時 ／
%video の `poster$aV 属性が［
設定- ／ 変更- ／ 除去-
］されたときには，~UAは
%video の
`~poster~frame@
を次を走らせた結果にし~MUST（ %video は`~posterを示して$いようがいまいが）（結果の ε は、`~poster~frame$はないことを表す）：
◎
If the specified resource is to be used, then, when the element is created or when the poster attribute is set, changed, or removed, the user agent must run the following steps to determine the element's poster frame (regardless of the value of the element's show poster flag):
</p> 

<ol>
	<li>
~IF［
%video に対し走らせているこの~algoの
既存の~instanceがある
］
⇒
その~instanceを中止する（`~poster~frame$は変更せずに）
◎
If there is an existing instance of this algorithm running for this video element, abort that instance of this algorithm without changing the poster frame.
</li>
	<li>
%poster ~LET %video は `poster$aV 属性を［
有するならば その値 ／
有さないならば ε
］
</li>
	<li>
~IF［
%poster ~IN { ε, 空~文字列 }
］
⇒
~RET ε
◎
If the poster attribute's value is the empty string or if the attribute is absent, then there is no poster frame; abort these steps.
</li>
	<li>
%url ~LET %poster を要素の`~node文書$に`相対的に構文解析-$した`結果の~URL~record$
</li>
	<li>
~IF［
%url ~EQ ~error 
］
⇒
~RET ε
◎
Parse the poster attribute's value relative to the element's node document. If this fails, then there is no poster frame; abort these steps.
</li>
	<li>
<p>
%要請 ~LET 次のようにされた新たな`要請$：
</p>

<ul><li>`~url$rq ~SET %url
</li><li>`~client$rq ~SET 要素の`~node文書$の `Window$I ~objの`環境~設定群~obj$
</li><li>`種別$rq ~SET `image^l
</li><li>`行先$rq ~SET `image^l
</li><li>`資格証~mode$rq ~SET `include^l
</li><li>`~URL資格証~利用~flag$rq ~SET ~ON
</li></ul>

◎
Let request be a new request whose url is the resulting URL record, client is the element's node document's Window object's environment settings object, type is "image", destination is "image", credentials mode is "include", and whose use-URL-credentials flag is set.
</li>
	<li>
%要請 を`~fetch$する
— これは、 %video の`~node文書$の`~load~eventを遅延-$し~MUST
◎
Fetch request. This must delay the load event of the element's node document.
</li>
	<li>
~IF［
何らかの画像が得られた
］
⇒
~RET その画像
◎
↓</li>
	<li>
~RET ε
◎
If an image is thus obtained, the poster frame is that image. Otherwise, there is no poster frame.
</li>
</ol>

<p class="note">注記：
`poster$aV 属性が与える`~poster~frame$は、どの様な動画なのか見当を利用者に与える，動画の代表~frameになることが意図される（概して，最初の方にある空内容でない~frame）
◎
The image given by the poster attribute, the poster frame, is intended to be a representative frame of the video (typically one of the first non-blank frames) that gives the user an idea of what the video is like.
</p>

<p>
`playsinline@aV
は、`真偽~属性$である。
在するならば、その動画は，既定では文書~内に “~inline” に表示されるべき
— ［
全~screenに, あるいは 独立かつ~resize可能な~window内に
］ではなく，要素の再生~区画に拘束される下で表示される —
ことを，~UAに~~指示する~hintとして~~働く。
◎
The playsinline is a boolean attribute. If present, it serves as a hint to the user agent that the video ought to be displayed "inline" in the document by default, constrained to the element's playback area, instead of being displayed fullscreen or in an independent resizable window.
</p>

<p class="note">注記：
`playsinline$aV の不在が、動画は既定で全~screenに表示することを含意するわけではない。
~~実際、ほとんどの~UAは，すべての動画を既定で~inlineに再生することを選んでおり、そのような~UAにおいては `playsinline$aV 属性の効果はない。
◎
The absence of the playsinline does not imply that the video will display fullscreen by default. Indeed, most user agents have chosen to play all videos inline by default, and in such user agents the playsinline attribute has no effect.
</p>

<hr>

<p class="algo-head">
`video$e 要素 %video が所与の時点で表現するものは、その時点で次を走らせた結果として定義される：
◎
A video element represents what is given for the first matching condition in the list below:
</p>

<ol>
	<li>
%readyState ~LET %video の`readyState$mM 属性
</li>
	<li>
%~poster ~LET %video の`~poster~frame$
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる（すなわち，可用な動画~dataはない）
］…：
</p>

<ul ><li>%readyState ~EQ `HAVE_NOTHING$mM
</li><li>［
%readyState ~EQ `HAVE_METADATA$mM
］~AND［
動画~dataはまったく得られてない
］
</li><li>［
%readyState ~NIN { `HAVE_NOTHING$mM, `HAVE_METADATA$mM } 
］~AND［
%video の`~media資源$に動画~channelはない
］］
</li></ul>

<p>
…ならば
⇒
~RET ［
%~poster ~NEQ ε ならば %~poster ／
~ELSE_ `内在的~寸法$を伴わない透明な黒
］
</p>
◎
When no video data is available (the element's readyState attribute is either HAVE_NOTHING, or HAVE_METADATA but no video data has yet been obtained at all, or the element's readyState attribute is any subsequent value but the media resource does not have a video channel)
◎
• The video element represents its poster frame, if any, or else transparent black with no intrinsic dimensions.
</li>
	<li>
~Assert：
%video の`~media資源$に動画~channelはある
</li>
	<li>
%paused ~LET %video の `paused$mM
◎
↓</li>
	<li>
%描画済み~frame ~LET 最後に描画された動画の~frame
◎
↓</li>
	<li>
%現~frame ~LET ［
`現在の再生~位置$に対応する動画の~frameが可用なら それ ／
~ELSE_ ε
］
◎
↓</li>
	<li>
<p>
~IF［
%paused ~EQ ~T
］：
</p>
		<ol>
			<li>
~IF［
%現~frame は動画の最初の~frameである
］~AND［
%video は`~posterを示して$いる
］~AND［
%~poster ~NEQ ε
］
⇒
~RET %~poster
</li>
			<li>
~IF［
%現~frame ~NEQ ε
］
⇒
~RET %現~frame
</li>
			<li>
~RET %描画済み~frame（例： 動画は~seek中か~buffer中にある）
</li>
		</ol>

◎
When the video element is paused, the current playback position is the first frame of video, and the element's show poster flag is set
◎
• The video element represents its poster frame, if any, or else the first frame of the video.
◎
When the video element is paused, and the frame of video corresponding to the current playback position is not available (e.g. because the video is seeking or buffering)
◎
↓When the video element is neither potentially playing nor paused (e.g. when seeking or stalled)
◎
• The video element represents the last frame of the video to have been rendered.
◎
When the video element is paused
◎
• The video element represents the frame of video corresponding to the current playback position.
</li>
	<li>
~ELIF［
%video は`再生-中であり得る$でない（例：~seek中か~stallしたとき）
］
⇒
~RET %描画済み~frame
◎
↑</li>
	<li>
~RET %現~frame
（ %video には動画~channelがあって`再生-中であり得る$）
— %video は，絶え間なく~~更新され続ける`現在の再生~位置$にある動画の~frameを`表現-$する。
`現在の再生~位置$が変化して，%描画済み~frame が動画~内の`現在の再生~位置$に対応する~frameでなくなったときは、新たな~frameが描画され~MUST。
◎
Otherwise (the video element has a video channel and is potentially playing)
◎
The video element represents the frame of video at the continuously increasing "current" position. When the current playback position changes such that the last frame rendered is no longer the frame corresponding to the current playback position in the video, the new frame must be rendered.
</li>
</ol>

<p>
動画の~frameは、`~event-loop$が最後に`最初の段$に達した時点で`選定-済みの動画~track$から得られ~MUST。
◎
Frames of video must be obtained from the video track that was selected when the event loop last reached step 1.
</p>

<p class="note">注記：
特定0の再生~位置に 動画~stream内のどの~frameが対応するかは、動画~streamの形式により定義される。
◎
Which frame in a video stream corresponds to a particular playback position is defined by the video stream's format.
</p>

<div class="p">
<p>
`video$e 要素は、上述に加え，次のものも`表現-$する：
</p>

<ul>
	<li>
<p>
次の両者を満たす`~text~track~cue$があれば それ：
</p>
<ul><li>`~text~track~cue作動中~flag$ ~EQ ~ON
</li><li>`~text~track$は`~showing$tT~modeにある
</li></ul>
	</li>
	<li>
`現在の再生~位置$にある`~media資源$からの音声があれば それ
</li>
</ul>

◎
The video element also represents any text track cues whose text track cue active flag is set and whose text track is in the showing mode, and any audio from the media resource, at the current playback position.
</div>

<p>
`~media資源$に結付けられている音声が再生される場合は、`現在の再生~位置$に同期するように，要素の`実効~media音量$で再生され~MUST。
~UAは、［
`~event-loop$が最後に`最初の段$に達した時点で，
<a href="~HTMLemb#dom-audiotrack-enabled">可能化されている</a>
音声~track
］からの音声を再生し~MUST。
◎
Any audio associated with the media resource must, if played, be played synchronized with the current playback position, at the element's effective media volume. The user agent must play the audio from audio tracks that were enabled when the event loop last reached step 1.
</p>

<p>
上に加えて、~UAは，利用者に~message（
 “~buffer中”, “動画まだ読込まれてない”, “~error”
 など，より詳細な情報）を提供してよい
— ~textや~iconを動画や他の要素の再生~区画~上に積層する，あるいは別の適切な方式で。
◎
In addition to the above, the user agent may provide messages to the user (such as "buffering", "no video loaded", "error", or more detailed information) by overlaying text or icons on the video or other areas of the element's playback area, or in another appropriate manner.
</p>

<p>
動画を描画できない~UAは、要素が［
外部の動画~再生~utility ／ 動画~data自体
］への~linkを`表現-$するようにしてもよい。
◎
User agents that cannot render the video may instead make the element represent a link to an external video playback utility or to the video data itself.
</p>

<div class="p">
<p>
`video$e 要素の`~media資源$に動画~channelがある場合、要素は，次のような`塗り~source$を提供する：
</p>
<ul>
	<li>
( 横幅, 縦幅 ) は`~media資源$の ( `内在的~横幅$vD, `内在的~縦幅$vD )
</li>
	<li>
外観は ［
`現在の再生~位置$に対応する動画の~frameが可用ならば それ ／
~ELSE_（例：動画は~seek中か~buffer中）その前の外観があれば それ ／
~ELSE_（例：動画はまだ最初の~frameの読込中にある）黒一色
］
</li>
</ul>
◎
When a video element's media resource has a video channel, the element provides a paint source whose width is the media resource's intrinsic width, whose height is the media resource's intrinsic height, and whose appearance is the frame of video corresponding to the current playback position, if that is available, or else (e.g. when the video is seeking or buffering) its previous appearance, if any, or else (e.g. because the video is still loading the first frame) blackness.
</div>


<hr>

<dl class="domintro">
	<dt>%video . `videoWidth$mV</dt>
	<dt>%video . `videoHeight$mV</dt>
	<dd>
これらの属性は、［
寸法が既知ならば動画の内在的~寸法 ／
~ELSE_ 0
］を返す。
◎
These attributes return the intrinsic dimensions of the video, or zero if the dimensions are not known.
</dd>
</dl>

<p>
`~media資源$の
`内在的~横幅@vD
／
`内在的~縦幅@vD
は、その資源に利用されている形式により定義される［
資源の寸法,
縦横比,
clean aperture†,
解像度,
等々
］を織り込んだ後の時点での，
`px$css による資源の寸法とする。
anamorphic 形式††が，［
“正しい” 寸法に~~復元するための，縦横比を動画~dataの寸法に適用する方法
］を定義していない場合、~UAは、一方の寸法は変えないまま他方の寸法を増やすことにより，縦横比を適用し~MUST。
◎
The intrinsic width and intrinsic height of the media resource are the dimensions of the resource in CSS pixels after taking into account the resource's dimensions, aspect ratio, clean aperture, resolution, and so forth, as defined for the format used by the resource. If an anamorphic format does not define how to apply the aspect ratio to the video data's dimensions to obtain the "correct" dimensions, then the user agent must apply the ratio by increasing one dimension and leaving the other unchanged.
</p>

<p class="trans-note">【†
動画の符号化処理の都合により縁に現れる “ゴミ” が見えなくなるよう切り落とすための， “きれいな” 区画。
】【††
円柱レンズで縦横いずれかの方向に圧縮して撮影された形式の動画
】</p>


<dl class="idl-def">
	<dt>`videoWidth@mV</dt>
	<dt>`videoHeight@mV</dt>
	<dd>
これらの取得子は，［
要素の `readyState$mM 属性 ~EQ `HAVE_NOTHING$mM
］の場合は 0 ／
~ELSE_ `px$css 単位による動画の［
`内在的~横幅$vD, `内在的~縦幅$vD
］（同順）を返さ~MUST。
◎
The videoWidth IDL attribute must return the intrinsic width of the video in CSS pixels. The videoHeight IDL attribute must return the intrinsic height of the video in CSS pixels. If the element's readyState attribute is HAVE_NOTHING, then the attributes must return 0.
</dd>
</dl>

<p id="dimUpdate">
動画の［
`内在的~横幅$vD ／ `内在的~縦幅$vD
］が変化したときは（例えば，`選定-済みの動画~track$が変化したときも含め）、~UAは次を走らせ~MUST
⇒
~IF［
要素の `readyState$mM 属性 ~NEQ `HAVE_NOTHING$mM
］
⇒
次を走らす`~taskを待入する$
⇒
`~media要素$に向けて，名前 `resize$et の`~eventを発火-$する
◎
Whenever the intrinsic width or intrinsic height of the video changes (including, for example, because the selected video track was changed), if the element's readyState attribute is not HAVE_NOTHING, the user agent must queue a task to fire an event named resize at the media element.
</p>

<p>
`video$e 要素は、`寸法~属性$を~supportする。
◎
The video element supports dimension attributes.
</p>

<p>
~style規則が不在の下であっても、動画~内容は，［
その縦横比は保全しつつ，要素の再生~区画に完全に収まるような最大の~sizeで、区画の中央に示される
］ように描画されるべきである。
したがって，要素の再生~区画と動画とで縦横比が合致しない場合、再生~区画~内に動画が占めない部位が生じることになる
— その部位は何も表現しない。
◎
In the absence of style rules to the contrary, video content should be rendered inside the element's playback area such that the video content is shown centered in the playback area at the largest possible size that fits completely within it, with the video content's aspect ratio being preserved. Thus, if the aspect ratio of the playback area does not match the aspect ratio of the video, the video will be shown letterboxed or pillarboxed. Areas of the element's playback area that do not contain the video represent nothing.
</p>

<p class="note">注記：
~CSSを実装する~UAにおいては、上の要件は，`具現化~節にて示唆される~style規則$を用いて実装できる。
◎
In user agents that implement CSS, the above requirement can be implemented by using the style rule suggested in the rendering section.
</p>

<p>
`video$e 要素の再生~区画の［
`内在的~横幅$, `内在的~縦幅$
］は：
◎
↓</p>

<ul>
	<li>
横幅は、［
`~poster~frame$の`内在的~横幅$が可用, かつ要素は~poster~frameを現在`表現-$しているならば それ ／
~ELSE_ 動画~資源の`内在的~横幅$vDが可用ならば それ ／
~ELSE_ ε（なし）
］とする。
◎
The intrinsic width of a video element's playback area is the intrinsic width of the poster frame, if that is available and the element currently represents its poster frame; otherwise, it is the intrinsic width of the video resource, if that is available; otherwise the intrinsic width is missing.
</li>
	<li>
縦幅は、横幅を縦幅に読み替える下で，横幅のときと同様とする。
◎
The intrinsic height of a video element's playback area is the intrinsic height of the poster frame, if that is available and the element currently represents its poster frame; otherwise it is the intrinsic height of the video resource, if that is available; otherwise the intrinsic height is missing.
</li>
</ul>

<p>
`既定の~obj~size$は、 `px$css 単位で
横幅 300, 縦幅 150
とする。
`CSSIMAGES$r
◎
The default object size is a width of 300 CSS pixels and a height of 150 CSS pixels. [CSSIMAGES]
</p>

<p>
`video$e 要素は、次を満たすならば
`表示域に交差-@
しているとされる
⇒
要素は`具現化され$ている ~AND
要素に結付けらている~CSS~layout~boxは`表示域$に交差している
◎
A video element is said to intersect the viewport when it is being rendered and its associated CSS layout box intersects the viewport.
</p>

<hr>

<p>
~UAは［
開閉可能な~caption, 音述~track,
動画~streamに結付けられている他の追加の~data
］の表示の［
可能化-／不能化-
］を制御する~controlを提供するべきである
— そのような特色機能もまた、頁の通常の描画には干渉しないべきである。
◎
User agents should provide controls to enable or disable the display of closed captions, audio description tracks, and other additional data associated with the video stream, though such features should, again, not interfere with the page's normal rendering.
</p>

<p>
~UAは、利用者がより相応しい方式で動画~内容を見れるようにしてもよい
— ［
全~screenや 独立かつ~resize可能な~window
］内など。
~UAは、そのような視聴modeを動画の再生-時に既定で誘発してもよい
—  `playsinline$aV 属性が指定されているときは，そうするべきでないが。
他の~UI特色機能と同様，これを可能化する~controlは、~UAが`~UIを公開-$していない限り，頁の通常の描画に干渉するべきでない。
しかしながら，そのような独立的な視聴modeにおいては、~UAは，
`controls$aM 属性が不在でも全部的な~UIを可視にしてよい。
◎
User agents may allow users to view the video content in manners more suitable to the user, such as fullscreen or in an independent resizable window. User agents may even trigger such a viewing mode by default upon playing a video, although they should not do so when the playsinline attribute is specified. As with the other user interface features, controls to enable this should not interfere with the page's normal rendering unless the user agent is exposing a user interface. In such an independent viewing mode, however, user agents may make full user interfaces visible, even if the controls attribute is absent.
</p>

<p>
~UAは、動画~再生-時に利用者~体験を損ないかねない~system特色機能がある場合は、それを~~抑制してもよい
— 例えば~UAは、動画の再生が進捗-中にある間は，~screensaverを不能化することもできる。
◎
User agents may allow video playback to affect system features that could interfere with the user's experience; for example, user agents could disable screensavers while video playback is in progress.
</p>

<hr>

<dl class="idl-def">
	<dt>`poster@mV</dt>
	<dd>
`poster$aV 内容~属性を`反映-$し~MUST。
◎
The poster IDL attribute must reflect the poster content attribute.
</dd>

	<dt>`playsInline@mV</dt>
	<dd>
`playsinline$aV 内容~属性を`反映-$し~MUST。
◎
The playsInline IDL attribute must reflect the playsinline content attribute.
</dd>
</dl>

<div class="example">

<p>
動画を正しく再生するのに失敗したことを検出する方法の一例：
◎
This example shows how to detect when a video has failed to play correctly:
</p>

<pre class="html-code">
&lt;script&gt;
 function failed(%e) {
   /* <span class="comment">
動画の再生に失敗した
—  その原因についての~messageを示す
◎
video playback failed - show a message saying why
</span> */
   switch (%e.target.error.code) {
     case %e.target.error.MEDIA_ERR_ABORTED:
       alert('動画の再生を中止しましたね。');
       break;
     case %e.target.error.MEDIA_ERR_NETWORK:
       alert('~network~errorのため、動画~downloadの中途で失敗しました。');
       break;
     case %e.target.error.MEDIA_ERR_DECODE:
       alert('動画の再生を中止しました。動画~dataに問題があるか，動画はこの~browserが~supportしない特色機能を利用しています。');
       break;
     case %e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
       alert('~serverまたは~networkに問題があるか，形式が未~supportのため、動画を読込めませんでした。');
       break;
     default:
       alert('未知の~errorが生じました。');
       break;
   }
 }
&lt;/script&gt;
&lt;p&gt;&lt;video src="tgif.vid" autoplay controls onerror="failed(event)"&gt;&lt;/video&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="tgif.vid"&gt;Download the video file&lt;/a&gt;.&lt;/p&gt;
</pre>
<!-- 
<script>
 function failed(e) {
   // video playback failed - show a message saying why
   switch (e.target.error.code) {
     case e.target.error.MEDIA_ERR_ABORTED:
       alert('You aborted the video playback.');
       break;
     case e.target.error.MEDIA_ERR_NETWORK:
       alert('A network error caused the video download to fail part-way.');
       break;
     case e.target.error.MEDIA_ERR_DECODE:
       alert('The video playback was aborted due to a corruption problem or because the video used features your browser did not support.');
       break;
     case e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
       alert('The video could not be loaded, either because the server or network failed or because the format is not supported.');
       break;
     default:
       alert('An unknown error occurred.');
       break;
   }
 }
</script>
<p><video src="tgif.vid" autoplay controls onerror="failed(event)"></video></p>
<p><a href="tgif.vid">Download the video file</a>.</p>

-->

</div>



			</section>
			<section id="the-audio-element">
<h3 title="The audio element" id="audio">4.8.10. `audio^e 要素</h3>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$／`句内容$／`埋込みの内容$／［
要素が `controls$aM 属性を有する場合に限り，`対話的~内容$
］ ／［
要素が `controls$aM 属性を有する場合に限り，`可触~内容$
］
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
If the element has a controls attribute: Interactive content.
◎
If the element has a controls attribute: Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込みの内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
<p>
次の順による並び：
</p>
<ol ><li>要素が `src$aM 属性を有さない場合に限り， 0 個以上の `source$e 要素
</li><li>0 個以上の `track$e 要素
</li><li>`透過的な内容$
</li></ol>
<p>
ただし，子孫に`~media要素$は含まないとする。
</p>

◎
If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.
◎
If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`src$aM
— 資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`crossorigin$aM
— 要素が非同一生成元~要請をどう取扱うか
◎
crossorigin — How the element handles crossorigin requests
</dd>
	<dd>
`preload$aM
— `~media資源$に必要と見込まれる~buffer量の~hintを与える
◎
preload — Hints how much buffering the media resource will likely need
</dd>
	<dd>
`autoplay$aM
— 頁が読込まれ次第，`~media資源$を自動的に開始できるかどうかの~hintを与える
◎
autoplay — Hint that the media resource can be started automatically when the page is loaded
</dd>
	<dd>
`loop$aM
— `~media資源$を~loopするかどうか
◎
loop — Whether to loop the media resource
</dd>
	<dd>
`muted$aM
— `~media資源$を既定で消音するかどうか
◎
muted — Whether to mute the media resource by default
</dd>
	<dd>
`controls$aM
— ~UA~controlを示す
◎
controls — Show user agent controls
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[`HTMLConstructor$, NamedConstructor=`Audio$m(optional DOMString %src)]
interface `HTMLAudioElement@I : `HTMLMediaElement$I {};
</pre>
	</dd>
</dl>


<p>
`audio$e 要素は、音響または音声の~streamを`表現-$する。
◎
An audio element represents a sound or audio stream.
</p>

<p>
`audio$e 要素の内側に内容が提供されてもよい。
~UAは、この内容を利用者に示すべきでない
— それは `audio$e を~supportしない旧~Web~browser向けに［
旧来の音声~pluginを試行できるよう，あるいは
利用者に当の動画~内容に~accessする方法を伝える~textを示す
］ためとして意図されている。
◎
Content may be provided inside the audio element. User agents should not show this content to the user; it is intended for older Web browsers which do not support audio, so that legacy audio plugins can be tried, or to show text to the users of these older browsers informing them of how to access the audio contents.
</p>

<p class="note">注記：
特に，この内容は~accessibilityの懸念に取組むために意図されるものではない。
［
聴覚において，部分的または全部的に, 物理的または認知的な障害
］を抱える利用者~向けに 音声~内容を~access可能にするための，様々な特色機能が可用である。
~captionや手話~動画が可用なら、
`audio$e 要素に代えて `video$e 要素を利用して音声を再生すれば，利用者に視覚的~代替も供せるようになる。
`track$e 要素と `~WebVTT-file$を用いて~chapter~titleを提供すれば、~naviを援助できる。
当然ながら、単純に，音声転写その他の~textual代替への~linkを `audio$e 要素~周りの注釈文に提供することもできる。
`WEBVTT$r
◎
In particular, this content is not intended to address accessibility concerns. To make audio content accessible to the deaf or to those with other physical or cognitive disabilities, a variety of features are available. If captions or a sign language video are available, the video element can be used instead of the audio element to play the audio, allowing users to enable the visual alternatives. Chapter titles can be provided to aid navigation, using the track element and a WebVTT file. And, naturally, transcripts or other textual alternatives can be provided by simply linking to them in the prose near the audio element. [WEBVTT]
</p>

<p>
`audio$e 要素は、表向きは音声~dataを`~media~data$とする`~media要素$である。
◎
The audio element is a media element whose media data is ostensibly audio data.
</p>

<p>
［
`src$aM,
`preload$aM,
`autoplay$aM,
`loop$aM,
`muted$aM,
`controls$aM
］属性は、`すべての~media要素に共通する属性$である。
◎
The src, preload, autoplay, loop, muted, and controls attributes are the attributes common to all media elements.
</p>

<p>
`audio$e 要素が`再生-中であり得る$ときは、その音声~dataは，要素の`実効~media音量$で`現在の再生~位置$に同期するよう再生され~MUST。
~UAは、`~event-loop$が最後に`最初の段$に達した時点で可能化されている音声~trackからの音声を再生し~MUST。
◎
When an audio element is potentially playing, it must have its audio data played synchronized with the current playback position, at the element's effective media volume. The user agent must play the audio from audio tracks that were enabled when the event loop last reached step 1.
</p>

<p>
`audio$e 要素に対する音声は、`再生-中であり得る$ときを除き，再生されては~MUST_NOT。
◎
When an audio element is not potentially playing, audio must not play for the element.
</p>

<dl class="domintro">
	<dt>%audio = new `Audio( [ url ] )$m</dt>
	<dd>
新たな `audio$e 要素を返す。
%url 引数は、与えられていれば， `src$aM 属性に設定される。
◎
Returns a new audio element, with the src attribute set to the value passed in the argument, if applicable.
</dd>
</dl>

<dl>
	<dt>`Audio(src)@m</dt>
	<dd>
<p>
この構築子は、 `HTMLAudioElement$I ~objを作成する
（ `createElement()$m などの~DOMによる~factory~methodに加えて提供されている）。
被呼出時には、次の手続きを遂行し~MUST：
◎
A constructor is provided for creating HTMLAudioElement objects (in addition to the factory methods from DOM such as createElement()): Audio(src). When invoked, the constructor must perform the following steps:
</p>

		<ol>
			<li>
%文書 ~LET `現在の大域~obj$に`結付けられている文書$
◎
Let document be the current global object's associated Document.
</li>
			<li>
%audio ~LET `新たな要素$( %文書, `audio$e, `~HTML名前空間$ )
◎
Let audio be the result of creating an element given document, audio, and the HTML namespace.
</li>
			<li>
( "`preload$aM", "`auto$v" )
を用いて %audio の`属性~値を設定-$する
◎
Set an attribute value for audio using "preload" and "auto".
</li>
			<li>
~IF［
%src は与えられている
］
⇒
( "`src$aM", %src )
を用いて %audio の`属性~値を設定-$する
（~UAは %audio 用の`資源~選定~algo$を
<a href="#concept-media-load-algorithm-at-creation">呼出す</a>
ことになる。）
◎
If src is given, then set an attribute value for audio using "src" and src. (This will cause the user agent to invoke the object's resource selection algorithm before returning.)
</li>
			<li>
~RET %audio
◎
Return audio.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="the-track-element">
<h3 title="The track element">4.8.11. `track^e 要素</h3>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
なし。
◎
None.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`~media要素$の子として
— ただし、同胞のどの`~flow内容$よりも前。
◎
As a child of a media element, before any flow content.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`kind$aT
— ~text~trackの型
◎
kind — The type of text track
</dd>
	<dd>
`src$aT
— 資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`srclang$aT
— ~text~trackの言語
◎
srclang — Language of the text track
</dd>
	<dd>
`label$aT
— 利用者に可視になる~label
◎
label — User-visible label
</dd>
	<dd>
`default$aT
— より相応しい`~text~track$が他にないときに，この~trackを可能化する。
◎
default — Enable the track if no other text track is more suitable
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[`HTMLConstructor$]
interface `HTMLTrackElement@I : `HTMLElement$I {
  [`CEReactions$] attribute DOMString `kind$mT;
  [`CEReactions$] attribute USVString `src$mT;
  [`CEReactions$] attribute DOMString `srclang$mT;
  [`CEReactions$] attribute DOMString `label$mT;
  [`CEReactions$] attribute boolean `default$mT;

  const unsigned short `NONE$mT = 0;
  const unsigned short `LOADING$mT = 1;
  const unsigned short `LOADED$mT = 2;
  const unsigned short `ERROR$mT = 3;
  readonly attribute unsigned short `readyState$mT;

  readonly attribute `TextTrack$I `track$mT;
};
</pre>
	</dd>
</dl>

<p>
`track$e 要素により、作者は，`~media要素$用に明示的な外部の［
時間同期的な`~text~track$
］を指定できるようになる。
それは、自身のみでは何も`表現-$しない。
◎
The track element allows authors to specify explicit external timed text tracks for media elements. It does not represent anything on its own.
</p>

<p>
`kind@aT
属性は、`列挙ed属性$である
。
次の表の 1 列目に，この属性~用に定義される各種~keywordを挙げる。
それぞれ、同じ行の 2 列目に与える状態に対応付けられる。
◎
The kind attribute is an enumerated attribute. The following table lists the keywords defined for this attribute. The keyword given in the first cell of each row maps to the state given in the second cell.
</p>

<!-- 
Keyword 	State 	Brief description 
 -->
<table><thead><tr><th>~keyword
<th>状態
<th>概略的な記述
</thead>

<tbody><tr><td>`subtitles@vK
<td>`Subtitles@st
<td>
音響は可用であるが解されないときに相応しくなるような，会話の音声転写0または翻訳（例： `~media資源$の音声~trackの言語を解さない利用者~向けなど）。
動画~上に積層される。
◎
Transcription or translation of the dialogue, suitable for when the sound is available but not understood (e.g. because the user does not understand the language of the media resource's audio track). Overlaid on the video.

<tr><td>`captions@vK
<td>`Captions@st
<td>
音響は可用でないか明瞭に聴取できないとき（例： 消音されている, 環境音でかき消されている,
利用者は聴覚に障害がある）に相応しくなるような，［
会話の［
音声転写0／翻訳 
］／
音響~効果 ／
関連する~musical~cue ／
その他の関連する音声~情報
］。
難聴~用に適切に~labelされて動画~上に積層される。
◎
Transcription or translation of the dialogue, sound effects, relevant musical cues, and other relevant audio information, suitable for when sound is unavailable or not clearly audible (e.g. because it is muted, drowned-out by ambient noise, or because the user is deaf). Overlaid on the video; labeled as appropriate for the hard-of-hearing.

<tr><td>`descriptions@vK
<td>`Descriptions@st
<td>
`~media資源$の動画~成分の~textual記述であって，
視覚的~成分が［
遮蔽されている ／ 可用でない ／ 利用可能でない
］とき（例：
利用者は ~screenを備えない~appと運転-中に対話している／盲目である）に，音声~合成~用に意図されるもの。
音声として合成される。
◎
Textual descriptions of the video component of the media resource, intended for audio synthesis when the visual component is obscured, unavailable, or not usable (e.g. because the user is interacting with the application without a screen while driving, or because the user is blind). Synthesized as audio.

<tr><td>`chapters@vK
<td>`Chapters@st
<td>
~chapter~title
—
`~media資源$の~navigate用に利用されるものと意図される。
対話的な（入子にされ得る）~listとして，~UI内に表示される。
◎
Chapter titles, intended to be used for navigating the media resource. Displayed as an interactive (potentially nested) list in the user agent's interface.

<tr><td>`metadata@vK
<td>`Metadata@st
<td>
~scriptからの利用-に意図される~track。
~UAにより表示されない。
◎
Tracks intended for use from script. Not displayed by the user agent.
</tbody></table>

<p>
この属性は、省略されてもよい。
`値なしに対する既定の状態$は、 `Subtitles$st とする。
`妥当でない値に対する既定の状態$は、 `Metadata$st とする。
◎
The attribute may be omitted. The missing value default is the subtitles state. The invalid value default is the metadata state.
</p>

<p>
`src@aT
属性は、~text~track~dataの`~URL$を与える。
要素は、この属性を有してい~MUST
— 指定する値は、`前後~空白~可の妥当かつ空でない~URL$で~MUST。
◎
The src attribute gives the URL of the text track data. The value must be a valid non-empty URL potentially surrounded by spaces. This attribute must be present.
</p>

<p>
要素の
`~track~URL@
は、［［
要素が `src$aT 属性を有する
］~AND［
その値 %値 ~NEQ 空~文字列
］~AND［
%値 が属性に設定された時点で，［
%値 を要素の`~node文書$に`相対的に構文解析-$した`結果の~URL文字列$
］ ~NEQ ~error
］ならば その結果 ／
~ELSE_ 空~文字列
］とする。
◎
If the element has a src attribute whose value is not the empty string and whose value, when the attribute was set, could be successfully parsed relative to the element's node document, then the element's track URL is the resulting URL string. Otherwise, the element's track URL is the empty string.
</p>

<p>
要素の`~track~URL$で識別される資源が~WebVTT~fileである場合、要素の `kind$aT 属性の状態 ~NEQ `Metadata$st ならば：
</p>

<ul>
	<li>
その~fileは`~cue~textを利用する~WebVTT~file$で~MUST。
`WEBVTT$r
◎
If the element's track URL identifies a WebVTT resource, and the element's kind attribute is not in the metadata state, then the WebVTT file must be a WebVTT file using cue text. [WEBVTT]
</li>
	<li>
加えて、［
状態 ~EQ `Chapters$st
］ならば、その~fileは［
`~chapter~title~textを利用する~WebVTT~file$である~AND
`入子の~cueのみを利用する~WebVTT~file$
］で~MUST。
`WEBVTT$r
◎
Furthermore, if the element's track URL identifies a WebVTT resource, and the element's kind attribute is in the chapters state, then the WebVTT file must be both a WebVTT file using chapter title text and a WebVTT file using only nested cues. [WEBVTT]
</li>
</ul>

<p>
`srclang@aT
属性は、~text~track~dataの言語を与える。
指定する値は、妥当な `BCP47$r 言語~tagで~MUST。
要素は、その `kind$aT 属性の状態 ~EQ `Subtitles$st の場合には，この属性を有してい~MUST。
◎
The srclang attribute gives the language of the text track data. The value must be a valid BCP 47 language tag. This attribute must be present if the element's kind attribute is in the subtitles state. [BCP47]
</p>

<p>
要素の
`~track言語@
は、［
要素は `srclang$aT 属性を有していて，その値 ~NEQ 空~文字列ならば その値 ／
~ELSE_ ε （なし）
］とする。
◎
If the element has a srclang attribute whose value is not the empty string, then the element's track language is the value of the attribute. Otherwise, the element has no track language.
</p>

<p>
`label@aT
属性は、~track用に利用者が読める~titleを与える。
この~titleは、［
 `kind$aT 属性の状態 ~IN { `Subtitles$st, `Captions$st, `Descriptions$st }
］なる~trackが~UAの~UIに~listされるときに利用される。
◎
The label attribute gives a user-readable title for the track. This title is used by user agents when listing subtitle, caption, and audio description tracks in their user interface.
</p>

<div>
<p>
`label$aT 属性の値に空~文字列が指定されては~MUST_NOT。
更には、同じ`~media要素$の子に，次をすべて満たすような［
2 つの `track$e 要素
］があっては~MUST_NOT：
</p>

<ul ><li>両者の `kind$aT 属性の状態は互いに同じ
</li><li>両者とも `srclang$aT 属性を有さない
~OR
両者とも有していて それらの値は互いに同じ言語を表現している
</li><li>両者とも `label$aT 属性を有さない
~OR
両者とも有していて それらの値は互いに同じ
</li></ul>
◎
The value of the label attribute, if the attribute is present, must not be the empty string. Furthermore, there must not be two track element children of the same media element whose kind attributes are in the same state, whose srclang attributes are both missing or have values that represent the same language, and whose label attributes are again both missing or both have the same value.
</div>

<p>
`track$e 要素の
`~track~label@
は、［
要素は `label$aT 属性を有するならば その値 ／
~ELSE_ 空~文字列
］とする。
◎
If the element has a label attribute whose value is not the empty string, then the element's track label is the value of the attribute. Otherwise, the element's track label is an empty string.
</p>

<p>
`default@aT
属性は`真偽~属性$である。
要素がこの属性を有する場合、［
要素が表現する~trackは、利用者の選好により別の~trackがより適切と指示されない場合には，可能化されることになる
］ことを指示する。
◎
The default attribute is a boolean attribute, which, if specified, indicates that the track is to be enabled if the user's preferences do not indicate that another track would be more appropriate.
</p>

<div class="p">
<p>
同じ`~media要素$の子に，次のいずれも満たすような［
2 つの `track$e 要素
］があっては~MUST_NOT：
</p>

<ul>
	<li>
両~要素とも `default$aT 属性を有する
</li>
	<li>
<p>
両~要素の `kind$aT 属性の状態は、次のいずれかを満たす：
</p>
<ul ><li>両~状態とも ~IN { `Subtitles$st, `Captions$st }
</li><li>両~状態とも `Descriptions$st
</li><li>両~状態とも `Chapters$st
</li></ul>
	</li>
</ul>


◎
Each media element must have no more than one track element child whose kind attribute is in the subtitles or captions state and whose default attribute is specified.
◎
Each media element must have no more than one track element child whose kind attribute is in the description state and whose default attribute is specified.
◎
Each media element must have no more than one track element child whose kind attribute is in the chapters state and whose default attribute is specified.
</div>


<p class="note">注記：
`default$aT 属性を有する `track$e 要素であっても，［
`kind$aT 属性の状態 ~EQ `Metadata$st
］なるものの個数には上限はない。
◎
There is no limit on the number of track elements whose kind attribute is in the metadata state and whose default attribute is specified.
</p>

<dl class="domintro">
	<dt>%track . `readyState$mT</dt>
	<dd>
<p>
次に挙げる数で表現される`~text~track準備度$を返す
<!-- 
— 返される状態の意味は〜に。
 -->
：
◎
Returns the text track readiness state, represented by a number from the following list:
</p>
		<dl>
			<dt>%track . `NONE$mT (0)</dt>
			<dd>
`~text~track未読込み$状態にある。
◎
The text track not loaded state.
</dd>

			<dt>%track . `LOADING$mT (1)</dt>
			<dd>
`~text~track読込中$状態にある。
◎
The text track loading state.
</dd>

			<dt>%track . `LOADED$mT (2)</dt>
			<dd>
`~text~track読込済み$状態にある。
◎
The text track loaded state.
</dd>

			<dt>%track . `ERROR$mT (3)</dt>
			<dd>
`~text~track読込失敗$状態にある。
◎
The text track failed to load state.
</dd>
		</dl>
	</dd>

	<dt>%track . `track$mT</dt>
	<dd>
`track$e 要素の`~text~track$に対応する
`TextTrack$I ~objを返す。
◎
Returns the TextTrack object corresponding to the text track of the track element.
</dd>
</dl>

<dl class="idl-def">
	<dt>`readyState@mT</dt>
	<dd>
<p>
取得子は、此れの`~text~track$の`~text~track準備度$に応じて，次に定義される数値を返さ~MUST：
◎
The readyState attribute must return the numeric value corresponding to the text track readiness state of the track element's text track, as defined by the following list:
</p>

		<dl>
			<dt>`NONE@mT （数値 0 ）
◎
NONE (numeric value 0)
</dt>
			<dd>
`~text~track未読込み$の状態にある。
◎
The text track not loaded state.
</dd>

			<dt>`LOADING@mT （数値 1 ）
◎
LOADING (numeric value 1)
</dt>
			<dd>
`~text~track読込中$の状態にある。
◎
The text track loading state.
</dd>

			<dt>`LOADED@mT （数値 2 ）
◎
LOADED (numeric value 2)
</dt>
			<dd>
`~text~track読込済み$の状態にある。
◎
The text track loaded state.
</dd>

			<dt>`ERROR@mT （数値 3 ）
◎
ERROR (numeric value 3)
</dt>
			<dd>
`~text~track読込失敗$の状態にある。
◎
The text track failed to load state.
</dd>
		</dl>
	</dd>

	<dt>`track@mT</dt>
	<dd>
取得子は、此れの`~text~track$に対応する `TextTrack$I ~objを返さ~MUST。
◎
The track IDL attribute must, on getting, return the track element's text track's corresponding TextTrack object.
</dd>

	<dt>`src@mT</dt>
	<dt>`srclang@mT</dt>
	<dt>`label@mT</dt>
	<dt>`default@mT</dt>
	<dd>
いずれも，対応する同じ名前の内容~属性を`反映-$し~MUST。
◎
↓</dd>

	<dt>`kind@mT</dt>
	<dd>
`既知の値のみに制限され$る下で，同じ名前の内容~属性を`反映-$し~MUST。
◎
The src, srclang, label, and default IDL attributes must reflect the respective content attributes of the same name. The kind IDL attribute must reflect the content attribute of the same name, limited to only known values.
</dd>
</dl>

<div class="example">

<p>
次の動画には、いくつかの言語による字幕がある：
◎
This video has subtitles in several languages:
</p>

<pre class="html-code">
&lt;video src="brave.webm"&gt;
 &lt;track kind=subtitles src=brave.en.vtt srclang=en label="English"&gt;
 &lt;track kind=captions src=brave.en.hoh.vtt srclang=en label="English for the Hard of Hearing"&gt;
 &lt;track kind=subtitles src=brave.fr.vtt srclang=fr lang=fr label="Français"&gt;
 &lt;track kind=subtitles src=brave.de.vtt srclang=de lang=de label="Deutsch"&gt;
&lt;/video&gt;
</pre>

<p>
（最後の 2 個の  `lang$a 属性は、字幕ではなく `label$aT 属性の言語を述べるものである。
字幕の言語は `srclang$aT 属性が与える。）
◎
(The lang attributes on the last two describe the language of the label attribute, not the language of the subtitles themselves. The language of the subtitles is given by the srclang attribute.)
</p>

</div>

			</section>
			<section id="media-elements">
<h3 title="Media elements">4.8.12. ~media要素</h3>

<p>
`HTMLMediaElement$I ~obj（この仕様における
`audio$e ／ `video$e
）は、単に
`~media要素@
とも呼ばれる。
◎
HTMLMediaElement objects (audio and video, in this specification) are simply known as media elements.
</p>


<pre class="idl">
enum `CanPlayTypeResult@I { "" /* `空~文字列$cP */, `maybe$l, `probably$l };

typedef (`MediaStream$I or `MediaSource$I or `Blob$I) `MediaProvider@I;

interface `HTMLMediaElement@I : `HTMLElement$I {

  // <span class="comment">~error状態</span>
  readonly attribute `MediaError$I? `error$mM;

  // <span class="comment">~network状態</span>
  [`CEReactions$] attribute USVString `src$mM;
  attribute `MediaProvider$I? `srcObject$mM;
  readonly attribute USVString `currentSrc$mM;
  [`CEReactions$] attribute DOMString? `crossOrigin$mM;
  const unsigned short `NETWORK_EMPTY$mM = 0;
  const unsigned short `NETWORK_IDLE$mM = 1;
  const unsigned short `NETWORK_LOADING$mM = 2;
  const unsigned short `NETWORK_NO_SOURCE$mM = 3;
  readonly attribute unsigned short `networkState$mM;
  [`CEReactions$] attribute DOMString `preload$mM;
  readonly attribute `TimeRanges$I `buffered$mM;
  void `load$mM();
  `CanPlayTypeResult$I `canPlayType$mM(DOMString %type);

  // <span class="comment">準備状態</span>
  const unsigned short `HAVE_NOTHING$mM = 0;
  const unsigned short `HAVE_METADATA$mM = 1;
  const unsigned short `HAVE_CURRENT_DATA$mM = 2;
  const unsigned short `HAVE_FUTURE_DATA$mM = 3;
  const unsigned short `HAVE_ENOUGH_DATA$mM = 4;
  readonly attribute unsigned short `readyState$mM;
  readonly attribute boolean `seeking$mM;

  // <span class="comment">再生~状態</span>
  attribute double `currentTime$mM;
  void `fastSeek$mM(double %time);
  readonly attribute unrestricted double `duration$mM;
  `object$ `getStartDate$mM();
  readonly attribute boolean `paused$mM;
  attribute double `defaultPlaybackRate$mM;
  attribute double `playbackRate$mM;
  readonly attribute `TimeRanges$I `played$mM;
  readonly attribute `TimeRanges$I `seekable$mM;
  readonly attribute boolean `ended$mM;
  [`CEReactions$] attribute boolean `autoplay$mM;
  [`CEReactions$] attribute boolean `loop$mM;
  Promise&lt;void&gt; `play$mM();
  void `pause$mM();

  // <span class="comment">各種~control</span>
  [`CEReactions$] attribute boolean `controls$mM;
  attribute double `volume$mM;
  attribute boolean `muted$mM;
  [`CEReactions$] attribute boolean `defaultMuted$mM;

  // <span class="comment">各種~track</span>
  [SameObject] readonly attribute `AudioTrackList$I `audioTracks$mM;
  [SameObject] readonly attribute `VideoTrackList$I `videoTracks$mM;
  [SameObject] readonly attribute `TextTrackList$I `textTracks$mM;
  `TextTrack$I `addTextTrack$mM(`TextTrackKind$I %kind, optional DOMString %label = "", optional DOMString %language = "");
};
</pre>

<p>
`~media要素~属性@
—
`src$aM,
`crossorigin$aM,
`preload$aM,
`autoplay$aM,
`loop$aM,
`muted$aM,
`controls$aM
—
は、この節にて定義され，すべての`~media要素$に適用される。
◎
The media element attributes, src, crossorigin, preload, autoplay, loop, muted, and controls, apply to all media elements. They are defined in this section.
</p>

<p>
`~media要素$は、利用者に［
音声~data ／
動画＆音声~data
］を呈示するために利用される。
この~dataは、この節においては
`~media~data@
と称される
— この節は［
音声, 動画
］用の`~media要素$に等しく適用されるので。
用語
`~media資源@
は、~media~dataの完全な集合を指すために利用される
— 例えば、完全な［
動画／音声
］~file。
◎
Media elements are used to present audio data, or video and audio data, to the user. This is referred to as media data in this section, since this section applies equally to media elements for audio or for video. The term media resource is used to refer to the complete set of media data, e.g. the complete video file, or complete audio file.
</p>

<p>
`~media資源$は、複数の［
音声／動画
］~trackを持ち得る。
`~media要素$の目的における`~media資源$の［
動画~data ／ 音声~data
］は、`~event-loop$が最後に`最初の段$に達した時点で，要素の［
`videoTracks$mM ／ `audioTracks$mM
］属性が与える［
現在~選択されている~trackのそれ（もしあれば） ／
現在~可能化されている~trackのそれら（もしあれば）を混合した結果
］に限られる。
◎
A media resource can have multiple audio and video tracks. For the purposes of a media element, the video data of the media resource is only that of the currently selected track (if any) as given by the element's videoTracks attribute when the event loop last reached step 1, and the audio data of the media resource is the result of mixing all the currently enabled tracks (if any) given by the element's audioTracks attribute when the event loop last reached step 1.
</p>

<p class="note">注記：
`audio$e, `video$e
両~要素とも［
音声, 動画
］の両者に利用できる。
この 2 つの主な相違は、単純に，視覚的~内容（動画や~captionなど）のための再生~区画が［
`audio$e 要素にはなく, `video$e 要素にはある
］ことである。
◎
Both audio and video elements can be used for both audio and video. The main difference between the two is simply that the audio element has no playback area for visual content (such as video or captions), whereas the video element does.
</p>

<p>
他から明示的に指定される場合を除いて、この節, その下位節にて`待入され$るどの~taskに対しても，その`~task源$は、当の`~media要素$の
`~media要素~event~task源@
とする。
`要素ごとに別々の~task源になる^tnote
◎
Except where otherwise explicitly specified, the task source for all the tasks queued in this section and its subsections is the media element event task source of the media element in question.
</p>

				<section id="error-codes">
<h4 title="Error codes">4.8.12.1. ~error~code</h4>

<dl class="domintro">

	<dt>%media . `error$mM</dt>
	<dd>
要素の現在の~error状態を表現している `MediaError$I ~objを返す。
◎
Returns a MediaError object representing the current error state of the element.
</dd>
	<dd>
~errorが生じてなければ ~NULL を返す。
◎
Returns null if there is no error.
</dd>
</dl>

<dl class="idl-def">
	<dt>`error@mM</dt>
	<dd>
各`~media要素$には、~error状態sが結付けられる
— それは、要素がその`資源~選定~algo$が最後に呼出されてから遭遇した最後の~errorを記録する。
</dd>
	<dd>
取得子は、此れにおいて~errorは［
まだ生じていなければ ~NULL ／
生じたならば それらのうち最後に生じたものに対し作成された `MediaError$I ~obj
］を返さ~MUST。
◎
All media elements have an associated error status, which records the last error the element encountered since its resource selection algorithm was last invoked. The error attribute, on getting, must return the MediaError object created for this last error, or null if there has not been an error.
</dd>
</dl>

<pre class="idl">
interface `MediaError@I {
  const unsigned short `MEDIA_ERR_ABORTED$mE = 1;
  const unsigned short `MEDIA_ERR_NETWORK$mE = 2;
  const unsigned short `MEDIA_ERR_DECODE$mE = 3;
  const unsigned short `MEDIA_ERR_SRC_NOT_SUPPORTED$mE = 4;

  readonly attribute unsigned short `code$mE;
  readonly attribute DOMString `message$mE;
};
</pre>

<dl class="domintro">
	<dt>%media . `error$mM . `code$mE</dt>
	<dd>
現在の~errorの~error~codeを，下に挙げるいずれかの値として返す。
◎
Returns the current error's error code, from the list below.
</dd>

	<dt>%media . `error$mM . `message$mE</dt>
	<dd>
遭遇した~error条件に特有の診断用の参考~messageを返す。
~messageと~message形式は、一般には，~UAごとに一様でない。
そのような~messageは可用でない場合、空~文字列が返される。
◎
Returns a specific informative diagnostic message about the error condition encountered. The message and message format are not generally uniform across different user agents. If no such message is available, then the empty string is returned.
</dd>
</dl>

<p>
各 `MediaError$I ~objは、文字列である
`~message@
, および
次のいずれかをとる
`~code@
を持つ：
◎
Every MediaError object has a message, which is a string, and a code, which is one of the following:
</p>

<dl class="idl-def">
	<dt>`MEDIA_ERR_ABORTED@mE （数値 1 ）</dt>
	<dd>
`~media資源$の~fetchingは、利用者の要請に応じて~UAにより中止された。
◎
The fetching process for the media resource was aborted by the user agent at the user's request.
</dd>

	<dt>`MEDIA_ERR_NETWORK@mE （数値 2 ）</dt>
	<dd>
資源は利用可能であると確立された後、何らかの~network~errorにより，~UAによる`~media資源$の~fetchingは停止された。
◎
A network error of some description caused the user agent to stop fetching the media resource, after the resource was established to be usable.
</dd>

	<dt>`MEDIA_ERR_DECODE@mE （数値 3 ）</dt>
	<dd>
資源は利用可能であると確立された後、`~media資源$を復号する際に，何らかの~errorが生じた。
◎
An error of some description occurred while decoding the media resource, after the resource was established to be usable.
</dd>

	<dt>`MEDIA_ERR_SRC_NOT_SUPPORTED@mE （数値 4 ）</dt>
	<dd>
［
`src$aM 属性 ／ `割当されている~media提供元~obj$
］により指示された`~media資源$は、相応しくなかった。
◎
The media resource indicated by the src attribute or assigned media provider object was not suitable.
</dd>
</dl>

<div class="p">
<p>
`新たな~MediaError@
を作成するときは、所与の
( 上に挙げたいずれかの値をとる~error~code %~code )
に対し，次のように設定された新たな `MediaError$I ~objを返す：
</p>

<ul>
	<li>
`~code$ ~SET %~code
</li>
	<li>
`~message$ ~SET 当の~error条件を生じさせたものについて~UAが給せる詳細が［
あれば それを表す文字列 ／
なければ 空~文字列
］
⇒
この文字列は、 %~code を介してすでに可用な情報を超えるものがない場合は，空~文字列にされ~MUST
— 例えば、単純に~codeを文字列に翻訳した結果にしては~MUST_NOT。
</li>
</ul>

◎
To create a MediaError, given an error code which is one of the above values, return a new MediaError object whose code is the given error code and whose message is a string containing any details the user agent is able to supply about the cause of the error condition, or the empty string if the user agent is unable to supply such details. This message string must not contain only the information already available via the supplied error code; for example, it must not simply be a translation of the code into a string format. If no additional information is available beyond that provided by the error code, the message must be set to the empty string.
</div>

<dl class="idl-def">
	<dt>`code@mE</dt>
	<dd>
取得子は、此れの`~code$を返さ~MUST。
◎
The code attribute of a MediaError object must return this MediaError object's code.
</dd>

	<dt>`message@mE</dt>
	<dd>
取得子は、此れの`~message$を返さ~MUST。
◎
The message attribute of a MediaError object must return this MediaError object's message.
</dd>
</dl>

				</section>
				<section id="location-of-the-media-resource">
<h4 title="Location of the media resource">4.8.12.2. ~media資源の所在</h4>

<p>
`~media要素$の
`src@aM
内容~属性は、利用者に示す~media資源（動画や音声）の`~URL$を与える。
属性に指定する値は、`前後~空白~可の妥当かつ空でない~URL$を包含し~MUST。
◎
The src content attribute on media elements gives the URL of the media resource (video, audio) to show. The attribute, if present, must contain a valid non-empty URL potentially surrounded by spaces.
</p>

<p>
`~media要素$が `itemprop$a 属性を有する場合、 `src$aM 属性も指定され~MUST。
◎
If the itemprop attribute is specified on the media element, then the src attribute must also be specified.
</p>

<p>
`~media要素$の
`crossorigin@aM
内容~属性は`~CORS設定群~属性$である。
◎
The crossorigin content attribute on media elements is a CORS settings attribute.
</p>

<p id="concept-media-load-algorithm-at-creation">
`~media要素$の作成-時に `src$aM 属性を有していた場合、
~UAは，`~media要素$の`資源~選定~algo$を`即時$に呼出さ~MUST。
◎
If a media element is created with a src attribute, the user agent must immediately invoke the media element's resource selection algorithm.
</p>

<p>
`~media要素$の `src$aM 属性が［
設定-／変更-
］されたときは、~UAは
`~media要素$の`~media要素~読込み~algo$を呼出さ~MUST。
（ `src$aM 属性が<em>除去された</em>ときは、子に `source$e 要素が在っても，これは行わない。）
◎
If a src attribute of a media element is set or changed, the user agent must invoke the media element's media element load algorithm. (Removing the src attribute does not do this, even if there are source elements present.)
</p>

<dl class="idl-def">
	<dt>`src@mM</dt>
	<dd>
`src$aM 内容~属性を`反映-$し~MUST。
◎
The src IDL attribute on media elements must reflect the content attribute of the same name.
</dd>

	<dt>`crossOrigin@mM</dt>
	<dd>
`crossorigin$aM 内容~属性を`反映-$し~MUST。
◎
The crossOrigin IDL attribute must reflect the crossorigin content attribute.
</dd>
</dl>

<p>
`~media提供元~obj@
は、`~URL$とは別々に`~media資源$を表現できる~objである。
［
`MediaStream$I ／ `MediaSource$I ／ `Blob$I 
］~objは、`~media提供元~obj$である。
◎
A media provider object is an object that can represent a media resource, separate from a URL. MediaStream objects, MediaSource objects, and Blob objects are all media provider objects.
</p>

<p>
各`~media要素$に
`割当されている~media提供元~obj@
は、要素に割当され得る`~media提供元~obj$であり，なければ ε とする。
`~media要素$の作成-時には ε とする。
◎
Each media element can have an assigned media provider object, which is a media provider object. When a media element is created, it has no assigned media provider object.
</p>

<dl class="domintro">
	<dt>%media . `srcObject$mM [ = %source ]</dt>
	<dd>
`~media要素$に`~media提供元~obj$を割当できるようにする。
◎
Allows the media element to be assigned a media provider object.
</dd>

	<dt>%media . `currentSrc$mM</dt>
	<dd>
［［
現在の`~media資源$はある
］~AND［
その`~URL$はある
］ならば それ ／
~ELSE_ 空~文字列
］を返す。
◎
Returns the URL of the current media resource, if any.
◎
Returns the empty string when there is no media resource, or it doesn't have a URL.
</dd>
</dl>

<dl class="idl-def">
	<dt>`currentSrc@mM</dt>
	<dd>
初期~時には空~文字列にされ~MUST。
その値は、下に定義される`資源~選定~algo$により変更される。
◎
The currentSrc IDL attribute must initially be set to the empty string. Its value is changed by the resource selection algorithm defined below.
</dd>

	<dt>`srcObject@mM</dt>
	<dd>
取得子は、［
此れに`割当されている~media提供元~obj$ ~NEQ ε ならば それ ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
↓</dd>
	<dd>
設定子は、此れに`割当されている~media提供元~obj$を所与の値に設定してから
此れの`~media要素~読込み~algo$を呼出さ~MUST。
◎
The srcObject IDL attribute, on getting, must return the element's assigned media provider object, if any, or null otherwise. On setting, it must set the element's assigned media provider object to the new value, and then invoke the element's media element load algorithm.
</dd>
</dl>


<p class="note">注記：
`~media資源$を指定する仕方には、~~優先される順に［
`srcObject$mM ~IDL属性,
`src$aM 内容~属性,
`source$e 要素
］がある。
◎
There are three ways to specify a media resource: the srcObject IDL attribute, the src content attribute, and source elements. The IDL attribute takes priority, followed by the content attribute, followed by the elements.
</p>


				</section>
				<section id="mime-types">
<h4 title="MIME types">4.8.12.3. ~MIME型</h4>

<p>
`~media資源$は、その<em>型</em>
— 特に`~MIME型$, および 事例によっては ~codecs ~parameter —
を通して記述され得る。
（ ~codecs ~parameterが許容されるかどうかは、~MIME型に依存する。）
`RFC6381$r
◎
A media resource can be described in terms of its type, specifically a MIME type, in some cases with a codecs parameter. (Whether the codecs parameter is allowed or not depends on the MIME type.) [RFC6381]
</p>

<p>
型は、通例的にはいくぶん不完全な記述である。
例えば `video/mpeg^l は、容器の型が何であるかを除き，何も言わない。
`video/mp4; codecs="avc1.42E01E, mp4a.40.2"^l
の様な型でも，実際の~bitrateの様な情報は含まない（含むのは最大~bitrateのみ）。
したがって~UAは、所与の型に対し，その型の~mediaを再生できるかどうか知り得るのは，［
（様々な確度で）<em>できるかもしれない</em>か，確定的に<em>できない</em>か
］までに限られることが多い。
◎
Types are usually somewhat incomplete descriptions; for example "video/mpeg" doesn't say anything except what the container type is, and even a type like "video/mp4; codecs="avc1.42E01E, mp4a.40.2"" doesn't include information like the actual bitrate (only the maximum bitrate). Thus, given a type, a user agent can often only know whether it might be able to play media of that type (with varying levels of confidence), or whether it definitely cannot play media of that type.
</p>

<p>
~UAが資源を確定的に~supportしないような型は、
`~UAが具現化できないと知る型@
とされる
— 例えば、認識できない容器~型や，~supportしない~codecが挙げられている型など。
◎
A type that the user agent knows it cannot render is one that describes a resource that the user agent definitely does not support, for example because it doesn't recognize the container type, or it doesn't support the listed codecs.
</p>

<p>
~parameterを伴わない`~MIME型$
`application/octet-stream$mt
は、常に`~UAが具現化できないと知る型$になる。
~UAは、`~media資源$になり得るものに この型が付与されているときは，［
明示的な`~Content-Type~metadata$
］を欠くものと等価に扱わ~MUST。
◎
The MIME type "application/octet-stream" with no parameters is never a type that the user agent knows it cannot render. User agents must treat that type as equivalent to the lack of any explicit Content-Type metadata when it is used to label a potential media resource.
</p>

<p class="note">注記：
ここでは、~parameterを伴わない `~MIME型$
`application/octet-stream$mt
のみが特別に扱われる
— ~parameterが現れる場合、他の`~MIME型$と同様に扱われることになる。
これは、［
未知の `~MIME型$ ~parameterは無視されるべきである
］とする規則からの逸脱である。
◎
Only the MIME type "application/octet-stream" with no parameters is special-cased here; if any parameter appears with it, it will be treated just like any other MIME type. This is a deviation from the rule that unknown MIME type parameters should be ignored.
</p>


<dl class="domintro">
	<dt>%media . `canPlayType(type)$mM</dt>
	<dd>
~UAが所与の型の~media資源を再生できる確度に基づいて，［
空~文字列（否定的~応答）,
`maybe^l,
`probably^l
］のいずれかを返す。
◎
Returns the empty string (a negative response), "maybe", or "probably" based on how confident the user agent is that it can play media resources of the given type.
</dd>
</dl>

<dl class="idl-def">
	<dt>`canPlayType(type)@mM</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
%type は`~UAが具現化できないと知る型$である
］~OR［
%型 ~EQ `application/octet-stream$mt
］
⇒
~RET `空~文字列@cP
</li>
			<li>
~IF［
~UAは、 %type が表現する`~media資源$が此れに利用されたなら，十分な確度で具現化できる
］
⇒
~RET
`probably@l
</li>
			<li>
~RET
`maybe@l
</li>
		</ol>
<p>
実装者には、
%type を~supportしないか~supportする~~十分な確度がない限り，
`maybe$l を返すことが奨励される。
一般に，~UAは、 ~codecs ~parameterを許容する型に対しては，その~parameterが無い場合は 決して `probably$l を返すべきでない。
</p>
◎
The canPlayType(type) method must return the empty string if type is a type that the user agent knows it cannot render or is the type "application/octet-stream"; it must return "probably" if the user agent is confident that the type represents a media resource that it can render if used in with this audio or video element; and it must return "maybe" otherwise. Implementors are encouraged to return "maybe" unless the type can be confidently established as being supported or not. Generally, a user agent should never return "probably" for a type that allows the codecs parameter if that parameter is not present.
</dd>
</dl>


<div class="example">
<p>
次の~scriptは、~UAは（架空の）新たな形式を~supportするかどうか試験して，
`video$e 要素か~pluginのどちらを利用するか動的に決める：
◎
This script tests to see if the user agent supports a (fictional) new format to dynamically decide whether to use a video element or a plugin:
</p>

<pre class="html-code">
&lt;section id="video"&gt;
 &lt;p&gt;&lt;a href="playing-cats.nfv"&gt;動画を~downloadする&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;script&gt;
 var %videoSection = document.getElementById('video');
 var %videoElement = document.createElement('video');
 var %support = videoElement.canPlayType('video/x-new-fictional-format;codecs="kittens,bunnies"');
 if (%support != "probably" &amp;&amp; "New Fictional Video Plugin" in navigator.plugins) {
   /* <span class="comment">
~browserが~supportする~~十分な確度はないが、~pluginがあるので代わりにそれを利用する
◎
not confident of browser support but we have a plugin so use plugin instead
</span> */
   %videoElement = document.createElement("embed");
 } else if (%support == "") {
   /* <span class="comment">
~browserからは~supportされず，~pluginもないので、何もしない
◎
no support from browser and no plugin — do nothing
</span> */
   %videoElement = null;
 }
 if (%videoElement) {
   while (%videoSection.hasChildNodes())
     %videoSection.removeChild(%videoSection.firstChild);
   %videoElement.setAttribute("src", "playing-cats.nfv");
   %videoSection.appendChild(%videoElement);
 }
&lt;/script&gt;
</pre>

</div>

<p class="note">注記：
`source$e 要素の `type$aS 属性を用いれば、~UAが具現化できない形式を利用している資源に対しては，~downloadを避けれるようになる。
◎
The type attribute of the source element allows the user agent to avoid downloading resources that use formats it cannot render.
</p>


				</section>
				<section id="network-states">
<h4 title="Network states">4.8.12.4. ~network状態</h4>

<dl class="domintro">

	<dt>%media . `networkState$mM</dt>
	<dd>
要素のための~network活動についての現在の状態を，下に挙げるいずれかの~codeとして返す。
◎
Returns the current state of network activity for the element, from the codes in the list below.
</dd>
</dl>

<dl class="idl-def">
	<dt>`networkState@mM</dt>
	<dd>
<p>
~networkと対話するときの現在の~network活動を表現する。
取得子は、此れの現在の~network状態を，次のいずれか値として返さ~MUST：
◎
As media elements interact with the network, their current network activity is represented by the networkState attribute. On getting, it must return the current network state of the element, which must be one of the following values:
</p>

		<dl>
			<dt>`NETWORK_EMPTY@mM （数値 0 ）</dt>
			<dd>
此れはまだ初期化されていない。
すべての属性は、それぞれの初期~状態にある。
◎
The element has not yet been initialized. All attributes are in their initial states.
</dd>

			<dt>`NETWORK_IDLE@mM （数値 1 ）</dt>
			<dd>
此れの`資源~選定~algo$は作動中にあり，`~media資源$を選択したが、現時点では，実際には~networkを利用していない。
◎
The element's resource selection algorithm is active and has selected a resource, but it is not actually using the network at this time.
</dd>

			<dt>`NETWORK_LOADING@mM （数値 2 ）</dt>
			<dd>
~UAは能動的に~dataを~downloadしようと試行している。
◎
The user agent is actively trying to download data.
</dd>

			<dt>`NETWORK_NO_SOURCE@mM （数値 3 ）</dt>
			<dd>
此れの`資源~選定~algo$は作動中にあるが、利用する`~media資源$はまだ見出されてない。
◎
The element's resource selection algorithm is active, but it has not yet found a resource to use.
</dd>
		</dl>
	</dd>
</dl>

<p>
`networkState$mM 属性の値がいつ変化するか，および
どの~eventを発火して その状態~変化を指示するかは、下に定義される`資源~選定~algo$にて正確に述べる。
◎
The resource selection algorithm defined below describes exactly when the networkState attribute changes value and what events fire to indicate changes in this state.
</p>


				</section>
				<section id="loading-the-media-resource">
<h4 title="Loading the media resource">4.8.12.5. ~media資源の読込み法</h4>

<dl class="domintro">

	<dt>%media . `load()$mM</dt>
	<dd>
この`~media要素$を再設定して、白紙状態から，新たな`~media資源$を選択して読込みを開始させる。
◎
Causes the element to reset and start selecting and loading a new media resource from scratch.
</dd>
</dl>

<p>
各`~media要素$は、
`自動再生~可能~flag@
— 初期~時は ~T, および
`~load~event遅延-中~flag@
— 初期~時は ~F
を持つ。
［
`~load~event遅延-中~flag$ ~EQ ~T
］の間は、要素はその文書の`~load~eventを遅延-$し~MUST。
◎
All media elements have a can autoplay flag, which must begin in the true state, and a delaying-the-load-event flag, which must begin in the false state. While the delaying-the-load-event flag is true, the element must delay the load event of its document.
</p>

<dl class="idl-def">
	<dt>`load()@mM</dt>
	<dd>
被呼出時には、此れに対する`~media要素~読込み~algo$を走らせ~MUST。
◎
When the load() method on a media element is invoked, the user agent must run the media element load algorithm.
</dd>
</dl>

<p class="algo-head">
所与の`~media要素$ %要素 に対する
`~media要素~読込み~algo@
は、次を走らす：
◎
The media element load algorithm consists of the following steps.
</p>

<ol>
	<li>
%要素 に対しすでに走らせている`資源~選定~algo$の~instanceがあれば，それを中止する
◎
Abort any already-running instance of the resource selection algorithm for this element.
</li>
	<li>
%処理待ち~taskたち ~LET［
ある`~task待行列$内の， %要素 の`~media要素~event~task源$から待入された`~task$
］すべてからなる，待入された順による~list
◎
Let pending tasks be a list of all tasks from the media element's media element event task source in one of the task queues.
</li>
	<li>
%処理待ち~taskたち 内の ~EACH( %~task ) に対し
⇒
~IF［
%~task は［［
`再生待ち~promiseたちを解決-$ ／ `再生待ち~promiseたちを却下-$
］するものである
］
⇒
それらの~promiseたちを即時に［
解決-／却下-
］する
◎
For each task in pending tasks that would resolve pending play promises or reject pending play promises, immediately resolve or reject those promises in the order the corresponding tasks were queued.
</li>
	<li>
<p>
%処理待ち~taskたち 内の ~EACH( %~task ) に対し
⇒
%~task をその`~task待行列$から除去する
◎
Remove each task in pending tasks from its task queue
</p>

<p class="note">注記：
基本的に，~media要素が新たな資源の読込処理を開始したときは、処理待ちの~eventや~callbackは破棄され，［
解決-／却下-
］待ちの~promiseたちは即時に［
解決-／却下-
］される。
◎
Basically, pending events and callbacks are discarded and promises in-flight to be resolved/rejected are resolved/rejected immediately when the media element starts loading a new resource.
</p>
	</li>
	<li>
~IF［
%要素 の `networkState$mM ~IN {
`NETWORK_LOADING$mM, `NETWORK_IDLE$mM
}
］
⇒
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `abort$et の`~eventを発火-$する
◎
If the media element's networkState is set to NETWORK_LOADING or NETWORK_IDLE, queue a task to fire an event named abort at the media element.
</li>
	<li>
<p>
~IF［
%要素 の`networkState$mM ~NEQ `NETWORK_EMPTY$mM
］：
◎
If the media element's networkState is not set to NETWORK_EMPTY, then:
</p>

	<ol>
			<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `emptied$et の`~eventを発火-$する
◎
Queue a task to fire an event named emptied at the media element.
</li>
			<li>
~IF［
%要素 に対し，進捗-中にある~fetchingがある
］
⇒
~UAはそれを停止するべきである
◎
If a fetching process is in progress for the media element, the user agent should stop it.
</li>
			<li>
~IF［
%要素 に`割当されている~media提供元~obj$は `MediaSource$I ~objである
］
⇒
それを`~detach$する
◎
If the media element's assigned media provider object is a MediaSource object, then detach it.
</li>
			<li>
%要素 の`~media資源に特有の~trackを忘れる$
◎
Forget the media element's media-resource-specific tracks.
</li>
			<li>
`readyState$mM ~SET `HAVE_NOTHING$mM
◎
If readyState is not set to HAVE_NOTHING, then set it to that state.
</li>
			<li>
<p>
~IF［
%要素 の `paused$mM 属性 ~EQ ~F
］：
◎
If the paused attribute is false, then:
</p>
				<ol>
					<li>
%要素 の `paused$mM 属性 ~SET ~T
◎
Set the paused attribute to true.
</li>
					<li>
`再生待ち~promiseたちを却下-$する
( %要素 の`再生待ち~promiseたちを取り出$した結果, `AbortError$E 例外 )
◎
Take pending play promises and reject pending play promises with the result and an "AbortError" DOMException.
</li>
				</ol>
			</li>
			<li>
~IF［
`seeking$mM ~EQ ~T
］
⇒
`seeking$mM ~SET ~F
◎
If seeking is true, set it to false.
</li>
			<li>
%要素 の`現在の再生~位置$ ~SET 0
◎
Set the current playback position to 0.
</li>
			<li>
%前~位置 ~LET %要素 の`公式的な再生~位置$
◎
↓</li>
			<li>
%要素 の`公式的な再生~位置$ ~SET 0
◎
Set the official playback position to 0.
</li>
			<li>
~IF［
%前~位置 ~NEQ 0
］
⇒
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `timeupdate$et の`~eventを発火-$する
◎
If this changed the official playback position, then queue a task to fire an event named timeupdate at the media element.
</li>
			<li>
`時間軸~offset$ ~SET `NaN^jv
◎
Set the timeline offset to Not-a-Number (NaN).
</li>
			<li>
<p>
%要素 の `duration$mM 属性 ~SET `NaN^jv
◎
Update the duration attribute to Not-a-Number (NaN).
</p>

<p class="note">注記：
~UAは、この段による時間長の変化に対しては，
`durationchange$et ~eventは
<a href="#durationChange">発火しない</a>
ことになる。
◎
The user agent will not fire a durationchange event for this particular change of the duration.
</p>
			</li>
		</ol>
	</li>
	<li>
%要素 の `playbackRate$mM 属性 ~SET %要素 の `defaultPlaybackRate$mM 属性の値
◎
Set the playbackRate attribute to the value of the defaultPlaybackRate attribute.
</li>
	<li>
%要素 の `error$mM 属性  ~SET ~NULL
◎
↓</li>
	<li>
%要素 の `自動再生~可能~flag$ ~SET ~T
◎
Set the error attribute to null and the can autoplay flag to true.
</li>
	<li>
<p>
%要素 の`資源~選定~algo$を呼出す
◎
Invoke the media element's resource selection algorithm.
</p>

<p class="note">注記：
以前に %要素 に対し再生していた`~media資源$があれば，この時点で停止する。
◎
Playback of any previously playing media resource for this element stops.
</p>
	</li>
</ol>


<div >
<p class="algo-head">
`~media要素$ %要素 に対する
`資源~選定~algo@
は、次に従う
— この~algoは：
</p>

<ul>
	<li>
常に`~task$の一部として呼出され、`並列的$に実行される。
</li>
	<li>
いくつかの`同期区間$があり，`~event-loop$の仕組みと緊密に対話する（同期区間は、`~event-loop$~algoの一部として誘発される）。
同期区間は、記号 ⌛ が付与された段で（または，付与せずに下位手続きとして）指示され，
“以降は `並列的$に継続する”
と記された段に達した所で終える（ ~GOTO では終えないことに注意）。
</li>
	<li>
この~algoは、通例のように ~RET せずに，自身, または 
それが呼出す`資源~fetch~algo$, または
それにより待入される~taskにより中止されることもある。
そのような箇所は、
“資源~選定~algoを
`中止-@
する”
という句で指示される。
また、一部の事例では，永遠に走り続ける。
<!-- 
ある~taskがこの~algoを中止する前に待入された，別の未処理の~taskがどう取扱われるかは、はっきりしない^tnote
 -->
</li>
</ul>

◎
The resource selection algorithm for a media element is as follows. This algorithm is always invoked as part of a task, but one of the first steps in the algorithm is to return and continue running the remaining steps in parallel. In addition, this algorithm interacts closely with the event loop mechanism; in particular, it has synchronous sections (which are triggered as part of the event loop algorithm). Steps in such sections are marked with ⌛.
</div>

<ol>
	<li>
%要素 の `networkState$mM 属性 ~SET `NETWORK_NO_SOURCE$mM
◎
Set the element's networkState attribute to the NETWORK_NO_SOURCE value.
</li>
	<li>
%要素 の`~show~poster~flag$ ~SET ~T
◎
Set the element's show poster flag to true.
</li>
	<li>
%要素 の`~load~event遅延-中~flag$ ~SET ~T
（これは`~load~eventを遅延-$する。）
◎
Set the media element's delaying-the-load-event flag to true (this delays the load event).
</li>
	<li>
<p>
以降の記号 ⌛ が付与された段を`同期区間$として、`安定~状態を待受ける$：
◎
Await a stable state, allowing the task that invoked this algorithm to continue. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)
</p>
		<ol>
			<li>⌛
~IF［
%要素 の `blocked-on-parser$ ~flag ~EQ ~F
］
⇒
`処理待ち~text~trackの~listを拡充-$する
◎
⌛ If the media element's blocked-on-parser flag is false, then populate the list of pending text tracks.
</li>
			<li>⌛
%要素 の`networkState$mM ~SET `NETWORK_LOADING$mM
◎
↓↓</li>
			<li>⌛
~IF［
%要素 に`割当されている~media提供元~obj$ ~NEQ ε
］
⇒
~GOTO `~obj^i
◎
⌛ If the media element has an assigned media provider object, then let mode be object.
</li>
			<li>⌛
~ELIF［
%要素 は `src$aM 属性を有する
］
⇒
~GOTO `属性^i
◎
⌛ Otherwise, if the media element has no assigned media provider object but has a src attribute, then let mode be attribute.
</li>
			<li>⌛
~ELIF［
%要素 の子である `source$e 要素はある
］
⇒
~GOTO `子たち^i
◎
⌛ Otherwise, if the media element does not have an assigned media provider object and does not have a src attribute, but does have a source element child, then let mode be children and let candidate be the first such source element child in tree order.
</li>
			<li>⌛
%要素 の `networkState$mM ~SET `NETWORK_EMPTY$mM
</li>
			<li>
以降は `並列的$に継続する
</li>
			<li>
~RET
◎
⌛ Otherwise the media element has no assigned media provider object and has neither a src attribute nor a source element child: set the networkState to NETWORK_EMPTY, and abort these steps; the synchronous section ends.
</li>
		</ol>
	</li>
	<li>
<p>
`~obj^i：
◎
↑↑⌛ Set the media element's networkState to NETWORK_LOADING.
◎
↓↓⌛ Queue a task to fire an event named loadstart at the media element.
◎
Run the appropriate steps from the following list:
◎
If mode is object
</p>
		<ol>
			<li>⌛
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `loadstart$et の`~eventを発火-$する
◎
↑↑</li>
			<li>⌛
%要素 の `currentSrc$mM 属性 ~SET 空~文字列
◎
⌛ Set the currentSrc attribute to the empty string.
</li>
			<li>
以降は `並列的$に継続する
◎
End the synchronous section, continuing the remaining steps in parallel.
</li>
			<li>
%要素 に`割当されている~media提供元~obj$で`資源~fetch~algo$を走らす
◎
Run the resource fetch algorithm with the assigned media provider object. If that algorithm returns without aborting this one, then the load failed.
</li>
			<li>
~GOTO `失敗^i
◎
↓↓Failed with media provider: Reaching this step indicates that the media resource failed to load. Take pending play promises and queue a task to run the dedicated media source failure steps with the result.
◎
Abort these steps. The element won't attempt to load another resource until this algorithm is triggered again.
</li>
		</ol>
	</li>
	<li>
<p>
`属性^i：
◎
If mode is attribute
</p>
		<ol>
			<li>⌛
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `loadstart$et の`~eventを発火-$する
◎
↑↑</li>
			<li>
<p>⌛
%~URL ~LET 次の下位手続きを走らせた結果：
</p>
				<ol>
					<li>
%src ~LET %要素 の `src$aM 属性の値
◎
↓</li>
					<li>
~IF［
%src ~EQ 空~文字列
］
⇒
~RET ε
◎
⌛ If the src attribute's value is the empty string, then end the synchronous section, and jump down to the failed with attribute step below.
</li>
					<li>
%~URL~record ~LET
%src を %要素 の`~node文書$に`相対的に構文解析-$した`結果の~URL~record$
◎
⌛ Let urlString and urlRecord be the resulting URL string and the resulting URL record, respectively, that would have resulted from parsing the URL specified by the src attribute's value relative to the media element's node document when the src attribute was last changed.
</li>
					<li>
~IF［
%~URL~record ~EQ ~error
］
⇒
~RET ε
</li>
					<li>
%要素の `currentSrc$mM 属性 ~SET %~URL~record を`~URL直列化器$にかけた結果
◎
⌛ If urlString was obtained successfully, set the currentSrc attribute to urlString.
</li>
					<li>
~RET %~URL~record
</li>
				</ol>
			</li>
			<li>
以降は `並列的$に継続する
◎
End the synchronous section, continuing the remaining steps in parallel.
</li>
			<li>
~IF［
%~URL ~EQ ε
］
⇒
~GOTO `失敗^i
</li>
			<li>
%~URL で`資源~fetch~algo$を走らす
◎
If urlRecord was obtained successfully, run the resource fetch algorithm with urlRecord. If that algorithm returns without aborting this one, then the load failed.
</li>
			<li>
~GOTO `失敗^i
◎
↓</li>
		</ol>
	</li>
	<li>
<p>
`失敗^i ：
</p>
		<ol>
			<li>
~Assert：
この`資源~選定~algo$は`中止-$されていない（~media資源の読込みに失敗した、または，`資源~fetch~algo$は呼出されなかった）
</li>
			<li>
%~promise~list ~LET %要素 の`再生待ち~promiseたちを取り出$した結果
</li>
			<li>
次を走らす`~taskを待入する$
⇒
`専用の~media~source失敗~手続き$( %要素, %~promise~list)
を走らす
</li>
			<li>
前~段により待入された`~task$が実行し終えるまで待機する
</li>
			<li>
~RET
— %要素 は、この~algoが再び誘発されるまで，別の資源を読込もうと試みないことになる。
</li>
		</ol>
◎
Failed with attribute: Reaching this step indicates that the media resource failed to load or that the given URL could not be parsed. Take pending play promises and queue a task to run the dedicated media source failure steps with the result.
◎
Wait for the task queued by the previous step to have executed.
◎
Abort these steps. The element won't attempt to load another resource until this algorithm is triggered again.
</li>
	<li>
<p>
`子たち^i：
◎
Otherwise (mode is children)
</p>
		<ol>
			<li>⌛
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `loadstart$et の`~eventを発火-$する
◎
↑↑</li>
			<li>
<p>⌛
%~pointer ~LET ~NULL
— この~pointerは ：
</p>
				<ul>
					<li>
~NULL （  “仮想の先頭” を表す）, または  %要素 の子~nodeを保持する。
</li>
					<li>
この手続きが走っている間に
%~pointer （ ~NEQ ~NULL ）が %要素 の子でなくなったときは、
%~pointer は，子でなくなる直前における %~pointer の`前の同胞$（ ~NULL にもなり得る）に更新されるとする。
</li>
					<li>
以下において，［
%~pointer ~EQ ~NULL
］のときの %~pointer の “`次の同胞$” は、
%要素 の`最初の子$を指すとする（ ~NULL にもなり得る）。
</li>
					<li>
<p>
以下において、 “次の候補を得る” と記された所では，次の下位手続きを走らせた結果を返すとする：
</p>
						<ol>
							<li>
<p>
~WHILE［
%~pointer の`次の同胞$ ~NEQ ~NULL
］：
</p>
								<ol>
									<li>
%~pointer ~SET %~pointer の`次の同胞$
</li>
									<li>
~IF［
%~pointer は `source$e 要素である
］
⇒
~RET %~pointer
</li>
								</ol>
							</li>
							<li>
~RET ε
</li>
						</ol>
					</li>
				</ul>

◎
⌛ Let pointer be a position defined by two adjacent nodes in the media element's child list, treating the start of the list (before the first child in the list, if any) and end of the list (after the last child in the list, if any) as nodes in their own right. One node is the node before pointer, and the other node is the node after pointer. Initially, let pointer be the position between the candidate node and the next node, if there are any, or the end of the list, if it is the last node.
◎
As nodes are inserted and removed into the media element, pointer must be updated as follows:
◎
If a new node is inserted between the two nodes that define pointer
◎
• Let pointer be the point between the node before pointer and the new node. In other words, insertions at pointer go after pointer.
◎
If the node before pointer is removed
• Let pointer be the point between the node after pointer and the node before the node after pointer. In other words, pointer doesn't move relative to the remaining nodes.
◎
If the node after pointer is removed
• Let pointer be the point between the node before pointer and the node after the node before pointer. Just as with the previous case, pointer doesn't move relative to the remaining nodes.
◎
Other changes don't affect pointer.
</li>
			<li>⌛
%候補 ~LET 次の候補を得た結果
</li>
			<li>
<p>
`候補を処理する^i：<br>⌛
%~URL ~LET 次の下位手続きを走らせた結果
</p>
				<ol>
					<li>
%src ~LET この時点で［
%候補 は `src$aS 属性を有していて その値 ~NEQ 空~文字列 ならば その値 ／
~ELSE_ ε
］
◎
↓</li>
					<li>
~IF［
%src ~EQ ε
］
⇒
~RET ε
◎
⌛ Process candidate: If candidate does not have a src attribute, or if its src attribute's value is the empty string, then end the synchronous section, and jump down to the failed with elements step below.
</li>
					<li>
%~URL~record ~LET
%src を %候補 の`~node文書$に`相対的に構文解析-$した`結果の~URL~record$
◎
⌛ Let urlString and urlRecord be the resulting URL string and the resulting URL record, respectively, that would have resulted from parsing the URL specified by candidate's src attribute's value relative to the candidate's node document when the src attribute was last changed.
</li>
					<li>
~IF［
%~URL~record ~EQ ~error
］
⇒
~RET ε
◎
⌛ If urlString was not obtained successfully, then end the synchronous section, and jump down to the failed with elements step below.
</li>
					<li>
~IF［
%候補 は `type$aS 属性を有する
］~AND［
その値を`~MIME型$として（ ~codecs ~parameterがあれば，それも織り込んだ上で）構文解析した結果は，`~UAが具現化できないと知る型$を表現する
］
⇒
~RET ε
◎
⌛ If candidate has a type attribute whose value, when parsed as a MIME type (including any codecs described by the codecs parameter, for types that define that parameter), represents a type that the user agent knows it cannot render, then end the synchronous section, and jump down to the failed with elements step below.
</li>
					<li>
%要素 の `currentSrc$mM 属性 ~SET %~URL~record を`~URL直列化器$にかけた結果
◎
⌛ Set the currentSrc attribute to urlString.
</li>
					<li>
~RET %~URL~record
</li>
				</ol>
			</li>
			<li>
以降は `並列的$に継続する
◎
End the synchronous section, continuing the remaining steps in parallel.
</li>
			<li>
<p>
~IF［
%~URL ~NEQ ε
］：
</p>

<ol ><li>%~URL で`資源~fetch~algo$を走らす
</li><li>~Assert：この`資源~選定~algo$は`中止-$されていない
</li></ol>

◎
Run the resource fetch algorithm with urlRecord. If that algorithm returns without aborting this one, then the load failed.
</li>
			<li>
次を走らす`~taskを待入する$
⇒
%候補 に向けて，名前 `~errorS$et の`~eventを発火-$する
◎
Failed with elements: Queue a task to fire an event named error at the candidate element.
</li>
			<li>
以降を`同期区間$として，`安定~状態を待受ける$
◎
Await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)
</li>
			<li>⌛
%要素 の`~media資源に特有の~trackを忘れる$
◎
⌛ Forget the media element's media-resource-specific tracks.
</li>
			<li>
`次の候補を見出す^i：<br>⌛ 
%候補 ~SET 次の候補を得た結果
◎
⌛ Find next candidate: Let candidate be null.
◎
⌛ Search loop: If the node after pointer is the end of the list, then jump to the waiting step below.
◎
⌛ If the node after pointer is a source element, let candidate be that element.
◎
⌛ Advance pointer so that the node before pointer is now the node that was after pointer, and the node after pointer is the node after the node that used to be after pointer, if any.
◎
⌛ If candidate is null, jump back to the search loop step. Otherwise, jump back to the process candidate step.
</li>
			<li>⌛ 
~IF［
%候補 ~NEQ ε
］
⇒
~GOTO `候補を処理する^i
◎
↑</li>
			<li>⌛ 
%要素 の`networkState$mM 属性 ~SET `NETWORK_NO_SOURCE$mM
◎
⌛ Waiting: Set the element's networkState attribute to the NETWORK_NO_SOURCE value.
</li>
			<li>⌛ 
%要素 の`~show~poster~flag$ ~SET ~T
◎
⌛ Set the element's show poster flag to true.
</li>
			<li>⌛ 
次を走らす`~taskを待入する$
⇒
%要素 の`~load~event遅延-中~flag$ ~SET ~F
（これは`~load~eventを遅延-$する。）
◎
⌛ Queue a task to set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
			<li>
以降は `並列的$に継続する
◎
End the synchronous section, continuing the remaining steps in parallel.
</li>
			<li>
［
%~pointer の`次の同胞$ ~NEQ ~NULL
］になるまで待機する（この段は永遠に待機するかもしれない）
◎
Wait until the node after pointer is a node other than the end of the list. (This step might wait forever.)
</li>
			<li>
以降を`同期区間$として，`安定~状態を待受ける$
◎
Await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)
</li>
			<li>⌛
%要素 の`~load~event遅延-中~flag$ ~SET ~T
（これもまた、まだ発火されてなければ`~load~eventを遅延-$する。）
◎
⌛ Set the element's delaying-the-load-event flag back to true (this delays the load event again, in case it hasn't been fired yet).
</li>
			<li>⌛
`networkState$mM ~SET `NETWORK_LOADING$mM
◎
⌛ Set the networkState back to NETWORK_LOADING.
</li>
			<li>⌛
~GOTO `次の候補を見出す^i
◎
⌛ Jump back to the find next candidate step above.
</li>
		</ol>

<p class="algo-head">
`専用の~media~source失敗~手続き@
は、所与の
( `~media要素$ %要素, ~promiseの~list %~promise~list )
に対し，次を走らす：
◎
The dedicated media source failure steps with a list of promises promises are the following steps:
</p>

		<ol>
			<li>
%要素 の `error$mM 属性 ~SET `新たな~MediaError$( `MEDIA_ERR_SRC_NOT_SUPPORTED$mE )
◎
Set the error attribute to the result of creating a MediaError with MEDIA_ERR_SRC_NOT_SUPPORTED.
</li>
			<li>
%要素 の`~media資源に特有の~trackを忘れる$
◎
Forget the media element's media-resource-specific tracks.
</li>
			<li>
%要素 の `networkState$mM 属性 ~SET `NETWORK_NO_SOURCE$mM
◎
Set the element's networkState attribute to the NETWORK_NO_SOURCE value.
</li>
			<li>
%要素 の`~show~poster~flag$ ~SET ~T
◎
Set the element's show poster flag to true.
</li>
			<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `~errorM$et の`~eventを発火-$する
◎
Fire an event named error at the media element.
</li>
			<li>
`再生待ち~promiseたちを却下-$する
( %~promise~list, `NotSupportedError$E 例外 )
◎
Reject pending play promises with promises and a "NotSupportedError" DOMException.
</li>
			<li>
%要素 の`~load~event遅延-中~flag$ ~SET ~F
（これは`~load~eventを遅延-$する。）
◎
Set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
		</ol>
	</li>
</ol>

<p class="algo-head">
`~media要素$ %要素 の
`資源~fetch~algo@
は、所与の［
`~URL$ ／ `~media提供元~obj$
］ %入力 に対し，次を走らす：
◎
The resource fetch algorithm for a media element and a given URL record or media provider object is as follows:
</p>

<ol>
	<li>
( %~URL, %~media提供元~obj ) ~LET ［
%入力 は`~media提供元~obj$ならば ( ε, %入力 ) ／
~ELSE_ ( %入力, %入力 の`~obj$url )
］
◎
If the algorithm was invoked with media provider object or a URL record whose object is a media provider object, then let mode be local. Otherwise let mode be remote.
</li>
	<li>
%現~media資源 ~LET ［
%~media提供元~obj ~NEQ ~NULL ならば それが与える資源 ／
~ELSE_ %~URL から得られることになる資源 
］
◎
If mode is remote, then let the current media resource be the resource given by the URL record passed to this algorithm; otherwise, let the current media resource be the resource given by the media provider object. Either way, the current media resource is now the element's media resource.
</li>
	<li>
%要素 の`~media資源$ ~SET %現~media資源
◎
↑</li>
	<li>
%要素 の`処理待ち~text~trackの~list$から
`~media資源に特有の~text~track$をすべて除去する
◎
Remove all media-resource-specific text tracks from the media element's list of pending text tracks, if any.
</li>
	<li>
<p>
~IF［
%~media提供元~obj ~EQ ~NULL
］：
◎
Run the appropriate steps from the following list:
◎
If mode is remote
</p>

		<ol>
			<li>
<p>
~UAの任意選択で、次の下位手続きを走らす
— これは［
利用者から明示的に要請されるまで，~UAは資源を~fetchしようと試みない
］ことを意図する場合に期待される挙動になる（例：
`preload$aM 属性の `none$v ~keywordを実装する仕方として）：
◎
Optionally, run the following substeps. This is the expected behavior if the user agent intends to not attempt to fetch the resource until the user requests it explicitly (e.g. as a way to implement the preload attribute's none keyword).
</p>

				<ol>
					<li>
%要素 の `networkState$mM ~SET `NETWORK_IDLE$mM
◎
Set the networkState to NETWORK_IDLE.
</li>
					<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `suspend$et の`~eventを発火-$する
◎
Queue a task to fire an event named suspend at the element.
</li>
					<li>
次を走らす`~taskを待入する$
⇒
%要素 の`~load~event遅延-中~flag$ ~SET ~F
（これは`~load~eventを遅延-$する。）
◎
Queue a task to set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
					<li>
前~段の~taskが走るまで待機する
◎
Wait for the task to be run.
</li>
					<li>
実装により定義される~eventを待機する（例：利用者は %要素 の再生を始めるよう要請している。）
◎
Wait for an implementation-defined event (e.g. the user requesting that the media element begin playback).
</li>
					<li>
%要素 の`~load~event遅延-中~flag$ ~SET ~T
（これもまた、まだ発火されてなければ`~load~eventを遅延-$する。）
◎
Set the element's delaying-the-load-event flag back to true (this delays the load event again, in case it hasn't been fired yet).
</li>
					<li>
%要素 の `networkState$mM ~SET `NETWORK_LOADING$mM
◎
Set the networkState to NETWORK_LOADING.
</li>
				</ol>
			</li>
			<li>
%要請 ~LET
次を与える下で，`~CORSになり得る要請を作成-$した結果
⇒
( %~URL, `media^l, %要素 の`crossorigin$aM 内容~属性の値 )
◎
Let request be the result of creating a potential-CORS request given current media resource's URL record, "media", and the media element's crossorigin content attribute value.
</li>
			<li>
%要請 の`~client$rq ~SET  %要素 の`~node文書$の `Window$I ~objの`環境~設定群~obj$
◎
Set request's client to the media element's node document's Window object's environment settings object and type to "audio" if the media element is an audio element and to "video" otherwise.
</li>
			<li>
%要請 の`種別$rq ~SET %要素 に応じて［
`audio$e 要素であるならば `audio^l ／
`video$e 要素であるならば  `video^l
］
◎
↑</li>
			<li>
<p>
%要請 を`~fetch$する
◎
Fetch request.
</p>

<div >
<p>
このようにして得られた応答の`非安全~応答$があれば それが`~media~data$を包含し、［
`~CORS同一生成元$, `~CORS非同一生成元$
］のいずれにもなり得る
— それに応じて、次に影響する：
</p>

<ul><li>`~media~data$内で参照された字幕は~APIに公開されるかどうか。
</li><li>`video$e 要素に対しては、動画が `canvas$e 上に描かれるとき，その `canvas^e は~taintedになるかどうか。
</li></ul>

◎
The response's unsafe response obtained in this fashion, if any, contains the media data. It can be CORS-same-origin or CORS-cross-origin; this affects whether subtitles referenced in the media data are exposed in the API and, for video elements, whether a canvas gets tainted when the video is drawn on it.
</div>

<p>
`~stall~timeout@
は、~UAにより定義される時間の長さであり，およそ 3 秒にするべきである。
%要素 が`~media~data$を得ようと能動的に試みていて，`~stall~timeout$に等しい時間長までに~dataを受信するのに失敗した場合、~UAは，次を走らす`~taskを待入し$~MUST
⇒
%要素 に向けて，名前 `stalled$et の`~eventを発火-$する
◎
The stall timeout is a user-agent defined length of time, which should be about three seconds. When a media element that is actively attempting to obtain media data has failed to receive any data for a duration equal to the stall timeout, the user agent must queue a task to fire an event named stalled at the element.
</p>

<p>
~UAは、利用者に［
選択的に阻む ／
`~media~data$の~downloadを低速にする
］ことを許容して~MAY。
%要素 の~download がまるごと阻まれたときは、~UAは，それが~stallしたかのように動作し~MUST（接続が~closeされたかのように動作するのとは~~対照的に）。
~downloadの~rateは，~UAにより自動的に減速されても~MAY
— 例えば、同じ帯域幅を共有している他の接続との兼ね合いをとるため。
◎
User agents may allow users to selectively block or slow media data downloads. When a media element's download has been blocked altogether, the user agent must act as if it was stalled (as opposed to acting as if the connection was closed). The rate of the download may also be throttled automatically by the user agent, e.g. to balance the download with other connections sharing the same bandwidth.
</p>

<div id="resourceSuspend">
<p>
~UAは、いつでも，資源の~downloadを休止して~MAY
— 例えば，次の場合など：
</p>

<ul><li>
<p>
1 時間の~media資源を 5 分だけ~bufferした後，利用者が資源を再生するかどうか決めるのを待機している間
</p>
<p class="note">注記：
`autoplay$aM 属性が不在の下でも、
`preload$aM 属性は、~buffer量に関して，作者が~~適切と~~考えている~hintを提供する。
</p>

</li><li>利用者が対話的~資源に入力するのを待機している間
</li><li>利用者が頁から~navigateして離れたとき
</li></ul>

<p>
資源の~downloadを休止する場合、~UAは：
</p>

				<ul>
					<li>
<p>
休止-時には、次を走らす`~taskを待入し$~MUST：
</p>

<ol><li>%要素 の `networkState$mM 属性 ~SET `NETWORK_IDLE$mM
</li><li>%要素 に向けて名前 `suspend$et の`~eventを発火-$する
</li></ol>

					</li>
					<li>
再開-時には、次を走らす`~taskを待入し$~MUST
⇒
%要素 の `networkState$mM 属性 ~SET `NETWORK_LOADING$mM
</li>
<li>
休止してから再開するまでの間（これらの~taskを待入する合間）は、読込みは休止される（なので、上に述べたように， `progress$et ~eventは発火されない）。
</li>
					<li>
~downloadを完全に休止すると決めたとき
— 例えば、利用者から再生を開始するよう指示されるまで，以降の内容は~downloadせずに待機する場合 —
は、次を走らす`~taskを待入し$~MUST
⇒
%要素 の`~load~event遅延-中~flag$ ~SET ~F
（これは`~load~eventを遅延-$する。）
</li>
				</ul>
◎
User agents may decide to not download more content at any time, e.g. after buffering five minutes of a one hour media resource, while waiting for the user to decide whether to play the resource or not, while waiting for user input in an interactive resource, or when the user navigates away from the page. When a media element's download has been suspended, the user agent must queue a task, to set the networkState to NETWORK_IDLE and fire an event named suspend at the element. If and when downloading of the resource resumes, the user agent must queue a task to set the networkState to NETWORK_LOADING. Between the queuing of these tasks, the load is suspended (so progress events don't fire, as described above).
◎
The preload attribute provides a hint regarding how much buffering the author thinks is advisable, even in the absence of the autoplay attribute.
◎
When a user agent decides to completely suspend a download, e.g., if it is waiting until the user starts playback before downloading any further content, the user agent must queue a task to set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</div>

<p>
~UAは、資源を~fetchするために必要とされる手段を何であれ利用して~MAY（この／他の仕様により課される拘束の中で）
— 例えば［
~network~errorに面したときに~serverへ再接続する ／
~HTTP範囲~検索取得~要請を利用する ／
~streaming~protocolに切替える
］など。
~UAが資源は~error含みと見なすのは、それ以上~fetchするのをあきらめた場合に限られ~MUST。
◎
The user agent may use whatever means necessary to fetch the resource (within the constraints put forward by this and other specifications); for example, reconnecting to the server in the face of network errors, using HTTP range retrieval requests, or switching to a streaming protocol. The user agent must consider a resource erroneous only if it has given up trying to fetch it.
</p>

<p>
`~media資源$の形式を決定するときは、~UAは，`音声／動画を特に~sniffする規則$を利用し~MUST。
◎
To determine the format of the media resource, the user agent must use the rules for sniffing audio and video specifically.
</p>

<p>
読込みが休止されていない間は（下を見よ）、~UAは：
◎
↓</p>

				<ul>
					<li>
［
毎 350ms （±200ms）ごと ／ ~byteが受信される度
］のうち，<em>低頻度</em>の方で、次を走らす`~taskを待入する$
⇒
要素に向けて，名前 `progress$et の`~eventを発火-$する
◎
While the load is not suspended (see below), every 350ms (±200ms) or for every byte received, whichever is least frequent, queue a task to fire an event named progress at the element.
</li>
					<li>
<p>
~fetchされた~dataを処理する
`~network用~task源$からの各`~task$は、
`即時$に次を走らす`~taskを待入し$~MUST
⇒
下に与える`~media~data処理~手続き~list$を走らす
</p>
<p>
（このためには新たな~taskが利用される
— 下に述べる作業が、`~network用~task源$ではなく，`~media要素~event~task源$から生じるようにするため。）
</p>
◎
The networking task source tasks to process the data as it is being fetched must each immediately queue a task to run the first appropriate steps from the media data processing steps list below. (A new task is used for this so that the work described below occurs relative to the media element event task source rather than the networking task source.)
</li>
				</ul>

<div class="p">
<p>
`~media資源$の~fetchingの一部として，`~network用~task源$から最後の `~task$が`待入され$たとき（すなわち，~downloadが完了したとき）は、~UAは次をし~MUST：
</p>

				<ol>
					<li>
<p>
~IF［
当の~fetchingが
— ~media~dataの復号-時も含めて —
~errorなしに完了した
］~AND［
すべての~dataは~network~accessを要せずに~UAに可用である
］
⇒
この`資源~選定~algo$を`中止-$する
<!-- 
~GOTO `最終~段^i
 -->
</p>

<p>
これは、決して起こらないかもしれない
— 例：
~Web~radioなどの無限~資源を~streamingしているとき ／
資源は ~UAが~dataを~cacheする能より長い場合。
</p>
					</li>
				</ol>

◎
When the networking task source has queued the last task as part of fetching the media resource (i.e. once the download has completed), if the fetching process completes without errors, including decoding the media data, and if all of the data is available to the user agent without network access, then, the user agent must move on to the final step below. This might never happen, e.g. when streaming an infinite resource such as Web radio, or if the resource is longer than the user agent's ability to cache data.
</div>

<p>
~UAは、［
`~media資源$の ある部分を得るためには，依然として~networkに~accessする必要があり得る間
］は，この段に留まり続け~MUST。
◎
While the user agent might still need network access to obtain parts of the media resource, the user agent must remain on this step.
</p>

<p class="example">
例えば，~UAは、動画の前半を破棄した場合は，この段に留まり続けることになる
— `再生は終止して$いるとしても、利用者には始端へ~seekして戻る~~機会が常にあるので。
事実，この状況において`再生は終止して$いるときは、先に述べたように，~UAは `suspend$et ~eventを発火することになる。
◎
For example, if the user agent has discarded the first half of a video, the user agent will remain at this step even once the playback has ended, because there is always the chance the user will seek back to the start. In fact, in this situation, once playback has ended, the user agent will end up firing a suspend event, as described earlier.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ %~media提供元~obj ~NEQ ~NULL ）：
◎
Otherwise (mode is local)
</p>

		<ul>
			<li>
%現~media資源 により述べられる資源があれば，それが`~media~data$を包含する。
それは`~CORS同一生成元$である。
◎
The resource described by the current media resource, if any, contains the media data. It is CORS-same-origin.
</li>
			<li>
<p>
~UAは、`~media資源$の形式を次に従って決定し~MUST：
</p>

<ul><li>%現~media資源 が生の~data~streamである場合（例えば `File$I ~objからの）
⇒
`音声／動画を特に~sniffする規則$を利用する
</li><li>他の場合（~data~streamは予め復号-済みである）
⇒
形式は、関連する仕様により与えられるそれとする
</li></ul>

◎
If the current media resource is a raw data stream (e.g. from a File object), then to determine the format of the media resource, the user agent must use the rules for sniffing audio and video specifically. Otherwise, if the data stream is pre-decoded, then the format is the format given by the relevant specification.
</li>
			<li>
%現~media資源 用に新たな~dataが可用になる度に、次を走らす`~taskを待入する$
⇒
下に与える`~media~data処理~手続き~list$を走らす
◎
Whenever new data for the current media resource becomes available, queue a task to run the first appropriate steps from the media data processing steps list below.
</li>
			<li>
<p>
%現~media資源 は永続的に尽きた時点で（例： `Blob$I のすべての~byteは処理-済みになった）：
</p>
				<ol>
					<li>
~IF［
復号-時に~errorが生じた
］
⇒
~RET
</li>
					<li>
この`資源~選定~algo$を`中止-$する
<!-- 
~GOTO `最終~段^i
 -->
</li>
				</ol>
<p>
これは、決して起こらないかもしれない
— 例えば %現~media資源 は `MediaStream$I である場合。
</p>
◎
When the current media resource is permanently exhausted (e.g. all the bytes of a Blob have been processed), if there were no decoding errors, then the user agent must move on to the final step below. This might never happen, e.g. if the current media resource is a MediaStream.
</li>
		</ul>

<p class="algo-head">
`~media~data処理~手続き~list@
は、次のうち最初に該当する項に対応する手続きに従わ~MUST：
◎
The media data processing steps list is as follows:
</p>

<dl class="switch">
	<dt>
`~media~data$は，~network~errorに因り全く~fetchできず、~UAは資源を~fetchしようと試行するのをあきらめたとき：
◎
If the media data cannot be fetched at all, due to network errors, causing the user agent to give up trying to fetch the resource
</dt>
	<dt>
`~media~data$は~fetchできたが、全く具現化できないことが~~判明したとき：
◎
If the media data can be fetched but is found by inspection to be in an unsupported format, or can otherwise not be rendered at all
</dt>
	<dd>
<div class="p">
<p>
すなわち、次のいずれかに該当する場合：
</p>

<ul><li>［
~UAが %現~media資源 は利用可能かどうか確立する前
］に生じた，［
~DNS~error／
~HTTP［
4xx ／ 5xx
］~error（あるいは，他の~protocolにおける等価なもの）／
他の致命的な~network~error
］
</li><li>~fileは ~UAが~supportしない容器~形式を利用している
</li><li>すべての~dataは ~UAが~supportしない ~codecs を利用している
</li></ul>

<p>
~UAは、次を実行し~MUST：
</p>
◎
DNS errors, HTTP 4xx and 5xx errors (and equivalents in other protocols), and other fatal network errors that occur before the user agent has established whether the current media resource is usable, as well as the file using an unsupported container format, or using unsupported codecs for all the data, must cause the user agent to execute the following steps:
</div>

		<ol>
			<li>
~UAは~fetchingを取消すべきである
◎
The user agent should cancel the fetching process.
</li>
			<li>
この`資源~fetch~algo$を終えて、`資源~選定~algo$へ ~RET する
◎
Abort this subalgorithm, returning to the resource selection algorithm.
</li>
		</ol>
	</dd>

	<dt id="found-another-audio-track">
`~media資源$に音声~trackが見出されたときは：
◎
If the media resource is found to have an audio track
</dt>
	<dd>
		<ol>
			<li>
%音声~track ~LET その音声~trackを表現する，新たな `AudioTrack$I ~obj
◎
Create an AudioTrack object to represent the audio track.
</li>
			<li>
%~track~list ~LET %要素 の`audioTracks$mM 属性が与える `AudioTrackList$I ~obj
◎
↓</li>
			<li>
%~track~list を %音声~track で更新する
◎
Update the media element's audioTracks attribute's AudioTrackList object with the new AudioTrack object.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
Let enable be unknown.
</p>
				<ul>
					<li>
<p>
［［
%現~media資源 ／ %~URL
］は、特定0の音声~trackの集合を可能化するよう指示している
］~OR［
~UAは、利用者の体験を改善するために，特定の音声~trackの選択を手助けするような情報を有している
］］~AND［
%音声~track は，それにより可能化するものに該当する
］
◎
If either the media resource or the URL of the current media resource indicate a particular set of audio tracks to enable, or if the user agent has information that would facilitate the selection of specific audio tracks to improve the user's experience, then: if this audio track is one of the ones to enable, then set enable to true, otherwise, set enable to false.
</p>

<p class="example">
これは`~media素片の構文$により誘発され得る。
加えて、例えば，~UAが~stereo音声~trackに代えて 5.1 ~surround音響による音声~trackを選択したときも誘発される。
◎
This could be triggered by media fragment syntax, but it could also be triggered e.g. by the user agent selecting a 5.1 surround sound audio track over a stereo audio track.
</p>
					</li>
					<li>
%~track~list 内には`可能化-済みの音声~track$はまだない
◎
If enable is still unknown, then, if the media element does not yet have an enabled audio track, then set enable to true, otherwise, set enable to false.
</li>
				</ul>
<p>
…ならば
⇒
%音声~track を可能化する
◎
If enable is true, then enable this audio track, otherwise, do not enable this audio track.
</p>
			</li>
			<li>
<p>
%~track~list に向けて，次のようにされた`~eventを発火-$する
</p>

<ul ><li>`TrackEvent$I を利用する
</li><li>名前 `addtrack$et
</li><li>`track$m 属性 ~SET %音声~track に初期化する
</li></ul>
◎
Fire an event named addtrack at this AudioTrackList object, using TrackEvent, with the track attribute initialized to the new AudioTrack object.
</li>
		</ol>
	</dd>

	<dt id="found-another-video-track">
`~media資源$に動画~trackが見出されたときは：
◎
If the media resource is found to have a video track
</dt>
	<dd>
		<ol>
			<li>
%動画~track ~LET その動画~trackを表現する，新たな `VideoTrack$I ~obj
◎
Create a VideoTrack object to represent the video track.
</li>
			<li>
%~track~list ~LET %要素 の`videoTracks$mM 属性が与える `VideoTrackList$I ~obj
◎
↓</li>
			<li>
%~track~list を %動画~track で更新する
◎
Update the media element's videoTracks attribute's VideoTrackList object with the new VideoTrack object.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
Let enable be unknown.
</p>
				<ul>
					<li>
<p>
［［［
%現~media資源 ／ %~URL
］は、特定0の動画~trackの集合を可能化するよう指示している
］~OR［
~UAは、利用者の体験を改善するために 特定の動画~trackの選択を手助けするような情報を有している
］］~AND［
%動画~track は そのような動画~trackのうち最初のものである
］
◎
If either the media resource or the URL of the current media resource indicate a particular set of video tracks to enable, or if the user agent has information that would facilitate the selection of specific video tracks to improve the user's experience, then: if this video track is the first such video track, then set enable to true, otherwise, set enable to false.
</p>

<p class="example">
これもまた`~media素片の構文$により誘発され得る。
◎
This could again be triggered by media fragment syntax.
</p>
					</li>
					<li>
%~track~list 内には まだ`選定-済みの動画~track$はまだない
◎
If enable is still unknown, then, if the media element does not yet have a selected video track, then set enable to true, otherwise, set enable to false.
</li>
				</ul>
<div class="p">
<p>
…ならば：
</p>
<ol ><li>
~IF［
すでに選択されている動画~trackはある
］
⇒
それを未選択にする
— この場合、<a href="#toggle-video-track">`change^et ~eventが発火されることになる</a>。
</li><li>%動画~track を選択する
</li></ol>

◎
If enable is true, then select this track and unselect any previously selected video tracks, otherwise, do not select this video track. If other tracks are unselected, then a change event will be fired.
</div>
			</li>
			<li>
<p>
%~track~list に向けて，次のようにされた`~eventを発火-$する：
</p>

<ul ><li>`TrackEvent$I を利用する
</li><li>名前 `addtrack$et
</li><li>`track$m 属性 ~SET %動画~track に初期化する
</li></ul>
◎
Fire an event named addtrack at this VideoTrackList object, using TrackEvent, with the track attribute initialized to the new VideoTrack object.
</li>
		</ol>
	</dd>

	<dt id="getting-media-metadata">
`~media資源$の［
時間長, 寸法, その他の~metadata
］を決定するに十分な`~media~data$が~fetchされたときは：
◎
Once enough of the media data has been fetched to determine the duration of the media resource, its dimensions, and other metadata
</dt>
	<dd>
<p>
これは、当の資源が利用可能であることを指示する。
~UAは、次に従わ~MUST：
◎
This indicates that the resource is usable. The user agent must follow these substeps:
</p>

		<ol>
			<li>
%~media時間軸 ~LET `~media~data$に基づいて，`~media時間軸を確立-$した結果の時間軸
— ［
`現在の再生~位置$, `可能な最も早い位置$
］の目的において
◎
Establish the media timeline for the purposes of the current playback position and the earliest possible position, based on the media data.
</li>
		<li>
`時間軸~offset$ ~SET `~media資源$は
%~media時間軸 内の時刻 0 に対応する明示的な時刻＆日付を与えているならば それ ／
~ELSE_ `NaN^jv
］ 
◎
Update the timeline offset to the date and time that corresponds to the zero time in the media timeline established in the previous step, if any. If no explicit time and date is given by the media resource, the timeline offset must be set to Not-a-Number (NaN).
</li>
			<li>
( `現在の再生~位置$, `公式的な再生~位置$ )
~SET 
( `可能な最も早い位置$, `可能な最も早い位置$ )
◎
Set the current playback position and the official playback position to the earliest possible position.
</li>
			<li>
<p>
%要素 の `duration$mM 属性 ~SET %~media時間軸 上の，資源の最後の~frameの時刻が［
既知ならば それ ／
既知でなければ正の `Infinity^jv （例： 原則的に無限の~stream）
］
◎
Update the duration attribute with the time of the last frame of the resource, if known, on the media timeline established above. If it is not known (e.g. a stream that is in principle infinite), update the duration attribute to the value positive Infinity.
</p>

<p class="note">注記：
~UAは、この時点で，次を走らす`~taskを待入する$
<a href="#durationChange">ことになる</a>
⇒
%要素 に向けて，名前 `durationchange$et の`~eventを発火-$する
◎
The user agent will queue a task to fire an event named durationchange at the element at this point.
</p>

			</li>
			<li>
<p>
~IF［
%要素 は `video$e 要素である
］：
</p>

				<ol>
					<li>
%要素 の［
`videoWidth$mV, `videoHeight$mV
］属性を設定する
</li>
					<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `resize$et の`~eventを発火-$する
</li>
				</ol>

<p class="note">注記：
寸法が後で変化した場合、更に `resize$et ~eventが発火されることになる。
</p>

◎
For video elements, set the videoWidth and videoHeight attributes, and queue a task to fire an event named resize at the media element.
◎
Further resize events will be fired if the dimensions subsequently change.
</li>
			<li>

<p>
%要素 の `readyState$mM 属性 ~SET `HAVE_METADATA$mM
◎
Set the readyState attribute to HAVE_METADATA.
</p>

<p class="note">注記：
この段で `readyState$mM 属性を設定する一部として、
`loadedmetadata$et ~eventが<a href="#fire-loadedmetadata">発火されることになる</a>。
◎
A loadedmetadata DOM event will be fired as part of setting the readyState attribute to a new value.
</p>

			</li>
			<li>
%~seek済み ~LET ~F
◎
Let jumped be false.
</li>
			<li>
<p>
~IF［
%要素 の`既定の再生~開始-位置$ ~GT 0
］：
</p>
<ol ><li>その時刻へ`~seek$する
</li><li>%~seek済み ~SET ~T
</li></ol>

◎
If the media element's default playback start position is greater than zero, then seek to that time, and let jumped be true.
</li>
			<li>
%要素 の`既定の再生~開始-位置$ ~SET 0
◎
Let the media element's default playback start position be zero.
</li>
			<li>
%初期~再生~位置 ~LET 0
◎
Let the initial playback position be zero.
</li>
			<li>
<div class="p">
<p>
~IF［［
%現~media資源 ／ %~URL
］は、特定0の開始-時刻を指示している
］：
</p>
				<ol>
					<li>
%初期~再生~位置 ~SET その時刻
</li>
					<li>
~IF［
%~seek済み ~EQ ~F
］
⇒
その時刻へ`~seek$する
</li>
				</ol>
◎
If either the media resource or the URL of the current media resource indicate a particular start time, then set the initial playback position to that time and, if jumped is still false, seek to that time.
</div>

<p class="example">
例えば，~media形式が`~media素片の構文$を~supportする場合、`素片$urlを利用して，始端~位置を指示できる。
◎
For example, with media formats that support media fragment syntax, the fragment can be used to indicate a start position.
</p>

			</li>
			<li>
~IF［
`可能化-済みの音声~track$はまだない
］
⇒
音声~track `どの？^tnote を可能化する
— これは、
<a href="~HTMLemb#toggle-audio-track">`change^et ~eventを発火させる</a>
ことになる。
◎
If there is no enabled audio track, then enable an audio track. This will cause a change event to be fired.
</li>
			<li>
~IF［
`選定-済みの動画~track$はなだない
］
⇒
動画~track `どの？^tnoteを選択する
— これは、
<a href="~HTMLemb#toggle-video-track">`change^et ~eventを発火させる</a>
ことになる。
◎
If there is no selected video track, then select a video track. This will cause a change event to be fired.
</li>
		</ol>

<p>
%要素 の `readyState$mM 属性 `HAVE_CURRENT_DATA$mM に達したときは、
<a href="#fire-loadeddata">`loadeddata^et ~eventを発火した後に</a>
⇒
%要素 の`~load~event遅延-中~flag$ ~SET ~F
（これは`~load~eventを遅延-$する。）
◎
Once the readyState attribute reaches HAVE_CURRENT_DATA, after the loadeddata event has been fired, set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</p>

<p class="note">注記：
各`~media資源$用の~metadataを依然として~fetchしている間，
~network利用量を抑制しようと試みている~UAは、<a href="#resourceSuspend">前に述べた規則</a>に従って，この時点で~bufferするのも停止することになる
— それは、 `networkState$mM 属性を `NETWORK_IDLE$mM 値に切替えて， `suspend$et ~eventの発火することを孕む。
◎
A user agent that is attempting to reduce network usage while still fetching the metadata for each media resource would also stop buffering at this point, following the rules described previously, which involve the networkState attribute switching to the NETWORK_IDLE value and a suspend event firing.
</p>

<p class="note">注記：
~UAには、再生する前に，`~media資源$の時間長を決定して この段を遂げることが<em>要求される</em>。
◎
The user agent is required to determine the duration of the media resource and go through this step before playing.
</p>
	</dd>

	<dt>
`~media資源$全体が~fetchされたときは（復号-前にもなり得る）：
◎
Once the entire media resource has been fetched (but potentially before any of it has been decoded)
</dt>
	<dd>
		<ol>
			<li>
%要素 に向けて，名前 `progress$et の`~eventを発火-$する
◎
Fire an event named progress at the media element.
</li>
			<li>
%要素 の `networkState$mM ~SET `NETWORK_IDLE$mM
</li>
			<li>
%要素 に向けて，名前 `suspend$et の`~eventを発火-$する
◎
Set the networkState to NETWORK_IDLE and fire an event named suspend at the media element.
</li>
		</ol>
<p>
~UAは、`~media~data$の一部でも破棄して，それを再び得るために~network活動を再開する必要が生じた場合、次を走らす`~taskを待入し$~MUST
⇒
%要素 の `networkState$mM ~SET `NETWORK_LOADING$mM
◎
If the user agent ever discards any media data and then needs to resume the network activity to obtain it again, then it must queue a task to set the networkState to NETWORK_LOADING.
</p>

<p class="note">注記：
~UAが読込んだ`~media資源$を保てる場合、この~algoは`中止-$されることになる。
◎
If the user agent can keep the media resource loaded, then the algorithm will continue to its final step below, which aborts the algorithm.
</p>
	</dd>

	<dt>
`~media~data$の一部が受信された後，接続は中断されたため、~UAは資源を~fetchしようと試行するのをあきらめたとき：
◎
If the connection is interrupted after some media data has been received, causing the user agent to give up trying to fetch the resource
</dt>
	<dd>
<div class="p">
<p>
すなわち、
%現~media資源 は利用可能かどうか確立された（すなわち， %要素 の`readyState$mM 属性 ~NEQ `HAVE_NOTHING$mM になった）後に，致命的な~network~errorが生じた場合。
</p>
<p>
~UAは次を実行し~MUST：
</p>

◎
Fatal network errors that occur after the user agent has established whether the current media resource is usable (i.e. once the media element's readyState attribute is no longer HAVE_NOTHING) must cause the user agent to execute the following steps:
</div>

		<ol>
			<li>
~UAは~fetchingを取消すべきである
◎
The user agent should cancel the fetching process.
</li>
			<li>
%要素 の `error$mM 属性 ~SET `新たな~MediaError$( `MEDIA_ERR_NETWORK$mE )
◎
Set the error attribute to the result of creating a MediaError with MEDIA_ERR_NETWORK.
</li>
			<li>
%要素 の `networkState$mM 属性 ~SET `NETWORK_IDLE$mM
◎
Set the element's networkState attribute to the NETWORK_IDLE value.
</li>
			<li>
%要素 の`~load~event遅延-中~flag$ ~SET ~F
（これは`~load~eventを遅延-$する。）
◎
Set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
			<li>
%要素 に向けて，名前 `~errorM$et の`~eventを発火-$する
◎
Fire an event named error at the media element.
</li>
			<li>
この`資源~選定~algo$を`中止-$する
◎
Abort the overall resource selection algorithm.
</li>
		</ol>
	</dd>

	<dt id="fatal-decode-error">
`~media~data$は~~壊れている：
◎
If the media data is corrupted
</dt>
	<dd>
<div class="p">
<p>
すなわち、~UAが %現~media資源 は利用可能かどうか確立した（すなわち， %要素 の`readyState$mM 属性は `HAVE_NOTHING$mM でなくなった）後に，`~media~data$の復号-時に致命的な~errorが生じた場合。
</p>

<p>
~UAは次を実行し~MUST：
</p>
◎
Fatal errors in decoding the media data that occur after the user agent has established whether the current media resource is usable (i.e. once the media element's readyState attribute is no longer HAVE_NOTHING) must cause the user agent to execute the following steps:
</div>

		<ol>
			<li>
~UAは~fetchingを取消すべきである
◎
The user agent should cancel the fetching process.
</li>
			<li>
%要素 の `error$mM 属性 ~SET `新たな~MediaError$( `MEDIA_ERR_DECODE$mE )
◎
Set the error attribute to the result of creating a MediaError with MEDIA_ERR_DECODE.
</li>
			<li>
%要素 の `networkState$mM 属性 ~SET `NETWORK_IDLE$mM
◎
Set the element's networkState attribute to the NETWORK_IDLE value.
</li>
			<li>
%要素 の`~load~event遅延-中~flag$ ~SET ~F
（これは`~load~eventを遅延-$する。）
◎
Set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
			<li>
%要素 に向けて，名前 `~errorM$et の`~eventを発火-$する
◎
Fire an event named error at the media element.
</li>
			<li>
この`資源~選定~algo$を`中止-$する
◎
Abort the overall resource selection algorithm.
</li>
		</ol>
	</dd>

	<dt>
`~media~data$の~fetchingは 利用者により中止されたとき：
◎
If the media data fetching process is aborted by the user
</dt>
	<dd>
<p>
利用者により~fetchingが中止される例としては、利用者が “停止-” ~buttonを押したときが挙げられる。
~UAは、次の手続きを実行し~MUST。
この手続きは、［
この手続き `を走らせている手続き？^tnote
が走っている間に `load()$mM ~method自身が呼出された場合
］には生じない
— 上の手続き`どれ？^tnoteがその種の中止-を取扱うので。
◎
The fetching process is aborted by the user, e.g. because the user pressed a "stop" button, the user agent must execute the following steps. These steps are not followed if the load() method itself is invoked while these steps are running, as the steps above handle that particular kind of abort.
</p>

		<ol>
			<li>
~UAは~fetchingを取消すべきである
◎
The user agent should cancel the fetching process.
</li>
			<li>
`error$mM 属性 ~SET 
`新たな~MediaError$( `MEDIA_ERR_ABORTED$mE )
◎
Set the error attribute to the result of creating a MediaError with MEDIA_ERR_ABORTED.
</li>
			<li>
%要素 に向けて，名前 `abort$et の`~eventを発火-$する
◎
Fire an event named abort at the media element.
</li>
			<li>
<p>
~IF［
%要素 の`readyState$mM 属性~値 ~EQ `HAVE_NOTHING$mM
］：
</p>

<ol ><li>%要素 の `networkState$mM 属性 ~SET `NETWORK_EMPTY$mM
</li><li>%要素 の`~show~poster~flag$ ~SET ~T
</li><li>%要素 に向けて，名前 `emptied$et の`~eventを発火-$する
</li></ol>

◎
If the media element's readyState attribute has a value equal to HAVE_NOTHING, set the element's networkState attribute to the NETWORK_EMPTY value, set the element's show poster flag to true, and fire an event named emptied at the element.
</li>
			<li>
~ELSE
⇒
%要素 の`networkState$mM 属性 ~SET `NETWORK_IDLE$mM
◎
Otherwise, set the element's networkState attribute to the NETWORK_IDLE value.
</li>
			<li>
%要素 の`~load~event遅延-中~flag$ ~SET ~F
（これは`~load~eventを遅延-$する。）
◎
Set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
			<li>
この`資源~選定~algo$を`中止-$する
◎
Abort the overall resource selection algorithm.
</li>
		</ol>

	</dd>

	<dt id="non-fatal-media-error">
~fetchした`~media~data$の一部に具現化できないものがある：
◎
If the media data can be fetched but has non-fatal errors or uses, in part, codecs that are unsupported, preventing the user agent from rendering the content completely correctly but not preventing playback altogether
</dt>
	<dd>
<p>
すなわち，次のいずれかに該当するが、それでも再生はできる：
</p>

<ul ><li>~fetchできるが、致命的でない~errorまたは利用が生じた
</li><li>~dataの一部に~supportされない ~codecs があり、~UAは内容を完全に正しく具現化できない
</li><li>~serverは、部分的には利用可能だが最適には具現化できない~dataを返している
</li></ul>

<p>
~UAは、自身が取扱える~dataだけ具現化して，残りは無視し~MUST。
</p>
◎
The server returning data that is partially usable but cannot be optimally rendered must cause the user agent to render just the bits it can handle, and ignore the rest.
</dd>

	<dt id="found-a-media-resource-specific-timed-track">
`~media資源$が［
~UAが~supportする，`~media資源に特有の~text~track$
］を宣言していることが見出されたとき：
◎
If the media resource is found to declare a media-resource-specific text track that the user agent supports
</dt>
	<dd>
<p>
~IF［
`~media~data$は`~CORS同一生成元$である
］
⇒
関連する~dataで`~media資源に特有の~text~trackを公開する手続き$を走らす
◎
If the media data is CORS-same-origin, run the steps to expose a media-resource-specific text track with the relevant data.
</p>

<p class="note">注記：
非同一生成元の動画は、その字幕を公開しない
— そうすると、敵対的~siteが，利用者の~intranet上の機密的な動画から字幕を読取るような攻撃を許容することになるので。
◎
Cross-origin videos do not expose their subtitles, since that would allow attacks such as hostile sites reading subtitles from confidential videos on a user's intranet.
</p>

	</dd>
</dl>
<!-- ~media~data処理~手続き~list  -->

<p>
◎
Final step: If the user agent ever reaches this step (which can only happen if the entire resource gets loaded and kept available): abort the overall resource selection algorithm.
</p>

	</li>

</ol>


<div class="p">

<p class="algo-head">
`~media要素$ %要素 の
`~media資源に特有の~trackを忘れる@
ときは、次を走らせ~MUST：
</p>

<ol><li>%要素 の`~text~trackの~list$から`~media資源に特有の~text~track$すべてを除去する
</li><li>%要素 の `audioTracks$mM 属性が~~保持する `AudioTrackList$I ~objを空にする
</li><li>%要素 の `videoTracks$mM 属性が~~保持する `VideoTrackList$I ~objを空にする
</li></ol>

<p>
~event（特に， `removetrack$et ~event）は、この手続きの一部として発火されることはない
— 代わりに，これを呼出した各種~algoにより発火される［
`~errorM$et, `emptied$et
］~eventを利用できる。
</p>
◎
When a media element is to forget the media element's media-resource-specific tracks, the user agent must remove from the media element's list of text tracks all the media-resource-specific text tracks, then empty the media element's audioTracks attribute's AudioTrackList object, then empty the media element's videoTracks attribute's VideoTrackList object. No events (in particular, no removetrack events) are fired as part of this; the error and emptied events, fired by the algorithms that invoke this one, can be used instead.
</div>


<hr>

<p>
`preload@aM
属性は`列挙ed属性$である。
次の表に，この属性~用の各種~keyword（ 1 列目）と，それぞれに対応する状態（同じ行の 2 列目）を挙げる。
この属性は、`~media資源$が［
~bufferされている／再生され始めた
］後でも変更できる
— 表の “概略” 列は、そのことを念頭に解釈されるとする。
◎
The preload attribute is an enumerated attribute. The following table lists the keywords and states for the attribute — the keywords in the left column map to the states in the cell in the second column on the same row as the keyword. The attribute can be changed even once the media resource is being buffered or played; the descriptions in the table below are to be interpreted with that in mind.
</p>

<table><thead><tr><th>~keyword
</th><th>状態
</th><th>概略
</th></tr></thead>
<!-- 
Keyword 	State 	Brief description 
 -->

<tbody><tr><td>`none@v
</td><td>`なし@st
</td><td>

<p>
次のいずれかであることを~UAに~hintする：
</p>
<ul><li>作者は，利用者が~media資源が必要になるものと期待していない
</li><li>~serverは不必要な流通を最小化することを求めている
</li></ul>

<p>
この状態は、［
~bufferingが開始されるときに備えて（例えば，利用者が “再生-” を叩いた），~media資源をどの程度~積極的に実際に~downloadするか
］に関する~hintは，提供しない。
</p>
◎
Hints to the user agent that either the author does not expect the user to need the media resource, or that the server wants to minimize unnecessary traffic. This state does not provide a hint regarding how aggressively to actually download the media resource if buffering starts anyway (e.g. once the user hits "play").

</td></tr><tr><td>`metadata@v
</td><td>`~metadata@st
</td><td>
作者は，利用者が~media資源が必要になるものと期待してはいないが、当の資源の~metadata（寸法, ~track~list, 時間長, 等々）を~fetchするのは
— 加えて，最初の少数の~frameも —
適度になることを，~UAに~hintする。
%要素 の `readyState$mM 属性は、~UAが精確に~metadataだけしか~fetchしなければ `HAVE_METADATA$mM になるが、概して，一部の~frameも得られることになり，おそらく［
`HAVE_CURRENT_DATA$mM, `HAVE_FUTURE_DATA$mM
］のいずれかになる。
~media資源の再生-中においては、帯域幅は狭いと見なされていることを，~UAに~hintする
— 例えば、~~安定的な再生は保守しつつ，~media~dataを可能な限り低速な~rateで得るよう，~downloadを減速することを示唆している。
◎
Hints to the user agent that the author does not expect the user to need the media resource, but that fetching the resource metadata (dimensions, track list, duration, etc), and maybe even the first few frames, is reasonable. If the user agent precisely fetches no more than the metadata, then the media element will end up with its readyState attribute set to HAVE_METADATA; typically though, some frames will be obtained as well and it will probably be HAVE_CURRENT_DATA or HAVE_FUTURE_DATA. When the media resource is playing, hints to the user agent that bandwidth is to be considered scarce, e.g. suggesting throttling the download so that the media data is obtained at the slowest possible rate that still maintains consistent playback.

</td></tr><tr><td>`auto@v
</td><td>`自動的@st
</td><td>
~serverにおける~riskなしに
— 楽観的に資源~全体を~downloadするまでに —
利用者の必要を~~最優先にできることを，~UAに~hintする。
◎
Hints to the user agent that the user agent can put the user's needs first without risk to the server, up to and including optimistically downloading the entire resource.

</td></tr></tbody></table>

<p>
空~文字列も~keywordとして妥当であり， `自動的$st 状態に対応付けられる。
`値なしに対する既定の状態$は、~UAにより定義される
— ［
~server負荷を抑制すること，最適な利用者~体験を提供すること
］の妥協点として， `~metadata$st 状態が示唆されるが。
◎
The empty string is also a valid keyword, and maps to the Automatic state. The attribute's missing value default is user-agent defined, though the Metadata state is suggested as a compromise between reducing server load and providing an optimal user experience.
</p>

<p class="note">注記：
作者は、利用者が再生し始めてから，この属性を［
`none$v ／ `metadata$v
］から `auto$v へ動的に切替えるかもしれない。
例えば，多数の動画がある頁では、多くの動画は，要請されない限り~downloadしないが、<em>要請されたなら</em>，積極的に~downloadするよう指示するために利用されるかもしれない。
◎
Authors might switch the attribute from "none" or "metadata" to "auto" dynamically once the user begins playback. For example, on a page with many videos this might be used to indicate that the many videos are not to be downloaded unless requested, but that once one is requested it is to be downloaded aggressively.
</p>


<p>
`preload$aM
属性は、［
何が利用者~体験にとって最善になるか
］についての~hintを，作者が~UAに提供するために意図されている。
~UAは、この属性をまるごと無視しても~MAY
— 例えば、明示的な利用者~選好や, 可用な~接続性に基づいて。
◎
The preload attribute is intended to provide a hint to the user agent about what the author thinks will lead to the best user experience. The attribute may be ignored altogether, for example based on explicit user preferences or based on the available connectivity.
</p>

<dl class="idl-def">
	<dt>`preload@mM</dt>
	<dd>
`既知の値のみに制限され$る下で，同じ名前の内容~属性を`反映-$し~MUST。
◎
The preload IDL attribute must reflect the content attribute of the same name, limited to only known values.
</dd>
</dl>


<p class="note">注記：
`autoplay$aM 属性は、 `preload$aM 属性を上書きし得る（
`preload$aM 属性が与える~hintに関わらず、当の~mediaの再生-時には，それに先立って~bufferしているはずなので）。
しかしながら、両者とも含めることは~errorではない。
◎
The autoplay attribute can override the preload attribute (since if the media plays, it naturally has to buffer first, regardless of the hint given by the preload attribute). Including both is not an error, however.
</p>

<hr>

<dl class="domintro">
	<dt>%media . `buffered$mM</dt>
	<dd>
~UAが~bufferした`~media資源$の一連の範囲を表現する
`TimeRanges$I ~objを返す。
◎
Returns a TimeRanges object that represents the ranges of the media resource that the user agent has buffered.
</dd>
</dl>

<dl class="idl-def">
	<dt>`buffered@mM</dt>
	<dd>
取得子は、この属性が評価された時点で［
~UAが~bufferした`~media資源$の一連の範囲を表現する，新たな静的かつ`正規化済み$ `TimeRanges$I ~obj
］を返さ~MUST。
~UAは、~media~streamに対し，これを手間のかかる検分でしか決定できない場合でも，可用な範囲を正確0に決定し~MUST。
◎
The buffered attribute must return a new static normalized TimeRanges object that represents the ranges of the media resource, if any, that the user agent has buffered, at the time the attribute is evaluated. Users agents must accurately determine the ranges available, even for media streams where this can only be determined by tedious inspection.
</dd>
</dl>

<p class="note">注記：
これは概して， 0 を起点とする単独の範囲になるが、例えば~UAの~seekingに呼応して
~HTTP~Range要請を利用する場合，複数の範囲にもなり得る。
◎
Typically this will be a single range anchored at the zero point, but if, e.g. the user agent uses HTTP range requests in response to seeking, then there could be multiple ranges.
</p>

<p>
~UAは、以前に~bufferされた~dataを破棄して~MAY。
◎
User agents may discard previously buffered data.
</p>

<p class="note">注記：
したがって，ある時点で `buffered$mM 属性が返す~objが表現する範囲たちのいずれかに含まれる時刻~位置は、後の時点で返されるものには含まれないかもしれない。
◎
Thus, a time position included within a range of the objects return by the buffered attribute at one time can end up being not included in the range(s) of objects returned by the same attribute at later times.
</p>

				</section>
				<section id="offsets-into-the-media-resource">
<h4 title="Offsets into the media resource">4.8.12.6. ~media資源の中への~offset</h4>

<dl class="domintro">
	<dt>%media . `duration$mM</dt>
	<dd>
`~media資源$の長さを秒単位で返す。
`~media資源$の始端が時刻 0 と見做される。
◎
Returns the length of the media resource, in seconds, assuming that the start of the media resource is at time zero.
</dd>
	<dd>
時間長は可用でなければ `NaN^jv を返す。
◎
Returns NaN if the duration isn't available.
</dd>
	<dd>
無限界~streamに対しては `Infinity^jv を返す。
◎
Returns Infinity for unbounded streams.
</dd>

	<dt>%media . `currentTime$mM [ = %value ]</dt>
	<dd>
`公式的な再生~位置$を秒単位で返す。
◎
Returns the official playback position, in seconds.
</dd>
	<dd>
設定して，所与の時刻に~seekできる。
◎
Can be set, to seek to the given time.
</dd>
</dl>

<p>
`~media資源$は、
`~media時間軸@
（ media timeline ）を持つ。
それは、時刻（秒単位）を`~media資源$内の位置に対応付ける。
時間軸の原点は、それに定義される最も早い位置になり，
時間軸の時間長（ duration ）は、それに定義される最後の位置になる。
◎
A media resource has a media timeline that maps times (in seconds) to positions in the media resource. The origin of a timeline is its earliest defined position. The duration of a timeline is its last defined position.
</p>

<p>
`~media時間軸を確立-@
するときは：
`~media資源$が，何らかの方法で，原点が負でない時間軸を明示的に指定する場合（すなわち，各~frameに特定の時刻~offsetを与えていて，最初の~frameには 0 以上の~offsetを与えている）、`~media時間軸$はその時間軸にされるべきである（`~media資源$が時間軸を指定できるかどうかは`~media資源$の形式に依存する）。
`~media資源$が明示的な開始-時刻<em>と日付</em>を指定する場合、その日時が
`~media時間軸$における~offset 0 の地点と見なされるべきである
— `getStartDate()$mM ~methodは、この`時間軸~offset$による日時を公開することになる。
◎
Establishing the media timeline: if the media resource somehow specifies an explicit timeline whose origin is not negative (i.e. gives each frame a specific time offset and gives the first frame a zero or positive offset), then the media timeline should be that timeline. (Whether the media resource can specify a timeline or not depends on the media resource's format.) If the media resource specifies an explicit start time and date, then that time and date should be considered the zero point in the media timeline; the timeline offset will be the time and date, exposed using the getStartDate() method.
</p>

<p>
`~media資源$の時間軸は不連続である場合、~UAは資源の始端に利用される時間軸を資源~全体にまたがるように拡張し~MUST
— 下層の`~media~data$は順不同, あるいは時刻~codeが重合している場合でも、`~media資源$の`~media時間軸$は，（下に定義される）`可能な最も早い位置$から開始して線形に増加するように。
◎
If the media resource has a discontinuous timeline, the user agent must extend the timeline used at the start of the resource across the entire resource, so that the media timeline of the media resource increases linearly starting from the earliest possible position (as defined below), even if the underlying media data has out-of-order or even overlapping time codes.
</p>

<p class="example">
例えば、
1 個の動画~file内に 2 個の連結された~clipがあって，動画の形式は両~clipの元の時刻による時間軸
— 例えば［
00:15 〜 00:29,
00:05 〜 00:38
］ —
を公開しているかもしれない。
~UAは、それらの時刻は公開せず，単独の動画として［
00:15 〜 00:29,
00:29 〜 01:02
］を公開することになる。
◎
For example, if two clips have been concatenated into one video file, but the video format exposes the original times for the two clips, the video data might expose a timeline that goes, say, 00:15..00:29 and then 00:05..00:38. However, the user agent would not expose those times; it would instead expose the times as 00:15..00:29 and 00:29..01:02, as a single video.
</p>

<p>
`~media資源$に明示的な時間軸がないような稀な事例においては、
`~media時間軸$の 時刻 0 は，`~media資源$の最初の~frameに対応するべきである。
`~media資源$が明示的な計時~情報を
— ~frame時間長すら —
全く伴わないようなもっと稀な事例においては、~UAは，自身により定義される方式で各~frameに対応する時刻を決定し~MUST。
~FINGERPRINTING
◎
In the rare case of a media resource that does not have an explicit timeline, the zero time on the media timeline should correspond to the first frame of the media resource. In the even rarer case of a media resource with no explicit timings of any kind, not even frame durations, the user agent must itself determine the time for each frame in a user-agent-defined manner.
(This is a fingerprinting vector.)
</p>

<p class="note">注記：
明示的な時間軸は伴わないが，明示的な~frame時間長は伴う~file形式の例としては、
Animated GIF 形式が挙げられる。
明示的な時間軸を全く伴わない~file形式の例としては、 JPEG-push 形式が挙げられる（
JPEG ~frameを伴う `multipart/x-mixed-replace$mt
— MJPEG ~stream用の形式として利用されることが多い）。
◎
An example of a file format with no explicit timeline but with explicit frame durations is the Animated GIF format. An example of a file format with no explicit timings at all is the JPEG-push format (multipart/x-mixed-replace with JPEG frames, often used as the format for MJPEG streams).
</p>

<div class="p">
<p>
`~media資源$ %資源 に計時~情報が伴われない事例では、~UAは，時刻 0 を次に与える時刻に対応させるべきである：
</p>
<ul>
	<li>
にもかかわらず，［
~serverが元々提供した最初の~frameより早い地点
］へ~seekできることになる場合
⇒
%資源 内の~seek可能な最も早い時刻
</li>
	<li>
他の場合
⇒
~serverから受信された最初の~frame（~UAが %資源 内の~streamを受信し始めた地点）。
</li>
</ul>
◎
If, in the case of a resource with no timing information, the user agent will nonetheless be able to seek to an earlier point than the first frame originally provided by the server, then the zero time should correspond to the earliest seekable time of the media resource; otherwise, it should correspond to the first frame received from the server (the point in the media resource at which the user agent began receiving the stream).
</div>

<p class="note">注記：
これを書いている時点では、［
~serverにより送信された最初の~frameより前の~frameへの~seekingを~supportしつつ，明示的な~frame時刻~offsetを欠く
］ような，既知の形式はない。
◎
At the time of writing, there is no known format that lacks explicit frame time offsets yet still supports seeking to a frame before the first frame sent by the server.
</p>

<div class="example">

<div class="p">
<p>
ある TV 放送局からの，次のような~streamを考える：
</p>

<ul><li>10 月の金曜日の昼過ぎから~streamingを始める
</li><li>接続してくるどの~UAに対しても，常に同じ~media時間軸~上の~media~dataを送信する
</li><li>その時刻 0 はこの~streamの始端に設定されている
</li></ul>

<p>
何ヶ月か後にこの~streamへ接続している~UAは、自身が受信する最初の~frameの時刻が秒~数で何千何百万になることを見出すことになる。
`getStartDate()$mM ~methodは，常に放送を開始した日付を返すことになる。
これにより，~controllerは，自身の~scrubber
`音声の区間を選択するための~UI^tnote
内に実~時刻（例： “午後 2:30”）
— 放送~~開始に相対的な時刻でなく（例： “8 ヶ月, 4 時間, 12分 23 秒” ） —
を表示できるようになる。
</p>

◎
Consider a stream from a TV broadcaster, which begins streaming on a sunny Friday afternoon in October, and always sends connecting user agents the media data on the same media timeline, with its zero time set to the start of this stream. Months later, user agents connecting to this stream will find that the first frame they receive has a time with millions of seconds. The getStartDate() method would always return the date that the broadcast started; this would allow controllers to display real times in their scrubber (e.g. "2:30pm") rather than a time relative to when the broadcast began ("8 months, 4 hours, 12 minutes, and 23 seconds").
</div>

<div class="p">
<p>
ある~serverにより放送される，次のような~streamを考える：
</p>
<ul ><li>いくつかの断片が連結された動画を運んでいる
</li><li>特定の時刻を要請するのを~UAに許容せず，単に動画~dataを予め決定された順序で~streamする
</li><li>最初の~frameは常に，時刻 0 の~frameとして識別されるよう送達される。
</li></ul>

<p>
~UAがこの~streamに接続して，時刻印［
2010-03-20 23:15:00 UTC 〜 2010-03-21 00:05:00 UTC,
2010-02-12 14:25:00 UTC 〜 2010-02-12 14:35:00 UTC
］を覆うものと定義された断片を受信する場合、これを 0 秒から開始して 3,600 秒（ 1 時間）へ拡張する`~media時間軸$を伴わせて公開することになる。
~streaming~serverは 2 個目の~clipの終端で切断されると見做すなら、
`duration$mM 属性は 3,600 を返し，
`getStartDate()$mM ~methodは
2010-03-20 23:15:00 UTC
に対応する時刻を表す `Date$I ~objを返すことになる。
その一方，別の~UAが 5 分~後に接続した場合、その~UAは，時刻印［
2010-03-20 23:20:00 UTC 〜 2010-03-21 00:05:00 UTC,
2010-02-12 14:25:00 UTC 〜 2010-02-12 14:35:00 UTC
］を覆う断片を（だいたいは）受信することになり、
0 秒から開始して 3,300 秒へ拡張する`~media時間軸$（ 55 分~間）を伴わせて，これを公開することになる。
この事例では、 `getStartDate()$mM ~methodは，
2010-03-20 23:20:00 UTC
に対応する時刻を表す `Date$I ~objを返すことになる。
</p>
◎
Consider a stream that carries a video with several concatenated fragments, broadcast by a server that does not allow user agents to request specific times but instead just streams the video data in a predetermined order, with the first frame delivered always being identified as the frame with time zero. If a user agent connects to this stream and receives fragments defined as covering timestamps 2010-03-20 23:15:00 UTC to 2010-03-21 00:05:00 UTC and 2010-02-12 14:25:00 UTC to 2010-02-12 14:35:00 UTC, it would expose this with a media timeline starting at 0s and extending to 3,600s (one hour). Assuming the streaming server disconnected at the end of the second clip, the duration attribute would then return 3,600. The getStartDate() method would return a Date object with a time corresponding to 2010-03-20 23:15:00 UTC. However, if a different user agent connected five minutes later, it would (presumably) receive fragments covering timestamps 2010-03-20 23:20:00 UTC to 2010-03-21 00:05:00 UTC and 2010-02-12 14:25:00 UTC to 2010-02-12 14:35:00 UTC, and would expose this with a media timeline starting at 0s and extending to 3,300s (fifty five minutes). In this case, the getStartDate() method would return a Date object with a time corresponding to 2010-03-20 23:20:00 UTC.
</div>

<p>
この両~例とも，
`seekable$mM 属性は~controllerが~UI内に実際に表示したいと求める一連の範囲を与えることになる
— ~serverが任意の時刻への~seekingを~supportしない場合、これは概して，［
~UAが~streamへ接続した瞬間の時刻から，~UAが直近に得た~frameまで
］の範囲になる。
しかしながら，~UAがより早い情報を破棄し始めた場合、実際の範囲はより短くなるかもしれない。
◎
In both of these examples, the seekable attribute would give the ranges that the controller would want to actually display in its UI; typically, if the servers don't support seeking to arbitrary times, this would be the range of time from the moment the user agent connected to the stream up to the latest frame that the user agent has obtained; however, if the user agent starts discarding earlier information, the actual range might be shorter.
</p>

</div>

<p>
いずれの事例であれ，~UAは、［
`~media時間軸$を確立したときは，それを利用している`可能な最も早い位置$は 0 以上になる
］ことを確保し~MUST。
◎
In any case, the user agent must ensure that the earliest possible position (as defined below) using the established media timeline, is greater than or equal to zero.
</p>

<p>
`~media時間軸$には、時計も結付けられる。
どの時計が利用されるかは~UAにより定義され，`~media資源$ に依存しても~MAYが、それは利用者の~wall時計
`局所時間帯？^tnote
に近似するべきである。
◎
The media timeline also has an associated clock. Which clock is used is user-agent defined, and may be media resource-dependent, but it should approximate the user's wall clock.
</p>

<p>
各`~media要素$には、次のものが結付けられる
— 初期~時には（すなわち，`~media~data$の不在の下では）、括弧~内に与える値に設定され~MUST：
◎
↓</p>

<dl class="def-list">
	<dt>`現在の再生~位置@ （ 0 秒 ）</dt>
	<dd>
`~media時間軸$上の時刻。
◎
Media elements have a current playback position, which must initially (i.e. in the absence of media data) be zero seconds. The current playback position is a time on the media timeline.
</dd>

	<dt>`公式的な再生~位置@ （ 0 秒 ）</dt>
	<dd>
これは、~scriptを走らせている間は安定に保たれるような，`現在の再生~位置$の近似である。
◎
Media elements also have an official playback position, which must initially be set to zero seconds. The official playback position is an approximation of the current playback position that is kept stable while scripts are running.
</dd>

	<dt>`既定の再生~開始-位置@（ 0 秒 ）</dt>
	<dd>
この時刻は、~mediaが読込まれる前であっても，要素を~seekできるようにするために利用される。
◎
Media elements also have a default playback start position, which must initially be set to zero seconds. This time is used to allow the element to be seeked even before the media is loaded.
</dd>

	<dt>`~show~poster~flag@ （ ~T ）</dt>
	<dd>
~UAが `video$e 要素~用に［
動画~内容に代えて，~poster~frameをいつ示すか
］を制御するために利用される。
◎
Each media element has a show poster flag. When a media element is created, this flag must be set to true. This flag is used to control when the user agent is to show a poster frame for a video element instead of showing the video contents.
</dd>
</dl>

<dl class="idl-def">
	<dt>`currentTime@mM</dt>
	<dd>
取得子は、此れの`既定の再生~開始-位置$は［
0 でないならば それ ／
0 ならば此れの`公式的な再生~位置$
］を，秒単位で返さ~MUST。
◎
↓</dd>
	<dd>
<p>
設定子は、所与の値 %値 に対し，次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れの`readyState$mM ~EQ `HAVE_NOTHING$mM
］
⇒
此れの`既定の再生~開始-位置$ ~SET %値
</li>
			<li>
<p>
~ELSE：
</p>

<ol><li>`公式的な再生~位置$ ~SET %値
</li><li>%値 を秒単位として解釈した結果の位置へ`~seek$する
</li></ol>
			</li>
		</ol>

◎
The currentTime attribute must, on getting, return the media element's default playback start position, unless that is zero, in which case it must return the element's official playback position. The returned value must be expressed in seconds. On setting, if the media element's readyState is HAVE_NOTHING, then it must set the media element's default playback start position to the new value; otherwise, it must set the official playback position to the new value and then seek to the new value. The new value must be interpreted as being in seconds.
</dd>
</dl>


<p>
`~media資源$は~streaming資源である場合、~bufferから失効した後は，~UAは資源のある部分を得れないかもしれない。
同様に，`~media資源$の`~media時間軸$は、 0 から開始しないこともあるかもしれない。
`可能な最も早い位置@
は、`~media時間軸$上の時刻であって，~UAがいつでも再び得れるような［
~stream／資源
］内の最も早い位置とする。
◎
If the media resource is a streaming resource, then the user agent might be unable to obtain certain parts of the resource after it has expired from its buffer. Similarly, some media resources might have a media timeline that doesn't start at zero. The earliest possible position is the earliest position in the stream or resource that the user agent can ever obtain again. It is also a time on the media timeline.
</p>

<p class="note">注記：
`可能な最も早い位置$は、~APIにおいては明示的には公開されない。
それは、 `seekable$mM 属性が返す `TimeRanges$I ~objが表す範囲~listが［
空でなければ その最初の範囲の開始-時刻 ／
空ならば `現在の再生~位置$
］に対応する。
◎
The earliest possible position is not explicitly exposed in the API; it corresponds to the start time of the first range in the seekable attribute's TimeRanges object, if any, or the current playback position otherwise.
</p>

<div class="p">
<p>
%要素 の`可能な最も早い位置$が変化したときは、~UAは，次を走らせ~MUST：
</p>

<ul>
	<li>
~IF［
`現在の再生~位置$は`可能な最も早い位置$より前
］
⇒
`可能な最も早い位置$へ`~seek$する
</li>
	<li>
~ELIF［
%要素 向けの `timeupdate$et ~eventは、［
過去 15ms 〜 250ms においては発火されていない
］~AND［
それらに対する~event~handlerは現在~走っていない
］］
⇒
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `timeupdate$et の`~eventを発火-$する
</li>
</ul>
◎
When the earliest possible position changes, then: if the current playback position is before the earliest possible position, the user agent must seek to the earliest possible position; otherwise, if the user agent has not fired a timeupdate event at the element in the past 15 to 250ms and is not still running event handlers for such an event, then the user agent must queue a task to fire an event named timeupdate at the element.
</div>

<p class="note">注記：
上の要件と［
<a href="~HTMLemb#getting-media-metadata">~clipの~metadataが既知になった</a>
ときから効き始める，`資源~fetch~algo$における要件
］があるので、［
`現在の再生~位置$ ~LT `可能な最も早い位置$
］になることは、決してない。
◎
Because of the above requirement and the requirement in the resource fetch algorithm that kicks in when the metadata of the clip becomes known, the current playback position can never be less than the earliest possible position.
</p>

<p class="algo-head">
~UAは いつでも，［［
音声／動画
］~trackは終止した
］~AND［
その~trackに関係しているすべての`~media~data$は、`可能な最も早い位置$より<em>前</em>にある `~media時間軸$の部分に対応する
］ことが~~判明したときは、次を走らす`~taskを待入し$ても~MAY：
◎
If at any time the user agent learns that an audio or video track has ended and all media data relating to that track corresponds to parts of the media timeline that are before the earliest possible position, the user agent may queue a task to run these steps:
</p>

<ol>
	<li>
~Assert：
~trackは、ある`~media要素$の［
`audioTracks$mM ／ `videoTracks$mM
］属性が返す［
`AudioTrackList$I ／ `VideoTrackList$I
］~obj %~track~list 内のある［
`AudioTrack$I ／ `VideoTrack$I
］~obj %~track で表現されている
◎
↓</li>
	<li>
%~track~list から %~track を除去する
◎
Remove the track from the audioTracks attribute's AudioTrackList object or the videoTracks attribute's VideoTrackList object as appropriate.
</li>
	<li>
<p>
%~track~list に向けて，次のようにされた`~eventを発火-$する：
</p>

<ul ><li>名前 `removetrack$et
</li><li>`TrackEvent$I を利用する
</li><li>`track$m 属性 ~SET %~track に初期化する
</li></ul>

◎
Fire an event named removetrack at the media element's aforementioned AudioTrackList or VideoTrackList object, using TrackEvent, with the track attribute initialized to the AudioTrack or VideoTrack object representing the track.
</li>
</ol>

<dl class="idl-def">
	<dt>`duration@mM</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れに可用な`~media~data$はない
］
⇒
~RET `NaN^jv
</li>
			<li>
~IF［
`~media資源$は有限界と既知でない（例：
~streaming~radioや，終止-時刻は公告されていない~live-event）
］
⇒
~RET 正の `Infinity^jv ／
</li>
			<li>
~RET 秒単位による，此れの`~media時間軸$上の此れの`~media資源$の終止-時刻
</li>
		</ol>

◎
The duration attribute must return the time of the end of the media resource, in seconds, on the media timeline. If no media data is available, then the attributes must return the Not-a-Number (NaN) value. If the media resource is not known to be bounded (e.g. streaming radio, or a live event with no announced end time), then the attribute must return the positive Infinity value.
</dd>
</dl>

<p>
~UAは、`~media資源$の時間長を，［
`~media~data$のどこか一部でも再生する ／
`readyState$mM を `HAVE_METADATA$mM 以上の値に設定する
］より前に決定し~MUST
— そのためには資源の複数の部分を~fetchする必要がある場合でも。
◎
The user agent must determine the duration of the media resource before playing any part of the media data and before setting readyState to a value equal to or greater than HAVE_METADATA, even if doing so requires fetching multiple parts of the resource.
</p>

<div class="p">
<p id="durationChange" class="algo-head">
`~media要素$ %要素 の`~media資源$ %資源 の長さが既知の値に変化したとき（例：未知から既知へ／以前に確立された長さから新たな長さへ変化したとき）は、~UAは次を走らせ~MUST：
</p>

<ol>
	<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `durationchange$et の`~eventを発火-$する
（この~eventは、新たな~media資源の読込み時の一環として，時間長が再設定されたときは発火されない。）
</li>
	<li>
%終端 ~LET %資源 の終端の時刻
</li>
	<li>
~IF［
時間長の変化により［
`現在の再生~位置$ ~GT %終端
］になった
］
⇒
%終端 へ`~seek$する
</li>
</ol>
◎
When the length of the media resource changes to a known value (e.g. from being unknown to known, or from a previously established length to a new length) the user agent must queue a task to fire an event named durationchange at the media element. (The event is not fired when the duration is reset as part of loading a new media resource.) If the duration is changed such that the current playback position ends up being greater than the time of the end of the media resource, then the user agent must also seek to the time of the end of the media resource.
</div>

<p class="example">
“無限” ~streamが何らかの理由で終止する場合、時間長は
正の `Infinity^jv から~stream内の最後の［
~frame／~sample
］時刻に変化して，
`durationchange$et ~eventは同様に発火されることになる。
~UAが`~media資源$の時間長を精確に決定する代わりに初期~時に見積もっていて，後で新たな情報に基づいて見積もりを改訂した場合、時間長は変化して `durationchange$et ~eventは発火されることになる。
◎
If an "infinite" stream ends for some reason, then the duration would change from positive Infinity to the time of the last frame or sample in the stream, and the durationchange event would be fired. Similarly, if the user agent initially estimated the media resource's duration instead of determining it precisely, and later revises the estimate based on new information, then the duration would change and the durationchange event would be fired.
</p>

<p>
一部の動画~fileは、
`時間軸~offset@
と呼ばれる，`~media時間軸$内の時刻 0 に対応する，明示的な日時も持つ。
それは、初期~時には `NaN^jv に設定され~MUST。
◎
Some video files also have an explicit date and time corresponding to the zero time in the media timeline, known as the timeline offset. Initially, the timeline offset must be set to Not-a-Number (NaN).
</p>

<dl class="idl-def">
	<dt>`getStartDate()@mM</dt>
	<dd>
被呼出時には、現在の`時間軸~offset$を表現している`新たな~Date~obj$を返さ~MUST。
◎
The getStartDate() method must return a new Date object representing the current timeline offset.
</dd>
</dl>

<hr>

<p>
`loop@aM
属性は，`真偽~属性$であり、指定された場合，`~media要素$が終端に達したときには`~media資源$の始端へ~seekして戻ることを指示する。
◎
The loop attribute is a boolean attribute that, if specified, indicates that the media element is to seek back to the start of the media resource upon reaching the end.
</p>

<dl class="idl-def">
	<dt>`loop@mM</dt>
	<dd>
同じ名前の内容~属性を`反映-$し~MUST。
◎
The loop IDL attribute must reflect the content attribute of the same name.
</dd>
</dl>

				</section>
				<section id="ready-states">
<h4 title="Ready states">4.8.12.7. 準備状態</h4>

<dl class="domintro">

	<dt>%media . `readyState$mM</dt>
	<dd>
此れの`現在の再生~位置$の具現化に関する，現在の状態を表す値を、下に挙げる~codeとして返す。
◎
Returns a value that expresses the current state of the element with respect to rendering the current playback position, from the codes in the list below.
</dd>
</dl>

<p>
各`~media要素$は、次に挙げるいずれかを値にとる
`準備状態^i
を持つ。
それは、`現在の再生~位置$に具現化する準備済み度合いを述べる。
与えられた特定0の時刻における~media要素の準備状態は、要素の状態を述べている~~最大~値になる：
◎
Media elements have a ready state, which describes to what degree they are ready to be rendered at the current playback position. The possible values are as follows; the ready state of a media element at any particular time is the greatest value describing the state of the element:
</p>


<dl class="idl-def">
	<dt>`HAVE_NOTHING@mM （数値 0 ）</dt>
	<dd>
<p>
次を指示する：
</p>

<ul ><li>`~media資源$に関する可用な情報はない。
</li><li>此れの`現在の再生~位置$に対する~dataは可用でない。
</li></ul>

<p>［
此れの `networkState$mM 属性 ~EQ `NETWORK_EMPTY$mM
］ならば、常に `HAVE_NOTHING$mM 状態にある。
</p>
◎
No information regarding the media resource is available. No data for the current playback position is available. Media elements whose networkState attribute are set to NETWORK_EMPTY are always in the HAVE_NOTHING state.
</dd>

	<dt>`HAVE_METADATA@mM （数値 1 ）</dt>
	<dd>
<p>
次を指示する：
</p>
<ul ><li>此れの資源の時間長が可用になるに十分な資源は得られ、此れが `video$e 要素である場合は，動画の寸法も可用である。
</li><li>此れの`現在の再生~位置$に対する直の`~media~data$は可用でない。
</li></ul>

◎
Enough of the resource has been obtained that the duration of the resource is available. In the case of a video element, the dimensions of the video are also available. No media data is available for the immediate current playback position.
</dd>

	<dt>`HAVE_CURRENT_DATA@mM （数値 2 ）</dt>
	<dd>
<p>
次を指示する：
</p>

<ul ><li>此れの`現在の再生~位置$に対する直の~dataは可用である。
</li><li>~UAは，此れの`現在の再生~位置$を`再生~方向$へ進めるために十分な~dataを有していない
— `再生~方向$に得れる~dataはもうないか、進めるためには即時に `HAVE_METADATA$mM 状態へ復帰する必要がある。
</li></ul>

◎
↓</dd>
	<dd>
<p>
例えば動画においては、これは次のいずれかに対応する：
</p>

<ul><li>`再生は終止して$いるとき
</li><li>此れの`現在の再生~位置$が現在の~frameの終端にある下で、~UAには現在の~frameからの~dataはあるが，次~frameのそれはない。
</li></ul>
◎
Data for the immediate current playback position is available, but either not enough data is available that the user agent could successfully advance the current playback position in the direction of playback at all without immediately reverting to the HAVE_METADATA state, or there is no more data to obtain in the direction of playback. For example, in video this corresponds to the user agent having data from the current frame, but not the next frame, when the current playback position is at the end of the current frame; and to when playback has ended.
</dd>

	<dt>`HAVE_FUTURE_DATA@mM （数値 3 ）</dt>
	<dd>
<p>
次を指示する：
</p>
<ul><li>此れの`現在の再生~位置$に対する直の~dataは可用である。
</li><li>~UAは、此れの`現在の再生~位置$を少なくとも少しは`再生~方向$へ進めるに十分な~dataを有していて、進めるために即時に `HAVE_METADATA$mM 状態へ復帰する必要はない。
</li><li>~text~trackは`準備済み$tTである。
</li></ul>
◎
↓</dd>
	<dd>
<p>
例えば動画においては、これは次のいずれかに対応する
</p>
		<ul>
			<li>
~UAは、少なくとも，［
`現在の再生~位置$の時刻を挟む，現在の~frameと次~frame
］用の~dataを有する。
</li>
			<li>
~UAは、現在の~frame用の［
動画~data, 音声~data
］を有する
— 此れの`現在の再生~位置$が ある~frameの途中にあるとき，少なくとも 少しは再生し続けれるだけの。
</li>
		</ul>
◎
↓</dd>
	<dd>
`再生は終止して$いる場合、此れの`現在の再生~位置$は決して進めれないので，この状態になり得ない。
◎
Data for the immediate current playback position is available, as well as enough data for the user agent to advance the current playback position in the direction of playback at least a little without immediately reverting to the HAVE_METADATA state, and the text tracks are ready. For example, in video this corresponds to the user agent having data for at least the current frame and the next frame when the current playback position is at the instant in time between the two frames, or to the user agent having the video data for the current frame and audio data to keep playing at least a little when the current playback position is in the middle of a frame. The user agent cannot be in this state if playback has ended, as the current playback position can never advance in this case.
</dd>

	<dt>`HAVE_ENOUGH_DATA@mM （数値 4 ）</dt>
	<dd>
<p>
`HAVE_FUTURE_DATA$mM
状態に述べたすべての条件は満たされることに
加えて、次のいずれかの条件も満たされることを指示する：
◎
All the conditions described for the HAVE_FUTURE_DATA state are met, and, in addition, either of the following conditions is also true:
</p>

		<ul>
			<li>
~UAは、［
次が満たされるような~rateで，~dataは~fetchされている
］ものと見積もっている
⇒
此れの`現在の再生~位置$から此れの `playbackRate$mM で進めた場合に、再生が`~media資源$の終端に達する前に，可用な~dataが尽きることはない
◎
The user agent estimates that data is being fetched at a rate where the current playback position, if it were to advance at the element's playbackRate, would not overtake the available data before playback reaches the end of the media resource.
</li>
			<li>
~UAは、これ以上~待機して再生を遅延しても，~dataは得られず何の利得もない（例えば、~bufferは満杯であるかもしれない）状態になった。
◎
The user agent has entered a state where waiting longer will not result in further data being obtained, and therefore nothing would be gained by delaying playback any further. (For example, the buffer might be full.)
</li>
		</ul>
	</dd>
</dl>

<p class="note">注記：
実施においては、
`HAVE_METADATA$mM と `HAVE_CURRENT_DATA$mM
との相違は些細である。
~~実際にこの相違が関連するのは、 `video$e 要素を `canvas$e 上に塗るときに限られる
— そこでは、何かが描かれるとき（ `HAVE_CURRENT_DATA$mM 以上）と何も描かれないとき（ `HAVE_METADATA$mM 以下）とが判別される。
同様に、
`HAVE_CURRENT_DATA$mM （現在の~frameしかない）と
`HAVE_FUTURE_DATA$mM （少なくともこの~frameと次がある）との相違も，些細にもなり得る（極端な場合，~frame は 1 個しかないとき）。
その区別が~~実際に関わるのは、頁が “~frame刻みの” ~navi用~UIを提供するときに限られる。
◎
In practice, the difference between HAVE_METADATA and HAVE_CURRENT_DATA is negligible. Really the only time the difference is relevant is when painting a video element onto a canvas, where it distinguishes the case where something will be drawn (HAVE_CURRENT_DATA or greater) from the case where nothing is drawn (HAVE_METADATA or less). Similarly, the difference between HAVE_CURRENT_DATA (only the current frame) and HAVE_FUTURE_DATA (at least this frame and the next) can be negligible (in the extreme, only one frame). The only time that distinction really matters is when a page provides an interface for "frame-by-frame" navigation.
</p>

<p class="algo-head">
`~media要素$ %要素 の準備状態が
%旧~状態 から %新~状態 へ変化したときは、~UAは，次の手続きに従わ~MUST：
◎
When the ready state of a media element whose networkState is not NETWORK_EMPTY changes, the user agent must follow the steps given below:
◎
Apply the first applicable set of substeps from the following list:
</p>

<ol>
	<li>
~IF［
%要素 の `networkState$mM ~EQ `NETWORK_EMPTY$mM
］
⇒
~RET
◎
↑</li>
	<li>
<p>
~IF［
%旧~状態 ~EQ `HAVE_NOTHING$mM
］~AND［
%新~状態 ~EQ `HAVE_METADATA$mM
］：
◎
If the previous ready state was HAVE_NOTHING, and the new ready state is HAVE_METADATA
</p>
		<ol>
			<li>
<p id="fire-loadedmetadata">
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `loadedmetadata$et の`~eventを発火-$する
◎
Queue a task to fire an event named loadedmetadata at the element.
</p>

<p class="note">注記：
この~taskを走らす前に，適切になるなら、
`video$e 要素は，`~event-loop$の仕組みの一部として，具現化-時に~resizeされるよう更新されることになる。
◎
Before this task is run, as part of the event loop mechanism, the rendering will have been updated to resize the video element if appropriate.
</p>
			</li>
			<li>
~RET
</li>
		</ol>
	</li>

	<li>
<p id="handling-first-frame-available">
~IF［
%旧~状態 ~EQ `HAVE_METADATA$mM
］~AND［
%新~状態 ~GTE `HAVE_CURRENT_DATA$mM
］：
◎
If the previous ready state was HAVE_METADATA and the new ready state is HAVE_CURRENT_DATA or greater
</p>
		<ol>
			<li id="fire-loadeddata">
~IF［
%要素 に対し生じたのは
`load()$mM ~algoが最後に呼出されてから初回である
］
⇒
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `loadeddata$et の`~eventを発火-$する
◎
If this is the first time this occurs for this media element since the load() algorithm was last invoked, the user agent must queue a task to fire an event named loadeddata at the element.
</li>
			<li>
~IF［
%新~状態 ~EQ `HAVE_CURRENT_DATA$mM
］
⇒
~RET
◎
If the new ready state is HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA, then the relevant steps below must then be run also.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%旧~状態 ~GTE `HAVE_FUTURE_DATA$mM
］~AND［
%新~状態 ~LTE `HAVE_CURRENT_DATA$mM
］：
◎
If the previous ready state was HAVE_FUTURE_DATA or more, and the new ready state is HAVE_CURRENT_DATA or less
</p>
		<ol>
			<li>
<p id="fire-waiting-when-waiting">
~IF［
`readyState$mM 属性が変化する前は， %要素 は`再生-中であり得る$であった
］：
</p>
				<ol>
					<li>
<p>
~IF［
%要素 は次のいずれかを満たしている
］
⇒
~RET：
</p>

<ul ><li>`再生は終止して$いる
</li><li>`~errorに因り停止され$ている
</li><li>`利用者~対話のため~pauseされ$ている
</li><li>`帯域内~内容のため~pauseされ$ている
</li></ul>

					</li>
					<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `timeupdate$et の`~eventを発火-$する
</li>
					<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `waiting$et の`~eventを発火-$する
</li>
				</ol>
◎
If the media element was potentially playing before its readyState attribute changed to a value lower than HAVE_FUTURE_DATA, and the element has not ended playback, and playback has not stopped due to errors, paused for user interaction, or paused for in-band content, the user agent must queue a task to fire an event named timeupdate at the element, and queue a task to fire an event named waiting at the element.
</li>
			<li>
~RET
</li>
		</ol>
	</li>

	<li>
<p>
~IF［
%旧~状態 ~LTE `HAVE_CURRENT_DATA$mM
］~AND［
%新~状態 ~EQ `HAVE_FUTURE_DATA$mM
］：
◎
If the previous ready state was HAVE_CURRENT_DATA or less, and the new ready state is HAVE_FUTURE_DATA
</p>
		<ol>
			<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `canplay$et の`~eventを発火-$する
◎
The user agent must queue a task to fire an event named canplay at the element.
</li>
			<li>
~IF［
%要素 の`paused$mM 属性 ~EQ ~F
］
⇒
%要素 に対し，`再生-中について通知-$する
◎
If the element's paused attribute is false, the user agent must notify about playing for the element.
</li>
			<li>
~RET
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%新~状態 ~EQ `HAVE_ENOUGH_DATA$mM
］：
◎
If the new ready state is HAVE_ENOUGH_DATA
</p>
		<ol>
			<li>
<p>
~IF［
%旧~状態 ~LTE `HAVE_CURRENT_DATA$mM
］：
</p>
				<ol>
					<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `canplay$et の`~eventを発火-$する
</li>
					<li>
~IF［
%要素 の`paused$mM 属性 ~EQ ~F
］
⇒
%要素 に対し，`再生-中について通知-$する
</li>
				</ol>
◎
If the previous ready state was HAVE_CURRENT_DATA or less, the user agent must queue a task to fire an event named canplay at the element, and, if the element's paused attribute is false, notify about playing for the element.
</li>
			<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `canplaythrough$et の`~eventを発火-$する
◎
The user agent must queue a task to fire an event named canplaythrough at the element.
</li>
			<li>
~IF［
%要素 は`自動再生に適格$でない
］
⇒
~RET
◎
If the element is not eligible for autoplay, then the user agent must abort these substeps.
</li>
			<li>
<p>
~UAの任意選択で、次のいずれか一つを行う：
</p>
				<ul>
					<li>
~RET（何もしない）
</li>
					<li>
下の手続き (A) を走らす
◎
The user agent may run the following substeps:
</li>
					<li>
<p>
~IF［
%要素 は `video$e 要素である
］
⇒
%要素 が`表示域に交差-$しているかどうか観測し始めた上で，下の規則 (B) に従う
</p>

<p class="note">注記：
この仕様は，交差がいつ試験されるか精確な時機は定義しないが、
Intersection Observer ~APIのそれに合致させることが示唆される。
`INTERSECTIONOBSERVER$r
◎
This specification doesn't define the precise timing for when the intersection is tested, but it is suggested that the timing match that of the Intersection Observer API. [INTERSECTIONOBSERVER]
</p>
					</li>
				</ul>

<p>
手続き (A) は、次で与えられる：
</p>
				<ol>
					<li>
`paused$mM 属性 ~SET ~F
◎
Set the paused attribute to false.
</li>
					<li>
<p>
~IF［
%要素 の`~show~poster~flag$ ~EQ ~T
］：
</p>

<ol><li>%要素 の`~show~poster~flag$ ~SET ~F
</li><li>%要素 に対し`~time-march-on$ 手続きを走らす
</li></ol>

◎
If the element's show poster flag is true, set it to false and run the time marches on steps.
</li>
					<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `play$et の`~eventを発火-$する
◎
Queue a task to fire an event named play at the element.
</li>
					<li>
%要素 に対し，`再生-中について通知-$する
◎
Notify about playing for the element.
</li>
				</ol>

<div class="p">
<p>
規則 (B) は、次で与えられる：
</p>
				<ul>
					<li>
%要素 が`表示域に交差-$し始めたときは
⇒
~IF［
その時点で， %要素 は`自動再生に適格$である
］
⇒
上の手続き (A) を走らす
</li>
					<li>
%要素 は`表示域に交差-$しなくなったときは、~UAの任意選択で
⇒
~IF［
その時点で，［
%要素 の`自動再生~可能~flag$ ~EQ ~T
］~AND［
%要素 は `autoplay$aM 属性を有する
］］
⇒
下の手続き (C) を走らす
</li>
				</ul>

◎
Alternatively, if the element is a video element, the user agent may start observing whether the element intersects the viewport. When the element starts intersecting the viewport, if the element is still eligible for autoplay, run the substeps above. Optionally, when the element stops intersecting the viewport, if the can autoplay flag is still true and the autoplay attribute is still specified, run the following substeps:
◎
＊重複
This specification doesn't define the precise timing for when the intersection is tested, but it is suggested that the timing match that of the Intersection Observer API. [INTERSECTIONOBSERVER]
</div>

<p>
手続き (C) は、次で与えられる：
</p>
				<ol>
					 <li>
`内部~pause手続き$を走らす
◎
↓</li>
					<li>
`自動再生~可能~flag$ ~SET ~T
◎
Run the internal pause steps and set the can autoplay flag to true.
</li>
					<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `pause$et の`~eventを発火-$する
◎
Queue a task to fire an event named pause at the element.
</li>
				</ol>

<p class="note">注記：
［
`自動再生~可能~flag$ ~EQ ~T
］の間は、
%要素 が`表示域に交差-$［
し始める／しなくなる
］たびに，［
再生する／~pauseする
］ための手続きも走らされ得る。
◎
The substeps for playing and pausing can run multiple times as the element starts or stops intersecting the viewport, as long as the can autoplay flag is true.
</p>

<p class="note">注記：
~UAは、自動再生を~supportする必要はない。
また、~UAには，そのことに関する利用者の選好を尊守することが示唆される。
作者には、~scriptを利用して動画~再生-を強制するのでなく、
`autoplay$aM 属性を利用して，利用者が欲する挙動に上書きできるようにすることが督促される。
◎
User agents do not need to support autoplay, and it is suggested that user agents honor user preferences on the matter. Authors are urged to use the autoplay attribute rather than using script to force the video to play, so as to allow the user to override the behavior if so desired.
</p>

			</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
~media要素の準備状態は、これらの状態を不連続に飛び移ることもあり得る。
例えば
`HAVE_METADATA$mM から，
`HAVE_CURRENT_DATA$mM,
`HAVE_FUTURE_DATA$mM
は~~飛ばして
`HAVE_ENOUGH_DATA$mM へ直に飛ぶなど。
◎
It is possible for the ready state of a media element to jump between these states discontinuously. For example, the state of a media element can jump straight from HAVE_METADATA to HAVE_ENOUGH_DATA without passing through the HAVE_CURRENT_DATA and HAVE_FUTURE_DATA states.
</p>


<dl class="idl-def">
	<dt>`readyState@mM</dt>
	<dd>
取得子は、上に述べた，此れの現在の準備状態を述べる値を返さ~MUST。
◎
The readyState IDL attribute must, on getting, return the value described above that describes the current ready state of the media element.
</dd>
</dl>

<p>
`autoplay@aM
属性は、`真偽~属性$である。
在するときは、~UAは（上の~algoで述べたように），可能になり次第，`~media資源$の再生を自動的に始めることになる。
<!-- ＊？without stopping -->
◎
The autoplay attribute is a boolean attribute. When present, the user agent (as described in the algorithm described herein) will automatically begin playback of the media resource as soon as it can do so without stopping.
</p>

<p class="note">注記：
作者には、~scriptを利用して自動的な再生を誘発せずに
`autoplay$aM 属性を利用することが督促される。
そうすれば利用者は自動的~再生を欲さないとき
— 例： ~screen-readerを利用しているとき —
には上書きできるようになるので。
作者には、自動的~再生の挙動を全く利用しない代わりに，利用者が再生を明示的に開始するのを~UAに待機させることを考慮することも奨励される。
◎
Authors are urged to use the autoplay attribute rather than using script to trigger automatic playback, as this allows the user to override the automatic playback when it is not desired, e.g. when using a screen reader. Authors are also encouraged to consider not using the automatic playback behavior at all, and instead to let the user agent wait for the user to start playback explicitly.
</p>

<dl class="idl-def">
	<dt>`autoplay@mM</dt>
	<dd>
同じ名前の内容~属性を`反映-$し~MUST。
◎
The autoplay IDL attribute must reflect the content attribute of the same name.
</dd>
</dl>

				</section>
				<section id="playing-the-media-resource">
<h4 title="Playing the media resource">4.8.12.8. ~media資源の再生-法</h4>

<dl class="domintro">

	<dt>%media . `paused$mM</dt>
	<dd>
再生は~pauseされて［
いれば ~T ／
いなければ ~F
］を返す。
◎
Returns true if playback is paused; false otherwise.
</dd>

	<dt>%media . `ended$mM</dt>
	<dd>
再生は`~media資源$の終端に［
達したならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if playback has reached the end of the media resource.
</dd>

	<dt>%media . `defaultPlaybackRate$mM [ = %value ]</dt>
	<dd>
利用者が`~media資源$を早送り／逆行していないときの，再生の既定の~rateを返す。
◎
Returns the default rate of playback, for when the user is not fast-forwarding or reversing through the media resource.
</dd>
	<dd>
設定して，再生の既定の~rateを変更できる。
◎
Can be set, to change the default rate of playback.
</dd>
	<dd>
この既定の~rateは，再生には直接的な効果はないが、利用者が早送り~modeに切替えた後に通常の再生~modeに戻ったときは，再生~rateも既定の~rateに戻ることになることが期待される。
◎
The default rate has no direct effect on playback, but if the user switches to a fast-forward mode, when they return to the normal playback mode, it is expected that the rate of playback will be returned to the default rate of playback.
</dd>

	<dt>%media . `playbackRate$mM [ = %value ]</dt>
	<dd>
現在の再生~rateを返す。
通常の速度は 1.0 。
◎
Returns the current rate playback, where 1.0 is normal speed.
</dd>
	<dd>
設定して，再生の~rateを変更できる。
◎
Can be set, to change the rate of playback.
</dd>

	<dt>%media . `played$mM</dt>
	<dd>
~UAが再生した`~media資源$の範囲たちを表現する， `TimeRanges$I ~objを返す。
◎
Returns a TimeRanges object that represents the ranges of the media resource that the user agent has played.
</dd>

	<dt>%media . `play()$mM</dt>
	<dd>
`paused$mM 属性を ~F に設定する。
加えて，必要とされれば、`~media資源$を読込んで再生を始める。
再生が終止していた場合、始端から開始し直すことになる。
◎
Sets the paused attribute to false, loading the media resource and beginning playback if necessary. If the playback had ended, will restart it from the start.
</dd>

	<dt>%media . `pause()$mM</dt>
	<dd>
`paused$mM 属性を ~T に設定する。
加えて、必要とされるなら`~media資源$を読込む。
◎
Sets the paused attribute to true, loading the media resource if necessary.
</dd>
</dl>


<dl class="idl-def">
	<dt>`paused@mM</dt>
	<dd>
此れは~pauseされているかどうかを表現する。
初期~時には ~T にされ~MUST。
◎
The paused attribute represents whether the media element is paused or not. The attribute must initially be true.
</dd>
</dl>

<div class="p">
<p>
`~media要素$は、次をすべて満たしているとき
`阻まれて@
いるとされる：
</p>

<ul ><li>`readyState$mM 属性 ~IN {
`HAVE_NOTHING$mM,
`HAVE_METADATA$mM,
`HAVE_CURRENT_DATA$mM
}
</li><li>`利用者~対話のため~pauseされ$ている
</li><li>`帯域内~内容のため~pauseされ$ている
</li></ul>
◎
A media element is a blocked media element if its readyState attribute is in the HAVE_NOTHING state, the HAVE_METADATA state, or the HAVE_CURRENT_DATA state, or if the element has paused for user interaction or paused for in-band content.
</div>

<div class="p">
<p>
`~media要素$は、次をすべて満たしているとき
`再生-中であり得る@
とされる：
</p>

<ul><li>`paused$mM 属性 ~EQ ~F
</li><li>`再生は終止して$いない
</li><li>再生は`~errorに因り停止され$ていない
</li><li>`阻まれて$いない
</li></ul>
◎
A media element is said to be potentially playing when its paused attribute is false, the element has not ended playback, playback has not stopped due to errors, and the element is not a blocked media element.
</div>

<p class="note">注記：
`再生-中であり得る$要素は、［
その `readyState$mM 属性が `HAVE_FUTURE_DATA$mM 未満の値に変化した
］ことに因る結果，再生を停止したときには， `waiting$et ~eventが
<a href="#fire-waiting-when-waiting">発火され得る</a>。
◎
A waiting DOM event can be fired as a result of an element that is potentially playing stopping playback due to its readyState attribute changing to a value lower than HAVE_FUTURE_DATA.
</p>

<div class="p">
<p>
`~media要素$は、次をすべて満たしているとき
`自動再生に適格@
とされる：
</p>
<ul><li>`自動再生~可能~flag$ ~EQ ~T
</li><li>`paused$mM 属性 ~EQ ~T
</li><li>`autoplay$aM 属性を有している
</li><li>`閲覧文脈~sandbox化( 自動~特色機能 )~flag$ ~NIN 要素の`~node文書$の`作動中の~sandbox用~flag集合$
</li></ul>

◎
A media element is said to be eligible for autoplay when its can autoplay flag is true, its paused attribute is true, the element has an autoplay attribute specified, and the element's node document's active sandboxing flag set does not have the sandboxed automatic features browsing context flag set.
</div>

<p>
`~media要素$は、~UA, および~systemが現在の文脈において~media再生を許容するならば，
`再生は許容され@
るとされる。
◎
A media element is said to be allowed to play if the user agent and the system allow media playback in the current context.
</p>

<p class="note">注記：
例えば~UAは、再生には`利用者による作動化から誘発されて$いることも要求できるが、`消音-$されている間は，例外的に再生を許容することもできる。
◎
For example, a user agent could require that playback is triggered by user activation, but an exception could be made to allow playback while muted.
</p>

<p>
`~media要素$は、次のすべてを満たしている間は
`再生は終止して@
いるとされる：
◎
A media element is said to have ended playback when:
</p>

<ul>
	<li>
`readyState$mM 属性 ~GTE `HAVE_METADATA$mM
◎
The element's readyState attribute is HAVE_METADATA or greater, and
</li>
	<li>
<p>
次のいずれかを満たしている：
◎
Either:
</p>
		<ul>
			<li>
<p>
次のすべてを満たしている：
</p>

				<ul>
					<li>
`現在の再生~位置$は`~media資源$の終端にある
◎
The current playback position is the end of the media resource, and
</li>
					<li>
`再生~方向$ ~EQ 順方向
◎
The direction of playback is forwards, and
</li>
					<li>
`loop$aM 属性を有していない
◎
The media element does not have a loop attribute specified. 
</li>
				</ul>
			</li>
			<li>
<p>
次のすべてを満たしている：
◎
Or:
</p>
			<ul>
				<li>
`現在の再生~位置$は`可能な最も早い位置$である
◎
The current playback position is the earliest possible position, and
</li>
				<li>
`再生~方向$ ~EQ 逆方向
◎
The direction of playback is backwards. 
</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>


<dl class="idl-def">
	<dt>`ended@mM</dt>
	<dd>
<p>
取得子は、［
最後に`~event-loop$の`最初の段$に達した時点で 次のいずれも満たされていたならば ~T ／
~ELSE_ ~F
］を返さ~MUST
</p>

<ul><li>此れの`再生は終止して$いる
</li><li>此れの`再生~方向$ ~EQ 順方向
</li></ul>

◎
The ended attribute must return true if, the last time the event loop reached step 1, the media element had ended playback and the direction of playback was forwards, and false otherwise.
</dd>
</dl>

<div class="p">
<p>
`~media要素$は、次をすべて満たしている間は，
`~errorに因り停止され@
ているとされる：
</p>
<ul><li>`readyState$mM 属性 ~GTE `HAVE_METADATA$mM
</li><li>~UAは要素の`~media~data$の処理している間に`致命的でない~errorに遭遇-$した
</li><li>その~errorに因り，`現在の再生~位置$にある内容を再生できなくなった
</li></ul>
◎
A media element is said to have stopped due to errors when the element's readyState attribute is HAVE_METADATA or greater, and the user agent encounters a non-fatal error during the processing of the media data, and due to that error, is not able to play the content at the current playback position.
</div>

<div class="p">
<p>
`~media要素$は、次をすべて満たしている間は，
`利用者~対話のため~pauseされ@
ているとされる：
</p>

<ul><li>`paused$mM 属性 ~EQ ~F
</li><li>`readyState$mM 属性 ~IN { `HAVE_FUTURE_DATA$mM, `HAVE_ENOUGH_DATA$mM }
</li><li>`~media資源$内の［
利用者が再生を継続するかどうか選択する必要がある
］地点に達した
</li></ul>
◎
A media element is said to have paused for user interaction when its paused attribute is false, the readyState attribute is either HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA and the user agent has reached a point in the media resource where the user has to make a selection for the resource to continue.
</div>

<p>
`~media要素$は、`再生は終止して$いると同時に`利用者~対話のため~pauseされ$ていることもあり得る。
◎
It is possible for a media element to have both ended playback and paused for user interaction at the same time.
</p>

<p>
`再生-中であり得る$`~media要素$ %要素 が`利用者~対話のため~pauseされ$たため，再生-を停止したときは、~UAは，次を走らす`~taskを待入し$~MUST
⇒
%要素 に向けて，名前 `timeupdate$et の`~eventを発火-$する
◎
When a media element that is potentially playing stops playing because it has paused for user interaction, the user agent must queue a task to fire an event named timeupdate at the element.
</p>

<div class="p">
<p>
`~media要素$は、次をすべて満たしている間は，
`帯域内~内容のため~pauseされ@
ているとされる：
</p>

<ul><li>`paused$mM 属性 ~EQ ~F
</li><li>`readyState$mM 属性 ~IN { `HAVE_FUTURE_DATA$mM, `HAVE_ENOUGH_DATA$mM }
</li><li>~UAは、次のいずれかを再生するために，`~media資源$の再生を休止している：
	<ul><li>`~media資源$に一時的に留められた，長さ 0 でない内容
	</li><li>`~media資源$のある区分に一時的に留められた，その区分より長い内容
	</li></ul>
</li></ul>
◎
A media element is said to have paused for in-band content when its paused attribute is false, the readyState attribute is either HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA and the user agent has suspended playback of the media resource in order to play content that is temporally anchored to the media resource and has a non-zero length, or to play content that is temporally anchored to a segment of the media resource but has a length longer than that segment.
</div>

<p class="example">
`~media要素$が`帯域内~内容のため~pauseされ$ることになる例としては、
~UAが外部の~WebVTT~fileから `Descriptions$st を再生していて、ある~cue用に生成された合成された発話の長さが`開始-時刻$tCから`終止-時刻$tCまでの時間より長い場合が挙げられる。
◎
One example of when a media element would be paused for in-band content is when the user agent is playing audio descriptions from an external WebVTT file, and the synthesized speech generated for a cue is longer than the time between the text track cue start time and the text track cue end time.
</p>

<hr>

<p id="reaches-the-end" class="algo-head">
`~media要素$ %要素 の［
`再生~方向$ ~EQ 順方向
］の下で， %要素 の`現在の再生~位置$が`~media資源$の終端に達したときは、~UAは，次の手続きに従わ~MUST：
◎
When the current playback position reaches the end of the media resource when the direction of playback is forwards, then the user agent must follow these steps:
</p>

<ol>
	<li>
<p>
~IF［
%要素 は `loop$aM 属性を有する
］：
</p>

<ol><li>`~media資源$の`可能な最も早い位置$へ`~seek$する
</li><li>~RET
</li></ol>

◎
If the media element has a loop attribute specified, then seek to the earliest possible position of the media resource and abort these steps.
</li>
	<li>
~Assert：
上に定義したように， %要素 の `ended$mM ~IDL属性は、`~event-loop$が`最初の段$に戻った時点から ~T を返すようになる。
◎
As defined above, the ended IDL attribute starts returning true once the event loop returns to step 1.
</li>
	<li>
<p>
次を走らす`~taskを待入する$：
◎
Queue a task to run these steps:
</p>

		<ol>
			<li>
%要素 に向けて，名前 `timeupdate$et の`~eventを発火-$する
◎
Fire an event named timeupdate at the media element.
</li>
			<li>
<p>
~IF［
%要素 の`再生は終止して$いる
］~AND［
%要素 の`再生~方向$ ~EQ 順方向
］~AND［
%要素 の `paused$mM ~EQ ~F
］：
◎
If the media element has ended playback, the direction of playback is forwards, and paused is false, then:
</p>
				<ol>
					<li>
%要素 の `paused$mM 属性 ~SET ~T
◎
Set the paused attribute to true.
</li>
					<li>
%要素 に向けて，名前 `pause$et の`~eventを発火-$する
◎
Fire an event named pause at the media element.
</li>
					<li>
`再生待ち~promiseたちを却下-$する
( %要素 の`再生待ち~promiseたちを取り出$した結果, `AbortError$E 例外 )
◎
Take pending play promises and reject pending play promises with the result and an "AbortError" DOMException.
</li>
				</ol>
			</li>
			<li>
%要素 に向けて，名前 `ended$et の`~eventを発火-$する
◎
Fire an event named ended at the media element.
</li>
		</ol>
	</li>
</ol>

<p>
［
`再生~方向$ ~EQ 逆方向
］の下で，`現在の再生~位置$が`~media資源$ %要素 の`可能な最も早い位置$に達した†ときは、~UAは，次を走らす`~taskを待入し$~MUST
⇒
%要素 に向けて，名前 `timeupdate$et の`~eventを発火-$する
◎
When the current playback position reaches the earliest possible position of the media resource when the direction of playback is backwards, then the user agent must only queue a task to fire an event named timeupdate at the element.
</p>

<p class="note">注記†：
この “達した” は、通常の再生によるものに限られない。
具体例として、`~seeking$を介しても達し得る。
◎
The word "reaches" here does not imply that the current playback position needs to have changed during normal playback; it could be via seeking, for instance.
</p>

<hr>

<dl class="idl-def">
	<dt>`defaultPlaybackRate@mM</dt>
	<dd>
欲される，此れの`~media資源$の再生-速度を、その内在的~速度からの倍数として与える。
◎
↓</dd>
	<dd>
取得子は、最後に設定された値を返さ~MUST
— 初期~時には 1.0 に設定されているとする。
◎
↓</dd>
	<dd>
設定子は、この属性を所与の値に設定し~MUST。
◎
The defaultPlaybackRate attribute gives the desired speed at which the media resource is to play, as a multiple of its intrinsic speed. The attribute is mutable: on getting it must return the last value it was set to, or 1.0 if it hasn't yet been set; on setting the attribute must be set to the new value.
</dd>
	<dd class="note">注記：
`defaultPlaybackRate$mM は、利用者に`~UIを公開-$するときに~UAにより利用される。
◎
The defaultPlaybackRate is used by the user agent when it exposes a user interface to the user.
</dd>

	<dt>`playbackRate@mM</dt>
	<dd>
実効~再生~rateを，此れの`~media資源$の内在的~速度の倍数として与える
— それが，この資源を再生する速度になる。
この値 ~NEQ `defaultPlaybackRate$mM の場合、［
利用者は［
高速な順方向／低速~motion
］再生などの特色機能を利用している
］ことを含意する。
◎
↓</dd>
	<dd>
取得子は、最後に設定された値を返さ~MUST
— 初期~時には 1.0 に設定されているとする。
◎
↓</dd>
	<dd>
設定子は、所与の値に設定し~MUST
— 再生~速度は変化することになる（此れが`再生-中であり得る$ならば）。
◎
The playbackRate attribute gives the effective playback rate, which is the speed at which the media resource plays, as a multiple of its intrinsic speed. If it is not equal to the defaultPlaybackRate, then the implication is that the user is using a feature such as fast forward or slow motion playback. The attribute is mutable: on getting it must return the last value it was set to, or 1.0 if it hasn't yet been set; on setting the attribute must be set to the new value, and the playback will change speed (if the element is potentially playing).
</dd>
</dl>

<p id="rateUpdate">
`defaultPlaybackRate$mM ／
`playbackRate$mM
属性の値が変更されたときは（~scriptにより設定されようが，例えば利用者からの制御に呼応して~UAにより直接的に変更されようが）、~UAは，次を走らす`~taskを待入し$~MUST
⇒
`~media要素$に向けて，名前 `ratechange$et の`~eventを発火-$する
◎
When the defaultPlaybackRate or playbackRate attributes change value (either by being set by script or by being changed directly by the user agent, e.g. in response to user control) the user agent must queue a task to fire an event named ratechange at the media element.
</p>

<hr>

<dl class="idl-def">
	<dt>`played@mM</dt>
	<dd>
取得子は、この属性が評価された時点で［
此れの`~media資源$の`~media時間軸$上の，［
通常の再生の間に、通例的に`現在の再生~位置$が単調に増加して達した，一連の範囲
］を表現する，新たな静的かつ`正規化済み$ `TimeRanges$I ~objを返さ~MUST。
◎
The played attribute must return a new static normalized TimeRanges object that represents the ranges of points on the media timeline of the media resource reached through the usual monotonic increase of the current playback position during normal playback, if any, at the time the attribute is evaluated.
</dd>
</dl>

<hr>

<p>
各
`~media要素$は
`再生待ち~promiseの~list@
を持つ
— 初期~時には空にされ~MUST。
◎
Each media element has a list of pending play promises, which must initially be empty.
</p>

<p class="algo-head">
`~media要素$に対し
`再生待ち~promiseたちを取り出@
すときは、次を走らせ~MUST：
◎
To take pending play promises for a media element, the user agent must run the following steps:
</p>

<ol>
	<li>
%~promise~list ~LET `~media要素$の`再生待ち~promiseの~list$の複製
◎
Let promises be an empty list of promises.
◎
Copy the media element's list of pending play promises to promises.
</li>
	<li>
`~media要素$の`再生待ち~promiseの~list$を空にする
◎
Clear the media element's list of pending play promises.
</li>
	<li>
~RET %~promise~list
◎
Return promises.
</li>
</ol>

<p class="algo-head">
`~media要素$に対する
`再生待ち~promiseたちを解決-@
するときは、所与の
( ~promiseの~list %~promise~list )
に対し，次を走らせ~MUST
⇒
%~promise~list 内の ~EACH( %~promise ) 
⇒
`undefined^jv で %~promise を解決する
◎
To resolve pending play promises for a media element with a list of promises promises, the user agent must resolve each promise in promises with undefined.
</p>

<p class="algo-head">
`~media要素$に対する
`再生待ち~promiseたちを却下-@
するときは、所与の
( ~promiseの~list %~promise~list, 例外~名 %~error ) 
に対し，次を走らせ~MUST
⇒
%~promise~list 内の ~EACH( %~promise ) に対し
⇒
%~error で %~promise を却下する
◎
To reject pending play promises for a media element with a list of promise promises and an exception name error, the user agent must reject each promise in promises with error.
</p>

<p class="algo-head">
`~media要素$ %要素 に対し
`再生-中について通知-@
するときは、次を走らせ~MUST：
◎
To notify about playing for a media element, the user agent must run the following steps:
</p>

<ol>
	<li>
%~promise~list ~LET
%要素 の`再生待ち~promiseたちを取り出$した結果
◎
Take pending play promises and let promises be the result.
</li>
	<li>
<p>
次を走らす`~taskを待入する$：
◎
Queue a task to run these steps:
</p>
		<ol>
			<li>
%要素 に向けて，名前 `playing$et の`~eventを発火-$する
◎
Fire an event named playing at the element.
</li>
			<li>
`再生待ち~promiseたちを解決-$する( %~promise~list )
◎
Resolve pending play promises with promises.
</li>
		</ol>
	</li>
</ol>

<dl class="idl-def">
	<dt>`play()@mM</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the play() method on a media element is invoked, the user agent must run the following steps.
</p>

		<ol>
			<li>
~IF［
此れの`再生は許容され$ていない
］
⇒
~RET `NotAllowedError$E 例外で却下された~promise
◎
If the media element is not allowed to play, return a promise rejected with a "NotAllowedError" DOMException and abort these steps.
</li>
			<li>
%error ~LET 此れの `error$mM 属性
</li>
			<li>
<p>
~IF［
%error ~NEQ ~NULL
］~AND［
%error の`~code$ ~EQ `MEDIA_ERR_SRC_NOT_SUPPORTED$mE
］
⇒
~RET `NotSupportedError$E 例外で却下された~promise
◎
If the media element's error attribute is not null and its code is MEDIA_ERR_SRC_NOT_SUPPORTED, return a promise rejected with a "NotSupportedError" DOMException and abort these steps.
</p>

<p class="note">注記：
これは、`専用の~media~source失敗~手続き$を走らせたことを意味する。
再生は、［
`~media要素~読込み~algo$により `error$mM 属性が ~NULL にされる
］まで，可能でない。
◎
This means that the dedicated media source failure steps have run. Playback is not possible until the media element load algorithm clears the error attribute.
</p>
			</li>
			<li>
%~promise ~LET 新たな~promise
◎
↓</li>
			<li>
`再生待ち~promiseの~list$に %~promise を付加する
◎
Let promise be a new promise and append promise to the list of pending play promises.
</li>
			<li>
~IF［
此れの `networkState$mM 属性~値 ~EQ `NETWORK_EMPTY$mM
］
⇒
此れの`資源~選定~algo$を呼出す
◎
If the media element's networkState attribute has the value NETWORK_EMPTY, invoke the media element's resource selection algorithm.
</li>
			<li>
<p>
~IF［
此れの`再生は終止して$いる
］~AND［
此れの`再生~方向$ ~EQ 順方向
］
⇒
此れの`~media資源$の`可能な最も早い位置$へ`~seek$する
◎
If the playback has ended and the direction of playback is forwards, seek to the earliest possible position of the media resource.
</p>

<p class="note">注記：
これは、~UAに<a href="#seekUpdate">次を行わせることになる</a>：
此れに向けて，名前 `timeupdate$et の`~eventを発火-$する`~taskを待入する$
◎
This will cause the user agent to queue a task to fire an event named timeupdate at the media element.
</p>
			</li>
			<li>
%準備状態 ~LET 此れの `readyState$mM 属性~値
</li>
			<li>
<p>
~IF［
此れの `paused$mM 属性~値 ~EQ ~T
］：
◎
If the media element's paused attribute is true, then:
</p>
				<ol>
					<li>
此れの `paused$mM 属性 ~SET ~F
◎
Change the value of paused to false.
</li>
					<li>
<p>
~IF［
此れの`~show~poster~flag$ ~EQ ~T
］：
</p>
<ol ><li>此れの`~show~poster~flag$ ~SET ~F
</li><li>`~time-march-on$ 手続きを走らす
</li></ol>
◎
If the show poster flag is true, set the element's show poster flag to false and run the time marches on steps.
</li>
					<li>
次を走らす`~taskを待入する$
⇒
此れに向けて，名前 `play$et の`~eventを発火-$する
◎
Queue a task to fire an event named play at the element.
</li>
					<li>
~IF［
%準備状態 ~IN {
`HAVE_NOTHING$mM,
`HAVE_METADATA$mM,
`HAVE_CURRENT_DATA$mM
}
］
⇒
次を走らす`~taskを待入する$
⇒
此れに向けて，名前 `waiting$et の`~eventを発火-$する
◎
If the media element's readyState attribute has the value HAVE_NOTHING, HAVE_METADATA, or HAVE_CURRENT_DATA, queue a task to fire an event named waiting at the element.
</li>
					<li>
~ELSE（
%準備状態 ~IN {
`HAVE_FUTURE_DATA$mM, 
`HAVE_ENOUGH_DATA$mM
}
）
⇒
此れに対し，`再生-中について通知-$する
◎
Otherwise, the media element's readyState attribute has the value HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA: notify about playing for the element.
</li>
				</ol>
			</li>
			<li>
<div class="p">
<p>
~ELIF［
%準備状態 ~IN {
`HAVE_FUTURE_DATA$mM,
`HAVE_ENOUGH_DATA$mM
}
］：
</p>
<ol ><li>%~promise~list ~LET `再生待ち~promiseたちを取り出$した結果
</li><li>次を走らす`~taskを待入する$
⇒
`再生待ち~promiseたちを解決-$する( %~promise~list )
</li></ol>

◎
Otherwise, if the media element's readyState attribute has the value HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA, take pending play promises and queue a task to resolve pending play promises with the result.
</div>

<p class="note">注記：
此れはすでに再生-中にあるが、待入された~taskが走る前に，再生待ち~promiseが却下されることもあり得る。
◎
The media element is already playing. However, it's possible that promise will be rejected before the queued task is run.
</p>

			</li>
			<li>
此れの`自動再生~可能~flag$ ~SET ~F
◎
Set the media element's can autoplay flag to false.
</li>
			<li>
~RET %~promise
◎
Return promise.
</li>
		</ol>
	</dd>

	<dt>`pause()@mM</dt>
	<dd>
<p>
`~media要素$を~pauseする。
被呼出時には、次を走らせ~MUST：
◎
When the pause() method is invoked, and when the user agent is required to pause the media element, the user agent must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れの`networkState$mM 属性~値 ~EQ `NETWORK_EMPTY$mM
］
⇒
此れの`資源~選定~algo$を呼出す
◎
If the media element's networkState attribute has the value NETWORK_EMPTY, invoke the media element's resource selection algorithm.
</li>
			<li>
此れに対する`内部~pause手続き$を走らす
◎
Run the internal pause steps for the media element.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
`~media要素$ %要素 に対する
`内部~pause手続き@
は、次に従う：
◎
The internal pause steps for a media element are as follows:
</p>

<ol>
	<li>
%要素 の`自動再生~可能~flag$ ~SET ~F
◎
Set the media element's can autoplay flag to false.
</li>
	<li>
<p>
~IF［
%要素 の`paused$mM 属性 ~EQ ~F
］：
◎
If the media element's paused attribute is false, run the following steps:
</p>

		<ol>
			<li>
`paused$mM ~SET ~T
◎
Change the value of paused to true.
</li>
			<li>
%~promise~list ~LET `再生待ち~promiseたちを取り出$した結果
◎
Take pending play promises and let promises be the result.
</li>
			<li>
<p>
次を走らす`~taskを待入する$：
◎
Queue a task to run these steps:
</p>

				<ol>
					<li>
%要素 に向けて，名前 `timeupdate$et の`~eventを発火-$する
◎
Fire an event named timeupdate at the element.
</li>
					<li>
%要素 に向けて，名前 `pause$et の`~eventを発火-$する
◎
Fire an event named pause at the element.
</li>
					<li>
%要素 の`再生待ち~promiseたちを却下-$する( %~promise~list, `AbortError$E 例外 )
◎
Reject pending play promises with promises and an "AbortError" DOMException.
</li>
				</ol>
			</li>
			<li>
%要素 の`公式的な再生~位置$ ~SET `現在の再生~位置$
◎
Set the official playback position to the current playback position.
</li>
		</ol>
	</li>
</ol>

<hr>

<p>
要素の
`再生~方向@
は、［
`playbackRate$mM ~GTE 0 ならば順方向 ／
~ELSE_ 逆方向
］とする。
◎
If the element's playbackRate is positive or zero, then the direction of playback is forwards. Otherwise, it is backwards.
</p>

<p id="media-playback">
`~media要素$ %要素 は、［
`再生-中であり得る$
~AND
%要素 の`~node文書$は`全部的に作動中$である
］下では、 %要素 の`現在の再生~位置$は，［
`~media時間軸$の時計の単位~時間 ~EQ 
( ~mediaの単位~時間 × %要素 の `playbackRate$mM )
］になるように，単調に増加し~MUST。
（この仕様は，これを常に `増加-^i と記しているが、実際には，要素の `playbackRate$mM が負の場合は<em>減少-</em>になる。）
◎
When a media element is potentially playing and its Document is a fully active Document, its current playback position must increase monotonically at the element's playbackRate units of media time per unit time of the media timeline's clock. (This specification always refers to this as an increase, but that increase could actually be a decrease if the element's playbackRate is negative.)
</p>

<p class="note">注記：
要素の `playbackRate$mM は 0.0 にもなり得る。
その事例では、再生が~pauseされていなくても`現在の再生~位置$は移動しない（ `paused$mM ~T にはならず， `pause$et ~eventは発火されない）。
◎
The element's playbackRate can be 0.0, in which case the current playback position doesn't move, despite playback not being paused (paused doesn't become true, and the pause event doesn't fire).
</p>

<p class="note">注記：
この仕様は、~UAが適切な再生~rateをどう達成するかは定義しない。
それは、可用な~protocolや~mediaに依存して，概ね可能にもなり得る
— ~UAが~serverと折衝して、~clientが実際に何~frameか［
落とさずに済む／補間せずに済む
］よう，~serverに~media~dataを適切な~rateで提供してもらえれば（~rateが変更されてから，~serverが~streamの再生~rateを更新するまでの期間は別として）。
◎
This specification doesn't define how the user agent achieves the appropriate playback rate — depending on the protocol and media available, it is plausible that the user agent could negotiate with the server to have the server provide the media data at the appropriate rate, so that (except for the period between when the rate is changed and when the server updates the stream's playback rate) the client doesn't actually have to drop or interpolate any frames.
</p>

<p>
どの時点であれ，~UAが`安定~状態を待受ける$ときは、`公式的な再生~位置$は，`現在の再生~位置$に設定され~MUST。
◎
Any time the user agent provides a stable state, the official playback position must be set to the current playback position.
</p>

<div class="p">
<p>
次のいずれかに該当する間は、音声は`消音-$され~MUST。
</p>

<ul><li>`再生~方向$ ~EQ 逆方向
</li><li>要素の `playbackRate$mM が，~UAが音声を有用に再生できないほどに 低過ぎるか高過ぎる
</li></ul>

<p>
［
要素の `playbackRate$mM ~NEQ 1.0
］の間は、~UAは，忠実に具現化する必要に応じて音声に音高~調整を適用して~MAY。
</p>
◎
While the direction of playback is backwards, any corresponding audio must be muted. While the element's playbackRate is so low or so high that the user agent cannot play audio usefully, the corresponding audio must also be muted. If the element's playbackRate is not 1.0, the user agent may apply pitch adjustments to the audio as necessary to render it faithfully.
</div>

<p>
`~media要素$が［
`再生-中であり得る$
］~AND［
`文書~内$にない
］間は，動画を再生しては~MUST_NOTが、音声~成分があれば それは再生するべきである。
~media要素は、それへの参照-がすべて除去されたとしても，それだけで再生-を停止しては~MUST_NOT
— ~media要素が~garbage収集されても~MAYのは、それ以上~要素の音声を再生できなくなって以降に限られる。
◎
Media elements that are potentially playing while not in a document must not play any video, but should play any audio component. Media elements must not stop playing just because all references to them have been removed; only once a media element is in a state where no further audio could ever be played by that element may the element be garbage collected.
</p>

<p class="note">注記：
要素への明示的な参照-は存在しなくとも，要素が音声を再生することはあり得る
— そのような要素は、依然として能動的に再生していない場合でも：
具体例として、［
~pauseされなくなったが，内容を~bufferする待機-中に~stallしたか、あるいは，~bufferしていて再生を始めるような `suspend$et ~event~listenerがある
］こともある。
~media要素の`~media資源$に音声~trackが伴われない場合でも、その`~media資源$を変更するような~event~listenerがあった場合，最終的に再び音声を再生できることもある。
◎
It is possible for an element to which no explicit references exist to play audio, even if such an element is not still actively playing: for instance, it could be unpaused but stalled waiting for content to buffer, or it could be still buffering, but with a suspend event listener that begins playback. Even a media element whose media resource has no audio tracks could eventually play audio again if it had an event listener that changes the media resource.
</p>

<hr>

<p>
各`~media要素$ %要素 は
`新たに導入される~cueの~list@
を持つ
`…以下、この用語に関わる要件は未訳。^tnote
◎
Each media element has a list of newly introduced cues...
</p>


<p>
`~media要素$ %要素 における
`~time-march-on@
手続きは、次に従う：
◎
The time marches on steps are as follows:
</p>

<p class="trans-note">【
以下、この~algoの内容（`~text~track$を再生に同期させるための処理）は未訳。
】</p>

<p class="note">注記：
`~media要素$の`~node文書$が`全部的に作動中$でなくなった場合、文書が再び作動中になるまで，<a href="#media-playback" >再生は停止する</a>ことになる。
◎
If the media element's node document stops being a fully active document, then the playback will stop until the document is active again.
</p>

<p>
`~media要素$ %要素 が`文書から除去され$たときは、次を走らせ~MUST：
◎
When a media element is removed from a Document, the user agent must run the following steps:
</p>

<ol>
	<li>
<p>
%要素 を除去した`~task$を継続できるようにするため、次の一連の段を`同期区間$として，`安定~状態を待受ける$：
◎
Await a stable state, allowing the task that removed the media element from the Document to continue. The synchronous section consists of all the remaining steps of this algorithm. (Steps in the synchronous section are marked with ⌛.)
</p>
		<ol>
			<li>
~IF［
%要素 は`文書~内$にある
］
⇒
~RET
◎
⌛ If the media element is in a document, abort these steps.
</li>
			<li>
%要素 に対する`内部~pause手続き$を走らす
◎
⌛ Run the internal pause steps for the media element.
</li>
		</ol>
	</li>
</ol>

				</section>
				<section id="seeking">
<h4 title="Seeking">4.8.12.9. ~seek法</h4>

<dl class="domintro">

	<dt>%media . `seeking$mM</dt>
	<dd>
~UAは現在~seekしているならば ~T を返す。
◎
Returns true if the user agent is currently seeking.
</dd>

	<dt>%media . `seekable$mM</dt>
	<dd>
`~media資源$の一連の範囲のうち，~UAが~seek可能なものからなる~listを表現する，
`TimeRanges$I ~objを返す。
◎
Returns a TimeRanges object that represents the ranges of the media resource to which it is possible for the user agent to seek.
</dd>

	<dt>%media . `fastSeek(time)$mM</dt>
	<dd>
精度と引き換えに速度を得るよう，可能な限り高速に、所与の %time の近くへ~seekする。
（精確な時刻へ~seekするためには `currentTime$mM 属性を利用すること。）
◎
Seeks to near the given time as fast as possible, trading precision for speed. (To seek to a precise time, use the currentTime attribute.)
</dd>
	<dd>
~media資源がまだ読込まれてない場合、何もしない。
◎
This does nothing if the media resource has not been loaded.
</dd>
</dl>


<dl class="idl-def">
	<dt>`seeking@mM</dt>
	<dd>
初期~時には ~F にされ~MUST。
◎
The seeking attribute must initially have the value false.
</dd>

	<dt>`fastSeek(time)@mM</dt>
	<dd>
被呼出時には、［
`速度優先~flag^i  ~SET ~ON
］の下で，
%time が与える時刻へ`~seek$し~MUST。
◎
The fastSeek() method must seek to the time given by the method's argument, with the approximate-for-speed flag set.
</dd>
</dl>

<p class="algo-head">
`速度優先~flag^i （省略時は ~OFF ）が与えられた下で，
`~media要素$ %要素 の`~media資源$ %資源 内の特定0の %新たな再生~位置 へ
`~seek@
するときは、次を走らせ~MUST：
<!-- 
This algorithm interacts closely with the event loop mechanism; in particular, it has a synchronous section (which is triggered as part of the event loop algorithm). Steps in that section are marked with ⌛.
この~algoは、~event-loopの仕組みと~closely対話する。
特に，その同期区間は、~event-loop ~algoの一部として誘発される。
その区間内の段には ⌛ が付与される。
 -->
◎
When the user agent is required to seek to a particular new playback position in the media resource, optionally with the approximate-for-speed flag set, it means that the user agent must run the following steps. This algorithm interacts closely with the event loop mechanism; in particular, it has a synchronous section (which is triggered as part of the event loop algorithm). Steps in that section are marked with ⌛.
</p>

<ol>
	<li>
%要素 の`~show~poster~flag$ ~SET ~F
◎
Set the media element's show poster flag to false.
</li>
	<li>
~IF［
%要素 の`readyState$mM ~EQ `HAVE_NOTHING$mM
］
⇒
~RET
◎
If the media element's readyState is HAVE_NOTHING, abort these steps.
</li>
	<li>
~IF［
%要素 の `seeking$mM 属性 ~EQ ~T
］
⇒
この~algoの別の~instanceがすでに走っている
— その~instanceを，それが完了するのを待機せずに中止する
◎
If the element's seeking IDL attribute is true, then another instance of this algorithm is already running. Abort that other instance of the algorithm without waiting for the step that it is running to complete.
</li>
	<li>
%要素 の `seeking$mM 属性 ~SET ~T
◎
Set the seeking IDL attribute to true.
</li>
	<li>
~IF［
この~algoは、~scriptによる ~IDL［
~method~call ／ 属性の設定子
］に呼応して呼出されている
］
⇒
~RET （その~scriptを継続させる）
— ただし
⇒
この手続きの以降も`並列的$に走らす
— ただし
⇒
この~algoの以下に現れる，`安定~状態を待受ける$箇所は、この~algoの別の~instanceが呼出された場合，それにより いつでも中止され得る。
◎
If the seek was in response to a DOM method call or setting of an IDL attribute, then continue the script. The remainder of these steps must be run in parallel. With the exception of the steps marked with ⌛, they could be aborted at any time by another instance of this algorithm being invoked.
</li>
	<li>
~IF［
%新たな再生~位置 ~GT %資源 の終端
］
⇒
%新たな再生~位置 ~SET %資源 の終端
◎
If the new playback position is later than the end of the media resource, then let it be the end of the media resource instead.
</li>
	<li>
~IF［
%新たな再生~位置 ~LT `可能な最も早い位置$
］
⇒
%新たな再生~位置 ~SET `可能な最も早い位置$
◎
If the new playback position is less than the earliest possible position, let it be that position instead.
</li>
	<li>
%現~位置 ~LET `現在の再生~位置$
◎
↓</li>
	<li>
%範囲~list ~LET %要素 の `seekable$mM 属性~値
◎
↓</li>
	<li>
<p>
~IF［
%範囲~list は空である
］：
</p>
<ol ><li>%要素 の `seeking$mM ~SET ~F
</li><li>~RET
</li></ol>
◎
↓</li>
	<li>
<p>
~IF［
<!-- (possibly now changed) -->
%新たな再生~位置 は %範囲~list 内のどの範囲にも入らない
］
⇒
%新たな再生~位置 ~SET ［［
%範囲~list 内の各 範囲の始端, 終端
］のうち， %新たな再生~位置 に最も近いもの†
］のうち， %現~位置 に最も近い位置
</p>
<p>（†
一意に決まるとは限らない
— %新たな再生~位置 がある範囲の終端と次の範囲の始端のちょうど真中にある場合、その終端, 始端の 2 つがこの条件を満たす
）</p>
◎
If the (possibly now changed) new playback position is not in one of the ranges given in the seekable attribute, then let it be the position in one of the ranges given in the seekable attribute that is the nearest to the new playback position. If two positions both satisfy that constraint (i.e. the new playback position is exactly in the middle between two ranges in the seekable attribute) then use the position that is closest to the current playback position. If there are no ranges given in the seekable attribute then set the seeking IDL attribute to false and abort these steps.
</li>
	<li>
<div class="p">
<p>
~IF［
`速度優先~flag^i ~EQ ~ON
］
⇒
%新たな再生~位置 を，再生を速やかに再開できる, かつ
次が満たされるような値に調整する
— 調整-前後の %新たな再生~位置 を
( %前~位置, %後~位置 )
とするとき：
</p>

<ul><li>［
%前~位置 ~LT %現~位置
］ならば［
%後~位置 ~LT %現~位置
］
</li><li>［
%前~位置 ~GT %現~位置
］ならば［
%後~位置 ~GT %現~位置
］
</li></ul>

◎
If the approximate-for-speed flag is set, adjust the new playback position to a value that will allow for playback to resume promptly. If new playback position before this step is before current playback position, then the adjusted new playback position must also be before the current playback position. Similarly, if the new playback position before this step is after current playback position, then the adjusted new playback position must also be after the current playback position.
</div>

<p class="example">
例えば~UAは
— 復号する時刻を費やさずに済むよう —
~key~frame近くに留めて、再生を再開する前に，中間の~frameを破棄することもできる。
◎
For example, the user agent could snap to a nearby key frame, so that it doesn't have to spend time decoding then discarding intermediate frames before resuming playback.
</p>
	</li>
	<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `seeking$et の`~eventを発火-$する
◎
Queue a task to fire an event named seeking at the element.
</li>
	<li>
<p>
`現在の再生~位置$ ~SET %新たな再生~位置
◎
Set the current playback position to the new playback position.
</p>

<p class="note">注記：
%要素 は~seekingを開始する直前では`再生-中であり得る$であったが，~seekingにより
%要素 の `readyState$mM 属性が `HAVE_FUTURE_DATA$mM 未満の値に変化した場合、
%要素 に向けて， `waiting$et ~eventが
<a href="#fire-waiting-when-waiting">発火される</a>
ことになる。
◎
If the media element was potentially playing immediately before it started seeking, but seeking caused its readyState attribute to change to a value lower than HAVE_FUTURE_DATA, then a waiting event will be fired at the element.
</p>
<p class="note">注記：
この段は，`現在の再生~位置$を設定するので、即時に他の条件を誘発し得る
— 再生において “`~media資源の終端に達-$した” ときに関する規則（~loopingを取扱う~logicの一部）など —
~UAが実際に その位置~用の~media~dataを（次の段にて）具現化できるようになる前に。
◎
This step sets the current playback position, and thus can immediately trigger other conditions, such as the rules regarding when playback "reaches the end of the media resource" (part of the logic that handles looping), even before the user agent is actually able to render the media data for that position (as determined in the next step).
</p>

<p class="note">注記：
`currentTime$mM 属性は、`現在の再生~位置$ではなく，`公式的な再生~位置$を返す。
したがって、この~algoとは別に，~script実行の前に更新される。
◎
The currentTime attribute returns the official playback position, not the current playback position, and therefore gets updated before script execution, separate from this algorithm.
</p>
	</li>
	<li>
~UAが，［
%新たな再生~位置 に対する`~media~data$が可用かどうかを確立して，その位置を再生するに十分な~dataを復号する
］まで、待機する
◎
Wait until the user agent has established whether or not the media data for the new playback position is available, and, if it is, until it has decoded enough data to play back that position.
</li>
	<li>
<p>
次の一連の段を`同期区間$として，`安定~状態を待受ける$：
◎
Await a stable state. The synchronous section consists of all the remaining steps of this algorithm. (Steps in the synchronous section are marked with ⌛.)
</p>
		<ol>
			<li>
%要素 の `seeking$mM ~IDL属性 ~SET ~F
◎
⌛ Set the seeking IDL attribute to false.
</li>
			<li>
%要素 に対する`~time-march-on$手続きを走らす。
◎
⌛ Run the time marches on steps.
</li>
			<li id="seekUpdate">
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `timeupdate$et の`~eventを発火-$する
◎
⌛ Queue a task to fire an event named timeupdate at the element.
</li>
			<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `seeked$et の`~eventを発火-$する
◎
⌛ Queue a task to fire an event named seeked at the element.
</li>
		</ol>
	</li>
</ol>

<hr>

<dl class="idl-def">
	<dt>`seekable@mM</dt>
	<dd>
取得子は、［
この属性が評価された時点で，~UAが~seekできるような，此れの`~media資源$の一連の範囲
］を表現する，新たな静的かつ`正規化済み$ `TimeRanges$I ~objを返さ~MUST。
◎
The seekable attribute must return a new static normalized TimeRanges object that represents the ranges of the media resource, if any, that the user agent is able to seek to, at the time the attribute is evaluated.
</dd>
</dl>

<p class="note">注記：
~UAは、`~media資源$内のどこへでも~seekできる場合
— 例えば単純な映画~fileで，~UA, ~serverとも ~HTTP~Range要請を~supportする場合 —
この属性は、次のような 1 個の範囲からなる~objを返すことになる：
始端 ~EQ 最初の~frameの時刻（`可能な最も早い位置$, 概して 0 ）,
終端 ~EQ ［
始端 ~PLUS `duration$mM 属性の値
］（最後の~frameの時刻に等しくなり，正の `Infinity^jv にもなり得る）。
◎
If the user agent can seek to anywhere in the media resource, e.g. because it is a simple movie file and the user agent and the server support HTTP Range requests, then the attribute would return an object with one range, whose start is the time of the first frame (the earliest possible position, typically zero), and whose end is the same as the time of the first frame plus the duration attribute's value (which would equal the time of the last frame, and might be positive Infinity).
</p>

<p class="note">注記：
範囲は、変化し続けるかもしれない。
例えば、~UAが無限~streamにて~sliding-windowを~bufferしている場合。
これは、具体例を挙げれば，~live TV を~~流している DVR に見られる挙動である。
◎
The range might be continuously changing, e.g. if the user agent is buffering a sliding window on an infinite stream. This is the behavior seen with DVRs viewing live TV, for instance.
</p>

<p>
~UAは、何が~seek可能になるかについて，~~相応に柔軟かつ楽観的な~viewを採用するべきである。
~UAはまた、高速な~seekingを可能化するため，可能な所では近過去の内容を~bufferするべきである。
◎
User agents should adopt a very liberal and optimistic view of what is seekable. User agents should also buffer recent content where possible to enable seeking to be fast.
</p>

<p class="example">
具体例として、~HTTP~Range要請を~supportしない ある~HTTP~serverから~serveされている巨大な動画~fileを考える。
~browserは、現在および後続の~frame用に得られた~dataのみを~bufferすることにより，これを実装する<em>こともできる</em>
— 全く~seekできないことにして（再生を開始し直すことによる始端への~seekは別として）。
しかしながら、これでは拙い実装になる。
高~品質な実装は、内容の最後の数~分を~bufferして（あるいは~storageが十分あればもっと）、利用者が何か面白いものを再~視聴するため，その箇所へすぐに戻れるようにすることに加え、必要とされたときは，~fileを始端から再度~読込んで任意の箇所へ~seekできるようにするであろう
— 後者は前者より低速だが、それでも［
より早い，未~bufferの箇所を得るだけのために、動画を開始し直して初めからくまなく視聴する
］よりは便利になる。
◎
For instance, consider a large video file served on an HTTP server without support for HTTP Range requests. A browser could implement this by only buffering the current frame and data obtained for subsequent frames, never allow seeking, except for seeking to the very start by restarting the playback. However, this would be a poor implementation. A high quality implementation would buffer the last few minutes of content (or more, if sufficient storage space is available), allowing the user to jump back and rewatch something surprising without any latency, and would in addition allow arbitrary seeking by reloading the file from the start if necessary, which would be slower but still more convenient than having to literally restart the video and watch it all the way through just to get to an earlier unbuffered spot.
</p>

<p>
`~media資源$は、内部的に~scriptを含む／対話的なこともあるかもしれない。
したがって`~media要素$は，~~不連続に再生され得る。
これが起こった場合、~UAは，`現在の再生~位置$が不連続に変化する度に，（関連する~eventが発火されるよう）`~seek$用の~algoが利用されていたかのように動作し~MUST。
◎
Media resources might be internally scripted or interactive. Thus, a media element could play in a non-linear fashion. If this happens, the user agent must act as if the algorithm for seeking was used whenever the current playback position changes in a discontinuous fashion (so that the relevant events fire).
</p>

				</section>
				<section id="media-resources-with-multiple-media-tracks">
<h4 title="Media resources with multiple media tracks">4.8.12.10. 複数の~media~trackを伴う~media資源</h4>

<p class="trans-note">【
この節は、未訳。
<a href="https://momdo.github.io/html/embedded-content.html#media-resources-with-multiple-media-tracks">他サイトによる和訳</a>
】</p>

				</section>
				<section id="timed-text-tracks">
<h4 title="Timed text tracks">4.8.12.11. 時間同期的な~text~track</h4>

<p class="trans-note">【
この節は、未訳。
<a href="https://momdo.github.io/html/embedded-content.html#media-elements">他サイトによる和訳</a>
】</p>

				</section>
				<section id="identifying-a-track-kind-through-a-url">
<h4 title="Identifying a track kind through a URL">4.8.12.12. ~URLによる~trackの種類の識別-法</h4>

<p class="trans-note">【
この節は、未訳。
<a href="https://momdo.github.io/html/embedded-content.html#identifying-a-track-kind-through-a-url">他サイトによる和訳</a>
】</p>

				</section>
				<section id="user-interface">
<h4 title="User interface">4.8.12.13. ~UI</h4>


<p>
`controls@aM
属性は`真偽~属性$であり、在する場合，作者は［
~scriptによる~controllerは提供せず，~UAに自前の~control一式を提供させたい
］こと指示する。
◎
The controls attribute is a boolean attribute. If present, it indicates that the author has not provided a scripted controller and would like the user agent to provide its own set of controls.
</p>


<div class="p">
<p>
`~media要素$において［
属性が在する ／
要素に対する`~scriptingは不能化され$ている
］場合、~UAは利用者に
`~UIを公開-@
するべきである。
この~UIは、次に挙げる特色機能を含むべきである：
</p>

<ul><li>再生を始める
</li><li>再生を~pauseする
</li><li>内容の任意の位置へ~seekする（内容が それを~supportするならば） 
</li><li>音量を変更する
</li><li>開閉可能な~caption／埋込みの手話~trackの表示を変更する
</li><li>異なる音声~trackたちを選択する／音述をオンにする
</li><li>~media内容をより相応しい方式で利用者に示す（例えば、動画を全~screen, あるいは 独立的かつ~resize可能な~window内に示す）
</li></ul>

<p>
他の~controlも可用にされて~MAY。
</p>
◎
If the attribute is present, or if scripting is disabled for the media element, then the user agent should expose a user interface to the user. This user interface should include features to begin playback, pause playback, seek to an arbitrary position in the content (if the content supports arbitrary seeking), change the volume, change the display of closed captions or embedded sign-language tracks, select different audio tracks or turn on audio descriptions, and show the media content in manners more suitable to the user (e.g. fullscreen video or in an independent resizable window). Other controls may also be made available.
</div>

<p>
しかしながら，属性が不在のときでも、~UAは~media資源の再生に影響する~control（例：再生- ／ ~pause ／ ~seeking ／ ~track選択 ／ 音量~control）を提供して~MAYが、そのような特色機能は，頁の通常の具現化に干渉するべきでない。
例えば，そのような特色機能は［
`~media要素$の文脈~menu ／
~platform~media~key ／
~remote-control
］内に公開できる。
~UAはこれを，単純に利用者に`~UIを公開-$することにより実装して~MAY
— 上に述べたように（ `controls$aM 属性を有していたかのように）。
◎
Even when the attribute is absent, however, user agents may provide controls to affect playback of the media resource (e.g. play, pause, seeking, track selection, and volume controls), but such features should not interfere with the page's normal rendering. For example, such features could be exposed in the media element's context menu, platform media keys, or a remote control. The user agent may implement this simply by exposing a user interface to the user as described above (as if the controls attribute was present).
</p>

<p>
~UAが~controlを`~media要素$に重ねて表示することにより，利用者に`~UIを公開-$する場合、
~UAは、［
<!-- 原文誤 user agent -->
利用者が，この~interfaceと対話している間
］は，利用者~対話~eventを抑止するべきである。
（例えば，利用者が動画の再生~controlを~clickした場合、頁の要素に向けて `mousedown$et ~event等々が同時に発火されることはない。）
◎
If the user agent exposes a user interface to the user by displaying controls over the media element, then the user agent should suppress any user interaction events while the user agent is interacting with this interface. (For example, if the user clicks on a video's playback control, mousedown events and so forth would not simultaneously be fired at elements on the page.)
</p>

<p>
可能な所では，~UAにより公開される~UI特色機能は（特に，再生を［
開始- ／ 停止-
］する ／
~pauseの切り替え ／
~seekする ／
再生~rateを変更する ／［
早送り／ 早戻し
］する ／
~text~trackを［
~list ／ 可能化- ／ 不能化-
］する ／
音声の音量を［
消音-／変更-
］するための）、例えば，同じ~eventすべてが発火されるよう，上に述べた~DOM~APIの用語を通して実装され~MUST。
◎
Where possible (specifically, for starting, stopping, pausing, and unpausing playback, for seeking, for changing the rate of playback, for fast-forwarding or rewinding, for listing, enabling, and disabling text tracks, and for muting or changing the volume of the audio), user interface features exposed by the user agent must be implemented in terms of the DOM API described above, so that, e.g., all the same events fire.
</p>

<p>
早送り／早戻しなどの特色機能は、 `playbackRate$mM 属性のみを変更するよう実装され~MUST（ `defaultPlaybackRate$mM 属性ではなく）。
◎
Features such as fast-forward or rewind must be implemented by only changing the playbackRate attribute (and not the defaultPlaybackRate attribute).
</p>

<p>
~seekingは、［
`~media要素$の`~media時間軸$内の，要請された位置へ`~seek$すること
］を通して実装され~MUST。
~media資源に対しては、［
~seek~barなどの近似-位置~UIを，利用者が操作するのに呼応して~seekする
］ときに任意の位置への~seekは低速になる所では、~UAには，
`速度優先~flag^iを利用することが奨励される。
◎
Seeking must be implemented in terms of seeking to the requested position in the media element's media timeline. For media resources where seeking to an arbitrary position would be slow, user agents are encouraged to use the approximate-for-speed flag when seeking in response to the user manipulating an approximate position interface such as a seek bar.
</p>

<p>
`~media資源$内の~chapterを~listする目的においては、
`~media要素$の`~text~trackの~list$内の`~text~track$のうち，［
`~showing$tT
~AND
~text~trackの`種類$tT ~EQ `chapters$mT
］なるもののみが利用されるべきである。
そのような~trackは、`~text~trackから~chapter木を構築する規則$に則って解釈され~MUST。
利用者が~chapter選択~UIを操作するのに呼応して~seekするときには，~UAは`速度優先~flag^iを利用するべきでない。
◎
For the purposes of listing chapters in the media resource, only text tracks in the media element's list of text tracks that are showing and whose text track kind is chapters should be used. Such tracks must be interpreted according to the rules for constructing the chapter tree from a text track. When seeking in response to a user manipulating a chapter selection interface, user agents should not use the approximate-for-speed flag.
</p>

<dl class="idl-def">
	<dt>`controls@mM</dt>
	<dd>
同じ名前の内容~属性を`反映-$し~MUST。
◎
The controls IDL attribute must reflect the content attribute of the same name.
</dd>
</dl>

<hr>


<dl class="domintro">

	<dt>%media . `volume$mM [ = %value ]</dt>
	<dd>
現在の再生~音量を，範囲［
0.0 （無音）以上, 1.0 （最大音量）以下
］の数として返す。
◎
Returns the current playback volume, as a number in the range 0.0 to 1.0, where 0.0 is the quietest and 1.0 the loudest.
</dd>
	<dd>
設定して，音量を変更できる。
◎
Can be set, to change the volume.
</dd>
	<dd>
［
0.0 ~LTE 所与の値 ~LTE  1.0
］でない場合、 `IndexSizeError$E 例外が投出される。
◎
Throws an "IndexSizeError" DOMException if the new value is not in the range 0.0 .. 1.0.
</dd>

	<dt>%media . `muted$mM [ = %value ]</dt>
	<dd>
音声は消音され, `volume$mM 属性を上書きしているならば ~T ／
~ELSE_ （ `volume$mM 属性は尊守されている） ~F
を返す。
◎
Returns true if audio is muted, overriding the volume attribute, and false if the volume attribute is being honored.
</dd>
	<dd>
設定して，音声は消音されるかどうか変更できる。
◎
Can be set, to change whether the audio is muted or not.
</dd>
</dl>


<p>
`~media要素$は、範囲［
0.0 （無音）以上, 1.0 （最大音量）以下
］の小数をとり得る
`再生~音量@
を持つ。
音量は、初期~時には  1.0 にされるべきである。
が，~UAは、~siteごとなどに基づく複数~sessionにまたがって最後に設定された値を覚えて，音量を他の値から開始させても~MAY。
◎
A media element has a playback volume, which is a fraction in the range 0.0 (silent) to 1.0 (loudest). Initially, the volume should be 1.0, but user agents may remember the last set value across sessions, on a per-site basis or otherwise, so the volume may start at other values.
</p>

<dl class="idl-def">
	<dt>`volume@mM</dt>
	<dd>
取得子は、`~media要素$の音声~部の`再生~音量$を返さ~MUST。
◎
↓</dd>
	<dd>
設定子は、［
0.0 ~LTE 所与の値 ~LTE  1.0
］の場合は，`~media要素$の`再生~音量$を所与の値に設定し~MUST。
~ELSE_ `IndexSizeError$E 例外を投出し~MUST。
◎
The volume IDL attribute must return the playback volume of any audio portions of the media element. On setting, if the new value is in the range 0.0 to 1.0 inclusive, the media element's playback volume must be set to the new value. If the new value is outside the range 0.0 to 1.0 inclusive, then, on setting, an "IndexSizeError" DOMException must be thrown instead.
</dd>
</dl>


<p>
`~media要素$はまた，
`消音-@
され得る。
要素を消音している何かがあれば、それは消音される（例えば，`再生~方向$が逆方向である間は、要素は消音される）。
◎
A media element can also be muted. If anything is muting the element, then it is muted. (For example, when the direction of playback is backwards, the element is muted.)
</p>

<dl class="idl-def">
	<dt>`muted@mM</dt>
	<dd>
取得子は、最後に設定された値を返さ~MUST。
`~media要素$の作成-時には，要素が `muted$aM 内容~属性を有するならば ~T に設定されるべきである。
他の場合、~UAは値を利用者が選好する値に設定して~MAY（例えば，~siteごとなどに基づく複数~sessionにまたがって最後に設定された値を覚えておくなど）。
この属性が ~T に設定されている間は、`~media要素$は`消音-$され~MUST。
◎
The muted IDL attribute must return the value to which it was last set. When a media element is created, if the element has a muted content attribute specified, then the muted IDL attribute should be set to true; otherwise, the user agents may set the value to the user's preferred value (e.g. remembering the last set value across sessions, on a per-site basis or otherwise). While the muted IDL attribute is set to true, the media element must be muted.
</dd>
</dl>

<div class="p">
<p class="algo-head">
`~media要素$ %要素 の［
`volume$mM ／ `muted$mM
］~IDL属性が返す値が変化したときは、~UAは次を走らせ~MUST：
</p>

<ol>
	<li>
次を走らす`~taskを待入する$
⇒
%要素 に向けて，名前 `volumechange$et の`~eventを発火-$する
</li>
	<li>
~IF［
%要素 には`再生は許容され$ていない
］
⇒
%要素 に対する`内部~pause手続き$を走らす
</li>
</ol>

◎
Whenever either of the values that would be returned by the volume and muted IDL attributes change, the user agent must queue a task to fire an event named volumechange at the media element. Then, if the media element is not allowed to play, the user agent must run the internal pause steps for the media element.
</div>

<p class="algo-head">
`~media要素$ %要素 の
`実効~media音量@
は、次に従って決定される：
◎
An element's effective media volume is determined as follows:
</p>

<ol>
	<li>
~IF［
%要素 の音量を上書きするよう，利用者から指示されている
］
⇒
~RET 利用者から欲された音量
◎
If the user has indicated that the user agent is to override the volume of the element, then the element's effective media volume is the volume desired by the user. Abort these steps.
</li>
	<li>
~IF［
%要素 の音声~出力は`消音-$されている
］
⇒
~RET 0
◎
If the element's audio output is muted, the element's effective media volume is zero. Abort these steps.
</li>
	<li>
~RET %要素 の音声~部の`再生~音量$
◎
Let volume be the playback volume of the audio portions of the media element, in range 0.0 (silent) to 1.0 (loudest).
</li>
</ol>

<div class="p">
<p>
`実効~media音量$は、次のように解釈される：
</p>

<ul ><li>範囲 0.0 以上, 1.0 以下
</li><li>0.0 は無音に対応する
</li><li>1.0 は最大音量に対応する
</li><li>聴感音量は，数が大きいほど増大するが、その関係は線形になる必要はない。
</li></ul>

<p>
最大音量~設定は、例えば，利用者が聴感音量を最大に設定していたときなど，~systemの最大音量~設定より低くされても~MAY。
</p>

◎
The element's effective media volume is volume, interpreted relative to the range 0.0 to 1.0, with 0.0 being silent, and 1.0 being the loudest setting, values in between increasing in loudness. The range need not be linear. The loudest setting may be lower than the system's loudest possible setting; for example the user could have set a maximum volume.
</div>

<p>
`~media要素$上の
`muted@aM
内容~属性は、`真偽~属性$であり，`~media資源$の音声~出力の既定の状態を制御する。
それは、利用者~選好を上書きするものになり得る。
◎
The muted content attribute on media elements is a boolean attribute that controls the default state of the audio output of the media resource, potentially overriding user preferences.
</p>


<dl class="idl-def">
	<dt>`defaultMuted@mM</dt>
	<dd>
`muted$aM 内容~属性を`反映-$し~MUST。
◎
The defaultMuted IDL attribute must reflect the muted content attribute.
</dd>
	<dd class="note">注記：
この属性には動的な効果はない（要素の既定の状態のみを制御する）。
◎
This attribute has no dynamic effect (it only controls the default state of the element).
</dd>
</dl>


<div class="example">

<p>
この動画（広告）は、自動再生するが、利用者をいらつかせないよう，音響なしにそれを行い，利用者が音響ありに切り替えれるようにする。
~UAは、利用者~対話なしに消音されなくなったときは，動画を~pauseできる。
◎
This video (an advertisement) autoplays, but to avoid annoying users, it does so without sound, and allows the user to turn the sound on. The user agent can pause the video if it's unmuted without a user interaction.
</p>

<pre class="html-code">
&lt;video src="adverts.cgi?kind=video" controls autoplay loop muted&gt;&lt;/video&gt;
</pre>

</div>

				</section>
				<section id="time-ranges">
<h4 title="Time ranges">4.8.12.14. 時刻~範囲</h4>

<p>
`TimeRanges$I ~objは、一連の［
時刻の範囲（期間）
］からなる~list
— 範囲~list —
を表現する。
◎
Objects implementing the TimeRanges interface represent a list of ranges (periods) of time.
</p>

<pre class="idl">
interface `TimeRanges@I {
  readonly attribute unsigned long `length$m;
  double `start$m(unsigned long %index);
  double `end$m(unsigned long %index);
};
</pre>

<dl class="domintro">
	<dt>%media . `length$m</dt>
	<dd>
範囲~listの~sizeを返す。
◎
Returns the number of ranges in the object.
</dd>

	<dt>%time = %~media . `start(index)$m</dt>
	<dd>
範囲~list内の %index 番の範囲の始端の時刻を返す。
◎
Returns the time for the start of the range with the given index.
</dd>
	<dd>
［
%index ~GTE 範囲~listの~size
］の場合、
`IndexSizeError$E 例外が投出される。
◎
Throws an "IndexSizeError" DOMException if the index is out of range.
</dd>

	<dt>%time = %media . `end(index)$m</dt>
	<dd>
範囲~list内の  %index 番の範囲の終端の時刻を返す。
◎
Returns the time for the end of the range with the given index.
</dd>
	<dd>
［
%index ~GTE 範囲~listの~size
］の場合、
`IndexSizeError$E 例外が投出される。
◎
Throws an "IndexSizeError" DOMException if the index is out of range.
</dd>
</dl>

<dl class="idl-def">
	<dt>`length@m</dt>
	<dd>
取得子は、此れが表現する範囲~listの~sizeを返さ~MUST。
◎
The length IDL attribute must return the number of ranges represented by the object.
</dd>

	<dt>`start(index)@m</dt>
	<dt>`end(index)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
%index ~GTE 此れが表現する範囲~listの~size
］
⇒
~THROW `IndexSizeError$E
</li>
			<li>
%位置 ~LET 此れが表現する範囲~list内の %index 番の範囲の［
`start()$m に対しては始端 ／
`end()$m に対しては終端
］
</li>
			<li>
~RET
%位置 を此れが覆う時間軸の始端から秒単位で測った結果
</li>
		</ol>

◎
The start(index) method must return the position of the start of the indexth range represented by the object, in seconds measured from the start of the timeline that the object covers.
◎
The end(index) method must return the position of the end of the indexth range represented by the object, in seconds measured from the start of the timeline that the object covers.
◎
These methods must throw "IndexSizeError" DOMExceptions if called with an index argument greater than or equal to the number of ranges represented by the object.
</dd>
</dl>


<p>
`TimeRanges$I ~objが
`正規化済み@
とは、それが表現する範囲たちが，次の判定基準を順守することを意味する：
◎
When a TimeRanges object is said to be a normalized TimeRanges object, the ranges it represents must obey the following criteria:
</p>

<ul>
	<li>
<p>
どの 2 つの範囲 %A, %B に対しても，
%A の方が %B より早いならば
⇒
%A の終端 ~LT %B の始端
</p>

<p>
`“より早い（ earlier ）”： おそらく，範囲の~list内でより早い — 時間的に早いではなく。^tnote
</p>

◎
The start of a range must be greater than the end of all earlier ranges.
</li>
	<li>
どの範囲 %A に対しても
⇒
%A の始端 ~LTE %A の終端
◎
The start of a range must be less than or equal to the end of that same range.
</li>
</ul>

<p>
言い換えれば、そのような~obj内の一連の範囲は、互いに［
順序付けられ, 重合しない, 触れてない（隣接する範囲どうしは 1 個のより大きい範囲に~~集約される）
］。
範囲は空（ある瞬間の時刻のみを参照している）にもなり得る
— 例えば`~media要素$が~pauseされたとき，~UAが`~media資源$の現在の~frame以外のすべてを破棄した事例において、現在~bufferされている唯一の~frameを指示するため。
◎
In other words, the ranges in such an object are ordered, don't overlap, and don't touch (adjacent ranges are folded into one bigger range). A range can be empty (referencing just a single moment in time), e.g. to indicate that only one frame is currently buffered in the case that the user agent has discarded the entire media resource except for the current frame, when a media element is paused.
</p>

<p>
`TimeRanges$I ~objの一連の範囲は両端を含んで~MUST。
◎
Ranges in a TimeRanges object must be inclusive.
</p>

<p class="example">
したがって，ある範囲の終端は、後続する隣接する（触れているが重合していない）範囲の始端に等しくなる。
同様に， 0 を起点に時間軸~全体を覆う範囲に対しては、始端は 0 に等しくなり，終端は時間軸の時間長に等しくなる。
◎
Thus, the end of a range would be equal to the start of a following adjacent (touching but not overlapping) range. Similarly, a range covering a whole timeline anchored at zero would have a start equal to zero and an end equal to the duration of the timeline.
</p>

<p>
`~media要素$ %要素 の［
`buffered$mM ／ `seekable$mM ／ `played$mM
］~IDL属性から返される~objが利用する時間軸は、
%要素 の`~media時間軸$で~MUST。
◎
The timelines used by the objects returned by the buffered, seekable and played IDL attributes of media elements must be that element's media timeline.
</p>


				</section>
				<section id="the-trackevent-interface">
<h4 title="The TrackEvent interface">4.8.12.15. `TrackEvent$I ~interface</h4>

<pre class="idl">
[Constructor(DOMString type, optional `TrackEventInit$I eventInitDict)]
interface `TrackEvent@I : `Event$I {
  readonly attribute (`VideoTrack$I or `AudioTrack$I or `TextTrack$I)? `track$m;
};

dictionary `TrackEventInit@I : `EventInit$I {
  (`VideoTrack$I or `AudioTrack$I or `TextTrack$I)? track = null;
};
</pre>

<dl class="domintro">

	<dt>%event . `track$m</dt>
	<dd>
この~eventに関係する~track~obj（
`TextTrack$I ／ `AudioTrack$I ／ `VideoTrack$I
）を返す。
◎
Returns the track object (TextTrack, AudioTrack, or VideoTrack) to which the event relates.
</dd>
</dl>


<dl class="idl-def">
	<dt>`track@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
それは、~eventの文脈~情報を表現する。
◎
The track attribute must return the value it was initialized to. It represents the context information for the event.
</dd>
</dl>

				</section>
				<section id="mediaevents">
<h4 title="Event summary">4.8.12.16. ~event要覧</h4>

~INFORMATIVE

<p>
特に指定されたものを除き、この節に挙げるどの~eventも，
`Event$I ~interfaceを利用する。
`原文の表には “~interface” 列があるが、この訳では，一部の表を除きその列を省略してこの一文に集約する。^tnote
</p>

<p>
上に述べた処理~modelの一部として、次に挙げる~eventが`~media要素$に向けて発火される：
◎
The following events fire on media elements as part of the processing model described above:
</p>

<table><thead><tr><th>~event名
</th><th>発火-時機
</th><th>事前条件

</th></tr></thead>

<tbody><tr><td>`loadstart@et
</td><td>
~UAは、`資源~選定~algo$の一環として，`~media~data$を探し始めた。
◎
The user agent begins looking for media data, as part of the resource selection algorithm.
</td><td>
`networkState$mM ~EQ `NETWORK_LOADING$mM
◎
networkState equals NETWORK_LOADING

</td></tr><tr><td>`progress@et
</td><td>
~UAは`~media~data$を~fetchしている。
◎
The user agent is fetching media data.
</td><td>
`networkState$mM ~EQ `NETWORK_LOADING$mM
◎
networkState equals NETWORK_LOADING

</td></tr><tr><td>`suspend@et
</td><td>
~UAは`~media~data$を意図的に現在~fetchしていない。
◎
The user agent is intentionally not currently fetching media data.
</td><td>
`networkState$mM ~EQ `NETWORK_IDLE$mM
◎
networkState equals NETWORK_IDLE

</td></tr><tr><td>`abort@et
</td><td>
`~media~data$が完全に~downloadされる前に，~UAは~errorに因らずに~fetchするのを停止した。
◎
The user agent stops fetching the media data before it is completely downloaded, but not due to an error.
</td><td>
［
`error$mM ~NEQ ~NULL
］~AND［
`error$mM の`~code$ ~EQ `MEDIA_ERR_ABORTED$mE
］~AND［
`networkState$mM ~EQ ［
`NETWORK_EMPTY$mM または `NETWORK_IDLE$mM
— どちらに ~EQ かは、~downloadがいつ中止されたかに依存する
］］
◎
error is an object with the code MEDIA_ERR_ABORTED. networkState equals either NETWORK_EMPTY or NETWORK_IDLE, depending on when the download was aborted.

</td></tr><tr><td>`~errorM@et
</td><td>
［
`~media~data$を~fetchしている間に~errorが生じた
］~OR［
資源の型は~supportされない~media形式である
］
◎
An error occurs while fetching the media data or the type of the resource is not supported media format.
</td><td>
［
`error$mM ~NEQ ~NULL
］~AND［
`error$mM の`~code$ ~GTE `MEDIA_ERR_NETWORK$mE
］~AND［
`networkState$mM ~EQ ［
`NETWORK_EMPTY$mM または `NETWORK_IDLE$mM
— どちらに ~EQ かは、~downloadがいつ中止されたかに依存する
］］
◎
error is an object with the code MEDIA_ERR_NETWORK or higher. networkState equals either NETWORK_EMPTY or NETWORK_IDLE, depending on when the download was aborted.

</td></tr><tr><td>`emptied@et
</td><td>
`~media要素$の `networkState$mM 値は `NETWORK_EMPTY$mM 以外の値からその値に切替わった（報告されつつある読込みの間に致命的な~errorが生じたか，
`load()$mM ~methodは`資源~選定~algo$を走らせている間に呼出されたために。）
◎
A media element whose networkState was previously not in the NETWORK_EMPTY state has just switched to that state (either because of a fatal error during load that's about to be reported, or because the load() method was invoked while the resource selection algorithm was already running).
</td><td>
`networkState$mM ~EQ `NETWORK_EMPTY$mM
— すべての~IDL属性は，それぞれの初期~状態にある。
◎
networkState is NETWORK_EMPTY; all the IDL attributes are in their initial states.

</td></tr><tr><td>`stalled@et
</td><td>
~UAは、`~media~data$を~fetchしようと試行しているが、~dataは期待通りに入手できていない。
◎
The user agent is trying to fetch media data, but data is unexpectedly not forthcoming.
</td><td>
`networkState$mM ~EQ `NETWORK_LOADING$mM
◎
networkState is NETWORK_LOADING.

</td></tr></tbody>

<tbody><tr><td>`loadedmetadata@et
</td><td>
~UAは`~media資源$の時間長と寸法を決定した所にある
~AND
~text~trackは`準備済み$tTにある
◎
The user agent has just determined the duration and dimensions of the media resource and the text tracks are ready.
</td><td>
［
`readyState$mM ~GTE `HAVE_METADATA$mM
］でない状態から初めてそうなった
◎
readyState is newly equal to HAVE_METADATA or greater for the first time.

</td></tr><tr><td>`loadeddata@et
</td><td>
［
~UAは`現在の再生~位置$にある`~media~data$を具現化できる
］でない状態から初めてそうなった
◎
The user agent can render the media data at the current playback position for the first time.
</td><td>
［
`readyState$mM ~GTE `HAVE_CURRENT_DATA$mM
］でない状態から初めてそうなった
◎
readyState newly increased to HAVE_CURRENT_DATA or greater for the first time.

</td></tr><tr><td>`canplay@et
</td><td>
~UAは`~media~data$の再生を再開できるが、今~再生が開始された場合，［
現在の再生~rateのままでは、停止して内容を更に~bufferしない限り，`~media資源$を終端までは具現化できない
］と見積もっている
◎
The user agent can resume playback of the media data, but estimates that if playback were to be started now, the media resource could not be rendered at the current playback rate up to its end without having to stop for further buffering of content.
</td><td>
［
`readyState$mM ~GTE `HAVE_FUTURE_DATA$mM
］でない状態からそうなった
◎
readyState newly increased to HAVE_FUTURE_DATA or greater.

</td></tr><tr><td>`canplaythrough@et
</td><td>
~UAは、今~再生が開始された場合でも，［
現在の再生~rateままでも、停止して内容を更に~bufferせずに，`~media資源$は終端まで具現化できる
］と見積もっている
◎
The user agent estimates that if playback were to be started now, the media resource could be rendered at the current playback rate all the way to its end without having to stop for further buffering.
</td><td>
［
`readyState$mM ~EQ `HAVE_ENOUGH_DATA$mM
］でない状態からそうなった
◎
readyState is newly equal to HAVE_ENOUGH_DATA.

</td></tr><tr><td>`playing@et
</td><td>
`~media~data$を欠くこと因り，再生は［
~pause／遅延-
］されていたが、その後，開始-準備済みにある。
◎
Playback is ready to start after having been paused or delayed due to lack of media data.
</td><td>
［［
`readyState$mM ~GTE `HAVE_FUTURE_DATA$mM
］~AND［
`paused$mM ~EQ ~F
］］でない状態からそうなった。
この~eventが発火されても，要素は`再生-中であり得る$ようになったとは限らない
— 例：
要素は［
`利用者~対話のため~pauseされ$／
`帯域内~内容のため~pauseされ$
］ているとき。
◎
readyState is newly equal to or greater than HAVE_FUTURE_DATA and paused is false, or paused is newly false and readyState is equal to or greater than HAVE_FUTURE_DATA. Even if this event fires, the element might still not be potentially playing, e.g. if the element is paused for user interaction or paused for in-band content.

</td></tr><tr><td>`waiting@et
</td><td>
再生は次~frameが可用でないため停止されたが、~UAは，そのうち可用になると期待している。
◎
Playback has stopped because the next frame is not available, but the user agent expects that frame to become available in due course.
</td><td>
［
`readyState$mM ~LTE `HAVE_CURRENT_DATA$mM
］~AND［
`paused$mM ~EQ ~F
］~AND［［
`seeking$mM ~EQ ~T
］~OR［
`現在の再生~位置$は `buffered$mM 内のどの範囲にも包含されていない
］］。
［
`paused$mM ~EQ ~F
］でなくとも，再生は他の理由により停止され得るが、この~eventはそのような理由では発火されない（加えて，それらの状況が解決されても，別々に `playing$et ~eventは発火されない）
— 例えば：
`再生は終止して$いる ／
再生は`~errorに因り停止され$ている ／
要素は`利用者~対話のため~pauseされ$ている ／
要素は`帯域内~内容のため~pauseされ$ている
。
◎
readyState is equal to or less than HAVE_CURRENT_DATA, and paused is false. Either seeking is true, or the current playback position is not contained in any of the ranges in buffered. It is possible for playback to stop for other reasons without paused being false, but those reasons do not fire this event (and when those situations resolve, a separate playing event is not fired either): e.g., playback has ended, or playback stopped due to errors, or the element has paused for user interaction or paused for in-band content.

</td></tr></tbody>

<tbody><tr><td>`seeking@et
</td><td>
［
`seeking$mM ~IDL属性は ~T に変化した
］~AND［
~UAは新たな位置への~seekingを開始した
］
◎
The seeking IDL attribute changed to true, and the user agent has started seeking to a new position.
</td><td>

</td></tr><tr><td>`seeked@et
</td><td>
`現在の再生~位置$が変化した後に， `seeking$mM ~IDL属性は ~F に変化した。
◎
The seeking IDL attribute changed to false after the current playback position was changed.
</td><td>

</td></tr><tr><td>`ended@et
</td><td>
`~media資源$の終端に達したため、再生を停止した。
◎
Playback has stopped because the end of the media resource was reached.
</td><td>
［
`currentTime$mM ~EQ `~media資源$の終端
］~AND［
`ended$mM ~EQ ~T
］
◎
currentTime equals the end of the media resource; ended is true.

</td></tr></tbody>

<tbody><tr><td>`durationchange@et
</td><td>
`duration$mM 属性が直前に更新された。
◎
The duration attribute has just been updated.
</td><td>

</td></tr><tr><td>`timeupdate@et
</td><td>
`現在の再生~位置$は、通常の再生の一部として，とりわけ~~特徴的な仕方で
— 例えば不連続に —
変化した。
◎
The current playback position changed as part of normal playback or in an especially interesting way, for example discontinuously.
</td><td>

</td></tr><tr><td>`play@et
</td><td>
~pauseされていた要素は、再生され始めた。
［
`play()$mM ~methodが返った後 ／
`autoplay$aM 属性により再生を始めさせたとき
］に，発火される。
◎
The element is no longer paused. Fired after the play() method has returned, or when the autoplay attribute has caused playback to begin.
</td><td>
`paused$mM 値は新たに ~F になった。
◎
paused is newly false.

</td></tr><tr><td>`pause@et
</td><td>
要素は~pauseされた。
`pause()$mM ~methodが返った後に発火される。
◎
The element has been paused. Fired after the pause() method has returned.
</td><td>
`paused$mM は新たに ~T になった。
◎
paused is newly true.

</td></tr><tr><td>`ratechange@et
</td><td>
［
`defaultPlaybackRate$mM ／ `playbackRate$mM
］属性が直前に更新された。
◎
Either the defaultPlaybackRate or the playbackRate attribute has just been updated.
</td><td>

</td></tr></tbody>

<tbody><tr><td>`resize@et
</td><td>
［
`videoWidth$mV ／ `videoHeight$mV
］属性が直前に更新された。
◎
One or both of the videoWidth and videoHeight attributes have just been updated.
</td><td>
［
`~media要素$は `video$e 要素である
］~AND［
`readyState$mM ~NEQ `HAVE_NOTHING$mM
］
◎
Media element is a video element; readyState is not HAVE_NOTHING

</td></tr><tr><td>`volumechange@et
</td><td>
［
`volume$mM ／ `muted$mM
］属性が変化した。
関連する属性の設定子が返った後に発火される。
◎
Either the volume attribute or the muted attribute has changed. Fired after the relevant attribute's setter has returned.
</td><td>

</td></tr></tbody></table>


<p>
次の~eventは、 `source$e 要素に向けて発火される：
◎
The following event fires on source element:
</p>

<table><thead><tr><th>~event名
</th><th>発火-時機
</th></tr></thead>

<tbody><tr><td>`~errorS@et
</td><td>
［
`~media~data$を~fetchしている間に~errorが生じた
］~OR［
資源の型は~supportされない~media形式である
］
◎
An error occurs while fetching the media data or the type of the resource is not supported media format.

</td></tr></tbody></table>

<p>
次の~eventは［
`AudioTrackList$I ／
`VideoTrackList$I ／
`TextTrackList$I
］~objに向けて発火される：
◎
The following events fire on AudioTrackList, VideoTrackList, and TextTrackList objects:
</p>

<table><thead><tr><th>~event名
</th><th>~interface
</th><th>発火-時機
</th></tr></thead>

<tbody><tr><td>`change@et
</td><td>`Event$I
</td><td>
~track~list内の 1 個~以上の~trackが［
可能化-／不能化-
］されたとき。
◎
One or more tracks in the track list have been enabled or disabled.

</td></tr><tr><td>`addtrack@et
</td><td>`TrackEvent$I
</td><td>
~track~listに~trackが追加されたとき。
◎
A track has been added to the track list.

</td></tr><tr><td>`removetrack@et
</td><td>`TrackEvent$I
</td><td>
~track~listから~trackが除去されたとき。
◎
A track has been removed from the track list.

</td></tr></tbody></table>



<p>
次の~eventは［
`TextTrack$I ~obj ／
`track$e 要素
］に向けて発火される：
◎
The following event fires on TextTrack objects and track elements:
</p>

<table><thead><tr><th>~event名
</th><th>発火-時機
</th></tr></thead>

<tbody><tr><td>`cuechange@et
</td><td>
~track内の 1 個~以上の~cueにおいて作動中かどうかが変化したとき。
◎
One or more cues in the track have become active or stopped being active.

</td></tr></tbody></table>

<p>
次の~eventは `track$e 要素に向けて発火される：
◎
The following events fire on track elements:
</p>

<table><thead><tr><th>~event名
</th><th>発火-時機
</th></tr></thead>

<tbody><tr><td>`~errorT@et
</td><td>
~track~dataを~fetchしている間に~errorが生じた
~OR
資源の型は~supportされない~text~track形式である。
◎
An error occurs while fetching the track data or the type of the resource is not supported text track format.

</td></tr><tr><td>`load@et
</td><td>
~track~dataは~fetchされ，成功裡に処理された。
◎
A track data has been fetched and successfully processed.

</td></tr></tbody></table>


<p>
次の~eventは `TextTrackCue$I ~objに向けて発火される：
◎
The following events fire on TextTrackCue objects:
</p>

<table><thead><tr><th>~event名
</th><th>発火-時機
</th></tr></thead>

<tbody><tr><td>`enter@et
</td><td>
~cueは作動中になった。
◎
The cue has become active.

</td></tr><tr><td>`exit@et
</td><td>
~cueは作動中でなくなった。
◎
The cue has stopped being active.

</td></tr></tbody></table>

				</section>
				<section id="security-and-privacy-considerations">
<h4 title="Security and privacy considerations">4.8.12.17. ~securityと~privacy上の考慮点</h4>

<p>
`video$e ／ `audio$e
要素における
主な~securityや~privacy上の含意は、非同一生成元の~mediaを埋込む能に~~由来する。
この脅威は、［
敵対的~内容から被害者~頁へ, および
敵対的~頁から被害者~内容へ
］の 2 つ方向に流れる。
◎
The main security and privacy implications of the video and audio elements come from the ability to embed media cross-origin. There are two directions that threats can flow: from hostile content to a victim page, and from a hostile page to victim content.
</p>

<hr>

<p>
被害者~頁が敵対的~内容を埋込む場合の脅威は、当の内容が~scriptを含んでいて，それを埋込んでいる `Document$I と対話しようと試みることにより生じる。
これを避けるためには、~UAは，その内容が埋込んでいる頁に~accessし得ないことを確保し~MUST。
~media内容~DOM概念を利用している事例では、埋込まれた内容は，自前の無関係な`~top-level閲覧文脈$に属しているかのように扱われ~MUST。
◎
If a victim page embeds hostile content, the threat is that the content might contain scripted code that attempts to interact with the Document that embeds the content. To avoid this, user agents must ensure that there is no access from the content to the embedding page. In the case of media content that uses DOM concepts, the embedded content must be treated as if it was in its own unrelated top-level browsing context.
</p>

<p class="example">
具体例として、
`video$e 要素~内に~SVG~animationが埋込まれた場合、~UAは，外縁~頁の~DOMへの~accessは与えないことになる。
~SVG資源~内の~scriptの視点からは、~SVG~fileは，親のない~top-level閲覧文脈~内にあるかのように現れることになる。
◎
For instance, if an SVG animation was embedded in a video element, the user agent would not give it access to the DOM of the outer page. From the perspective of scripts in the SVG resource, the SVG file would appear to be in a lone top-level browsing context with no parent.
</p>

<hr>

<p>
敵対的~頁が被害者~内容を埋込む場合の脅威は、埋込んでいる頁が，当の内容から さもなければ~accessできない情報を得れるときに生じる。
~APIは一部の情報
— その~mediaの存在, その［
型, 時間長, ~size
］, その~hostの処理能~上の特徴 —
については公開する。
そのような情報も~~問題になり得るが、実施においては，
`img$e 要素を利用しても およそ同じ情報を得れるので、受容可能と判断されている。
◎
If a hostile page embeds victim content, the threat is that the embedding page could obtain information from the content that it would not otherwise have access to. The API does expose some information: the existence of the media, its type, its duration, its size, and the performance characteristics of its host. Such information is already potentially problematic, but in practice the same information can more or less be obtained using the img element, and so it has been deemed acceptable.
</p>

<p>
しかしながら，~UAが内容の中の~metadata
— 字幕や~chapter~titleなど —
を更に公開した場合、より有意に敏感な情報も得れるようになる。
したがって，そのような情報は、動画~資源が~CORSを利用する場合に限り公開される。
作者は、 `crossorigin$aM 属性で~CORSを可能化できる。
`FETCH$r
◎
However, significantly more sensitive information could be obtained if the user agent further exposes metadata within the content such as subtitles or chapter titles. Such information is therefore only exposed if the video resource uses CORS. The crossorigin attribute allows authors to enable CORS. [FETCH]
</p>

<p class="example">
この制約がなければ、攻撃者は、企業内~networkの中で走らせている利用者を，~siteを訪問するよう騙して，企業の~intranet内の 以前に漏洩された所在から動画を読込ませるよう試みることも可能になる。
そのような動画が新製品の機密的な計画を含んでいた場合、字幕を読取れることにより，機密性に深刻な抜け穴を呈することになる。
◎
Without this restriction, an attacker could trick a user running within a corporate network into visiting a site that attempts to load a video from a previously leaked location on the corporation's intranet. If such a video included confidential plans for a new product, then being able to read the subtitles would present a serious confidentiality breach.
</p>

				</section>
				<section id="best-practices-for-authors-using-media-elements">
<h4 title="Best practices for authors using media elements">4.8.12.18. ~media要素を利用する作者~向けの最善の実施</h4>

~INFORMATIVE

<p>
音声や動画の資源を，~set-top-boxや携帯電話などの小さい機器で再生するときは、~hardware資源の制限に拘束されることが多い。
例えば機器は、同時に 3 個の動画までしか~supportしないかもしれない。
この理由から、再生し終えた`~media要素$に保持されている資源を解放するのは，良い実施になる
— 要素への参照-すべてを注意深く除去して~garbage収集されるようにするか，あるいはもっと良いのは、要素の `src$aM 属性, および子孫に `source$e 要素があれば それらも除去した上で，要素の `load()$mM ~methodを呼出すことにより。
◎
Playing audio and video resources on small devices such as set-top boxes or mobile phones is often constrained by limited hardware resources in the device. For example, a device might only support three simultaneous videos. For this reason, it is a good practice to release resources held by media elements when they are done playing, either by being very careful about removing all references to the element and allowing it to be garbage collected, or, even better, by removing the element's src attribute and any source element descendants, and invoking the element's load() method.
</p>

<p>
同様に，再生~rateが正確に 1.0 でない下では、［
~hardware ／ ~software ／ 形式
］の制限により，動画~frameが落とされたり, 音声が震える／消音されることもある。
◎
Similarly, when the playback rate is not exactly 1.0, hardware, software, or format limitations can cause video frames to be dropped and audio to be choppy or muted.
</p>


				</section>
				<section id="best-practices-for-implementors-of-media-elements">
<h4 title="Best practices for implementors of media elements">4.8.12.19. ~media要素の実装者~向けの最善の実施</h4>

~INFORMATIVE

<p>
`~media要素$~APIの様々な側面を正確0にどう実装するかは、実装の品質における課題と見なされる。
◎
How accurately various aspects of the media element API are implemented is considered a quality-of-implementation issue.
</p>

<p>
例えば `buffered$mM 属性を実装するとき、~bufferされた一連の範囲を 実装がどこまで精確に報告するかは、~UAが~dataをどこまで注意深く検分するかに依存する。
~APIは，一連の範囲を一連の時刻として報告するが、~dataは~byte~streamで得られるので、可変~bitrateの~streamを受信している~UAが精確な時刻を決定するためには，すべての~dataを実際に復号するしかないかもしれない。
~UAには，これを行うことは要求されないが、代わりに見積もりを返せる（例えば，それまでの平均~bitrateに基づいて）
— それは、情報がより多く可用になるに伴い，改訂され続ける。
◎
For example, when implementing the buffered attribute, how precise an implementation reports the ranges that have been buffered depends on how carefully the user agent inspects the data. Since the API reports ranges as times, but the data is obtained in byte streams, a user agent receiving a variable-bitrate stream might only be able to determine precise times by actually decoding all of the data. User agents aren't required to do this, however; they can instead return estimates (e.g. based on the average bitrate seen so far) which get revised as more information becomes available.
</p>

<p>
一般~規則として、~UAには楽観的になるより保守的になることが督促される。
例えば、全部~bufferされていないのに，そうであるかのように報告するのは、不良になる。
◎
As a general rule, user agents are urged to be conservative rather than optimistic. For example, it would be bad to report that everything had been buffered when it had not.
</p>

<p>
実装~品質に関する別の課題は、~codecが順方向の再生~用にしか設計されてないときに，動画を逆方向に再生することであろう（例えば、~key-frameはまばらで，~~合間の各~frameは前の~frameからの差分しか持たない）。
~UAは、例えば ~key-frameしか示さないような拙い仕事を行うこともできるが、もっと作り込めば
— 例えば、動画の順方向にある部分を実際に復号して，完全な~frameたちを格納してから、逆方向に再生するなど —
より良い仕事を行う実装になる。
◎
Another quality-of-implementation issue would be playing a video backwards when the codec is designed only for forward playback (e.g. there aren't many key frames, and they are far apart, and the intervening frames only have deltas from the previous frame). User agents could do a poor job, e.g. only showing key frames; however, better implementations would do more work and thus do a better job, e.g. actually decoding parts of the video forwards, storing the complete frames, and then playing the frames backwards.
</p>

<p>
同様に、実装には，いつでも~bufferされた~dataを落とすことも許容されるが（~UAが，得られた~media~dataすべてを~media要素が存続する限り保ち続ける要件はない）、それもまた実装~品質の課題になる。
周りの~dataすべてを保つに足る資源がある~UAには、そうすることが奨励される
— その方が利用者~体験はより良くなるので。
例えば，利用者が~live~streamを視聴している場合、~UAは，~live動画しか見れなくすることもできるが、~UAが全部を~bufferして，［
より早い素材へ~seekする ／
~pauseする ／
順方向や逆方向に再生する
］, 等々を利用できた方が良くなる。
◎
Similarly, while implementations are allowed to drop buffered data at any time (there is no requirement that a user agent keep all the media data obtained for the lifetime of the media element), it is again a quality of implementation issue: user agents with sufficient resources to keep all the data around are encouraged to do so, as this allows for a better user experience. For example, if the user is watching a live stream, a user agent could allow the user only to view the live video; however, a better user agent would buffer everything and allow the user to seek through the earlier material, pause it, play it forwards and backwards, etc.
</p>

<hr>

<p>
~pauseされている`~media要素$が`文書から除去され$，次回に`~event-loop$の`最初の段$に達する前に再~挿入されなかったときは、資源が拘束されている実装には、`~media要素$に利用されているすべての~hardware資源（動画~plane, ~network用の資源, ~data~bufferなど）を解放する機会を~~活用することが奨励される。
（それでも，後で再生を開始し直す事例もあるので、~UAは再生~位置, 等々は保ち続ける必要があるが。）
◎
When a media element that is paused is removed from a document and not reinserted before the next time the event loop reaches step 1, implementations that are resource constrained are encouraged to take that opportunity to release all hardware resources (like video planes, networking resources, and data buffers) used by the media element. (User agents still have to keep track of the playback position and so forth, though, in case playback is later restarted.)
</p>
				</section>
			</section>
</main>
