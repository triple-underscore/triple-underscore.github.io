<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML — media 要素（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>

#_preload-states td:nth-child(2){
	white-space: nowrap;
}

@supports (display: grid) and (display: contents) {

#dom-TrackList-getKind-categories {
	min-width: 30em;
	max-width: 70em;
}

#dom-TrackList-getKind-categories tr {
	grid-template-areas:
		"分類 定義 適"
		"分類 例 例"
	;
	grid-template-columns: 10em 1fr 9em;
}

#dom-TrackList-getKind-categories tr > *:nth-child(1) {
	grid-area: 分類;
	border-left-width: 0;
}

#dom-TrackList-getKind-categories tr > *:nth-child(2) {
	grid-area: 定義;
}

#dom-TrackList-getKind-categories tr > *:nth-child(3) {
	grid-area: 適;
}

#dom-TrackList-getKind-categories tr > *:nth-child(4) {
	grid-area: 例;
}

}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm': // IDL member
case 'mM':
case 'mA':
case 'mV':
case 'mS':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'tag': //
	text = `&lt;${text}&gt;`;
	break;
case 'sc': // url scheme
	text = text.replace(/_/, ':');
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'AA':
	return `<a href="~HTMLARIA#el-${key}">作者~向け</a>／<a href="~HTMLAAM#el-${key}">実装者~向け</a>`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">

●●options

spec_date:2021-11-04
trans_update:2021-08-05
source_checked:200402
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/media.html
	abbr_url:HEmedia
nav_prev:HEembed
nav_next:HEtrack
trans_1st_pub:2017-04-02


●●class_map
e:element
E:error
a:attr
aM:attr
aV:attr
aS:attr
et:event-type
sc:scheme
st:attr-state
v:value
vT:value
jv:js-value
h:header
U:code-point

●●tag_map
I:code
m:code
mM:code
mA:code
mV:code
mE:code
E:code
c:code
e:code
a:code
aM:code
aV:code
aT:code
aS:code
et:code
mt:code
tag:code
st:span
sc:code
h:code
sub:sub
U:span
v:code
vT:code
jv:code
i:i
em:em
cite:cite

●●words_table

	●仕様（動詞
助ける:helpする:~
促す:encourageする:~
採用-:adopt:~
	必要:have to
	~~働く:serve
	~~損なう:interfere

	●仕様
見当:idea:~
表向きは:ostensibleには:~
一様:uniform:~
診断用の:diagnosticな:~
逸脱:deviation:~
否定的:negative:~
架空の:fictionalな:~
積極的:aggressive:~
念頭:mind:~
妥協点:compromise:~
適度:reasonable:~
保守的:conservative:~
楽観的:optimistic:~
些細:negligible:~
柔軟:liberal:~
稀な:rare:~
選択的:selective:~
原則的:principle:~
適格:eligible:~
安定:stable:~
複雑な:complicatedな:~

	~~直に:straight
	あり得る／最〜／いずれか:possible
	あり得る:potentially
	~~指示
	~~実際:indeed
	~~抑制:allow 〜 to affect
	当然ながら:naturally
	見込まれる:will likely
	伝える:inform する
	不必要に:unnecessarily
	~~最優先に put 〜 first
	~~安定的な:consistent

	●仕様（他
	~~緊密に:closely
	確度:confidence／:how confident
	十分な確度:confident of／:can be confidently established
	~~相応に:very
	例外的に:exception could be made
	用語を通して／を通して:in terms of

	何の利得もない:nothing would be gained
	効き始める:kick-in
	~~実際に:really
	関わる／そのこと:matter
	にもかかわらず，:nonetheless
	だいたいは:presumably
	いつでも:ever
	定か:sure
	得る:potentially
	であっても:to the contrary
	方法
	されるべき:ought
	regardless
	原因:why

	極端な場合:in the extreme
	兼ね合い:balance
	~~適切と~~考えて:thinks is advisable
	今更〜そうなっている:enshrine
	高くつく:costly

	●network／navi
Content-Type:
	^h:Range
DNS:
close:
sliding-window:sliding window::sliding 窓

load:
読込中:loading::読み込み中::ロード中
切断-:disconnect::~
再接続-:reconnect::~
接続性:connectivity::~
放送:broadcast:~
放送局:broadcaster:~
運んで:carryして:~


	~URL資格証~利用:use-URL-credential

減速-:throttle::~
帯域幅:bandwidth::~
負荷:load::~

	●構文
省略不可:omissibleでない:~
省略:omission:~
	error含み:erroneous
	前後~空白~

	●内容
	frame刻みの:frame-by-frame
分類:categories:~
透過的:transparent::~
句ng:phrasing::句::フレージング
可触:palpable::~
空内容:blank:~
代表:representative:~

	●呈示
横:horizontal:~
縦:vertical:~
解像度:resolution::~
積層する:overlayする::重ねる
積層され:overlayされ::重ねられ
塗る:paintする:~
塗り:paint:~
描かれ:drawされ:~
合成-:synthesize::~
収まる:fitする:~
中央:center:~
開閉可能な:closed:~
縦横比:aspect ratio::~
	縦横比:the ratio

黒:black:~
	〜-可能:〜able
	〜-済み:〜ed

	●UI／対話
controller::::コントローラ
	^en:scrubber
bar::::バー
remote-control:remote control:::リモコン
	全~screen:fullscreen
reader::::リーダ
screensaver::::スクリーンセーバ
utility::::ユーティリティ

選択-:select::~
選択:selection::~
未選択に:unselect:~

障害:disabilities:~
認知的:cognitive:~
	聴覚
	において，部分的または全部的に, 物理的または認知的な障害:the partially sighted, the blind, the hard-of-hearing, the deaf, and those with other physical or cognitive disabilities ／the deaf or to those with other physical or cognitive disabilities
	partially sighted
	視覚:visual

視聴-:watch:~
視聴v:viewing:視聴
一過:transient::~
審美的:aesthetic:~
滑らか:smooth:~
知覚-:perceive:~
	途切れる:gap

	●media
	GIF
	JPEG
	MJPEG
	JPEG-push
	TV
Ogg:
MP4:
profile::::プロファイル
live-event:live event:::ライブイベント
clip::::クリップ
radio::::ラジオ
poster::::ポスター
bitrate::::ビットレート
codec::::コーデック
rate::::レート
MediaError:
WebVTT:
streaming::::ストリーミング
track::::トラック
tT:text track:::テキストトラック
chapter::::チャプター
cue::::キュー
showing:
	なし:none
	動画が占めない部位: letterboxed or pillarboxed
音声転写:transcript::~
音述:audio description::~
音響:sound::~
最大音:loudest::~
聴感音量:loudness::~
無音:silent::~
	無音:quietest
音量:volume::~
音高:pitch::~
消音-:mute::~::ミュート
	消音されなく:unmute
	低過ぎるか高過ぎる:so low or so high
発話:speech::~::スピーチ
混合-:mix::~
字幕:subtitle::~
手話:sign language:~
翻訳-:translate::~
実効:effective:~
映画:movie::~
提供元:provider::~
帯域内:in-band::~

	●範囲／timeline／再生／seek
Date:
	UTC
	時機:timing／when
時間長:duration::~
sample::::サンプル
断片:fragment::~
終止-:end::~
重合して:overlapして::重なり合って
重合しな:overlapしな::重なり合わな

	起点に:anchored at

日時:date＆time::~
time-march-on:time march-on
時間同期的な:timed::時間に同期的な
	~~時間:hours
時計:clock::~
瞬間:moment:~
増加-:increase:~
減少-:decrease:~
失効-:expire::~
	早い:earlyな:早い
	最も早い:earliest:
近似-:approximate:~
近似:approximation:~
過去:past:~
無限界:unbounded::~
有限界:bounded::~
触れて:touchして:~
wall:
区分:segment:~

進めた:advanceした:~
進める:advanceする:~
進めれ:advanceでき:~

seek:
seeking:::seek 処理
	seek法:seeking
停滞-:stall::~
再生-:play::~
再生:playback::~
	再生-中
再生待ち:pending play::~
逆方向:backwards::~
順方向:forwards::~
逆行-:reverse::~
早戻し:fast-rewind::~
早送り:fast-forward::~
自動再生:autoplay::~
静止-:pause::~
	静止されなく:unpause
再開p:unpause::再開
単調:monotonic::~
地点:point:~
見積もり:estimate:~
見積もっ:estimateし:~
速度優先:approximate-for-speed:~
速度:speed:~
低速:slow:~
高速:fast:~
motion::::モーション

不連続:discontinuous:~
	不連続に:discontinuous fashion
	~~不連続に:non-linear fashion

	~~集約:fold
	10 月の金曜日の昼過ぎ:sunny Friday afternoon in October
	真中:in the middle
	音高を保全するよう調整-:pitch-preserving algorithms are used／in effect
	速めたり遅める:speed up or slow down

	●処理
looping::::ループ処理
buffering:::buffer 処理:バッファ処理
	buffer中:buffering
detach:
制限時間:timeout::~

~timeout:
sniff:

活動:activity::~
遭遇-:encounter:~
復帰-:revert:~
	~~飛:without passing through／:jump
待受ける:awaitする::待ち受ける
同期区間:synchronous section::~
事前条件:preconditions::~
致命的:fatal::~
能動的:active::~
準備状態:ready state::~
処理待ち:pending:~
	〜待ちの:in-flight
忘れる:forgetする:~
候補:candidate:~
永続的:permanent::~
尽きた:exhaustした:~
	尽きる:overtake
	~~判明した:found by inspection to be
切替える:switchする:切り替える
切替えた:switchした:切り替えた
切替えて:switchして:切り替えて
切替わっ:switchされ:切り替わっ
	ありに切り替え:turn on
満杯:full::~


	●データ型／構造／操作
順不同:out-of-order:~
連結-:concatenate:~
	〜し直-:re〜
blob:

	●§tracklist
role:
angle:
WebM:
DASH:
	Role header field
	Ogg
	MPEG-2
	AC3
	BCP 47
歌:song:~
take:
外国語吹替え:foreign-language dubbed dialogues:外国語吹き替え
director:
実況:commentary:~
	識別子:ID 
自由形:free-form:~
焼付けら:burn inさ:焼き付けら

	●§保安
非安全:unsafe::~
intranet::::イントラネット
企業:corporation:~
企業内:corporate:~
新製品:new product:~
機密性:confidentiality:~
機密的:confidential:~
流れる:flowする:~
深刻:serious:~
脅威:threat:~
被害者:victim:~
視点:perspective:~
計画:plan:~
騙して:trickして:~
	~~問題になり得る:potentially problematic
	~~由来する:come from
	抜け穴を~~呈する:present 〜 breach


	●§最善な実施
key-frame:key-frame:::キーフレーム
plane:
set-top-box:set-top box:::セットトップボックス
携帯:mobile::~::モバイル
電話:phone::~
	小さい:small
解放-:release::~

	-:very
	震え:choppy
仕事:job:~
可変:variable:~
品質:quality:~
平均:average:~
拙い:poorな:~
機会:opportunity:~
	~~機会:chance
素材:material:~
	作り込めば:work
	良く
	見れ:view
	足る:sufficient:
	~~活用:take

	●未分類（動詞
落さず:dropせず:落とさず
確定的:definite:~
留めら:anchorさ:~
増大-:increase:~
覚えて:rememberして:~
破損-:corrupt:~

	留めて:snap 
	正規化-済み:normalized
	費や:spend
	遂げる:go through
	増やす:increase
	変えないまま:leaving the other unchanged
	見れる:view
	選ぶ:choose
	として:form
	絶え間なく~~更新され続ける:continuously increasing 
	~~復元
	選び取る:pick

	●未分類
factory::::ファクトリ
tainted:
surround::::サラウンド
stereo::::ステレオ
公告-:announce:~

数-:numeric::~
白紙状態:scratch:~
広告:advertisement:~
線形:linear:~
種類:kind:~
小数:fraction:~
中間の:intermediate:~
一時的:temporal:~
近過去の:recentな:~

	箇所:spot／
	巨大:large
	速やかに:promptly
	面白いもの:surprising
	最終的:eventual
	利用量:usage
	px:
	表:table
	-:cell
	行:row
	なし:missing
	potentially
	^en:anamorphic
	^en:clean aperture
	数:number
	方法:how to
	量:how much
	単位
	可能
	落とさ
	在して
	狭い:scarce
	直前に:has just
	でなくなった／再生され始めた／もはや:no longer
	一環／一部:part of
	最も大きい:largest
	より短くshorter
	~~判明:learn
	一式:set

	同時:simultaneous
	直近:latest
	~instant
	空に／ ~NULL に:clear
	近くに:a nearby
	重ねて:over
	実:real
	~~関係
	則って
	代えて:over

	●指示語
最大:maximam:~
	現時点:at the time the attribute is evaluated
	現時点:at the time of getting
	最~大:largest possible
	最~大:greatest
	前の:previous
	同じく:As with
	更には、furthermore
	様々な:variety of
	〜周りの near
	most
	旧:older
	respective
	もまた:again
	毎回:each time
	中途
	部位
	列目
	同様
	個以上
	次第
	時点
	場合
	上述
	自体
	一方
	他方
	同順
	上限
	一例
	自身
	個数
	各種
	結果
	対応

	●訳注
	符号化処理
	都合
	ゴミ
	円柱
	レンズ
	縦横
	圧縮-
	撮影-

●●words_table1

WEBVTT:https://w3c.github.io/webvtt/

errorM:error
errorS:error
codecs:<code class="production">codecs</code>

●●original_urls
the-source-element:https://html.spec.whatwg.org/multipage/embedded-content.html

●●original_id_map
	the-video-element:video
	the-audio-element:audio

●●mdn_urls
the-audio-element:HTML/Element/audio
the-video-element:HTML/Element/video
the-source-element:HTML/Element/source

audiotrack:API/AudioTrack
audiotracklist:API/AudioTrackList
	canplaytyperesult:API/CanPlayTypeResult
htmlaudioelement:API/HTMLAudioElement
htmlmediaelement:API/HTMLMediaElement
htmlvideoelement:API/HTMLVideoElement
mediaerror:API/MediaError
	mediaprovider:API/MediaProvider
timeranges:API/TimeRanges
trackevent:API/TrackEvent
	trackeventinit:API/TrackEventInit
videotrack:API/VideoTrack
videotracklist:API/VideoTrackList

	event-source-error:API/HTMLSourceElement/error
event-media-error:Events/error
event-error:Events/error
event-media-abort:API/HTMLMediaElement/abort_event
event-media-addtrack:API/VideoTrackList/addtrack_event
	event-media-addtrack:API/AudioTrackList/addtrack_event
	event-media-addtrack:API/TextTrackList/addtrack_event
event-media-canplay:API/HTMLMediaElement/canplay_event
event-media-canplaythrough:API/HTMLMediaElement/canplaythrough_event
event-media-change:API/VideoTrackList/change_event
event-media-durationchange:API/HTMLMediaElement/durationchange_event
event-media-emptied:API/HTMLMediaElement/emptied_event
event-media-ended:API/HTMLMediaElement/ended_event
event-media-loadeddata:API/HTMLMediaElement/loadeddata_event
event-media-loadedmetadata:API/HTMLMediaElement/loadedmetadata_event
event-media-loadstart:API/HTMLMediaElement/loadstart_event
event-media-pause:API/HTMLMediaElement/pause_event
event-media-play:API/HTMLMediaElement/play_event
event-media-playing:API/HTMLMediaElement/playing_event
event-media-progress:API/HTMLMediaElement/progress_event
event-media-ratechange:API/HTMLMediaElement/ratechange_event
event-media-removetrack:API/VideoTrackList/removetrack_event
	event-media-addtrack:API/AudioTrackList/removetrack_event
	event-media-addtrack:API/TextTrackList/removetrack_event
	event-media-resize:API/？/resize_event
event-media-seeked:API/HTMLMediaElement/seeked_event
event-media-seeking:API/HTMLMediaElement/seeking_event
event-media-stalled:API/HTMLMediaElement/stalled_event
event-media-suspend:API/HTMLMediaElement/suspend_event
event-media-timeupdate:API/HTMLMediaElement/timeupdate_event
event-media-volumechange:API/HTMLMediaElement/volumechange_event
event-media-waiting:API/HTMLMediaElement/waiting_event

●●link_map

	●IDL
LegacyFactoryFunction:~WEBIDLjs#LegacyFactoryFunction
CEReactions:~HEcustom#cereactions
HTMLConstructor:~HTMLdom#htmlconstructor

object:~WEBIDL#idl-object

E.AbortError:~WEBIDL#aborterror
E.IndexSizeError:~WEBIDL#indexsizeerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotAllowedError:~WEBIDL#notallowederror
E.NotFoundError:~WEBIDL#notfounderror
E.NotSupportedError:~WEBIDL#notsupportederror

I.Document:~HTMLdom#document
I.HTMLVideoElement:#htmlvideoelement
I.HTMLAudioElement:#htmlaudioelement
I.HTMLMediaElement:#htmlmediaelement
I.HTMLElement:~HTMLdom#htmlelement

I.CanPlayTypeResult:#canplaytyperesult
I.Blob:~FILEAPI#blob
	I.DOMException:~WEBIDL#idl-DOMException
I.Date:~TC39#sec-date-objects
I.Event:~DOM4#interface-event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#interface-eventtarget
I.TrackEvent:#trackevent
I.TrackEventInit:#trackeventinit
I.File:~FILEAPI#file
I.MediaError:#mediaerror
I.MediaProvider:#mediaprovider
I.MediaSource:https://w3c.github.io/media-source/#idl-def-mediasource
I.MediaStream:https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-mediastream

I.AudioTrackList:#audiotracklist
I.AudioTrack:#audiotrack
I.VideoTrackList:#videotracklist
I.VideoTrack:#videotrack

I.TextTrack:~HEtrack#texttrack
I.TextTrackList:~HEtrack#texttracklist
I.TextTrackKind:~HEtrack#texttrackkind

I.TimeRanges:#timeranges

mE.MEDIA_ERR_ABORTED:#dom-mediaerror-media_err_aborted
mE.MEDIA_ERR_DECODE:#dom-mediaerror-media_err_decode
mE.MEDIA_ERR_NETWORK:#dom-mediaerror-media_err_network
mE.MEDIA_ERR_SRC_NOT_SUPPORTED:#dom-mediaerror-media_err_src_not_supported
mE.code:#dom-mediaerror-code
mE.message:#dom-mediaerror-message

cP.空~文字列:#dom-canplaytyperesult-nil
l.maybe:#dom-canplaytyperesult-maybe
l.probably:#dom-canplaytyperesult-probably

m.src:#dom-source-src
m.Audio:#dom-audio
m.track:#dom-trackevent-track
m.createElement:~DOM4#dom-document-createelement
m.width:~HEembed#dom-dim-width
m.height:~HEembed#dom-dim-height

m.length:#dom-timeranges-length
m.end:#dom-timeranges-end
m.start:#dom-timeranges-start

m.onchange:#handler-tracklist-onchange
m.onaddtrack:#handler-tracklist-onaddtrack
m.onremovetrack:#handler-tracklist-onremovetrack
m.getter:#dom-tracklist-item

mM.HAVE_CURRENT_DATA:#dom-media-have_current_data
mM.HAVE_ENOUGH_DATA:#dom-media-have_enough_data
mM.HAVE_FUTURE_DATA:#dom-media-have_future_data
mM.HAVE_METADATA:#dom-media-have_metadata
mM.HAVE_NOTHING:#dom-media-have_nothing

mM.NETWORK_EMPTY:#dom-media-network_empty
mM.NETWORK_IDLE:#dom-media-network_idle
mM.NETWORK_LOADING:#dom-media-network_loading
mM.NETWORK_NO_SOURCE:#dom-media-network_no_source

mM.canPlayType:#dom-navigator-canplaytype
mM.addTextTrack:~HEtrack#dom-media-addtexttrack
mM.audioTracks:#dom-media-audiotracks
mM.autoplay:#dom-media-autoplay
mM.buffered:#dom-media-buffered
mM.controls:#dom-media-controls
mM.crossOrigin:#dom-media-crossorigin
mM.currentSrc:#dom-media-currentsrc
mM.currentTime:#dom-media-currenttime
mM.defaultMuted:#dom-media-defaultmuted
mM.defaultPlaybackRate:#dom-media-defaultplaybackrate
mM.duration:#dom-media-duration
mM.ended:#dom-media-ended
mM.error:#dom-media-error
mM.fastSeek:#dom-media-fastseek
mM.getStartDate:#dom-media-getstartdate
mM.load:#dom-media-load
mM.loop:#dom-media-loop
mM.muted:#dom-media-muted
mM.networkState:#dom-media-networkstate
mM.pause:#dom-media-pause
mM.paused:#dom-media-paused
mM.play:#dom-media-play
mM.playbackRate:#dom-media-playbackrate
mM.played:#dom-media-played
mM.preload:#dom-media-preload
mM.preservesPitch:#dom-media-preservespitch
mM.readyState:#dom-media-readystate
mM.seekable:#dom-media-seekable
mM.seeking:#dom-media-seeking
mM.src:#dom-media-src
mM.srcObject:#dom-media-srcobject
mM.textTracks:~HEtrack#dom-media-texttracks
mM.videoTracks:#dom-media-videotracks
mM.volume:#dom-media-volume

mV.playsInline:#dom-video-playsinline
mV.poster:#dom-video-poster
mV.videoHeight:#dom-video-videoheight
mV.videoWidth:#dom-video-videowidth

mV.getTrackById:#dom-videotracklist-gettrackbyid
mV.length:#dom-videotracklist-length
mV.selectedIndex:#dom-videotracklist-selectedindex

mV.id:#dom-videotrack-id
mV.kind:#dom-videotrack-kind
mV.label:#dom-videotrack-label
mV.language:#dom-videotrack-language
mV.selected:#dom-videotrack-selected

mA.getTrackById:#dom-audiotracklist-gettrackbyid
mA.length:#dom-audiotracklist-length

mA.enabled:#dom-audiotrack-enabled
mA.id:#dom-audiotrack-id
mA.kind:#dom-audiotrack-kind
mA.label:#dom-audiotrack-label
mA.language:#dom-audiotrack-language

et.error:~HTMLindex#event-error
et.~errorM:#event-media-error
et.~errorS:#event-source-error
et.abort:#event-media-abort
et.addtrack:#event-media-addtrack
et.canplay:#event-media-canplay
et.canplaythrough:#event-media-canplaythrough
et.change:#event-media-change
et.durationchange:#event-media-durationchange
et.emptied:#event-media-emptied
et.ended:#event-media-ended
et.loadeddata:#event-media-loadeddata
et.loadedmetadata:#event-media-loadedmetadata
et.loadstart:#event-media-loadstart
et.mousedown:~UIEVENTS#event-type-mousedown
et.pause:#event-media-pause
et.play:#event-media-play
et.playing:#event-media-playing
et.progress:#event-media-progress
et.ratechange:#event-media-ratechange
et.removetrack:#event-media-removetrack
et.resize:#event-media-resize
et.seeked:#event-media-seeked
et.seeking:#event-media-seeking
et.stalled:#event-media-stalled
et.suspend:#event-media-suspend
et.timeupdate:#event-media-timeupdate
et.volumechange:#event-media-volumechange
et.waiting:#event-media-waiting


	●要素
e.audio:#the-audio-element
e.canvas:~HEcanvas#the-canvas-element
e.img:~HEimages#the-img-element
e.source:#the-source-element
	e.source:~HEimages#the-source-element
e.track:~HEtrack#the-track-element
e.video:#the-video-element

a.id:~HTMLdom#the-id-attribute
a.itemprop:~HTMLLS/microdata.html#names:-the-itemprop-attribute

a.height:~HEembed#attr-dim-height
a.width:~HEembed#attr-dim-width

aS.src:#attr-source-src
aS.srcset:~HEimages#attr-source-srcset
aS.media:~HEimages#attr-source-media
aS.sizes:~HEimages#attr-source-sizes
aS.type:~HEimages#attr-source-type

aV.playsinline:#attr-video-playsinline
aV.poster:#attr-video-poster

aM.src:#attr-media-src
aM.crossorigin:#attr-media-crossorigin
aM.autoplay:#attr-media-autoplay
aM.controls:#attr-media-controls
aM.loop:#attr-media-loop
aM.muted:#attr-media-muted
aM.preload:#attr-media-preload


v.none:#attr-media-preload-none
v.auto:#attr-media-preload-auto
v.metadata:#attr-media-preload-metadata

st.なし:#attr-media-preload-none-state
st.自動的:#attr-media-preload-auto-state
st.~metadata:#attr-media-preload-metadata-state

vT.alternative:#value-track-kind-alternate
vT.captions:#value-track-kind-caption
vT.commentary:#value-track-kind-commentary
vT.descriptions:#value-track-kind-descriptions
vT.main:#value-track-kind-main
vT.main-desc:#value-track-kind-main-desc
vT.sign:#value-track-kind-sign
vT.subtitles:#value-track-kind-subtitle
vT.translation:#value-track-kind-translation
vT0.空~文字列:#value-track-kind-none

st.Descriptions:~HEtrack#attr-track-kind-descriptions

mt.multipart/x-mixed-replace:iana.html#multipart/x-mixed-replace
mt.application/octet-stream:~RFCx/rfc2046#section-4.5.1

sc.about_html-kind:~HTMLurl#about:html-kind

l.autoplay:~HTMLINFRA#autoplay-feature

	●用語
~poster~frame:#poster-frame
vD.内在的~縦幅:#concept-video-intrinsic-height
vD.内在的~横幅:#concept-video-intrinsic-width

	:#video
	:#audio
	:#dimUpdate

	●~media要素
~media要素:#media-element
~media要素~属性:#media-element-attributes
すべての~media要素に共通な属性:#media-element-attributes
~media~data:#media-data
~media資源:#media-resource
資源:#media-resource
~media要素~event~task源:#media-element-event-task-source
内部~再生-手続き:#internal-play-steps
~media~taskを~queueする:#queue-a-media-element-task

	•error
~message:#concept-mediaerror-message
~code:#concept-mediaerror-code
新たな~MediaError:#creating-a-mediaerror
	~MediaErrorを作成-:#creating-a-mediaerror

	•所在
~media提供元~obj:#media-provider-object
アテガわれている~media提供元~obj:#assigned-media-provider-object

	:#concept-media-load-algorithm-at-creation

	•MIME
~UAが具現化できないと知る型:#a-type-that-the-user-agent-knows-it-cannot-render

	•読込み
中止-:#_abort-media-load-algorithm
自動再生~可能か:#can-autoplay-flag
~load~event遅延-中か:#delaying-the-load-event-flag
~media要素~読込n~algo:#media-element-load-algorithm
資源~選定~algo:#concept-media-load-algorithm
専用の~media~source失敗~手続き:#dedicated-media-source-failure-steps
~media資源~fetch~algo:#concept-media-load-resource
~media要素の停滞-制限時間:#stall-timeout
~media~data処理~手続き~list:#media-data-processing-steps-list
~media資源に特有な~trackを忘れる:#forget-the-media-element's-media-resource-specific-tracks
	'
	:#non-fatal-media-error
	:#resourceSuspend
	:#found-another-audio-track
	:#found-another-video-track
	:#getting-media-metadata
	:#fatal-decode-error
	:#non-fatal-media-error
	:#found-a-media-resource-specific-timed-track

	•offset
~media時列線:#media-timeline
~media時列線を確立-:#defineTimeline
現在の再生~位置:#current-playback-position
既定の再生~開始~位置:#default-playback-start-position
公式的な再生~位置:#official-playback-position
アリな最も早い位置:#earliest-possible-position
~posterを示すか:#show-poster-flag
~posterを示して:#show-poster-flag
時列線~offset:#timeline-offset

	:#durationChange

	•準備状態
	:#fire-loadedmetadata
	:#handling-first-frame-available
	:#fire-loadeddata
	:#fire-waiting-when-waiting

	•再生
阻まれて:#blocked-media-element
再生-中であり得る:#potentially-playing
自動再生に適格:#eligible-for-autoplay
再生は許容されて:#allowed-to-play
再生は終止して:#ended-playback
~errorに因り停止され:#stopped-due-to-errors
帯域内~内容~用に静止され:#paused-for-in-band-content
利用者~対話~用に静止され:#paused-for-user-interaction
再生待ち~promise~list:#list-of-pending-play-promises
再生待ち~promiseたちを取り出す:#take-pending-play-promises
再生待ち~promiseたちを却下する:#reject-pending-play-promises
再生待ち~promiseたちを解決する:#resolve-pending-play-promises
再生-中について通知する:#notify-about-playing
内部~静止-手続き:#internal-pause-steps
再生~方向:#direction-of-playback

	~media資源の終端に達した:#reaches-the-end

	:#reaches-the-end
	:#rateUpdate
	:#media-playback

	•seek
~seekする:#dom-media-seek
~seeking:#dom-media-seek

	:#seekUpdate

	•UI
消音-:#concept-media-muted
~UIを公開する:#expose-a-user-interface-to-the-user
再生~音量:#concept-media-volume
実効~media音量:#effective-media-volume

正規化-済み:#normalised-timeranges-object
	正規化-済み TimeRanges ~obj

	•track
選択されている動画~track:#dom-videotrack-selected
可能化されている音声~track:#dom-audiotrack-enabled

	●text track
HTMLLS

~tT~list:~HEtrack#list-of-text-tracks
~tT:~HEtrack#text-track
~media資源に特有な~tT:~HEtrack#media-resource-specific-text-track

tT.種類:~HEtrack#text-track-kind
tT.~mode:~HEtrack#text-track-mode
tT.~cue~list:~HEtrack#text-track-list-of-cues
~cue:~HEtrack#text-track-cue

i.準備済み:~HEtrack#the-text-tracks-are-ready
i.~showing:~HEtrack#text-track-showing

tC.作動中か:~HEtrack#text-track-cue-active-flag
tC.終了~時刻:~HEtrack#text-track-cue-end-time
tC.開始~時刻:~HEtrack#text-track-cue-start-time

処理待ち~tT~list:~HEtrack#list-of-pending-text-tracks
処理待ち~tT~listを拡充する:~HEtrack#populate-the-list-of-pending-text-tracks

構文解析器にて阻まれているか:~HEtrack#blocked-on-parser
~media資源に特有な~tTを公開する手続き:~HEtrack#steps-to-expose-a-media-resource-specific-text-track

~tTを時間に合わせる:~HEtrack#time-marches-on

	●HTML

寸法~属性:~HEembed#dimension-attributes
利用は許容されて:~HEembed#allowed-to-use

node.挿入された:~HTMLINFRA#nodes-are-inserted
文書から除去され:~HTMLINFRA#remove-an-element-from-a-document
即時:~HTMLINFRA#immediately
並列的:~HTMLINFRA#in-parallel
新たな~Date~obj:~HTMLINFRA#create-a-date-object
~live:~HTMLINFRA#live

既知な値のみに制限され:~HTMLcdom#limited-to-only-known-values
反映する:~HTMLcdom#reflect

~CORS設定群~属性:~HTMLurl#cors-settings-attribute
~CORSになり得る要請を作成する:~HTMLurl#create-a-potential-cors-request
~CORS同一-生成元:~HTMLurl#cors-same-origin
~CORS非同一-生成元:~HTMLurl#cors-cross-origin
非安全~応答:~HTMLurl#unsafe-response
~Content-Type~metadata:~HTMLurl#content-type
相対的に~URL構文解析する:~HTMLurl#parse-a-url
前後~空白~可の妥当かつ空でない~URL:~HTMLurl#valid-non-empty-url-potentially-surrounded-by-spaces

真偽-属性:~HTMLcms#boolean-attribute
列挙d属性:~HTMLcms#enumerated-attribute
妥当でない値~用の既定:~HTMLcms#invalid-value-default
値なし用の既定:~HTMLcms#missing-value-default

分類:~HTMLdom#concept-element-categories
内容~属性:~HTMLdom#concept-element-attributes
内容~model:~HTMLdom#concept-element-content-model
この要素を利用できる文脈:~HTMLdom#concept-element-contexts
~accessibilityの考慮点:~HTMLdom#concept-element-accessibility-considerations
~DOM~interface:~HTMLdom#concept-element-dom
埋込d内容:~HTMLdom#embedded-content-category
~flow内容:~HTMLdom#flow-content-2
大域~属性:~HTMLdom#global-attributes
対話的~内容:~HTMLdom#interactive-content-2
可触~内容:~HTMLdom#palpable-content-2
句ng内容:~HTMLdom#phrasing-content-2
text/html における~tag省略:~HTMLdom#concept-element-tag-omission
表現-:~HTMLdom#represents
透過的な内容:~HTMLdom#transparent

全部的に作動中:~BROWSERS#fully-active
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context

結付けられている文書:~WINDOW#concept-document-window

作動中の~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
閲覧文脈~sandbox化( 自動的な特能 )~flag:~ORIGIN#sandboxed-automatic-features-browsing-context-flag

表示域に交差-:~HTMLrendering#intersect-the-viewport

現在の大域~obj:~WAPI#current-global-object
関連な設定群~obj:~WAPI#relevant-settings-object
~event~loop:~WAPI#event-loop
最初の段:~WAPI#step1
~task:~WAPI#concept-task
~task源:~WAPI#task-source
~network用~task源:~WAPI#networking-task-source
~task~queue:~WAPI#task-queue
~queueされ:~WAPI#queue-a-task
要素~taskを~queueする:~WAPI#queue-an-element-task
同期区間:~WAPI#synchronous-section
安定~状態を待受ける:~WAPI#await-a-stable-state
~scriptingは不能化され:~WAPI#concept-n-noscript
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler:~WAPI#event-handlers

一過な作動化？:~HTMLinteraction#transient-activation

~load~eventを遅延-:~HTMLparsing#delay-the-load-event

	●他
実装定義:~INFRA#implementation-defined
~HTML名前空間:~INFRA#html-namespace

有index~propの値を決定-:~WEBIDL#dfn-determine-the-value-of-an-indexed-property
~supportする~prop~index:~WEBIDL#dfn-supported-property-indices

~fetch:~FETCH#concept-fetch
要請:~FETCH#concept-request
rq.~client:~FETCH#concept-request-client
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.行先:~FETCH#concept-request-destination
rq.~URL:~FETCH#concept-request-url
rq.~URL資格証を利用するか:~FETCH#concept-request-use-url-credentials-flag

文書~内:~DOM4#in-a-document
属性~値を設定する:~DOM4#concept-element-attributes-set-value
要素を作成する:~DOM4#concept-create-element
~eventを発火する:~DOM4#concept-event-fire
発火-:~DOM4#concept-event-fire
~node文書:~DOM4#concept-node-document
最初の子？:~DOM4#concept-tree-first-child
	~tree順序:~DOM4#concept-tree-order
次の同胞？:~DOM4#concept-tree-next-sibling
前の同胞？:~DOM4#concept-tree-previous-sibling

~URL:~URL1#concept-url
~URLを直列化する:~URL1#concept-url-serializer
url.~blob~URL~entry:~URL1#concept-url-blob-entry
url.素片:~URL1#concept-url-fragment

~WebVTT~file:~WEBVTT#webvtt-file

~detach:https://w3c.github.io/media-source/#mediasource-detach

~CSS~pixel:~CSSVAL#px
既定の~obj~size:~CSSIMAGE#default-object-size
内在的~寸法:~CSSIMAGE#natural-dimensions
内在的~横幅:~CSSIMAGE#natural-width
内在的~縦幅:~CSSIMAGE#natural-height
塗り~source:~CSSIMAGE4#paint-source
透明な黒:~CSSCOLOR#transparent-black

	●
~MIME型:~MIMESNIFF#mime-type
音声や動画を特定的に~sniffするための規則:~MIMESNIFF#rules-for-sniffing-audio-and-video-specifically
	妥当な~MIME型:~MIMESNIFF#valid-mime-type
~media素片の構文:https://www.w3.org/TR/media-frags/#media-fragment-syntax


●●html_code_list


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ The video element, § The audio element, § Media elements</a>,
および
<a href="~HTMLLS/embedded-content.html#the-source-element">§ The source element</a>
の一部を日本語に翻訳したものです。
~PUB
</p>

</script>


</head>
<body>

<header id="head">
	<hgroup>
<h1>メディア要素（ video, audio ）</h1>
	</hgroup>

</header>

<main id="MAIN" hidden>

			<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

<p>
この訳の，~algoの記述に利用されている各種記号（ε, コレ, ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

			</section>
			<section id="the-source-element">
<h4 title="The source element">4.8.2. `source^e 要素</h4>

<p class="trans-note">【
この節では、原文のこの節における`~media要素$のみに関わる部分を述べる。
他の内容の和訳は、<a href="~HEimages#the-source-element">別ページ</a>にて。
】</p>

<p>
`source$e 要素 %source の親が`~media要素$である場合、以下に述べる要件も課される：
◎
The remainder of the requirements depend on whether the parent is a picture element or a media element:
◎
• The source element's parent is a media element
</p>

<ul>
	<li>
<p>
%source の
`src@aS
属性は、`~media資源$の`~URL$を与える。
指定する値は、`前後~空白~可の妥当かつ空でない~URL$でなければナラナイ。
%source はこの属性を有していなければナラナイ。
◎
The src attribute gives the URL of the media resource. The value must be a valid non-empty URL potentially surrounded by spaces. This attribute must be present.
</p>

<p class="note">注記：
%source が
`video$e ／ `audio$e
要素~内にすでに挿入されている場合、
%source とその属性を動的に改変しても，効果はない。
何を再生しているかを変更するためには、`~media要素$上の `src$aM 属性だけを直に利用するか，場合によっては `canPlayType()$mM ~methodを用立てて、可用な資源たちから一つ選び取ること。
一般に，文書が構文解析された後に %source を手動で操作するのは、不必要に複雑な~approachである。
◎
Dynamically modifying a source element and its attribute when the element is already inserted in a video or audio element will have no effect. To change what is playing, just use the src attribute on the media element directly, possibly making use of the canPlayType() method to pick from amongst available resources. Generally, manipulating source elements manually after the document has been parsed is an unnecessarily complicated approach.
</p>

	</li>
	<li>

<p>
%source の `type$aS 属性は、`~media資源$の型を与える
— それは、~UAが，当の`~media資源$を~fetchする前に再生できるかどうか決定するのを助けるためにある。
ある種の~MIME型は、 ~codecs ~parameterを定義する
— それは、資源がどう符号化されたかを正確に指定するため，必要とされる場合もある。
`RFC6381$r
◎
The type attribute gives the type of the media resource, to help the user agent determine if it can play this media resource before fetching it. The codecs parameter, which certain MIME types define, might be necessary to specify exactly how the resource is encoded. [RFC6381]
</p>

<div class="example">
<p>
以下に、 `type$aS 属性における ~codecs ~MIME~parameter（ `codecs="…"^c ）の用例をいくつか挙げる：
◎
The following list shows some examples of how to use the codecs= MIME parameter in the type attribute.
</p>

<dl>
	<dt>
~MP4容器~内の［
H.264 Constrained baseline ~profile動画（ `main^pf, および `extended^pf 動画に互換） ~level 3
＆
Low-Complexity AAC 音声
］
◎
H.264 Constrained baseline profile video (main and extended video compatible) level 3 and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'^tag
</dd>

	<dt>
~MP4容器~内の［
 H.264 Extended~profile動画（ `baseline^pf に互換）~level 3
＆
 Low-Complexity AAC 音声
］
◎
H.264 Extended profile video (baseline-compatible) level 3 and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="avc1.58A01E, mp4a.40.2"'^tag
</dd>

	<dt>
~MP4容器~内の［
H.264 Main ~profile動画~level 3
＆
Low-Complexity AAC 音声
］
◎
H.264 Main profile video level 3 and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="avc1.4D401E, mp4a.40.2"'^tag
</dd>

	<dt>
~MP4容器~内の［
 H.264 'High' ~profile動画（［
`main^pf ／ `baseline^pf／ `extended^pf
］~profileとは非~互換）~level 3
＆
Low-Complexity AAC 音声
］
◎
H.264 'High' profile video (incompatible with main, baseline, or extended profiles) level 3 and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="avc1.64001E, mp4a.40.2"'^tag
</dd>

	<dt>
~MP4容器~内の［
MPEG-4 Visual Simple Profile Level 0 動画
＆
Low-Complexity AAC 音声
］
◎
MPEG-4 Visual Simple Profile Level 0 video and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="mp4v.20.8, mp4a.40.2"'^tag
</dd>

	<dt>
~MP4容器~内の［
MPEG-4 Advanced Simple Profile Level 0 動画
＆
Low-Complexity AAC 音声
］
◎
MPEG-4 Advanced Simple Profile Level 0 video and Low-Complexity AAC audio in MP4 container
</dt>
	<dd>
`source src='video.mp4' type='video/mp4; codecs="mp4v.20.240, mp4a.40.2"'^tag
</dd>

	<dt>
3GPP 容器~内の［
 MPEG-4 Visual Simple Profile Level 0 動画
＆
 AMR 音声
］
◎
MPEG-4 Visual Simple Profile Level 0 video and AMR audio in 3GPP container
</dt>
	<dd>
`source src='video.3gp' type='video/3gpp; codecs="mp4v.20.8, samr"'^tag
</dd>

	<dt>
~Ogg容器~内の［
Theora 動画
＆
Vorbis 音声
］
◎
Theora video and Vorbis audio in Ogg container
</dt>
	<dd>
`source src='video.ogv' type='video/ogg; codecs="theora, vorbis"'^tag
</dd>

	<dt>
~Ogg容器~内の［
Theora 動画
＆
Speex 音声
］
◎
Theora video and Speex audio in Ogg container
</dt>
	<dd>
`source src='video.ogv' type='video/ogg; codecs="theora, speex"'^tag
</dd>

	<dt>
~Ogg容器~内の［
動画なし
＆
Vorbis 音声
］
◎
Vorbis audio alone in Ogg container
</dt>
	<dd>
`source src='audio.ogg' type='audio/ogg; codecs=vorbis'^tag
</dd>

	<dt>
~Ogg容器~内の［
動画なし
＆
Speex 音声
］
◎
Speex audio alone in Ogg container
</dt>
	<dd>
`source src='audio.spx' type='audio/ogg; codecs=speex'^tag
</dd>

	<dt>
~Ogg容器~内の［
動画なし
＆
FLAC 音声
］
◎
FLAC audio alone in Ogg container
</dt>
	<dd>
`source src='audio.oga' type='audio/ogg; codecs=flac'^tag
</dd>

	<dt>
~Ogg容器~内の［
Dirac 動画
＆
 Vorbis 音声
］
◎
Dirac video and Vorbis audio in Ogg container
</dt>
	<dd>
`source src='video.ogv' type='video/ogg; codecs="dirac, vorbis"'^tag
</dd>
</dl>

</div>

	</li>
	<li>
%source は、［
`srcset$aS ／ `sizes$aS ／ `media$aS
］属性を有してはナラナイ。
◎
The srcset, sizes, and media attributes must not be present.
</li>
</ul>

<p>
`source$e 要素 が次を満たす`~media要素$ %M の子として `挿入された$nodeときは、~UAは， %M の`資源~選定~algo$を呼出すモノトスル
⇒
［
%M は `src$aM 属性を有さない
］~AND［
%M の `networkState$mM の値 ~EQ `NETWORK_EMPTY$mM
］
◎
If a source element is inserted as a child of a media element that has no src attribute and whose networkState has the value NETWORK_EMPTY, the user agent must invoke the media element's resource selection algorithm.
</p>

<p>
`src@m
~IDL属性は、
`src$aM 内容~属性を`反映する$モノトスル。
◎
The IDL attributes src, type, srcset, sizes and media must reflect the respective content attributes of the same name.
</p>

<div class="example">

<p>
作者は、供した~media資源すべてを ~UAが具現化できるかどうか定かでない場合には、最後の `source$e 要素~上で `error$et ~eventを~listenすれば，~fallback用の挙動を誘発できる：
◎
If the author isn't sure if user agents will all be able to render the media resources provided, the author can listen to the error event on the last source element and trigger fallback behavior:
</p>

<pre class="lang-html">
&lt;script&gt;
 function fallback(%video) {
   /* <span class="comment">
`video$e をその内容に置換する
◎
replace &lt;video&gt; with its contents
</span> */
   while (%video.hasChildNodes()) {
     if (%video.firstChild instanceof HTMLSourceElement)
       %video.removeChild(%video.firstChild);
     else
       %video.parentNode.insertBefore(%video.firstChild, %video);
   }
   %video.parentNode.removeChild(%video);
 }
&lt;/script&gt;
&lt;video controls autoplay&gt;
 &lt;source src='video.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'&gt;
 &lt;source src='video.ogv' type='video/ogg; codecs="theora, vorbis"'
         onerror="fallback(parentNode)"&gt;
 ...
&lt;/video&gt;
</pre>

</div>

			</section>
			<section id="the-video-element">
<h4 title="The video element">4.8.9. `video^e 要素</h4>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$／`句ng内容$／`埋込d内容$／［
要素が `controls$aM 属性を有する場合に限り，
`対話的~内容$
］／`可触~内容$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
If the element has a controls attribute: Interactive content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
<p>
次の順による並び：
</p>
<ol ><li>要素が `src$aM 属性を有さない場合に限り， 0 個以上の `source$e 要素
</li><li>0 個以上の `track$e 要素
</li><li>`透過的な内容$
</li></ol>
<p>
ただし，子孫に`~media要素$は含まないとする。
</p>
◎
If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.
◎
If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`src$aM
— 資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`crossorigin$aM
— 要素が非同一-生成元~要請をどう取扱うか
◎
crossorigin — How the element handles crossorigin requests
</dd>
	<dd>
`poster$aV
— 動画~再生に先立って示す~poster~frame
◎
poster — Poster frame to show prior to video playback
</dd>
	<dd>
`preload$aM
— `~media資源$に必要と見込まれる~buffer量の~hintを与える
◎
preload — Hints how much buffering the media resource will likely need
</dd>
	<dd>
`autoplay$aM
— ~pageが読込まれ次第，`~media資源$を自動的に開始できるかどうかの~hintを与える
◎
autoplay — Hint that the media resource can be started automatically when the page is loaded
</dd>
	<dd>
`playsinline$aV
— 要素の再生~区画の中に動画~内容を表示するよう，~UAに促す
◎
playsinline — Encourage the user agent to display video content within the element's playback area
</dd>
	<dd>
`loop$aM
— `~media資源$を~loopするかどうか
◎
loop — Whether to loop the media resource
</dd>
	<dd>
`muted$aM
— `~media資源$を既定で消音するかどうか
◎
muted — Whether to mute the media resource by default
</dd>
	<dd>
`controls$aM
— ~UA~controlを示す
◎
controls — Show user agent controls
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`video$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLVideoElement@I : `HTMLMediaElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute unsigned long `width$m;
  [`CEReactions$] attribute unsigned long `height$m;
  readonly attribute unsigned long `videoWidth$mV;
  readonly attribute unsigned long `videoHeight$mV;
  [`CEReactions$] attribute USVString `poster$mV;
  [`CEReactions$] attribute boolean `playsInline$mV;
};
</pre>
	</dd>
</dl>

<p>
`video$e 要素は
動画や映画, および
~captionを伴う音声~file
を再生するために利用される。
◎
A video element is used for playing videos or movies, and audio files with captions.
</p>

<p>
`video$e 要素の内側に、内容を供してもヨイ。
~UAは、この内容を利用者に示すベキでない
— それは `video$e を~supportしない旧~web~browser向けに［
旧来の動画~pluginを試行できるよう，あるいは
その利用者に当の動画~内容に~accessする方法を伝える~textを示す
］ためとして意図されている。
◎
Content may be provided inside the video element. User agents should not show this content to the user; it is intended for older web browsers which do not support video, so that legacy video plugins can be tried, or to show text to the users of these older browsers informing them of how to access the video contents.
</p>

<p class="note">注記：
特に，この内容は、~accessibilityの懸念に取組むために意図されるものではない。
［
視覚／聴覚
において，部分的または全部的に, 物理的または認知的な障害
］を抱える利用者~向けに 動画~内容を~access可能にするための，様々な特能が可用である。
［
~caption／手話~track／音述
］は、動画~stream内に埋込める。
~captionは、 `track$e 要素を利用して 外部~fileとして供することもできる。
音述は、 `track$e 要素を利用して，~UAにより発話に合成される~textを内容とする`~WebVTT~file$を参照して埋込める。
~WebVTTは、~chapter~titleを供するためにも利用できる。
~media要素をまったく利用しない利用者~向けには、単純に，音声転写その他の~textな代替への~linkを `video$e 要素~周りの注釈文に供せる。
`WEBVTT$r
◎
In particular, this content is not intended to address accessibility concerns. To make video content accessible to the partially sighted, the blind, the hard-of-hearing, the deaf, and those with other physical or cognitive disabilities, a variety of features are available. Captions can be provided, either embedded in the video stream or as external files using the track element. Sign-language tracks can be embedded in the video stream. Audio descriptions can be embedded in the video stream or in text form using a WebVTT file referenced using the track element and synthesized into speech by the user agent. WebVTT can also be used to provide chapter titles. For users who would rather not use a media element at all, transcripts or other textual alternatives can be provided by simply linking to them in the prose near the video element. [WEBVTT]
</p>

<p>
`video$e 要素は、表向きは動画~dataを`~media~data$とする`~media要素$であり，場合によっては音声~dataが結付けられる。
◎
The video element is a media element whose media data is ostensibly video data, possibly with associated audio data.
</p>

<p>
［
`src$aM ／ `crossorigin$aM ／ `preload$aM ／ `autoplay$aM ／ `loop$aM ／ `muted$aM ／ `controls$aM
］属性は、`すべての~media要素に共通な属性$である。
◎
The src, crossorigin, preload, autoplay, loop, muted, and controls attributes are the attributes common to all media elements.
</p>

<p>
`poster@aV
属性は、動画~dataが可用でない間に~UAが示せる画像~fileの`~URL$を与える。
指定する値は、`前後~空白~可の妥当かつ空でない~URL$でなければナラナイ。
◎
The poster attribute gives the URL of an image file that the user agent can show while no video data is available. The attribute, if present, must contain a valid non-empty URL potentially surrounded by spaces.
</p>

<div class="algo">
<p>
`video$e 要素 %video に指定された資源が利用されることになる場合、［
%video の作成-時 ／
%video の `poster$aV 属性が［
設定- ／ 変更- ／ 除去-
］されたときには，~UAは
%video の
`~poster~frame@
を次を走らせた結果にするモノトスル（ %video は`~posterを示して$いようがいまいが）（結果の ε は、`~poster~frame$はないことを表す）：
◎
If the specified resource is to be used, then, when the element is created or when the poster attribute is set, changed, or removed, the user agent must run the following steps to determine the element's poster frame (regardless of the value of the element's show poster flag):
</p> 

<ol>
	<li>
~IF［
%video 用に走らせている，この~algoの既存の~instanceがある
］
⇒
その~instanceを中止する（`~poster~frame$は変更せずに）
◎
If there is an existing instance of this algorithm running for this video element, abort that instance of this algorithm without changing the poster frame.
</li>
	<li>
%poster ~LET %video は `poster$aV 属性を［
有するならば その値 ／
有さないならば ε
］
</li>
	<li>
~IF［
%poster ~IN { ε, 空~文字列 }
］
⇒
~RET ε
◎
If the poster attribute's value is the empty string or if the attribute is absent, then there is no poster frame; return.
</li>
	<li>
%~URL ~LET `相対的に~URL構文解析する$( %poster, 要素の`~node文書$ )
</li>
	<li>
~IF［
%~URL ~EQ `失敗^i
］
⇒
~RET ε
◎
Parse the poster attribute's value relative to the element's node document. If this fails, then there is no poster frame; return.
</li>
	<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒＃
`~URL$rq ~SET %~URL,
`~client$rq ~SET 要素の`~node文書$に`関連な設定群~obj$,
`行先$rq ~SET `image^l,
`資格証~mode$rq ~SET `include^l,
`~URL資格証を利用するか$rq ~SET ~T
◎
Let request be a new request whose URL is the resulting URL record, client is the element's node document's relevant settings object, destination is "image", credentials mode is "include", and whose use-URL-credentials flag is set.
</li>
	<li>
%要請 を`~fetch$する
— これは、 %video の`~node文書$の`~load~eventを遅延-$するモノトスル
◎
Fetch request. This must delay the load event of the element's node document.
</li>
	<li>
~IF［
何らかの画像が得された
］
⇒
~RET その画像
◎
If an image is thus obtained, the poster frame is that image.＼
</li>
	<li>
~RET ε
◎
Otherwise, there is no poster frame.
</li>
</ol>
</div>

<p class="note">注記：
`poster$aV 属性が与える`~poster~frame$は、どの様な動画なのか見当を利用者に与える，動画の代表~frameになることが意図される（概して，最初の方にある空内容でない~frame）
◎
The image given by the poster attribute, the poster frame, is intended to be a representative frame of the video (typically one of the first non-blank frames) that gives the user an idea of what the video is like.
</p>

<p>
`playsinline@aV
属性は、`真偽-属性$であり，次を~UAに~~指示する~hintとして~~働く
⇒
在るならば、その動画は，既定では文書~内に “~inline” に
— すなわち，要素の再生~区画に拘束される下で —
表示されるべきである
— 全~screenに, あるいは 独立かつ~resize可能な~UIwindow内にではなく。
◎
The playsinline attribute is a boolean attribute. If present, it serves as a hint to the user agent that the video ought to be displayed "inline" in the document by default, constrained to the element's playback area, instead of being displayed fullscreen or in an independent resizable window.
</p>

<p class="note">注記：
`playsinline$aV 属性が無いことが、動画は既定で全~screenに表示することを含意するわけではない。
~~実際、ほとんどの~UAは，すべての動画を既定で~inlineに再生することを選んでおり、そのような~UAにおいては `playsinline$aV 属性の効果はない。
◎
The absence of the playsinline attributes does not imply that the video will display fullscreen by default. Indeed, most user agents have chosen to play all videos inline by default, and in such user agents the playsinline attribute has no effect.
</p>

<hr>

<div class="algo">
<p>
`video$e 要素 %video が所与の時点で表現するものは、その時点で次を走らせた結果として定義される：
◎
A video element represents what is given for the first matching condition in the list below:
</p>

<ol>
	<li>
%readyState ~LET %video の`readyState$mM 属性~値
◎
↓</li>
	<li>
%~poster ~LET %video の`~poster~frame$
◎
↓</li>
	<li>
<p>
~IF［
次のいずれかが満たされる（すなわち，可用な動画~dataはない）
］…：
◎
When no video data is available (＼
</p>
		<ul>
			<li>
%readyState ~EQ `HAVE_NOTHING$mM
◎
the element's readyState attribute is either HAVE_NOTHING, or＼
</li>
			<li>
［
%readyState ~EQ `HAVE_METADATA$mM
］~AND［
動画~dataはまったく得されてない
］
◎
HAVE_METADATA but no video data has yet been obtained at all, or＼
</li>
			<li>
［
%readyState ~NIN { `HAVE_NOTHING$mM, `HAVE_METADATA$mM } 
］~AND［
%video の`~media資源$に動画~channelはない
］］
◎
the element's readyState attribute is any subsequent value but the media resource does not have a video channel)
</li>
		</ul>

<p>
…ならば
⇒
~RET ［
%~poster ~NEQ ε ならば %~poster ／
~ELSE_ `内在的~寸法$を伴わない`透明な黒$
］
◎
The video element represents its poster frame, if any, or else transparent black with no intrinsic dimensions.
</p>
	</li>
	<li>
~Assert：
%video の`~media資源$に動画~channelはある
</li>
	<li>
%paused ~LET %video の `paused$mM
◎
↓</li>
	<li>
%描画-済み~frame ~LET 最後に描画された動画の~frame
◎
↓</li>
	<li>
%現~frame ~LET ［
`現在の再生~位置$に対応する動画の~frameが可用なら それ ／
~ELSE_ ε
］
◎
↓</li>
	<li>
<p>
~IF［
%paused ~EQ ~T
］：
</p>
		<ol>
			<li>
~IF［
%現~frame は動画の最初の~frameである
］~AND［
%video は`~posterを示して$いる
］~AND［
%~poster ~NEQ ε
］
⇒
~RET %~poster
</li>
			<li>
~IF［
%現~frame ~NEQ ε
］
⇒
~RET %現~frame
</li>
			<li>
~RET %描画-済み~frame（例： 動画は~seek中か~buffer中にある）
</li>
		</ol>

◎
When the video element is paused, the current playback position is the first frame of video, and the element's show poster flag is set
◎
• The video element represents its poster frame, if any, or else the first frame of the video.
◎
When the video element is paused, and the frame of video corresponding to the current playback position is not available (e.g. because the video is seeking or buffering)
◎
↓When the video element is neither potentially playing nor paused (e.g. when seeking or stalled)
◎
• The video element represents the last frame of the video to have been rendered.
◎
When the video element is paused
◎
• The video element represents the frame of video corresponding to the current playback position.
</li>
	<li>
~ELIF［
%video は`再生-中であり得る$でない（例： 動画は ~seek中か停滞している）
］
⇒
~RET %描画-済み~frame
◎
↑</li>
	<li>
<p>
~RET %現~frame
（ %video には動画~channelがあって`再生-中であり得る$）
— この時点で：
◎
Otherwise (the video element has a video channel and is potentially playing)
</p>
		<ul>
			<li>
%video は、絶え間なく~~更新され続ける`現在の再生~位置$にある動画の~frameを`表現-$する。
◎
The video element represents the frame of video at the continuously increasing "current" position.＼
</li>
			<li>
`現在の再生~位置$が変化して，%描画-済み~frame が動画~内の`現在の再生~位置$に対応する~frameでなくなったときは、新たな~frameを描画するモノトスル。
◎
When the current playback position changes such that the last frame rendered is no longer the frame corresponding to the current playback position in the video, the new frame must be rendered.
</li>
		</ul>
	</li>
</ol>
</div>

<p>
動画の~frameは、`~event~loop$が最後に`最初の段$に達した時点で`選択されている動画~track$から得するモノトスル。
◎
Frames of video must be obtained from the video track that was selected when the event loop last reached step 1.
</p>

<p class="note">注記：
特定0の再生~位置に 動画~stream内のどの~frameが対応するかは、動画~streamの形式により定義される。
◎
Which frame in a video stream corresponds to a particular playback position is defined by the video stream's format.
</p>

<p>
`video$e 要素は、上述に加え，次に挙げるものも`表現-$する：
◎
The video element also represents＼
</p>

<ul>
	<li>
［
要素の`~tT~list$を成す各`~tT$のうち，［
`~mode$tT ~EQ `~showing$i
］を満たすものの`~cue~list$tT
］を成す各`~cue$のうち，［
`作動中か$tC ~EQ ~T
］を満たすものが在れば、それら
◎
any text track cues whose text track cue active flag is set and whose text track is in the showing mode, and＼
</li>
	<li>
`現在の再生~位置$にある［
`~media資源$からの音声
］が在れば、それら
◎
any audio from the media resource, at the current playback position.
</li>
</ul>

<p>
`~media資源$に結付けられている音声が再生される場合は、`現在の再生~位置$に同期するように，要素の`実効~media音量$で再生するモノトスル。
~UAは、［
`~event~loop$が最後に`最初の段$に達した時点で，
<a href="#dom-audiotrack-enabled">可能化されている</a>
音声~track
］からの音声を再生するモノトスル。
◎
Any audio associated with the media resource must, if played, be played synchronized with the current playback position, at the element's effective media volume. The user agent must play the audio from audio tracks that were enabled when the event loop last reached step 1.
</p>

<p>
上に加えて、~UAは，利用者に~message（
 “~buffer中”, “動画まだ読込まれてない”, “~error”
 など，より詳細な情報）を供してヨイ
— ~textや~iconを動画や他の要素の再生~区画~上に積層する，あるいは別の適切な方式で。
◎
In addition to the above, the user agent may provide messages to the user (such as "buffering", "no video loaded", "error", or more detailed information) by overlaying text or icons on the video or other areas of the element's playback area, or in another appropriate manner.
</p>

<p>
動画を描画できない~UAは、要素が［
外部の動画~再生~utility ／ 動画~data自体
］への~linkを`表現-$するようにしてもヨイ。
◎
User agents that cannot render the video may instead make the element represent a link to an external video playback utility or to the video data itself.
</p>

<div class="p">
<p>
`video$e 要素の`~media資源$に動画~channelがある場合、要素は，次のような`塗り~source$を供する：
</p>
<ul>
	<li>
( 横幅, 縦幅 ) は`~media資源$の ( `内在的~横幅$vD, `内在的~縦幅$vD )
</li>
	<li>
外観は ［
`現在の再生~位置$に対応する動画の~frameが可用ならば それ ／
~ELSE_（例：動画は~seek中か~buffer中）その前の外観があれば それ ／
~ELSE_（例：動画はまだ最初の~frameの読込中にある）黒一色
］
</li>
</ul>
◎
When a video element's media resource has a video channel, the element provides a paint source whose width is the media resource's intrinsic width, whose height is the media resource's intrinsic height, and whose appearance is the frame of video corresponding to the current playback position, if that is available, or else (e.g. when the video is seeking or buffering) its previous appearance, if any, or else (e.g. because the video is still loading the first frame) blackness.
</div>

<hr>

<dl class="domintro">
	<dt>%video.`videoWidth$mV</dt>
	<dt>%video.`videoHeight$mV</dt>
	<dd>
これらの属性は、［
寸法が既知ならば動画の内在的~寸法 ／
~ELSE_ 0
］を返す。
◎
These attributes return the intrinsic dimensions of the video, or zero if the dimensions are not known.
</dd>
</dl>

<p>
`~media資源$の
`内在的~横幅@vD
／
`内在的~縦幅@vD
は、その資源に利用されている形式により定義される［
資源の寸法,
縦横比,
`clean aperture^en†,
解像度,
等々
］を織り込んだ後の時点での，`~CSS~pixel$数による資源の寸法とする。
`anamorphic^en 形式††が，［
“正しい” 寸法に~~復元するための，縦横比を動画~dataの寸法に適用する方法
］を定義していない場合、~UAは、一方の寸法は変えないまま他方の寸法を増やすことにより，縦横比を適用するモノトスル。
◎
The intrinsic width and intrinsic height of the media resource are the dimensions of the resource in CSS pixels after taking into account the resource's dimensions, aspect ratio, clean aperture, resolution, and so forth, as defined for the format used by the resource. If an anamorphic format does not define how to apply the aspect ratio to the video data's dimensions to obtain the "correct" dimensions, then the user agent must apply the ratio by increasing one dimension and leaving the other unchanged.
</p>

<p class="trans-note">【†
動画の符号化処理の都合により縁に現れる “ゴミ” が見えなくなるよう切り~~落とすための， “きれいな” 区画。
】【††
円柱レンズで縦横いずれかの方向に圧縮して撮影された形式の動画
】</p>

<div class="algo">
<p>
［
`videoWidth@mV／
`videoHeight@mV
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの `readyState$mM 属性 ~EQ `HAVE_NOTHING$mM
］
⇒
~RET 0
</li>
	<li>
~RET `~CSS~pixel$数による動画の［
`videoWidth^m 用には `内在的~横幅$vD ／
`videoHeight^m 用には `内在的~縦幅$vD
］
</li>
</ol>
◎
The videoWidth IDL attribute must return the intrinsic width of the video in CSS pixels. The videoHeight IDL attribute must return the intrinsic height of the video in CSS pixels. If the element's readyState attribute is HAVE_NOTHING, then the attributes must return 0.
</div>

<p id="dimUpdate">
`~media要素$ %要素 が表現する動画の［
`内在的~横幅$vD ／ `内在的~縦幅$vD
］が変化したときは（例えば，`選択されている動画~track$が変化したときも含む）、~UAは次を走らすモノトスル
⇒
~IF［
%要素 の `readyState$mM 属性 ~NEQ `HAVE_NOTHING$mM
］
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `resize$et )
◎
Whenever the intrinsic width or intrinsic height of the video changes (including, for example, because the selected video track was changed), if the element's readyState attribute is not HAVE_NOTHING, the user agent must queue a media element task given the media element to fire an event named resize at the media element.
</p>

<p>
`video$e 要素は、`寸法~属性$を~supportする。
◎
The video element supports dimension attributes.
</p>

<p>
~style規則が無い下でも、動画~内容は，［
その縦横比は保全しつつ，要素の再生~区画に完全に収まるような最~大~sizeで、区画の中央に示される
］ように描画されるベキである。
したがって，要素の再生~区画と動画とで縦横比が合致しない場合、再生~区画~内に動画が占めない部位が生じることになる
— その部位は何も表現しない。
◎
In the absence of style rules to the contrary, video content should be rendered inside the element's playback area such that the video content is shown centered in the playback area at the largest possible size that fits completely within it, with the video content's aspect ratio being preserved. Thus, if the aspect ratio of the playback area does not match the aspect ratio of the video, the video will be shown letterboxed or pillarboxed. Areas of the element's playback area that do not contain the video represent nothing.
</p>

<p class="note">注記：
~CSSを実装する~UAにおいては、上の要件は，
<a href="~HTMLrendering#video-object-fit">§ 具現化にて示唆される~style規則</a>
を利用して実装できる。
◎
In user agents that implement CSS, the above requirement can be implemented by using the style rule suggested in the Rendering section.
</p>

<p>
`video$e 要素の再生~区画の［
`内在的~横幅$, `内在的~縦幅$
］は：
◎
↓</p>

<ul>
	<li>
横幅は、［
`~poster~frame$の`内在的~横幅$が可用, かつ要素は~poster~frameを現在`表現-$しているならば それ ／
~ELSE_ 動画~資源の`内在的~横幅$vDが可用ならば それ ／
~ELSE_ ε（なし）
］とする。
◎
The intrinsic width of a video element's playback area is the intrinsic width of the poster frame, if that is available and the element currently represents its poster frame; otherwise, it is the intrinsic width of the video resource, if that is available; otherwise the intrinsic width is missing.
</li>
	<li>
縦幅は、横幅を縦幅に読み替える下で，横幅のときと同様とする。
◎
The intrinsic height of a video element's playback area is the intrinsic height of the poster frame, if that is available and the element currently represents its poster frame; otherwise it is the intrinsic height of the video resource, if that is available; otherwise the intrinsic height is missing.
</li>
</ul>

<p>
`既定の~obj~size$は、`~CSS~pixel$数で
横幅 300, 縦幅 150
とする。
`CSSIMAGES$r
◎
The default object size is a width of 300 CSS pixels and a height of 150 CSS pixels. [CSSIMAGES]
</p>

<hr>

<p>
~UAは［
開閉可能な~caption, 音述~track,
動画~streamに結付けられている他の追加的な~data
］の表示の［
可能化-, 不能化-
］を制御する~controlを供するベキである
— そのような特能もまた、~pageの通常の描画には干渉しないベキである。
◎
User agents should provide controls to enable or disable the display of closed captions, audio description tracks, and other additional data associated with the video stream, though such features should, again, not interfere with the page's normal rendering.
</p>

<p>
~UAは、利用者がより相応しい方式で動画~内容を見れるようにしてもヨイ
— ［
全~screenや 独立かつ~resize可能な~UIwindow
］内など。
~UAは、そのような視聴v~modeを動画の再生-時に既定で誘発してもヨイ
—  `playsinline$aV 属性が指定されているときは，そうするベキでないが。
他の~UI特能と同じく，これを可能化する~controlは、~UAが`~UIを公開する$ときを除き，~pageの通常の描画に干渉するベキでない。
しかしながら，そのような独立な視聴v~modeにおいては、~UAは，
`controls$aM 属性が無い下でも全部的な~UIを可視にしてヨイ。
◎
User agents may allow users to view the video content in manners more suitable to the user, such as fullscreen or in an independent resizable window. User agents may even trigger such a viewing mode by default upon playing a video, although they should not do so when the playsinline attribute is specified. As with the other user interface features, controls to enable this should not interfere with the page's normal rendering unless the user agent is exposing a user interface. In such an independent viewing mode, however, user agents may make full user interfaces visible, even if the controls attribute is absent.
</p>

<p>
動画~再生-時に利用者~体験を損ないかねない~system特能がある場合、~UAは，それを~~抑制してもヨイ
— 例えば~UAは、動画の再生が進捗-中にある間は，~screensaverを不能化することもできる。
◎
User agents may allow video playback to affect system features that could interfere with the user's experience; for example, user agents could disable screensavers while video playback is in progress.
</p>

<hr>

<p>
`poster@mV
~IDL属性は、
`poster$aV 内容~属性を`反映する$モノトスル。
◎
The poster IDL attribute must reflect the poster content attribute.
</p>

<p>
`playsInline@mV
~IDL属性は、
`playsinline$aV 内容~属性を`反映する$モノトスル。
◎
The playsInline IDL attribute must reflect the playsinline content attribute.
</p>

<div class="example">

<p>
動画を正しく再生するのに失敗したことを検出する方法の一例：
◎
This example shows how to detect when a video has failed to play correctly:
</p>

<pre class="lang-html">
&lt;script&gt;
 function failed(%e) {
   /* <span class="comment">
動画の再生に失敗した
—  その原因についての~messageを示す
◎
video playback failed - show a message saying why
</span> */
   switch (%e.target.error.code) {
     case %e.target.error.MEDIA_ERR_ABORTED:
       alert('動画の再生を中止しましたね。');
       break;
     case %e.target.error.MEDIA_ERR_NETWORK:
       alert('~network~errorのため、動画~downloadの中途で失敗しました。');
       break;
     case %e.target.error.MEDIA_ERR_DECODE:
       alert('動画の再生を中止しました。動画~dataに問題があるか，動画はこの~browserが~supportしない特能を利用しています。');
       break;
     case %e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
       alert('~serverまたは~networkに問題があるか，形式が未~supportなため、動画を読込めませんでした。');
       break;
     default:
       alert('未知な~errorが生じました。');
       break;
   }
 }
&lt;/script&gt;
&lt;p&gt;&lt;video src="tgif.vid" autoplay controls onerror="failed(event)"&gt;&lt;/video&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="tgif.vid"&gt;Download the video file&lt;/a&gt;.&lt;/p&gt;
</pre>
<!-- 
<script>
 function failed(e) {
   // video playback failed - show a message saying why
   switch (e.target.error.code) {
     case e.target.error.MEDIA_ERR_ABORTED:
       alert('You aborted the video playback.');
       break;
     case e.target.error.MEDIA_ERR_NETWORK:
       alert('A network error caused the video download to fail part-way.');
       break;
     case e.target.error.MEDIA_ERR_DECODE:
       alert('The video playback was aborted due to a corruption problem or because the video used features your browser did not support.');
       break;
     case e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
       alert('The video could not be loaded, either because the server or network failed or because the format is not supported.');
       break;
     default:
       alert('An unknown error occurred.');
       break;
   }
 }
</script>
<p><video src="tgif.vid" autoplay controls onerror="failed(event)"></video></p>
<p><a href="tgif.vid">Download the video file</a>.</p>

-->

</div>

			</section>
			<section id="the-audio-element">
<h4 title="The audio element">4.8.10. `audio^e 要素</h4>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$／`句ng内容$／`埋込d内容$／［
要素が `controls$aM 属性を有する場合に限り，`対話的~内容$
］ ／［
要素が `controls$aM 属性を有する場合に限り，`可触~内容$
］
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
If the element has a controls attribute: Interactive content.
◎
If the element has a controls attribute: Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
<p>
次の順による並び：
</p>
<ol ><li>要素が `src$aM 属性を有さない場合に限り， 0 個以上の `source$e 要素
</li><li>0 個以上の `track$e 要素
</li><li>`透過的な内容$
</li></ol>
<p>
ただし，子孫に`~media要素$は含まないとする。
</p>

◎
If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.
◎
If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`src$aM
— 資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`crossorigin$aM
— 要素が非同一-生成元~要請をどう取扱うか
◎
crossorigin — How the element handles crossorigin requests
</dd>
	<dd>
`preload$aM
— `~media資源$に必要と見込まれる~buffer量の~hintを与える
◎
preload — Hints how much buffering the media resource will likely need
</dd>
	<dd>
`autoplay$aM
— ~pageが読込まれ次第，`~media資源$を自動的に開始できるかどうかの~hintを与える
◎
autoplay — Hint that the media resource can be started automatically when the page is loaded
</dd>
	<dd>
`loop$aM
— `~media資源$を~loopするかどうか
◎
loop — Whether to loop the media resource
</dd>
	<dd>
`muted$aM
— `~media資源$を既定で消音するかどうか
◎
muted — Whether to mute the media resource by default
</dd>
	<dd>
`controls$aM
— ~UA~controlを示す
◎
controls — Show user agent controls
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`audio$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window,
`LegacyFactoryFunction$=`Audio$m(optional DOMString %src)]
interface `HTMLAudioElement@I : `HTMLMediaElement$I {
  [`HTMLConstructor$] constructor();
};
</pre>
	</dd>
</dl>

<p>
`audio$e 要素は、音響または音声の~streamを`表現-$する。
◎
An audio element represents a sound or audio stream.
</p>

<p>
`audio$e 要素の内側に内容が供されてもヨイ。
~UAは、この内容を利用者に示すベキでない
— それは `audio$e を~supportしない旧~web~browser向けに［
旧来の音声~pluginを試行できるよう，あるいは
利用者に当の動画~内容に~accessする方法を伝える~textを示す
］ためとして意図されている。
◎
Content may be provided inside the audio element. User agents should not show this content to the user; it is intended for older web browsers which do not support audio, so that legacy audio plugins can be tried, or to show text to the users of these older browsers informing them of how to access the audio contents.
</p>

<p class="note">注記：
特に、この内容は［
~accessibilityの懸念に取組むために意図されるもの
］ではない。
［
聴覚において，部分的または全部的に, 物理的または認知的な障害
］を抱える利用者~向けに 音声~内容を~access可能にするための，様々な特能が可用である。
~captionや手話~動画が可用なら、
`audio$e 要素に代えて `video$e 要素を利用して音声を再生すれば，利用者に視覚的な代替も~~供せるようになる。
`track$e 要素と `~WebVTT~file$を利用して~chapter~titleを供すれば、~naviを援助できる。
当然ながら、単純に，音声転写その他の~textな代替への~linkを `audio$e 要素~周りの注釈文に供することもできる。
`WEBVTT$r
◎
In particular, this content is not intended to address accessibility concerns. To make audio content accessible to the deaf or to those with other physical or cognitive disabilities, a variety of features are available. If captions or a sign language video are available, the video element can be used instead of the audio element to play the audio, allowing users to enable the visual alternatives. Chapter titles can be provided to aid navigation, using the track element and a WebVTT file. And, naturally, transcripts or other textual alternatives can be provided by simply linking to them in the prose near the audio element. [WEBVTT]
</p>

<p>
`audio$e 要素は、表向きは音声~dataを`~media~data$とする`~media要素$である。
◎
The audio element is a media element whose media data is ostensibly audio data.
</p>

<p>
［
`src$aM ／ `crossorigin$aM ／ `preload$aM ／ `autoplay$aM ／ `loop$aM ／ `muted$aM ／ `controls$aM
］属性は、`すべての~media要素に共通な属性$である。
◎
The src, crossorigin, preload, autoplay, loop, muted, and controls attributes are the attributes common to all media elements.
</p>

<dl class="domintro">
	<dt>%audio = new `Audio( [ url ] )$m</dt>
	<dd>
新たな `audio$e 要素を返す。
%url 引数は、与えられていれば， `src$aM 属性に設定される。
◎
Returns a new audio element, with the src attribute set to the value passed in the argument, if applicable.
</dd>
</dl>

<div class="algo">
<p>
`Audio(src)@m
~methodは、
`HTMLAudioElement$I ~objを作成する旧来の~factory関数である（ `createElement()$m などの~DOMによる~factory~methodに加えて供されている）。
その~method~手続きは：
◎
A legacy factory function is provided for creating HTMLAudioElement objects (in addition to the factory methods from DOM such as createElement()): Audio(src).＼
When invoked, the legacy factory function must perform the following steps:
</p>
<ol>
	<li>
%文書 ~LET `現在の大域~obj$に`結付けられている文書$
◎
Let document be the current global object's associated Document.
</li>
	<li>
%audio ~LET `要素を作成する$( %文書, `audio$e, `~HTML名前空間$ )
◎
Let audio be the result of creating an element given document, audio, and the HTML namespace.
</li>
	<li>
%audio の`属性~値を設定する$( "`preload$aM", "`auto$v" )
◎
Set an attribute value for audio using "preload" and "auto".
</li>
	<li>
~IF［
%src は与えられている
］
⇒
%audio の`属性~値を設定する$( "`src$aM", %src )
（~UAは %audio 用の`資源~選定~algo$を
<a href="#concept-media-load-algorithm-at-creation">呼出す</a>
ことになる。）
◎
If src is given, then set an attribute value for audio using "src" and src. (This will cause the user agent to invoke the object's resource selection algorithm before returning.)
</li>
	<li>
~RET %audio
◎
Return audio.
</li>
</ol>
</div>

			</section>
			<section id="the-track-element">
<h4 title="The track element">4.8.11. `track^e 要素</h4>

<p class="trans-note">【
この節の内容の和訳は、<a href="~HEtrack#the-track-element">別ページ</a>にて。
】</p>

			</section>
			<section id="media-elements">
<h4 title="Media elements">4.8.12. ~media要素</h4>

<p>
`HTMLMediaElement$I ~obj（この仕様における
`audio$e ／ `video$e
）は、単に
`~media要素@
とも呼ばれる。
◎
HTMLMediaElement objects (audio and video, in this specification) are simply known as media elements.
</p>

<pre class="idl">
enum `CanPlayTypeResult@I { "" /* `空~文字列$cP */, `maybe$l, `probably$l };

typedef (`MediaStream$I or `MediaSource$I or `Blob$I) `MediaProvider@I;

[Exposed=Window]
interface `HTMLMediaElement@I : `HTMLElement$I {

  // <span class="comment">~error状態</span>
  readonly attribute `MediaError$I? `error$mM;

  // <span class="comment">~network状態</span>
  [`CEReactions$] attribute USVString `src$mM;
  attribute `MediaProvider$I? `srcObject$mM;
  readonly attribute USVString `currentSrc$mM;
  [`CEReactions$] attribute DOMString? `crossOrigin$mM;
  const unsigned short `NETWORK_EMPTY$mM = 0;
  const unsigned short `NETWORK_IDLE$mM = 1;
  const unsigned short `NETWORK_LOADING$mM = 2;
  const unsigned short `NETWORK_NO_SOURCE$mM = 3;
  readonly attribute unsigned short `networkState$mM;
  [`CEReactions$] attribute DOMString `preload$mM;
  readonly attribute `TimeRanges$I `buffered$mM;
  undefined `load$mM();
  `CanPlayTypeResult$I `canPlayType$mM(DOMString %type);

  // <span class="comment">準備状態</span>
  const unsigned short `HAVE_NOTHING$mM = 0;
  const unsigned short `HAVE_METADATA$mM = 1;
  const unsigned short `HAVE_CURRENT_DATA$mM = 2;
  const unsigned short `HAVE_FUTURE_DATA$mM = 3;
  const unsigned short `HAVE_ENOUGH_DATA$mM = 4;
  readonly attribute unsigned short `readyState$mM;
  readonly attribute boolean `seeking$mM;

  // <span class="comment">再生~状態</span>
  attribute double `currentTime$mM;
  undefined `fastSeek$mM(double %time);
  readonly attribute unrestricted double `duration$mM;
  `object$ `getStartDate$mM();
  readonly attribute boolean `paused$mM;
  attribute double `defaultPlaybackRate$mM;
  attribute double `playbackRate$mM;
  attribute boolean `preservesPitch$mM;
  readonly attribute `TimeRanges$I `played$mM;
  readonly attribute `TimeRanges$I `seekable$mM;
  readonly attribute boolean `ended$mM;
  [`CEReactions$] attribute boolean `autoplay$mM;
  [`CEReactions$] attribute boolean `loop$mM;
  Promise&lt;undefined&gt; `play$mM();
  undefined `pause$mM();

  // <span class="comment">各種~control</span>
  [`CEReactions$] attribute boolean `controls$mM;
  attribute double `volume$mM;
  attribute boolean `muted$mM;
  [`CEReactions$] attribute boolean `defaultMuted$mM;

  // <span class="comment">各種~track</span>
  [SameObject] readonly attribute `AudioTrackList$I `audioTracks$mM;
  [SameObject] readonly attribute `VideoTrackList$I `videoTracks$mM;
  [SameObject] readonly attribute `TextTrackList$I `textTracks$mM;
  `TextTrack$I `addTextTrack$mM(`TextTrackKind$I %kind, optional DOMString %label = "", optional DOMString %language = "");
};
</pre>

<p>
`~media要素~属性@
—
`src$aM,
`crossorigin$aM,
`preload$aM,
`autoplay$aM,
`loop$aM,
`muted$aM,
`controls$aM
—
は、この節にて定義され，すべての`~media要素$に適用される。
◎
The media element attributes, src, crossorigin, preload, autoplay, loop, muted, and controls, apply to all media elements. They are defined in this section.
</p>

<p>
`~media要素$は、利用者に［
音声~data ／
動画＆音声~data
］を呈示するために利用される。
この~dataは、この節においては
`~media~data@
と称される
— この節は［
音声, 動画
］用の`~media要素$に等しく適用されるので。
用語
`~media資源@
は、~media~dataの完全な集合を指すために利用される
— 例えば、完全な［
動画／音声
］~file。
◎
Media elements are used to present audio data, or video and audio data, to the user. This is referred to as media data in this section, since this section applies equally to media elements for audio or for video. The term media resource is used to refer to the complete set of media data, e.g. the complete video file, or complete audio file.
</p>

<p>
`~media資源$は、複数の［
音声／動画
］~trackを持ち得る。
`~media要素$の目的における`~media資源$の［
動画~data ／ 音声~data
］は、`~event~loop$が最後に`最初の段$に達した時点で，要素の［
`videoTracks$mM ／ `audioTracks$mM
］属性が与える［
現在~選択されている~trackのそれ（もしあれば） ／
現在~可能化されている~trackのそれら（もしあれば）を混合した結果
］に限られる。
◎
A media resource can have multiple audio and video tracks. For the purposes of a media element, the video data of the media resource is only that of the currently selected track (if any) as given by the element's videoTracks attribute when the event loop last reached step 1, and the audio data of the media resource is the result of mixing all the currently enabled tracks (if any) given by the element's audioTracks attribute when the event loop last reached step 1.
</p>

<p class="note">注記：
`audio$e, `video$e
両~要素とも［
音声, 動画
］の両者に利用できる。
この 2 つの主な相違は、単純に，視覚的な内容（動画や~captionなど）用の再生~区画が［
`audio$e 要素にはなく, `video$e 要素にはある
］ことである。
◎
Both audio and video elements can be used for both audio and video. The main difference between the two is simply that the audio element has no playback area for visual content (such as video or captions), whereas the video element does.
</p>

<p>
各`~media要素$には、一意な
`~media要素~event~task源@
がある。
【すなわち，要素ごとに別々な`~task源$を成す。】
◎
Each media element has a unique media element event task source.
</p>

<div class="algo">
<p>
`~media~taskを~queueする@
ときは、所与の
( `~media要素$ %要素, 何かを遂行する一連の段 %手続き )
に対し，次を走らす
⇒
`要素~taskを~queueする$( %要素 の`~media要素~event~task源$, %要素, %手続き )
</p>

<p>
【表記上の都合により，】
これは、次のような形でも呼出される
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
（ %手続き を成す内容 ）
</p>

◎
To queue a media element task with a media element element and a series of steps steps, queue an element task on the media element's media element event task source given element and steps.
</div>

				<section id="error-codes">
<h5 title="Error codes">4.8.12.1. ~error~code</h5>

<dl class="domintro">

	<dt>%media.`error$mM</dt>
	<dd>
要素の現在の~error状態を表現している `MediaError$I ~objを返す。
◎
Returns a MediaError object representing the current error state of the element.
</dd>
	<dd>
~errorが生じてなければ ~NULL を返す。
◎
Returns null if there is no error.
</dd>
</dl>

<p>
各`~media要素$には、~error状態sが結付けられる
— それは、要素がその`資源~選定~algo$が最後に呼出されてから遭遇した最後の~errorを記録する。
◎
All media elements have an associated error status, which records the last error the element encountered since its resource selection algorithm was last invoked.＼
</p>

<div class="algo">
<p>
`error@mM
取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレにおいて~errorは まだ生じていない
］
⇒
~RET ~NULL
</li>
	<li>
~RET コレにおいて最後に生じた~error用に作成された `MediaError$I ~obj
</li>
</ol>
◎
The error attribute, on getting, must return the MediaError object created for this last error, or null if there has not been an error.
</div>

<pre class="idl">
[Exposed=Window]
interface `MediaError@I {
  const unsigned short `MEDIA_ERR_ABORTED$mE = 1;
  const unsigned short `MEDIA_ERR_NETWORK$mE = 2;
  const unsigned short `MEDIA_ERR_DECODE$mE = 3;
  const unsigned short `MEDIA_ERR_SRC_NOT_SUPPORTED$mE = 4;

  readonly attribute unsigned short `code$mE;
  readonly attribute DOMString `message$mE;
};
</pre>

<dl class="domintro">
	<dt>%media.`error$mM.`code$mE</dt>
	<dd>
現在の~errorの~error~codeを，下に挙げるいずれかの値として返す。
◎
Returns the current error's error code, from the list below.
</dd>

	<dt>%media.`error$mM.`message$mE</dt>
	<dd>
遭遇した~error条件に特有な診断用の参考~messageを返す。
~messageと~message形式は、一般には，~UAごとに一様でない。
そのような~messageは可用でない場合、空~文字列が返される。
◎
Returns a specific informative diagnostic message about the error condition encountered. The message and message format are not generally uniform across different user agents. If no such message is available, then the empty string is returned.
</dd>
</dl>

<p>
各 `MediaError$I ~objは、文字列である
`~message@
, および
次のいずれかをとる
`~code@
を持つ：
◎
Every MediaError object has a message, which is a string, and a code, which is one of the following:
</p>

<dl class="def-list">
	<dt>`MEDIA_ERR_ABORTED@mE （数-値 1 ）</dt>
	<dd>
`~media資源$の~fetchingは、利用者の要請に応じて~UAにより中止された。
◎
The fetching process for the media resource was aborted by the user agent at the user's request.
</dd>

	<dt>`MEDIA_ERR_NETWORK@mE （数-値 2 ）</dt>
	<dd>
資源は利用-可能であると確立された後、何らかの~network~errorにより，~UAによる`~media資源$の~fetchingは停止された。
◎
A network error of some description caused the user agent to stop fetching the media resource, after the resource was established to be usable.
</dd>

	<dt>`MEDIA_ERR_DECODE@mE （数-値 3 ）</dt>
	<dd>
資源は利用-可能であると確立された後、`~media資源$を復号する際に，何らかの~errorが生じた。
◎
An error of some description occurred while decoding the media resource, after the resource was established to be usable.
</dd>

	<dt>`MEDIA_ERR_SRC_NOT_SUPPORTED@mE （数-値 4 ）</dt>
	<dd>
［
`src$aM 属性 ／ `アテガわれている~media提供元~obj$
］により指示された`~media資源$は、相応しくなかった。
◎
The media resource indicated by the src attribute or assigned media provider object was not suitable.
</dd>
</dl>

<div class="algo">
<p>
`新たな~MediaError@
を作成するときは、所与の
( 上に挙げたいずれかの値をとる~error~code %~code )
に対し，次のように設定された新たな `MediaError$I ~objを返す：
◎
To create a MediaError, given an error code which is one of the above values, return a new MediaError object
</p>

<ul>
	<li>
`~code$ ~SET %~code
◎
whose code is the given error code and＼
</li>
	<li>
<p>
`~message$ ~SET 当の~error条件を生じさせたものについて~UAが給せる詳細が［
あれば それを表す文字列 ／
なければ 空~文字列
］
◎
whose message is a string containing any details the user agent is able to supply about the cause of the error condition, or the empty string if the user agent is unable to supply such details.＼
</p>

<p>
この文字列は、 %~code を介してすでに可用な情報を超えるものがない場合は，空~文字列になるモノトスル
— 例えば、単純に~codeを文字列に翻訳した結果にはしないモノトスル。
◎
This message string must not contain only the information already available via the supplied error code; for example, it must not simply be a translation of the code into a string format. If no additional information is available beyond that provided by the error code, the message must be set to the empty string.
</p>
	</li>
</ul>
</div>


<div class="algo">
`code@mE
取得子~手続きは
⇒
~RET コレの`~code$
◎
The code getter steps are to return this's code.
</div>

<div class="algo">
`message@mE
取得子~手続きは
⇒
~RET コレの`~message$
◎
The message getter steps are to return this's message.
</div>

				</section>
				<section id="location-of-the-media-resource">
<h5 title="Location of the media resource">4.8.12.2. ~media資源の所在</h5>

<p>
`~media要素$の
`src@aM
内容~属性は、利用者に示す~media資源（動画や音声）の`~URL$を与える。
指定する値は、`前後~空白~可の妥当かつ空でない~URL$を包含しなければナラナイ。
◎
The src content attribute on media elements gives the URL of the media resource (video, audio) to show. The attribute, if present, must contain a valid non-empty URL potentially surrounded by spaces.
</p>

<p>
`~media要素$が `itemprop$a 属性を有する場合、 `src$aM 属性も指定しなければナラナイ。
◎
If the itemprop attribute is specified on the media element, then the src attribute must also be specified.
</p>

<p>
`~media要素$の
`crossorigin@aM
内容~属性は`~CORS設定群~属性$である。
◎
The crossorigin content attribute on media elements is a CORS settings attribute.
</p>

<div class="algo">
<p>
`~media要素$ %要素 の `src$aM 属性に対しては、~UAは：
◎
↓</p>

<ul>
	<li id="concept-media-load-algorithm-at-creation">
%要素 の作成-時に，
%要素 は `src$aM 属性を有していた場合、`即時$に次を呼出すモノトスル
⇒
%要素 の`資源~選定~algo$
◎
If a media element is created with a src attribute, the user agent must immediately invoke the media element's resource selection algorithm.
</li>
	<li>
<p>
%要素 の `src$aM 属性が［
設定-／変更-
］されたときは、次を呼出すモノトスル
⇒
`~media要素~読込n~algo$( %要素 )
◎
If a src attribute of a media element is set or changed, the user agent must invoke the media element's media element load algorithm.＼
</p>

<p>
（ `src$aM 属性が`除去された^emときは、これは行わない
— 子に `source$e 要素が在っても。）
◎
(Removing the src attribute does not do this, even if there are source elements present.)
</p>
	</li>
</ul>
</div>

<p>
`src@mM
~IDL属性は、
`src$aM 内容~属性を`反映する$モノトスル。
◎
The src IDL attribute on media elements must reflect the content attribute of the same name.
</p>

<p>
`crossOrigin@mM
~IDL属性は、`既知な値のみに制限され$る下で，
`crossorigin$aM 内容~属性を`反映する$モノトスル。
◎
The crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.
</p>

<p>
`~media提供元~obj@
は、`~URL$とは別々に`~media資源$を表現できる~objである。
［
`MediaStream$I ／ `MediaSource$I ／ `Blob$I 
］~objは、`~media提供元~obj$である。
◎
A media provider object is an object that can represent a media resource, separate from a URL. MediaStream objects, MediaSource objects, and Blob objects are all media provider objects.
</p>

<p>
各`~media要素$に
`アテガわれている~media提供元~obj@
は、要素にアテガわれ得る`~media提供元~obj$であり，なければ ε とする。
`~media要素$の作成-時には ε とする。
◎
Each media element can have an assigned media provider object, which is a media provider object. When a media element is created, it has no assigned media provider object.
</p>

<dl class="domintro">
	<dt>%media.`srcObject$mM [ = %source ]</dt>
	<dd>
`~media要素$に`~media提供元~obj$をアテガえるようにする。
◎
Allows the media element to be assigned a media provider object.
</dd>

	<dt>%media.`currentSrc$mM</dt>
	<dd>
［［
現在の`~media資源$はある
］~AND［
その`~URL$はある
］ならば それ ／
~ELSE_ 空~文字列
］を返す。
◎
Returns the URL of the current media resource, if any.
◎
Returns the empty string when there is no media resource, or it doesn't have a URL.
</dd>
</dl>

<p>
`currentSrc@mM
~IDL属性は、初期~時には空~文字列になるモノトスル。
その値は、下に定義される`資源~選定~algo$により変更される。
◎
The currentSrc IDL attribute must initially be set to the empty string. Its value is changed by the resource selection algorithm defined below.
</p>

<div class="algo">
`srcObject@mM
取得子~手続きは
⇒
~RET ［
コレに`アテガわれている~media提供元~obj$ ~NEQ ε ならば それ ／
~ELSE_ ~NULL
］
◎
The srcObject IDL attribute, on getting, must return the element's assigned media provider object, if any, or null otherwise.＼
</div>

<div class="algo">
<p>
`srcObject$mM 設定子~手続きは：
◎
On setting,＼
</p>
<ol>
	<li>
コレに`アテガわれている~media提供元~obj$ ~SET 所与の値
◎
it must set the element's assigned media provider object to the new value, and then＼
</li>
	<li>
`~media要素~読込n~algo$( コレ )
◎
invoke the element's media element load algorithm.
</li>
</ol>
</div>

<p class="note">注記：
`~media資源$を指定する仕方には、~~優先される順に［
`srcObject$mM ~IDL属性,
`src$aM 内容~属性,
`source$e 要素
］がある。
◎
There are three ways to specify a media resource: the srcObject IDL attribute, the src content attribute, and source elements. The IDL attribute takes priority, followed by the content attribute, followed by the elements.
</p>

				</section>
				<section id="mime-types">
<h5 title="MIME types">4.8.12.3. ~MIME型</h5>

<p>
`~media資源$は、その`型^em
— 特定的には、`~MIME型$, および 事例によっては ~codecs ~parameter —
を通して記述され得る。
（ ~codecs ~parameterが許容されるかどうかは、~MIME型に依存する。）
`RFC6381$r
◎
A media resource can be described in terms of its type, specifically a MIME type, in some cases with a codecs parameter. (Whether the codecs parameter is allowed or not depends on the MIME type.) [RFC6381]
</p>

<p>
型は、通例的にはいくぶん不完全な記述である。
例えば `video/mpeg^l は、容器の型が何であるかを除き，何も言わない。
`video/mp4; codecs="avc1.42E01E, mp4a.40.2"^l
の様な型でも，実際の~bitrateの様な情報は含まない（含むのは最大~bitrateのみ）。
したがって~UAは、所与の型に対し その型の~mediaが再生-可能かどうかについては，［
（様々な確度で）`できるかもしれない^emか，確定的に`できない^emか
］しか知り得ないことが多い。
◎
Types are usually somewhat incomplete descriptions; for example "video/mpeg" doesn't say anything except what the container type is, and even a type like "video/mp4; codecs="avc1.42E01E, mp4a.40.2"" doesn't include information like the actual bitrate (only the maximum bitrate). Thus, given a type, a user agent can often only know whether it might be able to play media of that type (with varying levels of confidence), or whether it definitely cannot play media of that type.
</p>

<p>
~UAが資源を確定的に~supportしない型は、
`~UAが具現化できないと知る型@
とされる
— 例えば、認識できない容器~型や，~supportしない~codecが挙げられている型など。
◎
A type that the user agent knows it cannot render is one that describes a resource that the user agent definitely does not support, for example because it doesn't recognize the container type, or it doesn't support the listed codecs.
</p>

<p>
~parameterを伴わない`~MIME型$
`application/octet-stream$mt
は、常に`~UAが具現化できないと知る型$になる。
`~media資源$になり得るものに この型が付与されているときは、［
明示的な`~Content-Type~metadata$
］を欠くものと等価に扱うモノトスル。
◎
The MIME type "application/octet-stream" with no parameters is never a type that the user agent knows it cannot render. User agents must treat that type as equivalent to the lack of any explicit Content-Type metadata when it is used to label a potential media resource.
</p>

<p class="note">注記：
ここでは、~parameterを伴わない `~MIME型$
`application/octet-stream$mt
のみが特別に扱われる
— ~parameterが現れる場合、他の`~MIME型$と同様に扱われることになる。
これは、［
未知な `~MIME型$ ~parameterは無視されるベキである
］とする規則からの逸脱である。
◎
Only the MIME type "application/octet-stream" with no parameters is special-cased here; if any parameter appears with it, it will be treated just like any other MIME type. This is a deviation from the rule that unknown MIME type parameters should be ignored.
</p>

<dl class="domintro">
	<dt>%media.`canPlayType(type)$mM</dt>
	<dd>
~UAが所与の型の~media資源を再生できる確度に基づいて，［
空~文字列（否定的~応答）,
`maybe^l,
`probably^l
］のいずれかを返す。
◎
Returns the empty string (a negative response), "maybe", or "probably" based on how confident the user agent is that it can play media resources of the given type.
</dd>
</dl>

<div class="algo">
<p>
`canPlayType(type)@mM
~method~手続きは：
◎
The canPlayType(type) method must return＼
</p>
<ol>
	<li>
~IF［
%type は`~UAが具現化できないと知る型$である
］~OR［
%型 ~EQ `application/octet-stream$mt
］
⇒
~RET `空~文字列@cP
◎
the empty string if type is a type that the user agent knows it cannot render or is the type "application/octet-stream";＼
</li>
	<li>
~IF［
~UAは、 %type が表現する`~media資源$がコレに利用されたなら，~~十分な確度で具現化できる
］
⇒
~RET
`probably@l
◎
it must return "probably" if the user agent is confident that the type represents a media resource that it can render if used in with this audio or video element; and＼
</li>
	<li>
~RET
`maybe@l
◎
it must return "maybe" otherwise.＼
</li>
</ol>

<p>
実装者には、
%type を~supportしないか~supportする~~十分な確度がない限り，
`maybe$l を返すことが奨励される。
一般に，~UAは、 ~codecs ~parameterを許容する型に対しては，その~parameterが無い場合は 決して `probably$l を返すベキでない。
◎
Implementers are encouraged to return "maybe" unless the type can be confidently established as being supported or not. Generally, a user agent should never return "probably" for a type that allows the codecs parameter if that parameter is not present.
</p>
</div>

<div class="example">
<p>
次の~scriptは、~UAは（架空の）新たな形式を~supportするかどうか~testして，
`video$e 要素か~pluginのどちらを利用するか動的に裁定する：
◎
This script tests to see if the user agent supports a (fictional) new format to dynamically decide whether to use a video element or a plugin:
</p>

<pre class="lang-html">
&lt;section id="video"&gt;
 &lt;p&gt;&lt;a href="playing-cats.nfv"&gt;動画を~downloadする&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;script&gt;
 var %videoSection = document.getElementById('video');
 var %videoElement = document.createElement('video');
 var %support = videoElement.canPlayType('video/x-new-fictional-format;codecs="kittens,bunnies"');
 if (%support != "probably" &amp;&amp; "New Fictional Video Plugin" in navigator.plugins) {
   /* <span class="comment">
~browserが~supportする~~十分な確度はないが、~pluginがあるので代わりにそれを利用する
◎
not confident of browser support but we have a plugin so use plugin instead
</span> */
   %videoElement = document.createElement("embed");
 } else if (%support == "") {
   /* <span class="comment">
~browserからは~supportされず，~pluginもないので、何もしない
◎
no support from browser and no plugin — do nothing
</span> */
   %videoElement = null;
 }
 if (%videoElement) {
   while (%videoSection.hasChildNodes())
     %videoSection.removeChild(%videoSection.firstChild);
   %videoElement.setAttribute("src", "playing-cats.nfv");
   %videoSection.appendChild(%videoElement);
 }
&lt;/script&gt;
</pre>

</div>

<p class="note">注記：
`source$e 要素の `type$aS 属性を用いれば、~UAが具現化できない形式を利用している資源に対しては，~downloadを避けれるようになる。
◎
The type attribute of the source element allows the user agent to avoid downloading resources that use formats it cannot render.
</p>

				</section>
				<section id="network-states">
<h5 title="Network states">4.8.12.4. ~network状態</h5>

<dl class="domintro">

	<dt>%media.`networkState$mM</dt>
	<dd>
要素~用の~network活動についての現在の状態を，下に挙げるいずれかの~codeとして返す。
◎
Returns the current state of network activity for the element, from the codes in the list below.
</dd>
</dl>

<p>
`~media要素$は、~networkとヤリトリする。
その現在の~network活動は
`networkState$mM 属性で表現される。
◎
As media elements interact with the network, their current network activity is represented by the networkState attribute.＼
</p>

<p>
`networkState@mM
取得子は、コレの現在の~network状態を，次のいずれか値として返す：
◎
On getting, it must return the current network state of the element, which must be one of the following values:
</p>
<dl class="def-list">
	<dt>`NETWORK_EMPTY@mM （数-値 0 ）</dt>
	<dd>
コレはまだ初期化されていない。
すべての属性は、それぞれの初期~状態にある。
◎
The element has not yet been initialized. All attributes are in their initial states.
</dd>

	<dt>`NETWORK_IDLE@mM （数-値 1 ）</dt>
	<dd>
コレの`資源~選定~algo$は作動中にあり，`~media資源$を選択したが、現時点では，実際には~networkを利用していない。
◎
The element's resource selection algorithm is active and has selected a resource, but it is not actually using the network at this time.
</dd>

	<dt>`NETWORK_LOADING@mM （数-値 2 ）</dt>
	<dd>
~UAは能動的に~dataを~downloadしようと試行している。
◎
The user agent is actively trying to download data.
</dd>

	<dt>`NETWORK_NO_SOURCE@mM （数-値 3 ）</dt>
	<dd>
コレの`資源~選定~algo$は作動中にあるが、利用する`~media資源$はまだ見出されてない。
◎
The element's resource selection algorithm is active, but it has not yet found a resource to use.
</dd>
</dl>

<p>
`networkState$mM 属性の値がいつ変化するか，および
どの~eventを発火して その状態~変化を指示するかは、下に定義される`資源~選定~algo$にて正確に述べる。
◎
The resource selection algorithm defined below describes exactly when the networkState attribute changes value and what events fire to indicate changes in this state.
</p>

				</section>
				<section id="loading-the-media-resource">
<h5 title="Loading the media resource">4.8.12.5. ~media資源の読込n法</h5>

<dl class="domintro">

	<dt>%media.`load()$mM</dt>
	<dd>
この`~media要素$を設定し直して、白紙状態から，新たな`~media資源$を選択して読込nを開始させる。
◎
Causes the element to reset and start selecting and loading a new media resource from scratch.
</dd>
</dl>

<div class="p">
<p>
各`~media要素$は、次に挙げるものを持つ：
</p>
<dl class="def-list">
	<dt>`自動再生~可能か@</dt>
	<dd>
真偽値
— 初期~時は ~T とする。
</dd>

	<dt>`~load~event遅延-中か@</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
~T をとる間は、要素は，その文書の`~load~eventを遅延-$するモノトスル。
</dd>
	<dd>
（ ~T から ~F に変化したときは、要素は`~load~eventを遅延-$するのをやめることになる。
~F から ~T に変化したときは、まだ発火されていなければ，要素は`~load~eventを遅延-$することになる。）
</dd>
</dl>
◎
All media elements have a can autoplay flag, which must begin in the true state, and a delaying-the-load-event flag, which must begin in the false state. While the delaying-the-load-event flag is true, the element must delay the load event of its document.
</div>

<div class="algo">
`load()@mM
~method~手続きは
⇒
`~media要素~読込n~algo$( コレ )
◎
When the load() method on a media element is invoked, the user agent must run the media element load algorithm.
</div>

<div class="algo">
<p>
`~media要素~読込n~algo@
は、所与の
( `~media要素$ %要素 )
に対し，次を走らす：
◎
The media element load algorithm consists of the following steps.
</p>

<ol>
	<li>
%要素 用にすでに走らせている`資源~選定~algo$の~instanceがあれば，それを中止する
◎
Abort any already-running instance of the resource selection algorithm for this element.
</li>
	<li>
%処理待ち~taskたち ~LET［
ある`~task~queue$内の， %要素 の`~media要素~event~task源$から~queueされた`~task$
］すべてからなる，~queueされた順による~list
◎
Let pending tasks be a list of all tasks from the media element's media element event task source in one of the task queues.
◎
↓</li>
	<li>
%処理待ち~taskたち を成す
~EACH( %~task )
に対し
⇒
~IF［
%~task は［［
`再生待ち~promiseたちを解決する$ ／ `再生待ち~promiseたちを却下する$
］ものである
］
⇒
それらの~promiseたちを即時に［
解決-／却下-
］する
◎
For each task in pending tasks that would resolve pending play promises or reject pending play promises, immediately resolve or reject those promises in the order the corresponding tasks were queued.
</li>
	<li>
<p>
%処理待ち~taskたち を成す
~EACH( %~task )
に対し
⇒
%~task をその`~task~queue$から除去する
◎
Remove each task in pending tasks from its task queue
</p>

<p class="note">注記：
基本的に，~media要素が新たな資源の読込ngを開始したときは、処理待ち~eventや~callbackは破棄され，［
解決-／却下-
］待ちの~promiseたちは即時に［
解決-／却下-
］される。
◎
Basically, pending events and callbacks are discarded and promises in-flight to be resolved/rejected are resolved/rejected immediately when the media element starts loading a new resource.
</p>
	</li>
	<li>
~IF［
%要素 の `networkState$mM ~IN {
`NETWORK_LOADING$mM, `NETWORK_IDLE$mM
}
］
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `abort$et )
◎
If the media element's networkState is set to NETWORK_LOADING or NETWORK_IDLE, queue a media element task given the media element to fire an event named abort at the media element.
</li>
	<li>
<p>
~IF［
%要素 の`networkState$mM ~NEQ `NETWORK_EMPTY$mM
］：
◎
If the media element's networkState is not set to NETWORK_EMPTY, then:
</p>

	<ol>
			<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `emptied$et )
◎
Queue a media element task given the media element to fire an event named emptied at the media element.
</li>
			<li>
~IF［
%要素 用に進捗-中にある~fetchingがある
］
⇒
~UAはそれを停止するベキである
◎
If a fetching process is in progress for the media element, the user agent should stop it.
</li>
			<li>
~IF［
%要素 に`アテガわれている~media提供元~obj$は `MediaSource$I ~objである
］
⇒
それを`~detach$する
◎
If the media element's assigned media provider object is a MediaSource object, then detach it.
</li>
			<li>
`~media資源に特有な~trackを忘れる$( %要素 )
◎
Forget the media element's media-resource-specific tracks.
</li>
			<li>
`readyState$mM ~SET `HAVE_NOTHING$mM
◎
If readyState is not set to HAVE_NOTHING, then set it to that state.
</li>
			<li>
<p>
~IF［
%要素 の `paused$mM 属性 ~EQ ~F
］：
◎
If the paused attribute is false, then:
</p>
				<ol>
					<li>
%要素 の `paused$mM 属性 ~SET ~T
◎
Set the paused attribute to true.
</li>
					<li>
`再生待ち~promiseたちを却下する$( %要素 の`再生待ち~promiseたちを取り出す$, `AbortError$E 例外 )
◎
Take pending play promises and reject pending play promises with the result and an "AbortError" DOMException.
</li>
				</ol>
			</li>
			<li>
~IF［
`seeking$mM ~EQ ~T
］
⇒
`seeking$mM ~SET ~F
◎
If seeking is true, set it to false.
</li>
			<li>
%要素 の`現在の再生~位置$ ~SET 0
◎
Set the current playback position to 0.
</li>
			<li>
%前~位置 ~LET %要素 の`公式的な再生~位置$
◎
↓</li>
			<li>
%要素 の`公式的な再生~位置$ ~SET 0
◎
Set the official playback position to 0.
</li>
			<li>
~IF［
%前~位置 ~NEQ 0
］
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `timeupdate$et )
◎
If this changed the official playback position, then queue a media element task given the media element to fire an event named timeupdate at the media element.
</li>
			<li>
`時列線~offset$ ~SET `NaN^jv
◎
Set the timeline offset to Not-a-Number (NaN).
</li>
			<li>
<p>
%要素 の `duration$mM 属性 ~SET `NaN^jv
◎
Update the duration attribute to Not-a-Number (NaN).
</p>

<p class="note">注記：
~UAは、この段による時間長の変化に対しては，
`durationchange$et ~eventは
<a href="#durationChange">発火しない</a>
ことになる。
◎
The user agent will not fire a durationchange event for this particular change of the duration.
</p>
			</li>
		</ol>
	</li>
	<li>
%要素 の `playbackRate$mM 属性 ~SET %要素 の `defaultPlaybackRate$mM 属性の値
◎
Set the playbackRate attribute to the value of the defaultPlaybackRate attribute.
</li>
	<li>
%要素 の `error$mM 属性  ~SET ~NULL
◎
Set the error attribute to null＼
</li>
	<li>
%要素 の `自動再生~可能か$ ~SET ~T
◎
and the can autoplay flag to true.
</li>
	<li>
<p>
%要素 の`資源~選定~algo$を呼出す
◎
Invoke the media element's resource selection algorithm.
</p>

<p class="note">注記：
以前に %要素 用に再生していた`~media資源$があれば，この時点で停止する。
◎
Playback of any previously playing media resource for this element stops.
</p>
	</li>
</ol>
</div>

<div class="algo">
<div class="p">
<p>
`~media要素$ %要素 の
`資源~選定~algo@
は、次に従う
— この~algoは：
</p>

<ul>
	<li>
常に`~task$の一部として呼出され、`並列的$に実行される。
</li>
	<li>
いくつかの`同期区間$があり，`~event~loop$の仕組みと~~緊密にヤリトリする（同期区間は、`~event~loop$~algoの一部として誘発される）。
同期区間は、記号 ⌛ が付与された段で（または，付与せずに下位手続きとして）指示され，
“以降は `並列的$に継続する”
と記された段に達した所で終える（ ~GOTO では終えないことに注意）。
</li>
	<li>
この~algoは、通常通り ~RET する代わりに［
自身, または
それが呼出す`~media資源~fetch~algo$, または
それにより~queueされる~task
］により中止されることもある。
そのような箇所は、
“資源~選定~algoを
`中止-@
する”
という句で指示される。
また、一部の事例では，（~event~loopが滅するまで）永遠に走り続ける。
【！ ある~taskがこの~algoを中止する前に~queueされた，別の未処理の~taskがどう取扱われるかは、はっきりしない】
</li>
</ul>

◎
The resource selection algorithm for a media element is as follows. This algorithm is always invoked as part of a task, but one of the first steps in the algorithm is to return and continue running the remaining steps in parallel. In addition, this algorithm interacts closely with the event loop mechanism; in particular, it has synchronous sections (which are triggered as part of the event loop algorithm). Steps in such sections are marked with ⌛.
</div>

<ol>
	<li>
%要素 の `networkState$mM 属性 ~SET `NETWORK_NO_SOURCE$mM
◎
Set the element's networkState attribute to the NETWORK_NO_SOURCE value.
</li>
	<li>
%要素 の`~posterを示すか$ ~SET ~T
◎
Set the element's show poster flag to true.
</li>
	<li>
%要素 の`~load~event遅延-中か$ ~SET ~T
◎
Set the media element's delaying-the-load-event flag to true (this delays the load event).
</li>
	<li>
<p>
以降の記号 ⌛ が付与された段を`同期区間$として、`安定~状態を待受ける$：
◎
Await a stable state, allowing the task that invoked this algorithm to continue. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)
</p>
		<ol>
			<li>⌛
~IF［
%要素 の`構文解析器にて阻まれているか$ ~EQ ~F
］
⇒
`処理待ち~tT~listを拡充する$
◎
⌛ If the media element's blocked-on-parser flag is false, then populate the list of pending text tracks.
</li>
			<li>⌛
%GOTO~label ~LET ε
◎
↓</li>
			<li>⌛
~IF［
%要素 に`アテガわれている~media提供元~obj$ ~NEQ ε
］
⇒
%GOTO~label ~SET `~obj^i
◎
⌛ If the media element has an assigned media provider object, then let mode be object.
</li>
			<li>⌛
~ELIF［
%要素 は `src$aM 属性を有する
］
⇒
%GOTO~label ~SET `属性^i
◎
⌛ Otherwise, if the media element has no assigned media provider object but has a src attribute, then let mode be attribute.
</li>
			<li>⌛
~ELIF［
%要素 の子である `source$e 要素はある
］
⇒
%GOTO~label ~SET `子たち^i
◎
⌛ Otherwise, if the media element does not have an assigned media provider object and does not have a src attribute, but does have a source element child, then let mode be children and let candidate be the first such source element child in tree order.
</li>
			<li>
<p>⌛
~ELSE：
◎
⌛ Otherwise the media element has no assigned media provider object and has neither a src attribute nor a source element child:
</p>
				<ol>
					<li>
%要素 の `networkState$mM ~SET `NETWORK_EMPTY$mM
◎
⌛ Set the networkState to NETWORK_EMPTY.
</li>
					<li>
%要素 の`~load~event遅延-中か$ ~SET ~F
◎
⌛ Set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
					<li>
以降は `並列的$に継続する
◎
End the synchronous section＼
</li>
					<li>
~RET
◎
and return.
</li>
				</ol>
			</li>
			<li>⌛
%要素 の`networkState$mM ~SET `NETWORK_LOADING$mM
◎
⌛ Set the media element's networkState to NETWORK_LOADING.
</li>
			<li>⌛
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `loadstart$et )
◎
⌛ Queue a media element task given the media element to fire an event named loadstart at the media element.
</li>
			<li>⌛
~GOTO %GOTO~label
◎
Run the appropriate steps from the following list:
</li>
		</ol>
	</li>
	<li>
<p>
`~obj^i：
◎
If mode is object
</p>
		<ol>
			<li>⌛
%要素 の `currentSrc$mM 属性 ~SET 空~文字列
◎
⌛ Set the currentSrc attribute to the empty string.
</li>
			<li>
以降は `並列的$に継続する
◎
End the synchronous section, continuing the remaining steps in parallel.
</li>
			<li>
`~media資源~fetch~algo$( %要素, %要素 に`アテガわれている~media提供元~obj$ )
◎
Run the resource fetch algorithm with the assigned media provider object. If that algorithm returns without aborting this one, then the load failed.
</li>
			<li>
~GOTO `失敗^i
◎
↓↓Failed with media provider: Reaching this step indicates that the media resource failed to load. Take pending play promises and queue a media element task given the media element to run the dedicated media source failure steps with the result.
◎
Wait for the task queued by the previous step to have executed.
◎
Return. The element won't attempt to load another resource until this algorithm is triggered again.
</li>
		</ol>
	</li>
	<li>
<p>
`属性^i：
◎
If mode is attribute
</p>
		<ol>
			<li>
<p>⌛
%~URL ~LET 次の下位手続きを走らせた結果：
</p>
				<ol>
					<li>
%src ~LET %要素 の `src$aM 属性の値
◎
↓</li>
					<li>
~IF［
%src ~EQ 空~文字列
］
⇒
~RET ε
◎
⌛ If the src attribute's value is the empty string, then end the synchronous section, and jump down to the failed with attribute step below.
</li>
					<li>
%~URL~record ~LET `相対的に~URL構文解析する$( %src, %要素 の`~node文書$ )
◎
⌛ Let urlString and urlRecord be the resulting URL string and the resulting URL record, respectively, that would have resulted from parsing the URL specified by the src attribute's value relative to the media element's node document when the src attribute was last changed.
</li>
					<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~RET ε
◎
↑</li>
					<li>
%要素 の `currentSrc$mM 属性 ~SET `~URLを直列化する$( %~URL~record )
◎
⌛ If urlString was obtained successfully, set the currentSrc attribute to urlString.
</li>
					<li>
~RET %~URL~record
◎
↑</li>
				</ol>
			</li>
			<li>
以降は `並列的$に継続する
◎
End the synchronous section, continuing the remaining steps in parallel.
</li>
			<li>
~IF［
%~URL ~EQ ε
］
⇒
~GOTO `失敗^i
◎
↓</li>
			<li>
`~media資源~fetch~algo$( %要素, %~URL )
◎
If urlRecord was obtained successfully, run the resource fetch algorithm with urlRecord.＼
</li>
			<li>
~GOTO `失敗^i
◎
If that algorithm returns without aborting this one, then the load failed.
◎
↓</li>
		</ol>
	</li>
	<li>
<p>
`失敗^i ：
◎
Failed with attribute:＼
</p>
		<ol>
			<li>
~Assert：
この`資源~選定~algo$は`中止-$されていない（~media資源の読込nに失敗した、または，`~media資源~fetch~algo$は呼出されなかった）
◎
Reaching this step indicates that the media resource failed to load or that the given URL could not be parsed.＼
</li>
			<li>
%~promise~list ~LET %要素 の`再生待ち~promiseたちを取り出す$
◎
Take pending play promises and＼
</li>
			<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`専用の~media~source失敗~手続き$( %要素, %~promise~list)
を走らす
◎
queue a media element task given the media element to run the dedicated media source failure steps with the result.
</li>
			<li>
前~段により~queueされた`~task$が実行し終えるまで待機する
◎
Wait for the task queued by the previous step to have executed.
</li>
			<li>
~RET
— %要素 は、この~algoが再び誘発されるまで，別の資源を読込もうと試みないことになる。
◎
Return. The element won't attempt to load another resource until this algorithm is triggered again.
</li>
		</ol>
	</li>
	<li>
<p>
`子たち^i：
◎
Otherwise (mode is children)
</p>
		<ol>
			<li>
<p>⌛
%~pointer ~LET ~NULL （ “仮想の先頭” を表す）
— この~pointerは：
</p>
				<ul>
					<li>
~NULL でないときは、 %要素 のある子~nodeを保持する。
</li>
					<li>
この手続きが走っている間に
%~pointer （ ~NEQ ~NULL ）が %要素 の子でなくなったときは、
%~pointer は，子でなくなる直前における %~pointer の`前の同胞？$に更新されるとする（ ~NULL にもなり得る）。
</li>
					<li>
以下における，
%~pointer の `次の同胞^i は、［
%~pointer ~NEQ ~NULL ならば %~pointer の`次の同胞？$ ／
~ELSE_ %要素 の`最初の子？$
］を指すとする（ ~NULL にもなり得る）。
</li>
					<li>
<p>
以下において， “次の候補を得る” と記された所では、次の下位手続きを走らせた結果に評価されるとする：
</p>
						<ol>
							<li>
<p>
~WHILE［
%~pointer の`次の同胞^i ~NEQ ~NULL
］：
</p>
								<ol>
									<li>
%~pointer ~SET %~pointer の`次の同胞^i
</li>
									<li>
~IF［
%~pointer は `source$e 要素である
］
⇒
~RET %~pointer
</li>
								</ol>
							</li>
							<li>
~RET ε
</li>
						</ol>
					</li>
				</ul>

◎
⌛ Let pointer be a position defined by two adjacent nodes in the media element's child list, treating the start of the list (before the first child in the list, if any) and end of the list (after the last child in the list, if any) as nodes in their own right. One node is the node before pointer, and the other node is the node after pointer. Initially, let pointer be the position between the candidate node and the next node, if there are any, or the end of the list, if it is the last node.
◎
As nodes are inserted and removed into the media element, pointer must be updated as follows:
◎
If a new node is inserted between the two nodes that define pointer
◎
• Let pointer be the point between the node before pointer and the new node. In other words, insertions at pointer go after pointer.
◎
If the node before pointer is removed
• Let pointer be the point between the node after pointer and the node before the node after pointer. In other words, pointer doesn't move relative to the remaining nodes.
◎
If the node after pointer is removed
• Let pointer be the point between the node before pointer and the node after the node before pointer. Just as with the previous case, pointer doesn't move relative to the remaining nodes.
◎
Other changes don't affect pointer.
</li>
			<li>⌛
%候補 ~LET 次の候補を得る
◎
↑↑</li>
			<li>
<p>⌛
`候補を処理する^i
⇒
%~URL ~LET 次の下位手続きを走らせた結果
</p>
				<ol>
					<li>
%src ~LET この時点で［
%候補 は `src$aS 属性を有していて その値 ~NEQ 空~文字列 ならば その値 ／
~ELSE_ ε
］
◎
↓</li>
					<li>
~IF［
%src ~EQ ε
］
⇒
~RET ε
◎
⌛ Process candidate: If candidate does not have a src attribute, or if its src attribute's value is the empty string, then end the synchronous section, and jump down to the failed with elements step below.
</li>
					<li>
%~URL~record ~LET `相対的に~URL構文解析する$( %src, %候補 の`~node文書$ )
◎
⌛ Let urlString and urlRecord be the resulting URL string and the resulting URL record, respectively, that would have resulted from parsing the URL specified by candidate's src attribute's value relative to the candidate's node document when the src attribute was last changed.
</li>
					<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~RET ε
◎
⌛ If urlString was not obtained successfully, then end the synchronous section, and jump down to the failed with elements step below.
</li>
					<li>
~IF［
%候補 は `type$aS 属性を有する
］~AND［
その値を`~MIME型$として（ ~codecs ~parameterがあれば，それも織り込んだ上で）構文解析した結果は，`~UAが具現化できないと知る型$を表現する
］
⇒
~RET ε
◎
⌛ If candidate has a type attribute whose value, when parsed as a MIME type (including any codecs described by the codecs parameter, for types that define that parameter), represents a type that the user agent knows it cannot render, then end the synchronous section, and jump down to the failed with elements step below.
</li>
					<li>
%要素 の `currentSrc$mM 属性 ~SET `~URLを直列化する$( %~URL~record )
◎
⌛ Set the currentSrc attribute to urlString.
</li>
					<li>
~RET %~URL~record
</li>
				</ol>
			</li>
			<li>
以降は `並列的$に継続する
◎
End the synchronous section, continuing the remaining steps in parallel.
</li>
			<li>
<p>
~IF［
%~URL ~NEQ ε
］：
</p>
				<ol>
					<li>
`~media資源~fetch~algo$( %要素, %~URL )
</li>
					<li>
~Assert：この`資源~選定~algo$は`中止-$されていない
</li>
				</ol>
◎
Run the resource fetch algorithm with urlRecord. If that algorithm returns without aborting this one, then the load failed.
</li>
			<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %候補, `~errorS$et )
◎
Failed with elements: Queue a media element task given the media element to fire an event named error at candidate.
</li>
			<li>
以降を`同期区間$として，`安定~状態を待受ける$
◎
Await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)
</li>
			<li>⌛
`~media資源に特有な~trackを忘れる$( %要素 )
◎
⌛ Forget the media element's media-resource-specific tracks.
</li>
			<li>⌛
`次の候補を見出す^i
⇒
%候補 ~SET 次の候補を得る
◎
⌛ Find next candidate: Let candidate be null.
◎
⌛ Search loop: If the node after pointer is the end of the list, then jump to the waiting step below.
◎
⌛ If the node after pointer is a source element, let candidate be that element.
◎
⌛ Advance pointer so that the node before pointer is now the node that was after pointer, and the node after pointer is the node after the node that used to be after pointer, if any.
◎
⌛ If candidate is null, jump back to the search loop step. Otherwise, jump back to the process candidate step.
</li>
			<li>⌛
~IF［
%候補 ~NEQ ε
］
⇒
~GOTO `候補を処理する^i
◎
↑</li>
			<li>⌛
%要素 の`networkState$mM 属性 ~SET `NETWORK_NO_SOURCE$mM
◎
⌛ Waiting: Set the element's networkState attribute to the NETWORK_NO_SOURCE value.
</li>
			<li>⌛
%要素 の`~posterを示すか$ ~SET ~T
◎
⌛ Set the element's show poster flag to true.
</li>
			<li>⌛
次を走らす`~media~taskを~queueする$( %要素 )
⇒
%要素 の`~load~event遅延-中か$ ~SET ~F
◎
⌛ Queue a media element task given the media element to set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
			<li>
以降は `並列的$に継続する
◎
End the synchronous section, continuing the remaining steps in parallel.
</li>
			<li>
［
%~pointer の`次の同胞^i ~NEQ ~NULL
］になるまで待機する（この段は永遠に待機するかもしれない）
◎
Wait until the node after pointer is a node other than the end of the list. (This step might wait forever.)
</li>
			<li>
以降を`同期区間$として，`安定~状態を待受ける$
◎
Await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)
</li>
			<li>⌛
%要素 の`~load~event遅延-中か$ ~SET ~T
◎
⌛ Set the element's delaying-the-load-event flag back to true (this delays the load event again, in case it hasn't been fired yet).
</li>
			<li>⌛
`networkState$mM ~SET `NETWORK_LOADING$mM
◎
⌛ Set the networkState back to NETWORK_LOADING.
</li>
			<li>⌛
~GOTO `次の候補を見出す^i
◎
⌛ Jump back to the find next candidate step above.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`専用の~media~source失敗~手続き@
は、所与の
( `~media要素$ %要素, ~promise~list %~promise~list )
に対し，次を走らす：
◎
The dedicated media source failure steps with a list of promises promises are the following steps:
</p>

<ol>
	<li>
%要素 の `error$mM 属性 ~SET `新たな~MediaError$( `MEDIA_ERR_SRC_NOT_SUPPORTED$mE )
◎
Set the error attribute to the result of creating a MediaError with MEDIA_ERR_SRC_NOT_SUPPORTED.
</li>
	<li>
`~media資源に特有な~trackを忘れる$( %要素 )
◎
Forget the media element's media-resource-specific tracks.
</li>
	<li>
%要素 の `networkState$mM 属性 ~SET `NETWORK_NO_SOURCE$mM
◎
Set the element's networkState attribute to the NETWORK_NO_SOURCE value.
</li>
	<li>
%要素 の`~posterを示すか$ ~SET ~T
◎
Set the element's show poster flag to true.
</li>
	<li>
`~eventを発火する$( %要素, `~errorM$et )
◎
Fire an event named error at the media element.
</li>
	<li>
`再生待ち~promiseたちを却下する$( %~promise~list, `NotSupportedError$E 例外 )
◎
Reject pending play promises with promises and a "NotSupportedError" DOMException.
</li>
	<li>
%要素 の`~load~event遅延-中か$ ~SET ~F
◎
Set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
</ol>
</div>

<div class="algo">
<p>
`~media資源~fetch~algo@
は、所与の
( `~media要素$ %要素, ［
`~URL$ ／ `~media提供元~obj$
］ %入力 )
に対し，次を走らす：
◎
The resource fetch algorithm for a media element and a given URL record or media provider object is as follows:
</p>

<ol>
	<li>
( %~URL, %~media提供元~obj, %現~media資源 ) ~LET ( ε, ~NULL, ε )
◎
↓</li>
	<li>
<p>
%入力 に応じて：
</p>
		<ul class="switch">
			<li>
`~media提供元~obj$である
⇒
%~media提供元~obj ~SET %入力
</li>
			<li>
<p>
`~URL$である：
</p>
				<ol>
					<li>
%~URL ~SET %入力
</li>
					<li>
%~media提供元~obj ~SET %~URL の`~blob~URL~entry$url
</li>
					<li>
~IF［
%~media提供元~obj は`~media提供元~obj$でない
］
⇒＃
%~media提供元~obj ~SET ~NULL；
%現~media資源 ~SET %~URL から得られることになる資源
</li>
				</ol>
			</li>
		</ul>
◎
If the algorithm was invoked with media provider object or a URL record whose blob URL entry is a blob URL entry whose object is a media provider object, then let mode be local. Otherwise let mode be remote.
◎
If mode is remote, then let the current media resource be the resource given by the URL record passed to this algorithm;＼
</li>
	<li>
~IF［
%~media提供元~obj ~NEQ ~NULL
］
⇒
%現~media資源 ~SET %~media提供元~obj が与える資源
◎
otherwise, let the current media resource be the resource given by the media provider object.＼
</li>
	<li>
%要素 の`~media資源$ ~SET %現~media資源
◎
Either way, the current media resource is now the element's media resource.
</li>
	<li>
%要素 の`処理待ち~tT~list$から
`~media資源に特有な~tT$をすべて除去する
◎
Remove all media-resource-specific text tracks from the media element's list of pending text tracks, if any.
</li>
	<li>
<p>
~IF［
%~media提供元~obj ~EQ ~NULL
］：
◎
Run the appropriate steps from the following list:
◎
If mode is remote
</p>
		<ol>
			<li>
<p>
任意選択で、次の下位手続きを走らす
— これは［
利用者から明示的に要請されるまで，~UAは資源を~fetchしようと試みない
］ことを意図する場合に期待される挙動になる（例：
`preload$aM 属性の `none$v ~keywordを実装する仕方として）：
◎
Optionally, run the following substeps. This is the expected behavior if the user agent intends to not attempt to fetch the resource until the user requests it explicitly (e.g. as a way to implement the preload attribute's none keyword).
</p>

				<ol>
					<li>
%要素 の `networkState$mM ~SET `NETWORK_IDLE$mM
◎
Set the networkState to NETWORK_IDLE.
</li>
					<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `suspend$et )
◎
Queue a media element task given the media element to fire an event named suspend at the element.
</li>
					<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
%要素 の`~load~event遅延-中か$ ~SET ~F
◎
Queue a media element task given the media element to set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
					<li>
前~段の~taskが走るまで待機する
◎
Wait for the task to be run.
</li>
					<li>
`実装定義$な~eventを待機する（例：利用者は %要素 の再生を始めるよう要請している。）
◎
Wait for an implementation-defined event (e.g., the user requesting that the media element begin playback).
</li>
					<li>
%要素 の`~load~event遅延-中か$ ~SET ~T
◎
Set the element's delaying-the-load-event flag back to true (this delays the load event again, in case it hasn't been fired yet).
</li>
					<li>
%要素 の `networkState$mM ~SET `NETWORK_LOADING$mM
◎
Set the networkState to NETWORK_LOADING.
</li>
				</ol>
			</li>
			<li>
%行先 ~LET %要素 に応じて
⇒
`audio$e 要素であるならば `audio^l ／
`video$e 要素であるならば `video^l
◎
Let destination be "audio" if the media element is an audio element and to "video" otherwise.
</li>
			<li>
%要請 ~LET
`~CORSになり得る要請を作成する$( %~URL, %行先, %要素 の`crossorigin$aM 内容~属性の値 )
◎
Let request be the result of creating a potential-CORS request given current media resource's URL record, destination, and the media element's crossorigin content attribute value.
</li>
			<li>
%要請 の`~client$rq ~SET  %要素 の`~node文書$に`関連な設定群~obj$
◎
Set request's client to the media element's node document's relevant settings object.
</li>
			<li>
<p>
%要請 を`~fetch$する
◎
Fetch request.
</p>

<p>
このようにして得された応答の`非安全~応答$があれば、それが`~media~data$を包含する。
それは、［
`~CORS同一-生成元$, `~CORS非同一-生成元$
］のいずれにもなり得る
— それに応じて、次に影響する：
◎
The response's unsafe response obtained in this fashion, if any, contains the media data. It can be CORS-same-origin or CORS-cross-origin; this affects＼
</p>

				<ul>
					<li>
`~media~data$内で参照された字幕は~APIに公開されるかどうか。
◎
whether subtitles referenced in the media data are exposed in the API and,＼
</li>
					<li>
`video$e 要素に対しては、動画が `canvas$e 上に描かれるとき，その `canvas^e は~taintedになるかどうか。
◎
for video elements, whether a canvas gets tainted when the video is drawn on it.
</li>
				</ul>

<p>
`~media要素の停滞-制限時間@
は、`実装定義$な長さの時間であり，およそ 3 秒にするベキである。
所与の時点で %要素 が`~media~data$を得しようと能動的に試みていて，その時点からこの制限時間~内に~dataを受信するのに失敗した場合、次を行うモノトスル
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `stalled$et )
◎
The media element stall timeout is an implementation-defined length of time, which should be about three seconds. When a media element that is actively attempting to obtain media data has failed to receive any data for a duration equal to the media element stall timeout, the user agent must queue a media element task given the media element to fire an event named stalled at the element.
</p>

<p>
~UAは、利用者に［
選択的に阻む ／
`~media~data$の~downloadを低速にする
］ことを許容してヨイ：
◎
User agents may allow users to selectively block or slow media data downloads.＼
</p>
				<ul>
					<li>
%要素 の~downloadがまるごと阻まれたときは
⇒
~UAは，それが停滞したかのように動作するモノトスル（接続が~closeされたかのように動作するのとは~~対照的に）。
◎
When a media element's download has been blocked altogether, the user agent must act as if it was stalled (as opposed to acting as if the connection was closed).＼
</li>
					<li>
~UAは、~downloadの~rateを自動的に減速してもヨイ
— 例えば、同じ帯域幅を共有している他の接続との兼ね合いで。
◎
The rate of the download may also be throttled automatically by the user agent, e.g. to balance the download with other connections sharing the same bandwidth.
</li>
				</ul>

<p id="resourceSuspend">
~UAは、いつでも，資源の~downloadを休止するものと裁定してヨイ
— 例えば，次のいずれかに該当するときなど：
◎
User agents may decide to not download more content at any time, e.g.＼
</p>
				<ul>
					<li>
1 ~~時間の~media資源を 5 分だけ~bufferした後，利用者が資源を再生するかどうか裁定するのを待機している間
【下の注記も見よ】
◎
after buffering five minutes of a one hour media resource, while waiting for the user to decide whether to play the resource or not,＼
</li>
					<li>
利用者が対話的~資源に入力するのを待機している間
◎
while waiting for user input in an interactive resource, or＼
</li>
					<li>
利用者が~pageから~navigateして離れたとき
◎
when the user navigates away from the page.＼
</li>
				</ul>

<p>
資源の~downloadを休止する場合、~UAは，次に従うモノトスル：
◎
＼
</p>
				<ul>
					<li>
<p>
休止-時には、次を走らす`~media~taskを~queueする$( %要素 )：
◎
When a media element's download has been suspended, the user agent must queue a media element task given the media element,＼
</p>
						<ol>
							<li>
%要素 の `networkState$mM 属性 ~SET `NETWORK_IDLE$mM
◎
to set the networkState to NETWORK_IDLE and＼
</li>
							<li>
`~eventを発火する$( %要素, `suspend$et )
◎
fire an event named suspend at the element.＼
</li>
						</ol>
					</li>
					<li>
再開-時には、次を走らす`~media~taskを~queueする$( %要素 )
⇒
%要素 の `networkState$mM 属性 ~SET `NETWORK_LOADING$mM
◎
If and when downloading of the resource resumes, the user agent must queue a media element task given the media element to set the networkState to NETWORK_LOADING.＼
</li>
				</ul>

<p>
休止してから再開するまでの間（これらの~taskを~queueする合間）は、読込nは休止される（なので、上に述べたように， `progress$et ~eventは発火されない）。
◎
Between the queuing of these tasks, the load is suspended (so progress events don't fire, as described above).
</p>

<p class="note">注記：
`autoplay$aM 属性が無い下でも、
`preload$aM 属性は，~buffer量に関して作者が~~適切と~~考えている~hintを供する。
◎
The preload attribute provides a hint regarding how much buffering the author thinks is advisable, even in the absence of the autoplay attribute.
</p>

<p>
~UAは、~downloadを完全に休止するものと裁定した場合は
— 例えば、利用者から再生を開始するよう指示されるまで，以降の内容は~downloadせずに待機する場合 —
次を行うモノトスル
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
%要素 の`~load~event遅延-中か$ ~SET ~F
◎
When a user agent decides to completely suspend a download, e.g., if it is waiting until the user starts playback before downloading any further content, the user agent must queue a media element task given the media element to set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</p>

<p>
~UAは、資源を~fetchするために必要とされる手段を何であれ利用してヨイ（この／他の仕様により課される拘束の中で）
— 例えば［
~network~errorに面したときに~serverへ再接続する ／
~HTTP範囲~検索取得【 `Range^h 】要請を利用する ／
~streaming~protocolに切替える
］など。
~UAが資源は~error含みと見なすのは、それ以上~fetchするのをあきらめた場合に限られるモノトスル。
◎
The user agent may use whatever means necessary to fetch the resource (within the constraints put forward by this and other specifications); for example, reconnecting to the server in the face of network errors, using HTTP range retrieval requests, or switching to a streaming protocol. The user agent must consider a resource erroneous only if it has given up trying to fetch it.
</p>

<p>
`~media資源$の形式を決定するときは、~UAは，`音声や動画を特定的に~sniffするための規則$を利用するモノトスル。
◎
To determine the format of the media resource, the user agent must use the rules for sniffing audio and video specifically.
</p>

<p>
読込nが休止されていない間は（下を見よ）、~UAは：
◎
While the load is not suspended (see below),＼
</p>

				<ul>
					<li>
［
毎 350ms （±200ms）ごと ／ ~byteが受信される度
］のうち，`低頻度^emの方で、次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( 要素, `progress$et )
◎
every 350ms (±200ms) or for every byte received, whichever is least frequent, queue a media element task given the media element to fire an event named progress at the element.
</li>
					<li>
<p>
~fetchされた~dataを処理する`~network用~task源$からの各`~task$は、`即時$に，次を行うモノトスル
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
下に与える`~media~data処理~手続き~list$を走らす
◎
The networking task source tasks to process the data as it is being fetched must each immediately queue a media element task given the media element to run the first appropriate steps from the media data processing steps list below.＼
</p>

<p>
（このためには新たな~taskが利用される
— 下に述べる作業が、`~network用~task源$を利用せずに，適切な`~media要素~event~task源$から生じるようにするため。）
◎
(A new task is used for this so that the work described below occurs relative to the appropriate media element event task source rather than using the networking task source.)
</p>
					</li>
				</ul>

<p>
`~media資源$の~fetchingの一部として，`~network用~task源$から最後の`~task$が`~queueされ$たとき（すなわち，~downloadが完了したとき）は、~UAは次を行うモノトスル：
◎
When the networking task source has queued the last task as part of fetching the media resource (i.e. once the download has completed),＼
</p>
				<ol>
					<li>
<p>
~IF［
当の~fetchingが
— ~media~dataの復号-時も含めて —
~errorなしに完了した
］~AND［
すべての~dataは、~network~accessを要することなく~UAに可用である
］
⇒
この`資源~選定~algo$を`中止-$する
【！GOTO Final step】
◎
if the fetching process completes without errors, including decoding the media data, and if all of the data is available to the user agent without network access, then, the user agent must move on to the final step below.＼
</p>

<p>
これは、決して起こらないかもしれない
— 例：
~web~radioなどの無限~資源を~streamingしているとき ／
資源は ~UAが~dataを~cacheする能より長い場合。
◎
This might never happen, e.g. when streaming an infinite resource such as web radio, or if the resource is longer than the user agent's ability to cache data.
</p>
					</li>
				</ol>

<p>
~UAは、［
`~media資源$の ある部分を得するためには，依然として~networkに~accessする必要があり得る間
］は，この段に留まり続けるモノトスル。
◎
While the user agent might still need network access to obtain parts of the media resource, the user agent must remain on this step.
</p>

<p class="example">
例えば，~UAは、動画の前半を破棄した場合は，この段に留まり続けることになる
— `再生は終止して$いるとしても、利用者には始端へ~seekして戻る~~機会が常にあるので。
事実，この状況において`再生は終止して$いるときは、先に述べたように，~UAは `suspend$et ~eventを発火することになる。
◎
For example, if the user agent has discarded the first half of a video, the user agent will remain at this step even once the playback has ended, because there is always the chance the user will seek back to the start. In fact, in this situation, once playback has ended, the user agent will end up firing a suspend event, as described earlier.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ %~media提供元~obj ~NEQ ~NULL ）：
◎
Otherwise (mode is local)
</p>
		<ul>
			<li>
%現~media資源 により述べられる資源があれば，それが`~media~data$を包含する。
それは`~CORS同一-生成元$である。
◎
The resource described by the current media resource, if any, contains the media data. It is CORS-same-origin.
</li>
			<li>
<p>
~UAは、`~media資源$の形式を次に従って決定するモノトスル：
</p>

<ul><li>%現~media資源 が生の~data~streamである場合（例えば `File$I ~objからの）
⇒
`音声や動画を特定的に~sniffするための規則$を利用する
</li><li>他の場合（~data~streamは予め復号-済みである）
⇒
形式は、関連な仕様により与えられるそれとする
</li></ul>

◎
If the current media resource is a raw data stream (e.g. from a File object), then to determine the format of the media resource, the user agent must use the rules for sniffing audio and video specifically. Otherwise, if the data stream is pre-decoded, then the format is the format given by the relevant specification.
</li>
			<li>
%現~media資源 用に新たな~dataが可用になる度に、次を走らす`~media~taskを~queueする$( %要素 )
⇒
下に与える`~media~data処理~手続き~list$を走らす
◎
Whenever new data for the current media resource becomes available, queue a media element task given the media element to run the first appropriate steps from the media data processing steps list below.
</li>
			<li>
<p>
%現~media資源 は永続的に尽きた時点で（例： `Blob$I のすべての~byteは処理-済みになった）：
◎
When the current media resource is permanently exhausted (e.g. all the bytes of a Blob have been processed),＼
</p>
				<ol>
					<li>
~IF［
復号-時に~errorは生じていない
］
⇒
この`資源~選定~algo$を`中止-$する
【！GOTO Final step】
◎
if there were no decoding errors, then the user agent must move on to the final step below.＼
</li>
				</ol>
<p>
これは、決して起こらないかもしれない
— 例えば %現~media資源 は `MediaStream$I である場合。
◎
This might never happen, e.g. if the current media resource is a MediaStream.
</p>

<p class="trans-note">【
復号-時に~errorが生じた場合の記述が無い
— ~RET ？下の`~media~data処理~手続き~list$にて取扱われる？
】</p>
			</li>
		</ul>

<p>
`~media~data処理~手続き~list@
は、次に従うモノトスル：
◎
The media data processing steps list is as follows:
</p>

<dl class="switch">
	<dt>
`~media~data$は，~network~errorに因り全く~fetchできず、~UAは資源を~fetchしようと試行するのをあきらめたときは：
◎
If the media data cannot be fetched at all, due to network errors, causing the user agent to give up trying to fetch the resource
</dt>
	<dt>
`~media~data$は~fetchできたが、全く具現化できないことが~~判明したときは：
◎
If the media data can be fetched but is found by inspection to be in an unsupported format, or can otherwise not be rendered at all
</dt>
	<dd>
<p>
すなわち、次のいずれかに該当する場合：
◎
↓</p>
		<ul>
			<li>
［
~UAが %現~media資源 は利用-可能かどうか確立する前
］に生じた，［
~DNS~error／
~HTTP［
4xx ／ 5xx
］~error（あるいは，他の~protocolにおける等価なもの）／
他の致命的な~network~error
］
◎
DNS errors, HTTP 4xx and 5xx errors (and equivalents in other protocols), and other fatal network errors that occur before the user agent has established whether the current media resource is usable,＼
</li>
			<li>
~fileは ~UAが~supportしない容器~形式を利用している
◎
as well as the file using an unsupported container format, or＼
</li>
			<li>
すべての~dataは、~UAが~supportしない ~codecs ~parameterを利用している
◎
using unsupported codecs for all the data,＼
</li>
		</ul>
	</dd>
	<dd>
<p>
次を実行するモノトスル：
◎
must cause the user agent to execute the following steps:
</p>
		<ol>
			<li>
~fetchingを取消すベキである
◎
The user agent should cancel the fetching process.
</li>
			<li>
この`~media資源~fetch~algo$を終えて、`資源~選定~algo$へ ~RET する
◎
Abort this subalgorithm, returning to the resource selection algorithm.
</li>
		</ol>
	</dd>

	<dt id="found-another-audio-track">
`~media資源$に音声~trackが見出されたときは：
◎
If the media resource is found to have an audio track
</dt>
	<dd>
		<ol>
			<li>
%音声~track ~LET その音声~trackを表現する，新たな `AudioTrack$I ~obj
◎
Create an AudioTrack object to represent the audio track.
</li>
			<li>
%~track~list ~LET %要素 の`audioTracks$mM 属性が与える `AudioTrackList$I ~obj
◎
↓</li>
			<li>
%~track~list を %音声~track で更新する
◎
Update the media element's audioTracks attribute's AudioTrackList object with the new AudioTrack object.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
Let enable be unknown.
</p>
				<ul>
					<li>
<div class="p">
<p>
%音声~track は、次のいずれかに該当する音声~trackである：
</p>
						<ul>
							<li>
［
%現~media資源 ／ %~URL
］が，可能化するよう特に指示している音声~trackたち
</li>
							<li>
~UAが，利用者の体験を改善するために［
特定の音声~trackの選択を手助けするような情報
］を有している下での、それら音声~trackたち
</li>
						</ul>
◎
If either the media resource or the URL of the current media resource indicate a particular set of audio tracks to enable, or if the user agent has information that would facilitate the selection of specific audio tracks to improve the user's experience, then: if this audio track is one of the ones to enable, then set enable to true, otherwise, set enable to false.
</div>

<p class="example">
これは`~media素片の構文$により誘発され得る。
加えて、例えば，~UAが~stereo音声~trackに代えて 5.1 ~surround音響による音声~trackを選択したときも誘発される。
◎
This could be triggered by media fragment syntax, but it could also be triggered e.g. by the user agent selecting a 5.1 surround sound audio track over a stereo audio track.
</p>
					</li>
					<li>
%~track~list 内には `可能化されている音声~track$はまだない
◎
If enable is still unknown, then, if the media element does not yet have an enabled audio track, then set enable to true, otherwise, set enable to false.
</li>
				</ul>
<p>
…ならば
⇒
%音声~track を可能化する
◎
If enable is true, then enable this audio track, otherwise, do not enable this audio track.
</p>
			</li>
			<li>
`~eventを発火する$( %~track~list, `addtrack$et, `TrackEvent$I )
— 次のように初期化して
⇒
`track$m 属性 ~SET %音声~track
◎
Fire an event named addtrack at this AudioTrackList object, using TrackEvent, with the track attribute initialized to the new AudioTrack object.
</li>
		</ol>
	</dd>

	<dt id="found-another-video-track">
`~media資源$に動画~trackが見出されたときは：
◎
If the media resource is found to have a video track
</dt>
	<dd>
		<ol>
			<li>
%動画~track ~LET その動画~trackを表現する，新たな `VideoTrack$I ~obj
◎
Create a VideoTrack object to represent the video track.
</li>
			<li>
%~track~list ~LET %要素 の`videoTracks$mM 属性が与える `VideoTrackList$I ~obj
◎
↓</li>
			<li>
%~track~list を %動画~track で更新する
◎
Update the media element's videoTracks attribute's VideoTrackList object with the new VideoTrack object.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
Let enable be unknown.
</p>
				<ul>
					<li>
<div class="p">
<p>
%動画~track は、次のいずれかに該当する動画~trackのうち最初のものである：
</p>
						<ul>
							<li>
［
%現~media資源 ／ %~URL
］が，可能化するよう特に指示している動画~trackたち
</li>
							<li>
~UAが，利用者の体験を改善するために［
特定の動画~trackの選択を手助けするような情報
］を有している下での、それら動画~trackたち
</li>
						</ul>
◎
If either the media resource or the URL of the current media resource indicate a particular set of video tracks to enable, or if the user agent has information that would facilitate the selection of specific video tracks to improve the user's experience, then: if this video track is the first such video track, then set enable to true, otherwise, set enable to false.
</div>

<p class="example">
これもまた`~media素片の構文$により誘発され得る。
◎
This could again be triggered by media fragment syntax.
</p>
					</li>
					<li>
%~track~list 内には `選択されている動画~track$はまだない
◎
If enable is still unknown, then, if the media element does not yet have a selected video track, then set enable to true, otherwise, set enable to false.
</li>
				</ul>
<p>
…ならば：
◎
If enable is true, then＼
</p>
				<ol>
					<li>
~IF［
すでに選択されている動画~trackはある
］
⇒
それを未選択にする
— この場合、<a href="#toggle-video-track">`change^et ~eventが発火されることになる</a>。
◎
select this track and unselect any previously selected video tracks, otherwise, do not select this video track. If other tracks are unselected, then a change event will be fired.
</li>
					<li>
%動画~track を選択する
◎
↑</li>
				</ol>
			</li>
			<li>
`~eventを発火する$( %~track~list, `addtrack$et, `TrackEvent$I )
— 次のように初期化して
⇒
`track$m 属性 ~SET %動画~track
◎
Fire an event named addtrack at this VideoTrackList object, using TrackEvent, with the track attribute initialized to the new VideoTrack object.
</li>
		</ol>
	</dd>

	<dt id="getting-media-metadata">
`~media資源$の［
時間長, 寸法, その他の~metadata
］を決定するに十分な`~media~data$が~fetchされたときは：
◎
Once enough of the media data has been fetched to determine the duration of the media resource, its dimensions, and other metadata
</dt>
	<dd>
これは、当の資源が利用-可能であることを指示する。
◎
This indicates that the resource is usable.＼
</dd>
	<dd>
<p>
~UAは、次に従うモノトスル：
◎
The user agent must follow these substeps:
</p>
		<ol>
			<li>
%~media時列線 ~LET `~media~data$に基づいて，`~media時列線を確立-$した結果の時列線
— ［
`現在の再生~位置$, `アリな最も早い位置$
］の目的において
◎
Establish the media timeline for the purposes of the current playback position and the earliest possible position, based on the media data.
</li>
		<li>
`時列線~offset$ ~SET `~media資源$は
%~media時列線 内の時刻 0 に対応する明示的な時刻＆日付を与えているならば それ ／
~ELSE_ `NaN^jv
］ 
◎
Update the timeline offset to the date and time that corresponds to the zero time in the media timeline established in the previous step, if any. If no explicit time and date is given by the media resource, the timeline offset must be set to Not-a-Number (NaN).
</li>
			<li>
( `現在の再生~位置$, `公式的な再生~位置$ )
~SET 
( `アリな最も早い位置$, `アリな最も早い位置$ )
◎
Set the current playback position and the official playback position to the earliest possible position.
</li>
			<li>
<p>
%要素 の `duration$mM 属性 ~SET %~media時列線 上の，資源の最後の~frameの時刻が［
既知ならば それ ／
既知でなければ正な `Infinity^jv （例： 原則的に無限な~stream）
］
◎
Update the duration attribute with the time of the last frame of the resource, if known, on the media timeline established above. If it is not known (e.g. a stream that is in principle infinite), update the duration attribute to the value positive Infinity.
</p>

<p class="note">注記：
~UAは、この時点で，<a href="#durationChange">次を行うことになる</a>
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `durationchange$et )
◎
The user agent will queue a media element task given the media element to fire an event named durationchange at the element at this point.
</p>

			</li>
			<li>
<p>
~IF［
%要素 は `video$e 要素である
］：
◎
For video elements,＼
</p>

				<ol>
					<li>
%要素 の［
`videoWidth$mV, `videoHeight$mV
］属性を設定する
◎
set the videoWidth and videoHeight attributes, and＼
</li>
					<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `resize$et )
◎
queue a media element task given the media element to fire an event named resize at the media element.
</li>
				</ol>

<p class="note">注記：
寸法が後で変化した場合、更に `resize$et ~eventが発火されることになる。
◎
Further resize events will be fired if the dimensions subsequently change.
</p>
			</li>
			<li>

<p>
%要素 の `readyState$mM 属性 ~SET `HAVE_METADATA$mM
◎
Set the readyState attribute to HAVE_METADATA.
</p>

<p class="note">注記：
この段で `readyState$mM 属性を設定する一部として、
`loadedmetadata$et ~eventが<a href="#fire-loadedmetadata">発火されることになる</a>。
◎
A loadedmetadata DOM event will be fired as part of setting the readyState attribute to a new value.
</p>

			</li>
			<li>
%~seek済みか ~LET ~F
◎
Let jumped be false.
</li>
			<li>
<p>
~IF［
%要素 の`既定の再生~開始~位置$ ~GT 0
］：
</p>
<ol ><li>`~seekする$( その時刻 )
</li><li>%~seek済みか ~SET ~T
</li></ol>

◎
If the media element's default playback start position is greater than zero, then seek to that time, and let jumped be true.
</li>
			<li>
%要素 の`既定の再生~開始~位置$ ~SET 0
◎
Let the media element's default playback start position be zero.
</li>
			<li>
%初期~再生~位置 ~LET 0
◎
Let the initial playback position be zero.
</li>
			<li>
<p>
~IF［［
%現~media資源 ／ %~URL
］は、特定0の開始~時刻 %t を指示している
］：
◎
If either the media resource or the URL of the current media resource indicate a particular start time, then＼
</p>
				<ol>
					<li>
%初期~再生~位置 ~SET %t
◎
set the initial playback position to that time and,＼
</li>
					<li>
~IF［
%~seek済みか ~EQ ~F
］
⇒
`~seekする$( %t )
◎
if jumped is still false, seek to that time.
</li>
				</ol>

<p class="example">
例えば，~media形式が`~media素片の構文$を~supportする場合、`素片$urlを利用して，始端~位置を指示できる。
◎
For example, with media formats that support media fragment syntax, the fragment can be used to indicate a start position.
</p>

			</li>
			<li>
~IF［
`可能化されている音声~track$はまだない
］
⇒
音声~track 【どの？】 を可能化する
— これは、
<a href="#toggle-audio-track">`change^et ~eventを発火させる</a>
ことになる。
◎
If there is no enabled audio track, then enable an audio track. This will cause a change event to be fired.
</li>
			<li>
~IF［
`選択されている動画~track$はなだない
］
⇒
動画~track 【どの？】を選択する
— これは、
<a href="#toggle-video-track">`change^et ~eventを発火させる</a>
ことになる。
◎
If there is no selected video track, then select a video track. This will cause a change event to be fired.
</li>
		</ol>

<p>
%要素 の `readyState$mM 属性 `HAVE_CURRENT_DATA$mM に達したときは、
<a href="#fire-loadeddata">`loadeddata^et ~eventを発火した後に</a>
⇒
%要素 の`~load~event遅延-中か$ ~SET ~F
◎
Once the readyState attribute reaches HAVE_CURRENT_DATA, after the loadeddata event has been fired, set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</p>

<p class="note">注記：
各`~media資源$用の~metadataを依然として~fetchしている間，
~network利用量を抑制しようと試みている~UAは、<a href="#resourceSuspend">前に述べた規則</a>に従って，この時点で~bufferするのも停止することになる
— それは、 `networkState$mM 属性を `NETWORK_IDLE$mM 値に切替えて， `suspend$et ~eventの発火することを孕む。
◎
A user agent that is attempting to reduce network usage while still fetching the metadata for each media resource would also stop buffering at this point, following the rules described previously, which involve the networkState attribute switching to the NETWORK_IDLE value and a suspend event firing.
</p>

<p class="note">注記：
~UAには、再生する前に，`~media資源$の時間長を決定して この段を遂げることが`要求される^em。
◎
The user agent is required to determine the duration of the media resource and go through this step before playing.
</p>
	</dd>

	<dt>
`~media資源$全体が~fetchされたときは（復号-前にもなり得る）：
◎
Once the entire media resource has been fetched (but potentially before any of it has been decoded)
</dt>
	<dd>
		<ol>
			<li>
`~eventを発火する$( %要素, `progress$et )
◎
Fire an event named progress at the media element.
</li>
			<li>
%要素 の `networkState$mM ~SET `NETWORK_IDLE$mM
</li>
			<li>
`~eventを発火する$( %要素, `suspend$et )
◎
Set the networkState to NETWORK_IDLE and fire an event named suspend at the media element.
</li>
		</ol>
<p>
~UAは、`~media~data$の一部でも破棄して，それを再び得するために~network活動を再開する必要が生じた場合、次を行うモノトスル
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
%要素 の `networkState$mM ~SET `NETWORK_LOADING$mM
◎
If the user agent ever discards any media data and then needs to resume the network activity to obtain it again, then it must queue a media element task given the media element to set the networkState to NETWORK_LOADING.
</p>

<p class="note">注記：
~UAが読込んだ`~media資源$を保てる場合、この~algoは`中止-$されることになる。
◎
If the user agent can keep the media resource loaded, then the algorithm will continue to its final step below, which aborts the algorithm.
</p>
	</dd>

	<dt>
`~media~data$の一部が受信された後，接続は中断されたため、~UAは資源を~fetchしようと試行するのをあきらめたときは：
◎
If the connection is interrupted after some media data has been received, causing the user agent to give up trying to fetch the resource
</dt>
	<dd>
すなわち、
%現~media資源 は利用-可能かどうか確立された（すなわち， %要素 の`readyState$mM 属性 ~NEQ `HAVE_NOTHING$mM になった）後に，致命的な~network~errorが生じた場合。
◎
Fatal network errors that occur after the user agent has established whether the current media resource is usable (i.e. once the media element's readyState attribute is no longer HAVE_NOTHING)＼
</dd>
	<dd>
<p>
次を実行するモノトスル：
◎
must cause the user agent to execute the following steps:
</p>
		<ol>
			<li>
~UAは~fetchingを取消すベキである
◎
The user agent should cancel the fetching process.
</li>
			<li>
%要素 の `error$mM 属性 ~SET `新たな~MediaError$( `MEDIA_ERR_NETWORK$mE )
◎
Set the error attribute to the result of creating a MediaError with MEDIA_ERR_NETWORK.
</li>
			<li>
%要素 の `networkState$mM 属性 ~SET `NETWORK_IDLE$mM
◎
Set the element's networkState attribute to the NETWORK_IDLE value.
</li>
			<li>
%要素 の`~load~event遅延-中か$ ~SET ~F
◎
Set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
			<li>
`~eventを発火する$( %要素, `~errorM$et )
◎
Fire an event named error at the media element.
</li>
			<li>
この`資源~選定~algo$を`中止-$する
◎
Abort the overall resource selection algorithm.
</li>
		</ol>
	</dd>

	<dt id="fatal-decode-error">
`~media~data$は破損しているときは：
◎
If the media data is corrupted
</dt>
	<dd>
すなわち、~UAが %現~media資源 は利用-可能かどうか確立した（すなわち， %要素 の`readyState$mM 属性は `HAVE_NOTHING$mM でなくなった）後に，`~media~data$の復号-時に致命的な~errorが生じた場合。
◎
Fatal errors in decoding the media data that occur after the user agent has established whether the current media resource is usable (i.e. once the media element's readyState attribute is no longer HAVE_NOTHING)＼
</dd>
	<dd>
<p>
次を実行するモノトスル：
◎
must cause the user agent to execute the following steps:
</p>
		<ol>
			<li>
~UAは~fetchingを取消すベキである
◎
The user agent should cancel the fetching process.
</li>
			<li>
%要素 の `error$mM 属性 ~SET `新たな~MediaError$( `MEDIA_ERR_DECODE$mE )
◎
Set the error attribute to the result of creating a MediaError with MEDIA_ERR_DECODE.
</li>
			<li>
%要素 の `networkState$mM 属性 ~SET `NETWORK_IDLE$mM
◎
Set the element's networkState attribute to the NETWORK_IDLE value.
</li>
			<li>
%要素 の`~load~event遅延-中か$ ~SET ~F
◎
Set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
			<li>
`~eventを発火する$( %要素, `~errorM$et )
◎
Fire an event named error at the media element.
</li>
			<li>
この`資源~選定~algo$を`中止-$する
◎
Abort the overall resource selection algorithm.
</li>
		</ol>
	</dd>

	<dt>
`~media~data$の~fetchingは 利用者により中止されたときは：
◎
If the media data fetching process is aborted by the user
</dt>
	<dd>
利用者により~fetchingが中止される例としては、利用者が “停止-” ~buttonを押したときが挙げられる。
◎
The fetching process is aborted by the user, e.g. because the user pressed a "stop" button,＼
</dd>
	<dd>
<p>
~UAは、次の手続きを実行するモノトスル。
この手続きは、［
この手続き 【を走らせている手続き？】
が走っている間に `load()$mM ~method自身が呼出された場合
］には生じない
— 上の手続き【どれ？】がその種の中止-を取扱うので。
◎
the user agent must execute the following steps. These steps are not followed if the load() method itself is invoked while these steps are running, as the steps above handle that particular kind of abort.
</p>
		<ol>
			<li>
~UAは~fetchingを取消すベキである
◎
The user agent should cancel the fetching process.
</li>
			<li>
`error$mM 属性 ~SET 
`新たな~MediaError$( `MEDIA_ERR_ABORTED$mE )
◎
Set the error attribute to the result of creating a MediaError with MEDIA_ERR_ABORTED.
</li>
			<li>
`~eventを発火する$( %要素, `abort$et )
◎
Fire an event named abort at the media element.
</li>
			<li>
<p>
~IF［
%要素 の`readyState$mM 属性~値 ~EQ `HAVE_NOTHING$mM
］：
◎
If the media element's readyState attribute has a value equal to HAVE_NOTHING,＼
</p>

				<ol>
					<li>
%要素 の `networkState$mM 属性 ~SET `NETWORK_EMPTY$mM
◎
set the element's networkState attribute to the NETWORK_EMPTY value,＼
</li>
					<li>
%要素 の`~posterを示すか$ ~SET ~T
◎
set the element's show poster flag to true, and＼
</li>
					<li>
`~eventを発火する$( %要素, `emptied$et )
◎
fire an event named emptied at the element.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%要素 の`networkState$mM 属性 ~SET `NETWORK_IDLE$mM
◎
Otherwise, set the element's networkState attribute to the NETWORK_IDLE value.
</li>
			<li>
%要素 の`~load~event遅延-中か$ ~SET ~F
◎
Set the element's delaying-the-load-event flag to false. This stops delaying the load event.
</li>
			<li>
この`資源~選定~algo$を`中止-$する
◎
Abort the overall resource selection algorithm.
</li>
		</ol>
	</dd>

	<dt id="non-fatal-media-error">
`~media~data$を~fetchできたが，その一部に具現化できないものがあるときは：
◎
If the media data can be fetched but＼
</dt>
	<dd>
<p>
すなわち，次のいずれかに該当するが、それでも再生はできるとき：
◎
＼
</p>
		<ul>
			<li>
~fetchできたが、致命的でない~errorまたは利用が生じた
◎
has non-fatal errors or uses, in part,＼
</li>
			<li>
~dataの一部に~UAが~supportしない ~codecs ~parameterがあるため、~UAは内容を完全に正しく具現化できない
◎
codecs that are unsupported, preventing the user agent from rendering the content completely correctly but not preventing playback altogether
</li>
			<li>
~serverは、部分的には利用-可能だが最適には具現化できない~dataを返している
◎
The server returning data that is partially usable but cannot be optimally rendered＼
</li>
		</ul>
	</dd>
	<dd>
~UAは、自身が取扱える~dataだけ具現化して，残りは無視するモノトスル。
◎
must cause the user agent to render just the bits it can handle, and ignore the rest.
</dd>

	<dt id="found-a-media-resource-specific-timed-track">
`~media資源$が［
~UAが~supportする，`~media資源に特有な~tT$
］を宣言していることが見出されたときは：
◎
If the media resource is found to declare a media-resource-specific text track that the user agent supports
</dt>
	<dd>
<p>
~IF［
`~media~data$は`~CORS同一-生成元$である
］
⇒
関連な~dataで`~media資源に特有な~tTを公開する手続き$を走らす
◎
If the media data is CORS-same-origin, run the steps to expose a media-resource-specific text track with the relevant data.
</p>

<p class="note">注記：
非同一-生成元の動画は、その字幕を公開しない
— そうすると、敵対的~siteが，利用者の~intranet上の機密的な動画から字幕を読取るような攻撃を許容することになるので。
◎
Cross-origin videos do not expose their subtitles, since that would allow attacks such as hostile sites reading subtitles from confidential videos on a user's intranet.
</p>

	</dd>
</dl>

【！~media~data処理~手続き~list ここまで】

	</li>
	<li>
`最終-段^i：
…
【この訳では、原文のこの段に代えて，`中止-$を利用している。】
◎
Final step: If the user agent ever reaches this step (which can only happen if the entire resource gets loaded and kept available): abort the overall resource selection algorithm.
</li>
</ol>
</div>

<div class="algo">
<p>
`~media資源に特有な~trackを忘れる@
ときは、所与の
( `~media要素$ %要素 )
に対し，次を走らすモノトスル：
◎
When a media element is to forget the media element's media-resource-specific tracks, the user agent must＼
</p>

<ol>
	<li>
%要素 の`~tT~list$から`~media資源に特有な~tT$すべてを除去する
◎
remove from the media element's list of text tracks all the media-resource-specific text tracks, then＼
</li>
	<li>
%要素 の `audioTracks$mM 属性が~~保持する `AudioTrackList$I ~objを空にする
◎
empty the media element's audioTracks attribute's AudioTrackList object, then＼
</li>
	<li>
%要素 の `videoTracks$mM 属性が~~保持する `VideoTrackList$I ~objを空にする
◎
empty the media element's videoTracks attribute's VideoTrackList object.＼
</li>
</ol>

<p>
~event（特に， `removetrack$et ~event）は、この手続きの一部として発火されることはない
— 代わりに，これを呼出した各種~algoにより発火される［
`~errorM$et, `emptied$et
］~eventを利用できる。
◎
No events (in particular, no removetrack events) are fired as part of this; the error and emptied events, fired by the algorithms that invoke this one, can be used instead.
</p>
</div>

<hr>

<p>
`preload@aM
属性は`列挙d属性$である。
次の表に，この属性~用の各種~keyword（ 1 列目）と，それぞれに対応する状態（同じ行の 2 列目）を挙げる。
この属性は、`~media資源$が［
~bufferされている／再生され始めた
］後でも変更できる
— 表の “概略” 列は、そのことを念頭に解釈されるとする。
◎
The preload attribute is an enumerated attribute. The following table lists the keywords and states for the attribute — the keywords in the left column map to the states in the cell in the second column on the same row as the keyword. The attribute can be changed even once the media resource is being buffered or played; the descriptions in the table below are to be interpreted with that in mind.
</p>

<table><thead><tr><th>~keyword
</th><th>状態
</th><th>概略
</th></tr></thead>
<!-- 
Keyword 	State 	Brief description 
 -->

<tbody id="_preload-states"><tr><td>`none@v
</td><td>`なし@st
</td><td>

<p>
次のいずれかであることを~UAに~hintする：
◎
Hints to the user agent that either＼
</p>
<ul>
	<li>
作者は，利用者が~media資源が必要になるものと期待していない
◎
the author does not expect the user to need the media resource, or＼
</li>
	<li>
~serverは不必要な流通を最小限にするよう求めている
◎
that the server wants to minimize unnecessary traffic.＼
</li>
</ul>

<p>
この状態は、［
~bufferingが開始されるときに備えて（例えば，利用者が “再生-” を叩いた），~media資源をどの程度~積極的に実際に~downloadするか
］に関する~hintは，供さない。
◎
This state does not provide a hint regarding how aggressively to actually download the media resource if buffering starts anyway (e.g. once the user hits "play").
</p>

</td></tr><tr><td>`metadata@v
</td><td>`~metadata@st
</td><td>
作者は，利用者が~media資源が必要になるものと期待してはいないが、［
当の資源の~metadata（寸法, ~track~list, 時間長, 等々）に加えて，最初の少数の~frameも~fetchする
］のは適度になることを，~UAに~hintする。
%要素 の `readyState$mM 属性は、~UAが精確に~metadataだけしか~fetchしなければ `HAVE_METADATA$mM になるが、概して，一部の~frameも得されることになり，おそらく［
`HAVE_CURRENT_DATA$mM, `HAVE_FUTURE_DATA$mM
］のいずれかになる。
~media資源の再生-中においては、帯域幅は狭いと見なされていることを，~UAに~hintする
— 例えば、~~安定的な再生は保守しつつ，~media~dataをアリな限り低速な~rateで得するよう，~downloadを減速することを示唆している。
◎
Hints to the user agent that the author does not expect the user to need the media resource, but that fetching the resource metadata (dimensions, track list, duration, etc.), and maybe even the first few frames, is reasonable. If the user agent precisely fetches no more than the metadata, then the media element will end up with its readyState attribute set to HAVE_METADATA; typically though, some frames will be obtained as well and it will probably be HAVE_CURRENT_DATA or HAVE_FUTURE_DATA. When the media resource is playing, hints to the user agent that bandwidth is to be considered scarce, e.g. suggesting throttling the download so that the media data is obtained at the slowest possible rate that still maintains consistent playback.

</td></tr><tr><td>`auto@v
</td><td>`自動的@st
</td><td>
~serverにおける~riskなしに
— 楽観的に資源~全体を~downloadするまでに —
利用者の必要を~~最優先にできることを，~UAに~hintする。
◎
Hints to the user agent that the user agent can put the user's needs first without risk to the server, up to and including optimistically downloading the entire resource.

</td></tr></tbody></table>

<p>
空~文字列も~keywordとして妥当であり， `自動的$st 状態に対応付けられる。
［
`値なし用の既定$, `妥当でない値~用の既定$
］は、`実装定義$である
— ［
~server負荷を抑制すること，最適な利用者~体験を供すること
］の妥協点として， `~metadata$st 状態が示唆されるが。
◎
The empty string is also a valid keyword, and maps to the Automatic state. The attribute's missing value default and invalid value default are implementation-defined, though the Metadata state is suggested as a compromise between reducing server load and providing an optimal user experience.
</p>

<p class="note">注記：
作者は、利用者が再生し始めてから，この属性を［
`none$v ／ `metadata$v
］から `auto$v へ動的に切替えるかもしれない。
例えば，多数の動画がある~pageでは、［
多くの動画は，要請されない限り~downloadしないが、`要請されたなら^em，積極的に~downloadする
］よう指示するために利用されるかもしれない。
◎
Authors might switch the attribute from "none" or "metadata" to "auto" dynamically once the user begins playback. For example, on a page with many videos this might be used to indicate that the many videos are not to be downloaded unless requested, but that once one is requested it is to be downloaded aggressively.
</p>

<p>
`preload$aM 属性は、［
何が利用者~体験にとって最善になるか
］についての~hintを，作者が~UAに供するために意図されている。
~UAは、この属性をまるごと無視してもヨイ
— 例えば、明示的な利用者~選好や, 可用な~接続性に基づいて。
◎
The preload attribute is intended to provide a hint to the user agent about what the author thinks will lead to the best user experience. The attribute may be ignored altogether, for example based on explicit user preferences or based on the available connectivity.
</p>

<p>
`preload@mM
~IDL属性は、`既知な値のみに制限され$る下で，
`preload$aM 内容~属性を`反映する$モノトスル。
◎
The preload IDL attribute must reflect the content attribute of the same name, limited to only known values.
</p>

<p class="note">注記：
`autoplay$aM 属性は、 `preload$aM 属性を上書きし得る（
`preload$aM 属性が与える~hintに関わらず、当の~mediaの再生-時には，それに先立って~bufferしているはずなので）。
しかしながら、両者とも含めることは~errorではない。
◎
The autoplay attribute can override the preload attribute (since if the media plays, it naturally has to buffer first, regardless of the hint given by the preload attribute). Including both is not an error, however.
</p>

<hr>

<dl class="domintro">
	<dt>%media.`buffered$mM</dt>
	<dd>
~UAが~bufferした`~media資源$の一連の範囲を表現する
`TimeRanges$I ~objを返す。
◎
Returns a TimeRanges object that represents the ranges of the media resource that the user agent has buffered.
</dd>
</dl>

<div class="algo">
<p>
`buffered@mM
取得子~手続きは
⇒
~RET 次を表現する，静的かつ`正規化-済み$な新たな `TimeRanges$I ~obj
⇒
~UAが現時点で~bufferした`~media資源$の一連の範囲
◎
The buffered attribute must return a new static normalized TimeRanges object that represents the ranges of the media resource, if any, that the user agent has buffered, at the time the attribute is evaluated.＼
</p>

<ul>
	<li>
<p>
~UAは、~media~streamに対し，これを手間のかかる検分でしか決定できない場合でも，可用な範囲を正確aに決定するモノトスル。
◎
Users agents must accurately determine the ranges available, even for media streams where this can only be determined by tedious inspection.
</p>

<p class="note">注記：
これは概して， 0 を起点とする単独の範囲になるが、例えば~UAの~seekingに呼応して
~HTTP `Range^h 要請を利用する場合，複数の範囲にもなり得る。
◎
Typically this will be a single range anchored at the zero point, but if, e.g. the user agent uses HTTP range requests in response to seeking, then there could be multiple ranges.
</p>
	</li>
	<li>
<p>
~UAは、以前に~bufferした~dataを破棄してヨイ。
◎
User agents may discard previously buffered data.
</p>

<p class="note">注記：
したがって，ある時点で `buffered$mM 属性が返す~objが表現する範囲たちのいずれかに含まれる時刻~位置は、後の時点で返されるものには含まれないかもしれない。
◎
Thus, a time position included within a range of the objects return by the buffered attribute at one time can end up being not included in the range(s) of objects returned by the same attribute at later times.
</p>
	</li>
</ul>

<p class="warning">
属性~取得子が毎回 新たな~objを返すのは不良な~patternであるが、今更それを変更するのは高くつくので，そうなっている。
そのようなふるまいは、新たな~APIには複製されない。
◎
Returning a new object each time is a bad pattern for attribute getters and is only enshrined here as it would be costly to change it. It is not to be copied to new APIs.
</p>
</div>

				</section>
				<section id="offsets-into-the-media-resource">
<h5 title="Offsets into the media resource">4.8.12.6. ~media資源の中への~offset</h5>

<dl class="domintro">
	<dt>%media.`duration$mM</dt>
	<dd>
`~media資源$の長さを秒数で返す。
`~media資源$の始端が時刻 0 と見做される。
◎
Returns the length of the media resource, in seconds, assuming that the start of the media resource is at time zero.
</dd>
	<dd>
時間長は可用でなければ `NaN^jv を返す。
◎
Returns NaN if the duration isn't available.
</dd>
	<dd>
無限界~stream用には `Infinity^jv を返す。
◎
Returns Infinity for unbounded streams.
</dd>

	<dt>%media.`currentTime$mM [ = %value ]</dt>
	<dd>
`公式的な再生~位置$を秒数で返す。
◎
Returns the official playback position, in seconds.
</dd>
	<dd>
設定して，所与の時刻に~seekできる。
◎
Can be set, to seek to the given time.
</dd>
</dl>

<p>
`~media資源$は、
`~media時列線@
（ `media timeline^en ）を持つ。
それは、時刻（秒数）を`~media資源$内の位置に対応付ける。
時列線の原点は、それに定義される最も早い位置になり，
時列線の時間長（ `duration^en ）は、それに定義される最後の位置になる。
◎
A media resource has a media timeline that maps times (in seconds) to positions in the media resource. The origin of a timeline is its earliest defined position. The duration of a timeline is its last defined position.
</p>

<p>
`~media時列線を確立-@
するときは：
◎
Establishing the media timeline:＼
</p>
<ul>
	<li>
`~media資源$が，何らかの方法で，原点が負でない時列線を明示的に指定する場合（すなわち，各~frameに特定の時刻~offsetを与えていて，最初の~frameには 0 以上の~offsetを与えている）
⇒
`~media時列線$はその時列線にされるベキである（`~media資源$が時列線を指定できるかどうかは`~media資源$の形式に依存する）。
◎
if the media resource somehow specifies an explicit timeline whose origin is not negative (i.e. gives each frame a specific time offset and gives the first frame a zero or positive offset), then the media timeline should be that timeline. (Whether the media resource can specify a timeline or not depends on the media resource's format.)＼
</li>
	<li>
`~media資源$が明示的な開始~時刻`と日付^emを指定する場合
⇒
その日時が
`~media時列線$における~offset 0 の地点と見なされるベキである
— `getStartDate()$mM ~methodは、この`時列線~offset$による日時を公開することになる。
◎
If the media resource specifies an explicit start time and date, then that time and date should be considered the zero point in the media timeline; the timeline offset will be the time and date, exposed using the getStartDate() method.
</li>
</ul>

<p>
`~media資源$の時列線は不連続である場合、~UAは資源の始端に利用される時列線を資源~全体にまたがるように拡張するモノトスル
— 下層の`~media~data$は順不同, あるいは時刻~codeが重合している場合でも、`~media資源$の`~media時列線$は，（下に定義される）`アリな最も早い位置$から開始して線形に増加するように。
◎
If the media resource has a discontinuous timeline, the user agent must extend the timeline used at the start of the resource across the entire resource, so that the media timeline of the media resource increases linearly starting from the earliest possible position (as defined below), even if the underlying media data has out-of-order or even overlapping time codes.
</p>

<p class="example">
例えば、
1 個の動画~file内に 2 個の連結された~clipがあって，動画の形式は両~clipの元の時刻による時列線
— 例えば［
00:15 〜 00:29,
00:05 〜 00:38
］ —
を公開しているかもしれない。
~UAは、それらの時刻は公開せず，単独の動画として［
00:15 〜 00:29,
00:29 〜 01:02
］を公開することになる。
◎
For example, if two clips have been concatenated into one video file, but the video format exposes the original times for the two clips, the video data might expose a timeline that goes, say, 00:15..00:29 and then 00:05..00:38. However, the user agent would not expose those times; it would instead expose the times as 00:15..00:29 and 00:29..01:02, as a single video.
</p>

<p>
~FINGERPRINTING
`~media資源$に明示的な時列線が無いような稀な事例においては、
`~media時列線$の 時刻 0 は，`~media資源$の最初の~frameに対応するベキである。
`~media資源$が明示的な計時~情報を
— ~frame時間長すら —
全く伴わないようなもっと稀な事例においては、~UAは，各~frameに対応する時刻を`実装定義$な方式で決定するモノトスル。
◎
(This is a tracking vector.)
In the rare case of a media resource that does not have an explicit timeline, the zero time on the media timeline should correspond to the first frame of the media resource. In the even rarer case of a media resource with no explicit timings of any kind, not even frame durations, the user agent must itself determine the time for each frame in an implementation-defined manner.
</p>

<p class="note">注記：
明示的な時列線は伴わないが，明示的な~frame時間長は伴う~file形式の例としては、
Animated GIF 形式が挙げられる。
明示的な時列線を全く伴わない~file形式の例としては、 JPEG-push 形式が挙げられる（
JPEG ~frameを伴う `multipart/x-mixed-replace$mt
— MJPEG ~stream用の形式として利用されることが多い）。
◎
An example of a file format with no explicit timeline but with explicit frame durations is the Animated GIF format. An example of a file format with no explicit timings at all is the JPEG-push format (multipart/x-mixed-replace with JPEG frames, often used as the format for MJPEG streams).
</p>

<p>
`~media資源$ %資源 に計時~情報が伴われない事例では、~UAは，時刻 0 を次に与える時刻に対応させるベキである：
◎
If, in the case of a resource with no timing information,＼
</p>

<ul>
	<li>
にもかかわらず，［
~serverが元々供した最初の~frameより早い地点
］へ~seekできることになる場合
⇒
%資源 内の~seek可能な最も早い時刻
◎
the user agent will nonetheless be able to seek to an earlier point than the first frame originally provided by the server, then the zero time should correspond to the earliest seekable time of the media resource;＼
</li>
	<li>
他の場合
⇒
~serverから受信された最初の~frame（~UAが %資源 内の~streamを受信し始めた地点）。
◎
otherwise, it should correspond to the first frame received from the server (the point in the media resource at which the user agent began receiving the stream).
</li>
</ul>

<p class="note">注記：
これを書いている時点では、［
~serverにより送信された最初の~frameより前の~frameへの~seek法を~supportしつつ，明示的な~frame時刻~offsetを欠く
］ような，既知な形式はない。
◎
At the time of writing, there is no known format that lacks explicit frame time offsets yet still supports seeking to a frame before the first frame sent by the server.
</p>

<div class="example">

<p>
ある TV 放送局からの，次のような~streamを考える：
◎
Consider a stream from a TV broadcaster, which＼
</p>

<ul>
	<li>
10 月の金曜日の昼過ぎから~streamingを始める
◎
begins streaming on a sunny Friday afternoon in October, and＼
</li>
	<li>
接続してくるどの~UAに対しても，常に同じ~media時列線~上の~media~dataを送信する
◎
always sends connecting user agents the media data on the same media timeline,＼
</li>
	<li>
その時刻 0 はこの~streamの始端に設定されている
◎
with its zero time set to the start of this stream.＼
</li>
</ul>

<p>
何ヶ月か後にこの~streamへ接続している~UAは、自身が受信する最初の~frameの時刻が秒~数で何千何百万になることを見出すことになる。
`getStartDate()$mM ~methodは，常に放送を開始した日付を返すことになる。
これにより，~controllerは，自身の `scrubber^en
【音声の区間を選択するための~UI】
内に実~時刻（例： “午後 2:30”）
— 放送~~開始に相対的な時刻（例： “8 ヶ月, 4 ~~時間, 12分 23 秒” ）ではなく —
を表示できるようになる。
◎
Months later, user agents connecting to this stream will find that the first frame they receive has a time with millions of seconds. The getStartDate() method would always return the date that the broadcast started; this would allow controllers to display real times in their scrubber (e.g. "2:30pm") rather than a time relative to when the broadcast began ("8 months, 4 hours, 12 minutes, and 23 seconds").
</p>

<p>
ある~serverにより放送される，次のような~streamを考える：
◎
Consider a stream that＼
</p>
<ul>
	<li>
いくつかの断片が連結された動画を運んでいる
◎
carries a video with several concatenated fragments, broadcast by a server＼
</li>
	<li>
特定の時刻を要請するのを~UAに許容せず，単に動画~dataを予め決定された順序で~streamする
◎
that does not allow user agents to request specific times but instead just streams the video data in a predetermined order,＼
</li>
	<li>
最初の~frameは常に，時刻 0 の~frameとして識別されるよう送達される。
◎
with the first frame delivered always being identified as the frame with time zero.＼
</li>
</ul>

<p>
~UAがこの~streamに接続して，時刻印［
2010-03-20 23:15:00 UTC 〜 2010-03-21 00:05:00 UTC
］, ［
2010-02-12 14:25:00 UTC 〜 2010-02-12 14:35:00 UTC
］を受持つものと定義された断片を受信した場合、これを 0 秒から開始して 3600 秒（ 1 ~~時間）へ拡張する`~media時列線$を伴わせて公開することになる。
~streaming~serverは 2 個目の~clipの終端で切断されると見做すなら、
`duration$mM 属性は 3600 を返し，
`getStartDate()$mM ~methodは
2010-03-20 23:15:00 UTC
に対応する時刻を表す `Date$I ~objを返すことになる。
◎
If a user agent connects to this stream and receives fragments defined as covering timestamps 2010-03-20 23:15:00 UTC to 2010-03-21 00:05:00 UTC and 2010-02-12 14:25:00 UTC to 2010-02-12 14:35:00 UTC, it would expose this with a media timeline starting at 0s and extending to 3,600s (one hour). Assuming the streaming server disconnected at the end of the second clip, the duration attribute would then return 3,600. The getStartDate() method would return a Date object with a time corresponding to 2010-03-20 23:15:00 UTC.＼
</p>

<p>
その一方，別の~UAが 5 分~後に接続した場合、その~UAは，時刻印［
2010-03-20 23:20:00 UTC 〜 2010-03-21 00:05:00 UTC
］, ［
2010-02-12 14:25:00 UTC 〜 2010-02-12 14:35:00 UTC
］を受持つ断片を（だいたいは）受信することになり、
0 秒から開始して 3300 秒（ 55 分間）へ拡張する`~media時列線$を伴わせて，これを公開することになる。
この事例では、 `getStartDate()$mM ~methodは，
2010-03-20 23:20:00 UTC
に対応する時刻を表す `Date$I ~objを返すことになる。
◎
However, if a different user agent connected five minutes later, it would (presumably) receive fragments covering timestamps 2010-03-20 23:20:00 UTC to 2010-03-21 00:05:00 UTC and 2010-02-12 14:25:00 UTC to 2010-02-12 14:35:00 UTC, and would expose this with a media timeline starting at 0s and extending to 3,300s (fifty five minutes). In this case, the getStartDate() method would return a Date object with a time corresponding to 2010-03-20 23:20:00 UTC.
</p>

<p>
この両~例とも，
`seekable$mM 属性は~controllerが~UI内に実際に表示したいと求める一連の範囲を与えることになる
— ~serverが任意の時刻への~seek法を~supportしない場合、これは概して，［
~UAが~streamへ接続した瞬間の時刻から，~UAが直近に得した~frameまで
］の範囲になる。
しかしながら，~UAがより早い情報を破棄し始めた場合、実際の範囲はより短くなるかもしれない。
◎
In both of these examples, the seekable attribute would give the ranges that the controller would want to actually display in its UI; typically, if the servers don't support seeking to arbitrary times, this would be the range of time from the moment the user agent connected to the stream up to the latest frame that the user agent has obtained; however, if the user agent starts discarding earlier information, the actual range might be shorter.
</p>

</div>

<p>
いずれの事例であれ，~UAは、［
`~media時列線$を確立したときは，それを利用している`アリな最も早い位置$は 0 以上になる
］ことを確保するモノトスル。
◎
In any case, the user agent must ensure that the earliest possible position (as defined below) using the established media timeline, is greater than or equal to zero.
</p>

<p>
`~media時列線$には、時計も結付けられる。
どの時計が利用されるかは~UAにより定義され，`~media資源$ に依存してもヨイが、それは利用者の~wall時計
【局所時間帯？】
に近似するベキである。
◎
The media timeline also has an associated clock. Which clock is used is user-agent defined, and may be media resource-dependent, but it should approximate the user's wall clock.
</p>

<p>
各`~media要素$には、次に挙げるものが結付けられる
— 初期~時には（すなわち，`~media~data$が無い下では）、括弧~内に与える値に設定するモノトスル：
◎
↓</p>

<dl class="def-list">
	<dt>`現在の再生~位置@ （ 0 秒 ）</dt>
	<dd>
`~media時列線$上の時刻。
◎
Media elements have a current playback position, which must initially (i.e. in the absence of media data) be zero seconds. The current playback position is a time on the media timeline.
</dd>

	<dt>`公式的な再生~位置@ （ 0 秒 ）</dt>
	<dd>
これは、~scriptを走らせている間は安定に保たれるような，`現在の再生~位置$の近似である。
◎
Media elements also have an official playback position, which must initially be set to zero seconds. The official playback position is an approximation of the current playback position that is kept stable while scripts are running.
</dd>

	<dt>`既定の再生~開始~位置@（ 0 秒 ）</dt>
	<dd>
この時刻は、~mediaが読込まれる前であっても，要素を~seekできるようにするために利用される。
◎
Media elements also have a default playback start position, which must initially be set to zero seconds. This time is used to allow the element to be seeked even before the media is loaded.
</dd>

	<dt>`~posterを示すか@ （ ~T ）</dt>
	<dd>
~UAが `video$e 要素~用に，いつ［
動画~内容に代えて，~poster~frameを示す
］かどうかを制御するために利用される。
“`~posterを示して$［
いる／いない
］”
という句は、この値が［
~T／~F
］であることを意味する。
◎
Each media element has a show poster flag. When a media element is created, this flag must be set to true. This flag is used to control when the user agent is to show a poster frame for a video element instead of showing the video contents.
</dd>
</dl>

<div class="algo">
`currentTime@mM
取得子~手続きは
⇒
~RET 次を秒数で表出する値
⇒＃
コレの`既定の再生~開始~位置$は 0 でないならば それ ／
~ELSE_ コレの`公式的な再生~位置$
◎
The currentTime attribute must, on getting, return the media element's default playback start position, unless that is zero, in which case it must return the element's official playback position. The returned value must be expressed in seconds.＼
</div>

<div class="algo">
<p>
`currentTime$mM 設定子~手続きは：
◎
On setting,＼
</p>
<ol>
	<li>
~IF［
コレの`readyState$mM ~EQ `HAVE_NOTHING$mM
］
⇒
コレの`既定の再生~開始~位置$ ~SET 所与の値
◎
if the media element's readyState is HAVE_NOTHING, then it must set the media element's default playback start position to the new value;＼
</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
コレの`公式的な再生~位置$ ~SET 所与の値
</li>
			<li>
`~seekする$( 所与の値を秒数として解釈した結果 )
</li>
		</ol>
◎
otherwise, it must set the official playback position to the new value and then seek to the new value. The new value must be interpreted as being in seconds.
</li>
</ol>
</div>

<p>
`~media資源$は~streaming資源である場合、~bufferから失効した後は，~UAは資源のある部分を得せないかもしれない。
同様に，`~media資源$の`~media時列線$は、 0 から開始しないこともあるかもしれない。
`アリな最も早い位置@
は、`~media時列線$上の時刻であって，~UAがいつでも再び得せるような［
~stream／資源
］内の最も早い位置とする。
◎
If the media resource is a streaming resource, then the user agent might be unable to obtain certain parts of the resource after it has expired from its buffer. Similarly, some media resources might have a media timeline that doesn't start at zero. The earliest possible position is the earliest position in the stream or resource that the user agent can ever obtain again. It is also a time on the media timeline.
</p>

<p class="note">注記：
`アリな最も早い位置$は、~APIにおいては明示的には公開されない。
それは、 `seekable$mM 属性が返す `TimeRanges$I ~objが表す範囲~listが［
空でなければ その最初の範囲の開始~時刻 ／
空ならば `現在の再生~位置$
］に対応する。
◎
The earliest possible position is not explicitly exposed in the API; it corresponds to the start time of the first range in the seekable attribute's TimeRanges object, if any, or the current playback position otherwise.
</p>

<div class="algo">
<p>
%要素 の`アリな最も早い位置$が変化したときは、次を走らすモノトスル：
◎
When the earliest possible position changes, then:＼
</p>

<ul>
	<li>
~IF［
`現在の再生~位置$は`アリな最も早い位置$より前
］
⇒
`~seekする$( `アリな最も早い位置$ )
◎
if the current playback position is before the earliest possible position, the user agent must seek to the earliest possible position;＼
</li>
	<li>
~ELIF［
%要素 向けの `timeupdate$et ~eventは、［
過去 15ms 〜 250ms においては発火されていない
］~AND［
それ用の~event~handlerは現在~走っていない
］］
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `timeupdate$et )
◎
otherwise, if the user agent has not fired a timeupdate event at the element in the past 15 to 250ms and is not still running event handlers for such an event, then the user agent must queue a media element task given the media element to fire an event named timeupdate at the element.
</li>
</ul>

<p class="note">注記：
上の要件と［
<a href="#getting-media-metadata">~clipの~metadataが既知になった</a>
ときから効き始める，`~media資源~fetch~algo$における要件
］があるので、［
`現在の再生~位置$ ~LT `アリな最も早い位置$
］になることは、決してない。
◎
Because of the above requirement and the requirement in the resource fetch algorithm that kicks in when the metadata of the clip becomes known, the current playback position can never be less than the earliest possible position.
</p>
</div>

<div class="algo">
<p>
~UAは、どの時点であれ，［
ある［
音声／動画
］~trackは終止した
］かつ［
その~trackに関係しているすべての`~media~data$は、`~media時列線$を成す［
`アリな最も早い位置$`より前^emにある部分
］に対応する
］ことが~~判明したときは、次を行ってヨイ：
◎
If at any time the user agent learns that an audio or video track has ended and all media data relating to that track corresponds to parts of the media timeline that are before the earliest possible position, the user agent may＼
</p>

<ol>
	<li>
~Assert：
当の~trackは、ある`~media要素$ %要素 の［
`audioTracks$mM ／ `videoTracks$mM
］属性が返す［
`AudioTrackList$I ／ `VideoTrackList$I
］~obj %~track~list 内のある［
`AudioTrack$I ／ `VideoTrack$I
］~obj %~track で表現されている
◎
↓</li>
	<li>
<p>
次を走らす`~media~taskを~queueする$( %要素 )
◎
queue a media element task given the media element to run these steps:
</p>
		<ol>
			<li>
%~track~list から %~track を除去する
◎
Remove the track from the audioTracks attribute's AudioTrackList object or the videoTracks attribute's VideoTrackList object as appropriate.
</li>
			<li>
<p>
`~eventを発火する$( %~track~list, `removetrack$et, `TrackEvent$I )
— 次のように初期化して
⇒
`track$m 属性 ~SET %~track
◎
Fire an event named removetrack at the media element's aforementioned AudioTrackList or VideoTrackList object, using TrackEvent, with the track attribute initialized to the AudioTrack or VideoTrack object representing the track.
</li>

		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`duration@mM
取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレに可用な`~media~data$はない
］
⇒
~RET `NaN^jv
</li>
	<li>
~IF［
`~media資源$は有限界と既知でない（例：
~streaming~radioや，終了~時刻は公告されていない~live-event）
］
⇒
~RET 正な `Infinity^jv ／
</li>
	<li>
~RET 秒数による，コレの`~media時列線$上のコレの`~media資源$の終了~時刻
</li>
</ol>
◎
The duration attribute must return the time of the end of the media resource, in seconds, on the media timeline. If no media data is available, then the attributes must return the Not-a-Number (NaN) value. If the media resource is not known to be bounded (e.g. streaming radio, or a live event with no announced end time), then the attribute must return the positive Infinity value.
</div>

<p>
~UAは、`~media資源$の時間長を，［
`~media~data$のどこか一部でも再生する ／
`readyState$mM を `HAVE_METADATA$mM 以上の値に設定する
］より前に決定するモノトスル
— そのためには資源の複数の部分を~fetchする必要がある場合でも。
◎
The user agent must determine the duration of the media resource before playing any part of the media data and before setting readyState to a value equal to or greater than HAVE_METADATA, even if doing so requires fetching multiple parts of the resource.
</p>

<div class="algo">
<p id="durationChange">
`~media要素$ %要素 の`~media資源$ %資源 の長さが既知な値に変化したとき（例：未知から既知へ／以前に確立された長さから新たな長さへ変化したとき）は、~UAは次を走らすモノトスル：
◎
When the length of the media resource changes to a known value (e.g. from being unknown to known, or from a previously established length to a new length) the user agent must＼
</p>

<ol>
	<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `durationchange$et )
（この~eventは、新たな~media資源の読込n時の一環として，時間長が設定し直されたときは発火されない。）
◎
queue a media element task given the media element to fire an event named durationchange at the media element. (The event is not fired when the duration is reset as part of loading a new media resource.)＼
</li>
	<li>
%終端 ~LET %資源 の終端の時刻
◎
＼</li>
	<li>
~IF［
時間長の変化により［
`現在の再生~位置$ ~GT %終端
］になった
］
⇒
`~seekする$( %終端 )
◎
If the duration is changed such that the current playback position ends up being greater than the time of the end of the media resource, then the user agent must also seek to the time of the end of the media resource.
</li>
</ol>
</div>

<p class="example">
“無限” ~streamが何らかの理由で終止する場合、時間長は
正な `Infinity^jv から~stream内の最後の［
~frame／~sample
］時刻に変化して，
`durationchange$et ~eventは同様に発火されることになる。
~UAが`~media資源$の時間長を精確に決定する代わりに初期~時に見積もっていて，後で新たな情報に基づいて見積もりを改訂した場合、時間長は変化して `durationchange$et ~eventは発火されることになる。
◎
If an "infinite" stream ends for some reason, then the duration would change from positive Infinity to the time of the last frame or sample in the stream, and the durationchange event would be fired. Similarly, if the user agent initially estimated the media resource's duration instead of determining it precisely, and later revises the estimate based on new information, then the duration would change and the durationchange event would be fired.
</p>

<p>
一部の動画~fileは、
`時列線~offset@
と呼ばれる，`~media時列線$内の時刻 0 に対応する，明示的な日時も持つ。
それは、初期~時には `NaN^jv に設定するモノトスル。
◎
Some video files also have an explicit date and time corresponding to the zero time in the media timeline, known as the timeline offset. Initially, the timeline offset must be set to Not-a-Number (NaN).
</p>

<div class="algo">
`getStartDate()@mM
~method~手続きは
⇒
~RET 現在の`時列線~offset$を表現している`新たな~Date~obj$
◎
The getStartDate() method must return a new Date object representing the current timeline offset.
</div>

<hr>

<p>
`loop@aM
属性は，`真偽-属性$であり、指定された場合，`~media要素$が終端に達したときには`~media資源$の始端へ~seekして戻ることを指示する。
◎
The loop attribute is a boolean attribute that, if specified, indicates that the media element is to seek back to the start of the media resource upon reaching the end.
</p>

<p>
`loop@mM
~IDL属性は、
`loop$aM 内容~属性を`反映する$モノトスル。
◎
The loop IDL attribute must reflect the content attribute of the same name.
</p>

				</section>
				<section id="ready-states">
<h5 title="Ready states">4.8.12.7. 準備状態</h5>

<dl class="domintro">

	<dt>%media.`readyState$mM</dt>
	<dd>
コレの`現在の再生~位置$の具現化に関する，現在の状態を表出する値を、下に挙げる~codeとして返す。
◎
Returns a value that expresses the current state of the element with respect to rendering the current playback position, from the codes in the list below.
</dd>
</dl>

<p>
各`~media要素$は、次に挙げるいずれかを値にとる
`準備状態^i
を持つ。
それは、`現在の再生~位置$に具現化する準備済み度合いを述べる。
与えられた特定0の時刻における~media要素の準備状態は、要素の状態を述べている最~大~値になる：
◎
Media elements have a ready state, which describes to what degree they are ready to be rendered at the current playback position. The possible values are as follows; the ready state of a media element at any particular time is the greatest value describing the state of the element:
</p>

<dl class="def-list">
	<dt>`HAVE_NOTHING@mM （数-値 0 ）</dt>
	<dd>
<p>
次を指示する：
◎
↓</p>
		<ul>
			<li>
`~media資源$に関する可用な情報はない。
◎
No information regarding the media resource is available.＼
</li>
			<li>
コレの`現在の再生~位置$用の~dataは可用でない。
◎
No data for the current playback position is available.＼
</li>
		</ul>
	</dd>
	<dd>
［
コレの `networkState$mM 属性 ~EQ `NETWORK_EMPTY$mM
］ならば、常に `HAVE_NOTHING$mM 状態にある。
◎
Media elements whose networkState attribute are set to NETWORK_EMPTY are always in the HAVE_NOTHING state.
</dd>

	<dt>`HAVE_METADATA@mM （数-値 1 ）</dt>
	<dd>
<p>
次を指示する：
</p>
		<ul>
			<li>
コレの資源の時間長が可用になるに十分な資源は得され、コレが `video$e 要素である場合は，動画の寸法も可用である。
◎
Enough of the resource has been obtained that the duration of the resource is available. In the case of a video element, the dimensions of the video are also available. ＼
</li>
			<li>
コレの`現在の再生~位置$用の直の`~media~data$は可用でない。
◎
No media data is available for the immediate current playback position.
</li>
		</ul>
	</dd>

	<dt>`HAVE_CURRENT_DATA@mM （数-値 2 ）</dt>
	<dd>
<p>
次を指示する：
◎
↓</p>
		<ul>
			<li>
コレの`現在の再生~位置$用の直の~dataは可用である。
◎
Data for the immediate current playback position is available, but.＼
</li>
			<li>
~UAは，コレの`現在の再生~位置$を`再生~方向$へ進めるために十分な~dataを有していない
— `再生~方向$に得せる~dataはもうないか、進めるためには即時に `HAVE_METADATA$mM 状態へ復帰する必要がある。
◎
either not enough data is available that the user agent could successfully advance the current playback position in the direction of playback at all without immediately reverting to the HAVE_METADATA state, or there is no more data to obtain in the direction of playback.＼
</li>
		</ul>
	</dd>
	<dd>
<p>
例えば動画においては、これは次のいずれかに対応する：
◎
For example, in video this corresponds＼
</p>
		<ul>
			<li>
コレの`現在の再生~位置$が現在の~frameの終端にある下で、~UAには現在の~frameからの~dataはあるが，次~frameのそれはない。
◎
to the user agent having data from the current frame, but not the next frame, when the current playback position is at the end of the current frame;＼
</li>
			<li>
`再生は終止して$いるとき
◎
and to when playback has ended.
</li>
		</ul>
	</dd>

	<dt>`HAVE_FUTURE_DATA@mM （数-値 3 ）</dt>
	<dd>
<p>
次を指示する：
◎
↓</p>
		<ul>
			<li>
コレの`現在の再生~位置$用の直の~dataは可用である。
◎
Data for the immediate current playback position is available, as well as ＼
</li>
			<li>
~UAは、コレの`現在の再生~位置$を少なくとも少しは`再生~方向$へ進めるに十分な~dataを有していて、進めるために即時に `HAVE_METADATA$mM 状態へ復帰する必要はない。
◎
enough data for the user agent to advance the current playback position in the direction of playback at least a little without immediately reverting to the HAVE_METADATA state, and＼
</li>
			<li>
~tTは `準備済み$i にある。
◎
the text tracks are ready.＼
</li>
		</ul>
	</dd>
	<dd>
<p>
例えば動画においては、これは次のいずれかに対応する
◎
For example, in video this corresponds＼
</p>
		<ul>
			<li>
~UAは、少なくとも，［
`現在の再生~位置$の時刻を挟む，現在の~frameと次~frame
］用の~dataを有する。
◎
to the user agent having data for at least the current frame and the next frame when the current playback position is at the instant in time between the two frames, or＼
</li>
			<li>
~UAは、現在の~frame用の［
動画~data, 音声~data
］を有する
— コレの`現在の再生~位置$が ある~frameの途中にあるとき，少なくとも 少しは再生し続けれるだけの。
◎
to the user agent having the video data for the current frame and audio data to keep playing at least a little when the current playback position is in the middle of a frame.＼
</li>
		</ul>
	</dd>
	<dd>
`再生は終止して$いる場合、コレの`現在の再生~位置$は決して進めれないので，この状態になり得ない。
◎
The user agent cannot be in this state if playback has ended, as the current playback position can never advance in this case.
</dd>

	<dt>`HAVE_ENOUGH_DATA@mM （数-値 4 ）</dt>
	<dd>
<p>
`HAVE_FUTURE_DATA$mM
状態に述べたすべての条件は満たされることに
加えて、次のいずれかの条件も満たされることを指示する：
◎
All the conditions described for the HAVE_FUTURE_DATA state are met, and, in addition, either of the following conditions is also true:
</p>
		<ul>
			<li>
~UAは、［
次が満たされるような~rateで，~dataは~fetchされている
］ものと見積もっている
⇒
コレの`現在の再生~位置$からコレの `playbackRate$mM で進めた場合に、再生が`~media資源$の終端に達する前に，可用な~dataが尽きることはない
◎
The user agent estimates that data is being fetched at a rate where the current playback position, if it were to advance at the element's playbackRate, would not overtake the available data before playback reaches the end of the media resource.
</li>
			<li>
~UAは、これ以上~待機して再生を遅延しても，~dataは得されず何の利得もない（例えば、~bufferは満杯であるかもしれない）状態になった。
◎
The user agent has entered a state where waiting longer will not result in further data being obtained, and therefore nothing would be gained by delaying playback any further. (For example, the buffer might be full.)
</li>
		</ul>
	</dd>
</dl>

<p class="note">注記：
実施においては、
`HAVE_METADATA$mM と `HAVE_CURRENT_DATA$mM
との相違は些細である。
~~実際にこの相違が関連するのは、 `video$e 要素を `canvas$e 上に塗るときに限られる
— そこでは、何かが描かれるとき（ `HAVE_CURRENT_DATA$mM 以上）と何も描かれないとき（ `HAVE_METADATA$mM 以下）とが判別される。
同様に、
`HAVE_CURRENT_DATA$mM （現在の~frameしかない）と
`HAVE_FUTURE_DATA$mM （少なくともこの~frameと次がある）との相違も，些細にもなり得る（極端な場合，~frame は 1 個しかないとき）。
その区別が~~実際に関わるのは、~pageが “~frame刻みの” ~navi用~UIを供するときに限られる。
◎
In practice, the difference between HAVE_METADATA and HAVE_CURRENT_DATA is negligible. Really the only time the difference is relevant is when painting a video element onto a canvas, where it distinguishes the case where something will be drawn (HAVE_CURRENT_DATA or greater) from the case where nothing is drawn (HAVE_METADATA or less). Similarly, the difference between HAVE_CURRENT_DATA (only the current frame) and HAVE_FUTURE_DATA (at least this frame and the next) can be negligible (in the extreme, only one frame). The only time that distinction really matters is when a page provides an interface for "frame-by-frame" navigation.
</p>

<div class="algo">
<p>
`~media要素$ %要素 の準備状態が
%旧~状態 から %新~状態 へ変化したときは、次の手続きに従うモノトスル：
◎
When the ready state of a media element whose networkState is not NETWORK_EMPTY changes, the user agent must follow the steps given below:
◎
Apply the first applicable set of substeps from the following list:
</p>

<ol>
	<li>
~IF［
%要素 の `networkState$mM ~EQ `NETWORK_EMPTY$mM
］
⇒
~RET
◎
↑</li>
	<li>
<p>
~IF［
%旧~状態 ~EQ `HAVE_NOTHING$mM
］~AND［
%新~状態 ~EQ `HAVE_METADATA$mM
］：
◎
If the previous ready state was HAVE_NOTHING, and the new ready state is HAVE_METADATA
</p>
		<ol>
			<li>
<p id="fire-loadedmetadata">
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `loadedmetadata$et )
◎
Queue a media element task given the media element to fire an event named loadedmetadata at the element.
</p>

<p class="note">注記：
この~taskを走らす前に，適切になるなら、
`video$e 要素は，`~event~loop$の仕組みの一部として，具現化-時に~resizeされるよう更新されることになる。
◎
Before this task is run, as part of the event loop mechanism, the rendering will have been updated to resize the video element if appropriate.
</p>
			</li>
			<li>
~RET
</li>
		</ol>
	</li>

	<li>
<p id="handling-first-frame-available">
~IF［
%旧~状態 ~EQ `HAVE_METADATA$mM
］~AND［
%新~状態 ~GTE `HAVE_CURRENT_DATA$mM
］：
◎
If the previous ready state was HAVE_METADATA and the new ready state is HAVE_CURRENT_DATA or greater
</p>
		<ol>
			<li id="fire-loadeddata">
~IF［
%要素 に対し生じたのは
`load()$mM ~algoが最後に呼出されてから初回である
］
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `loadeddata$et )
◎
If this is the first time this occurs for this media element since the load() algorithm was last invoked, the user agent must queue a media element task given the media element to fire an event named loadeddata at the element.
</li>
			<li>
~IF［
%新~状態 ~EQ `HAVE_CURRENT_DATA$mM
］
⇒
~RET
◎
If the new ready state is HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA, then the relevant steps below must then be run also.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%旧~状態 ~GTE `HAVE_FUTURE_DATA$mM
］~AND［
%新~状態 ~LTE `HAVE_CURRENT_DATA$mM
］：
◎
If the previous ready state was HAVE_FUTURE_DATA or more, and the new ready state is HAVE_CURRENT_DATA or less
</p>
		<ol>
			<li>
<p id="fire-waiting-when-waiting">
~IF［
`readyState$mM 属性が変化する前は， %要素 は`再生-中であり得る$であった
］：
◎
If the media element was potentially playing before its readyState attribute changed to a value lower than HAVE_FUTURE_DATA, and＼
</p>
				<ol>
					<li>
<p>
~IF［
%要素 は次のいずれかを満たしている
］
⇒
~RET：
</p>

<ul ><li>`再生は終止して$いる
</li><li>`~errorに因り停止され$ている
</li><li>`利用者~対話~用に静止され$ている
</li><li>`帯域内~内容~用に静止され$ている
</li></ul>

◎
the element has not ended playback, and playback has not stopped due to errors, paused for user interaction, or paused for in-band content, the user agent must＼
</li>
					<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `timeupdate$et )
◎
queue a media element task given the media element to fire an event named timeupdate at the element, and＼
</li>
					<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `waiting$et )
◎
queue a media element task given the media element to fire an event named waiting at the element.
</li>
				</ol>
			</li>
			<li>
~RET
</li>
		</ol>
	</li>

	<li>
<p>
~IF［
%旧~状態 ~LTE `HAVE_CURRENT_DATA$mM
］~AND［
%新~状態 ~EQ `HAVE_FUTURE_DATA$mM
］：
◎
If the previous ready state was HAVE_CURRENT_DATA or less, and the new ready state is HAVE_FUTURE_DATA
</p>
		<ol>
			<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `canplay$et )
◎
The user agent must queue a media element task given the media element to fire an event named canplay at the element.
</li>
			<li>
~IF［
%要素 の`paused$mM 属性 ~EQ ~F
］
⇒
`再生-中について通知する$( %要素 )
◎
If the element's paused attribute is false, the user agent must notify about playing for the element.
</li>
			<li>
~RET
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%新~状態 ~EQ `HAVE_ENOUGH_DATA$mM
］：
◎
If the new ready state is HAVE_ENOUGH_DATA
</p>
		<ol>
			<li>
<p>
~IF［
%旧~状態 ~LTE `HAVE_CURRENT_DATA$mM
］：
◎
If the previous ready state was HAVE_CURRENT_DATA or less, the user agent must＼
</p>
				<ol>
					<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `canplay$et )
◎
queue a media element task given the media element to fire an event named canplay at the element, and,＼
</li>
					<li>
~IF［
%要素 の`paused$mM 属性 ~EQ ~F
］
⇒
`再生-中について通知する$( %要素 )
◎
if the element's paused attribute is false, notify about playing for the element.
</li>
				</ol>
			</li>
			<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `canplaythrough$et )
◎
The user agent must queue a media element task given the media element to fire an event named canplaythrough at the element.
</li>
			<li>
~IF［
%要素 は`自動再生に適格$でない
］
⇒
~RET
◎
If the element is not eligible for autoplay, then the user agent must abort these substeps.
</li>
			<li>
<p>
任意選択で、次のいずれか一つを行う：
</p>

<div>
				<ul>
					<li>
~RET（何もしない）
</li>
					<li>
下の手続き (A) を走らす
</li>
					<li>
~IF［
%要素 は `video$e 要素である
］
⇒
%要素 が`表示域に交差-$しているかどうか観測し始めた上で，下の規則 (B) に従う
</li>
				</ul>

◎
The user agent may run the following substeps:
◎
↓</div>

<p>
手続き (A) は、次で与えられる：
</p>
				<ol>
					<li>
`paused$mM 属性 ~SET ~F
◎
Set the paused attribute to false.
</li>
					<li>
<p>
~IF［
%要素 の`~posterを示すか$ ~EQ ~T
］：
</p>

<ol><li>%要素 の`~posterを示すか$ ~SET ~F
</li><li>`~tTを時間に合わせる$( %要素 )
</li></ol>

◎
If the element's show poster flag is true, set it to false and run the time marches on steps.
</li>
					<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `play$et )
◎
Queue a media element task given the element to fire an event named play at the element.
</li>
					<li>
`再生-中について通知する$( %要素 )
◎
Notify about playing for the element.
</li>
				</ol>

<p>
規則 (B) は、次で与えられる：
◎
Alternatively, if the element is a video element,＼
</p>
				<ul>
					<li>
%要素 が`表示域に交差-$し始めたときは
⇒
~IF［
その時点で， %要素 は`自動再生に適格$である
］
⇒
上の手続き (A) を走らす
◎
the user agent may start observing whether the element intersects the viewport. When the element starts intersecting the viewport, if the element is still eligible for autoplay, run the substeps above.＼
</li>
					<li>
%要素 は`表示域に交差-$しなくなったときは、任意選択で
⇒
~IF［
その時点で，［
%要素 の`自動再生~可能か$ ~EQ ~T
］~AND［
%要素 は `autoplay$aM 属性を有する
］］
⇒
下の手続き (C) を走らす
◎
Optionally, when the element stops intersecting the viewport, if the can autoplay flag is still true and the autoplay attribute is still specified, run the following substeps:
</li>
				</ul>

<p>
手続き (C) は、次で与えられる：
</p>
				<ol>
					 <li>
`内部~静止-手続き$( %要素 )
◎
Run the internal pause steps and＼
</li>
					<li>
`自動再生~可能か$ ~SET ~T
◎
set the can autoplay flag to true.
</li>
					<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `pause$et )
◎
Queue a media element task given the element to fire an event named pause at the element.
</li>
				</ol>

<p class="note">注記：
［
`自動再生~可能か$ ~EQ ~T
］の間は、
%要素 が`表示域に交差-$［
し始める／しなくなる
］たびに，［
再生する／静止する
］ための手続きも走らされ得る。
◎
The substeps for playing and pausing can run multiple times as the element starts or stops intersecting the viewport, as long as the can autoplay flag is true.
</p>

<p class="note">注記：
~UAは、自動再生を~supportする必要はない。
また、~UAには，そのことに関する利用者の選好を尊守することが示唆される。
作者には、~scriptを利用して動画~再生-を強制するのでなく、
`autoplay$aM 属性を利用して，利用者が欲する挙動に上書きできるようにすることが督促される。
◎
User agents do not need to support autoplay, and it is suggested that user agents honor user preferences on the matter. Authors are urged to use the autoplay attribute rather than using script to force the video to play, so as to allow the user to override the behavior if so desired.
</p>

			</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
~media要素の準備状態は、これらの状態を不連続に~~飛び移ることもあり得る。
例えば， `HAVE_METADATA$mM から
— `HAVE_CURRENT_DATA$mM, `HAVE_FUTURE_DATA$mM を~~飛ばして —
`HAVE_ENOUGH_DATA$mM へ~~直に~~飛ぶなど。
◎
It is possible for the ready state of a media element to jump between these states discontinuously. For example, the state of a media element can jump straight from HAVE_METADATA to HAVE_ENOUGH_DATA without passing through the HAVE_CURRENT_DATA and HAVE_FUTURE_DATA states.
</p>
</div>

<div class="algo">
`readyState@mM
取得子~手続きは
⇒
~RET 上に述べた，コレの現在の準備状態を述べる値
◎
The readyState IDL attribute must, on getting, return the value described above that describes the current ready state of the media element.
</div>

<p>
`autoplay@aM
属性は、`真偽-属性$である。
在るときは、~UAは（上の~algoで述べたように），可能になり次第，`~media資源$の再生を自動的に始めることになる。
【！ ＊？without stopping】
◎
The autoplay attribute is a boolean attribute. When present, the user agent (as described in the algorithm described herein) will automatically begin playback of the media resource as soon as it can do so without stopping.
</p>

<p class="note">注記：
作者には、~scriptを利用して自動的な再生を誘発せずに
`autoplay$aM 属性を利用することが督促される。
そうすれば利用者は自動的な再生を欲さないとき
— 例： ~screen~readerを利用しているとき —
には上書きできるようになるので。
作者には、自動的な再生の挙動を全く利用しない代わりに，利用者が再生を明示的に開始するのを~UAに待機させることを考慮することも奨励される。
◎
Authors are urged to use the autoplay attribute rather than using script to trigger automatic playback, as this allows the user to override the automatic playback when it is not desired, e.g. when using a screen reader. Authors are also encouraged to consider not using the automatic playback behavior at all, and instead to let the user agent wait for the user to start playback explicitly.
</p>

<p>
`autoplay@mM
~IDL属性は、
`autoplay$aM 内容~属性を`反映する$モノトスル。
◎
The autoplay IDL attribute must reflect the content attribute of the same name.
</p>

				</section>
				<section id="playing-the-media-resource">
<h5 title="Playing the media resource">4.8.12.8. ~media資源の再生-法</h5>

<dl class="domintro">

	<dt>%media.`paused$mM</dt>
	<dd>
再生は静止されて［
いれば ~T ／
いなければ ~F
］を返す。
◎
Returns true if playback is paused; false otherwise.
</dd>

	<dt>%media.`ended$mM</dt>
	<dd>
再生は`~media資源$の終端に［
達したならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if playback has reached the end of the media resource.
</dd>

	<dt>%media.`defaultPlaybackRate$mM [ = %value ]</dt>
	<dd>
利用者が`~media資源$を早送り／逆行していないときの，再生の既定の~rateを返す。
◎
Returns the default rate of playback, for when the user is not fast-forwarding or reversing through the media resource.
</dd>
	<dd>
設定して，再生の既定の~rateを変更できる。
◎
Can be set, to change the default rate of playback.
</dd>
	<dd>
この既定の~rateは，再生には直接的な効果はないが、利用者が早送り~modeに切替えた後に通常の再生~modeに戻ったときは，再生~rateも既定の~rateに戻ることになることが期待される。
◎
The default rate has no direct effect on playback, but if the user switches to a fast-forward mode, when they return to the normal playback mode, it is expected that the rate of playback will be returned to the default rate of playback.
</dd>

	<dt>%media.`playbackRate$mM [ = %value ]</dt>
	<dd>
現在の再生~rateを返す。
通常の速度は 1.0 。
◎
Returns the current rate playback, where 1.0 is normal speed.
</dd>
	<dd>
設定して，再生の~rateを変更できる。
◎
Can be set, to change the rate of playback.
</dd>

	<dt>%media.`preservesPitch$mM</dt>
	<dd>
`playbackRate$mM （再生~rate）が 1.0 でない間も，音高を保全するよう調整されるならば ~T を返す。
既定では ~T を返す。
◎
Returns true if pitch-preserving algorithms are used when the playbackRate is not 1.0. The default value is true.
</dd>
	<dd>
~F に設定して、`~media資源$の音声の音高が `playbackRate$mM に応じて変化するようにさせられる。
これは、審美的または処理能の理由で有用になる。
◎
Can be set to false to have the media resource's audio pitch change up or down depending on the playbackRate. This is useful for aesthetic and performance reasons.
</dd>

	<dt>%media.`played$mM</dt>
	<dd>
~UAが再生した`~media資源$の範囲たちを表現する， `TimeRanges$I ~objを返す。
◎
Returns a TimeRanges object that represents the ranges of the media resource that the user agent has played.
</dd>

	<dt>%media.`play()$mM</dt>
	<dd>
`paused$mM 属性を ~F に設定する。
加えて、必要とされれば，`~media資源$を読込んで再生を始める。
再生が終止していた場合、始端から開始し直すことになる。
◎
Sets the paused attribute to false, loading the media resource and beginning playback if necessary. If the playback had ended, will restart it from the start.
</dd>

	<dt>%media.`pause()$mM</dt>
	<dd>
`paused$mM 属性を ~T に設定する。
加えて、必要とされれば，`~media資源$を読込む。
◎
Sets the paused attribute to true, loading the media resource if necessary.
</dd>
</dl>

<p>
`paused@mM
~IDL属性は、コレは静止されているかどうかを表現する。
初期~時には ~T になるモノトスル。
◎
The paused attribute represents whether the media element is paused or not. The attribute must initially be true.
</p>

<div class="algo">
<p>
`~media要素$は、次のいずれかを満たしている間は，
`阻まれて@
いるとされる：
</p>

<ul ><li>`readyState$mM 属性 ~IN {
`HAVE_NOTHING$mM,
`HAVE_METADATA$mM,
`HAVE_CURRENT_DATA$mM
}
</li><li>`利用者~対話~用に静止され$ている
</li><li>`帯域内~内容~用に静止され$ている
</li></ul>
◎
A media element is a blocked media element if its readyState attribute is in the HAVE_NOTHING state, the HAVE_METADATA state, or the HAVE_CURRENT_DATA state, or if the element has paused for user interaction or paused for in-band content.
</div>

<div class="algo">
<div class="p">
<p>
`~media要素$は、次をすべて満たしている間は，
`再生-中であり得る@
とされる：
</p>

<ul><li>`paused$mM 属性 ~EQ ~F
</li><li>`再生は終止して$いない
</li><li>再生は`~errorに因り停止され$ていない
</li><li>`阻まれて$いない
</li></ul>
◎
A media element is said to be potentially playing when its paused attribute is false, the element has not ended playback, playback has not stopped due to errors, and the element is not a blocked media element.
</div>

<p class="note">注記：
`再生-中であり得る$要素は、［
その `readyState$mM 属性が `HAVE_FUTURE_DATA$mM 未満の値に変化した
］ことに因る結果，再生を停止したときには， `waiting$et ~eventが
<a href="#fire-waiting-when-waiting">発火され得る</a>。
◎
A waiting DOM event can be fired as a result of an element that is potentially playing stopping playback due to its readyState attribute changing to a value lower than HAVE_FUTURE_DATA.
</p>
</div>

<div class="algo">
<p>
`~media要素$は、次をすべて満たしている間は，
`自動再生に適格@
とされる：
◎
A media element is said to be eligible for autoplay when all of the following conditions are met:
</p>

<ul>
	<li>
`自動再生~可能か$ ~EQ ~T
◎
Its can autoplay flag is true.
</li>
	<li>
`paused$mM 属性 ~EQ ~T
◎
Its paused attribute is true.
</li>
	<li>
`autoplay$aM 属性を有している
◎
It has an autoplay attribute specified.
</li>
	<li>
`閲覧文脈~sandbox化( 自動的な特能 )~flag$ ~NIN 要素の`~node文書$の`作動中の~sandbox法~flag集合$
◎
Its node document's active sandboxing flag set does not have the sandboxed automatic features browsing context flag set.
</li>
	<li>
要素の`~node文書$には `autoplay$l 特能の`利用は許容されて$いる
◎
Its node document is allowed to use the "autoplay" feature.
</li>
</ul>
</div>

<div class="algo">
<p>
`~media要素$は、［
~UA, および~systemが現在の文脈において~media再生を許容する
］ならば，
`再生は許容されて@
いるとされる。
◎
A media element is said to be allowed to play if the user agent and the system allow media playback in the current context.
</p>

<p class="note">注記：
例えば~UAは、［
`~media要素$の `Window^I の`一過な作動化？$ ~EQ ~T
］ときに限り，再生を許容することもできるが、`消音-$されている間は，例外的に再生を許容することもできる。
◎
For example, a user agent could allow playback only when the media element's Window object has transient activation, but an exception could be made to allow playback while muted.
</p>

</div>

<div class="algo">
<p>
`~media要素$は、次のすべてを満たしている間は，
`再生は終止して@
いるとされる：
◎
A media element is said to have ended playback when:
</p>

<ul>
	<li>
`readyState$mM 属性 ~GTE `HAVE_METADATA$mM
◎
The element's readyState attribute is HAVE_METADATA or greater, and
</li>
	<li>
<p>
次のいずれかを満たしている：
◎
Either:
</p>
		<ul>
			<li>
<p>
次のすべてを満たしている：
</p>

				<ul>
					<li>
`現在の再生~位置$は`~media資源$の終端にある
◎
The current playback position is the end of the media resource, and
</li>
					<li>
`再生~方向$ ~EQ 順方向
◎
The direction of playback is forwards, and
</li>
					<li>
`loop$aM 属性を有していない
◎
The media element does not have a loop attribute specified. 
</li>
				</ul>
			</li>
			<li>
<p>
次のすべてを満たしている：
◎
Or:
</p>
			<ul>
				<li>
`現在の再生~位置$は`アリな最も早い位置$である
◎
The current playback position is the earliest possible position, and
</li>
				<li>
`再生~方向$ ~EQ 逆方向
◎
The direction of playback is backwards. 
</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
</div>

<div class="algo">
`ended@mM
取得子~手続きは
⇒
~RET ［
最後に`~event~loop$の`最初の段$に達した時点で 次が満たされていたならば ~T ／
~ELSE_ ~F
］
⇒
［
コレの`再生は終止して$いる
］~AND［
コレの`再生~方向$ ~EQ 順方向
］
◎
The ended attribute must return true if, the last time the event loop reached step 1, the media element had ended playback and the direction of playback was forwards, and false otherwise.
</div>

<div class="algo">
<p>
`~media要素$は、次をすべて満たしている間は，
`~errorに因り停止され@
ているとされる：
</p>
<ul><li>`readyState$mM 属性 ~GTE `HAVE_METADATA$mM
</li><li>~UAは要素の`~media~data$の処理している間に
<a href="#non-fatal-media-error">致命的でない~errorに遭遇した</a>
</li><li>その~errorに因り，`現在の再生~位置$にある内容を再生できなくなった
</li></ul>
◎
A media element is said to have stopped due to errors when the element's readyState attribute is HAVE_METADATA or greater, and the user agent encounters a non-fatal error during the processing of the media data, and due to that error, is not able to play the content at the current playback position.
</div>

<div class="algo">
<p>
`~media要素$は、次をすべて満たしている間は，
`利用者~対話~用に静止され@
ているとされる：
</p>

<ul><li>`paused$mM 属性 ~EQ ~F
</li><li>`readyState$mM 属性 ~IN { `HAVE_FUTURE_DATA$mM, `HAVE_ENOUGH_DATA$mM }
</li><li>`~media資源$内の［
利用者が再生を継続するかどうか選択する必要がある
］地点に達した
</li></ul>
◎
A media element is said to have paused for user interaction when its paused attribute is false, the readyState attribute is either HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA and the user agent has reached a point in the media resource where the user has to make a selection for the resource to continue.
</div>

<p>
`~media要素$は、`再生は終止して$いると同時に`利用者~対話~用に静止され$ていることもあり得る。
◎
It is possible for a media element to have both ended playback and paused for user interaction at the same time.
</p>

<div class="algo">
<p>
`再生-中であり得る$`~media要素$ %要素 が`利用者~対話~用に静止され$たため，再生-を停止したときは、次を行うモノトスル
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `timeupdate$et )
◎
When a media element that is potentially playing stops playing because it has paused for user interaction, the user agent must queue a media element task given the media element to fire an event named timeupdate at the element.
</p>
</div>

<div class="algo">
<p>
`~media要素$は、次をすべて満たしている間は，
`帯域内~内容~用に静止され@
ているとされる：
</p>

<ul><li>`paused$mM 属性 ~EQ ~F
</li><li>`readyState$mM 属性 ~IN { `HAVE_FUTURE_DATA$mM, `HAVE_ENOUGH_DATA$mM }
</li><li>~UAは、次のいずれかを再生するために，`~media資源$の再生を休止している：
	<ul><li>`~media資源$に一時的に留められた，長さ 0 でない内容
	</li><li>`~media資源$のある区分に一時的に留められた，その区分より長い内容
	</li></ul>
</li></ul>
◎
A media element is said to have paused for in-band content when its paused attribute is false, the readyState attribute is either HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA and the user agent has suspended playback of the media resource in order to play content that is temporally anchored to the media resource and has a nonzero length, or to play content that is temporally anchored to a segment of the media resource but has a length longer than that segment.
</div>

<p class="example">
`~media要素$が`帯域内~内容~用に静止され$ることになる例としては、
~UAが外部の~WebVTT~fileから `Descriptions$st を再生していて、ある~cue用に生成された合成された発話の長さが`開始~時刻$tCから`終了~時刻$tCまでの時間より長い場合が挙げられる。
◎
One example of when a media element would be paused for in-band content is when the user agent is playing audio descriptions from an external WebVTT file, and the synthesized speech generated for a cue is longer than the time between the text track cue start time and the text track cue end time.
</p>

<hr>

<div class="algo">
<p id="reaches-the-end">
`~media要素$ %要素 の［
`再生~方向$ ~EQ 順方向
］の下で， %要素 の`現在の再生~位置$が`~media資源$の終端に達したときは、次の手続きに従うモノトスル：
◎
When the current playback position reaches the end of the media resource when the direction of playback is forwards, then the user agent must follow these steps:
</p>

<ol>
	<li>
<p>
~IF［
%要素 は `loop$aM 属性を有する
］：
</p>

<ol><li>`~seekする$( `~media資源$の`アリな最も早い位置$ )
</li><li>~RET
</li></ol>

◎
If the media element has a loop attribute specified, then seek to the earliest possible position of the media resource and return.
</li>
	<li>
~Assert：
上で定義したように， %要素 の `ended$mM ~IDL属性は、`~event~loop$が`最初の段$に戻った時点から ~T を返すようになる。
◎
As defined above, the ended IDL attribute starts returning true once the event loop returns to step 1.
</li>
	<li>
<p>
次を走らす`~media~taskを~queueする$( %要素 )：
◎
Queue a media element task given the media element and the following steps:
</p>
		<ol>
			<li>
`~eventを発火する$( %要素, `timeupdate$et )
◎
Fire an event named timeupdate at the media element.
</li>
			<li>
<p>
~IF［
%要素 の`再生は終止して$いる
］~AND［
%要素 の`再生~方向$ ~EQ 順方向
］~AND［
%要素 の `paused$mM ~EQ ~F
］：
◎
If the media element has ended playback, the direction of playback is forwards, and paused is false, then:
</p>
				<ol>
					<li>
%要素 の `paused$mM 属性 ~SET ~T
◎
Set the paused attribute to true.
</li>
					<li>
`~eventを発火する$( %要素, `pause$et )
◎
Fire an event named pause at the media element.
</li>
					<li>
`再生待ち~promiseたちを却下する$( %要素 の`再生待ち~promiseたちを取り出す$, `AbortError$E 例外 )
◎
Take pending play promises and reject pending play promises with the result and an "AbortError" DOMException.
</li>
				</ol>
			</li>
			<li>
`~eventを発火する$( %要素, `ended$et )
◎
Fire an event named ended at the media element.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
［
`再生~方向$ ~EQ 逆方向
］の下で，`現在の再生~位置$が`~media資源$ %要素 の`アリな最も早い位置$に達した†ときは、次を行うモノトスル
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `timeupdate$et )
◎
When the current playback position reaches the earliest possible position of the media resource when the direction of playback is backwards, then the user agent must only queue a media element task given the media element to fire an event named timeupdate at the element.
</p>

<p class="note">注記†：
この “達した” は、通常の再生によるものに限られない。
一例として、`~seeking$を介しても達し得る。
◎
The word "reaches" here does not imply that the current playback position needs to have changed during normal playback; it could be via seeking, for instance.
</p>
</div>

<hr>

<div class="algo">
<p>
`defaultPlaybackRate@mM
属性は、`~media資源$に欲される再生-速度を その内在的~速度からの倍数として与える。
その：
◎
The defaultPlaybackRate attribute gives the desired speed at which the media resource is to play, as a multiple of its intrinsic speed. The attribute is mutable:＼
</p>
<ul>
	<li>
取得子~手続きは、最後に設定された値を返す
— 初期~時には 1.0 に設定されるとする。
◎
on getting it must return the last value it was set to, or 1.0 if it hasn't yet been set;＼
</li>
	<li>
設定子~手続きは、この属性を所与の値に設定する。
◎
on setting the attribute must be set to the new value.
</li>
</ul>

<p class="note">注記：
`defaultPlaybackRate$mM は、利用者に`~UIを公開する$ときに~UAにより利用される。
◎
The defaultPlaybackRate is used by the user agent when it exposes a user interface to the user.
</p>
</div>

<div class="algo">
<p>
`playbackRate@mM
属性は、実効~再生~rateを，`~media資源$の内在的~速度の倍数として与える
— それが，この資源を再生する速度になる。
この値 ~NEQ `defaultPlaybackRate$mM の場合、［
利用者は［
高速な順方向／低速~motion
］再生などの特能を利用している
］ことを含意する。
その：
◎
The playbackRate attribute gives the effective playback rate, which is the speed at which the media resource plays, as a multiple of its intrinsic speed. If it is not equal to the defaultPlaybackRate, then the implication is that the user is using a feature such as fast forward or slow motion playback. The attribute is mutable:＼
</p>
<ul>
	<li>
取得子~手続きは、最後に設定された値を返す
— 初期~時には 1.0 に設定されているとする。
◎
on getting it must return the last value it was set to, or 1.0 if it hasn't yet been set;＼
</li>
	<li>
<p>
設定子~手続きは：
◎
on setting, the user agent must follow these steps:
</p>
		<ol>
			<li>
~IF［
~UAは 所与の値を~supportしない
］
⇒
~THROW `NotSupportedError$E
◎
If the given value is not supported by the user agent, then throw a "NotSupportedError" DOMException.
</li>
			<li>
`playbackRate$mM ~SET 所与の値
◎
Set playbackRate to the new value, and＼
</li>
			<li>
~IF［
コレは`再生-中であり得る$
］
⇒
再生~速度を変更する
◎
if the element is potentially playing, change the playback speed.
</li>
		</ol>
	</li>
</ul>
</div>

<p id="rateUpdate">
`~media要素$ %要素 の
［
`defaultPlaybackRate$mM ／
`playbackRate$mM
］属性の値が変化したときは（~scriptにより設定されようが，~UAにより直に変更されようが（例：利用者からの制御に呼応して））、~UAは，次に従うモノトスル：
◎
When the defaultPlaybackRate or playbackRate attributes change value (either by being set by script or by being changed directly by the user agent, e.g. in response to user control) the user agent must
</p>
<ul>
	<li class="algo">
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `ratechange$et )
◎
queue a media element task given the media element to fire an event named ratechange at the media element.＼
</li>
	<li>
再生が知覚-可能なほど途切れたり消音されないよう，滑らかに処理する。
【特に、音高を保全している場合。】
◎
The user agent must process attribute changes smoothly and must not introduce any perceivable gaps or muting of playback in response.
</li>
</ul>

<div class="p">
<p>
`preservesPitch@mM
属性は、再生の間，音声は元の音高が保全されるよう調整されるかどうかを表現する（ ~T ならば保全される）：
</p>
<ul>
	<li class="algo">
取得子~手続きは、最後に設定された値を返す
— 初期~時には ~T に設定されるモノトスル。
</li>
	<li class="algo">
設定子~手続きは、この属性を所与の値に設定する。
再生-中に値が変更されても、再生が知覚-可能なほど途切れたり消音されないよう切替えるモノトスル。
</li>
</ul>
◎
The preservesPitch getter steps are to return true if a pitch-preserving algorithm is in effect during playback. The setter steps are to correspondingly switch the pitch-preserving algorithm on or off, without any perceivable gaps or muting of playback. By default, such a pitch-preserving algorithm must be in effect (i.e., the getter will initially return true).
</div>

<hr>

<div class="algo">
<p>
`played@mM
取得子~手続きは
⇒
~RET 次を表現する，静的かつ`正規化-済み$な新たな `TimeRanges$I ~obj
⇒
現時点における，コレの`~media資源$の`~media時列線$上の［
通常の再生の間に、通例的に`現在の再生~位置$が単調に増加して達した，一連の範囲
］
◎
The played attribute must return a new static normalized TimeRanges object that represents the ranges of points on the media timeline of the media resource reached through the usual monotonic increase of the current playback position during normal playback, if any, at the time the attribute is evaluated.
</p>

<p class="warning">
属性~取得子が毎回 新たな~objを返すのは不良な~patternであるが、今更それを変更するのは高くつくので，そうなっている。
そのようなふるまいは、新たな~APIには複製されない。
◎
Returning a new object each time is a bad pattern for attribute getters and is only enshrined here as it would be costly to change it. It is not to be copied to new APIs.
</p>
</div>

<hr>

<p>
各
`~media要素$は
`再生待ち~promise~list@
を持つ
— 初期~時には空になるモノトスル。
◎
Each media element has a list of pending play promises, which must initially be empty.
</p>

<div class="algo">
<p>
`~media要素$ %要素 の
`再生待ち~promiseたちを取り出す@
ときは、次を走らすモノトスル：
◎
To take pending play promises for a media element, the user agent must run the following steps:
</p>

<ol>
	<li>
%~promise~list ~LET %要素 の`再生待ち~promise~list$の複製
◎
Let promises be an empty list of promises.
◎
Copy the media element's list of pending play promises to promises.
</li>
	<li>
%要素 の`再生待ち~promise~list$を空にする
◎
Clear the media element's list of pending play promises.
</li>
	<li>
~RET %~promise~list
◎
Return promises.
</li>
</ol>
</div>

<div class="algo">
<p>
`~media要素$用の
`再生待ち~promiseたちを解決する@
ときは、所与の
( ~promise~list %~promise~list )
に対し，次を走らすモノトスル
⇒
%~promise~list を成す
~EACH( %~promise )
に対し
⇒
`undefined^jv で %~promise を解決する
◎
To resolve pending play promises for a media element with a list of promises promises, the user agent must resolve each promise in promises with undefined.
</p>
</div>

<div class="algo">
<p>
`~media要素$用の
`再生待ち~promiseたちを却下する@
ときは、所与の
( ~promise~list %~promise~list, 例外~名 %~error ) 
に対し，次を走らすモノトスル
⇒
%~promise~list を成す
~EACH( %~promise )
に対し
⇒
%~error 例外で %~promise を却下する
◎
To reject pending play promises for a media element with a list of promise promises and an exception name error, the user agent must reject each promise in promises with error.
</p>
</div>

<div class="algo">
<p>
`再生-中について通知する@
ときは、所与の
( `~media要素$ %要素 )
に対し，次を走らすモノトスル：
◎
To notify about playing for a media element, the user agent must run the following steps:
</p>

<ol>
	<li>
%~promise~list ~LET
%要素 の`再生待ち~promiseたちを取り出す$
◎
Take pending play promises and let promises be the result.
</li>
	<li>
<p>
次を走らす`~media~taskを~queueする$( %要素 )：
◎
Queue a media element task given the element and the following steps:
</p>
		<ol>
			<li>
`~eventを発火する$( %要素, `playing$et )
◎
Fire an event named playing at the element.
</li>
			<li>
`再生待ち~promiseたちを解決する$( %~promise~list )
◎
Resolve pending play promises with promises.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`play()@mM
~method~手続きは：
◎
When the play() method on a media element is invoked, the user agent must run the following steps.
</p>
<ol>
	<li>
~IF［
コレの`再生は許容されて$いない
］
⇒
~RET `NotAllowedError$E 例外で却下される~promise
◎
If the media element is not allowed to play, return a promise rejected with a "NotAllowedError" DOMException.
</li>
	<li>
%error ~LET コレの `error$mM 属性~値
</li>
	<li>
<p>
~IF［
%error ~NEQ ~NULL
］~AND［
%error の`~code$ ~EQ `MEDIA_ERR_SRC_NOT_SUPPORTED$mE
］
⇒
~RET `NotSupportedError$E 例外で却下される~promise
◎
If the media element's error attribute is not null and its code is MEDIA_ERR_SRC_NOT_SUPPORTED, return a promise rejected with a "NotSupportedError" DOMException.
</p>

<p class="note">注記：
これは、`専用の~media~source失敗~手続き$を走らせたことを意味する。
再生は、［
`~media要素~読込n~algo$により `error$mM 属性が ~NULL にされる
］まで，アリでない。
◎
This means that the dedicated media source failure steps have run. Playback is not possible until the media element load algorithm clears the error attribute.
</p>
	</li>
	<li>
%~promise ~LET 新たな~promise
◎
Let promise be a new promise and＼
</li>
	<li>
`再生待ち~promise~list$に %~promise を付加する
◎
append promise to the list of pending play promises.
</li>
	<li>
`内部~再生-手続き$( コレ )
◎
Run the internal play steps for the media element.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`内部~再生-手続き@
は、所与の
( `~media要素$ %要素【！ media element → 要素 】 )
に対し，次を走らす：
◎
The internal play steps for a media element are as follows:
</p>
<ol>
	<li>
~IF［
%要素 の `networkState$mM 属性~値 ~EQ `NETWORK_EMPTY$mM
］
⇒
%要素 の`資源~選定~algo$を呼出す
◎
If the media element's networkState attribute has the value NETWORK_EMPTY, invoke the media element's resource selection algorithm.
</li>
	<li>
<p>
~IF［
%要素 の`再生は終止して$いる
］~AND［
%要素 の`再生~方向$ ~EQ 順方向
］
⇒
`~seekする$( %要素 の`~media資源$の`アリな最も早い位置$ )
◎
If the playback has ended and the direction of playback is forwards, seek to the earliest possible position of the media resource.
</p>

<p class="note">注記：
これは、~UAに<a href="#seekUpdate">次を行わせることになる</a>
⇒
%要素 に向けて `timeupdate$et ~eventを発火する~taskを~queueする
◎
This will cause the user agent to queue a media element task given the media element to fire an event named timeupdate at the media element.
</p>
	</li>
	<li>
%準備状態 ~LET %要素 の `readyState$mM 属性~値
</li>
	<li>
<p>
~IF［
%要素 の `paused$mM 属性~値 ~EQ ~T
］：
◎
If the media element's paused attribute is true, then:
</p>
		<ol>
			<li>
%要素 の `paused$mM 属性 ~SET ~F
◎
Change the value of paused to false.
</li>
			<li>
<p>
~IF［
%要素 の`~posterを示すか$ ~EQ ~T
］：
◎
If the show poster flag is true,＼
</p>
				<ol>
					<li>
%要素 の`~posterを示すか$ ~SET ~F
◎
set the element's show poster flag to false and＼
</li>
					<li>
`~tTを時間に合わせる$( %要素 )
◎
run the time marches on steps.
</li>
				</ol>
			</li>
			<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `play$et )
◎
Queue a media element task given the media element to fire an event named play at the element.
</li>
			<li>
~IF［
%準備状態 ~IN {
`HAVE_NOTHING$mM,
`HAVE_METADATA$mM,
`HAVE_CURRENT_DATA$mM
}
］
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `waiting$et )
◎
If the media element's readyState attribute has the value HAVE_NOTHING, HAVE_METADATA, or HAVE_CURRENT_DATA, queue a media element task given the media element to fire an event named waiting at the element.
</li>
			<li>
~ELSE（
%準備状態 ~IN {
`HAVE_FUTURE_DATA$mM, 
`HAVE_ENOUGH_DATA$mM
}
）
⇒
`再生-中について通知する$( %要素  )
◎
Otherwise, the media element's readyState attribute has the value HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA: notify about playing for the element.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%準備状態 ~IN {
`HAVE_FUTURE_DATA$mM,
`HAVE_ENOUGH_DATA$mM
}
］：
◎
Otherwise, if the media element's readyState attribute has the value HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA,＼
</p>
		<ol>
			<li>
%~promise~list ~LET %要素 の`再生待ち~promiseたちを取り出す$
◎
take pending play promises and＼
</li>
			<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`再生待ち~promiseたちを解決する$( %~promise~list )
◎
queue a media element task given the media element to resolve pending play promises with the result.
</li>
		</ol>

<p class="note">注記：
%要素 はすでに再生-中にあるが、~queueされた~taskが走る前に，再生待ち~promiseが却下されることもあり得る。
◎
The media element is already playing. However, it's possible that promise will be rejected before the queued task is run.
</p>

	</li>
	<li>
%要素 の`自動再生~可能か$ ~SET ~F
◎
Set the media element's can autoplay flag to false.
</li>
</ol>
</div>

<div class="algo">
~UAは、`~media要素$ %要素 を静止するよう要求されたとき【いつ要求されたものとされる？】は、次を走らすモノトスル
⇒
%要素 上の `pause$mM ~method手続き()
◎
When the pause() method is invoked, and when the user agent is required to pause the media element, the user agent must run the following steps:
</div>

<div class="algo">
<p>
`pause()@mM
~method~手続きは：
◎
↑</p>
<ol>
	<li>
~IF［
コレの`networkState$mM 属性~値 ~EQ `NETWORK_EMPTY$mM
］
⇒
コレの`資源~選定~algo$を呼出す
◎
If the media element's networkState attribute has the value NETWORK_EMPTY, invoke the media element's resource selection algorithm.
</li>
	<li>
`内部~静止-手続き$( コレ )
◎
Run the internal pause steps for the media element.
</li>
</ol>
</div>

<div class="algo">
<p>
`内部~静止-手続き@
は、所与の
( `~media要素$ %要素 )
に対し，次に従う：
◎
The internal pause steps for a media element are as follows:
</p>
<ol>
	<li>
%要素 の`自動再生~可能か$ ~SET ~F
◎
Set the media element's can autoplay flag to false.
</li>
	<li>
~IF［
%要素 の`paused$mM 属性 ~EQ ~T
］
⇒
~RET
◎
If the media element's paused attribute is false, run the following steps:
</li>
	<li>
%要素 の`paused$mM 属性 ~SET ~T
◎
Change the value of paused to true.
</li>
	<li>
%~promise~list ~LET %要素 の`再生待ち~promiseたちを取り出す$
◎
Take pending play promises and let promises be the result.
</li>
	<li>
<p>
次を走らす`~media~taskを~queueする$( %要素 )：
◎
Queue a media element task on the given the media element and the following steps:
</p>
		<ol>
			<li>
`~eventを発火する$( %要素, `timeupdate$et )
◎
Fire an event named timeupdate at the element.
</li>
			<li>
`~eventを発火する$( %要素, `pause$et )
◎
Fire an event named pause at the element.
</li>
			<li>
%要素 の`再生待ち~promiseたちを却下する$( %~promise~list, `AbortError$E 例外 )
◎
Reject pending play promises with promises and an "AbortError" DOMException.
</li>
		</ol>
	</li>
	<li>
%要素 の`公式的な再生~位置$ ~SET `現在の再生~位置$
◎
Set the official playback position to the current playback position.
</li>
</ol>
</div>

<hr>

<p>
要素の
`再生~方向@
は、［
`playbackRate$mM ~GTE 0 ならば順方向 ／
~ELSE_ 逆方向
］とする。
◎
If the element's playbackRate is positive or zero, then the direction of playback is forwards. Otherwise, it is backwards.
</p>

<p id="media-playback">
`~media要素$ %要素 は、［
`再生-中であり得る$
］~AND［
%要素 の`~node文書$は`全部的に作動中$である
］下では、 %要素 の`現在の再生~位置$は，［
`~media時列線$の時計の単位~時間 ~EQ 
( ~mediaの単位~時間 × %要素 の `playbackRate$mM )
］になるように，単調に増加するモノトスル。
（この仕様は，これを常に `増加-^i と記しているが、実際には，要素の `playbackRate$mM が負である場合は`減少-^emになる。）
◎
When a media element is potentially playing and its Document is a fully active Document, its current playback position must increase monotonically at the element's playbackRate units of media time per unit time of the media timeline's clock. (This specification always refers to this as an increase, but that increase could actually be a decrease if the element's playbackRate is negative.)
</p>

<p class="note">注記：
要素の `playbackRate$mM は 0.0 にもなり得る。
その事例では、再生が静止されていなくても`現在の再生~位置$は移動しない（ `paused$mM ~T にはならず， `pause$et ~eventは発火されない）。
◎
The element's playbackRate can be 0.0, in which case the current playback position doesn't move, despite playback not being paused (paused doesn't become true, and the pause event doesn't fire).
</p>

<p class="note">注記：
この仕様は、~UAが適切な再生~rateをどう達成するかは定義しない。
それは、可用な~protocolや~mediaに依存して，概ね可能にもなり得る
— ~UAが~serverと折衝して、~clientが実際に何~frameか［
落さずに済む／補間せずに済む
］よう，~serverに~media~dataを適切な~rateで供してもらえれば（~rateが変更されてから，~serverが~streamの再生~rateを更新するまでの期間は別として）。
◎
This specification doesn't define how the user agent achieves the appropriate playback rate — depending on the protocol and media available, it is plausible that the user agent could negotiate with the server to have the server provide the media data at the appropriate rate, so that (except for the period between when the rate is changed and when the server updates the stream's playback rate) the client doesn't actually have to drop or interpolate any frames.
</p>

<p>
どの時点であれ，~UAが`安定~状態を待受ける$ときは、`公式的な再生~位置$は，`現在の再生~位置$に設定するモノトスル。
◎
Any time the user agent provides a stable state, the official playback position must be set to the current playback position.
</p>

<p>
次のいずれかに該当する間は、音声は`消音-$するモノトスル。
◎
↓</p>
<ul>
	<li>
`再生~方向$ ~EQ 逆方向
◎
While the direction of playback is backwards, any corresponding audio must be muted.＼
</li>
	<li>
要素の `playbackRate$mM は，~UAが音声を有用に再生できないほど低過ぎるか高過ぎる
◎
While the element's playbackRate is so low or so high that the user agent cannot play audio usefully, the corresponding audio must also be muted.＼
</li>
</ul>

<p>
［
要素の `playbackRate$mM ~NEQ 1.0
］の間は、音声を速めたり遅めるときに［
元の音高を保全するような音高~調整
］を［
要素の `preservesPitch$mM
］が［
~T をとる間は適用する／
~F をとる間は適用しない
］モノトスル。
◎
If the element's playbackRate is not 1.0 and preservesPitch is true, the user agent must apply pitch adjustment to preserve the original pitch of the audio. Otherwise, the user agent must speed up or slow down the audio without any pitch adjustment.
</p>

<p>
`~media要素$が`再生-中であり得る$ときは、その音声~dataは，要素の`実効~media音量$で`現在の再生~位置$に同期するよう再生するモノトスル。
~UAは、`~event~loop$が最後に`最初の段$に達した時点で可能化されている音声~trackからの音声を再生するモノトスル。
◎
When a media element is potentially playing, its audio data played must be synchronized with the current playback position, at the element's effective media volume. The user agent must play the audio from audio tracks that were enabled when the event loop last reached step 1.
</p>

<p>
`~media要素$用の音声は、`再生-中であり得る$ときを除き，再生されないモノトスル。
◎
When a media element is not potentially playing, audio must not play for the element.
</p>

<p>
`~media要素$が［
`再生-中であり得る$
］~AND［
`文書~内$にない
］間は、動画は再生しないモノトスルが、音声~成分は，あるならば再生するベキである。
~media要素は、それへの参照がすべて除去されたとしても，それだけでは再生-は停止しないモノトスル
— ~media要素が~garbage収集されてもヨイのは、それ以上~要素の音声を再生できなくなって以降に限られる。
◎
Media elements that are potentially playing while not in a document must not play any video, but should play any audio component. Media elements must not stop playing just because all references to them have been removed; only once a media element is in a state where no further audio could ever be played by that element may the element be garbage collected.
</p>

<p class="note">注記：
要素への明示的な参照は存在しなくとも，要素が音声を再生することはあり得る
— そのような要素は、依然として能動的に再生していない場合でも：
一例として、［
静止されなくなったが，内容を~bufferする待機-中に停滞したか、あるいは，~bufferしていて再生を始めるような `suspend$et ~event~listenerがある
］こともある。
~media要素の`~media資源$に音声~trackが伴われない場合でも、その`~media資源$を変更するような~event~listenerがあった場合，最終的に再び音声を再生できることもある。
◎
It is possible for an element to which no explicit references exist to play audio, even if such an element is not still actively playing: for instance, it could be unpaused but stalled waiting for content to buffer, or it could be still buffering, but with a suspend event listener that begins playback. Even a media element whose media resource has no audio tracks could eventually play audio again if it had an event listener that changes the media resource.
</p>

<hr>

<p class="trans-note">【
この箇所に記されていた`~tT$に関連な記述（ “`~tTを時間に合わせる$” ~algo他）は、編集の都合により，
<a href="~HEtrack#playing-the-media-resource">別~page</a>にて。
】</p>

<hr>

<p class="note">注記：
`~media要素$の`~node文書$が`全部的に作動中$でなくなった場合、文書が再び作動中になるまで，<a href="#media-playback">再生は停止する</a>ことになる。
◎
If the media element's node document stops being a fully active document, then the playback will stop until the document is active again.
</p>

<div class="algo">
<p>
`~media要素$ %要素 が`文書から除去され$たときは、次を走らすモノトスル：
◎
When a media element is removed from a Document, the user agent must run the following steps:
</p>

<ol>
	<li>
<p>
次の手続きを`同期区間$として，`安定~状態を待受ける$（これは、 %要素 を除去した`~task$を継続できるようにする）：
◎
Await a stable state, allowing the task that removed the media element from the Document to continue. The synchronous section consists of all the remaining steps of this algorithm. (Steps in the synchronous section are marked with ⌛.)
</p>
		<ol>
			<li>
~IF［
%要素 は`文書~内$にない
］
⇒
~RET
◎
⌛ If the media element is in a document, return.
</li>
			<li>
`内部~静止-手続き$( %要素 )
◎
⌛ Run the internal pause steps for the media element.
</li>
		</ol>
	</li>
</ol>
</div>

				</section>
				<section id="seeking">
<h5 title="Seeking">4.8.12.9. ~seek法</h5>

<dl class="domintro">

	<dt>%media.`seeking$mM</dt>
	<dd>
~UAは現在~seekしているならば ~T を返す。
◎
Returns true if the user agent is currently seeking.
</dd>

	<dt>%media.`seekable$mM</dt>
	<dd>
`~media資源$の一連の範囲のうち，~UAが~seek可能なものからなる~listを表現する，
`TimeRanges$I ~objを返す。
◎
Returns a TimeRanges object that represents the ranges of the media resource to which it is possible for the user agent to seek.
</dd>

	<dt>%media.`fastSeek(time)$mM</dt>
	<dd>
精度と引き換えに速度を得るよう，アリな限り高速に、所与の %time の近くへ~seekする。
（精確な時刻へ~seekするためには `currentTime$mM 属性を利用すること。）
◎
Seeks to near the given time as fast as possible, trading precision for speed. (To seek to a precise time, use the currentTime attribute.)
</dd>
	<dd>
~media資源がまだ読込まれてない場合、何もしない。
◎
This does nothing if the media resource has not been loaded.
</dd>
</dl>

<p>
`seeking@mM
属性は、初期~時には ~F になるモノトスル。
◎
The seeking attribute must initially have the value false.
</p>

<div class="algo">
`fastSeek(time)@mM
~method~手続きは
⇒
`~seekする$( %time, ~T（ “速度優先” ） )
◎
The fastSeek(time) method must seek to the time given by time, with the approximate-for-speed flag set.
</div>

<div class="algo">
<p>
`~media要素$ %要素 の`~media資源$ %資源 内の特定0の再生~位置へ
`~seekする@
ときは、所与の
( %新たな再生~位置, 真偽値 %速度優先か（省略時は ~F ） )
に対し，次を走らすモノトスル：
<!-- 
This algorithm interacts ...
この~algoは、~event~loopの仕組みと~closelyヤリトリする。
特に，その同期区間は、~event~loop ~algoの一部として誘発される。
その区間内の段には ⌛ が付与される。
 -->
◎
When the user agent is required to seek to a particular new playback position in the media resource, optionally with the approximate-for-speed flag set, it means that the user agent must run the following steps. This algorithm interacts closely with the event loop mechanism; in particular, it has a synchronous section (which is triggered as part of the event loop algorithm). Steps in that section are marked with ⌛.
</p>

<ol>
	<li>
%要素 の`~posterを示すか$ ~SET ~F
◎
Set the media element's show poster flag to false.
</li>
	<li>
~IF［
%要素 の`readyState$mM ~EQ `HAVE_NOTHING$mM
］
⇒
~RET
◎
If the media element's readyState is HAVE_NOTHING, return.
</li>
	<li>
~IF［
%要素 の `seeking$mM 属性 ~EQ ~T
］
⇒
この~algoの別の~instanceがすでに走っている
— その~instanceを，それが完了するのを待機せずに中止する
◎
If the element's seeking IDL attribute is true, then another instance of this algorithm is already running. Abort that other instance of the algorithm without waiting for the step that it is running to complete.
</li>
	<li>
%要素 の `seeking$mM 属性 ~SET ~T
◎
Set the seeking IDL attribute to true.
</li>
	<li>
~IF［
この~algoは、~scriptによる ~IDL［
~method~call ／ 属性の設定子
］に呼応して呼出されている
］
⇒
~RET （その~scriptを継続させる）
— ただし
⇒
この手続きの以降も`並列的$に走らす
— ただし
⇒
この~algoの以下に現れる，`安定~状態を待受ける$箇所は、この~algoの別の~instanceが呼出された場合，それにより いつでも中止され得る。
◎
If the seek was in response to a DOM method call or setting of an IDL attribute, then continue the script. The remainder of these steps must be run in parallel. With the exception of the steps marked with ⌛, they could be aborted at any time by another instance of this algorithm being invoked.
</li>
	<li>
~IF［
%新たな再生~位置 ~GT %資源 の終端
］
⇒
%新たな再生~位置 ~SET %資源 の終端
◎
If the new playback position is later than the end of the media resource, then let it be the end of the media resource instead.
</li>
	<li>
~IF［
%新たな再生~位置 ~LT `アリな最も早い位置$
］
⇒
%新たな再生~位置 ~SET `アリな最も早い位置$
◎
If the new playback position is less than the earliest possible position, let it be that position instead.
</li>
	<li>
%現~位置 ~LET `現在の再生~位置$
◎
↓</li>
	<li>
%範囲~list ~LET %要素 の `seekable$mM 属性~値
◎
↓</li>
	<li>
<p>
~IF［
%範囲~list は空である
］：
</p>
<ol ><li>%要素 の `seeking$mM ~SET ~F
</li><li>~RET
</li></ol>
◎
↓</li>
	<li>
<p>
~IF［
【！ (possibly now changed)】
%新たな再生~位置 は %範囲~list 内のどの範囲にも入らない
］
⇒
%新たな再生~位置 ~SET ［［
%範囲~list 内の各 範囲の始端, 終端
］のうち， %新たな再生~位置 に最も近いもの†
］のうち， %現~位置 に最も近い位置
</p>
<p>（†
一意に決まるとは限らない
— %新たな再生~位置 がある範囲の終端と次の範囲の始端のちょうど真中にある場合、その終端, 始端の 2 つがこの条件を満たす
）</p>
◎
If the (possibly now changed) new playback position is not in one of the ranges given in the seekable attribute, then let it be the position in one of the ranges given in the seekable attribute that is the nearest to the new playback position. If two positions both satisfy that constraint (i.e. the new playback position is exactly in the middle between two ranges in the seekable attribute) then use the position that is closest to the current playback position. If there are no ranges given in the seekable attribute then set the seeking IDL attribute to false and return.
</li>
	<li>
<p>
~IF［
%速度優先か ~EQ ~T
］
⇒
%新たな再生~位置 を調整する
— 再生を速やかに再開できる, かつ
結果の %調整-済み位置 が次を満すように：
◎
If the approximate-for-speed flag is set, adjust the new playback position to a value that will allow for playback to resume promptly.＼
</p>
		<ul>
			<li>
%新たな再生~位置 ~LT %現~位置 のときは
⇒
%調整-済み位置 ~LT %現~位置
◎
If new playback position before this step is before current playback position, then the adjusted new playback position must also be before the current playback position.＼
</li>
			<li>
%新たな再生~位置 ~GT %現~位置 のときは
⇒
%調整-済み位置 ~GT %現~位置
◎
Similarly, if the new playback position before this step is after current playback position, then the adjusted new playback position must also be after the current playback position.
</li>
		</ul>

<p class="example">
例えば~UAは
— 復号する時刻を費やさずに済むよう —
~key~frame近くに留めて、再生を再開する前に，中間の~frameを破棄することもできる。
◎
For example, the user agent could snap to a nearby key frame, so that it doesn't have to spend time decoding then discarding intermediate frames before resuming playback.
</p>
	</li>
	<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `seeking$et )
◎
Queue a media element task given the media element to fire an event named seeking at the element.
</li>
	<li>
<p>
`現在の再生~位置$ ~SET %新たな再生~位置
◎
Set the current playback position to the new playback position.
</p>

<p class="note">注記：
%要素 は~seekingを開始する直前では`再生-中であり得る$であったが，~seekingにより
%要素 の `readyState$mM 属性が `HAVE_FUTURE_DATA$mM 未満の値に変化した場合、
%要素 に向けて， `waiting$et ~eventが
<a href="#fire-waiting-when-waiting">発火される</a>
ことになる。
◎
If the media element was potentially playing immediately before it started seeking, but seeking caused its readyState attribute to change to a value lower than HAVE_FUTURE_DATA, then a waiting event will be fired at the element.
</p>
<p class="note">注記：
この段は，`現在の再生~位置$を設定するので、即時に他の条件を誘発し得る
— 再生において
“<a href="#reaches-the-end">~media資源の終端に達した</a>”
ときに関する規則（~loopingを取扱う~logicの一部）など —
~UAが実際には その位置（次の段にて決定される）用の~media~dataを具現化できるとしても，その前に。
◎
This step sets the current playback position, and thus can immediately trigger other conditions, such as the rules regarding when playback "reaches the end of the media resource" (part of the logic that handles looping), even before the user agent is actually able to render the media data for that position (as determined in the next step).
</p>

<p class="note">注記：
`currentTime$mM 属性は、`現在の再生~位置$ではなく，`公式的な再生~位置$を返す。
したがって、この~algoとは別に，~script実行の前に更新される。
◎
The currentTime attribute returns the official playback position, not the current playback position, and therefore gets updated before script execution, separate from this algorithm.
</p>
	</li>
	<li>
~UAが，［
%新たな再生~位置 に対する`~media~data$が可用かどうかを確立して，その位置を再生するに十分な~dataを復号する
］まで、待機する
◎
Wait until the user agent has established whether or not the media data for the new playback position is available, and, if it is, until it has decoded enough data to play back that position.
</li>
	<li>
<p>
次の一連の段を`同期区間$として，`安定~状態を待受ける$：
◎
Await a stable state. The synchronous section consists of all the remaining steps of this algorithm. (Steps in the synchronous section are marked with ⌛.)
</p>
		<ol>
			<li>
%要素 の `seeking$mM ~IDL属性 ~SET ~F
◎
⌛ Set the seeking IDL attribute to false.
</li>
			<li>
`~tTを時間に合わせる$( %要素 )
◎
⌛ Run the time marches on steps.
</li>
			<li id="seekUpdate">
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `timeupdate$et )
◎
⌛ Queue a media element task given the media element to fire an event named timeupdate at the element.
</li>
			<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `seeked$et )
◎
⌛ Queue a media element task given the media element to fire an event named seeked at the element.
</li>
		</ol>
	</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`seekable@mM
取得子~手続きは
⇒
~RET 次を表現する，静的かつ`正規化-済み$な新たな `TimeRanges$I ~obj
⇒
現時点で~UAが~seekできるような，コレの`~media資源$の一連の範囲
◎
The seekable attribute must return a new static normalized TimeRanges object that represents the ranges of the media resource, if any, that the user agent is able to seek to, at the time the attribute is evaluated.
</p>

<p class="note">注記：
~UAは、`~media資源$内のどこへでも~seekできる場合
— 例えば単純な映画~fileで，~UA, ~serverとも ~HTTP `Range^h 要請を~supportする場合 —
この属性は、次のような 1 個の範囲からなる~objを返すことになる：
始端 ~EQ 最初の~frameの時刻（`アリな最も早い位置$, 概して 0 ）,
終端 ~EQ ［
始端 ~PLUS `duration$mM 属性の値
］（最後の~frameの時刻に等しくなり，正な `Infinity^jv にもなり得る）。
◎
If the user agent can seek to anywhere in the media resource, e.g. because it is a simple movie file and the user agent and the server support HTTP Range requests, then the attribute would return an object with one range, whose start is the time of the first frame (the earliest possible position, typically zero), and whose end is the same as the time of the first frame plus the duration attribute's value (which would equal the time of the last frame, and might be positive Infinity).
</p>

<p class="note">注記：
範囲は、変化し続けるかもしれない。
例えば、~UAが無限~streamにて~sliding-windowを~bufferしている場合。
これは、一例を挙げれば，~live TV を~~流している DVR に見られる挙動である。
◎
The range might be continuously changing, e.g. if the user agent is buffering a sliding window on an infinite stream. This is the behavior seen with DVRs viewing live TV, for instance.
</p>

<p class="warning">
属性~取得子が毎回 新たな~objを返すのは不良な~patternであるが、今更それを変更するのは高くつくので，そうなっている。
そのようなふるまいは、新たな~APIには複製されない。
◎
Returning a new object each time is a bad pattern for attribute getters and is only enshrined here as it would be costly to change it. It is not to be copied to new APIs.
</p>
</div>

<p>
~UAは、何が~seek可能になるかについて，~~相応に柔軟かつ楽観的な~viewを採用するベキである。
~UAはまた、高速な~seek法を可能化するため，アリな所では近過去の内容を~bufferするベキである。
◎
User agents should adopt a very liberal and optimistic view of what is seekable. User agents should also buffer recent content where possible to enable seeking to be fast.
</p>

<p class="example">
一例として、~HTTP `Range^h 要請を~supportしない ある~HTTP~serverから~serveされている巨大な動画~fileを考える。
~browserは、現在および後続の~frame用に得された~dataのみを~bufferすることにより，これを実装する`こともできる^em
— 全く~seekできないことにして（再生を開始し直すことによる始端への~seekは別として）。
しかしながら、これでは拙い実装になる。
高~品質な実装は、内容の最後の数~分を~bufferして（あるいは~storageが十分あればもっと）、利用者が何か面白いものを再~視聴するため，その箇所へすぐに戻れるようにすることに加え、必要とされれば，~fileを始端から再度~読込んで任意の箇所へ~seekできるようにするであろう
— 後者は前者より低速だが、それでも［
より早い，未~bufferの箇所を得るだけのために、動画を開始し直して初めからくまなく視聴する
］よりは簡便になる。
◎
For instance, consider a large video file served on an HTTP server without support for HTTP Range requests. A browser could implement this by only buffering the current frame and data obtained for subsequent frames, never allow seeking, except for seeking to the very start by restarting the playback. However, this would be a poor implementation. A high quality implementation would buffer the last few minutes of content (or more, if sufficient storage space is available), allowing the user to jump back and rewatch something surprising without any latency, and would in addition allow arbitrary seeking by reloading the file from the start if necessary, which would be slower but still more convenient than having to literally restart the video and watch it all the way through just to get to an earlier unbuffered spot.
</p>

<p>
`~media資源$は、内部的に~scriptを含む／対話的なこともあるかもしれない。
したがって`~media要素$は，~~不連続に再生され得る。
これが起こった場合、~UAは，`現在の再生~位置$が不連続に変化する度に，（関連な~eventが発火されるよう）`~seeking$用の~algoが利用されていたかのように動作するモノトスル。
◎
Media resources might be internally scripted or interactive. Thus, a media element could play in a non-linear fashion. If this happens, the user agent must act as if the algorithm for seeking was used whenever the current playback position changes in a discontinuous fashion (so that the relevant events fire).
</p>

				</section>
				<section id="media-resources-with-multiple-media-tracks">
<h5 title="Media resources with multiple media tracks">4.8.12.10. 複数の~media~trackを伴う~media資源</h5>

<p>
`~media資源$には、複数の［
動画／音声
］~trackも埋込まれ得る。
例えば、首な［
動画／音声
］~trackに加えて，［
外国語吹替え ／
~directorによる実況 ／
音述 ／
代替~angle ／
積層された手話
］など。
◎
A media resource can have multiple embedded audio and video tracks. For example, in addition to the primary video and audio tracks, a media resource could have foreign-language dubbed dialogues, director's commentaries, audio descriptions, alternative angles, or sign-language overlays.
</p>

<dl class="domintro">

	<dt>%media.`audioTracks$mM</dt>
	<dd>
`~media資源$に可用な一連の音声~trackを表現している
`AudioTrackList$I ~objを返す。
◎
Returns an AudioTrackList object representing the audio tracks available in the media resource.
</dd>

	<dt>%media.`videoTracks$mM</dt>
	<dd>
`~media資源$に可用な一連の動画~trackを表現している
`VideoTrackList$I ~objを返す。
◎
Returns a VideoTrackList object representing the video tracks available in the media resource.
</dd>
</dl>

<div class="algo">
`audioTracks@mM
取得子~手続きは
⇒
~RET コレの`~media資源$に可用な一連の音声~trackを表現している，`~live$な `AudioTrackList$I ~obj
◎
The audioTracks attribute of a media element must return a live AudioTrackList object representing the audio tracks available in the media element's media resource.
</div>

<div class="algo">
`videoTracks@mM
取得子~手続きは
⇒
~RET コレの`~media資源$に可用な一連の動画~trackを表現している，`~live$な `VideoTrackList$I ~obj
◎
The videoTracks attribute of a media element must return a live VideoTrackList object representing the video tracks available in the media element's media resource.
</div>

<p class="note">注記：
［
`AudioTrackList$I ／ `VideoTrackList$I
］~objは`~media要素$ごとに， 1 個に限られる
— 要素の中に別の`~media資源$が読込まれた場合でも，これらの~objが再利用される（が、［
`AudioTrack$I ／ `VideoTrack$I
］~objはそうでない）。
◎
There are only ever one AudioTrackList object and one VideoTrackList object per media element, even if another media resource is loaded into the element: the objects are reused. (The AudioTrack and VideoTrack objects are not, though.)
</p>

					<section id="audiotracklist-and-videotracklist-objects">
<h6 title="AudioTrackList and VideoTrackList objects">4.8.12.10.1. `AudioTrackList^I ／ `VideoTrackList^I ~obj</h6>

<p>
前~節に定義した属性は［
`AudioTrackList$I ／ `VideoTrackList$I
］~interfaceを利用する。
◎
The AudioTrackList and VideoTrackList interfaces are used by attributes defined in the previous section.
</p>

<pre class="idl">
[Exposed=Window]
interface `AudioTrackList@I : `EventTarget$I {
  readonly attribute unsigned long `length$mA;
  `getter$m `AudioTrack$I (unsigned long %index);
  `AudioTrack$I? `getTrackById$mA(DOMString %id);

  attribute `EventHandler$I `onchange$m;
  attribute `EventHandler$I `onaddtrack$m;
  attribute `EventHandler$I `onremovetrack$m;
};

[Exposed=Window]
interface `AudioTrack@I {
  readonly attribute DOMString `id$mA;
  readonly attribute DOMString `kind$mA;
  readonly attribute DOMString `label$mA;
  readonly attribute DOMString `language$mA;
  attribute boolean `enabled$mA;
};

[Exposed=Window]
interface `VideoTrackList@I : `EventTarget$I {
  readonly attribute unsigned long `length$mV;
  `getter$m `VideoTrack$I (unsigned long %index);
  `VideoTrack$I? `getTrackById$mV(DOMString %id);
  readonly attribute long `selectedIndex$mV;

  attribute `EventHandler$I `onchange$m;
  attribute `EventHandler$I `onaddtrack$m;
  attribute `EventHandler$I `onremovetrack$m;
};

[Exposed=Window]
interface `VideoTrack@I {
  readonly attribute DOMString `id$mV;
  readonly attribute DOMString `kind$mV;
  readonly attribute DOMString `label$mV;
  readonly attribute DOMString `language$mV;
  attribute boolean `selected$mV;
};
</pre>

<dl class="domintro">
	<dt>%media.`audioTracks$mM.`length$mA</dt>
	<dt>%media.`videoTracks$mM.`length$mV</dt>
	<dd>
~list内にある~trackの個数を返す。
◎
Returns the number of tracks in the list.
</dd>

	<dt>%audioTrack = %media.`audioTracks$mM[%index]</dt>
	<dt>%videoTrack = %media.`videoTracks$mM[%index]</dt>
	<dd>
指定された［
`AudioTrack$I, `VideoTrack$I
］~objを返す。
◎
Returns the specified AudioTrack or VideoTrack object.
</dd>

	<dt>%audioTrack = %media.`audioTracks$mM.`getTrackById(id)$mA</dt>
	<dt>%videoTrack = %media.`videoTracks$mM.`getTrackById(id)$mV</dt>
	<dd>
所与の識別子を有する［
`AudioTrack$I, `VideoTrack$I
］~objが［
あれば それ ／
なければ ~NULL
］を返す。
◎
Returns the AudioTrack or VideoTrack object with the given identifier, or null if no track has that identifier.
</dd>

	<dt>%audioTrack.`id$mA</dt>
	<dt>%videoTrack.`id$mV</dt>
	<dd>
所与の~trackの識別子を返す。
これは、形式が`~media素片の構文$を~supportするならば，`素片$urlにて利用できるような識別子にでき、また `getTrackById()^m ~methodにも利用できる。
◎
Returns the ID of the given track. This is the ID that can be used with a fragment if the format supports media fragment syntax, and that can be used with the getTrackById() method.
</dd>

	<dt>%audioTrack.`kind$mA</dt>
	<dt>%videoTrack.`kind$mV</dt>
	<dd>
所与の~trackの分類を返す。
<a href="#dom-TrackList-getKind-categories">アリな~track分類</a>
は、下に与える。
◎
Returns the category the given track falls into. The possible track categories are given below.
</dd>

	<dt>%audioTrack.`label$mA</dt>
	<dt>%videoTrack.`label$mV</dt>
	<dd>
［
所与の~trackの~labelが既知ならばそれ ／
~ELSE_ 空~文字列
］を返す。
◎
Returns the label of the given track, if known, or the empty string otherwise.
</dd>

	<dt>%audioTrack.`language$mA</dt>
	<dt>%videoTrack.`language$mV</dt>
	<dd>
［
所与の~trackの言語が既知ならばそれ ／
~ELSE_ 空~文字列
］を返す。
◎
Returns the language of the given track, if known, or the empty string otherwise.
</dd>

	<dt>%audioTrack.`enabled$mA [ = %value ]</dt>
	<dd>
［
所与の~trackは作動中ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the given track is active, and false otherwise.
</dd>
	<dd>
設定して，この~trackは可能化されるかどうかを変更できる。
複数の音声~trackが同時に可能化された場合、それらは混合される。
◎
Can be set, to change whether the track is enabled or not. If multiple audio tracks are enabled simultaneously, they are mixed.
</dd>

	<dt>%media.`videoTracks$mM.`selectedIndex$mV</dt>
	<dd>
現在~選択されている~trackが［
あれば その~index ／
なければ −1
］を返す。
◎
Returns the index of the currently selected track, if any, or −1 otherwise.
</dd>

	<dt>%videoTrack.`selected$mV [ = %value ]</dt>
	<dd>
［
所与の~trackは作動中ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the given track is active, and false otherwise.
</dd>
	<dd>
設定して，~trackは選択されるかどうかを変更できる。
選択される動画~trackの個数は 0 〜 1 個であり、ある~trackが選択されたときは，前に選択されていた別の~trackは未選択にされる。
◎
Can be set, to change whether the track is selected or not. Either zero or one video track is selected; selecting a new track while a previous one is selected will unselect the previous one.
</dd>
</dl>

<p>
`AudioTrackList$I ~objは、
0 個~以上の音声~trackからなる動的な~listを表現する。
それらの~trackのうち， 0 個~以上を同時に可能化できる。
各~音声~trackは `AudioTrack$I ~objで表現される。
◎
An AudioTrackList object represents a dynamic list of zero or more audio tracks, of which zero or more can be enabled at a time. Each audio track is represented by an AudioTrack object.
</p>

<p>
`VideoTrackList$I ~objは、
0 個~以上の動画~trackからなる動的な~listを表現する。
それらの~trackのうち， 0 〜 1 個を同時に選択できる。
各~動画~trackは `VideoTrack$I ~objで表現される。
◎
A VideoTrackList object represents a dynamic list of zero or more video tracks, of which zero or one can be selected at a time. Each video track is represented by a VideoTrack object.
</p>

<div class="p">
<p>
［
`AudioTrackList$I ／ `VideoTrackList$I
］~obj内の~trackたちの順序は、一貫して，次で定義される `自然な順序^i にするモノトスル：
</p>

<ul ><li>`~media資源$の形式により定義される順序がある場合、その順序。
</li><li>他の場合、`~media資源$内で~trackが宣言された順序。
</li></ul>

◎
Tracks in AudioTrackList and VideoTrackList objects must be consistently ordered. If the media resource is in a format that defines an order, then that order must be used; otherwise, the order must be the relative order in which the tracks are declared in the media resource. The order used is called the natural order of the list.
</div>

<p class="note">注記：
これらの~objを成す各~trackの~indexは、常に~list順に付与され（ 0 が先頭），`~media資源$に動的に~trackが［
追加-／除去-
］されるに伴い変化する。
`~media資源$がまるごと変更された場合、以前の~trackすべては除去され，新たな~trackに置換されることになる。
◎
Each track in one of these objects thus has an index; the first has the index 0, and each subsequent track is numbered one higher than the previous one. If a media resource dynamically adds or removes audio or video tracks, then the indices of the tracks will change dynamically. If the media resource changes entirely, then all the previous tracks will be removed and replaced with new tracks.
</p>

<div class="algo">
<p>
［
`AudioTrackList^I の
`length@mA
／
`VideoTrackList^I の
`length@mV
］取得子~手続きは
⇒
~RET 現時点でコレが表現する~trackの個数
◎
The AudioTrackList length and VideoTrackList length attribute getters must return the number of tracks represented by their objects at the time of getting.
</p>

<p>
コレが`~supportする~prop~index$は、
0 以上, ［
コレが表現する一連の~trackの個数
］未満とする。
◎
The supported property indices of AudioTrackList and VideoTrackList objects at any instant are the numbers from zero to the number of tracks represented by the respective object minus one, if any tracks are represented. If an AudioTrackList or VideoTrackList object represents no tracks, it has no supported property indices.
</p>

<p id="dom-tracklist-item">
コレにおける，所与の~indexに対する`有index~propの値を決定-$するときは、コレ内の~index番の~trackを表現する［
`AudioTrack$I ／ `VideoTrack$I
］~objを返すモノトスル。
◎
To determine the value of an indexed property for a given index index in an AudioTrackList or VideoTrackList object list, the user agent must return the AudioTrack or VideoTrack object that represents the indexth track in list.
</p>
</div>

<div class="algo">
`AudioTrackList^I の
`getTrackById(id)@mA
~method~手続きは
⇒
~RET コレ内に次を満たす `AudioTrack$I ~objは［
在るならば それらのうち（上に定義した，自然な順序で）最初のもの／
無いならば ~NULL
］
⇒
識別子 ~EQ %id
◎
↓</div>

<div class="algo">
`VideoTrackList^I の
`getTrackById(id)@mV
］~method~手続きは
⇒
~RET コレ内に次を満たす `VideoTrack$I ~objは［
在るならば それらのうち（上に定義した，自然な順序で）最初のもの／
無いならば ~NULL
］
⇒
識別子 ~EQ %id
◎
The AudioTrackList getTrackById(id) and VideoTrackList getTrackById(id) methods must return the first AudioTrack or VideoTrack object (respectively) in the AudioTrackList or VideoTrackList object (respectively) whose identifier is equal to the value of the id argument (in the natural order of the list, as defined above). When no tracks match the given argument, the methods must return null.
</div>

<p>
各［
`AudioTrack$I ／ `VideoTrack$I
］~objは、`~media資源$の特定の~trackを表現する。
各~trackは、［
識別子, 分類, ~label, 言語
］を持ち得る。
【！＊いずれも，持たない場合は ε とする】
~trackのこれらの側面は、~trackが存続する限り永続的とする
— ~trackが`~media資源$の［
`AudioTrackList$I ／ `VideoTrackList$I
］~objから除去されても，それらの側面は変化しない。
◎
The AudioTrack and VideoTrack objects represent specific tracks of a media resource. Each track can have an identifier, category, label, and language. These aspects of a track are permanent for the lifetime of the track; even if a track is removed from a media resource's AudioTrackList or VideoTrackList objects, those aspects do not change.
</p>

<p>
加えて，各 `AudioTrack$I ~objは、 ［
可能化されている,
不能化されている
］のいずれかの状態をとり得る。
`AudioTrack$I の作成-時には、不能化されているモノトスル。
`~media資源~fetch~algo$はこれを上書きし得る。
◎
In addition, AudioTrack objects can each be enabled or disabled; this is the audio track's enabled state. When an AudioTrack is created, its enabled state must be set to false (disabled). The resource fetch algorithm can override this.
</p>

<p>
同様に， `VideoTrackList$I ~objにおいては、
0 個または 1 個の `VideoTrack$I ~objを選択できる。
【！＊ video track's selection state】
`VideoTrack$I の作成-時には、未選択になるモノトスル。
これは、`~media資源~fetch~algo$により上書きされ得る。
◎
Similarly, a single VideoTrack object per VideoTrackList object can be selected, this is the video track's selection state. When a VideoTrack is created, its selection state must be set to false (not selected). The resource fetch algorithm can override this.
</p>

<div class="algo">
<p>
［
`AudioTrack^I の
`id@mA
／
`VideoTrack^I の
`id@mV
］取得子~手続きは
⇒
~RET コレの識別子は［
あるならば それ ／
ないならば 空~文字列
］
◎
The AudioTrack id and VideoTrack id attributes must return the identifier of the track, if it has one, or the empty string otherwise.＼
</p>

<p>
`~media資源$の形式が`~media素片の構文$を~supportする場合、返される識別子は，［
`素片$urlの~track次元~内で~trackの名前として利用された場合に，その~trackを可能化することになるもの
］と同じにするモノトスル
`INBAND$r
◎
If the media resource is in a format that supports media fragment syntax, the identifier returned for a particular track must be the same identifier that would enable the track if used as the name of a track in the track dimension of such a fragment. [INBAND]
</p>

<p class="example">
例えば~Ogg~fileにおいては、これは、~trackの
Name header field
になる。
`OGGSKELETONHEADERS$r
◎
For example, in Ogg files, this would be the Name header field of the track. [OGGSKELETONHEADERS]
</p>
</div>

<div class="algo">
［
`AudioTrack^I の
`kind@mA ／
`VideoTrack^I の
`kind@mV
］取得子~手続きは
⇒
~RET コレの分類（以下に与える）は［
あるならば それ ／
ないならば 空~文字列
］
◎
The AudioTrack kind and VideoTrack kind attributes must return the category of the track, if it has one, or the empty string otherwise.
</div>

<p>
~trackの分類は、下の表の 1 列目に与えるいずれかの文字列のうち，［
コレが表現する`~media資源$内の~track
］に最も適切なものになる
— それは、当の~trackに含まれる~metadataから決定される，表の
2, 3 列目に与える “定義”,  “適用-対象”
］に基づく。
“適用-対象” は、［
音声, 動画
］のうち，どれが分類に適用されるかを表す
— ［
音声／動画
］~trackのみに適用される分類が適切になるのは［
音声／動画
］~trackに限られ，そのような分類を返せるのは［
`AudioTrack$I ／ `VideoTrack$I
］ ~objに限られるモノトスル。
◎
The category of a track is the string given in the first column of the table below that is the most appropriate for the track based on the definitions in the table's second and third columns, as determined by the metadata included in the track in the media resource. The cell in the third column of a row says what the category given in the cell in the first column of that row applies to; a category is only appropriate for an audio track if it applies to audio tracks, and a category is only appropriate for video tracks if it applies to video tracks. Categories must only be returned for AudioTrack objects if they are appropriate for audio, and must only be returned for VideoTrack objects if they are appropriate for video.
</p>

<p>
関連な~metadata情報を与えるのは、~media資源の~~種類に応じて［
~Ogg `OGGSKELETONHEADERS$r ならば ~trackの Role header field ／
~DASH `DASH$r ならば Role 要素 ／
~WebM `WEBMCG$r ならば（現時点では） FlagDefault 要素
］になる。
更なる詳細は、
`Sourcing In-band Media Resource Tracks from Media Containers into HTML^cite `INBAND$r
にある。
◎
For Ogg files, the Role header field of the track gives the relevant metadata. For DASH media resources, the Role element conveys the information. For WebM, only the FlagDefault element currently maps to a value. Sourcing In-band Media Resource Tracks from Media Containers into HTML has further details. [OGGSKELETONHEADERS] [DASH] [WEBMCG] [INBAND]
</p>

<table id="dom-TrackList-getKind-categories" class="grid-table">
<caption>
［
`AudioTrack^I の `kind$mA ／
`VideoTrack^I の `kind$mV
］が返す値。
◎
Return values for AudioTrack's kind and VideoTrack's kind
</caption>

<thead><tr><th>分類◎ Category
</th><th>定義◎ Definition
</th><th>適用-対象◎ Applies to...
</th><th>例◎ Examples
</th></thead><tbody>

<tr><td>"`alternative@vT"
<td>
主~track用にアリな代替
— 例えば
歌の異なる~take（音声） ／
異なる~angle（動画）
◎
A possible alternative to the main track, e.g. a different take of a song (audio), or a different angle (video).
<td>
音声／動画
◎
Audio and video.
<td>
<ul ><li>~Ogg： `audio/alternate^l ／ `video/alternate^l
</li><li>~DASH： `alternate^l ~roleを有していて，［
`main^l, `commentary^l ~role（動画） ／
`dub^l ~role（音声）
］は有さないもの（他の~roleは無視される）。
</li></ul>
◎
Ogg: "audio/alternate" or "video/alternate"; DASH: "alternate" without "main" and "commentary" roles, and, for audio, without the "dub" role (other roles ignored).

<tr><td>"`captions@vT"
<td>
主~動画~trackに~captionが焼付けられた~version。
（旧来の内容~用
— 新たな内容は~tTを利用することになる。）
◎
A version of the main video track with captions burnt in. (For legacy content; new content would use text tracks.)
<td>
動画のみ
◎
Video only.
<td>
<ul ><li>~DASH：［
`caption^l, `main^l
］両~roleを有するもの（他の~roleは無視される）。
</li></ul>
◎
DASH: "caption" and "main" roles together (other roles ignored).

<tr><td>"`descriptions@vT"
<td>
動画~trackの音述。
◎
An audio description of a video track.
<td>
音声のみ
◎
Audio only.
<td>
<ul ><li>~Ogg： `audio/audiodesc^l 。
</li></ul>
◎
Ogg: "audio/audiodesc".

<tr><td>"`main@vT"
<td>
首な［
音声／動画
］~track。
◎
The primary audio or video track.
<td>
音声／動画
◎
Audio and video.
<td>
<ul ><li>~Ogg： `audio/main^l ／ `video/main^l
</li><li>~WebM： `FlagDefault^l 要素が設定されているもの
</li><li>~DASH： `main^l ~roleを有していて［
`caption^l, `subtitle^l, `dub^l
］~roleは有さないもの（他の~roleは無視される）。
</li></ul>
◎
Ogg: "audio/main" or "video/main"; WebM: the "FlagDefault" element is set; DASH: "main" role without "caption", "subtitle", and "dub" roles (other roles ignored).

<tr><td>"`main-desc@vT"
<td>
音述が混合された首な音声~track。
◎
The primary audio track, mixed with audio descriptions.
<td>
音声のみ
◎
Audio only.
<td>

<ul><li>MPEG-2 内の AC3 音声：
`TS: bsmod=2^c, `full_svc=1^c
</li></ul>

◎
AC3 audio in MPEG-2 TS: bsmod=2 and full_svc=1.

<tr><td>"`sign@vT"
<td>
音声~trackの手話~解釈。
◎
A sign-language interpretation of an audio track.
<td>
動画のみ
◎
Video only.
<td>
<ul ><li>~Ogg： `video/sign^l
</li></ul>
◎
Ogg: "video/sign".

<tr><td>"`subtitles@vT"
<td>
主~動画~trackに字幕が焼付けられた~version。
（旧来の内容~用
— 新たな内容は~tTを利用することになる。）
◎
A version of the main video track with subtitles burnt in. (For legacy content; new content would use text tracks.)
<td>
動画のみ
◎
Video only.
<td>
<ul ><li>~DASH：［
`subtitle^l , `main^l
］両~roleを有するもの（他の~roleは無視される）。
</li></ul>
◎
DASH: "subtitle" and "main" roles together (other roles ignored).

<tr><td>"`translation@vT"
<td>
主~音声~trackの翻訳された~version。
◎
A translated version of the main audio track.
<td>
音声のみ
◎
Audio only.
<td>
<ul ><li>~Ogg： `audio/dub^l
</li><li>~DASH：［
`dub^l, `main^l
］両~roleを有するもの（他の~roleは無視される）。
</li></ul>
◎
Ogg: "audio/dub". DASH: "dub" and "main" roles together (other roles ignored).

<tr><td>"`commentary@vT"
<td>
首な［
音声／動画
］~trackの実況
— 例：~directorによる実況。
◎
Commentary on the primary audio or video track, e.g. a director's commentary.
<td>
音声／動画
◎
Audio and video.
<td>
<ul ><li>~DASH： `commentary^l ~roleを有していて， `main^l ~roleは有さないもの（他の~roleは無視される）。
</li></ul>
◎
DASH: "commentary" role without "main" role (other roles ignored).

<tr><td>`空~文字列@vT0
<td>
明示的な種類はない，または
コレの~metadataが与える種類は~UAにより認識されていない。
◎
No explicit kind, or the kind given by the track's metadata is not recognized by the user agent.
<td>
音声／動画
◎
Audio and video.
<td>
—

</tbody></table>

<div class="algo">
［
`AudioTrack^I の
`label@mA
／
`VideoTrack^I の
`label@mV
］取得子~手続きは
⇒
~RET コレの~labelは［
あるならば それ ／
ないならば 空~文字列
］
`INBAND$r
◎
The AudioTrack label and VideoTrack label attributes must return the label of the track, if it has one, or the empty string otherwise. [INBAND]
</div>

<div class="algo">
<p>
［
`AudioTrack^I の
`language@mA
／
`VideoTrack^I の
`language@mV
］取得子~手続きは
⇒
~RET コレの言語の BCP 47 言語~tagは［
あるならば それ ／
ないならば 空~文字列
］
</p>

<p>
~UAは，その言語を BCP 47 言語~tagとして表出できない場合（例えば、当の`~media資源$の形式における言語~情報は、自由形の文字列で，解釈は定義されていないなど）、空~文字列を返すモノトスル
— コレの言語はなかったかのように。
`INBAND$r
◎
The AudioTrack language and VideoTrack language attributes must return the BCP 47 language tag of the language of the track, if it has one, or the empty string otherwise. If the user agent is not able to express that language as a BCP 47 language tag (for example because the language information in the media resource's format is a free-form string without a defined interpretation), then the method must return the empty string, as if the track had no language. [INBAND]
</p>

</div>

<div class="algo">
`AudioTrack^I の
`enabled@mA
取得子~手続きは
⇒
~RET コレは現在~可能化されて［
いるならば ~T ／
いなければ ~F
］
◎
The AudioTrack enabled attribute, on getting, must return true if the track is currently enabled, and false otherwise.＼
</div>

<div class="algo">
<p>
`AudioTrack^I の `enabled$mA 設定子~手続きは
⇒
所与の値に応じて
⇒＃
~T ならば コレを可能化する ／
~F ならば コレを不能化する
◎
On setting, it must enable the track if the new value is true, and disable it otherwise.＼
</p>

<p>
（コレがもはや `AudioTrackList$I ~objに属さなくなった場合、コレを［
可能化-／不能化-
］しても，単に取得子が返す値が変化する他に効果はない。）
◎
(If the track is no longer in an AudioTrackList object, then the track being enabled or disabled has no effect beyond changing the value of the attribute on the AudioTrack object.)
</p>
</div>

<div class="algo">
<p id="toggle-audio-track">
`AudioTrackList$I ~obj %~track~list 内の音声~trackが［
不能化-／可能化-
］されているかどうか変化したときは、~UAは次を行うモノトスル
⇒
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %~track~list, `change$et )
◎
Whenever an audio track in an AudioTrackList that was disabled is enabled, and whenever one that was enabled is disabled, the user agent must queue a media element task given the media element to fire an event named change at the AudioTrackList object.
</p>
</div>

<p>
音声~trackが`~media時列線$における特定0の位置に対し［
~dataを伴わない／存在しない
］場合、その時列線~上の地点においては無音と解釈するモノトスル。
◎
An audio track that has no data for a particular position on the media timeline, or that does not exist at that position, must be interpreted as being silent at that point on the timeline.
</p>

<div class="algo">
`VideoTrackList^I の
`selectedIndex@mV
取得子~手続きは
⇒
~RET コレ内に現在~選択されている~trackは
⇒＃
あれば その~index ／
なければ −1
◎
The VideoTrackList selectedIndex attribute must return the index of the currently selected track, if any. If the VideoTrackList object does not currently represent any tracks, or if none of the tracks are selected, it must instead return −1.
</div>

<div class="algo">
`VideoTrack^I の
`selected@mV
取得子~手続きは
⇒
~RET コレは現在~選択されて［
いるならば ~T ／
いないならば ~F
］
◎
The VideoTrack selected attribute, on getting, must return true if the track is currently selected, and false otherwise.＼
</div>

<div class="algo">
<p>
`VideoTrack^I の
`selected$mV 設定子~手続きは：
</p>
<ol>
	<li>
所与の値に応じて
⇒＃
~T ならばコレを選択する／
~F ならばコレを未選択にする
</li>
	<li>
~IF［
所与の値 ~EQ ~T
］~AND［
コレは ある `VideoTrackList$I に属する
］
⇒
その~list内の他のすべての `VideoTrack$I ~objは未選択にする
</li>
</ol>

<p>
（コレが `VideoTrackList$I ~objに属さなくなった場合、コレを選択しようが未選択にしようが，取得子が返す値が変化する他に効果はない。）
</p>

◎
On setting, it must select the track if the new value is true, and unselect it otherwise. If the track is in a VideoTrackList, then all the other VideoTrack objects in that list must be unselected. (If the track is no longer in a VideoTrackList object, then the track being selected or unselected has no effect beyond changing the value of the attribute on the VideoTrack object.)
</div>

<div class="algo">
<p id="toggle-video-track">
ある`~media要素$ %要素 の
【 `videoTracks$mM 属性が返す】
`VideoTrackList$I ~obj %~track~list 内で選択されている~trackが変化したときは（他が選択されずに未選択にされた場合も含む）、~UAは，次に従うモノトスル：
◎
Whenever a track in a VideoTrackList that was previously not selected is selected, and whenever the selected track in a VideoTrackList is unselected without a new track being selected in its stead, the user agent must＼
</p>
<ul>
	<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %~track~list, `change$et )
◎
queue a media element task given the media element to fire an event named change at the VideoTrackList object.＼
</li>
	<li>
前項の~taskは、［
%要素 に向けて `resize$et ~eventを発火する`~task$
］があれば，それより前に~queueする。
◎
This task must be queued before the task that fires the resize event, if any.
</li>
</ul>

</div>

<p>
動画~trackは、`~media時列線$上の特定0の位置に~dataを伴わない地点においては，次のように解釈するモノトスル：
◎
A video track that has no data for a particular position on the media timeline must be interpreted as＼
</p>

<ul>
	<li>
`透明な黒$である。
◎
being transparent black at that point on the timeline,＼
</li>
	<li>
寸法は、その位置より前に その~track用の~dataが［
あれば その最後の~frame ／
なければ 最初の~frame
］と同じ。
◎
with the same dimensions as the last frame before that position, or, if the position is before all the data for that track, the same dimensions as the first frame for that track.＼
</li>
	<li>
~trackが現在の位置にまったく存在しない場合、［
存在しているが，~dataは無い
］ものと扱う。
◎
A track that does not exist at all at the current position must be treated as if it existed but had no data.
</li>
</ul>

<p class="example">
一例として、動画に再生の 1 ~~時間~後から導入される~trackがある場合、利用者がその~trackを選択してから始端に戻ったときは、~UAは，その~trackが［
`~media資源$の始端から開始していて，1 ~~時間~過ぎるまでは単純に透明である
］かのように動作することになる。
◎
For instance, if a video has a track that is only introduced after one hour of playback, and the user selects that track then goes back to the start, then the user agent will act as if that track started at the start of the media resource but was simply transparent until one hour in.
</p>

<hr>

<p>
［
`AudioTrackList$I ／ `VideoTrackList$I
］~interfaceを実装するどの~objも、次に挙げる`~event~handler$（および対応する`~event~handler~event型$）を，`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the AudioTrackList and VideoTrackList interfaces:
</p>

<table><thead><tr><th>`~event~handler$
</th><th>`~event~handler~event型$
</th></thead>

<tbody><tr><td>`onchange@m
<td>`change$et
<tr><td>`onaddtrack@m
<td>`addtrack$et
<tr><td>`onremovetrack@m
<td>`removetrack$et
</tbody></table>

					</section>
					<section id="selecting-specific-audio-and-video-tracks-declaratively">
<h6 title="Selecting specific audio and video tracks declaratively">4.8.12.10.2. 特定の 音声／動画 ~trackの宣言的な選択-法</h6>

<p>
~scriptは，
`audioTracks$mM ／ `videoTracks$mM
属性で どの~trackを再生するベキか選択できるが、当の`~media資源$の`~URL$の`素片$url内に 指定することでも，特定の~trackを宣言的に選択できる。
`素片$urlの形式は、その`~media資源$の`~MIME型$に依存する。
`RFC2046$r
`URL$r
◎
The audioTracks and videoTracks attributes allow scripts to select which track should play, but it is also possible to select specific tracks declaratively, by specifying particular tracks in the fragment of the URL of the media resource. The format of the fragment depends on the MIME type of the media resource. [RFC2046] [URL]
</p>

<div class="example">

<p>
この例では、`~media素片の構文$を~supportする形式を利用する動画は、既定の動画~trackに代えて，代替の~angle `Alternative^l が可能化されるような仕方で埋込まれている。
◎
In this example, a video that uses a format that supports media fragment syntax is embedded in such a way that the alternative angles labeled "Alternative" are enabled instead of the default video track.
</p>

<pre class="lang-html">
&lt;video src="myvideo#track=Alternative"&gt;&lt;/video&gt;
</pre>

</div>

					</section>
				</section>
				<section id="timed-text-tracks">
<h5 title="Timed text tracks">4.8.12.11. 時間同期的な~tT</h5>

<p class="trans-note">【
この節の内容の和訳は、<a href="~HEtrack#timed-text-tracks">別~page</a>にて。
】</p>

				</section>
				<section id="identifying-a-track-kind-through-a-url">
<h5 title="Identifying a track kind through a URL">4.8.12.12. ~URLによる~trackの種類の識別-法</h5>

<div class="p">
<p>
他の仕様や形式は、次のために`~URL$が必要になる場合には，
`about_html-kind$sc `~URL$を利用しなければナラナイ：
</p>

<ul>
	<li>
［
`AudioTrack^I の `kind$mA ／
`VideoTrack^I の `kind$mV
］~IDL属性から返される値を識別する
</li>
	<li>
~tTの`種類$tTを識別する
</li>
</ul>

◎
Other specifications or formats that need a URL to identify the return values of the AudioTrack kind or VideoTrack kind IDL attributes, or identify the kind of text track, must use the about:html-kind URL.
</div>

				</section>
				<section id="user-interface">
<h5 title="User interface">4.8.12.13. ~UI</h5>

<p>
`controls@aM
属性は`真偽-属性$であり、在る場合，作者は［
~scriptによる~controllerは供さないで，~UAに自前の~control一式を供させたい
］こと指示する。
◎
The controls attribute is a boolean attribute. If present, it indicates that the author has not provided a scripted controller and would like the user agent to provide its own set of controls.
</p>

<p>
`~media要素$において［
属性が在る ／
要素に対する`~scriptingは不能化され$ている
］場合、~UAは利用者に
`~UIを公開する@
ベキである。
この~UIは、次に挙げる特能を含むベキである：
◎
If the attribute is present, or if scripting is disabled for the media element, then the user agent should expose a user interface to the user. This user interface should include features＼
</p>

<div class="p">

<ul><li>再生を始める
</li><li>再生を静止する
</li><li>内容の任意の位置へ~seekする（内容が それを~supportするならば） 
</li><li>音量を変更する
</li><li>開閉可能な~caption／埋込d手話~trackの表示を変更する
</li><li>異なる音声~trackたちを選択する／音述をオンにする
</li><li>~media内容をより相応しい方式で利用者に示す（例えば、動画を全~screen, あるいは 独立かつ~resize可能な~UIwindow内に示す）
</li></ul>

◎
to begin playback, pause playback, seek to an arbitrary position in the content (if the content supports arbitrary seeking), change the volume, change the display of closed captions or embedded sign-language tracks, select different audio tracks or turn on audio descriptions, and show the media content in manners more suitable to the user (e.g. fullscreen video or in an independent resizable window).＼
</div>

<p>
他の~controlも可用にされてヨイ。
◎
Other controls may also be made available.
</p>

<p>
属性が無い下でも、~UAは~media資源の再生に影響する~control（例：再生- ／ 静止- ／ ~seek法 ／ ~track選択 ／ 音量~control）を供してもヨイが、そのような特能は，~pageの通常の具現化に干渉するベキでない。
そのような特能は、例えば［
`~media要素$の文脈~menu ／
~platform~media~Key ／
~remote-control
］内に公開できる。
~UAは、単純に利用者に`~UIを公開する$ことにより，これを実装してもヨイ
— 上に述べたように（ `controls$aM 属性を有していたかのように）。
◎
Even when the attribute is absent, however, user agents may provide controls to affect playback of the media resource (e.g. play, pause, seeking, track selection, and volume controls), but such features should not interfere with the page's normal rendering. For example, such features could be exposed in the media element's context menu, platform media keys, or a remote control. The user agent may implement this simply by exposing a user interface to the user as described above (as if the controls attribute was present).
</p>

<p>
~UAが~controlを`~media要素$に重ねて表示することにより，利用者に`~UIを公開する$場合、
~UAは、［
【！原文誤 user agent】
利用者が，この~interfaceとヤリトリしている間
］は，利用者~対話~eventを抑止するベキである。
（例えば，利用者が動画の再生~controlを~clickした場合、~pageの要素に向けて `mousedown$et ~event等々が同時に発火されることはない。）
◎
If the user agent exposes a user interface to the user by displaying controls over the media element, then the user agent should suppress any user interaction events while the user agent is interacting with this interface. (For example, if the user clicks on a video's playback control, mousedown events and so forth would not simultaneously be fired at elements on the page.)
</p>

<p>
~UAが公開する~UI特能は（特定的には：
再生を［
開始する／停止する／静止する／再開pする
］／
~seekする／
再生~rateを変更する／
早送りする／早戻しする／
~tTを［
~listする／可能化する／不能化する
］／
音声の音量を［
消音する／変更する
］ための）、アリな所では
— 例えば，同じ~eventすべてが発火されるよう —
上に述べた~DOM~APIの用語を通して実装するモノトスル。
◎
Where possible (specifically, for starting, stopping, pausing, and unpausing playback, for seeking, for changing the rate of playback, for fast-forwarding or rewinding, for listing, enabling, and disabling text tracks, and for muting or changing the volume of the audio), user interface features exposed by the user agent must be implemented in terms of the DOM API described above, so that, e.g., all the same events fire.
</p>

<p>
早送り／早戻しなどの特能は、 `playbackRate$mM 属性のみを変更するように実装するモノトスル（ `defaultPlaybackRate$mM 属性ではなく）。
◎
Features such as fast-forward or rewind must be implemented by only changing the playbackRate attribute (and not the defaultPlaybackRate attribute).
</p>

<p>
~seekingは、［
`~media要素$の`~media時列線$内の，要請された位置へ`~seekする$こと
］を通して実装するモノトスル。
~media資源に対しては、［
利用者が~seek~barなどの近似-位置~UIを操作するのに呼応して，~seekするとき
］に，任意の位置への~seekingが低速になる所では、~UAには，
%速度優先か に ~T を利用することが奨励される。
◎
Seeking must be implemented in terms of seeking to the requested position in the media element's media timeline. For media resources where seeking to an arbitrary position would be slow, user agents are encouraged to use the approximate-for-speed flag when seeking in response to the user manipulating an approximate position interface such as a seek bar.
</p>

<p>
`controls@mM
~IDL属性は、
`controls$aM 内容~属性を`反映する$モノトスル。
◎
The controls IDL attribute must reflect the content attribute of the same name.
</p>

<hr>

<dl class="domintro">

	<dt>%media.`volume$mM [ = %value ]</dt>
	<dd>
現在の再生~音量を，範囲［
0.0 （無音）以上, 1.0 （最大音）以下
］の数として返す。
◎
Returns the current playback volume, as a number in the range 0.0 to 1.0, where 0.0 is the quietest and 1.0 the loudest.
</dd>
	<dd>
設定して，音量を変更できる。
◎
Can be set, to change the volume.
</dd>
	<dd>
［
0.0 ~LTE 所与の値 ~LTE  1.0
］でない場合、 `IndexSizeError$E 例外が投出される。
◎
Throws an "IndexSizeError" DOMException if the new value is not in the range 0.0 .. 1.0.
</dd>

	<dt>%media.`muted$mM [ = %value ]</dt>
	<dd>
音声は消音され, `volume$mM 属性を上書きしているならば ~T ／
~ELSE_ （ `volume$mM 属性は尊守されている） ~F
を返す。
◎
Returns true if audio is muted, overriding the volume attribute, and false if the volume attribute is being honored.
</dd>
	<dd>
設定して，音声は消音されるかどうか変更できる。
◎
Can be set, to change whether the audio is muted or not.
</dd>
</dl>

<p>
`~media要素$は、範囲［
0.0 （無音）以上, 1.0 （最大音）以下
］の小数をとり得る
`再生~音量@
を持つ。
音量は、初期~時には  1.0 にされるベキである。
が，~UAは、［
~siteごとなどに基づく複数~sessionにまたがって，最後に設定された値
］を覚えて，音量を他の値から開始してもヨイ。
◎
A media element has a playback volume, which is a fraction in the range 0.0 (silent) to 1.0 (loudest). Initially, the volume should be 1.0, but user agents may remember the last set value across sessions, on a per-site basis or otherwise, so the volume may start at other values.
</p>

<div class="algo">
`volume@mM
取得子~手続きは
⇒
~RET コレの音声~部の`再生~音量$
◎
The volume IDL attribute must return the playback volume of any audio portions of the media element.＼
</div>

<div class="algo">
<p>
`volume$mM 設定子~手続きは：
</p>
<ol>
	<li>
~IF［
0.0 ~LTE 所与の値 ~LTE  1.0
］
⇒
コレの`再生~音量$ ~SET 所与の値
</li>
	<li>
~ELSE
⇒
~THROW `IndexSizeError$E 例外
</li>
</ol>
◎
On setting, if the new value is in the range 0.0 to 1.0 inclusive, the media element's playback volume must be set to the new value. If the new value is outside the range 0.0 to 1.0 inclusive, then, on setting, an "IndexSizeError" DOMException must be thrown instead.
</div>

<p>
`~media要素$はまた，
`消音-@
され得る。
要素を消音している何かがあれば、それは消音される（例えば，`再生~方向$が逆方向である間は、要素は消音される）。
◎
A media element can also be muted. If anything is muting the element, then it is muted. (For example, when the direction of playback is backwards, the element is muted.)
</p>

<div class="algo">
<p>
`muted@mM
取得子~手続きは、最後に設定された値を返す。
`~media要素$の作成-時には，要素が `muted$aM 内容~属性を有するならば ~T に設定されるベキである。
他の場合、~UAは値を利用者が選好する値に設定してヨイ（例えば，~siteごとなどに基づく複数~sessionにまたがって最後に設定された値を覚えておくなど）。
この属性が ~T に設定されている間は、`~media要素$を`消音-$するモノトスル。
◎
The muted IDL attribute must return the value to which it was last set. When a media element is created, if the element has a muted content attribute specified, then the muted IDL attribute should be set to true; otherwise, the user agents may set the value to the user's preferred value (e.g. remembering the last set value across sessions, on a per-site basis or otherwise). While the muted IDL attribute is set to true, the media element must be muted.
</div>

<div class="algo">
<p>
`~media要素$ %要素 の［
`volume$mM ／ `muted$mM
］~IDL属性が返す値が変化したときは、~UAは次を走らすモノトスル：
◎
Whenever either of the values that would be returned by the volume and muted IDL attributes change, the user agent must＼
</p>
<ol>
	<li>
次を走らす`~media~taskを~queueする$( %要素 )
⇒
`~eventを発火する$( %要素, `volumechange$et )
◎
queue a media element task given the media element to fire an event named volumechange at the media element.＼
</li>
	<li>
~IF［
%要素 には`再生は許容されて$いない
］
⇒
`内部~静止-手続き$( %要素 )
◎
Then, if the media element is not allowed to play, the user agent must run the internal pause steps for the media element.
</li>
</ol>
</div>

<div class="algo">
<p>
`~media要素$ %要素 の
`実効~media音量@
は、次に従って決定される：
◎
An element's effective media volume is determined as follows:
</p>

<ol>
	<li>
~IF［
%要素 の音量を上書きするよう，利用者から指示されている
］
⇒
~RET 利用者から欲された音量
◎
If the user has indicated that the user agent is to override the volume of the element, then return the volume desired by the user.
</li>
	<li>
~IF［
%要素 の音声~出力は`消音-$されている
］
⇒
~RET 0
◎
If the element's audio output is muted, then return zero.
</li>
	<li>
~RET %要素 の音声~部の`再生~音量$
◎
Let volume be the playback volume of the audio portions of the media element, in range 0.0 (silent) to 1.0 (loudest).
</li>
</ol>
</div>

<div class="p">
<p>
`実効~media音量$は、範囲 0.0 〜 1.0 に相対的な聴感音量として，次のように解釈されるとする：
</p>

<ul ><li>0.0 は無音に対応する。
</li><li>1.0 は最大音に対応する。
</li><li>数が大きいほど増大するが、線形にそうなる必要はない。
</li></ul>

◎
Return volume, interpreted relative to the range 0.0 to 1.0, with 0.0 being silent, and 1.0 being the loudest setting, values in between increasing in loudness. The range need not be linear.＼
</div>

<p>
最大音~設定は、例えば，利用者が音量に~~上限を設定していたときなど，~systemの最大音~設定より低くされてもヨイ。
◎
The loudest setting may be lower than the system's loudest possible setting; for example the user could have set a maximum volume.
</p>

<p>
`~media要素$上の
`muted@aM
内容~属性は、`真偽-属性$であり，`~media資源$の音声~出力の既定の状態を制御する。
それは、利用者~選好を上書きするものになり得る。
◎
The muted content attribute on media elements is a boolean attribute that controls the default state of the audio output of the media resource, potentially overriding user preferences.
</p>

<p>
`defaultMuted@mM
~IDL属性は、
`muted$aM 内容~属性を`反映する$モノトスル。
◎
The defaultMuted IDL attribute must reflect the muted content attribute.
</p>

<p class="note">注記：
この属性には動的な効果はない（要素の既定の状態のみを制御する）。
◎
This attribute has no dynamic effect (it only controls the default state of the element).
</p>

<div class="example">

<p>
次の動画（広告）は，自動再生するが、利用者をいらつかせないよう，音響なしにそれを行うことに加え、利用者が音響ありに切り替えれるようにする。
~UAは、利用者~対話なしに消音されなくなったときは，動画を静止できる。
◎
This video (an advertisement) autoplays, but to avoid annoying users, it does so without sound, and allows the user to turn the sound on. The user agent can pause the video if it's unmuted without a user interaction.
</p>

<pre class="lang-html">
&lt;video src="adverts.cgi?kind=video" controls autoplay loop muted&gt;&lt;/video&gt;
</pre>

</div>

				</section>
				<section id="time-ranges">
<h5 title="Time ranges">4.8.12.14. 時刻~範囲</h5>

<p>
`TimeRanges$I ~objは、一連の［
時刻の範囲（期間）
］からなる~list
— 範囲~list —
を表現する。
◎
Objects implementing the TimeRanges interface represent a list of ranges (periods) of time.
</p>

<pre class="idl">
[Exposed=Window]
interface `TimeRanges@I {
  readonly attribute unsigned long `length$m;
  double `start$m(unsigned long %index);
  double `end$m(unsigned long %index);
};
</pre>

<dl class="domintro">
	<dt>%media.`length$m</dt>
	<dd>
範囲~listの~sizeを返す。
◎
Returns the number of ranges in the object.
</dd>

	<dt>%time = %~media.`start(index)$m</dt>
	<dd>
範囲~list内の %index 番の範囲の始端の時刻を返す。
◎
Returns the time for the start of the range with the given index.
</dd>
	<dd>
［
%index ~GTE 範囲~listの~size
］の場合、
`IndexSizeError$E 例外が投出される。
◎
Throws an "IndexSizeError" DOMException if the index is out of range.
</dd>

	<dt>%time = %media.`end(index)$m</dt>
	<dd>
範囲~list内の  %index 番の範囲の終端の時刻を返す。
◎
Returns the time for the end of the range with the given index.
</dd>
	<dd>
［
%index ~GTE 範囲~listの~size
］の場合、
`IndexSizeError$E 例外が投出される。
◎
Throws an "IndexSizeError" DOMException if the index is out of range.
</dd>
</dl>

<div class="algo">
`length@m
取得子~手続きは
⇒
~RET コレが表現する範囲~listの~size
◎
The length IDL attribute must return the number of ranges represented by the object.
</div>

<div class="algo">
<p>
［
`start(index)@m ／
`end(index)@m
］~method~手続きは：
</p>
<ol>
	<li>
~IF［
%index ~GTE コレが表現する範囲~listの~size
］
⇒
~THROW `IndexSizeError$E
</li>
	<li>
%位置 ~LET コレが表現する範囲~list内の %index 番の範囲の［
`start()$m に対しては始端 ／
`end()$m に対しては終端
］
</li>
	<li>
~RET コレが受持つ時列線の始端から，秒数で %位置 を測定した結果
</li>
</ol>

◎
The start(index) method must return the position of the start of the indexth range represented by the object, in seconds measured from the start of the timeline that the object covers.
◎
The end(index) method must return the position of the end of the indexth range represented by the object, in seconds measured from the start of the timeline that the object covers.
◎
These methods must throw "IndexSizeError" DOMExceptions if called with an index argument greater than or equal to the number of ranges represented by the object.
</div>

<p>
`TimeRanges$I ~objが
`正規化-済み@
とは、それが表現する範囲たちが，次の判定基準を順守することを意味する：
◎
When a TimeRanges object is said to be a normalized TimeRanges object, the ranges it represents must obey the following criteria:
</p>

<ul>
	<li>
<p>
どの 2 つの範囲 %A, %B に対しても，
%A の方が %B より早いならば
⇒
%A の終端 ~LT %B の始端
</p>

<p>
【“より早い（ `earlier^en ）”： おそらく，範囲の~list内でより早い — 時間的に早いではなく。】
</p>

◎
The start of a range must be greater than the end of all earlier ranges.
</li>
	<li>
どの範囲 %A に対しても
⇒
%A の始端 ~LTE %A の終端
◎
The start of a range must be less than or equal to the end of that same range.
</li>
</ul>

<p>
言い換えれば、そのような~obj内の一連の範囲は，互いに［
順序付けられ, 重合しない, 触れてない（隣接する範囲どうしは 1 個のより大きい範囲に~~集約される）
］。
範囲は空（ある瞬間の時刻のみを参照している）にもなり得る
— 例えば`~media要素$が静止されたとき，~UAが`~media資源$の現在の~frame以外のすべてを破棄した事例において、現在~bufferされている唯一の~frameを指示するため。
◎
In other words, the ranges in such an object are ordered, don't overlap, and don't touch (adjacent ranges are folded into one bigger range). A range can be empty (referencing just a single moment in time), e.g. to indicate that only one frame is currently buffered in the case that the user agent has discarded the entire media resource except for the current frame, when a media element is paused.
</p>

<p>
`TimeRanges$I ~objの一連の範囲は両端を含むモノトスル。
◎
Ranges in a TimeRanges object must be inclusive.
</p>

<p class="example">
したがって，ある範囲の終端は、後続する隣接する（触れているが重合していない）範囲の始端に等しくなる。
同様に， 0 を起点に時列線~全体を受持つ範囲に対しては、始端は 0 に等しくなり，終端は時列線の時間長に等しくなる。
◎
Thus, the end of a range would be equal to the start of a following adjacent (touching but not overlapping) range. Similarly, a range covering a whole timeline anchored at zero would have a start equal to zero and an end equal to the duration of the timeline.
</p>

<p>
`~media要素$ %要素 の［
`buffered$mM ／ `seekable$mM ／ `played$mM
］~IDL属性が返す~objは、
%要素 の`~media時列線$と同じ時列線を利用するモノトスル。
◎
The timelines used by the objects returned by the buffered, seekable and played IDL attributes of media elements must be that element's media timeline.
</p>

				</section>
				<section id="the-trackevent-interface">
<h5 title="The TrackEvent interface">4.8.12.15. `TrackEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `TrackEvent@I : `Event$I {
  constructor(DOMString type, optional `TrackEventInit$I %eventInitDict = {});

  readonly attribute (`VideoTrack$I or `AudioTrack$I or `TextTrack$I)? `track$m;
};

dictionary `TrackEventInit@I : `EventInit$I {
  (`VideoTrack$I or `AudioTrack$I or `TextTrack$I)? track = null;
};
</pre>

<dl class="domintro">

	<dt>%event.`track$m</dt>
	<dd>
この~eventに関係する~track~obj（
`TextTrack$I ／ `AudioTrack$I ／ `VideoTrack$I
）を返す。
◎
Returns the track object (TextTrack, AudioTrack, or VideoTrack) to which the event relates.
</dd>
</dl>

<div class="algo">
`track@m
取得子~手続きは、初期化-時の値を返す。
それは、~eventの文脈~情報を表現する。
◎
The track attribute must return the value it was initialized to. It represents the context information for the event.
</div>

				</section>
				<section id="mediaevents">
<h5 title="Events summary">4.8.12.16. ~event要覧</h5>

~INFORMATIVE

<p class="trans-note">【
この節に挙げられていた~eventのうち，`~tT$のみに関わるものについては、編集の都合により，
<a href="~HEtrack#mediaevents">別~page</a>に分けている。
】</p>

<p>
特に指定されたものを除き、この節に挙げるどの~eventも，
`Event$I ~interfaceを利用する。
【原文の表には “~interface” 列があるが、この訳では，一部の表を除きその列を省略してこの一文に集約する。】
</p>

<p>
上に述べた処理~modelの一部として、次に挙げる~eventが`~media要素$に向けて発火される：
◎
The following events fire on media elements as part of the processing model described above:
</p>

<table><thead><tr><th>~event名
</th><th>発火-時機
</th><th>事前条件

</th></tr></thead>

<tbody><tr><td>`loadstart@et
</td><td>
~UAは、`資源~選定~algo$の一環として，`~media~data$を探し始めた。
◎
The user agent begins looking for media data, as part of the resource selection algorithm.
</td><td>
`networkState$mM ~EQ `NETWORK_LOADING$mM
◎
networkState equals NETWORK_LOADING

</td></tr><tr><td>`progress@et
</td><td>
~UAは`~media~data$を~fetchしている。
◎
The user agent is fetching media data.
</td><td>
`networkState$mM ~EQ `NETWORK_LOADING$mM
◎
networkState equals NETWORK_LOADING

</td></tr><tr><td>`suspend@et
</td><td>
~UAは`~media~data$を意図的に現在~fetchしていない。
◎
The user agent is intentionally not currently fetching media data.
</td><td>
`networkState$mM ~EQ `NETWORK_IDLE$mM
◎
networkState equals NETWORK_IDLE

</td></tr><tr><td>`abort@et
</td><td>
`~media~data$が完全に~downloadされる前に，~UAは~errorに因らずに~fetchするのを停止した。
◎
The user agent stops fetching the media data before it is completely downloaded, but not due to an error.
</td><td>
［
`error$mM ~NEQ ~NULL
］~AND［
`error$mM の`~code$ ~EQ `MEDIA_ERR_ABORTED$mE
］~AND［
`networkState$mM ~EQ ［
`NETWORK_EMPTY$mM または `NETWORK_IDLE$mM
— どちらに ~EQ かは、~downloadがいつ中止されたかに依存する
］］
◎
error is an object with the code MEDIA_ERR_ABORTED. networkState equals either NETWORK_EMPTY or NETWORK_IDLE, depending on when the download was aborted.

</td></tr><tr><td>`~errorM@et
</td><td>
`~media~data$を~fetchしている間に~errorが生じた, または
資源の型は~supportされない~media形式である。
◎
An error occurs while fetching the media data or the type of the resource is not supported media format.
</td><td>
［
`error$mM ~NEQ ~NULL
］~AND［
`error$mM の`~code$ ~GTE `MEDIA_ERR_NETWORK$mE
］~AND［
`networkState$mM ~EQ ［
`NETWORK_EMPTY$mM または `NETWORK_IDLE$mM
— どちらに ~EQ かは、~downloadがいつ中止されたかに依存する
］］
◎
error is an object with the code MEDIA_ERR_NETWORK or higher. networkState equals either NETWORK_EMPTY or NETWORK_IDLE, depending on when the download was aborted.

</td></tr><tr><td>`emptied@et
</td><td>
`~media要素$の `networkState$mM 値は、他の値から `NETWORK_EMPTY$mM に切替わった（報告されつつある読込nの間に致命的な~errorが生じたか，
`load()$mM ~methodは`資源~選定~algo$を走らせている間に呼出されたために）。
◎
A media element whose networkState was previously not in the NETWORK_EMPTY state has just switched to that state (either because of a fatal error during load that's about to be reported, or because the load() method was invoked while the resource selection algorithm was already running).
</td><td>
`networkState$mM ~EQ `NETWORK_EMPTY$mM
— すべての~IDL属性は，それぞれの初期~状態にある。
◎
networkState is NETWORK_EMPTY; all the IDL attributes are in their initial states.

</td></tr><tr><td>`stalled@et
</td><td>
~UAは、`~media~data$を~fetchしようと試行しているが、~dataは期待通りに入手できていない。
◎
The user agent is trying to fetch media data, but data is unexpectedly not forthcoming.
</td><td>
`networkState$mM ~EQ `NETWORK_LOADING$mM
◎
networkState is NETWORK_LOADING.

</td></tr></tbody>

<tbody><tr><td>`loadedmetadata@et
</td><td>
~UAは`~media資源$の時間長と寸法を決定した所にあり、~tTは `準備済み$i にある。
◎
The user agent has just determined the duration and dimensions of the media resource and the text tracks are ready.
</td><td>
［
`readyState$mM ~GTE `HAVE_METADATA$mM
］でない状態から初めてそうなった
◎
readyState is newly equal to HAVE_METADATA or greater for the first time.

</td></tr><tr><td>`loadeddata@et
</td><td>
［
~UAは`現在の再生~位置$にある`~media~data$を具現化できる
］でない状態から初めてそうなった
◎
The user agent can render the media data at the current playback position for the first time.
</td><td>
［
`readyState$mM ~GTE `HAVE_CURRENT_DATA$mM
］でない状態から初めてそうなった
◎
readyState newly increased to HAVE_CURRENT_DATA or greater for the first time.

</td></tr><tr><td>`canplay@et
</td><td>
~UAは`~media~data$の再生を再開できるが、今~再生が開始された場合，［
現在の再生~rateのままでは、停止して内容を更に~bufferしない限り，`~media資源$を終端までは具現化できない
］と見積もっている。
◎
The user agent can resume playback of the media data, but estimates that if playback were to be started now, the media resource could not be rendered at the current playback rate up to its end without having to stop for further buffering of content.
</td><td>
［
`readyState$mM ~GTE `HAVE_FUTURE_DATA$mM
］でない状態からそうなった
◎
readyState newly increased to HAVE_FUTURE_DATA or greater.

</td></tr><tr><td>`canplaythrough@et
</td><td>
~UAは、今~再生が開始された場合でも，［
現在の再生~rateのままでも、停止して内容を更に~bufferせずに，`~media資源$は終端まで具現化できる
］と見積もっている。
◎
The user agent estimates that if playback were to be started now, the media resource could be rendered at the current playback rate all the way to its end without having to stop for further buffering.
</td><td>
［
`readyState$mM ~EQ `HAVE_ENOUGH_DATA$mM
］でない状態からそうなった
◎
readyState is newly equal to HAVE_ENOUGH_DATA.

</td></tr><tr><td>`playing@et
</td><td>
`~media~data$を欠くこと因り，再生は［
静止-／遅延-
］されていたが、その後，開始-準備済みにある。
◎
Playback is ready to start after having been paused or delayed due to lack of media data.
</td><td>
［［
`readyState$mM ~GTE `HAVE_FUTURE_DATA$mM
］~AND［
`paused$mM ~EQ ~F
］］でない状態からそうなった。
この~eventが発火されても，要素は`再生-中であり得る$ようになったとは限らない
— 例：
要素は［
`利用者~対話~用に静止され$／
`帯域内~内容~用に静止され$
］ているとき。
◎
readyState is newly equal to or greater than HAVE_FUTURE_DATA and paused is false, or paused is newly false and readyState is equal to or greater than HAVE_FUTURE_DATA. Even if this event fires, the element might still not be potentially playing, e.g. if the element is paused for user interaction or paused for in-band content.

</td></tr><tr><td>`waiting@et
</td><td>
再生は次~frameが可用でないため停止されたが、~UAは，そのうち可用になると期待している。
◎
Playback has stopped because the next frame is not available, but the user agent expects that frame to become available in due course.
</td><td>
［
`readyState$mM ~LTE `HAVE_CURRENT_DATA$mM
］~AND［
`paused$mM ~EQ ~F
］~AND［［
`seeking$mM ~EQ ~T
］~OR［
`現在の再生~位置$は `buffered$mM 内のどの範囲にも包含されていない
］］。
［
`paused$mM ~EQ ~F
］でなくとも，再生は他の理由により停止されることもあり得るが、この~eventはそのような理由では発火されない（加えて，それらの状況が解決されても，別々に `playing$et ~eventは発火されない）
— 例えば：
`再生は終止して$いる ／
再生は`~errorに因り停止され$ている ／
要素は`利用者~対話~用に静止され$ている ／
要素は`帯域内~内容~用に静止され$ている。
◎
readyState is equal to or less than HAVE_CURRENT_DATA, and paused is false. Either seeking is true, or the current playback position is not contained in any of the ranges in buffered. It is possible for playback to stop for other reasons without paused being false, but those reasons do not fire this event (and when those situations resolve, a separate playing event is not fired either): e.g., playback has ended, or playback stopped due to errors, or the element has paused for user interaction or paused for in-band content.

</td></tr></tbody>

<tbody><tr><td>`seeking@et
</td><td>
［
`seeking$mM ~IDL属性は ~T に変化した
］~AND［
~UAは新たな位置への~seekingを開始した
］。
◎
The seeking IDL attribute changed to true, and the user agent has started seeking to a new position.
</td><td>

</td></tr><tr><td>`seeked@et
</td><td>
`現在の再生~位置$が変化した後に， `seeking$mM ~IDL属性は ~F に変化した。
◎
The seeking IDL attribute changed to false after the current playback position was changed.
</td><td>

</td></tr><tr><td>`ended@et
</td><td>
`~media資源$の終端に達したため、再生を停止した。
◎
Playback has stopped because the end of the media resource was reached.
</td><td>
［
`currentTime$mM ~EQ `~media資源$の終端
］~AND［
`ended$mM ~EQ ~T
］
◎
currentTime equals the end of the media resource; ended is true.

</td></tr></tbody>

<tbody><tr><td>`durationchange@et
</td><td>
`duration$mM 属性が直前に更新された。
◎
The duration attribute has just been updated.
</td><td>

</td></tr><tr><td>`timeupdate@et
</td><td>
`現在の再生~位置$は、通常の再生の一部として，とりわけ~~特徴的な仕方で
— 例えば不連続に —
変化した。
◎
The current playback position changed as part of normal playback or in an especially interesting way, for example discontinuously.
</td><td>

</td></tr><tr><td>`play@et
</td><td>
静止されていた要素は、再生され始めた。
［
`play()$mM ~methodが返った後 ／
`autoplay$aM 属性により再生を始めさせたとき
］に，発火される。
◎
The element is no longer paused. Fired after the play() method has returned, or when the autoplay attribute has caused playback to begin.
</td><td>
`paused$mM 値は新たに ~F になった。
◎
paused is newly false.

</td></tr><tr><td>`pause@et
</td><td>
要素は静止された。
`pause()$mM ~methodが返った後に発火される。
◎
The element has been paused. Fired after the pause() method has returned.
</td><td>
`paused$mM は新たに ~T になった。
◎
paused is newly true.

</td></tr><tr><td>`ratechange@et
</td><td>
［
`defaultPlaybackRate$mM ／ `playbackRate$mM
］属性が直前に更新された。
◎
Either the defaultPlaybackRate or the playbackRate attribute has just been updated.
</td><td>

</td></tr></tbody>

<tbody><tr><td>`resize@et
</td><td>
［
`videoWidth$mV ／ `videoHeight$mV
］属性が直前に更新された。
◎
One or both of the videoWidth and videoHeight attributes have just been updated.
</td><td>
［
`~media要素$は `video$e 要素である
］~AND［
`readyState$mM ~NEQ `HAVE_NOTHING$mM
］
◎
Media element is a video element; readyState is not HAVE_NOTHING

</td></tr><tr><td>`volumechange@et
</td><td>
［
`volume$mM ／ `muted$mM
］属性が変化した。
関連な属性の設定子が返った後に発火される。
◎
Either the volume attribute or the muted attribute has changed. Fired after the relevant attribute's setter has returned.
</td><td>

</td></tr></tbody></table>

<p>
次に挙げる~eventは、 `source$e 要素に向けて発火される：
◎
The following event fires on source element:
</p>

<table><thead><tr><th>~event名
</th><th>発火-時機
</th></tr></thead>

<tbody><tr><td>`~errorS@et
</td><td>
`~media~data$を~fetchしている間に~errorが生じた, または
資源の型は~supportされない~media形式である。
◎
An error occurs while fetching the media data or the type of the resource is not supported media format.

</td></tr></tbody></table>

<p>
次に挙げる~eventは、［
`AudioTrackList$I ／
`VideoTrackList$I ／
`TextTrackList$I
］~objに向けて発火される：
◎
The following events fire on AudioTrackList, VideoTrackList, and TextTrackList objects:
</p>

<table><thead><tr><th>~event名
</th><th>~interface
</th><th>発火-時機
</th></tr></thead>

<tbody><tr><td>`change@et
</td><td>`Event$I
</td><td>
~track~list内の 1 個~以上の~trackが［
可能化-／不能化-
］されたとき。
◎
One or more tracks in the track list have been enabled or disabled.

</td></tr><tr><td>`addtrack@et
</td><td>`TrackEvent$I
</td><td>
~track~listに~trackが追加されたとき。
◎
A track has been added to the track list.

</td></tr><tr><td>`removetrack@et
</td><td>`TrackEvent$I
</td><td>
~track~listから~trackが除去されたとき。
◎
A track has been removed from the track list.

</td></tr></tbody></table>

				</section>
				<section id="security-and-privacy-considerations">
<h5 title="Security and privacy considerations">4.8.12.17. ~securityと~privacy上の考慮点</h5>

<p>
`video$e ／ `audio$e
要素における 主な~securityや~privacy上の含意は、非同一-生成元の~mediaを埋込む能に~~由来する。
この脅威は、敵対的~内容から被害者~pageへ流れることも，その逆~方向へ流れることもある。
◎
The main security and privacy implications of the video and audio elements come from the ability to embed media cross-origin. There are two directions that threats can flow: from hostile content to a victim page, and from a hostile page to victim content.
</p>

<hr>

<p>
被害者~pageが敵対的~内容を埋込む場合の脅威は、当の内容が~scriptを含んでいて，それを埋込んでいる `Document$I とヤリトリしようと試みることにより生じる。
これを避けるため、~UAは，［
そのような内容は、埋込んでいる~pageに~accessし得ない
］ことを確保するモノトスル。
~media内容~DOM概念を利用している事例では、［
埋込まれた内容は、自前の無関係な`~top-level閲覧文脈$に属している
］かのように扱うモノトスル。
◎
If a victim page embeds hostile content, the threat is that the content might contain scripted code that attempts to interact with the Document that embeds the content. To avoid this, user agents must ensure that there is no access from the content to the embedding page. In the case of media content that uses DOM concepts, the embedded content must be treated as if it was in its own unrelated top-level browsing context.
</p>

<p class="example">
一例として、
`video$e 要素~内に~SVG~animationが埋込まれた場合、~UAは，外縁~pageの~DOMへの~accessは与えないことになる。
~SVG資源~内の~scriptの視点からは、~SVG~fileは，親のない~top-level閲覧文脈~内にあるかのように現れることになる。
◎
For instance, if an SVG animation was embedded in a video element, the user agent would not give it access to the DOM of the outer page. From the perspective of scripts in the SVG resource, the SVG file would appear to be in a lone top-level browsing context with no parent.
</p>

<hr>

<p>
敵対的~pageが被害者~内容を埋込む場合の脅威は、埋込んでいる~pageが，さもなければ~accessできない情報を当の内容から得せるときに生じる。
~APIは一部の情報
— その~mediaの存在, その［
型, 時間長, ~size
］, その~hostの処理能~上の特徴 —
については公開する。
そのような情報も~~問題になり得るが、実施においては，
`img$e 要素を利用しても およそ同じ情報を得せるので、受容-可能と判断されている。
◎
If a hostile page embeds victim content, the threat is that the embedding page could obtain information from the content that it would not otherwise have access to. The API does expose some information: the existence of the media, its type, its duration, its size, and the performance characteristics of its host. Such information is already potentially problematic, but in practice the same information can more or less be obtained using the img element, and so it has been deemed acceptable.
</p>

<p>
しかしながら，~UAが内容の中の~metadata
— 字幕など —
を更に公開した場合、より有意に敏感な情報も得せるようになる。
したがって，そのような情報は、動画~資源が~CORSを利用する場合に限り公開される。
作者は、 `crossorigin$aM 属性で~CORSを可能化できる。
`FETCH$r
◎
However, significantly more sensitive information could be obtained if the user agent further exposes metadata within the content, such as subtitles. That information is therefore only exposed if the video resource uses CORS. The crossorigin attribute allows authors to enable CORS. [FETCH]
</p>

<p class="example">
この制約がなければ、攻撃者は、企業内~networkの中で走らせている利用者を ~siteを訪問するよう騙して，企業の~intranet内の 以前に漏洩された所在から動画を読込ませるよう試みることも可能になる。
そのような動画が新製品の機密的な計画を含んでいた場合、字幕を読取れることにより，機密性に深刻な抜け穴を~~呈することになる。
◎
Without this restriction, an attacker could trick a user running within a corporate network into visiting a site that attempts to load a video from a previously leaked location on the corporation's intranet. If such a video included confidential plans for a new product, then being able to read the subtitles would present a serious confidentiality breach.
</p>

				</section>
				<section id="best-practices-for-authors-using-media-elements">
<h5 title="Best practices for authors using media elements">4.8.12.18. ~media要素を利用する作者~向けの最善な実施</h5>

~INFORMATIVE

<p>
音声や動画の資源を，~set-top-boxや携帯~電話などの小さい機器で再生するときは、~hardware資源の制限に拘束されることが多い。
例えば機器は、同時に 3 個の動画までしか~supportしないかもしれない。
この理由から、再生し終えた`~media要素$に保持されている資源を解放するのは，良い実施になる
— 要素への参照~すべてを注意深く除去して~garbage収集されるようにするか，
あるいはもっと良いのは、
要素の `src$aM 属性を空~文字列に設定するか，あるいは［
`srcObject$mM が ~NULL 以外に設定された事例では、
代わりに それを ~NULL に設定する
］ことにより。
◎
Playing audio and video resources on small devices such as set-top boxes or mobile phones is often constrained by limited hardware resources in the device. For example, a device might only support three simultaneous videos. For this reason, it is a good practice to release resources held by media elements when they are done playing, either by being very careful about removing all references to the element and allowing it to be garbage collected, or, even better, by setting the element's src attribute to an empty string. In cases where srcObject was set, instead set the srcObject to null.
</p>

<p>
同様に，再生~rateが正確に 1.0 でない下では、［
~hardware ／ ~software ／ 形式
］の制限により，動画~frameが落とされたり, 音声が震える／消音されることもある。
◎
Similarly, when the playback rate is not exactly 1.0, hardware, software, or format limitations can cause video frames to be dropped and audio to be choppy or muted.
</p>

				</section>
				<section id="best-practices-for-implementers-of-media-elements">
<h5 title="Best practices for implementers of media elements">4.8.12.19. ~media要素の実装者~向けの最善な実施</h5>

~INFORMATIVE

<p>
`~media要素$~APIの様々な側面を正確aにどう実装するかは、実装の品質における課題と見なされる。
◎
How accurately various aspects of the media element API are implemented is considered a quality-of-implementation issue.
</p>

<p>
例えば `buffered$mM 属性を実装するとき、~bufferされた一連の範囲を 実装がどこまで精確に報告するかは、~UAが~dataをどこまで注意深く検分するかに依存する。
~APIは，一連の範囲を一連の時刻として報告するが、~dataは~byte~streamで得されるので、可変~bitrateの~streamを受信している~UAが精確な時刻を決定するためには，すべての~dataを実際に復号するしかないかもしれない。
~UAには，これを行うことは要求されないが、代わりに見積もりを返せる（例えば，それまでの平均~bitrateに基づいて）
— それは、情報がより多く可用になるに伴い，改訂され続ける。
◎
For example, when implementing the buffered attribute, how precise an implementation reports the ranges that have been buffered depends on how carefully the user agent inspects the data. Since the API reports ranges as times, but the data is obtained in byte streams, a user agent receiving a variable-bitrate stream might only be able to determine precise times by actually decoding all of the data. User agents aren't required to do this, however; they can instead return estimates (e.g. based on the average bitrate seen so far) which get revised as more information becomes available.
</p>

<p>
一般~規則として、~UAには楽観的になるより保守的になることが督促される。
例えば、全部~bufferされていないのに，そうであるかのように報告するのは、不良になる。
◎
As a general rule, user agents are urged to be conservative rather than optimistic. For example, it would be bad to report that everything had been buffered when it had not.
</p>

<p>
実装~品質に関する別の課題は、~codecが順方向への再生~用にしか設計されてないときに，動画を逆方向に再生することであろう（例えば、~key-frameはまばらで，~~合間の各~frameは前の~frameからの差分しか持たない）。
~UAは、例えば ~key-frameしか示さないような拙い仕事を行うこともできるが、もっと作り込めば
— 例えば、動画の順方向にある部分を実際に復号して，完全な~frameたちを格納してから、逆方向に再生するなど —
より良い仕事を行う実装になる。
◎
Another quality-of-implementation issue would be playing a video backwards when the codec is designed only for forward playback (e.g. there aren't many key frames, and they are far apart, and the intervening frames only have deltas from the previous frame). User agents could do a poor job, e.g. only showing key frames; however, better implementations would do more work and thus do a better job, e.g. actually decoding parts of the video forwards, storing the complete frames, and then playing the frames backwards.
</p>

<p>
同様に，実装は、いつでも，~bufferされた~dataを落とすことが許容されるが（~UAが，得した~media~dataすべてを~media要素が存続する限り保ち続ける要件はない）、それもまた実装~品質の課題になる。
周りの~dataすべてを保つに足る資源がある~UAには、そうすることが奨励される
— その方が利用者~体験はより良くなるので。
例えば，利用者が~live~streamを視聴している場合、~UAは，~live動画しか見れなくすることもできるが、~UAが全部を~bufferして，［
より早い素材へ~seekする ／
静止する ／
順方向や逆方向に再生する
］, 等々を利用できた方が良くなる。
◎
Similarly, while implementations are allowed to drop buffered data at any time (there is no requirement that a user agent keep all the media data obtained for the lifetime of the media element), it is again a quality of implementation issue: user agents with sufficient resources to keep all the data around are encouraged to do so, as this allows for a better user experience. For example, if the user is watching a live stream, a user agent could allow the user only to view the live video; however, a better user agent would buffer everything and allow the user to seek through the earlier material, pause it, play it forwards and backwards, etc.
</p>

<hr>

<p>
静止されている`~media要素$が`文書から除去され$，次回に`~event~loop$の`最初の段$に達する前に挿入し直されなかったときは、資源が拘束されている実装には，`~media要素$に利用されているすべての~hardware資源（動画~plane, ~network用の資源, ~data~bufferなど）を解放する機会を~~活用することが奨励される（それでも，後で再生を開始し直す事例もあるので、~UAは再生~位置, 等々は保ち続ける必要があるが）。
◎
When a media element that is paused is removed from a document and not reinserted before the next time the event loop reaches step 1, implementations that are resource constrained are encouraged to take that opportunity to release all hardware resources (like video planes, networking resources, and data buffers) used by the media element. (User agents still have to keep track of the playback position and so forth, though, in case playback is later restarted.)
</p>
				</section>
			</section>
</main>
