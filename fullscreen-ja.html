<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Fullscreen API （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	Util.switchWordsInit({
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		toc_main: 'MAIN0',
		generate: expand
	});
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l': // literal
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm': // IDL member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Fullscreen API
spec_date:2025-02-11
trans_update:2025-02-13
source_checked:200611
spec_status:LS
original_url:https://fullscreen.spec.whatwg.org/
	abbr_url:FULLSCREEN
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:uievents
copyright:,whatwg
trans_1st_pub:2017-12-24


●●class_map
E:error
A:abstract
p:property
css:css
ps:pseudo
pe:pseudo
e:element
a:attr
h:header
v:value
et:event-type

●●tag_map
I:code
m:code
E:code
p:code
css:code
ps:code
pe:code
et:code
e:code
a:code
v:code
c:code
h:code
A:span
i:i
cite:cite

●●mdn_urls
css-pc-fullscreen:CSS/:fullscreen
css-pe-backdrop:CSS/::backdrop

dictdef-fullscreenoptions:API/FullscreenOptions
	enumdef-fullscreennavigationui:API/FullscreenNavigationUI

●●original_id_map
	old-links:new-stacking-layer
	old-links:top-layer
	old-links:top-layer-add
	old-links:::backdrop-pseudo-element
	old-links:css-pe-backdrop

●●link_map


	●IDL／code

LegacyLenientSetter:~WEBIDLjs#LegacyLenientSetter
Unscopable:~WEBIDLjs#Unscopable

boolean:~WEBIDL#idl-boolean
undefined:~WEBIDL#idl-undefined
Promise:~WEBIDL#idl-promise

E.TypeError:~WEBIDL#exceptiondef-typeerror
I.Document:~DOM4#document
I.EventHandler:~WAPI#eventhandler
I.DocumentOrShadowRoot:~DOM4#documentorshadowroot
I.Element:~DOM4#element
I.ShadowRoot:~DOM4#shadowroot
I.Window:~WINDOW#window
I.FullscreenNavigationUI:#enumdef-fullscreennavigationui
I.FullscreenOptions:#dictdef-fullscreenoptions

m.bubbles:~DOM4#dom-event-bubbles
m.composed:~DOM4#dom-event-composed

m.navigationUI:#dom-fullscreenoptions-navigationui

m.exitFullscreen:#dom-document-exitfullscreen
m.fullscreen:#dom-document-fullscreen
m.fullscreenElement:#dom-document-fullscreenelement
m.fullscreenEnabled:#dom-document-fullscreenenabled
m.onfullscreenchange:#handler-document-onfullscreenchange
m.onfullscreenerror:#handler-document-onfullscreenerror

m.requestFullscreen:#dom-element-requestfullscreen

l.fullscreen:#fullscreen-feature
l.auto:#dom-fullscreennavigationui-auto
l.show:#dom-fullscreennavigationui-show
l.hide:#dom-fullscreennavigationui-hide

et.fullscreenchange:#eventdef-document-fullscreenchange
et.fullscreenerror:#eventdef-document-fullscreenerror

e.dialog:~HEinteractive#the-dialog-element
e.iframe:~HEembed#the-iframe-element
e.svg:~SVGstruct#elementdef-svg
	e.svg:~SVG11/struct.html#SVGElement
e.math:~MATHMLcore#the-top-level-math-element
	https://www.w3.org/Math/draft-spec/chapter2.html#interf.toplevel

a.allowfullscreen:~HEembed#attr-iframe-allowfullscreen
a.allow:~HEembed#attr-iframe-allow

h.Permissions-Policy:~PERMISSIONS-POLICY#permissions-policy-header

ps.fullscreen:#css-pc-fullscreen
pe.backdrop:~CSSPOS4#selectordef-backdrop

	●用語

~fullscreenは~supportされて:#fullscreen-is-supported
~fullscreenから抜出る:#exit-fullscreen
~fullscreen要素~準備済み検査:#fullscreen-element-ready-check
~fullscreen要素:#fullscreen-element
~fullscreenか:#fullscreen-flag
~iframe~fullscreenか:#iframe-fullscreen-flag
要素を~fullscreen化する:#fullscreen-an-element
~fullscreenから全部的に抜出る:#fully-exit-fullscreen
処理待ち~fullscreen~event群:#list-of-pending-fullscreen-events
~fullscreen化~手続き:#run-the-fullscreen-steps
単純~fullscreen文書:#simple-fullscreen-document

~unfullscreenする文書を収集する:#collect-documents-to-unfullscreen
要素を~unfullscreenする:#unfullscreen-an-element
文書を~unfullscreenする:#unfullscreen-a-document

	●外部
上端~層:~CSSPOS4#document-top-layer
上端~層に要素を追加する:~CSSPOS4#add-an-element-to-the-top-layer
上端~層から要素を即時に除去する:~CSSPOS4#remove-an-element-from-the-top-layer-immediately

~HTML名前空間:~INFRA#html-namespace
空:~INFRA#list-empty
空にする:~INFRA#list-empty
set.付加する:~INFRA#set-append
~tuple:~INFRA#tuple
文字列:~INFRA#string
有順序~集合:~INFRA#ordered-set
	~EACH:~INFRA#list-iterate
	~WHILE:~INFRA#iteration-while
	~BREAK:~INFRA#iteration-break
	~CONTINUE:~INFRA#iteration-continue

~eventを発火する:~DOM4#concept-event-fire
接続されて:~DOM4#connected
文書:~DOM4#concept-document
要素:~DOM4#concept-element
~host:~DOM4#concept-documentfragment-host
el.名前空間:~DOM4#concept-element-namespace
~node文書:~DOM4#concept-node-document
除去-時の手続き:~DOM4#concept-node-remove-ext
~targetし直す:~DOM4#retarget
~shadow~host:~DOM4#element-shadow-host
~shadow根:~DOM4#concept-shadow-root
~shadowも含めた広義-子孫:~DOM4#concept-shadow-including-inclusive-descendant
~shadowも含めた~tree順序:~DOM4#concept-shadow-including-tree-order
~tree順序:~DOM4#concept-tree-order
~tree:~DOM4#concept-tree

並列的:~HTMLINFRA#in-parallel

~navigable:~HTMLds#navigable
~node~navigable:~HTMLds#node-navigable
子~navigable:~HTMLds#child-navigable
子孫~navigable群:~HTMLds#descendant-navigables
~top-level辿可能:~HTMLds#top-level-traversable
nav.~top-level辿可能:~HTMLds#nav-top
nav.作動中な文書:~HTMLds#nav-document
nav.容器:~HTMLds#nav-container
全部的に作動中:~HTMLds#fully-active

~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler内容~属性:~WAPI#event-handler-content-attributes
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler:~WAPI#event-handlers
~event~loop:~WAPI#event-loop
関連な大域~obj:~WAPI#concept-relevant-global

特能の利用は許容され:~HEembed#allowed-to-use

	廃）利用者が生成した方位~変更により誘発され:~SCREEN-ORIENTATION#dfn-triggered-by-a-user-generated-orientation-change
~screen方位を全部的に~unlockする手続き:~SCREEN-ORIENTATION#dfn-fully-unlock-the-screen-orientation-steps

一過な作動化を有して:~HTMLinteraction#transient-activation
利用者-作動化を消費する:~HTMLinteraction#consume-user-activation

最上層な~popover先祖を見出す:~HTMLpopover#topmost-popover-ancestor
ある所までの~popoverをすべて隠す:~HTMLpopover#hide-all-popovers-until
~popover可視性~状態:~HTMLpopover#popover-visibility-state
i.隠している:~HTMLpopover#popover-hidden-state

文書~unload時の片付け手続き:~HTMLlifecycle#unloading-document-cleanup-steps

doc.許可~施策:~HTMLdom#concept-document-permissions-policy

施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature
既定の許容list:~PERMISSIONS-POLICY#policy-controlled-feature-default-allowlist
容器~施策:~PERMISSIONS-POLICY#container-policy
	~PERMISSIONS-POLICY#iframe-allowfullscreen-attribute

_acks1:#_acks1
_ipr1:#_ipr1

	●補完
新たな~promise:~WEBIDLjs#a-new-promise
~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve
疑似類:~SELECTORS4#pseudo-class

●●words_table1

●●words_table

	●UI
fullscreen::::全スクリーン
fullscreen-::::全スクリーン化
	~fullscreenになる:go fullscreen
unfullscreen::非 fullscreen 化::非全スクリーン化
一過:transient::~
開いて:openして::~
隠す:hideする:~
抜出る:exitする::抜け出る
popover:

	●CSS
重層する:overlayする::層を重ねる
最上層:topmost::~
出自の:originating::~

	●処理
unlock::::アンロック
unload:
処理待ち:pending:~
片付け:cleanup::~
復帰-:revert::~
終止-:end:~
候補:candidate:~
process::::プロセス
	~process外:out-of-process

	~targetし直す:retarget
	~unload時の:unloading
	いつでも:always
	それまでに:previously
	…以下の:remaining
	済んだ時点で:when done
	後に来る:comes after

	%どこまで隠すか:hideUntil
	%文書:doc
	%~fullscreen要素~群:fullscreenElements
	%除去された~node:removedNode
	%~top-level文書:topLevelDoc
	%文書:lastDoc
	%抜出る文書~群:exitDocs
	%抜出る文書:exitDoc
	%子孫~文書~群:descendantDocs
	%子孫~文書:descendantDoc
	%処理待ち文書:pendingDoc

	●仕様
改善案:potential improvements:~
末端利用者:end user:~:::エンドユーザ
指図-:instruct:~
指図:instruction:~
	呼ばれ:called
告知-:advertise:~
給-:supply:~
宿題:exercise:~

	気付ける:aware
	かまわない:free to
	平易に:simplicity
	他が言明されない限り:unless stated otherwise
	~~模造:recreate
	欺く:spoof する
	という:said to be

	●未分類
広義-:inclusive:~
	観測され得ない:not observable
iframe:
許容list:allowlist::許容 list:許容リスト
MathML:

	分だけ除いた:clamp
	より広い:more
	現れ:appear
	になる:go
	~CSS22
	https://www.w3.org/TR/CSS2/zindex.html
	~F:unset
	:against
	-:go
	下位節:subsection
	節:section:
	一部を成す:part of

●●ref_key_map
SVG:SVG11
CSS:CSS21

●●ref_normative

[CSS]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSS-POSITION-4]
    ＜CSS Positioned Layout Module Level 4＞. Editor's Draft. URL: https://drafts.csswg.org/css-position-4/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MATHML]
    Patrick D F Ion; Robert R Miner. ＜Mathematical Markup Language (MathML™) 1.01 Specification＞. 7 March 2023. REC. URL: https://www.w3.org/TR/REC-MathML/
[PERMISSIONS-POLICY-1]
    Ian Clelland. ＜Permissions Policy＞. URL: https://w3c.github.io/webappsec-permissions-policy/
[SCREEN-ORIENTATION]
    Marcos Caceres. ＜Screen Orientation＞. URL: https://w3c.github.io/screen-orientation/
[SVG]
    Erik Dahlström; et al. ＜Scalable Vector Graphics (SVG) 1.1 (Second Edition)＞. 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://fullscreen.spec.whatwg.org/">Fullscreen API</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/fullscreen">GitHub whatwg/fullscreen</a> (<a href="https://github.com/whatwg/fullscreen/issues/new/choose">new issue</a>, <a href="https://github.com/whatwg/fullscreen/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	<a href="https://github.com/whatwg/fullscreen/commits">GitHub whatwg/fullscreen/commits</a>
	<a href="https://fullscreen.spec.whatwg.org/commit-snapshots/1c324eeafe81ace8fc3e3b1c9c04776787a01f90/" id="commit-snapshot-link">Snapshot as of this commit</a></dd>
	<a href="https://twitter.com/fullscreenapi">@fullscreenapi</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/fullscreen">web-platform-tests fullscreen/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/fullscreen">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）
	<a href="https://htmlspecs.com/fullscreen/" hreflang="zh-hans" lang="zh-hans" rel="alternate">简体中文</a>

</script>
</head><body>

<header>
<a href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPHBhdGggZD0ibTAsMGgxMDB2MTAwaC0xMDB6IiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJtNSw0MHYtMzVoMzVtMjAsMGgzNXYzNW0wLDIwdjM1aC0zNW0tMjAsMGgtMzV2LTM1IiBzdHJva2Utd2lkdGg9IjEwIiBzdHJva2U9IiMzYzc5MGEiIGZpbGw9Im5vbmUiLz4KPHBhdGggZD0ibTM4LDM4YzAtMTIsMjQtMTUsMjMtMmMwLDktMTYsMTMtMTYsMjN2N2gxMHYtNGMwLTksMTctMTIsMTctMjdjLTItMjItNDUtMjItNDUsM3ptNywzMmgxMHYxMGgtMTAiIGZpbGw9IiMzYzc5MGEiLz4KPC9zdmc+Cg=="
></a>

	<hgroup>
<h1>Fullscreen API</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
Fullscreen ~API 標準は、自身を~fullscreenに表示する要素~用の~APIを定義する。
◎
The Fullscreen API standard defines an API for elements to display themselves fullscreen.
</p>

	</section>

<main id="MAIN0">

	<section id="terminology">
<h2 title="Terminology">1. 各種用語</h2>

<p>
この仕様は、
`INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様に利用される各種用語のほとんどは、
`CSS$r, `DOM$r, `HTML$r, `WEBIDL$r
による。
◎
Most terminology used in this specification is from CSS, DOM, HTML, and Web IDL. [CSS] [DOM] [HTML] [WEBIDL]
</p>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

		</section>
	</section>
	<section id="model">
<h2 title="Model">2. ~model</h2>

<p>
各 `要素$には，
`~fullscreenか@
が結付けられる
— それは、
真偽値であり，
他が言明されない限り ~F をとるとする。
◎
All elements have an associated fullscreen flag. Unless stated otherwise it is unset.
</p>

<p>
各 `iframe$e `要素$には，
`~iframe~fullscreenか@
が結付けられる
— それは、
真偽値であり，
他が言明されない限り ~F をとるとする。
◎
All iframe elements have an associated iframe fullscreen flag. Unless stated otherwise it is unset.
</p>

<p>
所与の`文書$ %文書 の
`~fullscreen要素@
は、
次を満たす %要素 は［
在るならば それらのうち最上層な【すなわち，最後の（最も手前に塗られる）】もの／
無いならば ~NULL
］とする
⇒
［
%要素 ~IN %文書 の`上端~層$
］~AND［
%要素 の`~fullscreenか$ ~EQ ~T
］
◎
All documents have an associated fullscreen element. The fullscreen element is the topmost element in the document’s top layer whose fullscreen flag is set, if any, and null otherwise.
</p>

<p>
各 `文書$には
`処理待ち~fullscreen~event群@
が結付けられる。
それは、［
( `文字列$, `要素$ )
が成す`~tuple$
］たちが成す`有順序~集合$であり，初期~時は空とする。
【この集合を成す~itemどうしの同等性は、成分ごとの比較に基づくことになろう。】
◎
All documents have an associated list of pending fullscreen events, which is an ordered set of (string, element) tuples. It is initially empty.
</p>

<div class="algo">
<p>
`要素を~fullscreen化する@
~algoは、
所与の
( %要素 )
に対し：
◎
To fullscreen an element:
</p>
<ol>
	<li>
%どこまで隠すか ~LET `最上層な~popover先祖を見出す$( %要素, ~NULL, ~F )
◎
Let hideUntil be the result of running topmost popover ancestor given element, null, and false.
</li>
	<li>
~IF［
%どこまで隠すか ~EQ ~NULL
］
⇒
%どこまで隠すか ~SET %要素 の`~node文書$
◎
If hideUntil is null, then set hideUntil to element’s node document.
</li>
	<li>
`ある所までの~popoverをすべて隠す$( %どこまで隠すか, ~F, ~T )
◎
Run hide all popovers until given hideUntil, false, and true.
</li>
	<li>
%要素 の`~fullscreenか$ ~SET ~T
◎
Set element’s fullscreen flag.
</li>
	<li>
`上端~層から要素を即時に除去する$( %要素 )
◎
Remove from the top layer immediately given element.
</li>
	<li>
`上端~層に要素を追加する$( %要素 )
◎
Add to the top layer given element.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素を~unfullscreenする@
~algoは、
所与の
( %要素 )
に対し：
◎
To unfullscreen an element,＼
</p>
<ol>
	<li>
%要素 の`~fullscreenか$ ~SET ~F
◎
unset element’s fullscreen flag＼
</li>
	<li>
~IF［
%要素 は `iframe$e 要素である
］
⇒
%要素 の`~iframe~fullscreenか$ ~SET ~F
◎
and iframe fullscreen flag (if any),＼
</li>
	<li>
`上端~層から要素を即時に除去する$( %要素 )
◎
and remove from the top layer immediately given element.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書を~unfullscreenする@
~algoは、
所与の
( %文書 )
に対し
⇒
%文書 の`上端~層$を成す
~EACH( `要素$ %要素 )
に対し
⇒
~IF［
%要素 の`~fullscreenか$ ~EQ ~T
］
⇒
`要素を~unfullscreenする$( %要素 )
◎
To unfullscreen a document, unfullscreen all elements, within document’s top layer, whose fullscreen flag is set.
</p>
</div>

<hr>

<div class="algo">
<p>
`~fullscreenから全部的に抜出る@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To fully exit fullscreen a document document, run these steps:
</p>

<ol>
	<li>
~IF［
%文書 の`~fullscreen要素$ ~EQ ~NULL
］
⇒
~RET
◎
If document’s fullscreen element is null, terminate these steps.
</li>
	<li>
%文書 の`上端~層$を成す
~EACH( %要素 )
に対し
⇒
~IF［
%要素 の`~fullscreenか$ ~EQ ~T
］~AND［
%要素 ~NEQ %文書 の`~fullscreen要素$
］
⇒
`要素を~unfullscreenする$( %要素 )
◎
Unfullscreen elements whose fullscreen flag is set, within document’s top layer, except for document’s fullscreen element.
</li>
	<li>
`~fullscreenから抜出る$( %文書 )
◎
Exit fullscreen document.
</li>
</ol>
</div>

<div class="algo">
<p id="removing-steps">
`除去-時の手続き$は、
所与の
( %除去された~node )
に対し：
◎
Whenever the removing steps run with a removedNode, run these steps:
</p>

<ol>
	<li>
%文書 ~LET %除去された~node の`~node文書$
◎
Let document be removedNode’s node document.
</li>
	<li>
<p>
%除去された~node の
~EACH( `~shadowも含めた広義-子孫$ %~node )
に対し，`~shadowも含めた~tree順序$で：
◎
Let nodes be removedNode’s shadow-including inclusive descendants that have their fullscreen flag set, in shadow-including tree order.
◎
For each node in nodes:
</p>
		<ol>
			<li>
~IF［
%~node の`~fullscreenか$ ~EQ ~F
］
⇒
~CONTINUE
◎
↑</li>
			<li>
~IF［
%~node ~EQ %文書 の`~fullscreen要素$
］
⇒
`~fullscreenから抜出る$( %文書 )
◎
If node is document’s fullscreen element, exit fullscreen document.
</li>
			<li>
~ELSE
⇒
`要素を~unfullscreenする$( %~node )
◎
Otherwise, unfullscreen node.
</li>
			<li>
<p>
~IF［
%~node ~IN %文書 の`上端~層$
］
⇒
`上端~層から要素を即時に除去する$( %~node )
◎
If document’s top layer contains node, remove from the top layer immediately given node.
</p>

<p class="note">注記：
`上端~層$は，他の仕様から要素が追加されたり除去され得るので、
%~node は %文書 の`~fullscreen要素$でないかもしれない。
例えば、
%~node は開いている `dialog$e 要素にもなり得る。
◎
Other specifications can add and remove elements from top layer, so node might not be document’s fullscreen element. For example, node could be an open dialog element.
</p>
			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`文書~unload時の片付け手続き$は、
所与の
( %文書 )
に対し
⇒
`~fullscreenから全部的に抜出る$( %文書 )
◎
Whenever the unloading document cleanup steps run with a document, fully exit fullscreen document.
</p>
</div>

<hr>

<p>
`~fullscreenは~supportされて@
いるとは、
それまでに確立された
【すなわち、所与の時点で，~fullscreen化を防止するような】
［
利用者-選好, ~security~risk, ~platform制限
］は無いことを~~意味する。
◎
Fullscreen is supported if there is no previously-established user preference, security risk, or platform limitation.
</p>

<hr>

<div class="algo">
<p>
`~fullscreen化~手続き@
は、
所与の
( `文書$ %文書 )
に対し：
◎
To run the fullscreen steps for a document document, run these steps:
</p>

<ol>
	<li>
%処理待ち~event群 ~LET %文書 の`処理待ち~fullscreen~event群$【の~clone】
◎
Let pendingEvents be document’s list of pending fullscreen events.
</li>
	<li>
%文書 の`処理待ち~fullscreen~event群$を`空にする$
◎
Empty document’s list of pending fullscreen events.
</li>
	<li>
<p>
%処理待ち~event群 を成す
~EACH( ~tuple ( %型, %要素 ) )
に対し：
◎
For each (type, element) in pendingEvents:
</p>
		<ol>
			<li>
%~target ~LET ［
次が満たされるならば %要素 ／
~ELSE_ %文書
］
⇒
［
%要素 は`接続されて$いる
］~AND［
%要素 の`~node文書$ ~EQ %文書
］
◎
Let target be element if element is connected and its node document is document, and otherwise let target be document.
</li>
			<li>
`~eventを発火する$( %~target, %型 )
— 次のように初期化して
⇒＃
`bubbles$m 属性 ~SET ~T,
`composed$m 属性 ~SET ~T
◎
Fire an event named type, with its bubbles and composed attributes set to true, at target.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
この手続きは、
`HTML$r にて定義される`描画を更新する手続き＠~WAPI#update-the-rendering$【！`~event~loop$】に統合されている。
◎
These steps integrate with the event loop defined in HTML. [HTML]
</p>
</div>

	</section>
	<section id="api">
<h2 title="API">3. ~API</h2>

<pre class="idl">
enum `FullscreenNavigationUI@I {
  `auto$l,
  `show$l,
  `hide$l
};

dictionary `FullscreenOptions@I {
  `FullscreenNavigationUI$I `navigationUI@m = "auto";
};

partial interface `Element$I {
  `Promise$&lt;`undefined$&gt; `requestFullscreen$m(optional `FullscreenOptions$I %options = {});

  attribute `EventHandler$I `onfullscreenchange$m;
  attribute `EventHandler$I `onfullscreenerror$m;
};

partial interface `Document$I {
  [`LegacyLenientSetter$] readonly attribute `boolean$ `fullscreenEnabled$m;
  [`LegacyLenientSetter$, `Unscopable$] readonly attribute `boolean$ `fullscreen$m; // <span class="comment">歴史的</span>

  `Promise$&lt;`undefined$&gt; `exitFullscreen$m();

  attribute `EventHandler$I `onfullscreenchange$m;
  attribute `EventHandler$I `onfullscreenerror$m;
};

partial interface mixin `DocumentOrShadowRoot$I {
  [`LegacyLenientSetter$] readonly attribute `Element$I? `fullscreenElement$m;
};
</pre>

<dl class="domintro">
	<dt>%promise = %element . `requestFullscreen([options])$m</dt>
	<dd>
%element を~fullscreenに表示する
— 済んだ時点で  %promise を解決する。
◎
Displays element fullscreen and resolves promise when done.
</dd>
	<dd>
%options の `navigationUI$m ~memberが給されたときは、［
~fullscreenが選好される間，~navi~UIを示すかどうか
］を指示する。
`show$l に設定した場合、
~screen空間を広くとるより~naviを平易にする方が選好される。
`hide$l に設定した場合、
~screen空間を広くとる方が選好される。
~UAは、
いつでも，~appの選好より利用者-選好を尊守することにしてもかまわない。
既定の値 `auto$l は、
~appによる選好は無いことを指示する。
◎
When supplied, options’s navigationUI member indicates whether showing navigation UI while in fullscreen is preferred or not. If set to "show", navigation simplicity is preferred over screen space, and if set to "hide", more screen space is preferred. User agents are always free to honor user preference over the application’s. The default value "auto" indicates no application preference.
</dd>

	<dt>%document . `fullscreenEnabled$m</dt>
	<dd>
［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返す
⇒
［
%document は `要素$を~fullscreenに表示する能を備える
］~AND［
`~fullscreenは~supportされて$いる
］
◎
Returns true if document has the ability to display elements fullscreen and fullscreen is supported, or false otherwise.
</dd>

	<dt>%promise = %document . `exitFullscreen()$m</dt>
	<dd>
%document の`~fullscreen要素$の~fullscreen表示-を停止する
— 済んだ時点で %promise を解決する。
◎
Stops document’s fullscreen element from being displayed fullscreen and resolves promise when done.
</dd>

	<dt>%document . `fullscreenElement$m</dt>
	<dd>
%document の`~fullscreen要素$を返す。
◎
Returns document’s fullscreen element.
</dd>

	<dt>%shadowroot . `fullscreenElement$m</dt>
	<dd>
%shadowroot の`~fullscreen要素$を返す。
◎
Returns shadowroot’s fullscreen element.
</dd>
</dl>

<div class="algo">
<p>
`~fullscreen要素~準備済み検査@
は、
所与の
( `要素$ %要素 )
に対し
⇒
~RET ~IS ~AND↓：
◎
A fullscreen element ready check for an element element returns true if all of the following are true, and false otherwise:
</p>
<ul>
	<li>
%要素 は`接続されて$いる
◎
element is connected.
</li>
	<li>
%要素 の`~node文書$には `fullscreen$l `特能の利用は許容され$ている
◎
element’s node document is allowed to use the "fullscreen" feature.
</li>
	<li>
［
%要素 の`名前空間$el ~NEQ `~HTML名前空間$
］~OR［
%要素 の`~popover可視性~状態$ ~EQ `隠している$i
］
◎
element namespace is not the HTML namespace or element’s popover visibility state is hidden.
</li>
</ul>
</div>

<div class="algo">
<p>
`requestFullscreen(options)@m
~method~手続きは：
◎
The requestFullscreen(options) method steps are:
</p>
<ol>
	<li>
%処理待ち文書 ~LET コレの`~node文書$
◎
Let pendingDoc be this’s node document.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
~IF［
%処理待ち文書 は`全部的に作動中$でない
］
⇒＃
`~promiseを却下する$( %~promise, `TypeError$E 例外 )；
~RET %~promise
◎
If pendingDoc is not fully active, then reject promise with a TypeError exception and return promise.
</li>
	<li>
<p>
%~error ~LET ~IS ~NOT ~AND↓：
◎
Let error be false.
◎
If any of the following conditions are false, then set error to true:
</p>
		<ul>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
コレの`名前空間$el ~EQ `~HTML名前空間$
</li>
					<li>
コレは~SVG `svg$e 要素である `SVG$r
</li>
					<li>
コレは~MathML `math$e 要素である `MATHML$r
</li>
				</ul>
◎
This’s namespace is the HTML namespace or this is an SVG svg or MathML math element. [SVG] [MATHML]
</li>
			<li>
コレは `dialog$e 要素でない
◎
This is not a dialog element.
</li>
			<li>
`~fullscreen要素~準備済み検査$( コレ ) ~EQ ~T
◎
The fullscreen element ready check for this returns true.
</li>
			<li>
`~fullscreenは~supportされて$いる
◎
Fullscreen is supported.
</li>
			<li>
<p>
［
コレに`関連な大域~obj$は`一過な作動化を有して$いる
］~OR［
この~algoは、
利用者が生成した方位~変更により誘発された†
］
</p>

<p class="trans-note">【†
この用語は、
`SCREEN-ORIENTATION$r に定義されていたが，今や廃された。
】</p>
◎
This’s relevant global object has transient activation or the algorithm is triggered by a user generated orientation change.
</li>
		</ul>
	</li>
	<li>
~IF［
%~error ~EQ ~F
］
⇒
`利用者-作動化を消費する$( %処理待ち文書 に`関連な大域~obj$ )
◎
If error is false, then consume user activation given pendingDoc’s relevant global object.
</li>
	<li>
<p>
~RET %~promise
— 加えて…
◎
Return promise,＼
</p>
<div class="algo">
<p>
…以下の手続きも`並列的$に走らす：
◎
and run the remaining steps in parallel.
</p>
		<ol>
			<li>
<p>
~IF［
%~error ~EQ ~F
］：
◎
If error is false, then＼
</p>
				<ul>
					<li>
<p>
%処理待ち文書 の`~node~navigable$の`~top-level辿可能$navにて`作動中な文書$navの表示域の寸法を~resizeする
— 任意選択で†
%options[ "`navigationUI$m" ] の値を織り込む下で：
◎
resize pendingDoc’s node navigable’s top-level traversable’s active document’s viewport’s dimensions, optionally taking into account options["navigationUI"]:
</p>

<table><thead>
<tr><th>値
<th>表示域の寸法
<tbody>

<tr><td>`hide@l
<td>
出力-機器の~screenの全部的な寸法
◎
full dimensions of the screen of the output device

<tr><td>`show@l
<td>
出力-機器の~screenから［
~UAが示す~page~navi~controlが占める部分
］を除いた寸法
◎
dimensions of the screen of the output device clamped to allow the user agent to show page navigation controls

<tr><td>`auto@l
<td>
他の行に挙げたいずれか
— どの寸法かは、
~UAが定義する
◎
user-agent defined, but matching one of the above
</table>

<p class="trans-note">【†
織り込まない場合、
`auto$l であったかのように挙動すると思われる。
】</p>
					</li>
					<li>
加えて，任意選択で
⇒
末端利用者~向けに、
これを復帰する方法について~~述べる~messageを表示する
◎
Optionally display a message how the end user can revert this.
</li>
				</ul>
			</li>
			<li>
<p>
~ELIF［
~NOT ~AND↓
］…
◎
If any of the following conditions are false, then set error to true:
</p>
				<ul>
					<li>
コレの`~node文書$ ~EQ %処理待ち文書
◎
This’s node document is pendingDoc.
</li>
					<li>
`~fullscreen要素~準備済み検査$( コレ ) ~EQ ~T
◎
The fullscreen element ready check for this returns true.
</li>
				</ul>
<p>
…ならば：
◎
If error is true:
</p>
				<ol>
					<li>
%処理待ち文書 の`処理待ち~fullscreen~event群$に
( `fullscreenerror$et, コレ )
を`付加する$set
◎
Append (fullscreenerror, this) to pendingDoc’s list of pending fullscreen events.
</li>
					<li>
`~promiseを却下する$( %~promise, `TypeError$E 例外 )
◎
Reject promise with a TypeError exception and＼
</li>
					<li>
~RET
◎
terminate these steps.
</li>
				</ol>
			</li>
			<li>
%~fullscreen要素~群 ~LET 新たな`有順序~集合$
◎
Let fullscreenElements be an ordered set＼
</li>
			<li>
%要素 ~LET コレ
◎
initially consisting of this.
</li>
			<li>
<p>
~WHILE［
%要素 ~NEQ ~NULL
］：
</p>
				<ol>
					<li>
%~fullscreen要素~群 に %要素 を`付加する$set
</li>
					<li>
%要素 ~LET %要素 の`~node~navigable$の`容器$nav
</li>
				</ol>
◎
While true:
• Let last be the last item of fullscreenElements.
• Let container be last’s node navigable’s container.
• If container is null, then break.
• Append container to fullscreenElements.
</li>
			<li>
<p>
%~fullscreen要素~群 を成す
~EACH( %要素 )
に対し：
◎
For each element in fullscreenElements:
</p>

				<ol>
					<li>
%文書 ~LET %要素 の`~node文書$
◎
Let doc be element’s node document.
</li>
					<li>
<p>
~IF［
%要素 ~EQ %文書 の`~fullscreen要素$
］
⇒
~CONTINUE
◎
If element is doc’s fullscreen element, continue.
</p>

<p class="note">注記：
何も変化しない場合、
観測器に通知する必要は無い。
◎
No need to notify observers when nothing has changed.
</p>
					</li>
					<li>
~IF［
%要素 ~EQ コレ
］~AND［
コレは `iframe$e `要素$である
］
⇒
%要素 の`~iframe~fullscreenか$ ~SET ~T
◎
If element is this and this is an iframe element, then set element’s iframe fullscreen flag.
</li>
					<li>
`要素を~fullscreen化する$( %要素 )
◎
Fullscreen element within doc.
</li>
					<li>
%文書 の`処理待ち~fullscreen~event群$に
( `fullscreenchange$et, %要素 )
を`付加する$set
◎
Append (fullscreenchange, element) to doc’s list of pending fullscreen events.
</li>
				</ol>

<p class="note">注記：
要素たちが~fullscreen化される順序は、
観測され得ない
— `~fullscreen化~手続き$は、
`~tree順序$で呼出されるので。
【なぜ観測され得ない？】
◎
The order in which elements are fullscreened is not observable, because run the fullscreen steps is invoked in tree order.
</p>
			</li>
			<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
		</ol>
</div>
	</li>
</ol>

<p class="note">注記：
~process外にある【？】`~navigable$での実装は、
読者への宿題として残される。
改善案があれば歓迎する。
◎
Implementations with out-of-process navigables are left as an exercise to the reader. Input welcome on potential improvements.
</p>
</div>

<div class="algo">
<p>
`fullscreenEnabled@m
取得子~手続きは
⇒
~RET ~IS［
コレには `fullscreen$l `特能の利用は許容され$ている
］~AND［
`~fullscreenは~supportされて$いる
］
◎
The fullscreenEnabled getter steps are to return true if this is allowed to use the "fullscreen" feature and fullscreen is supported, and false otherwise
</div>

<div class="algo">
<p>
`fullscreen@m
取得子~手続きは
⇒
~RET ~IS［
コレの`~fullscreen要素$ ~NEQ ~NULL
］
◎
The fullscreen getter steps are to return false if this’s fullscreen element is null, and true otherwise.
</p>

<p class="note">注記：
作者は、
代わりに `fullscreenElement$m 属性を利用するように。
◎
Use the fullscreenElement attribute instead.
</p>
</div>

<div class="algo">
<p>
`fullscreenElement@m
取得子~手続きは：
◎
The fullscreenElement getter steps are:
</p>
<ol>
	<li>
~IF［
コレは`~shadow根$である
］~AND［
コレの`~host$は`接続されて$いない
］
⇒
~RET ~NULL
◎
If this is a shadow root and its host is not connected, then return null.
</li>
	<li>
%候補 ~LET コレの`~fullscreen要素$をコレに向けて`~targetし直す$
◎
Let candidate be the result of retargeting fullscreen element against this.
</li>
	<li>
~IF［
( %候補, コレ )
は同じ`~tree$内にある
］
⇒
~RET %候補
◎
If candidate and this are in the same tree, then return candidate.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<p>
次を満たす`文書$ %文書 は
`単純~fullscreen文書@
という
⇒
［
%文書 の`上端~層$内の`要素$のうち［
`~fullscreenか$ ~EQ ~T
］を満たすもの
］の個数 ~EQ 1
◎
A document is said to be a simple fullscreen document if there is exactly one element in its top layer that has its fullscreen flag set.
</p>

<p class="note">注記：
`上端~層$内に 2 個の `要素$がある`文書$でも，`単純~fullscreen文書$になり得る。
例えば、
`~fullscreen要素$に加えて，開いている `dialog$e 要素がある場合。
◎
A document with two elements in its top layer can be a simple fullscreen document. For example, in addition to the fullscreen element there could be an open dialog element.
</p>

<div class="algo">
<p>
`~unfullscreenする文書を収集する@
~algoは、
所与の
( %文書 )
に対し：
◎
To collect documents to unfullscreen given doc, run these steps:
</p>

<ol>
	<li>
%文書~群 ~LET 新たな`有順序~集合$
◎
Let docs be an ordered set＼
↓ consisting of doc.
</li>
	<li>
<p>
~WHILE 無条件
</p>
		<ol>
			<li>
~Assert：
%文書 の`~fullscreen要素$ ~NEQ ~NULL
</li>
			<li>
%文書~群 に %文書 を`付加する$set
</li>
			<li>
~IF［
%文書 は`単純~fullscreen文書$でない
］
⇒
~BREAK
</li>
			<li>
%容器 ~LET %文書 の`~node~navigable$の`容器$nav
</li>
			<li>
~IF［
%容器 ~EQ ~NULL
］
⇒
~BREAK
</li>
			<li>
~IF［
%容器 の`~iframe~fullscreenか$ ~EQ ~F
【！原文 set( ~T ) は誤り】
］
⇒
~BREAK
</li>
			<li>
%文書 ~SET %容器 の`~node文書$
</li>
		</ol>
◎
While true:
• Let lastDoc be docs’s last document.
• Assert: lastDoc’s fullscreen element is not null.
• If lastDoc is not a simple fullscreen document, break.
• Let container be lastDoc’s node navigable’s container.
• If container is null, then break.
• If container’s iframe fullscreen flag is set, break.
• Append container’s node document to docs.
</li>
	<li>
<p>
~RET %文書~群
◎
Return docs.
</p>

<p class="note">注記：
%文書~群 は，文書のうち［
その`~fullscreen要素$が~unfullscreenされることになるもの
］からなるが、
その最後の文書 %文書 の`上端~層$内には［
`~fullscreenか$ ~EQ ~T
］にされた`要素$が複数個あるかもしれない
— その事例では、
%文書 は依然として，~fullscreenであり続けることになる。
◎
This is the set of documents for which the fullscreen element will be unfullscreened, but the last document in docs might have more than one element in its top layer with the fullscreen flag set, in which case that document will still remain in fullscreen.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~fullscreenから抜出る@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To exit fullscreen a document doc, run these steps:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］~OR［
%文書 の`~fullscreen要素$ ~EQ ~NULL
］
⇒＃
`~promiseを却下する$( %~promise, `TypeError$E 例外 )；
~RET %~promise
◎
If doc is not fully active or doc’s fullscreen element is null, then reject promise with a TypeError exception and return promise.
</li>
	<li>
%~resizeか ~LET ~F
◎
Let resize be false.
</li>
	<li>
%文書~群 ~LET `~unfullscreenする文書を収集する$( %文書 )
◎
Let docs be the result of collecting documents to unfullscreen given doc.
</li>
	<li>
%~top-level文書 ~LET %文書 の`~node~navigable$の`~top-level辿可能$navにて`作動中な文書$nav
◎
Let topLevelDoc be doc’s node navigable’s top-level traversable’s active document.
</li>
	<li>
~IF［
%~top-level文書 ~IN %文書~群
］~AND［
%~top-level文書 は`単純~fullscreen文書$である
］
⇒＃
%文書 ~SET %~top-level文書；
%~resizeか ~SET ~T
◎
If topLevelDoc is in docs, and it is a simple fullscreen document, then set doc to topLevelDoc and resize to true.
</li>
	<li>
<p>
~IF［
%文書 の`~fullscreen要素$は`接続されて$いない
］：
◎
If doc’s fullscreen element is not connected:
</p>
		<ol>
			<li>
%文書 の`処理待ち~fullscreen~event群$に
( `fullscreenchange$et, %文書 の`~fullscreen要素$ )
を`付加する$set
◎
Append (fullscreenchange, doc’s fullscreen element) to doc’s list of pending fullscreen events.
</li>
			<li>
`要素を~unfullscreenする$( %文書 の`~fullscreen要素$ )
◎
Unfullscreen doc’s fullscreen element.
</li>
		</ol>
	</li>
	<li>
<p>
~RET %~promise
— 加えて…
◎
Return promise,＼
</p>

<div class="algo">
<p>
…以下の手続きも`並列的$に走らす：
◎
and run the remaining steps in parallel.
</p>
		<ol>
			<li>
`~screen方位を全部的に~unlockする手続き$( %文書 )
◎
Run the fully unlock the screen orientation steps with doc.
</li>
			<li>
~IF［
%~resizeか ~EQ ~T
］
⇒
%文書 の表示域を その “通常の” 寸法に~resizeする
◎
If resize is true, resize doc’s viewport to its "normal" dimensions.
</li>
			<li>
~IF［
%文書 の`~fullscreen要素$ ~EQ ~NULL
］
⇒＃
`~promiseを解決する$( %~promise )；
~RET
◎
If doc’s fullscreen element is null, then resolve promise with undefined and terminate these steps.
</li>
			<li>
%抜出る文書~群 ~LET `~unfullscreenする文書を収集する$( %文書 )
◎
Let exitDocs be the result of collecting documents to unfullscreen given doc.
</li>
			<li>
%子孫~文書~群 ~LET 新たな`有順序~集合$
◎
↓</li>
			<li>
%文書 の`子孫~navigable群$を成す
~EACH( %子孫 )
に対し【！in tree order は不要】
⇒
~IF［
%子孫 にて`作動中な文書$navの`~fullscreen要素$ ~NEQ ~NULL
］
⇒
%子孫~文書~群 に %子孫 にて`作動中な文書$navを`付加する$set
◎
Let descendantDocs be an ordered set consisting of doc’s descendant navigables' active documents whose fullscreen element is non-null, if any, in tree order.
</li>
			<li>
<p>
%抜出る文書~群 を成す
~EACH( %抜出る文書 )
に対し：
◎
For each exitDoc in exitDocs:
</p>
				<ol>
					<li>
%抜出る文書 の`処理待ち~fullscreen~event群$に
( `fullscreenchange$et, %抜出る文書 の`~fullscreen要素$ )
を`付加する$set
◎
Append (fullscreenchange, exitDoc’s fullscreen element) to exitDoc’s list of pending fullscreen events.
</li>
					<li>
~IF［
%~resizeか ~EQ ~T
］
⇒
`文書を~unfullscreenする$( %抜出る文書 )
◎
If resize is true, unfullscreen exitDoc.
</li>
					<li>
~ELSE
⇒
`要素を~unfullscreenする$( %抜出る文書 の`~fullscreen要素$ )
◎
Otherwise, unfullscreen exitDoc’s fullscreen element.
</li>
				</ol>
			</li>
			<li>
<p>
%子孫~文書~群 を成す
~EACH( %子孫~文書 )
に対し：
◎
For each descendantDoc in descendantDocs:
</p>
				<ol>
					<li>
%子孫~文書 の`処理待ち~fullscreen~event群$に
( `fullscreenchange$et, %子孫~文書 の`~fullscreen要素$ )
を`付加する$set
◎
Append (fullscreenchange, descendantDoc’s fullscreen element) to descendantDoc’s list of pending fullscreen events.
</li>
					<li>
`文書を~unfullscreenする$( %子孫~文書 )
◎
Unfullscreen descendantDoc.
</li>
				</ol>

<p class="note">注記：
文書たちが~unfullscreenされる順序は、
観測され得ない
— `~fullscreen化~手続き$は、
`~tree順序$で呼出されるので。
【なぜ観測され得ない？】
◎
The order in which documents are unfullscreened is not observable, because run the fullscreen steps is invoked in tree order.
</p>
			</li>
			<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<div class="algo">
`exitFullscreen()@m
~method~手続きは
⇒
~RET `~fullscreenから抜出る$( コレ )
◎
The exitFullscreen() method steps are to return the result of running exit fullscreen on this.
</div>

<hr>

<p>
以下に挙げる各種`~event~handler$（および，対応する`~event~handler~event型$）は、［
`Element$I ／ `Document$I
］~objにより，`~event~handler~IDL属性$として~supportされるモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported by Element and Document objects as event handler IDL attributes:
</p>

<table><thead>
<tr><th>`~event~handler$
<th>`~event~handler~event型$
<tbody>

<tr><td>`onfullscreenchange@m
<td>`fullscreenchange@et

<tr><td>`onfullscreenerror@m
<td>`fullscreenerror@et
</table>

<p class="note">注記：
これらは、［
`ShadowRoot$I ／ `Window$I
］~objからは~supportされない。
また、
`Element$I ~obj用の対応する`~event~handler内容~属性$も無い
— 名前空間を問わず。
◎
These are not supported by ShadowRoot or Window objects, and there are no corresponding event handler content attributes for Element objects in any namespace.
</p>

	</section>
	<section id="ui">
<h2 title="UI">4. ~UI</h2>

<p>
~UAには、［
`requestFullscreen()$m,
`exitFullscreen()$m
］の手続きを通して，~native媒体の~fullscreen制御を実装することが奨励される。
◎
User agents are encouraged to implement native media fullscreen controls in terms of requestFullscreen() and exitFullscreen().
</p>

<p>
末端利用者は、［
`requestFullscreen()$m を介して起動された ~fullscreen~sessionを終止する
］よう，~UAに指図している場合
⇒
`~fullscreenから全部的に抜出る$( `~top-level辿可能$にて`作動中な文書$nav )
◎
If the end user instructs the user agent to end a fullscreen session initiated via requestFullscreen(), fully exit fullscreen given the top-level traversable’s active document.
</p>

<p>
~UAは、［
末端利用者からの指図 ／
`exitFullscreen()$m の~call
］が無いときでも，必要yであると判断するならば ~fullscreen~sessionを終止してもヨイ。
◎
The user agent may end any fullscreen session without instruction from the end user or call to exitFullscreen() whenever the user agent deems it necessary.
</p>

	</section>
	<section id="rendering">
<h2 title="Rendering">5. 描画</h2>

<p>
この節は、
`HTML$r `§ 具現化＠~HTMLrendering#rendering$と等価に解釈されることになる。

◎
This section is to be interpreted equivalently to the Rendering section of HTML. [HTML]
</p>

		<section id=":fullscreen-pseudo-class">
<h3 title=":fullscreen pseudo-class">5.1. `fullscreen^ps 疑似類</h3>

<p>
`fullscreen@ps
`疑似類$は、
~OR↓ を満たすどの`要素$ %要素 にも合致するモノトスル：
◎
The :fullscreen pseudo-class must match any element element for which one of the following conditions is true:
</p>
<ul>
	<li>
%要素 の`~fullscreenか$ ~EQ ~T
◎
element’s fullscreen flag is set.
</li>
	<li>
［
%要素 は`~shadow~host$である
］~AND［［［
%要素 の`~node文書$の`~fullscreen要素$
］を %要素 に向けて`~targetし直す$
］~EQ %要素
］
◎
element is a shadow host and the result of retargeting its node document’s fullscreen element against element is element.
</li>
</ul>

<p class="note">注記：
これは、
最上層な`~fullscreen要素$を返す
`fullscreenElement$m ~APIとは異なる。
◎
This makes it different from the fullscreenElement API, which returns the topmost fullscreen element.
</p>

		</section>
		<section id="user-agent-level-style-sheet-defaults">
<h3 title="User-agent level style sheet defaults">5.2. ~UA~levelの既定の~stylesheet</h3>

<pre class="lang-css">
@namespace "http://www.w3.org/1999/xhtml";

*|*:not(:root):fullscreen {
  position:fixed !important;
  inset:0 !important;
  margin:0 !important;
  box-sizing:border-box !important;
  min-width:0 !important;
  max-width:none !important;
  min-height:0 !important;
  max-height:none !important;
  width:100% !important;
  height:100% !important;
  transform:none !important;

  /* intentionally not !important */
  object-fit:contain;
}

iframe:fullscreen {
  border:none !important;
  padding:0 !important;
}

*|*:not(:root):fullscreen::backdrop {
  background:black;
}
</pre>

		</section>
	</section>
	<section id="feature-policy-integration">
<h2 title="Permissions Policy Integration">6. 許可~施策の統合</h2>

<p>
この仕様は、
文字列
`fullscreen@l
で識別される`施策により制御される特能$を定義する。
その`既定の許容list$は、
`'self'^l とする。
◎
This specification defines a policy-controlled feature identified by the string "fullscreen". Its default allowlist is 'self'.
</p>

<div class="note">
<p>注記：
`文書$の`許可~施策$docは、
その文書~内の内容は，~fullscreenにすることが許容されるかを決定する。
文書~内で不能化された場合、
文書~内のどの内容にも，~fullscreen`特能の利用は許容され$ない。
◎
A document’s permissions policy determines whether any content in that document is allowed to go fullscreen. If disabled in any document, no content in the document will be allowed to use fullscreen.
</p>

<p>
~HTML `iframe$e 要素の `allowfullscreen$a 属性は、
`allow$a 属性により上書きされない限り，それが入子にしている文書の`容器~施策$に影響する。
~iframe上に `allowfullscreen$a を設定することは，
`&lt;iframe allow="fullscreen *"&gt;^c
と等価になる
— `PERMISSIONS-POLICY-1$r の
<a href="~PERMISSIONS-POLICY#iframe-allowfullscreen-attribute">§ `allowfullscreen^a</a>
に述べられるとおり。
◎
The allowfullscreen attribute of the HTML iframe element affects the container policy for any document nested in that iframe. Unless overridden by the allow attribute, setting allowfullscreen on an iframe is equivalent to &lt;iframe allow="fullscreen *"&gt;, as described in Permissions Policy § 6.3.1 allowfullscreen.
</p>
</div>

	</section>
	<section id="security-and-privacy-considerations">
<h2 title="Security and Privacy Considerations">7. ~security／~privacyの考慮点</h2>

<p>
~UAは、
重層するなどの手段により，末端利用者が［
何かが~fullscreenで表示されていること
］に気付けることを確保するべきである。
~UAは、［
~fullscreenから抜出るための，常に働く手段
］を供して，利用者に告知するべきである。
これは、
ある~siteが［
~fullscreenにある間、
~UAや~OS環境までも~~模造して，末端利用者を欺く
］ことを防止する。
`requestFullscreen()$m の定義も見よ。
◎
User agents should ensure, e.g. by means of an overlay, that the end user is aware something is displayed fullscreen. User agents should provide a means of exiting fullscreen that always works and advertise this to the user. This is to prevent a site from spoofing the end user by recreating the user agent or even operating system environment when fullscreen. See also the definition of requestFullscreen().
</p>

<p>
`子~navigable$内の内容が~fullscreenになるのを可能化するためには、
許可~施策を介して特定的に許容される必要がある
— 次のいずれかを通して
⇒＃
~HTML `iframe$e 要素の `allowfullscreen$a 属性 ／
~HTML `iframe$e 要素の `allow$a  属性における適切な宣言 ／
内容を入子にしている`文書$と伴に `Permissions-Policy$h ~HTTP~headerを送達する
◎
To enable content in a child navigable to go fullscreen, it needs to be specifically allowed via permissions policy, either through the allowfullscreen attribute of the HTML iframe element, or an appropriate declaration in the allow attribute of the HTML iframe element, or through a `Permissions-Policy` HTTP header delivered with the document through which it is nested.
</p>

<p>
これは例えば、［
第三者-主体からの内容が，明示的な許可なく~fullscreenになる
］のを防止する。
◎
This prevents e.g. content from third parties to go fullscreen without explicit permission.
</p>

	</section>
	<section id="old-links">
<h2 title="Previously-hosted definitions">以前に~hostしていた定義</h2>

<p>
この仕様は、
以前に［
`backdrop$pe,
文書の`上端~層$の概念
］の定義を~hostしていた。
◎
This specification previously hosted the definitions of ::backdrop and the concept of the document’s top layer.
</p>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main></div>

<div hidden>
<div lang="en" id="_acks1">

<p>
Many thanks to Robert O’Callahan for designing the initial model and being awesome.
</p>
<p>
Thanks to
Andy Earnshaw,
Changwan Hong,
Chris Pearce,
Darin Fisher,
Dave Tapuska,
<i>fantasai</i>,
Giuseppe Pascale,
Glenn Maynard,
Ian Clelland,
Ian Hickson,
Ignacio Solla,
João Eiras,
Josh Soref,
Kagami Sascha Rosylight,
Matt Falkenhagen,
Mihai Balan,
Mounir Lamouri,
Øyvind Stenhaug,
Pat Ladd,
Rafał Chłodnicki,
Riff Jiang,
Rune Lillesveen,
Sigbjørn Vik,
Simon Pieters,
Tab Atkins-Bittner,
Takayoshi Kochi,
Theresa O’Connor,
triple-underscore,
Vincent Scheib, and
Xidorn Quan
for also being awesome.
</p>

<p lang="en">
This standard is edited by <a href="https://foolip.org/" lang="sv">Philip Jägenstedt</a> (<a href="https://google.com/">Google</a>, <a href="mailto:philip@foolip.org">philip@foolip.org</a>). It was originally written by <a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a> (<a href="https://www.apple.com/">Apple</a>, <a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>). <a href="http://tantek.com/" lang="tr">Tantek Çelik</a> (<a class="p-org org h-org h-card" href="https://www.mozilla.org/">Mozilla</a>, <a href="mailto:tantek@cs.stanford.edu">tantek@cs.stanford.edu</a>) sorted out legal hassles.

</div>

<div lang="en" id="_ipr1">
<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://fullscreen.spec.whatwg.org/review-drafts/2024-07/">Living Standard Review Draft</a>.
</p>
</div>

</div>

