<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Fullscreen API （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<style>

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	Util.switchWordsInit({
		collectParts: Util.collectParts,
		toc_main: 'MAIN0',
		generate: expand
	});

//	Util.del_j(); // checked 171220 spec
}

function expand(){

	var class_map = {
		E: 'error',
		A: 'abstract',
		jv: 'js-value',
		p: 'property',
		css: 'css',
		ps: 'pseudo',
		pe: 'pseudo',
		e: 'element',
		a: 'attr',
		v: 'value',
		et: 'event-type',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		mE: 'code',
		E: 'code',
		p: 'code',
		css: 'code',
		ps: 'code',
		pe: 'code',
		et: 'code',
		e: 'code',
		a: 'code',
		v: 'code',
		c: 'code',
		jv: 'span',
		A: 'span',
		i: 'i',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return '<var>' + match.slice(1) + '</var>'
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
case 'mE':
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'pe': 
	text = '::' + key;
	break;
case 'ps': 
	text = ':' + key;
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2018-05-29
trans_update:2018-01-07
spec_status:LS
original_url:https://fullscreen.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:uievents
copyright:2018,whatwg
trans_1st_pub:2017-12-24

●●link_map


	●IDL

LenientSetter:~WEBIDL#LenientSetter
Unscopable:~WEBIDL#Unscopable

I.Document:~DOM4#document
I.EventHandler:~WAPI#eventhandler
I.DocumentOrShadowRoot:~DOM4#documentorshadowroot
I.Element:~DOM4#element
I.ShadowRoot:~DOM4#shadowroot
I.Window:~WINDOW#window

boolean:~WEBIDL#idl-boolean
m.bubbles:~DOM4#dom-event-bubbles
m.composed:~DOM4#dom-event-composed

m.exitFullscreen:#dom-document-exitfullscreen
m.fullscreen:#dom-document-fullscreen
m.fullscreenElement:#dom-document-fullscreenelement
m.fullscreenEnabled:#dom-document-fullscreenenabled
m.onfullscreenchange:#handler-document-onfullscreenchange
m.onfullscreenerror:#handler-document-onfullscreenerror
mE.onfullscreenchange:#dom-element-onfullscreenchange
mE.onfullscreenerror:#dom-element-onfullscreenerror
mE.requestFullscreen:#dom-element-requestfullscreen

e.dialog:~HEinteractive#the-dialog-element
e.iframe:~HEembed#the-iframe-element
e.svg:~SVG11/struct.html#SVGElement
e.math:https://www.w3.org/Math/draft-spec/chapter2.html#interf.toplevel


ps.fullscreen:#css-pc-fullscreen
pe.backdrop:#css-pe-backdrop

	●用語
上端~層:#top-layer
追加する:#top-layer-add
子孫~閲覧文脈:#descendant-browsing-context

~fullscreenは~supportされて:#fullscreen-is-supported
~fullscreen要請は許容されて:#allowed-to-request-fullscreen
~fullscreenから抜出る:#exit-fullscreen
~fullscreen要素~準備済み検査:#fullscreen-element-ready-check
~fullscreen要素:#fullscreen-element
~fullscreen~flag:#fullscreen-flag
要素を~fullscreen化する:#fullscreen-an-element
~fullscreenから全部的に抜出る:#fully-exit-fullscreen
~iframe~fullscreen~flag:#iframe-fullscreen-flag
処理待ち~fullscreen~eventの~list:#list-of-pending-fullscreen-events
~fullscreen化~手続き:#run-the-fullscreen-steps
単純~fullscreen文書:#simple-fullscreen-document

~unfullscreenする文書を収集する:#collect-documents-to-unfullscreen
要素を~unfullscreenする:#unfullscreen-an-element
文書を~unfullscreenする:#unfullscreen-a-document

	●外部

~HTML名前空間:~INFRA#html-namespace
空:~INFRA#list-empty
空にする:~INFRA#list-empty
set.付加する:~INFRA#set-append
~pair:~INFRA#pair
除去する:~INFRA#list-remove
文字列:~INFRA#string
有順序~集合:~INFRA#ordered-set
	~EACH:~INFRA#list-iterate
	~WHILE:~INFRA#iteration-while
	~BREAK:~INFRA#iteration-break
	~CONTINUE:~INFRA#iteration-continue


先祖:~DOM4#concept-tree-ancestor
~eventを発火する:~DOM4#concept-event-fire
接続されて:~DOM4#connected
文脈~obj:~DOM4#context-object
文書:~DOM4#concept-document
要素:~DOM4#concept-element
~host:~DOM4#concept-documentfragment-host
el.名前空間:~DOM4#concept-element-namespace
~node文書:~DOM4#concept-node-document
除去-時の手続き:~DOM4#concept-node-remove-ext
~targetし直す:~DOM4#retarget
根:~DOM4#concept-tree-root
~shadow~host:~DOM4#element-shadow-host
~shadow根:~DOM4#concept-shadow-root
~shadowも含む広義-先祖:~DOM4#concept-shadow-including-inclusive-ancestor
~shadowも含む広義-子孫:~DOM4#concept-shadow-including-inclusive-descendant
~shadowも含む木~順序:~DOM4#concept-shadow-including-tree-order
木~順序:~DOM4#concept-tree-order
木:~DOM4#concept-tree

並列的:~HTMLINFRA#in-parallel

作動中の文書:~BROWSERS#active-document
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
閲覧文脈~容器:~BROWSERS#browsing-context-container
閲覧文脈:~BROWSERS#browsing-context
全部的に作動中:~BROWSERS#fully-active
入子の閲覧文脈:~BROWSERS#nested-browsing-context
入子にしている閲覧文脈~容器:#_nesting-bc-container
通して入子にされて:~BROWSERS#browsing-context-nested-through
属する閲覧文脈:~BROWSERS#concept-document-bc
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context

~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler内容~属性:~WAPI#event-handler-content-attributes
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler:~WAPI#event-handlers
~event-loop:~WAPI#event-loop

特色機能の利用は許容されて:~HEembed#allowed-to-use

利用者が生成した方位~変更により誘発されて:https://w3c.github.io/screen-orientation/#dfn-triggered-by-a-user-generated-orientation-change
利用者の作動化により誘発されて:~HTMLinteraction#triggered-by-user-activation
文書~unload時の片付け手続き:~NAVI#unloading-document-cleanup-steps

	●補完
新たな~promise:~PROMISES#a-new-promise
却下する:~PROMISES#reject-promise
解決する:~PROMISES#resolve-promise

p.z-index:~CSS2VISUREN#propdef-z-index
p.position:~CSS2VISUREN#propdef-position
	p.position:~CSSPOS#propdef-position
p.top:~CSS2VISUREN#propdef-top
p.right:~CSS2VISUREN#propdef-right
p.left:~CSS2VISUREN#propdef-left
p.display:~CSSDISP#propdef-display
p.outline:~CSSUI#outline
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.opacity:~CSSCOLOR#propdef-opacity
p.mask:~MASKING#propdef-mask

積層~文脈:~CSS2VISUREN#stacking-context
静的~位置:~CSS2VISUDET#static-position
指定値:~CASCADE#specified-value
算出値:~CASCADE#computed-value
包含塊:~CSSDISP#containing-block
初期~包含塊:~CSSDISP#initial-containing-block
表示域:~CSS2VISUREN#viewport
疑似要素:~SELECTORS4#pseudo-element
疑似類:~SELECTORS4#pseudo-class
出自の要素:~SELECTORS4#originating-element

●●words_table1
MASKING:https://drafts.fxtf.org/css-masking-1/


●●words_table

	●DOM
DOM:
event-loop:event loop:::イベントループ
event::::イベント
handler::::ハンドラ
発火-:fire::~
host::::ホスト
shadow:
node::::ノード
要素:element::~
根:root::~::ルート
広義-:inclusive:~
子孫:descendant::~
先祖:ancestor::~
親:parent::~
子:child::~
属性:attribute::~
文書:document::~
接続-:connect::~
名前空間:namespace::~
内容:content::~
木:tree::~::ツリー

	●CSS
CSS:
resize::::リサイズ
prop:property:::プロパティ
stylesheet:style sheet:::スタイルシート
style::::スタイル
layout::::レイアウト
box::::ボックス
overflow::::過フロー
容器:container:::コンテナ
媒体:media::~::メディア
疑似要素:pseudo-element::~
疑似類:pseudo-class::疑似 class:疑似クラス
表示域:viewport::~::ビューポート
積層:stacking::~
層:layer::~
重層する:overlay する::層を重ねる
最上端:topmost::~
上端:top::~
静的:static::~
包含塊:containing block::包含 block:包含ブロック
後景:backdrop::~
位置:position::~
寸法:dimension::~
文脈:context::~
指定値:specified value:specified 値:~
算出値:computed value:computed 値:~
算出-:compute::~
継承-:inherit::~
表示-:display::~
出自の:originating::~

	●仕様
API:
UA:
UI:
Web:
support::::サポート
risk::::リスク
platform::::プラットフォーム
privacy::::プライバシー
security::::セキュリティ
model::::モデル
native::::ネイティブ
OS:operating system:OS
algo:algorithm:::アルゴリズム

事例:case:~
仕様:spec:~
	付録:Appendix:~
	例えば:for example
効果:effect:~
単純:simple:~
各種用語:terminology:~
	必要:need
	必要と〜され:necessary
手段:means:~
明示的:explicit:~
条件:condition:~
概念:concept:~
標準:standard:~
正確:exact:~
特徴:characteristic:~
特色機能:feature:~
用語:term:~
能:ability:~
通常の:normal:~
第三者主体:third party::~
末端利用者:end user:~
特定的:specifical:~
歴史的:historical:~
手続き:steps:~
段:step:~
	気付けるaware
	ゆくゆくは:Long term
	言い換えれば:in other words
	大雑把な~~素描に過ぎない:sketchy as hell
	任意選択で:optionally

	●仕様（動詞

依存-:depend:~
働く:work する:~
制約:restriction:~
制限:limitation:~
奨励-:encourage:~
言明-:state:~
	他が言明されない限り:unless stated otherwise
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
導入-:introduce:~
影響-:affect:~
指示-:indicate:~
供-:provide:~
改善案:potential improvements:~
	歓迎-:welcome:~
確保-:ensure:~
確立-:establish:~
統合-:integrate:~
考慮点:considerations:~
	見よ:see:~
解釈-:interpret:~
記述:description:~
許容-:allow:~
適用-:apply:~
選好:preference:~
防止-:prevent:~
利用者:user:~
末端利用者:end user:~
指図-:instruct:~
指図:instruction:~
判断-:deem:~
継当て:patching:継ぎ当て
	呼ばれ:called
試みる:attempt する:~
告知-:advertise:~
	読者への演習に残しておく:left as an exercise to the reader
	加えて:in addition to
	~~模造:recreate
	欺く:spoof する
	詳説:Elaborate description
	という:said to be

	●未分類（動詞
screen::::スクリーン
fullscreen::::全スクリーン
fullscreen-::::全スクリーン化
unfullscreen::非 fullscreen 化::非全スクリーン化
開いて:open して::~
target::::
	~targetし直す:retarget
unload:
observer::::オブザーバ
promise::::
call:
上書き:override:~
作動中の:active な::~::アクティブな
作動中:active::~::アクティブ
作動化:activation:::~::アクティブ化
作成-:create:~
入子の:nested::入れ子の
入子に:nest::入れ子に
描画-:render::~
描画:rendering::~
具現化:rendering::~
処理待ち:pending:~
出力-:output:~
初期:initial:~
	初期~時には:initially
初期化-:initialize:~
利用-:use:~
制御:control:~
却下-:reject::~
解決-:resolve::~
取得子:getter:~
可能化-:enable:~
合致-:match:~
呼出され:invoke され:呼び出され
被呼出時:被 invoke 時:~
変化-:change:~
変更:change:~
方位:orientation::~
生成-:generate:~
移動-:move:~
空:empty::~
等価:equivalent:~
結付けら:associate さ:結び付けら
許可:permission::~
起動-:initiate::~
追加-:add::~
付加-:append::~
通知-:notify::~
除去-:remove::~
隠す:hide する:~
集合:set::~
順序:order::~
有順序:ordered::~
抜出る:exit する::抜け出る
片付け:cleanup::~
走らす:run する:~
走らせ:run し:~
停止-:stop::~
復帰-:revert::~
設定-:set::~
観測-:observe::~
	観測され得ない:not observable
塗り:painting::~
塗る:paint する::~
塗られ:paint され::~
誘発-:trigger::~
要請:request::~::リクエスト
準備済み:ready::~
検査:check::~
収集-:collect::~
終止-:end:~
	末尾:end
	在る:present:~
	対応:correspond
	現れ:appear:~
	返す:return:~
	になる:go
	~CSS22
	https://www.w3.org/TR/CSS2/zindex.html
	~OFF:unset
	:against
	-:go
	retargeting
	~unload時の:unloading

	●未分類
HTML:
IDL:
iframe:
error::::エラー
flag::::フラグ
level::::レベル
list::::リスト
message::::メッセージ
method::::メソッド
obj:object:::オブジェクト
pair::::ペア
session::::セッション
site::::サイト
top-level::::トップレベル


文字列:string::~
不可分:atomic::~
並列的:parallel::~
例外:exception::~
候補:candidate:~
	~~案:input:~
単位:unit:~
	直下:immediately below:~
同胞:sibling::~
名:name:~
名前:name:~
型:type:~
既定の:default:~
機器:device:~
環境:environment:~
process::::プロセス
	~process外の:out-of-process
閲覧文脈:browsing context::~


	●指示語
全部的:full:~
新たな:new:~
下層の:underlying:~

	〜の代わりに:instead
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	それらの:their
	べき:should
	上:above
	下:below
	介:via
	他の場合:otherwise
	何か:something
	依然として:still
	別の:another
	前:before
	各:each
	同じ:same
	常に:always
	後:after
	以下の:following
	所与の:given
	最初の:first
	最後の:last
	等々:etc
	複数の:multiple
	異なる:different
	ほとんど:most
	それまでにpreviously
	以降の:remaining
	であり続けるremain
	0:zero
	個:one／:two
	したがって:therefore
	したがって:thus
	下位節:subsection
	節:section:
	結果:result
	済んだ時点で:when done
	一部を成す:part of
	comes after
	最も手前:closest

	●変数名
	文書:doc
	~fullscreen要素たち:fullscreenElements
	除去された~node:removedNode
	~top-level文書:topLevelDoc
	文書:lastDoc
	抜出る文書たち:exitDocs
	抜出る文書:exitDoc
	子孫~文書たち:descendantDocs
	子孫~文書:descendantDoc
	処理待ち文書:pendingDoc


●●ref_normative

[CSS]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/
[MATHML]
    Patrick D F Ion; Robert R Miner. Mathematical Markup Language (MathML) 1.01 Specification. 7 July 1999. REC. URL: https://www.w3.org/TR/REC-MathML/
[SVG]
    Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://fullscreen.spec.whatwg.org/">Fullscreen API</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/fullscreen">GitHub whatwg/fullscreen</a> (<a href="https://github.com/whatwg/fullscreen/issues/new">new issue</a>, <a href="https://github.com/whatwg/fullscreen/issues">open issues</a>)</dd>
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a></dd>

Commits:
	<a href="https://github.com/whatwg/fullscreen/commits">GitHub whatwg/fullscreen/commits</a>
	<a href="https://fullscreen.spec.whatwg.org/commit-snapshots/6e49fbc41451caf3fb6f7d53c5428990902034bc/" id="commit-snapshot-link">Snapshot as of this commit</a></dd>
	<a href="https://twitter.com/fullscreenapi">@fullscreenapi</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/fullscreen">web-platform-tests fullscreen/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/fullscreen">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>


</head>

<body>

<header>

<a href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPHBhdGggZD0ibTUsNDB2LTM1aDM1bTIwLDBoMzV2MzVtMCwyMHYzNWgtMzVtLTIwLDBoLTM1di0zNSIgc3Ryb2tlLXdpZHRoPSIxMCIgc3Ryb2tlPSIjM2M3OTBhIiBmaWxsPSIjZmZmIi8+CjxwYXRoIGQ9Im0zOCwzOGMwLTEyLDI0LTE1LDIzLTJjMCw5LTE2LDEzLTE2LDIzdjdoMTB2LTRjMC05LDE3LTEyLDE3LTI3Yy0yLTIyLTQ1LTIyLTQ1LDN6bTcsMzJoMTB2MTBoLTEwIiBmaWxsPSIjM2M3OTBhIi8+Cjwvc3ZnPgo="
></a>

	<hgroup>
<h1 id="title">Fullscreen API</h1>
	</hgroup>
</header>

<div id="MAIN" style="display:none;">


	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
Fullscreen ~API 標準は、自身を~fullscreenに表示する要素~用の~APIを定義する。
◎
The Fullscreen API standard defines an API for elements to display themselves fullscreen.
</p>

	</section>

<main id="MAIN0">

	<section id="terminology">
<h2 title="Terminology">1. 各種用語</h2>

<p>
この仕様は、 `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様に利用される各種用語のほとんどは、
`CSS$r, `DOM$r, `HTML$r, `WEBIDL$r
による。
◎
Most terminology used in this specification is from CSS, DOM, HTML, and Web IDL. [CSS] [DOM] [HTML] [WEBIDL]
◎
A browsing context A is called a descendant browsing context of a browsing context B if and only if B is an ancestor browsing context of A.
この訳では、この用語は利用しない。
</p>

		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoの記述に利用されている各種記号（此れ, ~LET, ~ON, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
加えて、明確化するため，次の定義も導入する：
</p>

<p>
`文書$ %文書 を
`入子にしている閲覧文脈~容器@
は、次の手続きの結果で与えられる：
</p>

<ol>
	<li>
%B ~LET %文書 が`属する閲覧文脈$
</li>
	<li>
~IF［
%B ~NEQ ε
］~AND［
ある`閲覧文脈~容器$ %容器 があって， %B は %容器 を`通して入子にされて$いる
］
⇒
~RET  %容器
</li>
	<li>
~RET ε
</li>
</ol>

		</section>
	</section>
	<section id="model">
<h2 title="Model">2. ~model</h2>


<p>
各 `要素$には
`~fullscreen~flag@
が結付けられる。
他が言明されない限り ~OFF とする。
◎
All elements have an associated fullscreen flag. Unless stated otherwise it is unset.
</p>


<p>
各 `iframe$e `要素$には
`~iframe~fullscreen~flag@
が結付けられる。
他が言明されない限り ~OFF とする。
◎
All iframe elements have an associated iframe fullscreen flag. Unless stated otherwise it is unset.
</p>


<p>
`文書$の
`~fullscreen要素@
は、`文書$の`上端~層$内の`要素$のうち［
`~fullscreen~flag$ ~EQ ~ON
］なるものが［
あれば それらのうち最上端【最も手前に塗られる／最後】のもの／
他の場合は ~NULL
］とする。
◎
All documents have an associated fullscreen element. The fullscreen element is the topmost element in the document’s top layer whose fullscreen flag is set, if any, and null otherwise.
</p>

<p>
各 `文書$には
`処理待ち~fullscreen~eventの~list@
が結付けられる。
それは、 0 個~以上の［
( `文字列$, `要素$ ) が成す`~pair$
］かならる`有順序~集合$であり，初期~時には空とする。
◎
All documents have an associated list of pending fullscreen events, which is an ordered set of (string, element) pairs. It is initially empty.
</p>

<p class="algo-head">
`要素を~fullscreen化する@
ときは、所与の
( %要素 )
に対し
⇒＃
%要素 の`~fullscreen~flag$ ~SET ~ON；
%要素 の`~node文書$の`上端~層$に %要素 を`追加する$
◎
To fullscreen an element, set element’s fullscreen flag and add it to its node document’s top layer.
</p>

<div >
<p class="algo-head">
`要素を~unfullscreenする@
ときは、所与の
( %要素 )
に対し：
</p>
<ol>
	<li>
%要素 の`~fullscreen~flag$ ~SET ~OFF
</li>
	<li>
~IF［
%要素 は `iframe$e 要素である
］
⇒
%要素 の`~iframe~fullscreen~flag$ ~SET ~OFF
</li>
	<li>
%要素 の`~node文書$の`上端~層$から %要素 を`除去する$
</li>
</ol>
◎
To unfullscreen an element, unset element’s fullscreen flag and iframe fullscreen flag (if any), and remove it from its node document’s top layer.
</div>


<p class="algo-head">
`文書を~unfullscreenする@
ときは、所与の
( %文書 )
に対し
⇒
%文書 の`上端~層$を成す ~EACH( `要素$ %要素 ) に対し
⇒
~IF［
%要素 の`~fullscreen~flag$ ~EQ ~ON
］
⇒
`要素を~unfullscreenする$( %要素 )
◎
To unfullscreen a document, unfullscreen all elements, within document’s top layer, whose fullscreen flag is set.
</p>

<hr>

<p class="algo-head">
`~fullscreenから全部的に抜出る@
ときは、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
To fully exit fullscreen a document document, run these steps:
</p>

<ol>
	<li>
~IF［
%文書 の`~fullscreen要素$ ~EQ ~NULL
］
⇒
~RET
◎
If document’s fullscreen element is null, terminate these steps.
</li>
	<li>
%文書 の`上端~層$内の~EACH( %要素 ) に対し
⇒
~IF［
%要素 の`~fullscreen~flag$ ~EQ ~ON
］~AND［
%要素 ~NEQ %文書 の`~fullscreen要素$
］
⇒
`要素を~unfullscreenする$( %要素 )
◎
Unfullscreen elements whose fullscreen flag is set, within document’s top layer, except for document’s fullscreen element.
</li>
	<li>
`~fullscreenから抜出る$( %文書 )
◎
Exit fullscreen document.
</li>
</ol>

<p class="algo-head" id="removing-steps">
`除去-時の手続き$は、所与の
( %除去された~node )
に対し，次を走らす：
◎
Whenever the removing steps run with a removedNode, run these steps:
</p>

<ol>
	<li>
<p>
%除去された~node の~EACH( `~shadowも含む広義-子孫$ %~node ) に対し，`~shadowも含む木~順序$で：
◎
Let nodes be removedNode’s shadow-including inclusive descendants that have their fullscreen flag set, in shadow-including tree order.
◎
For each node in nodes:
</p>
		<ol>
			<li>
~IF［
%~node の`~fullscreen~flag$ ~EQ ~OFF
］
⇒
~CONTINUE
◎
↑</li>
			<li>
%~node文書 ~LET %~node の`~node文書$
◎
↓</li>
			<li>
~IF［
%~node ~EQ %~node文書 の`~fullscreen要素$
］
⇒
`~fullscreenから抜出る$( %~node文書 )
◎
If node is its node document’s fullscreen element, exit fullscreen that document.
</li>
			<li>
~ELSE
⇒
`要素を~unfullscreenする$( %~node )
◎
Otherwise, unfullscreen node within its node document.
</li>
		</ol>
	</li>
</ol>

<p>
`文書~unload時の片付け手続き$は、所与の
( %文書 )
に対し，走らす
⇒
`~fullscreenから全部的に抜出る$( %文書 )
◎
Whenever the unloading document cleanup steps run with a document, fully exit fullscreen document.
</p>

<hr>

<p>
`~fullscreenは~supportされて@
いるとは、それまでに確立されている
【すなわち、所与の時点で，~fullscreen化を防止するような】
［
利用者~選好, ~security~risk, ~platform制限
］は無いことを意味する。
◎
Fullscreen is supported if there is no previously-established user preference, security risk, or platform limitation.
</p>

<p>
~algo %A に
`~fullscreen要請は許容されて@
いるとは、
%A は次のいずれかを満たすことを意味する：
◎
An algorithm is allowed to request fullscreen if one of the following is true:
</p>

<ul>
	<li>
`利用者の作動化により誘発されて$いる。
◎
The algorithm is triggered by user activation.
</li>
	<li>
`利用者が生成した方位~変更により誘発されて$いる。
◎
The algorithm is triggered by a user generated orientation change.
</li>
</ul>

<hr>

<p>
`~fullscreen化~手続き@
は、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
To run the fullscreen steps for a document document, run these steps:
</p>

<ol>
	<li>
%~pair~list ~LET %文書 の`処理待ち~fullscreen~eventの~list$【の複製】<!-- ＊ -->
◎
Let pairs be document’s list of pending fullscreen events.
</li>
	<li>
%文書 の`処理待ち~fullscreen~eventの~list$を`空にする$
◎
Empty document’s list of pending fullscreen events.
</li>
	<li>
<p>
%~pair~list 内の ~EACH( ( %型, %要素 ) ) に対し：
◎
For each (type, element) in pairs:
</p>
		<ol>
			<li>
%~target ~LET ［
次が満たされるならば %要素 ／
~ELSE_ %文書
］
⇒
［
%要素 は`接続されて$いる
］~AND［
%要素 の`~node文書$ ~EQ %文書
］
◎
Let target be element if element is connected and its node document is document, and otherwise let target be document.
</li>
			<li>
%~target に向けて，名前 %型 の`~eventを発火する$
— 次のように初期化して
⇒＃
`bubbles$m 属性 ~SET ~T,
`composed$m 属性 ~SET ~T
◎
Fire an event named type, with its bubbles and composed attributes set to true, at target.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
この手続きは、 `HTML$r にて定義される`~event-loop$に統合されている。
【<a href="~WAPI#update-the-rendering">参照</a>】
◎
These steps integrate with the event loop defined in HTML. [HTML]
</p>



	</section>
	<section id="api">
<h2 title="API">3. ~API</h2>


<pre class="idl">
partial interface `Element$I {
  Promise&lt;void&gt; `requestFullscreen$mE();

  attribute `EventHandler$I `onfullscreenchange@mE;
  attribute `EventHandler$I `onfullscreenerror@mE;
};

partial interface `Document$I {
  [`LenientSetter$] readonly attribute `boolean$ `fullscreenEnabled$m;
  [`LenientSetter$, `Unscopable$] readonly attribute `boolean$ `fullscreen$m; // <span class="comment">歴史的</span>

  Promise&lt;void&gt; `exitFullscreen$m();

  attribute `EventHandler$I `onfullscreenchange$m;
  attribute `EventHandler$I `onfullscreenerror$m;
};

partial interface `DocumentOrShadowRoot$I {
  [`LenientSetter$] readonly attribute `Element$I? `fullscreenElement$m;
};
</pre>

<dl class="domintro">
	<dt>%promise = %element . `requestFullscreen()$mE</dt>
	<dd>
%element を~fullscreenに表示する
— 済んだ時点で  %promise を解決する。
◎
Displays element fullscreen and resolves promise when done.
</dd>

	<dt>%document . `fullscreenEnabled$m</dt>
	<dd>
［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返す
⇒
［
%document は `要素$を~fullscreenに表示する能を備える
］~AND［
`~fullscreenは~supportされて$いる
］
◎
Returns true if document has the ability to display elements fullscreen and fullscreen is supported, or false otherwise.
</dd>

	<dt>%promise = %document . `exitFullscreen()$m</dt>
	<dd>
%document の`~fullscreen要素$の~fullscreen表示-を停止する
— 済んだ時点で %promise を解決する。
◎
Stops document’s fullscreen element from being displayed fullscreen and resolves promise when done.
</dd>

	<dt>%document . `fullscreenElement$m</dt>
	<dd>
%document の`~fullscreen要素$を返す。
◎
Returns document’s fullscreen element.
</dd>

	<dt>%shadowroot . `fullscreenElement$m</dt>
	<dd>
%shadowroot の`~fullscreen要素$を返す。
◎
Returns shadowroot’s fullscreen element.
</dd>
</dl>

<p class="algo-head">
`~fullscreen要素~準備済み検査@
は、所与の
( `要素$ %要素 )
に対し，［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返す
⇒
［
%要素 は`接続されて$いる
］~AND［
%要素 の`~node文書$には、属性~名 `allowfullscreen^l で指示される`特色機能の利用は許容されて$いる
］
◎
A fullscreen element ready check for an element element returns true if all of the following are true, and false otherwise:
• element is connected.
• element’s node document is allowed to use the feature indicated by attribute name allowfullscreen.
</p>

<dl class="idl-def">
	<dt>`requestFullscreen()@mE</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The requestFullscreen() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%処理待ち文書 ~LET 此れの`~node文書$
◎
Let pending be the context object.
◎
Let pendingDoc be pending’s node document.
</li>
			<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
			<li>
~IF［
%処理待ち文書 は`全部的に作動中$でない
］
⇒＃
`TypeError^E 例外で %~promise を`却下する$；
~RET %~promise
◎
If pendingDoc is not fully active, then reject promise with a TypeError exception and return promise.
</li>
			<li>
<p>
%~error ~LET ［
次のすべてが満たされるならば ~F ／
~ELSE_ ~T
］：
◎
Let error be false.
◎
If any of the following conditions are false, then set error to true:
</p>
				<ul>
					<li>
此れは次のいずれかを満たす
⇒＃
`名前空間$elは`~HTML名前空間$である<!-- ＊~HTML要素 --> ／
SVG `svg$e 要素である `SVG$r ／
MathML `math$e 要素である `MATHML$r
◎
pending’s namespace is the HTML namespace or pending is an SVG svg or MathML math element. [SVG] [MATHML]
</li>
					<li>
此れは `dialog$e 要素でない
◎
pending is not a dialog element.
</li>
					<li>
`~fullscreen要素~準備済み検査$( 此れ ) ~EQ ~T
◎
The fullscreen element ready check for pending returns true.
</li>
					<li>
`~fullscreenは~supportされて$いる
◎
Fullscreen is supported.
</li>
					<li>
この~algoには`~fullscreen要請は許容されて$いる
◎
This algorithm is allowed to request fullscreen.
</li>
				</ul>
			</li>
			<li>
~RET %~promise
— ただし，以降の手続きも`並列的$に走らす。
◎
Return promise, and run the remaining steps in parallel.
</li>
			<li>
~IF［
%~error ~EQ ~F
］
⇒
%処理待ち文書 の`~top-level閲覧文脈$にて`作動中の文書$の表示域の寸法を，出力-機器の~screenの寸法に合致するよう~resizeする
— 加えて，~UAの任意選択で
⇒
末端利用者が，これを復帰する方法を~~述べる~messageを表示する
◎
If error is false: Resize pendingDoc’s top-level browsing context’s active document’s viewport’s dimensions to match the dimensions of the screen of the output device. Optionally display a message how the end user can revert this.
</li>
			<li>
<p>
~IF［
%~error ~EQ ~T
］~OR［
次のいずれかが満たされない
］…：
◎
If any of the following conditions are false, then set error to true:
</p>

				<ul>
					<li>
此れの`~node文書$ ~EQ %処理待ち文書
◎
pending’s node document is pendingDoc.
</li>
					<li>
`~fullscreen要素~準備済み検査$( 此れ ) ~EQ ~T
◎
The fullscreen element ready check for pending returns true.
</li>
				</ul>

<p>
…ならば：
◎
If error is true:
</p>

				<ol>
					<li>
%処理待ち文書 の`処理待ち~fullscreen~eventの~list$に
( `fullscreenerror^et, 此れ )
を`付加する$set
◎
Append (fullscreenerror, pending) to pendingDoc’s list of pending fullscreen events.
</li>
					<li>
`TypeError^E 例外で %~promise を`却下する$
◎
Reject promise with a TypeError exception and＼
</li>
					<li>
~RET
◎
terminate these steps.
</li>
				</ol>
			</li>
			<li>
%~fullscreen要素たち ~LET 此れのみからなる`有順序~集合$
◎
Let fullscreenElements be an ordered set initially consisting of pending.
</li>
			<li>
~WHILE ［
%~fullscreen要素たち の最初の【最後の？】要素の`~node文書$を`入子にしている閲覧文脈~容器$ %容器 ~NEQ ε
］
⇒
%~fullscreen要素たち に %容器 を`付加する$set
◎
While the first element in fullscreenElements is in a nested browsing context: append its browsing context container to fullscreenElements.
</li>
			<li>
<p>
%~fullscreen要素たち 内の~EACH( %要素 ) に対し：
◎
For each element in fullscreenElements:
</p>

				<ol>
					<li>
%文書 ~LET %要素 の`~node文書$
◎
Let doc be element’s node document.
</li>
					<li>
<p>
~IF［
%要素 ~EQ %文書 の`~fullscreen要素$
］
⇒
~CONTINUE
◎
If element is doc’s fullscreen element, continue.
</p>

<p class="note">注記：
何も変化しない場合、~observerに通知する必要は無い。
◎
No need to notify observers when nothing has changed.
</p>
					</li>
					<li>
~IF［
%要素 ~EQ 此れ
］~AND［
此れは `iframe$e `要素$である
］
⇒
%要素 の`~iframe~fullscreen~flag$ ~SET ~ON
◎
If element is pending and pending is an iframe element, then set element’s iframe fullscreen flag.
</li>
					<li>
`要素を~fullscreen化する$( %要素 )
◎
Fullscreen element within doc.
</li>
					<li>
%文書 の`処理待ち~fullscreen~eventの~list$に
~pair( `fullscreenchange^et, %要素 )
を`付加する$set
◎
Append (fullscreenchange, element) to doc’s list of pending fullscreen events.
</li>
				</ol>

<p class="note">注記：
要素たちが~fullscreen化される順序は、観測され得ない
— `~fullscreen化~手続き$は、`木~順序$で呼出されるので。
【なぜ観測され得ない？】
◎
The order in which elements are fullscreened is not observable, because run the fullscreen steps is invoked in tree order.
</p>
			</li>
			<li>
`undefined^jv で %~promise を`解決する$
◎
Resolve promise with undefined.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
~process外の`閲覧文脈$【？】での実装は、読者【実装者】への演習に残しておく。
改善案があれば歓迎する。
◎
Implementations with out-of-process browsing contexts are left as an exercise to the reader. Input welcome on potential improvements.
</dd>

	<dt>`fullscreenEnabled@m</dt>
	<dd>
取得子は、［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返さ~MUST
⇒
［
此れには、属性~名 `allowfullscreen^l で指示される`特色機能の利用は許容されて$いる
］~AND［
`~fullscreenは~supportされて$いる
］
◎
The fullscreenEnabled attribute’s getter must return true if the context object is allowed to use the feature indicated by attribute name allowfullscreen and fullscreen is supported, and false otherwise.
</dd>

	<dt>`fullscreen@m</dt>
	<dd>
取得子は、［
此れの`~fullscreen要素$ ~NEQ ~NULL ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The fullscreen attribute’s getter must return false if context object’s fullscreen element is null, and true otherwise.
</dd>
	<dd class="note">注記：
作者は、代わりに `fullscreenElement$m 属性を利用するように。
◎
Use the fullscreenElement attribute instead.
</dd>

	<dt>`fullscreenElement@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The fullscreenElement attribute’s getter must run these steps:
</p>
		<ol>
			<li>
~IF［
此れは`~shadow根$である
］~AND［
此れの`~host$は`接続されて$いない
］
⇒
~RET ~NULL
◎
If the context object is a shadow root and its host is not connected, then return null.
</li>
			<li>
%候補 ~LET 此れの`~fullscreen要素$を此れに向けて`~targetし直す$
◎
Let candidate be the result of retargeting fullscreen element against the context object.
</li>
			<li>
~IF［
( %候補, 此れ )
は同じ`木$内にある
］
⇒
~RET %候補
◎
If candidate and the context object are in the same tree, then return candidate.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</dd>
</dl>

<p>
次を満たす`文書$ %文書 は
`単純~fullscreen文書@
という
⇒
［
%文書 の`上端~層$内の`要素$のうち［
`~fullscreen~flag$ ~EQ ~ON
］を満たすもの
］の個数 ~EQ 1
◎
A document is said to be a simple fullscreen document if there is exactly one element in its top layer that has its fullscreen flag set.
</p>

<p class="note">注記：
`上端~層$内に 2 個の `要素$がある`文書$でも，`単純~fullscreen文書$になり得る。
例えば、`~fullscreen要素$に加えて，開いている `dialog$e 要素がある場合。
◎
A document with two elements in its top layer can be a simple fullscreen document. For example, in addition to the fullscreen element there could be an open dialog element.
</p>

<p class="algo-head">
`~unfullscreenする文書を収集する@
ときは、所与の
( %文書 )
に対し，次を走らす：
◎
To collect documents to unfullscreen given doc, run these steps:
</p>

<ol>
	<li>
%文書たち ~LET 新たな`有順序~集合$
◎
Let docs be an ordered set consisting of doc.
</li>
	<li>
<p>
~WHILE 無条件
</p>
		<ol>
			<li>
~Assert：
%文書 の`~fullscreen要素$ ~NEQ ~NULL
</li>
			<li>
%文書たち に %文書 を`付加する$set
</li>
			<li>
~IF［
%文書 は`単純~fullscreen文書$でない
］
⇒
~BREAK
</li>
			<li>
%容器 ~LET %文書 を`入子にしている閲覧文脈~容器$
</li>
			<li>
~IF［
%容器 ~NEQ ε
］~AND［
%容器 の`~iframe~fullscreen~flag$ ~EQ ~ON
］
⇒
%文書 ~SET %容器 の`~node文書$
</li>
			<li>
~ELSE
⇒
~BREAK
</li>
		</ol>
◎
While true:
• Let lastDoc be docs’s last document.
• Assert: lastDoc’s fullscreen element is not null.
• If lastDoc is not a simple fullscreen document, break.
• Let container be lastDoc’s browsing context container, if any, and otherwise break.
• If container’s iframe fullscreen flag is set, break.
• Append container’s node document to docs.
</li>
	<li>
<p>
~RET %文書たち
◎
Return docs.
</p>


<p class="note">注記：
%文書たち は，文書のうち［
その`~fullscreen要素$が~unfullscreenされることになるもの
］からなるが、その最後の文書 %文書 の`上端~層$内には［
`~fullscreen~flag$ ~EQ ~ON
］にされた`要素$が複数個あるかもしれない
— その事例では、 %文書 は依然として，~fullscreenであり続けることになる。
◎
This is the set of documents for which the fullscreen element will be unfullscreened, but the last document in docs might have more than one element in its top layer with the fullscreen flag set, in which case that document will still remain in fullscreen.
</p></li>
</ol>

<p class="algo-head">
`~fullscreenから抜出る@
ときは、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
To exit fullscreen a document doc, run these steps:
</p>

<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］~OR［
%文書 の`~fullscreen要素$ ~EQ ~NULL
］
⇒＃
`TypeError^E 例外で %~promise を`却下する$；
~RET %~promise
◎
If doc is not fully active or doc’s fullscreen element is null, then reject promise with a TypeError exception and return promise.
</li>
	<li>
%~resize ~LET ~F
◎
Let resize be false.
</li>
	<li>
%文書たち ~LET `~unfullscreenする文書を収集する$( %文書 )
◎
Let docs be the result of collecting documents to unfullscreen given doc.
</li>
	<li>
%~top-level文書 ~LET %文書 の`~top-level閲覧文脈$にて`作動中の文書$
◎
Let topLevelDoc be doc’s top-level browsing context’s active document.
</li>
	<li>
~IF［
%~top-level文書 ~IN %文書たち
］~AND［
%~top-level文書 は`単純~fullscreen文書$である
］
⇒＃
%文書 ~SET %~top-level文書；
%~resize ~SET ~T
◎
If topLevelDoc is in docs, and it is a simple fullscreen document, then set doc to topLevelDoc and resize to true.
</li>
	<li>
~RET %~promise
— ただし，以降の手続きも`並列的$に走らす。
◎
Return promise, and run the remaining steps in parallel.
</li>
	<li>
~IF［
%~resize ~EQ ~T
］
⇒
%文書 の表示域を その “通常の” 寸法に~resizeする
◎
If resize is true, resize doc’s viewport to its "normal" dimensions.
</li>
	<li>
~IF［
%文書 の`~fullscreen要素$ ~EQ ~NULL
］
⇒＃
`undefined^jv で %~promise を`解決する$；
~RET
◎
If doc’s fullscreen element is null, then resolve promise with undefined and terminate these steps.
</li>
	<li>
%抜出る文書たち ~LET `~unfullscreenする文書を収集する$( %文書 )
◎
Let exitDocs be the result of collecting documents to unfullscreen given doc.
</li>
	<li>
<p>
%子孫~文書たち ~LET 次をいずれも満たす文書 %子孫~文書 からなる，`木~順序$†による`有順序~集合$（無ければ空）
</p>
		<ul>
			<li>
ある`閲覧文脈$ %B があって，次が満たされる
⇒
［
%子孫~文書 は %B にて`作動中の文書$である
］~AND［
%文書 が`属する閲覧文脈$は %B の`先祖~閲覧文脈$である
］
</li>
			<li>
%子孫~文書 の`~fullscreen要素$ ~NEQ ~NULL
</li>
		</ul>

【† この “木~順序” は、 %子孫~文書 を`入子にしている閲覧文脈~容器$どうしのそれと，閲覧文脈の親子関係によるそれの，両者を含むと思われる。】
◎
Let descendantDocs be an ordered set consisting of doc’s descendant browsing contexts' active documents whose fullscreen element is non-null, if any, in tree order.
</li>
	<li>
<p>
%抜出る文書たち 内の~EACH( %抜出る文書 ) に対し：
◎
For each exitDoc in exitDocs:
</p>
		<ol>
			<li>
%抜出る文書 の`処理待ち~fullscreen~eventの~list$に
~pair( `fullscreenchange^et, %抜出る文書 の`~fullscreen要素$ )
を`付加する$set
◎
Append (fullscreenchange, exitDoc’s fullscreen element) to exitDoc’s list of pending fullscreen events.
</li>
			<li>
~IF［
%~resize ~EQ ~T
］
⇒
`文書を~unfullscreenする$( %抜出る文書 )
◎
If resize is true, unfullscreen exitDoc.
</li>
			<li>
~ELSE
⇒
`要素を~unfullscreenする$( %抜出る文書 の`~fullscreen要素$ )
◎
Otherwise, unfullscreen exitDoc’s fullscreen element.
</li>
		</ol>
	</li>
	<li>
<p>
%子孫~文書たち 内の~EACH( %子孫~文書 ) に対し：
◎
For each descendantDoc in descendantDocs:
</p>
		<ol>
			<li>
%子孫~文書 の`処理待ち~fullscreen~eventの~list$に
~pair( `fullscreenchange^et, %子孫~文書 の`~fullscreen要素$ )
を`付加する$set
◎
Append (fullscreenchange, descendantDoc’s fullscreen element) to descendantDoc’s list of pending fullscreen events.
</li>
			<li>
`文書を~unfullscreenする$( %子孫~文書 )
◎
Unfullscreen descendantDoc.
</li>
		</ol>

<p class="note">注記：
文書たちが~unfullscreenされる順序は観測され得ない
— `~fullscreen化~手続き$は、`木~順序$で呼出されるので。
【なぜ観測され得ない？】
◎
The order in which documents are unfullscreened is not observable, because run the fullscreen steps is invoked in tree order.
</p>
	</li>
	<li>
`undefined^jv で %~promise を`解決する$
◎
Resolve promise with undefined.
</li>
</ol>

<dl class="idl-def">
	<dt>`exitFullscreen()@m</dt>
	<dd>
被呼出時には、次の結果を返さ~MUST
⇒
`~fullscreenから抜出る$( 此れ )
◎
The exitFullscreen() method, when invoked, must return the result of running exit fullscreen on the context object.
</dd>
</dl>

<hr>

<p>
以下に挙げる各種`~event~handler$（および，対応する`~event~handler~event型$）は、［
`Element$I ／ `Document$I
］~objにより，`~event~handler~IDL属性$として~supportされ~MUST：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported by Element and Document objects as event handler IDL attributes:
</p>

<table><thead>
<tr><th>`~event~handler$
</th><th>`~event~handler~event型$
</th></tr></thead><tbody>

<tr><td>`onfullscreenchange@m
</td><td>`fullscreenchange^et
</td></tr>

<tr><td>`onfullscreenerror@m
</td><td>`fullscreenerror^et
</td></tr></tbody></table>


<p class="note">注記：
これらは、［
`ShadowRoot$I ／ `Window$I
］~objからは~supportされない。
また、 `Element$I ~obj用の対応する`~event~handler内容~属性$も無い
— 名前空間を問わず。
◎
These are not supported by ShadowRoot or Window objects, and there are no corresponding event handler content attributes for Element objects in any namespace.
</p>

	</section>
	<section id="ui">
<h2 title="UI">4. ~UI</h2>

<p>
~UAには、［
`requestFullscreen()$mE,
`exitFullscreen()$m
］の手続きを通して，~native媒体の~fullscreen制御を実装することが奨励される。
◎
User agents are encouraged to implement native media fullscreen controls in terms of requestFullscreen() and exitFullscreen().
</p>


<p>
末端利用者は、［
`requestFullscreen()$mE を介して起動された ~fullscreen~sessionを終止する
］よう，~UAに指図している場合
⇒
`~fullscreenから全部的に抜出る$( `~top-level閲覧文脈$にて`作動中の文書$ )
◎
If the end user instructs the user agent to end a fullscreen session initiated via requestFullscreen(), fully exit fullscreen the top-level browsing context’s active document.
</p>


<p>
~UAは、［
末端利用者からの指図 ／
`exitFullscreen()$m の~call
］が無いときでも，必要と判断されるならば ~fullscreen~sessionを終止して~MAY。
◎
The user agent may end any fullscreen session without instruction from the end user or call to exitFullscreen() whenever the user agent deems it necessary.
</p>



	</section>
	<section id="rendering">
<h2 title="Rendering">5. 描画</h2>

<p>
この節は、~HTMLの<a href="~HTMLrendering#rendering" >具現化~節</a>と等価に解釈されることになる。
`HTML$r
◎
This section is to be interpreted equivalently to the Rendering section of HTML. [HTML]
</p>


<p class="XXX">
~CSSは、ゆくゆくは，`上端~層$の概念を定義した上で ［
それに結付けられる `backdrop$pe 疑似要素は、~CSSの積層~文脈~modelの一部を成す
］ものとして定義することになる。
ここで行う~CSSへの継当ては、大雑把な~~素描に過ぎない。
◎
Long term CSS will define the top layer concept and its associated ::backdrop pseudo-element as part of CSS' stacking context model. Patching CSS as done here is sketchy as hell.
</p>


<p class="trans-note">【
この訳では、この節の一部の~CSS［
用語 ／ ~prop
］に，リンクを補完している。
】</p>

		<section id="new-stacking-layer">
<h3 title="New stacking layer">5.1. 新たな積層~層</h3>

<p>
この仕様は、
CSS 2.1 による
<a href="~CSS22/zindex.html">積層~文脈の詳説</a>
に，新たな積層~層を導入する。
それは，
`上端~層@
（ top layer ）と呼ばれ、塗り順序における段 10 【最後の段】の後に来る
— したがって、`表示域$の中で，利用者から見て最も手前に描画される。
各 `文書$には， 1 個の`表示域$が結付けられる
— したがって、 1 個の`上端~層$がある。
`CSS$r
◎
This specification introduces a new stacking layer to the Elaborate description of Stacking Contexts of CSS 2.1. It is called the top layer, comes after step 10 in the painting order, and is therefore rendered closest to the user within a viewport. Each document has one associated viewport and therefore also one top layer. [CSS]
</p>


<p class="note">注記：
以下のこの節とその下位節に利用される各種用語は、 CSS 2.1, 付録 E に合致するよう試みる。
◎
The terminology used in this and following subsection attempts to match CSS 2.1 Appendix E.
</p>

<p>
`上端~層$は、一連の要素が成す`有順序~集合$であり，集合~内に現れる順序で描画される。
この集合の最後の要素は、最後に描画され，したがって上端【最も手前】に現れる。
◎
The top layer is an ordered set of elements, rendered in the order they appear in the set. The last element in the set is rendered last, and thus appears on top.
</p>


<p class="note">注記：
`z-index$p ~propによる`上端~層$に対する効果は無い。
◎
The z-index property has no effect in the top layer.
</p>

<p>
`上端~層$を成す各［
要素, 【要素を`出自の要素$とする】 `backdrop$pe `疑似要素$
］ %E は、以下の特徴を備える：
◎
Each element and ::backdrop pseudo-element in a top layer has the following characteristics:
</p>

<ul>
	<li>
%E は新たな`積層~文脈$を生成する。
◎
It generates a new stacking context.
</li>
	<li>
%E の親~積層~文脈は、根~積層~文脈である。
◎
Its parent stacking context is the root stacking context.
</li>
	<li>
%E が複数の~layout~boxからなる場合、それらのうち最初の~boxが利用される。
◎
If it consists of multiple layout boxes, the first box is used.
</li>
	<li>
<p>
%E は、［
%E の`根$の同胞であった
］かのように，不可分な単位として描画される。
◎
It is rendered as an atomic unit as if it were a sibling of its root.
</p>


<p class="note">注記：
%E の`先祖$要素の
`overflow$p,
`opacity$p,
`mask$p,
等々の~propは、 %E に影響し得ない。
◎
Ancestor elements with overflow, opacity, masks, etc. cannot affect it.
</p>
	</li>
	<li>
%E の`包含塊$は、
%E の `position$p ~propの`算出値$に応じて，［
 `fixed^v ならば `表示域$ ／
~ELSE_ `初期~包含塊$
］になる
◎
If its position property computes to fixed, its containing block is the viewport, and the initial containing block otherwise.
</li>
	<li>
%E は要素であって，次を満たす場合、［
%E , および %E を`出自の要素$とする `backdrop$pe `疑似要素$
］は，描画されない
⇒
%E の`~shadowも含む広義-先祖$【のうち，いずれか】の `display$p ~propの値 ~EQ `none^v
◎
If it is an element, it and its ::backdrop pseudo-element are not rendered if its shadow-including inclusive ancestor has the display property set to none.
</li>
	<li>
%E の `display$p ~propは、その`指定値$が `contents^v ならば，`算出値$は `block^v になる。
◎
If its specified display property is contents, it computes to block.
</li>
	<li>
%E の `position$p ~propは、その`指定値$
~NIN { `absolute^v, `fixed^v }
ならば，`算出値$は `absolute^v になる。
◎
If its specified position property is not absolute or fixed, it computes to absolute.
</li>
	<li>
<p>
%E の外形線（ `outline$p ）は、あるならば 塗り順序における段 10 の前に描画される。
</p>
<p class="trans-note">【
段 10 は最後の段。
外形線は，任意選択で この段か 別の段で塗るものとされているので、段 10 “の前” という言い回しはおかしく，単に別の段で塗る選択肢は除外されることを表す
— すなわち，必ず最後に塗る。
】</p>
◎
Its outline, if any, is to be rendered before step 10 in the painting order.
</li>
	<li>
別の仕様により上書きされない限り、 %E の［
`left$p ／ `right$p ／ `top$p
］用の`静的~位置$は 0 になる。
◎
Unless overridden by another specification, its static position for left, right, and top is zero.
</li>

</ul>

<p class="algo-head">
%要素 を %上端~層 に
`追加する@
ときは
⇒＃
%上端~層 から %要素 を`除去する$；
%上端~層 に %要素 を`付加する$set
◎
To add an element to a top layer, remove it from top layer and then append it to top layer.
</p>

<p class="note">注記：
言い換えれば、 %要素 が %上端~層 内にすでに在るならば %上端~層 の末尾に移動する。
◎
In other words, element is moved to the end of top layer if it is already present.
</p>

		</section>
		<section id="::backdrop-pseudo-element">
<h3 title="::backdrop pseudo-element">5.2. `backdrop^pe 疑似要素</h3>

<p>
`上端~層$内の各~要素は
`backdrop@pe
`疑似要素$を持つ。
この疑似要素は、同じ`上端~層$の中で要素の直下（集合~内で要素の直前にある要素の直上）に描画される~boxである。
◎
Each element in a top layer has a ::backdrop pseudo-element. This pseudo-element is a box rendered immediately below the element (and above the element before the element in the set, if any), within the same top layer.
</p>


<p class="note">注記：
`backdrop$pe 疑似要素は、`上端~層$内の要素（~fullscreenに表示される要素など）用に［
下層の文書を隠す後景
］を作成するために利用できる。
◎
The ::backdrop pseudo-element can be used to create a backdrop that hides the underlying document for an element in a top layer (such as an element that is displayed fullscreen).
</p>

<p>
この疑似要素は、要素から何も継承しない／何からも継承されない。
また、どの~propを適用し得るかについても，制約は無い。
◎
It does not inherit from any element and is not inherited from. No restrictions are made on what properties apply to this pseudo-element either.
</p>

		</section>
		<section id=":fullscreen-pseudo-class">
<h3 title=":fullscreen pseudo-class">5.3. `fullscreen^ps 疑似類</h3>

<p>
`fullscreen@ps
`疑似類$は、次のいずれかを満たすどの`要素$ %要素 にも合致し~MUST：
◎
The :fullscreen pseudo-class must match any element element for which one of the following conditions is true:
</p>

<ul>
	<li>
%要素 の`~fullscreen~flag$ ~EQ ~ON
◎
element’s fullscreen flag is set.
</li>
	<li>
［
%要素 は`~shadow~host$である
］~AND［［［
%要素 の`~node文書$の`~fullscreen要素$
］を %要素 に向けて`~targetし直す$
］~EQ %要素
］
◎
element is a shadow host and the result of retargeting its node document’s fullscreen element against element is element.
</li>
</ul>


<p class="note">注記：
これは、最上端の`~fullscreen要素$を返す
`fullscreenElement$m ~APIとは異なる。
◎
This makes it different from the fullscreenElement API, which returns the topmost fullscreen element.
</p>



		</section>
		<section id="user-agent-level-style-sheet-defaults">
<h3 title="User-agent level style sheet defaults">5.4. ~UA~levelの既定の~stylesheet</h3>


<pre>
@namespace "http://www.w3.org/1999/xhtml";

*|*:not(:root):fullscreen {
  position:fixed !important;
  top:0 !important; right:0 !important; bottom:0 !important; left:0 !important;
  margin:0 !important;
  box-sizing:border-box !important;
  min-width:0 !important;
  max-width:none !important;
  min-height:0 !important;
  max-height:none !important;
  width:100% !important;
  height:100% !important;
  transform:none !important;

  /* intentionally not !important */
  object-fit:contain;
}

iframe:fullscreen {
  border:none !important;
  padding:0 !important;
}

::backdrop {
  position:fixed;
  top:0; right:0; bottom:0; left:0;
}

*|*:not(:root):fullscreen::backdrop {
  background:black;
}
</pre>



		</section>
	</section>
	<section id="security-and-privacy-considerations">
<h2 title="Security and Privacy Considerations">6. ~securityと~privacy上の考慮点</h2>

<p>
~UAは、重層するなどの手段により，末端利用者が［
何かが~fullscreenで表示されていること
］に気付けることを確保するべきである。
~UAは、［
常に働くような，~fullscreenから抜出る手段
］を供して，利用者に告知するべきである。
これは、ある~siteが［
~fullscreenにある間、~UAや~OS環境までも~~模造して，末端利用者を欺く
］のを防止する。
`requestFullscreen()$mE の定義も見よ。
◎
User agents should ensure, e.g. by means of an overlay, that the end user is aware something is displayed fullscreen. User agents should provide a means of exiting fullscreen that always works and advertise this to the user. This is to prevent a site from spoofing the end user by recreating the user agent or even operating system environment when fullscreen. See also the definition of requestFullscreen().
</p>

<p>
`入子の閲覧文脈$内の内容が~fullscreenになるのを可能化するためには、~HTML `iframe$e 要素の `allowfullscreen^a 属性を介して特定的に許容される必要がある。
これは例えば、［
第三者主体からの内容が，明示的な許可なしに~fullscreenになる
］のを防止する。
◎
To enable content in a nested browsing context to go fullscreen, it needs to be specifically allowed via the allowfullscreen attribute of the HTML iframe element. This prevents e.g. content from third parties to go fullscreen without explicit permission.
</p>


	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p lang="en-x-a0">
Many thanks to Robert O’Callahan for designing the initial model and being awesome.
</p>

<p lang="en-x-a0">
Thanks to
Andy Earnshaw,
Chris Pearce,
Darin Fisher, <i>fantasai</i>,
Giuseppe Pascale,
Glenn Maynard,
Ian Hickson,
Ignacio Solla,
João Eiras,
Josh Soref,
Matt Falkenhagen,
Mihai Balan,
Mounir Lamouri,
Øyvind Stenhaug,
Pat Ladd,
Rafał Chłodnicki,
Riff Jiang,
Rune Lillesveen,
Sigbjørn Vik,
Simon Pieters,
Tab Atkins,
Takayoshi Kochi,
Theresa O’Connor,
triple-underscore,
Vincent Scheib, and
Xidorn Quan
for also being awesome.
</p>

<p lang="en-x-a0">
This standard is edited by <a href="https://foolip.org/" lang="sv">Philip Jägenstedt</a> (<a href="https://google.com/">Google</a>, <a href="mailto:philip@foolip.org">philip@foolip.org</a>). It was originally written by <a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a> (<a href="https://www.mozilla.org/">Mozilla</a>, <a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>). <a href="http://tantek.com/" lang="tr">Tantek Çelik</a> (<a class="p-org org h-org h-card" href="https://www.mozilla.org/">Mozilla</a>, <a href="mailto:tantek@cs.stanford.edu">tantek@cs.stanford.edu</a>) sorted out legal hassles.
</p>

<p lang="en-x-a0">
Copyright © 2018 WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.
</p>

	</section>

</main></div>
