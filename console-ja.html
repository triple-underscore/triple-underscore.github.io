<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Console Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	Util.switchWordsInit({
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		toc_main: 'MAIN0',
		generate: expand
	});
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return `<var>${match.slice(1)}</var>`
}

let text = key;
let href = '';

switch(klass){
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'jI':
	text = `%${key}%`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2021-03-23
trans_update:2019-08-11
source_checked:170913
spec_status:LS
original_url:https://console.spec.whatwg.org/
ref_id_prefix:refs
copyright:,whatwg
trans_1st_pub:2017-10-02

●●class_map
E:error
A:abstract
jv:js-value
jT:js-type
jI:js-intrinsic
U:code-point

●●tag_map
I:code
m:code
E:code
U:span
jv:code
jT:code
jI:code
A:span
c:code
i:i


●●mdn_urls

namespacedef-console:API/Console
assert:API/Console/assert
clear:API/Console/clear
count:API/Console/count
countreset:API/Console/countReset
debug:API/Console/debug
dir:API/Console/dir
dirxml:API/Console/dirxml
error:API/Console/error
group:API/Console/group
groupcollapsed:API/Console/groupCollapsed
groupend:API/Console/groupEnd
info:API/Console/info
log:API/Console/log
table:API/Console/table
time:API/Console/time
timeend:API/Console/timeEnd
timelog:API/Console/timeLog
trace:API/Console/trace
warn:API/Console/warn

●●original_id_map
	console-namespace:console-interface
	assert:assert-condition-data
	assert:dom-console-assert
	clear:dom-console-clear
	debug:debug-data
	debug:dom-console-debug
	error:error-data
	error:dom-console-error
	info:info-data
	info:dom-console-info
	log:log-data
	log:dom-console-log
	table:table-tabulardata-properties
	table:dom-console-table
	trace:trace-data
	trace:dom-console-trace
	warn:warn-data
	warn:dom-console-warn
	count:count-label
	count:dom-console-count
	group:group-data
	group:dom-console-group
	groupcollapsed:groupcollapsed-data
	groupcollapsed:dom-console-groupcollapsed
	groupend:dom-console-groupend
	time:time-label
	time:dom-console-time
	timeend:dom-console-timeend

●●link_map


	●IDL
jI.ObjectPrototype:~TC39#sec-properties-of-the-object-prototype-object
jI.parseFloat:~TC39#sec-parsefloat-string
jI.parseInt:~TC39#sec-parseint-string-radix
jI.String:~TC39#sec-string-constructor

Exposed:~WEBIDLjs#Exposed

undefined:~WEBIDL#idl-undefined
any:~WEBID#idl-any
boolean:~WEBIDL#idl-boolean
object:~WEBIDL#idl-object
DOMString:~WEBIDL#idl-DOMString
sequence:~WEBIDL#idl-sequence


I.console:#namespacedef-console
m.assert:#assert
m.clear:#clear
m.count:#count
m.countReset:#countreset
m.debug:#debug
m.dir:#dir
m.dirxml:#dirxml
m.error:#error
m.group:#group
m.groupCollapsed:#groupcollapsed
m.groupEnd:#groupend
m.info:#info
m.log:#log
m.table:#table
m.time:#time
m.timeEnd:#timeend
m.timeLog:#timelog
m.trace:#trace
m.warn:#warn

A.Call:~TC39#sec-call
A.Formatter:#formatter
A.Logger:#logger
A.Printer:#printer

r.ECMASCRIPT:#biblio-ecmascript
計数~map:#count-map

A.ObjectCreate:~TC39#sec-objectcreate
A.ToString:~TC39#sec-tostring
A.Type:~TC39#sec-ecmascript-data-types-and-values

~group~stack:#group-stack
~group:#concept-group
汎用~JS~objの整形:#generic-javascript-object-formatting
最適に有用な整形:#optimally-useful-formatting
~timer~table:#timer-table
~consoleに警告を報告する:#report-a-warning-to-the-console

~log~level:#loglevel-severity

文字列:~INFRA#string
~list:~INFRA#list
~size:~INFRA#list-size
空:~INFRA#list-is-empty
空にする:~INFRA#list-empty
除去する:~INFRA#list-remove
付加する:~INFRA#list-append
前付加する:~INFRA#list-prepend
	~EACH:~INFRA#list-iterate

~stack:~INFRA#stack
~pop:~INFRA#stack-pop
~push:~INFRA#stack-push

~map:~INFRA#ordered-map
	~SET :~INFRA#map-set
	~SET ε:~INFRA#map-remove
	~NEQ ε:~INFRA#map-exists
	[]:~INFRA#map-get

名前空間~obj:~WEBIDLjs#dfn-namespace-object

	issue~tracker:https://github.com/whatwg/console/issues

_acks1:#_acks1
_ipr1:#_ipr1

●●images
print-before-returning｜｜｜console/print-before-returning.png
timeEnd-formatting｜｜｜console/timeEnd-formatting.png
edge-Count｜｜｜console/edge-Count.png
dedupe｜｜｜console/dedupe.png
severity-filter｜｜｜console/severity-filter.png

●●words_table1

●●words_table

	●data型／JS/DOM
List:
	status::::ステータス

	●console
UX:
callstack::::callスタック
trace::::トレース
console::::
	コンソール
	log用の:logging
timer::::タイマー
severity:
	報告-法:reporting
厳しさ:severity::~
警告-:warn::~
警告:warning::~
浮動小数点数:float::~
	時点:time
計数:count::~::カウント
	計数~用:counting
時間長:duration::~

	main::::
	集約:de-duplication
	ミリ秒間:ms duration
	文字列でない:non-string
	文字列~化:stringify
	group分け

	●UI／呈示／整形
print:
書式:format::~
	整形-済み~data:formattedData
	各列:columns:
	各行:rows:
表構造:tabular:::テーブル構造
展開-:expand::~
畳まれ:collapseされ::~
字下げ:indentation:~
	読める:readable
部位:portion:~
alert:
	開かれ:open
絞込める:filterできる::絞り込める
絞込む:filterする::絞り込む
一括-:batch::~
spam::::スパム
明滅-:flash:~
中立的:neutral:~
	脇に置かれる:off to the side
	青く:blue

	●変数（algo
	%連結結果:concat
	%current:current
	%最終-~list:finalList
	%先頭:first
	%~item:item
	%~map:map
	%~obj:object
	%残り:rest
	%~target:target
	%~trace:trace
	%~group:group
	%~group~label:groupLabel
	%~message:message
	%~timer~table:timerTable
	%~timer~table:-
	%先頭:first
	%変換-済み:converted
	%指定子:specifier
	%時間長:duration
	%結果:result
	%要素:element
	%記述:description
	%警告:warning
	%開始~時刻:startTime


	●仕様
	限られない:non-exhaustive
適度な:reasonableな:ほどよい
参考:informative:~
	規範的でない:informative
参考の:informativeな:~
新機軸:innovation:~
仕事:job:~
計画:plan:~
計画:plan::~
建設的:constructive:~
最大限:maximal:~
	委ねられる:up to
	にもなり得る:potential
	易くする:make it easier
汎用的:generical:~
選ばれ:chosen:~
選ぶ:choose:~
定義な:-definedな:~
判定-:judge:~
増補:enhancement:~
上限:limit:~

	meant
	ことにした:chose to make
	連結:join／:concatenation
	連結結果:concat
	何もしない:do nothing
	見られ:seen
	るようにする:allowing

	~debug時の:debugging
書込む:writeする::書き込む
代用-:substitute::~
給-:supply:~
埋める:fillする:~

	渡-:pass
	-:find

	●未分類
SPACE:
bootstrap:
中間的:intermediate:~

	存続する限り:throughout the life of
	:kind
	-:order
	please
	:logLevel
	:TODO
	-:together

	`Printer^A :printer
	:become
	~most
	~noted
	型~変換:Type Conversion
	振り分けて:group together
	各~methodごとに:depending on the method from which it originated

	●指示語
余分の:extra:追加の
	3 個目~以降の:starting from the third onward
	後続の:other
	に類する:something similar
	以前:previous
	残され／尽きる:left
	現れる順に:left to the right
	後続する:following
	深い:further
	先ず:first
	早期の:early
	広い:broad
	のまま:while leaving
	最終的:eventual
	単に:just
	所:where
	たくさんの:a lot of
	それまでに:previously
	少なくとも何百個か:on the order of at least 100
	主な:main


●●ref_normative
[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.es/ecma262/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[WebIDL]
    Boris Zbarsky. Web IDL. URL: https://heycam.github.io/webidl/


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://console.spec.whatwg.org/">Console Standard</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/console">GitHub whatwg/console</a>
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	<a href="https://github.com/whatwg/console">GitHub whatwg/console</a> (<a href="https://github.com/whatwg/console/issues/new">new issue</a>, <a href="https://github.com/whatwg/console/issues">open issues</a>)
	https://github.com/whatwg/console/commits

	<a href="https://console.spec.whatwg.org/commit-snapshots/6447e9d3cdb01c48094cbaa32d0e5fb1ab74367d/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/consolelog">@consolelog</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/console">web-platform-tests console/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/console">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>


</head>

<body>
<header>

<a href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZwoJeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgoJdmlld0JveD0iMCAwIDEwODAgMTA4MCIKCWZpbGw9IiMzYzc5MGEiCglzdHJva2U9IiMzYzc5MGEiCj4KCjxjaXJjbGUgc3Ryb2tlLXdpZHRoPSIxMDgiIGN4PSI1NDAiIGN5PSI1NDAiIHI9IjQ4NiIgZmlsbD0iI2ZmZiIvPgo8Y2lyY2xlIGN4PSI2MjAiIGN5PSI3MDAiIHI9IjMwIi8+CjxjaXJjbGUgY3g9IjcwMCIgY3k9IjcwMCIgcj0iMzAiLz4KPGNpcmNsZSBjeD0iNzgwIiBjeT0iNzAwIiByPSIzMCIvPgo8cGF0aCBkPSJNMjc4LjggNjAzLjJsMTcyLjctNzAuMi0xNzIuNi03OC44di04Mi43bDI4MS41IDE0MC45djQ3LjlsLTI4MS41IDEyNXYtODIuMXoiLz4KCjwvc3ZnPgo="
></a>

	<hgroup>
<h1 id="title">Console</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この仕様は、
~console~debug時の便宜性のための~APIを定義する。
◎
This specification defines APIs for console debugging facilities.
</p>
	</section>
	<section id="status">
~STATUSofTHIS

<p>
この仕様は、
進捗-中の早期の作業です。
より精確で互換な定義に向けて精緻化するため，~feedbackを歓迎します。
また、編集者の手による最初の仕様なので，どうかお手柔らかかつ建設的に。
◎
This specification is an early work in progress that welcomes feedback to refine toward more precise and compatible definitions. It is also the editors' first specification, so please be kind and constructive.
</p>

<p>
より論を深めたい方は
<a href="https://github.com/whatwg/console/issues">issue tracker</a>
に参加されたし。
◎
Please join us in the issue tracker for more discussion.
</p>

	</section>

<main id="MAIN0">

	<section id="console-namespace">
<h2 title="Namespace console">1. 名前空間 `console^I</h2>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
namespace `console@I { /* <span class="comment">
が、
下の名前空間~obj要件も見よ。
◎
but see namespace object requirements below
</span> */
  // <span class="comment">~log用</span>
  `undefined$ `assert$m(optional `boolean$ %condition = false, `any$... %data);
  `undefined$ `clear$m();
  `undefined$ `debug$m(`any$... %data);
  `undefined$ `error$m(`any$... %data);
  `undefined$ `info$m(`any$... %data);
  `undefined$ `log$m(`any$... %data);
  `undefined$ `table$m(optional `any$ %tabularData, optional `sequence$&lt;`DOMString$&gt; %properties);
  `undefined$ `trace$m(`any$... %data);
  `undefined$ `warn$m(`any$... %data);
  `undefined$ `dir$m(optional `any$ %item, optional `object$? %options);
  `undefined$ `dirxml$m(`any$... %data);

  // <span class="comment">計数~用</span>
  `undefined$ `count$m(optional `DOMString$ %label = "default");
  `undefined$ `countReset$m(optional `DOMString$ %label = "default");

  // <span class="comment">~group分け</span>
  `undefined$ `group$m(`any$... %data);
  `undefined$ `groupCollapsed$m(`any$... %data);
  `undefined$ `groupEnd$m();

  // <span class="comment">計時</span>
  `undefined$ `time$m(optional `DOMString$ %label = "default");
  `undefined$ `timeLog$m(optional `DOMString$ %label = "default", `any$... %data);
  `undefined$ `timeEnd$m(optional `DOMString$ %label = "default");
};
</pre>

<p class="note">注記：
歴史的な理由から、
`console$I は小文字にされている。
◎
For historical reasons, console is lowercased.
</p>

<p class="note">注記：
開発者~consoleが［
開かれていない／存在しない
］場合でも、
`console$I は，~scriptからは［
常に，可視かつ利用-可能
］になることが重要である。
◎
It is important that console is always visible and usable to scripts, even if the developer console has not been opened or does not exist.
</p>

<p>
歴史的な~web互換性の理由から、
`console$I 用の`名前空間~obj$の `Prototype^sl は，
`ObjectPrototype$jI に代えて空な~objになるモノトスル
— `ObjectCreate$A( `ObjectPrototype$jI ) により作成されたかのように。
◎
For historical web-compatibility reasons, the namespace object for console must have as its [[Prototype]] an empty object, created as if by ObjectCreate(%ObjectPrototype%), instead of %ObjectPrototype%.
</p>

		<section id="logging">
<h3 title="Logging functions">1.1. ~log用~関数</h3>

			<section id="assert">
<h4>1.1.1. `assert(condition, ...data)^m</h4>

<ol>
	<li>
~IF［
%condition ~EQ ~T
］
⇒
~RET
◎
If condition is true, return.
</li>
	<li>
%~message ~LET 
表明の失敗を汎用的に指示する, 整形~指定子を伴わない，文字列
（例： `Assertion failed^l ）
◎
Let message be a string without any formatting specifiers indicating generically an assertion failure (such as "Assertion failed").
</li>
	<li>
~IF［
%data は`空$である
］
⇒
%data に %~message を`付加する$
◎
If data is empty, append message to data.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%先頭 ~LET %data[ 0 ]
◎
Let first be data[0].
</li>
			<li>
~IF［
`Type$A( %先頭 ) ~NEQ `String^jT
］
⇒
%data に %~message を`前付加する$
◎
If Type(first) is not String, then prepend message to data.
</li>
			<li>
~ELSE
⇒
%data[ 0 ] ~SET 次を順に連結した結果
⇒＃
%~message,
`003A^U (:),
`0020^U ~SPACE,
%先頭
◎
Otherwise:
• Let concat be the concatenation of message, U+003A (:), U+0020 SPACE, and first.
• Set data[0] to concat.
</li>
		</ol>
	</li>
	<li>
`Logger$A( `assert^l, %data )
◎
Perform Logger("assert", data).
</li>
</ol>

			</section>
			<section id="clear">
<h4>1.1.2. `clear()^m</h4>

<ol>
	<li>
適切な`~group~stack$を`空にする$
◎
Empty the appropriate group stack.
</li>
	<li>
環境にて可能なら，~consoleを~clearする（他の場合，何もしない）
◎
If possible for the environment, clear the console. (Otherwise, do nothing.)
</li>
</ol>

			</section>
			<section id="debug">
<h4>1.1.3. `debug(...data)^m</h4>

<ol>
	<li>
`Logger$A( `debug^l, %data )
◎
Perform Logger("debug", data).
</li>
</ol>

			</section>
			<section id="error">
<h4>1.1.4. `error(...data)^m</h4>

<ol>
	<li>
`Logger$A( `error^l, %data )
◎
Perform Logger("error", data).
</li>
</ol>

			</section>
			<section id="info">
<h4>1.1.5. `info(...data)^m</h4>

<ol>
	<li>
`Logger$A( `info^l, %data )
◎
Perform Logger("info", data).
</li>
</ol>

			</section>
			<section id="log">
<h4>1.1.6. `log(...data)^m</h4>

<ol>
	<li>
`Logger$A( `log^l, %data )
◎
Perform Logger("log", data).
</li>
</ol>

			</section>
			<section id="table">
<h4>1.1.7. `table(tabularData, properties)^m</h4>

<p>
~tableを構築しようと試行した上で，
`~log~level$【！%logLevel】 `log^l の下で~logする
— ~tableの［
各列は、 %tabularData の各~propからなる（または %properties を利用する）／
各行は、 %tabularData からなる
］。
表構造として構文解析できなかった場合、
単に引数を~logすることに~fall-backする。
◎
Try to construct a table with the columns of the properties of tabularData (or use properties) and rows of tabularData and log it with a logLevel of "log". Fall back to just logging the argument if it can’t be parsed as tabular.
</p>

<p class="XXX">
未策定
— これには良い~algoが必要になる。
◎
TODO: This will need a good algorithm.
</p>

			</section>
			<section id="trace">
<h4>1.1.8. `trace(...data)^m</h4>

<ol>
	<li>
%~trace ~LET ［
この関数を~callした所からの~callstack
］の表現
— 実装に特有な, 何らかの, 対話的にもなり得るような
◎
Let trace be some implementation-specific, potentially-interactive representation of the callstack from where this function was called.
</li>
	<li>
任意選択で
⇒
%~trace 用の~labelとして［
`Formatter$A( %data ) の結果
］を組入れる
◎
Optionally, let formattedData be the result of Formatter(data), and incorporate formattedData as a label for trace.
</li>
	<li>
`Printer$A( `trace^l, « %~trace » )
◎
Perform Printer("trace", « trace »).
</li>
</ol>

<p class="note">注記：
~stack~trace内に~printされる関数の識別子は、
実装に依存する。
それはまた、
`new Error().stack^c 内に見られるものと同じ識別子になることは保証されない。
◎
The identifier of a function printed in a stack trace is implementation-dependant. It is also not guaranteed to be the same identifier that would be seen in new Error().stack.
</p>

			</section>
			<section id="warn">
<h4>1.1.9. `warn(...data)^m</h4>

<ol>
	<li>
`Logger$A( `warn^l, %data )
◎
Perform Logger("warn", data).
</li>
</ol>

			</section>
			<section id="dir">
<h4>1.1.10. `dir(item, options)^m</h4>

<ol>
	<li>
%~obj ~LET %item に`汎用~JS~objの整形$を適用した結果
◎
Let object be item with generic JavaScript object formatting applied.
</li>
	<li>
`Printer$A( `dir^l, « %~obj », %options )
◎
Perform Printer("dir", « object », options).
</li>
</ol>

			</section>
			<section id="dirxml">
<h4>1.1.11. `dirxml(...data)^m</h4>

<ol>
	<li>
%最終-~list ~LET 新たな`~list$
◎
Let finalList be a new list, initially empty.
</li>
	<li>
<p>
%data を成す
~EACH( %~item )
に対し：
◎
For each item of data:
</p>
		<ol>
			<li>
%変換-済み ~LET 
%~item の~DOM~tree表現が可能ならば それ ／
~ELSE_ %~item に`最適に有用な整形$を適用した結果
◎
Let converted be a DOM tree representation of item if possible; otherwise let converted be item with optimally useful formatting applied.
</li>
	<li>
%最終-~list に %変換-済み を付加する
◎
Append converted to finalList.
</li>
		</ol>
	</li>
	<li>
`Logger$A( `dirxml^l, %最終-~list )
◎
Perform Logger("dirxml", finalList).
</li>
</ol>

			</section>
		</section>
		<section id="counting">
<h3 title="Counting functions">1.2. 計数~用~関数</h3>

<p>
各 `console$I 名前空間~objには、
`計数~map@
が結付けられる。
それは、
各~entryが［
`文字列$ → 数
］として与えられる`~map$であり，
初期~時は空とする。
◎
Each console namespace object has an associated count map, which is a map of strings to numbers, initially empty.
</p>

			<section id="count">
<h4>1.2.1. `count(label)^m</h4>

<ol>
	<li>
%~map ~LET コレの`計数~map$
◎
Let map be the associated count map.
</li>
	<li>
~IF［
%~map[ %label ] ~NEQ ε
］
⇒
%~map[ %label ] ~INCBY 1
◎
If map[label] exists, set map[label] to map[label] + 1.
</li>
	<li>
~ELSE
⇒
%~map[ %label ] ~SET 1
◎
Otherwise, set map[label] to 1.
</li>
	<li>
%連結結果 ~LET 次を順に連結した結果
⇒＃
%label,
`003A^U (:),
`0020^U ~SPACE,
`ToString$A( %~map[ %label ] )
◎
Let concat be the concatenation of label, U+003A (:), U+0020 SPACE, and ToString(map[label]).
</li>
	<li>
`Logger$A( `count^l, « %連結結果 » )
◎
Perform Logger("count", « concat »).
</li>
</ol>

			</section>
			<section id="countreset">
<h4>1.2.2. `countReset(label)^m</h4>

<ol>
	<li>
%~map ~LET コレの`計数~map$
◎
Let map be the associated count map.
</li>
	<li>
~IF［
%~map[ %label ] ~NEQ ε
］
⇒
%~map[ %label ] ~SET 0
◎
If map[label] exists, set map[label] to 0.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~message ~LET ［
所与の~labelに計数が結付けられてないこと
］を汎用的に指示する, 整形~指定子を伴わない，文字列
◎
Let message be a string without any formatting specifiers indicating generically that the given label does not have an associated count.
</li>
			<li>
`Logger$A( `countReset^l, « %~message » )
◎
Perform Logger("countReset", « message »);
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
		<section id="grouping">
<h3 title="Grouping functions">1.3. ~group分け関数</h3>

<p>
`~group@
は、
実装に特有な, 対話的にもなり得る, 親より字下げ~levelが 1 つ深い, 出力~用の~viewであり、
`Printer$A の~callにより生産される。
各 `console$I 名前空間~objには、
`~group~stack@
が結付けられる
— それは、
`~stack$であり，
初期~時は空とする。
`~group~stack$内の最後の`~group$のみが［
`Printer$A の~callにより生産される出力
］を~hostすることになる。
◎
A group is an implementation-specific, potentially-interactive view for output produced by calls to Printer, with one further level of indentation than its parent. Each console namespace object has an associated group stack, which is a stack, initially empty. Only the last group in a group stack will host output produced by calls to Printer.
</p>

			<section id="group">
<h4>1.3.1. `group(...data)^m</h4>

<ol>
	<li>
%~group ~LET 新たな`~group$
◎
Let group be a new group.
</li>
	<li>
%~group~label ~LET ［
%data は`空$でないならば `Formatter$A( %data ) の結果 ／
~ELSE_ 実装により選ばれる［
`~group$を表現する~label
］］
◎
If data is not empty, let groupLabel be the result of Formatter(data). Otherwise, let groupLabel be an implementation-chosen label representing a group.
</li>
	<li>
%~group~label を %~group 用の~labelとして組入れる
◎
Incorporate groupLabel as a label for group.
</li>
	<li>
任意選択で
⇒
~IF［
環境は対話的~groupを~supportする
］
⇒
%~group は既定で展開されるべきである
◎
Optionally, if the environment supports interactive groups, group should be expanded by default.
</li>
	<li>
`Printer$A( `group^l, « %~group » )
◎
Perform Printer("group", « group »).
</li>
	<li>
適切な`~group~stack$に %~group を`~push$する
◎
Push group onto the appropriate group stack.
</li>
</ol>

			</section>
			<section id="groupcollapsed">
<h4>1.3.2. `groupCollapsed(...data)^m</h4>

<ol>
	<li>
%~group ~LET 新たな`~group$
◎
Let group be a new group.
</li>
	<li>
%~group~label ~LET ［
%data は空でないならば `Formatter$A( %data ) の結果 ／
~ELSE_ 実装により選ばれる［
`~group$を表現する~label
］］
◎
If data is not empty, let groupLabel be the result of Formatter(data). Otherwise, let groupLabel be an implementation-chosen label representing a group.
</li>
	<li>
%~group~label を %~group 用の~labelとして組入れる
◎
Incorporate groupLabel as a label for group.
</li>
	<li>
任意選択で
⇒
~IF［
環境は対話的~groupを~supportする
］
⇒
%~group は既定で畳まれるべきである
◎
Optionally, if the environment supports interactive groups, group should be collapsed by default.
</li>
	<li>
`Printer$A( `groupCollapsed^l, « %~group » )
◎
Perform Printer("groupCollapsed", « group »).
</li>
	<li>
適切な`~group~stack$に %~group を`~push$する
◎
Push group onto the appropriate group stack.
</li>
</ol>

			</section>
			<section id="groupend">
<h4>1.3.3. `groupEnd()^m</h4>

<ol>
	<li>
`~group~stack$から`~pop$する
◎
Pop the last group from the group stack.
</li>
</ol>

			</section>
		</section>
		<section id="timing">
<h3 title="Timing functions">1.4. 計時~関数</h3>

<p>
各 `console$I 名前空間~objには
`~timer~table@
が結付けられる。
それは、
各~entryが［
`文字列$ → 時刻
］として与えられる`~map$であり，
初期~時は空とする。
◎
Each console namespace object has an associated timer table, which is a map of strings to times, initially empty.
</p>

			<section id="time">
<h4>1.4.1. `time(label)^m</h4>

<ol>
	<li>
%~timer~table ~LET コレの`~timer~table$
◎
↓</li>
	<li>
<p>
~IF［
%~timer~table[ %label ] ~NEQ ε
］：
</p>
		<ol>
			<li>
任意選択で
⇒
［
~label %label を伴う~timerは、
すでに開始された
］ことを指示する警告を~consoleに報告する
</li>
			<li>
~RET
</li>
		</ol>
◎
If the associated timer table contains an entry with key label, return, optionally reporting a warning to the console indicating that a timer with label label has already been started.
</li>
	<li>
~ELSE
⇒
%~timer~table[ %label ] ~SET 現在の時刻
◎
Otherwise, set the value of the entry with key label in the associated timer table to the current time.
</li>
</ol>

			</section>
			<section id="timelog">
<h4>1.4.2. `timeLog(label, ...data)^m</h4>

<ol>
	<li>
%~timer~table ~LET コレの`~timer~table$
◎
Let timerTable be the associated timer table.
</li>
	<li>
%開始~時刻 ~LET %~timer~table[ %label ]
◎
Let startTime be timerTable[label].
</li>
	<li>
<p>
%時間長 ~LET 実装定義な書式で
( 現在の時刻 ~MINUS %開始~時刻 )
を表現している文字列
◎
Let duration be a string representing the difference between the current time and startTime, in an implementation-defined format.
</p>

<p class="example" id="duration-string-example">
`4650^l,
`4650.69 ms^l,
`5 seconds^l,
`00:05^l 
は、
どれも 4650.69 ミリ秒間を表示する 適度な仕方である。
◎
"4650", "4650.69 ms", "5 seconds", and "00:05" are all reasonable ways of displaying a 4650.69 ms duration.
</p>
	</li>
	<li>
%連結結果 ~LET 次を順に連結した結果
⇒＃
%label,
`003A^U (:),
`0020^U ~SPACE,
%時間長
◎
Let concat be the concatenation of label, U+003A (:), U+0020 SPACE, and duration.
</li>
	<li>
%data に %連結結果 を`前付加する$
◎
Prepend concat to data.
</li>
	<li>
`Printer$A( `timeLog^l, %data )
◎
Perform Printer("timeLog", data).
</li>
</ol>

<div class="example" id="timelog-example">
<p>
利用者が［
何らかの余分の~dataを伴う中間的な~timer~log
］を給し易くするため、
~timerが存続する限り，
`timeLog()$m の~callに渡す %data ~parameterは `Logger$A の~callに含まれる。
例えば：
◎
The data parameter in calls to timeLog() is included in the call to Logger to make it easier for users to supply intermediate timer logs with some extra data throughout the life of a timer. For example:
</p>

<pre class="lang-js">
console.time("MyTimer");
console.timeLog("MyTimer", "Starting application up…");
/* <span class="comment">
何らかの
— たぶん，複階的な~appを~bootstrapするような —
~codeが走る。
◎
Perhaps some code runs to bootstrap a complex app
</span> */
// ...
console.timeLog("MyTimer", "UI is setup, making API calls now");
/* <span class="comment">
何らかの
— たぶん，~appを それ用の~dataで埋めるような —
`fetch()^c をここで行う。
◎
Perhaps some fetch()'s here filling the app with data
</span> */
// ...
console.timeEnd("MyTimer");
</pre>
</div>

			</section>
			<section id="timeend">
<h4>1.4.3. `timeEnd(label)^m</h4>

<ol>
	<li>
%~timer~table ~LET コレの`~timer~table$
◎
Let timerTable be the associated timer table.
</li>
	<li>
%開始~時刻 ~LET %~timer~table[ %label ]
◎
Let startTime be timerTable[label].
</li>
	<li>
%~timer~table[ %label ] ~SET ε
◎
Remove timerTable[label].
</li>
	<li>
%時間長 ~LET 実装定義な書式で
( 現在の時刻 ~MINUS %開始~時刻 )
を表現している文字列
◎
Let duration be a string representing the difference between the current time and startTime, in an implementation-defined format.
</li>
	<li>
%連結結果 ~LET 次を順に連結した結果
⇒＃
%label,
`003A^U (:),
`0020^U ~SPACE,
%時間長
◎
Let concat be the concatenation of label, U+003A (:), U+0020 SPACE, and duration.
</li>
	<li>
`Printer$A( `timeEnd^l, « %連結結果 » )
◎
Perform Printer("timeEnd", « concat »).
</li>
</ol>

<p class="note" role="note">
%~timer~table 内に所与の %label が存在しないときに，
`timeEnd()$m, `timeLog()$m
が正式に警告を~consoleに報告させる計画については、
<a href="https://github.com/whatwg/console/issues/134">課題 #134</a>
を見よ。
◎
See whatwg/console#134 for plans to make timeEnd() and timeLog() formally report warnings to the console when a given label does not exist in the associated timer table.
</p>
			</section>
		</section>
	</section>
	<section id="supporting-ops">
<h2 title="Supporting abstract operations">2. 抽象-演算の~support法</h2>

		<section id="logger">
<h3>2.1. `Logger^A( %logLevel, %args )</h3>

<p>
`Logger^A 演算は、
( `~log~level$ %logLevel, 他の引数からなる`~list$ %args )
を受容する。
その主な出力を成すのは、
実装により定義される，結果を~consoleへ~printする副作用である。
この仕様は、
そうする間に整形-指定子をどう処理するかについて述べる。
◎
The logger operation accepts a log level and a list of other arguments. Its main output is the implementation-defined side effect of printing the result to the console. This specification describes how it processes format specifiers while doing so.
</p>
<ol>
	<li>
~IF［
%args は`空$である
］
⇒
~RET
◎
If args is empty, return.
</li>
	<li>
%先頭 ~LET %args[ 0 ]
◎
Let first be args[0].
</li>
	<li>
%残り ~LET %args 内の %先頭 に後続するすべての要素からなる`~list$
◎
Let rest be all elements following first in args.
</li>
	<li>
~IF［
%残り は`空$である
］
⇒＃
`Printer$A( %logLevel, « %先頭 » )；
~RET
◎
If rest is empty, perform Printer(logLevel, « first ») and return.
</li>
	<li>
~IF［
%先頭 は整形-指定子を包含しない
］
⇒
`Printer$A( %logLevel, %args )
◎
If first does not contain any format specifiers, perform Printer(logLevel, args).
</li>
	<li>
~ELSE
⇒
`Printer$A( %logLevel, `Formatter$A( %args ) )
◎
Otherwise, perform Printer(logLevel, Formatter(args)).
</li>
	<li>
~RET `undefined^jv
【 ~RET と ~RET `undefined^jv の違いは？】
◎
Return undefined.
</li>
</ol>

<div class="note">

<p>注記：
~algoが返る前に~printされることが重要である。
多くの開発者~consoleは、
その中に手入力した最後の演算の結果を~printする。
そのような~consoleにおいては、
開発者が
`console.log("hello!")^c
と手入力したとき，
先ず `hello!^l,
次に `console.log^c ~callの返り値 `undefined^jv を~printすることになる。
◎
It’s important that the printing occurs before returning from the algorithm. Many developer consoles print the result of the last operation entered into them. In such consoles, when a developer enters console.log("hello!"), this will first print "hello!", then the undefined return value from the console.log call.
</p>

<figure>
<figcaption id="_dgm-print-before-returning">
返る前に~printし終えたことを指示している図。
◎
Indicating that printing is done before return
</figcaption></figure>
</div>

		</section>
		<section id="formatter">
<h3>2.2. `Formatter^A( %args )</h3>

<p>
`Formatter^A 演算は、
供された最初の引数を，後続の引数を利用して整形しようと試行する。
それは、
最初の引数~内の整形~指定子が尽きるか, 他の引数が尽きるまで，入力を整形しようと試行した上で、
~print用に相応しい何個かの~objからなる`~list$を返す：
◎
The formatter operation tries to format the first argument provided, using the other arguments. It will try to format the input until no formatting specifiers are left in the first argument, or no more arguments are left. It returns a list of objects suitable for printing.
</p>

<ol>
	<li>
%~target ~LET %args の最初の要素
◎
Let target be the first element of args.
</li>
	<li>
%current ~LET %args の 2 個目の要素
◎
Let current be the second element of args.
</li>
	<li>
<p>
%指定子 ~LET %~target 内の未処理の整形-指定子のうち，最初に現れるもの
◎
Find the first possible format specifier specifier, from the left to the right in target.
</p>

<p class="trans-note">【
整形-指定子がない場合や %args が 1 個の要素のみからなる場合にどうなるか定義されていない。
この~algoの末尾にある検査は、
先頭に移動されるべき？
】【
“未処理の” はこの訳による追加。
さもなければ、
同じ整形-指定子を何度も繰り~~返すことにもなり得るので。
】</p>

		<ol>
			<li>
<p>
%変換-済み ~LET %指定子 に応じて，次で与えられる値：
</p>
				<dl class="switch">
					<dt>`%s^l</dt>
					<dd>
`Call$A( `String$jI, `undefined^jv, « %current » )
◎
If specifier is %s, let converted be the result of Call(%String%, undefined, « current »).
</dd>

					<dt>`%d^l</dt>
					<dt>`%i^l</dt>
					<dd>
`Type$A( %current ) に応じて
⇒＃
`Symbol^jT ならば `NaN^jv ／
~ELSE_ `Call$A( `parseInt$jI, `undefined^jv, « %current, 10 » )
◎
If specifier is %d or %i:
• If Type(current) is Symbol, let converted be NaN
• Otherwise, let converted be the result of Call(%parseInt%, undefined, « current, 10 »).
</dd>

					<dt>`%f^l</dt>
					<dd>
`Type$A( %current ) に応じて
⇒＃
`Symbol^jT ならば `NaN^jv ／
~ELSE_ `Call$A( `parseFloat$jI, `undefined^jv, « %current » )
◎
If specifier is %f:
• If Type(current) is Symbol, let converted be NaN
• Otherwise, let converted be the result of Call(%parseFloat%, undefined, « current »).
</dd>

					<dt>`%o^l</dt>
					<dd>
任意選択で、
次のいずれか
⇒＃
%指定子 ／
%current に`最適に有用な整形$を適用した結果
◎
If specifier is %o, optionally let converted be current with optimally useful formatting applied.
</dd>

					<dt>`%O^l</dt>
					<dd>
任意選択で、
次のいずれか
⇒＃
%指定子 ／
%current に`汎用~JS~objの整形$を適用した結果
◎
If specifier is %O, optionally let converted be current with generic JavaScript object formatting applied.
</dd>

					<dt>`%c^l</dt>
					<dd class="XXX">
（未策定）
◎
TODO: process %c
</dd>
				</dl>
			</li>
			<li>
%~target 内の %指定子 を %変換-済み に置換する
【 %変換-済み 内にも整形-指定子があった場合、その指定子も “未処理” と見なされるのか？】
◎
If any of the previous steps set converted, replace specifier in target with converted.
</li>
			<li>
%結果 ~LET %~target, および %args 内の 3 個目~以降の要素からなる`~list$
◎
Let result be a list containing target together with the elements of args starting from the third onward.
</li>
		</ol>
	</li>
	<li>
~IF［
%~target 内に未処理の整形-指定子はない
］
⇒
~RET %結果
◎
If target does not have any format specifiers left, return result.
</li>
	<li>
~IF［
%結果 の`~size$ ~EQ 1
］
⇒
~RET %結果
◎
If result’s size is 1, return result.
</li>
	<li>
~RET `Formatter$A( %結果 )
◎
Return Formatter(result).
</li>
</ol>

			<section id="formatting-specifiers">
<h4 title="Summary of formatting specifiers">2.2.1. 各種 整形~指定子の要約</h4>

<p>
上の~algoにて処理される各種 整形-指定子を，以下に要約する（規範的でない）：
◎
The following is an informative summary of the format specifiers processed by the above algorithm.
</p>

<div>
<table>
<caption>
この表~内の %要素 は、
指定子を代用する要素を指す。
</caption>
<thead>
<tr><th>指定子
<th>目的
<th>型~変換
</thead><tbody>

<tr><td>`%s^l
<td>
%要素 を文字列に変換する
<td>`String$jI( %要素 )

<tr><td>`%d^l ／ `%i^l
<td>
%要素 を整数に変換する
<td>`parseInt$jI( %要素, 10 )

<tr><td>`%f^l
<td>
%要素 を浮動小数点数に変換する
<td>`parseFloat$jI( %要素, 10 )

<tr><td>`%o^l
<td>
%要素 を`最適に有用な整形$で表示する
<td>可用でない

<tr><td>`%O^l
<td>
%要素 を`汎用~JS~objの整形$で表示する
<td>可用でない

<tr><td>`%c^l
<td>
%要素 に供された~CSSを適用する
<td>可用でない
</tbody></table>

◎
Specifier｜Purpose｜Type Conversion
%s｜Element which substitutes is converted to a string｜%String%(element)
%d or %i｜Element which substitutes is converted to an integer｜%parseInt%(element, 10)
%f｜Element which substitutes is converted to a float｜%parseFloat%(element, 10)
%o｜Element is displayed with optimally useful formatting｜n/a
%O｜Element is displayed with generic JavaScript object formatting｜n/a
%c｜Applies provided CSS｜n/a
</div>

			</section>
		</section>
		<section id="printer">
<h3>2.3. `Printer^A( %logLevel, %args[, %options] )</h3>

<p>
`Printer^A 演算は、
実装定義であり，次を受容する
⇒＃
厳しさを指示する`~log~level$ %logLevel,
~printする引数~群を与える~List %args,
実装に特有な整形~optionを与える省略可能な~obj %options
◎
The printer operation is implementation-defined. It accepts a log level indicating severity, a List of arguments to print, and an optional object of implementation-specific formatting options.＼
</p>

<p>
%args 内に現れる要素は、
次に挙げるいずれかになる：
◎
Elements appearing in args will be one of the following:
</p>
<ul>
	<li>
~JS~obj
— 型は問わず
◎
JavaScript objects of any type.
</li>
	<li>
~printできるもの
— ~stack~traceや`~group$など —
を成す，実装に特有な表現
◎
Implementation-specific representations of printable things such as a stack trace or group.
</li>
	<li>
`汎用~JS~objの整形$を適用した結果の~obj
◎
Objects with either generic JavaScript object formatting＼
</li>
	<li>
`最適に有用な整形$を適用した結果の~obj
◎
or optimally useful formatting applied.
</li>
</ul>

<p>
%options ~objが渡され, かつ［
`undefined^jv ／ `null^jv
］でない場合、
実装は，
%options を利用して
%args 内の各 要素に自身に特有な整形を適用してもヨイ。
◎
If the options object is passed, and is not undefined or null, implementations may use options to apply implementation-specific formatting to the elements in args.
</p>

<p>
実装が %args をどう~printするかは，実装に委ねられるが、
実装は，開発者の期待に沿うよう［
~objどうしを~spaceかそれに類する何かで分離する
］べきである。
◎
How the implementation prints args is up to the implementation, but implementations should separate the objects by a space or something similar, as that has become a developer expectation.
</p>

<p>
`Printer^A 演算が~callされる時点では、
すべての整形-指定子は織り込み済みであり，［
整形-指定子により消費されるものと意味された，引数
］は %args 内に残されないことになる。
実装の仕事は、
単純に~Listを~printすることである。
`Printer^A の~callにより生産される出力が現れるのは、［
適切な`~group~stack$が空でなければ その最後の`~group$の中に限られる／
他の場合は~console内の他所になる
］べきである。
◎
By the time the printer operation is called, all format specifiers will have been taken into account, and any arguments that are meant to be consumed by format specifiers will not be present in args. The implementation’s job is simply to print the List. The output produced by calls to Printer should appear only within the last group on the appropriate group stack if the group stack is not empty, or elsewhere in the console otherwise.
</p>

<p>
`Printer^A 演算の~call時に，~consoleが開かれていない場合、
実装は ~messageを~bufferするべきである（概して，少なくとも何百個かは）
— それらを，実装により選ばれる上限までの未来に示すため。
◎
If the console is not open when the printer operation is called, implementations should buffer messages to show them in the future up to an implementation-chosen limit (typically on the order of at least 100).
</p>

			<section id="loglevel-severity">
<h4 title="Indicating logLevel severity">2.3.1. ~logの厳しさ~levelの指示-法</h4>

<p>
`console$I の各~関数は、
各自に一意な値を［
`Printer^A の~call時の %logLevel ~parameter
］に利用する
— 実装は、
各~関数ごとに，~printする~messageを~custom化できるようになる。
しかしながら、［
一連の関数を次の表に要約される 4 ~groupに分けて，
同じ~groupに属する出力は同様に扱う
］ことも，共通的に実施されている：
◎
Each console function uses a unique value for the logLevel parameter when calling Printer, allowing implementations to customize each printed message depending on the function from which it originated. However, it is common practice to group together certain functions and treat their output similarly, in four broad categories. This table summarizes these common groupings:
</p>

<div>
<table><thead>
<tr><th>~group
<th>`console$I 関数
<th>概要
</thead><tbody>

<tr><td>log
<td>
`log()$m,
`trace()$m,
`dir()$m,
`dirxml()$m,
`group()$m,
`groupCollapsed()$m,
`debug()$m,
`timeLog()$m
<td>
汎用な~log

<tr><td>info
<td>
`count()$m,
`info()$m,
`timeEnd()$m
<td>
参考~log

<tr><td>warn
<td>
`warn()$m,
`countReset()$m
<td>
~messageにより指示される何かを利用者~向けに警告する ~log

<tr><td>error
<td>
`error()$m,
`assert()$m
<td>
利用者~向けに~errorを指示する~log

</tbody></table>

◎
Grouping｜console functions｜Description
log｜log(), trace(), dir(), dirxml(), group(), groupCollapsed(), debug(), timeLog()｜A generic log
info｜count(), info(), timeEnd()｜An informative log
warn｜warn(), countReset()｜A log warning the user of something indicated by the message
error｜error(), assert()｜A log indicating an error to the user
</div>

<p>
この~group分けに意味されるのは、
共通的な実施を文書化することである
— 実装が，各~関数~用に
— 次の例に見られるような —
特別な挙動を供さないよう拘束することではない：
◎
These groupings are meant to document common practices, and do not constrain implementations from providing special behavior for each function, as in the following examples:
</p>

<div class="example" id="timeEnd-formatting">
<p>
ここに見られる ある実装は、
`timeEnd()$m への~callにより生産される出力を青くすることにした
— `info()$m による出力は より中立的な色のままにしつつ。
◎
Here you can see one implementation chose to make output produced by calls to timeEnd() blue, while leaving info() a more neutral color.
</p>

<figure>
<figcaption id="_dgm-timeEnd-formatting">
`timeEnd()^m と `info()^m による整形の相違を示すデモ
◎
A demonstration of timeEnd and info formatting differences
</figcaption></figure>
</div>

<div class="example" id="count-output">
<p>
`count()$m の~callは、［
常に，新たな出力を~printする
］とは限らず，［
以前に出力した計数を更新する
］こともある。
◎
Calls to count() might not always print new output, but instead could update previously-output counts.
</p>

<figure>
<figcaption id="_dgm-edge-Count">
計数の挙動を示すデモ
◎
A demonstration of count behavior
</figcaption></figure>
</div>

			</section>
			<section id="printer-ux-innovation">
<h4 title="Printer user experience innovation">2.3.2. `Printer^A ~UX新機軸</h4>

<p>
`Printer$A は実装により定義されるので、
その実装には，~UX（利用者~体験）における新機軸も共通的に見られる。
~UXの増補として，例えば次が挙げられるが、
これらに限られない：
◎
Since Printer is implementation-defined, it is common to see UX innovations in its implementations. The following is a non-exhaustive list of potential UX enhancements:
</p>

<ul>
	<li>
<p>
~spamを防止するため、
互いに一致する出力は一つに集約する。
◎
De-duplication of identical output to prevent spam.
</p>

<div class="example" id="dedupe-example">
<p>
この例の実装は、
互いに一致する複数の~messageを一括するのみならず，
何個の~messageが一緒に一括されたかも供する。
◎
In this example, the implementation not only batches multiple identical messages, but also provides the number of messages that have been batched together.
</p>

<figure>
<figcaption id="_dgm-dedupe">
~console~messageの集約を示すデモ
◎
A demonstration of console message de-duplication
</figcaption></figure>
</div>

	</li>
	<li>
<p>
利用者が ~messageを~logの厳しさ~levelで絞込めるようにするための、
脇に置かれる余分の~UI。
◎
Extra UI off to the side allowing the user to filter messages by log level severity.
</p>

<div class="example" id="severity-filter-example">
<figure>
<figcaption id="_dgm-severity-filter">
絞込むための~UIを示すデモ
◎
</figcaption></figure>
</div>

	</li>
	<li>
［
`~timer~table$, `~group~stack$, その他の内部に保守される~dataの現在の状態
］を指示する, 脇に置かれる, 余分の~UI。
◎
Extra UI off to the side indicating the current state of the timer table, group stack, or other internally maintained data.
</li>
	<li>
~consoleのある部位を明滅して，利用者に何か重要なことを~alertする。
◎
Flashing portions of the console to alert the user of something important.
</li>
</ul>

			</section>
			<section id="object-formats">
<h4 title="Common object formats">2.3.3. 共通的な~obj整形-</h4>

<p>
~objは概して、
その文脈に相応しく整形されて~printされることになる。
この節では、
~objがその文脈にて最も有用に整形されるような，共通的な仕方を述べる。
この節に述べる整形は、［
最終的に `Printer$A に渡されることになる，実装に特有な~obj表現
］に適用されることに注意。
整形による実際の副作用は，そこで見えることになる。
◎
Typically objects will be printed in a format that is suitable for their context. This section describes common ways in which objects are formatted to be most useful in their context. It should be noted that the formatting described in this section is applied to implementation-specific object representations that will eventually be passed into Printer, where the actual side effect of formatting will be seen.
</p>

<p>
`汎用~JS~objの整形@
を伴う~objは、
展開-可能にもなり得る，汎用~JS~objの表現である。
`最適に有用な整形@
を伴う~objは、
対話的にもなり得る, 実装に特有な, 最大限に有用かつ参考と判定された，~objの表現である。
◎
An object with generic JavaScript object formatting is a potentially expandable representation of a generic JavaScript object. An object with optimally useful formatting is an implementation-specific, potentially-interactive representation of an object judged to be maximally useful and informative.
</p>

			</section>
			<section id="nodejs-printer">
<h4 title="Example printer in Node.js">2.3.4. 例： Node.js における `Printer^A</h4>

<div class="example" id="nodejs-printer-example">
<p>
Node.js ~platform上で `Printer^A 演算を実装する最も単純な仕方は、
それまでに整形された引数~群を~spaceで分離して連結した結果の出力を［
`stdout^c ／ `stderr^c
］に書込むことである。
◎
The simplest way to implement the printer operation on the Node.js platform is to join the previously formatted arguments separated by a space and write the output to stdout or stderr.
</p>

<p>
`ECMASCRIPT$r を利用する Node.js における実装~例：
◎
Example implementation in Node.js using [ECMASCRIPT]:
</p>

<pre class="lang-js">
const %util = require('util');

function print(%logLevel, ...%args) {
  const %message = %util.format(...%args);

  if (%logLevel === 'error') {
    process.stderr.write(%message + '\n');
  } else if (%logLevel === 'log' || %logLevel === 'info' || %logLevel === 'warn') {
    process.stdout.write(%message + '\n');
  }
}
</pre>

<p>
ここでの `util.format^c 関数により たくさんの作業が行われる。
それは、
入子な~objを文字列~化して，文字列でない引数は読める文字列~versionに変換する。
例えば `undefined^jv は 文字列 `undefined^l に,  `false^jv は `false^l になる：
◎
Here a lot of the work is done by the util.format function. It stringifies nested objects, and converts non-string arguments into a readable string version, e.g. undefined becomes the string "undefined" and false becomes "false":
</p>

<pre class="lang-js">
print('log', 'duck', [{foo: 'bar'}]);     // prints: `duck [ { foo: 'bar' } ]\n^c on stdout
print('log', 'duck', false);              // prints: `duck false\n^c on stdout
print('log', 'duck', undefined);          // prints: `duck undefined\n^c on stdout
</pre>
</div>

			</section>
		</section>
		<section id="reporting-warnings">
<h3 title="Reporting warnings to the console">2.4. ~consoleへの警告の報告-法</h3>

<p>
`~consoleに警告を報告する@
ときは、
所与の
( 警告の汎用な記述 %記述 )
に対し，実装は次の手続きを走らすモノトスル：
◎
To report a warning to the console given a generic description of a warning description, implementations must run these steps:
</p>

<ol>
	<li>
%警告 ~LET %記述 から導出される実装定義な文字列
◎
Let warning be an implementation-defined string derived from description.
</li>
	<li>
`Printer$A( `reportWarning^l, « %警告 » )
◎
Perform Printer("reportWarning", « warning »).
</li>
</ol>

		</section>
	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main></div>


<div hidden>
<div lang="en" id="_acks1">

<p>
The editors would like to thank
Boris Zbarsky,
Brent S.A. Cowgill,
Brian Grinstead,
Corey Farwell,
Ian Kilpatrick,
Jeff Carpenter,
Joseph Pecoraro,
Justin Woo,
Luc Martin,
Noah Bass,
Paul Irish,
Raphaël, and
Victor Costan
for their contributions to this specification. You are awesome!
</p>

<p lang="en">
This standard is written by <a href="https://terinstock.com">Terin Stock</a> (<a href="mailto:terin@terinstock.com">terin@terinstock.com</a>), <a href="http://kowalski.gd">Robert Kowalski</a> (<a href="mailto:rok@kowalski.gd">rok@kowalski.gd</a>), and <a href="https://domfarolino.com">Dominic Farolino</a> (<a href="mailto:domfarolino@gmail.com">domfarolino@gmail.com</a>)
with major help from <a href="https://domenic.me/">Domenic Denicola</a> (<a href="https://google.com">Google</a>, <a href="mailto:d@domenic.me">d@domenic.me</a>).</p>

</div>

<div lang="en" id="_ipr1">

<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://https://console.spec.whatwg.org/review-drafts/2020-12/">Living Standard Review Draft</a>.
</p>
</div>

</div>
