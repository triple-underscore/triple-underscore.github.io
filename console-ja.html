<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Console Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<style>

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	Util.switchWordsInit({
		collectParts: Util.collectParts,
		toc_main: 'MAIN0',
		generate: expand
	});

//	Util.del_j(); // checked 170913 spec
}

function expand(){

	var class_map = {
		E: 'error',
		A: 'abstract',
		jv: 'js-value',
		jsI: 'js-intrinsic',
		U: 'code-point',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		U: 'span',
		jv: 'span',
		jsI: 'span', // JS intrinsic/prototype object
		A: 'span',
		c: 'code',
		i: 'i',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return '<var>' + match.slice(1) + '</var>'
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U': // Unicode code point
	text = 'U+' + key;
	break;
case 'jsI':
	text = '%' + key + '%';
	break;
case 'dgm':
	return '<a id="_dgm-' + key + '"></a>';
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2018-01-05
trans_update:2017-10-02
spec_status:LS
original_url:https://console.spec.whatwg.org/
ref_id_prefix:refs
navs:idl
trans_1st_pub:2017-10-02


●●link_map


	●IDL
jsI.ObjectPrototype:~TC39#sec-properties-of-the-object-prototype-object
jsI.parseFloat:~TC39#sec-parsefloat-string
jsI.parseInt:~TC39#sec-parseint-string-radix

Exposed:~WEBIDL#Exposed
DOMString:~WEBIDL#idl-DOMString
object:~WEBIDL#idl-object
boolean:~WEBIDL#idl-boolean

m.assert:#assert
m.clear:#clear
I.console:#namespacedef-console
m.count:#count
m.debug:#debug
m.dir:#dir
m.dirxml:#dirxml
m.error:#error
m.group:#group
m.groupCollapsed:#groupcollapsed
m.groupEnd:#groupend
m.info:#info
m.log:#log
m.table:#table
m.time:#time
m.timeEnd:#timeend
m.trace:#trace
m.warn:#warn

A.Formatter:#formatter
A.Logger:#logger
A.Printer:#printer

r.ECMASCRIPT:#biblio-ecmascript
計数~map:#count-map

A.ObjectCreate:~TC39#sec-objectcreate
A.ToString:~TC39#sec-tostring
A.Type:~TC39#sec-ecmascript-data-types-and-values

汎用~JS~obj整形:#generic-javascript-object-formatting
~group~stack:#group-stack
~group:#concept-group
最適に有用な整形:#optimally-useful-formatting
~timer~table:#timer-table

~pop:~INFRA#stack-pop
~push:~INFRA#stack-push
付加する:~INFRA#list-append
前付加する:~INFRA#list-prepend
	~contains:~INFRA#map-exists
空にする:~INFRA#list-empty
	~EACH:~INFRA#list-iterate
空:~INFRA#list-is-empty
	~exists:~INFRA#map-exists
	~getting:~INFRA#map-get
	issue~tracker:https://github.com/whatwg/console/issues
~list:~INFRA#list
除去する:~INFRA#list-remove
~map:~INFRA#ordered-map
名前空間~obj:~WEBIDL#dfn-namespace-object
~set:~INFRA#map-set
~size:~INFRA#list-size
~stack:~INFRA#stack
文字列:~INFRA#string


●●words_table1


●●words_table



	●data型／JS/DOM
DOM:
JS:JavaScript
buffer::::バッファ
call::::
clear::::
data::::データ
host::::ホスト
index::::
List:
method::::メソッド
obj:object:::オブジェクト
script::::スクリプト
status::::ステータス
web::::
名前空間:namespace::~
親:parent:~

item::::アイテム
entry::::エントリ
map::::マップ
空:empty:~
要素:element:~
set::::集合
size::::サイズ
List:
push:
pop:
stack::::スタック

	●console
UX:
UI:
stack-trace::::スタックトレース
callstack:
console::::
	コンソール
error::::エラー
group::::グループ
	group分け::::
label::::ラベル
list::::リスト
log::::ログ
	log用の:logging
level::::レベル
	main::::
space::::
timer::::タイマー
parameter::::パラメタ
prop:property:::プロパティ
severity:
報告-:report::~
失敗:failure::~
指定子:specifier::~
識別子:identifier:~
厳しさ:severity::~
警告-:warn::~
警告:warning::~
表明:assertion::~

型:type::~
引数:argument::~
整数:integer::~
浮動小数点数:float::~
文字列:string::~
	文字列でない:non-string
文字列化-:stringify::~
値:value:~
構文解析-:parse::~::パース
消費-:consume::~

時刻:time::~
	時点:time
計時:timing::~
計数:count::~::カウント
	集約:de-duplication
時間長:duration::~
	ミリ秒間:ms duration

	●UI／呈示／整形
CSS:
print:
message::::メッセージ
書式:format::~
整形-:format::~
	整形-済み~data:formattedData
整形:formatting::~
table:::表::テーブル
	各列:columns:
	各行:rows:
表構造:tabular::~
展開-:expand::~
	展開-可能な:expandable
畳まれ:collapse され::~
view::::ビュー
対話的:interactive::~
手入力-:enter:~
可視:visible:~
字下げ:indentation:~
	読める:readable
部位:portion:~
alert:
	開かれ:open
絞込める:filter できる::絞り込める
一括-:batch::~
spam::::スパム
明滅-:flash:~
中立的:neutral:~
最適:optimal::~
色:color:~
	脇に置かれる:off to the side
	青く:blue

	●仕様
version::::バージョン
option::::オプション
platform::::プラットフォーム
API:
algo:algorithm:::アルゴリズム
互換:compatible:~
互換性:compatibility:~
仕方:way:~
仕様:specification:~
便宜性:facilities:~
	例:example:~
共通的に:common に:よく
共通的な:common な:よくある
副作用:side effect:~
単純:simple:~
	最も単純な:simplest
	可能:possible:~
実施:practice:~
実施-:practice:~
実際の:actual な:~
	必要:need:~
手続き:steps:~
抽象:abstract:~
有用:useful:~
概して:typical に:~
	歓迎-:welcome:~
歴史的:historical:~
汎用:generic:~
汎用の:generic な:~
特別:special:~
特有の:specific な:~
理由:reason:~
環境:environment:~
相応しい:suitable な:~
相応しく:suitable に:~
省略可:optional:~
精確:precise:~
	限られない:non-exhaustive
規範的:normative:~
適切:appropriate:~
適度な:reasonable な:ほどよい
重要:important:~
目的:purpose:~
任意選択で:optional に:~
参考:informative:~
参考の:informative な:~
新機軸:innovation:~
仕事:job:~
	委ねられる:up to
	良い:good な:
	にもなり得る:potential

	●仕様（動詞
support::::サポート
fall-back:fall back:::フォールバック
feedback::::フィードバック
custom::::カスタム
	カスタム化:customize
要約-:summarize:~
要約:summary:~
試行-:try:~
論点:discussion:~
述べる:describe する:~
進捗-:progress:~
遂行-:perform:~
適用-:apply:~
選ばれ:chosen:~
選ぶ:choose:~
開発者:developer:~
防止-:prevent:~
	分けて:broad category:~
利用-:use:~
	利用できる:usable
利用者:user:~
体験:experience:~
作業:work:~
依存-:depend:~
保守-:maintain:~
保証-:guarantee:~
	上限:limit:~
受容-:accept:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
拘束-:constrain:~
指示-:indicate:~
挙動:behavior:ふるまい
提供-:provide:~
期待:expectation:~
用いて:using:~
精緻化-:refine:~
結付け:associate:~:結び付け
結付けら:associate さ:結び付けら
統合-:incorporate:~
編集者:editor:~
要件:requirements:~
相違:differences:~
意味され:mean され:意図され
	meant
判定-:judge:~
増補:enhancement:~
	扱う:treat:~
	織り込まれ:taken into account
	ことにした:chose to make
	連結:join
	何もしない:do nothing
	を示す例:A demonstration of 

	●動詞
debug::::デバッグ
	~debug時の:debugging
付加-:append::~
前付加-:prepend::~
置換-:replace::~
構築-:construct:~
変換-:convert::~
区切る:separate する:~
区切って:separate して:~
作成-:create::~
入子の:nested::入れ子の
処理-:process:~
入力:input:~
出力:output:~
包含-:contain:~
参照-:reference:~
存在-:exist:~
更新-:update:~
書込む:write する::書き込む
生産-:produce::~
表現-:represent::~
表現:representation::~
表示-:display::~
代用-:substitute::~
	現れる:appear する:~
開始-:start:~

	渡-:pass:~
	生じ:occur:~
	示す:show:~
	返す:return
	見よ:see:~
	見られ:seen:~
	-:find:~

	●未分類
内部:internal:~
一意:unique:~
初期:initial:~
	初期~時:initially
小文字:lowercase:~
文書:document:~
文脈:context:~
既定の:default:~:::デフォルト
既定:default:~:::デフォルト
木:tree::~::ツリー
未来:future:~
演算:operation:~
状態:state:~
	無い:not present:~
関数:function:~

SPACE:
	:kind
	-:order
	please
建設的:constructive:~
	:logLevel
	:TODO
	一緒に／-:together

	`Printer^A :printer
	:become
	るようにする:allowing
	~most
	~noted
	型~変換:Type Conversion
	振り分けて:group together
	各~methodごとに:depending on the method from which it originated

	●指示語
余分の:extra:追加の
	個の:one／second／third／four
	3 個目~以降の:starting from the third onward
	〜の代わりに:instead
	ここ:here
	この:this
	これらの:these
	しかしながら，:however
	すでに:already
	すべての:all
	その:that
	そのような:such
	それらの:their
	それらを:them
	べき:should
	一定の:certain:~
	上:above
	下:below
	前:before
	他の／後続の:other:~
	他の場合:otherwise:~
	何か:something:~
	何個 number of
	他所:elsewhere:~
	一致:identical:~
	各:each:~
	同じ:same:~
	同様／類する:similar:~
	多くの:many:~
	以前:previous:~
	残され／尽きる:left:~
	現れる順に:left to the right
	常に:always:~
	次の:the following
	後続の｜従って:following:~
	深い:further:~
	新たな:new:~
	最初の:first:~
	先ず:first:~
	最後の:last:~
	現在の:current:~
	節:section:~
	結果:result:~
	複数の:multiple:~
	早期の:early
	広い:broad
	少なくとも:at least
	のまま:while leaving
	最終的:eventual
	単に:just
	何らかの:some
	所:where
	たくさんの:a lot of
	向けて:toward
	まで:until
	最大に:maximally
	それまでに:previously
	少なくとも何 100 個か:on the order of at least 100
	主な:main


●●ref_normative
[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://console.spec.whatwg.org/">Console Standard</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/console">GitHub whatwg/console</a>
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	<a href="https://github.com/whatwg/console">GitHub whatwg/console</a> (<a href="https://github.com/whatwg/console/issues/new">new issue</a>, <a href="https://github.com/whatwg/console/issues">open issues</a>)

	<a href="/commit-snapshots/d754102bbe2e014e3bab8dea5f74ae8521430f8a/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/consolelog">@consolelog</a>

Tests:
	<a href="https://github.com/w3c/web-platform-tests/tree/master/console">web-platform-tests console/</a> (<a href="https://github.com/w3c/web-platform-tests/labels/console">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>


</head>

<body>

<!--%resource pool -->
<div id="_persisted_parts" style="display:none;">
<img
	id="_dgm-print-before-returning"
	alt=""
	src="console/print-before-returning.png"
>
<img
	id="_dgm-timeEnd-formatting"
	alt=""
	src="console/timeEnd-formatting.png"
>
<img
	id="_dgm-edge-Count"
	alt=""
	src="console/edge-Count.png"
>
<img
	id="_dgm-dedupe"
	alt=""
	src="console/dedupe.png"
>
<img
	id="_dgm-severity-filter"
	alt=""
	src="console/severity-filter.png"
>
</div>

<header>

<a href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZwoJeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgoJdmlld0JveD0iMCAwIDEwODAgMTA4MCIKCWZpbGw9IiMzYzc5MGEiCglzdHJva2U9IiMzYzc5MGEiCj4KCjxjaXJjbGUgc3Ryb2tlLXdpZHRoPSIxMDgiIGN4PSI1NDAiIGN5PSI1NDAiIHI9IjQ4NiIgZmlsbD0iI2ZmZiIvPgo8Y2lyY2xlIGN4PSI2MjAiIGN5PSI3MDAiIHI9IjMwIi8+CjxjaXJjbGUgY3g9IjcwMCIgY3k9IjcwMCIgcj0iMzAiLz4KPGNpcmNsZSBjeD0iNzgwIiBjeT0iNzAwIiByPSIzMCIvPgo8cGF0aCBkPSJNMjc4LjggNjAzLjJsMTcyLjctNzAuMi0xNzIuNi03OC44di04Mi43bDI4MS41IDE0MC45djQ3LjlsLTI4MS41IDEyNXYtODIuMXoiLz4KCjwvc3ZnPgo="
></a>

	<hgroup>
<h1 id="title">Console</h1>
	</hgroup>
</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">~~要約</h2>

<p>
この仕様は、~console~debug時の便宜性のための~APIを定義する。
◎
This specification defines APIs for console debugging facilities.
</p>
	</section>
	<section id="status">
<h2 title="Status">この文書の位置付け</h2>

<p>
この仕様は、進捗-中の早期の作業です。
より精確で互換な定義に向けて精緻化するため，~feedbackを歓迎します。
また、編集者の手による最初の仕様なので、どうかお手柔らかかつ建設的に。
◎
This specification is an early work in progress that welcomes feedback to refine toward more precise and compatible definitions. It is also the editors' first specification, so please be kind and constructive.
</p>


<p>
より論を深めたい方は
<a href="https://github.com/whatwg/console/issues">issue tracker</a>
に参加されたし。
◎
Please join us in the issue tracker for more discussion.
</p>

	</section>


<main id="MAIN0">

	<section id="console-namespace">
<h2 title="Namespace console">1. 名前空間 `console^I</h2>

<span id="console-interface"></span>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
namespace `console@I { /* <span class="comment">
が、下の名前空間~obj要件も見よ。
◎
but see namespace object requirements below
</span> */
  // <span class="comment">~log用</span>
  void `assert$m(optional `boolean$ %condition = false, any... %data);
  void `clear$m();
  void `count$m(optional `DOMString$ %label = "default");
  void `debug$m(any... %data);
  void `error$m(any... %data);
  void `info$m(any... %data);
  void `log$m(any... %data);
  void `table$m(any %tabularData, optional sequence&lt;`DOMString$&gt; %properties);
  void `trace$m(any... %data);
  void `warn$m(any... %data);
  void `dir$m(any %item, optional `object$? %options);
  void `dirxml$m(any... %data);

  // <span class="comment">~group分け</span>
  void `group$m(any... %data);
  void `groupCollapsed$m(any... %data);
  void `groupEnd$m();

  // <span class="comment">計時</span>
  void `time$m(optional `DOMString$ %label = "default");
  void `timeEnd$m(optional `DOMString$ %label = "default");
};
</pre>


<p class="note">注記：
歴史的な理由から、 `console$I は小文字にされている。
◎
For historical reasons, console is lowercased.
</p>

<p class="note">注記：
開発者~consoleが［
開かれていない／存在しない
］場合でも、 `console$I は常に~scriptから可視, かつ利用できることが重要である。
◎
It is important that console is always visible and usable to scripts, even if the developer console has not been opened or does not exist.
</p>

<p>
歴史的な~web互換性の理由から、
`console$I 用の`名前空間~obj$の `Prototype^sl は，
`ObjectPrototype$jsI に代えて空~objで~MUST
— `ObjectCreate$A( `ObjectPrototype$jsI ) により作成されかのように。
◎
For historical web-compatibility reasons, the namespace object for console must have as its [[Prototype]] an empty object, created as if by ObjectCreate(%ObjectPrototype%), instead of %ObjectPrototype%.
</p>

		<section id="logging">
<h3 title="Logging methods">1.1. ~log用~method</h3>

<p>
各 `console$I 名前空間~objには、
`計数~map@
が結付けられる。
それは、各~entryが［
`文字列$→計数<!--  to labels -->
］として与えられる`~map$であり，初期~時には空とする。

◎
Each console namespace object has an associated count map, which is a map of strings to labels, initially empty.
</p>

			<section id="assert">
<h4>1.1.1. `assert(condition, ...data)^m</h4>
<span id="assert-condition-data"></span>
<span id="dom-console-assert"></span>

<ol>
	<li>
~IF［
%condition ~EQ ~T
］
⇒
~RET
◎
If condition is true, return.
</li>
	<li>
%~message ~LET 表明の失敗を指示するような, 汎用の, 整形~指定子を伴わない，文字列（例： `Assertion failed^l ）
◎
Let message be a string without any formatting specifiers indicating generically an assertion failure (such as "Assertion failed").
</li>
	<li>
~IF［
%data は`空$である
］
⇒
%data に %~message を`付加する$
◎
If data is empty, append message to data.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%先頭 ~LET %data[0]
◎
Let first be data[0].
</li>
			<li>
~IF［
`Type$A( %先頭 ) ~NEQ `String^js
］
⇒
%data に %~message を `前付加する$
◎
If Type(first) is not String, then prepend message to data.
</li>
			<li>
~ELSE
⇒
%data[0] ~SET 次を順に連結した結果
⇒＃
%~message,
`003A^U (:),
`0020^U ~SPACE,
%先頭
◎
Otherwise:
• Let concat be the concatenation of message, U+003A (:), U+0020 SPACE, and first.
• Set data[0] to concat.
</li>
		</ol>
	</li>
	<li>
`Logger$A( `assert^l, %data )
を遂行する
◎
Perform Logger("assert", data).
</li>
</ol>



			</section>
			<section id="clear">
<h4>1.1.2. `clear()^m</h4>
<span id="dom-console-clear"></span>

<ol>
	<li>
適切な`~group~stack$を`空にする$
◎
Empty the appropriate group stack.
</li>
	<li>
環境にて可能なら，~consoleを~clearする（他の場合，何もしない）
◎
If possible for the environment, clear the console. (Otherwise, do nothing.)
</li>
</ol>

			</section>
			<section id="count">
<h4>1.1.3. `count(label)^m</h4>
<span id="count-label"></span><span id="dom-console-count"></span>

<ol>
	<li>
%map ~LET 此れの`計数~map$
◎
Let map be the associated count map.
</li>
	<li>
~IF［
%map[ %label ] ~NEQ ε
］
⇒
%map[ %label ] ~INCBY 1
◎
If map[label] exists, set map[label] to map[label] + 1.
</li>
	<li>
~ELSE
⇒
%map[ %label ] ~SET 1
◎
Otherwise, set map[label] to 1.
</li>
	<li>
%concat ~LET 次を順に連結した結果
⇒＃
%label,
`003A^U (:),
`0020^U ~SPACE,
`ToString$A( %map[ %label ])
◎
Let concat be the concatenation of label, U+003A (:), U+0020 SPACE, and ToString(map[label]).
</li>
	<li>
`Logger$A( `count^l, « %concat »)
を遂行する
◎
Perform Logger("count", « concat »).
</li>
</ol>



			</section>
			<section id="debug">
<h4>1.1.4. `debug(...data)^m</h4>
<span id="debug-data"></span><span id="dom-console-debug"></span>

<ol>
	<li>
`Logger$A( `debug^l, %data )
を遂行する
◎
Perform Logger("debug", data).
</li>
</ol>



			</section>
			<section id="error">
<h4>1.1.5. `error(...data)^m</h4>
<span id="error-data"></span><span id="dom-console-error"></span>

<ol>
	<li>
`Logger$A( `error^l, %data )
を遂行する
◎
Perform Logger("error", data).
</li>
</ol>



			</section>
			<section id="info">
<h4>1.1.6. `info(...data)^m</h4>
<span id="info-data"></span><span id="dom-console-info"></span>

<ol>
	<li>
`Logger$A( `info^l, %data )
を遂行する
◎
Perform Logger("info", data).
</li>
</ol>



			</section>
			<section id="log">
<h4>1.1.7. `log(...data)^m</h4>
<span id="log-data"></span><span id="dom-console-log"></span>

<ol>
	<li>
`Logger$A( `log^l, %data )
を遂行する
◎
Perform Logger("log", data).
</li>
</ol>



			</section>
			<section id="table">
<h4>1.1.8. `table(tabularData, properties)^m</h4>
<span id="table-tabulardata-properties"></span>
<span id="dom-console-table"></span>

<p>
~tableを構築しようと試行した上で， %logLevel `log^l の下で~logする
— ~tableの各列は %tabularData の各~propからなり（または %properties を利用する），各行は %tabularData からなる。
表構造として構文解析できなかった場合、単に引数を~logすることに~fall-backする。
◎
Try to construct a table with the columns of the properties of tabularData (or use properties) and rows of tabularData and log it with a logLevel of "log". Fall back to just logging the argument if it can’t be parsed as tabular.
</p>


<p class="XXX">
未策定
— これには良い~algoが必要になる。
◎
TODO: This will need a good algorithm.
</p>

			</section>
			<section id="trace">
<h4>1.1.9. `trace(...data)^m</h4>
<span id="trace-data"></span>
<span id="dom-console-trace"></span>

<ol>
	<li>
%trace ~LET 実装に特有の, 何らかの, 対話的にもなり得る，［
この~methodを~callした所からの~callstack
］の表現
◎
Let trace be some implementation-specific, potentially-interactive representation of the callstack from where this method was called.
</li>
	<li>
任意選択で
⇒
%trace 用の~labelとして［
`Formatter$A( %data ) の結果
］を統合する
◎
Optionally, let formattedData be the result of Formatter(data), and incorporate formattedData as a label for trace.
</li>
	<li>
`Printer$A( `trace^l, « %trace » )
を遂行する
◎
Perform Printer("trace", « trace »).
</li>
</ol>


<p class="note">注記：
~stack-trace内に~printされる関数の識別子は、実装に依存する。
それはまた， `new Error().stack^c 内に見られるものと同じ識別子になることは保証されない。
◎
The identifier of a function printed in a stack trace is implementation-dependant. It is also not guaranteed to be the same identifier that would be seen in new Error().stack.
</p>


			</section>
			<section id="warn">
<h4>1.1.10. `warn(...data)^m</h4>
<span id="warn-data"></span>
<span id="dom-console-warn"></span>

<ol>
	<li>
`Logger$A( `warn^l, %data )
を遂行する
◎
Perform Logger("warn", data).
</li>
</ol>



			</section>
			<section id="dir">
<h4>1.1.11. `dir(item, options)^m</h4>

<ol>
	<li>
%object ~LET %item に`汎用~JS~obj整形$を適用した結果
◎
Let object be item with generic JavaScript object formatting applied.
</li>
	<li>
`Printer$A( `dir^l, « %object », %options )
を遂行する
◎
Perform Printer("dir", « object », options).
</li>
</ol>

			</section>
			<section id="dirxml">
<h4>1.1.12. `dirxml(...data)^m</h4>

<ol>
	<li>
%finalList ~LET 新たな空`~list$
◎
Let finalList be a new list, initially empty.
</li>
	<li>
<p>
%data 内の~EACH( %item ) に対し：
◎
For each item of data:
</p>
		<ol>
			<li>
%変換-済み ~LET 
%item の~DOM木~表現が可能ならば それ ／
~ELSE_ %item に`最適に有用な整形$を適用した結果
◎
Let converted be a DOM tree representation of item if possible; otherwise let converted be item with optimally useful formatting applied.
</li>
	<li>
%finalList に %変換-済み を付加する
◎
Append converted to finalList.
</li>
		</ol>
	</li>
	<li>
`Logger$A( `dirxml^l, %finalList )
を遂行する
◎
Perform Logger("dirxml", finalList).
</li>
</ol>



			</section>
		</section>
		<section id="grouping">
<h3 title="Grouping methods">1.2. ~group分け~method</h3>

<p>
`~group@
は、実装に特有の, 対話的にもなり得る, 親より字下げ~levelが 1 つ深い, 出力~用の~viewであり、
`Printer$A の~callにより生産される。
各 `console$I 名前空間~objには、
`~group~stack@
が結付けられる
— それは、`~stack$であり，初期~時には空とする。
`~group~stack$内の最後の`~group$のみが `Printer$A の~callにより生産される出力を~hostすることになる。
◎
A group is an implementation-specific, potentially-interactive view for output produced by calls to Printer, with one further level of indentation than its parent. Each console namespace object has an associated group stack, which is a stack, initially empty. Only the last group in a group stack will host output produced by calls to Printer.
</p>



			<section id="group">
<h4>1.2.1. `group(...data)^m</h4>
<span id="group-data"></span>
<span id="dom-console-group"></span>

<ol>
	<li>
%~group ~LET 新たな`~group$
◎
Let group be a new group.
</li>
	<li>
%~group~label ~LET ［
%data は`空$でないならば `Formatter$A( %data ) の結果 ／
~ELSE_ 実装により選ばれる［
`~group$を表現する~label
］］
◎
If data is not empty, let groupLabel be the result of Formatter(data). Otherwise, let groupLabel be an implementation-chosen label representing a group.
</li>
	<li>
%~group~label を %~group 用の~labelとして統合する
◎
Incorporate groupLabel as a label for group.
</li>
	<li>
任意選択で
⇒
~IF［
環境は対話的~groupを~supportする
］
⇒
%~group は既定で展開されるべきである
◎
Optionally, if the environment supports interactive groups, group should be expanded by default.
</li>
	<li>
`Printer$A( `group^l, « %~group »)
を遂行する
◎
Perform Printer("group", « group »).
</li>
	<li>
適切な`~group~stack$に %~group を`~push$する
◎
Push group onto the appropriate group stack.
</li>
</ol>

			</section>
			<section id="groupcollapsed">
<h4>1.2.2. `groupCollapsed(...data)^m</h4>
<span id="groupcollapsed-data"></span>
<span id="dom-console-groupcollapsed"></span>

<ol>
	<li>
%~group ~LET 新たな`~group$
◎
Let group be a new group.
</li>
	<li>
%~group~label ~LET ［
%data は空でないならば `Formatter$A( %data ) の結果 ／
~ELSE_ 実装により選ばれる［
`~group$を表現する~label
］］
◎
If data is not empty, let groupLabel be the result of Formatter(data). Otherwise, let groupLabel be an implementation-chosen label representing a group.
</li>
	<li>
%~group~label を %~group 用の~labelとして統合する
◎
Incorporate groupLabel as a label for group.
</li>
	<li>
任意選択で
⇒
~IF［
環境は対話的~groupを~supportする
］
⇒
%~group は既定で畳まれるべきである
◎
Optionally, if the environment supports interactive groups, group should be collapsed by default.
</li>
	<li>
`Printer$A( `groupCollapsed^l, « %~group »)
を遂行する
◎
Perform Printer("groupCollapsed", « group »).
</li>
	<li>
適切な`~group~stack$に %~group を`~push$する
◎
Push group onto the appropriate group stack.
</li>
</ol>

			</section>
			<section id="groupend">
<h4>1.2.3. `groupEnd()^m</h4>
<span id="dom-console-groupend"></span>

<ol>
	<li>
`~group~stack$から`~pop$する
◎
Pop the last group from the group stack.
</li>
</ol>

			</section>
		</section>
		<section id="timing">
<h3 title="Timing methods">1.3. 計時~method</h3>


<p>
各 `console$I 名前空間~objには
`~timer~table@
が結付けられる。
それは、各~entryが［
`文字列$→時刻
］として与えられる`~map$であり，初期~時には空とする。
◎
Each console namespace object has an associated timer table, which is a map of strings to times, initially empty.
</p>



			<section id="time">
<h4>1.3.1. `time(label)^m</h4>
<span id="time-label"></span>
<span id="dom-console-time"></span>

<ol>
	<li>
%~timer~table ~LET 此れの`~timer~table$
◎
↓</li>
	<li>
<p>
~IF［
%~timer~table[ %label ] ~NEQ ε
］：
</p>
		<ol>
			<li>
任意選択で
⇒
［
~label %label を伴う~timerは，すでに開始されている
］ことを指示する警告を，~consoleに報告する
</li>
			<li>
~RET
</li>
		</ol>
◎
If the associated timer table contains an entry with key label, return, optionally reporting a warning to the console indicating that a timer with label label has already been started.
</li>
	<li>
~ELSE
⇒
%~timer~table[ %label ] ~SET 現在の時刻
◎
Otherwise, set the value of the entry with key label in the associated timer table to the current time.
</li>
</ol>

			</section>
			<section id="timeend">
<h4>1.3.2. `timeEnd(label)^m</h4>
<span id="timeend-label"></span>
<span id="dom-console-timeend"></span>

<ol>
	<li>
%~timer~table ~LET 此れの`~timer~table$
◎
↓</li>
	<li>
%開始-時刻 ~LET %~timer~table[ %label ]
◎
Let startTime be the result of getting the value of the entry with key label in the associated timer table.
</li>
	<li>
<p>
%時間長 ~LET 実装により定義される整形-による，
( 現在の時刻 − %開始-時刻 ) を表現している文字列
◎
Let duration be a string representing the difference between the current time and startTime, in an implementation-defined format.
</p>

<p class="example" id="duration-string-example">
`4650^l,
`4650.69 ms^l,
`5 seconds^l,
`00:05^l 
は、どれも 4650.69 ミリ秒間を表示する 適度な仕方である。
◎
"4650", "4650.69 ms", "5 seconds", and "00:05" are all reasonable ways of displaying a 4650.69 ms duration.
</p>
	</li>
	<li>
%concat ~LET 次を順に連結した結果
⇒＃
%label,
`003A^U (:),
`0020^U ~SPACE,
%時間長
◎
Let concat be the concatenation of label, U+003A (:), U+0020 SPACE, and duration.
</li>
	<li>
`Logger$A( `timeEnd^l, « %concat » )
を遂行する
◎
Perform Logger("timeEnd", « concat »).
</li>
</ol>



			</section>
		</section>
	</section>
	<section id="supporting-ops">
<h2 title="Supporting abstract operations">2. 抽象~演算の~support法</h2>

		<section id="logger">
<h3>2.1. `Logger^A(%logLevel, %args)</h3>

<p>
`Logger^A 演算は、~log~levelおよび，他の引数からなる`~list$を受容する。
その主な出力を成すのは、実装により定義される，結果を~consoleへ~printする副作用である。
この仕様は、そうする間に整形-指定子をどう処理するかについて述べる。
◎
The logger operation accepts a log level and a list of other arguments. Its main output is the implementation-defined side effect of printing the result to the console. This specification describes how it processes format specifiers while doing so.
</p>

<ol>
	<li>
~IF［
%args は`空$である
］
⇒
~RET
◎
If args is empty, return.
</li>
	<li>
%first ~LET %args[0]
◎
Let first be args[0].
</li>
	<li>
%rest ~LET %args 内の %first に後続するすべての要素からなる`~list$
◎
Let rest be all elements following first in args.
</li>
	<li>
~IF［
%rest は`空$である
］
⇒＃
`Printer$A( %logLevel, « %first »） を遂行する；
~RET
◎
If rest is empty, perform Printer(logLevel, « first ») and return.
</li>
	<li>
~IF［
%first は整形-指定子を包含しない
］
⇒
`Printer$A( %logLevel, %args )
を遂行する
◎
If first does not contain any format specifiers, perform Printer(logLevel, args).
</li>
	<li>
~ELSE
⇒
`Printer$A( %logLevel, `Formatter$A( %args ))
を遂行する
◎
Otherwise, perform Printer(logLevel, Formatter(args)).
</li>
	<li>
~RET `undefined^jv
【 ~RET と ~RET `undefined^jv の違いは？】
◎
Return undefined.
</li>
</ol>


<div class="note">

<p>注記：
~algoが返る前に~printされることが重要である。
多くの開発者~consoleは、その中に手入力した最後の演算の結果を~printする。
そのような~consoleにおいては、開発者が
`console.log("hello!")^c
と手入力したとき，先ず `hello!^l,
次に `console.log^c ~callの返り値 `undefined^jv を~printすることになる。
◎
It’s important that the printing occurs before returning from the algorithm. Many developer consoles print the result of the last operation entered into them. In such consoles, when a developer enters console.log("hello!"), this will first print "hello!", then the undefined return value from the console.log call.
</p>

<figure>`print-before-returning^dgm
<figcaption>
返る前に~printし終えたことを指示している図。
◎
Indicating that printing is done before return
</figcaption></figure>
</div>



		</section>
		<section id="formatter">
<h3>2.2. `Formatter^A(%args)</h3>

<p>
`Formatter^A 演算は、提供された最初の引数を，後続の引数を用いて整形しようと試行する。
それは、最初の引数~内の整形~指定子が尽きるか, 他の引数が尽きるまで，入力を整形しようと試行した上で、~print用に相応しい何個かの~objからなる`~list$を返す：
◎
The formatter operation tries to format the first argument provided, using the other arguments. It will try to format the input until no formatting specifiers are left in the first argument, or no more arguments are left. It returns a list of objects suitable for printing.
</p>

<ol>
	<li>
%target ~LET %args の最初の要素
◎
Let target be the first element of args.
</li>
	<li>
%current ~LET %args の 2 個目の要素
◎
Let current be the second element of args.
</li>
	<li>
<p>
%指定子 ~LET %target 内の未処理の整形-指定子のうち，最初に現れるもの
◎
Find the first possible format specifier specifier, from the left to the right in target.
</p>

<p class="trans-note">【
整形-指定子がない場合や %args が 1 個の要素のみからなる場合にどうなるか定義されていない。
この~algoの末尾にある検査は、先頭に移動されるべき？
】【
“未処理の” はこの訳による追加。
さもなければ、同じ整形-指定子を何度も繰り返すことにもなり得るので。
】</p>


		<ol>
			<li>
<p>
%変換-済み ~LET %指定子 に応じて，次で与えられる値：
</p>
				<dl class="switch">
					<dt>`%s^l</dt>
					<dd>
`ToString$A( %current )
◎
If specifier is %s, let converted be the result of ToString(current).
</dd>

					<dt>`%d^l</dt>
					<dt>`%i^l</dt>
					<dd>
`parseInt$jsI( %current , 10 )
◎
If specifier is %d or %i, let converted be the result of %parseInt%(current, 10).
</dd>

					<dt>`%f^l</dt>
					<dd>
`parseFloat$jsI( %current )
◎
If specifier is %f, let converted be the result of %parseFloat%(current).
</dd>

					<dt>`%o^l</dt>
					<dd>
任意選択で、 %指定子 または
⇒
%current に`最適に有用な整形$を適用した結果
◎
If specifier is %o, optionally let converted be current with optimally useful formatting applied.
</dd>

					<dt>`%O^l</dt>
					<dd>
任意選択で、 %指定子 または
⇒
%current に`汎用~JS~obj整形$を適用した結果
◎
If specifier is %O, optionally let converted be current with generic JavaScript object formatting applied.
</dd>

					<dt>`%c^l</dt>
					<dd class="XXX">
（未策定）
◎
TODO: process %c
</dd>
				</dl>
			</li>
			<li>
%target 内の %指定子 を %変換-済み に置換する
【 %変換-済み 内にも整形-指定子があった場合、その指定子も “未処理” と見なされるのか？】
◎
If any of the previous steps set converted, replace specifier in target with converted.
</li>
			<li>
%結果 ~LET %target, および %args 内の 3 個目~以降の要素からなる`~list$
◎
Let result be a list containing target together with the elements of args starting from the third onward.
</li>
		</ol>
	</li>
	<li>
~IF［
%target 内に未処理の整形-指定子はない
］
⇒
~RET %結果
◎
If target does not have any format specifiers left, return result.
</li>
	<li>
~IF［
%結果 の`~size$ ~EQ 1
］
⇒
~RET %結果
◎
If result’s size is 1, return result.
</li>
	<li>
~RET `Formatter$A( %結果 )
◎
Return Formatter(result).
</li>
</ol>


			<section id="formatting-specifiers">
<h4 title="Summary of formatting specifiers">2.2.1. 各種 整形~指定子の要約</h4>

<p>
上の~algoにて処理される整形-指定子たちを，以下に要約する（参考）
— 表~内の “要素” は、指定子を代用する要素を指すとする：
◎
The following is an informative summary of the format specifiers processed by the above algorithm.
</p>

<table><thead>
<tr><th>指定子
</th><th>目的
</th><th>型~変換
</th></tr></thead><tbody>

<tr><td>`%s^l
</td><td>
要素は 文字列に変換される
◎
Element which substitutes is converted to a string
</td><td>`ToString$A(%element)
</td></tr>

<tr><td>`%d^l ／ `%i^l
</td><td>
要素は 整数に変換される
◎
Element which substitutes is converted to an integer
</td><td>`parseInt$jsI(%element, 10)
</td></tr>

<tr><td>`%f^l
</td><td>
要素は 浮動小数点数に変換される
◎
Element which substitutes is converted to a float
</td><td>`parseFloat$jsI(%element, 10)
</td></tr>

<tr><td>`%o^l
</td><td>
要素は `最適に有用な整形$で表示される
◎
Element is displayed with optimally useful formatting
</td><td>n/a
</td></tr>

<tr><td>`%O^l
</td><td>
要素は `汎用~JS~obj整形$で表示される
◎
Element is displayed with generic JavaScript object formatting
</td><td>n/a
</td></tr>

<tr><td>`%c^l
</td><td>
提供される~CSSを要素に適用する
◎
Applies provided CSS
</td><td>n/a
</td></tr></tbody></table>


			</section>
		</section>
		<section id="printer">
<h3>2.3. `Printer^A(%logLevel, %args[, %options])</h3>


<p>
`Printer^A 演算は、実装により定義され，［
厳しさを指示する~log~level,
~printする何個かの引数からなる~List,
実装に特有の整形~optionを与える~obj（省略可）
］を受容する。
%args 内に現れる要素は、次のうちいずれかになる：
◎
The printer operation is implementation-defined. It accepts a log level indicating severity, a List of arguments to print, and an optional object of implementation-specific formatting options. Elements appearing in args will be one of the following:
</p>

<ul>
	<li>
~JS~obj
— 型は問わず
◎
JavaScript objects of any type.
</li>
	<li>
~stack-traceや`~group$など，~printできるものを成すような、実装に特有の表現
◎
Implementation-specific representations of printable things such as a stack trace or group.
</li>
	<li>
`汎用~JS~obj整形$を適用した結果の~obj
◎
Objects with either generic JavaScript object formatting＼
</li>
	<li>
`最適に有用な整形$を適用した結果の~obj
◎
or optimally useful formatting applied.
</li>
</ul>

<p>
%options ~objが渡され, かつ［
`undefined^jv ／ `null^jv
］でない場合、実装は，
%args 内の各 要素に 自身に特有の整形を適用するときに %options を利用して~MAY。
◎
If the options object is passed, and is not undefined or null, implementations may use options to apply implementation-specific formatting to the elements in args.
</p>


<p>
実装が %args をどう~printするかは，実装に委ねられるが、実装は， 開発者の期待に沿うよう，~objを~spaceかそれに類する何かで区切るべきである。
◎
How the implementation prints args is up to the implementation, but implementations should separate the objects by a space or something similar, as that has become a developer expectation.
</p>

<p>
`Printer^A 演算が~callされる時点では、すべての整形-指定子は織り込み済みであり，［
整形-指定子により消費されるものと意味された，引数
］は %args 内に残されないことになる。
実装の仕事は、単純に~Listを~printすることである。
`Printer^A の~callにより生産される出力が現れるのは、適切な`~group~stack$が空でなければ その最後の`~group$の中に限られ，他の場合は~console内の他所になるべきである。
◎
By the time the printer operation is called, all format specifiers will have been taken into account, and any arguments that are meant to be consumed by format specifiers will not be present in args. The implementation’s job is simply to print the List. The output produced by calls to Printer should appear only within the last group on the appropriate group stack if the group stack is not empty, or elsewhere in the console otherwise.
</p>


<p>
`Printer^A 演算の~call時に，~consoleが開かれていない場合、実装は ~messageを~bufferするべきである（概して，少なくとも何 100 個かは）
— それらを，実装により選ばれる上限までの未来に示すため。
◎
If the console is not open when the printer operation is called, implementations should buffer messages to show them in the future up to an implementation-chosen limit (typically on the order of at least 100).
</p>



			<section id="loglevel-severity">
<h4 title="Indicating logLevel severity">2.3.1. ~logの厳しさ~levelの指示-法</h4>

<p>
`console$I の各~methodは、それぞれに一意な値を［
`Printer^A の~call時の %logLevel ~parameter
］に利用する
— 実装は、各~methodごとに，~printする~messageを~custom化できるようになる。
しかしながら、一連の~methodを 次の表に要約される 4 ~groupに分けて，同じ~groupに属する出力は同様に扱うことも、共通的に実施されている：
◎
Each console method uses a unique value for the logLevel parameter when calling Printer, allowing implementations to customize each printed message depending on the method from which it originated. However, it is common practice to group together certain methods and treat their output similarly, in four broad categories. This table summarizes these common groupings:
</p>

<table><thead>
<tr><th>~group◎ Grouping
</th><th>`console$I ~method
</th><th>概要◎ Description
</th></tr></thead><tbody>

<tr><td>log
</td><td> `log()$m, `trace()$m, `dir()$m, `dirxml()$m, `group()$m, `groupCollapsed()$m, `debug()$m
</td><td>
汎用の~log
◎
A generic log
</td></tr>

<tr><td>info
</td><td>`count()$m, `info()$m, `timeEnd()$m
</td><td>
参考の~log
◎
An informative log
</td></tr>

<tr><td>warn
</td><td>`warn()$m
</td><td>
~messageにより指示される何かを利用者~向けに警告する ~log
◎
A log warning the user of something indicated by the message
</td></tr>

<tr><td>error
</td><td>`error()$m, `assert()$m
</td><td>
利用者~向けに~errorを指示する~log
◎
A log indicating an error to the user
</td></tr></tbody></table>


<p>
この~group分けに意味されるのは，共通的な実施を文書~化することであり、実装が，各~method用に特別な挙動
— 次の例に見られるような —
を提供しないよう拘束することではない：
◎
These groupings are meant to document common practices, and do not constrain implementations from providing special behavior for each method, as in the following examples:
</p>

<div class="example" id="timeEnd-formatting">

<p>
ここに見られる ある実装は、 `timeEnd()$m への~callにより生産される出力を青くすることにした
— `info()$m による出力は より中立的な色のままにしつつ。
◎
Here you can see one implementation chose to make output produced by calls to timeEnd() blue, while leaving info() a more neutral color.
</p>

<figure>`timeEnd-formatting^dgm
<figcaption>
`timeEnd()^m と `info()^m による整形の相違を示す例
◎
A demonstration of timeEnd and info formatting differences
</figcaption></figure>

</div>

<div class="example" id="count-output">

<p>
`count()$m の~callは、常に，新たな出力を~printするとは限らず，以前に出力した計数を更新することもある。
◎
Calls to count() might not always print new output, but instead could update previously-output counts.
</p>

<figure>`edge-Count^dgm
<figcaption>
計数の挙動を示す例
◎
A demonstration of count behavior
</figcaption></figure>

</div>



			</section>
			<section id="printer-ux-innovation">
<h4 title="Printer user experience innovation">2.3.2. `Printer^A ~UX新機軸</h4>


<p>
`Printer$A は実装により定義されるので、その実装には，~UX（利用者~体験）における新機軸も共通的に見られる。
~UXの増補として，例えば次のものが挙げられるが、これらに限られない：
◎
Since Printer is implementation-defined, it is common to see UX innovations in its implementations. The following is a non-exhaustive list of potential UX enhancements:
</p>

<ul>
	<li>
<p>
~spamを防止するため、互いに一致する出力は一つに集約する。
◎
De-duplication of identical output to prevent spam.
</p>

<div class="example" id="dedupe-example">

<p>
この例の実装は、互いに一致する複数の~messageを一括するのみならず，何個の~messageが一緒に一括されたかも提供する。
◎
In this example, the implementation not only batches multiple identical messages, but also provides the number of messages that have been batched together.
</p>

<figure>`dedupe^dgm
<figcaption>
~console~messageの集約を示す例
◎
A demonstration of console message de-duplication
</figcaption></figure>
</div>

	</li>
	<li>
<p>
利用者が ~messageを~logの厳しさ~levelで絞込めるようにするための、脇に置かれる余分の~UI。
◎
Extra UI off to the side allowing the user to filter messages by log level severity.
</p>


<div class="example" id="severity-filter-example">
<figure>`severity-filter^dgm
<figcaption></figcaption></figure>
</div>

	</li>
	<li>
`~timer~table$, `~group~stack$, その他の内部に保守される~dataの現在の状態を指示するような、脇に置かれる余分の~UI。
◎
Extra UI off to the side indicating the current state of the timer table, group stack, or other internally maintained data.
</li>
	<li>
~consoleのある部位を明滅して，利用者に何か重要なことを~alertする。
◎
Flashing portions of the console to alert the user of something important.
</li>
</ul>


			</section>
			<section id="object-formats">
<h4 title="Common object formats">2.3.3. 共通的な~obj整形-</h4>

<p>
~objは概して、その文脈に相応しく整形されて~printされることになる。
この節では、~objがその文脈にて最も有用に整形されるような，共通的な仕方を述べる。
この節に述べる整形は、［
最終的に `Printer$A に渡されることになる，実装に特有の~obj表現
］に適用されることに注意。
整形による実際の副作用は，そこで見えることになる。
◎
Typically objects will be printed in a format that is suitable for their context. This section describes common ways in which objects are formatted to be most useful in their context. It should be noted that the formatting described in this section is applied to implementation-specific object representations that will eventually be passed into Printer, where the actual side effect of formatting will be seen.
</p>

<p>
`汎用~JS~obj整形@
を伴う~objは、展開-可能にもなり得る，汎用~JS~objの表現である。
`最適に有用な整形@
を伴う~objは、最大に有用かつ参考と判定された~objの，対話的にもなり得る, 実装に特有の表現である。
◎
An object with generic JavaScript object formatting is a potentially expandable representation of a generic JavaScript object. An object with optimally useful formatting is an implementation-specific, potentially-interactive representation of an object judged to be maximally useful and informative.
</p>

			</section>
			<section id="nodejs-printer">
<h4 title="Example printer in Node.js">2.3.4. 例： Node.js における `Printer^A</h4>

<div class="example" id="nodejs-printer-example">

<p>
Node.js ~platform上で `Printer^A 演算を実装する最も単純な仕方は、それまでに整形された引数たちを~spaceで区切って連結した結果の出力を
`stdout^c ／ `stderr^c
に書込むことである。
◎
The simplest way to implement the printer operation on the Node.js platform is to join the previously formatted arguments separated by a space and write the output to stdout or stderr.
</p>

<p>
`ECMASCRIPT$r を用いる Node.js における実装~例：
◎
Example implementation in Node.js using [ECMASCRIPT]:
</p>


<pre>
const %util = require('util');

function print(%logLevel, ...%args) {
  const %message = %util.format(...%args);

  if (%logLevel === 'error') {
    process.stderr.write(%message + '\n');
  } else if (%logLevel === 'log' || %logLevel === 'info' || %logLevel === 'warn') {
    process.stdout.write(%message + '\n');
  }
}
</pre>


<p>
ここでの `util.format^c 関数により たくさんの作業が行われる。
それは、入子の~objを文字列化して，文字列でない引数は読める文字列~versionに変換する。
例えば `undefined^jv は 文字列 `undefined^l に,  `false^jv は `false^l になる：
◎
Here a lot of the work is done by the util.format function. It stringifies nested objects, and converts non-string arguments into a readable string version, e.g. undefined becomes the string "undefined" and false becomes "false":
</p>


<pre>
print('log', 'duck', [{foo: 'bar'}]);     // prints: `duck [ { foo: 'bar' } ]\n^c on stdout
print('log', 'duck', false);              // prints: `duck false\n^c on stdout
print('log', 'duck', undefined);          // prints: `duck undefined\n^c on stdout
</pre>

</div>



			</section>
		</section>
	</section>

</main></div><!-- MAIN -->

	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p lang="en-x-a0">
The editors would like to thank
Boris Zbarsky,
Brent S.A. Cowgill,
Brian Grinstead,
Corey Farwell,
Ian Kilpatrick,
Jeff Carpenter,
Joseph Pecoraro,
Justin Woo,
Noah Bass,
Paul Irish,
Raphaël, and
Victor Costan
for their contributions to this specification. You are awesome!
</p>

<p lang="en-x-a0">
This standard is written by <a href="https://terinstock.com">Terin Stock</a> (<a href="mailto:terin@terinstock.com">terin@terinstock.com</a>), <a href="http://kowalski.gd">Robert Kowalski</a> (<a href="mailto:rok@kowalski.gd">rok@kowalski.gd</a>), and <a href="https://domfarolino.com">Dominic Farolino</a> (<a href="mailto:domfarolino@gmail.com">domfarolino@gmail.com</a>)
with major help from <a href="https://domenic.me/">Domenic Denicola</a> (<a href="https://google.com">Google</a>, <a href="mailto:d@domenic.me">d@domenic.me</a>).</p>

<p lang="en-x-a0">
Copyright © 2018 WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.
</p>

	</section>
