<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Console Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	Util.switchWordsInit({
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		toc_main: 'MAIN0',
		generate: expand
	});
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return `<var>${match.slice(1)}</var>`
}

let text = key;
let href = '';

switch(klass){
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'jI':
	text = `%${key}%`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2024-12-16
trans_update:2024-11-01
source_checked:241216
spec_status:LS
original_url:https://console.spec.whatwg.org/
ref_id_prefix:refs
copyright:,whatwg
trans_1st_pub:2017-10-02

●●class_map
E:error
A:abstract
jv:js-value
jt:js-type
jI:js-intrinsic
U:code-point

●●tag_map
I:code
m:code
E:code
U:span
jv:code
jt:code
jI:code
A:span
c:code
i:i


●●mdn_urls

namespacedef-console:API/Console
assert:API/Console/assert
clear:API/Console/clear
count:API/Console/count
countreset:API/Console/countReset
debug:API/Console/debug
dir:API/Console/dir
dirxml:API/Console/dirxml
error:API/Console/error
group:API/Console/group
groupcollapsed:API/Console/groupCollapsed
groupend:API/Console/groupEnd
info:API/Console/info
log:API/Console/log
table:API/Console/table
time:API/Console/time
timeend:API/Console/timeEnd
timelog:API/Console/timeLog
trace:API/Console/trace
warn:API/Console/warn

●●original_id_map
	console-namespace:console-interface
	assert:assert-condition-data
	assert:dom-console-assert
	clear:dom-console-clear
	debug:debug-data
	debug:dom-console-debug
	error:error-data
	error:dom-console-error
	info:info-data
	info:dom-console-info
	log:log-data
	log:dom-console-log
	table:table-tabulardata-properties
	table:dom-console-table
	trace:trace-data
	trace:dom-console-trace
	warn:warn-data
	warn:dom-console-warn
	count:count-label
	count:dom-console-count
	group:group-data
	group:dom-console-group
	groupcollapsed:groupcollapsed-data
	groupcollapsed:dom-console-groupcollapsed
	groupend:dom-console-groupend
	time:time-label
	time:dom-console-time
	timeend:dom-console-timeend

●●link_map

	●JS

jI.ObjectPrototype:~TC39#sec-properties-of-the-object-prototype-object
jI.parseFloat:~TC39#sec-parsefloat-string
jI.parseInt:~TC39#sec-parseint-string-radix
jI.String:~TC39#sec-string-constructor

jt.String:~TC39#sec-ecmascript-language-types-string-type
jt.Symbol:~TC39#sec-ecmascript-language-types-symbol-type

A.ObjectCreate:~TC39#sec-objectcreate
A.ToString:~TC39#sec-tostring

A.Call:~TC39#sec-call
A.Formatter:#formatter
A.Logger:#logger
A.Printer:#printer

	●IDL

Exposed:~WEBIDLjs#Exposed

undefined:~WEBIDL#idl-undefined
any:~WEBID#idl-any
boolean:~WEBIDL#idl-boolean
object:~WEBIDL#idl-object
DOMString:~WEBIDL#idl-DOMString
sequence:~WEBIDL#idl-sequence


I.console:#namespacedef-console
m.assert:#assert
m.clear:#clear
m.count:#count
m.countReset:#countreset
m.debug:#debug
m.dir:#dir
m.dirxml:#dirxml
m.error:#error
m.group:#group
m.groupCollapsed:#groupcollapsed
m.groupEnd:#groupend
m.info:#info
m.log:#log
m.table:#table
m.time:#time
m.timeEnd:#timeend
m.timeLog:#timelog
m.trace:#trace
m.warn:#warn

	●用語
計数~map:#count-map

~group~stack:#group-stack
~group:#concept-group
汎用~JS~objの整形:#generic-javascript-object-formatting
最適に有用な整形:#optimally-useful-formatting
~timer~table:#timer-table
~consoleに警告を報告する:#report-a-warning-to-the-console

~log~level:#loglevel-severity

	●用語（外部
実装定義:~INFRA#implementation-defined
文字列:~INFRA#string
~list:~INFRA#list
~size:~INFRA#list-size
空:~INFRA#list-is-empty
空にする:~INFRA#list-empty
除去する:~INFRA#list-remove
付加する:~INFRA#list-append
前付加する:~INFRA#list-prepend
	~EACH:~INFRA#list-iterate

~stack:~INFRA#stack
~pop:~INFRA#stack-pop
~push:~INFRA#stack-push

~map:~INFRA#ordered-map
	~SET :~INFRA#map-set
	~SET ε:~INFRA#map-remove
	~NEQ ε:~INFRA#map-exists
	[]:~INFRA#map-get
連結する:~INFRA#string-concatenate

名前空間~obj:~WEBIDLjs#dfn-namespace-object

r.ECMASCRIPT:#biblio-ecmascript

	https://github.com/whatwg/console/issues

_acks1:#_acks1
_ipr1:#_ipr1

●●images
＠console/
print-before-returning｜｜｜.webp
timeEnd-formatting｜｜｜.webp
edge-Count｜｜｜.webp
dedupe｜｜｜.webp
severity-filter｜｜｜.webp

●●words_table1

●●words_table

	●data型／JS/DOM
List:
	status::::ステータス

	●console
UX:
callstack::::callスタック
trace::::トレース
console::::
	コンソール
	log用の:logging
timer::::タイマー
severity:
	報告-法:reporting
厳しさ:severity::~
警告-:warn::~
警告:warning::~
浮動小数点数:float::~
	時点:time
計数:count::~::カウント
	計数~用:counting
時間長:duration::~

	main::::
	集約:de-duplication
	ミリ秒間:ms duration
	文字列でない:non-string
	文字列~化:stringify
	group分け

	●UI／呈示／整形
print:
書式:format::~
	整形-済み~data:formattedData
	各列:columns:
	各行:rows:
表構造:tabular:::テーブル構造
展開-:expand::~
畳まれ:collapseされ::~
字下げ:indentation:~
部位:portion:~
alert:
絞込む:filterする::絞り込む
一括-:batch::~
spam::::スパム
明滅-:flash:~
中立的:neutral:~
開かれ:openされ:~
	脇に置かれる:off to the side
	青く:blue
	読める:readable

	●変数（algo
連結結果:concat:~
	%連結結果:concat
	%current:current
	%最終-~list:finalList
	%先頭:first
	%~item:item
	%~map:map
	%~obj:object
	%残り:rest
	%~target:target
	%~trace:trace
	%~group:group
	%~group~label:groupLabel
	%~message:message
	%~timer~table:timerTable
	%~timer~table:-
	%先頭:first
	%変換-済み:converted
	%指定子:specifier
	%時間長:duration
	%結果:result
	%要素:element
	%記述:description
	%警告:warning
	%開始~時刻:startTime


	●仕様
	限られない:non-exhaustive
参考:informative:~
	規範的でない:informative
参考の:informativeな:~
新機軸:innovation:~
仕事:job:~
計画:plan:~
計画:plan::~
建設的:constructive:~
最大限:maximal:~
汎用的:generical:~
選ばれ:chosen:~
選ぶ:choose:~
定義な:-definedな:~
判定-:judge:~
増補:enhancement:~
追跡器:tracker:~

	委ねられる:up to
	にもなり得る:potential
	易くする:make it easier
	ことにした:chose to make
	何もしない:do nothing
	見られ:seen
	~debug時の:debugging

	●未分類
SPACE:
bootstrap:
上限:limit:~
中間的:intermediate:~
連結-:concatenate:~
	連結-:join／:concatenation
書込む:writeする::書き込む
代入-:substitute::~
給-:supply:~
埋める:fillする:~
余分な:extra:追加の

	渡-:pass
	-:find
	存続する限り:throughout the life of
	:kind
	-:order
	please
	:logLevel
	:TODO
	-:together

	`Printer^A :printer
	:become
	~most
	~noted
	型~変換:Type Conversion
	各~methodごとに:depending on the method from which it originated
	これらの:certain
	に分けて:together
	3 個目~以降の:starting from the third onward
	後続の:other
	に類する:something similar
	以前:previous
	残され／尽きる:left
	現れる順に:left to the right
	後続する:following
	深い:further
	先ず:first
	早期の:early
	広い:broad
	のまま:while leaving
	最終的:eventual
	単に:just
	所:where
	たくさんの:a lot of
	それまでに:previously
	少なくとも何百個か:on the order of at least 100
	主な:main


●●ref_normative

[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://console.spec.whatwg.org/">Console Standard</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/console">GitHub whatwg/console</a> (<a href="https://github.com/whatwg/console/issues/new/choose">new issue</a>, <a href="https://github.com/whatwg/console/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	https://github.com/whatwg/console/commits

	<a href="https://console.spec.whatwg.org/commit-snapshots/6960f44889f8dc9346e5a0e8981af22d5104df24/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/consolelog">@consolelog</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/console">web-platform-tests console/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/console">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>


</head>

<body>
<header>

<a href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZwoJeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgoJdmlld0JveD0iMCAwIDEwODAgMTA4MCIKCWZpbGw9IiMzYzc5MGEiCglzdHJva2U9IiMzYzc5MGEiCj4KCjxjaXJjbGUgc3Ryb2tlLXdpZHRoPSIxMDgiIGN4PSI1NDAiIGN5PSI1NDAiIHI9IjQ4NiIgZmlsbD0iI2ZmZiIvPgo8Y2lyY2xlIGN4PSI2MjAiIGN5PSI3MDAiIHI9IjMwIi8+CjxjaXJjbGUgY3g9IjcwMCIgY3k9IjcwMCIgcj0iMzAiLz4KPGNpcmNsZSBjeD0iNzgwIiBjeT0iNzAwIiByPSIzMCIvPgo8cGF0aCBkPSJNMjc4LjggNjAzLjJsMTcyLjctNzAuMi0xNzIuNi03OC44di04Mi43bDI4MS41IDE0MC45djQ3LjlsLTI4MS41IDEyNXYtODIuMXoiLz4KCjwvc3ZnPgo="
></a>

	<hgroup>
<h1>Console</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この仕様は、
~console~debug時の便宜性のための~APIを定義する。
◎
This specification defines APIs for console debugging facilities.
</p>
	</section>
	<section id="status">
◎位置付け

<p>
この仕様は、
進捗-中な早期の作業です。
より精確で互換な定義に向けて精緻化するため，~feedbackを歓迎します。
また、編集者の手による最初の仕様なので，どうかお手柔らかかつ建設的に。
◎
This specification is an early work in progress that welcomes feedback to refine toward more precise and compatible definitions. It is also the editors' first specification, so please be kind and constructive.
</p>

<p>
より論を深めたい方は、
<a href="https://github.com/whatwg/console/issues">課題~追跡器</a>に参加されたし。
◎
Please join us in the issue tracker for more discussion.
</p>

	</section>

<main id="MAIN0">

	<section id="console-namespace">
<h2 title="Namespace console">1. 名前空間 `console^I</h2>

<pre class="idl">
[`Exposed$=*]
namespace `console@I { /* <span class="comment">
が、
下の名前空間~obj要件も見よ。
◎
but see namespace object requirements below
</span> */
  // <span class="comment">~log用</span>
  `undefined$ `assert$m(optional `boolean$ %condition = false, `any$... %data);
  `undefined$ `clear$m();
  `undefined$ `debug$m(`any$... %data);
  `undefined$ `error$m(`any$... %data);
  `undefined$ `info$m(`any$... %data);
  `undefined$ `log$m(`any$... %data);
  `undefined$ `table$m(optional `any$ %tabularData, optional `sequence$&lt;`DOMString$&gt; %properties);
  `undefined$ `trace$m(`any$... %data);
  `undefined$ `warn$m(`any$... %data);
  `undefined$ `dir$m(optional `any$ %item, optional `object$? %options);
  `undefined$ `dirxml$m(`any$... %data);

  // <span class="comment">計数~用</span>
  `undefined$ `count$m(optional `DOMString$ %label = "default");
  `undefined$ `countReset$m(optional `DOMString$ %label = "default");

  // <span class="comment">~group分け</span>
  `undefined$ `group$m(`any$... %data);
  `undefined$ `groupCollapsed$m(`any$... %data);
  `undefined$ `groupEnd$m();

  // <span class="comment">計時</span>
  `undefined$ `time$m(optional `DOMString$ %label = "default");
  `undefined$ `timeLog$m(optional `DOMString$ %label = "default", `any$... %data);
  `undefined$ `timeEnd$m(optional `DOMString$ %label = "default");
};
</pre>

<p class="note">注記：
歴史的な理由から、
`console$I は小文字にされている。
◎
For historical reasons, console is lowercased.
</p>

<p class="note">注記：
開発者~consoleが［
開かれていない／存在しない
］場合でも、
`console$I は，~scriptからは［
常に，可視かつ利用-可能
］になることが重要である。
◎
It is important that console is always visible and usable to scripts, even if the developer console has not been opened or does not exist.
</p>

<p>
歴史的な~web互換性の理由から、
`console$I 用の`名前空間~obj$の `Prototype^sl は，
`ObjectPrototype$jI に代えて空な~objになるモノトスル
— `ObjectCreate$A( `ObjectPrototype$jI ) により作成されたかのように。
◎
For historical web-compatibility reasons, the namespace object for console must have as its [[Prototype]] an empty object, created as if by ObjectCreate(%ObjectPrototype%), instead of %ObjectPrototype%.
</p>

		<section id="logging">
<h3 title="Logging functions">1.1. ~log用~関数</h3>

			<section id="assert">
<h4>1.1.1. `assert(condition, ...data)^m</h4>

<ol>
	<li>
~IF［
%condition ~EQ ~T
］
⇒
~RET
◎
If condition is true, return.
</li>
	<li>
%~message ~LET 整形~指定子を伴わない文字列であって，
表明の失敗を汎用的に指示するもの
（例： `Assertion failed^l ）
◎
Let message be a string without any formatting specifiers indicating generically an assertion failure (such as "Assertion failed").
</li>
	<li>
~IF［
%data は`空$である
］
⇒
%data に %~message を`付加する$
◎
If data is empty, append message to data.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%先頭 ~LET %data[ 0 ]
◎
Let first be data[0].
</li>
			<li>
~IF［
%先頭 は `String$jt でない
］
⇒
%data に %~message を`前付加する$
◎
If first is not a String, then prepend message to data.
</li>
			<li>
~ELSE
⇒
%data[ 0 ] ~SET 次を順に`連結する$
⇒＃
%~message,
`003A^U (:),
`0020^U ~SPACE,
%先頭
◎
Otherwise:
• Let concat be the concatenation of message, U+003A (:), U+0020 SPACE, and first.
• Set data[0] to concat.
</li>
		</ol>
	</li>
	<li>
`Logger$A( `assert^l, %data )
◎
Perform Logger("assert", data).
</li>
</ol>

			</section>
			<section id="clear">
<h4>1.1.2. `clear()^m</h4>

<ol>
	<li>
適切な`~group~stack$を`空にする$
◎
Empty the appropriate group stack.
</li>
	<li>
環境にて可能なら，~consoleを~clearする（他の場合，何もしない）
◎
If possible for the environment, clear the console. (Otherwise, do nothing.)
</li>
</ol>

			</section>
			<section id="debug">
<h4>1.1.3. `debug(...data)^m</h4>

<ol>
	<li>
`Logger$A( `debug^l, %data )
◎
Perform Logger("debug", data).
</li>
</ol>

			</section>
			<section id="error">
<h4>1.1.4. `error(...data)^m</h4>

<ol>
	<li>
`Logger$A( `error^l, %data )
◎
Perform Logger("error", data).
</li>
</ol>

			</section>
			<section id="info">
<h4>1.1.5. `info(...data)^m</h4>

<ol>
	<li>
`Logger$A( `info^l, %data )
◎
Perform Logger("info", data).
</li>
</ol>

			</section>
			<section id="log">
<h4>1.1.6. `log(...data)^m</h4>

<ol>
	<li>
`Logger$A( `log^l, %data )
◎
Perform Logger("log", data).
</li>
</ol>

			</section>
			<section id="table">
<h4>1.1.7. `table(tabularData, properties)^m</h4>

<p>
~tableを構築するよう試行した上で，
`~log~level$【！%logLevel】 `log^l の下で~logする
— ~tableの［
各列は、 %tabularData の各~propからなる（または %properties を利用する）／
各行は、 %tabularData からなる
］。
表構造として構文解析できなかった場合、
単に引数を~logすることに~fall-backする。
◎
Try to construct a table with the columns of the properties of tabularData (or use properties) and rows of tabularData and log it with a logLevel of "log". Fall back to just logging the argument if it can’t be parsed as tabular.
</p>

<p class="XXX">
未策定
— これには良い~algoが必要になる。
◎
TODO: This will need a good algorithm.
</p>

			</section>
			<section id="trace">
<h4>1.1.8. `trace(...data)^m</h4>

<ol>
	<li>
%~trace ~LET ［
この関数を~callした所からの~callstack
］の表現
— `実装定義$な, 何らかの, ヤリトリありにもなり得るような
◎
Let trace be some implementation-defined, potentially-interactive representation of the callstack from where this function was called.
</li>
	<li>
任意選択で
⇒
%~trace 用の~labelとして［
`Formatter$A( %data ) の結果
］を組入れる
◎
Optionally, let formattedData be the result of Formatter(data), and incorporate formattedData as a label for trace.
</li>
	<li>
`Printer$A( `trace^l, « %~trace » )
◎
Perform Printer("trace", « trace »).
</li>
</ol>

<p class="note">注記：
~stack~trace内に~printされる関数の識別子は、
`実装定義$である。
それはまた、
`new Error().stack^c 内に見られるものと同じ識別子になることは保証されない。
◎
The identifier of a function printed in a stack trace is implementation-defined. It is also not guaranteed to be the same identifier that would be seen in new Error().stack.
</p>

			</section>
			<section id="warn">
<h4>1.1.9. `warn(...data)^m</h4>

<ol>
	<li>
`Logger$A( `warn^l, %data )
◎
Perform Logger("warn", data).
</li>
</ol>

			</section>
			<section id="dir">
<h4>1.1.10. `dir(item, options)^m</h4>

<ol>
	<li>
%~obj ~LET %item に`汎用~JS~objの整形$を適用した結果
◎
Let object be item with generic JavaScript object formatting applied.
</li>
	<li>
`Printer$A( `dir^l, « %~obj », %options )
◎
Perform Printer("dir", « object », options).
</li>
</ol>

			</section>
			<section id="dirxml">
<h4>1.1.11. `dirxml(...data)^m</h4>

<ol>
	<li>
%最終-~list ~LET 新たな`~list$
◎
Let finalList be a new list, initially empty.
</li>
	<li>
<p>
%data を成す
~EACH( %~item )
に対し：
◎
For each item of data:
</p>
		<ol>
			<li>
%変換-済み ~LET 
%~item の~DOM~tree表現が可能ならば それ ／
~ELSE_ %~item に`最適に有用な整形$を適用した結果
◎
Let converted be a DOM tree representation of item if possible; otherwise let converted be item with optimally useful formatting applied.
</li>
	<li>
%最終-~list に %変換-済み を付加する
◎
Append converted to finalList.
</li>
		</ol>
	</li>
	<li>
`Logger$A( `dirxml^l, %最終-~list )
◎
Perform Logger("dirxml", finalList).
</li>
</ol>

			</section>
		</section>
		<section id="counting">
<h3 title="Counting functions">1.2. 計数~用~関数</h3>

<p>
各 `console$I 名前空間~objには、
`計数~map@
が結付けられる。
それは、
各~entryが［
`文字列$ → 数
］として与えられる`~map$であり，
初期~時は空とする。
◎
Each console namespace object has an associated count map, which is a map of strings to numbers, initially empty.
</p>

			<section id="count">
<h4>1.2.1. `count(label)^m</h4>

<ol>
	<li>
%~map ~LET コレの`計数~map$
◎
Let map be the associated count map.
</li>
	<li>
~IF［
%~map[ %label ] ~NEQ ε
］
⇒
%~map[ %label ] ~INCBY 1
◎
If map[label] exists, set map[label] to map[label] + 1.
</li>
	<li>
~ELSE
⇒
%~map[ %label ] ~SET 1
◎
Otherwise, set map[label] to 1.
</li>
	<li>
%連結結果 ~LET 次を順に`連結する$
⇒＃
%label,
`003A^U (:),
`0020^U ~SPACE,
`ToString$A( %~map[ %label ] )
◎
Let concat be the concatenation of label, U+003A (:), U+0020 SPACE, and ToString(map[label]).
</li>
	<li>
`Logger$A( `count^l, « %連結結果 » )
◎
Perform Logger("count", « concat »).
</li>
</ol>

			</section>
			<section id="countreset">
<h4>1.2.2. `countReset(label)^m</h4>

<ol>
	<li>
%~map ~LET コレの`計数~map$
◎
Let map be the associated count map.
</li>
	<li>
~IF［
%~map[ %label ] ~NEQ ε
］
⇒
%~map[ %label ] ~SET 0
◎
If map[label] exists, set map[label] to 0.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~message ~LET 整形~指定子を伴わない文字列であって，［
%label【！the given label】 には計数は結付けられてないこと
］を汎用的に指示するもの
◎
Let message be a string without any formatting specifiers indicating generically that the given label does not have an associated count.
</li>
			<li>
`Logger$A( `countReset^l, « %~message » )
◎
Perform Logger("countReset", « message »);
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
		<section id="grouping">
<h3 title="Grouping functions">1.3. ~group分け関数</h3>

<p>
`~group@
は、
`実装定義$な, ヤリトリありにもなり得る, 親より字下げ~levelが 1 つ深い, 出力~用の~viewであり、
`Printer$A の~callにより生産される。
各 `console$I 名前空間~objには、
`~group~stack@
が結付けられる
— それは、
`~stack$であり，
初期~時は空とする。
`~group~stack$内の最後の`~group$のみが［
`Printer$A の~callにより生産される出力
］を~hostすることになる。
◎
A group is an implementation-defined, potentially-interactive view for output produced by calls to Printer, with one further level of indentation than its parent. Each console namespace object has an associated group stack, which is a stack, initially empty. Only the last group in a group stack will host output produced by calls to Printer.
</p>

			<section id="group">
<h4>1.3.1. `group(...data)^m</h4>

<ol>
	<li>
%~group ~LET 新たな`~group$
◎
Let group be a new group.
</li>
	<li>
%~group~label ~LET ［
%data は`空$でないならば `Formatter$A( %data ) の結果 ／
~ELSE_ 実装により選ばれる［
`~group$を表現する~label
］］
◎
If data is not empty, let groupLabel be the result of Formatter(data). Otherwise, let groupLabel be an implementation-chosen label representing a group.
</li>
	<li>
%~group~label を %~group 用の~labelとして組入れる
◎
Incorporate groupLabel as a label for group.
</li>
	<li>
任意選択で
⇒
~IF［
環境はヤリトリありな~groupを~supportする
］
⇒
%~group は既定で展開されるべきである
◎
Optionally, if the environment supports interactive groups, group should be expanded by default.
</li>
	<li>
`Printer$A( `group^l, « %~group » )
◎
Perform Printer("group", « group »).
</li>
	<li>
適切な`~group~stack$に %~group を`~push$する
◎
Push group onto the appropriate group stack.
</li>
</ol>

			</section>
			<section id="groupcollapsed">
<h4>1.3.2. `groupCollapsed(...data)^m</h4>

<ol>
	<li>
%~group ~LET 新たな`~group$
◎
Let group be a new group.
</li>
	<li>
%~group~label ~LET ［
%data は空でないならば `Formatter$A( %data ) の結果 ／
~ELSE_ 実装により選ばれる［
`~group$を表現する~label
］］
◎
If data is not empty, let groupLabel be the result of Formatter(data). Otherwise, let groupLabel be an implementation-chosen label representing a group.
</li>
	<li>
%~group~label を %~group 用の~labelとして組入れる
◎
Incorporate groupLabel as a label for group.
</li>
	<li>
任意選択で
⇒
~IF［
環境はヤリトリありな~groupを~supportする
］
⇒
%~group は既定で畳まれるべきである
◎
Optionally, if the environment supports interactive groups, group should be collapsed by default.
</li>
	<li>
`Printer$A( `groupCollapsed^l, « %~group » )
◎
Perform Printer("groupCollapsed", « group »).
</li>
	<li>
適切な`~group~stack$に %~group を`~push$する
◎
Push group onto the appropriate group stack.
</li>
</ol>

			</section>
			<section id="groupend">
<h4>1.3.3. `groupEnd()^m</h4>

<ol>
	<li>
`~group~stack$から`~pop$する
◎
Pop the last group from the group stack.
</li>
</ol>

			</section>
		</section>
		<section id="timing">
<h3 title="Timing functions">1.4. 計時~関数</h3>

<p>
各 `console$I 名前空間~objには
`~timer~table@
が結付けられる。
それは、
各~entryが［
`文字列$ → 時刻
］として与えられる`~map$であり，
初期~時は空とする。
◎
Each console namespace object has an associated timer table, which is a map of strings to times, initially empty.
</p>

			<section id="time">
<h4>1.4.1. `time(label)^m</h4>

<ol>
	<li>
%~timer~table ~LET コレの`~timer~table$
◎
↓</li>
	<li>
<p>
~IF［
%~timer~table[ %label ] ~NEQ ε
］：
</p>
		<ol>
			<li>
任意選択で
⇒
［
~label %label を伴う~timerは、
すでに開始された
］ことを指示する警告を~consoleに報告する
</li>
			<li>
~RET
</li>
		</ol>
◎
If the associated timer table contains an entry with key label, return, optionally reporting a warning to the console indicating that a timer with label label has already been started.
</li>
	<li>
~ELSE
⇒
%~timer~table[ %label ] ~SET 現在の時刻
◎
Otherwise, set the value of the entry with key label in the associated timer table to the current time.
</li>
</ol>

			</section>
			<section id="timelog">
<h4>1.4.2. `timeLog(label, ...data)^m</h4>

<ol>
	<li>
%~timer~table ~LET コレの`~timer~table$
◎
Let timerTable be the associated timer table.
</li>
	<li>
%開始~時刻 ~LET %~timer~table[ %label ]
◎
Let startTime be timerTable[label].
</li>
	<li>
<p>
%時間長 ~LET `実装定義$な書式で
( 現在の時刻 ~MINUS %開始~時刻 )
を表現している文字列
◎
Let duration be a string representing the difference between the current time and startTime, in an implementation-defined format.
</p>

<p class="example" id="duration-string-example">
`4650^l,
`4650.69 ms^l,
`5 seconds^l,
`00:05^l 
は、
どれも 4650.69 ミリ秒間を表示する適理な仕方である。
◎
"4650", "4650.69 ms", "5 seconds", and "00:05" are all reasonable ways of displaying a 4650.69 ms duration.
</p>
	</li>
	<li>
%連結結果 ~LET 次を順に`連結する$
⇒＃
%label,
`003A^U (:),
`0020^U ~SPACE,
%時間長
◎
Let concat be the concatenation of label, U+003A (:), U+0020 SPACE, and duration.
</li>
	<li>
%data に %連結結果 を`前付加する$
◎
Prepend concat to data.
</li>
	<li>
`Printer$A( `timeLog^l, %data )
◎
Perform Printer("timeLog", data).
</li>
</ol>

<div class="example" id="timelog-example">
<p>
利用者が［
何らかの余分な~dataを伴う中間的な~timer~log
］を給し易くするため、
~timerが存続する限り，
`timeLog()$m の~callに渡す %data ~parameterは `Logger$A の~callに含まれる。
例えば：
◎
The data parameter in calls to timeLog() is included in the call to Logger to make it easier for users to supply intermediate timer logs with some extra data throughout the life of a timer. For example:
</p>

<pre class="lang-js">
console.time("MyTimer");
console.timeLog("MyTimer", "Starting application up…");
/* <span class="comment">
何らかの
— たぶん，複階的な~appを~bootstrapするような —
~codeが走る。
◎
Perhaps some code runs to bootstrap a complex app
</span> */
// ...
console.timeLog("MyTimer", "UI is setup, making API calls now");
/* <span class="comment">
何らかの
— たぶん，~appを それ用の~dataで埋めるような —
`fetch()^c をここで行う。
◎
Perhaps some fetch()'s here filling the app with data
</span> */
// ...
console.timeEnd("MyTimer");
</pre>
</div>

			</section>
			<section id="timeend">
<h4>1.4.3. `timeEnd(label)^m</h4>

<ol>
	<li>
%~timer~table ~LET コレの`~timer~table$
◎
Let timerTable be the associated timer table.
</li>
	<li>
%開始~時刻 ~LET %~timer~table[ %label ]
◎
Let startTime be timerTable[label].
</li>
	<li>
%~timer~table[ %label ] ~SET ε
◎
Remove timerTable[label].
</li>
	<li>
%時間長 ~LET `実装定義$な書式で
( 現在の時刻 ~MINUS %開始~時刻 )
を表現している文字列
◎
Let duration be a string representing the difference between the current time and startTime, in an implementation-defined format.
</li>
	<li>
%連結結果 ~LET 次を順に`連結する$
⇒＃
%label,
`003A^U (:),
`0020^U ~SPACE,
%時間長
◎
Let concat be the concatenation of label, U+003A (:), U+0020 SPACE, and duration.
</li>
	<li>
`Printer$A( `timeEnd^l, « %連結結果 » )
◎
Perform Printer("timeEnd", « concat »).
</li>
</ol>

<p class="note" role="note">
%~timer~table 内に所与の %label が存在しないときに，
`timeEnd()$m, `timeLog()$m
が正式に警告を~consoleに報告させる計画については、
<a href="https://github.com/whatwg/console/issues/134">課題 #134</a>
を見よ。
◎
See whatwg/console#134 for plans to make timeEnd() and timeLog() formally report warnings to the console when a given label does not exist in the associated timer table.
</p>
			</section>
		</section>
	</section>
	<section id="supporting-ops">
<h2 title="Supporting abstract operations">2. 抽象-演算の~support法</h2>

		<section id="logger">
<h3>2.1. `Logger^A( %logLevel, %args )</h3>

<p>
`Logger^A 演算は、
( `~log~level$ %logLevel, 他の引数たちが成す`~list$ %args )
を受容する。
その主な出力を成すのは、
`実装定義$な，結果を~consoleへ~printする副作用である。
この仕様は、
そうする間に整形-指定子をどう処理するかについて述べる。
◎
The logger operation accepts a log level and a list of other arguments. Its main output is the implementation-defined side effect of printing the result to the console. This specification describes how it processes format specifiers while doing so.
</p>
<ol>
	<li>
~IF［
%args は`空$である
］
⇒
~RET
◎
If args is empty, return.
</li>
	<li>
%先頭 ~LET %args[ 0 ]
◎
Let first be args[0].
</li>
	<li>
%残り ~LET %args 内の %先頭 に後続するすべての要素からなる`~list$
◎
Let rest be all elements following first in args.
</li>
	<li>
~IF［
%残り は`空$である
］
⇒＃
`Printer$A( %logLevel, « %先頭 » )；
~RET
◎
If rest is empty, perform Printer(logLevel, « first ») and return.
</li>
	<li>
~ELSE
⇒
`Printer$A( %logLevel, `Formatter$A( %args ) )
◎
Otherwise, perform Printer(logLevel, Formatter(args)).
</li>
	<li>
~RET `undefined^jv
【 ~RET と ~RET `undefined^jv の違いは？】
◎
Return undefined.
</li>
</ol>

<div class="note">

<p>注記：
~algoが返る前に~printされることが重要である。
多くの開発者~consoleは、
その中に手入力した最後の演算の結果を~printする。
そのような~consoleにおいては、
開発者が
`console.log("hello!")^c
と手入力したとき，
先ず `hello!^l,
次に `console.log^c ~callの返り値 `undefined^jv を~printすることになる。
◎
It’s important that the printing occurs before returning from the algorithm. Many developer consoles print the result of the last operation entered into them. In such consoles, when a developer enters console.log("hello!"), this will first print "hello!", then the undefined return value from the console.log call.
</p>

<figure>
<figcaption id="_dgm-print-before-returning">
返る前に~printし終えたことを指示している図。
◎
Indicating that printing is done before return
</figcaption></figure>
</div>

		</section>
		<section id="formatter">
<h3>2.2. `Formatter^A( %args )</h3>

<p>
`Formatter^A 演算は、
供された 1 個目の引数を［
他の引数を利用して整形する
］よう試行する。
それは、［
1 個目の引数~内の整形~指定子が尽きるか, 他の引数が尽きる
］まで入力を整形するよう試行した上で，
~print用に相応しい~objたちが成す`~list$を返す：
◎
The formatter operation tries to format the first argument provided, using the other arguments. It will try to format the input until no formatting specifiers are left in the first argument, or no more arguments are left. It returns a list of objects suitable for printing.
</p>

<ol>
	<li>
~IF［
%args の`~size$ ~EQ 1
］
⇒
~RET %args
◎
If args’s size is 1, return args.
</li>
	<li>
%~target ~LET %args の 1 個目の要素
◎
Let target be the first element of args.
</li>
	<li>
%current ~LET %args の 2 個目の要素
◎
Let current be the second element of args.
</li>
	<li>
<p>
%指定子 ~LET %~target 内に未処理な†整形-指定子は［
在るならば，それらのうち最初に現れるもの／
無いならば ε
］
◎
Find the first possible format specifier specifier, from the left to the right in target.
</p>

<p class="trans-note">【†
“未処理な” は、
この訳による追加。
さもなければ、
同じ整形-指定子を何度も繰り~~返すことにもなり得るので。
】</p>

	</li>
	<li>
~IF［
%指定子 ~EQ ε
］
⇒
~RET %args
◎
If no format specifier was found, return args.
</li>
	<li>
<p>
%変換-済み ~LET %指定子 に応じて，次で与えられる値：
◎
Otherwise:
</p>
		<dl class="switch">
			<dt>`%s^l</dt>
			<dd>
`Call$A( `String$jI, `undefined^jv, « %current » )
◎
If specifier is %s, let converted be the result of Call(%String%, undefined, « current »).
</dd>

			<dt>`%d^l</dt>
			<dt>`%i^l</dt>
			<dd>
%current に応じて
⇒＃
`Symbol$jt であるならば `NaN^jv ／
~ELSE_ `Call$A( `parseInt$jI, `undefined^jv, « %current, 10 » )
◎
If specifier is %d or %i:
• If current is a Symbol, let converted be NaN
• Otherwise, let converted be the result of Call(%parseInt%, undefined, « current, 10 »).
</dd>

			<dt>`%f^l</dt>
			<dd>
%current に応じて
⇒＃
`Symbol$jt であるならば `NaN^jv ／
~ELSE_ `Call$A( `parseFloat$jI, `undefined^jv, « %current » )
◎
If specifier is %f:
• If current is a Symbol, let converted be NaN
• Otherwise, let converted be the result of Call(%parseFloat%, undefined, « current »).
</dd>

			<dt>`%o^l</dt>
			<dd>
任意選択で、
次のいずれか
⇒＃
%指定子 ／
%current に`最適に有用な整形$を適用した結果
◎
If specifier is %o, optionally let converted be current with optimally useful formatting applied.
</dd>

			<dt>`%O^l</dt>
			<dd>
任意選択で、
次のいずれか
⇒＃
%指定子 ／
%current に`汎用~JS~objの整形$を適用した結果
◎
If specifier is %O, optionally let converted be current with generic JavaScript object formatting applied.
</dd>

			<dt>`%c^l</dt>
			<dd class="XXX">
（未策定）
◎
TODO: process %c
</dd>
		</dl>
	</li>
	<li>
%~target 内の %指定子 を %変換-済み に置換する
【 %変換-済み 内にも整形-指定子があった場合、その指定子も “未処理” と見なされるのか？】
◎
If any of the previous steps set converted, replace specifier in target with converted.
</li>
	<li>
%結果 ~LET %~target, および %args 内の 3 個目~以降の要素からなる`~list$
◎
Let result be a list containing target together with the elements of args starting from the third onward.
</li>
	<li>
~RET `Formatter$A( %結果 )
◎
Return Formatter(result).
</li>
</ol>

			<section id="formatting-specifiers">
<h4 title="Summary of formatting specifiers">2.2.1. 各種 整形~指定子の要約</h4>

<p>
上の~algoにて処理される各種 整形-指定子を，以下に要約する（規範的でない）：
◎
The following is an informative summary of the format specifiers processed by the above algorithm.
</p>

<div>
<table>
<caption>
この表t内の %要素 は、
指定子へ代入される要素を指す。
</caption>
<thead>
<tr><th>指定子
<th>目的
<th>型~変換
<tbody>

<tr><td>`%s^l
<td>%要素 を文字列に変換する
<td>`String$jI( %要素 )

<tr><td>`%d^l ／ `%i^l
<td>%要素 を整数に変換する
<td>`parseInt$jI( %要素, 10 )

<tr><td>`%f^l
<td>%要素 を浮動小数点数に変換する
<td>`parseFloat$jI( %要素, 10 )

<tr><td>`%o^l
<td>%要素 を`最適に有用な整形$で表示する
<td>可用でない

<tr><td>`%O^l
<td>%要素 を`汎用~JS~objの整形$で表示する
<td>可用でない

<tr><td>`%c^l
<td>%要素 に供された~CSSを適用する
<td>可用でない
</table>

◎
Specifier｜Purpose｜Type Conversion
%s｜Element which substitutes is converted to a string｜%String%(element)
%d or %i｜Element which substitutes is converted to an integer｜%parseInt%(element, 10)
%f｜Element which substitutes is converted to a float｜%parseFloat%(element, 10)
%o｜Element is displayed with optimally useful formatting｜n/a
%O｜Element is displayed with generic JavaScript object formatting｜n/a
%c｜Applies provided CSS｜n/a
</div>

			</section>
		</section>
		<section id="printer">
<h3>2.3. `Printer^A( %logLevel, %args[, %options] )</h3>

<p>
`Printer^A 演算は、
`実装定義$であり，次を受容する
⇒＃
厳しさを指示する`~log~level$ %logLevel,
~printする引数~群を与える~List %args,
実装に特有な整形~optionを与える省略可能な~obj %options
◎
The printer operation is implementation-defined. It accepts a log level indicating severity, a List of arguments to print, and an optional object of implementation-specific formatting options.＼
</p>

<p>
%args 内に現れる要素は、
次に挙げるいずれかになる：
◎
Elements appearing in args will be one of the following:
</p>
<ul>
	<li>
~JS~obj
— 型を問わず
◎
JavaScript objects of any type.
</li>
	<li>
~print可能なもの
— ~stack~traceや`~group$など —
を成す，実装に特有な表現
◎
Implementation-specific representations of printable things such as a stack trace or group.
</li>
	<li>
`汎用~JS~objの整形$を適用した結果の~obj
◎
Objects with either generic JavaScript object formatting＼
</li>
	<li>
`最適に有用な整形$を適用した結果の~obj
◎
or optimally useful formatting applied.
</li>
</ul>

<p>
%options ~objが渡され，それは［
`undefined^jv ／ `null^jv
］でない場合、
実装は，
%options を利用して %args 内の各~要素に`実装定義$な整形を適用してもヨイ。
◎
If the options object is passed, and is not undefined or null, implementations may use options to apply implementation-defined formatting to the elements in args.
</p>

<p>
実装が %args をどう~printするかは，実装に委ねられるが、
実装は，開発者の期待に沿うよう［
~objどうしを~spaceかそれに類する何かで分離する
］べきである。
◎
How the implementation prints args is up to the implementation, but implementations should separate the objects by a space or something similar, as that has become a developer expectation.
</p>

<p>
`Printer^A 演算が~callされる時点では、
すべての整形-指定子は織り込み済みであり，［
整形-指定子により消費されるものと意味された引数たち
］は %args 内には残されないことになる。
実装の仕事は、
単純に~Listを~printすることである。
`Printer^A の~callにより生産される出力が現れるのは、［
適切な`~group~stack$が空でなければ それ成す最後の`~group$の中に限られる／
他の場合は~console内の他所になる
］べきである。
◎
By the time the printer operation is called, all format specifiers will have been taken into account, and any arguments that are meant to be consumed by format specifiers will not be present in args. The implementation’s job is simply to print the List. The output produced by calls to Printer should appear only within the last group on the appropriate group stack if the group stack is not empty, or elsewhere in the console otherwise.
</p>

<p>
`Printer^A 演算の~call時に，~consoleが開かれていない場合、
実装は，~messageたちを`実装定義$な上限（概して，少なくとも何百個か）までは
— それらを未来に示すために —
~bufferするべきである。
◎
If the console is not open when the printer operation is called, implementations should buffer messages to show them in the future up to an implementation-defined limit (typically on the order of at least 100).
</p>

			<section id="loglevel-severity">
<h4 title="Indicating logLevel severity">2.3.1. ~logの厳しさ~levelの指示-法</h4>

<p>
`console$I の各~関数は、
各自に一意な値を［
`Printer^A の~call時の %logLevel ~parameter
］に利用する
— それにより、
~printする~messageを関数ごとに~custom化することを実装に許容する。
しかしながら、［
これらの関数を次の表tに要約される 4 ~groupに分けて，
同じ~groupに属する出力は同様に扱う
］ことも，共通的に実施されている：
◎
Each console function uses a unique value for the logLevel parameter when calling Printer, allowing implementations to customize each printed message depending on the function from which it originated. However, it is common practice to group together certain functions and treat their output similarly, in four broad categories. This table summarizes these common groupings:
</p>

<div>
<table><thead>
<tr><th>~group
<th>`console$I 関数
<th>記述
<tbody>

<tr><td>log
<td>
`log()$m,
`trace()$m,
`dir()$m,
`dirxml()$m,
`group()$m,
`groupCollapsed()$m,
`debug()$m,
`timeLog()$m
<td>
汎用な~log

<tr><td>info
<td>
`count()$m,
`info()$m,
`timeEnd()$m
<td>
参考~log

<tr><td>warn
<td>
`warn()$m,
`countReset()$m
<td>
~messageにより指示される何かを利用者~向けに警告する~log

<tr><td>error
<td>
`error()$m,
`assert()$m
<td>
利用者~向けに~errorを指示する~log
</table>

◎
Grouping｜console functions｜Description
log｜log(), trace(), dir(), dirxml(), group(), groupCollapsed(), debug(), timeLog()｜A generic log
info｜count(), info(), timeEnd()｜An informative log
warn｜warn(), countReset()｜A log warning the user of something indicated by the message
error｜error(), assert()｜A log indicating an error to the user
</div>

<p>
この~group分けに意味されるのは，共通的な実施を文書化することであり、［
各~関数~用に，次の例に見られるような特別な挙動を供すること
］に関して，実装を拘束することではない：
◎
These groupings are meant to document common practices, and do not constrain implementations from providing special behavior for each function, as in the following examples:
</p>

<div class="example" id="timeEnd-formatting">
<p>
ここに見られる ある実装は、
`timeEnd()$m への~callにより生産される出力を青くすることにした
— `info()$m による出力は より中立的な色のままにしつつ。
◎
Here you can see one implementation chose to make output produced by calls to timeEnd() blue, while leaving info() a more neutral color.
</p>

<figure>
<figcaption id="_dgm-timeEnd-formatting">
`timeEnd()^m と `info()^m による整形の相違を示すデモ
◎
A demonstration of timeEnd and info formatting differences
</figcaption></figure>
</div>

<div class="example" id="count-output">
<p>
`count()$m の~callは、［
常に，新たな出力を~printする
］とは限らず，［
以前に出力した計数を更新する
］こともある。
◎
Calls to count() might not always print new output, but instead could update previously-output counts.
</p>

<figure>
<figcaption id="_dgm-edge-Count">
計数の挙動を示すデモ
◎
A demonstration of count behavior
</figcaption></figure>
</div>

			</section>
			<section id="printer-ux-innovation">
<h4 title="Printer user experience innovation">2.3.2. `Printer^A ~UX新機軸</h4>

<p>
`Printer$A は`実装定義$なので、
その実装には，~UX（利用者~体験）における新機軸も共通的に見られる。
~UXの増補として，例えば次が挙げられるが、
これらに限られない：
◎
Since Printer is implementation-defined, it is common to see UX innovations in its implementations. The following is a non-exhaustive list of potential UX enhancements:
</p>

<ul>
	<li>
<p>
~spamを防止するため、
互いに一致する出力は一つに集約する。
◎
De-duplication of identical output to prevent spam.
</p>

<div class="example" id="dedupe-example">
<p>
この例の実装は、
互いに一致する複数の~messageを一括するのみならず，
何個の~messageが一緒に一括されたかも供する。
◎
In this example, the implementation not only batches multiple identical messages, but also provides the number of messages that have been batched together.
</p>

<figure>
<figcaption id="_dgm-dedupe">
~console~messageの集約を示すデモ
◎
A demonstration of console message de-duplication
</figcaption></figure>
</div>

	</li>
	<li>
<p>
~messageたちを~logの厳しさ~levelで絞込むことを利用者に許容するための、
脇に置かれる余分な~UI。
◎
Extra UI off to the side allowing the user to filter messages by log level severity.
</p>

<div class="example" id="severity-filter-example">
<figure>
<figcaption id="_dgm-severity-filter">
絞込むための~UIを示すデモ
◎
Indicating UI that allows filtering by log severity
</figcaption></figure>
</div>
	</li>
	<li>
［
`~timer~table$, `~group~stack$, その他の内部に保守される~data
］の現在の状態を指示するための，脇に置かれる余分な~UI。
◎
Extra UI off to the side indicating the current state of the timer table, group stack, or other internally maintained data.
</li>
	<li>
~consoleのある部位を明滅して，利用者に何か重要なことを~alertする。
◎
Flashing portions of the console to alert the user of something important.
</li>
</ul>

			</section>
			<section id="object-formats">
<h4 title="Common object formats">2.3.3. 共通的な~obj整形-</h4>

<p>
~objは概して、
その文脈に相応しく整形されて~printされることになる。
この節では、
~objたちが各自の文脈にて最も有用に整形されるような，共通的な仕方を述べる。
この節に述べる整形は、［
最終的に `Printer$A に渡されることになる，`実装定義$な~obj表現
］に適用されることに注意。
整形による実際の副作用は，そこで見えることになる。
◎
Typically objects will be printed in a format that is suitable for their context. This section describes common ways in which objects are formatted to be most useful in their context. It should be noted that the formatting described in this section is applied to implementation-defined object representations that will eventually be passed into Printer, where the actual side effect of formatting will be seen.
</p>

<p>
`汎用~JS~objの整形@
を伴う~objとは、
汎用~JS~objの［
展開-可能にもなり得る表現
］である。
`最適に有用な整形@
を伴う~objとは、
~objの［
ヤリトリありにもなり得る`実装定義$な表現
］であって，最大限に有用かつ参考になると判定されたものである。
◎
An object with generic JavaScript object formatting is a potentially expandable representation of a generic JavaScript object. An object with optimally useful formatting is an implementation-defined, potentially-interactive representation of an object judged to be maximally useful and informative.
</p>

			</section>
			<section id="nodejs-printer">
<h4 title="Example printer in Node.js">2.3.4. 例： Node.js における `Printer^A</h4>

<div class="example" id="nodejs-printer-example">
<p>
Node.js ~platform上で `Printer^A 演算を実装する最も単純な仕方は、
それまでに整形された引数~群を~spaceで分離して連結した結果の出力を［
`stdout^c ／ `stderr^c
］に書込むことである。
◎
The simplest way to implement the printer operation on the Node.js platform is to join the previously formatted arguments separated by a space and write the output to stdout or stderr.
</p>

<p>
`ECMASCRIPT$r を利用する Node.js における実装~例：
◎
Example implementation in Node.js using [ECMASCRIPT]:
</p>

<pre class="lang-js">
const %util = require('util');

function print(%logLevel, ...%args) {
  const %message = %util.format(...%args);

  if (%logLevel === 'error') {
    process.stderr.write(%message + '\n');
  } else if (%logLevel === 'log' || %logLevel === 'info' || %logLevel === 'warn') {
    process.stdout.write(%message + '\n');
  }
}
</pre>

<p>
ここでの `util.format^c 関数により たくさんの作業が行われる。
それは、
入子な~objを文字列~化して，文字列でない引数は読める文字列~versionに変換する。
例えば `undefined^jv は 文字列 `undefined^l に,  `false^jv は `false^l になる：
◎
Here a lot of the work is done by the util.format function. It stringifies nested objects, and converts non-string arguments into a readable string version, e.g. undefined becomes the string "undefined" and false becomes "false":
</p>

<pre class="lang-js">
print('log', 'duck', [{foo: 'bar'}]);     // prints: `duck [ { foo: 'bar' } ]\n^c on stdout
print('log', 'duck', false);              // prints: `duck false\n^c on stdout
print('log', 'duck', undefined);          // prints: `duck undefined\n^c on stdout
</pre>
</div>

			</section>
		</section>
		<section id="reporting-warnings">
<h3 title="Reporting warnings to the console">2.4. ~consoleへの警告の報告-法</h3>

<p>
`~consoleに警告を報告する@
~algoは、
所与の
( 警告の汎用な記述 %記述 )
に対し：
◎
To report a warning to the console given a generic description of a warning description, implementations must run these steps:
</p>
<ol>
	<li>
%警告 ~LET %記述 から導出される`実装定義$な文字列
◎
Let warning be an implementation-defined string derived from description.
</li>
	<li>
`Printer$A( `reportWarning^l, « %警告 » )
◎
Perform Printer("reportWarning", « warning »).
</li>
</ol>

		</section>
	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main></div>


<div hidden>
<div lang="en" id="_acks1">

<p>
The editors would like to thank
Boris Zbarsky,
Brent S.A. Cowgill,
Brian Grinstead,
Corey Farwell,
Ian Kilpatrick,
Jeff Carpenter,
Joseph Pecoraro,
Justin Woo,
Luc Martin,
Noah Bass,
Paul Irish,
Raphaël, and
Victor Costan
for their contributions to this specification. You are awesome!
</p>

<p lang="en">
This standard is written by <a href="https://terinstock.com">Terin Stock</a> (<a href="mailto:terin@terinstock.com">terin@terinstock.com</a>), <a href="http://kowalski.gd">Robert Kowalski</a> (<a href="mailto:rok@kowalski.gd">rok@kowalski.gd</a>), and <a href="https://domfarolino.com">Dominic Farolino</a> (<a href="mailto:domfarolino@gmail.com">domfarolino@gmail.com</a>)
with major help from <a href="https://domenic.me/">Domenic Denicola</a> (<a href="https://google.com">Google</a>, <a href="mailto:d@domenic.me">d@domenic.me</a>).</p>

</div>

<div lang="en" id="_ipr1">

<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://https://console.spec.whatwg.org/review-drafts/2024-12/">Living Standard Review Draft</a>.
</p>
</div>

</div>
