<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Session history and navigation（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'history',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text = text.replace(/_/, ':');
	break;
case 'sbox': // sandboxing flags
	text = `閲覧文脈~sandbox化( ${key} )~flag`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'jI':
	text = `%${key}%`;
	break;
case 'bP':
	text = `${key}<code>BarProp</code> ~obj`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2020-07-10
trans_update:2020-06-27
source_checked:191126
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/history.html
	abbr_url:HISTORY
site_nav:browsers,network,html
nav_prev:ORIGIN
nav_next:NAVI
trans_1st_pub:2016-07-12


●●class_map
e:element
a:attr
et:event-type
sc:scheme
E:error
h:header
sl:js-slot
jI:js-intrinsic
jA:abstract
U:code-point
v:value

●●tag_map
I:code
m:code
c:code
e:code
a:code
sc:code
et:code
h:code
E:code
sl:span
jI:code
jA:span
U:span
v:code
V:var
i:i

●●words_table

	●network／保安
HTTP_S:HTTP(S) 
username::::ユーザ名
password::::パスワード
hostname::::ホスト名
	navigating:
transaction::::トランザクション
unload:
非冪等:non-idempotent::~
抹消-:evict::~
	eviction
乗取る:hijackする:乗っ取る

	●環境 ／ 閲覧
閲覧:browsing::~
入口:entry::~
現任の:incumbent:~
宛先:target::~
一足飛びに:jumpして:~

再読込み:reload::再読み込み::リロード
読込直す:reloadする::読み込み直す::リロードする
成熟-:mature::~
	一~pageだけ:one-page

辿る:traverseする::~
辿った:traverseした::~
辿られ:traverseされ::~
辿り:traversal::~

開かれ:openされ::~
先進する:go forwardする:先へ進む
後戻-:go back:後戻り




	●構造
族:family:~

	●IDL / js / event

	●UI
drop-down:drop down:::ドロップダウンメニュー
popup:
prompt:
書字方向性:directionality:~
聴覚:aural:~
操作o-:operate:操作

	●構文
colon::::コロン
区切っ:separateし:~
	先頭の:leading

直列形の:serialized::~::シリアル形の
逆直列化-:deserialize::~::逆シリアル化

	●data／操作
和集合:union::~
	getting
再構築-:reconstruct::~

	●処理一般
上書state:state override:上書き state
state:
	entry:item
例外投出あり:rethrow any exceptions:~
	~~投出:raise
	invoking
	-:substeps
給-:supply:~
再処理-:reprocess:~
持続化-:persist:~
持続的な:persisted:~
進行中の:ongoingな:~
復旧-:restore:~
復旧:restoration:~
	再び作動化-:reactivate
	:equal
	渡-:pass
	FIFO
	LIFO

	●仕様
metaphor::::メタファー
事実:fact:~
漠然:nebulous:~

	既定でない:non-default
	精確を期すため:for precision
	あり得る:possible
	:optionally
	素朴:naïve
	〜から:perspective
	早く:as soon as

	●仕様（動詞
濫用-:abuse:~
確認-:confirm:~
解放-:free:~
拒否-:refuse:~
協調-:coordinate:~
上限:limit:~

	関係-:relation
	-:involve
	食い違いが生じる:disagree
	きちんと定義され:well-defined
	unspecified
	配備-済み:deployed
	ものではない:not meant
	抵触する:hit
	代替わりする:bring 〜 into being to take the place of
	元々利用者から渡された:passed around by users
	-:except
	keeping track
	させ易く:help
	あらためて:afresh

	●未分類（動詞
増加-:increase:~
差挟む:interleaveする:差し挟む
塗直す:repaintする:塗り直す

	あてがう:prefill
	-:corresponding
	bookmarking
	having
	購入:purchase
	入れる／:put
	said
	取出して:pull して

	●未分類
bookmark:
command::::コマンド
database::::データベース
game::::ゲーム
iframe:
iframe-srcdoc:iframe srcdoc
timer::::タイマー
共同:joint:~
時系列的:chronological:~
連続的:contiguous:~
	連続する:consecutive
平坦:flat:~

	責を負う:responsible
	~Location~objにより:Location-object
	~Location~obj設定子により:Location-object-setter
	種類:kind
	-:duplicate
	~blocker
	より高速:faster
	-:common
	-:buffer
	表:table
	と違って:contrary to
	更には:furthermore
	~~記憶:memory
	線:line
	一本道:linear
	非:non-
	-:per
	point
	立て続けに:rapid succession
	-:respective
	組:tuple
	頻繁過ぎる:too-frequent
	巨大過ぎる:over-large
	失敗かも:possibleFailure
	一足飛びに:jumps straight

	●指示語
近過去:recent:~
	最も近過去に:most recently
最近の:latest:~
	様な:look
	:main
	いくぶん:somewhat
	あるいは:alternately
	もっぱら:purely
	単に:merely
	小さな:minor
	-:subsequent
	もう一つ:second
	-:otherwise
	以前／一つ前の:previous
	nothing
	-:newly
	次:next
	全体:whole
	後で／:later
	最も早期の:earliest
	直後:immediately after


●●original_id_map


dom-window-history:dom-history
dom-window-location:dom-location

	number-of-document-tree-child-browsing-contexts:number-of-child-browsing-contexts
	serialized-state:state-object


●●words_table1


HTMLWPROXY:HTML-windowproxy-ja.html
	Assert:<b>Assert</b>

document-domain:<code>document.domain</code> 
length0:length
location0:location
Location: <code>Location</code> 

●●mdn_urls
history-3:API/History
location:API/Location
	scrollrestoration:API/ScrollRestoration

●●link_map

	●IDL
LegacyUnforgeable:~WEBIDLjs#LegacyUnforgeable

E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror
E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror

I.Document:~HTMLdom#document
I.History:#history-3
I.Location:#location
I.ScrollRestoration:#scrollrestoration
I.Window:~WINDOW#window
I.DOMStringList:~HTMLcdom#domstringlist


	■#dom-member
l.auto:#dom-scrollrestoration-auto
l.manual:#dom-scrollrestoration-manual

m.isTrusted:~DOM4#dom-event-istrusted

m.history:#dom-window-history
m.back:#dom-history-back
m.forward:#dom-history-forward
m.go:#dom-history-go
m.length:#dom-history-length
m.pushState:#dom-history-pushstate
m.replaceState:#dom-history-replacestate
m.scrollRestoration:#dom-history-scroll-restoration
m.state:#dom-history-state

m.location:#dom-window-location
	m.window.location:#dom-window-location
m.~location0:#dom-document-location
	m.document.location:#dom-document-location

m.ancestorOrigins:#dom-location-ancestororigins
m.assign:#dom-location-assign
m.hash:#dom-location-hash
m.host:#dom-location-host
m.hostname:#dom-location-hostname
m.href:#dom-location-href
m.location.reload:#dom-location-reload
m.origin:#dom-location-origin
m.pathname:#dom-location-pathname
m.port:#dom-location-port
m.protocol:#dom-location-protocol
m.reload:#dom-location-reload
m.replace:#dom-location-replace
m.search:#dom-location-search


	●event
et.click:~UIEVENTS#event-type-click
et.hashchange:~HTMLindex#event-hashchange
et.resize:~CSSOMVIEW#eventdef-window-resize

	●要素
e.a:~HEtextlevel#the-a-element
e.div:~HEgrouping#the-div-element
e.head:~HEmetadata#the-head-element
e.title:~HEmetadata#the-title-element
e.area:~HEimages#the-area-element
e.iframe:~HEembed#the-iframe-element
e.script:~HEscripting#the-script-element

	●内容属性
a.dir:~HTMLdom#the-dir-attribute

	●code 他
sc.about_blank:~HTMLdep#about:blank

h.Cross-Origin-Opener-Policy:~HTMLiana#cross-origin-opener-policy-2

	●
~window:~WINDOW#the-window-object
文書:~HTMLdom#the-document-object

	●閲覧文脈
閲覧文脈:~BROWSERS#browsing-context
閲覧文脈~名:~BROWSERS#browsing-context-name
属する閲覧文脈:~BROWSERS#concept-document-bc
属する文書:~BROWSERS#concept-document-bc
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
bc.容器:~BROWSERS#bc-container
子~閲覧文脈:~BROWSERS#child-browsing-context
親~閲覧文脈:~BROWSERS#parent-browsing-context
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
作動中の文書:~BROWSERS#active-document
作動中の~window:~BROWSERS#active-window
作動中:~BROWSERS#active-document
文書~族:~BROWSERS#document-family
全部的に作動中:~BROWSERS#fully-active
~navigateすることは許容されて:~BROWSERS#allowed-to-navigate


	●WINDOW
対応する閲覧文脈:~WINDOW#window-bc
結付けられている文書:~WINDOW#concept-document-window
doc.破棄-:~WINDOW#discard-a-document

	●ORIGIN
生成元:~ORIGIN#concept-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
同一-生成元:~ORIGIN#same-origin
同じ生成元~domain:~ORIGIN#same-origin-domain

	●history
	§:#history
	§:#the-session-history-of-browsing-contexts
	:#_contiguous
	§:#the-history-interface
	§:#history-1
	§:#history-notes
	§:#the-location-interface

閲覧~session:#browsing-session
tlbc.閲覧~session:#tlbc-browsing-session
enV.閲覧~session:#environment-browsing-session

~session履歴:#session-history
~session履歴~entry:#session-history-entry
	m.history
直列形の状態:#serialized-state
現在の~entry:#current-entry
持続的な利用者~状態を伴う:#an-entry-with-persisted-user-state
~scroll復旧~mode:#scroll-restoration-mode
最近の~entry:#latest-entry

共同~session履歴:#joint-session-history
共同~session履歴の現在の~entry:#current-entry-of-the-joint-session-history
~session履歴~辿り~queue:#session-history-traversal-queue
~session履歴~event~loop:#session-history-event-loop
履歴を前／後に辿る:#traverse-the-history-by-a-delta
~URLと履歴を更新する:#url-and-history-update-steps

Loc.対応する閲覧文脈:#_concept-location-bc
Loc.関連な文書:#relevant-document
Loc.~url:#concept-location-url
先祖~生成元~list:#concept-location-ancestor-origins-list
~Location~obj設定子により~navigateする:#location-object-setter-navigate
~Location~objにより~navigateする:#location-object-navigate
生成元~domainを検査する:#_location-security-check


	●NAVI
~navigate:~NAVI#navigate
~navi:~NAVI#navigate
i.置換を可能化する:~NAVI#replacement-enabled
i.例外を可能化する:~NAVI#exceptions-enabled
i.履歴~navi:~NAVI#history-navigation-flag
~source閲覧文脈:~NAVI#source-browsing-context
文書を~unloadする:~NAVI#unload-a-document
文書の~unloadを~promptする:~NAVI#prompt-to-unload-a-document
~unloadは利用者から拒否された:~NAVI#refused-to-allow-the-document-to-be-unloaded
履歴を辿る:~NAVI#traverse-the-history
履歴の辿り:~NAVI#traverse-the-history
再読込みにより誘発され:~NAVI#reload-triggered-navigation
成熟-:~NAVI#concept-navigate-mature
~entry更新-:~NAVI#entry-update


	●INFRA
実装定義:~INFRA#implementation-defined
~list:~INFRA#list
付加する:~INFRA#list-append

	●WAPI
入口~設定群~obj:~WAPI#entry-settings-object
現任の設定群~obj:~WAPI#incumbent-settings-object
関連な設定群~obj:~WAPI#relevant-settings-object
関連な~Realm:~WAPI#concept-relevant-realm
関連な大域~obj:~WAPI#concept-relevant-global
~task:~WAPI#concept-task
現在~走っている~task:~WAPI#currently-running-task
~taskを~queueする:~WAPI#queue-a-task
大域~taskを~queueする:~WAPI#queue-a-global-task
~task源:~WAPI#task-source
履歴~辿り~task源:~WAPI#history-traversal-task-source
~event~loop:~WAPI#event-loop

環境~設定群~obj:~WAPI#environment-settings-object
enV.生成元:~WAPI#concept-settings-object-origin
enV.大域~obj:~WAPI#concept-settings-object-global
enV.担当の文書:~WAPI#responsible-document

	●HTML
並列的:~HTMLINFRA#in-parallel

相対的に構文解析-:~HTMLurl#parse-a-url
結果の~URL~record:~HTMLurl#resulting-url-record
	
jA.StructuredSerializeForStorage:~HTMLcloning#structuredserializeforstorage
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
逆直列化-:~HTMLcloning#structureddeserialize

~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document
完全に読込まれ:~HTMLparsing#completely-loaded
	~scriptに返される:~HTMLindex#event-popstate
~iframeの属性を処理する:~HEembed#process-the-iframe-attributes

	●URL1
~URL:~URL1#concept-url
~URL~record:~URL1#concept-url-record
基本~URL構文解析器:~URL1#concept-basic-url-parser
~hostを直列化する:~URL1#concept-host-serializer
~URLを直列化する:~URL1#concept-url-serializer
基底~URL不可用~flag:~URL1#url-cannot-be-a-base-url-flag
~username／~password／~portを持てない:~URL1#cannot-have-a-username-password-port

url.~host:~URL1#concept-url-host
url.~path:~URL1#concept-url-path
url.~port:~URL1#concept-url-port
url.~query:~URL1#concept-url-query
url.~scheme:~URL1#concept-url-scheme
url.素片:~URL1#concept-url-fragment
url.生成元:~URL1#concept-url-origin
url.既定の~port:~URL1#default-port
整数を直列化する:~URL1#serialize-an-integer

url.~host~state:~URL1#host-state
url.~hostname~state:~URL1#hostname-state
url.~path開始-~state:~URL1#path-start-state
url.~port~state:~URL1#port-state
url.~query~state:~URL1#query-state
url.~scheme開始-~state:~URL1#scheme-start-state
url.素片~state:~URL1#fragment-state

~HTTP_S~scheme:~FETCH#http-scheme

	●

doc.文字~符号化法:~DOM4#concept-document-encoding
doc.~URL:~DOM4#concept-document-url
作動化の挙動:~DOM4#eventtarget-activation-behavior


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ Session history and navigation</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

<body>

<header>
	<hgroup>
<h1>セッション履歴とナビ</h1>

	</hgroup>

</header>

<hr>

<main id="MAIN" hidden>

		<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ε, コレ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="history">
<h2 title="Session history and navigation">7.9. ~session履歴と~navi</h2>

			<section id="browsing-sessions">
<h4 title="Browsing sessions">7.9.1 閲覧~session</h4>

<div class="XXX">
<p>
`閲覧~session@
は…
`閲覧~session$の定義-法は、
<a href="~HTMLissue/4782">課題 #4782</a>,
<a href="~HTMLissue/5350">課題 #5350</a>
を見よ。
それは、概ね`~top-level閲覧文脈$に相似的である
— ［
`Cross-Origin-Opener-Policy$h ~header／~navi
］に因り置換され得ないことを除いて。
◎
A browsing session is …. See whatwg/html issue #4782 and whatwg/html issue #5350 for defining browsing session. It is roughly analogous to a top-level browsing context except that it cannot be replaced due to a `Cross-Origin-Opener-Policy` header or navigation.
</p>

<p>
各`~top-level閲覧文脈$には、ある`閲覧~session$を与える
`閲覧~session@tlbc
が結付けられる。
◎
A top-level browsing context has an associated browsing session which is a browsing session.
</p>

<div class="algorithm">
<p>
`環境~設定群~obj$ %環境 の
`閲覧~session@enV
は、次の手続きを走らせた結果になる：
◎
The browsing session of an environment settings object environment is the result of running these steps:
</p>
<ol>
	<li>
~Assert：
%環境 には`担当の文書$enVがある。
◎
Assert: environment has a responsible document.
</li>
	<li>
~RET %環境 の`担当の文書$enVが`属する閲覧文脈$の`~top-level閲覧文脈$の`閲覧~session$tlbc
◎
Return environment's responsible document's browsing context's top-level browsing context's browsing session.
</li>
</ol>
</div>
</div>

			</section>
			<section id="the-session-history-of-browsing-contexts">
<h3 title="The session history of browsing contexts">7.9.2. 閲覧文脈の~session履歴</h3>

<div class="p">
<p>
`閲覧文脈$ %B に`属する文書$たちからなる連列は、
%B の`~session履歴$を成す†。
`子~閲覧文脈$を含め，どの`閲覧文脈$も、互いに別個の`~session履歴$を有する。
各
`~session履歴@
は，何個かの`~session履歴~entry$からなる平坦な~listである。
</p>

<p class="trans-note">【†
この記述は、文書と~session履歴~entryとを同一視している。
しかしながら、複数の~entryが同じ文書に対応し得る。
】</p>

<p>
各
`~session履歴~entry@
は，次のものからなる
⇒＃
`~URL$,
`直列形の状態$,
~title,
`文書$,
~form~data,
`~scroll復旧~mode$,
~scroll位置,
`閲覧文脈~名$
</p>

<p>
これらのうち，`~URL$のみが必須とされる。
各~entryには、これら以外の情報も結付けられ得る。
</p>

◎
The sequence of Documents in a browsing context is its session history. Each browsing context, including child browsing contexts, has a distinct session history. A browsing context's session history consists of a flat list of session history entries. Each session history entry consists, at a minimum, of a URL, and each entry may in addition have serialized state, a title, a Document object, form data, a scroll restoration mode, a scroll position, a browsing context name, and other information associated with it.
</div>

<p class="note">注記：
各~entryには，最初に作成された時点で`文書$が結付けられるが、その文書は，`作動中$でないときは資源を解放するため`破棄-$docされることもあり得る。
`~session履歴~entry$内の`~URL$その他の~dataは、~UAが その`文書$を再び作動化する必要があると見出した場合に，元のものから新たな`文書$に~~代替わりするときに利用される。
◎
Each entry, when first created, has a Document. However, when a Document is not active, it's possible for it to be discarded to free resources. The URL and other data in a session history entry is then used to bring a new Document into being to take the place of the original, in case the user agent finds itself having to reactivate that Document.
</p>

<p class="note">注記：
`~session履歴~entry$の~titleは、`文書$の現在の `title$e に関係する必要はない。
この~titleが意図する所は、利用者が文書の履歴を~navigateできるよう，その時点での文書の状態を説明するためにある。
◎
Titles associated with session history entries need not have any relation with the current title of the Document. The title of a session history entry is intended to explain the state of the document at that point, so that the user can navigate the document's history.
</p>

<p>
`直列形の状態$が結付けられていない~URLは、利用者が（または~scriptにより）~pageから~pageへ~navigateするに伴い，~session履歴に追加される。
◎
URLs without associated serialized state are added to the session history as the user (or script) navigates from page to page.
</p>

<hr>

<p>
`閲覧文脈$の`~session履歴$内の各 `文書$には、一意な `History$I ~objが結付けられる
— そのいずれも、同じ下層の`~session履歴$を~model化するモノトスル。
◎
Each Document object in a browsing context's session history is associated with a unique History object which must all model the same underlying session history.
</p>

<div class="algo">
`~window$の
`history@m
取得子~手続きは
⇒
~RET コレに`結付けられている文書$に結付けられている `History$I ~obj
◎
The history attribute of the Window interface must return the object implementing the History interface for this Window object's associated Document.
</div>

<hr>

<p>
`直列形の状態@
は、~UI状態を表現している~objを（ `StructuredSerializeForStorage$jA を介して）直列化したものである。
非正式には、
“状態~obj”
と呼ばれることもある
— それは、［
作者から給された，~UI状態を表現している~obj
］，あるいは［
`直列形の状態$を（ `StructuredDeserialize$jA を介して）逆直列化して作成される~obj
］を表す。
◎
Serialized state is a serialization (via StructuredSerializeForStorage) of an object representing a user interface state. We sometimes informally refer to "state objects", which are the objects representing user interface state supplied by the author, or alternately the objects created by deserializing (via StructuredDeserialize) serialized state.
</p>

<p>
~pageは、~session履歴に`直列形の状態$を<a href="#dom-history-pushstate">追加できる</a>。
これは、利用者（または~script）が履歴~内を後戻したときに，`逆直列化-$された上で
<a href="~HTMLindex#event-popstate">~scriptに返される</a>。
したがって、 1 ~pageだけの~appにおいても，作者が “~navi” の~metaphorを利用できるようにする。
◎
Pages can add serialized state to the session history. These are then deserialized and returned to the script when the user (or script) goes back in the history, thus enabling authors to use the "navigation" metaphor even in one-page applications.
</p>

<div class="note">

<p>注記：
`直列形の状態$には、主に二つの用途が意図されている：
◎
Serialized state is intended to be used for two main purposes:＼
</p>

<ul>
	<li>
一つは、予め構文解析した状態の記述を `~URL$と一緒に格納して，単純な事例では 作者が構文解析せずに済むようにすること（元々利用者から渡された`~URL$を取扱うときは，依然として それを構文解析する必要があるので、これは小さな最適化に過ぎない）。
◎
first, storing a preparsed description of the state in the URL so that in the simple case an author doesn't have to do the parsing (though one would still need the parsing for handling URLs passed around by users, so it's only a minor optimization).＼
</li>
	<li>
もう一つは、他からは格納されない状態
— 現在の`文書$~instanceにのみ適用され，同じ~URLの`文書$が新たに開かれるときには再構築される必要があるような、状態 —
を，作者が ~URLと一緒に格納できるようにすること。
◎
Second, so that the author can store state that one wouldn't store in the URL because it only applies to the current Document instance and it would have to be reconstructed if a new Document were opened.
</li>
</ul>

<p>
後者の用例には、次が挙げられる：
◎
An example of the latter would be＼
</p>

<ul>
	<li>
利用者が後戻するときに、以前に~animateさせていた~popup `div$e を，同じ所在から~animateし続けれるよう，精確に協調するように追跡する。
◎
something like keeping track of the precise coordinate from which a popup div was made to animate, so that if the user goes back, it can be made to animate to the same location.＼
</li>
	<li>
［［
`~URL$ 内の情報に基づいて~serverから~fetchされるような~data
］の~cache
］の中への~pointerを保っておいて、後戻する／先進するときに，その情報を再度~fetchせずに済むようにする。
◎
Or alternatively, it could be used to keep a pointer into a cache of data that would be fetched from the server based on the information in the URL, so that when going back and forward, the information doesn't have to be fetched again.
</li>
</ul>
</div>

<hr>

<p>
どの時点においても，`~session履歴$内のある 1 つの~entryが
`現在の~entry@
になる。
これは、`閲覧文脈$にて`作動中の文書$を表現している~entryになる。
どの~entryが`現在の~entry$になるかは、この仕様に定義される~algo
— 例えば`履歴を辿る$間など —
により変更される。
◎
At any point, one of the entries in the session history is the current entry. This is the entry representing the active document of the browsing context. Which entry is the current entry is changed by the algorithms defined in this specification, e.g. during session history traversal.
</p>

<p class="trans-note">【
`作動中の文書$は常にあるので、~session履歴が空になることはない。
】</p>

<p class="note">注記：
`現在の~entry$は，通例的には`文書$の`~URL$doc用の~entryであるが、その文書により履歴に追加されたいずれかの`直列形の状態$用の~entryにもなり得る。
◎
The current entry is usually an entry for the URL of the Document. However, it can also be one of the entries for serialized state added to the history by that document.
</p>

<p>
`実装定義$な状態も持つような~entryは、
`持続的な利用者~状態を伴う@
とされる。
どのような種類の状態を格納し得るかは、この仕様では，指定しない。
◎
An entry with persisted user state is one that also has implementation-defined state. This specification does not specify what kind of state can be stored.
</p>

<p class="example">
例えば、~scroll位置や，~form~controlの値を持続化しようと求める~UAもある。
◎
For example, some user agents might want to persist the scroll position, or the values of form controls.
</p>

<p class="note">注記：
~form~controlの値を持続化する~UAには、それらの書字方向性（要素の `dir$a 属性~値）も持続化することが奨励される。
これは、［
明示的かつ既定でない書字方向性の下で，利用者が元々手入力した値
］が，履歴の辿り後に不正に表示されることを防止する。
◎
User agents that persist the value of form controls are encouraged to also persist their directionality (the value of the element's dir attribute). This prevents values from being displayed incorrectly after a history traversal when the user had originally entered the values with an explicit, non-default directionality.
</p>

<p>
~entryの
`~scroll復旧~mode@
は、~UAがその~entryへ辿ったとき，持続的な~scroll位置（もしあれば）を復旧するべきかどうかを指示する。
~scroll復旧~modeは次のいずれかをとり得る：
◎
An entry's scroll restoration mode indicates whether the user agent should restore the persisted scroll position (if any) when traversing to it. The scroll restoration mode may be one of the following:
</p>

<dl class="def-list">
	<dt>`auto@l</dt>
	<dd>
~UAが、~naviに際して~scroll位置を復旧する責を負う。
◎
The user agent is responsible for restoring the scroll position upon navigation.
</dd>

	<dt>`manual@l</dt>
	<dd>
~pageが、~naviに際して~scroll位置を復旧する責を負う。
~UAは、それを自動的に試みない。
◎
The page is responsible for restoring the scroll position and the user agent does not attempt to do so automatically
</dd>
</dl>

<p>
指定されていない場合、新たな~entryの`~scroll復旧~mode$は `auto$l に設定されるモノトスル。
◎
If unspecified, the scroll restoration mode of a new entry must be set to "auto".
</p>

<p>
`直列形の状態$を包含する各~entryは、その追加-時に作動中であった~page用の~entryと同じ`文書$を共有する。
◎
Entries that contain serialized state share the same Document as the entry for the page that was active when they were added.
</p>

<p>
`~URL$の`素片$urlのみ相違するような，連続的な各~entryも、同じ`文書$を共有する。
◎
Contiguous entries that differ just by their URLs' fragments also share the same Document.
</p>

<p id="_contiguous" class="note">注記：
同じ`文書$を共有するすべての~entryは、定義により連続的になる（それらは、単に，特定0の文書の異なる状態たちである）。
◎
All entries that share the same Document (and that are therefore merely different states of one particular document) are contiguous by definition.
</p>

<p>
`閲覧文脈$ %B に`属する文書$ %文書 の
`最近の~entry@
とは、［
%B の`~session履歴$内の~entry
］のうち［
~entryの`文書$ ~EQ %文書
］なるもの
］があれば、それらのうち最も近過去に辿られた~entryである。
そのような~entryがなければ（`文書$の作成-時）、
ε （なし）とする。
◎
Each Document in a browsing context can also have a latest entry. This is the entry for that Document to which the browsing context's session history was most recently traversed. When a Document is created, it initially has no latest entry.
</p>

<p>
~UAは、`~session履歴$内の~entry %entry に対しては：
</p>

<ul>
	<li>
［
%entry は`現在の~entry$でない
］~AND［
%entry は どの~scriptからも参照されていない
］ならば、 %entry の`文書$を`破棄-$docしてもヨイ
— 利用者／~scriptがそのような~pageに~navigateして戻ったときは，~pageを読込直すことになる。
この仕様は、~UAがいつ`文書$を［
破棄する／~cacheする
］べきかについては指定しない。
◎
User agents may discard the Document objects of entries other than the current entry that are not referenced from any script, reloading the pages afresh when the user or script navigates back to such pages. This specification does not specify when user agents should discard Document objects and when they should cache them.
</li>
	<li>
前項により %entry の`文書$が破棄されたとしても、下に与える各種~algoの目的においては，そうでなかったかのように動作するモノトスル。
利用者あるいは~scriptが，~DOM~objを~~記憶していない~pageへ~navigateして戻った／進んだときは、同じ`文書$を共有していた他の~entryも，その新たな文書~objを共有するモノトスル。
◎
Entries that have had their Document objects discarded must, for the purposes of the algorithms given below, act as if they had not. When the user or script navigates back or forwards to a page which has no in-memory DOM objects, any other entries that shared the same Document object with it must share the new object as well.
</li>
</ul>

			</section>
			<section id="the-history-interface">
<h3 title="The History interface">7.9.3. `History^I ~interface</h3>

<pre class="idl">
enum `ScrollRestoration@I { `auto$l, `manual$l };

[Exposed=Window]
interface `History@I {
  readonly attribute unsigned long `length$m;
  attribute `ScrollRestoration$I `scrollRestoration$m;
  readonly attribute any `state$m;
  void `go$m(optional long %delta = 0);
  void `back$m();
  void `forward$m();
  void `pushState$m(any %data, DOMString %title, optional USVString? %url = null);
  void `replaceState$m(any %data, DOMString %title, optional USVString? %url = null);
};
</pre>

<dl class="domintro">
	<dt>%window . `history$m . `length$m</dt>
	<dd>
`共同~session履歴$内の~entryの個数を返す。
◎
Returns the number of entries in the joint session history.
</dd>

	<dt>%window . `history$m . `scrollRestoration$m [ = %value ]</dt>
	<dd>
`~session履歴$内の現在の~entryの`~scroll復旧~mode$を返す。
◎
Returns the scroll restoration mode of the current entry in the session history.
</dd>
	<dd>
設定して、`~session履歴$内の現在の~entryの`~scroll復旧~mode$を変更できる。
◎
Can be set, to change the scroll restoration mode of the current entry in the session history.
</dd>

	<dt>%window . `history$m . `state$m</dt>
	<dd>
現在の`直列形の状態$を逆直列化した結果の~objを返す。
◎
Returns the current serialized state, deserialized into an object.
</dd>

	<dt>%window . `history$m . `go$m( [ %delta ] )</dt>
	<dd>
`共同~session履歴$内で，指定された段~数だけ後戻する／先進する。
◎
Goes back or forward the specified number of steps in the joint session history.
</dd>
	<dd>
%delta に対する 0 は、現在の~pageを読込直すことになる。
◎
A zero delta will reload the current page.
</dd>
	<dd>
%delta が範囲~外を指す場合は何もしない。
◎
If the delta is out of range, does nothing.
</dd>

	<dt>%window . `history$m . `back$m()</dt>
	<dd>
`共同~session履歴$内で 1 段だけ後戻する。
◎
Goes back one step in the joint session history.
</dd>
	<dd>
前~pageがない場合は何もしない。
◎
If there is no previous page, does nothing.
</dd>

	<dt>%window . `history$m . `forward$m()</dt>
	<dd>
`共同~session履歴$内で 1 段だけ先進する。
◎
Goes forward one step in the joint session history.
</dd>
	<dd>
次~pageがない場合は何もしない。
◎
If there is no next page, does nothing.
</dd>

	<dt>%window . `history$m . `pushState$m(%data, %title [, %url ] )</dt>
	<dd>
%data, %title を~session履歴に~pushする
— %url が与えられていて ~NULL でなければ それも伴わせて。
◎
Pushes the given data onto the session history, with the given title, and, if provided and not null, the given URL.
</dd>

	<dt>%window . `history$m . `replaceState$m(%data, %title [, %url ] )</dt>
	<dd>
［
%data, %title, %url（省略時は ~NULL ）
］で，~session履歴~内の現在の~entryのそれらを更新する。
◎
Updates the current entry in the session history to have the given data, title, and, if provided and not null, URL.
</dd>
</dl>

<div class="p">
<p>
`~top-level閲覧文脈$ %B の
`共同~session履歴@
とは、［
次を満たす各 `閲覧文脈$ %B1 の`~session履歴$内の~entryうち，その`現在の~entry$以外のもの
］すべての和集合に，`共同~session履歴の現在の~entry$を加えたものである：
</p>

<ul ><li>%B1 の`~top-level閲覧文脈$ ~EQ %B
</li><li>%B1 にて`作動中の文書$は、`全部的に作動中$である
</li></ul>

◎
The joint session history of a top-level browsing context is the union of all the session histories of all browsing contexts of all the fully active Document objects that share that top-level browsing context, with all the entries that are current entries in their respective session histories removed except for the current entry of the joint session history.
</div>

<p>
`共同~session履歴の現在の~entry@
は、それを成す`~session履歴$たちの`現在の~entry$のうち，最も近過去にそうなったものを指す。
◎
The current entry of the joint session history is the entry that most recently became a current entry in its session history.
</p>

<p>
`共同~session履歴$内の各~entryは，各自が属する`~session履歴$に追加された時刻により時系列的に順序付けられ、その順に 1 ずつ増加する整数~indexが付与される
— 最も早期の~entryに付与される~indexは 0 とする。
◎
Entries in the joint session history are ordered chronologically by the time they were added to their respective session histories. Each entry has an index; the earliest entry has index 0, and the subsequent entries are numbered with consecutively increasing integers (1, 2, 3, etc).
</p>

<p class="note">注記：
同じ`閲覧文脈$に`属する文書$たち それぞれの`~event~loop$は，互いに異なり得るので、`共同~session履歴$の実際の状態は，いくぶん漠然としたものになり得る。
例えば、【！ one unique origin】同じ生成元に属していた 2 個の同胞 `iframe$e 要素が，同時に別の生成元へ`履歴を辿る$こともあるので、それらの精確な順序は，きちんと定義されないかもしれない。
同様に，互いが他方を後と見出すこともあるため、それぞれにとっての`共同~session履歴$の長さには，食い違いが生じるかもしれない。
◎
Since each Document in a browsing context might have a different event loop, the actual state of the joint session history can be somewhat nebulous. For example, two sibling iframe elements could both traverse from one unique origin to another at the same time, so their precise order might not be well-defined; similarly, since they might only find out about each other later, they might disagree about the length of the joint session history.
</p>

【！ History 】
<div class="algo">
<p>
`length@m
取得子~手続きは：
◎
The length attribute of the History interface, on getting, must＼
</p>
<ol>
	<li>
~IF［
コレを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
↓</li>
	<li>
~RET `~top-level閲覧文脈$の`共同~session履歴$内の~entryの個数
◎
return the number of entries in the top-level browsing context's joint session history.＼
◎
If this History object is associated with a Document that is not fully active, getting must instead throw a "SecurityError" DOMException.
</li>
</ol>

<p>
~scriptからは、実際の各~entryには~access可能でない。
◎
The actual entries are not accessible from script.
</p>
</div>

<div class="algo">
<p>
`scrollRestoration@m
取得子~手続きは：
◎
The scrollRestoration attribute of the History interface, on getting, must＼
</p>
<ol>
	<li>
~IF［
コレを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
↓↓</li>
	<li>
~RET `~session履歴$内の`現在の~entry$の`~scroll復旧~mode$
◎
return the scroll restoration mode of the current entry in the session history.＼
</li>
</ol>
</div>

<div class="algo">
<p>
`scrollRestoration$m 設定子~手続きは：
◎
On setting,＼
</p>
<ol>
	<li>
~IF［
コレを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
↓</li>
	<li>
`~session履歴$内の`現在の~entry$の`~scroll復旧~mode$ ~SET 所与の値
◎
the scroll restoration mode of the current entry in the session history must be set to the new value.＼
◎
If this History object is associated with a Document that is not fully active, both getting and setting must instead throw a "SecurityError" DOMException.
</li>
</ol>
</div>

<div class="algo">
<p>
`state@m
取得子~手続きは：
◎
The state attribute of the History interface, on getting, must＼
</p>
<ol>
	<li>
~IF［
コレを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
return the last value it was set to by the user agent.＼
◎
If this History object is associated with a Document that is not fully active, getting must instead throw a "SecurityError" DOMException.＼
</li>
	<li>
~RET ~UAにより設定された最後の値
◎
↑</li>
</ol>

<p>
この属性の初期~時の値は、 ~NULL になるモノトスル。
◎
Initially, its value must be null.
</p>
</div>

<div class="algo">
<p>
`go(delta)@m
~method~手続きは：
◎
When the go(delta) method is invoked:
</p>
<ol>
	<li>
%文書 ~LET コレを結付けている`文書$
◎
Let document be this History object's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
%delta ~EQ 0
］
⇒
`location.reload()$m ~methodが~callされたかのように動作する
◎
If delta is 0, then act as if the location.reload() method was called, and return.
</li>
	<li>
~ELSE
⇒
`履歴を前／後に辿る$( %delta, %文書 が`属する閲覧文脈$ )
◎
Traverse the history by a delta with delta and document's browsing context.
</li>
</ol>
</div>

<div class="algo">
<p>
`back()@m
~method~手続きは：
◎
When the back() method is invoked:
</p>
<ol>
	<li>
%文書 ~LET コレを結付けている`文書$
◎
Let document be this History object's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
`履歴を前／後に辿る$( −1, %文書 が`属する閲覧文脈$ )
◎
Traverse the history by a delta with −1 and document's browsing context.
</li>
</ol>
</div>

<div class="algo">
<p>
`forward()@m
~method~手続きは：
◎
When the forward() method is invoked:
</p>
<ol>
	<li>
%文書 ~LET コレを結付けている`文書$
◎
Let document be this History object's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
`履歴を前／後に辿る$( 1, %文書 が`属する閲覧文脈$ )
◎
Traverse the history by a delta with +1 and document's browsing context.
</li>
</ol>
</div>

<hr>

<p>
各`~top-level閲覧文脈$は、初期~時には空な
`~session履歴~辿り~queue@
を持ち，`~task$を追加できる。
◎
Each top-level browsing context has a session history traversal queue, initially empty, to which tasks can be added.
</p>

<div class="algorithm">
<p>
各`~top-level閲覧文脈$ %B の作成-時には、その時点から`並列的$に，次の~algoを走らすモノトスル
— この~algoは， %B 用の
`~session履歴~event~loop@
と呼ばれる：
◎
Each top-level browsing context, when created, must begin running the following algorithm, known as the session history event loop for that top-level browsing context, in parallel:
</p>

<ol>
	<li>
%~queue ~LET %B の`~session履歴~辿り~queue$
◎
↓</li>
	<li>
<p >
~WHILE 無条件
</p>
		<ol>
			<li>
%~queue が空でなくなるまで待機する
◎
Wait until this top-level browsing context's session history traversal queue is not empty.
</li>
			<li>
%~queue から最初の`~task$を取出して、それを実行する
◎
Pull the first task from this top-level browsing context's session history traversal queue, and execute it.
◎
Return to the first step of this algorithm.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
`~session履歴~event~loop$は、`共同~session履歴$内の各 閲覧文脈~間の遷移を協調させ易くするためにある。
特定0の時点に，各 `閲覧文脈$が有する`~event~loop$は、互いに異なり得るので（これは、利用者が `example.com^c から `shop.example^c へ~navigateするときに起こり得る）、さもなければ，遷移に際し各~event~loop間の同期法を孕ます必要がある。
◎
The session history event loop helps coordinate cross-browsing-context transitions of the joint session history: since each browsing context might, at any particular time, have a different event loop (this can happen if the user navigates from example.com to shop.example), transitions would otherwise have to involve cross-event-loop synchronization.
</p>

<hr>

<div class="algorithm">
<p>
`履歴を前／後に辿る@
ときは、所与の
( 整数 %delta, `閲覧文脈$ %~source閲覧文脈 )
に対し，
%~source閲覧文脈 の【！ this 】`~top-level閲覧文脈$の`~session履歴~辿り~queue$に，次を走らす`~task$を付加するモノトスル：
◎
To traverse the history by a delta given delta and browsing context source browsing context, the user agent must append a task to this top-level browsing context's session history traversal queue, the task consisting of running the following steps:
</p>

<ol>
	<li>
%履歴 ~LET `共同~session履歴$
◎
↓</li>
	<li>
%index ~LET ( `共同~session履歴の現在の~entry$の~index ) ~PLUS %delta
◎
↓</li>
	<li>
~IF［
%index ~NIN { 0 〜 ( %履歴 内の~entry数 ~MINUS 1 ) }
］
⇒
~RET
◎
If the index of the current entry of the joint session history plus delta is less than zero or greater than or equal to the number of items in the joint session history, then return.
</li>
	<li>
%~entry ~LET %履歴 内の［
~index ~EQ %index
］なる~entry
◎
Let specified entry be the entry in the joint session history whose index is the sum of delta and the index of the current entry of the joint session history.
</li>
	<li>
%B ~LET %~entry の文書が`属する閲覧文脈$【！＊】
◎
Let specified browsing context be the browsing context of the specified entry.
</li>
	<li>
~IF［
%~source閲覧文脈 は， %B を`~navigateすることは許容されて$いない
］
⇒
~RET
◎
If source browsing context is not allowed to navigate specified browsing context, then return.
</li>
	<li>
~IF［
%B にて`作動中の文書$において、現在，`文書を~unloadする$~algoは走っている
］
⇒
~RET
◎
If the specified browsing context's active document's unload a document algorithm is currently running, return.
</li>
	<li>
<p>
次を遂行する`大域~taskを~queueする$( `履歴~辿り~task源$, %B にて`作動中の~window$ )：
◎
Queue a global task on the history traversal task source given specified browsing context's active window to perform the following steps:
</p>
		<ol>
			<li>
~IF［
%B を~navigateしようとする進行中の試みがあるが、
%B は【その試みにおいて】まだ`成熟-$していない（すなわち、 %B はまだ，その`文書$を`作動中$にする段を~~終えていない）
］
⇒
その試みを取消す
◎
If there is an ongoing attempt to navigate specified browsing context that has not yet matured (i.e. it has not passed the point of making its Document the active document), then cancel that attempt to navigate the browsing context.
</li>
			<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
			<li>
<p>
~IF［
%文書 ~NEQ %~entry の`文書$
］：
◎
If the specified browsing context's active document is not the same Document as the Document of the specified entry, then run these substeps:
</p>

				<ol>
					<li>
`文書の~unloadを~promptする$( %文書 )
⇒
~IF［
%文書 の`~unloadは利用者から拒否された$
］
⇒
~RET
◎
Prompt to unload the active document of the specified browsing context. If the user refused to allow the document to be unloaded, then return.
</li>
					<li>
`文書を~unloadする$( %文書 )
◎
Unload the active document of the specified browsing context.
</li>
				</ol>
			</li>
			<li>
%B の`履歴を辿る$( %~entry, `履歴~navi$i )
◎
Traverse the history of the specified browsing context to the specified entry with the history-navigation flag set.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
~UAは，利用者が（例えば~browserの戻る／進む~buttonを利用して）`閲覧文脈$を通して~navigateするときは、次を走らすモノトスル
⇒
`履歴を前／後に辿る$( 利用者が指定した動作に等価な %delta, 利用者が操作oしている`閲覧文脈$ )
◎
When the user navigates through a browsing context, e.g. using a browser's back and forward buttons, the user agent must traverse the history by a delta with a delta equivalent to the action specified by the user and the browsing context being operated on.
</p>

<hr id="history-1"> 

<div class="algorithm">
<p>
`~URLと履歴を更新する@
手続きは、所与の
(
`文書$ %文書,
`~URL$ %新~URL,
`直列形の状態$ %直列形の~data （省略時は ε ）,
文字列 %~title （省略時は ε ）,
%状態~push~flag ~IN { `~pushする^i, ε } （省略時は ε ）
)
に対し，次を走らす：
◎
The URL and history update steps, given a Document object document, a URL newURL, an optional serialized state serializedData, and an optional string title, optionally with a state push flag, are:
</p>

<ol>
	<li>
%履歴 ~LET %文書 が`属する閲覧文脈$の`~session履歴$
◎
Let browsingContext be document's browsing context.
	</li><li>
%現~entry ~LET %履歴 の`現在の~entry$
◎
↓</li>
	<li>
%更新する~entry ~LET %現~entry
◎
↓</li>
	<li>
<p>
~IF［
%状態~push~flag ~NEQ ε
］：
◎
If the state push flag is set, then:
</p>
		<ol>
			<li>
<p>
%履歴 内に %現~entry より後に~entryがあれば，それらすべてを除去する
◎
Remove all the entries in browsingContext's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.
</p>

<p class="note">注記：
これは、~UAの~UIに
<a href="#history-notes">影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
			</li>
			<li>
`~top-level閲覧文脈$の`文書~族$内の
~EACH( `文書$ %D )
に対し
⇒
`履歴~辿り~task源$から~queueされた`~task$のうち， %D に結付けられているものすべてを除去する
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.
</li>
			<li>
適切になるなら、~UAが持続化しようと望む状態を反映するように，
%現~entry を更新する
— この~entryは、`持続的な利用者~状態を伴う$ものとされる。
◎
If appropriate, update the current entry to reflect any state that the user agent wishes to persist. The entry is then said to be an entry with persisted user state.
</li>
			<li>
%更新する~entry ~SET 新たな`~session履歴~entry$
◎
↓</li>
			<li>
%更新する~entry を %履歴 の中で %現~entry の後に追加する
◎
Add a session history entry entry to the session history, after the current entry, with
</li>
			<li>
%更新する~entry の`~scroll復旧~mode$ ~SET %現~entry の`~scroll復旧~mode$
◎
•↓ newURL as the URL;
• the scroll restoration mode of the current entry in the session history as the scroll restoration mode;
•↓ serializedData as the serialized state, if it is given;
•↓ title as the title, if it is given.
</li>
			<li>
%履歴 の`現在の~entry$ ~SET %更新する~entry
◎
Update the current entry to be this newly added entry.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%更新する~entry は非 `GET^h 要請を表現する（例： それは `POST^h 提出の結果であった）
］
⇒
%更新する~entry を `GET^h 要請を表現するものに更新する
◎
Otherwise, update the current entry in browsingContext's session history so that:
•↓ newURL is the entry's new URL;
•↓ serializedData is the entry's new serialized state, if it is given; otherwise, the current entry's current serialized state is kept;
•↓ title is the entry's new title, if it is given; otherwise, the entry does not have a title;
• it represents a GET request, if it currently represents a non-GET request (e.g. it was the result of a POST submission).
</li>
	<li>
%更新する~entry の`~URL$ ~SET %新~URL
◎
↑</li>
	<li>
~IF［
%直列形の~data ~NEQ ε
］
⇒
%更新する~entry の`直列形の状態$ ~SET %直列形の~data
◎
↑</li>
	<li>
%更新する~entry の~title ~SET %~title
（ %~title ~EQ ε ならば, ~entryに~titleは無い）
◎
↑</li>

	<li>
<p>
%文書 の`~URL$doc ~SET %新~URL
◎
Set document's URL to newURL.
</p>

<p class="note">注記：
これは，［
`閲覧文脈$の`~navi$ ／ `履歴の辿り$
］ではないので、
`hashchange$et ~eventは発火されない。
◎
Since this is neither a navigation of the browsing context nor a history traversal, it does not cause a hashchange event to be fired.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`pushState(data, title, url)@m
は、状態~obj~entryを履歴に追加する。
◎
The pushState(data, title, url) method adds a state object entry to the history.
</p>

<p>
`replaceState(data, title, url)@m
は、履歴~内の`現在の~entry$の［
状態~obj, ~title, （ %url が与えられていれば）`~URL$
］を更新する。
◎
The replaceState(data, title, url) method updates the state object, title, and optionally the URL of the current entry in the history.
</p>

<p>
これらの~method~手続きは：
◎
When either of these methods is invoked, the user agent must run the following steps:
</p>
<ol>
	<li>
%文書 ~LET コレを結付けている`文書$
◎
Let document be the unique Document object this History object is associated with.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, throw a "SecurityError" DOMException.
</li>
	<li>
<p>
任意選択で
⇒
~RET
</p>

<p>
（例えば~UAは、これらの~methodの~callを，［
~timer ／
利用者による明瞭な動作に呼応して誘発されたものではない~event~listener
］によるものである場合や,
立て続けに呼出された場合には、許容しなくともよい。）
</p>
◎
Optionally, return. (For example, the user agent might disallow calls to these methods that are invoked on a timer, or from event listeners that are not triggered in response to a clear user action, or that are invoked in rapid succession.)
</li>
	<li>
%宛先~Realm ~LET コレに`関連な~Realm$
◎
Let targetRealm be this History object's relevant Realm.
</li>
	<li>
%直列形の~data ~LET `StructuredSerializeForStorage$jA( %data )
（例外投出あり）
◎
Let serializedData be StructuredSerializeForStorage(data). Rethrow any exceptions.
</li>
	<li>
%新~URL ~LET %文書 が`属する閲覧文脈$の`~session履歴$内の`現在の~entry$の`~URL$
◎
Let newURL be the URL of the current entry in browsingContext's session history.
</li>
	<li>
<p>
~IF［
%url ~NEQ ~NULL
］：
◎
If url is not null, then:
</p>
		<ol>
			<li>
%新~URL ~SET %url をコレに`関連な設定群~obj$に`相対的に構文解析-$した結果
◎
Parse url, relative to the relevant settings object of this History object.
</li>
			<li>
~IF［
%新~URL ~EQ `失敗^i
］
⇒
~THROW `SecurityError$E
◎
If that fails, then throw a "SecurityError" DOMException.
◎
Set newURL to the resulting URL record.
</li>
			<li>
%文書~URL ~LET %文書 の`~URL$doc
◎
↓</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~THROW `SecurityError$E
：
◎
↓</p>
				<ul>
					<li>
［
%新~URL, %文書~URL
］の［
`~path$url, `~query$url, `素片$url
］以外のある成分が相違する
◎
Compare newURL to document's URL. If any component of these two URL records differ other than the path, query, and fragment components, then throw a "SecurityError" DOMException.
</li>
					<li>
<p>
次の両者が満たされる：
</p>

<ul><li>
( %新~URL の`生成元$url, %文書 の`生成元$ )
は`同一-生成元$でない
</li><li>［
%新~URL, %文書~URL
］の［
`~path$url, `~query$url
］いずれかの成分は相違する
</li></ul>

<p>
（これは、~sandbox化された内容が 同一-生成元~上の他の~pageを偽装することを防止する。）
</p>
◎
If the origin of newURL is not same origin with the origin of document, and either the path or query components of the two URL records compared in the previous step differ, throw a "SecurityError" DOMException. (This prevents sandboxed content from spoofing other pages on the same origin.)
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
%状態~push~flag ~LET 呼出された~methodに応じて
⇒＃
`pushState()^m ならば `~pushする^i ／
`replaceState()^m ならば ε
◎
↓</li>
	<li>
`~URLと履歴を更新する$( %文書, %新~URL, %直列形の~data, %title, %状態~push~flag )
◎
Run the URL and history update steps given document, newURL, serializedData, and title, with the state push flag set if the method invoked was the pushState() method.
</li>
	<li>
%状態 ~SET `StructuredDeserialize$jA( %直列形の~data, %宛先~Realm )
⇒
例外が投出されたときは、~catchして
⇒
%状態 ~SET ~NULL （例外は無視する）
◎
Let state be StructuredDeserialize(serializedData, targetRealm). If this throws an exception, catch it, ignore the exception, and set state to null.
</li>
	<li>
コレの `state$m 属性 ~SET %状態
◎
Set history.state to state.
</li>
	<li>
%現~entry の`文書$の`最近の~entry$ ~SET %現~entry
◎
Set the current entry's Document object's latest entry to the current entry.
</li>
</ol>

<p class="note">注記：
%title は、もっぱら助言的でしかない。
~UAは，~titleを~UIに利用するかもしれない。
◎
The title is purely advisory. User agents might use the title in the user interface.
</p>
</div>

<p>
~UAは、~pageごとに，その~session履歴に追加される状態~objの個数を制限してもヨイ。
~pageが この`実装定義$な上限に抵触した場合、~UAは，新たな~entryが追加された後に，［
その~session履歴~内の~entryのうち，［
当の`文書$
【新たな~entryの文書？】【！＊】
用の最初の~entry
］の直後の~entryを除去するモノトスル（したがって，状態~履歴は、先に入れたものから抹消されるように動作する（ FIFO ）一方で、~naviに対しては，先に入れたものが最後に残るように動作する（ LIFO ））。
◎
User agents may limit the number of state objects added to the session history per page. If a page hits the implementation-defined limit, user agents must remove the entry immediately after the first entry for that Document object in the session history after having added the new entry. (Thus the state history acts as a FIFO buffer for eviction, but as a LIFO buffer for navigation.)
</p>

<div class="example">

<p>
~gameを考える：
利用者は，常に，ある “線” 上のある座標に居て、線に沿って~navigateでき，特定0の座標に対応する~pageを~bookmarkすれば後でそこへ戻れるとする。
◎
Consider a game where the user can navigate along a line, such that the user is always at some coordinate, and such that the user can bookmark the page corresponding to a particular coordinate, to return to it later.
</p>

<p>
そのような~gameの，位置 x=5 を実装している静的な~pageとして、次の様なものがあるとする：
◎
A static page implementing the x=5 position in such a game could look like the following:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 5 に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"&gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"&gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
</pre>
<!-- 
<!DOCTYPE HTML>
<!-&45; this is https://example.com/line?x=5 -&45;>
<title>Line Game - 5</title>
<p>You are at coordinate 5 on the line.</p>
<p>
 <a href="?x=6">Advance to 6</a> or
 <a href="?x=4">retreat to 4</a>?
</p>
-->
<p>
そのような~systemにおいて問題になるのは、利用者が~clickするたびに，~page全体を読込直す必要が生じることである。
次に、~scriptを利用して同じことをする別の仕方を示す：
◎
The problem with such a system is that each time the user clicks, the whole page has to be reloaded. Here instead is another way of doing it, using script:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 &lt;span id="coord"&gt;5&lt;/span&gt; に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"
   onclick="go(1); return false;"
 &gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"
   onclick="go(-1); return false;"
 &gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
&lt;script&gt;
 var %currentPage = 5; /* <span class="comment"
>~serverからあてがわれる
◎
prefilled by server
</span> */
 function go(%d) {
   setupPage(%currentPage + %d);
   history.pushState(%currentPage, document.title, '?x=' + %currentPage);
 }
 onpopstate = function(%event) {
   setupPage(%event.state);
 }
 function setupPage(%page) {
   %currentPage = %page;
   document.title = 'Line Game - ' + %currentPage;
   document.getElementById('coord').textContent = %currentPage;
   document.links[0].href = '?x=' + (%currentPage + 1);
   document.links[0].textContent = 'Advance to ' + (%currentPage + 1);
   document.links[1].href = '?x=' + (%currentPage - 1);
   document.links[1].textContent = 'retreat to ' + (%currentPage - 1);
 }
&lt;/script&gt;
</pre>

<!-- 
<!DOCTYPE HTML>
&lt;!-&45; this starts off as https://example.com/line?x=5 &45;-&gt;
<title>Line Game - 5</title>
<p>You are at coordinate <span id="coord">5</span> on the line.</p>
<p>
 <a href="?x=6" onclick="go(1); return false;">Advance to 6</a> or
 <a href="?x=4" onclick="go(-1); return false;">retreat to 4</a>?
</p>
<script>
 var currentPage = 5; // prefilled by server

-->

<p>
これは、~scriptの~supportを切っている~systemにおいても，依然として先掲の例の様に働くが、
<em>切っていない</em> 利用者は，ずっと高速に~navigateできるようになる
— 同じ体験に対し~network~accessはないので。
更には、~scriptに基づく素朴な~approachによる利用者~体験と違って，~session履歴を
~bookmarkする／~navigateする
のも依然として働く。
◎
In systems without script, this still works like the previous example. However, users that do have script support can now navigate much faster, since there is no network access for the same experience. Furthermore, contrary to the experience the user would have with just a naïve script-based approach, bookmarking and navigating the session history still work.
</p>

<p>
上の例において、
`pushState()$m ~methodに対する %data 引数は，~serverへ送信されることになる情報と同じになるが、利用者が~navigateするたびに~scriptが~URLを構文解析しなくとも済むような，より簡便な形になる。
◎
In the example above, the data argument to the pushState() method is the same information as would be sent to the server, but in a more convenient form, so that the script doesn't have to parse the URL each time the user navigates.
</p>
</div>

<hr />

<div class="example">
<p>
~appは、その時点の`~session履歴~entry$用の~titleに，文書の `title$e 要素の値と同じ値を利用しないこともできる。
例えばここに、 `title$e 要素~内に，ある~blockを示す単純な~pageがあるとする。
~navigateして以前の状態に後戻しても，利用者の時間は後戻しないので、~session履歴~title内に時刻を入れるのは不適切になるであろう。
◎
Applications might not use the same title for a session history entry as the value of the document's title element at that time. For example, here is a simple page that shows a block in the title element. Clearly, when navigating backwards to a previous state the user does not go back in time, and therefore it would be inappropriate to put the time in the session history title.
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;HTML LANG=EN&gt;
&lt;TITLE&gt;Line&lt;/TITLE&gt;
&lt;SCRIPT&gt;
 setInterval(function () {
   document.title = 'Line - ' + new Date();
 }, 1000);
 var %i = 1;
 function inc() {
   set(%i+1);
   history.pushState(%i, 'Line - ' + i);
 }
 function set(%newI) {
   %i = %newI;
   document.forms.F.I.value = %newI;
 }
&lt;/SCRIPT&gt;
&lt;BODY ONPOPSTATE="set(%event.state)"&gt;
&lt;FORM NAME=F&gt;
   State:
   &lt;OUTPUT NAME=I&gt;1&lt;/OUTPUT&gt;
   &lt;INPUT VALUE="Increment" TYPE=BUTTON ONCLICK="inc()"&gt;
&lt;/FORM&gt;
</pre>

</div>

<div class="example">
<p>
ほとんどの~appは、自身の履歴~entryのすべてに対し，同じ`~scroll復旧~mode$値を利用したいと求める。
そのためには、アリな限り早く `scrollRestoration$m 属性を設定して（例えば、文書の `head$e 要素~内の `script$e 要素で），［
履歴~sessionに追加された~entryが，欲される~scroll復旧~modeを取得する
］ことを確保することにより，達成できる。
◎
Most applications want to use the same scroll restoration mode value for all of their history entries. To achieve this they can set the scrollRestoration attribute as soon as possible (e.g., in the first script element in the document's head element) to ensure that any entry added to the history session gets the desired scroll restoration mode.
</p>

<pre class="lang-html">
&lt;head&gt;
  &lt;script&gt;
       if ('scrollRestoration' in history)
            history.scrollRestoration = 'manual';
  &lt;/script&gt;
&lt;/head&gt;
</pre>
</div>

			</section>
			<section id="history-notes">
<h3 title="Implementation notes for session history">7.9.4. ~session履歴~用の実装に対する注記</h3>

~INFORMATIVE

<p>
`History$I ~interfaceは、実装が~session履歴を利用者に向けてどう表現するかについて制約を課すものではない。
◎
The History interface is not meant to place restrictions on how implementations represent the session history to the user.
</p>

<p>
例えば~session履歴を，各~pageが，複数の “~~前方へ~~枝分かれする” ~pageを持つ様な方式で実装することもできる。
この仕様は、 `history$m ~obj内の各~pageからなる一本道の~listが利用者からどう見えるかについて，実際の~session履歴から導出する方法は定義しない。
◎
For example, session history could be implemented in a tree-like manner, with each page having multiple "forward" pages. This specification doesn't define how the linear list of pages in the history object are derived from the actual session history as seen from the user's perspective.
</p>

<p>
同様に，ある~pageが 2 個の `iframe$e を包含しているとき，~pageは各 `iframe$e の `history$m ~objとは別個の `history$m ~objを持つ
— ［
2 個の内縁~frameと外縁~pageの~navi
］を互いに差挟むような~session履歴を伴うような。
代表的な~web~browserは、利用者に “戻る” ~buttonを 1 個しか呈示しない事実があるにもかかわらず。
◎
Similarly, a page containing two iframes has a history object distinct from the iframes' history objects, despite the fact that typical web browsers present the user with just one "Back" button, with a session history that interleaves the navigation of the two inner frames and the outer page.
</p>

<p>
<strong>~security</strong>：
ある~pageが `pushState()$m を濫用して，~UAの履歴~navi便宜性を
“乗取る” のを避けるため、~UAには，以前の~pageへ一足飛びに戻る仕方を利用者に供することが示唆される（単に 1 つ前の状態へ後戻するのでなく）。
例えば、戻る~buttonは，~session履歴~内の~pageたちだけを示し，他のどの状態も示さないような ~drop-downを持たせることもできる。
同様に，聴覚~browserは、 2 つ前へ “戻る” ~command
— 1 つ前の状態へ後戻するもの, 以前の~pageへ一足飛びに戻るもの —
を持たせることもできる。
◎
Security: It is suggested that to avoid letting a page "hijack" the history navigation facilities of a UA by abusing pushState(), the UA provide the user with a way to jump back to the previous page (rather than just going back to the previous state). For example, the back button could have a drop down showing just the pages in the session history, and not showing any of the states. Similarly, an aural browser could have two "back" commands, one that goes back to the previous state, and one that jumps straight back to the previous page.
</p>

<p>
`pushState()$m, `replaceState()$m
いずれに対しても，~UAには、頻繁過ぎる~callや巨大過ぎる状態~objを介するような，これらの~APIの濫用-を防止することが奨励される。
上に詳細を与えたように，~algoでは、適切になるときは，~UAがそのような~callを無視することも明示的に許容されている。
◎
For both pushState() and replaceState(), user agents are encouraged to prevent abuse of these APIs via too-frequent calls or over-large state objects. As detailed above, the algorithm explicitly allows user agents to ignore any such calls when appropriate.
</p>

			</section>
			<section id="the-location-interface">
<h3 title="The Location interface">7.9.5. `Location^I ~interface</h3>

<p>
各 `~window$には、その作成-時に，新たな `Location$I ~objが結付けられる。
【！＊ unique instance of 〜 allocated】
</p>

<p class="trans-note">【
以下，ここでは、この節の内容のうち，~APIに関する部分のみ述べる。
他の内容は、
<a href="~HTMLWPROXY#the-location-interface">別ページ</a>
にて。
】</p>

<dl class="domintro">
	<dt>%document . `~location0$m [ = %value ]</dt>
	<dt>%window . `location$m [ = %value ]</dt>
	<dd>
現在の~pageの所在を伴う `Location$I ~objを返す。
◎
Returns a Location object with the current page's location.
</dd>
	<dd>
設定して，別の~pageへ~navigateできる。
◎
Can be set, to navigate to another page.
</dd>
</dl>

<div class="algo">
<p>
`Document$I の
`~location0@m
取得子~手続きは
◎
The Document object's location attribute's getter must＼
</p>
<ol>
	<li>
~IF［
コレは`全部的に作動中$である
］
⇒
~RET コレに`関連な大域~obj$の `Location$I ~obj
◎
return this Document object's relevant global object's Location object, if this Document object is fully active,＼
</li>
	<li>
~RET ~NULL
◎
and null otherwise.
</li>
</ol>
</div>

<div class="algo">
`Window$I の
`location@m
取得子~手続きは
⇒
~RET コレの `Location$I ~obj
◎
The Window object's location attribute's getter must return this Window object's Location object.
</div>

<p>
`Location$I ~objは、それに`対応する閲覧文脈$Locにて`作動中の文書$の`~URL$docを表現する。
それは、`閲覧文脈$の~session履歴の`現在の~entry$を
— `history$m ~obj内［
に~entryを追加する ／
の~entryを置換する
］ことを通して —
変更できるようにする。
◎
Location objects provide a representation of the URL of the active document of their Document's browsing context, and allow the current entry of the browsing context's session history to be changed, by adding or replacing entries in the history object.
</p>

<pre class="idl">
[Exposed=Window]
interface `Location@I { /* <span class="comment">
ただし、
<a href="~HTMLWPROXY#the-location-interface">追加的な作成~手続き</a>
と
<a href="~HTMLWPROXY#location-internal-methods">上書きされた内部~method</a>
も見よ。
◎
but see also additional creation steps and overridden internal methods
</span> */

  [`LegacyUnforgeable$] stringifier attribute USVString `href$m;
  [`LegacyUnforgeable$] readonly attribute USVString `origin$m;
  [`LegacyUnforgeable$] attribute USVString `protocol$m;
  [`LegacyUnforgeable$] attribute USVString `host$m;
  [`LegacyUnforgeable$] attribute USVString `hostname$m;
  [`LegacyUnforgeable$] attribute USVString `port$m;
  [`LegacyUnforgeable$] attribute USVString `pathname$m;
  [`LegacyUnforgeable$] attribute USVString `search$m;
  [`LegacyUnforgeable$] attribute USVString `hash$m;

  [`LegacyUnforgeable$] void `assign$m(USVString %url);
  [`LegacyUnforgeable$] void `replace$m(USVString %url);
  [`LegacyUnforgeable$] void `reload$m();

  [`LegacyUnforgeable$, SameObject] readonly attribute `DOMStringList$I `ancestorOrigins$m;
};
</pre>

<dl class="domintro">
	<dt>%location . `toString()^m</dt>
	<dt>%location . `href$m</dt>
	<dd>
`~url$Locを返す。
◎
Returns the Location object's URL.
</dd>
	<dd>
設定して，所与の~URLへ~navigateできる。
◎
Can be set, to navigate to the given URL.
</dd>

	<dt>%location . `origin$m</dt>
	<dd>
`~url$Locの生成元を返す。
◎
Returns the Location object's URL's origin.
</dd>

	<dt>%location . `protocol$m</dt>
	<dd>
`~url$Locの~schemeを返す。
◎
Returns the Location object's URL's scheme.
</dd>
	<dd>
設定して，`~url$Locの~schemeだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed scheme.
</dd>

	<dt>%location . `host$m</dt>
	<dd>
`~url$Locの［
~host,
~port（~scheme用の`既定の~port$urlと異なるならば）
］を返す。
◎
Returns the Location object's URL's host and port (if different from the default port for the scheme).
</dd>
	<dd>
設定して，`~url$Locの
~host, ~port
だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host and port.
</dd>

	<dt>%location . `hostname$m</dt>
	<dd>
`~url$Locの~hostを返す。
◎
Returns the Location object's URL's host.
</dd>
	<dd>
設定して，`~url$Locの~hostだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host.
</dd>

	<dt>%location . `port$m</dt>
	<dd>
`~url$Locの~port を返す。
◎
Returns the Location object's URL's port.
</dd>
	<dd>
設定して，`~url$Locの~portだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed port.
</dd>

	<dt>%location . `pathname$m</dt>
	<dd>
`~url$Locの~path を返す。
◎
Returns the Location object's URL's path.
</dd>
	<dd>
設定して，`~url$Locの~pathだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed path.
</dd>

	<dt>%location . `search$m</dt>
	<dd>
`~url$Locの~queryを返す（空でないならば 先頭の `?^l も含む）。
◎
Returns the Location object's URL's query (includes leading "?" if non-empty).
</dd>
	<dd>
設定して，`~url$Locの~query（先頭の `?^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed query (ignores leading "?").
</dd>

	<dt>%location . `hash$m</dt>
	<dd>
`~url$Locの素片を返す（空でないならば 先頭の `#^l を含む）。
◎
Returns the Location object's URL's fragment (includes leading "#" if non-empty).
</dd>
	<dd>
設定して，`~url$Locの素片（先頭の `#^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").
</dd>

	<dt>%location . `assign$m(%url)</dt>
	<dd>
%url へ~navigateする。
◎
Navigates to the given URL.
</dd>

	<dt>%location . `replace$m(%url)</dt>
	<dd>
~session履歴から現在の~pageを除去した上で，所与の %url へ~navigateする。
◎
Removes the current page from the session history and navigates to the given URL.
</dd>

	<dt>%location . `reload$m()</dt>
	<dd>
現在の~pageを読込直す。
◎
Reloads the current page.
</dd>

	<dt>%location . `ancestorOrigins$m</dt>
	<dd>
`親~閲覧文脈$から`~top-level閲覧文脈$までの各［
先祖`閲覧文脈$の生成元の値
］からなる， `DOMStringList$I ~objを返す。
◎
Returns a DOMStringList object listing the origins of the ancestor browsing contexts, from the parent browsing context to the top-level browsing context.
</dd>
</dl>

<p>
各 `Location$I ~obj %L には、次が定義される：
◎
↓</p>

<dl class="def-list">
	<dt>`対応する閲覧文脈@Loc</dt>
	<dd>
%L に`関連な大域~obj$†に`対応する閲覧文脈$を返す。
</dd>
	<dd class="trans-note">【†
すなわち、 %L を結付けている`~window$
】【
この定義は、この訳による補完。
原文では、単に “the 閲覧文脈”, 等としか記されていない箇所もある。
】</dd>

	<dt>`関連な文書@Loc</dt>
	<dd>
%L に`対応する閲覧文脈$Loc %B に応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ %B にて`作動中の文書$
◎
A Location object has an associated relevant Document, which is this Location object's relevant global object's browsing context's active document, if this Location object's relevant global object's browsing context is non-null, and null otherwise.
</dd>

	<dt>`~url@Loc</dt>
	<dd>
%L に`関連な文書$Loc %文書 に応じて
⇒＃
~NULL ならば `about_blank$sc ／
~ELSE_ %文書 の`~URL$doc
◎
A Location object has an associated url, which is this Location object's relevant Document's URL, if this Location object's relevant Document is non-null, and about:blank otherwise.
</dd>

	<dt>`先祖~生成元~list@</dt>
	<dd>
<p>
%L の作成-時に，［［
次の手続きから得られる文字列の~list
］が結付けられた `DOMStringList$I ~obj
］に設定されるモノトスル：
◎
A Location object has an associated ancestor origins list. When a Location object is created, its ancestor origins list must be set to a DOMStringList object whose associated list is the list of strings that the following steps would produce:
</p>

		<ol>
			<li>
%~list ~LET 新たな空`~list$
◎
Let output be a new list of strings.
</li>
			<li>
%B ~LET %L に`対応する閲覧文脈$Loc
【~Assert： %B ~NEQ ~NULL】
◎
Let current be the browsing context of the Document with which this Location object is associated.
</li>
			<li>
%B の
~EACH( `先祖~閲覧文脈$ %先祖 )
に対し， %B に近い先祖から順に
⇒
%~list に次の結果を`付加する$
⇒
`生成元を直列化する$( %先祖 にて`作動中の文書$の`生成元$ )
◎
Loop: If current has no parent browsing context, jump to the step labeled end.
◎
Let current be current's parent browsing context.
◎
Append the serialization of current's active document's origin to output.
◎
Return to the step labeled loop.
</li>
			<li>
~RET %~list
◎
End: Return output.
</li>
		</ol>
	</dd>
	<dd class="trans-note">【
この仕様の中では、 `ancestorOrigins$m のみから利用される。
service worker からも利用されている。
】</dd>
</dl>

<div class="algorithm">
<p>
`~Location~obj設定子により~navigateする@
ときは、所与の
( `Location$I ~obj %L, `~URL~record$ %url )
に対し，次を走らす：
◎
A Location object has an associated Location-object-setter navigate algorithm, which given a url, runs these steps:
</p>

<ol>
	<li>
<p>
%置換~flag ~LET［
次のいずれかが満たされるならば `置換^i ／
~ELSE_ ε
］：
◎
If any of the following conditions are met, let replacement flag be unset; otherwise, let it be set:
</p>
		<ul>
			<li>
%L に`関連な文書$Locは、`完全に読込まれ$ている
◎
This Location object's relevant Document has completely loaded, or
</li>
			<li>
【！＊？】
この~algoを走らせている`~task$は、次を満たす~eventに対する［
`作動化の挙動$を現在~処理して ／ ~event~listenerを取扱って
］いる
⇒
［
名前 `click$et
］~AND［
`isTrusted$m ~EQ ~T
］
◎
In the task in which the algorithm is running, an activation behavior is currently being processed whose click event's isTrusted attribute is true, or
◎
In the task in which the algorithm is running, the event listener for a click event, whose isTrusted attribute is true, is being handled.
</li>
		</ul>
	</li>
	<li>
`~Location~objにより~navigateする$( %L, %url, %置換~flag )
◎
Location-object navigate, given url and replacement flag.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~Location~objにより~navigateする@
ときは、所与の
( `Location$I ~obj %L, `~URL~record$ %url, %置換~flag ~IN { `置換^i, ε }（省略時は ε ）)
に対し，次を走らす：
</p>

<ol>
	<li>
%B ~LET %L に`対応する閲覧文脈$Loc
【~Assert： %B ~NEQ ~NULL】
</li>
	<li>
~IF［
%置換~flag ~NEQ ε
］~OR［
%B の`~session履歴$は、 %B の作成-時に作成された `about_blank$sc `文書$のみからなる
］
⇒
%置換~flag ~SET `置換を可能化する$i
</li>
	<li>
次を与える下で，
%B を %url へ`~navigate$する（例外投出あり）
⇒＃
`~source閲覧文脈$ ~SET `現任の設定群~obj$【の`大域~obj$enV】に`対応する閲覧文脈$,
`例外を可能化する$i,
%置換~flag
</li>
</ol>

◎
To Location-object navigate, given a url and replacement flag, run these steps:
• The source browsing context is the incumbent global object's browsing context.
• Navigate the browsing context to url, with the exceptions enabled flag set. Rethrow any exceptions.
• If the replacement flag is set or the browsing context's session history contains only one Document, and that was the about:blank Document created when the browsing context was created, then the navigation must be done with replacement enabled.
</div>

<div class="algorithm">
<p>
`Location$I ~obj %L の
`生成元~domainを検査する@
ときは、次を走らす：
</p>

<ol>
	<li>
%文書 ~LET %L に`関連な文書$Loc
</li>
	<li>
~IF［
%文書 ~NEQ ~NULL
］~AND［
( %文書 の`生成元$, `入口~設定群~obj$の`生成元$enV )
は`同じ生成元~domain$でない
］
⇒
~THROW `SecurityError$E
<!-- 
If this Location object's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException. 
／
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
-->
</li>
</ol>

<p class="trans-note">【
この手続きは、以下を簡潔に記すためにこの訳に導入している。
】</p>
</div>

<div class="algo">
<p>
`href@m
取得子~手続きは：
◎
The href attribute's getter must run these steps:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET `~URLを直列化する$( コレが指す`~url$Loc )
◎
Return this Location object's url, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`href$m 設定子~手続きは：
◎
The href attribute's setter must run these steps:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this Location object's relevant Document is null, then return.
</li>
	<li>
%~URL~record ~LET 所与の値を，`入口~設定群~obj$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse the given value relative to the entry settings object.＼
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If that failed, throw a TypeError exception.
</li>
	<li>
`~Location~obj設定子により~navigateする$( コレ, %~URL~record )
◎
Location-object-setter navigate to the resulting URL record.
</li>
</ol>

<p class="note">注記：
`href$m 属性~設定子に対しては、意図的に~security検査は行われない。
◎
The href attribute setter intentionally has no security check.
</p>
</div>

<div class="algo">
<p>
`origin@m
取得子~手続きは：
◎
The origin attribute's getter must run these steps:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET `生成元を直列化する$( コレが指す`~url$Locの`生成元$url )
◎
Return the serialization of this Location object's url's origin.
</li>
</ol>
</div>

<div class="algo">
<p>
`protocol@m
取得子~手続きは：
◎
The protocol attribute's getter must run these steps:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
コレが指す`~url$Locの`~scheme$url,
`:^l
◎
Return this Location object's url's scheme, followed by ":".
</li>
</ol>
</div>

<div class="algo">
<p>
`protocol$m 設定子~手続きは：
◎
The protocol attribute's setter must run these steps:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this Location object's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
	<li>
%~protocol文字列 ~LET 次を順に連結した結果
⇒＃
所与の値,
`:^l
◎
↓</li>
	<li>
<p>
%失敗かも ~LET 次を与える下で， %~protocol文字列 を`基本~URL構文解析器$にかけた結果
⇒
~URLと上書stateの組：
( %複製~URL, `~scheme開始-~state$url )
◎
Let possibleFailure be the result of basic URL parsing the given value, followed by ":", with copyURL as url and scheme start state as state override.
</p>
<p class="note">注記：
~URL構文解析器は，連続する~colonを無視するので、値に `https:^l を与えても（あるいは `https::::^l でさえ），
`https^l を与えるのと同じことになる。
◎
Because the URL parser ignores multiple consecutive colons, providing a value of "https:" (or even "https::::") is the same as providing a value of "https".
</p>
	</li>
	<li>
~IF［
%失敗かも ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If possibleFailure is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
~IF［
%複製~URL の `~scheme$urlは`~HTTP_S~scheme$である
］
⇒
~RET
◎
If copyURL's scheme is not an HTTP(S) scheme, then terminate these steps.
</li>
	<li>
`~Location~obj設定子により~navigateする$( コレ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`host@m
取得子~手続きは：
◎
The host attribute's getter must run these steps:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%url ~LET コレが指す`~url$Loc
◎
Let url be this Location object's url.
</li>
	<li>
~IF［
%url の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If url's host is null, return the empty string.
</li>
	<li>
%~host文字列 ~LET `~hostを直列化する$( %url の`~host$url )
◎
↓</li>
	<li>
~IF［
%url の`~port$url ~EQ ~NULL
］
⇒
~RET %~host文字列
◎
If url's port is null, return url's host, serialized.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
%~host文字列,
`:^l,
`整数を直列化する$( %url の`~port$url )
◎
Return url's host, serialized, followed by ":" and url's port, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`host$m 設定子~手続きは：
◎
The host attribute's setter must run these steps:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this Location object's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
	<li>
~IF［
%複製~URL の`基底~URL不可用~flag$ ~EQ ~T
］
⇒
~RET
◎
If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.
</li>
	<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~host~state$url )
◎
Basic URL parse the given value, with copyURL as url and host state as state override.
</li>
	<li>
`~Location~obj設定子により~navigateする$( コレ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`hostname@m
取得子~手続きは：
◎
The hostname attribute's getter must run these steps:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~url$Locの
`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this Location object's url's host is null, return the empty string.
</li>
	<li>
~RET `~hostを直列化する$( コレが指す`~url$Locの`~host$url )
◎
Return this Location object's url's host, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`hostname$m 設定子~手続きは：
◎
The hostname attribute's setter must run these steps:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this Location object's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
	<li>
~IF［
%複製~URL の`基底~URL不可用~flag$ ~EQ ~T
］
⇒
~RET
◎
If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.
</li>
	<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~hostname~state$url )
◎
Basic URL parse the given value, with copyURL as url and hostname state as state override.
</li>
	<li>
`~Location~obj設定子により~navigateする$( コレ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`port@m
取得子~手続きは：
◎
The port attribute's getter must run these steps:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~url$Locの`~port$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this Location object's url's port is null, return the empty string.
</li>
	<li>
~RET `整数を直列化する$( コレが指す`~url$Locの`~port$url )
◎
Return this Location object's url's port, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`port$m 設定子~手続きは：
◎
The port attribute's setter must run these steps:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this Location object's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
	<li>
~IF［
%複製~URL は `~username／~password／~portを持てない$
］
⇒
~RET
◎
If copyURL cannot have a username/password/port, then return.
</li>
	<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~port$url ~SET ~NULL
◎
If the given value is the empty string, then set copyURL's port to null.
</li>
	<li>
~ELSE
⇒
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~port~state$url )
◎
Otherwise, basic URL parse the given value, with copyURL as url and port state as state override.
</li>
	<li>
`~Location~obj設定子により~navigateする$( コレ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`pathname@m
取得子~手続きは：
◎
The pathname attribute's getter must run these steps:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%url ~LET コレが指す`~url$Loc
◎
Let url be this Location object's url.
</li>
	<li>
~IF［
%url の`基底~URL不可用~flag$ ~EQ ~T
］
⇒
~RET %url の`~path$url内の最初の文字列
◎
If url's cannot-be-a-base-URL flag is set, return the first string in url's path.
</li>
	<li>
~IF［
%url の`~path$urlは空である
］
⇒
~RET 空~文字列
◎
If url's path is empty, then return the empty string.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`/^l,
［ %url の`~path$url内の各~文字列（空~文字列も含めて）を `/^l で区切って連結した結果 ］
◎
Return "/", followed by the strings in url's path (including empty strings), separated from each other by "/".
</li>
</ol>
</div>

<div class="algo">
<p>
`pathname$m 設定子~手続きは：
◎
The pathname attribute's setter must run these steps:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this Location object's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
	<li>
~IF［
%複製~URL の`基底~URL不可用~flag$ ~EQ ~T
］
⇒
~RET
◎
If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.
</li>
	<li>
%複製~URL の`~path$url ~SET 空~list
◎
Set copyURL's path to the empty list.
</li>
	<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~path開始-~state$url )
◎
Basic URL parse the given value, with copyURL as url and path start state as state override.
</li>
	<li>
`~Location~obj設定子により~navigateする$( コレ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`search@m
取得子~手続きは：
◎
The search attribute's getter must run these steps:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~url$Locの`~query$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this Location object's url's query is either null or the empty string, return the empty string.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`?^l,
コレが指す`~url$Locの`~query$url
◎
Return "?", followed by this Location object's url's query.
</li>
</ol>
</div>

<div class="algo">
<p>
`search$m 設定子~手続きは：
◎
The search attribute's setter must run these steps:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this Location object's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
	<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~query$url ~SET ~NULL
◎
If the given value is the empty string, set copyURL's query to null.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise, run these substeps:
</p>

		<ol>
			<li>
%入力 ~LET 所与の値
◎
↓</li>
			<li>
~IF［
%入力 の最初の文字 ~EQ `?^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "?" removed, if any.
</li>
			<li>
%複製~URL の`~query$url ~SET 空~文字列
◎
Set copyURL's query to the empty string.
</li>
			<li>
次を与える下で，%入力 を`基本~URL構文解析器$にかける
⇒＃
~URLと上書stateの組：
( %複製~URL, `~query~state$url ),
%上書き符号化法： コレに`関連な文書$Locの`文字~符号化法$doc
◎
Basic URL parse input, with copyURL as url and query state as state override, and the relevant Document's document's character encoding as encoding override.
</li>
		</ol>
	</li>
	<li>
`~Location~obj設定子により~navigateする$( コレ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`hash@m
取得子~手続きは：
◎
The hash attribute's getter must run these steps:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~url$Locの`素片$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this Location object's url's fragment is either null or the empty string, return the empty string.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`#^l,
コレが指す`~url$Locの`素片$url
◎
Return "#", followed by this Location object's url's fragment.
</li>
</ol>
</div>

<div class="algo">
<p>
`hash$m 設定子~手続きは：
◎
The hash attribute's setter must run these steps:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this Location object's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
	<li>
%入力 ~LET 所与の値
◎
↓</li>
	<li>
~IF［
%入力 の最初の文字 ~EQ `#^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "#" removed, if any.
</li>
	<li>
%複製~URL の`素片$url ~SET 空~文字列
◎
Set copyURL's fragment to the empty string.
</li>
	<li>
次を与える下で， %入力 を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `素片~state$url )
◎
Basic URL parse input, with copyURL as url and fragment state as state override.
</li>
	<li>
`~Location~obj設定子により~navigateする$( コレ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
</ol>

<p class="note">注記：
`a$e, `area$e 要素~用の等価な~APIと違って，
`hash$m 属性の設定子は、［
空~文字列を，配備-済みの~scriptと互換にするよう特別に扱う
］ことはない。
◎
Unlike the equivalent API for the a and area elements, the hash attribute's setter does not special case the empty string to remain compatible with deployed scripts.
</p>
</div>

<div class="algo">
<p>
`assign(url)@m
~method~手続きは：
◎
When the assign(url) method is invoked, the user agent must run the following steps:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this Location object's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%~URL~record ~LET %url を，`入口~設定群~obj$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse url relative to the entry settings object.＼
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If that failed, throw a "SyntaxError" DOMException.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %~URL~record )
◎
Location-object navigate to the resulting URL record.
</li>
</ol>
</div>

<div class="algo">
<p>
`replace(url)@m
~method~手続きは：
◎
When the replace(url) method is invoked, the user agent must run the following steps:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this Location object's relevant Document is null, then return.
</li>
	<li>
%~URL~record ~LET 
%url を，`入口~設定群~obj$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse url relative to the entry settings object.＼
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If that failed, throw a "SyntaxError" DOMException.
</li>
	<li>
`~Location~objにより~navigateする$( コレ, %~URL~record, `置換^i )
◎
Location-object navigate to the resulting URL record with the replacement flag set.
</li>
</ol>

<p class="note">注記：
`replace()$m ~methodに対しては、~security検査は意図的に行われない。
◎
The replace() method intentionally has no security check.
</p>
</div>

<div class="algo">
<p>
`reload()@m
~method~手続きは：
◎
When the reload() method is invoked, the user agent must run the appropriate steps from the following list:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this Location object's relevant Document is null
• Return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin
• Throw a "SecurityError" DOMException.
</li>
	<li>
%B ~LET コレに`対応する閲覧文脈$Loc
◎
↓</li>
	<li>
<p>
~IF［
現在~実行-中の`~task$†は、利用者による %B の~resizeに呼応して配送された `resize$et ~eventによるものである††
］
⇒
%B を塗直す†††
◎
If the currently executing task is the dispatch of a resize event in response to the user resizing the browsing context
• Repaint the browsing context and return.
</p>

<p class="trans-note">【†
`現在~走っている~task$？
】【††
すなわち，この~methodが `resize^et ~event~handlerの中から呼出されたとき？
】【†††
“`repaint^en”
— 単に描画し直す？
】</p>

	</li>
	<li>
~IF［
%B にて`作動中の文書$は`~iframe-srcdoc文書$である
］
⇒
`~iframeの属性を処理する$( %B の`容器$bc )
◎
If the browsing context's active document is an iframe srcdoc document
• Reprocess the iframe attributes of the browsing context's container.
</li>
	<li>
<p>
~ELSE
⇒
次を与える下で， %B をコレが指す`~url$Locへ`~navigate$して（例外投出あり）、`閲覧文脈$の`現在の~entry$に対し`~entry更新-$を遂行する
⇒＃
`~source閲覧文脈$ ~SET %B,
`例外を可能化する$i
</p>

<p>
この~naviは、`再読込みにより誘発され$たものとされる。
</p>

◎
Otherwise
• Navigate the browsing context to this Location object's relevant Document's URL to perform an entry update of the browsing context's current entry, with the exceptions enabled flag set. The source browsing context must be the browsing context being navigated. This is a reload-triggered navigation. Rethrow any exceptions.
</li>
</ol>
</div>

<p>
利用者から ~UI要素†を通して［
`閲覧文脈$ %B にて`作動中の文書$ %文書 を読込直す
］よう要請されたときは、~UAは：
◎
When a user requests that the active document of a browsing context be reloaded through a user interface element,＼
</p>

<p class="trans-note">【†
~browserの “読込直す~button” 等を指すと思われるが，~DOM内の要素も含まれる？
】</p>

<ul>
	<li>
%B を %文書 と同じ資源へ`~navigate$して，`閲覧文脈$の`現在の~entry$に対し`~entry更新-$を遂行するべきである。
この~naviは、`再読込みにより誘発され$たものとされる。
◎
the user agent should navigate the browsing context to the same resource as that Document, to perform an entry update of the browsing context's current entry. This is a reload-triggered navigation.＼
</li>
	<li>
非冪等~method（例： ~HTTP `POST^meth ）の事例では、~UAは先ず，利用者にその演算を確認してもらうよう~promptするべきである
— さもなければ、~transaction（例：購入や~database改変）が繰返され得るので。
◎
In the case of non-idempotent methods (e.g. HTTP POST), the user agent should prompt the user to confirm the operation first, since otherwise transactions (e.g. purchases or database modifications) could be repeated.＼
</li>
	<li>
［
読込直すとき、~cacheを明示的に上書きする
］ことを，利用者に許容してもヨイ。
◎
User agents may allow the user to explicitly override any caches when reloading.
</li>
</ul>

<div class="algo">
<p>
`ancestorOrigins@m
取得子~手続きは：
◎
The ancestorOrigins attribute's getter must run these steps:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET 空`~list$†
◎
If this Location object's relevant Document is null, then return an empty list.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET コレの`先祖~生成元~list$
◎
Otherwise, return this Location object's ancestor origins list.
</li>
</ol>

<p class="warning">
`ancestorOrigins$m 属性がどう働くかの詳細は、まだ異論があり，変更され得る。
更なる情報は
<a href="~HTMLissue/1918">issue #1918</a> 
を見よ。
◎
The details of how the ancestorOrigins attribute works are still controversial and might change. See issue #1918 for more information.
</p>

<p class="trans-note">【†
常に同じ~objを返すはずなので（ [SameObject] ）、実際には，`対応する閲覧文脈$Locが破棄される時点で，`先祖~生成元~list$が空にされるのかもしれない。
】</p>
</div>

<hr>

<p class="trans-note">【
以下，この節, およびその各 下位節の内容は、
<a href="~HTMLWPROXY#the-location-interface">別ページ</a>
にて。
】</p>

			</section>
		</section>
</main>

