<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Session history and navigation（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style type="text/css">

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'history',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text = text.replace(/_/, ':');
	break;
case 'sbox': // sandboxing flags
	text = '閲覧文脈~sandbox化( ' + key + ' )~flag';
	break;
case 'sl': // JS internal slot
	text = '[[' + key + ']]';
	break;
case 'jI': // JS intrinsic objects
	text = '%' + key + '%';
	break;
case 'bP': //
	text = key + '<code>BarProp</code> ~obj';
	break;
case 'U': // Unicode code point
	text = 'U+' + key;
	break;
case 'smb': //
	text = '(<span class="char-symbol">' + text + '</span>)'
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2018-08-24
trans_update:2018-08-25
source_checked:180824
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/history.html
site_nav:browsers,network,html
nav_prev:ORIGIN
nav_next:NAVI
trans_1st_pub:2016-07-12


●●class_map
e:element
a:attr
et:event-type
sc:scheme
E:error
h:header
sl:js-slot
jI:js-intrinsic
jA:abstract
U:code-point
v:value

●●tag_map
I:code
m:code
c:code
e:code
a:code
sc:code
et:code
h:code
E:code
sl:span
jI:span
jA:span
U:span
v:code
V:var
i:i

●●words_table

	●network／保安
HTTP:
HTTP_S:HTTP(S) 
cannot-be-a-base-URL::基底 URL 不可用
cache::::キャッシュ
entry::::エントリ
fetch:
URL:
url:
record::::レコード
domain::::ドメイン
host::::ホスト
port::::ポート
username::::ユーザ名
password::::パスワード
scheme::::スキーム
hostname::::ホスト名
navigate::::ナビゲート
	navigating:
navi:navigation:::ナビ
network::::ネットワーク
path::::パス
protocol::::プロトコル
query::::クエリ
server::::サーバ
transaction::::トランザクション
unload:

保安:security::~:セキュリティ
session::::セッション
sandbox::::サンドボックス
素片:fragment::~::フラグメント
要請:request::~::リクエスト
資源:resource::~:リソース
追跡-:track:~
送信-:send:~
非冪等:non-idempotent:~
偽装:spoof:~
基本:basic:~
抹消-:evict:~
	eviction
不許可に:disallow:~

	●環境 ／ 閲覧
大域:global::~::グローバル
設定子:setter:~
設定群:settings:~
入口:entry::~
現在の:current:~
	現在:currently:~
現任の:incumbent:~
Realm:
宛先:target::~
状態:state:~
遷移:transition:~
関連する:relevant な:~

top-level::::トップレベル
一足飛びに:jump して:~
閲覧文脈:browsing context::~
生成元:origin::~::オリジン
同一生成元:same origin::~::同一オリジン
破棄-:discard:~

再読込み:reload::再読み込み::リロード
読込まれ:load され::読み込まれ::ロードされ
成分:component:~
成熟-:mature:~
所在:location:~
頁:page:::ページ
	一~頁だけ:one-page
	走査-:traverse:~
走査する:traverse する::辿る
走査した:traverse した::辿った
走査され:traverse され::辿られ
走査:traversal::辿り
入子の:nested:入れ子の
族:family:~
開かれ:open され::~
親:parent:~
容器:container:::コンテナ
文書:document:~
履歴:history::~
先進する:go forward する:先へ進む
後戻-:go back:後戻り
	backward:~
	戻る:back:~
	進む:forward:~

	●IDL / js / event
handler::::ハンドラ
event-loop:event loop:::イベントループ
event::::イベント
内部:internal:~
method::::メソッド
instance::::インスタンス
interface::::インタフェース
listener::::リスナ
obj:object:::オブジェクト
script::::スクリプト
window::
発火-:fire:~
配送-:dispatch:~
属性:attribute:~

	●UI
UI:user interface:UI
animate::::アニメート
button::::ボタン
click::::クリック
drop-down:drop down:::ドロップダウンメニュー
form::::フォーム
frame::::フレーム
resize::::リサイズ
popup:
prompt:
scroll::::スクロール
title::::タイトル
書字方向性:directionality:~
聴覚:aural:~
表示-:display:~
外縁:outer:~
内縁:inner:~
手入力-:enter:~
form::::フォーム
control::::コントロール
呈示-:present:~
描画:rendering:~

	●構文
colon::::コロン
整数:integer:~
文字:character:~
文字列:string:~
構文解析-:parse::~::パース
構文解析器:parser::~::パーサ
相対的:relative:~
空:empty:~
符号化法:encoding::~::エンコーディング
区切って:separate して:~
位置:position:~
名:name:~
名前:name:~
	先頭の:leading

	●処理一般
task::::タスク
源:source::~::ソース
error::::エラー
flag::::フラグ
list::::リスト
pointer::::ポインタ
push:
上書き:override:~
上書state:state override:上書き state
state:
下層の:underlying:~
index:
	entry:item
mode::::モード
access::::アクセス
call:
catch:
例外:exception:~
例外投出あり:rethrow any exceptions:~
並列的:parallel:~
投出:throw:~
	~~投出:raise
queue::::キュー
待機-:wait:~
引数:argument:~
呼出され:invoke され:呼び出され
	invoking
取得子:getter:~
被呼出時:被 invoke 時:~
初期:initial:~

直列化-:serialize::~::シリアル化
直列化:serialization::~::シリアル化

直列形の:serialized::~::シリアル形の
逆直列化-:deserialize::~::逆シリアル化

結付けら:associate さ:結び付けら
結付けて:associate して:結び付けて
取扱う:handle する:取り扱う
取扱って:handle して:取り扱って
	取扱い:handling:取り扱い
手続き:steps:~
	-:substeps
段:step:~
作成-:create:~
作成:creation:~
付加-:append:~
除去-:remove:~
設定-:set:~
変更-:change:~
取得-:get:~
	getting
置換-:replace:~
置換:replacement:~
再構築-:reconstruct:~
給-:supply:~
処理-:process:~
再処理-:reprocess:~
動作-:act:~
動作:action:~
取消す:cancel する::取り消す::キャンセルする
可能化-:enable:~
可能化:enabled:~
失敗:failure:~
実行-:execute:~
持続化-:persist:~
持続的な:persisted:~
改変:modification:~
更新-:update:~
格納-:store:~
検査-:check:~
検査:check:~
演算:operation:~
	-:produce:~
遂行-:perform:~
進行中:ongoing:~
複製:copy:~
復旧-:restore:~
復旧:restoration:~
誘発-:trigger:~
走らす:run する:~
走らせ:run し:~
走って:run して:~
開始-:start:~
順序:order:~
順序付けら:order さ:~
値:value:~
入力:input:~
静的:static:~
作動中の:active な::~::アクティブな
作動中:active::~::アクティブ
作動化:activation::~::アクティブ化
作動化-:activate::~::アクティブ化
	再び作動化-:reactivate
繰返され:repeat され:繰り返され
	:equal
	所与の:given
	与-:give
	渡-:pass
	返す:return
	FIFO
	LIFO

	●仕様
UA:user agent:UA
API:
Web:
approach::::アプローチ
support::::サポート
system::::システム
algo:algorithm:::アルゴリズム
app:application:::アプリ
model::::モデル
metaphor::::メタファー
一意:unique:~
不正:incorrect:~
不適切:inappropriate:~
事例:case:~
事実:fact:~
互換:compatible:~
仕方:way:~
仕様:spec:~
代表的:typical:~
作者:author:~
便宜性:facilities:~
実際:actual:~
既定の:default:~
既定:default:~
	既定でない:non-default
特別:special:~
特定0の:particular:ある特定の
目的:purpose:~
通例的:usual:~
適用-:apply:~
方式:manner:~
明示的:explicit:~
漠然:nebulous:~
	-:condition:~
簡便:convenient:~
体験:experience:~
適切:appropriate:~
問題:problem:~
助言的:advisory:~
非公式:informal:~
明瞭:clear:~
情報:information:~
精確:precise:~
	精確を期すため:for precision
	とは限らない:necessarily
	必要-:need
	:optionally
	しかしながら，:however
	したがって:therefore
	したがって:thus
	べき:should
	素朴:naïve
	〜から:perspective
	例:example

	●仕様（動詞
奨励-:encourage:~
定義-:define:~
	きちんと定義され:well-defined
定義:definition:~
実装-:implement:~
実装:implementation:~
指定-:specify:~
	unspecified
指示-:indicate:~
挙動:behavior:ふるまい
供-:provide:~
最適化:optimization:~
望む:wish する:~
欲され:desireされ:~
濫用-:abuse:~
無視-:ignore:~
相違-:differ:~
確保-:ensure:~
確認-:confirm:~
示唆-:suggest:~
解放-:free:~
要求-:require:~
述べた:describe した:~
記述:description:~
試みな:attempt しな:~
試み:attempt:~
説明-:explain:~
達成-:achieve:~
避ける:avoid する:~
働く:work する:~
利用-:use:~
利用者:user:~
制約-:restrict:~
制約:restriction:~
制限-:limit:~
	食い違いが生じる:disagree
影響-:affect:~
意味-:mean:~
意味:meaning:~
意図-:intend:~
意図的:intentional:~
拒否-:refuse:~
求める:want する:~
配備-:deploy:~
	配備-済みの:deployed
協調-:coordinate:~
導出-:derive:~
許容-:allow:~
関係-:relate:~
	relation
防止-:prevent:~
	-:involve
	課す:place:~
	ものではない:not meant
	meant
	抵触する:hit
	代替わりする:bring 〜 into being to take the place of
	元々利用者から渡された:passed around by users
	〜に基づく:based
	見よ:see
	-:except
	呼応して:in response to
	keeping track
	させ易く:help
	あらためて:afresh

	●未分類（動詞
共有-:share:~
参照-:reference:~
反映-:reflect:~
包含-:contain:~
増加-:increase:~
差挟む:interleave する:差し挟む
	相違-:compare:~
表現-:represent:~
見出す:find する:~
見出した:find した:~
追加-:add:~
	追加の:additional
	加えて:in addition
提出:submission::~
	-:begin:~
	含-:include
	含めて:including
	あてがう:prefill
	-:corresponding
	示す:show
	起こる:happen
	塗り直す:repaint
	bookmarking
	having
	乗っ取る:hijack
	購入:purchase
	入れる／:put
	said
	取出して:pull して

	●未分類
DOM:
block::::ブロック
bookmark:
browser::::ブラウザ
	-:buffer
command::::コマンド
data::::データ
database::::データベース
game::::ゲーム
source::::ソース
iframe-srcdoc:iframe srcdoc
	表:table
timer::::タイマー
	-:common
先祖:ancestor:~
共同:joint:~
内容:content:~
	-:output:~
単純:simple:~
同期:synchronization:~
同胞:sibling:~
和集合:union:~
完全:complete:~
	座標:coordinate
担当の:responsible:~
	責を負う:responsible
時系列的:chronological:~
段落:paragraph:~
	種類:kind
等価:equivalent:~
範囲:range:~
精確:precise:~
	精確を期すため:for precision:~
自動的:automatic:~
要素:element:~
連列:sequence:~
	連続する:consecutive
連続的:contiguous:~
	-:duplicate
長さ:length:~
	~blocker
	〜の代わりに:instead
	より高速:faster
	~Location~obj設定子により~Location-object-setter
	~Location~objにより:~Location-object
	と違って:contrary to
	更には:furthermore
	~~記憶:memory
	線:line
	一本道:linear
	非:non-
	-:per
	point
	立て続けに:rapid succession
	-:respective
	できるだけ早く:as soon as possible
	平坦:flat
	組:tuple
	頻繁過ぎる:too-frequent
	巨大過ぎる:over-large
	失敗かも:possibleFailure

	●指示語
新たな:new:~
近過去:recent:~
	最も近過去に:most recently
最近の:latest:~
全部的:full:~
	結果:result
	結果の:resulting
	様な:look
	:main
	介:via
	通:through
	いくぶん:somewhat
	あるいは:alternately
	自身:itself
	常に:always
	もっぱら:purely
	単に:merely
	小さな:minor
	同様:similarly
	複数の:multiple
	最初の:first
	最後の:last
	-:subsequent
	-:single:~
	後者:latter
	ほとんど:most
	この:this
	これらの:these
	すべての:all
	その:that
	そのような:such
	それら:they
	それらの:their
	それらの:those
	それらを:them
	上:above
	下:below
	両者:both
	0:zero
	2:two
	もう一つ:second
	他の:other
	-:otherwise
	以前／一つ前の:previous
	何か:something
	nothing
	依然として:still
	元々:originally
	元の:original
	再度:again
	別の:another
	別個の:distinct
	各:each
	同じ:same
	後:after
	-:newly
	次:next
	異なる:different
	等々:etc
	全体:whole
	後で／:later
	最も早期の:earliest
	一足飛びに:jumps straight
	直後:immediately after


●●original_id_map


dom-window-history:dom-history
dom-window-location:dom-location

	number-of-document-tree-child-browsing-contexts:number-of-child-browsing-contexts
	serialized-state:state-object


●●words_table1


HTMLWPROXY:HTML-windowproxy-ja.html
	Assert:<b>Assert</b>

document-domain:<code>document.domain</code> 
length0:length
location0:location
iframe: <code class="element">iframe</code> 
Location: <code>Location</code> 


●●link_map



	●IDL Interface/Dictionary
I.Document:~HTMLdom#document
I.History:#history-3
I.Location:#location
I.ScrollRestoration:#scrollrestoration
I.Window:~WINDOW#window
I.DOMStringList:~HTMLcdom#domstringlist

	●Error
E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror
E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror


	■#dom-member
l.auto:#dom-scrollrestoration-auto
l.manual:#dom-scrollrestoration-manual

m.isTrusted:~DOM4#dom-event-istrusted

m.history:#dom-window-history
m.back:#dom-history-back
m.forward:#dom-history-forward
m.go:#dom-history-go
m.length:#dom-history-length
m.pushState:#dom-history-pushstate
m.replaceState:#dom-history-replacestate
m.scrollRestoration:#dom-history-scroll-restoration
m.state:#dom-history-state

m.location:#dom-window-location
m.~location0:#dom-document-location
m.document.location:#dom-document-location
m.window.location:#dom-window-location

m.ancestorOrigins:#dom-location-ancestororigins
m.assign:#dom-location-assign
m.hash:#dom-location-hash
m.host:#dom-location-host
m.hostname:#dom-location-hostname
m.href:#dom-location-href
m.location.reload:#dom-location-reload
m.origin:#dom-location-origin
m.pathname:#dom-location-pathname
m.port:#dom-location-port
m.protocol:#dom-location-protocol
m.reload:#dom-location-reload
m.replace:#dom-location-replace
m.search:#dom-location-search


	●event
et.click:~UIEVENTS#event-type-click
et.hashchange:~HTMLindex#event-hashchange
et.resize:~CSSOMVIEW#eventdef-window-resize

	●要素
e.a:~HEtextlevel#the-a-element
e.div:~HEgrouping#the-div-element
e.head:~HEmetadata#the-head-element
e.title:~HEmetadata#the-title-element
e.area:~HEimages#the-area-element
e.iframe:~HEembed#the-iframe-element
e.script:~HEscripting#the-script-element

	●内容属性
a.dir:~HTMLdom#the-dir-attribute

	●code
sc.about_blank:~HTMLdep#about:blank

	●
~window:~WINDOW#the-window-object
文書:~HTMLdom#the-document-object

	●閲覧文脈
閲覧文脈:~BROWSERS#browsing-context
閲覧文脈~名:~BROWSERS#browsing-context-name
属する閲覧文脈:~BROWSERS#concept-document-bc
属する文書:~BROWSERS#concept-document-bc
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
閲覧文脈~容器:~BROWSERS#browsing-context-container
入子の閲覧文脈:~BROWSERS#nested-browsing-context
親~閲覧文脈:~BROWSERS#parent-browsing-context
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
作動中の文書:~BROWSERS#active-document
作動中:~BROWSERS#active-document
文書~族:~BROWSERS#document-family
全部的に作動中:~BROWSERS#fully-active
互いに関係する閲覧文脈~群:~BROWSERS#unit-of-related-browsing-contexts

	●WINDOW
対応する閲覧文脈:~WINDOW#_concept-window-bc
結付けられている文書:~WINDOW#concept-document-window
doc.破棄-:#discard-a-document

	●ORIGIN
生成元:~ORIGIN#concept-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
同一生成元:~ORIGIN#same-origin
同じ生成元~domain:~ORIGIN#same-origin-domain

	●history
	§:#history
	§:#the-session-history-of-browsing-contexts
	:#_contiguous
	§:#the-history-interface
	§:#history-1
	§:#history-notes
	§:#the-location-interface

~session履歴:#session-history
~session履歴~entry:#session-history-entry
	m.history
直列形の状態:#serialized-state
現在の~entry:#current-entry
持続的な利用者~状態を伴う:#an-entry-with-persisted-user-state
~scroll復旧~mode:#scroll-restoration-mode
最近の~entry:#latest-entry

共同~session履歴:#joint-session-history
共同~session履歴の現在の~entry:#current-entry-of-the-joint-session-history
~session履歴~走査~queue:#session-history-traversal-queue
~session履歴~event-loop:#session-history-event-loop
履歴を前／後に走査する:#traverse-the-history-by-a-delta
~URLと履歴を更新する:#url-and-history-update-steps

Loc.対応する閲覧文脈:#_concept-location-bc
Loc.関連する文書:#relevant-document
Loc.~url:#concept-location-url
先祖~生成元~list:#concept-location-ancestor-origins-list
~Location~obj設定子により~navigateする:#location-object-setter-navigate
~Location~objにより~navigateする:#location-object-navigate
生成元~domainを検査する:#_location-security-check


	●NAVI
~navigate:~NAVI#navigate
~navi:~NAVI#navigate
置換~可能化~flag:~NAVI#replacement-enabled
例外~可能化~flag:~NAVI#exceptions-enabled
~source閲覧文脈:~NAVI#source-browsing-context
文書を~unloadする:~NAVI#unload-a-document
文書の~unloadを~promptする:~NAVI#prompt-to-unload-a-document
~unloadは利用者から拒否された:~NAVI#refused-to-allow-the-document-to-be-unloaded
履歴を走査する:~NAVI#traverse-the-history
履歴の走査:~NAVI#traverse-the-history
V.履歴~navi~flag:~NAVI#history-navigation-flag
再読込みにより誘発され:~NAVI#reload-triggered-navigation
成熟-:~NAVI#concept-navigate-mature
~entry更新-:~NAVI#entry-update


	●INFRA
~list:~INFRA#list
付加する:~INFRA#list-append

	●WAPI
入口~設定群~obj:~WAPI#entry-settings-object
現任の設定群~obj:~WAPI#incumbent-settings-object
関連する設定群~obj:~WAPI#relevant-settings-object
関連する~Realm:~WAPI#concept-relevant-realm
関連する大域~obj:~WAPI#concept-relevant-global
~task:~WAPI#concept-task
現在~走っている~task:~WAPI#currently-running-task
~taskを~queueする:~WAPI#queue-a-task
~task源:~WAPI#task-source
履歴~走査~task源:~WAPI#history-traversal-task-source
~event-loop:~WAPI#event-loop

enV.担当の閲覧文脈:~WAPI#responsible-browsing-context
enV.生成元:~WAPI#concept-settings-object-origin

	●HTML
並列的:~HTMLINFRA#in-parallel

相対的に構文解析-:~HTMLurl#parse-a-url
結果の~URL~record:~HTMLurl#resulting-url-record
	
jA.StructuredSerializeForStorage:~HTMLcloning#structuredserializeforstorage
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
逆直列化-:~HTMLcloning#structureddeserialize

~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document
完全に読込まれ:~HTMLparsing#completely-loaded
	~scriptに返される:~HTMLindex#event-popstate
~iframeの属性を処理する:~HEembed#process-the-iframe-attributes

	●URL1
~URL:~URL1#concept-url
~URL~record:~URL1#concept-url-record
	~hostとして同等:~URL1#concept-host-equals
基本~URL構文解析器:~URL1#concept-basic-url-parser
~hostを直列化する:~URL1#concept-host-serializer
~URLを直列化する:~URL1#concept-url-serializer
~cannot-be-a-base-URL~flag:~URL1#url-cannot-be-a-base-url-flag
~username／~password／~portを持てない:~URL1#cannot-have-a-username-password-port

url.~host:~URL1#concept-url-host
url.~path:~URL1#concept-url-path
url.~port:~URL1#concept-url-port
url.~query:~URL1#concept-url-query
url.~scheme:~URL1#concept-url-scheme
url.素片:~URL1#concept-url-fragment
url.生成元:~URL1#concept-url-origin
url.既定の~port:~URL1#default-port
整数を直列化する:~URL1#serialize-an-integer

url.~host~state:~URL1#host-state
url.~hostname~state:~URL1#hostname-state
url.~path開始-~state:~URL1#path-start-state
url.~port~state:~URL1#port-state
url.~query~state:~URL1#query-state
url.~scheme開始-~state:~URL1#scheme-start-state
url.素片~state:~URL1#fragment-state

~HTTP_S~scheme:~FETCH#http-scheme

	●

doc.文字~符号化法:~DOM4#concept-document-encoding
doc.~URL:~DOM4#concept-document-url
作動化の挙動:~DOM4#eventtarget-activation-behavior


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
Loading Web pages 章の
<a href="~SPEC_URL">Session history and navigation</a>
節を日本語に翻訳したものです。
~PUB
</p>

</script>

<body>

<header>
	<hgroup>
<h1>セッション履歴とナビ</h1>

	</hgroup>

</header>

<hr>

<main id="MAIN" style="display:none;">


		<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ε, 此れ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="history">
<h2 title="Session history and navigation">7.7. ~session履歴と~navi</h2>


			<section id="the-session-history-of-browsing-contexts">
<h3 title="The session history of browsing contexts">7.7.1. 閲覧文脈の~session履歴</h3>

<div class="p">
<p>
`閲覧文脈$ %B に`属する文書$たちからなる連列は、
%B の`~session履歴$を成す†。
`入子の閲覧文脈$を含め，どの`閲覧文脈$も、互いに別個の`~session履歴$を有する。
各
`~session履歴@
は，何個かの`~session履歴~entry$からなる平坦な~listである。
</p>

<p class="trans-note">【†
この記述は、文書と~session履歴~entryとを同一視している。
しかしながら、複数の~entryが同じ文書に対応し得る。
】</p>

<p>
各
`~session履歴~entry@
は，次のものからなる
⇒＃
`~URL$,
`直列形の状態$,
~title,
`文書$,
~form~data,
`~scroll復旧~mode$,
~scroll位置,
`閲覧文脈~名$
</p>

<p>
これらのうち，`~URL$のみが必須とされる。
各~entryには、これら以外の情報も結付けられ得る。
</p>

◎
The sequence of Documents in a browsing context is its session history. Each browsing context, including nested browsing contexts, has a distinct session history. A browsing context's session history consists of a flat list of session history entries. Each session history entry consists, at a minimum, of a URL, and each entry may in addition have serialized state, a title, a Document object, form data, a scroll restoration mode, a scroll position, a browsing context name, and other information associated with it.
</div>


<p class="note">注記：
各~entryは、最初に作成された時点で`文書$が結付けられるが、`文書$が`作動中$でないときは，資源を解放するため`破棄-$docされることもある。
`~session履歴~entry$内の`~URL$その他の~dataは、~UAが その`文書$を再び作動化する必要があると見出した場合に，元のものから新たな`文書$に代替わりするときに利用される。
◎
Each entry, when first created, has a Document. However, when a Document is not active, it's possible for it to be discarded to free resources. The URL and other data in a session history entry is then used to bring a new Document into being to take the place of the original, in case the user agent finds itself having to reactivate that Document.
</p>

<p class="note">注記：
`~session履歴~entry$の~titleは、`文書$の現在の `title$e に関係する必要はない。
この~titleが意図する所は、利用者が文書の履歴を~navigateできるよう，その時点での文書の状態を説明するためにある。
◎
Titles associated with session history entries need not have any relation with the current title of the Document. The title of a session history entry is intended to explain the state of the document at that point, so that the user can navigate the document's history.
</p>

<p>
`直列形の状態$が結付けられていない~URLは、利用者が（または~scriptにより）頁から頁へ~navigateするに伴い，~session履歴に追加される。
◎
URLs without associated serialized state are added to the session history as the user (or script) navigates from page to page.
</p>


<hr>

<p>
`閲覧文脈$の`~session履歴$内の各 `文書$には、一意な `History$I ~objが結付けられる
— そのいずれも、同じ下層の`~session履歴$を~model化し~MUST。
◎
Each Document object in a browsing context's session history is associated with a unique History object which must all model the same underlying session history.
</p>


<p class="idl-def">
`~window$上の
`history@m
属性の取得子は、此れに`結付けられている文書$に結付けられている `History$I ~objを返さ~MUST。
◎
The history attribute of the Window interface must return the object implementing the History interface for this Window object's associated Document.
</p>


<hr>

<p>
`直列形の状態@
は、~UI状態を表現している~objを（ `StructuredSerializeForStorage$jA を介して）直列化したものである。
非公式には、
“状態~obj”
と呼ばれることもある
— それは、［
作者から給された，~UI状態を表現している~obj
］，あるいは［
`直列形の状態$を（ `StructuredDeserialize$jA を介して）逆直列化して作成される~obj
］を表す。
◎
Serialized state is a serialization (via StructuredSerializeForStorage) of an object representing a user interface state. We sometimes informally refer to "state objects", which are the objects representing user interface state supplied by the author, or alternately the objects created by deserializing (via StructuredDeserialize) serialized state.
</p>


<p>
頁は、~session履歴に`直列形の状態$を<a href="#dom-history-pushstate">追加できる</a>。
これは、利用者（または~script）が履歴~内を後戻したときに，`逆直列化-$された上で
<a href="~HTMLindex#event-popstate">~scriptに返される</a>。
したがって、 1 頁だけの~appにおいても，作者が “~navi” の~metaphorを利用できるようにする。
◎
Pages can add serialized state to the session history. These are then deserialized and returned to the script when the user (or script) goes back in the history, thus enabling authors to use the "navigation" metaphor even in one-page applications.
</p>

<div class="note">

<p>注記：
`直列形の状態$には、主に二つの用途が意図されている：
◎
Serialized state is intended to be used for two main purposes:＼
</p>

<ul>
	<li>
一つは、予め構文解析した状態の記述を `~URL$と一緒に格納して，単純な事例では 作者が構文解析せずに済むようにすること（元々利用者から渡された`~URL$を取扱うときは，依然として それを構文解析する必要があるので、これは小さな最適化に過ぎない）。
◎
first, storing a preparsed description of the state in the URL so that in the simple case an author doesn't have to do the parsing (though one would still need the parsing for handling URLs passed around by users, so it's only a minor optimization).＼
</li>
	<li>
もう一つは、他からは格納されない状態
— 現在の`文書$~instanceにのみ適用され，同じ~URLの`文書$が新たに開かれるときには再構築される必要があるような、状態 —
を，作者が ~URLと一緒に格納できるようにすること。
◎
Second, so that the author can store state that one wouldn't store in the URL because it only applies to the current Document instance and it would have to be reconstructed if a new Document were opened.
</li>
</ul>

<p>
後者の用例には、次が挙げられる：
◎
An example of the latter would be＼
</p>

<ul>
	<li>
利用者が後戻するときに、以前に~animateさせていた~popup `div$e を，同じ所在から~animateし続けれるよう，精確に協調するように追跡する。
◎
something like keeping track of the precise coordinate from which a pop-up div was made to animate, so that if the user goes back, it can be made to animate to the same location.＼
</li>
	<li>
［［
`~URL$ 内の情報に基づいて~serverから~fetchされるような~data
］の~cache
］の中への~pointerを保っておいて、後戻する／先進するときに，その情報を再度~fetchせずに済むようにする。
◎
Or alternatively, it could be used to keep a pointer into a cache of data that would be fetched from the server based on the information in the URL, so that when going back and forward, the information doesn't have to be fetched again.
</li>
</ul>
</div>

<hr>

<p>
どの時点においても，`~session履歴$内のある 1 つの~entryが
`現在の~entry@
になる。
これは、`閲覧文脈$にて`作動中の文書$を表現している~entryになる。
どの~entryが`現在の~entry$になるかは、この仕様に定義される~algo
— 例えば`履歴を走査する$間など —
により変更される。
◎
At any point, one of the entries in the session history is the current entry. This is the entry representing the active document of the browsing context. Which entry is the current entry is changed by the algorithms defined in this specification, e.g. during session history traversal.
</p>

<p class="trans-note">【
`作動中の文書$は常にあるので、~session履歴が空になることはない。
】</p>

<p class="note">注記：
`現在の~entry$は，通例的には`文書$の`~URL$doc用の~entryであるが、その文書により履歴に追加されたいずれかの`直列形の状態$用の~entryにもなり得る。
◎
The current entry is usually an entry for the URL of the Document. However, it can also be one of the entries for serialized state added to the history by that document.
</p>

<p>
~UAにより定義される状態も持つような~entryは、
`持続的な利用者~状態を伴う@
とされる。
どのような種類の状態を格納し得るかは、この仕様では，指定しない。
◎
An entry with persisted user state is one that also has user-agent defined state. This specification does not specify what kind of state can be stored.
</p>

<p class="example">
例えば、~scroll位置や，~form~controlの値を持続化しようと求める~UAもある。
◎
For example, some user agents might want to persist the scroll position, or the values of form controls.
</p>

<p class="note">注記：
~form~controlの値を持続化する~UAには、それらの書字方向性（要素の `dir$a 属性~値）も持続化することが奨励される。
これは、［
明示的かつ既定でない書字方向性の下で，利用者が元々手入力した値
］が，履歴の走査~後に不正に表示されることを防止する。
◎
User agents that persist the value of form controls are encouraged to also persist their directionality (the value of the element's dir attribute). This prevents values from being displayed incorrectly after a history traversal when the user had originally entered the values with an explicit, non-default directionality.
</p>

<p>
~entryの
`~scroll復旧~mode@
は、~UAがその~entryへ走査したとき，持続的な~scroll位置（もしあれば）を復旧するべきかどうかを指示する。
~scroll復旧~modeは次のいずれかをとり得る：
◎
An entry's scroll restoration mode indicates whether the user agent should restore the persisted scroll position (if any) when traversing to it. The scroll restoration mode may be one of the following:
</p>

<dl class="def-list">
	<dt>`auto@l</dt>
	<dd>
~UAが、~naviに際して~scroll位置を復旧する責を負う。
◎
The user agent is responsible for restoring the scroll position upon navigation.
</dd>

	<dt>`manual@l</dt>
	<dd>
頁が、~naviに際して~scroll位置を復旧する責を負う。
~UAは、それを自動的に試みない。
◎
The page is responsible for restoring the scroll position and the user agent does not attempt to do so automatically
</dd>
</dl>

<p>
指定されていない場合、新たな~entryの`~scroll復旧~mode$は `auto$l に設定され~MUST。
◎
If unspecified, the scroll restoration mode of a new entry must be set to "auto".
</p>

<p>
`直列形の状態$を包含する各~entryは、その追加-時に作動中であった頁~用の~entryと同じ`文書$を共有する。
◎
Entries that contain serialized state share the same Document as the entry for the page that was active when they were added.
</p>

<p>
`~URL$の`素片$urlのみ相違するような，連続的な各~entryも、同じ`文書$を共有する。
◎
Contiguous entries that differ just by their URLs' fragments also share the same Document.
</p>

<p id="_contiguous" class="note">注記：
同じ`文書$を共有するすべての~entryは、定義により連続的になる（それらは、単に，特定0の文書の異なる状態たちである）。
◎
All entries that share the same Document (and that are therefore merely different states of one particular document) are contiguous by definition.
</p>

<p>
`閲覧文脈$ %B に`属する文書$ %文書 の
`最近の~entry@
とは、［
%B の`~session履歴$内の~entry
］のうち［
~entryの`文書$ ~EQ %文書
］なるもの
］があれば、それらのうち最も近過去に走査された~entryである。
そのような~entryがなければ（`文書$の作成-時）、
ε （なし）とする。
◎
Each Document in a browsing context can also have a latest entry. This is the entry for that Document to which the browsing context's session history was most recently traversed. When a Document is created, it initially has no latest entry.
</p>

<p>
~UAは、`~session履歴$内の~entry %entry に対しては：
</p>

<ul>
	<li>
［
%entry は`現在の~entry$でない
］~AND［
%entry は どの~scriptからも参照されていない
］ならば、 %entry の`文書$を，`破棄-$docしてよい
— 利用者／~scriptがそのような頁に~navigateして戻ったときは，頁を再読込みすることになる。
この仕様は、~UAがいつ`文書$を［
破棄する／~cacheする
］べきかについては指定しない。
◎
User agents may discard the Document objects of entries other than the current entry that are not referenced from any script, reloading the pages afresh when the user or script navigates back to such pages. This specification does not specify when user agents should discard Document objects and when they should cache them.
</li>
	<li>
前項により %entry の`文書$が破棄されたとしても、下に与える各種~algoの目的においては，そうでなかったかのように動作し~MUST。
利用者あるいは~scriptが，~DOM~objを~~記憶していない頁へ~navigateして戻った／進んだときは、同じ`文書$を共有していた他の~entryも，その新たな文書~objを共有し~MUST。
◎
Entries that have had their Document objects discarded must, for the purposes of the algorithms given below, act as if they had not. When the user or script navigates back or forwards to a page which has no in-memory DOM objects, any other entries that shared the same Document object with it must share the new object as well.
</li>
</ul>


			</section>
			<section id="the-history-interface">
<h3 title="The History interface">7.7.2. `History^I ~interface</h3>

<pre class="idl">
enum `ScrollRestoration@I { `auto$l, `manual$l };

[Exposed=Window]
interface `History@I {
  readonly attribute unsigned long `length$m;
  attribute `ScrollRestoration$I `scrollRestoration$m;
  readonly attribute any `state$m;
  void `go$m(optional long %delta = 0);
  void `back$m();
  void `forward$m();
  void `pushState$m(any %data, DOMString %title, optional USVString? %url = null);
  void `replaceState$m(any %data, DOMString %title, optional USVString? %url = null);
};
</pre>

<dl class="domintro">
	<dt>%window . `history$m . `length$m</dt>
	<dd>
`共同~session履歴$内の~entryの個数を返す。
◎
Returns the number of entries in the joint session history.
</dd>

	<dt>%window . `history$m . `scrollRestoration$m [ = %value ]</dt>
	<dd>
`~session履歴$内の現在の~entryの`~scroll復旧~mode$を返す。
◎
Returns the scroll restoration mode of the current entry in the session history.
</dd>
	<dd>
設定して、`~session履歴$内の現在の~entryの`~scroll復旧~mode$を変更できる。
◎
Can be set, to change the scroll restoration mode of the current entry in the session history.
</dd>

	<dt>%window . `history$m . `state$m</dt>
	<dd>
現在の`直列形の状態$を逆直列化した結果の~objを返す。
◎
Returns the current serialized state, deserialized into an object.
</dd>

	<dt>%window . `history$m . `go$m( [ %delta ] )</dt>
	<dd>
`共同~session履歴$内で，指定された段~数だけ後戻する／先進する。
◎
Goes back or forward the specified number of steps in the joint session history.
</dd>
	<dd>
%delta に対する 0 は、現在の頁を再読込みさせることになる。
◎
A zero delta will reload the current page.
</dd>
	<dd>
%delta が範囲~外を指す場合は何もしない。
◎
If the delta is out of range, does nothing.
</dd>

	<dt>%window . `history$m . `back$m()</dt>
	<dd>
`共同~session履歴$内で 1 段だけ後戻する。
◎
Goes back one step in the joint session history.
</dd>
	<dd>
前~頁がない場合は何もしない。
◎
If there is no previous page, does nothing.
</dd>

	<dt>%window . `history$m . `forward$m()</dt>
	<dd>
`共同~session履歴$内で 1 段だけ先進する。
◎
Goes forward one step in the joint session history.
</dd>
	<dd>
次~頁がない場合は何もしない。
◎
If there is no next page, does nothing.
</dd>

	<dt>%window . `history$m . `pushState$m(%data, %title [, %url ] )</dt>
	<dd>
%data, %title を~session履歴に~pushする
— %url が与えられていて ~NULL でなければ それも伴わせて。
◎
Pushes the given data onto the session history, with the given title, and, if provided and not null, the given URL.
</dd>

	<dt>%window . `history$m . `replaceState$m(%data, %title [, %url ] )</dt>
	<dd>
［
%data, %title, %url（省略時は ~NULL ）
］で，~session履歴~内の現在の~entryのそれらを更新する。
◎
Updates the current entry in the session history to have the given data, title, and, if provided and not null, URL.
</dd>
</dl>

<div class="p">
<p>
`~top-level閲覧文脈$ %B の
`共同~session履歴@
とは、［
次を満たす各 `閲覧文脈$ %B1 の`~session履歴$内の~entryうち，その`現在の~entry$以外のもの
］すべての和集合に，`共同~session履歴の現在の~entry$を加えたものである：
</p>

<ul ><li>%B1 の`~top-level閲覧文脈$ ~EQ %B
</li><li>%B1 にて`作動中の文書$は、`全部的に作動中$である
</li></ul>

◎
The joint session history of a top-level browsing context is the union of all the session histories of all browsing contexts of all the fully active Document objects that share that top-level browsing context, with all the entries that are current entries in their respective session histories removed except for the current entry of the joint session history.
</div>


<p>
`共同~session履歴の現在の~entry@
は、それを成す`~session履歴$たちの`現在の~entry$のうち，最も近過去にそうなったものを指す。
◎
The current entry of the joint session history is the entry that most recently became a current entry in its session history.
</p>

<p>
`共同~session履歴$内の各~entryは，各自が属する`~session履歴$に追加された時刻により時系列的に順序付けられ、その順に 1 ずつ増加する整数~indexが付与される
— 最も早期の~entryに付与される~indexは 0 とする。
◎
Entries in the joint session history are ordered chronologically by the time they were added to their respective session histories. Each entry has an index; the earliest entry has index 0, and the subsequent entries are numbered with consecutively increasing integers (1, 2, 3, etc).
</p>

<p class="note">注記：
同じ`閲覧文脈$に`属する文書$たち それぞれの`~event-loop$は，互いに異なり得るので、`共同~session履歴$の実際の状態は，いくぶん漠然としたものになり得る。
例えば、<!-- one unique origin＊ -->同じ生成元に属していた 2 個の同胞 `iframe$e 要素が，同時に別の生成元へ`履歴を走査する$こともあるので、それらの精確な順序は，きちんと定義されないかもしれない。
同様に，互いが他方を後と見出すこともあるため、それぞれにとっての`共同~session履歴$の長さには，食い違いが生じるかもしれない。
◎
Since each Document in a browsing context might have a different event loop, the actual state of the joint session history can be somewhat nebulous. For example, two sibling iframe elements could both traverse from one unique origin to another at the same time, so their precise order might not be well-defined; similarly, since they might only find out about each other later, they might disagree about the length of the joint session history.
</p>


<!-- History -->
<dl class="idl-def">
	<dt>`length@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
</li>
			<li>
~RET `~top-level閲覧文脈$の`共同~session履歴$内の~entryの個数
</li>
		</ol>

◎
The length attribute of the History interface, on getting, must return the number of entries in the top-level browsing context's joint session history. If this History object is associated with a Document that is not fully active, getting must instead throw a "SecurityError" DOMException.
</dd>
	<dd>
~scriptからは、実際の各~entryに~access可能でない。
◎
The actual entries are not accessible from script.
</dd>

	<dt>`scrollRestoration@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
</li>
			<li>
~RET `~session履歴$内の`現在の~entry$の`~scroll復旧~mode$
</li>
		</ol>
◎
The scrollRestoration attribute of the History interface, on getting, must return the scroll restoration mode of the current entry in the session history.＼
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
</li>
			<li>
`~session履歴$内の`現在の~entry$の`~scroll復旧~mode$ ~SET 所与の値
</li>
		</ol>
◎
On setting, the scroll restoration mode of the current entry in the session history must be set to the new value.＼
◎
If this History object is associated with a Document that is not fully active, both getting and setting must instead throw a "SecurityError" DOMException.
</dd>

	<dt>`state@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
</li>
			<li>
~RET ~UAにより設定された最後の値
</li>
		</ol>
◎
The state attribute of the History interface, on getting, must return the last value it was set to by the user agent. If this History object is associated with a Document that is not fully active, getting must instead throw a "SecurityError" DOMException.＼
</dd>
	<dd>
この属性は、初期~時には、値は~NULL にされ~MUST。
◎
Initially, its value must be null.
</dd>

	<dt>`go(delta)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
</li>
			<li>
~IF［
%delta ~NEQ 0
］
⇒
%delta だけ`履歴を前／後に走査する$
</li>
			<li>
~ELSE
⇒
`location.reload()$m ~methodが~callされたかのように動作する
</li>
		</ol>
◎
When the go(delta) method is invoked, if delta is zero, the user agent must act as if the location.reload() method was called instead. Otherwise, the user agent must traverse the history by a delta whose value is delta. If this History object is associated with a Document that is not fully active, invoking must instead throw a "SecurityError" DOMException.
</dd>

	<dt>`back()@m</dt>
	<dd>
被呼出時には、 −1 を引数に `go()$m が~callされたかのように動作し~MUST。
◎
When the back() method is invoked, the user agent must traverse the history by a delta −1. If this History object is associated with a Document that is not fully active, invoking must instead throw a "SecurityError" DOMException.
</dd>

	<dt>`forward()@m</dt>
	<dd>
被呼出時には、 +1 を引数に `go()$m が~callされたかのように動作し~MUST。
◎
When the forward() method is invoked, the user agent must traverse the history by a delta +1. If this History object is associated with a Document that is not fully active, invoking must instead throw a "SecurityError" DOMException.
</dd>
</dl>


<hr>

<p>
各`~top-level閲覧文脈$は、初期~時には空の
`~session履歴~走査~queue@
を持ち，`~task$を追加できる。
◎
Each top-level browsing context has a session history traversal queue, initially empty, to which tasks can be added.
</p>

<p class="algo-head">
各`~top-level閲覧文脈$ %B の作成-時には、その時点から`並列的$に，次の~algoを走らせ~MUST
— この~algoは， %B 用の
`~session履歴~event-loop@
と呼ばれる：
◎
Each top-level browsing context, when created, must begin running the following algorithm, known as the session history event loop for that top-level browsing context, in parallel:
</p>

<ol>
	<li>
%~queue ~LET %B の`~session履歴~走査~queue$
◎
↓</li>
	<li>
<p >
~WHILE 無条件
</p>
		<ol>
			<li>
%~queue が空でなくなるまで待機する
◎
Wait until this top-level browsing context's session history traversal queue is not empty.
</li>
			<li>
%~queue から最初の`~task$を取出して、それを実行する
◎
Pull the first task from this top-level browsing context's session history traversal queue, and execute it.
◎
Return to the first step of this algorithm.
</li>
		</ol>
	</li>
</ol>

<p>
`~session履歴~event-loop$は、`共同~session履歴$内の各 閲覧文脈~間の遷移を協調させ易くするためにある。
特定0の時点に，各 `閲覧文脈$が有する`~event-loop$は、互いに異なり得るので（これは、~UAが`互いに関係する閲覧文脈~群$ごとに複数の`~event-loop$を有するときに起こり得る）、さもなければ，遷移に際し各~event-loop間の同期をとる必要が生じる。
◎
The session history event loop helps coordinate cross-browsing-context transitions of the joint session history: since each browsing context might, at any particular time, have a different event loop (this can happen if the user agent has more than one event loop per unit of related browsing contexts), transitions would otherwise have to involve cross-event-loop synchronization.
</p>

<hr>

<p class="algo-head">
%delta だけ`履歴を前／後に走査する@
ときは、~UAは，当の`~top-level閲覧文脈$の`~session履歴~走査~queue$に，次を走らす`~task$を付加し~MUST：
◎
To traverse the history by a delta delta, the user agent must append a task to this top-level browsing context's session history traversal queue, the task consisting of running the following steps:
</p>

 
<ol>
	<li>
%履歴 ~LET `共同~session履歴$
◎
↓</li>
	<li>
%index ~LET ( `共同~session履歴の現在の~entry$の~index ) ~PLUS %delta
◎
↓</li>
	<li>
~IF［
%index ~NIN { 0 〜 ( %履歴 内の~entry数 ~MINUS 1 ) }
］
⇒
~RET
◎
If the index of the current entry of the joint session history plus delta is less than zero or greater than or equal to the number of items in the joint session history, then return.
</li>
	<li>
%~entry ~LET %履歴 内の［
~index ~EQ %index
］なる~entry
◎
Let specified entry be the entry in the joint session history whose index is the sum of delta and the index of the current entry of the joint session history.
</li>
	<li>
%B ~LET %~entry の文書が`属する閲覧文脈$<!-- ＊ -->
◎
Let specified browsing context be the browsing context of the specified entry.
</li>
	<li>
~IF［
%B にて`作動中の文書$において、現在，`文書を~unloadする$~algoは走っている
］
⇒
~RET
◎
If the specified browsing context's active document's unload a document algorithm is currently running, return.
</li>
	<li>
<div class="p">
<p>
次のようにされた`~taskを~queueする$：
</p>

<ul ><li>関連する`~event-loop$： %B にて`作動中の文書$のそれ
</li><li>`~task源$： `履歴~走査~task源$
</li><li>走らす手続き： 下に与える手続き
</li></ul>

◎
Queue a task that consists of running the following substeps. The relevant event loop is that of the specified browsing context's active document. The task source for the queued task is the history traversal task source.
</div>

<p>
手続きは次で与えられる：
</p>

		<ol>
			<li>
~IF［
%B を~navigateしようとする進行中の試みがある
］~AND［
%B はまだ`成熟-$していない（すなわち、 %B はまだ，その`文書$を`作動中$にする段を~~終えていない）
］
⇒
その試みを取消す
◎
If there is an ongoing attempt to navigate specified browsing context that has not yet matured (i.e. it has not passed the point of making its Document the active document), then cancel that attempt to navigate the browsing context.
</li>
			<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
			<li>
<p>
~IF［
%文書 ~NEQ %~entry の`文書$
］：
◎
If the specified browsing context's active document is not the same Document as the Document of the specified entry, then run these substeps:
</p>

				<ol>
					<li>
`文書の~unloadを~promptする$( %文書 )
⇒
~IF［
%文書 の`~unloadは利用者から拒否された$
］
⇒
~RET
◎
Prompt to unload the active document of the specified browsing context. If the user refused to allow the document to be unloaded, then return.
</li>
					<li>
`文書を~unloadする$( %文書 )
◎
Unload the active document of the specified browsing context.
</li>
				</ol>
			</li>
			<li>
%B の`履歴を走査する$( %~entry, `履歴~navi~flag$V ~SET ~ON )
◎
Traverse the history of the specified browsing context to the specified entry with the history-navigation flag set.
</li>
		</ol>
	</li>
</ol>

<p>
利用者が`閲覧文脈$を通して~navigateするとき（例えば~browserの戻る／進む~buttonを利用して）、~UAは，利用者により指定される動作に等価な分だけ`履歴を前／後に走査する$ことが要求される。
◎
When the user navigates through a browsing context, e.g. using a browser's back and forward buttons, the user agent must traverse the history by a delta equivalent to the action specified by the user.
</p>

<hr id="history-1"> 

<p>
`~URLと履歴を更新する@
手続きは、所与の
(
`文書$ %文書,
`~URL$ %新~URL,
`直列形の状態$ %直列形の~data （省略時は ε ）,
文字列 %~title （省略時は ε ）,
%状態~push~flag ~IN { `~pushする^i, ε } （省略時は ε ）
)
に対し，次を走らす：
◎
The URL and history update steps, given a Document object document, a URL newURL, an optional serialized state serializedData, and an optional string title, optionally with a state push flag, are:
</p>

<ol>
	<li>
%履歴 ~LET %文書 が`属する閲覧文脈$の`~session履歴$
◎
Let browsingContext be document's browsing context.
	</li><li>
%現~entry ~LET %履歴 の`現在の~entry$
◎
↓</li>
	<li>
%更新する~entry ~LET %現~entry
◎
↓</li>
	<li>
<p>
~IF［
%状態~push~flag ~NEQ ε
］：
◎
If the state push flag is set, then:
</p>
		<ol>
			<li>
<p>
%履歴 内に %現~entry より後に~entryがあれば，それらすべてを除去する
◎
Remove all the entries in browsingContext's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.
</p>

<p class="note">注記：
これは、~UAの~UIに
<a href="#history-notes">影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
			</li>
			<li>
`~top-level閲覧文脈$の`文書~族$内の~EACH ( `文書$ %D ) に対し
⇒
`履歴~走査~task源$から~queueされた`~task$のうち， %D に結付けられているものすべてを除去する
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.
</li>
			<li>
適切になるなら、~UAが持続化しようと望む状態を反映するように，
%現~entry を更新する
— この~entryは、`持続的な利用者~状態を伴う$ものとされる。
◎
If appropriate, update the current entry to reflect any state that the user agent wishes to persist. The entry is then said to be an entry with persisted user state.
</li>
			<li>
%更新する~entry ~SET 新たな`~session履歴~entry$
◎
↓</li>
			<li>
%更新する~entry を %履歴 の中で %現~entry の後に追加する
◎
Add a session history entry entry to the session history, after the current entry, with
</li>
			<li>
%更新する~entry の`~scroll復旧~mode$ ~SET %現~entry の`~scroll復旧~mode$
◎
•↓ newURL as the URL;
• the scroll restoration mode of the current entry in the session history as the scroll restoration mode;
•↓ serializedData as the serialized state, if it is given;
•↓ title as the title, if it is given.
</li>
			<li>
%履歴 の`現在の~entry$ ~SET %更新する~entry
◎
Update the current entry to be this newly added entry.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%更新する~entry は非 `GET^h 要請を表現する（例： それは `POST^h 提出の結果であった）
］
⇒
%更新する~entry を `GET^h 要請を表現するものに更新する
◎
Otherwise, update the current entry in browsingContext's session history so that:
•↓ newURL is the entry's new URL;
•↓ serializedData is the entry's new serialized state, if it is given; otherwise, the current entry's current serialized state is kept;
•↓ title is the entry's new title, if it is given; otherwise, the entry does not have a title;
• it represents a GET request, if it currently represents a non-GET request (e.g. it was the result of a POST submission).
</li>
	<li>
%更新する~entry の`~URL$ ~SET %新~URL
◎
↑</li>
	<li>
~IF［
%直列形の~data ~NEQ ε
］
⇒
%更新する~entry の`直列形の状態$ ~SET %直列形の~data
◎
↑</li>
	<li>
%更新する~entry の~title ~SET %~title
（ %~title ~EQ ε ならば, ~entryに~titleは無い）
◎
↑</li>

	<li>
<p>
%文書 の`~URL$doc ~SET %新~URL
◎
Set document's URL to newURL.
</p>

<p class="note">注記：
これは，［
`閲覧文脈$の`~navi$ ／ `履歴の走査$
］ではないので、
`hashchange$et ~eventは発火されない。
◎
Since this is neither a navigation of the browsing context nor a history traversal, it does not cause a hashchange event to be fired.
</p>
	</li>
</ol>

<dl class="idl-def">
	<dt>`pushState(data, title, url)@m</dt>
	<dt>`replaceState(data, title, url)@m</dt>
	<dd>
`pushState()^m は、状態~obj~entryを履歴に追加する。
◎
The pushState(data, title, url) method adds a state object entry to the history.
</dd>
	<dd>
`replaceState()^m は、履歴~内の`現在の~entry$の［
状態~obj, ~title, （ %url が与えられていれば）`~URL$
］を更新する。
◎
The replaceState(data, title, url) method updates the state object, title, and optionally the URL of the current entry in the history.
</dd>
	<dd>
<p>
これらの~methodの被呼出時には、次を走らせ~MUST：
◎
When either of these methods is invoked, the user agent must run the following steps:
</p>

		<ol>
			<li>
%文書 ~LET 此れを結付けている`文書$
◎
Let document be the unique Document object this History object is associated with.
</li>
			<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, throw a "SecurityError" DOMException.
</li>
			<li>
<p>
~UAの任意選択で
⇒
~RET
</p>

<p>
（例えば~UAは、これらの~methodの~callを，［
~timer ／
利用者による明瞭な動作に呼応して誘発されたものではない~event~listener
］によるものである場合や,
立て続けに呼出された場合には、不許可にできる。）
</p>
◎
Optionally, return. (For example, the user agent might disallow calls to these methods that are invoked on a timer, or from event listeners that are not triggered in response to a clear user action, or that are invoked in rapid succession.)
</li>
			<li>
%宛先~Realm ~LET 此れに`関連する~Realm$
◎
Let targetRealm be this History object's relevant Realm.
</li>
			<li>
%直列形の~data ~LET `StructuredSerializeForStorage$jA( %data )
（例外投出あり）
◎
Let serializedData be StructuredSerializeForStorage(data). Rethrow any exceptions.
</li>
			<li>
%新~URL ~LET %文書 が`属する閲覧文脈$の`~session履歴$内の`現在の~entry$の`~URL$
◎
Let newURL be the URL of the current entry in browsingContext's session history.
</li>
			<li>
<p>
~IF［
%url ~NEQ ~NULL
］：
◎
If url is not null, then:
</p>
				<ol>
					<li>
%新~URL ~SET %url を此れに`関連する設定群~obj$に`相対的に構文解析-$した結果
◎
Parse url, relative to the relevant settings object of this History object.
</li>
					<li>
~IF［
%新~URL ~EQ `失敗^i
］
⇒
~THROW `SecurityError$E
◎
If that fails, then throw a "SecurityError" DOMException.
◎
Set newURL to the resulting URL record.
</li>
					<li>
%文書~URL ~LET %文書 の`~URL$doc
◎
↓</li>
					<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~THROW `SecurityError$E
：
◎
↓</p>
						<ul>
							<li>
［
%新~URL, %文書~URL
］の［
`~path$url, `~query$url, `素片$url
］以外のある成分が相違する
◎
Compare newURL to document's URL. If any component of these two URL records differ other than the path, query, and fragment components, then throw a "SecurityError" DOMException.
</li>
							<li>
<p>
次の両者が満たされる：
</p>

<ul><li>
( %新~URL の`生成元$url, %文書 の`生成元$ )
は`同一生成元$でない
</li><li>［
%新~URL, %文書~URL
］の［
`~path$url, `~query$url
］いずれかの成分は相違する
</li></ul>

<p>
（これは、~sandbox化された内容が 同一生成元~上の他の頁を偽装することを防止する。）
</p>
◎
If the origin of newURL is not same origin with the origin of document, and either the path or query components of the two URL records compared in the previous step differ, throw a "SecurityError" DOMException. (This prevents sandboxed content from spoofing other pages on the same origin.)
</li>
						</ul>
					</li>
				</ol>
			</li>
			<li>
%状態~push~flag ~LET 呼出された~methodに応じて
⇒＃
`pushState()^m ならば `~pushする^i ／
`replaceState()^m ならば ε
◎
↓</li>
			<li>
`~URLと履歴を更新する$( %文書, %新~URL, %直列形の~data, %title, %状態~push~flag )
◎
Run the URL and history update steps given document, newURL, serializedData, and title, with the state push flag set if the method invoked was the pushState() method.
</li>
			<li>
%状態 ~SET `StructuredDeserialize$jA( %直列形の~data, %宛先~Realm )
⇒
例外が投出されたときは、~catchして
⇒
%状態 ~SET ~NULL （例外は無視する）
◎
Let state be StructuredDeserialize(serializedData, targetRealm). If this throws an exception, catch it, ignore the exception, and set state to null.
</li>
			<li>
此れの `state$m 属性 ~SET %状態
◎
Set history.state to state.
</li>
			<li>
%現~entry の`文書$の`最近の~entry$ ~SET %現~entry
◎
Set the current entry's Document object's latest entry to the current entry.
</li>
		</ol>
	</dd>
</dl>


<p class="note">注記：
%title は、もっぱら助言的でしかない。
~UAは，~titleを~UIに利用するかもしれない。
◎
The title is purely advisory. User agents might use the title in the user interface.
</p>

<p>
~UAは、頁ごとに，その~session履歴に追加される状態~objの個数を制限してよい。
頁がこの制限-に抵触した場合、~UAは，新たな~entryが追加された後に，［
その~session履歴~内の~entryのうち，［
当の`文書$
【新たな~entryの文書？】<!-- ＊ -->
用の最初の~entry
］の直後の~entryを除去し~MUST（したがって，状態~履歴は、先に入れたものから抹消されるように動作する（ FIFO ）一方で、~naviに対しては，先に入れたものが最後に残るように動作する（ LIFO ））。
◎
User agents may limit the number of state objects added to the session history per page. If a page hits the UA-defined limit, user agents must remove the entry immediately after the first entry for that Document object in the session history after having added the new entry. (Thus the state history acts as a FIFO buffer for eviction, but as a LIFO buffer for navigation.)
</p>

<div class="example">

<p>
~gameを考える：
利用者は，常に，ある “線” 上のある座標に居て、線に沿って~navigateでき，特定0の座標に対応する頁を~bookmarkすれば後でそこへ戻れるとする。
◎
Consider a game where the user can navigate along a line, such that the user is always at some coordinate, and such that the user can bookmark the page corresponding to a particular coordinate, to return to it later.
</p>

<p>
そのような~gameの，位置 x=5 を実装している静的な頁として、次の様なものがあるとする：
◎
A static page implementing the x=5 position in such a game could look like the following:
</p>

<pre class="html-code">
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 5 に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"&gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"&gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
</pre>
<!-- 
<!DOCTYPE HTML>
<!-&45; this is https://example.com/line?x=5 -&45;>
<title>Line Game - 5</title>
<p>You are at coordinate 5 on the line.</p>
<p>
 <a href="?x=6">Advance to 6</a> or
 <a href="?x=4">retreat to 4</a>?
</p>
-->
<p>
そのような~systemにおいて問題になるのは、利用者が~clickするたびに，頁~全体の再読込みを要することである。
次に、~scriptを利用して同じことをする別の仕方を示す：
◎
The problem with such a system is that each time the user clicks, the whole page has to be reloaded. Here instead is another way of doing it, using script:
</p>

<pre class="html-code">
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 &lt;span id="coord"&gt;5&lt;/span&gt; に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"
   onclick="go(1); return false;"
 &gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"
   onclick="go(-1); return false;"
 &gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
&lt;script&gt;
 var %currentPage = 5; /* <span class="comment"
>~serverからあてがわれる
◎
prefilled by server
</span> */
 function go(%d) {
   setupPage(%currentPage + %d);
   history.pushState(%currentPage, document.title, '?x=' + %currentPage);
 }
 onpopstate = function(%event) {
   setupPage(%event.state);
 }
 function setupPage(%page) {
   %currentPage = %page;
   document.title = 'Line Game - ' + %currentPage;
   document.getElementById('coord').textContent = %currentPage;
   document.links[0].href = '?x=' + (%currentPage + 1);
   document.links[0].textContent = 'Advance to ' + (%currentPage + 1);
   document.links[1].href = '?x=' + (%currentPage - 1);
   document.links[1].textContent = 'retreat to ' + (%currentPage - 1);
 }
&lt;/script&gt;
</pre>

<!-- 
<!DOCTYPE HTML>
&lt;!-&45; this starts off as https://example.com/line?x=5 &45;-&gt;
<title>Line Game - 5</title>
<p>You are at coordinate <span id="coord">5</span> on the line.</p>
<p>
 <a href="?x=6" onclick="go(1); return false;">Advance to 6</a> or
 <a href="?x=4" onclick="go(-1); return false;">retreat to 4</a>?
</p>
<script>
 var currentPage = 5; // prefilled by server

-->

<p>
これは、~scriptの~supportを切っている~systemにおいても，依然として先掲の例の様に働くが、
<em>切っていない</em> 利用者は，ずっと高速に~navigateできるようになる
— 同じ体験に対し~network~accessはないので。
更には、~scriptに基づく素朴な~approachによる利用者~体験と違って，~session履歴を
~bookmarkする／~navigateする
のも依然として働く。
◎
In systems without script, this still works like the previous example. However, users that do have script support can now navigate much faster, since there is no network access for the same experience. Furthermore, contrary to the experience the user would have with just a naïve script-based approach, bookmarking and navigating the session history still work.
</p>

<p>
上の例において、
`pushState()$m ~methodに対する %data 引数は，~serverへ送信されることになる情報と同じになるが、利用者が~navigateするたびに~scriptが~URLを構文解析しなくとも済むような，より簡便な形になる。
◎
In the example above, the data argument to the pushState() method is the same information as would be sent to the server, but in a more convenient form, so that the script doesn't have to parse the URL each time the user navigates.
</p>
</div>

<hr />

<div class="example">
<p>
~appは、その時点の`~session履歴~entry$用の~titleに，文書の `title$e 要素の値と同じ値を利用しないこともできる。
例えばここに、 `title$e 要素~内に，ある~blockを示す単純な頁があるとする。
~navigateして以前の状態に後戻しても，利用者の時間は後戻しないので、~session履歴~title内に時刻を入れるのは不適切になるであろう。
◎
Applications might not use the same title for a session history entry as the value of the document's title element at that time. For example, here is a simple page that shows a block in the title element. Clearly, when navigating backwards to a previous state the user does not go back in time, and therefore it would be inappropriate to put the time in the session history title.
</p>

<pre class="html-code">
&lt;!DOCTYPE HTML&gt;
&lt;HTML LANG=EN&gt;
&lt;TITLE&gt;Line&lt;/TITLE&gt;
&lt;SCRIPT&gt;
 setInterval(function () {
   document.title = 'Line - ' + new Date();
 }, 1000);
 var %i = 1;
 function inc() {
   set(%i+1);
   history.pushState(%i, 'Line - ' + i);
 }
 function set(%newI) {
   %i = %newI;
   document.forms.F.I.value = %newI;
 }
&lt;/SCRIPT&gt;
&lt;BODY ONPOPSTATE="set(%event.state)"&gt;
&lt;FORM NAME=F&gt;
   State:
   &lt;OUTPUT NAME=I&gt;1&lt;/OUTPUT&gt;
   &lt;INPUT VALUE="Increment" TYPE=BUTTON ONCLICK="inc()"&gt;
&lt;/FORM&gt;
</pre>

</div>

<div class="example">
<p>
ほとんどの~appは、自身の履歴~entryのすべてに対し，同じ`~scroll復旧~mode$値を利用したいと求める。
そのためには、できるだけ早く `scrollRestoration$m 属性を設定して（例えば、文書の `head$e 要素~内の `script$e 要素で），［
履歴~sessionに追加された~entryが，欲される~scroll復旧~modeを取得する
］ことを確保することにより，達成できる。
◎
Most applications want to use the same scroll restoration mode value for all of their history entries. To achieve this they can set the scrollRestoration attribute as soon as possible (e.g., in the first script element in the document's head element) to ensure that any entry added to the history session gets the desired scroll restoration mode.
</p>

<pre class="html-code">
&lt;head&gt;
  &lt;script&gt;
       if ('scrollRestoration' in history)
            history.scrollRestoration = 'manual';
  &lt;/script&gt;
&lt;/head&gt;
</pre>
</div>


			</section>
			<section id="history-notes">
<h3 title="Implementation notes for session history">7.7.3. ~session履歴~用の実装に対する注記</h3>

~INFORMATIVE

<p>
`History$I ~interfaceは、実装が~session履歴を利用者に向けてどう表現するかについて制約を課すものではない。
◎
The History interface is not meant to place restrictions on how implementations represent the session history to the user.
</p>


<p>
例えば~session履歴を，各~頁が，複数の “~~前方へ~~枝分かれする” 頁を持つ様な方式で実装することもできる。
この仕様は、 `history$m ~obj内の各~頁からなる一本道の~listが利用者からどう見えるかについて，実際の~session履歴から導出する方法は定義しない。
◎
For example, session history could be implemented in a tree-like manner, with each page having multiple "forward" pages. This specification doesn't define how the linear list of pages in the history object are derived from the actual session history as seen from the user's perspective.
</p>

<p>
同様に，ある頁が 2 個の `iframe$e を包含しているとき，頁は各 `iframe$e の `history$m ~objとは別個の `history$m ~objを持つ
— ［
2 個の内縁~frameと外縁~頁の~navi
］を互いに差挟むような~session履歴を伴うような。
代表的な~Web~browserは、利用者に “戻る” ~buttonを 1 個しか呈示しない事実があるにもかかわらず。
◎
Similarly, a page containing two iframes has a history object distinct from the iframes' history objects, despite the fact that typical Web browsers present the user with just one "Back" button, with a session history that interleaves the navigation of the two inner frames and the outer page.
</p>


<p>
<strong>保安</strong>：
ある頁が `pushState()$m を濫用して，~UAの履歴~navi便宜性を
“乗っ取る” のを避けるため、~UAには，以前の頁へ一足飛びに戻る仕方を利用者に供することが示唆される（単に 1 つ前の状態へ後戻するのでなく）。
例えば、戻る~buttonは，~session履歴~内の頁たちだけを示し，他のどの状態も示さないような ~drop-downを持たせることもできる。
同様に，聴覚~browserは、 2 つ前へ “戻る” ~command
— 1 つ前の状態へ後戻するもの, 以前の頁へ一足飛びに戻るもの —
を持たせることもできる。
◎
Security: It is suggested that to avoid letting a page "hijack" the history navigation facilities of a UA by abusing pushState(), the UA provide the user with a way to jump back to the previous page (rather than just going back to the previous state). For example, the back button could have a drop down showing just the pages in the session history, and not showing any of the states. Similarly, an aural browser could have two "back" commands, one that goes back to the previous state, and one that jumps straight back to the previous page.
</p>


<p>
`pushState()$m, `replaceState()$m
いずれに対しても，~UAには、頻繁過ぎる~callや巨大過ぎる状態~objを介するような，
これらの~APIの濫用-を防止することが奨励される。
上に詳細を与えたように，~algoでは、適切になるときは，~UAがそのような~callを無視することも 明示的に許容されている。
◎
For both pushState() and replaceState(), user agents are encouraged to prevent abuse of these APIs via too-frequent calls or over-large state objects. As detailed above, the algorithm explicitly allows user agents to ignore any such calls when appropriate.
</p>



			</section>
			<section id="the-location-interface">
<h3 title="The Location interface">7.7.4. `Location^I ~interface</h3>

<p>
各 `~window$には、その作成-時に，新たな `Location$I ~objが結付けられる。
<!-- unique instance of 〜 allocated -->
</p>

<p class="trans-note">【
以下，ここでは、この節の内容のうち，~APIに関する部分のみ述べる。
他の内容は、
<a href="~HTMLWPROXY#the-location-interface">別ページ</a>
にて。
】</p>


<dl class="domintro">
	<dt>%document . `~location0$m [ = %value ]</dt>
	<dt>%window . `location$m [ = %value ]</dt>
	<dd>
現在の頁の所在を伴う `Location$I ~objを返す。
◎
Returns a Location object with the current page's location.
</dd>
	<dd>
設定して，別の頁へ~navigateできる。
◎
Can be set, to navigate to another page.
</dd>
</dl>


<dl class="idl-def">
	<dt>`document.location@m</dt>
	<dd>
取得子は、［
此れが`全部的に作動中$ならば，此れに`関連する大域~obj$の `Location$I ~obj ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
The Document object's location attribute's getter must return this Document object's relevant global object's Location object, if this Document object is fully active, and null otherwise.
</dd>

	<dt>`window.location@m</dt>
	<dd>
取得子は、此れの `Location$I ~objを返さ~MUST。
◎
The Window object's location attribute's getter must return this Window object's Location object.
</dd>

</dl>



<p>
`Location$I ~objは、それに`対応する閲覧文脈$Locにて`作動中の文書$の`~URL$docを表現し、`閲覧文脈$の~session履歴の`現在の~entry$を，
`history$m ~obj内［
に~entryを追加する ／
の~entryを置換する
］ことを通して 変更できるようにする。
◎
Location objects provide a representation of the URL of the active document of their Document's browsing context, and allow the current entry of the browsing context's session history to be changed, by adding or replacing entries in the history object.
</p>

<pre class="idl">
[Exposed=Window]
interface `Location@I { /* <span class="comment">
ただし、
<a href="~HTMLWPROXY#the-location-interface">追加の作成~手続き</a>
と
<a href="~HTMLWPROXY#location-internal-methods">上書きされた内部~method</a>
も見よ。
◎
but see also additional creation steps and overridden internal methods
</span> */

  [Unforgeable] stringifier attribute USVString `href$m;
  [Unforgeable] readonly attribute USVString `origin$m;
  [Unforgeable] attribute USVString `protocol$m;
  [Unforgeable] attribute USVString `host$m;
  [Unforgeable] attribute USVString `hostname$m;
  [Unforgeable] attribute USVString `port$m;
  [Unforgeable] attribute USVString `pathname$m;
  [Unforgeable] attribute USVString `search$m;
  [Unforgeable] attribute USVString `hash$m;

  [Unforgeable] void `assign$m(USVString %url);
  [Unforgeable] void `replace$m(USVString %url);
  [Unforgeable] void `reload$m();

  [Unforgeable, SameObject] readonly attribute `DOMStringList$I `ancestorOrigins$m;
};
</pre>

<dl class="domintro">
	<dt>%location . `toString()^m</dt>
	<dt>%location . `href$m</dt>
	<dd>
`~url$Locを返す。
◎
Returns the Location object's URL.
</dd>
	<dd>
設定して，所与の~URLへ~navigateできる。
◎
Can be set, to navigate to the given URL.
</dd>

	<dt>%location . `origin$m</dt>
	<dd>
`~url$Locの生成元を返す。
◎
Returns the Location object's URL's origin.
</dd>

	<dt>%location . `protocol$m</dt>
	<dd>
`~url$Locの~schemeを返す。
◎
Returns the Location object's URL's scheme.
</dd>
	<dd>
設定して，`~url$Locの~schemeだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed scheme.
</dd>

	<dt>%location . `host$m</dt>
	<dd>
`~url$Locの［
~host,
~port（~scheme用の`既定の~port$urlと異なるならば）
］を返す。
◎
Returns the Location object's URL's host and port (if different from the default port for the scheme).
</dd>
	<dd>
設定して，`~url$Locの
~host, ~port
だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host and port.
</dd>

	<dt>%location . `hostname$m</dt>
	<dd>
`~url$Locの~hostを返す。
◎
Returns the Location object's URL's host.
</dd>
	<dd>
設定して，`~url$Locの~hostだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host.
</dd>

	<dt>%location . `port$m</dt>
	<dd>
`~url$Locの~port を返す。
◎
Returns the Location object's URL's port.
</dd>
	<dd>
設定して，`~url$Locの~portだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed port.
</dd>

	<dt>%location . `pathname$m</dt>
	<dd>
`~url$Locの~path を返す。
◎
Returns the Location object's URL's path.
</dd>
	<dd>
設定して，`~url$Locの~pathだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed path.
</dd>

	<dt>%location . `search$m</dt>
	<dd>
`~url$Locの~queryを返す（空でないならば 先頭の `?^l も含む）。
◎
Returns the Location object's URL's query (includes leading "?" if non-empty).
</dd>
	<dd>
設定して，`~url$Locの~query（先頭の `?^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed query (ignores leading "?").
</dd>

	<dt>%location . `hash$m</dt>
	<dd>
`~url$Locの素片を返す（空でないならば 先頭の `#^l を含む）。
◎
Returns the Location object's URL's fragment (includes leading "#" if non-empty).
</dd>
	<dd>
設定して，`~url$Locの素片（先頭の `#^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").
</dd>

	<dt>%location . `assign$m(%url)</dt>
	<dd>
%url へ~navigateする。
◎
Navigates to the given URL.
</dd>

	<dt>%location . `replace$m(%url)</dt>
	<dd>
~session履歴から現在の頁を除去した上で，所与の %url へ~navigateする。
◎
Removes the current page from the session history and navigates to the given URL.
</dd>

	<dt>%location . `reload$m()</dt>
	<dd>
現在の頁を再読込みする。
◎
Reloads the current page.
</dd>

	<dt>%location . `ancestorOrigins$m</dt>
	<dd>
`親~閲覧文脈$から`~top-level閲覧文脈$までの各［
先祖`閲覧文脈$の生成元の値
］からなる， `DOMStringList$I ~objを返す。
◎
Returns a DOMStringList object listing the origins of the ancestor browsing contexts, from the parent browsing context to the top-level browsing context.
</dd>
</dl>



<p>
各 `Location$I ~obj %L には、次が定義される：
◎
↓</p>

<dl class="def-list">
	<dt>`対応する閲覧文脈@Loc</dt>
	<dd>
%L を結付けている`~window$に`対応する閲覧文脈$を指す。
</dd>
	<dd class="trans-note">【
この定義は、訳者の推定による。
原文では，
“%L の文書の閲覧文脈” あるいは単に “the 閲覧文脈”
等々としか記されていないが、
%L は`~window$に結付けられるものと定義されているので。
】</dd>

	<dt>`関連する文書@Loc</dt>
	<dd>
%L に`対応する閲覧文脈$Locにて`作動中の文書$を指す。
◎
A Location object has an associated relevant Document, which is this Location object's associated Document object's browsing context's active document.
</dd>

	<dt>`~url@Loc</dt>
	<dd>
%L に`関連する文書$Locの`~URL$docを指す。
◎
A Location object has an associated url, which is this Location object's relevant Document's URL.
</dd>

	<dt>`先祖~生成元~list@</dt>
	<dd>
<p>
%L の作成-時に，次の手続きから得られる文字列の~listが結付けられた
`DOMStringList$I ~objに設定され~MUST：
◎
A Location object has an associated ancestor origins list. When a Location object is created, its ancestor origins list must be set to a DOMStringList object whose associated list is the list of strings that the following steps would produce:
</p>

<ol>
	<li>
%~list ~LET 新たな空`~list$
◎
Let output be a new list of strings.
</li>
	<li>
%L に`対応する閲覧文脈$Loc %B の
~EACH( `先祖~閲覧文脈$ %先祖 ) に対し， %B に近い先祖から順に
⇒
%~list に次の結果を`付加する$
⇒
`生成元を直列化する$( %先祖 にて`作動中の文書$の`生成元$ )
◎
Let current be the browsing context of the Document with which this Location object is associated.
◎
Loop: If current has no parent browsing context, jump to the step labeled end.
◎
Let current be current's parent browsing context.
◎
Append the serialization of current's active document's origin to output.
◎
Return to the step labeled loop.
</li>
	<li>
~RET %~list
◎
End: Return output.
</li>
</ol>
	</dd>
	<dd class="trans-note">【
この仕様の中では、 `ancestorOrigins$m のみから利用される。
service worker からも利用されている。
】</dd>
</dl>


<p class="algo-head">
`~Location~obj設定子により~navigateする@
ときは、所与の
( `Location$I ~obj %L, `~URL~record$ %url )
に対し，次を走らす：
◎
A Location object has an associated Location-object-setter navigate algorithm, which given a url, runs these steps:
</p>

<ol>
	<li>
<p>
%置換~flag ~LET［
次のいずれかが満たされるならば `置換^i ／
~ELSE_ ε
］：
◎
If any of the following conditions are met, let replacement flag be unset; otherwise, let it be set:
</p>
		<ul>
			<li>
%L に`関連する文書$Locは、`完全に読込まれ$ている
◎
This Location object's relevant Document has completely loaded, or
</li>
			<li><!-- ＊？ -->
この~algoを走らせている`~task$は、次を満たす~eventに対する［
`作動化の挙動$を現在~処理して ／ ~event~listenerを取扱って
］いる
⇒
［
名前 `click$et
］~AND［
`isTrusted$m ~EQ ~T
］
◎
In the task in which the algorithm is running, an activation behavior is currently being processed whose click event's isTrusted attribute is true, or
◎
In the task in which the algorithm is running, the event listener for a click event, whose isTrusted attribute is true, is being handled.
</li>
		</ul>
	</li>
	<li>
`~Location~objにより~navigateする$( %L, %url, %置換~flag )
◎
Location-object navigate, given url and replacement flag.
</li>
</ol>


<p class="algo-head">
`~Location~objにより~navigateする@
ときは、所与の
( `Location$I ~obj %L, `~URL~record$ %url, %置換~flag ~IN { `置換^i, ε }（省略時は ε ）)
に対し，次を走らす：
◎
To Location-object navigate, given a url and replacement flag, run these steps:
</p>

<ol>
	<li>
%B ~LET %L に`対応する閲覧文脈$Loc
◎
↓</li>
	<li>
<p>
次を与える下で， %url へ %B を`~navigate$する（例外投出あり）：
</p>

		<ul>
			<li>
`~source閲覧文脈$は、`現任の設定群~obj$により指定される`担当の閲覧文脈$enV
</li>
			<li>
`例外~可能化~flag$ ~SET ~ON
</li>
			<li>
<p>
次のいずれかに該当する場合は、`置換~可能化~flag$ ~SET ~ON：
</p>

<ul ><li>%置換~flag ~NEQ ε
</li><li>%B の`~session履歴$は、 %B の作成-時に作成された `about_blank$sc `文書$のみからなる
</li></ul>

			</li>
		</ul>

◎
• The source browsing context is the responsible browsing context specified by the incumbent settings object.
• Navigate the browsing context to url, with the exceptions enabled flag set. Rethrow any exceptions.
• If the replacement flag is set or the browsing context's session history contains only one Document, and that was the about:blank Document created when the browsing context was created, then the navigation must be done with replacement enabled.
</li>
</ol>

<p class="algo-head">
`Location$I ~obj %L の
`生成元~domainを検査する@
ときは、次を走らす：
</p>

<ol>
	<li>
~IF［
( %L に`関連する文書$Locの`生成元$, `入口~設定群~obj$の`生成元$enV )
は`同じ生成元~domain$でない
］
⇒
~THROW `SecurityError$E
<!-- 
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
 -->
</li>
</ol>

<p class="trans-note">【
この手続きは、以下を簡潔に記すためにこの訳に導入したもの。
】</p>



<dl class="idl-def">

	<dt>`href@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The href attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET `~URLを直列化する$( 此れが指す`~url$Loc )
◎
Return this Location object's url, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The href attribute's setter must run these steps:
</p>

		<ol>
			<li>
%~URL~record ~LET 所与の値を，`入口~設定群~obj$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse the given value relative to the entry settings object.＼
</li>
			<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If that failed, throw a TypeError exception.
</li>
			<li>
`~Location~obj設定子により~navigateする$( 此れ, %~URL~record )
◎
Location-object-setter navigate to the resulting URL record.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
`href$m 属性~設定子に対しては、意図的に保安~検査は行われない。
◎
The href attribute setter intentionally has no security check.
</dd>


	<dt>`origin@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The origin attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET `生成元を直列化する$( 此れが指す`~url$Locの`生成元$url )
◎
Return the serialization of this Location object's url's origin.
</li>
		</ol>
	</dd>

	<dt>`protocol@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The protocol attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET 次を順に連結した結果
⇒
此れが指す`~url$Locの`~scheme$url,<br>
`:^l
◎
Return this Location object's url's scheme, followed by ":".
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The protocol attribute's setter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
%~protocol文字列 ~LET 次を順に連結した結果
⇒
所与の値,<br>
`:^l
◎
↓</li>
			<li>
<p>
%失敗かも ~LET 次を与える下で， %~protocol文字列 を`基本~URL構文解析器$にかけた結果
⇒
~URLと上書stateの組：
( %複製~URL, `~scheme開始-~state$url )
◎
Let possibleFailure be the result of basic URL parsing the given value, followed by ":", with copyURL as url and scheme start state as state override.
</p>
<p class="note">注記：
~URL構文解析器は，連続する~colonを無視するので、値に `https:^l を与えても（あるいは `https::::^l でさえ），
`https^l を与えるのと同じことになる。
◎
Because the URL parser ignores multiple consecutive colons, providing a value of "https:" (or even "https::::") is the same as providing a value of "https".
</p>
			</li>
			<li>
~IF［
%失敗かも ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If possibleFailure is failure, then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%複製~URL の `~scheme$urlは`~HTTP_S~scheme$である
］
⇒
~RET
◎
If copyURL's scheme is not an HTTP(S) scheme, then terminate these steps.
</li>
			<li>
`~Location~obj設定子により~navigateする$( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>


	<dt>`host@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The host attribute's getter must run these steps:
</p>


		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%url ~LET 此れが指す`~url$Loc
◎
Let url be this Location object's url.
</li>
			<li>
~IF［
%url の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If url's host is null, return the empty string.
</li>
			<li>
%~host文字列 ~LET `~hostを直列化する$( %url の`~host$url )
◎
↓</li>
			<li>
~IF［
%url の`~port$url ~EQ ~NULL
］
⇒
~RET %~host文字列
◎
If url's port is null, return url's host, serialized.
</li>
			<li>
~RET 次を順に連結した結果
⇒
%~host文字列,<br>
`:^l,<br>
`整数を直列化する$( %url の`~port$url )
◎
Return url's host, serialized, followed by ":" and url's port, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The host attribute's setter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
~IF［
%複製~URL の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.
</li>
			<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~host~state$url )
◎
Basic URL parse the given value, with copyURL as url and host state as state override.
</li>
			<li>
`~Location~obj設定子により~navigateする$( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>


	<dt>`hostname@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The hostname attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
此れが指す`~url$Locの
`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this Location object's url's host is null, return the empty string.
</li>
			<li>
~RET `~hostを直列化する$( 此れが指す`~url$Locの`~host$url )
◎
Return this Location object's url's host, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The hostname attribute's setter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
~IF［
%複製~URL の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.
</li>
			<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~hostname~state$url )
◎
Basic URL parse the given value, with copyURL as url and hostname state as state override.
</li>
			<li>
`~Location~obj設定子により~navigateする$( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>


	<dt>`port@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The port attribute's getter must run these steps:
</p>
		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
此れが指す`~url$Locの
`~port$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this Location object's url's port is null, return the empty string.
</li>
			<li>
~RET `整数を直列化する$( 此れが指す`~url$Locの`~port$url )
◎
Return this Location object's url's port, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The port attribute's setter must run these steps:
</p>


		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
~IF［
%複製~URL は `~username／~password／~portを持てない$
］
⇒
~RET
◎
If copyURL cannot have a username/password/port, then return.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~port$url ~SET ~NULL
◎
If the given value is the empty string, then set copyURL's port to null.
</li>
			<li>
~ELSE
⇒
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~port~state$url )
◎
Otherwise, basic URL parse the given value, with copyURL as url and port state as state override.
</li>
			<li>
`~Location~obj設定子により~navigateする$( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>

	<dt>`pathname@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The pathname attribute's getter must run these steps:
</p>
		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%url ~LET 此れが指す`~url$Loc
◎
Let url be this Location object's url.
</li>
			<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET %url の`~path$url内の最初の文字列
◎
If url's cannot-be-a-base-URL flag is set, return the first string in url's path.
</li>
			<li>
~IF［
%url の`~path$urlは空である
］
⇒
~RET 空~文字列
◎
If url's path is empty, then return the empty string.
</li>
			<li>
~RET 次を順に連結した結果
⇒
`/^l,<br>
［
%url の`~path$url内の各~文字列（空~文字列も含めて）を `/^l で区切って連結した結果
］
◎
Return "/", followed by the strings in url's path (including empty strings), separated from each other by "/".
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The pathname attribute's setter must run these steps:
</p>
		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
~IF［
%複製~URL の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.
</li>
			<li>
%複製~URL の`~path$url ~SET 空~list
◎
Set copyURL's path to the empty list.
</li>
			<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~path開始-~state$url )
◎
Basic URL parse the given value, with copyURL as url and path start state as state override.
</li>
			<li>
`~Location~obj設定子により~navigateする$( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>

	<dt>`search@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The search attribute's getter must run these steps:
</p>


		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
此れが指す`~url$Locの`~query$url
~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this Location object's url's query is either null or the empty string, return the empty string.
</li>
			<li>
~RET 次を順に連結した結果
⇒
`?^l,<br>
此れが指す`~url$Locの`~query$url
◎
Return "?", followed by this Location object's url's query.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The search attribute's setter must run these steps:
</p>


		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~query$url ~SET ~NULL
◎
If the given value is the empty string, set copyURL's query to null.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise, run these substeps:
</p>


				<ol>
					<li>
%入力 ~LET 所与の値
◎
↓</li>
					<li>
~IF［
%入力 の最初の文字 ~EQ `?^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "?" removed, if any.
</li>
					<li>
%複製~URL の`~query$url ~SET 空~文字列
◎
Set copyURL's query to the empty string.
</li>
					<li>
次を与える下で，%入力 を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~query~state$url ),<br>
%上書き符号化法： 此れに`関連する文書$Locの`文字~符号化法$doc
◎
Basic URL parse input, with copyURL as url and query state as state override, and the relevant Document's document's character encoding as encoding override.
</li>
				</ol>
			</li>
			<li>
`~Location~obj設定子により~navigateする$( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>


	<dt>`hash@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The hash attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
此れが指す`~url$Locの`素片$url
~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this Location object's url's fragment is either null or the empty string, return the empty string.
</li>
			<li>
~RET 次を順に連結した結果
⇒
`#^l,<br>
此れが指す`~url$Locの`素片$url
◎
Return "#", followed by this Location object's url's fragment.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The hash attribute's setter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
%入力 ~LET 所与の値
◎
↓</li>
			<li>
~IF［
%入力 の最初の文字 ~EQ `#^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "#" removed, if any.
</li>
			<li>
%複製~URL の`素片$url ~SET 空~文字列
◎
Set copyURL's fragment to the empty string.
</li>
			<li>
次を与える下で， %入力 を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `素片~state$url )
◎
Basic URL parse input, with copyURL as url and fragment state as state override.
</li>
			<li>
`~Location~obj設定子により~navigateする$( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>


<p class="note">注記：
`a$e, `area$e 要素~用の等価な~APIと違って，
`hash$m 属性の設定子は、［
空~文字列を，配備-済みの~scriptと互換にするよう特別に扱う
］ことはない。
◎
Unlike the equivalent API for the a and area elements, the hash attribute's setter does not special case the empty string to remain compatible with deployed scripts.
</p>
	</dd>


	<dt>`assign(url)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the assign(url) method is invoked, the user agent must run the following steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%~URL~record ~LET %url を，`入口~設定群~obj$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse url relative to the entry settings object.＼
</li>
			<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If that failed, throw a "SyntaxError" DOMException.
</li>
			<li>
`~Location~objにより~navigateする$( 此れ, %~URL~record )
◎
Location-object navigate to the resulting URL record.
</li>
		</ol>
	</dd>


	<dt>`replace(url)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the replace(url) method is invoked, the user agent must run the following steps:
</p>

		<ol>
			<li>
%~URL~record ~LET 
%url を，`入口~設定群~obj$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse url relative to the entry settings object.＼
</li>
			<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If that failed, throw a "SyntaxError" DOMException.
</li>
			<li>
`~Location~objにより~navigateする$( 此れ, %~URL~record, `置換^i )
◎
Location-object navigate to the resulting URL record with the replacement flag set.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
`replace()$m ~methodに対しては、意図的に保安~検査は行われない。
◎
The replace() method intentionally has no security check.
</dd>

	<dt>`reload()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the reload() method is invoked, the user agent must run the appropriate steps from the following list:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin
• Throw a "SecurityError" DOMException.
</li>
			<li>
%B ~LET 此れに`対応する閲覧文脈$Loc
◎
↓</li>
			<li>
<p>
~IF［
現在~実行-中の`~task$†は、利用者による %B の~resizeに呼応して配送された `resize$et ~eventによるものである††
］
⇒
%B を塗り直す†††
◎
If the currently executing task is the dispatch of a resize event in response to the user resizing the browsing context
• Repaint the browsing context and return.
</p>

<p class="trans-note">【†<!-- ＊ -->
`現在~走っている~task$？
】【††
すなわち，この~methodが `resize^et ~event~handlerの中から呼出されたとき？
】【†††
“`repaint^en”
— 単に再~描画するだけ？
】</p>

			</li>
			<li>
~ELIF［
%B にて`作動中の文書$は`~iframe-srcdoc文書$である
］
⇒
`~iframeの属性を処理する$( %B の`閲覧文脈~容器$ )
◎
If the browsing context's active document is an iframe srcdoc document
• Reprocess the iframe attributes of the browsing context's browsing context container.
</li>
			<li>
<p>
~ELSE
⇒
次を与える下で， %B を此れが指す`~url$Locへ`~navigate$して（例外投出あり）、`閲覧文脈$の`現在の~entry$に対し`~entry更新-$を遂行する
⇒＃
`例外~可能化~flag$ ~SET ~ON,
`~source閲覧文脈$ ~SET %B
</p>

<p>
この~naviは、`再読込みにより誘発され$たものとされる。
</p>

◎
Otherwise
• Navigate the browsing context to this Location object's relevant Document's URL to perform an entry update of the browsing context's current entry, with the exceptions enabled flag set. The source browsing context must be the browsing context being navigated. This is a reload-triggered navigation. Rethrow any exceptions.
</li>
		</ol>

	</dd>
	<dd>
<p>
利用者から ~UI要素†を通して［
`閲覧文脈$ %B にて`作動中の文書$ %文書 を再読込みする
］よう要請されたときは、~UAは：
◎
When a user requests that the active document of a browsing context be reloaded through a user interface element,＼
</p>

<p class="trans-note">【†
~browserの “再読込み~button” 等を指すと思われるが，~DOM内の要素も含まれる？
】</p>

		<ul>
			<li>
%B を %文書 と同じ資源へ`~navigate$して，`閲覧文脈$の`現在の~entry$に対し`~entry更新-$を遂行するべきである。
この~naviは、`再読込みにより誘発され$たものとされる。
◎
the user agent should navigate the browsing context to the same resource as that Document, to perform an entry update of the browsing context's current entry. This is a reload-triggered navigation.＼
</li>
			<li>
非冪等~method（例： ~HTTP `POST^meth ）の事例では、~UAは先ず，利用者にその演算を確認してもらうよう~promptするべきである
— さもなければ、~transaction（例：購入や~database改変）が繰返され得るので。
◎
In the case of non-idempotent methods (e.g. HTTP POST), the user agent should prompt the user to confirm the operation first, since otherwise transactions (e.g. purchases or database modifications) could be repeated.＼
</li>
			<li>
［
再読込み時に~cacheを明示的に上書きする
］ことを，利用者に許容してよい。
◎
User agents may allow the user to explicitly override any caches when reloading.
</li>
		</ul>
	</dd>

	<dt>`ancestorOrigins@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The ancestorOrigins attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET 此れの`先祖~生成元~list$
◎
Otherwise, return this Location object's ancestor origins list.
</li>
		</ol>
	</dd>
	<dd class="warning">
`ancestorOrigins$m 属性がどう働くかの詳細は、まだ異論があり，変更され得る。
更なる情報は
<a href="~HTMLissue/1918">issue #1918</a> 
を見よ。
◎
The details of how the ancestorOrigins attribute works are still controversial and might change. See issue #1918 for more information.
</dd>
</dl>


<hr>

<p class="trans-note">【
以下，この節, およびその各 下位節の内容は、
<a href="~HTMLWPROXY#the-location-interface">別ページ</a>
にて。
】</p>


			</section>
		</section>
</main>


