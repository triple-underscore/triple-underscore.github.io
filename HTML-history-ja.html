<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Session history and navigation（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'history',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sbox': // sandboxing flags
	text = `閲覧~文脈~sandbox化( ${key} )~flag`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'jI':
	text = `%${key}%`;
	break;
case 'bP':
	text = `${key}<code>BarProp</code> ~obj`;
	break;
case 'uST': 
	text = `${text} <small>state</small>`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2022-10-06
trans_update:2022-10-07
source_checked:221006
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/history.html
	abbr_url:HISTORY
site_nav:browsers,network,html
nav_prev:ORIGIN
nav_next:NAVI
trans_1st_pub:2016-07-12


●●class_map
e:element
a:attr
et:event-type
sc:scheme
E:error
h:header
sl:js-slot
jI:js-intrinsic
jA:abstract
U:code-point
v:value

●●tag_map
I:code
m:code
c:code
e:code
a:code
sc:code
et:code
h:code
E:code
sl:span
jI:code
jA:span
U:span
v:code
V:var
i:i
em:em

●●words_table1

HTMLWPROXY:HTML-windowproxy-ja.html
	Assert:<b>Assert</b>

about_blank:about:blank
location0:location
Location: <code>Location</code> 

●●words_table

	●network／保安
HTTP_S:HTTP(S) 
username::::ユーザ名
password::::パスワード
hostname::::ホスト名
	navigating:
transaction::::トランザクション
unload:
非冪等:non-idempotent::~
抹消-:evict::~
	eviction
乗取る:hijackする:乗っ取る

	●環境 ／ 閲覧
入口:entry::~
現任:incumbent:~
一足飛びに:jumpして:~
再読込み:reload::再読み込み::リロード
読込直す:reloadする::読み込み直す::リロードする
成熟-:mature::~
	一~pageだけ:one-page
iframe:
iframe-srcdoc:iframe srcdoc

辿る:traverseする::~
辿った:traverseした::~
辿られ:traverseされ::~
辿り:traversal::~

開かれ:openされ::~
先進する:go forwardする:先へ進む
後戻-:go back:後戻り

	●構造
族:family:~
共同:joint:~
差挟む:interleaveする:差し挟む
連続的:contiguous:~
	連続する:consecutive
和集合:union::~
	getting
	構築し直す:reconstruct

	●UI
drop-down:drop down:::ドロップダウンメニュー
popup:
prompt:
書字方向性:directionality:~
聴覚:aural:~
操作o-:operate:操作
bookmark:
塗直す:repaintする:塗り直す
一過:transient::~

	●構文
	先頭の:leading
直列形の:serialized::~::シリアル形の
逆直列化-:deserialize::~::逆シリアル化

	●処理一般
上書state:state override:上書き state
state:
	entry:item
timer::::タイマー
例外投出あり:rethrow any exceptions::~
	~~投出:raise
	invoking
	-:substeps
給-:supply:~
持続-:persist:~
進行中の:ongoingな:~
復旧-:restore:~
復旧:restoration:~
保存-:save:~
書直せ:rewriteでき::書き直せ
	合致しない:mismatch
	:equal
	渡-:pass
	FIFO
	LIFO
	-:reprocess
	後で／:later
	%~URL:url
	%~target~URL:targetURL

	●仕様
metaphor::::メタファー
事実:fact:~
漠然な:nebulousな:漠然とした
濫用-:abuse:~
確認-:confirm:~
解放-:free:~
拒否-:refuse:~
	拒否された:"refuse"
協調-:coordinate:~
上限:limit:~
冗長:redundant:~
脱出措置:bailout:~

	既定でない:non-default
	精確を期すため:for precision
	あり得る:possible
	:optionally
	素朴:naïve
	〜から:perspective
	早く:as soon as
	責を負う:responsible
	関係-:relation
	-:involve
	食い違いが生じる:disagree
	きちんと定義され:well-defined
	配備-済み:deployed
	ものではない:not meant
	抵触する:hit
	代替わりする:bring 〜 into being to take the place of
	元々利用者から渡された:passed around by users
	-:except
	keeping track
	させ易く:help
	あらためて:afresh
	慣習:traditional
	関わらない:matter
	直前の時点で:the predicate in step 1

	●未分類
増加-:increase:~
database::::データベース
game::::ゲーム
時系列的:chronological:~
作成元:creator::~

	あてがう:prefill
	-:corresponding
	bookmarking
	having
	購入:purchase
	said
	取出して:pull して
	責を負う:responsible
	~Location~objにより:Location-object
	-:duplicate
	~blocker
	より高速:faster
	-:common
	-:buffer
	表:table
	と違って:contrary to
	更には:furthermore
	線:line
	一本道:linear
	非:non-
	-:per
	point
	立て続けに:rapid succession
	-:respective
	組:tuple
	頻繁過ぎ:too-frequent
	巨大過ぎ:over-large
	失敗かも:possibleFailure
	一足飛びに:jumps straight
	後続-:follow
	保つ:keep
	他から生成元を継承した:inheritedorigins

	●指示語
近過去:recent:~
	最も近過去に:most recently
最近の:latest:~
	様な:look
	:main
	いくぶん:somewhat
	あるいは:alternately
	単に:merely
	小さな:minor
	その順に:subsequent
	もう一つ:second
	-:otherwise
	以前／一つ前の:previous
	nothing
	-:newly
	次:next
	全体:whole
	最も早期の:earliest
	直後:immediately after
	別として:apart from

●●original_id_map


dom-window-history:dom-history
dom-window-location:dom-location

	number-of-document-tree-child-browsing-contexts:number-of-child-browsing-contexts
	serialized-state:state-object
	she-other:an-entry-with-persisted-user-state

●●mdn_urls
history-3:API/History
location:API/Location
	scrollrestoration:API/ScrollRestoration

●●link_map

	●IDL
LegacyUnforgeable:~WEBIDLjs#LegacyUnforgeable

E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror
E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror

I.Document:~HTMLdom#document
I.History:#history-3
I.Location:#location
I.ScrollRestoration:#scrollrestoration
I.Window:~WINDOW#window
I.DOMStringList:~HTMLcdom#domstringlist


	■#dom-member
l.auto:#dom-scrollrestoration-auto
l.manual:#dom-scrollrestoration-manual

m.history:#dom-window-history
m.back:#dom-history-back
m.forward:#dom-history-forward
m.go:#dom-history-go
m.length:#dom-history-length
m.pushState:#dom-history-pushstate
m.replaceState:#dom-history-replacestate
m.scrollRestoration:#dom-history-scroll-restoration
m.state:#dom-history-state

m.location:#dom-window-location
	m.window.location:#dom-window-location
m.~location0:#dom-document-location
	m.document.location:#dom-document-location

m.ancestorOrigins:#dom-location-ancestororigins
m.assign:#dom-location-assign
m.hash:#dom-location-hash
m.host:#dom-location-host
m.hostname:#dom-location-hostname
m.href:#dom-location-href
m.location.reload:#dom-location-reload
m.origin:#dom-location-origin
m.pathname:#dom-location-pathname
m.port:#dom-location-port
m.protocol:#dom-location-protocol
m.reload:#dom-location-reload
m.replace:#dom-location-replace
m.search:#dom-location-search

m.document.domain:~ORIGIN#dom-document-domain

	●event
et.hashchange:~HTMLindex#event-hashchange
et.resize:~CSSOMVIEW#eventdef-window-resize

	●要素
e.a:~HEtextlevel#the-a-element
e.div:~HEgrouping#the-div-element
e.head:~HEmetadata#the-head-element
e.title:~HEmetadata#the-title-element
e.area:~HEimages#the-area-element
e.iframe:~HEembed#the-iframe-element
e.script:~HEscripting#the-script-element

	●内容属性
a.dir:~HTMLdom#attr-dir

	●code 他
sc.~about_blank:~HTMLdep#about:blank

h.Cross-Origin-Opener-Policy:~ORIGIN#cross-origin-opener-policy-2


	●用語

閲覧~session:#browsing-session
tlbc.閲覧~session:#tlbc-browsing-session
enV.閲覧~session:#environment-browsing-session

~session履歴:#session-history
hsT.状態:#concept-history-state
~session履歴~entry:#session-history-entry

shE.閲覧~文脈~名:#she-bc-name
shE.持続される利用者~状態:#she-other
shE.~scroll位置~data:#she-scroll-position
shE.~scroll復旧~mode:#she-scroll-restoration-mode
shE.直列形の状態:#she-serialized-state
shE.施策~容器:#she-policy-container
shE.~URL:#she-url
shE.文書:#she-document

現在の~entry:#current-entry
最近の~entry:#latest-entry
直列形の状態:#serialized-state
~scroll復旧~mode:#scroll-restoration-mode

共同~session履歴:#joint-session-history
共同~session履歴の現在の~entry:#current-entry-of-the-joint-session-history
~session履歴~辿り~queue:#session-history-traversal-queue
~session履歴~event~loop:#session-history-event-loop
履歴を前／後へ辿る:#traverse-the-history-by-a-delta
~URLと履歴を更新する:#url-and-history-update-steps
	serializedData:#uhus-serializeddata
	title#uhus-title
	isPush#uhus-ispush

共有される履歴の状態を~pushするか置換する手続き:#shared-history-push/replace-state-steps
文書の~URLは書直せるか:#can-have-its-url-rewritten
書直せ:#can-have-its-url-rewritten

Loc.関連な文書:#relevant-document
Loc.~URL:#concept-location-url
先祖~生成元~list:#concept-location-ancestor-origins-list
~Location~objにより~navigateする:#location-object-navigate
生成元~domainを検査する:#_location-security-check

	:#_contiguous
	§:#history-notes
	§:#the-location-interface

	●用語 HTML

並列的:~HTMLINFRA#in-parallel

相対的に~URL構文解析する:~HTMLurl#parse-a-url

jA.StructuredSerializeForStorage:~HTMLcloning#structuredserializeforstorage
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
逆直列化-:~HTMLcloning#structureddeserialize

文書:~HTMLdom#the-document-object
まだ初期~about_blank 文書である:~HTMLdom#still-on-its-initial-about:blank-document
初期~about_blank な文書:~HTMLdom#is-initial-about:blank

一過な作動化？:~HTMLinteraction#transient-activation

	●BROWSERS
閲覧~文脈:~BROWSERS#browsing-context
閲覧~文脈~名:~BROWSERS#browsing-context-name
属する閲覧~文脈:~BROWSERS#concept-document-bc
属する文書:~BROWSERS#concept-document-bc
~top-level閲覧~文脈:~BROWSERS#top-level-browsing-context
bc.容器:~BROWSERS#bc-container
子~閲覧~文脈:~BROWSERS#child-browsing-context
親~閲覧~文脈:~BROWSERS#parent-browsing-context
先祖~閲覧~文脈:~BROWSERS#ancestor-browsing-context
作動中の文書:~BROWSERS#active-document
作動中の~window:~BROWSERS#active-window
作動中:~BROWSERS#active-document
文書~族:~BROWSERS#document-family
全部的に作動中:~BROWSERS#fully-active
~navigateすることは許容されて:~BROWSERS#allowed-to-navigate

	●WINDOW
~window:~WINDOW#the-window-object
対応する閲覧~文脈:~WINDOW#window-bc
結付けられている文書:~WINDOW#concept-document-window
doc.破棄-:~WINDOW#discard-a-document

	●ORIGIN
生成元:~ORIGIN#concept-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
同一-生成元:~ORIGIN#same-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
施策~容器:~ORIGIN#policy-container

	●NAVI
~navigate:~NAVI#navigate
~navi:~NAVI#navigate
素片へ~navigateする:~NAVI#navigate-fragid

~source閲覧~文脈:~NAVI#source-browsing-context
履歴を取扱うときの挙動:~NAVI#history-handling-behavior
V.例外を可能化するか:~NAVI#exceptions-enabled
V.履歴~取扱い:~NAVI#navigation-hh
i.既定:~NAVI#hh-default
i.置換-:~NAVI#hh-replace
i.再読込み:~NAVI#hh-reload
V.明示的な履歴~naviか:~NAVI#explicithistorynavigation

文書を~unloadする:~NAVI#unload-a-document
文書の~unloadを~promptする:~NAVI#prompt-to-unload-a-document
~unload~counter:~NAVI#unload-counter
履歴を辿る:~NAVI#traverse-the-history
履歴の辿り:~NAVI#traverse-the-history
成熟-:~NAVI#concept-navigate-mature
完全に読込まれ:~NAVI#completely-loaded
復旧-可能な~scroll可能な領域:~NAVI#restorable-scrollable-regions
持続される状態を保存する:~NAVI#save-persisted-state

	●WAPI
入口~設定群~obj:~WAPI#entry-settings-object
関連な設定群~obj:~WAPI#relevant-settings-object
関連な~realm:~WAPI#concept-relevant-realm
関連な大域~obj:~WAPI#concept-relevant-global
現任な大域~obj:~WAPI#concept-incumbent-global
~task:~WAPI#concept-task
tK.文書:~WAPI#concept-task-document
現在~走っている~task:~WAPI#currently-running-task
~taskを~queueする:~WAPI#queue-a-task
大域~taskを~queueする:~WAPI#queue-a-global-task
~task源:~WAPI#task-source
履歴~辿り~task源:~WAPI#history-traversal-task-source
~event~loop:~WAPI#event-loop

環境~設定群~obj:~WAPI#environment-settings-object
enV.生成元:~WAPI#concept-settings-object-origin
enV.大域~obj:~WAPI#concept-settings-object-global

~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document
	~scriptに返される:~HTMLindex#event-popstate
~iframeの属性を処理する:~HEembed#process-the-iframe-attributes

	●用語 他
実装定義:~INFRA#implementation-defined
~list:~INFRA#list
付加する:~INFRA#list-append
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
~scalar値~文字列:~INFRA#scalar-value-string

~URL:~URL1#concept-url
~API用に~URL構文解析する:~URL1#_api-url-parser
	基本~URL構文解析器:~URL1#concept-basic-url-parser
~hostを直列化する:~URL1#concept-host-serializer
~URLを直列化する:~URL1#concept-url-serializer
~URL~pathを直列化する:~URL1#url-path-serializer

~username／~password／~portを持てない:~URL1#cannot-have-a-username-password-port
不透明な~path:~URL1#url-opaque-path

url.~host:~URL1#concept-url-host
url.~path:~URL1#concept-url-path
url.~port:~URL1#concept-url-port
url.~query:~URL1#concept-url-query
url.~scheme:~URL1#concept-url-scheme
url.~username:~URL1#concept-url-username
url.~password:~URL1#concept-url-password
url.素片:~URL1#concept-url-fragment
url.生成元:~URL1#concept-url-origin
url.既定の~port:~URL1#default-port

整数を直列化する:~URL1#serialize-an-integer

uST.~host:~URL1#host-state
uST.~hostname:~URL1#hostname-state
uST.~path開始:~URL1#path-start-state
uST.~port:~URL1#port-state
uST.~query:~URL1#query-state
uST.~scheme開始:~URL1#scheme-start-state
uST.素片:~URL1#fragment-state

~HTTP_S~scheme:~FETCH#http-scheme

doc.~URL:~DOM4#concept-document-url
doc.生成元:~DOM4#concept-document-origin


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ Session history and navigation</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

<body>

<header>
	<hgroup>
<h1>HTML — セッション履歴とナビ</h1>
	</hgroup>
</header>

<hr>

<main id="MAIN" hidden>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ε, コレ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="history">
<h3 title="Session history and navigation">7.10. ~session履歴と~navi</h3>

			<section id="browsing-sessions">
<h4 title="Browsing sessions">7.10.1. 閲覧~session</h4>

<div class="XXX">
<p>
`閲覧~session@
は…
`閲覧~session$の定義-法は、
<a href="~HTMLissue/4782">課題 #4782</a>,
<a href="~HTMLissue/5350">課題 #5350</a>
を見よ。
それは、
概ね`~top-level閲覧~文脈$に相似的である
— ［
`Cross-Origin-Opener-Policy$h ~header／~navi
］に因り置換され得ないことを除いて。
◎
A browsing session is …. See whatwg/html issue #4782 and whatwg/html issue #5350 for defining browsing session. It is roughly analogous to a top-level browsing context except that it cannot be replaced due to a `Cross-Origin-Opener-Policy` header or navigation.
</p>

<p>
各`~top-level閲覧~文脈$には、
ある`閲覧~session$を与える
`閲覧~session@tlbc
が結付けられる。
◎
A top-level browsing context has an associated browsing session which is a browsing session.
</p>

<div class="algo">
<p>
`環境~設定群~obj$ %環境 の
`閲覧~session@enV
は、
次の手続きを走らせた結果になる：
◎
The browsing session of an environment settings object environment is the result of running these steps:
</p>
<ol>
	<li>
~Assert：
%環境 の`大域~obj$enVは`~window$である。
◎
Assert: environment's global object is a Window.
</li>
	<li>
~RET %環境 の`大域~obj$enVに`対応する閲覧~文脈$の`~top-level閲覧~文脈$の`閲覧~session$tlbc
◎
Return environment's global object's browsing context's top-level browsing context's browsing session.
</li>
</ol>
</div>
</div>

			</section>
			<section id="the-session-history-of-browsing-contexts">
<h4 title="The session history of browsing contexts">7.10.2. 閲覧~文脈の~session履歴</h4>

<p>
各 `閲覧~文脈$は、
`子~閲覧~文脈$を含め，互いに別個な
`~session履歴@
を有する。
それは，何個かの`~session履歴~entry$からなる平坦な~listであり、
それまでに`閲覧~文脈$に呈示された一連の`文書$を表現する。
◎
The sequence of Documents in a browsing context is its session history. Each browsing context, including child browsing contexts, has a distinct session history. A browsing context's session history consists of a flat list of session history entries.
</p>

<p>
`閲覧~文脈$の`~session履歴$内の各`文書$shE【！`文書$】には、
一意な `History$I ~objが結付けられる
— そのいずれも、同じ下層の`~session履歴$を~model化するモノトスル。
◎
Each Document object in a browsing context's session history is associated with a unique History object which must all model the same underlying session history.
</p>

<div class="algo">
`~window$の
`history@m
取得子~手続きは
⇒
~RET コレに`結付けられている文書$の `History$I ~instance
◎
The history getter steps are to return this's associated Document's History instance.
</div>

<hr>

<p>
`~session履歴~entry@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A session history entry is a struct with the following items:
</p>

<dl class="def-list">
	<dt>
`~URL@shE
◎
URL,＼
</dt>
	<dd>
`~URL$
◎
a URL
</dd>

	<dt>
`文書@shE
◎
document,＼
</dt>
	<dd>
`文書$または ~NULL
◎
a Document or null
</dd>
	<dd class="note">注記：
各`~session履歴~entry$ %~entry には，［
最初に作成されたとき，その`文書$shE用に ある`文書$があてがわれる
］が、
それは，`作動中$でないときに資源を解放するため`破棄-$docされ得る。
%~entry の`~URL$shEと他の~dataは、
~UAが %~entry へ~navigateする必要があると見出した所で，
破棄されたそれに代わる新たな`文書$を得るために利用される。
◎
Each entry, when first created, has a Document for its document. However, when a Document is not active, it's possible for it to be discarded to free resources. The URL and other data in the session history entry is then used to bring a new Document into being to take the place of the original, in the case where the user agent finds itself having to navigate to the entry.
</dd>
	<dd class="note">注記：
履歴~naviが生じて，
（`履歴を辿る$直前の時点で）
行先の`~session履歴~entry$の`文書$shEは ~NULL でない場合、
~browserは，その`文書$を~cacheしたことを意味する。
この~cacheは、
<em lang="en">back-forward cache</em>,
略して `bfcache^em
（または、
たぶん “<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=274784" lang="en">blazingly fast</a>” ~cache）
と呼ばれることが多い。
◎
If a history navigation occurs, and the Document for the destination session history entry is not null (i.e., the predicate in step 1 of traversing the history is false), that means the browser has cached that Document. This cache is often called a back-forward cache, or bfcache (or perhaps "blazingly fast" cache).
</dd>

	<dt>
`直列形の状態@shE
◎
serialized state,＼
</dt>
	<dd>
`直列形の状態$または ~NULL
— 初期~時は ~NULL
◎
which is serialized state or null, initially null
</dd>

	<dt>
`施策~容器@shE
◎
policy container,＼
</dt>
	<dd>
`施策~容器$または ~NULL
◎
a policy container or null
</dd>

	<dt>
`~scroll復旧~mode@shE
◎
scroll restoration mode,＼
</dt>
	<dd>
`~scroll復旧~mode$
— 初期~時には `auto$l とする。
◎
a scroll restoration mode, initially "auto"
</dd>

	<dt>
`~scroll位置~data@shE
◎
scroll position data,＼
</dt>
	<dd>
`文書$shEの`復旧-可能な~scroll可能な領域$用の~scroll位置~data
◎
which is scroll position data for the document's restorable scrollable regions
</dd>

	<dt>
`閲覧~文脈~名@shE
◎
browsing context name,＼
</dt>
	<dd>
`閲覧~文脈~名$または ~NULL
— 初期~時は ~NULL
◎
a browsing context name or null, initially null
</dd>

	<dt>
`持続される利用者~状態@shE
◎
persisted user state,＼
</dt>
	<dd>
`実装定義$な何か
— 初期~時は ~NULL
◎
which is implementation-defined, initially null
</dd>
	<dd class="example">
例えば，一部の~UAは、
~form~controlの値を持続したいと求めるかもしれない。
◎
For example, some user agents might want to persist the values of form controls.
</dd>
	<dd class="note">注記：
~form~controlの値を持続する~UAには、
それらの書字方向性（要素の `dir$a 属性~値）も持続することが奨励される。
これは、［
明示的かつ既定でない書字方向性の下で，利用者が元々手入力した値
］が，履歴の辿り後に不正に表示されることを防止する。
◎
User agents that persist the value of form controls are encouraged to also persist their directionality (the value of the element's dir attribute). This prevents values from being displayed incorrectly after a history traversal when the user had originally entered the values with an explicit, non-default directionality.
</dd>
</dl>

<p>
`直列形の状態@
は、
~UI状態を表現している~objを（ `StructuredSerializeForStorage$jA を介して）直列化したものである。
非正式には、
“状態~obj”
と呼ばれることもある
— それは、［
作者から給された，~UI状態を表現している~obj
］，あるいは［
`直列形の状態$を（ `StructuredDeserialize$jA を介して）逆直列化して作成される~obj
］を表す。
◎
Serialized state is a serialization (via StructuredSerializeForStorage) of an object representing a user interface state. We sometimes informally refer to "state objects", which are the objects representing user interface state supplied by the author, or alternately the objects created by deserializing (via StructuredDeserialize) serialized state.
</p>

<p>
~pageは、
~session履歴に`直列形の状態$を<a href="#dom-history-pushstate">追加できる</a>。
これは、
利用者（または~script）が履歴~内を後戻したときに，
`逆直列化-$された上で
<a href="~HTMLindex#event-popstate">~scriptに返される</a>。
したがって、
1 ~pageだけの~appにおいても，
作者が “~navi” の~metaphorを利用できるようにする。
◎
Pages can add serialized state to the session history. These are then deserialized and returned to the script when the user (or script) goes back in the history, thus enabling authors to use the "navigation" metaphor even in one-page applications.
</p>

<div class="note">

<p>注記：
`直列形の状態$には、
主に二つの用途が意図されている：
◎
Serialized state is intended to be used for two main purposes:＼
</p>
<ul>
	<li>
一つは、
予め構文解析した状態の記述を`~URL$と一緒に格納して，
単純な事例では 作者が構文解析せずに済むようにすること
（元々利用者から渡された`~URL$を取扱うときは，依然として それを構文解析する必要があるので、
これは小さな最適化に過ぎない）。
◎
first, storing a preparsed description of the state in the URL so that in the simple case an author doesn't have to do the parsing (though one would still need the parsing for handling URLs passed around by users, so it's only a minor optimization).＼
</li>
	<li>
もう一つは、
他からは格納されない状態
— 現在の`文書$~instanceに限り適用され、
同じ~URLの`文書$が新たに開かれるときは構築し直す必要がある状態 —
を，作者が ~URLと一緒に格納できるようにすること。
◎
Second, so that the author can store state that one wouldn't store in the URL because it only applies to the current Document instance and it would have to be reconstructed if a new Document were opened.
</li>
</ul>

<p>
後者の用例には、
次が挙げられる：
◎
An example of the latter would be＼
</p>
<ul>
	<li>
利用者が後戻するときに、［
以前に~animateさせていた~popup `div$e を同じ所在から~animateし続けれる
］よう，
精確に協調するように追跡する。
◎
something like keeping track of the precise coordinate from which a popup div was made to animate, so that if the user goes back, it can be made to animate to the same location.＼
</li>
	<li>
［［
`~URL$ 内の情報に基づいて~serverから~fetchされる~data
］の~cache
］の中への~pointerを保っておいて、
後戻する／先進するときに，その情報を再度~fetchせずに済むようにする。
◎
Or alternatively, it could be used to keep a pointer into a cache of data that would be fetched from the server based on the information in the URL, so that when going back and forward, the information doesn't have to be fetched again.
</li>
</ul>
</div>

<p>
`~scroll復旧~mode@
は、
~UAが ある`~session履歴~entry$へ辿ったとき，
持続される~scroll位置（もしあれば）を復旧するべきかどうかを指示する。
それは、次のいずれかをとり得る：
◎
A scroll restoration mode indicates whether the user agent should restore the persisted scroll position (if any) when traversing to an entry. A scroll restoration mode is one of the following:
</p>

<dl class="def-list">
	<dt>`auto@l</dt>
	<dd>
~UAが、
~naviに際して~scroll位置を復旧する責を負う。
◎
The user agent is responsible for restoring the scroll position upon navigation.
</dd>

	<dt>`manual@l</dt>
	<dd>
~pageが、
~naviに際して~scroll位置を復旧する責を負う。
~UAは、
それを自動的に試みない。
◎
The page is responsible for restoring the scroll position and the user agent does not attempt to do so automatically
</dd>
</dl>

<hr>

<p>
~session履歴~内の［
連続的な~entryたち
］は、
同じ`文書$shEを共有し得る。
これは、
通常の`~navi$を介して初期~entryに到達してから，
`pushState()$m を介して それに後続する~entryが追加されたときに生じ得る。
あるいは、
`素片へ~navigateする$ことを介しても生じ得る。
◎
Several contiguous entries in a session history can share the same document. This can occur when the initial entry is reached via normal navigation, and the following entry is added via history.pushState(). Or it can occur via navigation to a fragment.
</p>

<p class="note" id="_contiguous">注記：
同じ`文書$shEを共有している すべての~entryは、
定義により連続的になる
（それらは、単に，特定0の文書の異なる状態たちを成す）。
◎
All entries that share the same document (and that are therefore merely different states of one particular document) are contiguous by definition.
</p>

<p>
~UAは、
所与の~entryたちに対し，その`文書$shEを
— それが ~NULL でないならば —
`破棄-$docしてもヨイ
— ただし，次に該当するものは、
`破棄-$docしないモノトスル
⇒＃
`現在の~entry$の`文書$shE／
~scriptから参照されている`文書$
◎
User agents may discard the documents of entries with non-null documents, as long as the following conditions are met:
• They must not discard the document of the current entry.
• They must not discard any Document objects which are referenced from script.
</p>

<p>
これらの制約は別として、
この標準は，~UAが~entryの`文書$shEを［
いつまで~cacheに保つべきか, いつ破棄するべきか
］については指定しない。
◎
Apart from these restrictions, this standard does not specify when user agents should discard an entry's document, versus keeping it cached.
</p>

<p class="note">注記：
`文書$を`破棄-$docすると、
それを共有している【！＊】各`~session履歴~entry$の`文書$shEも ~NULL に設定されることになる。
そのような~entryへの後続な~naviは、
新たな`文書$を作成して，それを~entryの`文書$shEに設定することになる。
◎
Discarding a Document will set the corresponding document item of any session history entries to null. Subsequent navigations to those entries will result in the creation of a new Document object, and set the document item to it.
</p>

<hr>

<p>
どの時点においても，`~session履歴$内のある 1 つの~entryが
`現在の~entry@
になる。
これは、
`閲覧~文脈$にて`作動中の文書$を表現している~entryになる。
どの~entryが`現在の~entry$になるかは、
この仕様に定義される~algo
— 例えば`履歴を辿る$間など —
により変更される。
◎
At any point, one of the entries in the session history is the current entry. This is the entry representing the active document of the browsing context. Which entry is the current entry is changed by the algorithms defined in this specification, e.g., during session history traversal.
</p>

<p class="trans-note">【
`作動中の文書$は常にあるので、
~session履歴が空になることはない。
】</p>

<p class="note">注記：
`現在の~entry$は、
通例的には，~naviの際に初期~時に作成される~entryになる。
しかしながら，上で述べたように、
同じ`文書$shEを共有している連続的な~entryのうち いずれかにもなり得る。
◎
The current entry is usually the initial entry created upon navigation. However, it can also be one of the contiguous entries that share the same document, as described above.
</p>

<p>
各`文書$ %文書 は、
それが`属する閲覧~文脈$ %B ~NEQ ~NULL ならば，
`最近の~entry@
を有する
— それは、
`文書$の作成-時には ε （なし）とする。
これは、［
%B の`~session履歴$内の~entry
］のうち［
その`文書$shE ~EQ %文書
］なるもののうち，最も近過去に辿られた~entryにされる。
◎
Each Document in a browsing context can also have a latest entry. This is the entry for that Document to which the browsing context's session history was most recently traversed. When a Document is created, it initially has no latest entry.
</p>

			</section>
			<section id="the-history-interface">
<h4 title="The History interface">7.10.3. `History^I ~interface</h4>

<pre class="idl">
enum `ScrollRestoration@I { `auto$l, `manual$l };

[Exposed=Window]
interface `History@I {
  readonly attribute unsigned long `length$m;
  attribute `ScrollRestoration$I `scrollRestoration$m;
  readonly attribute any `state$m;
  undefined `go$m(optional long %delta = 0);
  undefined `back$m();
  undefined `forward$m();
  undefined `pushState$m(any %data, DOMString %unused, optional USVString? %url = null);
  undefined `replaceState$m(any %data, DOMString %unused, optional USVString? %url = null);
};
</pre>

<dl class="domintro">
	<dt>%window.`history$m.`length$m</dt>
	<dd>
`共同~session履歴$内の~entryの個数を返す。
◎
Returns the number of entries in the joint session history.
</dd>

	<dt>%window.`history$m.`scrollRestoration$m [ = %value ]</dt>
	<dd>
`~session履歴$の`現在の~entry$の`~scroll復旧~mode$shEを返す。
◎
Returns the scroll restoration mode of the current entry in the session history.
</dd>
	<dd>
設定して、
`~session履歴$の`現在の~entry$の`~scroll復旧~mode$shEを変更できる。
◎
Can be set, to change the scroll restoration mode of the current entry in the session history.
</dd>

	<dt>%window.`history$m.`state$m</dt>
	<dd>
`~session履歴$の現在の`直列形の状態$を逆直列化した結果の~objを返す。
◎
Returns the current serialized state, deserialized into an object.
</dd>

	<dt>%window.`history$m.`go( [ delta ])$m</dt>
	<dd>
`共同~session履歴$内で，指定された段~数だけ後戻する／先進する。
◎
Goes back or forward the specified number of steps in the joint session history.
</dd>
	<dd>
%delta に対する 0 は、
現在の~pageを読込直すことになる。
◎
A zero delta will reload the current page.
</dd>
	<dd>
%delta が範囲~外を指す場合は何もしない。
◎
If the delta is out of range, does nothing.
</dd>

	<dt>%window.`history$m.`back()$m</dt>
	<dd>
`共同~session履歴$内で 1 段だけ後戻する。
◎
Goes back one step in the joint session history.
</dd>
	<dd>
前~pageがない場合は何もしない。
◎
If there is no previous page, does nothing.
</dd>

	<dt>%window.`history$m.`forward()$m</dt>
	<dd>
`共同~session履歴$内で 1 段だけ先進する。
◎
Goes forward one step in the joint session history.
</dd>
	<dd>
次~pageがない場合は何もしない。
◎
If there is no next page, does nothing.
</dd>

	<dt>%window.`history$m.`pushState(data, "")$m</dt>
	<dd>
`~session履歴$の中へ新たな~entryを~pushする
— この~entryには、
所与の %data が結付けられ，
`~URL$shEには［
現在の~entryの`~URL$shEが複製されて利用される
］ことになる。
◎
Push a new entry into session history with the given data associated. The current entry's URL will be copied over and used for the new entry's URL.
</dd>
	<dd>
（ 2 個目の~parameterは、歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>

	<dt>%window.`history$m.`pushState(data, "", url)$m</dt>
	<dd>
`~session履歴$の中へ新たな~entryを~pushする
— この~entryには、
所与の %data が結付けられ，
`~URL$shEには %url が設定される。
◎
Push a new entry into session history with the given data associated, and with its URL set to url.
</dd>
	<dd>
現在の`文書$の~URLを %url で`書直せ$ない場合、
`SecurityError$E 例外が投出されることになる。
◎
If the current Document cannot have its URL rewritten to url, a "SecurityError" DOMException will be thrown.
</dd>
	<dd>
（ 2 個目の~parameterは、歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>

	<dt>%window.`history$m.`replaceState(data, "")$m</dt>
	<dd>
現在の`~session履歴~entry$内に格納された~dataを %data に更新する。
◎
Updates the data stored in the current session history entry to data.
</dd>
	<dd>
（ 2 個目の~parameterは、歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>

	<dt>%window.`history$m.`replaceState(data, "", url)$m</dt>
	<dd>
現在の`~session履歴~entry$内に格納された~dataを %data に更新して，
当の~entryの`~URL$shEも %url に更新する。
◎
Updates the data stored in the current session history entry to data, and its URL to url.
</dd>
	<dd>
現在の`文書$の~URLを %url で`書直せ$ない場合、
`SecurityError$E 例外が投出されることになる。
◎
If the current Document cannot have its URL rewritten to url, a "SecurityError" DOMException will be thrown.
</dd>
	<dd>
（ 2 個目の~parameterは、歴史的な理由から存在し，省略できない
— 空~文字列を渡しているのは、慣習による。）
◎
(The second parameter exists for historical reasons, and cannot be omitted; passing the empty string is traditional.)
</dd>
</dl>

<div class="p">
<p>
`~top-level閲覧~文脈$ %B の
`共同~session履歴@
とは、［
次を満たす各 `閲覧~文脈$ %B1 の`~session履歴$内の~entryうち，その`現在の~entry$以外のもの
］すべての和集合に，`共同~session履歴の現在の~entry$を加えたものである：
</p>

<ul ><li>%B1 の`~top-level閲覧~文脈$ ~EQ %B
</li><li>%B1 にて`作動中の文書$は、`全部的に作動中$である
</li></ul>

◎
The joint session history of a top-level browsing context is the union of all the session histories of all browsing contexts of all the fully active Document objects that share that top-level browsing context, with all the entries that are current entries in their respective session histories removed except for the current entry of the joint session history.
</div>

<p>
`共同~session履歴の現在の~entry@
は、
それを成す各`~session履歴$の`現在の~entry$のうち，
最も近過去にそうなったものを指す。
◎
The current entry of the joint session history is the entry that most recently became a current entry in its session history.
</p>

<p>
`共同~session履歴$内の各~entryは、
各自が属する`~session履歴$に追加された時刻により時系列的に順序付けられ，
その順に 1 ずつ増加する整数~indexが付与される
— 最も早期の~entryに付与される~indexは 0 とする。
◎
Entries in the joint session history are ordered chronologically by the time they were added to their respective session histories. Each entry has an index; the earliest entry has index 0, and the subsequent entries are numbered with consecutively increasing integers (1, 2, 3, etc.).
</p>

<p class="note">注記：
同じ`閲覧~文脈$に`属する文書$どうしの`~event~loop$は，異なることもあるので、
`共同~session履歴$の実際の状態は，いくぶん漠然なものになり得る。
例えば、
【！ one unique origin】同じ生成元に属していた 2 個の同胞 `iframe$e 要素が，同時に別の生成元へ`履歴を辿る$こともあるので、
それらの精確な順序は，きちんと定義されないかもしれない。
同様に，互いが他方を後と見出すこともあるため、
それぞれにとっての`共同~session履歴$の長さには，食い違いが生じるかもしれない。
◎
Since each Document in a browsing context might have a different event loop, the actual state of the joint session history can be somewhat nebulous. For example, two sibling iframe elements could both traverse from one unique origin to another at the same time, so their precise order might not be well-defined; similarly, since they might only find out about each other later, they might disagree about the length of the joint session history.
</p>

<p>
各 `History$I ~objは
`状態@hsT
を有する
— 初期~時には ~NULL とする。
◎
Each History object has state, initially null.
</p>

<div class="algo">
<p>
`length@m
取得子~手続きは：
◎
The length getter steps are:
</p>
<ol>
	<li>
~IF［
コレを結付けている`文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET `~top-level閲覧~文脈$の`共同~session履歴$内の~entryの個数
◎
Return the number of entries in the top-level browsing context's joint session history.
</li>
</ol>

<p>
~scriptからは、
実際の各~entryには~access可能でない。
◎
The actual entries are not accessible from script.
</p>
</div>

<div class="algo">
<p>
`scrollRestoration@m
取得子~手続きは：
◎
The scrollRestoration getter steps are:
</p>
<ol>
	<li>
~IF［
コレを結付けている`文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET コレの`~session履歴$の`現在の~entry$の`~scroll復旧~mode$shE
◎
Return this's session history's current entry's scroll restoration mode.
</li>
</ol>
</div>

<div class="algo">
<p>
`scrollRestoration$m 設定子~手続きは：
◎
The scrollRestoration setter steps are:
</p>
<ol>
	<li>
~IF［
コレを結付けている`文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
コレの`~session履歴$の`現在の~entry$の`~scroll復旧~mode$shE ~SET 所与の値
◎
Set this's session history's current entry's scroll restoration mode to the given value.
</li>
</ol>
</div>

<div class="algo">
<p>
`state@m
取得子~手続きは：
◎
The state getter steps are:
</p>
<ol>
	<li>
~IF［
コレを結付けている`文書$は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If this's associated Document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET コレの`状態$hsT
◎
Return this's state.
</li>
</ol>
</div>

<div class="algo">
<p>
`go(delta)@m
~method~手続きは：
◎
The go(delta) method steps are:
</p>
<ol>
	<li>
%文書 ~LET コレを結付けている`文書$
◎
Let document be this's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
%delta ~EQ 0
］
⇒
`location.reload()$m ~methodが~callされたかのように動作する
◎
If delta is 0, then act as if the location.reload() method was called, and return.
</li>
	<li>
~ELSE
⇒
`履歴を前／後へ辿る$( %delta, %文書 が`属する閲覧~文脈$ )
◎
Traverse the history by a delta with delta and document's browsing context.
</li>
</ol>
</div>

<div class="algo">
<p>
`back()@m
~method~手続きは：
◎
The back() method steps are:
</p>
<ol>
	<li>
%文書 ~LET コレを結付けている`文書$
◎
Let document be this's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
`履歴を前／後へ辿る$( −1, %文書 が`属する閲覧~文脈$ )
◎
Traverse the history by a delta with −1 and document's browsing context.
</li>
</ol>
</div>

<div class="algo">
<p>
`forward()@m
~method~手続きは：
◎
The forward() method steps are:
</p>
<ol>
	<li>
%文書 ~LET コレを結付けている`文書$
◎
Let document be this's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
`履歴を前／後へ辿る$( 1, %文書 が`属する閲覧~文脈$ )
◎
Traverse the history by a delta with +1 and document's browsing context.
</li>
</ol>
</div>

<hr>

<p>
各`~top-level閲覧~文脈$は、
`~session履歴~辿り~queue@
を有する
— それは、
初期~時には空であり，いくつかの`~task$が追加され得る。
◎
Each top-level browsing context has a session history traversal queue, initially empty, to which tasks can be added.
</p>

<div class="algo">
<p>
各`~top-level閲覧~文脈$ %B の作成-時には、
その時点から`並列的$に，次の~algoを走らすモノトスル
— この~algoは， %B 用の
`~session履歴~event~loop@
と呼ばれる：
◎
Each top-level browsing context, when created, must begin running the following algorithm, known as the session history event loop for that top-level browsing context, in parallel:
</p>
<ol>
	<li>
%~queue ~LET %B の`~session履歴~辿り~queue$
◎
↓</li>
	<li>
<p >
~WHILE 無条件
</p>
		<ol>
			<li>
%~queue が空でなくなるまで待機する
◎
Wait until this top-level browsing context's session history traversal queue is not empty.
</li>
			<li>
%~queue から最初の`~task$を取出して、
それを実行する
◎
Pull the first task from this top-level browsing context's session history traversal queue, and execute it.
◎
Return to the first step of this algorithm.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
`~session履歴~event~loop$は、
`共同~session履歴$内の各 閲覧~文脈~間の遷移を協調させ易くするためにある。
特定0の時点で各 `閲覧~文脈$が有する`~event~loop$は、
互いに異なるかもしれないので
（これは、［
利用者が `example.com^c から `shop.example^c へ~navigateするとき
］に起こり得る）
— さもなければ、遷移は，それらの~event~loopの同期-法を孕むようにする必要が生じる。
◎
The session history event loop helps coordinate cross-browsing-context transitions of the joint session history: since each browsing context might, at any particular time, have a different event loop (this can happen if the user navigates from example.com to shop.example), transitions would otherwise have to involve cross-event-loop synchronization.
</p>

<hr>

<div class="algo">
<p>
`履歴を前／後へ辿る@
ときは、所与の
( 整数 %delta, `閲覧~文脈$ %~source閲覧~文脈 )
に対し，
%~source閲覧~文脈 の【！ this 】`~top-level閲覧~文脈$の`~session履歴~辿り~queue$に，次を走らす`~task$を付加するモノトスル：
◎
To traverse the history by a delta given delta and browsing context source browsing context, the user agent must append a task to this top-level browsing context's session history traversal queue, the task consisting of running the following steps:
</p>

<ol>
	<li>
%履歴 ~LET `共同~session履歴$
◎
↓</li>
	<li>
%index ~LET ( `共同~session履歴の現在の~entry$の~index ) ~PLUS %delta
◎
↓</li>
	<li>
~IF［
%index ~NIN { 0 〜 ( %履歴 内の~entry数 ~MINUS 1 ) }
］
⇒
~RET
◎
If the index of the current entry of the joint session history plus delta is less than zero or greater than or equal to the number of items in the joint session history, then return.
</li>
	<li>
%~entry ~LET %履歴 内の［
~index ~EQ %index
］なる~entry
◎
Let specified entry be the entry in the joint session history whose index is the sum of delta and the index of the current entry of the joint session history.
</li>
	<li>
%B ~LET %~entry が属する`~session履歴$を有する`閲覧~文脈$
◎
Let specified browsing context be the browsing context of the specified entry.
</li>
	<li>
~IF［
%~source閲覧~文脈 は， %B を`~navigateすることは許容されて$いない
］
⇒
~RET
◎
If source browsing context is not allowed to navigate specified browsing context, then return.
</li>
	<li>
~IF［
%B にて`作動中の文書$の`~unload~counter$ ~GT 0
］
⇒
~RET
◎
If the specified browsing context's active document's unload counter is greater than 0, then return.
</li>
	<li>
<p>
次を遂行する`大域~taskを~queueする$( `履歴~辿り~task源$, %B にて`作動中の~window$ )：
◎
Queue a global task on the history traversal task source given specified browsing context's active window to perform the following steps:
</p>
		<ol>
			<li>
~IF［
%B を~navigateしようとする進行中の試みがあるが、
%B は【その試みにおいて】まだ`成熟-$していない
（すなわち、 %B はまだ，その`文書$を`作動中$にする段を~~終えていない）
］
⇒
その試みを取消す
◎
If there is an ongoing attempt to navigate specified browsing context that has not yet matured (i.e. it has not passed the point of making its Document the active document), then cancel that attempt to navigate the browsing context.
</li>
			<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
			<li>
<p>
~IF［
%文書 ~NEQ %~entry の`文書$
］：
◎
If the specified browsing context's active document is not the same Document as the Document of the specified entry, then run these substeps:
</p>

				<ol>
					<li>
~IF［
`文書の~unloadを~promptする$( %文書 ) の結果 ~EQ `拒否された^i
］
⇒
~RET
◎
If the result of calling prompt to unload with the active document of the specified browsing context is "refuse", then abort these steps.
</li>
					<li>
`文書を~unloadする$( %文書 )
◎
Unload the active document of the specified browsing context.
</li>
				</ol>
			</li>
			<li>
%~entry へ`履歴を辿る$
— 次を与える下で
⇒
`明示的な履歴~naviか$V ~SET ~T
◎
Traverse the history of the specified browsing context to the specified entry with explicitHistoryNavigation set to true.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
~UAは，利用者が（例えば~browserの戻る／進む~buttonを利用して）`閲覧~文脈$を通して~navigateするときは、
次を走らすモノトスル
⇒
`履歴を前／後へ辿る$( 利用者が指定した動作に等価な %delta, 利用者が操作oしている`閲覧~文脈$ )
◎
When the user navigates through a browsing context, e.g. using a browser's back and forward buttons, the user agent must traverse the history by a delta with a delta equivalent to the action specified by the user and the browsing context being operated on.
</p>

<div class="algo">
<p>
`~URLと履歴を更新する@
手続きは、所与の
⇒＃
`文書$ %文書,
`~URL$ %新~URL,
`直列形の状態$または ~NULL %直列形の~data （省略時は ~NULL ）,
%~pushするか ~IN { `~pushする^i, ε } （省略時は ε ）
◎終
に対し，次を走らす：
◎
The URL and history update steps, given a Document document, a URL newURL, an optional serialized state-or-null serializedData (default null), and an optional boolean isPush (default false), are:
</p>

<ol>
	<li>
%B ~LET %文書 が`属する閲覧~文脈$
◎
Let browsingContext be document's browsing context.
</li>
	<li>
<p>
~IF［
%B は`まだ初期~about_blank 文書である$
］
⇒
%~pushするか ~SET ε
◎
If browsingContext is still on its initial about:blank Document, then set isPush to false.
</p>

<p class="note">注記：
これは、次を意味する
⇒
`初期~about_blank な文書$に対する `pushState()$m は、
`replaceState()$m の~callとして挙動する。
◎
This means that pushState() on an initial about:blank Document behaves as a replaceState() call.
</p>
	</li>
	<li>
%履歴 ~LET %B の`~session履歴$
◎
↓</li>
	<li>
<p>
~IF［
%~pushするか ~EQ `~pushする^i
］：
◎
If isPush is true, then:
</p>
		<ol>
			<li>
<p>
%履歴 から［
その`現在の~entry$より後にある~entry
］をすべて除去する
◎
Remove all the entries in browsingContext's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.
</p>

<p class="note">注記：
これは、
~UAの~UIに<a href="#history-notes">影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
			</li>
			<li>
`履歴~辿り~task源$から~queueされた`~task$のうち，次を満たすものすべてを除去する
⇒
`~task$の`文書$tK ~IN 【%文書 が`属する閲覧~文脈$の】`~top-level閲覧~文脈$の`文書~族$
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.
</li>
			<li>
%履歴 の`現在の~entry$に`持続される状態を保存する$
◎
Save persisted state to the current entry.
</li>
			<li>
%新たな~entry ~LET 次を伴う新たな`~session履歴~entry$
⇒＃
`~URL$shE ~SET %新~URL,
`文書$shE ~SET %文書,
`直列形の状態$shE ~SET %直列形の~data,
`~scroll復旧~mode$shE ~SET %履歴 の`現在の~entry$の`~scroll復旧~mode$shE
◎
Add a session history entry entry to browsingContext's session history, after the current entry, with
• newURL as the URL;
• document as the document;
• serializedData as the serialized state;
• the scroll restoration mode of the current entry in the session history as the scroll restoration mode.
</li>
			<li>
%履歴 に
— その`現在の~entry$の後に —
%新たな~entry を追加する
◎
↑</li>
			<li>
%履歴 の`現在の~entry$ ~SET %新たな~entry
◎
Update the current entry to be this newly added entry.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~entry ~LET %履歴 の`現在の~entry$
◎
Let entry be browsingContext's session history's current entry.
</li>
			<li>
%~entry の`~URL$shE ~SET %新~URL
◎
Set entry's URL to newURL.
</li>
			<li>
~IF［
%直列形の~data ~NEQ ~NULL
］
⇒
%~entry の`直列形の状態$shE ~SET %直列形の~data
◎
If serializedData is not null, then set entry's serialized state to serializedData.
</li>
			<li>
<p>
~IF［
%~entry は非 `GET^h 要請を表現する
（例： それは `POST^h 提出の結果であった）
］
⇒
%~entry を `GET^h 要請を表現するものに更新する
◎
Update entry so that it represents a GET request, if it currently represents a non-GET request (e.g. it was the result of a POST submission).
</p>

<p class="XXX">
これは何を意味する？
これは`~session履歴~entry$の定義の一部を成していない。
◎
What does this mean? This is not a part of the definition of session history entry.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
%文書 の`~URL$doc ~SET %新~URL
◎
Set document's URL to newURL.
</p>

<p class="note">注記：
これは，［
`閲覧~文脈$の`~navi$ ／ `履歴の辿り$
］ではないので、
`hashchange$et ~eventは発火されない。
◎
Since this is neither a navigation of the browsing context nor a history traversal, it does not cause a hashchange event to be fired.
</p>
	</li>
	<li>
<p>
~IF［
%直列形の~data ~NEQ ~NULL
］：
◎
If serializedData is not null, then:
</p>
		<ol>
			<li>
%状態 ~LET `StructuredDeserialize$jA( %直列形の~data, %文書 に`関連な~realm$ )
⇒
例外が投出されたときは、
~catchして
⇒
%状態 ~SET ~NULL
（例外は無視する）
◎
Let state be StructuredDeserialize(serializedData, document's relevant realm). If this throws an exception, catch it, ignore the exception, and set state to null.
</li>
			<li>
%文書 の `History$I ~instanceの`状態$hsT ~SET %状態
◎
Set document's History instance's state to state.
</li>
		</ol>
	</li>
	<li>
%履歴 の`現在の~entry$の`文書$shEの`最近の~entry$ ~SET `現在の~entry$
◎
Set the current entry's document's latest entry to the current entry.
</li>
</ol>
</div>

<div class="algo">
`pushState(data, unused, url)@m
~method手続きは
⇒
`共有される履歴の状態を~pushするか置換する手続き$( コレ, %data, %url, `~pushする^i )
◎
The pushState(data, unused, url) method steps are to run the shared history push/replace state steps given this, data, url, and true.
</div>

<div class="algo">
`replaceState(data, unused, url)@m
~method手続きは
⇒
`共有される履歴の状態を~pushするか置換する手続き$( コレ, %data, %url )
◎
The replaceState(data, unused, url) method steps are to run the shared history push/replace state steps given this, data, url, and false.
</div>

<div class="algo">
<p>
`共有される履歴の状態を~pushするか置換する手続き@
は、所与の
( `History$I %履歴, 値 %~data, `~scalar値~文字列$または ~NULL %~URL, %~pushするか ~IN { `~pushする^i, ε } （省略時は ε ） )
に対し：
◎
The shared history push/replace state steps, given a History history, a value data, a scalar value string-or-null url, and a boolean isPush, are:
</p>
<ol>
	<li>
%文書 ~LET %履歴 を結付けている`文書$
【以下における %履歴 は、それが表現している`~session履歴$も兼ねる。】
◎
Let document be history's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, then throw a "SecurityError" DOMException.
</li>
	<li>
<p>
任意選択で
⇒
~RET
◎
Optionally, return.＼
</p>

<p>
（例えば~UAは、
この手続きを呼出す~methodが［
~timer ／
利用者による明瞭な動作に呼応して誘発されたものではない~event~listener
］から~callされた場合, あるいは立て続けに呼出された場合には，許容しないかもしれない。）
◎
(For example, the user agent might disallow calls to these methods that are invoked on a timer, or from event listeners that are not triggered in response to a clear user action, or that are invoked in rapid succession.)
</p>
	</li>
	<li>
%直列形の~data ~LET
~ABRUPT `StructuredSerializeForStorage$jA( %~data )
◎
Let serializedData be ? StructuredSerializeForStorage(data).
</li>
	<li>
%新~URL ~LET %履歴【！the session history】 の`現在の~entry$の`~URL$shE
◎
Let newURL be the session history's current entry's URL.
</li>
	<li>
<p>
~IF［
%~URL ~NEQ ~NULL
］：
◎
If url is not null, then:
</p>
		<ol>
			<li>
%新~URL ~SET `相対的に~URL構文解析する$( %~URL, %履歴 に`関連な設定群~obj$ )
◎
Parse url, relative to the relevant settings object of history.
</li>
			<li>
~IF［
%新~URL ~EQ `失敗^i
］
⇒
~THROW `SecurityError$E
◎
If that fails, then throw a "SecurityError" DOMException.
◎
Set newURL to the resulting URL record.
</li>
			<li>
~IF［
`文書の~URLは書直せるか$( %文書, %新~URL ) ~EQ ~F
］
⇒
~THROW `SecurityError$E
◎
If document cannot have its URL rewritten to newURL, then throw a "SecurityError" DOMException.
</li>
		</ol>
	</li>
	<li>
`~URLと履歴を更新する$( %文書, %新~URL, %直列形の~data, %~pushするか )
◎
Run the URL and history update steps given document and newURL, with serializedData set to serializedData and isPush set to isPush.
</li>
</ol>
</div>

<p>
~UAは、
~pageごとに，その~session履歴に追加される状態~obj【`直列形の状態$として与えられる~obj】の個数を制限してもヨイ。
~pageが この`実装定義$な上限に抵触した場合、
~UAは，新たな~entryが追加された後に，［
当の`文書$用の`~session履歴$を成す最初の~entry
］の直後の~entryを除去するモノトスル
（したがって，状態~履歴は、
先に入れたものから抹消されるように動作する（ FIFO ）一方で、
~naviに対しては，先に入れたものが最後に残るように動作する（ LIFO ））。
◎
User agents may limit the number of state objects added to the session history per page. If a page hits the implementation-defined limit, user agents must remove the entry immediately after the first entry for that Document object in the session history after having added the new entry. (Thus the state history acts as a FIFO buffer for eviction, but as a LIFO buffer for navigation.)
</p>

<div class="algo">
<p>
`文書の~URLは書直せるか@
どうかは、所与の
( `文書$ %文書, `~URL$ %~target~URL )
に対し，次の~algoに従う
（結果が ~T ならば %~target~URL で “書直せる” ）：
◎
A Document document can have its URL rewritten to a URL targetURL if the following algorithm returns true:
</p>
<ol>
	<li>
%文書~URL ~LET %文書 の`~URL$doc
◎
Let documentURL be document's URL.
</li>
	<li>
<p>
~RET ［
次がいずれも満たされるならば ~T ／
~ELSE_ ~F
］：
</p>
		<ul>
			<li>
［
%~target~URL, %文書~URL
］は、
次に挙げるどの成分においても一致する
⇒＃
`~scheme$url,
`~username$url,
`~password$url,
`~host$url,
`~port$url
</li>
			<li>
<p>
［
%~target~URL, %文書~URL
］は、
%~target~URL の`~scheme$urlに応じて，次に挙げるどの成分においても一致する：
</p>
			<dl class="switch">
					<dt>
`~HTTP_S~scheme$
</dt>
					<dd>
なし
</dd>
					<dd>
（
<a href="~HTTPinfra#https.uri">`https:^sc</a> ~URLや
<a href="~HTTPinfra#http.uri">`http:^sc</a> ~URL用には、
【！~RFCx/rfc7230#section-2.7.1／~RFCx/rfc7230#section-2.7.2】
［
`~path$url ／ `~query$url ／ `素片$url
］における相違は許容される。）
</dd>

					<dt>
`file^l
</dt>
					<dd>
`~path$url
</dd>
					<dd>
（ `file:^sc ~URL用には、［
`~query$url ／ `素片$url
］における相違は許容される。）
</dd>

					<dt>
その他
</dt>
					<dd>
`~path$url,
`~query$url
</dd>
					<dd>
（`素片$urlにおける相違に限り許容される。）
</dd>
				</dl>
			</li>
		</ul>
◎
If targetURL and documentURL differ in their scheme, username, password, host, or port components, then return false.
◎
If targetURL's scheme is an HTTP(S) scheme, then return true. (Differences in path, query, and fragment are allowed for http: and https: URLs.)
◎
If targetURL's scheme is "file", and targetURL and documentURL differ in their path component, then return false. (Differences in query and fragment are allowed for file: URLs.)
◎
If targetURL and documentURL differ in their path component or query components, then return false. (Only differences in fragment are allowed for other types of URLs.)
◎
Return true.
</li>
</ol>
</div>

<div class="example">
<div>
<table><thead><tr><th>%文書~URL
<th>%~target~URL
<th>`文書の~URLは書直せるか$
</thead><tbody>

<tr><td>`https://example.com/home^c
<td>`https://example.com/home#about^c
<td>✅

<tr><td>`https://example.com/home^c
<td>`https://example.com/home?page=shop^c
<td>✅

<tr><td>`https://example.com/home^c
<td>`https://example.com/shop^c
<td>✅

<tr><td>`https://example.com/home^c
<td><code>https://user:pass@example.com/home</code>
<td>❌

<tr><td>`https://example.com/home^c
<td>`http://example.com/home^c
<td>❌

<tr><td>`file:///path/to/x^c
<td>`file:///path/to/x#hash^c
<td>✅

<tr><td>`file:///path/to/x^c
<td>`file:///path/to/x?search^c
<td>✅

<tr><td>`file:///path/to/x^c
<td>`file:///path/to/y^c
<td>❌

<tr><td>`about:blank^c
<td>`about:blank#hash^c
<td>✅

<tr><td>`about:blank^c
<td>`about:blank?search^c
<td>❌

<tr><td>`about:blank^c
<td>`about:srcdoc^c
<td>❌

<tr><td>`data:text/html,foo^c
<td>`data:text/html,foo#hash^c
<td>✅

<tr><td>`data:text/html,foo^c
<td>`data:text/html,foo?search^c
<td>❌

<tr><td>`data:text/html,foo^c
<td>`data:text/html,bar^c
<td>❌

<tr><td>`data:text/html,foo^c
<td>`data:bar^c
<td>❌

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43#hash^c
<td>✅

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43?search^c
<td>❌

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:https://example.com/anything^c
<td>❌

<tr><td>`blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43^c
<td>`blob:path^c
<td>❌
</tbody></table>
◎
document's URL 	targetURL 	can have its URL rewritten
https://example.com/home 	https://example.com/home#about 	✅
https://example.com/home 	https://example.com/home?page=shop 	✅
https://example.com/home 	https://example.com/shop 	✅
https://example.com/home 	https://user:pass@example.com/home 	❌
https://example.com/home 	http://example.com/home 	❌
file:///path/to/x 	file:///path/to/x#hash 	✅
file:///path/to/x 	file:///path/to/x?search 	✅
file:///path/to/x 	file:///path/to/y 	❌
about:blank 	about:blank#hash 	✅
about:blank 	about:blank?search 	❌
about:blank 	about:srcdoc 	❌
data:text/html,foo 	data:text/html,foo#hash 	✅
data:text/html,foo 	data:text/html,foo?search 	❌
data:text/html,foo 	data:text/html,bar 	❌
data:text/html,foo 	data:bar 	❌
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43#hash 	✅
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43?search 	❌
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:https://example.com/anything 	❌
blob:https://example.com/77becafe-657b-4fdc-8bd3-e83aaa5e8f43 	blob:path 	❌
</div>

<p>
ここでは、
`文書$の`生成元$docは関わらないことに注意。
それは、
次に挙げる様な事例では，文書の`~URL$docの`生成元$urlと合致しないこともある
⇒＃
生成元を他から継承した初期 `~about_blank$sc 文書／
~sandbox化された `iframe$e ／
`document.domain$m 設定子が利用されたとき
◎
Note how only the URL of the Document matters, and not its origin. They can mismatch in cases like about:blank Documents with inherited origins, in sandboxed iframes, or when the document.domain setter has been used.
</p>
</div>

<div class="example">

<p>
~gameを考える：
利用者は，常に，ある “線” 上のある座標に居て、
線に沿って~navigateでき，特定0の座標に対応する~pageを~bookmarkすれば後でそこへ戻れるとする。
◎
Consider a game where the user can navigate along a line, such that the user is always at some coordinate, and such that the user can bookmark the page corresponding to a particular coordinate, to return to it later.
</p>

<p>
そのような~gameの，位置 x=5 を実装している静的な~pageとして、
次の様なものがあるとする：
◎
A static page implementing the x=5 position in such a game could look like the following:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 5 に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"&gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"&gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
</pre>
<!-- 
<!DOCTYPE HTML>
<!-&45; this is https://example.com/line?x=5 -&45;>
<title>Line Game - 5</title>
<p>You are at coordinate 5 on the line.</p>
<p>
 <a href="?x=6">Advance to 6</a> or
 <a href="?x=4">retreat to 4</a>?
</p>
-->
<p>
そのような~systemにおいて問題になるのは、
利用者が~clickするたびに，~page全体を読込直す必要が生じることである。
次に、
~scriptを利用して同じことをする別の仕方を示す：
◎
The problem with such a system is that each time the user clicks, the whole page has to be reloaded. Here instead is another way of doing it, using script:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 &lt;span id="coord"&gt;5&lt;/span&gt; に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"
   onclick="go(1); return false;"
 &gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"
   onclick="go(-1); return false;"
 &gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
&lt;script&gt;
 var %currentPage = 5; /* <span class="comment"
>~serverからあてがわれる
◎
prefilled by server
</span> */
 function go(%d) {
   setupPage(%currentPage + %d);
   history.pushState(%currentPage, '', '?x=' + %currentPage);
 }
 onpopstate = function(%event) {
   setupPage(%event.state);
 }
 function setupPage(%page) {
   %currentPage = %page;
   document.title = 'Line Game - ' + %currentPage;
   document.getElementById('coord').textContent = %currentPage;
   document.links[0].href = '?x=' + (%currentPage + 1);
   document.links[0].textContent = 'Advance to ' + (%currentPage + 1);
   document.links[1].href = '?x=' + (%currentPage - 1);
   document.links[1].textContent = 'retreat to ' + (%currentPage - 1);
 }
&lt;/script&gt;
</pre>

<!-- 
<!DOCTYPE HTML>
&lt;!-&45; this starts off as https://example.com/line?x=5 &45;-&gt;
<title>Line Game - 5</title>
<p>You are at coordinate <span id="coord">5</span> on the line.</p>
<p>
 <a href="?x=6" onclick="go(1); return false;">Advance to 6</a> or
 <a href="?x=4" onclick="go(-1); return false;">retreat to 4</a>?
</p>
<script>
 var currentPage = 5; // prefilled by server

-->

<p>
これは、
~scriptの~supportを切っている~systemにおいても，依然として先掲の例の様に働くが、
`切っていない^em利用者は，ずっと高速に~navigateできるようになる
— 同じ体験に対し~network~accessはないので。
更には、
~scriptに基づく素朴な~approachによる利用者~体験と違って，~session履歴を
~bookmarkする／~navigateする
のも依然として働く。
◎
In systems without script, this still works like the previous example. However, users that do have script support can now navigate much faster, since there is no network access for the same experience. Furthermore, contrary to the experience the user would have with just a naïve script-based approach, bookmarking and navigating the session history still work.
</p>

<p>
上の例において，
`pushState()$m ~methodに対する %data 引数は、［
~serverへ送信されることになる情報と同じになる
］が［
利用者が~navigateするたびに~scriptが~URLを構文解析しなくとも済むような，より簡便な形
］になる。
◎
In the example above, the data argument to the pushState() method is the same information as would be sent to the server, but in a more convenient form, so that the script doesn't have to parse the URL each time the user navigates.
</p>
</div>

<div class="example">
<p>
ほとんどの~appは、
自身の履歴~entryのすべてに対し，同じ`~scroll復旧~mode$値を利用したいと求める。
そのためには、
アリな限り早く `scrollRestoration$m 属性を設定して
（例えば、文書の `head$e 要素~内の `script$e 要素で），［
履歴~sessionに追加された~entryが，欲される~scroll復旧~modeを取得する
］ことを確保することにより，達成できる。
◎
Most applications want to use the same scroll restoration mode value for all of their history entries. To achieve this they can set the scrollRestoration attribute as soon as possible (e.g., in the first script element in the document's head element) to ensure that any entry added to the history session gets the desired scroll restoration mode.
</p>

<pre class="lang-html">
&lt;head&gt;
  &lt;script&gt;
       if ('scrollRestoration' in history)
            history.scrollRestoration = 'manual';
  &lt;/script&gt;
&lt;/head&gt;
</pre>
</div>

			</section>
			<section id="history-notes">
<h4 title="Implementation notes for session history">7.10.4. ~session履歴~用の実装に対する注記</h4>

~INFORMATIVE

<p>
`History$I ~interfaceは、
実装が~session履歴を利用者に向けてどう表現するかについて制約を課すものではない。
◎
The History interface is not meant to place restrictions on how implementations represent the session history to the user.
</p>

<p>
例えば、
~session履歴を［
各~pageが，複数の “~~前方へ~~枝分かれする” ~pageを持つ
］様な方式で実装することもできる。
この仕様は、［
`history$m ~obj内の各~pageからなる一本道の~list
］が利用者からどう見えるかについて，実際の~session履歴から導出する方法は定義しない。
◎
For example, session history could be implemented in a tree-like manner, with each page having multiple "forward" pages. This specification doesn't define how the linear list of pages in the history object are derived from the actual session history as seen from the user's perspective.
</p>

<p>
同様に，ある~pageが 2 個の `iframe$e を包含しているとき，~pageは各 `iframe$e の `history$m ~objとは別個な `history$m ~objを持つ
— ［
2 個の内縁~frameと外縁~pageの~navi
］を互いに差挟むような~session履歴を伴うような。
代表的な~web~browserは、
利用者に “戻る” ~buttonを 1 個しか呈示しない事実があるにもかかわらず。
◎
Similarly, a page containing two iframes has a history object distinct from the iframes' history objects, despite the fact that typical web browsers present the user with just one "Back" button, with a session history that interleaves the navigation of the two inner frames and the outer page.
</p>

<p>
<strong>~security</strong>：
ある~pageが `pushState()$m を濫用して，
~UAの履歴~navi便宜性を “乗取る” のを避けるため、
~UAには，以前の~pageへ一足飛びに戻る仕方を利用者に供することが示唆される
（単に 1 つ前の状態へ後戻するのでなく）。
例えば、戻る~buttonは，［
~session履歴~内の~pageたちだけを示し，
他のどの状態も示さない~drop-down
］を備えるようにもできる。
同様に，聴覚~browserは、
2 個の前へ “戻る” ~command
— 1 つ前の状態へ後戻するもの, 以前の~pageへ一足飛びに戻るもの —
を持たせることもできる。
◎
Security: It is suggested that to avoid letting a page "hijack" the history navigation facilities of a UA by abusing pushState(), the UA provide the user with a way to jump back to the previous page (rather than just going back to the previous state). For example, the back button could have a drop down showing just the pages in the session history, and not showing any of the states. Similarly, an aural browser could have two "back" commands, one that goes back to the previous state, and one that jumps straight back to the previous page.
</p>

<p>
`pushState()$m, `replaceState()$m
いずれに対しても，~UAには、［
頻繁過ぎる~callや巨大過ぎる状態~objを介して，これらの~APIが濫用される
］のを防止することが奨励される。
上に詳細を与えたとおり，~algoでは、［
適切になるときは、~UAがそのような~callを無視する
］ことも明示的に許容されている。
◎
For both pushState() and replaceState(), user agents are encouraged to prevent abuse of these APIs via too-frequent calls or over-large state objects. As detailed above, the algorithm explicitly allows user agents to ignore any such calls when appropriate.
</p>

			</section>
			<section id="the-location-interface">
<h4 title="The Location interface">7.10.5. `Location^I ~interface</h4>

<p>
各 `~window$には、
その作成-時に，新たな `Location$I ~objが結付けられる。
【！＊ unique instance of 〜 allocated】
</p>

<p class="trans-note">【
以下，ここでは、
この節の内容のうち，~APIに関する部分のみ述べる。
他の内容は、
<a href="~HTMLWPROXY#the-location-interface">別~page</a>
にて。
】</p>

<dl class="domintro">
	<dt>%document.`~location0$m [ = %value ]</dt>
	<dt>%window.`location$m [ = %value ]</dt>
	<dd>
現在の~pageの所在を伴う `Location$I ~objを返す。
◎
Returns a Location object with the current page's location.
</dd>
	<dd>
設定して，別の~pageへ~navigateできる。
◎
Can be set, to navigate to another page.
</dd>
</dl>

<div class="algo">
<p>
`Document$I の
`~location0@m
取得子~手続きは
◎
The Document object's location getter steps are＼
</p>
<ol>
	<li>
~IF［
コレは`全部的に作動中$である
］
⇒
~RET コレに`関連な大域~obj$の `Location$I ~obj
◎
to return this's relevant global object's Location object, if this is fully active,＼
</li>
	<li>
~RET ~NULL
◎
and null otherwise.
</li>
</ol>
</div>

<div class="algo">
`Window$I の
`location@m
取得子~手続きは
⇒
~RET コレの `Location$I ~obj
◎
The Window object's location getter steps are to return this's Location object.
</div>

<p>
`Location$I ~objは、
その`文書$【それに`関連な文書$Loc？】が`属する閲覧~文脈$にて`作動中の文書$の`~URL$docを表現する。
それは、
`閲覧~文脈$の~session履歴の`現在の~entry$を
— `history$m ~obj内［
に~entryを追加する ／
の~entryを置換する
］ことを通して —
変更できるようにする。
◎
Location objects provide a representation of the URL of the active document of their Document's browsing context, and allow the current entry of the browsing context's session history to be changed, by adding or replacing entries in the history object.
</p>

<pre class="idl">
[Exposed=Window]
interface `Location@I { /* <span class="comment">
ただし、
<a href="~HTMLWPROXY#the-location-interface">追加的な作成~手続き</a>
と
<a href="~HTMLWPROXY#location-internal-methods">上書きされた内部~method</a>
も見よ。
◎
but see also additional creation steps and overridden internal methods
</span> */

  [`LegacyUnforgeable$] stringifier attribute USVString `href$m;
  [`LegacyUnforgeable$] readonly attribute USVString `origin$m;
  [`LegacyUnforgeable$] attribute USVString `protocol$m;
  [`LegacyUnforgeable$] attribute USVString `host$m;
  [`LegacyUnforgeable$] attribute USVString `hostname$m;
  [`LegacyUnforgeable$] attribute USVString `port$m;
  [`LegacyUnforgeable$] attribute USVString `pathname$m;
  [`LegacyUnforgeable$] attribute USVString `search$m;
  [`LegacyUnforgeable$] attribute USVString `hash$m;

  [`LegacyUnforgeable$] undefined `assign$m(USVString %url);
  [`LegacyUnforgeable$] undefined `replace$m(USVString %url);
  [`LegacyUnforgeable$] undefined `reload$m();

  [`LegacyUnforgeable$, SameObject] readonly attribute `DOMStringList$I `ancestorOrigins$m;
};
</pre>

<dl class="domintro">
	<dt>%location.`toString()^m</dt>
	<dt>%location.`href$m</dt>
	<dd>
`~URL$Locを返す。
◎
Returns the Location object's URL.
</dd>
	<dd>
設定して，所与の~URLへ~navigateできる。
◎
Can be set, to navigate to the given URL.
</dd>

	<dt>%location.`origin$m</dt>
	<dd>
`~URL$Locの生成元を返す。
◎
Returns the Location object's URL's origin.
</dd>

	<dt>%location.`protocol$m</dt>
	<dd>
`~URL$Locの~schemeを返す。
◎
Returns the Location object's URL's scheme.
</dd>
	<dd>
設定して，`~URL$Locの~schemeだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed scheme.
</dd>

	<dt>%location.`host$m</dt>
	<dd>
`~URL$Locの［
~host,
~port（~scheme用の`既定の~port$urlと異なるならば）
］を返す。
◎
Returns the Location object's URL's host and port (if different from the default port for the scheme).
</dd>
	<dd>
設定して，`~URL$Locの
~host, ~port
だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host and port.
</dd>

	<dt>%location.`hostname$m</dt>
	<dd>
`~URL$Locの~hostを返す。
◎
Returns the Location object's URL's host.
</dd>
	<dd>
設定して，`~URL$Locの~hostだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host.
</dd>

	<dt>%location.`port$m</dt>
	<dd>
`~URL$Locの~port を返す。
◎
Returns the Location object's URL's port.
</dd>
	<dd>
設定して，`~URL$Locの~portだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed port.
</dd>

	<dt>%location.`pathname$m</dt>
	<dd>
`~URL$Locの~path を返す。
◎
Returns the Location object's URL's path.
</dd>
	<dd>
設定して，`~URL$Locの~pathだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed path.
</dd>

	<dt>%location.`search$m</dt>
	<dd>
`~URL$Locの~queryを返す
（空でないならば 先頭の `?^l も含む）。
◎
Returns the Location object's URL's query (includes leading "?" if non-empty).
</dd>
	<dd>
設定して，`~URL$Locの~query（先頭の `?^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed query (ignores leading "?").
</dd>

	<dt>%location.`hash$m</dt>
	<dd>
`~URL$Locの素片を返す（空でないならば 先頭の `#^l を含む）。
◎
Returns the Location object's URL's fragment (includes leading "#" if non-empty).
</dd>
	<dd>
設定して，`~URL$Locの素片（先頭の `#^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").
</dd>

	<dt>%location.`assign(url)$m</dt>
	<dd>
%url へ~navigateする。
◎
Navigates to the given URL.
</dd>

	<dt>%location.`replace(url)$m</dt>
	<dd>
~session履歴から現在の~pageを除去した上で，所与の %url へ~navigateする。
◎
Removes the current page from the session history and navigates to the given URL.
</dd>

	<dt>%location.`reload()$m</dt>
	<dd>
現在の~pageを読込直す。
◎
Reloads the current page.
</dd>

	<dt>%location.`ancestorOrigins$m</dt>
	<dd>
`親~閲覧~文脈$から`~top-level閲覧~文脈$までの各［
先祖`閲覧~文脈$の生成元の値
］からなる， `DOMStringList$I ~objを返す。
◎
Returns a DOMStringList object listing the origins of the ancestor browsing contexts, from the parent browsing context to the top-level browsing context.
</dd>
</dl>

<p>
各 `Location$I ~obj %L には、
次が定義される：
◎
↓</p>

<dl class="def-list">
	<dt>`関連な文書@Loc</dt>
	<dd>
%L に`関連な大域~obj$に`対応する閲覧~文脈$ %B に応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ %B にて`作動中の文書$
◎
A Location object has an associated relevant Document, which is this Location object's relevant global object's browsing context's active document, if this Location object's relevant global object's browsing context is non-null, and null otherwise.
</dd>

	<dt>`~URL@Loc</dt>
	<dd>
%L に`関連な文書$Loc %文書 に応じて
⇒＃
~NULL ならば `~about_blank$sc ／
~ELSE_ %文書 の`~URL$doc
◎
A Location object has an associated url, which is this Location object's relevant Document's URL, if this Location object's relevant Document is non-null, and about:blank otherwise.
</dd>

	<dt>`先祖~生成元~list@</dt>
	<dd class="algo">
<p>
%L の作成-時に、［
次の手続きの結果で与えられる文字列の~list
］が結付けられた `DOMStringList$I ~objに設定するモノトスル：
◎
A Location object has an associated ancestor origins list. When a Location object is created, its ancestor origins list must be set to a DOMStringList object whose associated list is the list of strings that the following steps would produce:
</p>
		<ol>
			<li>
%~list ~LET 新たな空`~list$
◎
Let output be a new list of strings.
</li>
			<li>
%B ~LET %L を結付けている`文書$【 %L に`関連な文書$Loc？】が`属する閲覧~文脈$
【~Assert： %B ~NEQ ~NULL】
◎
Let current be the browsing context of the Document with which this Location object is associated.
</li>
			<li>
%B の
~EACH( `先祖~閲覧~文脈$ %先祖 )
に対し， %B に近い先祖から順に
⇒
%~list に次の結果を`付加する$
⇒
`生成元を直列化する$( %先祖 にて`作動中の文書$の`生成元$doc )
◎
Loop: If current has no parent browsing context, jump to the step labeled end.
◎
Let current be current's parent browsing context.
◎
Append the serialization of current's active document's origin to output.
◎
Return to the step labeled loop.
</li>
			<li>
~RET %~list
◎
End: Return output.
</li>
		</ol>
	</dd>
	<dd class="trans-note">【
この仕様の中では、
`ancestorOrigins$m のみから利用される。
~swからも利用されている。
】</dd>
</dl>

<div class="algo">
<p>
`~Location~objにより~navigateする@
ときは、
所与の
( `~URL$ %~URL, `履歴を取扱うときの挙動$ %履歴~取扱い（省略時は `既定$i ） )
に対し：
◎
To Location-object navigate, given a URL url and an optional history handling behavior historyHandling (default "default"):
</p>
<ol>
	<li>
%B ~LET この `Location$I ~obj`関連な大域~obj$に`対応する閲覧~文脈$
【~Assert： %B ~NEQ ~NULL】
◎
Let browsingContext be this Location object's relevant global object's browsing context.
</li>
	<li>
%~source閲覧~文脈 ~LET `現任な大域~obj$に`対応する閲覧~文脈$
◎
Let sourceBrowsingContext be the incumbent global object's browsing context.
</li>
	<li>
~IF［
この `Location$I ~objに`関連な文書$Locはまだ`完全に読込まれ$ていない
］~AND［
`現任な大域~obj$の`一過な作動化？$ ~EQ ~F
］
⇒
%履歴~取扱い ~SET `置換-$i
◎
If this Location object's relevant Document is not yet completely loaded, and the incumbent global object does not have transient activation, then set historyHandling to "replace".
</li>
	<li>
次を与える下で，
%B を %~URL へ`~navigate$する
（例外投出あり）
⇒＃
`例外を可能化するか$V ~SET ~T,
`履歴~取扱い$V ~SET %履歴~取扱い,
`~source閲覧~文脈$ ~SET %~source閲覧~文脈,
◎
Navigate browsingContext to url, with exceptionsEnabled set to true, historyHandling set to historyHandling, and the source browsing context set to sourceBrowsingContext.
</li>
</ol>
</div>

<div class="algo">
<p>
`Location$I ~obj %L の
`生成元~domainを検査する@
ときは、次を走らす：
</p>

<ol>
	<li>
%文書 ~LET %L に`関連な文書$Loc
</li>
	<li>
~IF［
%文書 ~NEQ ~NULL
］~AND［
( %文書 の`生成元$doc, `入口~設定群~obj$の`生成元$enV )
は`同じ生成元~domain$でない
］
⇒
~THROW `SecurityError$E
<!-- 
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException. 
／
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
-->
</li>
</ol>

<p class="trans-note">【
この手続きは、
以下を簡潔に記すためにこの訳に導入している。
】</p>
</div>

<div class="algo">
<p>
`href@m
取得子~手続きは：
◎
The href getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET `~URLを直列化する$( コレが指す`~URL$Loc )
◎
Return this's url, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`href$m 設定子~手続きは：
◎
The href setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
%~URL~record ~LET `相対的に~URL構文解析する$( 所与の値, `入口~設定群~obj$ )
◎
Parse the given value relative to the entry settings object.＼
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If that failed, throw a TypeError exception.
</li>
	<li>
`~Location~objにより~navigateする$( %~URL~record )
◎
Location-object navigate given the resulting URL record.
</li>
</ol>

<p class="note">注記：
`href$m 設定子に対しては、
意図的に~security検査は行われない。
◎
The href setter intentionally has no security check.
</p>
</div>

<div class="algo">
<p>
`origin@m
取得子~手続きは：
◎
The origin getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET `生成元を直列化する$( コレが指す`~URL$Locの`生成元$url )
◎
Return the serialization of this's url's origin.
</li>
</ol>
</div>

<div class="algo">
<p>
`protocol@m
取得子~手続きは：
◎
The protocol getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
コレが指す`~URL$Locの`~scheme$url,
`:^l
◎
Return this's url's scheme, followed by ":".
</li>
</ol>
</div>

<div class="algo">
<p>
`protocol$m 設定子~手続きは：
◎
The protocol setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
%~protocol文字列 ~LET 次を順に連結した結果
⇒＃
所与の値,
`:^l
◎
↓</li>
	<li>
<p>
%失敗かも ~LET
`~API用に~URL構文解析する$( %~protocol文字列, %複製~URL, `~scheme開始$uST )
◎
Let possibleFailure be the result of basic URL parsing the given value, followed by ":", with copyURL as url and scheme start state as state override.
</p>

<p class="note">注記：
~URL構文解析器は，連続する~colonを無視するので、
値に `https:^l を与えても
（あるいは `https::::^l でさえ），
`https^l を与えるのと同じことになる。
◎
Because the URL parser ignores multiple consecutive colons, providing a value of "https:" (or even "https::::") is the same as providing a value of "https".
</p>
	</li>
	<li>
~IF［
%失敗かも ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If possibleFailure is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
~IF［
%複製~URL の `~scheme$urlは`~HTTP_S~scheme$である
］
⇒
~RET
◎
If copyURL's scheme is not an HTTP(S) scheme, then terminate these steps.
</li>
	<li>
`~Location~objにより~navigateする$( %複製~URL )
◎
Location-object navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`host@m
取得子~手続きは：
◎
The host getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%~URL ~LET コレが指す`~URL$Loc
◎
Let url be this's url.
</li>
	<li>
~IF［
%~URL の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If url's host is null, return the empty string.
</li>
	<li>
%~host文字列 ~LET `~hostを直列化する$( %~URL の`~host$url )
◎
↓</li>
	<li>
~IF［
%~URL の`~port$url ~EQ ~NULL
］
⇒
~RET %~host文字列
◎
If url's port is null, return url's host, serialized.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
%~host文字列,
`:^l,
`整数を直列化する$( %~URL の`~port$url )
◎
Return url's host, serialized, followed by ":" and url's port, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`host$m 設定子~手続きは：
◎
The host setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
~IF［
%複製~URL は`不透明な~path$を持つ
］
⇒
~RET
◎
If copyURL has an opaque path, then return.
</li>
	<li>
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~host$uST )
◎
Basic URL parse the given value, with copyURL as url and host state as state override.
</li>
	<li>
`~Location~objにより~navigateする$( %複製~URL )
◎
Location-object navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`hostname@m
取得子~手続きは：
◎
The hostname getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~URL$Locの
`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this's url's host is null, return the empty string.
</li>
	<li>
~RET `~hostを直列化する$( コレが指す`~URL$Locの`~host$url )
◎
Return this's url's host, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`hostname$m 設定子~手続きは：
◎
The hostname setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
~IF［
%複製~URL は`不透明な~path$を持つ
］
⇒
~RET
◎
If copyURL has an opaque path, then return.
</li>
	<li>
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~hostname$uST )
◎
Basic URL parse the given value, with copyURL as url and hostname state as state override.
</li>
	<li>
`~Location~objにより~navigateする$( %複製~URL )
◎
Location-object navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`port@m
取得子~手続きは：
◎
The port getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~URL$Locの`~port$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this's url's port is null, return the empty string.
</li>
	<li>
~RET `整数を直列化する$( コレが指す`~URL$Locの`~port$url )
◎
Return this's url's port, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`port$m 設定子~手続きは：
◎
The port setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
~IF［
%複製~URL は `~username／~password／~portを持てない$
］
⇒
~RET
◎
If copyURL cannot have a username/password/port, then return.
</li>
	<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~port$url ~SET ~NULL
◎
If the given value is the empty string, then set copyURL's port to null.
</li>
	<li>
~ELSE
⇒
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~port$uST )
◎
Otherwise, basic URL parse the given value, with copyURL as url and port state as state override.
</li>
	<li>
`~Location~objにより~navigateする$( %複製~URL )
◎
Location-object navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`pathname@m
取得子~手続きは：
◎
The pathname getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET `~URL~pathを直列化する$( コレが指す`~URL$Loc )
◎
Return the result of URL path serializing this Location object's url.
</li>
</ol>
</div>

<div class="algo">
<p>
`pathname$m 設定子~手続きは：
◎
The pathname setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
~IF［
%複製~URL は`不透明な~path$を持つ
］
⇒
~RET
◎
If copyURL has an opaque path, then return.
</li>
	<li>
%複製~URL の`~path$url ~SET 空~list
◎
Set copyURL's path to the empty list.
</li>
	<li>
`~API用に~URL構文解析する$( 所与の値, %複製~URL, `~path開始$uST )
◎
Basic URL parse the given value, with copyURL as url and path start state as state override.
</li>
	<li>
`~Location~objにより~navigateする$( %複製~URL )
◎
Location-object navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`search@m
取得子~手続きは：
◎
The search getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~URL$Locの`~query$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this's url's query is either null or the empty string, return the empty string.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`?^l,
コレが指す`~URL$Locの`~query$url
◎
Return "?", followed by this's url's query.
</li>
</ol>
</div>

<div class="algo">
<p>
`search$m 設定子~手続きは：
◎
The search setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~query$url ~SET ~NULL
◎
If the given value is the empty string, set copyURL's query to null.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise, run these substeps:
</p>

		<ol>
			<li>
%入力 ~LET 所与の値
◎
↓</li>
			<li>
~IF［
%入力 の最初の文字 ~EQ `?^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "?" removed, if any.
</li>
			<li>
%複製~URL の`~query$url ~SET 空~文字列
◎
Set copyURL's query to the empty string.
</li>
			<li>
`~API用に~URL構文解析する$( %入力, %複製~URL, `~query$uST )
◎
Basic URL parse input, with copyURL as url, and query state as state override.
</li>
		</ol>
	</li>
	<li>
`~Location~objにより~navigateする$( %複製~URL )
◎
Location-object navigate to copyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`hash@m
取得子~手続きは：
◎
The hash getter steps are:
</p>
<ol>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document is non-null and its origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレが指す`~URL$Locの`素片$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this's url's fragment is either null or the empty string, return the empty string.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`#^l,
コレが指す`~URL$Locの`素片$url
◎
Return "#", followed by this's url's fragment.
</li>
</ol>
</div>

<div class="algo">
<p>
`hash$m 設定子~手続きは：
◎
The hash setter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%複製~URL ~LET コレが指す`~URL$Locの複製
◎
Let copyURL be a copy of this's url.
</li>
	<li>
%入力 ~LET 所与の値
◎
↓</li>
	<li>
~IF［
%入力 の最初の文字 ~EQ `#^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "#" removed, if any.
</li>
	<li>
%複製~URL の`素片$url ~SET 空~文字列
◎
Set copyURL's fragment to the empty string.
</li>
	<li>
`~API用に~URL構文解析する$( %入力, %複製~URL, `素片$uST )
◎
Basic URL parse input, with copyURL as url and fragment state as state override.
</li>
	<li>
<p>
~IF［
%複製~URL の`素片$url ~EQ コレの`~URL$Locの`素片$url
］
⇒
~RET
◎
If copyURL's fragment is this's url's fragment, then return.
</p>

<p class="note">注記：
この脱出措置は、
配備-済みな内容のうち［
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1733797#c2">~scrollに対し  `location.hash^c を冗長に設定する</a>もの
］との互換性に必要とされる。
それは、素片~naviを成す他の仕組み
— `href$m 設定子や `assign()$m など —
には適用されない。
◎
This bailout is necessary for compatibility with deployed content, which redundantly sets location.hash on scroll. It does not apply to other mechanisms of fragment navigation, such as the location.href setter or location.assign().
</p>
	</li>
	<li>
`~Location~objにより~navigateする$( %複製~URL )
◎
Location-object navigate to copyURL.
</li>
</ol>

<p class="note">注記：
`a$e, `area$e 要素~用の等価な~APIと違って，
`hash$m 設定子は、［
空~文字列を，配備-済みの~scriptと互換にするよう特別に扱う
］ことはない。
◎
Unlike the equivalent API for the a and area elements, the hash setter does not special case the empty string, to remain compatible with deployed scripts.
</p>
</div>

<div class="algo">
<p>
`assign(url)@m
~method~手続きは：
◎
The assign(url) method steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
%~URL~record ~LET `相対的に~URL構文解析する$( %url, `入口~設定群~obj$ )
◎
Parse url relative to the entry settings object.＼
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If that failed, throw a "SyntaxError" DOMException.
</li>
	<li>
`~Location~objにより~navigateする$( %~URL~record )
◎
Location-object navigate given the resulting URL record.
</li>
</ol>
</div>

<div class="algo">
<p>
`replace(url)@m
~method~手続きは：
◎
The replace(url) method steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null, then return.
</li>
	<li>
%~URL~record ~LET `相対的に~URL構文解析する$( %url, `入口~設定群~obj$ )
◎
Parse url relative to the entry settings object.＼
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If that failed, throw a "SyntaxError" DOMException.
</li>
	<li>
`~Location~objにより~navigateする$( %~URL~record, `置換-$i )
◎
Location-object navigate given the resulting URL record and "replace".
</li>
</ol>

<p class="note">注記：
`replace()$m ~methodに対しては、
~security検査は意図的に行われない。
◎
The replace() method intentionally has no security check.
</p>
</div>

<div class="algo">
<p>
`reload()@m
~method~手続きは：
◎
The reload() method steps are to run the appropriate steps from the following list:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET
◎
If this's relevant Document is null
• Return.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin
• Throw a "SecurityError" DOMException.
</li>
	<li>
%B ~LET コレに`関連な大域~obj$に`対応する閲覧~文脈$
◎
↓</li>
	<li>
<p>
~IF［
現在~実行-中の`~task$†は、
利用者による %B の~resizeに呼応して配送された `resize$et ~eventによるものである††
］
⇒
%B を塗直す†††
◎
If the currently executing task is the dispatch of a resize event in response to the user resizing the browsing context
• Repaint the browsing context and return.
</p>

<p class="trans-note">【†
`現在~走っている~task$？
】【††
すなわち，この~methodが `resize^et ~event~handlerの中から呼出されたとき？
】【†††
“`repaint^en”
— 単に描画し直す？
】</p>

	</li>
	<li>
~IF［
%B にて`作動中の文書$は`~iframe-srcdoc文書$である
］
⇒
`~iframeの属性を処理する$( %B の`容器$bc )
◎
If the browsing context's active document is an iframe srcdoc document
• Reprocess the iframe attributes of the browsing context's container.
</li>
	<li>
~ELSE
⇒
%B をコレが指す`~URL$Locへ`~navigate$する
— 次を与える下で
⇒＃
`例外を可能化するか$V ~SET ~T,
`履歴~取扱い$V ~SET `再読込み$i,
`~source閲覧~文脈$ ~SET %B
◎
Otherwise
• Navigate the browsing context to this's relevant Document's URL, with exceptionsEnabled set to true, historyHandling set to "reload", and the source browsing context set to the browsing context being navigated.
</li>
</ol>
</div>

<p>
利用者から ~UI要素†を通して［
`閲覧~文脈$ %B にて`作動中の文書$ %文書 を読込直す
］よう要請されたときは、
~UAは：
◎
When a user requests that the active document of a browsing context be reloaded through a user interface element,＼
</p>

<p class="trans-note">【†
~browserの “読込直す~button” 等を指すと思われるが，~DOM内の要素も含まれる？
】</p>

<ul>
	<li>
%B を %文書 と同じ資源へ`~navigate$するベキである
— 次を与える下で
⇒＃
`履歴~取扱い$V ~SET `再読込み$i,
◎
the user agent should navigate the browsing context to the same resource as that Document, with historyHandling set to "reload".＼
</li>
	<li>
非冪等~method（例： ~HTTP `POST^meth ）の事例では、
~UAは先ず，利用者にその演算を確認してもらうよう~promptするべきである
— さもなければ、
~transaction（例：購入や~database改変）が繰返され得るので。
◎
In the case of non-idempotent methods (e.g., HTTP POST), the user agent should prompt the user to confirm the operation first, since otherwise transactions (e.g., purchases or database modifications) could be repeated.＼
</li>
	<li>
［
読込直すとき、
~cacheを明示的に上書きする
］ことを，利用者に許容してもヨイ。
◎
User agents may allow the user to explicitly override any caches when reloading.
</li>
</ul>

<div class="algo">
<p>
`ancestorOrigins@m
取得子~手続きは：
◎
The ancestorOrigins getter steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な文書$Loc ~EQ ~NULL
］
⇒
~RET 空`~list$†
◎
If this's relevant Document is null, then return an empty list.
</li>
	<li>
コレの`生成元~domainを検査する$
◎
If this's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~RET コレの`先祖~生成元~list$
◎
Otherwise, return this's ancestor origins list.
</li>
</ol>

<p class="warning">
`ancestorOrigins$m 属性がどう働くかの詳細は、
まだ異論があり，変更され得る。
更なる情報は、
<a href="~HTMLissue/1918">課題 #1918</a> 
を見よ。
◎
The details of how the ancestorOrigins attribute works are still controversial and might change. See issue #1918 for more information.
</p>

<p class="trans-note">【†
常に同じ~objを返すはずなので（ [SameObject] ）、
実際には，コレに`関連な大域~obj$に`対応する閲覧~文脈$が破棄される時点で，
`先祖~生成元~list$が空にされるのかもしれない。
】</p>
</div>

<hr>

<p class="trans-note">【
以下，この節, およびその各 下位節の内容は、
<a href="~HTMLWPROXY#the-location-interface">別~page</a>
にて。
】</p>

			</section>
		</section>
</main>
