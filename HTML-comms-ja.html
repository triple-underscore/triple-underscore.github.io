<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Communication（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<style type="text/css">
.js-slot, .js-type {
	color: green;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'comms',
		collectParts: Util.collectParts,
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 161202 spec
}

function expand(){

	var class_map = {
		e: 'element',
		a: 'attr',
		E: 'error',
		P: 'production',
		et: 'event-type',
		st: 'attr-state',
		sl: 'js-slot',
		jT: 'js-type',
		jA: 'abstract',
		v: 'value',
	};

	var tag_map = {
		I: 'code', // IDL
		m: 'code', // IDL
		E: 'code', // err
		c: 'code', 
		e: 'code', // elem
		a: 'code', // attr
		et: 'code',
		st: 'span',
		sl: 'span',
		jA: 'span',
		jT: 'code',
		P: 'code',
		v: 'code', // attr value
		t: 'var',
		i: 'i',
	};

	var link_map = this.link_map;
	var context = '';

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|``?(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>'
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'bl': // byte literal
	text = '`<code class="literal">' + key + '</code>`';
	break;
case 'h': // HTTP header
	text = '`<code class="header">' + key + '</code>`';
	break;
case 'sl': // js slot
	text = '[[' + key + ']]';
	break;
case 'P': // production
	href = '#_p.' + key;
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case '0x': // escape '%'
	return '%x' + key;
	break;
}

if(match[1] === '`') {
	if(indicator === '^'){
		context = key;
	} else {
		klass = klass + '!' + context;
	}
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2017-10-03
trans_update:2017-10-03
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/comms.html
site_nav:comms,network,html
nav_prev:HTMLnavigator
nav_next:HTMLsse
trans_1st_pub:2016-12-06

●●original_urls
the-messageevent-interfaces:https://html.spec.whatwg.org/multipage/comms.html
server-sent-events:https://html.spec.whatwg.org/multipage/server-sent-events.html
network:https://html.spec.whatwg.org/multipage/web-sockets.html
web-messaging:https://html.spec.whatwg.org/multipage/web-messaging.html
channel-messaging:https://html.spec.whatwg.org/multipage/web-messaging.html
broadcasting-to-other-browsing-contexts:https://html.spec.whatwg.org/multipage/web-messaging.html

●●original_id_map


●●words_table1


BroadcastChannel:<code>BroadcastChannel</code> 
MessagePort:<code>MessagePort</code> 


●●words_table



入力ファイルをこの区画にドロップ。
（ファイルダイアログから入力：）
>

	●仕様（動詞
協調:coordination:~
取扱い:handling:取り扱い
不許可に:disallow:~
保証:guarantee:~
切替えれ:switch でき:~
判別-:distinguish:~
	判別できない:distinguishableでない
受容-:accept:~
無視-:ignore:~
	生-:occur:~
発展:evolution:~
拘束:constraint:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
結付けて:associate して:結び付けて
要求-:require:~
述べる:describe する:~
督促-:urge:~
確保-:ensure:~
計算:computation:~
見做して:assume して:~
設計:design:~
許容-:allow:~
開発者:developer:~
関係-:relate:~
関係性:relationship:~
防止-:prevent:~
遂行-:perform:~
避ける:avoid する:~
使役-:employ:~
到達-:reach:~
	到達でき:reachable:~
制約-:restrict:~
制限-:limit:~
	利用-:use:~
利用者:user:~
被呼出時:被 invoke 時:~
呼出す::invoke する:呼び出す
報告-:report:~
奨励-:encourage:~
孕まれ:involve され:~
定義-:define:~
実装-:implement:~
実装:implementation:~
実装者:implementor:~
尊守-:honor:~
導入-:introduce:~
影響-:affect:~
意味-:mean:~
意図-:intend:~
指定-:specify:~
指示-:indicate:~
期待-:expect:~
	予期されずに:unexpected
検証0-:verify:検証
求めて:want して:~
求める:want する:~
相互作用-:interact:やりとり
走って:run して:~
走らす:run する:~
走らせ:run し:~
抽象:abstract:~
	抽象~化:abstracting out
勧める:advise する:~
	放置-:forgot
	using:
	consist:
	know
	もたらす:lead
	〜とする:suppose


	●仕様
API:
Web:
UA:user agent:UA
model::::モデル
browser::::ブラウザ
bug::::バグ
library::::ライブラリ
web::::
support::::サポート
	未~supportの:unsupported
system::::システム
事例:case:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
任意の:arbitrary:~
作者:author:~
原則的:principle:~
問題:problem:~
完全:complete:~
実用的:practical:~
	実用的でなくなる:impractical
実際:actual:~
対称:symmetric:~
手続き:steps:~
方式:manner:~
明示的:explicit:~
暗黙的:implicit:~
含意:implications:~
本質的:essential:~
概して:typical に:~
機会:chance:~
注意深く:careful に:~
注意-:care:~
	格別に注意する:extra care
特色機能:feature:~
状況:situation:~
独立:independent:~
理由:reason:~
目的:purpose:~
直接的:direct:~
相似的:analogous:~
便利用:convenient:~
複雑さ:complexity:~
通常の:normal な:~
通常は:normal には:~
適切:appropriate:~
重要:important:~
高価:expensive:~
考慮-:consider:~
考える:consider する:~
的意味:sense:~
難点:difficulties:~
解決策:solution:~
基礎:basis:~
簡易的:naïve:~
効果:effect:~
black-box::::ブラックボックス
仮想の:virtual:~

	大げさすぎる:unreasonable overhead
	見込みが高い:likely
	任意選択:may／optional
	具体例として:for instance
	~~消費:usage
	~~要請:ask
	不要:no longer needed
	-:criteria
	例:example
	依然として:still
	~~主な違い:key difference
	含-:include
	序論:introduction
	得-:obtain
	とは限らない:necessarily
	必要-:need
	-:further
	節:section
	決して:never
	渡-:pass
	関わらず:regardless
	言い換えれば:In other words
	特に、:in particular
	似た命名の:similarly-named
	類似する:similar
	できないこと:inability
	利用でき:usable
	逆も同様:vice-versa
	当の:in question
	手の込んだ:elaborate
	目に見える:apparent
	optionally
	無論:of course
	ばかりの:just been
	こっち:over here
	そっち:your
	委ねる:opening up
	確かめる:make sure
	引き継いで:continuing
	することもあり得る:possibility of 〜 trying to
	〜に基づく:based／-based
	〜の代わりに:instead
	しかしながら，:however
	したがって:thus
	とりわけ:especially
	まったくin the slightest
	単に:merely
	何か:anything
	これら二者:together
	特に:most particularly
	自らに利する:on its behalf
	困った:rather unfortunate
	要は:key

	●network / messaging
URL:
scheme::::スキーム
address::::アドレス
address-book:address book::address 帳:アドレス帳
e-mail::::メール
メールアドレス:contact:::~
social::::ソーシャル

client::::クライアント
domain::::ドメイン
navigate::::ナビゲート
network::::ネットワーク
port::::ポート
protocol::::プロトコル
record::::レコード
server::::サーバ
server-sent::::サーバ送信
service::::サービス
site::::サイト
web-socket:web socket
host::::ホスト
hostname::::ホスト名
path::::パス
rate::::レート
	rate-limiting
投函-:post::~::ポスト
	投函~法:posting
投函済み:posted::~::ポスト済み
broadcast::::ブロードキャスト
access::::アクセス
文書間:cross-document:~
channel::::チャンネル
close::::
	~close済み:closed

message::::メッセージ
messaging:::message 法:メッセージ法
open::::
pipe::::パイプ
remote::::リモート
session::::セッション
source::::ソース
	source設定群:sourceSettings
listen::::リッスン
listener::::リスナ

受信-:receive::~
受信器:receiver::~
受信者:recipient::~
返信-:send back::~
送信-:send::~
送達-:deliver::~
応答-:respond::~
通信-:communicate::~
通信:communication::~
切断-:disconnect::~
接続-:connect::~
接続:connection::~
資格証:credentials::資格証明情報::クレデンシャル
資源:resource::~:リソース
連絡-:entangle::~
連絡:entangle::~
	連絡を解く:disentangle:~
伝送-:transmit::~
添付-:attach:~
主体:entity:~
宛先:target::~
流通:traffic:~
素片:fragment::~
動作-:act:~
消去っ:go away し:消え去っ

	●保安
DoS:denial-of-service:DoS
XSS:cross-site scripting:XSS
privacy::::プライバシー
risk::::リスク
保安:security::~:セキュリティ
log-in:log in:::ログイン
log-out:log out:::ログアウト
同一生成元:same-origin::~::同一オリジン
生成元:origin::~::オリジン
攻撃:attack:~
攻撃者:attacker:~
能力:capability:~
	~obj能力:object-capability
悪用-:exploite:~
完全性:integrity:~
敵対的:hostile:~
機密的:confidential:~
濫用-:abuse:~
漏洩-:leak:~
漏洩:leakage:~
特権:privilege:~
保護-:protect:~
信用-:trust:~
信用済み:trusted:~
検査-:check:~
欠陥:flaw:~
是認-:grant:~
動作者:actor:~
提供-:provide:~
提供者:provider:~
消費者:consumer:~
	大容量:high volume:~
増殖-:multiply:~

	●処理model
handler::::ハンドラ
現任の:incumbent:~
mark::::マーク
call:
catch:
algo:algorithm:::アルゴリズム
locking::::ロック処理
阻む:block する::~::ブロックする
console::::コンソール
clone::::
	clone~record:cloneRecord
flag::::フラグ
flow::::フロー
garbage::::ガーベジ
script::::スクリプト
code::::コード
task::::タスク
event-loop:event loop:::イベントループ
event::::イベント
源:source::~::ソース
cross-process::::プロセス間
搬送済み:shipped::~
未搬送の:unshipped::~

queue::::キュー
公告-:announce::~
転送-:transfer::~
	転送できる:transferable
保持体:holder::~::ホルダ
通知:notification::~
一時停止-:pause::~
所有者:owner::~
待機-:wait::~
破棄-:discard:~
伝播-:propagate::~
可能化-:enable::~
不能化-:disable::~
不能化:disabled::~
中断-:interrupt::~
再収集-:recollect::~
公開-:expose:~
共有-:share::~
共用:shared::~
処理-:process:~
回送-:forward::~
強く:strong に:~
強い:strong な:~
弱い:weak な:~
環境:environment:~
同時的:simultaneous:~
同期:synchronization:~
作動中:active::~::アクティブ
作成-:create:~
保たれ:keep され:~
保って:keep して:~

投出:throw:~
例外:exception:~
例外投出あり:rethrow any exceptions:~
	用意が整った旨:readiness:~
状態:state:~
操作-:manipulate:~
操作:manipulation:~
構築子:constructor::~::コンストラクタ
発火-:fire::~
登録-:register::~
行先:destination::~
要請:request::~::リクエスト
配送-:dispatch::~
休止可能:suspendable::~
即座:prompt::~
認知-:acknowledge:~
保守-:maintain:~
	短い:short
	二重化された:two-ways
破棄予定:doomed:~
	生きた:live な:~
	生き残り続け:continue to live
	毎分:per minute
	失われ:lost:~
代理-:proxy::~
時間:time:~
一定時間:certain amount of time:~

	●構文／stream
	LF:
	CR:
	COLON
	space
	BOM
data::::データ
frame::::フレーム
合致-:match:~
形式:format::~
構文解析-:parse::~::パース
解析済み:parsed::~::パース済み
直列化:serialization::~::シリアル化
直列化-:serialize::~::シリアル化
直列形:serialized::~::シリアル形
逆直列化-:deserialize::~::逆シリアル化

文字列:string:~
	数:number:~
順序:order:~
順序付け:ordering:~
収集-:collect:~
収集:collection:~
名前:name:~
名:name:~
型:type:~
読取る:read する:読み取る


	●未分類（動詞
入子に:nest:入れ子に
入子の:nested:入れ子の
出自に:originate:~
初期:initial:~
初期化-:initialize:~
削除-:delete:~
包含-:contain:~
参照-:reference:~
反復-:iterate:~
変更-:change:~
失敗:failure:~
移動-:move:~
表現-:represent:~
表示-:display:~
見出され:find され:~
設定-:set:~
追加-:add:~
開始-:start:~
除去-:remove:~
埋込んで:embed して:埋め込んで
形成-:form:~
	伝え:tell
	所与の:given
	与:give

	●未分類
UI:
closing:
DOM:
IDL:
JS:JavaScript
Realm:
interface::::インタフェース
凍結:frozen:~
取得子:getter:~

cookie:
clear:

	affectされない:unaffected
	落とす:drop
	form
game::::ゲーム
list::::リスト
配列:array:~
関数:function:~
memory::::メモリ
method::::メソッド
obj:object:::オブジェクト
pair::::ペア
property::::プロパティ
resize::::リサイズ
ID:
sort::::ソート
tab::::タブ
	time::::
	捉える:viewed as a
wildcard-keyword:wildcard keyword:::ワイルドカード
window::::
worker::::
全部的:full::~
大域:global::~::グローバル
局所:local::~::ローカル
担当の:responsible::~
設定群:settings::~
関連する:relevant な::~
閲覧文脈:browsing context::~
文書:document:~
子:child:~
要素:element:~
親:parent:~
属性:attribute:~
単独:single:~
個人名:person:~
値:value:~
側:side:~
内側:inside:~
内容:content:~
単純:simple:~
	直ぐには明らかに:immediately obvious

引数:argument:~
情報:information:~
新たな:new:~
有構造:structured:~
	比較的／より:relative:~
空:empty:~
管理-:manage:~
	利己:own
	返す:return
頁:page:::ページ

	同様
	場合
	方法
	注記
	あてがう:assign
	介:via
	新たに:newly
	通:through
	始-:begin
	対応:corresponding
	-:back
	入って来る:incoming
	どこか:floor
	片:piece
	等々:so forth
	後で:later
	相手~側~port:twin
	note
	-:causing
	respective
	instantaneous
	leaving
	starting
	first-class
	passing
	amount
	long
	sometime
	altogether
	part
	came
	形:form
	同順の:maintaining their relative order

	可能
	数値
	規定
	~~回復:
	一時的に多量の:high transient
	-:outer
	新~port~list:newPorts
	targetOrigin
	targetWindow
	targetRealm
	serialized
	finalTargetPort
	deserializeRecord
	parsedURL
	messageClone
	port1
	port2
	doomed
	transfer
	targetPort
	broadcastChannel
	sourceChannel
	BroadcastChannel
	MessagePort

	●指示語
	古いものから順:oldest first
	最早／それ以降:no longer
	最終的:final
	最終:final
	ある種の／一定の:certain
	別の:another
	十分:enough
	各:each
	合間:between
	同じ:same
	多数の:many
	後:after
	最後の:last
	結果:result
	異なる:different
	自身:itself
	複数の:multiple
	元の:original
	番目／個目:second／third
	いくつかの:several
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	それら:they／their／those／them／themselves
	一つ／もの:one
	-:whereby
	下:below:~
	両者／両:both
	-:identical
	two
	他の:other
	他の場合:otherwise
	再度／再び:again
	単独の／ 1 個の／同じ:single
	:earlier
	前:before
	次:next
	nothing
	now
	一部:part of
	前回:the previous
	一方
	他方
	片方
	一連
	両端:each end
	今度:now
	以下
	以外
	以降
	個
	初回
	前節
	各種
	唯一
	対応
	次第
	段階
	時点
	部位
	重複:duplicate:~


●●link_map



	●IDL
Transferable:~HTMLcloning#transferable
	
E.DataCloneError:~WEBIDL#datacloneerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SyntaxError:~WEBIDL#syntaxerror

I.BroadcastChannel:#broadcastchannel
	I.DOMException:~WEBIDL#idl-DOMException
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Blob:~FILEAPI#blob
I.Document:~HTMLdom#document
I.Event:~DOM4#interface-event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventSource:~HTMLsse#eventsource
I.EventTarget:~DOM4#interface-eventtarget
I.File:~FILEAPI#file
I.FileList:~FILEAPI#filelist-section
I.MessageChannel:#messagechannel
I.MessageEvent:#messageevent
I.MessageEventInit:#messageeventinit
I.MessageEventSource:#messageeventsource
I.MessagePort:#messageport
I.ServiceWorker:~SW#serviceworker
I.SharedWorkerGlobalScope:~WORKERS#sharedworkerglobalscope
I.WebSocket:~WEBSOCKET#websocket
I.Window:~WINDOW#window
	＊
I.WindowProxy:~WINDOW#windowproxy
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.XMLHttpRequest:~XHR#xmlhttprequest
I.object:~WEBIDL#idl-object

jT.Date:~TC39#sec-date-objects


	9.5
m!MessagePort.close:#dom-messageport-close
m!MessagePort.postMessage:#dom-messageport-postmessage
m!MessagePort.start:#dom-messageport-start
m!MessagePort.onmessage:#handler-messageport-onmessage
m!MessagePort.onmessageerror:#handler-messageport-onmessageerror


	9.6
m.BroadcastChannel:#dom-broadcastchannel
m!BroadcastChannel.Constructor:#dom-broadcastchannel
m!BroadcastChannel.postMessage:#dom-broadcastchannel-postmessage
m!BroadcastChannel.name:#dom-broadcastchannel-name
m!BroadcastChannel.close:#dom-broadcastchannel-close
m!BroadcastChannel.onmessage:#handler-broadcastchannel-onmessage
m!BroadcastChannel.onmessageerror:#handler-broadcastchannel-onmessageerror

	9.5.2
	m.Constructor:#dom-messagechannel
m.MessageChannel:#dom-messagechannel
m.port1:#dom-messagechannel-port1
m.port2:#dom-messagechannel-port2

m.postMessage:#dom-window-postmessage
m.window.postMessage:#dom-window-postmessage

m.initMessageEvent:#dom-messageevent-initmessageevent
m.lastEventId:#dom-messageevent-lasteventid
m.origin:#dom-messageevent-origin
m.ports:#dom-messageevent-ports
m.source:#dom-messageevent-source
m.data:#dom-messageevent-data

m.addEventListener:~DOM4#dom-eventtarget-addeventlistener
~closing~flag:~WORKERS#dom-workerglobalscope-closing
m.initEvent:~DOM4#dom-event-initevent
e.iframe:~HEembed#the-iframe-element
et.connect:~HTMLindex#event-workerglobalscope-connect
et.hashchange:~HTMLindex#event-hashchange
et.message:~HTMLindex#event-message
et.messageerror:~HTMLindex#event-messageerror
et.resize:~CSSOMVIEW#eventdef-window-resize
	●

~BroadcastChannel設定群~obj:#broadcastchannel-settings-object
~channel名:#channel-name
~close済み~flag:#concept-broadcastchannel-closed

eS.最後の~event~ID文字列:~HTMLsse#concept-event-stream-last-event-id

~port~message~queue:#port-message-queue
未搬送の~port~message~queue:#unshipped-port-message-queue
投函済み~message~task源:#posted-message-task-source

搬送済み~flag:#has-been-shipped
所有者:#concept-port-owner

~MessagePort~objを作成する:#create-a-new-messageport-object
~portを連絡する:#entangle


	§
	:#event-stream-interpretation
~server-sent~event:~HTMLsse#server-sent-events
~web-socket:~WEBSOCKET#network
~broadcast~channel:#broadcasting-to-other-browsing-contexts
~channel~messaging:#channel-messaging
文書間~messaging:#web-messaging


	●
	:~HTML5/introduction.html#fingerprint-postMessage

jA.StructuredSerialize:~HTMLcloning#structuredserialize
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
jA.StructuredSerializeWithTransfer:~HTMLcloning#structuredserializewithtransfer
jA.StructuredDeserializeWithTransfer:~HTMLcloning#structureddeserializewithtransfer
転送できる:~HTMLcloning#transferable-objects
転送-手続き:~HTMLcloning#transfer-steps
転送-受信-時の手続き:~HTMLcloning#transfer-receiving-steps

enV.大域~obj:~WAPI#concept-settings-object-global
enV.生成元:~WAPI#concept-settings-object-origin

~Realm:~WAPI#concept-global-object-realm
現任の設定群~obj:~WAPI#incumbent-settings-object

~event-loop:~WAPI#event-loop
閲覧文脈~event-loop:~WAPI#_browsing-context-event-loop
~event~handler:~WAPI#event-handlers
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
~task:~WAPI#concept-task
~taskを~queueする:~WAPI#queue-a-task
~task~queue:~WAPI#task-queue
~task源:~WAPI#task-source
~DOM操作~task源:~WAPI#dom-manipulation-task-source
担当の~event-loop:~WAPI#responsible-event-loop
担当の文書:~WAPI#responsible-document
環境~設定群~obj:~WAPI#environment-settings-object
設定群~obj:~WAPI#settings-object
関連する~Realm:~WAPI#concept-relevant-realm
関連する設定群~obj:~WAPI#relevant-settings-object

全部的に作動中:~BROWSERS#fully-active
閲覧文脈:~BROWSERS#browsing-context

結付けられている文書:~WINDOW#concept-document-window

同一生成元:~ORIGIN#same-origin
生成元:~ORIGIN#concept-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

~navigate:~NAVI#navigate
休止可能:~WORKERS#suspendable-worker
~worker:~WORKERS#worker
共用~worker:~WORKERS#sharedworker
共用~worker内:~WORKERS#sharedworkerglobalscope

凍結~配列:~WEBIDL#dfn-frozen-array-type

~eventを発火する:~DOM4#concept-event-fire

url.生成元:~URL1#concept-url-origin
url.素片:~URL1#concept-url-fragment
~URL:~URL1#concept-url
	~URL~record:~URL1#concept-url
~URL構文解析する:~URL1#concept-url-parser


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">Communication</a>
章を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>


<header id="head">
	<hgroup>
<h1>通信 — Communication</h1>
	</hgroup>

</header>

<main id="MAIN" style="display:none;">

	<section id="comms">
<h1 title="Communication">9. 通信</h1>

		<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="the-messageevent-interfaces">
<h2 title="The MessageEvent interfaces">9.1. `MessageEvent$I ~interface</h2>

  
<p>
`~server-sent~event$における~message,
`~web-socket$,
`文書間~messaging$,
`~channel~messaging$,
`~broadcast~channel$
では、各 `message$et ~eventに `MessageEvent$I ~interfaceを利用する：
◎
Messages in server-sent events, Web sockets, cross-document messaging, channel messaging, and broadcast channels use the MessageEvent interface for their message events:
</p>


<pre class="idl">
[Constructor(DOMString type, optional `MessageEventInit$I eventInitDict), Exposed=(Window,Worker,AudioWorklet)]
interface `MessageEvent@I : `Event$I {
  readonly attribute any `data$m;
  readonly attribute USVString `origin$m;
  readonly attribute DOMString `lastEventId$m;
  readonly attribute `MessageEventSource$I? `source$m;
  readonly attribute FrozenArray&lt;`MessagePort$I&gt; `ports$m;

 void `initMessageEvent$m(DOMString %type, optional boolean %bubbles = false, optional boolean %cancelable = false, optional any %data = null, optional USVString %origin = "", optional DOMString %lastEventId = "", optional `MessageEventSource$I? %source = null, optional sequence&lt;`MessagePort$I&gt; %ports = []);
};

dictionary `MessageEventInit@I : `EventInit$I {
  any data = null;
  USVString origin = "";
  DOMString lastEventId = "";
  `MessageEventSource$I? source = null;
  sequence&lt;`MessagePort$I&gt; ports = [];
};

typedef (`WindowProxy$I or `MessagePort$I or `ServiceWorker$I) `MessageEventSource@I;
</pre>

<dl class="domintro">

	<dt>%event . `data$m</dt>
	<dd>
~messageの~dataを返す。
◎
Returns the data of the message.
</dd>

	<dt>%event . `origin$m</dt>
	<dd>
［
`~server-sent~event$ ／
`文書間~messaging$
］の下では、~messageの生成元を返す。
◎
Returns the origin of the message, for server-sent events and cross-document messaging.
</dd>

	<dt>%event . `lastEventId$m</dt>
	<dd>
`~server-sent~event$の下では、`最後の~event~ID文字列$eSを返す。
◎
Returns the last event ID string, for server-sent events.
</dd>

	<dt>%event . `source$m</dt>
	<dd>
`文書間~messaging$の下では、~source~window
【送信-元~window】
の `WindowProxy$I を返す。
`SharedWorkerGlobalScope$I ~objに向けて発火された `connect$et ~eventにおいては、添付されている `MessagePort$Iを返す。
◎
Returns the WindowProxy of the source window, for cross-document messaging, and the MessagePort being attached, in the connect event fired at SharedWorkerGlobalScope objects.
</dd>

	<dt>%event . `ports$m</dt>
	<dd>
［
`文書間~messaging$ ／ `~channel~messaging$
］の下では、~messageに伴われて送信された `MessagePort$I 配列を返す。
◎
Returns the MessagePort array sent with the message, for cross-document messaging and channel messaging.
</dd>

</dl>


<dl class="idl-def">
	<dt>`data@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
送信されてきた~messageを表現する。
◎
The data attribute must return the value it was initialized to. It represents the message being sent.
</dd>

	<dt>`origin@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
これは、［
`~server-sent~event$ ／
`文書間~messaging$
］の下では、~messageを送信した文書の`生成元$を表現する（概して 当の文書の［
~scheme, ~hostname, ~port
］からなるなるが、その［
~path／`素片$url
］は含まない
)。
◎
The origin attribute must return the value it was initialized to. It represents, in server-sent events and cross-document messaging, the origin of the document that sent the message (typically the scheme, hostname, and port of the document, but not its path or fragment).
</dd>

	<dt>`lastEventId@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
これは、`~server-sent~event$の下では、
`EventSource$I ~objの`最後の~event~ID文字列$eSを表現する。
◎
The lastEventId attribute must return the value it was initialized to. It represents, in server-sent events, the last event ID string of the event source.
</dd>

	<dt>`source@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
これは、`文書間~messaging$の下では、~messageを送ってきた
`Window$I ~objの`閲覧文脈$の `WindowProxy$I を表現する。
`共用~worker内$で利用される `connect$et ~eventにおいては、新たに接続している `MessagePort$I になる。
◎
The source attribute must return the value it was initialized to. It represents, in cross-document messaging, the WindowProxy of the browsing context of the Window object from which the message came; and in the connect events used by shared workers, the newly connecting MessagePort.
</dd>

	<dt>`ports@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
これは、［
`文書間~messaging$ ／ `~channel~messaging$
］の下では、~messageに伴って送信される `MessagePort$I 配列を表現する。
◎
The ports attribute must return the value it was initialized to. It represents, in cross-document messaging and channel messaging, the MessagePort array being sent.
</dd>

	<dt>`initMessageEvent()@m</dt>
	<dd>
被呼出時には、似た命名の `initEvent()$m ~methodに相似的な方式で~eventを初期化し~MUST。
`DOM$r
◎
The initMessageEvent() method must initialize the event in a manner analogous to the similarly-named initEvent() method. [DOM]
</dd>
</dl>

<p class="note">注記：
種々の~API（例： `WebSocket$I や `EventSource$I ）は、
`MessagePort$I ~APIを利用せずに，
`MessageEvent$I ~interfaceを `message$et ~eventに利用する。
◎
Various APIs (e.g., WebSocket, EventSource) use the MessageEvent interface for their message event without using the MessagePort API.
</p>


		</section>
		<section id="server-sent-events">
<h2 title="Server-sent events">9.2. ~server-sent~event</h2>

<p class="trans-note">【
この節の内容の和訳は、<a href="~HTMLsse#network">別ページ</a>にて。
】</p>

		</section>
		<section id="network">
<h2 title="Web sockets">9.3. ~web-socket</h2>

<p class="trans-note">【
この節の内容の和訳は、<a href="~WEBSOCKET#network">別ページ</a>にて。
】</p>

		</section>
		<section id="web-messaging">
<h2 title="Cross-document messaging">9.4. 文書間~messaging</h2>
<a id="crossDocumentMessages"></a>


<p>
保安や~privacyの理由から、~web~browserは，異なる~domainに属する文書どうしが互いに影響しあうのを防止する
— すなわち、~XSSは不許可にされる。
◎
Web browsers, for security and privacy reasons, prevent documents in different domains from affecting each other; that is, cross-site scripting is disallowed.
</p>

<p>
これは重要な保安~用の特色機能であるが、異なる~domainに属する頁との通信は，その頁が敵対的でなくとも防止される。
この節では、~source~domainに関わらず，文書どうしが互いに~messageを通信しあえるようにする~systemを、~XSS攻撃を可能化しないように設計される仕方で導入する。
◎
While this is an important security feature, it prevents pages from different domains from communicating even when those pages are not hostile. This section introduces a messaging system that allows documents to communicate with each other regardless of their source domain, in a way designed to not enable cross-site scripting attacks.
</p>

<p class="note">注記：
この~APIには、直ぐには明らかにならないかもしれない
<a href="~HTML5/introduction.html#fingerprint-postMessage">ある~privacy上の含意がある</a>。
◎
This API has some privacy implications that might not be immediately obvious.
</p>


<p>
`投函済み~message~task源@
が、`文書間~messaging$における`~task$の`~task源$になる。
◎
The task source for the tasks in cross-document messaging is the posted message task source.
</p>

			<section id="introduction-12">
<h3 title="Introduction">9.4.1. 序論</h3>

~INFORMATIVE

<div class="example">

<p>
例えば，ある文書 %A が
`iframe$e 要素を包含していて,
その要素は 別の文書 %B を包含している下で，
%A 内の~scriptが %B の `Window$I ~objの
`window.postMessage()$m を~callした場合、~message~eventは，その~objに向けて発火される
— %A の `Window$I を出自にしているよう~markされた上で。
%A 内の~scriptは次の様になるであろう：
◎
For example, if document A contains an iframe element that contains document B, and script in document A calls postMessage() on the Window object of document B, then a message event will be fired on that object, marked as originating from the Window of document A. The script in document A might look like:
</p>

<pre class="js-code">
var %o = document.getElementsByTagName('iframe')[0];
%o.contentWindow.postMessage('Hello world', 'https://b.example.org/');
</pre>

<p>
%B 内の~scriptは、入って来る~eventに対する~event~handlerを登録するため、
`addEventListener()^m （または類似する仕組み）を利用することになる。
例えば，次の様になるであろう：
◎
To register an event handler for incoming events, the script would use addEventListener() (or similar mechanisms). For example, the script in document B might look like:
</p>

<pre class="js-code">
window.addEventListener('message', receiver, false);
function receiver(%e) {
  if (%e.origin == 'https://example.com') {
    if (%e.data == 'Hello world') {
      %e.source.postMessage('Hello', %e.origin);
    } else {
      alert(%e.data);
    }
  }
}
</pre>

<p>
この~scriptは、まず，~domainが期待されるものかどうか検査する。
次に，~messageの中身に応じて、利用者に表示するか，または
~message送信してきた文書に ~messageを返信して応答する。
◎
This script first checks the domain is the expected domain, and then looks at the message, which it either displays to the user, or responds to by sending a message back to the document which sent the message in the first place.
</p>

  </div>





			</section>
			<section id="security-postmsg">
<h3 title="Security">9.4.2. 保安</h3>

				<section id="authors">
<h4 title="Authors">9.4.2.1. 作者</h4>


<p id="security-4" class="warning">
利己~目的で~siteを濫用する敵対的~主体から 利用者を保護するため、この~APIの利用にあたっては，格別に注意することが要求される。
◎
Use of this API requires extra care to protect users from hostile entities abusing a site for their own purposes.
</p>

<p>
作者は、 `origin$m 属性を検査して，受容する~messageを，自身が期待する~domainから受信されるものに限ることを確保するべきである。
作者の~message取扱い~code内に~bugがある場合、敵対的~siteにより悪用され得ることになる。
◎
Authors should check the origin attribute to ensure that messages are only accepted from domains that they expect to receive messages from. Otherwise, bugs in the author's message handling code could be exploited by hostile sites.
</p>

<p>
加えて， `origin$m 属性を検査した後でも、作者は，当の~dataが期待される形式であるかどうか検査するべきある。
さもなければ、~eventの~sourceが~XSSに対する欠陥を突いて攻撃されていた場合に、
`window.postMessage()$m ~methodで送信された情報は，攻撃により受信器にまで伝播されることになる。
◎
Furthermore, even after checking the origin attribute, authors should also check that the data in question is of the expected format. Otherwise, if the source of the event has been attacked using a cross-site scripting flaw, further unchecked processing of information sent using the postMessage() method could result in the attack being propagated into the receiver.
</p>

<p>
作者は、機密的~情報を包含するような~messageに対しては，生成元~引数（ %targetOrigin ）に~wildcard-keyword （ `*^l ）を渡すべきでない。
そうしない以外に、~messageの送達-先を意図された受信者のみに限るよう保証する仕方はない。
◎
Authors should not use the wildcard keyword (*) in the targetOrigin argument in messages that contain any confidential information, as otherwise there is no way to guarantee that the message is only delivered to the recipient to which it was intended.
</p>

<hr>

<p>
どの生成元からの~messageも受容する作者には、~DoS攻撃の~riskを考慮することが奨励される。
攻撃者は大容量の~messageを送信することもできる。
受信-中の頁が高価な計算を遂行したり，そのような各~messageごとに 送信-による~network流通が生じる場合、攻撃者の~messageは，~DoS攻撃~用に増殖される。
作者には、そのような攻撃が実用的でなくなるよう，~rate制限-法を使役することが奨励される（毎分あたりの~message数を一定に抑えるなど）。
◎
Authors who accept messages from any origin are encouraged to consider the risks of a denial-of-service attack. An attacker could send a high volume of messages; if the receiving page performs expensive computation or causes network traffic to be sent for each such message, the attacker's message could be multiplied into a denial-of-service attack. Authors are encouraged to employ rate limiting (only accepting a certain number of messages per minute) to make such attacks impractical.
</p>


				</section>
				<section id="user-agents">
<h4 title="User agents">9.4.2.2. ~UA</h4>

<p>
この~API
【による~message】
の完全性は、ある`生成元$の~scriptが，任意の~eventを（`同一生成元$でない）他の生成元に属する~objへ（ `dispatchEvent()^m などを用いて）投函できないことに基づいている。
◎
The integrity of this API is based on the inability for scripts of one origin to post arbitrary events (using dispatchEvent() or otherwise) to objects in other origins (those that are not the same).
</p>

<p class="note">注記：
実装者には、この特色機能を実装するにあたり，格別に注意することが督促される。
この特色機能は、作者がある~domainから別の~domainへ情報を伝送できるようにする
— 通常は 保安の理由から不許可にされるような。
また，~UAには、ある種の~propertyへの~accessを，一方には許容しつつ, 他方には許容しないよう注意深くなることが要求される。
◎
Implementors are urged to take extra care in the implementation of this feature. It allows authors to transmit information from one domain to another domain, which is normally disallowed for security reasons. It also requires that UAs be careful to allow access to certain properties but not others.
</p>

<hr>

<p>
簡易的な~siteを~DoS攻撃から保護するため、~UAには，異なる`生成元$の間での~message流通~rateの制限-法を考慮することが奨励される。
◎
User agents are also encouraged to consider rate-limiting message traffic between different origins, to protect naïve sites from denial-of-service attacks.
</p>


				</section>
			</section>
			<section id="posting-messages">
<h3 title="Posting messages">9.4.3. ~messageの投函-法</h3>

<dl class="domintro">

	<dt>%window . `postMessage(message, targetOrigin [, transfer ] )$m</dt>
	<dd>
<p>
%message を %window へ投函する。
%message は有構造~objにもなり得る。
例えば次のものを包含できる：
</p>

<ul><li>入子にされた~objや配列
</li><li>~JS値（ `string^jT, `number^jT, `Date$jT ~obj, 等々）
</li><li>`File$I, `Blob$I, `FileList$I, `ArrayBuffer$I などの，ある種の~data~obj
</li></ul>
◎
Posts a message to the given window. Messages can be structured objects, e.g. nested objects and arrays, can contain JavaScript values (strings, numbers, Date objects, etc), and can contain certain data objects such as File Blob, FileList, and ArrayBuffer objects.
</dd>
	<dd>
%transfer 内に~listされた~objは、~cloneされるのみならず転送される
— すなわち，送信-側からは、それ以降，それらを利用できなくなる。
◎
Objects listed in transfer are transferred, not just cloned, meaning that they are no longer usable on the sending side.
</dd>
	<dd>
宛先 %window の生成元が，生成元 %targetOrigin に合致しない場合、情報~漏洩を避けるため，~messageは 破棄される。
生成元に関わらず，~messageを宛先に送信したければ、
%targetOrigin に `*^l を与える。
生成元を明示的に与えずに ~messageを同一生成元の宛先のみに制約したければ、
%targetOrigin に `/^l を与える。
◎
If the origin of the target window doesn't match the given origin, the message is discarded, to avoid information leakage. To send the message to the target regardless of origin, set the target origin to "*". To restrict the message to same-origin targets only, without needing to explicitly state the origin, set the target origin to "/".
</dd>
	<dd>
次の場合は `DataCloneError$E が投出される
⇒
%transfer 配列が同じ~objを重複して包含する場合／
%message を~cloneできなかった場合
◎
Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or if message could not be cloned.
</dd>

</dl>

<p class="note">注記：
~navigateされたばかりの`閲覧文脈$に属する新たな `Document$I の `Window$I に，~messageを投函した場合、その~messageは，意図された受信者に受信されない見込みが高い
— 宛先 `閲覧文脈$内の~scriptは、~messageに対する~listenerを設定しておく時間を要するので。
したがって，具体例として、~messageが 新たに作成された子 `iframe$e の `Window$I に送信される状況においては、作者には、子 `Document$I から先に，受信する用意が整った旨を親~宛に公告する~messageを投函させ、親は，この~messageを待機してから~messageを投函し始めるようにすることを勧める。
◎
When posting a message to a Window of a browsing context that has just been navigated to a new Document is likely to result in the message not receiving its intended recipient: the scripts in the target browsing context have to have had time to set up listeners for the messages. Thus, for instance, in situations where a message is to be sent to the Window of newly created child iframe, authors are advised to have the child Document post a message to their parent announcing their readiness to receive messages, and for the parent to wait for this message before beginning posting messages.
</p>


<p class="idl-def">
`Window$I ~obj上の
`postMessage( message, targetOrigin, transfer )@m
の被呼出時には、次の手続きを走らせ~MUST：
◎
The postMessage(message, targetOrigin, transfer) method, when invoked on a Window object must run the following steps:
</p>

<ol>
	<li>
%宛先~window ~LET 此れ
◎
Let targetWindow be this Window object.
</li>
	<li>
%宛先~Realm ~LET %宛先~window の`~Realm$
◎
Let targetRealm be targetWindow's Realm.
</li>
	<li>
%現任の設定群 ~LET `現任の設定群~obj$
◎
Let incumbentSettings be the incumbent settings object.
</li>
	<li>
%宛先~生成元 ~LET ε
◎
↓</li>
	<li>
~IF［
%targetOrigin ~EQ U+002F （ `/^l ）
］
⇒
%宛先~生成元 ~SET %現任の設定群 の`生成元$enV
◎
If targetOrigin is a single U+002F SOLIDUS character (/), then set targetOrigin to incumbentSettings's origin.
</li>
	<li>
<p>
~ELIF［
%targetOrigin ~NEQ U+002A （ `*^l ）
］：
◎
Otherwise, if targetOrigin is not a single U+002A ASTERISK character (*), then:
</p>

		<ol>
			<li>
%解析済み~URL ~LET `~URL構文解析する$( %targetOrigin )
◎
Let parsedURL be the result of running the URL parser on targetOrigin.
</li>
			<li>
~IF［
%解析済み~URL ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If parsedURL is failure, then throw a "SyntaxError" DOMException.
</li>
			<li>
%宛先~生成元 ~SET %解析済み~URL の`生成元$url
◎
Set targetOrigin to parsedURL's origin.
</li>
		</ol>
	</li>
	<li>
%転送-を伴う直列化-結果 ~LET `StructuredSerializeWithTransfer$jA( %message, %transfer )
（例外投出あり）
◎
Let serializeWithTransferResult be StructuredSerializeWithTransfer(message, transfer). Rethrow any exceptions.
</li>
	<li>
<p>
`投函済み~message~task源$から，次を走らす`~taskを~queueする$：
◎
Queue a task on the posted message task source to run the following steps:
</p>
		<ol>
			<li>
~IF［
%宛先~生成元 ~NEQ ε
］~AND［
( %宛先~window に`結付けられている文書$の`生成元$,  %宛先~生成元 )
は`同一生成元$でない
］
⇒
~RET
◎
If the targetOrigin argument is not a single literal U+002A ASTERISK character (*) and targetWindow's associated Document's origin is not same origin with targetOrigin, then abort these steps.
</li>
			<li>
%生成元 ~LET `生成元を直列化する$( %現任の設定群 の`生成元$enV )
◎
Let origin be the serialization of incumbentSettings's origin.
</li>
			<li>
%~source ~LET
`WindowProxy$I ~objの対応している【？】
%現任の設定群 の`大域~obj$enV （ `Window$I ~obj）
◎
Let source be the WindowProxy object's corresponding to incumbentSettings's global object (a Window object).
</li>
			<li>
<p>
%逆直列化-~record ~LET `StructuredDeserializeWithTransfer$jA( %転送-を伴う直列化-結果, %宛先~Realm )
◎
Let deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, targetRealm).
</p>

<p>
ここで例外が投出されたときは、~catchして：
◎
If this throws an exception, catch it,＼
</p>
				<ol>
					<li>
%宛先~window に向けて，次のように初期化された`~eventを発火する$
⇒＃
名前 `messageerror$et,
`MessageEvent$I を利用する,
`origin$m 属性 ~SET %生成元,
`source$m 属性 ~SET %~source
◎
fire an event named messageerror at targetWindow, using MessageEvent, with the origin attribute initialized to origin and the source attribute initialized to source, and then＼
</li>
					<li>
~RET
◎
abort these steps.
</li>
				</ol>
			</li>
			<li>
%~message~clone ~LET %逆直列化-~record . `Deserialized^sl
◎
Let messageClone be deserializeRecord.[[Deserialized]].
</li>
			<li>
%新~port~list ~LET
%逆直列化-~record . `TransferredValues^sl 内の すべての `MessagePort$I ~objからなる，同順の新たな`凍結~配列$
◎
Let newPorts be a new frozen array consisting of all MessagePort objects in deserializeRecord.[[TransferredValues]], if any, maintaining their relative order.
</li>
			<li>
%宛先~window に向けて，次のように初期化された`~eventを発火する$
⇒＃
名前 `message$et,
`MessageEvent$I を利用する,
`origin$m 属性 ~SET %生成元,
`source$m 属性 ~SET %~source,
`data$m 属性 ~SET  %~message~clone,
`ports$m 属性 ~SET %新~port~list
◎
Fire an event named message at targetWindow, using MessageEvent, with the origin attribute initialized to origin, the source attribute initialized to source, the data attribute initialized to messageClone, and the ports attribute initialized to newPorts.
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
		<section id="channel-messaging">
<h2 title="Channel messaging">9.5. ~channel~messaging</h2>

<!-- ``MessagePort^I -->

			<section id="introduction-13">
<h3 title="Introduction">9.5.1. 序論</h3>

~INFORMATIVE

<p>
`~channel~messaging$
【channel messaging （ “~channelを介した~messageの送信-法” ）】
を利用すれば、作者は，独立な~code片どうし（例えば，異なる`閲覧文脈$内で走っているもの）を 直接的に通信させれる。
◎
To enable independent pieces of code (e.g. running in different browsing contexts) to communicate directly, authors can use channel messaging.
</p>

<p>
この仕組みにおける通信~channelは、両端に~portを伴う，二重化された~pipeとして実装される。
一方の~portに送信される~messageは，他方の~portに送達され、逆も同様になる。
各~messageは、走っている`~task$を中断したり阻むことなく，~DOM~eventとして送達される。
◎
Communication channels in this mechanism are implemented as two-ways pipes, with a port at each end. Messages sent in one port are delivered at the other port, and vice-versa. Messages are delivered as DOM events, without interrupting or blocking running tasks.
</p>

<p>
接続（ “連絡された”  2 個の~port）を作成するためには、
`MessageChannel()$m 構築子を~callする：
◎
To create a connection (two "entangled" ports), the MessageChannel() constructor is called:
</p>

<pre class="js-code">
var %channel = new MessageChannel();
</pre>

<p>
一方の~portは 局所~portとして保たれ、他方の~portは ~remote~codeへ送信される
— 例えば `window.postMessage()$m を用いて：
◎
One of the ports is kept as the local port, and the other port is sent to the remote code, e.g. using postMessage():
</p>

<pre class="js-code">
%otherWindow.postMessage('hello', 'https://example.com', [%channel.port2]);
</pre>

<p>
~messageを送信するためには、局所~port上の ``postMessage()$m ~methodを利用する：
◎
To send messages, the postMessage() method on the port is used:
</p>

<pre class="js-code">
%channel.port1.postMessage('hello');
</pre>

<p>
~messageを受信するためには、 `message$et ~eventを~listenする：
◎
To receive messages, one listens to message events:
</p>

<pre class="js-code">
%channel.port1.onmessage = handleMessage;
function handleMessage(%event) {
  /* <span class="comment">
~messageは %event の`data$m 属性~内にある
◎
message is in event.data
</span> */
  // ...
}
</pre>

<p>
~portに送信する~dataは、有構造~dataも可能である。
例えば，次では、一連の文字列からなる配列が `MessagePort$I に渡される：
◎
Data sent on a port can be structured data; for example here an array of strings is passed on a MessagePort:
</p>

<pre class="js-code">
%channel.port1.postMessage(['hello', 'world']);
</pre>




				<section id="examples-5">
<h4 title="Examples">9.5.1.1. 例</h4>

~INFORMATIVE

<div class="example">

<p>
この例では、  2 つの~JS~libraryが `MessagePort$I を用いて互いに接続される。
これにより，~libraryは、~APIを何ら変更することなく，後で［
`~worker$ ~obj／異なる~frame
］内に~hostすることも可能になる。
◎
In this example, two JavaScript libraries are connected to each other using MessagePorts. This allows the libraries to later be hosted in different frames, or in Worker objects, without any change to the APIs.
</p>

<pre>
&lt;script src="contacts.js"&gt;&lt;/script&gt; &lt;!-- <span class="comment">
%contacts ~objを公開する
◎
exposes a contacts object
</span> --&gt;
&lt;script src="compose-mail.js"&gt;&lt;/script&gt; &lt;!-- <span class="comment">
%composer ~objを公開する
◎
exposes a composer object
</span> --&gt;
&lt;script&gt;
 var %channel = new MessageChannel();
 %composer.addContactsProvider(%channel.port1);
 %contacts.registerConsumer(%channel.port2);
&lt;/script&gt;
</pre>

<p>
`addContactsProvider()^c 関数の実装は、次の様になる：
◎
Here's what the "addContactsProvider()" function's implementation could look like:
</p>

<pre class="js-code">
function addContactsProvider(%port) {
  %port.onmessage = function (%event) {
    switch (%event.data.messageType) {
      'search-result': handleSearchResult(%event.data.results); break;
      'search-done': handleSearchDone(); break;
      'search-error': handleSearchError(%event.data.message); break;
      // ...
    }
  };
};
</pre>

<p>
あるいは、次の様に実装することもできる：
◎
Alternatively, it could be implemented as follows:
</p>

<pre class="js-code">
function addContactsProvider(%port) {
  %port.addEventListener('message', function (%event) {
    if (%event.data.messageType == 'search-result')
      handleSearchResult(%event.data.results);
  });
  %port.addEventListener('message', function (%event) {
    if (%event.data.messageType == 'search-done')
      handleSearchDone();
  });
  %port.addEventListener('message', function (%event) {
    if (%event.data.messageType == 'search-error')
      handleSearchError(%event.data.message);
  });
  // ...
  %port.start();
};
</pre>

<p>
上の 2 つの~codeにおける~~主な違いは、
`addEventListener()$m を利用した場合，
``start()$m ~methodも呼出す必要がある点にある。
``onmessage$m を利用した場合，暗黙的に ``start()$m も~callされる。
◎
The key difference is that when using addEventListener(), the start() method must also be invoked. When using onmessage, the call to start() is implied.
</p>

<p>
``start()$m ~methodは、明示的に~callされようが，（ ``onmessage$m を設定することにより）暗黙的に~callされようが，~messageの~flowを開始する。
その前の初期~時においては、~message~portに投函された~messageは，~scriptが自身による~handlerを設定しておく機会を得る前に どこかへ落とされないよう，一時停止される。
◎
The start() method, whether called explicitly or implicitly (by setting onmessage), starts the flow of messages: messages posted on message ports are initially paused, so that they don't get dropped on the floor before the script has had a chance to set up its handlers.
</p>

</div>


				</section>
				<section id="ports-as-the-basis-of-an-object-capability-model-on-the-web">
<h4 title="Ports as the basis of an object-capability model on the Web">9.5.1.2. ~web上の~obj能力~modelの基礎としての~port</h4>

~INFORMATIVE

<p class="trans-note">【
<a href="https://en.wikipedia.org/wiki/Object-capability_model">~obj能力~model</a>
】</p>

<p>
~portは、［
~system内の他の動作者に，制限された能力を公開する仕方
］と捉えることもできる（~obj能力~model的意味で）。
これは、弱い能力~systemにも、強い能力~modelにもなり得る。
弱い能力~systemにおける~portは、単に同じ生成元の中で便利用~modelとして利用される。
強い能力~systemにおける~portは、ある生成元に属する %提供者 （ provider ）から 別の生成元に属する %消費者 （ consumer ）に向けて， %消費者 が［
%提供者 に効果を及ぼせる ／
%提供者 からの情報を得る
］ような唯一の仕組みとして，提供される。
◎
Ports can be viewed as a way to expose limited capabilities (in the object-capability model sense) to other actors in the system. This can either be a weak capability system, where the ports are merely used as a convenient model within a particular origin, or as a strong capability model, where they are provided by one origin provider as the only mechanism by which another origin consumer can effect change in or obtain information from provider.
</p>

<p>
例えば、ある %~social~site の頁が，次のような 2 個の `iframe$e を埋込んでいる状況を考える：
◎
For example, consider a situation in which a social Web site embeds＼
</p>

<ul>
	<li>
%提供者~frame は、（ %~social~site とは別の生成元に属する） %提供者
— ここでは，利用者の~address-bookを提供している~serviceとする —
からの内容を含んでいる
◎
in one iframe the user's e-mail contacts provider (an address book site, from a second origin), and＼
</li>
	<li>
%消費者~frame は、（また別の生成元に属する）
%消費者
— 例えば，ある~game~siteなど —
からの内容を含んでいる
◎
in a second iframe a game (from a third origin).＼
</li>
</ul>

<p>
%~social~site 頁, および %消費者~frame 内からは、
%提供者~frame の内側にあるものには~accessできない
— これら二者が %提供者~frame の内側に何か及ぼせるのは、次に限られる：
◎
The outer social site and the game in the second iframe cannot access anything inside the first iframe; together they can only:
</p>


<ul>
	<li>
%提供者~frame を［
%提供者~frame の~URLと`素片$urlだけ異なる`~URL$
］へ`~navigate$する
—  %提供者~frame 内の `Window$I は `hashchange$et ~eventを受信することになる。
◎
Navigate the iframe to a new URL, such as the same URL but with a different fragment, causing the Window in the iframe to receive a hashchange event.
</li>
	<li>
%提供者~frame を~resizeする
— %提供者~frame 内の `Window$I は `resize$et ~eventを受信することになる。
◎
Resize the iframe, causing the Window in the iframe to receive a resize event.
</li>
	<li>
`window.postMessage()$m ~APIを用いて， %提供者~frame 内の `Window$I へ `message$et ~eventを送信する。
◎
Send a message event to the Window in the iframe using the window.postMessage() API.
</li>
</ul>

<p>
%提供者 は、これらのうち，特に 3 番目の~method
— `message$et ~event —
を利用して、他の生成元から~accessできるような，利用者の~address-bookを操作するための~APIを提供する。
例えば、~message
"<code class="literal">add-contact: Guillaume Tell &lt;tell@pomme.example.net&gt;</code>"
に対し、それが与える個人名とその~e-mail~addressを 利用者の~address-bookに追加することにより，応答することもできる。
◎
The contacts provider can use these methods, most particularly the third one, to provide an API that can be accessed by other origins to manipulate the user's address book. For example, it could respond to a message "add-contact Guillaume Tell &lt;tell@pomme.example.net&gt;" by adding the given person and e-mail address to the user's address book.
</p>

<p>
~Web上の どの~siteも利用者の~address-bookを操作できては困るので、
%提供者 は，当の %~social~site など, 一定の信用済み~siteに限って，これを許容するであろう。
◎
To avoid any site on the Web being able to manipulate the user's contacts, the contacts provider might only allow certain trusted sites, such as the social site, to do this.
</p>

<p>
ここで、 %消費者 は，利用者の~address-bookにメールアドレス（例えば、~gameの対戦相手の）を追加したいと求めていて、 %~social~site は，自らに利するため それを許容するつもりにあるとする
— それは，本質的には、 %提供者 が %~social~site と信用-を “共有すること” に等しい。
これを行う仕方にはいくつかあり、最も単純なのは， %~social~site が %消費者 ~siteと %提供者  ~siteとの間の~messageを代理することであろう。
しかしながら、この解決策には 難点がある：
◎
Now suppose the game wanted to add a contact to the user's address book, and that the social site was willing to allow it to do so on its behalf, essentially "sharing" the trust that the contacts provider had with the social site. There are several ways it could do this; most simply, it could just proxy messages between the game site and the contacts site. However, this solution has a number of difficulties:＼
</p>

<ul>
	<li>
%~social~site は、［
%消費者 ~siteが特権を濫用しないこと
］を完全に信用するか，あるいは 許容したくない要請（メールアドレスを［
複数~追加する ／ 読取る ／ 削除する
］など）ではないことを確かめるため，各~要請を検証0することが要求される。
◎
it requires the social site to either completely trust the game site not to abuse the privilege, or it requires that the social site verify each request to make sure it's not a request that it doesn't want to allow (such as adding multiple contacts, reading the contacts, or deleting them);＼
</li>
	<li>
他にもいくつかの %消費者 が居て，同時的に %提供者 と相互作用することもあり得る場合、複雑さが増す。
◎
it also requires some additional complexity if there's ever the possibility of multiple games simultaneously trying to interact with the contacts provider.
</li>
</ul>

<p>
~message~channelと `MessagePort$I ~objを用いれば、これらの問題すべてを消し去れる。
%消費者 がメールアドレスを追加したいと求める旨を %~social~site に伝えたとき、 %~social~site は、メールアドレスを追加することではなく，［
1 個のメールアドレスを追加する<em>能力</em>
］について， %提供者 に~~要請できる。
それに対し， %提供者 は、
`MessagePort$I ~objの~pairを作成して，その片方を %~social~site に返信する。
%~social~site は、受信したそれを %消費者 に回送する。
それにより、 %消費者 と %提供者 は，直接的に接続されることになり、
%提供者 は， “1 個のメールアドレスを追加する” 要請のみ尊守すればよいことを知る。
言い換えれば、 %消費者 には， 1 個のメールアドレスを追加する能力が是認されたことになる。
◎
Using message channels and MessagePort objects, however, all of these problems can go away. When the game tells the social site that it wants to add a contact, the social site can ask the contacts provider not for it to add a contact, but for the capability to add a single contact. The contacts provider then creates a pair of MessagePort objects, and sends one of them back to the social site, who forwards it on to the game. The game and the contacts provider then have a direct connection, and the contacts provider knows to only honor a single "add contact" request, nothing else. In other words, the game has been granted the capability to add a single contact.
</p>




				</section>
				<section id="ports-as-the-basis-of-abstracting-out-service-implementations">
<h4 title="Ports as the basis of abstracting out service implementations">9.5.1.3. ~service実装を抽象~化する基礎としての~port</h4>

~INFORMATIVE

<p>
前~節からの例を引き継いで、特に， %提供者 側を考える。
初期~実装では、単純に~serviceの `iframe$e 内で `XMLHttpRequest$I ~objを利用していたが、~serviceの発展に伴い，単独の `WebSocket$I 接続を備える`共用~worker$の利用に代えたいと求めることもあろう。
◎
Continuing the example from the previous section, consider the contacts provider in particular. While an initial implementation might have simply used XMLHttpRequest objects in the service's iframe, an evolution of the service might instead want to use a shared worker with a single WebSocket connection.
</p>

<p>
初期~設計の段階で， `MessagePort$I ~objを［
能力を是認するため／
または単に複数の同時的な独立~sessionを許容するため
］に利用していたなら、~service実装は，~APIに全く手を加えずに［
各 `iframe$e ごとに `XMLHttpRequest$I を用いる~model
］から［
`WebSocket$I を共有する~model
］へ切替えれるようになる
— ~service提供者~側のすべての~portは、~APIの利用者にまったく影響することなく，共用~workerに回送できる。
◎
If the initial design used MessagePort objects to grant capabilities, or even just to allow multiple simultaneous independent sessions, the service implementation can switch from the XMLHttpRequests-in-each-iframe model to the shared-WebSocket model without changing the API at all: the ports on the service provider side can all be forwarded to the shared worker without it affecting the users of the API in the slightest.
</p>





				</section>
			</section>
			<section id="message-channels">
<h3 title="Message channels">9.5.2. ~message~channel</h3>

<pre class="idl">
[<a href="#dom-messagechannel">Constructor</a>, Exposed=(Window,Worker)]
interface `MessageChannel@I {
  readonly attribute `MessagePort$I `port1$m;
  readonly attribute `MessagePort$I `port2$m;
};
</pre>

<dl class="domintro">

	<dt>%channel = new `MessageChannel()$m</dt>
	<dd>
2 個の新たな `MessagePort$I ~objが伴われた，新たな `MessageChannel$I ~objを返す。
◎
Returns a new MessageChannel object with two new MessagePort objects.
</dd>

	<dt>%channel . `port1$m</dt>
	<dd>
1 個目の `MessagePort$I ~objを返す。
◎
Returns the first MessagePort object.
</dd>

	<dt>%channel . `port2$m</dt>
	<dd>
2 個目の `MessagePort$I ~objを返す。
◎
Returns the second MessagePort object.
</dd>
</dl>

<dl class="idl-def">
	<dt>`MessageChannel()@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
◎
When the MessageChannel() constructor is called, it must run the following algorithm:
</p>

		<ol>
			<li>
%port1 ~LET `~MessagePort~objを作成する$( `現任の設定群~obj$ )
◎
Create a new MessagePort object whose owner is the incumbent settings object, and let port1 be that object.
</li>
			<li>
%port2 ~LET `~MessagePort~objを作成する$( `現任の設定群~obj$ )
◎
Create a new MessagePort object whose owner is the incumbent settings object, and let port2 be that object.
</li>
			<li>
`~portを連絡する$( %port1, %port2 )
◎
Entangle the port1 and port2 objects.
</li>
			<li>
%~channel ~LET 新たな `MessageChannel$I ~obj
◎
Instantiate a new MessageChannel object, and let channel be that object.
</li>
			<li>
%~channel の `port1$m 属性 ~SET %port1
◎
Let the port1 attribute of the channel object be port1.
</li>
			<li>
%~channel の `port2$m 属性 ~SET %port2
◎
Let the port2 attribute of the channel object be port2.
</li>
			<li>
~RET %~channel
◎
Return channel.
</li>
		</ol>
	</dd>

	<dt>`port1@m</dt>
	<dt>`port2@m</dt>
	<dd>
いずれの取得子も、此れの作成-時にあてがわれた値を返さ~MUST。
◎
The port1 and port2 attributes must return the values they were assigned when the MessageChannel object was created.
</dd>
</dl>

			</section>
			<section id="message-ports">
<h3 title="Message ports">9.5.3. ~message~port</h3>

<p>
各~channelは、 2 個の~message~portを持つ。
一方の~portから送信された~dataは，他方の~portに受信され、逆も同様になる。
◎
Each channel has two message ports. Data sent through one port is received by the other port, and vice versa.
</p>

<pre class="idl">
[Exposed=(Window,Worker,AudioWorklet) `Transferable$]
interface `MessagePort@I : `EventTarget$I {
  void ``postMessage$m(any %message, optional sequence&lt;`object$I&gt; %transfer = []);
  void ``start$m();
  void ``close$m();

  // event handlers
  attribute `EventHandler$I ``onmessage$m;
  attribute `EventHandler$I ``onmessageerror$m;
};
</pre>

<dl class="domintro">

	<dt>%port . ``postMessage( message [, transfer] )$m</dt>
	<dd>
~channelを通して~messageを投函する。
%transfer 内に~listされた~objは、~cloneされるのみならず転送される
— すなわち，送信-側からは、それ以降，それらを利用できなくなる。
◎
Posts a message through the channel. Objects listed in transfer are transferred, not just cloned, meaning that they are no longer usable on the sending side.
</dd>
	<dd>
次の場合は `DataCloneError$E が投出される
⇒
%transfer 配列が 同じ~objを重複して包含する場合 ／
%transfer 配列が この~port自身や宛先~portを包含する場合 ／
%message を~cloneできなかった場合
◎
Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or the source or target ports, or if message could not be cloned.
</dd>

	<dt>%port . ``start()$m</dt>
	<dd>
この~portに受信される／された~messageを配送させ始める。
◎
Begins dispatching messages received on the port.
</dd>

	<dt>%port . ``close()$m</dt>
	<dd>
この~portを切断する。
以降、この~portは 作動中でなくなる。
◎
Disconnects the port, so that it is no longer active.
</dd>

</dl>

<div class="p">
<p>
各 `MessagePort$I ~objは、別のそれと連絡され得る（その関係性は対称になる）。
</p>

<p class="trans-note">【
`port1$m, `port2$m のどちらを手元において もう片方を転送しようがかまわない。
】</p>

<p>
各 `MessagePort$I ~objは、次のものを持つ：
</p>

<dl class="def-list">
	<dt>`~port~message~queue@</dt>
	<dd>
`~task源$†。
初期~時には空とする。
`~port~message~queue$は、初期~時には不能化されており，ある時点で可能化され得る。
可能化された後，再び不能化されることは決してない（~queue~内の~messageたちは、別の~queueへ移動されたり，すべて除去されることもあるが
— それは、不能化されるのとほぼ同じ効果になる）。
</dd>
	<dd class="trans-note">【†
ここでは、個々の`~task源$と 個々の`~task~queue$としての`~port~message~queue$とが，同一視されている。
】</dd>

	<dt>`搬送済み~flag@</dt>
	<dd>
初期~時には ~OFF にされ~MUST
</dd>

	<dt>`所有者@</dt>
	<dd>
~objの作成-時に 下に述べるように設定される，`設定群~obj$。
</dd>

</dl>
◎
Each MessagePort object can be entangled with another (a symmetric relationship). Each MessagePort object also has a task source called the port message queue, initially empty. A port message queue can be enabled or disabled, and is initially disabled. Once enabled, a port can never be disabled again (though messages in the queue can get moved to another queue or removed altogether, which has much the same effect). A MessagePort also has a has been shipped flag, which must initially be false, and an owner, which is a settings object set when the object is created, as described below.
</div>

<p>
ある~port %P の`~port~message~queue$ %Q が可能化されたときは、
`~event-loop$は， %Q をその`~task源$の一つとして利用し~MUST。
%P の`所有者$が指定する`担当の~event-loop$が`閲覧文脈~event-loop$である場合、
%Q に~queueされた`~task$に結付けられる文書は，［
%P の`所有者$が指定する`担当の文書$
］にされ~MUST。
◎
When a port's port message queue is enabled, the event loop must use it as one of its task sources. When a port's owner specifies a responsible event loop that is a browsing context event loop, all tasks queued on its port message queue must be associated with the responsible document specified by the port's owner.
</p>

<p class="note">注記：
~portの`所有者$が指定する`担当の文書$が`全部的に作動中$であって、~portに登録されたすべての~event~listenerの~scriptは，［
その`設定群~obj$が `全部的に作動中$でない`担当の文書$を指定する
］場合、~queueされた~messageたちは，失われることになる。
◎
If the port's owner specifies a responsible document that is fully active, but the event listeners all have scripts whose settings objects specify responsible documents that are not fully active, then the messages will be lost.
</p> 


<div class="p">
<p>
各 `~event-loop$は、
`未搬送の~port~message~queue@
と呼ばれる`~task源$を持つ。
これは， “仮想の†” ~queueであり、［
下の条件を満たす各 `MessagePort$I %P の`~port~message~queue$
］内の~taskすべてを，~taskが~queueされた順序††で包含しているかのように動作し~MUST
— ~taskが`未搬送の~port~message~queue$から除去されるときは、代わりに，それが実際に属する`~port~message~queue$から除去され~MUST。
</p>

<p>
ここで、各 %P は，次をすべて満たすとする：
</p>

<ul><li>%P の`搬送済み~flag$ ~EQ ~OFF
</li><li>%P の`~port~message~queue$は可能化されている
</li><li>%P の`所有者$が指定する`担当の~event-loop$ ~EQ 当の`~event-loop$
</li></ul>

<p class="trans-note">【†
“仮想の” — すなわち、いくつかの~queueを包装するだけの，それ自身は実体を持たない~queue。
】【††
異なる`~port~message~queue$に属する~taskどうしの，`未搬送の~port~message~queue$の中での順序がどう定義されるのかは、明確に述べられていない（単に時系列順？）。
】</p>

◎
Each event loop has a task source called the unshipped port message queue. This is a virtual task source: it must act as if it contained the tasks of each port message queue of each MessagePort whose has been shipped flag is false, whose port message queue is enabled, and whose owner specifies that event loop as the responsible event loop, in the order in which they were added to their respective task source. When a task would be removed from the unshipped port message queue, it must instead be removed from its port message queue.
</div>

<p>
［
`MessagePort$I の`搬送済み~flag$ ~EQ ~OFF
］の下では、その`~port~message~queue$は，`~event-loop$の目的においては無視され~MUST（代わりに，`未搬送の~port~message~queue$が利用される）。
◎
When a MessagePort's has been shipped flag is false, its port message queue must be ignored for the purposes of the event loop. (The unshipped port message queue is used instead.)
</p>

<p class="note">注記：
`MessagePort$I ~obj %P の`搬送済み~flag$は、［
%P, %P の相手~側~port, %P の~clone元~obj
］のいずれかが，転送されるか, すでにされている
］ときに ~ON にされる。
%P の`搬送済み~flag$が ~ON にされて以降は、
%P の`~port~message~queue$は first-class `~task源$
【すなわち， “通常の，独立な” ~task源】
として動作し，`未搬送の~port~message~queue$には影響しなくなる
【その一部を成さなくなる】。
◎
The has been shipped flag is set to true when a port, its twin, or the object it was cloned from, is or has been transferred. When a MessagePort's has been shipped flag is true, its port message queue acts as a first-class task source, unaffected to any unshipped port message queue.
</p>

<p class="algo-head">
~UAは，
`~MessagePort~objを作成する@
ときは、所与の
( `環境~設定群~obj$ %所有者 )
に対し，新たな `MessagePort$I ~objを［
その`所有者$ ~SET %所有者
］とした上で返さ~MUST。
◎
When the user agent is to create a new MessagePort object with a particular environment settings object as its owner, it must instantiate a new MessagePort object, and let its owner be owner.
</p>

<p class="algo-head">
~UAは，
`~portを連絡する@
ときは、所与の 2 個の `MessagePort$I ~obj
( %A, %B )
に対し，次の手続きを走らせ~MUST：
◎
When the user agent is to entangle two MessagePort objects, it must run the following steps:
</p>

<ol>
	<li>
<p>
~EACH ( %P ~IN { %A, %B } ) に対し
⇒
~IF［
%P に連絡されている別の `MessagePort$I ~obj %Q がある
］
⇒
%P と %Q との連絡を解く
◎
If one of the ports is already entangled, then disentangle it and the port that it was entangled with.
</p>

<p class="note">注記：
%P, %Q が，ある `MessageChannel$I ~obj %C の 2 個の~portであった場合、
%C は最早~実際の~channelを表現しなくなる
— それ以降、 %P と %Q が連絡されることはない。
◎
If those two previously entangled ports were the two ports of a MessageChannel object, then that MessageChannel object no longer represents an actual channel: the two ports in that object are no longer entangled.
</p>

	</li>
	<li>
<p>
%A, %B を，ある新たな~channelの 2 個の部位を形成するように結付けて連絡する（その~channelを表現する `MessageChannel$I ~objは，まだない）
◎
Associate the two ports to be entangled, so that they form the two parts of a new channel. (There is no MessageChannel object that represents this channel.)
</p>

<p>
この時点で %A, %B は 互いに連絡されたことになる。
◎
Two ports A and B that have gone through this step are now said to be entangled; one is entangled to the other, and vice versa.
</p>

<p class="note">注記：
この仕様は，この処理-を instantaneous として述べるが、実装は，~message passing 【？】を介して実装する見込みが高い。
要は、他の~algoと同様，その最終的な結果が、~black-box的意味で “単に” 仕様が定めるものと判別できなければよい。
◎
While this specification describes this process as instantaneous, implementations are more likely to implement it via message passing. As with all algorithms, the key is "merely" that the end result be indistinguishable, in a black-box sense, from the specification.
</p>

	</li>
</ol>

<hr>

<p id="transferMessagePort">
`MessagePort$I ~objは`転送できる$。
◎
MessagePort objects are transferable objects.＼
</p>

<p>
その`転送-手続き$は、所与の
( %値, %~data保持体 )
に対し，次を走らす：
◎
Their transfer steps, given value and dataHolder, are:＼
</p>

<ol>
	<li>
%値 の`搬送済み~flag$ ~SET ~ON
◎
Set value's has been shipped flag to true.
</li>
	<li>
%~data保持体 . `PortMessageQueue^sl ~SET %値 の`~port~message~queue$
◎
Set dataHolder.[[PortMessageQueue]] to value's port message queue.
</li>
	<li>
<p>
~IF［
ある別~port %~remote~port が %値 に連絡されている
］：
◎
If value is entangled with another port remotePort, then:
</p>

		<ol>
			<li>
%~remote~port の`搬送済み~flag$ ~SET ~ON
◎
Set remotePort's has been shipped flag to true.
</li>
	<li>
<p>
%~data保持体 . `RemotePort^sl ~SET %~remote~port
◎
Set dataHolder.[[RemotePort]] to remotePort.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
⇒
%~data保持体 . `RemotePort^sl ~SET ~NULL
◎
Otherwise, set dataHolder.[[RemotePort]] to null.
</li>
</ol>

<p>
その`転送-受信-時の手続き$は、所与の
( %~data保持体, %値 )
に対し，次を走らす：
◎
Their transfer-receiving steps, given dataHolder and value, are:
</p>

<ol>
	<li>
%値 の`搬送済み~flag$ ~SET ~ON
◎
Set value's has been shipped flag to true.
</li>
	<li>
%所有者 ~LET %値 に`関連する設定群~obj$
◎
↓</li>
	<li>
%値 の`所有者$ ~SET %所有者
◎
Set value's owner to value's relevant settings object.
</li>
	<li>
<p>
%~data保持体 . `PortMessageQueue^sl 内の［
`message$et ~eventを発火する`~task$
］すべてを
%値 の`~port~message~queue$に移動する
— その際には：
◎
Move all the tasks that are to fire message events in dataHolder.[[PortMessageQueue]] to the port message queue of value, if any,＼
</p>

		<ul>
			<li>
%値 の`~port~message~queue$は，（初期~時の）不能化~状態のまま変えない
◎
leaving value's port message queue in its initial disabled state, and,＼
</li>
			<li>
［
%所有者 が指定する`担当の~event-loop$は `閲覧文脈~event-loop$である
］場合、移動された`~task$に， %所有者 が指定する`担当の文書$を結付ける
◎
if value's owner specifies a responsible event loop that is a browsing context event loop, associating the moved tasks with the responsible document specified by value's owner.
</li>
		</ul>
	</li>
	<li>
~IF［
%~data保持体 . `RemotePort^sl ~NEQ ~NULL
］
⇒
`~portを連絡する$( %~data保持体 . `RemotePort^sl, %値 )
⇒
（これは、元の転送された~portと %~data保持体 . `RemotePort^sl との連絡を解くことになる。）
◎
If dataHolder.[[RemotePort]] is not null, then entangle dataHolder.[[RemotePort]] and value. (This will disentangle dataHolder.[[RemotePort]] from the original port that was transferred.)
</li>
</ol>

<hr>

<dl class="idl-def">
	<dt>``postMessage( message, transfer )@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The postMessage(message, transfer) method, when invoked on a MessagePort object, must run the following steps:
</p>

<ol>
	<li>
%宛先~port ~LET  此れに連絡されている~portが［
あれば それ ／
なければ ~NULL
］
◎
Let targetPort be the port with which this MessagePort is entangled, if any; otherwise let it be null.
</li>
			<li>
<p>
~IF［
%transfer 内に此れがある†
］
⇒
~THROW `DataCloneError$E
◎
If any of the objects in transfer are this MessagePort, then throw a "DataCloneError" DOMException and abort these steps.
</p>
<p class="trans-note">【†
“内にある” が、 “配列~内に直接的に含まれている” ことを意味するのか，深く入子にされて含まれている場合も含めるのか、はっきりしない。
】</p>
			</li>
			<li>
%破棄予定 ~LET ~F
◎
Let doomed be false.
</li>
			<li>
<p>
~IF［
%宛先~port ~NEQ ~NULL
］~AND［
%transfer 内に %宛先~port はある
］：
</p>

<ol><li>
%破棄予定 ~SET ~T
</li><li>任意選択で
⇒
%宛先~port が自身に向けて投函された結果，通信~channelは失われることを、~UAの開発者~consoleに報告する
</li></ol>

◎
If targetPort is not null and any of the objects in transfer are targetPort, then set doomed to true, and optionally report to a developer console that the target port was posted to itself, causing the communication channel to be lost.
</li>
			<li>
%転送-を伴う直列化-結果 ~LET `StructuredSerializeWithTransfer$jA( %message, %transfer )
（例外投出あり）
◎
Let serializeWithTransferResult be StructuredSerializeWithTransfer(message, transfer). Rethrow any exceptions.
</li>
			<li>
~IF［
%宛先~port ~EQ ~NULL
］~OR［
%破棄予定 ~EQ ~T
］
⇒
~RET
◎
If there is no targetPort (i.e. if this MessagePort is not entangled), or if doomed is true, then abort these steps.
</li>
			<li>
<p>
次の手続きを走らす`~task$を
%宛先~port の`~port~message~queue$に追加する：
◎
Add a task that runs the following steps to the port message queue of targetPort:
</p>
				<ol>
					<li>
<p>
%最終~宛先~port ~LET この~taskが見出される`~port~message~queue$を持つ `MessagePort$I ~obj
◎
Let finalTargetPort be the MessagePort in whose port message queue the task now finds itself.
</p>
<p class="note">
これは %宛先~port と異なり得る
— %宛先~port 自身が転送されるに伴い，その~taskすべても移動された場合には。
◎
This can be different from targetPort, if targetPort itself was transferred and thus all its tasks moved along with it.
</p>
					</li>
					<li>
%宛先~Realm ~LET %最終~宛先~port に`関連する~Realm$
◎
Let targetRealm be finalTargetPort's relevant Realm.
</li>
					<li>
<p>
%逆直列化-~record ~LET `StructuredDeserializeWithTransfer$jA( %転送-を伴う直列化-結果, %宛先~Realm )
◎
Let deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, targetRealm).
</p>

<p>
ここで例外が投出されたときは、~catchして：
◎
If this throws an exception, catch it,＼
</p>
						<ol>
							<li>
%最終~宛先~port に向けて，次のように初期化された`~eventを発火する$
⇒＃
名前 `messageerror$et,
`MessageEvent$I を利用する
◎
fire an event named messageerror at finalTargetPort, using MessageEvent, and then＼
</li>
							<li>
~RET
◎
abort these steps. 
</li>
						</ol>
					</li>
					<li>
%~message~clone ~LET %逆直列化-~record . `Deserialized^sl
◎
Let messageClone be deserializeRecord.[[Deserialized]].
</li>
					<li>
%新~port~list ~LET
%逆直列化-~record . `TransferredValues^sl 内の すべての `MessagePort$I ~objからなる，同順の新たな`凍結~配列$
◎
Let newPorts be a new frozen array consisting of all MessagePort objects in deserializeRecord.[[TransferredValues]], if any, maintaining their relative order.
</li>
					<li>
%最終~宛先~port に向けて，次のように初期化された`~eventを発火する$
⇒＃
名前 `message$et,
`MessageEvent$I を利用する,
`data$m 属性 ~SET  %~message~clone,
`ports$m 属性 ~SET %新~port~list
◎
Fire an event named message at finalTargetPort, using MessageEvent, with the data attribute initialized to messageClone and the ports attribute initialized to newPorts.
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt>``start()@m</dt>
	<dd>
被呼出時には、まだ可能化されていなければ，此れの`~port~message~queue$を可能化し~MUST。
◎
The start() method must enable its port's port message queue, if it is not already enabled.
</dd>

	<dt>``close()@m</dt>
	<dd>
被呼出時には、此れに別~portが連絡されていれば，それを解か~MUST。
◎
The close() method, when called on a port local port that is entangled with another port, must cause the user agent to disentangle the two ports. If the method is called on a port that is not entangled, then the method must do nothing.
</dd>
</dl>


<hr>

<p>
`MessagePort$I ~interfaceを実装している~すべての~objは、以下に挙げる`~event~handler$, および対応する`~event~handler~event型$を，`~event~handler~IDL属性$として~supportし~MUST：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the MessagePort interface:
</p>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>``onmessage@m
<td>`message$et

<tr><td>``onmessageerror@m
<td>`messageerror$et

</tbody></table>

<p>
%P の`~port~message~queue$は、
`MessagePort$I ~obj %P の ``onmessage$m ~IDL属性が初回に設定された時点で，
%P の ``start()$m ~methodが~callされたかのように可能化され~MUST。
◎
The first time a MessagePort object's onmessage IDL attribute is set, the port's port message queue must be enabled, as if the start() method had been called.
</p>


			</section>
			<section id="broadcasting-to-many-ports">
<h3 title="Broadcasting to many ports">9.5.4. 多数の~portへの~broadcast法</h3>

~INFORMATIVE

<p>
多数の~portへ~broadcastすることは、原則的には，比較的~単純であり、~messageを送信-用の `MessagePort$I ~objからなる配列を保っておいて，配列~内を反復して, ~messageを送信すればよい。
しかしながら、相手~側が消去っても それらの~portを~garbage収集できなくなるという，困った効果もある。
この問題を避けるには、相手~側から自身の存在を認知させるような，単純な~protocolを実装するとよい
— 一定時間そうしなかったなら，消去ったと見做して、 `MessagePort$I ~objを~closeすることにより，~garbage収集に任せるような。
◎
Broadcasting to many ports is in principle relatively simple: keep an array of MessagePort objects to send messages to, and iterate through the array to send a message. However, this has one rather unfortunate effect: it prevents the ports from being garbage collected, even if the other side has gone away. To avoid this problem, implement a simple protocol whereby the other side acknowledges it still exists. If it doesn't do so after a certain amount of time, assume it's gone, close the MessagePort object, and let it be garbage collected.
</p>


			</section>
			<section id="ports-and-garbage-collection">
<h3 title="Ports and garbage collection">9.5.5. ~portと~garbage収集</h3>

<div class="p">
<p>
`MessagePort$I ~obj %O が連絡されたときは、~UAは，次のいずれかから %O への強い参照-があるかのように動作し~MUST：
</p>

<ul><li>%O に連絡されている `MessagePort$I ~obj
</li><li>%O の`所有者$が指定する`大域~obj$enV
</li></ul>
◎
When a MessagePort object o is entangled, user agents must either act as if o's entangled MessagePort object has a strong reference to o, or as if the global object specified by o's owner has a strong reference to o.
</div>

<div class="note">

<p>注記：
したがって，~message~portは、受信して~event~listenerをあてがった後は，放置しておくこともできる
— その~event~listenerが~messageを受信できる限り，~channelは保守される。
◎
Thus, a message port can be received, given an event listener, and then forgotten, and so long as that event listener could receive a message, the channel will be maintained.
</p>

<p>
無論，これが当の~channelの両~側に生じた場合、両~portとも~garbage収集され得る
— それらは、互いに強い参照-があるとしても，生きた~codeからは到達できなくなるので。
◎
Of course, if this was to occur on both sides of the channel, then both ports could be garbage collected, since they would not be reachable from live code, despite having a strong reference to each other.
</p>

</div>

<p>
更には， `MessagePort$I ~obj %O は、次のいずれかが満たされている間は，~garbage収集されては~MUST_NOT：
◎
Furthermore, a MessagePort object must not be garbage collected＼
</p> 

<ul>
	<li>
ある`~task~queue$内の ある`~task$が、 %O に向けて配送される~eventを参照している
◎
while there exists an event referenced by a task in a task queue that is to be dispatched on that MessagePort object, or＼
</li>
	<li>
%O の`~port~message~queue$は、空でない, かつ 可能化されている
◎
while the MessagePort object's port message queue is enabled and not empty.
</li>
</ul>

<p class="note">注記：
作者には、 `MessagePort$I ~objを明示的に~closeして，それらの連絡を解くことが強く奨励される
— そうすれば、それらの資源は再収集できるようになる。
多数の `MessagePort$I ~objを作成して，それらを~closeすることなく破棄することは、一時的に多量の~memoryを~~消費させ得る
— ~garbage収集は、とりわけ， `MessagePort$I に対する~garbage収集に~cross-processの協調も孕まれ得る所では、即座に遂行されるとは限らないので。
◎
Authors are strongly encouraged to explicitly close MessagePort objects to disentangle them, so that their resources can be recollected. Creating many MessagePort objects and discarding them without closing them can lead to high transient memory usage since garbage collection is not necessarily performed promptly, especially for MessagePorts where garbage collection can involve cross-process coordination.
</p>


			</section>
		</section>
		<section id="broadcasting-to-other-browsing-contexts">
<h2 title="Broadcasting to other browsing contexts">9.6. 他の閲覧文脈への~broadcast法</h2>

<!-- ``BroadcastChannel^I -->

<p>
ときには、［
同じ~UA内で同じ利用者により~openされているが，互いに関係しない異なる`閲覧文脈$内にある
］ような，同じ`生成元$に属する複数の頁どうしが、互いに通知を送信しあう必要が生じることもある。
例えば、
“利用者がこっちに~log-inしたから、そっちでも資格証を再度~検査してくれ”
。
◎
Pages on a single origin opened by the same user in the same user agent but in different unrelated browsing contexts sometimes need to send notifications to each other, for example "hey, the user logged in over here, check your credentials again".
</p>

<p>
もっと手の込んだ事例においては、`共用~worker$が最も適切な解決策になる
— 例えば：
共有されている状態の~lockingを管理する ／
~serverと複数の局所~clientとの間で 資源の同期を管理する ／
`WebSocket$I 接続を~remote~hostと共有する，等々。
◎
For elaborate cases, e.g. to manage locking of shared state, to manage synchronization of resources between a server and multiple local clients, to share a WebSocket connection with a remote host, and so forth, shared workers are the most appropriate solution.
</p>

<p>
共用~workerでは大げさにすぎるような単純な事例では、作者は，この節に述べる 単純な~channelに基づく~broadcastの仕組みを利用できる。
◎
For simple cases, though, where a shared worker would be an unreasonable overhead, authors can use the simple channel-based broadcast mechanism described in this section.
</p>

<pre class="idl">
[``Constructor$m(DOMString %name), Exposed=(Window,Worker)]
interface `BroadcastChannel@I : `EventTarget$I {
  readonly attribute DOMString ``name$m;
  void ``postMessage$m(any %message);
  void ``close$m();
  attribute `EventHandler$I ``onmessage$m;
  attribute `EventHandler$I ``onmessageerror$m;
};
</pre>

<dl class="domintro">

	<dt>%broadcastChannel = new `BroadcastChannel(name)$m</dt>
	<dd>
~channel名 %name の~channelを介して~messageを［
送信できる／受信できる
］ような，新たな `BroadcastChannel$I ~objを返す。
◎
Returns a new BroadcastChannel object via which messages for the given channel name can be sent and received.
</dd>

	<dt>%broadcastChannel . ``name$m</dt>
	<dd>
（構築子に渡された）~channel名を返す。
◎
Returns the channel name (as passed to the constructor).
</dd>

	<dt>%broadcastChannel . ``postMessage( message )$m</dt>
	<dd>
所与の~messageを，この~channelに設定しておかれた 他の `BroadcastChannel$I ~objへ送信する。
~messageは、入子の~objや配列など，有構造~dataも可能である。
◎
Sends the given message to other BroadcastChannel objects set up for this channel. Messages can be structured objects, e.g. nested objects and arrays.
</dd>

	<dt>%broadcastChannel . ``close()$m</dt>
	<dd>
`BroadcastChannel$I ~objを~closeして，~garbage収集に委ねる。
◎
Closes the BroadcastChannel object, opening it up to garbage collection.
</dd>
</dl>

<div class="p">
<p>
`BroadcastChannel$I ~objは、次のものを持つ：
</p>

<dl class="def-list">
	<dt>`~channel名@</dt>
	<dd>
共有する通信~channelを識別する文字列。
</dd>

	<dt>`~BroadcastChannel設定群~obj@</dt>
	<dd>
`環境~設定群~obj$。
</dd>

	<dt>`~close済み~flag@</dt>
	<dd>
~ON ならば、通信は~closeされたことを指示する。
</dd>
</dl>

◎
A BroadcastChannel object has a channel name, a BroadcastChannel settings object, and a closed flag.
</div>


<dl class="idl-def">
	<dt>`BroadcastChannel( name )@m</dt>
	<dd>
この構築子の被呼出時には、次のように設定された新たな
`BroadcastChannel$I ~objを返さ~MUST
⇒＃
`~channel名$ ~SET %name,
`~BroadcastChannel設定群~obj$ ~SET `現任の設定群~obj$,
`~close済み~flag$ ~SET ~OFF
◎
The BroadcastChannel() constructor, when invoked, must create and return a BroadcastChannel object whose channel name is the constructor's first argument, whose BroadcastChannel settings object is the incumbent settings object, and whose closed flag is false.
</dd>

	<dt>``name@m</dt>
	<dd>
取得子は、此れの`~channel名$を返さ~MUST。
◎
The name attribute must return the channel name.
</dd>

	<dt>``postMessage( message )@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The postMessage(message) method, when invoked on a BroadcastChannel object, must run the following steps:
</p>

		<ol>
			<li>
%~source設定群 ~LET 
此れの`~BroadcastChannel設定群~obj$
◎
Let source be this BroadcastChannel.
◎
Let sourceSettings be source's BroadcastChannel settings object.
</li>
			<li>
~IF［
此れの`~close済み~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidStateError$E
◎
If source's closed flag is true, then throw an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
%~source~channel ~LET 此れの`~channel名$
◎
Let sourceChannel be source's channel name.
</li>
			<li>
%宛先~Realm ~LET ~UAにより定義される~Realm
◎
Let targetRealm be a user-agent defined Realm.
</li>
			<li>
%直列形 ~LET  `StructuredSerialize$jA( %~message, %宛先~Realm )
（例外投出あり）
◎
Let serialized be StructuredSerialize(message). Rethrow any exceptions.
</li>
			<li>
<p>
%行先~list ~LET 次をすべて満たす `BroadcastChannel$I ~obj %O すべてからなる~list：
◎
Let destinations be a list of BroadcastChannel objects that match the following criteria:
</p>

				<ul>
					<li>
<p>
%O の`~BroadcastChannel設定群~obj$を %設定群, 
%設定群 が指定する`大域~obj$enV を %G とするとき：
◎
Their BroadcastChannel settings object specifies either:
</p>
						<ul>
							<li>
<p>
次のいずれかが満たされる：
</p>
								 <ul>
									 <li>
［
%G は `Window$I ~objである
］~AND［
%設定群 の`担当の文書$は`全部的に作動中$である
］
◎
a global object that is a Window object and a responsible document that is fully active, or
</li>
			<li>
［
%G は `WorkerGlobalScope$I ~objである
］~AND［
%G の `~closing~flag$ ~EQ ~F
］~AND［
%G の`~worker$は`休止可能$でない
］
◎
a global object that is a WorkerGlobalScope object whose closing flag is false and whose worker is not a suspendable worker.
</li>
								</ul>
							</li>
							<li>
( %設定群 の`生成元$enV, %~source設定群 の`生成元$enV )
は`同一生成元$である
◎
Their BroadcastChannel settings object's origin is same origin with sourceSettings's origin.
</li>
						</ul>
					<li>
%O の`~channel名$ ~EQ %~source~channel
◎
Their channel name is a case-sensitive match for sourceChannel.
</li>
					<li>
%O の`~close済み~flag$ ~EQ ~OFF
◎
Their closed flag is false.
</li>
				</ul>
			</li>
			<li>
%行先~list から此れを除去する
◎
Remove source from destinations.
</li>
			<li>
%行先~list を，次が満たされるように~sortする
⇒
%行先~list 内の `BroadcastChannel$I ~objのうち，［
その`~BroadcastChannel設定群~obj$が同じ`担当の~event-loop$を指定するもの
］どうしは、古いものから，作成した順に並ぶ
（これは、完全な順序付けは定義しない。~UAは、この拘束の下で，自身が定義する方式で更に~sortしてよい。）
◎
Sort destinations such that all BroadcastChannel objects whose BroadcastChannel settings objects specify the same responsible event loop are sorted in creation order, oldest first. (This does not define a complete ordering. Within this constraint, user agents may sort the list in any user-agent defined manner.)
</li>
			<li>
<p>
%行先~list 内の ~EACH( `BroadcastChannel$I ~obj %行先 ) に対し
⇒
次の手続きを走らす`~taskを~queueする$：
◎
For each BroadcastChannel object destination in destinations, queue a task that runs the following steps:
</p>
				<ol>
					<li>
%宛先~Realm ~LET %行先 に`関連する~Realm$
◎
Let targetRealm be destination's relevant Realm.
</li>
					<li>
%生成元 ~LET `生成元を直列化する$( %~source設定群 の`生成元$enV )
◎
↓</li>
					<li>
<p>
%~data ~LET `StructuredDeserialize$jA( %直列形, %宛先~Realm )
◎
Let data be StructuredDeserialize(serialized, targetRealm).
</p>

<p>
ここで例外が投出されたときは、~catchして：
◎
If this throws an exception, catch it,＼
</p>
						<ol>
							<li>
%行先 に向けて，次のように初期化された`~eventを発火する$
⇒＃
名前 `messageerror$et,
`MessageEvent$I を利用する,
`origin$m 属性 ~SET %生成元
◎
fire an event named messageerror at destination, using MessageEvent, with the origin attribute initialized to the serialization of sourceSettings's origin, and then＼
</li>
							<li>
~RET
◎
abort these steps.
</li>
						</ol>
					</li>
					<li>
%行先 に向けて，次のように初期化された`~eventを発火する$
⇒＃
名前 `message$et,
`MessageEvent$I を利用する,
`data$m 属性 ~SET %~data,
`origin$m 属性 ~SET %生成元
◎
Fire an event named message at destination, using MessageEvent, with the data attribute initialized to data and the origin attribute initialized to the serialization of sourceSettings's origin.
</li>
				</ol>

<div class="p">
<p>
この段の`~task$に対しては、次が要求される：
</p>

<ul><li>`~DOM操作~task源$を利用する
</li><li>%行先 の`~BroadcastChannel設定群~obj$ %O が指定する`~event-loop$が`閲覧文脈~event-loop$である場合、~taskに結付けられる文書は， %O が指定する`担当の文書$とする
</li></ul>

◎
The tasks must use the DOM manipulation task source, and, for those where the event loop specified by the target BroadcastChannel object's BroadcastChannel settings object is a browsing context event loop, must be associated with the responsible document specified by that target BroadcastChannel object's BroadcastChannel settings object.
</div>
			</li>
		</ol>
	</dd>
</dl>


<div class="p">
<p>
`BroadcastChannel$I ~obj %O に対しては、次がいずれも満たされている間は，［
%O の`~BroadcastChannel設定群~obj$が指定する`大域~obj$enV
］から %O への強い参照-が~MUST：
</p>

<ul><li>%O の`~close済み~flag$ ~EQ ~OFF
</li><li>%O 向けの `message$et ~eventに対し登録されている~event~listenerがある
</li></ul>

◎
While a BroadcastChannel object whose closed flag is false has an event listener registered for message events, there must be a strong reference from global object specified by the BroadcastChannel object's BroadcastChannel settings object to the BroadcastChannel object itself.
</div>

<dl class="idl-def">
	<dt>``close()@m</dt>
	<dd>
被呼出時には、［
此れの`~close済み~flag$ ~SET ~ON
］にし~MUST
◎
The close() method must set the closed flag of the BroadcastChannel object on which it was invoked to true.
</dd>
</dl>

<p class="note">注記：
作者には、 `BroadcastChannel$I ~objが不要になり次第，~UAが~garbage収集できるように
明示的に~closeすることが強く奨励される。
多数の `BroadcastChannel$I ~objを作成して，~event~listenerを伴わせたまま ~closeすることなく破棄した場合、目に見える~memory漏洩-をもたらす
— それらの~objは、~event~listenerがある限り（または、それらが属する［
頁／~worker
］が~closeされるまで），生き残り続けようとするので。
◎
Authors are strongly encouraged to explicitly close BroadcastChannel objects when they are no longer needed, so that they can be garbage collected. Creating many BroadcastChannel objects and discarding them while leaving them with an event listener and without closing them can lead to an apparent memory leak, since the objects will continue to live for as long as they have an event listener (or until their page or worker is closed).
</p>

<hr>

<p>
`BroadcastChannel$I ~interfaceを実装している~すべての~objは、以下に挙げる`~event~handler$, および対応する`~event~handler~event型$を，`~event~handler~IDL属性$として~supportし~MUST：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the BroadcastChannel interface:
</p>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>``onmessage@m
<td>`message$et

<tr><td>``onmessageerror@m
<td>`messageerror$et

</tbody></table>



<div class="example">
<p>
ある頁が利用者が，いつ~log-outしたか知りたいと求めているとする
— 同じ~siteに属する別の~tabの頁から利用者がそうしたときでも：
◎
Suppose a page wants to know when the user logs out, even when the user does so from another tab at the same site:
</p>

<pre class="js-code">
var %authChannel = new BroadcastChannel('auth');
%authChannel.onmessage = function (%event) {
  if (%event.data == 'logout')
    showLogout();
}

function logoutRequested() {
  /* <span class="comment">
利用者から~log-outを請われたとき，~callされる
◎
called when the user asks us to log them out
</span> */
  doLogout();
  showLogout();
  %authChannel.postMessage('logout');
}

function doLogout() {
  /* <span class="comment">
利用者は実際に~log-outした（例： ~cookieを~clearするなど）
◎
actually log the user out (e.g. clearing cookies)
</span> */
  // ...
}

function showLogout() {
  /* <span class="comment">
~log-outしたことを指示するように，~UIを更新する
◎
update the UI to indicate we're logged out
</span> */
  // ...
}
</pre>

  </div>


		</section>
	</section>

</main>
