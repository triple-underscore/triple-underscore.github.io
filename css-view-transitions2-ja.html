<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8">
<title>CSS View Transitions Module Level 2（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">
<style>

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't': // typedef
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'at': //
	text = `@${key}`;
	break;
case 'p': // property
	break;
case 'ps': // pseudo-class
	text = `:${key}`;
	break;
case 'pe': // pseudo-element
	text = `::${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm': // IDL member
	let n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}"></a>`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:CSS View Transitions Module Level 1
spec_date:2024-02-02
trans_update:2024-02-02
source_checked:231219
page_state_key:CSS
original_url:https://drafts.csswg.org/css-view-transitions-2/
	abbr_url:CSSVT2
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-anim,css
conformance:css
copyright:2024,permissive
trans_1st_pub:2023-12-21

●●class_map
p:property
d:descriptor
ps:pseudo
pe:pseudo
t:type
css:css
at:at-rule
f:func
v:value
et:event-type
e:element
E:error
jv:js-value

●●tag_map
p:code
pe:code
ps:code
t:var
at:code
css:code
f:code
d:code
et:code
e:code
I:code
m:code
mb:code
E:code
v:code
jv:code
c:code
V:var
em:em
i:i
cite:cite

●●original_id_map

●●mdn_urls

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
sequence:~WEBIDL#idl-sequence
DOMString:~WEBIDL#idl-DOMString
unsigned short:~WEBIDL#idl-unsigned-short
E.TimeoutError:~WEBIDL#timeouterror
E.AbortError:~WEBIDL#aborterror
I.CSSRule:~CSSOM1#cssrule
I.DOMException:~WEBIDL#idl-DOMException
I.Document:~DOM4#document
	I.Document → 文書

I.DOMTokenList:~DOM4#domtokenlist
I.ViewTransitionNavigation:#enumdef-viewtransitionnavigation
I.CSSViewTransitionRule:#cssviewtransitionrule
I.StartViewTransitionOptions:#dictdef-startviewtransitionoptions
I.NavigationType:~HTMLnavAPI#navigationtype
I.UpdateCallback:~CSSVT#callbackdef-updatecallback
I.ViewTransition:~CSSVT#viewtransition
I.PageRevealEvent:~WINDOW#pagerevealevent
	I.PageRevealEvent:#pagerevealevent
	reveal:#pagerevealevent

	%callbackOptions:#dom-document-startviewtransition-callbackoptions-callbackoptions
m.startViewTransition:#dom-document-startviewtransition
	＠~CSSVT#dom-document-startviewtransition
m.VIEW_TRANSITION_RULE:#dom-cssrule-view_transition_rule
m.navigation:#dom-cssviewtransitionrule-navigation
m.type:#dom-cssviewtransitionrule-type
m.sessionStorage:~WEBSTORAGE#dom-sessionstorage
m.updateCallbackDone:~CSSVT#dom-viewtransition-updatecallbackdone
m.requestAnimationFrame:~HTMLGAPI#dom-animationframeprovider-requestanimationframe
mb.update:#dom-startviewtransitionoptions-update
mb.type:#dom-startviewtransitionoptions-type
m.viewTransition:~WINDOW#dom-pagerevealevent-viewtransition

l.auto:#dom-viewtransitionnavigation-auto
l.none:#dom-viewtransitionnavigation-none
l.reload:~HTMLnavAPI#dom-navigationtype-reload
l.traverse:~HTMLnavAPI#dom-navigationtype-traverse
l.push:~HTMLnavAPI#dom-navigationtype-push
l.replace:~HTMLnavAPI#dom-navigationtype-replace


	●CSS/code

p.view-transition-name:~CSSVT#propdef-view-transition-name
p.view-transition-class:#propdef-view-transition-class

et.pagereveal:~HTMLindex#event-pagereveal

t.vt-type-selector:#typedef-vt-type-selector
t.pt-class-selector:#typedef-pt-class-selector
t.pt-name-selector:~CSSVT#typedef-pt-name-selector
t.custom-ident:~CSSVAL#identifier-value
t.declaration-rule-list:~CSSSYN#typedef-declaration-rule-list

v.auto:#valdef-view-transition-navigation-auto
v.none:#valdef-view-transition-navigation-none

v.~noneC:#valdef-view-transition-class-none
	t.custom-ident:#valdef-view-transition-class-custom-ident

at.media:~CSSCOND#at-ruledef-media
at.supports:~CSSCOND#at-ruledef-supports
at.view-transition:#at-view-transition-rule
d.navigation:#descdef-view-transition-navigation
	d.navigation:#view-transition-navigation
d.type:#descdef-view-transition-type
	d.type:#view-transition-type

ps.active-view-transition():#active-view-transition-pseudo
	ps.active-view-transition(&lt;vt-type-selector&gt;):#active-view-transition-pseudo
pe.view-transition-group():~CSSVT#selectordef-view-transition-group
pe.view-transition-image-pair():~CSSVT#selectordef-view-transition-image-pair
pe.view-transition-old():~CSSVT#selectordef-view-transition-old
pe.view-transition-new():~CSSVT#selectordef-view-transition-new


	●用語
非同一-文書な~view遷移を解決する:#resolve-cross-document-view-transition
~view遷移~規則を解決する:#resolve-view-transition-rule
非同一-文書な~view遷移を設定しておく:#setup-cross-document-view-transition
~naviは非同一-文書な~view遷移を誘発し得るか？:#navigation-can-trigger-a-cross-document-view-transition
vT.作動中な型~群:#viewtransition-active-types
vT.内へ来る非同一-文書な遷移か:#viewtransition-is-inbound-cross-document-transition
cE.~class~list:#captured-element-class-list

	●用語（level 1
~level 1:#biblio-css-view-transitions-1
要素:~CSSVT#_element
	要素:~CSSDISP#elements
	要素:~CSS2J#element
~view遷移を~clearする:~CSSVT#clear-view-transition
~view遷移を作動化する:~CSSVT#activate-view-transition
doc.作動中な~view遷移:~CSSVT#document-active-view-transition
doc.~view遷移を自動で飛ばすか:~CSSVT#document-auto-skip-view-transitions
捕捉された要素:~CSSVT#captured-element
有名~view遷移~疑似要素:~CSSVT#named-view-transition-pseudo-elements
~view遷移:~CSSVT#view-transitions
~view遷移~名:~CSSVT#view-transition-name
旧-状態を捕捉する:~CSSVT#capture-the-old-state
新-状態を捕捉する:~CSSVT#capture-the-new-state

vT.初期~snapshot包含塊~size:~CSSVT#viewtransition-initial-snapshot-containing-block-size
vT.有名~要素~群:~CSSVT#viewtransition-named-elements
処理待ち遷移~演算を遂行する:~CSSVT#perform-pending-transition-operations
vT.相:~CSSVT#viewtransition-phase
vT.旧-状態~捕捉-時の処理n:~CSSVT#viewtransition-process-old-state-captured
vT.更新~callback済み時の~promise:~CSSVT#viewtransition-update-callback-done-promise
~view遷移を設定しておく:~CSSVT#setup-view-transition
~view遷移を飛ばす:~CSSVT#skip-the-view-transition

i.捕捉-待ち:~CSSVT#_pending-capture
i.済み:~CSSVT#_done
i.更新~callbackは~call済み:~CSSVT#_update-callback-called

	●用語（CSS

算出d値:~CASCADE#computed-value
詳細度:~SELECTORS4#specificity
選択子:~SELECTORS4#selector
全称~選択子:~SELECTORS4#universal-selector
~class選択子:~SELECTORS4#class-selector
	https://drafts.csswg.org/selectors-3/#x
条件付き~group規則:~CSSCOND#conditional-group-rule

	●用語（他
~list:~INFRA#list
実装定義:~INFRA#implementation-defined
	~IN:~INFRA#list-contain

~method手続き:~WEBIDL#method-steps
新たな~obj:~WEBIDLjs#new
~promiseを解決する:~WEBIDLjs#resolve

文書:~DOM4#concept-document
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element
	doc.生成元:~DOM4#concept-document-origin → 生成元
生成元:~ORIGIN#concept-origin

並列的:~HTMLINFRA#in-parallel

doc.非同一-生成元~redirectを介して作成されたか:~HTMLdom#was-created-via-cross-origin-redirects

同一-生成元:~ORIGIN#same-origin
	browsers.html
~navigable:~HTMLds#navigable
nav.作動中な~window:~HTMLds#nav-window
履歴~stepを適用する:~HTMLnav#apply-the-history-step
~navigableを変更している継続の状態:~HTMLnav#changing-navigable-continuation-state
cnC.更新のみか:~HTMLnav#changing-nav-continuation-update-only
~BF~cache:~HTMLnav#_bf-cache
作動化し直され:~HTMLnav#reactivate-a-document
露呈され:~HTMLnav#reveal
~naviに対する利用者-関与i:~HTMLnav#user-navigation-involvement
i.~browser~UI:~HTMLnav#uni-browser-ui
~unloadされ:~HTMLlifecycle#unload-a-document

結付けられた文書:~WINDOW#concept-document-window

描画~機会:~WAPI#rendering-opportunity
大域~taskを~queueする:~WAPI#queue-a-global-task
関連な大域~obj:~WAPI#concept-relevant-global
関連な~realm:~WAPI#concept-relevant-realm
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability

●●words_table1
BQん:`
noneC:none
●●words_table

	●遷移／animation
新-:new:~
旧-:old:~
相:phase::~::フェーズ
捕捉-:capture::~
捕捉:capture::~
滑らか:smooth:~
cross-fade::::クロスフェード
	~cross-fade:crossfade
unload:
	~view遷移:view-transition
	内へ来る:inbound
	外へ出る:outbound

	●UI／呈示
明滅:flash:~
露呈-:reveal:露わに
bookmark::::ブックマーク
	~URL~bar:URL address bar

	●CSS
CSSOM:
For:for:用途
詳細度:specificity::~
全称:universal:~

	●処理
lifecycle:
時間切れ:timeout::~
続行-:proceed:~
処理待ち:pending:~
為され:makeされ:~

	直前:right before
	直前に:currently
	いつでも:At any given time
	順に経る:goes through
	経る:has
	以降:From this point forward
	渡した／渡す:pass

	%解決-済み規則:resolvedRule
	%~view遷移:viewTransition
	%外へ出る遷移:outboundTransition
	%内へ来る遷移:inboundTransition
	%準備済み時の手続き:onReady
	%~navigableを変更している継続:changingNavigationContinuation
	ときが来た:it’s time to
	優先される:take precedent
	再-作動化:reactivation
	-:accepting
	設定-法:setting up
	%~navi種別:navigationType
	%~browser~UIによる~naviか:isBrowserUINavigation
	%~naviに対する利用者-関与i:~userInvolvementForNavigateEvents
	%旧-文書:oldDocument
	%新-文書:newDocument
	%旧-生成元:oldOrigin
	%新-生成元:newOrigin
	%~naviは非同一-生成元な~redirectを経たか:navigationHasCrossOriginRedirects

	●保安
脅威:threat:~
潜在的:potential:~
提起-:raise:~
安全性:safety:~
軽微:minor:~

	第三者-主体:3rd-party
	生じさせ:causing
	その場を占めて:taken place
	事実:fact
	ぼやかす:obfuscate
	これまで:so far

	●仕様
opt-in:
monkey:
patch::::パッチ
	~monkey~patch:monkey-patch
保つ:keepする:~
併合-:merge:~

	意図されない:unintended
	現時点では:at this point
	まずは:to begin with
	関わる:around
	^en:learn
	おかげで:thank
	書かれ:written
	熟した:graduate

	●言い換え
	`文書$:Document
	文書:Document
	~BF~cache:BFCache
	互いの~page間の~link:link from page 1 to or from page 2
	`遷移を飛ばす^i:`skip transition^l
	手続き %手続き に代えて，次を遂行する:Prepend a step at the beginning of
	^e:iframe
	`~view遷移^cite:View Transitions
	~level 1$:previously
	~level 1$:L1

	●未分類
step:
側:side:~
	側:-side
BF:
横取-:intercept:横取り
複写-:replicate:~

	残りの:remaining
	ある種の:certain
	より多く:more
	~~設置-:put
	来る:come
	~~地点:location
	後戻りする:back
	以外:apart from

●●ref_key_map

●●ref_normative

[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-VIEW-TRANSITIONS-1]
    Tab Atkins Jr.; Jake Archibald; Khushal Sagar. ＜CSS View Transitions Module Level 1＞. URL: https://drafts.csswg.org/css-view-transitions-1/
[CSS22]
    Bert Bos. ＜Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-3]
    Tantek Çelik; et al. ＜Selectors Level 3＞. URL: https://drafts.csswg.org/selectors-3/
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-CONDITIONAL-3]
    David Baron; Elika Etemad; Chris Lilley. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより勧告候補として公開された
<a href="~SPEC_URL">CSS View Transitions Module Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-view-transitions-2/
公表履歴
	https://www.w3.org/standards/history/css-view-transitions-2/
フィードバック
	https://github.com/w3c/csswg-drafts/labels/css-view-transitions-2
編集
	Noam Rosenthal (Google)
	Khushal Sagar (Google)
	Vladimir Levin (Google)
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-view-transitions-2/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-view-transitions-2
</script>

</head>
<body>

<header>
	<hgroup>
<h1>CSS ビュー遷移 — CSS View Transitions Module Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この~moduleは、
`~view遷移^cite ~APIが非同一-文書な~naviと伴にどう働くかを定義する。
◎
This module defines how the View Transition API works with cross-document navigations.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
この節では、
公表~時点における…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
`~view遷移^cite は、
`~level 1$ にて指定されるとおり，
`文書$の視覚的な状態どうしで~animateされた遷移を作成することを開発者に許容する特能である。
◎
View Transitions, as specified in [css-view-transitions-1], is a feature that allows developers to create animated transitions between visual states of the document.
</p>

<p>
この~level 2 は、［
同一-生成元な非同一-文書な~naviにまたがる遷移を可能化するために必要yな~APIと~lifecycle
］を追加することにより，
`~level 1$ を拡張する。
◎
Level 2 extends that specification, by adding the necessary API and lifecycle to enable transitions across a same-origin cross-document navigation.
</p>

		<section id="lifecycle">
<h3 title="Lifecycle">1.1. ~lifecycle</h3>

◎非規範的

<p>
成功裡な［
非同一-文書な~view遷移
］は、
次に挙げる相を順に経る：
◎
A successful cross-document view transition goes through the following phases:
</p>
<ol>
	<li>
利用者は、［
~linkを~clickする／
~formを提出する／
~browser~UI等を利用して履歴を辿る
］などにより，
【ある`文書$ %旧-文書 から ある`文書$ %新-文書 へ】
~navigateする。
◎
The user navigates, by clicking a link, submitting a form, traversing history using the browser UI, etc.
</li>
	<li>
%旧-文書 が`~unloadされ$るときが来たとき、［
当の~naviは`同一-生成元$であって， %旧-文書 が非同一-文書な~view遷移を~opt-inした場合
］には， “旧-” 状態【 %旧-文書 の状態】が捕捉される。
◎
Once it’s time to unload the old document, if the navigation is same origin and the old Document has opted in to cross-document view-transitions, the old state is captured.
</li>
	<li>
%新-文書 に向けて
`pagereveal$et ~eventが発火される
— その `viewTransition$m ~propとして，ある `ViewTransition$I ~objを伴う。
この~objの `updateCallbackDone$m は、
すでに解決-済みであり，この~objに`捕捉された要素$たちは “旧-” 状態から拡充される。
◎
An event named pagereveal is fired on the new Document, with a viewTransition property, which is a ViewTransition object. This ViewTransition's updateCallbackDone is already resolved, and its captured elements are populated from the old Document.
</li>
	<li>
%新-文書 が最初に`描画~機会$を経る直前に，
その状態が “新-” 状態として捕捉される。
◎
Right before the new Document has the first rendering opportunity, its state is captured as the "new" state.
</li>
	<li>
以降、
`~view遷移を作動化する$手続きに従って，
当の遷移を同一-文書な遷移であったかのように継続する。
◎
From this point forward, the transition continues as if it was a same-document transition, as per activate view transition.
</li>
</ol>

		</section>
		<section id="examples">
<h3 title="Examples">1.2. 例</h3>

			<section id="cross-doc-example">
<h4 title="Cross-document view-transitions">1.2.1. 非同一-文書な~view遷移</h4>

<div class="example">
<p>
`~level 1$ の `§ 例＠~CSSVT#examples$ における最初の例と同じ~cross-fadeを生成するが、
複数の文書にまたがる【 “非同一-文書である” 】
— ~JSは必要ない。
◎
To generate the same cross-fade as in the first example CSS View Transitions 1 § 1.6 Examples, but across documents, we don’t need JavaScript.
</p>

<p>
代わりに，~page 1, ~page 2 両者において
~naviに対し~view遷移を誘発することを~opt-inする：
◎
Instead, we opt in to triggering view-transitions on navigation in both page 1 and page 2:
</p>

<pre class="lang-css">
/* <span class="comment">
両~文書において：
◎
in both documents:
</span> */
@view-transition {
  navigation: auto;
}
</pre>

<p>
互いの~page間の~linkは、
例 1 による~cross-fade遷移を生成する。
例 2, 3, 4 による効果を達成するためには、
単純に両~文書~内に疑似要素~用の~CSSを~~設置する。
◎
A link from page 1 to or from page 2 would generate a crossfade transition for example 1. To achieve the effect examples 2, 3 &amp; 4, simply put the CSS for the pseudo-elements in both documents.
</p>
</div>

<div class="example">
<p>
`例 5＠~CSSVT#_example-5$
の効果を達成するためには、
次を行う必要がある：
◎
To achieve the effect in example 5, we have to do several things:
</p>
<ul>
	<li>
両~pageにおいて，~naviにより誘発される~view遷移を~opt-inする。
◎
Opt-in to navigation-triggered view-transitions in both pages.
</li>
	<li>
新-文書に~click~~地点を渡す
— 例： `sessionStorage$m を介して。
◎
Pass the click location to the new document, e.g. via sessionStorage.
</li>
	<li>
`pagereveal$et を利用して，
新-文書~内の `ViewTransition$I ~objを横取する。
◎
Intercept the ViewTransition object in the new document, using the pagereveal event.
</li>
</ul>

<p>
両~page内には次がある：
◎
In both pages:
</p>

<pre class="lang-css">
@view-transition {
  navigation: auto;
}
</pre>

<p>
旧-~page内には次がある：
◎
In the old page:
</p>

<pre class="lang-js">
addEventListener('click', %event =&gt; {
  sessionStorage.setItem("lastClickX", %event.clientX);
  sessionStorage.setItem("lastClickY", %event.clientY);
});
</pre>

<p>
新-~page内には次がある：
◎
In the new page:
</p>

<pre class="lang-js">
/* <span class="comment">
これは、
初期~読込nと再-作動化どちらに対しても，
`~BF~cache$から走らすことになろう。
◎
This would run both on initial load and on reactivation from BFCache.
</span> */
addEventListener("pagereveal", async %event =&gt; {
  if (!%event.viewTransition)
    return;

  const %x = sessionStorage.getItem("lastClickX") ?? window.innerWidth / 2;
  const %y = sessionStorage.getItem("lastClickY") ?? window.innerHeight / 2;

  const %endRadius = Math.hypot(
    Math.max(%x, window.innerWidth - %x),
    Math.max(%y, window.innerHeight - %y)
  );

  await event.viewTransition.ready;

  /* <span class="comment">
新-文書の~viewを~animateする
◎
Animate the new document's view
</span> */
  document.documentElement.animate(
    {
      clipPath: [
        ~BQんcircle(0 at ${%x}px ${%y}px)~BQん,
        ~BQんcircle(${%endRadius}px at ${%x}px ${%y}px)~BQん,
      ],
    },
    {
      duration: 500,
      easing: 'ease-in',
      pseudoElement: '::view-transition-new(%root)'
    }
  );
})
</pre>
</div>

			</section>
			<section id="vt-class-example">
<h4 title="view-transition-class">1.2.2. `view-transition-class^p</h4>

<p>
`view-transition-class$p は、
複数の~view遷移~疑似要素~用に，同じ~styleを利用する仕方を供する
— 対応する疑似要素【による~style】を複写する必要なく。
◎
view-transition-class provides a way to use the same style for multiple view transition pseudo elements without having to replicate the corresponding pseudo-elements.
</p>

<div class="example">
<p>
この例が作成する遷移では、
各~boxは，自前の名前の下で遷移に関与する一方で，
すべての~boxの~animationに所要時間 1 秒を適用する：
◎
This example creates a transition with each box participating under its own name, while applying a 1-second duration to the animation of all the boxes:
</p>

<pre class="lang-html">
&lt;div class="box" id="red-box"&gt;&lt;/div&gt;
&lt;div class="box" id="green-box"&gt;&lt;/div&gt;
&lt;div class="box" id="yellow-box"&gt;&lt;/div&gt;
</pre>

<pre class="lang-css">
div.box {
  view-transition-class: any-box;
  width: 100px;
  height: 100px;
}
#red-box {
  view-transition-name: red-box;
  background: red;
}
#green-box {
  view-transition-name: green-box;
  background: green;
}
#yellow-box {
  view-transition-name: yellow-box;
  background: yellow;
}

/* <span class="comment">
次の~styleは、
`view-transition-class$p のおかげで，すべての~boxに適用されることになる：
◎
The following style would apply to all the boxes, thanks to 'view-transition-class'
</span> */
::view-transition-group(*.any-box) {
  animation-duration: 1s;
}
</pre>
</div>

			</section>
		</section>
	</section>
	<section id="css-properties">
<h2 title="CSS Properties">2. ~CSS~prop</h2>

		<section id="view-transition-class-prop">
<h3 title="Applying the same style to multiple participating elements: the view-transition-class property">2.1. 遷移に関与している複数の要素に対する同じ~styleの適用-法： `view-transition-class^p ~prop</h3>

◎名 `view-transition-class@p
◎値 `~noneC$v | `custom-ident$t*
◎初 `none^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`view-transition-class$p を利用すれば、
複数の`有名~view遷移~疑似要素$に対し，
`view-transition-name$p 【により指定された`~view遷移~名$】が異なっていても同じ~style規則を適用できる。
`view-transition-name$p は，
旧-状態~内にある要素と新-状態~内にある対応している要素どうしを照合するために利用されるが、
`view-transition-class$p は，
~view遷移~疑似要素
（ `view-transition-group()$pe,
`view-transition-image-pair()$pe,
`view-transition-old()$pe,
`view-transition-new()$pe ）
を利用して~styleを適用するために限り利用される。
◎
The view-transition-class can be used to apply the same style rule to multiple named view transition pseudo-elements which may have a different view-transition-name. While view-transition-name is used to match between the element in the old state with its corresponding element in the new state, view-transition-class is used only to apply styles using the view-transition pseudo-elements (::view-transition-group(), ::view-transition-image-pair(), ::view-transition-old(), ::view-transition-new()).
</p>

<p>
`view-transition-class$p は、
要素を捕捉するために~markするものではないことに注意
— その利用は、［
すでに `view-transition-name$p を有する要素を~styleする
］ための追加的な仕方に限られる。
◎
Note that view-transition-class by itself doesn’t mark an element for capturing, it is only used as an additional way to style an element that already has a view-transition-name.
</p>
<dl class="valdef">
	<dt>`~noneC@v</dt>
	<dd>
当の要素~用に生成される`有名~view遷移~疑似要素$に適用される~classは無い。
◎
No class would apply to the named view transition pseudo-elements generated for this element.
</dd>

	<dt id="valdef-view-transition-class-custom-ident">`custom-ident$t*</dt>
	<dd>
指定された `custom-ident$t 値（ `none^v 以外）すべてが、
`有名~view遷移~疑似要素$`選択子$内で利用されるときに適用される。
`none^v は、
この~prop用の `custom-ident^t としては妥当でない
— 他の `custom-ident^t と組合されたときでも。
◎
All of the specified &lt;custom-ident&gt; values (apart from none) are applied when used in named view transition pseudo-element selectors. none is an invalid &lt;custom-ident&gt; for view-transition-class, even when combined with other &lt;custom-ident&gt;s.
</dd>
	<dd class="note">注記：
同じ `view-transition-name$p が，遷移を成す［
旧-, 新-
］両~状態~内にある要素~用に指定された場合、
`view-transition-class$p の値は，新-状態~用のものに限り適用される。
このことは、
非同一-文書な~view遷移~用にも適用される：
旧-文書~内で指定された~classは、
対応する `view-transition-name$p が新-文書~内に指定されなかった場合に限り，
適用されることになる。
◎
Note: If the same view-transition-name is specified for an element both in the old and new states of the transition, only the view-transition-class values from the new state apply. This also applies for cross-document view-transitions: classes from the old document would only apply if their corresponding view-transition-name was not specified in the new document.
</dd>
</dl>

		</section>
	</section>
	<section id="pseudo-classes">
<h2 title="Pseudo-classes">3. 疑似類</h2>

		<section id="the-active-view-transition-pseudo">
<h3 title="Active View Transition Pseudo-class :active-view-transition()'">3.1. 作動中な~view遷移~疑似類 `active-view-transition()^ps</h3>

<p>
`active-view-transition()@ps
疑似類は、
当の文書が［
その引数 `vt-type-selector$t に合致している`作動中な~view遷移$doc
］を有する場合に［
当の文書の根~要素
］に適用される。
その構文は：
◎
The :active-view-transition(&lt;vt-type-selector&gt;) pseudo-class applies to the root element of the document, if it has a matching active view transition. It has the following syntax definition:
</p>

<pre class="prod">
:active-view-transition(`vt-type-selector$t)

`vt-type-selector@t
	= '*'
	| `custom-ident$t#
</pre>

<p>
`active-view-transition()$ps の`詳細度$は、
その `vt-type-selector$t が［
`*^css （`全称~選択子$）ならば 1 個／
~ELSE_ 2 個
］の疑似類~選択子と同じになる。
◎
The specificity of an :active-view-transition() is one pseudo-class selector if it has value is *, and two if it has any other value.
</p>

<p>
`active-view-transition()$ps 疑似類は、
~AND↓ が満たされるならば`文書~要素$に合致する：
◎
An ::active-view-transition() pseudo-class matches the document element when＼
</p>
<ul>
	<li>
`文書~要素$の`~node文書$にて`作動中な~view遷移$doc %~view遷移 ~NEQ ~NULL
◎
it has an non-null active view transition viewTransition,＼
</li>
	<li>
<p>
~OR↓
◎
for which any of the following are true:
</p>
		<ul>
			<li>
疑似類を成す `vt-type-selector$t ~EQ `*^css （`全称~選択子$）
◎
The &lt;vt-type-selector&gt; is *
</li>
			<li>
疑似類を成す `vt-type-selector$t を成すある `custom-ident$t ~IN %~view遷移 にて`作動中な型~群$vT
◎
viewTransition’s active types contains at least one of the &lt;custom-ident&gt; values of the &lt;vt-type-selector&gt;.
</li>
		</ul>
	</li>
</ul>

<div class="example">

<p>
例えば、
開発者は，次の方式で遷移を開始するかもしれない：
◎
For example, the developer might start a transition in the following manner:
</p>

<pre class="lang-js">
document.startViewTransition({update: %updateTheDOMSomehow, types: ["slide-in", "reverse"]});
</pre>

<p>
これは、
次に挙げる `active-view-transition()$ps 選択子をいずれも作動化することになる：
◎
This will activate any of the following '::active-view-transition()'' selectors:
</p>

<pre class="lang-css">
:root:active-view-transition(slide-in) {}
:root:active-view-transition(reverse) {}
:root:active-view-transition(slide-in, reverse) {}
:root:active-view-transition(slide-in, something-else) {}
:root:active-view-transition(*) {}
</pre>

<p>
一方で，遷移~型を選定することなく遷移を開始した場合、
`*^css を伴う `active-view-transition()^pe に限り，
作動化することになろう：
◎
While starting a transition without selecting transition types, would only activate '::active-view-transition() with *'':
</p>

<pre class="lang-js">
document.startViewTransition(%updateTheDOMSomehow);
/* <span class="comment">
または
◎
or
</span> */
document.startViewTransition({update: %updateTheDOMSomehow});
</pre>

<pre class="lang-css">
/* <span class="comment">
次に挙げるものは、
作動中になる：
◎
This would be active
</span> */
:root { }
:root:active-view-transition(*) {}

/* <span class="comment">
次に挙げるものは、
作動中にならない：

◎
This would not be active
</span> */
:root:active-view-transition(slide-in) {}
:root:active-view-transition(any-type-at-all-except-star) {}
</pre>
</div>

		</section>
	</section>
	<section id="pseudo-element-additions">
<h2 title="Additions to named view-transition pseudo-elements">4. 有名~view遷移~疑似要素に対する追加</h2>


<p>
`有名~view遷移~疑似要素$
（ `view-transition-group()$pe,
`view-transition-image-pair()$pe,
`view-transition-old()$pe,
`view-transition-new()$pe ）
は、
次の構文を~supportするよう拡張される：
◎
The named view transition pseudo-elements (view-transition-group(), view-transition-image-pair(), view-transition-old(), view-transition-new()) are extended to support the following syntax:
</p>

<pre class="prod">
::view-transition-group(`pt-name-selector$t`pt-class-selector$t)
::view-transition-image-pair(`pt-name-selector$t`pt-class-selector$t)
::view-transition-old(`pt-name-selector$t`pt-class-selector$t)
::view-transition-new(`pt-name-selector$t`pt-class-selector$t)
</pre>

<p>
`pt-name-selector$t は、
`~level 1$ にて定義されたとおりに働く。
`pt-class-selector$t の構文は：
◎
where &lt;pt-name-selector&gt; works as previously defined, and &lt;pt-class-selector&gt; has the following syntax definition:
</p>

<pre class="prod">
`pt-class-selector@t
	= ['.' `custom-ident$t]*
</pre>

<p>
`有名~view遷移~疑似要素$`選択子$に合致する要素は、
`pt-class-selector$t 空であったとするとき合致する要素 %疑似要素 のうち，
次を満たすものに合致する
⇒
`pt-class-selector$t を成す どの `custom-ident^t も次を満たす
⇒
`custom-ident^t ~IN 当の~view遷移の`有名~要素~群$vT[ %疑似要素 の`~view遷移~名$【！ `view-transition-name$p】 ] の`~class~list$cE
◎
A named view transition pseudo-element selector which has one or more &lt;custom-ident&gt; values in its &lt;pt-class-selector&gt; would only match an element if the class list value in named elements for the pseudo-element’s view-transition-name contains all of those values.
</p>

<p>
`有名~view遷移~疑似要素$`選択子$の`詳細度$は、［
`pt-class-selector$t 空であったとするときの詳細度
］に［
`pt-class-selector$t を成す `custom-ident^t の個数と同じ個数の`~class選択子$が成す詳細度
］を加えた結果になる。
◎
The specificity of a named view transition pseudo-element selector with a &lt;pt-class-selector&gt; is equivalent to a class selector with the equivalent number of classes.
</p>

	</section>
	<section id="css-rules">
<h2 title="CSS rules">5. ~CSS規則</h2>

		<section id="view-transition-rule">
<h3 title="The @view-transition rule">5.1. `view-transition^at 規則</h3>

<p>
`view-transition@at
~at-規則は、
次を指示するために利用される
⇒
非同一-文書~naviは、
`ViewTransition$I を設定しておいて作動化するベキである
【順に，`非同一-文書な~view遷移を設定しておく$, `~view遷移を作動化する$】
◎
The @view-transition rule is used by a document to indicate that cross-document navigations should setup and activate a ViewTransition.＼
</p>

<p>
［
旧-文書／新-文書
］において，この規則の効果が発揮されるためには、［
当の文書が`~unloadされ$る／
`pagereveal$et ~eventが発火される【当の文書が`露呈され$る】
］時点で，当の文書~内にそれが在ることが要求される。
◎
To take effect, it must be present in the old document when unloading, and in the new document when the pagereveal is fired.
</p>

		</section>
		<section id="view-transition-grammar">
<h3 title="@view-transition rule grammar">5.2. `view-transition^at 規則の文法</h3>

<p>
`view-transition$at 規則の構文は：
◎
The @view-transition rule has the following syntax:
</p>

<pre class="prod">
@view-transition {
  `declaration-rule-list$t
}
</pre>

<p class="note">注記：
既定の挙動に倣い、
`view-transition$at 規則は，`条件付き~group規則$
— `media$at や `supports$at など —
の内側に入子にできる。
◎
Note: as per default behavior, the @view-transition rule can be nested inside a conditional group rule such as @media or @supports.
</p>

		</section>
		<section id="view-transition-navigation-descriptor">
<h3 title="The navigation descriptor">5.3. `navigation^d 記述子</h3>

◎述 `navigation@d
◎用 `view-transition$at
◎値 `auto$v | `none$v
◎初 `none$v
◎表終

<p>
`navigation$d 記述子は、［
ある種の種別の~naviを遂行する
］ときに［
ある~view遷移を自動的に開始する
］ことを~opt-inする。
それは、［
旧-文書, 新-文書
］どちらにおいても
（前者は`~unloadされ$る時点で, 後者は`露呈され$る時点で）
可能化される必要がある。
◎
The 'navigation' descriptor opts in to automatically starting a view transition when performing a navigation of a certain type. It needs to be enabled both in the old document (when unloading) and in the new document (when reveal).
</p>

<dl>
	<dt>`none@v</dt>
	<dd>
遷移は無い。
◎
There will be no transition.
</dd>

	<dt>`auto@v</dt>
	<dd>
<p>
遷移は、
当の~naviが ~AND↓ を満たす場合には可能化されることになる：
</p>
		<ul>
			<li>
同一-生成元である
</li>
			<li>
非同一-生成元な~redirectを伴わない
</li>
			<li>
<p>
~OR↓
</p>
				<ul>
					<li>
その `NavigationType$I ~EQ `traverse$l
◎
traverse or
</li>
					<li>
［
その `NavigationType$I ~IN { `push$l, `replace$l }
］~AND［
`~naviに対する利用者-関与i$ ~NEQ `~browser~UI$i
］
◎
push or replace with user navigation involvement not equal to "browser UI".
</li>
				</ul>
			</li>
		</ul>
◎
The transition will be enabled if the navigation is same-origin, without cross-origin redirects, and whoes NavigationType is
• traverse or
• push or replace with user navigation involvement not equal to "browser UI".
</dd>
	<dd class="note">注記：
`auto$v から除外される~naviは、
例えば，次を介して~navigateすることである
⇒＃
~URL~bar／
~bookmarkを~clickすること
利用者や~scriptが起動した `reload$l
◎
Note: Navigations excluded from auto are for example, navigating via the URL address bar or clicking a bookmark, as well as any form of user or script initiated reload.
</dd>
</dl>

		</section>
		<section id="view-transition-type-descriptor">
<h3 title="The type descriptor">5.4. `type^d 記述子</h3>

◎述 `type@d
◎用 `view-transition$at
◎値 `none^v | `custom-ident$t*
◎初 `none^v
◎表終

<p>
`type$d 記述子は、
~view遷移を捕捉して遂行するときに，当の遷移にて`作動中な型~群$vTを設定する
— それは、
`startViewTransition(callbackOptions)$m を
— %callbackOptions の `type$mb に その値を与える下で —
~callすることに等価になる。
◎
The 'type' descriptor sets the active types for the transition when capturing and performing the transition, equivalent to calling startViewTransition(callbackOptions) with that type.
</p>

		</section>
	</section>
	<section id="api">
<h2 title="API">6. ~API</h2>

		<section id="additions-to-document-api">
<h3 title="Additions to Document">6.1. `Document^I に対する追加</h3>

<pre class="idl">
dictionary `StartViewTransitionOptions@I {
  `UpdateCallback$I? `update@mb = null;
  `sequence$&lt;`DOMString$&gt;? `type@mb = null;
};

partial interface `Document$I {

  `ViewTransition$I `startViewTransition$m(optional (`UpdateCallback$I or `StartViewTransitionOptions$I) %callbackOptions = {});
};
</pre>

<div class="algo">
<p id="ViewTransition-start-with-options">
`startViewTransition(callbackOptions)@m
`~method手続き$は：
◎
4.1.1. startViewTransition(callbackOptions) Method Steps
◎
The method steps for startViewTransition(callbackOptions) are as follows:
</p>
<ol>
	<li>
%startViewTransition ~LET ［
`~level 1$ に定義される `startViewTransition＠~CSSVT#dom-document-startviewtransition$m 用の~method手続き
］をコレ上で適用する手続き
◎
↓</li>
	<li>
~IF［
%callbackOptions ~EQ ε
］
⇒
~RET %startViewTransition()
◎
If callbackOptions is not provided, then run the method steps for startViewTransition() and return the result.
</li>
	<li>
~IF［
%callbackOptions は `UpdateCallback$I である
］
⇒
~RET %startViewTransition( %callbackOptions )
◎
If callbackOptions is an UpdateCallback, then run the method steps for startViewTransition(updateCallback) given callbackOptions and return the result.
</li>
	<li>
%~view遷移 ~LET %startViewTransition( %callbackOptions[ "`update$mb" ] )
◎
Let viewTransition be the result of running method steps for startViewTransition(updateCallback) given callbackOptions’s update.
</li>
	<li>
%~view遷移 にて`作動中な型~群$vT ~SET %callbackOptions[ "`type$mb" ] )
◎
Set viewTransition’s active types to callbackOptions’s type.
</li>
	<li>
~RET %~view遷移
◎
Return viewTransition.
</li>
</ol>
</div>

		</section>
		<section id="extensions-to-cssrule-interface">
<h3 title="Extensions to the CSSRule interface">6.2. `CSSRule^I ~interfaceに対する拡張</h3>

<p>
`CSSRule$I ~interfaceは
次に従って拡張される：
◎
The CSSRule interface is extended as follows:
</p>

<pre class="idl">
partial interface `CSSRule$I {
  const `unsigned short$ `VIEW_TRANSITION_RULE@m = 15;
};
</pre>

		</section>
		<section id="navgation-behavior-rule-interface">
<h3 title="The CSSViewTransitionRule interface">6.3. `CSSViewTransitionRule^I ~interface</h3>

<p>
`CSSViewTransitionRule$I は、
ある `view-transition$at 規則を表現する。
◎
The CSSViewTransitionRule represents a @view-transition rule.
</p>

<pre class="idl">
enum `ViewTransitionNavigation@I { `auto@l, `none@l };
[`Exposed$=Window]
interface `CSSViewTransitionRule@I : `CSSRule$I {
  attribute `ViewTransitionNavigation$I `navigation@m;
  attribute `DOMTokenList$I `type@m;
};
</pre>

		</section>
	</section>
	<section id="algorithms">
<h2 title="Algorithms">7. ~algo</h2>

		<section id="concepts">
<h3 title="Data Structures">7.1. ~data構造</h3>

			<section id="view-transitions-extension">
<h4 title="Additions to ViewTransition">7.1.1. `ViewTransition^I に対する追加</h4>

<p>
各 `ViewTransition$I は、
次に挙げるものを追加的に有する：
◎
A ViewTransition additionally has:
</p>
<ul>
	<li>
<p>
`内へ来る非同一-文書な遷移か@vT
⇒
真偽値
— 初期~時は ~F とする。
◎
is inbound cross-document transition
• a boolean, initially false.
</p>

<p class="trans-note">【
“内へ来る（ `inbound^en ）” とは、
新-文書における遷移であることを意味する
（すなわち， ~T ならば、
当の遷移は非同一-文書な~view遷移であって，
当の `ViewTransition$I に`関連な大域~obj$に`結付けられた文書$は新-文書である）。
対して，以下に現れる “外へ出る（ `outbound^en ）” は、
旧-文書における遷移であることを意味する。
】</p>

<p class="issue">
非同一-文書な~view遷移は【同一-文書な~view遷移が作動中な場合でも】優先されるベキか？
`9512$issue を見よ。
◎
should a cross-document transition take precedent? See #9512
</p>
	</li>
	<li>
`作動中な型~群@vT
⇒
~NULL ／ 文字列たちが成す`~list$
— 初期~時は ~NULL とする。
◎
active types
• Null or a list of strings, initially null.
</li>
</ul>

			</section>
		</section>
		<section id="additions-to-captured-element-struct">
<h3 title="Additions to captured element struct">7.2. `捕捉された要素$に対する追加</h3>

<p>
構造体 `捕捉された要素$は、
次に挙げる~item【！~field】も伴うベキである：
◎
The captured element struct should contain these fields, in addition to the existing ones:
</p>

<dl>
	<dt>`~class~list@cE</dt>
	<dd>
文字列たちが成す`~list$
◎
a list of strings,＼
</dd>
	<dd>
初期~時は空とする。
◎
initially empty.
</dd>
</dl>

		</section>
		<section id="vt-class-algorithms">
<h3 title="Algorithms to capture view-transition-class:">7.3. `view-transition-class$p に対し捕捉する~algo</h3>

<div class="algo">
<p>
`~level 1$ の［
`旧-状態を捕捉する$／
`新-状態を捕捉する$
］~algoには、
【 “新たな捕捉された要素” を設定する段の後に】
所与の
( `捕捉された要素$ %捕捉, `要素$ %要素 )
に対し，次を遂行する段を追加する
⇒
%捕捉 の`~class~list$cE ~SET %要素 の `view-transition-class$p の`算出d値$
◎
When capturing the old or new state for an element, perform the following steps given a captured element capture and an element element:
• Set capture’s class list to the computed value of element’s view-transition-class.
</p>

<p class="note">注記：
これは、
~monkey~patch方式で書かれており，
`~level 1$ 仕様が熟したときには，その~algoの中へ併合されることになる。
◎
Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</p>
</div>

		</section>
		<section id="monkey-patch-to-html">
<h3 title="Monkey patches to HTML">7.4. ~HTMLに対する~monkey~patch</h3>

<p>
`履歴~stepを適用する$
~algoに対し：
◎
Prepend these steps at the beginning of the task queued on navigable’s active window when applying the history step (14.11.1, here): 
</p>
<ul>
	<li>
この~monkey~patchは、
次が与えられたものと見做す
⇒＃
`~navigableを変更している継続の状態$ 【！真偽値】 %~navigableを変更している継続,
`~navigable$ %~navigable,
`文書$ %旧-文書,
`文書$ %新-文書,
`NavigationType$I %~navi種別,
`~naviに対する利用者-関与i$ %~naviに対する利用者-関与i.
◎
This monkey-patch step assumes a boolean changingNavigationContinuation, a navigable navigable, a Document oldDocument, a Document newDocument, a NavigationType navigationType, and a user navigation involvement userInvolvementForNavigateEvents.
</li>
	<li class="algo">
<p>
`段 14.11＠~HTMLnav#_monkey-patched-by-css-view-transitions-2$
にて~queueされる~taskを成す手続き %手続き に代えて，
次を遂行するようにする：
</p>
		<ol>
			<li>
%~browser~UIによる~naviか ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%~naviに対する利用者-関与i ~EQ `~browser~UI$i
◎
Let isBrowserUINavigation be true if userInvolvementForNavigateEvents is "browser UI", otherwise false.
</li>
			<li>
<p>
~IF［
%~navigableを変更している継続 の`更新のみか$cnC ~EQ ~F
］
⇒
`非同一-文書な~view遷移を設定しておく$( ↓ )
⇒＃
%旧-文書,
%新-文書,
%~navi種別†,
%~browser~UIによる~naviか†,
%手続き
</p>

<p class="trans-note">【†
これらの引数は，本当は［
新たに追加された，`~naviは非同一-文書な~view遷移を誘発し得るか？$
］に渡されるべきだが、
この~patchは，まだそれを織り込んでいない。
】</p>

<p class="note">注記：
これは、［
旧-文書を~unloadして新-文書を作動化する
］ことを続行する前に［
遷移が捕捉されるか飛ばされる
］まで待機することになる。
</p>
			</li>
			<li>
~ELSE
⇒
%手続き()
</li>
		</ol>
◎
If changingNavigationContinuation update-only is false, then setup cross-document view-transition given oldDocument, newDocument, navigationType, isBrowserUINavigation, and the remaining steps and return from these steps.
◎
Note: This would wait until a transition is captured or skipped before proceeding to unloading the old document and activating the new one.
</li>
</ul>

		</section>
		<section id="setting-up-and-activating-the-cross-document-view-transition">
<h3 title="Setting up and activating the cross-document view transition">7.5. 非同一-文書な~view遷移の設定-法と作動化-法</h3>

			<section id="resolve-view-transition-rule-algo">
<h4 title="Resolving the @view-transition' rule">7.5.1. `view-transition$at 規則の解決-法</h4>

<div class="algo">
<p>
`~view遷移~規則を解決する@
ときは、
所与の
( `文書$ %文書 )
に対し：
◎
To get the resolve @view-transition rule for a Document document:
</p>
<ol>
	<li>
<p>
%合致している規則 ~LET %文書 内に `view-transition$at 規則は［
在るならば それらのうち最後のもの／
無いならば ε
］
</p>

<p class="trans-note">【
`条件付き~group規則$内に入子にされ，条件が満たされないため無視される規則は、
この段の目的においては，無かったものと見なされよう。
】</p>
◎
Let matchingRule be the last @view-transition rule in document.
</li>
	<li>
~IF［
%合致している規則 ~EQ ε
］
⇒
~RET `遷移を飛ばす^i
◎
If matchingRule is not found, then return "skip transition".
</li>
	<li>
~IF［
%合致している規則 の `navigation$d 記述子の`算出d値$ ~EQ `none$v
］
⇒
~RET `遷移を飛ばす^i
◎
If matchingRule’s navigation descriptor’s computed value is none, then return "skip transition".
</li>
	<li>
~Assert：
%合致している規則 の `navigation$d 記述子の`算出d値$ ~EQ `auto$v
◎
Assert: matchingRule’s navigation descriptor’s computed value is auto.
</li>
	<li>
%型~群~記述子 ~LET %合致している規則 の `type$d 記述子の`算出d値$
◎
Let typesDescriptor be matchingRule’s type descriptor.
</li>
	<li>
~IF［
%型~群~記述子 ~EQ `none^v
］
⇒
~RET 新たな`~list$
◎
If typesDescriptor’s computed value is none, then return a list « ».
</li>
	<li>
~RET %型~群~記述子 を成す文字列たちが成す`~list$
◎
Return a list of strings corresponding to typesDescriptor’s computed value.
</li>
</ol>
</div>

			</section>
			<section id="setup-old-document-vt">
<h4 title="Setting up the view-transition in the old Document">7.5.2. 旧-文書~内で~view遷移を設定しておく</h4>

<div class="algo">
<p>
`~naviは非同一-文書な~view遷移を誘発し得るか？@
検査するときは、
所与の
⇒＃
`生成元$ %旧-生成元, 
`生成元$ %新-生成元,
真偽値 %~naviは非同一-生成元な~redirectを経たか,
`NavigationType$I %~navi種別,
真偽値 %~browser~UIによる~naviか
◎終
に対し：
◎
To check if a navigation can trigger a cross-document view-transition? given an origin oldOrigin, an origin newOrigin, a boolean navigationHasCrossOriginRedirects, a NavigationType navigationType, and a boolean isBrowserUINavigation:
</p>

<p class="note">注記：
これは、
~naviの間に［
~callされる／`並列的$に~callされる
］
— `view-transition$at 規則を利用して~view遷移を~opt-inした文書~用に。
◎
Note: this is called during navigation, potentially in parallel, for documents that have opted-in to view-transitions using the @view-transition rule.
</p>

<ol>
	<li>
任意選択で
⇒
~IF［
~UAは`実装定義$な~navi体験を表示するものと裁定した
（例： ~gestureに基づく後戻りする~navi用の遷移）
］
⇒
~RET ~F
（~UAは作者-定義な~view遷移を無視してもヨイ。）
◎
If the user agent decides to display an implementation-defined navigation experience, e.g. a gesture-based transition for a back navigation, the user agent may ignore the author-defined view transition. If that is the case, return false.
</li>
	<li>
~IF［
%~navi種別 ~EQ `reload$l
］
⇒
~RET ~F
◎
If navigationType is reload, then return false.
</li>
	<li>
~IF［
%~browser~UIによる~naviか ~EQ ~T
］~AND［
%~navi種別 ~IN { `push$l, `replace$l }
］
⇒
~RET ~F
◎
If isBrowserUINavigation is true, and navigationType is push or replace, then return false.
</li>
	<li>
~IF［
( %旧-生成元, %新-生成元 )
は`同一-生成元$でない
］
⇒
~RET ~F
◎
If oldOrigin is not same origin as newOrigin then return false.
</li>
	<li>
~IF［
%~naviは非同一-生成元な~redirectを経たか ~EQ ~T
］
⇒
~RET ~F
◎
If navigationHasCrossOriginRedirects is true, then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`非同一-文書な~view遷移を設定しておく@
ときは、
所与の
⇒＃
`文書$ %旧-文書,
`文書$ %新-文書,
~algo %準備済み時の手続き
◎終
に対し：
◎
To setup cross-document view-transition given a Document oldDocument, a Document newDocument, and onReady, which is an algorithm accepting nothing: 
</p>
<ol>
	<li>
%解決-済み規則 ~LET `~view遷移~規則を解決する$( %旧-文書 )
◎
Let resolvedRule be the result of resolving the @view-transition rule for oldDocument.
</li>
	<li>
<p>
~IF［
%解決-済み規則 ~EQ `遷移を飛ばす^i
］
⇒
~RET ~NULL
◎
If resolvedRule is "skip transition", then return null.
</p>

<p class="note">注記：
%新-文書 は，構文解析-済みでないかもしれないので、
それが~opt-inされたかどうかは，まだ知れない。
%新-文書 用に~opt-inを検査するのは、
`pagereveal$et ~eventが発火されたときになる。
◎
Note: We don’t know yet if newDocument has opted in, as it might not be parsed yet. We check the opt-in for newDocument when we fire the pagereveal event.
</p>
	</li>
	<li>
<p>
~IF［
%旧-文書 にて`作動中な~view遷移$doc ~NEQ~NULL
］
⇒
`~view遷移を飛ばす$( %旧-文書 にて`作動中な~view遷移$doc, %旧-文書 に`関連な~realm$に属する `AbortError$E 例外 )
◎
If oldDocument’s active view transition is not null, then skip oldDocument’s active view transition with an "AbortError" DOMException in oldDocument’s relevant Realm.
</p>

<p class="note">注記：
これは、
当の文書が~unloadするに準備済みなときは，
走っている遷移を飛ばすことを意味する。
◎
Note: this means that any running transition would be skipped when the document is ready to unload.
</p>
	</li>
	<li>
<p>
%旧-文書 の`~view遷移を自動で飛ばすか$doc ~SET ~T
◎
Set oldDocument’s auto-skip view transitions to true.
</p>

<p class="note">注記：
これは、
非同一-文書な~view遷移~用に旧-文書を捕捉している間に `startViewTransition()$m が~callされたときは、［
その引数に渡した~callbackは走らすが，~animationは飛ばす
］ようにすることを意味する。
◎
Note: this means that calling startViewTransition() while capturing the old document for a cross-document view-transition would run the callback but skip the animation.
</p>
	</li>
	<li>
%外へ出る遷移 ~LET `新たな~obj$( `ViewTransition$I, %旧-文書 に`関連な~realm$ )
◎
Let outboundTransition be a new ViewTransition object in oldDocument’s relevant Realm,＼
</li>
	<li>
<p>
%外へ出る遷移 の
⇒＃
`作動中な型~群$vT ~SET %解決-済み規則
`旧-状態~捕捉-時の処理n$vT ~SET 次の手続き：
◎
whose active types is resolvedRule, and whose process old state captured is set to the following steps:
</p>

<p class="issue">
ここでも再び~opt-inを検査するベキか？
— `requestAnimationFrame()$m に渡した~callbackが~CSSOMを変更した事例~用に。
◎
should we check for the opt-in again, in case there was a CSSOM change in a requestAnimationFrame callback?
</p>
<div class="algo">
<p>
手続きは：
</p>
		<ol>
			<li>
~IF［
%外へ出る遷移 の`相$vT ~EQ `済み$i
］
⇒＃
%準備済み時の手続き()；
~RET
◎
If outboundTransition’s phase is "done", then call onReady and return.
</li>
			<li>
~Assert：
%外へ出る遷移 の`相$vT ~EQ `捕捉-待ち$i
◎
Assert: outboundTransition’s phase is "pending-capture".
</li>
			<li>
<p>
`~view遷移を~clearする$( %外へ出る遷移 )
◎
Clear view transition outboundTransition.
</p>

<p class="note">注記：
旧-文書~上の `ViewTransition$I ~objは、
旧-状態が新-文書~下に複製された後には，破壊されるベキである。
この段は、
それを明示的に~clearする
— 旧-文書は、
~UAにより~cacheされることもあるので。
◎
Note: The ViewTransition object on the old Document should be destroyed after its state has been copied to the new Document below. We explicitly clear it here since the old Document may be cached by the UA.
</p>
			</li>
			<li>
%旧-文書 の`~view遷移を自動で飛ばすか$doc ~SET ~F
◎
Set oldDocument’s auto-skip view transitions to false.
</li>
			<li>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %新-文書 に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the DOM manipulation task source given newDocument’s relevant global object, to perform＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
				<ol>
					<li>
%内へ来る遷移 ~LET `新たな~obj$( `ViewTransition$I, %新-文書 に`関連な~realm$ )
◎
Let inboundTransition be a new ViewTransition in newDocument’s relevant Realm,＼
</li>
					<li>
%内へ来る遷移 の
⇒＃
`有名~要素~群$vT ~SET %外へ出る遷移 の`有名~要素~群$vT,
`初期~snapshot包含塊~size$vT ~SET %外へ出る遷移 の`初期~snapshot包含塊~size$vT,
`内へ来る非同一-文書な遷移か$vT ~SET ~T
◎
whose named elements is outboundTransition’s named elements, initial snapshot containing block size is outboundTransition’s initial snapshot containing block size, and whose is inbound cross-document transition is true.
</li>
					<li>
%新-文書 にて`作動中な~view遷移$doc ~SET %内へ来る遷移
◎
Set newDocument’s active view transition to inboundTransition.
</li>
					<li>
`~promiseを解決する$( %内へ来る遷移 の`更新~callback済み時の~promise$vT )
◎
Resolve inboundTransition’s update callback done promise with undefined.
</li>
					<li>
%内へ来る遷移 の`相$vT ~SET `更新~callbackは~call済み$i
◎
Set inboundTransition’s phase to "update-callback-called".
</li>
					<li>
<p>
%準備済み時の手続き()
◎
Call onReady.
</p>

<p class="note">注記：
%内へ来る遷移 は、
`pagereveal$et ~eventを配送した後に作動化される
— この~event【用の~handler】において為された変異が捕捉された新-状態に適用されることを確保するため。
◎
Note: The inboundTransition is activated after the dispatch of pagereveal to ensure mutations made in this event apply to the captured new state.
</p>
					</li>
					<li>
<p>
~UAは、
いつでも， %内へ来る遷移 を飛ばすものと裁定してもヨイ
— 例：`実装定義$な時間切れになった後に。
そうする場合、
~UAは，次を行うベキである
⇒
`大域~taskを~queueする$( `~DOM操作~task~source$, %新-文書 に`関連な大域~obj$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
~IF［
%遷移 の`相$vT ~NEQ `済み$i
］
⇒
`~view遷移を飛ばす$( %遷移, `TimeoutError$E 例外 )
</div>
◎
At any given time, the UA may decide to skip inboundTransition, e.g. after an implementation-defined timeout. To do so, the UA should queue a global task on the DOM manipulation task source given newDocument’s relevant global object to perform the following step: If transition’s phase is not "done", then skip the view transition transition with a "TimeoutError" DOMException.
</li>
				</ol>
</div>
			</li>
		</ol>
</div>

<p class="note">注記：
%外へ出る遷移 は~JSには公開されない
— それは、
旧-文書の状態を捕捉するために限り利用される。
◎
Note: outboundTransition is not exposed to JavaScript, it is used only for capturing the state of the old document.
</p>
	</li>
	<li>
<p>
%旧-文書 にて`作動中な~view遷移$doc ~SET %外へ出る遷移
◎
Set oldDocument’s active view transition to outboundTransition.
</p>

<p class="note">注記：
以降の処理nは、
`~view遷移を設定しておく$中で，
`処理待ち遷移~演算を遂行する$ことを介して継続される【？】。
◎
Note: The process continues in setup view transition, via perform pending transition operations.
</p>
	</li>
	<li>
~RET %外へ出る遷移
◎
↓</li>
</ol>

<p>
~UAは、
【上の手続きを遂行したなら，】
直前に表示していた~frameを次に挙げる いずれか【早い方】までは表示するベキである：
◎
The user agent should display the currently displayed frame until either:
</p>
		<ul>
			<li>
%新-文書 に向けて `pagereveal$et ~eventが発火される時点
◎
The pagereveal event is fired.
</li>
			<li>
%新-文書 にて`作動中な~view遷移$docの`相$vT ~EQ `済み$i になった時点
◎
its active view transition's phase is "done".
</li>
		</ul>

<p class="note">注記：
これは、［
旧-状態を表示してから新-状態を表示するまでの間、
意図されない明滅は生じない
］ことを確保して，遷移を滑らかに保つためである。
◎
Note: this is to ensure that there are no unintended flashes between displaying the old and new state, to keep the transition smooth.
◎
Return outboundTransition.
</p>
</div>

			</section>
			<section id="access-view-transition-in-new-doc">
<h4 title="Accessing the view-transition in the new Document">7.5.3. 新-文書~内での~view遷移の~access法</h4>

<div class="algo">
<p>
`非同一-文書な~view遷移を解決する@
ときは、
所与の
( `文書$ %文書 )
に対し：
◎
To resolve cross-document view-transition for Document document:
</p>
<ol>
	<li>
%遷移 ~LET %文書 にて`作動中な~view遷移$doc
◎
Let transition be document’s active view transition.
</li>
	<li>
<p>
~IF［
%遷移 ~EQ ~NULL
］~OR［
%遷移 の`内へ来る非同一-文書な遷移か$vT ~EQ ~F
］
⇒
~RET ~NULL
◎
If transition is null or transition’s is inbound cross-document transition is false, then return null.
</p>

<p class="note">注記：
%遷移 の`内へ来る非同一-文書な遷移か$vTは、
ある同一-文書な遷移が開始される前に
`pagereveal$et ~eventが発火されたときは
~F になる。
◎
Note: transition’s is inbound cross-document transition would be false if a same-document transition was started before the pagereveal event was fired.
</p>
	</li>
	<li>
%解決-済み規則 ~LET `~view遷移~規則を解決する$( %文書 )
◎
Resolve @view-transition rule for document and let resolvedRule be the result.
</li>
	<li>
~IF［
%解決-済み規則 ~EQ `遷移を飛ばす^i
］
⇒＃
`~view遷移を飛ばす$( %遷移 )；
~RET ~NULL
◎
If resolvedRule is "skip transition", then skip transition and return null.
</li>
	<li>
%遷移 の`作動中な型~群$vT ~SET %解決-済み規則
◎
Set transition’s active types to resolvedRule.
</li>
	<li>
~RET %遷移
◎
Return transition.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="priv">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この仕様が導入する新たな~privacy考慮点は無い。
◎
This specification introduces no new privacy considerations.
</p>

	</section>
	<section id="sec">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
非同一-生成元の課題を防止するため，現時点では、
非同一-文書な~view遷移が可能化され得るのは，同一-生成元な~naviに限られる。
それでも、
`WICG/view-transitions 課題 #200＠https://github.com/WICG/view-transitions/issues/200$
にて論じられたとおり，次に挙げる潜在的な脅威がある：
◎
To prevent cross-origin issues, at this point cross-document view transitions can only be enabled for same-origin navigations. As discussed in WICG/view-transitions#200, this still presents two potential threats:
</p>

<ol>
	<li>
新-文書, 旧-文書における`非同一-生成元~能力は隔離されるか？$enVは、
異なるかもしれない。
これは、［
この~flagが~T をとる文書
］が［
この~flagが ~F をとる文書
］から文書から画像~dataを読取れるような状況を生じさせ得る。
これは、
`~level 1$ `§ ~securityの考慮点＠~CSSVT#sec$
にて すでに軽減-済みである
— 同じ制約は、
捕捉された非同一-生成元な `iframe^e 用に適用されるので。
◎
The cross-origin isolated capability in both documents might be different. This can cause a situation where a Document that is cross-origin isolated can read image data from a document that is not cross-origin isolated. This is already mitigated in [[css-view-transitions-1#sec], as the same restriction applies for captured cross-origin iframes.
</li>
	<li>
<p>
同一-生成元な~naviは、
依然として
非同一-生成元な~redirectを介して生じるかもしれない
例：
`https://example.com^c に在る~pageが
`https://auth-provider.com/^c に在る~pageへ~linkしていて，
それが `https://example.com/loggedin^c へ戻るよう~redirectする場合。
◎
A same-origin navigation might still occur via a cross-origin redirect, e.g. https://example.com links to https://auth-provider.com/ which redirects back to https://example.com/loggedin.
</p>

<p>
これは、
非同一-生成元な主体が［
利用者を期待されない当事者-主体~URLへ~redirectする
］一方で［
期待されない遷移を生じさせる
］ことにより，
~redirectが在った事実
【非同一-生成元な文書が介入した事実】
をぼやかす（軽微な）状況を生じさせ得る。
これを軽減するため、
現時点では［
`文書$の`非同一-生成元~redirectを介して作成されたか$doc ~EQ ~T
］の場合には，~navi用の~view遷移は不能化される。
この検査は、
当の`文書$が`作動化し直され$ているときは，
適用されないことに注意
— その事例では、
非同一-生成元な~redirectが すでにその場を占めているので。
◎
This can cause a (minor) situation where the cross-origin party would redirect the user to an unexpected first-party URL, causing an unexpected transition and obfuscating that fact that there was a redirect. To mitigate this, currently view transitions are disabled for navigations if the Document was created via cross-origin redirects. Note that this check doesn’t apply when the Document is being reactivated, as in that case the cross-origin redirect has already taken place.
</p>

<p class="note">注記：
これが適用されるのは、
~server側による~redirectに限られる。
~client側による~redirect
— 例：
<code>&lt;`meta＠~HEmetadata#the-meta-element$ `http-equiv＠~HEmetadata#attr-meta-http-equiv$=`refresh＠~HEmetadata#attr-meta-http-equiv-keyword-refresh$&gt;</code>
を利用するなどによる —
は、
新たな~naviと等価になる。
◎
Note: this only applies to server-side redirects. A client-side redirect, e.g. using [^meta/http-equiv/refresh^], is equivalent to a new navigation.
</p>
	</li>
	<li>
この特能は、
~CSSに より多く情報を公開する
— これまでの~CSSは、
~naviに関係するものを何も自覚しなかったので。
これは、
第三者-主体に属する~CSSの安全性に関わる懸念を提起し得る。
しかしながら，一般~規則として、
第三者-主体に属する~stylesheetは，まずは信用される~sourceから来るベキである
— ~CSSは、［
文書について `learn^en 【？】し得る／
多くの仕方で文書【の呈示】を変更し得る
］ので。
◎
This feature exposes more information to CSS, as so far CSS was not aware of anything navigation-related. This can raise concerns around safety 3rd-party CSS. However, as a general rule, 3rd-party stylesheets should come from trusted sources to begin with, as CSS can learn about the document or change it in many ways.
</li>
</ol>

<p>
詳細な論点は、
`8684$issue,
`WICG/view-transitions 課題 #200＠https://github.com/WICG/view-transitions/issues/200$
を見よ。
◎
See Issue #8684 and WICG/view-transitions#200 for detailed discussion.
</p>

	</section>
</main></div>
