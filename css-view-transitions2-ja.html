<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8">
<title>CSS View Transitions Module Level 2（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">
<style>

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'at':
	text = `@${key}`;
	break;
case 'p':
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'pe':
	text = `::${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'm1':
	let n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}"></a>`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:CSS View Transitions Module Level 2
spec_date:2024-11-14
trans_update:2024-11-14
source_checked:240322
page_state_key:CSS
original_url:https://drafts.csswg.org/css-view-transitions-2/
	abbr_url:CSSVT2
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-anim,css
conformance:css
copyright:2024,permissive
trans_1st_pub:2023-12-21

●●class_map
p:property
d:descriptor
ps:pseudo
pe:pseudo
t:type
css:css
at:at-rule
f:func
v:value
vN:value
et:event-type
e:element
a:attr
aL:attr
E:error
jv:js-value

●●tag_map
p:code
pe:code
ps:code
t:var
at:code
css:code
f:code
d:code
et:code
e:code
a:code
aL:code
I:code
m:code
m1:code
mb:code
E:code
v:code
vN:code
jv:code
c:code
V:var
em:em
i:i
cite:cite

●●original_id_map
	descdef-view-transition-types:view-transition-types

●●mdn_urls

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject
sequence:~WEBIDL#idl-sequence
DOMString:~WEBIDL#idl-DOMString
CSSOMString:~CSSOM1#cssomstring
FrozenArray:~WEBIDL#idl-frozen-array
E.AbortError:~WEBIDL#aborterror
E.InvalidStateError:~WEBIDL#invalidstateerror
I.CSSRule:~CSSOM1#cssrule
	I.DOMException:~WEBIDL#idl-DOMException → 例外
I.Document:~DOM4#document
	I.Document → 文書
	I.Element:~DOM4#element → 要素
I.ViewTransitionTypeSet:#viewtransitiontypeset
I.CSSViewTransitionRule:#cssviewtransitionrule
I.StartViewTransitionOptions:#dictdef-startviewtransitionoptions
I.NavigationType:~HTMLnavAPI#navigationtype
I.ViewTransitionUpdateCallback:~CSSVT#callbackdef-viewtransitionupdatecallback
I.ViewTransition:~CSSVT#viewtransition
I.PageSwapEvent:~HTMLnavAPI#pageswapevent
	I.HTMLLinkElement:~HEmetadata#htmllinkelement → e.link

	%callbackOptions:#dom-document-startviewtransition-callbackoptions-callbackoptions
	＠~CSSVT#dom-document-startviewtransition

m.activation:~HTMLnavAPI#dom-pageswapevent-activation
	m.blocking:~HEscripting#dom-script-blocking → a.blocking
	m1.blocking:~HEmetadata#dom-style-blocking → aL.blocking
m.finished:~CSSVT#dom-viewtransition-finished
m.navigation:#dom-cssviewtransitionrule-navigation
m.ready:~CSSVT#dom-viewtransition-ready
m.sessionStorage:~WEBSTORAGE#dom-sessionstorage
m.skipTransition:~CSSVT#dom-viewtransition-skiptransition
m.startViewTransition:#dom-document-startviewtransition
m.types:#dom-viewtransition-types
m1.types:#dom-cssviewtransitionrule-types
m.updateCallbackDone:~CSSVT#dom-viewtransition-updatecallbackdone
m.viewTransition:~HTMLnavAPI#dom-pagerevealevent-viewtransition
m1.viewTransition:~HTMLnavAPI#dom-pageswapevent-viewtransition


mb.update:#dom-startviewtransitionoptions-update
mb.types:#dom-startviewtransitionoptions-types

l.reload:~HTMLnavAPI#dom-navigationtype-reload
l.traverse:~HTMLnavAPI#dom-navigationtype-traverse
l.push:~HTMLnavAPI#dom-navigationtype-push
l.replace:~HTMLnavAPI#dom-navigationtype-replace

	●CSS code

p.view-transition-group:#propdef-view-transition-group
p.view-transition-name:~CSSVT#propdef-view-transition-name
p.view-transition-class:#propdef-view-transition-class

p.box-shadow:~CSSBG#propdef-box-shadow
p.box-sizing:~SIZING#propdef-box-sizing
p.background:~CSSBG#propdef-background
p.border:~CSSBG#propdef-border
p.border-left:~CSSBG#propdef-border-left
p.border-top:~CSSBG#propdef-border-top
p.border-bottom:~CSSBG#propdef-border-bottom
p.border-right:~CSSBG#propdef-border-right
p.border-image:~CSSBG#propdef-border-image
p.border-radius:~CSSBG#propdef-border-radius
	p.border-*:~CSSWG/css-borders-4/#propdef-border-*
p.clip-path:~MASKING1#propdef-clip-path
p.filter:~FILTERS#propdef-filter
p.opacity:~CSSCOLOR#propdef-opacity
p.outline:~CSSUI#propdef-outline
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.padding:~CSSBOX#propdef-padding
p.perspective:~TRANSFORM2#propdef-perspective
p.mask:~MASKING1#propdef-mask
p.mask-image:~MASKING1#propdef-mask-image
p.transform-style:~TRANSFORM2#propdef-transform-style
p.transform:~TRANSFORM#propdef-transform

et.pagereveal:~HTMLindex#event-pagereveal
et.pageswap:~HTMLindex#event-pageswap

t.pt-name-and-class-selector:#typedef-pt-name-and-class-selector
t.pt-class-selector:#typedef-pt-class-selector
t.pt-name-selector:~CSSVT#typedef-pt-name-selector
t.custom-ident:~CSSVAL#identifier-value
t.declaration-list:~CSSSYN#typedef-declaration-list

vN.auto:#valdef-view-transition-navigation-auto
vN.none:#valdef-view-transition-navigation-none

v.~noneC:#valdef-view-transition-class-none
	t.custom-ident:#valdef-view-transition-class-custom-ident

v.none:~CSSVT#valdef-view-transition-name-none
v.auto:#view-transition-name-auto

v.normal:#valdef-view-transition-group-normal
v.nearest:#valdef-view-transition-group-nearest
v.contain:#valdef-view-transition-group-contain
	t.custom-ident:#valdef-view-transition-group-custom-ident
v.border-box:~SIZING#valdef-box-sizing-border-box
v.content-box:~SIZING#valdef-box-sizing-content-box
	v.relative:~CSSPOS#valdef-position-relative → 相対~位置決め

at.media:~CSSCOND#at-ruledef-media
at.supports:~CSSCOND#at-ruledef-supports
at.view-transition:#at-view-transition-rule
d.navigation:#descdef-view-transition-navigation
	d.navigation:#view-transition-navigation
d.types:#descdef-view-transition-types
	d.types:#view-transition-types

ps.active-view-transition:#active-view-transition-pseudo
ps.active-view-transition-type():#active-view-transition-type-pseudo
pe.view-transition:~CSSVT#selectordef-view-transition
pe.view-transition-group():~CSSVT#selectordef-view-transition-group
pe.view-transition-image-pair():~CSSVT#selectordef-view-transition-image-pair
pe.view-transition-old():~CSSVT#selectordef-view-transition-old
pe.view-transition-new():~CSSVT#selectordef-view-transition-new
pe.part():~CSSSHADOWPARTS#selectordef-part

	●code 他
e.link:~HEmetadata#the-link-element
e.script:~HEscripting#the-script-element
e.style:~HEmetadata#the-style-element
e.iframe:~HEembed#the-iframe-element

a.class:~HTMLdom#classes
	a.class:~DOM4#concept-class
a.blocking:~HEscripting#attr-script-blocking
aL.blocking:~HEmetadata#attr-link-blocking

v.expect:~HTMLlinks#link-type-expect

	●用語
内へ来る非同一-文書な~view遷移を解決する:#resolve-inbound-cross-document-view-transition
~view遷移~規則を解決する:#resolve-view-transition-rule
非同一-文書な~view遷移を設定しておく:#setup-cross-document-view-transition
~naviは非同一-文書な~view遷移を誘発し得るか？:#navigation-can-trigger-a-cross-document-view-transition
外へ出る遷移~用の~opt-in状態を更新する:#update-the-opt-in-state-for-outbound-transitions

vT.作動中な型~群:#viewtransition-active-types
vT.外へ出る捕捉-後の手続き:#viewtransition-outbound-post-capture-steps

cE.~class~list:#captured-element-class-list
cE.旧-層~化~捕捉~style:#captured-element-old-layered-capture-style
cE.旧-~box~prop群:#captured-element-old-box-properties
cE.新-~box~prop群:#captured-element-new-box-properties

doc.内へ来る~view遷移~params:#document-inbound-view-transition-params
~view遷移~params:#view-transition-params
doc.外へ出る~view遷移を起動できるか:#document-can-initiate-outbound-view-transition

vTP.有名~要素:#view-transition-params-named-elements
vTP.初期~snapshot包含塊~size:#view-transition-params-initial-snapshot-containing-block-size

cE.包含ng~group名:#captured-element-containing-group-name
cE.~snapshot包含塊からの変形:#captured-element-transform-from-snapshot-containing-block
最も近い包含ng~group名:#nearest-containing-group-name
使用~group名:#used-group-name
文書~視野な~view遷移~group:#document-scoped-view-transition-group

層~化~捕捉~prop群:#layered-capture-properties
層~化~box~prop群:#layered-box-properties
lbP.~box~sizing:#layered-box-properties-box-sizing
lbP.内容~box:#layered-box-properties-content-box
lbP.~padding~box:#layered-box-properties-padding-box
層~化~捕捉~style:#layered-capture-style
層~化~捕捉~幾何:#layered-capture-geometry
既定の~group~size:#default-group-size
入子な~group変形を調整する:#adjust-the-nested-group-transform

	●用語（level 1

~level 1:#biblio-css-view-transitions-1
要素:~CSSVT#_element
	要素:~CSSDISP#elements
	要素:~CSS2J#element

~view遷移~tree:~CSSVT#view-transition-tree
~view遷移を作動化する:~CSSVT#activate-view-transition
doc.作動中な~view遷移:~CSSVT#document-active-view-transition
doc.~view遷移~用の描画を抑止するか:~CSSVT#document-rendering-suppression-for-view-transitions
~snapshot包含塊:~CSSVT#snapshot-containing-block
捕捉された要素:~CSSVT#captured-element
有名~view遷移~疑似要素:~CSSVT#named-view-transition-pseudo-elements
~view遷移:~CSSVT#view-transitions
~view遷移~名:~CSSVT#view-transition-name
旧-状態を捕捉する:~CSSVT#capture-the-old-state
	旧-状態を捕捉する:~CSSVT#capture-old-state-algorithm
新-状態を捕捉する:~CSSVT#capture-the-new-state
	新-状態を捕捉する:~CSSVT#capture-new-state-algorithm
遷移~疑似要素たちを設定しておく:~CSSVT#setup-transition-pseudo-elements
	遷移~疑似要素たちを設定しておく:~CSSVT#setup-transition-pseudo-elements-algorithm
疑似要素~styleを更新する:~CSSVT#update-pseudo-element-styles
	疑似要素~styleを更新する:~CSSVT#style-transition-pseudo-elements-algorithm
画像を捕捉する:~CSSVT#capture-the-image
~view遷移を設定しておく:~CSSVT#setup-view-transition
~view遷移を飛ばす:~CSSVT#skip-the-view-transition
~view遷移の~page可視性~変化-時の手続き:~CSSVT#view-transition-page-visibility-change-steps
文書~視野な~view遷移~名:~CSSVT#document-scoped-view-transition-name

vT.初期~snapshot包含塊~size:~CSSVT#viewtransition-initial-snapshot-containing-block-size
vT.有名~要素~群:~CSSVT#viewtransition-named-elements
処理待ち遷移~演算を遂行する:~CSSVT#perform-pending-transition-operations
vT.相:~CSSVT#viewtransition-phase
vT.旧-状態~捕捉-時の処理n:~CSSVT#viewtransition-process-old-state-captured
vT.更新~callback済み時の~promise:~CSSVT#viewtransition-update-callback-done-promise
vT.更新~callback:~CSSVT#viewtransition-update-callback

cE.旧-変形:~CSSVT#captured-element-old-transform
cE.旧-横幅:~CSSVT#captured-element-old-width
cE.旧-縦幅:~CSSVT#captured-element-old-height
cE.~group~style規則:~CSSVT#captured-element-group-styles-rule

i.捕捉-待ち:~CSSVT#_pending-capture
i.済み:~CSSVT#_done
i.更新~callbackは~call済み:~CSSVT#_update-callback-called

	●用語（CSS

~cascaded値:~CASCADE#cascaded-value
算出d値:~CASCADE#computed-value
使用~値:~CASCADE#used-value
詳細度:~SELECTORS4#specificity
選択子:~SELECTORS4#selector
~class選択子:~SELECTORS4#class-selector
全称~選択子:~SELECTORS4#universal-selector
型~選択子:~SELECTORS4#type-selector
	https://drafts.csswg.org/selectors-3/#x

条件付き~group規則:~CSSCOND#conditional-group-rule

~tree視野な名前:~CSSSCOPING#css-tree-scoped-name
平坦~tree:~CSSSCOPING#flat-tree

~border~box:~CSSBOX#border-box
~padding~box:~CSSBOX#padding-box
内容~box:~CSSBOX#content-box
~padding辺:~CSSBOX#padding-edge

恒等~変形-関数:~TRANSFORM#identity-transform-function

生来な寸法:~CSSIMAGE#natural-dimensions

内容:~CSSCONTAIN#element-contents
封込め:~CSSCONTAIN#containment

相対~位置決め:~CSSPOS#relative-position

	●用語（他
連結する:~INFRA#string-concatenate
実装定義:~INFRA#implementation-defined
~list:~INFRA#list
付加する:~INFRA#list-append
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
~cloneする:~INFRA#list-clone
	~IN:~INFRA#list-contain
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
有順序~map:~INFRA#ordered-map
map.~key群:~INFRA#map-getting-the-keys
map.~cloneする:~INFRA#map-clone
~tuple:~INFRA#tuple

取得子~手続き:~WEBIDL#getter-steps
~method手続き:~WEBIDL#method-steps
新たな~obj:~WEBIDLjs#new
~promiseを解決する:~WEBIDLjs#resolve

文書:~DOM4#concept-document
~node文書:~DOM4#concept-node-document
根:~DOM4#concept-tree-root
文書~要素:~DOM4#document-element
先祖:~DOM4#concept-tree-ancestor
doc.生成元:~DOM4#concept-document-origin
~class群:~DOM4#concept-class
~ID:~DOM4#concept-id

並列的:~HTMLINFRA#in-parallel

doc.非同一-生成元~redirectを介して作成されたか:~HTMLdom#was-created-via-cross-origin-redirects

doc.可視性~状態:~HTMLinteraction#visibility-state

同一-生成元:~ORIGIN#same-origin
生成元:~ORIGIN#concept-origin

全部的に作動中:~HTMLds#fully-active
~navigable:~HTMLds#navigable
nav.作動中な~window:~HTMLds#nav-window

cnC.更新のみか:~HTMLnav#changing-nav-continuation-update-only
~BF~cache:~HTMLnav#_bf-cache
作動化し直され:~HTMLnav#reactivate-a-document
露呈され:~HTMLnav#reveal
~naviに対する利用者-関与i:~HTMLnav#user-navigation-involvement
i.~browser~UI:~HTMLnav#uni-browser-ui
doc.露呈されたか:~HTMLnav#has-been-revealed
最近の~entry:~HTMLnav#latest-entry

結付けられた文書:~WINDOW#concept-document-window

描画~機会:~WAPI#rendering-opportunity
~task:~WAPI#concept-task
大域~taskを~queueする:~WAPI#queue-a-global-task
関連な大域~obj:~WAPI#concept-relevant-global
関連な~realm:~WAPI#concept-relevant-realm
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability

行列:~GEOMETRY#matrix
乗算する:~GEOMETRY#multiply

所要時間:~HRTIME#dfn-duration

●●words_table1
BQん:`
noneC:none
●●words_table

	●遷移／animation
新-:new:~
旧-:old:~
相:phase::~::フェーズ
捕捉-:capture::~
捕捉:capture::~
滑らか:smooth:~
cross-fade::::クロスフェード
	~cross-fade:crossfade
unload:
切替わる:swapされる:切り替わる
	~view遷移:view-transition
	内へ来る:inbound
	外へ出る:outbound
	外へ出る~view遷移~用の:exiting
	内へ来る~view遷移~用の:entering

	●layout／幾何
矩形:rectangle:~
幾何:geometry:~
並進-:translate::~

	●塗り／効果
塗られ:paintされ:~
装飾:decoration::~
切取り:clipping::切り取り
切取られ:clipされ::切り取られ
	切取られたもの:clip
	その部分:the clipping
raster::::ラスター
	~raster化:rasterize
gradient:

	●UI／呈示
明滅:flash:~
露呈-:reveal:露わに
bookmark::::ブックマーク
	~URL~bar:URL address bar
打込んだ:typeした:打ち込んだ
	%thumbnail:thumbnail
非可視:hidden:~
	非可視なとき:when hiding
滑らす:slideする:~
drag::::ドラッグ
目障り:jarring:~
見かけ:look:~
表情豊か:expressive:~

	利用者~体験:UX
	示す:show
	押す:press
	“戻る”:back
	履歴を前後へ辿る:back/forward
	感じられ:feel

	●CSS
CSSOM:
For:for:用途
詳細度:specificity::~
全称:universal:~
cascaded::::カスケード
視野な:scopedな::~
keyframe:
	~keyframe群:keyframes
生来:natural::~
封込め:containment::封じ込め

	~style法:styling

	●処理
lifecycle:
時間切れ:timeout::~
続行-:proceed:~
処理待ち:pending:~
為され:makeされ:~
params::::パラメタ群
安定:stable:~
	安定~化:stabilize
適格:eligible:~
	適格~性:eligibility
片付ける:clean-upする:~
	片付ける:cleanup
	片付けるため:cleaning up
復旧-:restore:~
修繕:fixup:~
修繕-:fix up:~
適時:timely:~
連結-:concatenate::~

	直前:right before
	直前に:currently
	いつでも:At any given time
	順に経る:goes through
	経る:has
	以降:From this point forward
	渡した／渡す:pass
	~~処理され:seen
	同時に:simultaneously
	全体を通して:throughout the entire course of
	その場を占める:take place
	間際の:last minute
	直前:right before
	まるごと:altogether
	時点:moment
	設定しておく:setup
	具現化を阻む:render-blocking
	具現化を阻んで:render-blocking
	~~最新:up to date
	見つけられ:seen

	●変数
	%解決-済み規則:resolvedRule
	%~view遷移:viewTransition
	%外へ出る遷移:outboundTransition
	ときが来た:it’s time to
	再-作動化:reactivation
	-:accepting
	設定-法:setting up
	%~navi種別:navigationType
	%~browser~UIによる~naviか:isBrowserUINavigation
	%旧-文書:oldDocument
	%新-文書:newDocument
	%更新~callback:updateCallback
	%文書:document
	%~view遷移~params:viewTransitionParams
	%内へ来る~view遷移~params:inboundViewTransitionParams
	%~naviで続行する手続き:proceedWithNavigation
	%飛ばされる前の遷移:preSkippedTransition
	%規則からの遷移~型~群:~transitionTypesFromRule
	%~token:-
	%変形:transform
	%先祖:nearestAncestorWithContain
	%先祖:-
	%捕捉:capturedElement
	-:capturedElement
	%捕捉された要素:capturedElement
	%遷移~名:transitionName
	%遷移:transition
	%包含ng~group名:containingGroupName
	%~group容器~要素:groupContainerElement
	%親~group:parentGroup
	%要素:element
	%算出d値:computed
	%算出d~group:computedGroup
	%~ID:-
	-:ancestorGroup
	%~style:-
	%~style群:styles
	%容器~矩形:containerRect
	-:propertiesToCapture
	%親~変形:parentTransform
	%~border~box横幅:borderBoxWidth
	%~border~box縦幅:borderBoxHeight
	%~box~prop群:boxProperties
	%横幅:width
	%縦幅:height
	%旧-内容~横幅:oldContentWidth
	%旧-内容~縦幅:oldContentHeight
	%新-内容~横幅:newContentWidth
	%新-内容~縦幅:newContentHeight
	%左端:left
	%上端:top
	-:keyframesName

	●保安
脅威:threat:~
潜在的:potential:~
提起-:raise:~
安全性:safety:~
軽微:minor:~

	第三者-主体:3rd-party
	生じさせ:causing
	その場を占めて:taken place
	事実:fact
	ぼやかす:obfuscate
	これまで:so far

	●仕様
opt-in:
opt-out:
monkey:
patch::::パッチ
	~monkey~patch:monkey-patch
保つ:keepする:~
保たれ:keepされ:~
併合-:merge:~
責務:responsibility:~
	責務〜ある:responsible
多彩:rich:~
流儀:fashion:~
冗漫:verbose:~
普通は:ordinaryには:~
間違った:wrongな:~
無視r:disregard:無視することに
成行き:outcome:成り行き

	意図されない:unintended
	現時点では:at this point
	まずは:to begin with
	関わる:around
	^en:learn
	おかげで:thank
	書かれ:written
	熟した:graduate
	選んだ:chosen
	選ぶ:chooseする
	特定に:specifically
	~~便利:handy
	ようにするため:to make sure
	併せて:alongside
	はず:should be
	見られるとおり／に従って／倣い:as per
	勧める:advised
	足る:sufficient
	~prop:CSS property
	^en:mismatch
	まだこれから:TBD
	長々しく:tedious
	たいていは:mostly
	やめた:stop
	初期~仕様:Initial spec
	初期~仕様:First pass

	●言い換え
	文書$:Document
	要素$:Element
	~BF~cache:BFCache
	互いの~page間の~link:link from page 1 to or from page 2
	`遷移を飛ばす^i:`skip transition^l
	手続き %手続き に代えて，次を遂行する:Prepend a step at the beginning of
	^e:iframe
	^e:script
	^e:style
	^e:HTMLLinkElement
	`~view遷移^cite:View Transitions
	~level 1$:previously
	~level 1$:L1
	~~本当は:in fact
	利用し過ぎる:overusing
	空白:white space
	真っ先に挙がる:most prominent
	ある先祖:ancestor chain
	新たな:In addition to the existing values
	次の~CSS:the next string
	の一覧:table of

	●未分類
選択的:selective::~
step:
set:
側:side:~
	側:-side
BF:
横取-:intercept:横取り
実数:number:~
為す:makeする:~
3D:
変形-:transform::~
変形:transform::~
恒等:identity::~
行列:matrix::~
逆-:inverse::~
	逆-行列:inverse matrix
包含ng:containing::包含
存続期間:lifetime:~
最近の:latest:~
最終-:final:~

	現れる:appearする
	文書:Document
	残りの:remaining
	ある種の:certain
	より多く:more
	~~設置-:put
	来る:come
	~~地点:location
	後戻りする:back
	以外:apart from
	一箇所で:once
	全体:whole
	この時点で:now
	より大きい:greater than
	十分:enough
	失われ:lose
	崩れる:broken
	伴に:in conjuction with
	最も近い:nearest
	~EACH 〜 近いものから順に:nearest
	親を〜に~~改める:reparent
	まるごと:entirety
	~~特定する:address


●●ref_normative

[CSS-BACKGROUNDS-3]
    Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-BORDERS-4]
    ＜CSS Borders and Box Decorations Module Level 4＞. Editor's Draft. URL: https://drafts.csswg.org/css-borders-4/
[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-COLOR-4]
    Chris Lilley; Tab Atkins Jr.; Lea Verou. ＜CSS Color Module Level 4＞. URL: https://drafts.csswg.org/css-color-4/
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. ＜CSS Containment Module Level 2＞. URL: https://drafts.csswg.org/css-contain-2/
[CSS-IMAGES-3]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. ＜CSS Images Module Level 3＞. URL: https://drafts.csswg.org/css-images-3/
[CSS-MASKING-1]
    Dirk Schulze; Brian Birtles; Tab Atkins Jr.. ＜CSS Masking Module Level 1＞. URL: https://drafts.fxtf.org/css-masking-1/
[CSS-OVERFLOW-3]
    Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. URL: https://drafts.csswg.org/css-scoping/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. URL: https://drafts.csswg.org/css-transforms/
[CSS-TRANSFORMS-2]
    Tab Atkins Jr.; et al. ＜CSS Transforms Module Level 2＞. URL: https://drafts.csswg.org/css-transforms-2/
[CSS-UI-4]
    Florian Rivoal. ＜CSS Basic User Interface Module Level 4＞. URL: https://drafts.csswg.org/css-ui-4/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-VIEW-TRANSITIONS-1]
    Tab Atkins Jr.; Jake Archibald; Khushal Sagar. ＜CSS View Transitions Module Level 1＞. URL: https://drafts.csswg.org/css-view-transitions-1/
[CSS22]
    Bert Bos. ＜Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[FILTER-EFFECTS-1]
    Dirk Schulze; Dean Jackson. ＜Filter Effects Module Level 1＞. URL: https://drafts.fxtf.org/filter-effects-1/
[GEOMETRY-1]
    Simon Pieters; Chris Harrelson. ＜Geometry Interfaces Module Level 1＞. URL: https://drafts.fxtf.org/geometry/
[HR-TIME-3]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-3]
    Tantek Çelik; et al. ＜Selectors Level 3＞. URL: https://drafts.csswg.org/selectors-3/
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-CONDITIONAL-3]
    Chris Lilley; David Baron; Elika Etemad. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/
[CSS-POSITION-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 3＞. URL: https://drafts.csswg.org/css-position-3/
[CSS-SHADOW-PARTS-1]
    Tab Atkins Jr.; Fergal Daly. ＜CSS Shadow Parts＞. URL: https://drafts.csswg.org/css-shadow-parts/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS View Transitions Module Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-view-transitions-2/
公表履歴
	https://www.w3.org/standards/history/css-view-transitions-2/
フィードバック
	https://github.com/w3c/csswg-drafts/labels/css-view-transitions-2
編集
	Noam Rosenthal (Google)
	Khushal Sagar (Google)
	Vladimir Levin (Google)
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-view-transitions-2/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-view-transitions-2
</script>

</head>
<body>

<header>
	<hgroup>
<h1>CSS ビュー遷移 — CSS View Transitions Module Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この~moduleは、
`~view遷移^cite ~APIが非同一-文書な~naviと伴にどう働くかを定義する。
◎
This module defines how the View Transition API works with cross-document navigations.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
`~view遷移^cite は、
`~level 1$ にて指定されるとおり，［
`文書$の視覚的な状態どうしで~animateされる遷移を作成する
］ことを開発者に許容する特能である。
◎
View Transitions, as specified in [css-view-transitions-1], is a feature that allows developers to create animated transitions between visual states of the document.
</p>

<p>
この~level 2 は、
次を追加することにより，`~level 1$ を拡張する：
◎
Level 2 extends that specification, by＼
</p>
<ul>
	<li>
次を可能化するために必要yな~APIと~lifecycle
⇒
同一-生成元に属する非同一-文書な~naviにまたがる遷移
◎
adding the necessary API and lifecycle to enable transitions across a same-origin cross-document navigation,＼
</li>
	<li>
次が もっと容易になるようにする，少数のもの
⇒
作者が，~pageに より多彩な~view遷移を伴わせる
◎
as well as a few additions that make it easier to author pages with richer view transitions.
</li>
</ul>

<p>
~level 2 は、
次に挙げるものを定義する：
◎
Level 2 defines the following:
</p>
<ul>
	<li>
`§ 非同一-文書な~view遷移＠#cross-document-view-transitions$
⇒
`view-transition$at 規則,
非同一-文書な~view遷移の~lifecycleを可能化する~algoなど。
◎
Cross-document view transitions, including the @view-transition rule and the algorithms that enable the cross-document view transition lifecycle.
</li>
	<li>
`§ 選択的な~view遷移＠#selective-vt$
⇒
~styleを［
`作動中な~view遷移$docの存在に基づいて照合する
］および［
ある種の型を成している作動中な~view遷移に基づいて，より特定に照合する
］ための仕方。
◎
Selective view transitions, a way to match styles based on the existence of an active view transition, and more specifically based on the active view transition being of a certain type.
</li>
	<li>
`§ ~view遷移~疑似要素たちの~styleの共有-法＠#shared-style-with-vt-classes$
⇒
~styleを一箇所で宣言して，それを複数の~view遷移~疑似要素で利用するための仕方。
これは、
`view-transition-class$p ~prop,
`§ 有名~疑似要素に対する追加＠#pseudo-element-class-additions$
も含む。
◎
Sharing styles between view transition pseudo-elements, a way to declare a style once, and use it for multiple view transition pseudo-elements. This includes the view-transition-class property, and additions to named pseudo-elements
</li>
</ul>

	</section>
	<section id="cross-document-view-transitions">
<h2 title="Cross-document view transitions">2. 非同一-文書な~view遷移</h2>

		<section id="cross-doc-overview">
<h3 title="Overview">2.1. 概観</h3>

◎非規範的

			<section id="activating-cross-document-view-transition">
<h4 title="Activation">2.1.1. 作動化</h4>

<p>
同一-文書な~view遷移では、
作者は，~JSを利用して
— `startViewTransition()$m を~callすることにより —
~view遷移を開始する。
非同一-文書な~view遷移において，~view遷移を誘発するものは、
文書から他の文書への~naviである
— ~AND↓ が満たされる限り：
◎
With same-document view transitions, the author starts a view transition using JavaScript, by calling startViewTransition. In cross-document view transition, what triggers a view transition is a navigation between two documents, as long as the following conditions are met:
</p>
<ul>
	<li>
双方の文書は`同一-生成元$である。
◎
Both documents are of the same origin;
</li>
	<li>
当の~pageは、
当の~navi全体を通して可視である。
◎
The page is visible throughout the entire course of the navigation;
</li>
	<li>
当の~naviは、
利用者が［
当の~pageとヤリトリする
（例：~linkを~clickする／~formを提出する）／
`traverse$l する（履歴を前後へ辿る）ために~browser~UIとヤリトリする
］ことにより起動された。
これには、
例えば，~URL~barにより起動される~navi
【言い換えれば、新-文書への~naviは旧-文書とは独立に起動されたとき】
は除外される。
◎
The user initiates the navigation by interacting with the page, e.g. by clicking a link or submitting a form; or by interacting with the browser UI to do a traverse navigation (back/forward). This excludes, for example, navigations initiated by the URL bar;
</li>
	<li>
当の~naviには非同一-生成元な~redirectは生じなかった。
◎
the navigation didn’t include cross-origin redirects; and
</li>
	<li>
両~文書とも、
`view-transition$at 規則を利用して，
非同一-文書な~view遷移を~opt-inした。
◎
both documents opted in to cross-document view transitions, using the @view-transition rule.
</li>
</ul>

<p>
より詳細は、
`§ ~lifecycle＠#lifecycle$
を見よ。
◎
See the lifecycle section for more details.
</p>

			</section>
			<section id="waiting-for-stable-state">
<h4 title="Waiting for the new state to stabilize">2.1.2. 新-状態が安定~化するまでの待機-法</h4>

<p>
同一-文書な~view遷移においては、
作者は，
当の遷移の新-状態が いつ安定~状態になるかを
— `startViewTransition()$m に渡した~callback利用することにより —
指示できる。
非同一-文書な~view遷移は，宣言的なので、
そのような明示的な~promiseは無い。
代わりに，~UAは、［
当の文書がいつ安定~状態に達したか
］を`具現化を阻む仕組み＠~HTMLdom#render-blocking-mechanism$に依拠して裁定する。
この仕方においては、
作者は，当の遷移を次に挙げるときまで
— そこに挙げるものを利用することにより —
遅延できる：
◎
In same-document view transitions, the author can indicate when the new state of the transition is in a stable state by using the callback passed to startViewTransition. Since cross-document view transitions are declarative, there is no such explicit promise. Instead, the user agent relies on the render-blocking mechanism to decide when the document has reached a stable state. In this way, the author can use the blocking attribute, to delay the transition until:
</p>
<ul>
	<li>
期待されるすべての~scriptは、
実行された
⇒
該当する各 `script$e 要素の `blocking$a 属性
◎
All expected scripts are executed, by using the script’s blocking attribute on required scripts.
</li>
	<li>
期待されるすべての~styleは、
実行された
⇒
該当する各 `style$e 要素の `blocking$aL 属性
◎
All expected styles are executed, by using the style or link’s blocking attribute on required styles.
</li>
	<li>
期待されるすべての~HTML要素は、
構文解析器により~~処理された
⇒
`link$e 要素の【 `rel^a 属性~用の~keyword】 `expect$v
◎
All expected HTML elements are seen by the parser, using an expect HTMLLinkElement element.
</li>
</ul>

<p class="note">注記：
具現化を阻む仕組みを利用し過ぎると、
旧-状態が長い時間~凍結され続ける結果，目障りな利用者~体験にもなり得る。
これを避けるためには、［
具現化を阻んでいる要素が適時な方式で可用になる
］ことを確保することを勧める。
◎
Note: overusing the render-blocking mechanism could make it so that the old state remains frozen for a long time, resulting in a jarring user experience. To avoid this, it’s advised to ensure that the render-blocking elements are available in a timely manner.
</p>

<div class="example">
<p>
この例では、
旧-文書の最後の~frameが示されてから，
~AND↓ が満たされるまで~animationは遅延されることになる：
◎
In this example, the last frame of the old document will be shown, and the animation will be delayed, until all the following conditions are met:
</p>

<ul>
	<li>
~stylesheet `style.css^v は適用された
— 新-状態が正しい~styleを有することを確保するため
◎
style.css is applied, to ensure the new state has the correct styles
</li>
	<li>
~script `fixup.js^v は走った
— 当の呈示が，それに基づく修繕に伴って~~最新になることを確保するため。
◎
fixup.js is run, to ensure the presentation is up to date with script-based fixups.
</li>
	<li>
要素 `main-article^v は、
見つけられ, 構文解析された
— 当の遷移を続行する前に，十分な内容が読込まれることを確保するため。
◎
The main-article section is seen and parsed, to ensure enough of the content is loaded before allowing the transition to proceed.
</li>
</ul>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!-- <span class="comment">
次の~stylesheetは、
既定では具現化を阻むことになる：
◎
This will be render-blocking by default
</span> --&gt;
    &lt;link rel="stylesheet" href="style.css"&gt;

    &lt;!-- <span class="comment">
次の~scriptは、
~layoutを修繕する。
それは、
【 `blocking^a 属性により】具現化を阻むものとして~markされ、
その結果，~view遷移が作動化される前に走ることが確保される：
◎
Since this script fixes up the layout, marking it as render blocking will ensure it's run before the view transition is activated
</span> --&gt;
    &lt;script async href="fixup.js" blocking="render"&gt;&lt;/script&gt;

    &lt;!-- <span class="comment">
遷移を作動化する前に，
`main-article^v 要素が見つけられ, 全部的に構文解析されるまで待機するようにする：
◎
Wait until the main-article element is seen and fully parsed before activating the transition
</span> --&gt;
    &lt;link rel="expect" href="#main-article" blocking="render"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;header&gt;...&lt;/header&gt;
    &lt;main&gt;
      &lt;article id="main-article"&gt;...&lt;/article&gt;
    &lt;/main&gt;
    &lt;article id="secondary-article"&gt;...&lt;/article&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

			</section>
			<section id="customizing-cross-document-view-transitions">
<h4 title="Customization">2.1.3. ~custom化</h4>

<p>
`ViewTransition$I ~objは、
~scriptにより遷移を~custom化することを可能化する。
~view遷移の~lifecycle全体にわたって利用される `ViewTransition$I ~objは、
同一-文書な~view遷移~用には `startViewTransition()$m の~callから返された 1 個だけであり，
非同一-文書な~view遷移~用には 2 個
— 旧-文書~内のそれ, 新-文書~内のそれ —
ある。
◎
The ViewTransition object enables customizing the transition in script. Same-document view transitions use a single ViewTransition object returned from the startViewTransition call for the entire lifecycle. Cross-document view transitions have two ViewTransition objects, one in the old document and one in the new document.
</p>

				<section id="old-doc-event">
<h5 title="Handling the view transition in the old document">2.1.3.1. 旧-文書における~view遷移の取扱い</h5>

<p>
`pageswap$et ~eventは、［
文書が~unloadされつつあり，別の文書に切替わる前
］における最後の時点に発火される。
それは、［
~view遷移が その場を占めつつあるかどうかを見出す
］ため，および［
当の~view遷移に対し，［
`types$m を利用して~custom化して，捕捉される要素に対し間際の変更を為す
］か［
必要yなら飛ばす
］］ために利用できる。
`PageSwapEvent$I ~interfaceの `viewTransition$m1 は、
当の~naviが ~view遷移に適格なときには ~NULL 以外になり，
`ViewTransition$I ~objを返す。
その `activation$m は、
~redirect後の~URLの様な，当の~naviについての~~便利な情報を供する~objを返す。
その `finished$m ~promiseは、
当の文書が後で`~BF~cache$から復旧される事例において，
遷移の後に片付けるために利用できる。
◎
The pageswap event is fired at the last moment before a document is about to be unloaded and swapped by another document. It can be used to find out whether a view transition is about to take place, customize it using types, make last minute changes to the captured elements, or skip it if necessary. The PageSwapEvent interface has a viewTransition object, which would be non-null when the navigation is eligible to a view transition, and a activation object, providing handy information about the navigation, like the URL after redirects. The transition’s finished promise can be used for cleaning up after the transition, in case the document is later restored from BFCache.
</p>

				</section>
				<section id="new-doc-event">
<h5 title="Handling the view transition in the new document">2.1.3.2. 新-文書における~view遷移の取扱い</h5>

<p>
`pagereveal$et ~eventは、［
新-文書を成す最初の~frameを呈示する直前
］に発火される。
それは、
`viewTransition$m 属性を~queryすることにより，［
当の~view遷移は依然として妥当であるか否か
］を見出すために利用できる。
同一-文書な~view遷移と類似に、
作者は，この時点で［［
異なる `types$m を選定して，捕捉される要素に対し間際の変更を為す／
当の遷移を~animateするために それが準備済みになる（ `ready$m ~promiseが解決される）まで待機する
］か［
当の遷移をまるごと飛ばす
］ことができる。
◎
The pagereveal event is fired right before presenting the first frame of the new document. It can be used to find out if the view transition is still valid, by querying the viewTransition attribute. Similar to a same-document view transition, the author can now select different types, make last minute changes to the captured elements, wait for the transition to be ready in order to animate it, or skip it altogether.
</p>

				</section>
			</section>
			<section id="lifecycle">
<h4 title="Lifecycle">2.1.4. ~lifecycle</h4>

◎非規範的

<p>
`文書$ %旧-文書 から`文書$ %新-文書 への成功裡な［
非同一-文書な~view遷移
］は、
次に挙げる相を順に経る：
◎
A successful cross-document view transition goes through the following phases:
</p>

<ol>
	<li>
<p>
%旧-文書 においては：
◎
In the old Document:
</p>
		<ol>
			<li>
<p>
利用者は、［
~linkを~clickする／
~formを提出する／
~browserの “戻る” ~buttonを押す
］などにより，~naviを起動する。
◎
The user initiates a navigation, by clicking a link, submitting a form, pressing the browser’s back button, etc.
</p>

<p class="note">注記：
~naviには，~view遷移を誘発しないものもある
— 例：~URL~bar内に新たな~addressを打込んだとき。
◎
Note: some navigations do not trigger a view-transition, e.g. typing a new address in the URL bar.
</p>
			</li>
			<li>
%新-文書 は作動化されるに準備済みになったとき、
`pageswap$et ~event %~event が発火される。
◎
When the new Document is ready to be activated, the pageswap event is fired.
</li>
			<li>
%~event の `viewTransition$m1 属性は、
次が満たされるならば `ViewTransition$I ~obj %遷移 になる
⇒
［
当の~naviは`同一-生成元$である
］~AND［
非同一-生成元な~redirectは無い
］~AND［
%旧-文書 は`非同一-文書な~view遷移を~opt-inした＠#cross-doc-opt-in$
］
◎
If the navigation is same origin, has no cross-origin redirects, and the old Document has opted in to cross-document view transitions, the event’s viewTransition attribute would be a ViewTransition object.
</li>
			<li>
作者は、
今や， %遷移 を~custom化できる
（例：
`types$m を用いて %遷移 にて`作動中な型~群$vTを変異させる／
`skipTransition()$m を用いて %遷移 を まるごと飛ばす）。
◎
The author can now customize the transition, e.g. by mutating its types, or skip it altogether.
</li>
			<li>
%遷移 が飛ばされなかった場合、
%旧-文書 の`状態が捕捉される＠~CSSVT#capture-the-old-state$。
◎
If the ViewTransition is not skipped, the state of the old document is captured.
</li>
			<li>
当の~naviを続行する
— %旧-文書 が~unloadされ，
%新-文書 が今や作動中になる。
◎
The navigation proceeds: the old Document is unloaded, and the new Document is now active.
</li>
		</ol>
	</li>
	<li>
<p>
次に，
%新-文書 においては：
◎
Then, in the new Document:
</p>
		<ol>
			<li>
%新-文書 が最初の`描画~機会$用に準備済みになったとき、
%新-文書 に向けて `pagereveal$et ~event %~event が発火される。

◎
When the new Document is ready for its first rendering opportunity, an event named pagereveal is fired on the new Document, with a viewTransition attribute.
</li>
			<li>
%~event の `viewTransition$m 属性が返す `ViewTransition$I ~obj %遷移 の `updateCallbackDone$m ~promiseは、
すでに解決-済みであり，
その`捕捉された要素$は %旧-文書 から拡充される。
◎
This ViewTransition's updateCallbackDone promise is already resolved, and its captured elements are populated from the old Document.
</li>
			<li>
ここでは、
作者には， %遷移 を~custom化する別の機会が与えられる
（例：
`types$m により %遷移 にて`作動中な型~群$vTを変異させる／
`skipTransition()$m により %遷移 を まるごと飛ばす）。
◎
This is another opportunity for the author to customize the transition, e.g. by mutating its types, or skip it altogether.
</li>
			<li>
%遷移 の “新-” 状態として
%新-文書 の`状態が捕捉される＠~CSSVT#capture-the-new-state$。
◎
The state of the new document is captured as the "new" state of the transition.
</li>
			<li>
以降， %遷移 は、
同一-文書な遷移と類似な流儀で
— `~view遷移を作動化する$手続きに従って —
継続する。
◎
From this point forward, the transition continues in a similar fashion to a same-document transition, as per activate view transition.
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
		<section id="cross-doc-examples">
<h3 title="Examples">2.2. 例</h3>

<div class="example">
<p>
`~level 1$ の `§ 例＠~CSSVT#examples$ における最初の例と同じ~cross-fadeを生成するが、
複数の文書にまたがる【 “非同一-文書である” 】
— ~JSは必要ない。
◎
To generate the same cross-fade as in the first example CSS View Transitions 1 § 1.6 Examples, but across documents, we don’t need JavaScript.
</p>

<p>
代わりに，~page 1, ~page 2 両者において
~naviに対し~view遷移を誘発することを~opt-inする：
◎
Instead, we opt in to triggering view-transitions on navigation in both page 1 and page 2:
</p>

<pre class="lang-css">
/* <span class="comment">
両~文書において：
◎
in both documents:
</span> */
@view-transition {
  navigation: auto;
}
</pre>

<p>
互いの~page間の~linkは、
例 1 による~cross-fade遷移を生成する。
例 2, 3, 4 による効果を達成するためには、
単純に両~文書~内に疑似要素~用の~CSSを~~設置する。
◎
A link from page 1 to or from page 2 would generate a crossfade transition for example 1. To achieve the effect examples 2, 3 &amp; 4, simply put the CSS for the pseudo-elements in both documents.
</p>
</div>

<div class="example">
<p>
`view-transition$at 規則は、
媒体~queryと一緒に利用できることに注意。
例えば，次は、
~screenの横幅が 【`600px^v 】より大きいときに限り遷移を遂行することになる：
◎
Note that the @view-transition rule can be used together with media queries. For example, this would only perform the transition when the screen width is greater than:
</p>

<pre class="lang-css">
@view-transition {
  navigation: auto;
}

@media (max-width: 600px) {
  navigation: none;
}
</pre>
</div>

<div class="example">
<p>
`例 5＠~CSSVT#_example-5$
の効果を達成するためには、
次を行う必要がある：
◎
To achieve the effect in example 5, we have to do several things:
</p>
<ul>
	<li>
両~pageにおいて，~naviにより誘発される~view遷移を~opt-inする。
◎
Opt-in to navigation-triggered view-transitions in both pages.
</li>
	<li>
新-文書に~click~~地点を渡す
— 例： `sessionStorage$m を介して。
◎
Pass the click location to the new document, e.g. via sessionStorage.
</li>
	<li>
`pagereveal$et を利用して，
新-文書~内の `ViewTransition$I ~objを横取する。
◎
Intercept the ViewTransition object in the new document, using the pagereveal event.
</li>
</ul>

<p>
両~page内には次がある：
◎
In both pages:
</p>

<pre class="lang-css">
@view-transition {
  navigation: auto;
}
</pre>

<p>
旧-~page内には次がある：
◎
In the old page:
</p>

<pre class="lang-js">
addEventListener('click', %event =&gt; {
  sessionStorage.setItem("lastClickX", %event.clientX);
  sessionStorage.setItem("lastClickY", %event.clientY);
});
</pre>

<p>
新-~page内には次がある：
◎
In the new page:
</p>

<pre class="lang-js">
/* <span class="comment">
これは、
初期~読込nと再-作動化どちらに対しても，
`~BF~cache$から走らすことになろう。
◎
This would run both on initial load and on reactivation from BFCache.
</span> */
addEventListener("pagereveal", async %event =&gt; {
  if (!%event.viewTransition)
    return;

  const %x = sessionStorage.getItem("lastClickX") ?? window.innerWidth / 2;
  const %y = sessionStorage.getItem("lastClickY") ?? window.innerHeight / 2;

  const %endRadius = Math.hypot(
    Math.max(%x, window.innerWidth - %x),
    Math.max(%y, window.innerHeight - %y)
  );

  await event.viewTransition.ready;

  /* <span class="comment">
新-文書の~viewを~animateする
◎
Animate the new document's view
</span> */
  document.documentElement.animate(
    {
      clipPath: [
        ~BQんcircle(0 at ${%x}px ${%y}px)~BQん,
        ~BQんcircle(${%endRadius}px at ${%x}px ${%y}px)~BQん,
      ],
    },
    {
      duration: 500,
      easing: 'ease-in',
      pseudoElement: '::view-transition-new(%root)'
    }
  );
})
</pre>
</div>

<div class="example">
<p>
［
~naviの~propたちに基づいて，どの要素が捕捉されるか
］および［
ある種の画像が読込まれるかどうか
］を選ぶためには：
◎
To choose which elements are captured based on properties of the navigation, and whether certain images are loaded:
</p>

<p>
旧-~pageにおいては：
◎
In the old page:
</p>

<pre class="lang-js">
window.addEventListener("pageswap", %event =&gt; {
  /* <span class="comment">
例えば［
当の~pageは非可視であった／非同一-文書な~naviである
］とき：
◎
For example, the page was hidden, or the navigation is cross-document.
</span> */
  if (!%event.viewTransition)
    return;

  /* <span class="comment">
履歴を前後へ辿る~navi用には、
~view遷移は求まれない場合：
◎
If you don't want view transition for back/forward navigations...
</span> */
  if (%event.activation.navigationType === "traverse") {
    %event.viewTransition.skipTransition();
  }

  const %newURL = new URL(%event.activation.entry.url);
  if (%newURL.pathname === "/details" &amp;&amp; %thumbnail.complete) {
    %thumbnail.classList.add("transition-to-hero");

    /* <span class="comment">
~pageが`~BF~cache$から復旧された場合には、
状態を片付ける：
◎
This will cleanup the state if the page is restored from BFCache.
</span> */
    %event.viewTransition.finished.then(() =&gt; {
      %thumbnail.classList.remove("transition-to-hero");
    });
  }

});
</pre>

<p>
新-~pageにおいては：
◎
In the new page:
</p>

<pre class="lang-js">
window.addEventListener("pagereveal", %event =&gt; {
  /* <span class="comment">
例えば［
~pageは非可視であった／
非同一-文書な~naviである／
旧-文書における遷移は飛ばされた
］とき：
◎
For example, the page was hidden, the navigation is cross-document, or the transition was skipped in the old document.
</span> */
  if (!%event.viewTransition)
    return;

  const %oldURL = new URL(navigation.activation.from.url);
  if (%newURL.pathname === "/list") {
    %event.viewTransition.types.add("coming-from-list");

    /* <span class="comment">
当の~view遷移が完遂するまで， %thumbnail を示す：
◎
This will show the thumbnail until the view transition is finished.
</span> */
    if (!%hero.complete) {
      setToThumbnail(%hero);
      %event.viewTransition.finished.then(() =&gt; {
        setToFullResolution(%hero);
      })
    }
  }
});
</pre>
</div>

		</section>
		<section id="cross-doc-opt-in">
<h3 title="Opting in to cross-document view transitions">2.3. 非同一-文書な~view遷移の~opt-in法</h3>

			<section id="view-transition-rule">
<h4 title="The @view-transition rule">2.3.1. `view-transition^at 規則</h4>

<p>
`view-transition@at
~at-規則は、
次を指示するために利用される
⇒
非同一-文書~naviは、
`ViewTransition$I を設定しておいて作動化するベキである
【順に，`非同一-文書な~view遷移を設定しておく$, `~view遷移を作動化する$】
◎
The @view-transition rule is used by a document to indicate that cross-document navigations should setup and activate a ViewTransition.
</p>

<p>
`view-transition$at 規則の構文は：
◎
The @view-transition rule has the following syntax:
</p>

<pre class="prod">
@view-transition {
  `declaration-list$t
}
</pre>

<p>
`view-transition$at 規則は、
次に挙げる記述子を受容する
⇒＃
`navigation$d,
`types$d
◎
The @view-transition rule accepts the navigation and types descriptors.
</p>

<p class="note">注記：
既定の挙動に倣い、
`view-transition$at 規則は，`条件付き~group規則$
— `media$at や `supports$at など —
の内側に入子にできる。
◎
Note: as per default behavior, the @view-transition rule can be nested inside a conditional group rule such as @media or @supports.
</p>

<p>
`文書$ %文書 用の `view-transition$at 規則が変化したときは、
~UAは，次を遂行するとする
⇒
`外へ出る遷移~用の~opt-in状態を更新する$( %文書 )
◎
When the @view-transition rule changes for Document document, the user agent must update the opt-in state for outbound transitions given document.
</p>

<p class="note">注記：
これ【どれ？】は、
真偽値をとる何かに~cacheする必要がある
— 結果【何の？】は、
~navigateするとき，`並列的$に読取る必要があるので。
◎
Note: this needs to be cached in the boolean because the result needs to be read in parallel, when navigating.
</p>

			</section>
			<section id="view-transition-navigation-descriptor">
<h4 title="The navigation descriptor">2.3.2. `navigation^d 記述子</h4>

◎述 `navigation@d
◎用 `view-transition$at
◎値 `auto$vN | `none$vN
◎初 `none$vN
◎表終

<p>
`navigation$d 記述子は、［
ある種の種別の~naviを遂行する
］ときに［
ある~view遷移を自動的に開始する
］ことを~opt-inする。
それは、［
旧-文書, 新-文書
］どちらにも在ることが要求される【！Must be present】。
◎
The 'navigation' descriptor opts in to automatically starting a view transition when performing a navigation of a certain type. Must be present on both the old and new document.
</p>

<dl>
	<dt>`none@vN</dt>
	<dd>
遷移は無い。
◎
There will be no transition.
</dd>

	<dt>`auto@vN</dt>
	<dd>
<p>
遷移は、
当の~naviが ~AND↓ を満たす場合には可能化されることになる：
</p>
		<ul>
			<li>
同一-生成元である
</li>
			<li>
非同一-生成元な~redirectを伴わない
</li>
			<li>
<p>
~OR↓
</p>
				<ul>
					<li>
その `NavigationType$I ~EQ `traverse$l
</li>
					<li>
［
その `NavigationType$I ~IN { `push$l, `replace$l }
］~AND［
`~naviに対する利用者-関与i$ ~NEQ `~browser~UI$i
］
</li>
				</ul>

<p class="trans-note">【
`NavigationType^I は、
`window.navigation＠~HTMLnavAPI#dom-window-navigation$m の［
`transition＠~HTMLnavAPI#dom-navigation-transition$m,
`activation＠~HTMLnavAPI#dom-navigation-activation$m
］どちらかの `navigationType^m を指すと思われるが、
どちらかは，はっきりしない（どちらでも同じかもしれない）。
】</p>

			</li>
		</ul>
◎
The transition will be enabled if the navigation is same-origin, without cross-origin redirects, and whose NavigationType is
• traverse, or
• push or replace, with user navigation involvement not equal to "browser UI".
</dd>
	<dd class="note">注記：
`auto$vN から除外される~naviは、
例えば，次を介して~navigateすることである
⇒＃
~URL~bar／
~bookmarkを~clickすること
利用者や~scriptが起動した `reload$l
◎
Note: Navigations excluded from auto are for example, navigating via the URL address bar or clicking a bookmark, as well as any form of user or script initiated reload.
</dd>
</dl>

<div>
<p>
`view-transition$at ~at-規則は、
~CSSの前方-互換な構文解析~要件に適合する
— この規則を解さない適合t構文解析器は、
~errorを伴うことなく，それを無視することになる。
~UAは、［
この規則を成す記述子のうち，次のいずれかに該当するもの
］をまるごと無視するモノトスル
— そのような記述子は、
当の~at-規則を無効にすることはない：
</p>
<ul>
	<li>
自身が［
認識しない／実装していない
］
</li>
	<li>
その値は、
この仕様
— その将来の~versionも含む —
にて与えられる文法に合致しない
</li>
</ul>
◎
This at-rule conforms with the forward-compatible parsing requirement of CSS; conformant parsers that don’t understand these rules will ignore them without error. Any descriptors that are not recognized or implemented by a given user agent, or whose value does not match the grammars given here or in a future version of this specification, must be ignored in their entirety; they do not make the @view-transition rule invalid.
</div>

			</section>
			<section id="cssom">
<h4 title="Accessing the @view-transition rule using CSSOM">2.3.3. ~CSSOMによる `view-transition$at 規則への~access法</h4>

<p>
`CSSViewTransitionRule$I は、
ある `view-transition$at 規則を表現する。
◎
The CSSViewTransitionRule represents a @view-transition rule.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSViewTransitionRule@I : `CSSRule$I {
  readonly attribute `CSSOMString$ `navigation$m;
  [`SameObject$] readonly attribute `FrozenArray$&lt;`CSSOMString$&gt; `types$m1;
};
</pre>

<div class="algo">
`navigation@m
取得子~手続きは
⇒
~RET ［
コレが表現する `view-transition$at 規則に `navigation$d 記述子は存在するならば，その値／
~ELSE_ 空~文字列
］
◎
The navigation getter step is to return the value of the corresponding navigation descriptor if one exists, otherwise the empty string.
</div>

<div class="algo">
`types@m1
取得子~手続きは
⇒
~RET ［
コレが表現する `view-transition$at 規則に `types$d 記述子は存在するならば，その値／
~ELSE_ 空な`~list$
］
◎
The types getter steps is to return the value of the corresponding types descriptor if one exists, otherwise an empty list.
</div>

			</section>
		</section>
	</section>
	<section id="selective-vt">
<h2 title="Selective view transitions">3. 選択的な~view遷移</h2>

		<section id="selective-vt-overview">
<h3 title="Overview">3.1. 概観</h3>

◎非規範的

<p>
~page用の~view遷移が 1 つしかない単純な局面においては、
関与している各~要素に `view-transition-name$p ~propを設定することで足るはずである。
しかしながら，より複階的な局面においては、
作者は，様々な~view遷移を宣言して，うち 1 つだけを同時に走らすよう求めることもあろう。
例えば、
~navi~barを~clickしたときは，~page全体を滑らす一方で、
~listを成すいずれかの~itemが~dragされたときは，~listを~sortするなど。
◎
For simple pages, with a single view transition, setting the view-transition-name property on participating elements should be sufficient. However, in more complex scenarios, the author might want to declare various view transitions, and only run one of them simultaneously. For example, sliding the whole page when clicking on the navigation bar, and sorting a list when one of its items is dragged.
</p>

<p>
［
各~view遷移が必要なものに限り捕捉すること
］および［
異なる遷移どうしが互いに干渉しない
］ようにするため、
この仕様は，`作動中な型~群$vTの概念を
— ［
`active-view-transition$ps, `active-view-transition-type()$ps
］疑似類と併せて —
導入する。
◎
To make sure each view transition only captures what it needs to, and different transitions don’t interfere with each other, this spec introduces the concept of active types, alongside the :active-view-transition and :active-view-transition-type() pseudo-classes.
</p>

<p>
［
`active-view-transition$ps,
`active-view-transition-type()$ps
］は，どちらも［
`文書$にて`作動中な~view遷移$doc %遷移 ~NEQ ~NULL
］のときに限り，`文書$の`文書~要素$に合致するが、
`active-view-transition-type()$ps が合致するのは，さらに［
その引数を成す【いずれかの】型が %遷移 にて`作動中な型~群$vTに合致する場合
］に限られる。
◎
:active-view-transition matches the document element when it has an active view transition,＼
and :active-view-transition-type() matches the document element if the types in the selectors match the active view transition's active types.
</p>

<p>
`ViewTransition$I にて`作動中な型~群$vTを拡充するためには、
次に挙げる仕方がある：
◎
The ViewTransition's active types are populated in one of the following ways:
</p>
<ol>
	<li>
`startViewTransition()$m
に対する引数の一部【 `StartViewTransitionOptions$I の `types$mb 】として渡す。
◎
Passed as part of the arguments to startViewTransition(callbackOptions)
</li>
	<li>
いつでも、
当の遷移の `types$m を利用して変異する。
◎
Mutated at any time, using the transition’s types
</li>
	<li>
非同一-文書な~view遷移~用には、
`types$d 記述子を利用して宣言する。
◎
Declared for a cross-document view transition, using the types descriptor.
</li>
</ol>

		</section>
		<section id="active-view-transition-pseudo-examples">
<h3 title="Examples">3.2. 例</h3>

<div class="example">
<p>
例えば、
開発者は，次の方式で遷移を開始するかもしれない：
◎
For example, the developer might start a transition in the following manner:
</p>

<pre class="lang-js">
document.startViewTransition({update: %updateTheDOMSomehow, types: ["slide-in", "reverse"]});
</pre>

<p>
これは、
次に挙げる選択子をいずれも作動化することになる：
◎

This will activate any of the following selectors:
</p>

<pre class="lang-css">
:root:active-view-transition-type(slide-in) {}
:root:active-view-transition-type(reverse) {}
:root:active-view-transition-type(slide-in, reverse) {}
:root:active-view-transition-type(slide-in, something-else) {}
:root:active-view-transition {}
</pre>

<p>
一方で，遷移~型を供することなく遷移を開始した場合、
`active-view-transition^ps に限り，
作動化することになる：
◎
While starting a transition without providing transition types, would only activate ':active-view-transition'':
</p>

<pre class="lang-js">
document.startViewTransition(%updateTheDOMSomehow);
/* <span class="comment">
または
◎
or
</span> */
document.startViewTransition({update: %updateTheDOMSomehow});
</pre>

<pre class="lang-css">
/* <span class="comment">
次に挙げるものは、
作動中になる：
◎
This would be active
</span> */
:root { }
:root:active-view-transition {}

/* <span class="comment">
次に挙げるものは、
作動中にならない：

◎
This would not be active
</span> */
:root:active-view-transition-type(slide-in) {}
:root:active-view-transition-type(any-type-at-all-except-star) {}
</pre>
</div>

		</section>
		<section id="pseudo-classes-for-selective-vt">
<h3 title="Selecting based on the active view transition">3.3. 作動中な~view遷移に基づく選定-法</h3>

			<section id="the-active-view-transition-pseudo">
<h4 title="The :active-view-transition pseudo-class">3.3.1. `active-view-transition^ps 疑似類</h4>

<p>
`active-view-transition@ps
疑似類は、
当の文書にて`作動中な~view遷移$docは ~NULL でないならば，
当の文書の根~要素に適用される。
◎
The :active-view-transition pseudo-class applies to the root element of the document, if it has an active view transition.
</p>

<p>
`active-view-transition$ps の`詳細度$は、
1 個の疑似類~選択子と同じになる。
◎
The specificity of an :active-view-transition is one pseudo-class selector.
</p>

<p>
`active-view-transition$ps 疑似類は、
次を満たす`文書~要素$に合致する
⇒
その`~node文書$にて`作動中な~view遷移$doc ~NEQ ~NULL
◎
An :active-view-transition pseudo-class matches the document element when its node document has an non-null active view transition.
</p>

			</section>
			<section id="the-active-view-transition-type-pseudo">
<h4 title="The :active-view-transition-type() pseudo-class">3.3.2. `active-view-transition-type()^ps 疑似類</h4>

<p>
`active-view-transition-type()@ps
疑似類は、
当の文書にて`作動中な~view遷移$docは［
~NULL でない, かつ【いずれかの引数に】合致している
］ならば，
当の文書の根~要素に適用される。
その構文は：
◎
The :active-view-transition-type() pseudo-class applies to the root element of the document, if it has a matching active view transition. It has the following syntax definition:
</p>

<pre class="prod">
:active-view-transition-type(`custom-ident$t#)
</pre>

<p>
`active-view-transition-type()$ps の`詳細度$は、
1 個の疑似類~選択子と同じになる。
◎
The specificity of an :active-view-transition-type() is one pseudo-class selector.
</p>

<p>
`active-view-transition-type()$ps 疑似類は、
~AND↓ を満たす`文書~要素$に合致する：
◎
An :active-view-transition-type() pseudo-class matches the document element when＼
</p>
<ul>
	<li>
その`~node文書$にて`作動中な~view遷移$doc %~view遷移 ~NEQ ~NULL
◎
its node document has an non-null active view transition,＼
</li>
	<li>
引数を成す ある `custom-ident$t ~IN %~view遷移 にて`作動中な型~群$vT
◎
whose active types contains at least one of the &lt;custom-ident&gt; arguments.
</li>
</ul>

			</section>
		</section>
		<section id="view-transitions-extension-types">
<h3 title="Changing the types of an ongoing view transition">3.4. 進行中な~view遷移の型~群の変更-法</h3>

<p>
`ViewTransition$I ~interfaceは、
次に従って拡張される：
◎
The ViewTransition interface is extended as follows:
</p>

<pre class="idl">
[`Exposed$=Window]
interface `ViewTransitionTypeSet@I {
  setlike&lt;`DOMString$&gt;;
};

[`Exposed$=Window]
partial interface `ViewTransition$I {
  attribute `ViewTransitionTypeSet$I `types$m;
};
</pre>

<p>
`ViewTransitionTypeSet$I ~objは、［
特別な意味論を伴わない文字列
］たちが成す`有順序~集合$を表現する。
◎
The ViewTransitionTypeSet object represents a set of strings, without special semantics.
</p>

<p class="note">注記：
`ViewTransitionTypeSet$I は、
`active-view-transition-type()$ps 用には妥当でない文字列を包含し得る
— 例： `custom-ident$t でない文字列。
◎
Note: a ViewTransitionTypeSet can contain strings that are invalid for :active-view-transition-type, e.g. strings that are not a &lt;custom-ident&gt;.
</p>

<div class="algo">
`types@m
`取得子~手続き$は
⇒
~RET コレにて`作動中な型~群$vT
◎
The types getter steps are to return this's active types.
</div>

		</section>
		<section id="types-cross-doc">
<h3 title="Activating the transition type for cross-document view transitions＼The types descriptor">3.5. 非同一-文書な~view遷移~用の遷移~型の作動化-法： `types^d 記述子</h3>

◎述 `types@d
◎用 `view-transition$at
◎値 `none^v | `custom-ident$t+
◎初 `none^v
◎表終

<p>
`types$d 記述子は、
~view遷移を［
捕捉する／遂行する
］ときに，当の遷移にて`作動中な型~群$vTを設定する
— それは、
`startViewTransition(callbackOptions)$m を
— %callbackOptions の `types$mb に その値を与える下で —
~callすることに等価になる。
◎
The 'types' descriptor sets the active types for the transition when capturing or performing the transition, equivalent to calling startViewTransition(callbackOptions) with that types.
</p>

<p class="note">注記：
`types$d 記述子が適用されるのは、
それを定義した`文書$に限られる。
作者が選んだ型たちが成す集合を新-旧-両~文書~内で利用する責務は、
作者にある。
◎
Note: the types descriptor only applies to the Document in which it is defined. The author is responsible for using their chosen set of types in both documents.
</p>

		</section>
	</section>
	<section id="shared-style-with-vt-classes">
<h2 title="Sharing styles between view transition pseudo-elements">4. ~view遷移~疑似要素たちの~styleの共有-法</h2>

		<section id="shared-style-overview">
<h3 title="Overview">4.1. 概観</h3>

◎非規範的

<p>
~DOM内にある複数の要素を類似な仕方で~styleするときには、
`class$a 属性が共通的に利用される：
複数の要素にまたがって共有される名前を設定してから、
`~class選択子$を利用して共有される~styleを宣言するよう。
◎
When styling multiple elements in the DOM in a similar way, it is common to use the class attribute: setting a name that’s shared across multiple elements, and then using the class selector to declare the shared style.
</p>

<p>
`有名~view遷移~疑似要素$
（例： `view-transition-group()$pe ）は、
~DOM内には定義されず，
`view-transition-name$p ~propを利用して定義される。
`view-transition-class$p ~propは、
その目的~用に，~HTMLの`~class群$に等価なものを~view遷移に供する。
`view-transition-name$p を伴う ある要素が
`view-transition-class$p も有するときは、
その値を成す各~classが疑似要素により選定-可能になる
— 下の`例＠#vt-class-example$に見られるとおり。
◎
The view transition pseudo-elements (e.g. view-transition-group()) are not defined in the DOM, but rather by using the view-transition-name property. For that purpose, the view-transition-class' CSS property provides view transitions with the equivalent of HTML classes. When an element with a view-transition-name also has a view-transition-class value, that class would be selectable by the pseudo-elements, as per the examples.
</p>

		</section>
		<section id="vt-class-example">
<h3 title="Examples">4.2. 例</h3>

<div class="example">
<p>
この例が作成する遷移では、
各~boxは，自前の名前の下で遷移に関与する一方で，
すべての~boxの~animationに所要時間 1 秒を適用する：
◎
This example creates a transition with each box participating under its own name, while applying a 1-second duration to the animation of all the boxes:
</p>

<pre class="lang-html">
&lt;div class="box" id="red-box"&gt;&lt;/div&gt;
&lt;div class="box" id="green-box"&gt;&lt;/div&gt;
&lt;div class="box" id="yellow-box"&gt;&lt;/div&gt;
</pre>

<pre class="lang-css">
div.box {
  view-transition-class: any-box;
  width: 100px;
  height: 100px;
}
#red-box {
  view-transition-name: red-box;
  background: red;
}
#green-box {
  view-transition-name: green-box;
  background: green;
}
#yellow-box {
  view-transition-name: yellow-box;
  background: yellow;
}

/* <span class="comment">
次の~styleは、
`view-transition-class$p のおかげで，すべての~boxに適用されることになる：
◎
The following style would apply to all the boxes, thanks to 'view-transition-class'
</span> */
::view-transition-group(*.any-box) {
  animation-duration: 1s;
}
</pre>
</div>

		</section>
		<section id="view-transition-class-prop">
<h3 title="The view-transition-class property">4.3. `view-transition-class^p ~prop</h3>

◎名 `view-transition-class@p
◎値 `~noneC$v | `custom-ident$t+
◎初 `none^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`view-transition-class$p を利用すれば、
複数の`有名~view遷移~疑似要素$に対し，
`view-transition-name$p 【により指定された`~view遷移~名$】が異なっていても同じ~style規則を適用できる。
`view-transition-name$p は，
旧-状態~内にある要素と新-状態~内にある対応している要素どうしを照合するために利用されるが、
`view-transition-class$p は，
~view遷移~疑似要素
（ `view-transition-group()$pe,
`view-transition-image-pair()$pe,
`view-transition-old()$pe,
`view-transition-new()$pe ）
を利用して~styleを適用するために限り利用される。
◎
The view-transition-class can be used to apply the same style rule to multiple named view transition pseudo-elements which may have a different view-transition-name. While view-transition-name is used to match between the element in the old state with its corresponding element in the new state, view-transition-class is used only to apply styles using the view transitionpseudo-elements (::view-transition-group(), ::view-transition-image-pair(), ::view-transition-old(), ::view-transition-new()).
</p>

<p>
`view-transition-class$p は、
要素を捕捉するために~markするものではないことに注意
— その利用は、［
すでに `view-transition-name$p を有する要素を~styleする
］ための追加的な仕方に限られる。
◎
Note that view-transition-class by itself doesn’t mark an element for capturing, it is only used as an additional way to style an element that already has a view-transition-name.
</p>
<dl class="valdef">
	<dt>`~noneC@v</dt>
	<dd>
当の要素~用に生成される`有名~view遷移~疑似要素$に適用される~classは無い。
◎
No class would apply to the named view transition pseudo-elements generated for this element.
</dd>

	<dt id="valdef-view-transition-class-custom-ident">`custom-ident$t+</dt>
	<dd>
指定された `custom-ident$t 値（ `none^v 以外）すべてが、
`有名~view遷移~疑似要素$`選択子$内で利用されるときに適用される。
`none^v は、
この~prop用の `custom-ident^t としては妥当でない
— 別の `custom-ident^t と組合されたときでも。
◎
All of the specified &lt;custom-ident&gt; values (apart from none) are applied when used in named view transition pseudo-element selectors. none is an invalid &lt;custom-ident&gt; for view-transition-class, even when combined with another &lt;custom-ident&gt;.
</dd>
	<dd>
各 “~view遷移~class” 【これら各 `custom-ident^t 】は、
`~tree視野な名前$である。
◎
Each 'view transition class' is a tree-scoped name.
</dd>
	<dd class="note">注記：
同じ `view-transition-name$p が，遷移を成す［
旧-, 新-
］両~状態~内にある要素~用に指定された場合、
`view-transition-class$p の値は，新-状態~用のものに限り適用される。
このことは、
非同一-文書な~view遷移~用にも適用される：
旧-文書~内で指定された~classは、
対応する `view-transition-name$p が新-文書~内に指定されなかった場合に限り，
適用されることになる。
◎
Note: If the same view-transition-name is specified for an element both in the old and new states of the transition, only the view-transition-class values from the new state apply. This also applies for cross-document view transitions: classes from the old document would only apply if their corresponding view-transition-name was not specified in the new document.
</dd>
</dl>

		</section>
		<section id="pseudo-element-class-additions">
<h3 title="Additions to named view transition pseudo-elements">4.4. 有名~view遷移~疑似要素に対する追加</h3>


<p>
`有名~view遷移~疑似要素$
（ `view-transition-group()$pe,
`view-transition-image-pair()$pe,
`view-transition-old()$pe,
`view-transition-new()$pe ）
は、
次の構文を~supportするよう拡張される：
◎
The named view transition pseudo-elements (view-transition-group(), view-transition-image-pair(), view-transition-old(), view-transition-new()) are extended to support the following syntax:
</p>

<pre class="prod">
::view-transition-group(`pt-name-and-class-selector$t)
::view-transition-image-pair(`pt-name-and-class-selector$t)
::view-transition-old(`pt-name-and-class-selector$t)
::view-transition-new(`pt-name-and-class-selector$t)
</pre>

<p>
`pt-name-and-class-selector$t の構文は：
◎
↓ where &lt;pt-name-selector&gt; works as previously defined,＼
and &lt;pt-name-and-class-selector&gt; has the following syntax definition:
</p>

<pre class="prod">
`pt-name-and-class-selector@t
	= `pt-name-selector$t `pt-class-selector$t?
	| `pt-class-selector$t
`pt-class-selector@t
	= ['.' `custom-ident$t]+
</pre>

<p>
ここで， `pt-name-selector$t は、
`~level 1$ にて定義されたとおりに働く。
◎
↑</p>

<p>
上の文法は、［
次に挙げる箇所においては，空白は禁止される
］ものと解釈される：
◎
When interpreting the above grammar, white space is forbidden:
</p>
<ul>
	<li>
`pt-name-selector$t, `pt-class-selector$t の合間
◎
Between &lt;pt-name-selector&gt; and &lt;pt-class-selector&gt;
</li>
	<li>
`pt-class-selector$t を成す各~成分の合間
◎
Between any of the components of &lt;pt-class-selector&gt;.
</li>
</ul>

<p>
`有名~view遷移~疑似要素$`選択子$に合致する要素は、
`pt-class-selector$t 空であったとするとき合致する要素 %疑似要素 のうち，
次を満たすものに合致する
⇒
`pt-class-selector$t を成す どの `custom-ident^t も次を満たす
⇒
`custom-ident^t ~IN 当の~view遷移の`有名~要素~群$vT[ %疑似要素 の`~view遷移~名$【！ `view-transition-name$p】 ] の`~class~list$cE
◎
A named view transition pseudo-element selector which has one or more &lt;custom-ident&gt; values in its &lt;pt-class-selector&gt; would only match an element if the class list value in named elements for the pseudo-element’s view-transition-name contains all of those values.
</p>

<div>
<p>
`有名~view遷移~疑似要素$`選択子$の`詳細度$は：
</p>
<ul>
	<li>
次を満たす場合は `zero^en 【すなわち ( 0, 0, 0 ) 】になる
⇒
［
`pt-name-selector$t は `*^css （`全称~選択子$）をとる
］~OR［
`pt-class-selector$t は空である
］
</li>
	<li>
~ELSE_ `型~選択子$と等価【すなわち ( 0, 0, 1 ) 】になる
</li>
</ul>
◎
The specificity of a named view transition pseudo-element selector with either:
• a &lt;pt-name-selector&gt; with a &lt;custom-ident&gt;; or
• a &lt;pt-class-selector&gt; with at least one &lt;custom-ident&gt;,
◎
is equivalent to a type selector.
◎
The specificity of a named view transition pseudo-element selector with a * argument and with an empty &lt;pt-class-selector&gt; is zero.
</div>

		</section>
	</section>
	<section id="extend-document-types">
<h2 title="Extending document.startViewTransition()">5. `document.startViewTransition()^m の拡張-法</h2>

<pre class="idl">
dictionary `StartViewTransitionOptions@I {
  `ViewTransitionUpdateCallback$I? `update@mb = null;
  `sequence$&lt;`DOMString$&gt;? `types@mb = null;
};

partial interface `Document$I {
  `ViewTransition$I `startViewTransition$m(optional (`ViewTransitionUpdateCallback$I or `StartViewTransitionOptions$I) %callbackOptions = {});
};
</pre>

<div class="algo">
<p>
`startViewTransition(callbackOptions)@m
`~method手続き$は：
◎
The method steps for startViewTransition(callbackOptions) are as follows:
</p>
<ol>
	<li>
%更新~callback ~LET ~NULL
◎
Let updateCallback be null.
</li>
	<li>
~IF［
%callbackOptions は `ViewTransitionUpdateCallback$I である
］
⇒
%更新~callback ~SET %callbackOptions
◎
If callbackOptions is a ViewTransitionUpdateCallback, set updateCallback to callbackOptions.
</li>
	<li>
~ELIF［
%callbackOptions は `StartViewTransitionOptions$I である
］
⇒
%更新~callback ~SET %callbackOptions[ "`update$mb" ]
◎
Otherwise, if callbackOptions is a StartViewTransitionOptions, then set updateCallback to callbackOptions’s update.
</li>
	<li>
%作動中な遷移 ~LET コレにて`作動中な~view遷移$doc
◎
↓</li>
	<li>
<p>
~IF［
%作動中な遷移 ~NEQ ~NULL
］~AND［
%作動中な遷移 の`外へ出る捕捉-後の手続き$vT ~NEQ ~NULL
］：
◎
If this’s active view transition is not null and its outbound post-capture steps is not null, then:
</p>
		<ol>
			<li>
<p>
%飛ばされる前の遷移 ~LET コレに`関連な~realm$に属する新たな `ViewTransition$I
— その
⇒＃
`更新~callback$vT ~SET %更新~callback
◎
Let preSkippedTransition be a new ViewTransition in this’s relevant realm whose update callback is updateCallback.
</p>

<p class="note">注記：
ここでは、
当の遷移は決して作動化されないので，
%飛ばされる前の遷移 の `types$m は無視される。
◎
Note: The preSkippedTransition’s types are ignored here because the transition is never activated.
</p>

			</li>
			<li>
`~view遷移を飛ばす$( %飛ばされる前の遷移, `InvalidStateError$E 例外 )
◎
Skip preSkippedTransition with an "InvalidStateError" DOMException.
</li>
			<li>
~RET %飛ばされる前の遷移
◎
Return preSkippedTransition.
</li>
		</ol>

<p class="note">注記：
この段は、［
`pageswap$et を発火した後に開始された同一-文書な遷移
］は飛ばされることを確保する。
◎
Note: This ensures that a same-document transition that started after firing pageswap is skipped.
</p>
	</li>
	<li>
%~view遷移 ~LET コレ上の［
`~level 1$ に定義される `startViewTransition＠~CSSVT#dom-document-startviewtransition$m 用の`~method手続き$
］( %更新~callback )
◎
Let viewTransition be the result of running the method steps for startViewTransition(updateCallback) given updateCallback.
</li>
	<li>
<p>
~IF［
%callbackOptions は `StartViewTransitionOptions$I である
］：
【！%callbackOptions[ "`types$mb" ] を`~cloneする$】
</p>
		<ol>
			<li>
%~token群 ~LET 新たな`有順序~集合$
</li>
			<li>
%callbackOptions[ "`types$mb" ] を成す
~EACH( %~token )
に対し
⇒
%~token群 に %~token を`付加する$set
</li>
			<li>
%~view遷移 にて`作動中な型~群$vT ~SET %~token群
</li>
		</ol>
◎
If callbackOptions is a StartViewTransitionOptions, set viewTransition’s active types to a clone of types as a set.
</li>
	<li>
~RET %~view遷移
◎
Return viewTransition.
</li>
</ol>
</div>

	</section>
	<section id="auto-vt-name">
<h2 title="Determining view-transition-name automatically">6. `view-transition-name$p 自動的な決定-法</h2>


		<section id="auto-vt-name-overview">
<h3 title="Overview">6.1. 概観</h3>

◎非規範的

<p>
要素が ある`~view遷移$に関与するためには、
一意な`~view遷移~名$【！ `view-transition-name$p 】を受取る必要がある。
これは、
同じ~view遷移~内に複数の要素が孕まれるときに，長々しく冗漫になり得る
— とりわけ、
それらのうち多くが同一-要素な遷移であって．［
旧-状態, 新-状態
］における`~view遷移~名$【！ `view-transition-name$p 】が同じである事例では。
◎
For an element to participate in a view transition, it needs to receive a unique view-transition-name. This can be tedious and verbose when multiple elements are involved in the same view transition, especially in cases where many of those are same-element transitions, as in, the element has the same view-transition-name in the old and new state.
</p>

<p>
これは、
`view-transition-name$p を `auto$v に設定することで，もっと容易になる
— 要素~用の`~view遷移~名$【！ `view-transition-name$p 】は、
要素の`~ID$からとられるか，~IDが無い場合は【自動的に】生成される。
◎
To make this easier, setting the view-transition-name to auto would generate a view-transition-name for the element, or take it from the element’s id if present.
</p>

		</section>
		<section id="auto-vt-name-example">
<h3 title="Examples">6.2. 例</h3>

<div class="example">
<p>
この例では、
~listを~sortするときに~animateするための仕方として，
~view遷移が利用される：
◎
In this example, view transition is used to sort a list in an animated way:
</p>

<pre class="lang-html">
&lt;ul&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2&lt;/li&gt;
  &lt;li&gt;Item 3&lt;/li&gt;
  &lt;li&gt;Item 4&lt;/li&gt;
  ...
&lt;/ul&gt;
</pre>

<p>
~listを成す各~itemは、
普通は，一意な`~view遷移~名$【！ `view-transition-name$p 】を受取る
【そうなるようにする必要がある】
ことになろう
【見本~code内では全部 `item1^v に設定されているが、 `item2^v 等々の誤記？】：
◎
Ordinarily, each of these items would have to receive a unique view-transition-name:
</p>

<pre class="lang-css">
li:nth-child(1) { view-transition-name: item1; }
li:nth-child(2) { view-transition-name: item1; }
li:nth-child(3) { view-transition-name: item1; }
li:nth-child(4) { view-transition-name: item1; }
...
</pre>

<p>
`auto$v を伴う次の~CSSでも、
働くことになる：
◎
With auto, this CSS would work:
</p>

<pre class="lang-css">
li {
  view-transition-name: auto;
}
</pre>
</div>

		</section>
		<section id="additions-to-vt-name">
<h3 title="Additions to view-transition-name">6.3. `view-transition-name^p に対する追加</h3>

<p>
`view-transition-name$p ~propは、
新たな~keyword
`auto@v
も受容する。
◎
In addition to the existing values, the view-transition-name also accepts an auto keyword.＼
</p>

<div class="algo">
<p>
%要素 の `view-transition-name$p の`使用~値$を解決するときは、
その`算出d値$ %算出d値 に応じて：
◎
To resolve the used value of view-transition-name for element:
◎
• Let computed be the computed value of view-transition-name.
</p>
<ul class="switch">
	<li>
`none$v
⇒
~RET ~NULL
【 %要素 には`~view遷移~名$は無い】
◎
If computed is none, return null.
</li>
	<li>
`custom-ident$t である
⇒
~RET %算出d値
◎
If computed is a &lt;custom-ident&gt;, return computed.
</li>
	<li>
<p>
`auto$v ：
◎
Assert: computed is auto.
</p>
		<ol>
			<li>
%~ID ~LET %要素 の`~ID$
◎
↓</li>
			<li>
<p>
~IF［
%~ID ~NEQ ε
］~AND［
%算出d値 に`結付けられた根＠~CSSSCOPING#css-tree-scoped-name$ ~EQ %要素 の`根$
］
⇒
~RET %~ID
◎
If element has an associated id, and computed is associated with the same root as element’s root, then return the value of element’s id.
</p>

<p class="note">注記：
このことは、
`part()$pe 疑似要素に対しては，それに合致している要素【それを介して公開される要素】の`~ID$には解決されないことを意味する。
◎
Note: this means that a ::part() pseudo-element wouldn’t resolve to its matching element’s id.
</p>
	</li>
	<li>
<p>
~RET ある一意な文字列
— この文字列は、
少なくとも［
%要素 の`~node文書$ %文書 にて`作動中な~view遷移$docの存続期間
］においては，［
%要素 用に一貫する, かつ %文書 内で一意
］であり続けるベキである。
◎
Return a unique string. The string should remain consistent and unique for this element and Document, at least for the lifetime of element’s node document's active view transition.
</p>

<p class="note">注記：
この文字列は、
~webからは観測-可能にはならず，
内部~algo内で要素を~~特定するために利用される。
◎
Note: this string is not web-observable, and is used for addressing the element in internal algorithms.
</p>

<p class="note">注記：
非同一-文書な~view遷移において利用されるときには、
【旧-文書, 新-文書において】
`auto$v 値により生成される名前どうしは決して合致しない
— その結果、
外へ出る~view遷移~用の `view-transition-group()$pe 疑似要素は，
内へ来る~view遷移~用のそれとは別々になる。
◎
Note: When used in a cross-document view transition, generated auto values never match, resulting in separate ::view-transition-group() pseudo-elements, one exiting and one entering.
</p>
			</li>
		</ol>
	</li>
</ul>
</div>

<p>
`auto$v により生成される`~view遷移~名$【！ `view-transition-name$p 】は、
`~tree視野な名前$である。
◎
A view-transition-name generated by auto is a tree-scoped name.
</p>

		</section>
	</section>
	<section id="nested-view-transitions">
<h2 title="Nested view-transitions">7. 入子な~view遷移</h2>

		<section id="nested-overview">
<h3 title="Overview">7.1. 概観</h3>

◎非規範的

<p>
既定では、
複数の要素に `view-transition-name^p を設定したときは，
平坦な`~view遷移~tree$が生成される
— すなわち、
すべての `view-transition-group()$pe 疑似要素は，
`view-transition$pe 疑似要素の子になる。
これは，多くの単純な利用事例~用には足るが、
平坦な~treeでは達成できない~style法の利用事例もある。
真っ先に挙がる利用事例は、
【~overflowなどによる】切取りである：
平坦な~treeでは，すべての疑似要素は`~snapshot包含塊$で切取られるので、
通常の~treeにおいて要素が切取られると，その部分が~view遷移の間に失われ、
その結果，視覚-効果が崩れる。
次に挙げる効果は、
平坦な~treeにおいて期待されない視覚-効果を伴い得る：
◎
By default, setting view-transition-name on multiple elements generates a flat view transition tree, where all the ::view-transition-group() pseudo-elements are children of the ::view-transition pseudo-element. This is sufficient for many simple use-cases, but there are some styling use-cases that cannot be achieved with a flat tree. The most prominent use-case is clipping: with a flat tree, all pseudo-elements are clipped to the snapshot containing block, so clipping elements in the normal tree would lose their clipping during the view-transition, resulting in a broken visual effect. The effects that have can have an unexpected visual effect in a flat tree:
</p>

<ul>
	<li>
切取り
（ `overflow$p, `clip-path$p, `border-radius$p ）
⇒
切取りは、
当の要素の子たちに影響する。
◎
Clipping (overflow, clip-path, border-radius): clipping affects the children of the element.
</li>
	<li>
`opacity$p,
`mask-image$p,
`filter$p
⇒
これらの効果は、
~tree【これらを利用する要素を根とする下位tree】を全部的に~raster化した画像に対し，働くよう設計される
— 各~itemに対し個別に働くのではなく。
◎
opacity, mask-image and filter: These effects that are designed to work on a fully rasterized image of a tree, rather than on each item individually.
</li>
	<li>
~3D変形
（ `transform-style$p, `transform$p, `perspective$p ）
⇒
~3D変形の~animationを成す全部的な範囲を表示するためには、
何らかの階層が保たれる必要がある。
◎
3D transforms (transform-style, transform, perspective): to display the full range of 3D transform animations, some hierarchy needs to be kept.
</li>
</ul>

<p>
これらの利用事例を可能化するため、
この仕様は，［
~view遷移~疑似要素たちを入子にすること
］が成す概念を導入する。
作者は、
`view-transition-group$p ~propを利用して［
生成される `view-transition-group()$pe 疑似要素~用に “親~group” をアテガう
］ことにより，`~view遷移~tree$内に階層を作成できる。
◎
To enable these use cases, this specification introduces the concept of nesting view-transition pseudo-elements. By using the view-transition-group CSS property, the author can assign a "parent group" for a generated ::view-transition-group() pseudo-element, creating a hierarchy in the view transition tree.
</p>

		</section>
		<section id="nested-vt-example">
<h3 title="Examples">7.2. 例</h3>

<div class="example">
<p>
この例で作成される遷移の`~view遷移~tree$は、
平坦になる代わりに入子にされる：
◎
This example creates a transition where the view transition tree is nested instead of flat:
</p>

<pre class="lang-html">
&lt;section class="container"&gt;
  &lt;article&gt;Content&lt;/article&gt;
&lt;/section&gt;
</pre>

<pre class="lang-css">
.container {
  view-transition-name: container;
}

.container,
::view-transition-group(container) {
  clip-path: circle();
}

article {
  view-transition-name: article;
  view-transition-group: container;
}
</pre>

<p>
`clip-path$p を［
包含している要素【 `.container^css 】,
それ用に生成された疑似要素
］両者に適用することにより，
切取られたものは遷移の間も保全され、［
当の容器【 `.container^css 】を参照している `view-transition-group$p を当の内部~要素【 `article^e 】に適用する
］ことにより，［
この切取りを適用することになる仕方
］で当の~treeを “入子に” する。
◎
By applying the clip-path to both the containing element and its generated pseudo-element, we preserve the clip during the transition, and by applying view-transition-group to the internal element referencing the container, we make the tree "nested" in a way that would apply this clipping.
</p>
</div>

		</section>
		<section id="view-transition-group-prop">
<h3 title="The view-transition-group property">7.3. `view-transition-group^p ~prop</h3>

◎名 `view-transition-group@p
◎値 `normal$v | `contain$v | `nearest$v | `custom-ident$t
◎初 `normal$v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`view-transition-group$p ~propは、
`view-transition-name$p と伴に利用することで，
`有名~view遷移~疑似要素$たちが成す階層を生成できる。
◎
The view-transition-group property can be used in conjuction with view-transition-name to generate a hierarchy of named view transition pseudo-element.
</p>

<p>
`要素$ %要素 の `view-transition-group$p の`使用~値$は、［
%要素 の ある先祖の `view-transition-name$p の値
］ %名前 または `none$v に解決される。
`有名~view遷移~疑似要素$を生成するとき、
【`~view遷移~名$として】 %名前 を伴う `view-transition-group()$pe は，［
%要素 の `view-transition-name$p 用に生成される `view-transition-group()$pe
］の親になる。
◎
The used value for view-transition-group resolves to a view-transition-name in its ancestor chain, or to none. When generating the named view transition pseudo-element, the ::view-transition-group() with that name would be the parent of the ::view-transition-group() generated for this element’s view-transition-name.
</p>

		</section>
	</section>
	<section id="layered-capture">
<h2 title="Layered capture">8. 層~化~捕捉</h2>

		<section id="layered-capture-overview">
<h3 title="Overview">8.1. 概観</h3>

◎非規範的

<p>
`css-view-transitions-1$r においては、［
旧-状態, 新-状態
］は~snapshotとして捕捉される
— ［
初期~幾何, 最終-幾何
］が捕捉され，既定では~cross-fade~animationを作成する。
これは、
単純な~modelであり，たいていは欲される成り行きを作成する。
◎
In [css-view-transitions-1], the old and new states are captured as snapshots, and the initial and final geometry are captured, creating a crossfade animation by default. This is a simple model and mostly creates the desired outcome.
</p>

<p>
しかしながら、
2 個の平坦~化された~snapshotを~cross-fadeするだけでは，
常に最も表情豊かな~animationになるとは限らない。
~CSSは，［
~border, ~gradient背景, `filter$p, `box-shadow$p, 等々
］を~animateすることを許容する
— それは、
欲される利用者~体験に依存して，
~cross-fadeよりも表情豊かで自然に感じられ得る。
◎
However, crossfading two flattened snapshots is not always the most expressive animation. CSS allows animating borders, gradient backgrounds, filter, box-shadow etc. which can feel more expressive and natural than crossfade depending on the desired UX.
</p>

<p>
加えて，`入子な~view遷移＠#nested-view-transitions$を利用しているときは、
~animationによっては，~CSS~propたちが~snapshotへ平坦~化されるとき “間違った” 見かけになることもある。
これは、
~tree効果
— `opacity$p, `mask$p, `clip-path$p, `filter$p など —
に加えて， `overflow$p 利用している切取りも含む。
これらの効果は、［
1 個の要素と その内容
］のみならず，［
要素たちが成す~tree全体
］に適用するよう設計された。
◎
In addition, when using nested view transitions, some of the animations could look "wrong" when the CSS properties are flattened to a snapshot. This includes tree effects, such as opacity, mask, clip-path and filter, and also clipping using overflow. These effects are designed to apply to the whole tree of elements, not just to one element and its content.
</p>

<p>
~CSS~propのうち［
~tree全体に影響するものすべて, および~box装飾
］は、
層~化~捕捉（ `layered capture^en ）により~styleとして捕捉され，
当の~groupを成す一部として~animateする。
◎
With layered capture, all the CSS properties that affect the entire tree, as well as box decorations, are captured as style and animate as part of the group.
</p>

<p class="issue">
この挙動は［
~opt-in `with^en【？】 ~CSS~prop／~opt-out `with^en ~CSS~prop
］どちらになるべきか？
`11078$issue を見よ。
◎
should this behavior be an opt-in/opt-out with a CSS property? See issue 11078.
</p>

		</section>
		<section id="layered-captured-css-properties">
<h3 title="Table of captured CSS properties {#layered-captured-css-properties}">8.2. 捕捉される~CSS~prop一覧</h3>

<p>
`層~化~捕捉~prop群@
は、［
次に挙げる［
層~化~捕捉に関与する~CSS~prop
］たちが成す`~list$
］として定義される。
これらの~propは、
要素の［
旧-状態／新-状態
］が捕捉されるとき，
当の要素の~styleとして捕捉される
— ~UAは、
これらの~propを無視rする下で~snapshotを描画するモノトスル：
◎
The following list of layered capture properties defines the CSS properties that participate in layered capture. When the old or new state of the element are captured, these properties are captured as style, and the user agent must render the snapshot with disregard to that property:
</p>

<p class="trans-note">【
これらは、
無順序~list（ `ul^e ）として~mark-upされているので，
順序は定義されないことになる
（おそらく，順序は有意にならない）。
】</p>

<ul>
	<li>`background$p</li>
	<li>`border-left$p</li>
	<li>`border-top$p</li>
	<li>`border-bottom$p</li>
	<li>`border-right$p</li>
	<li>`border-radius$p</li>
	<li>`border-image$p</li>
	<li>`box-shadow$p</li>
	<li>`box-sizing$p</li>
	<li>`clip-path$p</li>
	<li>`filter$p</li>
	<li>`mask$p</li>
	<li>`opacity$p</li>
	<li>`outline$p</li>
	<li>`padding$p</li>
</ul>

		</section>
	</section>
	<section id="algorithms">
<h2 title="Algorithms">9. ~algo</h2>

		<section id="concepts">
<h3 title="Data Structures">9.1. ~data構造</h3>

			<section id="additions-to-document">
<h4 title="Additions to Document">9.1.1. 文書に対する追加</h4>

<p>
各`文書$は、
次に挙げるものを追加的に有する：
◎
A Document additionaly has:
</p>
<ul>
	<li>
`内へ来る~view遷移~params@doc
⇒
ある`~view遷移~params$ ／ ~NULL
— 初期~時は~NULLとする。
◎
inbound view transition params
◎
a view transition params, or null. Initially null.
</li>
	<li>
<p>
`外へ出る~view遷移を起動できるか@doc
⇒
真偽値
— 初期~時は ~F とする。
◎
can initiate outbound view transition
• a boolean. Initially false.
</p>

<p class="note">注記：
この値は、
~navigateしている間に`並列的$に読取られ得る。
◎
Note: this value can be read in parallel while navigating.
</p>
	</li>
</ul>

<p class="trans-note">【
［
“内へ来る（ `inbound^en ）〜” ／
“外へ出る（ `outbound^en ）〜”
］は、
非同一-文書な遷移に利用される概念であり，
“〜 は［
新-文書／旧-文書
］に結付けられたものである”
ことを意味する。
】</p>

			</section>
			<section id="cross-doc-data-structure-vt">
<h4 title="Additions to ViewTransition">9.1.2. `ViewTransition^I に対する追加</h4>

<p>
各 `ViewTransition$I は、
次に挙げるものを追加的に有する：
◎
A ViewTransition additionally has:
</p>
<ul>
	<li>
`作動中な型~群@vT
⇒
ある `ViewTransitionTypeSet$I
— 【それが表現する`~set~entry群＠~WEBIDL#dfn-set-entries$は】初期~時は空とする。
◎
active types
• A ViewTransitionTypeSet, initially empty.
</li>
	<li>
`外へ出る捕捉-後の手続き@vT
⇒
~NULL ／ ある手続き
— 初期~時は ~NULL とする。
◎
outbound post-capture steps
• Null or a set of steps, initially null.
</li>
</ul>

			</section>
			<section id="cross-doc-data-structure-serialization">
<h4 title="Serializable view transition params">9.1.3. 直列化-可能な~view遷移~params</h4>

<p>
`~view遷移~params@
は、
次に挙げる`~item$sctからなる`構造体$である。
その目的は、
文書たちにまたがって，~view遷移~情報を直列化する
【旧-文書から新-文書へ情報を渡す】
ことにある：
◎
A view transition params is a struct whose purpose is to serialize view transition information across documents. It has the following items:
</p>
<ul>
	<li>
`有名~要素@vTP
⇒
`有順序~map$
— 各~entryの［
~keyは文字列／
値は`捕捉された要素$
］を与える。
◎
named elements
• a map, whose keys are strings and whose values are captured elements.
</li>
	<li>
`初期~snapshot包含塊~size@vTP
⇒
2 個の実数 ( 横幅, 縦幅 ) が成す`~tuple$
◎
initial snapshot containing block size
• a tuple of two numbers (width and height).
</li>
</ul>

			</section>
		</section>
		<section id="page-visibility-change-steps-additions">
<h3 title="Additions to the view transition page-visibility change steps">9.2. ~view遷移の~page可視性~変化-時の手続きに対する追加</h3>

<div class="algo">
<p>
`~level 1$ の`~view遷移の~page可視性~変化-時の手続き$にて~queueされる~taskの末尾には、
所与の
( %文書 )
に対し，次を遂行する段を挿入する：
◎
The next steps are appended to the tasks view transition page-visibility change steps given document, after the current steps in the queued task:
</p>
<ol>
	<li>
%文書 の`内へ来る~view遷移~params$doc ~SET ~NULL
◎
Set document’s inbound view transition params to null.
</li>
</ol>

<p class="note">注記：
これは、
~HTML仕様から~callされる。
◎
Note: this is called from the HTML spec.
</p>
</div>

			<section id="capture-classes-data-structure">
<h4 title="Captured elements extension">9.2.1. 捕捉された要素に対する拡張</h4>

<p>
構造体 `捕捉された要素$は、
次に挙げる~item【！~field】も伴うベキである：
◎
The captured element struct should contain these fields, in addition to the existing ones:
</p>
<ul>
	<li>
`~class~list@cE
⇒
文字列たちが成す`~list$
— 初期~時は空とする。
◎
a list of strings, initially empty.
</li>
	<li>
`包含ng~group名@cE
⇒
~NULL／ある文字列
— 初期~時は ~NULL とする。
◎
containing group name
• Null or a string, initially null.
</li>
	<li>
`旧-層~化~捕捉~style@cE
⇒
ある文字列
◎
old layered-capture style
• A string.
</li>
	<li>
`~snapshot包含塊からの変形@cE
⇒
ある`行列$
— 初期~時は`恒等~変形-関数$とする。
◎
transform from snapshot containing block
• A matrix, initially the identity transform function.
</li>
	<li>
`旧-~box~prop群@cE
⇒
ある`層~化~box~prop群$／ ~NULL
— 初期~時は ~NULL とする。
◎
old box properties
◎
↓</li>
	<li>
`新-~box~prop群@cE
⇒
ある`層~化~box~prop群$／ ~NULL
— 初期~時は ~NULL とする。
◎
new box properties
• A layered box properties or null, initially null.
</li>
</ul>

<p>
`層~化~box~prop群@
は、
次に挙げる~itemからなる【！~fieldを包含している】構造体である：
◎
The layered box properties is a struct, containing the following fields:
</p>
<ul>
	<li>
`~box~sizing@lbP
⇒
`border-box$v ／ `content-box$v
◎
box sizing
• border-box or content-box.
</li>
	<li>
`内容~box@lbP
⇒
~border~boxに相対的な矩形
— ~CSS~pixel単位。
◎
content box
◎
• ↓
</li>
	<li>
`~padding~box@lbP
⇒
~border~boxに相対的な矩形
— ~CSS~pixel単位。
◎
padding box
• A rectangle, in CSS pixel units, relative to the border box.
</li>
</ul>

			</section>
		</section>
		<section id="vt-rule-algo">
<h3 title="Resolving the @view-transition rule">9.3. `view-transition$at 規則の解決-法</h3>

<div class="algo">
<p>
`~view遷移~規則を解決する@
ときは、
所与の
( `文書$ %文書 )
に対し：
◎
To resolve @view-transition rule for a Document document: 
</p>

<p class="note">注記：
これは、
旧-文書, 新-文書どちらからも~callされる。
◎
Note: this is called in both the old and new document.
</p>

<ol>
	<li>
~IF［
%文書 の`可視性~状態$doc ~EQ `hidden^l
］
⇒
~RET `遷移を飛ばす^i
◎
If document’s visibility state is "hidden", then return "skip transition".
</li>
	<li>
<p>
%合致している規則 ~LET %文書 内に `view-transition$at 規則は［
在るならば それらのうち最後のもの／
無いならば ε
］
</p>

<p class="trans-note">【
`条件付き~group規則$内に入子にされ，条件が満たされないため無視される規則は、
この段の目的においては，無かったものと見なされよう。
】</p>
◎
Let matchingRule be the last @view-transition rule in document.
</li>
	<li>
~IF［
%合致している規則 ~EQ ε
］
⇒
~RET `遷移を飛ばす^i
◎
If matchingRule is not found, then return "skip transition".
</li>
	<li>
~IF［
%合致している規則 の `navigation$d 記述子の`算出d値$ ~EQ `none$vN
］
⇒
~RET `遷移を飛ばす^i
◎
If matchingRule’s navigation descriptor’s computed value is none, then return "skip transition".
</li>
	<li>
~Assert：
%合致している規則 の `navigation$d 記述子の`算出d値$ ~EQ `auto$vN
◎
Assert: matchingRule’s navigation descriptor’s computed value is auto.
</li>
	<li>
%型~群~記述子 ~LET %合致している規則 の `types$d 記述子の`算出d値$
◎
Let typesDescriptor be matchingRule’s types descriptor.
</li>
	<li>
~IF［
%型~群~記述子 ~EQ `none^v
］
⇒
~RET 新たな`有順序~集合$
◎
If typesDescriptor’s computed value is none, then return a set « ».
</li>
	<li>
<p>
~RET %型~群~記述子 を成す文字列たちが成す`有順序~集合$
◎
Return a set of strings corresponding to typesDescriptor’s computed value.
</p>

<p class="trans-note">【
集合なので、
重複する文字列たちは，一つ（おそらく，最初のそれ）だけ残して他は除去されることになる。
】</p>

	</li>
</ol>
</div>

		</section>
		<section id="setup-old-document-vt">
<h3 title="Setting up the view transition in the old Document">9.4. 旧-文書~内で~view遷移を設定しておく</h3>

			<section id="check-eligibility">
<h4 title="Check eligibility for outbound cross-document view transition">9.4.1. 外へ出る非同一-文書な~view遷移の適格~性を検査する</h4>

<div class="algo">
<p>
`~naviは非同一-文書な~view遷移を誘発し得るか？@
検査するときは、
所与の
⇒＃
`文書$ %旧-文書,
`文書$ %新-文書,
`NavigationType$I %~navi種別,
真偽値 %~browser~UIによる~naviか
◎終
に対し：
◎
To check if a navigation can trigger a cross-document view-transition? given a Document oldDocument, a Document newDocument, a NavigationType navigationType, and a boolean isBrowserUINavigation:
</p>

<p class="note">注記：
これは、
~naviの間に［
~callされる／`並列的$に~callされる
］。
◎
Note: this is called during navigation, potentially in parallel.
</p>

<ol>
	<li>
任意選択で
⇒
~IF［
~UAは`実装定義$な~navi体験を表示するものと裁定した
（例： ~gestureに基づく後戻りする~navi用の遷移）
］
⇒
~RET ~F
（~UAは作者-定義な~view遷移を無視してもヨイ。）
◎
If the user agent decides to display an implementation-defined navigation experience, e.g. a gesture-based transition for a back navigation, the user agent may ignore the author-defined view transition. If that is the case, return false.
</li>
	<li>
~IF［
%旧-文書 の`外へ出る~view遷移を起動できるか$doc ~EQ ~F
］
⇒
~RET ~F
◎
If oldDocument’s can initiate outbound view transition is false, then return false.
</li>
	<li>
~IF［
%~navi種別 ~EQ `reload$l
］
⇒
~RET ~F
◎
If navigationType is reload, then return false.
</li>
	<li>
~IF［
( %旧-文書 の`生成元$doc, %新-文書 の`生成元$doc )
は`同一-生成元$でない
］
⇒
~RET ~F
◎
If oldDocument’s origin is not same origin as newDocument’s origin, then return false.
</li>
	<li>
<p>
~IF［
%新-文書 の`非同一-生成元~redirectを介して作成されたか$doc ~EQ ~T
］~AND［
%新-文書 の`最近の~entry$ ~EQ ~NULL
］
⇒
~RET ~F
◎
If newDocument was created via cross-origin redirects and newDocument’s latest entry is null, then return false.
</p>

<p class="note">注記：
`最近の~entry$は、
%新-文書 が［
`~BF~cache$から復旧されたものではなく，新たな~naviによるものである場合
］には ~NULL になる。
◎
Note: A Document's latest entry would be null if this is a new navigation, rather than a restore from BFCache.
</p>
	</li>
	<li>
~IF［
%~navi種別 ~EQ `traverse$l
］
⇒
~RET ~T
◎
If navigationType is traverse, then return true.
</li>
	<li>
~IF［
%~browser~UIによる~naviか ~EQ ~T
］
⇒
~RET ~F
◎
If isBrowserUINavigation is true, then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

			</section>
			<section id="setup-outbound-transition">
<h4 title="Setup the outbound transition when ready to swap pages">9.4.2. ~pageが切替わるに準備済みなとき外へ出る遷移を設定しておく</h4>

<div class="algo">
<p>
`非同一-文書な~view遷移を設定しておく@
ときは、
所与の
⇒＃
`文書$ %旧-文書,
`文書$ %新-文書,
~algo %~naviで続行する手続き
◎終
に対し：
◎
To setup cross-document view-transition given a Document oldDocument, a Document newDocument, and proceedWithNavigation, which is an algorithm accepting nothing: 
</p>

<p class="note">注記：
これは、
~HTML仕様から~callされる。
◎
Note: This is called from the HTML spec.
</p>

<ol>
	<li>
~Assert：
この手続きは、
%旧-文書 に対し~queueされた`~task$を成す一部として走っている。
◎
Assert: These steps are running as part of a task queued on oldDocument.
</li>
	<li>
~IF［
%旧-文書 の`外へ出る~view遷移を起動できるか$doc ~EQ ~F
］
⇒
~RET ~NULL
◎
If oldDocument’s can initiate outbound view transition is false, then return null.
</li>
	<li>
%規則からの遷移~型~群 ~LET `~view遷移~規則を解決する$( %旧-文書 )
◎
Let transitionTypesFromRule be the result of resolving the @view-transition rule for oldDocument.
</li>
	<li>
<p>
~Assert：
%規則からの遷移~型~群 ~NEQ `遷移を飛ばす^i
◎
Assert: transitionTypesFromRule is not "skip transition".
</p>

<p class="note">注記：
%新-文書 は，構文解析-済みでないかもしれないので、
それが~opt-inされたかどうかは，まだ知れない。
%新-文書 用に~opt-inを検査するのは、
`pagereveal$et ~eventが発火されたときになる。
◎
Note: We don’t know yet if newDocument has opted in, as it might not be parsed yet. We check the opt-in for newDocument when we fire the pagereveal event.
</p>
	</li>
	<li>
<p>
~IF［
%旧-文書 にて`作動中な~view遷移$doc ~NEQ~NULL
］
⇒
`~view遷移を飛ばす$( %旧-文書 にて`作動中な~view遷移$doc, %旧-文書 に`関連な~realm$に属する `AbortError$E 例外 )
◎
If oldDocument’s active view transition is not null, then skip oldDocument’s active view transition with an "AbortError" DOMException in oldDocument’s relevant Realm.
</p>

<p class="note">注記：
これは、
当の文書が~unloadするに準備済みなときは，
走っている遷移を飛ばすことを意味する。
◎
Note: this means that any running transition would be skipped when the document is ready to unload.
</p>
	</li>
	<li>
%外へ出る遷移 ~LET %旧-文書 に`関連な~realm$に属する新たな `ViewTransition$I ~obj
◎
Let outboundTransition be a new ViewTransition object in oldDocument’s relevant Realm.
</li>
	<li>
<p>
%外へ出る遷移 にて`作動中な型~群$vT ~SET %規則からの遷移~型~群
◎
Set outboundTransition’s active types to transitionTypesFromRule.
</p>

<p class="note">注記：
`作動中な型~群$vTは、
文書~間では共有されない。
新-文書 【 %旧-文書 ？】内の `types$m を操作しても， %新-文書 内の型たちには影響しない
— それは、
%新-文書 が`露呈され$たなら，
`types$d 記述子から読取られることになる。
◎
Note: the active types are not shared between documents. Manipulating the types in the new document does not affect the types in newDocument, which would be read from the types descriptor once newDocument is revealed.
</p>

<p class="note">注記：
%外へ出る遷移【！the ViewTransition】 は、
%旧-文書 が非可視になったなら飛ばされる。
◎
Note: the ViewTransition is skipped once the old document is hidden.
</p>

	</li>
	<li class="algo">
<p>
%外へ出る遷移 の`外へ出る捕捉-後の手続き$vT ~SET 
所与の
( ［
`~view遷移~params$／ ~NULL
］ %~params )
に対し，次を遂行する手続き：
◎
Set outboundTransition’s outbound post-capture steps to the following steps given a view transition params-or-null params:
</p>
		<ol>
			<li>
<p>
%新-文書 の`内へ来る~view遷移~params$doc ~SET %~params
◎
Set newDocument’s inbound view transition params to params.
</p>

<p class="note">注記：
内へ来る遷移は、
`pagereveal$et ~eventを配送した後に作動化される
— この~event【用の~handler】において為された変異が捕捉された新-状態に適用されることを確保するため。
◎
Note: The inbound transition is activated after the dispatch of pagereveal to ensure mutations made in this event apply to the captured new state.
</p>
			</li>
			<li class="algo">
<p>
任意選択で，次の手続きを`並列的$に遂行する
— これは、
時間切れになったとき，当の遷移を飛ばすようにする：
◎
To skip the transition after a timeout, the user agent may perform the following steps in parallel:
</p>
				<ol>
					<li>
`実装定義$な`所要時間$を経るまで待機する
◎
Wait for an implementation-defined duration.
</li>
					<li>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %新-文書 に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the DOM manipulation task source given newDocument’s relevant global object to perform the following step:
</p>

<div class="algo">
手続きは
⇒
~IF［
%新-文書 の`内へ来る~view遷移~params$doc ~EQ %~params
］
⇒
%新-文書 の`内へ来る~view遷移~params$doc ~SET ~NULL
◎
• If newDocument’s inbound view transition params is params, then set newDocument’s inbound view transition params to null.
</div>
					</li>
				</ol>
			</li>
			<li>
%~naviで続行する手続き()
◎
Call proceedWithNavigation.
</li>
		</ol>
	</li>
	<li>
<p>
%旧-文書 にて`作動中な~view遷移$doc ~SET %外へ出る遷移
◎
Set oldDocument’s active view transition to outboundTransition.
</p>

<p class="note">注記：
以降の処理nは、
`処理待ち遷移~演算を遂行する$中で継続される。
◎
Note: The process continues in perform pending transition operations.
</p>
	</li>
	<li>
~RET %外へ出る遷移
◎
↓</li>
</ol>

<p>
~UAは、
【上の手続きを遂行したなら，】
直前に表示していた~frameを次に挙げる いずれか【早い方】までは表示するベキである：
◎
The user agent should display the currently displayed frame until either:
</p>
		<ul>
			<li>
%新-文書 に向けて `pagereveal$et ~eventが発火される時点
◎
The pagereveal event is fired.
</li>
			<li>
%新-文書 にて`作動中な~view遷移$docの`相$vT ~EQ `済み$i になった時点
◎
its active view transition's phase is "done".
</li>
		</ul>

<p class="note">注記：
これは、［
旧-状態を表示してから新-状態を表示するまでの間、
意図されない明滅は生じない
］ことを確保して，遷移を滑らかに保つためである。
◎
Note: this is to ensure that there are no unintended flashes between displaying the old and new state, to keep the transition smooth.
◎
Return outboundTransition.
</p>
</div>

			</section>
			<section id="update-opt-in">
<h4 title="Update the opt-in flag to reflect the current state">9.4.3. 現在の状態を反映するよう~opt-in~flagを更新する</h4>

<div class="algo">
<p>
`外へ出る遷移~用の~opt-in状態を更新する@
ときは、
所与の
( `文書$ %文書 )
に対し：
◎
To update the opt-in state for outbound transitions for a Document document:
</p>
<ol>
	<li>
<p>
%文書 の`外へ出る~view遷移を起動できるか$doc ~SET ~IS ~AND↓：
</p>
		<ul>
			<li>
%文書 の`露呈されたか$doc ~EQ ~T
</li>
			<li>
`~view遷移~規則を解決する$( %文書 ) ~NEQ `遷移を飛ばす^i
</li>
		</ul>
◎
If document has been revealed, and the result of resolving the @view-transition rule is not "skip transition", then set document’s can initiate outbound view transition to true.
◎
Otherwise, set document’s can initiate outbound view transition to false.
</li>
</ol>
</div>

			</section>
			<section id="proceed-if-skipped">
<h4 title="Proceed with navigation if view transition is skipped">9.4.4. ~view遷移が飛ばされた場合に~naviと伴に続行する</h4>

<div class="algo">
<p>
`~level 1$ の`~view遷移を飛ばす$
~algoの末尾には、
所与の
( `ViewTransition$I %遷移 )
に対し，次を遂行する段を挿入する：
◎
Append the following steps to skip the view transition given a ViewTransition transition:
</p>
<ol>
	<li>
~IF［
%遷移 の`外へ出る捕捉-後の手続き$vT ~NEQ ~NULL
］
⇒
%遷移 の`外へ出る捕捉-後の手続き$vT( ~NULL )
◎
If transition’s outbound post-capture steps is not null, then run transition’s outbound post-capture steps with null.
</li>
</ol>

<p class="note">注記：
これは、
~monkey~patch方式で書かれており，
`~level 1$ 仕様が熟したときには，その~algoの中へ併合されることになる。
◎
Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</p>
</div>

			</section>
			<section id="cross-doc-after-capture">
<h4 title="Proceed with cross-document view transition after capturing the old state">9.4.5. 旧-状態を捕捉した後に非同一-文書な~view遷移と伴に続行する</h4>

<div class="algo">
<p>
`~level 1$ の`処理待ち遷移~演算を遂行する$
~algoの先頭には、
所与の
( `文書$ %文書 )
に対し，次を遂行する段たちを挿入する：
◎
Prepend the following step to the Perform pending transition operations algorithm given a Document document:
</p>
<ol>
	<li>
%~view遷移 ~LET %文書 にて`作動中な~view遷移$doc
◎
↓</li>
	<li>
<p>
~IF［
%~view遷移 ~NEQ ~NULL
］~AND［
%~view遷移 の`外へ出る捕捉-後の手続き$vT ~NEQ ~NULL
］：
◎
If document’s active view transition is not null and its outbound post-capture steps is not null, then:
</p>
		<ol>
			<li>
~Assert：
%~view遷移 の`相$vT ~EQ `捕捉-待ち$i
◎
Assert: document’s active view transition's phase is "pending-capture".
</li>
			<li>
%~view遷移~params ~LET ~NULL
◎
Let viewTransitionParams be null;
</li>
			<li>
%文書 の`~view遷移~用の描画を抑止するか$doc ~SET ~T
◎
Set document’s rendering suppression for view transitions to true.
</li>
			<li>
<p>
%結果 ~LET `旧-状態を捕捉する$( %遷移 )
</p>

<p class="issue">
ここでは，同期的に`旧-状態を捕捉する$が、
~~本当は，非同期的に行われる
— 要素を画像の中へ描画することは
同期的には行い得ないので。
これは、
`~level 1$ 仕様にて，もっと明示的に指定されるべきである。
</p>

◎
Though capture the old state appears here as a synchronous step, it is in fact an asynchronous step as rendering an element into an image cannot be done synchronously. This should be more explicit in the L1 spec.
◎
Capture the old state for transition.
</li>
			<li>
~IF［
%結果 ~EQ `成功^i
］
⇒
%~view遷移~params ~SET 新たな`~view遷移~params$
— その
⇒＃
`有名~要素$vTP ~SET %遷移 の`有名~要素~群$vTを`~cloneする$map,
`初期~snapshot包含塊~size$vTP ~SET %遷移 の`初期~snapshot包含塊~size$vT
◎
If this succeeded, then set viewTransitionParams to a new view transition params whose named elements is a clone of transition’s named elements, and whose initial snapshot containing block size is transition’s initial snapshot containing block size.
</li>
			<li>
%文書 の`~view遷移~用の描画を抑止するか$doc ~SET ~F
◎
Set document’s rendering suppression for view transitions to false.
</li>
			<li>
`外へ出る捕捉-後の手続き$vT( %~view遷移~params )
◎
Call transition’s outbound post-capture steps given viewTransitionParams.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
これは、
~monkey~patch方式で書かれており，
`~level 1$ 仕様が熟したときには，その~algoの中へ併合されることになる。
◎
Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</p>
</div>

			</section>
		</section>
		<section id="access-view-transition-in-new-doc">
<h3 title="Activating the view transition in the new Document">9.5. 新-文書における~view遷移の作動化-法</h3>

<div class="algo">
<p>
`内へ来る非同一-文書な~view遷移を解決する@
ときは、
所与の
( `文書$ %文書 )
に対し：
◎
To resolve inbound cross-document view-transition for Document document:
</p>
<ol>
	<li>
~Assert：
%文書 は`全部的に作動中$である。
◎
Assert: document is fully active.
</li>
	<li>
~Assert：
%文書 の`露呈されたか$doc ~EQ ~T
◎
Assert: document has been revealed is true.
</li>
	<li>
`外へ出る遷移~用の~opt-in状態を更新する$( %文書 )
◎
Update the opt-in state for outbound transitions for document.
</li>
	<li>
%内へ来る~view遷移~params ~LET %文書 の`内へ来る~view遷移~params$doc
◎
Let inboundViewTransitionParams be document’s inbound view transition params.
</li>
	<li>
~IF［
%内へ来る~view遷移~params ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If inboundViewTransitionParams is null, then return null.
</li>
	<li>
%文書 の`内へ来る~view遷移~params$doc ~SET ~NULL
◎
Set document’s inbound view transition params to null.
</li>
	<li>
<p>
~IF［
%文書 にて`作動中な~view遷移$doc ~NEQ ~NULL
］
⇒
~RET ~NULL
◎
If document’s active view transition is not null, then return null.
</p>

<p class="note">注記：
これは、［
非同一-文書な遷移が処理待ちにある下で，
当の文書が露呈される前に同一-文書な遷移が開始された
］ときは，前者の遷移を取消すようにすることを意味する。
◎
Note: this means that starting a same-document transition before revealing the document would cancel a pending cross-document transition.
</p>
	</li>
	<li>
%解決-済み規則 ~LET `~view遷移~規則を解決する$( %文書 )
◎
Resolve @view-transition rule for document and let resolvedRule be the result.
</li>
	<li>
~IF［
%解決-済み規則 ~EQ `遷移を飛ばす^i
］
⇒
~RET ~NULL
◎
If resolvedRule is "skip transition", then return null.
</li>
	<li>
%遷移 ~LET %文書 に`関連な~realm$に属する新たな `ViewTransition$I
— その
⇒＃
`有名~要素~群$vT ~SET %内へ来る~view遷移~params の`有名~要素$vTP,
`初期~snapshot包含塊~size$vT ~SET %内へ来る~view遷移~params の`初期~snapshot包含塊~size$vTP
◎
Let transition be a new ViewTransition in document’s relevant Realm, whose named elements is inboundViewTransitionParams’s named elements, and initial snapshot containing block size is inboundViewTransitionParams’s initial snapshot containing block size.
</li>
	<li>
%文書 の`作動中な~view遷移$doc ~SET %遷移
◎
Set document’s active view transition to transition.
</li>
	<li>
`~promiseを解決する$( %遷移 の`更新~callback済み時の~promise$vT )
◎
Resolve transition’s update callback done promise with undefined.
</li>
	<li>
%遷移 の`相$vT ~SET `更新~callbackは~call済み$i
◎
Set transition’s phase to "update-callback-called".
</li>
	<li>
%遷移 にて`作動中な型~群$vT ~SET %解決-済み規則
◎
Set transition’s active types to resolvedRule.
</li>
	<li>
~RET %遷移
◎
Return transition.
</li>
</ol>
</div>

		</section>
		<section id="vt-class-algorithms">
<h3 title="Capturing the view-transition-class">9.6. `view-transition-class$p の捕捉-法</h3>

<div class="algo">
<p>
`~level 1$ の［
`旧-状態を捕捉する$／
`新-状態を捕捉する$
］~algoには、
所与の
( `捕捉された要素$ %捕捉, `要素$ %要素 )
に対し，次を遂行する段を挿入する†：
◎
When capturing the old or new state for an element, perform the following steps given a captured element capture and an element element:
</p>
<ol>
	<li>
~IF［
%要素 の `view-transition-class$p ~propには %要素 の`~node文書$が結付けられる††
］
⇒
%捕捉 の`~class~list$cE ~SET %要素 の `view-transition-class$p の`算出d値$
◎
Set capture’s class list to the computed value of element’s view-transition-class, if it is associated with element’s node document.
</li>
</ol>

<p class="trans-note">【†
どこに挿入するか指定されていないが、
“… ~SET 新たな捕捉された要素” と記された段より後のどこかであろう。
】【††
`~tree視野な名前$用の根として
— すなわち， %要素 の `view-transition-class^p ~propの`~cascaded値$を与えた宣言を包含する~stylesheetを~hostしている要素の`根$ ~EQ %要素 の`~node文書$
】</p>

<p class="note">注記：
これは、
~monkey~patch方式で書かれており，
`~level 1$ 仕様が熟したときには，その~algoの中へ併合されることになる。
◎
Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</p>
</div>

		</section>
		<section id="vt-group-algorithm">
<h3 title="Capturing and applying view-transition-group">9.7. `view-transition-group$p の捕捉-法と適用-法</h3>

			<section id="vt-group-value-resolve">
<h4 title="Resolving the view-transition-group value">9.7.1. `view-transition-group$p 値の解決-法</h4>

<div class="algo">
<p>
`要素$【！`Element$I】 %要素 用の
`文書~視野な~view遷移~group@
を取得するときは、
次の手続きを遂行する：
◎
To get the document-scoped view transition group of an Element element, perform the following steps:
</p>
<ol>
	<li>
%算出d~group ~LET %要素 の `view-transition-group$p ~propの`算出d値$
◎
Let computedGroup be the computed value of element’s view-transition-group property.
</li>
	<li>
~IF［
%算出d~group は %要素 の`~node文書$に結付けられている
【~node文書に結付けられた`~tree視野な名前$である】
］
⇒
~RET %算出d~group
◎
If computedGroup is associated with element’s node document, return computedGroup.
</li>
	<li>
~RET `normal$v
◎
Return normal.
</li>
</ol>
</div>

			</section>
			<section id="vt-containing-group-name-resolve">
<h4 title="Resolving the containing group name">9.7.2. 包含ng~group名の解決-法</h4>

<div class="algo">
<p>
`要素$【！`Element$I】 %要素 用の
`最も近い包含ng~group名@
を解決するときは、
所与の
( `ViewTransition$I %~view遷移 )
に対し，次の手続きを遂行する：
◎
To resolve the nearest containing group name of an Element element, perform the following steps given a ViewTransition viewTransition:
</p>
<ol>
	<li>
~Assert：
%要素 は %~view遷移 に関与する。
◎
Assert: element participates in viewTransition.
</li>
	<li>
`平坦~tree$における %要素 の
~EACH( `先祖$ %先祖 )
に対し，
%要素 に近いものから順に
⇒
~IF［
%先祖 は %~view遷移 に関与する
］~AND［
%先祖 用の`文書~視野な~view遷移~group$ ~NEQ `normal$v
］
⇒
~RET %先祖 用の`文書~視野な~view遷移~名$
◎
Let ancestorGroup be element’s nearest flat tree ancestor who participates in viewTransition and whose document-scoped view transition group is not normal.
◎
If ancestorGroup exists, return ancestorGroup’s document-scoped view transition name.
</li>
	<li>
~RET `none$v
◎
Return none.
</li>
</ol>
</div>

			</section>
			<section id="vt-group-name-resolve">
<h4 title="Resolving the group name">9.7.3. ~group名の解決-法</h4>

<div class="algo">
<p>
`要素$【！`Element$I】 %要素 用の
`使用~group名@
【 `view-transition-group$p の`使用~値$】
を解決するときは、
所与の
( `ViewTransition$I %遷移 )
に対し，次の手続きを遂行する：
◎
To resolve the used group name of an Element element, perform the following steps given a ViewTransition transition:
</p>
<ol>
	<li>
~Assert：
%要素 は %遷移 に関与する。
◎
Assert: element participates in transition.
</li>
	<li>
%~group ~LET %要素 用の`文書~視野な~view遷移~group$
◎
Let group be element’s document-scoped view transition group.
</li>
	<li>
%包含ng~group名 ~LET %要素 用の`最も近い包含ng~group名$( %遷移 )
◎
Let containingGroupName be element’s nearest containing group name given transition.
◎
↓ Return the first matching statement, switching on group:
</li>
	<li>
<p>
~IF［
%~group ~IN {
`normal@v
,
`contain@v
}
］
⇒
~RET %包含ng~group名
◎
normal
contain
• containingGroupName.
</p>

<p class="note">注記：
【`view-transition-group$p に】 `contain$v を伴う要素【の `view-transition-name$p 】は、
その子孫~用の`最も近い包含ng~group名$になる。
◎
• Note: an element with contain becomes the nearest containing group name for its descendants.
</p>
	</li>
	<li>
<p>
~ELIF［
%~group ~EQ
`nearest@v
］：
</p>
		<ol>
			<li>
`平坦~tree$における %要素 の
~EACH( `先祖$ %先祖 )
に対し，
%要素 に近いものから順に
⇒
~IF［
%先祖 は %~view遷移 に関与する
］
⇒
~RET %先祖 用の`文書~視野な~view遷移~名$
</li>
			<li>
~RET 【何を返すか指定されていない（ %包含ng~group名 ？）】
</li>
		</ol>
◎
nearest
• The document-scoped view transition name of the element’s nearest flat tree ancestor which participates in the transition.
</li>
	<li>
<p id="valdef-view-transition-group-custom-ident">
~ELSE（ %~group は `custom-ident$t である）：
</p>
		<ol>
			<li>
`平坦~tree$における %要素 の
~EACH( `先祖$ %先祖 )
に対し，
%要素 に近いものから順に
⇒
~IF［
%先祖 は %~view遷移 に関与する
］~AND［
%先祖 用の`文書~視野な~view遷移~名$ ~EQ %~group
］
⇒
~RET %~group
</li>
			<li>
~RET %包含ng~group名
</li>
		</ol>
◎
&lt;custom-ident&gt;
• group if the element has a flat tree ancestor whose document-scoped view transition name is group and participates in transition; Otherwise containingGroupName.
</li>
</ol>
</div>

			</section>
			<section id="vt-group-capture-old">
<h4 title="Compute the old view-transition-group">9.7.4. 旧- `view-transition-group$p を算出する</h4>

<div class="algo">
<p>
`~level 1$ の`旧-状態を捕捉する$
~algoには、
その［
%捕捉~要素~群 を反復する段
］の中に，次を遂行する段を挿入する：
◎
When capturing the old state for an element, perform the following steps given a captured element capturedElement, a ViewTransition transition, and an element element:
</p>
<ol>
	<li>
%捕捉 の`包含ng~group名$cE ~SET %要素 用の`使用~group名$( %遷移 )
◎
Set capturedElement’s containing group name to element’s used group name given transition.
</li>
</ol>
</div>

			</section>
			<section id="vt-group-capture-new">
<h4 title="Compute the new view-transition-group">9.7.5. 新- `view-transition-group$p を算出する</h4>

<div class="algo">
<p>
`~level 1$ の`新-状態を捕捉する$
~algoには、
その［
各 `要素$ %要素 を反復する段
］の中の最後に，次を遂行する段を挿入する：
◎
When capturing the new state for an element, perform the following steps given a captured element capturedElement a ViewTransition transition, and an element element:
</p>
<ol>
	<li>
%有名~要素~群[ %遷移~名 ] の`包含ng~group名$cE ~SET %要素 用の`使用~group名$( %遷移 )
◎
Set capturedElement’s containing group name to element’s used group name given transition.
</li>
</ol>
</div>

			</section>
			<section id="vt-group-reparent">
<h4 title="Reparent a ::view-transition-group() to its specified containing group">9.7.6. `view-transition-group()$pe の親を指定された包含ng~groupに~~改める</h4>

<div class="algo">
<p>
`~level 1$ の`遷移~疑似要素たちを設定しておく$
~algoに対しては，その中の［
%遷移 の`有名~要素~群$vTを成す
~EACH( %遷移~名 → %捕捉された要素 )
を反復する段
］ %反復~段 に関して：
◎
When setting up the transition pseudo-element for a captured element capturedElement, given a transitionName and a transition:
</p>
<ul>
	<li>
<p>
%反復~段 の前に，次を遂行する段たちを挿入する：
</p>
		<ol>
			<li>
%~group~map ~LET 新たな`有順序~map$
</li>
			<li>
%遷移 の`有名~要素~群$vTの`~key群$mapを成す
~EACH( %遷移~名 )
に対し
⇒
%~group~map[ %遷移~名 ] ~SET 新たな `view-transition-group()$pe
— その
⇒＃
`~view遷移~名$ ~SET %遷移~名
</li>
		</ol>
<p class="trans-note">【
これらの段は、
この訳による補完。
原文は，次項にて %親~group に設定するものを それが作成される前に利用しているので、
ここで予め作成しておく。
】</p>
◎
↓</li>
	<li>
<p>
%反復~段 の中の［
%~group を新たな `view-transition-group()$pe で初期化する段
］に代えて，次を遂行する：
</p>
		<ol>
			<li>
%~group ~LET %~group~map[ %遷移~名 ]
</li>
			<li>
%包含ng~group名 ~LET %捕捉された要素 の`包含ng~group名$cE
</li>
			<li>
<p>
~IF［
%包含ng~group名 ~NEQ ~NULL
］：
</p>
				<ol>
					<li>
%親~group ~LET %~group~map[ %包含ng~group名 ]
</li>
					<li>
%親~group に【その子として】 %~group を付加する
</li>
				</ol>
			</li>
		</ol>
◎
Let containingGroupName be capturedElement’s containing group name.
◎
If containingGroupName is not null, then:
• Let groupContainerElement be transition’s named elements[containingGroupName].
• Let group be the ::view-transition-group(), whose view transition name is set to transitionName.
• Let parentGroup be the ::view-transition-group(), whose view transition name is set to containingGroupName.
• Append group to parentGroup.
</li>
	<li>
<p>
%反復~段 の中の %変形 を初期化する段（ `keyframes^at 規則の構築に関与する段）の直後に，次を遂行する段を挿入する：
</p>
		<ol>
			<li>
<p>
~IF［
%包含ng~group名 ~NEQ ~NULL
］：
</p>
				<ol>
					<li>
%~group容器~要素 ~LET %遷移 の`有名~要素~群$vT[ %包含ng~group名 ]
</li>
					<li>
`入子な~group変形を調整する$( ↓ )
⇒＃
%変形,
%~group容器~要素 の`旧-変形$cE,
%~group容器~要素 の`旧-横幅$cE,
%~group容器~要素 の`旧-縦幅$cE,
%~group容器~要素 の`旧-~box~prop群$cE
</li>
				</ol>
			</li>
		</ol>
◎
• When setting the animation keyframes given transform, adjust the nested group transform to transform, given groupContainerElement’s old transform, groupContainerElement’s old width, groupContainerElement’s old height, and groupContainerElement’s old box properties.
</li>
</ul>

<p class="note">注記：
旧-~groupと新-~groupが `mismatch^en なとき，これがどう解決されるかは、
まだこれから。
`10631$issue を見よ。
◎
Note: It is TBD how this is resolved when the old and new groups mismatch. See Issue 10631.
</p>
</div>

			</section>
			<section id="vt-group-transform-adjust">
<h4 title="Adjust the group’s transform to be relative to its containing ::view-transition-group()">9.7.7. ~groupの `transform$p を それを包含している `view-transition-group()$pe に相対的に調整する</h4>

<div class="algo">
<p>
`~level 1$ の`疑似要素~styleを更新する$
~algoには、
%捕捉された要素 用の`~group~style規則$cEを設定する段
］の前に，次を遂行する段を追加する：
◎
When updating the style of the transition pseudo-element, perform the following steps before setting the group styles rule, given a captured element capturedElement, a transform, and a ViewTransition transition:
</p>
<ol>
	<li>
<p>
~IF［
%捕捉された要素 の`包含ng~group名$cE ~NEQ ~NULL
］：
◎
↓ Set capturedElement’s transform from snapshot containing block to transform.
◎
If capturedElement’s containing group name is not null, then:
</p>
		<ol>
			<li>
%~group容器~要素 ~LET %遷移 の`有名~要素~群$vT[ %捕捉された要素 の`包含ng~group名$cE ]
◎
Let groupContainerElement be transition’s named elements[capturedElement’s containing group name].
</li>
			<li>
%容器~矩形 ~LET %捕捉された要素 に応じて
⇒＃
`文書~要素$であるならば`~snapshot包含塊$／
~ELSE_ %捕捉された要素 の`~border~box$
◎
Let containerRect be snapshot containing block if capturedElement is the document element, otherwise, capturedElement’s border box.
</li>
			<li>
`入子な~group変形を調整する$( ↓ )
⇒＃
%変形,
%~group容器~要素 の`~snapshot包含塊からの変形$cE,
%容器~矩形 の横幅,
%容器~矩形 の縦幅,
%~group容器~要素 の`新-~box~prop群$cE
◎
Adjust the nested group transform to transform, given groupContainerElement’s transform from snapshot containing block, containerRect’s width, containerRect’s height, and groupContainerElement’s new box properties.
</li>
			<li>
%変形 に %~group容器~要素 の`~snapshot包含塊からの変形$cEの逆-行列を`乗算する$
【左, 右どちらから乗算するか指定されていない。】
◎
Multiply transform by the inverse matrix of groupContainerElement’s transform from snapshot containing block.
</li>
		</ol>
	</li>
	<li>
%捕捉された要素 の`~snapshot包含塊からの変形$cE ~SET %変形
◎
↑</li>
</ol>
</div>

			</section>
		</section>
		<section id="layered-capture-algorithms">
<h3 title="Capturing layered CSS properties">9.8. 層~化~CSS~prop群の捕捉-法</h3>

			<section id="layered-capture-compute-style">
<h4 title="Compute the layered-capture style">9.8.1. 層~化~捕捉~styleを算出する</h4>

<div class="algo">
<p>
`要素$【！`Element$I】 %要素 用の
`層~化~捕捉~style@
を算出するときは：
◎
To compute the layered capture style of an Element element:
• Let propertiesToCapture be a new list corresponding to the layered capture properties,
</p>
<ol>
	<li class="issue">
`overflow$p と`封込め$の挙動を指定する。
`11079$issue を見よ。
◎
Specify the behavior of overflow and containment. See issue 11079.
</li>
	<li>
%~style群 ~LET « »
◎
Let styles be a « ».
</li>
	<li>
%要素 の`層~化~捕捉~prop群$を成す
~EACH( %~prop )
に対し
⇒
%~style群 に次の結果を`付加する$
⇒
次を順に`連結する$
⇒＃
%~prop,
`:^l,
%~prop の`算出d値$,
`;^l
◎
For each property in propertiesToCapture, append the concatentation of « property, ":", element’s computed value of property, ";" » to styles.
</li>
	<li>
~RET %~style群 を`連結する$
◎
Return the concatentation of styles.
</li>
</ol>
</div>

<div class="algo">
`要素$【！`Element$I】 %要素 用の
`層~化~捕捉~幾何@
を算出するときは
⇒
~RET 新たな`層~化~box~prop群$
— その
⇒＃
`~box~sizing$lbP ~SET %要素 の `box-sizing$p の`算出d値$,
`~padding~box$lbP ~SET %要素 の`~padding~box$,
`内容~box$lbP ~SET %要素 の`内容~box$
◎
To compute the layered capture geometry of an Element element, return a new layered box properties, whose box sizing is element’s computed box-sizing, padding box is element’s padding box, and whose content box is element’s content box.
</div>

<div class="algo">
`要素$ %要素 用の
`既定の~group~size@
を算出するときは
⇒
~RET %要素 の `box-sizing$p の`算出d値$ に応じて
⇒＃
`content-box$v ならば %要素 の`内容~box$の~size／
~ELSE_ %要素 の`~border~box$の~size
◎
To compute the default group size given element return element’s content box's size if element’s computed box-sizing is content-box, otherwise element’s border box's size.
</div>

			</section>
			<section id="capture-new-layered-props-algorithm">
<h4 title="Capture the old layered properties">9.8.2. 旧-層~化~prop群を捕捉する</h4>

<div class="algo">
<p>
`~level 1$ の`新-状態を捕捉する$
~algoには、
その［
各 `要素$ %要素 を反復する段
］の中の最後に，次を遂行する段を挿入する：
◎
When capturing the old state for an element, perform the following steps given a captured element capturedElement and an element element:
</p>
<ol>
	<li>
%有名~要素~群[ %遷移~名 ] 【！capturedElement】の
⇒＃
`旧-層~化~捕捉~style$cE ~SET %要素 用の`層~化~捕捉~style$,
`旧-~box~prop群$cE ~SET %要素 用の`層~化~捕捉~幾何$,
( `旧-横幅$cE, `旧-縦幅$cE ) ~SET %要素 用の`既定の~group~size$
◎
Set capturedElement’s old layered-capture style to element’s layered capture style.
◎
Set capturedElement’s old box properties to element’s layered capture geometry.
◎
Set capturedElement’s (old width, old height to element’s default group size.
</li>
</ol>
</div>

			</section>
			<section id="capture-image-size-algorithm">
<h4 title="Adjustment to image capture size">9.8.3. 画像~捕捉~sizeに対する調整</h4>

<div class="algo">
<p>
`~level 1$ の`画像を捕捉する$
~algoは、［
その最後の段における画像の`生来な寸法$
］は %要素 の［
`~border~box$ではなく`内容~box$
］の~sizeに基づくようにする。
◎
When capturing the image, the natural dimensions of the image will be based on the element’s content box's size rather than on the border box.
</p>
</div>

			</section>
			<section id="layered-capture-rendering">
<h4 title="Render the snapshot with layered capture">9.8.4. ~snapshotを層~化~捕捉で描画する</h4>

<p>
ある要素を~snapshotの中へ捕捉するときは、
その`内容$に限り塗られる
— 当の要素の［
効果, ~box装飾
］を伴わずに。
特定的に，当の要素の：
◎
When capturing an element into a snapshot, only the element contents are painted, without the element’s effects and box decorations. Specifically,＼
</p>
<ul>
	<li>
次に挙げる~prop【による効果】は塗られない
⇒＃
`background$p,
`border$p,
`border-image$p,
`box-shadow$p,
`outline$p
◎
the element’s background, border, border-image, box-shadow, and outline are not painted,＼
</li>
	<li>
次に挙げる~propは適用されない
⇒＃
`border-radius$p,
`clip-path$p,
`filter$p,
`mask$p,
`opacity$p
◎
and its border-radius, clip-path, filter, mask, and opacity are not applied.
</li>
</ul>

			</section>
			<section id="vt-adjust-nested-group-transform">
<h4 title="Adjust the nested group transform">9.8.5. 入子な~group変形を調整する</h4>

<p>
`入子な~group変形を調整する@
ときは、
所与の
⇒＃
`行列$ %変形,
`行列$ %親~変形,
%~border~box横幅,
%~border~box縦幅,
`層~化~box~prop群$ %~box~prop群
◎終
に対し，次の手続きを遂行する：
◎
To adjust the nested group transform given a matrix transform, a matrix parentTransform, borderBoxWidth, borderBoxHeight, and a layered box properties boxProperties, perform the following steps:
</p>
<ol>
	<li>
%変形 に %親~変形 の逆-行列を`乗算する$
【左, 右どちらから乗算するか指定されていない。】
◎
Multiply transform with the inverse matrix of parentTransform.
</li>
	<li>
( %左端, %上端 ) ~LET %~box~prop群 の`~padding~box$lbPに基づく
— ( %~border~box横幅, %~border~box縦幅 ) の内側【？】にある —
~border辺
◎
Let (left, top) be the border edge based on boxProperties’s padding box inside (borderBoxWidth, borderBoxHeight).
</li>
	<li>
<p>
%変形 を
( − %左端, − %上端 ) 
で並進する【？】
◎
Translate transform by (-left, -top).
</p>

<p class="note">注記：
これらの演算は、［
この入子な~groupの既定の位置が元の要素の位置と等価になる
］ことを確保する
— 既定の入子な `view-transition-group()$pe【！':view-transition-group'】 は、
親の`~padding辺$に相対的に位置される下で。
◎
Note: These operations ensure that the default position of this nested group would be equivalent to the original element’s position, given that by default a nested ':view-transition-group' would be positioned relative to the parent’s padding edge.
</p>
	</li>
</ol>

			</section>
			<section id="vt-layered-capture-apply-keyframes">
<h4 title="Apply the old layered-capture properties to ::view-transition-group() keyframes">9.8.6. 旧-層~化~捕捉~prop群を `view-transition-group()$pe ~keyframe群に適用する</h4>

<div class="algo">
<p>
`~level 1$ の`遷移~疑似要素たちを設定しておく$
~algoには
⇒
その中で構築される `keyframes^at 規則
（ `-ua-view-transition-group-anim-*^css を名前に伴うそれ）
の宣言~block内の `from^css ~block内に`旧-層~化~捕捉~style$cEを付加する
◎
When setting up the transition pseudo-element for a captured element capturedElement, given a transitionName:
• Let keyframesName be the concatentation of « -ua-view-transition-group-anim-, transitionName »
• Append capturedElement’s old layered-capture style to the constructed rule for keyframesName.
</p>
</div>

			</section>
			<section id="vt-layered-capture-apply-new-state">
<h4 title="Apply the new layered-capture properties to ::view-transition-group()">9.8.7. 新-層~化~捕捉~prop群を `view-transition-group()$pe に適用する</h4>

<div class="algo">
<p>
`~level 1$ の`疑似要素~styleを更新する$
~algoには、
その中の［
%捕捉された要素 の`~group~style規則$cEを設定する段 %段
］に対し：
◎
When updating the style of the transition pseudo-element, perform the following steps before setting the group styles rule, given a transitionName, a capturedElement, width, height, and an Element element:
</p>

<p class="note">注記：
これは、
%横幅, %縦幅 を変更するかもしれない
◎
Note: this might change and width, height.
</p>
<ul>
	<li>
%段 にて利用される~CSSの宣言~block内に %新-要素 用の`層~化~捕捉~style$を付加する
◎
Let style be element’s layered capture style.
◎
↓</li>
	<li>
<p>
%段 の前に，次を遂行する段たちを挿入する：
◎
↑</p>
		<ol>
			<li>
%捕捉された要素 の`新-~box~prop群$cE ~SET %新-要素 の`層~化~捕捉~prop群$
◎
Set capturedElement’s new box properties to element’s layered capture properties.
</li>
			<li>
( %横幅, %縦幅 ) ~SET %新-要素 用の`既定の~group~size$
◎
Set (width, height) to the element’s default group size.
◎
↑↑ Append the concatentation of « "::view-transition-group(", transitionName, ") {", style , "}" » to the constructed user-agent stylesheet.
</li>
			<li>
( %旧-内容~横幅, %旧-内容~縦幅 ) ~LET %捕捉された要素 の`旧-~box~prop群$cEに応じて
⇒＃
~NULL ならば ( %捕捉された要素 の`旧-横幅$cE, %捕捉された要素 の`旧-縦幅$cE ) ／
~ELSE_ %捕捉された要素 の`旧-~box~prop群$cEの`内容~box$lbPの~size
◎
Let (oldContentWidth, oldContentHeight) be (capturedElement’s old width, capturedElement’s old height) if capturedElement’s old box properties is null, otherwise capturedElement’s old box properties's content box's size.
</li>
			<li>
( %新-内容~横幅, %新-内容~縦幅 ) ~LET %捕捉された要素 の`新-~box~prop群$cE に応じて
⇒＃
~NULL ならば ( %横幅, %縦幅 ) ／
~ELSE_ %捕捉された要素 の`新-~box~prop群$cEの`内容~box$lbPの~size
◎
Let (newContentWidth, newContentHeight) be (width, height) if new box properties is null, otherwise capturedElement’s new box properties's content box's size.
</li>
			<li>
<p>
~UA~stylesheetに次の~CSSを付加する【！(with replaced variables)】：
◎
Append the next string (with replaced variables) to the user agent stylesheet:
</p>

<pre class="lang-css">
@keyframes -ua-view-transition-content-geometry-%遷移~名 {
  from {
    width: %旧-内容~横幅;
    height: %旧-内容~縦幅;
  }
}

:root::view-transition-image-pair(%遷移~名) {
  position: relative;
  inset: unset;
  width: %新-内容~横幅;
  height: %新-内容~縦幅;
  animation-name: -ua-view-transition-%遷移~名;
  animation-direction: inherit;
  animation-timing-function: inherit;
  animation-iteration-count: inherit;
  animation-duration: inherit;
}
</pre>
			</li>
		</ol>
<p class="note">注記：
`view-transition-image-pair()$pe【！':view-transition-image-pair'】 疑似要素は、
当の~groupの `padding$p の効果が得られるよう，
`相対~位置決め$（ `relative^v ）を利用する。
◎
Note: the ':view-transition-image-pair' pseudo-element is using relative positioning so that the group’s padding will take effect.
</p>

	</li>
</ul>
</div>

			</section>
		</section>
	</section>
	<section id="priv">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この仕様が導入する新たな~privacy考慮点は無い。
◎
This specification introduces no new privacy considerations.
</p>

	</section>
	<section id="sec">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
非同一-生成元の課題を防止するため，現時点では、
非同一-文書な~view遷移が可能化され得るのは，同一-生成元な~naviに限られる。
それでも、
`WICG/view-transitions 課題 #200＠https://github.com/WICG/view-transitions/issues/200$
にて論じられたとおり，次に挙げる潜在的な脅威がある：
◎
To prevent cross-origin issues, at this point cross-document view transitions can only be enabled for same-origin navigations. As discussed in WICG/view-transitions#200, this still presents two potential threats:
</p>

<ol>
	<li>
新-文書, 旧-文書における`非同一-生成元~能力は隔離されるか？$enVは、
異なるかもしれない。
これは、［
この~flagが~T をとる文書
］が［
この~flagが ~F をとる文書
］から文書から画像~dataを読取れるような状況を生じさせ得る。
これは、
`~level 1$ `§ ~securityの考慮点＠~CSSVT#sec$
にて すでに軽減-済みである
— 同じ制約は、
捕捉された非同一-生成元な `iframe$e 用に適用されるので。
◎
The cross-origin isolated capability in both documents might be different. This can cause a situation where a Document that is cross-origin isolated can read image data from a document that is not cross-origin isolated. This is already mitigated in [[css-view-transitions-1#sec], as the same restriction applies for captured cross-origin iframes.
</li>
	<li>
<p>
同一-生成元な~naviは、
依然として
非同一-生成元な~redirectを介して生じるかもしれない
例：
`https://example.com^c に在る~pageが
`https://auth-provider.com/^c に在る~pageへ~linkしていて，
それが `https://example.com/loggedin^c へ戻るよう~redirectする場合。
◎
A same-origin navigation might still occur via a cross-origin redirect, e.g. https://example.com links to https://auth-provider.com/ which redirects back to https://example.com/loggedin.
</p>

<p>
これは、
非同一-生成元な主体が［
利用者を期待されない当事者-主体~URLへ~redirectする
］一方で［
期待されない遷移を生じさせる
］ことにより，
~redirectが在った事実
【非同一-生成元な文書が介入した事実】
をぼやかす（軽微な）状況を生じさせ得る。
これを軽減するため、
現時点では［
`文書$の`非同一-生成元~redirectを介して作成されたか$doc ~EQ ~T
］の場合には，~navi用の~view遷移は不能化される。
この検査は、
当の`文書$が`作動化し直され$ているときは，
適用されないことに注意
— その事例では、
非同一-生成元な~redirectが すでにその場を占めているので。
◎
This can cause a (minor) situation where the cross-origin party would redirect the user to an unexpected first-party URL, causing an unexpected transition and obfuscating that fact that there was a redirect. To mitigate this, currently view transitions are disabled for navigations if the Document was created via cross-origin redirects. Note that this check doesn’t apply when the Document is being reactivated, as in that case the cross-origin redirect has already taken place.
</p>

<p class="note">注記：
これが適用されるのは、
~server側による~redirectに限られる。
~client側による~redirect
— 例：
<code>&lt;`meta＠~HEmetadata#the-meta-element$ `http-equiv＠~HEmetadata#attr-meta-http-equiv$=`refresh＠~HEmetadata#attr-meta-http-equiv-keyword-refresh$&gt;</code>
を利用するなどによる —
は、
新たな~naviと等価になる。
◎
Note: this only applies to server-side redirects. A client-side redirect, e.g. using [^meta/http-equiv/refresh^], is equivalent to a new navigation.
</p>
	</li>
	<li>
この特能は、
~CSSに より多く情報を公開する
— これまでの~CSSは、
~naviに関係するものを何も自覚しなかったので。
これは、
第三者-主体に属する~CSSの安全性に関わる懸念を提起し得る。
しかしながら，一般~規則として、
第三者-主体に属する~stylesheetは，まずは信用される~sourceから来るベキである
— ~CSSは、［
文書について `learn^en 【？】し得る／
多くの仕方で文書【の呈示】を変更し得る
］ので。
◎
This feature exposes more information to CSS, as so far CSS was not aware of anything navigation-related. This can raise concerns around safety 3rd-party CSS. However, as a general rule, 3rd-party stylesheets should come from trusted sources to begin with, as CSS can learn about the document or change it in many ways.
</li>
</ol>

<p>
詳細な論点は、
`8684$issue,
`WICG/view-transitions 課題 #200＠https://github.com/WICG/view-transitions/issues/200$
を見よ。
◎
See Issue #8684 and WICG/view-transitions#200 for detailed discussion.
</p>

	</section>
	<section id="changes">
<h2 title="Appendix A. Changes">変更点</h2>

◎非規範的

<dl>
	<dt id="changes-since-2024-05-16">
`2024年 05月 16日 作業草案＠~TR/2024/WD-css-view-transitions-2-20240516/$
からの変更点
◎
Changes from 2024-05-16 Working Draft
</dt>
	<dd>
層~化~捕捉の初期~仕様。
（ `10585$issue ）
◎
First pass at layered capture (#10585)
</dd>
	<dd>
［
非同一-生成元~redirectを利用して作成された文書
］の中へ辿るときの遷移を許容した。
（ `11063$issue ）
◎
Allow transitions when traversing into a document that was created using cross-origin redirects (#11063#11063)
</dd>
	<dd>
入子ngに関する少数の詳細を明確化した。
（ `10780$issue, `10633$issue ）
◎
Clarify a few nesting details (#10780 and #10633)
</dd>
	<dd>
`view-transition-name$p 用の値として~keyword `auto$v を許容した。
（ `8320$issue ）
◎
Allow auto as a keyword for view-transition-name (#8320)
</dd>
	<dd>
内へ来る~view遷移~用の時間切れの挙動を明確化した。
（ `10800$issue ）
◎
Clarify timeout behavior for inbound view transition (#10800)
</dd>
	<dd>
内へ来る非同一-文書な~view遷移は、
当の文書が非可視【 `可視性~状態$doc ~EQ `hidden^l 】なときは，飛ばされるべきであるとした。
（ `9822$issue ）
◎
When hiding the document, and inbound cross-document view transition should be skipped. (#9822)
</dd>
	<dd>
`UpdateCallback^I を もっと特有な何か【 `ViewTransitionUpdateCallback$I 】に改称した。
◎
Rename UpdateCallback to something more specific.
</dd>
	<dd>
`CSSViewTransitionRule$I 【の `navigation$m 取得子】は、
`navigation$d 記述子が［
妥当でない／欠落な
］場合には，空~文字列を返すことを明確化した。
（ `10654$issue ）
◎
Clarify that CSSViewTransitionRule returns an empty string for invalid/missing navigation descriptor (#10654)
</dd>
	<dd>
入子な~view遷移~用の初期~仕様
（ `10334$issue ）
◎
Initial spec for nested view transitions (#10334)
</dd>
	<dd>
`view-transition-class$p 【の `none^v 以外の値】は`~tree視野な名前$になるものとした。
（ `10529$issue ）
◎
view-transition-class is a tree-scoped name (#10529)
</dd>
	<dd>
`CSSRule$I を廃用な~patternで拡張することをやめた。
（ `10606$issue ）
◎
Stop extending CSSRule with obsolete pattern (See #10606)
</dd>
</dl>

	</section>
</main></div>
