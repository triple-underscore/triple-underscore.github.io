<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8">
<title>CSS View Transitions Module Level 2（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">
<style>

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't': // typedef
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'at': //
	text = `@${key}`;
	break;
case 'p': // property
	break;
case 'ps': // pseudo-class
	text = `:${key}`;
	break;
case 'pe': // pseudo-element
	text = `::${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm': // IDL member
	let n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}"></a>`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:CSS View Transitions Module Level 2
spec_date:2024-03-14
trans_update:2024-03-15
source_checked:231219
page_state_key:CSS
original_url:https://drafts.csswg.org/css-view-transitions-2/
	abbr_url:CSSVT2
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-anim,css
conformance:css
copyright:2024,permissive
trans_1st_pub:2023-12-21

●●class_map
p:property
d:descriptor
ps:pseudo
pe:pseudo
t:type
css:css
at:at-rule
f:func
v:value
et:event-type
e:element
E:error
jv:js-value

●●tag_map
p:code
pe:code
ps:code
t:var
at:code
css:code
f:code
d:code
et:code
e:code
I:code
m:code
mb:code
E:code
v:code
jv:code
c:code
V:var
em:em
i:i
cite:cite

●●original_id_map

●●mdn_urls

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
sequence:~WEBIDL#idl-sequence
DOMString:~WEBIDL#idl-DOMString
unsigned short:~WEBIDL#idl-unsigned-short
E.TimeoutError:~WEBIDL#timeouterror
E.AbortError:~WEBIDL#aborterror
E.InvalidStateError:~WEBIDL#invalidstateerror
I.CSSRule:~CSSOM1#cssrule
I.DOMException:~WEBIDL#idl-DOMException
I.Document:~DOM4#document
	I.Document → 文書
I.DOMTokenList:~DOM4#domtokenlist
I.ViewTransitionNavigation:#enumdef-viewtransitionnavigation
I.CSSViewTransitionRule:#cssviewtransitionrule
I.StartViewTransitionOptions:#dictdef-startviewtransitionoptions
I.NavigationType:~HTMLnavAPI#navigationtype
I.UpdateCallback:~CSSVT#callbackdef-updatecallback
I.ViewTransition:~CSSVT#viewtransition
I.PageRevealEvent:~HTMLnavAPI#pagerevealevent
	I.PageRevealEvent:#pagerevealevent
	reveal:#pagerevealevent

	%callbackOptions:#dom-document-startviewtransition-callbackoptions-callbackoptions
m.startViewTransition:#dom-document-startviewtransition
	＠~CSSVT#dom-document-startviewtransition
m.VIEW_TRANSITION_RULE:#dom-cssrule-view_transition_rule
m.navigation:#dom-cssviewtransitionrule-navigation
m.typeList:#dom-cssviewtransitionrule-typelist
m.sessionStorage:~WEBSTORAGE#dom-sessionstorage
m.updateCallbackDone:~CSSVT#dom-viewtransition-updatecallbackdone
m.typeList:#dom-viewtransition-typelist

mb.update:#dom-startviewtransitionoptions-update
mb.type:#dom-startviewtransitionoptions-type
m.viewTransition:~WINDOW#dom-pagerevealevent-viewtransition

l.auto:#dom-viewtransitionnavigation-auto
l.none:#dom-viewtransitionnavigation-none
l.reload:~HTMLnavAPI#dom-navigationtype-reload
l.traverse:~HTMLnavAPI#dom-navigationtype-traverse
l.push:~HTMLnavAPI#dom-navigationtype-push
l.replace:~HTMLnavAPI#dom-navigationtype-replace


	●CSS/code

p.view-transition-name:~CSSVT#propdef-view-transition-name
p.view-transition-class:#propdef-view-transition-class

et.pagereveal:~HTMLindex#event-pagereveal

t.pt-class-selector:#typedef-pt-class-selector
t.pt-name-selector:~CSSVT#typedef-pt-name-selector
t.custom-ident:~CSSVAL#identifier-value
t.declaration-list:~CSSSYN#typedef-declaration-list

v.auto:#valdef-view-transition-navigation-auto
v.none:#valdef-view-transition-navigation-none

v.~noneC:#valdef-view-transition-class-none
	t.custom-ident:#valdef-view-transition-class-custom-ident

at.media:~CSSCOND#at-ruledef-media
at.supports:~CSSCOND#at-ruledef-supports
at.view-transition:#at-view-transition-rule
d.navigation:#descdef-view-transition-navigation
	d.navigation:#view-transition-navigation
d.type:#descdef-view-transition-type
	d.type:#view-transition-type

ps.active-view-transition:#active-view-transition-pseudo
ps.active-view-transition-type():#active-view-transition-type-pseudo
pe.view-transition-group():~CSSVT#selectordef-view-transition-group
pe.view-transition-image-pair():~CSSVT#selectordef-view-transition-image-pair
pe.view-transition-old():~CSSVT#selectordef-view-transition-old
pe.view-transition-new():~CSSVT#selectordef-view-transition-new


	●用語
非同一-文書な~view遷移を解決する:#resolve-cross-document-view-transition
~view遷移~規則を解決する:#resolve-view-transition-rule
非同一-文書な~view遷移を設定しておく:#setup-cross-document-view-transition
~naviは非同一-文書な~view遷移を誘発し得るか？:#navigation-can-trigger-a-cross-document-view-transition
vT.作動中な型~群:#viewtransition-active-types
vT.外へ出る捕捉-後の手続き:#viewtransition-outbound-post-capture-steps
cE.~class~list:#captured-element-class-list


doc.内へ来る~view遷移~params:#document-inbound-view-transition-params
~view遷移~params:#view-transition-params
vTP.有名~要素:#view-transition-params-named-elements
vTP.初期~snapshot包含塊~size:#view-transition-params-initial-snapshot-containing-block-size


	●用語（level 1
~level 1:#biblio-css-view-transitions-1
要素:~CSSVT#_element
	要素:~CSSDISP#elements
	要素:~CSS2J#element
~view遷移を~clearする:~CSSVT#clear-view-transition
~view遷移を作動化する:~CSSVT#activate-view-transition
doc.作動中な~view遷移:~CSSVT#document-active-view-transition
doc.~view遷移~用の描画を抑止するか:~CSSVT#document-rendering-suppression-for-view-transitions
捕捉された要素:~CSSVT#captured-element
有名~view遷移~疑似要素:~CSSVT#named-view-transition-pseudo-elements
~view遷移:~CSSVT#view-transitions
~view遷移~名:~CSSVT#view-transition-name
旧-状態を捕捉する:~CSSVT#capture-the-old-state
新-状態を捕捉する:~CSSVT#capture-the-new-state

vT.初期~snapshot包含塊~size:~CSSVT#viewtransition-initial-snapshot-containing-block-size
vT.有名~要素~群:~CSSVT#viewtransition-named-elements
処理待ち遷移~演算を遂行する:~CSSVT#perform-pending-transition-operations
vT.相:~CSSVT#viewtransition-phase
vT.旧-状態~捕捉-時の処理n:~CSSVT#viewtransition-process-old-state-captured
vT.更新~callback済み時の~promise:~CSSVT#viewtransition-update-callback-done-promise
vT.更新~callback:~CSSVT#viewtransition-update-callback
~view遷移を設定しておく:~CSSVT#setup-view-transition
~view遷移を飛ばす:~CSSVT#skip-the-view-transition

i.捕捉-待ち:~CSSVT#_pending-capture
i.済み:~CSSVT#_done
i.更新~callbackは~call済み:~CSSVT#_update-callback-called

	●用語（CSS

算出d値:~CASCADE#computed-value
詳細度:~SELECTORS4#specificity
選択子:~SELECTORS4#selector
全称~選択子:~SELECTORS4#universal-selector
型~選択子:~SELECTORS4#type-selector
	https://drafts.csswg.org/selectors-3/#x
条件付き~group規則:~CSSCOND#conditional-group-rule

	●用語（他
実装定義:~INFRA#implementation-defined
~list:~INFRA#list
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
~cloneする:~INFRA#list-clone
	~IN:~INFRA#list-contain
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
有順序~map:~INFRA#ordered-map
map.~cloneする:~INFRA#map-clone
~tuple:~INFRA#tuple

取得子~手続き:~WEBIDL#getter-steps
~method手続き:~WEBIDL#method-steps
新たな~obj:~WEBIDLjs#new
~promiseを解決する:~WEBIDLjs#resolve

文書:~DOM4#concept-document
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element
tL.~token集合:~DOM4#concept-dtl-tokens

並列的:~HTMLINFRA#in-parallel

doc.非同一-生成元~redirectを介して作成されたか:~HTMLdom#was-created-via-cross-origin-redirects

doc.可視性~状態:~HTMLinteraction#visibility-state

同一-生成元:~ORIGIN#same-origin
生成元:~ORIGIN#concept-origin

全部的に作動中:~HTMLds#fully-active
~navigable:~HTMLds#navigable
nav.作動中な~window:~HTMLds#nav-window

cnC.更新のみか:~HTMLnav#changing-nav-continuation-update-only
~BF~cache:~HTMLnav#_bf-cache
作動化し直され:~HTMLnav#reactivate-a-document
露呈され:~HTMLnav#reveal
~naviに対する利用者-関与i:~HTMLnav#user-navigation-involvement
i.~browser~UI:~HTMLnav#uni-browser-ui
doc.露呈されたか:~HTMLnav#has-been-revealed
~unloadされ:~HTMLlifecycle#unload-a-document

結付けられた文書:~WINDOW#concept-document-window

描画~機会:~WAPI#rendering-opportunity
~task:~WAPI#concept-task
大域~taskを~queueする:~WAPI#queue-a-global-task
関連な大域~obj:~WAPI#concept-relevant-global
関連な~realm:~WAPI#concept-relevant-realm
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability

●●words_table1
BQん:`
noneC:none
●●words_table

	●遷移／animation
新-:new:~
旧-:old:~
相:phase::~::フェーズ
捕捉-:capture::~
捕捉:capture::~
滑らか:smooth:~
cross-fade::::クロスフェード
	~cross-fade:crossfade
unload:
	~view遷移:view-transition
	内へ来る:inbound
	外へ出る:outbound

	●UI／呈示
明滅:flash:~
露呈-:reveal:露わに
bookmark::::ブックマーク
	~URL~bar:URL address bar
非可視:hidden:~

	●CSS
CSSOM:
For:for:用途
詳細度:specificity::~
全称:universal:~

	●処理
lifecycle:
時間切れ:timeout::~
続行-:proceed:~
処理待ち:pending:~
為され:makeされ:~
params::::パラメタ群

	直前:right before
	直前に:currently
	いつでも:At any given time
	順に経る:goes through
	経る:has
	以降:From this point forward
	渡した／渡す:pass

	%解決-済み規則:resolvedRule
	%~view遷移:viewTransition
	%外へ出る遷移:outboundTransition
	ときが来た:it’s time to
	再-作動化:reactivation
	-:accepting
	設定-法:setting up
	%~navi種別:navigationType
	%~browser~UIによる~naviか:isBrowserUINavigation
	%旧-文書:oldDocument
	%新-文書:newDocument
	%旧-生成元:oldOrigin
	%新-生成元:newOrigin
	%~naviは非同一-生成元な~redirectを経たか:navigationHasCrossOriginRedirects
	%更新~callback:updateCallback
	%文書:document
	%~view遷移~params:viewTransitionParams
	%内へ来る~view遷移~params:inboundViewTransitionParams
	%~naviで続行する手続き:proceedWithNavigation
	%飛ばされる前の遷移:preSkippedTransition
	%~token群:-
	%~token:-

	●保安
脅威:threat:~
潜在的:potential:~
提起-:raise:~
安全性:safety:~
軽微:minor:~

	第三者-主体:3rd-party
	生じさせ:causing
	その場を占めて:taken place
	事実:fact
	ぼやかす:obfuscate
	これまで:so far

	●仕様
opt-in:
monkey:
patch::::パッチ
	~monkey~patch:monkey-patch
保つ:keepする:~
併合-:merge:~
責務:responsibility:~
	責務:responsible

	意図されない:unintended
	現時点では:at this point
	まずは:to begin with
	関わる:around
	^en:learn
	おかげで:thank
	書かれ:written
	熟した:graduate
	選んだ:chosen

	●言い換え
	`文書$:Document
	文書:Document
	~BF~cache:BFCache
	互いの~page間の~link:link from page 1 to or from page 2
	`遷移を飛ばす^i:`skip transition^l
	手続き %手続き に代えて，次を遂行する:Prepend a step at the beginning of
	^e:iframe
	`~view遷移^cite:View Transitions
	~level 1$:previously
	~level 1$:L1
	~~本当は:in fact

	●未分類
step:
側:side:~
	側:-side
BF:
横取-:intercept:横取り
複写-:replicate:~
実数:number:~

	現れる:appearする
	文書:Document
	残りの:remaining
	ある種の:certain
	より多く:more
	~~設置-:put
	来る:come
	~~地点:location
	後戻りする:back
	以外:apart from

●●ref_key_map

●●ref_normative

[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-VIEW-TRANSITIONS-1]
    Tab Atkins Jr.; Jake Archibald; Khushal Sagar. ＜CSS View Transitions Module Level 1＞. URL: https://drafts.csswg.org/css-view-transitions-1/
[CSS22]
    Bert Bos. ＜Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-3]
    Tantek Çelik; et al. ＜Selectors Level 3＞. URL: https://drafts.csswg.org/selectors-3/
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-CONDITIONAL-3]
    David Baron; Elika Etemad; Chris Lilley. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより勧告候補として公開された
<a href="~SPEC_URL">CSS View Transitions Module Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-view-transitions-2/
公表履歴
	https://www.w3.org/standards/history/css-view-transitions-2/
フィードバック
	https://github.com/w3c/csswg-drafts/labels/css-view-transitions-2
編集
	Noam Rosenthal (Google)
	Khushal Sagar (Google)
	Vladimir Levin (Google)
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-view-transitions-2/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-view-transitions-2
</script>

</head>
<body>

<header>
	<hgroup>
<h1>CSS ビュー遷移 — CSS View Transitions Module Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この~moduleは、
`~view遷移^cite ~APIが非同一-文書な~naviと伴にどう働くかを定義する。
◎
This module defines how the View Transition API works with cross-document navigations.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
この節では、
公表~時点における…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
`~view遷移^cite は、
`~level 1$ にて指定されるとおり，
`文書$の視覚的な状態どうしで~animateされた遷移を作成することを開発者に許容する特能である。
◎
View Transitions, as specified in [css-view-transitions-1], is a feature that allows developers to create animated transitions between visual states of the document.
</p>

<p>
この~level 2 は、［
同一-生成元な非同一-文書な~naviにまたがる遷移を可能化するために必要yな~APIと~lifecycle
］を追加することにより，
`~level 1$ を拡張する。
◎
Level 2 extends that specification, by adding the necessary API and lifecycle to enable transitions across a same-origin cross-document navigation.
</p>

		<section id="lifecycle">
<h3 title="Lifecycle">1.1. ~lifecycle</h3>

◎非規範的

<p>
成功裡な［
非同一-文書な~view遷移
］は、
次に挙げる相を順に経る：
◎
A successful cross-document view transition goes through the following phases:
</p>
<ol>
	<li>
利用者は、［
~linkを~clickする／
~formを提出する／
~browser~UI等を利用して履歴を辿る
］などにより，
【ある`文書$ %旧-文書 から ある`文書$ %新-文書 へ】
~navigateする。
◎
The user navigates, by clicking a link, submitting a form, traversing history using the browser UI, etc.
</li>
	<li>
%旧-文書 が`~unloadされ$るときが来たとき、［
当の~naviは`同一-生成元$であって， %旧-文書 が非同一-文書な~view遷移を~opt-inした場合
］には， “旧-” 状態【 %旧-文書 の状態】が捕捉される。
◎
Once it’s time to unload the old document, if the navigation is same origin and the old Document has opted in to cross-document view-transitions, the old state is captured.
</li>
	<li>
%新-文書 に向けて
`pagereveal$et ~eventが発火される
— その `viewTransition$m ~propとして，ある `ViewTransition$I ~objを伴う。
この~objの `updateCallbackDone$m は、
すでに解決-済みであり，この~objに`捕捉された要素$たちは “旧-” 状態から拡充される。
◎
An event named pagereveal is fired on the new Document, with a viewTransition property, which is a ViewTransition object. This ViewTransition's updateCallbackDone is already resolved, and its captured elements are populated from the old Document.
</li>
	<li>
%新-文書 が最初に`描画~機会$を経る直前に，
その状態が “新-” 状態として捕捉される。
◎
Right before the new Document has the first rendering opportunity, its state is captured as the "new" state.
</li>
	<li>
以降、
`~view遷移を作動化する$手続きに従って，
当の遷移を同一-文書な遷移であったかのように継続する。
◎
From this point forward, the transition continues as if it was a same-document transition, as per activate view transition.
</li>
</ol>

		</section>
		<section id="examples">
<h3 title="Examples">1.2. 例</h3>

			<section id="cross-doc-example">
<h4 title="Cross-document view-transitions">1.2.1. 非同一-文書な~view遷移</h4>

<div class="example">
<p>
`~level 1$ の `§ 例＠~CSSVT#examples$ における最初の例と同じ~cross-fadeを生成するが、
複数の文書にまたがる【 “非同一-文書である” 】
— ~JSは必要ない。
◎
To generate the same cross-fade as in the first example CSS View Transitions 1 § 1.6 Examples, but across documents, we don’t need JavaScript.
</p>

<p>
代わりに，~page 1, ~page 2 両者において
~naviに対し~view遷移を誘発することを~opt-inする：
◎
Instead, we opt in to triggering view-transitions on navigation in both page 1 and page 2:
</p>

<pre class="lang-css">
/* <span class="comment">
両~文書において：
◎
in both documents:
</span> */
@view-transition {
  navigation: auto;
}
</pre>

<p>
互いの~page間の~linkは、
例 1 による~cross-fade遷移を生成する。
例 2, 3, 4 による効果を達成するためには、
単純に両~文書~内に疑似要素~用の~CSSを~~設置する。
◎
A link from page 1 to or from page 2 would generate a crossfade transition for example 1. To achieve the effect examples 2, 3 &amp; 4, simply put the CSS for the pseudo-elements in both documents.
</p>
</div>

<div class="example">
<p>
`例 5＠~CSSVT#_example-5$
の効果を達成するためには、
次を行う必要がある：
◎
To achieve the effect in example 5, we have to do several things:
</p>
<ul>
	<li>
両~pageにおいて，~naviにより誘発される~view遷移を~opt-inする。
◎
Opt-in to navigation-triggered view-transitions in both pages.
</li>
	<li>
新-文書に~click~~地点を渡す
— 例： `sessionStorage$m を介して。
◎
Pass the click location to the new document, e.g. via sessionStorage.
</li>
	<li>
`pagereveal$et を利用して，
新-文書~内の `ViewTransition$I ~objを横取する。
◎
Intercept the ViewTransition object in the new document, using the pagereveal event.
</li>
</ul>

<p>
両~page内には次がある：
◎
In both pages:
</p>

<pre class="lang-css">
@view-transition {
  navigation: auto;
}
</pre>

<p>
旧-~page内には次がある：
◎
In the old page:
</p>

<pre class="lang-js">
addEventListener('click', %event =&gt; {
  sessionStorage.setItem("lastClickX", %event.clientX);
  sessionStorage.setItem("lastClickY", %event.clientY);
});
</pre>

<p>
新-~page内には次がある：
◎
In the new page:
</p>

<pre class="lang-js">
/* <span class="comment">
これは、
初期~読込nと再-作動化どちらに対しても，
`~BF~cache$から走らすことになろう。
◎
This would run both on initial load and on reactivation from BFCache.
</span> */
addEventListener("pagereveal", async %event =&gt; {
  if (!%event.viewTransition)
    return;

  const %x = sessionStorage.getItem("lastClickX") ?? window.innerWidth / 2;
  const %y = sessionStorage.getItem("lastClickY") ?? window.innerHeight / 2;

  const %endRadius = Math.hypot(
    Math.max(%x, window.innerWidth - %x),
    Math.max(%y, window.innerHeight - %y)
  );

  await event.viewTransition.ready;

  /* <span class="comment">
新-文書の~viewを~animateする
◎
Animate the new document's view
</span> */
  document.documentElement.animate(
    {
      clipPath: [
        ~BQんcircle(0 at ${%x}px ${%y}px)~BQん,
        ~BQんcircle(${%endRadius}px at ${%x}px ${%y}px)~BQん,
      ],
    },
    {
      duration: 500,
      easing: 'ease-in',
      pseudoElement: '::view-transition-new(%root)'
    }
  );
})
</pre>
</div>

			</section>
			<section id="vt-class-example">
<h4 title="view-transition-class">1.2.2. `view-transition-class^p</h4>

<p>
`view-transition-class$p は、
複数の~view遷移~疑似要素~用に，同じ~styleを利用する仕方を供する
— 対応する疑似要素【による~style】を複写する必要なく。
◎
view-transition-class provides a way to use the same style for multiple view transition pseudo elements without having to replicate the corresponding pseudo-elements.
</p>

<div class="example">
<p>
この例が作成する遷移では、
各~boxは，自前の名前の下で遷移に関与する一方で，
すべての~boxの~animationに所要時間 1 秒を適用する：
◎
This example creates a transition with each box participating under its own name, while applying a 1-second duration to the animation of all the boxes:
</p>

<pre class="lang-html">
&lt;div class="box" id="red-box"&gt;&lt;/div&gt;
&lt;div class="box" id="green-box"&gt;&lt;/div&gt;
&lt;div class="box" id="yellow-box"&gt;&lt;/div&gt;
</pre>

<pre class="lang-css">
div.box {
  view-transition-class: any-box;
  width: 100px;
  height: 100px;
}
#red-box {
  view-transition-name: red-box;
  background: red;
}
#green-box {
  view-transition-name: green-box;
  background: green;
}
#yellow-box {
  view-transition-name: yellow-box;
  background: yellow;
}

/* <span class="comment">
次の~styleは、
`view-transition-class$p のおかげで，すべての~boxに適用されることになる：
◎
The following style would apply to all the boxes, thanks to 'view-transition-class'
</span> */
::view-transition-group(*.any-box) {
  animation-duration: 1s;
}
</pre>
</div>

			</section>
		</section>
	</section>
	<section id="css-properties">
<h2 title="CSS Properties">2. ~CSS~prop</h2>

		<section id="view-transition-class-prop">
<h3 title="Applying the same style to multiple participating elements: the view-transition-class property">2.1. 遷移に関与している複数の要素に対する同じ~styleの適用-法： `view-transition-class^p ~prop</h3>

◎名 `view-transition-class@p
◎値 `~noneC$v | `custom-ident$t*
◎初 `none^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`view-transition-class$p を利用すれば、
複数の`有名~view遷移~疑似要素$に対し，
`view-transition-name$p 【により指定された`~view遷移~名$】が異なっていても同じ~style規則を適用できる。
`view-transition-name$p は，
旧-状態~内にある要素と新-状態~内にある対応している要素どうしを照合するために利用されるが、
`view-transition-class$p は，
~view遷移~疑似要素
（ `view-transition-group()$pe,
`view-transition-image-pair()$pe,
`view-transition-old()$pe,
`view-transition-new()$pe ）
を利用して~styleを適用するために限り利用される。
◎
The view-transition-class can be used to apply the same style rule to multiple named view transition pseudo-elements which may have a different view-transition-name. While view-transition-name is used to match between the element in the old state with its corresponding element in the new state, view-transition-class is used only to apply styles using the view-transition pseudo-elements (::view-transition-group(), ::view-transition-image-pair(), ::view-transition-old(), ::view-transition-new()).
</p>

<p>
`view-transition-class$p は、
要素を捕捉するために~markするものではないことに注意
— その利用は、［
すでに `view-transition-name$p を有する要素を~styleする
］ための追加的な仕方に限られる。
◎
Note that view-transition-class by itself doesn’t mark an element for capturing, it is only used as an additional way to style an element that already has a view-transition-name.
</p>
<dl class="valdef">
	<dt>`~noneC@v</dt>
	<dd>
当の要素~用に生成される`有名~view遷移~疑似要素$に適用される~classは無い。
◎
No class would apply to the named view transition pseudo-elements generated for this element.
</dd>

	<dt id="valdef-view-transition-class-custom-ident">`custom-ident$t*</dt>
	<dd>
指定された `custom-ident$t 値（ `none^v 以外）すべてが、
`有名~view遷移~疑似要素$`選択子$内で利用されるときに適用される。
`none^v は、
この~prop用の `custom-ident^t としては妥当でない
— 他の `custom-ident^t と組合されたときでも。
◎
All of the specified &lt;custom-ident&gt; values (apart from none) are applied when used in named view transition pseudo-element selectors. none is an invalid &lt;custom-ident&gt; for view-transition-class, even when combined with other &lt;custom-ident&gt;s.
</dd>
	<dd class="note">注記：
同じ `view-transition-name$p が，遷移を成す［
旧-, 新-
］両~状態~内にある要素~用に指定された場合、
`view-transition-class$p の値は，新-状態~用のものに限り適用される。
このことは、
非同一-文書な~view遷移~用にも適用される：
旧-文書~内で指定された~classは、
対応する `view-transition-name$p が新-文書~内に指定されなかった場合に限り，
適用されることになる。
◎
Note: If the same view-transition-name is specified for an element both in the old and new states of the transition, only the view-transition-class values from the new state apply. This also applies for cross-document view-transitions: classes from the old document would only apply if their corresponding view-transition-name was not specified in the new document.
</dd>
</dl>

		</section>
	</section>
	<section id="pseudo-classes">
<h2 title="Pseudo-classes">3. 疑似類</h2>

		<section id="the-active-view-transition-pseudo">
<h3 title="Active View Transition Pseudo-class :active-view-transition()">3.1. 作動中な~view遷移~疑似類 `active-view-transition^ps</h3>

<p>
`active-view-transition@ps
疑似類は、
当の文書にて`作動中な~view遷移$docは ~NULL でないならば，
当の文書の根~要素に適用される。
その構文は：
◎
The :active-view-transition pseudo-class applies to the root element of the document, if it has an active view transition. It has the following syntax definition:
</p>

<pre class="prod">
:active-view-transition
</pre>

<p>
`active-view-transition$ps の`詳細度$は、
1 個の疑似類~選択子と同じになる。
◎
The specificity of an :active-view-transition is one pseudo-class selector.
</p>

<p>
`active-view-transition$ps 疑似類は、
次を満たす`文書~要素$に合致する
⇒
その`~node文書$にて`作動中な~view遷移$doc ~NEQ ~NULL
◎
An :active-view-transition pseudo-class matches the document element when its node document has an non-null active view transition.
</p>

		</section>
		<section id="the-active-view-transition-type-pseudo">
<h3 title="Active View Transition Type Pseudo-class :active-view-transition-type()">3.2. 作動中な~view遷移~型~疑似類 `active-view-transition-type()^ps</h3>

<p>
`active-view-transition-type()@ps
疑似類は、
当の文書にて`作動中な~view遷移$docは［
~NULL でない, かつ【いずれかの引数に】合致している
］ならば，
当の文書の根~要素に適用される。
その構文は：
◎
The :active-view-transition-type() pseudo-class applies to the root element of the document, if it has a matching active view transition. It has the following syntax definition:
</p>

<pre class="prod">
:active-view-transition-type(`custom-ident$t#)
</pre>

<p>
`active-view-transition-type()$ps の`詳細度$は、
【通常の疑似類とは違って，】
2 個の疑似類~選択子と同じになる。
◎
The specificity of an :active-view-transition-type() is two pseudo-class selectors.
</p>

<p>
`active-view-transition-type()$ps 疑似類は、
~AND↓ を満たす`文書~要素$に合致する：
◎
An :active-view-transition-type() pseudo-class matches the document element when＼
</p>
<ul>
	<li>
`文書~要素$の`~node文書$にて`作動中な~view遷移$doc %~view遷移 ~NEQ ~NULL
◎
its node document has an non-null active view transition,＼
</li>
	<li>
引数を成す ある `custom-ident$t ~IN %~view遷移 にて`作動中な型~群$vT
◎
whose active types contains at least one of the &lt;custom-ident&gt; arguments.
</li>
</ul>

		</section>
		<section id="active-view-transition-pseudo-examples">
<h3 title="Examples">3.3. 例</h3>

<div class="example">
<p>
例えば、
開発者は，次の方式で遷移を開始するかもしれない：
◎
For example, the developer might start a transition in the following manner:
</p>

<pre class="lang-js">
document.startViewTransition({update: %updateTheDOMSomehow, type: ["slide-in", "reverse"]});
</pre>

<p>
これは、
次に挙げる［
`active-view-transition-type()^ps ／ `active-view-transition^ps
］選択子をいずれも作動化することになる：
◎
This will activate any of the following ':active-view-transition-type()'' selectors:
</p>

<pre class="lang-css">
:root:active-view-transition-type(slide-in) {}
:root:active-view-transition-type(reverse) {}
:root:active-view-transition-type(slide-in, reverse) {}
:root:active-view-transition-type(slide-in, something-else) {}
:root:active-view-transition {}
</pre>

<p>
一方で，遷移~型を供することなく遷移を開始した場合、
`active-view-transition^ps に限り，
作動化することになる：
◎
While starting a transition without providing transition types, would only activate ':active-view-transition'':
</p>

<pre class="lang-js">
document.startViewTransition(%updateTheDOMSomehow);
/* <span class="comment">
または
◎
or
</span> */
document.startViewTransition({update: %updateTheDOMSomehow});
</pre>

<pre class="lang-css">
/* <span class="comment">
次に挙げるものは、
作動中になる：
◎
This would be active
</span> */
:root { }
:root:active-view-transition {}

/* <span class="comment">
次に挙げるものは、
作動中にならない：

◎
This would not be active
</span> */
:root:active-view-transition-type(slide-in) {}
:root:active-view-transition-type(any-type-at-all-except-star) {}
</pre>
</div>

		</section>
	</section>
	<section id="pseudo-element-additions">
<h2 title="Additions to named view-transition pseudo-elements">4. 有名~view遷移~疑似要素に対する追加</h2>


<p>
`有名~view遷移~疑似要素$
（ `view-transition-group()$pe,
`view-transition-image-pair()$pe,
`view-transition-old()$pe,
`view-transition-new()$pe ）
は、
次の構文を~supportするよう拡張される：
◎
The named view transition pseudo-elements (view-transition-group(), view-transition-image-pair(), view-transition-old(), view-transition-new()) are extended to support the following syntax:
</p>

<pre class="prod">
::view-transition-group(`pt-name-selector$t`pt-class-selector$t)
::view-transition-image-pair(`pt-name-selector$t`pt-class-selector$t)
::view-transition-old(`pt-name-selector$t`pt-class-selector$t)
::view-transition-new(`pt-name-selector$t`pt-class-selector$t)
</pre>

<p>
`pt-name-selector$t は、
`~level 1$ にて定義されたとおりに働く。
`pt-class-selector$t の構文は：
◎
where &lt;pt-name-selector&gt; works as previously defined, and &lt;pt-class-selector&gt; has the following syntax definition:
</p>

<pre class="prod">
`pt-class-selector@t
	= ['.' `custom-ident$t]*
</pre>

<p>
`有名~view遷移~疑似要素$`選択子$に合致する要素は、
`pt-class-selector$t 空であったとするとき合致する要素 %疑似要素 のうち，
次を満たすものに合致する
⇒
`pt-class-selector$t を成す どの `custom-ident^t も次を満たす
⇒
`custom-ident^t ~IN 当の~view遷移の`有名~要素~群$vT[ %疑似要素 の`~view遷移~名$【！ `view-transition-name$p】 ] の`~class~list$cE
◎
A named view transition pseudo-element selector which has one or more &lt;custom-ident&gt; values in its &lt;pt-class-selector&gt; would only match an element if the class list value in named elements for the pseudo-element’s view-transition-name contains all of those values.
</p>

<div>
<p>
`有名~view遷移~疑似要素$`選択子$の`詳細度$は、［
次を満たす場合は `zero^en 【すなわち ( 0, 0, 0 ) 】／
~ELSE_ `型~選択子$と等価【すなわち ( 0, 0, 1 ) 】
］になる
⇒
［
`pt-name-selector$t として `*^css （`全称~選択子$）をとる
］~AND［
`pt-class-selector$t は空である
］
</p>
◎
The specificity of a named view transition pseudo-element selector with either:
• a &lt;pt-name-selector&gt; with a &lt;custom-ident&gt;; or
• a &lt;pt-class-selector&gt; with at least one &lt;custom-ident&gt;,
◎
is equivalent to a type selector.
◎
The specificity of a named view transition pseudo-element selector with a * argument and with an empty &lt;pt-class-selector&gt; is zero.
</div>

	</section>
	<section id="css-rules">
<h2 title="CSS rules">5. ~CSS規則</h2>

		<section id="view-transition-rule">
<h3 title="The @view-transition rule">5.1. `view-transition^at 規則</h3>

<p>
`view-transition@at
~at-規則は、
次を指示するために利用される
⇒
非同一-文書~naviは、
`ViewTransition$I を設定しておいて作動化するベキである
【順に，`非同一-文書な~view遷移を設定しておく$, `~view遷移を作動化する$】
◎
The @view-transition rule is used by a document to indicate that cross-document navigations should setup and activate a ViewTransition.＼
</p>

<p>
［
旧-文書／新-文書
］において，この規則の効果が発揮されるためには、［
当の文書が`~unloadされ$る／
`pagereveal$et ~eventが発火される【当の文書が`露呈され$る】
］時点で，当の文書~内にそれが在ることが要求される。
◎
To take effect, it must be present in the old document when unloading, and in the new document when the pagereveal is fired.
</p>

		</section>
		<section id="view-transition-grammar">
<h3 title="@view-transition rule grammar">5.2. `view-transition^at 規則の文法</h3>

<p>
`view-transition$at 規則の構文は：
◎
The @view-transition rule has the following syntax:
</p>

<pre class="prod">
@view-transition {
  `declaration-list$t
}
</pre>

<p class="note">注記：
既定の挙動に倣い、
`view-transition$at 規則は，`条件付き~group規則$
— `media$at や `supports$at など —
の内側に入子にできる。
◎
Note: as per default behavior, the @view-transition rule can be nested inside a conditional group rule such as @media or @supports.
</p>

		</section>
		<section id="view-transition-navigation-descriptor">
<h3 title="The navigation descriptor">5.3. `navigation^d 記述子</h3>

◎述 `navigation@d
◎用 `view-transition$at
◎値 `auto$v | `none$v
◎初 `none$v
◎表終

<p>
`navigation$d 記述子は、［
ある種の種別の~naviを遂行する
］ときに［
ある~view遷移を自動的に開始する
］ことを~opt-inする。
それは、［
旧-文書, 新-文書
］どちらにおいても
（前者は`~unloadされ$る時点で, 後者は`露呈され$る時点で）
可能化される必要がある。
◎
The 'navigation' descriptor opts in to automatically starting a view transition when performing a navigation of a certain type. It needs to be enabled both in the old document (when unloading) and in the new document (when reveal).
</p>

<dl>
	<dt>`none@v</dt>
	<dd>
遷移は無い。
◎
There will be no transition.
</dd>

	<dt>`auto@v</dt>
	<dd>
<p>
遷移は、
当の~naviが ~AND↓ を満たす場合には可能化されることになる：
</p>
		<ul>
			<li>
同一-生成元である
</li>
			<li>
非同一-生成元な~redirectを伴わない
</li>
			<li>
<p>
~OR↓
</p>
				<ul>
					<li>
その `NavigationType$I ~EQ `traverse$l
◎
traverse or
</li>
					<li>
［
その `NavigationType$I ~IN { `push$l, `replace$l }
］~AND［
`~naviに対する利用者-関与i$ ~NEQ `~browser~UI$i
］
◎
push or replace with user navigation involvement not equal to "browser UI".
</li>
				</ul>
			</li>
		</ul>
◎
The transition will be enabled if the navigation is same-origin, without cross-origin redirects, and whoes NavigationType is
• traverse or
• push or replace with user navigation involvement not equal to "browser UI".
</dd>
	<dd class="note">注記：
`auto$v から除外される~naviは、
例えば，次を介して~navigateすることである
⇒＃
~URL~bar／
~bookmarkを~clickすること
利用者や~scriptが起動した `reload$l
◎
Note: Navigations excluded from auto are for example, navigating via the URL address bar or clicking a bookmark, as well as any form of user or script initiated reload.
</dd>
</dl>

		</section>
		<section id="view-transition-type-descriptor">
<h3 title="The type descriptor">5.4. `type^d 記述子</h3>

◎述 `type@d
◎用 `view-transition$at
◎値 `none^v | `custom-ident$t*
◎初 `none^v
◎表終

<p>
`type$d 記述子は、
~view遷移を捕捉して遂行するときに，当の遷移にて`作動中な型~群$vTを設定する
— それは、
`startViewTransition(callbackOptions)$m を
— %callbackOptions の `type$mb に その値を与える下で —
~callすることに等価になる。
◎
The 'type' descriptor sets the active types for the transition when capturing and performing the transition, equivalent to calling startViewTransition(callbackOptions) with that type.
</p>

<p class="note">注記：
`type$d 記述子が適用されるのは、
それを定義した`文書$に限られる。
作者が選んだ型たちが成す集合を新-旧-両~文書~内で利用する責務は、
作者にある。
◎
Note: the type descriptor only applies to the Document in which it is defined. The author is responsible for using their chosen set of types in both documents.
</p>

		</section>
	</section>
	<section id="api">
<h2 title="API">6. ~API</h2>

		<section id="additions-to-document-api">
<h3 title="Additions to Document">6.1. `Document^I に対する追加</h3>

<pre class="idl">
dictionary `StartViewTransitionOptions@I {
  `UpdateCallback$I? `update@mb = null;
  `sequence$&lt;`DOMString$&gt;? `type@mb = null;
};

partial interface `Document$I {

  `ViewTransition$I `startViewTransition$m(optional (`UpdateCallback$I or `StartViewTransitionOptions$I) %callbackOptions = {});
};
</pre>

<div class="algo">
<p id="ViewTransition-start-with-options">
`startViewTransition(callbackOptions)@m
`~method手続き$は：
◎
4.1.1. startViewTransition(callbackOptions) Method Steps
◎
The method steps for startViewTransition(callbackOptions) are as follows:
</p>
<ol>
	<li>
%更新~callback ~LET ~NULL
◎
Let updateCallback be null.
</li>
	<li>
~IF［
%callbackOptions は `UpdateCallback$I である
］
⇒
%更新~callback ~SET %callbackOptions
◎
If callbackOptions is an an UpdateCallback, set updateCallback to callbackOptions.
</li>
	<li>
~ELIF［
%callbackOptions は `StartViewTransitionOptions$I である
］
⇒
%更新~callback ~SET %callbackOptions[ "`update$mb" ]
◎
Otherwise, if callbackOptions is a StartViewTransitionOptions, then set updateCallback to callbackOptions’s update.
</li>
	<li>
%作動中な遷移 ~LET コレにて`作動中な~view遷移$doc
◎
↓</li>
	<li>
<p>
~IF［
%作動中な遷移 ~NEQ ~NULL
］~AND［
%作動中な遷移 の`外へ出る捕捉-後の手続き$vT ~NEQ ~NULL
］：
◎
If this’s active view transition is not null and its outbound post-capture steps is not null, then:
</p>
		<ol>
			<li>
%飛ばされる前の遷移 ~LET コレに`関連な~realm$に属する新たな `ViewTransition$I
— その
⇒＃
`更新~callback$vT ~SET %更新~callback
◎
Let preSkippedTransition be a new ViewTransition in this’s relevant realm whose update callback is updateCallback.
</li>
			<li>
`~view遷移を飛ばす$( %飛ばされる前の遷移, `InvalidStateError$E 例外 )
◎
Skip preSkippedTransition with an "InvalidStateError" DOMException.
</li>
			<li>
~RET %飛ばされる前の遷移
◎
Return preSkippedTransition.
</li>
		</ol>
	</li>
	<li>
%~view遷移 ~LET コレ上の［
`~level 1$ に定義される `startViewTransition＠~CSSVT#dom-document-startviewtransition$m 用の`~method手続き$
］( %更新~callback )
◎
Let viewTransition be the result of running the method steps for startViewTransition(updateCallback) given updateCallback.
</li>
	<li>
<p>
~IF［
%callbackOptions は `StartViewTransitionOptions$I である
］：
【！`~cloneする$】
</p>
		<ol>
			<li>
%~token群 ~LET 新たな`有順序~集合$
</li>
			<li>
%callbackOptions[ "`type$mb" ] を成す
~EACH( %~token )
に対し
⇒
%~token群 に %~token を`付加する$set
</li>
			<li>
%~view遷移 にて`作動中な型~群$vTの`~token集合$tL ~SET %~token群
</li>
		</ol>

<p class="trans-note">【
`~token集合$tLを成す各~tokenは、
内部的には任意の文字列をとり得るが，
`DOMTokenList$I ~APIによる操作においては［
空白を包含し得ない, かつ空~文字列にもなり得ない
］よう制約される。
一方で、
`type$mb を成す文字列たちには，そのような制約は無い。
この段は、
各 %~token を そのように制約する処理nが必要かもしれない
— さもなければ、
そのような制約を満たさない~tokenを~APIからは除去したり置換できなくなるので。
】</p>

◎
If callbackOptions is a StartViewTransitionOptions, set viewTransition’s active types's token set to a clone of type as a set.
</li>
	<li>
~RET %~view遷移
◎
Return viewTransition.
</li>
</ol>
</div>

		</section>
		<section id="extensions-to-cssrule-interface">
<h3 title="Extensions to the CSSRule interface">6.2. `CSSRule^I ~interfaceに対する拡張</h3>

<p>
`CSSRule$I ~interfaceは
次に従って拡張される：
◎
The CSSRule interface is extended as follows:
</p>

<pre class="idl">
partial interface `CSSRule$I {
  const `unsigned short$ `VIEW_TRANSITION_RULE@m = 15;
};
</pre>

		</section>
		<section id="navgation-behavior-rule-interface">
<h3 title="The CSSViewTransitionRule interface">6.3. `CSSViewTransitionRule^I ~interface</h3>

<p>
`CSSViewTransitionRule$I は、
ある `view-transition$at 規則を表現する。
◎
The CSSViewTransitionRule represents a @view-transition rule.
</p>

<pre class="idl">
enum `ViewTransitionNavigation@I { `auto@l, `none@l };
[`Exposed$=Window]
interface `CSSViewTransitionRule@I : `CSSRule$I {
  attribute `ViewTransitionNavigation$I `navigation@m;
  attribute `DOMTokenList$I `typeList@m;
};
</pre>

		</section>
	</section>
	<section id="algorithms">
<h2 title="Algorithms">7. ~algo</h2>

		<section id="concepts">
<h3 title="Data Structures">7.1. ~data構造</h3>

			<section id="additions-to-document">
<h4 title="Additions to Document">7.1.1. 文書に対する追加</h4>

<p>
各`文書$は、
次に挙げるものを追加的に有する：
◎
A Document additionaly has:
</p>
<ul>
	<li>
`内へ来る~view遷移~params@doc
⇒
ある`~view遷移~params$ ／ ~NULL
— 初期~時は~NULLとする。
◎
inbound view transition params
◎
a view transition params, or null. Initially null.
</li>
</ul>

<p class="trans-note">【
［
“内へ来る（ `inbound^en ）〜” ／
“外へ出る（ `outbound^en ）〜”
］は、
非同一-文書な遷移に利用される概念であり，
“〜 は［
新-文書／旧-文書
］に結付けられたものである”
ことを意味する。
】</p>

			</section>
			<section id="view-transition-params-struct">
<h4 title="The View transition params struct">7.1.2. ~view遷移~params</h4>

<p>
`~view遷移~params@
は、
次に挙げる`~item$sctからなる`構造体$である。
その目的は、
文書たちにまたがって，~view遷移~情報を直列化する
【旧-文書から新-文書へ情報を渡す】
ことにある：
◎
A view transition params is a struct whose purpose is to serialize view transition information across documents. It has the following items:
</p>
<ul>
	<li>
`有名~要素@vTP
⇒
`有順序~map$
— 各~entryの［
~keyは文字列／
値は`捕捉された要素$
］を与える。
◎
named elements
• a map, whose keys are strings and whose values are captured elements.
</li>
	<li>
`初期~snapshot包含塊~size@vTP
⇒
2 個の実数 ( 横幅, 縦幅 ) が成す`~tuple$。
◎
initial snapshot containing block size
• a tuple of two numbers (width and height).
</li>
</ul>

			</section>
			<section id="view-transitions-extension">
<h4 title="Additions to ViewTransition">7.1.3. `ViewTransition^I に対する追加</h4>

<p>
`ViewTransition$I ~interfaceは、
次に従って拡張される：
◎
The ViewTransition interface is extended as follows:
</p>

<pre class="idl">
partial interface `ViewTransition$I {
  readonly attribute `DOMTokenList$I `typeList$m;
};
</pre>

<div class="algo">
`typeList@m
`取得子~手続き$は
⇒
~RET コレにて`作動中な型~群$vT
◎
The typeList getter steps are to return this's active types.
</div>

<p>
各 `ViewTransition$I は、
次に挙げるものを追加的に有する：
◎
A ViewTransition additionally has:
</p>
<ul>
	<li>
`外へ出る捕捉-後の手続き@vT
⇒
~NULL ／ ある手続き
— 初期~時は ~NULL とする。
◎
outbound post-capture steps
• Null or a set of steps, initially null.
</li>
	<li>
`作動中な型~群@vT
⇒
`DOMTokenList$I
— 初期~時は新たな `DOMTokenList$I とする。
◎
active types
• A DOMTokenList, initially a new DOMTokenList.
</li>
</ul>

			</section>
			<section id="additions-to-captured-element-struct">
<h4 title="Additions to captured element struct">7.1.4. `捕捉された要素$に対する追加</h4>

<p>
構造体 `捕捉された要素$は、
次に挙げる~item【！~field】も伴うベキである：
◎
The captured element struct should contain these fields, in addition to the existing ones:
</p>

<dl>
	<dt>`~class~list@cE</dt>
	<dd>
文字列たちが成す`~list$
◎
a list of strings,＼
</dd>
	<dd>
初期~時は空とする。
◎
initially empty.
</dd>
</dl>

			</section>
		</section>
		<section id="vt-class-algorithms">
<h3 title="Algorithms to capture view-transition-class:">7.2. `view-transition-class$p に対し捕捉する~algo</h3>

<div class="algo">
<p>
`~level 1$ の［
`旧-状態を捕捉する$／
`新-状態を捕捉する$
］~algoには、
【 “新たな捕捉された要素” を設定する段の後に】
所与の
( `捕捉された要素$ %捕捉, `要素$ %要素 )
に対し，次を遂行する段を追加する
⇒
%捕捉 の`~class~list$cE ~SET %要素 の `view-transition-class$p の`算出d値$
◎
When capturing the old or new state for an element, perform the following steps given a captured element capture and an element element:
• Set capture’s class list to the computed value of element’s view-transition-class.
</p>

<p class="note">注記：
これは、
~monkey~patch方式で書かれており，
`~level 1$ 仕様が熟したときには，その~algoの中へ併合されることになる。
◎
Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</p>
</div>

		</section>
		<section id="additional-skip-steps">
<h3 title="Additions to skip steps:">7.3. 遷移を飛ばす手続きに対する追加</h3>

<div class="algo">
<p>
`~level 1$ の`~view遷移を飛ばす$ ~algoの末尾には、
所与の
( `ViewTransition$I %遷移 )
に対し，次を遂行する段を追加する：
◎
Append the following steps to skip the view transition given a ViewTransition transition:
</p>

<ol>
	<li>
~IF［
%遷移 の`外へ出る捕捉-後の手続き$vT ~NEQ ~NULL
］
⇒
%遷移 の`外へ出る捕捉-後の手続き$vT( ~NULL )
◎
If transition’s outbound post-capture steps is not null, then run transition’s outbound post-capture steps with null.
</li>
</ol>

<p class="note">注記：
これは、
~monkey~patch方式で書かれており，
`~level 1$ 仕様が熟したときには，その~algoの中へ併合されることになる。
◎
Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</p>
</div>

		</section>
		<section id="additions-to-pending-transition-operation">
<h3 title="Addition to pending transition operations">7.4. 処理待ち遷移~演算に対する追加</h3>

<div class="algo">
<p>
`~level 1$ の`処理待ち遷移~演算を遂行する$ ~algoの先頭には、
所与の
( `文書$ %文書 )
に対し，次を遂行する段たちを追加する：
◎
Prepend this to the Perform pending transition operations algorithm given a Document document:
</p>
<ol>
	<li>
%~view遷移 ~LET %文書 にて`作動中な~view遷移$doc
◎
↓</li>
	<li>
<p>
~IF［
%~view遷移 ~NEQ ~NULL
］~AND［
%~view遷移 の`外へ出る捕捉-後の手続き$vT ~NEQ ~NULL
］：
◎
If document’s active view transition is not null and its outbound post-capture steps is not null, then:
</p>
		<ol>
			<li>
~Assert：
%~view遷移 の`相$vT ~EQ `捕捉-待ち$i
◎
Assert: document’s active view transition's phase is "pending-capture".
</li>
			<li>
%~view遷移~params ~LET ~NULL
◎
Let viewTransitionParams be null;
</li>
			<li>
%文書 の`~view遷移~用の描画を抑止するか$doc ~SET ~T
◎
Set document’s rendering suppression for view transitions to true.
</li>
	<li>
<p>
%結果 ~LET `旧-状態を捕捉する$( %遷移 )
</p>

<p class="issue">
ここでは，同期的に`旧-状態を捕捉する$が、
~~本当は，非同期的に行われる
— 要素を画像の中へ描画することは
同期的には行い得ないので。
これは、
`~level 1$ 仕様にて，もっと明示的に指定されるべきである。
</p>

◎
though capture the old state appears here as a synchronous step, it is in fact an asynchronous step as rendering an element into an image cannot be done synchronously. This should be more explicit in the L1 spec.
◎
Capture the old state for transition.
</li>
	<li>
%文書 の`~view遷移~用の描画を抑止するか$doc ~SET ~F
◎
Set document’s rendering suppression for view transitions to false.
</li>
	<li>
~IF［
%結果 ~EQ `成功^i
］
⇒
%~view遷移~params ~SET 新たな`~view遷移~params$
— その
⇒＃
`有名~要素$vTP ~SET %遷移 の`有名~要素~群$vTを`~cloneする$map,
`初期~snapshot包含塊~size$vTP ~SET %遷移 の`初期~snapshot包含塊~size$vT
◎
If this succeeded, then set viewTransitionParams to a new view transition params whose named elements is a clone of transition’s named elements, and whose initial snapshot containing block size is transition’s initial snapshot containing block size.
</li>
	<li>
`~view遷移を~clearする$( %遷移 )
◎
Clear view transition transition.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="monkey-patch-to-html">
<h3 title="Monkey patches to HTML">7.5. ~HTMLに対する~monkey~patch</h3>

<div>

<p class="trans-note">【
この節を成す内容
（ `履歴~stepを適用する~algo＠~HTMLnav#apply-the-history-step$における非同一-文書な~view遷移~用の~patch）
は，今や~HTMLに`統合された＠~HTMLissue/9702$ものと見受けられるので
（少なくとも，~HTMLの更新に整合でない）、
和訳は省略する。
】</p>
◎
Prepend these steps at the beginning of the task queued on navigable’s active window when applying the history step (14.11.1, here):
◎
This monkey-patch step assumes a boolean changingNavigationContinuation, a navigable navigable, a Document oldDocument, a Document newDocument, a NavigationType navigationType, and a user navigation involvement userInvolvementForNavigateEvents.
• Let isBrowserUINavigation be true if userInvolvementForNavigateEvents is "browser UI", otherwise false.
• If changingNavigationContinuation update-only is false, then setup cross-document view-transition given oldDocument, newDocument, navigationType, isBrowserUINavigation, and the remaining steps and return from these steps.
◎
Note: This would wait until a transition is captured or skipped before proceeding to unloading the old document and activating the new one.
</div>

		</section>
		<section id="setting-up-and-activating-the-cross-document-view-transition">
<h3 title="Setting up and activating the cross-document view transition">7.6. 非同一-文書な~view遷移の設定-法と作動化-法</h3>

			<section id="resolve-view-transition-rule-algo">
<h4 title="Resolving the @view-transition' rule">7.6.1. `view-transition$at 規則の解決-法</h4>

<div class="algo">
<p>
`~view遷移~規則を解決する@
ときは、
所与の
( `文書$ %文書 )
に対し：
◎
To get the resolve @view-transition rule for a Document document:
</p>
<ol>
	<li>
~IF［
%文書 の`可視性~状態$doc ~EQ `hidden^l
］
⇒
~RET `遷移を飛ばす^i
◎
If document’s visibility state is "hidden", then return "skip transition".
</li>
	<li>
<p>
%合致している規則 ~LET %文書 内に `view-transition$at 規則は［
在るならば それらのうち最後のもの／
無いならば ε
］
</p>

<p class="trans-note">【
`条件付き~group規則$内に入子にされ，条件が満たされないため無視される規則は、
この段の目的においては，無かったものと見なされよう。
】</p>
◎
Let matchingRule be the last @view-transition rule in document.
</li>
	<li>
~IF［
%合致している規則 ~EQ ε
］
⇒
~RET `遷移を飛ばす^i
◎
If matchingRule is not found, then return "skip transition".
</li>
	<li>
~IF［
%合致している規則 の `navigation$d 記述子の`算出d値$ ~EQ `none$v
］
⇒
~RET `遷移を飛ばす^i
◎
If matchingRule’s navigation descriptor’s computed value is none, then return "skip transition".
</li>
	<li>
~Assert：
%合致している規則 の `navigation$d 記述子の`算出d値$ ~EQ `auto$v
◎
Assert: matchingRule’s navigation descriptor’s computed value is auto.
</li>
	<li>
%型~群~記述子 ~LET %合致している規則 の `type$d 記述子の`算出d値$
◎
Let typesDescriptor be matchingRule’s type descriptor.
</li>
	<li>
~IF［
%型~群~記述子 ~EQ `none^v
］
⇒
~RET 新たな`有順序~集合$
◎
If typesDescriptor’s computed value is none, then return a set « ».
</li>
	<li>
<p>
~RET %型~群~記述子 を成す文字列たちが成す`有順序~集合$
◎
Return a set of strings corresponding to typesDescriptor’s computed value.
</p>

<p class="trans-note">【
集合なので、
重複する文字列たちは，一つ（おそらく，最初のそれ）だけ残して他は除去されることになる。
】</p>

	</li>
</ol>
</div>

			</section>
			<section id="setup-old-document-vt">
<h4 title="Setting up the view-transition in the old Document">7.6.2. 旧-文書~内で~view遷移を設定しておく</h4>

<div class="algo">
<p>
`~naviは非同一-文書な~view遷移を誘発し得るか？@
検査するときは、
所与の
⇒＃
`生成元$ %旧-生成元,
`生成元$ %新-生成元,
真偽値 %~naviは非同一-生成元な~redirectを経たか,
`NavigationType$I %~navi種別,
真偽値 %~browser~UIによる~naviか
◎終
に対し：
◎
To check if a navigation can trigger a cross-document view-transition? given an origin oldOrigin, an origin newOrigin, a boolean navigationHasCrossOriginRedirects, a NavigationType navigationType, and a boolean isBrowserUINavigation:
</p>

<p class="note">注記：
これは、
~naviの間に［
~callされる／`並列的$に~callされる
］
— `view-transition$at 規則を利用して~view遷移を~opt-inした文書~用に。
◎
Note: this is called during navigation, potentially in parallel, for documents that have opted-in to view-transitions using the @view-transition rule.
</p>

<ol>
	<li>
任意選択で
⇒
~IF［
~UAは`実装定義$な~navi体験を表示するものと裁定した
（例： ~gestureに基づく後戻りする~navi用の遷移）
］
⇒
~RET ~F
（~UAは作者-定義な~view遷移を無視してもヨイ。）
◎
If the user agent decides to display an implementation-defined navigation experience, e.g. a gesture-based transition for a back navigation, the user agent may ignore the author-defined view transition. If that is the case, return false.
</li>
	<li>
~IF［
%~navi種別 ~EQ `reload$l
］
⇒
~RET ~F
◎
If navigationType is reload, then return false.
</li>
	<li>
~IF［
%~browser~UIによる~naviか ~EQ ~T
］~AND［
%~navi種別 ~IN { `push$l, `replace$l }
］
⇒
~RET ~F
◎
If isBrowserUINavigation is true, and navigationType is push or replace, then return false.
</li>
	<li>
~IF［
( %旧-生成元, %新-生成元 )
は`同一-生成元$でない
］
⇒
~RET ~F
◎
If oldOrigin is not same origin as newOrigin then return false.
</li>
	<li>
~IF［
%~naviは非同一-生成元な~redirectを経たか ~EQ ~T
］
⇒
~RET ~F
◎
If navigationHasCrossOriginRedirects is true, then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`非同一-文書な~view遷移を設定しておく@
ときは、
所与の
⇒＃
`文書$ %旧-文書,
`文書$ %新-文書,
~algo %~naviで続行する手続き
◎終
に対し：
◎
To setup cross-document view-transition given a Document oldDocument, a Document newDocument, and proceedWithNavigation, which is an algorithm accepting nothing: 
</p>
<ol>
	<li>
~Assert：
この手続きは、
%旧-文書 に対し~queueされた`~task$を成す一部として走っている。
◎
Assert: These steps are running as part of a task queued on oldDocument.
</li>
	<li>
~IF［
%旧-文書 の`露呈されたか$doc ~EQ ~F
］
⇒
~RET ~NULL
◎
If oldDocument’s has been revealed is false, then return null.
</li>
	<li>
%解決-済み規則 ~LET `~view遷移~規則を解決する$( %旧-文書 )
◎
Let resolvedRule be the result of resolving the @view-transition rule for oldDocument.
</li>
	<li>
<p>
~IF［
%解決-済み規則 ~EQ `遷移を飛ばす^i
］
⇒
~RET ~NULL
◎
If resolvedRule is "skip transition", then return null.
</p>

<p class="note">注記：
%新-文書 は，構文解析-済みでないかもしれないので、
それが~opt-inされたかどうかは，まだ知れない。
%新-文書 用に~opt-inを検査するのは、
`pagereveal$et ~eventが発火されたときになる。
◎
Note: We don’t know yet if newDocument has opted in, as it might not be parsed yet. We check the opt-in for newDocument when we fire the pagereveal event.
</p>
	</li>
	<li>
<p>
~IF［
%旧-文書 にて`作動中な~view遷移$doc ~NEQ~NULL
］
⇒
`~view遷移を飛ばす$( %旧-文書 にて`作動中な~view遷移$doc, %旧-文書 に`関連な~realm$に属する `AbortError$E 例外 )
◎
If oldDocument’s active view transition is not null, then skip oldDocument’s active view transition with an "AbortError" DOMException in oldDocument’s relevant Realm.
</p>

<p class="note">注記：
これは、
当の文書が~unloadするに準備済みなときは，
走っている遷移を飛ばすことを意味する。
◎
Note: this means that any running transition would be skipped when the document is ready to unload.
</p>
	</li>
	<li>
%外へ出る遷移 ~LET %旧-文書 に`関連な~realm$に属する新たな `ViewTransition$I ~obj
◎
Let outboundTransition be a new ViewTransition object in oldDocument’s relevant Realm.
</li>
	<li>
<p>
%外へ出る遷移 の`作動中な型~群$vTの`~token集合$tL ~SET %解決-済み規則
◎
Set outboundTransition’s active types's token set to resolvedRule.
</p>

<p class="note">注記：
`作動中な型~群$vTは、
文書~間では共有されない。
%新-文書【 %旧-文書 ？】内の `typeList$m を操作しても， %新-文書 内の型たちには影響しない
— それは、
当の文書が`露呈され$たなら，
`type$d 記述子から読取られることになる。
◎
Note: the active types are not shared between documents. Manipulating the typeList in the new document does not affect the types in the new document, which would be read from the type descriptor once the document is revealed.
</p>

<p class="note">注記：
%外へ出る遷移【！the ViewTransition】 は、
%旧-文書 が非可視になったなら飛ばされる。
◎
Note: the ViewTransition is skipped once the old document is hidden.
</p>

	</li>
	<li class="algo">
<p>
%外へ出る遷移 の`外へ出る捕捉-後の手続き$vT ~SET 
所与の
( ［
`~view遷移~params$／ ~NULL
］ %~params )
に対し，次を遂行する手続き：
◎
Set outboundTransition’s outbound post-capture steps to the following steps given a view transition params-or-null params:
</p>
		<ol>
			<li>
<p>
%新-文書 の`内へ来る~view遷移~params$doc ~SET %~params
◎
Set newDocument’s inbound view transition params to params.
</p>

<p class="note">注記：
内へ来る遷移は、
`pagereveal$et ~eventを配送した後に作動化される
— この~event【用の~handler】において為された変異が捕捉された新-状態に適用されることを確保するため。
◎
Note: The inbound transition is activated after the dispatch of pagereveal to ensure mutations made in this event apply to the captured new state.
</p>
			</li>
			<li>
%~naviで続行する手続き()
◎
Call proceedWithNavigation.
</li>
		</ol>
	</li>
	<li>
<p>
%旧-文書 にて`作動中な~view遷移$doc ~SET %外へ出る遷移
◎
Set oldDocument’s active view transition to outboundTransition.
</p>

<p class="note">注記：
以降の処理nは、
`処理待ち遷移~演算を遂行する$中で継続される。
◎
Note: The process continues in perform pending transition operations.
</p>
	</li>
	<li>
~RET %外へ出る遷移
◎
↓</li>
</ol>

<p>
~UAは、
【上の手続きを遂行したなら，】
直前に表示していた~frameを次に挙げる いずれか【早い方】までは表示するベキである：
◎
The user agent should display the currently displayed frame until either:
</p>
		<ul>
			<li>
%新-文書 に向けて `pagereveal$et ~eventが発火される時点
◎
The pagereveal event is fired.
</li>
			<li>
%新-文書 にて`作動中な~view遷移$docの`相$vT ~EQ `済み$i になった時点
◎
its active view transition's phase is "done".
</li>
		</ul>

<p class="note">注記：
これは、［
旧-状態を表示してから新-状態を表示するまでの間、
意図されない明滅は生じない
］ことを確保して，遷移を滑らかに保つためである。
◎
Note: this is to ensure that there are no unintended flashes between displaying the old and new state, to keep the transition smooth.
◎
Return outboundTransition.
</p>
</div>

			</section>
			<section id="access-view-transition-in-new-doc">
<h4 title="Accessing the view-transition in the new Document">7.6.3. 新-文書における~view遷移の~access法</h4>

<div class="algo">
<p>
`非同一-文書な~view遷移を解決する@
ときは、
所与の
( `文書$ %文書 )
に対し：
◎
To resolve cross-document view-transition for Document document:
</p>
<ol>
	<li>
~Assert：
%文書 は`全部的に作動中$である。
◎
Assert: document is fully active.
</li>
	<li>
%内へ来る~view遷移~params ~LET %文書 の`内へ来る~view遷移~params$doc
◎
Let inboundViewTransitionParams be document’s inbound view transition params.
</li>
	<li>
~IF［
%内へ来る~view遷移~params ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If inboundViewTransitionParams is null, then return null.
</li>
	<li>
%文書 の`内へ来る~view遷移~params$doc ~SET ~NULL
◎
Set document’s inbound view transition params to null.
</li>
	<li>
<p>
~IF［
%文書 にて`作動中な~view遷移$doc ~NEQ ~NULL
］
⇒
~RET ~NULL
◎
If document’s active view transition is not null, then return null.
</p>

<p class="note">注記：
これは、［
非同一-文書な遷移が処理待ちにある下で，
当の文書が露呈される前に同一-文書な遷移が開始された
］ときは，前者の遷移を取消すようにすることを意味する。
◎
Note: this means that starting a same-document transition before revealing the document would cancel a pending cross-document transition.
</p>
	</li>
	<li>
%解決-済み規則 ~LET `~view遷移~規則を解決する$( %文書 )
◎
Resolve @view-transition rule for document and let resolvedRule be the result.
</li>
	<li>
~IF［
%解決-済み規則 ~EQ `遷移を飛ばす^i
］
⇒
~RET ~NULL
◎
If resolvedRule is "skip transition", then return null.
</li>
	<li>
%遷移 ~LET %文書 に`関連な~realm$に属する新たな `ViewTransition$I
— その
⇒＃
`有名~要素~群$vT ~SET %内へ来る~view遷移~params の`有名~要素$vTP,
`初期~snapshot包含塊~size$vT ~SET %内へ来る~view遷移~params の`初期~snapshot包含塊~size$vTP
◎
Let transition be a new ViewTransition in document’s relevant Realm, whose named elements is inboundViewTransitionParams’s named elements, and initial snapshot containing block size is inboundViewTransitionParams’s initial snapshot containing block size.
</li>
	<li>
%文書 の`作動中な~view遷移$doc ~SET %遷移
◎
Set document’s active view transition to transition.
</li>
	<li>
`~promiseを解決する$( %遷移 の`更新~callback済み時の~promise$vT )
◎
Resolve transition’s update callback done promise with undefined.
</li>
	<li>
%遷移 の`相$vT ~SET `更新~callbackは~call済み$i
◎
Set transition’s phase to "update-callback-called".
</li>
	<li>
%遷移 の`作動中な型~群$vTの`~token集合$tL ~SET %解決-済み規則
◎
Set transition’s active types's token set to resolvedRule.
</li>
	<li>
<p>
~UAは、
いつでも，内へ来る遷移を飛ばすものと裁定してもヨイ
— 例：`実装定義$な時間切れになった後に。
そうする場合、
~UAは，次を行うベキである
⇒
`大域~taskを~queueする$( `~DOM操作~task~source$, %文書 に`関連な大域~obj$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
~IF［
%遷移 の`相$vT ~NEQ `済み$i
］
⇒
`~view遷移を飛ばす$( %遷移, `TimeoutError$E 例外 )
</div>
◎
At any given time, the UA may decide to skip the inbound transition, e.g. after an implementation-defined timeout. To do so, the UA should queue a global task on the DOM manipulation task source given document’s relevant global object to perform the following step: If transition’s phase is not "done", then skip the view transition transition with a "TimeoutError" DOMException.
</li>
	<li>
~RET %遷移
◎
Return transition.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="priv">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この仕様が導入する新たな~privacy考慮点は無い。
◎
This specification introduces no new privacy considerations.
</p>

	</section>
	<section id="sec">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
非同一-生成元の課題を防止するため，現時点では、
非同一-文書な~view遷移が可能化され得るのは，同一-生成元な~naviに限られる。
それでも、
`WICG/view-transitions 課題 #200＠https://github.com/WICG/view-transitions/issues/200$
にて論じられたとおり，次に挙げる潜在的な脅威がある：
◎
To prevent cross-origin issues, at this point cross-document view transitions can only be enabled for same-origin navigations. As discussed in WICG/view-transitions#200, this still presents two potential threats:
</p>

<ol>
	<li>
新-文書, 旧-文書における`非同一-生成元~能力は隔離されるか？$enVは、
異なるかもしれない。
これは、［
この~flagが~T をとる文書
］が［
この~flagが ~F をとる文書
］から文書から画像~dataを読取れるような状況を生じさせ得る。
これは、
`~level 1$ `§ ~securityの考慮点＠~CSSVT#sec$
にて すでに軽減-済みである
— 同じ制約は、
捕捉された非同一-生成元な `iframe^e 用に適用されるので。
◎
The cross-origin isolated capability in both documents might be different. This can cause a situation where a Document that is cross-origin isolated can read image data from a document that is not cross-origin isolated. This is already mitigated in [[css-view-transitions-1#sec], as the same restriction applies for captured cross-origin iframes.
</li>
	<li>
<p>
同一-生成元な~naviは、
依然として
非同一-生成元な~redirectを介して生じるかもしれない
例：
`https://example.com^c に在る~pageが
`https://auth-provider.com/^c に在る~pageへ~linkしていて，
それが `https://example.com/loggedin^c へ戻るよう~redirectする場合。
◎
A same-origin navigation might still occur via a cross-origin redirect, e.g. https://example.com links to https://auth-provider.com/ which redirects back to https://example.com/loggedin.
</p>

<p>
これは、
非同一-生成元な主体が［
利用者を期待されない当事者-主体~URLへ~redirectする
］一方で［
期待されない遷移を生じさせる
］ことにより，
~redirectが在った事実
【非同一-生成元な文書が介入した事実】
をぼやかす（軽微な）状況を生じさせ得る。
これを軽減するため、
現時点では［
`文書$の`非同一-生成元~redirectを介して作成されたか$doc ~EQ ~T
］の場合には，~navi用の~view遷移は不能化される。
この検査は、
当の`文書$が`作動化し直され$ているときは，
適用されないことに注意
— その事例では、
非同一-生成元な~redirectが すでにその場を占めているので。
◎
This can cause a (minor) situation where the cross-origin party would redirect the user to an unexpected first-party URL, causing an unexpected transition and obfuscating that fact that there was a redirect. To mitigate this, currently view transitions are disabled for navigations if the Document was created via cross-origin redirects. Note that this check doesn’t apply when the Document is being reactivated, as in that case the cross-origin redirect has already taken place.
</p>

<p class="note">注記：
これが適用されるのは、
~server側による~redirectに限られる。
~client側による~redirect
— 例：
<code>&lt;`meta＠~HEmetadata#the-meta-element$ `http-equiv＠~HEmetadata#attr-meta-http-equiv$=`refresh＠~HEmetadata#attr-meta-http-equiv-keyword-refresh$&gt;</code>
を利用するなどによる —
は、
新たな~naviと等価になる。
◎
Note: this only applies to server-side redirects. A client-side redirect, e.g. using [^meta/http-equiv/refresh^], is equivalent to a new navigation.
</p>
	</li>
	<li>
この特能は、
~CSSに より多く情報を公開する
— これまでの~CSSは、
~naviに関係するものを何も自覚しなかったので。
これは、
第三者-主体に属する~CSSの安全性に関わる懸念を提起し得る。
しかしながら，一般~規則として、
第三者-主体に属する~stylesheetは，まずは信用される~sourceから来るベキである
— ~CSSは、［
文書について `learn^en 【？】し得る／
多くの仕方で文書【の呈示】を変更し得る
］ので。
◎
This feature exposes more information to CSS, as so far CSS was not aware of anything navigation-related. This can raise concerns around safety 3rd-party CSS. However, as a general rule, 3rd-party stylesheets should come from trusted sources to begin with, as CSS can learn about the document or change it in many ways.
</li>
</ol>

<p>
詳細な論点は、
`8684$issue,
`WICG/view-transitions 課題 #200＠https://github.com/WICG/view-transitions/issues/200$
を見よ。
◎
See Issue #8684 and WICG/view-transitions#200 for detailed discussion.
</p>

	</section>
</main></div>
