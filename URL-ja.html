<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>URL Standard ï¼ˆæ—¥æœ¬èªè¨³ï¼‰</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
.bytes, 
.literal,
.char-symbol {
	color: var(--literal-color-2);
}

.validation-error,
.parser-state {
	font-family: sans-serif0, sans-serif;
}

#_combi-host-types {
	writing-mode: vertical-rl;
}
</style>

<style>
/* table ç”¨ */
@supports (grid-template-columns: subgrid) and (display: contents) {

#_error-types {
	grid-template-columns: 4em 20em 1fr;
	min-width: 32em;
	max-width: 52em;
	tr {
		grid-template-areas:
			"ç¨®åˆ¥ ç¨®åˆ¥ å¤±æ•—"
			". è¨˜è¿° è¨˜è¿°"
			". ä¾‹ ä¾‹"
		;
		> *:nth-child(1) {
			grid-area: ç¨®åˆ¥;
			border-left-width: 0;
		}
		> th[colspan]{
			grid-area: ç¨®åˆ¥ / span 3;
		}
		> *:nth-child(2) {
			grid-area: è¨˜è¿°;
		}
		> *:nth-child(3) {
			grid-area: ä¾‹;
		}
		> *:nth-child(4) {
			grid-area: å¤±æ•—;
		}
	}
}

#_ex-percent-enc-dec {
	grid-template-columns: 4em 12em 1fr;
	min-width: 32em;
	max-width: 52em;
	tr {
		border-bottom: none;
		grid-template-areas:
			"æ¼”ç®— æ¼”ç®— æ¼”ç®—"
			". å…¥åŠ› å‡ºåŠ›"
		;
		/* 1 åˆ—ç›®ã« rowspan ãŒåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ã®ã§ :nth-last-child ã‚’åˆ©ç”¨ */
		> *:nth-last-child(3) {
			grid-area: æ¼”ç®—;
			border-left-width: 0;
		}
		> *:nth-last-child(2) {
			grid-area: å…¥åŠ›;
		}
		> *:nth-last-child(1) {
			grid-area: å‡ºåŠ›;
		}
	}
}


#_ex-roundtrip {
	grid-template-columns: 14em 1fr;
	min-width: 32em;
	max-width: 52em;
	tr {
		grid-template-areas:
			"å…¥åŠ› å‡ºåŠ›1"
			". å‡ºåŠ›2"
		;
		> *:nth-child(1) {
			grid-area: å…¥åŠ›;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: å‡ºåŠ›1;
		}
		> *:nth-child(3) {
			grid-area: å‡ºåŠ›2;
		}
	}
}


#_ex-suffix-domain {
	grid-template-columns: 4em 1fr 1fr;
	min-width: 20em;
	max-width: 36em;
	tr {
		grid-template-areas:
			"å…¥åŠ› å…¥åŠ› å…¥åŠ›"
			". æ¥å°¾è¾ ãƒ‰ãƒ¡ã‚¤ãƒ³"
		;
		> *:nth-child(1) {
			grid-area: å…¥åŠ›;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: æ¥å°¾è¾;
		}
		> *:nth-child(3) {
			grid-area: ãƒ‰ãƒ¡ã‚¤ãƒ³;
		}
	}
}


#_ex-url-validity {
	grid-template-columns: 4em 1fr 6em;
	min-width: 30em;
	max-width: 40em;
	tr {
		grid-template-areas:
			"å…¥åŠ› å…¥åŠ› å¦¥å½“æ€§"
			". åŸºåº• åŸºåº•"
			". å‡ºåŠ› å‡ºåŠ›"
		;
		> *:nth-child(1) {
			grid-area: å…¥åŠ›;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: åŸºåº•;
			min-height: 1.5em;
		}
		> *:nth-child(3) {
			grid-area: å¦¥å½“æ€§;
		}
		> *:nth-child(4) {
			grid-area: å‡ºåŠ›;
		}
	}
}


#_ex-url-components {
	grid-template-columns: 4em 1fr 1fr 1fr;
	min-width: 36em;
	max-width: 52em;
	tr {
		grid-template-areas:
			"å…¥åŠ› å…¥åŠ› å…¥åŠ› å…¥åŠ›"
			". scheme host port"
			". path query fragment"
		;
		> * {
			min-width: 12em;
		}
		> *:nth-child(1) {
			grid-area: å…¥åŠ›;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: scheme;
		}
		> *:nth-child(3) {
			grid-area: host;
		}
		> *:nth-child(4) {
			grid-area: port;
		}
		> *:nth-child(5) {
			grid-area: path;
		}
		> *:nth-child(6) {
			grid-area: query;
		}
		> *:nth-child(7) {
			grid-area: fragment;
		}
	}
}
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
/[ââ›].|%[~\w\-ä¸€-é¿†ã‚-ã‚“]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	if(match[0] === '%'){
		return `<var>${match.slice(1)}</var>`;
	}
	// [ââ›].
	const cp = match.charCodeAt(1).toString(16).toUpperCase();
	const smb = ` (<span class="char-symbol">&#x${cp};</span>)`;
	const val = (match[0] === 'â') ?
		`<span class="code-point">U+${('000'+cp).slice(-4)}</span>` :
		`<span class="hex-value">0x${cp}</span>`
	;
	return `${val}${smb}`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('ï¼ ');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="bytes">${text}</code>\``;
	break;
case 'sT':
	text += `<small>æ–‡å­—åˆ—</small>`;
	break;
case 'U':
	text = `U+${text}`;
	break;
case 'X':
	text = `0x${text}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'st':
	text += ' <small>state</small>';
	break;
case 'mc':
	text = 'constructor';
	klass = 'm';
	key = `new ${key}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

</script>

<script type="text/plain" id="_source_data">


â—â—options

spec_title:URL
spec_date:2025-03-05
trans_update:2025-03-05
source_checked:241202
spec_status:LS
original_url:https://url.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:network,security,html
copyright:,whatwg
trans_1st_pub:2012-10-20


â—â—class_map
E:error
st:parser-state
U:code-point
X:hex-value
AO:abstract
cn:cp-name
err:validation-error

â—â—tag_map
I:code
m:code
E:code
c:code
st:span
V:var
U:span
X:span
AO:span
i:i
err:i
cite:cite
cn:span

â—â—original_id_map

dom-urlsearchparams-iterable:
dom-urlsearchparams-stringifier:urlsearchparams-stringification-behavior
dom-url-stringifier:url-stringification-behavior

â—â—mdn_urls
url:API/URL
urlsearchparams:API/URLSearchParams

â—â—link_map

	â—IDL
Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject
LegacyWindowAlias:~WEBIDLjs#LegacyWindowAlias

webkitURL:#webkiturl

E.TypeError:~WEBIDL#exceptiondef-typeerror

undefined:~WEBIDL#idl-undefined
USVString:~WEBIDL#idl-USVString
boolean:~WEBIDL#idl-boolean
unsigned long:~WEBIDL#idl-unsigned-long
sequence:~WEBIDL#idl-sequence
record:~WEBIDL#idl-record

I.URL:#url
I.URLSearchParams:#urlsearchparams
	m.xxXx#dom-url-xxxx
	m.xxXx#dom-urlsearchparams-xxxx
I.EventSource:~HTMLsse#eventsource
I.HashChangeEvent:~WINDOW#hashchangeevent
I.Location:~WINDOW#location

m.~protocol0:~WINDOW#dom-location-protocol
m.registerProtocolHandler:~HTMLnavigator#dom-navigator-registerprotocolhandler
m.encodeURIComponent:~TC39#sec-encodeuricomponent-uricomponent

m.new URL:#dom-url-url
m.parse:#dom-url-parse
m.canParse:#dom-url-canparse
m.href:#dom-url-href
m.origin:#dom-url-origin
m.protocol:#dom-url-protocol
m.username:#dom-url-username
m.password:#dom-url-password
m.host:#dom-url-host
m.hostname:#dom-url-hostname
m.port:#dom-url-port
m.pathname:#dom-url-pathname
m.search:#dom-url-search
m.searchParams:#dom-url-searchparams
m.hash:#dom-url-hash
m.toJSON:#dom-url-tojson

m.new URLSearchParams:#dom-urlsearchparams-urlsearchparams
m.append:#dom-urlsearchparams-append
m.delete:#dom-urlsearchparams-delete
m.get:#dom-urlsearchparams-get
m.getAll:#dom-urlsearchparams-getall
m.has:#dom-urlsearchparams-has
m.set:#dom-urlsearchparams-set
m.size:#dom-urlsearchparams-size
m.sort:#dom-urlsearchparams-sort
m.iterable:#dom-urlsearchparams-iterable
m.stringifier:#dom-urlsearchparams-stringifier

	â— æ§‹æ–‡è§£æå™¨
æ¤œè¨¼~error:#validation-error
~pointer:#pointer
V.C:#c
V.C1:#c1
V.C2:#c2
æ•´æ•°ã‚’ç›´åˆ—åŒ–ã™ã‚‹:#serialize-an-integer
i.EOF:#eof-code-point
i.ç´ ç‰‡ã¯é™¤å¤–ã™ã‚‹:#url-serializer-exclude-fragment
	ç´ ç‰‡ã¯é™¤å¤–ã™ã‚‹:#url-equals-exclude-fragments

	~URL:#basic-url-parser-url
	ä¸Šæ›¸state:#basic-url-parser-state-override


	â— percent
~C0åˆ¶å¾¡æ–‡å­—~percent-ç¬¦å·åŒ–-é›†åˆ:#c0-control-percent-encode-set
ç´ ç‰‡~percent-ç¬¦å·åŒ–-é›†åˆ:#fragment-percent-encode-set
~query~percent-ç¬¦å·åŒ–-é›†åˆ:#query-percent-encode-set
ç‰¹åˆ¥~query~percent-ç¬¦å·åŒ–-é›†åˆ:#special-query-percent-encode-set
~path~percent-ç¬¦å·åŒ–-é›†åˆ:#path-percent-encode-set
~userinfo~percent-ç¬¦å·åŒ–-é›†åˆ:#userinfo-percent-encode-set
æˆåˆ†~percent-ç¬¦å·åŒ–-é›†åˆ:#component-percent-encode-set
~form_urlencoded~percent-ç¬¦å·åŒ–-é›†åˆ:#application-x-www-form-urlencoded-percent-encode-set

~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte:#percent-encoded-byte

~byteã‚’æ–‡å­—åˆ—ã«~percent-ç¬¦å·åŒ–ã™ã‚‹:#percent-encode
~byteåˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹:#percent-decode
~cpã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹:#utf-8-percent-encode
æ–‡å­—åˆ—ã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹:#string-utf-8-percent-encode
æ–‡å­—åˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹:#string-percent-decode
æ–‡å­—åˆ—ã‚’ç¬¦å·åŒ–ã—ã¦ã‹ã‚‰~percent-ç¬¦å·åŒ–ã™ã‚‹:#string-percent-encode-after-encoding

	â— host

~host:#concept-host
~hostæ§‹æ–‡è§£æå™¨:#concept-host-parser
~hostã‚’ç›´åˆ—åŒ–ã™ã‚‹:#concept-host-serializer
~hostç›´åˆ—åŒ–å™¨:#concept-host-serializer
ä¸é€æ˜ãª~host:#opaque-host
ç©º~host:#empty-host
ä¸é€æ˜ãª~hostæ§‹æ–‡è§£æå™¨:#concept-opaque-host-parser
ç¦æ­¢~host~cp:#forbidden-host-code-point
ç¦æ­¢~domain~cp:#forbidden-domain-code-point
åŒç­‰ãª~host:#concept-host-equals

sT.å¦¥å½“ãª~host:#valid-host-string
sT.å¦¥å½“ãª~domain:#valid-domain-string
sT.å¦¥å½“ãª~IPv4~address:#valid-ipv4-address-string
sT.å¦¥å½“ãª~IPv6~address:#valid-ipv6-address-string
sT.å¦¥å½“ãªä¸é€æ˜ãª~host:#valid-opaque-host-string
sT.ä¸é€æ˜ãª~hostï¼†~port:#opaque-host-and-port-string

å¦¥å½“ãª~domain:#valid-domain
~domain:#concept-domain
~domain~labelç¾¤:#domain-label
~domain~label:#domain-label
~domainã‚’~ASCIIåŒ–ã™ã‚‹:#concept-domain-to-ascii
~domainã‚’~UnicodeåŒ–ã™ã‚‹:#concept-domain-to-unicode

~IP~address:#ip-address

~IPv4~address:#concept-ipv4
~IPv4æ§‹æ–‡è§£æå™¨:#concept-ipv4-parser
~IPv4ç•ªå·~æ§‹æ–‡è§£æå™¨:#ipv4-number-parser
~IPv4ç›´åˆ—åŒ–å™¨:#concept-ipv4-serializer

ç•ªå·ã§çµ‚ç«¯ã—ã¦ã„ã‚‹ã‹æ¤œæŸ»ã™ã‚‹:#ends-in-a-number-checker

~IPv6~address:#concept-ipv6
~IPv6æ§‹æ–‡è§£æå™¨:#concept-ipv6-parser
~pieceç¾¤:#concept-ipv6-piece
~IPv6ç›´åˆ—åŒ–å™¨:#concept-ipv6-serializer
~IPv6~addressã®åœ§ç¸®ã•ã‚ŒãŸ~piece~indexã‚’è¦‹å‡ºã™:#find-the-ipv6-address-compressed-piece-index

å…¬å…±~æ¥å°¾è¾:#host-public-suffix
ç™»éŒ²-å¯èƒ½ãª~domain:#host-registrable-domain

	â— URL
~URL:#concept-url
~URL~record:#concept-url
url.ç”Ÿæˆå…ƒ:#concept-url-origin
url.ç´ ç‰‡:#concept-url-fragment
url.~host:#concept-url-host
url.~username:#concept-url-username
url.~password:#concept-url-password
url.~path:#concept-url-path
url.~port:#concept-url-port
url.~query:#concept-url-query
url.~scheme:#concept-url-scheme
url.~blob~URL~entry:#concept-url-blob-entry

åŸºæœ¬~URLæ§‹æ–‡è§£æå™¨:#concept-basic-url-parser
~URLæ§‹æ–‡è§£æå™¨:#concept-url-parser
~URLæ§‹æ–‡è§£æã™ã‚‹:#concept-url-parser
~APIç”¨ã«~URLæ§‹æ–‡è§£æã™ã‚‹:#_api-url-parser
~URLç›´åˆ—åŒ–å™¨:#concept-url-serializer
~URLã‚’ç›´åˆ—åŒ–ã™ã‚‹:#concept-url-serializer
~URL~pathã‚’ç›´åˆ—åŒ–ã™ã‚‹:#url-path-serializer
åŒç­‰ãª~URL:#concept-url-equals
~pathã‚’çŸ­ç¸®ã™ã‚‹:#shorten-a-urls-path

åŸºåº•~URL:#concept-base-url

ç‰¹åˆ¥~scheme:#special-scheme
ç‰¹åˆ¥:#is-special
	ç‰¹åˆ¥ã§ãªã„:#is-not-special
æ—¢å®š~port:#default-port

è³‡æ ¼è¨¼ã‚’å«ã‚“ã§:#include-credentials
ä¸é€æ˜ãª~path:#url-opaque-path
~URLã®~usernameã‚’è¨­å®šã™ã‚‹:#set-the-username
~URLã®~passwordã‚’è¨­å®šã™ã‚‹:#set-the-password
~usernameï¼~passwordï¼~portã‚’æœ‰ã—å¾—ãªã„:#cannot-have-a-username-password-port

~URL~path:#url-path
~URL~pathåŒºåˆ†:#url-path-segment
äºŒé‡-~dot~URL~pathåŒºåˆ†:#double-dot-path-segment
å˜-~dot~URL~pathåŒºåˆ†:#single-dot-path-segment

sT.å¦¥å½“ãª~URL:#valid-url-string
sT.çµ¶å¯¾~URL:#absolute-url-string
sT.ç´ ç‰‡~ä»˜ãçµ¶å¯¾~URL:#absolute-url-with-fragment-string
sT.ç´ ç‰‡~ä»˜ãç›¸å¯¾~URL:#relative-url-with-fragment-string
sT.~URL~scheme:#url-scheme-string
sT.ç›¸å¯¾~URL:#relative-url-string
sT.~schemeç›¸å¯¾~URL:#scheme-relative-url-string
sT.~schemeç›¸å¯¾~ç‰¹åˆ¥~URL:#scheme-relative-special-url-string
sT.~schemeç›¸å¯¾~file~URL:#scheme-relative-file-url-string
sT.~pathçµ¶å¯¾ é Windows file ~URL:#path-absolute-non-windows-file-url-string
sT.~URL~port:#url-port-string
sT.~pathçµ¶å¯¾~URL:#path-absolute-url-string
sT.~pathç›¸å¯¾~URL:#path-relative-url-string
sT.~pathç›¸å¯¾ ~schemeãªã—~URL:#path-relative-scheme-less-url-string
sT.~URL~pathåŒºåˆ†:#url-path-segment-string
sT.~URL~query:#url-query-string
sT.~URLç´ ç‰‡:#url-fragment-string

~drive_letter:#windows-drive-letter
æ­£è¦åŒ–-æ¸ˆã¿~drive_letter:#normalized-windows-drive-letter
~drive_letterã‹ã‚‰é–‹å§‹ã—ã¦:#start-with-a-windows-drive-letter

~URLå˜ä½:#url-units
~URLå˜ä½ã‹ã©ã†ã‹æ¤œè¨¼ã™ã‚‹:#_validate-if-url-unit
~URL~cp:#url-code-points


	â— URL æ§‹æ–‡è§£æå™¨

st.~schemeé–‹å§‹:#scheme-start-state
st.~scheme:#scheme-state
st.~schemeãªã—:#no-scheme-state
st.ç‰¹åˆ¥ ç›¸å¯¾/æ¨©é™:#special-relative-or-authority-state
st.~path/æ¨©é™:#path-or-authority-state
st.ç›¸å¯¾:#relative-state
st.ç›¸å¯¾~slash:#relative-slash-state
st.ç‰¹åˆ¥ æ¨©é™~slash:#special-authority-slashes-state
st.ç‰¹åˆ¥ æ¨©é™~slashç„¡è¦–:#special-authority-ignore-slashes-state
st.æ¨©é™:#authority-state
st.~host:#host-state
st.~hostname:#hostname-state
st.~file~host:#file-host-state
st.~file:#file-state
st.~file~slash:#file-slash-state
st.~port:#port-state
st.~pathé–‹å§‹:#path-start-state
st.~path:#path-state
st.ä¸é€æ˜~path:#cannot-be-a-base-url-path-state
st.~query:#query-state
st.ç´ ç‰‡:#fragment-state

	â— err
err.domain-to-ASCII:#validation-error-domain-to-ascii
err.domain-to-Unicode:#domain-to-unicode
err.domain-invalid-code-point:#domain-invalid-code-point
err.host-invalid-code-point:#host-invalid-code-point
err.IPv4-empty-part:#ipv4-empty-part
err.IPv4-too-many-parts:#ipv4-too-many-parts
err.IPv4-non-numeric-part:#ipv4-non-numeric-part
err.IPv4-non-decimal-part:#ipv4-non-decimal-part
err.IPv4-out-of-range-part:#ipv4-out-of-range-part
err.IPv6-unclosed:#ipv6-unclosed
err.IPv6-invalid-compression:#ipv6-invalid-compression
err.IPv6-too-many-pieces:#ipv6-too-many-pieces
err.IPv6-multiple-compression:#ipv6-multiple-compression
err.IPv6-invalid-code-point:#ipv6-invalid-code-point
err.IPv6-too-few-pieces:#ipv6-too-few-pieces
err.IPv4-in-IPv6-too-many-pieces:#ipv4-in-ipv6-too-many-pieces
err.IPv4-in-IPv6-invalid-code-point:#ipv4-in-ipv6-invalid-code-point
err.IPv4-in-IPv6-out-of-range-part:#ipv4-in-ipv6-out-of-range-part
err.IPv4-in-IPv6-too-few-parts:#ipv4-in-ipv6-too-few-parts
err.invalid-URL-unit:#invalid-url-unit
err.special-scheme-missing-following-solidus:#special-scheme-missing-following-solidus
err.missing-scheme-non-relative-URL:#missing-scheme-non-relative-url
err.invalid-reverse-solidus:#invalid-reverse-solidus
err.invalid-credentials:#invalid-credentials
err.host-missing:#host-missing
err.port-out-of-range:#port-out-of-range
err.port-invalid:#port-invalid
err.file-invalid-Windows-drive-letter:#file-invalid-windows-drive-letter
err.file-invalid-Windows-drive-letter-host:#file-invalid-windows-drive-letter-host

	â— API
URL.~URL:#concept-url-url
URL.~query~obj:#concept-url-query-object
~URL~objã‚’åˆæœŸåŒ–ã™ã‚‹:#url-initialize
~API~URLæ§‹æ–‡è§£æå™¨:#api-url-parser

USP.~URL~obj:#concept-urlsearchparams-url-object
USP.~parameter~list:#concept-urlsearchparams-list
~query~objã‚’åˆæœŸåŒ–ã™ã‚‹:#urlsearchparams-initialize
~query~objã‚’æ›´æ–°ã™ã‚‹:#concept-urlsearchparams-update
~query~parameter:#_concept-query-parameter

~form_urlencodedå½¢å¼:#concept-urlencoded
~form_urlencodedæ–‡å­—åˆ—~æ§‹æ–‡è§£æå™¨:#concept-urlencoded-string-parser
~form_urlencodedæ§‹æ–‡è§£æå™¨:#concept-urlencoded-parser
~form_urlencodedç›´åˆ—åŒ–å™¨:#concept-urlencoded-serializer
~form_urlencoded~byteç›´åˆ—åŒ–å™¨:#concept-urlencoded-byte-serializer

ä¸é€æ˜ãª~pathãªã‚‰ã° ãã®æœ«å°¾ã«ã‚ã‚‹~spaceåˆ—ã‚’å‰¥ã:#potentially-strip-trailing-spaces-from-an-opaque-path

	â—INFRA
16 ~bitãªç„¡ç¬¦å·~æ•´æ•°:~INFRA#16-bit-unsigned-integer
32 ~bitãªç„¡ç¬¦å·~æ•´æ•°:~INFRA#32-bit-unsigned-integer
128 ~bitãªç„¡ç¬¦å·~æ•´æ•°:~INFRA#128-bit-unsigned-integer
~byte:~INFRA#byte
~byteåˆ—:~INFRA#byte-sequence
byte.å€¤:~INFRA#byte-value
byte.é•·ã•:~INFRA#byte-sequence-length
æ–‡å­—åˆ—:~INFRA#string
é•·ã•:~INFRA#string-length
ã‹ã‚‰é–‹å§‹ã—ã¦:~INFRA#string-starts-with
~cp:~INFRA#code-point
~cpé•·ã•:~INFRA#string-code-point-length
cp.å€¤:~INFRA#code-point-value
~surrogate:~INFRA#surrogate
éæ–‡å­—:~INFRA#noncharacter
çµ‚ç«¯ã¾ã§ã‚’æˆã™~cpéƒ¨åˆ†æ–‡å­—åˆ—:~INFRA#code-point-substring-to-the-end-of-the-string
~ASCIIå¤§å°ç„¡è¦–:~INFRA#ascii-case-insensitive
~ASCII~cp:~INFRA#ascii-code-point
~ASCII~byte:~INFRA#ascii-byte
~ASCIIè‹±å­—:~INFRA#ascii-alpha
~ASCIIè‹±æ•°å­—:~INFRA#ascii-alphanumeric
~ASCIIæ•°å­—:~INFRA#ascii-digit
~ASCII~hexæ•°å­—:~INFRA#ascii-hex-digit
~ASCII~hexæ•°å­—ï¼ˆå¤§æ–‡å­—ï¼‰:~INFRA#ascii-upper-hex-digit
~ASCIIæ–‡å­—åˆ—:~INFRA#ascii-string
~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹:~INFRA#ascii-lowercase
~ASCII~tabã‚„~ASCIIæ”¹è¡Œæ–‡å­—:~INFRA#ascii-tab-or-newline
~C0åˆ¶å¾¡æ–‡å­—:~INFRA#c0-control
~C0åˆ¶å¾¡æ–‡å­—ã‚„~space:~INFRA#c0-control-or-space
~scalarå€¤:~INFRA#scalar-value
~scalarå€¤~æ–‡å­—åˆ—:~INFRA#scalar-value-string
åŒå‹ã«å¾©å·ã™ã‚‹:~INFRA#isomorphic-decode
åŒºåˆ‡å­ã§å³å¯†ã«åˆ†å‰²ã™ã‚‹:~INFRA#strictly-split
ã§çµ‚ç«¯ã—ã¦:~INFRA#string-ends-with
æœªæº€ã®ç¬¦å·å˜ä½~åˆ—:~INFRA#code-unit-less-than

ç©º:~INFRA#list-is-empty
	~EACH:~INFRA#list-iterate
~list:~INFRA#list
~indexç¾¤:~INFRA#list-get-the-indices
~size:~INFRA#list-size
~item:~INFRA#list-item
~tuple:~INFRA#tuple
ç©ºã«ã™ã‚‹:~INFRA#list-empty
é™¤å»ã™ã‚‹:~INFRA#list-remove
ä»˜åŠ ã™ã‚‹:~INFRA#list-append
~cloneã™ã‚‹:~INFRA#list-clone
æ‹¡å¼µã™ã‚‹:~INFRA#list-extend
~listã‚’æ˜‡é †ã«~sortã™ã‚‹:~INFRA#list-sort-in-ascending-order
æ§‹é€ ä½“:~INFRA#struct

	â—ENCODING
~UTF-8:~ENCODING#utf-8
~ISO-2022-JP:~ENCODING#iso-2022-jp
~Shift_JIS:~ENCODING#shift_jis
ç¬¦å·åŒ–æ³•ã‹ã‚‰å‡ºåŠ›~ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹:~ENCODING#get-an-output-encoding
ç¬¦å·åŒ–æ³•:~ENCODING#encoding
~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹:~ENCODING#utf-8-decode-without-bom
~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹:~ENCODING#utf-8-decode-without-bom-or-fail
~UTF-8ç¬¦å·åŒ–ã™ã‚‹:~ENCODING#utf-8-encode
ç¬¦å·åŒ–å™¨ã‚’å–å¾—ã™ã‚‹:~ENCODING#get-an-encoder
å…¥å‡ºåŠ›~queue:~ENCODING#concept-stream
ç¬¦å·åŒ–ã™ã‚‹ã‹å¤±æ•—ã™ã‚‹:~ENCODING#encode-or-fail
~ISO-2022-JPç¬¦å·åŒ–å™¨:~ENCODING#iso-2022-jp-encoder

	â—ä»–
ç”Ÿæˆå…ƒ:~ORIGIN#concept-origin
ä¸é€æ˜ãªç”Ÿæˆå…ƒ:~ORIGIN#concept-origin-opaque
æˆåˆ†çµ„~ç”Ÿæˆå…ƒ:~ORIGIN#concept-origin-tuple
åŒä¸€-ç”Ÿæˆå…ƒ:~ORIGIN#same-origin
ç”Ÿæˆå…ƒã‚’ç›´åˆ—åŒ–ã™ã‚‹:~ORIGIN#ascii-serialisation-of-an-origin
åŒã˜~site:~ORIGIN#same-site
~schemeç„¡ã—ã§åŒã˜~site:~ORIGIN#schemelessly-same-site

~blob~URL~store:~FILEAPI#BlobURLStore
~blob~URL~entry:~FILEAPI#blob-url-entry
~blob~URLã‚’è§£æ±ºã™ã‚‹:~FILEAPI#blob-url-resolve
bU.ç’°å¢ƒ:~FILEAPI#blob-url-entry-environment

enV.ç”Ÿæˆå…ƒ:~WAPI#concept-settings-object-origin

AO.Unicode ToASCII:https://www.unicode.org/reports/tr46/#ToASCII
AO.Unicode ToUnicode:https://www.unicode.org/reports/tr46/#ToUnicode

æ–°ãŸãª~obj:~WEBIDLjs#new
åå¾©ã•ã‚Œã‚‹å€¤~pairç¾¤:~WEBIDL#dfn-value-pairs-to-iterate-over
æ–‡å­—åˆ—~åŒ–ã®æŒ™å‹•:~WEBIDL#dfn-stringification-behavior
é€£åˆ—~å‹:~WEBIDL#idl-sequence
~recordå‹:~WEBIDL#idl-record

å…¬å…±~æ¥å°¾è¾~listã®~algo:https://github.com/publicsuffix/list/wiki/Format#formal-algorithm

_acks1:#_acks1
_ipr1:#_ipr1

â—â—words_table1

form_urlencoded:<code>application/x-www-form-urlencoded</code> 
APPEND: <span class="op">&lt;&lt;</span> 
protocol0:protocol
atã€…:@

â—â—words_table


	â—dataï¼æ§‹é€ 
store:
blob:
åŸºæ•°:radix::~
ç•ªå·:number::~
ç„¡ç¬¦å·:unsigned::~
	32-bitï¼16-bitï¼128-bit
æˆåˆ†çµ„:tuple::~
æˆåˆ†p:part:æˆåˆ†
éƒ¨ä½:portion:~
æ§‹æˆ-:compose:~

	å¤‰ç•°-ä¸èƒ½:immutable
	æœ‰æ§‹é€ ~clone
	APPEND:prepend
	~byteåˆ—:bytes
	ä¸¦ã³:sequence
	çµ„:pairï¼tuple
	ã€œã‚’é–‰ã˜ã‚‹:closing
	å…ˆé ­ã«~~ä½™è¨ˆãª:leading
	æ®‹ã‚Šã®éƒ¨åˆ†:remainder
	ç›´å‰:immediately preceding
	å„éƒ¨:parts
	é ­éƒ¨:leading
	å¤šéã:too many
	å°‘ãªéã:too few
	å§‹ã¾:begin
	å¤§ãéã:too big
	2 ç®‡æ‰€ä»¥ä¸Š:more than oen spot
	ã«æº€ãŸãªã„:fewer than
	å¾Œç¶šã—ã¦ã„ãªã„:not followed by
	~cpã”ã¨:code-point-for-code-point
	å°¾éƒ¨ï¼æœ«å°¾:trailing

	â—å‡¦ç†
æ¸¡ã™:passã™ã‚‹:~
æ¸¡ã•ã‚Œ:passã•ã‚Œ:~
ç­‰ä¾¡æ€§:equivalence::~
åŒç­‰:equal::~
åŒç­‰æ€§:equality::~
stateful::::ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«
é€£çµ-:concatenate::~

	æ›´ãªã‚‹åˆ†å²å‡¦ç†:dispatch ... for further processing
	~errorå«ã¿ã®:erroneous
	å¾Œã®æ®µ:later stage
	ã™ã‚‹ã“ã¨ã«ãªã‚‹:end up
	ã«ãªã‚‰ãªã„:not end up
	å¾€å¾©-å¯èƒ½:roundtripeable
	è§¦ã‚Œãªã„ã¾ã¾æ®‹ã™:leave ã€œ untouched
	å¾—ã‚‰ã‚Œã‚‹:yield
swap:

	â—æ–‡å­—ãƒ‡ãƒ¼ã‚¿
BOM:
	~BOMã‚‚å¤±æ•—-ã‚‚:BOM or fail
C0:
hex::16 é€²
octal::8 é€²
hexadecimal::16 é€²
cp:code point::ç¬¦å·ä½ç½®::ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
surrogate::::ã‚µãƒ­ã‚²ãƒ¼ãƒˆ
éæ–‡å­—:noncharacter::~
åˆ¶å¾¡æ–‡å­—:controls::~
è‹±æ•°å­—:alphanumeric::~
è‹±å­—:alpha::~
è§’æ‹¬å¼§:brackets::~
at-sign::::@ãƒãƒ¼ã‚¯
	æ–‡å­—åˆ—~åŒ–:stringification
	æ–‡å­—åˆ—~åŒ–-:stringify
éƒ¨åˆ†æ–‡å­—åˆ—:substring::~
å‰¥ã:stripã™ã‚‹::~
	æ•°ã§:numeric

	â—æ§‹æ–‡è§£æï¼ç›´åˆ—åŒ–
piece:
	-:separator
ä¸Šæ›¸state:state override::ä¸Šæ›¸ã state
çŠ¶æ…‹æ©Ÿæ¢°:state machine:~
state:
çŸ­ç¸®-:shorten::~
åœ§ç¸®-:compress::~
	åœ§ç¸®-æ¸ˆã¿ã§ãªã„:uncompressed
åœ§ç¸®:compression::~
æ›¸å‡ºæ³•:writing::æ›¸å¼
æ›¸å‡ºã•ã‚Œ:writeã•ã‚Œ::æ›¸ãå‡ºã•ã‚Œ
æ›¸å‡ºã›ã‚‹:writeã§ãã‚‹::æ›¸ãå‡ºã›ã‚‹
åŒå‹:isomorphic::~
Shift_JIS:
ISO-2022-JP:
å…¥å‡ºåŠ›:I/O:~

	~~å…¥åŠ›:takes
	æ­£è¦åŒ–-æ¸ˆã¿:normalized
	ç¬¦å·åŒ–-æ¸ˆã¿:encoded
	å…ˆé ­:start ofï¼:leadingï¼:starts with
	æŒ‡ã™:points to
	`0080^U ä»¥ä¸Š:greater than U+007F DELETE

	â—URLï¼originï¼domainï¼host
IP:
IPv6:
IPv4:
file:
subdomain::::ä¸‹ä½ãƒ‰ãƒ¡ã‚¤ãƒ³
hostname::::ãƒ›ã‚¹ãƒˆå
userinfo::::ãƒ¦ãƒ¼ã‚¶æƒ…å ±
username::::ãƒ¦ãƒ¼ã‚¶å
password::::ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
query::::ã‚¯ã‚¨ãƒª
dot:::ãƒ‰ãƒƒãƒˆ
	å˜-~dot:single-dot
	äºŒé‡-~dot:double-dot
äºŒé‡-:double-:~
åŒºåˆ†:segment::~
percent-::: %-
drive_letter:Windows drive letter:::Windows ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ¬ã‚¿ãƒ¼
å¤§åŸŸä¸€æ„:globally unique::~::ã‚°ãƒ­ãƒ¼ãƒãƒ«ä¸€æ„
æ¨©é™:authority::~
å…¬å…±:public::~
	en:PublicSuffixList
	å…¬å…±~æ¥å°¾è¾~listã®~algo:Public Suffix List algorithm

IDNA:
	IDNA2008
directory::::ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª

	â—network
DNS:

	â—ä»•æ§˜
ä¸»æµ:majority:~
æ™®éçš„:universal:~
çµ±ä¸€åŒ–:unified:~
å´é¢f:facet:å´é¢
å¸‚å ´:market share:~
å¢—è£œ:enhancement:~
	æ„å›³ã—ã¦:intent of what is
æŒ‡å-:designate:~
ç¾ä»Šã®:contemporary:~
ç¢ºå›º:solid:ç¢ºå›ºãŸã‚‹ã‚‚ã®
éå»äº’æ›å¯¾å‡¦:quirk:~
	conforming
é–‹ç™ºç”¨console:developer console:é–‹ç™ºç”¨ console::é–‹ç™ºç”¨ã‚³ãƒ³ã‚½ãƒ¼ãƒ«
æ’ä»–çš„:exclusive:~
å˜ç›´:straightforward:ç°¡å˜
	å˜ç›´:fairly straightforward
å†ªç­‰æ€§:idempotence:~
åˆ†å²-:diverge:~
åŠ©è¨€:advice:~
ç”³è«‹-:file:~
éæ¨å¥¨åŒ–:deprecation:~
è‡´å‘½çš„:fatal:~
èƒ½æ€§:potential:~
æœ«ç«¯:end:~
ç†è«–:theory:~
è¡Œä½¿:exercise:~
ç†æƒ³çš„:ideal:~

	~networkç”¨:networking
	æ˜ç­ã§ãªã„:unclear
	æœ€ä½~levelã®:lowest-level
	æ‰ãˆã‚‹:can be seen as
	é«˜:high
	-:Ensure
	åŒæ§˜ã«:Similarly
	å‘ã‘:-oriented
	ã‚ˆã‚Šé«˜~level:higher-level 
	~~è¦³ç‚¹:notion
	ä¸å¹¸ãªå·¡ã‚Šåˆã‚ã›:accidents
	å¥½ã¾ã—ã„:preferred
	å¦¥å”ã®ç”£ç‰©:compromises leading
	~~å®Œå…¨
	æƒã‚ã›:align
	æ‰±ã„æ–¹
	å–ã‚Š~~çµ„ã‚€:approach
	~~æ‹¡ãŒã‚‹:increase
	æ¬ ã„ã¦:lack ã—ã¦
	ç„¡ããªã‚‹:not a lack of
	ç‰¹ã«ï¼Œin particular
	æ”¹ã‚ãŸããªã„:avoid altering
	åˆ¥æ³•ã¨ã—ã¦:Alternatively
	ã€œã®ãã®ä»–è«¸ã€…:miscellaneous
	ã¹ãã¨ã•ã‚Œã‚‹:ought
	é¸ã¶:choose
	å¯èƒ½æ€§:potentially
	è¦–é‡ã‹ã‚‰å¤–ã‚Œã‚‹:out-of-scope
	ä¿‚ã‚‹:pertain
	æ„å¤–ãªçµæœ:surprising
	ã«åŸºã¥ã„ã¦ï¼å«ã‚€ã‚ˆã†ã«:in terms of
	å˜ç´”ã«ã™ã‚‹:simplicity
	æœŸå¾…ã•ã‚Œãªã„æ‰€ã§:unexpectedly

	â—ä¿å®‰
è¨¼æ˜æ›¸:certificate:~
å®³ã™ã‚‹:harmã™ã‚‹:å®³ã‚’åŠã¼ã™
å½¹å‹™:function:~
åŒæ–¹å‘-:bidirectional:~
	å·¦æ¨ªæ›¸ãåŸ‹ã‚è¾¼ã¿ left-to-right embedding
æ¡ç”¨-:adopt:~
è£½å“åŒ–-:produce:~
å …å›º:hard:~
è­¦å‘Š-:warn:~
è£œè¶³-:supplement:~
æ³¨ç›®:attention:~
çœã:elideã™ã‚‹:~
	~URLã‚’çœãã¨ã:elision
å‰²æŒ¯ã‚‹:allocateã™ã‚‹:å‰²ã‚ŠæŒ¯ã‚‹
voice::::ãƒœã‚¤ã‚¹
ç‚ºã™:makeã™ã‚‹:~

	æ°—ã‚’ãã‚‰ã™:distract
	æ··åŒã•ã‚Œæ˜“ã„:confusableï¼:prone to confusion
	èª¤ã‚Šã¸å°ã:mislead:~
	~~èª¤èª-:mistake
	æ°—ã‚’ãã‚‰ã—:distract
	è€ƒæ…®-:consideration
	æ³¨æ„:care
	æ³¨æ„ã™ã‚‹:Care is to be taken
	ãã®ã‚ˆã†ãªè¡¨ç¤º:display surface
	è¦‹è¾¼ã¿ãŒè–„ã„:unlikely
	åºƒç¯„ã«:wide
	é…·ä¼¼:appear eerily similar
	~~æœ€ä½ã§ã‚‚at the very least
	æ„ã«åã™ã‚‹not want to leak
	å—ã‘å…¥ã‚Œã‚‹:embrace
	äººã‹ã‚‰èª­ã‚ã‚‹:human-readable
	IDN
	^en:homograph
	å¼•ã:draw
	ç‹­ã„:space-constrained
	ç¾ã‚Œã‚‹ï¼ç¾ã‚Œãª:appear
	-:post
	ã€œã‹ã‚‰:starting
	ã•ã‚Œæ˜“ã„:prone to
	å‹§ã‚ã‚‹:advisable
	ã—ã¾ã„ãã†ã ãŒ:This can be unexpected

	â—å¤‰æ•°
	%A
	%B
	%C0
	%C1
	%C2
	%L
	%L1
	%L2
	%N
	%N:integer
	%R
	%b
	%å³å¯†ã‹:beStrict
	%i
	%init
	%~IPv4:ipv4
	%~IPv4å€‹æ•°:numbersSeen
	%~IPv4~piece:ipv4Piece
	%n
	%~path:path
	%remaining
	%state
	%~swapæ•°:swaps
	%url
	%~ASCII~domain:asciiDomain
	%~URL
	%~address:address
	%~at-signã‚ã‚Šã‹:atSignSeen
	%è§’æ‹¬å¼§ã®å†…å´ã‹:insideBrackets
	%~password~tokenã‚ã‚Šã‹:passwordTokenSeen
	%~buffer
	%~byte:byte
	%~byteåˆ—:bytes
	%~byteåˆ—~list:sequences
	%~counter:counter
	%~cp:codePoint
	%~scalarå€¤:scalarValue
	%~domain
	%~errorã«ãªã‚Šå¾—ã‚‹:potentialError
	%~hexæ–‡å­—åˆ—:-
	%~host
	%ç„¡è¦–ã™ã‚‹ã‹:ignore0
	%~obj:-
	%å†…ç¸~é€£åˆ—:innerSequence
	%~password:password
	%~percent-ç¬¦å·åŒ–-é›†åˆ:percentEncodeSet
	%~piece~index:pieceIndex
	%æœ€é•·~index:longestIndex
	%æœ€é•·~size:longestSize
	%è¦‹å‡ºã•ã‚ŒãŸ~index:foundIndex
	%è¦‹å‡ºã•ã‚ŒãŸ~size:foundSize
	%~pointer:pointer
	%~port:port
	%~query:query
	%~query~percent-ç¬¦å·åŒ–-é›†åˆ:queryPercentEncodeSet
	%~slashã‹:-
	%spaceAsPlus:spaceAsPlus
	%~parameter~list:tuples
	%~parameter:tuple
	%~URL:url
	%~URL~record:urlRecord
	%~URL~obj:url
	%~username
	%æˆåˆ†p:part
	%æˆåˆ†p~list:parts
	%ä¸Šæ›¸state:state override
	%ç¬¦å·åŒ–æ³•:encoding
	%å€¤:value
	%å€¤~æ–‡å­—åˆ—:valueString
	%å…¥åŠ›:input
	%å…¥åŠ›~queue:inputQueue
	%å…¬å…±~æ¥å°¾è¾:publicSuffix
	%å‡ºåŠ›:output
	%åŒå‹ãª~cp:isomorph
	%å:name
	%å~æ–‡å­—åˆ—:nameString
	%åœ§ç¸®-~index:compress
	%åŸºåº•:base
	%ç•ªå·:-
	%æœ€å¾Œã®~index:-
	%ç•ªå·~list:numbers
	%æ–‡å­—åˆ—:string
	%æ¤œè¨¼~errorã‹:validationError
	%ä¸é€æ˜ã‹:isOpaque
	%ç™»éŒ²-å¯èƒ½ãª~domain:registrableDomain
	%ç¬¦å·åŒ–-æ¸ˆã¿~cp:encodedCodePoints
	%ç¬¦å·åŒ–-å‡ºåŠ›:encodeOutput
	%ç´ ç‰‡ã¯é™¤å¤–ã™ã‚‹ã‹:exclude fragment
	%çµæœ:result
	%æ§‹æ–‡è§£æã—ãŸ~URL:parsedURL
	%æ§‹æ–‡è§£æã—ãŸåŸºåº•:parsedBase
	%è¨­å®šã—ãŸã‹:-
	%é•·ã•:and length
	%æœ€å¾Œã®~item:last
	%æœ«å°¾ã®~dot:trailingDot
	%å…¬å…±~æ¥å°¾è¾:publicSuffix
	%ç›´åˆ—åŒ–ã—ãŸ~query:serializedQuery

	â—æœªåˆ†é¡
æ­£æº–-:canonical::~
	æ­£æº–-åŒ–:canonicalization
å¤‰ç¨®:variant:~
hit::::ãƒ’ãƒƒãƒˆ

	~memoryå†…ã®:in-memory
	æœ€çŸ­:shortest possible
	å«ã¾ãªã„ã®ã§:due to the omission of
	-ing
	ç‡ã‚’é«˜ã‚ã‚‹:increase
	è¾¼ã¿ã§:along with
	æŒ‡ã—ã¦:refer
	æŒ‡ã™:refer
	æ›´ã«:further
	~~å…¨èˆ¬çš„ã«:at large

â—â—ref_normative

[BIDI]
    Manish Goregaokar à¤®à¤¨à¥€à¤· à¤—à¥‹à¤°à¥‡à¤—à¤¾à¤‚à¤µà¤•à¤°; Robin Leroy. ï¼œUnicode Bidirectional Algorithmï¼. 2 September 2024. Unicode Standard Annex #9. URL: https://www.unicode.org/reports/tr9/tr9-50.html
[ENCODING]
    Anne van Kesteren. ï¼œEncoding Standardï¼. Living Standard. URL: https://encoding.spec.whatwg.org/
[FILEAPI]
    Marijn Kruisselbrink. ï¼œFile APIï¼. URL: https://w3c.github.io/FileAPI/
[HTML]
    Anne van Kesteren; et al. ï¼œHTML Standardï¼. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[IANA-URI-SCHEMES]
    ï¼œUniform Resource Identifier (URI) Schemesï¼. URL: https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml
[INFRA]
    Anne van Kesteren; Domenic Denicola. ï¼œInfra Standardï¼. Living Standard. URL: https://infra.spec.whatwg.org/
[PSL]
    ï¼œPublic Suffix Listï¼.    Mozilla Foundation.
[RFC4291]
    R. Hinden; S. Deering. ï¼œIP Version 6 Addressing Architectureï¼. February 2006. Draft Standard. URL: https://www.rfc-editor.org/rfc/rfc4291
[UTS46]
    Mark Davis; Markus Scherer. ï¼œUnicode IDNA Compatibility Processingï¼. 30 August 2024. Unicode Technical Standard #46. URL: https://www.unicode.org/reports/tr46/tr46-33.html
[WEBIDL]
    Edgar Chen; Timothy Gu. ï¼œWeb IDL Standardï¼. Living Standard. URL: https://webidl.spec.whatwg.org/

â—â—ref_informative

[ECMA-262]
    ï¼œECMAScript Language Specificationï¼. URL: https://tc39.es/ecma262/multipage/
[IDNFAQ]
    ï¼œInternationalized Domain Names (IDN) FAQï¼. URL: https://unicode.org/faq/idn.html
[RFC1034]
    P. Mockapetris. ï¼œDomain names - concepts and facilitiesï¼. November 1987. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc1034
[RFC3986]
    T. Berners-Lee; R. Fielding; L. Masinter. ï¼œUniform Resource Identifier (URI): Generic Syntaxï¼. January 2005. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc3986
[RFC3987]
    M. Duerst; M. Suignard. ï¼œInternationalized Resource Identifiers (IRIs)ï¼. January 2005. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc3987
[RFC5890]
    J. Klensin. ï¼œInternationalized Domain Names for Applications (IDNA): Definitions and Document Frameworkï¼. August 2010. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc5890
[RFC5952]
    S. Kawamura; M. Kawashima. ï¼œA Recommendation for IPv6 Address Text Representationï¼. August 2010. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc5952
[RFC6454]
    A. Barth. ï¼œThe Web Origin Conceptï¼. December 2011. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6454
[RFC7595]
    D. Thaler, Ed.; T. Hansen; T. Hardie. ï¼œGuidelines and Registration Procedures for URI Schemesï¼. June 2015. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc7595
[RFC791]
    J. Postel. ï¼œInternet Protocolï¼. September 1981. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc791
[UTR36]
    Mark Davis; Michel Suignard. ï¼œUnicode Security Considerationsï¼. 19 September 2014. Unicode Technical Report #36. URL: https://www.unicode.org/reports/tr36/tr36-15.html
[UTS39]
    Mark Davis; Michel Suignard. ï¼œUnicode Security Mechanismsï¼. 3 September 2024. Unicode Technical Standard #39. URL: https://www.unicode.org/reports/tr39/tr39-30.html


â—â—trans_metadata
<p>
~THIS_PAGEã¯ã€~WHATWGã«ã‚ˆã‚‹
<a href="https://url.spec.whatwg.org/">URL Standard</a>
ã‚’æ—¥æœ¬èªã«ç¿»è¨³ã—ãŸã‚‚ã®ã§ã™ã€‚
~PUB
</p>

â—â—spec_metadata

Participate:
	<a href="https://github.com/whatwg/url">GitHub whatwg/url</a> (<a href="https://github.com/whatwg/url/issues/new/choose">new issue</a>, <a href="https://github.com/whatwg/url/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	<a href="https://github.com/whatwg/url/commits">GitHub whatwg/url/commits</a>
	<a href="https://url.spec.whatwg.org/commit-snapshots/9bc33c39d4a6cd6a936ea7620b5a69f606ec0d4c/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/urlstandard">@urlstandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/url">web-platform-tests url/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/url">ongoing work</a>)

å„å›½èªç¿»è¨³ï¼ˆéè¦ç¯„çš„ï¼‰
	æ—¥æœ¬èªï¼ˆã“ã®ãƒšãƒ¼ã‚¸ï¼‰
	<a href="https://htmlspecs.com/url/" hreflang="zh-hans" lang="zh-hans" rel="alternate">ç®€ä½“ä¸­æ–‡</a>

</script>
</head>
<body>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDUiIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzNjNzkwYSIgc3Ryb2tlLXdpZHRoPSIxMCIvPgo8cGF0aCBkPSJtNDUsMzFoMTB2MTBoLTEwem0wLDI4aDEwdjEwaC0xMCIgZmlsbD0iIzNjNzkwYSIvPgo8L3N2Zz4K"
></a>

	<hgroup>
<h1>URL</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
â—è¦ç´„

<p>
URL æ¨™æº–ã¯ã€ï¼»
~URL, ~domain, ~IP~address, ~form_urlencodedå½¢å¼
ï¼½ãŠã‚ˆã³ ãã‚Œã‚‰ã®~APIã‚’å®šç¾©ã™ã‚‹ã€‚
â—
The URL Standard defines URLs, domains, IP addresses, the application/x-www-form-urlencoded format, and their API.
</p>

	</section>

<main id="MAIN0">

	<section id="goals">
<h2 title="Goals">ç›®æ¨™</h2>

<p>
~URLæ¨™æº–ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹~approachã«ã‚ˆã‚Šï¼Œ~URLã‚’å…¨éƒ¨çš„ã«ç›¸äº’é‹ç”¨å¯èƒ½ã«ã™ã‚‹ã“ã¨ã‚’ç›®æŒ‡ã™ï¼š
â—
The URL standard takes the following approach towards making URLs fully interoperable:
</p>

<ul>
	<li>
ï¼»
`RFC3986$r, `RFC3987$r
ï¼½ã‚’ç¾ä»Šã®å®Ÿè£…ã«æƒã‚ã›ã¦ã€
ãã®éç¨‹ã®ä¸­ã§ãã‚Œã‚‰ã®~RFCã‚’éå»ã®ã‚‚ã®ã«ã™ã‚‹
ï¼ˆä¾‹ãˆã°ï¼Œï¼»
ç©ºç™½, ä»–ã® â€œåˆæ³•ã§ãªã„â€ ~cp, ~queryã®ç¬¦å·åŒ–æ³•, åŒç­‰æ€§, æ­£æº–-åŒ–
ï¼½ãªã©ã®æ¦‚å¿µã¯ã€
ã©ã‚Œã‚‚~~å®Œå…¨ã«ã¯å…±æœ‰-ã‚‚ã—ãã¯å®šç¾©ã•ã‚Œã¦ã„ãªã„ï¼‰ã€‚
~URLã®æ§‹æ–‡è§£æ-æ³•ã¯ã€
~HTMLã®æ§‹æ–‡è§£æ-æ³•ã¨åŒç¨‹åº¦ã«ç¢ºå›ºã«ãªã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
Align RFC 3986 and RFC 3987 with contemporary implementations and obsolete the RFCs in the process. (E.g., spaces, other "illegal" code points, query encoding, equality, canonicalization, are all concepts not entirely shared, or defined.) URL parsing needs to become as solid as HTML parsing. [RFC3986] [RFC3987]
</li>
	<li>
èª~URLã‚’æ¨™æº–~åŒ–ã™ã‚‹ã€‚
URI ã¨ IRI ã¯æ··åŒã•ã‚Œæ˜“ã„ã€‚
å®Ÿæ–½ã«ãŠã„ã¦ã¯ï¼Œã©ã¡ã‚‰ã«ã‚‚åŒã˜~algoãŒåˆ©ç”¨ã•ã‚Œã‚‹ã®ã§ã€
ãã‚Œã‚‰ã‚’åŒºåˆ¥ã™ã‚‹åˆ©ç‚¹ã¯ç„¡ã„ã€‚
`~Webã®æ¤œç´¢çµæœï¼ https://trends.google.com/trends/explore?q=url,uri$ã§ã‚‚ï¼Œ
~URLã®æ–¹ãŒå„ªä½ã«ã‚ã‚‹ã€‚
â—
Standardize on the term URL. URI and IRI are just confusing. In practice a single algorithm is used for both so keeping them distinct is not helping anyone. URL also easily wins the search result popularity contest.
</li>
	<li>
`URI [sic] ã®ç”Ÿæˆå…ƒï¼ ~RFCx/rfc6454#section-4$ `RFC6454$r
ã«å–ã£ã¦ä»£ã‚ã‚‹ã€‚
â—
Supplanting Origin of a URI [sic]. [RFC6454]
</li>
	<li>
~URLã®æ—¢å­˜ã®~JS~APIã«ãŠã‘ã‚‹å…¨éƒ¨çš„ãªè©³ç´°ã‚’å®šç¾©ã—ã¦ï¼Œ
ã‚ˆã‚Šä½œæ¥­ã—æ˜“ãã™ã‚‹ãŸã‚ã®å¢—è£œã‚’è¿½åŠ ã™ã‚‹ã€‚
ã¾ãŸã€
~HTMLè¦ç´ ã‚’é€šã•ãªã„~URLæ“ä½œ~ç”¨ã«ï¼Œ
`URL$I ~objã‚’æ–°ãŸã«è¿½åŠ ã™ã‚‹
ï¼ˆ~JS~workerç’°å¢ƒ~ç”¨ã«æœ‰ç”¨ã«ãªã‚‹ï¼‰ã€‚
â—
Define URLâ€™s existing JavaScript API in full detail and add enhancements to make it easier to work with. Add a new URL object as well for URL manipulation without usage of HTML elements. (Useful for JavaScript worker environments.)
</li>
	<li>
ï¼»
æ§‹æ–‡è§£æå™¨, ç›´åˆ—åŒ–å™¨, ~API
ï¼½ã®çµ„åˆnã«ãŠã‘ã‚‹å†ªç­‰æ€§ã‚’ä¿è¨¼ã™ã‚‹ã€‚
ä¾‹ãˆã°ã€
æ§‹æ–‡è§£æã—ã¦ã‹ã‚‰ç›´åˆ—åŒ–ã™ã‚‹æ¼”ç®—ã‚’é‡ã­ã¦é©ç”¨ã—ã¦ã‚‚ï¼Œ
1 å›ã ã‘é©ç”¨ã—ãŸçµæœï¼ˆå¤±æ•—ã§ãªã„ã¨ã™ã‚‹ï¼‰ã¨åŒã˜ã«ãªã‚‹ã“ã¨ã€‚
åŒæ§˜ã«ã€
~APIã‚’é€šã—ã¦æ“ä½œã—ãŸçµæœï¼ˆå¤±æ•—ã§ãªã„ã¨ã™ã‚‹ï¼‰ã«å¯¾ã—ï¼Œ
ãã‚Œã‚’ç›´åˆ—åŒ–ã—ã¦ã‹ã‚‰æ§‹æ–‡è§£æã—ãŸçµæœã¯ã€
ä½•å›~é©ç”¨ã—ã‚ˆã†ãŒåŒã˜ã«ãªã‚‹ã“ã¨ã€‚
â—
Ensure the combination of parser, serializer, and API guarantee idempotence. For example, a non-failure result of a parse-then-serialize operation will not change with any further parse-then-serialize operations applied to it. Similarly, manipulating a non-failure result through the API will not change from applying any number of serialize-then-parse operations to it.
</ul>

<p class="note">æ³¨è¨˜ï¼š
ç·¨é›†è€…ãŸã¡ãŒã“ã®~~ä¸»é¡Œã«é–¢ã—ã‚ˆã‚Šå¤šãã‚’å­¦ã¶ã«é€£ã‚Œã€
ç›®æ¨™ã¨ãªã‚‹è¦–é‡ã¯~~æ‹¡ãŒã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
â—
As the editors learn more about the subject matter the goals might increase in scope somewhat.
</p>

	</section>
	<section id="_conventions">
<h2>ã€ã“ã®è¨³ã«ç‰¹æœ‰ãªè¡¨è¨˜è¦ç´„ã€‘</h2>

â—è¡¨è¨˜è¨˜å·

<p>
åŠ ãˆã¦ã€
æ¬¡ã®è¨˜æ³•ã‚‚åˆ©ç”¨ã™ã‚‹
â‡’
%s ~APPEND %a ~APPEND %b ~APPEND â€¦
â‡’
ã“ã‚Œã¯ã€
å·¦è¾ºã®ï¼»
æ–‡å­—åˆ—ï¼~byteåˆ—
ï¼½ %s ã®æœ«å°¾ã«å¾Œç¶šã®ï¼»
æ–‡å­—åˆ—ï¼~byteåˆ—
ï¼½ %a, %b, â€¦ ã‚’ç¤ºã•ã‚ŒãŸé †ã«ä»˜åŠ ã™ã‚‹æ¼”ç®—ã‚’è¡¨ã™ã€‚
å¼ã¨ã—ã¦ç”¨ã„ã‚‰ã‚ŒãŸå ´åˆã€
çµæœã® %s ãŒå¼ã®å€¤ã«ãªã‚‹ã€‚
</p>

	</section>
	<section id="infrastructure">

<h2 title="Infrastructure">1. åŸºç›¤</h2>

<p>
ã“ã®ä»•æ§˜ã¯ `Infra^cite `INFRA$r ã«ä¾å­˜ã™ã‚‹ã€‚
â—
This specification depends on Infra. [INFRA]
</p>

<div class="p">
<p>
ã“ã®ä»•æ§˜ã«åˆ©ç”¨ã•ã‚Œã‚‹ä¸€éƒ¨ã®ç”¨èªã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ï¼»
æ¨™æº–ï¼ä»•æ§˜
ï¼½ã«ã¦å®šç¾©ã•ã‚Œã‚‹
â‡’ï¼ƒ
`Encoding^cite `ENCODING$r,
`File API^cite `FILEAPI$r,
`HTML^cite `HTML$r,
`Unicode IDNA Compatibility Processing^cite `UTS46$r,
`Web IDL^cite `WEBIDL$r
â—
Some terms used in this specification are defined in the following standards and specifications:
â€¢ Encoding [ENCODING]
â€¢ File API [FILEAPI]
â€¢ HTML [HTML]
â€¢ Unicode IDNA Compatibility Processing [UTS46]
â€¢ Web IDL [WEBIDL]
</div>

<hr>

<div class="algo">
<p>
`æ•´æ•°ã‚’ç›´åˆ—åŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( æ•´æ•° %N )
ã«å¯¾ã—
â‡’
~RET %N ã‚’ 10 é€²æ•°ã§æœ€çŸ­ã«è¡¨ç¾ã™ã‚‹æ–‡å­—åˆ—
ã€çµæœã«ã¯ã€`~ASCIIæ•°å­—$ã«åŠ ãˆï¼Œè² ç¬¦å·ã‚‚å«ã¾ã‚Œå¾—ã‚‹ãŒã€ã“ã®ä»•æ§˜ã§ã¯ï¼Œè² ç¬¦å·ã¯ç”Ÿã˜å¾—ãªã„ã€‚ã€‘
â—
To serialize an integer, represent it as the shortest possible decimal number.
</p>
</div>

		<section id="writing">
<h3 title="Writing">1.1. æ›¸å‡ºæ³•</h3>

<p>
`æ¤œè¨¼~error@
ã¨ã¯ã€
å…¥åŠ›ã¨å¦¥å½“ãªå…¥åŠ›ã¨ã®é–“ã®ä¸ä¸€è‡´ã‚’æŒ‡ç¤ºã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
~UA
â€” ã¨ã‚Šã‚ã‘ï¼Œé©åˆæ€§~æ¤œæŸ»å™¨ â€”
ã«ã¯ã€
ã©ã“ã‹ã¸ãã‚Œã‚’å ±å‘Šã™ã‚‹ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
â—
A validation error indicates a mismatch between input and valid input. User agents, especially conformance checkers, are encouraged to report them somewhere.
</p>

<div class="note">
<p>æ³¨è¨˜ï¼š
`æ¤œè¨¼~error$ã¯ã€
æ§‹æ–‡è§£æå™¨ã‚’çµ‚äº†ã•ã›ã‚‹ã‚‚ã®ã§ã¯ãªã„ã€‚
æ§‹æ–‡è§£æå™¨ã®çµ‚äº†nã¯ã€
å¸¸ã«ï¼Œæ˜ç¤ºçš„ã«ãã†è¨˜ã•ã‚Œã‚‹
â€” ~RET æ–‡ãªã©ã«ã‚ˆã‚Šã€‚
â—
A validation error does not mean that the parser terminates. Termination of a parser is always stated explicitly, e.g., through a return statement.
</p>

<p>
`æ¤œè¨¼~error$ã‚’é€šé”ã™ã‚‹ã“ã¨ã¯ã€
æœ‰ç”¨ã«ãªã‚‹
â€” ~errorã®å–æ‰±ã„ã¯ç›´æ„Ÿçš„ã§ãªã„ã“ã¨ã‚‚ã‚ã‚Šã€ï¼»
æ—§æ¥ã®~UAã¯ã€
æ­£ã—ã„~errorã®å–æ‰±ã„ã‚’å®Ÿè£…ã—ã¦ã„ãªã„ã‹ã‚‚ã—ã‚Œãªã„ï¼
ä»–ã®é–‹ç™ºè€…ã«ã¨ã£ã¦ã¯ã€
ä½•ã‚’æ„å›³ã—ã¦æ›¸å‡ºã•ã‚ŒãŸã‹æ˜ç­ã§ãªã„ã‹ã‚‚ã—ã‚Œãªã„
ï¼½ã®ã§ã€‚
â—
It is useful to signal validation errors as error-handling can be non-intuitive, legacy user agents might not implement correct error-handling, and the intent of what is written might be unclear to other developers.
</p>
</div>

<table class="grid-table" id="_error-types"><thead>
<tr><th>
~errorã®ç¨®åˆ¥
â—
Error type
<th>
~errorã®è¨˜è¿°
â—
Error description
<th>
ä¾‹
<th>
å¤±æ•—ã‹ï¼Ÿ
â—
Failure
<tbody>

<tr><th colspan="4" scope="rowgroup">
`Â§ ~IDNAï¼ #idna$
â—
IDNA

<tr><td>`domain-to-ASCII@err
<td>
<p>
`Unicode ToASCII$AO `UTS46$r ãŒï¼Œ
~errorã‚’è¨˜éŒ²ã—ãŸã‹ç©º~æ–‡å­—åˆ—ã‚’è¿”ã—ãŸã€‚
â—
Unicode ToASCII records an error or returns the empty string. [UTS46]
</p>

<p class="note">æ³¨è¨˜ï¼š
`Unicode ToASCII$AO ã«ãŠã‘ã‚‹~errorã«ã¤ã„ã¦ã®è©³ç´°ãŒè¨˜éŒ²ã•ã‚ŒãŸå ´åˆã€
~UAã«ã¯ï¼Œãã‚Œã‚‚æ¸¡ã™ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
â—
If details about Unicode ToASCII errors are recorded, user agents are encouraged to pass those along.
</p>
<td>
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`domain-invalid-code-point@err
<td>
å…¥åŠ›ã®`~host$ãŒï¼Œ`ç¦æ­¢~domain~cp$ã‚’åŒ…å«ã—ã¦ã„ã‚‹ã€‚
â—
The inputâ€™s host contains a forbidden domain code point.
<td class="example">
~URLãŒ`ç‰¹åˆ¥$ã§ã‚ã‚‹ã¨ãã€
ãã®~hostãŒï¼Œå‡¦ç†ã•ã‚Œã‚‹å‰ã«`~percent-å¾©å·ã•ã‚ŒãŸï¼ #string-percent-decode$
â€” ~URLãŒ `https://exa%23mple.org^l ã§ã‚ã£ãŸãªã‚‰ã€
ãã®çµæœï¼Œ~hostéƒ¨ä½ã¯ `exa#mple.org^l ã«ãªã‚Šã€
ã“ã®~errorã‚’èª˜ç™ºã™ã‚‹ã€‚
â—
Hosts are percent-decoded before being processed when the URL is special, which would result in the following host portion becoming "exa#mple.org" and thus triggering this error.
â—
"https://exa%23mple.org"
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`domain-to-Unicode@err
<td>
<p>
`Unicode ToUnicode$AO `UTS46$r ãŒï¼Œ
~errorã‚’è¨˜éŒ²ã—ãŸã€‚
â—
Unicode ToUnicode records an error. [UTS46]
</p>

<p class="note">æ³¨è¨˜ï¼š
`domain-to-ASCII$err ã¨åŒã˜è€ƒæ…®ç‚¹ãŒé©ç”¨ã•ã‚Œã‚‹ã€‚
â—
The same considerations as with domain-to-ASCII apply.
</p>
<td>
<td>Â·
<tbody>

<tr><th colspan="4" scope="rowgroup">
`Â§ ~hostã®æ§‹æ–‡è§£æ-æ³•ï¼ #host-parsing$
â—
Host parsing

<tr><td>`host-invalid-code-point@err
<td>
`ä¸é€æ˜ãª~host$ï¼ˆ`ç‰¹åˆ¥$ã§ãªã„~URLï¼‰ãŒï¼Œ`ç¦æ­¢~host~cp$ã‚’åŒ…å«ã—ã¦ã„ã‚‹ã€‚
â—
An opaque host (in a URL that is not special) contains a forbidden host code point.
<td class="example">
`foo://exa[mple.org^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv4-empty-part@err
<td>
`~IPv4~address$ãŒï¼Œ
â. ã§çµ‚ç«¯ã—ã¦ã„ã‚‹ã€‚
â—
An IPv4 address ends with a U+002E (.).
<td class="example">
`https://127.0.0.1./^l
<td>Â·

<tr><td>`IPv4-too-many-parts@err
<td>
`~IPv4~address$ã‚’æˆã™æˆåˆ†pã®å€‹æ•°ãŒï¼Œ
4 ã§ãªã„ã€‚
â—
An IPv4 address does not consist of exactly 4 parts.
<td class="example">
`https://1.2.3.4.5/^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv4-non-numeric-part@err
<td>
`~IPv4~address$ã‚’æˆã™ã‚ã‚‹æˆåˆ†pãŒï¼Œ
æ•°ã§ãªã„ã€‚
â—
An IPv4 address part is not numeric.
<td class="example">
`https://test.42^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv4-non-decimal-part@err
<td>
`~IPv4~address$ã‚’æˆã™ã‚ã‚‹æˆåˆ†pãŒï¼Œï¼»
~hexadecimalï¼~octal
ï¼½æ•°å­—ã‚’åˆ©ç”¨ã—ã¦è¡¨å‡ºã•ã‚ŒãŸç•ªå·ã§ã‚ã‚‹ã€‚
â—
The IPv4 address contains numbers expressed using hexadecimal or octal digits.
<td class="example">
`https://127.0.0x0.1^l
<td>Â·

<tr><td>`IPv4-out-of-range-part@err
<td>
`~IPv4~address$ã‚’æˆã™ã‚ã‚‹æˆåˆ†pãŒï¼Œ
255 ã‚’è¶…éã—ã¦ã„ã‚‹ã€‚
â—
An IPv4 address part exceeds 255.
<td class="example">
`https://255.255.4000.1^l
<td>
å¤±æ•—ã™ã‚‹
ï¼ˆæœ€å¾Œã®æˆåˆ†pã«é©ç”¨-å¯èƒ½ãªå ´åˆã«é™ã‚Šï¼‰
â—
Yes
(only if applicable to the last part)

<tr><td>`IPv6-unclosed@err
<td>
`~IPv6~address$ã‚’é–‰ã˜ã‚‹ â] ãŒæ¬ è½ã§ã‚ã‚‹ã€‚
â—
An IPv6 address is missing the closing U+005D (]).
<td class="example">
`https://[::1^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv6-invalid-compression@err
<td>
`~IPv6~address$ãŒï¼Œ
ä¸é©æ­£ãªåœ§ç¸®ã‹ã‚‰å§‹ã¾ã£ã¦ã„ã‚‹ã€‚
â—
An IPv6 address begins with improper compression.
<td class="example">
`https://[:1]^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv6-too-many-pieces@err
<td>
`~IPv6~address$ãŒåŒ…å«ã™ã‚‹~pieceã®å€‹æ•°ãŒï¼Œ
8 ä»¥ä¸‹ã§ãªã„ã€‚
â—
An IPv6 address contains more than 8 pieces.
<td class="example">
`https://[1:2:3:4:5:6:7:8:9]^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv6-multiple-compression@err
<td>
`~IPv6~address$ãŒï¼Œ
2 ç®‡æ‰€ä»¥ä¸Šã§åœ§ç¸®ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
An IPv6 address is compressed in more than one spot.
<td class="example">
`https://[1::1::1]^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv6-invalid-code-point@err
<td>
`~IPv6~address$ãŒï¼Œï¼»
`~ASCII~hexæ•°å­—$, â:
ï¼½ä»¥å¤–ã®~cpã‚’åŒ…å«ã—ã¦ã„ã‚‹ã‹,
æœŸå¾…ã•ã‚Œãªã„æ‰€ã§çµ‚ç«¯ã—ã¦ã„ã‚‹ã€‚
â—
An IPv6 address contains a code point that is neither an ASCII hex digit nor a U+003A (:). Or it unexpectedly ends.
<td class="example">
<p>
`https://[1:2:3!:4]^l
</p>

<p>
`https://[1:2:3:]^l
</p>
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv6-too-few-pieces@err
<td>
åœ§ç¸®-æ¸ˆã¿ã§ãªã„`~IPv6~address$ã‚’æˆã™~pieceã®å€‹æ•°ãŒï¼Œ
8 å€‹ã«æº€ãŸãªã„ã€‚
â—
An uncompressed IPv6 address contains fewer than 8 pieces.
<td class="example">
`https://[1:2:3]^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv4-in-IPv6-too-many-pieces@err
<td>
`~IPv4~address$æ§‹æ–‡ã‚’ä¼´ã†`~IPv6~address$ã«ãŠã„ã¦ã€
~IPv6~addressã‚’æˆã™~pieceã®å€‹æ•°ãŒï¼Œ
6 ä»¥ä¸‹ã§ãªã„ã€‚
â—
An IPv6 address with IPv4 address syntax: the IPv6 address has more than 6 pieces.
<td class="example">
`https://[1:1:1:1:1:1:1:127.0.0.1]^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv4-in-IPv6-invalid-code-point@err
<td>
<p>
`~IPv4~address$æ§‹æ–‡ã‚’ä¼´ã†`~IPv6~address$ã«ãŠã„ã¦ï¼š
â—
An IPv6 address with IPv4 address syntax:
</p>
<ul>
	<li>
ã‚ã‚‹~IPv4æˆåˆ†pãŒ
â‡’ï¼ƒ
ç©ºã§ã‚ã‚‹ï¼
`~ASCIIæ•°å­—$ã§ãªã„ã‚‚ã®ã‚’åŒ…å«ã—ã¦ã„ã‚‹ï¼
å…ˆé ­ã«~~ä½™è¨ˆãª 0 ã‚’åŒ…å«ã—ã¦ã„ã‚‹
â—
An IPv4 part is empty or contains a non-ASCII digit.
â—
An IPv4 part contains a leading 0.
</li>
	<li>
~IPv4æˆåˆ†pã®å€‹æ•°ãŒï¼Œ
å¤šéãã‚‹ã€‚
â—
There are too many IPv4 parts.
</li>
</ul>
<td class="example">
<p>
`https://[ffff::.0.0.1]^l
</p>

<p>
`https://[ffff::127.0.xyz.1]^l
</p>

<p>
`https://[ffff::127.0xyz]^l
</p>

<p>
`https://[ffff::127.00.0.1]^l
</p>

<p>
`https://[ffff::127.0.0.1.2]^l
</p>
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv4-in-IPv6-out-of-range-part@err
<td>
`~IPv4~address$æ§‹æ–‡ã‚’ä¼´ã†`~IPv6~address$ã«ãŠã„ã¦ã€
ã‚ã‚‹~IPv4æˆåˆ†pãŒï¼Œ
255 ã‚’è¶…éã—ã¦ã„ã‚‹ã€‚
â—
An IPv6 address with IPv4 address syntax: an IPv4 part exceeds 255.
<td class="example">
`https://[ffff::127.0.0.4000]^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`IPv4-in-IPv6-too-few-parts@err
<td>
`~IPv4~address$æ§‹æ–‡ã‚’ä¼´ã†`~IPv6~address$ã«ãŠã„ã¦ã€
~IPv4æˆåˆ†pã®å€‹æ•°ãŒï¼Œ
å°‘ãªéãã‚‹ã€‚
â—
An IPv6 address with IPv4 address syntax: an IPv4 address contains too few parts.
<td class="example">
`https://[ffff::127.0.0]^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes
<tbody>

<tr><th colspan="4" scope="rowgroup">
`Â§ ~URLã®æ§‹æ–‡è§£æ-æ³•ï¼ #url-parsing$
â—
URL parsing

<tr><td>`invalid-URL-unit@err
<td>
`~URLå˜ä½$ã§ãªã„~cpãŒè¦‹å‡ºã•ã‚ŒãŸã€‚
â—
A code point is found that is not a URL unit.
<td class="example">
<p>
`https://example.org/&gt;^l
</p>

<p>
` https://example.org ^l
</p>

<p>
`ht<br>tps://example.org^l
â—
"https://example.org"
</p>

<p>
`https://example.org/%s^l
</p>
<td>Â·

<tr><td>`special-scheme-missing-following-solidus@err
<td>
å…¥åŠ›ã®~schemeã« `//^l ãŒå¾Œç¶šã—ã¦ã„ãªã„ã€‚
â—
The inputâ€™s scheme is not followed by "//".
<td class="example">
<p>
`file:c:/my-secret-folder^l
</p>

<p>
`https:example.org^l
</p>

<pre>
const %url = new URL("https:foo.html", "https://example.org/");
</pre>
<td>Â·

<tr><td>`missing-scheme-non-relative-URL@err
<td>
å…¥åŠ›ã®`~scheme$urlãŒæ¬ è½ã§ã‚ã‚‹
â€” ï¼»
å…¥åŠ›ã¯`~ASCIIè‹±å­—$ã§å§‹ã¾ã£ã¦ã„ãªã„
ï¼½ã‹ã¤ï¼»
`åŸºåº•~URL$ã¯ä¾›ã•ã‚Œã¦ã„ãªã„ã‹ï¼Œ
ä¾›ã•ã‚ŒãŸãŒ`ä¸é€æ˜ãª~path$ã‚’æœ‰ã™ã‚‹ã®ã§`åŸºåº•~URL$ã¨ã—ã¦åˆ©ç”¨ã§ããªã„
ï¼½ã“ã¨ã«ã‚ˆã‚Šã€‚
â—
The input is missing a scheme, because it does not begin with an ASCII alpha, and either no base URL was provided or the base URL cannot be used as a base URL because it has an opaque path.
<td class="example">
<p>
å…¥åŠ›ã®`~scheme$urlãŒæ¬ è½ã£ã¦ï¼Œ`åŸºåº•~URL$ã¯ä¸ãˆã‚‰ã‚Œã¦ã„ãªã„ï¼š
â—
Inputâ€™s scheme is missing and no base URL is given:
</p>

<pre>
const %url = new URL("ğŸ’©");
</pre>

<p>
å…¥åŠ›ã®`~scheme$urlãŒæ¬ è½ã£ã¦ï¼Œ
`åŸºåº•~URL$ã¯`ä¸é€æ˜ãª~path$ã‚’æœ‰ã™ã‚‹ï¼š
â—
Inputâ€™s scheme is missing, but the base URL has an opaque path.
</p>

<pre>const %url = new URL("ğŸ’©", "mailto:user@example.org");
</pre>
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`invalid-reverse-solidus@err
<td>
~URLã¯ã€
`ç‰¹åˆ¥~scheme$ã‚’ä¼´ã†ãŒï¼Œ
â/ ã®ä»£ã‚ã‚Šã« â\ ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ã€‚
â—
The URL has a special scheme and it uses U+005C (\) instead of U+002F (/).
<td class="example">
`https://example.org\path\to\file^l
<td>Â·

<tr><td>`invalid-credentials@err
<td>
å…¥åŠ›ã¯ï¼Œ`è³‡æ ¼è¨¼ã‚’å«ã‚“ã§$ã„ã‚‹ã€‚
â—
The input includes credentials.
<td class="example">
<p>
`https://user~atã€…example.org^l
</p>

<p>
`ssh://user~atã€…example.org^l
</p>
<td>Â·

<tr><td>`host-missing@err
<td>
å…¥åŠ›ã¯ã€
`ç‰¹åˆ¥~scheme$ã‚’ä¼´ã†ãŒï¼Œ`~host$ã‚’åŒ…å«ã—ã¦ã„ãªã„ã€‚
â—
The input has a special scheme, but does not contain a host.
<td class="example">
<p>
`https://#fragment^l
</p>

<p>
`https://:443^l
</p>

<p>
`https://user:pass~atã€…^l
</p>
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`port-out-of-range@err
<td>
å…¥åŠ›ã®~portãŒï¼Œ
å¤§ãéãã‚‹ã€‚
â—
The inputâ€™s port is too big.
<td class="example">
`https://example.org:70000^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`port-invalid@err
<td>
å…¥åŠ›ã®~portãŒï¼Œ
å¦¥å½“ã§ãªã„ã€‚
â—
The inputâ€™s port is invalid.
<td class="example">
`https://example.org:7z^l
<td>
å¤±æ•—ã™ã‚‹
â—
Yes

<tr><td>`file-invalid-Windows-drive-letter@err
<td>
<p>
å…¥åŠ›ã¯`~drive_letterã‹ã‚‰é–‹å§‹ã—ã¦$ã„ã‚‹`ç›¸å¯¾~URL$sTã§ã‚ã‚‹ãŒã€
`åŸºåº•~URL$ã®`~scheme$urlã¯ `file^l ã€‚
â—
The input is a relative-URL string that starts with a Windows drive letter and the base URLâ€™s scheme is "file".
</p>
<td class="example">
<pre>
const %url = new URL("/c:/path/to/file", "file:///c:/");
</pre>

<td>Â·

<tr><td>`file-invalid-Windows-drive-letter-host@err
<td>
`file:^c ~URLã®~hostãŒï¼Œ
`~drive_letter$ã§ã‚ã‚‹ã€‚
â—
A file: URLâ€™s host is a Windows drive letter.
<td class="example">
`file://c:^l
<td>Â·
</table>

		</section>
		<section id="parsers">
<h3 title="Parsers">1.2. æ§‹æ–‡è§£æå™¨</h3>

<p>
`EOF@i
ã¨ã¯ã€ï¼»
æ–‡å­—åˆ—~stream ï¼ ~cp~stream
ï¼½ã®çµ‚ç«¯ã‚’è¡¨ã™ï¼Œæ¦‚å¿µçš„ãª~cpã§ã‚ã‚‹â€ ã€‚
â—
The EOF code point is a conceptual code point that signifies the end of a string or code point stream.
</p>

<p class="trans-note">ã€
â€œ`End Of File^enâ€ ã®ç•¥ç§°
â€” ã“ã®è¨³ã§ã¯ã€
åŸæ–‡ã® â€œEOF ~cpâ€ ã‚’å˜ã« â€œEOFâ€ ã¨ç•¥è¨˜ã™ã‚‹ã€‚
ã€‘ã€â€ 
ã—ãŸãŒã£ã¦ã€
ã©ã®æœ¬ç‰©ã®~cpã¨ã‚‚ç­‰ã—ããªã„ã€‚
ã€‘</p>

<p>
æ‰€ä¸ã®`æ–‡å­—åˆ—$ %å…¥åŠ› ç”¨ã®
`~pointer@
ã¯ã€
%å…¥åŠ› ã®ä¸­ã® ã‚ã‚‹`~cp$ã‚’æŒ‡ã™æ•´æ•°ã§ã‚ã‚Šï¼ŒåˆæœŸ~æ™‚ã«ã¯ %å…¥åŠ› ã®å…ˆé ­ã‚’æŒ‡ã™ã€å€¤ã¨ã—ã¦ã¯ 0 ã€‘ã¨ã™ã‚‹ã€‚
ãã‚Œã¯ã€
âˆ’1 ãªã‚‰ã° Îµ ã‚’æŒ‡ã™ï¼ˆ â€œã©ã“ã‚‚æŒ‡ã•ãªã„â€ ï¼‰ï¼
%å…¥åŠ› ã®`~cpé•·ã•$ä»¥ä¸Šãªã‚‰ã° `EOF$i ã‚’æŒ‡ã™ã€ %å…¥åŠ› ãŒç©ºãªã‚‰ã°ã€å¸¸ã«ãã†ãªã‚‹ã€‘ã€‚
â—
A pointer for a string input is an integer that points to a code point within input. Initially it points to the start of input. If it is âˆ’1 it points nowhere. If it is greater than or equal to inputâ€™s code point length, it points to the EOF code point.
</p>

<p>
`~pointer$ãŒåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ä¸‹ã§ã®è¨˜å·
`C@V,
`C1@V,
`C2@V
ã¯ã€
é †ã«ï¼»
`~pointer$ãŒæŒ‡ã—ã¦ã„ã‚‹`~cp$, ãã®æ¬¡ã®~cp, æ¬¡ã®æ¬¡ã®~cp
ï¼½ã‚’å‚ç…§ã™ã‚‹ã€‚
`~pointer$ãŒ Îµ ã‚’æŒ‡ã—ã¦ã„ã‚‹å ´åˆã€
ã“ã‚Œã‚‰ã®è¨˜å·ã¯åˆ©ç”¨ã•ã‚Œå¾—ãªã„ã€‚
`~pointer$ãŒ `EOF$i ã‚’æŒ‡ã—ã¦ã„ã‚‹å ´åˆï¼Œ
`C$V ã¯ `EOF$i ã«ãªã‚Šã€
`C1$V, `C2$V ã«ã¤ã„ã¦ã‚‚åŒæ§˜ã¨ã™ã‚‹ã€‚
â—
When a pointer is used, c references the code point the pointer points to as long as it does not point nowhere. When the pointer points to nowhere c cannot be used.
â—
When a pointer is used, remaining references the code point substring from the pointer + 1 to the end of the string, as long as c is not the EOF code point. When c is the EOF code point remaining cannot be used.
</p>

<p class="example">
ä¾‹ãˆã°ã€
å‡¦ç†ã•ã‚Œã‚‹`æ–‡å­—åˆ—$ãŒ `http://example.com^l ã§ï¼Œ
`~pointer$ãŒ `o^l ã‚’æŒ‡ã—ã¦ã„ã‚‹ãªã‚‰ã€ï¼»
`C$V, `C1$V, `C2$V
ï¼½ã¯ï¼Œé †ã«ï¼»
âo, âm, `EOF$i
ï¼½ã«ãªã‚‹ã€‚
â—
If "mailto:username@example" is a string being processed and a pointer points to @, c is U+0040 (@) and remaining is "example".
</p>

<p class="example">
ä¾‹ãˆã°ã€
`~pointer$ã¯æ–‡å­—åˆ—ã®å…ˆé ­ã‚’æŒ‡ã—ã¦ã„ã‚‹ä¸‹ã§ï¼Œ
1 æ¸›ã‚‰ã—ã¦ã‹ã‚‰ `C$V ï¼ˆã‚ã‚‹ã„ã¯ `C1$V, `C2$V ï¼‰ã‚’åˆ©ç”¨ã™ã‚‹ã®ã¯ã€ä»•æ§˜ã«ãŠã‘ã‚‹ã€‘~errorã§ã‚ã‚‹ã€‚
â—
If the empty string is being processed and a pointer points to the start and is then decreased by 1, using c or remaining would be an error.
</p>

<p class="trans-note">ã€
`C1$V, `C2$V ã¯ã€
åŸæ–‡ã®
<dfn id="remaining">%remaining</dfn>
ã«ä»£ãˆã¦ï¼Œã“ã®è¨³ã«å°å…¥ã—ãŸè¨˜å·ã§ã‚ã‚‹
â€” %remaining ã¯ï¼»
`~pointer$ ~PLUS 1 ã‹ã‚‰`çµ‚ç«¯ã¾ã§ã‚’æˆã™~cpéƒ¨åˆ†æ–‡å­—åˆ—$
ï¼½ï¼ˆ `C1$V ä»¥é™ã‚’æˆã™éƒ¨åˆ†æ–‡å­—åˆ—ï¼‰ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŒã€
ãã‚Œã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ã©ã®ç®‡æ‰€ã‚‚ï¼Œå®Ÿéš›ã«ã¯ `C1$V, `C2$V ã—ã‹åˆ©ç”¨ã—ã¦ã„ãªã„ã®ã§ã€‚
ã€‘ã€
`C$V ã¯ï¼ŒåŸæ–‡ã§ã¯å°æ–‡å­— â€œcâ€ ã§ã‚ã‚‹ãŒã€
æ—¥æœ¬èªã®å­—ã®å¤§ãã•ã¨ã®å…¼ã­åˆã„ã«ã‚ˆã‚Šï¼Œã“ã®è¨³ã§ã¯å¤§æ–‡å­—ã§è¨˜ã™ã“ã¨ã«ã™ã‚‹ã€‚
ã€‘</p>

		</section>
		<section id="percent-encoded-bytes">
<h2 title="Percent-encoded bytes">1.3. ~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte</h2>

<p class="trans-note">ã€
â€œ~percent-â€ ã¯ã€
åŸæ–‡ã®æ¥é ­èª â€œpercent-â€ ã®ï¼ˆã“ã®è¨³ã«ã‚ˆã‚‹ï¼‰ç•¥è¨˜ã§ã‚ã‚Šï¼Œæ–‡å­— `%^l ã«é–¢ã‚ã‚‹ã“ã¨ã‚’è¡¨ã™ã€‚
ã€‘</p>

<p>
`~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte@
ã¨ã¯ã€ï¼»
â%, `~ASCII~hexæ•°å­—$, `~ASCII~hexæ•°å­—$
ï¼½ã®ä¸¦ã³ãŒæˆã™æ–‡å­—åˆ—ã§ã‚ã‚‹ã€‚
â—
A percent-encoded byte is U+0025 (%), followed by two ASCII hex digits.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä¸€èˆ¬ã«ï¼Œ
`~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte$ãŸã¡ãŒæˆã™é€£åˆ—~ç”¨ã«ã¯ã€ï¼»
`æ–‡å­—åˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹$,
`~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$
ï¼½ã‚’é †ã«é©ç”¨ã—ãŸã¨ãã®çµæœãŒ `å¤±æ•—^i ã«ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒï¼Œè‰¯ã„æ¡ˆã«ãªã‚‹ã€‚
ã“ã‚ŒãŒã©ã†é‡è¦ã«ãªã‚‹ã‹ã¯ã€
`~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte$ãŒã©ã“ã§åˆ©ç”¨ã•ã‚Œã‚‹ã‹ã«ä¾å­˜ã™ã‚‹ã€‚
ä¾‹ï¼š
`~hostæ§‹æ–‡è§£æå™¨$ç”¨ã«ã¯ï¼Œã“ã®åŠ©è¨€ã«å¾“ã‚ãªã„ã“ã¨ã¯è‡´å‘½çš„ã§ã‚ã‚‹ä¸€æ–¹ã€
`~URLã®å…·ç¾åŒ–ï¼ #url-rendering-i18n$ç”¨ã«ã¯ï¼Œ`~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte$ã‚’`~percent-å¾©å·-ï¼ #string-percent-decode$ã—ãªã„ã§å…·ç¾åŒ–ã™ã‚‹ã“ã¨ã«ãªã‚ã†ã€‚
â—
It is generally a good idea for sequences of percent-encoded bytes to be such that, when percent-decoded and then passed to UTF-8 decode without BOM or fail, they do not end up as failure. How important this is depends on where the percent-encoded bytes are used. E.g., for the host parser not following this advice is fatal, whereas for URL rendering the percent-encoded bytes would not be rendered percent-decoded.
</p>

<div class="algo">
<p>
`~byteã‚’æ–‡å­—åˆ—ã«~percent-ç¬¦å·åŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( 1 å€‹ã®`~byte$ %~byte )
ã«å¯¾ã—
â‡’
~RET æ¬¡ã«ä¸ãˆã‚‹`~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte$
â‡’
â% ~APPEND ï¼»
%~byte ã‚’è¡¨ç¾ã™ã‚‹ 2 å€‹ã®`~ASCII~hexæ•°å­—ï¼ˆå¤§æ–‡å­—ï¼‰$
ï¼½
â—
To percent-encode a byte byte, return a string consisting of U+0025 (%), followed by two ASCII upper hex digits representing byte.
</p>
</div>

<div class="algo">
<p>
`~byteåˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~byteåˆ—$ %å…¥åŠ› )
ã«å¯¾ã—ï¼š
â—
To percent-decode a byte sequence input, run these steps:
</p>

<p class="warning">è­¦å‘Šï¼š
%å…¥åŠ› ãŒ`~ASCII~byte$ä»¥å¤–ã®~byteã‚’å«ã¿å¾—ã‚‹ã¨ãã«ï¼Œ
`~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$ä»¥å¤–ã‚’åˆ©ç”¨ã™ã‚‹ã®ã¯ã€
~secureã§ãªã„ã“ã¨ã‚‚ã‚ã‚‹ã®ã§æ¨å¥¨ã•ã‚Œãªã„ã€‚
â—
Using anything but UTF-8 decode without BOM when input contains bytes that are not ASCII bytes might be insecure and is not recommended.
</p>

<ol>
	<li>
%å‡ºåŠ› ~LET ç©º`~byteåˆ—$
â—
Let output be an empty byte sequence.
</li>
	<li>
%L ~LET %å…¥åŠ› ã®`é•·ã•$byte
â—
â†“</li>
	<li>
%N ~LET 1
â—
â†“</li>
	<li>
<p>
~WHILEï¼»
%N ~LTE %L
ï¼½ï¼š
</p>
		<ol>
			<li>
%~byte ~LET %å…¥åŠ› ã® %N å€‹ç›®ã®~byte
</li>
			<li>
%N ~INCBY 1
</li>
			<li>
<p>
~IFï¼»
%~byte ~EQ â›%
ï¼½~ANDï¼»
%N ~PLUS 1 ~LTE %L
ï¼½ï¼š
</p>
				<ol>
					<li>
%~byteåˆ— ~LET %å…¥åŠ› ã®ï¼»
%N å€‹ç›®, %N ~PLUS 1 å€‹ç›®
ï¼½ã®~byteãŒæˆã™~byteåˆ—
</li>
					<li>
<p>
~IFï¼»
%~byteåˆ— ã‚’æˆã™ã©ã®~byte %b ã‚‚ï¼»
%b ~IN { â›0 ã€œ â›9, â›A ã€œ â›F, â›a ã€œ â›f }
ï¼½ã‚’æº€ãŸã™
ï¼½ï¼š
</p>
						<ol>
							<li>
%~hexæ–‡å­—åˆ— ~LET `åŒå‹ã«å¾©å·ã™ã‚‹$( %~byteåˆ— )
</li>
							<li>
%~byte ~SET ï¼»
%~hexæ–‡å­—åˆ— ã‚’~hexadecimalæ•°ã¨ã—ã¦è§£é‡ˆã—ãŸçµæœã®æ•°
ï¼½ã‚’å€¤ã¨ã™ã‚‹~byte
</li>
							<li>
%N ~INCBY 2
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%å‡ºåŠ› ~APPEND %~byte
</li>
		</ol>
â—
For each byte byte in input:
â€¢ If byte is not 0x25 (%), then append byte to output.
â€¢ Otherwise, if byte is 0x25 (%) and the next two bytes after byte in input are not in the ranges 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F), and 0x61 (a) to 0x66 (f), all inclusive, append byte to output.
â€¢ Otherwise:
â€¢â€¢ Let bytePoint be the two bytes after byte in input, decoded, and then interpreted as hexadecimal number.
â€¢â€¢ Append a byte whose value is bytePoint to output.
â€¢â€¢ Skip the next two bytes in input.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`æ–‡å­—åˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~scalarå€¤~æ–‡å­—åˆ—$ %å…¥åŠ› )
ã«å¯¾ã—
â‡’
~RET `~byteåˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹$( `~UTF-8ç¬¦å·åŒ–ã™ã‚‹$( %å…¥åŠ› ) )
â—
To percent-decode a scalar value string input:
â€¢ Let bytes be the UTF-8 encoding of input.
â€¢ Return the percent-decoding of bytes.
</p>
</div>

<p class="note">æ³¨è¨˜ï¼š
ä¸€èˆ¬ã«ã€
~percent-ç¬¦å·åŒ–ã—ãŸçµæœã®æ–‡å­—åˆ—ã‚’æˆã™ â% ~cpã¯ï¼Œå…¥åŠ›ã‚ˆã‚Š~~å¢—ãˆã€
~percent-å¾©å·ã—ãŸçµæœã®~byteåˆ—ã‚’æˆã™ â›% ~byteã¯ï¼Œå…¥åŠ›ã‚ˆã‚Š~~æ¸›ã‚‹ã€‚
â—
In general, percent-encoding results in a string with more U+0025 (%) code points than the input, and percent-decoding results in a byte sequence with less 0x25 (%) bytes than the input.
</p>

<hr>

<p class="trans-note">ã€
æ¬¡ã«æŒ™ã’ã‚‹å„ç¨®ï¼»
~cpãŸã¡ãŒæˆã™é›†åˆ
ï¼½ã¯ã€
å¾Œç¶šã®å„ç¨® â€œ~percent-ç¬¦å·åŒ–ã™ã‚‹â€ ~algoã‹ã‚‰åˆ©ç”¨ã•ã‚Œã‚‹ï¼š
ã€‘</p>

<ul>
	<li>
`~C0åˆ¶å¾¡æ–‡å­—~percent-ç¬¦å·åŒ–-é›†åˆ@
ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹~cpãŒæˆã™é›†åˆã§ã‚ã‚‹
â‡’ï¼ƒ
`~C0åˆ¶å¾¡æ–‡å­—$,
`007F^U `DELETE^cn ã€œ `10FFFF^U
â—
The C0 control percent-encode set are the C0 controls and all code points greater than U+007E (~).
</li>
	<li>
`ç´ ç‰‡~percent-ç¬¦å·åŒ–-é›†åˆ@
ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹~cpãŒæˆã™é›†åˆã§ã‚ã‚‹
â‡’ï¼ƒ
`~C0åˆ¶å¾¡æ–‡å­—~percent-ç¬¦å·åŒ–-é›†åˆ$,
`0020^U `SPACE^cn,
â",
`003C^U `&lt;^smb,
`003E^U `&gt;^smb,
â`
â—
The fragment percent-encode set is the C0 control percent-encode set and U+0020 SPACE, U+0022 ("), U+003C (&lt;), U+003E (&gt;), and U+0060 (`).
</li>
	<li>
<p>
`~query~percent-ç¬¦å·åŒ–-é›†åˆ@
ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹~cpãŒæˆã™é›†åˆã§ã‚ã‚‹
â‡’ï¼ƒ
`~C0åˆ¶å¾¡æ–‡å­—~percent-ç¬¦å·åŒ–-é›†åˆ$,
`0020^U `SPACE^cn,
â",
â#,
`003C^U `&lt;^smb,
`003E^U `&gt;^smb,
â—
The query percent-encode set is the C0 control percent-encode set and U+0020 SPACE, U+0022 ("), U+0023 (#), U+003C (&lt;), and U+003E (&gt;).
</p>

<p class="note">æ³¨è¨˜ï¼š
`~query~percent-ç¬¦å·åŒ–-é›†åˆ$ã¯ã€
â` ã‚’å«ã¾ãªã„ã®ã§ï¼Œ`ç´ ç‰‡~percent-ç¬¦å·åŒ–-é›†åˆ$ã‚’å«ã‚€ã‚ˆã†ã«å®šç¾©ã—å¾—ãªã„ã€‚
â—
The query percent-encode set cannot be defined in terms of the fragment percent-encode set due to the omission of U+0060 (`).
</p>
	</li>
	<li>
`ç‰¹åˆ¥~query~percent-ç¬¦å·åŒ–-é›†åˆ@
ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹~cpãŒæˆã™é›†åˆã§ã‚ã‚‹
â‡’ï¼ƒ
`~query~percent-ç¬¦å·åŒ–-é›†åˆ$,
â'
â—
The special-query percent-encode set is the query percent-encode set and U+0027 (').
</li>
	<li>
`~path~percent-ç¬¦å·åŒ–-é›†åˆ@
ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹~cpãŒæˆã™é›†åˆã§ã‚ã‚‹
â‡’ï¼ƒ
`~query~percent-ç¬¦å·åŒ–-é›†åˆ$,
â?,
â^,
â`,
â{,
â}
â—
The path percent-encode set is the query percent-encode set and U+003F (?), U+005E (^), U+0060 (`), U+007B ({), and U+007D (}).
</li>
	<li>
`~userinfo~percent-ç¬¦å·åŒ–-é›†åˆ@
ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹~cpãŒæˆã™é›†åˆã§ã‚ã‚‹
â‡’ï¼ƒ
`~path~percent-ç¬¦å·åŒ–-é›†åˆ$,
â/,
â:,
â;,
â=,
â@,
â[,
â\,
â],ã€ï¼U+005B ([) to U+005D (])ã€‘
â|
â—
The userinfo percent-encode set is the path percent-encode set and U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([) to U+005D (]), inclusive, and U+007C (|).
</li>
	<li>
<p>
`æˆåˆ†~percent-ç¬¦å·åŒ–-é›†åˆ@
ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹~cpãŒæˆã™é›†åˆã§ã‚ã‚‹
â‡’ï¼ƒ
`~userinfo~percent-ç¬¦å·åŒ–-é›†åˆ$
â$,ã€ï¼U+0024 ($) to U+0026 (&amp;)ã€‘
â%,
`0026^U `&amp;^smb,
â+,
â,
â—
The component percent-encode set is the userinfo percent-encode set and U+0024 ($) to U+0026 (&amp;), inclusive, U+002B (+), and U+002C (,).
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
`HTML^cite ã«ãŠã„ã¦ `registerProtocolHandler()$m ç”¨ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
ã¾ãŸï¼Œä»–ã®æ¨™æº–ã‚‚ã€
å¾Œã§ï¼»
`~URL$ã®ï¼»
`~path$urlï¼`~query$urlï¼`ç´ ç‰‡$url
ï¼½å†… ï¼
`ä¸é€æ˜ãª~host$å†…
ï¼½ã«åŸ‹è¾¼ã‚ã‚‹ã‚ˆã†ï¼Œ~dataã‚’~percent-ç¬¦å·åŒ–ã™ã‚‹ã¨ãã«åˆ©ç”¨ã§ãã‚‹ã€‚
`æ–‡å­—åˆ—ã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹$ã¨ãã« ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã¨ã€
~JSã® `encodeURIComponent()$m [sic]â€  ã«ä¸€è‡´ã™ã‚‹çµæœãŒå¾—ã‚‰ã‚Œã‚‹ã€‚
`HTML$r
`ECMA-262$r
ã€â€  â€œ "URI" ã¯èª¤å­—ã§ã¯ãªã„â€ ã€‘
â—
This is used by HTML for registerProtocolHandler(), and could also be used by other standards to percent-encode data that can then be embedded in a URLâ€™s path, query, or fragment; or in an opaque host. Using it with UTF-8 percent-encode gives identical results to JavaScriptâ€™s encodeURIComponent() [sic]. [HTML] [ECMA-262]
</p>
	</li>
	<li>
<p>
`~form_urlencoded~percent-ç¬¦å·åŒ–-é›†åˆ@
ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹~cpãŒæˆã™é›†åˆã§ã‚ã‚‹
â‡’ï¼ƒ
`æˆåˆ†~percent-ç¬¦å·åŒ–-é›†åˆ$,
â!,
â',ã€ï¼U+0027 (') to U+0029 RIGHT PARENTHESISã€‘
â(,
â),
â~
â—
The application/x-www-form-urlencoded percent-encode set is the component percent-encode set and U+0021 (!), U+0027 (') to U+0029 RIGHT PARENTHESIS, inclusive, and U+007E (~).
</p>

<p class="note">æ³¨è¨˜ï¼š
`~form_urlencoded~percent-ç¬¦å·åŒ–-é›†åˆ$ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ä»¥å¤–ã® ã™ã¹ã¦ã®~cpã‚’åŒ…å«ã™ã‚‹
â‡’ï¼ƒ
`~ASCIIè‹±æ•°å­—$,
â*,
â-,
â.,
â_
â—
The application/x-www-form-urlencoded percent-encode set contains all code points, except the ASCII alphanumeric, U+002A (*), U+002D (-), U+002E (.), and U+005F (_).
</p>
	</li>
</ul>

<div class="algo">
<p>
`æ–‡å­—åˆ—ã‚’ç¬¦å·åŒ–ã—ã¦ã‹ã‚‰~percent-ç¬¦å·åŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `ç¬¦å·åŒ–æ³•$ %ç¬¦å·åŒ–æ³•, `~scalarå€¤~æ–‡å­—åˆ—$ %å…¥åŠ›, ~cpãŸã¡ãŒæˆã™é›†åˆ %~percent-ç¬¦å·åŒ–-é›†åˆ, çœŸå½å€¤ %spaceAsPlus ï¼ˆçœç•¥æ™‚ã¯ ~F ï¼‰ )
ã«å¯¾ã—ï¼š
â—
To percent-encode after encoding, given an encoding encoding, scalar value string input, a percentEncodeSet, and an optional boolean spaceAsPlus (default false):
</p>
<ol>
	<li>
%ç¬¦å·åŒ–å™¨ ~LET `ç¬¦å·åŒ–å™¨ã‚’å–å¾—ã™ã‚‹$( %ç¬¦å·åŒ–æ³• )
â—
Let encoder be the result of getting an encoder from encoding.
</li>
	<li>
%å…¥åŠ›~queue ~LET %å…¥åŠ› ã‚’`å…¥å‡ºåŠ›~queue$ã«å¤‰æ›ã—ãŸçµæœã€ï¼ï¼Šã€‘
â—
Let inputQueue be input converted to an I/O queue.
</li>
	<li>
%å‡ºåŠ› ~LET ç©º~æ–‡å­—åˆ—
â—
Let output be the empty string.
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
Let potentialError be 0.
â—
This needs to be a non-null value to initiate the subsequent while loop.
â—
While potentialError is non-null:
â—
â†“â†“</p>
		<ol>
			<li>
%ç¬¦å·åŒ–-å‡ºåŠ› ~LET ç©ºãª`å…¥å‡ºåŠ›~queue$
â—
Let encodeOutput be an empty I/O queue.
</li>
			<li>
%~errorã«ãªã‚Šå¾—ã‚‹ ~LET `ç¬¦å·åŒ–ã™ã‚‹ã‹å¤±æ•—ã™ã‚‹$( %å…¥åŠ›~queue, %ç¬¦å·åŒ–å™¨, %ç¬¦å·åŒ–-å‡ºåŠ› )
â—
Set potentialError to the result of running encode or fail with inputQueue, encoder, and encodeOutput.
</li>
			<li>
<p>
ï¼»
%ç¬¦å·åŒ–-å‡ºåŠ› ã‚’~byteåˆ—ã«å¤‰æ›ã—ãŸçµæœã€ï¼ï¼Šã€‘
ï¼½ã‚’æˆã™
~EACH( %~byte )
ã«å¯¾ã—ï¼š
â—
For each byte of encodeOutput converted to a byte sequence:
</p>
				<ol>
					<li>
~IFï¼»
%spaceAsPlus ~EQ ~T
ï¼½~ANDï¼»
%~byte ~EQ  0x20 (SP)
ï¼½
â‡’ï¼ƒ
%å‡ºåŠ› ~APPEND â+ï¼›
~CONTINUE
â—
If spaceAsPlus is true and byte is 0x20 (SP), then append U+002B (+) to output and continue.
</li>
					<li>
%åŒå‹ãª~cp ~LET æ¬¡ã‚’æº€ãŸã™`~cp$
â‡’
ãã®`å€¤$cp ~EQ %~byte ã®`å€¤$byte
â—
Let isomorph be a code point whose value is byteâ€™s value.
</li>
					<li>
~Assertï¼š
%~percent-ç¬¦å·åŒ–-é›†åˆ ã¯`~ASCII~cp$ã§ãªã„ã™ã¹ã¦ã®~cpã‚’å«ã‚€ã€‚
â—
Assert: percentEncodeSet includes all non-ASCII code points.
</li>
					<li>
~IFï¼»
%åŒå‹ãª~cp ~NIN %~percent-ç¬¦å·åŒ–-é›†åˆ
ï¼½
â‡’
%å‡ºåŠ› ~APPEND %åŒå‹ãª~cp
â—
If isomorph is not in percentEncodeSet, then append isomorph to output.
</li>
					<li>
~ELSE
â‡’
%å‡ºåŠ› ~APPEND `~byteã‚’æ–‡å­—åˆ—ã«~percent-ç¬¦å·åŒ–ã™ã‚‹$( %~byte )
â—
Otherwise, percent-encode byte and append the result to output.
</li>
				</ol>
			</li>
			<li>
<p>
~IFï¼»
%~errorã«ãªã‚Šå¾—ã‚‹ ~NEQ ~NULL
ï¼½
â‡’
%å‡ºåŠ› ~APPEND `%26%23^l
~APPEND `æ•´æ•°ã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %~errorã«ãªã‚Šå¾—ã‚‹ )ã€ï¼shortest sequence of ASCII digits...ã€‘
~APPEND `%3B^l
â—
If potentialError is non-null, then append "%26%23", followed by the shortest sequence of ASCII digits representing potentialError in base ten, followed by "%3B", to output.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
%ç¬¦å·åŒ–æ³• ãŒ`~UTF-8$ã§ãªã„ã¨ãèµ·ã“ã‚Šå¾—ã‚‹ã€‚
â—
This can happen when encoding is not UTF-8.
</p>
			</li>
			<li>
~ELSE
â‡’
~BREAK
â—
â†‘â†‘</li>
		</ol>
	</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
å¼•æ•° %~percent-ç¬¦å·åŒ–-é›†åˆ ç”¨ã«ã‚¢ãƒªãªå€¤ã®ã†ã¡ï¼Œ
~percent-ç¬¦å·åŒ–ã™ã‚‹å¯¾è±¡ã« â% ã‚’å«ã‚€ã‚‚ã®ã¯ã€ï¼»
`æˆåˆ†~percent-ç¬¦å·åŒ–-é›†åˆ$,
`~form_urlencoded~percent-ç¬¦å·åŒ–-é›†åˆ$
ï¼½ã«é™ã‚‰ã‚Œã‚‹
â€” ã—ãŸãŒã£ã¦ï¼Œ â€œå¾€å¾©-å¯èƒ½ãª~dataâ€ ã‚’ä¸ãˆã‚‹ã€‚
ä»–ã®å€¤
â€” `~URLæ§‹æ–‡è§£æå™¨$ã«åˆ©ç”¨ã•ã‚Œå¾—ã‚‹ã‚‚ã® â€”
ã¯ã€
â% ã«ã¯è§¦ã‚Œãªã„ã¾ã¾æ®‹ã™
â€” ãã®ã‚ˆã†ãªã‚ã‘ã§ã€
é©æ­£ã«è¡¨ç¾ã™ã‚‹ãŸã‚ã«ã¯ï¼Œã¾ãš`~cpã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹$å¿…è¦ãŒã‚ã‚‹ã€‚
â—
Of the possible values for the percentEncodeSet argument only two end up encoding U+0025 (%) and thus give â€œroundtripable dataâ€: component percent-encode set and application/x-www-form-urlencoded percent-encode set. The other values for the percentEncodeSet argument â€” which happen to be used by the URL parser â€” leave U+0025 (%) untouched and as such it needs to be percent-encoded first in order to be properly represented.
</p>
</div>

<div class="algo">
<p>
`~cpã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~scalarå€¤$ %~scalarå€¤, ~cpãŸã¡ãŒæˆã™é›†åˆ %~percent-ç¬¦å·åŒ–-é›†åˆ )
ã«å¯¾ã—
â‡’
~RET `æ–‡å­—åˆ—ã‚’ç¬¦å·åŒ–ã—ã¦ã‹ã‚‰~percent-ç¬¦å·åŒ–ã™ã‚‹$( `~UTF-8$, %~scalarå€¤ 1 å€‹ã‹ã‚‰ãªã‚‹`æ–‡å­—åˆ—$, %~percent-ç¬¦å·åŒ–-é›†åˆ )
â—
To UTF-8 percent-encode a scalar value scalarValue using a percentEncodeSet, return the result of running percent-encode after encoding with UTF-8, scalarValue as a string, and percentEncodeSet.
</p>
</div>

<div class="algo">
<p>
`æ–‡å­—åˆ—ã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~scalarå€¤~æ–‡å­—åˆ—$ %å…¥åŠ›, ~cpãŸã¡ãŒæˆã™é›†åˆ %~percent-ç¬¦å·åŒ–-é›†åˆ )
ã«å¯¾ã—
â‡’
~RET `æ–‡å­—åˆ—ã‚’ç¬¦å·åŒ–ã—ã¦ã‹ã‚‰~percent-ç¬¦å·åŒ–ã™ã‚‹$( `~UTF-8$, %å…¥åŠ›, %~percent-ç¬¦å·åŒ–-é›†åˆ )
â—
To UTF-8 percent-encode a scalar value string input using a percentEncodeSet, return the result of running percent-encode after encoding with UTF-8, input, and percentEncodeSet.
</p>
</div>

<hr>

<div class="example">
<p>
ä¸Šã§å®šç¾©ã—ãŸå„ æ¼”ç®—ã‚’ä¾‹ã«ã‚ˆã‚Šè¦ç´„ã™ã‚‹ï¼š
â—
Here is a summary, by way of example, of the operations defined above:
</p>

<div>
<table class="grid-table" id="_ex-percent-enc-dec"><thead>
<tr><th>æ¼”ç®—
<th>å…¥åŠ›~ä¾‹
<th>å‡ºåŠ›~ä¾‹
<tbody>

<tr><td rowspan="2">`~byteã‚’æ–‡å­—åˆ—ã«~percent-ç¬¦å·åŒ–ã™ã‚‹$( %å…¥åŠ› )
<td>`23^X
<td>`%23^l

<tr>
<td>`7F^X
<td>`%7F^l

<tr><td>`~byteåˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹$( %å…¥åŠ› )
<td>`%25%s%1G^bl
<td>`%%s%1G^bl

<tr><td>`æ–‡å­—åˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹$( %å…¥åŠ› )
<td>`â€½%25%2E^l
<td>`E2^X `80^X `BD^X `25^X `2E^X

<tr><td rowspan="3">
`æ–‡å­—åˆ—ã‚’ç¬¦å·åŒ–ã—ã¦ã‹ã‚‰~percent-ç¬¦å·åŒ–ã™ã‚‹$( `~Shift_JIS$, %å…¥åŠ›, `~userinfo~percent-ç¬¦å·åŒ–-é›†åˆ$ )
<td>` ^l
<td>`%20^l

<tr>
<td>`â‰¡^l
<td>`%81%DF^l

<tr>
<td>`â€½^l
<td>`%26%238253%3B^l

<tr><td>`æ–‡å­—åˆ—ã‚’ç¬¦å·åŒ–ã—ã¦ã‹ã‚‰~percent-ç¬¦å·åŒ–ã™ã‚‹$( `~ISO-2022-JP$, %å…¥åŠ›, `~userinfo~percent-ç¬¦å·åŒ–-é›†åˆ$ )
<td>`Â¥^l
<td>`%1B(J\%1B(B^l

<tr><td>`æ–‡å­—åˆ—ã‚’ç¬¦å·åŒ–ã—ã¦ã‹ã‚‰~percent-ç¬¦å·åŒ–ã™ã‚‹$( `~Shift_JIS$, %å…¥åŠ›, `~userinfo~percent-ç¬¦å·åŒ–-é›†åˆ$, ~T )
<td>`1+1 â‰¡ 2%20â€½^l
<td>`1+1+%81%DF+2%20%26%238253%3B^l

<tr><td rowspan="2">`~cpã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹$( %å…¥åŠ›, `~userinfo~percent-ç¬¦å·åŒ–-é›†åˆ$ )
<td>ââ‰¡
<td>`%E2%89%A1^l

<tr>
<td>ââ€½
<td>`%E2%80%BD^l

<tr><td>`æ–‡å­—åˆ—ã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹$( %å…¥åŠ›, `~userinfo~percent-ç¬¦å·åŒ–-é›†åˆ$ )
<td>`Say whatâ€½^l
<td>`Say%20what%E2%80%BD^l
</table>

â—
Operationï½œInputï½œOutput

Percent-encode inputï½œ0x23ï½œ"%23"
ï½œ0x7Fï½œ"%7F"
Percent-decode inputï½œ`%25%s%1G`ï½œ`%%s%1G`
Percent-decode inputï½œ"â€½%25%2E"ï½œ0xE2 0x80 0xBD 0x25 0x2E
Percent-encode after encoding with Shift_JIS, input, and the userinfo percent-encode setï½œ" "ï½œ"%20"
ï½œ"â‰¡"ï½œ"%81%DF"
ï½œ"â€½"ï½œ"%26%238253%3B"
Percent-encode after encoding with ISO-2022-JP, input, and the userinfo percent-encode setï½œ"Â¥"ï½œ"%1B(J\%1B(B"
Percent-encode after encoding with Shift_JIS, input, the userinfo percent-encode set, and trueï½œ"1+1 â‰¡ 2%20â€½"ï½œ"1+1+%81%DF+2%20%26%238253%3B"
UTF-8 percent-encode input using the userinfo percent-encode setï½œU+2261 (â‰¡)ï½œ"%E2%89%A1"
U+203D (â€½)ï½œ"%E2%80%BD"
UTF-8 percent-encode input using the userinfo percent-encode setï½œ"Say whatâ€½"ï½œ"Say%20what%E2%80%BD"
</div>
</div>

		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security considerations">2. ~securityã®è€ƒæ…®ç‚¹</h2>

<p>
`~URL$ã®~securityã¯ã€
ãã®ç’°å¢ƒã®å½¹å‹™ã§ã‚ã‚‹ã€‚
`~URL$ã‚’ï¼»
å‘¨ã‚Šã«å‘ã‘ã¦å…·ç¾åŒ–ã™ã‚‹ï¼æ¸¡ã™, ã‚ã‚‹ã„ã¯ å‘¨ã‚Šã®ãã‚Œã‚’è§£é‡ˆã™ã‚‹
ï¼½ã¨ãã«ã¯ã€
æ³¨æ„ã™ã‚‹ã“ã¨ã€‚
â—
The security of a URL is a function of its environment. Care is to be taken when rendering, interpreting, and passing URLs around.
</p>

<p>
æ–°ãŸãª`~URL$ã‚’ï¼»
å…·ç¾åŒ–ã™ã‚‹ï¼å‰²æŒ¯ã‚‹
ï¼½ã¨ãã¯ã€
â€œå½è£…ï¼ˆ `spoofing^en, ãªã‚Šã™ã¾ã—ï¼‰â€
ã«ã¤ã„ã¦è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
ï¼»
`~host$ï¼`~URL$
ï¼½ã«ã‚ˆã‚‹æ”»æ’ƒã¯ã€
èª°ã‹ã‚’åˆ¥ã®ãã‚Œã«æ··åŒã•ã›ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚
ä¸€ä¾‹ã¨ã—ã¦ã€
1/l/I, m/rn/rri, 0/O, Ğ°/a
ã¯ï¼Œã©ã‚Œã‚‚é…·ä¼¼ã™ã‚‹ã‚‚ã®ã«ãªã‚Šå¾—ã‚‹â€ ã€‚
`202A^U `LEFT-TO-RIGHT EMBEDDING^cn
ç­‰ã€…ã®ã‚ˆã†ãªï¼Œã‚ˆã‚Š~~å•é¡Œã«ãªã‚‹ä¸å¯è¦–ãª~cpã™ã‚‰ã‚ã‚‹â€ â€ ã€‚
`UTR36$r
â—
When rendering and allocating new URLs "spoofing" needs to be considered. An attack whereby one host or URL can be confused for another. For instance, consider how 1/l/I, m/rn/rri, 0/O, and Ğ°/a can all appear eerily similar. Or worse, consider how U+202A LEFT-TO-RIGHT EMBEDDING and similar code points are invisible. [UTR36]
</p>

<p class="trans-note">ã€
â€œå…·ç¾åŒ–ï¼ˆ `rendering^en ï¼‰â€ ã«ã¯ã€
~~æç”»ã«é™ã‚‰ãšï¼Œ~~éŸ³å£°åŒ–ãªã©ã‚‚å«ã¾ã‚Œã‚‹ã€‚
ã€‘ã€â€ 
ä¸€èˆ¬ã«ã¯è¦‹ã‹ã‘ï¼ˆã‚ã‚‹ã„ã¯ç™ºéŸ³ï¼‰ãŒç•°ãªã‚‹æ–‡å­—ã§ã‚‚ã€
ç’°å¢ƒã«ã¦å¯ç”¨ãª~fontï¼ˆã‚ã‚‹ã„ã¯~voiceï¼‰ã«ä¾å­˜ã—ã¦é…·ä¼¼ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
é è‹±èªè©±è€…ã«ã¨ã£ã¦ã¯ã€
è¦‹ã‹ã‘ã¯ç•°ãªã£ã¦ã„ã¦ã‚‚ä¼¼ãŸç™ºéŸ³ã¨ã—ã¦è¨˜æ†¶ã—ã¦ã„ã‚‹ãŸã‚ï¼Œ
éŒ¯è¦šã—æ˜“ã„ã‚‚ã®ã‚‚ã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„
ï¼ˆä¾‹ï¼š `correction^en ã¨ `collection^en ï¼‰ã€‚
ã€‘ã€â€ â€ 
ç©ºé–“ã™ã‚‰å ã‚ãªã„ã“ã¨ã«åŠ ãˆã€
~UnicodeåŒæ–¹å‘-~algoã‚‚é©ç”¨ã™ã‚‹ä¸‹ã§æç”»ã•ã‚ŒãŸå ´åˆï¼Œ
å‰å¾Œã®å­—ã®ä¸¦ã³é †ã¾ã§ã‚‚å¤‰ã‚ã‚‹ã€‚
ã€‘ã€
å‚è€ƒï¼š `IDNFAQ$r
ã€‘</p>

<p>
ä¸»ä½“ %A ã‹ã‚‰ä¸»ä½“ %B ã¸`~URL$ãŒæ¸¡ã•ã‚Œã‚‹ã¨ãã¯ã€
ä¸¡~ä¸»ä½“ã¨ã‚‚ï¼Œä½•ãŒèµ·ãã‚‹ã‹æ³¨æ„æ·±ãè€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
%A ã¯ã€
æ„ã«åã—ã¦~dataã‚’æ¼æ´©ã™ã‚‹ã¯ã‚ã«ãªã‚Šå¾—ã‚‹ã€‚
%B ã¯ã€
è‡ªèº«ãŒäºˆæœŸã—ã¦ã„ãªã„å…¥åŠ›ã‚’å—å–ã£ã¦åˆ©ç”¨è€…ã«å®³ã™ã‚‹å‹•ä½œã‚’ã¨ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚
ç‰¹ã«ã€
%B ã¯ï¼Œæ±ºã—ã¦ %A ã‚’ä¿¡ç”¨ã™ã‚‹ãƒ™ã‚­ã§ãªã„
â€” æ¸¡ã•ã‚Œã‚‹`~URL$ã¯ã€
å¸¸ã«ä¿¡ç”¨ã§ãã‚‹~sourceã‹ã‚‰æ¥ã¦ã„ã‚‹ã¨ã¯é™ã‚‰ãªã„ã®ã§ã€‚
â—
When passing a URL from party A to B, both need to carefully consider what is happening. A might end up leaking data it does not want to leak. B might receive input it did not expect and take an action that harms the user. In particular, B should never trust A, as at some point URLs from A can come from untrusted sources.
</p>

	</section>
	<section id="hosts-(domains-and-ip-addresses)">
<h2 title="Hosts (domains and IP addresses)">3. ~hostï¼ˆ~domainã¨~IP~addressï¼‰</h2>

<p>
é«˜~levelã‹ã‚‰ã¯ã€ï¼»
`~host$, `å¦¥å½“ãª~host$sT, `~hostæ§‹æ–‡è§£æå™¨$, `~hostç›´åˆ—åŒ–å™¨$
ï¼½ã¯ï¼Œæ¬¡ã®ã‚ˆã†ã«é–¢ä¿‚ã™ã‚‹ï¼š
â—
At a high level, a host, valid host string, host parser, and host serializer relate as follows:
</p>

<ul>
	<li>
`~hostæ§‹æ–‡è§£æå™¨$ã¯ã€
ä»»æ„ãª`~scalarå€¤~æ–‡å­—åˆ—$ã«å¯¾ã—ï¼»
`å¤±æ•—^i, ã¾ãŸã¯ `~host$
ï¼½ã‚’è¿”ã™ã€‚
â—
The host parser takes an arbitrary scalar value string and returns either failure or a host.
</li>
	<li>
`~host$ã¯ã€
~memoryå†…ã®è¡¨ç¾ã¨æ‰ãˆã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
â—
A host can be seen as the in-memory representation.
</li>
	<li>
`å¦¥å½“ãª~host$sTã¯ã€
`~hostæ§‹æ–‡è§£æå™¨$ã«ä¸ãˆãŸã¨ãã«ï¼Œ`æ¤œè¨¼~error$ã‚„ `å¤±æ•—^i ã‚’èª˜ç™ºã—ãªã„
â€” ã™ãªã‚ã¡ã€ï¼»
é©åˆã™ã‚‹ï¼å¦¥å½“ã§ã‚ã‚‹
ï¼½ã¨è¦‹ãªã•ã‚Œã‚‹ â€”
ã‚ˆã†ãªå…¥åŠ›ã‚’å®šç¾©ã™ã‚‹ã€‚
â—
A valid host string defines what input would not trigger a validation error or failure when given to the host parser. I.e., input that would be considered conforming or valid.
</li>
	<li>
`~hostç›´åˆ—åŒ–å™¨$ã¯ã€
~~å…¥åŠ›ã®`~host$ã«å¯¾ã—ï¼Œ`~ASCIIæ–‡å­—åˆ—$ã‚’è¿”ã™ã€‚
ï¼ˆãã®æ–‡å­—åˆ—ã‚’ã•ã‚‰ã«`~hostæ§‹æ–‡è§£æå™¨$ã«ã‹ã‘ãŸçµæœã¯ã€
~~å…ƒã®`~host$ã¨`åŒç­‰ãª~host$ã«ãªã‚‹ã€‚ï¼‰
â—
The host serializer takes a host and returns an ASCII string. (If that string is then parsed, the result will equal the host that was serialized.)
</li>
</ul>

<div class="example">
<p>
ï¼»
`~hostæ§‹æ–‡è§£æå™¨$, `~hostç›´åˆ—åŒ–å™¨$
ï¼½ã‚’é †ã«é©ç”¨ã—ã¦å¾€å¾©ã—ãŸçµæœã¯ã€
`~hostæ§‹æ–‡è§£æå™¨$ã®å¼•æ•° %ä¸é€æ˜ã‹ ã«ä¾å­˜ã—ã¦ï¼Œæ¬¡ã®ã‚ˆã†ã«ãªã‚‹ï¼š
â—
A parse-serialize roundtrip gives the following results, depending on the isOpaque argument to the host parser:
</p>

<div>
<table class="grid-table" id="_ex-roundtrip"><thead>
<tr><th>å…¥åŠ›
<th>å‡ºåŠ›ï¼ˆ %ä¸é€æ˜ã‹ ~EQ ~F ï¼‰
<th>å‡ºåŠ›ï¼ˆ %ä¸é€æ˜ã‹ ~EQ ~T ï¼‰
<tbody>

<tr><td>`EXAMPLE.COM^c
<td>`example.com^c ï¼ˆ`~domain$ï¼‰
<td>`EXAMPLE.COM^c ï¼ˆ`ä¸é€æ˜ãª~host$ï¼‰

<tr><td>`example%2Ecom^c
<td>`example.com^c ï¼ˆ`~domain$ï¼‰
<td>`example%2Ecom^c ï¼ˆ`ä¸é€æ˜ãª~host$ï¼‰

<tr><td>`faÃŸ.example^c
<td>`xn--fa-hia.example^c ï¼ˆ`~domain$ï¼‰
<td>`fa%C3%9F.example^c ï¼ˆ`ä¸é€æ˜ãª~host$ï¼‰

<tr><td>`0^c
<td>`0.0.0.0^c ï¼ˆ`~IPv4~address$ï¼‰
<td>`0^c ï¼ˆ`ä¸é€æ˜ãª~host$ï¼‰

<tr><td>`%30^c
<td>`0.0.0.0^c ï¼ˆ`~IPv4~address$ï¼‰
<td>`%30^c ï¼ˆ`ä¸é€æ˜ãª~host$ï¼‰

<tr><td>`0x^c
<td>`0.0.0.0^c ï¼ˆ`~IPv4~address$ï¼‰
<td>`0x^c ï¼ˆ`ä¸é€æ˜ãª~host$ï¼‰

<tr><td>`0xffffffff^c
<td>`255.255.255.255^c ï¼ˆ`~IPv4~address$ï¼‰
<td>`0xffffffff^c ï¼ˆ`ä¸é€æ˜ãª~host$ï¼‰

<tr><td>`[0:0::1]^c
<td>`[::1]^c ï¼ˆ`~IPv6~address$ï¼‰
<td>`[::1]^c ï¼ˆ`~IPv6~address$ï¼‰

<tr><td>`[0:0::1%5D^c
<td>`å¤±æ•—^i
<td>`å¤±æ•—^i

<tr><td>`[0:0::%31]^c
<td>`å¤±æ•—^i
<td>`å¤±æ•—^i

<tr><td>`09^c
<td>`å¤±æ•—^i
<td>`09^c ï¼ˆ`ä¸é€æ˜ãª~host$ï¼‰

<tr><td>`example.255^c
<td>`å¤±æ•—^i
<td>`example.255^c ï¼ˆ`ä¸é€æ˜ãª~host$ï¼‰

<tr><td><code>example^example</code>
<td>`å¤±æ•—^i
<td>`å¤±æ•—^i
</table>

â—
Inputï½œOutput (isOpaque = false)ï½œOutput (isOpaque = true)
EXAMPLE.COMï½œexample.com (domain)ï½œEXAMPLE.COM (opaque host)
example%2Ecomï½œï½œexample%2Ecom (opaque host)
faÃŸ.exampleï½œxn--fa-hia.example (domain)ï½œfa%C3%9F.example (opaque host)
0ï½œ0.0.0.0 (IPv4)ï½œ0 (opaque host)
%30ï½œï½œ%30 (opaque host)
0xï½œï½œ0x (opaque host)
0xffffffffï½œ255.255.255.255 (IPv4)ï½œ0xffffffff (opaque host)
[0:0::1]ï½œ[::1] (IPv6)ï½œ
[0:0::1%5Dï½œFailureï½œ
[0:0::%31]ï½œï½œ
09ï½œFailureï½œ09 (opaque host)
example.255ï½œï½œexample.255 (opaque host)
example^exampleï½œï½œFailure
</div>
</div>

		<section id="host-representation">
<h3 title="Host representation">3.1. ~hostè¡¨ç¾</h3>

<p>
`~host@
ã¯ã€ï¼»
`~domain$,
`~IP~address$,
`ä¸é€æ˜ãª~host$,
`ç©º~host$
ï¼½ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹ã€‚
`~host$ã¯ï¼Œæ¦‚ã—ã¦~network~addressã¨ã—ã¦~serveã™ã‚‹ãŒã€
~network~addressãŒå¿…è¦yã§ãªã„æ‰€ã§ã¯ï¼Œ
`~URL$å†…ã§ ä¸é€æ˜ãªè­˜åˆ¥å­ã¨ã—ã¦åˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚‹ã€‚
â—
A host is a domain, an IP address, an opaque host, or an empty host. Typically a host serves as a network address, but it is sometimes used as opaque identifier in URLs where a network address is not necessary.
</p>

<p class="example">
`~host$urlãŒ`ä¸é€æ˜ãª~host$ã§ã‚ã‚‹`~URL$ã®å…¸å‹çš„ãªä¾‹
â‡’
`git://github.com/whatwg/url.git^c
â—
A typical URL whose host is an opaque host is git://github.com/whatwg/url.git.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä¸‹ã®å„ æ®µè½~å†…ã§å‚ç…§ã•ã‚Œã¦ã„ã‚‹~RFCã¯ã€
å‚è€ƒç›®çš„ã«é™ã‚‰ã‚Œã‚‹ã€‚
ãã‚Œã‚‰ã¯ã€
`~host$ã®ï¼»
æ›¸å‡ºæ³•, æ§‹æ–‡è§£æ-æ³•, ç›´åˆ—åŒ–
ï¼½ã«ã¯ä½•ã‚‰æ³¢åŠã—ãªã„
â€” ä»¥ä¸‹ã®ç¯€ã«ã¦ä»–ãŒè¨€æ˜ã•ã‚Œãªã„é™ã‚Šã€‚
â—
The RFCs referenced in the paragraphs below are for informative purposes only. They have no influence on host writing, parsing, and serialization. Unless stated otherwise in the sections that follow.
</p>

<p>
`~domain@
ã¨ã¯ã€
~networkã®ä¸­ã®~realmã‚’è­˜åˆ¥ã™ã‚‹ç©ºã§ãªã„`~ASCIIæ–‡å­—åˆ—$ã§ã‚ã‚‹ã€‚
`RFC1034$r
â—
A domain is a non-empty ASCII string that identifies a realm within a network. [RFC1034]
</p>

<div class="algo">
<p>
`~domain$ %~domain ã®
`~domain~labelç¾¤@
ã¯ã€
æ¬¡ã®çµæœã‚’è¿”ã™
â‡’
`åŒºåˆ‡å­ã§å³å¯†ã«åˆ†å‰²ã™ã‚‹$( %~domain, â. )
â—
The domain labels of a domain domain are the result of strictly splitting domain on U+002E (.).
</p>
</div>

<p class="note">
2 ã¤ã®~domain
`example.com^l ã¨ `example.com.^l
ã¯ã€
ç­‰ä¾¡ã§ã¯ãªãï¼Œæ¦‚ã—ã¦åˆ¥ç‰©ã«æ‰±ã‚ã‚Œã‚‹ã€‚
â—
The example.com and example.com. domains are not equivalent and typically treated as distinct.
</p>

<p>
`~IP~address@
ã¯ã€ï¼»
`~IPv4~address$ï¼`~IPv6~address$
ï¼½ã§ã‚ã‚‹ã€‚
â—
An IP address is an IPv4 address or an IPv6 address.
</p>

<p>
`~IPv4~address@
ã¯ã€
~network~addressã‚’è­˜åˆ¥ã™ã‚‹ `32 ~bitãªç„¡ç¬¦å·~æ•´æ•°$ã§ã‚ã‚‹ã€‚
`RFC791$r
â—
An IPv4 address is a 32-bit unsigned integer that identifies a network address. [RFC791]
</p>

<p>
`~IPv6~address@
ã¯ã€
~network~addressã‚’è­˜åˆ¥ã™ã‚‹ `128 ~bitãªç„¡ç¬¦å·~æ•´æ•°$ã§ã‚ã‚‹ã€‚
ã“ã®æ•´æ•°ã¯ã€
`~IPv6~address$ã®
`~pieceç¾¤@
ã¨ã‚‚ç§°ã•ã‚Œã‚‹ï¼Œï¼»
8 å€‹ã® `16 ~bitãªç„¡ç¬¦å·~æ•´æ•°$
ï¼½ãŒæˆã™`~list$ã§æ§‹æˆã•ã‚Œã‚‹ã€‚
`RFC4291$r
â—
An IPv6 address is a 128-bit unsigned integer that identifies a network address. This integer is composed of a list of 8 16-bit unsigned integers, also known as an IPv6 addressâ€™s pieces. [RFC4291]
</p>

<p class="note">æ³¨è¨˜ï¼š
<code>&lt;zone_id&gt;</code> ã®~supportã¯ã€
`æ„å›³çš„ã«é™¤ã‹ã‚Œã¦ã„ã‚‹ï¼ https://www.w3.org/Bugs/Public/show_bug.cgi?id=27234#c2$ã€‚
â—
Support for &lt;zone_id&gt; is intentionally omitted.
</p>

<p>
`ä¸é€æ˜ãª~host@
ã¯ã€
ç©ºã§ãªã„`~ASCIIæ–‡å­—åˆ—$ã§ã‚ã‚Šï¼Œæ›´ãªã‚‹å‡¦ç†ã«åˆ©ç”¨ã•ã‚Œå¾—ã‚‹ã€‚
â—
An opaque host is a non-empty ASCII string that can be used for further processing.
</p>

<p>
`ç©º~host@
ã¯ã€
ç©º~æ–‡å­—åˆ—ã§ã‚ã‚‹ã€‚
â—
An empty host is the empty string.
</p>

		</section>
		<section id="host-miscellaneous">
<h3 title="Host miscellaneous">3.2. ~hostã®ãã®ä»–è«¸ã€…</h3>

<p>
æ¬¡ã«æŒ™ã’ã‚‹~cpã¯
`ç¦æ­¢~host~cp@
ã¨ã•ã‚Œã‚‹
â‡’ï¼ƒ
`0000^U `NULL^cn,
`0009^U `TAB^cn,
`000A^U `LF^cn,
`000D^U `CR^cn,
`0020^U `SPACE^cn,
â#,
â/,
â:,
`003C^U `&lt;^smb,
`003E^U `&gt;^smb,
â?,
â@,
â[,
â\,
â],
â^,
â|
â—
A forbidden host code point is U+0000 NULL, U+0009 TAB, U+000A LF, U+000D CR, U+0020 SPACE, U+0023 (#), U+002F (/), U+003A (:), U+003C (&lt;), U+003E (&gt;), U+003F (?), U+0040 (@), U+005B ([), U+005C (\), U+005D (]), U+005E (^), or U+007C (|).
</p>

<p>
æ¬¡ã«æŒ™ã’ã‚‹~cpã¯
`ç¦æ­¢~domain~cp@
ã¨ã•ã‚Œã‚‹
â‡’ï¼ƒ
`ç¦æ­¢~host~cp$,
`~C0åˆ¶å¾¡æ–‡å­—$,
â%,
`007F^U `DELETE^cn
â—
A forbidden domain code point is a forbidden host code point, a C0 control, U+0025 (%), or U+007F DELETE.
</p>

<div class="algo">
<p>
æ‰€ä¸ã®
( `~host$ %~host )
ã®
`å…¬å…±~æ¥å°¾è¾@
ï¼ˆ `public suffix^en ï¼‰
å¾—ã™ã‚‹
~algoã¯ã€ï¼»
~NULL ï¼ï¼»
%~host å†…ã®ï¼»
`å…¬å…±~æ¥å°¾è¾~list^citeï¼ˆ `PublicSuffixList^en ï¼‰ `PSL$r ã«å«ã¾ã‚Œã‚‹éƒ¨ä½
ï¼½ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹`~domain$
ï¼½ï¼½ã‚’è¿”ã™ï¼š
â—
To obtain the public suffix of a host host, run these steps. They return null or a domain representing a portion of host that is included on the Public Suffix List. [PSL]
</p>
<ol>
	<li>
~IFï¼»
%~host ã¯`~domain$ã§ãªã„
ï¼½
â‡’
~RET ~NULL
â—
If host is not a domain, then return null.
</li>
	<li>
%æœ«å°¾ã®~dot ~LET ï¼»
%~host ã¯ `.^l `ã§çµ‚ç«¯ã—ã¦$ã„ã‚‹ãªã‚‰ã° `.^l ï¼
~ELSE_ ç©º~æ–‡å­—åˆ—
ï¼½
â—
Let trailingDot be "." if host ends with "."; otherwise the empty string.
</li>
	<li>
%å…¬å…±~æ¥å°¾è¾ ~LET 
`å…¬å…±~æ¥å°¾è¾~listã®~algo$ã‚’~domainã¨ã—ã¦ %~host ã‚’ä¸ãˆã¦èµ°ã‚‰ã›ãŸçµæœã®å…¬å…±~æ¥å°¾è¾
`PSL$r
â—
Let publicSuffix be the public suffix determined by running the Public Suffix List algorithm with host as domain. [PSL]
</li>
	<li>
~Assertï¼šï¼»
%å…¬å…±~æ¥å°¾è¾ ã¯`~ASCIIæ–‡å­—åˆ—$ã§ã‚ã‚‹
ï¼½~ANDï¼»
%å…¬å…±~æ¥å°¾è¾ ã¯ `.^l `ã§çµ‚ç«¯ã—ã¦$ã„ãªã„
ï¼½
â—
Assert: publicSuffix is an ASCII string that does not end with ".".
</li>
	<li>
~RET ï¼»
%å…¬å…±~æ¥å°¾è¾, %æœ«å°¾ã®~dot
ï¼½ã‚’é †ã«é€£çµã—ãŸçµæœ
â—
Return publicSuffix and trailingDot concatenated.
</li>
</ol>
</div>

<div class="algo">
<p>
æ‰€ä¸ã®
( `~host$ %~host )
ã®
`ç™»éŒ²-å¯èƒ½ãª~domain@
ï¼ˆ `registrable domain^en ï¼‰
ã‚’å¾—ã™ã‚‹
~algoã¯ã€ï¼»
~NULL ï¼ï¼»
%~host ã®`å…¬å…±~æ¥å°¾è¾$ã¨ï¼»
ãã‚Œã«å…ˆè¡Œã—ã¦ã„ã‚‹`~domain~label$ãŒåœ¨ã‚Œã° ãã‚Œ
ï¼½ã«ã‚ˆã‚Šå½¢æˆã•ã‚Œã‚‹`~domain$
ï¼½ï¼½ã‚’è¿”ã™ï¼š
â—
To obtain the registrable domain of a host host, run these steps. They return null or a domain formed by hostâ€™s public suffix and the domain label preceding it, if any.
</p>
<ol>
	<li>
~IFï¼»
%~host ã®`å…¬å…±~æ¥å°¾è¾$ ~EQ ~NULL
ï¼½~ORï¼»
( %~host ã®`å…¬å…±~æ¥å°¾è¾$, %~host )
ã¯`åŒç­‰ãª~host$ã§ã‚ã‚‹
ï¼½
â‡’
~RET ~NULL
â—
If hostâ€™s public suffix is null or hostâ€™s public suffix equals host, then return null.
</li>
	<li>
%æœ«å°¾ã®~dot ~LET ï¼»
%~host ã¯ `.^l `ã§çµ‚ç«¯ã—ã¦$ã„ã‚‹ãªã‚‰ã° `.^l ï¼
~ELSE_ ç©º~æ–‡å­—åˆ—
ï¼½
â—
Let trailingDot be "." if host ends with "."; otherwise the empty string.
</li>
	<li>
%ç™»éŒ²-å¯èƒ½ãª~domain ~LET 
`å…¬å…±~æ¥å°¾è¾~listã®~algo$ã‚’~domainã¨ã—ã¦ %~host ã‚’ä¸ãˆã¦èµ°ã‚‰ã›ãŸçµæœã®ç™»éŒ²-å¯èƒ½ãª~domain
`PSL$r
â—
Let registrableDomain be the registrable domain determined by running the Public Suffix List algorithm with host as domain. [PSL]
</li>
	<li>
~Assertï¼šï¼»
%ç™»éŒ²-å¯èƒ½ãª~domain ã¯`~ASCIIæ–‡å­—åˆ—$ã§ã‚ã‚‹
ï¼½~ANDï¼»
%ç™»éŒ²-å¯èƒ½ãª~domain ã¯ `.^l `ã§çµ‚ç«¯ã—ã¦$ã„ãªã„
ï¼½
â—
Assert: registrableDomain is an ASCII string that does not end with ".".
</li>
	<li>
~RET ï¼»
%ç™»éŒ²-å¯èƒ½ãª~domain, %æœ«å°¾ã®~dot
ï¼½ã‚’é †ã«é€£çµã—ãŸçµæœ
â—
Return registrableDomain and trailingDot concatenated.
</li>
</ol>
</div>

<div class="example">
<table class="grid-table" id="_ex-suffix-domain"><thead>
<tr><th>
å…¥åŠ›~host
â—
Host input
<th>
å…¬å…±~æ¥å°¾è¾
â—
Public suffix
<th>ç™»éŒ²-å¯èƒ½ãª~domain
â—
Registrable domain
<tbody>

<tr><td>`com^c
<td>`com^c
<td>~NULL

<tr><td>`example.com^c
<td>`com^c
<td>`example.com^c

<tr><td>`www.example.com^c
<td>`com^c
<td>`example.com^c

<tr><td>`sub.www.example.com^c
<td>`com^c
<td>`example.com^c

<tr><td>`EXAMPLE.COM^c
<td>`com^c
<td>`example.com^c

<tr><td>`example.com.^c
<td>`com.^c
<td>`example.com.^c

<tr><td>`github.io^c
<td>`github.io^c
<td>~NULL

<tr><td>`whatwg.github.io^c
<td>`github.io^c
<td>`whatwg.github.io^c

<tr><td>`Ø¥Ø®ØªØ¨Ø§Ø±^c
<td>`xn--kgbechtv^c
<td>~NULL

<tr><td>`example.Ø¥Ø®ØªØ¨Ø§Ø±^c
<td>`xn--kgbechtv^c
<td>`example.xn--kgbechtv^c

<tr><td>`sub.example.Ø¥Ø®ØªØ¨Ø§Ø±^c
<td>`xn--kgbechtv^c
<td>`example.xn--kgbechtv^c

<tr><td>`[2001:0db8:85a3:0000:0000:8a2e:0370:7334]^c
<td>~NULL
<td>~NULL
</table>
</div>

<p class="warning" id="warning-avoid-psl">
ä»•æ§˜ã¯ã€
~securityã®è£å®šã‚’ç‚ºã™ã¨ãã«ã¯ï¼Œ`ç”Ÿæˆå…ƒ$ã®æ¦‚å¿µã‚’é¸å¥½ã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹ã€‚
ï¼»
â€œ`å…¬å…±~æ¥å°¾è¾$â€ ï¼
â€œ`ç™»éŒ²-å¯èƒ½ãª~domain$â€
ï¼½ã®è¦³å¿µã«ä¾å­˜ã™ã‚‹ã“ã¨ã§ã¯ã€
å …å›ºãª~securityå¢ƒç•Œã¯ä¾›ã›ãªã„
â€” å…¬å…±~æ¥å°¾è¾~listã¯ï¼Œ~clientã”ã¨ã«åˆ†å²ã™ã‚‹ã®ã§ã€‚
ã“ã®åŠ©è¨€ã‚’ç„¡è¦–ã™ã‚‹ä»•æ§˜ã¯ã€
ãã“ã§ç‚ºã™è£å®šã®ä¸­ã«ï¼Œ~URLã®~schemeã¯çµ„å…¥ã‚Œã‚‹ã¹ãã¨ã•ã‚Œã‚‹ã‹ã©ã†ã‹
â€” ã™ãªã‚ã¡ï¼Œï¼»
`åŒã˜~site$ï¼`~schemeç„¡ã—ã§åŒã˜~site$
ï¼½ã®æ¦‚å¿µã‚’åˆ©ç”¨ã™ã‚‹ã‹ã©ã†ã‹ â€”
ã«ã¤ã„ã¦ï¼Œæ³¨æ„æ·±ãè€ƒæ…®ã™ã‚‹ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
â—
Specifications should prefer the origin concept for security decisions. The notion of "public suffix" and "registrable domain" cannot be relied-upon to provide a hard security boundary, as the public suffix list will diverge from client to client. Specifications which ignore this advice are encouraged to carefully consider whether URLs' schemes ought to be incorporated into any decisions made, i.e. whether to use the same site or schemelessly same site concepts.
</p>

		</section>
		<section id="idna">
<h3 title="IDNA">3.3. ~IDNA</h3>

<div class="algo">
<p>
`~domainã‚’~ASCIIåŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `æ–‡å­—åˆ—$ %~domain, çœŸå½å€¤ %å³å¯†ã‹ )
ã«å¯¾ã—ï¼š
â—
The domain to ASCII algorithm, given a string domain and a boolean beStrict, runs these steps:
</p>
<ol>
	<li>
<p>
%çµæœ ~LET æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ `Unicode ToASCII$AO ã‚’èµ°ã‚‰ã›ãŸçµæœ `UTS46$r
â‡’ï¼ƒ
`domain_name^i ~SET %~domain,
`CheckHyphens^i ~SET %å³å¯†ã‹,
`CheckBidi^i ~SET ~T,
`CheckJoiners^i ~SET ~T,
`UseSTD3ASCIIRules^i ~SET %å³å¯†ã‹,
`Transitional_Processing^i ~SET ~F,
`VerifyDnsLength^i ~SET %å³å¯†ã‹,
`IgnoreInvalidPunycode^i ~SET ~F
â—
Let result be the result of running Unicode ToASCII with domain_name set to domain, CheckHyphens set to beStrict, CheckBidi set to true, CheckJoiners set to true, UseSTD3ASCIIRules set to beStrict, Transitional_Processing set to false, VerifyDnsLength set to beStrict, and IgnoreInvalidPunycode set to false. [UTS46] 
</p>

<div class="note">
<p>æ³¨è¨˜ï¼š
~ANDâ†“ æ¬¡ãŒæº€ãŸã•ã‚Œã‚‹å ´åˆã€
ã“ã®æ®µã¯ %~domain ã‚’`~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹$ã“ã¨ã¨ç­‰ä¾¡ã«ãªã‚‹ï¼š
</p>
		<ul>
			<li>
%å³å¯†ã‹ ~EQ ~F
</li>
			<li>
%~domain ã¯`~ASCIIæ–‡å­—åˆ—$ã§ã‚ã‚‹
</li>
			<li>
æ¬¡ã®çµæœ
â‡’
`åŒºåˆ‡å­ã§å³å¯†ã«åˆ†å‰²ã™ã‚‹$( %~domain, â. )
â—çµ‚
ã‚’æˆã™ ã©ã®`~item$ã‚‚ï¼Œæ¬¡ã‚’æº€ãŸã™
â‡’
ï¼»
`~ASCIIå¤§å°ç„¡è¦–$ã§ `xn--^l ã«åˆè‡´ã™ã‚‹æ–‡å­—åˆ—
ï¼½`ã‹ã‚‰é–‹å§‹ã—ã¦$ã„ãªã„
</li>
		</ul>
â—
If beStrict is false, domain is an ASCII string, and strictly splitting domain on U+002E (.) does not produce any item that starts with an ASCII case-insensitive match for "xn--", this step is equivalent to ASCII lowercasing domain.
</div>
	</li>
	<li>
~IFï¼»
%çµæœ ~EQ `å¤±æ•—^i
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `domain-to-ASCII$err )ï¼›
~RET `å¤±æ•—^i
â—
If result is a failure value, domain-to-ASCII validation error, return failure.
</li>
	<li>
<p>
~IFï¼»
%å³å¯†ã‹ ~EQ ~F
ï¼½ï¼š
â—
If beStrict is false:
</p>
		<ol>
			<li>
~IFï¼»
%çµæœ ~EQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `domain-to-ASCII$err )ï¼›
~RET `å¤±æ•—^i
â—
If result is the empty string, domain-to-ASCII validation error, return failure.
</li>
			<li>
<p>
~IFï¼»
%çµæœ å†…ã«`ç¦æ­¢~domain~cp$ãŒåœ¨ã‚‹
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `domain-invalid-code-point$err )ï¼›
~RET `å¤±æ•—^i
â—
If result contains a forbidden domain code point, domain-invalid-code-point validation error, return failure.
</p>

<p class="note">æ³¨è¨˜ï¼š
ï¼»
~webäº’æ›æ€§,
~DNSã«åŸºã¥ã‹ãªã„~systemã¨ã®äº’æ›æ€§
ï¼½ã«å› ã‚Šã€
`ç¦æ­¢~domain~cp$ã¯ï¼Œï¼»
`UseSTD3ASCIIRules^i ãŒ ~T ã‚’ã¨ã‚‹ã¨ãã«ã¯è¨±å®¹ã•ã‚Œãªã„~cpãŸã¡
ï¼½ã®ä¸‹ä½é›†åˆã‚’æˆã™ã€‚
`èª²é¡Œ #397ï¼ https://github.com/whatwg/url/issues/397$
ã‚‚è¦‹ã‚ˆã€‚
â—
Due to web compatibility and compatibility with non-DNS-based systems the forbidden domain code points are a subset of those disallowed when UseSTD3ASCIIRules is true. See also issue #397.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~Assertï¼š
ï¼»
%çµæœ ~NEQ ç©º~æ–‡å­—åˆ—
ï¼½~ANDï¼»
%çµæœ å†…ã«`ç¦æ­¢~domain~cp$ã¯ç„¡ã„
ï¼½
â—
Assert: result is not the empty string and does not contain a forbidden domain code point.
</p>

<p class="note">æ³¨è¨˜ï¼š
ï¼»
%å³å¯†ã‹ ~EQ ~T
ï¼½ã®ã¨ãã«ã¯ã€
`UTS46$r ãŒï¼Œã“ã‚ŒãŒæº€ãŸã•ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã€‚
â—
Unicode IDNA Compatibility Processing guarantees this holds when beStrict is true. [UTS46]
</p>
	</li>
	<li>
~RET %çµæœ
â—
Return result.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ–‡æ›¸ãŠã‚ˆã³~web~platformã¯ã€
IDNA2008 `RFC5890$r ã§ã¯ãªãï¼Œ
`Unicode IDNA Compatibility Processing^cite `UTS46$r
ã€ â€œ~Unicode~IDNAäº’æ›æ€§~å‡¦ç†â€ ã€‘
ã‚’~~å…¨èˆ¬çš„ã«åˆ©ç”¨ã™ã‚‹ã€‚
ä¸€ä¾‹ã¨ã—ã¦ã€
`â˜•.example^l ã¯ï¼Œ
`å¤±æ•—^i ã§ã¯ãªã `xn--53h.example^l ã«ãªã‚‹ã€‚
â—
This document and the web platform at large use Unicode IDNA Compatibility Processing and not IDNA2008. For instance, â˜•.example becomes xn--53h.example and not failure. [UTS46] [RFC5890]
</p>
</div>

<div class="algo">
<p>
`~domainã‚’~UnicodeåŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~domain$ %~domain, çœŸå½å€¤ %å³å¯†ã‹ )
ã«å¯¾ã—ï¼š
â—
The domain to Unicode algorithm, given a domain domain and a boolean beStrict, runs these steps:
</p>

<ol>
	<li>
%çµæœ ~LET æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ `Unicode ToUnicode$AO ã‚’èµ°ã‚‰ã›ãŸçµæœ `UTS46$r
â‡’ï¼ƒ
`domain_name^i ~SET %~domain,
`CheckHyphens^i ~SET %å³å¯†ã‹,
`CheckBidi^i ~SET ~T,
`CheckJoiners^i ~SET ~T,
`UseSTD3ASCIIRules^i ~SET %å³å¯†ã‹,
`Transitional_Processing^i ~SET ~F,
`IgnoreInvalidPunycode^i ~SET ~F
â—
Let result be the result of running Unicode ToUnicode with domain_name set to domain, CheckHyphens set to beStrict, CheckBidi set to true, CheckJoiners set to true, UseSTD3ASCIIRules set to beStrict, Transitional_Processing set to false, and IgnoreInvalidPunycode set to false. [UTS46]
</li>
	<li>
~IFï¼»
%çµæœ ã«ã¯ä½•ã‚‰ã‹ã®~errorãŒè¨˜éŒ²ã•ã‚ŒãŸ
ï¼½
â‡’
`æ¤œè¨¼~error$( `domain-to-Unicode$err )
â—
Signify domain-to-Unicode validation errors for any returned errors, and then,ï¼¼
</li>
	<li>
~RET %çµæœ
â—
return result.
</li>
</ol>
</div>

		</section>
		<section id="host-writing">
<h3 title="Host writing">3.4. ~hostã®æ›¸å‡ºæ³•</h3>

<div class="p">
<p>
`å¦¥å½“ãª~host@sT
ã¯ã€
æ¬¡ã®ã„ãšã‚Œã‹ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
</p>
<ul>
	<li>
`å¦¥å½“ãª~domain$sT
</li>
	<li>
`å¦¥å½“ãª~IPv4~address$sT
</li>
	<li>
<p>
æ¬¡ã®ä¸¦ã³ï¼š
</p>
		<ol>
			<li>
â[
</li>
			<li>
`å¦¥å½“ãª~IPv6~address$sT
</li>
			<li>
â]
	</li></ol>
</li></ul>

â—
A valid host string must be a valid domain string, a valid IPv4-address string, or: U+005B ([), followed by a valid IPv6-address string, followed by U+005D (]).
</div>

<div class="algo">
<p>
`æ–‡å­—åˆ—$ %å…¥åŠ› ãŒ
`å¦¥å½“ãª~domain@
ã§ã‚ã‚‹ã¨ã¯ã€ï¼»
æ¬¡ã®çµæœ ~NEQ `å¤±æ•—^i
ï¼½ã«ãªã‚‹ã“ã¨ã‚’ã„ã†
â‡’
`~domainã‚’~ASCIIåŒ–ã™ã‚‹$( %å…¥åŠ›, ~T )
â—
A string input is a valid domain if these steps return true:
â€¢ Let domain be the result of running domain to ASCII with input and true.
â€¢ Return false if domain is failure; otherwise true.
</p>

<p class="XXX">èª²é¡Œï¼š
ç†æƒ³çš„ã«ã¯ã€
`å¦¥å½“ãª~domain$ã‚’æˆã™~cpä¸¦ã³ã«åŸºã¥ã„ã¦å®šç¾©ã—ãŸã„æ‰€
â€” ãƒ¢ã‚°ãƒ©å©ãã®ã‚ˆã†ã«å®šç¾©ã™ã‚‹ã®ã§ã¯ãªãï¼š
`èª²é¡Œ #245ï¼ https://github.com/whatwg/url/issues/245$
â—
Ideally we define this in terms of a sequence of code points that make up a valid domain rather than through a whack-a-mole: issue 245.
</p>
</div>

<p>
`å¦¥å½“ãª~domain@sT
ã¯ã€
`å¦¥å½“ãª~domain$ã‚’ä¸ãˆã‚‹æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
A valid domain string must be a string that is a valid domain.
</p>

<p>
`å¦¥å½“ãª~IPv4~address@sT
ã¯ã€ï¼»
â. ã§åˆ†é›¢ã•ã‚ŒãŸï¼Œ 4 å€‹ã®ï¼»
æ¬¡ã‚’æº€ãŸã™æœ€çŸ­ãªæ–‡å­—åˆ—
ï¼½ãŒæˆã™ä¸¦ã³
ï¼½ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤
â‡’
ï¼»
1 å€‹ä»¥ä¸Šã®`~ASCIIæ•°å­—$ã®ã¿ã‹ã‚‰ãªã‚‹
ï¼½~ANDï¼»
ãã‚ŒãŒè¡¨ç¾ã™ã‚‹ 10 é€²æ•° ~IN { 0 ã€œ 255 }
ï¼½
â—
A valid IPv4-address string must be four shortest possible strings of ASCII digits, representing a decimal number in the range 0 to 255, inclusive, separated from each other by U+002E (.).
</p>

<p>
`å¦¥å½“ãª~IPv6~address@sT
ã¯ã€
`IP Version 6 Addressing Architecture^cite
`Â§ Text Representation of Addressesï¼ ~RFCx/rfc4291#section-2.2$
ï¼ˆ Â§ ~addressã®~textè¡¨ç¾ï¼‰ã«ã¦å®šç¾©ã•ã‚Œã‚‹ã€‚
`RFC4291$r
â—
A valid IPv6-address string is defined in the "Text Representation of Addresses" chapter of IP Version 6 Addressing Architecture. [RFC4291]
</p>

<p>
`å¦¥å½“ãªä¸é€æ˜ãª~host@sT
ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ ã„ãšã‚Œã‹ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A valid opaque-host string must be one of the following:
</p>

<ul>
	<li>
1 å€‹ä»¥ä¸Šã®ï¼»
æ¬¡ã‚’æº€ãŸã™`~URLå˜ä½$
ï¼½ãŸã¡ãŒæˆã™ä¸¦ã³
â‡’
`ç¦æ­¢~host~cp$ã§ãªã„
â—
one or more URL units excluding forbidden host code points
</li>
	<li>
æ¬¡ã®ä¸¦ã³ï¼š
		<ol>
			<li>
â[
</li>
			<li>
`å¦¥å½“ãª~IPv6~address$sT
</li>
			<li>
â]
		</li>
	</ol>
â—
U+005B ([), followed by a valid IPv6-address string, followed by U+005D (]).
</li>
</ul>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
`å¦¥å½“ãª~host$sTã®å®šç¾©ã‚’æˆã™ä¸€éƒ¨ã§ã¯ãªã„
â€” ãã‚Œã«ã¯ã€
æ–‡è„ˆã‚’åˆ¤åˆ¥ã™ã‚‹ã“ã¨ãŒè¦æ±‚ã•ã‚Œã‚‹ã®ã§ã€‚
â—
This is not part of the definition of valid host string as it requires context to be distinguished.
</p>

		</section>
		<section id="host-parsing">
<h3 title="Host parsing">3.5. ~hostã®æ§‹æ–‡è§£æ-æ³•</h3>

<div class="algo">
<p>
`~hostæ§‹æ–‡è§£æå™¨@
ã¯ã€
æ‰€ä¸ã®
( `~scalarå€¤~æ–‡å­—åˆ—$ %å…¥åŠ›, çœŸå½å€¤ %ä¸é€æ˜ã‹ ï¼ˆçœç•¥æ™‚ã¯ ~F ï¼‰ )
ã«å¯¾ã—ï¼Œï¼»
`å¤±æ•—^i ï¼`~host$
ï¼½ã‚’è¿”ã™ï¼š
â—
The host parser takes a scalar value string input with an optional boolean isOpaque (default false), and then runs these steps. They return failure or a host.
</p>
<ol>
	<li>
<p>
~IFï¼»
%å…¥åŠ› ã®å…ˆé ­ ~EQ â[
ï¼½ï¼š
â—
If input starts with U+005B ([), then:
</p>
		<ol>
			<li>
~IFï¼»
%å…¥åŠ› ã®æœ«å°¾ ~NEQ â]
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv6-unclosed$err )ï¼›
~RET `å¤±æ•—^i
â—
If input does not end with U+005D (]), IPv6-unclosed validation error, return failure.
</li>
			<li>
~RET `~IPv6æ§‹æ–‡è§£æå™¨$( %å…¥åŠ› ã‹ã‚‰å…ˆé ­ã® â[ ã¨æœ«å°¾ã® â] ã‚’é™¤å»ã—ãŸçµæœ )
â—
Return the result of IPv6 parsing input with its leading U+005B ([) and trailing U+005D (]) removed.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%ä¸é€æ˜ã‹ ~EQ ~T
ï¼½
â‡’
~RET `ä¸é€æ˜ãª~hostæ§‹æ–‡è§£æå™¨$( %å…¥åŠ› )
â—
If isOpaque is true, then return the result of opaque-host parsing input.
</li>
	<li>
~Assertï¼š
%å…¥åŠ› ~NEQ ç©º~æ–‡å­—åˆ—
â—
Assert: input is not the empty string.
</li>
	<li>
<p>
%~domain ~LET `~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$( `æ–‡å­—åˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹$( %å…¥åŠ› ) )
â—
Let domain be the result of running UTF-8 decode without BOM on the percent-decoding of input.
</p>

<p class="note">æ³¨è¨˜ï¼š
åˆ¥æ³•ã¨ã—ã¦ã€
`~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$~algoã‚’åˆ©ç”¨ã—ãŸä¸Šã§ï¼Œ
`å¤±æ•—^i æ™‚ã«ã¯æ—©ã€…ã« ~RET ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹
â€” `~domainã‚’~ASCIIåŒ–ã™ã‚‹$ã®ã¯
`FFFD^U `REPLACEMENT CHARACTER^cn ã€ï¼(ï¿½)ã€‘
ã«å¯¾ã—å¤±æ•—ã™ã‚‹ã®ã§ã€‚
â—
Alternatively UTF-8 decode without BOM or fail can be used, coupled with an early return for failure, as domain to ASCII fails on U+FFFD (ï¿½).
</p>
	</li>
	<li>
%~ASCII~domain ~LET `~domainã‚’~ASCIIåŒ–ã™ã‚‹$( %~domain, ~F )
â—
Let asciiDomain be the result of running domain to ASCII with domain and false.
</li>
	<li>
~IFï¼»
%~ASCII~domain ~EQ `å¤±æ•—^i
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If asciiDomain is failure, then return failure.
</li>
	<li>
~IFï¼»
`ç•ªå·ã§çµ‚ç«¯ã—ã¦ã„ã‚‹ã‹æ¤œæŸ»ã™ã‚‹$( %~ASCII~domain ) ~EQ ~T
ï¼½
â‡’
~RET `~IPv4æ§‹æ–‡è§£æå™¨$( %~ASCII~domain )
â—
If asciiDomain ends in a number, then return the result of IPv4 parsing asciiDomain.
</li>
	<li>
~RET %~ASCII~domain
â—
Return asciiDomain.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`ç•ªå·ã§çµ‚ç«¯ã—ã¦ã„ã‚‹ã‹æ¤œæŸ»ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~ASCIIæ–‡å­—åˆ—$ %å…¥åŠ› )
ã«å¯¾ã—ï¼ŒçœŸå½å€¤ã‚’è¿”ã™ï¼š
â—
The ends in a number checker takes an ASCII string input and then runs these steps. They return a boolean.
</p>
<ol>
	<li>
%æˆåˆ†p~list ~LET `åŒºåˆ‡å­ã§å³å¯†ã«åˆ†å‰²ã™ã‚‹$( %å…¥åŠ›, â. )
â—
Let parts be the result of strictly splitting input on U+002E (.).
</li>
	<li>
<p>
~IFï¼»
%æˆåˆ†p~list ã®æœ€å¾Œã®`~item$ ~EQ ç©º~æ–‡å­—åˆ—
ï¼½ï¼š
â—
If the last item in parts is the empty string, then:
</p>
		<ol>
			<li>
~IFï¼»
%æˆåˆ†p~list ã®`~size$ ~EQ 1
ï¼½
â‡’
~RET ~F
â—
If partsâ€™s size is 1, then return false.
</li>
			<li>
%æˆåˆ†p~list ã‹ã‚‰æœ€å¾Œã®`~item$ã‚’`é™¤å»ã™ã‚‹$
â—
Remove the last item from parts.
</li>
		</ol>
	</li>
	<li>
%æœ€å¾Œã®~item ~LET %æˆåˆ†p~list ã®æœ€å¾Œã®`~item$
â—
Let last be the last item in parts.
</li>
	<li>
<p>
~IFï¼»
%æœ€å¾Œã®~item ã¯ 1 å€‹ä»¥ä¸Šã®`~ASCIIæ•°å­—$ã®ã¿ã‹ã‚‰ãªã‚‹
ï¼½
â‡’
~RET ~T
â—
If last is non-empty and contains only ASCII digits, then return true.
</p>

<p class="note">æ³¨è¨˜ï¼š
~errorå«ã¿ã®å…¥åŠ› `09^l ã¯ã€
å¾Œã®æ®µã«ã¦`~IPv4æ§‹æ–‡è§£æå™¨$ã«ã‚ˆã‚Š~catchã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
The erroneous input "09" will be caught by the IPv4 parser at a later stage.
</p>
	</li>
	<li>
<p>
~IFï¼»
`~IPv4ç•ªå·~æ§‹æ–‡è§£æå™¨$( %æœ€å¾Œã®~item ) ~NEQ `å¤±æ•—^i
ï¼½
â‡’
~RET ~T
â—
If parsing last as an IPv4 number does not return failure, then return true.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
%æœ€å¾Œã®~item ãŒæ¬¡ã®ä¸¦ã³ã‹å¦ã‹æ¤œæŸ»ã™ã‚‹ã“ã¨ã«ç­‰ä¾¡ã«ãªã‚‹
â‡’ï¼ƒ
`0X^l ã¾ãŸã¯ `0x^l,
0 å€‹~ä»¥ä¸Šã®`~ASCII~hexæ•°å­—$
â—
This is equivalent to checking that last is "0X" or "0x", followed by zero or more ASCII hex digits.
</p>
	</li>
	<li>
~RET ~F
â—
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`~IPv4æ§‹æ–‡è§£æå™¨@
ã¯ã€
æ‰€ä¸ã®
( `~ASCIIæ–‡å­—åˆ—$ %å…¥åŠ› )
ã«å¯¾ã—ï¼Œï¼»
`å¤±æ•—^i ï¼`~IPv4~address$
ï¼½ã‚’è¿”ã™ï¼š
â—
The IPv4 parser takes an ASCII string input and then runs these steps. They return failure or an IPv4 address.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä»–ã®ä»•æ§˜ã¯ã€
`~IPv4æ§‹æ–‡è§£æå™¨$ã‚’ç›´ã«å‘¼å‡ºã•ãªã„ã“ã¨ã€‚
ä»£ã‚ã‚Šã«ï¼Œï¼»
`~hostæ§‹æ–‡è§£æå™¨$ã®è¿”ã‚Šå€¤ãŒ`~IPv4~address$ã«ãªã‚‹ã‹ã©ã†ã‹
ï¼½ã‚’æ¤œæŸ»ã™ã‚‹ã“ã¨ã€‚
â—
The IPv4 parser is not to be invoked directly. Instead check that the return value of the host parser is an IPv4 address.
</p>
<ol>
	<li>
%æˆåˆ†p~list ~LET `åŒºåˆ‡å­ã§å³å¯†ã«åˆ†å‰²ã™ã‚‹$( %å…¥åŠ›, â. )
â—
Let parts be the result of strictly splitting input on U+002E (.).
</li>
	<li>
<p>
~IFï¼»
%æˆåˆ†p~list å†…ã®æœ€å¾Œã®`~item$ ~EQ ç©º~æ–‡å­—åˆ—
ï¼½ï¼š
â—
If the last item in parts is the empty string, then:
</p>
		<ol>
			<li>
`æ¤œè¨¼~error$( `IPv4-empty-part$err )
â—
IPv4-empty-part validation error.
</li>
			<li>
<p>
~IFï¼»
%æˆåˆ†p~list ã®`~size$ ~GT 1
ï¼½
â‡’
%æˆåˆ†p~list ã‹ã‚‰æœ€å¾Œã®`~item$ã‚’`é™¤å»ã™ã‚‹$
</p>

<p class="trans-note">ã€
%å…¥åŠ› ã®æœ«å°¾ã«ä½™è¨ˆãª â. ãŒã‚ã£ã¦ã‚‚å—å®¹ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
ã€‘</p>
â—
If partsâ€™s size is greater than 1, then remove the last item from parts.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%æˆåˆ†p~list ã®`~size$ ~GT 4
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv4-too-many-parts$err )ï¼›
~RET `å¤±æ•—^i
â—
If partsâ€™s size is greater than 4, IPv4-too-many-parts validation error, return failure.
</li>
	<li>
%ç•ªå·~list ~LET æ–°ãŸãª`~list$
â—
Let numbers be an empty list.
</li>
	<li>
<p>
%æˆåˆ†p~list ã‚’æˆã™
~EACH( %æˆåˆ†p )
ã«å¯¾ã—ï¼š
â—
For each part of parts:
</p>
		<ol>
			<li>
%çµæœ ~LET `~IPv4ç•ªå·~æ§‹æ–‡è§£æå™¨$( %æˆåˆ†p )
â—
Let result be the result of parsing part.
</li>

			<li>
~IFï¼»
%çµæœ ~EQ `å¤±æ•—^i
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv4-non-numeric-part$err )ï¼›
~RET `å¤±æ•—^i
â—
If result is failure, IPv4-non-numeric-part validation error, return failure.
</li>
			<li>
( %ç•ªå·, %æ¤œè¨¼~errorã‹ ) ~LET %çµæœ
â—
â†“</li>
			<li>
~IFï¼»
%æ¤œè¨¼~errorã‹ ~EQ ~T
ï¼½
â‡’
`æ¤œè¨¼~error$( `IPv4-non-decimal-part$err )
â—
If result[1] is true, IPv4-non-decimal-part validation error.
</li>
			<li>
%ç•ªå·~list ã« %ç•ªå· ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Append result[0] to numbers.
</li>
		</ol>
	</li>
	<li>
%æœ€å¾Œã®~index ~LET %ç•ªå·~list ã®`~size$ ~MINUS 1
â—
â†“</li>
	<li>
<p>
ç¯„å›² { 0 ã€œ %æœ€å¾Œã®~index } ã‚’æˆã™
~EACH( %i )
ã«å¯¾ã—ï¼Œæ˜‡é †ã«ï¼š
</p>
		<ol>
			<li>
~IFï¼»
%ç•ªå·~list[ %i ] ~LTE 255
ï¼½
â‡’
~CONTINUE
</li>
			<li>
`æ¤œè¨¼~error$( `IPv4-out-of-range-part$err )
</li>
			<li>
~IFï¼»
%i ~NEQ %æœ€å¾Œã®~index
ï¼½
â‡’
~RET `å¤±æ•—^i
</li>
		</ol>
â—
If any item in numbers is greater than 255, IPv4-out-of-range-part validation error.
â—
If any but the last item in numbers is greater than 255, then return failure.
</li>
	<li>
~IFï¼»
%ç•ªå·~list[ %æœ€å¾Œã®~index ]â€  ~GTE
( 256 ã® ( 4 âˆ’ %æœ€å¾Œã®~index ) ä¹— )
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If the last item in numbers is greater than or equal to 256(5 âˆ’ numbersâ€™s size), then return failure.
</li>
	<li>
%~IPv4 ~LET %ç•ªå·~list[ %æœ€å¾Œã®~index ]
â—
Let ipv4 be the last item in numbers.
</li>
	<li>
%ç•ªå·~list ã‹ã‚‰æœ€å¾Œã®`~item$ã‚’`é™¤å»ã™ã‚‹$â€ â€ 
â—
Remove the last item from numbers.
</li>
	<li>
%~counter ~LET 0
â—
Let counter be 0.
</li>
	<li>
<p>
%ç•ªå·~list ã‚’æˆã™
~EACH( %n )
ã«å¯¾ã—ï¼š
â—
For each n of numbers:
</p>
		<ol>
			<li>
%~IPv4 ~INCBY ( %n Ã— ( 256 ã® ( 3 âˆ’ %~counter ) ä¹— ) )
â—
Increment ipv4 by n Ã— 256(3 âˆ’ counter).
</li>
			<li>
%~counter ~INCBY 1
â—
Increment counter by 1.
</li>
		</ol>
	</li>
	<li>
~RET %~IPv4
â—
Return ipv4.
</li>
</ol>

<p class="trans-note">ã€â€ 
æœ€å¾Œã®~itemã ã‘ç‰¹åˆ¥æ‰±ã„
â€” ä¾‹ãˆã°ã€
`100.100.25600^l ã¯ `100.100.100.0^l ã¨ç­‰ä¾¡ã«ãªã‚Šï¼Œ
`0xFFFFFFFF^l ã¯ `255.255.255.255^l ã¨ç­‰ä¾¡ã«ãªã‚‹ã€‚
ã€‘ã€â€ â€ 
ã“ã“ã§ã‚‚ã€
 %ç•ªå·~list ã®~sizeãŒ 4 ã«æº€ãŸãªã„å ´åˆã¯ï¼‰æœ€å¾Œã®~itemã ã‘ç‰¹åˆ¥æ‰±ã„
â€” ä¾‹ãˆã°ã€
`100.100^l ã¯ `100.0.0.100^l ã¨ç­‰ä¾¡ã«ãªã‚‹ã€‚
ã€‘</p>
</div>

<div class="algo">
<p>
`~IPv4ç•ªå·~æ§‹æ–‡è§£æå™¨@
ã¯ã€
æ‰€ä¸ã®
( `~ASCIIæ–‡å­—åˆ—$ %å…¥åŠ› )
ã«å¯¾ã—ï¼Œï¼»
`å¤±æ•—^i ï¼
( ç•ªå·, çœŸå½å€¤ ) ãŒæˆã™`~tuple$
ï¼½ã‚’è¿”ã™ï¼š
â—
The IPv4 number parser takes an ASCII string input and then runs these steps. They return failure or a tuple of a number and a boolean.
</p>
<ol>
	<li>
~IFï¼»
%å…¥åŠ› ~EQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If input is the empty string, then return failure.
</li>
	<li>
%æ¤œè¨¼~errorã‹ ~LET ~F
â—
Let validationError be false.
</li>
	<li>
%R ~LET 10
â—
Let R be 10.
</li>
	<li>
<p>
~IFï¼»
%å…¥åŠ› ã®é•·ã• ~GTE 2
ï¼½~ANDï¼»
%å…¥åŠ› ã®å…ˆé ­ã®~cp ~EQ â0
ï¼½ï¼š
</p>
		<ol>
			<li>
%æ¤œè¨¼~errorã‹ ~SET ~T
</li>
			<li>
%å…¥åŠ› ã‹ã‚‰å…ˆé ­ã®~cpã‚’é™¤å»ã™ã‚‹
</li>
			<li>
%R ~SET 8
</li>
			<li>
~IFï¼»
%å…¥åŠ› ã®å…ˆé ­ã®~cp ~IN { âX, âx }
ï¼½
â‡’ï¼ƒ
%å…¥åŠ› ã‹ã‚‰å…ˆé ­ã®~cpã‚’é™¤å»ã™ã‚‹ï¼›
%R ~SET 16
</li>
		</ol>

â—
If input contains at least two code points and the first two code points are either "0X" or "0x", then:
â€¢ Set validationError to true.
â€¢ Remove the first two code points from input.
â€¢ Set R to 16.
â—
Otherwise, if input contains at least two code points and the first code point is U+0030 (0), then:
â€¢ Set validationError to true.
â€¢ Remove the first code point from input.
â€¢ Set R to 8.
</li>
	<li>
<p>
~IFï¼»
%å…¥åŠ› ~EQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’
~RET ( 0, ~T )
</p>

<p class="trans-note">ã€
`0x^l ï¼ `0X^l ãŒå…¥åŠ›ã•ã‚ŒãŸã¨ãã‚‚ï¼Œã“ã“ã«è©²å½“ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
ã€‘</p>
â—
If input is the empty string, then return (0, true).
</li>
	<li>
~IFï¼»
%å…¥åŠ› å†…ã«åŸºæ•° %R ã®æ•°å­—ã§ãªã„~cpãŒåœ¨ã‚‹
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If input contains a code point that is not a radix-R digit, then return failure.
</li>
	<li>
%å‡ºåŠ› ~LET %å…¥åŠ› ã‚’åŸºæ•° %R ã«ã‚ˆã‚‹è¡¨è¨˜ã¨~~è¦‹ãªã™ä¸‹ã§ï¼Œæ•´æ•° å€¤ã¨ã—ã¦~~è§£é‡ˆã—ãŸçµæœ
â€” %R ~EQ 16 ã®å ´åˆã€
å„æ¡ã®`~ASCII~hexæ•°å­—$ã‚’ 0 ã€œ 15 ã®å€¤ã«å¯¾å¿œ~ä»˜ã‘ã‚‹ä¸‹ã§
â—
Let output be the mathematical integer value that is represented by input in radix-R notation, using ASCII hex digits for digits with values 0 through 15.
</li>
	<li>
~RET ( %å‡ºåŠ›, %æ¤œè¨¼~errorã‹ )
â—
Return (output, validationError).
</li>
</ol>

<p class="trans-note">ã€
`0xAB.012.0X12.12^l
ã®æ§˜ãª~hoståã‚‚ IPv4 ~addressã¨è¦‹ãªã•ã‚Œã€
`0xAB^l, `0X12^l ã¯ 16 é€²æ•°,
`012^l ã¯ 8 é€²æ•°,
`12^l ã¯ 10 é€²æ•°
ã¨ã—ã¦è§£é‡ˆã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
ã€‘</p>
</div>

<hr>

<div class="algo">
<p>
`~IPv6æ§‹æ–‡è§£æå™¨@
ã¯ã€
æ‰€ä¸ã®
( `~scalarå€¤~æ–‡å­—åˆ—$ %å…¥åŠ› )
ã«å¯¾ã—ï¼Œï¼»
`å¤±æ•—^i ï¼`~IPv6~address$
ï¼½ã‚’è¿”ã™ï¼š
â—
The IPv6 parser takes a scalar value string input and then runs these steps. They return failure or an IPv6 address.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä»–ã®ä»•æ§˜ã¯ã€
ç†è«–~ä¸Šã¯ï¼Œ`~IPv6æ§‹æ–‡è§£æå™¨$ã‚’ç›´ã«å‘¼å‡ºã™ã“ã¨ã‚‚ã§ãã‚‹ãŒã€
å®Ÿéš›ã«ãã‚Œã‚’è¡Œã†å‰ã«ï¼Œã“ã®æ–‡æ›¸ã®ç·¨é›†è€…ãŸã¡ã¨è«–ã˜ã‚‰ã‚ŒãŸã—ã€‚
â—
The IPv6 parser could in theory be invoked directly, but please discuss actually doing that with the editors of this document first.
</p>
<ol>
	<li>
%~address ~LET æ–°ãŸãª`~IPv6~address$
â€” ãã®
â‡’
`~pieceç¾¤$ ~SET Â« 0, 0, 0, 0, 0, 0, 0, 0 Â»
â—
Let address be a new IPv6 address whose pieces are all 0.
</li>
	<li>
%~piece~index ~LET 0
â—
Let pieceIndex be 0.
</li>
	<li>
%åœ§ç¸®-~index ~LET ~NULL
â—
Let compress be null.
</li>
	<li>
%~pointer ~LET %å…¥åŠ› ç”¨ã®`~pointer$
â—
Let pointer be a pointer for input.
</li>
	<li>
<p>
~IFï¼»
`C$V ~EQ â:
ï¼½ï¼š
â—
If c is U+003A (:), then:
</p>
		<ol>
			<li>
~IFï¼»
`C1$V ~NEQ â:
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv6-invalid-compression$err )ï¼›
~RET `å¤±æ•—^i
â—
If remaining does not start with U+003A (:), IPv6-invalid-compression validation error, return failure.
</li>
	<li>
%~pointer ~INCBY 2
â—
Increase pointer by 2.
</li>
	<li>
%~piece~index ~INCBY 1
â—
Increase pieceIndex by 1 and thenï¼¼
</li>
	<li>
%åœ§ç¸®-~index ~SET %~piece~index
â—
set compress to pieceIndex.
</li>
		</ol>
	</li>
	<li>
<p>
~WHILE ï¼»
`C$V ~NEQ `EOF$i
ï¼½ï¼š
â—
While c is not the EOF code point:
</p>
		<ol>
			<li>
~IFï¼»
%~piece~index ~EQ 8
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv6-too-many-pieces$err )ï¼›
~RET `å¤±æ•—^i
â—
If pieceIndex is 8, IPv6-too-many-pieces validation error, return failure.
</li>
			<li>
<p>
~IFï¼»
`C$V ~EQ â:
ï¼½ï¼š
â—
If c is U+003A (:), then:
</p>
				<ol>
					<li>
~IFï¼»
%åœ§ç¸®-~index ~NEQ ~NULL
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv6-multiple-compression$err )ï¼›
~RET `å¤±æ•—^i
â—
If compress is non-null, IPv6-multiple-compression validation error, return failure.
</li>
					<li>
%~pointer ~INCBY 1
â—
â†“</li>
					<li>
%~piece~index ~INCBY 1
â—
Increase pointer and pieceIndex by 1,ï¼¼
</li>
					<li>
%åœ§ç¸®-~index ~SET %~piece~index
â—
set compress to pieceIndex,ï¼¼
</li>
					<li>
~CONTINUE
â—
and then continue.
</li>
				</ol>
			</li>
			<li>
%å€¤ ~LET 0
â—
â†“</li>
			<li>
%é•·ã• ~LET 0
â—
Let value and length be 0.
</li>
			<li>
~WHILE ï¼»
%é•·ã• ~LT 4
ï¼½~ANDï¼»
`C$V ~IN `~ASCII~hexæ•°å­—$
ï¼½
â‡’ï¼ƒ
%å€¤ ~SET %å€¤ ~MUL `10^X ~PLUS ï¼» `C$V ã‚’~hexadecimalæ•°ã¨ã—ã¦è§£é‡ˆã—ãŸå€¤ ï¼½ï¼›
%~pointer ~INCBY 1ï¼›
%é•·ã• ~INCBY 1
â—
While length is less than 4 and c is an ASCII hex digit, set value to value Ã— 0x10 + c interpreted as hexadecimal number, and increase pointer and length by 1.
</li>
			<li>
<p>
~IFï¼»
`C$V ~EQ â.
ï¼½ï¼š
â—
If c is U+002E (.), then:
</p>
				<ol>
					<li>
~IFï¼»
%é•·ã• ~EQ 0
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv4-in-IPv6-invalid-code-point$err )ï¼›
~RET `å¤±æ•—^i
â—
If length is 0, IPv4-in-IPv6-invalid-code-point validation error, return failure.
</li>
					<li>
%~pointer ~DECBY %é•·ã•
â—
Decrease pointer by length.
</li>
					<li>
~IFï¼»
%~piece~index ~GT 6
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv4-in-IPv6-too-many-pieces$err )ï¼›
~RET `å¤±æ•—^i
â—
If pieceIndex is greater than 6, IPv4-in-IPv6-too-many-pieces validation error, return failure.
</li>
					<li>
%~IPv4å€‹æ•° ~LET 0
â—
Let numbersSeen be 0.
</li>
					<li>
<p>
~WHILE ï¼»
`C$V ~NEQ `EOF$i
ï¼½ï¼š
â—
While c is not the EOF code point:
</p>
						<ol>
							<li>
%~IPv4~piece ~LET ~NULL
â—
Let ipv4Piece be null.
</li>
							<li>
<p>
~IFï¼»
%~IPv4å€‹æ•° ~GT 0
ï¼½ï¼š
â—
If numbersSeen is greater than 0, then:
</p>
								<ol>
									<li>
~IFï¼»
`C$V ~EQ â.
ï¼½~ANDï¼»
%~IPv4å€‹æ•° ~LT 4
ï¼½
â‡’
%~pointer ~INCBY 1
â—
If c is a U+002E (.) and numbersSeen is less than 4, then increase pointer by 1.
</li>
									<li>
~ELSE
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv4-in-IPv6-invalid-code-point$err )ï¼›
~RET `å¤±æ•—^i
â—
Otherwise, IPv4-in-IPv6-invalid-code-point validation error, return failure.
</li>
								</ol>
							</li>
							<li>
~IFï¼»
`C$V ~NIN `~ASCIIæ•°å­—$
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv4-in-IPv6-invalid-code-point$err )ï¼›
~RET `å¤±æ•—^iã€ï¼ prevent the empty stringã€‘
â—
If c is not an ASCII digit, IPv4-in-IPv6-invalid-code-point validation error, return failure.
</li>
							<li>
<p>
~WHILE ï¼»
`C$V ~IN `~ASCIIæ•°å­—$
ï¼½ï¼š
â—
While c is an ASCII digit:
</p>
								<ol>
									<li>
~IFï¼»
%~IPv4~piece ~EQ 0
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv4-in-IPv6-invalid-code-point$err )ï¼›
~RET `å¤±æ•—^i
â—
Let number be c interpreted as decimal number.
â—
If ipv4Piece is null, then set ipv4Piece to number.
â—
Otherwise, if ipv4Piece is 0, IPv4-in-IPv6-invalid-code-point validation error, return failure.
</li>
									<li>
~IFï¼»
%~IPv4~piece ~EQ ~NULL
ï¼½
â‡’
%~IPv4~piece ~SET 0
â—
â†‘</li>
									<li>
%~IPv4~piece ~SET %~IPv4~piece ~MUL 10 + ï¼»
`C$V ã‚’ 10 é€²æ•°ã¨ã—ã¦è§£é‡ˆã—ãŸå€¤
ï¼½
â—
Otherwise, set ipv4Piece to ipv4Piece Ã— 10 + number.
</li>
									<li>
~IFï¼»
%~IPv4~piece ~GT 255
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv4-in-IPv6-out-of-range-part$err )ï¼›
~RET `å¤±æ•—^i
â—
If ipv4Piece is greater than 255, IPv4-in-IPv6-out-of-range-part validation error, return failure.
</li>
									<li>
%~pointer ~INCBY 1
â—
Increase pointer by 1.
</li>
								</ol>
							</li>
							<li>
%~address[ %~piece~index ] ~SET %~address[ %~piece~index ] ~MUL `100^X ~PLUS %~IPv4~piece
â—
Set address[pieceIndex] to address[pieceIndex] Ã— 0x100 + ipv4Piece.
</li>
							<li>
%~IPv4å€‹æ•° ~INCBY 1
â—
Increase numbersSeen by 1.
</li>
							<li>
~IFï¼»
%~IPv4å€‹æ•° ~IN { 2, 4 }
ï¼½
â‡’
%~piece~index ~INCBY 1
â—
If numbersSeen is 2 or 4, then increase pieceIndex by 1.
</li>
						</ol>
					</li>
					<li>
~IFï¼»
%~IPv4å€‹æ•° ~NEQ 4
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv4-in-IPv6-too-few-parts$err )ï¼›
~RET `å¤±æ•—^i
â—
If numbersSeen is not 4, IPv4-in-IPv6-too-few-parts validation error, return failure.
</li>
					<li>
~BREAK
â—
Break.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIFï¼»
`C$V ~EQ â:
ï¼½ï¼š
â—
Otherwise, if c is U+003A (:):
</p>
				<ol>
					<li>
%~pointer ~INCBY 1
â—
Increase pointer by 1.
</li>
					<li>
~IFï¼»
`C$V ~EQ `EOF$i
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv6-invalid-code-point$err )ï¼›
~RET `å¤±æ•—^i
â—
If c is the EOF code point, IPv6-invalid-code-point validation error, return failure.
</li>
				</ol>
			</li>
			<li>
~ELIFï¼»
`C$V ~NEQ `EOF$i
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv6-invalid-code-point$err )ï¼›
~RET `å¤±æ•—^i
â—
Otherwise, if c is not the EOF code point, IPv6-invalid-code-point validation error, return failure.
</li>
			<li>
%~address[ %~piece~index ] ~SET %å€¤
â—
Set address[pieceIndex] to value.
</li>
			<li>
%~piece~index ~INCBY 1
â—
Increase pieceIndex by 1.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
%åœ§ç¸®-~index ~NEQ ~NULL
ï¼½ï¼š
â—
If compress is non-null, then:
</p>
		<ol>
			<li>
%~swapæ•° ~LET %~piece~index ~MINUS %åœ§ç¸®-~index
â—
Let swaps be pieceIndex âˆ’ compress.
</li>
			<li>
%~piece~index ~SET 7
â—
Set pieceIndex to 7.
</li>
			<li>
~WHILE ï¼»
%~piece~index ~NEQ 0
ï¼½~ANDï¼»
%~swapæ•° ~GT 0
ï¼½
â‡’ï¼ƒ
%~address[ %~piece~index ] ã¨ %~address[ %åœ§ç¸®-~index ~PLUS %~swapæ•° ~MINUS 1 ] ã®å€¤ã‚’~swapã™ã‚‹ï¼›
%~piece~index ~DECBY 1ï¼›
%~swapæ•° ~DECBY 1
â—
While pieceIndex is not 0 and swaps is greater than 0, swap address[pieceIndex] with address[compress + swaps âˆ’ 1], and then decrease both pieceIndex and swaps by 1.
</li>
		</ol>
<div class="trans-note">
<p>ã€
ã“ã®æ®µã¯å¦™ã«ã¾ã‚ã‚Šãã©ã„
â€” å®Ÿè³ªçš„ã«ã¯ã€
æ¬¡ã¨ç­‰ä¾¡ã«ãªã‚‹ï¼š
</p>
		<ol>
			<li>
%~piece~index ~SET 7
</li>
			<li>
~WHILE ï¼»
%~piece~index ~GT %åœ§ç¸®-~index
ï¼½
â‡’ï¼ƒ
%~address[ %~piece~index ] ã¨ %~address[ %~piece~index ~MINUS 1 ] ã®å€¤ã‚’~swapã™ã‚‹ï¼›
%~piece~index ~DECBY 1
â—
While pieceIndex is not 0 and swaps is greater than 0, swap address[pieceIndex] with address[compress + swaps âˆ’ 1], and then decrease both pieceIndex and swaps by 1.
</li>
		</ol>
<p>
ã™ãªã‚ã¡ã€
%~address[ 7 ] ã‚’ %~address[ %åœ§ç¸®-~index ] ã¸ç§»å‹•ã—ã¦ï¼Œ
%~address[ %åœ§ç¸®-~index ] ä»¥é™ã‚’ä¸€ã¤ãšã‚‰ã—ã¦ã„ã‚‹ãŒã€
æ­£ã—ã„æŒ™å‹•ã¨ã¯æ€ãˆãªã„ã€‚
æœ¬å½“ã¯ã€
%~address[ %åœ§ç¸®-~index ] ã®ç›´å‰ã«å¿…è¦yãªå€‹æ•°ã® 0 ã‚’æŒ¿å…¥ã™ã‚‹ã¹ãã§ã¯ï¼Ÿ
â€” ãã‚Œã«ä¼´ã„ã€
ã“ã®~algoã®ä»–æ‰€ã‚‚æ”¹ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€‚
ã€‘</p>
</div>
	</li>
	<li>
~ELSE
â‡’
~IFï¼»
%~piece~index ~NEQ 8
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `IPv6-too-few-pieces$err )ï¼›
~RET `å¤±æ•—^i
â—
Otherwise, if compress is null and pieceIndex is not 8, IPv6-too-few-pieces validation error, return failure.
</li>
	<li>
~RET %~address
â—
Return address.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`ä¸é€æ˜ãª~hostæ§‹æ–‡è§£æå™¨@
ã¯ã€
æ‰€ä¸ã®
( `~scalarå€¤~æ–‡å­—åˆ—$ %å…¥åŠ› )
ã«å¯¾ã—ï¼Œï¼»
`å¤±æ•—^i ï¼`ä¸é€æ˜ãª~host$
ï¼½ã‚’è¿”ã™ï¼š
â—
The opaque-host parser takes a scalar value string input, and then runs these steps. They return failure or an opaque host.
</p>
<ol>
	<li>
~IFï¼»
%å…¥åŠ› å†…ã«`ç¦æ­¢~host~cp$ãŒåœ¨ã‚‹
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `host-invalid-code-point$err )ï¼›
~RET `å¤±æ•—^i
â—
If input contains a forbidden host code point, host-invalid-code-point validation error, return failure.
</li>
	<li>
~IFï¼»
%å…¥åŠ› å†…ã«ï¼»
`~URL~cp$, `%^l
ï¼½ä»¥å¤–ã®`~cp$ãŒåœ¨ã‚‹
ï¼½
â‡’
`æ¤œè¨¼~error$( `invalid-URL-unit$err )
â—
If input contains a code point that is not a URL code point and not U+0025 (%), invalid-URL-unit validation error.
</li>
	<li>
~IFï¼»
%å…¥åŠ› å†…ã«ï¼»
2 å€‹ã®`~ASCII~hexæ•°å­—$ãŒå¾Œç¶šã—ã¦ã„ãªã„ `%^l
ï¼½ãŒåœ¨ã‚‹
ï¼½
â‡’
`æ¤œè¨¼~error$( `invalid-URL-unit$err )
â—
If input contains a U+0025 (%) and the two code points following it are not ASCII hex digits, invalid-URL-unit validation error.
</li>
	<li>
~RET `æ–‡å­—åˆ—ã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹$( %å…¥åŠ›, `~C0åˆ¶å¾¡æ–‡å­—~percent-ç¬¦å·åŒ–-é›†åˆ$ )
â—
Return the result of running UTF-8 percent-encode on input using the C0 control percent-encode set.
</li>
</ol>
</div>

		</section>
		<section id="host-serializing">
<h3 title="Host serializing">3.6. ~hostã®ç›´åˆ—åŒ–-æ³•</h3>

<div class="algo">
<p>
`~hostã‚’ç›´åˆ—åŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~host$ %~host )
ã«å¯¾ã—ï¼Œ`~ASCIIæ–‡å­—åˆ—$ã‚’è¿”ã™ï¼š
â—
The host serializer takes a host host and then runs these steps. They return an ASCII string.
</p>
<ol>
	<li>
<p>
%~host ã®ç¨®åˆ¥ã«å¿œã˜ã¦ï¼š
â—
â†“</p>
		<ul class="switch">
			<li>
`~IPv4~address$
â‡’
~RET `~IPv4ç›´åˆ—åŒ–å™¨$( %~host )
â—
If host is an IPv4 address, return the result of running the IPv4 serializer on host.
</li>
			<li>
`~IPv6~address$
â‡’
~RET â[ ~APPEND `~IPv6ç›´åˆ—åŒ–å™¨$( %~host ) ~APPEND â]
â—
Otherwise, if host is an IPv6 address, return U+005B ([), followed by the result of running the IPv6 serializer on host, followed by U+005D (]).
</li>
			<li>
`~domain$ ï¼
`ä¸é€æ˜ãª~host$ ï¼
`ç©º~host$
â‡’
~RET %~host
â—
Otherwise, host is a domain, opaque host, or empty host, return host.
</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~IPv4ç›´åˆ—åŒ–å™¨@
ã¯ã€
æ‰€ä¸ã®
( `~IPv4~address$ %~address )
ã«å¯¾ã—ï¼Œ
`~ASCIIæ–‡å­—åˆ—$ã‚’è¿”ã™ï¼š
â—
The IPv4 serializer takes an IPv4 address address and then runs these steps. They return an ASCII string.
</p>

<ol>
	<li>
%å‡ºåŠ› ~LET ç©º~æ–‡å­—åˆ—
â—
Let output be the empty string.
</li>
	<li>
%n ~LET %~address
â—
Let n be the value of address.
</li>
	<li>
<p>
{ 1 ã€œ 4 } ã‚’æˆã™
~EACH( %i )
ã«å¯¾ã—ï¼Œæ˜‡é †ã«ï¼š
â—
For each i in the range 1 to 4, inclusive:
</p>
		<ol>
			<li>
%å‡ºåŠ› ~SET 
`æ•´æ•°ã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %n ã‚’ 256 ã§å‰²ã£ãŸä½™ã‚Š ) ~APPEND %å‡ºåŠ›
â—
Prepend n % 256, serialized, to output.
</li>
			<li>
~IFï¼»
%i ~NEQ 4
ï¼½
â‡’
â. ã‚’ %å‡ºåŠ› ã®å…ˆé ­ã«~~æŒ¿å…¥ã™ã‚‹
â—
If i is not 4, then prepend U+002E (.) to output.
</li>
			<li>
%n ~SET floor( %n ~DIV 256 )
â—
Set n to floor(n / 256).
</li>
		</ol>
	</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~IPv6ç›´åˆ—åŒ–å™¨@
ã¯ã€
æ‰€ä¸ã®
( `~IPv6~address$ %~address )
ã«å¯¾ã—ï¼Œ
`~ASCIIæ–‡å­—åˆ—$ã‚’è¿”ã™ï¼š
â—
The IPv6 serializer takes an IPv6 address address and then runs these steps. They return an ASCII string.
</p>
<ol>
	<li>
%å‡ºåŠ› ~LET ç©º~æ–‡å­—åˆ—
â—
Let output be the empty string.
</li>
	<li>
%åœ§ç¸®-~index ~LET `~IPv6~addressã®åœ§ç¸®ã•ã‚ŒãŸ~piece~indexã‚’è¦‹å‡ºã™$( %~address )
â—
Let compress be the result of finding the IPv6 address compressed piece index given address.
</li>
	<li>
%ç„¡è¦–ã™ã‚‹ã‹ ~LET ~F
â—
Let ignore0 be false.
</li>
	<li>
<p>
%~address ã®`~pieceç¾¤$ã®`~indexç¾¤$ã‚’æˆã™
~EACH( %~piece~index )
ã«å¯¾ã—ï¼š
â—
For each pieceIndex of addressâ€™s piecesâ€™s indices:
</p>
		<ol>
			<li>
~IFï¼»
%ç„¡è¦–ã™ã‚‹ã‹ ~EQ ~T
ï¼½~ANDï¼»
%~address[ %~piece~index ] ~EQ 0
ï¼½
â‡’
~CONTINUE
â—
If ignore0 is true and address[pieceIndex] is 0, then continue.
</li>
			<li>
%ç„¡è¦–ã™ã‚‹ã‹ ~SET ~F
â—
Otherwise, if ignore0 is true, set ignore0 to false.
</li>
			<li>
<p>
~IFï¼»
%åœ§ç¸®-~index ~EQ %~piece~index
ï¼½ï¼š
â—
If compress is pieceIndex, then:
</p>
				<ol>
					<li>
%å‡ºåŠ› ~APPEND ï¼»
%~piece~index ~EQ 0 ãªã‚‰ã° `::^l ï¼
~ELSE_ `:^l
ï¼½
â—
Let separator be "::" if pieceIndex is 0; otherwise U+003A (:).
â—
Append separator to output.
</li>
					<li>
%ç„¡è¦–ã™ã‚‹ã‹ ~SET ~T
â—
Set ignore0 to true and continue.
</li>
					<li>
~CONTINUE
â—
â†‘</li>
				</ol>
			</li>
			<li>
%å‡ºåŠ› ~APPEND æ¬¡ã‚’æº€ãŸã™æœ€çŸ­ãªæ–‡å­—åˆ—
â‡’
%~address[ %~piece~index ] ã‚’å°æ–‡å­—~hexadecimalæ•°ã§è¡¨ç¾ã—ã¦ã„ã‚‹
â—
Append address[pieceIndex], represented as the shortest possible lowercase hexadecimal number, to output.
</li>
			<li>
~IFï¼»
%~piece~index ~NEQ 7
ï¼½
â‡’
%å‡ºåŠ› ~APPEND â:
â—
If pieceIndex is not 7, then append U+003A (:) to output.
</li>
		</ol>
	</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®~algoã¯ã€
`A Recommendation for IPv6 Address Text Representation^cite
ï¼ˆ~IPv6~addressã®æ¨å¥¨~è¡¨è¨˜ï¼‰ã¸ã®æº–æ‹ ã‚’è¦æ±‚ã™ã‚‹ã€‚
`RFC5952$r
ã€å‚è€ƒï¼š`~IPv6~addressè¡¨è¨˜ã®æŸ”è»Ÿæ€§ãŒèµ·ã“ã™å•é¡Œã¨ RFC5952 ã®è§£èª¬ï¼ http://www.nic.ad.jp/ja/newsletter/No46/0800.html$ã€‘

â—
This algorithm requires the recommendation from A Recommendation for IPv6 Address Text Representation. [RFC5952]
</p>
</div>

<div class="algo">
<p>
`~IPv6~addressã®åœ§ç¸®ã•ã‚ŒãŸ~piece~indexã‚’è¦‹å‡ºã™@
~algoã¯ã€
æ‰€ä¸ã®
( `~IPv6~address$ %~address )
ã«å¯¾ã—ï¼š
â—
To find the IPv6 address compressed piece index given an IPv6 address address:
</p>
<ol>
	<li>
%æœ€é•·~index ~LET ~NULL
â—
Let longestIndex be null.
</li>
	<li>
%æœ€é•·~size ~LET 1
â—
Let longestSize be 1.
</li>
	<li>
%è¦‹å‡ºã•ã‚ŒãŸ~index ~LET ~NULL
â—
Let foundIndex be null.
</li>
	<li>
%è¦‹å‡ºã•ã‚ŒãŸ~size ~LET 0
â—
Let foundSize be 0.
</li>
	<li>
<p>
%~address ã®`~pieceç¾¤$ã®`~indexç¾¤$ã‚’æˆã™
~EACH( %~piece~index )
ã«å¯¾ã—ï¼š
â—
For each pieceIndex of addressâ€™s piecesâ€™s indices:
</p>
		<ol>
			<li>
<p>
~IFï¼»
%~address ã®`~pieceç¾¤$[ %~piece~index ] ~NEQ 0
ï¼½ï¼š
â—
If addressâ€™s pieces[pieceIndex] is not 0:
</p>
				<ol>
					<li>
~IFï¼»
%è¦‹å‡ºã•ã‚ŒãŸ~size ~GT %æœ€é•·~size
ï¼½
â‡’ï¼ƒ
%æœ€é•·~index ~SET %è¦‹å‡ºã•ã‚ŒãŸ~indexï¼›
%æœ€é•·~size ~SET %è¦‹å‡ºã•ã‚ŒãŸ~size
â—
If foundSize is greater than longestSize, then set longestIndex to foundIndex and longestSize to foundSize.
</li>
					<li>
%è¦‹å‡ºã•ã‚ŒãŸ~index ~SET ~NULL
â—
Set foundIndex to null.
</li>
					<li>
%è¦‹å‡ºã•ã‚ŒãŸ~size ~SET 0
â—
Set foundSize to 0.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSEï¼š
â—
Otherwise:
</p>
				<ol>
					<li>
~IFï¼»
%è¦‹å‡ºã•ã‚ŒãŸ~index ~EQ ~NULL
ï¼½
â‡’
%è¦‹å‡ºã•ã‚ŒãŸ~index ~SET %~piece~index
â—
If foundIndex is null, then set foundIndex to pieceIndex.
</li>
					<li>
%è¦‹å‡ºã•ã‚ŒãŸ~size ~INCBY 1
â—
Increment foundSize by 1.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IFï¼»
%è¦‹å‡ºã•ã‚ŒãŸ~size ~GT %æœ€é•·~size
ï¼½
â‡’
~RET %è¦‹å‡ºã•ã‚ŒãŸ~index
â—
If foundSize is greater than longestSize, then return foundIndex.
</li>
	<li>
~RET %æœ€é•·~index
â—
Return longestIndex.
</li>
</ol>

<p class="example">
ä¾‹ãˆã°ï¼Œ `0:f:0:0:f:f:0:0^l ã«å¯¾ã—ã¦ã¯ã€
2 å€‹ç›®ã® 0 ã‚’æŒ‡ã™~indexã‚’è¿”ã™ã“ã¨ã«ãªã‚‹ã€‚
â—
In 0:f:0:0:f:f:0:0 it would point to the second 0.
</p>
</div>

		</section>
		<section id="host-equivalence">

<h3 title="Host equivalence">3.7. ~hostã®ç­‰ä¾¡æ€§</h3>

<div class="algo">
<p>
2 ã¤ã®`~host$ ( %A, %B ) ã¯ã€
æ¬¡ã‚’æº€ãŸã™ã¨ã, ãã®ã¨ãã«é™ã‚Š
`åŒç­‰ãª~host@
ã§ã‚ã‚‹ã¨ã•ã‚Œã‚‹
â‡’
%A ã¨ %B ã¯ã€äº’ã„ã®å‹ãŒä¸€è‡´ã™ã‚‹, ã‹ã¤å€¤ã‚‚ã€‘ç­‰ã—ã„
â—
To determine whether a host A equals host B, return true if A is B, and false otherwise.
</p>
</div>

<p class="XXX">èª²é¡Œï¼š
è¨¼æ˜æ›¸ã®æ¯”è¼ƒã«ã¯ã€ï¼»
~domainã®å°¾éƒ¨ã®~dotã¯ç„¡è¦–ã™ã‚‹
ï¼½ã‚ˆã†ãªï¼Œ~hostã®ç­‰ä¾¡æ€§ã®æ¤œæŸ»ãŒè¦æ±‚ã•ã‚Œã‚‹ã€‚
ã—ã‹ã—ãªãŒã‚‰ã€
ãã‚Œã‚‰ã®~hostã«ã¯ï¼Œ
ã“ã“ã§ã¯æ–½è¡Œã•ã‚Œãªã„~DNSé•·ã•ãªã©ã® ä»–ã®ç¨®ã€…ã®å´é¢fã‚‚æ–½è¡Œã•ã‚Œã‚‹
â€” ~URLã¯ãã‚Œã‚‰ã‚’æ–½è¡Œã—ãªã„ã®ã§ã€‚
ã“ã‚Œã‚‰ 2 ã¤ã‚’è¿‘ã¥ã‘ã‚‹ã‚ˆã†ãª, ã‚ã‚‹ã„ã¯
çµ±ä¸€åŒ–~modelã¨ã—ã¦ä½•ã‹è‰¯ã„ç¤ºå”†ãŒã‚ã‚Œã°ï¼Œèª²é¡Œã‚’ç”³è«‹ã•ã‚ŒãŸã—ã€‚
â—
Certificate comparison requires a host equivalence check that ignores the trailing dot of a domain (if any). However, those hosts have also various other facets enforced, such as DNS length, that are not enforced here, as URLs do not enforce them. If anyone has a good suggestion for how to bring these two closer together, or what a good unified model would be, please file an issue.
</p>

		</section>
	</section>
	<section id="urls">
<h2 title="URLs">4. ~URL</h2>

<p>
é«˜~levelã‹ã‚‰ã¯ã€ï¼»
`~URL~record$,
`å¦¥å½“ãª~URL$sT,
`~URLæ§‹æ–‡è§£æå™¨$,
`~URLç›´åˆ—åŒ–å™¨$
ï¼½ã¯ï¼Œæ¬¡ã®ã‚ˆã†ã«é–¢ä¿‚ã™ã‚‹ï¼š
â—
At a high level, a URL, valid URL string, URL parser, and URL serializer relate as follows:
</p>

<ul>
	<li>
`~URLæ§‹æ–‡è§£æå™¨$ã¯ã€
ä»»æ„ãª`~scalarå€¤~æ–‡å­—åˆ—$ã«å¯¾ã—ï¼Œï¼»
`å¤±æ•—^i, ã¾ãŸã¯ `~URL~record$
ï¼½ã‚’è¿”ã™ã€‚
ã¾ãŸã€
ç”Ÿã˜ãŸå„`æ¤œè¨¼~error$ã‚‚è¨˜éŒ²ã™ã‚‹ã€‚
â—
The URL parser takes an arbitrary scalar value string and returns either failure or a URL. It might also record zero or more validation errors.
</li>
	<li>
`~URL~record$ã¯ã€
~memoryå†…ã®è¡¨ç¾ã¨æ‰ãˆã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
â—
A URL can be seen as the in-memory representation.
</li>
	<li>
`å¦¥å½“ãª~URL$sTã¯ã€
`~URLæ§‹æ–‡è§£æå™¨$ã«ã‹ã‘ãŸã¨ãã«ï¼Œ`æ¤œè¨¼~error$ã‚„ `å¤±æ•—^i ã‚’èª˜ç™ºã—ãªã„
â€” ã™ãªã‚ã¡ã€ï¼»
é©åˆã™ã‚‹ï¼å¦¥å½“ã§ã‚ã‚‹
ï¼½ã¨è¦‹ãªã•ã‚Œã‚‹ â€”
ã‚ˆã†ãªå…¥åŠ›ã‚’å®šç¾©ã™ã‚‹ã€‚
â—
A valid URL string defines what input would not trigger a validation error or failure when given to the URL parser. I.e., input that would be considered conforming or valid.
</li>
	<li>
`~URLç›´åˆ—åŒ–å™¨$ã¯ã€
~~å…¥åŠ›ã®`~URL~record$ã«å¯¾ã—ï¼Œ`~ASCIIæ–‡å­—åˆ—$ã‚’è¿”ã™ã€‚
ï¼ˆãã®æ–‡å­—åˆ—ã‚’ã•ã‚‰ã«`~URLæ§‹æ–‡è§£æå™¨$ã«ã‹ã‘ãŸçµæœã¯ã€
~~å…ƒã®`~URL~record$ã¨`åŒç­‰ãª~URL$ã«ãªã‚‹ã€‚ï¼‰
`~URLç›´åˆ—åŒ–å™¨$ã®å‡ºåŠ›ã¯ã€
å¸¸ã«`å¦¥å½“ãª~URL$sTã«ãªã‚‹ã¨ã¯é™ã‚‰ãªã„ã€‚
â—
The URL serializer takes a URL and returns an ASCII string. (If that string is then parsed, the result will equal the URL that was serialized.) The output of the URL serializer is not always a valid URL string.
</li>
</ul>

<div class="example" id="example-url-parsing" style="overflow:auto">
<table class="grid-table" id="_ex-url-validity"><thead>
<tr><th>
å…¥åŠ›~URL
â—
Input
<th>
åŸºåº•~URL
â—
Base
<th>
å¦¥å½“ã‹ï¼Ÿ
â—
Valid
<th>
å‡ºåŠ›~URL
â—
Output
<tbody>

<tr><td>`https:example.org^c
<td>
<td>âŒ
<td>`https://example.org/^c

<tr><td>`https://////example.com///^c
<td>
<td>âŒ
<td>`https://example.com///^c

<tr><td>`https://example.com/././foo^c
<td>
<td>âœ…
<td>`https://example.com/foo^c

<tr><td>`hello:world^c
<td>`https://example.com/^c
<td>âœ…
<td>`hello:world^c

<tr><td>`https:example.org^c
<td>`https://example.com/^c
<td>âŒ
<td>`https://example.com/example.org^c

<tr><td>`\example\..\demo/.\^c
<td>`https://example.com/^c
<td>âŒ
<td>`https://example.com/demo/^c

<tr><td>`example^c
<td>`https://example.com/demo^c
<td>âœ…
<td>`https://example.com/example^c

<tr><td>`file:///C|/demo^c
<td>
<td>âŒ
<td>`file:///C:/demo^c

<tr><td>`..^c
<td>`file:///C:/demo^c
<td>âœ…
<td>`file:///C:/^c

<tr><td>`file://loc%61lhost/^c
<td>
<td>âœ…
<td>`file:///^c

<tr><td>`https://user:password~atã€…example.org/^c
<td>
<td>âŒ
<td>`https://user:password~atã€…example.org/^c

<tr><td>`https://example.org/foo bar^c
<td>
<td>âŒ
<td>`https://example.org/foo%20bar^c

<tr><td>`https://EXAMPLE.com/../x^c
<td>
<td>âœ…
<td>`https://example.com/x^c

<tr><td>`https://ex ample.org/^c
<td>
<td>âŒ
<td>`å¤±æ•—^i

<tr><td>`example^c
<td>
<td title="due to lack of base">âŒâ€ 
<td>`å¤±æ•—^i

<tr><td>`https://example.com:demo^c
<td>
<td>âŒ
<td>`å¤±æ•—^i

<tr><td>`http://[www.example.com]/^c
<td>
<td>âŒ
<td>`å¤±æ•—^i

<tr><td>`https://example.org//^c
<td>
<td>âœ…
<td>`https://example.org//^c

<tr><td>`https://example.com/[]?[]#[]^c
<td>
<td>âŒ
<td>`https://example.com/[]?[]#[]^c

<tr><td>`https://example/%?%#%^c
<td>
<td>âŒ
<td>`https://example/%?%#%^c

<tr><td>`https://example/%25?%25#%25^c
<td>
<td>âœ…
<td>`https://example/%25?%25#%25^c

</table>

<p>
ç°¡æ½”ã«ã™ã‚‹ãŸã‚ã€
ã“ã“ã§ã®ï¼»
åŸºåº•ï¼å‡ºåŠ›
ï¼½`~URL$ã¯ï¼Œ`~URLç›´åˆ—åŒ–å™¨$ã«ã‹ã‘ãŸçµæœã§è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
The base and output URL are represented in serialized form for brevity.
</p>

<small>â€ 
â€” åŸºåº•~URLã‚’æ¬ ãã“ã¨ã«å› ã‚Šå¦¥å½“ã§ãªã„ã€‚
</small>
</div>

		<section id="url-representation">
<h3 title="URL representation">4.1. ~URLè¡¨ç¾</h3>

<p>
`~URL@
ã¯ã€
ä»¥ä¸‹ã«æŒ™ã’ã‚‹~itemã‹ã‚‰ãªã‚‹`æ§‹é€ ä½“$ã§ã‚ã‚Šï¼Œ
æ™®éçš„ãªè­˜åˆ¥å­ã‚’è¡¨ç¾ã™ã‚‹ã€‚
`å¦¥å½“ãª~URL$sTã¨åŒºåˆ¥ã™ã‚‹ãŸã‚ã€
`~URL~record$ã¨ã‚‚ç§°ã•ã‚Œã‚‹ï¼š
â—
A URL is a struct that represents a universal identifier. To disambiguate from a valid URL string it can also be referred to as a URL record.
</p>
<dl class="def-list">
	<dt>
`~scheme@url
â—
A URLâ€™s schemeï¼¼
</dt>
	<dd>
`~ASCIIæ–‡å­—åˆ—$
â—
is an ASCII stringï¼¼
</dd>
	<dd>
`~URL$ã®ç¨®åˆ¥ã‚’è­˜åˆ¥ã™ã‚‹
â€” `~URLæ§‹æ–‡è§£æå™¨$ã«ã‹ã‘ãŸå¾Œã®ï¼Œæ›´ãªã‚‹åˆ†å²å‡¦ç†ã«åˆ©ç”¨ã•ã‚Œå¾—ã‚‹ã€‚
â—
that identifies the type of URL and can be used to dispatch a URL for further processing after parsing.ï¼¼
</dd>
	<dd>
åˆæœŸ~æ™‚ã¯ç©º~æ–‡å­—åˆ—ã¨ã™ã‚‹ã€‚
â—
It is initially the empty string.
</dd>

	<dt>
`~username@url
â—
A URLâ€™s usernameï¼¼
</dt>
	<dd>
`~ASCIIæ–‡å­—åˆ—$
â—
is an ASCII stringï¼¼
</dd>
	<dd>
~usernameã‚’è­˜åˆ¥ã™ã‚‹ã€‚
â—
identifying a username.ï¼¼
</dd>
	<dd>
åˆæœŸ~æ™‚ã¯ç©º~æ–‡å­—åˆ—ã¨ã™ã‚‹ã€‚
â—
It is initially the empty string.
</dd>

	<dt>
`~password@url
â—
A URLâ€™s passwordï¼¼
</dt>
	<dd>
`~ASCIIæ–‡å­—åˆ—$
â—
is an ASCII stringï¼¼
</dd>
	<dd>
~passwordã‚’è­˜åˆ¥ã™ã‚‹ã€‚
â—
identifying a password.ï¼¼
</dd>
	<dd>
åˆæœŸ~æ™‚ã¯ç©º~æ–‡å­—åˆ—ã¨ã™ã‚‹ã€‚
â—
It is initially the empty string.
</dd>

	<dt>
`~host@url
â—
A URLâ€™s hostï¼¼
</dt>
	<dd>
~NULL ï¼
`~host$
â—
is null or a host.ï¼¼
</dd>
	<dd>
åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
It is initially null.
</dd>
	<dd class="note">
<p>æ³¨è¨˜ï¼š
`~URL$ã«è¨±å®¹ã•ã‚Œã‚‹ï¼»
`~scheme$url, `~host$url
ï¼½ã®çµ„åˆnã‚’æ¬¡ã®è¡¨tã«æŒ™ã’ã‚‹ã€‚
</p>

<table><thead>
<tr><th rowspan="2">`~scheme$url
<th colspan="6">`~host$url
<tr id="_combi-host-types">
<th>`~domain$
<th>`~IPv4~address$
<th>`~IPv6~address$
<th>`ä¸é€æ˜ãª~host$
<th>`ç©º~host$
<th>~NULL
<tbody>

<tr><td>`file^l ä»¥å¤–ã®`ç‰¹åˆ¥~scheme$
<td>âœ… <td>âœ… <td>âœ… <td>âŒ <td>âŒ <td>âŒ

<tr><td>`file^l
<td>âœ… <td>âœ… <td>âœ… <td>âŒ <td>âœ… <td>âŒ

<tr><td>ãã®ä»–
<td>âŒ <td>âŒ <td>âœ… <td>âœ… <td>âœ… <td>âœ…
</table>

â—
The following table lists allowed URLâ€™s scheme / host combinations.
â—
schemeï½œhost
ï½œdomainï½œIPv4 addressï½œIPv6 addressï½œopaque hostï½œempty hostï½œnull
Special schemes excluding "file"ï½œâœ…ï½œâœ…ï½œâœ…ï½œâŒï½œâŒï½œâŒ
"file"ï½œâœ…ï½œâœ…ï½œâœ…ï½œâŒï½œâœ…ï½œâŒ
Othersï½œâŒï½œâŒï½œâœ…ï½œâœ…ï½œâœ…ï½œâœ…
</dd>

	<dt>
`~port@url
â—
A URLâ€™s portï¼¼
</dt>
	<dd>
~NULL ï¼
`16 ~bitãªç„¡ç¬¦å·~æ•´æ•°$
â—
is either null or a 16-bit unsigned integerï¼¼
</dd>
	<dd>
~NULL ä»¥å¤–ã¯ã€
~networkç”¨ã®~portã‚’è­˜åˆ¥ã™ã‚‹ã€‚
â—
that identifies a networking port.ï¼¼
</dd>
	<dd>
åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
It is initially null.
</dd>

	<dt>
`~path@url
â—
A URLâ€™s pathï¼¼
</dt>
	<dd>
`~URL~path$
â—
is a URL path,ï¼¼
</dd>
	<dd>
é€šä¾‹çš„ã«ã¯ã€
è³‡æºã®æ‰€åœ¨ã‚’è­˜åˆ¥ã™ã‚‹ã€‚
â—
usually identifying a location.ï¼¼
</dd>
	<dd>
åˆæœŸ~æ™‚ã¯ Â« Â» ã¨ã™ã‚‹ã€‚
â—
It is initially Â« Â».
</dd>
	<dd class="note">æ³¨è¨˜ï¼š
`~URL$ãŒ`ç‰¹åˆ¥$ã§ã‚ã‚‹å ´åˆã€
ãã®`~path$urlã¯å¸¸ã«`~list$ã«ãªã‚Šï¼Œ
`ä¸é€æ˜ãª~path$ã‚’æœ‰ã™ã‚‹ã“ã¨ã¯æ±ºã—ã¦ãªã„ã€‚
â—
A special URLâ€™s path is always a list, i.e., it is never opaque.
</dd>

	<dt>
`~query@url
â—
A URLâ€™s queryï¼¼
</dt>
	<dd>
~NULL ï¼
`~ASCIIæ–‡å­—åˆ—$
â—
is either null or an ASCII string.ï¼¼
</dd>
	<dd>
åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
It is initially null.
</dd>

	<dt>
`ç´ ç‰‡@url
â—
A URLâ€™s fragmentï¼¼
</dt>
	<dd>
~NULL ï¼
`~ASCIIæ–‡å­—åˆ—$
â—
is either null or an ASCII stringï¼¼
</dd>
	<dd>
~NULL ä»¥å¤–ã¯ã€ï¼»
`~URL$ã‚’æˆã™ä»–ã®æˆåˆ†ã«ã‚ˆã‚Šè­˜åˆ¥ã•ã‚Œã‚‹è³‡æº
ï¼½ã‚’æ›´ã«å‡¦ç†ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œå¾—ã‚‹ã€‚
â—
that can be used for further processing on the resource the URLâ€™s other components identify.ï¼¼
</dd>
	<dd>
åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
It is initially null.
</dd>
</dl>

<p>
å„`~URL$ã«ã¯ã€
`~blob~URL~entry@url
ã‚‚çµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
ãã‚Œã¯ã€ï¼»
~NULL ï¼`~blob~URL~entry$
ï¼½ã§ã‚ã‚Šï¼ŒåˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
A URL also has an associated blob URL entry that is either null or a blob URL entry. It is initially null.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€ï¼»
`blob^l ~URLãŒæŒ‡ã—ã¦ã„ã‚‹~objã‚’ ãã®ç”Ÿæˆå…ƒã¨ã¨ã‚‚ã«~cacheã™ã‚‹
ï¼½ã“ã¨ã‚’~supportã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
ã“ã‚Œã‚‰ã‚’~cacheã™ã‚‹ã“ã¨ã¯ã€
é‡è¦ã«ãªã‚‹
â€” ãã®ã‚ˆã†ãª`~URL$ã¯ã€
æ§‹æ–‡è§£æã—ã¦ã‹ã‚‰~fetchã™ã‚‹ã¾ã§ã®é–“ã« `~blob~URL~store$ã‹ã‚‰é™¤å»ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ä¸€æ–¹ã§ï¼Œ
~fetchingã¯æˆåŠŸã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ã€‚
â—
This is used to support caching the object a "blob" URL refers to as well as its origin. It is important that these are cached as the URL might be removed from the blob URL store between parsing and fetching, while fetching will still need to succeed.
</p>

<div class="example">

<p>
`å¦¥å½“ãª~URL$sTã‚’`~URLæ§‹æ–‡è§£æå™¨$ã«ã‹ã‘ãŸçµæœãŒ`~URL~record$ã®å„~æˆåˆ†ã«ã©ã†å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã‚‹ã‹ã‚’ï¼Œæ¬¡ã®è¡¨tã«æŒ™ã’ã‚‹ã€‚
ã“ã®è¡¨tã‹ã‚‰çœç•¥ã•ã‚ŒãŸï¼»
`~username$urlï¼
`~password$urlï¼
`~blob~URL~entry$url
ï¼½ã¯ã€
ã“ã®ä¾‹ã§ã¯ï¼Œã©ã‚Œã‚‚ï¼»
ç©º~æ–‡å­—åˆ—ï¼ç©º~æ–‡å­—åˆ—ï¼~NULL
ï¼½ã«ãªã‚‹ã€‚
â—
The following table lists how valid URL strings, when parsed, map to a URLâ€™s components. Username, password, and blob URL entry are omitted; in the examples below they are the empty string, the empty string, and null, respectively.
</p>

<div style="overflow:auto;">
<table class="grid-table" id="_ex-url-components"><thead>
<tr><th>å…¥åŠ›
<th>`~scheme$url
<th>`~host$url
<th>`~port$url
<th>`~path$url
<th>`~query$url
<th>`ç´ ç‰‡$url
<tbody>

<tr><td>`https://example.com/^c
<td>`https^l
<td>`example.com^l
<td>~NULL
<td>Â« ç©º~æ–‡å­—åˆ— Â»
<td>~NULL
<td>~NULL

<tr><td>`https://localhost:8000/search?q=text#hello^c
<td>`https^l
<td>`localhost^l
<td>8000
<td>Â« `search^l Â»
<td>`q=text^l
<td>`hello^l

<tr><td>`urn:isbn:9780307476463^c
<td>`urn^l
<td>~NULL
<td>~NULL
<td>`isbn:9780307476463^l
<td>~NULL
<td>~NULL

<tr><td>`file:///ada/Analytical%20Engine/README.md^c
<td>`file^l
<td>~NULL
<td>~NULL
<td>Â« `ada^l, `Analytical%20Engine^l, `README.md^l Â»
<td>~NULL
<td>~NULL
</table>

â—
â€¢ Inputï½œSchemeï½œHostï½œPortï½œPathï½œQueryï½œFragment
â€¢ https://example.com/ï½œ"https"ï½œ"example.com"ï½œnullï½œÂ« the empty string Â»ï½œnullï½œnull
â€¢ https://localhost:8000/search?q=text#helloï½œ"https"ï½œ"localhost"ï½œ8000ï½œÂ« "search" Â»ï½œ"q=text"ï½œ"hello"
â€¢ urn:isbn:9780307476463ï½œ"urn"ï½œnullï½œnullï½œ"isbn:9780307476463"ï½œnullï½œnull
â€¢ file:///ada/Analytical%20Engine/README.mdï½œ"file"ï½œnullï½œnullï½œÂ« "ada", "Analytical%20Engine", "README.md" Â»ï½œnullï½œnull
</div>
</div>

<p>
`~URL~path@
ã¯ã€
æ¬¡ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹
â‡’ï¼ƒ
`~URL~pathåŒºåˆ†$ ï¼
`~URL~pathåŒºåˆ†$ãŸã¡ãŒæˆã™`~list$
â—
A URL path is either a URL path segment or a list of zero or more URL path segments.
</p>

<p>
`~URL~pathåŒºåˆ†@
ã¯ã€
`~ASCIIæ–‡å­—åˆ—$ã§ã‚ã‚‹ã€‚
ãã‚Œã¯ã€
ã‚ã‚‹ï¼»
~directoryï¼~file
ï¼½ã‚’æŒ‡ã™ã“ã¨ãŒå¤šã„ãŒï¼Œå®šç¾©æ¸ˆã¿ãªæ„å‘³ã¯ç„¡ã„ã€‚
â—
A URL path segment is an ASCII string. It commonly refers to a directory or a file, but has no predefined meaning.
</p>

<p>
`å˜-~dot~URL~pathåŒºåˆ†@
ã¯ã€
æ¬¡ã‚’æº€ãŸã™`~URL~pathåŒºåˆ†$ã§ã‚ã‚‹
â‡’
`~ASCIIå¤§å°ç„¡è¦–$ã§ï¼»
`.^l ï¼ `%2e^l
ï¼½ã«åˆè‡´ã™ã‚‹
â—
A single-dot URL path segment is a URL path segment that is "." or an ASCII case-insensitive match for "%2e".
</p>

<p>
`äºŒé‡-~dot~URL~pathåŒºåˆ†@
ã¯ã€
æ¬¡ã‚’æº€ãŸã™`~URL~pathåŒºåˆ†$ã§ã‚ã‚‹
â‡’
`~ASCIIå¤§å°ç„¡è¦–$ã§ï¼»
`..^l ï¼ `.%2e^l ï¼ `%2e.^l ï¼ `%2e%2e^l
ï¼½ã«åˆè‡´ã™ã‚‹
â—
A double-dot URL path segment is a URL path segment that is ".." or an ASCII case-insensitive match for ".%2e", "%2e.", or "%2e%2e".
</p>

		</section>
		<section id="url-miscellaneous">
<h3 title="URL miscellaneous">4.2. ~URLã®ãã®ä»–è«¸ã€…</h3>

<p>
`ç‰¹åˆ¥~scheme@
ã¨ã¯ã€
æ¬¡ã®è¡¨tã® 1 åˆ—ç›®ã«æŒ™ã’ã‚‰ã‚Œã‚‹`~ASCIIæ–‡å­—åˆ—$ã§ã‚ã‚‹ã€‚
å„`ç‰¹åˆ¥~scheme$ç”¨ã®
`æ—¢å®š~port@
ã¯ã€
è¡¨tã®åŒã˜è¡Œã® 2 åˆ—ç›®ã«æŒ™ã’ã‚‰ã‚Œã‚‹
â€” ä»–ã®`~ASCIIæ–‡å­—åˆ—$ç”¨ã®`æ—¢å®š~port$ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
A special scheme is an ASCII string that is listed in the first column of the following table. The default port for a special scheme is listed in the second column on the same row. The default port for any other ASCII string is null. 
</p>

<table><thead>
<tr><th>`ç‰¹åˆ¥~scheme$
<th>`æ—¢å®š~port$
<tbody>

<tr><td>`ftp^l
<td>21

<tr><td>`file^l
<td>~NULL

<tr><td>`http^l
<td>80

<tr><td>`https^l
<td>443

<tr><td>`ws^l
<td>80

<tr><td>`wss^l
<td>443
</table>

<p>
æ‰€ä¸ã®`~URL$ãŒ
`ç‰¹åˆ¥@
ã§ã‚ã‚‹ã¨ã¯ã€
ãã®`~scheme$urlã¯`ç‰¹åˆ¥~scheme$ã§ã‚ã‚‹ã“ã¨ã‚’ã„ã†ã€‚
â—
A URL is special if its scheme is a special scheme. A URL is not special if its scheme is not a special scheme.
</p>

<p class="trans-note">ã€
åŸæ–‡ã§ã¯ï¼Œä¸€ä½“å¥ã¨ã—ã¦ã®
`ç‰¹åˆ¥ã§ãªã„ï¼ #is-not-special@
ãŒ â€œ`ç‰¹åˆ¥$ã§ã‚ã‚‹â€ ã®å¦å®šã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŒã€
ã“ã®è¨³ã§ã¯åˆ©ç”¨ã—ãªã„
ï¼ˆå˜ã« â€œ`ç‰¹åˆ¥$<em>ã§ãªã„</em>â€ ã¨è¨˜ã™ã“ã¨ã«ã™ã‚‹ï¼‰ã€‚
ã€‘</p>

<p>
`~URL$ãŒ
`è³‡æ ¼è¨¼ã‚’å«ã‚“ã§@
ã„ã‚‹ã¨ã¯ã€
æ¬¡ã‚’æº€ãŸã™ã“ã¨ã‚’ã„ã†
â‡’
ï¼»
ãã®`~username$url ~NEQ ç©º~æ–‡å­—åˆ—
ï¼½~ORï¼»
ãã®`~password$url ~NEQ ç©º~æ–‡å­—åˆ—
ï¼½
â—
A URL includes credentials if its username or password is not the empty string.
</p>

<p class="trans-note">ã€ï¼ˆå‚è€ƒï¼‰
~HTTPä»•æ§˜ã®
<a href="~HTTPinfra#http.userinfo">Â§ `userinfo^P ã®éæ¨å¥¨åŒ–</a>
ã«~securityã«é–¢ã™ã‚‹è¨˜è¿°ãŒã‚ã‚‹ã€‚
ã€‘</p>

<p>
`~URL$ãŒ
`ä¸é€æ˜ãª~path@
ã‚’æœ‰ã™ã‚‹ã¨ã¯ã€
æ¬¡ã‚’æº€ãŸã™ã“ã¨ã‚’ã„ã†
â‡’
ãã®`~path$urlã¯`~URL~pathåŒºåˆ†$ã§ã‚ã‚‹ã€~listã§ãªã„ã€‘
â—
A URL has an opaque path if its path is a URL path segment.
</p>

<p>
`~URL$ãŒ
`~usernameï¼~passwordï¼~portã‚’æœ‰ã—å¾—ãªã„@
ã¨ã¯ã€
æ¬¡ã‚’æº€ãŸã™ã“ã¨ã‚’ã„ã†
â‡’
ï¼»
ãã®`~host$url ~IN { ~NULL, ç©º~æ–‡å­—åˆ— }
ï¼½~ORï¼»
ãã®`~scheme$url ~EQ `file^l
ï¼½
â—
A URL cannot have a username/password/port if its host is null or the empty string, or its scheme is "file".
</p>

<p>
`~URL$ã¯
`åŸºåº•~URL@
ã§ã‚ã‚‹ã‚‚ã®ã¨æŒ‡åã•ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚‹ã€‚
â—
A URL can be designated as base URL.
</p>

<p class="note">æ³¨è¨˜ï¼š
`åŸºåº•~URL$ã¯ã€
`~URLæ§‹æ–‡è§£æå™¨$ã«ãŠã„ã¦ï¼Œ`ç›¸å¯¾~URL$sTã‚‚å…¥åŠ›ã«ã¨ã‚Šå¾—ã‚‹ã¨ãã«æœ‰ç”¨ã«ãªã‚‹ã€‚
â—
A base URL is useful for the URL parser when the input might be a relative-URL string.
</p>

<hr>

<p>
`~drive_letter@
ã¨ã¯ã€
æ¬¡ã‚’æº€ãŸã™ 2 å€‹ã®~cpãŒæˆã™ä¸¦ã³ã§ã‚ã‚‹
â‡’
ï¼»
1 å€‹ç›®ã®~cp ~IN `~ASCIIè‹±å­—$
ï¼½~ANDï¼»
2 å€‹ç›®ã®~cp ~IN { â:, â| }
ï¼½
â—
A Windows drive letter is two code points, of which the first is an ASCII alpha and the second is either U+003A (:) or U+007C (|).
</p>

<p>
`æ­£è¦åŒ–-æ¸ˆã¿~drive_letter@
ã¨ã¯ã€
`~drive_letter$ã®ã†ã¡ï¼Œæ¬¡ã‚’æº€ãŸã™ã‚‚ã®ã§ã‚ã‚‹
â‡’
2 å€‹ç›®ã®~cp ~EQ â:
â—
A normalized Windows drive letter is a Windows drive letter of which the second code point is U+003A (:).
</p>

<p class="note">æ³¨è¨˜ï¼š
`Â§ ~URLã®æ›¸å‡ºæ³•ï¼ #url-writing$ã«ã‚ˆã‚Šã€
é©åˆã™ã‚‹ã‚‚ã®ã¯`æ­£è¦åŒ–-æ¸ˆã¿~drive_letter$ã«é™ã‚‰ã‚Œã‚‹ã€‚
â—
As per the URL writing section, only a normalized Windows drive letter is conforming.
</p>

<p>
3 å€‹ã®ï¼»
~cp ï¼ `EOF$i
ï¼½ãŸã¡ãŒæˆã™ä¸¦ã³ï¼»
%C0, %C1, %C2
ï¼½ãŒ
`~drive_letterã‹ã‚‰é–‹å§‹ã—ã¦@
ã„ã‚‹ã¨ã¯ã€
~ANDâ†“ ã‚’æº€ãŸã™ã“ã¨ã‚’ã„ã†ï¼š
â—
A string starts with a Windows drive letter if all of the following are true:
</p>
<ul>
	<li>
ä¸¦ã³ï¼»
%C0, %C1
ï¼½ã¯`~drive_letter$ã§ã‚ã‚‹ï¼ˆç‰¹ã«ï¼Œã„ãšã‚Œã‚‚ `EOF$i ã§ãªã„ï¼‰
â—
its length is greater than or equal to 2
â—
its first two code points are a Windows drive letter
</li>
	<li>
%C2 ~IN { `EOF$i, â/, â\, â?, â# }
â—
its length is 2 or its third code point is U+002F (/), U+005C (\), U+003F (?), or U+0023 (#).
</li>
</ul>

<div class="example">
<table><tbody>
<tr><th>ä¸¦ã³ãŒæˆã™æ–‡å­—åˆ—
<th>~drive_letterã‹ã‚‰é–‹å§‹ã—ã¦ã„ã‚‹ã‹ï¼Ÿ

<tr><td>`c:^l
<td>âœ…

<tr><td>`c:/^l
<td>âœ…

<tr><td>`c:a^l
<td>âŒ
</table>
â—
Stringï½œStarts with a Windows drive letter
"c:"ï½œâœ…
"c:/"ï½œâœ…
"c:a"ï½œâŒ
</div>

<div class="algo">
<p>
%~URL ã®
`~pathã‚’çŸ­ç¸®ã™ã‚‹@
~algoã¯ï¼š
â—
To shorten a urlâ€™s path:
</p>
<ol>
	<li>
~Assertï¼š
%~URL ã¯`ä¸é€æ˜ãª~path$ã‚’æœ‰ã•ãªã„ã€‚
â—
Assert: url does not have an opaque path.
</li>
	<li>
%~path ~LET %~URL ã®`~path$url
â—
Let path be urlâ€™s path.
</li>
	<li>
~IFï¼»
%~URL ã®`~scheme$url ~EQ `file^l
ï¼½~ANDï¼»
%~path ã®`~size$ ~EQ 1
ï¼½~ANDï¼»
%~path[ 0 ] ã¯`æ­£è¦åŒ–-æ¸ˆã¿~drive_letter$ã§ã‚ã‚‹
ï¼½
â‡’
~RET
â—
If urlâ€™s scheme is "file", pathâ€™s size is 1, and path[0] is a normalized Windows drive letter, then return.
</li>
	<li>
~IFï¼»
%~path ã¯`ç©º$ã§ãªã„
ï¼½
â‡’
%~path ã‹ã‚‰æœ€å¾Œã®~itemã‚’`é™¤å»ã™ã‚‹$
â—
Remove pathâ€™s last item, if any.
</li>
</ol>
</div>

		</section>
		<section id="url-writing">
<h3 title="URL writing">4.3. ~URLã®æ›¸å‡ºæ³•</h3>

<p>
ä»¥ä¸‹ã«ãŠã„ã¦ï¼Œâ€œçœç•¥å¯èƒ½â€ ã¨è¨˜ã•ã‚ŒãŸéƒ¨åˆ†ã¯çœç•¥ã§ãã‚‹ï¼ã•ã‚Œå¾—ã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ï¼ˆã™ãªã‚ã¡ï¼Œ 0 å€‹, ã¾ãŸã¯ 1 å€‹ï¼‰ã€‚
â—
â†“</p>

<div>
<p>
`å¦¥å½“ãª~URL@sT
ã¯ã€
æ¬¡ã®ã„ãšã‚Œã‹ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A valid URL string must be eitherï¼¼
</p>
<ul>
	<li>
`ç´ ç‰‡~ä»˜ãç›¸å¯¾~URL$sT
â—
a relative-URL-with-fragment stringï¼¼
</li>
	<li>
`ç´ ç‰‡~ä»˜ãçµ¶å¯¾~URL$sT
â—
or an absolute-URL-with-fragment string.
</li>
</ul>
</div>

<div>
<p>
`ç´ ç‰‡~ä»˜ãçµ¶å¯¾~URL@sT
ã¯ã€
æ¬¡ã®ä¸¦ã³ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
An absolute-URL-with-fragment string must beï¼¼
</p>
<ol>
	<li>
`çµ¶å¯¾~URL$sT
â—
an absolute-URL string,ï¼¼
</li>
	<li>
<p>
çœç•¥å¯èƒ½ãªï¼Œæ¬¡ã®ä¸¦ã³ï¼š
</p>
		<ol>
			<li>
â#
</li>
			<li>
`~URLç´ ç‰‡$sT
</li>
		</ol>
â—
optionally followed by U+0023 (#) and a URL-fragment string.
</li>
</ol>
</div>

<div>
<p>
`çµ¶å¯¾~URL@sT
ã¯ã€
æ¬¡ã®ä¸¦ã³ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
An absolute-URL string must beï¼¼
</p>
<ol>
	<li>
<p>
æ¬¡ã®ã„ãšã‚Œã‹ï¼š
â—
one of the following:
</p>
		<ul>
			<li>
<p>
æ¬¡ã®ä¸¦ã³ï¼š
â—
â†“</p>
				<ol>
					<li>
`~URL~scheme$sTã§ã‚ã£ã¦ï¼Œï¼»
`file^l ä»¥å¤–ã®`ç‰¹åˆ¥~scheme$
ï¼½ã«`~ASCIIå¤§å°ç„¡è¦–$ã§åˆè‡´ã™ã‚‹ã‚‚ã®
â—
a URL-scheme string that is an ASCII case-insensitive match for a special scheme and not an ASCII case-insensitive match for "file",ï¼¼
</li>
					<li>
â:
â—
followed by U+003A (:)ï¼¼
</li>
					<li>
`~schemeç›¸å¯¾~ç‰¹åˆ¥~URL$sT
â—
and a scheme-relative-special-URL string
</li>
				</ol>
			</li>
			<li>
<p>
æ¬¡ã®ä¸¦ã³ï¼š
â—
â†“</p>
				<ol>
					<li>
`~URL~scheme$sTã§ã‚ã£ã¦ï¼Œ`ç‰¹åˆ¥~scheme$ã«`~ASCIIå¤§å°ç„¡è¦–$ã§<em>åˆè‡´ã—ãªã„</em>ã‚‚ã®
â—
a URL-scheme string that is not an ASCII case-insensitive match for a special scheme,ï¼¼
</li>
					<li>
â:
â—
followed by U+003A (:)ï¼¼
</li>
					<li>
`ç›¸å¯¾~URL$sT
â—
and a relative-URL string
</li>
				</ol>
			</li>
			<li>
<p>
æ¬¡ã®ä¸¦ã³ï¼š
â—
â†“</p>
				<ol>
					<li>
`~URL~scheme$sTã§ã‚ã£ã¦ï¼Œ `file^l ã«`~ASCIIå¤§å°ç„¡è¦–$ã§åˆè‡´ã™ã‚‹ã‚‚ã®
â—
a URL-scheme string that is an ASCII case-insensitive match for "file",ï¼¼
</li>
					<li>
â:
â—
followed by U+003A (:)ï¼¼
</li>
					<li>
`~schemeç›¸å¯¾~file~URL$sT
â—
and a scheme-relative-file-URL string
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
<p>
çœç•¥å¯èƒ½ãªï¼Œæ¬¡ã®ä¸¦ã³ï¼š
â—
any optionally followed byï¼¼
</p>
		<ol>
			<li>
â?
â—
U+003F (?)ï¼¼
</li>
			<li>
`~URL~query$sT
â—
and a URL-query string.
</li>
		</ol>
	</li>
</ol>
</div>

<div>
<p>
`~URL~scheme@sT
ã¯ã€
æ¬¡ã®ä¸¦ã³ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A URL-scheme string must beï¼¼
</p>
<ol>
	<li>
1 å€‹ã®`~ASCIIè‹±å­—$
â—
one ASCII alpha,ï¼¼
</li>
	<li>
0 å€‹ä»¥ä¸Šã®æ¬¡ã«æŒ™ã’ã‚‹~cpãŸã¡ãŒæˆã™ä¸¦ã³
â‡’ï¼ƒ
`~ASCIIè‹±æ•°å­—$,
â+,
â-,
â.
â—
followed by zero or more of ASCII alphanumeric, U+002B (+), U+002D (-), and U+002E (.).ï¼¼
</li>
</ol>

<p>
`~URL~scheme$sT
ã¯ã€
`IANA URI [sic] Schemes^cite ~registryã«ç™»éŒ²ã•ã‚Œã‚‹ãƒ™ã‚­ã§ã‚ã‚‹ã€‚
`IANA-URI-SCHEMES$r
`RFC7595$r
â—
Schemes should be registered in the IANA URI [sic] Schemes registry. [IANA-URI-SCHEMES] [RFC7595]
</p>
</div>

<div>
<p>
`ç´ ç‰‡~ä»˜ãç›¸å¯¾~URL@sT
ã¯ã€
æ¬¡ã®ä¸¦ã³ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A relative-URL-with-fragment string must beï¼¼
</p>
<ol>
	<li>
`ç›¸å¯¾~URL$sT
â—
a relative-URL string,ï¼¼
</li>
	<li>
<p>
çœç•¥å¯èƒ½ãªï¼Œæ¬¡ã®ä¸¦ã³ï¼š
â—
optionally followed byï¼¼
</p>
		<ol>
			<li>
â#
â—
U+0023 (#)ï¼¼
</li>
			<li>
`~URLç´ ç‰‡$sT
â—
and a URL-fragment string.
</li>
		</ol>
	</li>
</ol>
</div>

<div>
<p>
`ç›¸å¯¾~URL@sT
ã¯ã€
æ¬¡ã®ä¸¦ã³ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A relative-URL string must be one of the following,ï¼¼
</p>
<ol>
	<li>
<p>
`åŸºåº•~URL$ã®`~scheme$urlã«å¿œã˜ã¦ï¼š
â—
switching on base URLâ€™s scheme:
</p>
		<ul class="switch">
			<li>
<p>
`file^l ä»¥å¤–ã®`ç‰¹åˆ¥~scheme$ãªã‚‰ã°ï¼Œæ¬¡ã®ã„ãšã‚Œã‹ï¼š
â—
A special scheme that is not "file"
</p>
				<ul>
					<li>
`~schemeç›¸å¯¾~ç‰¹åˆ¥~URL$sT
â—
a scheme-relative-special-URL string
</li>
					<li>
`~pathçµ¶å¯¾~URL$sT
â—
a path-absolute-URL string
</li>
					<li>
`~pathç›¸å¯¾ ~schemeãªã—~URL$sT
â—
a path-relative-scheme-less-URL string
</li>
				</ul>
			</li>
			<li>
<p>
`file^l ãªã‚‰ã°ï¼Œæ¬¡ã®ã„ãšã‚Œã‹ï¼š
â—
"file"
</p>
				<ul>
					<li>
`~schemeç›¸å¯¾~file~URL$sT
â—
a scheme-relative-file-URL string
</li>
					<li>
`~pathçµ¶å¯¾~URL$sT
â€” ãŸã ã—ã€ï¼»
`åŸºåº•~URL$ã®`~host$urlã¯`ç©º~host$ã§ã‚ã‚‹
ï¼½å ´åˆã«é™ã‚‹
â—
a path-absolute-URL string if base URLâ€™s host is an empty host
</li>
					<li>
`~pathçµ¶å¯¾ é Windows file ~URL$sT
â€” ãŸã ã—ã€ï¼»
`åŸºåº•~URL$ã®`~host$urlã¯`ç©º~host$ã§ãªã„
ï¼½å ´åˆã«é™ã‚‹
â—
a path-absolute-non-Windows-file-URL string if base URLâ€™s host is not an empty host
</li>
					<li>
`~pathç›¸å¯¾ ~schemeãªã—~URL$sT
â—
a path-relative-scheme-less-URL string
</li>
				</ul>
			</li>
			<li>
<p>
ä»–ã®å ´åˆï¼Œæ¬¡ã®ã„ãšã‚Œã‹ï¼š
â—
Otherwise
</p>
				<ul>
					<li>
`~schemeç›¸å¯¾~URL$sT
â—
a scheme-relative-URL string
</li>
					<li>
`~pathçµ¶å¯¾~URL$sT
â—
a path-absolute-URL string
</li>
					<li>
`~pathç›¸å¯¾ ~schemeãªã—~URL$sT
â—
a path-relative-scheme-less-URL string
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
<p>
çœç•¥å¯èƒ½ãªï¼Œæ¬¡ã®ä¸¦ã³ï¼š
â—
any optionally followed byï¼¼
</p>
		<ol>
			<li>
â?
â—
U+003F (?)ï¼¼
</li>
			<li>
`~URL~query$sT
â—
and a URL-query string.
</li>
		</ol>
	</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
`ç›¸å¯¾~URL$sTã‚’`~URLæ§‹æ–‡è§£æå™¨$ã«ã‹ã‘ã‚‹ã¨ãã¯ã€
`åŸºåº•~URL$ã« ~NULL ä»¥å¤–ã‚’ä¸ãˆã‚‹ã“ã¨ãŒå¿…è¦yã§ã‚ã‚‹ã€‚
â—
A non-null base URL is necessary when parsing a relative-URL string.
</p>
</div>

<div>
<p>
`~schemeç›¸å¯¾~ç‰¹åˆ¥~URL@sT
ã¯ã€
æ¬¡ã®ä¸¦ã³ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A scheme-relative-special-URL string must beï¼¼
</p>
<ol>
	<li>
`//^l
â—
"//",ï¼¼
</li>
	<li>
`å¦¥å½“ãª~host$sT
â—
followed by a valid host string,ï¼¼
</li>
	<li>
<p>
çœç•¥å¯èƒ½ãªï¼Œæ¬¡ã®ä¸¦ã³ï¼š
â—
optionally followed byï¼¼
</p>
		<ol>
			<li>
â:
â—
U+003A (:)ï¼¼
</li>
			<li>
`~URL~port$sT
â—
and a URL-port string,ï¼¼
</li>
		</ol>
	</li>
	<li>
çœç•¥å¯èƒ½ãªï¼Œ`~pathçµ¶å¯¾~URL$sT
â—
optionally followed by a path-absolute-URL string.
</li>
</ol>
</div>

<div>
<p>
`~URL~port@sT
ã¯ã€
æ¬¡ã®ã„ãšã‚Œã‹ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A URL-port string must be one of the following:
</p>
<ul>
	<li>
ç©º~æ–‡å­—åˆ—
â—
the empty string
</li>
	<li>
1 å€‹ä»¥ä¸Šã®`~ASCIIæ•°å­—$ãŸã¡ãŒæˆã™ä¸¦ã³ã§ã‚ã£ã¦ï¼Œ
10 é€²æ•°ã§ `16 ~bitãªç„¡ç¬¦å·~æ•´æ•°$ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹ã‚‚ã®
â—
one or more ASCII digits representing a decimal number that is a 16-bit unsigned integer.
</li>
</ul>
</div>

<div>
<p>
`~schemeç›¸å¯¾~URL@sT
ã¯ã€
æ¬¡ã®ä¸¦ã³ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A scheme-relative-URL string must beï¼¼
</p>
<ol>
	<li>
`//^l
â—
"//",ï¼¼
</li>
	<li>
`ä¸é€æ˜ãª~hostï¼†~port$sT
â—
followed by an opaque-host-and-port string,ï¼¼
</li>
	<li>
çœç•¥å¯èƒ½ãªï¼Œ`~pathçµ¶å¯¾~URL$sT
â—
optionally followed by a path-absolute-URL string.
</li>
</ol>
</div>

<div>
<p>
`ä¸é€æ˜ãª~hostï¼†~port@sT
ã¯ã€
æ¬¡ã®ã„ãšã‚Œã‹ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
An opaque-host-and-port string must be eitherï¼¼
</p>
<ul>
	<li>
ç©º~æ–‡å­—åˆ—
â—
the empty stringï¼¼
</li>
	<li>
<p>
æ¬¡ã®ä¸¦ã³ï¼š
â—
or:ï¼¼
</p>
		<ol>
			<li>
`å¦¥å½“ãªä¸é€æ˜ãª~host$sT
â—
a valid opaque-host string,ï¼¼
</li>
			<li>
<p>
çœç•¥å¯èƒ½ãªï¼Œæ¬¡ã®ä¸¦ã³ï¼š
â—
optionally followed byï¼¼
</p>
				<ol>
					<li>
â:
â—
U+003A (:)ï¼¼
</li>
					<li>
`~URL~port$sT
â—
and a URL-port string.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ul>
</div>

<div>
<p>
`~schemeç›¸å¯¾~file~URL@sT
ã¯ã€
æ¬¡ã®ä¸¦ã³ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A scheme-relative-file-URL string must beï¼¼
</p>
<ol>
	<li>
`//^l
â—
"//", followed byï¼¼
</li>
	<li>
<p>
æ¬¡ã®ã„ãšã‚Œã‹ï¼š
â—
one of the following:
</p>
		<ul>
			<li>
<p>
æ¬¡ã®ä¸¦ã³ï¼š
</p>
				<ol>
					<li>
`å¦¥å½“ãª~host$sT
</li>
					<li>
çœç•¥å¯èƒ½ãªï¼Œ`~pathçµ¶å¯¾ é Windows file ~URL$sT
</li>
				</ol>
â—
a valid host string, optionally followed by a path-absolute-non-Windows-file-URL string
</li>
			<li>
`~pathçµ¶å¯¾~URL$sT
â—
a path-absolute-URL string.
</li>
		</ul>
	</li>
</ol>
</div>

<div>
<p>
`~pathçµ¶å¯¾~URL@sT
ã¯ã€
æ¬¡ã®ä¸¦ã³ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A path-absolute-URL string must beï¼¼
</p>
<ol>
	<li>
â/
â—
U+002F (/)ï¼¼
</li>
	<li>
`~pathç›¸å¯¾~URL$sT
â—
followed by a path-relative-URL string.
</li>
</ol>
</div>

<div>
<p>
`~pathçµ¶å¯¾ é Windows file ~URL@sT
ã¯ã€
~ANDâ†“ ã‚’æº€ãŸã™æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A path-absolute-non-Windows-file-URL string must beï¼¼
</p>
<ul>
	<li>
`~pathçµ¶å¯¾~URL$sTã§ã‚ã‚‹
â—
a path-absolute-URL stringï¼¼
</li>
	<li>
<p>
æ¬¡ã®ä¸¦ã³ã‹ã‚‰é–‹å§‹ã—ã¦ã„ãªã„ï¼š
â—
that does not start with:ï¼¼
</p>
		<ol>
			<li>
â/
â—
U+002F (/),ï¼¼
</li>
			<li>
`~drive_letter$
â—
followed by a Windows drive letter,ï¼¼
</li>
			<li>
â/
â—
followed by U+002F (/).
</li>
		</ol>
	</li>
</ul>
</div>

<div>
<p>
`~pathç›¸å¯¾~URL@sT
ã¯ã€
~ANDâ†“ ã‚’æº€ãŸã™æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A path-relative-URL string must beï¼¼
</p>
<ul>
	<li>
â/ ã§åˆ†é›¢ã•ã‚ŒãŸï¼»
0 å€‹ä»¥ä¸Šã®`~URL~pathåŒºåˆ†$sT
ï¼½ã‹ã‚‰ãªã‚‹
â—
zero or more URL-path-segment strings, separated from each other by U+002F (/), andï¼¼
</li>
	<li>
â/ ã‹ã‚‰é–‹å§‹ã—ã¦ã„ãªã„
â—
not start with U+002F (/).
</li>
</ul>
</div>

<div>
<p>
`~pathç›¸å¯¾ ~schemeãªã—~URL@sT
ã¯ã€
~ANDâ†“ ã‚’æº€ãŸã™æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ï¼š
â—
A path-relative-scheme-less-URL string must beï¼¼
</p>
<ul>
	<li>
`~pathç›¸å¯¾~URL$sTã§ã‚ã‚‹
â—
a path-relative-URL stringï¼¼
</li>
	<li>
<p>
æ¬¡ã®ä¸¦ã³ã‹ã‚‰é–‹å§‹ã—ã¦ã„ãªã„ï¼š
â—
that does not start with:ï¼¼
</p>
		<ol>
			<li>
`~URL~scheme$sT
â—
a URL-scheme string,ï¼¼
</li>
			<li>
â:
â—
followed by U+003A (:).
</li>
		</ol>
	</li>
</ul>
</div>

<div>
<p>
`~URL~pathåŒºåˆ†@sT
ã¯ã€
0 å€‹ä»¥ä¸Šã®ï¼»
â/, â? ä»¥å¤–ã®`~URLå˜ä½$
ï¼½ãŸã¡ãŒæˆã™ä¸¦ã³ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
A URL-path-segment string must be one of the following:
â€¢ zero or more URL units excluding U+002F (/) and U+003F (?), that together are not a single-dot URL path segment or a double-dot URL path segment.
</p>

<p>
ç‰¹ã«ï¼Œï¼»
`äºŒé‡-~dot~URL~pathåŒºåˆ†$ï¼`å˜-~dot~URL~pathåŒºåˆ†$
ï¼½ã¯ã€
`~URL~pathåŒºåˆ†$sTã§ã‚ã‚‹ã€‚
â—
â€¢ a single-dot URL path segment
â€¢ a double-dot URL path segment.
</p>

<p class="trans-note">ã€
ä¼¼ãŸåå‰ã®`~URL~pathåŒºåˆ†$ã¯ã€
~ASCIIæ–‡å­—åˆ—ã«é™å®šã•ã‚Œã‚‹ã€‚
ã€‘</p>
</div>

<p>
`~URL~query@sT
ã¯ã€ï¼»
0 å€‹ä»¥ä¸Šã®`~URLå˜ä½$ãŸã¡ãŒæˆã™ä¸¦ã³
ï¼½ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
A URL-query string must be zero or more URL units.
</p>

<p>
`~URLç´ ç‰‡@sT
ã¯ã€ï¼»
0 å€‹ä»¥ä¸Šã®`~URLå˜ä½$ãŸã¡ãŒæˆã™ä¸¦ã³
ï¼½ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
A URL-fragment string must be zero or more URL units.
</p>

<p>
æ¬¡ã«æŒ™ã’ã‚‹`~cp$ãŒ
`~URL~cp@
ã§ã‚ã‚‹ï¼š
â—
The URL code points areï¼¼
</p>
<ul>
	<li>
`~ASCIIè‹±æ•°å­—$
â—
ASCII alphanumeric,ï¼¼
</li>
	<li>
â!,
â$,
`0026^U `&amp;^smb,
â',
â(,
â),
â*,
â+,
â,,
â-,
â.,
â/,
â:,
â;,
â=,
â?,
â@,
â_,
â~
â—
U+0021 (!), U+0024 ($), U+0026 (&amp;), U+0027 ('), U+0028 LEFT PARENTHESIS, U+0029 RIGHT PARENTHESIS, U+002A (*), U+002B (+), U+002C (,), U+002D (-), U+002E (.), U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+003F (?), U+0040 (@), U+005F (_), U+007E (~),ï¼¼
</li>
	<li>
`00A0^U ã€œ `10FFFD^U
â€” ãŸã ã—ã€
`~surrogate$, `éæ–‡å­—$ã¯é™¤å¤–ã™ã‚‹ã€‚
â—
and code points in the range U+00A0 to U+10FFFD, inclusive, excluding surrogates and noncharacters.
</li>
</ul>

<p class="note">æ³¨è¨˜ï¼š
`0080^U ä»¥ä¸Šã®~cpã¯ã€
`~URLæ§‹æ–‡è§£æå™¨$ã«ã‚ˆã‚Š`~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte$ã«å¤‰æ›ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
Code points greater than U+007F DELETE will be converted to percent-encoded bytes by the URL parser.
</p>

<p class="note">æ³¨è¨˜ï¼š
~HTMLã«ãŠã„ã¦ã¯ã€
æ–‡æ›¸ã®ç¬¦å·åŒ–æ³•ãŒæ—§æ¥ã®ã‚‚ã®ã§ã‚ã‚‹å ´åˆã€
`~URL~query$sTå†…ã® `0080^U ä»¥ä¸Šã®~cpã¯ï¼Œ
æ–‡æ›¸ã®ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦`~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte$ã«å¤‰æ›ã•ã‚Œã‚‹ã€‚
ã“ã‚Œã¯ã€
ã‚ã‚‹æ–‡æ›¸ã§åƒã~URLãŒ ç•°ãªã‚‹æ–‡æ›¸~ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã™ã‚‹æ–‡æ›¸ã«è¤‡è£½ã•ã‚Œã‚‹ã¨ãã«ï¼Œ
å•é¡Œã«ãªã‚Šå¾—ã‚‹ã€‚
ã“ã®å•é¡Œã¯ã€
ã‚ã‚‰ã‚†ã‚‹ç®‡æ‰€ã«~UTF-8ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã™ã‚Œã°~~è§£æ¶ˆã™ã‚‹ã€‚
â—
In HTML, when the document encoding is a legacy encoding, code points in the URL-query string that are higher than U+007F DELETE will be converted to percent-encoded bytes using the documentâ€™s encoding. This can cause problems if a URL that works in one document is copied to another document that uses a different document encoding. Using the UTF-8 encoding everywhere solves this problem.
</p>

<div class="example" id="query-encoding-example">
<p>
ä¾‹ãˆã°ã€
æ¬¡ã®~HTMLæ–‡æ›¸ã‚’è€ƒãˆã‚‹ï¼š
â—
For example, consider this HTML document:
</p>

<pre class="lang-html">
&lt;!doctype html&gt;
&lt;meta charset="windows-1252"&gt;
&lt;a href="?sm&amp;ouml;rg&amp;aring;sbord"&gt;Test&lt;/a&gt;
</pre>

<p>
æ–‡æ›¸~ç¬¦å·åŒ–æ³•ã¯ windows-1252 ãªã®ã§ã€
~linkã®`~URL$ã®`~query$urlã¯
`sm%F6rg%E5sbord^l
ã«ãªã‚‹ã€‚
æ–‡æ›¸~ç¬¦å·åŒ–æ³•ãŒ UTF-8 ã§ã‚ã£ãŸå ´åˆã€
ãã‚Œã¯
`sm%C3%B6rg%C3%A5sbord^l
ã«ãªã‚‹ã€‚
â—
Since the document encoding is windows-1252, the linkâ€™s URLâ€™s query will be "sm%F6rg%E5sbord". If the document encoding had been UTF-8, it would instead be "sm%C3%B6rg%C3%A5sbord".
</p>
			</div>

<p>
æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ãŒ
`~URLå˜ä½@
ã§ã‚ã‚‹
â‡’ï¼ƒ
`~URL~cp$,
`~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte$
â—
The URL units are URL code points and percent-encoded bytes.
</p>

<p class="trans-note">ã€
ã—ãŸãŒã£ã¦ã€
`~URLå˜ä½$ã¯ï¼Œä¸€èˆ¬ã«ã¯ï¼ˆ 1 å€‹ã®~cpã«é™ã‚‰ã‚Œãªã„ï¼‰æ–‡å­—åˆ—ã§ã‚ã‚‹ã€‚
ã€‘</p>

<p class="note">æ³¨è¨˜ï¼š
`~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte$ã¯ã€
~cpã®ã†ã¡ï¼»
`~URL~cp$ã§ãªã„, ã‚ã‚‹ã„ã¯
æ›¸å‡ºã›ã‚‹ã‚‚ã®ã‹ã‚‰é™¤å¤–ã•ã‚Œã¦ã„ã‚‹
ï¼½ã‚‚ã®ã‚’ç¬¦å·åŒ–ã™ã‚‹ã¨ãã«ï¼Œåˆ©ç”¨ã•ã‚Œå¾—ã‚‹ï¼ã§ãã‚‹ã€‚
â—
Percent-encoded bytes can be used to encode code points that are not URL code points or are excluded from being written.
</p>

<hr>

<p class="note">æ³¨è¨˜ï¼š
`å¦¥å½“ãª~URL$sTã®ä¸­ã§ï¼Œ`~URL~record$ã®ï¼»
`~username$url, `~password$url
ï¼½ã‚’è¡¨å‡ºã™ã‚‹ä»•æ–¹ã¯ç„¡ã„ã€‚
â—
There is no way to express a username or password of a URL record within a valid URL string.
</p>

		</section>
		<section id="url-parsing">
<h3 title="URL parsing">4.4. ~URLã®æ§‹æ–‡è§£æ-æ³•</h3>

<div class="algo">
<p>
`~URLæ§‹æ–‡è§£æã™ã‚‹@
~algoã¯ï¼ˆ â€œ~URLæ§‹æ–‡è§£æå™¨ã«ã‹ã‘ã‚‹â€ ã¨ã‚‚ç§°ã•ã‚Œã‚‹ï¼‰ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`~scalarå€¤~æ–‡å­—åˆ—$ %å…¥åŠ›,
ï¼»~NULL ï¼`åŸºåº•~URL$ï¼½ %åŸºåº• ï¼ˆçœç•¥æ™‚ã¯ ~NULL ï¼‰,
`ç¬¦å·åŒ–æ³•$ %ç¬¦å·åŒ–æ³• ï¼ˆçœç•¥æ™‚ã¯ `~UTF-8$ ï¼‰
â—çµ‚
ã«å¯¾ã—ï¼š
â—
The URL parser takes a scalar value string input, with an optional null or base URL base (default null) and an optional encoding encoding (default UTF-8), and then runs these steps:
</p>

<p class="note">æ³¨è¨˜ï¼š
é~web~browserå®Ÿè£…ã¯ã€
`åŸºæœ¬~URLæ§‹æ–‡è§£æå™¨$ã®ã¿å®Ÿè£…ã™ã‚Œã°~~ååˆ†ã§ã‚ã‚‹ã€‚
â—
Non-web-browser implementations only need to implement the basic URL parser.
</p>

<p class="note">æ³¨è¨˜ï¼š
~browserã®~URL~barå†…ã®åˆ©ç”¨è€…~å…¥åŠ›ã‚’`~URL~record$ã« ã©ã†å¤‰æ›ã™ã‚‹ã‹ã¯ã€
ã“ã®æ¨™æº–ã®è¦–é‡ã‹ã‚‰å¤–ã‚Œã‚‹ã€‚
ã“ã®æ¨™æº–ã¯ã€
`~URLã®å…·ç¾åŒ–~è¦ä»¶ï¼ #url-rendering$ã‚’
â€” ä¿¡ç”¨-è£å®šã«ä¿‚ã‚‹ã®ã§ â€”
å«ã‚€ãŒã€‚
â—
How user input in the web browserâ€™s address bar is converted to a URL record is out-of-scope of this standard. This standard does include URL rendering requirements as they pertain trust decisions.
</p>
<ol>
	<li>
%~URL ~LET `åŸºæœ¬~URLæ§‹æ–‡è§£æå™¨$( %å…¥åŠ›, %åŸºåº•, %ç¬¦å·åŒ–æ³• )
â—
Let url be the result of running the basic URL parser on input with base and encoding.
</li>
	<li>
~IFï¼»
%~URL ~EQ `å¤±æ•—^i
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If url is failure, return failure.
</li>
	<li>
~IFï¼»
%~URL ã®`~scheme$url ~NEQ `blob^l
ï¼½
â‡’
~RET %~URL
â—
If urlâ€™s scheme is not "blob", return url.
</li>
	<li>
%~URL ã®`~blob~URL~entry$url ~SET æ¬¡ã®çµæœã«å¿œã˜ã¦ï¼»
`å¤±æ•—^i ãªã‚‰ã° ~NULL ï¼
~ELSE_ ãã®çµæœ
ï¼½
â‡’
`~blob~URLã‚’è§£æ±ºã™ã‚‹$( %~URL )
â—
Set urlâ€™s blob URL entry to the result of resolving the blob URL url, if that did not return failure, and null otherwise.
</li>
	<li>
~RET %~URL
â—
Return url.
</li>
</ol>
</div>

<div class="algo">
<p>
`~APIç”¨ã«~URLæ§‹æ–‡è§£æã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`~scalarå€¤~æ–‡å­—åˆ—$ %å…¥åŠ›,
`~URL$ %~URL,
%ä¸Šæ›¸state,
`ç¬¦å·åŒ–æ³•$ %ç¬¦å·åŒ–æ³• ï¼ˆçœç•¥æ™‚ã¯ `~UTF-8$ ï¼‰
â—çµ‚
ã«å¯¾ã—
â‡’
`åŸºæœ¬~URLæ§‹æ–‡è§£æå™¨$( %å…¥åŠ›, ~NULL, %ç¬¦å·åŒ–æ³•, ( %~URL, %ä¸Šæ›¸state ) )
â—çµ‚
åŠ ãˆã¦ã€
çµæœã«å¿œã˜ã¦ï¼Œæ¬¡ã‚’è¿”ã™
â‡’ï¼ƒ
`å¤±æ•—^i ãªã‚‰ã° `å¤±æ•—^i ï¼
~ELSE_ï¼ˆåŸºæœ¬~URLæ§‹æ–‡è§£æå™¨ã¯å€¤ã‚’è¿”ã•ãªã‹ã£ãŸï¼‰ `æˆåŠŸ^i
</p>

<p class="trans-note">ã€
ã“ã®~algoã¯ï¼Œ`åŸºæœ¬~URLæ§‹æ–‡è§£æå™¨$ã‚’åŒ…è£…ã™ã‚‹ã‚‚ã®ã§ã—ã‹ãªã„ãŒã€
ãã‚Œã‚’ä»–æ‰€ï¼ˆä»–ã®ä»•æ§˜ã‚‚å«ã‚€ï¼‰ã‹ã‚‰ç°¡ä¾¿ã«åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ï¼Œ
ã“ã®è¨³ã«å°å…¥ã—ã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ã€
é¦–ã«ï¼Œ
%~URL å†…ã® %ä¸Šæ›¸state ã«å¯¾å¿œã™ã‚‹~URLæˆåˆ†
ï¼ˆä¾‹ï¼š`~host$st ãªã‚‰ã°`~host$urlæˆåˆ†ï¼‰
ã‚’ï¼»
%å…¥åŠ› ã‚’ ãã®æˆåˆ†ã«é–¢ã—ã¦æ§‹æ–‡è§£æã—ãŸçµæœ
ï¼½ã«æ”¹å¤‰ã™ã‚‹ç”¨é€”ãŒæ„å›³ã•ã‚Œã‚‹
ï¼ˆæ–°ãŸãª~URLã¯ä½œæˆã—ãªã„ï¼‰ã€‚
ï¼ˆ â€œ~APIç”¨â€¦â€ ã¨å‘½åã•ã‚ŒãŸç†ç”±ã¯ã€
ä¸‹ã®æ³¨è¨˜ã‚’è¦‹ã‚ˆã€‚ï¼‰
ã€‘</p>
â—
</div>

<hr>

<div class="algo">
<p>
`åŸºæœ¬~URLæ§‹æ–‡è§£æå™¨@
ã¯ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`~scalarå€¤~æ–‡å­—åˆ—$ %å…¥åŠ›,
ï¼»~NULL ï¼`åŸºåº•~URL$ï¼½ %åŸºåº• ï¼ˆçœç•¥æ™‚ã¯ ~NULL ï¼‰,
`ç¬¦å·åŒ–æ³•$ %ç¬¦å·åŒ–æ³• ï¼ˆçœç•¥æ™‚ã¯`~UTF-8$ ï¼‰,
`~URL$ã¨ä¸Šæ›¸stateãŒæˆã™~pair ( %~URL, %ä¸Šæ›¸state ) ï¼ˆçœç•¥æ™‚ã¯ ( Îµ, Îµ ) ï¼‰
â—çµ‚
ã«å¯¾ã—ï¼š
â—
The basic URL parser takes a scalar value string input, with an optional null or base URL base (default null), an optional encoding encoding (default UTF-8), an optional URL url, and an optional state override state override, and then runs these steps:
</p>

<div class="note">
<p>æ³¨è¨˜ï¼š</p>

<ul>
	<li>
å¼•æ•° %ç¬¦å·åŒ–æ³• ã¯ã€
`~HTML^citeã«é™ã‚Šé–¢é€£ã™ã‚‹ï¼Œæ—§æ¥ã®æ¦‚å¿µã§ã‚ã‚‹ã€‚
`HTML$r
â—
The encoding argument is a legacy concept only relevant for HTML.ï¼¼
</li>
	<li>
<p>
( %~URL, %ä¸Šæ›¸state )
ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã®ã¯ã€
å„ç¨®~APIã«é™ã‚‰ã‚Œã‚‹â€ ã€‚
`åŸºæœ¬~URLæ§‹æ–‡è§£æå™¨$ã¯ã€
ã“ã®~pairãŒ
â‡’ï¼ƒ
æ¸¡ã•ã‚Œãªã‹ã£ãŸå ´åˆã€`~URL$ã¾ãŸã¯ `å¤±æ•—^i ã‚’è¿”ã™ï¼
æ¸¡ã•ã‚ŒãŸå ´åˆã€ï¼»æ¸¡ã•ã‚ŒãŸ %~URL ã‚’æ”¹å¤‰ã—ã¦ä½•ã‚‚è¿”ã•ãšã«çµ‚äº†ã™ã‚‹ï¼½ã“ã¨ã‚‚ã‚ã‚‹â€ â€ 
</p>

<p class="trans-note">ã€â€ 
ã™ãªã‚ã¡ã€
`~APIç”¨ã«~URLæ§‹æ–‡è§£æã™ã‚‹$ã‚’ä»‹ã—ã¦å‘¼å‡ºã•ã‚ŒãŸå ´åˆã€‚
ã€‘ã€â€ â€ 
ã‚ã‚‹ã„ã¯ `å¤±æ•—^i ã‚’è¿”ã™ã€‚
ãã®å ´åˆã€
%~URL ã¯æ”¹å¤‰ã•ã‚Œãªã„ã¹ãã ãŒï¼Œæ˜ç¤ºçš„ã« ãã†è¿°ã¹ã‚‰ã‚Œã¦ã¯ã„ãªã„
â€” ~algoã‚’ç²¾æŸ»ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
ã€‘</p>
â—
The url and state override arguments are only for use by various APIs. [HTML]
â—
When the url and state override arguments are not passed, the basic URL parser returns either a new URL or failure. If they are passed, the algorithm modifies the passed url and can terminate without returning anything.
</li>
</ul>
</div>

<ol>
	<li>
<p>
~IFï¼»
%~URL ~EQ Îµ
ï¼½ï¼š
â—
If url is not given:
</p>
		<ol>
			<li>
%~URL ~SET æ–°ãŸãª`~URL$
â—
Set url to a new URL.
</li>
			<li>
~IFï¼»
%å…¥åŠ› ã®ï¼»
å…ˆé ­ã¾ãŸã¯æœ«å°¾
ï¼½ã®æ–‡å­— ~IN `~C0åˆ¶å¾¡æ–‡å­—ã‚„~space$
ï¼½
â‡’
`æ¤œè¨¼~error$( `invalid-URL-unit$err )
â—
If input contains any leading or trailing C0 control or space, invalid-URL-unit validation error.
</li>
			<li>
%å…¥åŠ› ã‹ã‚‰ï¼»
é ­éƒ¨, å°¾éƒ¨
ï¼½ã‚’æˆã™ï¼»
`~C0åˆ¶å¾¡æ–‡å­—ã‚„~space$ãŸã¡ãŒæˆã™ä¸¦ã³
ï¼½ã‚’é™¤å»ã™ã‚‹
â—
Remove any leading and trailing C0 control or space from input.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%å…¥åŠ› å†…ã«`~ASCII~tabã‚„~ASCIIæ”¹è¡Œæ–‡å­—$ãŒåœ¨ã‚‹
ï¼½
â‡’
`æ¤œè¨¼~error$( `invalid-URL-unit$err )
â—
If input contains any ASCII tab or newline, invalid-URL-unit validation error.
</li>
	<li>
%å…¥åŠ› ã‹ã‚‰ã™ã¹ã¦ã®`~ASCII~tabã‚„~ASCIIæ”¹è¡Œæ–‡å­—$ã‚’é™¤å»ã™ã‚‹
â—
Remove all ASCII tab or newline from input.
</li>
	<li>
%state ~LET ï¼»
%ä¸Šæ›¸state ~NEQ Îµ ãªã‚‰ã° %ä¸Šæ›¸state ï¼
~ELSE_ `~schemeé–‹å§‹$st
ï¼½
â—
Let state be state override if given, or scheme start state otherwise.
</li>
	<li>
%ç¬¦å·åŒ–æ³• ~SET `ç¬¦å·åŒ–æ³•ã‹ã‚‰å‡ºåŠ›~ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹$( %ç¬¦å·åŒ–æ³• )
â—
Set encoding to the result of getting an output encoding from encoding.
</li>
	<li>
%~buffer ~LET ç©º~æ–‡å­—åˆ—
â—
Let buffer be the empty string.
</li>
	<li>
( %~at-signã‚ã‚Šã‹, %è§’æ‹¬å¼§ã®å†…å´ã‹, %~password~tokenã‚ã‚Šã‹ ) ~LET ( ~F, ~F, ~F )
â—
Let atSignSeen, insideBrackets, and passwordTokenSeen be false.
</li>
	<li>
%~pointer ~LET %å…¥åŠ› ç”¨ã®`~pointer$
â—
Let pointer be a pointer for input.
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶
</p>
		<ol>
			<li>
ä¸‹ã«ä¸ãˆã‚‹çŠ¶æ…‹æ©Ÿæ¢°ã‚’èµ°ã‚‰ã™
</li>
			<li>
~IFï¼»
%~pointer ~NEQ âˆ’1
ï¼½~ANDï¼»
`C$V ~EQ `EOF$i
ï¼½
â‡’
~BREAK
</li>
			<li>
%~pointer ~INCBY 1
</li>
		</ol>
â—
Keep running the following state machine by switching on state. If after a run pointer points to the EOF code point, go to the next step. Otherwise, increase pointer by 1 and continue with the state machine.
</li>
	<li>
<p>
~IFï¼»
%ä¸Šæ›¸state ~EQ Îµ
ï¼½
â‡’
~RET %~URL
</p>

<p class="trans-note">ã€
æ§‹æ–‡è§£æã«å¤±æ•—ã—ãŸå ´åˆã€
ã“ã®æ®µã«ã¯åˆ°é”ã—ãªã„ã€‚
ã€‘ã€
ã“ã®æ®µã¯ï¼ŒåŸæ–‡ã§ã¯çŠ¶æ…‹æ©Ÿæ¢°ã®å¾Œã«ç½®ã‹ã‚Œã¦ã„ã‚‹ãŒã€
è¦‹é€šã—ã‚’è‰¯ãã™ã‚‹ãŸã‚ï¼Œã“ã“ã«ç§»å‹•ã—ã¦ã„ã‚‹ã€‚
ã€‘</p>
â—
â†“â†“</li>
</ol>

<p>
çŠ¶æ…‹æ©Ÿæ¢°ã¯ã€
%state ã«å¿œã˜ã¦ï¼Œä»¥ä¸‹ã«ãŠã‘ã‚‹å¯¾å¿œã™ã‚‹æ®µã‚’èµ°ã‚‰ã™
â€” ã“ã®çŠ¶æ…‹æ©Ÿæ¢°ã®ä¸­ã§ã¯ï¼š
â—
â†‘â†‘</p>

<ul>
	<li>
â€œ~RETâ€ ã¯ã€
ä¸Šã®~algoè‡ªèº«ã‚’çµ‚äº†ã•ã›ã‚‹ã¨ã™ã‚‹ã€‚
</li>
	<li>
<p>
`~URLå˜ä½ã‹ã©ã†ã‹æ¤œè¨¼ã™ã‚‹@
æ‰€ã§ã¯ã€
`C$V ã«å¿œã˜ã¦æ¬¡ã‚’èµ°ã‚‰ã™ã¨ã™ã‚‹ï¼š
</p>
		<ol class="switch">
			<li>
`~URL~cp$
â‡’
ä½•ã‚‚ã—ãªã„
</li>
			<li>
â%
â‡’
~IFï¼»
`C1$V ~NIN `~ASCII~hexæ•°å­—$
ï¼½~ORï¼»
`C2$V ~NIN `~ASCII~hexæ•°å­—$
ï¼½
â‡’
`æ¤œè¨¼~error$( `invalid-URL-unit$err )
</li>
			<li>
ãã®ä»–
â‡’
`æ¤œè¨¼~error$( `invalid-URL-unit$err )
</li>
		</ol>

<p class="trans-note">ã€
ã“ã®å®šç¾©ã¯ã€
å…±é€šãªè¨˜è¿°ã‚’é›†ç´„ã™ã‚‹ãŸã‚ã«ï¼Œã“ã®è¨³ã«å°å…¥ã—ã¦ã„ã‚‹ã€‚
ã€‘</p>

	</li>
</ul>

<p class="trans-note">ã€
ã“ã®çŠ¶æ…‹æ©Ÿæ¢°ã¯ã€
ç¾åœ¨ã® `state^i ã‹ã‚‰ã¯å¸¸ã«ï¼Œè‡ªèº«ã¾ãŸã¯è‡ªèº«ã‚ˆã‚Šå¾Œã«ç¤ºã•ã‚Œã‚‹ `state^i ã¸é·ç§»ã™ã‚‹ã‚ˆã†ã€
~sortã—ã¦è¨˜ã•ã‚Œã¦ã„ã‚‹ã€‚
ã€‘</p>

<dl class="switch">

<!--% scheme-start-state -->
	<dt>`~schemeé–‹å§‹@st</dt>

	<dd>
		<ol>
			<li>
~IFï¼»
`C$V ~IN `~ASCIIè‹±å­—$
ï¼½
â‡’ï¼ƒ
%~buffer ~APPEND `~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹$( `C$V )ï¼›
%state ~SET `~scheme$st
â—
If c is an ASCII alpha, append c, lowercased, to buffer, and set state to scheme state.
</li>
			<li>
~ELIFï¼»
%ä¸Šæ›¸state ~EQ Îµ
ï¼½
â‡’ï¼ƒ
%~pointer ~DECBY 1ï¼›
%state ~SET `~schemeãªã—$st
â—
Otherwise, if state override is not given, set state to no scheme state and decrease pointer by 1.
</li>
			<li>
<p>
~ELSE
â‡’
~RET `å¤±æ•—^i
â—
Otherwise, return failure.
</p>

<p class="note">
ã“ã® `å¤±æ•—^i ã®æŒ‡ç¤ºã¯ã€
`Location$I ~objã® `~protocol0$m è¨­å®šå­ã‹ã‚‰æ’ä»–çš„ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
This indication of failure is used exclusively by the Location objectâ€™s protocol setter.
</p>
			</li>
		</ol>
	</dd>

<!--% scheme-state -->
	<dt>`~scheme@st</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
`C$V ã¯`~ASCIIè‹±æ•°å­—$ã§ã‚ã‚‹
ï¼½~ORï¼»
`C$V ~IN { â+, â-, â. }
ï¼½
â‡’
%~buffer ~APPEND `~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹$( `C$V )
â—
If c is an ASCII alphanumeric, U+002B (+), U+002D (-), or U+002E (.), append c, lowercased, to buffer.
</li>
			<li>
<p>
~ELIFï¼»
`C$V ~EQ â:
ï¼½ï¼š
â—
Otherwise, if c is U+003A (:), then:
</p>

				<ol>
					<li>
<p>
~IFï¼»
%ä¸Šæ›¸state ~NEQ Îµ
ï¼½~ANDï¼»
~ORâ†“
ï¼½â€¦
â—
If state override is given, then:
</p>
						<ul>
							<li>
ï¼»
%~URL ã®`~scheme$url, %~buffer
ï¼½ã®ã†ã¡ï¼Œç‰‡æ–¹ã ã‘ãŒ`ç‰¹åˆ¥~scheme$ã§ã‚ã‚‹
â—
If urlâ€™s scheme is a special scheme and buffer is not a special scheme, then return.
â—
If urlâ€™s scheme is not a special scheme and buffer is a special scheme, then return.
</li>
							<li>
ï¼»ï¼»
%~URL ã¯`è³‡æ ¼è¨¼ã‚’å«ã‚“ã§$ã„ã‚‹
ï¼½~ORï¼»
%~URL ã®`~port$url ~NEQ ~NULL
ï¼½ï¼½~ANDï¼»
%~buffer ~EQ `file^l
ï¼½
â—
If url includes credentials or has a non-null port, and buffer is "file", then return.
</li>
							<li>
ï¼»
%~URL ã®`~scheme$url ~EQ `file^l
ï¼½~ANDï¼»
%~URL ã®`~host$urlã¯`ç©º~host$ã§ã‚ã‚‹
ï¼½
â—
If urlâ€™s scheme is "file" and its host is an empty host, then return.
</li>
						</ul>
<p>
â€¦ãªã‚‰ã°
â‡’
~RET
â—
â†‘</p>
					</li>
					<li>
%~URL ã®`~scheme$url ~SET %~buffer
â—
Set urlâ€™s scheme to buffer.
</li>
					<li>
<p>
~IFï¼»
%ä¸Šæ›¸state ~NEQ Îµ
ï¼½ï¼š
â—
If state override is given, then:
</p>
						<ol>
							<li>
~IFï¼»
%~URL ã®`~port$url ~EQ %~URL ã®`~scheme$urlã®`æ—¢å®š~port$
ï¼½
â‡’
%~URL ã®`~port$url ~SET ~NULL
â—
If urlâ€™s port is urlâ€™s schemeâ€™s default port, then set urlâ€™s port to null.
</li>
							<li>
~RET
â—
Return.
</li>
						</ol>
					</li>
					<li>
%~buffer ~SET ç©º~æ–‡å­—åˆ—
â—
Set buffer to the empty string.
</li>
					<li>
<p>
~IFï¼»
%~URL ã®`~scheme$url ~EQ `file^l
ï¼½ï¼š
â—
If urlâ€™s scheme is "file", then:
</p>
						<ol>
							<li>
~IFï¼»
`C1$V ~NEQ `/^l
ï¼½~ORï¼»
`C2$V ~NEQ `/^l
ï¼½
â‡’
`æ¤œè¨¼~error$( `special-scheme-missing-following-solidus$err )
â—
If remaining does not start with "//", special-scheme-missing-following-solidus validation error.
</li>
							<li>
%state ~SET `~file$st
â—
Set state to file state.
</li>
						</ol>
					</li>
					<li>
<p>
~ELIFï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼½~ANDï¼»
%åŸºåº• ~NEQ ~NULL
ï¼½~ANDï¼»
%åŸºåº• ã®`~scheme$url ~EQ %~URL ã®`~scheme$url
ï¼½ï¼š
â—
Otherwise, if url is special, base is non-null, and baseâ€™s scheme is urlâ€™s scheme:
</p>
						<ol>
							<li>
~Assertï¼š
%åŸºåº• ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼ˆã—ãŸãŒã£ã¦ï¼Œ`ä¸é€æ˜ãª~path$ã‚’æœ‰ã•ãªã„ï¼‰ã€‚
â—
Assert: base is special (and therefore does not have an opaque path).
</li>
							<li>
%çŠ¶æ…‹ ~SET `ç‰¹åˆ¥ ç›¸å¯¾/æ¨©é™$st
â—
Set state to special relative or authority state.
</li>
						</ol>
					</li>
					<li>
~ELIFï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼½
â‡’
%state ~SET `ç‰¹åˆ¥ æ¨©é™~slash$st
â—
Otherwise, if url is special, set state to special authority slashes state.
</li>
					<li>
~ELIFï¼»
`C1$V ~EQ â/
ï¼½
â‡’ï¼ƒ
%~pointer ~INCBY 1ï¼›
%state ~SET `~path/æ¨©é™$st
â—
Otherwise, if remaining starts with an U+002F (/), set state to path or authority state and increase pointer by 1.
</li>
					<li>
~ELSE
â‡’ï¼ƒ
%~URL ã®`~path$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `ä¸é€æ˜~path$st
â—
Otherwise, set urlâ€™s path to the empty string and set state to opaque path state.
</li>
				</ol>
			</li>
			<li>
~ELIFï¼»
%ä¸Šæ›¸state ~EQ Îµ
ï¼½
â‡’ï¼ƒ
%~buffer ~SET ç©º~æ–‡å­—åˆ—ï¼›
%~pointer ~SET âˆ’1 ï¼ˆ%å…¥åŠ› ã®æœ€åˆã®~cpã‹ã‚‰ã€ã‚„ã‚Šç›´ã™ï¼‰ï¼›
%state ~SET `~schemeãªã—$stï¼›
â—
Otherwise, if state override is not given, set buffer to the empty string, state to no scheme state, and start over (from the first code point in input).
</li>
			<li>
<p>
~ELSE
â‡’
~RET `å¤±æ•—^i
â—
Otherwise, return failure.
</p>

<p class="note">
ã“ã® `å¤±æ•—^i ã®æŒ‡ç¤ºã¯ã€
`Location$I ~objã® `~protocol0$m è¨­å®šå­ã‹ã‚‰æ’ä»–çš„ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
æ›´ã«ã¯ï¼Œã“ã®~stateã®æ—©æœŸã«ãŠã‘ã‚‹é `å¤±æ•—^i ã«ã‚ˆã‚‹çµ‚äº†nã¯ã€
ãã®è¨­å®šå­ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã®æ„å›³çš„ãªç›¸é•ã§ã‚ã‚‹ã€‚
â—
This indication of failure is used exclusively by the Location objectâ€™s protocol setter. Furthermore, the non-failure termination earlier in this state is an intentional difference for defining that setter.
</p>
			</li>
		</ol>
	</dd>

<!--% no-scheme-state -->
	<dt>`~schemeãªã—@st</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
%åŸºåº• ~EQ ~NULL
ï¼½~ORï¼»ï¼»
%åŸºåº• ã¯`ä¸é€æ˜ãª~path$ã‚’æœ‰ã™ã‚‹
ï¼½~ANDï¼»
`C$V ~NEQ â#
ï¼½ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `missing-scheme-non-relative-URL$err )ï¼›
~RET `å¤±æ•—^i
â—
If base is null, or base has an opaque path and c is not U+0023 (#), missing-scheme-non-relative-URL validation error, return failure.
</li>
			<li>
<p>
~ELIFï¼»
%åŸºåº• ã¯`ä¸é€æ˜ãª~path$ã‚’æœ‰ã™ã‚‹
ï¼½~ANDï¼»
`C$V ~EQ â#
ï¼½ï¼š
</p>
				<ol>
					<li>
%~URL ã®
â‡’ï¼ƒ
`~scheme$url ~SET %åŸºåº• ã®`~scheme$urlï¼›
`~path$url ~SET %åŸºåº• ã®`~path$urlï¼›
`~query$url ~SET %åŸºåº• ã®`~query$urlï¼›
`ç´ ç‰‡$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
</li>
					<li>
%state ~SET `ç´ ç‰‡$st
</li>
				</ol>
â—
Otherwise, if base has an opaque path and c is U+0023 (#), set urlâ€™s scheme to baseâ€™s scheme, urlâ€™s path to baseâ€™s path, urlâ€™s query to baseâ€™s query, urlâ€™s fragment to the empty string, and set state to fragment state.
</li>
			<li>
~ELIFï¼»
%åŸºåº• ã®`~scheme$url ~NEQ `file^l
ï¼½
â‡’ï¼ƒ
%~pointer ~DECBY 1ï¼›
%state ~SET `ç›¸å¯¾$st
â—
Otherwise, if baseâ€™s scheme is not "file", set state to relative state and decrease pointer by 1.
</li>
			<li>
~ELSE
â‡’ï¼ƒ
%~pointer ~DECBY 1ï¼›
%state ~SET `~file$st
â—
Otherwise, set state to file state and decrease pointer by 1.
</li>
		</ol>
	</dd>

<!--% special-relative-or-authority-state -->
	<dt>`ç‰¹åˆ¥ ç›¸å¯¾/æ¨©é™@st</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
`C$V ~EQ â/
ï¼½~ANDï¼»
`C1$V ~EQ â/
ï¼½
â‡’ï¼ƒ
%~pointer ~INCBY 1ï¼›
%state ~SET `ç‰¹åˆ¥ æ¨©é™~slashç„¡è¦–$st
â—
If c is U+002F (/) and remaining starts with U+002F (/), then set state to special authority ignore slashes state and increase pointer by 1.
</li>
			<li>
~ELSE
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `special-scheme-missing-following-solidus$err )ï¼›
%~pointer ~DECBY 1ï¼›
%state ~SET `ç›¸å¯¾$st
â—
Otherwise, special-scheme-missing-following-solidus validation error, set state to relative state and decrease pointer by 1.
</li>
		</ol>
	</dd>

<!--% path-or-authority-state -->
	<dt>`~path/æ¨©é™@st</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
`C$V ~EQ â/
ï¼½
â‡’
%state ~SET `æ¨©é™$st
â—
If c is U+002F (/), then set state to authority state.
</li>
			<li>
~ELSE
â‡’ï¼ƒ
%~pointer ~DECBY 1ï¼›
%state ~SET `~path$st
â—
Otherwise, set state to path state, and decrease pointer by 1.
</li>
		</ol>
	</dd>

<!--% relative-state -->
	<dt>`ç›¸å¯¾@st</dt>
	<dd>
		<ol>
			<li>
~Assertï¼š
%åŸºåº• ã®`~scheme$url ~NEQ `file^l
â—
Assert: baseâ€™s scheme is not "file".
</li>
			<li>
%~URL ã®`~scheme$url ~SET %åŸºåº• ã®`~scheme$url
â—
Set urlâ€™s scheme to baseâ€™s scheme.
</li>
			<li>
~IFï¼»
`C$V ~EQ â/
ï¼½
â‡’
%state ~SET `ç›¸å¯¾~slash$st
â—
If c is U+002F (/), then set state to relative slash state.
</li>
			<li>
~ELIFï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼½~ANDï¼»
`C$V ~EQ â\
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `invalid-reverse-solidus$err )ï¼›
%state ~SET `ç›¸å¯¾~slash$st
â—
Otherwise, if url is special and c is U+005C (\), invalid-reverse-solidus validation error, set state to relative slash state.
</li>
			<li>
<p>
~ELSEï¼š
â—
Otherwise:
</p>
				<ol>
					<li>
%~URL ã®
â‡’ï¼ƒ
`~username$url ~SET %åŸºåº• ã®`~username$urlï¼›
`~password$url ~SET %åŸºåº• ã®`~password$urlï¼›
`~host$url ~SET %åŸºåº• ã®`~host$urlï¼›
`~port$url ~SET %åŸºåº• ã®`~port$urlï¼›
`~path$url ~SET %åŸºåº• ã®`~path$urlã‚’`~cloneã™ã‚‹$ï¼›
`~query$url ~SET %åŸºåº• ã®`~query$url
â—
Set urlâ€™s username to baseâ€™s username, urlâ€™s password to baseâ€™s password, urlâ€™s host to baseâ€™s host, urlâ€™s port to baseâ€™s port, urlâ€™s path to a clone of baseâ€™s path, and urlâ€™s query to baseâ€™s query.
</li>
					<li>
~IFï¼»
`C$V ~EQ â?
ï¼½
â‡’ï¼ƒ
%~URL ã®`~query$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `~query$st
â—
If c is U+003F (?), then set urlâ€™s query to the empty string, and state to query state.
</li>
					<li>
~ELIFï¼»
`C$V ~EQ â#
ï¼½
â‡’ï¼ƒ
%~URL ã®`ç´ ç‰‡$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `ç´ ç‰‡$st
â—
Otherwise, if c is U+0023 (#), set urlâ€™s fragment to the empty string and state to fragment state.
</li>
					<li>
<p>
~ELIFï¼»
`C$V ~NEQ `EOF$i
ï¼½ï¼š
â—
Otherwise, if c is not the EOF code point:
</p>
						<ol>
							<li>
%~URL ã®`~query$url ~SET ~NULL
â—
Set urlâ€™s query to null.
</li>
							<li>
%~URL ã®`~pathã‚’çŸ­ç¸®ã™ã‚‹$
â—
Shorten urlâ€™s path.
</li>
							<li>
%~pointer ~DECBY 1
â—
Set state to path state and decrease pointer by 1.
</li>
							<li>
%state ~SET `~path$st
â—
â†‘</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% relative-slash-state -->
	<dt>`ç›¸å¯¾~slash@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IFï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼½~ANDï¼»
`C$V ~IN { â/, â\ }
ï¼½ï¼š
â—
If url is special and c is U+002F (/) or U+005C (\), then:
</p>
				<ol>
					<li>
~IFï¼»
`C$V ~EQ â\
ï¼½
â‡’
`æ¤œè¨¼~error$( `invalid-reverse-solidus$err )
â—
If c is U+005C (\), invalid-reverse-solidus validation error.
</li>
					<li>
%state ~SET `ç‰¹åˆ¥ æ¨©é™~slashç„¡è¦–$st
â—
Set state to special authority ignore slashes state.
</li>
				</ol>
			</li>
			<li>
~ELIFï¼»
`C$V ~EQ â/
ï¼½
â‡’
%state ~SET `æ¨©é™$st
â—
Otherwise, if c is U+002F (/), then set state to authority state.
</li>
			<li>
<p>
~ELSEï¼š
</p>
				<ol>
					<li>
%~URL ã®
â‡’ï¼ƒ
`~username$url ~SET %åŸºåº• ã®`~username$urlï¼›
`~password$url ~SET %åŸºåº• ã®`~password$urlï¼›
`~host$url ~SET %åŸºåº• ã®`~host$urlï¼›
`~port$url ~SET %åŸºåº• ã®`~port$url
</li>
					<li>
%~pointer ~DECBY 1
</li>
					<li>
%state ~SET `~path$st
</li>
				</ol>
â—
Otherwise, set urlâ€™s username to baseâ€™s username, urlâ€™s password to baseâ€™s password, urlâ€™s host to baseâ€™s host, urlâ€™s port to baseâ€™s port, state to path state, and then, decrease pointer by 1.
</li>
		</ol>
	</dd>

<!--% special-authority-slashes-state -->
	<dt>`ç‰¹åˆ¥ æ¨©é™~slash@st</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
`C$V ~EQ â/
ï¼½~ANDï¼»
`C1$V ~EQ â/
ï¼½
â‡’
%~pointer ~INCBY 1
â—
If c is U+002F (/) and remaining starts with U+002F (/), then set state to special authority ignore slashes state and increase pointer by 1.
</li>
			<li>
~ELSE
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `special-scheme-missing-following-solidus$err )ï¼›
%~pointer ~DECBY 1
â—
Otherwise, special-scheme-missing-following-solidus validation error, set state to special authority ignore slashes state and decrease pointer by 1.
</li>
			<li>
%state ~SET `ç‰¹åˆ¥ æ¨©é™~slashç„¡è¦–$st
â—
â†‘</li>
		</ol>
	</dd>

<!--% special-authority-ignore-slashes-state -->
	<dt>`ç‰¹åˆ¥ æ¨©é™~slashç„¡è¦–@st</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
`C$V ~NIN { â/, â\ }
ï¼½
â‡’ï¼ƒ
%~pointer ~DECBY 1ï¼›
%state ~SET `æ¨©é™$st
â—
If c is neither U+002F (/) nor U+005C (\), then set state to authority state and decrease pointer by 1.
</li>
			<li>
~ELSE
â‡’
`æ¤œè¨¼~error$( `special-scheme-missing-following-solidus$err )
â—
Otherwise, special-scheme-missing-following-solidus validation error.
</li>
		</ol>
	</dd>

<!--% authority-state -->
	<dt>`æ¨©é™@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IFï¼»
`C$V ~EQ â@
ï¼½ï¼š
â—
If c is U+0040 (@), then:
</p>
				<ol>
					<li>
`æ¤œè¨¼~error$( `invalid-credentials$err )
â—
Invalid-credentials validation error.
</li>
					<li>
~IFï¼»
%~at-signã‚ã‚Šã‹ ~EQ ~T
ï¼½
â‡’
%~buffer ã®å…ˆé ­ã« `%40^l ã‚’~~æŒ¿å…¥ã™ã‚‹
â—
If atSignSeen is true, then prepend "%40" to buffer.
</li>
					<li>
%~at-signã‚ã‚Šã‹ ~SET ~T
â—
Set atSignSeen to true.
</li>
					<li>
<p>
%~buffer ã‚’æˆã™
~EACH( %~cp )
ã«å¯¾ã—ï¼š
â—
For each codePoint in buffer:
</p>
						<ol>
							<li>
~IFï¼»
%~cp ~EQ â:
ï¼½~ANDï¼»
%~password~tokenã‚ã‚Šã‹ ~EQ ~F
ï¼½
â‡’ï¼ƒ
%~password~tokenã‚ã‚Šã‹ ~SET ~Tï¼›
~CONTINUE
â—
If codePoint is U+003A (:) and passwordTokenSeen is false, then set passwordTokenSeen to true and continue.
</li>
							<li>
%ç¬¦å·åŒ–-æ¸ˆã¿~cp ~LET
`~cpã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹$( %~cp, `~userinfo~percent-ç¬¦å·åŒ–-é›†åˆ$ )
â—
Let encodedCodePoints be the result of running UTF-8 percent-encode codePoint using the userinfo percent-encode set.
</li>
							<li>
~IFï¼»
%~password~tokenã‚ã‚Šã‹ ~EQ ~T
ï¼½
â‡’
%~URL ã®`~password$url ~APPEND %ç¬¦å·åŒ–-æ¸ˆã¿~cp
â—
If passwordTokenSeen is true, then append encodedCodePoints to urlâ€™s password.
</li>
							<li>
~ELSE
â‡’
%~URL ã®`~username$url ~APPEND %ç¬¦å·åŒ–-æ¸ˆã¿~cp
â—
Otherwise, append encodedCodePoints to urlâ€™s username.
</li>
						</ol>
					</li>
					<li>
%~buffer ~SET ç©º~æ–‡å­—åˆ—
â—
Set buffer to the empty string.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIFï¼»
~ORâ†“
ï¼½â€¦
â—
Otherwise, if one of the following is true:
</p>
				<ul>
					<li>
`C$V ~IN { `EOF$i, â/, â?, â# }
â—
c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
</li>
					<li>
ï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼½~ANDï¼»
`C$V ~EQ â\
ï¼½
â—
url is special and c is U+005C (\)
</li>
				</ul>

<p>
â€¦ãªã‚‰ã°ï¼š
â—
then:
</p>
				<ol>
					<li>
~IFï¼»
%~at-signã‚ã‚Šã‹ ~EQ ~T
ï¼½~ANDï¼»
%~buffer ~EQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `host-missing$err )ï¼›
~RET `å¤±æ•—^i
â—
If atSignSeen is true and buffer is the empty string, host-missing validation error, return failure.
</li>
					<li>
%~pointer ~DECBY %~buffer ã®`~cpé•·ã•$ ~PLUS 1
â—
Decrease pointer by bufferâ€™s code point length + 1,ï¼¼
</li>
					<li>
%~buffer ~SET ç©º~æ–‡å­—åˆ—
â—
set buffer to the empty string,ï¼¼
</li>
					<li>
%state ~SET `~host$st
â—
and set state to host state.
</li>
				</ol>
			</li>
			<li>
~ELSE
â‡’
%~buffer ~APPEND `C$V
â—
Otherwise, append c to buffer.
</li>
		</ol>
	</dd>

<!--% host-state -->
	<dt>`~host@st</dt>

<!--% hostname-state -->
	<dt>`~hostname@st</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
%ä¸Šæ›¸state ~NEQ Îµ
ï¼½~ANDï¼»
%~URL ã®`~scheme$url ~EQ `file^l
ï¼½
â‡’ï¼ƒ
%~pointer ~DECBY 1ï¼›
%state ~SET `~file~host$st
â—
If state override is given and urlâ€™s scheme is "file", then decrease pointer by 1 and set state to file host state.
</li>
			<li>
<p>
~ELIFï¼»
`C$V ~EQ â:
ï¼½~ANDï¼»
%è§’æ‹¬å¼§ã®å†…å´ã‹ ~EQ ~F
ï¼½ï¼š
â—
Otherwise, if c is U+003A (:) and insideBrackets is false, then:
</p>

				<ol>
					<li>
~IFï¼»
%~buffer ~EQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `host-missing$err )ï¼›
~RET `å¤±æ•—^i
â—
If buffer is the empty string, host-missing validation error, return failure.
</li>
					<li>
~IFï¼»
%ä¸Šæ›¸state ~EQ `~hostname$st
ï¼½
â‡’
~RET
â—
If state override is given and state override is hostname state, then return.
</li>
					<li>
%~host ~LET
`~hostæ§‹æ–‡è§£æå™¨$( %~buffer, ~ISï¼» %~URL ã¯`ç‰¹åˆ¥$ã§ãªã„ï¼½ )
â—
Let host be the result of host parsing buffer with url is not special.
</li>
					<li>
~IFï¼»
%~host ~EQ `å¤±æ•—^i
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If host is failure, then return failure.
</li>
					<li>
%~URL ã®`~host$url ~SET %~host
â—
Set urlâ€™s host to host,ï¼¼
</li>
					<li>
%~buffer ~SET ç©º~æ–‡å­—åˆ—
â—
buffer to the empty string,ï¼¼
</li>
					<li>
%state ~SET `~port$st
â—
and state to port state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIFï¼»
~ORâ†“
ï¼½â€¦
â—
Otherwise, if one of the following is true:
</p>
				<ul>
					<li>
`C$V ~IN { `EOF$i, â/, â?, â# }
â—
c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
</li>
					<li>
ï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼½~ANDï¼»
`C$V ~EQ â\
ï¼½
â—
url is special and c is U+005C (\)
</li>
				</ul>
<p>
â€¦ãªã‚‰ã°ï¼š
â—
then decrease pointer by 1, and then:
</p>

				<ol>
					<li>
%~pointer ~DECBY 1
â—
â†‘</li>
					<li>
~IFï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼½~ANDï¼»
%~buffer ~EQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `host-missing$err )ï¼›
~RET `å¤±æ•—^i
â—
If url is special and buffer is the empty string, host-missing validation error, return failure.
</li>
					<li>
~ELIFï¼»
%ä¸Šæ›¸state ~NEQ Îµ
ï¼½~ANDï¼»
%~buffer ~EQ ç©º~æ–‡å­—åˆ—
ï¼½~ANDï¼»ï¼»
%~URL ã¯`è³‡æ ¼è¨¼ã‚’å«ã‚“ã§$ã„ã‚‹
ï¼½~ORï¼»
%~URL ã®`~port$url ~NEQ ~NULL
ï¼½ï¼½
â‡’
~RET
â—
Otherwise, if state override is given, buffer is the empty string, and either url includes credentials or urlâ€™s port is non-null, return.
</li>
					<li>
%~host ~LET
`~hostæ§‹æ–‡è§£æå™¨$( %~buffer, ~ISï¼» %~URL ã¯`ç‰¹åˆ¥$ã§ãªã„ï¼½ )
â—
Let host be the result of host parsing buffer with url is not special.
</li>
					<li>
~IFï¼»
%~host ~EQ `å¤±æ•—^i
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If host is failure, then return failure.
</li>
					<li>
%~URL ã®`~host$url ~SET %~host
â—
Set urlâ€™s host to host, buffer to the empty string, and state to path start state.
</li>
					<li>
~IFï¼»
%ä¸Šæ›¸state ~NEQ Îµ
ï¼½
â‡’
~RET
â—
If state override is given, then return.
</li>
					<li>
%~buffer ~SET ç©º~æ–‡å­—åˆ—
â—
â†‘</li>
					<li>
%state ~SET `~pathé–‹å§‹$st
â—
â†‘</li>
				</ol>
			</li>
			<li>
<p>
~ELSEï¼š
â—
Otherwise:
</p>

				<ol>
					<li>
~IFï¼»
`C$V ~EQ â[
ï¼½
â‡’
%è§’æ‹¬å¼§ã®å†…å´ã‹ ~SET ~T
â—
If c is U+005B ([), then set insideBrackets to true.
</li>
					<li>
~IFï¼»
`C$V ~EQ â]
ï¼½
â‡’
%è§’æ‹¬å¼§ã®å†…å´ã‹ ~SET ~F
â—
If c is U+005D (]), then set insideBrackets to false.
</li>
					<li>
%~buffer ~APPEND `C$V
â—
Append c to buffer.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% port-state -->
	<dt>`~port@st</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
`C$V ~IN `~ASCIIæ•°å­—$
ï¼½
â‡’
%~buffer ~APPEND `C$V
â—
If c is an ASCII digit, append c to buffer.
</li>
			<li>
<p>
~ELIFï¼»
~ORâ†“
ï¼½â€¦
â—
Otherwise, if one of the following is true:
</p>
				<ul>
					<li>
`C$V ~IN { `EOF$i, â/, â?, â# }
â—
c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
</li>
					<li>
ï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼½~ANDï¼»
`C$V ~EQ â\
ï¼½
â—
url is special and c is U+005C (\)
</li>
					<li>
%ä¸Šæ›¸state ~NEQ Îµ
â—
state override is given
</li>
				</ul>
<p>
â€¦ãªã‚‰ã°ï¼š
â—
then:
</p>
				<ol>
					<li>
<p>
~IFï¼»
%~buffer ~NEQ ç©º~æ–‡å­—åˆ—
ï¼½ï¼š
â—
If buffer is not the empty string, then:
</p>
						<ol>
							<li>
%~port ~LET %~buffer ã‚’ï¼»
ãã®å„ `~ASCIIæ•°å­—$ã‚’åŸºæ•° 10 ã«ã‚ˆã‚‹å€¤ 0 ã€œ 9 ã¨è§£é‡ˆã—ãŸ
ï¼½ä¸‹ã§è¡¨ç¾ã•ã‚Œã‚‹ï¼Œæ•°å­¦çš„ãªæ•´æ•°~å€¤
â—
Let port be the mathematical integer value that is represented by buffer in radix-10 using ASCII digits for digits with values 0 through 9.
</li>
							<li>
~IFï¼»
%~port ã¯ `16 ~bitãªç„¡ç¬¦å·~æ•´æ•°$ã§ãªã„
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `port-out-of-range$err )ï¼›
~RET `å¤±æ•—^i
â—
If port is not a 16-bit unsigned integer, port-out-of-range validation error, return failure.
</li>
							<li>
%~URL ã®`~port$url ~SET ï¼»
æ¬¡ãŒæº€ãŸã•ã‚Œã‚‹ãªã‚‰ã° ~NULL ï¼
~ELSE_ %~port
ï¼½
â‡’
%~port ~EQ %~URL ã®`~scheme$urlã®`æ—¢å®š~port$
â—
Set urlâ€™s port to null, if port is urlâ€™s schemeâ€™s default port; otherwise to port.
</li>
							<li>
%~buffer ~SET ç©º~æ–‡å­—åˆ—
â—
Set buffer to the empty string.
</li>
						</ol>
					</li>
					<li>
~IFï¼»
%ä¸Šæ›¸state ~NEQ Îµ
ï¼½
â‡’
~RET
â—
If state override is given, then return.
</li>
					<li>
%~pointer ~DECBY 1
â—
â†“</li>
					<li>
%state ~SET `~pathé–‹å§‹$st
â—
Set state to path start state and decrease pointer by 1.
</li>
				</ol>
			</li>
			<li>
~ELSE
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `port-invalid$err )ï¼›
~RET `å¤±æ•—^i
â—
Otherwise, port-invalid validation error, return failure.
</li>
		</ol>
	</dd>

<!--% file-state -->
	<dt>`~file@st</dt>
	<dd>
		<ol>
			<li>
%~URL ã®`~scheme$url ~SET `file^l
â—
Set urlâ€™s scheme to "file".
</li>
			<li>
%~URL ã®`~host$url ~SET ç©º~æ–‡å­—åˆ—
â—
Set urlâ€™s host to the empty string.
</li>
			<li>
<p>
~IFï¼»
`C$V ~IN { â/, â\ }
ï¼½ï¼š
â—
If c is U+002F (/) or U+005C (\), then:
</p>
				<ol>
					<li>
~IFï¼»
`C$V ~EQ â\
ï¼½
â‡’
`æ¤œè¨¼~error$( `invalid-reverse-solidus$err )
â—
If c is U+005C (\), invalid-reverse-solidus validation error.
</li>
					<li>
%state ~SET `~file~slash$st
â—
Set state to file slash state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIFï¼»
%åŸºåº• ~NEQ ~NULL
ï¼½~ANDï¼»
%åŸºåº• ã®`~scheme$url ~EQ `file^l
ï¼½ï¼š
â—
Otherwise, if base is non-null and baseâ€™s scheme is "file":
</p>
				<ol>
					<li>
%~URL ã®
â‡’ï¼ƒ
`~host$url ~SET %åŸºåº• ã®`~host$urlï¼›
`~path$url ~SET %åŸºåº• ã®`~path$urlã‚’`~cloneã™ã‚‹$ï¼›
`~query$url ~SET %åŸºåº• ã®`~query$url
â—
Set urlâ€™s host to baseâ€™s host, urlâ€™s path to a clone of baseâ€™s path, and urlâ€™s query to baseâ€™s query.
</li>
					<li>
~IFï¼»
`C$V ~EQ â?
ï¼½
â‡’ï¼ƒ
%~URL ã®`~query$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `~query$st
â—
If c is U+003F (?), then set urlâ€™s query to the empty string and state to query state.
</li>

					<li>
~ELIFï¼»
`C$V ~EQ â#
â‡’ï¼ƒ
%~URL ã®`ç´ ç‰‡$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `ç´ ç‰‡$st
â—
Otherwise, if c is U+0023 (#), set urlâ€™s fragment to the empty string and state to fragment state.
</li>
					<li>
<p>
~ELIFï¼»
`C$V ~NEQ `EOF$i
ï¼½ï¼š
â—
Otherwise, if c is not the EOF code point:
</p>
						<ol>
							<li>
%~URL ã®`~query$url ~SET ~NULL
â—
Set urlâ€™s query to null.
</li>
							<li>
~IFï¼»
ä¸¦ã³ï¼»
`C$V, `C1$V, `C2$V
ï¼½ã¯`~drive_letterã‹ã‚‰é–‹å§‹ã—ã¦$ã„ãªã„
ï¼½
â‡’
%~URL ã®`~pathã‚’çŸ­ç¸®ã™ã‚‹$
â—
If the code point substring from pointer to the end of input does not start with a Windows drive letter, then shorten urlâ€™s path.
</li>
							<li>
<p>
~ELSE
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `file-invalid-Windows-drive-letter$err )ï¼›
%~URL ã®`~path$url ~SET Â« Â»
â—
Otherwise:
â€¢ File-invalid-Windows-drive-letter validation error.
â€¢ Set urlâ€™s path to Â« Â».
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
~drive_letterç”¨ã®ï¼ˆ~platformã«ä¾å­˜ã—ãªã„ï¼‰éå»äº’æ›å¯¾å‡¦ã§ã‚ã‚‹ã€‚
â—
This is a (platform-independent) Windows drive letter quirk.
</p>
							</li>
							<li>
%~pointer ~DECBY 1ï¼›
â—
â†“</li>
							<li>
%state ~SET `~path$st
â—
Set state to path state and decrease pointer by 1.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~ELSE
â‡’ï¼ƒ
%~pointer ~DECBY 1ï¼›
%state ~SET `~path$st
â—
Otherwise, set state to path state, and decrease pointer by 1.
</li>
		</ol>
	</dd>

<!--% file-slash-state -->
	<dt>`~file~slash@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IFï¼»
`C$V ~IN { â/, â\ }
ï¼½ï¼š
â—
If c is U+002F (/) or U+005C (\), then:
</p>
				<ol>
					<li>
~IFï¼»
`C$V ~EQ â\
ï¼½
â‡’
`æ¤œè¨¼~error$( `invalid-reverse-solidus$err )
â—
If c is U+005C (\), invalid-reverse-solidus validation error.
</li>
					<li>
%state ~SET `~file~host$st
â—
Set state to file host state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSEï¼š
â—
Otherwise:
</p>
				<ol>
					<li>
<p>
~IFï¼»
%åŸºåº• ~NEQ ~NULL
ï¼½~ANDï¼»
%åŸºåº• ã®`~scheme$url ~EQ `file^l
ï¼½ï¼š
â—
If base is non-null and baseâ€™s scheme is "file", then:
</p>
						<ol>
							<li>
%~URL ã®`~host$url ~SET %åŸºåº• ã®`~host$url
â—
Set urlâ€™s host to baseâ€™s host.
</li>
							<li>
<p>
~IFï¼»
ä¸¦ã³ï¼»
`C$V, `C1$V, `C2$V
ï¼½ã¯`~drive_letterã‹ã‚‰é–‹å§‹ã—ã¦$ã„ãªã„
ï¼½~ANDï¼»ï¼»
%åŸºåº• ã®`~path$url[ 0 ]
ï¼½ã¯`æ­£è¦åŒ–-æ¸ˆã¿~drive_letter$ã§ã‚ã‚‹
ï¼½
â‡’
%~URL ã®`~path$urlã«ï¼»
%åŸºåº• ã®`~path$url[ 0 ]
ï¼½ã‚’`ä»˜åŠ ã™ã‚‹$
â—
If the code point substring from pointer to the end of input does not start with a Windows drive letter and baseâ€™s path[0] is a normalized Windows drive letter, then append baseâ€™s path[0] to urlâ€™s path.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
~drive_letterç”¨ã®ï¼ˆ~platformã«ä¾å­˜ã—ãªã„ï¼‰éå»äº’æ›å¯¾å‡¦ã§ã‚ã‚‹ã€‚
â—
This is a (platform-independent) Windows drive letter quirk.
</p>
							</li>
						</ol>
					</li>
					<li>
%~pointer ~DECBY 1
â—
â†“</li>
					<li>
%state ~SET `~path$st
â—
Set state to path state, and decrease pointer by 1.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% file-host-state -->
	<dt>`~file~host@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IFï¼»
`C$V ~IN { `EOF$i, â/, â\, â?, â# }
ï¼½ï¼š
â—
If c is the EOF code point, U+002F (/), U+005C (\), U+003F (?), or U+0023 (#), thenï¼¼
</p>
				<ol>
					<li>
%~pointer ~DECBY 1
â—
decrease pointer by 1 and then:ï¼¼
</li>
					<li>
<p>
~IFï¼»
%ä¸Šæ›¸state ~EQ Îµ
ï¼½~ANDï¼»
%~buffer ã¯`~drive_letter$ã§ã‚ã‚‹
ï¼½
â‡’ï¼ƒ
`æ¤œè¨¼~error$( `file-invalid-Windows-drive-letter-host$err )ï¼›
%state ~SET `~path$st
â—
If state override is not given and buffer is a Windows drive letter, file-invalid-Windows-drive-letter-host validation error, set state to path state.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
~drive_letterç”¨ã®ï¼ˆ~platformã«ä¾å­˜ã—ãªã„ï¼‰éå»äº’æ›å¯¾å‡¦ã§ã‚ã‚‹ã€‚
ã“ã“ã§ã¯ %~buffer ã¯è¨­å®šã—ç›´ã•ã‚Œãšï¼Œä»£ã‚ã‚Šã«`~path$stã®ä¸­ã§åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
This is a (platform-independent) Windows drive letter quirk. buffer is not reset here and instead used in the path state.
</p>
					</li>
					<li>
<p>
~ELIFï¼»
%~buffer ~EQ ç©º~æ–‡å­—åˆ—
ï¼½ï¼š
â—
Otherwise, if buffer is the empty string, then:
</p>
						<ol>
							<li>
%~URL ã®`~host$url ~SET ç©º~æ–‡å­—åˆ—
â—
Set urlâ€™s host to the empty string.
</li>
							<li>
~IFï¼»
%ä¸Šæ›¸state ~NEQ Îµ
ï¼½
â‡’
~RET
â—
If state override is given, then return.
</li>
							<li>
%state ~SET `~pathé–‹å§‹$st
â—
Set state to path start state.
</li>
						</ol>
					</li>
					<li>
<p>
~ELSEï¼š
â—
Otherwise, run these steps:
</p>
						<ol>
							<li>
%~host ~LET
`~hostæ§‹æ–‡è§£æå™¨$( %~buffer, ~ISï¼» %~URL ã¯`ç‰¹åˆ¥$ã§ãªã„ï¼½ )
â—
Let host be the result of host parsing buffer with url is not special.
</li>
							<li>
~IFï¼»
%~host ~EQ `å¤±æ•—^i
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If host is failure, then return failure.
</li>
							<li>
~IFï¼»
%~host ~EQ `localhost^l
ï¼½
â‡’
%~host ~SET ç©º~æ–‡å­—åˆ—
â—
If host is "localhost", then set host to the empty string.
</li>
							<li>
%~URL ã®`~host$url ~SET %~host
â—
Set urlâ€™s host to host.
</li>
							<li>
~IFï¼»
%ä¸Šæ›¸state ~NEQ Îµ
ï¼½
â‡’
~RET
â—
If state override is given, then return.
</li>
							<li>
%~buffer ~SET ç©º~æ–‡å­—åˆ—
â—
Set buffer to the empty string andï¼¼
</li>
							<li>
%state ~SET `~pathé–‹å§‹$st
â—
state to path start state.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~ELSE
â‡’
%~buffer ~APPEND `C$V
â—
Otherwise, append c to buffer.
</li>
		</ol>
	</dd>

<!--% path-start-state -->
	<dt>`~pathé–‹å§‹@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IFï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼½ï¼š
â—
If url is special, then:
</p>
				<ol>
					<li>
~IFï¼»
`C$V ~EQ â\
ï¼½
â‡’
`æ¤œè¨¼~error$( `invalid-reverse-solidus$err )
â—
If c is U+005C (\), invalid-reverse-solidus validation error.
</li>
					<li>
~IFï¼»
`C$V ~NIN { â/, â\ }
ï¼½
â‡’
%~pointer ~DECBY 1
â—
Set state to path state.
â—
If c is neither U+002F (/) nor U+005C (\), then decrease pointer by 1.
</li>
					<li>
%state ~SET `~path$st
â—
â†‘</li>
				</ol>
			</li>
			<li>
~ELIFï¼»
%ä¸Šæ›¸state ~EQ Îµ
ï¼½~ANDï¼»
`C$V ~EQ â?
ï¼½
â‡’ï¼ƒ
%~URL ã®`~query$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `~query$st
â—
Otherwise, if state override is not given and c is U+003F (?), set urlâ€™s query to the empty string and state to query state.
</li>
			<li>
~ELIFï¼»
%ä¸Šæ›¸state ~EQ Îµ
ï¼½~ANDï¼»
`C$V ~EQ â#
ï¼½
â‡’ï¼ƒ
%~URL ã®`ç´ ç‰‡$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `ç´ ç‰‡$st
â—
Otherwise, if state override is not given and c is U+0023 (#), set urlâ€™s fragment to the empty string and state to fragment state.
</li>
			<li>
<p>
~ELIFï¼»
`C$V ~NEQ `EOF$i
ï¼½ï¼š
â—
Otherwise, if c is not the EOF code point:
</p>
				<ol>
					<li>
~IFï¼»
`C$V ~NEQ â/
ï¼½
â‡’
%~pointer ~DECBY 1
â—
Set state to path state.
â—
If c is not U+002F (/), then decrease pointer by 1.
</li>
					<li>
%state ~SET `~path$st
â—
â†‘</li>
				</ol>
			</li>
			<li>
~ELIFï¼»
%ä¸Šæ›¸state ~NEQ Îµ
ï¼½~ANDï¼»
%~URL ã®`~host$url ~EQ ~NULL
ï¼½
â‡’
%~URL ã®`~path$urlã«ç©º~æ–‡å­—åˆ—ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Otherwise, if state override is given and urlâ€™s host is null, append the empty string to urlâ€™s path.
</li>
		</ol>
	</dd>

<!--% path-state -->
	<dt>`~path@st</dt>
	<dd>
		<ol>
			<li>
%~slashã‹ ~LET ~ISï¼»
`C$V ~EQ â/
ï¼½~ORï¼»ï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼½~ANDï¼»
`C$V ~EQ â\
ï¼½ï¼½
â—
â†“</li>
			<li>
<p>
~IFï¼»
~ORâ†“
ï¼½â€¦
â—
If one of the following is true:
</p>
				<ul>
					<li>
`C$V ~EQ `EOF$i
â—
c is the EOF code point or U+002F (/)
â†“</li>
					<li>
%~slashã‹ ~EQ ~T
â—
url is special and c is U+005C (\)
</li>
					<li>
ï¼»
%ä¸Šæ›¸state ~EQ Îµ
ï¼½~ANDï¼»
`C$V ~IN { â?, â# }
ï¼½ï¼š
â—
state override is not given and c is U+003F (?) or U+0023 (#)
</li>
				</ul>
<p>
â€¦ãªã‚‰ã°ï¼š
â—
then:
</p>
				<ol>
					<li>
~IFï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹
ï¼½~ANDï¼»
`C$V ~EQ â\
ï¼½
â‡’
`æ¤œè¨¼~error$( `invalid-reverse-solidus$err )
â—
If url is special and c is U+005C (\), invalid-reverse-solidus validation error.
</li>
					<li>
<p>
~IFï¼»
%~buffer ã¯`äºŒé‡-~dot~URL~pathåŒºåˆ†$ã§ã‚ã‚‹
ï¼½ï¼š
â—
If buffer is a double-dot URL path segment, then:
</p>
						<ol>
							<li>
%~URL ã®`~pathã‚’çŸ­ç¸®ã™ã‚‹$
â—
Shorten urlâ€™s path.
</li>
							<li>
<p>
~IFï¼»
%~slashã‹ ~EQ ~F
ï¼½
â‡’
%~URL ã®`~path$urlã«ç©º~æ–‡å­—åˆ—ã‚’`ä»˜åŠ ã™ã‚‹$
â—
If neither c is U+002F (/), nor url is special and c is U+005C (\), append the empty string to urlâ€™s path.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
å…¥åŠ›ãŒ `/usr/..^l ãªã‚‰ï¼Œçµæœã¯ `/^l ã«ãªã‚Šï¼Œ
~pathãŒç„¡ããªã‚‹ã‚ã‘ã§ã¯ãªã„ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
â—
This means that for input /usr/.. the result is / and not a lack of a path.
</p>
							</li>
						</ol>
					</li>
					<li>
~ELIFï¼»
%~buffer ã¯`å˜-~dot~URL~pathåŒºåˆ†$ã§ã‚ã‚‹
ï¼½
â‡’
~IFï¼»
%~slashã‹ ~EQ ~F
ï¼½
â‡’
%~URL ã®`~path$urlã«ç©º~æ–‡å­—åˆ—ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Otherwise, if buffer is a single-dot URL path segment and if neither c is U+002F (/), nor url is special and c is U+005C (\), append the empty string to urlâ€™s path.
</li>
					<li>
<p>
~ELSEï¼š
â—
Otherwise, if buffer is not a single-dot URL path segment, then:
</p>
						<ol>
							<li>
<p>
~IFï¼»
%~URL ã®`~scheme$url ~EQ `file^l
ï¼½~ANDï¼»
%~URL ã®`~path$urlã¯`ç©º$ã§ã‚ã‚‹
ï¼½~ANDï¼»
%~buffer ã¯`~drive_letter$ã§ã‚ã‚‹
ï¼½
â‡’
%~buffer ã® 2 å€‹ç›®ã®~cpã‚’ â: ã«ç½®æ›ã™ã‚‹
â—
If urlâ€™s scheme is "file", urlâ€™s path is empty, and buffer is a Windows drive letter, then replace the second code point in buffer with U+003A (:).
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
~drive_letterç”¨ã®ï¼ˆ~platformã«ä¾å­˜ã—ãªã„ï¼‰éå»äº’æ›å¯¾å‡¦ã§ã‚ã‚‹ã€‚
â—
This is a (platform-independent) Windows drive letter quirk.
</p>
							</li>
							<li>
%~URL ã®`~path$urlã« %~buffer ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Append buffer to urlâ€™s path.
</li>
						</ol>
					</li>
					<li>
%~buffer ~SET ç©º~æ–‡å­—åˆ—
â—
Set buffer to the empty string.
</li>
					<li>
~IFï¼»
`C$V ~EQ â?
ï¼½
â‡’ï¼ƒ
%~URL ã®`~query$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `~query$st
â—
If c is U+003F (?), then set urlâ€™s query to the empty string and state to query state.
</li>
					<li>
~IFï¼»
`C$V ~EQ â#
ï¼½
â‡’ï¼ƒ
%~URL ã®`ç´ ç‰‡$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `ç´ ç‰‡$st
â—
If c is U+0023 (#), then set urlâ€™s fragment to the empty string and state to fragment state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSEï¼š
â—
Otherwise, run these steps:
</p>
				<ol>
					<li>
`~URLå˜ä½ã‹ã©ã†ã‹æ¤œè¨¼ã™ã‚‹$
â—
If c is not a URL code point and not U+0025 (%), invalid-URL-unit validation error.
â—
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, invalid-URL-unit validation error.
</li>
					<li>
%~buffer ~APPEND
`~cpã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹$( `C$V, `~path~percent-ç¬¦å·åŒ–-é›†åˆ$ )
â—
UTF-8 percent-encode c using the path percent-encode set and append the result to buffer.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% opaque path state -->
	<dt>`ä¸é€æ˜~path@st</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
`C$V ~EQ â?
ï¼½
â‡’ï¼ƒ
%~URL ã®`~query$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `~query$st
â—
If c is U+003F (?), then set urlâ€™s query to the empty string and state to query state.
</li>
			<li>
~ELIFï¼»
`C$V ~EQ â#
ï¼½
â‡’ï¼ƒ
%~URL ã®`ç´ ç‰‡$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `ç´ ç‰‡$st
â—
Otherwise, if c is U+0023 (#), then set urlâ€™s fragment to the empty string and state to fragment state.
</li>
			<li>
<p>
~ELIFï¼»
`C$V ~NEQ `EOF$i
ï¼½ï¼š
â—
Otherwise:
</p>
				<ol>
					<li>
`~URLå˜ä½ã‹ã©ã†ã‹æ¤œè¨¼ã™ã‚‹$
â—
If c is not the EOF code point, not a URL code point, and not U+0025 (%), invalid-URL-unit validation error.
â—
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, invalid-URL-unit validation error.
</li>
					<li>
%~URL ã®`~path$url ~APPEND
`~cpã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹$( `C$V, `~C0åˆ¶å¾¡æ–‡å­—~percent-ç¬¦å·åŒ–-é›†åˆ$ )
â—
If c is not the EOF code point, UTF-8 percent-encode c using the C0 control percent-encode set and append the result to urlâ€™s path.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% query-state -->
	<dt>`~query@st</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
%~URL ã¯`ç‰¹åˆ¥$ã§ãªã„
ï¼½~ORï¼»
%~URL ã®`~scheme$url ~IN { `ws^l, `wss^l }
ï¼½
â‡’
%ç¬¦å·åŒ–æ³• ~SET `~UTF-8$
â—
If encoding is not UTF-8 and one of the following is true:
â€¢ url is not special
â€¢ urlâ€™s scheme is "ws" or "wss"
â—
then set encoding to UTF-8.
</li>
			<li>
<p>
~IFï¼»
~ORâ†“
ï¼½â€¦
â—
If one of the following is true:
</p>
				<ul>
					<li>
ï¼»
%ä¸Šæ›¸state ~EQ Îµ
ï¼½~ANDï¼»
`C$V ~EQ â#
ï¼½
â—
state override is not given and c is U+0023 (#)
</li>
					<li>
`C$V ~EQ `EOF$i
â—
c is the EOF code point
</li>
				</ul>
<p>
â€¦ãªã‚‰ã°ï¼š
â—
then:
</p>
				<ol>
					<li>
%~query~percent-ç¬¦å·åŒ–-é›†åˆ ~LET %~URL ã«å¿œã˜ã¦
â‡’ï¼ƒ
`ç‰¹åˆ¥$ã§ã‚ã‚‹ãªã‚‰ã° `ç‰¹åˆ¥~query~percent-ç¬¦å·åŒ–-é›†åˆ$ ï¼
~ELSE_ `~query~percent-ç¬¦å·åŒ–-é›†åˆ$
â—
Let queryPercentEncodeSet be the special-query percent-encode set if url is special; otherwise the query percent-encode set.
</li>
					<li>
<p>
%~URL ã®`~query$url ~APPEND æ¬¡ã®çµæœ
â‡’
`æ–‡å­—åˆ—ã‚’ç¬¦å·åŒ–ã—ã¦ã‹ã‚‰~percent-ç¬¦å·åŒ–ã™ã‚‹$( %ç¬¦å·åŒ–æ³•, %~buffer, %~query~percent-ç¬¦å·åŒ–-é›†åˆ )
â—
Percent-encode after encoding, with encoding, buffer, and queryPercentEncodeSet, and append the result to urlâ€™s query.
</p>

<p class="note">æ³¨è¨˜ï¼š
`~ISO-2022-JPç¬¦å·åŒ–å™¨$ãŒ~statefulã§ã‚ã‚‹ã“ã¨ã«å› ã‚Šã€
ã“ã®æ¼”ç®—ã¯~cpã”ã¨ã«ã¯å‘¼å‡ºã›ãªã„ã€‚
â—
This operation cannot be invoked code-point-for-code-point due to the stateful ISO-2022-JP encoder.
</p>
					</li>
					<li>
%~buffer ~SET ç©º~æ–‡å­—åˆ—
â—
Set buffer to the empty string.
</li>
					<li>
~IFï¼»
`C$V ~EQ â#
ï¼½
â‡’ï¼ƒ
%~URL ã®`ç´ ç‰‡$url ~SET ç©º~æ–‡å­—åˆ—ï¼›
%state ~SET `ç´ ç‰‡$st
â—
If c is U+0023 (#), then set urlâ€™s fragment to the empty string and state to fragment state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIFï¼»
`C$V ~NEQ `EOF$i
ï¼½ï¼š
â—
Otherwise, if c is not the EOF code point:
</p>
				<ol>
					<li>
`~URLå˜ä½ã‹ã©ã†ã‹æ¤œè¨¼ã™ã‚‹$
â—
If c is not a URL code point and not U+0025 (%), invalid-URL-unit validation error.
â—
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, invalid-URL-unit validation error.
</li>
					<li>
%~buffer ~APPEND `C$V
â—
Append c to buffer.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% fragment-state -->
	<dt>`ç´ ç‰‡@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IFï¼»
`C$V ~NEQ `EOF$i
ï¼½ï¼š
â—
If c is not the EOF code point, then:
</p>
				<ol>
					<li>
`~URLå˜ä½ã‹ã©ã†ã‹æ¤œè¨¼ã™ã‚‹$
â—
If c is not a URL code point and not U+0025 (%), invalid-URL-unit validation error.
â—
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, invalid-URL-unit validation error.
</li>
					<li>
%~URL ã®`ç´ ç‰‡$url ~APPEND
`~cpã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹$( `C$V, `ç´ ç‰‡~percent-ç¬¦å·åŒ–-é›†åˆ$ )
â—
UTF-8 percent-encode c using the fragment percent-encode set and append the result to urlâ€™s fragment.
</li>
				</ol>
			</li>
		</ol>
	</dd>
</dl>

<p>
â—
â†‘â†‘Return url.
</p>
</div>

<hr>

<div class="algo">
<p>
`~URLã®~usernameã‚’è¨­å®šã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~URL$ %~URL, æ–‡å­—åˆ— %~username )
ã«å¯¾ã—
â‡’
%~URL ã®`~username$url ~SET
`æ–‡å­—åˆ—ã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹$( %~username, `~userinfo~percent-ç¬¦å·åŒ–-é›†åˆ$ )
â—
To set the username given a url and username, set urlâ€™s username to the result of running UTF-8 percent-encode on username using the userinfo percent-encode set.
</p>
</div>

<div class="algo">
<p>
`~URLã®~passwordã‚’è¨­å®šã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~URL$ %~URL, æ–‡å­—åˆ— %~password )
ã«å¯¾ã—
â‡’
%~URL ã®`~password$url ~SET
`æ–‡å­—åˆ—ã‚’~UTF-8~percent-ç¬¦å·åŒ–ã™ã‚‹$( %~password, `~userinfo~percent-ç¬¦å·åŒ–-é›†åˆ$ )
â—
To set the password given a url and password, set urlâ€™s password to the result of running UTF-8 percent-encode on password using the userinfo percent-encode set.
</p>
</div>

		</section>
		<section id="url-serializing">
<h3 title="URL serializing">4.5. ~URLã®ç›´åˆ—åŒ–-æ³•</h3>

<div class="algo">
<p>
`~URLç›´åˆ—åŒ–å™¨@
ã¯ã€
æ‰€ä¸ã®
( `~URL$ %~URL, %ç´ ç‰‡ã¯é™¤å¤–ã™ã‚‹ã‹ ~IN { `ç´ ç‰‡ã¯é™¤å¤–ã™ã‚‹@i, Îµ }ï¼ˆçœç•¥æ™‚ã¯ Îµ ï¼‰ )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã›ãŸçµæœã®`~ASCIIæ–‡å­—åˆ—$ã‚’è¿”ã™ï¼š
â—
The URL serializer takes a URL url, with an optional boolean exclude fragment (default false), and then runs these steps. They return an ASCII string.
</p>

<ol>
	<li>
%å‡ºåŠ› ~LET
ç©º~æ–‡å­—åˆ— ~APPEND %~URL ã®`~scheme$url
~APPEND â:
â—
Let output be urlâ€™s scheme and U+003A (:) concatenated.
</li>
	<li>
<p>
~IFï¼»
%~URL ã®`~host$url ~NEQ ~NULL
ï¼½ï¼š
â—
If urlâ€™s host is non-null:
</p>
		<ol>
			<li>
%å‡ºåŠ› ~APPEND `//^l
â—
Append "//" to output.
</li>
			<li>
<p>
~IFï¼»
%~URL ã¯`è³‡æ ¼è¨¼ã‚’å«ã‚“ã§$ã„ã‚‹
ï¼½ï¼š
â—
If url includes credentials, then:
</p>
				<ol>
					<li>
%å‡ºåŠ› ~APPEND %~URL ã®`~username$url
â—
Append urlâ€™s username to output.
</li>
					<li>
~IFï¼»
%~URL ã®`~password$url ~NEQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’
%å‡ºåŠ› ~APPEND â:
~APPEND %~URL ã®`~password$url
â—
If urlâ€™s password is not the empty string, then append U+003A (:), followed by urlâ€™s password, to output.
</li>
					<li>
%å‡ºåŠ› ~APPEND â@
â—
Append U+0040 (@) to output.
</li>
				</ol>
			</li>
			<li>
%å‡ºåŠ› ~APPEND `~hostã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %~URL ã®`~host$url )
â—
Append urlâ€™s host, serialized, to output.
</li>
			<li>
~IFï¼»
%~URL ã®`~port$url ~NEQ ~NULL
ï¼½
â‡’
%å‡ºåŠ› ~APPEND â:
~APPEND `æ•´æ•°ã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %~URL ã®`~port$url )
â—
If urlâ€™s port is non-null, append U+003A (:) followed by urlâ€™s port, serialized, to output.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
%~URL ã®`~host$url ~EQ ~NULL
ï¼½~ANDï¼»
%~URL ã¯`ä¸é€æ˜ãª~path$ã‚’æœ‰ã•ãªã„
ï¼½~ANDï¼»
%~URL ã®`~path$urlã®`~size$ ~GT 1
ï¼½~ANDï¼»
%~URL ã®`~path$url[ 0 ] ~EQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’
%å‡ºåŠ› ~APPEND â/
~APPEND â.
â—
If urlâ€™s host is null, url does not have an opaque path, urlâ€™s pathâ€™s size is greater than 1, and urlâ€™s path[0] is the empty string, then append U+002F (/) followed by U+002E (.) to output.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
`web+demo:/.//not-a-host/^c
ã‚„
`web+demo:/path/..//not-a-host/^c
ã‚’
`æ§‹æ–‡è§£æ-ï¼ #concept-url-parser$ã—ã¦ã‹ã‚‰
`ç›´åˆ—åŒ–-ï¼ #concept-url-serializer$ã—ãŸçµæœãŒ
`web+demo://not-a-host/^c
ã«ãªã‚‹ã®ã‚’é˜²æ­¢ã™ã‚‹ï¼ˆçµæœã¯
`web+demo:/.//not-a-host/^c
ã«ãªã‚‹ï¼‰ã€‚
â—
This prevents web+demo:/.//not-a-host/ or web+demo:/path/..//not-a-host/, when parsed and then serialized, from ending up as web+demo://not-a-host/ (they end up as web+demo:/.//not-a-host/).
</p>
	</li>
	<li>
%å‡ºåŠ› ~APPEND `~URL~pathã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %~URL )
â—
Append the result of URL path serializing url to output.
</li>
	<li>
~IFï¼»
%~URL ã®`~query$url ~NEQ ~NULL
ï¼½
â‡’
%å‡ºåŠ› ~APPEND â?
~APPEND %~URL ã®`~query$url
â—
If urlâ€™s query is non-null, append U+003F (?), followed by urlâ€™s query, to output.
</li>
	<li>
~IFï¼»
%ç´ ç‰‡ã¯é™¤å¤–ã™ã‚‹ã‹ ~EQ Îµ
ï¼½~ANDï¼»
%~URL ã®`ç´ ç‰‡$url ~NEQ ~NULL
ï¼½
â‡’
%å‡ºåŠ› ~APPEND â#
~APPEND %~URL ã®`ç´ ç‰‡$url
â—
If exclude fragment is false and urlâ€™s fragment is non-null, then append U+0023 (#), followed by urlâ€™s fragment, to output.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~URL~pathã‚’ç›´åˆ—åŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~URL$ %~URL )
ã«å¯¾ã—ï¼Œ`~ASCIIæ–‡å­—åˆ—$ã‚’è¿”ã™ï¼š
â—
The URL path serializer takes a URL url and then runs these steps. They return an ASCII string.
</p>
<ol>
	<li>
~IFï¼»
%~URL ã¯`ä¸é€æ˜ãª~path$ã‚’æœ‰ã™ã‚‹
ï¼½
â‡’
~RET %~URL ã®`~path$url
â—
If url has an opaque path, then return urlâ€™s path.
</li>
	<li>
%å‡ºåŠ› ~LET ç©º~æ–‡å­—åˆ—
â—
Let output be the empty string.
</li>
	<li>
%~URL ã®`~path$urlã‚’æˆã™
~EACH( %åŒºåˆ† )
ã«å¯¾ã—
â‡’
%å‡ºåŠ› ~APPEND â/
~APPEND %åŒºåˆ†
â—
For each segment of urlâ€™s path: append U+002F (/) followed by segment to output.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

		</section>
		<section id="url-equivalence">
<h3 title="URL equivalence">4.6. ~URLã®ç­‰ä¾¡æ€§</h3>

<div class="algo">
<p>
æ‰€ä¸ã®
( `~URL$ %A, `~URL$ %B )
ãŒï¼š
</p>
<ul>
	<li>
ï¼ˆå˜ã«ï¼‰
`åŒç­‰ãª~URL@
ã§ã‚ã‚‹ã¨ã¯ã€
æ¬¡ãŒæº€ãŸã•ã‚Œã‚‹ã“ã¨ã‚’ã„ã†
â‡’
`~URLã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %A ) ~EQ `~URLã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %B )
</li>
	<li id="url-equals-exclude-fragments">
`ç´ ç‰‡ã¯é™¤å¤–ã™ã‚‹^iä¸‹ã§`åŒç­‰ãª~URL$ã§ã‚ã‚‹ã¨ã¯ã€
æ¬¡ãŒæº€ãŸã•ã‚Œã‚‹ã“ã¨ã‚’ã„ã†
â‡’
`~URLã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %A, `ç´ ç‰‡ã¯é™¤å¤–ã™ã‚‹$i ) ~EQ `~URLã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %B, `ç´ ç‰‡ã¯é™¤å¤–ã™ã‚‹$i )
</li>
</ul>
â—
To determine whether a URL A equals URL B, with an optional boolean exclude fragments (default false), run these steps:
â€¢ Let serializedA be the result of serializing A, with exclude fragment set to exclude fragments.
â€¢ Let serializedB be the result of serializing B, with exclude fragment set to exclude fragments.
â€¢ Return true if serializedA is serializedB; otherwise false.
</div>

		</section>
		<section id="origin">
<h3 title="Origin">4.7. ç”Ÿæˆå…ƒ</h3>

<p class="note">æ³¨è¨˜ï¼š
å¿…è¦ãªèƒŒæ™¯0æƒ…å ±ã«ã¤ã„ã¦ã¯ã€
`HTML^cite ã«ã‚ˆã‚‹`ç”Ÿæˆå…ƒ$ã®å®šç¾©ã‚’è¦‹ã‚ˆã€‚
`HTML$r
â—
See originâ€™s definition in HTML for the necessary background information. [HTML]
</p>

<div class="algo">
<p>
`~URL$ %~URL ã®
`ç”Ÿæˆå…ƒ@url
ã¯ã€
%~URL ã®`~scheme$urlã«å¿œã˜ã¦ï¼Œæ¬¡ã®æ‰‹ç¶šãã‚’èµ°ã‚‰ã›ã¦è¿”ã•ã‚Œã‚‹`ç”Ÿæˆå…ƒ$ã§ã‚ã‚‹ï¼š
â—
The origin of a URL url is the origin returned by running these steps, switching on urlâ€™s scheme:
</p>

<dl class="switch">
	<dt>`blob^l</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
%~URL ã®`~blob~URL~entry$url ~NEQ ~NULL
ï¼½
â‡’
~RET %~URL ã®`~blob~URL~entry$urlã®`ç’°å¢ƒ$bUã®`ç”Ÿæˆå…ƒ$enV
â—
If urlâ€™s blob URL entry is non-null, then return urlâ€™s blob URL entryâ€™s environmentâ€™s origin.
</li>
			<li>
%~path~URL ~LET `åŸºæœ¬~URLæ§‹æ–‡è§£æå™¨$( `~URL~pathã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %~URL ) )
â—
Let pathURL be the result of parsing the result of URL path serializing url.
</li>
			<li>
~IFï¼»
%~path~URL ~EQ `å¤±æ•—^i
ï¼½
â‡’
~RET æ–°ãŸãª`ä¸é€æ˜ãªç”Ÿæˆå…ƒ$
â—
If pathURL is failure, then return a new opaque origin.
</li>
			<li>
~IFï¼»
%~path~URL ã®`~scheme$url ~IN { `http^l, `https^l, `file^l }
ï¼½
â‡’
~RET %~path~URL ã®`ç”Ÿæˆå…ƒ$url
â—
If pathURLâ€™s scheme is "http", "https", or "file", then return pathURLâ€™s origin.
</li>
			<li>
~RET æ–°ãŸãª`ä¸é€æ˜ãªç”Ÿæˆå…ƒ$
â—
Return a new opaque origin.
</li>
		</ol>
	</dd>
	<dd class="example">
`blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f^l
ã®`ç”Ÿæˆå…ƒ$urlã¯ã€
`æˆåˆ†çµ„~ç”Ÿæˆå…ƒ$
( `https^l, `whatwg.org^l, ~NULL, ~NULL )
ã«ãªã‚‹ã€‚
â—
The origin of blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f is the tuple origin ("https", "whatwg.org", null, null).
</dd>

	<dt>`ftp^l</dt>
	<dt>`http^l</dt>
	<dt>`https^l</dt>
	<dt>`ws^l</dt>
	<dt>`wss^l</dt>
	<dd>
~RET `æˆåˆ†çµ„~ç”Ÿæˆå…ƒ$( %~URL ã®`~scheme$url, %~URL ã®`~host$url, %~URL ã®`~port$url, ~NULL )
â—
Return the tuple origin (urlâ€™s scheme, urlâ€™s host, urlâ€™s port, null).
</dd>

	<dt>`file^l</dt>
	<dd>
ã‚ã„ã«ãã€
ã“ã‚Œã«ã¤ã„ã¦ã¯ï¼Œ
èª­è€…ã€~UAé–‹ç™ºè€…ã€‘ã®è¡Œä½¿ã«å§”ã­ã‚‰ã‚Œã‚‹ã€‚
ç–‘ã‚ã—ã„å ´åˆã¯ã€
æ–°ãŸãª`ä¸é€æ˜ãªç”Ÿæˆå…ƒ$ã‚’è¿”ã™ã“ã¨ã€‚
â—
Unfortunate as it is, this is left as an exercise to the reader. When in doubt, return a new opaque origin.
</dd>

	<dt>ãã®ä»–</dt>
	<dd>
<p>
~RET æ–°ãŸãª`ä¸é€æ˜ãªç”Ÿæˆå…ƒ$
â—
Return a new opaque origin.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯~~å®Ÿéš›ã«ã€
ã“ã®ç¨®ã®`~URL$ã¯ï¼Œè‡ªèº«ã¨`åŒä¸€-ç”Ÿæˆå…ƒ$ã«ãªã‚Šå¾—ãªã„ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
ã€æ¯å›ï¼Œç•°ãªã‚‹çµæœãŒè¿”ã•ã‚Œã‚‹ã®ã§ã€‚ã€‘
â—
This does indeed mean that these URLs cannot be same origin with themselves.
</p>
	</dd>
</dl>
</div>

		</section>
		<section id="url-rendering">
<h3 title="URL rendering">4.8. ~URLã®å…·ç¾åŒ–-æ³•</h3>

<p>
`~URL$ã‚’è¡¨ç¤ºã™ã‚‹ç›®çš„ãŒï¼Œé¦–ã«ï¼»
~securityã‚„ä¿¡ç”¨ã«é–¢ã™ã‚‹è£å®šã‚’åˆ©ç”¨è€…ãŒç‚ºã™ã“ã¨
ï¼½ã«ã‚ã‚‹ã¨ãã¯ã€ï¼»
`~URLç›´åˆ—åŒ–å™¨$ã«ã‹ã‘ãŸå½¢
ï¼½ã«ä»¥ä¸‹ã«è¿°ã¹ã‚‹æ”¹å¤‰ã‚’åŠ ãˆãŸä¸Šã§å…·ç¾åŒ–ã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹ã€‚
ä¾‹ãˆã°ã€
åˆ©ç”¨è€…ã¯ï¼»
~URL~barå†…ã«å…·ç¾åŒ–ã•ã‚ŒãŸ~URL
ï¼½ã«åŸºã„ã¦ï¼»
ä¿¡ç”¨ã«é–¢ã™ã‚‹è£å®šã‚’ç‚ºã™
ï¼½ã‚‚ã®ã¨äºˆæœŸã•ã‚Œã‚‹ã€‚
â—
A URL should be rendered in its serialized form, with modifications described below, when the primary purpose of displaying a URL is to have the user make a security or trust decision. For example, users are expected to make trust decisions based on a URL rendered in the browser address bar.
</p>

<p class="trans-note">ã€
â€œå…·ç¾åŒ–ï¼ˆ `rendering^en ï¼‰â€ ã«ã¯ã€
~~æç”»ã«é™ã‚‰ãšï¼Œ~~éŸ³å£°åŒ–ãªã©ã‚‚å«ã¾ã‚Œã‚‹
â€” ãã‚Œã‚‰ã®å–æ‰±ã„ã«ã¯å¤šå°‘ç•°ãªã‚‹æ‰€ã‚‚ã‚ã‚ã†ãŒï¼ŒåŒæ§˜ãªè¶£æ—¨ã«å¾“ã†ã“ã¨ã«ãªã‚‹ã€‚
ã€‘</p>

			<section id="url-rendering-simplification">
<h4 title="Simplify non-human-readable or irrelevant components">4.8.1. ãƒ’ãƒˆãŒèª­ã‚ãªã„ï¼é–¢é€£ã—ãªã„æˆåˆ†ã‚’å˜ç´”~åŒ–ã™ã‚‹</h4>

<p>
~securityã«é–¢é€£ãªæƒ…å ±ã«å¯¾ã—ï¼»
å½è£…ã™ã‚‹ï¼æ°—ã‚’ãã‚‰ã™
ï¼½æ©Ÿä¼šã‚’ä¾›ã—å¾—ã‚‹æˆåˆ†ã‚’é™¤å»ã™ã‚‹
â€” ~browserã¯ï¼š
â—
Remove components that can provide opportunities for spoofing or distract from security-relevant information:
</p>

<ul>
	<li>
ï¼»
æœ«ç«¯~åˆ©ç”¨è€…ãŒï¼Œ~hostã¨~URLã‚’æˆã™ä»–ã®å„éƒ¨ï¼ˆ`~path$urlãªã©ï¼‰ã¨ã‚’åˆ¤åˆ¥ã§ãã‚‹
ï¼½ã“ã¨ãŒé‡è¦ã«ãªã‚‹æ‰€ã§ã¯ã€
~URLã®`~host$urlã®ã¿ã‚’å…·ç¾åŒ–ã—ã¦ã‚‚ãƒ¨ã‚¤ã€‚
`ç™»éŒ²-å¯èƒ½ãª~domain$ã«æ³¨ç›®ã‚’å¼•ãã‚ˆã†ï¼Œ~hostã‚’æ›´ã«å˜ç´”~åŒ–ã™ã‚‹ã“ã¨ã‚’è€ƒæ…®ã—ã¦ã‚‚ãƒ¨ã‚¤ã€‚
ä¾‹ãˆã°ã€
é ­éƒ¨ã‚’æˆã™`~domain~label$ï¼»
`www^c ã‚„ `m^c
ï¼½ã‚’çœç•¥ã—ã¦ï¼Œ~hostã‚’å˜ç´”~åŒ–ã—ã¦ã‚‚ãƒ¨ã‚¤ã€‚
ã‚ã‚‹ã„ã¯ï¼Œãã®`ç™»éŒ²-å¯èƒ½ãª~domain$ã®ã¿ã‚’è¡¨ç¤ºã—ã¦ã€
~subdomain
ï¼ˆä¾‹ï¼š `https://examplecorp.attacker.com/^c ï¼‰
ã«ã‚ˆã‚‹å½è£…~æ©Ÿä¼šã‚’é™¤å»ã—ã¦ã‚‚ãƒ¨ã‚¤ã€‚
â—
Browsers may render only a URLâ€™s host in places where it is important for end users to distinguish between the host and other parts of the URL such as the path. Browsers may consider simplifying the host further to draw attention to its registrable domain. For example, browsers may omit a leading www or m domain label to simplify the host, or display its registrable domain only to remove spoofing opportunities posted by subdomains (e.g., https://examplecorp.attacker.com/).
</li>
	<li>
`~URL$ã®ï¼»
`~username$url, `~password$url
ï¼½ã‚’å…·ç¾åŒ–ã™ã‚‹ãƒ™ã‚­ã§ãªã„
â€” ãã‚Œã‚‰ã¯ `~URL$ã®`~host$urlã«~~èª¤èªã•ã‚Œå¾—ã‚‹ã®ã§
ï¼ˆä¾‹ï¼š `https://examplecorp.com~atã€…attacker.example/^c ï¼‰ã€‚
â—
Browsers should not render a URLâ€™s username and password, as they can be mistaken for a URLâ€™s host (e.g., https://examplecorp.com@attacker.example/).
</li>
	<li>
~URLã‚’`~scheme$urlã‚’ä¼´ã‚ãšã«å…·ç¾åŒ–ã—ã¦ã‚‚ãƒ¨ã‚¤
â€” ãã®ã‚ˆã†ãªè¡¨ç¤ºã‚’å˜ç‹¬ã®~schemeã«é™ã‚Šè¨±å¯ã—ã¦ã„ã‚‹å ´åˆã«ã¯
ï¼ˆ~secureãªç”Ÿæˆå…ƒ~ç”¨ã«é™ã‚Šå¯èƒ½åŒ–ã•ã‚Œã‚‹ï¼Œ `https://^c ã‚’çœç•¥ã™ã‚‹~browserç‰¹èƒ½ãªã©ï¼‰ã€‚
ä»–ã®å ´åˆã€
~schemeã‚’ï¼»
ãƒ’ãƒˆãŒèª­ã‚ã‚‹æ–‡å­—åˆ—ï¼ˆä¾‹ï¼š â€œ~secureã§ãªã„â€ ï¼‰
ã‚„~securityæŒ‡ç¤ºå­~icon, ã“ã‚Œã‚‰ä¸¡è€…
ï¼½ã§ç½®æ›ã—ãŸã‚Šè£œè¶³ã—ã¦ã‚‚ãƒ¨ã‚¤ã€‚
â—
Browsers may render a URL without its scheme if the display surface only ever permits a single scheme (such as a browser feature that omits https:// because it is only enabled for secure origins). Otherwise, the scheme may be replaced or supplemented with a human-readable string (e.g., "Not secure"), a security indicator icon, or both.
</li>
</ul>

			</section>
			<section id="url-rendering-elision">
<h4 title="Elision">4.8.2. ~URLã‚’çœãã¨ã</h4>

<p>
è¡¨ç¤ºãŒç‹­ã„ã¨ãã«~URLã®ä¸€éƒ¨ã‚’çœãã¨ãã¯ã€ï¼»
åˆ©ç”¨è€…ãŒ~securityã«é–¢ã™ã‚‹è£å®šã‚’ç‚ºã™ã¨ãã«ï¼Œèª¤ã‚Šã¸å°ãã“ã¨
ï¼½ã‚’æ³¨æ„æ·±ãé¿ã‘ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹
â€” ~browserã¯ï¼š
â—
In a space-constrained display, URLs should be elided carefully to avoid misleading the user when making a security decision:
</p>

<ul>
	<li>
~URLã‚’å…·ç¾åŒ–ã™ã‚‹ã¨ãã¯ã€
å°‘ãªãã¨ã‚‚`ç™»éŒ²-å¯èƒ½ãª~domain$ã¯ç¤ºã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹
ï¼ˆä¾‹ï¼š
`https://not-really-examplecorp.com/^c
ã‚’èª­è¾¼ã‚€ã¨ãï¼Œ
`...examplecorp.com^c
ã¨ç¤ºã•ã‚Œã‚‹ã®ã‚’é¿ã‘ã‚‹ãŸã‚ï¼‰ã€‚
â—
Browsers should ensure that at least the registrable domain can be shown when the URL is rendered (to avoid showing, e.g., ...examplecorp.com when loading https://not-really-examplecorp.com/).
</li>
	<li>
å…¨éƒ¨çš„ãª`~host$urlã‚’å…·ç¾åŒ–ã§ããªã„ã¨ãã¯ã€
`~domain~labelç¾¤$ã‚’æœ€ä½~levelã®ã‚‚ã®ã‹ã‚‰çœããƒ™ã‚­ã§ã‚ã‚‹ã€‚
ä¾‹ãˆã° `examplecorp.com.evil.com^c ã¯ã€
`examplecorp.com...^c ã§ã¯ãªãï¼Œ
`...com.evil.com^c ã®ã‚ˆã†ã«çœããƒ™ã‚­ã§ã‚ã‚‹
ï¼ˆåŒæ–¹å‘-~textã®å ´åˆã€
æœ€ä½~levelã®~domain~labelã¯å·¦ç«¯ã«ç¾ã‚Œãªã„ã“ã¨ã‚‚ã‚ã‚‹ã“ã¨ã«æ³¨æ„ï¼‰ã€‚
â—
When the full host cannot be rendered, browsers should elide domain labels starting from the lowest-level domain label. For example, examplecorp.com.evil.com should be elided as ...com.evil.com, not examplecorp.com.... (Note that bidirectional text means that the lowest-level domain label may not appear on the left.)
</li>
</ul>

			</section>
			<section id="url-rendering-i18n">
<h4 title="Internationalization and special characters">4.8.3. å›½éš›-åŒ–ã¨ç‰¹æ®Š~æ–‡å­—</h4>

<p>
ï¼»
å›½éš›-åŒ–~domainåï¼ˆ IDN ï¼‰,
ç‰¹æ®Š~æ–‡å­—,
åŒæ–¹å‘-~text
ï¼½ã¯ã€
å½è£…ã‚’é˜²æ­¢ã™ã‚‹ã‚ˆã†æ³¨æ„ã—ã¦å–æ‰±ã†ãƒ™ã‚­ã§ã‚ã‚‹
â€” ~browserã¯ï¼š
â—
Internationalized domain names (IDNs), special characters, and bidirectional text should be handled with care to prevent spoofing:
</p>

<ul>
	<li>
<p>
`~URL$ã®`~host$url %~host ã‚’æ¬¡ã®çµæœã‚’åˆ©ç”¨ã—ã¦å…·ç¾åŒ–ã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹
â‡’
`~domainã‚’~UnicodeåŒ–ã™ã‚‹$( %~host, ~F )
â—
Browsers should render a URLâ€™s host by running domain to Unicode with the URLâ€™s host and false.
</p>

<p class="note">æ³¨è¨˜ï¼š
æ§˜ã€…ãªæ–‡å­—ãŒ `homograph^en ã€åŒå‹æ„ç¾©èªï¼åŒå‹~glyphã€‘å½è£…~æ”»æ’ƒã«åˆ©ç”¨ã•ã‚Œå¾—ã‚‹ã“ã¨ã«æ³¨æ„ã€‚
åˆ©ç”¨-ä¸­ã«ã‚ã‚‹æ··åŒã•ã‚Œæ˜“ã„æ–‡å­—ã‚’æ¤œå‡ºã—ã¦è­¦å‘Šã™ã‚‹ã“ã¨ã‚’è€ƒæ…®ã™ã‚‹ã“ã¨ã€‚
`IDNFAQ$r
`UTS39$r
â—
Various characters can be used in homograph spoofing attacks. Consider detecting confusable characters and warning when they are in use. [IDNFAQ] [UTS39]
</p>
	</li>
	<li>
~URLãŒåŒæ–¹å‘-~textã‚’åŒ…å«ã™ã‚‹å ´åˆã€
ç‰¹ã«ï¼Œ~hostã¨~pathãŒæ··åŒã•ã‚Œæ˜“ã„ã€‚
ãã®ã‚ˆã†ãªäº‹ä¾‹ã§ã¯ã€
~URLã®`~host$urlã®ã¿ã‚’å…·ç¾åŒ–ã™ã‚‹ã“ã¨ã‚’ç‰¹ã«å‹§ã‚ã‚‹ã€‚
å¯èª­æ€§ã‚’å¾—ã‚‹ãŸã‚ã«`~URL$ã®ä»–ã®éƒ¨åˆ†ã‚’å…·ç¾åŒ–ã™ã‚‹å ´åˆã€
`~percent-ç¬¦å·åŒ–ã•ã‚ŒãŸ~byte$ãŸã¡ãŒæˆã™é€£åˆ— %æ–‡å­—åˆ— ã‚’
`~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$( `æ–‡å­—åˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹$( %æ–‡å­—åˆ— ) )
ã®çµæœã‚’æˆã™~cpåˆ—ã«ç½®æ›ã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹
â€” ãã®çµæœãŒä¸å¯è¦–ã«ãªã‚‹å ´åˆã‚’é™¤ã„ã¦ã€‚
å½è£…~riskãŒã‚ã‚‹ã‚ˆã†ãªä¸€å®šã®ä¸¦ã³ã¯å¾©å·ã—ãªã„ã“ã¨ã‚’é¸ã‚“ã§ã‚‚ãƒ¨ã‚¤
ï¼ˆä¾‹ï¼š `1F512^U `ğŸ”’^smb ï¼‰ã€‚
â—
URLs are particularly prone to confusion between host and path when they contain bidirectional text, so in this case it is particularly advisable to only render a URLâ€™s host. For readability, other parts of the URL, if rendered, should have their sequences of percent-encoded bytes replaced with code points resulting from running UTF-8 decode without BOM on the percent-decoding of those sequences, unless that renders those sequences invisible. Browsers may choose to not decode certain sequences that present spoofing risks (e.g., U+1F512 (ğŸ”’)).
</li>
	<li>
<p>
åŒæ–¹å‘-~textã‚’å·¦æ¨ªæ›¸ãåŸ‹ã‚è¾¼ã¿ï¼ˆ `left-to-right embedding^en ï¼‰å†…ã«ã‚ã‚‹ã‹ã®ã‚ˆã†ã«å…·ç¾åŒ–ã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹ã€‚
`BIDI$r
â—
Browsers should render bidirectional text as if it were in a left-to-right embedding. [BIDI]
</p>

<p class="note">æ³¨è¨˜ï¼š
ã‚ã„ã«ãã€
å…·ç¾åŒ–ã•ã‚Œã‚‹`~URL$ã¯ï¼Œã©ã“ã«ã§ã‚‚ç¾ã‚Œã‚‹ã‚ˆã†ãªæ–‡å­—åˆ—ã§ã‚ã‚Šã€
å…·ç¾åŒ–ã•ã‚Œã‚‹`~URL$ã«ç‰¹æœ‰ãªåŒæ–¹å‘-~algoãŒã‚ã£ã¦ã‚‚ï¼Œ
åºƒç¯„ã«æ¡ç”¨ã•ã‚Œã‚‹è¦‹è¾¼ã¿ã¯è–„ã„ã§ã‚ã‚ã†ã€‚
åŒæ–¹å‘-~textã«ã‚ˆã‚‹~URLã®å„éƒ¨ã¸ã®~~ä½œç”¨ã¯ã€
ã“ã“ã§ã®~modelã¨ã¯ç•°ãªã‚‹å…·ç¾åŒ–ã«ã•ã›å¾—ã‚‹ã€‚
åŒæ–¹å‘-è¨€èªã®åˆ©ç”¨è€…ã¯ã€
ç‰¹ã«ç´ ãª~textç’°å¢ƒã®ä¸‹ã§ã¯ï¼Œã“ã‚Œã‚’æœŸå¾…ã™ã‚‹ã‚ˆã†ã«ãªã‚Šå¾—ã‚‹ã€‚
â—
Unfortunately, as rendered URLs are strings and can appear anywhere, a specific bidirectional algorithm for rendered URLs would not see wide adoption. Bidirectional text interacts with the parts of a URL in ways that can cause the rendering to be different from the model. Users of bidirectional languages can come to expect this, particularly in plain text environments.
</p>
	</li>
</ul>

			</section>
		</section>
	</section>
	<section id="application/x-www-form-urlencoded">
<h2 title="application/x-www-form-urlencoded">5. ~form_urlencoded</h2>

<p>
`~form_urlencodedå½¢å¼@
ã¯ã€
`~query~parameter$ãŸã¡ãŒæˆã™`~list$ã‚’ç¬¦å·åŒ–ã™ã‚‹ä»•æ–¹ã‚’ä¾›ã™ã‚‹ã€‚
â—
The application/x-www-form-urlencoded format provides a way to encode a list of tuples, each consisting of a name and a value.
</p>

<p class="note">æ³¨è¨˜ï¼š
~form_urlencodedå½¢å¼ã¯ã€
ä½•å¹´ã«ã‚‚ã‚ãŸã‚‹å®Ÿè£…ã®ä¸å¹¸ãªå·¡ã‚Šåˆã‚ã›ã®çµæœï¼Œå¤šãã®é¢ã§å¥‡ç•°ãªã‚‚ã®ã«ãªã£ã¦ãŠã‚Šã€
ç›¸äº’é‹ç”¨èƒ½ã‚’å¾—ã‚‹ãŸã‚ã«å¿…è¦yãªè¦ä»¶~ç¾¤ã‹ã‚‰ãªã‚‹ï¼Œå¦¥å”ã®ç”£ç‰©ã§ã‚ã‚‹
â€” è‰¯ã„è¨­è¨ˆã®å®Ÿæ–½ã‚’è¡¨ç¾ã™ã‚‹ä»•æ–¹ã¯ç„¡ã„ã€‚
èª­è€…ã¯ç‰¹ã«ã€
æ–‡å­—~ç¬¦å·åŒ–æ³•ã¨~byteåˆ—ã¨ã®é–“ã§ç¹°è¿”ã•ã‚Œã‚‹ï¼ˆå ´åˆã«ã‚ˆã£ã¦ã¯å…¥å­ã«ã•ã‚ŒãŸï¼‰å¤‰æ›ã®ã²ã­ãã‚ŒãŸè©³ç´°~ã«ï¼Œæ³¨æ„ã‚’æ‰•ã†ã‚ˆã†ã«ã€‚
ã‚ã„ã«ãï¼Œã“ã®å½¢å¼ã¯~HTML~formã«æ™®åŠã—ã¦ã„ã‚‹ãŒãŸã‚ã€
åºƒãåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ã€‚
`HTML$r
â—
The application/x-www-form-urlencoded format is in many ways an aberrant monstrosity, the result of many years of implementation accidents and compromises leading to a set of requirements necessary for interoperability, but in no way representing good design practices. In particular, readers are cautioned to pay close attention to the twisted details involving repeated (and in some cases nested) conversions between character encodings and byte sequences. Unfortunately the format is in widespread use due to the prevalence of HTML forms. [HTML]
</p>

		<section id="urlencoded-parsing">
<h3 title="application/x-www-form-urlencoded parsing">5.1. ~form_urlencodedæ§‹æ–‡è§£æ-æ³•</h3>

<p class="note">æ³¨è¨˜ï¼š
æ—§æ¥ã®~serverå‘ã‘å®Ÿè£…ã«ã¯ã€
`~UTF-8$ä»¥å¤–ã®`ç¬¦å·åŒ–æ³•$ã‚’~supportã™ã‚‹ã¨ã¨ã‚‚ã«ï¼»
å ~EQ `_charset^blã€ï¼_charset_ï¼Ÿã€‘
ï¼½ãªã‚‹`~query~parameter$ã€ï¼tupleã€‘ç”¨ã«ç‰¹åˆ¥ãª~logicã‚’ä¼´ã†ã‚‚ã®ã‚‚ã‚ã‚‹ã€‚
ãã®ã‚ˆã†ãª~logicã¯ã€
ã“ã“ã§ã¯è¿°ã¹ã‚‰ã‚Œãªã„
â€” é©åˆã™ã‚‹ã‚‚ã®ã¯`~UTF-8$ã«é™ã‚‰ã‚Œã‚‹ã€‚
â—
A legacy server-oriented implementation might have to support encodings other than UTF-8 as well as have special logic for tuples of which the name is `_charset`. Such logic is not described here as only UTF-8 is conforming.
</p>

<div class="algo">
<p>
`~form_urlencodedæ§‹æ–‡è§£æå™¨@
ã¯ã€
æ‰€ä¸ã®
( ~byteåˆ— %å…¥åŠ› )
ã«å¯¾ã—ï¼š
â—
The application/x-www-form-urlencoded parser takes a byte sequence input, and then runs these steps:
</p>

<ol>
	<li>
%~byteåˆ—~list ~LET %å…¥åŠ› ã‚’ `26^X `&amp;^smb ã§åˆ†å‰²ã—ãŸçµæœ
â—
Let sequences be the result of splitting input on 0x26 (&amp;).
</li>
	<li>
%å‡ºåŠ› ~LET æ–°ãŸãª`~list$ï¼ˆ`~query~parameter$ãŸã¡ï¼‰
â—
Let output be an initially empty list of name-value tuples where both name and value hold a string.
</li>
	<li>
<p>
%~byteåˆ—~list ã‚’æˆã™
~EACH( %~byteåˆ— )
ã«å¯¾ã—ï¼š
â—
For each byte sequence bytes in sequences:
</p>
		<ol>
			<li>
~IFï¼»
%~byteåˆ— ~EQ ç©º~byteåˆ—
ï¼½
â‡’
~CONTINUE
â—
If bytes is the empty byte sequence, then continue.
</li>
			<li>
( %å, %å€¤ ) ~LET ( %~byteåˆ—, ç©º~byteåˆ— )
â—
â†“</li>
			<li>
~IFï¼»
%~byteåˆ— å†…ã« â›= ãŒåœ¨ã‚‹
ï¼½
â‡’
( %å, %å€¤ ) ~SET  %~byteåˆ— ã‚’æœ€åˆã® â›= ã®æ‰€ã§ 2 å€‹ã®~byteåˆ—ã«åˆ†å‰²ã—ãŸçµæœ
ï¼ˆãã®æœ€åˆã® â›= ã¯çµæœã«å«ã‚ãªã„
â€” ã—ãŸãŒã£ã¦ï¼Œã„ãšã‚Œã‚‚ç©º~byteåˆ—ã«ãªã‚Šå¾—ã‚‹ï¼‰
â—
If bytes contains a 0x3D (=), then let name be the bytes from the start of bytes up to but excluding its first 0x3D (=), and let value be the bytes, if any, after the first 0x3D (=) up to the end of bytes. If 0x3D (=) is the first byte, then name will be the empty byte sequence. If it is the last, then value will be the empty byte sequence.
â—
Otherwise, let name have the value of bytes and let value be the empty byte sequence.
</li>
			<li>
ï¼»
%å, %å€¤
ï¼½å†…ã®ã™ã¹ã¦ã® â›+ ã‚’ `20^X (SP) ã«ç½®æ›ã™ã‚‹
â—
Replace any 0x2B (+) in name and value with 0x20 (SP).
</li>
			<li>
%å~æ–‡å­—åˆ— ~LET `~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$( `~byteåˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹$( %å ) )
â—
â†“</li>
			<li>
%å€¤~æ–‡å­—åˆ— ~LET `~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$( `~byteåˆ—ã‚’~byteåˆ—ã«~percent-å¾©å·ã™ã‚‹$( %å€¤ ) )
â—
Let nameString and valueString be the result of running UTF-8 decode without BOM on the percent-decoding of name and value, respectively.
</li>
			<li>
%å‡ºåŠ› ã« ( %å~æ–‡å­—åˆ—, %å€¤~æ–‡å­—åˆ— ) ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Append (nameString, valueString) to output.
</li>
		</ol>
	</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

		</section>
		<section id="urlencoded-serializing">
<h3 title="application/x-www-form-urlencoded serializing">5.2. ~form_urlencodedç›´åˆ—åŒ–-æ³•</h3>

<div class="algo">
<p>
`~form_urlencodedç›´åˆ—åŒ–å™¨@
ã¯ã€
æ‰€ä¸ã®
( `~list$ %~parameter~list, `ç¬¦å·åŒ–æ³•$ %ç¬¦å·åŒ–æ³• ï¼ˆçœç•¥æ™‚ã¯`~UTF-8$ ï¼‰ )
ã«å¯¾ã—ï¼Œ`~ASCIIæ–‡å­—åˆ—$ã‚’è¿”ã™ï¼š
â—
The application/x-www-form-urlencoded serializer takes a list of name-value tuples tuples, with an optional encoding encoding (default UTF-8), and then runs these steps. They return an ASCII string.
</p>
<ol>
	<li>
%ç¬¦å·åŒ–æ³• ~SET `ç¬¦å·åŒ–æ³•ã‹ã‚‰å‡ºåŠ›~ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹$( %ç¬¦å·åŒ–æ³• )
â—
Set encoding to the result of getting an output encoding from encoding.
</li>
	<li>
%å‡ºåŠ› ~LET ç©º~æ–‡å­—åˆ—
â—
Let output be the empty string.
</li>
	<li>
<p>
%~parameter~list ã‚’æˆã™
~EACH( %~parameter )
ã«å¯¾ã—ï¼š
â—
For each tuple of tuples:
</p>
		<ol>
			<li>
~Assertï¼š %~parameter ã¯`~query~parameter$ã§ã‚ã‚‹ã€‚
â—
Assert: tupleâ€™s name and tupleâ€™s value are scalar value strings.
</li>
			<li>
%å ~LET `æ–‡å­—åˆ—ã‚’ç¬¦å·åŒ–ã—ã¦ã‹ã‚‰~percent-ç¬¦å·åŒ–ã™ã‚‹$( %ç¬¦å·åŒ–æ³•, %~parameter ã®å, `~form_urlencoded~percent-ç¬¦å·åŒ–-é›†åˆ$, ~T )
â—
Let name be the result of running percent-encode after encoding with encoding, tupleâ€™s name, the application/x-www-form-urlencoded percent-encode set, and true.
</li>
			<li>
%å€¤ ~LET `æ–‡å­—åˆ—ã‚’ç¬¦å·åŒ–ã—ã¦ã‹ã‚‰~percent-ç¬¦å·åŒ–ã™ã‚‹$( %ç¬¦å·åŒ–æ³•, %~parameter ã®å€¤, `~form_urlencoded~percent-ç¬¦å·åŒ–-é›†åˆ$, ~T )
â—
Let value be the result of running percent-encode after encoding with encoding, tupleâ€™s value, the application/x-www-form-urlencoded percent-encode set, and true.
</li>
			<li>
~IFï¼»
%å‡ºåŠ› ~NEQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’
%å‡ºåŠ› ~APPEND `0026^U `&amp;^smb
â—
If output is not the empty string, then append U+0026 (&amp;) to output.
</li>
			<li>
%å‡ºåŠ›
~APPEND %å
~APPEND â=
~APPEND %å€¤
â—
Append name, followed by U+003D (=), followed by value, to output.
</li>
		</ol>
	</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

		</section>
		<section id="urlencoded-hooks">
<h3 title="Hooks">5.3. ~hook</h3>

<div class="algo">
<p>
`~form_urlencodedæ–‡å­—åˆ—~æ§‹æ–‡è§£æå™¨@
ã¯ã€
æ‰€ä¸ã®
( `~scalarå€¤~æ–‡å­—åˆ—$ %å…¥åŠ› )
ã«å¯¾ã—
â‡’
~RET `~form_urlencodedæ§‹æ–‡è§£æå™¨$( `~UTF-8ç¬¦å·åŒ–ã™ã‚‹$( %å…¥åŠ› ) )
â—
The application/x-www-form-urlencoded string parser takes a scalar value string input, UTF-8 encodes it, and then returns the result of application/x-www-form-urlencoded parsing it.
</p>
</div>

		</section>
	</section>
	<section id="api">
<h2 title="API">6. ~API</h2>

<p>
ã“ã®ç¯€ã¯ã€
`Web IDL^cite ã«ã‚ˆã‚‹å„ç¨®ç”¨èªã‚’åˆ©ç”¨ã™ã‚‹ã€‚
~browser~UAã¯ã€
ã“ã®~APIã‚’~supportã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
~JSå®Ÿè£…ã¯ã€
ã“ã®~APIã‚’~supportã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹ã€‚
ä»–ã®ï¼»
~UAï¼~programmingè¨€èª
ï¼½ã¯ã€
å„è‡ªã®å¿…è¦ã«ç›¸å¿œã—ã„~APIã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹
â€” ã“ã®~APIã¨ã¯ç•°ãªã‚‹ã“ã¨ã‚‚ã‚ã‚ã†ãŒã€‚
`WEBIDL$r
â—
This section uses terminology from Web IDL. Browser user agents must support this API. JavaScript implementations should support this API. Other user agents or programming languages are encouraged to use an API suitable to their needs, which might not be this one. [WEBIDL]
</p>

		<section id="url-class">
<h3 title="URL class">6.1. `URL^I ~class</h3>

<pre class="idl">
[`Exposed$=*, `LegacyWindowAlias$=`webkitURL@]
interface `URL@I {
  `URL$mc(`USVString$ %url, optional `USVString$ %base);

  static `URL$I? `parse$m(`USVString$ %url, optional `USVString$ %base);
  static `boolean$ `canParse$m(`USVString$ %url, optional `USVString$ %base);

  <span id="url-stringification-behavior">stringifier</span> attribute `USVString$ `href$m;
  readonly attribute `USVString$ `origin$m;
           attribute `USVString$ `protocol$m;
           attribute `USVString$ `username$m;
           attribute `USVString$ `password$m;
           attribute `USVString$ `host$m;
           attribute `USVString$ `hostname$m;
           attribute `USVString$ `port$m;
           attribute `USVString$ `pathname$m;
           attribute `USVString$ `search$m;
  [`SameObject$] readonly attribute `URLSearchParams$I `searchParams$m;
           attribute `USVString$ `hash$m;

  `USVString$ `toJSON$m();
};
</pre>

<p>
å„ `URL$I ~objã«ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
A URL object has an associated:
</p>
<ul>
	<li>
`~URL@URL
â‡’
ã‚ã‚‹`~URL$
â—
URL: a URL.
</li>
	<li>
`~query~obj@URL
â‡’
ã‚ã‚‹ `URLSearchParams$I ~obj
â—
query object: a URLSearchParams object.
</li>
</ul>

<div class="algo">
<p>
`ä¸é€æ˜ãª~pathãªã‚‰ã° ãã®æœ«å°¾ã«ã‚ã‚‹~spaceåˆ—ã‚’å‰¥ã@
~algoã¯ã€
æ‰€ä¸ã®
( `URL$I ~obj %~URL~obj )
ã«å¯¾ã—ï¼š
â—
To potentially strip trailing spaces from an opaque path given a URL object url:
</p>
<ol>
	<li>
%~URL ~LET %~URL~obj ã®`~URL$URL
â—
â†“</li>
	<li>
<p>
~IFï¼»
%~URL ã¯`ä¸é€æ˜ãª~path$ã‚’æœ‰ã™ã‚‹
ï¼½~ANDï¼»
%~URL ã®`ç´ ç‰‡$url ~EQ ~NULL
ï¼½~ANDï¼»
%~URL ã®`~query$url ~EQ ~NULL
ï¼½ï¼š
</p>
		<ol>
			<li>
%~pathæ–‡å­—åˆ— ~LET %~URL ã®`~path$url
</li>
			<li>
~WHILEï¼»
%~pathæ–‡å­—åˆ— ã¯ç©ºã§ãªã„
ï¼½~ANDï¼»
%~pathæ–‡å­—åˆ— ã®æœ€å¾Œã®æ–‡å­— ~EQ `0020^U `SPACE^cn
ï¼½
â‡’
%~pathæ–‡å­—åˆ— ã‹ã‚‰æœ€å¾Œã®æ–‡å­—ã‚’é™¤å»ã™ã‚‹
</li>
			<li>
%~URL ã®`~path$url ~SET %~pathæ–‡å­—åˆ—
</li>
		</ol>
â—
If urlâ€™s URL does not have an opaque path, then return.
â—
If urlâ€™s URLâ€™s fragment is non-null, then return.
â—
If urlâ€™s URLâ€™s query is non-null, then return.
â—
Remove all trailing U+0020 SPACE code points from urlâ€™s URLâ€™s path.
</li>
</ol>
</div>

<div class="algo">
<p>
`~API~URLæ§‹æ–‡è§£æå™¨@
ã¯ã€
æ‰€ä¸ã®
( `~scalarå€¤~æ–‡å­—åˆ—$ %~URL, ï¼»~NULLï¼`~scalarå€¤~æ–‡å­—åˆ—$ï¼½ %åŸºåº•ã€ï¼ï¼ˆçœç•¥æ™‚ã¯ ~NULL ï¼‰ã€‘ )
ã«å¯¾ã—ï¼š
â—
The API URL parser takes a scalar value string url and an optional null-or-scalar value string base (default null), and then runs these steps:
</p>
<ol>
	<li>
%æ§‹æ–‡è§£æã—ãŸåŸºåº• ~LET ~NULL
â—
Let parsedBase be null.
</li>
	<li>
<p>
~IFï¼»
%åŸºåº• ~NEQ ~NULL
ï¼½ï¼š
â—
If base is non-null:
</p>
		<ol>
			<li>
%æ§‹æ–‡è§£æã—ãŸåŸºåº• ~SET `åŸºæœ¬~URLæ§‹æ–‡è§£æå™¨$( %åŸºåº• )
â—
Set parsedBase to the result of running the basic URL parser on base.
</li>
			<li>
~IFï¼»
%æ§‹æ–‡è§£æã—ãŸåŸºåº• ~EQ `å¤±æ•—^i
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If parsedBase is failure, then return failure.
</li>
		</ol>
	</li>
	<li>
~RET `åŸºæœ¬~URLæ§‹æ–‡è§£æå™¨$( %~URL, %æ§‹æ–‡è§£æã—ãŸåŸºåº• )
â—
Return the result of running the basic URL parser on url with parsedBase.
</li>
</ol>
</div>

<div class="algo">
<p>
`~URL~objã‚’åˆæœŸåŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `URL$I ~obj %~URL, `~URL~record$ %~URL~record )
ã«å¯¾ã—ï¼š
â—
To initialize a URL object url with a URL urlRecord:
</p>
<ol>
	<li>
%~query ~LET %~URL~record ã®`~query$url
â—
Let query be urlRecordâ€™s query,ï¼¼
</li>
	<li>
~IFï¼»
%~query ~EQ ~NULL
ï¼½
â‡’
%~query ~SET ç©º~æ–‡å­—åˆ—
â—
if that is non-null; otherwise the empty string.
</li>
	<li>
%~URL ã®`~URL$URL ~SET %~URL~record
â—
Set urlâ€™s URL to urlRecord.
</li>
	<li>
%~URL ã®`~query~obj$URL ~SET `æ–°ãŸãª~obj$( `URLSearchParams$I )
â—
Set urlâ€™s query object to a new URLSearchParams object.
</li>
	<li>
`~query~objã‚’åˆæœŸåŒ–ã™ã‚‹$( %~URL ã®`~query~obj$URL,  %~query )
â—
Initialize urlâ€™s query object with query.
</li>
	<li>
%~URL ã®`~query~obj$URLã®`~URL~obj$USP ~SET %~URL
â—
Set urlâ€™s query objectâ€™s URL object to url.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`new URL(url, base)@m
æ§‹ç¯‰å­~æ‰‹ç¶šãã¯ï¼š
â—
The new URL(url, base) constructor steps are:
</p>
<ol>
	<li>
~IFï¼»
%base ~EQ Îµ
ï¼½
â‡’
%base ~SET ~NULL
â—
â†“</li>
	<li>
%æ§‹æ–‡è§£æã—ãŸ~URL ~LET `~API~URLæ§‹æ–‡è§£æå™¨$( %url, %base )
â—
Let parsedURL be the result of running the API URL parser on url with base, if given.
</li>
	<li>
~IFï¼»
%æ§‹æ–‡è§£æã—ãŸ~URL ~EQ `å¤±æ•—^i
ï¼½
â‡’
~THROW `TypeError$E
â—
If parsedURL is failure, then throw a TypeError.
</li>
	<li>
`~URL~objã‚’åˆæœŸåŒ–ã™ã‚‹$( ã‚³ãƒ¬, %æ§‹æ–‡è§£æã—ãŸ~URL )
â—
Initialize this with parsedURL.
</li>
</ol>
</div>

<div class="example">
<p>
`åŸºåº•~URL$ã‚’åˆ©ç”¨ã›ãšã«ï¼Œ
æ–‡å­—åˆ—ã‚’`æ§‹æ–‡è§£æ-ï¼ #concept-basic-url-parser$ã—ã¦`~URL$ã‚’å¾—ã‚‹ã¨ãã¯ã€
å˜ç‹¬ã®å¼•æ•°ã§ `new URL()$m æ§‹ç¯‰å­ã‚’å‘¼ã³å‡ºã™ï¼š
â—
To parse a string into a URL without using a base URL, invoke the URL constructor with a single argument:
</p>

<pre class="lang-js">
var %input = `https://example.org/ğŸ’©^l,
    %url = new URL(%input);
%url.pathname; // `/%F0%9F%92%A9^l
</pre>

<p>
æ¬¡ã®ã‚‚ã®ã¯ã€
å…¥åŠ›ãŒ`ç›¸å¯¾~URL$sTã§ã‚ã‚‹å ´åˆï¼Œä¾‹å¤–ã‚’æŠ•å‡ºã™ã‚‹ï¼š
â—
This throws an exception if the input is a relative-URL string:
</p>

<pre class="lang-js">
try {
  var %url = new URL(`/ğŸ£ğŸº^l);
} catch(%e) {
  // <span class="comment" title="that happened">ã“ã“ã«æ¥ã‚‹</span>
}
</pre>

<p>
`åŸºåº•~URL$ãŒå¿…è¦yãªäº‹ä¾‹ã§ã¯ï¼š
â—
For those cases a base URL is necessary:
</p>

<pre class="lang-js">
var %input = `/ğŸ£ğŸº^l,
    %url = new URL(%input, document.baseURI);
%url.href; // `https://url.spec.whatwg.org/%F0%9F%8D%A3%F0%9F%8D%BA^l
</pre>

<p>
`URL$I ~objã¯ã€
`åŸºåº•~URL$ã¨ã—ã¦åˆ©ç”¨ã§ãã‚‹
ï¼ˆ~IDLã‹ã‚‰ã¯å¼•æ•°ã¨ã—ã¦æ–‡å­—åˆ—ãŒè¦æ±‚ã•ã‚Œã‚‹ã®ã§ã€
`URL$I ~objã¯ï¼Œãã® `href$m å–å¾—å­ãŒè¿”ã™å€¤ã«æ–‡å­—åˆ—~åŒ–ã•ã‚Œã‚‹ï¼‰ï¼š
â—
A URL object can be used as a base URL (as the IDL requires a string as argument, a URL object stringifies to its href getter return value):
</p>

<pre class="lang-js">
var %url = new URL(`ğŸŒˆ^l, new URL(`https://pride.example/hello-world^l));
%url.pathname // `/%F0%9F%8F%B3%EF%B8%8F%E2%80%8D%F0%9F%8C%88^l
</pre>
</div>

<hr>

<div class="algo">
<p>
`parse(url, base)@m
é™çš„~methodæ‰‹ç¶šãã¯ï¼š
â—
The static parse(url, base) method steps are:
</p>
<ol>
	<li>
%æ§‹æ–‡è§£æã—ãŸ~URL ~LET `~API~URLæ§‹æ–‡è§£æå™¨$( %url, %base )
â—
Let parsedURL be the result of running the API URL parser on url with base, if given.
</li>
	<li>
~IFï¼»
%æ§‹æ–‡è§£æã—ãŸ~URL ~EQ `å¤±æ•—^i
ï¼½
â‡’
~RET ~NULL
â—
If parsedURL is failure, then return null.
</li>
	<li>
%~URL ~LET `æ–°ãŸãª~obj$( `URL$I )
â—
Let url be a new URL object.
</li>
	<li>
`~URL~objã‚’åˆæœŸåŒ–ã™ã‚‹$( %~URL, %æ§‹æ–‡è§£æã—ãŸ~URL )
â—
Initialize url with parsedURL.
</li>
	<li>
~RET %~URL
â—
Return url.
</li>
</ol>
</div>

<div class="algo">
<p>
`canParse(url, base)@m
é™çš„~methodæ‰‹ç¶šãã¯ï¼š
â—
The static canParse(url, base) method steps are:
</p>
<ol>
	<li>
~IFï¼»
%base ~EQ Îµ
ï¼½
â‡’
%base ~SET ~NULL
â—
â†“</li>
	<li>
%æ§‹æ–‡è§£æã—ãŸ~URL ~LET `~API~URLæ§‹æ–‡è§£æå™¨$( %url, %base )
â—
Let parsedURL be the result of running the API URL parser on url with base, if given.
</li>
	<li>
~IFï¼»
%æ§‹æ–‡è§£æã—ãŸ~URL ~EQ `å¤±æ•—^i
ï¼½
â‡’
~RET ~F
â—
If parsedURL is failure, then return false.
</li>
	<li>
~RET ~T
â—
Return true.
</li>
</ol>
</div>

<hr id="urlutils-members">

<div class="algo">
<p>
`toJSON()@m
~methodæ‰‹ç¶šãï¼
`href@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
<p>
<ol>
	<li>
~RET `~URLã‚’ç›´åˆ—åŒ–ã™ã‚‹$( ã‚³ãƒ¬ã®`~URL$URL )
</li>
</ol>
â—
The href getter steps and the toJSON() method steps are to return the serialization of thisâ€™s URL.
</div>

<div class="algo">
<p>
`href$m è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
â—
The href setter steps are:
</p>
<ol>
	<li>
%æ§‹æ–‡è§£æã—ãŸ~URL ~LET `åŸºæœ¬~URLæ§‹æ–‡è§£æå™¨$( æ‰€ä¸ã®å€¤ )
â—
Let parsedURL be the result of running the basic URL parser on the given value.
</li>
	<li>
~IFï¼»
%æ§‹æ–‡è§£æã—ãŸ~URL ~EQ `å¤±æ•—^i
ï¼½
â‡’
~THROW `TypeError$E
â—
If parsedURL is failure, then throw a TypeError.
</li>
	<li>
ã‚³ãƒ¬ã®`~URL$URL ~SET %æ§‹æ–‡è§£æã—ãŸ~URL
â—
Set thisâ€™s URL to parsedURL.
</li>
	<li>
ã‚³ãƒ¬ã®`~query~obj$URLã®`~parameter~list$USPã‚’`ç©ºã«ã™ã‚‹$
â—
Empty thisâ€™s query objectâ€™s list.
</li>
	<li>
%~query ~LET ã‚³ãƒ¬ã®`~URL$URLã®`~query$url
â—
Let query be thisâ€™s URLâ€™s query.
</li>
	<li>
~IFï¼»
%~query ~NEQ ~NULL
ï¼½
â‡’
ã‚³ãƒ¬ã®`~query~obj$URLã®`~parameter~list$USP ~SET `~form_urlencodedæ–‡å­—åˆ—~æ§‹æ–‡è§£æå™¨$( %~query )
â—
If query is non-null, then set thisâ€™s query objectâ€™s list to the result of parsing query.
</li>
</ol>
</div>

<div class="algo">
<p>
`origin@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
<p>
<ol>
	<li>
~RET `ç”Ÿæˆå…ƒã‚’ç›´åˆ—åŒ–ã™ã‚‹$( ã‚³ãƒ¬ã®`~URL$URLã®`ç”Ÿæˆå…ƒ$url )
`HTML$r
</li>
</ol>
â—
The origin getter steps are to return the serialization of thisâ€™s URLâ€™s origin. [HTML]
</div>

<div class="algo">
<p>
`protocol@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
<p>
<ol>
	<li>
~RET
ç©º~æ–‡å­—åˆ— ~APPEND ã‚³ãƒ¬ã®`~URL$URLã®`~scheme$url
~APPEND â:
</li>
</ol>
â—
The protocol getter steps are to return thisâ€™s URLâ€™s scheme, followed by U+003A (:).
</div>

<div class="algo">
<p>
`protocol$m è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
</p>
<ol>
	<li>
%å…¥åŠ› ~LET æ‰€ä¸ã®å€¤ ~APPEND â:
</li>
	<li>
`~APIç”¨ã«~URLæ§‹æ–‡è§£æã™ã‚‹$( %å…¥åŠ›, ã‚³ãƒ¬ã®`~URL$URL, `~schemeé–‹å§‹$st )
</li>
</ol>
â—
The protocol setter steps are to basic URL parse the given value, followed by U+003A (:), with thisâ€™s URL as url and scheme start state as state override.
</div>

<div class="algo">
<p>
`username@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
<p>
<ol>
	<li>
~RET ã‚³ãƒ¬ã®`~URL$URLã®`~username$url
</li>
</ol>
â—
The username getter steps are to return thisâ€™s URLâ€™s username.
</div>

<div class="algo">
<p>
`username$m è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
â—
The username setter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
â†“</li>
	<li>
~IFï¼»
%~URL ã¯`~usernameï¼~passwordï¼~portã‚’æœ‰ã—å¾—ãªã„$
ï¼½
â‡’
~RET
â—
If thisâ€™s URL cannot have a username/password/port, then return.
</li>
	<li>
`~URLã®~usernameã‚’è¨­å®šã™ã‚‹$( %~URL, æ‰€ä¸ã®å€¤ )
â—
Set the username given thisâ€™s URL and the given value.
</li>
</ol>
</div>

<div class="algo">
<p>
`password@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
<p>
<ol>
	<li>
~RET ã‚³ãƒ¬ã®`~URL$URLã®`~password$url
</li>
</ol>
â—
The password getter steps are to return thisâ€™s URLâ€™s password.
</div>

<div class="algo">
<p>
`password$m è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
â—
The password setter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
â†“</li>
	<li>
~IFï¼»
%~URL ã¯`~usernameï¼~passwordï¼~portã‚’æœ‰ã—å¾—ãªã„$
ï¼½
â‡’
~RET
â—
If thisâ€™s URL cannot have a username/password/port, then return.
</li>
	<li>
`~URLã®~passwordã‚’è¨­å®šã™ã‚‹$(  %~URL, æ‰€ä¸ã®å€¤ )
â—
Set the password given thisâ€™s URL and the given value.
</li>
</ol>
</div>

<div class="algo">
<p>
`host@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The host getter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
Let url be thisâ€™s URL.
</li>
	<li>
~IFï¼»
%~URL ã®`~host$url ~EQ ~NULL
ï¼½
â‡’
~RET ç©º~æ–‡å­—åˆ—
â—
If urlâ€™s host is null, then return the empty string.
</li>
	<li>
%~host ~LET `~hostã‚’ç›´åˆ—åŒ–ã™ã‚‹$( `~host$url )
â—
â†“</li>
	<li>
~IFï¼»
%~URL ã®`~port$url ~EQ ~NULL
ï¼½
â‡’
~RET %~host
â—
If urlâ€™s port is null, return urlâ€™s host, serialized.
</li>
	<li>
~RET %~host ~APPEND â:
~APPEND `æ•´æ•°ã‚’ç›´åˆ—åŒ–ã™ã‚‹$( `~port$url )
â—
Return urlâ€™s host, serialized, followed by U+003A (:) and urlâ€™s port, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`host$m è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
â—
The host setter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
â†“</li>
	<li>
~IFï¼»
%~URL ã¯`ä¸é€æ˜ãª~path$ã‚’æœ‰ã™ã‚‹
ï¼½
â‡’
~RET
â—
If thisâ€™s URL has an opaque path, then return.
</li>
	<li>
`~APIç”¨ã«~URLæ§‹æ–‡è§£æã™ã‚‹$( æ‰€ä¸ã®å€¤, %~URL, `~host$st )
â—
Basic URL parse the given value with thisâ€™s URL as url and host state as state override.
</li>
</ol>
<p class="note">æ³¨è¨˜ï¼š
`host$m è¨­å®šå­ã«ä¸ãˆã‚‹å€¤ãŒï¼Œ`~URL~port$sTã‚’æ¬ ã„ã¦ã„ã‚‹å ´åˆã€
%~URL ã®`~port$urlã¯å¤‰åŒ–ã—ãªã„ã“ã¨ã«ãªã‚‹ã€‚
`host^m å–å¾—å­ãŒ`~URL~port$sTã‚’è¿”ã•ãªã„ãŸã‚ã«ã€
è¨­å®šå­ãŒå¸¸ã«ä¸¡è€…ã‚’ â€œè¨­å®šã—ç›´ã™â€ ã¨è¦‹åšã—ã¦ã—ã¾ã„ãã†ã ãŒã€‚
â—
If the given value for the host setter lacks a port, thisâ€™s URLâ€™s port will not change. This can be unexpected as host getter does return a URL-port string so one might have assumed the setter to always "reset" both.
</p>
</div>

<div class="algo">
<p>
`hostname@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The hostname getter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
â†“</li>
	<li>
~IFï¼»
%~URL ã®`~host$url ~EQ ~NULL
ï¼½
â‡’
~RET ç©º~æ–‡å­—åˆ—
â—
If thisâ€™s URLâ€™s host is null, then return the empty string.
</li>
	<li>
~RET `~hostã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %~URL ã®`~host$url )
â—
Return thisâ€™s URLâ€™s host, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`hostname$m è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
â—
The hostname setter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
â†“</li>
	<li>
~IFï¼»
%~URL ã¯`ä¸é€æ˜ãª~path$ã‚’æœ‰ã™ã‚‹
ï¼½
â‡’
~RET
â—
If thisâ€™s URL has an opaque path, then return.
</li>
	<li>
`~APIç”¨ã«~URLæ§‹æ–‡è§£æã™ã‚‹$( æ‰€ä¸ã®å€¤, %~URL, `~hostname$st )
â—
Basic URL parse the given value with thisâ€™s URL as url and hostname state as state override.
</li>
</ol>
</div>

<div class="algo">
<p>
`port@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The port getter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
â†“</li>
	<li>
~IFï¼»
%~URL ã®`~port$url ~EQ ~NULL
ï¼½
â‡’
~RET ç©º~æ–‡å­—åˆ—
â—
If thisâ€™s URLâ€™s port is null, then return the empty string.
</li>
	<li>
~RET `æ•´æ•°ã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %~URL ã®`~port$url )
â—
Return thisâ€™s URLâ€™s port, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`port$m è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
â—
The port setter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
â†“</li>
	<li>
~IFï¼»
%~URL ã¯`~usernameï¼~passwordï¼~portã‚’æœ‰ã—å¾—ãªã„$
ï¼½
â‡’
~RET
â—
If thisâ€™s URL cannot have a username/password/port, then return.
</li>
	<li>
~IFï¼»
æ‰€ä¸ã®å€¤ ~EQ ç©º~æ–‡å­—åˆ—
ï¼½
â‡’
%~URL ã®`~port$url ~SET ~NULL
â—
If the given value is the empty string, then set thisâ€™s URLâ€™s port to null.
</li>
	<li>
~ELSE
â‡’
`~APIç”¨ã«~URLæ§‹æ–‡è§£æã™ã‚‹$( æ‰€ä¸ã®å€¤, %~URL, `~port$st )
â—
Otherwise, basic URL parse the given value with thisâ€™s URL as url and port state as state override.
</li>
</ol>
</div>

<div class="algo">
<p>
`pathname@m
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET `~URL~pathã‚’ç›´åˆ—åŒ–ã™ã‚‹$( ã‚³ãƒ¬ã®`~URL$URL )
â—
The pathname getter steps are to return the result of URL path serializing thisâ€™s URL.
</p>
</div>

<div class="algo">
<p>
`pathname$m è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
â—
The pathname setter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
â†“</li>
	<li>
~IFï¼»
%~URL ã¯`ä¸é€æ˜ãª~path$ã‚’æœ‰ã™ã‚‹
ï¼½
â‡’
~RET
â—
If thisâ€™s URL has an opaque path, then return.
</li>
	<li>
%~URL ã®`~path$urlã‚’`ç©ºã«ã™ã‚‹$
â—
Empty thisâ€™s URLâ€™s path.
</li>
	<li>
`~APIç”¨ã«~URLæ§‹æ–‡è§£æã™ã‚‹$( æ‰€ä¸ã®å€¤, %~URL, `~pathé–‹å§‹$st )
â—
Basic URL parse the given value with thisâ€™s URL as url and path start state as state override.
</li>
</ol>
</div>

<div class="algo">
<p>
`search@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The search getter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
â†“</li>
	<li>
~IFï¼»
%~URL ã®`~query$url ~IN { ~NULL, ç©º~æ–‡å­—åˆ— }
ï¼½
â‡’
~RET ç©º~æ–‡å­—åˆ—
â—
If thisâ€™s URLâ€™s query is either null or the empty string, then return the empty string.
</li>
	<li>
~RET ï¼»
â? ~APPEND %~URL ã®`~query$url
ï¼½
â—
Return U+003F (?), followed by thisâ€™s URLâ€™s query.
</li>
</ol>
</div>

<div class="algo">
<p>
`search$m è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
â—
The search setter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
Let url be thisâ€™s URL.
</li>
	<li>
%å…¥åŠ› ~LET æ‰€ä¸ã®å€¤
â—
â†“</li>
	<li>
<p>
~IFï¼»
%å…¥åŠ› ~EQ ç©º~æ–‡å­—åˆ—
ï¼½ï¼š
â—
If the given value is the empty string:
</p>
		<ol>
			<li>
%~URL ã®`~query$url ~SET ~NULL
â—
Set urlâ€™s query to null.
</li>
			<li>
ã‚³ãƒ¬ã®`~query~obj$URLã®`~parameter~list$USPã‚’`ç©ºã«ã™ã‚‹$
â—
Empty thisâ€™s query objectâ€™s list.
</li>
			<li>
`ä¸é€æ˜ãª~pathãªã‚‰ã° ãã®æœ«å°¾ã«ã‚ã‚‹~spaceåˆ—ã‚’å‰¥ã$( ã‚³ãƒ¬ )
â—
Potentially strip trailing spaces from an opaque path with this.
</li>
			<li>
~RET
â—
Return.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%å…¥åŠ› ã®å…ˆé ­ã®~cp ~EQ â?
ï¼½
â‡’
%å…¥åŠ› ã‹ã‚‰å…ˆé ­ã®~cpã‚’é™¤å»ã™ã‚‹
â—
Let input be the given value with a single leading U+003F (?) removed, if any.
</li>
	<li>
%~URL ã®`~query$url ~SET ç©º~æ–‡å­—åˆ—
â—
Set urlâ€™s query to the empty string.
</li>
	<li>
`~APIç”¨ã«~URLæ§‹æ–‡è§£æã™ã‚‹$( %å…¥åŠ›, %~URL, `~query$st )
â—
Basic URL parse input with url as url and query state as state override.
</li>
	<li>
ã‚³ãƒ¬ã®`~query~obj$URLã®`~parameter~list$USP ~SET `~form_urlencodedæ–‡å­—åˆ—~æ§‹æ–‡è§£æå™¨$( %å…¥åŠ› )
â—
Set thisâ€™s query objectâ€™s list to the result of parsing input.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
`search$m è¨­å®šå­ã«ã¯ã€
ã‚³ãƒ¬ã®`~URL$URLã®`~path$urlã‹ã‚‰å°¾éƒ¨ã‚’æˆã™ï¼»
`0020^U `SPACE^cn ã‹ã‚‰ãªã‚‹`~cp$åˆ—
ï¼½ã‚’é™¤å»ã™ã‚‹èƒ½æ€§ãŒã‚ã‚‹ã€‚
ã“ã‚Œã‚’è¡Œã†ã®ã¯ã€
ã‚³ãƒ¬ã®`~URL$URLã‚’`~URLç›´åˆ—åŒ–å™¨$ã«ã‹ã‘ã¦ã‹ã‚‰`~URLæ§‹æ–‡è§£æå™¨$ã«ã‹ã‘ãŸã¨ãï¼Œ~~å…ƒã¨`åŒç­‰ãª~URL$ãŒå¾—ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
â—
The search setter has the potential to remove trailing U+0020 SPACE code points from thisâ€™s URLâ€™s path. It does this so that running the URL parser on the output of running the URL serializer on thisâ€™s URL does not yield a URL that is not equal.
</p>
</div>

<div class="algo">
<p>
`searchParams@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
<p>
<ol>
	<li>
~RET ã‚³ãƒ¬ã®`~query~obj$URL
</li>
</ol>
â—
The searchParams getter steps are to return thisâ€™s query object.
</div>

<div class="algo">
<p>
`hash@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The hash getter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
â†“</li>
	<li>
~IFï¼»
%~URL ã®`ç´ ç‰‡$url ~IN { ~NULL, ç©º~æ–‡å­—åˆ— }
ï¼½
â‡’
~RET ç©º~æ–‡å­—åˆ—
â—
If thisâ€™s URLâ€™s fragment is either null or the empty string, then return the empty string.
</li>
	<li>
~RET ï¼»
â# ~APPEND %~URL ã®`ç´ ç‰‡$url
ï¼½
â—
Return U+0023 (#), followed by thisâ€™s URLâ€™s fragment.
</li>
</ol>
</div>

<div class="algo">
<p>
`hash$m è¨­å®šå­~æ‰‹ç¶šãã¯ï¼š
â—
The hash setter steps are:
</p>
<ol>
	<li>
%~URL ~LET ã‚³ãƒ¬ã®`~URL$URL
â—
â†“</li>
	<li>
%å…¥åŠ› ~LET æ‰€ä¸ã®å€¤
â—
â†“</li>
	<li>
<p>
~IFï¼»
%å…¥åŠ› ~EQ ç©º~æ–‡å­—åˆ—
ï¼½ï¼š
â—
If the given value is the empty string:
</p>
		<ol>
			<li>
%~URL ã®`ç´ ç‰‡$url ~SET ~NULLï¼›
â—
Set thisâ€™s URLâ€™s fragment to null.
</li>
			<li>
`ä¸é€æ˜ãª~pathãªã‚‰ã° ãã®æœ«å°¾ã«ã‚ã‚‹~spaceåˆ—ã‚’å‰¥ã$( ã‚³ãƒ¬ )
â—
Potentially strip trailing spaces from an opaque path with this.
</li>
			<li>
~RET
â—
Return.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%å…¥åŠ› ã®å…ˆé ­ã®~cp ~EQ â#
ï¼½
â‡’
%å…¥åŠ› ã‹ã‚‰å…ˆé ­ã®~cpã‚’é™¤å»ã™ã‚‹
â—
Let input be the given value with a single leading U+0023 (#) removed, if any.
</li>
	<li>
%~URL ã®`ç´ ç‰‡$url ~SET ç©º~æ–‡å­—åˆ—
â—
Set thisâ€™s URLâ€™s fragment to the empty string.
</li>
	<li>
`~APIç”¨ã«~URLæ§‹æ–‡è§£æã™ã‚‹$( %å…¥åŠ›, %~URL, `ç´ ç‰‡$st )
â—
Basic URL parse input with thisâ€™s URL as url and fragment state as state override.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
`hash$m è¨­å®šå­ã«ã¯ã€
`search$m è¨­å®šå­ã¨ç­‰ä¾¡ãªæ–¹å¼ã§ï¼Œ
ã‚³ãƒ¬ã®`~URL$URLã®`~path$urlã‚’å¤‰æ›´ã™ã‚‹èƒ½æ€§ãŒã‚ã‚‹ã€‚
â—
The hash setter has the potential to change thisâ€™s URLâ€™s path in a manner equivalent to the search setter.
</p>
</div>

		</section>
		<section id="interface-urlsearchparams">
<h3 title="URLSearchParams class">6.2. `URLSearchParams^I ~class</h3>

<pre class="idl">
[`Exposed$=*]
interface `URLSearchParams@I {
  `URLSearchParams$mc(optional (`sequence$&lt;`sequence$&lt;`USVString$&gt;&gt; or `record$&lt;`USVString$, `USVString$&gt; or `USVString$) %init = "");

  readonly attribute `unsigned long$ `size$m;

  `undefined$ `append$m(`USVString$ %name, `USVString$ %value);
  `undefined$ `delete$m(`USVString$ %name, optional `USVString$ %value);
  `USVString$? `get$m(`USVString$ %name);
  `sequence$&lt;`USVString$&gt; `getAll$m(`USVString$ %name);
  `boolean$ `has$m(`USVString$ %name, optional `USVString$ %value);
  `undefined$ `set$m(`USVString$ %name, `USVString$ %value);

  `undefined$ `sort$m();

  `iterable$m&lt;`USVString$, `USVString$&gt;;
  `stringifier$m;
};
</pre>

<div class="example" id="example-constructing-urlsearchparams">
<p>
`URLSearchParams$I ~objã‚’æ§‹ç¯‰ã™ã‚‹ï¼æ–‡å­—åˆ—~åŒ–ã™ã‚‹ã®ã¯ã€
å˜ç›´ã§ã‚ã‚‹ï¼š
â—
Constructing and stringifying a URLSearchParams object is fairly straightforward:
</p>

<pre class="lang-js">
let %params = new URLSearchParams({key: "730d67"})
%params.toString() // `key=730d67^l
</pre>
</div>

<div class="note" role="note">

<p>æ³¨è¨˜ï¼š
`URLSearchParams$I ~objã¯ï¼Œ`~form_urlencodedå½¢å¼$ã‚’åˆ©ç”¨ã™ã‚‹ã®ã§ã€
ã‚ã‚‹ç¨®ã®~cpã‚’ç¬¦å·åŒ–ã™ã‚‹ã¨ãã«ï¼Œ
`URL$I ~objã¨ã®ç›¸é•ãŒã‚ã‚‹ï¼ˆ `href$m, `search$m ã‚‚å«ã‚ï¼‰ã€‚
ã¨ã‚Šã‚ã‘ã€
`searchParams$m ã‚’åˆ©ç”¨ã—ã¦`~URL~record$ã®`~query$urlã«å¯¾ã—æ¼”ç®—ã™ã‚‹ã¨ãã«ã¯ï¼Œ
æ„å¤–ãªçµæœã«ãªã‚Šå¾—ã‚‹ã€‚
â—
As a URLSearchParams object uses the application/x-www-form-urlencoded format underneath there are some difference with how it encodes certain code points compared to a URL object (including href and search). This can be especially surprising when using searchParams to operate on a URLâ€™s query.
</p>


<pre class="lang-js">
const %url = new URL('`https://example.com/?a=b ~^');
console.log(%url.href);   // `https://example.com/?a=b%20~^l
%url.searchParams.sort();
console.log(%url.href);   // `https://example.com/?a=b+%7E^l
</pre>


<pre class="lang-js">
const %url = new URL('`https://example.com/?a=~&amp;b=%7E^');
console.log(%url.search);                // `?a=~&amp;b=%7E^l
console.log(%url.searchParams.get('a')); // `~^l
console.log(%url.searchParams.get('b')); // `~^l
</pre>

<p>
`URLSearchParams$I ~objã¯ã€ï¼»
`0020^U `SPACE^cn ã¯ â+ ã«ç¬¦å·åŒ–ã™ã‚‹ï¼
ã€ä»–ã®ã€‘~cpã®ã†ã¡`~form_urlencoded~percent-ç¬¦å·åŒ–-é›†åˆ$ã«å…¥ã‚‹ã‚‚ã®ã¯~percent-ç¬¦å·åŒ–ã™ã‚‹
ï¼½ã“ã¨ã«ãªã‚‹ã€‚
â—
URLSearchParams objects will percent-encode anything in the application/x-www-form-urlencoded percent-encode set, and will encode U+0020 SPACE as U+002B (+).
</p>

<p>
`search$m ã¯ï¼Œç¬¦å·åŒ–æ³•ã‚’ç„¡è¦–ã™ã‚‹ï¼ˆ`~UTF-8$ã‚’åˆ©ç”¨ã™ã‚‹ï¼‰ä¸‹ã§ã¯ã€
~cpã®ã†ã¡ï¼»
`~URL~record$ã¯`ç‰¹åˆ¥$ã§ã‚ã‚‹ãªã‚‰ã° `ç‰¹åˆ¥~query~percent-ç¬¦å·åŒ–-é›†åˆ$ï¼
~ELSE_ `~query~percent-ç¬¦å·åŒ–-é›†åˆ$
ï¼½ã«å…¥ã‚‹ã‚‚ã®ã‚’~percent-ç¬¦å·åŒ–ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
ã€ã“ã‚Œã¯ã€`~query$stå†…ã®æœ€å¾Œè¿‘ãã®æ®µã«å¯¾å¿œã™ã‚‹ã€‘
â—
Ignoring encodings (use UTF-8), search will percent-encode anything in the query percent-encode set or the special-query percent-encode set (depending on whether or not the URL is special).
</p>
</div>

<p>
å„ `URLSearchParams$I ~objã«ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
A URLSearchParams object has an associated:
</p>
<ul>
	<li>
`~parameter~list@USP
â‡’
`~query~parameter$ãŸã¡ãŒæˆã™`~list$
â€” åˆæœŸ~æ™‚ã¯ç©ºã¨ã™ã‚‹ã€‚
â—
list: a list of tuples each consisting of a name and a value, initially empty.
</li>
	<li>
`~URL~obj@USP
â‡’
~NULL ï¼ ã‚ã‚‹ `URL$I ~obj
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
URL object: null or a URL object, initially null.
</li>
</ul>

<p class="note">æ³¨è¨˜ï¼š
`URLSearchParams$I ~objã®ã†ã¡ï¼Œ
ãã®`~URL~obj$USPãŒ ~NULLã§ãªã„ã‚‚ã®ã«ã¯ã€
`URL$I ~objã®ï¼»
`search$m, `hash$m
ï¼½è¨­å®šå­ã¨ç­‰ä¾¡ãªæ–¹å¼ã§ï¼Œ
`~URL~obj$USPã®`~path$urlã‚’å¤‰æ›´ã™ã‚‹èƒ½æ€§ãŒã‚ã‚‹ã€‚
â—
A URLSearchParams object with a non-null URL object has the potential to change that objectâ€™s path in a manner equivalent to the URL objectâ€™s search and hash setters.
</p>

<p>
`~query~parameter@
ã¯ã€
( `~scalarå€¤~æ–‡å­—åˆ—$ å, `~scalarå€¤~æ–‡å­—åˆ—$ å€¤ )
ãŒæˆã™`~tuple$ã§ã‚ã‚‹ã€‚
</p>

<p class="trans-note">ã€
`~query~parameter$ã¯ã€
ä»–æ‰€ã®è¨˜è¿°ã‚’é›†ç´„ã—ã¦æ„å‘³ã‚’æ˜ç¢ºåŒ–ã™ã‚‹ãŸã‚ã®ï¼Œã“ã®è¨³ã«ã‚ˆã‚‹è¿½åŠ 
ï¼ˆãã‚Œã«ä¼´ã„ï¼Œä¸€éƒ¨ã®å¤‰æ•°~åã‚‚æ”¹ã‚ã¦ã„ã‚‹ï¼ˆ %~tuple â†’ %~parameter, ç­‰ã€…ï¼‰ï¼‰ã€‚
ã€‘</p>

<div class="algo">
<p>
`~query~objã‚’åˆæœŸåŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `URLSearchParams$I ~obj %~query, %init )
ã«å¯¾ã—ï¼š
â—
To initialize a URLSearchParams object query with init:
</p>
<ol>
	<li>
<p>
%init ã®å‹ã«å¿œã˜ã¦ï¼š
â—
â†“</p>
		<ul class="switch">
			<li>
<p>
`é€£åˆ—~å‹$ã§ã‚ã‚‹ï¼š
</p>
				<ol>
					<li>
%init ã‚’æˆã™
~EACH( %å†…ç¸~é€£åˆ— )
ã«å¯¾ã—
â‡’
~IFï¼»
%å†…ç¸~é€£åˆ— ã®`~size$ ~NEQ 2
ï¼½
â‡’
~THROW `TypeError$E
</li>
					<li>
%init ã‚’æˆã™
~EACH( %å†…ç¸~é€£åˆ— )
ã«å¯¾ã—
â‡’
%~query ã®`~parameter~list$USPã«
( %å†…ç¸~é€£åˆ—[ 0 ], %å†…ç¸~é€£åˆ—[ 1 ] )
ã‚’`ä»˜åŠ ã™ã‚‹$
</li>
				</ol>
â—
If init is a sequence, then for each innerSequence of init:
â€¢ If innerSequenceâ€™s size is not 2, then throw a TypeError.
â€¢ Append (innerSequence[0], innerSequence[1]) to queryâ€™s list.
</li>
			<li>
`~recordå‹$ã§ã‚ã‚‹
â‡’
%init ã‚’æˆã™
~EACH( %å â†’ %å€¤ )
ã«å¯¾ã—
â‡’
%~query ã®`~parameter~list$USPã« ( %å, %å€¤ ) ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Otherwise, if init is a record,ï¼¼
then for each name â†’ value of init, append (name, value) to queryâ€™s list.
</li>
			<li>
æ–‡å­—åˆ—ã§ã‚ã‚‹
â‡’
%~query ã®`~parameter~list$USP ~SET `~form_urlencodedæ–‡å­—åˆ—~æ§‹æ–‡è§£æå™¨$( %init )
â—
Otherwise:
â€¢ Assert: init is a string.
â€¢ Set queryâ€™s list to the result of parsing init.
</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~query~objã‚’æ›´æ–°ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `URLSearchParams$I ~obj %~query )
ã«å¯¾ã—ï¼š
â—
To update a URLSearchParams object query:
</p>
<ol>
	<li>
~IFï¼»
%~query ã®`~URL~obj$USP ~EQ ~NULL
ï¼½
â‡’
~RET
â—
If queryâ€™s URL object is null, then return.
</li>
	<li>
%ç›´åˆ—åŒ–ã—ãŸ~query ~LET `~form_urlencodedç›´åˆ—åŒ–å™¨$( %~query ã®`~parameter~list$USP )
â—
Let serializedQuery be the serialization of queryâ€™s list.
</li>
	<li>
%~query ã®`~URL~obj$USPã®`~URL$URLã®`~query$url ~SET %ç›´åˆ—åŒ–ã—ãŸ~query ã«å¿œã˜ã¦
â‡’ï¼ƒ
ç©º~æ–‡å­—åˆ— ãªã‚‰ã° ~NULL ï¼
~ELSE_ %ç›´åˆ—åŒ–ã—ãŸ~query
â—
If serializedQuery is the empty string, then set serializedQuery to null.
â—
Set queryâ€™s URL objectâ€™s URLâ€™s query to serializedQuery.
</li>
	<li>
~IFï¼»
%ç›´åˆ—åŒ–ã—ãŸ~query ~EQ ~NULL
ï¼½
â‡’
`ä¸é€æ˜ãª~pathãªã‚‰ã° ãã®æœ«å°¾ã«ã‚ã‚‹~spaceåˆ—ã‚’å‰¥ã$( %~query ã®`~URL~obj$USP )
â—
If serializedQuery is null, then potentially strip trailing spaces from an opaque path with queryâ€™s URL object.
</li>
</ol>
</div>

<div class="algo">
<p>
`new URLSearchParams(init)@m
æ§‹ç¯‰å­~æ‰‹ç¶šãã¯ï¼š
â—
The new URLSearchParams(init) constructor steps are:
</p>
<ol>
	<li>
~IFï¼»
%init ã®æœ€åˆã®~cp ~EQ â?
ï¼½
â‡’
%init ã‹ã‚‰æœ€åˆã®~cpã‚’é™¤å»ã™ã‚‹
â—
If init is a string and starts with U+003F (?), then remove the first code point from init.
</li>
	<li>
`~query~objã‚’åˆæœŸåŒ–ã™ã‚‹$( ã‚³ãƒ¬, %init )
â—
Initialize this with init.
</li>
</ol>
</div>

<div class="algo">
<p>
`size@m
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
</p>
<ol>
	<li>
~RET ã‚³ãƒ¬ã®`~parameter~list$USPã®`~size$
</li>
</ol>
â—
The size getter steps are to return thisâ€™s listâ€™s size.
</div>

<div class="algo">
<p>
`append(name, value)@m
~methodæ‰‹ç¶šãã¯ï¼š
â—
The append(name, value) method steps are:
</p>
<ol>
	<li>
ã‚³ãƒ¬ã®`~parameter~list$USPã« ( %name, %value ) ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Append (name, value) to thisâ€™s list.
</li>
	<li>
`~query~objã‚’æ›´æ–°ã™ã‚‹$( ã‚³ãƒ¬ )
â—
Update this.
</li>
</ol>
</div>

<div class="algo">
<p>
`delete(name, value)@m
~methodæ‰‹ç¶šãã¯ï¼š
â—
The delete(name, value) method steps are:
</p>
<ol>
	<li>
~IFï¼»
%value ~NEQ Îµ
ï¼½
â‡’
ã‚³ãƒ¬ã®`~parameter~list$USPã‹ã‚‰æ¬¡ã‚’æº€ãŸã™`~query~parameter$ã€ï¼~tupleã€‘ã‚’ã™ã¹ã¦`é™¤å»ã™ã‚‹$
â‡’
ï¼»
å ~EQ %name
ï¼½~ANDï¼»
å€¤ ~EQ %value
ï¼½
â—
If value is given, then remove all tuples whose name is name and value is value from thisâ€™s list.
</li>
	<li>
~ELSE
â‡’
ã‚³ãƒ¬ã®`~parameter~list$USPã‹ã‚‰æ¬¡ã‚’æº€ãŸã™`~query~parameter$ã€ï¼~tupleã€‘ã‚’ã™ã¹ã¦`é™¤å»ã™ã‚‹$
â‡’
å ~EQ %name
â—
Otherwise, remove all tuples whose name is name from thisâ€™s list.
</li>
	<li>
`~query~objã‚’æ›´æ–°ã™ã‚‹$( ã‚³ãƒ¬ )
â—
Update this.
</li>
</ol>
</div>

<div class="algo">
<p>
`get(name)@m
~methodæ‰‹ç¶šãã¯ï¼š
</p>
<ol>
	<li>
ã‚³ãƒ¬ã®`~parameter~list$USPã‚’æˆã™
~EACH ( %~parameter )
ã«å¯¾ã—
â‡’
~IFï¼»
%~parameter ã®å ~EQ %name
ï¼½
â‡’
~RET %~parameter ã®å€¤
</li>
	<li>
~RET ~NULL
</li>
</ol>
â—
The get(name) method steps are to return the value of the first tuple whose name is name in thisâ€™s list, if there is such a tuple; otherwise null.
</div>

<div class="algo">
<p>
`getAll(name)@m
~methodæ‰‹ç¶šãã¯ï¼š
</p>
<ol>
	<li>
%çµæœ ~LET æ–°ãŸãª`~list$
</li>
	<li>
ã‚³ãƒ¬ã®`~parameter~list$USPã‚’æˆã™
~EACH ( %~parameter )
ã«å¯¾ã—
â‡’
~IFï¼»
%~parameter ã®å ~EQ %name
ï¼½
â‡’
%çµæœ ã« %~parameter ã®å€¤ã‚’`ä»˜åŠ ã™ã‚‹$
</li>
	<li>
~RET %çµæœ
</li>
</ol>

â—
The getAll(name) method steps are to return the values of all tuples whose name is name in thisâ€™s list, in list order; otherwise the empty sequence.
</div>

<div class="algo">
<p>
`has(name, value)@m
~methodæ‰‹ç¶šãã¯ï¼š
â—
The has(name, value) method steps are:
</p>
<ol>
	<li>
<p>
ã‚³ãƒ¬ã®`~parameter~list$USPã‚’æˆã™
~EACH ( %~parameter )
ã«å¯¾ã—ï¼š
</p>
		<ol>
			<li>
~IFï¼»
%~parameter ã®å ~NEQ %name
ï¼½
â‡’
~CONTINUE
</li>
			<li>
~IFï¼»
%value ~EQ Îµ
ï¼½
â‡’
~RET ~T
</li>
			<li>
~IFï¼»
%~parameter ã®å€¤ ~EQ %value
ï¼½
â‡’
~RET ~T
</li>
		</ol>
â—
If value is given and there is a tuple whose name is name and value is value in thisâ€™s list, then return true.
â—
If value is not given and there is a tuple whose name is name in thisâ€™s list, then return true.
</li>
	<li>
~RET ~F
â—
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`set(name, value)@m
~methodæ‰‹ç¶šãã¯ï¼š
â—
The set(name, value) method steps are:
</p>
<ol>
	<li>
%~parameter~list ~LET ã‚³ãƒ¬ã®`~parameter~list$USP
â—
â†“</li>
	<li>
%è¨­å®šã—ãŸã‹ ~LET ~F
â—
â†“</li>
	<li>
<p>
%~parameter~list ã‚’æˆã™
~EACH( %~parameter )
ã«å¯¾ã—ï¼š
</p>
		<ol>
			<li>
~IFï¼»
%~parameter ã®å ~NEQ %name
ï¼½
â‡’
~CONTINUE
</li>
			<li>
~IFï¼»
%è¨­å®šã—ãŸã‹ ~EQ ~T
ï¼½
â‡’ï¼ƒ
%~parameter~list ã‹ã‚‰ %~parameter ã‚’`é™¤å»ã™ã‚‹$ï¼›
~CONTINUE
</li>
			<li>
%~parameter ã®å€¤ ~SET %value
</li>
			<li>
%è¨­å®šã—ãŸã‹ ~SET ~T
</li>
		</ol>
â—
If thisâ€™s list contains any tuples whose name is name, then set the value of the first such tuple to value and remove the others.
</li>
	<li>
~IFï¼»
%è¨­å®šã—ãŸã‹ ~EQ ~F
ï¼½
â‡’
%~parameter~list ã« ( %name, %value ) ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Otherwise, append (name, value) to thisâ€™s list.
</li>
	<li>
`~query~objã‚’æ›´æ–°ã™ã‚‹$( ã‚³ãƒ¬ )
â—
Update this.
</li>
</ol>
</div>

<hr>

<div class="example" id="example-searchparams-sort">

<p>
`URLSearchParams$I ~objã®`~parameter~list$USPã‚’~sortã™ã‚‹ã¨æœ‰ç”¨ã«ãªã‚‹ã“ã¨ã‚‚ã‚ã‚‹
â€” ç‰¹ã«ï¼Œ~cache~hitç‡ã‚’é«˜ã‚ã‚Œã‚‹ã€‚
ã“ã‚Œã¯ã€
`sort()$m ~methodã‚’å‘¼å‡ºã™ã“ã¨ã§æˆé‚ã’ã‚Œã‚‹ï¼š
â—
It can be useful to sort the name-value tuples in a URLSearchParams object, in particular to increase cache hits. This can be accomplished through invoking the sort() method:
</p>

<pre class="lang-js">
const %url = new URL("https://example.org/?q=ğŸ³ï¸â€ğŸŒˆ&key=e1f7bc78");
%url.searchParams.sort();
%url.search; // `?key=e1f7bc78&q=%F0%9F%8F%B3%EF%B8%8F%E2%80%8D%F0%9F%8C%88^l
</pre>

<p>
å…ƒã®å…¥åŠ›ã‚’æ”¹ã‚ãŸããªã„å ´åˆï¼ˆä¾‹ï¼šæ¯”è¼ƒ~ç›®çš„ï¼‰ã¯ã€
æ–°ãŸãª `URLSearchParams$I ~objã‚’æ§‹ç¯‰ã™ã‚‹ï¼š
â—
To avoid altering the original input, e.g., for comparison purposes, construct a new URLSearchParams object:
</p>

<pre class="lang-js">
const %sorted = new URLSearchParams(%url.search)
%sorted.sort()
</pre>
</div>

<div class="algo">
<p>
`sort()@m
~methodæ‰‹ç¶šãã¯ï¼š
</p>
<ol>
	<li>
%~parameter~list ~LET ã‚³ãƒ¬ã®`~parameter~list$USP
</li>
	<li>
<p>
%~sortæ¸ˆã¿~list ~LET `~listã‚’æ˜‡é †ã«~sortã™ã‚‹$( %~parameter~list, æ¬¡ã®æ‰‹ç¶šã )
</p>

<p class="algo">
æ‰‹ç¶šãã¯ã€
æ‰€ä¸ã®
( `~query~parameter$ %A, `~query~parameter$ %B )
ã«å¯¾ã—
â‡’
~RET ~ISï¼»
%A ã®åã¯ %B ã®å `æœªæº€ã®ç¬¦å·å˜ä½~åˆ—$ã§ã‚ã‚‹
ï¼½
</p>
	</li>
	<li>
%~parameter~list ã‚’`ç©ºã«ã™ã‚‹$
</li>
	<li>
%~parameter~list ã‚’ %~sortæ¸ˆã¿~list ã§`æ‹¡å¼µã™ã‚‹$
</li>
	<li>
`~query~objã‚’æ›´æ–°ã™ã‚‹$( ã‚³ãƒ¬ )
</li>
</ol>

â—
The sort() method steps are:
â€¢ Sort all tuples in thisâ€™s list, if any, by their names. Sorting must be done by comparison of code units. The relative order between tuples with equal names must be preserved.
â€¢ Update this.
</div>

<div class="algo">
<p>
`iterable@m
ã«ãŠã‘ã‚‹`åå¾©ã•ã‚Œã‚‹å€¤~pairç¾¤$ã¯ï¼Œ
ã‚³ãƒ¬ã®`~parameter~list$USPã§ã‚ã‚Šã€
å‰è€…ã‚’æˆã™å„~pairã‚’æˆã™ï¼»
~keyï¼å€¤
ï¼½ã¯ï¼Œå¾Œè€…ã‚’æˆã™å„`~query~parameter$ã‚’æˆã™ï¼»
åï¼å€¤
ï¼½ãŒä¸ãˆã‚‹ã¨ã™ã‚‹ã€‚
â—
The value pairs to iterate over are thisâ€™s listâ€™s tuples with the key being the name and the value being the value.
</div>

<div class="algo">
<p>
`stringifier@m
ã«ãŠã‘ã‚‹`æ–‡å­—åˆ—~åŒ–ã®æŒ™å‹•$ã‚’æˆã™æ‰‹ç¶šãã¯ï¼š
<p>
<ol>
	<li>
~RET `~form_urlencodedç›´åˆ—åŒ–å™¨$( ã‚³ãƒ¬ã®`~parameter~list$USP )
</li>
</ol>
â—
The stringification behavior steps are to return the serialization of thisâ€™s list.
</div>

		</section>
		<section id="url-apis-elsewhere">
<h3 title="URL APIs elsewhere">6.3. ä»–ã®ä»•æ§˜ã«ãŠã‘ã‚‹~URL~API</h3>

<p>
`~URL$ã‚’å…¬é–‹ã™ã‚‹æ¨™æº–ã¯ã€
`~URL$ã‚’ï¼ˆå†…éƒ¨çš„ãª`~URL$ã¯`~URLç›´åˆ—åŒ–å™¨$ã«ã‹ã‘ã‚‹ãªã©ã—ã¦ï¼‰æ–‡å­—åˆ—ã¨ã—ã¦å…¬é–‹ã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹ã€‚
æ¨™æº–ã¯ã€
`URL$I ~objã‚’åˆ©ç”¨ã—ã¦`~URL$ã‚’å…¬é–‹ã™ã‚‹ãƒ™ã‚­ã§ãªã„ã€‚
`URL$I ~objã¯ã€
`~URL$ã‚’æ“ä½œã™ã‚‹ãŸã‚ã«ã‚ã‚‹ã€‚
~IDLã«ãŠã„ã¦ã¯ã€
`USVString^I å‹ãŒåˆ©ç”¨ã•ã‚Œã‚‹ãƒ™ã‚­ã§ã‚ã‚‹ã€‚
â—
A standard that exposes URLs, should expose the URL as a string (by serializing an internal URL). A standard should not expose a URL using a URL object. URL objects are meant for URL manipulation. In IDL the USVString type should be used.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã‚ˆã‚Šé«˜~levelãª~~è¦³ç‚¹ã‹ã‚‰ã¯ã€
ãã‚Œã‚‰ã®å€¤ã¯ï¼Œå¤‰ç•°-ä¸èƒ½ãª~dataæ§‹é€ ã¨ã—ã¦å…¬é–‹ã•ã‚Œã‚‹ã‚‚ã®ã«ãªã‚‹ã€‚
â—
The higher-level notion here is that values are to be exposed as immutable data structures.
</p>

<p>
æ¨™æº–ãŒï¼Œè‡ªèº«ãŒå®šç¾©ã™ã‚‹ç‰¹èƒ½ã®åå‰ã« `URL^l ã®å¤‰ç¨®ã‚’åˆ©ç”¨ã™ã‚‹ã‚‚ã®ã¨è£å®šã—ãŸå ´åˆã€
ãã®ç¨®ã®ç‰¹èƒ½ã¯ `url^l ï¼ˆã™ãªã‚ã¡ï¼Œå°æ–‡å­—, æœ«å°¾ã¯ â€œã‚¨ãƒ«â€ ï¼‰ã¨å‘½åã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚Šï¼Œ
`URL^l, `URI^l, `IRI^l ãªã©ã®åå‰ã¯åˆ©ç”¨ã•ã‚Œã‚‹ãƒ™ã‚­ã§ãªã„ã€‚
ã—ã‹ã—ãªãŒã‚‰ï¼Œãã®åå‰ãŒè¤‡åˆçš„ãªã‚‚ã®ã§ã‚ã‚‹å ´åˆã¯ã€
å¤§æ–‡å­—ã® `URL^l ãŒå¥½ã¾ã—ã„
â€” `newURL^l ã‚„ `oldURL^l ãªã©ã€‚
â—
If a standard decides to use a variant of the name "URL" for a feature it defines, it should name such a feature "url" (i.e., lowercase and with an "l" at the end). Names such as "URL", "URI", and "IRI" should not be used. However, if the name is a compound, "URL" (i.e., uppercase) is preferred, e.g., "newURL" and "oldURL".
</p>

<p class="note">æ³¨è¨˜ï¼š
é©æ­£ãªå‘½å~ä¾‹ã¨ã—ã¦ã¯ã€
`HTML^cite ã«ãŠã‘ã‚‹ï¼»
`EventSource$I ï¼ `HashChangeEvent$I
ï¼½~interfaceãŒæŒ™ã’ã‚‰ã‚Œã‚‹ã€‚
`HTML$r
â—
The EventSource and HashChangeEvent interfaces in HTML are examples of proper naming. [HTML]
</p>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">è¬è¾</h2>

<p>
å¹´æœˆã«æ¸¡ã‚Šï¼ŒãŸãã•ã‚“ã®æ–¹ã€…ãŒ`~URL$ã‚’ç›¸äº’é‹ç”¨å¯èƒ½ã«ã™ã‚‹ãŸã‚ã«åŠ©åŠ›ã•ã‚Œã€
ã“ã®æ¨™æº–ã®ç›®æ¨™ã¸è¿‘ä»˜ã‘ã¦ããŸã€‚
åŒæ§˜ã«ï¼Œã“ã®æ¨™æº–ã¯ã€
å¤šãã®æ–¹ã€…ã‹ã‚‰ã®åŠ©åŠ›ã«ã‚ˆã‚Šä»Šæ—¥ã®å§¿ã«ä»•ç«‹ã¦ä¸Šã’ã‚‰ã‚Œã¦ã„ã‚‹ï¼š
â—
There have been a lot of people that have helped make URLs more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</p>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">çŸ¥çš„è²¡ç”£æ¨©</h2>

`_ipr1@

	</section>
</main></div>

<div hidden>
<div lang="en" id="_acks1">
<p>
With that, many thanks to

<span lang="ja">100ã®äºº</span>,
Adam Barth,
Addison Phillips,
AdriÃ¡n Chaves,
Adrien Ricciardi,
Albert Wiersch,
Alex Christensen,
Alexis Hunt,
Alexandre Morgaut,
Alexis Hunt,
Alwin Blok,
Andrew Sullivan,
Arkadiusz Michalski,
Behnam Esfahbod,
Bobby Holley,
Boris Zbarsky,
Brad Hill,
Brandon Ross,
Cailyn Hansen,
Chris Dumez,
Chris Rebert,
Corey Farwell,
Dan Appelquist,
Daniel Bratell,
Daniel Stenberg,
David Burns,
David HÃ¥sÃ¤ther,
David Sheets,
David Singer,
David Walp,
Domenic Denicola,
Emily Schechter,
Emily Stark,
Eric Lawrence,
Erik Arvidsson,
Gavin Carothers,
Geoff Richards,
Glenn Maynard,
Gordon P. Hemsley,
hemanth,
Henri Sivonen,
Ian Hickson,
Ilya Grigorik,
Italo A. Casas,
Jakub Gieryluk,
James Graham,
James Manger,
James Ross,
Jeff Hodges,
Jeffrey Posnick,
Jeffrey Yasskin,
Joe Duarte,
Joshua Bell,
Jxck,
Karl Wagner,
Kemal Zebari,
<span lang="ja">ç”°æ‘å¥äºº</span> (Kent TAMURA),
Kevin Grandon,
Kornel LesiÅ„ski,
Larry Masinter,
Leif Halvard Silli,
Mark Amery,
Mark Davis,
Marcos CÃ¡ceres,
Marijn Kruisselbrink,
Martin DÃ¼rst,
Mathias Bynens,
Matt Falkenhagen,
Matt Giuca,
Michael Peick,
Michaelâ„¢ Smith,
Michal BukovskÃ½,
Michel Suignard,
MikaÃ«l GeljiÄ‡,
Noah Levitt,
Peter Occil,
Philip JÃ¤genstedt,
Philippe Ombredanne,
Prayag Verma,
Rimas MiseviÄius,
Robert Kieffer,
Rodney Rehm,
Roy Fielding,
Ryan Sleevi,
Sam Ruby,
Sam Sneddon,
Santiago M. Mola,
Sebastian Mayr,
Simon Pieters,
Simon Sapin,
Steven Vachon,
Stuart Cook,
Sven Uhlig,
Tab Atkins,
<span lang="ja">å‰é‡å‰›å²</span> (Takeshi Yoshino),
Tantek Ã‡elik,
Tiancheng "Timothy" Gu,
Tim Berners-Lee,
<span lang="zh">ç°¡å† åº­</span> (Tim Guan-tin Chien),
Titi_Alone,
Tomek WytrÄ™bowicz,
Trevor Rowbotham,
Tristan Seligmann,
Valentin Gosu,
Vyacheslav Matva,
Wei Wang,
Wolf Lammen,
<span lang="ja">å±±å²¸å’Œåˆ©</span> (Yamagishi Kazutoshi),
Yongsheng Zhang,
<span lang="ja">æˆç€¬ã‚†ã„</span> (Yui Naruse), and
zealousidealroll

for being awesome!
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.apple.com/">Apple</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>
</div>

<div lang="en" id="_ipr1">
<p>
Copyright Â© WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://url.spec.whatwg.org/review-drafts/2025-02/">Living Standard Review Draft</a>.
</p>
</div>
</div>

