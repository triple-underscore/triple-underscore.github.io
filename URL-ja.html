<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>URL Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>
.bytes, 
.literal {
	color: #DD1111;
}

.char-symbol {
	color: #DD1111;
	font-family: monospace;
}

.parser-state {
	font-family: sans-serif0, sans-serif;
}

var.ref {
	text-decoration: underline;
}

.hex-value {
	font-family: sans-serif0, sans-serif;
}

code > dfn {
	color: inherit;
}

@supports (writing-mode: vertical-rl) {

/* 本来は span, nowrap 不要（td, th に対する writing-mode のバグ対策） */

	#_combi-host-types > th > span {
		writing-mode: vertical-rl;
		white-space: nowrap;
	}
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>


Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let context_ifc = '#dom-url-'

	return this.html.replace(
/[❝❛].|%[~\w\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '❝':
		return (
'<span class="code-point">U+00' + match.charCodeAt(1).toString(16).toUpperCase() +
'</span> (<span class="char-symbol">' + match[1] + '</span>)'
		);
	case '❛':
		return(
'<span class="hex-value">0x' + match.charCodeAt(1).toString(16).toUpperCase() +
'</span> (<span class="char-symbol">' + match[1] + '</span>)'
		);
	default://%
		return '<var>' + match.slice(1) + '</var>';
	}
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'bl': // literal bytes
	text = '`<code class="bytes">' + text + '</code>`';
	break;
case 'sT': // URL syntax
	text += '<small>文字列</small>';
	break;
case 'U': // Unicode code point
	text = 'U+' + text;
	break;
case 'X': // byte value
	text = '0x' + text;
	break;
case 'smb': //
	text = '(<span class="char-symbol">' + text + '</span>)'
	break;
case 'st': // parser state
	text += ' <small>state</small>';
	break;
case 'I':
	if( indicator === '@' && key === 'URLSearchParams' ){
		context_ifc = '#dom-urlsearchparams-'
	}
	break;
case 'm': // IDL member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	href = context_ifc + key.toLowerCase();
	break;
case 'en': // english words
	return '<span lang="en-x-a0">' + key + '</span>'
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:URL
spec_date:2018-08-09
trans_update:2018-08-13
source_checked:180608
spec_status:LS
original_url:https://url.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:network,security,html
copyright:2018,whatwg
trans_1st_pub:2012-10-20


●●class_map
E:error
st:parser-state
V:ref
U:code-point
X:hex-value
AO:abstract

●●tag_map
I:code
m:code
E:code
c:code
st:span
V:var
U:span
X:span
AO:span
i:i

●●original_id_map


dom-urlsearchparams-stringifier:urlsearchparams-stringification-behavior
dom-url-stringifier:url-stringification-behavior

	concept-urlencoded:application-x-www-form-urlencoded-0


●●link_map



	●IDL
Exposed:~WEBIDL#Exposed
SameObject:~WEBIDL#SameObject
LegacyWindowAlias:~WEBIDL#LegacyWindowAlias
webkitURL:#webkiturl

E.TypeError:~WEBIDL#exceptiondef-typeerror

USVString:~WEBIDL#idl-USVString
boolean:~WEBIDL#idl-boolean
sequence:~WEBIDL#idl-sequence
record:~WEBIDL#idl-record

I.URL:#url
I.URLSearchParams:#urlsearchparams
	m.xxXx#dom-url-xxxx
	m.xxXx#dom-urlsearchparams-xxxx
I.EventSource:~HTMLsse#eventsource
I.HashChangeEvent:~NAVI#hashchangeevent
I.Blob:~FILEAPI#blob
I.MediaSource:https://w3c.github.io/media-source/#idl-def-mediasource
I.MediaStream:https://w3c.github.io/mediacapture-main/#idl-def-mediastream
I.Location:~HISTORY#location

m.~protocol0:~HISTORY#dom-location-protocol


	● 構文解析器
検証~error:#validation-error
V.C:#c
V.C1:#c1
V.C2:#c2
整数を直列化する:#serialize-an-integer
i.EOF:#eof-code-point

	● percent
~C0制御文字~percent-符号化-集合:#c0-control-percent-encode-set
素片~percent-符号化-集合:#fragment-percent-encode-set
~path~percent-符号化-集合:#path-percent-encode-set
~userinfo~percent-符号化-集合:#userinfo-percent-encode-set
~percent-符号化された~byte:#percent-encoded-byte

~byteを文字列に~percent-符号化する:#percent-encode
	~byteを~percent-符号化する:#percent-encode
~percent-復号-:#percent-decode
~byte列を~byte列に~percent-復号する:#percent-decode
~UTF-8~percent-符号化する:#utf-8-percent-encode
文字列を~byte列に~percent-復号する:#string-percent-decode

	● host

~host:#concept-host
~host構文解析器:#concept-host-parser
~hostを直列化する:#concept-host-serializer
~host直列化器:#concept-host-serializer
不透明な~host:#opaque-host
空~host:#empty-host
不透明な~host構文解析器:#concept-opaque-host-parser
禁止~host~cp:#forbidden-host-code-point
host.同等:#concept-host-equals

sT.妥当な~host:#valid-host-string
sT.妥当な~domain:#valid-domain-string
sT.妥当な~IPv4~address:#valid-ipv4-address-string
sT.妥当な~IPv6~address:#valid-ipv6-address-string
sT.妥当な不透明な~host:#valid-opaque-host-string
sT.不透明な~host＆~port:#opaque-host-and-port-string

妥当な~domain:#valid-domain
~domain:#concept-domain
~domainを~ASCII化する:#concept-domain-to-ascii
~domainを~Unicode化する:#concept-domain-to-unicode

~IPv4~address:#concept-ipv4
~IPv4構文解析器:#concept-ipv4-parser
~IPv4番号~構文解析器:#ipv4-number-parser
~IPv4直列化器:#concept-ipv4-serializer

~IPv6~address:#concept-ipv6
~IPv6構文解析器:#concept-ipv6-parser
~IPv6~piece:#concept-ipv6-piece
~IPv6直列化器:#concept-ipv6-serializer

公共接尾辞:#host-public-suffix
登録-可能な~domain:#host-registrable-domain
同じ~site:#host-same-site
~PublicSuffixListにより定義される~algo:https://publicsuffix.org/list/

	● URL
~URL:#concept-url
~URL~record:#concept-url
url.生成元:#concept-url-origin
url.素片:#concept-url-fragment
url.~host:#concept-url-host
url.~username:#concept-url-username
url.~password:#concept-url-password
url.~path:#concept-url-path
url.~port:#concept-url-port
url.~query:#concept-url-query
url.~scheme:#concept-url-scheme

url.~obj:#concept-url-object
~cannot-be-a-base-URL~flag:#url-cannot-be-a-base-url-flag

基本~URL構文解析器:#concept-basic-url-parser
~URL構文解析器:#concept-url-parser
~URL構文解析する:#concept-url-parser
~URL直列化器:#concept-url-serializer
~URLを直列化する:#concept-url-serializer
同等:#concept-url-equals
~pathを短縮する:#shorten-a-urls-path

基底~URL:#concept-base-url

特別~scheme:#special-scheme
特別:#is-special
特別でない？:#is-not-special
	特別でない:#is-not-special
既定~port:#default-port

資格証明情報を含む:#include-credentials
~URLの~usernameを設定する:#set-the-username
~URLの~passwordを設定する:#set-the-password
~username／~password／~portを持てない:#cannot-have-a-username-password-port


sT.妥当な~URL:#valid-url-string
sT.絶対~URL:#absolute-url-string
sT.素片~付き絶対~URL:#absolute-url-with-fragment-string
sT.素片~付き相対~URL:#relative-url-with-fragment-string
sT.~URL~scheme:#url-scheme-string
sT.相対~URL:#relative-url-string
sT.~scheme相対~URL:#scheme-relative-url-string
sT.~scheme相対~特別~URL:#scheme-relative-special-url-string
sT.~scheme相対~file~URL:#scheme-relative-file-url-string
sT.~path絶対 非 Windows file ~URL:#path-absolute-non-windows-file-url-string
sT.~URL~port:#url-port-string
sT.~path絶対~URL:#path-absolute-url-string
sT.~path相対~URL:#path-relative-url-string
sT.~path相対 ~schemeなし~URL:#path-relative-scheme-less-url-string
sT.~URL~path区分:#url-path-segment-string
二重dot~path区分:#double-dot-path-segment
単dot~path区分:#single-dot-path-segment
sT.~URL~query:#url-query-string
sT.~URL素片:#url-fragment-string

~drive_letter:#windows-drive-letter
正規化-済み~drive_letter:#normalized-windows-drive-letter
~drive_letterから開始されて:#start-with-a-windows-drive-letter

~URL単位:#url-units
~URL単位かどうか検証する:#_validate-if-url-unit
~URL~cp:#url-code-points


	● URL 構文解析器

st.~scheme開始-:#scheme-start-state
st.~scheme:#scheme-state
st.~schemeなし:#no-scheme-state
st.特別 相対/権限:#special-relative-or-authority-state
st.~path/権限:#path-or-authority-state
st.相対:#relative-state
st.相対~slash:#relative-slash-state
st.特別 権限~slash:#special-authority-slashes-state
st.特別 権限~slash無視:#special-authority-ignore-slashes-state
st.権限:#authority-state
st.~host:#host-state
st.~hostname:#hostname-state
st.~file~host:#file-host-state
st.~file:#file-state
st.~file~slash:#file-slash-state
st.~port:#port-state
st.~path開始-:#path-start-state
st.~path:#path-state
st.~cannot-be-a-base-URL~path:#cannot-be-a-base-url-path-state
st.~query:#query-state
st.素片:#fragment-state


	● API
url.~url:#concept-url-url
url.~query~obj:#concept-url-query-object

更新~手続き:#concept-urlsearchparams-update
~url~obj:#concept-urlsearchparams-url-object
新たな~URLSearchParams~obj:#concept-urlsearchparams-new
名値~組~list:#concept-urlsearchparams-list

~form_urlencoded形式:#concept-urlencoded
~form_urlencoded文字列~構文解析器:#concept-urlencoded-string-parser
~form_urlencoded構文解析器:#concept-urlencoded-parser
~form_urlencoded直列化器:#concept-urlencoded-serializer
~form_urlencoded~byte直列化器:#concept-urlencoded-byte-serializer

	●INFRA
~byte列:~INFRA#byte-sequence
文字列:~INFRA#string
長さ:~INFRA#string-length
byte.長さ:~INFRA#byte-sequence-length
~cp:~INFRA#code-point
~surrogate:~INFRA#surrogate
非文字:~INFRA#noncharacter
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII~byte:~INFRA#ascii-byte
~ASCII英字:~INFRA#ascii-alpha
~ASCII英数字:~INFRA#ascii-alphanumeric
~ASCII数字:~INFRA#ascii-digit
~ASCII~hex数字:~INFRA#ascii-hex-digit
~ASCII~hex数字（大文字）:~INFRA#ascii-upper-hex-digit
~ASCII文字列:~INFRA#ascii-string
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII~tabや~ASCII改行文字:~INFRA#ascii-tab-or-newline
~C0制御文字:~INFRA#c0-control
~C0制御文字や~space:~INFRA#c0-control-or-space
同型に復号する:~INFRA#isomorphic-decode
空:~INFRA#list-is-empty
	~EACH:~INFRA#list-iterate
~list:~INFRA#list
~size:~INFRA#list-size
~item:~INFRA#list-item
除去する:~INFRA#list-remove
付加する:~INFRA#list-append

	●ENCODING
符号化法から出力~符号化法を取得する:~ENCODING#get-an-output-encoding
符号化法を用いて符号化する:~ENCODING#encode
符号化法:~ENCODING#encoding
~UTF-8:~ENCODING#utf-8
~BOMはそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom
~BOMも失敗-もそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom-or-fail
~UTF-8符号化する:~ENCODING#utf-8-encode

	●他
文脈~obj:~DOM4#context-object
生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
成分組~生成元:~ORIGIN#concept-origin-tuple
同一生成元:~ORIGIN#same-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

~Blob~URL~store:~FILEAPI#BlobURLStore

AO.Unicode ToASCII:https://www.unicode.org/reports/tr46/#ToASCII
AO.Unicode ToUnicode:https://www.unicode.org/reports/tr46/#ToUnicode

反復される値の~pair:~WEBIDL#dfn-value-pairs-to-iterate-over
文字列化の挙動:~WEBIDL#dfn-stringification-behavior
連列~型:~WEBIDL#idl-sequence
~record型:~WEBIDL#idl-record


●●words_table1


URLSearchParams: <code>URLSearchParams</code> 
form_urlencoded:<code>application/x-www-form-urlencoded</code> 
APPEND: <span class="op">&lt;&lt;</span> 
protocol0:protocol
atmark:@
brackets:[]
atexample:@example

●●words_table



	●IDL
IDL:
class:
obj:object:::オブジェクト
interface::::インタフェース
属性:attribute::~
method::::メソッド
連列:sequence::~::シーケンス
新たな:new::~
例外:exception::~
投出-:throw::~
構築子:constructor::~::コンストラクタ
構築-:construct::~
取得-:get::~
取得子:getter::~
設定子:setter::~
被呼出時:被 invoke 時:~
呼出す:invoke する:~
読専:readonly::読み取り専用
型:type::~
引数:argument::~

	● data 構造
record::::レコード
byte::::バイト
	~byte列:bytes
data::::データ
stream::::ストリーム
Blob:
store:
16-bit:
list::::リスト
entry::::エントリ
item::::アイテム
長さ:length:~
size::::サイズ
index:
名前:name::~
名:name::~
値:value::~
名値:name-value: ( 名, 値 ) 
	組:pair／tuple
pair::::ペア
成分組:tuple::~
有順序:ordered:~
変異-:mutate::~
	変異-不能:immutable
構造:structure:~
有構造:structured::~
clone::::クローン
	有構造~clone
複製-:copy:~
複製:copy:~

	●構文解析／直列化
token::::トークン
pointer::::ポインタ
buffer::::バッファ
error::::エラー
piece:::片
入力:input:~
出力:output:~

Unicode:
BOM:
	~BOMも失敗-も:BOM or fail
UTF-8:
C0:
ASCII:
hex::16 進
hexadecimal::16 進
cp:code point::符号位置::コードポイント
大小無視:case-insensitive::~
文字:character::~
surrogate::::サロゲート
非文字:noncharacter::~
空白類:whitespace::~
space::::スペース
tab::::タブ
改行文字:newline::~
制御文字:controls::~
英数字:alphanumeric::~
英字:alpha::~
数字:digits::~
基数:radix::~
番号:number::~
整数:integer::~
無符号:unsigned::~
小文字:lowercase::~
	小文字~化
大文字:uppercase::~
文字列:string::~
文字列化:stringification::~
文字列化-:stringify::~
空:empty:~
区切子:separator::~
正規化-:normalize::~
	正規化-済み:normalized

符号化-:encode::~::エンコード
	符号化-済み:encoded
符号化法:encoding::~::エンコーディング
上書符号化法:encoding override::上書き符号化法::上書きエンコーディング
上書state:state override::上書き state

符号単位:code unit::~
符号化集合:encode set::~::エンコードセット
集合:set:~
単純:simple::~
復号-:decode::~::デコード

解析済み:parsed::~::パース済み
構文解析-:parse::~::パース
	構文解析-法:parsing
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
検証:validation::~
検証-:validate::~
違反:violation::~
	parsing:::構文解析
	parse:::構文解析
	parsed:::解析済み
直列化:serialization::~::シリアル化
直列化-:serialize::~::シリアル化
	直列化-法:serializing
	シリアル化
直列化器:serializer::~::シリアライザ
	直列化物:serialization::直列化::シリアル化
	serialized:::直列化

状態機械:state machine:~
state:

短縮-:shorten::~
変換-:convert::~
変換:conversion::~
圧縮-:compress::~
構文:syntax::~
生成規則:production::~
更新:update::~
前更新:pre-update::前-更新

妥当:valid::~
等価性:equivalence::~
等価:equivalent::~
同等:equal::~
	等しい:equal
同等性:equality::~
比較:comparison::~
比較-:compare::~
禁止:forbidden::~

失敗-:fail::~
失敗:failure::~
成功:success::~

形式:format::~
書式:writing::~
書出され:write され::書き出され
書出せる:write できる::書き出せる
通達-:signal:~
	~~入力:takes
ignore0::ゼロは読み飛ばす

部位:portion:~

	●URL／origin／domain／host
URL:
IP:
IPv6:
IPv4:
url:
file:
filename:::file 名
domain::::ドメイン
host::::ホスト
hostname::::ホスト名
address::::アドレス

基底:base::~
	ベース
cannot-be-a-base-URL:::基底 URL 不可用
scheme::::スキーム
userinfo::::ユーザ情報
username::::ユーザ名
password::::パスワード
port::::ポート
query::::クエリ
path::::パス
素片:fragment::~::フラグメント
素片除外:exclude fragment:fragment 除外:~::フラグメント除外
除外-:exclude:~
dot:::ドット
単dot:single-dot::単 dot:単ドット
二重dot:double-dot::二重 dot:二重ドット
区分:segment::~
percent-::: %-
drive_letter:Windows drive letter:::Windows ドライブレター

絶対:absolute::~
相対:relative::~
相対的:relative::~
単位:unit::~
特別:special::~
	特別でない:isNotSpecial
slash::::スラッシュ

生成元:origin::~::オリジン
同一生成元:same-origin::~::同一オリジン
大域:global::~::グローバル
識別子:identifier::~
識別-:identify::~
大域一意:globally unique::~::グローバル一意
不透明な:opaque::~

権限:authority::~
realm::::レルム
	authority:::権限
登録-:register::~
	登録-可能な:registrable
PublicSuffixList: <cite>Public Suffix List</cite> 
公共接尾辞:public suffix::~
site::::サイト
label::::ラベル
資格証明情報:credentials::~::クレデンシャル
階層的:hierarchical:~

	●network
DNS:
web::::ウェブ
browser::::ブラウザ
server::::サーバ
network::::ネットワーク
networking::::ネットワーク処理
target:
protocol::::プロトコル
client::::クライアント


	●仕様
API:
algo:algorithm:::アルゴリズム
UA:user agent:UA:::ユーザエージェント
hooks::::フック
model::::モデル
platform::::プラットフォーム
registry::::レジストリ
support::::サポート
Web::::ウェブ
主流:majority:~
特色機能:feature:~
統一的:universal:~
統一化:unified:~
互換性:compatibility:~
仕方:way:~
仕様:spec:~
依存-:depend:~
側面0:facet:側面
全部的:full:~
全部的な:full:~
共有-:share:~
利用者:user:~:::ユーザ
概して:typical に:~
命名-:name:~
命名:naming:~
報告-:report:~
奨励-:encourage:~
定義-:define:~
定義:definition:~
実施:practice:~
実装-:implement:~
実装:implementation:~
市場:market share:~
強化-:enhance:~
意図的:intentional:~
	意図して:intent
	所与の:given
手続き:steps:~
指名され:designate され:指定を受け
挙動:behavior:ふるまい
供-:provide:~
操作-:manipulate:~
施行-:enforce:~
既存の:existing:~
旧来の:legacy:~
明示的:explicit:~
有用:useful:~
検査:check:~
検査器:checker:~
概念:concept:~
標準:standard:~
	標準~化-:standard 化
	standardize
推奨-:recommend:~
推奨:recommendation:~
決定-:determine:~
裁定:decision:~
無視-:ignore:~
現今の:contemporary:~
環境:environment:~
目標:goal:~
目的:purpose:~
相互運用可能:interoperable:~
相互運用性:interoperability:~
確定的:solid:~
示唆:suggestion:~
結付けら:associate さ:結び付けら
背景情報:background information:~
表現-:represent:~
表現:representation:~
要件:requirements:~
要求-:require:~
視野:scope:~:::スコープ
解釈-:interpret:~
設計:design:~
詳細:details:~
課題:issue:~
走らす:run する:~
走らせ:run し:~
通例的:usual:~
過去互換対処:quirk:~
適切:appropriate:~
適合-:conform:~
	conforming
適合性:conformance:~
適正:proper:~
開発用console:developer console:開発用 console::開発用コンソール
開発者:developer:~
改変-:modify:~
改変:modification:~
排他的:exclusive:~
指示-:indicate:~
指示:indication:~
見做して:assume して:~
見做す:assume する:~
	簡単に:fairly straightforward
達成-:accomplish:~
logic::::ロジック
特有の:specific な:~
特定的:specific:~
用語:term:~
演算:operation:~
適用-:apply:~
冪等性:idempotence:~
保証-:guarantee:~
取扱い:handling:取り扱い
直感的:intuitive:~
正しい:correct な:~
明瞭:clear:~
	明瞭でない:unclear
関係-:relate:~
level::::レベル
記憶域内の:in-memory:~
誘発-:trigger:~
見なさ:consider さ:~
言明-:state:~
言明:statement:~
関連する:relevant な:~
依拠-:rely:~
分岐-:diverge:~
組入れる:incorporate する:~
裁定:decision:~
裁定-:decide:~
助言:advice:~
避ける:avoid する:~
適度:reasonable:~
	捉える:can be seen as
	高次の:At a high
	-:Ensure
	組み合わせ:combination
	同様に:Similarly
	向け:-oriented
	より高次の観点:higher-level notion
	不幸な巡り合わせ:accidents
	仮想の:conceptual
	入力:input:~
	好ましい:preferred
	妥協の産物:compromises leading
	~~完全
	揃わせ:align
	扱い方
	取り~~組む:approach
	~~機能する:serves
	~~拡がる:increase
	欠いて:lack して
	特に，in particular
	改めたくない:avoid altering
	別法として:Alternatively
	任意の:arbitrary
	〜のその他諸々:miscellaneous
	べきとされる:ought
	べき:should
	例:example
	例えば:for example
	〜に基づく:based

	●保安
保安的:secure::~:セキュア
保安:security::~:セキュリティ
font::::フォント
bar::::バー
text::::テキスト
証明書:certificate:~
予期-:expect:~
具現化-:render:~
描画-:render:~
描画:rendering:~
描画法:rendering:~
	音声化-:render:~
	allocatingあてがう
攻撃:attack:~
最善:best:~
	なりすましspoofing
主体:party:~
注意深く:carefulに:~
漏洩-:leak:~
受取って::receive して:受け取って
害する:harm する:害を及ぼす
動作:action:~
信用:trust:~
源:source:~
役務:function:~
	~~誤認-:mistake
誤認-:confuse:~
	作用-:interact:~
素の:plain:~
	酷似:appear eerily similar
	~~最低でもat the very least
	意に反するnot want to leak
考慮-:consider:~
	考慮-:consideration
考える:consider する:~
考慮点:considerations:~
	注意するCare is to be taken
双方向的:bidirectional:~
言語:language:~
	左横書き埋め込み left-to-right embedding
	見込みが薄い:unlikely
判別-:distinguish:~
重要:important:~
	広範にwide
採用-:adopt:~
製品化-:produce:~
	受け入れる:embrace:~
不可視:invisible:~
不可視の:invisible な:~
境界:boundary:~
堅固:hard:~

	●未分類
HTML:
JS:JavaScript
worker:
flag::::フラグ
link::::リンク
form::::フォーム
省略可:optional::~::オプション
反復-:iterate:~
	反復
既定:default::~::デフォルト
正準化:canonicalization::~
真偽値:boolean:~

種別:type::~
	更なる分岐処理:dispatch ... for further processing
成分:component:~
所在:location::~
保持-:hold:~
	-ing
資源:resource::~:リソース
	残りの部分remainder
	可能性potentially
付加-:append::~
	APPEND:prepend
追加-:add::~
分割-:split::~
置換-:replace::~
交換-:swap::~
除去-:remove::~
作成-:create::~
設定-:set::~
	設定し直す:reset
合致-:match::~
開始-:start::~
公開-:expose::~
終了-:terminate:~
終了:termination:~
渡す:pass する:~
渡され:pass され:~
受取って:recieve して:~
保全-:preserve:~
sort::::ソート
初期:initial::~
初期化-:initialize::~

文書:document::~
複合的:compound:~
内部的:internal::~
変種:variant:~
基本:basic::~
相違:difference:~
相違-:differ:~
文脈:context::~
入子に:nest::入れ子に
要素:element::~
	元の／:original:~
cache-hit:cache hit:::キャッシュヒット
	率を高める:increase
実行-:execute:~
形成-:form:~
	含む:include
	得る:obtain
	直前:immediately preceeding
	込みで:along with

●●ref_normative

[BIDI]
    Mark Davis; Aharon Lanin; Andrew Glass. Unicode Bidirectional Algorithm. 14 May 2017. Unicode Standard Annex #9. URL: https://www.unicode.org/reports/tr9/tr9-37.html 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[FILEAPI]
    Marijn Kruisselbrink. File API. URL: https://w3c.github.io/FileAPI/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[IANA-URI-SCHEMES]
    Uniform Resource Identifier (URI) Schemes. URL: https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MEDIA-SOURCE]
    Matthew Wolenetz; et al. Media Source Extensions™. URL: https://w3c.github.io/media-source/ 
[PSL]
    Public Suffix List. Mozilla Foundation.
[RFC4291]
    R. Hinden; S. Deering. IP Version 6 Addressing Architecture. February 2006. Draft Standard. URL: https://tools.ietf.org/html/rfc4291 
[UTS46]
    Mark Davis; Michel Suignard. Unicode IDNA Compatibility Processing. 8 June 2017. Unicode Technical Standard #46. URL: https://www.unicode.org/reports/tr46/tr46-19.html 
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[RFC1034]
    P.V. Mockapetris. Domain names - concepts and facilities. November 1987. Internet Standard. URL: https://tools.ietf.org/html/rfc1034 
[RFC3986]
    T. Berners-Lee; R. Fielding; L. Masinter. Uniform Resource Identifier (URI): Generic Syntax. January 2005. Internet Standard. URL: https://tools.ietf.org/html/rfc3986 
[RFC3987]
    M. Duerst; M. Suignard. Internationalized Resource Identifiers (IRIs). January 2005. Proposed Standard. URL: https://tools.ietf.org/html/rfc3987 
[RFC5952]
    S. Kawamura; M. Kawashima. A Recommendation for IPv6 Address Text Representation. August 2010. Proposed Standard. URL: https://tools.ietf.org/html/rfc5952 
[RFC6454]
    A. Barth. The Web Origin Concept. December 2011. Proposed Standard. URL: https://tools.ietf.org/html/rfc6454 
[RFC7595]
    D. Thaler, Ed.; T. Hansen; T. Hardie. Guidelines and Registration Procedures for URI Schemes. June 2015. Best Current Practice. URL: https://tools.ietf.org/html/rfc7595 
[RFC791]
    J. Postel. Internet Protocol. September 1981. Internet Standard. URL: https://tools.ietf.org/html/rfc791 
[UTR36]
    Mark Davis; Michel Suignard. Unicode Security Considerations. 19 September 2014. Unicode Technical Report #36. URL: https://www.unicode.org/reports/tr36/ 

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://url.spec.whatwg.org/">URL Standard</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/url">GitHub whatwg/url</a> (<a href="https://github.com/whatwg/url/issues/new">new issue</a>, <a href="https://github.com/whatwg/url/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	<a href="https://github.com/whatwg/url/commits">GitHub whatwg/url/commits</a>
	<a href="https://url.spec.whatwg.org/commit-snapshots/23af4fb31f3d946ed85d1eb9db6329578c29511c/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/urlstandard">@urlstandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/url">web-platform-tests url/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/url">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）


</script>


</head>


<body>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDUiIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzNjNzkwYSIgc3Ryb2tlLXdpZHRoPSIxMCIvPgo8cGF0aCBkPSJtNDUsMzFoMTB2MTBoLTEwem0wLDI4aDEwdjEwaC0xMCIgZmlsbD0iIzNjNzkwYSIvPgo8L3N2Zz4K"
></a>

	<hgroup>
<h1>URL</h1>
	</hgroup>
</header>


<div id="MAIN" style="display:none;">



<h2 id="abstract">要約</h2>
<p>
URL 標準は、［
~URL, ~domain, ~IP~address, ~form_urlencoded形式,
］および それらの~APIを定義する。
◎
The URL Standard defines URLs, domains, IP addresses, the application/x-www-form-urlencoded format, and their API.
</p>

<main id="MAIN0">

	<section id="goals">
<h2 title="Goals">目標</h2>

<p>
URL 標準は、次のように取り~~組むことにより，~URLを全部的に相互運用可能にすることを目指す：
◎
The URL standard takes the following approach towards making URLs fully interoperable:
</p>

<ul>
	<li>
RFC 3986 と RFC 3987 を現今の実装に揃わせて、その過程の中でそれらを過去のものにする。
（例えば、空白類, 他の “合法でない” ~cp, ~queryの符号化法, 同等性, 正準化, などの概念は、どれも~~完全には共有-もしくは定義されていない。）
~URLの構文解析-法は~HTMLの構文解析-法と同程度に確定的になる必要がある。
`RFC3986$r
`RFC3987$r
◎
Align RFC 3986 and RFC 3987 with contemporary implementations and obsolete them in the process. (E.g., spaces, other "illegal" code points, query encoding, equality, canonicalization, are all concepts not entirely shared, or defined.) URL parsing needs to become as solid as HTML parsing. [RFC3986] [RFC3987]
</li>
	<li>
語~URLを標準~化する。
URI と IRI は混同され易い。
実施においては，どちらに対しても同じ~algoが利用されるので、それらを区別する利点は無い。
<a href="https://trends.google.com/trends/explore?q=url,uri">~Webの検索結果</a>
でも~URLの方が優位にある。
◎
Standardize on the term URL. URI and IRI are just confusing. In practice a single algorithm is used for both so keeping them distinct is not helping anyone. URL also easily wins the search result popularity contest.
</li>
	<li>
<a href="~IETF/rfc6454#section-4">URI [sic] の生成元</a>
`RFC6454$r
に取って代わる。
◎
Supplanting Origin of a URI [sic]. [RFC6454]
</li>
	<li>
~URLの既存の~JS~APIにおける全部的な詳細を定義し、より扱い易くなる様に~~機能を強化する。
また、~HTML要素を通さずに~URLを操作できるようにする（ ~JS~worker環境からも有用にする）ため，
`URL$I ~objを新たに追加する。
◎
Define URL’s existing JavaScript API in full detail and add enhancements to make it easier to work with. Add a new URL object as well for URL manipulation without usage of HTML elements. (Useful for JavaScript worker environments.)
</li>
	<li>
［
構文解析器, 直列化器, ~API
］の組み合わせにおける冪等性を保証する。
例えば、構文解析してから直列化する演算を重ねて適用しても， 1 回だけ適用した結果（失敗でないとする）と同じになること。
同様に、~APIを通して操作した結果（失敗でないとする）に対し，それを直列化してから構文解析した結果は、何回~適用しようが同じになること。
◎
Ensure the combination of parser, serializer, and API guarantee idempotence. For example, a non-failure result of a parse-then-serialize operation will not change with any further parse-then-serialize operations applied to it. Similarly, manipulating a non-failure result through the API will not change from applying any number of serialize-then-parse operations to it.
</ul>

<p class="note">注記：
編集者たちがこの~~主題に関しより多くを学ぶに連れ、目標となる視野は~~拡がるかもしれない。
◎
As the editors learn more about the subject matter the goals might increase in scope somewhat.
</p>

	</section>

	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（
~LET, 此れ, ε, ~INCBY, { <var>…</var> }, ~IF, ~THROW, 等々
）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<ul>
	<li>
記号 ~INCBY, ~DECBY は，~stream／配列~内の位置を指す~pointerの増減操作に特に用いられる。
</li>
	<li>
集合の表記（ { <var>…</var> } ）は、ほとんどが~cpの集合または~byte値の集合に用いられる。
</li>
	<li>
入子にされた集合については、和集合をとることを意味する。
例えば，~cpの集合 %S, ~cp %t に対する { %S, %t } は、 %S と { %t } の和集合を意味する。
</li>
</ul>

<p>
加えて、次の記法も用いる：
</p>

<dl>
	<dt>%s ~APPEND %a ~APPEND %b ~APPEND …</dt>
	<dd>
左辺の［
文字列／~byte列
］ %s の末尾に後続の［
文字列／~byte列
］ %a, %b, … を示された順に付加する演算を表す。
式として用いられた場合、結果の %s が式の値になる。
</dd>

	<dt>`失敗^i （原文では “`failure^i” ）</dt>
	<dd>
この仕様にて定義される種々の~algoにおいて，通常~期待されている値を返せないときに返される，~~特別な値（当の処理に失敗したことを意味する）。
</dd>
</dl>

	</section>

	<section id="infrastructure">

<h2 title="Infrastructure">1. 基盤</h2>

<p>
この仕様は Infra Standard `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<div class="p">
<p>
この仕様に利用される一部の用語は、次の各種 標準／仕様にて定義される：
</p>

<ul ><li>DOM Standard `DOM$r
</li><li>Encoding Standard `ENCODING$r
</li><li>File API `FILEAPI$r
</li><li>HTML Standard `HTML$r
</li><li>Media Source Extensions `MEDIA-SOURCE$r
</li><li>Unicode IDNA Compatibility Processing `UTS46$r
</li><li>Web IDL `WEBIDL$r
</li></ul>

◎
Some terms used in this specification are defined in the following standards and specifications:

• DOM Standard [DOM]
• Encoding Standard [ENCODING]
• File API [FILEAPI]
• HTML Standard [HTML]
• Media Source Extensions [MEDIA-SOURCE]
• Unicode IDNA Compatibility Processing [UTS46]
• Web IDL [WEBIDL]
</div>

<hr>

<p class="algo-head">
`整数を直列化する@
ときは、所与の
( 整数 %N )
に対し， %N を 10 進数で表現する最短の文字列を返す。
◎
To serialize an integer, represent it as the shortest possible decimal number.
</p>

		<section id="writing">
<h3 title="Writing">1.1. 書式</h3>

<p>
`検証~error@
とは、入力と妥当な入力との間の不一致を意味する。
~UA，とりわけ適合性~検査器には、どこかへそれを報告することが奨励される。
◎
A validation error indicates a mismatch between input and valid input. User agents, especially conformance checkers, are encouraged to report them somewhere.
</p>

<div class="note">
<p>注記：
`検証~error$は、構文解析器を終了させるものではない。
構文解析器の終了は、常に，明示的にそう記される
— ~RET 文などにより。
◎
A validation error does not mean that the parser terminates. Termination of a parser is always stated explicitly, e.g., through a return statement.
</p>

<p>
`検証~error$を通達するのは有用になる
—
~errorの取扱いは直感的でないこともあり、旧来の~UAは 正しい~errorの取扱いを実装しないかもしれず、他の開発者にとっては 何を意図して書出されたか明瞭でないかもしれないので。
◎
It is useful to signal validation errors as error-handling can be non-intuitive, legacy user agents might not implement correct error-handling, and the intent of what is written might be unclear to other developers.
</p>

</div>

		</section>
		<section id="parsers">
<h3 title="Parsers">1.2. 構文解析器</h3>

<p>
`EOF@i
とは、［
文字列~stream ／ ~cp~stream
］の終端を表す，仮想の~cpである†。
◎
The EOF code point is a conceptual code point that signifies the end of a string or code point stream.
</p>

<p class="trans-note">【
“End Of File”
— この訳では、原文の “EOF ~cp” を単に “EOF” と略記する。
】【†
すなわち、自身以外のどの~cpにも等しくない
】</p>

<p>
記号
`C@V,
`C1@V,
`C2@V
は、（処理中の文字列~内の文字~位置を指す） %~pointer 変数を利用する構文解析器の中で用いられ，順に［
%~pointer 変数が指している~cp, その次の~cp, 次の次の~cp
］を参照する。
%~pointer 変数が文字列の外を指している場合の `C$V は， `EOF$i になり、
`C1$V, `C2$V についても同様になる。
◎
Within a parser algorithm that uses a pointer variable, c references the code point the pointer variable points to.
◎
Within a string-based parser algorithm that uses a pointer variable, remaining references the substring after pointer in the string being processed.
</p>

<p class="example">
例えば、処理中の`文字列$が
`http://example.com^l
で， %~pointer が `o^l を指しているなら、［
`C$V, `C1$V, `C2$V
］は、順に［
❝o, ❝m, `EOF$i
］になる。
◎
If "mailto:username@example" is a string being processed and pointer points to @, c is U+0040 (@) and remaining is "example". 
</p>

<p class="trans-note">【
`C1$V, `C2$V は、原文の
<dfn id="remaining">%remaining</dfn>
に代えて，この訳に導入した記号である
— %remaining は %~pointer より後の（ `C1$V 以降の）部分を成す文字列を表すが、それを利用しているどの箇所も，実際には `C1$V, `C2$V しか利用していないので。
】【
`C$V は，原文では小文字 “c” であるが、日本語の字の大きさとの兼ね合いにより，この訳では大文字で記すことにする。
】</p>


		</section>
		<section id="percent-encoded-bytes">
<h2 title="Percent-encoded bytes">1.3. ~percent-符号化された~byte</h2>

<p class="trans-note">【
“~percent-” は、原文の接頭語 “percent-” の（この訳による）略記であり，文字 `%^l に関わることを表す。
】</p>

<p>
`~percent-符号化された~byte@
とは、［
❝%, `~ASCII~hex数字$, `~ASCII~hex数字$
］の並びが成す文字列である。
`~percent-符号化された~byte$を~byte列に変換した結果に
`~BOMも失敗-もそのままに~UTF-8復号する$を適用した結果が `失敗^i になることはない筈である。
◎
A percent-encoded byte is U+0025 (%), followed by two ASCII hex digits. Sequences of percent-encoded bytes, after conversion to bytes, should not cause UTF-8 decode without BOM or fail to return failure.
</p>

<p class="algo-head">
`~byteを文字列に~percent-符号化する@
ときは、所与の
( 1 個の~byte %~byte )
に対し，次に与える`~percent-符号化された~byte$を返す
⇒
❝% ~APPEND ［
%~byte を表現する 2 個の`~ASCII~hex数字（大文字）$
］
◎
To percent encode a byte into a percent-encoded byte, return a string consisting of U+0025 (%), followed by two ASCII upper hex digits representing byte. 
</p>

<p class="algo-head">
`~byte列を~byte列に~percent-復号する@
ときは、所与の
( `~byte列$ %入力 )
に対し，次を走らす：
◎
To percent decode a byte sequence input, run these steps:
</p>

<p class="warning">警告：
［［
`~ASCII~byte$の以外の~byte
］が含まれ得るような %入力
］に対する
`~BOMはそのままに~UTF-8復号する$以外の利用は，保安的でないこともあるので、推奨されない。
◎
Using anything but UTF-8 decode without BOM when the input contains bytes that are not ASCII bytes might be insecure and is not recommended. 
</p>

<ol>
	<li>
%出力 ~LET 空`~byte列$
◎
Let output be an empty byte sequence.
</li>
	<li>
%L ~LET %入力 の`長さ$byte
◎
↓</li>
	<li>
%N ~LET 1
◎
↓</li>
	<li>
<p>
~WHILE［
%N ~LTE %L
］：
</p>
		<ol>
			<li>
%~byte ~LET %入力 の %N 個目の~byte
</li>
			<li>
%N ~INCBY 1
</li>
			<li>
<p>
~IF［
%~byte ~EQ ❛%
］~AND［
%N ~PLUS 1 ~LTE %L
］：
</p>
				<ol>
					<li>
%~byte列 ~LET %入力 の［
%N 個目, %N ~PLUS 1 個目
］の~byteが成す~byte列
</li>
					<li>
<p>
~IF［
%~byte列 を成すどの~byte %b も［
%b ~IN { ❛0 〜 ❛9, ❛A 〜 ❛F, ❛a 〜 ❛f }
］を満たす
］：
</p>
						<ol>
							<li>
%~hex文字列 ~LET `~BOMはそのままに~UTF-8復号する$( %~byte列 )
</li>
							<li>
%~byte ~SET ［
%~hex文字列 を~hexadecimal数として解釈した結果の数
］を値とする~byte
</li>
							<li>
%N ~INCBY 2
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%出力 ~APPEND %~byte
</li>
		</ol>
◎
For each byte byte in input:
• If byte is not 0x25 (%), then append byte to output.
• Otherwise, if byte is 0x25 (%) and the next two bytes after byte in input are not in the ranges 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F), and 0x61 (a) to 0x66 (f), all inclusive, append byte to output.
• Otherwise:
•• Let bytePoint be the two bytes after byte in input, decoded, and then interpreted as hexadecimal number.
•• Append a byte whose value is bytePoint to output.
•• Skip the next two bytes in input.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="algo-head">
`文字列を~byte列に~percent-復号する@
ときは、所与の
( 文字列 %入力 )
に対し，次の結果を返す
⇒
`~byte列を~byte列に~percent-復号する$( `~UTF-8符号化する$( %入力 ) )
◎
To string percent decode a string input, run these steps:
• Let bytes be the UTF-8 encoding of input.
• Return the percent decoding of bytes.
</p>

<hr>

<p class="trans-note">【
次に挙げる各種 ~cpの集合は、`~UTF-8~percent-符号化する$ときに利用される：
】</p>

<ul>
	<li>
`~C0制御文字~percent-符号化-集合@
は、次に挙げる~cpの集合である
⇒＃
`~C0制御文字$,
`007F^U DELETE 〜 `10FFFF^U
◎
The C0 control percent-encode set are the C0 controls and all code points greater than U+007E (~).
</li>
	<li>
`素片~percent-符号化-集合@
は、次に挙げる~cpの集合である
⇒＃
`~C0制御文字~percent-符号化-集合$,
`0020^U,
❝",
`003C^U `&lt;^smb,
`003E^U `&gt;^smb,
❝`
◎
The fragment percent-encode set is the C0 control percent-encode set and U+0020 SPACE, U+0022 ("), U+003C (&lt;), U+003E (&gt;), and U+0060 (`).
</li>
	<li>
`~path~percent-符号化-集合@
は、次に挙げる~cpの集合である
⇒＃
`素片~percent-符号化-集合$,
❝#,
❝?,
❝},
❝{
◎
The path percent-encode set is the fragment percent-encode set and U+0023 (#), U+003F (?), U+007B ({), and U+007D (}). 
</li>
	<li>
`~userinfo~percent-符号化-集合@
は、次に挙げる~cpの集合である
⇒＃
`~path~percent-符号化-集合$,
❝/,
❝:,
❝;,
❝=,
❝@,
❝[,
❝\,
❝],
❝^,
❝|
◎
The userinfo percent-encode set is the path percent-encode set and U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([), U+005C (\), U+005D (]), U+005E (^), and U+007C (|). 
</li>
</ul>

<p class="algo-head">
`~UTF-8~percent-符号化する@
ときは、所与の
( ~cpの集合 %~percent-符号化-集合,  1 個の~cp %~cp )
に対し，次を走らす：
◎
To UTF-8 percent encode a codePoint, using a percentEncodeSet, run these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~NIN %~percent-符号化-集合
］
⇒
~RET %~cp
◎
If codePoint is not in percentEncodeSet, then return codePoint.
</li>
	<li>
%~byte列 ~LET `~UTF-8符号化する$( %~cp )
◎
Let bytes be the result of running UTF-8 encode on codePoint.
</li>
	<li>
%結果 ~LET 空~文字列
◎
↓</li>
	<li>
%~byte列 内の
~EACH( %~byte )
に対し
⇒
%結果 ~APPEND `~byteを文字列に~percent-符号化する$( %~byte )
◎
Percent encode each byte in bytes, and then＼
</li>
	<li>
~RET %結果
◎
return the results concatenated, in the same order.
</li>
</ol>


		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security considerations">2. 保安~上の考慮点</h2>

<p>
`~URL$の保安は、その環境の役務である。
`~URL$を，周りに向けて描画する／渡す, あるいは 周りのそれを解釈するときには、注意すること。
◎
The security of a URL is a function of its environment. Care is to be taken when rendering, interpreting, and passing URLs around.
</p>

<p>
新たな`~URL$を描画したり，あてがうときは、
“なりすまし（ `spoofing^en ）”
について考慮する必要がある。
`~host$／`~URL$ による攻撃は、誰かを誤認させる可能性がある。
具体例として、
1/l/I, m/rn/rri, 0/O, а/a
は，どれも酷似するものになり得る†。
`202A^U LEFT-TO-RIGHT EMBEDDING
等々のような，より~~問題になる不可視の††~cpすらある。
`UTR36$r
◎
When rendering and allocating new URLs "spoofing" needs to be considered. An attack whereby one host or URL can be confused for another. For instance, consider how 1/l/I, m/rn/rri, 0/O, and а/a can all appear eerily similar. Or worse, consider how U+202A LEFT-TO-RIGHT EMBEDDING and similar code points are invisible. [UTR36]
</p>

<p class="trans-note">【
“描画（ `rendering^en ）” の原義には、音声化なども含まれる
— その場合、発音が似るものに対し，同様のことが該当することになる。
】【†
一般的には見かけがかなり異なる文字でも、例えば，その場の環境にて可用な~fontに依存して酷似するかもしれない。
】【
非 英語話者にとっては、綴りや字形が異なっていても発音が似るがため，錯覚し易いものもあるかもしれない
— 例えば “correction” と “collection” 。
】【††
空間すら占めない。
】【
参考：
<a href="http://unicode.org/faq/idn.html">IDN FAQ</a>
】</p>

<p>
主体 %A から主体 %B へ`~URL$が渡されるときは、いずれの側も，何が起きるか注意深く考慮する必要がある。
%A は、意に反して~dataを漏洩するはめになり得る。
%B は、自身が予期していない入力を受取って利用者に害する動作をとる可能性がある。
特に、 %B は，決して %A を信用するべきでない
— 渡される`~URL$は，常に信用できる源に~~由来するとは限らないので。
◎
When passing a URL from party A to B, both need to carefully consider what is happening. A might end up leaking data it does not want to leak. B might receive input it did not expect and take an action that harms the user. In particular, B should never trust A, as at some point URLs from A can come from untrusted sources.
</p>

	</section>
	<section id="hosts-(domains-and-ip-addresses)">
<h2 title="Hosts (domains and IP addresses)">3. ~host（~domainと~IP~address）</h2>

<p>
高次の~levelからは、［
`~host$, `妥当な~host$sT, `~host構文解析器$, `~host直列化器$
］は，次のように関係する：
◎
At a high level, a host, valid host string, host parser, and host serializer relate as follows:
</p>

<ul>
	<li>
`~host構文解析器$は、任意の~~入力~文字列に対し［
`失敗^i, または `~host$
］を返す。
◎
The host parser takes an arbitrary string and returns either failure or a host.
</li>
	<li>
`~host$は、記憶域内の表現と捉えることもできる。
◎
A host can be seen as the in-memory representation.
</li>
	<li>
`妥当な~host$sTは、`~host構文解析器$に与えたときに，`検証~error$や `失敗^i を誘発しない
— すなわち、［
適合する／妥当である
］と見なされる —
ような入力を定義する。
◎
A valid host string defines what input would not trigger a validation error or failure when given to the host parser. I.e., input that would be considered conforming or valid.
</li>
	<li>
`~host直列化器$は、~~入力の`~host$に対し，文字列を返す。
（その文字列をさらに`~host構文解析器$にかけた結果は、元の`~host$と`同等$hostになる。）
◎
The host serializer takes a host and returns a string. (If that string is then parsed, the result will equal the host that was serialized.)
</li>
</ul>

		<section id="host-representation">
<h3 title="Host representation">3.1. ~host表現</h3>

<p>
`~host@
は、［
`~domain$,
`~IPv4~address$,
`~IPv6~address$,
`不透明な~host$,
`空~host$
］のいずれかである。
`~host$は，概して~network~addressとして~~機能するが、~network~addressが必要とされない所では，`~URL$内で 不透明な識別子として利用されることもある。
◎
A host is a domain, an IPv4 address, an IPv6 address, an opaque host, or an empty host. Typically a host serves as a network address, but it is sometimes used as opaque identifier in URLs where a network address is not necessary.
</p>

<p class="note">注記：
下の各 段落~内で参照されている RFC は、参考目的に限られる。
それらは、`~host$の書式, 構文解析-法, 直列化には何ら波及しない。
以下の節にて他が言明されない限り。
◎
The RFCs referenced in the paragraphs below are for informative purposes only. They have no influence on host writing, parsing, and serialization. Unless stated otherwise in the sections that follow.
</p>


<p>
`~domain@
とは、~networkの中の~realmを識別する`~ASCII文字列$である。
`RFC1034$r
◎
A domain is an ASCII string that identifies a realm within a network. [RFC1034]
</p>

<p class="note">
2 つの~domain
`example.com^l と `example.com.^l
は、等価ではなく，概して別物に扱われる。
◎
The example.com and example.com. domains are not equivalent and typically treated as distinct.
</p>

<p>
`~IPv4~address@
は、~network~addressを識別する 32-bit 無符号~整数である。
`RFC791$r
◎
An IPv4 address is a 32-bit unsigned integer that identifies a network address. [RFC791]
</p>

<p>
`~IPv6~address@
は，~network~addressを識別する 128-bit 無符号~整数であり、この標準~の目的においては， 8 個の［
`~IPv6~piece@
と称される， 16-bit 無符号~整数
］からなる`~list$として表現される。
`RFC4291$r
◎
An IPv6 address is a 128-bit unsigned integer that identifies a network address. For the purposes of this standard it is represented as a list of eight 16-bit unsigned integers, also known as IPv6 pieces. [RFC4291]
</p>

<p class="note">注記：
<code>&lt;zone_id&gt;</code> の~supportは、
<a href="~SPECBUGS?id=27234#c2">意図的に除かれている</a>。
◎
Support for &lt;zone_id&gt; is intentionally omitted.
</p>

<p>
`不透明な~host@
は、［
更なる処理に利用され得る~data
］を保持する，空でない`~ASCII文字列$である
◎
An opaque host is a non-empty ASCII string holding data that can be used for further processing.
</p>

<p>
`空~host@
は、空~文字列である。
◎
An empty host is the empty string.
</p>

		</section>
		<section id="host-miscellaneous">
<h3 title="Host miscellaneous">3.2. ~hostのその他諸々</h3>

<p>
次に挙げる~cpは
`禁止~host~cp@
とされる
⇒＃
`0000^U NULL,
`0009^U TAB,
`000A^U LF,
`000D^U CR,
`0020^U SPACE,
❝#,
❝%,
❝/,
❝:,
❝?,
❝@,
❝[,
❝\,
❝]
◎
A forbidden host code point is U+0000 NULL, U+0009 TAB, U+000A LF, U+000D CR, U+0020 SPACE, U+0023 (#), U+0025 (%), U+002F (/), U+003A (:), U+003F (?), U+0040 (@), U+005B ([), U+005C (\), or U+005D (]).
</p>

<p class="algo-head">
`~host$の
`公共接尾辞@
（ `public suffix^en ）は、`~host$内の，~PublicSuffixList `PSL$r に含まれる部位である。
所与の %~host の`公共接尾辞$を得るときは、次を走らす：
◎
A host’s public suffix is the portion of a host which is included on the Public Suffix List. To obtain host’s public suffix, run these steps: [PSL]
</p>

<ol>
	<li>
~IF［
%~host は`~domain$でない
］
⇒
~RET ~NULL
◎
If host is not a domain, then return null.
</li>
	<li>
~RET ［
`~PublicSuffixListにより定義される~algo$
`PSL$r
］を， %~host に対し実行して得られる`公共接尾辞$
◎
Return the public suffix obtained by executing the algorithm defined by the Public Suffix List on host. [PSL].
</li>
</ol>

<p class="algo-head">
`~host$の
`登録-可能な~domain@
（ `registrable domain^en ）は、最も特定的な公共接尾辞により
— および，その直前に~domain~labelがあれば それも込みで —
形成される`~domain$である。
所与の %~host の`登録-可能な~domain$を得るときは、次を走らす：
◎
A host’s registrable domain is a domain formed by the most specific public suffix, along with the domain label immediately preceeding it, if any. To obtain host’s registrable domain, run these steps:
</p>

<ol>
	<li>
~IF［
%~host の`公共接尾辞$ ~EQ ~NULL
］~OR［
( %~host の`公共接尾辞$, %~host )
は`同等$hostである
］
⇒
~RET ~NULL
◎
If host’s public suffix is null or host’s public suffix equals host, then return null.
</li>
	<li>
~RET ［
`~PublicSuffixListにより定義される~algo$
`PSL$r
］を， %~host に対し実行して得られる`登録-可能な~domain$
◎
Return the registrable domain obtained by executing the algorithm defined by the Public Suffix List on host. [PSL]
</li>
</ol>

<div class="example">
<table><tbody>

<tr><th>入力~host
◎
Host input
<th>公共接尾辞
◎
Public suffix
<th>登録-可能な~domain
◎
Registrable domain
</tr>

<tr><td>`com^c
<td>`com^c
<td><i>null</i>
</tr>

<tr><td>`example.com^c
<td>`com^c
<td>`example.com^c
</tr>

<tr><td>`www.example.com^c
<td>`com^c
<td>`example.com^c
</tr>

<tr><td>`sub.www.example.com^c
<td>`com^c
<td>`example.com^c
</tr>

<tr><td>`EXAMPLE.COM^c
<td>`com^c
<td>`example.com^c
</tr>

<tr><td>`github.io^c
<td>`github.io^c
<td><i>null</i>
</tr>

<tr><td>`whatwg.github.io^c
<td>`github.io^c
<td>`whatwg.github.io^c
</tr>

<tr><td>`إختبار^c
<td>`xn-kgbechtv^c
<td><i>null</i>
</tr>

<tr><td>`example.إختبار^c
<td>`xn-kgbechtv^c
<td>`example.xn-kgbechtv^c
</tr>

<tr><td>`sub.example.إختبار^c
<td>`xn-kgbechtv^c
<td>`example.xn-kgbechtv^c
</tr></tbody></table>
</div>


<p>
2 つの`~host$
( %A, %B )
は、次の言明のいずれかを満たすならば、互いに
`同じ~site@
とされる：
◎
Two hosts, A and B are said to be same site with each other if either of the following statements are true:
</p>

<ul class="brief">
	<li>
［
( %A, %B )
は`同等$hostである
］~AND［
%A の`登録-可能な~domain$ ~NEQ ~NULL
］
◎
A equals B and A’s registrable domain is non-null.
</li>
	<li>
%A の`登録-可能な~domain$ ~EQ %B の`登録-可能な~domain$ ~NEQ ~NULL
◎
A’s registrable domain is B’s registrable domain and is non-null.
</li>
</ul>

<div class="example">

<p>
`suffix.example^c は`公共接尾辞$で，
`example.com^c はそうでないと見做すならば：
◎
Assuming that suffix.example is a public suffix and that example.com is not:
</p>

<ul>
	<li>
次に挙げるものは、どれも，互いに（および, それぞれ自身とも）`同じ~site$になる
⇒＃
`example.com^c,
`sub.example.com^c,
`other.example.com^c,
`sub.sub.example.com^c,
`sub.other.example.com^c
◎終
— どれも，`登録-可能な~domain$は `example.com^c になるので。
◎
example.com, sub.example.com, other.example.com, sub.sub.example.com, and sub.other.example.com are all same site with each other (and themselves), as their registrable domains are example.com.
</li>
	<li>
次に挙げるものは、どれも，互いに（および, それぞれ自身とも）`同じ~site$になる
⇒＃
`registrable.suffix.example^c,
`sub.registrable.suffix.example^c,
`other.registrable.suffix.example^c,
`sub.sub.registrable.suffix.example^c,
`sub.other.registrable.suffix.example^c
◎終
— どれも，`登録-可能な~domain$は `registrable.suffix.example^c になるので。
◎
registrable.suffix.example, sub.registrable.suffix.example, other.registrable.suffix.example, sub.sub.registrable.suffix.example, and sub.other.registrable.suffix.example are all same site with each other (and themselves), as their registrable domains are registrable.suffix.example.
</li>
	<li>
次に挙げる 2 つは、互いに`同じ~site$でない
⇒＃
`example.com^c,
`registrable.suffix.example^c
◎終
— `登録-可能な~domain$が相違するので
◎
example.com and registrable.suffix.example are not same site with each other, as their registrable domains differ.
</li>
	<li>
`suffix.example^c は、自身と`同じ~site$でない
— それは`公共接尾辞$であり，`登録-可能な~domain$は ~NULL になるので。
◎
suffix.example is not same site with suffix.example, as it is a public suffix, and therefore has a null registrable domain.
</li>
</ul>
</div>


<p class="warning">
仕様は、［
“`公共接尾辞$” ／
“`登録-可能な~domain$” ／
“`同じ~site$”
］に依存するのを避けるべきである。
公共接尾辞~listは，~clientごとに分岐するので、それに依拠して，堅固な保安~境界を供することはできない。
この助言を無視する仕様は、［［
2 つの`~host$は`同じ~site$かどうか
］に基づいて下される裁定の中に，~URLの~schemeは組入れるべきとされるか
］について，注意深く考慮することが奨励される。
~HTMLの`同じ生成元~domain$の概念は、実施において これが考慮された適度な例である。
◎
Specifications should avoid depending on "public suffix", "registrable domain", and "same site". The public suffix list will diverge from client to client, and cannot be relied-upon to provide a hard security boundary. Specifications which ignore this advice are encouraged to carefully consider whether URLs' schemes ought to be incorporated into any decision made based upon whether or not two hosts are same site. HTML’s same origin-domain concept is a reasonable example of this consideration in practice.
</p>

		</section>
		<section id="idna">
<h3 title="IDNA">3.3. IDNA</h3>

<p class="algo-head">
`~domainを~ASCII化する@
ときは、所与の
( `文字列$ %~domain, 真偽値 %beStrict （省略時は ~F） )
に対し，次を走らす：
◎
The domain to ASCII algorithm, given a string domain and optionally a boolean beStrict, runs these steps:
◎
If beStrict is not given, set it to false.
</p>

<ol>
	<li>
%結果 ~LET 次を与える下で， `Unicode ToASCII$AO を走らせた結果
⇒＃
`domain_name^i ~SET %~domain,
`UseSTD3ASCIIRules^i ~SET %beStrict,
`CheckHyphens^i ~SET ~F,
`CheckBidi^i ~SET ~T,
`CheckJoiners^i ~SET ~T,
`Transitional_Processing^i ~SET ~F,
`VerifyDnsLength^i ~SET %beStrict
◎
Let result be the result of running Unicode ToASCII with domain_name set to domain, UseSTD3ASCIIRules set to beStrict, CheckHyphens set to false, CheckBidi set to true, CheckJoiners set to true, Transitional_Processing set to false, and VerifyDnsLength set to beStrict.
</li>
	<li>
~IF［
%結果 ~EQ `失敗^i
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If result is a failure value, validation error, return failure.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="algo-head">
`~domainを~Unicode化する@
ときは、所与の`~domain$ %~domain に対し，次を走らす：
◎
The domain to Unicode algorithm, given a domain domain, runs these steps:
</p>

<ol>
	<li>
%結果 ~LET 次を与える下で， `Unicode ToUnicode$AO を走らせた結果
⇒＃
`domain_name^i ~SET %~domain,
`CheckHyphens^i ~SET ~F,
`CheckBidi^i ~SET ~T,
`CheckJoiners^i ~SET ~T,
`UseSTD3ASCIIRules^i ~SET ~F,
`Transitional_Processing^i ~SET ~F
◎
Let result be the result of running Unicode ToUnicode with domain_name set to domain, CheckHyphens set to false, CheckBidi set to true, CheckJoiners set to true, UseSTD3ASCIIRules set to false, and Transitional_Processing set to false.
</li>
	<li>
~IF［
%結果 に何らかの~errorがある
］
⇒
`検証~error$
◎
Signify validation errors for any returned errors, and then＼
</li>
	<li>
~RET %結果
◎
return result.
</li>
</ol>

		</section>
		<section id="host-writing">
<h3 title="Host writing">3.4. ~hostの書式</h3>

<div class="p">
<p>
`妥当な~host@sT
は、次のいずれかで~MUST：
</p>

<ul><li>`妥当な~domain$sT
</li><li>`妥当な~IPv4~address$sT
</li><li>
<p>
次の並び：
</p>
	<ol><li>❝[
	</li><li>`妥当な~IPv6~address$sT
	</li><li>❝]
	</li></ol>
</li></ul>

◎
A valid host string must be a valid domain string, a valid IPv4-address string, or: U+005B ([), followed by a valid IPv6-address string, followed by U+005D (]).
</div>


<p class="algo-head">
次の手続きが `成功^i を返すような %~domain は、
`妥当な~domain@
であるとされる：
◎
A domain is a valid domain if these steps return success:
</p>


<ol>
	<li>
%結果 ~LET `~domainを~ASCII化する$( %~domain, ~T )
◎
Let result be the result of running domain to ASCII with domain and true.
</li>
	<li>
~IF［
%結果 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If result is failure, then return failure.
</li>
	<li>
%結果 ~SET 次を与える下で， `Unicode ToUnicode$AO を走らせた結果
⇒＃
`domain_name^i ~SET %結果,
`CheckHyphens^i ~SET ~F,
`CheckBidi^i ~SET ~T,
`CheckJoiners^i ~SET ~T,
`UseSTD3ASCIIRules^i ~SET ~T,
`Transitional_Processing^i ~SET ~F
◎
Set result to the result of running Unicode ToUnicode with domain_name set to result, CheckHyphens set to false, CheckBidi set to true, CheckJoiners set to true, UseSTD3ASCIIRules set to true, and Transitional_Processing set to false.
</li>
	<li>
~IF［
%結果 に何らかの~errorがある
］
⇒
~RET `失敗^i
◎
If result contains any errors, return failure.
</li>
	<li>
~RET `成功^i
◎
Return success.
</li>
</ol>

<p class="XXX">課題：
理想的には、`妥当な~domain$を成す~cpの並びを通して定義したい所
— モグラ叩きのように定義するのではなく：
<a href="~SPECBUGS?id=25334">bug 25334</a>
◎
Ideally we define this in terms of a sequence of code points that make up a valid domain rather than through a whack-a-mole: bug 25334.
</p>

<p>
`妥当な~domain@sT
は、`妥当な~domain$を与える文字列で~MUST。
◎
A valid domain string must be a string that is a valid domain.
</p>

<p>
`妥当な~IPv4~address@sT
は、 4 個の［
0 〜 255 の 10 進数を表現する［
3 個までの`~ASCII数字$からなる並び
］］を， ❝. で区切った並びで~MUST。
◎
A valid IPv4-address string must be four sequences of up to three ASCII digits per sequence, each representing a decimal number no greater than 255, and separated from each other by U+002E (.).
</p>

<p>
`妥当な~IPv6~address@sT
は、 IP Version 6 Addressing Architecture の
<a href="~IETF/rfc4291#section-2.2">Text Representation of Addresses</a>
（ “~addressの~text表現” ）章にて定義される。
`RFC4291$r
◎
A valid IPv6-address string is defined in the "Text Representation of Addresses" chapter of IP Version 6 Addressing Architecture. [RFC4291]
</p>

<p>
`妥当な不透明な~host@sT
は、次のいずれかで~MUST：
◎
A valid opaque-host string must be＼
</p>

<ul>
	<li>
1 個以上の`~URL単位$からなる並び
◎
one or more URL units or:＼
</li>
	<li>
次の並び：
<ol ><li>❝[
</li><li>`妥当な~IPv6~address$sT
</li><li>❝]
</li></ol>
◎
U+005B ([), followed by a valid IPv6-address string, followed by U+005D (]).
</li>
</ul>

<p class="note">注記：
これは、`妥当な~host$sTの定義の一部ではない
— それには、文脈を判別することが要求されるので。
◎
This is not part of the definition of valid host string as it requires context to be distinguished. 
</p>

		</section>
		<section id="host-parsing">
<h3 title="Host parsing">3.5. ~hostの構文解析-法</h3>

<p class="algo-head">
`~host構文解析器@
は、所与の
( 文字列 %入力, 真偽値 %特別でない （省略時は ~F ） )
に対し，次を走らす：
◎
The host parser takes a string input with an optional boolean isNotSpecial, and then runs these steps:
• If isNotSpecial is not given, then set isNotSpecial to false.
</p>

<ol>
	<li>
<p>
~IF［
%入力 の先頭 ~EQ ❝[
］：
◎
If input starts with U+005B ([), then:
</p>
		<ol>
			<li>
~IF［
%入力 の末尾 ~NEQ ❝]
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If input does not end with U+005D (]), validation error, return failure.
</li>
			<li>
~RET `~IPv6構文解析器$( %入力 から先頭の ❝[ と末尾の ❝] を除去した結果 )
◎
Return the result of IPv6 parsing input with its leading U+005B ([) and trailing U+005D (]) removed.
</li>
		</ol>
	</li>
	<li>
~IF［
%特別でない ~EQ ~T
］
⇒
~RET `不透明な~host構文解析器$( %入力 )
◎
If isNotSpecial is true, then return the result of opaque-host parsing input.
</li>
	<li>
<p>
%~domain ~LET `~BOMはそのままに~UTF-8復号する$( `文字列を~byte列に~percent-復号する$( %入力 ) )
◎
Let domain be the result of running UTF-8 decode without BOM on the string percent decoding of input.
</p>

<p class="note">注記：
別法として、`~BOMも失敗-もそのままに~UTF-8復号する$を利用した上で， `失敗^i 時には早々に ~RET することもできる
— `~domainを~ASCII化する$のは
`FFFD^U REPLACEMENT CHARACTER
に対し失敗するので。
◎
Alternatively UTF-8 decode without BOM or fail can be used, coupled with an early return for failure, as domain to ASCII fails on U+FFFD REPLACEMENT CHARACTER.
</p>
	</li>
	<li>
%~ASCII~domain ~LET `~domainを~ASCII化する$( %~domain )
◎
Let asciiDomain be the result of running domain to ASCII on domain.
</li>
	<li>
~IF［
%~ASCII~domain ~EQ `失敗^i
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If asciiDomain is failure, validation error, return failure.
</li>
	<li>
~IF［
%~ASCII~domain 内に`禁止~host~cp$がある
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If asciiDomain contains a forbidden host code point, validation error, return failure.
</li>
	<li>
%ipv4~host ~LET `~IPv4構文解析器$( %~ASCII~domain )
◎
Let ipv4Host be the result of IPv4 parsing asciiDomain.
</li>
	<li>
~IF［
%ipv4~host ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
↓</li>
	<li>
~IF［
%ipv4~host は`~IPv4~address$である
］
⇒
~RET %ipv4~host
◎
If ipv4Host is an IPv4 address or failure, return ipv4Host.
</li>
	<li>
~RET %~ASCII~domain
◎
Return asciiDomain.
</li>
</ol>

<p class="algo-head">
`~IPv4番号~構文解析器@
は、所与の
( 文字列 %入力 )
に対し，次を走らす：
◎
The IPv4 number parser takes a string input and a validationErrorFlag pointer, and then runs these steps:
</p>

<ol>
	<li>
<p>
%検証~error ~LET `無し^i
</p>

<p class="trans-note">【
和訳固有の既存の記号で表記する都合により、特にこの変数（原文 %validationErrorFlag ）に関して，この~algoには入出力の表記法に手を加えている。
】</p>
</li>
	<li>
%R ~LET 10
◎
Let R be 10.
</li>
	<li>
<p>
~IF［
%入力 の長さ ~GTE 2
］~AND［
%入力 の先頭の~cp ~EQ ❝0
］：
</p>
		<ol>
			<li>
%検証~error ~SET `有り^i
</li>
			<li>
%入力 から先頭の~cpを除去する
</li>
			<li>
%R ~SET 8
</li>
			<li>
<p>
~IF［
%入力 の先頭の~cp ~IN { ❝x, ❝X }
］：
</p>

<ol><li>%入力 から先頭の~cpを除去する
</li><li>%R ~SET 16
</li></ol>
			</li>
		</ol>

◎
If input contains at least two code points and the first two code points are either "0x" or "0X", then:
• Set validationErrorFlag.
• Remove the first two code points from input.
• Set R to 16.

Otherwise, if input contains at least two code points and the first code point is U+0030 (0), then:
• Set validationErrorFlag.
• Remove the first code point from input.
• Set R to 8.
</li>
	<li>
<p>
~IF［
%入力 ~EQ 空~文字列
］
⇒
~RET ( 0, %検証~error )
</p>

<p class="trans-note">【
`0x^l ／ `0X^l が入力されたときも，ここに該当することになる。
】</p>
◎
If input is the empty string, then return zero.
</li>
	<li>
~IF［
%入力 内に基数 %R の数字でない~cpがある
］
⇒
~RET ( `失敗^i, `有り^i )
◎
If input contains a code point that is not a radix-R digit, then return failure.
</li>
	<li>
%結果 ~LET %入力 を（`~ASCII~hex数字$が値 0 〜 15 の数字に対応付けられた）基数 %R による表記と見なした下で，整数 値として解釈した結果
◎
Return the mathematical integer value that is represented by input in radix-R notation, using ASCII hex digits for digits with values 0 through 15. 
</li>
	<li>
~RET ( %結果, %検証~error )
</li>
</ol>

<p class="trans-note">【
`0xAB.012.0X12.12^l
の様な~host名も IPv4 ~addressと見なされ、
`0xAB^l, `0X12^l は 16 進数,
`012^l は 8 進数,
`12^l は 10 進数
として解釈されることになる。
】</p>

<hr>

<p class="algo-head">
`~IPv4構文解析器@
は、所与の
( 文字列 %入力 )
に対し，次を走らす：
◎
The IPv4 parser takes a string input and then runs these steps:
</p>

<ol>
	<li>
%検証~error~flag ~LET ~OFF
◎
Let validationErrorFlag be unset.
</li>
	<li>
%~~成分~list ~LET %入力 を ❝. で分割した結果
◎
Let parts be input split on U+002E (.).
</li>
	<li>
<p>
~IF［
%~~成分~list 内の最後の~item ~EQ 空~文字列
］：
◎
If the last item in parts is the empty string, then:
</p>
		<ol>
			<li>
%検証~error~flag ~SET ~ON
◎
Set validationErrorFlag.
</li>
			<li>
<p>
~IF［
%~~成分~list の~item数 ~GT 1
］
⇒
%~~成分~list から最後の~itemを除去する
</p>
<p class="trans-note">【
%入力 の末尾に余計な ❝. があっても受容されることになる。
】</p>
◎
If parts has more than one item, then remove the last item from parts.
</li>
		</ol>
	</li>
	<li>
~IF［
%~~成分~list の~item数 ~GT 4
］
⇒
~RET %入力
【結果は`~IPv4~address$ではない。】
◎
If parts has more than four items, return input.
</li>
	<li>
%数~list ~LET 空~list
◎
Let numbers be the empty list.
</li>
	<li>
<p>
%~~成分~list 内の
~EACH( %~~成分 )
に対し：
◎
For each part in parts:
</p>
		<ol>
			<li>
<p>
~IF［
%~~成分 ~EQ 空~文字列
］
⇒
~RET %入力
◎
If part is the empty string, return input.
</p>

<p class="example">
`0..0x300^l は`~domain$であって，`~IPv4~address$ではない。
◎
0..0x300 is a domain, not an IPv4 address.
</p>
			</li>
			<li>
( %n, %検証~error ) ~LET
`~IPv4番号~構文解析器$( %~~成分 )
◎
Let n be the result of parsing part using validationErrorFlag.
</li>
			<li>
~IF［
%n ~EQ `失敗^i
］
⇒
~RET %入力
◎
If n is failure, return input.
</li>
			<li>
%数~list に %n を付加する
◎
Append n to numbers.
</li>
			<li>
~IF［
%検証~error ~EQ `有り^i
］
⇒
%検証~error~flag ~SET ~ON
◎
↑↑↑</li>
		</ol>
	</li>
	<li>
~IF［
%検証~error~flag ~EQ ~ON
］
⇒
`検証~error$
◎
If validationErrorFlag is set, validation error.
</li>
	<li>
~IF［
%数~list 内の ある~item ~GT 255
］
⇒
`検証~error$
◎
If any item in numbers is greater than 255, validation error.
</li>
	<li>
~IF［
%数~list 内の最後でない ある~item ~GT 255
］
⇒
~RET `失敗^i
◎
If any but the last item in numbers is greater than 255, return failure.
</li>
	<li>
~IF［
%数~list の最後の~item† ~GTE
( 256 の ( 5 − ( %数~list の~item数 ) ) 乗 )
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If the last item in numbers is greater than or equal to 256(5 − the number of items in numbers), validation error, return failure.
</li>
	<li>
%ipv4 ~LET %数~list の最後の~item
◎
Let ipv4 be the last item in numbers.
</li>
	<li>
%数~list から最後の~itemを除去する††
◎
Remove the last item from numbers.
</li>
	<li>
%counter ~LET 0
◎
Let counter be zero.
</li>
	<li>
<p>
%数~list 内の
~EACH( %n )
に対し：
◎
For each n in numbers:
</p>
		<ol>
			<li>
%ipv4 ~INCBY ( %n × ( 256 の (3 − %counter) 乗 ) )
◎
Increment ipv4 by n × 256(3 − counter).
</li>
			<li>
%counter ~INCBY 1
◎
Increment counter by 1.
</li>
		</ol>
	</li>
	<li>
~RET %ipv4
◎
Return ipv4.
</li>
</ol>

<p class="trans-note">【†
最後の~itemだけ特別扱い：
例えば
`100.100.25600^l と `100.100.100.0^l
は等価になり，
`0xFFFFFFFF^l と `255.255.255.255^l
は等価になることになる。
】【††
ここでも、（ %数~list の項~数が 4 に満たない場合は）最後の~itemだけ特別扱い：
例えば `100.100^l は， `100.0.0.100^l と等価になる。
】</p>

<hr>

<p class="algo-head">
`~IPv6構文解析器@
は、所与の
( 文字列 %入力 )
に対し，次を走らす：
◎
The IPv6 parser takes a string input and then runs these steps:
</p>

<ol>
	<li>
%~address ~LET `~IPv6~piece$がすべて 0 にされた，新たな`~IPv6~address$
◎
Let address be a new IPv6 address whose IPv6 pieces are all 0.
</li>
	<li>
%~piece~index ~LET 0
◎
Let pieceIndex be 0.
</li>
	<li>
%圧縮- ~LET ~NULL
◎
Let compress be null.
</li>
	<li>
%~pointer ~LET 0 （ %入力 内を指す~pointer, 初期~時は最初の~cpを指す）
◎
Let pointer be a pointer into input, initially 0 (pointing to the first code point).
</li>
	<li>
<p>
~IF［
`C$V ~EQ ❝:
］：
◎
If c is U+003A (:), then:
</p>
		<ol>
			<li>
~IF［
`C1$V ~NEQ ❝:
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If remaining does not start with U+003A (:), validation error, return failure.
</li>
	<li>
%~pointer ~INCBY 2
◎
Increase pointer by 2.
</li>
	<li>
%~piece~index ~INCBY 1；
%圧縮- ~SET %~piece~index
◎
Increase pieceIndex by 1 and then set compress to pieceIndex.
</li>
		</ol>
	</li>
	<li>
<p>
~WHILE ［
`C$V ~NEQ `EOF$i
］：
◎
While c is not the EOF code point:
</p>
		<ol>
			<li>
~IF［
%~piece~index ~EQ 8
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If pieceIndex is 8, validation error, return failure.
</li>
			<li>
<p>
~IF［
`C$V ~EQ ❝:
］：
◎
If c is U+003A (:), then:
</p>
				<ol>
					<li>
~IF［
%圧縮- ~NEQ ~NULL
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If compress is non-null, validation error, return failure.
</li>
					<li>
%~pointer ~INCBY 1
◎
↓</li>
					<li>
%~piece~index ~INCBY 1
◎
Increase pointer and pieceIndex by 1,＼
</li>
					<li>
%圧縮- ~SET %~piece~index
◎
set compress to pieceIndex,＼
</li>
					<li>
~CONTINUE
◎
and then continue.
</li>
				</ol>
			</li>
			<li>
( %値, %長さ ) ~LET ( 0, 0 )
◎
Let value and length be 0.
</li>
			<li>
~WHILE ［
%長さ ~LT 4
］~AND［
`C$V ~IN `~ASCII~hex数字$
］
⇒＃
%値 ~SET %値 ~MUL `10^X ~PLUS ［ `C$V を~hexadecimal数として解釈した値 ］；
%~pointer ~INCBY 1；
%長さ ~INCBY 1
◎
While length is less than 4 and c is an ASCII hex digit, set value to value × 0x10 + c interpreted as hexadecimal number, and increase pointer and length by 1.
</li>
			<li>
<p>
~IF［
`C$V ~EQ ❝.
］：
◎
If c is U+002E (.), then:
</p>
				<ol>
					<li>
~IF［
%長さ ~EQ 0
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If length is 0, validation error, return failure.
</li>
					<li>
%~pointer ~DECBY %長さ
◎
Decrease pointer by length.
</li>
					<li>
~IF［
%~piece~index ~GT 6
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If pieceIndex is greater than 6, validation error, return failure.
</li>
					<li>
%ipv4個数 ~LET 0
◎
Let numbersSeen be 0.
</li>
					<li>
<p>
~WHILE ［
`C$V ~NEQ `EOF$i
］：
◎
While c is not the EOF code point:
</p>
						<ol>
							<li>
%ipv4片 ~LET ~NULL
◎
Let ipv4Piece be null.
</li>
							<li>
<p>
~IF［
%ipv4個数 ~GT 0
］：
◎
If numbersSeen is greater than 0, then:
</p>
								<ol>
									<li>
~IF［
`C$V ~EQ ❝.
］~AND［
%ipv4個数 ~LT 4
］
⇒
%~pointer ~INCBY 1
◎
If c is a U+002E (.) and numbersSeen is less than 4, then increase pointer by 1.
</li>
									<li>
~ELSE
⇒＃
`検証~error$；
~RET `失敗^i
◎
Otherwise, validation error, return failure.
</li>
								</ol>
							</li>
							<li>
~IF［
`C$V ~NIN `~ASCII数字$
］
⇒＃
`検証~error$；
~RET `失敗^i
<!-- prevent the empty string -->
◎
If c is not an ASCII digit, validation error, return failure.
</li>
							<li>
<p>
~WHILE ［
`C$V ~IN `~ASCII数字$
］：
◎
While c is an ASCII digit:
</p>
								<ol>
									<li>
~IF［
%ipv4片 ~EQ 0
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
Let number be c interpreted as decimal number.
◎
If ipv4Piece is null, then set ipv4Piece to number.
◎
Otherwise, if ipv4Piece is 0, validation error, return failure.
</li>
									<li>
~IF［
%ipv4片 ~EQ ~NULL
］
⇒
%ipv4片 ~SET 0
◎
↑</li>
									<li>
%ipv4片 ~SET %ipv4片 ~MUL 10 + ［
`C$V を 10 進数として解釈した値
］
◎
Otherwise, set ipv4Piece to ipv4Piece × 10 + number.
</li>
									<li>
~IF［
%ipv4片 ~GT 255
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If ipv4Piece is greater than 255, validation error, return failure.
</li>
									<li>
%~pointer ~INCBY 1
◎
Increase pointer by 1.
</li>
								</ol>
							</li>
							<li>
%~address[ %~piece~index ] ~SET %~address[ %~piece~index ] ~MUL `100^X ~PLUS %ipv4片
◎
Set address[pieceIndex] to address[pieceIndex] × 0x100 + ipv4Piece.
</li>
							<li>
%ipv4個数 ~INCBY 1
◎
Increase numbersSeen by 1.
</li>
							<li>
~IF［
%ipv4個数 ~IN { 2, 4 }
］
⇒
%~piece~index ~INCBY 1
◎
If numbersSeen is 2 or 4, then increase pieceIndex by 1.
</li>
						</ol>
					</li>
					<li>
~IF［
%ipv4個数 ~NEQ 4
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If numbersSeen is not 4, validation error, return failure.
</li>
					<li>
~BREAK
◎
Break.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
`C$V ~EQ ❝:
］：
◎
Otherwise, if c is U+003A (:):
</p>
				<ol>
					<li>
%~pointer ~INCBY 1
◎
Increase pointer by 1.
</li>
					<li>
~IF［
`C$V ~EQ `EOF$i
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If c is the EOF code point, validation error, return failure.
</li>
				</ol>
			</li>
			<li>
~ELIF［
`C$V ~NEQ `EOF$i
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
Otherwise, if c is not the EOF code point, validation error, return failure.
</li>
			<li>
%~address[ %~piece~index ] ~SET %値
◎
Set address[pieceIndex] to value.
</li>
			<li>
%~piece~index ~INCBY 1
◎
Increase pieceIndex by 1.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%圧縮- ~NEQ ~NULL
］：
◎
If compress is non-null, then:
</p>
		<ol>
			<li>
%swaps ~LET %~piece~index ~MINUS %圧縮-
◎
Let swaps be pieceIndex − compress.
</li>
			<li>
%~piece~index ~SET 7
◎
Set pieceIndex to 7.
</li>
			<li>

~WHILE ［
%~piece~index ~NEQ 0
］~AND［
%swaps ~GT 0
］
⇒＃
%~address[ %~piece~index ] と %~address[ %圧縮- ~PLUS %swaps ~MINUS 1 ] の値を交換する；
%~piece~index ~DECBY 1；
%swaps ~DECBY 1
◎
While pieceIndex is not 0 and swaps is greater than 0, swap address[pieceIndex] with address[compress + swaps − 1], and then decrease both pieceIndex and swaps by 1.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%圧縮- ~EQ ~NULL
］~AND［
%~piece~index ~NEQ 8
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
Otherwise, if compress is null and pieceIndex is not 8, validation error, return failure.
</li>
	<li>
~RET %~address
◎
Return address.
</li>
</ol>

<hr>

<p>
`不透明な~host構文解析器@
は、所与の
( %入力 )
に対し，次を走らす：
◎
The opaque-host parser takes a string input, and then runs these steps:
</p>

<ol>
	<li>
~IF［
%入力 内に `%^l 以外の`禁止~host~cp$がある
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If input contains a forbidden host code point excluding U+0025 (%), validation error, return failure.
</li>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
%入力 内の
~EACH( ~cp %~cp )
に対し
⇒
%出力 ~APPEND
`~UTF-8~percent-符号化する$( `~C0制御文字~percent-符号化-集合$, %~cp )
◎
For each code point in input, UTF-8 percent encode it using the C0 control percent-encode set, and append the result to output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

		</section>
		<section id="host-serializing">
<h3 title="Host serializing">3.6. ~hostの直列化-法</h3>

<p class="algo-head">
`~hostを直列化する@
ときは、所与の
( `~host$ %~host )
に対し，
%~host の種別に応じて 次で与えられる結果を返す：
◎
The host serializer takes a host host and then runs these steps:
</p>

<dl class="switch">
	<dt>`~IPv4~address$</dt>
	<dd>
`~IPv4直列化器$( %~host )
◎
If host is an IPv4 address, return the result of running the IPv4 serializer on host.
</dd>

	<dt>`~IPv6~address$</dt>
	<dd>
❝[ ~APPEND `~IPv6直列化器$( %~host ) ~APPEND ❝]
◎
Otherwise, if host is an IPv6 address, return U+005B ([), followed by the result of running the IPv6 serializer on host, followed by U+005D (]).
</dd>

	<dt>`~domain$</dt>
	<dt>`不透明な~host$</dt>
	<dt>`空~host$</dt>
	<dd>
%~host
◎
Otherwise, host is a domain, opaque host, or empty host, return host.
</dd>
</dl>


<p class="algo-head">
`~IPv4直列化器@
は、所与の
( `~IPv4~address$ %~address )
に対し，次を走らす：
◎
The IPv4 serializer takes an IPv4 address address and then runs these steps:
</p>

<ol>
<!-- ＊
	<li>
~RET ［
32-bit %~address を成す各 8-bit 成分の数
］を［
最短の`~ASCII数字$列で表現する文字列に変換した結果
］の 4 個の文字列を，上位 bit のものから順に
❝. で区切って連結した結果
</li>
 -->


	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
%n ~LET %~address
◎
Let n be the value of address.
</li>
	<li>
<p>
~EACH( %i ~IN { 1 〜 4 } )
に対し，昇順に：
◎
For each i in the range 1 to 4, inclusive:
</p>
		<ol>
			<li>
%出力 ~SET 
`整数を直列化する$( %n を 256 で割った余り ) ~APPEND %出力
◎
Prepend n % 256, serialized, to output.
</li>
			<li>
~IF［
%i ~NEQ 4
］
⇒
❝. を %出力 の先頭に~~挿入する
◎
If i is not 4, then prepend U+002E (.) to output.
</li>
			<li>
%n ~SET floor( %n ÷ 256 )
◎
Set n to floor(n / 256).
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>


<p class="algo-head">
`~IPv6直列化器@
は、所与の
( `~IPv6~address$ %~address )
に対し，次を走らす：
◎
The IPv6 serializer takes an IPv6 address address and then runs these steps:
</p>

<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
%圧縮- ~LET ε
◎
↓</li>
	<li>
<p>
~IF［
%~address の中に，［
2 個以上~連続する，値 0 をとる`~IPv6~piece$からなる並び
］がある
］
⇒
%圧縮- ~SET ［［
そのような並びのうち，最長である並び
］のうち，最初に来る並び
］の中の，最初の`~IPv6~piece$を指す~index
</p>

<p class="example">
例えば `0:f:0:0:f:f:0:0^l に対しては、 2 個目の 0 を指すことになる。
</p>

◎
Let compress be an index to the first IPv6 piece in the first longest sequences of address’s IPv6 pieces that are 0.
◎
In 0:f:0:0:f:f:0:0 it would point to the second 0.
◎
If there is no sequence of address’s IPv6 pieces that are 0 that is longer than 1, then set compress to null.
</li>
	<li>
%~ignore0 ~LET ~F
◎
Let ignore0 be false.
</li>
	<li>
<p>
~EACH( 整数 %~piece~index ~IN { 0 〜 7 } )
に対し，昇順に：
◎
For each pieceIndex in the range 0 to 7, inclusive:
</p>
		<ol>
			<li>
~IF［
%~ignore0 ~EQ ~T
］~AND［
%~address[ %~piece~index ] ~EQ 0
］
⇒
~CONTINUE
◎
If ignore0 is true and address[pieceIndex] is 0, then continue.
</li>
			<li>
%~ignore0 ~SET ~F
◎
Otherwise, if ignore0 is true, set ignore0 to false.
</li>
			<li>
<p>
~IF［
%圧縮- ~NEQ ε
］~AND［
%圧縮- ~EQ %~piece~index
］：
◎
If compress is pieceIndex, then:
</p>
				<ol>
					<li>
%出力 ~APPEND ［
%~piece~index ~EQ 0 ならば `::^l ／
~ELSE_ `:^l
］
◎
Let separator be "::" if pieceIndex is 0, and U+003A (:) otherwise.
◎
Append separator to output.
</li>
					<li>
%~ignore0 ~SET ~T
◎
Set ignore0 to true and continue.
</li>
					<li>
~CONTINUE
◎
↑</li>
				</ol>
			</li>
			<li>
%出力 ~APPEND ［
%~address[ %~piece~index ] を小文字~hexadecimal数で表現する最短の文字列
］
◎
Append address[pieceIndex], represented as the shortest possible lowercase hexadecimal number, to output.
</li>
			<li>
~IF［
%~piece~index ~NEQ 7
］
⇒
%出力 ~APPEND ❝:
◎
If pieceIndex is not 7, then append U+003A (:) to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
この~algoは
A Recommendation for IPv6 Address Text Representation
（~IPv6~addressの推奨~表記）への準拠を要求する。
`RFC5952$r
【参考：<a href="http://www.nic.ad.jp/ja/newsletter/No46/0800.html" >~IPv6~address表記の柔軟性が起こす問題と RFC5952 の解説</a>】

◎
This algorithm requires the recommendation from A Recommendation for IPv6 Address Text Representation. [RFC5952]
</p>

		</section>
		<section id="host-equivalence">

<h3 title="Host equivalence">3.7. ~hostの等価性</h3>

<p class="algo-head">
2 つの`~host$［
%A, %B
］が
`同等@host
かどうか決定するときは
⇒
［［
%A ~EQ %B
］ならば ~T ／
~ELSE_ ~F
］を返す。
◎
To determine whether a host A equals B, return true if A is B, and false otherwise.
</p>

<p class="XXX">課題：
証明書の比較には、［
~domainの尾部の~dotは無視する
］ような，~hostの等価性の検査が要求される。
しかしながら、それらの~hostには，ここでは施行されない~DNS長さなどの 他の種々の側面0も施行される
— ~URLはそれらを施行しないので。
これら 2 つを近づけるような, あるいは
統一化~modelとして何か良い示唆があれば，issue を file されたし。
◎
Certificate comparison requires a host equivalence check that ignores the trailing dot of a domain (if any). However, those hosts have also various other facets enforced, such as DNS length, that are not enforced here, as URLs do not enforce them. If anyone has a good suggestion for how to bring these two closer together, or what a good unified model would be, please file an issue.
</p>

		</section>
	</section>
	<section id="urls">
<h2 title="URLs">4. ~URL</h2>

<p>
高次の~levelからは、［
`~URL~record$,
`妥当な~URL$sT,
`~URL構文解析器$,
`~URL直列化器$
］は，次のように関係する：
◎
At a high level, a URL, valid URL string, URL parser, and URL serializer relate as follows:
</p>

<ul>
	<li>
`~URL構文解析器$は、任意の~~入力~文字列に対し，［
`失敗^i, または `~URL~record$
］を返す。
◎
The URL parser takes an arbitrary string and returns either failure or a URL.
</li>
	<li>
`~URL~record$は、記憶域内の表現と捉えることもできる。
◎
A URL can be seen as the in-memory representation.
</li>
	<li>
`妥当な~URL$sTは、`~URL構文解析器$に与えたときに，`検証~error$や `失敗^i を誘発しない
— すなわち、［
適合する／妥当である
］と見なされる —
ような入力を定義する。
◎
A valid URL string defines what input would not trigger a validation error or failure when given to the URL parser. I.e., input that would be considered conforming or valid.
</li>
	<li>
`~URL直列化器$は、~~入力の`~URL~record$に対し，`~ASCII文字列$を返す。
（その文字列をさらに`~URL構文解析器$にかけた結果は、元の`~URL~record$と`同等$になる。）
◎
The URL serializer takes a URL and returns an ASCII string. (If that string is then parsed, the result will equal the URL that was serialized.)
</li>
</ul>

<div class="example" id="example-url-parsing" style="overflow:auto">
<table><thead><tr>
<th>入力~URL◎ Input 
<th>基底~URL◎ Base
<th>妥当？◎ Valid
<th>出力~URL◎ Output 
</thead><tbody>

<tr><td>`https:example.org^c
<td>
<td>❌
<td>`https://example.org/^c

<tr><td>`https://////example.com///^c
<td>
<td>❌
<td>`https://example.com///^c

<tr><td>`https://example.com/././foo^c
<td>
<td>✅
<td>`https://example.com/foo^c

<tr><td>`hello:world^c
<td>`https://example.com/^c
<td>✅
<td>`hello:world^c

<tr><td>`https:example.org^c
<td>`https://example.com/^c
<td>❌
<td>`https://example.com/example.org^c

<tr><td>`\example\..\demo/.\^c
<td>`https://example.com/^c
<td>❌
<td>`https://example.com/demo/^c

<tr><td>`example^c
<td>`https://example.com/demo^c
<td>✅
<td>`https://example.com/example^c

<tr><td>`file:///C|/demo^c
<td>
<td>❌
<td>`file:///C:/demo^c

<tr><td>`..^c
<td>`file:///C:/demo^c
<td>✅
<td>`file:///C:/^c

<tr><td>`file://loc%61lhost/^c
<td>
<td>✅
<td>`file:///^c

<tr><td>`https://user:password~atexample.org/^c
<td>
<td>❌
<td>`https://user:password~atexample.org/^c

<tr><td>`https://example.org/foo bar^c
<td>
<td>❌
<td>`https://example.org/foo%20bar^c

<tr><td>`https://EXAMPLE.com/../x^c
<td>
<td>✅
<td>`https://example.com/x^c

<tr><td>`https://ex ample.org/^c
<td>
<td>❌
<td>`失敗^i

<tr><td>`example^c
<td>
<td title="due to lack of base">❌†
<td>`失敗^i

<tr><td>`https://example.com:demo^c
<td>
<td>❌
<td>`失敗^i

<tr><td>`http://[www.example.com]/^c
<td>
<td>❌
<td>`失敗^i

</table>

<p>
簡潔にするため、ここでの［
基底／出力
］`~URL$は，`~URL直列化器$にかけた結果で表現されている。
◎
The base and output URL are represented in serialized form for brevity.
</p>

<small>†
— 基底~URLを欠くことに因り妥当でない。
</small>

</div>

		<section id="url-representation">
<h3 title="URL representation">4.1. ~URL表現</h3>

<p>
`~URL@
とは、統一的†な識別子である。
`妥当な~URL$sTと区別するため、`~URL~record$とも称される††。
◎
A URL is a universal identifier. To disambiguate from a valid URL string it can also be referred to as a URL record.
</p>

<p class="trans-note">【†
“universal” — 
（資源を一意的に識別するために，）~~普遍的に／広く~~一般から／広範の応用に渡って／共通して
利用し得るような
】【††
以下に定義される`~URL$の各種 構成子は、この，内部表現による~URL（~URLを意図して与えられた文字列を構文解析して得られる`~URL~record$）の各種~成分を表す。
】</p>

<p>
`~URL$は、次の成分からなる：
</p>

<dl class="def-list">
	<dt>`~scheme@url（初期~値：空~文字列）</dt>
	<dd>
`~URL$の種別を識別する`~ASCII文字列$であって、`~URL構文解析器$にかけた後の，`~URL$の更なる分岐処理に利用し得るもの。
◎
A URL’s scheme is an ASCII string that identifies the type of URL and can be used to dispatch a URL for further processing after parsing. It is initially the empty string.
</dd>

	<dt>`~username@url（初期~値：空~文字列）</dt>
	<dd>
~usernameを識別する`~ASCII文字列$。
◎
A URL’s username is an ASCII string identifying a username. It is initially the empty string.
</dd>

	<dt>`~password@url（初期~値：空~文字列 ）</dt>
	<dd>
~passwordを識別する`~ASCII文字列$。
◎
A URL’s password is an ASCII string identifying a password. It is initially the empty string.
</dd>

	<dt>`~host@url（初期~値： ~NULL ）</dt>
	<dd>
~NULL, または
`~host$。
◎
A URL’s host is null or a host. It is initially null.
</dd>
	<dd class="note">
<p>注記：
`~URL$に許容される［
`~scheme$url, `~host$url
］の組み合わせを次の表に挙げる。
◎
The following table lists allowed URL’s scheme / host combinations.
</p>

<table>

<thead><tr><th rowspan="2">`~scheme$url 
<th colspan="6">`~host$url
<tr id="_combi-host-types"><th><span>`~domain$
</span><th><span>`~IPv4~address$
</span><th><span>`~IPv6~address$
</span><th><span>`不透明な~host$
</span><th><span>`空~host$
</span><th><span>~NULL
</span></thead>

<tbody><tr><td>`file^l 以外の`特別~scheme$
<td>✅ <td>✅ <td>✅ <td>❌ <td>❌ <td>❌ 

<tr><td>`file^l
<td>✅ <td>✅ <td>✅ <td>❌ <td>✅ <td>✅ 

<tr><td>非`特別~scheme$
<td>❌ <td>❌ <td>✅ <td>✅ <td>✅ <td>✅ 
</tbody></table>


	</dd>

	<dt>`~port@url（初期~値： ~NULL ）</dt>
	<dd>
~NULL, または
~networking~portを識別する 16-bit 非負~整数。
◎
A URL’s port is either null or a 16-bit unsigned integer that identifies a networking port. It is initially null.
</dd>

	<dt>`~path@url（初期~値：空）</dt>
	<dd>
~dataを保持している［
0 個以上の`~ASCII文字列$からなる`~list$
］であり、通例的には，資源の所在を階層的に識別するものになる。
◎
A URL’s path is a list of zero or more ASCII strings holding data, usually identifying a location in hierarchical form. It is initially empty.
</dd>
	<dd class="note">注記：
`~URL$が`特別$である場合、その`~path$urlは，常に`空$でない
◎
A special URL always has a non-empty path.
</dd>

	<dt>`~query@url（初期~値： ~NULL ）</dt>
	<dd>
~NULL, または ~dataを保持している`~ASCII文字列$。
◎
A URL’s query is either null or an ASCII string holding data. It is initially null.
</dd>

	<dt>`素片@url（初期~値： ~NULL ）</dt>
	<dd>
~NULL, または`~ASCII文字列$。
非~NULLは、［
`~URL$の他の成分から識別される資源
］に対する更なる処理に利用され得る~dataを，保持する。
◎
A URL’s fragment is either null or an ASCII string holding data that can be used for further processing on the resource the URL’s other components identify. It is initially null.
</dd>
</dl>


<p>
`~URL$には、次のものも結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~cannot-be-a-base-URL~flag@（初期~値： ~OFF ）</dt>
	<dd>
~flag値
◎
A URL also has an associated cannot-be-a-base-URL flag. It is initially unset.
</dd>

	<dt>`~obj@url（初期~値： ~NULL ）</dt>
	<dd>
~NULL, または
次のいずれかの~obj
⇒
`Blob$I `FILEAPI$r ／
`MediaSource$I `MEDIA-SOURCE$r
◎
A URL also has an associated object that is null, a Blob object, or a MediaSource object. It is initially null. [FILEAPI] [MEDIA-SOURCE]
</dd>
	<dd class="note">注記：
現時点では，これは主に `blob^l `~URL$を~supportするためにあるが、他のものも追加され得るので，単に “~obj” と称する。
◎
At this point this is used primarily to support "blob" URLs, but others can be added going forward, hence "object".
</dd>

</dl>

		</section>
		<section id="url-miscellaneous">
<h3 title="URL miscellaneous">4.2. ~URLのその他諸々</h3>

<p>
`特別~scheme@
とは、次の表の 1 列目に挙げられている`~scheme$urlである。
`特別~scheme$の
`既定~port@
とは、表の同じ行の 2 列目に示されている`~port$urlである。
◎
A special scheme is a scheme listed in the first column of the following table. A default port is a special scheme’s optional corresponding port and is listed in the second column on the same row.
</p>

<table>
<thead><tr><th>`~scheme$url
<th>`~port$url
</thead>

<tbody><tr><td>`ftp^l
<td>21

<tr><td>`file^l
<td>（未定義）

<tr><td>`gopher^l
<td>70

<tr><td>`http^l
<td>80

<tr><td>`https^l
<td>443

<tr><td>`ws^l
<td>80

<tr><td>`wss^l
<td>443

</tbody></table>

<p>
`~scheme$urlが`特別~scheme$であるような`~URL$は，
`特別@
であるという。
`特別でない？@( %~URL )
は、所与の %~URL に対し［
%~URL は`特別$でないならば ~T ／
~ELSE_ ~F
］を返す。
【原文では “特別でない” が “特別である” の否定として定義されているが、表記上の都合により，この訳ではこのように表現する（否定は、単に`特別$でないと記す。】
◎
A URL is special if its scheme is a special scheme. A URL is not special if its scheme is not a special scheme.
</p>


<p>
`~URL$が
`資格証明情報を含む@
とは、その［
`~username$url, `~password$url
］のいずれかは空~文字列でないことを意味する。
◎
A URL includes credentials if its username or password is not the empty string.
</p>

<p class="trans-note">【（参考）
HTTP ~protocolの下では、~target~URL内での直接的な［
~password／~username
］の利用は保安~上の問題から許容されない（参照：
RFC7230 の
<a href="~RFC7230#appendix-A.2">Appendix A</a>,
<a href="~RFC7230#section-2.7.1">2.7.1 節の userinfo の記述</a>
）。
】</p>

<div class="p">
<p>
次のいずれかを満たす`~URL~record$は、
`~username／~password／~portを持てない@
とされる：
</p>

<ul ><li>`~host$url ~IN { ~NULL, 空~文字列 }
</li><li>`~cannot-be-a-base-URL~flag$ ~EQ ~ON
</li><li>`~scheme$url ~EQ `file^l
</li></ul>

◎
A URL cannot have a username/password/port if its host is null or the empty string, its cannot-be-a-base-URL flag is set, or its scheme is "file".
</div>

<p>
`~URL$は
`基底~URL@
であるものと指名されることもある。
◎
A URL can be designated as base URL.
</p>

<p class="note">注記：
`基底~URL$は、`~URL構文解析器$において，`相対~URL$sTも入力にとり得るときに有用になる。
◎
A base URL is useful for the URL parser when the input might be a relative-URL string.
</p>

<hr>

<div class="p">
<p>
`~drive_letter@
とは、次を満たす 2 個の~cp並び［
%L1, %L2
］である：
</p>

<ul ><li>%L1 ~IN `~ASCII英字$
</li><li>%L2 ~IN { ❝:, ❝| }
</li></ul>

◎
A Windows drive letter is two code points, of which the first is an ASCII alpha and the second is either U+003A (:) or U+007C (|).
</div>

<p>
`正規化-済み~drive_letter@
とは、`~drive_letter$のうち，［
2 個目の~cp ~EQ ❝:
］なるものである。
◎
A normalized Windows drive letter is a Windows drive letter of which the second code point is U+003A (:).
</p>

<p class="note">注記：
<a href="#url-writing">~URLの書式</a>
節により、適合するのは`正規化-済み~drive_letter$に限られる。
◎
As per the URL writing section, only a normalized Windows drive letter is conforming.
</p>

<p>
3 個の［
~cp, または `EOF$i
］からなる並び［
%C0, %C1, %C2
］は、次をすべて満たすならば
`~drive_letterから開始されて@
いるとされる：
◎
A string starts with a Windows drive letter if all of the following are true:
</p>

<ul class="brief">

	<li>
並び［
%C0, %C1
］は、`~drive_letter$である（特に，いずれも `EOF$i でない）
◎
its length is greater than or equal to 2
◎
its first two code points are a Windows drive letter
</li>
	<li>
%C2 ~IN { `EOF$i, ❝/, ❝\, ❝?, ❝# }
◎
its length is 2 or its third code point is U+002F (/), U+005C (\), U+003F (?), or U+0023 (#).
</li>
</ul>

<div class="example">

<table><tbody>
<tr><th>並びが成す文字列
<th>~drive_letterから開始されている？
</tr>

<tr><td>"`c:^c"
<td>✅
</tr>

<tr><td>"`c:/^c"
<td>✅
</tr>

<tr><td>"`c:a^c"
<td>❌

</tbody></table>
</div>


<p class="algo-head">
%url の
`~pathを短縮する@
ときは、次を走らす：
◎
To shorten a url’s path:
</p>

<ol>
	<li>
%path ~LET %url の`~path$url
◎
Let path be url’s path.
</li>
	<li>
~IF［
%path は`空$である
］
⇒
~RET
◎
If path is empty, then return.
</li>
	<li>
~IF［
%url の`~scheme$url ~EQ `file^l
］~AND［
%path の`~size$ ~EQ 1
］~AND［
%path[0] は`正規化-済み~drive_letter$である
］
⇒
~RET
◎
If url’s scheme is "file", path’s size is 1, and path[0] is a normalized Windows drive letter, then return.
</li>
	<li>
%path から最後の~itemを`除去する$
◎
Remove path’s last item.
</li>
</ol>

		</section>
		<section id="url-writing">
<h3 title="URL writing">4.3. ~URLの書式</h3>

<div class="p">
<p>
`妥当な~URL@sT
は、［
`素片~付き相対~URL$sT,
`素片~付き絶対~URL$sT
］のいずれかで~MUST。
</p>

<p>
以下において，“省略可” と記された部分は省略できる／され得ることを意味する（すなわち， 0 個, または 1 個）。
</p>

◎
A valid URL string must be either a relative-URL-with-fragment string or an absolute-URL-with-fragment string.
</div>

<div class="p">
<p>
`素片~付き絶対~URL@sT
は、次の並びで~MUST：
</p>

<ol><li>`絶対~URL$sT
</li><li>次の並び（省略可）：
	<ol><li>❝#
	</li><li>`~URL素片$sT
	</li></ol>
</li></ol>

◎
An absolute-URL-with-fragment string must be an absolute-URL string, optionally followed by U+0023 (#) and a URL-fragment string.
</div>

<p>
`絶対~URL@sT
は、次の並びで~MUST：
◎
An absolute-URL string must be one of the following
</p>

<ol>
	<li>
<p>
次のいずれか：
</p>

		<ul>
			<li>
<p>
次の並び：
</p>

<ol><li>`~URL~scheme$sTであって，［
`file^l 以外の`特別~scheme$
］に`~ASCII大小無視$で合致するもの
</li><li>❝:
</li><li>`~scheme相対~特別~URL$sT
</li></ol>

◎
a URL-scheme string that is an ASCII case-insensitive match for a special scheme and not an ASCII case-insensitive match for "file", followed by U+003A (:) and a scheme-relative-special-URL string
</li>
			<li>
<p>
次の並び：
</p>

<ol><li>`~URL~scheme$sTであって，`特別~scheme$に`~ASCII大小無視$で<em>合致しない</em>もの
</li><li>❝:
</li><li>`相対~URL$sT
</li></ol>

◎
a URL-scheme string that is not an ASCII case-insensitive match for a special scheme, followed by U+003A (:) and a relative-URL string
</li>
			<li>
<p>
次の並び：
</p>
<ol><li>`~URL~scheme$sTであって， `file^l に`~ASCII大小無視$で合致するもの
</li><li>❝:
</li><li>`~scheme相対~file~URL$sT
</li></ol>

◎
a URL-scheme string that is an ASCII case-insensitive match for "file", followed by U+003A (:) and a scheme-relative-file-URL string
</li>
		</ul>
	</li>
	<li>
<p>
次の並び（省略可）：
</p>

<ol><li>❝?
</li><li>`~URL~query$sT
</li></ol>

◎
any optionally followed by U+003F (?) and a URL-query string.
</li>
</ol>


<div class="p">
<p>
`~URL~scheme@sT
は、次の並びで~MUST：
</p>

<ol><li>1 個の`~ASCII英字$
</li><li>0 個以上の { `~ASCII英数字$, ❝+, ❝-, ❝. } からなる並び
</li></ol>

<p>
`~URL~scheme$sT
は、 <cite>IANA URI [sic] Schemes</cite> ~registryに登録されるべきである。
`IANA-URI-SCHEMES$r
`RFC7595$r
</p>

◎
A URL-scheme string must be one ASCII alpha, followed by zero or more of ASCII alphanumeric, U+002B (+), U+002D (-), and U+002E (.). Schemes should be registered in the IANA URI [sic] Schemes registry. [IANA-URI-SCHEMES] [RFC7595]
</div>

<div class="p">
<p>
`素片~付き相対~URL@sT
は、次の並びで~MUST：
</p>

<ol><li>`相対~URL$sT
</li><li>次の並び（省略可）：
	<ol><li>❝#
	</li><li>`~URL素片$sT
	</li></ol>
</li></ol>

◎
A relative-URL-with-fragment string must be a relative-URL string, optionally followed by U+0023 (#) and a URL-fragment string.
</div>

<p>
`相対~URL@sT
は、次の並びで~MUST：
◎
A relative-URL string must be one of the following,＼
</p>

<ol>
	<li>
<p>
`基底~URL$の`~scheme$urlに応じて：
◎
switching on base URL’s scheme:
</p>

		<dl class="switch">
			<dt>
`file^l 以外の`特別~scheme$ならば，次のいずれか：
◎
A special scheme that is not "file"
</dt>
			<dd>
`~scheme相対~特別~URL$sT
◎
a scheme-relative-special-URL string
</dd>
			<dd>
`~path絶対~URL$sT
◎
a path-absolute-URL string
</dd>
			<dd>
`~path相対 ~schemeなし~URL$sT
◎
a path-relative-scheme-less-URL string
</dd>

			<dt>
`file^l ならば，次のいずれか：
◎
"file"
</dt>
			<dd>
`~scheme相対~file~URL$sT
◎
a scheme-relative-file-URL string
</dd>
			<dd>
`~path絶対~URL$sT
— ただし、［
`基底~URL$の`~host$urlは`空~host$である
］場合に限る
◎
a path-absolute-URL string if base URL’s host is an empty host
</dd>
			<dd>
`~path絶対 非 Windows file ~URL$sT
— ただし、［
`基底~URL$の`~host$urlは`空~host$でない
］場合に限る
◎
a path-absolute-non-Windows-file-URL string if base URL’s host is not an empty host
</dd>
			<dd>
`~path相対 ~schemeなし~URL$sT
◎
a path-relative-scheme-less-URL string
</dd>

			<dt>
他の場合，次のいずれか：
◎
Otherwise
</dt>
			<dd>
`~scheme相対~URL$sT
◎
a scheme-relative-URL string
</dd>
			<dd>
`~path絶対~URL$sT
◎
a path-absolute-URL string
</dd>
			<dd>
`~path相対 ~schemeなし~URL$sT
◎
a path-relative-scheme-less-URL string
</dd>
		</dl>
	</li>
	<li>
<p>
次の並び（省略可）：
</p>

<ol><li>❝?
</li><li>`~URL~query$sT
</li></ol>

◎
any optionally followed by U+003F (?) and a URL-query string.
</li>
</ol>

<p class="note">注記：
`相対~URL$sTを`~URL構文解析器$にかけるときは、非~NULLの`基底~URL$が必要とされる。
◎
A non-null base URL is necessary when parsing a relative-URL string.
</p>

<div class="p">
<p>
`~scheme相対~特別~URL@sT
は、次の並びで~MUST
</p>

<ol><li>`//^l
</li><li>`妥当な~host$sT
</li><li>
<p>
次の並び（省略可）：
</p>
	<ol><li>❝:
	</li><li>`~URL~port$sT
	</li></ol>

</li><li>`~path絶対~URL$sT（省略可）
</li></ol>

◎
A scheme-relative-special-URL string must be "//", followed by a valid host string, optionally followed by U+003A (:) and a URL-port string, optionally followed by a path-absolute-URL string.
</div>

<p>
`~URL~port@sT
は、［
0 個以上の`~ASCII数字$からなる並び
］で~MUST。
◎
A URL-port string must be zero or more ASCII digits.
</p>

<div class="p">
<p>
`~scheme相対~URL@sT
は、次の並びで~MUST
</p>

<ol><li>`//^l
</li><li>`不透明な~host＆~port$sT
</li><li>`~path絶対~URL$sT（省略可）
</li></ol>

◎
A scheme-relative-URL string must be "//", followed by an opaque-host-and-port string, optionally followed by a path-absolute-URL string. 
</div>

<div class="p">
<p>
`不透明な~host＆~port@sT
は、［
空~文字列, または次の並び
］で~MUST：
</p>

<ol><li>`妥当な不透明な~host$sT
</li><li>
<p>
次の並び（省略可）：
</p>
		<ol><li>❝:
		</li><li>`~URL~port$sT
		</li></ol>
</li></ol>
◎
An opaque-host-and-port string must be either the empty string or: a valid opaque-host string, optionally followed by U+003A (:) and a URL-port string.
</div>


<div class="p">

<p>
`~scheme相対~file~URL@sT
は、次の並びで~MUST：
</p>

<ol><li>`//^l
</li><li>次のいずれか：
	<ul><li>`~path絶対~URL$sT
	</li><li>次の並び：
		<ol><li>`妥当な~host$sT
		</li><li>`~path絶対 非 Windows file ~URL$sT（省略可）
		</li></ol>
	</li></ul>
</li></ol>

◎
A scheme-relative-file-URL string must be "//", followed by one of the following
◎
a valid host string, optionally followed by a path-absolute-non-Windows-file-URL string
◎
a path-absolute-URL string.
</div>

<div class="p">
<p>
`~path絶対~URL@sT
は、次の並びで~MUST：
</p>

<ol><li>❝/
</li><li>`~path相対~URL$sT
</li></ol>
◎
A path-absolute-URL string must be U+002F (/) followed by a path-relative-URL string.
</div>

<div class="p">
<p>
`~path絶対 非 Windows file ~URL@sT
は、次をいずれも満たす文字列で~MUST：
</p>

<ul ><li>`~path絶対~URL$sTである
</li><li>次の並びから開始されていない：
	<ol><li>❝/
	</li><li>`~drive_letter$
	</li><li>❝/
	</li></ol>
</li></ul>

◎
A path-absolute-non-Windows-file-URL string must be a path-absolute-URL string that does not start with: U+002F (/), followed by a Windows drive letter, followed by U+002F (/).
</div>

<div class="p">
<p>
`~path相対~URL@sT
は、次をいずれも満たす文字列で~MUST：
</p>

<ul><li>❝/ で区切られた［
0 個以上の`~URL~path区分$sT
］からなる
</li><li>❝/ から開始されていない
</li></ul>

◎
A path-relative-URL string must be zero or more URL-path-segment strings, separated from each other by U+002F (/), and not start with U+002F (/).
</div>

<div >
<p>
`~path相対 ~schemeなし~URL@sT
は、次をいずれも満たす文字列で~MUST：
</p>

<ul ><li>`~path相対~URL$sTである
</li><li>次の並びから開始されていない：
	<ol ><li>`~URL~scheme$sT
	</li><li>❝:
	</li></ol>
</li></ul>

◎
A path-relative-scheme-less-URL string must be a path-relative-URL string that does not start with: a URL-scheme string, followed by U+003A (:).
</div>

<p>
`~URL~path区分@sT
は、［
0 個以上の［
❝/, ❝? を除く`~URL単位$
］からなる並び
］で~MUST。
◎
A URL-path-segment string must be one of the following
</p>

<p>
`~URL~path区分$sTのうち，次のものは、構文解析-時に~~特別に扱われる：
◎
zero or more URL units, excluding U+002F (/) and U+003F (?), that together are not a single-dot path segment or a double-dot path segment.
◎
a single-dot path segment
◎
a double-dot path segment.
</p>

<ul>
	<li>
<p>
`単dot~path区分@
は、次のいずれかで~MUST：
</p>

<ul><li>❝.
</li><li>`~ASCII大小無視$で `%2e^l に合致するもの
</li></ul>

◎
A single-dot path segment must be "." or an ASCII case-insensitive match for "%2e".
</li>
	<li>
`二重dot~path区分@
は、［
2 個の`単dot~path区分$（同じでなくてもよい）からなる並び
］で~MUST。
◎
A double-dot path segment must be ".." or an ASCII case-insensitive match for ".%2e", "%2e.", or "%2e%2e".
</li>
</ul>

<p>
`~URL~query@sT
は、［
0 個以上の`~URL単位$からなる並び
］で~MUST。
◎
A URL-query string must be zero or more URL units.
</p>

<p>
`~URL素片@sT
は、［
0 個以上の`~URL単位$からなる並び
］で~MUST。
◎
A URL-fragment string must be zero or more URL units.
</p>

<div class="p">
<p>
次に挙げる`~cp$が
`~URL~cp@
である：
</p>

<ul><li>`~ASCII英数字$
</li><li>
❝!,
❝$,
`0026^U `&amp;^smb,
❝',
❝(,
❝),
❝*,
❝+,
❝,,
❝-,
❝.,
❝/,
❝:,
❝;,
❝=,
❝?,
❝@,
❝_,
❝~
</li><li>`00A0^U 〜 `10FFFD^U
— ただし、`~surrogate$, `非文字$は除外する。
</li></ul>

◎
The URL code points are ASCII alphanumeric, U+0021 (!), U+0024 ($), U+0026 (&amp;), U+0027 ('), U+0028 LEFT PARENTHESIS, U+0029 RIGHT PARENTHESIS, U+002A (*), U+002B (+), U+002C (,), U+002D (-), U+002E (.), U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+003F (?), U+0040 (@), U+005F (_), U+007E (~), and code points in the range U+00A0 to U+10FFFD, inclusive, excluding surrogates and noncharacters.
</div>

<p class="note">注記：
`0080^U DELETE
以上の~cpは、`~URL構文解析器$により`~percent-符号化された~byte$に変換されることになる。
◎
Code points greater than U+007F DELETE will be converted to percent-encoded bytes by the URL parser.
</p>

<p class="note">注記：
~HTMLにおいては、文書の符号化法が旧来のものである場合，`~URL~query$sT内の `0080^U 以上の~cpは、文書の符号化法を用いて`~percent-符号化された~byte$に変換される。
これは、ある文書で働く~URLが 異なる文書~符号化法を利用する文書に複製されるときに，問題になり得る。
この問題は、あらゆる箇所に~UTF-8符号化法を用いれば~~解消する。
◎
In HTML, when the document encoding is a legacy encoding, code points in the URL-query string that are higher than U+007F DELETE will be converted to percent-encoded bytes using the document’s encoding. This can cause problems if a URL that works in one document is copied to another document that uses a different document encoding. Using the UTF-8 encoding everywhere solves this problem.
</p>

<div class="example" id="query-encoding-example">
<p>
例えば、次の~HTML文書を考える：
◎
For example, consider this HTML document:
</p>

<pre>
&lt;!doctype html&gt;
&lt;meta charset="windows-1252"&gt;
&lt;a href="?sm&amp;ouml;rg&amp;aring;sbord"&gt;Test&lt;/a&gt;
</pre>

<p>
文書~符号化法は windows-1252 なので、
~linkの `~URL$の`~query$urlは
`sm%F6rg%E5sbord^l
になる。
文書~符号化法が UTF-8 であった場合、それは
`sm%C3%B6rg%C3%A5sbord^l
になる。
◎
Since the document encoding is windows-1252, the link’s URL’s query will be "sm%F6rg%E5sbord". If the document encoding had been UTF-8, it would instead be "sm%C3%B6rg%C3%A5sbord".
</p>
			</div>

<p>
次のものが
`~URL単位@
である
⇒
`~URL~cp$, `~percent-符号化された~byte$
【従って，`~URL単位$がなす集合は文字列の集合になる。】
◎
The URL units are URL code points and percent-encoded bytes.
</p>


<p class="note">注記：
`~percent-符号化された~byte$は、~cpのうち［
`~URL~cp$でない, あるいは
書出せるものから除外されている
］ものを符号化するときに，利用され得る／できる。
◎
Percent-encoded bytes can be used to encode code points that are not URL code points or are excluded from being written.
</p>

<hr>

<p class="note">注記：
`妥当な~URL$sTの中で，`~URL~record$の［
`~username$url, `~password$url
］を表す仕方は無い。
◎
There is no way to express a username or password of a URL record within a valid URL string.
</p>


		</section>
		<section id="url-parsing">
<h3 title="URL parsing">4.4. ~URLの構文解析-法</h3>

<p class="algo-head">
`~URL構文解析器@
は、所与の
⇒＃
文字列 %入力,
`基底~URL$ %基底 （省略時は ε ）,
`符号化法$ %上書符号化法 （省略時は ε ）
◎終
に対し，次を走らす：
◎
The URL parser takes a string input, with an optional base URL base and an optional encoding encoding override, and then runs these steps:
</p>

<p class="note">注記：
非~web~browser実装は、`基本~URL構文解析器$のみ実装すれば~~十分である。
◎
Non-web-browser implementations only need to implement the basic URL parser.
</p>

<ol>
	<li>
%url ~LET 次を与える下で，
%入力 を`基本~URL構文解析器$にかけた結果
⇒
( `基底~URL$ %基底 , `符号化法$ %上書符号化法 )
◎
Let url be the result of running the basic URL parser on input with base, and encoding override as provided.
</li>
	<li>
~IF［
%url ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If url is failure, return failure.
</li>
	<li>
~IF［
%url の`~scheme$url ~NEQ `blob^l
］
⇒
~RET %url
◎
If url’s scheme is not "blob", return url.
</li>
	<li>
~IF［
`~Blob~URL~store$ `FILEAPI$r 内に［
%url の`~path$url[0]
］に対応する~entryは在る
］
⇒
%url の`~obj$url ~SET その~entry
◎
If url’s path is empty or url’s path[0] is not in the Blob URL Store, then return url. [FILEAPI]
◎
Set url’s object to the entry in the Blob URL Store corresponding to url’s path[0].
</li>
	<li>
~RET %url
◎
Return url.
</li>
</ol>

<hr>

<p class="algo-head">
所与の文字列 %入力 を
`基本~URL構文解析器@
にかけるときは、所与の
⇒＃
`基底~URL$ %基底  （省略時は ε ）,
`符号化法$ %上書符号化法 （省略時は ε ）,
`~URL$と上書stateの組 ( %url, %上書state ) （省略時は ( ε, ε ) ）
◎終
に対し，次を走らす：
◎
The basic URL parser takes a string input, optionally with a base URL base, optionally with an encoding encoding override, optionally with a URL url and a state override state override, and then runs these steps:
</p>


<div class="note">
<p>注記：</p>

<ul>
	<li>
引数 %上書符号化法 は、~HTMLにのみ関連する，旧来の概念である。
`HTML$r
</li>
	<li>
引数 組
( %url, %上書state )
が利用されるのは、種々の~APIに限られる。
`基本~URL構文解析器$は、この引数 組が：
		<ul>
			<li>
渡されなかった場合は、`~URL$または `失敗^i を返す。
</li>
			<li>
渡された場合は、渡された %url を改変した上で 何も返さずに終了することもある。
【あるいは `失敗^i を返す。 `失敗^i を返しつつ，渡された %url も改変することはあり得るか？】
</li>
		</ul>
	</li>
</ul>

◎
The encoding override argument is a legacy concept only relevant for HTML. The url and state override arguments are only for use by various APIs. [HTML]
◎
When the url and state override arguments are not passed, the basic URL parser returns either a new URL or failure. If they are passed, the algorithm modifies the passed url and can terminate without returning anything.
</div>


<ol>
	<li>
<p>
~IF［
%url ~EQ ε
］：
◎
If url is not given:
</p>
		<ol>
			<li>
%url ~SET 新たな`~URL$
◎
Set url to a new URL.
</li>
			<li>
~IF［
%入力 の［
先頭または末尾
］の文字 ~IN `~C0制御文字や~space$
］
⇒
`検証~error$
◎
If input contains any leading or trailing C0 control or space, validation error.
</li>
			<li>
%入力 から［［
頭部と尾部
］の，`~C0制御文字や~space$からなる並び
］を除去する
◎
Remove any leading and trailing C0 control or space from input.
</li>
		</ol>
	</li>
	<li>
~IF［
%入力 内に`~ASCII~tabや~ASCII改行文字$がある
］
⇒
`検証~error$
◎
If input contains any ASCII tab or newline, validation error.
</li>
	<li>
%入力 からすべての`~ASCII~tabや~ASCII改行文字$を除去する
◎
Remove all ASCII tab or newline from input.
</li>
	<li>
%state ~LET ［
%上書state ~NEQ ε ならば %上書state ／
~ELSE_ `~scheme開始-$st
］
◎
Let state be state override if given, or scheme start state otherwise.
</li>
	<li>
~IF［
%基底 ~EQ ε
］
⇒
%基底 ~SET ~NULL
◎
If base is not given, set it to null.
</li>
	<li>
%符号化法 ~LET `~UTF-8$
◎
Let encoding be UTF-8.
</li>
	<li>
~IF［
%上書符号化法 ~NEQ ε
］
⇒
%符号化法 ~SET `符号化法から出力~符号化法を取得する$( %上書符号化法 )
◎
If encoding override is given, set encoding to the result of getting an output encoding from encoding override.
</li>
	<li>
%~buffer ~LET 空~文字列
◎
Let buffer be the empty string.
</li>
	<li>
( %~atmark~flag, %~brackets~flag, %~password~token出現~flag ) ~LET ( ~OFF, ~OFF, ~OFF )
◎
Let the @ flag, [] flag, and passwordTokenSeenFlag be unset.
</li>
	<li>
%~pointer ~LET 0 （ %入力 内の最初の~cpを指す~pointer）
◎
Let pointer be a pointer to first code point in input.
</li>
	<li>
<p>
~WHILE 無条件
</p>
		<ol>
			<li>
下に与える状態機械を走らす
</li>
			<li>
~IF［
`C$V ~EQ `EOF$i
］
⇒
~BREAK
</li>
			<li>
%~pointer ~INCBY 1
</li>
		</ol>
◎
Keep running the following state machine by switching on state. If after a run pointer points to the EOF code point, go to the next step. Otherwise, increase pointer by one and continue with the state machine.
</li>
	<li>
<p>
~IF［
%上書state ~EQ ε
］
⇒
~RET %url
</p>

<p class="trans-note">【
構文解析に失敗した場合、この段には到達しない。
】【
この段は，原文では状態機械の末尾に置かれているが、見通しを良くするため，ここに移動している。
】</p>
◎
↓↓</li>
</ol>

<p>
状態機械は、 %state に応じて，以下における対応する段を走らす
— この状態機械の中では：
◎
↑↑</p>

<ul>
	<li>
“~RET” は、上の~algo自身を終了させるとする。
</li>
	<li>
<p>
`~URL単位かどうか検証する@
ときは、 `C$V に応じて次を走らすとする†：
</p>
		<ol class="switch">
			<li>
`~URL~cp$
⇒
何もしない
</li>
			<li>
❝%
⇒
~IF［
`C1$V ~NIN `~ASCII~hex数字$
］~OR［
`C2$V ~NIN `~ASCII~hex数字$
］
⇒
`検証~error$
</li>
			<li>
その他
⇒
`検証~error$
</li>
		</ol>
	</li>
</ul>

<p class="trans-note">【†
この定義は、共通する記述を集約するために，この訳にて追加したもの。
】【
この状態機械は、現在の `state^i からは常に，自身または自身より後に示されている `state^i へ遷移するように、整列して記されている。
】</p>

<dl class="switch">

<!--% scheme-start-state -->
	<dt>`~scheme開始-@st</dt>

	<dd>
		<ol>
			<li>
~IF［
`C$V ~IN `~ASCII英字$
］
⇒＃
%~buffer ~APPEND `~ASCII小文字~化する$( `C$V )；
%state ~SET `~scheme$st
◎
If c is an ASCII alpha, append c, lowercased, to buffer, and set state to scheme state.
</li>
			<li>
~ELIF［
%上書state ~EQ ε
］
⇒＃
%~pointer ~DECBY 1；
%state ~SET `~schemeなし$st
◎
Otherwise, if state override is not given, set state to no scheme state, and decrease pointer by one.
</li>
			<li>
<p>
~ELSE
⇒＃
`検証~error$；
~RET `失敗^i
◎
Otherwise, validation error, return failure.
</p>

<p class="note">
この `失敗^i の指示は、 `Location$I ~objの `~protocol0$m 属性から排他的に利用される。
◎
This indication of failure is used exclusively by Location object’s protocol attribute.
</p>
			</li>
		</ol>
	</dd>

<!--% scheme-state -->
	<dt>`~scheme@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~IN { `~ASCII英数字$, ❝+, ❝-, ❝. }
］
⇒
%~buffer ~APPEND `~ASCII小文字~化する$( `C$V )
◎
If c is an ASCII alphanumeric, U+002B (+), U+002D (-), or U+002E (.), append c, lowercased, to buffer.
</li>
			<li>
<p>
~ELIF［
`C$V ~EQ ❝:
］：
◎
Otherwise, if c is U+003A (:), then:
</p>

				<ol>
					<li>
<p>
~IF［
%上書state ~NEQ ε
］~AND［
次のいずれかが満たされる
］…：
◎
If state override is given, then:
</p>
						<ul>
							<li>
［
%url の`~scheme$url, %~buffer
］のうち，片方だけが`特別~scheme$である
◎
If url’s scheme is a special scheme and buffer is not a special scheme, then return.
◎
If url’s scheme is not a special scheme and buffer is a special scheme, then return.
</li>
							<li>
［［
%url は`資格証明情報を含む$
］~OR［
%url の`~port$url ~NEQ ~NULL
］］~AND［
%~buffer ~EQ `file^l
］
◎
If url includes credentials or has a non-null port, and buffer is "file", then return.
</li>
							<li>
［
%url の`~scheme$url ~EQ `file^l
］~AND［
%url の`~host$urlは［
`空~host$または~NULL
］である
］
◎
If url’s scheme is "file" and its host is an empty host or null, then return.
</li>
						</ul>
<p>
…ならば
⇒
~RET
◎
↑</p>
					</li>
					<li>
%url の`~scheme$url ~SET %~buffer
◎
Set url’s scheme to buffer.
</li>
					<li>
<p>
~IF［
%上書state ~NEQ ε
］：
◎
If state override is given, then:
</p>
						<ol>
							<li>
~IF［
%url の`~port$url ~EQ %url の`~scheme$urlの`既定~port$
］
⇒
%url の`~port$url ~SET ~NULL
◎
If url’s port is url’s scheme’s default port, then set url’s port to null.
</li>
							<li>
~RET
◎
Return.
</li>
						</ol>
					</li>
					<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
					<li>
<p>
~IF［
%url の`~scheme$url ~EQ `file^l
］：
◎
If url’s scheme is "file", then:
</p>
						<ol>
							<li>
~IF［
`C1$V ~NEQ `/^l
］~OR［
`C2$V ~NEQ `/^l
］
⇒
`検証~error$
◎
If remaining does not start with "//", validation error.
</li>
							<li>
%state ~SET `~file$st
◎
Set state to file state.
</li>
						</ol>
					</li>
					<li>
<p>
~ELIF［
%url は`特別$である
］~AND［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ %url の`~scheme$url
］
⇒
%state ~SET `特別 相対/権限$st
◎
Otherwise, if url is special, base is non-null, and base’s scheme is equal to url’s scheme, set state to special relative or authority state.
</p>

<p class="note">注記：
これは、`~cannot-be-a-base-URL~flag$は ~OFF にされていることを意味する。
◎
This means that base’s cannot-be-a-base-URL flag is unset.
</p>
					</li>
					<li>
~ELIF［
%url は`特別$である
］
⇒
%state ~SET `特別 権限~slash$st
◎
Otherwise, if url is special, set state to special authority slashes state.
</li>
					<li>
~ELIF［
`C1$V ~EQ ❝/
］
⇒＃
%~pointer ~INCBY 1；
%state ~SET `~path/権限$st
◎
Otherwise, if remaining starts with an U+002F (/), set state to path or authority state and increase pointer by one.
</li>
					<li>
~ELSE
⇒＃
%url の`~cannot-be-a-base-URL~flag$ ~SET ~ON；
%url の`~path$urlに空~文字列を`付加する$；
%state ~SET `~cannot-be-a-base-URL~path$st
◎
Otherwise, set url’s cannot-be-a-base-URL flag, append an empty string to url’s path, and set state to cannot-be-a-base-URL path state.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%上書state ~EQ ε
］
⇒＃
%~buffer ~SET 空~文字列；
%~pointer ~SET −1 （%入力 の最初の~cpから、やり直す）；
%state ~SET `~schemeなし$st；
◎
Otherwise, if state override is not given, set buffer to the empty string, state to no scheme state, and start over (from the first code point in input).
</li>
			<li>
<p>
~ELSE
⇒＃
`検証~error$；
~RET `失敗^i
◎
Otherwise, validation error, return failure.
</p>

<p class="note">
この `失敗^i の指示は、 `Location$I ~objの `~protocol0$m 属性から排他的に利用される。
更には、この~stateの早期における非 `失敗^i による終了は、その属性を定義するための意図的な相違である。
◎
This indication of failure is used exclusively by Location object’s protocol attribute. Furthermore, the non-failure termination earlier in this state is an intentional difference for defining that attribute.
</p>
			</li>
		</ol>
	</dd>

<!--% no-scheme-state -->
	<dt>`~schemeなし@st</dt>
	<dd>
		<ol>
			<li>
~IF［
%基底 ~EQ ~NULL
］~OR［［
%基底 の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］~AND［
`C$V ~NEQ ❝#
］］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If base is null, or base’s cannot-be-a-base-URL flag is set and c is not U+0023 (#), validation error, return failure.
</li>
			<li>
<p>
~ELIF［
%基底 の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］~AND［
`C$V ~EQ ❝#
］：
</p>
				<ol>
					<li>
%url の
⇒＃
`~scheme$url ~SET %基底 の`~scheme$url；
`~path$url ~SET %基底 の`~path$urlの複製；
`~query$url ~SET %基底 の`~query$url；
`素片$url ~SET 空~文字列；
`~cannot-be-a-base-URL~flag$ ~SET ~ON
</li>
					<li>
%state ~SET `素片$st
</li>
				</ol>
◎
Otherwise, if base’s cannot-be-a-base-URL flag is set and c is U+0023 (#), set url’s scheme to base’s scheme, url’s path to a copy of base’s path, url’s query to base’s query, url’s fragment to the empty string, set url’s cannot-be-a-base-URL flag, and set state to fragment state.
</li>
			<li>
~ELIF［
%基底 の`~scheme$url ~NEQ `file^l
］
⇒＃
%~pointer ~DECBY 1；
%state ~SET `相対$st
◎
Otherwise, if base’s scheme is not "file", set state to relative state and decrease pointer by one.
</li>
			<li>
~ELSE
⇒＃
%~pointer ~DECBY 1；
%state ~SET `~file$st
◎
Otherwise, set state to file state and decrease pointer by one.
</li>
		</ol>
	</dd>

<!--% special-relative-or-authority-state -->
	<dt>`特別 相対/権限@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~EQ ❝/
］~AND［
`C1$V ~EQ ❝/
］
⇒＃
%~pointer ~INCBY 1；
%state ~SET `特別 権限~slash無視$st
◎
If c is U+002F (/) and remaining starts with U+002F (/), then set state to special authority ignore slashes state and increase pointer by one.
</li>
			<li>
~ELSE
⇒＃
`検証~error$；
%~pointer ~DECBY 1；
%state ~SET `相対$st
◎
Otherwise, validation error, set state to relative state and decrease pointer by one.
</li>
		</ol>
	</dd>

<!--% path-or-authority-state -->
	<dt>`~path/権限@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~EQ ❝/
］
⇒
%state ~SET `権限$st
◎
If c is U+002F (/), then set state to authority state.
</li>
			<li>
~ELSE
⇒＃
%~pointer ~DECBY 1；
%state ~SET `~path$st
◎
Otherwise, set state to path state, and decrease pointer by one.
</li>
		</ol>
	</dd>

<!--% relative-state -->
	<dt>`相対@st</dt>
	<dd>
		<ol>
			<li>
%url の`~scheme$url ~SET %基底 の`~scheme$url
</li>
			<li>
~IF［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
⇒＃
`検証~error$；
%state ~SET `相対~slash$st
</li>
			<li>
~ELIF［
`C$V ~EQ ❝/
］
⇒
%state ~SET `相対~slash$st
</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
%url の
⇒＃
`~username$url ~SET %基底 の`~username$url；
`~password$url ~SET %基底 の`~password$url；
`~host$url ~SET %基底 の`~host$url；
`~port$url ~SET %基底 の`~port$url；
`~path$url ~SET %基底 の`~path$urlの複製
</li>
					<li>
<p>
`C$V に応じて：
</p>
						<ol class="switch">
							<li>
`EOF$i
⇒
%url の`~query$url ~SET %基底 の`~query$url
</li>
							<li>
❝?
⇒＃
%url の`~query$url ~SET 空~文字列；
%state ~SET `~query$st
</li>
							<li>
❝#
⇒＃
%url の`~query$url ~SET %基底 の`~query$url；
%url の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
</li>
							<li>
<p>
~OTHER：
</p>
								<ol>
									<li>
~IF［
%url の`~path$urlは空でない
］
⇒
%url の`~path$urlから最後の~itemを`除去する$
</li>
									<li>
%~pointer ~DECBY 1
</li>
									<li>
%state ~SET `~path$st
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
<p class="trans-note">【
この段では、原文の記述を論理的に集約している。
】</p>

◎
Set url’s scheme to base’s scheme, and then, switching on c:

The EOF code point
• Set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, url’s path to a copy of base’s path, and url’s query to base’s query.

U+002F (/)
• Set state to relative slash state.

U+003F (?)
• Set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, url’s path to a copy of base’s path, url’s query to the empty string, and state to query state.

U+0023 (#)
• Set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, url’s path to a copy of base’s path, url’s query to base’s query, url’s fragment to the empty string, and state to fragment state.

Otherwise
• If url is special and c is U+005C (\), validation error, set state to relative slash state.
• Otherwise, run these steps:
•• Set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, url’s path to a copy of base’s path, and then remove url’s path’s last item, if any.
•• Set state to path state, and decrease pointer by one.
</dd>

<!--% relative-slash-state -->
	<dt>`相対~slash@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
%url は`特別$である
］~AND［
`C$V ~IN { ❝/, ❝\ }
］：
◎
If url is special and c is U+002F (/) or U+005C (\), then: 
</p>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝\
］
⇒
`検証~error$
◎
If c is U+005C (\), validation error.
</li>
					<li>
%state ~SET `特別 権限~slash無視$st
◎
Set state to special authority ignore slashes state.
</li>
				</ol>
			</li>
			<li>
~ELIF［
`C$V ~EQ ❝/
］
⇒
%state ~SET `権限$st
◎
Otherwise, if c is U+002F (/), then set state to authority state.
</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
%url の
⇒＃
`~username$url ~SET %基底 の`~username$url；
`~password$url ~SET %基底 の`~password$url；
`~host$url ~SET %基底 の`~host$url；
`~port$url ~SET %基底 の`~port$url
</li>
					<li>
%~pointer ~DECBY 1
</li>
					<li>
%state ~SET `~path$st
</li>
				</ol>
◎
Otherwise, set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, state to path state, and then, decrease pointer by one.
</li>
		</ol>
	</dd>

<!--% special-authority-slashes-state -->
	<dt>`特別 権限~slash@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~EQ ❝/
］~AND［
`C1$V ~EQ ❝/
］
⇒
%~pointer ~INCBY 1
◎
If c is U+002F (/) and remaining starts with U+002F (/), then set state to special authority ignore slashes state and increase pointer by one.
</li>
			<li>
~ELSE
⇒＃
`検証~error$；
%~pointer ~DECBY 1
◎
Otherwise, validation error, set state to special authority ignore slashes state, and decrease pointer by one.
</li>
			<li>
%state ~SET `特別 権限~slash無視$st
◎
↑</li>
		</ol>
	</dd>

<!--% special-authority-ignore-slashes-state -->
	<dt>`特別 権限~slash無視@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~NIN { ❝/, ❝\ }
］
⇒＃
%~pointer ~DECBY 1；
%state ~SET `権限$st
◎
If c is neither U+002F (/) nor U+005C (\), then set state to authority state, and decrease pointer by one.
</li>
			<li>
~ELSE
⇒
`検証~error$
◎
Otherwise, validation error.
</li>
		</ol>
	</dd>

<!--% authority-state -->
	<dt>`権限@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`C$V ~EQ ❝@
］：
◎
If c is U+0040 (@), then:
</p>
				<ol>
					<li>
`検証~error$
◎
Validation error.
</li>
					<li>
~IF［
%~atmark~flag ~EQ ~ON
］
⇒
%~buffer の先頭に `%40^l を~~挿入する
◎
If the @ flag is set, prepend "%40" to buffer.
</li>
					<li>
%~atmark~flag ~SET ~ON
◎
Set the @ flag.
</li>
					<li>
<p>
%~buffer 内の
~EACH( %~cp )
に対し：
◎
For each codePoint in buffer:
</p>
						<ol>
							<li>
~IF［
%~cp ~EQ ❝:
］~AND［
%~password~token出現~flag ~EQ ~OFF
］
⇒＃
%~password~token出現~flag ~SET ~ON；
~CONTINUE
◎
If codePoint is U+003A (:) and passwordTokenSeenFlag is unset, then set passwordTokenSeenFlag and continue.
</li>
							<li>
%符号化-済み~cp ~LET
`~UTF-8~percent-符号化する$( `~userinfo~percent-符号化-集合$, %~cp )
◎
Let encodedCodePoints be the result of running UTF-8 percent encode codePoint using the userinfo percent-encode set.
</li>
							<li>
~IF［
%~password~token出現~flag ~EQ ~ON
］
⇒
%url の`~password$url ~APPEND %符号化-済み~cp
◎
If passwordTokenSeenFlag is set, then append encodedCodePoints to url’s password.
</li>
							<li>
~ELSE
⇒
%url の`~username$url ~APPEND %符号化-済み~cp
◎
Otherwise, append encodedCodePoints to url’s username.
</li>
						</ol>
					</li>
					<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
次のいずれかが満たされる
］…：
◎
Otherwise, if one of the following is true
</p>
				<ul>
					<li>
`C$V ~IN { `EOF$i, ❝/, ❝?, ❝# } 
◎
c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
</li>
					<li>
［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
◎
url is special and c is U+005C (\)
</li>
				</ul>

<p>
…ならば：
◎
then:
</p>

				<ol>
					<li>
~IF［
%~atmark~flag ~EQ ~ON
］~AND［
%~buffer ~EQ 空~文字列
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If @ flag is set and buffer is the empty string, validation error, return failure.
</li>
					<li>
%~pointer ~DECBY %~buffer に含まれる~cpの個数 ~PLUS 1
◎
Decrease pointer by the number of code points in buffer plus one,＼
</li>
					<li>
%~buffer ~SET 空~文字列
◎
set buffer to the empty string, and＼
</li>
					<li>
%state ~SET `~host$st
◎
set state to host state.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%~buffer ~APPEND `C$V
◎
Otherwise, append c to buffer.
</li>
		</ol>
	</dd>

<!--% host-state -->
	<dt>`~host@st</dt>

<!--% hostname-state -->
	<dt>`~hostname@st</dt>
	<dd>
		<ol>
			<li>
~IF［
%上書state ~NEQ ε
］~AND［
%url の`~scheme$url ~EQ `file^l
］
⇒＃
%~pointer ~DECBY 1；
%state ~SET `~file~host$st
◎
If state override is given and url’s scheme is "file", then decrease pointer by one and set state to file host state.
</li>
			<li>
<p>
~ELIF［
`C$V ~EQ ❝:
］~AND［
%~brackets~flag ~EQ ~OFF
］：
◎
Otherwise, if c is U+003A (:) and the [] flag is unset, then:
</p>

				<ol>
					<li>
~IF［
%~buffer ~EQ 空~文字列
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If buffer is the empty string, validation error, return failure.
</li>
					<li>
%~host ~LET
`~host構文解析器$( %~buffer, `特別でない？$( %url ) )
◎
Let host be the result of host parsing buffer with url is not special.
</li>
					<li>
~IF［
%~host ~EQ `失敗^i 
］
⇒
~RET `失敗^i
◎
If host is failure, then return failure.
</li>
					<li>
%url の`~host$url ~SET %~host
◎
Set url’s host to host, buffer to the empty string, and state to port state.
</li>
					<li>
~IF［
%上書state ~EQ `~hostname$st
］
⇒
~RET
◎
If state override is given and state override is hostname state, then return.
</li>
					<li>
%~buffer ~SET 空~文字列
◎
↑</li>
					<li>
%state ~SET `~port$st
◎
↑</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
次のいずれかが満たされる
］…：
◎
Otherwise, if one of the following is true
</p>
				<ul>
					<li>
`C$V ~IN { `EOF$i, ❝/, ❝?, ❝# } 
◎
c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
</li>
					<li>
［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
◎
url is special and c is U+005C (\)
</li>
				</ul>
<p>
…ならば：
◎
then decrease pointer by one, and then:
</p>

				<ol>
					<li>
%~pointer ~DECBY 1
◎
↑</li>
					<li>
~IF［
%url は`特別$である
］~AND［
%~buffer ~EQ 空~文字列
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If url is special and buffer is the empty string, validation error, return failure.
</li>
					<li>
~ELIF［
%上書state ~NEQ ε
］~AND［
%~buffer ~EQ 空~文字列
］~AND［［
%url は`資格証明情報を含む$
］~OR［
%url の`~port$url ~NEQ ~NULL
］］
⇒＃
`検証~error$；
~RET
◎
Otherwise, if state override is given, buffer is the empty string, and either url includes credentials or url’s port is non-null, validation error, return.
</li>
					<li>
%~host ~LET
`~host構文解析器$( %~buffer, `特別でない？$( %url ) )
◎
Let host be the result of host parsing buffer with url is not special.
</li>
					<li>
~IF［
%~host ~EQ `失敗^i 
］
⇒
~RET `失敗^i
◎
If host is failure, then return failure.
</li>
					<li>
%url の`~host$url ~SET %~host
◎
Set url’s host to host, buffer to the empty string, and state to path start state.
</li>
					<li>
~IF［
%上書state ~NEQ ε
］
⇒
~RET
◎
If state override is given, then return.
</li>
					<li>
%~buffer ~SET 空~文字列
◎
↑</li>
					<li>
%state ~SET `~path開始-$st
◎
↑</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
：
◎
Otherwise:
</p>

				<ol>
					<li>
~IF［
`C$V ~EQ ❝[
］
⇒
%~brackets~flag ~SET ~ON
◎
If c is U+005B ([), then set the [] flag.
</li>
					<li>
~IF［
`C$V ~EQ ❝]
］
⇒
%~brackets~flag ~SET ~OFF
◎
If c is U+005D (]), then unset the [] flag.
</li>
					<li>
%~buffer ~APPEND `C$V
◎
Append c to buffer.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% port-state -->
	<dt>`~port@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~IN `~ASCII数字$
］
⇒
%~buffer ~APPEND `C$V
◎
If c is an ASCII digit, append c to buffer.
</li>
			<li>
<p>
~ELIF［
次のいずれかが満たされる
］…：
◎
Otherwise, if one of the following is true
</p>
				<ul>
					<li>
`C$V ~IN { `EOF$i, ❝/, ❝?, ❝# } 
◎
c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
</li>
					<li>
［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
◎
url is special and c is U+005C (\)
</li>
					<li>
%上書state ~NEQ ε
◎
state override is given
</li>
				</ul>
<p>
…ならば：
◎
then:
</p>
				<ol>
					<li>
<p>
~IF［
%~buffer ~NEQ 空~文字列
］：
◎
If buffer is not the empty string, then:
</p>
						<ol>
							<li>
%~port ~LET %~buffer を［
その各 `~ASCII数字$を基数 10 による値 0 〜 9 と解釈した
］下で表現される，数学的な整数~値
◎
Let port be the mathematical integer value that is represented by buffer in radix-10 using ASCII digits for digits with values 0 through 9.
</li>
							<li>
~IF［
%~port ~GTE ( 2 の 16 乗 )
］
⇒＃
`検証~error$；
~RET `失敗^i
◎
If port is greater than 216 − 1, validation error, return failure.
</li>
							<li>
%url の`~port$url ~SET［
%~port ~EQ %url の`~scheme$urlの`既定~port$ならば ~NULL ／
~ELSE_ %~port
］
◎
Set url’s port to null, if port is url’s scheme’s default port, and to port otherwise.
</li>
							<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
						</ol>
					</li>
					<li>
~IF［
%上書state ~NEQ ε
］
⇒
~RET
◎
If state override is given, then return.
</li>
					<li>
%~pointer ~DECBY 1
◎
↓</li>
					<li>
%state ~SET `~path開始-$st
◎
Set state to path start state, and decrease pointer by one.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒＃
`検証~error$；
~RET `失敗^i
◎
Otherwise, validation error, return failure.
</li>
		</ol>
	</dd>

<!--% file-state -->
	<dt>`~file@st</dt>
	<dd>
		<ol>
			<li>
%url の`~scheme$url ~SET `file^l
◎
Set url’s scheme to "file".
</li>
			<li>
<p>
~IF［
`C$V ~IN { ❝/, ❝\ }
］：
◎
If c is U+002F (/) or U+005C (\), then:
</p>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝\
］
⇒
`検証~error$
◎
If c is U+005C (\), validation error.
</li>
					<li>
%state ~SET `~file~slash$st
◎
Set state to file slash state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ `file^l
］：
◎
Otherwise, if base is non-null and base’s scheme is "file",＼
</p>
				<ol>
					<li>
<p>
%D ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
並び［
`C$V, `C1$V, `C2$V
］は`~drive_letterから開始されて$いる
</p>

<p class="note">注記：
これは~drive_letterのための（~platformに依存しない）過去互換対処である。
</p>

◎
↓↓</li>
					<li>
~IF［
%D ~EQ ~F
］
⇒＃
%url の`~host$url ~SET %基底 の`~host$url；
%url の`~path$url ~SET %基底 の`~path$urlの複製
◎
↓↓</li>
					<li>
<p>
`C$V に応じて：
◎
switch on c:
</p>
						<ol class="switch">
							<li>
`EOF$i
⇒
%url の`~query$url ~SET %基底 の`~query$url
◎
The EOF code point
• Set url’s host to base’s host, url’s path to a copy of base’s path, and url’s query to base’s query.
</li>

							<li>
❝?
⇒＃
%url の`~query$url ~SET 空~文字列；
%state ~SET `~query$st
◎
U+003F (?)
• Set url’s host to base’s host, url’s path to a copy of base’s path, url’s query to the empty string, and state to query state.
</li>

							<li>
❝#
⇒＃
%url の`~query$url ~SET %基底 の`~query$url；
%url の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
◎
U+0023 (#)
• Set url’s host to base’s host, url’s path to a copy of base’s path, url’s query to base’s query, url’s fragment to the empty string, and state to fragment state.
</li>

							<li>
<p>
その他：
◎
Otherwise
</p>
								<ol>
									<li>
~IF［
%D ~EQ ~F
］
⇒
%url の`~pathを短縮する$
◎
If the substring from pointer in input does not start with a Windows drive letter, then set url’s host to base’s host, url’s path to a copy of base’s path, and then shorten url’s path.

This is a (platform-independent) Windows drive letter quirk.
</li>
									<li>
~ELSE
⇒
`検証~error$
◎
Otherwise, validation error.
</li>
									<li>
%~pointer ~DECBY 1；
◎
↓</li>
									<li>
%state ~SET `~path$st
◎
Set state to path state, and decrease pointer by one.
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~ELSE
⇒＃
%~pointer ~DECBY 1；
%state ~SET `~path$st
◎
Otherwise, set state to path state, and decrease pointer by one.
</li>
		</ol>
	</dd>

<!--% file-slash-state -->
	<dt>`~file~slash@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`C$V ~IN { ❝/, ❝\ }
］：
◎
If c is U+002F (/) or U+005C (\), then:
</p>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝\
］
⇒
`検証~error$
◎
If c is U+005C (\), validation error.
</li>
					<li>
%state ~SET `~file~host$st
◎
Set state to file host state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
：
◎
Otherwise:
</p>
				<ol>
					<li>
<p>
~IF［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ `file^l
］~AND［
並び［
`C$V, `C1$V, `C2$V
］は`~drive_letterから開始されて$いない
］：
◎
If base is non-null, base’s scheme is "file", and the substring from pointer in input does not start with a Windows drive letter, then:
</p>
						<ol>
							<li>
<p>
~IF［［
%基底 の`~path$url[0]
］は `正規化-済み~drive_letter$である
］
⇒
%url の`~path$urlに［
%基底 の`~path$url[0]
］を付加する
◎
If base’s path[0] is a normalized Windows drive letter, then append base’s path[0] to url’s path.
</p>

<p class="note">注記：
これは~drive_letterのための（~platformに依存しない）過去互換対処である。
この条件の下では、 %url, %基底 いずれの`~host$urlも~NULLであり、したがって，複製されない。
◎
This is a (platform-independent) Windows drive letter quirk. Both url’s and base’s host are null under these conditions and therefore not copied.
</p>
							</li>
							<li>
~ELSE
⇒
%url の`~host$url ~SET %基底 の`~host$url
◎
Otherwise, set url’s host to base’s host.
</li>
						</ol>
					</li>
					<li>
%~pointer ~DECBY 1
◎
↓</li>
					<li>
%state ~SET `~path$st
◎
Set state to path state, and decrease pointer by one.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% file-host-state -->
	<dt>`~file~host@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`C$V ~IN { `EOF$i, ❝/, ❝\, ❝?, ❝# }
］：
◎
If c is the EOF code point, U+002F (/), U+005C (\), U+003F (?), or U+0023 (#), then＼
</p>
				<ol>
					<li>
%~pointer ~DECBY 1
◎
decrease pointer by one and then:＼
</li>
					<li>
<p>
~IF［
%上書state ~EQ ε
］~AND［
%~buffer は`~drive_letter$である
］
⇒＃
`検証~error$；
%state ~SET `~path$st
◎
If state override is not given and buffer is a Windows drive letter, validation error, set state to path state.
</p>

<p class="note">注記：
これは~drive_letterのための（~platformに依存しない）過去互換対処である。
ここでは %~buffer は設定し直されず，代わりに`~path$stの中で利用される。
◎
This is a (platform-independent) Windows drive letter quirk. buffer is not reset here and instead used in the path state.
</p>
					</li>
					<li>
<p>
~ELIF［
%~buffer ~EQ 空~文字列
］：
◎
Otherwise, if buffer is the empty string, then:
</p>
						<ol>
							<li>
%url の`~host$url ~SET 空~文字列
◎
Set url’s host to the empty string.
</li>
							<li>
~IF［
%上書state ~NEQ ε
］
⇒
~RET
◎
If state override is given, then return.
</li>
							<li>
%state ~SET `~path開始-$st
◎
Set state to path start state.
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE
：
◎
Otherwise, run these steps:
</p>
						<ol>
							<li>
%~host ~LET
`~host構文解析器$( %~buffer, `特別でない？$( %url ) )
◎
Let host be the result of host parsing buffer with url is not special.
</li>
							<li>
~IF［
%~host ~EQ `失敗^i 
］
⇒
~RET `失敗^i
◎
If host is failure, then return failure.
</li>
							<li>
~IF［
%~host ~EQ `localhost^l
］
⇒
%~host ~SET 空~文字列
◎
If host is "localhost", then set host to the empty string.
</li>
							<li>
%url の`~host$url ~SET %~host
◎
Set url’s host to host.
</li>
							<li>
~IF［
%上書state ~NEQ ε
］
⇒
~RET
◎
If state override is given, then return.
</li>
							<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string and＼
</li>
							<li>
%state ~SET `~path開始-$st
◎
state to path start state.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%~buffer ~APPEND `C$V
◎
Otherwise, append c to buffer.
</li>
		</ol>
	</dd>

<!--% path-start-state -->
	<dt>`~path開始-@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
%url は`特別$である
］：
◎
If url is special, then:
</p>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝\
］
⇒
`検証~error$
◎
If c is U+005C (\), validation error.
</li>
					<li>
~IF［
`C$V ~NIN { ❝/, ❝\ }
］
⇒
%~pointer ~DECBY 1
◎
Set state to path state.
◎
If c is neither U+002F (/) nor U+005C (\), then decrease pointer by one.
</li>
					<li>
%state ~SET `~path$st
◎
↑</li>
				</ol>
			</li>
			<li>
~ELIF［
%上書state ~EQ ε
］~AND［
`C$V ~EQ ❝?
］
⇒＃
%url の`~query$url ~SET 空~文字列；
%state ~SET `~query$st
◎
Otherwise, if state override is not given and c is U+003F (?), set url’s query to the empty string and state to query state.
</li>
			<li>
~ELIF［
%上書state ~EQ ε
］~AND［
`C$V ~EQ ❝#
］
⇒＃
%url の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
◎
Otherwise, if state override is not given and c is U+0023 (#), set url’s fragment to the empty string and state to fragment state.
</li>
			<li>
<p>
~ELIF［
`C$V ~NEQ `EOF$i
］：
◎
Otherwise, if c is not the EOF code point:
</p>

				<ol>
					<li>
~IF［
`C$V ~NEQ ❝/
］
⇒
%~pointer ~DECBY 1
◎
Set state to path state.
◎
If c is not U+002F (/), then decrease pointer by one.
</li>
					<li>
%state ~SET `~path$st
◎
↑</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% path-state -->
	<dt>`~path@st</dt>
	<dd>
		<ol>
			<li>
%~slash ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
`C$V ~EQ ❝/
］~OR［［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］］
◎
↓</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If one of the following is true
</p>
				<ul>
					<li>
`C$V ~EQ `EOF$i
◎
c is the EOF code point or U+002F (/)
↓</li>
					<li>
%~slash ~EQ ~T
◎
url is special and c is U+005C (\)
</li>
					<li>
［
%上書state ~EQ ε
］~AND［
`C$V ~IN { ❝?, ❝# }
］：
◎
state override is not given and c is U+003F (?) or U+0023 (#)
</li>
				</ul>
<p>
…ならば：
◎
then:
</p>
				<ol>
					<li>
~IF［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
⇒
`検証~error$
◎
If url is special and c is U+005C (\), validation error.
</li>
					<li>
<p>
~IF［
%~buffer は`二重dot~path区分$である
］：
</p>
						<ol>
							<li>
%url の`~pathを短縮する$
</li>
							<li>
~IF［
%~slash ~EQ ~F
］
⇒
%url の`~path$urlに空~文字列を`付加する$
</li>
						</ol>
◎
If buffer is a double-dot path segment, shorten url’s path, and then if neither c is U+002F (/), nor url is special and c is U+005C (\), append the empty string to url’s path.
</li>
					<li>
~ELIF［
%~buffer は`単dot~path区分$である
］
⇒
~IF［
%~slash ~EQ ~F
］
⇒
%url の`~path$urlに空~文字列を`付加する$
◎
Otherwise, if buffer is a single-dot path segment and if neither c is U+002F (/), nor url is special and c is U+005C (\), append the empty string to url’s path.
</li>
					<li>
<p>
~ELSE
：
◎
Otherwise, if buffer is not a single-dot path segment, then:
</p>

						<ol>
							<li>
<p>
~IF［
%url の`~scheme$url ~EQ `file^l
］~AND［
%url の`~path$urlは`空$である
］~AND［
%~buffer は`~drive_letter$である
］：
◎
If url’s scheme is "file", url’s path is empty, and buffer is a Windows drive letter, then:
</p>

							<ol>
								<li>
~IF［
%url の`~host$url ~NIN { 空~文字列, ~NULL }
］
⇒＃
`検証~error$；
%url の`~host$url ~SET 空~文字列
◎
If url’s host is neither the empty string nor null, validation error, set url’s host to the empty string.
</li>
								<li>
%~buffer の 2 個目の~cpを ❝: に置換する
◎
Replace the second code point in buffer with U+003A (:).
</li>
							</ol>


<p class="note">注記：
これは~drive_letterのための（~platformに依存しない）過去互換対処である。
◎
This is a (platform-independent) Windows drive letter quirk.
</p>
							</li>
							<li>
%url の`~path$urlに %~buffer を`付加する$
◎
Append buffer to url’s path.
</li>
						</ol>
					</li>
					<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
					<li>
~IF［
%url の`~scheme$url ~EQ `file^l
］~AND［
`C$V ~IN { `EOF$i, ❝?, ❝# }
］
⇒
~WHILE［
%url の`~path$urlの`~size$ ~GT 1
］~AND［
%url の`~path$url[0] ~EQ 空~文字列
］
⇒＃
`検証~error$；
%url の`~path$urlから最初の`~item$を`除去する$
◎
If url’s scheme is "file" and c is the EOF code point, U+003F (?), or U+0023 (#), then while url’s path’s size is greater than 1 and url’s path[0] is the empty string, validation error, remove the first item from url’s path.
</li>
					<li>
~IF［
`C$V ~EQ ❝?
］
⇒＃
%url の`~query$url ~SET 空~文字列；
%state ~SET `~query$st
◎
If c is U+003F (?), then set url’s query to the empty string and state to query state.
</li>
					<li>
~IF［
`C$V ~EQ ❝#
］
⇒＃
%url の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
◎
If c is U+0023 (#), then set url’s fragment to the empty string and state to fragment state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
：
◎
Otherwise, run these steps:
</p>
				<ol>
					<li>
`~URL単位かどうか検証する$
◎
If c is not a URL code point and not U+0025 (%), validation error.
◎
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, validation error.
</li>
					<li>
%~buffer ~APPEND
`~UTF-8~percent-符号化する$( `~path~percent-符号化-集合$, `C$V )
◎
UTF-8 percent encode c using the path percent-encode set, and append the result to buffer.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% cannot-be-a-base-url-path-state -->
	<dt>`~cannot-be-a-base-URL~path@st</dt>
	<dd>
		<ol>
			<li>
<p>
`C$V に応じて：
◎
↓</p>
				<ol class="switch">
					<li>
❝?
⇒＃
%url の`~query$url ~SET 空~文字列；
%state ~SET `~query$st
◎
If c is U+003F (?), then set url’s query to the empty string and state to query state.
</li>
					<li>
❝#
⇒＃
%url の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
◎
Otherwise, if c is U+0023 (#), then set url’s fragment to the empty string and state to fragment state.
</li>
					<li>
`EOF$i
⇒
何もしない
◎
↓</li>
					<li>
<p>
~OTHER：
◎
Otherwise:
</p>
						<ol>
							<li>
`~URL単位かどうか検証する$
◎
If c is not the EOF code point, not a URL code point, and not U+0025 (%), validation error.
◎
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, validation error.
</li>
							<li>
%url の`~path$url[0]
~APPEND
`~UTF-8~percent-符号化する$( `~C0制御文字~percent-符号化-集合$, `C$V )
◎
If c is not the EOF code point, UTF-8 percent encode c using the C0 control percent-encode set, and append the result to url’s path[0].
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% query-state -->
	<dt>`~query@st</dt>
	<dd>
		<ol>
			<li>
~IF［
%url は`特別$でない
］~OR［
%url の`~scheme$url ~IN { `ws^l, `wss^l }
］
⇒
%符号化法 ~SET `~UTF-8$
◎
If encoding is not UTF-8 and one of the following is true
• url is not special
• url’s scheme is "ws" or "wss"
◎
then set encoding to UTF-8.
</li>
			<li>
~IF［
%上書state ~EQ ε
］~AND［
`C$V ~EQ ❝#
］
⇒＃
%url の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
◎
If state override is not given and c is U+0023 (#), then set url’s fragment to the empty string and state to fragment state.
</li>
			<li>
<p>
~ELIF［
`C$V ~NEQ `EOF$i
］：
◎
Otherwise, if c is not the EOF code point:
</p>
				<ol>
					<li>
`~URL単位かどうか検証する$
◎
If c is not a URL code point and not U+0025 (%), validation error.
◎
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, validation error.
</li>
					<li>
%~byte列 ~LET `符号化法を用いて符号化する$( `C$V, %符号化法 )
◎
Let bytes be the result of encoding c using encoding.
</li>
					<li>
<p>
~IF［
%~byte列 の［
1 個目, 2 個目, 最後
］の~byte ~EQ 順に［
`26^X `&amp;^smb, ❛#, ❛;
］
⇒
%url の`~query$urlに次の結果を付加する
⇒
`同型に復号する$( 次を順に連結した結果 )
⇒＃
`%26%23^bl,
%~byte列 から 1 個目, 2 個目, 最後の~byteを除去した結果,
`%3B^bl
◎
If bytes starts with `&amp;#` and ends with 0x3B (;), then:
• Replace `&amp;#` at the start of bytes with `%26%23`.
• Replace 0x3B (;) at the end of bytes with `%3B`.
• Append bytes, isomorphic decoded, to url’s query.
</p>

<p class="note">注記：
これは、`~UTF-8$以外の`符号化法$を用いて<a href="~ENCODING#encode">~cpを符号化する</a>ときに起こり得る。
◎
This can happen when encoding code points using a non-UTF-8 encoding.
</p>
					</li>
					<li>
<p>
~ELSE
⇒
%~byte列 内の
~EACH( %~byte )
に対し：
◎
Otherwise, for each byte in bytes:
</p>

						<ol>
							<li>
~IF［
%~byte ~LT ❛!
］~OR［
%~byte ~GT ❛~
］~OR［
%~byte ~IN { ❛", ❛#, `3C^X `&lt;^smb, `3E^X `&gt;^smb }
］~OR［［
%~byte ~EQ ❛'
］~AND［
%url は`特別$である
］］
⇒
%url の`~query$urlに次の結果を付加する
⇒
`~byteを文字列に~percent-符号化する$( %~byte )
◎
If one of the following is true
• byte is less than 0x21 (!)
• byte is greater than 0x7E (~)
• byte is 0x22 ("), 0x23 (#), 0x3C (&lt;), or 0x3E (&gt;)
• byte is 0x27 (') and url is special
◎
then append byte, percent encoded, to url’s query.
</li>
							<li>
~ELSE
⇒
%url の`~query$urlに %~byte を値とする~cpを付加する
◎
Otherwise, append a code point whose value is byte to url’s query.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% fragment-state -->
	<dt>`素片@st</dt>
	<dd>
		<ol>
			<li>
<p>
`C$V に応じて：
◎
Switching on c:
</p>
				<ol class="switch">
					<li>
`EOF$i
⇒
何もしない
◎
The EOF code point
• Do nothing.
</li>
					<li>
`0000^U NULL
⇒
`検証~error$
◎
U+0000 NULL
• Validation error.
</li>
					<li>
<p>
~OTHER：
◎
Otherwise
</p>
						<ol>
							<li>
`~URL単位かどうか検証する$
◎
If c is not a URL code point and not U+0025 (%), validation error.
◎
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, validation error.
</li>
							<li>
%url の`素片$url ~APPEND
`~UTF-8~percent-符号化する$( `素片~percent-符号化-集合$, `C$V )
◎
UTF-8 percent encode c using the fragment percent-encode set and append the result to url’s fragment.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</dd>
</dl>

<p>
◎
↑↑Return url.
</p>


<hr>

<p class="algo-head">
`~URLの~usernameを設定する@
ときは、所与の
( `~URL$ %url, 文字列 %~username )
に対し，次を走らす：
◎
To set the username given a url and username, run these steps:
</p>

<ol>
	<li>
%url の`~username$url ~SET 空~文字列
◎
Set url’s username to the empty string.
</li>
	<li>
%~username 内の
~EACH( ~cp %C )
に対し
⇒
%url の`~username$url ~APPEND
`~UTF-8~percent-符号化する$( `~userinfo~percent-符号化-集合$, %C )
◎
For each code point in username, UTF-8 percent encode it using the userinfo percent-encode set, and append the result to url’s username.
</li>
</ol>


<p class="algo-head">
`~URLの~passwordを設定する@
ときは、所与の
( `~URL$ %url, 文字列 %~username )
に対し，次を走らす：
◎
To set the password given a url and password, run these steps:
</p>

<ol>
	<li>
%url の`~password$url ~SET 空~文字列
◎
Set url’s password to the empty string.
</li>
	<li>
%~password 内の
~EACH( ~cp %C )
に対し
⇒
%url の`~password$url ~APPEND
`~UTF-8~percent-符号化する$( `~userinfo~percent-符号化-集合$, %C )
◎
For each code point in password, UTF-8 percent encode it using the userinfo percent-encode set, and append the result to url’s password.
</li>
</ol>


		</section>
		<section id="url-serializing">
<h3 title="URL serializing">4.5. ~URLの直列化-法</h3>

<p class="algo-head">
`~URL直列化器@
は、所与の
( `~URL$ %url, %素片は除外する~flag ~IN { `素片は除外する^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
The URL serializer takes a URL url, an optional exclude fragment flag, and then runs these steps: 
</p>

<ol>
	<li>
%出力 ~LET
空~文字列 ~APPEND %url の`~scheme$url
~APPEND ❝:
◎
Let output be url’s scheme and U+003A (:) concatenated.
</li>
	<li>
<p>
~IF［
%url の`~host$url ~NEQ ~NULL
］：
◎
If url’s host is non-null:
</p>
		<ol>
			<li>
%出力 ~APPEND `//^l
◎
Append "//" to output.
</li>
			<li>
<p>
~IF［
%url は`資格証明情報を含む$
］：
◎
If url includes credentials, then: 
</p>
				<ol>
					<li>
%出力 ~APPEND %url の`~username$url
◎
Append url’s username to output.
</li>
					<li>
~IF［
%url の`~password$url ~NEQ 空~文字列
］
⇒
%出力 ~APPEND ❝:
~APPEND %url の`~password$url
◎
If url’s password is not the empty string, then append U+003A (:), followed by url’s password, to output.
</li>
					<li>
%出力 ~APPEND ❝@
◎
Append U+0040 (@) to output.
</li>
				</ol>

			</li>
			<li>
%出力 ~APPEND `~hostを直列化する$( %url の`~host$url )
◎
Append url’s host, serialized, to output.
</li>
			<li>
~IF［
%url の`~port$url ~NEQ ~NULL
］
⇒
%出力 ~APPEND ❝:
~APPEND `整数を直列化する$( %url の`~port$url )
◎
If url’s port is non-null, append U+003A (:) followed by url’s port, serialized, to output.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%url の`~host$url ~EQ ~NULL
］~AND［
%url の`~scheme$url ~EQ `file^l
］
⇒
%出力 ~APPEND `//^l
◎
Otherwise, if url’s host is null and url’s scheme is "file", append "//" to output.
</li>
	<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
%出力 ~APPEND %url の`~path$url[0]
◎
If url’s cannot-be-a-base-URL flag is set, append url’s path[0] to output.
</li>
	<li>
~ELSE
⇒
%url の`~path$url内の
~EACH( %文字列 )
に対し
⇒
%出力 ~APPEND ❝/
~APPEND %文字列
◎
Otherwise, then for each string in url’s path, append U+002F (/) followed by the string to output.
</li>
	<li>
~IF［
%url の`~query$url ~NEQ ~NULL
］
⇒
%出力 ~APPEND ❝?
~APPEND %url の`~query$url
◎
If url’s query is non-null, append U+003F (?), followed by url’s query, to output.
</li>
	<li>
~IF［
%素片は除外する~flag ~EQ ε
］~AND［
%url の`素片$url ~NEQ ~NULL
］
⇒
%出力 ~APPEND ❝#
~APPEND %url の`素片$url
◎
If the exclude fragment flag is unset and url’s fragment is non-null, append U+0023 (#), followed by url’s fragment, to output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>


		</section>
		<section id="url-equivalence">
<h3 title="URL equivalence">4.6. ~URLの等価性</h3>

<p class="algo-head">
2 つの`~URL$［
%A, %B
］は、次が満たされるならば，所与の
( %素片は除外する~flag ~IN { `素片は除外する^i, ε }（省略時は ε ） )
の下で
`同等@
とされる
⇒
`~URLを直列化する$( %A, %素片除外~flag ) ~EQ `~URLを直列化する$( %B, %素片除外~flag )
◎
To determine whether a URL A equals B, optionally with an exclude fragments flag, run these steps:
◎
• Let serializedA be the result of serializing A, with the exclude fragment flag set if the exclude fragments flag is set.
◎
• Let serializedB be the result of serializing B, with the exclude fragment flag set if the exclude fragments flag is set.
◎
• Return true if serializedA is serializedB, and false otherwise. 
</p>

		</section>
		<section id="origin">
<h3 title="Origin">4.7. 生成元</h3>

<p class="note">注記：
必要な背景情報については，~HTMLによる`生成元$の定義を見よ。
`HTML$r
◎
See origin’s definition in HTML for the necessary background information. [HTML]
</p>

<p class="algo-head">
`~URL$ %~URL の
`生成元@url
は、 %~URL の`~scheme$urlに応じて，次を走らせて得られる`生成元$である：
◎
A URL’s origin is the origin returned by running these steps, switching on URL’s scheme:
</p>

<dl class="switch">

	<dt>`blob^l</dt>
	<dd>
		<ol>
			<li>
%url ~LET ［
%~URL の`~path$url[0]
］を`基本~URL構文解析器$にかけた結果
◎
Let url be the result of parsing URL’s path[0].
</li>
			<li>
~RET ［
%url ~EQ `失敗^i ならば 新たな`不透明な生成元$ ／
~ELSE_ %url の`生成元$url
］
◎
Return a new opaque origin, if url is failure, and url’s origin otherwise.
</li>
		</ol>
	</dd>
	<dd class="example">
`blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f^l
の`生成元$urlは、成分組
( `https^c, `whatwg.org^c, ~NULL, ~NULL )
になる。
◎
The origin of blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f is the tuple (https, whatwg.org, null, null).
</dd>

	<dt>`ftp^l</dt>
	<dt>`gopher^l</dt>
	<dt>`http^l</dt>
	<dt>`https^l</dt>
	<dt>`ws^l</dt>
	<dt>`wss^l</dt>
	<dd>
~RET 新たな`成分組~生成元$( %~URL の`~scheme$url, %~URL の`~host$url, %~URL の`~port$url, ~NULL )
◎
Return a tuple consisting of URL’s scheme, URL’s host, URL’s port, and null.
</dd>

	<dt>`file^l</dt>
	<dd>
あいにく、これについては，実装に委ねられる。
疑わしい場合は 新たな`不透明な生成元$を返すこと。
◎
Unfortunate as it is, this is left as an exercise to the reader. When in doubt, return a new opaque origin.
</dd>

	<dt>~OTHER</dt>
	<dd>
<p>
~RET 新たな`不透明な生成元$
◎
Return a new opaque origin.
</p>

<p class="note">注記：
これは~~実際に、この種の`~URL$は，自身と`同一生成元$になり得ないことを意味する。
【毎回，異なる結果が返されるので。】
◎
This does indeed mean that these URLs cannot be same-origin with themselves.
</p>
	</dd>

</dl>

		</section>
		<section id="url-rendering">
<h3 title="URL rendering">4.8. ~URLの描画-法</h3>

<p>
`~URL$の描画に際しては、`~URL直列化器$にかけた形に，以下の改変を加えるべきである：
◎
A URL should be rendered in its serialized form, with these modifications:
</p>

<ul>
	<li>
`~URL$の `~username$url, `~password$urlは、`~URL$の`~host$urlに~~誤認され易いので描画されるべきでない。
例えば，
<samp>https://examplecorp.com@attacker.example/</samp>
。
◎
A URL’s username and password should not be rendered as they can be mistaken for a URL’s host. E.g., consider https://examplecorp.com@attacker.example/.
</li>
	<li>
`~URL$の`~host$urlは、`~domainを~Unicode化する$を用いて描画されるべきである。
◎
A URL’s host should be rendered using domain to Unicode.
</li>
	<li>
`~URL$の他の部分における`~percent-符号化された~byte$並びは、それを`~percent-復号-$した結果の~byte列による~cpに置換されるべきである
— その結果が不可視になる場合は除いて。
◎
Other parts of the URL should have their sequences of percent-encoded bytes replaced with code points resulting from percent decoding those sequences converted to bytes, unless that renders those sequences invisible.
</li>
</ul>

<p class="trans-note">【
“描画（ `rendering^en ）” の原義には、音声化なども含まれる
— その場合の取り扱いは多少異なるものになるであろうが，同様の趣旨に従うことになる。
】</p>

<p>
双方向的~textの目的においては、左横書き埋め込み（ `left-to-right embedding^en ）であったかのように描画されるべきである。
`BIDI$r
◎
For the purposes of bidirectional text it should be rendered as if it were in a left-to-right embedding. [BIDI]
</p>

<p class="note">
あいにく、描画された`~URL$は，どこにでも現れるような文字列であり、描画される`~URL$に特有の双方向的~algoがあっても，広範に採用される見込みは薄いであろう。
双方向的~textによる~URLの各部への~~作用は、ここでの~modelと異なる描画にさせ得る。
したがって，双方向的~言語の利用者は、特に，素の~text環境の下では，このことについて予期しておくよう注意されたし。
◎
Unfortunately, as rendered URLs are strings and can appear anywhere, a specific bidirectional algorithm for rendered URLs would not see wide adoption. Bidirectional text interacts with the parts of a URL in ways that can cause the rendering to be different from the model. Users of bidirectional languages are thus cautioned that this is to be expected, particularly in plain text environments.
</p>

<p>
双方向的~textにおいては、`~URL$の`~host$urlと`~path$urlが，誤認され易くなる。
そのため，~browserには、利用者が この 2 つを判別できることが重要になる所では，
`~URL$の`~host$urlのみを描画することが奨励される。
例えば利用者は、~address~bar内に描画された`~URL$の`~host$urlに基いて，信用に関する裁定を下すものと予期されるので。
◎
Due to the confusion that can arise between a URL’s host and path with bidirectional text, browsers are encouraged to only render a URL’s host in places where it is important for users to distinguish between the two. E.g., users are expected to make trust decisions based on a URL’s host rendered in the address bar.
</p>

		</section>
	</section>
	<section id="application/x-www-form-urlencoded">
<h2 title="application/x-www-form-urlencoded">5. ~form_urlencoded</h2>


<p>
`~form_urlencoded形式@
は、一連の名値~組を符号化する仕方を供する。
◎
The application/x-www-form-urlencoded format provides a way to encode name-value pairs.
</p>

<p class="note">注記：
~form_urlencoded形式は、何年にもわたる実装の不幸な巡り合わせの結果，多くの面で奇異なものになっており、相互運用性のために必要とされる要件の集合からなる，妥協の産物である
— 良い設計の実施を表現する仕方は無い。
読者は特に、文字~符号化法と~byte列との間で繰り返される（場合によっては入子にされた）変換のひねくれた詳細に，注意を払うように。
あいにく，この形式は~HTML~formに普及しているがため、広く利用されている。
`HTML$r
◎
The application/x-www-form-urlencoded format is in many ways an aberrant monstrosity, the result of many years of implementation accidents and compromises leading to a set of requirements necessary for interoperability, but in no way representing good design practices. In particular, readers are cautioned to pay close attention to the twisted details involving repeated (and in some cases nested) conversions between character encodings and byte sequences. Unfortunately the format is in widespread use due to the prevalence of HTML forms. [HTML]
</p>

		<section id="urlencoded-parsing">
<h3 title="application/x-www-form-urlencoded parsing">5.1. ~form_urlencoded構文解析-法</h3>

<p class="note">注記：
旧来の~server向け実装には、`~UTF-8$以外の`符号化法$を~supportするとともに［
名 ~EQ `_charset^bl
<!-- _charset_？ -->
］なる組に対する特別な~logicを伴うものもある。
そのような~logicは、ここでは述べられない
— 適合するのは`~UTF-8$に限られる。
◎
A legacy server-oriented implementation might have to support encodings other than UTF-8 as well as have special logic for tuples of which the name is `_charset`. Such logic is not described here as only UTF-8 is conforming.
</p>

<p>
`~form_urlencoded構文解析器@
は、所与の
( ~byte列 %入力 )
に対し，次を走らす：
◎
The application/x-www-form-urlencoded parser takes a byte sequence input, and then runs these steps: 
</p>

<ol>
	<li>
%~byte列~list ~LET %入力 を `26^X `&amp;^smb で分割した結果
◎
Let sequences be the result of splitting input on 0x26 (&amp;).
</li>
	<li>%出力 ~LET 空`~list$（名, 値のいずれも文字列であるような，名値~組からなる~list）
◎
Let output be an initially empty list of name-value tuples where both name and value hold a string.
</li>
	<li>
<p>
%~byte列~list 内の
~EACH( %~byte列 )
に対し：
◎
For each byte sequence bytes in sequences:
</p>
		<ol>
			<li>
~IF［
%~byte列 ~EQ 空~byte列
］
⇒
~CONTINUE
◎
If bytes is the empty byte sequence, then continue.
</li>
			<li>
( %名, %値 ) ~LET ( %~byte列, 空~byte列 )
◎
↓</li>
			<li>
~IF［
%~byte列 内に ❛= がある
］
⇒
( %名, %値 ) ~SET  %~byte列 を最初の ❛= の所で 2 個の~byte列に分割した結果（その最初の ❛= は結果に含めない — したがって，いずれも空~byte列になり得る）
◎
If bytes contains a 0x3D (=), then let name be the bytes from the start of bytes up to but excluding its first 0x3D (=), and let value be the bytes, if any, after the first 0x3D (=) up to the end of bytes. If 0x3D (=) is the first byte, then name will be the empty byte sequence. If it is the last, then value will be the empty byte sequence.
◎
Otherwise, let name have the value of bytes and let value be the empty byte sequence.
</li>
			<li>
［
%名, %値
］内のすべての ❛+ を `20^X (SP) に置換する
◎
Replace any 0x2B (+) in name and value with 0x20 (SP).
</li>
			<li>
%名~文字列 ~LET `~BOMはそのままに~UTF-8復号する$( `~byte列を~byte列に~percent-復号する$( %名 ) ) 
◎
↓</li>
			<li>
%値~文字列 ~LET `~BOMはそのままに~UTF-8復号する$( `~byte列を~byte列に~percent-復号する$( %値 ) ) 
◎
Let nameString and valueString be the result of running UTF-8 decode without BOM on the percent decoding of name and value, respectively.
</li>
			<li>
%出力 に 組( %名~文字列, %値~文字列 ) を`付加する$
◎
Append (nameString, valueString) to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>


		</section>
		<section id="urlencoded-serializing">
<h3 title="application/x-www-form-urlencoded serializing">5.2. ~form_urlencoded直列化-法</h3>

<p class="algo-head">
`~form_urlencoded~byte直列化器@
は、所与の
( ~byte列 %入力 )
に対し，次を走らす：
◎
The application/x-www-form-urlencoded byte serializer takes a byte sequence input and then runs these steps:
</p>

<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
<p>
%入力 内の
~EACH( %~byte )
に対し
⇒
%出力 ~APPEND ［
%~byte に応じて次で与えられる文字列
］：
◎
For each byte in input, depending on byte:
</p>

		<dl class="switch">
			<dt>`20^X (SP)</dt>
			<dd>
❝+
◎
Append U+002B (+) to output.
</dd>

			<dt>❛*</dt>
			<dt>❛-</dt>
			<dt>❛.</dt>
			<dt>❛0 〜 ❛9</dt>
			<dt>❛A 〜 ❛Z</dt>
			<dt>❛_</dt>
			<dt>❛a 〜 ❛z</dt>
			<dd>
%~byte を値とする~cp
◎
Append a code point whose value is byte to output.
</dd>

			<dt>~OTHER</dt>
			<dd>
`~byteを文字列に~percent-符号化する$( %~byte )
◎
Append byte, percent encoded, to output.
</dd>

		</dl>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="algo-head">
`~form_urlencoded直列化器@
は、所与の
( 一連の［名値~組］からなる~list %組~list, `符号化法$ %上書符号化法（省略時は ε ） )
に対し，次を走らす：
◎
The application/x-www-form-urlencoded serializer takes a list of name-value tuples tuples, optionally with an encoding encoding override, and then runs these steps:
</p>

<ol>
	<li>
%符号化法 ~LET `~UTF-8$
◎
Let encoding be UTF-8.
</li>
	<li>
~IF［
%上書符号化法 ~NEQ ε
］
⇒
%符号化法 ~SET `符号化法から出力~符号化法を取得する$( %上書符号化法 )
◎
If encoding override is given, set encoding to the result of getting an output encoding from encoding override.
</li>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
<p>
%組~list 内の
~EACH( %組 )
に対し：
◎
For each tuple in tuples:
</p>
		<ol>
			<li>
%名 ~LET `~form_urlencoded~byte直列化器$( `符号化法を用いて符号化する$( %符号化法, %組 の名 ) )
◎
Let name be the result of serializing the result of encoding tuple’s name, using encoding.
</li>
			<li>
%値 ~LET %組 の値
◎
Let value be tuple’s value.
</li>
			<li>
~IF［
%値 は~fileである
］
⇒
%値 ~SET %値 の~filename成分
◎
If value is a file, then set value to value’s filename.
</li>
			<li>
%値 ~SET
`~form_urlencoded~byte直列化器$( `符号化法を用いて符号化する$( %符号化法, %値 ) )
◎
Set value to the result of serializing the result of encoding value, using encoding.
</li>
			<li>
~IF［
%組 は %組~list 内の最初の組でない
］
⇒
%出力 ~APPEND `0026^U `&amp;^smb
◎
If tuple is not the first pair in tuples, then append U+0026 (&amp;) to output.
</li>
			<li>
%出力
~APPEND %名
~APPEND ❝=
~APPEND %値
◎
Append name, followed by U+003D (=), followed by value, to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
`HTML$r は、組の値に~fileを伴う~listで この~algoを呼出す。
◎
The HTML standard invokes this algorithm with values that are files. [HTML]
</p>


		</section>
		<section id="urlencoded-hooks">

<h3 title="Hooks">5.3. ~hooks</h3>

<p class="algo-head">
`~form_urlencoded文字列~構文解析器@
は、所与の
( 文字列 %入力 )
に対し，次の結果を返す
⇒
`~form_urlencoded構文解析器$( `~UTF-8符号化する$( %入力 ) )
◎
The application/x-www-form-urlencoded string parser takes a string input, UTF-8 encodes it, and then returns the result of application/x-www-form-urlencoded parsing it.
</p>


		</section>
	</section>

	<section id="api">
<h2 title="API">6. ~API</h2>

		<section id="url-class">
<h3 title="URL class">6.1. `URL^I ~class</h3>

<pre class="idl">
[<a href="#dom-url-url">Constructor</a>(`USVString$ %url, optional `USVString$ %base),
 `Exposed$=(Window,Worker),
 `LegacyWindowAlias$=`webkitURL@]
interface `URL@I {
  `stringifier@m attribute `USVString$ `href$m;
  readonly attribute `USVString$ `origin$m;
           attribute `USVString$ `protocol$m;
           attribute `USVString$ `username$m;
           attribute `USVString$ `password$m;
           attribute `USVString$ `host$m;
           attribute `USVString$ `hostname$m;
           attribute `USVString$ `port$m;
           attribute `USVString$ `pathname$m;
           attribute `USVString$ `search$m;
  [`SameObject$] readonly attribute `URLSearchParams$I `searchParams$m;
           attribute `USVString$ `hash$m;

  `USVString$ `toJSON$m();
};
</pre>


<div class="p">
<p>
各 `URL$I ~objには、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~url@url</dt>
	<dd>
`~URL$
</dd>
	<dt>`~query~obj@url</dt>
	<dd>
`URLSearchParams$I ~obj
</dd>
</dl>

◎
A URL object has an associated url (a URL) and query object (a URLSearchParams object).
</div>

<hr id="constructors">

<p class="idl-def">
`URL(url, base)@m
構築子の被呼出時には、次を走らせ~MUST：
◎
The URL(url, base) constructor, when invoked, must run these steps:
</p>

<ol>
	<li>
%解析済み基底 ~LET ~NULL
◎
Let parsedBase be null.
</li>
	<li>
<p>
~IF［
%base は与えられている
］：
◎
If base is given, then:
</p>
		<ol>
			<li>
%解析済み基底 ~SET %base を`基本~URL構文解析器$にかけた結果
◎
Let parsedBase be the result of running the basic URL parser on base.
</li>
			<li>
~IF［
%解析済み基底 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parsedBase is failure, then throw a TypeError.
</li>
		</ol>
	</li>
	<li>
%解析済み~URL ~LET
次を与える下で， %url を`基本~URL構文解析器$にかけた結果
⇒
`基底~URL$ : %解析済み基底
◎
Let parsedURL be the result of running the basic URL parser on url with parsedBase.
</li>
	<li>
~IF［
%解析済み~URL ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parsedURL is failure, then throw a TypeError.
</li>
	<li>
%~query ~LET ［
%解析済み~URL の `~query$url ~NEQ ~NULL ならば それ ／
~ELSE_ 空~文字列
］
◎
Let query be parsedURL’s query, if that is non-null, and the empty string otherwise.
</li>
	<li>
%結果 ~LET 新たな `URL$I ~obj
◎
Let result be a new URL object.
</li>
	<li>
%結果 の`~url$url ~SET %解析済み~URL
◎
Set result’s url to parsedURL.
</li>
	<li>
%~obj ~SET `新たな~URLSearchParams~obj$( %~query )
◎
↓</li>
	<li>
%結果 の`~query~obj$url ~SET %~obj
◎
↓</li>
	<li>
%~obj の`~url~obj$ ~SET %結果
◎
Set result’s query object to a new URLSearchParams object using query, and then set that query object’s url object to result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<div class="example">

<p>
`基底~URL$を用いずに，文字列を<a href="#concept-basic-url-parser">構文解析して</a> `~URL$を得るときは、単独の引数で `URL$I 構築子を呼び出す：
◎
To parse a string into a URL without using a base URL, invoke the URL constructor with a single argument:
</p>

<pre>
var %input = `https://example.org/💩^l,
    %url = new URL(%input);
%url.pathname; // `/%F0%9F%92%A9^l
</pre>

<p>
次のものは、入力が`素片~付き絶対~URL$sTでない場合には，例外を投出する：
◎
This throws an exception if the input is not an absolute-URL-with-fragment string:
</p>

<pre>
try {
  var %url = new URL(`/🍣🍺^l);
} catch(%e) {
  // <span class="comment" title="that happened">ここに来る</span>
}
</pre>

<p>
入力が`相対~URL$sTの場合には、`基底~URL$が必要とされる：
◎
A base URL is necessary if the input is a relative-URL string:
</p>

<pre>
var %input = `/🍣🍺^l,
    %url = new URL(%input, document.baseURI);
%url.href; // `https://url.spec.whatwg.org/%F0%9F%8D%A3%F0%9F%8D%BA^l
</pre>

<p>
`URL$I ~objは`基底~URL$として利用できる（~IDLからは文字列を引数にとるよう要求されるが、 `URL$I ~objは，その `href$m 属性~値に文字列化される）：
◎
A URL object can be used as base URL (while IDL requires a string as argument, a URL object stringifies to its href attribute value):
</p>

<pre>
var %url = new URL(`🏳🌈^l, new URL(`https://pride.example/hello-world^l))
%url.pathname // `/%F0%9F%8F%B3%EF%B8%8F%E2%80%8D%F0%9F%8C%88^l
</pre>

</div>

<hr id="urlutils-members">

<dl class="idl-def">
	<dt>`toJSON()@m</dt>
	<dd>
被呼出時には、此れの `href$m の取得子と同じ結果を返さ~MUST。
◎
↓</dd>
	<dt>`href@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
</p>
		<ol>
			<li>
~RET `~URLを直列化する$( 此れの`~url$url )
</li>
		</ol>
◎
The href attribute’s getter and the toJSON() method, when invoked, must return the serialization of context object’s url.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The href attribute’s setter must run these steps:
</p>
		<ol>
			<li>
%解析済み~URL ~LET
所与の値を`基本~URL構文解析器$にかけた結果
◎
Let parsedURL be the result of running the basic URL parser on the given value.
</li>
			<li>
~IF［
%解析済み~URL ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parsedURL is failure, then throw a TypeError.
</li>
			<li>
此れの`~url$url ~SET %解析済み~URL
◎
Set context object’s url to parsedURL.
</li>
			<li>
此れの`~query~obj$urlの`名値~組~list$を空にする
◎
Empty context object’s query object’s list.
</li>
			<li>
%~query ~LET 此れの`~url$urlの`~query$url
◎
Let query be context object’s url’s query.
</li>
			<li>
~IF［
%~query ~NEQ ~NULL
］
⇒
此れの`~query~obj$urlの`名値~組~list$ ~SET `~form_urlencoded文字列~構文解析器$( %~query )
◎
If query is non-null, then set context object’s query object’s list to the result of parsing query.
</li>
		</ol>
	</dd>

	<dt>`origin@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~RET `生成元を直列化する$( 此れの`~url$urlの`生成元$url )
`HTML$r
</li>
		</ol>
◎
The origin attribute’s getter must return the serialization of context object’s url’s origin. [HTML]
</dd>

	<dt>`protocol@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~RET
空~文字列 ~APPEND 此れの`~url$urlの`~scheme$url
~APPEND ❝:
</li>
		</ol>
◎
The protocol attribute’s getter must return context object url’s scheme, followed by U+003A (:).
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
次を与える下で，［
所与の値 ~APPEND ❝:
］を`基本~URL構文解析器$にかける
⇒
`~URL$と上書stateの組： ( 此れの`~url$url, `~scheme開始-$st )
</li>
		</ol>
◎
The protocol attribute’s setter must basic URL parse the given value, followed by U+003A (:), with context object’s url as url and scheme start state as state override.
</dd>

	<dt>`username@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~RET 此れの`~url$urlの`~username$url
</li>
		</ol>
◎
The username attribute’s getter must return context object’s url’s username.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The username attribute’s setter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url は`~username／~password／~portを持てない$
］
⇒
~RET
◎
If context object’s url cannot have a username/password/port, then return.
</li>
			<li>
`~URLの~usernameを設定する$( %url, 所与の値 )
◎
Set the username given context object’s url and the given value.
</li>
		</ol>
	</dd>

	<dt>`password@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~RET 此れの`~url$urlの`~password$url
</li>
		</ol>
◎
The password attribute’s getter must return context object’s url’s password. 
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The password attribute’s setter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url は`~username／~password／~portを持てない$
］
⇒
~RET
◎
If context object’s url cannot have a username/password/port, then return.
</li>
			<li>
`~URLの~passwordを設定する$(  %url, 所与の値 )
◎
Set the password given context object’s url and the given value.
</li>
		</ol>
	</dd>

	<dt>`host@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The host attribute’s getter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
Let url be context object’s url.
</li>
			<li>
~IF［
%url の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If url’s host is null, return the empty string.
</li>
			<li>
%~host ~LET `~hostを直列化する$( `~host$url )
◎
↓</li>
			<li>
~IF［
%url の`~port$url ~EQ ~NULL
］
⇒
~RET %~host
◎
If url’s port is null, return url’s host, serialized.
</li>
			<li>
~RET %~host ~APPEND ❝:
~APPEND `整数を直列化する$( `~port$url )
◎
Return url’s host, serialized, followed by U+003A (:) and url’s port, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The host attribute’s setter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If context object’s url’s cannot-be-a-base-URL flag is set, then return.
</li>
			<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
`~URL$と上書stateの組： ( %url , `~host$st )
◎
Basic URL parse the given value with context object’s url as url and host state as state override.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
`host$m 属性の設定子に与える値が，`~URL~port$sTを欠いている場合、
%url の`~port$urlは変化しないことになる。
<!-- ＊This can be unexpected -->
`host^c 属性の取得子が`~URL~port$sTを返さないために、設定子が常に両者を “設定し直す” と見做してしまいそうだが。
◎
If the given value for the host attribute’s setter lacks a port, context object’s url’s port will not change. This can be unexpected as host attribute’s getter does return a URL-port string so one might have assumed the setter to always "reset" both.
</dd>

	<dt>`hostname@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The hostname attribute’s getter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If context object’s url’s host is null, return the empty string.
</li>
			<li>
~RET `~hostを直列化する$( %url の`~host$url )
◎
Return context object’s url’s host, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The hostname attribute’s setter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If context object’s url’s cannot-be-a-base-URL flag is set, then return.
</li>
			<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
`~URL$と上書stateの組： ( %url , `~hostname$st )
◎
Basic URL parse the given value with context object’s url as url and hostname state as state override.
</li>
		</ol>
	</dd>

	<dt>`port@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The port attribute’s getter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~port$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If context object’s url’s port is null, return the empty string.
</li>
			<li>
~RET `整数を直列化する$( %url の`~port$url )
◎
Return context object’s url’s port, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The port attribute’s setter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url は`~username／~password／~portを持てない$
］
⇒
~RET
◎
If context object’s url cannot have a username/password/port, then return.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%url の`~port$url ~SET ~NULL
◎
If the given value is the empty string, then set context object’s url’s port to null.
</li>
			<li>
~ELSE
⇒
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
`~URL$と上書stateの組： ( %url , `~port$st )
◎
Otherwise, basic URL parse the given value with context object’s url as url and port state as state override.
</li>
		</ol>
	</dd>

	<dt>`pathname@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The pathname attribute’s getter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET［
%url の`~path$url[0]
］
◎
If context object’s url’s cannot-be-a-base-URL flag is set, then return context object’s url’s path[0].
</li>
			<li>
%結果 ~LET 空~文字列
◎
If context object’s url’s path is empty, then return the empty string.
</li>
			<li>
%url の`~path$url内の
~EACH( %文字列 )
に対し
⇒
%結果 ~APPEND ❝/
~APPEND %文字列
◎
↓</li>
			<li>
~RET %結果
◎
Return U+002F (/), followed by the strings in context object’s url’s path (including empty strings), if any, separated from each other by U+002F (/).
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The pathname attribute’s setter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If context object’s url’s cannot-be-a-base-URL flag is set, then return.
</li>
			<li>
%url の`~path$urlを空にする
◎
Empty context object’s url’s path.
</li>
			<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
`~URL$と上書stateの組： ( %url , `~path開始-$st )
◎
Basic URL parse the given value with context object’s url as url and path start state as state override.
</li>
		</ol>
	</dd>

	<dt>`search@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The search attribute’s getter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~query$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If context object’s url’s query is either null or the empty string, return the empty string.
</li>
			<li>
~RET ［
❝? ~APPEND %url の`~query$url
］
◎
Return U+003F (?), followed by context object’s url’s query.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The search attribute’s setter must run these steps:
</p>
		<ol>
<li>
%url ~LET 此れの`~url$url
◎
Let url be context object’s url.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒＃
%url の`~query$url ~SET ~NULL；
此れの`~query~obj$urlの`名値~組~list$を空にする；
~RET
◎
If the given value is the empty string, set url’s query to null, empty context object’s query object’s list, and then return.
</li>
			<li>
%入力 ~LET 所与の値 — ただし，先頭 1 個の ❝? は（もし在れば）除去する
◎
Let input be the given value with a single leading U+003F (?) removed, if any.
</li>
			<li>
%url の`~query$url ~SET 空~文字列
◎
Set url’s query to the empty string.
</li>
			<li>
次を与える下で， %入力 を`基本~URL構文解析器$にかける
⇒
`~URL$と上書stateの組： ( %url, `~query$st )
◎
Basic URL parse input with url as url and query state as state override.
</li>
			<li>
此れの`~query~obj$urlの`名値~組~list$ ~SET `~form_urlencoded文字列~構文解析器$( %入力 )
◎
Set context object’s query object’s list to the result of parsing input.
</li>
		</ol>
	</dd>

	<dt>`searchParams@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~RET 此れの`~query~obj$url
</li>
		</ol>
◎
The searchParams attribute’s getter must return context object’s query object.
</dd>

	<dt>`hash@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The hash attribute’s getter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`素片$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If context object’s url’s fragment is either null or the empty string, return the empty string.
</li>
			<li>
~RET ［
❝# ~APPEND %url の`素片$url
］
◎
Return U+0023 (#), followed by context object’s url’s fragment.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The hash attribute’s setter must run these steps:
</p>
		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
%入力 ~LET 所与の値
◎
↓</li>
			<li>
~IF［
%入力 ~EQ 空~文字列
］
⇒＃
%url の`素片$url ~SET ~NULL；
~RET
◎
If the given value is the empty string, then set context object’s url’s fragment to null and return.
</li>
			<li>
~IF［
%入力 の先頭の文字 ~EQ ❝#
］
⇒
%入力 から先頭の文字を除去する
◎
Let input be the given value with a single leading U+0023 (#) removed, if any.
</li>
			<li>
%url の`素片$url ~SET 空~文字列
◎
Set context object’s url’s fragment to the empty string.
</li>
			<li>
次を与える下で， %入力 を`基本~URL構文解析器$にかける
⇒
`~URL$と上書stateの組： ( %url , `素片$st )
◎
Basic URL parse input with context object’s url as url and fragment state as state override.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="interface-urlsearchparams">
<h3 title="URLSearchParams class">6.2. `URLSearchParams^I ~class</h3>

<pre class="idl">
[<a href="#dom-urlsearchparams-urlsearchparams">Constructor</a>(optional (`sequence$&lt;`sequence$&lt;`USVString$&gt;&gt; or `record$&lt;`USVString$, `USVString$&gt; or `USVString$) %init = ""),
`Exposed$=(Window,Worker)]
interface `URLSearchParams@I {
  void `append$m(`USVString$ %name, `USVString$ %value);
  void `delete$m(`USVString$ %name);
  `USVString$? `get$m(`USVString$ %name);
  `sequence$&lt;`USVString$&gt; `getAll$m(`USVString$ %name);
  `boolean$ `has$m(`USVString$ %name);
  void `set$m(`USVString$ %name, `USVString$ %value);

  void `sort$m();

  iterable&lt;`USVString$, `USVString$&gt;;
  `stringifier$m;
};
</pre>

<div class="example" id="example-constructing-urlsearchparams">
<p>
`URLSearchParams$I ~objを構築する／文字列化するのは、簡単である：
◎
Constructing and stringifying a URLSearchParams object is fairly straightforward:
</p>

<pre >
let %params = new URLSearchParams({key: "730d67"})
%params.toString() // `key=730d67^l
</pre>
</div>

<p>
各 `URLSearchParams$I ~objには、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`名値~組~list@</dt>
	<dd>
0 個以上の名値~組からなる~list（初期~時は空）
◎
A URLSearchParams object has an associated list of name-value pairs, which is initially empty.
</dd>
	<dt>`~url~obj@</dt>
	<dd>
（初期~時は ~NULL ）
◎
A URLSearchParams object has an associated url object, which is initially null.
</dd>
</dl>

<p class="algo-head">
`新たな~URLSearchParams~obj@
を作成するときは、所与の
( %init ) 
に対し，次を走らす：
◎
To create a new URLSearchParams object using init, run these steps:
</p>

<ol>
	<li>
%~query ~LET 新たな `URLSearchParams$I ~obj
◎
Let query be a new URLSearchParams object.
</li>
	<li>
<p>
~IF［
%init は`連列~型$である
］：
◎
If init is a sequence, then＼
</p>
		<ol>
			<li>
<p>
%init 内の
~EACH( %組 )
に対し：
◎
for each pair in init:
</p>
				<ol>
					<li>
~IF［
%組 内の~itemの個数 ~NEQ 2
］
⇒
~THROW `TypeError$E
◎
If pair does not contain exactly two items, then throw a TypeError.
</li>
					<li>
%~query の`名値~組~list$に，新たな
組( %組 内の 1 個目の~item, %組 内の 2 個目の~item )
を付加する
◎
Append a new name-value pair whose name is pair’s first item, and value is pair’s second item, to query’s list.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~ELIF［
%init は`~record型$である
］
⇒
%init 内の
~EACH( %名 → %値 )
に対し
⇒
%~query の`名値~組~list$に，新たな
組( %名, %値 )
を付加する
◎
Otherwise, if init is a record, then for each name → value in init, append a new name-value pair whose name is name and value is value, to query’s list.
</li>
	<li>
~ELIF［
%init は文字列である
］
⇒
%~query の`名値~組~list$ ~SET `~form_urlencoded文字列~構文解析器$( %init )
◎
Otherwise, init is a string, then set query’s list to the result of parsing init.
</li>
	<li>
~RET %~query
◎
Return query.
</li>
</ol>


<p class="algo-head">
`URLSearchParams$I ~obj %O の
`更新~手続き@
は、次を走らす：
◎
A URLSearchParams object’s update steps are to run these steps:
</p>

<ol>
	<li>
%~query ~LET `~form_urlencoded直列化器$( %O の`名値~組~list$ )
◎
Let query be the serialization of URLSearchParams object’s list.
</li>
	<li>
%O の`~url~obj$の`~url$urlの`~query$url ~SET［
%~query ~EQ 空~文字列 ならば ~NULL ／
~ELSE_ %~query
］
◎
If query is the empty string, then set query to null.
◎
Set url object’s url’s query to query.
</li>
</ol>


<dl class="idl-def">
	<dt>`URLSearchParams(init)@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
◎
The URLSearchParams(init) constructor, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%init の最初の~cp ~EQ ❝?
］
⇒
%init から最初の~cpを除去する
◎
If init is a string and starts with U+003F (?), remove the first code point from init.
</li>
			<li>
~RET `新たな~URLSearchParams~obj$( %init )
◎
Return a new URLSearchParams object using init.
</li>
		</ol>
	</dd>

	<dt>`append(name, value)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The append(name, value) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
此れの`名値~組~list$に，新たな組( %name, %value ) を付加する
◎
Append a new name-value pair whose name is name and value is value, to list.
</li>
			<li>
`更新~手続き$を走らす
◎
Run the update steps.
</li>
		</ol>
	</dd>

	<dt>`delete(name)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The delete(name) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
此れの`名値~組~list$から［
名 ~EQ %name
］なるすべての組を除去する
◎
Remove all name-value pairs whose name is name from list.
</li>
			<li>
`更新~手続き$を走らす
◎
Run the update steps.
</li>
		</ol>
	</dd>

	<dt>`get(name)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>
		<ol>
			<li>
~RET 此れの`名値~組~list$内に［
名 ~EQ %name
］なる組が［
在れば それらのうちの最初の組の値 ／
無ければ ~NULL
］
</li>
		</ol>
◎
The get(name) method, when invoked, must return the value of the first name-value pair whose name is name in list, if there is such a pair, and null otherwise.
</dd>

	<dt>`getAll(name)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>
		<ol>
			<li>
~RET 此れの`名値~組~list$内の［
名 ~EQ %name
］なる組すべてからなる，~list順による`連列~型$の値（空にもなり得る）
</li>
		</ol>

◎
The getAll(name) method, when invoked, must return the values of all name-value pairs whose name is name, in list, in list order, and the empty sequence otherwise.
</dd>

	<dt>`has(name)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>
		<ol>
			<li>
~RET 此れの`名値~組~list$内に［
名 ~EQ %name
］なる組が［
在れば ~T ／
無ければ ~F
］
</li>
		</ol>

◎
The has(name) method, when invoked, must return true if there is a name-value pair whose name is name in list, and false otherwise.
</dd>

	<dt>`set(name, value)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The set(name, value) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れの`名値~組~list$内に［
名 ~EQ %name
］なる組が在る
］
⇒
それらのうちの
⇒＃
最初の組の値 ~SET %value；
最初でない組はすべて此れの`名値~組~list$から除去する
◎
If there are any name-value pairs whose name is name, in list, set the value of the first such name-value pair to value and remove the others.
</li>
			<li>
~ELSE
⇒
此れの`名値~組~list$に，新たな組 ( %name, %value ) を付加する
◎
Otherwise, append a new name-value pair whose name is name and value is value, to list.
</li>
			<li>
`更新~手続き$を走らす
◎
Run the update steps.
</li>
		</ol>
	</dd>

</dl>

<hr>

<div class="example" id="example-searchparams-sort">

<p>
`URLSearchParams$I ~obj内の名値~組を~sortすると有用になることもある
— 特に，~cache-hit率を高めれる。
これは、 `sort()$m ~methodを呼出すことで達成できる：
◎
It can be useful to sort the name-value pairs in a URLSearchParams object, in particular to increase cache hits. This can be accomplished through invoking the sort() method:
</p>

<pre>
const %url = new URL("https://example.org/?q=🏳️‍🌈&key=e1f7bc78");
%url.searchParams.sort();
%url.search; // `?key=e1f7bc78&q=%F0%9F%8F%B3%EF%B8%8F%E2%80%8D%F0%9F%8C%88^l
</pre>

<p>
例えば比較~目的など，元の入力を改めたくない場合は、新たな `URLSearchParams$I ~objを構築する：
◎
To avoid altering the original input, e.g., for comparison purposes, construct a new URLSearchParams object:
</p>

<pre>
const %sorted = new URLSearchParams(%url.search)
%sorted.sort()
</pre>

</div>

<dl class="idl-def">
	<dt>`sort()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The sort() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
<p>
此れの`名値~組~list$内の すべての組を，名で~sortする
— ここで：
</p>

<ul><li>名の比較は符号単位に基づくとする。
</li><li>名が等しい組どうしの順序は保全され~MUST。
</li></ul>

◎
Sort all name-value pairs, if any, by their names. Sorting must be done by comparison of code units. The relative order between name-value pairs with equal names must be preserved.
</li>
			<li>
`更新~手続き$を走らす
◎
Run the update steps.
</li>
		</ol>
	</dd>

	<dt>`反復される値の~pair$</dt>
	<dd>
此れの`名値~組~list$で与えられ、その各
( 名, 値 )
が，反復される値の
( key, value )
に対応するとする。
◎
The value pairs to iterate over are the list name-value pairs with the key being the name and the value being the value.
</dd>

	<dt>`stringifier@m</dt>
	<dd>
`文字列化の挙動$は、次の結果を返さ~MUST
⇒
`~form_urlencoded直列化器$( 此れの`名値~組~list$ )
◎
The stringification behavior must return the serialization of the URLSearchParams object’s list.
</dd>
</dl>

		</section>
		<section id="url-apis-elsewhere">
<h3 title="URL APIs elsewhere">6.3. 他の仕様における~URL~API</h3>

<p>
`~URL$を公開する標準は、`~URL$を（内部的な`~URL$は`~URL直列化器$にかけるなどして）文字列として公開するべきである。
標準は、`URL$I ~objを用いて`~URL$を公開するべきでない。
`URL$I ~objは、`~URL$を操作するためにある。
~IDLにおいては、 `USVString^I 型が利用されるべきである。
◎
A standard that exposes URLs, should expose the URL as a string (by serializing an internal URL). A standard should not expose a URL using a URL object. URL objects are meant for URL manipulation. In IDL the USVString type should be used.
</p>

<p class="note">注記：
より高次の観点からは、それらの値は，変異-不能な~data構造として公開されるものになる。
◎
The higher-level notion here is that values are to be exposed as immutable data structures.
</p>

<p>
標準が，それが定義する特色機能に `URL^l という名前の変種を用いるものと裁定する場合、その種の特色機能には `url^l （すなわち，小文字, 末尾は “エル” ）と命名するべきであり、 `URL^l, `URI^l, `IRI^l などの名前は用いられるべきでない。
しかしながら，その名前が複合的なものである場合は、大文字の `URL^l が好ましい
— `newURL^l や `oldURL^l など。
◎
If a standard decides to use a variant of the name "URL" for a feature it defines, it should name such a feature "url" (i.e., lowercase and with an "l" at the end). Names such as "URL", "URI", and "IRI" should not be used. However, if the name is a compound, "URL" (i.e., uppercase) is preferred, e.g., "newURL" and "oldURL".
</p>

<p class="note">注記：
適正な命名~例としては、~HTMLの `EventSource$I や `HashChangeEvent$I ~interfaceが挙げられる。
`HTML$r
◎
The EventSource and HashChangeEvent interfaces in HTML are examples of proper naming. [HTML]
</p>



		</section>
	</section>

</main></div><!-- id="MAIN" -->

	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り，たくさんの方々が
<a href="#concept-url">URL</a>
を相互運用可能にするために助力され、この標準~の目標へ近付けてきた。
同様に多くの方々からの助力により，この標準は現在の姿に仕立て上げられてきた：
<span lang="en">
There have been a lot of people that have helped make URLs more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</span></p>

<div lang="en-x-a0">
<p>
With that, many thanks to

<span lang="ja">100の人</span>,
Adam Barth,
Addison Phillips,
Albert Wiersch,
Alex Christensen,
Alexandre Morgaut,
Andrew Sullivan,
Arkadiusz Michalski,
Behnam Esfahbod,
Bobby Holley,
Boris Zbarsky,
Brad Hill,
Brandon Ross,
Chris Dumez,
Chris Rebert,
Corey Farwell,
Dan Appelquist,
Daniel Bratell,
Daniel Stenberg,
David Burns,
David Håsäther,
David Sheets,
David Singer,
David Walp,
Domenic Denicola,
Erik Arvidsson,
Gavin Carothers,
Geoff Richards,
Glenn Maynard,
Gordon P. Hemsley,
Henri Sivonen,
Ian Hickson,
Ilya Grigorik,
Italo A. Casas,
Jakub Gieryluk,
James Graham,
James Manger,
James Ross,
Jeffrey Posnick,
Jeffrey Yasskin,
Joe Duarte,
Joshua Bell,
Jxck,
<span lang="ja">田村健人</span> (Kent TAMURA),
Kevin Grandon,
Kornel Lesiński,
Larry Masinter,
Leif Halvard Silli,
Mark Davis,
Marcos Cáceres,
Martin Dürst,
Mathias Bynens,
Michael Peick,
Michael™ Smith,
Michal Bukovský,
Michel Suignard,
Noah Levitt,
Peter Occil,
Philip Jägenstedt,
Philippe Ombredanne,
Prayag Verma,
Rimas Misevičius,
Robert Kieffer,
Rodney Rehm,
Roy Fielding,
Ryan Sleevi,
Sam Ruby,
Santiago M. Mola,
Sebastian Mayr,
Simon Pieters,
Simon Sapin,
Steven Vachon,
Stuart Cook,
Sven Uhlig,
Tab Atkins,
<span lang="ja">吉野剛史</span> (Takeshi Yoshino),
Tantek Çelik,
Tiancheng "Timothy" Gu,
Tim Berners-Lee,
<span lang="zh">簡冠庭</span> (Tim Guan-tin Chien),
Titi_Alone,
Tomek Wytrębowicz,
Trevor Rowbotham,
Valentin Gosu,
Vyacheslav Matva,
Wei Wang,
<span lang="ja">山岸和利</span> (Yamagishi Kazutoshi), and
<span lang="ja">成瀬ゆい</span> (Yui Naruse)

for being awesome!
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>

<p>
Copyright © 2018 WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.
</p>

</div>


	</section>
