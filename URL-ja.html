<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>URL Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
.bytes, 
.literal,
.char-symbol {
	color: var(--literal-color-2);
}

.validation-error,
.parser-state {
	font-family: sans-serif0, sans-serif;
}

#_combi-host-types {
	writing-mode: vertical-rl;
}
</style>

<style>
/* table 用 */
@supports (grid-template-columns: subgrid) and (display: contents) {

#_error-types {
	grid-template-columns: 4em 20em 1fr;
	min-width: 32em;
	max-width: 52em;
	tr {
		grid-template-areas:
			"種別 種別 失敗"
			". 記述 記述"
			". 例 例"
		;
		> *:nth-child(1) {
			grid-area: 種別;
			border-left-width: 0;
		}
		> th[colspan]{
			grid-area: 種別 / span 3;
		}
		> *:nth-child(2) {
			grid-area: 記述;
		}
		> *:nth-child(3) {
			grid-area: 例;
		}
		> *:nth-child(4) {
			grid-area: 失敗;
		}
	}
}

#_ex-percent-enc-dec {
	grid-template-columns: 4em 12em 1fr;
	min-width: 32em;
	max-width: 52em;
	tr {
		border-bottom: none;
		grid-template-areas:
			"演算 演算 演算"
			". 入力 出力"
		;
		/* 1 列目に rowspan が利用されているので :nth-last-child を利用 */
		> *:nth-last-child(3) {
			grid-area: 演算;
			border-left-width: 0;
		}
		> *:nth-last-child(2) {
			grid-area: 入力;
		}
		> *:nth-last-child(1) {
			grid-area: 出力;
		}
	}
}


#_ex-roundtrip {
	grid-template-columns: 14em 1fr;
	min-width: 32em;
	max-width: 52em;
	tr {
		grid-template-areas:
			"入力 出力1"
			". 出力2"
		;
		> *:nth-child(1) {
			grid-area: 入力;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: 出力1;
		}
		> *:nth-child(3) {
			grid-area: 出力2;
		}
	}
}


#_ex-suffix-domain {
	grid-template-columns: 4em 1fr 1fr;
	min-width: 20em;
	max-width: 36em;
	tr {
		grid-template-areas:
			"入力 入力 入力"
			". 接尾辞 ドメイン"
		;
		> *:nth-child(1) {
			grid-area: 入力;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: 接尾辞;
		}
		> *:nth-child(3) {
			grid-area: ドメイン;
		}
	}
}


#_ex-url-validity {
	grid-template-columns: 4em 1fr 6em;
	min-width: 30em;
	max-width: 40em;
	tr {
		grid-template-areas:
			"入力 入力 妥当性"
			". 基底 基底"
			". 出力 出力"
		;
		> *:nth-child(1) {
			grid-area: 入力;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: 基底;
			min-height: 1.5em;
		}
		> *:nth-child(3) {
			grid-area: 妥当性;
		}
		> *:nth-child(4) {
			grid-area: 出力;
		}
	}
}


#_ex-url-components {
	grid-template-columns: 4em 1fr 1fr 1fr;
	min-width: 36em;
	max-width: 52em;
	tr {
		grid-template-areas:
			"入力 入力 入力 入力"
			". scheme host port"
			". path query fragment"
		;
		> * {
			min-width: 12em;
		}
		> *:nth-child(1) {
			grid-area: 入力;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: scheme;
		}
		> *:nth-child(3) {
			grid-area: host;
		}
		> *:nth-child(4) {
			grid-area: port;
		}
		> *:nth-child(5) {
			grid-area: path;
		}
		> *:nth-child(6) {
			grid-area: query;
		}
		> *:nth-child(7) {
			grid-area: fragment;
		}
	}
}
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
/[❝❛].|%[~\w\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	if(match[0] === '%'){
		return `<var>${match.slice(1)}</var>`;
	}
	// [❝❛].
	const cp = match.charCodeAt(1).toString(16).toUpperCase();
	const smb = ` (<span class="char-symbol">&#x${cp};</span>)`;
	const val = (match[0] === '❝') ?
		`<span class="code-point">U+${('000'+cp).slice(-4)}</span>` :
		`<span class="hex-value">0x${cp}</span>`
	;
	return `${val}${smb}`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="bytes">${text}</code>\``;
	break;
case 'sT':
	text += `<small>文字列</small>`;
	break;
case 'U':
	text = `U+${text}`;
	break;
case 'X':
	text = `0x${text}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'st':
	text += ' <small>state</small>';
	break;
case 'mc':
	text = 'constructor';
	klass = 'm';
	key = `new ${key}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:URL
spec_date:2025-03-05
trans_update:2025-03-05
source_checked:241202
spec_status:LS
original_url:https://url.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:network,security,html
copyright:,whatwg
trans_1st_pub:2012-10-20


●●class_map
E:error
st:parser-state
U:code-point
X:hex-value
AO:abstract
cn:cp-name
err:validation-error

●●tag_map
I:code
m:code
E:code
c:code
st:span
V:var
U:span
X:span
AO:span
i:i
err:i
cite:cite
cn:span

●●original_id_map

dom-urlsearchparams-iterable:
dom-urlsearchparams-stringifier:urlsearchparams-stringification-behavior
dom-url-stringifier:url-stringification-behavior

●●mdn_urls
url:API/URL
urlsearchparams:API/URLSearchParams

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject
LegacyWindowAlias:~WEBIDLjs#LegacyWindowAlias

webkitURL:#webkiturl

E.TypeError:~WEBIDL#exceptiondef-typeerror

undefined:~WEBIDL#idl-undefined
USVString:~WEBIDL#idl-USVString
boolean:~WEBIDL#idl-boolean
unsigned long:~WEBIDL#idl-unsigned-long
sequence:~WEBIDL#idl-sequence
record:~WEBIDL#idl-record

I.URL:#url
I.URLSearchParams:#urlsearchparams
	m.xxXx#dom-url-xxxx
	m.xxXx#dom-urlsearchparams-xxxx
I.EventSource:~HTMLsse#eventsource
I.HashChangeEvent:~WINDOW#hashchangeevent
I.Location:~WINDOW#location

m.~protocol0:~WINDOW#dom-location-protocol
m.registerProtocolHandler:~HTMLnavigator#dom-navigator-registerprotocolhandler
m.encodeURIComponent:~TC39#sec-encodeuricomponent-uricomponent

m.new URL:#dom-url-url
m.parse:#dom-url-parse
m.canParse:#dom-url-canparse
m.href:#dom-url-href
m.origin:#dom-url-origin
m.protocol:#dom-url-protocol
m.username:#dom-url-username
m.password:#dom-url-password
m.host:#dom-url-host
m.hostname:#dom-url-hostname
m.port:#dom-url-port
m.pathname:#dom-url-pathname
m.search:#dom-url-search
m.searchParams:#dom-url-searchparams
m.hash:#dom-url-hash
m.toJSON:#dom-url-tojson

m.new URLSearchParams:#dom-urlsearchparams-urlsearchparams
m.append:#dom-urlsearchparams-append
m.delete:#dom-urlsearchparams-delete
m.get:#dom-urlsearchparams-get
m.getAll:#dom-urlsearchparams-getall
m.has:#dom-urlsearchparams-has
m.set:#dom-urlsearchparams-set
m.size:#dom-urlsearchparams-size
m.sort:#dom-urlsearchparams-sort
m.iterable:#dom-urlsearchparams-iterable
m.stringifier:#dom-urlsearchparams-stringifier

	● 構文解析器
検証~error:#validation-error
~pointer:#pointer
V.C:#c
V.C1:#c1
V.C2:#c2
整数を直列化する:#serialize-an-integer
i.EOF:#eof-code-point
i.素片は除外する:#url-serializer-exclude-fragment
	素片は除外する:#url-equals-exclude-fragments

	~URL:#basic-url-parser-url
	上書state:#basic-url-parser-state-override


	● percent
~C0制御文字~percent-符号化-集合:#c0-control-percent-encode-set
素片~percent-符号化-集合:#fragment-percent-encode-set
~query~percent-符号化-集合:#query-percent-encode-set
特別~query~percent-符号化-集合:#special-query-percent-encode-set
~path~percent-符号化-集合:#path-percent-encode-set
~userinfo~percent-符号化-集合:#userinfo-percent-encode-set
成分~percent-符号化-集合:#component-percent-encode-set
~form_urlencoded~percent-符号化-集合:#application-x-www-form-urlencoded-percent-encode-set

~percent-符号化された~byte:#percent-encoded-byte

~byteを文字列に~percent-符号化する:#percent-encode
~byte列を~byte列に~percent-復号する:#percent-decode
~cpを~UTF-8~percent-符号化する:#utf-8-percent-encode
文字列を~UTF-8~percent-符号化する:#string-utf-8-percent-encode
文字列を~byte列に~percent-復号する:#string-percent-decode
文字列を符号化してから~percent-符号化する:#string-percent-encode-after-encoding

	● host

~host:#concept-host
~host構文解析器:#concept-host-parser
~hostを直列化する:#concept-host-serializer
~host直列化器:#concept-host-serializer
不透明な~host:#opaque-host
空~host:#empty-host
不透明な~host構文解析器:#concept-opaque-host-parser
禁止~host~cp:#forbidden-host-code-point
禁止~domain~cp:#forbidden-domain-code-point
同等な~host:#concept-host-equals

sT.妥当な~host:#valid-host-string
sT.妥当な~domain:#valid-domain-string
sT.妥当な~IPv4~address:#valid-ipv4-address-string
sT.妥当な~IPv6~address:#valid-ipv6-address-string
sT.妥当な不透明な~host:#valid-opaque-host-string
sT.不透明な~host＆~port:#opaque-host-and-port-string

妥当な~domain:#valid-domain
~domain:#concept-domain
~domain~label群:#domain-label
~domain~label:#domain-label
~domainを~ASCII化する:#concept-domain-to-ascii
~domainを~Unicode化する:#concept-domain-to-unicode

~IP~address:#ip-address

~IPv4~address:#concept-ipv4
~IPv4構文解析器:#concept-ipv4-parser
~IPv4番号~構文解析器:#ipv4-number-parser
~IPv4直列化器:#concept-ipv4-serializer

番号で終端しているか検査する:#ends-in-a-number-checker

~IPv6~address:#concept-ipv6
~IPv6構文解析器:#concept-ipv6-parser
~piece群:#concept-ipv6-piece
~IPv6直列化器:#concept-ipv6-serializer
~IPv6~addressの圧縮された~piece~indexを見出す:#find-the-ipv6-address-compressed-piece-index

公共~接尾辞:#host-public-suffix
登録-可能な~domain:#host-registrable-domain

	● URL
~URL:#concept-url
~URL~record:#concept-url
url.生成元:#concept-url-origin
url.素片:#concept-url-fragment
url.~host:#concept-url-host
url.~username:#concept-url-username
url.~password:#concept-url-password
url.~path:#concept-url-path
url.~port:#concept-url-port
url.~query:#concept-url-query
url.~scheme:#concept-url-scheme
url.~blob~URL~entry:#concept-url-blob-entry

基本~URL構文解析器:#concept-basic-url-parser
~URL構文解析器:#concept-url-parser
~URL構文解析する:#concept-url-parser
~API用に~URL構文解析する:#_api-url-parser
~URL直列化器:#concept-url-serializer
~URLを直列化する:#concept-url-serializer
~URL~pathを直列化する:#url-path-serializer
同等な~URL:#concept-url-equals
~pathを短縮する:#shorten-a-urls-path

基底~URL:#concept-base-url

特別~scheme:#special-scheme
特別:#is-special
	特別でない:#is-not-special
既定~port:#default-port

資格証を含んで:#include-credentials
不透明な~path:#url-opaque-path
~URLの~usernameを設定する:#set-the-username
~URLの~passwordを設定する:#set-the-password
~username／~password／~portを有し得ない:#cannot-have-a-username-password-port

~URL~path:#url-path
~URL~path区分:#url-path-segment
二重-~dot~URL~path区分:#double-dot-path-segment
単-~dot~URL~path区分:#single-dot-path-segment

sT.妥当な~URL:#valid-url-string
sT.絶対~URL:#absolute-url-string
sT.素片~付き絶対~URL:#absolute-url-with-fragment-string
sT.素片~付き相対~URL:#relative-url-with-fragment-string
sT.~URL~scheme:#url-scheme-string
sT.相対~URL:#relative-url-string
sT.~scheme相対~URL:#scheme-relative-url-string
sT.~scheme相対~特別~URL:#scheme-relative-special-url-string
sT.~scheme相対~file~URL:#scheme-relative-file-url-string
sT.~path絶対 非 Windows file ~URL:#path-absolute-non-windows-file-url-string
sT.~URL~port:#url-port-string
sT.~path絶対~URL:#path-absolute-url-string
sT.~path相対~URL:#path-relative-url-string
sT.~path相対 ~schemeなし~URL:#path-relative-scheme-less-url-string
sT.~URL~path区分:#url-path-segment-string
sT.~URL~query:#url-query-string
sT.~URL素片:#url-fragment-string

~drive_letter:#windows-drive-letter
正規化-済み~drive_letter:#normalized-windows-drive-letter
~drive_letterから開始して:#start-with-a-windows-drive-letter

~URL単位:#url-units
~URL単位かどうか検証する:#_validate-if-url-unit
~URL~cp:#url-code-points


	● URL 構文解析器

st.~scheme開始:#scheme-start-state
st.~scheme:#scheme-state
st.~schemeなし:#no-scheme-state
st.特別 相対/権限:#special-relative-or-authority-state
st.~path/権限:#path-or-authority-state
st.相対:#relative-state
st.相対~slash:#relative-slash-state
st.特別 権限~slash:#special-authority-slashes-state
st.特別 権限~slash無視:#special-authority-ignore-slashes-state
st.権限:#authority-state
st.~host:#host-state
st.~hostname:#hostname-state
st.~file~host:#file-host-state
st.~file:#file-state
st.~file~slash:#file-slash-state
st.~port:#port-state
st.~path開始:#path-start-state
st.~path:#path-state
st.不透明~path:#cannot-be-a-base-url-path-state
st.~query:#query-state
st.素片:#fragment-state

	● err
err.domain-to-ASCII:#validation-error-domain-to-ascii
err.domain-to-Unicode:#domain-to-unicode
err.domain-invalid-code-point:#domain-invalid-code-point
err.host-invalid-code-point:#host-invalid-code-point
err.IPv4-empty-part:#ipv4-empty-part
err.IPv4-too-many-parts:#ipv4-too-many-parts
err.IPv4-non-numeric-part:#ipv4-non-numeric-part
err.IPv4-non-decimal-part:#ipv4-non-decimal-part
err.IPv4-out-of-range-part:#ipv4-out-of-range-part
err.IPv6-unclosed:#ipv6-unclosed
err.IPv6-invalid-compression:#ipv6-invalid-compression
err.IPv6-too-many-pieces:#ipv6-too-many-pieces
err.IPv6-multiple-compression:#ipv6-multiple-compression
err.IPv6-invalid-code-point:#ipv6-invalid-code-point
err.IPv6-too-few-pieces:#ipv6-too-few-pieces
err.IPv4-in-IPv6-too-many-pieces:#ipv4-in-ipv6-too-many-pieces
err.IPv4-in-IPv6-invalid-code-point:#ipv4-in-ipv6-invalid-code-point
err.IPv4-in-IPv6-out-of-range-part:#ipv4-in-ipv6-out-of-range-part
err.IPv4-in-IPv6-too-few-parts:#ipv4-in-ipv6-too-few-parts
err.invalid-URL-unit:#invalid-url-unit
err.special-scheme-missing-following-solidus:#special-scheme-missing-following-solidus
err.missing-scheme-non-relative-URL:#missing-scheme-non-relative-url
err.invalid-reverse-solidus:#invalid-reverse-solidus
err.invalid-credentials:#invalid-credentials
err.host-missing:#host-missing
err.port-out-of-range:#port-out-of-range
err.port-invalid:#port-invalid
err.file-invalid-Windows-drive-letter:#file-invalid-windows-drive-letter
err.file-invalid-Windows-drive-letter-host:#file-invalid-windows-drive-letter-host

	● API
URL.~URL:#concept-url-url
URL.~query~obj:#concept-url-query-object
~URL~objを初期化する:#url-initialize
~API~URL構文解析器:#api-url-parser

USP.~URL~obj:#concept-urlsearchparams-url-object
USP.~parameter~list:#concept-urlsearchparams-list
~query~objを初期化する:#urlsearchparams-initialize
~query~objを更新する:#concept-urlsearchparams-update
~query~parameter:#_concept-query-parameter

~form_urlencoded形式:#concept-urlencoded
~form_urlencoded文字列~構文解析器:#concept-urlencoded-string-parser
~form_urlencoded構文解析器:#concept-urlencoded-parser
~form_urlencoded直列化器:#concept-urlencoded-serializer
~form_urlencoded~byte直列化器:#concept-urlencoded-byte-serializer

不透明な~pathならば その末尾にある~space列を剥ぐ:#potentially-strip-trailing-spaces-from-an-opaque-path

	●INFRA
16 ~bitな無符号~整数:~INFRA#16-bit-unsigned-integer
32 ~bitな無符号~整数:~INFRA#32-bit-unsigned-integer
128 ~bitな無符号~整数:~INFRA#128-bit-unsigned-integer
~byte:~INFRA#byte
~byte列:~INFRA#byte-sequence
byte.値:~INFRA#byte-value
byte.長さ:~INFRA#byte-sequence-length
文字列:~INFRA#string
長さ:~INFRA#string-length
から開始して:~INFRA#string-starts-with
~cp:~INFRA#code-point
~cp長さ:~INFRA#string-code-point-length
cp.値:~INFRA#code-point-value
~surrogate:~INFRA#surrogate
非文字:~INFRA#noncharacter
終端までを成す~cp部分文字列:~INFRA#code-point-substring-to-the-end-of-the-string
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII~cp:~INFRA#ascii-code-point
~ASCII~byte:~INFRA#ascii-byte
~ASCII英字:~INFRA#ascii-alpha
~ASCII英数字:~INFRA#ascii-alphanumeric
~ASCII数字:~INFRA#ascii-digit
~ASCII~hex数字:~INFRA#ascii-hex-digit
~ASCII~hex数字（大文字）:~INFRA#ascii-upper-hex-digit
~ASCII文字列:~INFRA#ascii-string
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII~tabや~ASCII改行文字:~INFRA#ascii-tab-or-newline
~C0制御文字:~INFRA#c0-control
~C0制御文字や~space:~INFRA#c0-control-or-space
~scalar値:~INFRA#scalar-value
~scalar値~文字列:~INFRA#scalar-value-string
同型に復号する:~INFRA#isomorphic-decode
区切子で厳密に分割する:~INFRA#strictly-split
で終端して:~INFRA#string-ends-with
未満の符号単位~列:~INFRA#code-unit-less-than

空:~INFRA#list-is-empty
	~EACH:~INFRA#list-iterate
~list:~INFRA#list
~index群:~INFRA#list-get-the-indices
~size:~INFRA#list-size
~item:~INFRA#list-item
~tuple:~INFRA#tuple
空にする:~INFRA#list-empty
除去する:~INFRA#list-remove
付加する:~INFRA#list-append
~cloneする:~INFRA#list-clone
拡張する:~INFRA#list-extend
~listを昇順に~sortする:~INFRA#list-sort-in-ascending-order
構造体:~INFRA#struct

	●ENCODING
~UTF-8:~ENCODING#utf-8
~ISO-2022-JP:~ENCODING#iso-2022-jp
~Shift_JIS:~ENCODING#shift_jis
符号化法から出力~符号化法を取得する:~ENCODING#get-an-output-encoding
符号化法:~ENCODING#encoding
~BOMはそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom
~BOMも失敗-もそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom-or-fail
~UTF-8符号化する:~ENCODING#utf-8-encode
符号化器を取得する:~ENCODING#get-an-encoder
入出力~queue:~ENCODING#concept-stream
符号化するか失敗する:~ENCODING#encode-or-fail
~ISO-2022-JP符号化器:~ENCODING#iso-2022-jp-encoder

	●他
生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
成分組~生成元:~ORIGIN#concept-origin-tuple
同一-生成元:~ORIGIN#same-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
同じ~site:~ORIGIN#same-site
~scheme無しで同じ~site:~ORIGIN#schemelessly-same-site

~blob~URL~store:~FILEAPI#BlobURLStore
~blob~URL~entry:~FILEAPI#blob-url-entry
~blob~URLを解決する:~FILEAPI#blob-url-resolve
bU.環境:~FILEAPI#blob-url-entry-environment

enV.生成元:~WAPI#concept-settings-object-origin

AO.Unicode ToASCII:https://www.unicode.org/reports/tr46/#ToASCII
AO.Unicode ToUnicode:https://www.unicode.org/reports/tr46/#ToUnicode

新たな~obj:~WEBIDLjs#new
反復される値~pair群:~WEBIDL#dfn-value-pairs-to-iterate-over
文字列~化の挙動:~WEBIDL#dfn-stringification-behavior
連列~型:~WEBIDL#idl-sequence
~record型:~WEBIDL#idl-record

公共~接尾辞~listの~algo:https://github.com/publicsuffix/list/wiki/Format#formal-algorithm

_acks1:#_acks1
_ipr1:#_ipr1

●●words_table1

form_urlencoded:<code>application/x-www-form-urlencoded</code> 
APPEND: <span class="op">&lt;&lt;</span> 
protocol0:protocol
at々:@

●●words_table


	●data／構造
store:
blob:
基数:radix::~
番号:number::~
無符号:unsigned::~
	32-bit／16-bit／128-bit
成分組:tuple::~
成分p:part:成分
部位:portion:~
構成-:compose:~

	変異-不能:immutable
	有構造~clone
	APPEND:prepend
	~byte列:bytes
	並び:sequence
	組:pair／tuple
	〜を閉じる:closing
	先頭に~~余計な:leading
	残りの部分:remainder
	直前:immediately preceding
	各部:parts
	頭部:leading
	多過ぎ:too many
	少な過ぎ:too few
	始ま:begin
	大き過ぎ:too big
	2 箇所以上:more than oen spot
	に満たない:fewer than
	後続していない:not followed by
	~cpごと:code-point-for-code-point
	尾部／末尾:trailing

	●処理
渡す:passする:~
渡され:passされ:~
等価性:equivalence::~
同等:equal::~
同等性:equality::~
stateful::::ステートフル
連結-:concatenate::~

	更なる分岐処理:dispatch ... for further processing
	~error含みの:erroneous
	後の段:later stage
	することになる:end up
	にならない:not end up
	往復-可能:roundtripeable
	触れないまま残す:leave 〜 untouched
	得られる:yield
swap:

	●文字データ
BOM:
	~BOMも失敗-も:BOM or fail
C0:
hex::16 進
octal::8 進
hexadecimal::16 進
cp:code point::符号位置::コードポイント
surrogate::::サロゲート
非文字:noncharacter::~
制御文字:controls::~
英数字:alphanumeric::~
英字:alpha::~
角括弧:brackets::~
at-sign::::@マーク
	文字列~化:stringification
	文字列~化-:stringify
部分文字列:substring::~
剥ぐ:stripする::~
	数で:numeric

	●構文解析／直列化
piece:
	-:separator
上書state:state override::上書き state
状態機械:state machine:~
state:
短縮-:shorten::~
圧縮-:compress::~
	圧縮-済みでない:uncompressed
圧縮:compression::~
書出法:writing::書式
書出され:writeされ::書き出され
書出せる:writeできる::書き出せる
同型:isomorphic::~
Shift_JIS:
ISO-2022-JP:
入出力:I/O:~

	~~入力:takes
	正規化-済み:normalized
	符号化-済み:encoded
	先頭:start of／:leading／:starts with
	指す:points to
	`0080^U 以上:greater than U+007F DELETE

	●URL／origin／domain／host
IP:
IPv6:
IPv4:
file:
subdomain::::下位ドメイン
hostname::::ホスト名
userinfo::::ユーザ情報
username::::ユーザ名
password::::パスワード
query::::クエリ
dot:::ドット
	単-~dot:single-dot
	二重-~dot:double-dot
二重-:double-:~
区分:segment::~
percent-::: %-
drive_letter:Windows drive letter:::Windows ドライブレター
大域一意:globally unique::~::グローバル一意
権限:authority::~
公共:public::~
	en:PublicSuffixList
	公共~接尾辞~listの~algo:Public Suffix List algorithm

IDNA:
	IDNA2008
directory::::ディレクトリ

	●network
DNS:

	●仕様
主流:majority:~
普遍的:universal:~
統一化:unified:~
側面f:facet:側面
市場:market share:~
増補:enhancement:~
	意図して:intent of what is
指名-:designate:~
現今の:contemporary:~
確固:solid:確固たるもの
過去互換対処:quirk:~
	conforming
開発用console:developer console:開発用 console::開発用コンソール
排他的:exclusive:~
単直:straightforward:簡単
	単直:fairly straightforward
冪等性:idempotence:~
分岐-:diverge:~
助言:advice:~
申請-:file:~
非推奨化:deprecation:~
致命的:fatal:~
能性:potential:~
末端:end:~
理論:theory:~
行使:exercise:~
理想的:ideal:~

	~network用:networking
	明瞭でない:unclear
	最低~levelの:lowest-level
	捉える:can be seen as
	高:high
	-:Ensure
	同様に:Similarly
	向け:-oriented
	より高~level:higher-level 
	~~観点:notion
	不幸な巡り合わせ:accidents
	好ましい:preferred
	妥協の産物:compromises leading
	~~完全
	揃わせ:align
	扱い方
	取り~~組む:approach
	~~拡がる:increase
	欠いて:lack して
	無くなる:not a lack of
	特に，in particular
	改めたくない:avoid altering
	別法として:Alternatively
	〜のその他諸々:miscellaneous
	べきとされる:ought
	選ぶ:choose
	可能性:potentially
	視野から外れる:out-of-scope
	係る:pertain
	意外な結果:surprising
	に基づいて／含むように:in terms of
	単純にする:simplicity
	期待されない所で:unexpectedly

	●保安
証明書:certificate:~
害する:harmする:害を及ぼす
役務:function:~
双方向-:bidirectional:~
	左横書き埋め込み left-to-right embedding
採用-:adopt:~
製品化-:produce:~
堅固:hard:~
警告-:warn:~
補足-:supplement:~
注目:attention:~
省く:elideする:~
	~URLを省くとき:elision
割振る:allocateする:割り振る
voice::::ボイス
為す:makeする:~

	気をそらす:distract
	混同され易い:confusable／:prone to confusion
	誤りへ導く:mislead:~
	~~誤認-:mistake
	気をそらし:distract
	考慮-:consideration
	注意:care
	注意する:Care is to be taken
	そのような表示:display surface
	見込みが薄い:unlikely
	広範に:wide
	酷似:appear eerily similar
	~~最低でもat the very least
	意に反するnot want to leak
	受け入れる:embrace
	人から読める:human-readable
	IDN
	^en:homograph
	引く:draw
	狭い:space-constrained
	現れる／現れな:appear
	-:post
	〜から:starting
	され易い:prone to
	勧める:advisable
	しまいそうだが:This can be unexpected

	●変数
	%A
	%B
	%C0
	%C1
	%C2
	%L
	%L1
	%L2
	%N
	%N:integer
	%R
	%b
	%厳密か:beStrict
	%i
	%init
	%~IPv4:ipv4
	%~IPv4個数:numbersSeen
	%~IPv4~piece:ipv4Piece
	%n
	%~path:path
	%remaining
	%state
	%~swap数:swaps
	%url
	%~ASCII~domain:asciiDomain
	%~URL
	%~address:address
	%~at-signありか:atSignSeen
	%角括弧の内側か:insideBrackets
	%~password~tokenありか:passwordTokenSeen
	%~buffer
	%~byte:byte
	%~byte列:bytes
	%~byte列~list:sequences
	%~counter:counter
	%~cp:codePoint
	%~scalar値:scalarValue
	%~domain
	%~errorになり得る:potentialError
	%~hex文字列:-
	%~host
	%無視するか:ignore0
	%~obj:-
	%内縁~連列:innerSequence
	%~password:password
	%~percent-符号化-集合:percentEncodeSet
	%~piece~index:pieceIndex
	%最長~index:longestIndex
	%最長~size:longestSize
	%見出された~index:foundIndex
	%見出された~size:foundSize
	%~pointer:pointer
	%~port:port
	%~query:query
	%~query~percent-符号化-集合:queryPercentEncodeSet
	%~slashか:-
	%spaceAsPlus:spaceAsPlus
	%~parameter~list:tuples
	%~parameter:tuple
	%~URL:url
	%~URL~record:urlRecord
	%~URL~obj:url
	%~username
	%成分p:part
	%成分p~list:parts
	%上書state:state override
	%符号化法:encoding
	%値:value
	%値~文字列:valueString
	%入力:input
	%入力~queue:inputQueue
	%公共~接尾辞:publicSuffix
	%出力:output
	%同型な~cp:isomorph
	%名:name
	%名~文字列:nameString
	%圧縮-~index:compress
	%基底:base
	%番号:-
	%最後の~index:-
	%番号~list:numbers
	%文字列:string
	%検証~errorか:validationError
	%不透明か:isOpaque
	%登録-可能な~domain:registrableDomain
	%符号化-済み~cp:encodedCodePoints
	%符号化-出力:encodeOutput
	%素片は除外するか:exclude fragment
	%結果:result
	%構文解析した~URL:parsedURL
	%構文解析した基底:parsedBase
	%設定したか:-
	%長さ:and length
	%最後の~item:last
	%末尾の~dot:trailingDot
	%公共~接尾辞:publicSuffix
	%直列化した~query:serializedQuery

	●未分類
正準-:canonical::~
	正準-化:canonicalization
変種:variant:~
hit::::ヒット

	~memory内の:in-memory
	最短:shortest possible
	含まないので:due to the omission of
	-ing
	率を高める:increase
	込みで:along with
	指して:refer
	指す:refer
	更に:further
	~~全般的に:at large

●●ref_normative

[BIDI]
    Manish Goregaokar मनीष गोरेगांवकर; Robin Leroy. ＜Unicode Bidirectional Algorithm＞. 2 September 2024. Unicode Standard Annex #9. URL: https://www.unicode.org/reports/tr9/tr9-50.html
[ENCODING]
    Anne van Kesteren. ＜Encoding Standard＞. Living Standard. URL: https://encoding.spec.whatwg.org/
[FILEAPI]
    Marijn Kruisselbrink. ＜File API＞. URL: https://w3c.github.io/FileAPI/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[IANA-URI-SCHEMES]
    ＜Uniform Resource Identifier (URI) Schemes＞. URL: https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[PSL]
    ＜Public Suffix List＞.    Mozilla Foundation.
[RFC4291]
    R. Hinden; S. Deering. ＜IP Version 6 Addressing Architecture＞. February 2006. Draft Standard. URL: https://www.rfc-editor.org/rfc/rfc4291
[UTS46]
    Mark Davis; Markus Scherer. ＜Unicode IDNA Compatibility Processing＞. 30 August 2024. Unicode Technical Standard #46. URL: https://www.unicode.org/reports/tr46/tr46-33.html
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[ECMA-262]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[IDNFAQ]
    ＜Internationalized Domain Names (IDN) FAQ＞. URL: https://unicode.org/faq/idn.html
[RFC1034]
    P. Mockapetris. ＜Domain names - concepts and facilities＞. November 1987. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc1034
[RFC3986]
    T. Berners-Lee; R. Fielding; L. Masinter. ＜Uniform Resource Identifier (URI): Generic Syntax＞. January 2005. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc3986
[RFC3987]
    M. Duerst; M. Suignard. ＜Internationalized Resource Identifiers (IRIs)＞. January 2005. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc3987
[RFC5890]
    J. Klensin. ＜Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework＞. August 2010. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc5890
[RFC5952]
    S. Kawamura; M. Kawashima. ＜A Recommendation for IPv6 Address Text Representation＞. August 2010. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc5952
[RFC6454]
    A. Barth. ＜The Web Origin Concept＞. December 2011. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6454
[RFC7595]
    D. Thaler, Ed.; T. Hansen; T. Hardie. ＜Guidelines and Registration Procedures for URI Schemes＞. June 2015. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc7595
[RFC791]
    J. Postel. ＜Internet Protocol＞. September 1981. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc791
[UTR36]
    Mark Davis; Michel Suignard. ＜Unicode Security Considerations＞. 19 September 2014. Unicode Technical Report #36. URL: https://www.unicode.org/reports/tr36/tr36-15.html
[UTS39]
    Mark Davis; Michel Suignard. ＜Unicode Security Mechanisms＞. 3 September 2024. Unicode Technical Standard #39. URL: https://www.unicode.org/reports/tr39/tr39-30.html


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://url.spec.whatwg.org/">URL Standard</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/url">GitHub whatwg/url</a> (<a href="https://github.com/whatwg/url/issues/new/choose">new issue</a>, <a href="https://github.com/whatwg/url/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	<a href="https://github.com/whatwg/url/commits">GitHub whatwg/url/commits</a>
	<a href="https://url.spec.whatwg.org/commit-snapshots/9bc33c39d4a6cd6a936ea7620b5a69f606ec0d4c/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/urlstandard">@urlstandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/url">web-platform-tests url/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/url">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）
	<a href="https://htmlspecs.com/url/" hreflang="zh-hans" lang="zh-hans" rel="alternate">简体中文</a>

</script>
</head>
<body>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDUiIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzNjNzkwYSIgc3Ryb2tlLXdpZHRoPSIxMCIvPgo8cGF0aCBkPSJtNDUsMzFoMTB2MTBoLTEwem0wLDI4aDEwdjEwaC0xMCIgZmlsbD0iIzNjNzkwYSIvPgo8L3N2Zz4K"
></a>

	<hgroup>
<h1>URL</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
URL 標準は、［
~URL, ~domain, ~IP~address, ~form_urlencoded形式
］および それらの~APIを定義する。
◎
The URL Standard defines URLs, domains, IP addresses, the application/x-www-form-urlencoded format, and their API.
</p>

	</section>

<main id="MAIN0">

	<section id="goals">
<h2 title="Goals">目標</h2>

<p>
~URL標準は、
次に挙げる~approachにより，~URLを全部的に相互運用可能にすることを目指す：
◎
The URL standard takes the following approach towards making URLs fully interoperable:
</p>

<ul>
	<li>
［
`RFC3986$r, `RFC3987$r
］を現今の実装に揃わせて、
その過程の中でそれらの~RFCを過去のものにする
（例えば，［
空白, 他の “合法でない” ~cp, ~queryの符号化法, 同等性, 正準-化
］などの概念は、
どれも~~完全には共有-もしくは定義されていない）。
~URLの構文解析-法は、
~HTMLの構文解析-法と同程度に確固になる必要がある。
◎
Align RFC 3986 and RFC 3987 with contemporary implementations and obsolete the RFCs in the process. (E.g., spaces, other "illegal" code points, query encoding, equality, canonicalization, are all concepts not entirely shared, or defined.) URL parsing needs to become as solid as HTML parsing. [RFC3986] [RFC3987]
</li>
	<li>
語~URLを標準~化する。
URI と IRI は混同され易い。
実施においては，どちらにも同じ~algoが利用されるので、
それらを区別する利点は無い。
`~Webの検索結果＠https://trends.google.com/trends/explore?q=url,uri$でも，
~URLの方が優位にある。
◎
Standardize on the term URL. URI and IRI are just confusing. In practice a single algorithm is used for both so keeping them distinct is not helping anyone. URL also easily wins the search result popularity contest.
</li>
	<li>
`URI [sic] の生成元＠~RFCx/rfc6454#section-4$ `RFC6454$r
に取って代わる。
◎
Supplanting Origin of a URI [sic]. [RFC6454]
</li>
	<li>
~URLの既存の~JS~APIにおける全部的な詳細を定義して，
より作業し易くするための増補を追加する。
また、
~HTML要素を通さない~URL操作~用に，
`URL$I ~objを新たに追加する
（~JS~worker環境~用に有用になる）。
◎
Define URL’s existing JavaScript API in full detail and add enhancements to make it easier to work with. Add a new URL object as well for URL manipulation without usage of HTML elements. (Useful for JavaScript worker environments.)
</li>
	<li>
［
構文解析器, 直列化器, ~API
］の組合nにおける冪等性を保証する。
例えば、
構文解析してから直列化する演算を重ねて適用しても，
1 回だけ適用した結果（失敗でないとする）と同じになること。
同様に、
~APIを通して操作した結果（失敗でないとする）に対し，
それを直列化してから構文解析した結果は、
何回~適用しようが同じになること。
◎
Ensure the combination of parser, serializer, and API guarantee idempotence. For example, a non-failure result of a parse-then-serialize operation will not change with any further parse-then-serialize operations applied to it. Similarly, manipulating a non-failure result through the API will not change from applying any number of serialize-then-parse operations to it.
</ul>

<p class="note">注記：
編集者たちがこの~~主題に関しより多くを学ぶに連れ、
目標となる視野は~~拡がるかもしれない。
◎
As the editors learn more about the subject matter the goals might increase in scope somewhat.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

<p>
加えて、
次の記法も利用する
⇒
%s ~APPEND %a ~APPEND %b ~APPEND …
⇒
これは、
左辺の［
文字列／~byte列
］ %s の末尾に後続の［
文字列／~byte列
］ %a, %b, … を示された順に付加する演算を表す。
式として用いられた場合、
結果の %s が式の値になる。
</p>

	</section>
	<section id="infrastructure">

<h2 title="Infrastructure">1. 基盤</h2>

<p>
この仕様は `Infra^cite `INFRA$r に依存する。
◎
This specification depends on Infra. [INFRA]
</p>

<div class="p">
<p>
この仕様に利用される一部の用語は、
次に挙げる［
標準／仕様
］にて定義される
⇒＃
`Encoding^cite `ENCODING$r,
`File API^cite `FILEAPI$r,
`HTML^cite `HTML$r,
`Unicode IDNA Compatibility Processing^cite `UTS46$r,
`Web IDL^cite `WEBIDL$r
◎
Some terms used in this specification are defined in the following standards and specifications:
• Encoding [ENCODING]
• File API [FILEAPI]
• HTML [HTML]
• Unicode IDNA Compatibility Processing [UTS46]
• Web IDL [WEBIDL]
</div>

<hr>

<div class="algo">
<p>
`整数を直列化する@
~algoは、
所与の
( 整数 %N )
に対し
⇒
~RET %N を 10 進数で最短に表現する文字列
【結果には、`~ASCII数字$に加え，負符号も含まれ得るが、この仕様では，負符号は生じ得ない。】
◎
To serialize an integer, represent it as the shortest possible decimal number.
</p>
</div>

		<section id="writing">
<h3 title="Writing">1.1. 書出法</h3>

<p>
`検証~error@
とは、
入力と妥当な入力との間の不一致を指示するものである。
~UA
— とりわけ，適合性~検査器 —
には、
どこかへそれを報告することが奨励される。
◎
A validation error indicates a mismatch between input and valid input. User agents, especially conformance checkers, are encouraged to report them somewhere.
</p>

<div class="note">
<p>注記：
`検証~error$は、
構文解析器を終了させるものではない。
構文解析器の終了nは、
常に，明示的にそう記される
— ~RET 文などにより。
◎
A validation error does not mean that the parser terminates. Termination of a parser is always stated explicitly, e.g., through a return statement.
</p>

<p>
`検証~error$を通達することは、
有用になる
— ~errorの取扱いは直感的でないこともあり、［
旧来の~UAは、
正しい~errorの取扱いを実装していないかもしれない／
他の開発者にとっては、
何を意図して書出されたか明瞭でないかもしれない
］ので。
◎
It is useful to signal validation errors as error-handling can be non-intuitive, legacy user agents might not implement correct error-handling, and the intent of what is written might be unclear to other developers.
</p>
</div>

<table class="grid-table" id="_error-types"><thead>
<tr><th>
~errorの種別
◎
Error type
<th>
~errorの記述
◎
Error description
<th>
例
<th>
失敗か？
◎
Failure
<tbody>

<tr><th colspan="4" scope="rowgroup">
`§ ~IDNA＠#idna$
◎
IDNA

<tr><td>`domain-to-ASCII@err
<td>
<p>
`Unicode ToASCII$AO `UTS46$r が，
~errorを記録したか空~文字列を返した。
◎
Unicode ToASCII records an error or returns the empty string. [UTS46]
</p>

<p class="note">注記：
`Unicode ToASCII$AO における~errorについての詳細が記録された場合、
~UAには，それも渡すことが奨励される。
◎
If details about Unicode ToASCII errors are recorded, user agents are encouraged to pass those along.
</p>
<td>
<td>
失敗する
◎
Yes

<tr><td>`domain-invalid-code-point@err
<td>
入力の`~host$が，`禁止~domain~cp$を包含している。
◎
The input’s host contains a forbidden domain code point.
<td class="example">
~URLが`特別$であるとき、
その~hostが，処理される前に`~percent-復号された＠#string-percent-decode$
— ~URLが `https://exa%23mple.org^l であったなら、
その結果，~host部位は `exa#mple.org^l になり、
この~errorを誘発する。
◎
Hosts are percent-decoded before being processed when the URL is special, which would result in the following host portion becoming "exa#mple.org" and thus triggering this error.
◎
"https://exa%23mple.org"
<td>
失敗する
◎
Yes

<tr><td>`domain-to-Unicode@err
<td>
<p>
`Unicode ToUnicode$AO `UTS46$r が，
~errorを記録した。
◎
Unicode ToUnicode records an error. [UTS46]
</p>

<p class="note">注記：
`domain-to-ASCII$err と同じ考慮点が適用される。
◎
The same considerations as with domain-to-ASCII apply.
</p>
<td>
<td>·
<tbody>

<tr><th colspan="4" scope="rowgroup">
`§ ~hostの構文解析-法＠#host-parsing$
◎
Host parsing

<tr><td>`host-invalid-code-point@err
<td>
`不透明な~host$（`特別$でない~URL）が，`禁止~host~cp$を包含している。
◎
An opaque host (in a URL that is not special) contains a forbidden host code point.
<td class="example">
`foo://exa[mple.org^l
<td>
失敗する
◎
Yes

<tr><td>`IPv4-empty-part@err
<td>
`~IPv4~address$が，
❝. で終端している。
◎
An IPv4 address ends with a U+002E (.).
<td class="example">
`https://127.0.0.1./^l
<td>·

<tr><td>`IPv4-too-many-parts@err
<td>
`~IPv4~address$を成す成分pの個数が，
4 でない。
◎
An IPv4 address does not consist of exactly 4 parts.
<td class="example">
`https://1.2.3.4.5/^l
<td>
失敗する
◎
Yes

<tr><td>`IPv4-non-numeric-part@err
<td>
`~IPv4~address$を成すある成分pが，
数でない。
◎
An IPv4 address part is not numeric.
<td class="example">
`https://test.42^l
<td>
失敗する
◎
Yes

<tr><td>`IPv4-non-decimal-part@err
<td>
`~IPv4~address$を成すある成分pが，［
~hexadecimal／~octal
］数字を利用して表出された番号である。
◎
The IPv4 address contains numbers expressed using hexadecimal or octal digits.
<td class="example">
`https://127.0.0x0.1^l
<td>·

<tr><td>`IPv4-out-of-range-part@err
<td>
`~IPv4~address$を成すある成分pが，
255 を超過している。
◎
An IPv4 address part exceeds 255.
<td class="example">
`https://255.255.4000.1^l
<td>
失敗する
（最後の成分pに適用-可能な場合に限り）
◎
Yes
(only if applicable to the last part)

<tr><td>`IPv6-unclosed@err
<td>
`~IPv6~address$を閉じる ❝] が欠落である。
◎
An IPv6 address is missing the closing U+005D (]).
<td class="example">
`https://[::1^l
<td>
失敗する
◎
Yes

<tr><td>`IPv6-invalid-compression@err
<td>
`~IPv6~address$が，
不適正な圧縮から始まっている。
◎
An IPv6 address begins with improper compression.
<td class="example">
`https://[:1]^l
<td>
失敗する
◎
Yes

<tr><td>`IPv6-too-many-pieces@err
<td>
`~IPv6~address$が包含する~pieceの個数が，
8 以下でない。
◎
An IPv6 address contains more than 8 pieces.
<td class="example">
`https://[1:2:3:4:5:6:7:8:9]^l
<td>
失敗する
◎
Yes

<tr><td>`IPv6-multiple-compression@err
<td>
`~IPv6~address$が，
2 箇所以上で圧縮されている。
◎
An IPv6 address is compressed in more than one spot.
<td class="example">
`https://[1::1::1]^l
<td>
失敗する
◎
Yes

<tr><td>`IPv6-invalid-code-point@err
<td>
`~IPv6~address$が，［
`~ASCII~hex数字$, ❝:
］以外の~cpを包含しているか,
期待されない所で終端している。
◎
An IPv6 address contains a code point that is neither an ASCII hex digit nor a U+003A (:). Or it unexpectedly ends.
<td class="example">
<p>
`https://[1:2:3!:4]^l
</p>

<p>
`https://[1:2:3:]^l
</p>
<td>
失敗する
◎
Yes

<tr><td>`IPv6-too-few-pieces@err
<td>
圧縮-済みでない`~IPv6~address$を成す~pieceの個数が，
8 個に満たない。
◎
An uncompressed IPv6 address contains fewer than 8 pieces.
<td class="example">
`https://[1:2:3]^l
<td>
失敗する
◎
Yes

<tr><td>`IPv4-in-IPv6-too-many-pieces@err
<td>
`~IPv4~address$構文を伴う`~IPv6~address$において、
~IPv6~addressを成す~pieceの個数が，
6 以下でない。
◎
An IPv6 address with IPv4 address syntax: the IPv6 address has more than 6 pieces.
<td class="example">
`https://[1:1:1:1:1:1:1:127.0.0.1]^l
<td>
失敗する
◎
Yes

<tr><td>`IPv4-in-IPv6-invalid-code-point@err
<td>
<p>
`~IPv4~address$構文を伴う`~IPv6~address$において：
◎
An IPv6 address with IPv4 address syntax:
</p>
<ul>
	<li>
ある~IPv4成分pが
⇒＃
空である／
`~ASCII数字$でないものを包含している／
先頭に~~余計な 0 を包含している
◎
An IPv4 part is empty or contains a non-ASCII digit.
◎
An IPv4 part contains a leading 0.
</li>
	<li>
~IPv4成分pの個数が，
多過ぎる。
◎
There are too many IPv4 parts.
</li>
</ul>
<td class="example">
<p>
`https://[ffff::.0.0.1]^l
</p>

<p>
`https://[ffff::127.0.xyz.1]^l
</p>

<p>
`https://[ffff::127.0xyz]^l
</p>

<p>
`https://[ffff::127.00.0.1]^l
</p>

<p>
`https://[ffff::127.0.0.1.2]^l
</p>
<td>
失敗する
◎
Yes

<tr><td>`IPv4-in-IPv6-out-of-range-part@err
<td>
`~IPv4~address$構文を伴う`~IPv6~address$において、
ある~IPv4成分pが，
255 を超過している。
◎
An IPv6 address with IPv4 address syntax: an IPv4 part exceeds 255.
<td class="example">
`https://[ffff::127.0.0.4000]^l
<td>
失敗する
◎
Yes

<tr><td>`IPv4-in-IPv6-too-few-parts@err
<td>
`~IPv4~address$構文を伴う`~IPv6~address$において、
~IPv4成分pの個数が，
少な過ぎる。
◎
An IPv6 address with IPv4 address syntax: an IPv4 address contains too few parts.
<td class="example">
`https://[ffff::127.0.0]^l
<td>
失敗する
◎
Yes
<tbody>

<tr><th colspan="4" scope="rowgroup">
`§ ~URLの構文解析-法＠#url-parsing$
◎
URL parsing

<tr><td>`invalid-URL-unit@err
<td>
`~URL単位$でない~cpが見出された。
◎
A code point is found that is not a URL unit.
<td class="example">
<p>
`https://example.org/&gt;^l
</p>

<p>
` https://example.org ^l
</p>

<p>
`ht<br>tps://example.org^l
◎
"https://example.org"
</p>

<p>
`https://example.org/%s^l
</p>
<td>·

<tr><td>`special-scheme-missing-following-solidus@err
<td>
入力の~schemeに `//^l が後続していない。
◎
The input’s scheme is not followed by "//".
<td class="example">
<p>
`file:c:/my-secret-folder^l
</p>

<p>
`https:example.org^l
</p>

<pre>
const %url = new URL("https:foo.html", "https://example.org/");
</pre>
<td>·

<tr><td>`missing-scheme-non-relative-URL@err
<td>
入力の`~scheme$urlが欠落である
— ［
入力は`~ASCII英字$で始まっていない
］かつ［
`基底~URL$は供されていないか，
供されたが`不透明な~path$を有するので`基底~URL$として利用できない
］ことにより。
◎
The input is missing a scheme, because it does not begin with an ASCII alpha, and either no base URL was provided or the base URL cannot be used as a base URL because it has an opaque path.
<td class="example">
<p>
入力の`~scheme$urlが欠落って，`基底~URL$は与えられていない：
◎
Input’s scheme is missing and no base URL is given:
</p>

<pre>
const %url = new URL("💩");
</pre>

<p>
入力の`~scheme$urlが欠落って，
`基底~URL$は`不透明な~path$を有する：
◎
Input’s scheme is missing, but the base URL has an opaque path.
</p>

<pre>const %url = new URL("💩", "mailto:user@example.org");
</pre>
<td>
失敗する
◎
Yes

<tr><td>`invalid-reverse-solidus@err
<td>
~URLは、
`特別~scheme$を伴うが，
❝/ の代わりに ❝\ を利用している。
◎
The URL has a special scheme and it uses U+005C (\) instead of U+002F (/).
<td class="example">
`https://example.org\path\to\file^l
<td>·

<tr><td>`invalid-credentials@err
<td>
入力は，`資格証を含んで$いる。
◎
The input includes credentials.
<td class="example">
<p>
`https://user~at々example.org^l
</p>

<p>
`ssh://user~at々example.org^l
</p>
<td>·

<tr><td>`host-missing@err
<td>
入力は、
`特別~scheme$を伴うが，`~host$を包含していない。
◎
The input has a special scheme, but does not contain a host.
<td class="example">
<p>
`https://#fragment^l
</p>

<p>
`https://:443^l
</p>

<p>
`https://user:pass~at々^l
</p>
<td>
失敗する
◎
Yes

<tr><td>`port-out-of-range@err
<td>
入力の~portが，
大き過ぎる。
◎
The input’s port is too big.
<td class="example">
`https://example.org:70000^l
<td>
失敗する
◎
Yes

<tr><td>`port-invalid@err
<td>
入力の~portが，
妥当でない。
◎
The input’s port is invalid.
<td class="example">
`https://example.org:7z^l
<td>
失敗する
◎
Yes

<tr><td>`file-invalid-Windows-drive-letter@err
<td>
<p>
入力は`~drive_letterから開始して$いる`相対~URL$sTであるが、
`基底~URL$の`~scheme$urlは `file^l 。
◎
The input is a relative-URL string that starts with a Windows drive letter and the base URL’s scheme is "file".
</p>
<td class="example">
<pre>
const %url = new URL("/c:/path/to/file", "file:///c:/");
</pre>

<td>·

<tr><td>`file-invalid-Windows-drive-letter-host@err
<td>
`file:^c ~URLの~hostが，
`~drive_letter$である。
◎
A file: URL’s host is a Windows drive letter.
<td class="example">
`file://c:^l
<td>·
</table>

		</section>
		<section id="parsers">
<h3 title="Parsers">1.2. 構文解析器</h3>

<p>
`EOF@i
とは、［
文字列~stream ／ ~cp~stream
］の終端を表す，概念的な~cpである†。
◎
The EOF code point is a conceptual code point that signifies the end of a string or code point stream.
</p>

<p class="trans-note">【
“`End Of File^en” の略称
— この訳では、
原文の “EOF ~cp” を単に “EOF” と略記する。
】【†
したがって、
どの本物の~cpとも等しくない。
】</p>

<p>
所与の`文字列$ %入力 用の
`~pointer@
は、
%入力 の中の ある`~cp$を指す整数であり，初期~時には %入力 の先頭を指す【値としては 0 】とする。
それは、
−1 ならば ε を指す（ “どこも指さない” ）／
%入力 の`~cp長さ$以上ならば `EOF$i を指す【 %入力 が空ならば、常にそうなる】。
◎
A pointer for a string input is an integer that points to a code point within input. Initially it points to the start of input. If it is −1 it points nowhere. If it is greater than or equal to input’s code point length, it points to the EOF code point.
</p>

<p>
`~pointer$が利用されている下での記号
`C@V,
`C1@V,
`C2@V
は、
順に［
`~pointer$が指している`~cp$, その次の~cp, 次の次の~cp
］を参照する。
`~pointer$が ε を指している場合、
これらの記号は利用され得ない。
`~pointer$が `EOF$i を指している場合，
`C$V は `EOF$i になり、
`C1$V, `C2$V についても同様とする。
◎
When a pointer is used, c references the code point the pointer points to as long as it does not point nowhere. When the pointer points to nowhere c cannot be used.
◎
When a pointer is used, remaining references the code point substring from the pointer + 1 to the end of the string, as long as c is not the EOF code point. When c is the EOF code point remaining cannot be used.
</p>

<p class="example">
例えば、
処理される`文字列$が `http://example.com^l で，
`~pointer$が `o^l を指しているなら、［
`C$V, `C1$V, `C2$V
］は，順に［
❝o, ❝m, `EOF$i
］になる。
◎
If "mailto:username@example" is a string being processed and a pointer points to @, c is U+0040 (@) and remaining is "example".
</p>

<p class="example">
例えば、
`~pointer$は文字列の先頭を指している下で，
1 減らしてから `C$V （あるいは `C1$V, `C2$V ）を利用するのは【仕様における】~errorである。
◎
If the empty string is being processed and a pointer points to the start and is then decreased by 1, using c or remaining would be an error.
</p>

<p class="trans-note">【
`C1$V, `C2$V は、
原文の
<dfn id="remaining">%remaining</dfn>
に代えて，この訳に導入した記号である
— %remaining は［
`~pointer$ ~PLUS 1 から`終端までを成す~cp部分文字列$
］（ `C1$V 以降を成す部分文字列）として定義されているが、
それを利用しているどの箇所も，実際には `C1$V, `C2$V しか利用していないので。
】【
`C$V は，原文では小文字 “c” であるが、
日本語の字の大きさとの兼ね合いにより，この訳では大文字で記すことにする。
】</p>

		</section>
		<section id="percent-encoded-bytes">
<h2 title="Percent-encoded bytes">1.3. ~percent-符号化された~byte</h2>

<p class="trans-note">【
“~percent-” は、
原文の接頭語 “percent-” の（この訳による）略記であり，文字 `%^l に関わることを表す。
】</p>

<p>
`~percent-符号化された~byte@
とは、［
❝%, `~ASCII~hex数字$, `~ASCII~hex数字$
］の並びが成す文字列である。
◎
A percent-encoded byte is U+0025 (%), followed by two ASCII hex digits.
</p>

<p class="note">注記：
一般に，
`~percent-符号化された~byte$たちが成す連列~用には、［
`文字列を~byte列に~percent-復号する$,
`~BOMも失敗-もそのままに~UTF-8復号する$
］を順に適用したときの結果が `失敗^i にならないようにすることが，良い案になる。
これがどう重要になるかは、
`~percent-符号化された~byte$がどこで利用されるかに依存する。
例：
`~host構文解析器$用には，この助言に従わないことは致命的である一方、
`~URLの具現化＠#url-rendering-i18n$用には，`~percent-符号化された~byte$を`~percent-復号-＠#string-percent-decode$しないで具現化することになろう。
◎
It is generally a good idea for sequences of percent-encoded bytes to be such that, when percent-decoded and then passed to UTF-8 decode without BOM or fail, they do not end up as failure. How important this is depends on where the percent-encoded bytes are used. E.g., for the host parser not following this advice is fatal, whereas for URL rendering the percent-encoded bytes would not be rendered percent-decoded.
</p>

<div class="algo">
<p>
`~byteを文字列に~percent-符号化する@
~algoは、
所与の
( 1 個の`~byte$ %~byte )
に対し
⇒
~RET 次に与える`~percent-符号化された~byte$
⇒
❝% ~APPEND ［
%~byte を表現する 2 個の`~ASCII~hex数字（大文字）$
］
◎
To percent-encode a byte byte, return a string consisting of U+0025 (%), followed by two ASCII upper hex digits representing byte.
</p>
</div>

<div class="algo">
<p>
`~byte列を~byte列に~percent-復号する@
~algoは、
所与の
( `~byte列$ %入力 )
に対し：
◎
To percent-decode a byte sequence input, run these steps:
</p>

<p class="warning">警告：
%入力 が`~ASCII~byte$以外の~byteを含み得るときに，
`~BOMはそのままに~UTF-8復号する$以外を利用するのは、
~secureでないこともあるので推奨されない。
◎
Using anything but UTF-8 decode without BOM when input contains bytes that are not ASCII bytes might be insecure and is not recommended.
</p>

<ol>
	<li>
%出力 ~LET 空`~byte列$
◎
Let output be an empty byte sequence.
</li>
	<li>
%L ~LET %入力 の`長さ$byte
◎
↓</li>
	<li>
%N ~LET 1
◎
↓</li>
	<li>
<p>
~WHILE［
%N ~LTE %L
］：
</p>
		<ol>
			<li>
%~byte ~LET %入力 の %N 個目の~byte
</li>
			<li>
%N ~INCBY 1
</li>
			<li>
<p>
~IF［
%~byte ~EQ ❛%
］~AND［
%N ~PLUS 1 ~LTE %L
］：
</p>
				<ol>
					<li>
%~byte列 ~LET %入力 の［
%N 個目, %N ~PLUS 1 個目
］の~byteが成す~byte列
</li>
					<li>
<p>
~IF［
%~byte列 を成すどの~byte %b も［
%b ~IN { ❛0 〜 ❛9, ❛A 〜 ❛F, ❛a 〜 ❛f }
］を満たす
］：
</p>
						<ol>
							<li>
%~hex文字列 ~LET `同型に復号する$( %~byte列 )
</li>
							<li>
%~byte ~SET ［
%~hex文字列 を~hexadecimal数として解釈した結果の数
］を値とする~byte
</li>
							<li>
%N ~INCBY 2
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%出力 ~APPEND %~byte
</li>
		</ol>
◎
For each byte byte in input:
• If byte is not 0x25 (%), then append byte to output.
• Otherwise, if byte is 0x25 (%) and the next two bytes after byte in input are not in the ranges 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F), and 0x61 (a) to 0x66 (f), all inclusive, append byte to output.
• Otherwise:
•• Let bytePoint be the two bytes after byte in input, decoded, and then interpreted as hexadecimal number.
•• Append a byte whose value is bytePoint to output.
•• Skip the next two bytes in input.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`文字列を~byte列に~percent-復号する@
~algoは、
所与の
( `~scalar値~文字列$ %入力 )
に対し
⇒
~RET `~byte列を~byte列に~percent-復号する$( `~UTF-8符号化する$( %入力 ) )
◎
To percent-decode a scalar value string input:
• Let bytes be the UTF-8 encoding of input.
• Return the percent-decoding of bytes.
</p>
</div>

<p class="note">注記：
一般に、
~percent-符号化した結果の文字列を成す ❝% ~cpは，入力より~~増え、
~percent-復号した結果の~byte列を成す ❛% ~byteは，入力より~~減る。
◎
In general, percent-encoding results in a string with more U+0025 (%) code points than the input, and percent-decoding results in a byte sequence with less 0x25 (%) bytes than the input.
</p>

<hr>

<p class="trans-note">【
次に挙げる各種［
~cpたちが成す集合
］は、
後続の各種 “~percent-符号化する” ~algoから利用される：
】</p>

<ul>
	<li>
`~C0制御文字~percent-符号化-集合@
は、
次に挙げる~cpが成す集合である
⇒＃
`~C0制御文字$,
`007F^U `DELETE^cn 〜 `10FFFF^U
◎
The C0 control percent-encode set are the C0 controls and all code points greater than U+007E (~).
</li>
	<li>
`素片~percent-符号化-集合@
は、
次に挙げる~cpが成す集合である
⇒＃
`~C0制御文字~percent-符号化-集合$,
`0020^U `SPACE^cn,
❝",
`003C^U `&lt;^smb,
`003E^U `&gt;^smb,
❝`
◎
The fragment percent-encode set is the C0 control percent-encode set and U+0020 SPACE, U+0022 ("), U+003C (&lt;), U+003E (&gt;), and U+0060 (`).
</li>
	<li>
<p>
`~query~percent-符号化-集合@
は、
次に挙げる~cpが成す集合である
⇒＃
`~C0制御文字~percent-符号化-集合$,
`0020^U `SPACE^cn,
❝",
❝#,
`003C^U `&lt;^smb,
`003E^U `&gt;^smb,
◎
The query percent-encode set is the C0 control percent-encode set and U+0020 SPACE, U+0022 ("), U+0023 (#), U+003C (&lt;), and U+003E (&gt;).
</p>

<p class="note">注記：
`~query~percent-符号化-集合$は、
❝` を含まないので，`素片~percent-符号化-集合$を含むように定義し得ない。
◎
The query percent-encode set cannot be defined in terms of the fragment percent-encode set due to the omission of U+0060 (`).
</p>
	</li>
	<li>
`特別~query~percent-符号化-集合@
は、
次に挙げる~cpが成す集合である
⇒＃
`~query~percent-符号化-集合$,
❝'
◎
The special-query percent-encode set is the query percent-encode set and U+0027 (').
</li>
	<li>
`~path~percent-符号化-集合@
は、
次に挙げる~cpが成す集合である
⇒＃
`~query~percent-符号化-集合$,
❝?,
❝^,
❝`,
❝{,
❝}
◎
The path percent-encode set is the query percent-encode set and U+003F (?), U+005E (^), U+0060 (`), U+007B ({), and U+007D (}).
</li>
	<li>
`~userinfo~percent-符号化-集合@
は、
次に挙げる~cpが成す集合である
⇒＃
`~path~percent-符号化-集合$,
❝/,
❝:,
❝;,
❝=,
❝@,
❝[,
❝\,
❝],【！U+005B ([) to U+005D (])】
❝|
◎
The userinfo percent-encode set is the path percent-encode set and U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([) to U+005D (]), inclusive, and U+007C (|).
</li>
	<li>
<p>
`成分~percent-符号化-集合@
は、
次に挙げる~cpが成す集合である
⇒＃
`~userinfo~percent-符号化-集合$
❝$,【！U+0024 ($) to U+0026 (&amp;)】
❝%,
`0026^U `&amp;^smb,
❝+,
❝,
◎
The component percent-encode set is the userinfo percent-encode set and U+0024 ($) to U+0026 (&amp;), inclusive, U+002B (+), and U+002C (,).
</p>

<p class="note">注記：
これは、
`HTML^cite において `registerProtocolHandler()$m 用に利用される。
また，他の標準も、
後で［
`~URL$の［
`~path$url／`~query$url／`素片$url
］内 ／
`不透明な~host$内
］に埋込めるよう，~dataを~percent-符号化するときに利用できる。
`文字列を~UTF-8~percent-符号化する$ときに これを利用すると、
~JSの `encodeURIComponent()$m [sic]† に一致する結果が得られる。
`HTML$r
`ECMA-262$r
【† “ "URI" は誤字ではない” 】
◎
This is used by HTML for registerProtocolHandler(), and could also be used by other standards to percent-encode data that can then be embedded in a URL’s path, query, or fragment; or in an opaque host. Using it with UTF-8 percent-encode gives identical results to JavaScript’s encodeURIComponent() [sic]. [HTML] [ECMA-262]
</p>
	</li>
	<li>
<p>
`~form_urlencoded~percent-符号化-集合@
は、
次に挙げる~cpが成す集合である
⇒＃
`成分~percent-符号化-集合$,
❝!,
❝',【！U+0027 (') to U+0029 RIGHT PARENTHESIS】
❝(,
❝),
❝~
◎
The application/x-www-form-urlencoded percent-encode set is the component percent-encode set and U+0021 (!), U+0027 (') to U+0029 RIGHT PARENTHESIS, inclusive, and U+007E (~).
</p>

<p class="note">注記：
`~form_urlencoded~percent-符号化-集合$は、
次に挙げるもの以外の すべての~cpを包含する
⇒＃
`~ASCII英数字$,
❝*,
❝-,
❝.,
❝_
◎
The application/x-www-form-urlencoded percent-encode set contains all code points, except the ASCII alphanumeric, U+002A (*), U+002D (-), U+002E (.), and U+005F (_).
</p>
	</li>
</ul>

<div class="algo">
<p>
`文字列を符号化してから~percent-符号化する@
~algoは、
所与の
( `符号化法$ %符号化法, `~scalar値~文字列$ %入力, ~cpたちが成す集合 %~percent-符号化-集合, 真偽値 %spaceAsPlus （省略時は ~F ） )
に対し：
◎
To percent-encode after encoding, given an encoding encoding, scalar value string input, a percentEncodeSet, and an optional boolean spaceAsPlus (default false):
</p>
<ol>
	<li>
%符号化器 ~LET `符号化器を取得する$( %符号化法 )
◎
Let encoder be the result of getting an encoder from encoding.
</li>
	<li>
%入力~queue ~LET %入力 を`入出力~queue$に変換した結果【！＊】
◎
Let inputQueue be input converted to an I/O queue.
</li>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
<p>
~WHILE 無条件：
◎
Let potentialError be 0.
◎
This needs to be a non-null value to initiate the subsequent while loop.
◎
While potentialError is non-null:
◎
↓↓</p>
		<ol>
			<li>
%符号化-出力 ~LET 空な`入出力~queue$
◎
Let encodeOutput be an empty I/O queue.
</li>
			<li>
%~errorになり得る ~LET `符号化するか失敗する$( %入力~queue, %符号化器, %符号化-出力 )
◎
Set potentialError to the result of running encode or fail with inputQueue, encoder, and encodeOutput.
</li>
			<li>
<p>
［
%符号化-出力 を~byte列に変換した結果【！＊】
］を成す
~EACH( %~byte )
に対し：
◎
For each byte of encodeOutput converted to a byte sequence:
</p>
				<ol>
					<li>
~IF［
%spaceAsPlus ~EQ ~T
］~AND［
%~byte ~EQ  0x20 (SP)
］
⇒＃
%出力 ~APPEND ❝+；
~CONTINUE
◎
If spaceAsPlus is true and byte is 0x20 (SP), then append U+002B (+) to output and continue.
</li>
					<li>
%同型な~cp ~LET 次を満たす`~cp$
⇒
その`値$cp ~EQ %~byte の`値$byte
◎
Let isomorph be a code point whose value is byte’s value.
</li>
					<li>
~Assert：
%~percent-符号化-集合 は`~ASCII~cp$でないすべての~cpを含む。
◎
Assert: percentEncodeSet includes all non-ASCII code points.
</li>
					<li>
~IF［
%同型な~cp ~NIN %~percent-符号化-集合
］
⇒
%出力 ~APPEND %同型な~cp
◎
If isomorph is not in percentEncodeSet, then append isomorph to output.
</li>
					<li>
~ELSE
⇒
%出力 ~APPEND `~byteを文字列に~percent-符号化する$( %~byte )
◎
Otherwise, percent-encode byte and append the result to output.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~errorになり得る ~NEQ ~NULL
］
⇒
%出力 ~APPEND `%26%23^l
~APPEND `整数を直列化する$( %~errorになり得る )【！shortest sequence of ASCII digits...】
~APPEND `%3B^l
◎
If potentialError is non-null, then append "%26%23", followed by the shortest sequence of ASCII digits representing potentialError in base ten, followed by "%3B", to output.
</p>

<p class="note">注記：
これは、
%符号化法 が`~UTF-8$でないとき起こり得る。
◎
This can happen when encoding is not UTF-8.
</p>
			</li>
			<li>
~ELSE
⇒
~BREAK
◎
↑↑</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
引数 %~percent-符号化-集合 用にアリな値のうち，
~percent-符号化する対象に ❝% を含むものは、［
`成分~percent-符号化-集合$,
`~form_urlencoded~percent-符号化-集合$
］に限られる
— したがって， “往復-可能な~data” を与える。
他の値
— `~URL構文解析器$に利用され得るもの —
は、
❝% には触れないまま残す
— そのようなわけで、
適正に表現するためには，まず`~cpを~UTF-8~percent-符号化する$必要がある。
◎
Of the possible values for the percentEncodeSet argument only two end up encoding U+0025 (%) and thus give “roundtripable data”: component percent-encode set and application/x-www-form-urlencoded percent-encode set. The other values for the percentEncodeSet argument — which happen to be used by the URL parser — leave U+0025 (%) untouched and as such it needs to be percent-encoded first in order to be properly represented.
</p>
</div>

<div class="algo">
<p>
`~cpを~UTF-8~percent-符号化する@
~algoは、
所与の
( `~scalar値$ %~scalar値, ~cpたちが成す集合 %~percent-符号化-集合 )
に対し
⇒
~RET `文字列を符号化してから~percent-符号化する$( `~UTF-8$, %~scalar値 1 個からなる`文字列$, %~percent-符号化-集合 )
◎
To UTF-8 percent-encode a scalar value scalarValue using a percentEncodeSet, return the result of running percent-encode after encoding with UTF-8, scalarValue as a string, and percentEncodeSet.
</p>
</div>

<div class="algo">
<p>
`文字列を~UTF-8~percent-符号化する@
~algoは、
所与の
( `~scalar値~文字列$ %入力, ~cpたちが成す集合 %~percent-符号化-集合 )
に対し
⇒
~RET `文字列を符号化してから~percent-符号化する$( `~UTF-8$, %入力, %~percent-符号化-集合 )
◎
To UTF-8 percent-encode a scalar value string input using a percentEncodeSet, return the result of running percent-encode after encoding with UTF-8, input, and percentEncodeSet.
</p>
</div>

<hr>

<div class="example">
<p>
上で定義した各 演算を例により要約する：
◎
Here is a summary, by way of example, of the operations defined above:
</p>

<div>
<table class="grid-table" id="_ex-percent-enc-dec"><thead>
<tr><th>演算
<th>入力~例
<th>出力~例
<tbody>

<tr><td rowspan="2">`~byteを文字列に~percent-符号化する$( %入力 )
<td>`23^X
<td>`%23^l

<tr>
<td>`7F^X
<td>`%7F^l

<tr><td>`~byte列を~byte列に~percent-復号する$( %入力 )
<td>`%25%s%1G^bl
<td>`%%s%1G^bl

<tr><td>`文字列を~byte列に~percent-復号する$( %入力 )
<td>`‽%25%2E^l
<td>`E2^X `80^X `BD^X `25^X `2E^X

<tr><td rowspan="3">
`文字列を符号化してから~percent-符号化する$( `~Shift_JIS$, %入力, `~userinfo~percent-符号化-集合$ )
<td>` ^l
<td>`%20^l

<tr>
<td>`≡^l
<td>`%81%DF^l

<tr>
<td>`‽^l
<td>`%26%238253%3B^l

<tr><td>`文字列を符号化してから~percent-符号化する$( `~ISO-2022-JP$, %入力, `~userinfo~percent-符号化-集合$ )
<td>`¥^l
<td>`%1B(J\%1B(B^l

<tr><td>`文字列を符号化してから~percent-符号化する$( `~Shift_JIS$, %入力, `~userinfo~percent-符号化-集合$, ~T )
<td>`1+1 ≡ 2%20‽^l
<td>`1+1+%81%DF+2%20%26%238253%3B^l

<tr><td rowspan="2">`~cpを~UTF-8~percent-符号化する$( %入力, `~userinfo~percent-符号化-集合$ )
<td>❝≡
<td>`%E2%89%A1^l

<tr>
<td>❝‽
<td>`%E2%80%BD^l

<tr><td>`文字列を~UTF-8~percent-符号化する$( %入力, `~userinfo~percent-符号化-集合$ )
<td>`Say what‽^l
<td>`Say%20what%E2%80%BD^l
</table>

◎
Operation｜Input｜Output

Percent-encode input｜0x23｜"%23"
｜0x7F｜"%7F"
Percent-decode input｜`%25%s%1G`｜`%%s%1G`
Percent-decode input｜"‽%25%2E"｜0xE2 0x80 0xBD 0x25 0x2E
Percent-encode after encoding with Shift_JIS, input, and the userinfo percent-encode set｜" "｜"%20"
｜"≡"｜"%81%DF"
｜"‽"｜"%26%238253%3B"
Percent-encode after encoding with ISO-2022-JP, input, and the userinfo percent-encode set｜"¥"｜"%1B(J\%1B(B"
Percent-encode after encoding with Shift_JIS, input, the userinfo percent-encode set, and true｜"1+1 ≡ 2%20‽"｜"1+1+%81%DF+2%20%26%238253%3B"
UTF-8 percent-encode input using the userinfo percent-encode set｜U+2261 (≡)｜"%E2%89%A1"
U+203D (‽)｜"%E2%80%BD"
UTF-8 percent-encode input using the userinfo percent-encode set｜"Say what‽"｜"Say%20what%E2%80%BD"
</div>
</div>

		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security considerations">2. ~securityの考慮点</h2>

<p>
`~URL$の~securityは、
その環境の役務である。
`~URL$を［
周りに向けて具現化する／渡す, あるいは 周りのそれを解釈する
］ときには、
注意すること。
◎
The security of a URL is a function of its environment. Care is to be taken when rendering, interpreting, and passing URLs around.
</p>

<p>
新たな`~URL$を［
具現化する／割振る
］ときは、
“偽装（ `spoofing^en, なりすまし）”
について考慮する必要がある。
［
`~host$／`~URL$
］による攻撃は、
誰かを別のそれに混同させる可能性がある。
一例として、
1/l/I, m/rn/rri, 0/O, а/a
は，どれも酷似するものになり得る†。
`202A^U `LEFT-TO-RIGHT EMBEDDING^cn
等々のような，より~~問題になる不可視な~cpすらある††。
`UTR36$r
◎
When rendering and allocating new URLs "spoofing" needs to be considered. An attack whereby one host or URL can be confused for another. For instance, consider how 1/l/I, m/rn/rri, 0/O, and а/a can all appear eerily similar. Or worse, consider how U+202A LEFT-TO-RIGHT EMBEDDING and similar code points are invisible. [UTR36]
</p>

<p class="trans-note">【
“具現化（ `rendering^en ）” には、
~~描画に限らず，~~音声化なども含まれる。
】【†
一般には見かけ（あるいは発音）が異なる文字でも、
環境にて可用な~font（あるいは~voice）に依存して酷似するかもしれない。
非 英語話者にとっては、
見かけは異なっていても似た発音として記憶しているため，
錯覚し易いものもあるかもしれない
（例： `correction^en と `collection^en ）。
】【††
空間すら占めないことに加え、
~Unicode双方向-~algoも適用する下で描画された場合，
前後の字の並び順までも変わる。
】【
参考： `IDNFAQ$r
】</p>

<p>
主体 %A から主体 %B へ`~URL$が渡されるときは、
両~主体とも，何が起きるか注意深く考慮する必要がある。
%A は、
意に反して~dataを漏洩するはめになり得る。
%B は、
自身が予期していない入力を受取って利用者に害する動作をとる可能性がある。
特に、
%B は，決して %A を信用するベキでない
— 渡される`~URL$は、
常に信用できる~sourceから来ているとは限らないので。
◎
When passing a URL from party A to B, both need to carefully consider what is happening. A might end up leaking data it does not want to leak. B might receive input it did not expect and take an action that harms the user. In particular, B should never trust A, as at some point URLs from A can come from untrusted sources.
</p>

	</section>
	<section id="hosts-(domains-and-ip-addresses)">
<h2 title="Hosts (domains and IP addresses)">3. ~host（~domainと~IP~address）</h2>

<p>
高~levelからは、［
`~host$, `妥当な~host$sT, `~host構文解析器$, `~host直列化器$
］は，次のように関係する：
◎
At a high level, a host, valid host string, host parser, and host serializer relate as follows:
</p>

<ul>
	<li>
`~host構文解析器$は、
任意な`~scalar値~文字列$に対し［
`失敗^i, または `~host$
］を返す。
◎
The host parser takes an arbitrary scalar value string and returns either failure or a host.
</li>
	<li>
`~host$は、
~memory内の表現と捉えることもできる。
◎
A host can be seen as the in-memory representation.
</li>
	<li>
`妥当な~host$sTは、
`~host構文解析器$に与えたときに，`検証~error$や `失敗^i を誘発しない
— すなわち、［
適合する／妥当である
］と見なされる —
ような入力を定義する。
◎
A valid host string defines what input would not trigger a validation error or failure when given to the host parser. I.e., input that would be considered conforming or valid.
</li>
	<li>
`~host直列化器$は、
~~入力の`~host$に対し，`~ASCII文字列$を返す。
（その文字列をさらに`~host構文解析器$にかけた結果は、
~~元の`~host$と`同等な~host$になる。）
◎
The host serializer takes a host and returns an ASCII string. (If that string is then parsed, the result will equal the host that was serialized.)
</li>
</ul>

<div class="example">
<p>
［
`~host構文解析器$, `~host直列化器$
］を順に適用して往復した結果は、
`~host構文解析器$の引数 %不透明か に依存して，次のようになる：
◎
A parse-serialize roundtrip gives the following results, depending on the isOpaque argument to the host parser:
</p>

<div>
<table class="grid-table" id="_ex-roundtrip"><thead>
<tr><th>入力
<th>出力（ %不透明か ~EQ ~F ）
<th>出力（ %不透明か ~EQ ~T ）
<tbody>

<tr><td>`EXAMPLE.COM^c
<td>`example.com^c （`~domain$）
<td>`EXAMPLE.COM^c （`不透明な~host$）

<tr><td>`example%2Ecom^c
<td>`example.com^c （`~domain$）
<td>`example%2Ecom^c （`不透明な~host$）

<tr><td>`faß.example^c
<td>`xn--fa-hia.example^c （`~domain$）
<td>`fa%C3%9F.example^c （`不透明な~host$）

<tr><td>`0^c
<td>`0.0.0.0^c （`~IPv4~address$）
<td>`0^c （`不透明な~host$）

<tr><td>`%30^c
<td>`0.0.0.0^c （`~IPv4~address$）
<td>`%30^c （`不透明な~host$）

<tr><td>`0x^c
<td>`0.0.0.0^c （`~IPv4~address$）
<td>`0x^c （`不透明な~host$）

<tr><td>`0xffffffff^c
<td>`255.255.255.255^c （`~IPv4~address$）
<td>`0xffffffff^c （`不透明な~host$）

<tr><td>`[0:0::1]^c
<td>`[::1]^c （`~IPv6~address$）
<td>`[::1]^c （`~IPv6~address$）

<tr><td>`[0:0::1%5D^c
<td>`失敗^i
<td>`失敗^i

<tr><td>`[0:0::%31]^c
<td>`失敗^i
<td>`失敗^i

<tr><td>`09^c
<td>`失敗^i
<td>`09^c （`不透明な~host$）

<tr><td>`example.255^c
<td>`失敗^i
<td>`example.255^c （`不透明な~host$）

<tr><td><code>example^example</code>
<td>`失敗^i
<td>`失敗^i
</table>

◎
Input｜Output (isOpaque = false)｜Output (isOpaque = true)
EXAMPLE.COM｜example.com (domain)｜EXAMPLE.COM (opaque host)
example%2Ecom｜｜example%2Ecom (opaque host)
faß.example｜xn--fa-hia.example (domain)｜fa%C3%9F.example (opaque host)
0｜0.0.0.0 (IPv4)｜0 (opaque host)
%30｜｜%30 (opaque host)
0x｜｜0x (opaque host)
0xffffffff｜255.255.255.255 (IPv4)｜0xffffffff (opaque host)
[0:0::1]｜[::1] (IPv6)｜
[0:0::1%5D｜Failure｜
[0:0::%31]｜｜
09｜Failure｜09 (opaque host)
example.255｜｜example.255 (opaque host)
example^example｜｜Failure
</div>
</div>

		<section id="host-representation">
<h3 title="Host representation">3.1. ~host表現</h3>

<p>
`~host@
は、［
`~domain$,
`~IP~address$,
`不透明な~host$,
`空~host$
］のいずれかである。
`~host$は，概して~network~addressとして~serveするが、
~network~addressが必要yでない所では，
`~URL$内で 不透明な識別子として利用されることもある。
◎
A host is a domain, an IP address, an opaque host, or an empty host. Typically a host serves as a network address, but it is sometimes used as opaque identifier in URLs where a network address is not necessary.
</p>

<p class="example">
`~host$urlが`不透明な~host$である`~URL$の典型的な例
⇒
`git://github.com/whatwg/url.git^c
◎
A typical URL whose host is an opaque host is git://github.com/whatwg/url.git.
</p>

<p class="note">注記：
下の各 段落~内で参照されている~RFCは、
参考目的に限られる。
それらは、
`~host$の［
書出法, 構文解析-法, 直列化
］には何ら波及しない
— 以下の節にて他が言明されない限り。
◎
The RFCs referenced in the paragraphs below are for informative purposes only. They have no influence on host writing, parsing, and serialization. Unless stated otherwise in the sections that follow.
</p>

<p>
`~domain@
とは、
~networkの中の~realmを識別する空でない`~ASCII文字列$である。
`RFC1034$r
◎
A domain is a non-empty ASCII string that identifies a realm within a network. [RFC1034]
</p>

<div class="algo">
<p>
`~domain$ %~domain の
`~domain~label群@
は、
次の結果を返す
⇒
`区切子で厳密に分割する$( %~domain, ❝. )
◎
The domain labels of a domain domain are the result of strictly splitting domain on U+002E (.).
</p>
</div>

<p class="note">
2 つの~domain
`example.com^l と `example.com.^l
は、
等価ではなく，概して別物に扱われる。
◎
The example.com and example.com. domains are not equivalent and typically treated as distinct.
</p>

<p>
`~IP~address@
は、［
`~IPv4~address$／`~IPv6~address$
］である。
◎
An IP address is an IPv4 address or an IPv6 address.
</p>

<p>
`~IPv4~address@
は、
~network~addressを識別する `32 ~bitな無符号~整数$である。
`RFC791$r
◎
An IPv4 address is a 32-bit unsigned integer that identifies a network address. [RFC791]
</p>

<p>
`~IPv6~address@
は、
~network~addressを識別する `128 ~bitな無符号~整数$である。
この整数は、
`~IPv6~address$の
`~piece群@
とも称される，［
8 個の `16 ~bitな無符号~整数$
］が成す`~list$で構成される。
`RFC4291$r
◎
An IPv6 address is a 128-bit unsigned integer that identifies a network address. This integer is composed of a list of 8 16-bit unsigned integers, also known as an IPv6 address’s pieces. [RFC4291]
</p>

<p class="note">注記：
<code>&lt;zone_id&gt;</code> の~supportは、
`意図的に除かれている＠https://www.w3.org/Bugs/Public/show_bug.cgi?id=27234#c2$。
◎
Support for &lt;zone_id&gt; is intentionally omitted.
</p>

<p>
`不透明な~host@
は、
空でない`~ASCII文字列$であり，更なる処理に利用され得る。
◎
An opaque host is a non-empty ASCII string that can be used for further processing.
</p>

<p>
`空~host@
は、
空~文字列である。
◎
An empty host is the empty string.
</p>

		</section>
		<section id="host-miscellaneous">
<h3 title="Host miscellaneous">3.2. ~hostのその他諸々</h3>

<p>
次に挙げる~cpは
`禁止~host~cp@
とされる
⇒＃
`0000^U `NULL^cn,
`0009^U `TAB^cn,
`000A^U `LF^cn,
`000D^U `CR^cn,
`0020^U `SPACE^cn,
❝#,
❝/,
❝:,
`003C^U `&lt;^smb,
`003E^U `&gt;^smb,
❝?,
❝@,
❝[,
❝\,
❝],
❝^,
❝|
◎
A forbidden host code point is U+0000 NULL, U+0009 TAB, U+000A LF, U+000D CR, U+0020 SPACE, U+0023 (#), U+002F (/), U+003A (:), U+003C (&lt;), U+003E (&gt;), U+003F (?), U+0040 (@), U+005B ([), U+005C (\), U+005D (]), U+005E (^), or U+007C (|).
</p>

<p>
次に挙げる~cpは
`禁止~domain~cp@
とされる
⇒＃
`禁止~host~cp$,
`~C0制御文字$,
❝%,
`007F^U `DELETE^cn
◎
A forbidden domain code point is a forbidden host code point, a C0 control, U+0025 (%), or U+007F DELETE.
</p>

<div class="algo">
<p>
所与の
( `~host$ %~host )
の
`公共~接尾辞@
（ `public suffix^en ）
得する
~algoは、［
~NULL ／［
%~host 内の［
`公共~接尾辞~list^cite（ `PublicSuffixList^en ） `PSL$r に含まれる部位
］を表現している`~domain$
］］を返す：
◎
To obtain the public suffix of a host host, run these steps. They return null or a domain representing a portion of host that is included on the Public Suffix List. [PSL]
</p>
<ol>
	<li>
~IF［
%~host は`~domain$でない
］
⇒
~RET ~NULL
◎
If host is not a domain, then return null.
</li>
	<li>
%末尾の~dot ~LET ［
%~host は `.^l `で終端して$いるならば `.^l ／
~ELSE_ 空~文字列
］
◎
Let trailingDot be "." if host ends with "."; otherwise the empty string.
</li>
	<li>
%公共~接尾辞 ~LET 
`公共~接尾辞~listの~algo$を~domainとして %~host を与えて走らせた結果の公共~接尾辞
`PSL$r
◎
Let publicSuffix be the public suffix determined by running the Public Suffix List algorithm with host as domain. [PSL]
</li>
	<li>
~Assert：［
%公共~接尾辞 は`~ASCII文字列$である
］~AND［
%公共~接尾辞 は `.^l `で終端して$いない
］
◎
Assert: publicSuffix is an ASCII string that does not end with ".".
</li>
	<li>
~RET ［
%公共~接尾辞, %末尾の~dot
］を順に連結した結果
◎
Return publicSuffix and trailingDot concatenated.
</li>
</ol>
</div>

<div class="algo">
<p>
所与の
( `~host$ %~host )
の
`登録-可能な~domain@
（ `registrable domain^en ）
を得する
~algoは、［
~NULL ／［
%~host の`公共~接尾辞$と［
それに先行している`~domain~label$が在れば それ
］により形成される`~domain$
］］を返す：
◎
To obtain the registrable domain of a host host, run these steps. They return null or a domain formed by host’s public suffix and the domain label preceding it, if any.
</p>
<ol>
	<li>
~IF［
%~host の`公共~接尾辞$ ~EQ ~NULL
］~OR［
( %~host の`公共~接尾辞$, %~host )
は`同等な~host$である
］
⇒
~RET ~NULL
◎
If host’s public suffix is null or host’s public suffix equals host, then return null.
</li>
	<li>
%末尾の~dot ~LET ［
%~host は `.^l `で終端して$いるならば `.^l ／
~ELSE_ 空~文字列
］
◎
Let trailingDot be "." if host ends with "."; otherwise the empty string.
</li>
	<li>
%登録-可能な~domain ~LET 
`公共~接尾辞~listの~algo$を~domainとして %~host を与えて走らせた結果の登録-可能な~domain
`PSL$r
◎
Let registrableDomain be the registrable domain determined by running the Public Suffix List algorithm with host as domain. [PSL]
</li>
	<li>
~Assert：［
%登録-可能な~domain は`~ASCII文字列$である
］~AND［
%登録-可能な~domain は `.^l `で終端して$いない
］
◎
Assert: registrableDomain is an ASCII string that does not end with ".".
</li>
	<li>
~RET ［
%登録-可能な~domain, %末尾の~dot
］を順に連結した結果
◎
Return registrableDomain and trailingDot concatenated.
</li>
</ol>
</div>

<div class="example">
<table class="grid-table" id="_ex-suffix-domain"><thead>
<tr><th>
入力~host
◎
Host input
<th>
公共~接尾辞
◎
Public suffix
<th>登録-可能な~domain
◎
Registrable domain
<tbody>

<tr><td>`com^c
<td>`com^c
<td>~NULL

<tr><td>`example.com^c
<td>`com^c
<td>`example.com^c

<tr><td>`www.example.com^c
<td>`com^c
<td>`example.com^c

<tr><td>`sub.www.example.com^c
<td>`com^c
<td>`example.com^c

<tr><td>`EXAMPLE.COM^c
<td>`com^c
<td>`example.com^c

<tr><td>`example.com.^c
<td>`com.^c
<td>`example.com.^c

<tr><td>`github.io^c
<td>`github.io^c
<td>~NULL

<tr><td>`whatwg.github.io^c
<td>`github.io^c
<td>`whatwg.github.io^c

<tr><td>`إختبار^c
<td>`xn--kgbechtv^c
<td>~NULL

<tr><td>`example.إختبار^c
<td>`xn--kgbechtv^c
<td>`example.xn--kgbechtv^c

<tr><td>`sub.example.إختبار^c
<td>`xn--kgbechtv^c
<td>`example.xn--kgbechtv^c

<tr><td>`[2001:0db8:85a3:0000:0000:8a2e:0370:7334]^c
<td>~NULL
<td>~NULL
</table>
</div>

<p class="warning" id="warning-avoid-psl">
仕様は、
~securityの裁定を為すときには，`生成元$の概念を選好するベキである。
［
“`公共~接尾辞$” ／
“`登録-可能な~domain$”
］の観念に依存することでは、
堅固な~security境界は供せない
— 公共~接尾辞~listは，~clientごとに分岐するので。
この助言を無視する仕様は、
そこで為す裁定の中に，~URLの~schemeは組入れるべきとされるかどうか
— すなわち，［
`同じ~site$／`~scheme無しで同じ~site$
］の概念を利用するかどうか —
について，注意深く考慮することが奨励される。
◎
Specifications should prefer the origin concept for security decisions. The notion of "public suffix" and "registrable domain" cannot be relied-upon to provide a hard security boundary, as the public suffix list will diverge from client to client. Specifications which ignore this advice are encouraged to carefully consider whether URLs' schemes ought to be incorporated into any decisions made, i.e. whether to use the same site or schemelessly same site concepts.
</p>

		</section>
		<section id="idna">
<h3 title="IDNA">3.3. ~IDNA</h3>

<div class="algo">
<p>
`~domainを~ASCII化する@
~algoは、
所与の
( `文字列$ %~domain, 真偽値 %厳密か )
に対し：
◎
The domain to ASCII algorithm, given a string domain and a boolean beStrict, runs these steps:
</p>
<ol>
	<li>
<p>
%結果 ~LET 次を与える下で， `Unicode ToASCII$AO を走らせた結果 `UTS46$r
⇒＃
`domain_name^i ~SET %~domain,
`CheckHyphens^i ~SET %厳密か,
`CheckBidi^i ~SET ~T,
`CheckJoiners^i ~SET ~T,
`UseSTD3ASCIIRules^i ~SET %厳密か,
`Transitional_Processing^i ~SET ~F,
`VerifyDnsLength^i ~SET %厳密か,
`IgnoreInvalidPunycode^i ~SET ~F
◎
Let result be the result of running Unicode ToASCII with domain_name set to domain, CheckHyphens set to beStrict, CheckBidi set to true, CheckJoiners set to true, UseSTD3ASCIIRules set to beStrict, Transitional_Processing set to false, VerifyDnsLength set to beStrict, and IgnoreInvalidPunycode set to false. [UTS46] 
</p>

<div class="note">
<p>注記：
~AND↓ 次が満たされる場合、
この段は %~domain を`~ASCII小文字~化する$ことと等価になる：
</p>
		<ul>
			<li>
%厳密か ~EQ ~F
</li>
			<li>
%~domain は`~ASCII文字列$である
</li>
			<li>
次の結果
⇒
`区切子で厳密に分割する$( %~domain, ❝. )
◎終
を成す どの`~item$も，次を満たす
⇒
［
`~ASCII大小無視$で `xn--^l に合致する文字列
］`から開始して$いない
</li>
		</ul>
◎
If beStrict is false, domain is an ASCII string, and strictly splitting domain on U+002E (.) does not produce any item that starts with an ASCII case-insensitive match for "xn--", this step is equivalent to ASCII lowercasing domain.
</div>
	</li>
	<li>
~IF［
%結果 ~EQ `失敗^i
］
⇒＃
`検証~error$( `domain-to-ASCII$err )；
~RET `失敗^i
◎
If result is a failure value, domain-to-ASCII validation error, return failure.
</li>
	<li>
<p>
~IF［
%厳密か ~EQ ~F
］：
◎
If beStrict is false:
</p>
		<ol>
			<li>
~IF［
%結果 ~EQ 空~文字列
］
⇒＃
`検証~error$( `domain-to-ASCII$err )；
~RET `失敗^i
◎
If result is the empty string, domain-to-ASCII validation error, return failure.
</li>
			<li>
<p>
~IF［
%結果 内に`禁止~domain~cp$が在る
］
⇒＃
`検証~error$( `domain-invalid-code-point$err )；
~RET `失敗^i
◎
If result contains a forbidden domain code point, domain-invalid-code-point validation error, return failure.
</p>

<p class="note">注記：
［
~web互換性,
~DNSに基づかない~systemとの互換性
］に因り、
`禁止~domain~cp$は，［
`UseSTD3ASCIIRules^i が ~T をとるときには許容されない~cpたち
］の下位集合を成す。
`課題 #397＠https://github.com/whatwg/url/issues/397$
も見よ。
◎
Due to web compatibility and compatibility with non-DNS-based systems the forbidden domain code points are a subset of those disallowed when UseSTD3ASCIIRules is true. See also issue #397.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~Assert：
［
%結果 ~NEQ 空~文字列
］~AND［
%結果 内に`禁止~domain~cp$は無い
］
◎
Assert: result is not the empty string and does not contain a forbidden domain code point.
</p>

<p class="note">注記：
［
%厳密か ~EQ ~T
］のときには、
`UTS46$r が，これが満たされることを保証する。
◎
Unicode IDNA Compatibility Processing guarantees this holds when beStrict is true. [UTS46]
</p>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="note">注記：
この文書および~web~platformは、
IDNA2008 `RFC5890$r ではなく，
`Unicode IDNA Compatibility Processing^cite `UTS46$r
【 “~Unicode~IDNA互換性~処理” 】
を~~全般的に利用する。
一例として、
`☕.example^l は，
`失敗^i ではなく `xn--53h.example^l になる。
◎
This document and the web platform at large use Unicode IDNA Compatibility Processing and not IDNA2008. For instance, ☕.example becomes xn--53h.example and not failure. [UTS46] [RFC5890]
</p>
</div>

<div class="algo">
<p>
`~domainを~Unicode化する@
~algoは、
所与の
( `~domain$ %~domain, 真偽値 %厳密か )
に対し：
◎
The domain to Unicode algorithm, given a domain domain and a boolean beStrict, runs these steps:
</p>

<ol>
	<li>
%結果 ~LET 次を与える下で， `Unicode ToUnicode$AO を走らせた結果 `UTS46$r
⇒＃
`domain_name^i ~SET %~domain,
`CheckHyphens^i ~SET %厳密か,
`CheckBidi^i ~SET ~T,
`CheckJoiners^i ~SET ~T,
`UseSTD3ASCIIRules^i ~SET %厳密か,
`Transitional_Processing^i ~SET ~F,
`IgnoreInvalidPunycode^i ~SET ~F
◎
Let result be the result of running Unicode ToUnicode with domain_name set to domain, CheckHyphens set to beStrict, CheckBidi set to true, CheckJoiners set to true, UseSTD3ASCIIRules set to beStrict, Transitional_Processing set to false, and IgnoreInvalidPunycode set to false. [UTS46]
</li>
	<li>
~IF［
%結果 には何らかの~errorが記録された
］
⇒
`検証~error$( `domain-to-Unicode$err )
◎
Signify domain-to-Unicode validation errors for any returned errors, and then,＼
</li>
	<li>
~RET %結果
◎
return result.
</li>
</ol>
</div>

		</section>
		<section id="host-writing">
<h3 title="Host writing">3.4. ~hostの書出法</h3>

<div class="p">
<p>
`妥当な~host@sT
は、
次のいずれかでなければナラナイ：
</p>
<ul>
	<li>
`妥当な~domain$sT
</li>
	<li>
`妥当な~IPv4~address$sT
</li>
	<li>
<p>
次の並び：
</p>
		<ol>
			<li>
❝[
</li>
			<li>
`妥当な~IPv6~address$sT
</li>
			<li>
❝]
	</li></ol>
</li></ul>

◎
A valid host string must be a valid domain string, a valid IPv4-address string, or: U+005B ([), followed by a valid IPv6-address string, followed by U+005D (]).
</div>

<div class="algo">
<p>
`文字列$ %入力 が
`妥当な~domain@
であるとは、［
次の結果 ~NEQ `失敗^i
］になることをいう
⇒
`~domainを~ASCII化する$( %入力, ~T )
◎
A string input is a valid domain if these steps return true:
• Let domain be the result of running domain to ASCII with input and true.
• Return false if domain is failure; otherwise true.
</p>

<p class="XXX">課題：
理想的には、
`妥当な~domain$を成す~cp並びに基づいて定義したい所
— モグラ叩きのように定義するのではなく：
`課題 #245＠https://github.com/whatwg/url/issues/245$
◎
Ideally we define this in terms of a sequence of code points that make up a valid domain rather than through a whack-a-mole: issue 245.
</p>
</div>

<p>
`妥当な~domain@sT
は、
`妥当な~domain$を与える文字列でなければナラナイ。
◎
A valid domain string must be a string that is a valid domain.
</p>

<p>
`妥当な~IPv4~address@sT
は、［
❝. で分離された， 4 個の［
次を満たす最短な文字列
］が成す並び
］でなければナラナイ
⇒
［
1 個以上の`~ASCII数字$のみからなる
］~AND［
それが表現する 10 進数 ~IN { 0 〜 255 }
］
◎
A valid IPv4-address string must be four shortest possible strings of ASCII digits, representing a decimal number in the range 0 to 255, inclusive, separated from each other by U+002E (.).
</p>

<p>
`妥当な~IPv6~address@sT
は、
`IP Version 6 Addressing Architecture^cite
`§ Text Representation of Addresses＠~RFCx/rfc4291#section-2.2$
（ § ~addressの~text表現）にて定義される。
`RFC4291$r
◎
A valid IPv6-address string is defined in the "Text Representation of Addresses" chapter of IP Version 6 Addressing Architecture. [RFC4291]
</p>

<p>
`妥当な不透明な~host@sT
は、
次に挙げる いずれかでなければナラナイ：
◎
A valid opaque-host string must be one of the following:
</p>

<ul>
	<li>
1 個以上の［
次を満たす`~URL単位$
］たちが成す並び
⇒
`禁止~host~cp$でない
◎
one or more URL units excluding forbidden host code points
</li>
	<li>
次の並び：
		<ol>
			<li>
❝[
</li>
			<li>
`妥当な~IPv6~address$sT
</li>
			<li>
❝]
		</li>
	</ol>
◎
U+005B ([), followed by a valid IPv6-address string, followed by U+005D (]).
</li>
</ul>

<p class="note">注記：
これは、
`妥当な~host$sTの定義を成す一部ではない
— それには、
文脈を判別することが要求されるので。
◎
This is not part of the definition of valid host string as it requires context to be distinguished.
</p>

		</section>
		<section id="host-parsing">
<h3 title="Host parsing">3.5. ~hostの構文解析-法</h3>

<div class="algo">
<p>
`~host構文解析器@
は、
所与の
( `~scalar値~文字列$ %入力, 真偽値 %不透明か （省略時は ~F ） )
に対し，［
`失敗^i ／`~host$
］を返す：
◎
The host parser takes a scalar value string input with an optional boolean isOpaque (default false), and then runs these steps. They return failure or a host.
</p>
<ol>
	<li>
<p>
~IF［
%入力 の先頭 ~EQ ❝[
］：
◎
If input starts with U+005B ([), then:
</p>
		<ol>
			<li>
~IF［
%入力 の末尾 ~NEQ ❝]
］
⇒＃
`検証~error$( `IPv6-unclosed$err )；
~RET `失敗^i
◎
If input does not end with U+005D (]), IPv6-unclosed validation error, return failure.
</li>
			<li>
~RET `~IPv6構文解析器$( %入力 から先頭の ❝[ と末尾の ❝] を除去した結果 )
◎
Return the result of IPv6 parsing input with its leading U+005B ([) and trailing U+005D (]) removed.
</li>
		</ol>
	</li>
	<li>
~IF［
%不透明か ~EQ ~T
］
⇒
~RET `不透明な~host構文解析器$( %入力 )
◎
If isOpaque is true, then return the result of opaque-host parsing input.
</li>
	<li>
~Assert：
%入力 ~NEQ 空~文字列
◎
Assert: input is not the empty string.
</li>
	<li>
<p>
%~domain ~LET `~BOMはそのままに~UTF-8復号する$( `文字列を~byte列に~percent-復号する$( %入力 ) )
◎
Let domain be the result of running UTF-8 decode without BOM on the percent-decoding of input.
</p>

<p class="note">注記：
別法として、
`~BOMも失敗-もそのままに~UTF-8復号する$~algoを利用した上で，
`失敗^i 時には早々に ~RET することもできる
— `~domainを~ASCII化する$のは
`FFFD^U `REPLACEMENT CHARACTER^cn 【！(�)】
に対し失敗するので。
◎
Alternatively UTF-8 decode without BOM or fail can be used, coupled with an early return for failure, as domain to ASCII fails on U+FFFD (�).
</p>
	</li>
	<li>
%~ASCII~domain ~LET `~domainを~ASCII化する$( %~domain, ~F )
◎
Let asciiDomain be the result of running domain to ASCII with domain and false.
</li>
	<li>
~IF［
%~ASCII~domain ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If asciiDomain is failure, then return failure.
</li>
	<li>
~IF［
`番号で終端しているか検査する$( %~ASCII~domain ) ~EQ ~T
］
⇒
~RET `~IPv4構文解析器$( %~ASCII~domain )
◎
If asciiDomain ends in a number, then return the result of IPv4 parsing asciiDomain.
</li>
	<li>
~RET %~ASCII~domain
◎
Return asciiDomain.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`番号で終端しているか検査する@
~algoは、
所与の
( `~ASCII文字列$ %入力 )
に対し，真偽値を返す：
◎
The ends in a number checker takes an ASCII string input and then runs these steps. They return a boolean.
</p>
<ol>
	<li>
%成分p~list ~LET `区切子で厳密に分割する$( %入力, ❝. )
◎
Let parts be the result of strictly splitting input on U+002E (.).
</li>
	<li>
<p>
~IF［
%成分p~list の最後の`~item$ ~EQ 空~文字列
］：
◎
If the last item in parts is the empty string, then:
</p>
		<ol>
			<li>
~IF［
%成分p~list の`~size$ ~EQ 1
］
⇒
~RET ~F
◎
If parts’s size is 1, then return false.
</li>
			<li>
%成分p~list から最後の`~item$を`除去する$
◎
Remove the last item from parts.
</li>
		</ol>
	</li>
	<li>
%最後の~item ~LET %成分p~list の最後の`~item$
◎
Let last be the last item in parts.
</li>
	<li>
<p>
~IF［
%最後の~item は 1 個以上の`~ASCII数字$のみからなる
］
⇒
~RET ~T
◎
If last is non-empty and contains only ASCII digits, then return true.
</p>

<p class="note">注記：
~error含みの入力 `09^l は、
後の段にて`~IPv4構文解析器$により~catchされることになる。
◎
The erroneous input "09" will be caught by the IPv4 parser at a later stage.
</p>
	</li>
	<li>
<p>
~IF［
`~IPv4番号~構文解析器$( %最後の~item ) ~NEQ `失敗^i
］
⇒
~RET ~T
◎
If parsing last as an IPv4 number does not return failure, then return true.
</p>

<p class="note">注記：
これは、
%最後の~item が次の並びか否か検査することに等価になる
⇒＃
`0X^l または `0x^l,
0 個~以上の`~ASCII~hex数字$
◎
This is equivalent to checking that last is "0X" or "0x", followed by zero or more ASCII hex digits.
</p>
	</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`~IPv4構文解析器@
は、
所与の
( `~ASCII文字列$ %入力 )
に対し，［
`失敗^i ／`~IPv4~address$
］を返す：
◎
The IPv4 parser takes an ASCII string input and then runs these steps. They return failure or an IPv4 address.
</p>

<p class="note">注記：
他の仕様は、
`~IPv4構文解析器$を直に呼出さないこと。
代わりに，［
`~host構文解析器$の返り値が`~IPv4~address$になるかどうか
］を検査すること。
◎
The IPv4 parser is not to be invoked directly. Instead check that the return value of the host parser is an IPv4 address.
</p>
<ol>
	<li>
%成分p~list ~LET `区切子で厳密に分割する$( %入力, ❝. )
◎
Let parts be the result of strictly splitting input on U+002E (.).
</li>
	<li>
<p>
~IF［
%成分p~list 内の最後の`~item$ ~EQ 空~文字列
］：
◎
If the last item in parts is the empty string, then:
</p>
		<ol>
			<li>
`検証~error$( `IPv4-empty-part$err )
◎
IPv4-empty-part validation error.
</li>
			<li>
<p>
~IF［
%成分p~list の`~size$ ~GT 1
］
⇒
%成分p~list から最後の`~item$を`除去する$
</p>

<p class="trans-note">【
%入力 の末尾に余計な ❝. があっても受容されることになる。
】</p>
◎
If parts’s size is greater than 1, then remove the last item from parts.
</li>
		</ol>
	</li>
	<li>
~IF［
%成分p~list の`~size$ ~GT 4
］
⇒＃
`検証~error$( `IPv4-too-many-parts$err )；
~RET `失敗^i
◎
If parts’s size is greater than 4, IPv4-too-many-parts validation error, return failure.
</li>
	<li>
%番号~list ~LET 新たな`~list$
◎
Let numbers be an empty list.
</li>
	<li>
<p>
%成分p~list を成す
~EACH( %成分p )
に対し：
◎
For each part of parts:
</p>
		<ol>
			<li>
%結果 ~LET `~IPv4番号~構文解析器$( %成分p )
◎
Let result be the result of parsing part.
</li>

			<li>
~IF［
%結果 ~EQ `失敗^i
］
⇒＃
`検証~error$( `IPv4-non-numeric-part$err )；
~RET `失敗^i
◎
If result is failure, IPv4-non-numeric-part validation error, return failure.
</li>
			<li>
( %番号, %検証~errorか ) ~LET %結果
◎
↓</li>
			<li>
~IF［
%検証~errorか ~EQ ~T
］
⇒
`検証~error$( `IPv4-non-decimal-part$err )
◎
If result[1] is true, IPv4-non-decimal-part validation error.
</li>
			<li>
%番号~list に %番号 を`付加する$
◎
Append result[0] to numbers.
</li>
		</ol>
	</li>
	<li>
%最後の~index ~LET %番号~list の`~size$ ~MINUS 1
◎
↓</li>
	<li>
<p>
範囲 { 0 〜 %最後の~index } を成す
~EACH( %i )
に対し，昇順に：
</p>
		<ol>
			<li>
~IF［
%番号~list[ %i ] ~LTE 255
］
⇒
~CONTINUE
</li>
			<li>
`検証~error$( `IPv4-out-of-range-part$err )
</li>
			<li>
~IF［
%i ~NEQ %最後の~index
］
⇒
~RET `失敗^i
</li>
		</ol>
◎
If any item in numbers is greater than 255, IPv4-out-of-range-part validation error.
◎
If any but the last item in numbers is greater than 255, then return failure.
</li>
	<li>
~IF［
%番号~list[ %最後の~index ]† ~GTE
( 256 の ( 4 − %最後の~index ) 乗 )
］
⇒
~RET `失敗^i
◎
If the last item in numbers is greater than or equal to 256(5 − numbers’s size), then return failure.
</li>
	<li>
%~IPv4 ~LET %番号~list[ %最後の~index ]
◎
Let ipv4 be the last item in numbers.
</li>
	<li>
%番号~list から最後の`~item$を`除去する$††
◎
Remove the last item from numbers.
</li>
	<li>
%~counter ~LET 0
◎
Let counter be 0.
</li>
	<li>
<p>
%番号~list を成す
~EACH( %n )
に対し：
◎
For each n of numbers:
</p>
		<ol>
			<li>
%~IPv4 ~INCBY ( %n × ( 256 の ( 3 − %~counter ) 乗 ) )
◎
Increment ipv4 by n × 256(3 − counter).
</li>
			<li>
%~counter ~INCBY 1
◎
Increment counter by 1.
</li>
		</ol>
	</li>
	<li>
~RET %~IPv4
◎
Return ipv4.
</li>
</ol>

<p class="trans-note">【†
最後の~itemだけ特別扱い
— 例えば、
`100.100.25600^l は `100.100.100.0^l と等価になり，
`0xFFFFFFFF^l は `255.255.255.255^l と等価になる。
】【††
ここでも、
 %番号~list の~sizeが 4 に満たない場合は）最後の~itemだけ特別扱い
— 例えば、
`100.100^l は `100.0.0.100^l と等価になる。
】</p>
</div>

<div class="algo">
<p>
`~IPv4番号~構文解析器@
は、
所与の
( `~ASCII文字列$ %入力 )
に対し，［
`失敗^i ／
( 番号, 真偽値 ) が成す`~tuple$
］を返す：
◎
The IPv4 number parser takes an ASCII string input and then runs these steps. They return failure or a tuple of a number and a boolean.
</p>
<ol>
	<li>
~IF［
%入力 ~EQ 空~文字列
］
⇒
~RET `失敗^i
◎
If input is the empty string, then return failure.
</li>
	<li>
%検証~errorか ~LET ~F
◎
Let validationError be false.
</li>
	<li>
%R ~LET 10
◎
Let R be 10.
</li>
	<li>
<p>
~IF［
%入力 の長さ ~GTE 2
］~AND［
%入力 の先頭の~cp ~EQ ❝0
］：
</p>
		<ol>
			<li>
%検証~errorか ~SET ~T
</li>
			<li>
%入力 から先頭の~cpを除去する
</li>
			<li>
%R ~SET 8
</li>
			<li>
~IF［
%入力 の先頭の~cp ~IN { ❝X, ❝x }
］
⇒＃
%入力 から先頭の~cpを除去する；
%R ~SET 16
</li>
		</ol>

◎
If input contains at least two code points and the first two code points are either "0X" or "0x", then:
• Set validationError to true.
• Remove the first two code points from input.
• Set R to 16.
◎
Otherwise, if input contains at least two code points and the first code point is U+0030 (0), then:
• Set validationError to true.
• Remove the first code point from input.
• Set R to 8.
</li>
	<li>
<p>
~IF［
%入力 ~EQ 空~文字列
］
⇒
~RET ( 0, ~T )
</p>

<p class="trans-note">【
`0x^l ／ `0X^l が入力されたときも，ここに該当することになる。
】</p>
◎
If input is the empty string, then return (0, true).
</li>
	<li>
~IF［
%入力 内に基数 %R の数字でない~cpが在る
］
⇒
~RET `失敗^i
◎
If input contains a code point that is not a radix-R digit, then return failure.
</li>
	<li>
%出力 ~LET %入力 を基数 %R による表記と~~見なす下で，整数 値として~~解釈した結果
— %R ~EQ 16 の場合、
各桁の`~ASCII~hex数字$を 0 〜 15 の値に対応~付ける下で
◎
Let output be the mathematical integer value that is represented by input in radix-R notation, using ASCII hex digits for digits with values 0 through 15.
</li>
	<li>
~RET ( %出力, %検証~errorか )
◎
Return (output, validationError).
</li>
</ol>

<p class="trans-note">【
`0xAB.012.0X12.12^l
の様な~host名も IPv4 ~addressと見なされ、
`0xAB^l, `0X12^l は 16 進数,
`012^l は 8 進数,
`12^l は 10 進数
として解釈されることになる。
】</p>
</div>

<hr>

<div class="algo">
<p>
`~IPv6構文解析器@
は、
所与の
( `~scalar値~文字列$ %入力 )
に対し，［
`失敗^i ／`~IPv6~address$
］を返す：
◎
The IPv6 parser takes a scalar value string input and then runs these steps. They return failure or an IPv6 address.
</p>

<p class="note">注記：
他の仕様は、
理論~上は，`~IPv6構文解析器$を直に呼出すこともできるが、
実際にそれを行う前に，この文書の編集者たちと論じられたし。
◎
The IPv6 parser could in theory be invoked directly, but please discuss actually doing that with the editors of this document first.
</p>
<ol>
	<li>
%~address ~LET 新たな`~IPv6~address$
— その
⇒
`~piece群$ ~SET « 0, 0, 0, 0, 0, 0, 0, 0 »
◎
Let address be a new IPv6 address whose pieces are all 0.
</li>
	<li>
%~piece~index ~LET 0
◎
Let pieceIndex be 0.
</li>
	<li>
%圧縮-~index ~LET ~NULL
◎
Let compress be null.
</li>
	<li>
%~pointer ~LET %入力 用の`~pointer$
◎
Let pointer be a pointer for input.
</li>
	<li>
<p>
~IF［
`C$V ~EQ ❝:
］：
◎
If c is U+003A (:), then:
</p>
		<ol>
			<li>
~IF［
`C1$V ~NEQ ❝:
］
⇒＃
`検証~error$( `IPv6-invalid-compression$err )；
~RET `失敗^i
◎
If remaining does not start with U+003A (:), IPv6-invalid-compression validation error, return failure.
</li>
	<li>
%~pointer ~INCBY 2
◎
Increase pointer by 2.
</li>
	<li>
%~piece~index ~INCBY 1
◎
Increase pieceIndex by 1 and then＼
</li>
	<li>
%圧縮-~index ~SET %~piece~index
◎
set compress to pieceIndex.
</li>
		</ol>
	</li>
	<li>
<p>
~WHILE ［
`C$V ~NEQ `EOF$i
］：
◎
While c is not the EOF code point:
</p>
		<ol>
			<li>
~IF［
%~piece~index ~EQ 8
］
⇒＃
`検証~error$( `IPv6-too-many-pieces$err )；
~RET `失敗^i
◎
If pieceIndex is 8, IPv6-too-many-pieces validation error, return failure.
</li>
			<li>
<p>
~IF［
`C$V ~EQ ❝:
］：
◎
If c is U+003A (:), then:
</p>
				<ol>
					<li>
~IF［
%圧縮-~index ~NEQ ~NULL
］
⇒＃
`検証~error$( `IPv6-multiple-compression$err )；
~RET `失敗^i
◎
If compress is non-null, IPv6-multiple-compression validation error, return failure.
</li>
					<li>
%~pointer ~INCBY 1
◎
↓</li>
					<li>
%~piece~index ~INCBY 1
◎
Increase pointer and pieceIndex by 1,＼
</li>
					<li>
%圧縮-~index ~SET %~piece~index
◎
set compress to pieceIndex,＼
</li>
					<li>
~CONTINUE
◎
and then continue.
</li>
				</ol>
			</li>
			<li>
%値 ~LET 0
◎
↓</li>
			<li>
%長さ ~LET 0
◎
Let value and length be 0.
</li>
			<li>
~WHILE ［
%長さ ~LT 4
］~AND［
`C$V ~IN `~ASCII~hex数字$
］
⇒＃
%値 ~SET %値 ~MUL `10^X ~PLUS ［ `C$V を~hexadecimal数として解釈した値 ］；
%~pointer ~INCBY 1；
%長さ ~INCBY 1
◎
While length is less than 4 and c is an ASCII hex digit, set value to value × 0x10 + c interpreted as hexadecimal number, and increase pointer and length by 1.
</li>
			<li>
<p>
~IF［
`C$V ~EQ ❝.
］：
◎
If c is U+002E (.), then:
</p>
				<ol>
					<li>
~IF［
%長さ ~EQ 0
］
⇒＃
`検証~error$( `IPv4-in-IPv6-invalid-code-point$err )；
~RET `失敗^i
◎
If length is 0, IPv4-in-IPv6-invalid-code-point validation error, return failure.
</li>
					<li>
%~pointer ~DECBY %長さ
◎
Decrease pointer by length.
</li>
					<li>
~IF［
%~piece~index ~GT 6
］
⇒＃
`検証~error$( `IPv4-in-IPv6-too-many-pieces$err )；
~RET `失敗^i
◎
If pieceIndex is greater than 6, IPv4-in-IPv6-too-many-pieces validation error, return failure.
</li>
					<li>
%~IPv4個数 ~LET 0
◎
Let numbersSeen be 0.
</li>
					<li>
<p>
~WHILE ［
`C$V ~NEQ `EOF$i
］：
◎
While c is not the EOF code point:
</p>
						<ol>
							<li>
%~IPv4~piece ~LET ~NULL
◎
Let ipv4Piece be null.
</li>
							<li>
<p>
~IF［
%~IPv4個数 ~GT 0
］：
◎
If numbersSeen is greater than 0, then:
</p>
								<ol>
									<li>
~IF［
`C$V ~EQ ❝.
］~AND［
%~IPv4個数 ~LT 4
］
⇒
%~pointer ~INCBY 1
◎
If c is a U+002E (.) and numbersSeen is less than 4, then increase pointer by 1.
</li>
									<li>
~ELSE
⇒＃
`検証~error$( `IPv4-in-IPv6-invalid-code-point$err )；
~RET `失敗^i
◎
Otherwise, IPv4-in-IPv6-invalid-code-point validation error, return failure.
</li>
								</ol>
							</li>
							<li>
~IF［
`C$V ~NIN `~ASCII数字$
］
⇒＃
`検証~error$( `IPv4-in-IPv6-invalid-code-point$err )；
~RET `失敗^i【！ prevent the empty string】
◎
If c is not an ASCII digit, IPv4-in-IPv6-invalid-code-point validation error, return failure.
</li>
							<li>
<p>
~WHILE ［
`C$V ~IN `~ASCII数字$
］：
◎
While c is an ASCII digit:
</p>
								<ol>
									<li>
~IF［
%~IPv4~piece ~EQ 0
］
⇒＃
`検証~error$( `IPv4-in-IPv6-invalid-code-point$err )；
~RET `失敗^i
◎
Let number be c interpreted as decimal number.
◎
If ipv4Piece is null, then set ipv4Piece to number.
◎
Otherwise, if ipv4Piece is 0, IPv4-in-IPv6-invalid-code-point validation error, return failure.
</li>
									<li>
~IF［
%~IPv4~piece ~EQ ~NULL
］
⇒
%~IPv4~piece ~SET 0
◎
↑</li>
									<li>
%~IPv4~piece ~SET %~IPv4~piece ~MUL 10 + ［
`C$V を 10 進数として解釈した値
］
◎
Otherwise, set ipv4Piece to ipv4Piece × 10 + number.
</li>
									<li>
~IF［
%~IPv4~piece ~GT 255
］
⇒＃
`検証~error$( `IPv4-in-IPv6-out-of-range-part$err )；
~RET `失敗^i
◎
If ipv4Piece is greater than 255, IPv4-in-IPv6-out-of-range-part validation error, return failure.
</li>
									<li>
%~pointer ~INCBY 1
◎
Increase pointer by 1.
</li>
								</ol>
							</li>
							<li>
%~address[ %~piece~index ] ~SET %~address[ %~piece~index ] ~MUL `100^X ~PLUS %~IPv4~piece
◎
Set address[pieceIndex] to address[pieceIndex] × 0x100 + ipv4Piece.
</li>
							<li>
%~IPv4個数 ~INCBY 1
◎
Increase numbersSeen by 1.
</li>
							<li>
~IF［
%~IPv4個数 ~IN { 2, 4 }
］
⇒
%~piece~index ~INCBY 1
◎
If numbersSeen is 2 or 4, then increase pieceIndex by 1.
</li>
						</ol>
					</li>
					<li>
~IF［
%~IPv4個数 ~NEQ 4
］
⇒＃
`検証~error$( `IPv4-in-IPv6-too-few-parts$err )；
~RET `失敗^i
◎
If numbersSeen is not 4, IPv4-in-IPv6-too-few-parts validation error, return failure.
</li>
					<li>
~BREAK
◎
Break.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
`C$V ~EQ ❝:
］：
◎
Otherwise, if c is U+003A (:):
</p>
				<ol>
					<li>
%~pointer ~INCBY 1
◎
Increase pointer by 1.
</li>
					<li>
~IF［
`C$V ~EQ `EOF$i
］
⇒＃
`検証~error$( `IPv6-invalid-code-point$err )；
~RET `失敗^i
◎
If c is the EOF code point, IPv6-invalid-code-point validation error, return failure.
</li>
				</ol>
			</li>
			<li>
~ELIF［
`C$V ~NEQ `EOF$i
］
⇒＃
`検証~error$( `IPv6-invalid-code-point$err )；
~RET `失敗^i
◎
Otherwise, if c is not the EOF code point, IPv6-invalid-code-point validation error, return failure.
</li>
			<li>
%~address[ %~piece~index ] ~SET %値
◎
Set address[pieceIndex] to value.
</li>
			<li>
%~piece~index ~INCBY 1
◎
Increase pieceIndex by 1.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%圧縮-~index ~NEQ ~NULL
］：
◎
If compress is non-null, then:
</p>
		<ol>
			<li>
%~swap数 ~LET %~piece~index ~MINUS %圧縮-~index
◎
Let swaps be pieceIndex − compress.
</li>
			<li>
%~piece~index ~SET 7
◎
Set pieceIndex to 7.
</li>
			<li>
~WHILE ［
%~piece~index ~NEQ 0
］~AND［
%~swap数 ~GT 0
］
⇒＃
%~address[ %~piece~index ] と %~address[ %圧縮-~index ~PLUS %~swap数 ~MINUS 1 ] の値を~swapする；
%~piece~index ~DECBY 1；
%~swap数 ~DECBY 1
◎
While pieceIndex is not 0 and swaps is greater than 0, swap address[pieceIndex] with address[compress + swaps − 1], and then decrease both pieceIndex and swaps by 1.
</li>
		</ol>
<div class="trans-note">
<p>【
この段は妙にまわりくどい
— 実質的には、
次と等価になる：
</p>
		<ol>
			<li>
%~piece~index ~SET 7
</li>
			<li>
~WHILE ［
%~piece~index ~GT %圧縮-~index
］
⇒＃
%~address[ %~piece~index ] と %~address[ %~piece~index ~MINUS 1 ] の値を~swapする；
%~piece~index ~DECBY 1
◎
While pieceIndex is not 0 and swaps is greater than 0, swap address[pieceIndex] with address[compress + swaps − 1], and then decrease both pieceIndex and swaps by 1.
</li>
		</ol>
<p>
すなわち、
%~address[ 7 ] を %~address[ %圧縮-~index ] へ移動して，
%~address[ %圧縮-~index ] 以降を一つずらしているが、
正しい挙動とは思えない。
本当は、
%~address[ %圧縮-~index ] の直前に必要yな個数の 0 を挿入するべきでは？
— それに伴い、
この~algoの他所も改める必要があるが。
】</p>
</div>
	</li>
	<li>
~ELSE
⇒
~IF［
%~piece~index ~NEQ 8
］
⇒＃
`検証~error$( `IPv6-too-few-pieces$err )；
~RET `失敗^i
◎
Otherwise, if compress is null and pieceIndex is not 8, IPv6-too-few-pieces validation error, return failure.
</li>
	<li>
~RET %~address
◎
Return address.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`不透明な~host構文解析器@
は、
所与の
( `~scalar値~文字列$ %入力 )
に対し，［
`失敗^i ／`不透明な~host$
］を返す：
◎
The opaque-host parser takes a scalar value string input, and then runs these steps. They return failure or an opaque host.
</p>
<ol>
	<li>
~IF［
%入力 内に`禁止~host~cp$が在る
］
⇒＃
`検証~error$( `host-invalid-code-point$err )；
~RET `失敗^i
◎
If input contains a forbidden host code point, host-invalid-code-point validation error, return failure.
</li>
	<li>
~IF［
%入力 内に［
`~URL~cp$, `%^l
］以外の`~cp$が在る
］
⇒
`検証~error$( `invalid-URL-unit$err )
◎
If input contains a code point that is not a URL code point and not U+0025 (%), invalid-URL-unit validation error.
</li>
	<li>
~IF［
%入力 内に［
2 個の`~ASCII~hex数字$が後続していない `%^l
］が在る
］
⇒
`検証~error$( `invalid-URL-unit$err )
◎
If input contains a U+0025 (%) and the two code points following it are not ASCII hex digits, invalid-URL-unit validation error.
</li>
	<li>
~RET `文字列を~UTF-8~percent-符号化する$( %入力, `~C0制御文字~percent-符号化-集合$ )
◎
Return the result of running UTF-8 percent-encode on input using the C0 control percent-encode set.
</li>
</ol>
</div>

		</section>
		<section id="host-serializing">
<h3 title="Host serializing">3.6. ~hostの直列化-法</h3>

<div class="algo">
<p>
`~hostを直列化する@
~algoは、
所与の
( `~host$ %~host )
に対し，`~ASCII文字列$を返す：
◎
The host serializer takes a host host and then runs these steps. They return an ASCII string.
</p>
<ol>
	<li>
<p>
%~host の種別に応じて：
◎
↓</p>
		<ul class="switch">
			<li>
`~IPv4~address$
⇒
~RET `~IPv4直列化器$( %~host )
◎
If host is an IPv4 address, return the result of running the IPv4 serializer on host.
</li>
			<li>
`~IPv6~address$
⇒
~RET ❝[ ~APPEND `~IPv6直列化器$( %~host ) ~APPEND ❝]
◎
Otherwise, if host is an IPv6 address, return U+005B ([), followed by the result of running the IPv6 serializer on host, followed by U+005D (]).
</li>
			<li>
`~domain$ ／
`不透明な~host$ ／
`空~host$
⇒
~RET %~host
◎
Otherwise, host is a domain, opaque host, or empty host, return host.
</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~IPv4直列化器@
は、
所与の
( `~IPv4~address$ %~address )
に対し，
`~ASCII文字列$を返す：
◎
The IPv4 serializer takes an IPv4 address address and then runs these steps. They return an ASCII string.
</p>

<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
%n ~LET %~address
◎
Let n be the value of address.
</li>
	<li>
<p>
{ 1 〜 4 } を成す
~EACH( %i )
に対し，昇順に：
◎
For each i in the range 1 to 4, inclusive:
</p>
		<ol>
			<li>
%出力 ~SET 
`整数を直列化する$( %n を 256 で割った余り ) ~APPEND %出力
◎
Prepend n % 256, serialized, to output.
</li>
			<li>
~IF［
%i ~NEQ 4
］
⇒
❝. を %出力 の先頭に~~挿入する
◎
If i is not 4, then prepend U+002E (.) to output.
</li>
			<li>
%n ~SET floor( %n ~DIV 256 )
◎
Set n to floor(n / 256).
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~IPv6直列化器@
は、
所与の
( `~IPv6~address$ %~address )
に対し，
`~ASCII文字列$を返す：
◎
The IPv6 serializer takes an IPv6 address address and then runs these steps. They return an ASCII string.
</p>
<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
%圧縮-~index ~LET `~IPv6~addressの圧縮された~piece~indexを見出す$( %~address )
◎
Let compress be the result of finding the IPv6 address compressed piece index given address.
</li>
	<li>
%無視するか ~LET ~F
◎
Let ignore0 be false.
</li>
	<li>
<p>
%~address の`~piece群$の`~index群$を成す
~EACH( %~piece~index )
に対し：
◎
For each pieceIndex of address’s pieces’s indices:
</p>
		<ol>
			<li>
~IF［
%無視するか ~EQ ~T
］~AND［
%~address[ %~piece~index ] ~EQ 0
］
⇒
~CONTINUE
◎
If ignore0 is true and address[pieceIndex] is 0, then continue.
</li>
			<li>
%無視するか ~SET ~F
◎
Otherwise, if ignore0 is true, set ignore0 to false.
</li>
			<li>
<p>
~IF［
%圧縮-~index ~EQ %~piece~index
］：
◎
If compress is pieceIndex, then:
</p>
				<ol>
					<li>
%出力 ~APPEND ［
%~piece~index ~EQ 0 ならば `::^l ／
~ELSE_ `:^l
］
◎
Let separator be "::" if pieceIndex is 0; otherwise U+003A (:).
◎
Append separator to output.
</li>
					<li>
%無視するか ~SET ~T
◎
Set ignore0 to true and continue.
</li>
					<li>
~CONTINUE
◎
↑</li>
				</ol>
			</li>
			<li>
%出力 ~APPEND 次を満たす最短な文字列
⇒
%~address[ %~piece~index ] を小文字~hexadecimal数で表現している
◎
Append address[pieceIndex], represented as the shortest possible lowercase hexadecimal number, to output.
</li>
			<li>
~IF［
%~piece~index ~NEQ 7
］
⇒
%出力 ~APPEND ❝:
◎
If pieceIndex is not 7, then append U+003A (:) to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
この~algoは、
`A Recommendation for IPv6 Address Text Representation^cite
（~IPv6~addressの推奨~表記）への準拠を要求する。
`RFC5952$r
【参考：`~IPv6~address表記の柔軟性が起こす問題と RFC5952 の解説＠http://www.nic.ad.jp/ja/newsletter/No46/0800.html$】

◎
This algorithm requires the recommendation from A Recommendation for IPv6 Address Text Representation. [RFC5952]
</p>
</div>

<div class="algo">
<p>
`~IPv6~addressの圧縮された~piece~indexを見出す@
~algoは、
所与の
( `~IPv6~address$ %~address )
に対し：
◎
To find the IPv6 address compressed piece index given an IPv6 address address:
</p>
<ol>
	<li>
%最長~index ~LET ~NULL
◎
Let longestIndex be null.
</li>
	<li>
%最長~size ~LET 1
◎
Let longestSize be 1.
</li>
	<li>
%見出された~index ~LET ~NULL
◎
Let foundIndex be null.
</li>
	<li>
%見出された~size ~LET 0
◎
Let foundSize be 0.
</li>
	<li>
<p>
%~address の`~piece群$の`~index群$を成す
~EACH( %~piece~index )
に対し：
◎
For each pieceIndex of address’s pieces’s indices:
</p>
		<ol>
			<li>
<p>
~IF［
%~address の`~piece群$[ %~piece~index ] ~NEQ 0
］：
◎
If address’s pieces[pieceIndex] is not 0:
</p>
				<ol>
					<li>
~IF［
%見出された~size ~GT %最長~size
］
⇒＃
%最長~index ~SET %見出された~index；
%最長~size ~SET %見出された~size
◎
If foundSize is greater than longestSize, then set longestIndex to foundIndex and longestSize to foundSize.
</li>
					<li>
%見出された~index ~SET ~NULL
◎
Set foundIndex to null.
</li>
					<li>
%見出された~size ~SET 0
◎
Set foundSize to 0.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~IF［
%見出された~index ~EQ ~NULL
］
⇒
%見出された~index ~SET %~piece~index
◎
If foundIndex is null, then set foundIndex to pieceIndex.
</li>
					<li>
%見出された~size ~INCBY 1
◎
Increment foundSize by 1.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
%見出された~size ~GT %最長~size
］
⇒
~RET %見出された~index
◎
If foundSize is greater than longestSize, then return foundIndex.
</li>
	<li>
~RET %最長~index
◎
Return longestIndex.
</li>
</ol>

<p class="example">
例えば， `0:f:0:0:f:f:0:0^l に対しては、
2 個目の 0 を指す~indexを返すことになる。
◎
In 0:f:0:0:f:f:0:0 it would point to the second 0.
</p>
</div>

		</section>
		<section id="host-equivalence">

<h3 title="Host equivalence">3.7. ~hostの等価性</h3>

<div class="algo">
<p>
2 つの`~host$ ( %A, %B ) は、
次を満たすとき, そのときに限り
`同等な~host@
であるとされる
⇒
%A と %B は【互いの型が一致する, かつ値も】等しい
◎
To determine whether a host A equals host B, return true if A is B, and false otherwise.
</p>
</div>

<p class="XXX">課題：
証明書の比較には、［
~domainの尾部の~dotは無視する
］ような，~hostの等価性の検査が要求される。
しかしながら、
それらの~hostには，
ここでは施行されない~DNS長さなどの 他の種々の側面fも施行される
— ~URLはそれらを施行しないので。
これら 2 つを近づけるような, あるいは
統一化~modelとして何か良い示唆があれば，課題を申請されたし。
◎
Certificate comparison requires a host equivalence check that ignores the trailing dot of a domain (if any). However, those hosts have also various other facets enforced, such as DNS length, that are not enforced here, as URLs do not enforce them. If anyone has a good suggestion for how to bring these two closer together, or what a good unified model would be, please file an issue.
</p>

		</section>
	</section>
	<section id="urls">
<h2 title="URLs">4. ~URL</h2>

<p>
高~levelからは、［
`~URL~record$,
`妥当な~URL$sT,
`~URL構文解析器$,
`~URL直列化器$
］は，次のように関係する：
◎
At a high level, a URL, valid URL string, URL parser, and URL serializer relate as follows:
</p>

<ul>
	<li>
`~URL構文解析器$は、
任意な`~scalar値~文字列$に対し，［
`失敗^i, または `~URL~record$
］を返す。
また、
生じた各`検証~error$も記録する。
◎
The URL parser takes an arbitrary scalar value string and returns either failure or a URL. It might also record zero or more validation errors.
</li>
	<li>
`~URL~record$は、
~memory内の表現と捉えることもできる。
◎
A URL can be seen as the in-memory representation.
</li>
	<li>
`妥当な~URL$sTは、
`~URL構文解析器$にかけたときに，`検証~error$や `失敗^i を誘発しない
— すなわち、［
適合する／妥当である
］と見なされる —
ような入力を定義する。
◎
A valid URL string defines what input would not trigger a validation error or failure when given to the URL parser. I.e., input that would be considered conforming or valid.
</li>
	<li>
`~URL直列化器$は、
~~入力の`~URL~record$に対し，`~ASCII文字列$を返す。
（その文字列をさらに`~URL構文解析器$にかけた結果は、
~~元の`~URL~record$と`同等な~URL$になる。）
`~URL直列化器$の出力は、
常に`妥当な~URL$sTになるとは限らない。
◎
The URL serializer takes a URL and returns an ASCII string. (If that string is then parsed, the result will equal the URL that was serialized.) The output of the URL serializer is not always a valid URL string.
</li>
</ul>

<div class="example" id="example-url-parsing" style="overflow:auto">
<table class="grid-table" id="_ex-url-validity"><thead>
<tr><th>
入力~URL
◎
Input
<th>
基底~URL
◎
Base
<th>
妥当か？
◎
Valid
<th>
出力~URL
◎
Output
<tbody>

<tr><td>`https:example.org^c
<td>
<td>❌
<td>`https://example.org/^c

<tr><td>`https://////example.com///^c
<td>
<td>❌
<td>`https://example.com///^c

<tr><td>`https://example.com/././foo^c
<td>
<td>✅
<td>`https://example.com/foo^c

<tr><td>`hello:world^c
<td>`https://example.com/^c
<td>✅
<td>`hello:world^c

<tr><td>`https:example.org^c
<td>`https://example.com/^c
<td>❌
<td>`https://example.com/example.org^c

<tr><td>`\example\..\demo/.\^c
<td>`https://example.com/^c
<td>❌
<td>`https://example.com/demo/^c

<tr><td>`example^c
<td>`https://example.com/demo^c
<td>✅
<td>`https://example.com/example^c

<tr><td>`file:///C|/demo^c
<td>
<td>❌
<td>`file:///C:/demo^c

<tr><td>`..^c
<td>`file:///C:/demo^c
<td>✅
<td>`file:///C:/^c

<tr><td>`file://loc%61lhost/^c
<td>
<td>✅
<td>`file:///^c

<tr><td>`https://user:password~at々example.org/^c
<td>
<td>❌
<td>`https://user:password~at々example.org/^c

<tr><td>`https://example.org/foo bar^c
<td>
<td>❌
<td>`https://example.org/foo%20bar^c

<tr><td>`https://EXAMPLE.com/../x^c
<td>
<td>✅
<td>`https://example.com/x^c

<tr><td>`https://ex ample.org/^c
<td>
<td>❌
<td>`失敗^i

<tr><td>`example^c
<td>
<td title="due to lack of base">❌†
<td>`失敗^i

<tr><td>`https://example.com:demo^c
<td>
<td>❌
<td>`失敗^i

<tr><td>`http://[www.example.com]/^c
<td>
<td>❌
<td>`失敗^i

<tr><td>`https://example.org//^c
<td>
<td>✅
<td>`https://example.org//^c

<tr><td>`https://example.com/[]?[]#[]^c
<td>
<td>❌
<td>`https://example.com/[]?[]#[]^c

<tr><td>`https://example/%?%#%^c
<td>
<td>❌
<td>`https://example/%?%#%^c

<tr><td>`https://example/%25?%25#%25^c
<td>
<td>✅
<td>`https://example/%25?%25#%25^c

</table>

<p>
簡潔にするため、
ここでの［
基底／出力
］`~URL$は，`~URL直列化器$にかけた結果で表現されている。
◎
The base and output URL are represented in serialized form for brevity.
</p>

<small>†
— 基底~URLを欠くことに因り妥当でない。
</small>
</div>

		<section id="url-representation">
<h3 title="URL representation">4.1. ~URL表現</h3>

<p>
`~URL@
は、
以下に挙げる~itemからなる`構造体$であり，
普遍的な識別子を表現する。
`妥当な~URL$sTと区別するため、
`~URL~record$とも称される：
◎
A URL is a struct that represents a universal identifier. To disambiguate from a valid URL string it can also be referred to as a URL record.
</p>
<dl class="def-list">
	<dt>
`~scheme@url
◎
A URL’s scheme＼
</dt>
	<dd>
`~ASCII文字列$
◎
is an ASCII string＼
</dd>
	<dd>
`~URL$の種別を識別する
— `~URL構文解析器$にかけた後の，更なる分岐処理に利用され得る。
◎
that identifies the type of URL and can be used to dispatch a URL for further processing after parsing.＼
</dd>
	<dd>
初期~時は空~文字列とする。
◎
It is initially the empty string.
</dd>

	<dt>
`~username@url
◎
A URL’s username＼
</dt>
	<dd>
`~ASCII文字列$
◎
is an ASCII string＼
</dd>
	<dd>
~usernameを識別する。
◎
identifying a username.＼
</dd>
	<dd>
初期~時は空~文字列とする。
◎
It is initially the empty string.
</dd>

	<dt>
`~password@url
◎
A URL’s password＼
</dt>
	<dd>
`~ASCII文字列$
◎
is an ASCII string＼
</dd>
	<dd>
~passwordを識別する。
◎
identifying a password.＼
</dd>
	<dd>
初期~時は空~文字列とする。
◎
It is initially the empty string.
</dd>

	<dt>
`~host@url
◎
A URL’s host＼
</dt>
	<dd>
~NULL ／
`~host$
◎
is null or a host.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
It is initially null.
</dd>
	<dd class="note">
<p>注記：
`~URL$に許容される［
`~scheme$url, `~host$url
］の組合nを次の表tに挙げる。
</p>

<table><thead>
<tr><th rowspan="2">`~scheme$url
<th colspan="6">`~host$url
<tr id="_combi-host-types">
<th>`~domain$
<th>`~IPv4~address$
<th>`~IPv6~address$
<th>`不透明な~host$
<th>`空~host$
<th>~NULL
<tbody>

<tr><td>`file^l 以外の`特別~scheme$
<td>✅ <td>✅ <td>✅ <td>❌ <td>❌ <td>❌

<tr><td>`file^l
<td>✅ <td>✅ <td>✅ <td>❌ <td>✅ <td>❌

<tr><td>その他
<td>❌ <td>❌ <td>✅ <td>✅ <td>✅ <td>✅
</table>

◎
The following table lists allowed URL’s scheme / host combinations.
◎
scheme｜host
｜domain｜IPv4 address｜IPv6 address｜opaque host｜empty host｜null
Special schemes excluding "file"｜✅｜✅｜✅｜❌｜❌｜❌
"file"｜✅｜✅｜✅｜❌｜✅｜❌
Others｜❌｜❌｜✅｜✅｜✅｜✅
</dd>

	<dt>
`~port@url
◎
A URL’s port＼
</dt>
	<dd>
~NULL ／
`16 ~bitな無符号~整数$
◎
is either null or a 16-bit unsigned integer＼
</dd>
	<dd>
~NULL 以外は、
~network用の~portを識別する。
◎
that identifies a networking port.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
It is initially null.
</dd>

	<dt>
`~path@url
◎
A URL’s path＼
</dt>
	<dd>
`~URL~path$
◎
is a URL path,＼
</dd>
	<dd>
通例的には、
資源の所在を識別する。
◎
usually identifying a location.＼
</dd>
	<dd>
初期~時は « » とする。
◎
It is initially « ».
</dd>
	<dd class="note">注記：
`~URL$が`特別$である場合、
その`~path$urlは常に`~list$になり，
`不透明な~path$を有することは決してない。
◎
A special URL’s path is always a list, i.e., it is never opaque.
</dd>

	<dt>
`~query@url
◎
A URL’s query＼
</dt>
	<dd>
~NULL ／
`~ASCII文字列$
◎
is either null or an ASCII string.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
It is initially null.
</dd>

	<dt>
`素片@url
◎
A URL’s fragment＼
</dt>
	<dd>
~NULL ／
`~ASCII文字列$
◎
is either null or an ASCII string＼
</dd>
	<dd>
~NULL 以外は、［
`~URL$を成す他の成分により識別される資源
］を更に処理するために利用され得る。
◎
that can be used for further processing on the resource the URL’s other components identify.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
It is initially null.
</dd>
</dl>

<p>
各`~URL$には、
`~blob~URL~entry@url
も結付けられる。
それは、［
~NULL ／`~blob~URL~entry$
］であり，初期~時は ~NULL とする。
◎
A URL also has an associated blob URL entry that is either null or a blob URL entry. It is initially null.
</p>

<p class="note">注記：
これは、［
`blob^l ~URLが指している~objを その生成元とともに~cacheする
］ことを~supportするために利用される。
これらを~cacheすることは、
重要になる
— そのような`~URL$は、
構文解析してから~fetchするまでの間に `~blob~URL~store$から除去されるかもしれない一方で，
~fetchingは成功する必要があるので。
◎
This is used to support caching the object a "blob" URL refers to as well as its origin. It is important that these are cached as the URL might be removed from the blob URL store between parsing and fetching, while fetching will still need to succeed.
</p>

<div class="example">

<p>
`妥当な~URL$sTを`~URL構文解析器$にかけた結果が`~URL~record$の各~成分にどう対応付けられるかを，次の表tに挙げる。
この表tから省略された［
`~username$url／
`~password$url／
`~blob~URL~entry$url
］は、
この例では，どれも［
空~文字列／空~文字列／~NULL
］になる。
◎
The following table lists how valid URL strings, when parsed, map to a URL’s components. Username, password, and blob URL entry are omitted; in the examples below they are the empty string, the empty string, and null, respectively.
</p>

<div style="overflow:auto;">
<table class="grid-table" id="_ex-url-components"><thead>
<tr><th>入力
<th>`~scheme$url
<th>`~host$url
<th>`~port$url
<th>`~path$url
<th>`~query$url
<th>`素片$url
<tbody>

<tr><td>`https://example.com/^c
<td>`https^l
<td>`example.com^l
<td>~NULL
<td>« 空~文字列 »
<td>~NULL
<td>~NULL

<tr><td>`https://localhost:8000/search?q=text#hello^c
<td>`https^l
<td>`localhost^l
<td>8000
<td>« `search^l »
<td>`q=text^l
<td>`hello^l

<tr><td>`urn:isbn:9780307476463^c
<td>`urn^l
<td>~NULL
<td>~NULL
<td>`isbn:9780307476463^l
<td>~NULL
<td>~NULL

<tr><td>`file:///ada/Analytical%20Engine/README.md^c
<td>`file^l
<td>~NULL
<td>~NULL
<td>« `ada^l, `Analytical%20Engine^l, `README.md^l »
<td>~NULL
<td>~NULL
</table>

◎
• Input｜Scheme｜Host｜Port｜Path｜Query｜Fragment
• https://example.com/｜"https"｜"example.com"｜null｜« the empty string »｜null｜null
• https://localhost:8000/search?q=text#hello｜"https"｜"localhost"｜8000｜« "search" »｜"q=text"｜"hello"
• urn:isbn:9780307476463｜"urn"｜null｜null｜"isbn:9780307476463"｜null｜null
• file:///ada/Analytical%20Engine/README.md｜"file"｜null｜null｜« "ada", "Analytical%20Engine", "README.md" »｜null｜null
</div>
</div>

<p>
`~URL~path@
は、
次のいずれかである
⇒＃
`~URL~path区分$ ／
`~URL~path区分$たちが成す`~list$
◎
A URL path is either a URL path segment or a list of zero or more URL path segments.
</p>

<p>
`~URL~path区分@
は、
`~ASCII文字列$である。
それは、
ある［
~directory／~file
］を指すことが多いが，定義済みな意味は無い。
◎
A URL path segment is an ASCII string. It commonly refers to a directory or a file, but has no predefined meaning.
</p>

<p>
`単-~dot~URL~path区分@
は、
次を満たす`~URL~path区分$である
⇒
`~ASCII大小無視$で［
`.^l ／ `%2e^l
］に合致する
◎
A single-dot URL path segment is a URL path segment that is "." or an ASCII case-insensitive match for "%2e".
</p>

<p>
`二重-~dot~URL~path区分@
は、
次を満たす`~URL~path区分$である
⇒
`~ASCII大小無視$で［
`..^l ／ `.%2e^l ／ `%2e.^l ／ `%2e%2e^l
］に合致する
◎
A double-dot URL path segment is a URL path segment that is ".." or an ASCII case-insensitive match for ".%2e", "%2e.", or "%2e%2e".
</p>

		</section>
		<section id="url-miscellaneous">
<h3 title="URL miscellaneous">4.2. ~URLのその他諸々</h3>

<p>
`特別~scheme@
とは、
次の表tの 1 列目に挙げられる`~ASCII文字列$である。
各`特別~scheme$用の
`既定~port@
は、
表tの同じ行の 2 列目に挙げられる
— 他の`~ASCII文字列$用の`既定~port$は ~NULL とする。
◎
A special scheme is an ASCII string that is listed in the first column of the following table. The default port for a special scheme is listed in the second column on the same row. The default port for any other ASCII string is null. 
</p>

<table><thead>
<tr><th>`特別~scheme$
<th>`既定~port$
<tbody>

<tr><td>`ftp^l
<td>21

<tr><td>`file^l
<td>~NULL

<tr><td>`http^l
<td>80

<tr><td>`https^l
<td>443

<tr><td>`ws^l
<td>80

<tr><td>`wss^l
<td>443
</table>

<p>
所与の`~URL$が
`特別@
であるとは、
その`~scheme$urlは`特別~scheme$であることをいう。
◎
A URL is special if its scheme is a special scheme. A URL is not special if its scheme is not a special scheme.
</p>

<p class="trans-note">【
原文では，一体句としての
`特別でない＠#is-not-special@
が “`特別$である” の否定として定義されているが、
この訳では利用しない
（単に “`特別$<em>でない</em>” と記すことにする）。
】</p>

<p>
`~URL$が
`資格証を含んで@
いるとは、
次を満たすことをいう
⇒
［
その`~username$url ~NEQ 空~文字列
］~OR［
その`~password$url ~NEQ 空~文字列
］
◎
A URL includes credentials if its username or password is not the empty string.
</p>

<p class="trans-note">【（参考）
~HTTP仕様の
<a href="~HTTPinfra#http.userinfo">§ `userinfo^P の非推奨化</a>
に~securityに関する記述がある。
】</p>

<p>
`~URL$が
`不透明な~path@
を有するとは、
次を満たすことをいう
⇒
その`~path$urlは`~URL~path区分$である【~listでない】
◎
A URL has an opaque path if its path is a URL path segment.
</p>

<p>
`~URL$が
`~username／~password／~portを有し得ない@
とは、
次を満たすことをいう
⇒
［
その`~host$url ~IN { ~NULL, 空~文字列 }
］~OR［
その`~scheme$url ~EQ `file^l
］
◎
A URL cannot have a username/password/port if its host is null or the empty string, or its scheme is "file".
</p>

<p>
`~URL$は
`基底~URL@
であるものと指名されることもある。
◎
A URL can be designated as base URL.
</p>

<p class="note">注記：
`基底~URL$は、
`~URL構文解析器$において，`相対~URL$sTも入力にとり得るときに有用になる。
◎
A base URL is useful for the URL parser when the input might be a relative-URL string.
</p>

<hr>

<p>
`~drive_letter@
とは、
次を満たす 2 個の~cpが成す並びである
⇒
［
1 個目の~cp ~IN `~ASCII英字$
］~AND［
2 個目の~cp ~IN { ❝:, ❝| }
］
◎
A Windows drive letter is two code points, of which the first is an ASCII alpha and the second is either U+003A (:) or U+007C (|).
</p>

<p>
`正規化-済み~drive_letter@
とは、
`~drive_letter$のうち，次を満たすものである
⇒
2 個目の~cp ~EQ ❝:
◎
A normalized Windows drive letter is a Windows drive letter of which the second code point is U+003A (:).
</p>

<p class="note">注記：
`§ ~URLの書出法＠#url-writing$により、
適合するものは`正規化-済み~drive_letter$に限られる。
◎
As per the URL writing section, only a normalized Windows drive letter is conforming.
</p>

<p>
3 個の［
~cp ／ `EOF$i
］たちが成す並び［
%C0, %C1, %C2
］が
`~drive_letterから開始して@
いるとは、
~AND↓ を満たすことをいう：
◎
A string starts with a Windows drive letter if all of the following are true:
</p>
<ul>
	<li>
並び［
%C0, %C1
］は`~drive_letter$である（特に，いずれも `EOF$i でない）
◎
its length is greater than or equal to 2
◎
its first two code points are a Windows drive letter
</li>
	<li>
%C2 ~IN { `EOF$i, ❝/, ❝\, ❝?, ❝# }
◎
its length is 2 or its third code point is U+002F (/), U+005C (\), U+003F (?), or U+0023 (#).
</li>
</ul>

<div class="example">
<table><tbody>
<tr><th>並びが成す文字列
<th>~drive_letterから開始しているか？

<tr><td>`c:^l
<td>✅

<tr><td>`c:/^l
<td>✅

<tr><td>`c:a^l
<td>❌
</table>
◎
String｜Starts with a Windows drive letter
"c:"｜✅
"c:/"｜✅
"c:a"｜❌
</div>

<div class="algo">
<p>
%~URL の
`~pathを短縮する@
~algoは：
◎
To shorten a url’s path:
</p>
<ol>
	<li>
~Assert：
%~URL は`不透明な~path$を有さない。
◎
Assert: url does not have an opaque path.
</li>
	<li>
%~path ~LET %~URL の`~path$url
◎
Let path be url’s path.
</li>
	<li>
~IF［
%~URL の`~scheme$url ~EQ `file^l
］~AND［
%~path の`~size$ ~EQ 1
］~AND［
%~path[ 0 ] は`正規化-済み~drive_letter$である
］
⇒
~RET
◎
If url’s scheme is "file", path’s size is 1, and path[0] is a normalized Windows drive letter, then return.
</li>
	<li>
~IF［
%~path は`空$でない
］
⇒
%~path から最後の~itemを`除去する$
◎
Remove path’s last item, if any.
</li>
</ol>
</div>

		</section>
		<section id="url-writing">
<h3 title="URL writing">4.3. ~URLの書出法</h3>

<p>
以下において，“省略可能” と記された部分は省略できる／され得ることを意味する（すなわち， 0 個, または 1 個）。
◎
↓</p>

<div>
<p>
`妥当な~URL@sT
は、
次のいずれかでなければナラナイ：
◎
A valid URL string must be either＼
</p>
<ul>
	<li>
`素片~付き相対~URL$sT
◎
a relative-URL-with-fragment string＼
</li>
	<li>
`素片~付き絶対~URL$sT
◎
or an absolute-URL-with-fragment string.
</li>
</ul>
</div>

<div>
<p>
`素片~付き絶対~URL@sT
は、
次の並びでなければナラナイ：
◎
An absolute-URL-with-fragment string must be＼
</p>
<ol>
	<li>
`絶対~URL$sT
◎
an absolute-URL string,＼
</li>
	<li>
<p>
省略可能な，次の並び：
</p>
		<ol>
			<li>
❝#
</li>
			<li>
`~URL素片$sT
</li>
		</ol>
◎
optionally followed by U+0023 (#) and a URL-fragment string.
</li>
</ol>
</div>

<div>
<p>
`絶対~URL@sT
は、
次の並びでなければナラナイ：
◎
An absolute-URL string must be＼
</p>
<ol>
	<li>
<p>
次のいずれか：
◎
one of the following:
</p>
		<ul>
			<li>
<p>
次の並び：
◎
↓</p>
				<ol>
					<li>
`~URL~scheme$sTであって，［
`file^l 以外の`特別~scheme$
］に`~ASCII大小無視$で合致するもの
◎
a URL-scheme string that is an ASCII case-insensitive match for a special scheme and not an ASCII case-insensitive match for "file",＼
</li>
					<li>
❝:
◎
followed by U+003A (:)＼
</li>
					<li>
`~scheme相対~特別~URL$sT
◎
and a scheme-relative-special-URL string
</li>
				</ol>
			</li>
			<li>
<p>
次の並び：
◎
↓</p>
				<ol>
					<li>
`~URL~scheme$sTであって，`特別~scheme$に`~ASCII大小無視$で<em>合致しない</em>もの
◎
a URL-scheme string that is not an ASCII case-insensitive match for a special scheme,＼
</li>
					<li>
❝:
◎
followed by U+003A (:)＼
</li>
					<li>
`相対~URL$sT
◎
and a relative-URL string
</li>
				</ol>
			</li>
			<li>
<p>
次の並び：
◎
↓</p>
				<ol>
					<li>
`~URL~scheme$sTであって， `file^l に`~ASCII大小無視$で合致するもの
◎
a URL-scheme string that is an ASCII case-insensitive match for "file",＼
</li>
					<li>
❝:
◎
followed by U+003A (:)＼
</li>
					<li>
`~scheme相対~file~URL$sT
◎
and a scheme-relative-file-URL string
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
<p>
省略可能な，次の並び：
◎
any optionally followed by＼
</p>
		<ol>
			<li>
❝?
◎
U+003F (?)＼
</li>
			<li>
`~URL~query$sT
◎
and a URL-query string.
</li>
		</ol>
	</li>
</ol>
</div>

<div>
<p>
`~URL~scheme@sT
は、
次の並びでなければナラナイ：
◎
A URL-scheme string must be＼
</p>
<ol>
	<li>
1 個の`~ASCII英字$
◎
one ASCII alpha,＼
</li>
	<li>
0 個以上の次に挙げる~cpたちが成す並び
⇒＃
`~ASCII英数字$,
❝+,
❝-,
❝.
◎
followed by zero or more of ASCII alphanumeric, U+002B (+), U+002D (-), and U+002E (.).＼
</li>
</ol>

<p>
`~URL~scheme$sT
は、
`IANA URI [sic] Schemes^cite ~registryに登録されるベキである。
`IANA-URI-SCHEMES$r
`RFC7595$r
◎
Schemes should be registered in the IANA URI [sic] Schemes registry. [IANA-URI-SCHEMES] [RFC7595]
</p>
</div>

<div>
<p>
`素片~付き相対~URL@sT
は、
次の並びでなければナラナイ：
◎
A relative-URL-with-fragment string must be＼
</p>
<ol>
	<li>
`相対~URL$sT
◎
a relative-URL string,＼
</li>
	<li>
<p>
省略可能な，次の並び：
◎
optionally followed by＼
</p>
		<ol>
			<li>
❝#
◎
U+0023 (#)＼
</li>
			<li>
`~URL素片$sT
◎
and a URL-fragment string.
</li>
		</ol>
	</li>
</ol>
</div>

<div>
<p>
`相対~URL@sT
は、
次の並びでなければナラナイ：
◎
A relative-URL string must be one of the following,＼
</p>
<ol>
	<li>
<p>
`基底~URL$の`~scheme$urlに応じて：
◎
switching on base URL’s scheme:
</p>
		<ul class="switch">
			<li>
<p>
`file^l 以外の`特別~scheme$ならば，次のいずれか：
◎
A special scheme that is not "file"
</p>
				<ul>
					<li>
`~scheme相対~特別~URL$sT
◎
a scheme-relative-special-URL string
</li>
					<li>
`~path絶対~URL$sT
◎
a path-absolute-URL string
</li>
					<li>
`~path相対 ~schemeなし~URL$sT
◎
a path-relative-scheme-less-URL string
</li>
				</ul>
			</li>
			<li>
<p>
`file^l ならば，次のいずれか：
◎
"file"
</p>
				<ul>
					<li>
`~scheme相対~file~URL$sT
◎
a scheme-relative-file-URL string
</li>
					<li>
`~path絶対~URL$sT
— ただし、［
`基底~URL$の`~host$urlは`空~host$である
］場合に限る
◎
a path-absolute-URL string if base URL’s host is an empty host
</li>
					<li>
`~path絶対 非 Windows file ~URL$sT
— ただし、［
`基底~URL$の`~host$urlは`空~host$でない
］場合に限る
◎
a path-absolute-non-Windows-file-URL string if base URL’s host is not an empty host
</li>
					<li>
`~path相対 ~schemeなし~URL$sT
◎
a path-relative-scheme-less-URL string
</li>
				</ul>
			</li>
			<li>
<p>
他の場合，次のいずれか：
◎
Otherwise
</p>
				<ul>
					<li>
`~scheme相対~URL$sT
◎
a scheme-relative-URL string
</li>
					<li>
`~path絶対~URL$sT
◎
a path-absolute-URL string
</li>
					<li>
`~path相対 ~schemeなし~URL$sT
◎
a path-relative-scheme-less-URL string
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
<p>
省略可能な，次の並び：
◎
any optionally followed by＼
</p>
		<ol>
			<li>
❝?
◎
U+003F (?)＼
</li>
			<li>
`~URL~query$sT
◎
and a URL-query string.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
`相対~URL$sTを`~URL構文解析器$にかけるときは、
`基底~URL$に ~NULL 以外を与えることが必要yである。
◎
A non-null base URL is necessary when parsing a relative-URL string.
</p>
</div>

<div>
<p>
`~scheme相対~特別~URL@sT
は、
次の並びでなければナラナイ：
◎
A scheme-relative-special-URL string must be＼
</p>
<ol>
	<li>
`//^l
◎
"//",＼
</li>
	<li>
`妥当な~host$sT
◎
followed by a valid host string,＼
</li>
	<li>
<p>
省略可能な，次の並び：
◎
optionally followed by＼
</p>
		<ol>
			<li>
❝:
◎
U+003A (:)＼
</li>
			<li>
`~URL~port$sT
◎
and a URL-port string,＼
</li>
		</ol>
	</li>
	<li>
省略可能な，`~path絶対~URL$sT
◎
optionally followed by a path-absolute-URL string.
</li>
</ol>
</div>

<div>
<p>
`~URL~port@sT
は、
次のいずれかでなければナラナイ：
◎
A URL-port string must be one of the following:
</p>
<ul>
	<li>
空~文字列
◎
the empty string
</li>
	<li>
1 個以上の`~ASCII数字$たちが成す並びであって，
10 進数で `16 ~bitな無符号~整数$を表現しているもの
◎
one or more ASCII digits representing a decimal number that is a 16-bit unsigned integer.
</li>
</ul>
</div>

<div>
<p>
`~scheme相対~URL@sT
は、
次の並びでなければナラナイ：
◎
A scheme-relative-URL string must be＼
</p>
<ol>
	<li>
`//^l
◎
"//",＼
</li>
	<li>
`不透明な~host＆~port$sT
◎
followed by an opaque-host-and-port string,＼
</li>
	<li>
省略可能な，`~path絶対~URL$sT
◎
optionally followed by a path-absolute-URL string.
</li>
</ol>
</div>

<div>
<p>
`不透明な~host＆~port@sT
は、
次のいずれかでなければナラナイ：
◎
An opaque-host-and-port string must be either＼
</p>
<ul>
	<li>
空~文字列
◎
the empty string＼
</li>
	<li>
<p>
次の並び：
◎
or:＼
</p>
		<ol>
			<li>
`妥当な不透明な~host$sT
◎
a valid opaque-host string,＼
</li>
			<li>
<p>
省略可能な，次の並び：
◎
optionally followed by＼
</p>
				<ol>
					<li>
❝:
◎
U+003A (:)＼
</li>
					<li>
`~URL~port$sT
◎
and a URL-port string.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ul>
</div>

<div>
<p>
`~scheme相対~file~URL@sT
は、
次の並びでなければナラナイ：
◎
A scheme-relative-file-URL string must be＼
</p>
<ol>
	<li>
`//^l
◎
"//", followed by＼
</li>
	<li>
<p>
次のいずれか：
◎
one of the following:
</p>
		<ul>
			<li>
<p>
次の並び：
</p>
				<ol>
					<li>
`妥当な~host$sT
</li>
					<li>
省略可能な，`~path絶対 非 Windows file ~URL$sT
</li>
				</ol>
◎
a valid host string, optionally followed by a path-absolute-non-Windows-file-URL string
</li>
			<li>
`~path絶対~URL$sT
◎
a path-absolute-URL string.
</li>
		</ul>
	</li>
</ol>
</div>

<div>
<p>
`~path絶対~URL@sT
は、
次の並びでなければナラナイ：
◎
A path-absolute-URL string must be＼
</p>
<ol>
	<li>
❝/
◎
U+002F (/)＼
</li>
	<li>
`~path相対~URL$sT
◎
followed by a path-relative-URL string.
</li>
</ol>
</div>

<div>
<p>
`~path絶対 非 Windows file ~URL@sT
は、
~AND↓ を満たす文字列でなければナラナイ：
◎
A path-absolute-non-Windows-file-URL string must be＼
</p>
<ul>
	<li>
`~path絶対~URL$sTである
◎
a path-absolute-URL string＼
</li>
	<li>
<p>
次の並びから開始していない：
◎
that does not start with:＼
</p>
		<ol>
			<li>
❝/
◎
U+002F (/),＼
</li>
			<li>
`~drive_letter$
◎
followed by a Windows drive letter,＼
</li>
			<li>
❝/
◎
followed by U+002F (/).
</li>
		</ol>
	</li>
</ul>
</div>

<div>
<p>
`~path相対~URL@sT
は、
~AND↓ を満たす文字列でなければナラナイ：
◎
A path-relative-URL string must be＼
</p>
<ul>
	<li>
❝/ で分離された［
0 個以上の`~URL~path区分$sT
］からなる
◎
zero or more URL-path-segment strings, separated from each other by U+002F (/), and＼
</li>
	<li>
❝/ から開始していない
◎
not start with U+002F (/).
</li>
</ul>
</div>

<div>
<p>
`~path相対 ~schemeなし~URL@sT
は、
~AND↓ を満たす文字列でなければナラナイ：
◎
A path-relative-scheme-less-URL string must be＼
</p>
<ul>
	<li>
`~path相対~URL$sTである
◎
a path-relative-URL string＼
</li>
	<li>
<p>
次の並びから開始していない：
◎
that does not start with:＼
</p>
		<ol>
			<li>
`~URL~scheme$sT
◎
a URL-scheme string,＼
</li>
			<li>
❝:
◎
followed by U+003A (:).
</li>
		</ol>
	</li>
</ul>
</div>

<div>
<p>
`~URL~path区分@sT
は、
0 個以上の［
❝/, ❝? 以外の`~URL単位$
］たちが成す並びでなければナラナイ。
◎
A URL-path-segment string must be one of the following:
• zero or more URL units excluding U+002F (/) and U+003F (?), that together are not a single-dot URL path segment or a double-dot URL path segment.
</p>

<p>
特に，［
`二重-~dot~URL~path区分$／`単-~dot~URL~path区分$
］は、
`~URL~path区分$sTである。
◎
• a single-dot URL path segment
• a double-dot URL path segment.
</p>

<p class="trans-note">【
似た名前の`~URL~path区分$は、
~ASCII文字列に限定される。
】</p>
</div>

<p>
`~URL~query@sT
は、［
0 個以上の`~URL単位$たちが成す並び
］でなければナラナイ。
◎
A URL-query string must be zero or more URL units.
</p>

<p>
`~URL素片@sT
は、［
0 個以上の`~URL単位$たちが成す並び
］でなければナラナイ。
◎
A URL-fragment string must be zero or more URL units.
</p>

<p>
次に挙げる`~cp$が
`~URL~cp@
である：
◎
The URL code points are＼
</p>
<ul>
	<li>
`~ASCII英数字$
◎
ASCII alphanumeric,＼
</li>
	<li>
❝!,
❝$,
`0026^U `&amp;^smb,
❝',
❝(,
❝),
❝*,
❝+,
❝,,
❝-,
❝.,
❝/,
❝:,
❝;,
❝=,
❝?,
❝@,
❝_,
❝~
◎
U+0021 (!), U+0024 ($), U+0026 (&amp;), U+0027 ('), U+0028 LEFT PARENTHESIS, U+0029 RIGHT PARENTHESIS, U+002A (*), U+002B (+), U+002C (,), U+002D (-), U+002E (.), U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+003F (?), U+0040 (@), U+005F (_), U+007E (~),＼
</li>
	<li>
`00A0^U 〜 `10FFFD^U
— ただし、
`~surrogate$, `非文字$は除外する。
◎
and code points in the range U+00A0 to U+10FFFD, inclusive, excluding surrogates and noncharacters.
</li>
</ul>

<p class="note">注記：
`0080^U 以上の~cpは、
`~URL構文解析器$により`~percent-符号化された~byte$に変換されることになる。
◎
Code points greater than U+007F DELETE will be converted to percent-encoded bytes by the URL parser.
</p>

<p class="note">注記：
~HTMLにおいては、
文書の符号化法が旧来のものである場合、
`~URL~query$sT内の `0080^U 以上の~cpは，
文書の符号化法を利用して`~percent-符号化された~byte$に変換される。
これは、
ある文書で働く~URLが 異なる文書~符号化法を利用する文書に複製されるときに，
問題になり得る。
この問題は、
あらゆる箇所に~UTF-8符号化法を利用すれば~~解消する。
◎
In HTML, when the document encoding is a legacy encoding, code points in the URL-query string that are higher than U+007F DELETE will be converted to percent-encoded bytes using the document’s encoding. This can cause problems if a URL that works in one document is copied to another document that uses a different document encoding. Using the UTF-8 encoding everywhere solves this problem.
</p>

<div class="example" id="query-encoding-example">
<p>
例えば、
次の~HTML文書を考える：
◎
For example, consider this HTML document:
</p>

<pre class="lang-html">
&lt;!doctype html&gt;
&lt;meta charset="windows-1252"&gt;
&lt;a href="?sm&amp;ouml;rg&amp;aring;sbord"&gt;Test&lt;/a&gt;
</pre>

<p>
文書~符号化法は windows-1252 なので、
~linkの`~URL$の`~query$urlは
`sm%F6rg%E5sbord^l
になる。
文書~符号化法が UTF-8 であった場合、
それは
`sm%C3%B6rg%C3%A5sbord^l
になる。
◎
Since the document encoding is windows-1252, the link’s URL’s query will be "sm%F6rg%E5sbord". If the document encoding had been UTF-8, it would instead be "sm%C3%B6rg%C3%A5sbord".
</p>
			</div>

<p>
次に挙げるものが
`~URL単位@
である
⇒＃
`~URL~cp$,
`~percent-符号化された~byte$
◎
The URL units are URL code points and percent-encoded bytes.
</p>

<p class="trans-note">【
したがって、
`~URL単位$は，一般には（ 1 個の~cpに限られない）文字列である。
】</p>

<p class="note">注記：
`~percent-符号化された~byte$は、
~cpのうち［
`~URL~cp$でない, あるいは
書出せるものから除外されている
］ものを符号化するときに，利用され得る／できる。
◎
Percent-encoded bytes can be used to encode code points that are not URL code points or are excluded from being written.
</p>

<hr>

<p class="note">注記：
`妥当な~URL$sTの中で，`~URL~record$の［
`~username$url, `~password$url
］を表出する仕方は無い。
◎
There is no way to express a username or password of a URL record within a valid URL string.
</p>

		</section>
		<section id="url-parsing">
<h3 title="URL parsing">4.4. ~URLの構文解析-法</h3>

<div class="algo">
<p>
`~URL構文解析する@
~algoは（ “~URL構文解析器にかける” とも称される）、
所与の
⇒＃
`~scalar値~文字列$ %入力,
［~NULL ／`基底~URL$］ %基底 （省略時は ~NULL ）,
`符号化法$ %符号化法 （省略時は `~UTF-8$ ）
◎終
に対し：
◎
The URL parser takes a scalar value string input, with an optional null or base URL base (default null) and an optional encoding encoding (default UTF-8), and then runs these steps:
</p>

<p class="note">注記：
非~web~browser実装は、
`基本~URL構文解析器$のみ実装すれば~~十分である。
◎
Non-web-browser implementations only need to implement the basic URL parser.
</p>

<p class="note">注記：
~browserの~URL~bar内の利用者~入力を`~URL~record$に どう変換するかは、
この標準の視野から外れる。
この標準は、
`~URLの具現化~要件＠#url-rendering$を
— 信用-裁定に係るので —
含むが。
◎
How user input in the web browser’s address bar is converted to a URL record is out-of-scope of this standard. This standard does include URL rendering requirements as they pertain trust decisions.
</p>
<ol>
	<li>
%~URL ~LET `基本~URL構文解析器$( %入力, %基底, %符号化法 )
◎
Let url be the result of running the basic URL parser on input with base and encoding.
</li>
	<li>
~IF［
%~URL ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If url is failure, return failure.
</li>
	<li>
~IF［
%~URL の`~scheme$url ~NEQ `blob^l
］
⇒
~RET %~URL
◎
If url’s scheme is not "blob", return url.
</li>
	<li>
%~URL の`~blob~URL~entry$url ~SET 次の結果に応じて［
`失敗^i ならば ~NULL ／
~ELSE_ その結果
］
⇒
`~blob~URLを解決する$( %~URL )
◎
Set url’s blob URL entry to the result of resolving the blob URL url, if that did not return failure, and null otherwise.
</li>
	<li>
~RET %~URL
◎
Return url.
</li>
</ol>
</div>

<div class="algo">
<p>
`~API用に~URL構文解析する@
~algoは、
所与の
⇒＃
`~scalar値~文字列$ %入力,
`~URL$ %~URL,
%上書state,
`符号化法$ %符号化法 （省略時は `~UTF-8$ ）
◎終
に対し
⇒
`基本~URL構文解析器$( %入力, ~NULL, %符号化法, ( %~URL, %上書state ) )
◎終
加えて、
結果に応じて，次を返す
⇒＃
`失敗^i ならば `失敗^i ／
~ELSE_（基本~URL構文解析器は値を返さなかった） `成功^i
</p>

<p class="trans-note">【
この~algoは，`基本~URL構文解析器$を包装するものでしかないが、
それを他所（他の仕様も含む）から簡便に利用するために，
この訳に導入している。
これは、
首に，
%~URL 内の %上書state に対応する~URL成分
（例：`~host$st ならば`~host$url成分）
を［
%入力 を その成分に関して構文解析した結果
］に改変する用途が意図される
（新たな~URLは作成しない）。
（ “~API用…” と命名された理由は、
下の注記を見よ。）
】</p>
◎
</div>

<hr>

<div class="algo">
<p>
`基本~URL構文解析器@
は、
所与の
⇒＃
`~scalar値~文字列$ %入力,
［~NULL ／`基底~URL$］ %基底 （省略時は ~NULL ）,
`符号化法$ %符号化法 （省略時は`~UTF-8$ ）,
`~URL$と上書stateが成す~pair ( %~URL, %上書state ) （省略時は ( ε, ε ) ）
◎終
に対し：
◎
The basic URL parser takes a scalar value string input, with an optional null or base URL base (default null), an optional encoding encoding (default UTF-8), an optional URL url, and an optional state override state override, and then runs these steps:
</p>

<div class="note">
<p>注記：</p>

<ul>
	<li>
引数 %符号化法 は、
`~HTML^citeに限り関連する，旧来の概念である。
`HTML$r
◎
The encoding argument is a legacy concept only relevant for HTML.＼
</li>
	<li>
<p>
( %~URL, %上書state )
が利用されるのは、
各種~APIに限られる†。
`基本~URL構文解析器$は、
この~pairが
⇒＃
渡されなかった場合、`~URL$または `失敗^i を返す／
渡された場合、［渡された %~URL を改変して何も返さずに終了する］こともある††
</p>

<p class="trans-note">【†
すなわち、
`~API用に~URL構文解析する$を介して呼出された場合。
】【††
あるいは `失敗^i を返す。
その場合、
%~URL は改変されないべきだが，明示的に そう述べられてはいない
— ~algoを精査する必要がある。
】</p>
◎
The url and state override arguments are only for use by various APIs. [HTML]
◎
When the url and state override arguments are not passed, the basic URL parser returns either a new URL or failure. If they are passed, the algorithm modifies the passed url and can terminate without returning anything.
</li>
</ul>
</div>

<ol>
	<li>
<p>
~IF［
%~URL ~EQ ε
］：
◎
If url is not given:
</p>
		<ol>
			<li>
%~URL ~SET 新たな`~URL$
◎
Set url to a new URL.
</li>
			<li>
~IF［
%入力 の［
先頭または末尾
］の文字 ~IN `~C0制御文字や~space$
］
⇒
`検証~error$( `invalid-URL-unit$err )
◎
If input contains any leading or trailing C0 control or space, invalid-URL-unit validation error.
</li>
			<li>
%入力 から［
頭部, 尾部
］を成す［
`~C0制御文字や~space$たちが成す並び
］を除去する
◎
Remove any leading and trailing C0 control or space from input.
</li>
		</ol>
	</li>
	<li>
~IF［
%入力 内に`~ASCII~tabや~ASCII改行文字$が在る
］
⇒
`検証~error$( `invalid-URL-unit$err )
◎
If input contains any ASCII tab or newline, invalid-URL-unit validation error.
</li>
	<li>
%入力 からすべての`~ASCII~tabや~ASCII改行文字$を除去する
◎
Remove all ASCII tab or newline from input.
</li>
	<li>
%state ~LET ［
%上書state ~NEQ ε ならば %上書state ／
~ELSE_ `~scheme開始$st
］
◎
Let state be state override if given, or scheme start state otherwise.
</li>
	<li>
%符号化法 ~SET `符号化法から出力~符号化法を取得する$( %符号化法 )
◎
Set encoding to the result of getting an output encoding from encoding.
</li>
	<li>
%~buffer ~LET 空~文字列
◎
Let buffer be the empty string.
</li>
	<li>
( %~at-signありか, %角括弧の内側か, %~password~tokenありか ) ~LET ( ~F, ~F, ~F )
◎
Let atSignSeen, insideBrackets, and passwordTokenSeen be false.
</li>
	<li>
%~pointer ~LET %入力 用の`~pointer$
◎
Let pointer be a pointer for input.
</li>
	<li>
<p>
~WHILE 無条件
</p>
		<ol>
			<li>
下に与える状態機械を走らす
</li>
			<li>
~IF［
%~pointer ~NEQ −1
］~AND［
`C$V ~EQ `EOF$i
］
⇒
~BREAK
</li>
			<li>
%~pointer ~INCBY 1
</li>
		</ol>
◎
Keep running the following state machine by switching on state. If after a run pointer points to the EOF code point, go to the next step. Otherwise, increase pointer by 1 and continue with the state machine.
</li>
	<li>
<p>
~IF［
%上書state ~EQ ε
］
⇒
~RET %~URL
</p>

<p class="trans-note">【
構文解析に失敗した場合、
この段には到達しない。
】【
この段は，原文では状態機械の後に置かれているが、
見通しを良くするため，ここに移動している。
】</p>
◎
↓↓</li>
</ol>

<p>
状態機械は、
%state に応じて，以下における対応する段を走らす
— この状態機械の中では：
◎
↑↑</p>

<ul>
	<li>
“~RET” は、
上の~algo自身を終了させるとする。
</li>
	<li>
<p>
`~URL単位かどうか検証する@
所では、
`C$V に応じて次を走らすとする：
</p>
		<ol class="switch">
			<li>
`~URL~cp$
⇒
何もしない
</li>
			<li>
❝%
⇒
~IF［
`C1$V ~NIN `~ASCII~hex数字$
］~OR［
`C2$V ~NIN `~ASCII~hex数字$
］
⇒
`検証~error$( `invalid-URL-unit$err )
</li>
			<li>
その他
⇒
`検証~error$( `invalid-URL-unit$err )
</li>
		</ol>

<p class="trans-note">【
この定義は、
共通な記述を集約するために，この訳に導入している。
】</p>

	</li>
</ul>

<p class="trans-note">【
この状態機械は、
現在の `state^i からは常に，自身または自身より後に示される `state^i へ遷移するよう、
~sortして記されている。
】</p>

<dl class="switch">

<!--% scheme-start-state -->
	<dt>`~scheme開始@st</dt>

	<dd>
		<ol>
			<li>
~IF［
`C$V ~IN `~ASCII英字$
］
⇒＃
%~buffer ~APPEND `~ASCII小文字~化する$( `C$V )；
%state ~SET `~scheme$st
◎
If c is an ASCII alpha, append c, lowercased, to buffer, and set state to scheme state.
</li>
			<li>
~ELIF［
%上書state ~EQ ε
］
⇒＃
%~pointer ~DECBY 1；
%state ~SET `~schemeなし$st
◎
Otherwise, if state override is not given, set state to no scheme state and decrease pointer by 1.
</li>
			<li>
<p>
~ELSE
⇒
~RET `失敗^i
◎
Otherwise, return failure.
</p>

<p class="note">
この `失敗^i の指示は、
`Location$I ~objの `~protocol0$m 設定子から排他的に利用される。
◎
This indication of failure is used exclusively by the Location object’s protocol setter.
</p>
			</li>
		</ol>
	</dd>

<!--% scheme-state -->
	<dt>`~scheme@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V は`~ASCII英数字$である
］~OR［
`C$V ~IN { ❝+, ❝-, ❝. }
］
⇒
%~buffer ~APPEND `~ASCII小文字~化する$( `C$V )
◎
If c is an ASCII alphanumeric, U+002B (+), U+002D (-), or U+002E (.), append c, lowercased, to buffer.
</li>
			<li>
<p>
~ELIF［
`C$V ~EQ ❝:
］：
◎
Otherwise, if c is U+003A (:), then:
</p>

				<ol>
					<li>
<p>
~IF［
%上書state ~NEQ ε
］~AND［
~OR↓
］…
◎
If state override is given, then:
</p>
						<ul>
							<li>
［
%~URL の`~scheme$url, %~buffer
］のうち，片方だけが`特別~scheme$である
◎
If url’s scheme is a special scheme and buffer is not a special scheme, then return.
◎
If url’s scheme is not a special scheme and buffer is a special scheme, then return.
</li>
							<li>
［［
%~URL は`資格証を含んで$いる
］~OR［
%~URL の`~port$url ~NEQ ~NULL
］］~AND［
%~buffer ~EQ `file^l
］
◎
If url includes credentials or has a non-null port, and buffer is "file", then return.
</li>
							<li>
［
%~URL の`~scheme$url ~EQ `file^l
］~AND［
%~URL の`~host$urlは`空~host$である
］
◎
If url’s scheme is "file" and its host is an empty host, then return.
</li>
						</ul>
<p>
…ならば
⇒
~RET
◎
↑</p>
					</li>
					<li>
%~URL の`~scheme$url ~SET %~buffer
◎
Set url’s scheme to buffer.
</li>
					<li>
<p>
~IF［
%上書state ~NEQ ε
］：
◎
If state override is given, then:
</p>
						<ol>
							<li>
~IF［
%~URL の`~port$url ~EQ %~URL の`~scheme$urlの`既定~port$
］
⇒
%~URL の`~port$url ~SET ~NULL
◎
If url’s port is url’s scheme’s default port, then set url’s port to null.
</li>
							<li>
~RET
◎
Return.
</li>
						</ol>
					</li>
					<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
					<li>
<p>
~IF［
%~URL の`~scheme$url ~EQ `file^l
］：
◎
If url’s scheme is "file", then:
</p>
						<ol>
							<li>
~IF［
`C1$V ~NEQ `/^l
］~OR［
`C2$V ~NEQ `/^l
］
⇒
`検証~error$( `special-scheme-missing-following-solidus$err )
◎
If remaining does not start with "//", special-scheme-missing-following-solidus validation error.
</li>
							<li>
%state ~SET `~file$st
◎
Set state to file state.
</li>
						</ol>
					</li>
					<li>
<p>
~ELIF［
%~URL は`特別$である
］~AND［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ %~URL の`~scheme$url
］：
◎
Otherwise, if url is special, base is non-null, and base’s scheme is url’s scheme:
</p>
						<ol>
							<li>
~Assert：
%基底 は`特別$である
（したがって，`不透明な~path$を有さない）。
◎
Assert: base is special (and therefore does not have an opaque path).
</li>
							<li>
%状態 ~SET `特別 相対/権限$st
◎
Set state to special relative or authority state.
</li>
						</ol>
					</li>
					<li>
~ELIF［
%~URL は`特別$である
］
⇒
%state ~SET `特別 権限~slash$st
◎
Otherwise, if url is special, set state to special authority slashes state.
</li>
					<li>
~ELIF［
`C1$V ~EQ ❝/
］
⇒＃
%~pointer ~INCBY 1；
%state ~SET `~path/権限$st
◎
Otherwise, if remaining starts with an U+002F (/), set state to path or authority state and increase pointer by 1.
</li>
					<li>
~ELSE
⇒＃
%~URL の`~path$url ~SET 空~文字列；
%state ~SET `不透明~path$st
◎
Otherwise, set url’s path to the empty string and set state to opaque path state.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%上書state ~EQ ε
］
⇒＃
%~buffer ~SET 空~文字列；
%~pointer ~SET −1 （%入力 の最初の~cpから、やり直す）；
%state ~SET `~schemeなし$st；
◎
Otherwise, if state override is not given, set buffer to the empty string, state to no scheme state, and start over (from the first code point in input).
</li>
			<li>
<p>
~ELSE
⇒
~RET `失敗^i
◎
Otherwise, return failure.
</p>

<p class="note">
この `失敗^i の指示は、
`Location$I ~objの `~protocol0$m 設定子から排他的に利用される。
更には，この~stateの早期における非 `失敗^i による終了nは、
その設定子を定義するための意図的な相違である。
◎
This indication of failure is used exclusively by the Location object’s protocol setter. Furthermore, the non-failure termination earlier in this state is an intentional difference for defining that setter.
</p>
			</li>
		</ol>
	</dd>

<!--% no-scheme-state -->
	<dt>`~schemeなし@st</dt>
	<dd>
		<ol>
			<li>
~IF［
%基底 ~EQ ~NULL
］~OR［［
%基底 は`不透明な~path$を有する
］~AND［
`C$V ~NEQ ❝#
］］
⇒＃
`検証~error$( `missing-scheme-non-relative-URL$err )；
~RET `失敗^i
◎
If base is null, or base has an opaque path and c is not U+0023 (#), missing-scheme-non-relative-URL validation error, return failure.
</li>
			<li>
<p>
~ELIF［
%基底 は`不透明な~path$を有する
］~AND［
`C$V ~EQ ❝#
］：
</p>
				<ol>
					<li>
%~URL の
⇒＃
`~scheme$url ~SET %基底 の`~scheme$url；
`~path$url ~SET %基底 の`~path$url；
`~query$url ~SET %基底 の`~query$url；
`素片$url ~SET 空~文字列；
</li>
					<li>
%state ~SET `素片$st
</li>
				</ol>
◎
Otherwise, if base has an opaque path and c is U+0023 (#), set url’s scheme to base’s scheme, url’s path to base’s path, url’s query to base’s query, url’s fragment to the empty string, and set state to fragment state.
</li>
			<li>
~ELIF［
%基底 の`~scheme$url ~NEQ `file^l
］
⇒＃
%~pointer ~DECBY 1；
%state ~SET `相対$st
◎
Otherwise, if base’s scheme is not "file", set state to relative state and decrease pointer by 1.
</li>
			<li>
~ELSE
⇒＃
%~pointer ~DECBY 1；
%state ~SET `~file$st
◎
Otherwise, set state to file state and decrease pointer by 1.
</li>
		</ol>
	</dd>

<!--% special-relative-or-authority-state -->
	<dt>`特別 相対/権限@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~EQ ❝/
］~AND［
`C1$V ~EQ ❝/
］
⇒＃
%~pointer ~INCBY 1；
%state ~SET `特別 権限~slash無視$st
◎
If c is U+002F (/) and remaining starts with U+002F (/), then set state to special authority ignore slashes state and increase pointer by 1.
</li>
			<li>
~ELSE
⇒＃
`検証~error$( `special-scheme-missing-following-solidus$err )；
%~pointer ~DECBY 1；
%state ~SET `相対$st
◎
Otherwise, special-scheme-missing-following-solidus validation error, set state to relative state and decrease pointer by 1.
</li>
		</ol>
	</dd>

<!--% path-or-authority-state -->
	<dt>`~path/権限@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~EQ ❝/
］
⇒
%state ~SET `権限$st
◎
If c is U+002F (/), then set state to authority state.
</li>
			<li>
~ELSE
⇒＃
%~pointer ~DECBY 1；
%state ~SET `~path$st
◎
Otherwise, set state to path state, and decrease pointer by 1.
</li>
		</ol>
	</dd>

<!--% relative-state -->
	<dt>`相対@st</dt>
	<dd>
		<ol>
			<li>
~Assert：
%基底 の`~scheme$url ~NEQ `file^l
◎
Assert: base’s scheme is not "file".
</li>
			<li>
%~URL の`~scheme$url ~SET %基底 の`~scheme$url
◎
Set url’s scheme to base’s scheme.
</li>
			<li>
~IF［
`C$V ~EQ ❝/
］
⇒
%state ~SET `相対~slash$st
◎
If c is U+002F (/), then set state to relative slash state.
</li>
			<li>
~ELIF［
%~URL は`特別$である
］~AND［
`C$V ~EQ ❝\
］
⇒＃
`検証~error$( `invalid-reverse-solidus$err )；
%state ~SET `相対~slash$st
◎
Otherwise, if url is special and c is U+005C (\), invalid-reverse-solidus validation error, set state to relative slash state.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%~URL の
⇒＃
`~username$url ~SET %基底 の`~username$url；
`~password$url ~SET %基底 の`~password$url；
`~host$url ~SET %基底 の`~host$url；
`~port$url ~SET %基底 の`~port$url；
`~path$url ~SET %基底 の`~path$urlを`~cloneする$；
`~query$url ~SET %基底 の`~query$url
◎
Set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, url’s path to a clone of base’s path, and url’s query to base’s query.
</li>
					<li>
~IF［
`C$V ~EQ ❝?
］
⇒＃
%~URL の`~query$url ~SET 空~文字列；
%state ~SET `~query$st
◎
If c is U+003F (?), then set url’s query to the empty string, and state to query state.
</li>
					<li>
~ELIF［
`C$V ~EQ ❝#
］
⇒＃
%~URL の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
◎
Otherwise, if c is U+0023 (#), set url’s fragment to the empty string and state to fragment state.
</li>
					<li>
<p>
~ELIF［
`C$V ~NEQ `EOF$i
］：
◎
Otherwise, if c is not the EOF code point:
</p>
						<ol>
							<li>
%~URL の`~query$url ~SET ~NULL
◎
Set url’s query to null.
</li>
							<li>
%~URL の`~pathを短縮する$
◎
Shorten url’s path.
</li>
							<li>
%~pointer ~DECBY 1
◎
Set state to path state and decrease pointer by 1.
</li>
							<li>
%state ~SET `~path$st
◎
↑</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% relative-slash-state -->
	<dt>`相対~slash@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
%~URL は`特別$である
］~AND［
`C$V ~IN { ❝/, ❝\ }
］：
◎
If url is special and c is U+002F (/) or U+005C (\), then:
</p>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝\
］
⇒
`検証~error$( `invalid-reverse-solidus$err )
◎
If c is U+005C (\), invalid-reverse-solidus validation error.
</li>
					<li>
%state ~SET `特別 権限~slash無視$st
◎
Set state to special authority ignore slashes state.
</li>
				</ol>
			</li>
			<li>
~ELIF［
`C$V ~EQ ❝/
］
⇒
%state ~SET `権限$st
◎
Otherwise, if c is U+002F (/), then set state to authority state.
</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
%~URL の
⇒＃
`~username$url ~SET %基底 の`~username$url；
`~password$url ~SET %基底 の`~password$url；
`~host$url ~SET %基底 の`~host$url；
`~port$url ~SET %基底 の`~port$url
</li>
					<li>
%~pointer ~DECBY 1
</li>
					<li>
%state ~SET `~path$st
</li>
				</ol>
◎
Otherwise, set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, state to path state, and then, decrease pointer by 1.
</li>
		</ol>
	</dd>

<!--% special-authority-slashes-state -->
	<dt>`特別 権限~slash@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~EQ ❝/
］~AND［
`C1$V ~EQ ❝/
］
⇒
%~pointer ~INCBY 1
◎
If c is U+002F (/) and remaining starts with U+002F (/), then set state to special authority ignore slashes state and increase pointer by 1.
</li>
			<li>
~ELSE
⇒＃
`検証~error$( `special-scheme-missing-following-solidus$err )；
%~pointer ~DECBY 1
◎
Otherwise, special-scheme-missing-following-solidus validation error, set state to special authority ignore slashes state and decrease pointer by 1.
</li>
			<li>
%state ~SET `特別 権限~slash無視$st
◎
↑</li>
		</ol>
	</dd>

<!--% special-authority-ignore-slashes-state -->
	<dt>`特別 権限~slash無視@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~NIN { ❝/, ❝\ }
］
⇒＃
%~pointer ~DECBY 1；
%state ~SET `権限$st
◎
If c is neither U+002F (/) nor U+005C (\), then set state to authority state and decrease pointer by 1.
</li>
			<li>
~ELSE
⇒
`検証~error$( `special-scheme-missing-following-solidus$err )
◎
Otherwise, special-scheme-missing-following-solidus validation error.
</li>
		</ol>
	</dd>

<!--% authority-state -->
	<dt>`権限@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`C$V ~EQ ❝@
］：
◎
If c is U+0040 (@), then:
</p>
				<ol>
					<li>
`検証~error$( `invalid-credentials$err )
◎
Invalid-credentials validation error.
</li>
					<li>
~IF［
%~at-signありか ~EQ ~T
］
⇒
%~buffer の先頭に `%40^l を~~挿入する
◎
If atSignSeen is true, then prepend "%40" to buffer.
</li>
					<li>
%~at-signありか ~SET ~T
◎
Set atSignSeen to true.
</li>
					<li>
<p>
%~buffer を成す
~EACH( %~cp )
に対し：
◎
For each codePoint in buffer:
</p>
						<ol>
							<li>
~IF［
%~cp ~EQ ❝:
］~AND［
%~password~tokenありか ~EQ ~F
］
⇒＃
%~password~tokenありか ~SET ~T；
~CONTINUE
◎
If codePoint is U+003A (:) and passwordTokenSeen is false, then set passwordTokenSeen to true and continue.
</li>
							<li>
%符号化-済み~cp ~LET
`~cpを~UTF-8~percent-符号化する$( %~cp, `~userinfo~percent-符号化-集合$ )
◎
Let encodedCodePoints be the result of running UTF-8 percent-encode codePoint using the userinfo percent-encode set.
</li>
							<li>
~IF［
%~password~tokenありか ~EQ ~T
］
⇒
%~URL の`~password$url ~APPEND %符号化-済み~cp
◎
If passwordTokenSeen is true, then append encodedCodePoints to url’s password.
</li>
							<li>
~ELSE
⇒
%~URL の`~username$url ~APPEND %符号化-済み~cp
◎
Otherwise, append encodedCodePoints to url’s username.
</li>
						</ol>
					</li>
					<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
~OR↓
］…
◎
Otherwise, if one of the following is true:
</p>
				<ul>
					<li>
`C$V ~IN { `EOF$i, ❝/, ❝?, ❝# }
◎
c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
</li>
					<li>
［
%~URL は`特別$である
］~AND［
`C$V ~EQ ❝\
］
◎
url is special and c is U+005C (\)
</li>
				</ul>

<p>
…ならば：
◎
then:
</p>
				<ol>
					<li>
~IF［
%~at-signありか ~EQ ~T
］~AND［
%~buffer ~EQ 空~文字列
］
⇒＃
`検証~error$( `host-missing$err )；
~RET `失敗^i
◎
If atSignSeen is true and buffer is the empty string, host-missing validation error, return failure.
</li>
					<li>
%~pointer ~DECBY %~buffer の`~cp長さ$ ~PLUS 1
◎
Decrease pointer by buffer’s code point length + 1,＼
</li>
					<li>
%~buffer ~SET 空~文字列
◎
set buffer to the empty string,＼
</li>
					<li>
%state ~SET `~host$st
◎
and set state to host state.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%~buffer ~APPEND `C$V
◎
Otherwise, append c to buffer.
</li>
		</ol>
	</dd>

<!--% host-state -->
	<dt>`~host@st</dt>

<!--% hostname-state -->
	<dt>`~hostname@st</dt>
	<dd>
		<ol>
			<li>
~IF［
%上書state ~NEQ ε
］~AND［
%~URL の`~scheme$url ~EQ `file^l
］
⇒＃
%~pointer ~DECBY 1；
%state ~SET `~file~host$st
◎
If state override is given and url’s scheme is "file", then decrease pointer by 1 and set state to file host state.
</li>
			<li>
<p>
~ELIF［
`C$V ~EQ ❝:
］~AND［
%角括弧の内側か ~EQ ~F
］：
◎
Otherwise, if c is U+003A (:) and insideBrackets is false, then:
</p>

				<ol>
					<li>
~IF［
%~buffer ~EQ 空~文字列
］
⇒＃
`検証~error$( `host-missing$err )；
~RET `失敗^i
◎
If buffer is the empty string, host-missing validation error, return failure.
</li>
					<li>
~IF［
%上書state ~EQ `~hostname$st
］
⇒
~RET
◎
If state override is given and state override is hostname state, then return.
</li>
					<li>
%~host ~LET
`~host構文解析器$( %~buffer, ~IS［ %~URL は`特別$でない］ )
◎
Let host be the result of host parsing buffer with url is not special.
</li>
					<li>
~IF［
%~host ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If host is failure, then return failure.
</li>
					<li>
%~URL の`~host$url ~SET %~host
◎
Set url’s host to host,＼
</li>
					<li>
%~buffer ~SET 空~文字列
◎
buffer to the empty string,＼
</li>
					<li>
%state ~SET `~port$st
◎
and state to port state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
~OR↓
］…
◎
Otherwise, if one of the following is true:
</p>
				<ul>
					<li>
`C$V ~IN { `EOF$i, ❝/, ❝?, ❝# }
◎
c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
</li>
					<li>
［
%~URL は`特別$である
］~AND［
`C$V ~EQ ❝\
］
◎
url is special and c is U+005C (\)
</li>
				</ul>
<p>
…ならば：
◎
then decrease pointer by 1, and then:
</p>

				<ol>
					<li>
%~pointer ~DECBY 1
◎
↑</li>
					<li>
~IF［
%~URL は`特別$である
］~AND［
%~buffer ~EQ 空~文字列
］
⇒＃
`検証~error$( `host-missing$err )；
~RET `失敗^i
◎
If url is special and buffer is the empty string, host-missing validation error, return failure.
</li>
					<li>
~ELIF［
%上書state ~NEQ ε
］~AND［
%~buffer ~EQ 空~文字列
］~AND［［
%~URL は`資格証を含んで$いる
］~OR［
%~URL の`~port$url ~NEQ ~NULL
］］
⇒
~RET
◎
Otherwise, if state override is given, buffer is the empty string, and either url includes credentials or url’s port is non-null, return.
</li>
					<li>
%~host ~LET
`~host構文解析器$( %~buffer, ~IS［ %~URL は`特別$でない］ )
◎
Let host be the result of host parsing buffer with url is not special.
</li>
					<li>
~IF［
%~host ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If host is failure, then return failure.
</li>
					<li>
%~URL の`~host$url ~SET %~host
◎
Set url’s host to host, buffer to the empty string, and state to path start state.
</li>
					<li>
~IF［
%上書state ~NEQ ε
］
⇒
~RET
◎
If state override is given, then return.
</li>
					<li>
%~buffer ~SET 空~文字列
◎
↑</li>
					<li>
%state ~SET `~path開始$st
◎
↑</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>

				<ol>
					<li>
~IF［
`C$V ~EQ ❝[
］
⇒
%角括弧の内側か ~SET ~T
◎
If c is U+005B ([), then set insideBrackets to true.
</li>
					<li>
~IF［
`C$V ~EQ ❝]
］
⇒
%角括弧の内側か ~SET ~F
◎
If c is U+005D (]), then set insideBrackets to false.
</li>
					<li>
%~buffer ~APPEND `C$V
◎
Append c to buffer.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% port-state -->
	<dt>`~port@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~IN `~ASCII数字$
］
⇒
%~buffer ~APPEND `C$V
◎
If c is an ASCII digit, append c to buffer.
</li>
			<li>
<p>
~ELIF［
~OR↓
］…
◎
Otherwise, if one of the following is true:
</p>
				<ul>
					<li>
`C$V ~IN { `EOF$i, ❝/, ❝?, ❝# }
◎
c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
</li>
					<li>
［
%~URL は`特別$である
］~AND［
`C$V ~EQ ❝\
］
◎
url is special and c is U+005C (\)
</li>
					<li>
%上書state ~NEQ ε
◎
state override is given
</li>
				</ul>
<p>
…ならば：
◎
then:
</p>
				<ol>
					<li>
<p>
~IF［
%~buffer ~NEQ 空~文字列
］：
◎
If buffer is not the empty string, then:
</p>
						<ol>
							<li>
%~port ~LET %~buffer を［
その各 `~ASCII数字$を基数 10 による値 0 〜 9 と解釈した
］下で表現される，数学的な整数~値
◎
Let port be the mathematical integer value that is represented by buffer in radix-10 using ASCII digits for digits with values 0 through 9.
</li>
							<li>
~IF［
%~port は `16 ~bitな無符号~整数$でない
］
⇒＃
`検証~error$( `port-out-of-range$err )；
~RET `失敗^i
◎
If port is not a 16-bit unsigned integer, port-out-of-range validation error, return failure.
</li>
							<li>
%~URL の`~port$url ~SET ［
次が満たされるならば ~NULL ／
~ELSE_ %~port
］
⇒
%~port ~EQ %~URL の`~scheme$urlの`既定~port$
◎
Set url’s port to null, if port is url’s scheme’s default port; otherwise to port.
</li>
							<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
						</ol>
					</li>
					<li>
~IF［
%上書state ~NEQ ε
］
⇒
~RET
◎
If state override is given, then return.
</li>
					<li>
%~pointer ~DECBY 1
◎
↓</li>
					<li>
%state ~SET `~path開始$st
◎
Set state to path start state and decrease pointer by 1.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒＃
`検証~error$( `port-invalid$err )；
~RET `失敗^i
◎
Otherwise, port-invalid validation error, return failure.
</li>
		</ol>
	</dd>

<!--% file-state -->
	<dt>`~file@st</dt>
	<dd>
		<ol>
			<li>
%~URL の`~scheme$url ~SET `file^l
◎
Set url’s scheme to "file".
</li>
			<li>
%~URL の`~host$url ~SET 空~文字列
◎
Set url’s host to the empty string.
</li>
			<li>
<p>
~IF［
`C$V ~IN { ❝/, ❝\ }
］：
◎
If c is U+002F (/) or U+005C (\), then:
</p>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝\
］
⇒
`検証~error$( `invalid-reverse-solidus$err )
◎
If c is U+005C (\), invalid-reverse-solidus validation error.
</li>
					<li>
%state ~SET `~file~slash$st
◎
Set state to file slash state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ `file^l
］：
◎
Otherwise, if base is non-null and base’s scheme is "file":
</p>
				<ol>
					<li>
%~URL の
⇒＃
`~host$url ~SET %基底 の`~host$url；
`~path$url ~SET %基底 の`~path$urlを`~cloneする$；
`~query$url ~SET %基底 の`~query$url
◎
Set url’s host to base’s host, url’s path to a clone of base’s path, and url’s query to base’s query.
</li>
					<li>
~IF［
`C$V ~EQ ❝?
］
⇒＃
%~URL の`~query$url ~SET 空~文字列；
%state ~SET `~query$st
◎
If c is U+003F (?), then set url’s query to the empty string and state to query state.
</li>

					<li>
~ELIF［
`C$V ~EQ ❝#
⇒＃
%~URL の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
◎
Otherwise, if c is U+0023 (#), set url’s fragment to the empty string and state to fragment state.
</li>
					<li>
<p>
~ELIF［
`C$V ~NEQ `EOF$i
］：
◎
Otherwise, if c is not the EOF code point:
</p>
						<ol>
							<li>
%~URL の`~query$url ~SET ~NULL
◎
Set url’s query to null.
</li>
							<li>
~IF［
並び［
`C$V, `C1$V, `C2$V
］は`~drive_letterから開始して$いない
］
⇒
%~URL の`~pathを短縮する$
◎
If the code point substring from pointer to the end of input does not start with a Windows drive letter, then shorten url’s path.
</li>
							<li>
<p>
~ELSE
⇒＃
`検証~error$( `file-invalid-Windows-drive-letter$err )；
%~URL の`~path$url ~SET « »
◎
Otherwise:
• File-invalid-Windows-drive-letter validation error.
• Set url’s path to « ».
</p>

<p class="note">注記：
これは、
~drive_letter用の（~platformに依存しない）過去互換対処である。
◎
This is a (platform-independent) Windows drive letter quirk.
</p>
							</li>
							<li>
%~pointer ~DECBY 1；
◎
↓</li>
							<li>
%state ~SET `~path$st
◎
Set state to path state and decrease pointer by 1.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~ELSE
⇒＃
%~pointer ~DECBY 1；
%state ~SET `~path$st
◎
Otherwise, set state to path state, and decrease pointer by 1.
</li>
		</ol>
	</dd>

<!--% file-slash-state -->
	<dt>`~file~slash@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`C$V ~IN { ❝/, ❝\ }
］：
◎
If c is U+002F (/) or U+005C (\), then:
</p>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝\
］
⇒
`検証~error$( `invalid-reverse-solidus$err )
◎
If c is U+005C (\), invalid-reverse-solidus validation error.
</li>
					<li>
%state ~SET `~file~host$st
◎
Set state to file host state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
<p>
~IF［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ `file^l
］：
◎
If base is non-null and base’s scheme is "file", then:
</p>
						<ol>
							<li>
%~URL の`~host$url ~SET %基底 の`~host$url
◎
Set url’s host to base’s host.
</li>
							<li>
<p>
~IF［
並び［
`C$V, `C1$V, `C2$V
］は`~drive_letterから開始して$いない
］~AND［［
%基底 の`~path$url[ 0 ]
］は`正規化-済み~drive_letter$である
］
⇒
%~URL の`~path$urlに［
%基底 の`~path$url[ 0 ]
］を`付加する$
◎
If the code point substring from pointer to the end of input does not start with a Windows drive letter and base’s path[0] is a normalized Windows drive letter, then append base’s path[0] to url’s path.
</p>

<p class="note">注記：
これは、
~drive_letter用の（~platformに依存しない）過去互換対処である。
◎
This is a (platform-independent) Windows drive letter quirk.
</p>
							</li>
						</ol>
					</li>
					<li>
%~pointer ~DECBY 1
◎
↓</li>
					<li>
%state ~SET `~path$st
◎
Set state to path state, and decrease pointer by 1.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% file-host-state -->
	<dt>`~file~host@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`C$V ~IN { `EOF$i, ❝/, ❝\, ❝?, ❝# }
］：
◎
If c is the EOF code point, U+002F (/), U+005C (\), U+003F (?), or U+0023 (#), then＼
</p>
				<ol>
					<li>
%~pointer ~DECBY 1
◎
decrease pointer by 1 and then:＼
</li>
					<li>
<p>
~IF［
%上書state ~EQ ε
］~AND［
%~buffer は`~drive_letter$である
］
⇒＃
`検証~error$( `file-invalid-Windows-drive-letter-host$err )；
%state ~SET `~path$st
◎
If state override is not given and buffer is a Windows drive letter, file-invalid-Windows-drive-letter-host validation error, set state to path state.
</p>

<p class="note">注記：
これは、
~drive_letter用の（~platformに依存しない）過去互換対処である。
ここでは %~buffer は設定し直されず，代わりに`~path$stの中で利用される。
◎
This is a (platform-independent) Windows drive letter quirk. buffer is not reset here and instead used in the path state.
</p>
					</li>
					<li>
<p>
~ELIF［
%~buffer ~EQ 空~文字列
］：
◎
Otherwise, if buffer is the empty string, then:
</p>
						<ol>
							<li>
%~URL の`~host$url ~SET 空~文字列
◎
Set url’s host to the empty string.
</li>
							<li>
~IF［
%上書state ~NEQ ε
］
⇒
~RET
◎
If state override is given, then return.
</li>
							<li>
%state ~SET `~path開始$st
◎
Set state to path start state.
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE：
◎
Otherwise, run these steps:
</p>
						<ol>
							<li>
%~host ~LET
`~host構文解析器$( %~buffer, ~IS［ %~URL は`特別$でない］ )
◎
Let host be the result of host parsing buffer with url is not special.
</li>
							<li>
~IF［
%~host ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If host is failure, then return failure.
</li>
							<li>
~IF［
%~host ~EQ `localhost^l
］
⇒
%~host ~SET 空~文字列
◎
If host is "localhost", then set host to the empty string.
</li>
							<li>
%~URL の`~host$url ~SET %~host
◎
Set url’s host to host.
</li>
							<li>
~IF［
%上書state ~NEQ ε
］
⇒
~RET
◎
If state override is given, then return.
</li>
							<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string and＼
</li>
							<li>
%state ~SET `~path開始$st
◎
state to path start state.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%~buffer ~APPEND `C$V
◎
Otherwise, append c to buffer.
</li>
		</ol>
	</dd>

<!--% path-start-state -->
	<dt>`~path開始@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
%~URL は`特別$である
］：
◎
If url is special, then:
</p>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝\
］
⇒
`検証~error$( `invalid-reverse-solidus$err )
◎
If c is U+005C (\), invalid-reverse-solidus validation error.
</li>
					<li>
~IF［
`C$V ~NIN { ❝/, ❝\ }
］
⇒
%~pointer ~DECBY 1
◎
Set state to path state.
◎
If c is neither U+002F (/) nor U+005C (\), then decrease pointer by 1.
</li>
					<li>
%state ~SET `~path$st
◎
↑</li>
				</ol>
			</li>
			<li>
~ELIF［
%上書state ~EQ ε
］~AND［
`C$V ~EQ ❝?
］
⇒＃
%~URL の`~query$url ~SET 空~文字列；
%state ~SET `~query$st
◎
Otherwise, if state override is not given and c is U+003F (?), set url’s query to the empty string and state to query state.
</li>
			<li>
~ELIF［
%上書state ~EQ ε
］~AND［
`C$V ~EQ ❝#
］
⇒＃
%~URL の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
◎
Otherwise, if state override is not given and c is U+0023 (#), set url’s fragment to the empty string and state to fragment state.
</li>
			<li>
<p>
~ELIF［
`C$V ~NEQ `EOF$i
］：
◎
Otherwise, if c is not the EOF code point:
</p>
				<ol>
					<li>
~IF［
`C$V ~NEQ ❝/
］
⇒
%~pointer ~DECBY 1
◎
Set state to path state.
◎
If c is not U+002F (/), then decrease pointer by 1.
</li>
					<li>
%state ~SET `~path$st
◎
↑</li>
				</ol>
			</li>
			<li>
~ELIF［
%上書state ~NEQ ε
］~AND［
%~URL の`~host$url ~EQ ~NULL
］
⇒
%~URL の`~path$urlに空~文字列を`付加する$
◎
Otherwise, if state override is given and url’s host is null, append the empty string to url’s path.
</li>
		</ol>
	</dd>

<!--% path-state -->
	<dt>`~path@st</dt>
	<dd>
		<ol>
			<li>
%~slashか ~LET ~IS［
`C$V ~EQ ❝/
］~OR［［
%~URL は`特別$である
］~AND［
`C$V ~EQ ❝\
］］
◎
↓</li>
			<li>
<p>
~IF［
~OR↓
］…
◎
If one of the following is true:
</p>
				<ul>
					<li>
`C$V ~EQ `EOF$i
◎
c is the EOF code point or U+002F (/)
↓</li>
					<li>
%~slashか ~EQ ~T
◎
url is special and c is U+005C (\)
</li>
					<li>
［
%上書state ~EQ ε
］~AND［
`C$V ~IN { ❝?, ❝# }
］：
◎
state override is not given and c is U+003F (?) or U+0023 (#)
</li>
				</ul>
<p>
…ならば：
◎
then:
</p>
				<ol>
					<li>
~IF［
%~URL は`特別$である
］~AND［
`C$V ~EQ ❝\
］
⇒
`検証~error$( `invalid-reverse-solidus$err )
◎
If url is special and c is U+005C (\), invalid-reverse-solidus validation error.
</li>
					<li>
<p>
~IF［
%~buffer は`二重-~dot~URL~path区分$である
］：
◎
If buffer is a double-dot URL path segment, then:
</p>
						<ol>
							<li>
%~URL の`~pathを短縮する$
◎
Shorten url’s path.
</li>
							<li>
<p>
~IF［
%~slashか ~EQ ~F
］
⇒
%~URL の`~path$urlに空~文字列を`付加する$
◎
If neither c is U+002F (/), nor url is special and c is U+005C (\), append the empty string to url’s path.
</p>

<p class="note">注記：
これは、
入力が `/usr/..^l なら，結果は `/^l になり，
~pathが無くなるわけではないことを意味する。
◎
This means that for input /usr/.. the result is / and not a lack of a path.
</p>
							</li>
						</ol>
					</li>
					<li>
~ELIF［
%~buffer は`単-~dot~URL~path区分$である
］
⇒
~IF［
%~slashか ~EQ ~F
］
⇒
%~URL の`~path$urlに空~文字列を`付加する$
◎
Otherwise, if buffer is a single-dot URL path segment and if neither c is U+002F (/), nor url is special and c is U+005C (\), append the empty string to url’s path.
</li>
					<li>
<p>
~ELSE：
◎
Otherwise, if buffer is not a single-dot URL path segment, then:
</p>
						<ol>
							<li>
<p>
~IF［
%~URL の`~scheme$url ~EQ `file^l
］~AND［
%~URL の`~path$urlは`空$である
］~AND［
%~buffer は`~drive_letter$である
］
⇒
%~buffer の 2 個目の~cpを ❝: に置換する
◎
If url’s scheme is "file", url’s path is empty, and buffer is a Windows drive letter, then replace the second code point in buffer with U+003A (:).
</p>

<p class="note">注記：
これは、
~drive_letter用の（~platformに依存しない）過去互換対処である。
◎
This is a (platform-independent) Windows drive letter quirk.
</p>
							</li>
							<li>
%~URL の`~path$urlに %~buffer を`付加する$
◎
Append buffer to url’s path.
</li>
						</ol>
					</li>
					<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
					<li>
~IF［
`C$V ~EQ ❝?
］
⇒＃
%~URL の`~query$url ~SET 空~文字列；
%state ~SET `~query$st
◎
If c is U+003F (?), then set url’s query to the empty string and state to query state.
</li>
					<li>
~IF［
`C$V ~EQ ❝#
］
⇒＃
%~URL の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
◎
If c is U+0023 (#), then set url’s fragment to the empty string and state to fragment state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise, run these steps:
</p>
				<ol>
					<li>
`~URL単位かどうか検証する$
◎
If c is not a URL code point and not U+0025 (%), invalid-URL-unit validation error.
◎
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, invalid-URL-unit validation error.
</li>
					<li>
%~buffer ~APPEND
`~cpを~UTF-8~percent-符号化する$( `C$V, `~path~percent-符号化-集合$ )
◎
UTF-8 percent-encode c using the path percent-encode set and append the result to buffer.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% opaque path state -->
	<dt>`不透明~path@st</dt>
	<dd>
		<ol>
			<li>
~IF［
`C$V ~EQ ❝?
］
⇒＃
%~URL の`~query$url ~SET 空~文字列；
%state ~SET `~query$st
◎
If c is U+003F (?), then set url’s query to the empty string and state to query state.
</li>
			<li>
~ELIF［
`C$V ~EQ ❝#
］
⇒＃
%~URL の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
◎
Otherwise, if c is U+0023 (#), then set url’s fragment to the empty string and state to fragment state.
</li>
			<li>
<p>
~ELIF［
`C$V ~NEQ `EOF$i
］：
◎
Otherwise:
</p>
				<ol>
					<li>
`~URL単位かどうか検証する$
◎
If c is not the EOF code point, not a URL code point, and not U+0025 (%), invalid-URL-unit validation error.
◎
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, invalid-URL-unit validation error.
</li>
					<li>
%~URL の`~path$url ~APPEND
`~cpを~UTF-8~percent-符号化する$( `C$V, `~C0制御文字~percent-符号化-集合$ )
◎
If c is not the EOF code point, UTF-8 percent-encode c using the C0 control percent-encode set and append the result to url’s path.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% query-state -->
	<dt>`~query@st</dt>
	<dd>
		<ol>
			<li>
~IF［
%~URL は`特別$でない
］~OR［
%~URL の`~scheme$url ~IN { `ws^l, `wss^l }
］
⇒
%符号化法 ~SET `~UTF-8$
◎
If encoding is not UTF-8 and one of the following is true:
• url is not special
• url’s scheme is "ws" or "wss"
◎
then set encoding to UTF-8.
</li>
			<li>
<p>
~IF［
~OR↓
］…
◎
If one of the following is true:
</p>
				<ul>
					<li>
［
%上書state ~EQ ε
］~AND［
`C$V ~EQ ❝#
］
◎
state override is not given and c is U+0023 (#)
</li>
					<li>
`C$V ~EQ `EOF$i
◎
c is the EOF code point
</li>
				</ul>
<p>
…ならば：
◎
then:
</p>
				<ol>
					<li>
%~query~percent-符号化-集合 ~LET %~URL に応じて
⇒＃
`特別$であるならば `特別~query~percent-符号化-集合$ ／
~ELSE_ `~query~percent-符号化-集合$
◎
Let queryPercentEncodeSet be the special-query percent-encode set if url is special; otherwise the query percent-encode set.
</li>
					<li>
<p>
%~URL の`~query$url ~APPEND 次の結果
⇒
`文字列を符号化してから~percent-符号化する$( %符号化法, %~buffer, %~query~percent-符号化-集合 )
◎
Percent-encode after encoding, with encoding, buffer, and queryPercentEncodeSet, and append the result to url’s query.
</p>

<p class="note">注記：
`~ISO-2022-JP符号化器$が~statefulであることに因り、
この演算は~cpごとには呼出せない。
◎
This operation cannot be invoked code-point-for-code-point due to the stateful ISO-2022-JP encoder.
</p>
					</li>
					<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
					<li>
~IF［
`C$V ~EQ ❝#
］
⇒＃
%~URL の`素片$url ~SET 空~文字列；
%state ~SET `素片$st
◎
If c is U+0023 (#), then set url’s fragment to the empty string and state to fragment state.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
`C$V ~NEQ `EOF$i
］：
◎
Otherwise, if c is not the EOF code point:
</p>
				<ol>
					<li>
`~URL単位かどうか検証する$
◎
If c is not a URL code point and not U+0025 (%), invalid-URL-unit validation error.
◎
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, invalid-URL-unit validation error.
</li>
					<li>
%~buffer ~APPEND `C$V
◎
Append c to buffer.
</li>
				</ol>
			</li>
		</ol>
	</dd>

<!--% fragment-state -->
	<dt>`素片@st</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`C$V ~NEQ `EOF$i
］：
◎
If c is not the EOF code point, then:
</p>
				<ol>
					<li>
`~URL単位かどうか検証する$
◎
If c is not a URL code point and not U+0025 (%), invalid-URL-unit validation error.
◎
If c is U+0025 (%) and remaining does not start with two ASCII hex digits, invalid-URL-unit validation error.
</li>
					<li>
%~URL の`素片$url ~APPEND
`~cpを~UTF-8~percent-符号化する$( `C$V, `素片~percent-符号化-集合$ )
◎
UTF-8 percent-encode c using the fragment percent-encode set and append the result to url’s fragment.
</li>
				</ol>
			</li>
		</ol>
	</dd>
</dl>

<p>
◎
↑↑Return url.
</p>
</div>

<hr>

<div class="algo">
<p>
`~URLの~usernameを設定する@
~algoは、
所与の
( `~URL$ %~URL, 文字列 %~username )
に対し
⇒
%~URL の`~username$url ~SET
`文字列を~UTF-8~percent-符号化する$( %~username, `~userinfo~percent-符号化-集合$ )
◎
To set the username given a url and username, set url’s username to the result of running UTF-8 percent-encode on username using the userinfo percent-encode set.
</p>
</div>

<div class="algo">
<p>
`~URLの~passwordを設定する@
~algoは、
所与の
( `~URL$ %~URL, 文字列 %~password )
に対し
⇒
%~URL の`~password$url ~SET
`文字列を~UTF-8~percent-符号化する$( %~password, `~userinfo~percent-符号化-集合$ )
◎
To set the password given a url and password, set url’s password to the result of running UTF-8 percent-encode on password using the userinfo percent-encode set.
</p>
</div>

		</section>
		<section id="url-serializing">
<h3 title="URL serializing">4.5. ~URLの直列化-法</h3>

<div class="algo">
<p>
`~URL直列化器@
は、
所与の
( `~URL$ %~URL, %素片は除外するか ~IN { `素片は除外する@i, ε }（省略時は ε ） )
に対し，次を走らせた結果の`~ASCII文字列$を返す：
◎
The URL serializer takes a URL url, with an optional boolean exclude fragment (default false), and then runs these steps. They return an ASCII string.
</p>

<ol>
	<li>
%出力 ~LET
空~文字列 ~APPEND %~URL の`~scheme$url
~APPEND ❝:
◎
Let output be url’s scheme and U+003A (:) concatenated.
</li>
	<li>
<p>
~IF［
%~URL の`~host$url ~NEQ ~NULL
］：
◎
If url’s host is non-null:
</p>
		<ol>
			<li>
%出力 ~APPEND `//^l
◎
Append "//" to output.
</li>
			<li>
<p>
~IF［
%~URL は`資格証を含んで$いる
］：
◎
If url includes credentials, then:
</p>
				<ol>
					<li>
%出力 ~APPEND %~URL の`~username$url
◎
Append url’s username to output.
</li>
					<li>
~IF［
%~URL の`~password$url ~NEQ 空~文字列
］
⇒
%出力 ~APPEND ❝:
~APPEND %~URL の`~password$url
◎
If url’s password is not the empty string, then append U+003A (:), followed by url’s password, to output.
</li>
					<li>
%出力 ~APPEND ❝@
◎
Append U+0040 (@) to output.
</li>
				</ol>
			</li>
			<li>
%出力 ~APPEND `~hostを直列化する$( %~URL の`~host$url )
◎
Append url’s host, serialized, to output.
</li>
			<li>
~IF［
%~URL の`~port$url ~NEQ ~NULL
］
⇒
%出力 ~APPEND ❝:
~APPEND `整数を直列化する$( %~URL の`~port$url )
◎
If url’s port is non-null, append U+003A (:) followed by url’s port, serialized, to output.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~URL の`~host$url ~EQ ~NULL
］~AND［
%~URL は`不透明な~path$を有さない
］~AND［
%~URL の`~path$urlの`~size$ ~GT 1
］~AND［
%~URL の`~path$url[ 0 ] ~EQ 空~文字列
］
⇒
%出力 ~APPEND ❝/
~APPEND ❝.
◎
If url’s host is null, url does not have an opaque path, url’s path’s size is greater than 1, and url’s path[0] is the empty string, then append U+002F (/) followed by U+002E (.) to output.
</p>

<p class="note">注記：
これは、
`web+demo:/.//not-a-host/^c
や
`web+demo:/path/..//not-a-host/^c
を
`構文解析-＠#concept-url-parser$してから
`直列化-＠#concept-url-serializer$した結果が
`web+demo://not-a-host/^c
になるのを防止する（結果は
`web+demo:/.//not-a-host/^c
になる）。
◎
This prevents web+demo:/.//not-a-host/ or web+demo:/path/..//not-a-host/, when parsed and then serialized, from ending up as web+demo://not-a-host/ (they end up as web+demo:/.//not-a-host/).
</p>
	</li>
	<li>
%出力 ~APPEND `~URL~pathを直列化する$( %~URL )
◎
Append the result of URL path serializing url to output.
</li>
	<li>
~IF［
%~URL の`~query$url ~NEQ ~NULL
］
⇒
%出力 ~APPEND ❝?
~APPEND %~URL の`~query$url
◎
If url’s query is non-null, append U+003F (?), followed by url’s query, to output.
</li>
	<li>
~IF［
%素片は除外するか ~EQ ε
］~AND［
%~URL の`素片$url ~NEQ ~NULL
］
⇒
%出力 ~APPEND ❝#
~APPEND %~URL の`素片$url
◎
If exclude fragment is false and url’s fragment is non-null, then append U+0023 (#), followed by url’s fragment, to output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~URL~pathを直列化する@
~algoは、
所与の
( `~URL$ %~URL )
に対し，`~ASCII文字列$を返す：
◎
The URL path serializer takes a URL url and then runs these steps. They return an ASCII string.
</p>
<ol>
	<li>
~IF［
%~URL は`不透明な~path$を有する
］
⇒
~RET %~URL の`~path$url
◎
If url has an opaque path, then return url’s path.
</li>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
%~URL の`~path$urlを成す
~EACH( %区分 )
に対し
⇒
%出力 ~APPEND ❝/
~APPEND %区分
◎
For each segment of url’s path: append U+002F (/) followed by segment to output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

		</section>
		<section id="url-equivalence">
<h3 title="URL equivalence">4.6. ~URLの等価性</h3>

<div class="algo">
<p>
所与の
( `~URL$ %A, `~URL$ %B )
が：
</p>
<ul>
	<li>
（単に）
`同等な~URL@
であるとは、
次が満たされることをいう
⇒
`~URLを直列化する$( %A ) ~EQ `~URLを直列化する$( %B )
</li>
	<li id="url-equals-exclude-fragments">
`素片は除外する^i下で`同等な~URL$であるとは、
次が満たされることをいう
⇒
`~URLを直列化する$( %A, `素片は除外する$i ) ~EQ `~URLを直列化する$( %B, `素片は除外する$i )
</li>
</ul>
◎
To determine whether a URL A equals URL B, with an optional boolean exclude fragments (default false), run these steps:
• Let serializedA be the result of serializing A, with exclude fragment set to exclude fragments.
• Let serializedB be the result of serializing B, with exclude fragment set to exclude fragments.
• Return true if serializedA is serializedB; otherwise false.
</div>

		</section>
		<section id="origin">
<h3 title="Origin">4.7. 生成元</h3>

<p class="note">注記：
必要な背景0情報については、
`HTML^cite による`生成元$の定義を見よ。
`HTML$r
◎
See origin’s definition in HTML for the necessary background information. [HTML]
</p>

<div class="algo">
<p>
`~URL$ %~URL の
`生成元@url
は、
%~URL の`~scheme$urlに応じて，次の手続きを走らせて返される`生成元$である：
◎
The origin of a URL url is the origin returned by running these steps, switching on url’s scheme:
</p>

<dl class="switch">
	<dt>`blob^l</dt>
	<dd>
		<ol>
			<li>
~IF［
%~URL の`~blob~URL~entry$url ~NEQ ~NULL
］
⇒
~RET %~URL の`~blob~URL~entry$urlの`環境$bUの`生成元$enV
◎
If url’s blob URL entry is non-null, then return url’s blob URL entry’s environment’s origin.
</li>
			<li>
%~path~URL ~LET `基本~URL構文解析器$( `~URL~pathを直列化する$( %~URL ) )
◎
Let pathURL be the result of parsing the result of URL path serializing url.
</li>
			<li>
~IF［
%~path~URL ~EQ `失敗^i
］
⇒
~RET 新たな`不透明な生成元$
◎
If pathURL is failure, then return a new opaque origin.
</li>
			<li>
~IF［
%~path~URL の`~scheme$url ~IN { `http^l, `https^l, `file^l }
］
⇒
~RET %~path~URL の`生成元$url
◎
If pathURL’s scheme is "http", "https", or "file", then return pathURL’s origin.
</li>
			<li>
~RET 新たな`不透明な生成元$
◎
Return a new opaque origin.
</li>
		</ol>
	</dd>
	<dd class="example">
`blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f^l
の`生成元$urlは、
`成分組~生成元$
( `https^l, `whatwg.org^l, ~NULL, ~NULL )
になる。
◎
The origin of blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f is the tuple origin ("https", "whatwg.org", null, null).
</dd>

	<dt>`ftp^l</dt>
	<dt>`http^l</dt>
	<dt>`https^l</dt>
	<dt>`ws^l</dt>
	<dt>`wss^l</dt>
	<dd>
~RET `成分組~生成元$( %~URL の`~scheme$url, %~URL の`~host$url, %~URL の`~port$url, ~NULL )
◎
Return the tuple origin (url’s scheme, url’s host, url’s port, null).
</dd>

	<dt>`file^l</dt>
	<dd>
あいにく、
これについては，
読者【~UA開発者】の行使に委ねられる。
疑わしい場合は、
新たな`不透明な生成元$を返すこと。
◎
Unfortunate as it is, this is left as an exercise to the reader. When in doubt, return a new opaque origin.
</dd>

	<dt>その他</dt>
	<dd>
<p>
~RET 新たな`不透明な生成元$
◎
Return a new opaque origin.
</p>

<p class="note">注記：
これは~~実際に、
この種の`~URL$は，自身と`同一-生成元$になり得ないことを意味する。
【毎回，異なる結果が返されるので。】
◎
This does indeed mean that these URLs cannot be same origin with themselves.
</p>
	</dd>
</dl>
</div>

		</section>
		<section id="url-rendering">
<h3 title="URL rendering">4.8. ~URLの具現化-法</h3>

<p>
`~URL$を表示する目的が，首に［
~securityや信用に関する裁定を利用者が為すこと
］にあるときは、［
`~URL直列化器$にかけた形
］に以下に述べる改変を加えた上で具現化するベキである。
例えば、
利用者は［
~URL~bar内に具現化された~URL
］に基いて［
信用に関する裁定を為す
］ものと予期される。
◎
A URL should be rendered in its serialized form, with modifications described below, when the primary purpose of displaying a URL is to have the user make a security or trust decision. For example, users are expected to make trust decisions based on a URL rendered in the browser address bar.
</p>

<p class="trans-note">【
“具現化（ `rendering^en ）” には、
~~描画に限らず，~~音声化なども含まれる
— それらの取扱いには多少異なる所もあろうが，同様な趣旨に従うことになる。
】</p>

			<section id="url-rendering-simplification">
<h4 title="Simplify non-human-readable or irrelevant components">4.8.1. ヒトが読めない／関連しない成分を単純~化する</h4>

<p>
~securityに関連な情報に対し［
偽装する／気をそらす
］機会を供し得る成分を除去する
— ~browserは：
◎
Remove components that can provide opportunities for spoofing or distract from security-relevant information:
</p>

<ul>
	<li>
［
末端~利用者が，~hostと~URLを成す他の各部（`~path$urlなど）とを判別できる
］ことが重要になる所では、
~URLの`~host$urlのみを具現化してもヨイ。
`登録-可能な~domain$に注目を引くよう，~hostを更に単純~化することを考慮してもヨイ。
例えば、
頭部を成す`~domain~label$［
`www^c や `m^c
］を省略して，~hostを単純~化してもヨイ。
あるいは，その`登録-可能な~domain$のみを表示して、
~subdomain
（例： `https://examplecorp.attacker.com/^c ）
による偽装~機会を除去してもヨイ。
◎
Browsers may render only a URL’s host in places where it is important for end users to distinguish between the host and other parts of the URL such as the path. Browsers may consider simplifying the host further to draw attention to its registrable domain. For example, browsers may omit a leading www or m domain label to simplify the host, or display its registrable domain only to remove spoofing opportunities posted by subdomains (e.g., https://examplecorp.attacker.com/).
</li>
	<li>
`~URL$の［
`~username$url, `~password$url
］を具現化するベキでない
— それらは `~URL$の`~host$urlに~~誤認され得るので
（例： `https://examplecorp.com~at々attacker.example/^c ）。
◎
Browsers should not render a URL’s username and password, as they can be mistaken for a URL’s host (e.g., https://examplecorp.com@attacker.example/).
</li>
	<li>
~URLを`~scheme$urlを伴わずに具現化してもヨイ
— そのような表示を単独の~schemeに限り許可している場合には
（~secureな生成元~用に限り可能化される， `https://^c を省略する~browser特能など）。
他の場合、
~schemeを［
ヒトが読める文字列（例： “~secureでない” ）
や~security指示子~icon, これら両者
］で置換したり補足してもヨイ。
◎
Browsers may render a URL without its scheme if the display surface only ever permits a single scheme (such as a browser feature that omits https:// because it is only enabled for secure origins). Otherwise, the scheme may be replaced or supplemented with a human-readable string (e.g., "Not secure"), a security indicator icon, or both.
</li>
</ul>

			</section>
			<section id="url-rendering-elision">
<h4 title="Elision">4.8.2. ~URLを省くとき</h4>

<p>
表示が狭いときに~URLの一部を省くときは、［
利用者が~securityに関する裁定を為すときに，誤りへ導くこと
］を注意深く避けるベキである
— ~browserは：
◎
In a space-constrained display, URLs should be elided carefully to avoid misleading the user when making a security decision:
</p>

<ul>
	<li>
~URLを具現化するときは、
少なくとも`登録-可能な~domain$は示されることを確保するベキである
（例：
`https://not-really-examplecorp.com/^c
を読込むとき，
`...examplecorp.com^c
と示されるのを避けるため）。
◎
Browsers should ensure that at least the registrable domain can be shown when the URL is rendered (to avoid showing, e.g., ...examplecorp.com when loading https://not-really-examplecorp.com/).
</li>
	<li>
全部的な`~host$urlを具現化できないときは、
`~domain~label群$を最低~levelのものから省くベキである。
例えば `examplecorp.com.evil.com^c は、
`examplecorp.com...^c ではなく，
`...com.evil.com^c のように省くベキである
（双方向-~textの場合、
最低~levelの~domain~labelは左端に現れないこともあることに注意）。
◎
When the full host cannot be rendered, browsers should elide domain labels starting from the lowest-level domain label. For example, examplecorp.com.evil.com should be elided as ...com.evil.com, not examplecorp.com.... (Note that bidirectional text means that the lowest-level domain label may not appear on the left.)
</li>
</ul>

			</section>
			<section id="url-rendering-i18n">
<h4 title="Internationalization and special characters">4.8.3. 国際-化と特殊~文字</h4>

<p>
［
国際-化~domain名（ IDN ）,
特殊~文字,
双方向-~text
］は、
偽装を防止するよう注意して取扱うベキである
— ~browserは：
◎
Internationalized domain names (IDNs), special characters, and bidirectional text should be handled with care to prevent spoofing:
</p>

<ul>
	<li>
<p>
`~URL$の`~host$url %~host を次の結果を利用して具現化するベキである
⇒
`~domainを~Unicode化する$( %~host, ~F )
◎
Browsers should render a URL’s host by running domain to Unicode with the URL’s host and false.
</p>

<p class="note">注記：
様々な文字が `homograph^en 【同型意義語／同型~glyph】偽装~攻撃に利用され得ることに注意。
利用-中にある混同され易い文字を検出して警告することを考慮すること。
`IDNFAQ$r
`UTS39$r
◎
Various characters can be used in homograph spoofing attacks. Consider detecting confusable characters and warning when they are in use. [IDNFAQ] [UTS39]
</p>
	</li>
	<li>
~URLが双方向-~textを包含する場合、
特に，~hostと~pathが混同され易い。
そのような事例では、
~URLの`~host$urlのみを具現化することを特に勧める。
可読性を得るために`~URL$の他の部分を具現化する場合、
`~percent-符号化された~byte$たちが成す連列 %文字列 を
`~BOMはそのままに~UTF-8復号する$( `文字列を~byte列に~percent-復号する$( %文字列 ) )
の結果を成す~cp列に置換するベキである
— その結果が不可視になる場合を除いて。
偽装~riskがあるような一定の並びは復号しないことを選んでもヨイ
（例： `1F512^U `🔒^smb ）。
◎
URLs are particularly prone to confusion between host and path when they contain bidirectional text, so in this case it is particularly advisable to only render a URL’s host. For readability, other parts of the URL, if rendered, should have their sequences of percent-encoded bytes replaced with code points resulting from running UTF-8 decode without BOM on the percent-decoding of those sequences, unless that renders those sequences invisible. Browsers may choose to not decode certain sequences that present spoofing risks (e.g., U+1F512 (🔒)).
</li>
	<li>
<p>
双方向-~textを左横書き埋め込み（ `left-to-right embedding^en ）内にあるかのように具現化するベキである。
`BIDI$r
◎
Browsers should render bidirectional text as if it were in a left-to-right embedding. [BIDI]
</p>

<p class="note">注記：
あいにく、
具現化される`~URL$は，どこにでも現れるような文字列であり、
具現化される`~URL$に特有な双方向-~algoがあっても，
広範に採用される見込みは薄いであろう。
双方向-~textによる~URLの各部への~~作用は、
ここでの~modelとは異なる具現化にさせ得る。
双方向-言語の利用者は、
特に素な~text環境の下では，これを期待するようになり得る。
◎
Unfortunately, as rendered URLs are strings and can appear anywhere, a specific bidirectional algorithm for rendered URLs would not see wide adoption. Bidirectional text interacts with the parts of a URL in ways that can cause the rendering to be different from the model. Users of bidirectional languages can come to expect this, particularly in plain text environments.
</p>
	</li>
</ul>

			</section>
		</section>
	</section>
	<section id="application/x-www-form-urlencoded">
<h2 title="application/x-www-form-urlencoded">5. ~form_urlencoded</h2>

<p>
`~form_urlencoded形式@
は、
`~query~parameter$たちが成す`~list$を符号化する仕方を供する。
◎
The application/x-www-form-urlencoded format provides a way to encode a list of tuples, each consisting of a name and a value.
</p>

<p class="note">注記：
~form_urlencoded形式は、
何年にもわたる実装の不幸な巡り合わせの結果，多くの面で奇異なものになっており、
相互運用能を得るために必要yな要件~群からなる，妥協の産物である
— 良い設計の実施を表現する仕方は無い。
読者は特に、
文字~符号化法と~byte列との間で繰返される（場合によっては入子にされた）変換のひねくれた詳細~に，注意を払うように。
あいにく，この形式は~HTML~formに普及しているがため、
広く利用されている。
`HTML$r
◎
The application/x-www-form-urlencoded format is in many ways an aberrant monstrosity, the result of many years of implementation accidents and compromises leading to a set of requirements necessary for interoperability, but in no way representing good design practices. In particular, readers are cautioned to pay close attention to the twisted details involving repeated (and in some cases nested) conversions between character encodings and byte sequences. Unfortunately the format is in widespread use due to the prevalence of HTML forms. [HTML]
</p>

		<section id="urlencoded-parsing">
<h3 title="application/x-www-form-urlencoded parsing">5.1. ~form_urlencoded構文解析-法</h3>

<p class="note">注記：
旧来の~server向け実装には、
`~UTF-8$以外の`符号化法$を~supportするとともに［
名 ~EQ `_charset^bl【！_charset_？】
］なる`~query~parameter$【！tuple】用に特別な~logicを伴うものもある。
そのような~logicは、
ここでは述べられない
— 適合するものは`~UTF-8$に限られる。
◎
A legacy server-oriented implementation might have to support encodings other than UTF-8 as well as have special logic for tuples of which the name is `_charset`. Such logic is not described here as only UTF-8 is conforming.
</p>

<div class="algo">
<p>
`~form_urlencoded構文解析器@
は、
所与の
( ~byte列 %入力 )
に対し：
◎
The application/x-www-form-urlencoded parser takes a byte sequence input, and then runs these steps:
</p>

<ol>
	<li>
%~byte列~list ~LET %入力 を `26^X `&amp;^smb で分割した結果
◎
Let sequences be the result of splitting input on 0x26 (&amp;).
</li>
	<li>
%出力 ~LET 新たな`~list$（`~query~parameter$たち）
◎
Let output be an initially empty list of name-value tuples where both name and value hold a string.
</li>
	<li>
<p>
%~byte列~list を成す
~EACH( %~byte列 )
に対し：
◎
For each byte sequence bytes in sequences:
</p>
		<ol>
			<li>
~IF［
%~byte列 ~EQ 空~byte列
］
⇒
~CONTINUE
◎
If bytes is the empty byte sequence, then continue.
</li>
			<li>
( %名, %値 ) ~LET ( %~byte列, 空~byte列 )
◎
↓</li>
			<li>
~IF［
%~byte列 内に ❛= が在る
］
⇒
( %名, %値 ) ~SET  %~byte列 を最初の ❛= の所で 2 個の~byte列に分割した結果
（その最初の ❛= は結果に含めない
— したがって，いずれも空~byte列になり得る）
◎
If bytes contains a 0x3D (=), then let name be the bytes from the start of bytes up to but excluding its first 0x3D (=), and let value be the bytes, if any, after the first 0x3D (=) up to the end of bytes. If 0x3D (=) is the first byte, then name will be the empty byte sequence. If it is the last, then value will be the empty byte sequence.
◎
Otherwise, let name have the value of bytes and let value be the empty byte sequence.
</li>
			<li>
［
%名, %値
］内のすべての ❛+ を `20^X (SP) に置換する
◎
Replace any 0x2B (+) in name and value with 0x20 (SP).
</li>
			<li>
%名~文字列 ~LET `~BOMはそのままに~UTF-8復号する$( `~byte列を~byte列に~percent-復号する$( %名 ) )
◎
↓</li>
			<li>
%値~文字列 ~LET `~BOMはそのままに~UTF-8復号する$( `~byte列を~byte列に~percent-復号する$( %値 ) )
◎
Let nameString and valueString be the result of running UTF-8 decode without BOM on the percent-decoding of name and value, respectively.
</li>
			<li>
%出力 に ( %名~文字列, %値~文字列 ) を`付加する$
◎
Append (nameString, valueString) to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

		</section>
		<section id="urlencoded-serializing">
<h3 title="application/x-www-form-urlencoded serializing">5.2. ~form_urlencoded直列化-法</h3>

<div class="algo">
<p>
`~form_urlencoded直列化器@
は、
所与の
( `~list$ %~parameter~list, `符号化法$ %符号化法 （省略時は`~UTF-8$ ） )
に対し，`~ASCII文字列$を返す：
◎
The application/x-www-form-urlencoded serializer takes a list of name-value tuples tuples, with an optional encoding encoding (default UTF-8), and then runs these steps. They return an ASCII string.
</p>
<ol>
	<li>
%符号化法 ~SET `符号化法から出力~符号化法を取得する$( %符号化法 )
◎
Set encoding to the result of getting an output encoding from encoding.
</li>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
<p>
%~parameter~list を成す
~EACH( %~parameter )
に対し：
◎
For each tuple of tuples:
</p>
		<ol>
			<li>
~Assert： %~parameter は`~query~parameter$である。
◎
Assert: tuple’s name and tuple’s value are scalar value strings.
</li>
			<li>
%名 ~LET `文字列を符号化してから~percent-符号化する$( %符号化法, %~parameter の名, `~form_urlencoded~percent-符号化-集合$, ~T )
◎
Let name be the result of running percent-encode after encoding with encoding, tuple’s name, the application/x-www-form-urlencoded percent-encode set, and true.
</li>
			<li>
%値 ~LET `文字列を符号化してから~percent-符号化する$( %符号化法, %~parameter の値, `~form_urlencoded~percent-符号化-集合$, ~T )
◎
Let value be the result of running percent-encode after encoding with encoding, tuple’s value, the application/x-www-form-urlencoded percent-encode set, and true.
</li>
			<li>
~IF［
%出力 ~NEQ 空~文字列
］
⇒
%出力 ~APPEND `0026^U `&amp;^smb
◎
If output is not the empty string, then append U+0026 (&amp;) to output.
</li>
			<li>
%出力
~APPEND %名
~APPEND ❝=
~APPEND %値
◎
Append name, followed by U+003D (=), followed by value, to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

		</section>
		<section id="urlencoded-hooks">
<h3 title="Hooks">5.3. ~hook</h3>

<div class="algo">
<p>
`~form_urlencoded文字列~構文解析器@
は、
所与の
( `~scalar値~文字列$ %入力 )
に対し
⇒
~RET `~form_urlencoded構文解析器$( `~UTF-8符号化する$( %入力 ) )
◎
The application/x-www-form-urlencoded string parser takes a scalar value string input, UTF-8 encodes it, and then returns the result of application/x-www-form-urlencoded parsing it.
</p>
</div>

		</section>
	</section>
	<section id="api">
<h2 title="API">6. ~API</h2>

<p>
この節は、
`Web IDL^cite による各種用語を利用する。
~browser~UAは、
この~APIを~supportするモノトスル。
~JS実装は、
この~APIを~supportするベキである。
他の［
~UA／~programming言語
］は、
各自の必要に相応しい~APIを利用することが奨励される
— この~APIとは異なることもあろうが。
`WEBIDL$r
◎
This section uses terminology from Web IDL. Browser user agents must support this API. JavaScript implementations should support this API. Other user agents or programming languages are encouraged to use an API suitable to their needs, which might not be this one. [WEBIDL]
</p>

		<section id="url-class">
<h3 title="URL class">6.1. `URL^I ~class</h3>

<pre class="idl">
[`Exposed$=*, `LegacyWindowAlias$=`webkitURL@]
interface `URL@I {
  `URL$mc(`USVString$ %url, optional `USVString$ %base);

  static `URL$I? `parse$m(`USVString$ %url, optional `USVString$ %base);
  static `boolean$ `canParse$m(`USVString$ %url, optional `USVString$ %base);

  <span id="url-stringification-behavior">stringifier</span> attribute `USVString$ `href$m;
  readonly attribute `USVString$ `origin$m;
           attribute `USVString$ `protocol$m;
           attribute `USVString$ `username$m;
           attribute `USVString$ `password$m;
           attribute `USVString$ `host$m;
           attribute `USVString$ `hostname$m;
           attribute `USVString$ `port$m;
           attribute `USVString$ `pathname$m;
           attribute `USVString$ `search$m;
  [`SameObject$] readonly attribute `URLSearchParams$I `searchParams$m;
           attribute `USVString$ `hash$m;

  `USVString$ `toJSON$m();
};
</pre>

<p>
各 `URL$I ~objには、
次に挙げるものが結付けられる：
◎
A URL object has an associated:
</p>
<ul>
	<li>
`~URL@URL
⇒
ある`~URL$
◎
URL: a URL.
</li>
	<li>
`~query~obj@URL
⇒
ある `URLSearchParams$I ~obj
◎
query object: a URLSearchParams object.
</li>
</ul>

<div class="algo">
<p>
`不透明な~pathならば その末尾にある~space列を剥ぐ@
~algoは、
所与の
( `URL$I ~obj %~URL~obj )
に対し：
◎
To potentially strip trailing spaces from an opaque path given a URL object url:
</p>
<ol>
	<li>
%~URL ~LET %~URL~obj の`~URL$URL
◎
↓</li>
	<li>
<p>
~IF［
%~URL は`不透明な~path$を有する
］~AND［
%~URL の`素片$url ~EQ ~NULL
］~AND［
%~URL の`~query$url ~EQ ~NULL
］：
</p>
		<ol>
			<li>
%~path文字列 ~LET %~URL の`~path$url
</li>
			<li>
~WHILE［
%~path文字列 は空でない
］~AND［
%~path文字列 の最後の文字 ~EQ `0020^U `SPACE^cn
］
⇒
%~path文字列 から最後の文字を除去する
</li>
			<li>
%~URL の`~path$url ~SET %~path文字列
</li>
		</ol>
◎
If url’s URL does not have an opaque path, then return.
◎
If url’s URL’s fragment is non-null, then return.
◎
If url’s URL’s query is non-null, then return.
◎
Remove all trailing U+0020 SPACE code points from url’s URL’s path.
</li>
</ol>
</div>

<div class="algo">
<p>
`~API~URL構文解析器@
は、
所与の
( `~scalar値~文字列$ %~URL, ［~NULL／`~scalar値~文字列$］ %基底【！（省略時は ~NULL ）】 )
に対し：
◎
The API URL parser takes a scalar value string url and an optional null-or-scalar value string base (default null), and then runs these steps:
</p>
<ol>
	<li>
%構文解析した基底 ~LET ~NULL
◎
Let parsedBase be null.
</li>
	<li>
<p>
~IF［
%基底 ~NEQ ~NULL
］：
◎
If base is non-null:
</p>
		<ol>
			<li>
%構文解析した基底 ~SET `基本~URL構文解析器$( %基底 )
◎
Set parsedBase to the result of running the basic URL parser on base.
</li>
			<li>
~IF［
%構文解析した基底 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If parsedBase is failure, then return failure.
</li>
		</ol>
	</li>
	<li>
~RET `基本~URL構文解析器$( %~URL, %構文解析した基底 )
◎
Return the result of running the basic URL parser on url with parsedBase.
</li>
</ol>
</div>

<div class="algo">
<p>
`~URL~objを初期化する@
~algoは、
所与の
( `URL$I ~obj %~URL, `~URL~record$ %~URL~record )
に対し：
◎
To initialize a URL object url with a URL urlRecord:
</p>
<ol>
	<li>
%~query ~LET %~URL~record の`~query$url
◎
Let query be urlRecord’s query,＼
</li>
	<li>
~IF［
%~query ~EQ ~NULL
］
⇒
%~query ~SET 空~文字列
◎
if that is non-null; otherwise the empty string.
</li>
	<li>
%~URL の`~URL$URL ~SET %~URL~record
◎
Set url’s URL to urlRecord.
</li>
	<li>
%~URL の`~query~obj$URL ~SET `新たな~obj$( `URLSearchParams$I )
◎
Set url’s query object to a new URLSearchParams object.
</li>
	<li>
`~query~objを初期化する$( %~URL の`~query~obj$URL,  %~query )
◎
Initialize url’s query object with query.
</li>
	<li>
%~URL の`~query~obj$URLの`~URL~obj$USP ~SET %~URL
◎
Set url’s query object’s URL object to url.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`new URL(url, base)@m
構築子~手続きは：
◎
The new URL(url, base) constructor steps are:
</p>
<ol>
	<li>
~IF［
%base ~EQ ε
］
⇒
%base ~SET ~NULL
◎
↓</li>
	<li>
%構文解析した~URL ~LET `~API~URL構文解析器$( %url, %base )
◎
Let parsedURL be the result of running the API URL parser on url with base, if given.
</li>
	<li>
~IF［
%構文解析した~URL ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parsedURL is failure, then throw a TypeError.
</li>
	<li>
`~URL~objを初期化する$( コレ, %構文解析した~URL )
◎
Initialize this with parsedURL.
</li>
</ol>
</div>

<div class="example">
<p>
`基底~URL$を利用せずに，
文字列を`構文解析-＠#concept-basic-url-parser$して`~URL$を得るときは、
単独の引数で `new URL()$m 構築子を呼び出す：
◎
To parse a string into a URL without using a base URL, invoke the URL constructor with a single argument:
</p>

<pre class="lang-js">
var %input = `https://example.org/💩^l,
    %url = new URL(%input);
%url.pathname; // `/%F0%9F%92%A9^l
</pre>

<p>
次のものは、
入力が`相対~URL$sTである場合，例外を投出する：
◎
This throws an exception if the input is a relative-URL string:
</p>

<pre class="lang-js">
try {
  var %url = new URL(`/🍣🍺^l);
} catch(%e) {
  // <span class="comment" title="that happened">ここに来る</span>
}
</pre>

<p>
`基底~URL$が必要yな事例では：
◎
For those cases a base URL is necessary:
</p>

<pre class="lang-js">
var %input = `/🍣🍺^l,
    %url = new URL(%input, document.baseURI);
%url.href; // `https://url.spec.whatwg.org/%F0%9F%8D%A3%F0%9F%8D%BA^l
</pre>

<p>
`URL$I ~objは、
`基底~URL$として利用できる
（~IDLからは引数として文字列が要求されるので、
`URL$I ~objは，その `href$m 取得子が返す値に文字列~化される）：
◎
A URL object can be used as a base URL (as the IDL requires a string as argument, a URL object stringifies to its href getter return value):
</p>

<pre class="lang-js">
var %url = new URL(`🌈^l, new URL(`https://pride.example/hello-world^l));
%url.pathname // `/%F0%9F%8F%B3%EF%B8%8F%E2%80%8D%F0%9F%8C%88^l
</pre>
</div>

<hr>

<div class="algo">
<p>
`parse(url, base)@m
静的~method手続きは：
◎
The static parse(url, base) method steps are:
</p>
<ol>
	<li>
%構文解析した~URL ~LET `~API~URL構文解析器$( %url, %base )
◎
Let parsedURL be the result of running the API URL parser on url with base, if given.
</li>
	<li>
~IF［
%構文解析した~URL ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If parsedURL is failure, then return null.
</li>
	<li>
%~URL ~LET `新たな~obj$( `URL$I )
◎
Let url be a new URL object.
</li>
	<li>
`~URL~objを初期化する$( %~URL, %構文解析した~URL )
◎
Initialize url with parsedURL.
</li>
	<li>
~RET %~URL
◎
Return url.
</li>
</ol>
</div>

<div class="algo">
<p>
`canParse(url, base)@m
静的~method手続きは：
◎
The static canParse(url, base) method steps are:
</p>
<ol>
	<li>
~IF［
%base ~EQ ε
］
⇒
%base ~SET ~NULL
◎
↓</li>
	<li>
%構文解析した~URL ~LET `~API~URL構文解析器$( %url, %base )
◎
Let parsedURL be the result of running the API URL parser on url with base, if given.
</li>
	<li>
~IF［
%構文解析した~URL ~EQ `失敗^i
］
⇒
~RET ~F
◎
If parsedURL is failure, then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<hr id="urlutils-members">

<div class="algo">
<p>
`toJSON()@m
~method手続き／
`href@m
取得子~手続きは：
<p>
<ol>
	<li>
~RET `~URLを直列化する$( コレの`~URL$URL )
</li>
</ol>
◎
The href getter steps and the toJSON() method steps are to return the serialization of this’s URL.
</div>

<div class="algo">
<p>
`href$m 設定子~手続きは：
◎
The href setter steps are:
</p>
<ol>
	<li>
%構文解析した~URL ~LET `基本~URL構文解析器$( 所与の値 )
◎
Let parsedURL be the result of running the basic URL parser on the given value.
</li>
	<li>
~IF［
%構文解析した~URL ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parsedURL is failure, then throw a TypeError.
</li>
	<li>
コレの`~URL$URL ~SET %構文解析した~URL
◎
Set this’s URL to parsedURL.
</li>
	<li>
コレの`~query~obj$URLの`~parameter~list$USPを`空にする$
◎
Empty this’s query object’s list.
</li>
	<li>
%~query ~LET コレの`~URL$URLの`~query$url
◎
Let query be this’s URL’s query.
</li>
	<li>
~IF［
%~query ~NEQ ~NULL
］
⇒
コレの`~query~obj$URLの`~parameter~list$USP ~SET `~form_urlencoded文字列~構文解析器$( %~query )
◎
If query is non-null, then set this’s query object’s list to the result of parsing query.
</li>
</ol>
</div>

<div class="algo">
<p>
`origin@m
取得子~手続きは：
<p>
<ol>
	<li>
~RET `生成元を直列化する$( コレの`~URL$URLの`生成元$url )
`HTML$r
</li>
</ol>
◎
The origin getter steps are to return the serialization of this’s URL’s origin. [HTML]
</div>

<div class="algo">
<p>
`protocol@m
取得子~手続きは：
<p>
<ol>
	<li>
~RET
空~文字列 ~APPEND コレの`~URL$URLの`~scheme$url
~APPEND ❝:
</li>
</ol>
◎
The protocol getter steps are to return this’s URL’s scheme, followed by U+003A (:).
</div>

<div class="algo">
<p>
`protocol$m 設定子~手続きは：
</p>
<ol>
	<li>
%入力 ~LET 所与の値 ~APPEND ❝:
</li>
	<li>
`~API用に~URL構文解析する$( %入力, コレの`~URL$URL, `~scheme開始$st )
</li>
</ol>
◎
The protocol setter steps are to basic URL parse the given value, followed by U+003A (:), with this’s URL as url and scheme start state as state override.
</div>

<div class="algo">
<p>
`username@m
取得子~手続きは：
<p>
<ol>
	<li>
~RET コレの`~URL$URLの`~username$url
</li>
</ol>
◎
The username getter steps are to return this’s URL’s username.
</div>

<div class="algo">
<p>
`username$m 設定子~手続きは：
◎
The username setter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
↓</li>
	<li>
~IF［
%~URL は`~username／~password／~portを有し得ない$
］
⇒
~RET
◎
If this’s URL cannot have a username/password/port, then return.
</li>
	<li>
`~URLの~usernameを設定する$( %~URL, 所与の値 )
◎
Set the username given this’s URL and the given value.
</li>
</ol>
</div>

<div class="algo">
<p>
`password@m
取得子~手続きは：
<p>
<ol>
	<li>
~RET コレの`~URL$URLの`~password$url
</li>
</ol>
◎
The password getter steps are to return this’s URL’s password.
</div>

<div class="algo">
<p>
`password$m 設定子~手続きは：
◎
The password setter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
↓</li>
	<li>
~IF［
%~URL は`~username／~password／~portを有し得ない$
］
⇒
~RET
◎
If this’s URL cannot have a username/password/port, then return.
</li>
	<li>
`~URLの~passwordを設定する$(  %~URL, 所与の値 )
◎
Set the password given this’s URL and the given value.
</li>
</ol>
</div>

<div class="algo">
<p>
`host@m
取得子~手続きは：
◎
The host getter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
Let url be this’s URL.
</li>
	<li>
~IF［
%~URL の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If url’s host is null, then return the empty string.
</li>
	<li>
%~host ~LET `~hostを直列化する$( `~host$url )
◎
↓</li>
	<li>
~IF［
%~URL の`~port$url ~EQ ~NULL
］
⇒
~RET %~host
◎
If url’s port is null, return url’s host, serialized.
</li>
	<li>
~RET %~host ~APPEND ❝:
~APPEND `整数を直列化する$( `~port$url )
◎
Return url’s host, serialized, followed by U+003A (:) and url’s port, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`host$m 設定子~手続きは：
◎
The host setter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
↓</li>
	<li>
~IF［
%~URL は`不透明な~path$を有する
］
⇒
~RET
◎
If this’s URL has an opaque path, then return.
</li>
	<li>
`~API用に~URL構文解析する$( 所与の値, %~URL, `~host$st )
◎
Basic URL parse the given value with this’s URL as url and host state as state override.
</li>
</ol>
<p class="note">注記：
`host$m 設定子に与える値が，`~URL~port$sTを欠いている場合、
%~URL の`~port$urlは変化しないことになる。
`host^m 取得子が`~URL~port$sTを返さないために、
設定子が常に両者を “設定し直す” と見做してしまいそうだが。
◎
If the given value for the host setter lacks a port, this’s URL’s port will not change. This can be unexpected as host getter does return a URL-port string so one might have assumed the setter to always "reset" both.
</p>
</div>

<div class="algo">
<p>
`hostname@m
取得子~手続きは：
◎
The hostname getter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
↓</li>
	<li>
~IF［
%~URL の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this’s URL’s host is null, then return the empty string.
</li>
	<li>
~RET `~hostを直列化する$( %~URL の`~host$url )
◎
Return this’s URL’s host, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`hostname$m 設定子~手続きは：
◎
The hostname setter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
↓</li>
	<li>
~IF［
%~URL は`不透明な~path$を有する
］
⇒
~RET
◎
If this’s URL has an opaque path, then return.
</li>
	<li>
`~API用に~URL構文解析する$( 所与の値, %~URL, `~hostname$st )
◎
Basic URL parse the given value with this’s URL as url and hostname state as state override.
</li>
</ol>
</div>

<div class="algo">
<p>
`port@m
取得子~手続きは：
◎
The port getter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
↓</li>
	<li>
~IF［
%~URL の`~port$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this’s URL’s port is null, then return the empty string.
</li>
	<li>
~RET `整数を直列化する$( %~URL の`~port$url )
◎
Return this’s URL’s port, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`port$m 設定子~手続きは：
◎
The port setter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
↓</li>
	<li>
~IF［
%~URL は`~username／~password／~portを有し得ない$
］
⇒
~RET
◎
If this’s URL cannot have a username/password/port, then return.
</li>
	<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%~URL の`~port$url ~SET ~NULL
◎
If the given value is the empty string, then set this’s URL’s port to null.
</li>
	<li>
~ELSE
⇒
`~API用に~URL構文解析する$( 所与の値, %~URL, `~port$st )
◎
Otherwise, basic URL parse the given value with this’s URL as url and port state as state override.
</li>
</ol>
</div>

<div class="algo">
<p>
`pathname@m
取得子~手続きは
⇒
~RET `~URL~pathを直列化する$( コレの`~URL$URL )
◎
The pathname getter steps are to return the result of URL path serializing this’s URL.
</p>
</div>

<div class="algo">
<p>
`pathname$m 設定子~手続きは：
◎
The pathname setter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
↓</li>
	<li>
~IF［
%~URL は`不透明な~path$を有する
］
⇒
~RET
◎
If this’s URL has an opaque path, then return.
</li>
	<li>
%~URL の`~path$urlを`空にする$
◎
Empty this’s URL’s path.
</li>
	<li>
`~API用に~URL構文解析する$( 所与の値, %~URL, `~path開始$st )
◎
Basic URL parse the given value with this’s URL as url and path start state as state override.
</li>
</ol>
</div>

<div class="algo">
<p>
`search@m
取得子~手続きは：
◎
The search getter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
↓</li>
	<li>
~IF［
%~URL の`~query$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this’s URL’s query is either null or the empty string, then return the empty string.
</li>
	<li>
~RET ［
❝? ~APPEND %~URL の`~query$url
］
◎
Return U+003F (?), followed by this’s URL’s query.
</li>
</ol>
</div>

<div class="algo">
<p>
`search$m 設定子~手続きは：
◎
The search setter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
Let url be this’s URL.
</li>
	<li>
%入力 ~LET 所与の値
◎
↓</li>
	<li>
<p>
~IF［
%入力 ~EQ 空~文字列
］：
◎
If the given value is the empty string:
</p>
		<ol>
			<li>
%~URL の`~query$url ~SET ~NULL
◎
Set url’s query to null.
</li>
			<li>
コレの`~query~obj$URLの`~parameter~list$USPを`空にする$
◎
Empty this’s query object’s list.
</li>
			<li>
`不透明な~pathならば その末尾にある~space列を剥ぐ$( コレ )
◎
Potentially strip trailing spaces from an opaque path with this.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~IF［
%入力 の先頭の~cp ~EQ ❝?
］
⇒
%入力 から先頭の~cpを除去する
◎
Let input be the given value with a single leading U+003F (?) removed, if any.
</li>
	<li>
%~URL の`~query$url ~SET 空~文字列
◎
Set url’s query to the empty string.
</li>
	<li>
`~API用に~URL構文解析する$( %入力, %~URL, `~query$st )
◎
Basic URL parse input with url as url and query state as state override.
</li>
	<li>
コレの`~query~obj$URLの`~parameter~list$USP ~SET `~form_urlencoded文字列~構文解析器$( %入力 )
◎
Set this’s query object’s list to the result of parsing input.
</li>
</ol>

<p class="note">注記：
`search$m 設定子には、
コレの`~URL$URLの`~path$urlから尾部を成す［
`0020^U `SPACE^cn からなる`~cp$列
］を除去する能性がある。
これを行うのは、
コレの`~URL$URLを`~URL直列化器$にかけてから`~URL構文解析器$にかけたとき，~~元と`同等な~URL$が得られるようにするためである。
◎
The search setter has the potential to remove trailing U+0020 SPACE code points from this’s URL’s path. It does this so that running the URL parser on the output of running the URL serializer on this’s URL does not yield a URL that is not equal.
</p>
</div>

<div class="algo">
<p>
`searchParams@m
取得子~手続きは：
<p>
<ol>
	<li>
~RET コレの`~query~obj$URL
</li>
</ol>
◎
The searchParams getter steps are to return this’s query object.
</div>

<div class="algo">
<p>
`hash@m
取得子~手続きは：
◎
The hash getter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
↓</li>
	<li>
~IF［
%~URL の`素片$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this’s URL’s fragment is either null or the empty string, then return the empty string.
</li>
	<li>
~RET ［
❝# ~APPEND %~URL の`素片$url
］
◎
Return U+0023 (#), followed by this’s URL’s fragment.
</li>
</ol>
</div>

<div class="algo">
<p>
`hash$m 設定子~手続きは：
◎
The hash setter steps are:
</p>
<ol>
	<li>
%~URL ~LET コレの`~URL$URL
◎
↓</li>
	<li>
%入力 ~LET 所与の値
◎
↓</li>
	<li>
<p>
~IF［
%入力 ~EQ 空~文字列
］：
◎
If the given value is the empty string:
</p>
		<ol>
			<li>
%~URL の`素片$url ~SET ~NULL；
◎
Set this’s URL’s fragment to null.
</li>
			<li>
`不透明な~pathならば その末尾にある~space列を剥ぐ$( コレ )
◎
Potentially strip trailing spaces from an opaque path with this.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~IF［
%入力 の先頭の~cp ~EQ ❝#
］
⇒
%入力 から先頭の~cpを除去する
◎
Let input be the given value with a single leading U+0023 (#) removed, if any.
</li>
	<li>
%~URL の`素片$url ~SET 空~文字列
◎
Set this’s URL’s fragment to the empty string.
</li>
	<li>
`~API用に~URL構文解析する$( %入力, %~URL, `素片$st )
◎
Basic URL parse input with this’s URL as url and fragment state as state override.
</li>
</ol>

<p class="note">注記：
`hash$m 設定子には、
`search$m 設定子と等価な方式で，
コレの`~URL$URLの`~path$urlを変更する能性がある。
◎
The hash setter has the potential to change this’s URL’s path in a manner equivalent to the search setter.
</p>
</div>

		</section>
		<section id="interface-urlsearchparams">
<h3 title="URLSearchParams class">6.2. `URLSearchParams^I ~class</h3>

<pre class="idl">
[`Exposed$=*]
interface `URLSearchParams@I {
  `URLSearchParams$mc(optional (`sequence$&lt;`sequence$&lt;`USVString$&gt;&gt; or `record$&lt;`USVString$, `USVString$&gt; or `USVString$) %init = "");

  readonly attribute `unsigned long$ `size$m;

  `undefined$ `append$m(`USVString$ %name, `USVString$ %value);
  `undefined$ `delete$m(`USVString$ %name, optional `USVString$ %value);
  `USVString$? `get$m(`USVString$ %name);
  `sequence$&lt;`USVString$&gt; `getAll$m(`USVString$ %name);
  `boolean$ `has$m(`USVString$ %name, optional `USVString$ %value);
  `undefined$ `set$m(`USVString$ %name, `USVString$ %value);

  `undefined$ `sort$m();

  `iterable$m&lt;`USVString$, `USVString$&gt;;
  `stringifier$m;
};
</pre>

<div class="example" id="example-constructing-urlsearchparams">
<p>
`URLSearchParams$I ~objを構築する／文字列~化するのは、
単直である：
◎
Constructing and stringifying a URLSearchParams object is fairly straightforward:
</p>

<pre class="lang-js">
let %params = new URLSearchParams({key: "730d67"})
%params.toString() // `key=730d67^l
</pre>
</div>

<div class="note" role="note">

<p>注記：
`URLSearchParams$I ~objは，`~form_urlencoded形式$を利用するので、
ある種の~cpを符号化するときに，
`URL$I ~objとの相違がある（ `href$m, `search$m も含め）。
とりわけ、
`searchParams$m を利用して`~URL~record$の`~query$urlに対し演算するときには，
意外な結果になり得る。
◎
As a URLSearchParams object uses the application/x-www-form-urlencoded format underneath there are some difference with how it encodes certain code points compared to a URL object (including href and search). This can be especially surprising when using searchParams to operate on a URL’s query.
</p>


<pre class="lang-js">
const %url = new URL('`https://example.com/?a=b ~^');
console.log(%url.href);   // `https://example.com/?a=b%20~^l
%url.searchParams.sort();
console.log(%url.href);   // `https://example.com/?a=b+%7E^l
</pre>


<pre class="lang-js">
const %url = new URL('`https://example.com/?a=~&amp;b=%7E^');
console.log(%url.search);                // `?a=~&amp;b=%7E^l
console.log(%url.searchParams.get('a')); // `~^l
console.log(%url.searchParams.get('b')); // `~^l
</pre>

<p>
`URLSearchParams$I ~objは、［
`0020^U `SPACE^cn は ❝+ に符号化する／
【他の】~cpのうち`~form_urlencoded~percent-符号化-集合$に入るものは~percent-符号化する
］ことになる。
◎
URLSearchParams objects will percent-encode anything in the application/x-www-form-urlencoded percent-encode set, and will encode U+0020 SPACE as U+002B (+).
</p>

<p>
`search$m は，符号化法を無視する（`~UTF-8$を利用する）下では、
~cpのうち［
`~URL~record$は`特別$であるならば `特別~query~percent-符号化-集合$／
~ELSE_ `~query~percent-符号化-集合$
］に入るものを~percent-符号化することになる。
【これは、`~query$st内の最後近くの段に対応する】
◎
Ignoring encodings (use UTF-8), search will percent-encode anything in the query percent-encode set or the special-query percent-encode set (depending on whether or not the URL is special).
</p>
</div>

<p>
各 `URLSearchParams$I ~objには、
次に挙げるものが結付けられる：
◎
A URLSearchParams object has an associated:
</p>
<ul>
	<li>
`~parameter~list@USP
⇒
`~query~parameter$たちが成す`~list$
— 初期~時は空とする。
◎
list: a list of tuples each consisting of a name and a value, initially empty.
</li>
	<li>
`~URL~obj@USP
⇒
~NULL ／ ある `URL$I ~obj
— 初期~時は ~NULL とする。
◎
URL object: null or a URL object, initially null.
</li>
</ul>

<p class="note">注記：
`URLSearchParams$I ~objのうち，
その`~URL~obj$USPが ~NULLでないものには、
`URL$I ~objの［
`search$m, `hash$m
］設定子と等価な方式で，
`~URL~obj$USPの`~path$urlを変更する能性がある。
◎
A URLSearchParams object with a non-null URL object has the potential to change that object’s path in a manner equivalent to the URL object’s search and hash setters.
</p>

<p>
`~query~parameter@
は、
( `~scalar値~文字列$ 名, `~scalar値~文字列$ 値 )
が成す`~tuple$である。
</p>

<p class="trans-note">【
`~query~parameter$は、
他所の記述を集約して意味を明確化するための，この訳による追加
（それに伴い，一部の変数~名も改めている（ %~tuple → %~parameter, 等々））。
】</p>

<div class="algo">
<p>
`~query~objを初期化する@
~algoは、
所与の
( `URLSearchParams$I ~obj %~query, %init )
に対し：
◎
To initialize a URLSearchParams object query with init:
</p>
<ol>
	<li>
<p>
%init の型に応じて：
◎
↓</p>
		<ul class="switch">
			<li>
<p>
`連列~型$である：
</p>
				<ol>
					<li>
%init を成す
~EACH( %内縁~連列 )
に対し
⇒
~IF［
%内縁~連列 の`~size$ ~NEQ 2
］
⇒
~THROW `TypeError$E
</li>
					<li>
%init を成す
~EACH( %内縁~連列 )
に対し
⇒
%~query の`~parameter~list$USPに
( %内縁~連列[ 0 ], %内縁~連列[ 1 ] )
を`付加する$
</li>
				</ol>
◎
If init is a sequence, then for each innerSequence of init:
• If innerSequence’s size is not 2, then throw a TypeError.
• Append (innerSequence[0], innerSequence[1]) to query’s list.
</li>
			<li>
`~record型$である
⇒
%init を成す
~EACH( %名 → %値 )
に対し
⇒
%~query の`~parameter~list$USPに ( %名, %値 ) を`付加する$
◎
Otherwise, if init is a record,＼
then for each name → value of init, append (name, value) to query’s list.
</li>
			<li>
文字列である
⇒
%~query の`~parameter~list$USP ~SET `~form_urlencoded文字列~構文解析器$( %init )
◎
Otherwise:
• Assert: init is a string.
• Set query’s list to the result of parsing init.
</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~query~objを更新する@
~algoは、
所与の
( `URLSearchParams$I ~obj %~query )
に対し：
◎
To update a URLSearchParams object query:
</p>
<ol>
	<li>
~IF［
%~query の`~URL~obj$USP ~EQ ~NULL
］
⇒
~RET
◎
If query’s URL object is null, then return.
</li>
	<li>
%直列化した~query ~LET `~form_urlencoded直列化器$( %~query の`~parameter~list$USP )
◎
Let serializedQuery be the serialization of query’s list.
</li>
	<li>
%~query の`~URL~obj$USPの`~URL$URLの`~query$url ~SET %直列化した~query に応じて
⇒＃
空~文字列 ならば ~NULL ／
~ELSE_ %直列化した~query
◎
If serializedQuery is the empty string, then set serializedQuery to null.
◎
Set query’s URL object’s URL’s query to serializedQuery.
</li>
	<li>
~IF［
%直列化した~query ~EQ ~NULL
］
⇒
`不透明な~pathならば その末尾にある~space列を剥ぐ$( %~query の`~URL~obj$USP )
◎
If serializedQuery is null, then potentially strip trailing spaces from an opaque path with query’s URL object.
</li>
</ol>
</div>

<div class="algo">
<p>
`new URLSearchParams(init)@m
構築子~手続きは：
◎
The new URLSearchParams(init) constructor steps are:
</p>
<ol>
	<li>
~IF［
%init の最初の~cp ~EQ ❝?
］
⇒
%init から最初の~cpを除去する
◎
If init is a string and starts with U+003F (?), then remove the first code point from init.
</li>
	<li>
`~query~objを初期化する$( コレ, %init )
◎
Initialize this with init.
</li>
</ol>
</div>

<div class="algo">
<p>
`size@m
取得子~手続きは：
</p>
<ol>
	<li>
~RET コレの`~parameter~list$USPの`~size$
</li>
</ol>
◎
The size getter steps are to return this’s list’s size.
</div>

<div class="algo">
<p>
`append(name, value)@m
~method手続きは：
◎
The append(name, value) method steps are:
</p>
<ol>
	<li>
コレの`~parameter~list$USPに ( %name, %value ) を`付加する$
◎
Append (name, value) to this’s list.
</li>
	<li>
`~query~objを更新する$( コレ )
◎
Update this.
</li>
</ol>
</div>

<div class="algo">
<p>
`delete(name, value)@m
~method手続きは：
◎
The delete(name, value) method steps are:
</p>
<ol>
	<li>
~IF［
%value ~NEQ ε
］
⇒
コレの`~parameter~list$USPから次を満たす`~query~parameter$【！~tuple】をすべて`除去する$
⇒
［
名 ~EQ %name
］~AND［
値 ~EQ %value
］
◎
If value is given, then remove all tuples whose name is name and value is value from this’s list.
</li>
	<li>
~ELSE
⇒
コレの`~parameter~list$USPから次を満たす`~query~parameter$【！~tuple】をすべて`除去する$
⇒
名 ~EQ %name
◎
Otherwise, remove all tuples whose name is name from this’s list.
</li>
	<li>
`~query~objを更新する$( コレ )
◎
Update this.
</li>
</ol>
</div>

<div class="algo">
<p>
`get(name)@m
~method手続きは：
</p>
<ol>
	<li>
コレの`~parameter~list$USPを成す
~EACH ( %~parameter )
に対し
⇒
~IF［
%~parameter の名 ~EQ %name
］
⇒
~RET %~parameter の値
</li>
	<li>
~RET ~NULL
</li>
</ol>
◎
The get(name) method steps are to return the value of the first tuple whose name is name in this’s list, if there is such a tuple; otherwise null.
</div>

<div class="algo">
<p>
`getAll(name)@m
~method手続きは：
</p>
<ol>
	<li>
%結果 ~LET 新たな`~list$
</li>
	<li>
コレの`~parameter~list$USPを成す
~EACH ( %~parameter )
に対し
⇒
~IF［
%~parameter の名 ~EQ %name
］
⇒
%結果 に %~parameter の値を`付加する$
</li>
	<li>
~RET %結果
</li>
</ol>

◎
The getAll(name) method steps are to return the values of all tuples whose name is name in this’s list, in list order; otherwise the empty sequence.
</div>

<div class="algo">
<p>
`has(name, value)@m
~method手続きは：
◎
The has(name, value) method steps are:
</p>
<ol>
	<li>
<p>
コレの`~parameter~list$USPを成す
~EACH ( %~parameter )
に対し：
</p>
		<ol>
			<li>
~IF［
%~parameter の名 ~NEQ %name
］
⇒
~CONTINUE
</li>
			<li>
~IF［
%value ~EQ ε
］
⇒
~RET ~T
</li>
			<li>
~IF［
%~parameter の値 ~EQ %value
］
⇒
~RET ~T
</li>
		</ol>
◎
If value is given and there is a tuple whose name is name and value is value in this’s list, then return true.
◎
If value is not given and there is a tuple whose name is name in this’s list, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`set(name, value)@m
~method手続きは：
◎
The set(name, value) method steps are:
</p>
<ol>
	<li>
%~parameter~list ~LET コレの`~parameter~list$USP
◎
↓</li>
	<li>
%設定したか ~LET ~F
◎
↓</li>
	<li>
<p>
%~parameter~list を成す
~EACH( %~parameter )
に対し：
</p>
		<ol>
			<li>
~IF［
%~parameter の名 ~NEQ %name
］
⇒
~CONTINUE
</li>
			<li>
~IF［
%設定したか ~EQ ~T
］
⇒＃
%~parameter~list から %~parameter を`除去する$；
~CONTINUE
</li>
			<li>
%~parameter の値 ~SET %value
</li>
			<li>
%設定したか ~SET ~T
</li>
		</ol>
◎
If this’s list contains any tuples whose name is name, then set the value of the first such tuple to value and remove the others.
</li>
	<li>
~IF［
%設定したか ~EQ ~F
］
⇒
%~parameter~list に ( %name, %value ) を`付加する$
◎
Otherwise, append (name, value) to this’s list.
</li>
	<li>
`~query~objを更新する$( コレ )
◎
Update this.
</li>
</ol>
</div>

<hr>

<div class="example" id="example-searchparams-sort">

<p>
`URLSearchParams$I ~objの`~parameter~list$USPを~sortすると有用になることもある
— 特に，~cache~hit率を高めれる。
これは、
`sort()$m ~methodを呼出すことで成遂げれる：
◎
It can be useful to sort the name-value tuples in a URLSearchParams object, in particular to increase cache hits. This can be accomplished through invoking the sort() method:
</p>

<pre class="lang-js">
const %url = new URL("https://example.org/?q=🏳️‍🌈&key=e1f7bc78");
%url.searchParams.sort();
%url.search; // `?key=e1f7bc78&q=%F0%9F%8F%B3%EF%B8%8F%E2%80%8D%F0%9F%8C%88^l
</pre>

<p>
元の入力を改めたくない場合（例：比較~目的）は、
新たな `URLSearchParams$I ~objを構築する：
◎
To avoid altering the original input, e.g., for comparison purposes, construct a new URLSearchParams object:
</p>

<pre class="lang-js">
const %sorted = new URLSearchParams(%url.search)
%sorted.sort()
</pre>
</div>

<div class="algo">
<p>
`sort()@m
~method手続きは：
</p>
<ol>
	<li>
%~parameter~list ~LET コレの`~parameter~list$USP
</li>
	<li>
<p>
%~sort済み~list ~LET `~listを昇順に~sortする$( %~parameter~list, 次の手続き )
</p>

<p class="algo">
手続きは、
所与の
( `~query~parameter$ %A, `~query~parameter$ %B )
に対し
⇒
~RET ~IS［
%A の名は %B の名 `未満の符号単位~列$である
］
</p>
	</li>
	<li>
%~parameter~list を`空にする$
</li>
	<li>
%~parameter~list を %~sort済み~list で`拡張する$
</li>
	<li>
`~query~objを更新する$( コレ )
</li>
</ol>

◎
The sort() method steps are:
• Sort all tuples in this’s list, if any, by their names. Sorting must be done by comparison of code units. The relative order between tuples with equal names must be preserved.
• Update this.
</div>

<div class="algo">
<p>
`iterable@m
における`反復される値~pair群$は，
コレの`~parameter~list$USPであり、
前者を成す各~pairを成す［
~key／値
］は，後者を成す各`~query~parameter$を成す［
名／値
］が与えるとする。
◎
The value pairs to iterate over are this’s list’s tuples with the key being the name and the value being the value.
</div>

<div class="algo">
<p>
`stringifier@m
における`文字列~化の挙動$を成す手続きは：
<p>
<ol>
	<li>
~RET `~form_urlencoded直列化器$( コレの`~parameter~list$USP )
</li>
</ol>
◎
The stringification behavior steps are to return the serialization of this’s list.
</div>

		</section>
		<section id="url-apis-elsewhere">
<h3 title="URL APIs elsewhere">6.3. 他の仕様における~URL~API</h3>

<p>
`~URL$を公開する標準は、
`~URL$を（内部的な`~URL$は`~URL直列化器$にかけるなどして）文字列として公開するベキである。
標準は、
`URL$I ~objを利用して`~URL$を公開するベキでない。
`URL$I ~objは、
`~URL$を操作するためにある。
~IDLにおいては、
`USVString^I 型が利用されるベキである。
◎
A standard that exposes URLs, should expose the URL as a string (by serializing an internal URL). A standard should not expose a URL using a URL object. URL objects are meant for URL manipulation. In IDL the USVString type should be used.
</p>

<p class="note">注記：
より高~levelな~~観点からは、
それらの値は，変異-不能な~data構造として公開されるものになる。
◎
The higher-level notion here is that values are to be exposed as immutable data structures.
</p>

<p>
標準が，自身が定義する特能の名前に `URL^l の変種を利用するものと裁定した場合、
その種の特能は `url^l （すなわち，小文字, 末尾は “エル” ）と命名するベキであり，
`URL^l, `URI^l, `IRI^l などの名前は利用されるベキでない。
しかしながら，その名前が複合的なものである場合は、
大文字の `URL^l が好ましい
— `newURL^l や `oldURL^l など。
◎
If a standard decides to use a variant of the name "URL" for a feature it defines, it should name such a feature "url" (i.e., lowercase and with an "l" at the end). Names such as "URL", "URI", and "IRI" should not be used. However, if the name is a compound, "URL" (i.e., uppercase) is preferred, e.g., "newURL" and "oldURL".
</p>

<p class="note">注記：
適正な命名~例としては、
`HTML^cite における［
`EventSource$I ／ `HashChangeEvent$I
］~interfaceが挙げられる。
`HTML$r
◎
The EventSource and HashChangeEvent interfaces in HTML are examples of proper naming. [HTML]
</p>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り，たくさんの方々が`~URL$を相互運用可能にするために助力され、
この標準の目標へ近付けてきた。
同様に，この標準は、
多くの方々からの助力により今日の姿に仕立て上げられている：
◎
There have been a lot of people that have helped make URLs more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</p>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main></div>

<div hidden>
<div lang="en" id="_acks1">
<p>
With that, many thanks to

<span lang="ja">100の人</span>,
Adam Barth,
Addison Phillips,
Adrián Chaves,
Adrien Ricciardi,
Albert Wiersch,
Alex Christensen,
Alexis Hunt,
Alexandre Morgaut,
Alexis Hunt,
Alwin Blok,
Andrew Sullivan,
Arkadiusz Michalski,
Behnam Esfahbod,
Bobby Holley,
Boris Zbarsky,
Brad Hill,
Brandon Ross,
Cailyn Hansen,
Chris Dumez,
Chris Rebert,
Corey Farwell,
Dan Appelquist,
Daniel Bratell,
Daniel Stenberg,
David Burns,
David Håsäther,
David Sheets,
David Singer,
David Walp,
Domenic Denicola,
Emily Schechter,
Emily Stark,
Eric Lawrence,
Erik Arvidsson,
Gavin Carothers,
Geoff Richards,
Glenn Maynard,
Gordon P. Hemsley,
hemanth,
Henri Sivonen,
Ian Hickson,
Ilya Grigorik,
Italo A. Casas,
Jakub Gieryluk,
James Graham,
James Manger,
James Ross,
Jeff Hodges,
Jeffrey Posnick,
Jeffrey Yasskin,
Joe Duarte,
Joshua Bell,
Jxck,
Karl Wagner,
Kemal Zebari,
<span lang="ja">田村健人</span> (Kent TAMURA),
Kevin Grandon,
Kornel Lesiński,
Larry Masinter,
Leif Halvard Silli,
Mark Amery,
Mark Davis,
Marcos Cáceres,
Marijn Kruisselbrink,
Martin Dürst,
Mathias Bynens,
Matt Falkenhagen,
Matt Giuca,
Michael Peick,
Michael™ Smith,
Michal Bukovský,
Michel Suignard,
Mikaël Geljić,
Noah Levitt,
Peter Occil,
Philip Jägenstedt,
Philippe Ombredanne,
Prayag Verma,
Rimas Misevičius,
Robert Kieffer,
Rodney Rehm,
Roy Fielding,
Ryan Sleevi,
Sam Ruby,
Sam Sneddon,
Santiago M. Mola,
Sebastian Mayr,
Simon Pieters,
Simon Sapin,
Steven Vachon,
Stuart Cook,
Sven Uhlig,
Tab Atkins,
<span lang="ja">吉野剛史</span> (Takeshi Yoshino),
Tantek Çelik,
Tiancheng "Timothy" Gu,
Tim Berners-Lee,
<span lang="zh">簡冠庭</span> (Tim Guan-tin Chien),
Titi_Alone,
Tomek Wytrębowicz,
Trevor Rowbotham,
Tristan Seligmann,
Valentin Gosu,
Vyacheslav Matva,
Wei Wang,
Wolf Lammen,
<span lang="ja">山岸和利</span> (Yamagishi Kazutoshi),
Yongsheng Zhang,
<span lang="ja">成瀬ゆい</span> (Yui Naruse), and
zealousidealroll

for being awesome!
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.apple.com/">Apple</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>
</div>

<div lang="en" id="_ipr1">
<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://url.spec.whatwg.org/review-drafts/2025-02/">Living Standard Review Draft</a>.
</p>
</div>
</div>

