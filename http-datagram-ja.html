<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP Datagrams（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">
<style>
.settings-parameter,
.frame-type,
.capsule,
.error-code {
	font-family: sans-serif0, sans-serif;
	color: var(--K-color);
}

.frame-diagram {
	margin: 0;
}

.frame-diagram > span[lang="en"] {
	white-space: pre;
}
</style>


<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options
spec_title:HTTP Datagrams
	spec_date:2022-08-
trans_update:2024-01-02
	source_checked:2022-08-
page_state_key:HTTP
original_url:https://www.rfc-editor.org/rfc/rfc9297.html
	abbr_url:HTTPdatagram
spec_status:IETFPR
no_original_dfn:true
ref_rfc:true
trans_1st_pub:2024-01-02

●●class_map
ft:frame-type
cps:capsule
er:error-code
hex:hex-value
sp:settings-parameter

●●tag_map
ft:code
cps:code
er:code
hex:span
sp:code
sup:sup

●●original_id_map
	h3-datagram-format:name-http-3-datagram-format
	h3-datagram-format:figure-1
	capsule-stream-format:name-capsule-protocol-stream-for
	capsule-stream-format:figure-2
	capsule-format:name-capsule-format
	capsule-format:figure-3
	datagram-capsule-format:name-datagram-capsule-format
	datagram-capsule-format:figure-4

●●mdn_urls

●●link_map

h.Capsule-Protocol:#hdr

ft.STREAM:~QUICv1#frame-stream
ft.DATAGRAM:~RFCx/rfc9221#datagram-frame-types
cps.DATAGRAM:#DATAGRAM

sp.SETTINGS_H3_DATAGRAM:#setting

er.H3_DATAGRAM_ERROR:#H3_DATAGRAM_ERROR
er.H3_SETTINGS_ERROR:~HTTPv3#H3_SETTINGS_ERROR
er.H3_ID_ERROR:~HTTPv3#H3_ID_ERROR

	●用語
~capsule:#dfn-capsule
~capsule~protocol:#dfn-capsule-protocol
~data~stream:#dfn-data-stream
~HTTP~datagram:#dfn-http-datagram

h3.受信器:~HTTPv3#h3-receiver
~HTTP3接続~error:~HTTPv3#quic-connection-error

	●用語（外部
~stream~ID:~QUICv1#section-2.1

有構造~field:~STRUCTURED-FIELDS#structured-field
~sf~list:~STRUCTURED-FIELDS#sf-list
~sf~item:~STRUCTURED-FIELDS#sf-item
~sf真偽値:~STRUCTURED-FIELDS#sf-boolean
~sf~parameter:~STRUCTURED-FIELDS#sf-parameter

	●§


●●words_table1
QUICv1:https://www.rfc-editor.org/rfc/rfc9000
HTTPv2:https://httpwg.org/specs/rfc9113.html
	HTTPv2:~RFCx/rfc9113

sf:<sub>sf-</sub>

●●words_table

	●略称／名称
IESG:
UDP:
QUIC:
HTTP1x:HTTP/1.x
HTTP2:HTTP/2
HTTP3:HTTP/3
0-RTT:
Upgrade:
WebSockets:
MASQUE:
MTU:
PMTU:
DPLPMTUD:

	^i:NewSessionTicket
	^i:FIN
	^en:HTTP Datagrams Design Team

	●network
受信器:receiver::~
多重化:multiplexing::~
多重化-:multiplex::~
逆多重化:demultiplexing::~
喪失:loss:~
流入:incoming:~
handshake::::ハンドシェイク
窓:window::~::ウインドウ
非依拠-:unrely:~
	相手の端点:peer
運び:carryし:~

	●stream／frame
datagram::::データグラム
四分:quarter::~
	~frame化:framing

	●処理
優先度化:prioritization:優先度付け
優先度化-:prioritize:優先度付け
黙って:silentに:~
clean:
累積-:accumulate::~
deadlock::::デッドロック

	●形式
可変長:variable-length:長さ可変
不正形:malformed:~

	●保安
枯渇-:exhaust:~
ボヤカす:obfuscateする:ぼやかす
探査-:probe:~
打破-:defeat:~
学習-:learn:~

	目立つ:sticks out
	目立つ:sticking out

	●仕様
合意-:agree:~
理論:theory:~
	理論~上:theoretical
分析:analysis:~
合法:legal:~
連絡先:contact:~
行使-:exercise:~
認可:approval:~
義務:mandatory:~
アテガい:assignment::あてがい
意見:input:~
template:
妨げる:preventする:~
起因-:stem:~
表記上の:notationalな:~
選べる:chooseできる:~
選ばれ:chooseされ:~
暫定的:provisional:~

	用意がある:willing
	用意はない:willing
	至らす:lead
	にもなり得る:potentially
	可用でない:unavailable
	望ましくない:undesirable
	望ましい:desirable
	難を伴わずに:without suffering
	誤った〜を表現-:misrepresent the true
	難しくなる:harder
	~~有益:helpful
	謝意:acknowledge
	感謝:thank
	助けに:help
	適した:suited
	~platform:Platform
	~error~code:Error Codes
	事実:fact
	により:by virtue of
	生み出され:came out of
	したくなる:tempted
	~~貴重:substantive

	●言い換え
	~header節$:headers
	何~往復-かの中で:on the order of a round trip
	~0-RTTを利用する:with their 0-RTT state
	導入すること:introduction
	~list:listing
	~bitの:-bit
	往復-:round trip
	空~行l$:blank line
	自己-整合な:to be self-consistent
	~~後続の 〜 し続け:skip over it to 〜 the next
	結付けて〜:an association to
	-:hexadecimal

	●言い換え（文字大小
	四分~stream~ID^i:Quarter Stream ID
	~HTTP~datagram~payload^i:HTTP Datagram Payload
	~capsule種別^i:Capsule Type
	~capsule長さ^i:Capsule Length
	~capsule値^i:Capsule Value
	経路~MTU:Path MTU
	~Upgrade:upgrade
	~capsule~protocol$:the Capsule Protocol
	~datagram:Datagram
	~HTTP~datagram$:HTTP Datagrams
	~datagram:Datagrams
	~capsule$:Capsule
	拡張d:the Extended
	~sf~item$:Item
	~sf~list$:List
	~sf真偽値$:Boolean
	`有構造~field$:Structured Field
	仕様が要求される施策$:Specification Required
	標準~化を通して$:Standards Action
	~IESGによる認可$:IESG Approval
	`~datagram~packet化~層~用の~PMTUの発見^cite:Datagram Packetization Layer PMTU Discovery
	以上／以下:inclusive

	●未分類
後続-:follow:~
冗長:redundant:~
伝達:conveyance:~
待受けて:awaitして:待ち受けて
切落さ:truncateさ:切り落とさ
収まる:fitする:~
落さな:dropしな:落とさな

	低過ぎる:too low
	大き過ぎる:too large
	大きく:large
	巨大:large
	最~大:largest
	より大きい:larger
	短か過ぎ:too short
	短い:short
	その逆を行って:vice versa
	一部を成すもの:part
	以上:greater than or equal to
	無かった:not present
	在る下で:presence
	有無:presence
	し直し:re-
	再-:re-
	各部:portions
	以前は:previously
	ときには:sometimes
	改変することなく:without modification
	締めくくる:conclude
	割り切れる:divisible
	なし:none


●●ref_key_map
WEBSOCKET:RFC6455

●●ref_normative

[HTTP]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP Semantics＞, STD 97, ~RFC9110, June 2022
[HTTP/1.1]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP/1.1＞, STD 99, ~RFC9112, June 2022
[HTTP/2]
    Thomson, M., Ed. and C. Benfield, Ed., ＜HTTP/2＞, ~RFC9113, June 2022
[HTTP/3]
    Bishop, M., Ed., ＜HTTP/3＞, ~RFC9114, June 2022
[IANA-POLICY]
    Cotton, M., Leiba, B., and T. Narten, ＜Guidelines for Writing an IANA Considerations Section in RFCs＞, BCP 26, ~RFC8126, June 2017
[QUIC]
    Iyengar, J., Ed. and M. Thomson, Ed., ＜QUIC: A UDP-Based Multiplexed and Secure Transport＞, ~RFC9000, May 2021
[QUIC-DGRAM]
    Pauly, T., Kinnear, E., and D. Schinazi, ＜An Unreliable Datagram Extension to QUIC＞, ~RFC9221, March 2022
[RFC2119]
    Bradner, S., ＜Key words for use in RFCs to Indicate Requirement Levels＞, BCP 14, ~RFC2119, March 1997
[RFC8174]
    Leiba, B., ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞, BCP 14, ~RFC8174, May 2017
[STRUCTURED-FIELDS]
    Nottingham, M. and P-H. Kamp, ＜Structured Field Values for HTTP＞, ~RFC8941, February 2021
[TCP]
    Eddy, W., Ed., ＜Transmission Control Protocol (TCP)＞, STD 7, ~RFC9293, August 2022

●●ref_informative

[DPLPMTUD]
    Fairhurst, G., Jones, T., Tüxen, M., Rüngeler, I., and T. Völker, ＜Packetization Layer Path MTU Discovery for Datagram Transports＞, ~RFC8899, September 2020
[EXT-CONNECT2]
    McManus, P., ＜Bootstrapping WebSockets with HTTP/2＞, ~RFC8441, September 2018
[EXT-CONNECT3]
    Hamilton, R., ＜Bootstrapping WebSockets with HTTP/3＞, ~RFC9220, June 2022
[PRIORITY]
    Oku, K. and L. Pardue, ＜Extensible Prioritization Scheme for HTTP＞, ~RFC9218, June 2022
[WEBSOCKET]
    Fette, I. and A. Melnikov, ＜The WebSocket Protocol＞, ~RFC6455, December 2011


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet Standard として公表された，
<a href="~SPEC_URL">HTTP Datagrams</a> （RFC 9297）
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata
Stream
	Internet Engineering Task Force (IETF)
RFC
	9297
分類
	Standards Track
ISSN
	2070-1721
日付
	2022 年 8 月
編集／著作者アドレス
	<a href="mailto:dschinazi.ietf@gmail.com">David Schinazi</a> (Google LLC)
	<a href="mailto:lucaspardue.24.7@gmail.com">Lucas Pardue</a> (Cloudflare)
履歴
	https://datatracker.ietf.org/doc/rfc9297/
現在の位置付け, フィードバックの方法
	https://www.rfc-editor.org/info/rfc9297
正誤表
	https://www.rfc-editor.org/errata_search.php?rfc=9297

</script>

</head>
<body>


<header>
	<hgroup>
<h1>HTTP データグラムとカプセルプロトコル</h1>
<p>RFC 9297 — HTTP Datagrams and the Capsule Protocol</p>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section>
◎要約

<p>
この文書は、
~HTTP~datagramを述べる
— それは、
~HTTP接続の内側で
多重化され, 非依拠-可能になり得る~datagramたちを伝達するための規約である。
◎
This document describes HTTP Datagrams, a convention for conveying multiplexed, potentially unreliable datagrams inside an HTTP connection.
</p>

<p>
~HTTP3においては、
`~HTTP~datagram$は，~QUIC `DATAGRAM$ft 拡張を利用して非依拠-可能に送信できる。
~QUIC `DATAGRAM$ft ~frameが［
可用でない／望ましくない
］ときは、
`~HTTP~datagram$を`~capsule~protocol$を利用して送信できる
— それは、
~HTTP接続において~dataを伝達するための，より一般な規約である。
◎
In HTTP/3, HTTP Datagrams can be sent unreliably using the QUIC DATAGRAM extension. When the QUIC DATAGRAM frame is unavailable or undesirable, HTTP Datagrams can be sent using the Capsule Protocol, which is a more general convention for conveying data in HTTP connections.
</p>

<p>
［
`~HTTP~datagram$／`~capsule~protocol$
］は、
応用ではなく，~HTTP拡張による利用-用に意図される。
◎
HTTP Datagrams and the Capsule Protocol are intended for use by HTTP extensions, not applications.
</p>

	</section>
	<section id="status-of-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status$に移譲。
】</p>

	</section>
	<section id="copyright">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
`~HTTP拡張＠~HTTPinfra#extending$ `HTTP$r は，ときには、
下層の~transport~protocol特能
— `QUIC-DGRAM$r により提供される非依拠-可能な送達など —
に~accessして，望ましい特能を可能化する必要がある。
これは、
例えば，次を許容することもできる：
◎
HTTP extensions (as defined in Section 16 of [HTTP]) sometimes need to access underlying transport protocol features such as unreliable delivery (as offered by [QUIC-DGRAM]) to enable desirable features. For example, this could allow＼
</p>
<ul>
	<li>
`CONNECT$m ~method【により確立される`~tunnel$】に非依拠-可能な~versionを導入する。
◎
for the introduction of an unreliable version of the CONNECT method and＼
</li>
	<li>
~WebSockets `WEBSOCKET$r 用に非依拠-可能な送達を追加する。
◎
the addition of unreliable delivery to WebSockets [WEBSOCKET].
</li>
</ul>

<p>
`§ ~HTTP~datagram＠#datagrams$
では、
`~HTTP~datagram$を述べる。
それは、
~HTTP接続の内側で，双方向な非依拠-可能にもなり得る~datagramたちを
— アリなときは多重化を伴って —
伝達するための規約である。
`~HTTP~datagram$には、
~HTTP要請が結付けられるが，`~message内容$の一部を成すものではない。
代わりに，それらは、
~HTTP拡張（ `CONNECT$m ~methodなど）による利用-用に意図され，
~HTTPを成す すべての~versionと互換である。
◎
In Section 2, this document describes HTTP Datagrams, a convention for conveying bidirectional and potentially unreliable datagrams inside an HTTP connection, with multiplexing when possible. While HTTP Datagrams are associated with HTTP requests, they are not a part of message content. Instead, they are intended for use by HTTP extensions (such as the CONNECT method) and are compatible with all versions of HTTP.
</p>

<p>
~HTTPが［
非依拠-可能な送達を~supportする ある~transport~protocol
］越しに走っているときは
（~HTTP3 `HTTP/3$r にて~QUIC `DATAGRAM$ft 拡張 `QUIC-DGRAM$r が可用なときなど）、
`~HTTP~datagram$は，その能力を利用できる。
◎
When HTTP is running over a transport protocol that supports unreliable delivery (such as when the QUIC DATAGRAM extension [QUIC-DGRAM] is available to HTTP/3 [HTTP/3]), HTTP Datagrams can use that capability.
</p>

<p>
`§ ~capsule＠#capsule$
では、
~HTTP用の`~capsule~protocol$を述べる。
それは、
依拠-可能な送達を利用して`~HTTP~datagram$の伝達を許容する。
これは、
次に取組む：
◎
In Section 3, this document describes the HTTP Capsule Protocol, which allows the conveyance of HTTP Datagrams using reliable delivery. This addresses＼
</p>
<ul>
	<li>
~HTTP3においては、
~QUIC `DATAGRAM$ft ~frameの利用は可用でないか望ましくない事例。
◎
HTTP/3 cases where use of the QUIC DATAGRAM frame is unavailable or undesirable＼
</li>
	<li>
当の~transport~protocolが依拠-可能な送達
— ~TCP越しな［
~HTTP11 ／
~HTTP2
］など `TCP$r `HTTP/1.1$r `HTTP/2$r —
しか供さない所。
◎
or where the transport protocol only provides reliable delivery, such as with HTTP/1.1 [HTTP/1.1] or HTTP/2 [HTTP/2] over TCP [TCP].
</li>
</ul>

		<section id="defs">
<h3 title="Conventions and Definitions">1.1. 規約と定義</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

<p>
この文書は、
`QUIC$r による各種用語を利用する。
◎
This document uses terminology from [QUIC].
</p>

<p>
この文書が~protocol【~protocol要素の】種別を定義する所では、
定義~形式は，
`QUIC$r `§ 表記上の規約＠~QUICv1#notation$ による記法を利用する。
各~種別の中の~fieldが整数をとる所では、
それらは
`QUIC$r `§ 可変長な整数の符号化法＠~QUICv1#integer-encoding$
を利用して符号化される。
整数~値は、
必要yな最小な~byte数で符号化される必要はない。
◎
Where this document defines protocol types, the definition format uses the notation from Section 1.3 of [QUIC]. Where fields within types are integers, they are encoded using the variable-length integer encoding from Section 16 of [QUIC]. Integer values do not need to be encoded on the minimum number of bytes necessary.
</p>

<p>
この文書における用語 `中継者$は、
`HTTP$r のそれを指す。
◎
In this document, the term "intermediary" refers to an HTTP intermediary as defined in Section 3.7 of [HTTP].
</p>

		</section>
	</section>
	<section id="datagrams">
<h2 title="HTTP Datagrams">2. ~HTTP~datagram</h2>

<p>
`~HTTP~datagram@
（ `HTTP Datagrams^en ）は、
~HTTP接続の内側で，双方向な非依拠-可能にもなり得る~datagramたちを
— アリなときは多重化を伴って —
伝達するための規約である。
すべての`~HTTP~datagram$には、
ある~HTTP要請が結付けられる。
◎
HTTP Datagrams are a convention for conveying bidirectional and potentially unreliable datagrams inside an HTTP connection with multiplexing when possible. All HTTP Datagrams are associated with an HTTP request.
</p>

<p>
`~HTTP~datagram$が~HTTP3接続~上で伝達されるときは、
~QUIC `DATAGRAM$ft ~frameを利用して，逆多重化と非依拠-可能な送達を供せる
— `§ ~HTTP3~datagram＠#format$ を見よ。
`~HTTP~datagram$用に~QUIC `DATAGRAM$ft ~frameの利用を折衝することは、
~HTTP3設定群の交換を介して達成される
— `SETTINGS_H3_DATAGRAM$sp 【！`§ 2.1.1＠#setting$】を見よ。
◎
When HTTP Datagrams are conveyed on an HTTP/3 connection, the QUIC DATAGRAM frame can be used to provide demultiplexing and unreliable delivery; see Section 2.1. Negotiating the use of QUIC DATAGRAM frames for HTTP Datagrams is achieved via the exchange of HTTP/3 settings; see Section 2.1.1.
</p>

<p>
~HTTP2越しに走っているときは、
逆多重化は~HTTP2~frame化~層により供されるが，非依拠-可能な送達は可用でない。
~HTTP~datagramは、
`~capsule~protocol$を利用して折衝され，伝達される
— `3.5＠#datagram-capsule§
を見よ。
◎
When running over HTTP/2, demultiplexing is provided by the HTTP/2 framing layer, but unreliable delivery is unavailable. HTTP Datagrams are negotiated and conveyed using the Capsule Protocol; see Section 3.5.
</p>

<p>
~HTTP1x越しに走っているときは、
要請は接続~内で厳密に直列化されるので，逆多重化は可用でない。
同様に，非依拠-可能な送達は可用でない。
`~HTTP~datagram$は、
`~capsule~protocol$を利用して折衝され, 伝達される
— `3.5＠#datagram-capsule§
を見よ。
◎
When running over HTTP/1.x, requests are strictly serialized in the connection; therefore, demultiplexing is not available. Unreliable delivery is likewise not available. HTTP Datagrams are negotiated and conveyed using the Capsule Protocol; see Section 3.5.
</p>

<p>
`~HTTP~datagram$を［
それを明示的に~supportしない~HTTP要請
］に結付けて送信してはナラナイ。
例えば、
既存の~HTTP~method［
`GET$m ／ `POST$m
］は，`~HTTP~datagram$用の意味論を定義しないので、
`~HTTP~datagram$を［
`GET$m ／ `POST$m
］要請~streamに結付けて送信することはできない。
◎
HTTP Datagrams MUST only be sent with an association to an HTTP request that explicitly supports them. For example, existing HTTP methods GET and POST do not define semantics for associated HTTP Datagrams; therefore, HTTP Datagrams associated with GET or POST request streams cannot be sent.
</p>

<p>
受信した~HTTP~datagramが`~HTTP~datagram$用に既知な意味論が無い要請に結付けられている場合、
受信器は，当の要請を終了しなければナラナイ。
~HTTP3が利用-中にある場合、
当の要請~streamを `H3_DATAGRAM_ERROR$er （ `0x33^hex ）で中止しなければナラナイ。
~HTTP拡張は、
`~HTTP~datagram$用の［
折衝の仕組み, 意味論
］を定義することにより，これらの要件を上書きしてもヨイ。
◎
If an HTTP Datagram is received and it is associated with a request that has no known semantics for HTTP Datagrams, the receiver MUST terminate the request. If HTTP/3 is in use, the request stream MUST be aborted with H3_DATAGRAM_ERROR (0x33). HTTP extensions MAY override these requirements by defining a negotiation mechanism and semantics for HTTP Datagrams.
</p>

		<section id="format">
<h3 title="HTTP/3 Datagrams">2.1. ~HTTP3~datagram</h3>

<p>
~QUIC `DATAGRAM$ft ~frameの `~datagram~data^i ~fieldは、
~HTTP3と伴に利用されるときは，次の形式を利用する：
◎
When used with HTTP/3, the Datagram Data field of QUIC DATAGRAM frames uses the following format:
</p>

<figure id="h3-datagram-format">
<pre class="frame-diagram">
~HTTP3~datagram {
  四分~stream~ID (i),
  ~HTTP~datagram~payload (..),
}
◎
HTTP/3 Datagram {
  Quarter Stream ID (i),
  HTTP Datagram Payload (..),
}
</pre>
<figcaption>
~HTTP3~datagramの形式
◎
Figure 1: HTTP/3 Datagram Format
</figcaption></figure>

<dl>
	<dt>
`四分~stream~ID^i
◎
Quarter Stream ID:
</dt>
	<dd>
この~datagramが結付けられた［
~clientが起動した双方向~stream
］【の`~stream~ID$】を 4 で除算した結果を可変長な整数として包含する
（ 4 による除算は、
~HTTP要請は~clientが起動した双方向~stream上に送信され，
その~stream~IDは 4 で割り切れる事実に起因する）。
~QUIC`~stream~ID$として合法な値の最~大は
2`62^sup ~MINUS 1
なので，
`四分~stream~ID^i ~fieldとして合法な値の最~大は
2`60^sup ~MINUS 1
になる。
より大きい値を内包する~HTTP3~datagramの受領は、
`~HTTP3接続~error$( `H3_DATAGRAM_ERROR$er )
として扱わなければナラナイ。
◎
A variable-length integer that contains the value of the client-initiated bidirectional stream that this datagram is associated with divided by four (the division by four stems from the fact that HTTP requests are sent on client-initiated bidirectional streams, which have stream IDs that are divisible by four). The largest legal QUIC stream ID value is 262-1, so the largest legal value of the Quarter Stream ID field is 260-1. Receipt of an HTTP/3 Datagram that includes a larger value MUST be treated as an HTTP/3 connection error of type H3_DATAGRAM_ERROR (0x33).
</dd>

	<dt>
`~HTTP~datagram~payload^i
◎
HTTP Datagram Payload:
</dt>
	<dd>
当の~datagramの~payload
— その意味論は、
`~HTTP~datagram$を利用して，当の拡張により定義される。
この~fieldは，空になり得ることに注意。
◎
The payload of the datagram, whose semantics are defined by the extension that is using HTTP Datagrams. Note that this field can be empty.
</dd>
</dl>

<p>
受信した~QUIC `DATAGRAM$ft ~frameの~payloadが，
`四分~stream~ID^i ~fieldの構文解析を許容しないまでに短か過ぎる場合、
`~HTTP3接続~error$( `H3_DATAGRAM_ERROR$er )
として扱わなければナラナイ。
◎
Receipt of a QUIC DATAGRAM frame whose payload is too short to allow parsing the Quarter Stream ID field MUST be treated as an HTTP/3 connection error of type H3_DATAGRAM_ERROR (0x33).
</p>

<p>
~HTTP3~datagramを［
対応している~streamの送信-側が~openでない間
］に送信してはナラナイ。
ある~datagramを［
対応している~streamの受信-側が~closeされた後
］に受信した場合、
黙って落さなければナラナイ。
◎
HTTP/3 Datagrams MUST NOT be sent unless the corresponding stream's send side is open. If a datagram is received after the corresponding stream's receive side is closed, the received datagrams MUST be silently dropped.
</p>

<p>
受信した~HTTP3~datagramの `四分~stream~ID^i ~fieldが，
まだ作成されてない~streamへ対応付けられる場合、
`受信器$h3は，次のいずれかに従わなければナラナイ【！SHALL】：
◎
If an HTTP/3 Datagram is received and its Quarter Stream ID field maps to a stream that has not yet been created, the receiver SHALL either＼
</p>
<ul>
	<li>
当の~datagramを黙って落とす。
◎
drop that datagram silently＼
</li>
	<li>
対応している~streamの作成を（何~往復-かの中で）待受けている間，
当の~datagramを一時的に~bufferする。
◎
or buffer it temporarily (on the order of a round trip) while awaiting the creation of the corresponding stream.
</li>
</ul>

<p>
受信した~HTTP3~datagramの `四分~stream~ID^i ~fieldが［
~clientが起動する双方向~streamの【個数に対する】上限
］に因り，作成し得ない~streamへ対応付けられる場合、
当の~datagramは，
`~HTTP3接続~error$( `H3_ID_ERROR$er )
として扱われるベキである。
~QUIC~streamの上限は，~HTTP3層には未知かもしれないので、
~errorを生成することは義務でない。
◎
If an HTTP/3 Datagram is received and its Quarter Stream ID field maps to a stream that cannot be created due to client-initiated bidirectional stream limits, it SHOULD be treated as an HTTP/3 connection error of type H3_ID_ERROR. Generating an error is not mandatory because the QUIC stream limit might be unknown to the HTTP/3 layer.
</p>

<p>
この文書では、
~HTTP3~datagramたちの優先度化は定義されない。
将来の拡張は、［
~datagramたちを優先度化する方法／
優先度化の選好を通信することを許容するための通達-法
］を定義してもヨイ。
◎
Prioritization of HTTP/3 Datagrams is not defined in this document. Future extensions MAY define how to prioritize datagrams and MAY define signaling to allow communicating prioritization preferences.
</p>

			<section id="setting">
<h4 title="The SETTINGS_H3_DATAGRAM HTTP/3 Setting">2.1.1. `SETTINGS_H3_DATAGRAM^sp ~HTTP3設定</h4>

<p>
端点は、
値 1 を伴う
`SETTINGS_H3_DATAGRAM^sp
設定（ `0x33^hex ）を送信することにより，［
自身は~HTTP3~datagramを受信する用意がある
］ことを相手の端点に指示できる。
◎
An endpoint can indicate to its peer that it is willing to receive HTTP/3 Datagrams by sending the SETTINGS_H3_DATAGRAM (0x33) setting with a value of 1.
</p>

<p>
`SETTINGS_H3_DATAGRAM^sp 設定の値は、
0 か 1 でなければナラナイ。
値 0 は、［
実装には，`~HTTP~datagram$を受信する用意はない
］ことを指示する。
受信した `SETTINGS_H3_DATAGRAM^sp 設定の値が 0, 1 どちらでもない場合、
`受信器$h3は，当の接続を~error `H3_SETTINGS_ERROR$er で終了しなければナラナイ。
◎
The value of the SETTINGS_H3_DATAGRAM setting MUST be either 0 or 1. A value of 0 indicates that the implementation is not willing to receive HTTP Datagrams. If the SETTINGS_H3_DATAGRAM setting is received with a value that is neither 0 nor 1, the receiver MUST terminate the connection with error H3_SETTINGS_ERROR.
</p>

<p>
~QUIC `DATAGRAM$ft ~frameは、
値 1 を伴う `SETTINGS_H3_DATAGRAM^sp 設定が送信され, かつ受信されるまでは送信してはナラナイ。
◎
QUIC DATAGRAM frames MUST NOT be sent until the SETTINGS_H3_DATAGRAM setting has been both sent and received with a value of 1.
</p>

<p>
~0-RTT を利用する~clientは、
【それまでに受信した】
~serverの `SETTINGS_H3_DATAGRAM^sp 設定の値を格納してもヨイ。
これは、
~0-RTT~packet内に~QUIC `DATAGRAM$ft ~frameを送信することを~clientに許容する。
~serverは、
~0-RTT~dataを受容するものと裁定したときは，
`SETTINGS_H3_DATAGRAM^sp 設定を送信しなければナラナイ
— その値を［
自身が `NewSessionTicket^i ~messageを送信した接続において~clientへ送信した【同じ設定の】値
］以上にして。
【！a client, their, they】
~clientは、［
~0-RTT用に `SETTINGS_H3_DATAGRAM^sp 設定の値を格納した
］かつ［
~0-RTTを利用する
］ならば，［
~handshakeにおいて~serverにより送信された `SETTINGS_H3_DATAGRAM^sp 設定の新たな値
］が格納した値~以上であることを検証しなければナラナイ
— そうでない場合、
当の接続を~error `H3_SETTINGS_ERROR$er で終了しなければナラナイ。
すべての事例において、
`SETTINGS_H3_DATAGRAM^sp 設定~parameterに許可される最大な値は 1 である。
◎
When clients use 0-RTT, they MAY store the value of the server's SETTINGS_H3_DATAGRAM setting. Doing so allows the client to send QUIC DATAGRAM frames in 0-RTT packets. When servers decide to accept 0-RTT data, they MUST send a SETTINGS_H3_DATAGRAM setting greater than or equal to the value they sent to the client in the connection where they sent them the NewSessionTicket message. If a client stores the value of the SETTINGS_H3_DATAGRAM setting with their 0-RTT state, they MUST validate that the new value of the SETTINGS_H3_DATAGRAM setting sent by the server in the handshake is greater than or equal to the stored value; if not, the client MUST terminate the connection with error H3_SETTINGS_ERROR. In all cases, the maximum permitted value of the SETTINGS_H3_DATAGRAM setting parameter is 1.
</p>

<p>
~HTTP3~datagramの受信を~supportする実装には、
応用が~HTTP3~datagramを利用するよう意図しない場合でも常に，［
値 1 を伴う `SETTINGS_H3_DATAGRAM^sp 設定を送信する
］ことが`推奨される^2119。
これは、 “目立つ” ことを避ける助けになる
— `§ ~securityの考慮点＠#security$
を見よ。
◎
It is RECOMMENDED that implementations that support receiving HTTP/3 Datagrams always send the SETTINGS_H3_DATAGRAM setting with a value of 1, even if the application does not intend to use HTTP/3 Datagrams. This helps to avoid "sticking out"; see Section 4.
</p>

			</section>
		</section>
		<section id="http-datagrams-using-capsules">
<h3 title="HTTP Datagrams Using Capsules">2.2. ~capsule利用している~HTTP~datagram</h3>

<p>
~HTTP3~datagramが［
可用でない／望ましくない
］ときは、
`~capsule~protocol$を利用して`~HTTP~datagram$を送信できる
— `3.5＠#datagram-capsule§
を見よ。
◎
When HTTP/3 Datagrams are unavailable or undesirable, HTTP Datagrams can be sent using the Capsule Protocol; see Section 3.5.
</p>

		</section>
	</section>
	<section id="capsule">
<h2 title="Capsules">3. ~capsule</h2>

<p>
~HTTPを拡張する仕組みとして，
新たな~HTTP~Upgrade~tokenの導入がある
— `HTTP$r `§ ~Upgrade~token~registry＠~HTTPinfra#upgrade.token.registry$ を見よ。
~HTTP1xにおいては、
これらの~tokenは，~Upgradeの仕組みを介して利用される
— `HTTP$r `Upgrade§h を見よ。
［
~HTTP2／~HTTP3
］においては、
これらの~tokenは，拡張d `CONNECT$m の仕組み
— `EXT-CONNECT2$r ／ `EXT-CONNECT3$r —
を介して利用される。
◎
One mechanism to extend HTTP is to introduce new HTTP upgrade tokens; see Section 16.7 of [HTTP]. In HTTP/1.x, these tokens are used via the Upgrade mechanism; see Section 7.8 of [HTTP]. In HTTP/2 and HTTP/3, these tokens are used via the Extended CONNECT mechanism; see [EXT-CONNECT2] and [EXT-CONNECT3].
</p>

<p>
この仕様は、
`~capsule~protocol$（ `Capsule Protocol^en ）を導入する。
`~capsule~protocol$は、
( 種別, 長さ, 値 )
が成す~tuple【として与えられる`~capsule$】たちが成す連列である
— 新たな~HTTP~Upgrade~tokenの定義が、
そこから自身が利用するものを選べるような。
`~capsule~protocol$は：
◎
This specification introduces the Capsule Protocol. The Capsule Protocol is a sequence of type-length-value tuples that definitions of new HTTP upgrade tokens can choose to use.＼
</p>
<ul>
	<li>
~HTTP`中継者$が在る下でも，要請に関係する情報を［
~HTTP要請~stream上で依拠-可能に，端点間で通信する
］ことを端点に許容する。
◎
It allows endpoints to reliably communicate request-related information end-to-end on HTTP request streams, even in the presence of HTTP intermediaries.＼
</li>
	<li>
~HTTPが［
~QUIC `DATAGRAM$ft ~frameを~supportしない~transport
］越しに走っているときでも，必要yな`~HTTP~datagram$を交換するために利用できる。
◎
The Capsule Protocol can be used to exchange HTTP Datagrams, which is necessary when HTTP is running over a transport that does not support the QUIC DATAGRAM frame.＼
</li>
	<li>
~HTTP3~datagramが利用-中にあるときでも，［
~datagramに基づく~protocolに結付けられた依拠-可能かつ双方向な制御~message
］を通信するために利用できる。
◎
The Capsule Protocol can also be used to communicate reliable and bidirectional control messages associated with a datagram-based protocol even when HTTP/3 Datagrams are in use.
</li>
</ul>

		<section id="data-stream">
<h3 title="HTTP Data Streams">3.1. ~HTTP~data~stream</h3>

<p>
この仕様は、
所与の~HTTP`要請$の
`~data~stream@
を［
当の要請, それに対する［
成功裡な（すなわち， `2xx$st ）／
~Upgradeされた（すなわち， `101$st ）
］`最終-応答$
］~messageの`~header節$に後続する~byteたちが成す双方向~streamとして定義する。
◎
This specification defines the "data stream" of an HTTP request as the bidirectional stream of bytes that follows the header section of the request message and the final response message that is either successful (i.e., 2xx) or upgraded (i.e., 101).
</p>

<p>
~HTTP1xにおいては、
`~data~stream$は，［［
`要請$／`最終-応答$
］の`~header節$を締めくくる`空~行l＠~HTTPv1#empty-line$に後続する，当の接続~上のすべての~byte
］からなるので、
`~capsule~protocol$を開始し得るのは，~HTTP1x接続~上の最後の~HTTP要請に限られる。
◎
In HTTP/1.x, the data stream consists of all bytes on the connection that follow the blank line that concludes either the request header section or the final response header section. As a result, only the last HTTP request on an HTTP/1.x connection can start the Capsule Protocol.
</p>

<p>
［
~HTTP2／~HTTP3
］においては、
所与の~HTTP要請の`~data~stream$は，［
対応している`~stream~ID$を伴う［
`DATA＠~HTTPv2#section-6.1$ft ／ `DATA＠~HTTPv3#frame-data$ft
］~frame
］内に送信されたすべての~byteからなる。
◎
In HTTP/2 and HTTP/3, the data stream of a given HTTP request consists of all bytes sent in DATA frames with the corresponding stream ID.
</p>

<p>
`~data~stream$の概念は、
特に `CONNECT$m などの~method用に関連する
— そこでは、
`~header節$の後には~HTTP`~message内容$は無い。
◎
The concept of a data stream is particularly relevant for methods such as CONNECT, where there is no HTTP message content after the headers.
</p>

<p>
`~data~stream$は、［
~streamたち／要請たち
］の優先度化に適した手段を利用して優先度化され得る。
例えば，
`PRIORITY$r `§ 11＠~HTTPpriority#section-11$
を見よ。
◎
Data streams can be prioritized using any means suited to stream or request prioritization. For example, see Section 11 of [PRIORITY].
</p>

<p>
`~data~stream$は、
下層な層による~flow制御の仕組み
（例： ~HTTP2~stream~flow制御, ~HTTP2接続~flow制御, ~TCP~flow制御）
の~subjectになる。
◎
Data streams are subject to the flow control mechanisms of the underlying layers; examples include HTTP/2 stream flow control, HTTP/2 connection flow control, and TCP flow control.
</p>

		</section>
		<section id="capsule-protocol">
<h3 title="The Capsule Protocol">3.2. ~capsule~protocol</h3>

<p>
新たな~HTTP~Upgrade~tokenの定義は、［
それが結付けられた要請の`~data~stream$は，`~capsule~protocol$を利用する
］ものと言明できる。
そうする場合、
当の`~data~stream$を成す内容は，次の形式を利用する：
◎
Definitions of new HTTP upgrade tokens can state that their associated request's data stream uses the Capsule Protocol. If they do so, the contents of the associated request's data stream uses the following format:
</p>

<figure id="capsule-stream-format">
<pre class="frame-diagram">
`~capsule~protocol@ {
  ~capsule (..) ...,
}
◎
Capsule Protocol {
  Capsule (..) ...,
}
</pre>
<figcaption>
`~capsule~protocol$の~stream形式
◎
Figure 2: Capsule Protocol Stream Format
</figcaption></figure>

<figure id="capsule-format">
<pre class="frame-diagram">
`~capsule@ {
  ~capsule種別 (i),
  ~capsule長さ (i),
  ~capsule値 (..),
}
◎
Capsule {
  Capsule Type (i),
  Capsule Length (i),
  Capsule Value (..),
}
</pre>
<figcaption>
~capsule形式
◎
Figure 3: Capsule Format
</figcaption></figure>

<dl>
	<dt>
`~capsule種別^i
◎
Capsule Type:
</dt>
	<dd>
当の~capsuleの種別を指示する可変長な整数。
`~capsule種別^i のアテガいを管理するため、
~IANA~registryが利用される
— `~capsule種別＠#iana-types§
を見よ。
◎
A variable-length integer indicating the type of the capsule. An IANA registry is used to manage the assignment of Capsule Types; see Section 5.4.
</dd>

	<dt>
`~capsule長さ^i
◎
Capsule Length:
</dt>
	<dd>
［
この~fieldに後続する `~capsule値^i ~field
］の［
~byte数による長さ
］を［
可変長な整数
］に符号化したもの。
この~fieldは、
値 0 をとり得ることに注意。
◎
The length, in bytes, of the Capsule Value field, which follows this field, encoded as a variable-length integer. Note that this field can have a value of zero.
</dd>
	<dt>
`~capsule値^i
◎
Capsule Value:
</dt>
	<dd>
この`~capsule$の~payload。
その意味論は、
`~capsule種別^i ~fieldの値により決定される。
◎
The payload of this Capsule. Its semantics are determined by the value of the Capsule Type field.
</dd>
</dl>

<p>
`中継者$は、［
`Capsule-Protocol$h ~headerの有無
］または［
選ばれた~HTTP~Upgrade~tokenを解すること
］を通して，`~capsule~protocol$の利用を識別できる。
◎
An intermediary can identify the use of the Capsule Protocol either through the presence of the Capsule-Protocol header field (Section 3.4) or by understanding the chosen HTTP Upgrade token.
</p>

<p>
新たな［
~protocol／拡張
］は，新たな `~capsule種別^i を定義するかもしれないので、
将来の拡張能を許容するよう望む`中継者$は，各`~capsule$を
— 利用-中にある `~capsule種別^i の定義が，中継者による処理を追加的に指定しない限り —
改変することなく回送するベキである。
そのような`~capsule種別^i として、
`DATAGRAM$cps `~capsule$がある
— `3.5＠#datagram-capsule§
を見よ。
特に，`中継者$は、
未知な `~capsule種別^i を伴う各`~capsule$を改変することなく回送するベキである。
◎
Because new protocols or extensions might define new Capsule Types, intermediaries that wish to allow for future extensibility SHOULD forward Capsules without modification unless the definition of the Capsule Type in use specifies additional intermediary processing. One such Capsule Type is the DATAGRAM Capsule; see Section 3.5. In particular, intermediaries SHOULD forward Capsules with an unknown Capsule Type without modification.
</p>

<p>
端点は、
受信した ある`~capsule$の `~capsule種別^i が未知な場合には，
それを黙って落として~~後続の`~capsule$たちを構文解析し続けなければナラナイ。
◎
Endpoints that receive a Capsule with an unknown Capsule Type MUST silently drop that Capsule and skip over it to parse the next Capsule.
</p>

<p>
`~data~stream$の定義により：
◎
By virtue of the definition of the data stream:
</p>
<ul>
	<li>
`~capsule~protocol$が利用-中にあるのは、
応答が状態s~code［
`2xx$st ／ `101$st
］を内包する場合に限られる。
◎
The Capsule Protocol is not in use unless the response includes a 2xx (Successful) or 101 (Switching Protocols) status code.
</li>
	<li>
`~capsule~protocol$が利用-中にあるときは、
それが結付けられた~HTTP［
要請／応答
］は，~HTTP`内容$を運ばない。
将来の拡張は、
新たな`~capsule種別^i として，~HTTP`内容$を運ぶものを定義してもヨイ。
◎
When the Capsule Protocol is in use, the associated HTTP request and response do not carry HTTP content. A future extension MAY define a new Capsule Type to carry HTTP content.
</li>
</ul>

<p>
`~capsule~protocol$は，新たな~HTTP~Upgrade~tokenの定義に限り適用されるので、［
~HTTP2／~HTTP3
］においては，
`CONNECT$m ~methodを伴う場合に限り利用し得る。
したがって，双方の端点が`~capsule~protocol$を利用することに合意したなら、
当の~streamにおける~frameの用法に対する要件は，［
`HTTP/2$r `§ 8.5＠~HTTPv2#section-8.5$／
`HTTP/3$r `§ 4.4＠~HTTPv3#connect$
］にて指定されるとおりに変更される。
◎
The Capsule Protocol only applies to definitions of new HTTP upgrade tokens; thus, in HTTP/2 and HTTP/3, it can only be used with the CONNECT method. Therefore, once both endpoints agree to use the Capsule Protocol, the frame usage requirements of the stream change as specified in Section 8.5 of [HTTP/2] and Section 4.4 of [HTTP/3].
</p>

<p>
`~capsule~protocol$は、［
`Content-Length$h ／
`Content-Type$h ／
`Transfer-Encoding$h
］~headerを包含する~messageに利用してはナラナイ。
加えて，
`~capsule~protocol$を利用する応答においては、
~HTTP状態s~code［
`204$st,
`205$st,
`206$st
］を送信してはナラナイ。
受信器は、
これらの要件に対する違反を観測したときは，
当の~HTTP~messageを不正形として扱わなければナラナイ。
◎
The Capsule Protocol MUST NOT be used with messages that contain Content-Length, Content-Type, or Transfer-Encoding header fields. Additionally, HTTP status codes 204 (No Content), 205 (Reset Content), and 206 (Partial Content) MUST NOT be sent on responses that use the Capsule Protocol. A receiver that observes a violation of these requirements MUST treat the HTTP message as malformed.
</p>

<p>
受信器は、
各`~capsule$を処理するとき，
それを取扱う前に`~data~stream$内の `~capsule値^i ~fieldを成す全部的な長さを累積したくなるかもしれない。
この~approachは、
避けるベキである
— そうすると、
下層な層における~flow制御を消費し得る結果，［
~capsule~dataが~flow制御~窓を枯渇させた場合に~deadlockへ至らす
］かもしれないので。
◎
When processing Capsules, a receiver might be tempted to accumulate the full length of the Capsule Value field in the data stream before handling it. This approach SHOULD be avoided because it can consume flow control in underlying layers, and that might lead to deadlocks if the Capsule data exhausts the flow control window.
</p>

		</section>
		<section id="error-handling">
<h3 title="Error Handling">3.3. ~errorの取扱い</h3>

<p>
受信器は、
ある~error処理`~capsule~protocol$に遭遇したときは，それを［
~HTTP3用には不正形／
~HTTP2用には不正形／
~HTTP1x用には`不完全$
］な~HTTP`~message$を受信したかのように扱わなければナラナイ。
そのような~messageの取扱いは、
次にて述べられる
⇒＃
~HTTP3用には `HTTP/3$r `§ 不正形な~message＠~HTTPv3#malformed$／
~HTTP2用には `HTTP/2$r `§ 不正形な~message＠~HTTPv2#section-8.1.1$／
~HTTP1x用には `HTTP/1.1$r `§ 不完全な~messageの取扱い＠~HTTPv1#incomplete.messages$
◎
When a receiver encounters an error processing the Capsule Protocol, the receiver MUST treat it as if it had received a malformed or incomplete HTTP message. For HTTP/3, the handling of malformed messages is described in Section 4.1.2 of [HTTP/3]. For HTTP/2, the handling of malformed messages is described in Section 8.1.1 of [HTTP/2]. For HTTP/1.x, the handling of incomplete messages is described in Section 8 of [HTTP/1.1].
</p>

<p>
各`~capsule$の~payloadは、
正確に，その【 `~capsule値^i の定義の】記述にて識別される~field群を包含しなければナラナイ。
~payloadが識別される~field群の［
後に追加的な~byte列を包含する／
終端より前に終了する
］場合、
~messageは［
不正形／`不完全$
］（順不同）であったかのように扱わなければナラナイ。
特に、
冗長に符号化された長さは，自己-整合なことが検証yされなければナラナイ。
◎
Each Capsule's payload MUST contain exactly the fields identified in its description. A Capsule payload that contains additional bytes after the identified fields or a Capsule payload that terminates before the end of the identified fields MUST be treated as it if were a malformed or incomplete message. In particular, redundant length encodings MUST be verified to be self-consistent.
</p>

<p>
`~capsule$を運んでいる~streamを成す受信-側が~cleanに終了された下で
（これは、
例えば~HTTP3においては，［
`FIN^i ~bitが 1 に設定された~QUIC `STREAM$ft ~frame
］の受信として定義される），
~stream上の最後の`~capsule$を成す一部が切落された場合、
当の~messageは［
不正形／`不完全$
］であったかのように扱われなければナラナイ。
◎
If the receive side of a stream carrying Capsules is terminated cleanly (for example, in HTTP/3 this is defined as receiving a QUIC STREAM frame with the FIN bit set) and the last Capsule on the stream was truncated, this MUST be treated as if it were a malformed or incomplete message.
</p>

		</section>
		<section id="hdr">
<h3 title="The Capsule-Protocol Header Field">3.4. `Capsule-Protocol^h ~header</h3>

<p>
`Capsule-Protocol^h ~headerは、
`~sf~item$をとる`有構造~field$であり，
その値は`~sf真偽値$でなければナラナイ
`STRUCTURED-FIELDS$r
— 他の値~型である場合、
受信者は，この~fieldを無かったものとして取扱わなければナラナイ
（例えば，この~fieldが複数個~内包された場合、
その型は`~sf~list$になり，それらは無視されることになる）。
この文書は、
`Capsule-Protocol^h ~header値~用の~parameter【`~sf~parameter$】を何も定義しないが、
将来の文書は，何らかの~parameterを定義するかもしれない。
受信器は、
未知な~parameterを無視しなければナラナイ。
◎
The "Capsule-Protocol" header field is an Item Structured Field; see Section 3.3 of [STRUCTURED-FIELDS]. Its value MUST be a Boolean; any other value type MUST be handled as if the field were not present by recipients (for example, if this field is included multiple times, its type will become a List and the field will be ignored). This document does not define any parameters for the Capsule-Protocol header field value, but future documents might define parameters. Receivers MUST ignore unknown parameters.
</p>

<p>
端点は、
~T 値を伴う `Capsule-Protocol^h ~headerを送信することにより，
`~capsule~protocol$が`~data~stream$上で利用-中にあることを指示する。
~F 値を伴う `Capsule-Protocol^h ~headerの意味論は、
この~headerが無かったときと同じになる。
◎
Endpoints indicate that the Capsule Protocol is in use on a data stream by sending a Capsule-Protocol header field with a true value. A Capsule-Protocol header field with a false value has the same semantics as when the header is not present.
</p>

<p>
`中継者$は、［
未知な~HTTP~Upgrade~token用に`~HTTP~datagram$の処理を許容する
］ためとして，この~headerを利用してもヨイ。
これがアリになるのは、［
~HTTP~Upgrade／ 拡張d `CONNECT$m
］用に限られることに注意。
◎
Intermediaries MAY use this header field to allow processing of HTTP Datagrams for unknown HTTP upgrade tokens. Note that this is only possible for HTTP Upgrade or Extended CONNECT.
</p>

<p>
`Capsule-Protocol^h ~headerを`状態s~code$［
`101$st ／ `2xx$st 番台
］以外を伴う~HTTP応答に利用してはナラナイ。
◎
The Capsule-Protocol header field MUST NOT be used on HTTP responses with a status code that is both different from 101 (Switching Protocols) and outside the 2xx (Successful) range.
</p>

<p>
中継者による処理を単純~化するため、
~HTTP端点は，`~capsule~protocol$を利用しているときは，
`Capsule-Protocol^h ~headerを送信するベキである。
`~capsule~protocol$を利用する新たな~HTTP~Upgrade~tokenの定義は、
この推奨を改めてもヨイ。
◎
When using the Capsule Protocol, HTTP endpoints SHOULD send the Capsule-Protocol header field to simplify intermediary processing. Definitions of new HTTP upgrade tokens that use the Capsule Protocol MAY alter this recommendation.
</p>

		</section>
		<section id="datagram-capsule">
<h3 title="The DATAGRAM Capsule">3.5. `DATAGRAM^cps ~capsule</h3>

<p>
この文書は、
`~capsule種別^i として
`DATAGRAM@cps
（ `0x00^hex ）を定義する。
この`~capsule$は、［
`~HTTP~datagram$を`~capsule~protocol$を利用して~stream上に送信する
］ことを許容する。
これは、
特に，~HTTPが［
~QUIC `DATAGRAM$ft ~frameを~supportしない~transport
］越しに走っているときに有用になる。
◎
This document defines the DATAGRAM (0x00) Capsule Type. This Capsule allows HTTP Datagrams to be sent on a stream using the Capsule Protocol. This is particularly useful when HTTP is running over a transport that does not support the QUIC DATAGRAM frame.
</p>

<figure id="datagram-capsule-format">
<pre class="frame-diagram">
~datagram~capsule {
  種別 (i) = 0x00,
  長さ (i),
  ~HTTP~datagram~payload (..),
}
◎
Datagram Capsule {
  Type (i) = 0x00,
  Length (i),
  HTTP Datagram Payload (..),
}
</pre>
<figcaption>
`DATAGRAM$cps `~capsule$の形式
◎
Figure 4: DATAGRAM Capsule Format
</figcaption></figure>

<dl>
	<dt>
`~HTTP~datagram~payload^i
◎
HTTP Datagram Payload:
</dt>
	<dd>
当の~datagramの~payload
— その意味論は、
`~HTTP~datagram$を利用している拡張により定義される。
この~fieldは、
空になり得ることに注意。
◎
The payload of the datagram, whose semantics are defined by the extension that is using HTTP Datagrams. Note that this field can be empty.
</dd>
</dl>

<p>
`DATAGRAM$cps `~capsule$を利用して送信される`~HTTP~datagram$の意味論は、
~QUIC `DATAGRAM$ft ~frame内に送信されるそれらと同じである。
特に，［
~HTTP~datagramの送信が いつ許容されるか／
~HTTP~datagramを処理する方法
］に対する（ `§ ~HTTP3~datagram＠#format$ による）制約は、
`DATAGRAM$cps `~capsule$を利用して［
送信される／受信される
］`~HTTP~datagram$にも適用される。
◎
HTTP Datagrams sent using the DATAGRAM Capsule have the same semantics as those sent in QUIC DATAGRAM frames. In particular, the restrictions on when it is allowed to send an HTTP Datagram and how to process them (from Section 2.1) also apply to HTTP Datagrams sent and received using the DATAGRAM Capsule.
</p>

<p>
`中継者$は、
`~HTTP~datagram$を回送するに伴い，符号化し直せる。
言い換えれば、
`中継者$は，［
~QUIC `DATAGRAM$ft ~frame内に受信した~HTTP~datagram
］を回送するためとして `DATAGRAM$cps `~capsule$を送信しても，その逆を行ってもヨイ。
`中継者$は、［
対応している要請~streamにおける`~capsule~protocol$の利用
］を識別した場合
（ `§ ~capsule~protocol＠#capsule-protocol$ を見よ）
を除き，
この再-符号化法を遂行してはナラナイ。
◎
An intermediary can re-encode HTTP Datagrams as it forwards them. In other words, an intermediary MAY send a DATAGRAM Capsule to forward an HTTP Datagram that was received in a QUIC DATAGRAM frame and vice versa. Intermediaries MUST NOT perform this re-encoding unless they have identified the use of the Capsule Protocol on the corresponding request stream; see Section 3.2.
</p>

<p>
`DATAGRAM$cps `~capsule$たちは，［
順序どおり依拠-可能に送達される~stream
］上に送信されるので、
`中継者$は~messageを回送するときに［
`DATAGRAM$cps `~capsule$を~QUIC `DATAGRAM$ft ~frameの中へ符号化し直す
］こともあり，その結果［
喪失／並替ng
］が生じ得ることに注意。
◎
Note that while DATAGRAM Capsules, which are sent on a stream, are reliably delivered in order, intermediaries can re-encode DATAGRAM Capsules into QUIC DATAGRAM frames when forwarding messages, which could result in loss or reordering.
</p>

<p>
`中継者$は、［
~QUIC `DATAGRAM$ft ~frame内に受信した~HTTP~datagram
］を［
~QUIC `DATAGRAM$ft ~frameを~supportする接続
］上に回送している場合には，
その~HTTP~datagramを `DATAGRAM$cps `~capsule$へ変換するベキでない。
~HTTP~datagramが `DATAGRAM$ft ~frame内に収まるには大き過ぎる場合
（例えば，
~QUIC接続の経路~MTU（ ~PMTU ）が低過ぎるか，
~QUIC接続~上で広告された最大~UDP~payload~sizeが低過ぎるために）、
`中継者$は，当の~HTTP~datagramを `DATAGRAM$cps `~capsule$へ変換することなく落とすベキである。
これは、［
`~datagram~packet化~層~用の~PMTUの発見^cite `DPLPMTUD$r などの~method
］が依存している［
端点間における非依拠-能の特性
］を保全する。
`中継者$が~QUIC `DATAGRAM$ft ~frameを `DATAGRAM$cps `~capsule$へ変換した場合、
喪失の難を伴わずに，`~HTTP~datagram$が任意に大きくなることを許容する。
これは、
誤った経路~propを表現し得る結果，~DPLPMTUDなどの~methodを打破することになる。
◎
If an intermediary receives an HTTP Datagram in a QUIC DATAGRAM frame and is forwarding it on a connection that supports QUIC DATAGRAM frames, the intermediary SHOULD NOT convert that HTTP Datagram to a DATAGRAM Capsule. If the HTTP Datagram is too large to fit in a DATAGRAM frame (for example, because the Path MTU (PMTU) of that QUIC connection is too low or if the maximum UDP payload size advertised on that connection is too low), the intermediary SHOULD drop the HTTP Datagram instead of converting it to a DATAGRAM Capsule. This preserves the end-to-end unreliability characteristic that methods such as Datagram Packetization Layer PMTU Discovery (DPLPMTUD) depend on [DPLPMTUD]. An intermediary that converts QUIC DATAGRAM frames to DATAGRAM Capsules allows HTTP Datagrams to be arbitrarily large without suffering any loss. This can misrepresent the true path properties, defeating methods such as DPLPMTUD.
</p>

<p>
`DATAGRAM$cps `~capsule$は，
理論~上は長さ 2`62^sup ~MINUS 1
までの~payloadを運べるが、
`~HTTP~datagram$を利用する ほとんどの~HTTP拡張は，
~datagram~payloadの~sizeに実用的な自前の上限を~~課すことになる。
実装は、
`DATAGRAM$cps `~capsule$を構文解析する際に，それらの上限を織り込むベキである。
流入 `DATAGRAM$cps `~capsule$の長さが利用-可能でないほど巨大なことが知れた場合、
実装は，当の`~capsule$を
— その内容を~memoryの中へ~bufferすることなく —
破棄するベキである。
◎
While DATAGRAM Capsules can theoretically carry a payload of length 262-1, most HTTP extensions that use HTTP Datagrams will have their own limits on what datagram payload sizes are practical. Implementations SHOULD take those limits into account when parsing DATAGRAM Capsules. If an incoming DATAGRAM Capsule has a length that is known to be so large as to not be usable, the implementation SHOULD discard the Capsule without buffering its contents into memory.
</p>

<p>
~QUIC `DATAGRAM$ft ~frameは，
~QUIC~packetの中に収まることが要求されるので、
`DATAGRAM$cps `~capsule$を~QUIC `DATAGRAM$ft ~frameの中へ符号化し直す実装は，
`~capsule$全体を
— 符号化し直す前に —
~stream内に累積したくなるかもしれないが、
そうするのは避けるベキである
— そうすると，~flow制御の問題を生じさせ得るので
— `§ ~capsule~protocol＠#capsule-protocol$
を見よ。
◎
Since QUIC DATAGRAM frames are required to fit within a QUIC packet, implementations that re-encode DATAGRAM Capsules into QUIC DATAGRAM frames might be tempted to accumulate the entire Capsule in the stream before re-encoding it. This SHOULD be avoided, because it can cause flow control problems; see Section 3.2.
</p>

<p>
~HTTP拡張にとっては、
`~capsule~protocol$を利用せずに`~HTTP~datagram$を利用することもアリであることに注意。
例えば，`~HTTP~datagram$を利用する ある~HTTP拡張が［
~QUIC `DATAGRAM$ft ~frameを~supportする~transport越しに限られる
］ものとして定義された場合、
~stream符号化法は不要かもしれない。
加えて、
~HTTP拡張は，`~HTTP~datagram$を自前の~data~stream~protocolで利用し得る。
しかしながら，新たな~HTTP拡張は、
`~HTTP~datagram$を利用するよう望むなら，`~capsule~protocol$を利用するベキである
— そうすることに失敗すると、
当の~HTTP拡張は［
~HTTP3以外の~HTTP~versionを~supportするのが難しくなる
］ことに加え［
`~capsule~protocol$しか~supportしない`中継者$たちとの相互運用能を妨げる
］ことになるので。
◎
Note that it is possible for an HTTP extension to use HTTP Datagrams without using the Capsule Protocol. For example, if an HTTP extension that uses HTTP Datagrams is only defined over transports that support QUIC DATAGRAM frames, it might not need a stream encoding. Additionally, HTTP extensions can use HTTP Datagrams with their own data stream protocol. However, new HTTP extensions that wish to use HTTP Datagrams SHOULD use the Capsule Protocol, as failing to do so will make it harder for the HTTP extension to support versions of HTTP other than HTTP/3 and will prevent interoperability with intermediaries that only support the Capsule Protocol.
</p>

		</section>
	</section>
	<section id="security">
<h2 title="Security Considerations">4. ~securityの考慮点</h2>

<p>
~QUIC `DATAGRAM$ft ~frameを利用して`~HTTP~datagram$を伝送するためには、
~HTTP3 `SETTINGS_H3_DATAGRAM$sp 設定の送信が要求されるので， “目立つ” 。
言い換えれば、
探査している~clientは，［
ある~serverが~QUIC `DATAGRAM$ft ~frame越しに`~HTTP~datagram$を~supportするかどうか
］を学習し得る。
一部の~serverは、［
自身が提供する応用~serviceが`~HTTP~datagram$を利用する事実
］をボヤカすよう望むかもしれないので、［
この特能を~supportする すべての実装が，この設定を常に送信する
］ことが最善である
— `SETTINGS_H3_DATAGRAM＠#setting§sp
を見よ。
◎
Since transmitting HTTP Datagrams using QUIC DATAGRAM frames requires sending the HTTP/3 SETTINGS_H3_DATAGRAM setting, it "sticks out". In other words, probing clients can learn whether a server supports HTTP Datagrams over QUIC DATAGRAM frames. As some servers might wish to obfuscate the fact that they offer application services that use HTTP Datagrams, it's best for all implementations that support this feature to always send this setting; see Section 2.1.1.
</p>

<p>
`~capsule~protocol$は、
その利用が新たな~HTTP~Upgrade~tokenに制約されるので，
~Web~platform~API
（共通的に ~web~browser内で~JSを介して~accessされるものなど）
からは直に~access可能でない。
◎
Since use of the Capsule Protocol is restricted to new HTTP upgrade tokens, it is not directly accessible from Web Platform APIs (such as those commonly accessed via JavaScript in web browsers).
</p>

<p>
`~capsule~protocol$を利用する新たな~HTTP~Upgrade~tokenの定義は、［
各自の~protocolの文脈における［
`~HTTP~datagram$／`~capsule$
］による影響i
］を考慮する~security分析を含める必要がある。
◎
Definitions of new HTTP upgrade tokens that use the Capsule Protocol need to include a security analysis that considers the impact of HTTP Datagrams and Capsules in the context of their protocol.
</p>

	</section>
	<section id="iana">
<h2 title="IANA Considerations">5. ~IANA考慮点</h2>

		<section id="iana-setting">
<h3 title="HTTP/3 Setting">5.1. ~HTTP3設定</h3>

<p>
~IANAは、
`~HTTP3設定~registry＠~IANA-a/http3-parameters$cite
内に次に挙げる~entryを登録した：
◎
IANA has registered the following entry in the "HTTP/3 Settings" registry maintained at &lt;https://www.iana.org/assignments/http3-parameters&gt;:
</p>

<ul>
	<li>
値
⇒
`0x33^hex
◎
Value:
• 0x33
</li>
	<li>
設定~名
⇒
`SETTINGS_H3_DATAGRAM$sp
◎
Setting Name:
• SETTINGS_H3_DATAGRAM
</li>
	<li>
既定
⇒
0
◎
Default:
• 0
</li>
	<li>
位置付け
⇒
`恒久的^i
◎
Status:
• permanent
</li>
	<li>
参照
⇒
~RFC 9297
◎
Reference:
• RFC 9297
</li>
	<li>
変更~制御者
⇒
~IETF
◎
Change Controller:
• IETF
</li>
	<li>
連絡先
⇒
~HTTP~WG（ ietf-http-wg@w3.org ）
◎
Contact:
• HTTP_WG; HTTP working group; ietf-http-wg@w3.org
</li>
	<li>
注記
⇒
なし
◎
Notes:
• None
</li>
</ul>

		</section>
		<section id="iana-error">
<h3 title="HTTP/3 Error Code">5.2. ~HTTP3~error~code</h3>

<p>
~IANAは、
`~HTTP3~error~code~registry＠~IANA-a/http3-parameters$cite
内に，次に挙げる~entryを登録した：
◎
IANA has registered the following entry in the "HTTP/3 Error Codes" registry maintained at &lt;https://www.iana.org/assignments/http3-parameters&gt;:
</p>
<ul>
	<li>
値
⇒
`0x33^hex
◎
Value:
• 0x33
</li>
	<li>
名前
⇒
`H3_DATAGRAM_ERROR@er
◎
Name:
• H3_DATAGRAM_ERROR
</li>
	<li>
記述
⇒
~datagram／`~capsule~protocol$
構文解析-~error
◎
Description:
• Datagram or Capsule Protocol parse error
</li>
	<li>
位置付け
⇒
`恒久的^i
◎
Status:
• permanent
</li>
	<li>
参照
⇒
~RFC 9297
◎
Reference:
• RFC 9297
</li>
	<li>
変更~制御者
⇒
~IETF
◎
Change Controller:
• IETF
</li>
	<li>
連絡先
⇒
~HTTP~WG（ ietf-http-wg@w3.org ）
◎
Contact:
• HTTP_WG; HTTP working group; ietf-http-wg@w3.org
</li>
	<li>
注記
⇒
なし
◎
Notes:
• None
</li>
</ul>

		</section>
		<section id="iana-hdr">
<h3 title="HTTP Header Field Name">5.3. ~HTTP~header名</h3>

<p>
~IANAは、
`~HTTP~field名前~registry＠~IANA-a/http-fields$cite
内に次に挙げる~entryを登録した：
◎
IANA has registered the following entry in the "Hypertext Transfer Protocol (HTTP) Field Name Registry" maintained at &lt;https://www.iana.org/assignments/http-fields&gt;:
</p>
<ul>
	<li>
~field名
⇒
`Capsule-Protocol$h
◎
Field Name:
• Capsule-Protocol
</li>
	<li>
~template
⇒
なし
◎
Template:
• None
</li>
	<li>
位置付け
⇒
`恒久的^i
◎
Status:
• permanent
</li>
	<li>
参照
⇒
~RFC 9297
◎
Reference:
• RFC 9297
</li>
	<li>
~comment
⇒
なし
◎
Comments:
• None
</li>

</ul>

		</section>
		<section id="iana-types">
<h3 title="Capsule Types">5.4. ~capsule種別</h3>

<p>
この文書は、
~HTTP`~capsule種別^i ~code用の~registryとして
`~HTTP~capsule種別~registry^cite
（ `"HTTP Capsule Types" registry^en ）
を確立する。
それは、
62 ~bitの空間を統治し，
`QUIC$r `§ ~QUIC~registry用の登録~施策＠~QUICv1#iana-policy$
にて文書化された施策の下で運用される。
この新たな~registryは、
`QUIC$r `§ 暫定的な登録＠~QUICv1#iana-provisional$
に挙げられた~fieldたちが成す共通な集合を含む。
それら共通な~fieldに加えて，
この~registry内のすべての登録は、
`~capsule種別^i 用の短い［
名前／~label
］を包含する~capsule種別~fieldを含めなければナラナイ。
◎
This document establishes a registry for HTTP Capsule Type codes. The "HTTP Capsule Types" registry governs a 62-bit space and operates under the QUIC registration policy documented in Section 22.1 of [QUIC]. This new registry includes the common set of fields listed in Section 22.1.1 of [QUIC]. In addition to those common fields, all registrations in this registry MUST include a "Capsule Type" field that contains a short name or label for the Capsule Type.
</p>

<p>
この~registry内の `恒久的^i な登録は、
`仕様が要求される施策＠~RFCx/rfc8126#section-4.6$ `IANA-POLICY$r
を利用してアテガわれる
— ただし，範囲 { `0x00^hex 〜 `0x3f^hex } に入る値は、
`標準~化を通して＠~RFCx/rfc8126#section-4.9$ `IANA-POLICY$r
または
`~IESGによる認可により＠~RFCx/rfc8126#section-4.10$ `IANA-POLICY$r
アテガわれる。
◎
Permanent registrations in this registry are assigned using the Specification Required policy (Section 4.6 of [IANA-POLICY]), except for values between 0x00 and 0x3f (in hexadecimal; inclusive), which are assigned using Standards Action or IESG Approval as defined in Sections 4.9 and 4.10 of [IANA-POLICY].
</p>

<p>
`~capsule種別^i のうち，その値が
{ `0x29^hex ~MUL %N ~PLUS `0x17^hex ； %N は整数 }
に入るものは、［
未知な `~capsule種別^i は無視するとする要件
］を行使するためとして予約される。
これらの`~capsule$には意味論は無く，任意な値を運び得る。
これらの値は
⇒＃
~IANAによりアテガわれてはナラナイ／
アテガわれた値たちが成す~listに出現してはナラナイ
◎
Capsule Types with a value of the form 0x29 * N + 0x17 for integer values of N are reserved to exercise the requirement that unknown Capsule Types be ignored. These Capsules have no semantics and can carry arbitrary values. These values MUST NOT be assigned by IANA and MUST NOT appear in the listing of assigned values.
</p>

<p>
この~registryは、
初期~時は，次に挙げる~entryを包含する：
◎
This registry initially contains the following entry:
</p>
<ul>
	<li>
値
⇒
0x00
◎
Value:
• 0x00
</li>
	<li>
~capsule種別
⇒
`DATAGRAM$cps
◎
Capsule Type:
• DATAGRAM
</li>
	<li>
位置付け
⇒
`恒久的^i
◎
Status:
• permanent
</li>
	<li>
参照
⇒
~RFC 9297
◎
Reference:
• RFC 9297
</li>
	<li>
変更~制御者
⇒
~IETF
◎
Change Controller:
• IETF
</li>
	<li>
連絡先
⇒
~MASQUE~WG
<a href="mailto:masque@ietf.org">masque@ietf.org</a>
◎
Contact:
• MASQUE Working Group masque@ietf.org
</li>
	<li>
注記
⇒
なし
◎
Notes: None
</li>
</ul>

		</section>
	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この文書を成す各部は、
以前は，~QUIC `DATAGRAM$ft ~frame定義の一部を成していた
— その文書の策定者たち, ~IETF~MASQUE~WGの~memberたちによる示唆に謝意を。
加えて，次に挙げる方々にも感謝したい：
◎
Portions of this document were previously part of the QUIC DATAGRAM frame definition itself; the authors would like to acknowledge the authors of that document and the members of the IETF MASQUE working group for their suggestions. Additionally,＼
</p>
<ul>
	<li>
`Martin Thomson^en 氏は、
~HTTP3設定の利用を示唆された。
◎
the authors would like to thank Martin Thomson for suggesting the use of an HTTP/3 setting.＼
</li>
	<li>
`Ben Schwartz^en 氏は、
~~貴重な意見を寄せられた。
◎
Furthermore, the authors would like to thank Ben Schwartz for substantive input.＼
</li>
	<li>
この文書における最終-設計は、
この文書の著作者たちに加え，
次に挙げる `HTTP Datagrams Design Team^en の~memberたちから生み出された
⇒
<span lang="en">
Alan Frindell,
Alex Chernyakhovsky,
Ben Schwartz,
Eric Rescorla,
Marcus Ihlar,
Martin Thomson,
Mike Bishop,
Tommy Pauly,
Victor Vasiliev
</span>
◎
The final design in this document came out of the HTTP Datagrams Design Team, whose members were Alan Frindell, Alex Chernyakhovsky, Ben Schwartz, Eric Rescorla, Marcus Ihlar, Martin Thomson, Mike Bishop, Tommy Pauly, Victor Vasiliev, and the authors of this document.＼
</li>
	<li>
`Mark Nottingham^en,
`Philipp Tiesel^en
各氏は，~~有益な~commentを寄せられた。
◎
The authors thank Mark Nottingham and Philipp Tiesel for their helpful comments.
</li>
</ul>

	</section>
</main></div>
