<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Cooperative Scheduling of Background Tasks（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style type="text/css">
._frames1 {
	white-space: nowrap;
}
._frames1 ._period {
	display: inline-block;
	border: solid #F0C441 1px;
	background:#FEF3CE;
	padding: 0.1em;
}

._frames1 ._task {
	display: inline-block;
	border-style: solid;
	border-width: 2px;
	padding: 3px;
	line-height: 1.1em;
	min-height: 2.2em;
	min-width: 4em;
	text-align: center;
	border-radius: 5px;
	vertical-align: middle;
}
._idle_callback {
	border-color: orange;
	background: #F0C441;
}

._UA_task {
	border-color:#4385C5;
	background:#D0E2F2;
}

._deadline {
	background: white;
	text-align: center;
	font-size: smaller;
}

._separator {
	display: inline-block;
	border-left: dashed currentcolor 2px;
	color: black;
	height: 7em;
	width: 0;
	vertical-align: middle;
	position: relative;
}
._separator > div {
	position:absolute;
	top:-1.3em;
	left:0;
	width:8em;
	text-align:left;
	font-size:small;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	var source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: 170815 spec
}

function expand(){

	var class_map = {
		l: 'literal',
		E: 'dom-error',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		d: 'code',
		c: 'code',
		E: 'code',
		l: 'code',
		V: 'var',
		b: 'b',
		i: 'i',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w一-鿆~あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){


if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#bib-' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"'
	break;
case 'I': // IDL interface
	href = '#' + key;
	break;
case 'm': // IDL member
	key = key.replace(/\(.+/, '');
	text = key + text.replace(/^[^\(]+/, '').replace(/\w+/g, '<var>$&</var>' );
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Cooperative Scheduling of Background Tasks
spec_date:2017-10-30
trans_update:2017-09-25
page_state_key:TIMING
original_url:https://w3c.github.io/requestidlecallback/
spec_status:ED
ref_id_prefix:bib-
	conformance:w3c
copyright:2017,permissive
trans_1st_pub:2015-11-27


●●original_id_map


●●link_map



Exposed:~WEBIDL#Exposed
文書:~DOM4#concept-document
	I.Document:~TR/dom/#document
I.IdleDeadline:#idl-def-idledeadline
I.IdleRequestCallback:#idl-def-idlerequestcallback
I.IdleRequestOptions:#idl-def-idlerequestoptions

I.Window:~WINDOW#the-window-object
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp

	50ms:#why50
	:#figure1
	:#figure2
	:#window_extensions

m.requestIdleCallback:#dom-window-requestidlecallback
m.cancelIdleCallback:#dom-window-cancelidlecallback

m.timeout:#dom-idlerequestoptions-timeout
m.timeRemaining:#dom-idledeadline-timeremaining
m.didTimeout:#dom-idledeadline-didtimeout

m.performance.now:~HRTIME#dom-performance-now

m.requestAnimationFrame:~HTMLGAPI#dom-window-requestanimationframe
m.setInterval:~HTMLGAPI#dom-setinterval
m.setTimeout:~HTMLGAPI#dom-settimeout
m.hidden:~PAGE-VISIBILITY#dom-document-hidden

遊休~callback:#_idle-callback
~callback:#_callback
~handle:#_handle
稼働可能:#_runnable

~timeout？:#dfn-timeout
文脈~obj:~DOM4#context-object

刻限~時刻:#dfn-time
遊休~callback~list:#_list-of-idle-callbacks
要請-済み遊休~callback~list:#dfn-list-of-idle-request-callbacks
稼働可能な遊休~callback~list:#dfn-list-of-runnable-idle-callbacks
遊休~callback識別子:#dfn-idle-callback-identifier
最後の遊休~期間~刻限:#dfn-last-idle-period-deadline

遊休task~task源:#dfn-idle-task-task-source
遊休~期間:#dfn-idle-period

遊休~期間を開始する:#dfn-start-an-idle-period-algorithm
遊休~callbackを呼出す:#dfn-invoke-idle-callbacks-algorithm
~timeoutに達した遊休~callbackを呼出す:#dfn-invoke-idle-callback-timeout-algorithm
遊休~callbackを内部的に呼出す:#_invoke-idle-callback

時刻起点:~HRTIME#time-origin
現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time


	conforming implementation:~WEBIDL/#dfn-conforming-implementation
	~privacyと保安:~HRTIME#privacy-security

~task源:~WAPI#task-source
~task~queue:~WAPI#task-queue
極小task~queue:~WAPI#microtask-queue
~event~loop:~WAPI#event-loop
~event~loopを回す:~WAPI#spin-the-event-loop
	#spinning-the-event-loop
~taskを~queueする:~WAPI#queue-a-task
~task:~WAPI#concept-task
~errorを報告する:~WAPI#report-the-error

閲覧文脈:~BROWSERS#browsing-context
全部的に作動中:~BROWSERS#fully-active

	結付けている~window:~WINDOW#concept-document-window
	結付けられている文書:~WINDOW#concept-document-window
作動中の~timerの~list:~HTMLGAPI#list-of-active-timers
作動中の文書:~BROWSERS#active-document


●●words_table1


PAGE-VISIBILITY:page-visibility-ja.html


●●words_table



jank:::カクつき
templating:::テンプレート処理
code:::コード
pattern:::パタン
animation:::アニメーション
client:::クライアント
	client側:client-side
data:::データ
entry:::エントリ
layout:::レイアウト
list:::リスト
mode:::モード
model:::モデル

overhead:::オーバーヘッド
processor:::プロセッサ
screen:::スクリーン
script:::スクリプト
	scriptに基づく:script-based
source:::ソース
源:source::~:ソース
	式style
	0:zero
頁:page::ページ
文脈:context:~

error:::エラー
event:::イベント
interface:::インタフェース
obj:object::オブジェクト
member:::メンバ
method:::メソッド
promise:::
関数:function:~

	●処理model
logic:::ロジック
catch:
例外:exception:~
call:::
callback::::コールバック
commit:::コミット
frame:::フレーム
loop:::ループ
micro:micro-::マイクロ
	micro-秒:microsecond:~
milli:milli-::ミリ
	milli-秒:millisecond:~
timeout::::タイムアウト
handle::::ハンドル
timer:::タイマー
post:::ポスト
	repost:::
	reposting:::
round-robin:::ラウンドロビン
	running:::
	save:::
schedule:::スケジュール
	scheduled:::
	scheduling:::
vsync::video 同期:ビデオ同期
main-thread:main thread::メインスレッド
access:::アクセス
mark:::マーク

仕事:work::タスク
処理待ち:pending:~
処理待ちの:pending:~
遂行-:perform:~
	時間に厳しいtime-critical
	遅延に厳しい:latency-critical
予測不能:unpredictable:~
	再~post:re-post:~
	再度:again:~
	再度~schedule:reschedule:~
処理-:process:~
処理:processing:~
刻限:deadline::~
協同的な:cooperative:~
協同して:cooperative に:~
即時:immediate:~
反応-:react:~
	前:before:~
取消す:cancel する:取り消す
受取る:receive する:受け取る
	合間:between:~
	同じ:same:~
	含-:include:~
呼出す:invoke する:呼び出す
呼出され:invoke され:呼び出され
呼出:invocation:呼び出し
被呼出時:被 invoke 時:~
取得子:getter:~
差挟む:interleave する:差し挟む
	先送りpostpone／yield／get called back／to be performed／ to be repeatedly executed
完了-:complete:~
実行-:execute:~
実行:execution:~
実行時:runtime:~

task:::タスク
極小task:microtask::極小 task:極小タスク:マイクロタスク
queue::::キュー

負荷:load:~
	負荷が高い~heavy page load
待機-:wait:~
応答-:respond:~
応答:response:~
応答性:responsiveness:~
早期:early:~
今:now:~
時間:time::~
時刻:time::~
時刻起点:time origin::~
時区間:time::~
時間軸:timeline::~
所要時間:duration::~
現在時刻:current time::~
現在:currently:~
現在の:current:~
絶対的な:absolute:~
更新:update:~
期間:period::~
未来の:future:~
未来:future:~
機会:chance:~
正確0:accurate:正確
生成:generation:~
瞬間的:instantaneous:~
	秒:second:~
稼働-:run:~
	稼働資格:run する資格:~
	稼働可能とされ:eligible to run:~
稼働可能:runnable:~
稼働可能な:runnable:~
粒度:granularity:~
	終わった:finish
終端:end:~
	末尾:end:~
継続的:continuous:~
継続-:continue:~
背景:background:~
要請:request::~:リクエスト
要請-:request::~:リクエスト
	要請-済み:requested
見積もり:estimation:~
見積もる:estimate する:~
見積もっ:estimate し:~
	見込まれる／:likely:~
識別子:identifier:~
識別-:identify:~
遅延:delay::~:ディレイ
遊休:idle::~:アイドル
遊休task:idle-task::遊休タスク :アイドルタスク 
	達-:reach:~
開始:start:~
	method:function:~
閾値:threshold:~
高頻度:frequent:~
非同期的:asynchronous:~
非同期:asynchronous:~
投出-:throw:~
	策:strategy:~

競争:race:~
並列的:parallel:~
走らす:run する:~
走らせ:run し:~
走る:run する:~
未終了の:outstanding:~
状態:state:~
真偽:boolean:~
	間引くthrottle〜rather than continuously
	~~静止quiescence:::
	不定期 unbounded amount of time:::
	生じ:occur
	-:pop
	taking
	繰り返し:repeatedly
	exit
	expectation
	要請された順に:FIFO order
	-:assess
	begun
	ある時間までに time bound within which
	bound
	過ぎる:expire
	produce
	水増し:pad する
	上限:cap
	細分化された仕事:chunk
	continuation
	continue
	周期:cycle

	●仕様
API:
UA:user agent:UA
	~UA:browser
algo:algorithm::アルゴリズム
app:application::アプリ
browser:::ブラウザ
approach:::アプローチ
platform:::プラットフォーム
vendor:::ベンダ
web:::ウェブ
version:::バージョン
support:::サポート
仕方:way:~
仕様:spec:~
任意選択:optional:~
	伝える:inform する:~
制御:control:~
制限-:limit:~
前提:assumption:~
	加えて:in addition:~
参照:reference:~
受容可能:acceptable:~
可用:available:~
	可能化-:enable:~
困難:difficult:~
在する:present する:在る
	基づく:based:~
報告-:report:~
	始-:begin:~
存在-:exist:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
実装者:implementer:~
	対応-:correspond:~
	もたらす-:introduce:~
	導入:introduction:~
導出-:derive:~
波及-:impact:~
意味-:mean:~
意図-:intend:~
	成す:constitute:~
手段:means:~
手続き:steps:~
段:step:~
拡張:extension:~
	指す:refer する:~
指定-:specify:~
提供-:provide:~
作者:author:~
	例:example:~
	例えば:for example:~
全部的:full:~
依拠-:rely:~
	依然として:still:~
知識:knowledge:~
最適:optimal:~
最適化-:optimize:~
有意な:significant:~
	望む:wish する:~
期待-:expect:~
予期-:expect:~
概して:typical に:~
欠点:disadvantage:~
状況:situation:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
段階:stage:~
研究:studies:~
確保-:ensure:~
許容-:allow:~
	謝辞:acknowledgment:~
要求-:require:~
議論:discussion:~
適切:appropriate:~
適合性:conformance:~
	重要:important:~
	勧告案:Candidate Recommendation:~
注意深く:careful に:~
開発者:developer:~
将来:future:~
事例:case:~

	可能になる:enable
	させたい-:prefer:~
	存続する限り:lifetime

最良の:best:~
処理能:performance:~
開発者:developers:~
奨励-:encourage:~
不必要な:unnecessary:~
有意義な:meaningful:~
発火-:fire:~
	し続けて:keep
全体的な:overall :~
	発揮させる:deliver
効率性:efficiency:~
効率的:efficient:~
排する:eliminateする:~
巨大block:large block:巨大 block:巨大ブロック
改善-:improve:~
一般:general:~
非互換:incompatible:~
情報:information:~
抑える:reduce する:~
関係-:relate:~
	因り:due to
直接的:direct:~
予見され:believe され:~
依存関係:dependencies:~
判断-:deem:~
決定-:determine:~
保証-:guarantee:~
利用者:user:~::ユーザ
述べる:describe する:~
求めら:want さ:~
	勘定に入れる:account
	避ける:avoid する
	-:decide
	とする:decision
	causing

	●保安
算出-:compute:~
軽減-:mitigate:~
cache:::キャッシュ
攻撃:attack:~
統計的指紋収集:statistical fingerprinting:~
分解能:resolution:~
高分解能:high resolution:~
privacy:::プライバシー
保安:security::~:セキュリティ

	●未分類（動詞
markup:::マークアップ
付加-:append:~
作動中の:active な:~::アクティブ
作動中:active:~::アクティブ
公開-:expose:~
共有-:share:~
具現化-:render:~::レンダー
具現化:rendering:~::レンダリング
	事前に具現化:pre-rendering
描画:rendering:~::レンダリング
描画-:render:~::レンダー
対話:interaction:~::インタラクション
知覚-:perceive:~
	perception
	利用者が知覚し得る:user-perceptible
	知覚し得る:perceptible
可視:visible:~
合成:compositing:~
構築-:construct:~
演算:operation:~
見出す:find する:~
解析:analytic:~
解決-:resolve:~
計算-:calculate:~
計算:computation:~
記録-:record:~
設定-:set:~
誘発-:trigger:~
除去-:remove:~
保持-:hold:~
拡充-:populate:~
超過-:exceed:~
反映-:reflect:~

	返-:return
	空にする:clear
	追加の:additional
	書く:write する
	渡す-:pass する
	示-:show
	示され:shown
	選ぶ:choose する
	所与の:given
	与-:give
	interested
	加わる:join
	slow-down
	changing
	占める／taken

	●未分類
IDL:
一意:unique:~
片:fragment:~
値:value:~
入力:input:~
内容:content:~
内部的:internal:~
初期:initial:~
優先度:priority:~
人:human:~
単純:simple:~
文書:document:~
属性:attribute:~
引数:argument:~
機器:device:~
電力消費:power-usage:~
節電:low-power:~
部分的:partial:~
長さ:length:~
閲覧文脈:browsing context:~


音声:audio:~
順序:order:~
	高い:high:~
flag:::フラグ
空:empty:~

	-:portion:~
	CPU
	final
	get
	i
	increment
	lag
	-:last_deadline
	note
	part
	possible
	property
	remain
	step
	subtlety
	uncaught
	差し迫った:upcoming
	very
	自由:free
	見合う:fit
	負荷:load
	利用-:use／using
	必要-:need
	必ずしも〜ない:necessarily
	数:number
	最も容易な:easiest
	正の:positive
	~~精度:accurate
	短い:short
	立場:position
	non-trivial
	重い:heavy
	量:amount
	したがって:therefore
	なり得る:potential
	mailing
	50ms
	option
	now
	doc
	doclist
	runlist
	長時間~稼働する:long running
	微小な:very small
	小さな:small
	要する時間:how long each of these callbacks are likely to take

	●指示語
新たな:new:~
単独の:single:~
	残りの／:remaining
	最小:minimum
	最小限に:minimum possible
	previous
	previously
	他の:other
	代わりに:instead
	より:more
	current
	entirely
	余計な:extra
	-forward
	further
	long
	longer
	near
	後続の:subsequent
	両者:both
	介:via
	during
	別の:another
	各:each
	後:after
	新たに:newly
	最も近い:closest
	最大:maximum
	最後の:last
	最終的:eventual
	次の:next
	次の:the-following
	結果:result
	結果の:resulting
	より早期の:earlier
	より良い:better
	より高い:higher
	この:this
	これらの:these
	すべて:all
	そのような:such
	下:below
	早々:early／


●●ref_normative
[HR-TIME]
    High Resolution Time. Jatinder Mann. W3C. 17 December 2012. W3C Recommendation. URL: https://www.w3.org/TR/hr-time/ 
[HTML5]
    HTML5. Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Theresa O’Connor; Silvia Pfeiffer. W3C. 28 October 2014. W3C Recommendation. URL: https://www.w3.org/TR/html5/ 
[RESPONSETIME]
    Response time in man-computer conversational transactions. Robert B. Miller.December 1968. Fall Joint Computer Conference. URL: http://yusufarslan.net/sites/yusufarslan.net/files/upload/content/Miller1968.pdf 
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[WebIDL]
    Web IDL. Cameron McCormack; Boris Zbarsky; Tobie Langel. W3C. 15 December 2016. W3C Editor’s Draft. URL: https://heycam.github.io/webidl/ 
[hr-time-2]
    High Resolution Time Level 2. Ilya Grigorik; James Simonsen; Jatinder Mann. W3C. 1 November 2016. W3C Candidate Recommendation. URL: https://www.w3.org/TR/hr-time-2/ 
[html]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[page-visibility]
    Page Visibility (Second Edition). Jatinder Mann; Arvind Jain. W3C. 29 October 2013. W3C Recommendation. URL: https://www.w3.org/TR/page-visibility/


●●ref_informative
[WEBIDL]
    Web IDL. Cameron McCormack; Boris Zbarsky; Tobie Langel. W3C. 15 December 2016. W3C Editor’s Draft. URL: https://heycam.github.io/webidl/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより，副題に日付にて編集者草案として公開された
<a href="~SPEC_URL">Cooperative Scheduling of Background Tasks</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	http://www.w3.org/TR/requestidlecallback/

最新の編集者草案
	https://w3c.github.io/requestidlecallback/

編集
	Ross McIlroy, Google Inc., rmcilroy@chromium.org
	Ilya Grigorik, Google Inc., igrigorik@gmail.com

リポジトリ
	<a href="https://github.com/w3c/requestidlecallback/">We are on GitHub.</a>
	<a href="https://github.com/w3c/requestidlecallback/issues">File a bug.</a>
	<a href="https://github.com/w3c/requestidlecallback/commits/gh-pages/index.html">Commit history.</a>
	<a href="https://w3c-test.org/requestidlecallback/">Tests.</a>
	<a href="http://wpt.fyi/requestidlecallback">Implementation Report.</a>

Mailing list
	<a href="https://lists.w3.org/Archives/Public/public-web-perf/">public-web-perf@w3.org</a>

</script>

</head>
<body>

<header>


	<hgroup>
<h1>背景タスクの協同的なスケジュール法 — Cooperative Scheduling of Background Tasks</h1>
	</hgroup>


</header>


<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この文書は、~web頁~作者が背景~taskと協同して~scheduleするために
— すなわち，［
入力~処理／~animation／~frame合成
］などの，同じ~event~loopを共有する高~優先度~taskに遅延をもたらさないように — 
利用できる~APIを定義する。
~UAは、［
現在~scheduleされている~task, ~vsync刻限, 利用者~対話, 等々
］の知識を有するので、背景~taskを［
~animationや入力~応答にて
利用者が知覚し得る遅延や~jank
］をもたらすことなく，いつ稼働できるかを決定するにあたって、~~有利な立場にある。
したがって，この~APIを利用すれば、背景~taskは，~UAが遊休~中のときに稼働されるように，より適切に~scheduleされるはずである。
◎
This document defines an API that web page authors can use to cooperatively schedule background tasks such that they do not introduce delays to other high priority tasks that share the same event loop, such as input processing, animations and frame compositing. The user agent is in a better position to determine when background tasks can be run without introducing user-perceptible delays or jank in animations and input response, based on its knowledge of currently scheduled tasks, vsync deadlines, user-interaction and so on. Using this API should therefore result in more appropriate scheduling of background tasks during times when the browser would otherwise be idle.
</p>

	</section>
	<section id="sotd">
<h2 title="Status of This document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<!-- 
この節では、発行時点における…
-->
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>

<p>
この文書は
<a href="https://www.w3.org/webperf/">Web Performance Working Group</a>
により発行されました。
◎
This document was published by the Web Performance Working Group as an Editor's Draft. Comments regarding this document are welcome. Please send them to public-web-perf@w3.org (subscribe, archives) with [RequestIdleCallback] at the start of your email's subject.
</p>

	</section>

<main id="MAIN0">
	<section id="dependencies">
<h2 title="Dependencies">1. 依存関係</h2>

<p class="trans-note">【
この節の和訳は、省略する。
】
◎
The terms browsing context , event loop, event loop processing model, spin the event loop, fully active, tasks, task source, task queues, queue a task, microtask queue, list of active timers, setTimeout, setInterval, requestAnimationFrame and report the error are defined in [html].
◎
The terms current high resolution time and DOMHighResTimestamp are defined in [hr-time-2].
◎
The term conforming implementation is defined in [WebIDL].
◎
The term hidden is defined in [page-visibility].
</p>


	</section>
	<section id="introduction">
<h2 title="Introduction">2. 序論</h2>

~INFORMATIVE

<p>
~web頁では、~UAの~event~loop上で，背景~taskを実行することが求められることが多い。
背景~taskとは、
“時間に厳しい”
~task
【 time-critical — 所定の刻限までに終えることが求められる~task 】
ではないが，有意な時間はかかるような、計算~taskである。
そのような~taskの例には、［
解析~dataを記録する ／
長時間~稼働し続けるような~data処理~演算 ／
~client側~templating ／
近い未来に可視になると見込まれる内容を 事前に具現化しておく
］などが挙げられる。
これらの~taskは、~event~loopを，時間に厳しい他の演算（例えば［
利用者~入力に反応する ／
`requestAnimationFrame()$m を利用する ~scriptに基づく~animation
］など）と共有しなければならない。
これらの背景~taskは、概して，［
`setTimeout()$m を利用して~callbackを~scheduleして，その~callbackにて背景~taskを稼働する
］ことにより遂行されている。
◎
Web pages often want to execute computation tasks on the browser's event loop which are not time-critical, but might take a significant portion of time to perform. Examples of such background tasks include recording analytics data, long running data processing operations, client-side templating and pre-rendering of content likely to become visible in the near future. These tasks must share the event loop with other time-critical operations, such as reacting to input and performing script-based animations using requestAnimationFrame. These background tasks are typically performed by scheduling a callback using setTimeout and running the background task during that callback.
</p>

<p>
この~approachの欠点は：
◎
A disadvantage of this approach is that＼
</p>

<ul>
	<li>
~scriptの作者には、
`setTimeout()$m に与えた~callbackが［
時間に厳しいのか，~UAが遊休~中になるまで遅延できるのか
］について，~UAに伝えるすべがない。
◎
the author of the script has no way to inform the user-agent as to whether a given setTimeout callback is time-critical or could be delayed until the browser is otherwise idle.＼
</li>
	<li>
~UAは、［［
時間に厳しい演算の遅延や，~jankその他の利用者が知覚し得るような遅延
］をもたらすことなく，いつまで~callbackを実行し続けられるか
］についての情報を，~callbackに提供できない。
◎
In addition, the user agent isn't able to provide the callback with any information about how long it can continue to execute without delaying time-critical operations and causing jank or other user-perceptible delays.＼
</li>
</ul>

<p>
その結果，作者にとっては、単純に［
微小な値を引数に `setTimeout()$m を~callして，その~callbackの中で最小限に細分化された仕事をこなし，追加の仕事を `setTimeout()$m への別の~callで再度~scheduleする
］のが，最も容易になるが、これは：
◎
As a result, the easiest way forward is for the author is to simply call setTimeout with a very small value, and then execute the minimum possible chunk of work in the resulting callback and reschedule additional work with another call to setTimeout.＼
</p>

<ul>
	<li>
多数の小さな~taskを~UAの~event~loopに~postして，それらの実行を~scheduleすることによる，余計な~overheadがあるので、最適とは言えない。
◎
This is less than optimal because there is extra overhead from having to post many small tasks on the user agent's event loop and schedule their execution.＼
</li>
	<li>
~UAが，［
これらの~callbackのそれぞれを，時間に厳しい他の仕事の合間に適切に差挟む
］ことに依拠しているが、そうするのは困難である
— ~UAは、それぞれの~callbackが要する時間について正確0な前提を置けないので。
◎
 It also relies on the user-agent interleaving other time-critical work between each of these callbacks appropriately, which is difficult since the user-agent can't make accurate assumptions on how long each of these callbacks are likely to take.
</li>
</ul>


<p>
この文書にて述べる~APIにより、~script作者は，［
~callbackを，~UAが遊休~中になったなら~callされるように~scheduleする
］よう，~UAに要請することが可能になる。
~UAは、その~callbackに［
自身の見積もりによる，自身が遊休~中であり続ける時間
］を，刻限（ deadline ）として渡す。
頁~作者は、その刻限を利用して，［
~callbackが実行する背景~taskが，~animationや, 利用者~入力に対する応答などの~~遅延に厳しい~eventに波及しない
］ことを確保できる。
◎
The API described in this document allows script authors to request the user-agent to schedule a callback when it would otherwise be idle. The user agent provides an estimation of how long it expects to remain idle as a deadline passed to the callback. The page author can use the deadline to ensure that these background tasks don't impact latency-critical events such as animation and input response.
</p>

<p>
この~APIを利用して、背景~taskを書く例を示す：
◎
Here is an example of using the API to write a background task.
</p>

<div class="example">
<pre>
&lt;!DOCTYPE html&gt;
&lt;title&gt;<span class="comment">
`requestIdleCallback()$m を利用して、背景~taskを~scheduleする
◎
Scheduling background tasks using requestIdleCallback
</span>&lt;/title&gt;
&lt;script&gt;
var %requestId = 0;
var %pointsTotal = 0;
var %pointsInside = 0;

function piStep() {
  var %r = 10;
  var %x = Math.random() * %r * 2 - %r;
  var %y = Math.random() * %r * 2 - %r;
  return (Math.pow(%x, 2) + Math.pow(%y, 2) &lt; Math.pow(%r, 2))
}
function refinePi(%deadline) {
  while (%deadline.timeRemaining() &gt; 0) {
    if (piStep())
      %pointsInside++;
    %pointsTotal++;
  }
  var %currentEstimate = (4 * %pointsInside / %pointsTotal);
  var %textElement = document.getElementById("piEstimate");
  %textElement.innerHTML="Pi Estimate: " + %currentEstimate;
  %requestId = window.requestIdleCallback(refinePi);
}
function start() {
  %requestId = window.requestIdleCallback(refinePi);
}
function stop() {
  if (%requestId)
    window.cancelIdleCallback(%requestId);
  %requestId = 0;
}
&lt;/script&gt;
&lt;button onclick="start()"&gt;クリックで開始&lt;/button&gt;
&lt;button onclick="stop()"&gt;クリックで停止&lt;/button&gt;
&lt;div id="piEstimate"&gt;まだ開始されていない&lt;/div&gt;
</pre>

<!-- 
Click me to start!
Click me to stop!
Not started
 -->
</div>

	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~IF, ~THROW 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
原文にて `HTML5$r 仕様による定義を参照している用語は、便宜のため，この訳では WHATWG HTML 仕様（の和訳）による定義を参照している。
</p>


	</section>
	<section id="idle_period">
<h2 title="Idle Periods">3. 遊休~期間</h2>

~INFORMATIVE

<p>
~UAの~main-threadは、［
入力~処理, および
所与の~frameに対する 具現化＆合成
］が完了してから，［
次の~frameが始まる ／
別の処理待ち~taskが稼働可能になる ／
利用者からの入力を受取る
］のいずれかが生じるまでは、遊休~中になることが多い。
この仕様は、この遊休~中の間に ~callbackの実行を~scheduleする手段を， `requestIdleCallback()$m を介して提供する。
◎
After input processing, rendering and compositing for a given frame has been completed, the user agent's main thread often becomes idle until either: the next frame begins; another pending task becomes eligible to run; or user input is received. This specification provides a means to schedule execution of callbacks during this otherwise idle time via a requestIdleCallback API.
</p>

<p>
`requestIdleCallback()$m を介して~postされた~callbackには、~UAにより定義される遊休~期間にて稼働可能になる。
遊休~callback
【 “~UAの遊休~期間に~callされるものとして，作者が与える~callback関数” 】
の稼働-時には、現在の遊休~期間の終端に対応する刻限が渡される。
何をもって遊休~期間とするかは，~UAにより定義されるが、［
~UA自身が遊休~中にあると予期するような， “~~静止” 期間
］に生じるものと期待される。
◎
Callbacks posted via the requestIdleCallback API become eligible to run during user agent defined idle periods. When an idle callback is run it will be given a deadline which corresponds to the end of the current idle period. The decision as to what constitutes an idle period is user agent defined, however the expectation is that they occur in periods of quiescence where the browser expects to be idle.
</p>

<p>
遊休~期間の一例として、次の図に示されるような，［
所与の~frameを~screenへ~commitしてから，作動中の~animationの間に次の~frameの処理を開始するまで
］の時区間が挙げられる。
そのような遊休~期間は，~animationが作動中にあり, ~screenが更新され続ける間に，高頻度に生じるが、概して とても短くなる（すなわち、~vsync周期が 60Hz の機器においては約 16ms 以下）。
◎
One example of an idle period is the time between committing a given frame to the screen and starting processing on the next frame during active animations, as shown in Figure 1 Example of an inter-frame idle period . Such idle periods will occur frequently during active animations and screen updates, but will typically be very short (i.e., less than 16ms for devices with a 60Hz vsync cycle).
</p>


<figure id="figure1">
<!-- requestidlecallback/image01.png
Image source avaliable at
https://docs.google.com/document/d/1zGgKAJVTDVgq0LpZDL3HD0jNiveivHb_V2Wb8C3jsEE/edit
-->

<div style="padding: 1em 0;">
	<div class="_frames1">
…
		<div class="_separator">
<div style="left:0;">~frame#1</div>
		</div>
<span class="_task _UA_task">~taskを<br>稼働する</span>
<span class="_task _UA_task">描画<br>更新</span>
		<div class="_period">
遊休~期間<br />
<span class="_task _idle_callback">遊休<br>~callback</span>
<span class="_task _idle_callback">遊休<br>~callback</span>
		</div>
		<div class="_separator">
<div style="left:0;">~frame#2</div>
		</div>
<span class="_task _UA_task">~taskを<br>稼働する</span>
<span class="_task _UA_task">~taskを<br>稼働する</span>
<span class="_task _UA_task">描画<br>更新</span>
		<div class="_period">
遊休~期間<br />
<span class="_task _idle_callback">遊休<br>~callback</span>
		</div>
		<div class="_separator">
		</div>
…
	</div>
	<div style="border-top: solid black 1px;" title="時間軸">
時間 →
<span style="float:right;">→</span>
	</div>
</div>
<figcaption>
~frame間の遊休~期間の例
◎
Example of an inter-frame idle period
</figcaption></figure>

<p class="note">注記：
~web開発者は、遊休~callbackの間に その演算が遂行するすべての仕事を【非同期的なものも含めて】勘定に入れるよう，注意深くなるべきである。
一部の演算
— 例えば、~promiseを解決する, あるいは頁~layoutを誘発するものなど —
は、遊休~callbackが終わった後にも，後続の~taskを~scheduleさせ得る。
そのような事例では、刻限を過ぎる前に，これらの演算を次の~frame刻限の前に遂行できるように先送りするべきである。
◎
The web-developer should be careful to account for all work performed by operations during an idle callback. Some operations, such as resolving a promise or triggering a page layout, may cause subsequent tasks to be scheduled to run after the idle callback has finished. In such cases, the application should account for this additional work by yielding before the deadline expires to allow these operations to be performed before the next frame deadline.
</p>

<p>
遊休~期間の別の例として、~screenの更新がないときの遊休~~状態が挙げられる。
そのような状況では、~UAが遊休~期間を早々に終端させ得るような差し迫った~taskがないときでも、いつ起きるか予測不能な~task
— 利用者~入力の処理など —
により，利用者が知覚し得る遅延が起きないようにするため、遊休~期間の長さは，
<a href="#why50">50ms を上限にする</a>べきである。
遊休~期間が終わり，まだ遊休~中にあるならば、~UAは，次の図に示されるように，別の遊休~期間を~scheduleできる
— 背景~仕事は、複数の遊休~期間にわたり，何回でも存続し続けられる。
◎
Another example of an idle period is when the user agent is idle with no screen updates occurring. In such a situation the user agent may have no upcoming tasks with which it can bound the end of the idle period. In order to avoid causing user-perceptible delays in unpredictable tasks, such as processing of user input, the length of these idle periods should be capped to a maximum value of 50ms. Once an idle period is finished the user agent can schedule another idle period if it remains idle, as shown in Figure 2 Example of an idle period when there are no pending frame updates , to enable background work to continue to occur over longer idle time periods.
</p>


<figure id="figure2">
<!-- requestidlecallback/image00.png -->
<div style="padding-bottom: 1em;">
	<div class="_frames1">
…
<span class="_task _UA_task">描画<br>更新</span>
		<div class="_separator">
<div style="left:auto; right:0; text-align:right;">~frame#1</div>
		</div>
		<div class="_period">
<div class="_deadline">← 50ms 刻限 →</div>
遊休~期間<br />
<span class="_task _idle_callback">遊休<br>~callback</span>
<span class="_task _idle_callback">遊休<br>~callback</span>
		</div>

		<div class="_period" style="position:relative;">
<div class="_deadline">← 50ms 刻限 →</div>
遊休~期間<br />
<span class="_task _idle_callback">遊休<br>~callback</span>
<span class="_task _idle_callback">遊休<br>~callback</span>
<div style="position:absolute; right:1em;">　　　↑<br><span style="background: white;">利用者~入力</span></div>
		</div>
		<div class="_separator">
<div style="left:0;">~frame#2</div>
		</div>
<span class="_task _UA_task">描画<br>更新</span>
…
	</div>
	<div style="border-top: solid black 1px;" title="時間軸">
時間 →
<span style="float:right;">→</span>
	</div>
</div>
<figcaption>
処理待ちの~frame更新はないときの遊休~期間の例
◎
Example of an idle period when there are no pending frame updates
</figcaption></figure>


<p>
遊休~期間の間，~UAは、各 遊休~callbackを［
遊休~期間が終端するか, または
稼働可能とされている遊休~callbackをすべて稼働し終える
］まで、要請された順に稼働することになる。
すなわち、~UAは必ずしも，~postされた遊休~callbackすべてを単独の遊休~期間~内に稼働させることはない。
残りの遊休~taskは、次の遊休~期間にも稼働可能であり続ける。
◎
During an idle period the user agent will run idle callbacks in FIFO order until either the idle period ends or there are no more idle callbacks eligible to be run. As such, the user agent will not necessarily run all currently posted idle callbacks within a single idle period. Any remaining idle tasks are eligible to run during the next idle period.
</p>

<p class="note">注記：
最良の処理能を発揮させるためには、開発者には，有意義な仕事を遂行しない不必要な~callback（例：
`requestAnimationFrame()^m,
`setTimeout()^m, 等々）は排することが奨励される
— そのような~callbackを発火させ続けて，各~eventに反応するのを待機するのでなく、各~eventに反応する~callbackを，可用になり次第 必要に応じて~scheduleするほうがよい。
この~patternにより、全体的な効率性は改善され、~UAは，背景~仕事の巨大blockをより効率的に遂行できるような，長い（ 50ms までの）遊休~callbackを~scheduleすることが可能になる。
◎
To deliver the best performance developers are encouraged to eliminate unnecessary callbacks (e.g. requestAnimationFrame, setTimeout, and so on) that do not perform meaningful work; do not keep such callbacks firing and waiting for events to react, instead schedule them as necessary to react to events once they become available. Such pattern improves overall efficiency, and enables the user agent to schedule long idle callbacks (up to 50ms) that can be used to efficiently perform large blocks of background work.
</p>

<p>
現在の遊休~期間にて稼働可能であるとされる遊休~taskは、その遊休~期間が開始される前に~postされたものに限られる。
したがって、ある遊休~callbackが `requestIdleCallback()$m を利用して別の~callbackを~postしたならば、その~callbackは，現在の遊休~期間においては稼働しないことになる。
これにより、遊休~callbackは，自身の仕事を所与の刻限までに完了できない場合には，未来の遊休~期間にまた稼働させるように自身を再度~postできるようになる。
すなわち、次の例の様に，遊休~期間が短か過ぎるときは先送りする~code~patternも可能になる：
◎
Only idle tasks which posted before the start of the current idle period are eligible to be run during the current idle period. As a result, if an idle callback posts another callback using requestIdleCallback, this subsequent callback won't be run during the current idle period. This enables idle callbacks to re-post themselves to be run in a future idle period if they cannot complete their work by a given deadline - i.e., allowing code patterns like the following example, without causing the callback to be repeatedly executed during a too-short idle period:
</p>


<div class="example"><pre>
function doWork(%deadline) {
  if (%deadline.timeRemaining() &lt;= 5) {
    /* <span class="comment">
この仕事は 5ms 以上かかるので、刻限の余裕が十分になるまで，先送りする。
◎
This will take more than 5ms so wait until we get called back with a long enough deadline.
</span> */
    requestIdleCallback(doWork);
    return;
  }
  /* <span class="comment">
何らかの仕事を行う…
◎
do work...
</span> */
}
</pre></div>


<p>
新たに~postされた遊休~callbackは、`遊休~callback~list$の末尾に付加され，次の遊休~期間の開始~時に`稼働可能$にされる。
したがって，再~postされる~callbackたちは、~round-robin式に
— 各~callbackが［
同じ遊休~期間における，より早期の~taskにより再~postされた~callback
］より前に稼働する機会が得られるように —
稼働することが確保される。
◎
At the start of the next idle period newly posted idle callbacks are appended to the end of the runnable idle callback list, thus ensuring that reposting callbacks will be run round-robin style, with each callback getting a chance to be run before that of an earlier task's reposted callback.
</p>

<p class="note">注記：
この仕様の将来~versionでは、他の~schedule方策も許容され得る。
例えば、遊休~callbackを同じ遊休~期間の中で~scheduleしたり、少なくとも X ~milli秒 以上の遊休~期間, 等々。
現在の仕様は、~callbackが［
自身の~logicを実行したり，次の遊休~期間に自身を再~postできる
］ような，次の遊休~期間に~scheduleする事例のみを~supportする
◎
Future versions of this specification could allow other scheduling strategies. For example, schedule idle callback within the same idle period, a period that has at least X milliseconds of idle time, and so on. Current specification only supports the case for scheduling into the next idle period, at which time the callback can execute its logic, or repost itself into the next idle period.
</p>

<p>
~UAは、~web頁が利用者から可視でない下では、機器の電力消費を抑えるためなど，遊休~期間の生成を間引くこともできる
— 例えば，毎 10 秒ごとに一回にするなど。
◎
When the user agent determines that the web page is not user visible it can throttle idle periods to reduce the power usage of the device, for example, only triggering an idle period every 10 seconds rather than continuously.
</p>

<p>
最後に，目立たないが重要な点として、頁の負荷が高い間は，~UAが遊休~期間として可用な CPU 時間をあてがう保証-はないことに注意。
~UAが遊休~期間を何ら~scheduleしないことも，まったく受容可能であり、その場合，
`requestIdleCallback()$m を介して~postされた遊休~callbackは、不定期に先送りされることにもなり得る。
作者は、~callbackを遊休~期間~内に実行させたいが，ある時間までに実行することを要する場合には、
`requestIdleCallback()$m の %options 引数に `timeout$m ~memberを提供できる
— 遊休~期間~内に~callbackが実行される前に，指定された~timeoutに達した場合、それを実行する~taskが~queueされる。
◎
A final subtlety to note is that there is no guarantee that a user agent will have any idle CPU time available during heavy page load. As such, it is entirely acceptable that the user agent does not schedule any idle period, which would result in the idle callbacks posted via the requestIdleCallback API being postponed for a potentially unbounded amount of time. For cases where the author prefers to execute the callback within an idle period, but requires a time bound within which it can be executed, the author can provide the timeout property in the options argument to requestIdleCallback: if the specified timeout is reached before the callback is executed within an idle period, a task is queued to execute it.
</p>

<p class="note" id="why50">
刻限の上限 50ms は、 `RESPONSETIME$r の研究から導出されたものである
— そこでは、利用者~入力に対する 100ms 内の応答は，一般に人にとっては瞬間的であると知覚されることが示されている。
したがって，遊休~taskが始まった直後に利用者~入力が生じたとしても、~UAには，［
利用者から知覚されることなく 入力に応答するための猶予
］として， 50ms が残されることになる。
◎
The maximum deadline of 50ms is derived from studies [RESPONSETIME] which show that that a response to user input within 100ms is generally perceived as instantaneous to humans. Capping idle deadlines to 50ms means that even if the user input occurs immediately after the idle task has begun, the user agent still has a remaining 50ms in which to respond to the user input without producing user perceptible lag.
</p>
	</section>
	<section id="conformance">

<h2 title="Conformance">4. 適合性</h2>
<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>
	<section id="window_extensions">

<h2 title="Window interface extensions">5. `Window^I ~interfaceに対する拡張</h2>

<p>
`requestIdleCallback()$m 演算は、下の IDL 片による部分的~interfaceにより，
`Window$I ~obj上に公開される。
`HTML5$r
◎
The partial interface in the IDL fragment below is used to expose the requestIdleCallback operation on the Window object. [HTML5]
</p>

<pre class="idl">
partial interface `Window$I {
  unsigned long `requestIdleCallback$m(
      `IdleRequestCallback$I %callback,
      `IdleRequestOptions$I %options
  );
  void `cancelIdleCallback$m(unsigned long %handle);
};

dictionary `IdleRequestOptions@I {
  unsigned long `timeout@m;
};

[`Exposed$=Window]
interface `IdleDeadline@I {
  `DOMHighResTimeStamp$I `timeRemaining$m();
  readonly attribute boolean `didTimeout$m;
};

callback `IdleRequestCallback@I = void (`IdleDeadline$I %deadline);
</pre>

<p>
各 `Window$I ~objは、次のものを持つ：
◎
Each Window has:
</p>


<dl class="def-list">
	<dt>`遊休~callback~list@</dt>
	<dd>
一連の`遊休~callback$からなる~listであり，初期~時は空で~MUST。
~list内の各 `遊休~callback$の`~handle$は、当の `Window^I ~objが存続する限り，一意にされ~MUST。
◎
A list of idle request callbacks. The list MUST be initially empty and each entry in this list is identified by a number, which MUST be unique within the list for the lifetime of the Window object.
◎
A list of runnable idle callbacks. The list MUST be initially empty and each entry in this list is identified by a number, which MUST be unique within the list of the lifetime of the Window object.
</dd>
	<dd class="trans-note">【
この~listは、原文では， 2 つの~list
`要請-済み遊休~callback~list@,
`稼働可能な遊休~callback~list@
に分けて管理されているが、この訳では 1 つの~listに集約した上で，各`遊休~callback$の`稼働可能$により管理する。
そうした方がずっと簡潔に記述できるので。
】</dd>

	<dt>`遊休~callback識別子@</dt>
	<dd>
整数。
初期~時は 0 にされ~MUST。
◎
An idle callback identifier, which is a number which MUST initially be zero.
</dd>

	<dt>`最後の遊休~期間~刻限@</dt>
	<dd>
`DOMHighResTimeStamp$I 値。
初期~時は 0 にされ~MUST。
◎
A last idle period deadline, which is a DOMHighResTimeStamp which MUST initially be zero.
</dd>
</dl>


		<section id="the-requestidlecallback-method">
<h3 title="The requestIdleCallback method">5.1. `requestIdleCallback()^m ~method</h3>

<p class="idl-def">
`requestIdleCallback(callback, options)@m
~methodの被呼出時には、次を走らせ~MUST：
◎
When requestIdleCallback(callback, options) is invoked with a given IdleRequestCallback and optional IdleRequestOptions, the user agent MUST run the following steps:
</p>

<ol>
	<li>
此れの`遊休~callback識別子$ ~INCBY 1
◎
Let window be this Window object.
◎
Increment the window's idle callback identifier by one.
</li>
	<li>
%~handle ~LET 此れの`遊休~callback識別子$の値
◎
Let handle be the current value of window's idle callback identifier.
</li>
	<li>
`遊休~期間を開始する？^V ~LET ［
此れの`遊休~callback~list$は空ならば ~T ／
~ELSE_ ~F
］
◎
Let start_idle_period be true if the window's list of idle request callbacks and it's list of runnable idle callbacks are empty, otherwise false.
</li>
	<li>
此れの`遊休~callback~list$に，次のように設定された新たな`遊休~callback$を付加する
⇒
( `~callback$, `~handle$ ) ~SET ( %callback, %~handle )
◎
Push callback to the end of window's list of idle request callbacks, associated with handle.
</li>
	<li>
~IF［
`遊休~期間を開始する？^V ~EQ ~T
］
⇒
`遊休task~task源$から，次を走らす`~taskを~queueする$
⇒
`遊休~期間を開始する$( 此れ )
◎
If start_idle_period is true:
• queue a task on the queue associated with the idle-task task source, which performs the start an idle period algorithm, passing window as a parameter.
</li>
	<li>
<p>
~RET %~handle
— ただし、以降の手続きも非同期に継続する。
◎
Return handle and then continue running this algorithm asynchronously.
</p>

<p class="note">注記：
以降，手続きは並列的に走るが、任意選択の `timeout^m ~memberが提供されていれば， `setTimeout()^m に似た~timerも~queueする。
ここからは，遊休~callbackと~timeout~callbackの競争になり、先に~scheduleされた方がもう片方（例えば 遊休~callbackが先なら、~timeout~callbackの方）を取消すことになる。
◎
The following steps run in parallel and queue a timer similar to setTimeout() if the optional timeout property is provided. From here, the idle and timeout callbacks are raced and cancel each other—e.g. if the idle callback is scheduled first, then it cancels the timeout callback, and vice versa.
</p>
	</li>
	<li>
<p>
~IF［
%options に `timeout$m ~memberは在する ~AND
その値 ~GT 0
］：
◎
If the timeout property is present in options and has a positive value:
</p>
		<ol >
			<li>
%~timeout ~LET
現在時刻 ~PLUS ( `timeout^m ~member値を~milli秒~単位の時間~長として解釈した結果 )
◎
↓</li>
			<li>
［
現在時刻 ~GTE %~timeout
］になるまで待機する
◎
Wait for timeout milliseconds.
</li>
			<li>
~IF［
この~algoの他の呼出にて，この~algoの中で待機しているもののうち，［
そこでの %~timeout ~LT この %~timeout
］なるものがある
⇒
それらすべてが この~algoを終えるまで待機する
◎
Wait until all invocations of this algorithm, whose timeout added to their posted time occurred before this one's, have completed.
</li>
			<li>
<p>
任意選択で、~UAが定義する時間だけ更に待機する
◎
Optionally, wait a further user-agent defined length of time.
</p>

<p class="note">注記：
この段には、［
~UAが、機器の電力消費を最適化する必要に応じて，~timeoutを pad できるようにする
］ことが意図されている。
例えば、~timerの粒度を抑えるような節電~modeを有する~processorも中にはあり、そのような~platform上では，~UAは，より正確0な非~節電~modeを利用することを要求する代わりに，この~scheduleに見合うように~timerを slow down できる。
◎
This is intended to allow user agents to pad timeouts as needed to optimise the power usage of the device. For example, some processors have a low-power mode where the granularity of timers is reduced; on such platforms, user agents can slow timers down to fit this schedule instead of requiring the processor to use the more accurate mode with its associated higher power usage.
</p>

<p class="trans-note">【
“pad”, “slow down” が，時間の進行を遅らすのか, 実装が保有する すべての［ 刻限／~timeout ］を延期する（遅延を加算する）のかは、明確に述べられていない
— いずれにせよ、その違いは~APIには現れないためと見られる。
】</p>

			</li>
			<li>
`遊休task~task源$から，次を走らす`~taskを~queueする$
⇒
`~timeoutに達した遊休~callbackを呼出す$( 此れ, %~handle )
◎
Queue a task on the queue associated with the idle-task task source, which performs the invoke idle callback timeout algorithm, passing handle and window as arguments.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
`requestIdleCallback()$m は、［
単独の`遊休~期間$~内に実行されることになる，~callbackの一回の~call
］のみを~scheduleする。
その~callbackは， %刻限 までに自身の仕事を完了できないならば、再度 `requestIdleCallback()$m を~callした上で（これは，~callback自身の中で行える），制御を即時に`~event~loop$に返して、自身の~taskを継続するための未来の~callを~scheduleするべきである。
◎
requestIdleCallback only schedules a single callback, which will be executed during a single idle period. If the callback cannot complete its work before the given deadline then it should call requestIdleCallback again (which may be done from within the callback) to schedule a future callback for the continuation of its task, and exit immediately to return control back to the event loop.
</p>

		</section>
		<section id="the-cancelidlecallback-method">
<h3 title="The cancelIdleCallback method">5.2. `cancelIdleCallback()^m ~method</h3>

<p class="idl-def">
`cancelIdleCallback(handle)@m
~methodは、以前に行った`遊休~callback$を~scheduleする要請を取消す。
被呼出時には、次を走らせ~MUST：
◎
The cancelIdleCallback method is used to cancel a previously made request to schedule an idle callback. When cancelIdleCallback(handle) is invoked, the user agent MUST run the following steps:
</p>

<ol>
	<li>
%遊休~callback~list ~LET 此れの`遊休~callback~list$
◎
Let window be this Window object.
</li>
	<li>
~IF［
%遊休~callback~list 内に［
`~handle$ ~EQ %~handle
］なる`遊休~callback$はある
］
⇒
%遊休~callback~list から その`遊休~callback$を除去する
◎
Find the entry in either the window's list of idle request callbacks or list of runnable idle callbacks that is associated with the value handle.
◎
If there is such an entry, remove it from both window's list of idle request callbacks and the list of runnable idle callbacks.
</li>
</ol>

<p class="note">注記：
`cancelIdleCallback()$m
は、`稼働可能$かどうかにかかわらず，`遊休~callback~list$から`遊休~callback$を除去する。
◎
cancelIdleCallback might be invoked for an entry in window's list of idle request callbacks or the list of runnable idle callbacks. In either case the entry should be removed from the list so that the callback does not run.
</p>

		</section>
		<section id="the-idledeadline-interface">
<h3 title="The IdleDeadline interface">5.3. `IdleDeadline^I ~interface</h3>

<div class="p">
<p>
各 `IdleDeadline$I ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`刻限~時刻@</dt>
	<dd>
刻限の絶対的な時刻
— すなわち，`時刻起点$から刻限までの時間~差 —
を表現する `DOMHighResTimeStamp$I 値を保持する。
<!-- 
~objの作成-時に拡充され~MUST。
 -->
</dd>
	<dd class="trans-note">【
この用語は，原文では `time^c と記され, ~markupされているが、
`IdleDeadline$I の~IDL~memberではなく紛らわしいので，この語で表すことにする。
】</dd>

	<dt>`~timeout？@</dt>
	<dd>
現在時刻が`刻限~時刻$を過ぎたかどうかを指示する真偽~値。
</dd>
	<dd class="trans-note">【
原文では 単に “~timeout” であるが、~timeoutの時刻を表す変数／語と同じ名前で紛らわしいので，この訳では "？" を付けることにする。
】</dd>
</dl>

◎
Each IdleDeadline has an associated time which holds a DOMHighResTimeStamp representing the absolute time in milliseconds of the deadline. This MUST be populated when the IdleDeadline is created.
◎
↓↓</div>

<dl class="idl-def">
	<dt>`timeRemaining()@m</dt>
	<dd class="trans-note">【
`刻限~時刻$までの残り時間を返す。
】</dd>
	<dd>
被呼出時には、
( 此れの`刻限~時刻$ − `現在の高分解能~時刻$ )
を 0 以上に切り上げた結果を表現する `DOMHighResTimeStamp$I 型~値を返さ~MUST。
◎
When the timeRemaining() method is invoked on an IdleDeadline object it MUST return the duration, as a DOMHighResTimeStamp, between the current time and the time associated with the IdleDeadline object.＼
</dd>
	<dd>
結果の値は， 5 ~micro秒までの細かさに~~抑える~SHOULDである（
<a href="~HRTIME#privacy-security">~privacyと保安</a>
`HR-TIME-2$r
を見よ）。
◎
The value SHOULD be accurate to 5 microseconds - see "Privacy and Security" section of [HR-TIME]. This value is calculated by performing the following steps:
• Let now be a DOMHighResTimeStamp representing current high resolution time in milliseconds.
• Let deadline be the time associated with the IdleDeadline object.
• Let timeRemaining be deadline - now.
• If timeRemaining is negative, set it to 0.
• Return timeRemaining.
</dd>

	<dt>`didTimeout@m</dt>
	<dd>
取得子は、此れの`~timeout？$を返さ~MUST。
◎
Each IdleDeadline has an associated timeout, which is initially false. The didTimeout getter MUST return timeout.
</dd>
	<dd class="note">注記：
`~timeoutに達した遊休~callbackを呼出す$~algoは、~callbackの登録-時に渡された `IdleRequestOptions$I ~objの `timeout^m 値を超過したときには、`~timeout？$を ~T に設定して，~callbackが遊休~期間の外側で実行されていることを指示する。
◎
The invoke idle callback timeout algorithm sets timeout to true to specify that the callback is being executed outside an idle period, due to it having exceeded the value of the IdleRequestOptions's timeout property which was passed when the callback was registered.
</dd>
</dl>


		</section>
	</section>
	<section id="processing-model">
<h2 title="Processing Model">6. 処理~model</h2>

		<section id="_idle-callbacks">
<h3>6.X. 遊休~callback</h3>

<p class="trans-note">【
この訳では、~modelを明確かつ簡潔に記述するため，この節にて，以下の各種~用語／~algoを導入する。
】</p>

<p>
各
`遊休~callback@
は、次のものからなる：
</p>

<dl class="def-list">
	<dt>`~callback@</dt>
	<dd>
~scheduleするよう要請された~callback関数。
</dd>

	<dt>`~handle@</dt>
	<dd>
この遊休~callbackを`遊休~callback~list$内で一意に識別する整数。
</dd>

	<dt>`稼働可能@</dt>
	<dd>
真偽~値。
初期~時は ~F 。
~F の間は、次回の遊休~期間まで，`~callback$の~callは先送りされる。
</dd>
</dl>

<p class="algo-head">
`遊休~callbackを内部的に呼出す@
ときは、所与の
(
`遊休~callback$ %遊休~callback,
`DOMHighResTimeStamp$I 値 %刻限,
真偽~値 `~timeout？^V
)
に対し，次を走らす：
</p>

<ol>
	<li>
%刻限~引数 ~LET
次のように設定された，新たな `IdleDeadline$I ~obj
⇒
( `刻限~時刻$, `~timeout？$ ) ~SET ( %刻限, `~timeout？^V )
</li>
	<li>
<p>
%刻限~引数 を引数に，
%遊休~callback の`~callback$を~callする
</p>

<p>
この段にて~scriptから例外が投出されたときは、~catchして
⇒
その`~errorを報告する$
</p>
	</li>
</ol>

		</section>
		<section id="start-an-idle-period-algorithm">
<h3 title="Start an idle period algorithm">6.1 遊休~期間を開始する~algo</h3>

<p class="algo-head">
`遊休~期間を開始する@
ときは、所与の %window に対し，次を走らす：
◎
The start an idle period algorithm:
</p>

<ol>
	<li>
%最後の刻限 ~LET %window の`最後の遊休~期間~刻限$
◎
Let last_deadline be the last idle period deadline associated with window
</li>
	<li>
%~event~loop ~LET %window 【が属する閲覧文脈】に結付けられている`~event~loop$
◎
Let event_loop be the event loop associated with window
</li>
	<li>
~IF［
現在時刻 ~LT %最後の刻限
］
⇒
現在時刻 ~GTE  %最後の刻限 になるまで，`~event~loopを回す$
◎
If last_deadline is greater than the current time:
• Spin the event loop until the current time is greater than or equal to last_deadline.
</li>
	<li>
<p>
%~event~loop が有する［
`~task~queue$,  `極小task~queue$
］すべてが空になるまで，`~event~loopを回す$
◎
Spin the event loop until all the task queues and the microtask queue associated with event_loop are empty.
</p>

<p class="note">注記：
~UAには、［［
%~event~loop が結付けられていて, かつ
自身が描画しようと意図する，すべての`閲覧文脈$
］それぞれにて`全部的に作動中$の文書
］における未終了の更新
］があれば、それらの現在の状態を反映するために，描画と`閲覧文脈$を更新することが期待される（すなわち、
<a href="~WAPI#event-loop-processing-model" >~event~loop処理~model</a>
の
<a href="~WAPI#update-the-rendering">描画を更新する</a>
段）。
すなわち，~animationにおける現在の~frame用の描画~更新は、この段を終えた時点で，すべて完了することになる。
◎
The expectation is that the user agent will update the rendering and browsing context to reflect the current state of any outstanding updates for all fully active Document objects associated event_loop (i.e., step 7 of event loop processing model) for any browsing context the user agent intends to render. I.e., during animations all rendering updates for the current frame will be completed after this step.
</p>
	</li>
	<li>
<p>
任意選択で、~UAが定義する時間だけ更に待機する
◎
Optionally, wait a further user-agent defined length of time.
</p>

<p class="note">注記：
これには、~UAが，機器の電力消費を最適化するために［
必要に応じて，遊休~期間を開始するのを遅延できるようにする
］ことが意図されている。
［
`文書$の `hidden$m 属性 ~EQ ~T
］の下では、~UAは，文書に対し遊休~期間の生成を間引くこともできる
— 例えば、一回の遊休~期間を毎 10 秒ごとに制限するなど。
`page-visibility$r
◎
This is intended to allow user agents to delay the start of idle periods as needed to optimise the power usage of the device. For example, if the Document's hidden attribute ([page-visibility]) is true then the user agent can throttle idle period generation, for example limiting the Document to one idle period every 10 seconds to optimize for power usage.
</p>
	</li>
	<li>
%今 ~LET 現在時刻
◎
Let now be the current time.
</li>
	<li>
<p>
%刻限 ~LET ~UAがその時点までは遊休~中であり続けるものと予期する，時間軸~上のある時点
◎
Let deadline be a time in the future until which the browser expects to remain idle.＼
</p>

<p>
~UAは、［
~callbackが %今 から %刻限 までの期間~全体にわたって稼働するとしても，時間に厳しい~taskは遅延されない
］ように， %刻限 を選ぶべきである。
そのようなわけで、次のうちの最小に設定するべきである：
◎
The user agent SHOULD choose deadline to ensure that no time-critical tasks will be delayed even if a callback runs for the whole time period from now to deadline. As such, it should be set to the minimum of:＼
</p>

		<ul>
			<li>
［［
`setTimeout()$m ／ `setInterval()$m
］を介して設定された`作動中の~timerの~list$
］内の，最も近未来の~timeout
◎
the closest timeout in the list of active timers as set via setTimeout and setInterval;＼
</li>
			<li>
［
`requestAnimationFrame()$m を介して~postされた，処理待ちの~animation~callback
］用に~scheduleされている実行時
◎
the scheduled runtime for pending animation callbacks posted via requestAnimationFrame;＼
</li>
			<li>
 内部的な処理待ち~timeout
— 次の~frame描画の開始~刻限, 音声~処理, ~UAが重要と判断する他の内部的~taskなど。
◎
pending internal timeouts such as deadlines to start rendering the next frame, process audio or any other internal task the user agent deems important.
</li>
		</ul>
	</li>
	<li>
<p>
%刻限 ~SET min( %今 + 50ms, %刻限 )
◎
If deadline - now is greater than 50ms, then cap deadline by setting it to be now + 50ms.
</p>

<p class="note">注記：
50ms 後の未来までにしているのは、新たな利用者~入力に対し，人から知覚される閾値~内に~~収まる応答性を確保するためである。
◎
The cap of 50ms in the future is to ensure responsiveness to new user input within the threshold of human perception.
</p>
	</li>
	<li>
%window の`遊休~callback~list$内の ~EACH( %遊休~callback ) に対し
⇒
%遊休~callback の`稼働可能$ ~SET ~T
◎
Let pending_list be window's list of idle request callbacks.
◎
Let run_list be window's list of runnable idle callbacks.
◎
Append all entries from pending_list into run_list preserving order.
◎
Clear pending_list.
</li>
	<li>
`遊休task~task源$から，次を走らす`~taskを~queueする$
⇒
`遊休~callbackを呼出す$( %刻限, %window )
◎
Queue a task on the queue associated with the idle-task task source, which performs the steps defined in the invoke idle callbacks algorithm with deadline and window as parameters.
</li>
	<li>
%window の`最後の遊休~期間~刻限$ ~SET %刻限
◎
Save deadline as the last idle period deadline associated with window.
</li>
</ol>

<p>
これらの`~task$の`~task源$は、
`遊休task~task源@
とする。
◎
The task source for these tasks is the idle-task task source.
</p>

<p class="note">注記：
%今 から %刻限 までの時区間を指して，
`遊休~期間@
という。
どの `Window^I ~objにおいても、ある時点で作動中の遊休~期間は，一つに限られる。
遊休~期間は、~UAが最早~遊休~中でないと決定した場合には，早期に終端し得る。
そうなった場合でも、次の遊休~期間は， %刻限 に達するまで開始できない。
◎
The time between now and deadline is referred to as the idle period. There can only be one idle period active at a given time for any given window. The idle period can end early if the user agent determines that it is no longer idle. If so, the next idle period cannot start until after deadline.
</p>

		</section>
		<section id="invoke-idle-callbacks-algorithm">
<h3 title="Invoke idle callbacks algorithm">6.2 遊休~callbackを呼出す~algo</h3>

<p class="algo-head">
`遊休~callbackを呼出す@
ときは、所与の
( %刻限, %window )
に対し，次を走らす：
◎
The invoke idle callbacks algorithm:
</p>

<ol>
	<li>
%遊休~callback~list ~LET %window の`遊休~callback~list$
◎
↓</li>
	<li>
~IF［
高~優先度な仕事が新たに~scheduleされたことに因り，遊休~期間は早々に終端すべきと予見される
］
⇒
~GOTO `最後の段^i
◎
If the user-agent believes it should end the idle period early due to newly scheduled high-priority work, skip to step 4.
</li>
	<li>
<p>
~IF［
現在時刻 ~LT %刻限
］：
◎
Let now be the current time.
◎
If now is less than deadline:
</p>
		<ol>
			<li>
%遊休~callback ~SET %遊休~callback~list 内の［
`稼働可能$ ~EQ ~T
］なる最初の`遊休~callback$
<!-- ＊Pop -->
◎
Pop the top callback from window's list of runnable idle callbacks.
</li>
			<li>
~Assert：
そのような %遊休~callback はある
【この ~Assert は、この訳による追加。】
</li>
			<li>
%遊休~callback~list から %遊休~callback を除去する
◎
↑</li>
			<li>
`遊休~callbackを内部的に呼出す$( %遊休~callback, %刻限, ~F )
◎
Let deadlineArg be a new IdleDeadline. Set the time associated with deadlineArg to deadline and set the timeout associated with deadlineArg to false.
◎
Call callback with deadlineArg as its argument. If an uncaught runtime script error occurs, then report the error.
</li>
			<li>
~IF［
%遊休~callback~list は空でない
］
⇒
次を走らす`~taskを~queueする$
⇒
`遊休~callbackを呼出す$( %刻限, %window )
◎
If window's list of runnable idle callbacks is not empty, queue a task which performs the steps in the invoke idle callbacks algorithm with deadline and window as a parameters and return from this algorithm
</li>
			<li>
~RET
◎
↑</li>
		</ol>
	</li>
	<li>
`最後の段^i：<br>
~IF［
%遊休~callback~list は空でない
］
⇒
次を走らす`~taskを~queueする$
⇒
`遊休~期間を開始する$( %window )
◎
Otherwise, if either the window's list of idle request callbacks or it's list of runnable idle callbacks are not empty, queue a task which performs the steps in the start an idle period algorithm algorithm with window and as a parameter.
</li>
</ol>

<p class="note">注記：
~UAは、 %刻限 がまだ来ていなくても，上の~algoの `最後の段^i まで直接的に飛んで 遊休~期間を早々に終端させれる。
例えば~UAは、より優先度の高い稼働可能~な仕事があれば，そうしてよい。
◎
The user agent is free to end an idle period early, even if deadline has not yet occurred, by deciding to skip from step 1 directly to step 4. For example, the user agent may decide to do this if it determines that higher priority work has become runnable.
</p>


		</section>
		<section id="invoke-idle-callback-timeout-algorithm">
<h3 title="Invoke idle callback timeout algorithm">6.3 ~timeoutに達した遊休~callbackを呼出す~algo</h3>

<p class="algo-head">
`~timeoutに達した遊休~callbackを呼出す@
ときは、所与の
( %window, %~handle )
に対し，次を走らす：
◎
The invoke idle callback timeout algorithm:
</p>

<ol>
	<li>
%遊休~callback ~LET［
%window の`遊休~callback~list$内の［
`~handle$ ~EQ %~handle
］なる`遊休~callback$
］
◎
Let callback be the result of finding the entry in window's list of idle request callbacks or the list of runnable idle callbacks that is associated with the value given by the handle argument passed to the algorithm.
</li>
	<li>
~IF［
そのような %遊休~callback はない
］
⇒
~RET
◎
If callback is not undefined:
</li>
	<li>
%window の`遊休~callback~list$から %遊休~callback を除去する
◎
Remove callback from both window's list of idle request callbacks and the list of runnable idle callbacks.
</li>
	<li>
`遊休~callbackを内部的に呼出す$( %遊休~callback, 現在時刻, ~T )
◎
Let now be the current time.
◎
Let deadlineArg be a new IdleDeadline. Set the time associated with deadlineArg to now and set the timeout associated with deadlineArg to true.
◎
Call callback with deadlineArg as its argument. If an uncaught runtime script error occurs, then report the error.
</li>
</ol>

		</section>
	</section>
	<section id="privacy-and-security">
<h2 title="Privacy and Security">7. ~privacyと保安</h2>


<p>
~UAは、遊休~callbackの~schedule時に，自身が予期する，遊休であり続ける時間の見積もりを提供する。
この情報は、その~frameの中で 他の~app~taskや関係する~browserの仕事にかかった時間を見積もるために利用できる。
しかしながら，開発者はすでに、他の手段を介してこの情報に~accessできる
— 例えば、 `requestAnimationFrame()^m を介して~frameの始まりを~markして，次の~frameの時刻を見積もって，その情報を~callbackの中での “残り時間” を算出するために利用するなど。
◎
When an idle callback is scheduled the user agent provides an estimate of how long it expects to remain idle. This information can be used to estimate the time taken by other application tasks and related browser work within that frame. However, developers can already access this information via other means - e.g. mark beginning of the frame via requestAnimationFrame, estimate the time of the next frame, and use that information to compute "remaining time" within any callback.
</p>

<p>
~cache攻撃と統計的指紋収集を軽減するため、 `IdleDeadline$I ~interfaceから返される時間の分解能は、［
`HR-TIME-2$r に定義される `Performance^I ~interface
］と同じ 5 ~micro秒までの細かさに設定されるべきである。
◎
To mitigate cache and statistical fingerprinting attacks, the resolution of the time estimates returned by the IdleDeadline interface should be set to the same 5 microsecond minimum as the Performance interface defined in [HR-TIME].
</p>
	</section>

</main></div><!-- id="MAIN"／MAIN0 -->

	<section id="acknowledgements" class="appendix">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様に協力された次の方々に：
<span lang="en">
The editors would like to thank the following people for contributing to this specification:
</span></p>

<p lang="en-x-a0">
Sami Kyostila, Alex Clarke, Boris Zbarsky, Marcos Caceres, Jonas Sicking, Robert O'Callahan, David Baron, Todd Reifsteck, Tobin Titus, Elliott Sprehn, Tetsuharu OHZEKI, Lon Ingram, Domenic Denicola, Philippe Le Hegaret and Anne van Kesteren 
</p>
	</section>
