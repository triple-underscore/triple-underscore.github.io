<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Safe passing of structured data（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
.xattr {
	font-family: monospace0, monospace;
	color: var(--K-color);
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);

	return;
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l': // literal
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm': // IDL member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl': // JS internal slot
	text = `[[${key}]]`;
	break;
case 'jI': // JS intrinsic objects
	text = `%${key}%`;
	break;
case 'xA': // 
	text = `[${key}]`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;
	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2024-01-31
trans_update:2022-12-12
source_checked:221208
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/structured-data.html
	abbr_url:HTMLcloning
nav_prev:HTMLcdom
nav_next:HTMLdom
trans_1st_pub:2016-01-28


●●class_map
e:element
a:attr
E:error
xA:xattr
sl:js-slot
js:js-other
jA:abstract
jC:js-class
jI:js-intrinsic
jv:js-value
jp:js-property
t:type

●●tag_map
I:code
m:code
E:code
c:code
sl:span
js:span
jA:span
jC:code
jI:code
jv:code
jp:code
xA:code
V:var
t:var
i:i
cite:cite

●●original_id_map


●●link_map



	●idl
E.RangeError:~TC39#sec-native-error-types-used-in-this-standard-rangeerror
DOMException:~WEBIDL#idl-DOMException
xA.Serializable:#serializable
xA.Transferable:#transferable

I.MessagePort:~HTMLcomms#messageport
I.SharedArrayBuffer:~TC39#sec-sharedarraybuffer-objects
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope

m.broadcastChannel.postMessage:~HTMLcomms#dom-broadcastchannel-postmessage
m.history.pushState:~WINDOW#dom-history-pushstate
m.history.replaceState:~WINDOW#dom-history-replacestate
m.history.state:~WINDOW#dom-history-state
m.lastModified:~FILEAPI#dfn-lastModified
m.messagePort.postMessage:~HTMLcomms#dom-messageport-postmessage
m.name:~FILEAPI#dfn-name
m.window.postMessage:~HTMLcomms#dom-window-postmessage
m.structuredClone:#dom-structuredclone
m.transfer:~HTMLcomms#dom-structuredserializeoptions-transfer

jA.Get:~TC39#sec-get-o-p
jA.StructuredDeserialize:#structureddeserialize
jA.StructuredDeserializeWithTransfer:#structureddeserializewithtransfer
StructuredSerializeInternal
jA.StructuredSerializeInternal:#structuredserializeinternal
jA.StructuredSerialize:#structuredserialize
jA.StructuredSerializeForStorage:#structuredserializeforstorage
jA.StructuredSerializeWithTransfer:#structuredserializewithtransfer
jA.EnumerableOwnProperties:~TC39#sec-enumerableownpropertynames
jA.IsArrayBufferViewOutOfBounds:https://tc39.es/proposal-resizablearraybuffer/#sec-isarraybufferviewoutofbounds

sl.Detached:#detached

転送-可能:#transferable-objects
転送-手続き:#transfer-steps
転送-受信-時の手続き:#transfer-receiving-steps
直列化-可能:#serializable-objects
直列化~手続き:#serialization-steps
下位-直列化:#sub-serialization
下位-逆直列化:#sub-deserialization
逆直列化~手続き:#deserialization-steps

E.DataCloneError:~WEBIDL#datacloneerror

jA.ArrayCreate:~TC39#sec-arraycreate
jA.CopyDataBlockBytes:~TC39#sec-copydatablockbytes
jA.CreateByteDataBlock:~TC39#sec-createbytedatablock
jA.CreateDataProperty:~TC39#sec-createdataproperty
jA.DetachArrayBuffer:~TC39#sec-detacharraybuffer
jA.HasOwnProperty:~TC39#sec-hasownproperty
jA.IsCallable:~TC39#sec-iscallable
jA.IsDataDescriptor:~TC39#sec-isdatadescriptor
jA.IsDetachedBuffer:~TC39#sec-isdetachedbuffer
jA.IsSharedArrayBuffer:~TC39#sec-issharedarraybuffer
jA.OrdinaryObjectCreate:~TC39#sec-objectcreate
jA.OrdinaryDefineOwnProperty:~TC39#sec-ordinarydefineownproperty
jA.OrdinaryGetOwnProperty:~TC39#sec-ordinarygetownproperty
jA.ToString:~TC39#sec-tostring

jI.Array.prototype:~TC39#sec-properties-of-the-array-prototype-object
jI.Error.prototype:~TC39#sec-properties-of-the-error-prototype-object
jI.EvalError.prototype:~HTMLdep#evalerror.prototype
jI.Object.prototype:~TC39#sec-properties-of-the-object-prototype-object
jI.RangeError.prototype:~HTMLdep#rangeerror.prototype
jI.ReferenceError.prototype:~HTMLdep#referenceerror.prototype
jI.SyntaxError.prototype:~HTMLdep#syntaxerror.prototype
jI.TypeError.prototype:~HTMLdep#typeerror.prototype
jI.URIError.prototype:~HTMLdep#urierror.prototype

js.~List:~TC39#sec-list-and-record-specification-type
js.~Record:~TC39#sec-list-and-record-specification-type
js.~PropertyDescriptor:~TC39#sec-property-descriptor-specification-type

~realm:~TC39#sec-code-realms
~agent:~TC39#sec-agents
~agent~cluster:~TC39#sec-agent-clusters
~surrounding~agent:~TC39#surrounding-agent
変異-不能な~prototype~exotic~obj:~TC39#immutable-prototype-exotic-object
完了~Record:~TC39#sec-completion-record-specification-type

jA.Type:~TC39#sec-ecmascript-data-types-and-values
	[JAVASCRIPT]:references.html#refsJAVASCRIPT


付加する:~INFRA#list-append
~list:~INFRA#list
~map:~INFRA#ordered-map
	~EACH:~INFRA#list-iterate
	~NEQ ε:~INFRA#map-exists
	~SET:~INFRA#map-set

~JS値への変換:~WEBIDLjs#js-type-mapping
拡張d属性:~WEBIDL#dfn-extended-attribute
~platform~obj:~WEBIDL#dfn-platform-object
首~interface:~WEBIDLjs#dfn-primary-interface
公開されて:~WEBIDLjs#dfn-exposed

直列形の状態:~HTMLnav#serialized-state
~session履歴~entry:~HTMLnav#session-history-entry
搬送-済み:~HTMLcomms#has-been-shipped

入口~某:~WAPI#concept-entry-everything
現任な某:~WAPI#concept-incumbent-everything
関連な~realm:~WAPI#concept-relevant-realm
~callbackを走らすために準備する:~WAPI#prepare-to-run-a-callback
~scriptを走らすために準備する:~WAPI#prepare-to-run-script
~event~loop:~WAPI#event-loop
~task:~WAPI#concept-task
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability
現在の設定群~obj:~WAPI#current-settings-object

~snapshot状態:~FILEAPI#snapshot-state

●●words_table1


Foo:<var>Foo</var>


●●words_table

	●処理
process::::プロセス
同期して:synchronousに:~
複製した:copied:~
添付-:attach::~

	手続き:set of steps
	一連の段からなる
	新たな:new empty
	新たな:empty
	てはいない所:Call sites that are not
	~callする所:call site
	渡す:pass
	~clone法:cloning

	●変数
ArrayBuffer:
BestFriend:
name:
保持体:holder::~::ホルダ
宛先:target::~

	%深いか:deep
	%memory:memory
	%~agent~cluster:agentCluster
	%~buffer直列形:bufferSerialized
	%~dataの複製:dataCopy
	%~data保持体:dataHolder
	%~entry:entry
	%~interface名:interfaceName
	%~interface:-
	%~key:key
	%~key群:-
	%~message:message
	%~message記述子:messageDesc
	%~realm:realm
	%~size:size
	%~storage用か:forStorage
	%下位-値:subValue
	%下位-直列形:subSerialized
	%値:value
	%値~message記述子:valueMessageDesc
	%値~長さ:valueLen
	%値~長さ記述子:valueLenDescriptor
	%入力~値:inputValue
	%出力~prototype:outputProto
	%出力~値:outputValue
	%名前:name
	%型~文字列:typeString
	%宛先~realm:targetRealm
	%直列形:serialized
	%直列形の~key:serializedKey
	%直列形の値:serializedValue
	%結果:result
	%複製した~entry:copiedEntry
	%複製した~list:copiedList
	%転送-~data保持体:transferDataHolder
	%転送-~data保持体~群:transferDataHolders
	%転送-~list:transferList
	%転送-を伴う直列化-結果:serializeWithTransferResult
	%転送-済み値~list:transferredValues
	%転送対象:transferable
	%逆直列化-~record:deserializeRecord
	%逆直列形:deserialized
	%逆直列形の~ArrayBuffer:deserializedArrayBuffer
	%逆直列形の~entry:deserializedEntry
	%直列化~手続き:-
	%逆直列化~手続き:-
	%転送-手続き:-
	%転送-受信-時の手続き:-

	●IDL／JS／data型
List:
Record:
PropertyDescriptor::::プロパティ記述子
mix-in:
	mixed-in-to
exotic:
	~exotic性:exoticness
agent:
surrounding:
Record:
prototype:
boolean:
入口:entry::~
accessor::::アクセサ
首:primary::~
内包-:include::~
	access可能:accessible
	変異-不能:immutable

	●有構造~clone
	clone可能:cloneable
深い:deep::~
某:〜
現任:incumbent:~
切離す:detachする:切り離す
切離され:detachされ:切り離され
転送対象:transferable::~
転送ng:transferring::転送
	転送-~list:transferList:
転送処理:transferral::~
	直列化できない:un-serializable
直列形:serialized::~::シリアル形
直列形の:serialized::~::シリアル形の
逆直列化-:deserialize::~::逆シリアル化
逆直列化:deserialization::~::逆シリアル化
逆直列形:deserialized::~::逆シリアル形
逆直列形の:deserialized::~::逆シリアル形の

不可逆:irreversible:~
循環参照:cycle:~
	参照を循環させる:create circular reference
冪等:idempotent:~
所有権:ownership:~
対称:symmetric:~
	very symmetric
復旧-:restore:~
持続化-:persist:~
割振る:allocateする:割り振る
割振ろう:allocateしよう:割り振ろう
割振り:allocation:割り振り

	●仕様
高価:expensive:~
仕事:job:~
付随-:accompany:~
防ぐ:preventする:~
見越され:anticipateされ:~
関心ng:interesting:関心事になる
自立的:standalone:~

	要注意:It’s important to realize
	specialization
	による通常の用-法:how it is used normally by
	導入するとき:introduction
	し得ない:possible
	委ねられ:up to
	あるとするなら、:hypothetical
	表-
	課題
	委ねられ
	とする:say
	無為:not make sense
	およそ〜ないであろうunlikely
	ことになるであろう:would likely
	~~実際には:really a
	進捗-中:in-progress
	方が，上手く~~働く:better served
	総称される:collectively 〜 known as
	注目すべき:notable

	●未分類（動詞
broadcast::::ブロードキャスト
搬送-:ship::~
重複:duplicate:~
保存-:save:~
給-:supply:~
disk::::ディスク
filesystem::::ファイルシステム
	組みで:pair
部位:portion:~
不定:indefinite:~
循環:circular:~
持続的:persistent:~
	持続的に:persistent manner で

	初期化されていない:uninitialized
	ε:uninitialized value
	渡し方
	現れ:appear
	知られ
	越えて
	見られ
	~~復元:reified-back
	付与され:decorated
	列:sequence
	とる:take
	anything
	-:we
	片:piece
	なる:become
	新規の:fresh
	~~期間:amount of time
	から離れ:leave

	●指示語
	前もって:beforehand
	以前に:previously
	複数:multi-
	当の:in question／
	他にも:any
	〜以降:and subsequent
	何らか
	何も
	何を
	する側:sites
	側
	一部:part of
	事前に:ahead of time
	以外
	し直す:again
	内
	場合
	対応-
	属する
	現時点では:As of this time
	時点
	~~最終的:final
	次を
	自身
	種
	節
	限り
	間
	類の

	●訳注
	右辺
	否定
	比較式
	記され
	記号
	表記
	明らか
	大雑把に言えば


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ Safe passing of structured data</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTML — 有構造データの安全な渡し方</h1>
	</hgroup>
</header>

<hr>

<main id="MAIN" hidden>

		<section id="safe-passing-of-structured-data">
<h3 title="Safe passing of structured data">2.7. 有構造~dataの安全な渡し方</h3>


<p id="structuredclone">
<a id="structured-clone"></a>
~JS~obj (1) を`~realm$ 境界をまたがって渡すことを~supportするため、
この仕様は，~objを［
直列化する／逆直列化する
］(2) ための基盤を以下に定義する。
ここで (1), (2) は
⇒＃
(1) `~platform~obj$も含む ／
(2) 一部の事例では、下層の~dataを複製する代わりに転送することも含む
◎
To support passing JavaScript objects, including platform objects, across realm boundaries, this specification defines the following infrastructure for serializing and deserializing objects, including in some cases transferring the underlying data instead of copying it.＼
</p>

<p>
この［
直列化／逆直列化
］処理nは、
“有構造~clone法” と総称される
— ほとんどの~APIは、
直列化と逆直列化において，別々な手続きを遂行するが。
（注目すべき例外として， `structuredClone()$m ~methodがある。）
◎
Collectively this serialization/deserialization process is known as "structured cloning", although most APIs perform separate serialization and deserialization steps. (With the notable exception being the structuredClone() method.)
</p>

<p>
この節では、
~JS仕様による，各種用語と表記規約を利用する。
`JAVASCRIPT$r
◎
This section uses the terminology and typographic conventions from the JavaScript specification. [JAVASCRIPT]
</p>

<ul class="trans-note">
	<li>
~algo内に現れる抽象-演算のうち［
`完了~Record$を返すよう定義されたもの
］には、
<a href="~TC39#sec-returnifabrupt-shorthands">"~NOABRUPT" や "~ABRUPT" を接頭する記法</a>
が利用される
（これは、
完了~Recordで包装された［
値／~error
］を透過的に取扱うための記法であり，
"~ABRUPT" は 例外が投出され得ること／
"~NOABRUPT" は 例外は決して投出されないことを表す）。
</li>
	<li>
`~Foo^sl という表記は、
名前 "~Foo" の［
内部~slot／内部~method／~field
］を表す
（~scriptには直に公開されない内部~dataを保持する）。
</li>
</ul>

			<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

<p>
上述に加えて、
この訳では，次のような略記法を導入する：
</p>
<ul>
	<li>
“%O . `~Foo^sl”
のような表記は、［
~JS~obj ／ ~JS`~Record$js
］ %O の 名前 `~Foo^l の［［
内部~slot または 内部~method
］／ ~field
］を表すとする。
%O が明らかな所では、
単に “`~Foo^sl” のようにも記される。
</li>
	<li>
代入の右辺や比較式に現れる
“%O . `~Foo^sl”
のような表記は、
~Foo［
内部~slot ／ ~field
］の値を表す。
同様に，
“%O . `~Foo^sl(…)”
は、
~Foo 内部~methodを~callした結果の値を表す。
</li>
	<li>
“%O . `~Foo^sl ~NEQ ε”
という表記は、
%O には，名前 `~Foo^l の［
内部~slot／内部~method／~field
］が在ることを意味する。
“%O . `~Foo^sl ~EQ ε”
はその否定（無いこと）を意味する。
</li>
</ul>

◎表記記号

			</section>
			<section id="serializable-objects">
<h4 title="Serializable objects">2.7.1. 直列化-可能な~obj</h4>

<p>
`直列化-可能$な~objは、
所与の`~realm$が何であれ，それに独立な仕方で直列化され, 後に逆直列化されることを~supportする
【逆直列化（ deserialize ） — 字義通り，直列化された結果から元に復元すること】
。
これにより、
それを~diskに格納して後に復旧したり，`~agent$, あるいは`~agent~cluster$の境界まで越えて~cloneすることも許容される。
◎
Serializable objects support being serialized, and later deserialized, in a way that is independent of any given realm. This allows them to be stored on disk and later restored, or cloned across agent and even agent cluster boundaries.
</p>

<p>
~objには`直列化-可能$でないものもあり、
`直列化-可能$なものでも，そのすべての側面が直列化-時に保全されるとは限らない。
◎
Not all objects are serializable objects, and not all aspects of objects that are serializable objects are necessarily preserved when they are serialized.
</p>

<p>
`~platform~obj$は、
その`首~interface$に
`Serializable@xA
~IDL`拡張d属性$が付与されているならば、
`直列化-可能$である。
そのような~interfaceは、
次に挙げる~algoも定義しなければナラナイ
（括弧内は入力）：
◎
Platform objects can be serializable objects if their primary interface is decorated with the [Serializable] IDL extended attribute. Such interfaces must also define the following algorithms:
</p>
<dl class="def-list">
	<dt>
`直列化~手続き@
◎
serialization steps,＼
</dt>
	<dd>
所与の
( `~platform~obj$ %値, `~Record$js %直列形, ~boolean %~storage用か )
に対し，［
%値 内の~dataを %直列形 の各~fieldの中に直列化する
］ための手続き。
%直列形 の中に直列化される結果の~dataは、
どの`~realm$からも独立でなければナラナイ。
◎
taking a platform object value, a Record serialized, and a boolean forStorage
◎
A set of steps that serializes the data in value into fields of serialized. The resulting data serialized into serialized must be independent of any realm.
</dd>
	<dd>
この手続きは、
直列化がアリでない場合は，例外を投出してもヨイ／し得る。
◎
These steps may throw an exception if serialization is not possible.
</dd>
	<dd>
この手続きは、
`下位-直列化$を遂行して，入子な~data構造を直列化してもヨイ／し得る。
そこでは【！They】， `StructuredSerialize$jA を直に~callするベキでない
— そうすると、
重要な %memory 引数が省略されることになるので。
◎
These steps may perform a sub-serialization to serialize nested data structures. They should not call StructuredSerialize directly, as doing so will omit the important memory argument.
</dd>
	<dd>
この手続きを導入するときは、
~algoに関連な場合を除き，引数 %~storage用か は省略するベキである。
◎
The introduction of these steps should omit mention of the forStorage argument if it is not relevant to the algorithm.
</dd>

	<dt>
`逆直列化~手続き@
◎
deserialization steps,＼
</dt>
	<dd>
所与の
( `~Record$js %直列形, `~platform~obj$ %値, `~realm$ %宛先~realm )
に対し，［
%値 を適切に設定しておくために，
%直列形 内の~dataを逆直列化する
］ための手続き。
%値 は，新たな［
当の`~platform~obj$の型の~instance
］であり、
その内部~dataは何も設定されてないものになる
— それを設定しておくのが、
この手続きの仕事である。
◎
taking a Record serialized, a platform object value, and a realm targetRealm
◎
A set of steps that deserializes the data in serialized, using it to set up value as appropriate. value will be a newly-created instance of the platform object type in question, with none of its internal data set up; setting that up is the job of these steps.
</dd>
	<dd>
この手続きは、
逆直列化がアリでない場合は，例外を投出してもヨイ／し得る。
◎
These steps may throw an exception if deserialization is not possible.
</dd>
	<dd>
この手続きは、
`下位-逆直列化$を遂行して，入子な~data構造を逆直列化してもヨイ／し得る。
そこでは【！They】， `StructuredDeserialize$jA を直に~callするベキでない
— そうすると、
重要な［
%宛先~realm, %memory
］引数が省略されることになるので。
◎
These steps may perform a sub-deserialization to deserialize nested data structures. They should not call StructuredDeserialize directly, as doing so will omit the important targetRealm and memory arguments.
</dd>
</dl>

<p>
これらの手続きにより どの~dataを［
直列化するか／逆直列化するか
］を決定するのは、
個々の~platform~objの定義に委ねられる。
この 2 つの手続きは、
概して対称になる。
◎
It is up to the definition of individual platform objects to determine what data is serialized and deserialized by these steps. Typically the steps are very symmetric.
</p>

<p>
`Serializable$xA 拡張d属性は
⇒＃
引数をとってはナラナイ。
~interface以外に現れてはナラナイ。
~interfaceに現れるのは一度限りでなければナラナイ。
◎
The [Serializable] extended attribute must take no arguments, and must only appear on an interface. It must not appear more than once on an interface.
</p>

<p>
所与の`~platform~obj$に対し，その［
直列化／逆直列化
］処理nにおいて考慮されるのは、
~objの`首~interface$に限られる。
したがって，~interfaceが継承を孕むように定義されている場合、
継承~連鎖を成す各 
`Serializable$xA 注釈-付き~interfaceは，自立的な［
`直列化~手続き$, `逆直列化~手続き$
］を
— 継承した~interfaceから来ている重要な~dataがあれば それも織り込むように —
定義する必要がある。
◎
For a given platform object, only the object's primary interface is considered during the (de)serialization process. Thus, if inheritance is involved in defining the interface, each [Serializable]-annotated interface in the inheritance chain needs to define standalone serialization steps and deserialization steps, including taking into account any important data that might come from inherited interfaces.
</p>

<div class="example">
<p>
ある~platform~obj `Person^I を定義していて，
それには次の 2 つの~data片が結付けられるとする：
◎
Let's say we were defining a platform object Person, which had associated with it two pieces of associated data:
</p>

<ul>
	<li>
`~name^i ：文字列を値にとる
◎
a name value, which is a string; and
</li>
	<li>
`~BestFriend^i：別の `Person^c ~instanceまたは ~NULL を値にとる
◎
a best friend value, which is either another Person instance or null.
</li>
</ul>

<p>
このとき， `Person^I ~instanceを`直列化-可能$になるように定義するためには、
`Person^I ~interfaceに `Serializable$xA `拡張d属性$を注釈して，付随する~algoを次のように定義する：
◎
We could then define Person instances to be serializable objects by annotating the Person interface with the [Serializable] extended attribute, and defining the following accompanying algorithms:
</p>

<dl>
	<dt>
`直列化~手続き$
◎
serialization steps
</dt>
	<dd>
		<ol>
			<li>
%直列形 . `Name^sl ~SET %値 の `~name^i 値
◎
Set serialized.[[Name]] to value's associated name value.
</li>
			<li>
%直列形 . `BestFriend^sl ~SET %値 の `~BestFriend^i 値の`下位-直列化$
◎
Let serializedBestFriend be the sub-serialization of value's associated best friend value.
◎
Set serialized.[[BestFriend]] to serializedBestFriend.
</li>
		</ol>
	</dd>

	<dt>
`逆直列化~手続き$
◎
deserialization steps
</dt>
	<dd>
		<ol>
			<li>
%値 の `~name^i 値 ~SET %直列形 . `Name^sl
◎
Set value's associated name value to serialized.[[Name]].
</li>
			<li>
%値 の `~BestFriend^i ~SET %直列形 . `BestFriend^sl の`下位-逆直列化$
◎
Let deserializedBestFriend be the sub-deserialization of serialized.[[BestFriend]].
◎
Set value's associated best friend value to deserializedBestFriend.
</li>
		</ol>
	</dd>
</dl>
</div>

<p>
~JS仕様にて定義される各種~objは、
`StructuredSerialize$jA 抽象-演算により直に取扱われる。
◎
Objects defined in the JavaScript specification are handled by the StructuredSerialize abstract operation directly.
</p>

<p class="note">注記：
<a id="cloneable-objects"></a>
元々，この仕様は、
ある`~realm$から別の~realmへ~cloneできる
“~clone可能な~obj” の概念を定義していた。
しかしながら，ある種のより複階的な状況~下における挙動をより良く指定するため、
直列化と逆直列化を明示的に与えるよう，この~modelは更新された。
◎
Originally, this specification defined the concept of "cloneable objects", which could be cloned from one realm to another. However, to better specify the behavior of certain more complex situations, the model was updated to make the serialization and deserialization explicit.
</p>

			</section>
			<section id="transferable-objects">
<h4 title="Transferable objects">2.7.2. 転送-可能な~obj</h4>

<p>
`転送-可能$な~objは、
`~agent$間をまたぐ転送ngを~supportする。
~obj %O の転送ngは、
実質的に，
%O と同じ下層の~dataを参照するような~objを作成し直す一方で，転送-側から %O を切離すことである。
これは、
高価な資源の所有権を転送するときに，有用になる。
~objには`転送-可能$でないものもあり、
`転送-可能$なものでも そのすべての側面が転送-時に保全されるとは限らない。
◎
Transferable objects support being transferred across agents. Transferring is effectively recreating the object while sharing a reference to the underlying data and then detaching the object being transferred. This is useful to transfer ownership of expensive resources. Not all objects are transferable objects and not all aspects of objects that are transferable objects are necessarily preserved when transferred.
</p>

<p class="note">注記：
転送ngは、
不可逆であり，冪等でない演算である。
~objを転送した側は、
それを再び［
転送する／利用する
］ことはできなくなる。
◎
Transferring is an irreversible and non-idempotent operation. Once an object has been transferred, it cannot be transferred, or indeed used, again.
</p>


<p>
`~platform~obj$は、
その`首~interface$に
`Transferable@xA
~IDL`拡張d属性$が付与されているならば、
`転送-可能$である。
そのような~interfaceは，次の~algoも定義しなければナラナイ
（括弧内は入力）：
◎
Platform objects can be transferable objects if their primary interface is decorated with the [Transferable] IDL extended attribute. Such interfaces must also define the following algorithms:
</p>

<dl>
	<dt>
`転送-手続き@( `~platform~obj$ %値, `~Record$js %~data保持体 )
◎
transfer steps, taking a platform object value and a Record dataHolder
</dt>
	<dd>
%値 内の~dataを %~data保持体 の各~fieldの中に転送するための手続き。
%~data保持体 内に保持される結果の~dataは、
どの`~realm$からも独立でなければナラナイ。
◎
A set of steps that transfers the data in value into fields of dataHolder. The resulting data held in dataHolder must be independent of any realm.
</dd>
	<dd>
この手続きは、
転送処理がアリでない場合は，例外を投出してもヨイ／し得る。
◎
These steps may throw an exception if transferral is not possible.
</dd>

	<dt>
`転送-受信-時の手続き@( `~Record$js %~data保持体, `~platform~obj$ %値 )
◎
transfer-receiving steps, taking a Record dataHolder and a platform object value
</dt>
	<dd>
%~data保持体 内の~dataを受信するための手続き。
%値 は，新たな［
当の`~platform~obj$の型の~instance
］であり、
その内部~dataは何も設定されてないものになる
— それを設定しておくのが、
この手続きの仕事である。
◎
A set of steps that receives the data in dataHolder, using it to set up value as appropriate. value will be a newly-created instance of the platform object type in question, with none of its internal data set up; setting that up is the job of these steps.
</dd>
	<dd>
この手続きは、
転送-を受信し得ない場合は，例外を投出してもヨイ／し得る。
◎
These steps may throw an exception if it is not possible to receive the transfer.
</dd>
</dl>


<p>
これらの手続きにより どの~dataを転送するか決定するのは、
個々の~platform~objの定義に委ねられる。
この 2 つの手続きは、
概して対称になる。
◎
It is up to the definition of individual platform objects to determine what data is transferred by these steps. Typically the steps are very symmetric.
</p>

<p>
`Transferable$xA 拡張d属性は
⇒＃
引数をとってはナラナイ。
~interface以外に現れてはナラナイ。
~interfaceに現れるのは一度限りでなければナラナイ。
◎
The [Transferable] extended attribute must take no arguments, and must only appear on an interface. It must not appear more than once on an interface.
</p>

<p>
所与の`~platform~obj$に対し，その転送ng処理nにおいて考慮されるのは、
~objの`首~interface$に限られる。
したがって，~interfaceが継承が孕むように定義されている場合、
継承~連鎖を成す各 `Transferable$xA 注釈-付き~interfaceは，自立的な［
`転送-手続き$, `転送-受信-時の手続き$
］を
— ［
継承した~interfaceから来ている~dataのうち重要なもの
］があれば，それも織り込むように —
定義する必要がある。
◎
For a given platform object, only the object's primary interface is considered during the transferring process. Thus, if inheritance is involved in defining the interface, each [Transferable]-annotated interface in the inheritance chain needs to define standalone transfer steps and transfer-receiving steps, including taking into account any important data that might come from inherited interfaces.
</p>

<p>
`~platform~obj$のうち，`転送-可能$なものは、
`Detached@sl
内部~slotを持つ。
これは、［
転送された~platform~objは，再度~転送され得ない
］ことを確保するために利用される。
◎
Platform objects that are transferable objects have a [[Detached]] internal slot. This is used to ensure that once a platform object has been transferred, it cannot be transferred again.
</p>

<p>
~JS仕様にて定義される各種~objは、
`StructuredSerializeWithTransfer$jA
抽象-演算により直に取扱われる。
◎
Objects defined in the JavaScript specification are handled by the StructuredSerializeWithTransfer abstract operation directly.
</p>

			</section>
			<section id="structuredserializeinternal">
<h4 title="StructuredSerializeInternal ( value, forStorage [ , memory ] )">2.7.3. `StructuredSerializeInternal^jA ( %値, %~storage用か [ , %memory ] )</h4>

<p>
`StructuredSerializeInternal$jA 抽象-演算は、
~JS値（ %値 ）を入力にとり，それを`~realm$から独立な形に直列化する
— ここでは `~Record$jsとして表現される。
この直列化された形は、
後で［
異なる~realm内で，新たな~JS値に逆直列化する
］ときに必要yなすべての情報を伴う。
◎
The StructuredSerializeInternal abstract operation takes as input a JavaScript value value and serializes it to a realm-independent form, represented here as a Record. This serialized form has all the information necessary to later deserialize into a new JavaScript value in a different realm.
</p>

<p>
この処理nは、
例外を投出し得る
— 例えば、
`直列化-可能$でない~objを直列化しようと試行したとき。
◎
This process can throw an exception, for example when trying to serialize un-serializable objects.
</p>
<ol>
	<li>
<p>
~IF［
%memory は給されてない
］
⇒
%memory ~LET 新たな`~map$
◎
If memory was not supplied, let memory be an empty map.
</p>

<p class="note">注記：
%memory ~mapの目的は、
~objが重ねて直列化されるのを避けることにある。
これには、
循環参照を保全して，~graphにおける~objの重複を識別することが必要になる。
◎
The purpose of the memory map is to avoid serializing objects twice. This ends up preserving cycles and the identity of duplicate objects in graphs.
</p>
	</li>
	<li>
~IF［
%memory[ %値 ] ~NEQ ε
］
⇒
~RET %memory[ %値 ]
◎
If memory[value] exists, then return memory[value].
</li>
	<li>
%深いか ~LET ~F
◎
Let deep be false.
</li>
	<li>
~IF［
`Type$jA( %値 ) ~IN {
`Undefined^jC,
`Null^jC,
`Boolean^jC,
`Number^jC,
`BigInt^jC,
`String^jC
}
］
⇒
~RET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `primitive^l,
`Value^sl ~SET %値
◎
If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String, then return { [[Type]]: "primitive", [[Value]]: value }.
</li>
	<li>
~IF［
`Type$jA( %値 ) ~EQ `Symbol^jC
］
⇒
~THROW `DataCloneError$E
◎
If Type(value) is Symbol, then throw a "DataCloneError" DOMException.
</li>
	<li>
%直列形 ~LET ε
◎
Let serialized be an uninitialized value.
</li>
	<li>
~IF［
%値 . `BooleanData^sl ~NEQ ε
］
⇒
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `Boolean^l,
`BooleanData^sl ~SET %値 . `BooleanData^sl
◎
If value has a [[BooleanData]] internal slot, then set serialized to { [[Type]]: "Boolean", [[BooleanData]]: value.[[BooleanData]] }.
</li>
	<li>
~ELIF［
%値 . `NumberData^sl ~NEQ ε
］
⇒
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `Number^l,
`NumberData^sl ~SET %値 . `NumberData^s
◎
Otherwise, if value has a [[NumberData]] internal slot, then set serialized to { [[Type]]: "Number", [[NumberData]]: value.[[NumberData]] }.
</li>
	<li>
~ELIF［
%値 . `BigIntData^sl ~NEQ ε
］
⇒
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `BigInt^l,
`BigIntData^sl ~SET %値 . `BigIntData^sl
◎
Otherwise, if value has a [[BigIntData]] internal slot, then set serialized to { [[Type]]: "BigInt", [[BigIntData]]: value.[[BigIntData]] }.
</li>
	<li>
~ELIF［
%値 . `StringData^sl ~NEQ ε
］
⇒
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `String^l,
`StringData^sl ~SET %値 . `StringData^sl
◎
Otherwise, if value has a [[StringData]] internal slot, then set serialized to { [[Type]]: "String", [[StringData]]: value.[[StringData]] }.
</li>
	<li>
~ELIF［
%値 . `DateValue^sl ~NEQ ε
］
⇒
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `Date^l,
`DateValue^sl ~SET %値 . `DateValue^sl
◎
Otherwise, if value has a [[DateValue]] internal slot, then set serialized to { [[Type]]: "Date", [[DateValue]]: value.[[DateValue]] }.
</li>
	<li>
~ELIF［
%値 . `RegExpMatcher^sl ~NEQ ε
］
⇒
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `RegExp^l,
`RegExpMatcher^sl ~SET %値 . `RegExpMatcher^sl,
`OriginalSource^sl ~SET %値 . `OriginalSource^sl,
`OriginalFlags^sl ~SET %値 . `OriginalFlags^sl
◎
Otherwise, if value has a [[RegExpMatcher]] internal slot, then set serialized to { [[Type]]: "RegExp", [[RegExpMatcher]]: value.[[RegExpMatcher]], [[OriginalSource]]: value.[[OriginalSource]], [[OriginalFlags]]: value.[[OriginalFlags]] }.
</li>
	<li>
<p>
~ELIF［
%値 . `ArrayBufferData^sl ~NEQ ε
］：
◎
Otherwise, if value has an [[ArrayBufferData]] internal slot, then:
</p>
		<ol>
			<li>
<p>
~IF［
`IsSharedArrayBuffer$jA( %値 ) ~EQ ~T
］：
◎
If IsSharedArrayBuffer(value) is true, then:
</p>
				<ol>
					<li>
<p>
~IF［
`現在の設定群~obj$の`非同一-生成元~能力は隔離されるか？$enV ~EQ ~F
］
⇒
~THROW `DataCloneError$E
◎
If the current settings object's cross-origin isolated capability is false, then throw a "DataCloneError" DOMException.
</p>

<p class="note">注記：
この検査は、
直列化するときに限り必要になる
（逆直列化するときは必要ない）
— `非同一-生成元~能力は隔離されるか？$enVの結果は、
時間~越しに変化することはなく，
`SharedArrayBuffer$I は`~agent~cluster$から離れ得ないので。
◎
This check is only needed when serializing (and not when deserializing) as the cross-origin isolated capability cannot change over time and a SharedArrayBuffer cannot leave an agent cluster.
</p>
					</li>
					<li>
~IF［
%~storage用か ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If forStorage is true, then throw a "DataCloneError" DOMException.
</li>
					<li>
~IF［
%値 . `ArrayBufferMaxByteLength^sl ~NEQ ε
］
⇒
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `GrowableSharedArrayBuffer^l,
`ArrayBufferData^sl ~SET %値 . `ArrayBufferData^sl,
`ArrayBufferByteLengthData^sl ~SET %値 . `ArrayBufferByteLengthData^sl,
`ArrayBufferMaxByteLength^sl ~SET %値 . `ArrayBufferMaxByteLength^sl,
`AgentCluster^sl ~SET `~surrounding~agent$の`~agent~cluster$
◎
If value has an [[ArrayBufferMaxByteLength]] internal slot, then set serialized to { [[Type]]: "GrowableSharedArrayBuffer", [[ArrayBufferData]]: value.[[ArrayBufferData]], [[ArrayBufferByteLengthData]]: value.[[ArrayBufferByteLengthData]], [[ArrayBufferMaxByteLength]]: value.[[ArrayBufferMaxByteLength]], [[AgentCluster]]: the surrounding agent's agent cluster }.
</li>
					<li>
~ELSE
⇒
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `SharedArrayBuffer^l,
`ArrayBufferData^sl ~SET %値 . `ArrayBufferData^sl,
`ArrayBufferByteLength^sl ~SET %値 . `ArrayBufferByteLength^sl,
`AgentCluster^sl ~SET `~surrounding~agent$の`~agent~cluster$
◎
Otherwise, set serialized to { [[Type]]: "SharedArrayBuffer", [[ArrayBufferData]]: value.[[ArrayBufferData]], [[ArrayBufferByteLength]]: value.[[ArrayBufferByteLength]], [[AgentCluster]]: the surrounding agent's agent cluster }.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~IF［
`IsDetachedBuffer$jA( %値 ) ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If IsDetachedBuffer(value) is true, then throw a "DataCloneError" DOMException.
</li>
					<li>
%~size ~LET %値 . `ArrayBufferByteLength^sl
◎
Let size be value.[[ArrayBufferByteLength]].
</li>
					<li>
<p>
%~dataの複製 ~LET
~ABRUPT `CreateByteDataBlock$jA( %~size )
◎
Let dataCopy be ? CreateByteDataBlock(size).
</p>

<p class="note">注記：
これは、
割振りの失敗に際しては `RangeError$E 例外を投出し得る
◎
This can throw a RangeError exception upon allocation failure.
</p>
					</li>
					<li>
`CopyDataBlockBytes$jA( %~dataの複製, 0, %値 . `ArrayBufferData^sl, 0, %~size )
◎
Perform CopyDataBlockBytes(dataCopy, 0, value.[[ArrayBufferData]], 0, size).
</li>
					<li>
~IF［
%値 . `ArrayBufferMaxByteLength^sl ~NEQ ε
］
⇒
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `ResizableArrayBuffer^l,
`ArrayBufferData^sl ~SET %~dataの複製,
`ArrayBufferByteLength^sl ~SET %~size,
`ArrayBufferMaxByteLength^sl ~SET %値 . `ArrayBufferMaxByteLength^sl
◎
If value has an [[ArrayBufferMaxByteLength]] internal slot, then set serialized to { [[Type]]: "ResizableArrayBuffer", [[ArrayBufferData]]: dataCopy, [[ArrayBufferByteLength]]: size, [[ArrayBufferMaxByteLength]]: value.[[ArrayBufferMaxByteLength]] }.
</li>
					<li>
~ELSE
⇒
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `ArrayBuffer^l,
`ArrayBufferData^sl ~SET %~dataの複製,
`ArrayBufferByteLength^sl ~SET %~size
◎
Otherwise, set serialized to { [[Type]]: "ArrayBuffer", [[ArrayBufferData]]: dataCopy, [[ArrayBufferByteLength]]: size }.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%値 . `ViewedArrayBuffer^sl ~NEQ ε
］：
◎
Otherwise, if value has a [[ViewedArrayBuffer]] internal slot, then:
</p>
		<ol>
			<li>
~IF［
`IsArrayBufferViewOutOfBounds$jA( %値 ) ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If IsArrayBufferViewOutOfBounds(value) is true, then throw a "DataCloneError" DOMException.
</li>
			<li>
%~buffer ~LET %値 . `ViewedArrayBuffer^sl
◎
Let buffer be the value of value's [[ViewedArrayBuffer]] internal slot.
</li>
			<li>
%~buffer直列形 ~LET
~ABRUPT `StructuredSerializeInternal$jA( %~buffer, %~storage用か, %memory )
◎
Let bufferSerialized be ? StructuredSerializeInternal(buffer, forStorage, memory).
</li>
			<li>
~Assert：
%~buffer直列形 . `Type^sl ~IN {
`ArrayBuffer^l,
`ResizableArrayBuffer^l,
`SharedArrayBuffer^l,
`GrowableSharedArrayBuffer^l
}
◎
Assert: bufferSerialized.[[Type]] is "ArrayBuffer", "ResizableArrayBuffer", "SharedArrayBuffer", or "GrowableSharedArrayBuffer".
</li>
			<li>
~IF［
%値 . `DataView^sl ~NEQ ε
］
⇒
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `ArrayBufferView^l,
`Constructor^sl ~SET `DataView^l,
`ArrayBufferSerialized^sl ~SET %~buffer直列形,
`ByteLength^sl ~SET %値 . `ByteLength^sl,
`ByteOffset^sl ~SET %値 . `ByteOffset^sl
◎
If value has a [[DataView]] internal slot, then set serialized to { [[Type]]: "ArrayBufferView", [[Constructor]]: "DataView", [[ArrayBufferSerialized]]: bufferSerialized, [[ByteLength]]: value.[[ByteLength]], [[ByteOffset]]: value.[[ByteOffset]] }.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~Assert：
%値 . `TypedArrayName^sl ~NEQ ε
◎
Assert: value has a [[TypedArrayName]] internal slot.
</li>
					<li>
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `ArrayBufferView^l,
`Constructor^sl ~SET %値 . `TypedArrayName^sl,
`ArrayBufferSerialized^sl ~SET %~buffer直列形,
`ByteLength^sl ~SET %値 . `ByteLength^sl,
`ByteOffset^sl ~SET %値 . `ByteOffset^sl,
`ArrayLength^sl ~SET %値 . `ArrayLength^sl
◎
Set serialized to { [[Type]]: "ArrayBufferView", [[Constructor]]: value.[[TypedArrayName]], [[ArrayBufferSerialized]]: bufferSerialized, [[ByteLength]]: value.[[ByteLength]], [[ByteOffset]]: value.[[ByteOffset]], [[ArrayLength]]: value.[[ArrayLength]] }.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%値 . `MapData^sl ~NEQ ε
］：
◎
Otherwise, if value has [[MapData]] internal slot, then:
</p>
		<ol>
			<li>
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `Map^l,
`MapData^sl ~SET 新たな`~List$js
◎
Set serialized to { [[Type]]: "Map", [[MapData]]: a new empty List }.
</li>
			<li>
%深いか ~SET ~T
◎
Set deep to true.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%値 . `SetData^sl ~NEQ ε
］：
◎
Otherwise, if value has [[SetData]] internal slot, then:
</p>
		<ol>
			<li>
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `Set^l,
`SetData^sl ~SET 新たな`~List$js
◎
Set serialized to { [[Type]]: "Set", [[SetData]]: a new empty List }.
</li>
			<li>
%深いか ~SET ~T
◎
Set deep to true.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%値 . `ErrorData^sl ~NEQ ε
］~AND［
%値 は`~platform~obj$でない
］：
◎
Otherwise, if value has an [[ErrorData]] internal slot and value is not a platform object, then:
</p>
		<ol>
			<li>
%名前 ~LET
~ABRUPT `Get$jA( %値, `name^l )
◎
Let name be ? Get(value, "name").
</li>
			<li>
~IF［
%名前 ~NIN { `Error^l, `EvalError^l, `RangeError^l, `ReferenceError^l, `SyntaxError^l, `TypeError^l, `URIError^l }
］
⇒
%名前 ~SET `Error^l
◎
If name is not one of "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", or "URIError", then set name to "Error".
</li>
			<li>
%値~message記述子 ~LET
~ABRUPT %値 . `GetOwnProperty^sl( `message^l )
◎
Let valueMessageDesc be ? value.[[GetOwnProperty]]("message").
</li>
			<li>
%~message ~LET `IsDataDescriptor$jA( %値~message記述子 ) に応じて
⇒＃
~F ならば `undefined^jv ／
~ELSE_ ~ABRUPT `ToString$jA( %値~message記述子 . `Value^sl )
◎
Let message be undefined if IsDataDescriptor(valueMessageDesc) is false, and ? ToString(valueMessageDesc.[[Value]]) otherwise.
</li>
			<li>
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `Error^l,
`Name^sl ~SET %名前,
`Message^sl ~SET %~message
◎
Set serialized to { [[Type]]: "Error", [[Name]]: name, [[Message]]: message }.
</li>
			<li>
<p>
~UAは、
まだ仕様~化されていないが関心ng~data
— 特に， `stack^jp ~propが挙げられる —
が付随しているならば、
それを直列化した表現も %直列形 に添付するベキである
◎
User agents should attach a serialized representation of any interesting accompanying data which are not yet specified, notably the stack property, to serialized.
</p>

<p class="note">
この~dataを指定する進捗-中な作業については、
`Error Stacks^cite 提案 `JSERRORSTACKS$r を見よ。
◎
See the Error Stacks proposal for in-progress work on specifying this data. [JSERRORSTACKS]
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%値 は `Array^jC ~exotic~objである
］：
◎
Otherwise, if value is an Array exotic object, then:
</p>
		<ol>
			<li>
%値~長さ記述子 ~LET
~ABRUPT `OrdinaryGetOwnProperty$jA( %値, `length^l )
◎
Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, "length").
</li>
			<li>
%値~長さ ~LET %値~長さ記述子 . `Value^sl
◎
Let valueLen be valueLenDescriptor.[[Value]].
</li>
			<li>
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `Array^l,
`Length^sl ~SET %値~長さ,
`Properties^sl ~SET 新たな`~List$js
◎
Set serialized to { [[Type]]: "Array", [[Length]]: valueLen, [[Properties]]: a new empty List }.
</li>
			<li>
%深いか ~SET ~T
◎
Set deep to true.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%値 は`直列化-可能$な`~platform~obj$である
］：
◎
Otherwise, if value is a platform object that is a serializable object:
</p>
		<ol>
			<li>
~IF［
%値 . `Detached$sl ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If value has a [[Detached]] internal slot whose value is true, then throw a "DataCloneError" DOMException.
</li>
			<li>
%型~文字列 ~LET %値 の`首~interface$の識別子
◎
Let typeString be the identifier of the primary interface of value.
</li>
			<li>
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET %型~文字列
◎
Set serialized to { [[Type]]: typeString }.
</li>
			<li>
%深いか ~SET ~T
◎
Set deep to true.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%値 は`~platform~obj$である
］
⇒
~THROW `DataCloneError$E
◎
Otherwise, if value is a platform object, then throw a "DataCloneError" DOMException.
</li>
	<li>
~ELIF［
`IsCallable$jA( %値 ) ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
Otherwise, if IsCallable(value) is true, then throw a "DataCloneError" DOMException.
</li>
	<li>
<p>
~ELIF［
%値 は［
`Prototype^sl, `Extensible^sl
］以外の内部~slotを持つ
］
⇒
~THROW `DataCloneError$E
◎
Otherwise, if value has any internal slot other than [[Prototype]] or [[Extensible]], then throw a "DataCloneError" DOMException.
</p>

<p class="example">
一例として、［
`PromiseState^sl ／ `WeakMapData^sl
］内部~slot。
◎
For instance, a [[PromiseState]] or [[WeakMapData]] internal slot.
</p>
	</li>
	<li>
<p>
~ELIF［
%値 は~exotic~objである
］~AND［
どの`~realm$ %~realm に対しても［
%値 ~NEQ ［
%~realm に結付けられた `Object.prototype$jI 内在的~obj
］］］
⇒
~THROW `DataCloneError$E
◎
Otherwise, if value is an exotic object and value is not the %Object.prototype% intrinsic object associated with any realm, then throw a "DataCloneError" DOMException.
</p>

<p class="example">
一例として、
`proxy^en ~obj。
【~JSの `Proxy^jC ~obj？】
◎
For instance, a proxy object.
</p>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%直列形 ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET `Object^l,
`Properties^sl ~SET 新たな`~List$js
◎
Set serialized to { [[Type]]: "Object", [[Properties]]: a new empty List }.
</li>
			<li>
%深いか ~SET ~T
◎
Set deep to true.
</li>
		</ol>

<p class="note">注記：
`Object.prototype$jI は、
この段~以降を介して取扱われることになる。
その結果、
その~exotic性は無視され，逆直列化の後には空な~objになる
（それは、
`変異-不能な~prototype~exotic~obj$ではない）。
◎
%Object.prototype% will end up being handled via this step and subsequent steps. The end result is that its exoticness is ignored, and after deserialization the result will be an empty object (not an immutable prototype exotic object).
</p>

	</li>
	<li>
%memory[ %値 ] ~SET %直列形
◎
Set memory[value] to serialized.
</li>
	<li>
<p>
~IF［
%深いか ~EQ ~T
］：
◎
If deep is true, then:
</p>
		<ol>
			<li>
<p>
~IF［
%値 . `MapData^sl ~NEQ ε
］：
◎
If value has a [[MapData]] internal slot, then:
</p>
				<ol>
					<li>
%複製した~list ~LET 新たな`~List$js
◎
Let copiedList be a new empty List.
</li>
					<li>
<p>
%値 . `MapData^sl を成す
~EACH( `~Record$js %~entry )
に対し：
◎
For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]:
</p>
						<ol>
							<li>
%複製した~entry ~LET 新たな`~Record$js
— その
⇒＃
`Key^sl ~SET %~entry . `Key^sl,
`Value^sl ~SET %~entry . `Value^sl
◎
Let copiedEntry be a new Record { [[Key]]: entry.[[Key]], [[Value]]: entry.[[Value]] }.
</li>
							<li>
~IF［
%複製した~entry . `Key^sl ~NEQ 特殊~値 `empty^i
］
⇒
%複製した~list に %複製した~entry を`付加する$
◎
If copiedEntry.[[Key]] is not the special value empty, append copiedEntry to copiedList.
</li>
						</ol>
					</li>
					<li>
<p>
%複製した~list を成す
~EACH( `~Record$js %~entry )
に対し：
◎
For each Record { [[Key]], [[Value]] } entry of copiedList:
</p>
						<ol>
							<li>
%直列形の~key ~LET
~ABRUPT `StructuredSerializeInternal$jA( %~entry . `Key^sl, %~storage用か, %memory )
◎
Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).
</li>
							<li>
%直列形の値 ~LET
~ABRUPT `StructuredSerializeInternal$jA( %~entry . `Value^sl, %~storage用か, %memory )
◎
Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).
</li>
							<li>
%直列形 . `MapData^sl に次を`付加する$
⇒
新たな`~Record$js
— その
⇒＃
`Key^sl ~SET %直列形の~key,
`Value^sl ~SET %直列形の値
◎
Append { [[Key]]: serializedKey, [[Value]]: serializedValue } to serialized.[[MapData]].
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%値 . `SetData^sl ~NEQ ε
］：
◎
Otherwise, if value has a [[SetData]] internal slot, then:
</p>

				<ol>
					<li>
%複製した~list ~LET 新たな`~List$js
◎
Let copiedList be a new empty List.
</li>
					<li>
<p>
%値 . `SetData^sl を成す
~EACH( %~entry )
に対し：
◎
For each entry of value.[[SetData]]:
</p>
						<ol>
							<li>
~IF［
%~entry ~NEQ 特殊~値 `empty^i
］
⇒
%複製した~list に %~entry を`付加する$
◎
If entry is not the special value empty, append entry to copiedList.
</li>
						</ol>
					</li>
					<li>
<p>
%複製した~list を成す
~EACH( %~entry )
に対し：
◎
For each entry of copiedList:
</p>
						<ol>
							<li>
%直列形の~entry ~LET
~ABRUPT `StructuredSerializeInternal$jA( %~entry, %~storage用か, %memory )
◎
Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).
</li>
							<li>
%直列形 . `SetData^sl に %直列形の~entry を`付加する$
◎
Append serializedEntry to serialized.[[SetData]].
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%値 は`直列化-可能$な`~platform~obj$である
］：
◎
Otherwise, if value is a platform object that is a serializable object,＼
</p>
				<ol>
					<li>
%直列化~手続き ~LET ［
%値 の`首~interface$
］用の`直列化~手続き$
◎
then perform the serialization steps for value's primary interface,＼
</li>
					<li>
%直列化~手続き( %値, %直列形, %~storage用か )
◎
given value, serialized, and forStorage.
</li>
				</ol>

<p>
`直列化~手続き$は
`下位-直列化@
を遂行することも必要になり得る。
これは、
値 %下位-値 を入力にとり，
`StructuredSerializeInternal$jA( %下位-値, %~storage用か, %memory )
を返す演算である。
（言い換えれば、
`下位-直列化$は，この呼出nの中に整合するよう特化された `StructuredSerializeInternal$jA である。）
◎
The serialization steps may need to perform a sub-serialization. This is an operation which takes as input a value subValue, and returns StructuredSerializeInternal(subValue, forStorage, memory). (In other words, a sub-serialization is a specialization of StructuredSerializeInternal to be consistent within this invocation.)
</p>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise,＼
</p>
				<ol>
					<li>
%~key群 ~LET ~NOABRUPT `EnumerableOwnProperties$jA( %値, `key^i【！%key】 )
◎
for each key in ! EnumerableOwnProperties(value, key):
</li>
					<li>
<p>
%~key群 を成す
~EACH( %~key )
に対し：
◎
↑</p>
						<ol>
							<li>
~IF［
~NOABRUPT `HasOwnProperty$jA( %値, %~key ) ~EQ ~F
］
⇒
~CONTINUE
◎
If ! HasOwnProperty(value, key) is true, then:
</li>
							<li>
%入力~値 ~LET
~ABRUPT %値 . `Get^sl( %~key, %値 )
◎
Let inputValue be ? value.[[Get]](key, value).
</li>
							<li>
%出力~値 ~LET
~ABRUPT `StructuredSerializeInternal$jA( %入力~値, %~storage用か, %memory )
◎
Let outputValue be ? StructuredSerializeInternal(inputValue, forStorage, memory).
</li>
							<li>
%直列形 . `Properties^sl に次を`付加する$
⇒
新たな`~Record$js
— その
⇒＃
`Key^sl ~SET %~key,
`Value^sl ~SET %出力~値
◎
Append { [[Key]]: key, [[Value]]: outputValue } to serialized.[[Properties]].
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %直列形
◎
Return serialized.
</li>
</ol>

<div class="example">
<p>
`StructuredSerializeInternal$jA から生産される`~Record$jsは、
参照を循環させるような，他の~recordへの “~pointer” を包含し得ることに要注意。
例えば、
次の~JS~objを `StructuredSerializeInternal$jA に渡したとするとき：
◎
It's important to realize that the Records produced by StructuredSerializeInternal might contain "pointers" to other records that create circular references. For example, when we pass the following JavaScript object into StructuredSerializeInternal:
</p>

<pre class="lang-js">
const %o = {};
%o.myself = %o;
</pre>

<p>
次の結果が生産される：
◎
it produces the following result:
</p>

<pre>
{
  `Type^sl: `Object^l,
  `Properties^sl: «
    {
      `Key^sl: `myself^l,
      `Value^sl: `&lt;この構造~全体を指す~pointer&gt;^i
    }
  »
}
</pre>

<!-- 
a pointer to this whole structure
 -->

</div>

			</section>
			<section id="structuredserialize">
<h4 title="StructuredSerialize ( value )">2.7.4. `StructuredSerialize^jA ( %値 )</h4>

<ol>
	<li>
~RET
~ABRUPT `StructuredSerializeInternal$jA( %値, ~F )
◎
Return ? StructuredSerializeInternal(value, false).
</li>
</ol>

			</section>
			<section id="structuredserializeforstorage">
<h4 title="StructuredSerializeForStorage ( value )">2.7.5. `StructuredSerializeForStorage^jA ( %値 )</h4>

<ol>
	<li>
~RET
~ABRUPT `StructuredSerializeInternal$jA( %値, ~T )
◎
Return ? StructuredSerializeInternal(value, true).
</li>
</ol>

			</section>
			<section id="structureddeserialize">
<h4 title="StructuredDeserialize ( serialized, targetRealm [ , memory ] )">2.7.6. `StructuredDeserialize^jA ( %直列形, %宛先~realm [ , %memory ] )</h4>

<p>
`StructuredDeserialize$jA 抽象-演算は、
以前に［
`StructuredSerialize$jA ／
`StructuredSerializeForStorage$jA
］が生産した`~Record$js %直列形
を入力にとり，［
%宛先~realm に属する新たな~JS値
］に逆直列化する：
◎
The StructuredDeserialize abstract operation takes as input a Record serialized, which was previously produced by StructuredSerialize or StructuredSerializeForStorage, and deserializes it into a new JavaScript value, created in targetRealm.
</p>

<p>
この処理nは、
例外を投出し得る
— 例えば，新たな~obj用に~memoryを割振ろうと試行したとき
（とりわけ， `ArrayBuffer^jC ~obj）。
◎
This process can throw an exception, for example when trying to allocate memory for the new objects (especially ArrayBuffer objects).
</p>

<ol>
	<li>
<p>
~IF［
%memory は給されてない
］
⇒
%memory ~LET 新たな`~map$
◎
If memory was not supplied, let memory be an empty map.
</p>

<p class="note">注記：
%memory ~mapの目的は、
~objが重ねて逆直列化されるのを避けることにある。
これには、
循環参照を保全して，~graphにおける~objの重複を識別することが必要になる。
◎
The purpose of the memory map is to avoid deserializing objects twice. This ends up preserving cycles and the identity of duplicate objects in graphs.
</p>
	</li>
	<li>
~IF［
%memory[ %直列形 ] ~NEQ ε
］
⇒
~RET %memory[ %直列形 ] 
◎
If memory[serialized] exists, then return memory[serialized].
</li>
	<li>
%深いか ~LET ~F
◎
Let deep be false.
</li>
	<li>
%値 ~LET ε
◎
Let value be an uninitialized value.
</li>
	<li>
<p>
%直列形 . `Type^sl に応じて：
◎
↓</p>

		<ol class="switch">
			<li>
`primitive^l
⇒
%値 ~SET %直列形 . `Value^sl
◎
If serialized.[[Type]] is "primitive", then set value to serialized.[[Value]].
</li>
			<li>
`Boolean^l
⇒
%値 ~SET %宛先~realm 内の新たな `Boolean^jC ~obj
— その
⇒
`BooleanData^sl ~SET %直列形 . `BooleanData^sl
◎
Otherwise, if serialized.[[Type]] is "Boolean", then set value to a new Boolean object in targetRealm whose [[BooleanData]] internal slot value is serialized.[[BooleanData]].
</li>
			<li>
`Number^l
⇒
%値 ~SET %宛先~realm 内の新たな `Number^jC ~obj
— その
⇒
`NumberData^sl ~SET %直列形 . `NumberData^sl
◎
Otherwise, if serialized.[[Type]] is "Number", then set value to a new Number object in targetRealm whose [[NumberData]] internal slot value is serialized.[[NumberData]].
</li>
			<li>
`BigInt^l
⇒
%値 ~SET %宛先~realm 内の新たな `BigInt^jC ~obj
— その
⇒
`BigIntData^sl ~SET %直列形 . `BigIntData^sl
◎
Otherwise, if serialized.[[Type]] is "BigInt", then set value to a new BigInt object in targetRealm whose [[BigIntData]] internal slot value is serialized.[[BigIntData]].
</li>
			<li>
`String^l
⇒
%値 ~SET %宛先~realm 内の新たな `String^jC ~obj
— その
⇒
`StringData^sl ~SET %直列形 . `StringData^sl
◎
Otherwise, if serialized.[[Type]] is "String", then set value to a new String object in targetRealm whose [[StringData]] internal slot value is serialized.[[StringData]].
</li>
			<li>
`Date^l
⇒
%値 ~SET %宛先~realm 内の新たな `Date^jC ~obj
— その
⇒
`DateValue^sl ~SET %直列形 . `DateValue^sl
◎
Otherwise, if serialized.[[Type]] is "Date", then set value to a new Date object in targetRealm whose [[DateValue]] internal slot value is serialized.[[DateValue]].
</li>
			<li>
`RegExp^l
⇒
%値 ~SET %宛先~realm 内の新たな `RegExp^jC ~obj
— その
⇒＃
`RegExpMatcher^sl ~SET %直列形 . `RegExpMatcher^sl,
`OriginalSource^sl ~SET %直列形 . `OriginalSource^sl,
`OriginalFlags^sl ~SET %直列形 . `OriginalFlags^sl
◎
Otherwise, if serialized.[[Type]] is "RegExp", then set value to a new RegExp object in targetRealm＼
whose [[RegExpMatcher]] internal slot value is serialized.[[RegExpMatcher]],＼
whose [[OriginalSource]] internal slot value is serialized.[[OriginalSource]], and＼
whose [[OriginalFlags]] internal slot value is serialized.[[OriginalFlags]].
</li>
			<li>
<p>
`SharedArrayBuffer^l：
◎
Otherwise, if serialized.[[Type]] is "SharedArrayBuffer", then:
</p>
				<ol>
					<li>
~IF［
%宛先~realm に対応する`~agent~cluster$ ~NEQ %直列形 . `AgentCluster^l
］
⇒
~THROW `DataCloneError$E
◎
If targetRealm's corresponding agent cluster is not serialized.[[AgentCluster]], then then throw a "DataCloneError" DOMException.
</li>
					<li>
%値 ~SET %宛先~realm 内の新たな `SharedArrayBuffer^jC ~obj
— その
⇒＃
`ArrayBufferData^sl ~SET %直列形 . `ArrayBufferData^sl,
`ArrayBufferByteLength^sl ~SET %直列形 . `ArrayBufferByteLength^sl
◎
Otherwise, set value to a new SharedArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot value is serialized.[[ArrayBufferData]] and whose [[ArrayBufferByteLength]] internal slot value is serialized.[[ArrayBufferByteLength]].
</li>
				</ol>
			</li>
			<li>
<p>
`GrowableSharedArrayBuffer^l ：
◎
Otherwise, if serialized.[[Type]] is "GrowableSharedArrayBuffer", then:
</p>
				<ol>
					<li>
~IF［
%宛先~realm に対応する`~agent~cluster$ ~NEQ %直列形 . `AgentCluster^sl
］
⇒
~THROW `DataCloneError$E
◎
If targetRealm's corresponding agent cluster is not serialized.[[AgentCluster]], then then throw a "DataCloneError" DOMException.
</li>
					<li>
%値 ~SET %宛先~realm 内の新たな `SharedArrayBuffer^jC ~obj
— その
⇒＃
`ArrayBufferData^sl ~SET %直列形 . `ArrayBufferData^sl,
`ArrayBufferByteLengthData^sl ~SET %直列形 . `ArrayBufferByteLengthData^sl,
`ArrayBufferMaxByteLength^sl ~SET %直列形 . `ArrayBufferMaxByteLength^sl
◎
Otherwise, set value to a new SharedArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot value is serialized.[[ArrayBufferData]], whose [[ArrayBufferByteLengthData]] internal slot value is serialized.[[ArrayBufferByteLengthData]], and whose [[ArrayBufferMaxByteLength]] internal slot value is serialized.[[ArrayBufferMaxByteLength]].
</li>
				</ol>
			</li>
			<li>
<p>
`ArrayBuffer^l：
◎
Otherwise, if serialized.[[Type]] is "ArrayBuffer", then＼
</p>
				<ol>
					<li>
<p>
%値 ~SET %宛先~realm 内の新たな `ArrayBuffer^jC ~obj
— その
⇒＃
`ArrayBufferData^sl ~SET %直列形 . `ArrayBufferData^sl,
`ArrayBufferByteLength^sl ~SET %直列形 . `ArrayBufferByteLength^sl
◎
set value to a new ArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot value is serialized.[[ArrayBufferData]], and whose [[ArrayBufferByteLength]] internal slot value is serialized.[[ArrayBufferByteLength]].
</p>

<p>
ここで例外が投出されたときは、
~catchして
⇒
~THROW `DataCloneError$E
◎
If this throws an exception, catch it, and then throw a "DataCloneError" DOMException.
</p>
					</li>
				</ol>

<p class="note">注記：
この段にて例外が投出されるのは、
`ArrayBuffer^jC ~objを作成するに十分な~memoryが可用でない場合である。
◎
This step might throw an exception if there is not enough memory available to create such an ArrayBuffer object.
</p>
			</li>
			<li>
<p>
~ELIF［
%直列形 . `Type^sl ~EQ `ResizableArrayBuffer^l
］
⇒
%値 ~SET %宛先~realm 内の新たな `ArrayBuffer^jC ~obj
— その
⇒＃
`ArrayBufferData^sl ~SET %直列形 . `ArrayBufferData^sl,
`ArrayBufferByteLength^sl ~SET %直列形 . `ArrayBufferByteLength^sl,
`ArrayBufferMaxByteLength^sl ~SET %直列形 . `ArrayBufferMaxByteLength^sl
◎
Otherwise, if serialized.[[Type]] is "ResizableArrayBuffer", then set value to a new ArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot value is serialized.[[ArrayBufferData]], whose [[ArrayBufferByteLength]] internal slot value is serialized.[[ArrayBufferByteLength]], and whose [[ArrayBufferMaxByteLength]] internal slot value is a serialized.[[ArrayBufferMaxByteLength]].
</p>

<p>
ここで例外が投出されたときは、
~catchして
⇒
~THROW `DataCloneError$E
◎
If this throws an exception, catch it, and then throw a "DataCloneError" DOMException.
</p>

<p class="note">注記：
この段にて例外が投出されるのは、
`ArrayBuffer^jC ~objを作成するに十分な~memoryが可用でない場合である。
◎
This step might throw an exception if there is not enough memory available to create such an ArrayBuffer object.
</p>
			</li>
			<li>
<p>
`ArrayBufferView^l：
◎
Otherwise, if serialized.[[Type]] is "ArrayBufferView", then:
</p>
				<ol>
					<li>
%逆直列形の~ArrayBuffer ~LET
~ABRUPT `StructuredDeserialize$jA( %直列形 . `ArrayBufferSerialized^sl, %宛先~realm, %memory )
◎
Let deserializedArrayBuffer be ? StructuredDeserialize(serialized.[[ArrayBufferSerialized]], targetRealm, memory).
</li>
					<li>
~IF［
%直列形 . `Constructor^sl ~EQ `DataView^l
］
⇒
%値 ~SET %宛先~realm 内の新たな `DataView^jC ~obj
— その
⇒＃
`ViewedArrayBuffer^sl ~SET %逆直列形の~ArrayBuffer,
`ByteLength^sl ~SET %直列形 . `ByteLength^sl,
`ByteOffset^sl ~SET %直列形 . `ByteOffset^sl
◎
If serialized.[[Constructor]] is "DataView", then set value to a new DataView object in targetRealm＼
whose [[ViewedArrayBuffer]] internal slot value is deserializedArrayBuffer,＼
whose [[ByteLength]] internal slot value is serialized.[[ByteLength]], and＼
whose [[ByteOffset]] internal slot value is serialized.[[ByteOffset]].
</li>
					<li>
~ELSE
⇒
%値 ~SET ［
%直列形 . `Constructor^sl が与える構築子
］を利用する， %宛先~realm 内の新たな有型~配列~obj
— その
⇒＃
`ViewedArrayBuffer^sl ~SET %逆直列形の~ArrayBuffer,
`TypedArrayName^sl ~SET %直列形 . `Constructor^sl,
`ByteLength^sl ~SET %直列形 . `ByteLength^sl,
`ByteOffset^sl ~SET %直列形 . `ByteOffset^sl,
`ArrayLength^sl ~SET %直列形 . `ArrayLength^sl
◎
Otherwise, set value to a new typed array object in targetRealm, using the constructor given by serialized.[[Constructor]],＼
whose [[ViewedArrayBuffer]] internal slot value is deserializedArrayBuffer,＼
whose [[TypedArrayName]] internal slot value is serialized.[[Constructor]],＼
whose [[ByteLength]] internal slot value is serialized.[[ByteLength]],＼
whose [[ByteOffset]] internal slot value is serialized.[[ByteOffset]], and＼
whose [[ArrayLength]] internal slot value is serialized.[[ArrayLength]].
</li>
				</ol>
			</li>
			<li>
<p>
`Map^l：
◎
Otherwise, if serialized.[[Type]] is "Map", then:
</p>
				<ol>
					<li>
%値 ~SET %宛先~realm 内の新たな `Map^jC ~obj
— その
⇒
`MapData^sl ~SET 新たな`~List$js
◎
Set value to a new Map object in targetRealm whose [[MapData]] internal slot value is a new empty List.
</li>
					<li>
%深いか ~SET ~T
◎
Set deep to true.
</li>
				</ol>
			</li>
			<li>
<p>
`Set^l：
◎
Otherwise, if serialized.[[Type]] is "Set", then:
</p>
				<ol>
					<li>
%値 ~SET %宛先~realm 内の新たな `Set^jC ~obj
— その
⇒
`SetData^sl ~SET 新たな`~List$js
◎
Set value to a new Set object in targetRealm whose [[SetData]] internal slot value is a new empty List.
</li>
					<li>
%深いか ~SET ~T
◎
Set deep to true.
</li>
				</ol>
			</li>
			<li>
<p>
`Array^l：
◎
Otherwise, if serialized.[[Type]] is "Array", then:
</p>
				<ol>
					<li>
%出力~prototype ~LET %宛先~realm . `Intrinsics^sl . `%Array.prototype%^sl
◎
Let outputProto be targetRealm.[[Intrinsics]].[[%Array.prototype%]].
</li>
					<li>
%値 ~SET
~NOABRUPT `ArrayCreate$jA( %直列形 . `Length^sl, %出力~prototype )
◎
Set value to ! ArrayCreate(serialized.[[Length]], outputProto).
</li>
					<li>
%深いか ~SET ~T
◎
Set deep to true.
</li>
				</ol>
			</li>
			<li>
<p>
`Object^l：
◎
Otherwise, if serialized.[[Type]] is "Object", then:
</p>
				<ol>
					<li>
%値 ~SET %宛先~realm 内の新たな `Object^jC
◎
Set value to a new Object in targetRealm.
</li>
					<li>
%深いか ~SET ~T
◎
Set deep to true.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%直列形 . `Type^sl ~EQ `Error^l
］：
◎
Otherwise, if serialized.[[Type]] is "Error", then:
</p>
				<ol>
					<li>
<p>
%~prototype ~LET %直列形 . `Name^sl に応じて
⇒＃
`EvalError^l ならば `EvalError.prototype$jI ／
`RangeError^l ならば `RangeError.prototype$jI ／
`ReferenceError^l ならば `ReferenceError.prototype$jI ／
`SyntaxError^l ならば `SyntaxError.prototype$jI ／
`TypeError^l ならば `TypeError.prototype$jI ／
`URIError^l ならば `URIError.prototype$jI ／
~ELSE_ `Error.prototype$jI
◎
Let prototype be %Error.prototype%.
◎
If serialized.[[Name]] is "EvalError", then set prototype to %EvalError.prototype%.
◎
If serialized.[[Name]] is "RangeError", then set prototype to %RangeError.prototype%.
◎
If serialized.[[Name]] is "ReferenceError", then set prototype to %ReferenceError.prototype%.
◎
If serialized.[[Name]] is "SyntaxError", then set prototype to %SyntaxError.prototype%.
◎
If serialized.[[Name]] is "TypeError", then set prototype to %TypeError.prototype%.
◎
If serialized.[[Name]] is "URIError", then set prototype to %URIError.prototype%.
</li>
					<li>
%~message ~LET %直列形 . `Message^sl
◎
Let message be serialized.[[Message]].
</li>
					<li>
%値 ~SET
`OrdinaryObjectCreate$jA( %~prototype, « `ErrorData^sl » )
◎
Set value to OrdinaryObjectCreate(prototype, « [[ErrorData]] »).
</li>
					<li>
%~message記述子 ~LET 新たな`~PropertyDescriptor$js
— その
⇒＃
`Value^sl ~SET %~message,
`Writable^sl ~SET ~T,
`Enumerable^sl ~SET ~F,
`Configurable^sl ~SET ~T
◎
Let messageDesc be PropertyDescriptor{ [[Value]]: message, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
</li>
					<li>
~IF［
%~message ~NEQ `undefined^jv
］
⇒
~NOABRUPT `OrdinaryDefineOwnProperty$jA( %値, `message^l, %~message記述子 )
◎
If message is not undefined, then perform ! OrdinaryDefineOwnProperty(value, "message", messageDesc).
</li>
					<li>
他にも %直列形 に添付された関心ng~dataがあるならば、
それも逆直列化して %値 に添付するベキである
◎
Any interesting accompanying data attached to serialized should be deserialized and attached to value.
</li>
				</ol>
			</li>
			<li>
<p>
その他：
◎
Otherwise:
</p>
				<ol>
					<li>
%~interface名 ~LET %直列形 . `Type^sl
◎
Let interfaceName be serialized.[[Type]].
</li>
					<li>
%~interface ~LET %~interface名 により識別される~interface
◎
↓</li>
					<li>
~IF［
%~interface は %宛先~realm 内に`公開されて$いない
］
⇒
~THROW `DataCloneError$E
◎
If the interface identified by interfaceName is not exposed in targetRealm, then throw a "DataCloneError" DOMException.
</li>
					<li>
%値 ~SET %宛先~realm 内に作成される，
%~interface の新たな~instance
◎
Set value to a new instance of the interface identified by interfaceName, created in targetRealm.
</li>
					<li>
%深いか ~SET ~T
◎
Set deep to true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%memory[ %直列形 ] ~SET %値
◎
Set memory[serialized] to value.
</li>
	<li>
~IF［
%深いか ~EQ ~F
］
⇒
~RET %値
◎
↓</li>
	<li>
<p>
%直列形 . `Type^sl に応じて：
◎
If deep is true, then:
</p>
		<ol class="switch">
			<li>
<p>
`Map^l：
◎
If serialized.[[Type]] is "Map", then:
</p>
				<ol>
					<li>
<p>
%直列形 . `MapData^sl を成す
~EACH( `~Record$js %~entry )
に対し：
◎
For each Record { [[Key]], [[Value]] } entry of serialized.[[MapData]]:
</p>
						<ol>
							<li>
%逆直列形の~key ~LET
~ABRUPT `StructuredDeserialize$jA( %~entry . `Key^sl, %宛先~realm, %memory )
◎
Let deserializedKey be ? StructuredDeserialize(entry.[[Key]], targetRealm, memory).
</li>
							<li>
%逆直列形の値 ~LET
~ABRUPT `StructuredDeserialize$jA( %~entry . `Value^sl, %宛先~realm, %memory )
◎
Let deserializedValue be ? StructuredDeserialize(entry.[[Value]], targetRealm, memory).
</li>
							<li>
%値 . `MapData^sl に次を`付加する$
⇒
新たな`~Record$js
— その
⇒＃
`Key^sl ~SET %逆直列形の~key,
`Value^sl ~SET %逆直列形の値
◎
Append { [[Key]]: deserializedKey, [[Value]]: deserializedValue } to value.[[MapData]].
</li>
						</ol>
					</li>
				</ol>
			</li>
		<li>
<p>
`Set^l：
◎
Otherwise, if serialized.[[Type]] is "Set", then:
</p>
				<ol>
					<li>
<p>
%直列形 . `SetData^sl を成す
~EACH( %~entry )
に対し：
◎
For each entry of serialized.[[SetData]]:
</p>
						<ol>
							<li>
%逆直列形の~entry ~LET
~ABRUPT `StructuredDeserialize$jA( %~entry, %宛先~realm, %memory )
◎
Let deserializedEntry be ? StructuredDeserialize(entry, targetRealm, memory).
</li>
							<li>
%値 . `SetData^sl に %逆直列形の~entry を`付加する$
◎
Append deserializedEntry to value.[[SetData]].
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
`Array^l ／ `Object^l：
◎
Otherwise, if serialized.[[Type]] is "Array" or "Object", then:
</p>

				<ol>
					<li>
<p>
%直列形 . `Properties^sl を成す
~EACH( `~Record$js %~entry )
に対し：
◎
For each Record { [[Key]], [[Value]] } entry of serialized.[[Properties]]:
</p>
						<ol>
							<li>
%逆直列形の値 ~LET
~ABRUPT `StructuredDeserialize$jA( %~entry . `Value^sl, %宛先~realm, %memory )
◎
Let deserializedValue be ? StructuredDeserialize(entry.[[Value]], targetRealm, memory).
</li>
							<li>
%結果 ~LET
~NOABRUPT `CreateDataProperty$jA( %値, %~entry . `Key^sl, %逆直列形の値 )
◎
Let result be ! CreateDataProperty(value, entry.[[Key]], deserializedValue).
</li>
							<li>
~Assert：
%結果 ~EQ ~T
◎
Assert: result is true.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
その他：
◎
Otherwise:
</p>
				<ol>
					<li>
%逆直列化~手続き ~LET ［
%直列形 . `Type^sl により識別される~interface
］用の適切な`逆直列化~手続き$
◎
Perform the appropriate deserialization steps for the interface identified by serialized.[[Type]],＼
</li>
					<li>
%逆直列化~手続き( %直列形, %値, %宛先~realm )
◎
given serialized, value, and targetRealm.
</li>
				</ol>
<p>
`逆直列化~手続き$は、
`下位-逆直列化@
を遂行することも必要になり得る。
これは、
以前に直列化された`~Record$js %下位-直列形 を入力にとり，
`StructuredDeserialize$jA( %下位-直列形, %宛先~realm, %memory )
を返す演算である
（言い換えれば、
`下位-逆直列化$は，この呼出nの中で整合するよう特化された `StructuredDeserialize$jA である。）
◎
The deserialization steps may need to perform a sub-deserialization. This is an operation which takes as input a previously-serialized Record subSerialized, and returns StructuredDeserialize(subSerialized, targetRealm, memory). (In other words, a sub-deserialization is a specialization of StructuredDeserialize to be consistent within this invocation.)
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %値
◎
Return value.
</li>
</ol>

			</section>
			<section id="structuredserializewithtransfer">
<h4 title="StructuredSerializeWithTransfer ( value, transferList )">2.7.7. `StructuredSerializeWithTransfer^jA ( %値, %転送-~list )</h4>

<ol>
	<li>
<p>
%memory ~LET 新たな`~map$
◎
Let memory be an empty map.
</p>

<p class="note">注記：
`StructuredSerializeInternal$jA による通常の用-法に加えて，この~algoにおける %memory は、［
`StructuredSerializeInternal$jA が %転送-~list 内の~itemを無視して，代わりに自前の取扱いを行えるようにする
］ことを確保するためにも利用される。
◎
In addition to how it is used normally by StructuredSerializeInternal, in this algorithm memory is also used to ensure that StructuredSerializeInternal ignores items in transferList, and let us do our own handling instead.
</p>
	</li>
	<li>
<p>
%転送-~list を成す
~EACH( %転送対象 )
に対し：
◎
For each transferable of transferList:
</p>
		<ol>
			<li>
~IF［
%転送対象 . `ArrayBufferData^sl ~EQ ε
］~AND［
%転送対象 . `Detached$sl ~EQ ε
］
⇒
~THROW `DataCloneError$E
◎
If transferable has neither an [[ArrayBufferData]] internal slot nor a [[Detached]] internal slot, then throw a "DataCloneError" DOMException.
</li>
			<li>
~IF［
%転送対象 . `ArrayBufferData^sl ~NEQ ε
］~AND［
`IsSharedArrayBuffer$jA( %転送対象 ) ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If transferable has an [[ArrayBufferData]] internal slot and IsSharedArrayBuffer(transferable) is true, then throw a "DataCloneError" DOMException.
</li>
			<li>
~IF［
%memory[ %転送対象 ] ~NEQ ε
］
⇒
~THROW `DataCloneError$E
◎
If memory[transferable] exists, then throw a "DataCloneError" DOMException.
</li>
			<li>
<p>
%memory[ %転送対象 ] ~SET 新たな`~Record$js
— その
⇒＃
`Type^sl ~SET 初期化されていない値【すなわち、以下において，何らかの値がアテガわれることになる。】
◎
Set memory[transferable] to { [[Type]]: an uninitialized value }.
</p>

<p class="note">注記：
%転送対象 はまだ転送されない
— 転送ngには副作用があり， `StructuredSerializeInternal$jA は最初に投出-可能になる必要があるので。
◎
transferable is not transferred yet as transferring has side effects and StructuredSerializeInternal needs to be able to throw first.
</p>
			</li>
		</ol>
	</li>
	<li>
%直列形 ~LET
~ABRUPT `StructuredSerializeInternal$jA( %値, ~F, %memory )
◎
Let serialized be ? StructuredSerializeInternal(value, false, memory).
</li>
	<li>
%転送-~data保持体~群 ~LET 新たな`~List$js

◎
Let transferDataHolders be a new empty List.
</li>
	<li>
<p>
%転送-~list を成す
~EACH( %転送対象 )
に対し：
◎
For each transferable of transferList:
</p>
		<ol>
			<li>
~IF［
%転送対象 . `ArrayBufferData^sl ~NEQ ε
］~AND［
`IsDetachedBuffer$jA( %転送対象 ) ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If transferable has an [[ArrayBufferData]] internal slot and IsDetachedBuffer(transferable) is true, then throw a "DataCloneError" DOMException.
</li>
			<li>
~IF［
%転送対象 . `Detached$sl ~NEQ ε
］~AND［
%転送対象 . `Detached$sl ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If transferable has a [[Detached]] internal slot and transferable.[[Detached]] is true, then throw a "DataCloneError" DOMException.
</li>
			<li>
%~data保持体 ~LET %memory[ %転送対象 ]
◎
Let dataHolder be memory[transferable].
</li>
			<li>
<p>
~IF［
%転送対象 . `ArrayBufferData^sl ~NEQ ε
］：
◎
If transferable has an [[ArrayBufferData]] internal slot, then:
</p>
				<ol>
					<li>
<p>
~IF［
%転送対象 . `ArrayBufferMaxByteLength^sl ~NEQ ε
］
⇒
%~data保持体 の
⇒＃
`Type^sl ~SET `ResizableArrayBuffer^l,
`ArrayBufferData^sl ~SET %転送対象 . `ArrayBufferData^sl,
`ArrayBufferByteLength^sl ~SET %転送対象 . `ArrayBufferByteLength^sl,
`ArrayBufferMaxByteLength^sl ~SET %転送対象 . `ArrayBufferMaxByteLength^sl
◎
If transferable has an [[ArrayBufferMaxByteLength]] internal slot, then:
• Set dataHolder.[[Type]] to "ResizableArrayBuffer".
• Set dataHolder.[[ArrayBufferData]] to transferable.[[ArrayBufferData]].
• Set dataHolder.[[ArrayBufferByteLength]] to transferable.[[ArrayBufferByteLength]].
• Set dataHolder.[[ArrayBufferMaxByteLength]] to transferable.[[ArrayBufferMaxByteLength]].
</li>
					<li>
~ELSE
⇒
%~data保持体 の
⇒＃
`Type^sl ~SET `ArrayBuffer^l,
`ArrayBufferData^sl ~SET %転送対象 . `ArrayBufferData^sl,
`ArrayBufferByteLength^sl ~SET %転送対象 . `ArrayBufferByteLength^sl
◎
Otherwise:
• Set dataHolder.[[Type]] to "ArrayBuffer".
• Set dataHolder.[[ArrayBufferData]] to transferable.[[ArrayBufferData]].
• Set dataHolder.[[ArrayBufferByteLength]] to transferable.[[ArrayBufferByteLength]].
</li>
					<li>
<p>
~ABRUPT `DetachArrayBuffer$jA( %転送対象 )
◎
Perform ? DetachArrayBuffer(transferable).
</p>

<p class="note">注記：
仕様は、
`ArrayBuffer$I が切離されるのを防ぐためとして， `ArrayBufferDetachKey^sl 内部~slotを利用できる。
これは
`WebAssembly JavaScript Interface^cite
に利用される
— 例えば `WASMJS$r 。
◎
Specifications can use the [[ArrayBufferDetachKey]] internal slot to prevent ArrayBuffers from being detached. This is used in WebAssembly JavaScript Interface, for example. [WASMJS]
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~Assert：
%転送対象 は`転送-可能$な`~platform~obj$である
◎
Assert: transferable is a platform object that is a transferable object.
</li>
					<li>
%~interface名 ~LET %転送対象 の`首~interface$の識別子
◎
Let interfaceName be the identifier of the primary interface of transferable.
</li>
					<li>
%~data保持体 . `Type^sl ~SET %~interface名
◎
Set dataHolder.[[Type]] to interfaceName.
</li>
					<li>
%転送-手続き ~LET ［
%~interface名 により識別される~interface
］用の適切な`転送-手続き$
◎
Perform the appropriate transfer steps for the interface identified by interfaceName,＼
</li>
					<li>
%転送-手続き( %転送対象, %~data保持体 )
◎
given transferable and dataHolder.
</li>
					<li>
%転送対象 . `Detached$sl ~SET ~T
◎
Set transferable.[[Detached]] to true.
</li>
				</ol>
			</li>
			<li>
%転送-~data保持体~群 に %~data保持体 を`付加する$
◎
Append dataHolder to transferDataHolders.
</li>
		</ol>
	</li>
	<li>
~RET 新たな`~Record$js
— その
⇒＃
`Serialized^sl ~SET %直列形,
`TransferDataHolders^sl ~SET %転送-~data保持体~群
◎
Return { [[Serialized]]: serialized, [[TransferDataHolders]]: transferDataHolders }.
</li>
</ol>

			</section>
			<section id="structureddeserializewithtransfer">
<h4 title="StructuredDeserializeWithTransfer ( serializeWithTransferResult, targetRealm )">2.7.8. `StructuredDeserializeWithTransfer^jA ( %転送-を伴う直列化-結果, %宛先~realm )</h4>

<ol>
	<li>
<p>
%memory ~LET 新たな`~map$
◎
Let memory be an empty map.
</p>

<p class="note">注記：
`StructuredSerializeWithTransfer$jA と相似的に、
`StructuredDeserialize$jA による通常の用-法に加えて，この~algoにおける %memory は、［
`StructuredSerializeInternal$jA が［
%転送-を伴う直列化-結果 . [[TransferDataHolders]] 内の~item
］を無視して，代わりに自前の取扱いを行えるようにする。
◎
Analogous to StructuredSerializeWithTransfer, in addition to how it is used normally by StructuredDeserialize, in this algorithm memory is also used to ensure that StructuredDeserialize ignores items in serializeWithTransferResult.[[TransferDataHolders]], and let us do our own handling instead.
</p>
	</li>
	<li>
%転送-済み値~list ~LET 新たな`~List$js
◎
Let transferredValues be a new empty List.
</li>
	<li>
<p>
%転送-を伴う直列化-結果 . `TransferDataHolders^sl を成す
~EACH( %転送-~data保持体 )
に対し：
◎
For each transferDataHolder of serializeWithTransferResult.[[TransferDataHolders]]:
</p>
		<ol>
			<li>
%値 ~LET ε
◎
Let value be an uninitialized value.
</li>
			<li>
<p>
~IF［
%転送-~data保持体 . `Type^sl ~EQ `ArrayBuffer^l
］
⇒
%値 ~SET %宛先~realm 内の新たな `ArrayBuffer^jC ~obj
— その
⇒＃
`ArrayBufferData^sl ~SET %転送-~data保持体 . `ArrayBufferData^sl,
`ArrayBufferByteLength^sl ~SET %転送-~data保持体 . `ArrayBufferByteLength^sl
◎
If transferDataHolder.[[Type]] is "ArrayBuffer", then set value to a new ArrayBuffer object in targetRealm＼
whose [[ArrayBufferData]] internal slot value is transferDataHolder.[[ArrayBufferData]], and＼
whose [[ArrayBufferByteLength]] internal slot value is transferDataHolder.[[ArrayBufferByteLength]].
</p>

<p class="note">注記：
`ArrayBufferData^sl が占めている元の~memoryが 逆直列化の間も~access可能な事例では、
この段は，およそ例外を投出しないであろう
— 新たな~memoryを割振る必要はないので。
代わりに，その元の~memoryが新たな `ArrayBuffer^jC に転送されることになる。
これは、
例えば，~source~realmと宛先~realmの両者とも同じ~process内にあるときに該当し得る
◎
In cases where the original memory occupied by [[ArrayBufferData]] is accessible during the deserialization, this step is unlikely to throw an exception, as no new memory needs to be allocated: the memory occupied by [[ArrayBufferData]] is instead just getting transferred into the new ArrayBuffer. This could be true, for example, when both the source and target realms are in the same process.
</p>
			</li>
			<li>
<p>
~ELIF［
%転送-~data保持体 . `Type^sl ~EQ `ResizableArrayBuffer^l
］
⇒
%値 ~SET %宛先~realm 内の新たな `ArrayBuffer^jC ~obj
— その
⇒＃
`ArrayBufferData^sl ~SET %転送-~data保持体 . `ArrayBufferData^sl,
`ArrayBufferByteLength^sl ~SET %転送-~data保持体 . `ArrayBufferByteLength^sl,
`ArrayBufferMaxByteLength^sl ~SET %転送-~data保持体 . `ArrayBufferMaxByteLength^sl
◎
Otherwise, if transferDataHolder.[[Type]] is "ResizableArrayBuffer", then set value to a new ArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot value is transferDataHolder.[[ArrayBufferData]], whose [[ArrayBufferByteLength]] internal slot value is transferDataHolder.[[ArrayBufferByteLength]], and whose [[ArrayBufferMaxByteLength]] internal slot value is transferDataHolder.[[ArrayBufferMaxByteLength]].
</p>

<p class="note">注記：
前~段と同じ理由から、
この段も，およそ例外を投出しないであろう。
◎
For the same reason as the previous step, this step is also unlikely to throw an exception.
</p>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%~interface名 ~LET %転送-~data保持体 . `Type^sl
◎
Let interfaceName be transferDataHolder.[[Type]].
</li>
					<li>
%~interface ~LET %~interface名 により識別される~interface
◎
↓</li>
					<li>
~IF［
%~interface は %宛先~realm 内に`公開されて$いない
］
⇒
~THROW `DataCloneError$E
◎
If the interface identified by interfaceName is not exposed in targetRealm, then throw a "DataCloneError" DOMException.
</li>
					<li>
%値 ~SET %宛先~realm 内に作成される，
%~interface の新たな~instance
◎
Set value to a new instance of the interface identified by interfaceName, created in targetRealm.
</li>
					<li>
%転送-受信-時の手続き ~LET %~interface 用の適切な`転送-受信-時の手続き$
◎
Perform the appropriate transfer-receiving steps for the interface identified by interfaceName＼
</li>
					<li>
%転送-受信-時の手続き( %転送-~data保持体, %値 )
◎
given transferDataHolder and value.
</li>
				</ol>
			</li>
			<li>
%memory[ %転送-~data保持体 ] ~SET %値
◎
Set memory[transferDataHolder] to value.
</li>
			<li>
%転送-済み値~list に %値 を`付加する$
◎
Append value to transferredValues.
</li>
		</ol>
	</li>
	<li>
%逆直列形 ~LET
~ABRUPT `StructuredDeserialize$jA( %転送-を伴う直列化-結果 . `Serialized^sl, %宛先~realm, %memory )
◎
Let deserialized be ? StructuredDeserialize(serializeWithTransferResult.[[Serialized]], targetRealm, memory).
</li>
	<li>
~RET 新たな`~Record$js
— その
⇒＃
`Deserialized^sl ~SET %逆直列形,
`TransferredValues^sl ~SET %転送-済み値~list
◎
Return { [[Deserialized]]: deserialized, [[TransferredValues]]: transferredValues }.
</li>
</ol>

			</section>
			<section id="performing-structured-clones-from-other-specifications">
<h4 title="Performing serialization and transferring from other specifications">2.7.9. 他の仕様からの直列化と転送-の遂行-法</h4>

<p>
他の仕様は、
ここに定義した抽象-演算を利用してもヨイ。
以下に、
各種 抽象-演算が概していつ有用になるかについての指導を，例とともに供する：
◎
Other specifications may use the abstract operations defined here. The following provides some guidance on when each abstract operation is typically useful, with examples.
</p>

<dl>
	<dt>`StructuredSerializeWithTransfer$jA</dt>
	<dt>`StructuredDeserializeWithTransfer$jA</dt>
	<dd>
宛先~realmは事前に既知でない下で、
別の`~realm$へ，転送-~listも伴わせて値を~cloneするとき。
この事例では、
直列化の段は即時に遂行できる一方で，逆直列化の段は 宛先~realmが既知になるまで遅延される。
◎
Cloning a value to another realm, with a transfer list, but where the target realm is not known ahead of time. In this case the serialization step can be performed immediately, with the deserialization step delayed until the target realm becomes known.
</dd>
	<dd class="example">
`messagePort.postMessage()$m は、
行先~realmは `MessagePort$I が`搬送-済み$になるまで既知でないので，これらの抽象-演算を組みで利用する。
◎
messagePort.postMessage() uses this pair of abstract operations, as the destination realm is not known until the MessagePort has been shipped.
</dd>

	<dt>`StructuredSerialize$jA</dt>
	<dt>`StructuredSerializeForStorage$jA</dt>
	<dt>`StructuredDeserialize$jA</dt>
	<dd>
所与の値~用に，`~realm$から独立な~snapshotを作成するとき
— 不定~~期間~保存でき、
後で，場合によっては複数~回にわたり ~JS値に~~復元されるような。
◎
Creating a realm-independent snapshot of a given value which can be saved for an indefinite amount of time, and then reified back into a JavaScript value later, possibly multiple times.
</dd>
	<dd>
`StructuredSerializeForStorage$jA は、
直列化が
— ~realm間で渡される代わりに —
持続的に格納されると見越される状況に利用できる。
それは、
`SharedArrayBuffer$I ~objを直列化しようと試みたときは投出する
— 共用~memory内に格納しても無為なので。
同様に，所与の`~platform~obj$に~customな`直列化~手続き$がある場合、［
%~storage用か ~EQ ~T
］の下では，［
投出する ／ 場合によっては挙動が異なる
］こともある。
◎
StructuredSerializeForStorage can be used for situations where the serialization is anticipated to be stored in a persistent manner, instead of passed between realms. It throws when attempting to serialize SharedArrayBuffer objects, since storing shared memory does not make sense. Similarly, it can throw or possibly have different behavior when given a platform object with custom serialization steps when the forStorage argument is true.
</dd>
	<dd class="example">
`history.pushState()$m ／
`history.replaceState()$m
は、
作者から給された状態~objに
`StructuredSerializeForStorage$jA を利用し，それを適切な`~session履歴~entry$内に`直列形の状態$で格納する。
`history.state$m ~propは、
`StructuredDeserialize$jA を利用して，元々給された状態~objの~cloneを返す。
◎
history.pushState() and history.replaceState() use StructuredSerializeForStorage on author-supplied state objects, storing them as serialized state in the appropriate session history entry. Then, StructuredDeserialize is used so that the history.state property can return a clone of the originally-supplied state object.
</dd>
	<dd class="example">
`broadcastChannel.postMessage()$m は、
その入力に対し
`StructuredSerialize$jA を利用した結果に対し，
`StructuredDeserialize$jA を複数~回~利用して、
~broadcastされている各 行先~用に新規の~cloneを生産する。
行先が複数ある状況では、
転送ngはイミを成さないことに注意。
◎
broadcastChannel.postMessage() uses StructuredSerialize on its input, then uses StructuredDeserialize multiple times on the result to produce a fresh clone for each destination being broadcast to. Note that transferring does not make sense in multi-destination situations.
</dd>
	<dd class="example">
~filesystemに~JS値を持続化させるような~APIも、
その入力に `StructuredSerializeForStorage$jA を利用し，その出力に `StructuredDeserialize$jA を利用する。
◎
Any API for persisting JavaScript values to the filesystem would also use StructuredSerializeForStorage on its input and StructuredDeserialize on its output.
</dd>
</dl>

<p>
一般に、
~callする所では，~JS値の代わりに~Web~IDL値を渡してもヨイ
— これは、
これらの~algoを呼出す前に，暗黙的な`~JS値への変換$を遂行するものと解される。
◎
In general, call sites may pass in Web IDL values instead of JavaScript values; this is to be understood to perform an implicit conversion to the JavaScript value before invoking these algorithms.
</p>

<hr>

<p>
［
作者~codeが~UA~methodの中へ~callした結果として同期的に呼出されてはいない所
］から，抽象-演算［
`StructuredSerialize$jA ／
`StructuredSerializeForStorage$jA ／
`StructuredSerializeWithTransfer$jA
］を呼出すときは
— それが任意の~objに対し遂行されている場合には —
呼出す前に，適正に［
`~scriptを走らすために準備する$,
`~callbackを走らすために準備する$
］よう~careするモノトスル。
このことは、
必要yである
— 直列化~処理nは、
その~~最終的な深い直列化~手続きの一部として，作者により定義される~accessorを呼出すこともあり、
その~accessorは［［
`入口~某$／`現任な某$
の概念が 適正に設定してある
］ことに依拠するような演算
］の中へ~callすることもあるので。
◎
Call sites that are not invoked as a result of author code synchronously calling into a user agent method must take care to properly prepare to run script and prepare to run a callback before invoking StructuredSerialize, StructuredSerializeForStorage, or StructuredSerializeWithTransfer abstract operations, if they are being performed on arbitrary objects. This is necessary because the serialization process can invoke author-defined accessors as part of its final deep-serialization steps, and these accessors could call into operations that rely on the entry and incumbent concepts being properly set up.
</p>

<p class="example">
`window.postMessage()$m は、
その引数に対し `StructuredSerializeWithTransfer$jA を遂行するが、
注意深く，自身の~algoの同期的な部位の内側で即時に行うので、［
`~scriptを走らすために準備する$ ／ `~callbackを走らすために準備する$
］必要なく，この~algoを利用できる。
◎
window.postMessage() performs StructuredSerializeWithTransfer on its arguments, but is careful to do so immediately, inside the synchronous portion of its algorithm. Thus it is able to use the algorithms without needing to prepare to run script and prepare to run a callback.
</p>

<p class="example">
対照的に、
`StructuredSerialize$jA を利用して，［
作者から給された何らかの~objを，`~event~loop$上の`~task$から毎回 直に直列化する
］ような~APIがあるとするなら、
前もって適切な準備が遂行されることを確保する必要がある。
現時点では、
そのような~APIは，【~web】~platformには無いことが知られている
— 通例的には、
作者~codeに同期して，事前に直列化を遂行しておく方が単純になる。
◎
In contrast, a hypothetical API that used StructuredSerialize to serialize some author-supplied object periodically, directly from a task on the event loop, would need to ensure it performs the appropriate preparations beforehand. As of this time, we know of no such APIs on the platform; usually it is simpler to perform the serialization ahead of time, as a synchronous consequence of author code.
</p>

			</section>
			<section id="structured-cloning">
<h4 title="Structured cloning API">2.7.10. 有構造~clone法~API</h4>

<dl class="domintro">
	<dt>%result = self.`structuredClone(value[, options ])$m</dt>
	<dd>
入力~値に対し有構造~clone~algoを遂行することにより，深い複製を返す。
%options[ "`transfer$m" ] 配列~内に~listされた`転送-可能$な~objは、
~cloneされるのみならず，転送される
— すなわち、
それらは，入力~値において もはや利用-可能でなくなる。
◎
Takes the input value and returns a deep copy by performing the structured clone algorithm. Transferable objects listed in the transfer array are transferred, not just cloned, meaning that they are no longer usable in the input value.
</dd>
	<dd>
入力~値を成す ある一部が`直列化-可能$でない場合、
`DataCloneError$E 例外が投出される。
◎
Throws a "DataCloneError" DOMException if any part of the input value is not serializable.
</dd>
</dl>

<div class="algo">
<p>
`WindowOrWorkerGlobalScope$I の
`structuredClone(value, options)@m
~method手続きは：
◎
The structuredClone(value, options) method steps are:
</p>
<ol>
	<li>
%直列形 ~LET 
~ABRUPT `StructuredSerializeWithTransfer$jA( %value, %options[ "`transfer$m" ] )
◎
Let serialized be ? StructuredSerializeWithTransfer(value, options["transfer"]).
</li>
	<li>
%逆直列化-~record ~LET ~ABRUPT `StructuredDeserializeWithTransfer$jA( %直列形, コレに`関連な~realm$ )
◎
Let deserializeRecord be ? StructuredDeserializeWithTransfer(serialized, this's relevant realm).
</li>
	<li>
~RET %逆直列化-~record . `Deserialized^sl
◎
Return deserializeRecord.[[Deserialized]].
</li>
</ol>
</div>

			</section>
		</section>
</main>
