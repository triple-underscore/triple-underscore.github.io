<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Safe passing of structured data（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>

.xattr {
	font-family: monospace0, monospace;
	color: black;
}


</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170608 spec

	return;
}

function expand(){

	var class_map = {
		e: 'element',
		a: 'attr',
		E: 'error',
		xA: 'xattr',
		sl: 'js-slot',
		js: 'js',
		jA: 'abstract',
		jC: 'js-class',
		jI: 'js-intrinsic',
		t: 'type',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		c: 'code',
		sl: 'span',
		js: 'span',
		jA: 'span',
		jI: 'span',
		jC: 'code',
		xA: 'code',
		V: 'var',
		t: 'var',
		i: 'i', // model constants
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl': // JS internal slot
	text = '[[' + key + ']]';
	break;
case 'jI': // JS intrinsic objects
	text = '%' + key + '%';
	break;
case 'xA': // 
	text = '[' + key + ']';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2018-02-26
trans_update:2018-02-27
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/structured-data.html
nav_prev:HTMLcdom
nav_next:HTMLdom
trans_1st_pub:2016-01-28


●●original_id_map


●●link_map



	●idl
E.RangeError:~TC39#sec-native-error-types-used-in-this-standard-rangeerror
DOMException:~WEBIDL#dfn-DOMException
xA.Serializable:#serializable
xA.Transferable:#transferable

I.MessagePort:~HTMLcomms#messageport
I.SharedArrayBuffer:~TC39#sec-sharedarraybuffer-objects

m.broadcastChannel.postMessage:~HTMLcomms#dom-broadcastchannel-postmessage
m.history.pushState:~HISTORY#dom-history-pushstate
m.history.replaceState:~HISTORY#dom-history-replacestate
m.history.state:~HISTORY#dom-history-state
m.lastModified:~FILEAPI#dfn-lastModified
m.messagePort.postMessage:~HTMLcomms#dom-messageport-postmessage
m.name:~FILEAPI#dfn-name
m.window.postMessage:~HTMLcomms#dom-window-postmessage

jA.StructuredDeserialize:#structureddeserialize
jA.StructuredDeserializeWithTransfer:#structureddeserializewithtransfer
StructuredSerializeInternal
jA.StructuredSerializeInternal:#structuredserializeinternal
jA.StructuredSerialize:#structuredserialize
jA.StructuredSerializeForStorage:#structuredserializeforstorage
jA.StructuredSerializeWithTransfer:#structuredserializewithtransfer

sl.Detached:#detached

転送-可能:#transferable-objects
転送-手続き:#transfer-steps
転送-受信-時の手続き:#transfer-receiving-steps
直列化-可能:#serializable-objects
直列化~手続き:#serialization-steps
下位直列化:#sub-serialization
下位逆直列化:#sub-deserialization
逆直列化~手続き:#deserialization-steps

E.DataCloneError:~WEBIDL#datacloneerror

jI.ArrayPrototype:~TC39#sec-properties-of-the-array-prototype-object
jA.ArrayCreate:~TC39#sec-arraycreate
jA.CopyDataBlockBytes:~TC39#sec-copydatablockbytes
jA.CreateByteDataBlock:~TC39#sec-createbytedatablock
jA.CreateDataProperty:~TC39#sec-createdataproperty
jA.DetachArrayBuffer:~TC39#sec-detacharraybuffer
jA.EnumerableOwnProperties:~TC39#sec-enumerableownproperties
jA.HasOwnProperty:~TC39#sec-hasownproperty
jA.IsCallable:~TC39#sec-iscallable
jA.IsDetachedBuffer:~TC39#sec-isdetachedbuffer
jA.IsSharedArrayBuffer:~TC39#sec-issharedarraybuffer
jA.OrdinaryGetOwnProperty:~TC39#sec-ordinarygetownproperty
jA.IsSharedArrayBuffer:~TC39#sec-issharedarraybuffer

js.List:~TC39#sec-list-and-record-specification-type
js.Record:~TC39#sec-list-and-record-specification-type

~JS~Realm:~TC39#sec-code-realms
~Realm:~TC39#sec-code-realms
現在の~Realm~Record:~TC39#current-realm
~agent-cluster:~TC39#sec-agent-clusters

jA.Type:~TC39#sec-ecmascript-data-types-and-values
	[JAVASCRIPT]:references.html#refsJAVASCRIPT

~EACH:~INFRA#list-iterate
~SET:~INFRA#map-set
付加する:~INFRA#list-append
	~NEQ ε:~INFRA#map-exists
~list:~INFRA#list
~map:~INFRA#ordered-map

~JS値への変換:~WEBIDL#es-type-mapping
拡張属性:~WEBIDL#dfn-extended-attribute
~platform~obj:~WEBIDL#dfn-platform-object
首~interface:~WEBIDL#dfn-primary-interface
部分的~interface:~WEBIDL#dfn-partial-interface
~interface~mixin:~WEBIDL#interface-mixin
内包している~interface:~WEBIDL#include

直列形の状態:~HISTORY#serialized-state
~session履歴~entry:~HISTORY#session-history-entry

生成元:~ORIGIN#concept-origin

搬送-済み:~HTMLcomms#has-been-shipped

入口~某:~WAPI#concept-entry-everything
現任の某:~WAPI#concept-incumbent-everything
~callbackを走らすために準備する:~WAPI#prepare-to-run-a-callback
~scriptを走らすために準備する:~WAPI#prepare-to-run-script
~event-loop:~WAPI#event-loop
~task:~WAPI#concept-task

~snapshot状態:~FILEAPI#snapshot-state

●●words_table1


Foo:<var>Foo</var>


●●words_table




	●処理
task::::タスク
event-loop:event loop:::イベントループ
instance::::インスタンス
code::::コード
algo:algorithm:::アルゴリズム
call:
catch:
script::::スクリプト

process::::プロセス
処理-:process:~
出力:output:~
入力:input:~
内部:internal:~
同期して:synchronous に:~
同期的:synchronous:~

	変換-:convert:~
変換:conversion:~
即時に:immediate に:~

例外:exception:~
呼出:invocation:呼び出し
呼出す:invoke する:呼び出す
呼出され:invoke され:呼び出され

設定-:set:~
	設定しておく:set up:~

走らす:run する:~
遂行-:perform:~
	返す:return:~
投出-:throw:~
	演算-:operate:~
演算:operation:~
所与の:given:与えられた
手続き:steps:~
	手続き:set of steps
	一連の段からなる
段:step:~
準備-:prepare:~
準備:preparation:~
複製:copy:~
複製した:copied:~

	●変数
ArrayBuffer:
BestFriend:
name:
下位:sub:~
列挙-:enumerate:~
	列挙-可能:enumerable
保持体:holder::~::ホルダ
記述子:descriptor:~
長さ:length:~
file::::ファイル
size::::サイズ
	出力~prototype:outputProto
	列挙-可能~key~list:enumerableKeys
	入力~値:inputValue
	出力~値:outputValue
	下位~値:subValue
	複製した~list:copiedList
	複製した~entry:copiedEntry
	~interface名:interfaceName
	直列形:serialized
	下位直列形:subSerialized
	直列形の~値:serializedValue
	直列形の~key:serializedKey
	直列形の~entry:serializedEntry
	逆直列形の値:deserializedValue
	逆直列形の~ArrayBuffer:deserializedArrayBuffer
	逆直列形の~key:deserializedKey
	逆直列形の~entry:deserializedEntry
	逆直列形の~BestFriend:deserializedBestFriend
	deserializedValue:deserializedValue
	型~文字列:typeString
	宛先~Realm:targetRealm
	~dataの複製:dataCopy
	~data保持体:dataHolder
	転送済み値~list:transferredValues
	転送-~data保持体:transferDataHolder
	転送-~data保持体~list:transferDataHolders
	転送-を伴う直列化-結果:serializeWithTransferResult
	値~記述子:valueDesc
	値~長さ:valueLen
	値~長さ記述子:valueLenDescriptor
	~file:file
	値:value
	~buffer直列形:bufferSerialized
	~buffer:buffer
	~size:size

	●IDL／JS／data型
list:
JS:JavaScript
WebIDL:
IDL:
mix-in:
	mixed-in-to
mixin:
exotic:
Realm:
Record:
agent-cluster:agent cluster
prototype:
boolean:
entry::::エントリ
入口:entry::~
list::::リスト
obj:object:::オブジェクト
slot::::スロット
interface::::インタフェース
key::::
callback::::
構築子:constructor::~::コンストラクタ
data::::データ
field::::フィールド
map::::マップ
method::::メソッド
platform::::プラットフォーム
access::::アクセス
	access可能:accessible
accessor::::アクセサ
record::::レコード
型:type:~
有型:typed:~
属性:attribute:~
識別子:identifier:~
部分的:partial:~
配列:array:~
公開-:expose:~
抽象演算:abstract operation:~

内在的:intrinsic:~
首:primary::主
内包-:include::~

	●有構造~clone
clone::::クローン
	clone可能:cloneable
snapshot::::スナップショット
深い:deep::~
某:〜
現任の:incumbent:~
buffer::::バッファ
切離す:detach する:切り離す
転送-:transfer::~
	転送-可能:transferable
転送対象:transferable::~
転送:transferring::~
転送済み:transferred::~
	転送-~list:transferList:
	転送を行えない:transferral is not possible
直列化-:serialize::~::シリアル化
直列化:serialization::~::シリアル化
	直列化-可能:serializable
	直列化できない:un-serializable
直列形:serialized::~::シリアル形
直列形の:serialized::~::シリアル形の
下位直列化:sub-serialization::~::下位シリアル化
下位直列形:sub-serialized::~::下位逆シリアル形

逆直列化-:deserialize::~::逆シリアル化
逆直列化:deserialization::~::逆シリアル化
逆直列形:deserialized::~::逆シリアル形
逆直列形の:deserialized::~::逆シリアル形の
下位逆直列化:sub-deserialization::~::下位逆シリアル化

宛先:target::~
不可逆:irreversible:~
循環参照:cycle:~
	参照を循環させる:create circular reference
graph::::グラフ
有構造:structured::~
構造:structure::~
冪等:idempotent:~

所有権:ownership:~
境界:boundary:~

下層の:underlying:~
参照:reference:~
共用:shared:~
	同じ-:share:~
受信-:receive:~
拡張属性:extended attribute:~
対称:symmetric:~
	very symmetric
復旧-:restore:~
持続化-:persist:~
割当て:allocation:割り当て
割当てる:allocate する:割り当てる
割当てよ:allocate しよ:割り当てよ
行先:destination:~

蓄積用:forStorage::~

	●仕様
custom::::カスタム
model::::モデル
support::::サポート
API:
UA:user agent:UA
	利用-:use:~
一般:general:~
仕様:spec:~
作者:author:~
依拠-:rely:~
保全-:preserve:~
保持-:hold:~
側面:aspect:~
取扱われ:handle され:取り扱われ
取扱い:handling:~
各種用語:terminology:~
定義-:define:~
定義:definition:~
実装-:implement:~
指定-:specify:~
暗黙的:implicit:~
概念:concept:~
注意-:care:~
注意深く:careful に:~
	要注意:It’s important to realize
	に注意:Note that
無視-:ignore:~
目的:purpose:~
表記規約:conventions:~
適切:appropriate:~
高価:expensive:~
有用:useful:~
実質的:effective:~
適正:proper:~
通例的:usual:~
確保-:ensure:~
解-:understand:~
情報:information:~
手引き:guidance:~
挙動:behavior:ふるまい
明示的:explicit:~
試行-:try:~
避ける:avoid する:~
状況:situation:~
概して:typical に:~
自前の:own:~
許容-:allow:~
重要:important:~
複雑:complex:~
事例:case:~
仕事:job:~
仕方:way:~
付随-:accompany:~
既知の:known:~
既知:known:~
決定-:determine:~
注釈-:annotate:~
可用:available:~
特殊:special:~
特化-:specialize:~
	specialization
実施:practice:~
整合する:consistent になる:~
試みた:attempt した:~
通常の:normal な:~
	による通常の用法:how it is used normally by
導入-:introduce:~
	導入するとき:introduction
関連する:relevant な:~
副作用:side effects:~
相似的:analogous:~
	見込まれ:anticipate:~
	加えて:In addition to
	十分:enough
	可能:possible
	場合によっては:possibly
	委ねられ:up to
	言い換えれば、:In other words
	対照的に:in contrast
	あるとするなら、:hypothetical
	表-
	必要:need
	必要とされ:necessary
	とは限らない:necessarily
	課題
	通例でないunusual
	利用-
	可能
	委ねられ
	容易:ease:~
	具体的には:for instance
	付与-:decorate:~
	例:example
	とする:say
	~~意味を成さない／無為:not make sense
	およそ〜ないであろうunlikely
	ことになるであろう:would likely
	~~実際には:really a
	同様に:similarly

	●未分類（動詞
broadcast::::ブロードキャスト
搬送-:ship::~
除去-:remove:~
置換-:replace:~
作成-:create:~
識別-:identify:~
追加-:add:~
重複:duplicate:~
並替える:reorder する:並び替える
未指定の:unspecified:~
供-:provide:~
収集:collection:~
付加-:append:~
作成-:create:~
保存-:save:~
入子の:nested:入れ子の
分離-:separate:~
更新-:update:~
格納-:store:~
初期化-:initialize:~
	初期化されていない:uninitialized
	ε:uninitialized value
利用-:use:~
包含-:contain:~
生産-:produce:~
省略-:omit:~
遅延-:delay:~
表現-:represent:~
給-:supply:~

	占めて:occupy して:~
	渡し方
	渡-:pass
	生じ
	現れ:appear
	異なる:different
	結果の:resulting
	結果:result
	見よ
	知られ
	越えて
	見られ
	~~復元:reified-back

	●未分類
disk::::ディスク
filesystem::::ファイルシステム
memory::::メモリ
byte::::バイト
文字列:string:~
item::::アイテム
	組みで:pair
pointer::::ポインタ
prop:property:::プロパティ
session::::セッション
履歴:history::~
source::::ソース
worker::::
引数:argument:~
文書:document:~
生成元:origin::~::オリジン
資源:resource::~:リソース
値:value:~
単純:simple:~
名前:name:~
安全:safe:~
直接的:direct:~
空:empty:~
部位:portion:~
配列:array:~
方式:manner:~
決定的順序:deterministic ordering:~
不定:indefinite:~
名:name:~
失敗:failure:~
形:form:~
循環:circular:~
状態:state:~
独立:independent:~
結付けら:associate さ:結び付けら
	返す:return:~
持続的:persistent:~
	持続的に:persistent manner で
	列:sequence
	とる:take
	anything
	-:we
	片:piece
	なる:become
	新規の:fresh
	~~期間:amount of time

	●指示語
内側:inside:~
元の:original:~
新たな:new:~
	新たに:newly
現在の:current:~
	前もって:beforehand
	近過去:recently
	以前に:previously
	回:time
	個の:one／two
	ある種の:certain
	ここ:here
	この:this
	これらの／この:these
	すべての:all
	その:that
	そのような:such
	それら:they
	それらを:them
	個々の:individual
	複数:multiple:~
	複数:multi-
	間:during:~
	後に:later:~
	両者:both
	別の:another:~
	他の:other
	当の:in question／
	何らか
	何も
	何を
	する側:sites
	側
	一部:part of
	事前に:ahead of time
	〜の代わりに:instead
	以外
	任意の:arbitrary:~
	再び／再度／し直す:again
	間:between
	内
	各:each
	同じ:same
	元々:originally
	含めて:including
	場合
	対応-
	属する
	現時点では:As of this time
	時点
	~~最終的:final
	次の:the following
	次を
	自身
	種
	節
	限り
	間
	類の


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
Common infrastructure 章の
<a href="~SPEC_URL">Safe passing of structured data</a>
節を日本語に翻訳したものです。
~PUB
</p>

</script>
<!-- 訳注
	前に
	右辺
	向けに
	否定を
	得る
	所では
	持つ
	方
	時
	比較式に
	決して
	記され
	記号
	表記
	明らか
	意図
	大雑把に言えば
	しかしながら，:however
	とりわけ:especially
	べき:should
	上手く~~働くようになる:better served
	より良く:better
	あっては~MUST_NOT:must be impossible

 -->

</head>
<body>

<header id="head">
	<hgroup>
<h1>有構造データの安全な渡し方 — Safe passing of structured data</h1>

	</hgroup>

</header>

<hr>

<main id="MAIN" style="display:none;">

		<section id="safe-passing-of-structured-data">
<h2 title="Safe passing of structured data">2.7. 有構造~dataの安全な渡し方</h2>

<p>
この節では、~JS仕様による，各種用語と表記規約を利用する。
`JAVASCRIPT$r
◎
This section uses the terminology and typographic conventions from the JavaScript specification. [JAVASCRIPT]
</p>


<ul class="trans-note">
	<li>
~algo内の抽象演算の前に現れる記号［
"?", "!"
］の意味は、その仕様にて定義される。
（大雑把に言えば、 "?" は 例外が投出され得ることを表し， "!" は 例外は決して投出されないことを表す）。
</li>
	<li>
`~Foo^sl という表記は、名前 "~Foo" の［
内部~slot／内部~method／~field
］を表す（~script向けには直接~公開されない内部~dataを保持する）。
</li>
</ul>

<p class="trans-note">【
加えて、この訳では次のような略記法を導入する：
】</p>

<ul>
	<li>
“%O . `~Foo^sl”
のような表記は、［
~JS~obj ／ ~JS `Record$js
］ %O 上の 名前 `~Foo^l の［［
内部~slot または 内部~method
］／ ~field
］を表すとする。
%O が明らかな所では、単に “ . `~Foo^sl” のようにも記される。
</li>
	<li>
代入の右辺や比較式に現れる
“%O . `~Foo^sl”
のような表記は、 ~Foo［
内部~slot ／ ~field
］の値を表す。
同様に，
“%O . `~Foo^sl(…)”
は、 ~Foo 内部~methodを~callした結果の値を表す。
</li>
	<li>
“%O . `~Foo^sl ~NEQ ε”
という表記は、
%O には，名前 `~Foo^l の［
内部~slot／内部~method／~field
］が在ることを意味する。
“%O . `~Foo^sl ~EQ ε”
はその否定（無いこと）を意味する。
</li>
</ul>


			<section id="serializable-objects">
<h3 title="Serializable objects">2.7.1. 直列化-可能な~obj</h3>

<p>
`直列化-可能$な~objは、所与の`~Realm$が何であれ，それに独立な仕方で直列化され, 後に逆直列化されることを~supportする
【逆直列化（ deserialize ） — 字義通り，直列化された結果から元に復元すること】
。
これにより、それを~diskに格納して後に復旧したり，文書や~workerの境界を（異なる`生成元$や異なる`~event-loop$に属する文書~間も含めて）越えて~cloneすることも許容される。
◎
Serializable objects support being serialized, and later deserialized, in a way that is independent of any given JavaScript Realm. This allows them to be stored on disk and later restored, or cloned across document and worker boundaries (including across documents of different origins or in different event loops).
</p>

<p>
~objには`直列化-可能$でないものもあり、`直列化-可能$なものでも，そのすべての側面が直列化-時に保全されるとは限らない。
◎
Not all objects are serializable objects, and not all aspects of objects that are serializable objects are necessarily preserved when they are serialized.
</p>


<p>
`~platform~obj$は、
`Serializable@xA
~IDL`拡張属性$が付与された~interfaceのみを実装するならば、`直列化-可能$である。
そのような~interfaceは、次の~algoも定義し~MUST（括弧内は入力）：
◎
Platform objects can be serializable objects if they implement only interfaces decorated with the [Serializable] IDL extended attribute. Such interfaces must also define the following algorithms:
</p>

<dl>
	<dt>
`直列化~手続き@( `~platform~obj$ %値, `Record$js %直列形, ~boolean %蓄積用 )
◎
serialization steps, taking a platform object value, a Record serialized, and a boolean forStorage
</dt>
	<dd>
%値 内の~dataを %直列形 の各~fieldの中に直列化するための手続き。
%直列形 の中に直列化される結果の~dataは、どの`~Realm$からも独立で~MUST。
◎
A set of steps that serializes the data in value into fields of serialized. The resulting data serialized into serialized must be independent of any JavaScript Realm.
</dd>
	<dd>
この手続きは、直列化が可能でない場合は，例外を投出してもよい／し得る。
◎
These steps may throw an exception if serialization is not possible.
</dd>
	<dd>
この手続きは、`下位直列化$を遂行して，入子の~data構造を直列化してもよい／し得る。
それらは `StructuredSerialize$jA を直接的に~callするべきでない
— そうすると、重要な %memory 引数が省略されることになるので。
<!-- ＊それらとは？ -->
◎
These steps may perform a sub-serialization to serialize nested data structures. They should not call StructuredSerialize directly, as doing so will omit the important memory argument.
</dd>
	<dd>
この手続きを導入するときは、~algoに関連する場合を除き， %蓄積用 引数は省略するべきである。
◎
The introduction of these steps should omit mention of the forStorage argument if it is not relevant to the algorithm.
</dd>

	<dt>
`逆直列化~手続き@( `Record$js %直列形, `~platform~obj$ %値 )
◎
deserialization steps, taking a Record serialized and a platform object value
</dt>
	<dd>
%値 を適切に設定しておくために， %直列形 内の~dataを逆直列化するための手続き。
%値 は，新たな［
当の`~platform~obj$の型の~instance
］であり、その内部~dataは何も設定されてないものになる
— それを設定しておくのが、この手続きの仕事である。
◎
A set of steps that deserializes the data in serialized, using it to set up value as appropriate. value will be a newly-created instance of the platform object type in question, with none of its internal data set up; setting that up is the job of these steps.
</dd>
	<dd>
この手続きは、逆直列化が可能でない場合は，例外を投出してもよい／し得る。
◎
These steps may throw an exception if deserialization is not possible.
</dd>
	<dd>
この手続きは、`下位逆直列化$を遂行して，入子の~data構造を逆直列化してもよい／し得る。
そこでは `StructuredDeserialize$jA を直接的に~callするべきでない
— そうすると、重要な［
%宛先~Realm, %memory
］引数が省略されることになるので。
<!-- ＊それらとは？ -->
◎
These steps may perform a sub-deserialization to deserialize nested data structures. They should not call StructuredDeserialize directly, as doing so will omit the important targetRealm and memory arguments.
</dd>
</dl>

<p>
これらの手続きにより どの~dataを［
直列化-／逆直列化-
］するかを決定するのは、個々の~platform~objの定義に委ねられる。
この 2 つの手続きは、概して対称になる。
◎
It is up to the definition of individual platform objects to determine what data is serialized and deserialized by these steps. Typically the steps are very symmetric.
</p>

<div>
<p>
`Serializable$xA
拡張属性は：
</p>
<ul> <li>引数をとっては~MUST_NOT。
</li><li>~interface以外に現れては~MUST_NOT。
</li><li>~interfaceに現れるのは一度限りで~MUST。
</li><li>~callback~interface上に利用されては~MUST_NOT。
</li><li>［
`部分的~interface$ ／ `~interface~mixin$
］上に現れる場合、［
その元の~interface ／ それを`内包している~interface$
］にも現れ~MUST
— 前者~用に給された［
`直列化~手続き$や`逆直列化~手続き$
］があれば、それらは後者に付加されているものと解されるべきである。
</li></ul>

◎
The [Serializable] extended attribute must take no arguments, and must not appear on anything other than an interface. It must appear only once on an interface. It must not be used on a callback interface. If it appears on a partial interface or an interface that is really a mixin, then it must also appear on the original or mixed-in-to interface, and any supplied serialization steps and deserialization steps for the partial interface or mixin should be understood as being appended to those of the original or mixed-in-to interface.
</div>

<div class="example">
<p>
ある~platform~obj `Person^I を定義していて，それには次の 2 つの~data片が結付けられているとする：
◎
Let's say we were defining a platform object Person, which had associated with it two pieces of associated data:
</p>

<ul>
	<li>
`~name^i ：文字列を値にとる
◎
a name value, which is a string;
</li>
<li>
`~BestFriend^i：別の `Person^c ~instanceまたは ~NULL を値にとる
◎
and a best friend value, which is either another Person instance or null
</li>
</ul>

<p>
このとき， `Person^I ~instanceを`直列化-可能$になるように定義するためには、
`Person^I ~interfaceに `Serializable$xA `拡張属性$を注釈して，付随する~algoを次のように定義する：
◎
We could then define Person instances to be serializable objects by annotating the Person interface with the [Serializable] extended attribute, and defining the following accompanying algorithms:
</p>

<dl>
	<dt>
`直列化~手続き$
◎
serialization steps
</dt>
	<dd>
		<ol>
			<li>
%直列形 . `Name^sl ~SET %値 の `~name^i 値
◎
Set serialized.[[Name]] to value's associated name value.
</li>
			<li>
%直列形の~BestFriend ~LET %値 の `~BestFriend^i 値の`下位直列化$
◎
Let serializedBestFriend be the sub-serialization of value's associated best friend value.
</li>
			<li>
%直列形 . `BestFriend^sl ~SET %直列形の~BestFriend
◎
Set serialized.[[BestFriend]] to serializedBestFriend.
</li>
		</ol>
    </dd>

	<dt>
`逆直列化~手続き$
◎
deserialization steps
</dt>
	<dd>
		<ol>
			<li>
%値 の `~name^i 値 ~SET %直列形 . `Name^sl
◎
Set value's associated name value to serialized.[[Name]].
</li>
			<li>
%逆直列形の~BestFriend ~LET %直列形 . `BestFriend^sl の`下位逆直列化$
◎
Let deserializedBestFriend be the sub-deserialization of serialized.[[BestFriend]].
</li>
			<li>
%値 の `~BestFriend^i  ~SET %逆直列形の~BestFriend
◎
Set value's associated best friend value to deserializedBestFriend.
</li>
		</ol>
	</dd>
</dl>
</div>

<p>
~JS仕様にて定義される各種~objは、`StructuredSerialize$jA 抽象演算により直接的に取扱われる。
◎
Objects defined in the JavaScript specification are handled by the StructuredSerialize abstract operation directly.
</p>

<p class="note">注記：
<a id="cloneable-objects"></a>
元々，この仕様は、ある`~Realm$から別へ~cloneすることもできる
“~clone可能な~obj” の概念を定義していた。
しかしながら，ある種のより複雑な状況~下での挙動をより良く指定するため、直列化と逆直列化を明示的に与えるよう，この~modelは更新された。
◎
Originally, this specification defined the concept of "cloneable objects", which could be cloned from one JavaScript Realm to another. However, to better specify the behavior of certain more complex situations, the model was updated to make the serialization and deserialization explicit.
</p>

			</section>
			<section id="transferable-objects">
<h3 title="Transferable objects">2.7.2. 転送-可能な~obj</h3>

<p>
`転送-可能$な~objは、`~event-loop$間をまたぐ転送を~supportする。
~obj %O の転送は、実質的に，
%O と同じ下層の~dataを参照するような~objを作成し直す一方で，転送-側から %O を切離すことである。
これは、高価な資源の所有権を転送するときに，有用になる。
~objには`転送-可能$でないものもあり、`転送-可能$なものでも そのすべての側面が転送-時に保全されるとは限らない。
◎
Transferable objects support being transferred across event loops. Transferring is effectively recreating the object while sharing a reference to the underlying data and then detaching the object being transferred. This is useful to transfer ownership of expensive resources. Not all objects are transferable objects and not all aspects of objects that are transferable objects are necessarily preserved when transferred.
</p>

<p class="note">注記：
転送は、不可逆であり，冪等でない演算である。
~objを転送した側は、それを再び 転送する／利用することはできなくなる。
◎
Transferring is an irreversible and non-idempotent operation. Once an object has been transferred, it cannot be transferred, or indeed used, again.
</p>


<p>
`~platform~obj$は、
`Transferable@xA
~IDL`拡張属性$が付与された~interfaceのみを実装するならば、`転送-可能$である。
そのような~interfaceは，次の~algoも定義し~MUST（括弧内は入力）：
◎
Platform objects can be transferable objects if they implement only interfaces decorated with the [Transferable] IDL extended attribute. Such interfaces must also define the following algorithms:
</p>

<dl>

	<dt>
`転送-手続き@( `~platform~obj$ %値, `Record$js %~data保持体 )
◎
transfer steps, taking a platform object value and a Record dataHolder
</dt>
	<dd>
%値 内の~dataを %~data保持体 の各~fieldの中に転送するための手続き。
%~data保持体 内に保持される結果の~dataは、どの`~Realm$からも独立で~MUST。
◎
A set of steps that transfers the data in value into fields of dataHolder. The resulting data held in dataHolder must be independent of any JavaScript Realm.
</dd>
	<dd>
この手続きは、転送を行えない場合は，例外を投出してもよい／し得る。
◎
These steps may throw an exception if transferral is not possible.
</dd>

	<dt>
`転送-受信-時の手続き@( `Record$js %~data保持体, `~platform~obj$ %値 )
◎
transfer-receiving steps, taking a Record dataHolder and a platform object value
</dt>
	<dd>
%~data保持体 内の~dataを受信するための手続き。
%値 は，新たな［
当の`~platform~obj$の型の~instance
］であり、その内部~dataは何も設定されてないものになる
— それを設定しておくのが、この手続きの仕事である。
◎
A set of steps that receives the data in dataHolder, using it to set up value as appropriate. value will be a newly-created instance of the platform object type in question, with none of its internal data set up; setting that up is the job of these steps.
</dd>
	<dd>
この手続きは、転送を受信できない場合は，例外を投出してもよい／し得る。
◎
These steps may throw an exception if it is not possible to receive the transfer.
</dd>
</dl>


<p>
これらの手続きにより どの~dataを転送するか決定するのは、個々の~platform~objの定義に委ねられる。
この 2 つの手続きは、概して対称になる。
◎
It is up to the definition of individual platform objects to determine what data is transferred by these steps. Typically the steps are very symmetric.
</p>

<div>
<p>
`Transferable$xA
拡張属性は：
</p>
<ul> <li>引数をとっては~MUST_NOT。
</li><li>~interface以外に現れては~MUST_NOT。
</li><li>~interfaceに現れるのは一度限りで~MUST。
</li><li>~callback~interface上に利用されては~MUST_NOT。
</li><li>［
`部分的~interface$ ／ `~interface~mixin$
］上に現れる場合、［
その元の~interface ／ それを`内包している~interface$
］にも現れ~MUST
— 前者~用に給された［
`直列化~手続き$や`逆直列化~手続き$
］があれば、それらは後者に付加されているものと解されるべきである。
</li></ul>
◎
The [Transferable] extended attribute must take no arguments, and must not appear on anything other than an interface. It must appear only once on an interface. It must not be used on a callback interface. If it appears on a partial interface or an interface that is really a mixin, then it must also appear on the original or mixed-in-to interface, and any supplied serialization steps and deserialization steps for the partial interface or mixin should be understood as being appended to those of the original or mixed-in-to interface.
</div>

<p>
`~platform~obj$のうち，`転送-可能$なものは、
`Detached@sl
内部~slotを持つ。
これは、［
転送された~platform~objは，再度~転送され得ない
］ことを確保するために利用される。
◎
Platform objects that are transferable objects have a [[Detached]] internal slot. This is used to ensure that once a platform object has been transferred, it cannot be transferred again.
</p>

<p>
~JS仕様にて定義される各種~objは、
`StructuredSerializeWithTransfer$jA
抽象演算により直接的に取扱われる。
◎
Objects defined in the JavaScript specification are handled by the StructuredSerializeWithTransfer abstract operation directly.
</p>

			</section>
			<section id="structuredserializeinternal">
<h3 title="StructuredSerializeInternal ( value, forStorage [ , memory ] )">2.7.3. `StructuredSerializeInternal^jA ( %値, %蓄積用 [ , %memory ] )</h3>

<p>
`StructuredSerializeInternal$jA 抽象演算は、~JS値（ %値 ）を入力にとり，それを`~Realm$から独立な形に直列化する
— ここでは `Record$js として表現される。
この直列化された形は、後に異なる~Realm内で新たな~JS値に逆直列化するときに必要とされるすべての情報を持つ。
◎
The StructuredSerializeInternal abstract operation takes as input a JavaScript value value and serializes it to a Realm-independent form, represented here as a Record. This serialized form has all the information necessary to later deserialize into a new JavaScript value in a different Realm.
</p>

<p>
この処理-は、例外を投出し得る
— 例えば、`直列化-可能$でない~objを直列化しようと試行したとき。
◎
This process can throw an exception, for example when trying to serialize un-serializable objects.
</p>

<ol>
	<li>
<p>
~IF［
%memory は給されてない
］
⇒
%memory ~LET 空`~map$
◎
If memory was not supplied, let memory be an empty map.
</p>

<p class="note">注記：
%memory ~mapの目的は、~objが重ねて直列化されるのを避けることにある。
これには、循環参照を保全して，~graphにおける~objの重複を識別することが必要になる。
◎
The purpose of the memory map is to avoid serializing objects twice. This ends up preserving cycles and the identity of duplicate objects in graphs.
</p>
	</li>
	<li>
~IF［
%memory[ %値 ] ~NEQ ε
］
⇒
~RET %memory[ %値 ]
◎
If memory[value] exists, then return memory[value].
</li>
	<li>
%deep ~LET ~F
◎
Let deep be false.
</li>
	<li>
~IF［
`Type$jA( %値 ) ~IN {
`Undefined^jC,
`Null^jC,
`Boolean^jC,
`Number^jC,
`BigInt^jC,
`String^jC
}
］
⇒
~RET {
`Type^sl: `primitive^l,
`Value^sl: %値
}
◎終
`JSBIGINT$r
◎
If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String, then return { [[Type]]: "primitive", [[Value]]: value }. [JSBIGINT]
</li>
	<li>
~IF［
`Type$jA( %値 ) ~EQ `Symbol^jC
］
⇒
~THROW `DataCloneError$E
◎
If Type(value) is Symbol, then throw a "DataCloneError" DOMException.
</li>
	<li>
%直列形 ~LET ε
◎
Let serialized be an uninitialized value.
</li>
	<li>
~IF［
%値 . `BooleanData^sl ~NEQ ε
］
⇒
%直列形 ~SET {
`Type^sl: `Boolean^l,
`BooleanData^sl: %値 . `BooleanData^sl
}
◎
If value has a [[BooleanData]] internal slot, then set serialized to { [[Type]]: "Boolean", [[BooleanData]]: value.[[BooleanData]] }.
</li>
	<li>
~ELIF［
%値 . `NumberData^sl ~NEQ ε
］
⇒
%直列形 ~SET {
`Type^sl: `Number^l,
`NumberData^sl: %値 . `NumberData^sl
}
◎
Otherwise, if value has a [[NumberData]] internal slot, then set serialized to { [[Type]]: "Number", [[NumberData]]: value.[[NumberData]] }.
</li>
	<li>
~ELIF［
%値 . `BigIntData^sl ~NEQ ε
］
⇒
%直列形 ~SET {
`Type^sl: `BigInt^l,
`BigIntData^sl: %値 . `BigIntData^sl
}
◎終
`JSBIGINT$r
◎
Otherwise, if value has a [[BigIntData]] internal slot, then set serialized to { [[Type]]: "BigInt", [[BigIntData]]: value.[[BigIntData]] }. [JSBIGINT]
</li>
	<li>
~ELIF［
%値 . `StringData^sl ~NEQ ε
］
⇒
%直列形 ~SET {
`Type^sl: `String^l,
`StringData^sl: %値 . `StringData^sl
}
◎
Otherwise, if value has a [[StringData]] internal slot, then set serialized to { [[Type]]: "String", [[StringData]]: value.[[StringData]] }.
</li>
	<li>
~ELIF［
%値 . `DateValue^sl ~NEQ ε
］
⇒
%直列形 ~SET {
`Type^sl: `Date^l,
`DateValue^sl: %値 . `DateValue^sl
}
◎
Otherwise, if value has a [[DateValue]] internal slot, then set serialized to { [[Type]]: "Date", [[DateValue]]: value.[[DateValue]] }.
</li>
	<li>
~ELIF［
%値 . `RegExpMatcher^sl ~NEQ ε
］
⇒
%直列形 ~SET {
`Type^sl: `RegExp^l,
`RegExpMatcher^sl: %値 . `RegExpMatcher^sl,
`OriginalSource^sl: %値 . `OriginalSource^sl,
`OriginalFlags^sl: %値 . `OriginalFlags^sl
}
◎
Otherwise, if value has a [[RegExpMatcher]] internal slot, then set serialized to { [[Type]]: "RegExp", [[RegExpMatcher]]: value.[[RegExpMatcher]], [[OriginalSource]]: value.[[OriginalSource]], [[OriginalFlags]]: value.[[OriginalFlags]] }.
</li>
	<li>
<p>
~ELIF［
%値 . `ArrayBufferData^sl ~NEQ ε
］：
◎
Otherwise, if value has an [[ArrayBufferData]] internal slot, then:
</p>
		<ol>
			<li>
%~size ~LET %値 . `ArrayBufferByteLength^sl
◎
Let size be value.[[ArrayBufferByteLength]].
</li>
			<li>
<p>
~IF［
! `IsSharedArrayBuffer$jA( %値 ) ~EQ ~T
］：
◎
If ! IsSharedArrayBuffer(value) is true, then:
</p>
				<ol>
					<li>
~IF［
%蓄積用 ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If forStorage is true, then throw a "DataCloneError" DOMException.
</li>
					<li>
%直列形 ~SET {
`Type^sl: `SharedArrayBuffer^l,
`ArrayBufferData^sl: %値 . `ArrayBufferData^sl,
`ArrayBufferByteLength^sl: %~size,
`AgentCluster^sl: `現在の~Realm~Record$に対応する`~agent-cluster$
}
◎
Set serialized to { [[Type]]: "SharedArrayBuffer", [[ArrayBufferData]]: value.[[ArrayBufferData]], [[ArrayBufferByteLength]]: size, [[AgentCluster]]: the current Realm Record's corresponding agent cluster }.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~IF［
! `IsDetachedBuffer$jA( %値 ) ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If ! IsDetachedBuffer(value) is true, then throw a "DataCloneError" DOMException.
</li>
					<li>
<p>
%~dataの複製 ~LET
? `CreateByteDataBlock$jA( %~size )
◎
Let dataCopy be ? CreateByteDataBlock(size).
</p>

<p class="note">注記：
これは、割当ての失敗に際しては `RangeError$E 例外を投出し得る
◎
This can throw a RangeError exception upon allocation failure.
</p>
					</li>
					<li>
! `CopyDataBlockBytes$jA( %~dataの複製, 0, %値 . `ArrayBufferData^sl, 0, %~size )
を遂行する
◎
Perform ! CopyDataBlockBytes(dataCopy, 0, value.[[ArrayBufferData]], 0, size).
</li>
					<li>
%直列形 ~SET {
`Type^sl: `ArrayBuffer^l,
`ArrayBufferData^sl: %~dataの複製,
`ArrayBufferByteLength^sl: %~size
}
◎
Set serialized to { [[Type]]: "ArrayBuffer", [[ArrayBufferData]]: dataCopy, [[ArrayBufferByteLength]]: size }.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%値 . `ViewedArrayBuffer^sl ~NEQ ε
］：
◎
Otherwise, if value has a [[ViewedArrayBuffer]] internal slot, then:
</p>
		<ol>
			<li>
%~buffer ~LET %値 . `ViewedArrayBuffer^sl
◎
Let buffer be the value of value's [[ViewedArrayBuffer]] internal slot.
</li>
			<li>
%~buffer直列形 ~LET
? `StructuredSerializeInternal$jA( %~buffer, %蓄積用, %memory )
◎
Let bufferSerialized be ? StructuredSerializeInternal(buffer, forStorage, memory).
</li>
			<li>
~Assert：
%~buffer直列形 . `Type^sl ~EQ `ArrayBuffer^l
◎
Assert: bufferSerialized.[[Type]] is "ArrayBuffer".
</li>
			<li>
~IF［
%値 . `DataView^sl ~NEQ ε
］
⇒
%直列形 ~SET {
`Type^sl: `ArrayBufferView^l,
`Constructor^sl: `DataView^l,
`ArrayBufferSerialized^sl: %~buffer直列形,
`ByteLength^sl: %値 . `ByteLength^sl,
`ByteOffset^sl: %値 . `ByteOffset^sl
}
◎
If value has a [[DataView]] internal slot, then set serialized to { [[Type]]: "ArrayBufferView", [[Constructor]]: "DataView", [[ArrayBufferSerialized]]: bufferSerialized, [[ByteLength]]: value.[[ByteLength]], [[ByteOffset]]: value.[[ByteOffset]] }.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~Assert：
%値 . `TypedArrayName^sl ~NEQ ε
◎
Assert: value has a [[TypedArrayName]] internal slot.
</li>
					<li>
%直列形 ~SET {
`Type^sl: `ArrayBufferView^l,
`Constructor^sl: %値 . `TypedArrayName^sl,
`ArrayBufferSerialized^sl: %~buffer直列形,
`ByteLength^sl: %値 . `ByteLength^sl,
`ByteOffset^sl: %値 . `ByteOffset^sl,
`ArrayLength^sl: %値 . `ArrayLength^sl
}
◎
Set serialized to { [[Type]]: "ArrayBufferView", [[Constructor]]: value.[[TypedArrayName]], [[ArrayBufferSerialized]]: bufferSerialized, [[ByteLength]]: value.[[ByteLength]], [[ByteOffset]]: value.[[ByteOffset]], [[ArrayLength]]: value.[[ArrayLength]] }.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%値 . `MapData^sl ~NEQ ε
］：
◎
Otherwise, if value has [[MapData]] internal slot, then:
</p>
		<ol>
			<li>
%直列形 ~SET {
`Type^sl: `Map^l,
`MapData^sl: 新たな空`List$js
}
◎
Set serialized to { [[Type]]: "Map", [[MapData]]: a new empty List }.
</li>
			<li>
%deep ~SET ~T
◎
Set deep to true.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%値 . `SetData^sl ~NEQ ε
］：
◎
Otherwise, if value has [[SetData]] internal slot, then:
</p>
		<ol>
			<li>
%直列形 ~SET {
`Type^sl: `Set^l,
`SetData^sl: 新たな空`List$js
}
◎
Set serialized to { [[Type]]: "Set", [[SetData]]: a new empty List }.
</li>
			<li>
%deep ~SET ~T
◎
Set deep to true.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%値 は `Array^jC ~exotic~objである
］：
◎
Otherwise, if value is an Array exotic object, then:
</p>
		<ol>
			<li>
%値~長さ記述子 ~LET
? `OrdinaryGetOwnProperty$jA( %値, `length^l )
◎
Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, "length").
</li>
			<li>
%値~長さ ~LET %値~長さ記述子 . `Value^sl
◎
Let valueLen be valueLenDescriptor.[[Value]].
</li>
			<li>
%直列形 ~SET {
`Type^sl: `Array^l,
`Length^sl: %値~長さ,
`Properties^sl: 新たな空 `List$js
}
◎
Set serialized to { [[Type]]: "Array", [[Length]]: valueLen, [[Properties]]: a new empty List }.
</li>
			<li>
%deep ~SET ~T
◎
Set deep to true.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%値 は`直列化-可能$な`~platform~obj$である
］：
◎
Otherwise, if value is a platform object that is a serializable object:
</p>
		<ol>
			<li>
~IF［
%値 . `Detached$sl ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If value has a [[Detached]] internal slot whose value is true, then throw a "DataCloneError" DOMException.
</li>
			<li>
%型~文字列 ~LET %値 の`首~interface$の識別子
◎
Let typeString be the identifier of the primary interface of value.
</li>
			<li>
%直列形 ~SET {
`Type^sl: %型~文字列
}
◎
Set serialized to { [[Type]]: typeString }.
</li>
			<li>
%deep ~SET ~T
◎
Set deep to true.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%値 は`~platform~obj$である
］
⇒
~THROW `DataCloneError$E
◎
Otherwise, if value is a platform object, then throw a "DataCloneError" DOMException.
</li>
	<li>
~ELIF［
`IsCallable$jA( %値 ) ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
Otherwise, if IsCallable(value) is true, then throw a "DataCloneError" DOMException.
</li>
	<li>
<p>
~ELIF［
%値 は［
`Prototype^sl, `Extensible^sl
］以外の内部~slotを持つ
］
⇒
~THROW `DataCloneError$E
◎
Otherwise, if value has any internal slot other than [[Prototype]] or [[Extensible]], then throw a "DataCloneError" DOMException.
</p>

<p class="example">
具体的には、［
`PromiseState^sl ／ `WeakMapData^sl
］内部~slot。
◎
For instance, a [[PromiseState]] or [[WeakMapData]] internal slot.
</p>
	</li>
	<li>
<p>
~ELIF［
%値 は~exotic~objである
］
⇒
~THROW `DataCloneError$E
◎
Otherwise, if value is an exotic object, then throw a "DataCloneError" DOMException.
</p>

<p class="example">
具体的には、 proxy ~obj。
【~JS の Proxy ~obj？】
◎
For instance, a proxy object.
</p>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%直列形 ~SET {
`Type^sl: `Object^l,
`Properties^sl: 新たな空`List$js
}
◎
Set serialized to { [[Type]]: "Object", [[Properties]]: a new empty List }.
</li>
			<li>
%deep ~SET ~T
◎
Set deep to true.
</li>
		</ol>
	</li>
	<li>
%memory[ %値 ] `~SET$ %直列形
◎
Set memory[value] to serialized.
</li>
	<li>
<p>
~IF［
%deep ~EQ ~T
］：
◎
If deep is true, then:
</p>
		<ol>
			<li>
<p>
~IF［
%値 . `MapData^sl ~NEQ ε
］：
◎
If value has a [[MapData]] internal slot, then:
</p>
				<ol>
					<li>
%複製した~list ~LET 新たな空`List$js
◎
Let copiedList be a new empty List.
</li>
					<li>
<p>
%値 . `MapData^sl 内の`~EACH$( `Record$js %~entry ) に対し：
◎
For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]:
</p>
						<ol>
							<li>
%複製した~entry ~LET 新たな `Record$js {
`Key^sl: %~entry . `Key^sl,
`Value^sl: %~entry . `Value^sl
}
◎
Let copiedEntry be a new Record { [[Key]]: entry.[[Key]], [[Value]]: entry.[[Value]] }.
</li>
							<li>
~IF［
%複製した~entry . `Key^sl ~NEQ 特殊~値 `empty^i
］
⇒
%複製した~list に %複製した~entry を`付加する$
◎
If copiedEntry.[[Key]] is not the special value empty, append copiedEntry to copiedList.
</li>
						</ol>
					</li>
					<li>
<p>
%複製した~list 内の`~EACH$( `Record$js %~entry ) に対し：
◎
For each Record { [[Key]], [[Value]] } entry of copiedList:
</p>
						<ol>
							<li>
%直列形の~key ~LET
? `StructuredSerializeInternal$jA( %~entry . `Key^sl, %蓄積用, %memory )
◎
Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).
</li>
							<li>
%直列形の値 ~LET
? `StructuredSerializeInternal$jA( %~entry . `Value^sl, %蓄積用, %memory )
◎
Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).
</li>
							<li>
%直列形 . `MapData^sl に
{
`Key^sl: %直列形の~key,
`Value^sl: %直列形の値
} を`付加する$
◎
Append { [[Key]]: serializedKey, [[Value]]: serializedValue } to serialized.[[MapData]].
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%値 . `SetData^sl ~NEQ ε
］：
◎
Otherwise, if value has a [[SetData]] internal slot, then:
</p>

				<ol>
					<li>
%複製した~list ~LET 新たな空`List$js
◎
Let copiedList be a new empty List.
</li>
					<li>
<p>
%値 . `SetData^sl 内の`~EACH$( %~entry ) に対し：
◎
For each entry of value.[[SetData]]:
</p>
						<ol>
							<li>
~IF［
%~entry ~NEQ 特殊~値 `empty^i
］
⇒
%複製した~list に %~entry を`付加する$
◎
If entry is not the special value empty, append entry to copiedList.
</li>
						</ol>
					</li>
					<li>
<p>
%複製した~list 内の`~EACH$( %~entry ) に対し：
◎
For each entry of copiedList:
</p>
						<ol>
							<li>
%直列形の~entry ~LET
? `StructuredSerializeInternal$jA( %~entry, %蓄積用, %memory )
◎
Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).
</li>
							<li>
%直列形 . `SetData^sl に %直列形の~entry を`付加する$
◎
Append serializedEntry to serialized.[[SetData]].
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%値 は`直列化-可能$な`~platform~obj$である
］
⇒
適切な`直列化~手続き$( %値, %直列形, %蓄積用 )
を遂行する
◎
Otherwise, if value is a platform object that is a serializable object, then perform the appropriate serialization steps given value, serialized, and forStorage.
</p>

<p>
`直列化~手続き$は
`下位直列化@
を遂行することも必要になり得る。
これは、値 %下位~値 を入力にとり，
`StructuredSerializeInternal$jA( %下位~値, %蓄積用, %memory )
を返す演算である。
（言い換えれば、`下位直列化$は，この呼出の中に整合するよう特化された `StructuredSerializeInternal$jA である。）
◎
The serialization steps may need to perform a sub-serialization. This is an operation which takes as input a value subValue, and returns StructuredSerializeInternal(subValue, forStorage, memory). (In other words, a sub-serialization is a specialization of StructuredSerializeInternal to be consistent within this invocation.)
</p>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%列挙-可能~key~list ~LET 新たな空`List$js

◎
Let enumerableKeys be a new empty List.
</li>
					<li>
<p>
! %値 . `OwnPropertyKeys^sl() 内の~EACH( %~key ) に対し：
◎
For each key in ! value.[[OwnPropertyKeys]]():
</p>
						<ol>
							<li>
<p>
~IF［
`Type$jA( %~key ) ~EQ `String^jC
］：
◎
If Type(key) is String, then:
</p>
								<ol>
									<li>
%値~記述子 ~LET  
! %値 . `GetOwnProperty^sl( %~key )
◎
Let valueDesc be ! value.[[GetOwnProperty]](key).
</li>
									<li>
~IF［
%値~記述子 . `Enumerable^sl ~EQ ~T
］
⇒
%列挙-可能~key~list に %~key を`付加する$
◎
If valueDesc.[[Enumerable]] is true, then append key to enumerableKeys.
</li>
								</ol>
							</li>
						</ol>
					</li>
					<li>
<p>
%列挙-可能~key~list 内の~EACH( %~key ) に対し：
◎
For each key in enumerableKeys:
</p>
						<ol>
							<li>
<p>
~IF［
! `HasOwnProperty$jA( %値, %~key ) ~EQ ~T
］：
◎
If ! HasOwnProperty(value, key) is true, then:
</p>
								<ol>
									<li>
%入力~値 ~LET
? %値 . `Get^sl( %~key, %値 )
◎
Let inputValue be ? value.[[Get]](key, value).
</li>
									<li>
%出力~値 ~LET
? `StructuredSerializeInternal$jA( %入力~値, %蓄積用, %memory )
◎
Let outputValue be ? StructuredSerializeInternal(inputValue, forStorage, memory).
</li>
									<li>
%直列形 . `Properties^sl に
{
`Key^sl: %~key,
`Value^sl: %出力~値
} を`付加する$
◎
Append { [[Key]]: key, [[Value]]: outputValue } to serialized.[[Properties]].
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>

<p class="note">注記：
上で遂行される~key収集は，~JS仕様の `EnumerableOwnProperties$jA 演算によく似ているが、その演算のように~keyたちを未指定の方式で並替えることなく，
`OwnPropertyKeys^sl 内部~methodが供する決定的順序を利用する。
`JAVASCRIPT$r
◎
The key collection performed above is very similar to the JavaScript specification's EnumerableOwnProperties operation, but crucially it uses the deterministic ordering provided by the [[OwnPropertyKeys]] internal method, instead of reordering the keys in an unspecified manner as EnumerableOwnProperties does. [JAVASCRIPT]
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %直列形
◎
Return serialized.
</li>
</ol>

<div class="example">
<p>
`StructuredSerializeInternal$jA から生産される `Record$js は、参照を循環させるような，他の~recordへの “~pointer” を包含し得ることに要注意。
例えば、次の~JS~objを `StructuredSerializeInternal$jA に渡したとするとき：
◎
It's important to realize that the Records produced by StructuredSerializeInternal might contain "pointers" to other records that create circular references. For example, when we pass the following JavaScript object into StructuredSerializeInternal:
</p>

<pre>
const %o = {};
%o.myself = %o;
</pre>

<p>
次の結果が生産される：
◎
it produces the following result:
</p>

<pre>
{
  `Type^sl: `Object^l,
  `Properties^sl: «
    {
      `Key^sl: `myself^l,
      `Value^sl: `&lt;この構造~全体を指す~pointer&gt;^i
    }
  »
}
</pre>

<!-- 
a pointer to this whole structure
 -->

</div>

			</section>
			<section id="structuredserialize">
<h3 title="StructuredSerialize ( value )">2.7.4. `StructuredSerialize^jA ( %値 )</h3>

<ol>
	<li>
~RET
? `StructuredSerializeInternal$jA( %値, ~F )
◎
Return ? StructuredSerializeInternal(value, false).
</li>
</ol>

			</section>
			<section id="structuredserializeforstorage">
<h3 title="StructuredSerializeForStorage ( value )">2.7.5. `StructuredSerializeForStorage^jA ( %値 )</h3>

<ol>
	<li>
~RET
? `StructuredSerializeInternal$jA( %値, ~T )
◎
Return ? StructuredSerializeInternal(value, true).
</li>
</ol>

			</section>
			<section id="structureddeserialize">
<h3 title="StructuredDeserialize ( serialized, targetRealm [ , memory ] )">2.7.6. `StructuredDeserialize^jA ( %直列形, %宛先~Realm [ , %memory ] )</h3>

<p>
`StructuredDeserialize$jA 抽象演算は、以前に［
`StructuredSerialize$jA ／
`StructuredSerializeForStorage$jA
］が生産した `Record$js %直列形
を入力にとり，［
%宛先~Realm に属する新たな~JS値
］に逆直列化する：
◎
The StructuredDeserialize abstract operation takes as input a Record serialized, which was previously produced by StructuredSerialize or StructuredSerializeForStorage, and deserializes it into a new JavaScript value, created in targetRealm.
</p>

<p>
この処理-は、例外を投出し得る
— 例えば，新たな~obj用に~memoryを割当てようと試行したとき（とりわけ， `ArrayBuffer^jC ~obj）。
◎
This process can throw an exception, for example when trying to allocate memory for the new objects (especially ArrayBuffer objects).
</p>

<ol>
	<li>
<p>
~IF［
%memory は給されてない
］
⇒
%memory ~LET 空`~map$
◎
If memory was not supplied, let memory be an empty map.
</p>

<p class="note">注記：
%memory ~mapの目的は、~objが重ねて逆直列化されるのを避けることにある。
これには、循環参照を保全して，~graphにおける~objの重複を識別することが必要になる。
◎
The purpose of the memory map is to avoid deserializing objects twice. This ends up preserving cycles and the identity of duplicate objects in graphs.
</p>
	</li>
	<li>
~IF［
%memory[ %直列形 ] ~NEQ ε
］
⇒
~RET %memory[ %直列形 ] 
◎
If memory[serialized] exists, then return memory[serialized].
</li>
	<li>
%deep ~LET ~F
◎
Let deep be false.
</li>
	<li>
%値 ~LET ε
◎
Let value be an uninitialized value.
</li>
	<li>
<p>
%直列形 . `Type^sl に応じて：
◎
↓</p>

		<ol class="switch">
			<li>
`primitive^l
⇒
%値 ~SET %直列形 . `Value^sl
◎
If serialized.[[Type]] is "primitive", then set value to serialized.[[Value]].
</li>
			<li>
`Boolean^l
⇒
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `Boolean^jC ~obj
⇒
. `BooleanData^sl ~SET %直列形 . `BooleanData^sl
◎
Otherwise, if serialized.[[Type]] is "Boolean", then set value to a new Boolean object in targetRealm whose [[BooleanData]] internal slot value is serialized.[[BooleanData]].
</li>
			<li>
`Number^l
⇒
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `Number^jC ~obj
⇒
. `NumberData^sl ~SET %直列形 . `NumberData^sl
◎
Otherwise, if serialized.[[Type]] is "Number", then set value to a new Number object in targetRealm whose [[NumberData]] internal slot value is serialized.[[NumberData]].
</li>
			<li>
`BigInt^l `JSBIGINT$r
⇒
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `BigInt^jC ~obj
⇒
. `BigIntData^sl ~SET %直列形 . `BigIntData^sl
◎
Otherwise, if serialized.[[Type]] is "BigInt", then set value to a new BigInt object in targetRealm whose [[BigIntData]] internal slot value is serialized.[[BigIntData]]. [JSBIGINT]
</li>
			<li>
`String^l
⇒
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `String^jC ~obj
⇒
. `StringData^sl ~SET %直列形 . `StringData^sl
◎
Otherwise, if serialized.[[Type]] is "String", then set value to a new String object in targetRealm whose [[StringData]] internal slot value is serialized.[[StringData]].
</li>
			<li>
`Date^l
⇒
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `Date^jC ~obj
⇒
. `DateValue^sl ~SET %直列形 . `DateValue^sl
◎
Otherwise, if serialized.[[Type]] is "Date", then set value to a new Date object in targetRealm whose [[DateValue]] internal slot value is serialized.[[DateValue]].
</li>
			<li>
`RegExp^l
⇒
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `RegExp^jC ~obj
⇒＃
. `RegExpMatcher^sl ~SET %直列形 . `RegExpMatcher^sl,
. `OriginalSource^sl ~SET %直列形 . `OriginalSource^sl,
. `OriginalFlags^sl ~SET %直列形 . `OriginalFlags^sl
◎
Otherwise, if serialized.[[Type]] is "RegExp", then set value to a new RegExp object in targetRealm whose [[RegExpMatcher]] internal slot value is serialized.[[RegExpMatcher]], whose [[OriginalSource]] internal slot value is serialized.[[OriginalSource]], and whose [[OriginalFlags]] internal slot value is serialized.[[OriginalFlags]].
</li>
			<li>
<p>
`SharedArrayBuffer^l：
◎
Otherwise, if serialized.[[Type]] is "SharedArrayBuffer", then:
</p>
				<ol>
					<li>
~IF［
%宛先~Realm に対応する`~agent-cluster$ ~NEQ  %直列形 . `AgentCluster^l
］
⇒
~THROW `DataCloneError$E
◎
If targetRealm's corresponding agent cluster is not serialized.[[AgentCluster]], then then throw a "DataCloneError" DOMException.
</li>
					<li>
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `SharedArrayBuffer^jC ~obj
⇒＃
. `ArrayBufferData^sl ~SET %直列形 . `ArrayBufferData^sl,
. `ArrayBufferByteLength^sl ~SET %直列形 . `ArrayBufferByteLength^sl
◎
Otherwise, set value to a new SharedArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot value is serialized.[[ArrayBufferData]] and whose [[ArrayBufferByteLength]] internal slot value is serialized.[[ArrayBufferByteLength]].
</li>
				</ol>
			</li>
			<li>
<p>
`ArrayBuffer^l：
◎
Otherwise, if serialized.[[Type]] is "ArrayBuffer", then＼
</p>
				<ol>
					<li>
<p>
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `ArrayBuffer^jC ~obj
⇒＃
. `ArrayBufferData^sl ~SET %直列形 . `ArrayBufferData^sl,
. `ArrayBufferByteLength^sl ~SET %直列形 . `ArrayBufferByteLength^sl
◎
set value to a new ArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot value is serialized.[[ArrayBufferData]], and whose [[ArrayBufferByteLength]] internal slot value is serialized.[[ArrayBufferByteLength]].
</p>

<p>
ここで例外が投出されたときは、~catchして
⇒
~THROW `DataCloneError$E
◎
If this throws an exception, catch it, and then throw a "DataCloneError" DOMException.
</p>
					</li>
				</ol>

<p class="note">注記：
この段にて例外が投出されるのは、
`ArrayBuffer^jC ~objを作成するに十分な~memoryが可用でない場合である。
◎
This step might throw an exception if there is not enough memory available to create such an ArrayBuffer object.
</p>
			</li>
			<li>
<p>
`ArrayBufferView^l：
◎
Otherwise, if serialized.[[Type]] is "ArrayBufferView", then:
</p>
				<ol>
					<li>
%逆直列形の~ArrayBuffer ~LET
? `StructuredDeserialize$jA( %直列形 . `ArrayBufferSerialized^sl, %宛先~Realm, %memory )
◎
Let deserializedArrayBuffer be ? StructuredDeserialize(serialized.[[ArrayBufferSerialized]], targetRealm, memory).
</li>
					<li>
~IF［
%直列形 . `Constructor^sl ~EQ `DataView^l
］
⇒
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `DataView^jC ~obj
⇒＃
. `ViewedArrayBuffer^sl ~SET %逆直列形の~ArrayBuffer,
. `ByteLength^sl ~SET %直列形 . `ByteLength^sl,
. `ByteOffset^sl ~SET %直列形 . `ByteOffset^sl
◎
If serialized.[[Constructor]] is "DataView", then set value to a new DataView object in targetRealm whose [[ViewedArrayBuffer]] internal slot value is deserializedArrayBuffer, whose [[ByteLength]] internal slot value is serialized.[[ByteLength]], and whose [[ByteOffset]] internal slot value is serialized.[[ByteOffset]].
</li>
					<li>
~ELSE
⇒
%値 ~SET ［
%直列形 . `Constructor^sl が与える構築子を利用し, 次のようにされた， %宛先~Realm 内の新たな有型~配列~obj
］
⇒＃
. `ViewedArrayBuffer^sl ~SET %逆直列形の~ArrayBuffer,
. `TypedArrayName^sl ~SET %input . `Constructor^sl,
. `ByteLength^sl ~SET %直列形 . `ByteLength^sl,
. `ByteOffset^sl ~SET %直列形 . `ByteOffset^sl,
. `ArrayLength^sl ~SET %直列形 . `ArrayLength^sl
◎
Otherwise, set value to a new typed array object in targetRealm, using the constructor given by serialized.[[Constructor]], whose [[ViewedArrayBuffer]] internal slot value is deserializedArrayBuffer, whose [[TypedArrayName]] internal slot value is serialized.[[Constructor]], whose [[ByteLength]] internal slot value is serialized.[[ByteLength]], whose [[ByteOffset]] internal slot value is serialized.[[ByteOffset]], and whose [[ArrayLength]] internal slot value is serialized.[[ArrayLength]].
</li>
				</ol>
			</li>
			<li>
<p>
`Map^l：
◎
Otherwise, if serialized.[[Type]] is "Map", then:
</p>
				<ol>
					<li>
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `Map^jC ~obj
⇒
. `MapData^sl ~SET  新たな空`List$js
◎
Set value to a new Map object in targetRealm whose [[MapData]] internal slot value is a new empty List.
</li>
					<li>
%deep ~SET ~T
◎
Set deep to true.
</li>
				</ol>
			</li>
			<li>
<p>
`Set^l：
◎
Otherwise, if serialized.[[Type]] is "Set", then:
</p>
				<ol>
					<li>
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `Set^jC ~obj
⇒
. `SetData^sl ~SET 新たな空`List$js
◎
Set value to a new Set object in targetRealm whose [[SetData]] internal slot value is a new empty List.
</li>
					<li>
%deep ~SET ~T
◎
Set deep to true.
</li>
				</ol>
			</li>
			<li>
<p>
`Array^l：
◎
Otherwise, if serialized.[[Type]] is "Array", then:
</p>
				<ol>
					<li>
%出力~prototype ~LET %宛先~Realm 内の
`ArrayPrototype$jI 内在的~obj
◎
Let outputProto be the %ArrayPrototype% intrinsic object in targetRealm.
</li>
					<li>
%値 ~SET
! `ArrayCreate$jA( %直列形 . `Length^sl, %出力~prototype )
◎
Set value to ! ArrayCreate(serialized.[[Length]], outputProto).
</li>
					<li>
%deep ~SET ~T
◎
Set deep to true.
</li>
				</ol>
			</li>
			<li>
<p>
`Object^l：
◎
Otherwise, if serialized.[[Type]] is "Object", then:
</p>
				<ol>
					<li>
%値 ~SET %宛先~Realm 内の新たな `Object^jC
◎
Set value to a new Object in targetRealm.
</li>
					<li>
%deep ~SET ~T
◎
Set deep to true.
</li>
				</ol>
			</li>
			<li>
<p>
その他：
◎
Otherwise:
</p>
				<ol>
					<li>
%~interface名 ~LET %直列形 . `Type^sl
◎
Let interfaceName be serialized.[[Type]].
</li>
					<li>
~IF［
%~interface名 により識別される~interfaceは
%宛先~Realm 内に公開されていない
］
⇒
~THROW `DataCloneError$E
◎
If the interface identified by interfaceName is not exposed in targetRealm, then throw a "DataCloneError" DOMException.
</li>
					<li>
%値 ~SET %宛先~Realm 内に作成される，
%~interface名 により識別される~interfaceの新たな~instance
◎
Set value to a new instance of the interface identified by interfaceName, created in targetRealm.
</li>
					<li>
%deep ~SET ~T
◎
Set deep to true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%memory[ %直列形 ] `~SET$ %値
◎
Set memory[serialized] to value.
</li>
	<li>
~IF［
%deep ~EQ ~F
］
⇒
~RET %値
◎
↓</li>
	<li>
<p>
%直列形 . `Type^sl に応じて：
◎
If deep is true, then:
</p>
		<ol class="switch">
			<li>
<p>
`Map^l：
◎
If serialized.[[Type]] is "Map", then:
</p>
				<ol>
					<li>
<p>
%直列形 . `MapData^sl 内の`~EACH$( `Record$js %~entry ) に対し：
◎
For each Record { [[Key]], [[Value]] } entry of serialized.[[MapData]]:
</p>
						<ol>
							<li>
%逆直列形の~key ~LET
? `StructuredDeserialize$jA( %~entry . `Key^sl, %宛先~Realm, %memory )
◎
Let deserializedKey be ? StructuredDeserialize(entry.[[Key]], targetRealm, memory).
</li>
							<li>
%逆直列形の値 ~LET
? `StructuredDeserialize$jA( %~entry . `Value^sl, %宛先~Realm, %memory )
◎
Let deserializedValue be ? StructuredDeserialize(entry.[[Value]], targetRealm, memory).
</li>
							<li>
%値 . `MapData^sl に {
`Key^sl: %逆直列形の~key,
`Value^sl: %逆直列形の値
} を`付加する$
◎
Append { [[Key]]: deserializedKey, [[Value]]: deserializedValue } to value.[[MapData]].
</li>
						</ol>
					</li>
				</ol>
			</li>
		<li>
<p>
`Set^l：
◎
Otherwise, if serialized.[[Type]] is "Set", then:
</p>
				<ol>
					<li>
<p>
%直列形 . `SetData^sl 内の`~EACH$( %~entry ) に対し：
◎
For each entry of serialized.[[SetData]]:
</p>
						<ol>
							<li>
%逆直列形の~entry ~LET
? `StructuredDeserialize$jA( %~entry, %宛先~Realm, %memory )
◎
Let deserializedEntry be ? StructuredDeserialize(entry, targetRealm, memory).
</li>
							<li>
%値 . `SetData^sl に %逆直列形の~entry を`付加する$
◎
Append deserializedEntry to value.[[SetData]].
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
`Array^l ／ `Object^l：
◎
Otherwise, if serialized.[[Type]] is "Array" or "Object", then:
</p>

				<ol>
					<li>
<p>
%直列形 . `Properties^sl 内の`~EACH$( `Record$js %~entry ) に対し：
◎
For each Record { [[Key]], [[Value]] } entry of serialized.[[Properties]]:
</p>
						<ol>
							<li>
%逆直列形の値 ~LET
? `StructuredDeserialize$jA( %~entry . `Value^sl, %宛先~Realm, %memory )
◎
Let deserializedValue be ? StructuredDeserialize(entry.[[Value]], targetRealm, memory).
</li>
							<li>
%結果 ~LET
! `CreateDataProperty$jA( %値, %~entry . `Key^sl, %逆直列形の値 )
◎
Let result be ! CreateDataProperty(value, entry.[[Key]], deserializedValue).
</li>
							<li>
~Assert：
%結果 ~EQ ~T
◎
Assert: result is true.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
その他：
◎
Otherwise:
</p>
				<ol>
					<li>
<p>
%直列形 . `Type^sl により識別される~interface用に適切な`逆直列化~手続き$( %直列形, %値 )
を遂行する
◎
Perform the appropriate deserialization steps for the interface identified by serialized.[[Type]], given serialized and value.
</p>

<p>
`逆直列化~手続き$は、
`下位逆直列化@
を遂行することも必要になり得る。
これは、以前に直列化された `Record$js %下位直列形 を入力にとり，
`StructuredDeserialize$jA( %下位直列形, %宛先~Realm, %memory )
を返す演算である（言い換えれば、`下位逆直列化$は，この呼出の中で整合するよう特化された `StructuredDeserialize$jA である。）
◎
The deserialization steps may need to perform a sub-deserialization. This is an operation which takes as input a previously-serialized Record subSerialized, and returns StructuredDeserialize(subSerialized, targetRealm, memory). (In other words, a sub-deserialization is a specialization of StructuredDeserialize to be consistent within this invocation.)
</p>
					</li>
				</ol>
    		</li>
		</ol>
	</li>
	<li>
~RET %値
◎
Return value.
</li>
</ol>

			</section>
			<section id="structuredserializewithtransfer">
<h3 title="StructuredSerializeWithTransfer ( value, transferList )">2.7.7. `StructuredSerializeWithTransfer^jA ( %値, %転送-~list )</h3>

<ol>
	<li>
<p>
%memory ~LET 空`~map$
◎
Let memory be an empty map.
</p>

<p class="note">注記：
`StructuredSerializeInternal$jA による通常の用法に加えて，この~algoにおける %memory は、［
`StructuredSerializeInternal$jA が %転送-~list 内の~itemを無視して，代わりに自前の取扱いを行えるようにする
］ことを確保するためにも利用される。
◎
In addition to how it is used normally by StructuredSerializeInternal, in this algorithm memory is also used to ensure that StructuredSerializeInternal ignores items in transferList, and let us do our own handling instead.
</p>
	</li>
	<li>
<p>
%転送-~list 内の`~EACH$( %転送対象 ) に対し：
◎
For each transferable of transferList:
</p>
		<ol>
			<li>
~IF［
%転送対象 . `ArrayBufferData^sl ~EQ ε
］~AND［
%転送対象 . `Detached$sl ~EQ ε
］
⇒
~THROW `DataCloneError$E
◎
If transferable has neither an [[ArrayBufferData]] internal slot nor a [[Detached]] internal slot, then throw a "DataCloneError" DOMException.
</li>
			<li>
~IF［
%転送対象 . `ArrayBufferData^sl ~NEQ ε
］~AND［［
! `IsSharedArrayBuffer$jA( %転送対象 ) ~EQ ~T
］~OR［
! `IsDetachedBuffer$jA( %転送対象 ) ~EQ ~T
］］
⇒
~THROW `DataCloneError$E
◎
If transferable has an [[ArrayBufferData]] internal slot and either ! IsSharedArrayBuffer(transferable) is true or ! IsDetachedBuffer(transferable) is true, then throw a "DataCloneError" DOMException.
</li>
			<li>
~IF［
%転送対象 . `Detached$sl ~NEQ ε
］~AND［
%転送対象 . `Detached$sl ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If transferable has a [[Detached]] internal slot and transferable.[[Detached]] is true, then throw a "DataCloneError" DOMException.
</li>
			<li>
~IF［
%memory[ %転送対象 ] ~NEQ ε
］
⇒
~THROW `DataCloneError$E
◎
If memory[transferable] exists, then throw a "DataCloneError" DOMException.
</li>
			<li>
<p>
%memory[ %転送対象 ] `~SET$ {
`Type^sl: 初期化されていない値
}
【実質的には，空の~record】
◎
Set memory[transferable] to { [[Type]]: an uninitialized value }.
</p>

<p class="note">注記：
%転送対象 はまだ転送されない
— 転送には副作用があり， `StructuredSerializeInternal$jA は最初に投出-可能になる必要があるので。
◎
transferable is not transferred yet as transferring has side effects and StructuredSerializeInternal needs to be able to throw first.
</p>
			</li>
		</ol>
	</li>
	<li>
%直列形 ~LET
? `StructuredSerializeInternal$jA( %値, ~F, %memory )
◎
Let serialized be ? StructuredSerializeInternal(value, false, memory).
</li>
	<li>
%転送-~data保持体~list ~LET 新たな空`List$js

◎
Let transferDataHolders be a new empty List.
</li>
	<li>
<p>
%転送-~list 内の`~EACH$( %転送対象 ) に対し：
◎
For each transferable of transferList:
</p>
		<ol>
			<li>
%~data保持体 ~LET ε
◎
Let dataHolder be an uninitialized value.
</li>
			<li>
<p>
~IF［
%転送対象 . `ArrayBufferData^sl ~NEQ ε
］：
◎
If transferable has an [[ArrayBufferData]] internal slot, then:
</p>
				<ol>
					<li>
%~data保持体 の
⇒＃
. `Type^sl ~SET `ArrayBuffer^l,
. `ArrayBufferData^sl ~SET %転送対象 . `ArrayBufferData^sl,
. `ArrayBufferByteLength^sl ~SET %転送対象 . `ArrayBufferByteLength^sl
◎
Set dataHolder.[[Type]] to "ArrayBuffer".
◎
Set dataHolder.[[ArrayBufferData]] to transferable.[[ArrayBufferData]].
◎
Set dataHolder.[[ArrayBufferByteLength]] to transferable.[[ArrayBufferByteLength]].
</li>
					<li>
! `DetachArrayBuffer$jA( %転送対象 )
を遂行する
◎
Perform ! DetachArrayBuffer(transferable).
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~Assert：
%転送対象 は`転送-可能$な`~platform~obj$である
◎
Assert: transferable is a platform object that is a transferable object.
</li>
					<li>
%~interface名 ~LET %転送対象 の`首~interface$の識別子
◎
Let interfaceName be the identifier of the primary interface of transferable.
</li>
					<li>
%~data保持体 . `Type^sl ~SET %~interface名
◎
Set dataHolder.[[Type]] to interfaceName.
</li>
					<li>
%~interface名 により識別される~interfaceに適切な`転送-手続き$( %転送対象, %~data保持体 )
を遂行する
◎
Perform the appropriate transfer steps for the interface identified by interfaceName, given transferable and dataHolder.
</li>
					<li>
%転送対象 . `Detached$sl ~SET ~T
◎
Set transferable.[[Detached]] to true.
</li>
				</ol>
			</li>
			<li>
%転送-~data保持体~list に %~data保持体 を`付加する$
◎
Append dataHolder to transferDataHolders.
</li>
		</ol>
	</li>
	<li>
~RET {
`Serialized^sl: %直列形,
`TransferDataHolders^sl: %転送-~data保持体~list
}
◎
Return { [[Serialized]]: serialized, [[TransferDataHolders]]: transferDataHolders }.
</li>
</ol>

			</section>
			<section id="structureddeserializewithtransfer">
<h3 title="StructuredDeserializeWithTransfer ( serializeWithTransferResult, targetRealm )">2.7.8. `StructuredDeserializeWithTransfer^jA ( %転送-を伴う直列化-結果, %宛先~Realm )</h3>

<ol>
	<li>
<p>
%memory ~LET 空`~map$
◎
Let memory be an empty map.
</p>

<p class="note">注記：
`StructuredSerializeWithTransfer$jA と相似的に、
`StructuredDeserialize$jA による通常の用法に加えて，この~algoにおける %memory は、［
`StructuredSerializeInternal$jA が［
%転送-を伴う直列化-結果 . [[TransferDataHolders]] 内の~item
］を無視して，代わりに自前の取扱いを行えるようにする。
◎
Analogous to StructuredSerializeWithTransfer, in addition to how it is used normally by StructuredDeserialize, in this algorithm memory is also used to ensure that StructuredDeserialize ignores items in serializeWithTransferResult.[[TransferDataHolders]], and let us do our own handling instead.
</p>
	</li>
	<li>
%転送済み値~list ~LET 新たな空`List$js
◎
Let transferredValues be a new empty List.
</li>
	<li>
<p>
%転送-を伴う直列化-結果 . `TransferDataHolders^sl 内の`~EACH$( %転送-~data保持体 ) に対し：
◎
For each transferDataHolder of serializeWithTransferResult.[[TransferDataHolders]]:
</p>
		<ol>
			<li>
%値 ~LET ε
◎
Let value be an uninitialized value.
</li>
			<li>
<p>
~IF［
%転送-~data保持体 . `Type^sl ~EQ `ArrayBuffer^l
］
⇒
%値 ~SET 次のようにされた， %宛先~Realm 内の新たな `ArrayBuffer^jC ~obj
⇒＃
. `ArrayBufferData^sl ~SET %転送-~data保持体 . `ArrayBufferData^sl,
. `ArrayBufferByteLength^sl ~SET %転送-~data保持体 . `ArrayBufferByteLength^sl
◎
If transferDataHolder.[[Type]] is "ArrayBuffer", then set value to a new ArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot value is transferDataHolder.[[ArrayBufferData]], and whose [[ArrayBufferByteLength]] internal slot value is transferDataHolder.[[ArrayBufferByteLength]].
</p>

<p class="note">注記：
`ArrayBufferData^sl が占めている元の~memoryが 逆直列化の間も~access可能な事例では、この段は，およそ例外を投出しないであろう
— 新たな~memoryを割当てる必要はないので。
代わりに，その元の~memoryが新たな `ArrayBuffer^jC に転送されることになる。
これは、例えば，~source~Realmと宛先~Realmの両者とも同じ~process内にあるときに該当し得る
◎
In cases where the original memory occupied by [[ArrayBufferData]] is accessible during the deserialization, this step is unlikely to throw an exception, as no new memory needs to be allocated: the memory occupied by [[ArrayBufferData]] is instead just getting transferred into the new ArrayBuffer. This could be true, for example, when both the source and target Realms are in the same process.
</p>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%~interface名 ~LET %転送-~data保持体 . `Type^sl
◎
Let interfaceName be transferDataHolder.[[Type]].
</li>
					<li>
~IF［
%~interface名 により識別される~interfaceは
%宛先~Realm 内に公開されていない
］
⇒
~THROW `DataCloneError$E
◎
If the interface identified by interfaceName is not exposed in targetRealm, then throw a "DataCloneError" DOMException.
</li>
					<li>
%値 ~SET %宛先~Realm 内に作成される，
%~interface名 により識別される~interfaceの新たな~instance
◎
Set value to a new instance of the interface identified by interfaceName, created in targetRealm.
</li>
					<li>
%~interface名 により識別される~interfaceに適切な`転送-受信-時の手続き$( %転送-~data保持体, %値 )
を遂行する
◎
Perform the appropriate transfer-receiving steps for the interface identified by interfaceName given transferDataHolder and value.
</li>
				</ol>
			</li>
			<li>
%memory[ %転送-~data保持体 ] ~SET %値
◎
Set memory[transferDataHolder] to value.
</li>
			<li>
%転送済み値~list に %値 を`付加する$
◎
Append value to transferredValues.
</li>
		</ol>
	</li>
	<li>
%逆直列形 ~LET
? `StructuredDeserialize$jA( %転送-を伴う直列化-結果 . `Serialized^sl, %宛先~Realm, %memory )
◎
Let deserialized be ? StructuredDeserialize(serializeWithTransferResult.[[Serialized]], targetRealm, memory).
</li>
	<li>
~RET {
`Deserialized^sl: %逆直列形,
`TransferredValues^sl: %転送済み値~list
}
◎
Return { [[Deserialized]]: deserialized, [[TransferredValues]]: transferredValues }.
</li>
</ol>

			</section>
			<section id="performing-structured-clones-from-other-specifications">
<h3 title="Performing serialization and transferring from other specifications">2.7.9. 他の仕様からの直列化と転送-の遂行-法</h3>

<p>
他の仕様は、ここに定義した抽象演算を利用してよい。
以下に、各種 抽象演算が概していつ有用になるかについての手引きを，例とともに供する：
◎
Other specifications may use the abstract operations defined here. The following provides some guidance on when each abstract operation is typically useful, with examples.
</p>

<dl>
	<dt>`StructuredSerializeWithTransfer$jA</dt>
	<dt>`StructuredDeserializeWithTransfer$jA</dt>
	<dd>
宛先~Realmは事前に既知でないとき，
別の`~Realm$へ，転送-~listも伴わせて値を~cloneするとき。
この事例では，直列化の段は即時に遂行できる一方で、逆直列化の段は 宛先~Realmが既知になるまで遅延される。
◎
Cloning a value to another JavaScript Realm, with a transfer list, but where the target Realm is not known ahead of time. In this case the serialization step can be performed immediately, with the deserialization step delayed until the target Realm becomes known.
</dd>
	<dd class="example">
`messagePort.postMessage()$m は、行先~Realmは `MessagePort$I が`搬送-済み$になるまで既知でないので，この抽象演算を組みで利用する。
◎
messagePort.postMessage() uses this pair of abstract operations, as the destination Realm is not known until the MessagePort has been shipped.
</dd>

	<dt>`StructuredSerialize$jA</dt>
	<dt>`StructuredSerializeForStorage$jA</dt>
	<dt>`StructuredDeserialize$jA</dt>
	<dd>
所与の値に対し，`~Realm$から独立な~snapshotを作成するとき
— 不定~~期間~保存でき、後に，場合によっては複数~回にわたり~JS値に~~復元されるような。
◎
Creating a JavaScript Realm-independent snapshot of a given value which can be saved for an indefinite amount of time, and then reified back into a JavaScript value later, possibly multiple times.
</dd>
	<dd>
`StructuredSerializeForStorage$jA は、直列化が，~Realm間で渡されず持続的に格納されると見込まれる状況に利用できる。
`SharedArrayBuffer$I ~objを直列化しようと試みたときは、投出する
— 共用~memory内に格納しても無為なので。
同様に，所与の`~platform~obj$に~custom`直列化~手続き$がある場合、［
%蓄積用 引数 ~EQ ~T
］の下では，［
投出する ／ 場合によっては挙動が異なる
］こともある。
◎
StructuredSerializeForStorage can be used for situations where the serialization is anticipated to be stored in a persistent manner, instead of passed between Realms. It throws when attempting to serialize SharedArrayBuffer objects, since storing shared memory does not make sense. Similarly, it can throw or possibly have different behavior when given a platform object with custom serialization steps when the forStorage argument is true.
</dd>
	<dd class="example">
`history.pushState()$m ／
`history.replaceState()$m
は、作者から給された状態~objに
`StructuredSerializeForStorage$jA を利用し，それを適切な`~session履歴~entry$内に`直列形の状態$で格納する。
`history.state$m ~propは、
`StructuredDeserialize$jA を利用して，元々給された状態~objの~cloneを返す。
◎
history.pushState() and history.replaceState() use StructuredSerializeForStorage on author-supplied state objects, storing them as serialized state in the appropriate session history entry. Then, StructuredDeserialize is used so that the history.state property can return a clone of the originally-supplied state object.
</dd>
	<dd class="example">
`broadcastChannel.postMessage()$m は、その入力に対し
`StructuredSerialize$jA を利用した結果に対し，
`StructuredDeserialize$jA を複数~回~利用して、~broadcastされている各 行先~用に新規の~cloneを生産する。
行先が複数ある状況では、転送は~~意味を成さないことに注意。
◎
broadcastChannel.postMessage() uses StructuredSerialize on its input, then uses StructuredDeserialize multiple times on the result to produce a fresh clone for each destination being broadcast to. Note that transferring does not make sense in multi-destination situations.
</dd>
	<dd class="example">
~filesystemに~JS値を持続化させるような~APIも、その入力に `StructuredSerializeForStorage$jA を利用し，その出力に `StructuredDeserialize$jA を利用する。
◎
Any API for persisting JavaScript values to the filesystem would also use StructuredSerializeForStorage on its input and StructuredDeserialize on its output.
</dd>
</dl>

<p>
一般に、~callする側は，~JS値の代わりに~WebIDL値を渡してもよい
— これは、これらの~algoを呼出す前に，暗黙的な`~JS値への変換$を遂行するものと解される。
◎
In general, call sites may pass in Web IDL values instead of JavaScript values; this is to be understood to perform an implicit conversion to the JavaScript value before invoking these algorithms.
</p>

<p class="note">注記：
<a id="structuredclone"></a>
<a id="structured-clone"></a>
この仕様は，
“有構造~clone” ~algo, および
より近過去には `StructuredClone^jA 抽象演算も定義していたが、それらは除去された
— 既知の［
実施におけるそれらの利用
］すべては、直列化と逆直列化の手続きに分離することで，より上手く~~働くようになるので。
◎
This specification used to define a "structured clone" algorithm, and more recently a StructuredClone abstract operation. However, in practice all known uses of it were better served by separate serialization and deserialization steps, so it was removed.
</p>

<hr>

<p>
~callする側が［
作者~codeが~UA~methodの中へ~callした結果として同期的に呼出されてはいない
］場合、それが任意の~obj上で遂行されている場合には，抽象演算［
`StructuredSerialize$jA ／
`StructuredSerializeForStorage$jA ／
`StructuredSerializeWithTransfer$jA
］を呼出す前に，適正に［
`~scriptを走らすために準備する$ ／ `~callbackを走らすために準備する$
］よう注意し~MUST。
このことは、必要とされる
— 直列化~処理-は、その~~最終的な深い直列化~手続きの一部として，作者により定義される~accessorを呼出すこともあり、その~accessorは［［
`入口~某$／`現任の某$
の概念が 適正に設定してある
］ことに依拠するような演算
］の中へ~callすることもあるので。
◎
Call sites that are not invoked as a result of author code synchronously calling into a user agent method must take care to properly prepare to run script and prepare to run a callback before invoking StructuredSerialize, StructuredSerializeForStorage, or StructuredSerializeWithTransfer abstract operations, if they are being performed on arbitrary objects. This is necessary because the serialization process can invoke author-defined accessors as part of its final deep-serialization steps, and these accessors could call into operations that rely on the entry and incumbent concepts being properly set up.
</p>

<p class="example">
`window.postMessage()$m は、その引数に対し `StructuredSerializeWithTransfer$jA を遂行するが、注意深く，自身の~algoの同期的~部位の内側で即時に行うので、［
`~scriptを走らすために準備する$ ／ `~callbackを走らすために準備する$
］必要なく，この~algoを利用できる。
◎
window.postMessage() performs StructuredSerializeWithTransfer on its arguments, but is careful to do so immediately, inside the synchronous portion of its algorithm. Thus it is able to use the algorithms without needing to prepare to run script and prepare to run a callback.
</p>

<p class="example">
対照的に、 `StructuredSerialize$jA を利用して，［
作者から給された何らかの~objを，`~event-loop$上の`~task$から直接的に 毎回~直列化する
］ような ~APIがあるとするなら、前もって適切な準備が遂行されることを確保する必要がある。
現時点では、そのような~APIは~platform上にないことが知られている
— 通例的には，作者~codeに同期して，事前に直列化を遂行しておく方が単純になる。
◎
In contrast, a hypothetical API that used StructuredSerialize to serialize some author-supplied object periodically, directly from a task on the event loop, would need to ensure it performs the appropriate preparations beforehand. As of this time, we know of no such APIs on the platform; usually it is simpler to perform the serialization ahead of time, as a synchronous consequence of author code.
</p>

			</section>
		</section>
</main><!-- id="MAIN" -->
