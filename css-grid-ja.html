<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Grid Layout Module Level 2 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<style>
img {
	background: white;
}

.example {
	clear:both
}

dd > p:nth-child(1) {
	margin-top:0
}

figure.sidefigure1 {
	display: inline-block;
	margin: 0.5em;
}

._ex-fg-layout {
	position: relative;
	font-size: 1rem;
	width:  30em;
	height:  4em;
}
._ex-fg-layout > div {
	position: absolute;
	top: 0;
	height: 1.5em;
	border: solid currentcolor 0.2em;
	background: var(--pale-color);
	border-radius: 0.3em;
}


#grid-property-breakdown td {
	text-align: center;
	border: solid 1px var(--table-rule-color);
}

#_dgm-basic-form,
#_dgm-auto-placed-form {
	border-collapse: collapse;
}

#_dgm-basic-form tr,
#_dgm-auto-placed-form tr {
	border: none;
}

#_dgm-basic-form td,
#_dgm-auto-placed-form td {
	border: dashed 1px var(--K-color);
	padding: 0.2em;
	white-space: nowrap;
}

#_dgm-basic-form td {
	padding: 0.5em;
}

#_dgm-grid-item-determination {
	background: var(--deep-color);
	color: var(--W-color);
	border: solid 3px var(--deep-color);
	border-radius: 6px;
	display: inline-block;
	white-space: nowrap;
}
#_dgm-grid-item-determination > div {
	background: var(--dim-color);
	margin-right: 3px;
	padding: 0 3px;
	border-radius: 3px;
	display: inline-block;
	vertical-align: top;
}

._ex-spanned-gap {
	font-size: 0.6rem;
	position: relative;
	border: solid 2px var(--N-color);
	width:47em;
	height:35em;
}
._ex-spanned-gap > div {
	position: absolute;
	background: var(--bg-color-1);
	color: var(--K-color);
	outline: dashed 1px var(--K-color);
}
._ex-spanned-gap > div > div {
	font-size: 2em;
	padding: 0.4em;
	font-family: monospace;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const text_map = this.text_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'p':
	if( indicator === '@') {
		context_prop = `#valdef-${key}-`;
	}
	break;
case 'pe':
	text = `::${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s?\[.+/, '');
	break;
case 'tp': // property value type
	text = `&lt;'<code class="property">${key}</code>'&gt;`;
	href = link_map[`p.${key}`];
	break;
case 'f':
	text = `${key}()`;
	break;
case 'vt': // value for grid-template-columns/rows
	href= `#valdef-grid-template-columns-${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}"></a>`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	href = `https://github.com/w3c/csswg-drafts/issues/${key}`;
	text = `課題 #${key}`
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Grid Layout Module Level 2
spec_date:2023-11-03
trans_update:2023-11-04
source_checked:210702
page_state_key:CSS
original_url:https://drafts.csswg.org/css-grid-2/
	abbr_url:CSSGRID
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:layouts,layout,css
conformance:css
copyright:2023,permissive
trans_1st_pub:2014-04-29


●●class_map
p:property
d:descriptor
u:unit
v:value
vt:value
f:func
pe:pseudo
e:element
t:type
tp:type
op:op
css:css
U:code-point
cn:cp-name

●●tag_map
p:code
d:code
v:code
u:code
vt:code
f:code
pe:code
e:code
t:var
tp:var
c:code
i:i
css:code
op:span
V:var
em:em
b:b
U:span
cn:span


●●words_table1

SIZING4:https://drafts.csswg.org/css-sizing-4/

fr: <code class="unit">fr</code> 
none1:none
autoS:auto
autoP:auto
stretchAC:stretch
normalJC:normal

●●words_table


	●算術
min:
max:
最小-:min-::~
最大-:max-::~
	最~大／`max^op:largest
	最~小:smallest
	最小~size:min size
	最大~size:max size
	min^op:smaller of
係数:factor::~
均等:even:~
切詰めて:clampして:切り詰めて
切詰めら:clampさ:切り詰めら
切詰める:clampする:切り詰める
	〜以下に切詰める:capped by
	切り上げ
切落され:truncateさ:切り落とされ
	-:truncate
	切り上げられ:floored
超過-:exceed::~
	超過:excess
縦横比:aspect ratio::~
公式:formula:~
無制限:unlimited:~
上限:limit:~
	上限:maximum／:upper limit
上限付き:limited:~
制限付き:limited:~
減算-:subtract:~
総和:sum:~
増分:increase:~
増やす:increaseする:~
増やし:increaseし:~
増やさ:increaseさ:~
圧縮-:compress::~

	~INCBY:increment
	~INCBY:incrementally
	比率／比例分:proportion
	比:ratio
	比例する割合:in proportion to
	~minus:
	減算
	~missing:

	●layout 幾何
アキ:spacing::~
疎:sparse::~
稠密:dense::~
主-:main-::~
交叉-:cross::~
幅:wide:~
対辺:opposite edge::~
横方向:horizontal::~
縦方向:vertical::~

	方向: 〜ward
限界域:bounds::~
限界b:bound::境界
	限界b:bound by
	限界bを成す:bounding
境界線:boundaries::~
縮短-:shrink:~
一次元的:linear:~
二次元的:2-dimensional:~
二次元:two-dimensional:~
縦置き:portrait::~
横置き:landscape::~
垂直:perpendicular:~
合間:between:~
直交:orthogonal::~
直交な:orthogonalな::直交する
挿入地点:insertion point:~

	超えて:outside
	側:side
	前方:forwards
	後方:backwards
	長:length
	両端の〜を端に寄せる:justifies
	右:right
	左:left

	●layout
span::::スパン
	spans::span 数:スパン数
	~spanning
確定的:definite::~
不定:indefinite::~
auto:
収容-:accommodate::~
配列-:arrange::~
配列法:arrangement::~
	配列し直:rearrange
	配列し直す:rearrangement
再配列:rearrangement::配置替え
増補:augmented::~
並替えら:reorderさ::並び替えら
並替えて:reorderして::並び替えて
拡幅:growth::~
拡幅-:grow::~
供与-:contribute::~
供与:contribution::~
	寄与-:contribute
収まる:fitする::~
伸張-:stretch::~
	伸張して収まる:stretch-fit
内容-:content-::~
分布:distribution::~
分布型の:distributed::~
分配-:distribute::~
分配:distribution::~
分割0:divide:分割
相殺-:collapse::~
畳まれ:collapseされ::~
	collapsing
収納-:pack::~
	収納-法:packing
吸収-:absorb::~
重合させ:overlapさせ::重ね合わせ
重合する:overlapする::重なり合う
重合した:overlapした::重なり合った
重合しな:overlapしな::重なり合わな
重合して:overlapして::重なり合って
	重合する部分:overlap
覆う:coverする::~
覆われ:coverされ::~
埋める:fillする::~
埋めら:fillさ::~
埋めて:fillして::~
埋まる:fillされる::~
埋めれ:fillでき::~
詰物:shim::詰め物
削減-:reduce:~
侵入-:intrude:~
多層化:layering::~::多レイヤ化
先頭字:initial letter::~
膨張-:inflate:~
ズラす:shiftする:ずらす

	互いに重なる:layer one over the other
	位置され:positioned
	絶対~位置決め:abspos
	~layoutにおいては:Layoutwise,
	~flow内:in-flow
	~flowに相対的:flow-relative
	順番どおりに:“in order”
	順番どおりに〜ない:out-of-order
	順番に空かどうか調べていく:looks linearly through
	逆順:in reverse
	占める／’s:occupy
	占めている:occupying
	占める:take up／in
	残されて:left
	穴埋め:fill in holes
	穴の無い:filled-in
	~~置く:put
	配置-法:placing
	継ぎ合される:merge／:splicing

	●格子 layout
罫:line::~
駒:item:::アイテム
筋:track::~::トラック
筋rc:row／column:track:筋::トラック
格子:grid::~::グリッド
下位格子:subgrid::~::下位グリッド
	下位格子~化-:subgrid
	格子~levelの:grid-level
升:cell::~::セル
col:column
row:
col-:column-
row-:row-
	-始端／-終端
	区画:slot
側溝:gutter::~
	-:alley
gap:
template::::テンプレート
無名:unnamed:~
語数:word 数:~
未占有:unoccupied:~
占有-:occupy:~

null:
trash:
自立的:standalone::~
番号:number:~
嵌込まれ:slotされ:嵌め込まれ

	●格子 flex／分配
flex:
	~flex可能:flexible
	~flex可能でない:non-flexible
	-:inflexible
	~flexに~sizeされる:flex-sized
割合分:fraction::~
	fractional
	一部分／
持分:share:持ち分
free:
自由:free::~
残余:leftover::~
余分な:extra::~
余った:extra::~

	~~追加の:extra
	割り当てられ:allotted
	~~均等に分ける:dividing 〜 equally amongst them
	太さ:thickness／-

	●CSS layout
強制d:forced::強制
	~flex行l:line

固定-:fix::~
固定d:fixed::固定
固定的:fixed::~

基底線:baseline::~::ベースライン
基底線-:baseline-::~::ベースライン
不可分:atomic::~
複柱:multi-column::複 column::複カラム
中段:middle::~
中央寄せに:center::~
	centered
変形:transform::~
変形n:transformation::変形
	転置
	置換されない:non-replaced
	置換される:replaced
折返され:wrapされ::折り返され
折返す:wrapする::折り返す
	:line-wrapping
排他的:exclusive:~
浮動体:float::~
浮動-:float::~
浮動:floating::~

塗ng:painting::塗り
積層:stacking::~
	Z-axis
生来:natural::~
拡げる:expandする:~
拡げら:expandさ:~
	~~拡げる:enlarge
	拡げること:expansion
	~sizeし直:resize／resizing
	半分:half
	接していない:not at

	●構造
構造付け:structuring:~
	content-sized:内容から~sizeされ
対応関係:correspondence:~
	連続する:consecutive／Adjacent／contiguous
	子の子:grandchildren
	子の子:grandchild
	親の親:grandparent
	織り交ぜ法:interlacing
	巻き上げる:hoistする

	●構文
片:fragment::~::フラグメント
角括弧:bracket:~
数量的:numerical:~
数量-:numeric:~
最長合致:longest-match semantics:~
repeat:

	~token化:tokenize
	宣言-法:declaring
	whitespace

	●CSS
CSSOM:
横書き:horizontal::~
左横書き:left-to-right::~
右横書き:right-to-left::~
	LTR
書字:writing::~
	~scroll可能:scrollable
描き:drawing:~

発話:speech::~::スピーチ
逐次的:sequential:~
可視化:visualization::~
	印刷-用の:printing
封込め:containment::封じ込め
横組み:horizontal writing mode::~
縦組み:vertical writing mode::~

	算出し直:back-compute
	解決し直:re-resolve
	解決した結果の長さ:resolved length
	下位prop:longhand


	●一般処理
遭遇-:encounter:~
繰返せる:repeatできる:繰り返せる
繰返n:repetition:繰り返し
	recurring:繰り~~返-
	回数:repetition number／:number of repetitions
見出しな:findしな:~
転換:transferred:~
後戻り:backtrack:~
周回:pass:~
再帰-:recurse:~
再帰:recursion:~
掘下げ:introspection:掘り下げ
掘下げら:introspectさ:掘り下げら
計画d:planned:計画
	掘り下げる:drill down
	渡-:pass
	~skipping
	まだアテガわれてない:unassigned
	加える:addする
	入力:input
	走らせ:running those instructions
	何もしない:no-op
	変更しない:leaves them unchanged
	設定し直:reset
	設定しておく:set up
	setting
	切り上げられ:floored at
	~PLUS:plus
	候補:candidate

	●仕様
top-down::::トップダウン
bottom-up::::ボトムアップ
得意分野:specialties:~
節:section:~
独立性:independence:~
些細:trivial:~
利点:advantage:~
	享受:take advantage of
実効:effective:~
不安定:brittle:~
対処法:workarounds:~
代用:substitute:~
主要:major:~
主導:-major:~
劇的:dramatic:~
理想的:ideal:~
相補的:complementary:~
道具:tool::~::ツール
見積もり:estimate:~
一般形:generic form:~
整理-:organize:~
整理:clean-up:~
不用意:accidental:~
特質:property:~
改正-:amend:~
順応-:adapt:~
順応的:adaptive:~
模索-:discover:~
発展-:evolve:~
完結-:finalize:~
解消-:address:~
競合:conflict:~
誂える:tailorする:あつらえる
受入れる:adoptする:受け入れる
受入れた:adoptした:受け入れた
組織化-:embody:~
編成-:organize:~
循環依存:circular dependencies:~
循環:cycle:~
循環な:cyclicな:~
参照r:refer:参照
最小化-:minimize:~
普通の:ordinaryな:~
変種:variant:~
抵触-:hit:~

	情報~片:piece of information
	~risk下:at-risk
	-:possible
	大雑把に言えば:Loosely speaking
	賢い:smart
	見込まれる:likely／
	厳しく:severely
	広範な種類の:wide variety
	早期の:early／earlier／earliest
	可能／enable
	足る:sufficient
	簡潔:compact
	多様:across
	よく似る:very similar
	良好な:good
	図:figure
	よく:very
	なり得る:potentially
	項:bullet point
	事実:fact
	にもかかわらず:despite
	早期の:early
	誤り:error
	調べる:attempt
	-:additionally
	きちんと:well-
	ε:undefined
	とられ:take
	課され:imposeされ
	損なわれ:ruin さ
	causes
	指す:referする
	されたし:please
	記され／書かれ:written
	書き直:rewriting
	指向する:–oriented
	満たす:satisfy
	進んだ:advanced
	適する:suit 
	揃うよう:alignment
	細かな:minor
	強大な力:great powers
	いきなり:suddenly
	ある:somewhat
	防ぐ／ないようにする:prevent
	保つ:keep
	選ぶ:choose
	高〜から:at a high
	それに対応して:correspondingly

	●仕様（言い換え

	~level:Level
	組入れた:incorporation
	たい:want
	現実の:real-world
	の違い:vs.
	~~省ける:shortcut
	に注意:notice
	~~既定では:In the general case
	~~流れ:look
	貫き続ける:stick to
	~~留意-:beware
	十分なものとは言えなく:necessarily well suited:
	~~説明-:illustrate
	説明図:illustration
	読み替えて:Substitute
	加味:respect
	明快にするため:aid in clarity
	~~待っている:looking for
	厳しくなるに連れ:became
	力点を置い:focus
	きれいに:cleanly
	総称:generic
	比して:with respect to
	役立つ:helpful
	適する:suitable
	注意:Remember
	限りがある:not infinite
	大きく違える:largely disjoint
	よく考えずに:without much thought given to it
	漏れ出た:leak
	文書化されていなかった:undocumented
	予め定義された:predefined
	対応:respective
	~~発揮する:deliver
	~~見出され:identified
	~~選んで:opted for
	易く:help
	~~現れる:mentions
	その結果，consequently
	突き合わせて〜検査する:cross-check
	気の利いた:intelligently
	用例:-
	成立:-
	用途
	様子
	その一方:meanwhile
	織り込まれ:factors into
	-:very well
	-:instruct
	説明する:illustrate
	追加した:plus 〜 additional

	●謝辞
記念碑的:monumental:~
隔たり:gap:~
聡明:intelligent:~
	~~追求-:insist
	~~絵図:illustration
	橋渡し:bridge
	助力:help
	すべての方々:everyone
	先へ進めな:able to move forward
	thanks

	●未分類
獲得-:acquire:~
共有:sharing:~
入替える:swapする:入れ替える
付番-:number:~
分解-:decompose:~
歪み:distortion:~
歪める:distortする:~
維持-:retain:~
近似:approximation:~
component::::コンポーネント
ASCII-art:::ASCII アート
触覚:tactile::~
構築部品:building block:~
使用方位:orientation:~
機器形態:device form factors:~
仮の:hypotheticalな:~
平行:parallel:~
画面:screen:~
内方:inward:~
ゲーム:game:~
成績:stats:~
盤面:board:~
スコア:score:~
矩形:rectangle:~
	non-rectangular
ヘッダ:header:~
フッタ:footer:~
メイン:main:~
右上部分:top right quadrant:~
合成-:synthesize::~
Arabic:::アラビア語

時計回り:clockwise:~
滑らか:smooth:~
連続的:continuous:~
	巨大:large
本物の:realな:~

	Mozilla:
	消え去:disappear
	~~揃う:line up
	得る:gain
	-:located
	:became／becomes／becoming
	consist／consisting:〜からなる
	~web~site:website
	follow
	離せる:how far apart
	後続の:come up later
	cases:
	made／makes／making
	-:marked
	-:exhibit
	絞り込:filtering
	ending
	:seen
	-:restart
	take／taking
	-:yielding
	現れる:appear
	属する:belong
	数える:count
	挟まれ:surrounded／:intervening
	に応じて変わる:vary as
	得る／-:yield
	~call:
	~mark
	一致する:coincide
	振り分け直され:rebalance
	回数:count／:number of
	個数
	本数:number of／
	総本数
	英語:English
	付与-
	-:down
	〜沿い:along
	-:catalog
	徐々に／次第に:gradually
	近づ:approach
	大きい:large／larger／largest
	小さい:small／smaller／smallest
	~MUL:product／multiply
	~~構成:configuration
	数:number
	-:quantity
	量:amount
	減り
	直線的:straight
	巨大過ぎ:overly-large
	駒:member
	縦横
	間隔
	合計
	記号
	差:difference
	合致するようにする:match up
	戻す:back up

	●言い換え
	~~区間:section
	近い／大きい:extreme
	視覚-効果~上の:effective visual
	アテガわれ方:assignments
	近くなった:underflow
	入子にされただけの:regular nested
	~~段階:stage／phase
	すき間なく:tightly
	異なる:distinct
	~~基準:against
	とは逆になる:compared to invert
	分離-:separation
	生成-:generation
	それに伴い:by extension
	可変性:changes
	~~表示され:viewed
	〜とする下で得られる:is taken under the provision of having
	~~条項:provisions
	単連結でない:disconnected regions
	~~本番:for real
	ていく:in turn
	~rowを~sizeする〜:row-sizing

	●指示語
	末尾にある:trailing
	最後尾の:final
	最終的な:final
	直下:immediately under
	全体的:overall
	右側
	幾本
	半分:half
	下位:sub
	両方向
	囲う:around
	離れた:away
	満たない:less than
	少数:a small list of
	上述:-
	多数:a number of／large number of／:many
	以外
	以上
	以下
	次回:next round
	自身:own
	各種
	前段
	部分
	一連
	最も右:rightmost
	nothing
	別々:separately
	〜にまたがって:across
	以前:previous
	前〜:previous
	次の:next
	非:non
	百万:million
	地点:point
	周囲:
	among
	唯一の:sole
	残り:remainder
	同時
	一部
	一括
	更に:further
	同じく:just as
	最も:most
	anything
	prior to／:先立って
	-:Lastly:
	certain
	-:now
	同様に:of course
	~~共同:together
	一方で
	下回る／:less than
	分
	全体にわたり:over the course of
	-:alternating
	-:ultimately
	他方の:opposite／
	より少なく:fewer

●●original_id_map

valdef-grid-template-columns-none:valdef-grid-template-rows-none
valdef-grid-template-columns-subgrid:valdef-grid-template-rows-subgrid
typedef-grid-line:typedef-grid-row-start-grid-line
	grid-auto-flow-property:auto-placement
	layout-algorithm:algo-overview

●●mdn_urls
propdef-grid:CSS/grid
propdef-grid-area:CSS/grid-area
propdef-grid-auto-columns:CSS/grid-auto-columns
propdef-grid-auto-flow:CSS/grid-auto-flow
propdef-grid-auto-rows:CSS/grid-auto-rows
propdef-grid-column:CSS/grid-column
propdef-grid-column-end:CSS/grid-column-end
propdef-grid-column-start:CSS/grid-column-start
propdef-grid-row:CSS/grid-row
propdef-grid-row-end:CSS/grid-row-end
propdef-grid-row-start:CSS/grid-row-start
propdef-grid-template:CSS/grid-template
propdef-grid-template-areas:CSS/grid-template-areas
propdef-grid-template-columns:CSS/grid-template-columns
propdef-grid-template-rows:CSS/grid-template-rows

funcdef-repeat:CSS/repeat()
funcdef-grid-template-columns-fit-content:CSS/fit-content()
funcdef-grid-template-columns-minmax:CSS/minmax()

valdef-flex-fr:CSS/flex_value#fr
typdef-flex:CSS/flex_value

●●link_map

	●property
p.grid-area:#propdef-grid-area
p.grid-auto-columns:#propdef-grid-auto-columns
p.grid-auto-flow:#propdef-grid-auto-flow
p.grid-auto-rows:#propdef-grid-auto-rows
p.grid-column-end:#propdef-grid-column-end
p.grid-column-start:#propdef-grid-column-start
p.grid-column:#propdef-grid-column
p.grid-row-end:#propdef-grid-row-end
p.grid-row-start:#propdef-grid-row-start
p.grid-row:#propdef-grid-row
p.grid-template-areas:#propdef-grid-template-areas
p.grid-template-columns:#propdef-grid-template-columns
p.grid-template-rows:#propdef-grid-template-rows
p.grid-template-*:#track-sizing
p.grid-template:#propdef-grid-template
p.grid:#propdef-grid

p.place-content:~CSSALIGN#propdef-place-content
p.column-gap:~CSSALIGN#propdef-column-gap
p.row-gap:~CSSALIGN#propdef-row-gap
p.gap:~CSSALIGN#propdef-gap
p.align-content:~CSSALIGN#propdef-align-content
p.align-items:~CSSALIGN#propdef-align-items
p.align-self:~CSSALIGN#propdef-align-self
p.justify-content:~CSSALIGN#propdef-justify-content
p.justify-items:~CSSALIGN#propdef-justify-items
p.justify-self:~CSSALIGN#propdef-justify-self

p.white-space:~CSSTEXT#propdef-white-space

p.width:~SIZING#propdef-width
p.height:~SIZING#propdef-height
p.max-width:~SIZING#propdef-max-width
p.max-height:~SIZING#propdef-max-height
p.min-width:~SIZING#propdef-min-width
p.min-height:~SIZING#propdef-min-height

	p.min-width:~CSS2J#propdef-min-width
	p.max-width:~CSS2J#propdef-max-width
	p.min-height:~CSS2J#propdef-min-height
	p.max-height:~CSS2J#propdef-max-height

	p.column-*:~CSSMCOL#propdef-column

p.direction:~CSSWM#propdef-direction
p.writing-mode:~CSSWM#propdef-writing-mode

p.break-before:~CSSBREAK#propdef-break-before
p.break-after:~CSSBREAK#propdef-break-after
p.break-*:~CSSBREAK#break-between
p.display:~CSSDISP#propdef-display

	p.margin-bottom:~CSSBOX#propdef-margin-bottom
	p.margin-top:~CSSBOX#propdef-margin-top
	p.padding-bottom:~CSSBOX#propdef-padding-bottom
	p.padding-top:~CSSBOX#propdef-padding-top
p.margin:~CSSBOX#propdef-margin
p.vertical-align:~CSSINLINE#propdef-vertical-align
p.order:~CSSDISP#propdef-order
p.flex-flow:~CSSFLEX#propdef-flex-flow
p.flex:~CSSFLEX#propdef-flex
p.clear:~CSS2J#propdef-clear
p.float:~CSS2J#propdef-float
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.border-spacing:~CSS2TABLE#propdef-border-spacing

p.top:~CSSPOS#propdef-top
p.right:~CSSPOS#propdef-right
p.bottom:~CSSPOS#propdef-bottom
p.left:~CSSPOS#propdef-left
p.position:~CSSPOS#propdef-position

p.z-index:~CSS2J#propdef-z-index

p.aspect-ratio:~SIZING#propdef-aspect-ratio

	●value
v.grid:#valdef-display-grid
v.inline-grid:#valdef-display-inline-grid

v.row:#valdef-grid-auto-flow-row
v.column:#valdef-grid-auto-flow-column
v.dense:#valdef-grid-auto-flow-dense
	v.auto-flow:#_valdef-grid-auto-flow

v.none:#valdef-grid-template-none
v.~none1:#valdef-grid-template-areas-none

v.auto:#valdef-repeat-auto
v.~autoP:#grid-placement-auto

v.span:#grid-placement-span-int

v.normal:~CSSALIGN#valdef-align-self-normal

v.auto-fit:#valdef-repeat-auto-fit
v.auto-fill:#valdef-repeat-auto-fill

v.~autoS:~SIZING#valdef-width-auto
v.min-content:~SIZING#valdef-width-min-content
v.fit-content:~SIZING4#valdef-width-fit-content

v.start:~CSSALIGN#valdef-self-position-start
v.center:~CSSALIGN#valdef-self-position-center

v.table-cell:~CSSDISP#valdef-display-table-cell
v.block:~CSSDISP#valdef-display-block

v.space-around:~CSSALIGN#valdef-align-content-space-around
v.space-between:~CSSALIGN#valdef-align-content-space-between
v.space-evenly:~CSSALIGN#valdef-align-content-space-evenly

v.stretch:~CSSALIGN#valdef-align-self-stretch
	v.stretch:~CSSALIGN#valdef-justify-self-stretch
v.~stretchAC:~CSSALIGN#valdef-align-content-stretch
v.~normalJC:~CSSALIGN#valdef-justify-content-normal

	v.normal:~CSSALIGN#valdef-justify-self-normal
v.normal:~CSSALIGN#valdef-align-self-normal
v.baseline:~CSSALIGN#valdef-justify-content-baseline

	vt.*:#valdef-grid-template-columns-*
	valdef-grid-template-columns-auto
	valdef-grid-template-columns-none
	valdef-grid-template-columns-subgrid
		valdef-grid-template-columns-flex →
		valdef-grid-template-columns-flex-factor →
		valdef-grid-template-columns-length →
	valdef-grid-template-columns-max-content
	valdef-grid-template-columns-min-content
	funcdef-grid-template-columns-minmax
	valdef-grid-template-columns-percentage

	valdef-grid-template-areas-string → 
	valdef-grid-template-rows-grid-template-columns-none
	normal:~CSSALIGN#valdef-row-gap-normal

f.repeat:#funcdef-repeat
f.fit-content:#funcdef-grid-template-columns-fit-content
vt.fit-content:#funcdef-grid-template-columns-fit-content
f.minmax:#funcdef-grid-template-columns-minmax
vt.minmax:#funcdef-grid-template-columns-minmax
f.calc:~CSSVAL#funcdef-calc

u.fr:#valdef-flex-fr

	●type

t.auto-repeat:#typdef-auto-repeat
t.auto-track-list:#typdef-auto-track-list
t.explicit-track-list:#typdef-explicit-track-list
t.fixed-breadth:#typdef-fixed-breadth
t.fixed-repeat:#typdef-fixed-repeat
t.fixed-size:#typdef-fixed-size
t.flex:#typedef-flex
t.grid-line:#typdef-grid-line
t.inflexible-breadth:#typdef-inflexible-breadth
t.line-names:#typedef-line-names
t.line-name-list:#typedef-line-name-list
t.name-repeat:#typedef-name-repeat
t.track-breadth:#typdef-track-breadth
t.track-list:#typdef-track-list
t.track-repeat:#typdef-track-repeat
t.track-size:#typdef-track-size

t.custom-ident:~CSSVAL#identifier-value
t.ident:~CSSVAL#typedef-ident
t.length:~CSSVAL#length-value
t.percentage:~CSSVAL#percentage-value
t.length-percentage:~CSSVAL#typedef-length-percentage
t.string:~CSSVAL#string-value
t.integer:~CSSVAL#integer-value

d.orientation:~MQ5#descdef-media-orientation
	v.portrait::~MQ5#valdef-media-orientation-portrait
	v.landscape::~MQ5#valdef-media-orientation-landscape
	portrait:~CSSPAGE#valdef-page-size-portrait
	landscape:~CSSPAGE#valdef-page-size-landscape

pe.first-line:~CSSPSEUDO#selectordef-first-line
pe.first-letter:~CSSPSEUDO#selectordef-first-letter


	●用語
格子~layout:#grid-layout
格子~level:#grid-level
格子~整形~文脈:#grid-formatting-context

格子:#grid
増補~格子:#augmented-grid
明示的な格子:#explicit-grid
暗黙的な格子:#implicit-grid

下位格子:#subgrid
下位格子~化:#subgridded-axis
自立的:#standalone-axis
自立的な格子:#standalone-grid
入子な格子:#nested-grid
親~格子:#parent-grid

罫:#grid-line
格子~線:#grid-line
暗黙的な罫:#implicit-grid-lines

明示的にアテガわれる罫~名:#explicitly-assigned-line-name
暗黙的にアテガわれる罫~名:#implicitly-assigned-line-name

区画:#grid-area
格子~区画:#grid-area
有名~区画:#named-grid-area
暗黙的に命名された区画:#implicitly-named-area

升:#grid-cell
格子~升:#grid-cell

筋:#grid-track
格子~筋:#grid-track
明示的な筋:#explicit-grid-track
暗黙的な筋:#implicit-grid-track
~col:#grid-column
~row:#grid-row
格子~col:#grid-column
格子~row:#grid-row
格子~容器:#grid-container
駒:#grid-item
格子~駒:#grid-item

明示的な格子~prop:#explicit-grid-properties
暗黙的な格子~prop:#implicit-grid-properties
格子~配置~prop:#grid-placement-property
	§:#placement
配置:#grid-placement
位置:#grid-position
	格子~位置:#grid-position
~span数:#grid-span
	格子~span:#grid-span
~row-始端 罫:#_row-start-line
~col-始端 罫:#_column-start-line
~row-終端 罫:#_row-end-line
~col-終端 罫:#_column-start-line
pos.自動的:#automatic-grid-position
pos.確定的:#definite-grid-position
span.暗黙的:#implicit-grid-span
span.明示的:#explicit-grid-span
span.自動的:#automatic-grid-span


自動-配置~algo:#grid-item-placement-algorithm
格子~駒の配置~algo:#grid-item-placement-algorithm
自動-配置~cursor:#auto-placement-cursor
自動-配置:#grid-auto-flow-property
	自動-配置:#auto-placement

升~token:#_cell-token
有名~升~token:#grid-template-areas-named-cell-token
~null升~token:#grid-template-areas-null-cell-token
~trash~token:#grid-template-areas-trash-token

占有-済み:#occupied
未占有:#unoccupied

格子~順序:#grid-order
塗ng順序:#z-order

格子~区画を切詰める:#clamp-a-grid-area

~flex割合分:#flex-fraction
	~free空間:#free-space
筋~sizing関数:#grid-template-rows-track-sizing-function

筋~list:#track-list
~flex可能な長さ:#flexible-length
~flex可能:#flexible-tracks
	~flex可能な筋:#flexible-tracks

畳まれ:#collapsed-grid-track
gut.畳まれ:#collapsed-gutter

内容に基づく最小~size:#content-based-minimum-size
内容~size示唆:#content-size-suggestion
指定d~size示唆:#specified-size-suggestion
転換~size示唆:#transferred-size-suggestion

算出d筋~list:#computed-track-list
罫~名:#line-name
罫~名~集合:#line-name-set
筋~節:#track-section

§ 格子~駒の自動的な最小~size:#min-size-auto

	#subgrid-item-contribution
	#subgrid-listing
	#subgrid-span
	§ subgrid:#subgrids

	●筋~sizing~algo
~flex係数:#grid-template-columns-flex-factor
§ 格子~layout~algo:#layout-algorithm
格子~sizing~algo:#algo-grid-sizing
~min筋~sizing関数:#min-track-sizing-function
~max筋~sizing関数:#max-track-sizing-function
~free空間:#free-space
V.残余~空間:#leftover-space
可用な格子~空間:#available-grid-space
1.~span数:#span-count
固定的~sizing関数:#fixed-sizing-function
内在的~sizing関数:#intrinsic-sizing-function
~flex可能な~sizing関数:#flexible-sizing-function
筋~sizing~algo:#track-sizing-algorithm
基底~size:#base-size
拡幅~上限:#growth-limit
無限に拡幅-可能:#infinitely-growable
余った空間を分配する:#distribute-extra-space
	extra-space
最小~供与:#minimum-contribution
制限付き最大-内容~供与:#limited-contribution
制限付き最小-内容~供与:#limited-contribution
~fr~sizeを見出す:#algo-find-fr-size

	~size供与:#_size-contribution
影響される~size:#_affected-size
計画d増分:#_planned-increase
駒による増分:#_item-incurred-increase
V.埋める空間:#space-to-fill
算出d筋~size:#computed-track-size
算出d~repeat記法:#computed-repeat-notation


	~flex係数の総和:#flex-factor-sum
	仮の~flex割合分:#hypothetical-flex-fraction
	仮の~fr~size:#hypothetical-fr-size
	必要な空間:#needed-space
	拡幅-可能な筋:#growable-tracks
	~overgrowable筋:#overgrowable-tracks
	拡幅~delta:#growth-delta
	仮の~size:#hypothetical-size
	§:#abspos-items


	●外部
~list:~INFRA#list
集合:~INFRA#ordered-set

略式~prop:~CASCADE#shorthand-property
使用~値:~CASCADE#used-value
指定d値:~CASCADE#specified-value
算出d値:~CASCADE#computed-value
下位prop:~CASCADE#longhand

側溝:~CSSALIGN#gutter

A類の分断~機会:~CSSBREAK#btw-blocks
C類の分断~機会:~CSSBREAK#end-block

~box整列~prop:~CSSALIGN#box-alignment-properties
自己-整列~prop:~CSSALIGN#self-alignment-properties
内容-分布~prop:~CSSALIGN#content-distribution-properties
基底線~集合:~CSSALIGN#baseline-set
最初の基底線~集合:~CSSALIGN#first-baseline-set
最後の基底線~集合:~CSSALIGN#last-baseline-set
最初の基底線による整列:~CSSALIGN#first-baseline-alignment
最後の基底線による整列:~CSSALIGN#last-baseline-alignment
基底線-共有~group:~CSSALIGN#baseline-sharing-group
生成される:~CSSALIGN#generate-baselines
基底線~整列:~CSSALIGN#baseline-alignment
~fallback整列:~CSSALIGN#fallback-alignment
整列~基底線:~CSSALIGN#alignment-baseline
基底線を合成-:~CSSALIGN#synthesize-baseline
合成-:~CSSALIGN#synthesize-baseline
整列~文脈:~CSSALIGN#shared-alignment-context
分布型の整列:~CSSALIGN#distributed-alignment

基底線:~CSSINLINE#baseline

物理的:~CSSWM#physical
直交~flow:~CSSWM#orthogonal-flows
直交~flowを確立して:~CSSWM#establish-an-orthogonal-flow
塊-軸:~CSSWM#block-axis
行内-軸:~CSSWM#inline-axis
行内~size:~CSSWM#inline-size
塊~size:~CSSWM#block-size
始端:~CSSWM#css-start
終端:~CSSWM#css-end
~flowに相対的:~CSSWM#flow-relative
塊-終端:~CSSWM#block-end
塊-始端:~CSSWM#block-start
行内-終端:~CSSWM#inline-end
行内-始端:~CSSWM#inline-start
書字~mode:~CSSWM#writing-mode
行内~基底~方向:~CSSWM#inline-base-direction

包含塊:~CSSDISP#containing-block
塊~layout:~CSSDISP#block-layout
塊~整形~文脈:~CSSDISP#block-formatting-context
行内~整形~文脈:~CSSDISP#inline-formatting-context
独立な整形~文脈:~CSSDISP#independent-formatting-context
独立な整形~文脈を確立する:~CSSDISP#establish-an-independent-formatting-context
塊~化:~CSSDISP#blockify
塊~level:~CSSDISP#block-level
塊~box:~CSSDISP#block-box
塊~levelの~box:~CSSDISP#block-level-box
行内~level:~CSSDISP#inline-level
不可分な行内~level:~CSSDISP#atomic-inline
塊~容器:~CSSDISP#block-container
匿名:~CSSDISP#anonymous
匿名~box:~CSSDISP#anonymous
~text連列:~CSSDISP#css-text-sequence
~text~node:~CSSDISP#text-nodes
置換され:~CSSDISP#replaced-element
~flow内:~CSSDISP#in-flow
~flow~layout:~CSSDISP#flow-layout
改変された文書~順序:~CSSDISP#order-modified-document-order

行l~box:~CSSINLINE#line-box
先頭字:~CSSINLINE#initial-letter

可用な空間:~SIZING#available
不定:~SIZING#indefinite
確定的:~SIZING#definite
外縁~size:~SIZING#outer-size
選好d~size:~SIZING#preferred-size
選好d~size~prop:~SIZING#preferred-size-properties
最小~size:~SIZING#min-size
	#min-width
最小~size~prop:~SIZING#min-size-properties
最大~size:~SIZING#max-size
最大~size~prop:~SIZING#max-size-properties
最小-内容~供与:~SIZING#min-content-contribution
最大-内容~供与:~SIZING#max-content-contribution
最小-内容~size:~SIZING#min-content
最大-内容~size:~SIZING#max-content
最小-内容~拘束:~SIZING#min-content-constraint
最大-内容~拘束:~SIZING#max-content-constraint
内在的~size:~SIZING#intrinsic-size
内在的~size供与:~SIZING#intrinsic-size-contribution
収まるよう伸張-:~SIZING#stretch-fit
自動的な最小~size:~SIZING#automatic-minimum-size
~autoとして挙動する:~SIZING#behave-as-auto
内縁:~SIZING#inner-size
内縁~size:~SIZING#inner-size
選好d縦横比:~SIZING#preferred-aspect-ratio
伸張して収まる~size:~SIZING#stretch-fit-size
自動的~size:~SIZING#automatic-size

生来な~size:~CSSIMAGE#natural-size
生来な縦横比:~CSSIMAGE#natural-aspect-ratio

整形される最初の行l:~CSSPSEUDO#first-formatted-line
識別子~符号位置:~CSSSYN#ident-code-point
空白:~CSSSYN#whitespace

~flex~layout:~CSSFLEX#flex-layout
	~flex~layout:http://www.w3.org/TR/css3-flexbox
~flex容器:~CSSFLEX#flex-container
~flex駒:~CSSFLEX#flex-item
主-軸:~CSSFLEX#main-axis

文書~空白:~CSSTEXT#white-space

解決d値:~CSSOM1#resolved-values
解決d値は特別に定義される:~CSSOM1#resolved-value-special-case-property
静的~位置:~CSSPOS#static-position
絶対~位置決め包含塊:~CSSPOS#absolute-positioning-containing-block
絶対~位置決め:~CSSPOS#absolute-position
相対~位置決め:~CSSPOS#relative-position

	#abs-non-replaced-width
	white space:~CSS22/text.html#white-space-prop

~layout封込め:~CSSCONTAIN#layout-containment

断片化~文脈:~CSSBREAK#fragmentation-context
断片化~容器:~CSSBREAK#fragmentation-container
分断:~CSSBREAK#fragmentation-break
断片化-:~CSSBREAK#fragment

複柱~容器:~CSSMCOL#multi-column-container

絶対的に位置され:~CSSPOS#absolute-position

~scroll容器:~CSSOVERFLOW3#scroll-container
~scroll可能な~overflow矩形:~CSSOVERFLOW3#scrollable-overflow-rectangle
~scroll可能な~overflow区画:~CSSOVERFLOW3#scrollable-overflow-region
~scrollbar側溝:~CSSOVERFLOW3#scrollbar-gutter

内容~区画:~CSSBOX#content-area
内容~box:~CSSBOX#content-box
~border~box:~CSSBOX#border-box
~margin:~CSSBOX#margin
相殺-:~CSS2J#collapsing-margins
浮動-:~CSS2J#floats
浮動体:~CSS2J#floats

媒体~query:~MQ5#media-query
離散的:~WANIM#discrete
要素間~空白:~HTMLdom#inter-element-whitespace

~level 1:~TR/css-grid-1/

	~table-cell の基底線の決定:~CSS2TABLE#height-layout

●●images
＠css-grid/
	basic-form｜height:242px;｜Image: Application layout example requiring horizontal and vertical alignment.｜.png
game-smaller｜height:265px;｜｜.png
game-larger｜height:313px;｜｜.png
game-portrait｜height:303px;｜＝Image: An arrangement suitable for portrait orientation.｜.png
game-landscape｜height:240px;｜＝Image: An arrangement suitable for landscape orientation.｜.png
grid-lines｜height:320px;｜＝Image: Grid Lines.｜.svg
drawing-order｜height:220px;｜｜.svg
grid-named-lines｜height:320px;｜＝Image: Named Grid Lines.｜.svg
grid-shorthand｜height:330px;｜｜.svg
auto-flow｜height:360px;｜＝SVG image: auto flow grid｜.svg
	auto-placed-form｜width:521px; height:354px;｜Image: A form arranged using automatic placement.｜.png
implicit-lines-search｜height:300px;｜｜.svg
subgrid-gap-normal｜height:464px;｜＋｜.png
subgrid-gap-0px｜height:465px;｜＋｜.png
subgrid-gap-25px｜height:465px;｜＋｜.png
subgrid-gap-75px｜height:465px;｜＋｜.png
abspos-grid｜height:400px;｜＋｜.svg

●●ref_key_map
CSS3BREAK:CSSBREAK3
CSS3WRITINGMODES:CSSWRITINGMODES3

●●ref_normative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Box Alignment Module Level 3＞. URL: https://drafts.csswg.org/css-align/
[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 4＞. URL: https://drafts.csswg.org/css-break-4/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. ＜CSS Containment Module Level 2＞. URL: https://drafts.csswg.org/css-contain-2/
[CSS-DISPLAY-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Display Module Level 3＞. URL: https://drafts.csswg.org/css-display/
[CSS-DISPLAY-4]
    ＜CSS Display Module Level 4＞. Editor's Draft. URL: https://drafts.csswg.org/css-display-4/
[CSS-FLEXBOX-1]
    Tab Atkins Jr.; et al. ＜CSS Flexible Box Layout Module Level 1＞. URL: https://drafts.csswg.org/css-flexbox-1/
[CSS-GRID-1]
    Tab Atkins Jr.; et al. ＜CSS Grid Layout Module Level 1＞. URL: https://drafts.csswg.org/css-grid/
[CSS-IMAGES-3]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. ＜CSS Images Module Level 3＞. URL: https://drafts.csswg.org/css-images-3/
[CSS-INLINE-3]
    Dave Cramer; Elika Etemad. ＜CSS Inline Layout Module Level 3＞. URL: https://drafts.csswg.org/css-inline-3/
[CSS-OVERFLOW-3]
    Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-POSITION-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 3＞. URL: https://drafts.csswg.org/css-position-3/
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. ＜CSS Pseudo-Elements Module Level 4＞. URL: https://drafts.csswg.org/css-pseudo-4/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[CSS-SIZING-4]
    Tab Atkins Jr.; Elika Etemad; Jen Simmons. ＜CSS Box Sizing Module Level 4＞. URL: https://drafts.csswg.org/css-sizing-4/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-TEXT-4]
    Elika Etemad; et al. ＜CSS Text Module Level 4＞. URL: https://drafts.csswg.org/css-text-4/
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. URL: https://drafts.csswg.org/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. URL: https://drafts.csswg.org/css-writing-modes-4/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSS22]
    Bert Bos. ＜Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification＞. URL: https://drafts.csswg.org/css2/
[CSS3-BREAK]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 3＞. URL: https://drafts.csswg.org/css-break/
[CSS3-WRITING-MODES]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 3＞. URL: https://drafts.csswg.org/css-writing-modes-3/
[CSSOM]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MEDIAQUERIES-5]
    Dean Jackson; et al. ＜Media Queries Level 5＞. URL: https://drafts.csswg.org/mediaqueries-5/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[WEB-ANIMATIONS-1]
    Brian Birtles; et al. ＜Web Animations＞. URL: https://drafts.csswg.org/web-animations-1/

●●ref_informative

[CSS-MULTICOL-1]
    Florian Rivoal; Rachel Andrew. ＜CSS Multi-column Layout Module Level 1＞. URL: https://drafts.csswg.org/css-multicol/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Grid Layout Module Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-grid-2/
公表履歴
	https://www.w3.org/standards/history/css-grid-2/
実装報告
	https://wpt.fyi/results/css/css-grid/subgrid

フィードバック
	<a href="https://github.com/w3c/csswg-drafts/issues?q=is%3Aopen+is%3Aissue+label%3Acss-grid-2">CSSWG Issues Repository</a>

編集
	<a href="http://www.xanthir.com/contact/">Tab Atkins Jr.</a> (Google)
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Apple)
	<a href="mailto:ratan@microsoft.com">Rossen Atanassov</a> (Microsoft)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-grid-2/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-grid-2

</script>

</head>
<body>


<!--%resource pool -->
<template id="_persisted_parts">

	<!-- flex-layout.png -->
<div
	id="_dgm-flex-layout"
	class="_ex-fg-layout"
>
	<div style="width: 9.5em; left:0em"></div>
	<div style="width: 9.5em; left:10em"></div>
	<div style="width: 9.5em; left:20em"></div>

	<div style="width: 5.5em; top:2em; left:0em"></div>
	<div style="width: 5.5em; top:2em; left:6em"></div>
	<div style="width: 5.5em; top:2em; left:12em"></div>
	<div style="width: 5.5em; top:2em; left:18em"></div>
	<div style="width: 5.5em; top:2em; left:24em"></div>
</div>

	<!-- grid-layout.png -->
<div
	id="_dgm-grid-layout"
	class="_ex-fg-layout"
>
	<div style="width: 6em; left:0em"></div>
	<div style="width: 6em; left:6.5em"></div>
	<div style="width: 6em; left:13em"></div>
	<div style="width: 10em; height:3.5em; left:19.5em"></div>

	<div style="width:12.5em; top:2em; left:0em"></div>
	<div style="width:6em; top:2em; left:13em"></div>
</div>

<table id="_dgm-basic-form">
<tbody><tr><td>氏名
<td><input type="text"/>
<td rowspan="3">
所属科<br>
<select multiple>
<option>あっち系</option>
<option>そっち系</option>
<option>こっち系</option>
<option>にっち系</option>
</select>

<tr><td>登録名
<td><input type="text"/>

<tr><td>メール
<td><input type="text"/>

<tr><td><td colspan="2" style="text-align:right; font-size: 1.2em;">
<button>取り消し</button><button>戻る</button><button>次へ</button>
</table>

<table id="_dgm-auto-placed-form">
<tbody><tr><td>氏名（姓）
<td><input type="text"/>
<td rowspan="3">
所属科<br>
<select multiple>
<option>あっち系</option>
<option>そっち系</option>
<option>こっち系</option>
<option>にっち系</option>
</select>

<tr><td>氏名（名）
<td><input type="text"/>

<tr><td>〒郵便番号
<td><input type="text"/>

<tr><td>都道府県
<td><select><option>東京都</option></select>
<td>

<tr><td>市区町村・番地
<td><input type="text" />
<td>

<tr><td>建物名・号室
<td><input type="text" />
<td>

<tr><td colspan="3" style="text-align:right;">
<button>取り消し</button><button>戻る</button><button>次へ</button>
</table>

<svg
	id="_dgm-align-justify-content"
	xmlns="http://www.w3.org/2000/svg"
	viewBox="-1 -1 242 202"
	width="242" height="202"
	shape-rendering="crispEdges"
>
<path
	fill="none"
	stroke="var(--K-color)" stroke-width="1" stroke-dasharray="5 3"
	d="
M0,0 h240
M0,50 h240
M0,100 h240
M0,150 h240
M0,200 h240
M0,0 v200
M60,0 v200
M120,0 v200
M180,0 v200
M240,0 v200
" />
</svg>


<div
	id="_dgm-spanned-gap"
	class="_ex-spanned-gap"
>
<div style="width:35em; height:9em; left:0em; top:0em;"
><div>item1</div></div>
<div style="width:17em; height:19em; left:0em; top:10em;"
><div>item2</div></div>
<div style="width:17em; height:9em; left:18em; top:10em; "
><div>item3</div></div>
<div style="width:8em; height:9em; left:18em; top:20em; "
><div>item4</div></div>
<div style="width:8em; height:9em; left:27em; top:20em; "
><div>item5</div></div>
</div>

<div
	id="_dgm-spanned-gap-align"
	class="_ex-spanned-gap"
>
<div style="width:47em; height:9em; left:0em; top:1em;"
><div>item1</div></div>
<div style="width:21em; height:21em; left:0em; top:13em;"
><div>item2</div></div>
<div style="width:21em; height:9em; left:26em; top:13em; "
><div>item3</div></div>
<div style="width:8em; height:9em; left:26em; top:25em;"
><div>item4</div></div>
<div style="width:8em; height:9em; left:39em; top:25em;"
><div>item5</div></div>
</div>

<div
	id="_dgm-grid-item-determination"
	aria-describedby="_alt-grid-item-determination"
><div>blcok<br>&nbsp;<br>&nbsp;</div
><div>float<br>&nbsp;<br>&nbsp;</div
><div>anonymous item 3<br>&nbsp;<br>&nbsp;</div
><div style="text-align: center; margin-right:0;">item 4<br><q>item 4</q><br>item 4</div></div>

</template>

<header>
	<hgroup>
<h1>CSS 格子レイアウト — CSS Grid Layout Module Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この仕様は、
~UI設計に最適化された，二次元~格子に基づく~layout~systemを定義する。
格子~layout~modelにおいては、
格子~容器の一連の子を，予め定義された［
~flex可能な~size／固定d~size
］の~layout格子の中の任意な区画に位置させられる。
この~level 2 では、
`入子な格子$用に［
親~格子の~sizingに関与するような， “下位格子” の能力
］を追加して，`~level 1$ を拡げる。
◎
This CSS module defines a two-dimensional grid-based layout system, optimized for user interface design. In the grid layout model, the children of a grid container can be positioned into arbitrary slots in a predefined flexible or fixed-size layout grid. Level 2 expands Grid by adding “subgrid” capabilities for nested grids to participate in the sizing of their parent grids.
</p>

~CSSisaLANG

	</section>

	<section id="sotd">
◎位置付け

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

<p>
◎
（すでに勧告候補になったので不要。）
The CSSWG has resolved to move CSS Grid Level 2 to Candidate Recommendation. This transition is merely pending editorial work to merge the CSS Grid Level 1 prose into this document.
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
格子~layout（ Grid Layout ）は、
~CSS用の~layout~modelであり，
~boxとその内容に対する~sizingと位置決めを制御する強力な能を備える。
単独の軸を指向する`~flex~layout$ `CSS-FLEXBOX-1$r と違って、
格子~layoutは，［
両~次元とも内容の整列が欲されるような，二次元的な~layout
］に最適化されている。
◎
Grid Layout is a layout model for CSS that has powerful abilities to control the sizing and positioning of boxes and their contents. Unlike Flexible Box Layout, which is single-axis–oriented, Grid Layout is optimized for 2-dimensional layouts: those in which alignment of content is desired in both dimensions.
</p>

<figure>`flex-layout^dgm
<figcaption>
~flex~layoutの例：
2 本の~rowがある。
1 本目には，それぞれが空間の 1 / 3 を占める 3 個の駒が在り、
2 本目には，それぞれが空間の 1 / 5 を占める 5 個の駒が在る。
したがって、
~row沿いには整列があるが，~col沿いにはない。
◎
alt=
An example of flex layout: two rows of items, the first being three items a third of the space each, and the second being five items, a fifth of the space each. There is therefore alignment along the “rows”, but not along the “columns”.
◎
Representative Flex Layout Example
</figcaption></figure>

<figure>`grid-layout^dgm
<figcaption>
格子~layoutの例：
2 本の~rowが在る。
1 本目には 4 個の駒が在り、
その最後の駒は両~rowに~spanする。
2 本目には、［
最初の 2 本の~colに~spanする駒,
1 個の駒,
1 本目の~rowから~spanする最後の駒
］が在る。
◎
alt=
An example of grid layout: two rows of items, the first being four items—the last of which spans both rows, and the second being two items—the first of which spans the first two columns— plus the spanned item from the first row.
◎
Representative Grid Layout Example
</figcaption></figure>

<p>
加えて，格子~layoutでは、
格子~内に駒を明示的に位置する能に因り，［
対応する~markup変更を要することなく，
視覚的な~layout構造を劇的に変形する
］ことが許容される。
`媒体~query$と［
格子~容器とその一連の子の~layout
］を制御する各種~CSS~propとの組合nにより、
作者は，［
内容に対する より理想的な意味論上の構造付け
］を様々な呈示にわたって保全しながら、
~layoutを多様な［
機器形態, 使用方位, 可用な空間
］に順応させれるようになる。
◎
In addition, due to its ability to explicitly position items in the grid, Grid Layout allows dramatic transformations in visual layout structure without requiring corresponding markup changes. By combining media queries with the CSS properties that control layout of the grid container and its children, authors can adapt their layout to changes in device form factors, orientation, and available space, while preserving a more ideal semantic structuring of their content across presentations.
</p>

<div>
<p>
多くの~layoutは［
`格子~layout$または`~flex~layout$
］で表出できるが、
それぞれには得意分野がある：
</p>
<ul>
	<li>
格子~layoutは
⇒＃
二次元的な整列を施行する ／
~layoutに対し ~top-down式に~approachする ／
駒どうしを明示的に重合させることも許容する ／
駒を~spanさせるより強力な能力を備える
</li>
	<li>
`~flex~layout$は
⇒＃
一方の軸（主-軸）の中での空間の分配に力点を置く ／
~layoutに対し より単純な~bottom-up式に~approachする ／
内容~sizeに基づいて~flex行lを折返す~systemを利用して 他方の軸（交叉-軸）を制御できる ／
より複階的な~layoutを築くときに 下層の~markup階層に依拠する
</li>
</ul>
<p>
両者は、
~CSS作者にとって価値のある，相補的な道具になることが期待されている。
</p>

◎
Although many layouts can be expressed with either Grid or Flexbox, they each have their specialties. Grid enforces 2-dimensional alignment, uses a top-down approach to layout, allows explicit overlapping of items, and has more powerful spanning capabilities. Flexbox focuses on space distribution within an axis, uses a simpler bottom-up approach to layout, can use a content-size–based line-wrapping system to control its secondary axis, and relies on the underlying markup hierarchy to build more complex layouts. It is expected that both will be valuable and complementary tools for CSS authors.
</div>

<p>
~level 2 は、
`下位格子$の特能を追加する
⇒
`下位格子~化$された軸は，その各~罫が［
要素の親である格子
］内の罫に合致するようにするものであり、
`親~格子$への この統合を通して，【下位格子の】各~筋の~sizeを導出する。
◎
Grid Level 2 adds the subgrid feature: a subgridded axis is one which matches up its grid lines to lines in the element’s parent’s grid, and which derives the sizes of its tracks through this integration with the parent grid.
</p>

		<section id="background">
<h3 title="Background and Motivation">1.1. 背景0と動機</h3>

<figure style="float:right; margin:0 0 0.5em 1em;">`basic-form^dgm
<figcaption style="max-width: 20em">
横方向と縦方向の整列を要する~appの~layout例
◎
Application layout example requiring horizontal and vertical alignment.
</figcaption></figure>

<p>
~web~siteが単純な文書から複階的で対話的な~appへ発展するに伴い、
例えば`浮動体$などの文書~layout用の技法は，
~appの~layoutにとり十分なものとは言えなくなってきている。
~web~app作者たちは、［
~table, JavaScript, 浮動された要素に対する注意深い測定
］の組合nを利用しながら，
欲される~layoutを達成するための対処法を模索してきた。
可用な空間の変化に順応する~layoutは，不安定なことが多く、
空間の拘束が厳しくなるに伴い，直感に反する挙動に悩まされる。
代替として，多くの作者は固定的な~layoutを~~選んでいるが、
画面~上の可用な描画~空間の可変性から得られる利点は享受できなくなる。
◎
As websites evolved from simple documents into complex, interactive applications, techniques for document layout, e.g. floats, were not necessarily well suited for application layout. By using a combination of tables, JavaScript, or careful measurements on floated elements, authors discovered workarounds to achieve desired layouts. Layouts that adapted to the available space were often brittle and resulted in counter-intuitive behavior as space became constrained. As an alternative, authors of many web applications opted for a fixed layout that cannot take advantage of changes in the available rendering space on a screen.
</p>

<p>
格子~layoutには、
これらの問題を解消する能力がある。
それは、［
一連の予測-可能な~sizingの挙動を利用して，
可用な空間を何本かの~colや~rowに分割0して~layoutする
］ための仕組みを作者に供する。
作者は、
~appの構築部品を成す要素~群の精確な位置と~sizeを，［
これらの~colや~rowの交差域で定義される`区画$
］の中で与えられるようになる。
格子~layoutの順応的~能力, それにより［
内容と~styleを もっときれいに分離する方法
］を，以下の例で~~説明する。
◎
The capabilities of grid layout address these problems. It provides a mechanism for authors to divide available space for layout into columns and rows using a set of predictable sizing behaviors. Authors can then precisely position and size the building block elements of their application into the grid areas defined by the intersections of these columns and rows. The following examples illustrate the adaptive capabilities of grid layout, and how it allows a cleaner separation of content and style.
</p>

			<section id="adapting-to-available-space">
<h4 title="Adapting Layouts to Available Space">1.1.1. ~layoutを可用な空間に順応させる</h4>

<div style="display:flow-root;">
<figure style="float:right; margin:0 0 0.5em 1em; max-width:370px;">
<p class="alt" hidden id="_dgm-game-smaller">
2 本の~colと 3 本の~rowに~lay-outされるゲームを考える。
左~colには、
上から順に~title, ~menu, スコアがある。
右~colには、
上端~升と中段~升を占めている盤面, 下端を埋めている~controlがある。
左~colは，その内容が正確に収まるよう~sizeされ、
右~colは，残りの空間を埋める。
◎
Let us consider the layout of a game in two columns and three rows: the game title in the top left corner, the menu below it, and the score in the bottom left with the game board occupying the top and middle cells on the right followed by game controls filling the bottom left. The left column is sized to exactly fit its contents (the game title, menu items, and score), with the right column filling the remaining space.
</p>
<figcaption>
［
可用な空間と, 各自の内容~size
］に則って配列された 5 個の格子~駒
◎
Five grid items arranged according to content size and available space.
</figcaption></figure>

<p>
格子~layoutを利用すれば、
~web~page内の要素を気の利いた~~形に~sizeし直せる。
ここに示す 2 つの図は、
5 個の主要な~component［
~title, 成績, 盤面, スコア, ~control
］を備えたゲームの~layoutを表現している。
作者の意図は、
ゲーム用の空間を次の様に分割0することである：
◎
Grid layout can be used to intelligently resize elements within a webpage. The adjacent figures represent a game with five major components in the layout: the game title, stats area, game board, score area, and control area. The author’s intent is to divide the space for the game such that:
</p>

<ul>
	<li>
成績~区画は、
常に，~titleの直下に現れる。
◎
The stats area always appears immediately under the game title.
</li>
	<li>
盤面は、
成績, ~titleを併せた区画の右側に現れる。
◎
The game board appears to the right of the stats and title.
</li>
	<li>
~titleと盤面の上端は常に整列されるべきである。
◎
The top of the game title and the game board should always align.
</li>
	<li>
盤面と成績~区画の下端は、
ゲームが可用な空間の最小~縦幅に達したときには整列するが、
他のときは，可用な空間による利点を享受できるよう盤面を伸張する（下の図）。
◎
The bottom of the game board and bottom of the stats area align when the game has reached its minimum height. In all other cases the game board will stretch to take advantage of all the space available to it.
</li>
	<li>
~controlは、
盤面の下側にて中央寄せにする。
◎
The controls are centered under the game board.
</li>
	<li>
スコア区画は、
成績~区画の下にあり，
その上端は~control区画の上端に整列する。
◎
The top of the score area is aligned to the top of the controls area.
◎
The score area is beneath the stats area.
◎
The score area is aligned to the controls beneath the stats area.
</li>
</ul>

<figure>
<p class="alt" hidden id="_dgm-game-larger">
~screenが大きくなり，空間がもっと可用になるに伴い、
中段~rowと右~colは，その空間を埋めるよう拡げることが許容される。
◎
As more space becomes available in larger screens, the middle row / right column are allowed to expand to fill that space.
</p>
<figcaption>
可用な空間の増分による，格子の拡幅
◎
Growth in the grid due to an increase in available space.
</figcaption></figure>
</div>

<p>
次の格子~layout例に、
すべての［
~sizing, 配置, 整列
］規則を宣言的に達成する方法を示す：
◎
The following grid layout example shows how an author might achieve all the sizing, placement, and alignment rules declaratively.
</p>

<div class="example">
<pre class="lang-css">
/** <span class="comment">
`格子~容器$上に格子を宣言して、
各 `格子~駒$用の空間を定義する。
◎
Define the space for each grid item by declaring the grid on the grid container.
</span> */

#grid {

  /* <span class="comment">
格子~layoutで内容を~lay-outする。
</span> */
  display: grid;

  /* <span class="comment" style="white-space:pre-line;"
>2 本の~col：
   • 1 本目の~colは内容に合わせて~sizeされる。
   • 2 本目の~colは残りの空間を受取る（が、この~colを占める盤面やゲーム~controlに要する最小~横幅よりは，決して小さくされない）。
◎
   * Two columns:
   *  1. the first sized to content,
   *  2. the second receives the remaining space
   *     (but is never smaller than the minimum size of the board
   *     or the game controls, which occupy this column [Figure 4])
</span>  */

  grid-template-columns:
    /* col 1 */ auto
    /* col 2 */ 1fr;

  /* <span class="comment" style="white-space:pre-line;"
>3 本の~row：
   • 1 本目, 3 本目の~rowは内容に合わせて~sizeされる。
   • 2 本目の~rowは残りの空間を受取る（が、盤面／成績~区画に要する最小~縦幅よりは，決して小さくされない）。
◎
   * Three rows:
   *  3. the first sized to content,
   *  4. the middle row receives the remaining space
   *     (but is never smaller than the minimum height
   *      of the board or stats areas)
   *  5. the last sized to content.
</span>  */

  grid-template-rows:
    /* row 1 */ auto
    /* row 2 */ 1fr
    /* row 3 */ auto;
}

  /* <span class="comment">
各 駒の位置を［
各自の `grid-row$p, `grid-column$p ~propによる座標
］を利用して指定する。
◎
Specify the position of each grid item using coordinates on the 'grid-row' and 'grid-column' properties of each grid item.
</span>*/

#title    { grid-column: 1; grid-row: 1; }
#score    { grid-column: 1; grid-row: 3; }
#stats    { grid-column: 1; grid-row: 2; align-self: start; }
#board    { grid-column: 2; grid-row: 1 / span 2; }
#controls { grid-column: 2; grid-row: 3; justify-self: center; }

</pre>

<pre class="lang-html">
&lt;div id="grid"&gt;
  &lt;div id="title"&gt;Game Title&lt;/div&gt;
  &lt;div id="score"&gt;Score&lt;/div&gt;
  &lt;div id="stats"&gt;Stats&lt;/div&gt;
  &lt;div id="board"&gt;Board&lt;/div&gt;
  &lt;div id="controls"&gt;Controls&lt;/div&gt;
&lt;/div&gt;
</pre>
</div>

<p class="note">注記：
格子の構造や, 一連の`格子~駒$の位置／~sizeを指定する際には、
局面に応じて最適化された仕方が，複数あることに注意。
◎
Note: There are multiple ways to specify the structure of the grid and to position and size grid items, each optimized for different scenarios.
</p>

			</section>
			<section id="source-independence">
<h4 title="Source-Order Independence">1.1.2. ~source順序からの独立性</h4>

<p>
前節の例から継続して，作者は、
ゲームを種々の異なる機器にも順応させたいとする。
また，［
縦置き（ `portrait^v ）／横置き（ `landscape^v ）
］どちらの方位（ `orientation$d ）で~~表示されても（下の 2 つの図）、
ゲームを成す各~componentの配置は最適化されるべきであるとする。
格子~layoutを`媒体~query$と組合せることで、
作者は，一連の要素を
— それらの意味論上の~markupは変えないまま,
~source順序とは独立に,
どちらの方位でも欲される~layoutが達成されるよう —
配列し直せる。
◎
Continuing the prior example, the author also wants the game to adapt to different devices. Also, the game should optimize the placement of the components when viewed either in portrait or landscape orientation (Figures 6 and 7). By combining grid layout with media queries, the author is able to use the same semantic markup, but rearrange the layout of elements independent of their source order, to achieve the desired layout in both orientations.
</p>

<figure class="sidefigure1">
<figcaption id="_dgm-game-portrait">
“縦置き” 方位に適する配列法。
◎
An arrangement suitable for “portrait” orientation.
</figcaption></figure>

<figure class="sidefigure1">
<figcaption id="_dgm-game-landscape">
“横置き” 方位に適する配列法。
◎
An arrangement suitable for “landscape” orientation.
</figcaption></figure>

<p>
次の例では、
格子~layoutの能を利用して，`格子~駒$に占められる空間を命名する。
これにより、
格子の定義が変更されても，`格子~駒$用の規則は書き直さずに済むようになる。
◎
The following example uses grid layout’s ability to name the space which will be occupied by a grid item. This allows the author to avoid rewriting rules for grid items as the grid’s definition changes.
</p>

<div class="example">
<pre class="lang-css">
@media (`orientation$d: portrait) {
  #grid {
    display: grid;

    /* <span class="comment">
格子の各［
~row, ~col, 区画
］は、
`grid-template-areas$p ~propを利用して視覚的に定義される。
各~文字列が 1 本の~rowを表し, その中の各~単語が~rowの中のある区画を表す。
~col数は文字列~内の語数から決定される
— どの文字列~内の語数も一致するように揃えなければならないことに注意。
◎
The rows, columns and areas of the grid are defined visually using the grid-template-areas property. Each string is a row, and each word an area. The number of words in a string determines the number of columns. Note the number of words in each string must be identical.
</span>*/
    grid-template-areas: "title stats"
                         "score stats"
                         "board board"
                         "ctrls ctrls";

    /* <span class="comment">
各［
~col／~row
］を~sizeする仕方は［
`grid-template-columns$p ／ `grid-template-rows$p
］~propであてがえる。
◎
The way to size columns and rows can be assigned with the grid-template-columns and grid-template-rows properties.
</span>*/

    grid-template-columns: auto 1fr;
    grid-template-rows: auto auto 1fr auto;
  }
}

@media (`orientation$d: landscape) /* <span class="comment">横置き方位</span> */ {
  #grid {
    display: grid;
    /* <span class="comment">
~template~propは，ここでも同じ一連の名前からなる区画を定義するが、
ここでは，横置き方位により適するように位置を替える：
◎
Again the template property defines areas of the same name, but this time positioned differently to better suit a landscape orientation.
</span>*/
    grid-template-areas: "title board"
                         "stats board"
                         "score ctrls";

    grid-template-columns: auto 1fr;
    grid-template-rows: auto 1fr auto;
  }
}

/* <span class="comment">
`grid-area$p ~propにより、
格子~駒は，格子の有名~区画に配置されるようになる：
◎
The grid-area property places a grid item into a named area of the grid.
</span>*/
#title    { grid-area: title }
#score    { grid-area: score }
#stats    { grid-area: stats }
#board    { grid-area: board }
#controls { grid-area: ctrls }
</pre>

<pre class="lang-html">
&lt;div id="grid"&gt;
  &lt;div id="title"&gt;Game Title&lt;/div&gt;
  &lt;div id="score"&gt;Score&lt;/div&gt;
  &lt;div id="stats"&gt;Stats&lt;/div&gt;
  &lt;div id="board"&gt;Board&lt;/div&gt;
  &lt;div id="controls"&gt;Controls&lt;/div&gt;
&lt;/div&gt;
</pre>
</div>

<p class="note">注記：
格子~layoutによる並替ngの能力が影響するのは、
意図的に，`~~描画（視覚的な具現化）に限られる^em
— 発話~順序, ~source順序に基づく~naviは、
そのままであり続ける。
これは、
作者が，視覚的な呈示を［
非~CSS~UA／
発話や逐次的~naviなどの一次元な~model
］用の~source順序に触れることなく操作したり最適化することを許容する。
◎
Note: The reordering capabilities of grid layout intentionally affect only the visual rendering, leaving speech order and navigation based on the source order. This allows authors to manipulate the visual presentation while leaving the source order intact and optimized for non-CSS UAs and for linear models such as speech and sequential navigation.
</p>

<p class="advisement"><strong>
格子~駒の配置と並替ngは、
~sourceに対する正しい順序付けの代用として利用してはナラナイ
— 文書の~accessibilityが損なわれることになるので。
◎
Grid item placement and reordering must not be used as a substitute for correct source ordering, as that can ruin the accessibility of the document.
</strong></p>

			</section>
		</section>
		<section id="values">
<h3 title="Value Definitions">1.2. 値~定義</h3>

<p class="trans-note">【
この節の内容は、
`~CSS日本語訳 共通~page＠~CSScommon#values$に移譲。
】</p>

		</section>
		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

<p>
この節の以下では、
本文を解釈するために必要な情報を与える。
</p>

<p>
縦横いずれかの軸に属する`筋$
— ~rowまたは~col —
について述べている文脈の下での，
(1) ［
`筋^i, `辺^i, `罫^i
］などの，どちらの軸にも属し得る語、
あるいは
(2) ［
`始端^i, `終端^i, `~size^i, `~span^i, `位置^i, `距離^i, `空間^i
］などの，どちらの軸にも相対的になり得る語は、
他が指定されない限り，その文脈の下で
<em>
一貫して，当の軸に［
(1) 属する方, あるいは (2) 相対的な方
］を表す
</em>
とする。
(2) の “相対的” とは、
格子の中のどの筋かにより変わり得る方 —
すなわち、
格子の中で<strong>筋が並べられていく方向</strong>（筋に垂直な軸）に基づくこと意味する。
</p>

<p>
加えて、［
~row, ~col
］どちらの筋にも該当し得る記述は、
他が指定されない限り，`並立的な^em 記述であり, その上で前~段落の規約も適用するとする。
</p>

<p>
例えば，
<span class="block" style="padding:0.5em;">
“格子を成す各 `筋$の始端に在る`罫$の位置は…”
</span>
の様な記述は、
次のような（冗長な） 2 つの記述が並行している（ 2 つを個別に解釈する）ことを表す：
</p>

<ul>
	<li>
“［
格子を成す各~colの［
~col軸に垂直な軸における［
~colの始端
］に在る，~col軸に平行な罫
］の，~col軸に垂直な軸における位置は…”
</li>
	<li>
“［
格子を成す各~rowの［
~row軸に垂直な軸における［
~rowの始端
］に在る，~row軸に平行な罫
］の，~row軸に垂直な軸における位置は…”
</li>
</ul>

<p><small>（
元々の原文が，多くの箇所でそのような~~形で記述されているが、
訳において特に，そのような~~形の記述に~~変形している箇所もある。
）</small></p>

		</section>
	</section>
	<section id="overview">
<h2 title="Overview">2. 概観</h2>

◎非規範的

<p>
格子~layoutは、
`格子$の利用を通して，その内容の~layoutを制御する：
まず、
縦横に交差する罫たちが成す集合で，
`格子~容器$の内容~用に~sizingと位置決めの座標系が作成される。
格子~layoutの特能には、
次が挙げられる：
◎
Grid Layout controls the layout of its content through the use of a grid: an intersecting set of horizontal and vertical lines which create a sizing and positioning coordinate system for the grid container’s contents. Grid Layout features
</p>

<ul>
	<li>
［
固定的な／~flex可能な／内容に基づく
］`筋~sizing関数$【！#track-sizing】
◎
fixed, flexible, and content-based track sizing functions
</li>
	<li>
<p>
`格子$内に`駒$を配置する：
◎
↓</p>
		<ul>
			<li>
次のいずれかを介して，`明示的に配置する＠#placement$
⇒＃
前方へ（正に）あるいは後方へ（負に）付番される格子~座標／
`罫~名$【！有名~罫】／
`有名~区画$
◎
explicit item placement via forwards (positive) and backwards (negative) numerical grid coordinates, named grid lines, and named grid areas;＼
</li>
			<li>
空な区画の中へ自動的に
— `order$p による`並替ng＠#order-property$も含めて —
配置する
◎
automatic item placement into empty areas, including reordering with order
</li>
		</ul>
	</li>
	<li>
空間に応じて追加的な内容を収容するよう，［
`筋$を繰返す／自動的に`筋$を追加する
］
◎
space-sensitive track repetition and automatic addition of rows or columns to accommodate additional content
</li>
	<li>
次により，整列とアキを制御する
⇒
`~margin＠#auto-margins$,
`側溝$,
各種 `~box整列~prop$
◎
control over alignment and spacing with margins, gutters, and the alignment properties
</li>
	<li>
内容を重合させる能，および
`z-index$p により その`多層化を制御する＠#z-order$
◎
the ability to overlap content and control layering with z-index
</li>
</ul>

<p>
`格子~容器$は、
より複階的な~layoutを作成するために必要yなだけ，
`~flex容器$と入子にしたり混在させたりできる。
◎
Grid containers can be nested or mixed with flex containers as necessary to create more complex layouts.
</p>

		<section id="overview-grid">
<h3 title="Declaring the Grid">2.1. 格子の宣言-法</h3>

<p>
`格子$の各`筋$（ ~row, ~col の総称）は、
`明示的な格子$用の各種~propを通して明示的に宣言して~sizeでき、
また，`明示的な格子$の外側に配置される駒に対しては暗黙的に作成され得る。
`grid$p 略式~propとその各種~下位propは、
格子の~parameter群を定義する。
（ `§ 格子の定義-法＠#grid-definition$ ）
◎
The tracks (rows and columns) of the grid are declared and sized either explicitly through the explicit grid properties or are implicitly created when items are placed outside the explicit grid. The grid shorthand and its sub-properties define the parameters of the grid. § 7 Defining the Grid
</p>

<p class="trans-note">【
`上述したように＠#_conventions$，筋の “~size” は、
長さではなく太さを指す。
】【
以下の各~節における例は、
横組みを念頭に記されている
— そのままでは縦組みには通用しない記述もあることに注意。
】</p>

<div class="example">
<p>
格子を宣言するいくつかの例を挙げる：
◎
Below are some examples of grid declarations:
</p>

<p>
次の宣言は、
4 個の有名~区画
— `H^css, `A^css, `B^css, `F^css —
を伴う格子を与える。
1 本目の~colは その内容が収まるように~sizeされ（ `auto$vt ）、
2 本目の~colは 残りの空間を占める（ `1fr^v ）。
各~rowの~sizingは既定の `auto$vt による（内容に基づく）が、
最後の~rowには，固定d~size `30px^v が与えられる。
◎
The following declares a grid with four named areas: H, A, B, and F. The first column is sized to fit its contents (auto), and the second column takes up the remaining space (1fr). Rows default to auto (content-based) sizing; the last row is given a fixed size of 30px.
</p>

<pre class="lang-css">
main {
  `grid$p: "H    H "
        "A    B "
        "F    F " 30px
  /     auto 1fr;
}
</pre>

<p>
次の宣言は、
それぞれが `5em^v 以上の多数の~rowを伴い，
格子~容器の縦幅（ `100vh^v ）までに収まる格子を与える。
明示的~colはなく、
~colは，内容が追加されるに伴って追加される。
結果の~col横幅は等しくされる（ `1fr^v ）。
右端を~overflowする内容は 印刷されないので、
印刷-用の代替-~layoutでは，代わりに~rowが追加される。
◎
The following declares a grid with as many rows of at least 5em as will fit in the height of the grid container (100vh). The grid has no explicit columns; instead columns are added as content is added, the resulting column widths are equalized (1fr). Since content overflowing to the right won’t print, an alternate layout for printing adds rows instead.
</p>

<pre class="lang-css">
main {
  grid: repeat(auto-fill, 5em) / auto-flow 1fr;
  height: 100vh;
}
@media print {
  main {
    grid: auto-flow 1fr / repeat(auto-fill, 5em);
  }
}
</pre>

<p>
次で宣言される格子は、
均等に~sizeされた 5 本の~col, および 3 本の~rowを伴う。
中段の~rowは、
残りの空間すべてを占める
（少なくともその内容が収まるに十分な）。
◎
The following declares a grid with 5 evenly-sized columns and three rows, with the middle row taking up all remaining space (and at least enough to fit its contents).
</p>

<pre class="lang-css">
main {
  grid: auto 1fr auto / repeat(5, 1fr);
  min-height: 100vh;
}
</pre>
</div>

		</section>
		<section id="overview-placement">
<h3 title="Placing Items">2.2. 駒の配置-法</h3>

<p>
`格子~容器$の内容は、
（`~flex駒$と相似的に）個々の`格子~駒$たちに編成されてから，
`格子$内の予め定義された各~区画にアテガわれる。
それらは、
`格子~配置~prop$により座標を利用して明示的に配置することも，
`自動-配置$を利用して空な区画に暗黙的に配置することもできる。
（`§ 格子~駒の配置-法＠#placement$）
◎
The contents of the grid container are organized into individual grid items (analogous to flex items), which are then assigned to predefined areas in the grid. They can be explicitly placed using coordinates through the grid-placement properties or implicitly placed into empty areas using auto-placement. § 8 Placing Grid Items
</p>

<div class="example">
<p>
`grid-area$p 略式を利用する いくつかの格子~配置~宣言：
◎
Below are some examples of grid placement declarations using the grid-area shorthand:
</p>

<pre class="lang-css">
grid-area: a;          /*
        <span class="comment">
`有名~区画$ "a" の中へ配置する
◎
Place into named grid area “a
</span> */
grid-area: auto;       /*
        <span class="comment">
次にある空な区画の中へ自動-配置する
◎
Auto-place into next empty area
</span> */
grid-area: 2 / 4;      /*
        <span class="comment">
~row 2, ~col 4 の中へ配置する
◎
Place into row 2, column 4
</span> */
grid-area: 1 / 3 / -1; /*
        <span class="comment">
すべての~rowに~spanする~col 3 の中へ配置する
◎
Place into column 3, span all rows
</span> */
grid-area: header-start / sidebar-start
           / footer-end / sidebar-end; /*
        <span class="comment">
`罫~名$【！有名~罫】を利用して配置する
◎
Place using named lines
</span> */
</pre>

<p>
これらは次の `grid-row$p, `grid-column$p を併用する宣言と等価になる：
◎
These are equivalent to the following grid-row + grid-column declarations:
</p>

<pre class="lang-css">
grid-row: a;        grid-column: a;
grid-row: auto;     grid-column: auto;
grid-row: 2;        grid-column: 4;
grid-row: 1 / -1;   grid-column: 3;

grid-row: header-start / footer-end;
    grid-column: sidebar-start / sidebar-end;
</pre>

<p>
これらは更に
`grid-row-start$p,
`grid-row-end$p,
`grid-column-start$p,
`grid-column-end$p
下位propに分解できる — 例えば：
◎
They can further be decomposed into the grid-row-start/grid-row-end/grid-column-start/grid-column-end longhands, e.g.
</p>

<pre class="lang-css">
grid-area: a;
/* <span class="comment">
次と等価になる：
◎
Equivalent to
</span>
    grid-row-start: a;
    grid-column-start: a;
    grid-row-end: a;
    grid-column-end: a;
*/
grid-area: 1 / 3 / -1;

/* <span class="comment">
次と等価になる：
◎
Equivalent to
</span>
    grid-row-start: 1;
    grid-column-start: 3;
    grid-row-end: -1;
    grid-column-end: auto;
*/
</pre>
</div>

		</section>
		<section id="overview-sizing">
<h3 title="Sizing the Grid">2.3. 格子の~sizing</h3>

<p>
`格子~駒$が`配置された＠#placement$なら：
◎
↓</p>

<ol>
	<li>
各 `筋$（ ~row／~col ）の~sizeが、
それら駒の内容や可用な空間の~sizeを織り込みながら，
格子~定義に指定されるように計算される。
◎
Once the grid items have been placed, the sizes of the grid tracks (rows and columns) are calculated, accounting for the sizes of their contents and/or available space as specified in the grid definition.
</li>
	<li>
<p>
次に，~sizeされた格子は、
`格子~容器$の`内容-分布~prop$に則って，その`格子~容器$の中で整列される。
（`§ 整列とアキ＠#alignment$）
◎
The resulting sized grid is aligned within the grid container according to the grid container’s align-content and justify-content properties. § 11 Alignment and Spacing
</p>

<div class="example">
<p>
次の例では、
横方向に余った空間をすべての~colに分配するように，両端の~colを端に寄せた上で、
`格子~容器$内の格子の縦幅が `100vh^v 未満のときは，それを縦方向に中央寄せにする。
◎
The following example justifies all columns by distributing any extra space among them, and centers the grid in the grid container when it is smaller than 100vh.
</p>

<pre class="lang-css">
main {
  grid: auto-flow 1fr / repeat(auto-fill, 5em);
  min-height: 100vh;
  justify-content: space-between;
  align-content: safe center;
}
</pre>
</div>

	</li>
	<li>
最後に，各 `格子~駒$は、
自身にアテガわれた`区画$の中で自前の［
~sizing~prop `CSS2$r と整列~prop `CSS-ALIGN-3$r
］に指定されるとおり~sizeされ，整列される。
◎
Finally each grid item is sized and aligned within its assigned grid area, as specified by its own sizing [CSS2] and alignment properties [CSS-ALIGN-3].
</li>
</ol>

		</section>
	</section>
	<section id="grid-concepts">
<h2 title="Grid Layout Concepts and Terminology">3. 格子~layoutの概念と各種用語</h2>

<p>
`格子~layout@
においては、
`格子~容器$の内容は，［
`格子$の中へ位置されてから，整列される
］ことにより~lay-outされる。
`格子@
（ `grid^en ）
とは、
`格子~容器$の空間をいくつかの`区画$に分割0する，
縦横に交差する`罫$たちが成す集合であり、
（`格子~容器$の内容を表現する）一連の`格子~駒$を，それらの区画に配置できるようにする。
これらの`罫$のうち、
`塊-軸$~~方向のものが
`格子~col@
— 略して <dfn>~col</dfn> —
を定義し、
それに直交な`行内-軸$~~方向のものが
`格子~row@
— 略して <dfn>~row</dfn> —
を定義する。
`CSS3-WRITING-MODES$r
◎
In grid layout, the content of a grid container is laid out by positioning and aligning it into a grid. The grid is an intersecting set of horizontal and vertical grid lines that divides the grid container’s space into grid areas, into which grid items (representing the grid container’s content) can be placed. There are two sets of grid lines: one set defining columns that run along the block axis, and an orthogonal set defining rows along the inline axis. [CSS3-WRITING-MODES]
</p>

<figure>
<figcaption id="_dgm-grid-lines">
塊-軸~~方向の`罫$が 3 本, 行内-軸~~方向の罫が 4 本。
【横組みの場合。】
◎
Grid lines: Three in the block axis and four in the inline axis.
</figcaption></figure>

		<section id="grid-line-concept">
<h3 title="Grid Lines">3.1. 罫（格子~線）</h3>

<p>
`格子~線@
（ `grid line^en ）
— 略して <dfn>罫</dfn>（ `line^en ） —
とは、
`格子$を［
横方向／縦方向
］に分割0する線である
【描画されない，概念的な線である】
【この訳では、もっぱら， “罫” の表記に統一する】
。
`罫$は、
各［
~row／~col
］を挟むように存在する。
それらは［
数量的~index【 1 から数える】, あるいは指定された名前
］で参照rできる。
`格子~駒$の`格子$内における位置は、
`格子~配置~prop＠#placement$を介して参照される`罫$から決定される。
◎
Grid lines are the horizontal and vertical dividing lines of the grid. A grid line exists on either side of a column or row. They can be referred to by numerical index, or by an author-specified name. A grid item references the grid lines to determine its position within the grid using the grid-placement properties.
</p>

<div class="example">
<p>
次の 2 つの例では、
いずれも［
3 本の~col`罫$と 4 本の~row`罫$
］が作成される。
◎
The following two examples both create three column grid lines and four row grid lines.
</p>

<p>
1 個目の例は、
番号【すなわち，数量的~index — 端から数えた本数】による`罫$を利用して`格子~駒$を位置する方法をデモる：
◎
This first example demonstrates how an author would position a grid item using grid line numbers:
</p>

<pre class="lang-css">
#grid {
  display: grid;
  grid-template-columns: 150px 1fr;
  grid-template-rows: 50px 1fr 50px;
}

#item1 {
  grid-column: 2;
  grid-row-start: 1; grid-row-end: 4;
}
</pre>

<p>
2 個目の例は、
`明示的にアテガわれる罫~名$【！有名~罫】を利用する：
◎
This second example uses explicitly named grid lines:
</p>

<pre class="lang-css">
/* <span class="comment">
先の例と等価な~layout。
ここでは、
明示的に命名された罫【！有名~罫】を利用する。
◎
equivalent layout to the prior example, but using named lines
</span>*/
#grid {
  display: grid;
  grid-template-columns: 150px [item1-start] 1fr [item1-end];
  grid-template-rows: [item1-start] 50px 1fr 50px [item1-end];
}

#item1 {
  grid-column: item1-start / item1-end;
  grid-row: item1-start / item1-end;
}
</pre>
</div>

		</section>
		<section id="grid-track-concept">
<h3 title="Grid Tracks and Cells">3.2. 格子の筋と升</h3>

<p>
`格子~筋@
— 略して <dfn>筋</dfn>（ `track^en ） —
とは、［
`格子~col$, `格子~row$
］の総称である
【この訳では、もっぱら， “筋” と略記する】
。
言い換えれば、
それは，隣接する 2 本の平行な`罫$の合間を成す空間である。
各`筋$には，~sizing関数がアテガわれる。
それは、
筋rcがどれだけ太く拡幅し得るか
— すなわち，その限界bを成す`罫$の間隔をどれだけ離せるか —
を制御する。
互いに隣接する`筋$は、
`側溝$で分離できる
— さもなければ すき間なく収納される。
◎
Grid track is a generic term for a grid column or grid row—in other words, it is the space between two adjacent grid lines. Each grid track is assigned a sizing function, which controls how wide or tall the column or row may grow, and thus how far apart its bounding grid lines are. Adjacent grid tracks can be separated by gutters but are otherwise packed tightly.
</p>

<p class="trans-note">【
筋 — 原語の `track^en は，陸上トラック競技の “トラック” と同じ~~概念。
】【
~row, ~colどちらが横方向になるかは、
§ `格子~layout$にて説明されたように，`書字~mode$に依存する
（`参照＠#note-writing-mode$）。
ほとんどの例は，
横組み（ ~rowが横方向）を前提に記されているが、
縦組みの場合には逆になる。
】</p>

<p>
`格子~升@
— 略して <dfn>升</dfn>（ `cell^en ） —
とは、
格子を成す［
ある~row, ある~col
］の交差域である
【この訳では、もっぱら， “升” と略記する】
。
それは、
~rowと~colのそれぞれについて隣接する 2 本の`罫$に囲まれた空間であり、
`格子~駒$を位置させるときに参照できる，格子の最~小な単位である。
◎
A grid cell is the intersection of a grid row and a grid column. It is the smallest unit of the grid that can be referenced when positioning grid items.
</p>

<div class="example">
<p>
次の例では、
2 本の~colと 3 本の~rowが在る。
1 本目の~colは太さ `150px^v に固定されている。
2 本目の~colの太さには ~flex可能な~sizing（ `1fr^v ）が利用されている
— それは格子~内で まだアテガわれてない空間の関数であり，`格子~容器$の横幅の変化に応じて変わることになる。
`格子~容器$の使用~横幅が `200px^v ならば、
2 本目の~colは太さ `50px^v になる。
`格子~容器$の使用~横幅が `100px^v ならば、
2 本目の~colは太さ `0px^v になり，［
この~colに位置された内容は，当の`格子~容器$を~overflowする
］ことになる。
◎
In the following example there are two columns and three rows. The first column is fixed at 150px. The second column uses flexible sizing, which is a function of the unassigned space in the grid, and thus will vary as the width of the grid container changes. If the used width of the grid container is 200px, then the second column is 50px wide. If the used width of the grid container is 100px, then the second column is 0px and any content positioned in the column will overflow the grid container.
</p>

<pre class="lang-css">
#grid {
  display: grid;
  grid-template-columns: 150px 1fr; /* <span class="comment">2 本の~col</span>*/
  grid-template-rows: 50px 1fr 50px /* <span class="comment">3 本の~row</span>*/
}
</pre>
</div>

		</section>
		<section id="grid-area-concept">
<h3 title="Grid Areas">3.3. 格子~区画</h3>

<p>
`格子~区画@
— 略して <dfn>区画</dfn>（ `area^en ） —
とは、
`格子~駒$の~lay-outに利用される，論理的な空間である
【この訳では、もっぱら， “区画” と略記する】
。
`区画$は、
互いに隣接する 1 個~以上の`升$からなる。
区画は、
その限界bの各~側に対応する 4 本の`罫$で囲まれる。
区画は、
それに交差する`筋$の~sizingに関与する。
区画は、［
`格子~容器$の `grid-template-areas$p ~propを利用して付与される名前
］を介して明示的に，あるいは［
その限界bを成す`罫$
］を介して暗黙的に，参照される。
各`格子~駒$は、
`格子~配置~prop＠#placement$を利用して`区画$にアテガわれる。
◎
A grid area is the logical space used to lay out one or more grid items. A grid area consists of one or more adjacent grid cells. It is bound by four grid lines, one on each side of the grid area, and participates in the sizing of the grid tracks it intersects. A grid area can be named explicitly using the grid-template-areas property of the grid container, or referenced implicitly by its bounding grid lines. A grid item is assigned to a grid area using the grid-placement properties.
</p>

<div class="example">
<pre class="lang-css">
/* <span class="comment">
~template構文の用例
◎
using the template syntax
</span>*/
#grid  {
  display: grid;
  grid-template-areas: ". a"
                       "b a"
                       ". a";
  grid-template-columns: 150px 1fr;
  grid-template-rows: 50px 1fr 50px;
  height: 100vh;
}

#item1 { grid-area: a }
#item2 { grid-area: b }
#item3 { grid-area: b }

/* <span class="comment">
`#item2^c と `#item3^c を区画 `b^l 内の異なる地点に整列させる。
既定では［
各~格子~駒は，自身が置かれる区画に収まるよう伸張される
］ので、
これらの駒は互いに重なることになる。
◎
Align items 2 and 3 at different points in the grid area "b".
By default, grid items are stretched to fit their grid area
and these items would layer one over the other.
</span>*/
#item2 { align-self: start; }
#item3 { justify-self: end; align-self: end; }
</pre>
</div>

<p>
`区画$は、
その中へ~lay-outされる`格子~駒$の`包含塊$を形成する。
同じ`区画$に配置された複数の`格子~駒$は、
互いの~layoutに直に影響することはない。
しかしながら，間接的には、
`格子~駒$が`内在的~sizing関数$を伴う場合，その駒が占めている筋の~sizeに
（したがってそれを囲んでいる`罫$の位置にも）
影響し得る結果、
別の`格子~駒$の位置や~sizeにも影響することになる。
◎
A grid item’s grid area forms the containing block into which it is laid out. Grid items placed into the same grid area do not directly affect each other’s layout. Indirectly, however, a grid item occupying a grid track with an intrinsic sizing function can affect the size of that track (and thus the positions of its bounding grid lines), which in turn can affect the position or size of another grid item.
</p>

		</section>
		<section id="subgrid-items">
<h3 title="Nested vs. Subgridded Items">3.4. 入子な格子~駒, 下位格子~化された格子~駒</h3>

<p>
`格子~駒$は、
その `display$p に `grid^v を与えることにより，`格子~容器$になれる
— そのような駒は、
`入子な格子@
と称される。
`入子な格子$の内容の~layoutは、
~~既定では，その
`親~格子@
— 自身が関与している`格子~容器$ —
の~layoutとは独立になる。
◎
A grid item can itself be a grid container by giving it display: grid. In the general case the layout of this nested grid’s contents will be independent of the layout of the parent grid it participates in.
</p>

<p>
しかしながら，複数の`格子~駒$
【すなわち，`入子な格子$内の各~駒, `親~格子$内の各~駒】
の内容を互いに整列することが必要yな事例もある。
`入子な格子$ %格子 は
`下位格子@
にすることもできる。
この事例では，
%格子 の`下位格子~化$された各~軸 %軸 において、
%格子 を成す各~筋の定義は親の`格子~容器$へ先送りされ，
%格子 を成す各`格子~駒$は %軸 において`親~格子$の~sizingに関与するようになり、
%格子 の内容を %軸 において`親~格子$の内容に
【したがって，`親~格子$を成す他の`下位格子$の内容とも】
整列できるようになる。
`§ 下位格子＠#subgrids$を見よ。
◎
However, in some cases it might be necessary for the contents of multiple grid items to align to each other. A nested grid can defer the definition of its rows and/or columns to its parent grid container, making it a subgrid. In this case, the grid items of the subgrid participate in sizing the parent grid, allowing the contents of both grids to align. See § 9 Subgrids.
</p>

<p>
`下位格子$は、［
`grid-template-rows$p ／ `grid-template-columns$p
］の `subgrid$vt ~keywordにより確立され，各 軸ごとに`下位格子~化$できる。
`下位格子~化$された軸は無い格子は
`自立的な格子@
を成す。
◎
A subgrid is established by the subgrid keyword of grid-template-rows or grid-template-columns, and can be subgridded in either axis or in both. A grid that has no subgridded axis is a standalone grid.
</p>

<p class="trans-note">【
言い換えれば，`下位格子$は、［
`入子な格子$のうち，［
~row, ~col
］軸どちらかは`下位格子~化$されたもの
］を指す総称として定義される。
】</p>

<div class="example">
<p>
例えば、
~listを成している何個かの入力からなる~formがあって，各~入力は~labelも伴うとする：
◎
For example, suppose we have a form consisting of a list of inputs with labels:
</p>
<pre class="lang-html">
&lt;ul&gt;
  &lt;li&gt;&lt;label&gt;Name:&lt;/label&gt; &lt;input name=fn&gt;
  &lt;li&gt;&lt;label&gt;Address:&lt;/label&gt; &lt;input name=address&gt;
  &lt;li&gt;&lt;label&gt;Phone:&lt;/label&gt; &lt;input name=phone&gt;
&lt;/ul&gt;
</pre>

<p>
［
各~labelどうし／各~入力どうし
］を互いに整列させ，各~list~itemを~borderで~styleしたいとする。
これは、
下位格子~layoutで成遂げれる：
◎
We want the labels and inputs to align, and we want to style each list item with a border. This can be accomplished with subgrid layout:
</p>

<pre class="lang-css">ul {
  display: grid;
  grid: auto-flow / auto 1fr;
}
li {
  grid-column: span 2;
  display: grid;
  grid-template-columns: subgrid;
  border: solid;
}
label {
  grid-column: 1;
}
input {
  grid-column: 2;
}
</pre>
</div>

		</section>
	</section>
	<section id="order-accessibility">
<h2 title="Reordering and Accessibility">4. 並替ngと~accessibility</h2>

<p>
格子~layoutは、
文書を配列し直す強大な力を作者に与えるが，
文書~sourceの順序付けの代用になるものではない。
◎
Grid layout gives authors great powers of rearrangement over the document. However, these are not a substitute for correct ordering of the document source.
…
</p>

<p class="trans-note">【
以下、
この節の内容は，
`CSS-DISPLAY-3$r `§ 並替ngと~accessibility＠~CSSDISP#order-accessibility$とほぼ同じなので、
この訳では省略する
（ `order$p を［
“`order$p や各種 `格子~配置~prop$”
］に読み替える下で）。
】</p>

	</section>
	<section id="grid-model">
<h2 title="Grid Containers">5. 格子~容器</h2>

		<section id="grid-containers">
<h3 title="Establishing Grid Containers: the grid and inline-grid display values">5.1. 格子~容器の確立-法： `display^p の `grid^v, `inline-grid^v 値</h3>

◎名 `display$p
◎新値
`grid$v | `inline-grid$v
◎表終

<dl class="valdef">
	<dt>`grid@v</dt>
	<dd>
この値は、
要素に`格子~容器$~boxを生成させる
— `~flow~layout$内に配置されたときには、
`塊~level$になるような。
◎
This value causes an element to generate a grid container box that is block-level when placed in flow layout.
</dd>

	<dt>`inline-grid@v</dt>
	<dd>
この値は、
要素に`格子~容器$~boxを生成させる
— `~flow~layout$内に配置されたときには、
`行内~level$になるような。
◎
This value causes an element to generate a grid container box that is inline-level when placed in flow layout.
</dd>
</dl>

<p>
`格子~容器@
のうち，`下位格子$でないものは、
`格子~整形~文脈@
を，その内容~用の`独立な整形~文脈$として確立する。
これは、［
その内容の~layoutに，塊~layoutではなく `格子~layout$を利用する
］ことを除き，
独立な`塊~整形~文脈$を確立したとするときと同じにふるまう【！するのと同じになる】：
◎
A grid container that is not a subgrid establishes an independent grid formatting context for its contents. This is the same as establishing an independent block formatting context, except that grid layout is used instead of block layout:＼
</p>
<ul>
	<li>
`浮動体$は格子~容器の中へは侵入しない。
◎
floats do not intrude into the grid container,＼
</li>
	<li>
格子~容器の~marginと その内容の~marginは、
`相殺-$されない。
◎
and the grid container’s margins do not collapse with the margins of its contents.＼
</li>
	<li>
`格子~容器$の内容は、
各 `駒$の`包含塊$の境界線を形成している`罫$により，
`格子$の中へ~lay-outされる。
◎
The contents of a grid container are laid out into a grid, with grid lines forming the boundaries of each grid items’ containing block.
</li>
</ul>

<p>
`下位格子$の内容は、
入子にされただけの格子と違って，
親の`格子~整形~文脈$に関与する
— したがって、
`下位格子$は`独立な整形~文脈$は確立しない。
◎
Unlike those of a regular nested grid, a subgrid’s contents participate in its parent grid formatting context; thus a subgrid does not establish an independent formatting context.
</p>

<p>
`格子~容器$は`塊~容器$ではないので、
塊~layoutを前提に設計されている~propには，
格子~layoutの文脈~下では適用されないものもある。
特に：
◎
Grid containers are not block containers, and so some properties that were designed with the assumption of block layout don’t apply in the context of grid layout. In particular:
</p>
<ul>
	<li>
［
`float$p ／ `clear$p
］には、
`格子~駒$に対する効果は無い。
それでも、
`float$p ~propは，`格子~容器$の子の `display$p の算出d値には影響する
— それが算出されるのは、
`格子~駒$が決定される`より前^emなので。
◎
float and clear have no effect on a grid item. However, the float property still affects the computed value of display on children of a grid container, as this occurs before grid items are determined.
</li>
	<li>
`vertical-align$p には、
格子~駒に対する効果は無い。
◎
vertical-align has no effect on a grid item.
</li>
	<li>
［
`first-line$pe ／ `first-letter$pe
］疑似要素は、
`格子~容器$には適用されない
— `格子~容器$は、
その先祖に［
`整形される最初の行l$／`先頭字$
］を供与しない。
◎
the ::first-line and ::first-letter pseudo-elements do not apply to grid containers, and grid containers do not contribute a first formatted line or first letter to their ancestors.
</li>
</ul>

<p>
［
浮動された／`絶対的に位置され$た
］要素の `display$p は、
その指定d値が `inline-grid$v の場合，その算出d値は `grid$v になる
【すなわち，`塊~化$される】
。
したがって，
`CSS2$r `§ 9.7＠~CSS2J#dis-pos-flo$
の表は、
次の行を追加するよう改正される
⇒＃
“指定d値” 列の欄は `inline-grid$v,
“算出d値” 列の欄は `grid$v
◎
If an element’s specified display is inline-grid and the element is floated or absolutely positioned, the computed value of display is grid. The table in CSS 2.1 Chapter 9.7 is thus amended to contain an additional row, with inline-grid in the "Specified Value" column and grid in the "Computed Value" column.
</p>

		</section>
		<section id="intrinsic-sizes">
<h3 title="Sizing Grid Containers">5.2. 格子~容器の~sizing</h3>

<p>
この節の用語【最小-／最大-〜】の定義については， `CSS-SIZING-3$r を見よ。
◎
Note see [CSS-SIZING-3] for a definition of the terms in this section.
</p>

<p>
`格子~容器$は、
それが関与する整形~文脈の規則を利用して~sizeされる：
◎
A grid container is sized using the rules of the formatting context in which it participates:
</p>

<ul>
	<li>
`塊~整形~文脈$における`塊~level$の~boxとしては、
`塊~box$が整形~文脈を確立するときと同様に~sizeされる
— その際の `~autoS$v
【！auto】【！auto 値のリンク先は更新される回ごとに変化 — 以下同様】
による`行内~size$は、
`置換され$ない塊~boxに対するときと同様に計算される。
◎
As a block-level box in a block formatting context, it is sized like a block box that establishes a formatting context, with an auto inline size calculated as for non-replaced block boxes.
</li>
	<li>
`行内~整形~文脈$における`行内~level$の~boxとしては、
`不可分な行内~level$の~box（行内-塊など）と同様に~sizeされる。
◎
As an inline-level box in an inline formatting context, it is sized as an atomic inline-level box (such as an inline-block).
</li>
</ul>

<p>
行内／塊いずれの整形~文脈においても、
`格子~容器$に対する `~autoS$v【！＊】 による`塊~size$は，
その`最大-内容~size$になる。
◎
In both inline and block formatting contexts, the grid container’s auto block size is its max-content size.
</p>

<p class="note">注記：
塊~layout仕様【！＊】が，おそらく これを定義するべきだが、
まだ書かれていない。
◎
The block layout spec should probably define this, but it isn’t written yet.
</p>

<p>
格子が［
`最大-内容~拘束$／
`最小-内容~拘束$
］の下で~sizeされるときの，`格子~容器$の［
`最大-内容~size$ ／
`最小-内容~size$
］は、
`格子~容器$の適切な軸の方の一連の筋~size（`側溝$も含む）の総和になる。
◎
The max-content size (min-content size) of a grid container is the sum of the grid container’s track sizes (including gutters) in the appropriate axis, when the grid is sized under a max-content constraint (min-content constraint).
</p>

		</section>
		<section id="overflow">
<h3 title="Scrollable Grid Overflow">5.3. ~scroll可能な格子~overflow</h3>

<p>
`overflow$p ~propは、
`格子~容器$にも適用される。
◎
The overflow property applies to grid containers.
</p>

<p>
`格子$は
— 内在的~sizingに含まれるのと同じく
（ `§ 格子~容器の~sizing＠#intrinsic-sizes$を見よ） —
`格子~容器$の`~scroll可能な~overflow区画$にも含まれる。
◎
Just as it is included in intrinsic sizing (see § 5.2 Sizing Grid Containers), the grid is also included in a grid container’s scrollable overflow region.
</p>

<p class="note">注記：
`格子~容器$が`~scroll容器$であるときは、
~paddingとの相互作用にも~~留意すること：
追加的な~paddingは、
~scroll可能な内容の `place-content$p 整列を可能化する必要に応じて，
`~scroll可能な~overflow矩形$に追加されるものと定義される。
`CSS-OVERFLOW-3$r
`§ ~scroll可能な~overflow＠~CSSOVERFLOW3#scrollable$を見よ。
◎
Note: Beware the interaction with padding when the grid container is a scroll container: additional padding is defined to be added to the scrollable overflow rectangle as needed to enable place-content: end alignment of scrollable content. See CSS Overflow 3 § 2.2 Scrollable Overflow
</p>

		</section>
		<section id="overlarge-grids">
<h3 title="Limiting Large Grids">5.4. 巨大な格子の制限-法</h3>

<p>
~memoryには限りがあるので、
~UAは、
`暗黙的な格子$にアリな~size【~span数】を自身が定義する上限
（範囲 { −10000 〜 10000 } に入る筋は収容するベキである）
に切詰めて，
その上限を超える罫をすべて落としてもヨイ。
`格子~駒$が，この上限を超えて配置される場合、
その区画を，その上限付き格子の中に切詰めるモノトスル
— 次に述べるように。
◎
Since memory is limited, UAs may clamp the possible size of the implicit grid to be within a UA-defined limit (which should accommodate lines in the range [-10000, 10000]), dropping all lines outside that limit. If a grid item is placed outside this limit, its grid area must be clamped to within this limited grid.
</p>

<p>
`格子~区画を切詰める@
ときは：
◎
To clamp a grid area:
</p>

<ul>
	<li>
当の`区画$が上限付き`格子$の内側にも外側にも~spanする場合
⇒
駒の`~span数$を［
上限付き格子の最後の罫
］までに切詰める。
◎
If the grid area would span outside the limited grid, its span is clamped to the last line of the limited grid.
</li>
	<li>
当の`区画$が上限付き格子の完全に外側に配置される場合
⇒
駒の`~span数$を 1 にした上で，区画を［
格子の その側の最後の`筋$
］に位置し直す。
◎
If the grid area would be placed completely outside the limited grid, its span must be truncated to 1 and the area repositioned into the last grid track on that side of the grid.
</li>
</ul>

<div class="example">
<p>
例えば、
~UAが各~次元に対し最大 1000 本までの筋を~supportする場合、
配置~propを次のようにしたときの結果は：
◎
For example, if a UA only supported grids with at most 1000 tracks in each dimension, the following placement properties:
</p>

<pre class="lang-css">
.grid-item {
  grid-row: 500 / 1500;
  grid-column: 2000 / 3000;
}
</pre>

<p>
次と等価になる：
◎
Would end up being equivalent to:
</p>

<pre class="lang-css">
.grid-item {
  grid-row: 500 / 1001;
  grid-column: 1000 / 1001;
}
</pre>
</div>

		</section>
	</section>
	<section id="grid-items">
<h2 title="Grid Items">6. 格子~駒</h2>

<p>
`格子~容器$の
`格子~駒@
とは、
大雑把に言えば，その`~flow内$にある内容を表現する~boxである。
◎
Loosely speaking, the grid items of a grid container are boxes representing its in-flow contents.
</p>

<p>
`格子~容器$の`~flow内$にある各~子のうち、
要素は`格子~駒$になり，
`~text連列$は`匿名$な`塊~容器$である`格子~駒$で包装される。
ただし，そのような`~text連列$が`文書~空白$【！`空白＠~CSS22/text.html#white-space-prop$】
（すなわち， `white-space$p ~propに影響され得る文字）
のみからなる場合、
描画されない
（対応する`~text~node$の `display$p は `none^v にされていたかのように†）。
◎
Each in-flow child of a grid container becomes a grid item, and each child text sequence is wrapped in an anonymous block container grid item. However, if the text sequence contains only white space (i.e. characters that can be affected by the white-space property) it is instead not rendered (just as if its text nodes were display:none).
</p>

<p class="trans-note">【†
すなわち，~boxを生成しないので、
格子~駒にはならず，`自動-配置~algo$においても 1 個の駒として数えられなくなる。
】</p>

<div class="example">
<p>
格子~駒の例：
◎
Examples of grid items:
</p>

<pre class="lang-html">
&lt;div style="display: grid"&gt;

  &lt;!-- <span class="comment">
格子~駒：子~塊
◎
grid item: block child
</span> --&gt;
  &lt;div id="item1"&gt;block&lt;/div&gt;

  &lt;!-- <span class="comment">
格子~駒：浮動された要素 — その浮動は無視される
◎
grid item: floated element; floating is ignored
</span> --&gt;
  &lt;div id="item2" style="float: left;"&gt;float&lt;/div&gt;

  &lt;!-- <span class="comment">
格子~駒：行内~内容を囲う匿名な塊~box
◎
grid item: anonymous block box around inline content
</span> --&gt;
  anonymous item 3

  &lt;!-- <span class="comment">
格子~駒：行内の子
◎
grid item: inline child
</span> --&gt;
  &lt;span&gt;
    item 4
    &lt;!-- <span class="comment">
格子~駒が塊の周囲で`分割される＠~CSS2J#anonymous-block-level$ことはない
◎
grid items do not split around blocks
</span> --&gt;
    &lt;q style="display: block" id=not-an-item&gt;item 4&lt;/q&gt;
    item 4
  &lt;/span&gt;
&lt;/div&gt;
</pre>

<figure><figcaption>
上の~codeから決定される格子~駒
（`実演＠~CSSWG/css-grid/examples/grid-item-determination.html$）
◎
grid items determined from above code block
</figcaption>

`grid-item-determination^dgm
<ol hidden id="_alt-grid-item-determination">
	<li>
<samp>block</samp> を包含している格子~駒
◎
grid item containing block.
</li>
	<li>
<samp>float</samp> を包含している格子~駒
◎
grid item containing float.
</li>
	<li>
<samp>anonymous item 3</samp> を包含している（匿名かつ~style不能な）格子~駒
◎
(Anonymous, unstyleable) grid item containing anonymous item 3.
</li>
	<li>
<p>
~~連続する 3 個の塊を包含している格子~駒：
◎
grid item containing three blocks in succession:
</p>
		<ul>
			<li>
<samp>item 4</samp> を包含している匿名~塊
◎
Anonymous block containing item 4.
</li>
			<li>
<samp>item 4</samp> を包含している`q^e 要素~塊
◎
&lt;q&gt; element block containing item 4.
</li>
			<li>
<samp>item 4</samp> を包含している匿名~塊
◎
Anonymous block containing item 4.
</li>
		</ul>
	</li>
</ol>
</figure>
</div>

<p class="note">注記：
要素~間の空白は消え去り，格子~駒にはならないことに注意
— 要素~間の【非~空白を含んだ】~textは、
匿名な格子~駒で`包装される^emことになるが。
◎
Note: inter-element white space disappears: it does not become its own grid item, even though inter-element text does get wrapped in an anonymous grid item.
</p>

<p class="note">注記：
匿名な駒は、
~style規則をアテガう要素が無いので，~style不能なことに注意。
しかしながら，その内容は、
格子~容器から~style（~font設定群など）を継承する。
◎
Note: The box of a anonymous item is unstyleable, since there is no element to assign style rules to. Its contents will however inherit styles (such as font settings) from the grid container.
</p>

		<section id="grid-item-display">
<h3 title="Grid Item Display">6.1. 格子~駒の `display^p</h3>

<p>
`格子~駒$は、
`下位格子$でない限り，その内容~用に`独立な整形~文脈を確立する$。
しかしながら，格子~駒は
`格子~level@
の~boxであって, `塊~level$の~boxではないので、
駒が関与するのは，その容器の`格子~整形~文脈$になる
— `塊~整形~文脈$ではなく。
◎
Unless it is a subgrid, a grid item establishes an independent formatting context for its contents. However, grid items are grid-level boxes, not block-level boxes: they participate in their container’s grid formatting context, not in a block formatting context.
</p>

<p>
所与の要素に対し，［
その先祖であって `display$p の`算出d値$が `contents^v 以外になるもののうち，要素に最も近いもの
］の `display$p の`算出d値$が［
`grid$v ／ `inline-grid$v
］である場合、
要素の自前の `display$p 値は，`塊~化$される。
（この種の `display$p 値の変換の詳細は、
`CSS2$r `§ 9.7＠~CSS2J#dis-pos-flo$,
`CSS-DISPLAY-3$r `§ ~box型の自動的な変形n＠~CSSDISP#transformations$
を見よ。）
◎
If the computed display value of an element’s nearest ancestor element (skipping display:contents ancestors) is grid or inline-grid, the element’s own display value is blockified. (See CSS2.1 § 9.7 [CSS2] and CSS Display 3 § 2.7 Automatic Box Type Transformations for details on this type of display value conversion.)
</p>

<p class="note">注記：
この塊~化は、
当の［
`grid^v ／ `inline-grid^v
］にされた先祖が`格子~容器$を生成しない場合でも，依然として生じる
— 例： それが［
`置換され$る ／ `display$p が `none^v にされた下位tree内にある
］場合でも。
◎
Note: Blockification still occurs even when the grid or inline-grid element does not end up generating a grid container box, e.g. when it is replaced or in a display: none subtree.
</p>

<p class="note">注記：
`display$p の値には、
通常は，元の~boxの周りに`匿名~box$の作成を誘発するものもある。
そのような~boxが格子~駒である場合、
それは先ず`塊~化$されるので，匿名~boxは作成されなくなる。
例えば， 2 個の連続する駒が
<code class="css">`display^p: `table-cell$v</code>
を伴っていた場合、
1 個の匿名な~table中へ包装される代わりに，
2 個の別々な
<code class="css">`display^p: `block$v</code>
にされた駒になる。
◎
Note: Some values of display normally trigger the creation of anonymous boxes around the original box. If such a box is a grid item, it is blockified first, and so anonymous box creation will not happen. For example, two contiguous grid items with display: table-cell will become two separate display: block grid items, instead of being wrapped into a single anonymous table.
</p>

		</section>
		<section id="grid-item-sizing">
<h3 title="Grid Item Sizing">6.2. 格子~駒の~sizing</h3>

<p>
`格子~駒$は、
その`区画$により定義される`包含塊$の中で~sizeされる。
◎
A grid item is sized within the containing block defined by its grid area.
</p>

<p>
`格子~駒$ %駒 の所与の次元における`自動的~size$の計算は、
`自己-整列~値＠~CSSALIGN#self-alignment$に応じて変わる：
◎
Grid item calculations for automatic sizes in a given dimensions vary by their self-alignment values:
</p>

<dl class="switch">
	<dt>`normal$v</dt>
	<dd>
%駒 が次を満たす場合、
<code class="css">`align-self$p: `stretch$v</code>
のときと同じに~sizeされる
⇒
`選好d縦横比$は無い, かつ
（ %駒 は`置換され$る要素である場合は）関連な軸において`生来な~size$は無い
◎
If the grid item has no preferred aspect ratio, and no natural size in the relevant axis (if it is a replaced element), the grid item is sized as for align-self: stretch.
</dd>
	<dd>
他の場合，対応する軸における`塊~level$の要素~用の~size計算~規則と整合するように~sizeされる
（ `CSS2$r `§ 視覚-整形~modelの詳細＠~CSS2J#visudet$を見よ）。
◎
Otherwise, the grid item is sized consistent with the size calculation rules for block-level elements for the corresponding axis. (See CSS 2.1 § 10 Visual formatting model details.)
</dd>

	<dt>`stretch$v</dt>
	<dd>
`置換され$ない要素~用の`行内~size$の計算~規則を利用する
（ `CSS2$r `§ 通常~flow内にある塊~levelの置換されない要素＠~CSS2J#blockwidth$にて定義される）
— すなわち，`伸張して収まる~size$。
◎
Use the inline size calculation rules for non-replaced boxes (defined in CSS 2.1 § 10.3.3 Block-level, non-replaced elements in normal flow), i.e. the stretch-fit size.
</dd>
	<dd class="note">注記：
これは、
`選好d縦横比$を有する %駒 の縦横比を歪めることもある
— その~sizeも他方の軸により拘束される場合には。
◎
Note: This can distort the aspect ratio of an item with a preferred aspect ratio, if its size is also constrained in the other axis.
</dd>

	<dt>
他のすべての値
◎
all other values
</dt>
	<dd>
`fit-content$v のときと同じに~sizeする。
◎
Size the item as fit-content.
</dd>
</dl>

<div class="note">
<p>注記：
次の規範的でない表tに，格子~駒の自動的~sizingを要約する：
◎
The following informative table summarizes the automatic sizing of grid items:
◎
Summary of automatic sizing behavior of grid items
</p>

<div>
<table><thead>
<tr><th>整列
<th>`置換され$ない要素の~size
<th>`置換され$る要素の~size
<tbody>

<tr><th scope="row">`normal$v
<td>区画を埋める
<td>`生来な~size$を利用する

<tr><th scope="row">`stretch$v
<td>区画を埋める
<td>区画を埋める

<tr><th scope="row">`start$v／ `center$v／等々
<td>`fit-content$v ~sizing（`浮動体$の様な）
<td>`生来な~size$を利用する
</table>
◎
• Alignment ｜ Non-replaced Element Size ｜ Replaced Element Size
• normal ｜ Fill grid area ｜ Use natural size
• stretch ｜ Fill grid area ｜ Fill grid area
• start/center/etc. ｜ fit-content sizing (like floats) ｜ Use natural size
</div>
</div>

<p class="note">注記：
`格子~駒$の［
`min-width$p ／ `min-height$p
］に対する値 `~autoS$v は、
`~flex駒$の`主-軸$~sizeに影響するときと類似に，関連な軸における筋~sizingに影響する。
`§ 格子~駒の自動的な最小~size$を見よ。
◎
Note: The auto value of min-width and min-height affects track sizing in the relevant axis similar to how it affects the main size of a flex item. See § 6.6 Automatic Minimum Size of Grid Items.
</p>

		</section>
		<section id="order-property">
<h3 title="Reordered Grid Items: the order property">6.3. 格子~駒の並替ng： `order^p ~prop</h3>

<p>
`order$p ~propは，`格子~駒$にも適用され、
それらの`自動-配置$や`塗ng順序$に影響する。
◎
The order property also applies to grid items. It affects their auto-placement and painting order.
</p>

<p class="advisement"><strong>
~flex駒の並替ngと同様に、
`order$p ~propは，［
視覚的な順序を 発話や~naviの順序と `違える^em 必要がある場合
］に限って利用されなければナラナイ。
必要なければ、
下層の文書~sourceが並替えられるべきである。
`CSS-DISPLAY-3$r【！`CSS-FLEXBOX-1$r 】 `§ 並替ngと~accessibility＠~CSSDISP#order-accessibility$

を見よ。
</strong>
◎
As with reordering flex items, the order property must only be used when the visual order needs to be out-of-sync with the speech and navigation order; otherwise the underlying document source should be reordered instead. See CSS Flexbox 1 § 5.4.1 Reordering and Accessibility in [CSS-FLEXBOX-1].
</p>

		</section>
		<section id="item-margins">
<h3 title="Grid Item Margins and Paddings">6.4. 格子~駒の~marginと~padding</h3>

<p>
隣接する 2 個の`格子~駒$は、
それぞれ独立に各自の`区画$が形成する`包含塊$の中に包含されるので，
それらの~marginが`相殺-$されることはない。
◎
As adjacent grid items are independently contained within the containing block formed by their grid areas, the margins of adjacent grid items do not collapse.
</p>

<p>
`格子~駒$ %駒 上の百分率による［
~margin／~padding
］は、
%駒 の`包含塊$の`行内~size$を~~基準に解決される
— `塊~box$のときと同様に。
例えば，横書き`書字~mode$の下では、［
左端, 右端, 上端, 下端
］のいずれも，百分率は包含塊の横幅を~~基準に解決される。
◎
Percentage margins and paddings on grid items, like those on block boxes, are resolved against the inline size of their containing block, e.g. left/right/top/bottom percentages all resolve against their containing block’s width in horizontal writing modes.
</p>

<p>
格子~駒に対する自動~marginは、
対応する次元の余った空間を吸収するように拡幅される。
これを利用すれば、
駒たちを互いを整列させられる。
<a href="#auto-margins">§ `auto^v ~marginによる整列-法</a>を見よ。
◎
Auto margins expand to absorb extra space in the corresponding dimension, and can therefore be used for alignment. See § 11.2 Aligning with auto margins
</p>

		</section>
		<section id="z-order">
<h3 title="Z-axis Ordering: the z-index property">6.5. Z 軸~~方向の順序付け： `z-index^p ~prop</h3>

<p>
2 つの`格子~駒$は、
重合することもある
— 互いに交差する（すなわち，ある`升$を共有する）`区画$に位置されるとき，
あるいは交差しない区画に位置されるときでも, 負な~marginや負な位置決めにより。
`格子~駒$の塗ng順序は、［
そのままの文書~順序の代わりに `order$p により`改変された文書~順序$が利用される
］ことを除いて，行内~塊 `CSS2$r のそれと正確に同じになり、
`auto^v 以外の `z-index$p 値は，
`position$p が `static^v であっても積層~文脈を作成する
（ `position$p が `relative^v であったときと正確に同じに挙動する）。
したがって、
格子~駒の z-軸 順序は `z-index$p ~propで容易に制御できる
◎
Grid items can overlap when they are positioned into intersecting grid areas, or even when positioned in non-intersecting areas because of negative margins or positioning. The painting order of grid items is exactly the same as inline blocks [CSS2], except that order-modified document order is used in place of raw document order, and z-index values other than auto create a stacking context even if position is static (behaving exactly as if position were relative). Thus the z-index property can easily be used to control the z-axis order of grid items.
</p>

<p class="note">注記：
格子~駒の外側に位置される子孫も，依然として 格子~駒により確立される積層~文脈に関与する。
◎
Note: Descendants that are positioned outside a grid item still participate in any stacking context established by the grid item.
</p>

<div class="example">
<p>
次の図式に、［
暗黙的~source順序と,
それらの積層~順序の制御に利用される明示的 `z-index$p
］の組合nにより，いくつかの格子~駒が重合する様子を示す：
◎
The following diagram shows several overlapping grid items, with a combination of implicit source order and explicit z-index used to control their stacking order.
</p>

<figure>
<figcaption id="_dgm-drawing-order">
`z-index^p と~source順序により制御される描き順序
◎
Drawing order controlled by z-index and source order.
</figcaption></figure>

<pre class="lang-css">
#grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr
}
#A { grid-column: 1 / span 2; grid-row: 2;
     align-self: end; }
#B { grid-column: 1; grid-row: 1;
     z-index: 10 }
#C { grid-column: 2; grid-row: 1;
     align-self: start; margin-left: -20px }
#D { grid-column: 2; grid-row: 2;
     justify-self: end; align-self: start; }
#E { grid-column: 1 / span 2; grid-row: 1 / span 2;
     z-index: 5; justify-self: center; align-self: center; }
</pre>

<pre class="lang-html">
&lt;div id="grid"&gt;
  &lt;div id="A"&gt;A&lt;/div&gt;
  &lt;div id="B"&gt;B&lt;/div&gt;
  &lt;div id="C"&gt;C&lt;/div&gt;
  &lt;div id="D"&gt;D&lt;/div&gt;
  &lt;div id="E"&gt;E&lt;/div&gt;
&lt;/div&gt;
</pre>
</div>

		</section>
		<section id="min-size-auto">
<h3 title="Automatic Minimum Size of Grid Items">6.6. 格子~駒の自動的な最小~size</h3>

<p class="note">注記：
この節（および以降の節）では、
`CSS-SIZING-3$r にて定義される~sizingの各種用語が多用される。
◎
Note: Much of the sizing terminology used in this section (and throughout the rest of the specification) is defined in CSS Intrinsic and Extrinsic Sizing [CSS-SIZING-3].
</p>

<p>
`格子~駒$ %駒 用に，より適度な既定の`最小~size$を供するため、
所与の軸における %駒 の`自動的な最小~size$の使用~値は，［
~AND↓ が満たされるならば %駒 の`内容に基づく最小~size$ ／
~ELSE_ 通例通り 0
］になるとする：
◎
To provide a more reasonable default minimum size for grid items, the used value of its automatic minimum size in a given axis is the content-based minimum size if all of the following are true:
</p>
<ul>
	<li>
%駒 は`~scroll容器$でない
◎
it is not a scroll container
</li>
	<li>
%駒 が その軸~沿いに~spanする ある`筋$の`~min筋~sizing関数$は `auto$vt である
◎
it spans at least one track in that axis whose min track sizing function is auto
</li>
	<li>
%駒 がその軸~沿いに~spanする`筋$は 1 本だけか，どれも`~flex可能$でない
◎
if it spans more than one track in that axis, none of those tracks are flexible
◎
↑Otherwise, the automatic minimum size is zero, as usual.
</li>
</ul>

<p class="note">注記：
`内容に基づく最小~size$は、
`内在的~size供与$の一種なので，
`CSS-SIZING-3$r `§ 内在的~供与＠~SIZING#intrinsic-contribution$
における~~条項が適用される。
◎
Note: The content-based minimum size is a type of intrinsic size contribution, and thus the provisions in CSS Sizing 3 § 5.2 Intrinsic Contributions apply.
</p>

<div class="algo">
<p>
`格子~駒$ %駒 の
`内容に基づく最小~size@
は、
次で与えられる
⇒
`min^op( %~size示唆【！the size suggestion】, %~size~~上限 )
◎
The content-based minimum size for a grid item in a given dimension is＼
</p>

<p>
ここで：
◎
↓</p>
<ul>
	<li>
上, および以下に利用される［
`min^op(…) ／ `max^op(…)
］は、
各~引数の［
最小／最大
］値をとる関数であり，
引数のうち ε を値にとるものは無視するとする
— どの引数も ε をとる場合、
結果も ε になるとする
（ ε は、
値が［
定義されない／`確定的$でない
］ことを表す定数である）。
◎
↓</li>
	<li>
<p>
%~size示唆【！the size suggestion】 は
⇒＃
%駒 の`指定d~size示唆$ ~NEQ ε ならば それ／
~ELSE_ %駒 は`置換され$る, かつ %駒 の`転換~size示唆$ ~NEQ ε ならば それ／
~ELSE_ %駒 の`内容~size示唆$
</p>

<p>
ただし，所与の次元において
%駒 が次の (A) を満たす場合、
その次元における %駒 の［
`指定d~size示唆$, `内容~size示唆$
］は
（他方の次元における`転換~size示唆$への，この次元からの入力も含む），
次の (B) 以下に切詰める：
</p>
		<ul>
			<li>(A)
%駒 が~spanする どの`筋$の`~max筋~sizing関数$も，`固定的~sizing関数$である
</li>
			<li>(B)
%駒 を次に与える~sizeに`収まるよう伸張-$した~size
⇒
次の総和として表現される，その次元における %駒 の`区画$の最大~size
⇒
%駒 が~spanする各~筋の`~max筋~sizing関数$,
それらの筋に挟まれる固定d~sizeの`側溝$
</li>
		</ul>

◎
its specified size suggestion if it exists, otherwise its transferred size suggestion if that exists and the element is replaced, else its content size suggestion, see below.＼
However, if in a given dimension the grid item spans only grid tracks that have a fixed max track sizing function, then its specified size suggestion and content size suggestion in that dimension (and its input from this dimension to the transferred size suggestion in the opposite dimension) are further clamped to less than or equal to the stretch fit into the grid area’s maximum size in that dimension, as represented by the sum of those grid tracks’ max track sizing functions plus any intervening fixed gutters.
</li>
	<li>
<p>
%~size~~上限 は（ ε になり得る）：
</p>
		<ul class="switch">
			<li>
%駒 は`圧縮-可能な置換される要素＠~SIZING#min-content-zero$である場合
⇒
`min^op( %選好d~size†, %最大~size† )
</li>
			<li>
他の場合
⇒
%最大~size
</li>
		</ul>
<p>
（ %選好d~size, %最大~size は、
下を見よ。）
</p>
◎
In all cases, the size suggestion is additionally clamped by the maximum size in the affected axis, if it’s definite.＼
If the item is a compressible replaced element, and has a definite preferred size or maximum size in the relevant axis, the size suggestion is capped by those sizes; for this purpose, any indefinite percentages in these sizes are resolved against zero (and considered definite).
</li>
</ul>

<p class="note">注記：
`fit-content$f がとる引数は、
上の (A), (B) と同じ仕方で，`内容に基づく最小~size$に切詰める`ことはない^em。
◎
Note: The argument to fit-content() does not clamp the content-based minimum size in the same way as a fixed max track sizing function.
</p>

<p>
上で利用される %駒 の各種~size示唆は、
次で定義される
（これらには、［
`内容に基づく最小~size$が作者から供された拘束に干渉しない
］よう，関連な［
最小-／最大-／選好d
］~sizeも織り込まれる）：
◎
The content size suggestion, specified size suggestion, and transferred size suggestion used in this calculation account for the relevant min/max/preferred size properties so that the content-based minimum size does not interfere with any author-provided constraints, and are defined below:
</p>
<dl class="def-list">
	<dt>
`指定d~size示唆@
◎
specified size suggestion
</dt>
	<dd>
%選好d~size
◎
If the item’s preferred size in the relevant axis is definite, then the specified size suggestion is that size.＼
It is otherwise undefined.
</dd>

	<dt>
`転換~size示唆@
◎
transferred size suggestion
</dt>
	<dd>
［
%縦横比 ~NEQ ε
］~AND［
%交叉-選好d~size ~NEQ ε
］ならば，次の結果
⇒
`min^op( 次の結果, %選好d~size†, %最大~size† )
⇒
`max^op( `min^op( %交叉-選好d~size, %交叉-最大-~size ), %交叉-最小-~size ) ~MUL %縦横比
◎
If the item has a preferred aspect ratio and its preferred size in the opposite axis is definite, then the transferred size suggestion is that size (clamped by the opposite-axis minimum and maximum sizes if they are definite), converted through the aspect ratio.＼
It is otherwise undefined.
◎
If the item has a definite preferred size or maximum size in the relevant axis, the transferred size suggestion is capped by those sizes; for this purpose, any indefinite percentages in these sizes are resolved against zero (and considered definite).
</dd>
	<dd>
~ELSE_ ε
◎
↑</dd>

	<dt>
`内容~size示唆@
◎
content size suggestion
</dt>
	<dd>
%縦横比 ~NEQ ε ならば，次の結果
⇒
`max^op( `min^op( %最小~内容~size ~DIV %縦横比, %交叉-最大~size ), %交叉-最小-~size ) ~MUL %縦横比
◎
The content size suggestion is the min-content size in the relevant axis,＼
clamped, if it has a preferred aspect ratio, by any definite opposite-axis minimum and maximum sizes converted through the aspect ratio.
</dd>
	<dd>
~ELSE_ %最小~内容~size
◎
↑</dd>
</dl>

<div>
<p>
上においては：
</p>
<ul>
	<li>
%縦横比 は、
%駒 は`選好d縦横比$を有するならば［
当の軸における~size ~DIV 他方の軸における~size
］を表すそれ ／
~ELSE_ ε とする。
</li>
	<li>
<p>
各種~sizeのうち：
</p>
		<ul>
			<li>
［
%最小~内容~size ／ %選好d~size ／ %最大~size
］は、
当の軸における %駒 の［
`最小-内容~size$ ／ `選好d~size$ ／ `最大~size$
］を指す。
</li>
			<li>
［
%交叉-選好d~size ／ %交叉-最大-~size ／ %交叉-最小-~size
］は、
他方の軸における %駒 の［
`選好d~size$ ／ `最大~size$ ／ `最小~size$
］を指す。
</li>
		</ul>
<p>
これらの~sizeは、
`確定的$でない場合は ε になるとする。
【 %最小~内容~size は、常に確定的と思われる。】
ただし， † が付与されたものにおいては、
不定な百分率は， 0 を~~基準に解決する（`確定的$と見なす）とする。
</p>
	</li>
</ul>
◎
↑</div>
</div>

<p>
`内容に基づく最小~size$は：
◎
↓</p>
<ul>
	<li>
~boxの`内在的~size$
（例： 要素の`最小-内容~size$）
を計算する目的においては、
当の軸における~boxの~sizeを不定にする
（例えば、
~boxの `width$p ~propが`確定的$な~sizeを指定していても）。
したがって、
この~sizeを~~基準に計算される百分率は，
`~autoとして挙動する$ようになることに注意。
◎
For the purpose of calculating an intrinsic size of the box (e.g. the box’s min-content size), a content-based minimum size causes the box’s size in that axis to become indefinite (even if e.g. its width property specifies a definite size). Note this means that percentages calculated against this size will behave as auto.
</li>
	<li>
内在的~sizeを計算する`以外^emの目的においては、
~boxの~sizeが不定になるよう強制しない
（明示的な `min-content$v【！`min-content$vt】, 等々や`最小~size$と違って）。
しかしながら、
ある百分率が，この最小が適用される`より前^emに~boxの~sizeを~~基準に解決される場合、
それを適用した後の新たな~sizeを~~基準に，それ【内在的~size以外の何か？】を解決し直すモノトスル。
◎
For any purpose other than calculating intrinsic sizes, a content-based minimum size (unlike an explicit min-content/etc minimum size) does not force the box’s size to become indefinite. However, if a percentage resolved against the box’s size before this minimum was applied, it must be re-resolved against the new size after it is applied.
</li>
</ul>

<div class="note" id="min-size-opt">
<p>注記：
`内容に基づく最小~size$は、
多くの場合 適切であり，内容が［
重合しない／その容器の外側にあふれない
］ようにするが、
一部の事例ではそうならない：
◎
Note that while a content-based minimum size is often appropriate, and helps prevent content from overlapping or spilling outside its container, in some cases it is not:
</p>

<p>
特に，格子~layoutが文書の主要な内容~領域に利用される場合、
~font~sizeに相対的な最小~横幅（ `min-width$p: `12em^v など）を明示的に設定した方がよい。
最小~横幅が内容に基づく場合、
巨大な［
~tableや画像
］が在るときに，
内容~領域~全体の~sizeを~overflowする地帯にまで伸張させ、
その結果，~text行lが無用に長く読みづらいものになり得る。
◎
In particular, if grid layout is being used for a major content area of a document, it is better to set an explicit font-relative minimum width such as min-width: 12em. A content-based minimum width could result in a large table or large image stretching the size of the entire content area, potentially into an overflow zone, and thereby making lines of text needlessly long and hard to read.
</p>

<p>
内容に基づく~sizingが，多量の内容を伴う駒に利用された場合、
~layout~engineは，
その最小~sizeを見出す前に その内容すべてを辿らなければならなくなる。
作者が明示的な最小~sizeを設定しておけば、
これは必要yでない。
（駒の内容が少量ならば、
この辿りは些細であり，処理能の懸念にはならない）
◎
Note also, when content-based sizing is used on an item with large amounts of content, the layout engine must traverse all of this content before finding its minimum size, whereas if the author sets an explicit minimum, this is not necessary. (For items with small amounts of content, however, this traversal is trivial and therefore not a performance concern.)
</p>
</div>

		</section>
	</section>
	<section id="grid-definition">
<h2 title="Defining the Grid">7. 格子の定義-法</h2>

		<section id="explicit-grids">
<h3 title="The Explicit Grid">7.1. 明示的な格子</h3>

<p>
［
`grid-template-rows$p,
`grid-template-columns$p,
`grid-template-areas$p
］~propは、
~~共同で`格子~容器$の
`明示的な筋@
を指定することにより，
`明示的な格子@
を定義する。
最終的な格子は、［
`格子~駒$が`明示的な格子$の外側に配置されたときに，暗黙的に筋が追加される
］ため，より大きくなり得る。
この場合、
暗黙的な筋が作成され，それらの~sizeは［
`grid-auto-rows$p, `grid-auto-columns$p
］~propにより指定される。
◎
The three properties grid-template-rows, grid-template-columns, and grid-template-areas together define the explicit grid of a grid container by specifying its explicit grid tracks. The final grid may end up larger due to grid items placed outside the explicit grid; in this case implicit tracks will be created, these implicit tracks will be sized by the grid-auto-rows and grid-auto-columns properties.
</p>

<p>
`明示的な格子$を成す筋rcの総本数【！size＊】は、［
`grid-template-areas$p により定義される筋rcの本数
］と［
`grid-template-rows$p ／ `grid-template-columns$p
により~sizeされる筋rcの本数
］の大きい方として決定される。
［
`grid-template-areas$p により定義された筋rcのうち，［
`grid-template-rows$p ／ `grid-template-columns$p
］~propから~sizeされないもの
］の~sizeは、［
`grid-auto-rows$p ／ `grid-auto-columns$p
］~propからとられる。
これらの~propが`明示的な格子$を成す筋を`まったく^em定義しない場合でも、
`明示的な格子$は，各~軸に 1 本の`罫$を包含する。
◎
The size of the explicit grid is determined by the larger of the number of rows/columns defined by grid-template-areas and the number of rows/columns sized by grid-template-rows/grid-template-columns. Any rows/columns defined by grid-template-areas but not sized by grid-template-rows/grid-template-columns take their size from the grid-auto-rows/grid-auto-columns properties. If these properties don’t define any explicit tracks the explicit grid still contains one grid line in each axis. 
</p>

<p>
`格子~配置~prop$における［
正な／負な
］数量的~indexは、
`明示的な格子$の［
`始端$／`終端$
］側から, かつ［
1 ／ −1
］から，罫を数える。
◎
Numeric indexes in the grid-placement properties count from the edges of the explicit grid. Positive indexes count from the start side (starting from 1 for the start-most explicit line), while negative indexes count from the end side (starting from -1 for the end-most explicit line).
</p>

<p>
［
`grid$p ／
`grid-template$p
］~propは、
3 つの
`明示的な格子~prop@
— `grid-template-rows$p, `grid-template-columns$p, `grid-template-areas$p —
すべてを，一括して設定するために利用できる`略式~prop$である。
`grid$p 略式~propは，`暗黙的な格子$を制御する~propも設定し直す一方で、
`grid-template$p ~propは，それらを変更しない。
◎
The grid and grid-template properties are shorthands that can be used to set all three explicit grid properties (grid-template-rows, grid-template-columns, and grid-template-areas) at the same time. The grid shorthand also resets properties controlling the implicit grid, whereas the grid-template property leaves them unchanged.
</p>

		</section>
		<section id="track-sizing">
<h3 title="Explicit Track Sizing: the grid-template-rows and grid-template-columns properties">7.2. 明示的な筋の~sizing： `grid-template-rows^p, `grid-template-columns^p ~prop</h3>

◎名 `grid-template-columns@p, `grid-template-rows@p
◎値 `none$vt | `track-list$t | `auto-track-list$t | `subgrid$vt `line-name-list$t?
◎初 `none$vt
◎適 `格子~容器$
◎継 されない
◎百
`内容~区画$の対応する次元に相対的
◎
refer to corresponding dimension of the content area
◎算 
~keyword `none$vt ／ `算出d筋~list$
◎
the keyword none or a computed track list
◎順 文法に従う
◎ア 
~list長さが合致する場合は、
各~itemを`算出d筋~list$とする，算出された値~型による
（
`§ 筋~listの算出d値＠#computed-tracks$, 
<a href="#repeat-interpolation">§ `repeat^f の補間／結合n</a>
を見よ）。
他の場合は離散的。
◎
if the list lengths match, by computed value type per item in the computed track list (see § 7.2.5 Computed Value of a Track Listing and § 7.2.3.3 Interpolation/Combination of repeat()); discrete otherwise 
◎表終

<p>
［
`grid-template-columns$p ／ `grid-template-rows$p
］~propは、
~spaceで分離された
`筋~list@
として，`格子$を成す一連の［
~col／~row
］用に［
`罫~名$, `筋~sizing関数$
］を指定する。
◎
These properties specify, as a space-separated track list, the line names and track sizing functions of the grid. The grid-template-columns property specifies the track list for the grid’s columns, while grid-template-rows specifies the track list for the grid’s rows.
</p>

<p>
各種 値の意味は：
◎
Values have the following meanings:
</p>

<dl class="valdef">
	<dt>`none@vt</dt>
	<dd>
この~propからは，`明示的な格子$を成す筋は作成されないことを指示する
（それでも，明示的な格子~筋は `grid-template-areas$p ~propにより作成され得る）。
◎
Indicates that no explicit grid tracks are created by this property (though explicit grid tracks could still be created by grid-template-areas).
</dd>
	<dd class="note">注記：
`明示的な格子$が無い下では、
どの［
~row／~col
］も
`暗黙的に生成-＠#implicit-grids$され，それらの~sizeは［
`grid-auto-rows$p ／ `grid-auto-columns$p
］~propから決定されることになる。
◎
Note: In the absence of an explicit grid any rows/columns will be implicitly generated, and their size will be determined by the grid-auto-rows and grid-auto-columns properties.
</dd>

	<dt id="track-listing">`track-list$t | `auto-track-list$t</dt>
	<dd>
<p>
`筋~list$を，一連の［
`筋~sizing関数$, `罫~名$
］として指定する。
各
`筋~sizing関数@
は：
◎
Specifies the track list as a series of track sizing functions and line names. Each track sizing function＼
</p>
		<ul>
			<li>
<p>
次に挙げるいずれかとして指定できる：
</p>
				<ul>
					<li>
長さ（ `length$t ）
</li>
					<li>
`格子~容器$の~sizeに対する百分率（ `percentage$t ）
</li>
					<li>
筋rcを占める内容の測定（ `min-content$vt, `max-content$vt ）
</li>
					<li>
格子~内の~free空間の割合分（ `flex$t ）
</li>
				</ul>

<p class="trans-note">【
この~listの和集合は、
下の構文の `track-breadth$t （から値 `auto^v を除いたもの）に該当する。
】</p>

◎
can be specified as a length, a percentage of the grid container’s size, a measurement of the contents occupying the column or row, or a fraction of the free space in the grid.＼
</li>
			<li>
または、
`minmax$f 記法による範囲として指定できる
— その［
%min, %max
］引数に，前~項に挙げたいずれかの筋~sizing関数を与えて。
これらの引数は、
順に［
`~min筋~sizing関数$, `~max筋~sizing関数$
］を与えることになる。
◎
It can also be specified as a range using the minmax() notation, which can combine any of the previously mentioned mechanisms to specify separate min and max track sizing functions for the column or row.
</li>
		</ul>
	</dd>

	<dt id="subgrid-listing">`subgrid$vt `line-name-list$t?</dt>
	<dd>
<p>
`subgrid@vt
値は、
この値が`入子な格子$ %容器 の［
`grid-template-columns$p に指定された場合は %容器 の~col軸／
`grid-template-rows$p に指定された場合は %容器 の~row軸
］を
`下位格子~化@
することを指示する
【 %容器 は、その軸に関して`下位格子$になる】：
</p>
		<ul>
			<li>
%容器 は、
`下位格子~化$された軸において［
格子~駒としての %容器 が`親~格子$内で~spanする部位
］を受入れることになる。
</li>
			<li>
%容器 の`下位格子~化$された各~筋の~sizeは、
明示的に指定されることなく，`親~格子$の定義から採られる。
</li>
			<li>
%容器 内の各~駒は、
`親~格子$と共有される筋の`内在的~size$の計算に関与することになる
（ `§ 内在的な筋~sizeを解決する＠#algo-content$ ）。
</li>
		</ul>

<p class="trans-note">【
%容器 が`直交~flowを確立して$いる場合、
`下位格子~化$される［
~col／~row
］は，
%容器 の`親~格子$における［
~row／~col
］として共有されることに注意。
】</p>
◎
The subgrid value indicates that the grid will adopt the spanned portion of its parent grid in that axis (the subgridded axis). Rather than being specified explicitly, the sizes of the grid rows/columns will be taken from the parent grid's definition, and the subgrid’s items will participate in the intrinsic size calculations (CSS Grid Layout 1 § 11.5 Resolve Intrinsic Track Sizes) of any tracks shared with the parent grid.＼
</dd>
	<dd>
`下位格子$は、
本質的には，次の能を供する
⇒
自身を通して、
親~格子の~parameter群を自身が入子にしている各~要素へ渡して，
各~要素の内容に基づく~sizingの情報を親~格子へ戻す。
◎
Essentially, subgrids provide the ability to pass grid parameters down through nested elements, and content-based sizing information back up to their parent grid.
</dd>
	<dd>
`line-name-list$t 引数は、
`親~格子$と共有される罫たちを，局所的に命名できるようにする。
与えられた場合，指定された各 `line-names$t は、
`下位格子$の`明示的な格子$を成す罫に，罫 1 から順にアテガわれる。
超過した `line-names$t は無視される。
◎
The &lt;line-name-list&gt; argument allows local naming of the grid lines shared with the parent grid: if a &lt;line-name-list&gt; is given, the specified &lt;line-names&gt;s are assigned to the lines of the subgrid’s explicit grid, one per line, starting with line 1. Excess &lt;line-names&gt; are ignored.
</dd>
	<dd>
この`格子~容器$は［
`入子な格子$でない【！`親~格子$は無い】場合／
`独立な整形~文脈$を確立するよう強制される場合
（例：`~layout封込め$ `CSS-CONTAIN-2$r や`絶対~位置決め$ `CSS-POSITION-3$r に因り）
］、
`使用~値$は初期~値 `none$vt になり，`下位格子$にはならない。
◎
If there is no parent grid, or if the grid container is otherwise forced to establish an independent formatting context (for example, due to layout containment [CSS-CONTAIN-2] or absolute positioning [CSS-POSITION-3]), the used value is the initial value, none, and the grid container is not a subgrid.
</dd>
	<dd>
`下位格子~化$されない軸は、
`自立的@
な軸と称される。
◎
An axis that is not subgridded is a standalone axis.
</dd>
</dl>

<p>
`筋~list$の構文は：
◎
The syntax of a track list is:
</p>

<pre class="prod">
`track-list@t
	= [ `line-names$t? [ `track-size$t | `track-repeat$t ] ]+
		`line-names$t?

`auto-track-list@t
	= [ `line-names$t? [ `fixed-size$t | `fixed-repeat$t ] ]*
		`line-names$t? `auto-repeat$t
	  [ `line-names$t? [ `fixed-size$t | `fixed-repeat$t ] ]*
		`line-names$t?

`explicit-track-list@t
	= [ `line-names$t? `track-size$t ]+ `line-names$t?

`line-name-list@t
	= [ `line-names$t | `name-repeat$t ]+

`track-size@t
	= `track-breadth$t
	| `minmax$vt( `inflexible-breadth$t , `track-breadth$t )
	| `fit-content$vt( `length-percentage [0,∞]$t ] )

`fixed-size@t
	= `fixed-breadth$t
	| `minmax$vt( `fixed-breadth$t , `track-breadth$t )
	| `minmax$vt( `inflexible-breadth$t , `fixed-breadth$t )

`track-breadth@t
	= `length-percentage [0,∞]$t
	| `flex [0,∞]$t
	| `min-content$vt
	| `max-content$vt
	| `auto$vt

`inflexible-breadth@t
	= `length-percentage [0,∞]$t
	| `min-content$vt
	| `max-content$vt
	| `auto$vt

`fixed-breadth@t
	= `length-percentage [0,∞]$t

`line-names@t
	= '[' `custom-ident$t* ']'
</pre>

<p>
ここで、
各種 成分~値は以下に定義される…
◎
Where the component values are defined as follows…
</p>

			<section id="track-sizes">
<h4 title="Track Sizes">7.2.1. 筋~size</h4>

<dl class="valdef">

	<dt id="valdef-grid-template-columns-length-percentage-0">`length-percentage [0,∞]$t</dt>
	<dd>
`CSS-VALUES-3$r にて定義される，負でない［
長さ／百分率
］値。
◎
A non-negative length or percentage, as defined by CSS3 Values. [CSS-VALUES-3]
</dd>
	<dd>
百分率~値は、［
~col`筋$／~row`筋$
］においては`格子~容器$ %容器 の`内縁$［
`行内~size$／`塊~size$
］に相対的になる。
%容器 の~sizeが その各~筋の~sizeに依存する場合の百分率~値は、
まず， %容器 の`内在的~size$を計算する目的においては，
`~autoS$v として扱った上で、
%容器 内に駒を~lay-outする目的においては，
その結果の~sizeに相対的に解決するモノトスル。
◎
&lt;percentage&gt; values are relative to the inner inline size of the grid container in column grid tracks, and the inner block size of the grid container in row grid tracks. If the size of the grid container depends on the size of its tracks, then the &lt;percentage&gt; must be treated as auto, for the purpose of calculating the intrinsic sizes of the grid container and then resolve against that resulting grid container size for the purpose of laying out the grid and its items.
</dd>

	<dt id="valdef-grid-template-columns-flex-0">`flex [0,∞]$t</dt>
	<dd>
`fr$u 単位による負でない次元であり，筋の
`~flex係数@
を指定する。
`flex$t ~sizeにされた各~筋は、
残りの空間から，その`~flex係数$に比例する割合を持分として得る。
例えば，筋~listが `1fr 2fr^v の場合、
各~筋は，順に `残余~空間$V の ⅓, ⅔ を占めることになる。
詳細は
`§ ~flex可能な長さ＠#fr-unit$を見よ。
◎
A non-negative dimension with the unit fr specifying the track’s flex factor. Each &lt;flex&gt;-sized track takes a share of the remaining space in proportion to its flex factor. For example, given a track listing of 1fr 2fr, the tracks will take up ⅓ and ⅔ of the leftover space, respectively. See § 7.2.4 Flexible Lengths: the fr unit for more details.
</dd>
	<dd class="note">注記：
`~flex係数$の総和が 1 未満になる場合、
筋たちは `残余~空間$V の対応する割合分のみを占める
— 全体を埋めるよう拡げられることはない。
◎
Note: If the sum of the flex factors is less than 1, they’ll take up only a corresponding fraction of the leftover space, rather than expanding to fill the entire thing.
</dd>
	<dd>
`minmax$f 記法の外側に現れるときは、
自動的な最小
（すなわち， <code class="value">minmax(auto, `flex$t )</code> ）
を~~意味する。
◎
When appearing outside a minmax() notation, implies an automatic minimum (i.e. minmax(auto, &lt;flex&gt;)).
</dd>

	<dt><code class="value">`minmax@vt(%min, %max)</code></dt>
	<dd>
%min 以上 %max 以下の~size範囲を定義する。
%min ~GT %max の場合、
%max は %min 以上に切り上げられる
（本質的に、
<code class="value">minmax(%min, %min)</code> を得る）。
%max に対する `flex$t 値は，筋の`~flex係数$を設定する一方で、
%min に対するそれは，無効になるとする。
◎
Defines a size range greater than or equal to min and less than or equal to max. If the max is less than the min, then the max will be floored by the min (essentially yielding minmax(min, min)). As a maximum, a &lt;flex&gt; value sets the track’s flex factor; it is invalid as a minimum.

If max &lt; min, then max is ignored and minmax(min,max) is treated as min. 
</dd>
	<dd class="note">注記：
この仕様の将来~levelでは、
%min に対する `flex$t 値も許容され，それを正しく織り込むよう`筋~sizing~algo$を更新することになる。
◎
Note: A future level of this spec may allow &lt;flex&gt; minimums, and will update the track sizing algorithm to account for this correctly
</dd>

	<dt>`auto@vt</dt>
	<dd>
`最大^emとしては、
`max^op( `筋$を占めている各 `格子~駒$の`最大-内容~供与$ )
を表現する。
しかしながら， `max-content$vt と違って、
`内容-分布~prop$により筋を拡げることも許容する。
◎
As a maximum: represents the largest max-content contribution of the grid items occupying the grid track; however, unlike max-content, allows expansion of the track by the align-content and justify-content properties.
</dd>
	<dd>
`最小^emとしては、
`max^op( `筋$を占めている各 `格子~駒$の`最小~size$ )
を表現する。
（これは，初期~時には `min-content$vt による最小に等しくなることが多いが、
常にではない
— `§ 格子~駒の自動的な最小~size$を見よ。）
◎
As a minimum: represents the largest minimum size (specified by min-width/min-height) of the grid items occupying the grid track. (This initially is often, but not always, equal to a min-content minimum—see § 6.6 Automatic Minimum Size of Grid Items.)
</dd>
	<dd>
`minmax$f 記法の外側に現れるときは、
`minmax(auto, auto)^v と等価になり，
上で述べた最小から最大までの範囲を表現する
（ほとんどの基本的な事例では， `minmax(min-content, max-content)^v と類似に挙動するが、
~~追加の能もある）。
◎
When appearing outside a minmax() notation: equivalent to minmax(auto, auto), representing the range between the minimum and maximum described above. (This behaves similar to minmax(min-content, max-content) in the most basic cases, but with extra abilities.)
</dd>

	<dt>`max-content@vt</dt>
	<dd>
`max^op( `筋$を占めている各 `格子~駒$の`最大-内容~供与$ )
を表現する。
◎
Represents the largest max-content contribution of the grid items occupying the grid track.
</dd>

	<dt>`min-content@vt</dt>
	<dd>
`max^op( `筋$を占めている各 `格子~駒$の`最小-内容~供与$ )
を表現する。
◎
Represents the largest min-content contribution of the grid items occupying the grid track.
</dd>

	<dt><code class="value">`fit-content@vt( `length-percentage [0,∞]$t【！length-percentage】 )</code></dt>
	<dd>
`max^op( %最小, `min^op( %上限, `max-content$vt ) )
を表現する
— ここで、
%最小 は `auto$vt による最小を表現する
（これは， `min-content$vt による最小に等しくなることが多いが、常にではない）／
%上限 は `fit-content$f の引数に渡された`筋~sizing関数$。
これは，本質的には、
`min^op( `minmax(auto, max-content)^v, <code class="value">minmax(auto, %上限)</code> )
として計算される。
◎
Represents the formula max(minimum, min(limit, max-content)), where minimum represents an auto minimum (which is often, but not always, equal to a min-content minimum), and limit is the track sizing function passed as an argument to fit-content(). This is essentially calculated as the smaller of minmax(auto, max-content) and minmax(auto, limit).
</dd>
</dl>

<div class="example">
<p>
次の宣言に対しては：
◎
Given the following grid-template-columns declaration:
</p>

<pre class="lang-css">
`grid-template-columns$p: 100px 1fr max-content `minmax$vt(min-content, 1fr);
</pre>

<p>
5 本の罫が作成される：
◎
Five grid lines are created:
</p>
<ol>
	<li>
`格子~容器$の始端~辺に 1 本
◎
At the start edge of the grid container.
</li>
	<li>
`格子~容器$の始端~辺から 100px の所に 1 本
◎
100px from the start edge of the grid container.
</li>
	<li>
前の罫からの距離が［
`~free空間$
（ ~EQ `格子~容器$の横幅 ~MINUS `~flex可能$でない`筋$たちの横幅の総和 ）
の半分
］に等しい所に 1 本
◎
A distance from the previous line equal to half the free space (the width of the grid container, minus the width of the non-flexible grid tracks).
</li>
	<li>
前の罫からの距離が［
`max^op( 前の罫と この罫の合間にある~colに属する各 `格子~駒$の最大~size )
］に等しい所に 1 本
◎
A distance from the previous line equal to the maximum size of any grid items belonging to the column between these two lines.
</li>
	<li>
前の罫からの距離が［
`max^op( 前の罫と この罫の合間にある~colに属する各 `格子~駒$の最小~size )
以上, かつ［
`~free空間$のもう半分
］以下
］の所に 1 本
◎
A distance from the previous line at least as large as the largest minimum size of any grid items belonging to the column between these two lines, but no larger than the other half of the free space.
</li>
</ol>

<p>
~flex可能でない~size
（ `100px^v, `max-content$vt, `min-content$vt ）
の総和が`格子~容器$の横幅より大きい場合、
最後尾の`罫$は，`格子~容器$の始端~辺からこの総和だけ離れた所に~~位置する
（~size `1fr^v は，いずれも `0^v に解決される）。
この総和が`格子~容器$の横幅より小さい場合、
最後尾の`罫$は，正確に`格子~容器$の終端~辺の所に~~位置する。
これは一般に、［
一連の`筋$~sizeのうち 少なくとも 1 個は `flex$t 値があるとき
］に成立する。
◎
If the non-flexible sizes (100px, max-content, and min-content) sum to larger than the grid container’s width, the final grid line will be a distance equal to their sum away from the start edge of the grid container (the 1fr sizes both resolve to 0). If the sum is less than the grid container’s width, the final grid line will be exactly at the end edge of the grid container. This is true in general whenever there’s at least one &lt;flex&gt; value among the grid track sizes.
</p>
</div>

<div class="example">
<p>
その他の，`筋$として妥当な定義~例：
◎
Additional examples of valid grid track definitions:
/* examples of valid track definitions */
</p>

<pre class="lang-css">
grid-template-rows: 1fr minmax(min-content, 1fr);
grid-template-rows: 10px repeat(2, 1fr auto minmax(30%, 1fr));
grid-template-rows: calc(4em - 5px);
</pre>
</div>

<p class="note">注記：
格子の~sizeは、
各~筋~sizeの総和そのままではない
—
`row-gap$p, `column-gap$p, および`内容-分布~prop$により，
各~筋~間に空間が追加され得るので。
◎
Note: The size of the grid is not purely the sum of the track sizes, as row-gap, column-gap and justify-content, align-content can add additional space between tracks.
</p>

			</section>
			<section id="named-lines">
<h4 title="Naming Grid Lines: the [&lt;custom-ident&gt;*] syntax">7.2.2. 罫の命名-法： <span class="prod">[`custom-ident^t*]</span> 構文</h4>

<p>
各`罫$は数量的~indexで参照rできるが、
`罫~名@
をアテガうことで，`格子~配置~prop$を［
理解する／保守する
］のは もっと容易になり得る。
`罫~名$は、
次のいずれかによりアテガえる：
◎
While grid lines can always be referred to by their numerical index, line names can make the grid-placement properties easier to understand and maintain. Line names can be＼
</p>
<ul>
	<li>
［
`grid-template-rows$p ／ `grid-template-columns$p
］~propにより，
`明示的にアテガわれる罫~名@
◎
explicitly assigned with the grid-template-rows and grid-template-columns properties,＼
</li>
	<li>
`grid-template-areas$p ~propにより定義される`有名~区画$により，
`暗黙的にアテガわれる罫~名$
◎
or implicitly assigned by named grid areas with the grid-template-areas property.
</li>
</ul>

<p class="trans-note">【
これらの罫~名を異なる名前にすることは必要yでない。
`暗黙的にアテガわれる罫~名$どうしは、
定義により，~~重複し得ないが。
】</p>

<div class="example">
<p>
例えば，次の~codeでは、
格子~内のすべての罫に，有意義な名前を与えている。
罫のうちいくつかは複数の名前を持つことに注意：
◎
For example, the following code gives meaningful names to all of the lines in the grid. Note that some of the lines have multiple names.
</p>

<pre class="lang-css">
#grid {
  display: grid;
  grid-template-columns:
        [first nav-start] 150px [main-start] 1fr [last];
  grid-template-rows:
      [first header-start] 50px [main-start] 1fr [footer-start] 50px [last];
}
</pre>

<figure class="figure">
<figcaption id="_dgm-grid-named-lines">
罫を参照rする［
~index／`明示的にアテガわれる罫~名$【！有名~罫】
］
◎
Named Grid Lines.
</figcaption></figure>
</div>

<p>
`罫~名$を［
`span^v ／ `auto^v
］にすることはできない。
すなわち，これらの~keywordは、
`line-names$t を成す `custom-ident$t からは除外される。
◎
A line name cannot be span or auto, i.e. the &lt;custom-ident&gt; in the &lt;line-names&gt; production excludes the keywords span and auto.
</p>

			</section>
			<section id="repeat-notation">
<h4 title="Repeating Rows and Columns: the repeat() notation">7.2.3. 一連の筋rcを繰返すための記法： `repeat^f</h4>

<p>
`repeat@f
記法は、
`筋~list$の繰返nを表現する。
これは、
同じ~patternを繰り~~返す多数の筋rcを，より簡潔に記せるようにするものである。
◎
The repeat() notation represents a repeated fragment of the track list, allowing a large number of columns or rows that exhibit a recurring pattern to be written in a more compact form.
</p>

<div class="example">
<p>
次の例に、
同じ格子~定義を記す 2 つの等価な仕方を示す。
どちらの宣言も、［
10px の “側溝” ~colに挟まれた 250px 幅の “主” ~col
］が 4 回~繰返される格子を生産する。
◎
This example shows two equivalent ways of writing the same grid definition. Both declarations produce four “main” columns, each 250px wide, surrounded by 10px “gutter” columns.
</p>

<pre class="lang-css">
grid-template-columns:
               10px [col-start] 250px [col-end]
               10px [col-start] 250px [col-end]
               10px [col-start] 250px [col-end]
               10px [col-start] 250px [col-end]
               10px;

/* <span class="comment">
上と同じだが，より書き易い：
◎
same as above, except easier to write
</span>*/
grid-template-columns:
     repeat(4, 10px [col-start] 250px [col-end])
               10px;
</pre>
</div>

				<section id="repeat-syntax">
<h5 title="Syntax of repeat()">7.2.3.1. `repeat^f の構文</h5>

<p>
`repeat$f 構文の一般形は、
およそ次のようになる：
◎
The generic form of the repeat() syntax is, approximately,
</p>

<pre class="prod">
repeat( [ `integer [1,∞]$t | `auto-fill^v | `auto-fit^v ] , `track-list$t )
</pre>

<p>
1 個目の引数は繰返n回数を指定する。
2 個目の引数は`筋~list$であり， 1 個目の引数による回数だけ繰返される。
しかしながら、
いくつかの制約がある：
◎
The first argument specifies the number of repetitions. The second argument is a track list, which is repeated that number of times. However, there are some restrictions:
</p>

<ul>
	<li>
`repeat$f 記法は入子にできない。
◎
The repeat() notation can’t be nested.
</li>
	<li>
自動的な繰返n（ `auto-fill$v ／ `auto-fit$v ）と全部的に［
内在的／~flex可能
］な~size（`内在的~sizing関数$／`~flex可能な~sizing関数$）とを組合せることはできない（文法を見よ）。
◎
Automatic repetitions (auto-fill or auto-fit) cannot be combined with fully intrinsic or flexible sizes (see grammar).
</li>
</ul>

<p>
したがって， `repeat$f 記法の精確な構文は、
いくつかの形をとる：
◎
Thus the precise syntax of the repeat() notation has several forms:
</p>

<pre class="prod">
`track-repeat@t
	= repeat(
		[ `integer [1,∞]$t ],
		[ `line-names$t? `track-size$t ]+ `line-names$t? )

`auto-repeat@t
	= repeat(
		[ `auto-fill$v | `auto-fit$v ],
		[ `line-names$t? `fixed-size$t]+ `line-names$t? )

`fixed-repeat@t
	= repeat(
		[ `integer [1,∞]$t ],
		[ `line-names$t? `fixed-size$t ]+ `line-names$t? )

`name-repeat@t
	= repeat(
		[ `integer [1,∞]$t | `auto-fill$v ],
		`line-names$t+ )
</pre>

<p>
これらの変種は：
◎
↓</p>

<ul>
	<li>
`track-repeat$t は，どの `track-size$t の繰返nも表現できるが、
繰返nは固定的な回数に制限される。
◎
The &lt;track-repeat&gt; variant can represent the repetition of any &lt;track-size&gt;, but is limited to a fixed number of repetitions.
</li>
	<li>
`auto-repeat$t は，空間を埋めるよう自動的に繰返せるが、
繰返n回数が計算できるようになるためには，各 筋~sizeが`確定的$になることを要する。
これは，`筋~list$内に一度しか現れ得ないが、
同じ`筋~list$は `fixed-repeat$t も包含できる。
◎
The &lt;auto-repeat&gt; variant can repeat automatically to fill a space, but requires definite track sizes so that the number of repetitions can be calculated. It can only appear once in the track list, but the same track list can also contain &lt;fixed-repeat&gt;s.
</li>
	<li>
`name-repeat$t は，`下位格子$に`罫~名$を追加するためにあり、
`subgrid$vt ~keywordとの併用に限り利用できる。
それは、
筋~sizeは指定できない
— 指定できるのは`罫~名$に限られる。
◎
The &lt;name-repeat&gt; variant is for adding line names to subgrids. It can only be used with the subgrid keyword and cannot specify track sizes, only line names.
</li>
</ul>

<p>
`name-repeat$t 以外の
`repeat$f 関数が `line-names$t を隣接させることになる場合、
それらの名前は継ぎ合される：
例えば［
`repeat(2, [a] 1fr [b])^v
］は［
`[a] 1fr [b a] 1fr [b]^v
］と等価になる。
◎
If a repeat() function that is not a &lt;name-repeat&gt; ends up placing two &lt;line-names&gt; adjacent to each other, the name lists are merged. For example, repeat(2, [a] 1fr [b]) is equivalent to [a] 1fr [b a] 1fr [b].
</p>

				</section>
				<section id="auto-repeat">
<h5 title="Repeat-to-fill: auto-fill and auto-fit repetitions">7.2.3.2. 埋まるまで繰返す： `auto-fill^v ／ `auto-fit^v</h5>

<p>
~keyword
`auto-fill@v
による繰返n回数は、
以下に従って決定される。
◎
↓</p>

<p>
`下位格子~化$された軸に対しては
⇒
`auto-fill$v ~keywordが妥当になるのは，
`line-name-list$t 内で 1 回までに限られ、
名前~list
【 `name-repeat$t 内の `line-names$t 】
を［
下位格子に指定された`~span数$に合致するまで十分な回数
］だけ繰返す
（すでに~span数が充足されていた場合、
0 に~fall-backする）。
◎
On a subgridded axis, the auto-fill keyword is only valid once per &lt;line-name-list&gt;, and repeats enough times for the name list to match the subgrid’s specified grid span (falling back to 0 if the span is already fulfilled).
</p>

<p>
`自立的$な軸に対し `auto-fill$v が与えられた場合、
指定された`筋~list$は［
次に従って決定される回数
］だけ繰返される：
◎
Otherwise on a standalone axis, when auto-fill is given as the repetition number,＼
</p>
<ol>
	<li>
<p>
`格子~容器$の関連な軸における［
~size【`選好d~size$】または~max~size【`最大~size$】
］は`確定的$な場合
⇒
回数は、
次を満たす最~大な正な整数は［
在るならば それ ／
無いならば 1
］になる
⇒
`格子$は，その`格子~容器$の`内容~box$を~overflowしない
</p>

<p>
この~overflowの~~判定においては：
</p>
		<ul>
			<li>
各~筋の~sizeは，その［
`~max筋~sizing関数$ %~max, `~min筋~sizing関数$ %~min
］に応じて，次に与える~sizeになるものと扱う
⇒＃
%~max, %~min とも`確定的$であるならば `max^op( %~max, %~min )／
%~max のみ`確定的$であるならば %~max／
~ELSE_ %~min
</li>
			<li>
`側溝$が占める~size（ `gap$p ）も織り込む。
</li>
		</ul>
◎
if the grid container has a definite size or max size in the relevant axis, then＼
the number of repetitions is the largest possible positive integer that does not cause the grid to overflow the content box of its grid container＼
(treating each track as its max track sizing function if that is definite or as its minimum track sizing function otherwise,＼
flooring the max track sizing function by the min track sizing function if both are definite, and taking gap into account);＼
if any number of repetitions would overflow, then 1 repetition.＼
</li>
	<li>
他の場合，`格子~容器$の関連な軸における~min~size【`最小~size$】は`確定的$ならば
⇒
回数は、
その最小~要件を充足する最~小な正な整数になる。
◎
Otherwise, if the grid container has a definite min size in the relevant axis, the number of repetitions is the smallest possible positive integer that fulfills that minimum requirement.＼
</li>
	<li>
他の場合
⇒
回数は 1 になる。
◎
Otherwise, the specified track list repeats only once.
</li>
</ol>

<div class="example">
<p>
例えば次の~codeは、
~UIwindow横幅に収まるような 25 文字幅の~colたちを作成した上で、
余った空間は これらの~colに分配する。
◎
For example, the following code will create as many 25-character columns as will fit into the window width. If there is any remaining space, it will be distributed among the 25-character columns.
</p>

<pre class="lang-css">
body {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(25ch, 1fr));
}
</pre>
</div>

<p>
~keyword
`auto-fit@v
の挙動は、
次のようにふるまうことを除いて，
`auto-fill$v と同じになる
⇒
繰返される筋のうち，空な筋
— そこに~spanするよう`配置される＠#auto-placement-algo$［
`~flow内$に在る格子~駒
］は無い筋 —
は、
`畳まれ$る
（すべての筋が空になる場合、
`すべて^em`畳まれ$る）。
◎
The auto-fit keyword behaves the same as auto-fill, except that after grid item placement any empty repeated tracks are collapsed. An empty track is one with no in-flow grid items placed into or spanning across it. (This can result in all tracks being collapsed, if they’re all empty.)
</p>

<p>
`畳まれ@
た筋の`筋~sizing関数$は、
固定的な `0px^v と扱われ，その両~側の`側溝$も
— `分布型の整列$を通して割り当てられた空間も含め —
`畳まれ$gutる。
◎
A collapsed track is treated as having a fixed track sizing function of 0px, and the gutters on either side of it—including any space allotted through distributed alignment—collapse.
</p>

<p>
`自立的$な軸において自動的に繰返される筋の本数を見出す目的においては、
0 による除算を避けるため、
~UAは，筋~sizeを，自身が指定する~~下限~以上に切り上げるモノトスル。
この~~下限には， `1px^v が示唆される。
◎
For the purpose of finding the number of auto-repeated tracks in a standalone axis, the UA must floor the track size to a UA-specified value to avoid division by zero. It is suggested that this floor be 1px.
</p>

				</section>
				<section id="repeat-interpolation">
<h5 title="Interpolation/Combination of repeat()">7.2.3.3. `repeat^f の補間／結合n</h5>

<p>
2 つの `repeat$f 記法は、
双方の［
1 個目の引数（繰返n回数）,
2 個目の引数（筋~list）による筋~本数
］どちらも互いに同じならば、
互いの`算出d筋~list$を成す各~成分を`算出d値の型により＠~WANIM#by-computed-value$ 結合することにより結合される
（~top-levelの筋~listを結合するときと同じく）。
他の場合、
`離散的$に結合される。
◎
If two repeat() notations that have the same first argument (repetition count) and the same number of tracks in their second argument (the track listing), they are combined by combining each component of their computed track lists by computed value (just like combining a top-level track list). They otherwise combine discretely.
</p>

				</section>
			</section>
			<section id="fr-unit">
<h4 title="Flexible Lengths: the fr unit">7.2.4.  ~flex可能な長さ： `fr^u 単位</h4>

<p>
`~flex可能な長さ@
（ `flex@t ）は、
`fr@u
単位の次元であり，`格子~容器$内の `残余~空間$V の割合分を表現する。
`fr$u 単位で~sizeされている筋は
`~flex可能@
と呼ばれる
— それらは、
`~flex容器$内で［
基底~size 0 にされた`~flex駒$
］が空間を埋めるときと類似に， `残余~空間$V に呼応して~flexするので。
◎
A flexible length or &lt;flex&gt; is a dimension with the fr unit, which represents a fraction of the leftover space in the grid container. Tracks sized with fr units are called flexible tracks
as they flex in response to leftover space similar to how flex items with a zero base size fill space in a flex container.
</p>

<p>
`~free空間$の分配は、
すべての`~flex可能$でない筋の`筋~sizing関数$がそれらの最大に†達した後に生じる。
可用な空間から それらの筋rcの合計~sizeを差し引いた結果が `残余~空間$V になる。
`残余~空間$V は、
~flexに~sizeされる筋rcたちに，各自の`~flex係数$に比例する割合で分割0される。
【† “達した” の意味は，`§ 格子~layout~algo$の中で定義される。】
◎
The distribution of leftover space occurs after all non-flexible track sizing functions have reached their maximum. The total size of such rows or columns is subtracted from the available space, yielding the leftover space, which is then divided among the flex-sized rows and columns in proportion to their flex factor.
</p>

<p>
`残余~空間$V において各~筋rc %筋 が成す持分は、
次の結果として算出できる
⇒
`残余~空間$V ~MUL ( %筋 の`~flex係数$ ~DIV すべての`~flex係数$の総和 )
◎
Each column or row’s share of the leftover space can be computed as the column or row’s &lt;flex&gt; * &lt;leftover space&gt; / &lt;sum of all flex factors&gt;.
</p>

<details class="note">
<summary>注記：
`0fr^v から `1fr^v までの合間にある `flex$t 値には、
ある特別な挙動がある：
筋たちの~flex係数の総和が 1 に満たない場合、
それらが占める残余~空間は 100% に満たなくなる。
◎
&lt;flex&gt; values between 0fr and 1fr have a somewhat special behavior: when the sum of the flex factors is less than 1, they will take up less than 100% of the leftover space.
</summary>

<p>
筋の `flex$t 値は、
実質的に残余~空間の比例分を要請する
— 値 `1fr^v は “残余~空間 の 100%” を意味する。
同じ軸に属する筋たちが要請している残余~空間が，合計で 100% を超える場合、
互いの比を保ちながら正確に 100% を利用し尽くすように，振り分け直される
— 一方で 100% を下回る場合
（それぞれが `.25fr^v にされた 3 本の筋が在る場合など）、
各~筋は正確に要請した分だけ取得する
（各~筋は残余~空間の 25% を取得し，残る 25% は埋められない）。
残余~空間がどう分配されるかの正確な詳細は、
`~flex可能な筋を拡げる~algo＠#algo-flex-tracks$を見よ。
◎
A track’s &lt;flex&gt; value is effectively a request for some proportion of the leftover space, with 1fr meaning “100% of the leftover space”; then if the tracks in that axis are requesting more than 100% in total, the requests are rebalanced to keep the same ratio but use up exactly 100% of it. However, if the tracks request less than the full amount (such as three tracks that are each .25fr) then they’ll each get exactly what they request (25% of the leftover space to each, with the final 25% left unfilled). See § 12.7 Expand Flexible Tracks for the exact details of how leftover space is distributed.
</p>

<p>
この~patternは、
~flex係数が 0 に近づくときの挙動を連続的にするために要求される
（すなわち、
筋は残余~空間をまったく占めないことが求まれる）。
さもなければ、
筋の~flex係数が `0fr^v にどこまで近づこうが
— `1fr^v のときと同じく —
残余~空間すべてを占め， 0 に十分~近くなった所で，いきなり，まったく占めなくなる。
この挙動があれば、
~flex係数が `1fr^v から下へ縮短するに伴い［
駒が占める残余~空間は、
次第に減り， 0 の所で無くなる
］よう，滑らかに遷移することになる。
◎
This pattern is required for continuous behavior as fr values approach zero (which means the tracks wants none of the leftover space). Without this, a 1fr track would take all of the leftover space; but so would a 0.1fr track, and a 0.01fr track, etc., until finally the value is small enough to underflow to zero and the track suddenly takes up none of the leftover space. With this behavior, the track instead gradually takes less of the leftover space as its flex factor shrinks below 1fr, smoothly transitioning to taking none of the leftover space at zero.
</p>

<p>
作者は、
この “部分的に埋める” 挙動が`特定的に^em欲されない限り，
1 以上の値を貫き続けるべきである。
例えば `1^v, `2^v を利用する方が，
`.33^v, `.67^v を利用するより通例的に良い
— その方が、
筋が追加-／除去されたときにも，意図される挙動が保たれると見込まれるので。
【！原文誤：余計な or line-wrapped 】
◎
Unless this “partial fill” behavior is specifically what’s desired, authors should stick to values ≥ 1; for example, using 1fr and 2fr is usually better than using .33fr and .67fr, as they’re more likely to behave as intended if tracks are added or removed.
</p>
</details>

<p>
可用な空間が無限である場合
（`格子~容器$の横幅／縦幅が`不定$なときに起こる）、
~flexに~sizeされる`筋$たちは，
互いの比率を維持しながら 各自の内容に~sizeされる。
~flexに~sizeされる各`筋$の使用~sizeは、
次に従って算出される：
◎
When the available space is infinite (which happens when the grid container’s width or height is indefinite), flex-sized grid tracks are sized to their contents while retaining their respective proportions. The used size of each flex-sized grid track is computed by＼
</p>

<ol>
	<li>
<p>
各~筋に対し、
その “仮の `1fr^v ~size” を決定する。
それは、
次で与えられる
⇒
筋の `max-content$vt ~sizeを決定した結果 ~DIV  筋の`~flex係数$
</p>

<p class="trans-note">【
上述した特別な挙動があるので、
実際の計算はずっと複階的な過程を経る。
】</p>
◎
determining the max-content size of each flex-sized grid track and dividing that size by the respective flex factor to determine a “hypothetical 1fr size”.＼
</li>
	<li>
`~flex割合分@
— `1fr^v を解決した結果の長さ —
を得る。
それは、
次で与えられる
⇒
すべての筋の “仮の `1fr^v ~size” の最大
◎
The maximum of those is used as the resolved 1fr length (the flex fraction),＼
</li>
	<li>
各~筋の最終的な~sizeは、
次で与えられる
⇒
`~flex割合分$ ~MUL 筋の`~flex係数$
◎
which is then multiplied by each grid track’s flex factor to determine its final size.
</li>
</ol>

<p class="note">注記：
`flex$t 値は `length$t ではない
（一部の `percentage$t 値のように `length$t と互換でもない）
ので、
`calc$f 式において，他の単位~型［
で表現する／と組合せる
］ことはできない。
◎
Note: &lt;flex&gt; values are not &lt;length&gt;s (nor are they compatible with &lt;length&gt;s, like some &lt;percentage&gt; values), so they cannot be represented in or combined with other unit types in calc() expressions.
</p>

			</section>
			<section id="computed-tracks">
<h4 title="Computed Value of a Track Listing">7.2.5. 筋~listの算出d値</h4>

<div>
<p>
`算出d筋~list@
— `筋~list$の`算出d値$ —
は、
その軸~用の各~罫を表現している［
`罫~名~集合$／`筋~節$
］たちが成す`~list$になる
— ただし：
</p>
<ul>
	<li>
非 `subgrid$vt 軸である場合【 `subgrid^v を伴わない場合】
⇒
~listを成す［
最初の~item, 最後の~item
］は、
`罫~名~集合$に限られる。
</li>
	<li>
<p>
`subgrid$vt 軸である場合
⇒
先頭に~keyword `subgrid$vt を伴うことに加え、
~listを成す`筋~節$は，`算出d~repeat記法$に限られる。
</p>

<p class="trans-note">【
当の格子が`入子な格子$でない場合、
使用~値は `none^v になり，
`下位格子~化$された軸にならない（`自立的$な軸になる）が、
それでも，算出d値は このように定義される
（ `6165$issue ）。
】</p>
	</li>
</ul>

<p>
`罫~名~集合@
は、［
`罫~名$を表現している識別子
］たちが成す`集合$である。
</p>

<p>
`筋~節@
は、
次のいずれかである：
</p>
<ul>
	<li>
`算出d筋~size@
⇒
1 本の筋の~sizeを表現している `minmax$f 関数-記法
— ただし、
その【引数に含まれる】各 `length-percentage$t は算出される。
</li>
	<li>
`算出d~repeat記法@
⇒
繰返される筋~list節を表現している `repeat$f 関数-記法
— ただし、
その【引数に含まれる】
⇒＃
各 `integer$t は算出される【？】／
各 `track-list$t は`算出d筋~list$で表現される
</li>
</ul>

◎
The computed track list of a non-subgrid axis is a list alternating between line name sets and track sections, with the first and last items being line name sets.
◎
A line name set is a (potentially empty) set of identifiers representing line names.
◎
A track section is either:
• a minmax() functional notation representing a single track’s size, with each &lt;length-percentage&gt; computed (a computed track size)
• a repeat() functional notation representing a repeated track list section, with its &lt;integer&gt; computed and its &lt;track-list&gt; represented as a computed track list (a computed repeat notation)
◎
The computed track list of a subgrid axis is the subgrid keyword followed by a list of line name sets and computed repeat notations representing the line names specified for that axis.
</div>

			</section>
			<section id="resolved-track-list">
<h4 title="Resolved Value of a Track Listing">7.2.6. 筋~listの解決d値</h4>

<p>
［
`grid-template-rows$p ／ `grid-template-columns$p
］~propの`解決d値は特別に定義される$
`CSSOM$r
— 以下に与えるとおり：
◎
The grid-template-rows and grid-template-columns properties are resolved value special case properties. [CSSOM]
</p>

				<section id="resolved-track-list-standalone">
<h5 title="Resolved Value of a Standalone Track Listing">7.2.6.1. 自立的な筋~listの解決d値</h5>

<p>
要素が`格子~容器$を生成する場合、
その`自立的$な軸における［
`grid-template-rows$p ／ `grid-template-columns$p
］~propの`解決d値$は，その`使用~値$を次に従って直列化した結果になる：
◎
When an element generates a grid container box, the resolved value of its grid-template-rows or grid-template-columns property in a standalone axis is the used value, serialized with:
</p>
<ul>
	<li>
すべての筋が, 個別に~listされる
— 暗黙的に作成されたものも含め，`repeat$f 記法は利用せずに。
◎
Every track listed individually, whether implicitly or explicitly created, without using the repeat() notation.
</li>
	<li>
筋~sizeは、
~sizing関数に関わらず，~pixel単位の長さとして与えられる。
◎
Every track size given as a length in pixels, regardless of sizing function.
</li>
	<li>
連続する`罫~名$は、
角括弧で括って一つにまとめられる。
◎
Adjacent line names collapsed into a single bracketed set.
</li>
</ul>

<div class="issue">
<p>
上の~listの最初の項は、
暗黙的な筋は `grid-template-rows$p 等々の一部として直列化されることを意味する
— 実際には、
作者は，それらの~propで暗黙的な筋の~sizeを`指定し得ない^em事実があるにもかかわらず。
なので，［
`grid-template-rows$p ／ `grid-template-columns$p
］の値は、
正しく往復しないかもしれない：
◎
The first bullet point of the above list means that implicit tracks get serialized as part of grid-template-rows/etc., despite the fact that an author cannot actually specify implicit track sizes in those properties! So grid-template-rows and grid-template-columns values might not round-trip correctly:
</p>

<pre class="lang-js">
const %s = getComputedStyle(%gridEl);
%gridEl.style.gridTemplateRows = %s.gridTemplateRows;
</pre>

<p>
この様な~codeは，`何もしないべきである^emが、
暗黙的な~rowが在る場合，明示的な~rowに変換される
— その結果，場合によっては、
格子~駒がどう位置されるかが変化し，
格子の全体的な~sizeを改めることになる。
◎
Code like this should be a no-op, but if there are any implicit rows, this will convert them into explicit rows, possibly changing how grid items are positioned and altering the overall size of the grid!
</p>

<p>
これは、
早期の実装による不用意な特質であり，
よく考えないまま後の実装に漏れ出た。
これは仕様から除去するものと意図されているが、
それは［
暗黙的な筋についての情報を取得するための~CSSOM~API
］を定義した後になる
— 現時点では、
これがその情報を取得する唯一の仕方であり，
いくつかの~pageはそれに依拠しているので。
◎
This is an accidental property of an early implementation that leaked into later implementations without much thought given to it. We intend to remove it from the spec, but not until after we’ve defined a CSSOM API for getting information about implicit tracks, as currently this is the only way to get that information and a number of pages rely on that.
</p>
</div>

<p>
他の場合
（例：要素の `display^p は `none^v ／要素は`格子~容器$でない）
の解決d値は、
単に算出d値になる。
◎
Otherwise, (e.g. when the element has display: none or is not a grid container) the resolved value is simply the computed value.
</p>

<div class="example">
<pre class="lang-html">
&lt;style&gt;
#grid {
  width: 500px;
  grid-template-columns:
    [a]     auto
    [b]     minmax(min-content, 1fr)
    [b c d] repeat(2, [e] 40px)
            repeat(5, auto);
}
&lt;/style&gt;

&lt;div id="grid"&gt;
  &lt;div style="grid-column-start: 1; width: 50px"&gt;&lt;/div&gt;
  &lt;div style="grid-column-start: 9; width: 50px"&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  var %gridElement = document.getElementById("grid");
  getComputedStyle(%gridElement).gridTemplateColumns;
  // <span class="comment">解決d値は次になる：</span>
  // [a] 50px [b] 320px [b c d e] 40px [e] 40px 0px 0px 0px 0px 50px
&lt;/script&gt;
</pre>
</div>

<p class="note">注記：
一般に，解決d値は、
少数の旧来の CSS 2.1 ~propを除いて，算出d値に等しい。
しかしながら，この~moduleの早期の実装との互換性を得るため、［
`grid-template-rows$p ／ `grid-template-columns$p
］は，使用~値を返すよう定義することが要求される。
◎
Note: In general, resolved values are the computed values, except for a small list of legacy 2.1 properties. However, compatibility with early implementations of this module requires us to define grid-template-rows and grid-template-columns as returning used values.
</p>

<p class="issue">
~CSS~WGは、
`格子~配置~prop$に対しても使用~値も返すかどうか考慮-中にある。
とりわけ実装者からの~feedbackを~~待っている。
`論点＠~CSSissue/2681$を見よ。
◎
The CSS Working Group is considering whether to also return used values for the grid-placement properties and is looking for feedback, especially from implementors. See discussion.
</p>

				</section>
				<section id="resolved-track-list-subgrid">
<h5 title="Resolved Value of a Subgridded Track Listing">7.2.6.2. 下位格子~化された筋~listの解決d値</h5>

<p>
要素が生成する~boxが`格子~容器$で，それは`下位格子$でもある場合、
要素の
【`下位格子~化$された軸における】［
`grid-template-rows$p ／ `grid-template-columns$p
］~propの`解決d値$は、
筋の本数の`使用~値$を［
`subgrid$vt ~keyword,
`罫~名~集合$を表現している~list
］が成す並びとして
— `repeat$f 記法を利用することなく —
直列化したものを表現する。
後者の~listは、
`下位格子$に対し明示的に定義された，すべての罫~名からなる
（`親~格子$から受入れたものは含まない）。
◎
When an element generates a grid container box that is a subgrid, the resolved value of the grid-template-rows and grid-template-columns properties represents the used number of columns, serialized as the subgrid keyword followed by a list representing each of its lines as a line name set of all the line’s names explicitly defined on the subgrid (not including those adopted from the parent grid), without using the repeat() notation.
</p>

<div class="example">
<p>
例えば， `grid-column$p を伴う`下位格子$に適用されるとき、
次の表の 1 列目に挙げる［
各 `grid-template-columns$p の`指定d値$
］に対応する`解決d値$は，
同じ行の 2 列目に与えられる：
◎
For example, when applied to a subgrid with grid-column: span 4, each of the following grid-template-columns specified values becomes the corresponding resolved values:
</p>

<div>
<table><thead>
<tr><th>指定d値
<th>解決d値
<tbody>

<tr><td>`subgrid [a] repeat(auto-fill, [b]) [c]^v
<td>`subgrid [a] [b] [b] [b] [c]^v

<tr><td>`subgrid [a] [a] [a] [a] repeat(auto-fill, [b]) [c] [c]^v
<td>`subgrid [a] [a] [a] [a] [c]^v

<tr><td>`subgrid [] [a]^v
<td>`subgrid [] [a] [] [] []^v

<tr><td>`subgrid [a] [b] [c] [d] [e] [f]^v
<td>`subgrid [a] [b] [c] [d] [e]^v
</table>
◎
specified: subgrid [a] repeat(auto-fill, [b]) [c]
resolved:  subgrid [a] [b] [b] [b] [c]

specified: subgrid [a] [a] [a] [a] repeat(auto-fill, [b]) [c] [c]
resolved:  subgrid [a] [a] [a] [a] [c]

specified: subgrid [] [a]
resolved:  subgrid [] [a] [] [] []

specified: subgrid [a] [b] [c] [d] [e] [f]
resolved:  subgrid [a] [b] [c] [d] [e]
</div>
</div>

<p class="note">注記：
これは、
末尾にある空な罫~名も含めて`罫~名~集合$を直列化していて，
“直列化は、等価なもののうち最短なそれにする”
とする一般~原則に違反する
— そうしているのは、
そのような罫~名たちが［
下位格子が~spanしている筋の本数について，有用になり得る情報
］を供するからである。
◎
Note: This violates the general "shortest equivalent serialization" principle by serializing empty trailing line name sets, as the trailing line name sets provide potentially-useful information about how many tracks the subgrid is spanning.
</p>

				</section>
			</section>
		</section>
		<section id="grid-template-areas-property">
<h3 title="Named Areas: the grid-template-areas property">7.3. 有名~区画： `grid-template-areas^p ~prop</h3>

◎名 `grid-template-areas@p
◎値
`~none1$v | `string$t+
◎初 `~none1$v
◎適 `格子~容器$
◎継 されない
◎百 受容しない
◎算 
~keyword `~none1$v ／ 文字列たちが成す~list
◎
the keyword none or a list of string values
◎順 文法に従う
◎ア 離散的
◎表終

<p>
この~propは、
一連の
`有名~区画@
を指定する。
それらの`区画$は、
特定0の`格子~駒$には結付けられないが，
`格子~配置~prop$から名前を通して参照できるものになる。
`grid-template-areas$p ~propの構文は、
`格子$構造の可視化も供して，
`格子~容器$の全体的な~layoutを理解し易くする。
◎
This property specifies named grid areas, which are not associated with any particular grid item, but can be referenced from the grid-placement properties. The syntax of the grid-template-areas property also provides a visualization of the structure of the grid, making the overall layout of the grid container easier to understand.
</p>

<p>
各種 値の意味は：
◎
Values have the following meanings:
</p>

<dl class="valdef">
	<dt>`~none1@v</dt>
	<dd>
この~propからは、
`有名~区画$は定義されない
— したがって`明示的な格子$を成す筋も定義されない —
ことを指示する
（それでも、
明示的な格子~筋は［
`grid-template-columns$p ／ `grid-template-rows$p
］~propにより作成され得る）。
◎
Indicates that no named grid areas, and likewise no explicit grid tracks, are defined by this property (though explicit grid tracks could still be created by grid-template-columns or grid-template-rows).
</dd>

	<dd class="note">注記：
`明示的な格子$が無い下では、
どの［
~row／~col
］も
`暗黙的に生成-＠#implicit-grids$され，それらの~sizeは［
`grid-auto-rows$p ／ `grid-auto-columns$p
］~propから決定されることになる。
◎
Note: In the absence of an explicit grid any rows/columns will be implicitly generated, and their size will be determined by the grid-auto-rows and grid-auto-columns properties.
</dd>

	<dt id="valdef-grid-template-areas-string">`string$t+</dt>
	<dd>
~listされた各~文字列ごとに， 1 本の~rowが作成される。
各~文字列は、
次に従って構文解析した上で，その中の各 
`升~token@
— `有名~升~token$／`~null升~token$ —
が【出現した順に】 ~row内の 1 個の升に対応する。
各~升ごとに【各~row内の，同じ位置に在る升たちが成す集合ごとに】，対応する~colが作成される：
◎
A row is created for every separate string listed for the grid-template-areas property, and a column is created for each cell in the string, when parsed as follows:
</dd>
	<dd>
<p>
各~文字列は、
最長合致に基づいて，次に挙げる~tokenからなる~listに~token化されることになる：
</p>
		<ul class="switch">
			<li>
`識別子~符号位置$のみからなる並び
⇒
`有名~升~token@
を表現する。
その並びがそのまま名前を与える。
同じ名前を共有する`有名~升~token$たちが成す集合は、［
それらの~tokenに対応する`升$すべてに~spanする，
1 個の`有名~区画$
］を作成する。
</li>
			<li>
`.^l （ `002E^U `FULL STOP^cn ）のみからなる並び
⇒
`~null升~token@
を表現する。
それは，`格子~容器$内の無名~区画を表現する。
</li>
			<li>
`空白$のみからなる並び
⇒
何も表現しない
（~tokenは生産しない）。
</li>
			<li>
その他の文字のみからなる並び
⇒
`~trash~token@
を表現する。
これは、
構文~errorであり，宣言は無効になる。
</li>
		</ul>

<p class="note">注記：
`有名~升~token$は、
`ident$t 構文に合致しない升~名も生産し得る
— `1st 2nd 3rd^l を与えた場合など。
そのような区画を他の~propから名前で参照する際には、
~escapeを要する
— 例えば，名前 `1st^v の区画を参照するときは、
次の様に
⇒
<code class="css">`grid-row^p: `\31st^v;</code>
</p>
◎
Tokenize the string into a list of the following tokens, using longest-match semantics:
• A sequence of ident code points, representing a named cell token with a name consisting of its code points.
• A sequence of one or more "." (U+002E FULL STOP), representing a null cell token.
• A sequence of whitespace, representing nothing (do not produce a token).
• A sequence of any other characters, representing a trash token.
◎
Note: These rules can produce cell names that do not match the &lt;ident&gt; syntax, such as "1st 2nd 3rd", which requires escaping when referencing those areas by name in other properties, like grid-row: \31st; to reference the area named 1st.
• A null cell token represents an unnamed area in the grid container.
• A named cell token creates a named grid area with the same name. Multiple named cell tokens within and between rows create a single named grid area that spans the corresponding grid cells.
• A trash token is a syntax error, and makes the declaration invalid.
</dd>
	<dd>
<p>
すべての文字列は、［
1 個以上かつ互いに同じ個数
］の`升~token$を定義しなければならない
— さもなければ、
当の宣言は無効になる。
◎
All strings must define the same number of cell tokens (named cell tokens and/or null cell tokens), and at least one cell token, or else the declaration is invalid.＼
</dd>
	<dd>
<p>
`有名~区画$を成す`升$たちが［
単独の, 穴の無い矩形
］を形成していない場合、
当の宣言は無効になる。
◎
If a named grid area spans multiple grid cells, but those cells do not form a single filled-in rectangle, the declaration is invalid.
</p>

<p class="note">注記：
この~moduleの将来~versionでは、
矩形でない, あるいは単連結でない領域も許可され得る。
◎
Note: Non-rectangular or disconnected regions may be permitted in a future version of this module.
</p>
	</dd>
</dl>

<div class="example">
<p>
この例では、
`grid-template-areas$p ~propを利用して，~page~layoutを作成している。
そこでは、［
ヘッダ内容（ `head^c ）,
~navi用の内容（ `nav^c ）,
フッタ内容（ `foot^c ）,
メイン内容（ `main^c ）
］用の区画が定義されている。
その結果、
~templateからは，
4 個の`有名~区画$が伴われた，3 本の~rowと 2 本の~colが作成される。
`head^c 区画は、
格子の最初の~row全体に~spanする。
◎
In this example, the grid-template-areas property is used to create a page layout where areas are defined for header content (head), navigational content (nav), footer content (foot), and main content (main). Accordingly, the template creates three rows and two columns, with four named grid areas. The head area spans both columns and the first row of the grid.
</p>

<pre class="lang-css">
#grid {
  display: grid;
  grid-template-areas: "head head"
                       "nav  main"
                       "foot ...."
}
#grid &gt; header { grid-area: head; }
#grid &gt; nav    { grid-area: nav; }
#grid &gt; main   { grid-area: main; }
#grid &gt; footer { grid-area: foot; }
</pre>
</div>

			<section id="serialize-template">
<h4 title="Serialization Of Template Strings">7.3.1. ~template文字列の直列化</h4>

<p>
`grid-template-areas$p を成す `string$t の［
`指定d値$／`算出d値$
］を直列化するときは
⇒＃
各`~null升~token$は 1 個の `.^l （ `002E^U `FULL STOP^cn ）に直列化する ／
連続する`升~token$は 1 個の ` ^l （ `0020^U `SPACE^cn ）で分離する ／
他の`空白$は省く
◎
When serializing either the specified or computed value of a &lt;string&gt; value of grid-template-areas, each null cell token is serialized as a single "." (U+002E FULL STOP), and consecutive cell tokens are separated by a single space (U+0020 SPACE), with all other white space elided.
</p>

			</section>
			<section id="implicit-named-lines">
<h4 title="Implicitly-Assigned Line Names">7.3.2. 暗黙的にアテガわれる罫~名</h4>

<p>
`grid-template-areas$p ~propは、
~template内の各 `有名~区画$から
`暗黙的にアテガわれる罫~名@
を生成する
— `有名~区画$ %区画 の名前を %foo とするとき：
◎
The grid-template-areas property generates implicitly-assigned line names from the named grid areas in the template. For each named grid area foo, four implicitly-assigned line names are created:＼
</p>
<ul>
	<li>
%区画 の［
~row-始端／~col-始端
］罫は、
`<var>foo</var>-start^l
と命名される。
◎
two named foo-start, naming the row-start and column-start lines of the named grid area,＼
</li>
	<li>
%区画 の［
~row-終端／~col-終端
］罫は、
`<var>foo</var>-end^l
と命名される。
◎
and two named foo-end, naming the row-end and column-end lines of the named grid area.
</li>
</ul>

<p>
`暗黙的にアテガわれる罫~名$の挙動は、［
`grid-template-rows$p ／ `grid-template-columns$p
］の値に現れないことを除いて，他の`罫~名$と同様になる。
同じ名前の`明示的にアテガわれる罫~名$が定義されたとしても、
`暗黙的にアテガわれる罫~名$は，もう一つの罫に名前をアテガう。
◎
These implicitly-assigned line names behave just like any other line names, except that they do not appear in the value of grid-template-rows/grid-template-columns. Even if an explicitly-assigned line name with the same name is defined, the implicitly-assigned line names are just more lines with the same name.
</p>

			</section>
			<section id="implicit-named-areas">
<h4 title="Implicitly-Named Areas">7.3.3. 暗黙的に命名される区画</h4>

<p>
`有名~区画$は，［
それが生産する`暗黙的にアテガわれる罫~名$
］を介して参照されるので、
同じ形の名前
（ `<var>foo</var>-start^l ／ `<var>foo</var>-end^l ）
を`明示的にアテガわれる罫~名$として【！明示的に】追加することは、
実質的に`有名~区画$を作成するのと同じことになる。
そのような区画は
`暗黙的に命名された区画@
と称され、
`grid-template-areas$p の値には現れないが，
`格子~配置~prop$からは`参照できる＠#grid-placement-slot$ものになる。
【！とは言え、 `<var>foo</var>-start^l だけ明示的にアテガうなど， “不完全” なものもあるので、常に`有名~区画$と同等に扱えることにはならない。】
◎
Since a named grid area is referenced by the implicitly-assigned line names it produces, explicitly adding named lines of the same form (foo-start/foo-end) effectively creates a named grid area. Such implicitly-named areas do not appear in the value of grid-template-areas, but can still be referenced by the grid-placement properties.
</p>

			</section>
		</section>
		<section id="explicit-grid-shorthand">
<h3 title="Explicit Grid Shorthand: the grid-template property">7.4. 明示的な格子： `grid-template^p 略式~prop</h3>

◎名 `grid-template@p
◎値
<span style="white-space:pre-wrap;"
>`none$v
| [ `grid-template-rows$tp / `grid-template-columns$tp ]
| [ `line-names$t? `string$t `track-size$t? `line-names$t? ]+ [ / `explicit-track-list$t ]?
</span>
◎初 `none^v
◎適 `格子~容器$
◎継 個々の~propを見よ
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎順 文法に従う
◎ア 個々の~propを見よ
◎表終

<p>
`grid-template$p ~propは、［
`grid-template-rows$p,
`grid-template-columns$p,
`grid-template-areas$p
］を，単独の宣言で一括して設定するための`略式~prop$である。
この`略式~prop$の構文は，いくつかの異なる形をとる：
◎
The grid-template property is a shorthand for setting grid-template-columns, grid-template-rows, and grid-template-areas in a single declaration. It has several distinct syntax forms:
</p>

<dl class="valdef">
	<dt>`none@v</dt>
	<dd>
すべての下位propを，各自の初期~値（ `none^v ）に設定する。
◎
Sets all three properties to their initial values (none).
</dd>

	<dt id="grid-template-rowcol">`grid-template-rows$tp / `grid-template-columns$tp</dt>
	<dd>
順に，［
`grid-template-rows$p, `grid-template-columns$p
］を指定された値に設定し、
`grid-template-areas$p は `none^v に設定する。
◎
Sets grid-template-rows and grid-template-columns to the specified values, respectively, and sets grid-template-areas to none.
</dd>
	<dd class="example">
<p>
次のものは：
</p>

<pre class="lang-css">
grid-template: auto 1fr / auto 1fr auto;
</pre>

<p>
次と等価になる：
◎
is equivalent to
</p>

<pre class="lang-css">
grid-template-rows: auto 1fr;
grid-template-columns: auto 1fr auto;
grid-template-areas: none;
</pre>

	</dd>

	<dt id="grid-template-ascii">[ `line-names$t? `string$t `track-size$t? `line-names$t? ]+ [ / `explicit-track-list$t ]?</dt>
	<dd>
		<ul>
			<li>
`grid-template-areas$p を，［
~listされている文字列（ `string^t ）の並び
］に設定する。
◎
Sets grid-template-areas to the strings listed.
</li>
			<li>
`grid-template-rows$p を，次を順に施した結果に設定する
⇒＃
`string^t すべてを値から取り除く；
`explicit-track-list^t が在れば直前の~slashとともに値から取り除く；
`track-size^t が抜けている所には `auto$vt を補う；
2 個の `track-size^t に挟まれた連続する 2 個の `line-names^t は， 1 つに継ぎ合せる
◎
Sets grid-template-rows to the &lt;track-size&gt;s following each string (filling in auto for any missing sizes), and splicing in the named lines defined before/after each size.
</li>
			<li>
`grid-template-columns$p を，
（~slashの後の）筋~list（ `explicit-track-list^t ）が指定されて［
いれば それ ／
いなければ `none$vt
］に設定する。
◎
Sets grid-template-columns to the track listing specified after the slash (or none, if not specified).
</li>
		</ul>
	</dd>

	<dd>
この構文は、［
~codeの中で、
一連の筋~名と~sizeを，それぞれに対応する区画に揃えて記せる
］よう設計されている。
◎
This syntax allows the author to align track names and sizes inline with their respective grid areas.
</dd>
	<dd class="example">
<p>
次のものは：
</p>

<pre class="lang-css">
grid-template:
    [header-top] "a   a   a"       [header-bottom]
      [main-top] "b   b   b"   1fr [main-bottom]
              / auto 1fr auto;
</pre>

<p>
次と等価になる：
◎
is equivalent to
</p>

<pre class="lang-css">
grid-template-areas:
                 "a   a   a"
                 "b   b   b";
grid-template-rows:
    [header-top]              auto [header-bottom
       main-top]               1fr [main-bottom];
grid-template-columns:
                auto 1fr auto;
</pre>

<p>
したがって、
次のような格子を作成する：
◎
and creates the following grid:
</p>

<figure>
<ul class="alt" hidden id="_dgm-grid-shorthand">
	<li>
3 本の~colがあり、
順に `auto$vt, `1fr^v, `auto$vt で~sizeされている。
◎
Three columns, sized auto, 1fr, and auto, respectively
</li>
	<li>
2 本の~rowがあり、
順に `auto$vt, `1fr^v で~sizeされている。
◎
Two rows sized as auto and 1fr, respectively.
</li>
	<li>
上端には 2 個の名前 `header-top^v, `a-start^v を伴う罫がある。
◎
A line named both “header-top” and “a-start” at the top,＼
</li>
	<li>
中段には 4 個の名前 `header-bottom^v, `main-top^v, `a-end^v, `b-start^v を伴う罫がある。
◎
a line with four names—“header-bottom”, “main-top”, “a-end”, and “b-start”—in the middle,＼
</li>
	<li>
下端には 2 個の名前 `main-bottom^v, `b-end^v を伴う罫がある
◎
a line named “main-bottom” and “b-end” at the bottom.
</li>
	<li>
左端~辺には 2 個の名前 `a-start^v, `b-start^v を伴う罫がある。
◎
A line named “a-start” and “b-start” on the left edge, and＼
</li>
	<li>
右端~辺には 2 個の名前 `a-end^v, `b-end^v を伴う罫がある。
◎
a line named “a-end” and “b-end” on the right edge.
</li>
</ul>
<figcaption>
上の宣言により作成される格子。
（ `*-start^c ／ `*-end^c は、
`有名~区画$により`暗黙的にアテガわれる罫~名$。）
◎
The grid created by the declarations above. (The “a/b-start/end” names are implicitly assigned by the named grid areas.)
</figcaption></figure>
	</dd>
	<dd class="note">注記：
`repeat$f 関数は，これらの筋~listには許容されない
— 各~筋と, “~ASCII-art” 内の各 “筋rc” とは、
視覚的に一対一に~~揃うよう意図されているので。
◎
Note: Note that the repeat() function isn’t allowed in these track listings, as the tracks are intended to visually line up one-to-one with the rows/columns in the “ASCII art”.
</dd>
</dl>

<p class="note">注記：
`grid$p 略式~propも同じ構文を受容する
— それは、
暗黙的な格子~propも，各自の初期~値に設定し直す。
したがって作者には、
これらを別々に~cascadeさせたいときは別として，
`grid-template$p よりも `grid$p を利用することが推奨される。
◎
Note: The grid shorthand accepts the same syntax, but also resets the implicit grid properties to their initial values. Unless authors want those to cascade in separately, it is therefore recommended to use grid instead of grid-template.
</p>

		</section>
		<section id="implicit-grids">
<h3 title="The Implicit Grid">7.5. 暗黙的な格子</h3>

<p>
［
`grid-template-rows$p ／ `grid-template-columns$p ／ `grid-template-areas$p
］~propは、
`明示的な格子$を形成する，固定d本数の筋を定義する。
その限界域の外側に`格子~駒$が位置された場合、
`格子~容器$は，`格子$に
`暗黙的な罫@
を追加して，
`暗黙的な筋@
を生成する。
これらの罫は、
`明示的な格子$と共に
`暗黙的な格子@
を形成するようになる
【特に、暗黙的な格子は，明示的な格子を包含する】
。
［
`grid-auto-rows$p ／ `grid-auto-columns$p
］~propは、
これらの`暗黙的な筋$, および［
`grid-template-areas$p により作成された`明示的な筋$のうち［
`grid-template-rows$p ／ `grid-template-columns$p
］により明示的に~sizeされていないもの
］を~sizeする。
◎
The grid-template-rows, grid-template-columns, and grid-template-areas properties define a fixed number of tracks that form the explicit grid. When grid items are positioned outside of these bounds, the grid container generates implicit grid tracks by adding implicit grid lines to the grid. These lines together with the explicit grid form the implicit grid. The grid-auto-rows and grid-auto-columns properties size these implicit grid tracks, as well as any explicit grid tracks created by grid-template-areas but not explicitly sized by grid-template-rows or grid-template-columns
</p>

<p>
`grid-auto-flow$p ~propは、
明示的な位置を伴わない`格子~駒$の自動-配置を制御する。
暗黙的な筋は、
`明示的な格子$が埋められた後に，自動-配置により生成される。
◎
The grid-auto-flow property controls auto-placement of grid items without an explicit position. 	Once the explicit grid is filled (or if there is no explicit grid) auto-placement will also cause the generation of implicit grid tracks.
</p>

<p>
`grid$p `略式~prop$は、
各種 `明示的な格子~prop$に加えて， 3 つの
`暗黙的な格子~prop@
— `grid-auto-flow$p, `grid-auto-rows$p, `grid-auto-columns$p —
も単独の宣言で設定できる。
◎
The grid shorthand property can set the implicit grid properties (grid-auto-flow, grid-auto-rows, and grid-auto-columns) together with the explicit grid properties in a single declaration.
</p>

		</section>
		<section id="auto-tracks">
<h3 title="Implicit Track Sizing: the grid-auto-rows and grid-auto-columns properties">7.6. 暗黙的な筋の~sizing： `grid-auto-rows^p ／ `grid-auto-columns^p ~prop</h3>

◎名 `grid-auto-columns@p, `grid-auto-rows@p
◎値 `track-size$t+
◎初 `auto^v
◎適 `格子~容器$
◎継 されない
◎百 `§ 筋の~sizing＠#track-sizing$を見よ
◎算 `§ 筋の~sizing＠#track-sizing$を見よ
◎順 文法に従う
◎ア 
互いの~listの長さが合致する場合、
各~itemごとに算出d値の型による／
他の場合は離散的
◎
if the list lengths match, by computed value type per item; discrete otherwise 
◎表終

<p>
［
`grid-auto-columns$p ／ `grid-auto-rows$p
］~propは、［
`grid-template-rows$p ／ `grid-template-columns$p
］により~sizeがアテガわれなかった`筋$の~sizeを指定する。
そのような筋のうち，明示的に~sizeされたものより［
後に在るもの／前に在るもの
］は、
指定された各~size（ `track-size$t ）を［
最初の筋から順に，そのままの順に／
最後の筋から順に，最後から逆順に
］受取る。
~sizeの個数が足りない場合は、
必要yなだけ~patternが繰返される。
【例えば 1 個だけ指定された場合、どの暗黙的な筋も同じ~sizeを受取ることになる。】
◎
The grid-auto-columns and grid-auto-rows properties specify the size of tracks not assigned a size by grid-template-rows or grid-template-columns. If multiple track sizes are given, the pattern is repeated as necessary to find the size of the affected tracks. The first track after the last explicitly-sized track receives the first specified size, and so on forwards; and the last implicit grid track before the explicit grid receives the last specified size, and so on backwards.
</p>

<p class="note">注記：
`格子~駒$が［
`grid-template-rows$p ／ `grid-template-columns$p ／ `grid-template-areas$p
］にて明示的に宣言されていない筋rcの中へ位置される場合、
それを保持するための`暗黙的な筋$が作成される。
これが起こり得るのは、［
駒が，明示的に範囲~外の筋rcの中へ位置された
］とき, あるいは［
`自動-配置~algo$により，追加的な筋rcが作成された
］ときである。
◎
Note: If a grid item is positioned into a row or column that is not explicitly declared by grid-template-rows/grid-template-columns and/or grid-template-areas, implicit grid tracks are created to hold it. This can happen either by explicitly positioning into a row or column that is out of range, or by the auto-placement algorithm creating additional rows or columns.
</p>

<div class="example">
<pre class="lang-html">
&lt;style&gt;
  #grid {
    display: grid;
    grid-template-columns: 20px;
    grid-auto-columns: 40px;
    grid-template-rows: 20px;
    grid-auto-rows: 40px;
  }
  #A { grid-column: 1; grid-row: 1; }
  #B { grid-column: 2; grid-row: 1; }
  #C { grid-column: 1; grid-row: 2; }
  #D { grid-column: 2; grid-row: 2; }
&lt;/style&gt;

&lt;div id="grid"&gt;
  &lt;div id="A"&gt;A&lt;/div&gt;
  &lt;div id="B"&gt;B&lt;/div&gt;
  &lt;div id="C"&gt;C&lt;/div&gt;
  &lt;div id="D"&gt;D&lt;/div&gt;
&lt;/div&gt;
</pre>

<figure>
<figcaption id="_dgm-auto-flow">
2 × 2 格子には、［
1 本目の~row × 1 本目の~col
］内に［
1 個の明示的な 20px × 20px の格子~升
］を伴うことに加え，
3 個の升も伴う。
これら 3 個の升は、［
追加的な格子~駒を保持するため，暗黙的~な 40px 幅の~col, ~rowが生成される
］結果，追加される。
◎
A 2×2 grid with one explicit 20px×20px grid cell in the first row+column and three additional cells resulting from the implicit 40px column and row generated to hold the additional grid items.
</figcaption>
</figure>
</div>

		</section>
		<section id="grid-auto-flow-property">
<h3 title="Automatic Placement: the grid-auto-flow property">7.7. 自動-配置： `grid-auto-flow^p ~prop</h3>

◎名 `grid-auto-flow@p
◎値 [ `row$v | `column$v ] || `dense$v
◎初 `row$v
◎適 `格子~容器$
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎表終

<p>
明示的に配置されていない`格子~駒$は、
後述する`自動-配置~algo$により，
`格子~容器$の中の`未占有$な空間へ自動的に配置される。
`grid-auto-flow$p が、
自動-配置された駒を格子の中へ~flowさせる正確な方法を指定する
— すなわち、
`自動-配置~algo$が どう働くかを制御する。
◎
Grid items that aren’t explicitly placed are automatically placed into an unoccupied space in the grid container by the auto-placement algorithm. grid-auto-flow controls how the auto-placement algorithm works, specifying exactly how auto-placed items get flowed into the grid. See § 8.5 Grid Item Placement Algorithm for details on precisely how the auto-placement algorithm works.
</p>

<dl class="valdef">
	<dt>`row@v</dt>
	<dd>
各~駒は、
`自動-配置~algo$により［
各~rowが埋まる度に，必要yなだけ新たな~rowを追加しながら
］置かれていく。
`row$v も `column$v も供されなかった場合、
`row^v と見做される。
◎
The auto-placement algorithm places items by filling each row in turn, adding new rows as necessary. If neither row nor column is provided, row is assumed.
</dd>

	<dt>`column@v</dt>
	<dd>
各~駒は、
`自動-配置~algo$により［
各~colが埋まる度に，必要yなだけ新たな~colを追加しながら
］置かれていく。
◎
The auto-placement algorithm places items by filling each column in turn, adding new columns as necessary.
</dd>

	<dt>`dense@v</dt>
	<dd>
指定された場合、
自動-配置~algoでは， “稠密な” 収納-法~algoが利用される：
それは、
後続の小さい駒により，大きい駒で埋められなかった格子の “穴埋め” を試みる。
そのため、
駒は順番どおりに現れなくなり得る。
◎
If specified, the auto-placement algorithm uses a “dense” packing algorithm, which attempts to fill in holes earlier in the grid if smaller items come up later. This may cause items to appear out-of-order, when doing so would fill in holes left by larger items.
</dd>
	<dd>
省略された場合、
“疎な” ~algoが利用される：
自動-配置~algoは、
格子~内に駒を配置していくときに “前に” しか進まず、
決して，後戻りして穴埋めすることはない。
これは、
自動-配置されるすべての駒が
— 後続の駒で埋めれるような “穴” が残されていても —
“順番どおりに” 現れるようにする。
◎
If omitted, a “sparse” algorithm is used, where the placement algorithm only ever moves “forward” in the grid when placing items, never backtracking to fill holes. This ensures that all of the auto-placed items appear “in order”, even if this leaves holes that could have been filled by later items.
</dd>
</dl>

<p class="note">注記：
この~moduleの将来~levelにおいては、［
自動-位置された駒を単独の “既定の” 升の中へまとめて~flowさせる
］ような値の追加-が予期されている。
◎
Note: A future level of this module is expected to add a value that flows auto-positioned items together into a single “default” cell.
</p>

<p>
自動-配置では、
`order$p により`改変された文書~順序$で`格子~駒$を並べる。
◎
Auto-placement takes grid items in order-modified document order.
</p>

<div class="example">
<p>
次の例では、
3 本の~colのいずれも，その内容に自動-~sizeされている。
明示的に定義される~rowは無い。
`grid-auto-flow$p ~propは `row$v なので、
格子の 1 本目の~rowから順に，必要に応じて［
自動-配置される`格子~駒$を収容する空間に足る分の~row
］を追加しながら、
各~rowごとに 3 本の~colが探索される。
◎
In the following example, there are three columns, each auto-sized to their contents. No rows are explicitly defined. The grid-auto-flow property is row which instructs the grid to search across its three columns starting with the first row, then the next, adding rows as needed until sufficient space is located to accommodate the position of any auto-placed grid item.
</p>

<figure class="figure">`auto-placed-form^dgm
<figcaption>
自動的な配置を利用する~form：
◎
A form arranged using automatic placement.
</figcaption></figure>

<pre class="lang-css">
form {
  display: grid;
  /* <span class="comment">
3 本の~colを定義する。
どれも内容から~sizeされ，対応する各~罫には名前が付与される。
◎
Define three columns, all content-sized, and name the corresponding lines.
</span>*/
  grid-template-columns:
      [labels] auto [controls] auto [oversized] auto;
  grid-auto-flow: row dense;
}
form &gt; label {
  /* <span class="comment">
次に可用な~rowを自動的に見出しながら，すべての~labelを 名前 `labels^l の~colに配置する。
◎
Place all labels in the "labels" column and automatically find the next available row.
</span>*/
  grid-column: labels;
  grid-row: auto;
}
form &gt; input, form &gt; select {
  /* <span class="comment">
次に可用な~rowを自動的に見出しながら，すべての~controlを 名前 `controls^l の~colに配置する。
◎
Place all controls in the "controls" column and automatically find the next available row.
</span>*/
  grid-column: controls;
  grid-row: auto;
}

#department-block {
  /* <span class="comment">
この駒を 1 本目の~row内の名前 `oversized^l の~colに自動-配置する。
駒が配置される 3 本の~rowに~spanする区画は、
他の明示的に配置される駒や区画,
あるいは，この区画に先立って自動的に配置されたどの駒とも、
重合しない。
◎
Auto place this item in the "oversized" column in the first row where an area that spans three rows won’t overlap other explicitly placed items or areas or any items automatically placed prior to this area.
</span>*/
  grid-column: oversized;
  grid-row: span 3;
}

/* <span class="comment">
~formのすべての~buttonを，明示的に定義された区画~内に配置する。
◎
Place all the buttons of the form in the explicitly defined grid area.
</span>*/
#buttons {
  grid-row: auto;

  /* <span class="comment">
~button区画を行内~軸~全体に~spanさせる。
◎
Ensure the button area spans the entire grid element in the inline axis.
</span>*/
  grid-column: 1 / -1;
  text-align: end;
}
</pre>

<pre class="lang-html">
&lt;form&gt;
  &lt;label for="姓"&gt;氏名（姓）&lt;/label&gt;
  &lt;input type="text" id="姓" name="name1"&gt;
  &lt;label for="名"&gt;氏名（名）&lt;/label&gt;
  &lt;input type="text" id="名" name="name2"&gt;
  &lt;label for="郵"&gt;〒郵便番号&lt;/label&gt;
  &lt;input type="text" id="郵" name="zip"&gt;
  &lt;label for="県"&gt;都道府県&lt;/label&gt;
  &lt;select type="text" id="県" name="fuken"&gt;
    &lt;option value="東京"&gt;東京都&lt;/option&gt;
  &lt;/select&gt;
  &lt;label for="市区番"&gt;市区町村・番地&lt;/label&gt;
  &lt;input type="text" id="市区番" name="address1"&gt;
  &lt;label for="号室"&gt;建物名・号室&lt;/label&gt;
  &lt;input type="text" id="号室" name="address2"&gt;

  &lt;div id="department-block"&gt;
    &lt;label for="科"&gt;所属科&lt;/label&gt;
    &lt;select id="科" name="department" multiple&gt;
      &lt;option value="あ"&gt;あっち系&lt;/option&gt;
      &lt;option value="そ"&gt;そっち系&lt;/option&gt;
      &lt;option value="こ"&gt;こっち系&lt;/option&gt;
      &lt;option value="に"&gt;にっち系&lt;/option&gt;
    &lt;/select&gt;
  &lt;/div&gt;

  &lt;div id="buttons"&gt;
    &lt;button id="cancel"&gt;取り消し&lt;/button&gt;
    &lt;button id="back"&gt;戻る&lt;/button&gt;
    &lt;button id="next"&gt;次へ&lt;/button&gt;
  &lt;/div&gt;
&lt;/form&gt;
</pre>
</div>

		</section>
		<section id="grid-shorthand">
<h3 title="Grid Definition Shorthand: the grid property">7.8. 格子~定義： `grid^p 略式~prop</h3>

◎名 `grid@p
◎値
<span style="white-space:pre-wrap;"
>`grid-template$tp
| `grid-template-rows$tp / [ `auto-flow^v &amp;&amp; `dense$v? ] `grid-auto-columns$tp?
| [ `auto-flow^v &amp;&amp; `dense$v? ] `grid-auto-rows$tp? / `grid-template-columns$tp
</span>

◎初 `none^v
◎適 `格子~容器$
◎継 個々の~propを見よ
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎順 文法に従う
◎ア 個々の~propを見よ
◎表終

<p>
`grid$p ~propは、
各種［
`明示的な格子~prop$, `暗黙的な格子~prop$
］すべてを単独の宣言で一括して設定するための`略式~prop$である
（これは、
`側溝$~propを設定し直すことはない）。
◎
The grid property is a shorthand that sets all of the explicit grid properties (grid-template-rows, grid-template-columns, and grid-template-areas), and all the implicit grid properties (grid-auto-rows, grid-auto-columns, and grid-auto-flow), in a single declaration. (It does not reset the gutter properties.)
</p>

<p>
その構文は、
`grid-template$p の構文に［
自動~flowによる格子を定義する形を成す構文
］を追加したものになる：
◎
Its syntax matches grid-template, plus an additional syntax form for defining auto-flow grids:
</p>

<dl class="valdef">
	<dt>`grid-template$tp</dt>
	<dd>
`grid-template$p の各~下位propを `grid-template$p と同じように設定する。
各 `grid-auto-*^p 下位propを それらの初期~値に設定する。
◎
Sets the grid-template longhands as as for grid-template, and the grid-auto-* longhands to their initial values.
</dd>
	<dt id="grid-s-auto-row">`grid-template-rows$tp / [ `auto-flow^v && `dense$v? ] `grid-auto-columns$tp?</dt>
	<dt id="grid-s-auto-column">[ `auto-flow^v && `dense$v? ] `grid-auto-rows$tp? / `grid-template-columns$tp</dt>
	<dd>
いずれも、
一方の軸の筋たちは 明示的に設定する
（ `grid-template-rows$p, `grid-template-columns$p
のうち一方は指定されたとおりに, 他方は `none^v に設定する）
一方で，他方の軸の筋たちは 自動で繰返す方法を指定する
（ `grid-auto-rows$p, `grid-auto-columns$p
のうち一方を指定されたとおりに, 他方は `none^v に設定する）
ことにより、
自動~flowを設定する。
`grid-auto-flow$p も，指定されたとおりに
（ `row$v または `column$v に, および `dense$v が指定されていれば それも）
設定する。
◎
Sets up auto-flow, by setting the tracks in one axis explicitly (setting either grid-template-rows or grid-template-columns as specified, and setting the other to none), and specifying how to auto-repeat the tracks in the other axis (setting either grid-auto-rows or grid-auto-columns as specified, and setting the other to auto). grid-auto-flow is also set to either row or column accordingly, with dense if it’s specified.
</dd>
	<dd>
他のすべての`下位prop$は、
各自の初期~値に設定する。
◎
All other grid sub-properties are reset to their initial values.
</dd>
</dl>

<p class="note">注記：
単独の `grid$p 宣言で指定できるのは、
各種［
明示的 ／ 暗黙的
］な格子~propのうち，片方の軸に限られる。
指定しなかった下位propは、
通常の略式~propと同じく，初期~値に設定される。
◎
Note: Note that you can only specify the explicit or the implicit grid properties in a single grid declaration. The sub-properties you don’t specify are set to their initial value, as normal for shorthands.
</p>

<div class="example">
<p>
［
明示的な格子を設定しておくための `grid-template$p 略式~propの構文
］を受容することに加えて、
`grid$p 略式~propでは，［
自動-整形される格子~用の~parameter群
］も容易に設定しておける。
例えば
<samp class="css">`grid$p: `auto-flow 1fr / 100px^v;</samp>
は、
次と等価になる：
◎
In addition to accepting the grid-template shorthand syntax for setting up the explicit grid, the grid shorthand can also easily set up parameters for an auto-formatted grid. For example, grid: auto-flow 1fr / 100px; is equivalent to
</p>

<pre class="lang-css">
grid-template: none / 100px;
grid-auto-flow: row;
grid-auto-rows: 1fr;
grid-auto-columns: auto;
</pre>

<p>
同様に
<samp class="css">`grid$p: `none / auto-flow 1fr^v</samp>
は、
次と等価になる：
◎
Similarly, grid: none / auto-flow 1fr is equivalent to
</p>

<pre class="lang-css">
grid-template: none;
grid-auto-flow: column;
grid-auto-rows: auto;
grid-auto-columns: 1fr;
</pre>
</div>

<p>
直列化するときは、［
すべての `grid-auto-*^p 下位propが各自の初期~値をとる場合
］には，
`grid-template$p 構文が利用される。
◎
When serializing, if all the grid-auto-* longhands have their initial values, the grid-template syntax is used.
</p>

		</section>
	</section>
	<section id="placement">
<h2 title="Placing Grid Items">8. 格子~駒の配置-法</h2>

<p>
どの`格子~駒$にも、
それが占めることになる［
互いに接する, かつ矩形を成すような，`升$たちが成す集合
］からなる`区画$が結付けられる。
この`区画$は、
当の駒の`包含塊$を定義する
— その中における駒の実際の位置は，駒の`自己-整列~prop$から決定される。
`格子~駒$が占める一連の升は、［
`§ 格子~layout~algo$にて定義される，筋rcの~sizing
］にも波及する。
◎
Every grid item is associated with a grid area, a rectangular set of adjacent grid cells that the grid item occupies. This grid area defines the containing block for the grid item within which the self-alignment properties (justify-self and align-self) determine their actual position. The cells that a grid item occupies also influence the sizing of the grid’s rows and columns, defined in § 12 Grid Layout Algorithm.

in § 12 Grid Sizing.
</p>

<p>
`格子~駒$ %駒 が`格子$内を占める`区画$の所在は、
%駒 の
`配置@
により定義される
— それは、
各~軸ごとに次に挙げるものからなる：
◎
The location of a grid item’s grid area within the grid is defined by its placement, which consists of a grid position and a grid span:
</p>

<dl class="def-list">
	<dt>
`位置@
（ `grid position^en ）
◎
grid position
</dt>
	<dd>
<p>
%駒 の所在
【具体的には，区画を囲う各~罫の~index】
を与える
— それは：
</p>
		<ul>
			<li>
明示的に指定された場合、
`確定的@pos
とされる。
</li>
			<li>
`自動-配置$から決定される場合、
`自動的@pos
とされる。
</li>
		</ul>
◎
The grid item’s location in the grid in each axis. A grid position can be either definite (explicitly specified) or automatic (determined by auto-placement).
</dd>

	<dt>
`~span数@
（ `grid span^en ／ 略して `span^en ）
◎
grid span
</dt>
	<dd>
<p>
%駒 が占める`筋$の本数を与える
— `~span数$は、
%駒 の当の軸における`格子~配置~prop$［
`*-start^p, `*-end^p
］の値に応じて：
◎
How many grid tracks the grid item occupies in each axis.＼
↓The grid span in an axis can be implicit, explicit, or automatic:
</p>
		<ul>
			<li>
次の場合、
`暗黙的@span
とされる
⇒
どちらの値も、
ある罫を指定している
◎
If both the *-start and *-end values of its grid-placement properties specify a line, its grid span is implicit.
</li>
			<li>
次の場合、
`明示的@span
とされる
⇒
どちらかの値は、
`span$v を明示的に伴う
◎
If it has an explicit span value, its grid span is explicit.
</li>
			<li>
<p>
他の場合、
`自動的@span
とされる
— この場合、
`~span数$は：
</p>
				<ul>
					<li>
当の軸は`下位格子~化$されている場合、
%駒 の `line-name-list$t から`決定される＠#subgrid-span$。
</li>
					<li>
他の場合、
1 になる。
</li>
				</ul>
◎
Otherwise, its grid span is automatic: if it is subgridded in that axis, its grid span is determined from its &lt;line-name-list&gt;; otherwise its grid span is 1.
</li>
		</ul>
	</dd>
</dl>

<p>
`格子~配置~prop@
— 下位prop［
`grid-row-start$p,
`grid-row-end$p,
`grid-column-start$p,
`grid-column-end$p
］と, それらに対応する略式~prop［
`grid-row$p,
`grid-column$p,
`grid-area$p
］ —
は、
次の 6 個の情報~片を供する。
作者は、
これらを用いて`格子~駒$の`配置$を指定できる：
◎
The grid-placement properties—the longhands grid-row-start, grid-row-end, grid-column-start, grid-column-end, and their shorthands grid-row, grid-column, and grid-area—allow the author to specify a grid item’s placement by providing any (or none) of the following six pieces of information:
</p>

<div>
<table><thead>
<tr><td>
<th>~row
<th>~col
<tbody>

<tr><th>%始端
<td>`~row-始端 罫@
<td>`~col-始端 罫@

<tr><th>%終端
<td>`~row-終端 罫@
<td>`~col-終端 罫@

<tr><th>%~span
<td>~row~span
<td>~col~span
</table>

◎
｜Row｜Column
Start｜row-start line｜column-start line
End｜row-end line｜column-end line
Span｜row span｜column span 
</div>

<p id="_explicit-or-implicit">
所与の次元において、［
%始端,
%終端,
%~span
］のうち，どれか 2 個の値が確定的ならば、
残りの値も確定的になる。
◎
A definite value for any two of Start, End, and Span in a given dimension implies a definite value for the third.
</p>

		<section id="common-uses">
<h3 title="Common Patterns for Grid Placement">8.1. 格子~配置~用の共通な~pattern</h3>

◎非規範的

<p>
`格子~配置~prop$の下位propは、
3 個の`略式~prop$に整理される：
◎
The grid-placement property longhands are organized into three shorthands:
</p>

<table class="data" id="grid-property-breakdown"><tbody>
<tr><td colspan="4">`grid-area$p

<tr><td colspan="2">`grid-column$p
<td colspan="2">`grid-row$p

<tr><td>`grid-column-start$p
<td>`grid-column-end$p
<td>`grid-row-start$p
<td>`grid-row-end$p
</table>

			<section id="common-uses-named-areas">
<h4 title="Named Areas">8.1.1. 有名~区画</h4>

<p>
駒は、
`grid-area$p にて区画~名を指定することにより，`有名~区画$
（ `grid-template-areas$p 内の~templateにより生産されるものなど）
の中へ配置できる：
◎
An item can be placed into a named grid area (such as those produced by the template in grid-template-areas) by specifying the area’s name in grid-area:
</p>

<div class="example">
<pre class="lang-css">
article {
  grid-area: main;
  /* <span class="comment">
駒を有名~区画 `main^l の中へ配置する。
◎
Places item into the named area "main".
</span>*/
}
</pre>
</div>

<p>
駒は、
そのある辺を，`有名~区画$に `部分的^emに
— すなわち，他の辺は他の罫に整列させながら —
整列させられる：
◎
An item can also be partially aligned with a named grid area, with other edges aligned to some other line:
</p>

<div class="example">
<pre class="lang-css">
.one {
  grid-row-start: main;
  /* <span class="comment">
~row-始端~辺を `main^l 有名~区画の始端~辺に整列させる。
◎
Align the row-start edge to the start edge of the "main" named area.
</span>*/
}
</pre>
</div>

			</section>
			<section id="common-uses-numeric">
<h4 title="Numeric Indexes and Spans">8.1.2. 数量-~indexと~span数</h4>

<p>
格子~駒の位置と~span数【！~size】は、
数で指定できる。
特に，~script駆動な~layoutにおいて役立つ：
◎
Grid items can be positioned and sized by number, which is particularly helpful for script-driven layouts:
</p>

<div class="example">
<pre class="lang-css">
.two {
  grid-row: 2;    /* <span class="comment">
駒を 2 本目の~row内に配置する。
◎
Place item in the second row.
</span>*/
  grid-column: 3; /* <span class="comment">
駒を 3 本目の~col内に配置する。
◎
Place item in the third column.
</span>*/
    /* <span class="comment">
<code class="css">`grid-area^p: `2 / 3^v;</code>
と等価。
◎
Equivalent to grid-area: 2 / 3;
</span>*/
}
</pre>
</div>

<p>
既定では、
格子~駒の~span数は 1 になる。
他の~span数を明示的に与えることもできる：
◎
By default, a grid item has a span of 1. Different spans can be given explicitly:
</p>

<div class="example">
<pre class="lang-css">
.three {
  `grid-row$p: 2 / span 5;
  /* <span class="comment">
2 本目の~rowが始端になり，そこから
5 本~先の~rowまで~spanする
（ 7 本目の~rowが終端になる）。
◎
Starts in the 2nd row, spans 5 rows down (ending in the 7th row).
</span>*/
}

.four {
  grid-row: span 5 / 7;
  /* <span class="comment">
7 本目の~rowが`終端になり^em，そこから
5 本~前の~rowまで~spanする
（ 2 本目の~rowが始端になる）。
◎
Ends in the 7th row, spans 5 rows up (starting in the 2nd row).
</span>*/
}
</pre>
</div>

<p class="note">注記：
格子~index【が表現する位置】は、
`書字~mode$に相対的になることに注意。
例えば，~Arabicのような右横書きの言語においては、
最初の~colは，最も右に来る。
◎
Note: Note that grid indexes are writing mode relative. For example, in a right-to-left language like Arabic, the first column is the rightmost column.
</p>

			</section>
			<section id="common-uses-named-lines">
<h4 title="Named Lines and Spans">8.1.3. 罫~名【！有名~罫】と~span数</h4>

<p>
罫は、
数による~indexに代えて，`罫~名$でも参照できる：
◎
Instead of counting lines by number, lines can be referenced by their line name:
</p>

<div class="example">
<pre class="lang-css">
.five {
  grid-column: first / middle;
  /* <span class="comment">
罫 `first^l から罫 `middle^l まで~spanする。
◎
Span from line "first" to line "middle".
</span>*/
}
</pre>
</div>

<p class="note">注記：
`有名~区画$が ある`罫~名$と同じ名前を有する場合、
配置~algoでは，`有名~区画$の罫が選好されることになる。
【！`暗黙的にアテガわれる罫~名$と`明示的にアテガわれる罫~名$が同じになる場合？】
【意図不明：該当する要件が見当たらない／はっきりしない。】
◎
Note: Note that if a named grid area has the same name as a line name, the placement algorithm will prefer to use named grid area’s lines instead.
</p>

<p>
同じ名前の罫が複数~在る場合、
それらは実質的に，それらの罫からなる【！有名~罫の】集合を確立する。
そのような名前による配置【！placement by name】は、
数量-~indexを付与して，排他的に絞り込める：
◎
If there are multiple lines of the same name, they effectively establish a named set of grid lines, which can be exclusively indexed by filtering the placement by name:
</p>

<div class="example">
<pre class="lang-css">
.six {
  grid-row: text 5 / text 7;
  /* <span class="comment">
名前 `text^l の罫のうち， 5 本目から 7 本目まで~spanする
◎
Span between the 5th and 7th lines named "text".
</span>*/
  grid-row: text 5 / span text 2;
  /* <span class="comment">
上と同じ
— 5 本目の名前 `text^l の罫から さらに `text^l 罫を 2 本， 7 本目まで~spanする。
◎
Same as above - start at the 5th line named "text", then span across two more "text" lines, to the 7th.
</span>*/
}
</pre>
</div>

			</section>
			<section id="common-uses-auto-placement">
<h4 title="Auto Placement">8.1.4. 自動-配置</h4>

<p>
`格子~駒$は、
次に来る可用な空な`升$に，自動的に配置させられる。
空間が残されていない場合は`格子$が占める域を拡幅させながら。
◎
A grid item can be automatically placed into the next available empty grid cell, growing the grid if there’s no space left.
</p>

<div class="example">
<pre class="lang-css">
.eight {
  grid-area: auto; /* <span class="comment">
初期~値
◎
Initial value
</span>*/
}
</pre>
</div>

<p>
例えばこれを、
多数の駒を格子~patternに並べる用途に利用できる。
◎
This can be used, for example, to list a number of sale items on a catalog site in a grid pattern.
</p>

<p>
明示的な~spanと組合せることで、
自動-配置の駒が複数~升を占めるようにもできる。
◎
Auto-placement can be combined with an explicit span, if the item should take up more than one cell:
</p>

<div class="example">
<pre class="lang-css">
.nine {
  grid-area: span 2 / span 3;
  /* <span class="comment">
駒は 2 × 3 本の ~row × ~colを覆うように自動-配置される。
◎
Auto-placed item, covering two rows and three columns.
</span>*/
}
</pre>
</div>

<p>
`自動-配置~algo$が
~row／~col
のいずれに対し，空な升を探索したり追加するかは、
`grid-auto-flow$p ~propにより制御される。
◎
Whether the auto-placement algorithm searches across and adds rows, or searches across and adds columns, is controlled by the grid-auto-flow property.
</p>

<p class="note">注記：
既定では、
`自動-配置~algo$は，
後戻りすることなく 順番に空かどうか調べていく。
より大きい駒を配置するために，空な空間を飛ばす必要が生じた場合、
その空な空間を埋めるために後戻りすることはない。
この挙動を変更するには、
`grid-auto-flow$p に `dense$v ~keywordを指定する。
◎
Note: By default, the auto-placement algorithm looks linearly through the grid without backtracking; if it has to skip some empty spaces to place a larger item, it will not return to fill those spaces. To change this behavior, specify the dense keyword in grid-auto-flow.
</p>

			</section>
		</section>
		<section id="placement-a11y">
<h3 title="Grid Item Placement vs. Source Order">8.2. 格子~駒の配置 vs. ~source順序</h3>

<blockquote>
“大いなる力には大いなる責任が伴う”
◎
“With great power comes great responsibility.”
</blockquote>

<p>
`格子~配置~prop$の能は、
内容を`格子$の中で並替えて自由に配列して、
視覚的な呈示を［
下層の文書~source順序から大きく違える
］ことも可能にする。
この能により，作者は、
例えば`媒体~query$を利用して，
異なる機器や~modeの下で呈示の描画を自由に誂えることも可能になる。
ただし、
<strong>これは，~sourceに対する正しい順序付けの代用ではない</strong>ことに注意。
◎
The abilities of the grid-placement properties allow content to be freely arranged and reordered within the grid, such that the visual presentation can be largely disjoint from the underlying document source order. These abilities allow the author great freedom in tailoring the rendering to different devices and modes of presentation e.g. using media queries. However they are not a substitute for correct source ordering.
</p>

<p>
正しい~source順序は、［
発話 ／
逐次的~navi（~keyboard~naviなど） ／
探索~engine ／
触覚~browser
］等々の非~CSS~UAにとって重要になる。
格子~配置は、
視覚的な呈示`のみに^em影響することに注意。
これにより，作者は、
文書~sourceを［
非~CSS ／ 視覚的でない対話~mode
］用に最適化しつつ、
格子~配置の技法を利用して，
~source順序に触れることなく視覚的な呈示を操作できるようになる。
◎
Correct source order is important for speech, for sequential navigation (such as keyboard navigation), and non-CSS UAs such as search engines, tactile browsers, etc. Grid placement only affects the visual presentation! This allows authors to optimize the document source for non-CSS/non-visual interaction modes, and use grid placement techniques to further manipulate the visual presentation so as to leave that source order intact.
</p>

		</section>
		<section id="line-placement">
<h3 title="Line-based Placement: the grid-row-start, grid-column-start, grid-row-end, and grid-column-end properties">8.3. 罫に基づく配置： `grid-row-start^p, `grid-column-start^p, `grid-row-end^p, `grid-column-end^p ~prop</h3>

◎名 `grid-row-start@p, `grid-column-start@p, `grid-row-end@p, `grid-column-end@p
◎値
`grid-line$t
◎初 `~autoP$v
◎適
`格子~駒$, および［
`絶対的に位置され$た~boxのうち，その`包含塊$は`格子~容器$であるもの
］
◎
grid items and absolutely-positioned boxes whose containing block is a grid container
◎継 されない
◎百 受容しない
◎算 指定された［
~keyword／識別子／整数
］または, これらの組み合わせ
◎
specified keyword, identifier, and/or integer
◎順 文法に従う
◎ア 離散的
◎表終

<pre class="prod">
`grid-line@t
	= `~autoP$v
	| `custom-ident$t
	| [ [ `integer [−∞,−1]$t | `integer [1,∞]$t ] &amp;&amp; `custom-ident$t? ]
	| [ `span^v &amp;&amp; [ `integer [1,∞]$t || `custom-ident$t ] ]
</pre>

<p>
［
`grid-row-start$p,
`grid-column-start$p,
`grid-row-end$p,
`grid-column-end$p
］~propは、
`格子$の中の`格子~駒$の`~span数$【！~size】と所在を決定する。
すなわち、
駒の`配置$に［
罫の位置や~span数についての情報を供与するか，何も供与しない（自動的に配置する）
］ことを通して，駒が置かれる`区画$は どの罫を［
`行内-始端$,
`塊-始端$,
`行内-終端$,
`塊-終端$
］辺とするかを指定する。
◎
The grid-row-start, grid-column-start, grid-row-end, and grid-column-end properties determine a grid item’s size and location within the grid by contributing a line, a span, or nothing (automatic) to its grid placement, thereby specifying the inline-start, block-start, inline-end, and block-end edges of its grid area.
</p>

<p>
各種 値の意味は：
◎
Values have the following meanings:
</p>

<dl class="valdef">
	<dt id="grid-placement-slot">`custom-ident$t</dt>
	<dd>
<p>
最初に、
`有名~区画$の辺に合致するかどうか試みる：
`custom-ident^t に与えられた名前 %foo が［
`grid-*-start^p ／ `grid-*-end^p
］~propに指定されていて，`罫~名$として［
`<var>foo</var>-start^l ／
`<var>foo</var>-end^l
］を有する`罫$は在るならば、
それらのうち最初の罫を`格子~駒$の`配置$に供与する。
◎
First attempt to match the grid area’s edge to a named grid area: if there is a grid line whose line name is &lt;custom-ident&gt;-start (for grid-*-start) / &lt;custom-ident&gt;-end (for grid-*-end), contributes the first such line to the grid item’s placement.
</p>

<p class="note">注記：
`有名~区画$は，この形の`暗黙的にアテガわれる罫~名$を自動的に生成するので、
<code class="css">`grid-row-start$p: %foo</code>
を指定すれば，
%foo と命名された`有名~区画$の始端~辺を選ぶことになる
— それより前【始端~側】に，
`明示的にアテガわれる罫~名$として同じ
`<var>foo</var>-start^l
を伴う罫は無いならば。
◎
Note: Named grid areas automatically generate implicitly-assigned line names of this form, so specifying grid-row-start: foo will choose the start edge of that named grid area (unless another line named foo-start was explicitly specified before it).
</p>
	</dd>
	<dd>
<p>
他の場合、
"`<var>foo</var>^v"
の代わりに
"`1 <var>foo</var>^v"
が指定されていたかのように扱う。
【次項で取扱われる。】
◎
Otherwise, treat this as if the integer 1 had been specified along with the &lt;custom-ident&gt;.
</p>

<p class="trans-note">【
%foo と命名された`有名~区画$がある下で，
<code class="css">`grid-row-start^p: `<var>foo</var>-start^v</code>
の様に接尾辞も含めて指定した場合、
`<var>foo</var>-start^l と（紛らわしく）命名された`有名~区画$が無い限り，これに該当する
— その結果は、
%foo を指定したときと同じになる。
】</p>

	</dd>
	<dd class="trans-note">【
`grid-*-start^p が供与する罫が
`grid-*-end^p が供与する罫と同じか より後に位置する場合に どうなるかは、
`§ 格子~配置における競合の取扱い＠#grid-placement-errors$にて述べられる
（以下も同様）。
】</dd>

	<dt id="grid-placement-int">[ `integer [−∞,−1]$t | `integer [1,∞]$t ] &amp;&amp; `custom-ident$t?</dt>
	<dd>
%N を `integer^t に与えられた整数とする。
`integer^t のみ与えられた場合、
%N 本目の`罫$を`格子~駒$の`配置$に供与する。
%N が負である場合、
`明示的な格子$の終端~辺から逆順に数える。
◎
Contributes the Nth grid line to the grid item’s placement. If a negative integer is given, it instead counts in reverse, starting from the end edge of the explicit grid.
</dd>
	<dd class="trans-note">【
%N ~EQ ［
1 ／ −1
］が`明示的な格子$の［
始端／終端
］罫に対応する。
結果の罫が`明示的な格子$の［
終端~辺／始端~辺
］を超える場合、
`暗黙的な罫$を供与することになる。
】</dd>
	<dd>
`custom-ident$t として`罫~名$も与えられた場合、
その名前を伴う罫に限り数えられる
（その名前を伴う`罫$のうち %N 本目を供与する）。
この目的においては、
`暗黙的な罫$は，すべて その名前を伴うものと見做される
（したがって，`明示的な格子$内の該当する罫の本数が %N に満たない場合、
`暗黙的な罫$を供与することになる）。
◎
If a name is given as a &lt;custom-ident&gt;, only lines with that name are counted. If not enough lines with that name exist, all implicit grid lines are assumed to have that name for the purpose of finding this position.
</dd>

	<dd>
`integer$t に対する値 0 は、
宣言を無効にする。
◎
An &lt;integer&gt; value of zero makes the declaration invalid.
</dd>

	<dt id="grid-placement-span-int">`span^v &amp;&amp; [ `integer [1,∞]$t || `custom-ident$t ]</dt>
	<dd>
%N を `integer^t に与えられた整数とする。
`integer^t のみ与えられた場合、
`~span数$として %N を`格子~駒$の`配置$に供与する。
すなわち、［
`格子~駒$が占める`区画$の，この~propに対応する辺
］を，その対辺†から %N 本目††の所に~~位置させる。
例えば
`grid-column-end$p に対する `span 2^v は、
`grid-column-start$p 罫から終端~方向に在る 2 本目の罫を指示する。
◎
Contributes a grid span to the grid item’s placement such that the corresponding edge of the grid item’s grid area is N lines from its opposite edge in the corresponding direction. For example, grid-column-end: span 2 indicates the second grid line in the endward direction from the grid-column-start line.
</dd>
	<dd class="trans-note">【†
対辺とは、
この~span数が `grid-row-end^p に指定されているならば，
`grid-row-start^p から指定される罫を指す
（ `-end^l と `-strat^l を入れ替えても，
あるいは `-row-^l を `-column-^l に置き換えても同様）。
したがって［
`grid-row-start^p, `grid-row-end^p
］の両者に この形による値が与えられた場合，定義が循環するが、
その場合の取扱いは
`§ 格子~配置における競合の取扱い＠#grid-placement-errors$にて述べられる。
】【††
対辺~自身は 0 本目。
例えば `span 2^v は “2 本の筋に~spanする” ことを表す。
】【
対辺が指定されていない場合（ `auto^v ）、
それが指す罫は，`自動-配置~algo$に従って決定される。
】</dd>
	<dd>
`custom-ident$t も与えられた場合、
その名前を伴う罫に限り数えられる
（そのような`罫$のうち %N 本目を指すことになる）。
この目的においては、
`暗黙的な罫$のうち［
`明示的な格子$の探索していく方向に対応する側に在るもの
］は，すべて その名前を伴うものと見做される
（したがって，`明示的な格子$内の該当する罫の本数が %N に満たない場合、
`暗黙的な罫$を指すことになる）。
◎
If a name is given as a &lt;custom-ident&gt;, only lines with that name are counted. If not enough lines with that name exist, all implicit grid lines on the side of the explicit grid corresponding to the search direction are assumed to have that name for the purpose of counting this span.
</dd>
	<dd class="trans-note">【
この事例でも、
対辺が指定されていない場合，駒は自動-配置されるが、
それに加え，~span数も 1 と見做される。
】</dd>

	<dd class="example">
<p>
例えば、
次の宣言が与えられた下では：
◎
For example, given the following declarations: 
</p>

<pre class="lang-css">
.grid { grid-template-columns: 100px; }
.griditem { grid-column: span foo / 4; }
</pre>

<p>
`格子~容器$（ `.grid^css ）には，`明示的にアテガわれる罫~名$は無く、
`明示的な格子$は 2 本の`罫$（罫 1, 罫 2 ）からなるとする。
`格子~駒$（ `.griditem^css ）の ~col-終端~辺は罫 4 の所に指定されるので、
`暗黙的な格子$の終端~側に 2 本の罫が生成される。
◎
The grid container has an explicit grid with two grid lines, numbered 1 and 2. The grid item’s column-end edge is specified to be at line 4, so two lines are generated in the endward side of the implicit grid.
</p>

<p>
その~col-始端~辺は，始端~方向に見出される最初の `foo^l 罫でなければナラナイが、
格子~内には `foo^l 罫は無いので，その罫は`暗黙的な格子$内にあることになる。
罫 3 はその候補でない
— それは，`明示的な格子$の終端~側にあり、
`grid-column-start$p に指定された `span$v は，該当する罫を始端~方向へ探索するよう強制しているので。
よって、
`明示的な格子$の始端~側に，`暗黙的な格子$用の罫が生成されることになる。
◎
Its column-start edge must be the first "foo" line it can find startward of that. There is no "foo" line in the grid, though, so the only possibility is a line in the implicit grid. Line 3 is not a candidate, because it’s on the endward side of the explicit grid, while the grid-column-start span forces it to search startward. So, the only option is for the implicit grid to generate a line on the startward side of the explicit grid.
</p>
<figure>
<figcaption id="_dgm-implicit-lines-search">
結果の説明図
（赤い罫／~textは暗黙的な格子に属する）。
◎
An illustration of the result.
</figcaption>
</figure>

	</dd>

	<dd>
`integer$t が省略された場合の既定は `1^v とする。
負な整数や 0 は無効になる。
◎
If the &lt;integer&gt; is omitted, it defaults to 1. Negative integers or zero are invalid.
</dd>

	<dt>`~autoP@v</dt>
	<dd>
~propは、
`格子~駒$の`配置$に何も供与しない。
すなわち、［
`自動-配置$ ／
既定の~span数 1 
］のいずれかにすることを指示する
（ `§ 格子~駒の配置-法＠#placement$を見よ）。
◎
The property contributes nothing to the grid item’s placement, indicating auto-placement or a default span of one. (See § 8 Placing Grid Items, above.)
</dd>
</dl>

<p>
上の どの生成規則の `custom-ident$t においても，~keyword
`span$v, `auto^v
は除外される。
◎
In all the above productions, the &lt;custom-ident&gt; additionally excludes the keywords span and auto.
</p>

<div class="example">
<p>
1 本の~rowと 8 本の~colを有する格子があり、
それを成す 9 本の~col罫は次のように命名されているとする【！9 本の有名~罫】：
◎
Given a single-row, 8-column grid and the following 9 named lines:
</p>

<pre class="presentation">
1  2  3  4  5  6  7  8  9
+--+--+--+--+--+--+--+--+
|  |  |  |  |  |  |  |  |
A  B  C  A  B  C  A  B  C
|  |  |  |  |  |  |  |  |
+--+--+--+--+--+--+--+--+
</pre>

<p>
このとき，次の各 宣言は、
格子~駒を~indexで指示される各~罫の合間に配置する：
◎
The following declarations place the grid item between the lines indicated by index:
</p>

<pre class="lang-css">
grid-column-start: 4; grid-column-end: auto;
/* <span class="comment">
罫 4 〜 罫 5
（ 5 = 4 + 既定の~span数）
◎
Line 4 to line 5
</span>*/

grid-column-start: auto; grid-column-end: 6;
/* <span class="comment">
罫 5 〜 罫 6
（ 5 = 6 − 既定の~span数）
◎
Line 5 to line 6
</span>*/

grid-column-start: C; grid-column-end: C -1;
/* <span class="comment">
罫 3 〜 罫 9
（ 3 = 始端~側から最初の `C^c, 9 = 終端~側から最初の `C^c ）
◎
Line 3 to line 9
</span>*/

grid-column-start: C; grid-column-end: span C;
/* <span class="comment">
罫 3 〜 罫 6
（ 6 = 3 から終端~方向に在る次の `C^c ）
◎
Line 3 to line 6
</span>*/

grid-column-start: span C; grid-column-end: C -1;
/* <span class="comment">
罫 6 〜 罫 9
（ 6 = 9 から始端~方向に在る次の `C^c ）
◎
Line 6 to line 9
</span>*/

grid-column-start: span C; grid-column-end: span C;
/* <span class="comment">
~error：
まず，始端, 終端とも `span$v を指定しているので、
終端に指定された~spanは無視される。
その結果、
駒は自動-配置され，命名された罫【！有名~罫】には~spanし得ない。
<code class="css">`grid-column$p: `span 1^v;</code>
と等価になる。
◎
Error: The end span is ignored, and an auto-placed item can’t span to a named line. Equivalent to grid-column: span 1;.
</span>*/

grid-column-start: 5; grid-column-end: C -1;
/* <span class="comment">
罫 5 〜 罫 9
◎
Line 5 to line 9
</span>*/

grid-column-start: 5; grid-column-end: span C;
/* <span class="comment">
罫 5 〜 罫 6
（ 6 = 5 から終端~方向に在る次の `C^c ）
◎
Line 5 to line 6
</span>*/

grid-column-start: 8; grid-column-end: 8;
/* <span class="comment">
~error：罫 8 〜 罫 9 になる
◎
Error: line 8 to line 9
</span>*/

grid-column-start: B 2; grid-column-end: span 1;
/* <span class="comment">
罫 5 〜 罫 6
（ 5 = 始端~側から 2 個目の `B^c, 6 = 5 + 1 ）
◎
Line 5 to line 6
</span>*/
</pre>
</div>

			<section id="grid-placement-errors">
<h4 title="Grid Placement Conflict Handling">8.3.1. 格子~配置における競合の取扱い</h4>

<p>
`駒$の`配置$が 2 本の罫を包含していて，
`始端$ 罫が`終端$ 罫より終端に来る場合、
2 本の罫を入替える。
`始端$ 罫が`終端$ 罫に等しい場合、
`終端$ 罫を除去する。
◎
If the placement for a grid item contains two lines, and the start line is further end-ward than the end line, swap the two lines. If the start line is equal to the end line, remove the end line.
</p>

<p>
`配置$が 2 つの~span†を包含している場合、
`終端$ 側の`格子~配置~prop$から供与された方を除去する。
【†すなわち， `span$v を伴う値から供与されるそれ。】
◎
If the placement contains two spans, remove the one contributed by the end grid-placement property.
</p>

<p>
【前~段落を適用した上で】
`配置$が`罫~名$のみを伴う~span†しか包含しない場合、
その~span数を 1 に置換する。
【†すなわち， <span class="prod">`span$v `custom-ident$t</span> による値から供与されるそれ。】
◎
If the placement contains only a span for a named line, replace it with a span of 1.
</p>

			</section>
		</section>
		<section id="placement-shorthands">
<h3 title="Placement Shorthands: the grid-column, grid-row, and grid-area properties">8.4. 配置： `grid-column^p, `grid-row^p, `grid-area^p 略式~prop</h3>

◎名 `grid-row@p, `grid-column@p
◎値
`grid-line$t [ / `grid-line$t ]?
◎初 `auto^v
◎適
`格子~駒$, および［
`絶対的に位置され$た~boxのうち，その`包含塊$は`格子~容器$であるもの
］
◎
grid items and absolutely-positioned boxes whose containing block is a grid container
◎継 されない
◎百 受容しない
◎算 個々の~propを見よ
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`grid-row$p ~propは［
`grid-row-start$p, `grid-row-end$p
］に対応する`略式~prop$であり，
`grid-column$p ~propは［
`grid-row-start$p, `grid-row-end$p
］に対応する`略式~prop$である。
◎
The grid-row and grid-column properties are shorthands for grid-row-start/grid-row-end and grid-column-start/grid-column-end, respectively.
</p>

<p>
文法の~slashの
前／後
に与えられた値が，下位prop［
`grid-*-start^p ／ `grid-*-end^p
］を設定する。
◎
If two &lt;grid-line&gt; values are specified, the grid-row-start/grid-column-start longhand is set to the value before the slash, and the grid-row-end/grid-column-end longhand is set to the value after the slash.
</p>

<p>
~slashの後の値が省略された場合、
下位prop `grid-*-end^p は，［
~slashの前の値が `custom-ident$t であるならば それと同じ値 ／
他の場合は `~autoP$v
］に設定される。
◎
When the second value is omitted, if the first value is a &lt;custom-ident&gt;, the grid-row-end/grid-column-end longhand is also set to that &lt;custom-ident&gt;; otherwise, it is set to auto.
</p>

◎名 `grid-area@p
◎値
`grid-line$t [ / `grid-line$t ]{0,3}
◎初 `auto^v
◎適
`格子~駒$, および［
`絶対的に位置され$た~boxのうち，その`包含塊$は`格子~容器$であるもの
］
◎
grid items and absolutely-positioned boxes whose containing block is a grid container
◎継 されない
◎百 受容しない
◎算 個々の~propを見よ
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`grid-area$p ~propは、［
`grid-row-start$p,
`grid-column-start$p,
`grid-row-end$p,
`grid-column-end$p
］用の略式である。
◎
The grid-area property is a shorthand for grid-row-start, grid-column-start, grid-row-end and grid-column-end.
</p>

<p>
4 個の `grid-line$t 値は、
順に［
`grid-row-start$p,
`grid-column-start$p,
`grid-row-end$p,
`grid-column-end$p
］の値を設定する。
ただし，指定された値の個数が：
◎
If four &lt;grid-line&gt; values are specified, grid-row-start is set to the first value, grid-column-start is set to the second value, grid-row-end is set to the third value, and grid-column-end is set to the fourth value.
</p>

<div >
	<ol>
		<li>
2 個に満たない場合、
`grid-column-start$p は［
1 個目の値は `custom-ident$t ならば それ ／
他の場合は `~autoP$v
］に設定される。
</li>
		<li>
3 個に満たない場合、
`grid-row-end$p は［
1 個目の値は `custom-ident$t ならば それ ／
他の場合は `~autoP$v
］に設定される。
</li>
		<li>
4 個に満たない場合、
`grid-column-end$p は
`grid-column-start$p に設定される値と同じ値に設定される。
</li>
	</ol>

◎
When grid-column-end is omitted, if grid-column-start is a &lt;custom-ident&gt;, grid-column-end is set to that &lt;custom-ident&gt;; otherwise, it is set to auto.
◎
When grid-row-end is omitted, if grid-row-start is a &lt;custom-ident&gt;, grid-row-end is set to that &lt;custom-ident&gt;; otherwise, it is set to auto.
◎
When grid-column-start is omitted, if grid-row-start is a &lt;custom-ident&gt;, all four longhands are set to that value. Otherwise, it is set to auto.
</div>

<p class="note">注記：
この略式~propの各~成分~値は、
`row-start^p から順に，左横書きの~pageでは時計回りに†, 右横書きの~pageでは反~時計回りに 4 辺を指定することになる。
【†原文の “CCW” （ `counterclockwise^en ）は “CW”（ `clockwise^en ）の誤りと見られる。】
◎
Note: The resolution order for this shorthand is row-start/column-start/row-end/column-end, which goes CCW for LTR pages, the opposite direction of the related 4-edge properties using physical directions, like margin.
</p>

		</section>
		<section id="auto-placement-algo">
<h4 title="Grid Item Placement Algorithm">8.5. 格子~駒の自動-配置~algo</h4>

<p>
位置が`自動的$posにされた`格子~駒$は、
以下に与える
`格子~駒の配置~algo@
により，
どの`格子~駒$も
— きちんと定義された`区画$に~lay-outされるよう —
`確定的$posな位置に解決される。
（`~span数$は，特別に解決される必要はない
— 明示的に指定されていない場合、
既定~の 1 になるので。
【したがって，以下の~algoにおいては、駒の［ `~row-始端 罫$, `~col-始端 罫$ ］のみを決定することになる。】
）
◎
The following grid item placement algorithm resolves automatic positions of grid items into definite positions, ensuring that every grid item has a well-defined grid area to lay out into. (Grid spans need no special resolution; if they’re not explicitly specified, they default to 1.)
</p>

<p class="note">注記：
この~algoは、［
`明示的な格子$内に，自動-位置された`格子~駒$を配置する部屋
］が足りなくなったときには，
`暗黙的な格子$内に新たな筋rcを作成する。
◎
Note: This algorithm can result in the creation of new rows or columns in the implicit grid, if there is no room in the explicit grid to place an auto-positioned grid item.
</p>

<p>
どの`升$も，初期~時には
`未占有@
とされ、
~algoの中で［
位置が確定された`格子~駒$が占める`区画$
］に覆われる升が
`占有-済み@
に変化する。
◎
Every grid cell (in both the explicit and implicit grids) can be occupied or unoccupied. A cell is occupied if it’s covered by the grid area of a grid item with a definite grid position; otherwise, the cell is unoccupied. A cell’s occupied/unoccupied status can change during this algorithm.
</p>

<p>
明快にするため、
この~algoは，［
`grid-auto-flow$p に `row$v が指定されている
］ことを前提に記されている。
`column$v に設定されている下では、
この~algoの中に~~現れる
~rowと~col
すべてを入替える。
◎
To aid in clarity, this algorithm is written with the assumption that grid-auto-flow has row specified. If it is instead set to column, swap all mentions of rows and columns, inline and block, etc. in this algorithm.
</p>

<p class="note">注記：
自動-配置~algoは、
論理的な文書~順序ではなく
`order$p により`改変された文書~順序$の下で，`格子~駒$たちに対し働く。
◎
Note: The auto-placement algorithm works with the grid items in order-modified document order, not their original document order.
</p>

<ol>
	<li>
`§ 格子~駒＠#grid-items$にて述べたとおりに，
<strong>匿名な格子~駒を生成する</strong>
（匿名な`格子~駒$は、
常に自動-配置される
— それらの~boxには`格子~配置~prop$は指定できないので）。
◎
Generate anonymous grid items as described in § 6 Grid Items. (Anonymous grid items are always auto-placed, since their boxes can’t have any grid-placement properties specified.)
</li>
	<li>
<strong>
自動-位置されてないものを位置させる
</strong>
◎
Position anything that’s not auto-positioned.
</li>
	<li>
<p><strong>
（~rowが確定的である駒を処理する）
</strong>
◎
Process the items locked to a given row.
</p>

<p>
`格子~駒$のうち，~row位置が`確定的$posである
（すなわち、
~row位置は［
`grid-row-start$p, `grid-row-end$p
］~propから`確定的$posに定義される）
~EACH( %駒 )
に対し， `order$p により`改変された文書~順序$で：
◎
For each grid item with a definite row position (that is, the grid-row-start and grid-row-end properties define a definite grid position), in order-modified document order:
</p>
		<dl class="switch">
			<dt>
“疎” な収納-法の場合
（既定の挙動）
◎
“sparse” packing (default behavior)
</dt>
			<dd>
%駒 の`配置$の`~col-始端 罫$ ~SET 次を満たすような最~小な正な~index
⇒
［
%駒 が占める`区画$は、
`占有-済み$のどの升にも重合しない
］~AND［
これまでに［
この段にて この~rowに配置された，どの`格子~駒$の`~col-始端 罫$
］よりも大きい
］
◎
Set the column-start line of its placement to the earliest (smallest positive index) line index that ensures this item’s grid area will not overlap any occupied grid cells and that is past any grid items previously placed in this row by this step.
</dd>
			<dt>
“稠密” な収納-法の場合
（ `dense$v が指定されている）
◎
“dense” packing (dense specified)
</dt>
			<dd>
%駒 の`配置$の`~col-始端 罫$ ~SET 次を満たすような最~小な正な~index
⇒
%駒 が占める`区画$は`占有-済み$のどの升にも重合しない
◎
Set the column-start line of its placement to the earliest (smallest positive index) line index that ensures this item’s grid area will not overlap any occupied grid cells.
</dd>
		</dl>
	</li>
	<li>
<p><strong>
（`暗黙的な格子$に含まれる~colたちを決定する）
</strong>
◎
Determine the columns in the implicit grid.
</p>

<p>
次に従って，`暗黙的な格子$内に~colを作成する：
◎
Create columns in the implicit grid:
</p>
		<ol>
			<li>
前~段までに~col位置は確定された駒
（明示的に位置されているもの ／
前~段により位置されたもの ／
まだ位置されていないが~col位置は`確定的$posであるもの）
すべてを収容するため、
必要yなだけ，`暗黙的な格子$に~colを追加する。
【 `span$v 値の`例＠#_dgm-implicit-lines-search$に示したように、始端~側に追加される場合もある。】
◎
Start with the columns from the explicit grid.
◎
Among all the items with a definite column position (explicitly positioned items, items positioned in the previous step, and items not yet positioned but with a definite column) add columns to the beginning and end of the implicit grid as necessary to accommodate those items.
</li>
			<li>
前~段までに~col位置は確定されていない駒のうち［
`~span数$が`暗黙的な格子$の~col数【！＊width】を超えるもの
］すべてを収容するため、
必要に応じて，`暗黙的な格子$の終端に~colを追加する。
◎
If the largest column span among all the items without a definite column position is larger than the width of the implicit grid, add columns to the end of the implicit grid to accommodate that column span.
</li>
		</ol>

<div class="example">
<p>
例えば、
次の style 片の場合：
◎
For example, in the following style fragment:
</p>

<pre class="lang-css">
#grid {
  display: grid;
  grid-template-columns: repeat(5, 100px);
  grid-auto-flow: row;
}
#grid-item {
  grid-column: 4 / span 3;
}
</pre>

<p>
必要な~col数は 6 になる。
明示的な格子は，
（ `grid-template-columns$p から）
罫 1 〜 罫 6 までの 5 本の~colを供するが、
`#grid-item^c の~col位置は罫 7 で終端することを意味するので，
暗黙的な格子の終端に~colを追加することが要求される。
◎
The number of columns needed is 6. The explicit grid provides 5 columns (from grid-template-columns) with lines number 1 through 6, but #grid-item’s column position means it ends on line 7, which requires an additional column added to the end of the implicit grid.
</p>
</div>
	</li>
	<li>
<p><strong>
（まだ位置が確定されていない，残りの`格子~駒$たちの位置を確定する）
</strong>
◎
Position the remaining grid items.
</p>

<div class="p">
<p>
以下においては：
</p>
		<ul>
			<li>
%駒~list は、
それらの駒たちが成す，
`order$p により`改変された文書~順序$による~listを表すとする。
</li>
			<li>
［
`最~始端~col罫^i ／ `最~始端~row罫^i ／ `最~終端~col罫^i
］は、
`暗黙的な格子$の周を成す［
最も始端に在る~col罫 ／ 最も始端に在る~row罫 ／ 最も終端に在る~col罫
］（の~index）を表すとする
— これらは、
前~段までに確定されている。
</li>
			<li>
変数
( %~row位置, %~col位置 )
の組
—
`自動-配置~cursor@
—
は、
`暗黙的な格子$内の現在の “駒の挿入地点” とされる
( ~row`罫$, ~col`罫$ )
を表す
（すなわち、
以下に現れる “%駒 が占める区画” は，駒の
( `~row-始端 罫$, `~col-始端 罫$ )
が
( %~row位置, %~col位置 )
であったとするときに占める区画を表す）。
初期~時には
( `最~始端~row罫^i, `最~始端~col罫^i )
に設定されているとする。
</li>
			<li>
%~row位置 が増やされる所では、
必要なら（駒を収容する部屋が足りなくなったときは），
`暗黙的な格子$ 内に新たな~rowを作成するとする。
</li>
		</ul>

<p class="trans-note">【
“自動-配置~cursor” 以外の，ここに挙げた規約は、
原文にて以下に現れていた記述を，この訳にて集約して補完したものである。
】</p>

◎
The auto-placement cursor defines the current “insertion point” in the grid, specified as a pair of row and column grid lines. Initially the auto-placement cursor is set to the start-most row and column lines in the implicit grid.
</div>

<p>
一連の駒を位置させる方法は、
利用-中な `grid-auto-flow$p 値から決定される：
◎
The grid-auto-flow value in use determines how to position the items:
</p>

		<dl class="switch">
			<dt>
“疎” な収納-法
（既定の挙動）
◎
“sparse” packing (default behavior)
</dt>
			<dd>
<p>
%駒~list を成す
~EACH( %駒 )
に対し：
◎
For each grid item that hasn’t been positioned by the previous steps, in order-modified document order:
</p>
				<ol>
					<li>
<p>
~IF［
%駒 の~col位置は`確定的$posである
］：
◎
If the item has a definite column position:
</p>
						<ol>
							<li>
~IF［
%駒 の`~col-始端 罫$ ~LT %~col位置
］
⇒
%~row位置 ~INCBY 1
◎
↓</li>
							<li>
%~col位置 ~SET %駒 の`~col-始端 罫$
◎
Set the column position of the cursor to the grid item’s column-start line. If this is less than the previous column position of the cursor, increment the row position by 1.
</li>
							<li>
~WHILE［
%駒 が占める`区画$は`占有-済み$のある`升$に重合する
］
⇒
%~row位置 ~INCBY 1
◎
Increment the cursor’s row position until a value is found where the grid item does not overlap any occupied grid cells (creating new rows in the implicit grid as necessary).
</li>
							<li>
%駒 の`~row-始端 罫$ ~SET %~row位置
◎
Set the item’s row-start line to the cursor’s row position, and set the item’s row-end line according to its span from that position.
</li>
						</ol>
					</li>

					<li>
<p>
~ELSE
（ %駒 の位置は両~軸とも`自動的$pos）：
◎
If the item has an automatic grid position in both axes:
</p>
						<ol>
							<li>
<p>
~WHILE 無条件：
</p>
								<ol>
									<li>
~WHILE［
%駒 が占める`区画$は`占有-済み$のある`升$に重合する
］
⇒
%~col位置 ~INCBY 1
</li>
									<li>
~IF［
( %~col位置 + %駒 の~col`~span数$ ) ~LTE `最~終端~col罫^i
］
⇒
~BREAK
</li>
									<li>
%~row位置 ~INCBY 1
</li>
									<li>
%~col位置 ~SET `最~始端~col罫^i
</li>
								</ol>
◎
Increment the column position of the auto-placement cursor until either this item’s grid area does not overlap any occupied grid cells, or the cursor’s column position, plus the item’s column span, overflow the number of columns in the implicit grid, as determined earlier in this algorithm.
◎
If a non-overlapping position was found in the previous step, set the item’s row-start and column-start lines to the cursor’s position. Otherwise, increment the auto-placement cursor’s row position (creating new rows in the implicit grid as necessary), set its column position to the start-most column line in the implicit grid, and return to the previous step.
</li>
							<li>
%駒 の
⇒＃
`~row-始端 罫$ ~SET %~row位置；
`~col-始端 罫$ ~SET %~col位置
◎
↑</li>
						</ol>
					</li>
				</ol>
			</dd>

			<dt>
“稠密” な収納-法
（ `dense$v が指定されている）
◎
“dense” packing (dense specified)
</dt>
			<dd>
<p>
%駒~list を成す
~EACH( %駒 )
に対し：
◎
For each grid item that hasn’t been positioned by the previous steps, in order-modified document order:
</p>
				<ol>
					<li>
%~row位置 ~SET `最~始端~row罫^i
◎
↓↓</li>
					<li>
<p>
~IF［
%駒 の~col位置は`確定的$posである
］：
◎
If the item has a definite column position:
</p>
						<ol>
							<li>
%~col位置 ~SET %駒 の`~col-始端 罫$
◎
Set the row position of the cursor to the start-most row line in the implicit grid. Set the column position of the cursor to the grid item’s column-start line.
</li>
							<li>
~WHILE［
%駒 が占める`区画$は`占有-済み$のある升に重合する
］
⇒
%~row位置 ~INCBY 1
◎
Increment the auto-placement cursor’s row position until a value is found where the grid item does not overlap any occupied grid cells (creating new rows in the implicit grid as necessary).
</li>
							<li>
%駒 の`~row-始端 罫$ ~SET %~row位置
◎
Set the item’s row-start line index to the cursor’s row position. (Implicitly setting the item’s row-end line according to its span, as well.)
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE
（ %駒 の位置は両~軸とも`自動的$pos）：
◎
If the item has an automatic grid position in both axes:
</p>
						<ol>
							<li>
<p>
~WHILE 無条件：
</p>
								<ol>
									<li>
%~col位置 ~SET `最~始端~col罫^i
</li>
									<li>
~WHILE［
%駒 が占める`区画$は`占有-済み$のある升に重合する
］
⇒
%~col位置 ~INCBY 1
</li>
									<li>
~IF［
( %~col位置 + %駒 の~col`~span数$ ) ~LTE `最~終端~col罫^i
］
⇒
~BREAK
</li>
									<li>
%~row位置 ~INCBY 1
</li>
								</ol>
◎
Set the cursor’s row and column positions to start-most row and column lines in the implicit grid.
◎
Increment the column position of the auto-placement cursor until either this item’s grid area does not overlap any occupied grid cells, or the cursor’s column position, plus the item’s column span, overflow the number of columns in the implicit grid, as determined earlier in this algorithm.
◎
If a non-overlapping position was found in the previous step, set the item’s row-start and column-start lines to the cursor’s position. Otherwise, increment the auto-placement cursor’s row position (creating new rows in the implicit grid as necessary), reset its column position to the start-most column line in the implicit grid, and return to the previous step.
</li>
							<li>
%駒 の
⇒＃
`~row-始端 罫$ ~SET %~row位置；
`~col-始端 罫$ ~SET %~col位置
◎
↑</li>
						</ol>
					</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

		</section>
	</section>
	<section id="subgrids">
<h2 title="Subgrids">9. 下位格子</h2>

<p>
`下位格子$は、
以下に挙げる点を除いて，通常の`格子~容器$と同じ様に挙動する：
◎
A subgrid behaves just like a normal grid container except that:
</p>

<p>
この節の以下の記述は、
<strong>
`下位格子~化$された各~軸ごとに適用される。
</strong>
以下に現れる，次に挙げる用語は、［
`下位格子~化$された軸に`対応する方＠#_conventions$
］を表すとする
⇒＃
“筋”, ~size, ~span, 罫, 辺, 整列, 次元, 寸法（または、これらを一部に含む語句）,
`grid-template-*$p ~prop,
`格子~配置~prop$,
`自己-整列~prop$,
`内容-分布~prop$
</p>

<p class="trans-note">【
これらの語には、
逐一，
“`下位格子~化$された軸に対応する方の”
が暗黙的に注釈される。
この規約は、
以下を簡潔に述べるため，この訳に導入している。
】</p>

<ul>
	<li id="subgrid-tracks">
`下位格子$の配置-法においては、［
`下位格子$を成す各~筋から`下位格子$が`親~格子$内で~spanする各~筋への対応関係
］が作成される。
したがって，`下位格子$の各~罫は、
`親~格子$と共有され，`下位格子$の`明示的な格子$を形成し，`親~格子$が`下位格子$の各~筋の~sizeを統治するようになる。
◎
Placing the subgrid creates a correspondence between its subgridded tracks and those that it spans in its parent grid. The grid lines thus shared between the subgrid and its parent form the subgrid’s explicit grid, and its track sizes are governed by the parent grid.
</li>
	<li id="subgrid-span">
<p>
`下位格子$における`明示的な筋$の本数は、
常に，`下位格子$が`親~格子$内で~spanする`筋$の本数に対応する
— `下位格子$の`~span数$に応じて：
◎
The number of explicit tracks in the subgrid in a subgridded dimension always corresponds to the number of grid tracks that it spans in its parent grid:
</p>
		<ul class="switch">
			<li>
［
`明示的$span／`暗黙的$span
］である場合
⇒
`下位格子$の`明示的な筋$の本数は、
`下位格子$の使用`~span数$から採られる
（`下位格子$の `grid-template-*$p ~propに関わらず）。
◎
If the subgrid’s grid span in the subgridded dimension is explicit or implicit, then the number of explicit tracks in each subgridded dimension is taken from its used grid span in that dimension (regardless of its grid-template-* properties).
</li>
			<li>
`自動的$spanである場合
⇒
使用`~span数$は、
`下位格子$の `grid-template-*$p ~propに指定された`明示的な筋$たちの本数から採られ，
1 以上に切り上げられる。
◎
If it has an automatic grid span, then its used grid span is taken from the number of explicit tracks specified for that axis by its grid-template-* properties, floored at one.
</li>
		</ul>

<p class="note">注記：
ここで決定される明示的な格子は、［
`下位格子$の配置が，その親~格子により切詰められる場合
］には，さらに切落され得る
— `下位格子には、暗黙的な筋は無い＠#subgrid-implicit$ので。
◎
Note: The explicit grid determined here can be further truncated if the placement of the subgrid is clamped by its parent grid. See the "no implicit tracks" bullet point.
</p>

<p>
`grid-template-*$p ~propが `line-name-list$t を指定する場合、
その使用~値は，`明示的な筋$の使用~本数に合致するよう切落される。
◎
If the grid-template-* properties specify a &lt;line-name-list&gt; in a subgridded axis, the used value is truncated to match the used number of explicit tracks.
</p>

	</li>
	<li id="subgrid-indexing">
<p>
`下位格子$の`格子~駒$の`格子~配置~prop$, および
それらが利用する罫~番号の視野は、
当の`下位格子$が覆う罫たちに絞られる
— ［
`下位格子$の外側にある罫はすべて`下位格子$の`明示的な格子$から除外した結果
］と正確に整合するよう。
例えば，数量-~indexは、
`親~格子$の最初の罫ではなく，
`下位格子$の最初の罫から数えられる。
◎
The grid-placement properties of the subgrid’s grid items and the line numbers they use are scoped to the lines covered by the subgrid, exactly consistent with the lines outside the subgrid being excluded from its explicit grid. E.g. numeric indices count starting from the first line of the subgrid rather than the first line of the parent grid.
</p>

<p>
罫の［
付番, 配置
］の規則は、
`下位格子$の自前の`書字~mode$を順守する
— `自立的な格子$【！nested independent】用にそうなるのと同じく。
◎
Line numbering and placement rules obey the subgrid’s own writing mode, just as they would for a nested independent grid.
</p>

<p class="trans-note">【
特に，`下位格子$が`直交~flowを確立して$いる場合、
下位格子の［
~row／~col
］は親~格子の［
~col／~row
］に対応することになる。
また，下位格子の`行内~基底~方向$が親~格子のそれと逆になっている場合、
罫~番号も逆順に対応することになる。
】</p>

	</li>
	<li id="subgrid-line-name-inheritance">
<p>
`下位格子$は，その内容が配置される前に配置できるので、
各~罫は［
`親~格子$の対応する罫に指定された`明示的にアテガわれる罫~名$
］を自動的に受取る。
◎
Since subgrids can be placed before their contents are placed, the subgridded lines automatically receive the explicitly-assigned line names specified on the corresponding lines of the parent grid.
</p>

<p>
これらの名前は、
`下位格子$に局所的に指定された`罫~名$に対する`追加^emである。
◎
These names are in addition to any line names specified locally on the subgrid.
</p>
	</li>
	<li id="subgrid-area-inheritance">
<p>
`下位格子$が`親~格子$内の`有名~区画$に重合する場合、
`下位格子$の中で`親~格子$の`有名~区画$を表現するため，
`下位格子$を成す罫には`暗黙的にアテガわれる罫~名$たちもアテガわれる。
◎
When a subgrid overlaps a named grid area in its parent that was created by a grid-template-areas property declaration, implicitly-assigned line names are assigned to represent the parent’s named grid area within the subgrid.
</p>

<p class="note">注記：
`有名~区画$が`下位格子$に部分的にしか重合しない場合、
`暗黙的にアテガわれる罫~名$は，［
その部分的に重合している区画を`下位格子$内で表現している`有名~区画$
］が存在するよう，`下位格子$の［
最初／最後
］の罫にアテガわれることになる。
したがって、
`下位格子$に対する`罫~名$のアテガわれ方は，
`親~格子$に対する`罫~名$のアテガわれ方に常に正確に対応するとは限らない。
◎
Note: If a named grid area only partially overlaps the subgrid, its implicitly-assigned line names will be assigned to the first and/or last line of the subgrid such that a named grid area exists representing that partially overlapped area of the subgrid; thus the line name assignments of the subgrid might not always correspond exactly to the line name assignments of the parent grid.
</p>

<p>
これらの名前も、
当の`下位格子$に局所的に指定された`罫~名$に対する`追加^emである。
◎
These names are also in addition to any line names specified locally on the subgrid.
</p>

<div class="example">
<p>
次の例では、
4 本の~colからなる格子（ `.outer^css ）があり，それは［
格子（ `.inner^css ）の親~格子を成す格子（ `.middle^css ）の親~格子
］を成している。
この格子には、
明示的な罫~名に加え，
`grid-template-areas$p により生成される暗黙的な罫~名もある：
◎
In the following example, the 4-column grand-parent grid has both explicit line names and implicit ones generated by grid-template-areas:
</p>

<pre class="lang-css">
&lt;style type="css"&gt;
  .outer {
    display: grid;
    grid-template-columns:
      [outer-edge] 20px [main-start] 1fr [center] 1fr max-content [main-end];
    grid-template-areas:
      "gutter info info photos";
  }
  .middle {
    grid-column: main-start / main-end;
    display: grid;
    grid: subgrid / subgrid;
  }
  .inner {
    grid-column: center / -1;
    display: grid;
    grid: subgrid / subgrid;
  }
&lt;/style&gt;

&lt;div class="outer"&gt;
  &lt;div class="middle"&gt;
    &lt;div class="inner"&gt;&amp;hellip;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>

<p>
各 種別の名前を解決した結果の，各~格子~用の名前は：
◎
After all types of name resolution, the names for each grid will be:
</p>
<ul>
	<li>
`.outer^css 用
⇒
`[outer-edge gutter-start] [gutter-end info-start main-start] [center] [info-end photos-start] [main-end photos-end]^css
◎
.outer = [outer-edge gutter-start] [gutter-end info-start main-start] [center] [info-end photos-start] [main-end photos-end]
</li>
	<li>
`.middle^css 用
⇒
`[info-start main-start] [center] [info-end photos-start] [main-end photos-end]^css
◎
.middle = [info-start main-start] [center] [info-end photos-start] [main-end photos-end]
</li>
	<li>
`.inner^css 用
⇒
`[center info-start] [info-end photos-start] [main-end photos-end]^css
◎
.inner = [center info-start] [info-end photos-start] [main-end photos-end]
</li>
</ul>

<p>
`明示的にアテガわれる罫~名$は、
すべて `.inner^css まで直線的に継承される。
一方で，`暗黙的にアテガわれる罫~名$は、
各 `下位格子$が元の`有名~区画$と重合する部分に基づいて計算されることに注意。
◎
Notice that all the explicitly-assigned line names inherit straight through to .inner, but the implicitly-assigned line names are calculated based on each subgrid's overlap of the original named grid area.
</p>
</div>
	</li>
	<li id="subgrid-implicit">
<p>
`下位格子$には、
`暗黙的な筋$は無い。
`明示的な格子$に十分な罫たちが無いときは、
仮の`暗黙的な罫$が通例通り配置を解決するために利用される
— しかしながら，【下位格子~内の】`格子~駒$が占める`格子~区画$は、
`格子~区画を切詰める$ことにより
（巨大過ぎる格子において配置を切詰めるときと同じ手続-），
`下位格子$の`明示的な格子$に切詰められる。
◎
The subgrid does not have any implicit grid tracks in the subgridded dimension(s). Hypothetical implicit grid lines are used to resolve placement as usual when the explicit grid does not have enough lines; however each grid item’s grid area is clamped to the subgrid’s explicit grid (using the same procedure as for clamping placement in an overly-large grid).
</p>

<div class="example">
<p>
例えば，［
下位格子の `grid-column$p は `span 1^v,
それを成す ある`格子~駒$の `grid-column$p は `2 / span 3^v
］にされた場合、
その駒は，下位格子~内の最初の（かつ唯一の）筋の中へ強制される（かつ制限される）。
◎
For example, if a span 1 subgrid has a grid item with grid-column: 2 / span 3;, then that item is instead forced into (and limited to) the first (only) track in the subgrid.
</p>
</div>

<p class="note">注記：
このことは、［
下位格子を成す筋の本数は、
その親も下位格子である場合には
— したがって，親を成す筋の本数は固定的になる —
期待されるより少なくなり得る
］ことを意味する。
（親が【下位格子であるかどうかを問わず】［
`~UAによる，格子~筋の本数に対する上限＠#overlarge-grids$
］に抵触しているときも、
同様に，筋の本数は期待されるより少なくなり得る。）
◎
Note: This means that a subgrid might have fewer tracks than it expected, if its parent is also a subgrid and therefore has a fixed number of tracks. (A subgrid might likewise have fewer tracks than expected because its parent is hitting the UA limit on grid tracks.)
</p>
	</li>
	<li id="subgrid-size-contribution">
`下位格子$自身は，`親~格子$内で普通の`格子~駒$として~lay-outされるが、
【親~格子の】筋~sizingの目的においては，完全に空であったかのように動作する。
◎
The subgrid itself lays out as an ordinary grid item in its parent grid, but acts as if it was completely empty for track sizing purposes in the subgridded dimension.
</li>
	<li id="subgrid-item-contribution">
<p>
`下位格子$の`格子~駒$は、
`親~格子$の~sizingに関与し，`親~格子$に整列される。
◎
The subgrid’s own grid items participate in the sizing of its parent grid in the subgridded dimension(s) and are aligned to it in those dimensions.
</p>

<p id="subgrid-margins">
この処理nにおいては，`下位格子$の各~辺 %辺 に対し、
%辺 における`下位格子$の［
~margin, ~padding, `~scrollbar側溝$, ~border
］の総和（負になり得る）は，［
%辺 に接する各~駒に対し，駒の~marginを成す余分な層
］として適用される。
この余分な層を成す “~margin” は、
複数~levelの`下位格子$たちを通して累積される。
◎
In this process, the sum of the subgrid’s margin, padding, scrollbar gutter, and border at each edge are applied as an extra layer of (potentially negative) margin to the items at those edges. This extra layer of “margin” accumulates through multiple levels of subgrids.
</p>

<div class="example">
<p>
例えば、
親~格子は次のような 3 本の~colを伴うとするとき：
◎
For example, if we have a 3×3 grid with the following tracks:
</p>
<pre class="lang-css">
#parent-grid { grid-template-columns: 300px auto 300px; }
</pre>

<p>
`下位格子$が`親~格子$の最後の 2 本の筋を覆う場合、
下位格子の［
1 本目／ 2 本目
］の~colは，親~格子の［
2 本目／ 3 本目
］の~colに対応する
— これらの筋~内に位置する下位格子の駒は、
親~格子の~sizingに関与する。
特定的には、
駒が下位格子の 1 本目の~col内に位置するならば，
親~格子の 2 本目の筋の自動-~sizingに波及する。
◎
If a subgrid covers the last two tracks, its first two columns correspond to the parent grid’s last two columns, and any items positioned into those tracks participate in sizing the parent grid. Specifically, an item positioned in the first track of the subgrid influences the auto-sizing of the parent grid’s middle track.
</p>

<pre class="lang-css">
#subgrid { grid-column: 2 / span 2; } /* <span class="comment">
下位格子は親~格子の 2 本目, 3 本目の筋を覆う
◎
cover parent’s 2nd and 3rd tracks
</span> */
#subgrid &gt; :first-child { grid-column: 1; } /* <span class="comment">
下位格子の 1 本目の筋は、
親の 2 本目の筋に対応する
◎
subgrid’s 1st track, parent grid’s 2nd track
</span> */
</pre>

<p>
下位格子の［
~margin／~border／~padding
］は、
~sizingに波及する。
例えば，下位格子の~paddingは `100px^v ならば：
◎
If the subgrid has margins/borders/padding, the size of those margins/borders/padding also influences sizing. For example, if the subgrid has 100px padding:
</p>

<pre class="lang-css">
#subgrid { padding: 100px; }
</pre>

<p>
`下位格子$の最初の筋に置かれた`格子~駒$は、［
上端, 左端, 下端
］†に追加的な~margin `100px^v があるかのように動作して，［
`親~格子$の筋の~sizing,
`格子~駒$の位置
］に波及することになる。
【†右端だけ除外されているのはなぜ？】
◎
Then a grid item in the subgrid’s first track acts as if it has an additional 100px of top, left, and bottom margin, influencing the sizing of the parent grid’s tracks and the grid item’s own position.
</p>
</div>

<p id="subgrid-gaps">
その一方，［
`下位格子$の`側溝$（ `row-gap$p ／ `column-gap$p ）,
その`親~格子$の`側溝$
］の~size差の半分は、
それらの辺に接していない駒に対する余分な層を成す~margin（負になり得る）として適用される。
この余分な層を成す “~margin” もまた、
複数~levelの下位格子たちを通して累積される。
値 `normal$v は、
下位格子, その親~格子の`側溝$は同じ~sizeになることを指示する
— すなわち，適用される~size差は 0 になる。
◎
Meanwhile, half the size of the difference between the subgrid’s gutters (row-gap/column-gap) and its parent grid’s gutters is applied as an extra layer of (potentially negative) margin to the items not at those edges. This extra layer of “margin” also accumulates through multiple levels of subgrids. A value of normal indicates that the subgrid has the same size gutters as its parent grid, i.e. the applied difference is zero.
</p>

<p class="note">注記：
その結果、
親~格子を成す各~筋は指定されたとおりに~sizeされ、
結果的に［
`下位格子$の`側溝$，親~格子の`側溝$
］は互いの中心が整列されることになる。
◎
Note: The end result will be that the parent’s grid tracks will be sized as specified, and that the subgrid’s gutters will visually center-align with the parent grid’s gutters.
</p>

<div class="example">
<p>
例えば，幅 `300px^v, ~gap `50px^v を伴う外縁~格子には 2 本の~colがあって
`100px 1fr^v が指定されているとする。
ある下位格子がこの両~筋に~spanしていて，下位格子には その［
左端／右端
］~colを占める格子~駒［
%左端~駒 ／ %右端~駒
］があるとする。
◎
For example, suppose we have a 300px-wide outer grid with 50px gaps and its columns specified as 100px 1fr. A subgrid spanning both tracks would have…
</p>

<div>
<p>
以下の各~図式に示すように，［
%左端~駒 ／ %右端~駒
］は、
`column-gap$p の値 %G に応じて，その［
右端~margin／左端~margin
］が［
%M ~EQ ( %G ~MINUS `50px^v ) ~DIV 2
］であったかのように，~sizeされ~lay-outされる
（加えて、
自身の~sizeを親~格子の~sizing計算に供与する）。
その結果：
</p>
		<ul>
			<li>
%左端~駒 は，下位格子の左端~辺に整列されたまま，幅
( `100px^v ~MINUS %M )
に伸張されるか縮短される。
</li>
			<li>
%右端~駒 は，下位格子の右端~辺に整列されたまま，幅
( `300px^v ~MINUS `100px^v ~MINUS `50px^v ~MINUS %M )
に伸張されるか縮短される。
</li>
			<li>
［
%左端~駒, %右端~駒
］の合間を成す視覚-効果~上の`側溝$は、
下位格子の `column-gap$p に指定されたとおり %G になる：
</li>
		</ul>
◎
↓</div>

		<dl class="switch">
			<dt>
%G ~EQ
`50px^v ／ `normal$v の場合：
◎
… if its column-gap were normal (or 50px):
</dt>
			<dd>
<p>
%M ~EQ 0 になるので、［
%左端~駒, %右端~駒
］どちらも特別な調整を伴うことなく，~sizeされ~lay-outされる。
その結果，これらの駒の合間を成す視覚-効果~上の`側溝$は、
親~格子のそれ（ `50px^v ）に正確に合致する。
◎
A grid item in its left column sized and laid out (and contributing its size to the parent grid’s sizing calculations) without any special adjustment, thus stretching to 100px wide while remaining aligned to the subgrid’s left edge.
◎
A grid item in its right column sized and laid out (and contributing its size to the parent grid’s sizing calculations) without any special adjustment, thus stretching to 150px wide, while remaining aligned to the subgrid’s right edge.
◎
An effective visual gutter between the items of 50px, exactly matching its parent grid.
</p>

`subgrid-gap-normal^dgm
</dd>

			<dt>
%G ~EQ
`0^v の場合：
◎
… if its column-gap were 0:
</dt>
			<dd>
<p>
%M ~EQ `-25px^v になり、［
%左端~駒 は幅 `125px^v ／
%右端~駒 は幅 `175px^v
］になる。
◎
A grid item in its left column sized and laid out (and contributing its size to the parent grid’s sizing calculations) as if it had a -25px right margin, thus stretching to 125px wide while remaining aligned to the subgrid’s left edge.
◎
A grid item in its right column sized and laid out (and contributing its size to the parent grid’s sizing calculations) as if it had a -25px left margin, thus stretching to 175px wide, while remaining aligned to the subgrid’s right edge.
◎
An effective visual gutter between the items of zero, as specified by its column-gap.
</p>

`subgrid-gap-0px^dgm
</dd>

			<dt>
%G ~EQ
`25px^v の場合：
◎
… if its column-gap were 25px:
</dt>
			<dd>
<p>
%M ~EQ `-12.5px^v になり、［
%左端~駒 は幅 `112.5px^v／
%右端~駒 は幅 `162.5px^v
］になる。
◎
A grid item in its left column sized and laid out (and contributing its size to the parent grid’s sizing calculations) as if it had a -12.5px right margin, thus stretching to 112.5px wide while remaining aligned to the subgrid’s left edge.
◎
A grid item in its right column sized and laid out (and contributing its size to the parent grid’s sizing calculations) as if it had a -12.5px left margin, thus stretching to 162.5px wide, while remaining aligned to the subgrid’s right edge.
◎
An effective visual gutter between the items of 25px, as specified by its column-gap.
</p>

`subgrid-gap-25px^dgm
</dd>

			<dt>
%G ~EQ
`75px^v の場合：
◎
… if its column-gap were 75px:
</dt>
			<dd>
<p>
%M ~EQ `12.5px^v になり、［
%左端~駒 は幅 `87.5px^v ／
%右端~駒 は幅 `137.5px^v
］になる。
◎
A grid item in its left column sized and laid out (and contributing its size to the parent grid’s sizing calculations) as if it had a 12.5px right margin, thus stretching to 87.5px wide while remaining aligned to the subgrid’s left edge.
◎
A grid item in its right column sized and laid out (and contributing its size to the parent grid’s sizing calculations) as if it had a 12.5px left margin, thus stretching to 137.5px wide, while remaining aligned to the subgrid’s right edge.
◎
An effective visual gutter between the items of 75px, as specified by its column-gap.
</p>
`subgrid-gap-75px^dgm
</dd>
		</dl>
</div>
	</li>
	<li id="subgrid-edge-placeholders">
<p>
`下位格子$は空でない場合、
`下位格子$の各~辺 %辺 に対し
【原文の意図がよくわからないため、この段落はきちんと翻訳できていない。】
⇒
［
`下位格子$の %辺 における［
~margin／~border／~padding
］］
%MBP を織り込むため、
`筋~sizing~algo$には，各~span~size
【おそらく、~span数（以下同様）】
に対し［
`下位格子$の %辺 に “最も近い空でない筋”
— 1 個以上の駒が占めている筋のうち %辺 に最も近い筋 —
に~spanしている駒たち
］用に仮の駒が供与される。
この［
仮の駒の~size【~span数？】たち
］は、
各~span~sizeに対し，それらの駒のうち最~大なものから採られ、
%辺 における %MBP の分だけ追加的に膨張する。
それに対応して，仮の駒の~spanも、
その同じ本物の駒の~spanから採られ，［
%辺 との合間にある空な筋の本数
］だけ膨張する。
◎
For each edge of a non-empty subgrid, to account for the subgrid’s margin/border/padding at that edge, a hypothetical item is contributed to the track sizing algorithm for each span size in the set of items spanning into the occupied track closest to that edge of the subgrid. The hypothetical item’s sizes are taken from the sizes of the largest such item of each span size, and are additionally inflated by the subgrid’s own margin/border/padding at that edge. Correspondingly, the hypothetical item’s span is taken from that same real item’s span, and inflated by the number of empty tracks between it and the relevant subgrid’s edge(s).
</p>

<p class="note">注記：
この段は、
%辺 に最も近い空でない筋が本物の駒を包含する場合には，~~省ける
— 上で述べたとおり，
<a href="#subgrid-item-contribution">
下位格子の［
~margin／~border／~padding
］用にすでに織り込まれている</a>ので。
◎
Note: This step can be shortcut if the tracks closest to the subgrid’s edges contain real items, which would have already accounted for the subgrid’s margin/border/padding as described above.
</p>

<div class="example">
<p>
例えば，次の下位格子~layoutにおいて：
◎
For example, in the following subgrid layout:
</p>
<pre class="lang-css">
5px auto auto 5px
.   aaaa aaaa【！aaaaaaaaa】 .
.   bbbb cccc .
</pre>

<p>
下位格子を成す駒［
`aaaa^v, `bbbb^v, `cccc^v
］は、
各自に対応する格子~区画を占めていて，下位格子の~paddingは `25px^v と見做すなら、
2 個の仮の格子~駒は、
下位格子の行内-始端~paddingを取扱う目的においては，
`筋~sizing~algo$に次を供与することになる
⇒＃
`bbbb^v の~size ~PLUS `25px^v を伴い，最初の 2 本の~colに~spanしているもの,
`aaaa^v の~size ~PLUS `25px^v を伴い，最初の 3 本の~colに~spanしているもの
◎
Assuming subgrid items a, b, and c occupying their corresponding grid areas and a subgrid padding of 25px, two hypothetical grid items would be contributed to the track sizing algorithm for the purpose of handling the subgrid’s inline-start padding: one with the size of b plus 25px, spanning the first two columns; and one with the size of a plus 25px, spanning the first three columns.
</p>
</div>
	</li>
	<li id="subgrid-box-alignment">
`下位格子$の寸法は、
常に伸張される。
`下位格子$の`自己-整列~prop$は
— ［
横幅／縦幅
］に指定された拘束と同じく —
無視される。
◎
The subgrid is always stretched in its subgridded dimension(s): the align-self/justify-self properties on it are ignored, as are any specified width/height constraints.
</li>
	<li id="subgrid-grid-alignment">
~layoutにおいては、
`下位格子$を成す格子は，常に`親~格子$の対応している~~区間と整列される。
`下位格子$の`内容-分布~prop$もまた、
無視される，
◎
Layoutwise, the subgrid’s grid is always aligned with the corresponding section of the parent grid; the align-content/justify-content properties on it are also ignored in the subgridded dimension.
</li>
	<li id="subgrid-overflow">
`overflow$p ~propは、
`下位格子$にも適用され，`下位格子$の~overflowしている内容を~viewの中へ~scrollできるようにする。
（~scrollする動作-は~layoutには影響しないことに注意。
【~scrollbarが現れるとしても，~scroll位置は~layoutに影響しない？】
）
◎
The overflow property does apply to subgrids, so that overflowing contents of the subgrid can be scrolled into view. (Note: the act of scrolling does not affect layout.)
</li>
	<li id="subgrid-relpos">
`相対~位置決め$は、
`下位格子$にも通常通り適用され，~boxとその内容を通例通り一緒にズラす。
（`相対~位置決め$が適用されるのは整列の後であり，筋の~sizingには影響しないことに注意。）
◎
Relative positioning applies to subgrids as normal, and shifts the box and its content together as usual. (Note: Relative positioning takes place after alignment, and does not affect track sizing.)
</li>
</ul>

	</section>
	<section id="abspos">
<h2 title="Absolute Positioning">10. 絶対~位置決め</h2>

		<section id="abspos-items">
<h3 title="With a Grid Container as Containing Block">10.1. 包含塊が格子~容器により生成されているとき</h3>

<p>
`絶対的に位置され$た要素の`包含塊$が，`格子~容器$により生成されている場合、
その包含塊の辺は，その要素の`格子~配置~prop$から決定される`区画$の辺になる。
各種~offset~prop
（ `top$p, `right$p, `bottom$p, `left$p ）は、
通常通り，この`包含塊$の対応する辺から 内方への~offsetを指示する。
◎
If an absolutely positioned element’s containing block is generated by a grid container, the containing block corresponds to the grid area determined by its grid-placement properties. The offset properties (top/right/bottom/left) then indicate offsets inwards from the corresponding edges of this containing block, as normal.
</p>

<p class="note">注記：
`格子~容器$に対する`絶対的に位置され$た要素も，その容器の`罫$に整列させれるが、
そのような要素は，空間を（排他的に）占めたり, その格子の~layoutに関与することはない。
◎
Note: While absolutely-positioning an element to a grid container does allow it to align to that container’s grid lines, such elements do not take up space or otherwise participate in the layout of the grid.
</p>

<div class="example">
<pre class="lang-css">
.grid {
  grid: 1fr 1fr 1fr 1fr / 10rem 10rem 10rem 10rem;
  /* <span class="comment">
`格子~容器$を埋める，それぞれ同じ太さの 4 本の~row と,
それぞれ同じ太さ `10rem^v の 4 本の~col
◎
4 equal-height rows filling the grid container, 4 columns of 10rem each 
</span>*/
  justify-content: center;
  /* <span class="comment">
格子の内容を，`格子~容器$の中で横方向に中央寄せにする
◎
center the grid horizontally within the grid container
</span>*/
  position: relative;
  /* <span class="comment">
`絶対~位置決め包含塊$を確立させる。
◎
Establish abspos containing block
</span>*/
}

.abspos {
  grid-row-start: 1;     /* <span class="comment">
始端になる~row罫は 1 本目 — すなわち，格子~容器の上端
◎
1st grid row line = top of grid container
</span>*/
  grid-row-end: span 2;  /* <span class="comment">
終端になる~row罫は 3 本目
◎
3rd grid row line
</span>*/
  grid-column-start: 3;  /* <span class="comment">
始端になる~col罫は 3 本目
◎
3rd grid col line
</span>*/
  grid-column-end: auto; /* <span class="comment">
~colは右~padding辺で終端する
◎
right padding edge
</span>*/
  /* <span class="comment">
`包含塊$は、
`格子~容器$の右上部分を覆う
◎
Containing block covers the top right quadrant of the grid container
</span>*/

  position: absolute;
  top: 70px;
  bottom: 40px;
  left: 100px;
  right: 30px;
}
</pre>

<figure>
`abspos-grid^dgm
</figure>

<p class="note" id="note-writing-mode">注記：
格子や`格子~配置~prop$は `~flowに相対的$である一方，
各種~offset~prop
（ `top$p, `right$p, `bottom$p, `left$p ）
は`物理的$なので、［
`direction$p ／ `writing-mode$p
］~propが変化したときには，格子は合致するように変形される一方で、
~offsetはそうならない。
◎
Note: Grids and the grid-placement properties are flow-relative, while the offset properties (left, right, top, and bottom) are physical, so if the direction or writing-mode properties change, the grid will transform to match, but the offsets won’t.
</p>
</div>

<p>
`格子~配置~prop$に対する `~autoP$v 値は、
自動-配置に代わって，`配置$に特別な罫を供与する
— `格子~容器$の対応する~padding辺
（`格子~容器$が~overflowする場合は、
~scroll可能な区画の~padding辺）
に位置するような。
これらの罫は、
`絶対的に位置され$た駒の位置決めに利用され，この
`増補~格子@
の最初の（ 0 番の）罫, 最後の（ −0 番の）罫になる。
◎
Instead of auto-placement, an auto value for a grid-placement property contributes a special line to the placement whose position is that of the corresponding padding edge of the grid container (the padding edge of the scrollable area, if the grid container overflows). These lines become the first and last lines (0th and -0th) of the augmented grid used for positioning absolutely-positioned items.
</p>

<p class="note">注記：
したがって既定では、
`絶対的に位置され$た~boxの`包含塊$は、
`塊~容器$に対するときと同じく，`格子~容器$の各~padding辺に対応する。
◎
Note: Thus, by default, the absolutely-positioned box’s containing block will correspond to the padding edges of the grid container, as it does for block containers.
</p>

<p>
`絶対~位置決め$は、
`格子$とその`~flow内$にある内容の~layout後に生じるので、
格子~筋の~sizingに何も供与せず，格子の［
~size／~~構成
］に影響することもない。
`格子~配置~prop$が，存在しない罫を指している場合
— 明示的に そのような罫を指定しているか, 既存の`暗黙的な罫$の外側まで~spanしている場合 —
代わりに `~autoP$v【！auto】 を指定しているものと扱われる
（新たな`暗黙的な罫$は作成されない）。
◎
Absolute positioning occurs after layout of the grid and its in-flow contents, and does not contribute to the sizing of any grid tracks or affect the size/configuration of the grid in any way. If a grid-placement property refers to a non-existent line either by explicitly specifying such a line or by spanning outside of the existing implicit grid, it is instead treated as specifying auto (instead of creating new implicit grid lines).
</p>

<p class="note">注記：
`暗黙的な罫$は、
【その生成-時に付与される】すべての`罫~名$を持つものと見做されることに注意。
なので，参照された罫は、
明示的に命名されていない罫であっても，存在するかもしれない。
◎
Note: Remember that implicit lines are assumed to have all line names, so a referenced line might exist even though it is not explicitly named.
</p>

<p>
`配置$が`~span数$のみを包含する場合、
それを［
その軸における 2 個の `~autoP$v 罫
］に置換する。
（これは、
次のいずれにおいても起こる：
ある軸の`格子~配置~prop$が
元々の~spanを供与したとき, あるいは
`§ 格子~配置における競合の取扱い＠#grid-placement-errors$により，
2 個目の~spanが無視されるとき。）
◎
If the placement only contains a grid span, replace it with the two auto lines in that axis. (This happens when both grid-placement properties in an axis contributed a span originally, and § 8.3.1 Grid Placement Conflict Handling caused the second span to be ignored.)
</p>

		</section>
		<section id="static-position">
<h3 title="With a Grid Container as Parent">10.2. 親が格子~容器であるとき</h3>

<p>
`格子~容器$の子のうち，`絶対的に位置され$たものは、
~flow外であり，`格子~駒$ではないので、
格子の他の駒の配置や~sizingには影響しない。
◎
An absolutely-positioned child of a grid container is out-of-flow and not a grid item, and so does not affect the placement of other items or the sizing of the grid.
</p>

<p>
`格子~容器$の子が`絶対的に位置され$ている場合、
その`静的~位置$は，［
それが`区画$の中で 唯一の格子~駒である, かつ
その各~辺が格子~容器の内容~辺に~~一致している
］かのように決定される。
◎
The static position [CSS2] of an absolutely-positioned child of a grid container is determined as if it were the sole grid item in a grid area whose edges coincide with the content edges of the grid container.
</p>

<p class="note">注記：
この位置は、
子の`自己-整列~prop$の値に影響されることに注意。
他のほとんどの~layout~modelと同様、
`絶対的に位置され$た子は，
包含塊の~sizeや内容の~layoutには効果は無い。
◎
Note: Note that this position is affected by the values of justify-self and align-self on the child, and that, as in most other layout models, the absolutely-positioned child has no effect on the size of the containing block or layout of its contents.
</p>

		</section>
	</section>
	<section id="alignment">
<h2 title="Alignment and Spacing">11. 整列とアキ</h2>

<p>
`格子~容器$の`筋$が~sizeされ，`格子~駒$の~sizeが両~次元とも完結したなら、
`格子~駒$をそれらの`区画$内で整列できるようになる。
◎
After a grid container’s grid tracks have been sized, and the dimensions of all grid items are finalized, grid items can be aligned within their grid areas.
</p>

<p class="note">注記：
`下位格子$の`格子~駒$は、
`親~格子$の駒と一緒に，`整列に関与する＠#subgrid-item-contribution$
— `基底線~整列$も含めて。
◎
Note: The grid items of subgrids participate in alignment, including baseline alignment, together with their parent grid's items; see Subgrids (h).
</p>

<p>
`margin$p ~propを、［
塊~layoutで~marginが行えるものに類似な方式
］で駒を整列させるために利用できる。
`格子~駒$の整列においては，
`CSS-ALIGN-3$r 仕様による各種`~box整列~prop$も加味される。
それにより，駒の整列は、［
~row, ~col
］両方に対し，~keywordに基づいて容易に行えるようになる。
◎
The margin properties can be used to align items in a manner similar to what margins can do in block layout. Grid items also respect the box alignment properties from the CSS Box Alignment Module [CSS-ALIGN-3], which allow easy keyword-based alignment of items in both the rows and columns.
</p>

<p>
既定では、
`格子~駒$は，自身が占める`区画$を埋めるように伸張する。
しかしながら、
`自己-整列~prop$が `stretch^v 以外の値に算出される場合,
あるいは `margin^p が `auto^v に算出される場合、
`格子~駒$は，それらの内容に収まるように自動-~sizeされることになる。
◎
By default, grid items stretch to fill their grid area. However, if justify-self or align-self compute to a value other than stretch or margins are auto, grid items will auto-size to fit their contents.
</p>

		<section id="gutters">
<h3  title="Gutters: the row-gap, column-gap, and gap properties">11.1. 側溝： `column-gap^p, `row-gap^p, `gap^p ~prop</h3>

<p>
`格子~容器$に［
`row-gap$p ／ `column-gap$p
］~prop（あるいは，対応する `gap$p 略式~prop）が指定された場合、
各［
`格子~row$ ／ `格子~col$
］間の`側溝$を定義する。
それらの構文は、
`CSS-ALIGN-3$r `§ ~box間の~gap＠~CSSALIGN#gaps$
にて定義される。
◎
The row-gap and column-gap properties (and their gap shorthand), when specified on a grid container, define the gutters between grid rows and grid columns. Their syntax is defined in CSS Box Alignment 3 § 8 Gaps Between Boxes.
</p>

<p>
これらの~propの効果は、
影響される`罫$が太さを獲得するかのようになる：
`筋$を挟む 2 本の`罫$を表現する`側溝$の合間が，その`筋$の空間になる。
`§ 筋の~sizing＠#algo-track-sizing$
の目的においては、
各`側溝$は，指定d~sizeによる［
余分な, 空な, 固定d~sizeな
］筋として扱われ、
対応する`罫$をまたがって~spanする格子~駒は，側溝にも~spanする。
◎
The effect of these properties is as though the affected grid lines acquired thickness: the grid track between two grid lines is the space between the gutters that represent them. For the purpose of track sizing, each gutter is treated as an extra, empty, fixed-size track of the specified size, which is spanned by any grid items that span across its corresponding grid line.
</p>

<p class="note">注記：
`内容-分布~prop$に因り、
各~筋の合間には，空間が追加され得る。
`格子~sizing~algo$を見よ。
この空間は、
実質的に`側溝$の~size（太さ）を増やす。
◎
Note: Additional spacing may be added between tracks due to justify-content/align-content. See § 12.1 Grid Sizing Algorithm. This space effectively increases the size of the gutters.
</p>

<p>
`格子$が筋~間で`断片化-$されている場合、
そのような筋~間における`側溝$によるアキは，
抑止するモノトスル。
<span class="note">注記：
~marginと違って、
側溝は，強制d分断~後でも抑止される。
</span>
◎
If a grid is fragmented between tracks, the gutter spacing between those tracks must be suppressed. Note that gutters are suppressed even after forced breaks, unlike margins.
</p>

<p>
`側溝$が現れるのは，`暗黙的な格子$を成す筋たちの合間に限られ、［
最初の筋より前／最後の筋より後
］には側溝はない
（特に，［
`暗黙的な格子$を成す［
最初／最後
］の筋
］と［
`増補~格子$を成す［
最初／最後
］の “自動” 罫
］との合間には、
側溝はない）
◎
Gutters only appear between tracks of the implicit grid; there is no gutter before the first track or after the last track. (In particular, there is no gutter between the first/last track of the implicit grid and the “auto” lines in the augmented grid.)
</p>

<p>
筋が`畳まれ$る結果，その両~側の側溝が
`畳まれ@gut
る場合、
両 側溝は，［
互いの始端~辺, 互いの終端~辺
］が正確に一致するように重合する。
`畳まれ$た筋の一方の側に側溝がない場合
（例： `暗黙的な格子$の［
最初／最後
］の筋）、
`畳まれ$た筋のどちら “側” の側溝もなくなる。
◎
When a collapsed track’s gutters collapse, they coincide exactly—the two gutters overlap so that their start and end edges coincide. If one side of a collapsed track does not have a gutter (e.g. if it is the first or last track of the implicit grid), then collapsing its gutters results in no gutter on either “side” of the collapsed track.
</p>

		</section>
		<section id="auto-margins">
<h3 title="Aligning with auto margins">11.2. `auto^v ~marginによる整列-法</h3>

<p>
`格子~駒$に対する自動`~margin$（ `auto^v ~margin ）の効果は、
`塊~layout$における自動~marginによる効果によく似る：
◎
Auto margins on grid items have an effect very similar to auto margins in block layout:
</p>
<ul>
	<li>
`筋$~sizeを計算する目的においては、
`auto^v ~marginは `0^v として扱われる。
◎
During calculations of grid track sizes, auto margins are treated as 0.
</li>
	<li>
`塊~layout$の`行内-軸$用に定義されるとおり
（ `CSS2$r `§ 通常~flow内にある塊~levelの置換されない要素＠~CSS2J#blockwidth$を見よ）、
`auto^v ~marginは
— どちらの軸においても，整列に先立って，`~box整列~prop$を介して —
正な~free空間を吸収する
— それにより，当の軸における`自己-整列~prop$の効果を不能化する。
◎
As defined for the inline axis of block layout (see CSS2§10.3.3), auto margins in either axis absorb positive free space prior to alignment via the box alignment properties, thereby disabling the effects of any self-alignment properties in that axis.
</li>
	<li>
~overflowしている`格子~駒$の `auto^v ~marginは 0 に解決され、
各種`~box整列~prop$に指定されるように~overflowする。
◎
Overflowing grid items resolve their auto margins to zero and overflow as specified by their box alignment properties.
</li>
</ul>

		</section>
		<section id="row-align">
<h3 title="Inline-axis Alignment: the justify-self and justify-items properties">11.3. 行内-軸~方向の整列： `justify-self^p, `justify-items^p ~prop</h3>

<p>
`格子~駒$は、［
`CSS-ALIGN-3$r にて定義される
`格子~駒$の `justify-self$p ~prop
］や［
`格子~容器$の `justify-items$p ~prop
］を利用して，行内~次元に整列できる。
◎
Grid items can be aligned in the inline dimension by using the justify-self property on the grid item or justify-items property on the grid container, as defined in [CSS-ALIGN-3].
</p>

<div class="example">
<p>
例えば，英語~文書では，行内-軸は横方向になるので、
`justify-*^p ~propは、
`格子~駒$を横方向に整列する。
◎
For example, for an English document, the inline axis is horizontal, and so the justify-* properties align the grid items horizontally.
</p>
</div>

<p id="_baseline-and-dependency">
`格子~駒$ %駒 の~sizeが，内在的に~sizeされた`筋$†の~sizeに依存していて、
その軸において %駒 に`基底線~整列$ %整列 が指定されている場合††
（したがって，筋の~sizeは、
%駒 の~sizeと %整列 の両者に依存する結果，循環依存が生じる）、
%駒 は %整列 には関与せず，代わりに %整列 の`~fallback整列$が
— 元々指定されていたかのように —
利用されるとする。
この目的においては、
`格子~容器$の~sizeが関連な軸において`不定$であるときは，
`flex$t 筋~sizeは “内在的に~sizeされた” ものと数えられる。
【† この場合は~col筋 — 同じ~col筋を共有する駒たちの基底線が整列される。】
【†† すなわち、これらの~propに `baseline^v ~keywordが指定されている場合。】
◎
If baseline alignment is specified on a grid item whose size in that axis depends on the size of an intrinsically-sized track (whose size is therefore dependent on both the item’s size and baseline alignment, creating a cyclic dependency), that item does not participate in baseline alignment, and instead uses its fallback alignment as if that were originally specified. For this purpose, &lt;flex&gt; track sizes count as “intrinsically-sized” when the grid container has an indefinite size in the relevant axis.
</p>

<p class="note">注記：
~fallback整列が利用されるかどうかは、
~layout全体にわたり変化しない
— 循環は、
存在するならば存在し続ける。
◎
Note: Whether the fallback alignment is used or not does not change over the course of layout: if a cycle exists, it exists.
</p>

		</section>
		<section id="column-align">
<h3 title="Block-axis Alignment: the align-self and align-items properties">11.4. 塊-軸~方向の整列： `align-self^p, `align-items^p ~prop</h3>

<p>
`格子~駒$は、［
`CSS-ALIGN-3$r に定義される
`格子~駒$の `align-self$p ~prop
］や［
`格子~容器$の `align-items$p ~prop
］を利用して，（行内~次元に垂直な）塊~次元にも整列できる。
◎
Grid items can also be aligned in the block dimension (perpendicular to the inline dimension) by using the align-self property on the grid item or align-items property on the grid container, as defined in [CSS-ALIGN-3].
</p>

<p>
`前~節に述べた~fallback整列＠#_baseline-and-dependency$に関する要件は、
これらの~propにも
— ~row筋を~col筋に置き換えて —
適用される。
◎
If baseline alignment is specified on a grid item whose size in that axis depends on the size of an intrinsically-sized track (whose size is therefore dependent on both the item’s size and baseline alignment, creating a cyclic dependency), that item does not participate in baseline alignment, and instead uses its fallback alignment as if that were originally specified. For this purpose, &lt;flex&gt; track sizes count as “intrinsically-sized” when the grid container has an indefinite size in the relevant axis.
</p>

		</section>
		<section id="grid-align">
<h3 title="Aligning the Grid: the justify-content and align-content properties">11.5. 格子の整列-法： `justify-content^p, `align-content^p ~prop</h3>

<p>
`格子$の外縁~辺が`格子~容器$ %容器 の内容~辺に対応しない場合
（例えば，~flexに~sizeされる~colが無いとき）、
%容器 内の`筋$たちは，
%容器 の`内容-分布~prop$に則って %容器 の`内容~box$内で整列される。
◎
If the grid’s outer edges do not correspond to the grid container’s content edges (for example, if no columns are flex-sized), the grid tracks are aligned within the content box according to the justify-content and align-content properties on the grid container.
</p>

<div class="example">
<p>
例えば次の格子は、
縦方向に中央寄せにされ，その`格子~容器$の右~辺に整列される：
◎
For example, the following grid is centered vertically, and aligned to the right edge of its grid container:
</p>

<pre class="lang-css">
.grid {
  display: grid;
  grid: 12rem 12rem 12rem 12rem / 10rem 10rem 10rem 10rem;
  justify-content: end;
  align-content: center;
  min-height: 60rem;
}
</pre>

<figure>
<div style="width:310px; height:261px; padding:5px 0 5px 5px; border:solid 3px var(--N-color); background:var(--bg-color-1); font-size:18px;">
<div style="height:30px; color:gray;">格子~容器</div>
<div style="position:relative;left:69px;top:0;">
<div style="position:absolute; padding:5px;">格子</div>
`align-justify-content^dgm
</div></div>
</figure>
</div>

<p>
格子に`筋$が 1 本もない場合
（`明示的な格子$は空であり，`暗黙的な格子$により作成される筋もない）、
各~軸における唯一の`罫$は，`格子~容器$の始端~辺に整列される。
◎
If there are no grid tracks (the explicit grid is empty, and no tracks were created in the implicit grid), the sole grid line in each axis is aligned with the start edge of the grid container.
</p>

<p>
`内容-分布~prop$がとる一部の値は、
筋~間を互いに離したり
（ `space-around$v, `space-between$v, `space-evenly$v ），
筋を~sizeし直す（ `~stretchAC$v ）ことに注意。
`格子$が筋~間で`断片化-$されている場合、
筋~間におけるそのような追加的なアキは，抑止するモノトスル。
◎
Note that certain values of justify-content and align-content can cause the tracks to be spaced apart (space-around, space-between, space-evenly) or to be resized (stretch). If the grid is fragmented between tracks, any such additional spacing between those tracks must be suppressed.
</p>

<div class="example">
<p>
例えば，次の格子では、
整列に因り，余分な空間が側溝にアテガわれているため、
駒が~spanする区画は，それを収容するように増やされている：
◎
For example, in the following grid, the spanning item’s grid area is increased to accommodate the extra space assigned to the gutters due to alignment:
</p>

<pre class="lang-css">
.wrapper {
  display: grid;
  /* <span class="comment">
4 本の~col, 3 本の~rowからなる格子~容器
◎
3-row / 4-column grid container
</span> */
  grid: repeat(3, auto) / repeat(4, auto);
  gap: 10px;
  align-content: space-around;
  justify-content: space-between;
}

.item1 { grid-column: 1 / 5; }
.item2 { grid-column: 1 / 3; grid-row: 2 / 4; }
.item3 { grid-column: 3 / 5; }
/* <span class="comment">
最後の 2 個の駒は最後の 2 個の升に自動-配置される
◎
last two items auto-place into the last two grid cells
</span> */
</pre>

<figure>`spanned-gap^dgm
<figcaption>
整列~前の格子 :
格子は `gap$p により~gap `10px^v がとられていて、
要素たちは すべての~colに~spanしている。
各~colの横幅の総和は、
格子~容器の横幅より小さい。
◎
alt=
Grid with 10px gap and an element spanning all columns. The sum of the columns is less than the width of the grid container.
◎
Grid before alignment
</figcaption></figure>

<figure>`spanned-gap-align^dgm
<figcaption>
整列~後の格子：
格子~容器を超過した横幅を吸収するように~gapが増やされた，同じ格子。
複数の~colに~spanしている要素は、
それが交叉する~gapにアテガわれた余った空間を収容するため，拡幅される。
◎
alt=
Same grid with increased gaps absorbing the excess grid container width. The spanning element has grown to accommodate the extra space assigned to the gap it crosses.
◎
Grid after alignment
</figcaption></figure>

<p>
整列は、
各~筋が~sizeされた後に起こることに注意
（ `gap$p によるアキと違って）。
よって、
筋~sizeが，そこに~spanしている駒の内容から決定される場合、
その筋が［
整列によるアキを収容するよう 超過した空間を得る
］のは，整列の~~段階になる。
◎
Note that alignment (unlike gap spacing) happens after the grid tracks are sized, so if the track sizes are determined by the contents of the spanned item, it will gain excess space in the alignment stage to accommodate the alignment spacing.
</p>
</div>

		</section>
		<section id="grid-baselines">
<h3 title="Grid Container Baselines">11.6. 格子~容器の基底線</h3>

<p>
`格子~容器$ %容器 の【~row（行内-軸）沿いの】［
最初／最後
］の`基底線$は、
次に従って決定される
—  %容器 の［
`最初の基底線~集合$／`最後の基底線~集合$
］【！`基底線~集合$】は、
結果の基底線から`生成される$ことになる
（以下における各 ［
“最初…” ／ “最後…”
］は、
同順とする）：
◎
The first (last) baselines of a grid container are determined as follows:
</p>
<ol>
	<li>
<p>
~IF［
%容器 内に 1 個以上の`格子~駒$が在る
］：
</p>
		<ol>
			<li>
%~row ~LET %容器 を成す［
1 個以上の`格子~駒$が交差している~row
］のうち［
最初／最後
］のもの
⇒

◎
Find the first (last) row of the grid container containing at least one grid item.
</li>
			<li>
~IF［
%~row に交差している`格子~駒$のうち［
%~row における［
`最初の基底線による整列$／`最後の基底線による整列$【！`基底線~整列$】
］に関与するもの
］は在る
］
⇒＃
~RET 該当する駒たちが共有する`整列~基底線$
◎
If any of the grid items intersecting this row participate in baseline alignment in that row, the grid container’s baseline set is generated from the shared alignment baseline of those grid items.
</li>
			<li>
%駒 ~LET %容器 内の［
最初／最後
］の駒
— ~row主導による`格子~順序$で（ %容器 の`書字~mode$に則って）
◎
↓</li>
			<li>
~IF［
%容器【！格子】 の行内-軸において，
%駒 は`整列~基底線$を持つ
］
⇒
~RET その基底線
◎
Otherwise, the grid container’s first (last) baseline set is generated from the alignment baseline of the first (last) grid item in row-major grid order (according to the writing mode of the grid container).＼
</li>
			<li>
~ELSE
⇒
~RET %駒 の`~border~box$から`合成-$される基底線
◎
If the grid item has no alignment baseline in the grid’s inline axis, then one is first synthesized from its border edges.
</li>
		</ol>
	</li>
	<li>
~ELSE
（ %容器 内に`格子~駒$は無く、
%容器 は`基底線~集合$を持たない）
⇒
~RET %容器 が属する`整列~文脈$の規則に則って`合成-$される基底線
◎
If the grid container does not contain any grid items, the grid container has no first (last) baseline set, and one is synthesized if needed according to the rules of its alignment context. Exit from this algorithm.
</li>
</ol>

<p>
`格子~順序@
— “格子により改変された文書~順序” —
とは、
格子の各`升$を辿るときに，`格子~駒$に遭遇する順序である。
複数の駒に同時に遭遇する【同じ升に重合している】場合は，
`order$p により`改変された文書~順序$に従う。
◎
Grid-modified document order (grid order) is the order in which grid items are encountered when traversing the grid’s grid cells. If two items are encountered at the same time, they are taken in order-modified document order.
</p>

<p>
上の規則に則って基底線を計算する際に，
基底線を供与している~boxの `overflow$p が~scrollを許容する値をとる場合、
その~boxは，［
基底線を決定する目的においては，その初期~scroll位置に在る
］と扱うモノトスル。
◎
When calculating the baseline according to the above rules, if the box contributing a baseline has an overflow value that allows scrolling, the box must be treated as being in its initial scroll position for the purpose of determining its baseline.
</p>

<p>
`table-cell^v の`基底線を決定する＠~CSS2TABLE#height-layout$ときには、
`行l~box$や `table-row^v のときと同じく，
格子~容器が基底線を供する。
`CSS2$r
◎
When determining the baseline of a table cell, a grid container provides a baseline just as a line box or table-row does. [CSS2]
</p>

<p>
基底線についての詳細は、
CSS Writing Modes 3 の
`§ 基底線 — 序論＠~CSSWM#intro-baselines$,
および CSS Alignment の
`§ 基底線~整列の詳細＠~CSSALIGN#baseline-rules$
を見よ。
◎
See CSS Writing Modes 3 § 4.1 Introduction to Baselines and CSS Box Alignment 3 § 9 Baseline Alignment Details for more information on baselines.
</p>

		</section>
	</section>
	<section id="layout-algorithm">
<h2 title="Grid Layout Algorithm">12. 格子~layout~algo</h2>

<p>
この節は、
`格子~layout~algo^bを定義する
— それは
⇒＃
`格子~容器$を~sizeする,
すべての`格子~筋$を~sizeして位置する,
`格子~区画$の中へ`配置した＠#grid-item-placement-algorithm$各`格子~駒$を~lay-outする
◎
This section defines the grid layout algorithm, which sizes the grid container, sizes and positions all the grid tracks, and lays out the grid items which have been placed into its grid areas.
</p>
<ol>
	<li>
`格子~駒の配置~algo$を走らす
— これは、
`格子$内のすべての`格子~駒$の配置を解決する
（各`下位格子$, それらの下位-駒も含めて）。
◎
Run the Grid Item Placement Algorithm to resolve the placement of all grid items (including subgrids and their sub-items) in the grid.
</li>
	<li>
<p>
`§ 格子~容器の~sizing＠#intrinsic-sizes$により，
`格子~容器$の~sizeを見出す。
◎
Find the size of the grid container, per § 5.2 Sizing Grid Containers.
</p>

<p class="note">注記：
この~~段階の間は、
筋~sizeにおける循環な `percentage$t は， `auto$vt として扱われる。
◎
Note: During this phase, cyclic &lt;percentage&gt;s in track sizes are treated as auto.
</p>
	</li>
	<li>
<p>
`格子~sizing~algo$を［
前段の結果による`格子~容器$の~size
］を与える下で走らすことにより、
当の`格子$を~sizeする。
◎
Given the resulting grid container size, run the Grid Sizing Algorithm to size the grid.
</p>

<p class="note">注記：
この~~段階の間は、
筋~sizeにおける `percentage$t は，
当の`格子~容器$の~sizeを~~基準に解決される。
◎
Note: During this phase, &lt;percentage&gt;s in track sizes are resolved against the grid container size.
</p>
	</li>
	<li>
<p>
各 `格子~駒$を各自の包含塊の中へ~lay-outする。
この目的においては、
各 `格子~区画$の［
横幅／縦幅
］は`確定的$と見なされる。
◎
Lay out the grid items into their respective containing blocks. Each grid area’s width and height are considered definite for this purpose.
</p>

<p class="note">注記：
`収まるよう伸張-$する公式など，
各~公式は確定的~sizeのみを利用して計算されるので、
結果の伸張された格子~駒の~sizeも確定的と見なされる。
◎
Note: Since formulas calculated using only definite sizes, such as the stretch fit formula, are also definite, the size of a grid item which is stretched is also considered definite.
</p>
	</li>
</ol>

		<section id="algo-grid-sizing">
<h3 title="Grid Sizing Algorithm">12.1. 格子~sizing~algo</h3>

<p>
この節では、
`格子~sizing~algo^bを定義する
— それは、
すべての`筋$の~sizeを決定して，
それに伴い格子~全体の~sizeを決定する。
◎
This section defines the grid sizing algorithm, which determines the size of all grid tracks and, by extension, the entire grid.
</p>

<p>
各~筋には，
`~min筋~sizing関数$,
`~max筋~sizing関数$
（同じにもなり得る）が指定されている。
それぞれ，次のいずれかに~~分類される：
◎
Each track has specified minimum and maximum sizing functions (which may be the same). Each sizing function is either:
</p>

<ul>
	<li>
`固定的~sizing関数@
— 次のいずれか
⇒＃
`length$t ／
解決-可能な `percentage$t
◎
A fixed sizing function (&lt;length&gt; or resolvable &lt;percentage&gt;).
</li>
	<li>
`内在的~sizing関数@
— 次のいずれか
⇒＃
`min-content$vt ／
`max-content$vt ／
`auto$vt ／
`fit-content$f
◎
An intrinsic sizing function (min-content, max-content, auto, fit-content()).
</li>
	<li>
`~flex可能な~sizing関数@
⇒
`flex$t
◎
A flexible sizing function (&lt;flex&gt;).
</li>
</ul>

<p>
`格子~sizing~algo$は、［
これらの~sizingによる拘束
］を［
筋の使用~size
］に解決する方法を定義する。
◎
The grid sizing algorithm defines how to resolve these sizing constraints into used track sizes.
</p>
<ol>
	<li>
<p>
`筋~sizing~algo$により，一連の`格子~col$の~sizeを解決する
— この処理nにおいては：
◎
First, the track sizing algorithm is used to resolve the sizes of the grid columns.
</p>
		<ul>
			<li>
<p>
`格子~駒$ %駒 のうち，`格子~容器$ %容器 の`下位格子$を成すものに対しては：
◎
↓</p>
				<ul>
					<li>
%駒 は %容器 の`行内-軸$において`下位格子~化$されている場合
⇒
%駒 を空として扱うとともに、
%駒 の`格子~駒$（ %容器 の子の子）は %容器 の直な子として扱う。
この掘下げは再帰的になる。
◎
In this process, any grid item which is subgridded in the grid container’s inline axis is treated as empty and its grid items (the grandchildren) are treated as direct children of the grid container (their grandparent). This introspection is recursive.
</li>
					<li>
<p>
他の場合（ %駒 は %容器 の`塊-軸$に限り`下位格子~化$されている場合）
⇒
`格子~容器$としての %駒
— 以下 %下位格子 —
の［
%容器 の`行内-軸$
］における~sizeが %駒 の内容の~sizeに依存する場合もまた、
掘下げられる
⇒
この次元における %駒 の~sizeは，［
他方の次元における， %下位格子 の`下位格子~化$された筋
］の~sizingに依存し得るので、［
%駒 が %容器 の~col~sizingに供与する~size
］は
（ `§ 内在的な筋~sizeを解決する＠#algo-content$を見よ）、
［［
`格子~sizing~algo$を【 %下位格子 に対し適用するとき，】
これ【 %容器 】自身と同じ地点
］までに限り，それ【 %下位格子 】の筋~sizingは決定-済みである
］とする下で得られるとする。
例：
1 周回~目に，この最初の段を経るときには，
%下位格子 の各~筋は、
この段のみを通して~sizeされることになり、
2 周回~目にこの段が誘発された場合、
%下位格子 は
— %格子 の~col~sizingを考慮するためにそれ【 %駒 】の~sizeを返すに先立って —
1 周回~目における段 1 〜 3, および 
2 周回~目における この段を完了したことになる。
この掘下げもまた，再帰的になる。
◎
Items which are subgridded only in the block axis, and whose grid container size in the inline axis depends on the size of its contents are also introspected:＼
since the size of the item in this dimension can be dependent on the sizing of its subgridded tracks in the other, the size contribution of any such item to this grid’s column sizing (see Resolve Intrinsic Track Sizes) is taken under the provision of having determined its track sizing only up to the same point in the Grid Sizing Algorithm as this itself.＼
E.g. for the first pass through this step, the item will have its tracks sized only through this first step; if a second pass of this step is triggered then the item will have completed a first pass through steps 1-3 as well as the second pass of this step prior to returning its size for consideration in this grid’s column sizing. Again, this introspection is recursive.
</p>

<p class="trans-note">【
原文の~~行間情報が多いので、
この段落の和訳は，おそらく この仕様が意図する~modelを正しく反映し切れていない。
】</p>

				</li>
				</ul>
			</li>
			<li>
`格子~駒$の~layoutの計算が `塊-軸$において`可用な空間$に依存する場合、
`可用な空間$は，［
各~rowの~sizeが次に与える~sizeであった
］とするときのそれと見做す
⇒＃
`確定的$な`~max筋~sizing関数$を伴う~rowは その~size ／
他のすべての~rowは 無限大
◎
If calculating the layout of a grid item in this step depends on the available space in the block axis, assume the available space that it would have if any row with a definite max track sizing function had that size and all other rows were infinite.＼
</li>
			<li>
`格子~容器$も, それを成すどの~rowの~sizeも`確定的$である場合、
`align-content$p も適用して，そのような駒が~spanする各~row~gapの最終的な実効~sizeを見出す。
他の場合、
この見積もりにおいては，筋~整列による効果を無視する。
【！↓ track = row 】
◎
If both the grid container and all tracks have definite sizes, also apply align-content to find the final effective size of any gaps spanned by such items; otherwise ignore the effects of track alignment in this estimation.
</li>
		</ul>
	</li>
	<li>
<p>
`筋~sizing~algo$により，一連の`格子~row$の~sizeを解決する
— この処理nにおいては：
◎
Next, the track sizing algorithm resolves the sizes of the grid rows.
</p>
		<ul>
			<li>
<p>
`格子~駒$ %駒 のうち，`格子~容器$ %容器 の`下位格子$を成すものに対しては：
◎
↓</p>
				<ul>
					<li>
%駒 は %容器 の`塊-軸$において`下位格子~化$されている場合
⇒
%駒 を空として扱うことに加え、
%駒 の`格子~駒$（ %容器 の子の子）は， %容器 の直な子として扱う。
この掘下げは再帰的である。
◎
In this process, any grid item which is subgridded in the grid container’s block axis is treated as empty and its grid items (the grandchildren) are treated as direct children of the grid container (their grandparent). This introspection is recursive.
</li>
					<li>
他の場合
（ %駒 は %容器 の`行内-軸$に限り`下位格子~化$されている場合）
⇒
%容器 の`塊-軸$における［
%駒 の~size
］のうち［
%駒 の内容の~size
］に依存するものも掘下げられる。
（~col~sizingのときと同じく、
%駒 が，この格子の~row~sizingに供与する~sizeは、［
`格子~sizing~algo$【！the algorithm】における この対応している地点までに限られ，
それの筋~sizingは決定-済みである
］とする下で得られるとする
— この掘下げもまた、再帰的である。）
◎
As with sizing columns, items which are subgridded only in the inline axis, and whose grid container size in the block axis depends on the size of its contents are also introspected. (As with sizing columns, the size contribution to this grid’s row sizing is taken under the provision of having determined its track sizing only up to this corresponding point in the algorithm; and again, this introspection is recursive.)
</li>
				</ul>
			</li>
			<li>
駒の`塊-軸$~size供与を得るために`行内-軸$に`可用な空間$が要求される所では、
前~段にて計算した`格子~col$の~sizeを利用して，それを見出す。
◎
To find the inline-axis available space for any items whose block-axis size contributions require it, use the grid column sizes calculated in the previous step.＼
</li>
			<li>
`格子~容器$の`行内~size$は`確定的$である場合、
~col~gapの実効~sizeも織り込むため `justify-content$p も適用する。
◎
If the grid container’s inline size is definite, also apply justify-content to account for the effective column gap sizes.
</li>
		</ul>
	</li>
	<li>
<p>
ある格子~駒の`最小-内容~供与$が，前~段にて計算した~row~sizeと整列に基づいて変化した場合
⇒
新たな［
`最小-内容~供与$, `最大-内容~供与$
］の下で，`格子~col$の~sizeを解決し直す（一度限り）
— 次に従う下で：
◎
Then, if the min-content contribution of any grid item has changed based on the row sizes and alignment calculated in step 2, re-resolve the sizes of the grid columns with the new min-content and max-content contributions (once only).
</p>
		<ul>
			<li>
駒の`行内-軸$~size供与を得るために`塊-軸$に`可用な空間$が要求される所では、
前~段にて計算した`格子~row$の~sizeを利用して，それを見出す。
◎
To find the block-axis available space for any items whose inline-axis size contributions require it, use the grid row sizes calculated in the previous step.＼
</li>
			<li>
`格子~容器$の`塊~size$は`確定的$である場合、
~row~gapの実効~sizeも織り込むため `align-content$p も適用する。
◎
If the grid container’s block size is definite, also apply align-content to account for the effective row gap sizes.
</li>
		</ul>

<div class="note">

<p>注記：
この繰返nは、
`格子~駒$の`行内~size$が，それが占める`区画$の`塊~size$に依存するとき必要yである。
例えば、
次に挙げるとき：
</p>
<ul>
	<li>
折返される~col`~flex容器$
（ <code class="css">`flex-flow$p: `column wrap^v;</code> ）
</li>
	<li>
`直交~flow$（ `writing-mode$p ）
</li>
	<li>
`複柱~容器$
</li>
	<li>
縦横比【！aspect-ratio】を伴う（または，子に縦横比を伴うものがある）駒のうち，その~sizeは~rowの~sizeに依存するもの
</li>
</ul>
◎
This repetition is necessary for cases where the inline size of a grid item depends on the block size of its grid area. Examples include wrapped column flex containers (flex-flow: column wrap), orthogonal flows (writing-mode), multi-column containers, and items with an aspect-ratio (or with a child with an aspect ratio) whose size depends on the size of the row.
</div>
	</li>
	<li>
<p>
ある`格子~駒$の`最小-内容~供与$が，前~段にて計算した［
一連の~col~sizeと整列
］に基づいて変化した場合
⇒
新たな［
`最小-内容~供与$, `最大-内容~供与$
］の下で，一連の`格子~row$の~sizeを解決し直す（一度限り）
— 次に従う下で：
◎
Next, if the min-content contribution of any grid item has changed based on the column sizes and alignment calculated in step 3, re-resolve the sizes of the grid rows with the new min-content and max-content contributions (once only).
</p>
		<ul>
			<li>
駒の`塊-軸$~size供与を得るために`行内-軸$に`可用な空間$が要求される所では、
前~段にて計算した`格子~col$の~sizeを利用して，それを見出す。
◎
To find the inline-axis available space for any items whose block-axis size contributions require it, use the grid column sizes calculated in the previous step.＼
</li>
			<li>
`格子~容器$の`行内~size$は`確定的$である場合、
~col~gapの実効~sizeも織り込むため `justify-content$p も適用する。
◎
If the grid container’s inline size is definite, also apply justify-content to account for the effective column gap sizes.
</li>
		</ul>
	</li>
	<li>
<p>
`格子~容器$の中の筋たちを`内容-分布~prop$に則って整列する。
◎
Finally, align the tracks within the grid container according to the align-content and justify-content properties.
</p>

<p class="note">注記：
これは，筋と筋の合間に余分な空間を導入し得るので、
その~gapに~spanしている駒の区画は，［
筋を~sizeしている間に 割り当てられた空間
］を超えて~~拡げられ得る。
◎
Note: This can introduce extra space between tracks, potentially enlarging the grid area of any grid items spanning the gaps beyond the space allotted to during track sizing.
</p>
	</li>
</ol>

<p class="note">注記：
`下位格子~化$された各~筋の~sizingは、
そのような筋を占める各~駒を，`親~格子$の駒として扱う。
この織り交ぜ法は、
格子~sizingは
— 再帰するに伴い，両~軸とも完了するのではなく —
軸ごとに`下位格子$の中へ掘り下げることを要求する。
このことは、
次を意味することに注意
⇒
`下位格子$が`直交~flowを確立して$いる場合、
下位格子の筋たちを~sizeする順序は`入子な格子$とは逆になる。
【下位格子の［~row, ~col］を~sizeする順序は，親~格子とは逆になる？】
◎
Note: Track sizing in a subgridded dimension treats each item in a given track in that axis as members of the parent grid. This interlacing requires that grid sizing drill down per axis into subgrids, rather than completing both axes as it recurses. Note this means that a subgrid establishing an orthogonal flow would have the order of its track sizing inverted compared to a nested grid.
</p>

<div class="example">
<p>
下位格子が軸ごとに どう~sizeされるかを，次の例で~~説明する：
◎
The following example illustrates how per-axis subgrids are sized:
</p>

<p class="trans-note">【
この例の記述では、
どの下位格子も，［
縦組み／横組み
］どちらであるかは親~格子のそれと一致すると見做される。
】</p>

<p>
%A は`格子~容器$とする。
%A は駒 %B を包含していて，
%B は~colが`下位格子~化$されていて，
%B は %A の子の子として駒 %C【！%B】, %D を包含していて，
%C は~rowが`下位格子~化$されていて，
%D は単純に`自立的な格子$【！入子な格子】であるとする。
◎
Suppose we have a parent grid container A which contains an item B that has subgridded columns and contains a grandchild B that has subgridded rows and grandchild D that is simply a nested grid.
</p>

<pre class="lang-html">
&lt;grid-A&gt;
  &lt;grid-B subgrid=columns&gt;
    &lt;grid-C subgrid=rows&gt;&lt;/grid-C&gt;
    &lt;grid-D&gt;&lt;/grid-D&gt;
  &lt;/grid-B&gt;
&lt;grid-A&gt;
</pre>

<p>
%A の各~colを~sizeするときには，［
%B の各~駒を %A 内の対応する~colの中へ嵌込まれたもの
］として扱う一方で、
%A の各~rowを~sizeするときには，
%B を単独の駒
（自前の~rowを伴う格子~容器であって，駒 %C, %D を含んでいる何らかの駒）
として扱う。
類似に、
%B の各~rowを~sizeするときは，［
%C の各~駒を %B 内の対応する~rowの中へ嵌込まれたもの
］として扱う一方で、
%B の各~colを~sizeするときは，
%C を
— %D 対するときと同じく —
単独の駒として扱う。
%C に属する~rowと %A に属する~rowの間に関係性は無い
— %B に属する~rowは、
入子にされていても，`下位格子~化$されてはいないので。
◎
When A sizes its columns it treats B’s items as slotted into to A’s corresponding columns, but when A sizes its rows it treats B as a single item (a grid container with its own rows and some items including items C and D). Similarly when B sizes its rows, it treats C’s items as slotted into B’s rows, but when B sizes its columns, it treats C as a single item, just as it does with D. There is no relationship between C’s rows and A’s rows, because the rows in B are nested, not subgridded.
</p>

<p>
高~levelからは、
`格子~sizing~algo$【！格子~algo】は：
◎
At a high level, the grid algorithm is:
</p>
<ol>
	<li>
各~colを~sizeする
◎
Size the columns
</li>
	<li>
各~rowを~sizeする
◎
Size the rows
</li>
	<li>
必要なら，各~rowの最終的な~sizeに基づいて，各~colを調整する
◎
Adjust the columns (if needed based on final row sizes)
</li>
</ol>

<p>
したがって，この例における格子~sizing~algoは、
次の様な~~流れになる：
◎
The grid sizing algorithm in this example would thus look like this:
</p>
<ol>
	<li>
<p><strong>
（ %A に属する各~colの~sizeを %A に属する各~駒の~sizeを利用して解決する
— その際には、
%B は空として扱う一方で，
%B の子 %C, %D は %A に属する駒として扱う）
</strong>
◎
Resolve sizes of A’s grid columns, using the sizes of A’s grid items, treating B as empty but treating its children (including C and D) as items in grid A.
</p>

<p>
格子~sizing~algo【！格子~algo】は、
%D に対しては，単純に %D の中へ再帰する。
%C に対しては，もっと複雑になる：
◎
The grid algorithm simply recurses into D. For C, it’s more complicated:
</p>
		<ol>
			<li>
%C に属する各~colを~sizeする。
◎
Size C’s columns.
</li>
			<li>
%B に属する各~rowを~sizeすることにより，
%C に属する各~rowを~sizeする。
◎
Size C’s rows by sizing B’s rows.
</li>
			<li>
%C に属する各~col【の~size】を調整する。
◎
Adjust C’s columns.
</li>
			<li>
%C に属する各~colの最終的な~sizeを返す。
◎
Return C’s final column sizes.
</li>
		</ol>

<p>
%B に属する~row用の正しい~sizeには，
%C に属する各~colの最終的な~sizeが要求される
— %B に属する~rowの~sizeは %B に属する~colの~sizeに依存し、
それは， %C に属する~colたちの最終的な~sizeに依存するので。
この循環な依存関係を分断するため、
格子~sizing~algo【！the algorithm】は分割する必要がある
— %C の各~colの最終的な~sizeの初期~近似に依存するようして，後で調整~周回を行うように。
なので，
%C に対しては、
~col~sizingに限り中へ再帰して，その初期~sizeを
%A の初期~col~sizing用に %A に渡しておく必要がある。
◎
A correct size for B’s rows requires C’s final column sizes, because the row size depends on the column size, and thus B’s rows could very well depend on C’s final column sizes. To break this cyclic dependency, we need to split the algorithm to depend on the initial approximation of C’s final column sizes, and do the adjustment pass later. So for C, we need to recurse into column sizing only, and pass that initial size up to A for its initial column sizing.
</p>

<p>
後で %B に属する各~rowを~sizeするときには、［
%C に属する（`下位格子~化$された）各~rowを~sizeして，
%C に属する各~colを完結する
］ことにより，
%C の~sizingを完遂しておく。
これが ある変化【？】による結果である場合、［
それ【？】の調整~周回の間に %A に属する~col用の調整~周回を誘発する機会
］がある。
◎
When we size B’s rows later on, we will size C’s rows (which are subgridded), and finish up C’s sizing by finalizing its columns. If this resulted in a change, we have the opportunity to trigger an adjustment pass for A’s columns during its adjustment pass.
</p>
	</li>
	<li>
<p><strong>
（ %A に属する各~rowの~sizeを %A に属する各~駒の~sizeを利用して解決する
— %B は単独の駒として扱う下で）
</strong>
◎
Next, resolve sizes of A’s rows, using the sizes of A’s grid items, treating B as a single item.
</p>

<p>
下位格子としての %B の~sizingは，複数の周回に分割されるので、
格子~sizing~algo【！格子~algo】は， %B の中への~rowを~sizeするときに限り再帰する
⇒＃
%B に属する各~rowは %D を単独の駒として扱う下で~sizeする,
その【 %D の？】最終的な~sizeを要請する,
%C を空な駒として扱うに伴い %C に属する各~子を格子 %B の中へ駒として巻き上げる。
◎
Since B, as a subgrid, has its sizing is split out into the multiple passes, the grid algorithm issues only a row-sizing recursion into B: Size B’s rows, treating D as a single item, requesting its final size, and treating C as an empty item and hoisting its children as items into grid B.
</p>

<p>
%B の最終的な~row~sizeを返す
— それは、
%A の~row~sizing周回に織り込まれる。
◎
B returns its final row size, which factors into A’s row sizing pass.
</p>
	</li>
	<li>
<p><strong>
（ %A に属する各~colの~sizeを完結する）
</strong>
◎
Last, finalize A’s column sizes.＼
</p>
<p>
%B の~rowを~sizeする周回を経た結果，
%C の最終的な~sizeが変化した場合、
これは %B に属する各~colを~sizeし直すことを誘発する
— それは， %A に属する各~colを~sizeし直す周回を誘発するベキである。
◎
If C’s final size changes as a result of the row-sizing pass through B, this should trigger a resizing of B’s columns, which should trigger a resizing pass on A’s column.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="algo-terms">
<h3 title="Track Sizing Terminology">12.2. 筋~sizingの用語</h3>

<dl class="def-list">
	<dt>
`~min筋~sizing関数@
◎
min track sizing function
</dt>
	<dd>
<p>
当の筋を~sizeしている`筋~sizing関数$に応じて：
</p>
		<ul>
			<li>
`minmax$f 関数ならば、
その関数の 1 個目の引数になる。
</li>
			<li>
`flex$t 値ならば、
`auto$vt になる。
</li>
			<li>
`fit-content$f 関数ならば、
`auto$vt になる。
</li>
			<li>
他の場合、
その`筋~sizing関数$になる。
</li>
		</ul>
◎
If the track was sized with a minmax() function, this is the first argument to that function. If the track was sized with a &lt;flex&gt; value or fit-content() function, auto. Otherwise, the track’s sizing function.
</dd>

	<dt>
`~max筋~sizing関数@
◎
max track sizing function
</dt>
	<dd>
<p>
当の筋を~sizeしている`筋~sizing関数$に応じて：
</p>
		<ul>
			<li>
`minmax$f 関数ならば、
その関数の 2 個目の引数になる。
</li>
			<li>
他の場合、
その`筋~sizing関数$。
</li>
		</ul>
<p>
とした上で、［
`auto$vt ／ `fit-content$f
］は `max-content$vt として扱う
— ただし， `fit-content$f に対し他が指定されている所は除く。
</p>
◎
If the track was sized with a minmax() function, this is the second argument to that function. Otherwise, the track’s sizing function. In all cases, treat auto and fit-content() as max-content, except where specified otherwise for fit-content().
</dd>

	<dt>
`可用な格子~空間@
◎
available grid space
</dt>
	<dd>
<p>
各~次元ごとに次で与えられる：
◎
Independently in each dimension, the available grid space is:
</p>
		<ul>
			<li>
`格子~容器$の~sizeが確定的な場合
⇒
その`内容~box$の~sizeを利用する。
◎
If the grid container’s size is definite, then use the size of its content box.
</li>
			<li>
`格子~容器$が［
`最小-内容~拘束$ ／ `最大-内容~拘束$
］の下で~sizeされている場合
⇒
`可用な格子~空間$はその拘束になる（不定になる）。
◎
If the grid container is being sized under a min-content constraint or max-content constraint then the available grid space is that constraint (and is indefinite).
</li>
		</ul>
	</dd>
	<dd class="note">注記：
内容に基づく~sizingを指示する `auto$vt ~size
（例：横組みにおける`塊~levelの~box$の縦幅）は、
`max-content$vt と等価になる。
◎
Note: auto sizes that indicate content-based sizing (e.g. the height of a block-level box in horizontal writing modes) are equivalent to max-content.
</dd>
	<dd>
すべての事例において、
`可用な格子~空間$は，`格子~容器$の［［
`min-width^p ／ `max-width^p
］~prop／［
`min-height^p ／ `max-height^p
］~prop
］の値が確定的ならば、
それらに則って切詰めるとする。
◎
In all cases, clamp the available grid space according to the grid container’s min/max-width/height properties, if they are definite.
</dd>

	<dt>
`~free空間@
◎
free space
</dt>
	<dd>
		<ul>
			<li>
`可用な空間$が`不定$な場合は`不定$。
</li>
			<li>
他の場合、
`max^op( ( `可用な格子~空間$ − ( すべての筋（側溝も含む）の`基底~size$の総和 ) ), 0 )
</li>
		</ul>
◎
Equal to the available grid space minus the sum of the base sizes of all the grid tracks (including gutters), floored at zero. If available grid space is indefinite, the free space is indefinite as well.
</dd>

	<dt>
`~span数@1
◎
span count
</dt>
	<dd>
`格子~駒$に交叉する`筋$の本数
— 筋は、
文脈にて適用-可能な次元のそれとする。
◎
The number of grid tracks crossed by a grid item in the applicable dimension.
</dd>
</dl>

<p class="note">注記：
`格子~sizing~algo$の目的においては、
`側溝$は，固定d~sizeな筋
— ［
~min, ~max
］~sizing関数とも側溝の使用~sizeに設定された筋 —
として扱われるので、［
`筋~sizing~algo$の計算には，側溝の~sizeも組入れられる必要がある
］ことに注意。
◎
Note: Remember that gutters are treated as fixed-size tracks—tracks with their min and max sizing functions both set to the gutter’s used size—for the purpose of the grid sizing algorithm. Their widths need to be incorporated into the track sizing algorithm’s calculations accordingly.
</p>

		</section>
		<section id="algo-track-sizing">
<h3 title="Track Sizing Algorithm">12.3. 筋~sizing~algo</h3>

<div>

<p>
この節~以降では，
`筋~sizing~algo@
を与える
— それは、［
`~min筋~sizing関数$,
`~max筋~sizing関数$
］から，使用 筋~sizeを計算する。
各~筋には、
次に挙げる `length$t 値がある：
</p>
<ul>
	<li>
`基底~size@
⇒
~algo全体を通して，拡幅され得る
— 最後には，筋の最終的な~sizeになる。
【常に有限。】
</li>
	<li>
`拡幅~上限@
⇒
`基底~size$に欲される最大~sizeを供する。
【無限大になり得る。】
</li>
</ul>
◎
The remainder of this section is the track sizing algorithm, which calculates from the min and max track sizing functions the used track size. Each track has a base size, a &lt;length&gt; which grows throughout the algorithm and which will eventually be the track’s final size, and a growth limit, a &lt;length&gt; which provides a desired maximum size for the base size. There are 5 steps:
</div>

<p>
5 段からなる手続きがある：
</p>

<ol>
	<li>
`筋~sizeの初期化＠#algo-init$
◎
Initialize Track Sizes
</li>
	<li>
`内在的な筋~sizeを解決する＠#algo-content$
◎
Resolve Intrinsic Track Sizes
</li>
	<li>
`筋を最大~化する＠#algo-grow-tracks$
◎
Maximize Tracks
</li>
	<li>
`~flex可能な筋を拡げる＠#algo-flex-tracks$
◎
Expand Flexible Tracks
</li>
	<li>
<a href="#algo-stretch">`auto^v 筋を伸張する</a>
◎
[[#algo-stretch|Expand Stretched auto Tracks]]
</li>
</ol>

		</section>
		<section id="algo-init">
<h3 title="Initialize Track Sizes">12.4. 筋~sizeの初期化</h3>

<p>
~EACH( `筋$ %筋 )
に対し，
%筋 の［
`基底~size$, `拡幅~上限$
］を初期化する：
◎
Initialize each track’s base size and growth limit.＼
</p>
<ol>
	<li>
<p>
%筋 の`基底~size$ ~SET %筋 の`~min筋~sizing関数$に応じて
⇒＃
`固定的~sizing関数$であるならば，絶対~長さに解決した結果† ／
`内在的~sizing関数$であるばらば， 0
</p>

<p class="note">注記†：
長さは`不定$にはなり得ない
— その場合、
`auto$vt 【すなわち，内在的~sizing関数】に扱われるので。
</p>

◎
For each track, if the track’s min track sizing function is:
• A fixed sizing function
•• Resolve to an absolute length and use that size as the track’s initial base size.
•• Note: Indefinite lengths cannot occur, as they’re treated as auto.
• An intrinsic sizing function
•• Use an initial base size of zero.
</li>
	<li>
%筋 の`拡幅~上限$ ~SET %筋 の`~max筋~sizing関数$に応じて
⇒＃
`固定的~sizing関数$であるならば，絶対~長さに解決した結果 ／
`内在的~sizing関数$であるならば，無限大／
`~flex可能な~sizing関数$であるならば，無限大
◎
For each track, if the track’s max track sizing function is:
• A fixed sizing function
•• Resolve to an absolute length and use that size as the track’s initial growth limit.
• An intrinsic sizing function
• A flexible sizing function
•• Use an initial growth limit of infinity. 
</li>
	<li>
~IF［
%筋 の`拡幅~上限$ ~LT %筋 の`基底~size$
］
⇒
%筋 の`拡幅~上限$ ~SET %筋 の`基底~size$
◎
In all cases, if the growth limit is less than the base size, increase the growth limit to match the base size.
</li>
</ol>

<p class="note">注記：
`側溝$は、
`筋~sizing~algo$の目的においては，空な固定d~sizeの筋として扱われる。
◎
Note: Gutters are treated as empty fixed-size tracks for the purpose of the track sizing algorithm.
</p>

		</section>
		<section id="algo-content">
<h3 title="Resolve Intrinsic Track Sizes">12.5. 内在的な筋~sizeを解決する</h3>

<p>
この段では、
`内在的~sizing関数$を絶対~長さに解決する。
それはまず、
全体が単独の筋に包含されている駒に基づいて，それらの~sizeを解決する。
次に、
筋の本数を徐々に増やしながら，
複数本の筋に~spanする駒に要する空間を加えていく
— それらの筋にまたがる余った空間を，アリな限り均等に分配しつつ。
◎
This step resolves intrinsic track sizing functions to absolute lengths. First it resolves those sizes based on items that are contained wholly within a single track. Then it gradually adds in the space requirements of items that span multiple tracks, evenly distributing the extra space across those tracks insofar as possible.
</p>

<p class="note">注記：
この節の手続きが完了したとき、
すべての［
内在的な`基底~size$, `拡幅~上限$
］は、
絶対~長さに解決されることになる。
◎
Note: When this step is complete, all intrinsic base sizes and growth limits will have been resolved to absolute lengths.
</p>

<p class="note">注記：
`~max筋~sizing関数$［
`fit-content$f ／ `auto$vt
］は、
明示的に他が指定されない限り，
`max-content$vt と`同じに扱われる＠#algo-terms$ことに注意。
◎
Note: Remember that fit-content() and auto max track sizing functions are treated the same as max-content except where explicitly specified otherwise.
</p>

<ol>
	<li id="algo-baseline-shims">
<p><strong>
（各~駒の`内在的~size供与$が 駒の基底線~整列を反映するように、
基底線が整列される各~駒に詰物を付与する）
</strong>
◎
Shim baseline-aligned items so their intrinsic size contributions reflect their baseline alignment.＼
</p>

<p>
各 `基底線-共有~group$に対し，それを成す駒たちに対し、
その［
始端／終端
］側に  “詰物” （実質的に，追加的な~margin）を（［
最初の／最後の
］基底線~整列~用に）追加して、
それらが［
始端／終端
］に一緒に整列されるとき，各自の基底線が
`指定された値＠~CSSALIGN#baseline-values$に整列するようにする。
【`基底線~整列により拡幅される様子を示す参考図＠~CSSWG/css-flexbox-1/images/flex-align.svg$（これは~flex~layoutの例だが）】
◎
For the items in each baseline-sharing group, add a “shim” (effectively, additional margin) on the start/end side (for first/last-baseline alignment) of each item so that, when start/end-aligned together their baselines align as specified.
</p>

<p>
下に与える筋~sizingの目的においては、
これらの “詰物” は，駒の`内在的~size供与$の一部を成すと見なされる。
ある駒が複数の`内在的~size供与$を利用する場合、
各自の詰物は互いに異なり得る。
◎
Consider these “shims” as part of the items’ intrinsic size contribution for the purpose of track sizing, below. If an item uses multiple intrinsic size contributions, it can have different shims for each one.
</p>

<p class="example">
例えば，`格子~容器$の~sizeが`不定$なときは、
先ず［
`最小-内容~拘束$／`最大-内容~拘束$
］の下で~lay-outして，~sizeを見出してから，その~sizeで “~~本番” 用に~lay-outされる
（それは、
百分率~sizeの筋の様なものに影響し得る）。
各~~段階で追加される “詰物” は互いに独立であり、
それぞれの~~段階における~layoutのみに影響する。
◎
For example, when the grid container has an indefinite size, it is first laid out under min/max-content constraints to find the size, then laid out "for real" with that size (which can affect things like percentage tracks). The "shims" added for each phase are independent, and only affect the layout during that phase.
</p>

<p class="note">注記：
この段では、
基底線により［
`自己-整列される駒＠~CSSALIGN#baseline-align-self$,
`内容~整列される駒＠~CSSALIGN#baseline-align-content$
］どちらも考慮される。
`CSS-ALIGN-3$r
◎
Note: Note that both baseline self-aligned and baseline content-aligned items are considered in this step.
</p>

<p class="note">注記：
自前の~sizeが［
内在的に~sizeされる筋の~size
］に依存する格子~駒には、
詰物は付与されない
— それらは、
`基底線~整列に関与しない＠#row-align$ので。
◎
Note: Since grid items whose own size depends on the size of an intrinsically-sized track do not participate in baseline alignment, they are not shimmed.
</p>
	</li>
	<li id="algo-single-span-items">
<div class="p">
<p><strong>
（各~筋を［
~span数が 1 である，すべての駒
］が収まるように~sizeする）
</strong></p>

<p>
~EACH( %筋 )
に対し：
</p>
◎
Size tracks to fit non-spanning items: For each track with an intrinsic track sizing function and not a flexible sizing function, consider the items in it with a span of 1:
</div>

		<ol>
			<li>
~IF［
%筋 は`~flex可能な~sizing関数$を伴う
］
⇒
~CONTINUE
◎
↑</li>
			<li>
%S ~LET
~spanする筋は %筋 のみである駒からなる集合
◎
↑</li>
			<li>
~IF［
%S は空である
］
⇒
~CONTINUE
◎
↑</li>
			<li>
<p>
~IF［
%筋 の`~min筋~sizing関数$は`内在的~sizing関数$である
］
⇒
%筋 の`基底~size$ ~SET 
%筋 の`~min筋~sizing関数$に応じて 次で与えられる値：
◎
↓</p>
				<dl class="switch">
					<dt>`min-content$vt
◎
For min-content minimums:
If the track has a min-content min track sizing function,＼
</dt>
					<dd>
`max^op( `max^op( %駒 の`最小-内容~供与$ ； %駒 ~IN %S ), 0 )
◎
set its base size to the maximum of the items’ min-content contributions, floored at zero.
</dd>
					<dt>`max-content$vt
◎
For max-content minimums:
If the track has a max-content min track sizing function,＼
</dt>
					<dd>
`max^op( `max^op( %駒 の`最大-内容~供与$ ； %駒 ~IN %S ), 0 )
◎
set its base size to the maximum of the items’ max-content contributions, floored at zero.
</dd>
					<dt>
`auto$vt
◎
For auto minimums:
If the track has an auto min track sizing function＼
</dt>
					<dd>
						<ol>
							<li>
~IF［
`格子~容器$は［
`最小-内容~拘束$／`最大-内容~拘束$
］の下で~sizeされている
］
⇒
`max^op( `max^op( %駒 の［
`制限付き最小-内容~供与$／`制限付き最大-内容~供与$
］ ； %駒 ~IN %S ), 0 )
◎
and the grid container is being sized under a min-/max-content constraint, set the track’s base size to the maximum of its items’ limited min-/max-content contributions (respectively), floored at zero.＼
</li>
							<li>
~ELSE
⇒
`max^op( `max^op( %駒 の`最小~供与$ ； %駒 ~IN %S ), 0 )
◎
↓</li>
						</ol>

<p>
%駒 の［
`制限付き最小-内容~供与@
／
`制限付き最大-内容~供与$
］は、
（この目的においては）次で与えられる
⇒
`max^op( `min^op( %駒 の［
`最小-内容~供与$／`最大-内容~供与$
］, %上限 ), %駒 の`最小~供与$ )
— ここで %上限 は、
%筋 の`~max筋~sizing関数$
（これは、
`fit-content$f 筋~sizing関数への引数にもなり得る）
に応じて
⇒＃
`固定的~sizing関数$であるならば それ／
~ELSE_ 無限大
◎
The limited min-/max-content contribution of an item is (for this purpose) its min-/max-content contribution (accordingly), limited by the max track sizing function (which could be the argument to a fit-content() track sizing function) if that is fixed and ultimately floored by its minimum contribution (defined below).
◎
↑Otherwise, set the track’s base size to the maximum of its items’ minimum contributions, floored at zero.＼
</p>

<p>
%駒 の
`最小~供与@
は、
%駒 の`外縁~size$として可能な最~小になる
— 特定的には：
◎
The minimum contribution of an item is the smallest outer size it can have. Specifically,＼
</p>
						<ul class="switch">
							<li>
%駒 の算出d`選好d~size$は，関連な軸において［
`~autoとして挙動する$か，
%駒 の`包含塊$の~sizeに依存する
］場合
⇒
%駒 の使用`最小~size$は`選好d~size$に等しいと見做したときの，結果の`外縁~size$
◎
if the item’s computed preferred size behaves as auto or depends on the size of its containing block in the relevant axis, its minimum contribution is the outer size that would result from assuming the item’s used minimum size as its preferred size;＼
</li>
							<li>
他の場合
⇒
%駒 の`最小-内容~供与$
◎
else the item’s minimum contribution is its min-content contribution.＼
</li>
						</ul>

<p>
`最小~供与$は、
%駒 の内容の~sizeに依存することが多いので，
`内在的~size供与$の一種と見なされる。
◎
Because the minimum contribution often depends on the size of the item’s content, it is considered a type of intrinsic size contribution.
</p>

<p class="note">注記：†
%駒 に指定された`最小~size$が `~autoS$v （初期~値）の場合の結果は、
通例的には %駒 の`最小-内容~供与$と等価になるが，
異なる事例もある。
`§ 格子~駒の自動的な最小~size$を見よ。
また、
次が満たされる
⇒
`最小~供与$ ~LTE `最小-内容~供与$ ~LTE `最大-内容~供与$
◎
Note: For items with a specified minimum size of auto (the initial value), the minimum contribution is usually equivalent to the min-content contribution—but can differ in some cases, see § 6.6 Automatic Minimum Size of Grid Items. Also, minimum contribution ≤ min-content contribution ≤ max-content contribution.
</p>
					</dd>
				</dl>
			</li>
			<li>
<p>
~IF［
%筋 の`~max筋~sizing関数$は`内在的~sizing関数$である
］
⇒
%筋 の`拡幅~上限$ ~SET %筋 の`~max筋~sizing関数$に応じて：
◎
↓</p>
				<dl class="switch">
					<dt>
`min-content$vt
◎
For min-content maximums:
</dt>
					<dd>
`max^op( %駒 の`最小-内容~供与$ ； %駒 ~IN %S )
◎
If the track has a min-content max track sizing function, set its growth limit to the maximum of the items’ min-content contributions.
</dd>

					<dt>
`max-content$vt
（ `auto$vt, `fit-content$f も含む）
◎
For max-content maximums:
</dt>
					<dd>
`max^op( %駒 の`最大-内容~供与$ ； %駒 ~IN %S )
◎
If the track has a max-content max track sizing function, set its growth limit to the maximum of the items’ max-content contributions.＼
</dd>
					<dd>
ただし， `fit-content$f の場合は
⇒
`max^op( 上の結果, `fit-content^f の引数 )
◎
For fit-content() maximums, furthermore clamp this growth limit by the fit-content() argument.
</dd>
				</dl>
			</li>
			<li>
%筋 の`拡幅~上限$ ~SET `max^op( %筋 の`拡幅~上限$, %筋 の`基底~size$ )
◎
In all cases, if a track’s growth limit is now less than its base size, increase the growth limit to match the base size.
</li>
		</ol>

<p class="note">注記：
この段は、
下の［
複数~筋に~spanしている駒たちを取扱う段
］の単純~化であり，~span数 1 の駒に対し それを走らせたときと同じ挙動が得られるべきである。
◎
Note: This step is a simplification of the steps below for handling spanning items, and should yield the same behavior as running those instructions on items with a span of 1.
</p>
	</li>
	<li>
%N ~LET 2
</li>
	<li id="algo-spanning-items">
<div class="p">
<p><strong>
（~span数 %N を増やしながら、
内容により~sizeされる各~筋の~sizeを，下に与える %駒~集合 を収容するように増やす）
</strong></p>
<p>
~WHILE ［ ~span数 ~GTE %N なる駒は在る ］：
</p>
◎
Increase sizes to accommodate spanning items crossing content-sized tracks:＼
</div>
		<ol>
			<li>
%駒~集合 ~LET 駒のうち，次を満たすものからなる集合
⇒
［
~span数 ~EQ %N
］~AND［
`~flex可能な~sizing関数$を伴う筋には~spanしない
］
◎
Next, consider the items with a span of 2 that do not span a track with a flexible sizing function.
</li>
			<li>
~IF［
%駒~集合 は空である
］
⇒＃
%N ~INCBY 1 ；
~CONTINUE
◎
↑</li>
			<li>
<p><strong>
（`~min筋~sizing関数$は`内在的~sizing関数$である筋たちに，余った空間を分配する）
</strong>
◎
↓</p>
				<ol>
					<li>
<p id="track-size-intrinsic-min">
（各~駒の`最小~供与$を収容する）：
</p>
						<ol>
							<li>
%~size供与 ~LET “`最小~供与$”
</li>
							<li>
~IF［
当の`格子~容器$は［
`最小-内容~拘束$／`最大-内容~拘束$
］の下で~sizeされている
］
⇒
%~size供与 ~SET “`制限付き最小-内容~供与$”†
</li>
							<li>
`余った空間を分配する$( ↓ )
⇒＃
%駒~集合,
%~size供与,
`基底~size^i,
`~min筋~sizing関数$は`内在的~sizing関数$である筋からなる集合
</li>
						</ol>

<p>†
（複数~筋に~spanしている駒に対しては、
駒の［
`制限付き最小-内容~供与$／`制限付き最大-内容~供与$
］を計算するために利用する %上限 は、［
駒が~spanする各~筋の`~max筋~sizing関数$は、
どれも`固定的~sizing関数$である場合
］に限り適用され，
それらの`固定的~sizing関数$の`総和^emになる。）
</p>
◎
For intrinsic minimums: First distribute extra space to base sizes of tracks with an intrinsic min track sizing function, to accommodate these items’ minimum contributions.
◎
If the grid container is being sized under a min- or max-content constraint, use the items’ limited min-content contributions in place of their minimum contributions here.＼
(For an item spanning multiple tracks, the upper limit used to calculate its limited min-/max-content contribution is the sum of the fixed max track sizing functions of any tracks it spans, and is applied if it only spans such tracks.)
</li>
					<li id="track-size-content-min">
（各~駒の`最小-内容~供与$を収容する）
⇒
`余った空間を分配する$( ↓ )
⇒＃
%駒~集合,
“`最小-内容~供与$”,
`基底~size^i,
`~min筋~sizing関数$は［ `min-content$vt ／ `max-content$vt ］である筋からなる集合
◎
For content-based minimums: Next continue to distribute extra space to the base sizes of tracks with a min track sizing function of min-content or max-content, to accommodate these items' min-content contributions.
</li>
					<li id="track-size-max-content-min">
（各~駒の`制限付き最大-内容~供与$を収容する）
⇒
~IF［
`格子~容器$は`最大-内容~拘束$の下で~sizeされている
］
⇒
`余った空間を分配する$( ↓ )
⇒＃
%駒~集合,
“`制限付き最大-内容~供与$”,
`基底~size^i,
`~min筋~sizing関数$は［ `auto^v ／ `max-content$vt ］である筋からなる集合
◎
For max-content minimums: Next, if the grid container is being sized under a max-content constraint, continue to distribute extra space to the base sizes of tracks with a min track sizing function of auto or max-content, to accommodate these items' limited max-content contributions.
</li>
					<li id="_track-size-max-content-min-1">
【！In all cases, は、上のすべての段を指すであろう 】
（各~駒の`最大-内容~供与$を収容する）
⇒
`余った空間を分配する$( ↓ )
⇒＃
%駒~集合,
“`最大-内容~供与$”,
`基底~size^i,
`~min筋~sizing関数$は `max-content$vt である筋からなる集合
◎
In all cases, continue to distribute extra space to the base sizes of tracks with a min track sizing function of max-content, to accommodate these items' max-content contributions.
</li>
				</ol>
			</li>
			<li>
~EACH( %筋 )
に対し
⇒
%筋 の`拡幅~上限$ ~SET `min^op( %筋 の`拡幅~上限$, %筋 の`基底~size$ )
◎
If at this point any track’s growth limit is now less than its base size, increase its growth limit to match its base size.
</li>
			<li>
<p><strong>
（`~max筋~sizing関数$は`内在的~sizing関数$である筋たちに，余った空間を分配する）
</strong></p>
				<ol>
					<li>
<p>
（各~駒の`最小-内容~供与$を収容する）
⇒
`余った空間を分配する$( ↓ )
⇒＃
%駒~集合,
“`最小-内容~供与$”,
`拡幅~上限^i,
`~max筋~sizing関数$は`内在的~sizing関数$である筋からなる集合
◎
For intrinsic maximums: Next distribute extra space to the growth limits of tracks with intrinsic max track sizing function, to accommodate these items' min-content contributions.＼
</p>

<p>
［
この段で`拡幅~上限$が無限から有限に変化した各~筋
］は、
次の段のために
`無限に拡幅-可能@
とする
◎
Mark any tracks whose growth limit changed from infinite to finite in this step as infinitely growable for the next step.
</p>

<p>
“無限に拡幅-可能”
は何のためにあるかについて…
【以下、この段の内容は未訳（`~~参照＠https://lists.w3.org/Archives/Public/www-style/2014Mar/0500.html$）】
【！＊ 】
◎
Why does the infinitely growable flag exist?

Peter Salas explains:

    Consider the following case:
        Two "auto" tracks (i.e. minmax(min-content, max-content) minmax(min-content, max-content)).
        Item 1 is in track 1, and has min-content = max-content = 10.
        Item 2 spans tracks 1 and 2, and has min-content = 30, max-content = 100.

        After resolving min-content/max-content for the first item, we have this.

        track 1: base size = 10 growth limit = 10

        track 2: base size = 0 growth limit = infinity

        Then we resolve min-content/max-content for the second item.

        Phase 1 sets the base size of track 2 to 20 so that the two tracks' base sizes sum to 30.
        Phase 2 does nothing because there are no relevant tracks.
        Phase 3 sets the growth limit of track 2 to 20 so that the two tracks' growth limits sum to 30.
        In phase 4, we need to grow the sum of the growth limits by 70 to accommodate item 2.
        Two options are:

        1. Grow each track’s growth limit equally,
          and end up with growth limits = [45, 55].
        2. Grow only the second track’s growth limit,
          and end up with growth limits = [10, 90].

        By not considering the just-set growth limit as a constraint during space distribution
        (i.e. by treating it as infinity),
        we get the second result,
        which we considered a better result because the first track remains sized exactly to the first item.
</p>

					</li>
					<li>
<p>
（各~駒の`最大-内容~供与$を収容する）
⇒
`余った空間を分配する$( ↓ )
⇒＃
%駒~集合,
“`最大-内容~供与$”,
`拡幅~上限^i,
`~max筋~sizing関数$は `max-content$vt であるである筋からなる集合
◎
For max-content maximums: Lastly continue to distribute extra space to the growth limits of tracks with a max track sizing function of max-content, to accommodate these items' max-content contributions.＼
</p>

<p>
ただし，この段では、［
`~max筋~sizing関数$が `fit-content$f として与えられた筋
］については，その引数を拡幅の上限とする。
◎
However, limit the growth of any fit-content() tracks by their fit-content() argument.
</p>
					</li>
				</ol>
			</li>
			<li>
%N ~INCBY 1
◎
Repeat incrementally for items with greater spans until all items have been considered.
</li>
		</ol>
	</li>
	<li id="algo-spanning-flex-items">
<p><strong>
（`~flex可能$な筋に~spanしている駒を収容するよう，それらの筋~sizeを増やす）
</strong>
◎
Increase sizes to accommodate spanning items crossing flexible tracks:
</p>

<p>
次に従う下で、
前~段の ~WHILE 内の手続きを 1 回だけ行う
（ %N は関わらない）
◎
Next, repeat the previous step instead considering (together, rather than grouped by span size)＼
</p>
		<ul>
			<li>
%駒~集合 は、
`~flex可能な~sizing関数$を伴う筋にも~spanするものからなる。
◎
all items that do span a track with a flexible sizing function while
</li>
			<li>
`~flex可能$な筋のみに空間を分配する
（すなわち、
他のすべての筋は，`固定的~sizing関数$を伴うものと扱う）。
◎
distributing space only to flexible tracks (i.e. treating all other tracks as having a fixed sizing function)
</li>
			<li>
<p>
［
駒が~spanする`~flex可能$な筋たち
］に対しては、
それら［
各~筋の`~flex可能な~sizing関数$
］の総和に応じて：
◎
if the sum of the flexible sizing functions of all flexible tracks spanned by the item＼
</p>
				<ul>
					<li>
総和 ~GT 1 になる場合
⇒
各~筋の`~flex可能な~sizing関数$の比に則って，空間を各~筋に分配する
— 空間を等しく分配するのでなく。
◎
is greater than or equal to one, distributing space to such tracks according to the ratios of their flexible sizing functions rather than distributing space equally;＼
</li>
					<li>
総和 ~LTE 1 になる場合
⇒
各~筋の`~flex可能な~sizing関数$の比に則って，空間の［
当の総和に比例する分
］を各~筋に分配した上で、
残りを各~筋に等しく分配する
◎
and if the sum is less than one, distributing that proportion of space according to the ratios of their flexible sizing functions and the rest equally
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li id="algo-finite-growth">
~EACH( %筋 )
に対し
⇒
~IF［
%筋 の`拡幅~上限$は無限である
（例えば，［
駒が配置されていない／`~flex可能$な筋である
］ため）
］
⇒
%筋 の`拡幅~上限$ ~SET %筋 の`基底~size$
◎
If any track still has an infinite growth limit (because, for example, it had no items placed in it or it is a flexible track), set its growth limit to its base size.
</li>
</ol>

<p class="note">注記：
複数の筋に~spanする駒があるとき、
内在的~sizingによる拘束を満たすような~~一意な仕方は無い。
この~algoは、
この仕様の
`§ 序論＠#intro$
に述べた “ゲーム” の例など，［
現実の利用事例で良好な結果が得られるようにする，いくつかの経験則
］を組織化する。
この~algoは、
より進んだ経験則が将来に~~見出されたなら，それを織り込むよう更新され得る。
◎
Note: There is no single way to satisfy intrinsic sizing constraints when items span across multiple tracks. This algorithm embodies a number of heuristics which have been seen to deliver good results on real-world use-cases, such as the “game” examples earlier in this specification. This algorithm may be updated in the future to take into account more advanced heuristics as they are identified.
</p>

			<section id="extra-space">
<h4 title="Distributing Extra Space Across Spanned Tracks">12.5.1. ~spanする筋たちへの，余った空間の分配-法</h4>

<div class="algo">
<p>
`余った空間を分配する@
ときは、
所与の
( %駒~集合, %~size供与, %影響される~size, %影響される筋~群 )
に対し，以下に従う。
この~algoは、［
各~駒（ ~IN %駒~集合 ）を それが~spanしている筋に収容する
］べく，筋の`影響される~size$に駒の内在的~size供与
（その~~種類は %~size供与 で指示される）
を分配する：
◎
To distribute extra space, perform the following steps, with these inputs:
◎
• whether to affect base sizes or growth limits (the affected sizes).
• which tracks to affect (the affected tracks).
• what intrinsic size contributions are being accommodated (the size contributions) of which grid items spanning those tracks (the items).
</p>

<p class="trans-note">【
%影響される筋~群 という命名に反して、
この~algoは， %影響される筋~群 に属さない筋にも影響する（よう更新された）。
】</p>

<ol>
	<li>
<p>
以下においては：
</p>
		<ul>
			<li>
所与の %筋 の
`影響される~size@
は、
%影響される~size に応じて，次を指すとする
⇒＃
`基底~size^i ならば %筋 の`基底~size$／
`拡幅~上限^i ならば %筋 の`拡幅~上限$
</li>
			<li>
%影響される筋~群 を成す各~筋には、
`計画d増分@
が結び付けられ，初期~時は 0 をとるとする
（これは、
~size増分が順序に依存するのを防止する）。
</li>
			<li>
各~筋には、
`駒による増分@
が結び付けられ，初期~時は 0 をとるとする。
</li>
		</ul>
◎
↑
◎
Maintain separately for each affected track a planned increase, initially set to 0. (This prevents the size increases from becoming order-dependent.)
</li>
	<li>
<p>
%駒~集合 を成す
~EACH( %駒 )
に対し：
◎
For each accommodated item,＼
considering only tracks the item spans:
</p>
		<ol>
			<li>
%余った空間 ~LET %~size供与 により指示される %駒 の~size
（例： “`最小~供与$” ならば %駒 の`最小~供与$, 等々）
◎
↓</li>
			<li>
<p>
%駒 が~spanしている
~EACH( `筋$ %筋 )
（ %影響される筋~群 に属さない筋も含む）に対し：
</p>
				<ol>
					<li>
%~size ~LET %筋 の`影響される~size$
</li>
					<li>
~IF［
%~size ~EQ 無限大
（したがって， %影響される~size ~EQ `拡幅~上限^i ）
］
⇒
%~size ~SET %筋 の`基底~size$
</li>
					<li>
%余った空間 ~DECBY %~size
</li>
				</ol>
◎
Find the space to distribute:＼
Subtract the affected size of every spanned track (not just the affected tracks) from the item’s size contribution, flooring it at zero. (For infinite growth limits, substitute the track’s base size.) This remaining size contribution is the space to distribute.
</li>
			<li>
%余った空間 ~SET `max^op( %余った空間, 0 )
◎
space = max(0, size contribution - ∑track-sizes)
</li>
			<li>
<p><strong>
（ %余った空間 を上限まで分配する）
◎
Distribute space up to limits:
</strong></p>
				<ol>
					<li>
%筋~群 ~LET %影響される筋~群 に属する筋のうち %駒 が~spanしている筋たちが成す集合
◎
↑</li>
					<li>
<p>
~WHILE［
%余った空間 ~GT 0
］~AND［
%筋~群 は空でない
］：
</p>
						<ol>
							<li>
%均等~分配 ~LET %余った空間 ~DIV ( %筋~群 を成す筋の本数 )
</li>
							<li>
<p>
%筋~群 を成す
~EACH( %筋 )
に対し
</p>
								<ol>
									<li>
%上限 ~LET %筋 の`拡幅~上限$
</li>
									<li>
~IF［
%影響される~size ~EQ `拡幅~上限^i
］~AND［
%筋 は`無限に拡幅-可能$である
］
⇒
%上限 ~SET 無限大
</li>
									<li>
%筋~増分 ~LET %均等~分配
</li>
									<li>
<p>
~IF［
%上限 ~NEQ 無限大
］：
</p>
										<ol>
											<li>
%最大~増分 ~LET %上限 ~MINUS ( %筋 の`影響される~size$ ~PLUS %筋 の`駒による増分$ )
</li>
											<li>
~IF［
%筋~増分 ~GTE %最大~増分
］
⇒＃
%筋~増分 ~SET %最大~増分；
%筋~群 から %筋 を除去する
</li>
										</ol>
									</li>
									<li>
%筋 の`駒による増分$ ~INCBY %筋~増分
</li>
									<li>
%余った空間 ~DECBY %筋~増分
</li>
								</ol>
							</li>
						</ol>
◎
Find the item-incurred increase for each affected track by:＼
distributing the space equally among these tracks, freezing a track’s item-incurred increase as its affected size + item-incurred increase reaches its limit (and continuing to grow the unfrozen tracks as needed).
◎
For base sizes, the limit is its growth limit. For growth limits, the limit is infinity if it is marked as infinitely growable, and equal to the growth limit otherwise.
</li>
				</ol>

<p class="note">注記：
［
%影響される~size ~EQ `拡幅~上限^i
］かつ %筋 は`無限に拡幅-可能$でない場合、
%最大~増分 ~LTE 0 になり %筋~増分 ~EQ 0 になるので，
%筋 の`駒による増分$は増えない。
◎
Note: If the affected size was a growth limit and the track is not marked infinitely growable, then each item-incurred increase will be zero.
</p>
			</li>
			<li>
<p><strong>
（ %影響される筋~群 以外の筋たちに %余った空間 を分配する）
</strong>
◎
Distribute space to non-affected tracks:
</p>

<p>
~IF［
%駒 は %影響される筋~群 に属するある筋に~spanする
］
⇒
前~段の内容を成す手続きを［
その最初の段を次に置換する
］下で遂行する
⇒
%筋~群 ~LET %影響される筋~群 に属さない筋のうち %駒 が~spanしている筋たちが成す集合
◎
If extra space remains at this point, and the item spans both affected tracks and non-affected tracks, distribute space as for the previous step, but into the non-affected tracks instead.
</p>

<p class="note">注記：
この段は、
`拡幅~上限$にまだ達してない筋たちに残りの空間を分配する
— %影響される筋~群 の`拡幅~上限$に違反する代わりに。
◎
Note: This distributes any remaining space into tracks that have not yet reached their growth limits, instead of violating the growth limits of the affected tracks.
</p>
			</li>
			<li>
<p><strong>
（上限を超えて空間を分配する）
</strong>
◎
Distribute space beyond limits:
</p>

<p>
~IF［
%余った空間 ~GT 0
］：
◎
If extra space remains at this point,＼
</p>
				<ol>
					<li>
%筋~群 ~LET %影響される筋~群 の複製
◎
unfreeze and continue to distribute space to the item-incurred increase of…
</li>
					<li>
<p>
~IF［
%影響される~size ~EQ `基底~size^i
］
⇒
%~size供与 に応じて：
</p>
						<dl class="switch">
							<dt>“`最小~供与$”</dt>
							<dt>“`制限付き最小-内容~供与$”</dt>
							<dt>“`最小-内容~供与$”</dt>
							<dd>
~IF［
%筋~群 内に`~max筋~sizing関数$が`内在的~sizing関数$である筋は在る
］
⇒
%筋~群 から他の筋すべてを除去する
</dd>

							<dt>“`制限付き最大-内容~供与$”</dt>
							<dt>“`最大-内容~供与$”</dt>
							<dd>
~IF［
%筋~群 内に `~max筋~sizing関数$が `max-content$vt である筋は在る
］
⇒
%筋~群 から他の筋すべてを除去する
</dd>
						</dl>
◎
when accommodating minimum contributions or accommodating min-content contributions: any affected track that happens to also have an intrinsic max track sizing function; if there are no such tracks, then all affected tracks.
◎
when accommodating max-content contributions: any affected track that happens to also have a max-content max track sizing function; if there are no such tracks, then all affected tracks.
◎
when handling any intrinsic growth limit: all affected tracks.
</li>
					<li>
%筋~群 を成す
~EACH( %筋 )
に対し
⇒
%筋 の`駒による増分$ ~INCBY %余った空間 ~DIV ( %筋~群 を成す筋の本数 )
◎
↑</li>
				</ol>
<p>
この段の目的においては，
`fit-content$f 筋の`~max筋~sizing関数$は、［
その引数に指定される上限に達するまでは `max-content$vt，
それ以降は`固定的~sizing関数$である
］ものとして扱う。
◎
For this purpose, the max track sizing function of a fit-content() track is treated as max-content until it reaches the limit specified as the fit-content() argument, after which it is treated as having a fixed sizing function of that argument.
</p>

<p class="note">注記：
この段は、［
各~筋の`~max筋~sizing関数$の種別に基づく，筋の現在の拡幅~上限
］を超えるような %~size供与 を収容するための空間の分配を優先する。
◎
Note: This step prioritizes the distribution of space for accommodating size contributions beyond the tracks' current growth limits based on the types of their max track sizing functions
</p>
			</li>
			<li>
%影響される筋~群 を成す
~EACH( %筋 )
に対し
⇒
%筋 の`計画d増分$ ~SET `min^op( %筋 の`計画d増分$, %筋 の`駒による増分$ )
◎
For each affected track, if the track’s item-incurred increase is larger than the track’s planned increase set the track’s planned increase to that value.
</li>
		</ol>
	</li>
	<li>
<p><strong>
（各~筋の`計画d増分$が次回の空間~分配に織り込まれるよう，`影響される~size$を更新する）
</strong></p>

<p>
%影響される筋~群 を成す
~EACH( %筋 )
に対し：
</p>
		<ol>
			<li>
~IF［
%筋 の`影響される~size$ ~EQ 無限大
（したがって， %影響される~size ~EQ `拡幅~上限^i ）
］
⇒
%筋 の`影響される~size$ ~SET %筋 の`基底~size$
</li>
			<li>
%筋 の`影響される~size$ ~INCBY %筋 の`計画d増分$
</li>
		</ol>
◎
Update the tracks' affected sizes by adding in the planned increase, so that the next round of space distribution will account for the increase. (If the affected size is an infinite growth limit, set it to the track’s base size plus the planned increase.)
</li>
</ol>
</div>

			</section>
		</section>
		<section id="algo-grow-tracks">
<h3 title="Maximize Tracks">12.6. 筋を最大~化する</h3>

<p>
`~free空間$が正である場合、
それを，すべての筋の`基底~size$に等しく分配する
— その際には、
`拡幅~上限$に達した筋は，そこで凍結する
（他の筋は拡幅させ続ける）。
◎
If the free space is positive, distribute it equally to the base sizes of all tracks, freezing tracks as they reach their growth limits (and continuing to grow the unfrozen tracks as needed).
</p>

<div class="p">
<p>
この段の目的においては、
`格子~容器$が：
</p>

<ul>
	<li>
`最大-内容~拘束$の下で~sizeされている場合、
`~free空間$は無限とみなす。
</li>
	<li>
`最小-内容~拘束$の下で~sizeされている場合、
`~free空間$は 0 とみなす。
</li>
</ul>

◎
For the purpose of this step: if sizing the grid container under a max-content constraint, the free space is infinite; if sizing under a min-content constraint, the free space is zero.
</div>

<p>
これにより，格子が［［
`max-width$p ／ `max-height$p
］で制限された，`格子~容器$の`内縁~size$
］より大きくなった場合、
次を加味する下で，この段をやり直す
⇒
格子を，その［
`max-width$p ／ `max-height$p
］に~sizeするときは、［
`可用な格子~空間$は，`格子~容器$の`内縁~size$に等しい
］ものと扱う。
◎
If this would cause the grid to be larger than the grid container’s inner size as limited by its max-width/height, then redo this step, treating the available grid space as equal to the grid container’s inner size when it’s sized to its max-width/height.
</p>

		</section>
		<section id="algo-flex-tracks">
<h3 title="Expand Flexible Tracks">12.7. ~flex可能な筋を拡げる</h3>

<p>
この段では、
`~flex可能$な筋を［
`可用な空間$を超過せずに `fr$u にアテガえる，最~大な値
］を利用して~sizeする。
◎
This step sizes flexible tracks using the largest value it can assign to an fr without exceeding the available space.
</p>

<ol>
	<li>
%使用~flex割合分 ~LET 0
（格子の使用`~flex割合分$を表す）
◎
First, find the grid’s used flex fraction:
</li>
	<li>
~IF［
`~free空間$ ~EQ 0
］~OR［
`最小-内容~拘束$の下で`格子~容器$を~sizeしている
］
⇒
何もしない
◎
If the free space is zero or if sizing the grid container under a min-content constraint:
• The used flex fraction is zero.
</li>
	<li>
~ELIF［
`~free空間$は`確定的$である
］
⇒
%使用~flex割合分 ~SET `~fr~sizeを見出す$( すべての`筋$, `可用な格子~空間$ )
◎
Otherwise, if the free space is a definite length:
• The used flex fraction is the result of finding the size of an fr using all of the grid tracks and a space to fill of the available grid space. 
</li>
	<li>
<p>
~ELSE（ `~free空間$は`不定$である）：
◎
Otherwise, if the free space is an indefinite length:
• The used flex fraction is the maximum of:
</p>
		<ol>
			<li>
<p>
~EACH( `~flex可能$な筋 %筋 )
に対し：
</p>
				<ol>
					<li>
%基底~size ~LET %筋 の`基底~size$
</li>
					<li>
~IF［
%筋 の`~flex係数$ ~GT 1
］
⇒
%基底~size ~SET %基底~size ~DIV %筋 の`~flex係数$
</li>
					<li>
%使用~flex割合分 ~SET `max^op( %使用~flex割合分, %基底~size )
</li>
				</ol>
◎
For each flexible track, if the flexible track’s flex factor is greater than one, the result of dividing the track’s base size by its flex factor; otherwise, the track’s base size.
</li>
			<li>
<p>
格子を成す
~EACH( `駒$ %駒 )
に対し：
</p>
				<ol>
					<li>
~IF［
%駒 は`~flex可能$な筋に交叉しない
］
⇒
~CONTINUE
</li>
					<li>
%駒~fr~size ~LET `~fr~sizeを見出す$( %駒 が交叉する筋~すべて, %駒 の`最大-内容~供与$ )
</li>
					<li>
%使用~flex割合分 ~SET `max^op( %使用~flex割合分, %駒~fr~size )
</li>
				</ol>
◎
For each grid item that crosses a flexible track, the result of finding the size of an fr using all the grid tracks that the item crosses and a space to fill of the item’s max-content contribution.
</li>
		</ol>

<div class="p">
<p>
この`~flex割合分$の利用により、
`格子$が`格子~容器$の［
`min-width$p ／ `min-height$p 
］より小さくなる場合
（あるいは［
`max-width$p ／ `max-height$p 
］より大きくなる場合）
⇒
次を加味する下で，この段をやり直す：
</p>
			<ul>
				<li>
`~free空間$は確定的であるものと扱う。
</li>
				<li>
格子を，その［
`min-width$p ／ `min-height$p 
］（あるいは
`max-width$p ／ `max-height$p
）に~sizeするときは、［
`可用な格子~空間$は，`格子~容器$の`内縁~size$に等しい
］ものと扱う。
</li>
			</ul>

◎
If using this flex fraction would cause the grid to be smaller than the grid container’s min-width/height (or larger than the grid container’s max-width/height), then redo this step, treating the free space as definite and the available grid space as equal to the grid container’s inner size when it’s sized to its min-width/height (max-width/height).
</div>

	</li>
	<li>
~EACH( `~flex可能$な筋 %筋 )
に対し
⇒
%筋 の`基底~size$ ~SET
`max^op( %筋 の`基底~size$, ( %使用~flex割合分 ~MUL ( %筋 の`~flex係数$ ) )
◎
For each flexible track, if the product of the used flex fraction and the track’s flex factor is greater than the track’s base size, set its base size to that product.
</li>
</ol>

			<section id="algo-find-fr-size">
<h4 title="Find the Size of an fr">12.7.1. `fr^u ~sizeを見出す</h4>

<p>
この~algoは、
所与の
( `筋$たちが成す集合 %S, ~target~size
`埋める空間@V
)
に対し，［
%埋める空間 を超過しない下で `fr$u 単位がとり得る，最~大な~size
］を見出す：
◎
This algorithm finds the largest size that an fr unit can be without exceeding the target size. It must be called with a set of grid tracks and some quantity of space to fill.
</p>

<ol>
	<li>
%F ~LET %S 内の`~flex可能$な筋からなる集合
◎
↓</li>
	<li>
<p>
~WHILE 無条件
◎
↓</p>
		<ol>
			<li>
`残余~空間@V ~LET
%埋める空間 ~MINUS ∑ ( %筋 の`基底~size$ ； %筋 ~IN %S ~AND %筋 ~NIN %F ) )
◎
Let leftover space be the space to fill minus the base sizes of the non-flexible grid tracks.
</li>
			<li>
%~flex係数の総和 ~LET
`max^op( 1, ∑ ( %筋 の`~flex係数$ ； %筋 ~IN %F ) )
◎
Let flex factor sum be the sum of the flex factors of the flexible tracks. If this value is less than 1, set it to 1 instead.
</li>
			<li>
%仮の~fr~size ~LET `残余~空間$V ~DIV %~flex係数の総和
◎
Let the hypothetical fr size be the leftover space divided by the flex factor sum.
</li>
			<li>
%F を成す
~EACH( %筋 )
に対し
⇒
~IF［
( %仮の~fr~size ~MUL %筋 の`~flex係数$ ) ~LT %筋 の`基底~size$
］
⇒
%筋 を %F から除去する
◎
If the product of the hypothetical fr size and a flexible track’s flex factor is less than the track’s base size, restart this algorithm treating all such tracks as inflexible.
</li>
			<li>
~IF［
前~段で %F から除去された筋は無い
］
⇒
~RET %仮の~fr~size
◎
Return the hypothetical fr size.
</li>
		</ol>
	</li>
<!-- 

T = ∅
→
仮fr × flex係数 < ∑ 基底(筋 in T)
∑ 基底(筋 in T) >
	仮fr × ∑ flex係数(筋 in T) 
	= 残余
	= %埋める空間 − ∑ 基底(筋 in S \ T)
→
∑ 基底(筋 in S) > %埋める空間 になる

従って、
%埋める空間 > ∑ 基底(筋 in S) が前提でなければならない

-->
</ol>

			</section>
		</section>
		<section id="algo-stretch">
<h3 title="Stretch auto Tracks">12.8. `auto^v 筋を伸張する</h3>

<p>
この段は、
`格子~容器$の`内容-分布~prop$がこの軸において［
`~normalJC$v ／ `~stretchAC$v
］のとき，［
`~max筋~sizing関数$が `auto$vt にされた筋
］たちを［
残っている`確定的$かつ正な`~free空間$を~~均等に分ける
］ことにより拡げる。
`~free空間$は`不定$であるが`格子~容器$の［
`min-width$p ／ `min-height$p
］は`確定的$である場合、
この段のために`~free空間$を計算するときには，代わりに その確定的~sizeを利用する。
◎
When the content-distribution property of the grid container is normal or stretch in this axis, this step expands tracks that have an auto max track sizing function by dividing any remaining positive, definite free space equally amongst them. If the free space is indefinite, but the grid container has a definite min-width/height, use that size to calculate the free space for this step instead.
</p>

		</section>
	</section>
	<section id="pagination">
<h2 title="Fragmenting Grid Layout">13. 格子~layoutの断片化-法</h2>

<p>
`格子~容器$は、
各~筋rcの合間や駒の内側で`分断$され，何~pageかに渡り得る。
各種 `break-*$p ~propは、
格子~容器にも，それが関与する整形~文脈において通常通り適用される。
この節では、［
分断が格子~駒, およびその内容にどう適用されるか
］について定義する。
◎
Grid containers can break across pages between rows or columns and inside items. The break-* properties apply to grid containers as normal for the formatting context in which they participate. This section defines how they apply to grid items and the contents of grid items.
</p>

<p>
以下の分断ng規則の下での， “~page” とは、
`断片化~容器$を指す。
同じ規則は，他の`断片化~文脈$においても適用される
（必要に応じて， “~page” を適切な`断片化~容器$の種別に読み替える）
— `CSS3-BREAK$r を見よ。
◎
 The following breaking rules refer to the fragmentation container as the “page”. The same rules apply in any other fragmentation context. (Substitute “page” with the appropriate fragmentation container type as needed.) See the CSS Fragmentation Module [CSS3-BREAK].
</p>

<p>
断片化された格子~容器の正確な~layoutは、
この~level 2 では定義されない。
ただし、
格子~容器の内側にある分断は，次の規則の~subjectになる：
◎
The exact layout of a fragmented grid container is not defined in this level of Grid Layout. However, breaks inside a grid container are subject to the following rules:
</p>

<ul>
	<li>
`格子~駒$の［
`break-before$p／`break-after$p
］~propは、
それが~spanする格子~rowへ伝播する。
［
最初の~rowの `break-before$p ／
最後の~rowの `break-after$p
］~propは、
格子~容器へ伝播する。
◎
The break-before and break-after properties on grid items are propagated to their grid row. The break-before property on the first row and the break-after property on the last row are propagated to the grid container.
</li>
	<li>
格子~駒の内側にある強制d分断は、
実質的に その内容の~sizeを増やす
— これは、
同胞の各~駒の内側には強制d分断を誘発しない。
◎
A forced break inside a grid item effectively increases the size of its contents; it does not trigger a forced break inside sibling items.
</li>
	<li>
［
軸に適切な方の筋rc間の合間
］には， `A類の分断~機会$が生じる。
［［
最初／最後
］の筋rc, 格子~容器の内容~辺
］の合間には， `C類の分断~機会$が生じる。
`CSS3-BREAK$r
◎
Class A break opportunities occur between rows or columns (whichever is in the appropriate axis), and Class C break opportunities occur between the first/last row (column) and the grid container’s content edges. [CSS3-BREAK]
</li>
	<li>
格子~容器が分断の後も継続するときは、
【分断より後の~pageにて】その`格子~駒$たちに可用な（断片化~文脈の塊~flow方向の）空間は、
【分断より】前の~page上にて格子~容器の断片たちが消費した空間だけ，削減される。
格子~容器の【分断より後の】断片により消費される空間は、
【分断より後の】~page上の その内容~boxの~sizeである。
この調整による結果，可用な空間が負になった場合、
0 に設定される。
◎
When a grid container is continued after a break, the space available to its grid items (in the block flow direction of the fragmentation context) is reduced by the space consumed by grid container fragments on previous pages. The space consumed by a grid container fragment is the size of its content box on that page. If as a result of this adjustment the available space becomes negative, it is set to zero.
</li>
	<li>
上に挙げた各項により課される駒たちの再配列は別として、
~UAは，格子~容器の歪みを［
断片化されないときの~flowに比して最小化する
］よう試みるべきである。
◎
Aside from the rearrangement of items imposed by the previous point, UAs should attempt to minimize distortion of the grid container with respect to unfragmented flow. 
</li>
</ul>

		<section id="fragmentation-alg">
<h3 title="Sample Fragmentation Algorithm">13.1. 断片化~algoの一例</h3>

◎非規範的

<p class="issue">
これはまだ，断片化~algoの一例を示す大まかな草案に過ぎず，
`CSS-FLEXBOX-1$r による~algoと突き合わせて厳しく検査する必要がある。
`Feedback overall is welcome; please reference the rules above instead as implementation guidance.^en
【以下は、横組みを念頭に記されている。縦組みの場合は，横幅と縦幅の役割が入れ替わるであろう。】
◎
This is a rough draft of one possible fragmentation algorithm, and still needs to be severely cross-checked with the [CSS-FLEXBOX-1] algorithm for consistency. Feedback is welcome; please reference the rules above instead as implementation guidance. 
</p>

<ol>
	<li>
`§ 格子~layout~algo$に従って，格子を~layoutする
— 格子の［
`行内~size$は`断片化~容器$のそれ,
`塊~size$は無制限
］であるものと見做した下で。
`grid-row$p に対する `auto$vt 値, `fr$u 単位の値は、
すべて この段の間に解決するモノトスル。
◎
Layout the grid following the § 12 Grid Layout Algorithm by using the fragmentation container’s inline size and assume unlimited block size. During this step all grid-row auto and fr values must be resolved.
</li>
	<li>
前~段で解決された値を利用して格子~容器を~layoutする。
◎
Layout the grid container using the values resolved in the previous step.
</li>
	<li>
<p>
断片化により ある区画の~sizeが変化した場合
（これを決めるにあたり，複数の~rowに~spanする駒は含めないこと）、
~OR↓ を満たす各~row用に，必要yなだけ格子~row~sizeを増やす：
◎
If a grid area’s size changes due to fragmentation (do not include items that span rows in this decision), increase the grid row size as necessary for rows that either:
</p>
		<ul>
			<li>
~rowの`~min筋~sizing関数$は `*-content^v である。
◎
have a content min track sizing function.
</li>
			<li>
~rowは，明示的な縦幅を持たない格子に属し，`~flex可能$でもある。
◎
are in a grid that does not have an explicit height and the grid row is flexible.
</li>
		</ul>

	<li>
格子の縦幅が `auto$vt【！auto】 の場合、
格子の縦幅は，各~rowの最終的な~sizeの総和になるべきである。
◎
If the grid height is auto, the height of the grid should be the sum of the final row sizes.
</li>
	<li>
断片化において~marginが`相殺-$されたために，区画が格子~容器を~overflowする場合、
その区画を包含するよう格子~容器を拡張する
（この段は、
断片化による~layoutの循環依存を避けるために必要yである。）
◎
If a grid area overflows the grid container due to margins being collapsed during fragmentation, extend the grid container to contain this grid area (this step is necessary in order to avoid circular layout dependencies due to fragmentation). 
</li>
</ol>

<p class="note">注記：
格子に縦幅が指定されている場合、
3 段~目, 4 段~目において，格子~rowは格子を~overflowし得る。
◎
If the grid’s height is specified, steps three and four may cause the grid rows to overflow the grid. 
</p>

		</section>
	</section>
	<section id="priv">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この仕様は、
新たな~privacy漏洩を導入するものではない。
◎
Grid introduces no new privacy leaks.
Grid introduces no new privacy leaks, or security considerations beyond "implement it correctly".
</p>

	</section>
	<section id="sec">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
この仕様は、
“正しく実装すること” を超える~securityの考慮点を導入するものではない。
◎
Grid introduces no new security considerations beyond "implement it correctly".
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p class="trans-note">【
この節の内容は未訳。
】</p>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgements">謝辞</h2>

<p>
下位格子~特能は、
Mozilla の `Mats Palmgren^en 氏による~supportと~feedbackが無ければ，先へ進めなかった。
`Daniel Tonon^en 氏は、
下位格子における~gapの聡明な取扱いを~~追求され，~~絵図も供与された。
`Rachel Andrew^en, `Jen Simmons^en
両氏は、
~CSS~WGと~Web［
設計／著作
］~communityからの~feedbackとの隔たりの橋渡しに助力された。
◎
Many thanks to Mats Palmgren of Mozilla, without whose support and feedback the subgrid feature would not be able to move forward. Thanks also to Daniel Tonon, who insisted on intelligent handling of gaps in subgrids and contributed illustrations; and Rachel Andrew and Jen Simmons who helped bridge the feedback gap between the CSS Working Group and the Web design/authoring community.
</p>

<p>
最後に、
記念碑的な`~level 1$ の~taskをアリにした，すべての方々に。
◎
Lastly, the acknowledgements section of CSS Grid Level 2 would be incomplete without acknowledgement of everyone who made the monumental task of CSS Grid Level 1 possible.
</p>

	</section>
</main></div>
