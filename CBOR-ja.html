<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>RFC 8949 — Concise Binary Object Representation (CBOR)（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="RFC-common.css" type="text/css">

<style>
td {
border-top: thin solid var(--pale-color);
}

.tag-number {
	font-family: sans-serif0, sans-serif;
	color: var(--text-color-2);
}
.major-type {
	color: var(--text-color-4);
	font-family: sans-serif0, sans-serif;
}

.additional-info {
	font-family: sans-serif0, sans-serif;
}

.diagnostic {
	color: var(--text-color-3);
}
</style>



<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const section_id_map = this.section_id_map;


	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^§])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#${key}`;
	break;
case 'l': // octet literal
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'X': // hex
	text = `0x${text}`;
	break;
case 'B': // binary
	text = `0b${text}`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'tag': // tag number
	href = `#tag-number-${key}`;
	break;
case 'mj': // major type
	href = `#major-type-${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '§':
		text = ` <a href="${href}">§ ${text}</a> `;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Concise Binary Object Representation (CBOR)
trans_update:2022-08-03
original_url:https://www.rfc-editor.org/rfc/rfc8949
spec_status:IETFPR
	source_checked:201200
no_original_dfn:true
no_index:true
toc:toc
ref_id_prefix:
ref_rfc:true
	site_nav:
trans_1st_pub:2022-08-03

●●class_map
P:production
X:hex-value
hex:hex-value
B:hex-value
U:code-point
cn:cp-name
tag:tag-number
mj:major-type
ai:additional-info
cn:cp-name
dg:diagnostic
cmt:comment
2119:rfc2119

●●tag_map
P:code
c:code
s:samp
X:span
hex:span
B:span
U:span
cn:span
tag:span
mj:span
ai:span
dg:code
cmt:span
i:i
2119:em


●●mdn_urls

●●link_map

	https://tools.ietf.org/html/ → https://datatracker.ietf.org/doc/html/

~data~item:#CBOR-data-item
符号化された~data~item:#CBOR-encoded-data-item

復号器:#CBOR-decoder
符号化器:#CBOR-encoder
~data~stream:#CBOR-data-stream
整形式:#CBOR-well-formed
妥当:#CBOR-valid
期待され:#CBOR-expected
~stream復号器:#stream-decoder
~break:#break-stop-code

~integer:#integer
~UTF-8~string:#utf-8-string
~text~string:#text-string
~byte~string:#byte-string
~array:#array
~map:#map
~entry:#map-entry
~key:#map-key
値:#map-value
~map~key:#map-key
単純~値:#simple-value
~float:#floating-point-number
	~float~number:#floating-point-number

i.undefined:#undefined
i.false:#false
i.true:#true
i.null:#null

半-精度~float:#half-precision-float
単-精度~float:#single-precision-float
倍-精度~float:#double-precision-float
半-精度:#half-precision-float
単-精度:#single-precision-float
倍-精度:#double-precision-float
	~binary16

確定長:#definite-length
不定長:#indefinite-length

汎用~data~model:#generic-data-model

拡張された汎用~data~model:#extended-generic-data-models

~major型:#major-type
追加l情報:#additional-information
引数:#argument
~head:#head
先頭~byte:#initial-byte


~tag:#tag
~tag番号:#tag-number
~tag内容:#tag-content

~bigfloat:#bigfloat
~decimal小数:#decimal-fraction
~bignum:#bignum

~streamして:#streaming

決定論的な符号化法の中核~要件:#core-deterministic-encoding-requirements
長さ優先な決定論的な符号化法の中核~要件:#length-first-core-deterministic-encoding-requirements

~repertoire:https://www.unicode.org/glossary/#character_repertoire

	●§
1:#introduction
1.1:#objectives
1.2:#terminology
2:#cbor-data-models
2.1:#extended-generic-data-models
2.2:#specific-data-models
3:#encoding
3.1:#majortypes
3.2:#indefinite
3.2.1:#break
3.2.2:#indef
3.2.3:#indefinite-length-byte-strings-and-text-strings
3.2.4:#summary-of-indefinite-length-use-of-major-types
3.3:#fpnocont
3.4:#tags
3.4.1:#stringdatetimesect
3.4.2:#epochdatetimesect
3.4.3:#bignums
3.4.4:#fractions
3.4.5.1:#embedded-di
3.4.5.2:#convexpect
3.4.5.3:#encodedtext
3.4.6:#self-describe
4:#serialization-considerations
4.1:#preferred
4.2:#det-enc
4.2.1:#core-det
4.2.2:#additional-deterministic-encoding-considerations
4.2.3:#length-first
5:#creating-cbor-based-protocols
5.1:#embedded-di
5.2:#generic
5.3:#semantic-errors
5.3.1:#basic-validity
5.3.2:#tag-validity
5.4:#validity-checking
5.5:#numbers
5.6:#map-keys
5.6.1:#equivalence-of-keys
6:#converting-data-between-cbor-and-json
6.1:#converting-from-cbor-to-json
6.2:#converting-from-json
7:#future-evolution-of-cbor
7.1:#extension-points
7.2:#curating
8:#diagnostic-notation
8.1:#encoding-indicators
9:#ianacons
9.1:#ianasimple
9.2:#ianatags
9.3:#media-type-mime-type
9.4:#coap-content-format
9.5:#the-cbor-structured-syntax-suffix-registration
10:#securitycons

A:#examples
B:#jump-table
C:#pseudocode
D:#half-precision
E:#comparison-app
F:#errors

先着順に~serveされ:~RFCx/rfc8126#section-4.4
仕様が要求され:~RFCx/rfc8126#section-4.6
標準~化を通して:~RFCx/rfc8126#section-4.9

	表0 1:#major-type-table
	表0 2:#major-type-indef-table
	表0 3:#fpnoconttbl
	表0 4:#fpnoconttbl2
	表0 5:#tagvalues
	表0 6:#table_examples
	表0 7:#jumptable
	表0 8:#concise

●●ref_data

●●words_table1

ナラナイ:<em class="rfc2119">ならない</em>
ベキ:<em class="rfc2119">べき</em>
ヨイ:<em class="rfc2119">よい</em>
POW:<span class="op">pow</span>
break:<i>break</i>

●●words_table

●名称／略語

Internet:
	~ASCII
ASN1:ASN.1
BCP:
BER:
BSON:
BinaryPack:
C:
	~C言語:C
CBOR:
CPU:
CoAP:
CoRE:
DER:
ECMA262:
I-JSON:
IEEE754:IEEE 754
IESG:
ISO:
Internet-Draft:
IoT:
MSDTP:
MessagePack:
MongoDB:
PCRE2:
PCRE:
PER:
POSIX:
Python:
RESTful:
RPC:
TLS:
UBJSON:
UTC:
YAML:
	拡張された診断用の記法（ EDN ）:"Extended Diagnostic Notation" (EDN)
	決定論的な符号化法の中核~要件:Core Deterministic Encoding Requirements
	正準的~CBOR:Canonical CBOR
	^en:Applications and Real-Time Area
	CoAP
	~CoAP内容~形式~entry:CoAP Content-Format entry
	内容~形式:Content-Format
	~MIME型:Media Types
	~message~service~data転送／^en:Message Services Data Transmission
	Perl 互換な正規表現／^en:Perl Compatible Regular Expressions
	有構造~構文~接尾辞／^en:Structured Syntax Suffixes
	普遍的な~binary~JOSN／^en:Universal Binary JSON:#1
	^en:Concise Binary Object Representation
	^en:Packed Encoding Rules
	^en:Constrained Application Protocol
	^en:Constrained RESTful Environments Parameters
	^i:binaryjs
	^i:msgpack-js-browser
	^i:msgpack-js:#1
	^i:xml2rfc
	^r:CNN-TERMS
	C++
	~CBOR~tag~registry^cite:"Concise Binary Object Representation (CBOR) Tags" registry
	~CBOR単純~値~registry^cite:"Concise Binary Object Representation (CBOR) Simple Values" registry

	●data／構造／型／形式
major:
有限:finite::~
	非-有限:~non-finite
数量-:numeric:~
数量的:numerical:~
先頭:initial:~
	先頭~byte:initial byte
	先頭~byte:the first byte
	先頭~byte + n ~byte:"1+n"
	先頭~byteのみ:"1+0"
	~head$:initial bytes
	~head$:initial byte and following bytes
tag:
	~tag内容$:tagged data item
	~tag付き:presence of the tag
	~tag付きでない:untagged
	~tag付き:tagged
	~tag付け:taging
bignum:
floating-point:
Infinity:
NaN:
	^en:signaling NaN
	^en:NaN payload
subnormal:
integer:
	~integerとして等しい:integral
	ある~integerに等しい値:integral-valued
byte:
text:
string:
array:
multimap:
map:
big:
stack:
tree:
object:
float:
	float:floating-point
	float:floating-point number
bigfloat:
	Bigfloat:bigfloat
number:
番号:number::~
uint8_t:
uint16_t:
uint32_t:
uint64_t:
int64_t:
	XX ~bit無符号~整数
有符号:signed:~
無符号:unsigned:~
正負符号:sign:符号
確定長:definite-length::長さ確定
不定長:indefinite-length::長さ不定
不定:indefinite::~
確定:definite::~
日時:date/time::~
半-:half-:~
単-:single-:~
倍-:double-:~
追加l:additional::追加
無構造:unstructured:~
等価性:equivalence:~
	等価性:equivalency
chunk:
epoch:
	~epochに基づく:epoch-based
hash::::ハッシュ
生な:rawな:~
blob:
裸の:bare:~
URI:

	~byte列:sequence of bytes
	一連の~byte:bytes
	~byte列:bytes
	~byte数:bytes
	複-~byte:multi-byte
	単-~byte:single-byte
	2 ~byteからなる:two-byte
	1 ~byteからなる:one-byte
	4 ~byteからなる:four-byte
	8 ~byteからなる:eight-byte
	bit:
	半-精度:16-bit
	単-精度:32-bit
	倍-精度:64-bit
	半-精度~float:binary16
	単-精度~float:binary32
	倍-精度~float:binary64
	16 ~bit:16-bit
	32 ~bit:32-bit
	64 ~bit:64-bit
	128 ~bit:128-bit
	256 ~bit:256-bit
	5 ~bitからなる:5-bit
	`追加l情報$:5-bit value
	辞書:dictionaries
	~tuple:tuple
	~pair:pair
	負でない:nonnegative
	偶数:even
	奇数:odd
	1 個の~integerを成す:single-integer
	{ 〜 }:inclusive
	妥当性を検査する:validity-checking
	素な~text:plain-text
	~entry:key/value pair
	下位-構造:substructure
	含む:includeする
	含め:including
	含まな:includeしな
	~POW():power of
	下位-型:subtype
	下位-空間:subspace
	~hash~table:hash-table
	先頭~byte + n ~byte:"1+n"
	先頭~byteのみ:"1+0"
	0 で拡張し:zero-extending
	~data~item$:CBOR~data~item
	~data~item$:CBOR~item 
	 〜 が後続する:followed by 〜
	^en:UNIX Epoch
	^en:loop
	^en:lattice-style graph
	^en:class 1
	^c:Map
	^i:undefined
	^i:false
	^i:true
	^i:null


	●構文／符号化
bit:
binary:
hexadecimal:
decimal:
base-:base-* 
	~base-符号化法:alternate encoding
base64url:
base64:
base16:
base32:
base32hex:
小数:fraction::~
小数部:fractional part::~
小数な:fractionalな::小数を伴う
	小数を伴う秒:nonzero fractions of seconds
冪指数:scaling factor::~
指数:exponent::~
	指数~化:exponentiation
仮数部:significand::~
仮数:mantissa::~
surrogate::::サロゲート
head:
alphabetic:
alphabetics:
alphabet:
tilde:
hex:
辞書式:lexicographic:~
	辞書式:lexical
	~byteごとの辞書式~順序:bytewise lexicographic order
	~byteごとの辞書式~順序:the one with the lower value in (bytewise) lexical order
基数:base::~
	基数 10 の:base-10
	基数 2 の:base-2
	等号:equals sign:~
	2 の補数:two's complement
補数:complement::~
	上位:high-order
	下位:low-order
先行-:precede:~
後続-:follow:~
	 〜 が後続する:followed-by 〜
復号:decoding::~::デコーディング
	復号-時:decoding
	復号-可能:decodable
符号化:encoding::~::エンコーディング
符号化器:encoder::~::エンコーダ
圧縮:compression::~
改行:line break:~
改行文字:newline character:~
整形式:well-formed::~
整形式性:well-formedness::~
	整形式な~data~item:well-formed CBOR encoded data item
	整形式な~data~item:well-formed encoded data item
	整形式な~data~item:well-formed data item
封入-:enclose::~
	括られ:enclose／:-
接頭-:prefix::~
underscore:
符号点:codepoint::~

運んで:carryして:~
運ぶ:carryする:~
運ばな:carryしな:~
交換:interchange::~
交換-:interchange::~
	交換-可能:interchangeable
診断:diagnostic::~
診断用の:diagnostic::~
mark::::マーク
marker::::マーカ
角括弧:bracket:~
波括弧:brace:~
丸括弧:parenthesis:~
補充:padding::~
補充-:pad::~
	~bit 0 で補充:zero-padding
	補充~文字:padding
	補充~文字:padding character
不正形な:malformed:不正な形の

	置換するもの:replacement
	任意な長さの:arbitrary-length
	精度が任意な:arbitrary-precision
	任意な~sizeの:arbitrarily sized
	一連の文字:sequence of characters
	REVERSE SOLIDUS^cn:reverse solidus
	QUOTATION MARK^cn:quotation mark
英数字:alphanumeric:~
数字:decimal digit:~
閉じる:closeする:~
閉じら:closeさ:~
	~escape法:escaping
切落とさ:truncateさ:切り落とさ
切落とす:truncateする:切り落とす
重複:duplicate::~
	一重-引用符:single quote
	二重-引用符:quotation mark
	〜が占める位置:position
C0:
span:
	^en:null-byte
	^en:big-endian
	左:opening
repertoire::::レパートリ
区切る:delimitする:~

	●network
到着-:arrive:~
伝送路:wire::~

	●処理
連結-:concatenate::~
連結:concatenation::~
回送-:forward::~
算術:arithmetic:~
代用-:substitute:~
変換器:converter::~
発-:emit::~
逆直列化:deserialization::~::逆シリアル化
overflow::::オーバーフロー
underflow::::アンダーフロー
形式変換:transformation::~
発行-:issue:~
増分的:incremental::~
結集-:marshal:~
時機:timing:~
尚早:premature:~
命令:instruction::~
丸め:rounding:~
shift::::シフト
展開-:expand::~
展開:expansion::~
書込んで:writeして::書き込んで
提起-:raise:~

	~call元:caller
	~streamしている:streaming
	~stream用の:streaming
	渡せる:pass
	渡す:pass
	次は〜~testする:repeat the process
	~~上限:threshold
	^en:roundTiesToEven
	~~正しく行う:get right

	●保安
署名-:sign::~
firewall::::ファイアーウォール
暗号化-:encrypt::~
悪用-:exploit:~
防御者:defender::~
細工-:craft::~
秘匿:secret:~
線形:linear::~
	線形を超える:superlinear
未検証:unvalidated:~
overrun::::オーバーラン
crash::::クラッシュ

	●仕様
目標群:objectives:~
節約-:save:~
品質:quality:~
回復:recovery:~
損傷-:damage:~
安定的:stable:~
非互換性:incompatibility:~
利用度:usage:~
設計者:designer:~
相互運用-:interoperate:~
助言:advice:~
策:strategy:~
発展:evolution:~
発展-:evolve:~
協力-:cooperate:~
破損-:corrupt:~
採用-:adopt:~
適度:reasonable:~
現今の:contemporaryな:~
安上がり:frugal:~
表記-:denote:~
自由度:freedom:~
翻訳-:translate:~
同義語:synonym:~
手助け:facilitate:~
目指す:aimする:~
発生-:arise:~
収容-:accommodate:~
普遍的:universal:~
満足する:satisfyする:満たす
有益:beneficial:~
古典的:classical:~
合意-:agree:~
不自然:unnatural:~
自明:trivial:~
	自明でない:nontrivial
一意性:uniqueness:~
処-:deal:~
衝突:collision:~
危険性:danger:~
機会:opportunity:~
故意:deliberate:~
未拡張な:unextendedな:~
馴染みな:familiarな:~
拡げら:expandさ:~
狭めら:shrinkさ:~
見極める:ascertainする:~
overhead::::オーバーヘッド
呈-:exhibit:~
知覚-:perceive:~
制定-:prescribe:~
害:harm:~
	害が及ばない:without harm
最大化-:maximize:~
ecosystem::::エコシステム
project::::プロジェクト
英語:English:~
収まる:fitする:~
記す:notateする:~
記され:notateされ:~
記せ:notateでき:~
分野:domain:~
念頭:mind:~
思考:mind:~
価値:value:~
著作権:copyright:~
告知:notice:~
周知:well known:~
変種:variant:~
検査ng:checking:検査
面倒:onerous:~
欠如:lack:~
尊重-:respect:~
相似物:analog:~
病的:pathological:~
主観的:subjective:~
教本:textbook:~
膨大:abundant:~
候補:candidate:~
実体:entity:~
妨害-:disrupt:~
	妨害-:disruption:~
枯渇:exhaustion:~
枯渇-:exhaust:~
深く:deepに:~
深さ:depth:~
堅牢性:robustness:~
今日:today:~
立証-:prove:~
読者:reader:~
批判:criticism:~
優先度:priority:~
採用:adoption:~
事務的:clerical:~
対称性:symmetry:~
版:edition:~
厳格:stringent:~
着想-:inspire:~
帰属:attribution:~
予知-:foresee:~
明白:obvious:~
決定論的:deterministic:~
	決定論的に:deterministically
寛容:tolerant:~
絶対要件:imperative:~
派生:derivation:~
進歩-:advance:~
負担:burden:~
断続的:continual:~
多方面:extensive:~
準備-:prepare:~
頻繁:frequent:~
	さほど頻繁にない:less frequently
機械的:mechanical:~
硬直化:ossification:~
喪失:loss:~
受容:acceptance:~
一式:suites:~
準拠-:comply:~
	~~推定-:presume:~
想定-:suppose:~
支配-:dominate:~
簡潔:concise:~
	簡潔さ:conciseness
遅滞-:impede:~
注力-:focus:~
築け:buildでき:~
演習-:exercise:~
精選:curation:~
精選-:curate:~
余計:extraneous:~
受理不能:inadmissible:~
受理可能:admissible:~
表出:expression:~
同一視-:equate:~
借用-:borrow:~
	本当:real
長期的:long-term:~
構成-:compose:~
疑似-:pseudo-:~
	疑似-~code:pseudocode
副次的:secondary:~
強勢-:emphasize:~
	強勢しなくする:de-emphasizing
	強勢する:words emphasis
現実:real-world:~
連絡先:contact:~
	連絡先:point of contact
継目なく:seamlessに:継ぎ目なく
鋭敏に:sharpen:~
救済-:remedy:~
非決定的:indeterminate:~
最先端:state of the art:~
設置-:place:~
基礎:basis:~
主要:major:~
文言:language:~
存続期間:lifetime:~
特質:property:~:::プロパティ
帯域外:out-of-band:~
成長-:grow:~
別物:distinct:~
参照r:refer:参照
申請者:applicant:~
容認-:condone:~
強調-:highlight:~
表0:table:表
分岐表:jump table:~
隙間:gap:~
移行期:transition:~
雛形:template:~
種類:kind:~
	さらに 5 種類に分かれる:five subkinds
選んで:chooseして:~
選ぶ:chooseする:~
選ばな:chooseしな:~
選ばれ:chooseされ:~
選べる:chooseできる:~
選択肢:choice:~
	選択肢をとらせる:make 〜 choice
	選ぶこと／選ぶ／どちらを選ぶか:choice
	に絞る:pick
	絞らな:pick
open:
可読:readable:~
	ヒトが可読な:human-readable
自己を:self-:~
多様さ:variety:~
多様性:variation:~
多様な:varietyが広い:~
	多様な:wide variety of
為され:makeされ:~
為して:makeして:~

	より表現力が高い:more expressive
	表現力に劣る:less-expressive
	原因になる:cause
	もたらす:cause
	なり得る:can go into
	相互:to and from
	課す:has
	課され／課す:pose
	でしかない:just
	足る:sufficient
	利用-可能:usable
	今や~~慣例になった:its now-customary sense
	用立てる:make use
	指すときは〜も:can be addressed
	〜には:speaking
	成す:make up
	従う:follow
	挙げる:list
	極めて:extremely
	標準~化:standardize
	一般~化:generalize
	かける労:amount of effort
	有用さ:usefulness
	としても知られる:known as
	〜は別として:beside
	概ね:roughly
	期待されない:unexpected
	問題になり得る:problematic
	言い回し:wording
	予測-可能:predictable
	相応に~fairly
	最も知られた:best known
	満たさ:met
	優先される:secondary to
	数十年／十年:decade
	あと何十年か:a few more decades
	好ましい:preferable
	その逆を行う:vice versa
	-:vice versa
	損なう:detract
	現時点では:currently
	~CBORの現~version:the present version of CBOR
	~CBORの現~version:the present specification
	~CBORの現~version:the present document
	現時点の この〜:present
	称されるときもある:sometimes also referred to
	総称され:collectively referred
	と称される:referred
	どう〜とは異なる:differently
	〜を表す:stands for
	してもかまわない:free to
	知る:know
	至らす:lead
	至り:lead
	定かで:certain
	十分:enough
	真に:truly
	難しい:hard
	第二の:secondary
	注記:note
	区別する:differentiation
	許容しない:disallow
	容易にする:ease
	可能性:possibility
	異なる:different
	起こる:happenする
	不必要な:unnecessary
	転換する:turn into
	必要以上に長い:longer-than-needed
	実装の品質:quality-of-implementation
	〜に関する:with respect to
	保たれ:kept
	保つ:keepする:~
	保ち:keepし:~
	保たな:keepしな:~
	処理-可能:processable
	訴えた:complain
	考慮し直すこと:reconsideration
	規範的でない:informative
	多岐にわたる:a diverse set of
	受容-能:acceptability
	至った:led to
	表面的に:surface
	妨げに:hampered
	足りる:will suffice
	選好されない:non-preferred
	見込まれる:likely
	見込みが高い:likely
	見込まれる:knows that 〜 likely to ~be
	例えば:say
	それによる:any ensuing
	後者が好ましいが:preferably
	広く:widely
	間違って:wrong
	能力がある:capable
	もちろん:of course
	目に見える:appreciable
	~~実際に:indeed
	者:someone
	添えな:impart
	無駄にもなりにくい:less wasteful
	~~簡潔にするため:for brevity
	どっちつかずに:straddle
	〜と言える:can 〜 be said to
	倣っている:in alignment with
	誤ち:mistake
	面して:facing
	誘い込む:lure
	誤り:error
	分類される:category
	活かす:exploiting
	称され:referred to
	事実:fact
	判明した:it turned out
	特に:notably
	思い浮かぶであろう:might come to mind
	一律に〜どちらかを:either to require that the tag is present or to require that it is absent, not allow either one
	気付き得ない:can't notice
	気付き得ないことすら:not even be able to notice
	気付く:notice
	およそどんな~~形をとるか:rough impression of how this could look
	伝え:say
	一部に限り，当の応用に渡す:lose some
	ならざるを得ない:necessarily
	~~留意すること:It is worth noting
	〜しまいそうだが:lest
	追認できる:tolerate and embrace
	知られる限り，:to the best of our knowledge,
	見えそう:may seem
	必要以上に:than needed
	採る:take
	採って:take
	見つけ:see
	可用でない:n/a
	指示する:give 〜 an indication
	区別:distinction
	そこを埋めて白黒つけたがる:mind is sometimes drawn to filling 〜 to make something neat
	引き寄せる:attractor
	になり得るような:happen to be
	指摘-:pointed out
	指せる:point
	指している:pointing
	~~不都合な:fine
	相互に作業する:interwork
	~~責任を課す:creating an onus
	推し進められ:promote:~
	注意:attention
	考慮点:Consideration
	人々:people
	者:people
	きちんと定義されてはいない:less well-defined
	かなり上手く:very well
	-:very well
	免れる:relieve
	可能性もある:potential
	あり得る所では:potential
	~~扱う:make
	課す:make
	替える:stand in
	〜を外すわけにいかない:cannot leave out
	〜を外す:leave out
	残され:left
	残す:leave
	残さない:leave out
	まま残され:leave
	委ねる:leave
	べき:should
	~~検知されずに:silent
	取り込む:ingest
	~~追加の:extra
	~~再構成:reconstitute:~
	概要を再掲する:brief recap
	格式ばったもの:baroque
	変更~制御者:change controller
	変更~制御者:Change Controller
	満たさなく:meet
	満たす:meet
	良い:good
	から外れる:outside
	生き続ける:live
	等しく:equally
	またがり:spread
	何もアテガわれていない:unassigned
	課さな:put
	語句:words
	〜からなる:comprising
	成す:constitute
	狭める:narrow
	費やす:expend
	費やす:spend
	費やした:spent
	助け:help
	助ける:help
	助けになる:help
	出会った:meet
	探して:looking for
	規範的でない:informational
	~~説明:illustration
	~~説明:illustrate
	条項:bullet
	その場で:in place
	その場に:in place
	占める所:in place of
	際立った:distinguishing
	〜に関する事:matter
	表す:signify
	略語:abbreviation
	~~確証を高める:increase confidence
	下位節:subsection
	緩く:loosely
	旧い:older
	旧:old
	比例する:commensurate
	問題になる:presents a problem with
	下位-~registry:subregistry
	見方:view
	標準~化を通して$:Standards Action
	先着順に~serveされ$:First Come First Served
	仕様が要求され$:Specification Required
	他の~registryの傘下:under an umbrella registry
	規範的でない部分:informational components
	~WG:the working-group
	〜においては:prerequisites
	関心がない:not interested in
	~code化:coding
	^en:Magic number(s)
	^en:Macintosh file type code(s)
	^en:directorate
	~~整理-:streamlining
	~code片:pieces of code
	必要に足る:sufficient
	提出された時点:current at the time of 〜 submission
	どこに適用されるかについて:the domain of applicability
	処理-可能:processable at all
	格式ばった:baroque
	普及している:popular
	何らかの〜をあてがう:ascribing
	受持たないこと:gap
	^en:Person &amp; email address
	どの〜か~~判別できない:might have
	さらに:additional
	~~除外される:omitted
	見る:view
	者:anyone
	取り込んだ:importation
	~~不一致:disparity
	ごく:very
	特段に:very
	^en:processing
	書き直され:rewritten
	書き直す:rewrite
	書く:write
	書ける:written
	書かれ:written
	引き出され:drawn
	引き出した:drew upon
	小さな:minor
	代替として:alternatively
	メモ:memo

	●未分類
schema::::スキーマ
遭遇-:encounter:~
最小化-:minimize:~
超過-:exceed:~
compact::::コンパクト
compactさ:compactness:::コンパクトさ
大容量:high volume:~
	大容量:high-volume
	大容量:very high volume
割振る:allocateする:割り振る
割振っ:allocateし:割り振っ
割振られ:allocateされ:割り振られ
割振り:allocation:割り振り
database::::データベース
正規表現:regular expression::~
失効:expiry:~
side-channel:side channel:::サイドチャネル
計算機-:machine::~::マシン
処理能力:processor power::~
上付文字:superscript:上付き文字
重合しな:overlapしな:重なり合わな
増やす:increaseする:~
閏秒:leap seconds:~

	~C言語:C
	~C言語:C language

	各国の:national
	暦:calendar:~
	改暦される前の:points in time that precede discontinuities in
	秒:seconds
	1 秒:1-second
	挟まれる:discontinuity
	秒数による:count-of-seconds
	秒数による:counting the number of seconds
	始まる／始まり:begin
	始める:begin
	始め:at beginning
	正準的:Canonical
	正準-化:canonicalization
	最低:lowest
	長さ優先:length-first
	長さ優先で順序付けられた:length-first-ordered
	一致:identical
	等し:equal
	呼ばれ:called
	日時:point in time or date/time
	日時:point in time
	~byteごと:byte by byte
	後で行う:later
	もの:thing
	所与の:take
	集合を成す:out of the set
	終わらす:causes no further
	分断しておく:break up
	上層:on top of
	総量:total
	総-:total
	値~型:types of values
	実装~品質に対する:quality-of-implementation
	頭部／頭部を成す:leading
	^en:civil time
	^en:the mathematical value
	来た:come
	来る:come
	現れる:appearする
	現れて:appearして
	〜が後続する:followed by〜
	置く:put
	生じたもの:occurrence
	~~連続的:contiguous
	流入して:incoming
	~port可能:portable
	~port能:portability
	成して:making up
	そのまま:unchanged
	-:leave 〜 unchanged
	無い:absent
	無いこと:absence
	共通／^en:COMMON

	●言い換え
	2 進数として全桁が 1 になるもの:binary all-ones
	在るのか無いのか:either the presence of 〜 or absence of 〜
	~text~string以外の型:A nested item of another type
	`妥当$になるため:for tag validity
	終わらす:causes no further
	高いものから順に:in decreasing order
	54 ~bit以上~要する:with more than 53 significant bits
	~~可能になる:leading to 〜 such as
	初めから〜いなかった:start using more 〜 than
	これまでの各:the previous
	それらのうち，どれか一つだけを含むよう:with only one instance of that key
	~~存在自体が:just because they are there
	〜から〜までの秒数による値:numerical value counting the number of seconds
	〜を~tag内容とする:to be put on
	簡単に埋め尽くされない:can slowly be filled
	大文字 A 〜 F を利用する下で:with uppercase alphabetics
	抽象-~levelの:for the abstract idea
	正確に どの順序で:exact sequence
	封入してもしなくても:the presence and absence of
	~~連続するよう:back-to-back
	〜に見合った:matching
	2 乗に比例する:quadratic
	0 でない:nonzero
	置換するもの:replacement
	負でない:nonnegative
	-:(mathematical function)
	多量な何かを追加-:large amounts of addition
	~MIME型:media type
	0 化され:flushed to zero
	~bit列を弄り回す:Using〜 extensive bit-fiddling
	途中で:before the end of
	~tag内容:content of tag
	~map:~CBOR~map
	~memory内:in-memory
	〜を成す:inside
	~API:programming interface
	その値を与える:the appropriate
	~byte~code:bytecode
	~remoteから:remotely
	入子にしている〜すべて:enclosing 〜 completely
	直列化の各~変種のうち どれが利用されたか:serialization variants
	個数が足らない:not closed with enough
	~~妨げる:prevent
	格納するため:for storage
	そのまま〜として:exactly as in this sentence
	“1”:"one"
	多量な何かを追加しないと完全にならない:would require large amounts of addition to be completed，
	構文~error:Errors of the third kind
	~dataが多過ぎる~error:errors of the first kind
	~dataが少な過ぎる~error:errors of the second kind
	4 文字~block:block of 4
	下位-構造:substructure
	次の 2 つに関して:two areas
	`~tag内容$:contained item
	~keyから値への:key-value
	~integerしか用いない:integer-only
	他の~data~itemの中に入子にされない:not further assembled into a larger containing data item
	下の疑似-~code:Figure
	CBOR-TAGS$r: #I-D.bormann-cbor-notable-tags
	~size:quantities

	●他
単方向:unidirectional:~
最終-:final:~
地点:point:~
近過去:recent:~

	そのまま:as-is
	まるごと:altogether
	いくつか:a number of
	かつ:both
	何であれ:whichever
	~byteごとの:bytewise
	~bitごとの:bitwise
	以後:on or after
	該当する:true
	一連の:series of
	一連の:a sequence of
	最も外縁な:outermost
	総数:total number
	いくつかの:several
	の下で:under
	に加えて:addition to
	と同じく:as with
	僅か:a tiny part of
	およそ:nearly
	残りの／残され:remaining
	少し:slightly
	後で:later
	これら数多の:the dozens of
	何年もの間:over the years
	多過ぎる:too much
	少な過ぎる:too little
	上限:upper-bound
	上限:upper limit
	この上限:this limit
	数回の:several times
	2106年初頭:early 2106
	〜年初頭からの短期間:a short period of time around early 〜
	ごく早期の:very early
	短か過ぎる:too short
	短か過ぎる:with short data
	より短い／より短く／短い方の:shorter
	最短:shortest
	短い／短くshort
	3 種の:the three
	より長くかかる:take longer
	より長い:longer
	〜から〜への:〜-to-〜
	尾部にある:trailing
	直後にある:immediately followed by
	後続の:subsequent
	全体を通して:throughout
	合間:between
	個数:number of
	結果:result
	側:side:~
	各部:parts
	より高い:higher
	何百も:hundreds
	場合もある:may be
	〜ちょうど同じく:just as
	そうならない:does not
	残り続ける:last
	を成す残り:the rest of
	他の部分:the rest of
	以降では:the rest of
	あらゆる:every
	数えられるモノ:piece
	先に来る／これまでの:~earlier
	ときには、:sometimes
	ほとんどが~mostly
	少数:small number of
	個数が少ない::small number of
	最も短く:smallest
	小さな／小さく:small
	大きく／大きい:large
	~~巨大:very large
	~~巨大:very big
	より大き:larger
	その次の:the next
	他に無い:nothing else
	各所:places of
	より低い:lower
	〜頃:around
	さらには:or even
	と同じく:as for
	（任意）:(any)
	現時点では:at this time
	時点:at the time
	いつでも:at any time
	同時に:at the same time
	そのときから:since then
	一つだけ:just one
	さほど ない:somewhat less
	一部に限り〜にもなり得る:can be 〜 as many or as few
	自体:per se
	初めから:the outset
	少しだけ〜でない:less
	なし:none
	各種:a different set of 
	各所:specific instances of
	自前では:on their own
	すでに得られた:previous
	第 11:11th
	10 億:one billion
	8 種の／8 個の:eight
	7 個の:seven
	7 年間:seven years
	半分:half
	下~半分:lower half
	上~半分:upper half
	4 分の 1:quarter
	0 でない:nonzero
	一緒:together
	少ししかない:little
	小さな:little
	最後の:final
	ある時点の時刻:points in time
	ある時点:point in
	長さ 0:zero-length
	長さを集計する:counting
	数えられ:count
	〜を数えた:counting
	回数:count
	1 列目:left column
	2 列目:right column
	1 個の文字からなる:single-character
	箇所:places
	XからYへの:X-to-Y
	-:the respective
	一群の:set of
	集合:set of
	量:amount
	右側:right
	右:right
	-:out of
	外へ:out of
	〜への:towards

●●ref_normative

[C]
    International Organization for Standardization, "Information technology - Programming languages - C", Fourth Edition, ISO/IEC 9899:2018, June 2018,
    URL: https://www.iso.org/standard/74528.html
[Cplusplus20]
    International Organization for Standardization, "Programming languages - C++", Sixth Edition, ISO/IEC DIS 14882, ISO/IEC ISO/IEC JTC1 SC22 WG21 N 4860, March 2020,
    URL: https://isocpp.org/files/papers/N4860.pdf
[IEEE754]
    IEEE, "IEEE Standard for Floating-Point Arithmetic", IEEE Std 754-2019, DOI 10.1109/IEEESTD.2019.8766229,
    URL: https://ieeexplore.ieee.org/document/8766229
[RFC2045]
    Freed, N. and N. Borenstein, "Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies", ~RFC2045, November 1996,
    URL: https://www.rfc-editor.org/info/rfc2045
[RFC2119]
    Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, ~RFC2119, March 1997
[RFC3339]
    Klyne, G. and C. Newman, "Date and Time on the Internet: Timestamps", ~RFC3339, July 2002
[RFC3629]
    Yergeau, F., "UTF-8, a transformation format of ISO 10646", STD 63, ~RFC3629, November 2003
[RFC3986]
    Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform Resource Identifier (URI): Generic Syntax", STD 66, ~RFC3986, January 2005
[RFC4287]
    Nottingham, M., Ed. and R. Sayre, Ed., "The Atom Syndication Format", ~RFC4287, December 2005
[RFC4648]
    Josefsson, S., "The Base16, Base32, and Base64 Data Encodings", ~RFC4648, October 2006
[RFC8126]
    Cotton, M., Leiba, B., and T. Narten, "Guidelines for Writing an IANA Considerations Section in RFCs", BCP 26, ~RFC8126, June 2017
[RFC8174]
    Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, ~RFC8174, May 2017
[TIME_T]
    The Open Group, "The Open Group Base Specifications", Section 4.16, 'Seconds Since the Epoch', Issue 7, 2018 Edition, IEEE Std 1003.1, 2018,
    URL: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16

●●ref_informative

[ASN.1]
    International Telecommunication Union, "Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)", ITU-T Recommendation X.690, 2015,
    URL: https://www.itu.int/rec/T-REC-X.690-201508-I/en
[BSON]
    Various, "BSON - Binary JSON",
    URL: http://bsonspec.org/
[CBOR-TAGS]
    Bormann, C., "Notable CBOR Tags", Work in Progress, Internet-Draft, draft-bormann-cbor-notable-tags-02, 25 June 2020,
    URL: https://tools.ietf.org/html/draft-bormann-cbor-notable-tags-02
[ECMA262]
    Ecma International, "ECMAScript 2020 Language Specification", Standard ECMA-262, 11th Edition, June 2020,
    URL: https://www.ecma-international.org/publications/standards/Ecma-262.htm
[Err3764]
    RFC Errata, Erratum ID 3764, RFC 7049,
    URL: https://www.rfc-editor.org/errata/eid3764
[Err3770]
    RFC Errata, Erratum ID 3770, RFC 7049,
    URL: https://www.rfc-editor.org/errata/eid3770
[Err4294]
    RFC Errata, Erratum ID 4294, RFC 7049,
    URL: https://www.rfc-editor.org/errata/eid4294
[Err4409]
    RFC Errata, Erratum ID 4409, RFC 7049,
    URL: https://www.rfc-editor.org/errata/eid4409
[Err4963]
    RFC Errata, Erratum ID 4963, RFC 7049,
    URL: https://www.rfc-editor.org/errata/eid4963
[Err4964]
    RFC Errata, Erratum ID 4964, RFC 7049,
    URL: https://www.rfc-editor.org/errata/eid4964
[Err5434]
    RFC Errata, Erratum ID 5434, RFC 7049,
    URL: https://www.rfc-editor.org/errata/eid5434
[Err5763]
    RFC Errata, Erratum ID 5763, RFC 7049,
    URL: https://www.rfc-editor.org/errata/eid5763
[Err5917]
    RFC Errata, Erratum ID 5917, RFC 7049,
    URL: https://www.rfc-editor.org/errata/eid5917
[IANA.cbor-simple-values]
    IANA, "Concise Binary Object Representation (CBOR) Simple Values",
    URL: https://www.iana.org/assignments/cbor-simple-values
[IANA.cbor-tags]
    IANA, "Concise Binary Object Representation (CBOR) Tags",
    URL: https://www.iana.org/assignments/cbor-tags
[IANA.core-parameters]
    IANA, "Constrained RESTful Environments (CoRE) Parameters",
    URL: https://www.iana.org/assignments/core-parameters
[IANA.media-types]
    IANA, "Media Types",
    URL: https://www.iana.org/assignments/media-types
[IANA.structured-suffix]
    IANA, "Structured Syntax Suffixes",
    URL: https://www.iana.org/assignments/media-type-structured-suffix
[MessagePack]
    Furuhashi, S., "MessagePack",
    URL: https://msgpack.org/
[PCRE]
    Hazel, P., "PCRE - Perl Compatible Regular Expressions",
    URL: https://www.pcre.org/
[RFC0713]
    Haverty, J., "MSDTP-Message Services Data Transmission Protocol", ~RFC713, April 1976
[RFC6838]
    Freed, N., Klensin, J., and T. Hansen, "Media Type Specifications and Registration Procedures", BCP 13, ~RFC6838, January 2013
[RFC7049]
    Bormann, C. and P. Hoffman, "Concise Binary Object Representation (CBOR)", ~RFC7049, October 2013
[RFC7228]
    Bormann, C., Ersue, M., and A. Keranen, "Terminology for Constrained-Node Networks", ~RFC7228, May 2014
[RFC7493]
    Bray, T., Ed., "The I-JSON Message Format", ~RFC7493, March 2015
[RFC7991]
    Hoffman, P., "The "xml2rfc" Version 3 Vocabulary", ~RFC7991, December 2016
[RFC8259]
    Bray, T., Ed., "The JavaScript Object Notation (JSON) Data Interchange Format", STD 90, ~RFC8259, December 2017
[RFC8610]
    Birkholz, H., Vigano, C., and C. Bormann, "Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures", ~RFC8610, June 2019
[RFC8618]
    Dickinson, J., Hague, J., Dickinson, S., Manderson, T., and J. Bond, "Compacted-DNS (C-DNS): A Format for DNS Packet Capture", ~RFC8618, September 2019
[RFC8742]
    Bormann, C., "Concise Binary Object Representation (CBOR) Sequences", ~RFC8742, February 2020
[RFC8746]
    Bormann, C., Ed., "Concise Binary Object Representation (CBOR) Tags for Typed Arrays", ~RFC8746, February 2020
[SIPHASH_LNCS]
    Aumasson, J. and D. Bernstein, "SipHash: A Fast Short-Input PRF", Progress in Cryptology - INDOCRYPT 2012, pp. 489-508, DOI 10.1007/978-3-642-34931-7_28, 2012,
    URL: https://doi.org/10.1007/978-3-642-34931-7_28
[SIPHASH_OPEN]
    Aumasson, J. and D.J. Bernstein, "SipHash: a fast short-input PRF",
    URL: https://www.aumasson.jp/siphash/siphash.pdf
[YAML]
    Ben-Kiki, O., Evans, C., and I.d. Net, "YAML Ain't Markup Language (YAML[TM]) Version 1.2", 3rd Edition, October 2009,
    URL: https://www.yaml.org/spec/1.2/spec.html


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により PROPOSED STANDARD として公表された，
RFC 8949
<a href="~SPEC_URL">Concise Binary Object Representation (CBOR)</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

Stream
	Internet Engineering Task Force (IETF)
RFC
	<a href="https://www.rfc-editor.org/rfc/rfc8949">8949</a>
STD
	94
廃用
	<a href="https://www.rfc-editor.org/rfc/rfc7049">7049</a>
分類
	Standards Track
公表
	2020年 12月
ISSN
	2070-1721
著作者
	<a href="mailto:cabo@tzi.org">Carsten Bormann</a>, Universität Bremen TZI
	<a href="mailto:paul.hoffman@icann.org">Paul Hoffman</a>, ICANN
現在の位置付け, 正誤表, フィードバックの方法
	https://www.rfc-editor.org/info/rfc8949

</script>

</head>

<body>

<header>
	<hgroup>
<h1>CBOR</h1>
<p>RFC 8949 — Concise Binary Object Representation (CBOR)</p>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section>
~ABSTRACT

<p>
~CBOR（ `Concise Binary Object Representation^en ）
【 “簡潔な， 2 進~dataによる，~obj表現” 】
は、
その設計~目標として［
極めて小さな~code~size,
相応に小さな~message~size
］の可能性, および［
~version折衝の必要を伴わない拡張能
］を含む~data形式である。
~CBORは、
これまでの~binary直列化
— ~ASN1, ~MessagePackなど —
とは，これらの設計~目標において異なる。
◎
The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.
</p>

<p>
この文書は、
~RFC 7049 を廃用にする。
この文書は、［
編集上の改善, 新たな詳細, 正誤表の修正点
］を供する一方で，
~RFC 7049 による交換~形式との全部的な互換性を保つ。
この文書は、
~CBOR形式の新たな~versionを作成するものではない。
◎
This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format.
</p>

	</section>
	<section id="status-of-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status$に移譲。
】</p>

	</section>
	<section id="copyright">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">
	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
有構造~dataの~binary表現~用に標準~化された形式
（~binary直列化~形式としても知られる）
は、
何百もある。
うち一部のものは，特定の分野の情報~用にある一方で、
任意な~data用に一般~化されたものもある。
~IETFにおいて，後者に分類される最も知られた形式は、
おそらく `ASN.1$r の［
~BER, ~DER
］であろう。
◎
There are hundreds of standardized formats for binary representation of structured data (also known as binary serialization formats). Of those, some are for specific domains of information, while others are generalized for arbitrary data. In the IETF, probably the best-known formats in the latter category are ASN.1's BER and DER [ASN.1].
</p>

<p>
ここに定義される形式は、
現在の形式がきちんと満たさない，ある, 特定の設計~目標に従う。
下層の~data~modelは、
~JSON~data~model `RFC8259$r を拡張した~versionである。
重要な注意として、
これは，~JSON~data~modelの文法を一般に拡張するための提案ではない
— そうすることは、
すでに配備-済みな~JSON文書との有意な後方-非互換性の原因になるので。
代わりに，この文書は、
自前の~data~modelを単純に~JSONから開始するよう定義する。
◎
The format defined here follows some specific design goals that are not well met by current formats. The underlying data model is an extended version of the JSON data model [RFC8259]. It is important to note that this is not a proposal that the grammar in RFC 8259 be extended in general, since doing so would cause a significant backwards incompatibility with already deployed JSON documents. Instead, this document simply defines its own data model that starts from JSON.
</p>

<p>
`E§ にて、
一部の既存の~binary形式を挙げる
— それらが~CBORの設計~目標群に，どうきちんと収まるか否かについて論じる。
◎
Appendix E lists some existing binary formats and discusses how well they do or do not fit the design objectives of the Concise Binary Object Representation (CBOR).
</p>

<p>
この文書は、
`RFC7049$r を廃用にする
⇒
この文書は、［
編集上の改善, 新たな詳細, 正誤表の修正点
］を供する一方で，
~RFC 7049 による交換~形式との全部的な互換性を保つ。
この文書は、
~CBOR形式の新たな~versionを作成するものではない。
◎
This document obsoletes [RFC7049], providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format.
</p>

		<section id="objectives">
<h3 title="Objectives">1.1. 目標群</h3>

<p>
~CBORの目標群は、
概ね重要度の高いものから順に：
◎
The objectives of CBOR, roughly in decreasing order of importance, are:
</p>
<ol>
	<li>
<p>
表現は、
各種~Internet標準にて利用される ほとんどの共通な~data形式を，
一義的に符号化-可能でなければならない：
◎
The representation must be able to unambiguously encode most common data formats used in Internet standards.
</p>
		<ul>
			<li>
それは、
~binary符号化法を利用して，一群の基本的な［
~data型, 構造
］として適度なものを表現しなければならない。
ここでの “適度” とは，~JSONの能力に大きく波及されることをいうが、
主要な追加として~binary`~byte~string$を伴う。
~supportする構造は、［
`~array$, ~tree
］に制限され，［
`loop^en, `lattice-style graph^en
【言い換えれば、一般な~graph構造】
］は~supportしない。
◎
It must represent a reasonable set of basic data types and structures using binary encoding. "Reasonable" here is largely influenced by the capabilities of JSON, with the major addition of binary byte strings. The structures supported are limited to arrays and trees; loops and lattice-style graphs are not supported.
</li>
			<li>
すべての~data形式を一意に符号化する要件は無い
— すなわち、［
“7” などの~numberが複数の異なる仕方で符号化され得る
］ことも受容-可能である。
◎
There is no requirement that all data formats be uniquely encoded; that is, it is acceptable that the number "7" might be encoded in multiple different ways.
</li>
		</ul>
	</li>
	<li>
<p>
［
~memory, 処理能力, 命令~集合
］が ごく制限された~systemを~supportするため、［
符号化器／復号器
］用の~codeは，~compact†になることが可能でなければならない。
◎
The code for an encoder or decoder must be able to be compact in order to support systems with very limited memory, processor power, and instruction sets.
</p>
		<ul>
			<li>
［
符号化器, 復号器
］は、
ごく小さな~code量で実装-可能になる必要がある
（例えば、
`RFC7228$r にて定義される `class 1^en に拘束された~node）。
◎
An encoder and a decoder need to be implementable in a very small amount of code (for example, in class 1 constrained nodes as defined in [RFC7228]).
</li>
	<li>
~CBOR形式は、
現今の［
~dataの計算機-表現
］を利用するべきである
（例えば、
~binaryから~decimalへの変換は要求しない）。
◎
The format should use contemporary machine representations of data (for example, not requiring binary-to-decimal conversion).
</li>
		</ul>

<p class="trans-note">【†
`compact^en
— “密” ／ “ぎゅうぎゅう詰め” 。
~CBOR の `Concise^en （ “簡潔” ）と混同しないように。
】</p>
	</li>
	<li>
~dataは、
~schema記述を伴うことなく，復号-可能でなければならない
⇒
~JSONと類似に、
符号化された~dataは，［
汎用な復号器を書けるよう，自己を記述している
］べきである。
◎
Data must be able to be decoded without a schema description.
• Similar to JSON, encoded data should be self-describing so that a generic decoder can be written.
</li>
	<li>
直列化は、
適度に~compactにならなければならないが、
~dataの~compactさより，［
符号化器, 復号器
］用の~codeの~compactさが優先される。
ここでの “適度” とは、
~JSONにより~sizeにおける上限として束縛され，
実装の複階性により束縛されることをいう
— それは、
~compactさを達成するためにかける労を制限するものになり得る。
一般的な圧縮~schemeを利用したり，~bit列を弄り回すことは、
複階性を抑える目標に違反する。
◎
The serialization must be reasonably compact, but data compactness is secondary to code compactness for the encoder and decoder.
◎
"Reasonable" here is bounded by JSON as an upper bound in size and by the implementation complexity, which limits the amount of effort that can go into achieving that compactness. Using either general compression schemes or extensive bit-fiddling violates the complexity goals.
</li>
	<li>
~CBOR形式は、［
拘束された~node,
大容量な応用
］どちらにも適用-可能でなければならない。
このことは、［
符号化, 復号
］どちらにおいても［
~CPU利用度において適度に安上がりでなければならない
］ことを意味する。
これは、［
拘束された~node
］にも［
応用における大容量な~dataを伴う可能性もある用法
］にも関連する。
◎
The format must be applicable to both constrained nodes and high-volume applications.
◎
This means it must be reasonably frugal in CPU usage for both encoding and decoding. This is relevant both for constrained nodes and for potential usage in applications with a very high volume of data.
</li>
	<li>
<p>
~CBOR形式は、
~JSONとの相互~変換~用に，すべての~JSON~data型を~supportしなければならない
— それは：
◎
The format must support all JSON data types for conversion to and from JSON.
</p>
		<ul>
			<li>
~JSONの能力の中で表現される~dataに関する限り，
適度な~levelの変換を~supportしなければならない。
◎
It must support a reasonable level of conversion as long as the data represented is within the capabilities of JSON.＼
</li>
			<li>
すべての型の~dataに対し，［
~JSONへの単方向な対応付けを定義する
］ことがアリでなければならない。
◎
It must be possible to define a unidirectional mapping towards JSON for all types of data.
</li>
		</ul>
	</li>
	<li>
<p>
~CBOR形式は、
拡張-可能かつ［
拡張された~dataは、
これまでの復号器により復号-可能
］でなければならない。
~CBOR形式は：
◎
The format must be extensible, and the extended data must be decodable by earlier decoders.
</p>
		<ul>
			<li>
数十年の利用-用に設計される。
◎
The format is designed for decades of use.
</li>
			<li>
ある形を成す拡張能
— 拡張を解さない復号器でも~messageを復号できるよう，~fallbackを許容する拡張能 —
を~supportしなければならない。
◎
The format must support a form of extensibility that allows fallback so that a decoder that does not understand an extension can still decode the message.
</li>
			<li>
後の~IETF標準により，将来に拡張-可能でなければならない。
◎
The format must be able to be extended in the future by later IETF standards.
</li>
		</ul>
	</li>
</ol>

		</section>
		<section id="terminology">
<h3 title="Terminology">1.2. 各種用語</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

<p>
“~octet” の同義語として，今や~~慣例になった用語 “~byte” が利用される。
すべての複-~byte値は、
~network~byte順序（ “`big-endian^en” としても知られる）で符号化される
（すなわち，最も有意な~byteが最初）。
◎
The term "byte" is used in its now-customary sense as a synonym for "octet". All multi-byte values are encoded in network byte order (that is, most significant byte first, also known as "big-endian").
</p>

<p>
この仕様は、
次に挙げる各種用語を用立てる：
◎
This specification makes use of the following terminology:
</p>
<dl>
	<dt>
`~data~item@
（ `data item^en, 略して~item）
◎
Data item:
</dt>
	<dd>
~CBOR~dataを成す 1 個として数えられるモノ。
~data~itemの構造は、［
入子にされた 0 個以上の~data~item
］を包含することもある。
この用語は、［
表現~形式における~data~item,
復号器により~data~itemから導出し得る抽象-~levelの~data
］どちらにも利用される
— 前者を特定的に指すときは、
用語
`符号化された~data~item@
も利用される。
◎
A single piece of CBOR data. The structure of a data item may contain zero, one, or more nested data items. The term is used both for the data item in representation format and for the abstract idea that can be derived from that by a decoder; the former can be addressed specifically by using the term "encoded data item".
</dd>

	<dt>
`復号器@
（ `decoder^en ）
◎
Decoder:
</dt>
	<dd>
`整形式$な`符号化された~data~item$を復号して，結果を応用に可用にする処理n【を行うもの】。
正式には、［
~CBORの構文~規則を利用して入力を【一群の “~token” に】分断しておく，構文解析器
］および［
当の~dataを応用に相応しい形に準備する，意味論上の処理器
］を包含する復号器。
◎
A process that decodes a well-formed encoded CBOR data item and makes it available to an application. Formally speaking, a decoder contains a parser to break up the input using the syntax rules of CBOR, as well as a semantic processor to prepare the data in a form suitable to the application.
</dd>

	<dt>
`符号化器@
（ `encoder^en ）
◎
Encoder:
</dt>
	<dd>
応用~情報から［
（`整形式$な）表現~形式を成す`~data~item$
］を生成する処理n【を行うもの】。
◎
A process that generates the (well-formed) representation format of a CBOR data item from application information.
</dd>

	<dt>
`~data~stream@
（ `data stream^en ）
◎
Data Stream:
</dt>
	<dd>
0 個以上の［
他の~data~itemの中に入子にされない（ “~top-levelの” ）~data~item
］からなる連列
（応用~例は `RFC8742$r を見よ）。
◎
A sequence of zero or more data items, not further assembled into a larger containing data item (see [RFC8742] for one application). The independent data items that make up a data stream are sometimes also referred to as "top-level data items".
</dd>

	<dt>
`整形式@
（ `well-formed^en, “きちんと形成された” ）：
◎
Well-formed:
</dt>
	<dd>
~CBORの構文-構造に従う~data~item
【したがって、 “整形式” という語は，当の~data~itemは`符号化された~data~item$であることを含意する】
。
整形式な~data~itemは、
`~head$, および［
~CBORにて定義されるとおり，その値により含意される［
`~byte~string$群／~data~item群
］］を利用し，後続している余計な~dataは含まない。
◎
A data item that follows the syntactic structure of CBOR. A well-formed data item uses the initial bytes and the byte strings and/or data items that are implied by their values as defined in CBOR and does not include following extraneous data.＼
</dd>
	<dd>
~CBOR復号器が返すものは、
定義により，`整形式$な~data~itemから得られた内容に限られる。
◎
CBOR decoders by definition only return contents from well-formed data items.
</dd>

	<dt>
`妥当@
（ `valid^en ）
◎
Valid:
</dt>
	<dd>
`整形式$な~data~itemのうち，
`~data~item$に適用される意味論上の制約にも従うもの
（ `5.3§ ）。
◎
A data item that is well-formed and also follows the semantic restrictions that apply to CBOR data items (Section 5.3).
</dd>

	<dt>
`期待され@
る
（ `expected^en ）
◎
Expected:
</dt>
	<dd>
用語 “期待される” は、
英語における その通常の意味は別として，［
応用が自身への入力~dataに対し課す要件
］のうち［
~CBOR妥当性を超えるもの
］を述べるために利用される。
◎
Besides its normal English meaning, the term "expected" is used to describe requirements beyond CBOR validity that an application has on its input data.＼
</dd>
	<dd>
［
`整形式$（処理-可能）,
`妥当$（妥当性を検査する汎用な復号器により検査-済み）,
`期待され$る（当の応用により検査-済み）
］は、
これらの受容-能が成す層が成す階層を形成する。
【言い換えれば、`期待され$るもの ならば必然的に`妥当$であり，`妥当$ならば必然的に`整形式$である。】
◎
Well-formed (processable at all), valid (checked by a validity-checking generic decoder), and expected (checked by the application) form a hierarchy of layers of acceptability.
</dd>

	<dt>
`~stream復号器@
（ `stream decoder^en ）
◎
Stream decoder:
</dt>
	<dd>
ある`~data~stream$を復号して、
当の連列を成す各~data~itemを受信するに伴い，それを応用に可用にする処理n【を行うもの】。
【この用語は、この仕様では利用されていない。】
◎
A process that decodes a data stream and makes each of the data items in the sequence available to an application as they are received.
</dd>
</dl>

<p>
`~float$用の用語と概念
— ~Infinity,
~NaN（ `not a number^en ）,
負な 0,
~subnormal†など —
は、
`IEEE754$r にて定義される。
◎
Terms and concepts for floating-point values such as Infinity, NaN (not a number), negative zero, and subnormal are defined in [IEEE754].
</p>

<p class="trans-note">【†
仮数が 1 以上になるよう正規化し得ないほど 0 に近い~number
（`参考＠https://en.wikipedia.org/wiki/Subnormal_number$）
】</p>

<p>
この文書は、［
~bit算術／~data型
］を説明する所では，
~programming言語 C `C$r に馴染みな記法を利用することに加え、
次に挙げる表記も利用する：
◎
Where bit arithmetic or data types are explained, this document uses the notation familiar from the programming language C [C], except that＼
</p>
<ul>
	<li>
{ %A 〜 %B } は、
%A 以上 %B 以下の範囲を表記する。
【原文では、 %A..%B と表記される。】
◎
".." denotes a range that includes both ends given,＼
</li>
	<li>
~POW( %A, %B ) は、
指数~化を表記する
— 例： ~POW( 2, 64 ) は、
2 の 64 乗を表す。
【原文では、上付文字により %A<sup>%B</sup> と表記される。】
◎
and superscript notation denotes exponentiation. For example, 2 to the power of 64 is notated: 264.＼
</li>
</ul>

<p>
この仕様の素な~text~versionでは…
【以下，省略する（この訳には不要な表記規約なので）】。
◎
In the plain-text version of this specification, superscript notation is not available and therefore is rendered by a surrogate notation. That notation is not optimized for this RFC; it is unfortunately ambiguous with C's exclusive-or (which is only used in the appendices, which in turn do not use exponentiation) and requires circumspection from the reader of the plain-text version.
</p>

<p>
各~例と疑似-~codeは、［
有符号な~integerには， 2 の補数による表現を利用する／
有符号な~integerの右~shiftは，正負符号~拡張を遂行する
【すなわち、負な場合は，最上位~bitに 1 を補充する】
］と見做す
— これらの前提は、
C++ の 2020年~version
（現時点では最終-草案 `Cplusplus20$r として可用）の［
§ 6.8.1 `basic.fundamental^en,
§ 7.6.7 `expr.shift^en
］にも指定される。
◎
Examples and pseudocode assume that signed integers use two's complement representation and that right shifts of signed integers perform sign extension; these assumptions are also specified in Sections 6.8.1 (basic.fundamental) and 7.6.7 (expr.shift) of the 2020 version of C++ (currently available as a final draft, [Cplusplus20]).
</p>

<p>
~hexadecimal~number用の "0x" 記法と類似に、
~binary記法による~numberには "0b" が接頭される。
そのような~numberには、
もっぱら可読性を得るためとして，~underscoreが追加され得る。
なので，
`00100001^B ( `21^X ）は、［
当の~byteを成す~bit群に欲される解釈を強勢する
］よう， `001_00001^B と書かれることもある
— この事例では、
3 個の~bitと 5 個の~bitに分割される。
符号化された各`~data~item$は、［
"0x" ／ "0b"
］記法で与えられることもある
— これらの値は、
まず，~C言語と同じく~numberとして解釈してから，
~network~byte順序による`~byte~string$として
— 当の記法~内に表出された頭部を成す 0 ~byte列を含めて —
解釈される。
◎
Similar to the "0x" notation for hexadecimal numbers, numbers in binary notation are prefixed with "0b". Underscores can be added to a number solely for readability, so 0b00100001 (0x21) might be written 0b001_00001 to emphasize the desired interpretation of the bits in the byte; in this case, it is split into three bits and five bits. Encoded CBOR data items are sometimes given in the "0x" or "0b" notation; these values are first interpreted as numbers as in C and are then interpreted as byte strings in network byte order, including any leading zero bytes expressed in the notation.
</p>

<p>
この仕様の素な~text~versionでは，単語を強勢する所では…
【以下，省略する（この訳には不要な表記規約なので）。】
◎
Words may be italicized for emphasis; in the plain text form of this specification, this is indicated by surrounding words with underscore characters. Verbatim text (e.g., names from a programming language) may be set in monospace type; in plain text, this is approximated somewhat ambiguously by surrounding the text in double quotes (which also retain their usual meaning).
</p>

		</section>
	</section>
	<section id="cbor-data-models">
<h2 title="CBOR Data Models">2. ~CBOR~data~model</h2>

<p>
~CBORは、
その
`汎用~data~model@
について明示的である
— それは、すべての［
~CBOR内で表現し得る~data~item
］からなる集合を定義する。
その基本的な汎用~data~modelは、
各種［
“単純~値”, `~tag$
］の登録により拡張-可能である。
各~応用は、［
その結果の`拡張された汎用~data~model$
］の下位集合を作成して，自身に特有な~data~modelを築ける。
◎
CBOR is explicit about its generic data model, which defines the set of all data items that can be represented in CBOR. Its basic generic data model is extensible by the registration of "simple values" and tags. Applications can then create a subset of the resulting extended generic data model to build their specific data models.
</p>

<p>
［
各種~data~itemを`汎用~data~model$内で表現できる環境
］の中では、
汎用な~CBOR［
符号化器, 復号器
］を実装できる
（そうすることは、
通例的に，［
当の環境が，ある型の~data~itemの自然な表現を備えていない
］ときは［
それ用に，実装~用の~data型を追加的に定義する
］ことを孕む）。
汎用な［
符号化器, 復号器
］を供する能は、
~CBORの明示的な設計~目標である
— しかしながら、
多くの応用は，自身に特有な自前の［
符号化器／復号器
］を供することになる。
◎
Within environments that can represent the data items in the generic data model, generic CBOR encoders and decoders can be implemented (which usually involves defining additional implementation data types for those data items that do not already have a natural representation in the environment). The ability to provide generic encoders and decoders is an explicit design goal of CBOR; however, many applications will provide their own application-specific encoders and/or decoders.
</p>

<p>
`3§ にて定義される基本的な（未拡張な）`汎用~data~model$においては、
~data~itemは，次に挙げるいずれかになる：
◎
In the basic (unextended) generic data model defined in Section 3, a data item is one of the following:
</p>
<dl>
	<dt>
`~integer@
◎
an integer＼
</dt>
	<dd>
`汎用~data~model$においては、
範囲 { −~POW( 2, 64 ) 〜 ( ~POW( 2, 64 ) ~MINUS 1 ) } に入るものに限られる。
◎
in the range -264..264-1 inclusive
</dd>

	<dt>
`単純~値$
◎
a simple value,＼
</dt>
	<dd>
~number ~IN { 0 〜 255 } により識別されるが、
それは，その~number自身とは別物である
◎
identified by a number between 0 and 255, but distinct from that number itself
</dd>

	<dt>
`~float$
◎
a floating-point value,＼
</dt>
	<dd>
`~integer$とは別物であり、
`IEEE754$r `倍-精度~float$（非-有限な値も含む）により表現-可能な集合を成す
◎
distinct from an integer, out of the set representable by IEEE 754 binary64 (including non-finites) [IEEE754]
</dd>

	<dt>
`~byte~string@
◎
↓</dt>
	<dd>
0 個以上の~byteからなる連列
◎
a sequence of zero or more bytes ("byte string")
</dd>

	<dt>
<p>
`~text~string@
◎
↓</dt>
	<dd>
0 個以上の~Unicode符号位置からなる連列
◎
a sequence of zero or more Unicode code points ("text string")
</dd>
	<dd class="trans-note">【
~data~itemに対し利用される用語
`~UTF-8~string@
は、［
`符号化された~data~item$としての`~text~string$
］を意味する。
】</dd>

	<dt>
`~array@
◎
↓</dt>
	<dd>
0 個以上の~data~itemからなる連列
◎
a sequence of zero or more data items ("array")
</dd>

	<dt>
`~map@
◎
↓</dt>
	<dd>
ある~data~item群を成す各~data~item（`~key$）から
別の~data~item群を成す各~data~item（`値$）への対応付け【！(mathematical function)】
◎
a mapping (mathematical function) from zero or more data items ("keys") each to a data item ("values"), ("map")
</dd>

	<dt>
`~tag$
◎
a tagged data item ("tag"),＼
</dt>
	<dd>
次の 2 つからなる
⇒＃
`~tag番号$（~integer ~IN 範囲 { 0 〜 ( ~POW( 2, 64 ) ~MINUS 1 ) } ）,
`~tag内容$（ 1 個の~data~item）
◎
comprising a tag number (an integer in the range 0..264-1) and the tag content (a data item)
</dd>
</dl>

<p>
この~modelにおいては、［
`~integer$値と`~float$値
］は［
数量-値としては同じであっても，別物である
］ことに注意。
◎
Note that integer and floating-point values are distinct in this model, even if they have the same numeric value.
</p>

<p>
直列化の各~変種のうち どれが利用されたかは、
`汎用~data~model$の~levelでは可視にならないことにも注意。
このことは、
故意であり，［
符号化された`~float$値の~byte数
］および［
次に挙げるものなど，`引数$用に選ぶ符号化法
］を含む【！（ `3§ を見よ）】
⇒＃
`~integer$／
`~text~string$の長さ／
`~byte~string$の長さ／
`~array$を成す要素の個数／
`~map$を成す`~entry$の個数／
`~tag番号$
◎
Also note that serialization variants are not visible at the generic data model level. This deliberate absence of visibility includes the number of bytes of the encoded floating-point value. It also includes the choice of encoding for an "argument" (see Section 3) such as the encoding for an integer, the encoding for the length of a text or byte string, the encoding for the number of elements in an array or pairs in a map, or the encoding for a tag number.
</p>

		<section id="extended-generic-data-models">
<h3 title="Extended Generic Data Models">2.1. 拡張された汎用~data~model</h3>

<p>
この基本的な`汎用~data~model$は、
この文書において，いくつかの［
`単純~値$, `~tag番号$
］の登録により拡張される
— 次に挙げるものなど：
◎
This basic generic data model has been extended in this document by the registration of a number of simple values and tag numbers, such as:
</p>
<ul>
	<li>
`false$i,
`true$i,
`null$i,
`undefined$i
（挙げられた順に，【`引数$】［
20, 21, 22, 23
］により識別される`単純~値$【！`3.3§】）
◎
false, true, null, and undefined (simple values identified by 20..23, Section 3.3)
</li>
	<li>
より大きい［
範囲, 精度
］を伴う［
`~integer$値, `~float$値
］（`~tag番号$ ~IN { `2$tag 〜 `5$tag } ）
◎
integer and floating-point values with a larger range and precision than the above (tag numbers 2 to 5, Section 3.4)
</li>
	<li>
応用~data型
— ~RFC 3339 にて定義される日時~stringなど
（`~tag番号$ ~IN { `1$tag, `0$tag } ）
◎
application data types such as a point in time or date/time string defined in RFC 3339 (tag numbers 1 and 0, Section 3.4)
</li>
</ul>

<p>
`拡張された汎用~data~model$を成す追加的な要素は、
~CBOR用に作成された~IANA~registryを介して，定義できる
（または，定義-済みである）。
ある汎用な［
符号化器／復号器
］において，そのような拡張が未知であっても、
その拡張を利用している~data~itemは，［
基本的な`汎用~data~model$の中で
— すなわち，汎用な［
`単純~値$／`~tag$
］（順不同）として —
当の応用~interfaceで表現する
］ことにより，当の応用［
から／へ
］渡せる。
◎
Additional elements of the extended generic data model can be (and have been) defined via the IANA registries created for CBOR. Even if such an extension is unknown to a generic encoder or decoder, data items using that extension can be passed to or from the application by representing them at the application interface within the basic generic data model, i.e., as generic simple values or generic tags.
</p>

<p>
言い換えれば、
基本的な`汎用~data~model$は，
この文書にて定義されるとおり安定的である一方で、
`拡張された汎用~data~model$は，新たな［
`単純~値$／`~tag番号$
］の登録により拡げられるが，狭められることは決してない。
◎
In other words, the basic generic data model is stable as defined in this document, while the extended generic data model expands by the registration of new simple values or tag numbers, but never shrinks.
</p>

<p>
汎用な［
符号化器／復号器
］は，［
`false$i, `true$i, `null$i
］（ `undefined$i は意図的に~~除外される【！omitted】）を［
各自の~programming環境に適切な形
］で表現できることが強く期待されるが、［
各種`~tag$により作成される~data~model拡張
］の実装は，真に任意選択~であり, 実装~品質に関する事である。
◎
While there is a strong expectation that generic encoders and decoders can represent false, true, and null (undefined is intentionally omitted) in the form appropriate for their programming environment, the implementation of the data model extensions created by tags is truly optional and a matter of implementation quality.
</p>

		</section>
		<section id="specific-data-models">
<h3 title="Specific Data Models">2.2. ~protocolに特有な~data~model</h3>

<p>
ある~CBORに基づく~protocol用に特有な~data~modelは、
通例的に［
`拡張された汎用~data~model$を成す，ある下位集合
］を採って，［
この下位集合, それを成す各~成分
］の中の~data~itemに応用の意味論をアテガう。
そのような［
応用に特有な~data~modelを文書化するとき／
各種~data~itemの型を指定するとき
］は、
当の型は［
`汎用~data~model$における，その名前
］（例： “負な~integer” ／ “~array” ）
により識別する方が好ましい
— その~CBOR表現の側面（例： “`~major型$ `1$mj” ／ “~major型 `4$mj” ）で参照rする代わりに。
◎
The specific data model for a CBOR-based protocol usually takes a subset of the extended generic data model and assigns application semantics to the data items within this subset and its components. When documenting such specific data models and specifying the types of data items, it is preferable to identify the types by their generic data model names ("negative integer", "array") instead of referring to aspects of their CBOR representation ("major type 1", "major type 4").
</p>

<p>
特有な~data~modelは、［
`~map~key$と符号化器
］に自由度を与える目的で，
値の等価性を（型が異なる値どうしも含めて）指定することもできる。
例えば，`汎用~data~model$においては、
`妥当$な`~map$は，`~key$として［
0, 0.0
］どちらを有してもヨイ【異なるものとして扱われる】ので，
符号化器は 0.0 を`~integer$（`~major型$ `0$mj 【！`3.1§】）として符号化してはナラナイ。
しかしながら，特有な~data~modelが［
~integerとして等しい［
`~float$, `~integer$
］表現は等価である
］ものと宣言する場合、
同じ`~map$内で［
0, 0.0
］両者を`~map~key$に利用することは
— 異なる`~major型$として符号化されようが —
重複と見なされ，`妥当$でなくなることに加え、
符号化器は，［
ある~integerに等しい値をとる`~float$を
— たぶん，符号化される~byte数を節約するために —
`~integer$として符号化する
］ことも［
その逆を行う
］こともできる。
◎
Specific data models can also specify value equivalency (including values of different types) for the purposes of map keys and encoder freedom. For example, in the generic data model, a valid map MAY have both 0 and 0.0 as keys, and an encoder MUST NOT encode 0.0 as an integer (major type 0, Section 3.1). However, if a specific data model declares that floating-point and integer representations of integral values are equivalent, using both map keys 0 and 0.0 in a single map would be considered duplicates, even while encoded as different major types, and so invalid; and an encoder could encode integral-valued floats as integers or vice versa, perhaps to save encoded bytes.
</p>

		</section>
	</section>
	<section id="encoding">
<h2 title="Specification of the CBOR Encoding">3. ~CBOR符号化法の仕様</h2>

<p>
`~data~item$（ `2§ ）は、
この節にて述べられるとおりに，ある［
`整形式$な`~data~item$
］を運んでいる`~byte~string$［
へ符号化される／から復号される
］。
符号化法は、
`B§ `表0 7＠#jumptable$ にて
— `先頭~byte$により~indexされて —
要約される。
符号化器は、［
`符号化された~data~item$として`整形式$でないもの
］を生産してはナラナイ。
復号器は、［
`符号化された~data~item$として`整形式$でない入力
］に遭遇したときには，それを復号した~data~itemを返してはナラナイ
（これは、［
診断と回復を行う~tool
］による有用さ
— 損傷した［
`符号化された~data~item$
］から，一部の情報を可用にするかもしれない有用さ —
を損なうものではない）。
◎
A CBOR data item (Section 2) is encoded to or decoded from a byte string carrying a well-formed encoded data item as described in this section. The encoding is summarized in Table 7 in Appendix B, indexed by the initial byte. An encoder MUST produce only well-formed encoded data items. A decoder MUST NOT return a decoded data item when it encounters input that is not a well-formed encoded CBOR data item (this does not detract from the usefulness of diagnostic and recovery tools that might make available some information from a damaged encoded CBOR data item).
</p>

<p>
各［
`符号化された~data~item$
］を成す最初の~byteは、
`先頭~byte@
（ `initial byte^en ）
と称され，次についての情報を包含する：
◎
The initial byte of each encoded data item contains both information about＼
</p>
<ul>
	<li>
上位 3 ~bitが成す値（ 0 〜 7 ）は、
`~major型@
（ `major type^en ）
を与える（`3.1§ にて述べられる）
◎
the major type (the high-order 3 bits, described in Section 3.1) and＼
</li>
	<li>
下位 5 ~bitが成す値（ 0 〜 31 ）は、
`追加l情報@
（ `additional information^en ）
を与える
◎
additional information (the low-order 5 bits).＼
</li>
</ul>

<p>
`追加l情報$の値は、
当の`符号化された~data~item$の
`引数@
を読込む方法を述べる
— `引数$は（在るならば）、
少数の例外を除き，無符号`~integer$をとる：
◎
With a few exceptions, the additional information's value describes how to load an unsigned integer "argument":
</p>
<dl class="switch">
	<dt>
`24^ai 未満：
◎
Less than 24:
</dt>
	<dd>
`引数$の値は、
`追加l情報$の値に等しい。
◎
The argument's value is the value of the additional information.
</dd>

	<dt>
`24^ai ／ `25^ai ／ `26^ai ／ `27^ai：
◎
24, 25, 26, or 27:
</dt>
	<dd>
`引数$の値は、
後続している［
1 個／ 2 個／ 4 個／ 8 個
］（同順）の~byte内に~network~byte順序で保持される。
◎
The argument's value is held in the following 1, 2, 4, or 8 bytes, respectively, in network byte order.＼
</dd>
	<dd>
［
`~major型$ ~EQ `7$mj
］かつ［
`追加l情報$ ~IN { `25^ai, `26^ai, `27^ai }
］の場合、
`引数$は，`~integer$ではなく`~float$値として利用される（ `3.3§ ）。
◎
For major type 7 and additional information value 25, 26, 27, these bytes are not used as an integer argument, but as a floating-point value (see Section 3.3).
</dd>

	<dt>
`28^ai ／ `29^ai ／ `30^ai：
◎
28, 29, 30:
</dt>
	<dd>
これらの値は、
~CBOR形式に対する将来の追加~用に予約される。
~CBORの現~versionにおいては、
当の~itemは`整形式$でない。
◎
These values are reserved for future additions to the CBOR format. In the present version of CBOR, the encoded item is not well-formed.
</dd>

	<dt>
`31^ai：
◎
31:
</dt>
	<dd>
<p>
導出される`引数$~値は無い
— `~major型$に応じて：
</p>
		<ul class="switch">
			<li>
`0$mj ／ `1$mj ／ `6$mj
⇒
当の~itemは`整形式$でない
</li>
			<li>
`2$mj ／ `3$mj ／ `4$mj ／ `5$mj
⇒
当の~itemは`不定長$である
</li>
			<li>
`7$mj
⇒
当の`先頭~byte$は、
~data~itemを成すものではなく，
`不定長$な~itemを終了するもの【 `~break$ 】である。
</li>
		</ul>
<p>
これらは すべて `3.2§ にて述べられる。
</p>
◎
No argument value is derived. If the major type is 0, 1, or 6, the encoded item is not well-formed. For major types 2 to 5, the item's length is indefinite, and for major type 7, the byte does not constitute a data item at all but terminates an indefinite-length item; all are described in Section 3.2.
</dd>
</dl>

<p>
`引数$を構築するために消費される［
`先頭~byte$, 追加的な~byte列（もしあれば）
］は、
当の~data~itemの
`~head@
と総称される。
◎
The initial byte and any additional bytes consumed to construct the argument are collectively referred to as the head of the data item.
</p>

<p>
`引数$の意味は、
`~major型$に依存する。
例えば、
`~major型$に応じて：
◎
The meaning of this argument depends on the major type. For example,＼
</p>
<ul>
	<li>
`0$mj ならば、
`引数$は，そのまま~data~itemの値を与える。
◎
in major type 0, the argument is the value of the data item itself＼
</li>
	<li>
`1$mj ならば、
~data~itemの値は`引数$から算出される。
◎
(and in major type 1, the value of the data item is computed from the argument);＼
</li>
	<li>
`2$mj ／ `3$mj ならば、
`引数$は，後続する~string~dataの長さを~byte数で与える。
◎
in major type 2 and 3, it gives the length of the string data in bytes that follow;＼
</li>
	<li>
`4$mj ／ `5$mj ならば、
`引数$は，封入された~data~itemの個数を決定するために利用される。
【特定的には、`~array$を成す要素の個数／`~map$を成す`~entry$の個数を与える。】
◎
and in major types 4 and 5, it is used to determine the number of data items enclosed.
</li>
</ul>

<p>
符号化された~byte列が，ある`~data~item$の途中で終端する場合、
その~itemは`整形式$でない。
符号化された~byte列は、［
最も外縁な符号化された~itemが復号された後にも，まだ~byte列が残されている
］場合， 1 個の`整形式$な`~data~item$を成していない
— 当の復号器は、当の応用に依存して，［
当の符号化を整形式でないものとして扱う
］ことも［
当の応用に対する残りの~byte列の開始を識別するだけの
【すなわち，`~streamして$いる】
］こともある。
◎
If the encoded sequence of bytes ends before the end of a data item, that item is not well-formed. If the encoded sequence of bytes still has bytes remaining after the outermost encoded item is decoded, that encoding is not a single well-formed CBOR item. Depending on the application, the decoder may either treat the encoding as not well-formed or just identify the start of the remaining bytes to the application.
</p>

<p>
~CBOR復号器の実装は、［
`先頭~byte$用に定義される 256 通りの値~すべてに対応する分岐表
］（ `表0 7＠#jumptable$ ）に基づくものになり得る。
拘束された実装における復号器は、
代わりに，
より~compactな~code用に`~head$【！initial byte and following bytes】の構造を利用できる（これが，およそどんな~~形をとるかは、 `C§ を見よ）。
◎
A CBOR decoder implementation can be based on a jump table with all 256 defined values for the initial byte (Table 7). A decoder in a constrained implementation can instead use the structure of the initial byte and following bytes for more compact code (see Appendix C for a rough impression of how this could look).
</p>

		<section id="majortypes">
<h3 title="Major Types">3.1. 各種~major型</h3>

<p>
各種［
`~major型$, `追加l情報$
］および［
当の型に結付けられる他の~byte列
］を以下に挙げる：
◎
The following lists the major types and the additional information and other bytes associated with the type.
</p>
<dl>
	<dt>
`~major型$
`0@mj
◎
Major type 0:
</dt>
	<dd>
無符号`~integer$ ~IN 範囲 { 0 〜 ( ~POW( 2, 64 ) ~MINUS 1 ) } 。
◎
An unsigned integer in the range 0..264-1 inclusive.＼
</dd>
	<dd>
<p>
当の符号化された~itemの値は、`引数$自身になる。
例えば：
◎
The value of the encoded item is the argument itself. For example,＼
</p>
		<ul>
			<li>
`~integer$ 10 は、
1 個の~byte `000_01010^B
（`~major型$ `0$mj, `追加l情報$ `10^ai ）
として表記される。
◎
the integer 10 is denoted as the one byte 0b000_01010 (major type 0, additional information 10).＼
</li>
			<li>
`~integer$ 500 は、
`000_11001^B
（`~major型$ `0$mj, `追加l情報$ `25^ai ）に
【`引数$を成す】
2 個の~byte `01f4^X （~decimalで 500 ）が後続する。
◎
The integer 500 would be 0b000_11001 (major type 0, additional information 25) followed by the two bytes 0x01f4, which is 500 in decimal.
</li>
		</ul>
	</dd>

	<dt>
`~major型$
`1@mj
◎
Major type 1:
</dt>
	<dd>
負な`~integer$ ~IN 範囲 { −~POW( 2, 64 ) 〜 −1 } 。
◎
A negative integer in the range -264..-1 inclusive.＼
</dd>
	<dd>
当の~itemの値は、
( −1 ~MINUS `引数$ )
になる。
例えば
⇒
`~integer$ −500 は、
`001_11001^B
（`~major型$ `1$mj, `追加l情報$ `25^ai ）に
【`引数$を成す】
2 個の~byte `01f3^X （~decimalで 499 ）が後続する。
◎
The value of the item is -1 minus the argument.＼
For example, the integer -500 would be 0b001_11001 (major type 1, additional information 25) followed by the two bytes 0x01f3, which is 499 in decimal.
</dd>

	<dt>
`~major型$
`2@mj
◎
Major type 2:
</dt>
	<dd>
<p>
`~byte~string$。
当の~string内の~byte数は`引数$に等しい。
例えば：
◎
A byte string. The number of bytes in the string is equal to the argument. For example,＼
</p>
		<ul>
			<li>
長さ 5 の`~byte~string$は、
`先頭~byte$ `010_00101^B
（`~major型$ `2$mj, `追加l情報$ `5^ai （長さ用））に［
~binary内容を成す 5 個の~byte
］が後続する。
◎
a byte string whose length is 5 would have an initial byte of 0b010_00101 (major type 2, additional information 5 for the length), followed by 5 bytes of binary content.＼
</li>
			<li>
長さ 500 の`~byte~string$は、
`先頭~byte$ `010_11001^B
（`~major型$ `2$mj, `追加l情報$ `25^ai ）に［
【`引数$を成す】長さ 500 用の 2 個の~byte `01f4^X
］が後続し，さらに［
~binary内容を成す 500 個の~byte
］が後続する。
◎
A byte string whose length is 500 would have 3 initial bytes of 0b010_11001 (major type 2, additional information 25 to indicate a two-byte length) followed by the two bytes 0x01f4 for a length of 500, followed by 500 bytes of binary content.
</li>
		</ul>
	</dd>

	<dt>
`~major型$
`3@mj
◎
Major type 3:
</dt>
	<dd>
~UTF-8 `RFC3629$r として符号化された`~text~string$
（ `2§ ）。
◎
A text string (Section 2) encoded as UTF-8 [RFC3629].＼
</dd>
	<dd>
`引数$は、［
当の~stringを成す~byteの個数
］を与える。
◎
The number of bytes in the string is equal to the argument.＼
</dd>
	<dd>
~stringが［
妥当でない~UTF-8連列
］を包含している場合、
`整形式$ではあるが，`妥当$でない【！`1.2§】。
◎
A string containing an invalid UTF-8 sequence is well-formed but invalid (Section 1.2).＼
</dd>
	<dd>
この型は、
ヒトが可読な~text［
に解釈する／を表示する
］必要がある~system用に供され，［
無構造な~byte列
］と［
指定された［
`~repertoire$（~Unicodeのそれ）, 符号化法（~UTF-8）
］を伴う~text
］を区別することを許容する。
◎
This type is provided for systems that need to interpret or display human-readable text, and allows the differentiation between unstructured bytes and text that has a specified repertoire (that of Unicode) and encoding (UTF-8).＼
</dd>
	<dd>
~JSONなどの形式とは対照的に、
この型における~Unicode文字は，~escapeされることは決してない。
したがって， `000A^U （改行文字）は、
~string内では，常に~byte `0a^X として表現される
— 決して，~byte列［
`5c6e^X
（文字［
"`\^c" , "`n^c"
］が成す並び）／
`5c7530303061^X
（文字［
"`\^c", "`u^c", "`0^c", "`0^c", "`0^c", "`a^c"
］が成す並び）
］としてではなく。
◎
In contrast to formats such as JSON, the Unicode characters in this type are never escaped. Thus, a newline character (U+000A) is always represented in a string as the byte 0x0a, and never as the bytes 0x5c6e (the characters "\" and "n") nor as 0x5c7530303061 (the characters "\", "u", "0", "0", "0", and "a").
</dd>

	<dt>
`~major型$
`4@mj
◎
Major type 4:
</dt>
	<dd>
0 個以上の~data~itemからなる`~array$。
`~array$は、
他の形式においては［
~list（ `list^en ）,
連列（ `sequence^en ）,
~tuple（ `tuple^en ）
］とも呼ばれる
（ “~CBOR連列” `RFC8742$r は、
少し異なる何かであるが）。
◎
An array of data items. In other formats, arrays are also called lists, sequences, or tuples (a "CBOR sequence" is something slightly different, though [RFC8742]).＼
</dd>
	<dd>
`引数$は、［
当の`~array$を成す~data~itemの個数
］を与える。
◎
The argument is the number of data items in the array.＼
</dd>
	<dd>
`~array$内の~itemは、
すべてが同じ型になる必要はない。
例えば， 10 個の~itemを包含する`~array$は、
各~itemの型が何であれ，
`先頭~byte$ `100_01010^B
（`~major型$ `4$mj, `追加l情報$ `10^ai （長さ用））
に［
10 個の~item
］が後続することになる。
◎
Items in an array do not need to all be of the same type. For example, an array that contains 10 items of any type would have an initial byte of 0b100_01010 (major type 4, additional information 10 for the length) followed by the 10 remaining items.
</dd>

	<dt>
`~major型$
`5@mj
◎
Major type 5:
</dt>
	<dd>
0 個以上の
`~entry@
からなる`~map$。
各`~entry$は、
~~連続する 2 個の~data~itemが成す~pairで与えられ，
順に当の`~entry$の［
`~key@,
`値@
］を与える。
`~map$は、
他の形式においては［
~table（ `table^en ）／
辞書（ `dictionary^en ）／
~hash（ `hash^en ）／
（~JSONにおいては）~object（ `object^en ）
］とも呼ばれる。
◎
A map of pairs of data items. Maps are also called tables, dictionaries, hashes, or objects (in JSON).＼
A map is comprised of pairs of data items, each pair consisting of a key that is immediately followed by a value.＼
</dd>
	<dd class="trans-note">【
~entryは，原文では “`key/value piar^en” と称されるが、
この訳では，各種~web標準に共通して利用される名称 “~entry（ `entry^en ）” を利用する。
】</dd>
	<dd>
`引数$は、
当の`~map$を成す`~entry$の個数を与える。
例えば，`~map$が 9 個の`~entry$を包含するならば、
`先頭~byte$は `101_01001^B
（`~major型$ `5$mj, `追加l情報$ `9^ai （`~entry$の個数~用））になり，
18 個の~itemが後続することになる
— ［
1 個目, 2 個目
］の~itemは 1 個目の`~entry$の［
`~key$, `値$
］, ［
3 個目, 4 個目
］の~itemは 2 個目の`~entry$の［
`~key$, `値$
］, 等々。
◎
The argument is the number of pairs of data items in the map. For example, a map that contains 9 pairs would have an initial byte of 0b101_01001 (major type 5, additional information 9 for the number of pairs) followed by the 18 remaining items. The first item is the first key, the second item is the first value, the third item is the second key, and so on.＼
</dd>
	<dd>
`~map$内の~itemたちは`~entry$を成すよう~pairで来るので、
~itemの総数は常に偶数になる
— `~map$が奇数~個の~itemを包含する場合
（すなわち、
最後の`~entry$の`~key$を与える~data~itemの後に，`値$を与える~data~itemが無い場合）、
`整形式$でない。
◎
Because items in a map come in pairs, their total number is always even: a map that contains an odd number of items (no value data present after the last key data item) is not well-formed.＼
</dd>
	<dd>
`~map$内に重複な`~key$がある場合、
`整形式$にはなり得るが，`妥当$ではない
— したがって，それは、
復号が非決定的になる原因になる
— `5.6§ も見よ。
◎
A map that has duplicate keys may be well-formed, but it is not valid, and thus it causes indeterminate decoding; see also Section 5.6.
</dd>

	<dt>
`~major型$
`6@mj
◎
Major type 6:
</dt>
	<dd>
<p>
`~tag$。
各`~tag$は、
次の 2 つからなる：
</p>
		<ul>
			<li>
`~tag番号$
⇒
~integer ~IN 範囲 { 0 〜 ( ~POW( 2, 64 ) ~MINUS 1 ) } であり，
`引数$として与えられる。
</li>
			<li>
`~tag内容$
⇒
`~tag$に封入された［
`~head$に後続する 1 個の`符号化された~data~item$
］として与えられる。
</li>
		</ul>
◎
A tagged data item ("tag") whose tag number, an integer in the range 0..264-1 inclusive, is the argument and whose enclosed data item (tag content) is the single encoded data item that follows the head. See Section 3.4.
</dd>

	<dt>
`~major型$
`7@mj
◎
Major type 7:
</dt>
	<dd>
`~float$／
`単純~値$／
`~break$
◎
Floating-point numbers and simple values, as well as the "break" stop code. See Section 3.3.
</dd>
</dl>

<p>
これらの 8 種の`~major型$から、［
~data~itemの`先頭~byte$にアリな 256 通りの値
］のうちどれが利用されるかを示す単純な表0（ `表0 7＠#jumptable$ ）が導かれる。
◎
These eight major types lead to a simple table showing which of the 256 possible values for the initial byte of a data item are used (Table 7).
</p>

<p>
`~major型$ ~IN { `6$mj, `7$mj } においては、
アリな値の多くは，将来の仕様~用に予約される。
これらの値についての さらなる情報は `9§ を見よ。
◎
In major types 6 and 7, many of the possible values are reserved for future specification. See Section 9 for more information on these values.
</p>

<p>
~CBORにより定義される`~major型$は、
`表0 1＠#major-type-table$
に要約される
— 今の所は `3.2§ は無視して。
この表0における~number %N は、
`引数$を表す。
◎
Table 1 summarizes the major types defined by CBOR, ignoring Section 3.2 for now. The number N in this table stands for the argument.
</p>

<div>
<table id="table-1">
<caption id="major-type-table">
表0 1：
各種~CBOR~major型における確定~長さの利用の概観
（ %N ~EQ `引数$ )
</caption>
<thead>
<tr><th>`~major型$
<th>意味
<th>内容
</thead><tbody>
<tr><td>`0$mj
<td>無符号`~integer$ %N
<td>なし

<tr><td>`1$mj
<td>負な`~integer$ −1−%N
<td>なし

<tr><td>`2$mj
<td>`~byte~string$
<td>%N 個の~byte

<tr><td>`3$mj
<td>`~text~string$
<td>%N 個の~byte （~UTF-8~text）

<tr><td>`4$mj
<td>`~array$
<td>%N 個の~data~item（要素）

<tr><td>`5$mj
<td>`~map$
<td>( 2 ~MUL %N ) 個の~data~item（ %N 個の`~entry$）

<tr><td>`6$mj
<td>`~tag番号$ %N
<td>1 個の~data~item

<tr><td>`7$mj
<td>`単純~値$／`~float$
<td>なし

</tbody>
</table>
◎
Table 1: Overview over the Definite-Length Use of CBOR Major Types (N = Argument)
◎
Major Type｜Meaning｜Content
0｜unsigned integer N｜-
1｜negative integer -1-N｜-
2｜byte string｜N bytes
3｜text string｜N bytes (UTF-8 text)
4｜array｜N data items (elements)
5｜map｜2N data items (key/value pairs)
6｜tag of number N｜1 data item
7｜simple/float｜-
</div>

		</section>
		<section id="indefinite">
<h3 title="Indefinite Lengths for Some Major Types">3.2. 一部の~major型~用の不定な長さ</h3>

<p>
`~data~item$のうち［
`~array$,
`~map$,
`~byte~string$,
`~text~string$
］は、
`追加l情報$に値 `31^ai を利用して，
`不定長@
（ `indefinite-length^en ）
になるよう符号化できる
—
`確定長@
（ `definite-length^en ）は、
その否定を表す。
これは、
当の~itemの符号化は［
`~array$を成す~itemの個数／
`~map$を成す`~entry$の個数／
~stringの総-長さ
］が既知になる前に始まる必要がある場合に有用になる。
（~data~itemを成す すべてが既知になる前に，その送信を開始する能は、
当の~data~itemの中で
`~streamして@
いると称されることが多い。）
◎
Four CBOR items (arrays, maps, byte strings, and text strings) can be encoded with an indefinite length using additional information value 31. This is useful if the encoding of the item needs to begin before the number of items inside the array or map, or the total length of the string, is known. (The ability to start sending a data item before all of it is known is often referred to as "streaming" within that data item.)
</p>

<p>
`不定長$な［
`~array$／`~map$
］が どう処されるかは、
`不定長$な~string【！（`~byte~string$, `~text~string$）】とは異なる。
◎
Indefinite-length arrays and maps are dealt with differently than indefinite-length strings (byte strings and text strings).
</p>

			<section id="break">
<h4 title="The 'break' Stop Code">3.2.1. `break^i</h4>

<p>
`~break@
（ `"break" stop code^en, 略して `break^en ）†は、
`111_11111^B
（ `~major型$ `7$mj, `追加l情報$ `31^ai ）
に符号化される。
それ自体は~data~itemではなく，
`不定長$な~itemを閉じるための構文-特能でしかない。
◎
The "break" stop code is encoded with major type 7 and additional information value 31 (0b111_11111). It is not itself a data item: it is just a syntactic feature to close an indefinite-length item.
</p>

<p class="trans-note">【†
この訳では、
一律に `break^i と略記する。
】</p>

<p>
~data~itemが期待される所に `~break$ が現れる場合、
`不定長$な~stringの内側に直に現れる場合
（例：`確定長$な［
`~array$／`~map$
］の内側に直に現れる場合）
を除き，それを封入している~data~itemは`整形式$でない。
◎
If the "break" stop code appears where a data item is expected, other than directly inside an indefinite-length string, array, or map -- for example, directly inside a definite-length array or map -- the enclosing item is not well-formed.
</p>

			</section>
			<section id="indef">
<h4 title="Indefinite-Length Arrays and Maps">3.2.2. 不定長な~array／~map</h4>

<p>
`不定長$な［
`~array$／`~map$
］は、［
各自の`~major型$, `追加l情報$ `31^ai
］を利用して表現され，
0 個以上の［
`~array$用の~item／`~map$用の`~entry$
］からなる連列,
`~break$ が順に後続する。
言い換えれば、
`不定長$な［
`~array$／`~map$
］の見かけは，［
`追加l情報$を成す値 `31^ai で始まり， `~break$ で終端する
］ことを除いて他の［
`~array$／`~map$
］と一致する。
◎
Indefinite-length arrays and maps are represented using their major type with the additional information value of 31, followed by an arbitrary-length sequence of zero or more items for an array or key/value pairs for a map, followed by the "break" stop code (Section 3.2.1). In other words, indefinite-length arrays and maps look identical to other arrays and maps except for beginning with the additional information value of 31 and ending with the "break" stop code.
</p>

<p>
`~break$ が`~map$内のある`~entry$の値が占める所に現れる場合、
当の`~map$は，`整形式$でない。
◎
If the "break" stop code appears after a key in a map, in place of that key's value, the map is not well-formed.
</p>

<p>
`不定長$な［
`~array$／`~map$
］~itemを入子にすることに抗する制約は無い。
`~break$ は、
単独の~itemに限り，終了させる
— `~break$ は、
入子にされた`不定長$な~itemごとに
— 各自を開始している`先頭~byte$【！type bytes】と対になるよう —
必要になる。
◎
There is no restriction against nesting indefinite-length array or map items. A "break" only terminates a single item, so nested indefinite-length items need exactly as many "break" stop codes as there are type bytes starting an indefinite-length item.
</p>

<p>
例えば，ある符号化器が抽象-~array
[1, [2, 3], [4, 5]]
を表現するよう求めていると見做すなら、
`確定長$な符号化法は， `8301820203820405^X になる：
◎
For example, assume an encoder wants to represent the abstract array [1, [2, 3], [4, 5]]. The definite-length encoding would be 0x8301820203820405:
</p>

<div>
<pre class="artwork">
83        `— ~array, 長さ 3^cmt
   01     `— 1^cmt
   82     `— ~array, 長さ 2^cmt
      02  `— 2^cmt
      03  `— 3^cmt
   82     `— ~array, 長さ 2^cmt
      04  `— 4^cmt
      05  `— 5^cmt
</pre>
<pre class="_en" lang="en">
83        -- Array of length 3
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   82     -- Array of length 2
      04  -- 4
      05  -- 5
</pre>
</div>

<p>
この~data~item内に符号化された 3 個の各`~array$には、
要求されるだけ独立に，`不定長$な符号化法を適用することもでき，
次に挙げる表現も~~可能になる：
◎
Indefinite-length encoding could be applied independently to each of the three arrays encoded in this data item, as required, leading to representations such as:
</p>

<div>
<pre class="artwork">
`9f018202039f0405ffff^X
9F        `— 不定長な~arrayの開始^cmt
   01     `— 1^cmt
   82     `— ~array, 長さ 2^cmt
      02  `— 2^cmt
      03  `— 3^cmt
   9F     `— Start 不定長な~arrayの開始^cmt
      04  `— 4^cmt
      05  `— 5^cmt
      FF  `— ~break （内縁~array）^cmt
   FF     `— ~break （外縁~array）^cmt
</pre>
<pre class="_en" lang="en">
0x9f018202039f0405ffff
9F        -- Start indefinite-length array
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   9F     -- Start indefinite-length array
      04  -- 4
      05  -- 5
      FF  -- "break" (inner array)
   FF     -- "break" (outer array)
</pre>
</div>

<div>
<pre class="artwork">
`9f01820203820405ff^X
9F        `— 不定長な~arrayの開始^cmt
   01     `— 1^cmt
   82     `— ~array, 長さ 2^cmt
      02  `— 2^cmt
      03  `— 3^cmt
   82     `— ~array, 長さ 2^cmt
      04  `— 4^cmt
      05  `— 5^cmt
   FF     `— ~break^cmt
</pre>
<pre class="_en" lang="en">
0x9f01820203820405ff
9F        -- Start indefinite-length array
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   82     -- Array of length 2
      04  -- 4
      05  -- 5
   FF     -- "break"
</pre>
</div>

<div>
<pre class="artwork">
`83018202039f0405ff^X
83        `— ~array, 長さ 3^cmt
   01     `— 1^cmt
   82     `— ~array, 長さ 2^cmt
      02  `— 2^cmt
      03  `— 3^cmt
   9F     `— 不定長な~arrayの開始^cmt
      04  `— 4^cmt
      05  `— 5^cmt
      FF  `— ~break^cmt
</pre>
<pre class="_en" lang="en">
0x83018202039f0405ff
83        -- Array of length 3
   01     -- 1
   82     -- Array of length 2
      02  -- 2
      03  -- 3
   9F     -- Start indefinite-length array
      04  -- 4
      05  -- 5
      FF  -- "break"
</pre>
</div>

<div>
<pre class="artwork">
`83019f0203ff820405^X
83        `— ~array, 長さ 3^cmt
   01     `— 1^cmt
   9F     `— 不定長な~arrayの開始^cmt
      02  `— 2^cmt
      03  `— 3^cmt
      FF  `— ~break^cmt
   82     `— ~array, 長さ 2^cmt
      04  `— 4^cmt
      05  `— 5^cmt
</pre>
<pre class="_en" lang="en">
0x83019f0203ff820405
83        -- Array of length 3
   01     -- 1
   9F     -- Start indefinite-length array
      02  -- 2
      03  -- 3
      FF  -- "break"
   82     -- Array of length 2
      04  -- 4
      05  -- 5
</pre>
</div>

<p>
`不定長$な`~map$
（ 2 個の`~entry$を伴うとする）の例：
◎
An example of an indefinite-length map (that happens to have two key/value pairs) might be:
</p>

<div>
<pre class="artwork">
`bf6346756ef563416d7421ff^X
BF           `— 不定長な~mapの開始^cmt
   63        `— 1 個目の~key（ ~UTF-8~string, 長さ 3 ）^cmt
      46756e `—   "Fun"^cmt
   F5        `— 1 個目の値, true^cmt
   63        `— 2 個目の~key（ ~UTF-8~string, 長さ 3 ）^cmt
      416d74 `—   "Amt"^cmt
   21        `— 2 個目の値（ −2 ）^cmt
   FF        `— ~break^cmt
</pre>
<pre class="_en" lang="en">
0xbf6346756ef563416d7421ff
BF           -- Start indefinite-length map
   63        -- First key, UTF-8 string length 3
      46756e --   "Fun"
   F5        -- First value, true
   63        -- Second key, UTF-8 string length 3
      416d74 --   "Amt"
   21        -- Second value, -2
   FF        -- "break"
</pre>
</div>

			</section>
			<section id="indefinite-length-byte-strings-and-text-strings">
<h4 title="Indefinite-Length Byte Strings and Text Strings">3.2.3. 不定長な `~byte~string$／`~text~string$</h4>

<p>
`不定長$な［
`~byte~string$／`~text~string$
］は、［
各自の`~major型$［
`2$mj ／ `3$mj
］, `追加l情報$ `31^ai
］を包含している~byteにより表現され，一連の 0 個以上の［
指定された型の`確定長$な~string
］（ “~chunk列” ）が後続し，
`~break$ により完遂する。
`不定長$な~stringが表現する~data~itemは、
これら~chunkの連結になる。
~chunkが 1 つも無い場合、
当の~data~itemは，指定された型の空な~stringになる。
長さ 0 の~chunkも
— 特に有用ではないが —
許可される。
◎
Indefinite-length strings are represented by a byte containing the major type for byte string or text string with an additional information value of 31, followed by a series of zero or more strings of the specified type ("chunks") that have definite lengths, and finished by the "break" stop code (Section 3.2.1). The data item represented by the indefinite-length string is the concatenation of the chunks. If no chunks are present, the data item is an empty string of the specified type. Zero-length chunks, while not particularly useful, are permitted.
</p>

<p>
`不定長$な~string指示子（ `010_11111^B ／ `011_11111^B ）と `~break$ の合間に生じ得る~itemは、［
同じ`~major型$の`確定長$な~string~item
］に限られる
— さもなければ、当の~stringは`整形式$でない。
◎
If any item between the indefinite-length string indicator (0b010_11111 or 0b011_11111) and the "break" stop code is not a definite-length string item of the same major type, the string is not well-formed.
</p>

<p>
`不定長$な~stringの中に［
~chunkとして`不定長$な~stringを入子にすること
］は、
設計により，許容されない。
それを許容した場合、
復号器~実装に入子ng~levelの［
~stack, あるいは少なくとも回数
］を保つよう要求することになろう。
そのような入子ngは、
符号化器には必要とされない
— 内縁な`不定長$な~stringを成す各~chunkは、
代わりに外縁な`不定長$な~stringの中に直に置くこともできるので。
◎
The design does not allow nesting indefinite-length strings as chunks into indefinite-length strings. If it were allowed, it would require decoder implementations to keep a stack, or at least a count, of nesting levels. It is unnecessary on the encoder side because the inner indefinite-length string would consist of chunks, and these could instead be put directly into the outer indefinite-length string.
</p>

<p>
`不定長$な`~text~string$は、
それを成すある~chunkが`確定長$な`~text~string$として`妥当$でない場合には，`妥当$でない。
したがって、［
ある 1 個の~Unicode符号位置（~scalar値）のみからなる~UTF-8~byte列
］は，複数個の~chunkにまたがり得ないことに注意
— 新たな~chunkを成す`~text~string$を開始し得るのは、
符号位置~境界に限られる。
◎
If any definite-length text string inside an indefinite-length text string is invalid, the indefinite-length text string is invalid. Note that this implies that the UTF-8 bytes of a single Unicode code point (scalar value) cannot be spread between chunks: a new chunk of a text string can only be started at a code point boundary.
</p>

<p>
例えば、
ある`符号化された~data~item$が次の~byte列からなると見做すなら：
◎
For example, assume an encoded data item consisting of the bytes:
</p>

<div>
<pre class="artwork">
`010_11111^B `010_00100^B 0xaabbccdd `010_00011^B 0xeeff99 `111_11111^B
5F              `— 不定長な~byte~stringの開始^cmt
   44           `— ~byte~string, 長さ 4^cmt
      aabbccdd  `— ~byte列の内容^cmt
   43           `— ~byte~string, 長さ 3^cmt
      eeff99    `— ~byte列の内容^cmt
   FF           `— ~break^cmt
</pre>
<pre class="_en" lang="en">
0b010_11111 0b010_00100 0xaabbccdd 0b010_00011 0xeeff99 0b111_11111
5F              -- Start indefinite-length byte string
   44           -- Byte string of length 4
      aabbccdd  -- Bytes content
   43           -- Byte string of length 3
      eeff99    -- Bytes content
   FF           -- "break"
</pre>
</div>

<p>
これを復号した結果は、［
7 個の~byteからなる 1 個の`~byte~string$
］ `aabbccddeeff99^X を伴う。
◎
After decoding, this results in a single byte string with seven bytes: 0xaabbccddeeff99.
</p>

			</section>
			<section id="summary-of-indefinite-length-use-of-major-types">
<h4 title="Summary of Indefinite-Length Use of Major Types">3.2.4. 不定長な~major型の利用の要約</h4>

<p>
~CBORにより定義される各`~major型$において［
`不定長$な（`追加l情報$ `31^ai を伴う）符号化法
］として利用されるものを
`表0 2＠#major-type-indef-table$に要約する。
◎
Table 2 summarizes the major types defined by CBOR as used for indefinite-length encoding (with additional information set to 31).
</p>

<div>
<table id="table-2">
<caption id="major-type-indef-table">
表0 2：
`不定長$な~CBOR`~major型$（`追加l情報$ `31^ai ）の利用の概観
</caption>
<thead>
<tr><th>`~major型$
<th>意味
<th>`~break$ まで封入される内容
</thead><tbody>

<tr><td>`0$mj
<td>（`整形式$でない）
<td>—

<tr><td>`1$mj
<td>（`整形式$でない）
<td>—

<tr><td>`2$mj
<td>`~byte~string$
<td>0 個以上の`確定長$な`~byte~string$

<tr><td>`3$mj
<td>`~text~string$
<td>0 個以上の`確定長$な`~text~string$

<tr><td>`4$mj
<td>`~array$
<td>0 個以上の~data~item（要素）

<tr><td>`5$mj
<td>`~map$
<td>0 個以上の~data~item（各`~entry$の`~key$, `値$）

<tr><td>`6$mj
<td>（`整形式$でない）
<td>—

<tr><td>`7$mj
<td>`~break$ 
<td>—

</tbody>
</table>
◎
Table 2: Overview of the Indefinite-Length Use of CBOR Major Types (Additional Information = 31)
◎
Major Type｜Meaning｜Enclosed up to "break" Stop Code
0｜(not well-formed)｜-
1｜(not well-formed)｜-
2｜byte string｜definite-length byte strings
3｜text string｜definite-length text strings
4｜array｜data items (elements)
5｜map｜data items (key/value pairs)
6｜(not well-formed)｜-
7｜"break" stop code｜-
</div>

			</section>
		</section>
		<section id="fpnocont">
<h3 title="Floating-Point Numbers and Values with No Content">3.3. ~floatと単純~値</h3>

<div>
<p>
`~major型$ `7$mj は、
次に挙げる 2 種の~data型~用にある：
</p>
<ul>
	<li>
`~float@
（ `floating-point number^en, 浮動小数点数, 略して `float^en ）
【この訳では、一律に~floatと略記する】
</li>
	<li>
`単純~値@
（ `simple value^en ）
</li>
</ul>

<p>
この`~major型$の~itemは、
`~integer$用の`~major型$と同様に，内容~dataを運ばない
— すべての情報は、
`~head$内にある。
</p>

<p>
`先頭~byte$内の`追加l情報$を与える 32 通りの値は、
`表0 3＠#fpnoconttbl$ に定義されるとおり，
自前の別々な意味がある。
</p>

◎
Major type 7 is for two types of data: floating-point numbers and "simple values" that do not need any content. Each value of the 5-bit additional information in the initial byte has its own separate meaning, as defined in Table 3. Like the major types for integers, items of this major type do not carry content data; all the information is in the initial bytes (the head).
</div>


<div>
<table id="table-3">
<caption id="fpnoconttbl">
表0 3：
~major型 `7$mj における`追加l情報$用の値
</caption>
<thead>
<tr><th>`追加l情報$
<th>意味論
</thead><tbody>

<tr><td>`0^ai 〜 `23^ai
<td>`単純~値$ ~IN { 0 〜 23 }
【（`追加l情報$が，そのまま値を成す）】）

<tr><td>`24^ai
<td>`単純~値$ ~IN { 32 〜 255 }
（後続する 1 個の~byteが値を成す）

<tr><td>`25^ai
<td>`半-精度~float$
（後続する 2 個の~byteが値を成す）

<tr><td>`26^ai
<td>`単-精度~float$
（後続する 4 個の~byteが値を成す）

<tr><td>`27^ai
<td>`倍-精度~float$
（後続する 8 個の~byteが値を成す）

<tr><td>`28^ai ／ `29^ai ／ `30^ai
<td>予約-済み
— ~CBORの現~versionにおいては`整形式$でない

<tr><td>`31^ai
<td>`不定長$な~item用の `~break$

</tbody>
</table>

<p>
上に挙げた各種`~float$は、
`IEEE754$r に定義される：
</p>
<ul>
	<li>
`半-精度~float@
⇒
~IEEE754 `Half-Precision Float^en
（ 16 ~bit, `binary16^en 形式とも称される）
</li>
	<li>
`単-精度~float@
⇒
~IEEE754 `Single-Precision Float^en
（ 32 ~bit, `binary32^en 形式とも称される）
</li>
	<li>
`倍-精度~float@
⇒
~IEEE754 `Double-Precision Float^en
（ 64 ~bit, `binary64^en 形式とも称される）
</li>
</ul>

◎
Table 3: Values for Additional Information in Major Type 7
5-Bit Value｜Semantics
0..23｜Simple value (value 0..23)
24｜Simple value (value 32..255 in following byte)
25｜IEEE 754 Half-Precision Float (16 bits follow)
26｜IEEE 754 Single-Precision Float (32 bits follow)
27｜IEEE 754 Double-Precision Float (64 bits follow)
28-30｜Reserved, not well-formed in the present document
31｜"break" stop code for indefinite-length items (Section 3.2.1)
</div>

<p>
他すべての`~major型$と同じく、
`追加l情報$ `24^ai は，単-~byteによる拡張を表す
— それには、
`単純~値$を表現する，追加的な（ 1 個の）~byteが後続する
（混同を最小化するため、
この~byteに利用される値は 32 以上に限られる）。
これは、
`~head$の構造を保守する：
他の`~major型$と同じく、
これらの長さは，常に［
`先頭~byte$内の`追加l情報$
］に依存する。
`表0 4＠#fpnoconttbl2$ に，
`単純~値$に可用な数量-値, アテガわれた意味論を挙げる。
◎
As with all other major types, the 5-bit value 24 signifies a single-byte extension: it is followed by an additional byte to represent the simple value. (To minimize confusion, only the values 32 to 255 are used.) This maintains the structure of the initial bytes: as for the other major types, the length of these always depends on the additional information in the first byte. Table 4 lists the numeric values assigned and available for simple values.
</p>

<div>
<table id="table-4">
<caption id="fpnoconttbl2">
表0 4：
`単純~値$
</caption>
<thead>
<tr><th>値
<th>意味論
</thead><tbody>

<tr><td>0 〜 19
<td>（何もアテガわれていない）

<tr><td>20
<td>`false@i

<tr><td>21
<td>`true@i

<tr><td>22
<td>`null@i

<tr><td>23
<td>`undefined@i

<tr><td>24 〜 31
<td>（予約-済み）

<tr><td>32 〜 255
<td>（何もアテガわれていない）

</tbody>
</table>
◎
Table 4: Simple Values
◎
Value｜Semantics
0..19｜(unassigned)
20｜false
21｜true
22｜null
23｜undefined
24..31｜(reserved)
32..255｜(unassigned)
</div>

<p>
符号化器は、
`先頭~byte$ `f8^X （`~major型$ `7$mj, `追加l情報$ `24^ai ）に継続して，
`20^X （ 32 ）未満の~byteを発行してはナラナイ。
そのような 2 個の~byteからなる連列は、
`整形式$でない。
（このことは、［
符号化器は［
`false$i ／ `true$i ／ `null$i ／ `undefined$i
］を 2 個の~byteとして符号化し得ない
］こと，および［
これら 1 個の~byteからなる表現~変種に限り`整形式$になる
］ことを含意する
— より一般には、
どの`単純~値$も，その表現~変種は一つに限られる）。
◎
An encoder MUST NOT issue two-byte sequences that start with 0xf8 (major type 7, additional information 24) and continue with a byte less than 0x20 (32 decimal). Such sequences are not well-formed. (This implies that an encoder cannot encode false, true, null, or undefined in two-byte sequences and that only the one-byte variants of these are well-formed; more generally speaking, each simple value only has a single representation variant).
</p>

<p>
`追加l情報$［
`25^ai ／ `26^ai ／ `27^ai
］は、［
`半-精度$／`単-精度$／`倍-精度$
］`~float$用にある。
これらの`~float$値は、
適切な~sizeの追加的な~byte列~内に符号化される。
（`半-精度~float$についての他の情報は `D§ を見よ。）
◎
The 5-bit values of 25, 26, and 27 are for 16-bit, 32-bit, and 64-bit IEEE 754 binary floating-point values [IEEE754]. These floating-point values are encoded in the additional bytes of the appropriate size. (See Appendix D for some information about 16-bit floating-point numbers.)
</p>

		</section>
		<section id="tags">
<h3 title="Tagging of Items">3.4. ~itemの~tag付け</h3>

<p>
~CBORにおける~data~itemは、
ある`~tag$内に封入することにより，何らかの追加的な意味論を与えれる
— `~tag$の意味論は、
`~tag番号@
（ `tag number^en ）により一意に識別される。
`~tag$の`~major型$は `6$mj であり，
その`引数$【！（ `3§ ）】が`~tag番号$を指示する。
各`~tag$は、
`~tag内容@
（ `tag content^en ）
— 当の~tagに封入された 1 個の~data~item —
を包含する
（ある`~tag$が，その`~tag内容$に更なる構造を要求する場合、
封入された~data~itemが，その構造を供する）。
用語
`~tag@
は、［
`~tag番号$, `~tag内容$
］からなる~data~item全体を指す
【すなわち、~tag自身も`~data~item$である】
— `~tag内容$は、
~tag付けられた~data~itemである。
◎
In CBOR, a data item can be enclosed by a tag to give it some additional semantics, as uniquely identified by a tag number. The tag is major type 6, its argument (Section 3) indicates the tag number, and it contains a single enclosed data item, the tag content. (If a tag requires further structure to its content, this structure is provided by the enclosed data item.) We use the term tag for the entire data item consisting of both a tag number and the tag content: the tag content is the data item that is being tagged.
</p>

<p class="trans-note">【
所与の~data~itemを形容する語 “~tag付き（ `tagged^en ）” は、
当の~data~itemが，ある`~tag$の`~tag内容$であることをいう
（ “~tag付ける” は、そうなるようにすることをいう）。
しかしながら、
“~tag付き~data~item” が実際には`~tag$を意味する箇所も少数あり，紛らわしいので、
この訳では，ほとんどの “~tag付き~data~item” を［
~tag内容／~tag
］のうち適切な方に置換している。
】</p>

<p>
例えば，長さ 12 の`~byte~string$は、
`~tag番号$ `2$tag を伴う`~tag$で~markされたと見做すならば，
無符号な`~bignum$であることを指示する。
`符号化された~data~item$は、
`先頭~byte$ `110_00010^B
（`~major型$ `6$mj, `追加l情報$ `2^ai （`~tag番号$用））
に，符号化された`~tag内容$として次が順に後続することになる
⇒＃
`010_01100^B （`~major型$ `2$mj, `追加l情報$ `12^ai （長さ用））,
当の`~bignum$を成す 12 個の~byte
◎
For example, assume that a byte string of length 12 is marked with a tag of number 2 to indicate it is an unsigned bignum (Section 3.4.3). The encoded data item would start with a byte 0b110_00010 (major type 6, additional information 2 for the tag number) followed by the encoded tag content: 0b010_01100 (major type 2, additional information 12 for the length) followed by the 12 bytes of the bignum.
</p>

<p>
`拡張された汎用~data~model$においては、
`~tag番号$の定義は，［
当の~tag番号で伝達される追加的な意味論
］を述べる。
これらの意味論は、
一部の`~tag$と他の~data~item
— 一部の［
基本的な`汎用~data~model$で表現できる~data~item
］も含む —
との等価性を含むこともある。
一例として，
`~bignum$ `c24101^X は、
その`~tag内容$は
1 個の~byte `01^X を伴う`~byte~string$であり，
`~integer$ 1 に等価になる
— それは、［
`01^X ／ `1801^X ／ `190001^X
］として符号化することもできる。
当の~tag定義は、
汎用な符号化器~用に推奨される選好される直列化（ `4.1§ ）を指定することもあろう
— それは、
`~tag$を使役する表現よりも，
基本的な`汎用~data~model$による表現を選好することもあろう。
◎
In the extended generic data model, a tag number's definition describes the additional semantics conveyed with the tag number. These semantics may include equivalence of some tagged data items with other data items, including some that can be represented in the basic generic data model. For instance, 0xc24101, a bignum the tag content of which is the byte string with the single byte 0x01, is equivalent to an integer 1, which could also be encoded as 0x01, 0x1801, or 0x190001. The tag definition may specify a preferred serialization (Section 4.1) that is recommended for generic encoders; this may prefer basic generic data model representations over ones that employ a tag.
</p>

<p>
~tag定義は、
通例的に［
どの~data~itemが，その`~tag内容$として妥当になるか
］を定義する。
~tag定義は、
その内容を［
この文書にて定義される`~tag$が行うとおり，ごく特定の構文-構造に制約する
］こともあれば［
より意味論的に定義する
］こともある。
後者の例として、
`~tag番号$【！~tag】 ~IN { `40^tag, `1040^tag } が，
`~array$を表現する複数の仕方を どう受容するかがある
`RFC8746$r
。
◎
The tag definition usually defines which nested data items are valid for such tags. Tag definitions may restrict their content to a very specific syntactic structure, as the tags defined in this document do, or they may define their content more semantically. An example for the latter is how tags 40 and 1040 accept multiple ways to represent arrays [RFC8746].
</p>

<p>
規約に関する事として、
多くの`~tag$は，`~tag内容$として［
`null$i, `undefined$i
］値を受容しない
— 代わりに，`~tag$が占める所に値［
`null$i ／ `undefined$i
］を利用できることを期待する
— `3.4.2§ は、［
ある特定の`~tag$用の更なる考慮点
］として［
応用~protocol, ~platform型への対応付け
］における，この規約の取扱いを供する。
◎
As a matter of convention, many tags do not accept null or undefined values as tag content; instead, the expectation is that a null or undefined value can be used in place of the entire tag; Section 3.4.2 provides some further considerations for one specific tag about the handling of this convention in application protocols and in mapping to platform types.
</p>

<p>
復号器は、
あらゆる`~tag番号$の`~tag$を解する必要はない。
また，応用における`~tag$の価値は少ししかないこともあろう
— そこでは、［
特定0の`~data~item$を作成している実装,
その~streamを復号している実装
］が［
~data~flowにおける各~itemの意味論上の意味
］を知る。
この仕様における`~tag$の首な目的は、
日付など，共通な~data型を定義することにある。
第二の目的は、［
当の`~data~item$は、
異なる形式に翻訳される必要があり，
~itemの内容についての~hintを要求している
］ことが予知されるとき，変換~用の~hintを供することにある。
`~tag$の意味論を解することは、
復号器にとっては任意選択~である。
復号器は、
単純に
— すなわち，当の`~tag$による追加的な意味論を解釈することなく —
当の応用に［
`~tag番号$, `~tag内容$
］を呈示できる。
◎
Decoders do not need to understand tags of every tag number, and tags may be of little value in applications where the implementation creating a particular CBOR data item and the implementation decoding that stream know the semantic meaning of each item in the data flow. The primary purpose of tags in this specification is to define common data types such as dates. A secondary purpose is to provide conversion hints when it is foreseen that the CBOR data item needs to be translated into a different format, requiring hints about the content of items. Understanding the semantics of tags is optional for a decoder; it can simply present both the tag number and the tag content to the application, without interpreting the additional semantics of the tag.
</p>

<p>
`~tag$は、
その`~tag内容$【！data item it encloses】に意味論を適用する。
~tagは入子にできる
— `~tag$ %A の`~tag内容$ %B もまた`~tag$である場合、
%B の`~tag内容$に %B を適用した結果に %A が適用される。
◎
A tag applies semantics to the data item it encloses. Tags can nest: if tag A encloses tag B, which encloses data item C, tag A applies to the result of applying tag B on data item C.
</p>

<p>
~IANAは、
`9.2§ にて述べられるとおり，
`~tag番号$の~registryを保守する。
`表0 5＠#tagvalues$ は、
`RFC7049$r にて定義された`~tag番号$の~listを
— この節を成す残りの定義と伴に —
供する
（ `RFC7049$r は、
~tag番号 `35^tag も定義した
— この~tag番号の論点は、
`3.4.5.3§ に従う）。
他の`~tag番号$のうち多くは、
`RFC7049$r の公表~後に定義されたことに注意
— 完全な~listは `9.2§ にて述べる~registryを見よ。
◎
IANA maintains a registry of tag numbers as described in Section 9.2. Table 5 provides a list of tag numbers that were defined in [RFC7049] with definitions in the rest of this section. (Tag number 35 was also defined in [RFC7049]; a discussion of this tag number follows in Section 3.4.5.3.) Note that many other tag numbers have been defined since the publication of [RFC7049]; see the registry described at Section 9.2 for the complete list.
</p>

<div>
<table id="table-5">
<caption id="tagvalues">
表0 5：
~RFC 7049 にて定義された`~tag番号$
</caption>
<thead>
<tr><th>`~tag番号$
<th>`~tag内容$【！~data~item】
<th>意味論
<th>参照
</thead><tbody>

<tr><td>`0$tag
<td>`~text~string$
<td>標準な日時~string
<td>`3.4.1§

<tr><td>`1$tag
<td>`~integer$ ／`~float$
<td>~epochに基づく日時
<td>`3.4.2§

<tr><td>`2$tag
<td>`~byte~string$
<td>無符号な`~bignum$
<td>`3.4.3§

<tr><td>`3$tag
<td>`~byte~string$
<td>負な`~bignum$
<td>`3.4.3§

<tr><td>`4$tag
<td>`~array$
<td>`~decimal小数$
<td>`3.4.4§

<tr><td>`5$tag
<td>`~array$
<td>`~bigfloat$
<td>`3.4.4§

<tr><td>`21$tag
<td>（任意）
<td>~base64url符号化法への変換が期待される
<td>`3.4.5.2§

<tr><td>`22$tag
<td>（任意）
<td>~base64符号化法への変換が期待される
<td>`3.4.5.2§

<tr><td>`23$tag
<td>（任意）
<td>~base16符号化法への変換が期待される
<td>`3.4.5.2§

<tr><td>`24$tag
<td>`~byte~string$
<td>`符号化された~data~item$
<td>`3.4.5.1§

<tr><td>`32$tag
<td>`~text~string$
<td>~URI
<td>`3.4.5.3§

<tr><td>`33$tag
<td>`~text~string$
<td>~base64url
<td>`3.4.5.3§

<tr><td>`34$tag
<td>`~text~string$
<td>~base64
<td>`3.4.5.3§

<tr><td>`36$tag
<td>`~text~string$
<td>~MIME~message
<td>`3.4.5.3§

<tr><td>`55799$tag
<td>（任意）
<td>自己を記述する~CBOR
<td>`3.4.6§

</tbody>
</table>
◎
Table 5: Tag Numbers Defined in RFC 7049
◎
Tag｜Data Item｜Semantics
0｜text string｜Standard date/time string; see Section 3.4.1
1｜integer or float｜Epoch-based date/time; see Section 3.4.2
2｜byte string｜Unsigned bignum; see Section 3.4.3
3｜byte string｜Negative bignum; see Section 3.4.3
4｜array｜Decimal fraction; see Section 3.4.4
5｜array｜Bigfloat; see Section 3.4.4
21｜(any)｜Expected conversion to base64url encoding; see Section 3.4.5.2
22｜(any)｜Expected conversion to base64 encoding; see Section 3.4.5.2
23｜(any)｜Expected conversion to base16 encoding; see Section 3.4.5.2
24｜byte string｜Encoded CBOR data item; see Section 3.4.5.1
32｜text string｜URI; see Section 3.4.5.3
33｜text string｜base64url; see Section 3.4.5.3
34｜text string｜base64; see Section 3.4.5.3
36｜text string｜MIME message; see Section 3.4.5.3
55799｜(any)｜Self-described CBOR; see Section 3.4.6
</div>

<p>
`~tag$は、
概念的には
— 直列化（逆直列化）の時点ではなく —
`汎用~data~model$において解釈される。
少数の`~tag$
（現時点では，`~tag番号$ `25^tag, `29^tag `IANA.cbor-tags$r ）
は、［
直列化／逆直列化
］の時点における処理を要求し得る意味論を伴って登録された
— 符号化器は，［
直列化において，`~data~item$たちを正確に どの順序で符号化するか
］を制御-下におく必要があり、
復号器は，［
逆直列化において，`~data~item$たちが正確に どの順序で符号化されたか
］を自覚する必要がある。
このことは、
これらの`~tag$は，任意な汎用な~CBOR［
符号化器／復号器
］（それは、
~data~model~levelにおける`~map$を成す`~entry$用には，［
直列化／逆直列化
］の順序を反映しないかもしれない）
の上層には実装し得ないことを意味する
— したがって，それらの実装は、
概して，汎用［
符号化器／復号器
］の中に統合される必要がある。
新たな`~tag$には、
この特質を伴う定義は`推奨されない^2119。
◎
Conceptually, tags are interpreted in the generic data model, not at (de-)serialization time. A small number of tags (at this time, tag number 25 and tag number 29 [IANA.cbor-tags]) have been registered with semantics that may require processing at (de-)serialization time: the decoder needs to be aware of, and the encoder needs to be in control of, the exact sequence in which data items are encoded into the CBOR data item. This means these tags cannot be implemented on top of an arbitrary generic CBOR encoder/decoder (which might not reflect the serialization order for entries in a map at the data model level and vice versa); their implementation therefore typically needs to be integrated into the generic encoder/decoder. The definition of new tags with this property is NOT RECOMMENDED.
</p>

<p>
~IANAは、
`~tag番号$［
`65535^tag,
`4294967295^tag,
`18446744073709551615^tag
］
（ 2 進数として全桁が 1 になるもの
— 順に， 16 ~bit, 32 ~bit, 64 ~bit）
を割振った。
これらは、実装者が［
特定の`~tag$が在ると期待される所に無いこと
【！either the presence of a specific tag or absence of a tag】
］を［
1 個の~integerを成す~data構造で指示する【？】
］よう求める場合の便利として利用され得る。
その割振りは、
`CBOR-TAGS$r `§ 10＠https://datatracker.ietf.org/doc/html/draft-bormann-cbor-notable-tags-02#section-10$
にて述べられる。
これらの`~tag$は、
実際の`~data~item$として生じるよう意図されたものではない
— 実装は、
そのように生じたものを~errorとして~flagしてもヨイ。
◎
IANA allocated tag numbers 65535, 4294967295, and 18446744073709551615 (binary all-ones in 16-bit, 32-bit, and 64-bit). These can be used as a convenience for implementers who want a single-integer data structure to indicate either the presence of a specific tag or absence of a tag. That allocation is described in Section 10 of [CBOR-TAGS]. These tags are not intended to occur in actual CBOR data items; implementations MAY flag such an occurrence as an error.
</p>

<p>
各~protocolは、
`汎用~data~model$を拡張できる：
◎
Protocols can extend the generic data model (Section 2)＼
</p>
<ul>
	<li>
`~tag番号$ ~IN { `0$tag, `1$tag } を利用することにより，
ある時点の時刻を表現している~data~itemで
◎
with data items representing points in time by using tag numbers 0 and 1,＼
</li>
	<li>
`~tag番号$ ~IN { `2$tag, `3$tag } を利用することにより，任意な~sizeの`~integer$で
◎
with arbitrarily sized integers by using tag numbers 2 and 3,＼
</li>
	<li>
`~tag番号$ ~IN { `4$tag, `5$tag } を利用することにより，任意な［
~size, 精度
］の`~float$値で
◎
and with floating-point values of arbitrary size and precision by using tag numbers 4 and 5.
</li>
</ul>

			<section id="stringdatetimesect">
<h4 title="Standard Date/Time String">3.4.1. 標準な日時~string</h4>

<p>
`~tag番号$
`0@tag
は、
日時を表現する。
その`~tag内容$は、
標準な形式
— `RFC3339$r における `date-time^P 生成規則により述べられ，
`RFC4287$r `§ 3.3＠~RFCx/rfc4287#section-3.3$ により精緻化された形式 —
による`~text~string$である。
［
`~text~string$以外の型／
`RFC4287$r にて述べられる形式に合致しないもの
］は、
`~tag内容$として`妥当$でない。
◎
Tag number 0 contains a text string in the standard format described by the date-time production in [RFC3339], as refined by Section 3.3 of [RFC4287], representing the point in time described there. A nested item of another type or a text string that doesn't match the format described in [RFC4287] is invalid.
</p>

			</section>
			<section id="epochdatetimesect">
<h4 title="Epoch-Based Date/Time">3.4.2. ~epochに基づく日時</h4>

<p>
`~tag番号$
`1@tag
は、［
~UTC時刻 `1970-01-01T00:00Z^c から
`civil time^en 【常用時（地域ごとの標準時）】において表現された ある時点まで
］の秒数による値を包含する。
◎
Tag number 1 contains a numerical value counting the number of seconds from 1970-01-01T00:00Z in UTC time to the represented point in civil time.
</p>

<p>
その`~tag内容$は、
次に挙げるいずれかでなければナラナイ
— 他の型【！contained types】は`妥当$でない
⇒＃
無符号な`~integer$（`~major型$ `0$mj ）／
負な`~integer$（`~major型$ `1$mj ）／
`~float$（`~major型$ `7$mj, `追加l情報$ ~IN { `25^ai, `26^ai, `27^ai } ）
◎
The tag content MUST be an unsigned or negative integer (major types 0 and 1) or a floating-point number (major type 7 with additional information 25, 26, or 27). Other contained types are invalid.
</p>

<p>
負でない値
（`~major型$ `0$mj ／負でない`~float$）
は、
~UTC時刻 `1970-01-01T00:00Z^c 以後の時刻~値を表し，
~POSIX `TIME_T$r に則って解釈される
（~POSIX時刻は “`UNIX Epoch^en 時刻” としても知られる）。
閏秒は、
~POSIX時刻により特別に取扱われる
— その結果，十年に数回の 1 秒が挟まれる。
応用は、［
2106年初頭を超える時刻の表出を要求する場合
］には［
当の`~tag内容$用に 64 ~bit~integerの~support
］を外すわけにいかないことに注意。
◎
Nonnegative values (major type 0 and nonnegative floating-point numbers) stand for time values on or after 1970-01-01T00:00Z UTC and are interpreted according to POSIX [TIME_T]. (POSIX time is also known as "UNIX Epoch time".) Leap seconds are handled specially by POSIX time, and this results in a 1-second discontinuity several times per decade. Note that applications that require the expression of times beyond early 2106 cannot leave out support of 64-bit integers for the tag content.
</p>

<p>
負な値
（`~major型$ `1$mj ／ 負な`~float$）
は、
当の応用の要件により決定されるとおりに解釈される
— `1970-01-01T00:00Z^c より前の秒数による~UTC時刻には、
普遍的な標準は無いので
（これは，特に、
各国の暦が改暦される前の時刻が該当する）。
同じことは、
非-有限な値にも適用される。
◎
Negative values (major type 1 and negative floating-point numbers) are interpreted as determined by the application requirements as there is no universal standard for UTC count-of-seconds time before 1970-01-01T00:00Z (this is particularly true for points in time that precede discontinuities in national calendars). The same applies to non-finite values.
</p>

<p>
小数な秒は、
`~tag内容$として，
`~integer$値の代わりに`~float$値を利用することで指示できる。
一般に，これは、
`倍-精度~float$の~supportを要求することに注意
— ［
`半-精度~float$／`単-精度~float$
］は、
小数を伴う秒としては，［
1970年初頭からの短期間までの時刻
］しか供さないので。
`~tag番号$ `1$tag の~supportを要求する応用は、
当の`~tag内容$を`~integer$に限る（または`~float$に限る）よう制約することもある。
◎
To indicate fractional seconds, floating-point values can be used within tag number 1 instead of integer values. Note that this generally requires binary64 support, as binary16 and binary32 provide nonzero fractions of seconds only for a short period of time around early 1970. An application that requires tag number 1 support may restrict the tag content to be an integer (or a floating-point value) only.
</p>

<p>
日時~用の~platform型は，［
`null$i ／ `undefined$i
］値を含むこともあり、
応用~protocol~levelにおいては，それが望ましい場合もあることに注意。
`~tag番号$ `1$tag に`~tag内容$として非-有限な値を伴わせて発することは
（例：
未定義な日時~用には~NaN ／
設定されない失効~日付~用には~Infinity ），
これを取扱う明白な仕方に見えそうだが、
~tag付きでない［
`null$i ／ `undefined$i
］を利用すれば，
非-有限な値の利用を避けることに加え，符号化した結果は より短くなる。
応用~protocol設計者には、［
これらの事例を考慮して，
それらを取扱うための明瞭な指針を含める
］ことが奨励される。
◎
Note that platform types for date/time may include null or undefined values, which may also be desirable at an application protocol level. While emitting tag number 1 values with non-finite tag content values (e.g., with NaN for undefined date/time values or with Infinity for an expiry date that is not set) may seem an obvious way to handle this, using untagged null or undefined avoids the use of non-finites and results in a shorter encoding. Application protocol designers are encouraged to consider these cases and include clear guidelines for handling them.
</p>

			</section>
			<section id="bignums">
<h4 title="Bignums">3.4.3. ~bignum</h4>

<p>
`~tag番号$ ~IN {
`2@tag,
`3@tag
} を利用している~protocolは、
`汎用~data~model$を［
任意な~sizeの~integerを表現できる
`~bignum@
］で拡張する。
基本的な`汎用~data~model$においては，`~bignum$の値と`~integer$の値は等しくないが、
この~tag定義により作成される`拡張された汎用~data~model$は，等価性を数量-値に基づいて定義する
— それに選好される直列化（ `4.1§ ）は、［
基本的な`~integer$としても表出できる`~bignum$
］を用立てることは決してない（下を見よ）。
◎
Protocols using tag numbers 2 and 3 extend the generic data model (Section 2) with "bignums" representing arbitrarily sized integers. In the basic generic data model, bignum values are not equal to integers from the same model, but the extended generic data model created by this tag definition defines equivalence based on numeric value, and preferred serialization (Section 4.1) never makes use of bignums that also can be expressed as basic integers (see below).
</p>

<p>
`~bignum$の`~tag内容$は、
`~byte~string$~data~itemとして符号化され，
~network~byte順序で無符号~integer %n として解釈される。
`~tag内容$が他の型を成す場合、
`妥当$でないとする。
`~bignum$の値は、
`~tag番号$に応じて［
`2$tag ならば %n ／
`3$tag ならば −1 ~MINUS %n
］になる。
この`~byte~string$の直列化においては、
頭部を成す 0 は残さないことが選好される
（これは、［
%n ~EQ 0 用に選好される直列化は、
空な`~byte~string$になる
］ことを意味することに注意【！, but see below】）。
これらの`~tag$を解する復号器は、
頭部に 0 を伴う`~bignum$も復号-可能でなければナラナイ。
［
`~integer$のうち`~major型$ ~IN { `0$mj, `1$mj } を利用して表現できるもの
］の直列化においては、
この仕方で符号化することが選好される
— `~bignum$としてではなく
（このことは、［
選好される直列化を利用しているときは、
~bignumにおいて空な~stringは決して生じない
］ことを意味する）。
このことは、
~numberを符号化するために［
基本的な`~integer$に代えて，選好されない~bignum表現を選ぶこと
］には［
意図された応用~意味論は無い
］ことを意味することに注意
（基本的な`~integer$に必要以上に長い表現
— `00^X 用に `1800^X など —
を選ぶことが、
そうならないのと ちょうど同じく）。
◎
Bignums are encoded as a byte string data item, which is interpreted as an unsigned integer n in network byte order. Contained items of other types are invalid. For tag number 2, the value of the bignum is n. For tag number 3, the value of the bignum is -1 - n. The preferred serialization of the byte string is to leave out any leading zeroes (note that this means the preferred serialization for n = 0 is the empty byte string, but see below). Decoders that understand these tags MUST be able to decode bignums that do have leading zeroes. The preferred serialization of an integer that can be represented using major type 0 or 1 is to encode it this way instead of as a bignum (which means that the empty string never occurs in a bignum when using preferred serialization). Note that this means the non-preferred choice of a bignum representation instead of a basic integer for encoding a number is not intended to have application semantics (just as the choice of a longer basic integer representation than needed, such as 0x1800 for 0x00, does not).
</p>

<p>
例えば，
~number 18446744073709551616 （ ~POW( 2, 64 ) ）は、
次の順の並びになる
⇒＃
`110_00010^B（`~major型$ `6$mj, `~tag番号$ `2$tag ）,
`010_01001^B（`~major型$ `2$mj, 長さ 9 ）,
`010000000000000000^X （ 1 個の~byte `01^X, 8 個の~byte `00^X ）
◎
For example, the number 18446744073709551616 (264) is represented as 0b110_00010 (major type 6, tag number 2), followed by 0b010_01001 (major type 2, length 9), followed by 0x010000000000000000 (one byte 0x01 and eight bytes 0x00).＼
</p>

<p>
~hexadecimalにおいては：
◎
In hexadecimal:
</p>
<div>
<pre class="artwork">
C2                        `— ~tag 2^cmt
   49                     `— ~byte~string, 長さ 9^cmt
      010000000000000000  `— ~byte列の内容^cmt
</pre>
<pre class="_en" lang="en">
C2                        -- Tag 2
   49                     -- Byte string of length 9
      010000000000000000  -- Bytes content
</pre>
</div>

			</section>
			<section id="fractions">
<h4 title="Decimal Fractions and Bigfloats">3.4.4. ~decimal小数と~bigfloat</h4>

<p>
`~tag番号$
`4@tag
を利用している~protocolは、［［
%m ~MUL ~POW( 10, %e )
］の形を成す，任意な長さの`~decimal小数$
］を表現している~data~itemで`汎用~data~model$を拡張する。
`~tag番号$
`5@tag
を利用している~protocolは、［［
%m ~MUL ~POW( 2, %e )
］の形を成す任意な長さの~binary小数
］を表現している~data~itemで`汎用~data~model$を拡張する。
`~bignum$と同じく、
`汎用~data~model$においては，型が異なる値どうしは等しくないものとされる。
◎
Protocols using tag number 4 extend the generic data model with data items representing arbitrary-length decimal fractions of the form m*(10e). Protocols using tag number 5 extend the generic data model with data items representing arbitrary-length binary fractions of the form m*(2e). As with bignums, values of different types are not equal in the generic data model.
</p>

<p>
`~decimal小数@
（ `decimal fraction^en ）
【小数を伴う 10 進数（分母が 10 の冪乗である分数）】
は、［
~integerをとる仮数, 基数 10 の冪指数
］を組合せる。
それは、
応用が`~decimal小数$の正確な表現（ 1.1 など）を必要とする場合に，最も有用になる
— 多くの`~decimal小数$は、
~binary`~float$では正確に表現できない【循環小数になる】ので。
◎
Decimal fractions combine an integer mantissa with a base-10 scaling factor. They are most useful if an application needs the exact representation of a decimal fraction such as 1.1 because there is no exact representation for many decimal fractions in binary floating-point representations.
</p>

<p>
`~bigfloat@
は、［
~integerをとる仮数, 基数 2 の冪指数
］を組合せる。
それは、［
~CBORにより~supportされる 3 種の~IEEE754形式の［
範囲／精度
］を超過し得る~binary`~float$値である。
`~bigfloat$は、
拘束された応用
— ~IEEE754を~supportする必要なく，
何らかの基本的な~binary`~float$能力を必要とするもの —
からも利用され得る。
◎
"Bigfloats" combine an integer mantissa with a base-2 scaling factor. They are binary floating-point values that can exceed the range or the precision of the three IEEE 754 formats supported by CBOR (Section 3.3). Bigfloats may also be used by constrained applications that need some basic binary floating-point capability without the need for supporting IEEE 754.
</p>

<p>
［
`~decimal小数$／`~bigfloat$
］は、
正確に 2 個の~integer~number
— 指数 %e と仮数 %m —
を包含する~tag付き`~array$として表現される。
`~decimal小数$（`~tag番号$ `4$tag ）は、
基数 10 の指数を利用する
— その`~tag内容$【！~decimal小数~data~item】の値は、
%m ~MUL ~POW( 10, %e )
になる。
`~bigfloat$（`~tag番号$ `5$tag ）は、
基数 2 の指数を利用する
— その`~tag内容$【！~bigfloat~data~item】の値は、
%m ~MUL ~POW( 2, %e )
になる。
指数 %e は、
`~major型$ ~IN { `0$mj, `1$mj } による`~integer$で表現されなければナラナイ。
一方で，
仮数 %m は、`~bignum$にもなり得る。
`~tag内容$が他の構造を伴う場合、
当の`~tag$は`妥当$でない。
◎
A decimal fraction or a bigfloat is represented as a tagged array that contains exactly two integer numbers: an exponent e and a mantissa m. Decimal fractions (tag number 4) use base-10 exponents; the value of a decimal fraction data item is m*(10e). Bigfloats (tag number 5) use base-2 exponents; the value of a bigfloat data item is m*(2e). The exponent e MUST be represented in an integer of major type 0 or 1, while the mantissa can also be a bignum (Section 3.4.3). Contained items with other structures are invalid.
</p>

<p>
`~decimal小数$の例として，
~number 273.15 の表現は、
次の順の並びになる
⇒＃
`110_00100^B （`~major型$ `6$mj（`~tag$用）, `追加l情報$ `4^ai （`~tag番号$用））,
`100_00010^B （`~major型$ `4$mj（`~array$用）, `追加l情報$ `2^ai （`~array$の長さ用））,
`001_00001^B （`~major型$ `1$mj（ 1 個目の`~integer$用）, `追加l情報$ `1^ai （値 −2 用））,
`000_11001^B （`~major型$ `0$mj（ 2 個目の`~integer$用）, `追加l情報$ `25^ai （ 2 ~byteからなる値~用））,
`0110101010110011^B （ 2 個の~byteで 27315 ）
◎
An example of a decimal fraction is the representation of the number 273.15 as 0b110_00100 (major type 6 for tag, additional information 4 for the tag number), followed by 0b100_00010 (major type 4 for the array, additional information 2 for the length of the array), followed by 0b001_00001 (major type 1 for the first integer, additional information 1 for the value of -2), followed by 0b000_11001 (major type 0 for the second integer, additional information 25 for a two-byte value), followed by 0b0110101010110011 (27315 in two bytes).＼
</p>

<p>
~hexadecimalにおいては：
◎
In hexadecimal:
</p>

<div>
<pre class="artwork">
C4             `— ~tag 4^cmt
   82          `— ~array, 長さ 2^cmt
      21       `— −2^cmt
      19 6ab3  `— 27315^cmt
</pre>
<pre class="_en" lang="en">
C4             -- Tag 4
   82          -- Array of length 2
      21       -- -2
      19 6ab3  -- 27315
</pre>
</div>

<p>
`~bigfloat$の例として，~number 1.5 の表現は、
次の順の並びになる
⇒＃
`110_00101^B（`~major型$ `6$mj（`~tag$用）, `追加l情報$ `5^ai （`~tag番号$用））,
`100_00010^B（`~major型$ `4$mj（`~array$用）, `追加l情報$ `2^ai （`~array$の長さ用））,
`001_00000^B（`~major型$ `1$mj（ 1 個目の`~integer$用）, `追加l情報$ `0^ai （値 −1 用））,
`000_00011^B（`~major型$ `0$mj（ 2 個目の`~integer$用）, `追加l情報$ `3^ai （値 3 用））
◎
An example of a bigfloat is the representation of the number 1.5 as 0b110_00101 (major type 6 for tag, additional information 5 for the tag number), followed by 0b100_00010 (major type 4 for the array, additional information 2 for the length of the array), followed by 0b001_00000 (major type 1 for the first integer, additional information 0 for the value of -1), followed by 0b000_00011 (major type 0 for the second integer, additional information 3 for the value of 3).＼
</p>

<p>
~hexadecimalにおいては：
◎
In hexadecimal:
</p>
<div>
<pre class="artwork">
C5             `— ~tag 5^cmt
   82          `— ~array, 長さ 2^cmt
      20       `— −1^cmt
      03       `— 3^cmt
</pre>
<pre class="_en" lang="en">
C5             -- Tag 5
   82          -- Array of length 2
      20       -- -1
      03       -- 3
</pre>
</div>

<p>
［
`~decimal小数$／`~bigfloat$
］は、［
~Infinity, −~Infinity, ~NaN
］の表現を供さない
— ［
`~decimal小数$／`~bigfloat$
］が占める所に これらが必要になる場合、
~IEEE754`半-精度$表現を利用できる。
◎
Decimal fractions and bigfloats provide no representation of Infinity, -Infinity, or NaN; if these are needed in place of a decimal fraction or bigfloat, the IEEE 754 half-precision representations from Section 3.3 can be used.
</p>

			</section>
			<section id="content-hints">
<h4 title="Content Hints">3.4.5. 内容~hint</h4>

<p>
この節に挙げる`~tag$は、
内容~hint用であり，
汎用な~CBOR処理器により利用されるかもしれない。
これらの内容~hintは、
`汎用~data~model$を拡張しない。
◎
The tags in this section are for content hints that might be used by generic CBOR processors. These content hints do not extend the generic data model.
</p>

				<section id="embedded-di">
<h5 title="Encoded CBOR Data Item">3.4.5.1. 符号化された~CBOR~data~item</h5>

<p>
ときには、
ある~data~itemを “埋込まれたもの”
— それを封入している~data~itemが復号される時点で，即時に復号することは、
意味されないもの —
として運ぶことが有益になる。
`~tag番号$
`24@tag
（~CBOR~data~item）は、［
~CBOR形式に符号化された 1 個の~data~itemとして埋込まれた`~byte~string$
］を~tag付けるために利用できる。
当の`~tag$は、［
`~tag内容$が`~byte~string$を成していて，
ある`整形式$な`~data~item$を符号化している
］ならば`妥当$になり，そうでなければ`妥当$でない。
`~tag内容$を復号した結果の`~data~item$に対し妥当性を検査することは、
`~tag$が`妥当$になるためには要求されない
（が，汎用な復号器は、
そのような検査を，ある特別な~optionとして提供することもできる）。
◎
Sometimes it is beneficial to carry an embedded CBOR data item that is not meant to be decoded immediately at the time the enclosing data item is being decoded. Tag number 24 (CBOR data item) can be used to tag the embedded byte string as a single data item encoded in CBOR format. Contained items that aren't byte strings are invalid. A contained byte string is valid if it encodes a well-formed CBOR data item; validity checking of the decoded CBOR item is not required for tag validity (but could be offered by a generic decoder as a special option).
</p>

				</section>
				<section id="convexpect">
<h5 title="Expected Later Encoding for CBOR-to-JSON Converters">3.4.5.2. ~CBORから~JSONへの変換器に期待される，後で行う符号化</h5>

<p>
`~tag番号$ ~IN { `21$tag, `22$tag, `23$tag } は、［
~textに基づく表現で相互運用するとき，
【`~tag内容$を成す】`~byte~string$には特定の符号化法が要求されるかもしれない
］ことを指示する。
これらの`~tag$は、
符号化器が［
自身が書込んでいる`~byte~string$~dataは、
後で，~JSONに基づく特定0の用法に変換されると見込まれる
］ことを知るとき，有用になる。
その用法は、
何らかの~stringが［
~base64, ~base64url, 等々
］として符号化されることを指定する。
符号化器は、
符号化~自体を行う代わりに`~byte~string$を利用して，［
~message~size／符号化器の~code~size
］を抑制する。
符号化器は，変換器が汎用かどうかを知らないので、
~binary~stringを~JSONへ変換する仕方として，
何が適正になると予見するかを伝えたいと求める。
◎
Tag numbers 21 to 23 indicate that a byte string might require a specific encoding when interoperating with a text-based representation. These tags are useful when an encoder knows that the byte string data it is writing is likely to be later converted to a particular JSON-based usage. That usage specifies that some strings are encoded as base64, base64url, and so on. The encoder uses byte strings instead of doing the encoding itself to reduce the message size, to reduce the code size of the encoder, or both. The encoder does not know whether or not the converter will be generic, and therefore wants to say what it believes is the proper way to convert binary strings to JSON.
</p>

<p>
`~tag内容$は、
`~byte~string$にも他の~data~itemにもなり得る。
後者の事例では、
当の`~tag$は，［
当の~data~itemに包含される各`~byte~string$~data~item
］すべてに適用される
— ある［
`期待され$る変換を指示する`~tag$
］の`~tag内容$として入子にされたものは除いて。
◎
The data item tagged can be a byte string or any other data item. In the latter case, the tag applies to all of the byte string data items contained in the data item, except for those contained in a nested data item tagged with an expected conversion.
</p>

<div>
<p>
これら 3 種の`~tag番号$は、
次に挙げる符号化法への変換を示唆する：
</p>
<ul>
	<li>
`21@tag
は、
~base64url
（ `RFC4648$r `§ 5＠~RFCx/rfc4648#section-5$ ）
</li>
	<li>
`22@tag
は、
古典的な~base64
（ `RFC4648$r `§ 4＠~RFCx/rfc4648#section-4$ ）
</li>
	<li>
`23@tag
は、
~base16
（~hexとも呼ばれる）
（ `RFC4648$r `§ 8＠~RFCx/rfc4648#section-8$ ）
（これは、大文字 A 〜 F を利用する）
</li>
</ul>

<p>
ここで：
</p>
<ul>
	<li>
~base64urlにおいては、
補充~文字（等号 "`=^c" ）は利用されない
（ `RFC4648$r `§ 3.2＠~RFCx/rfc4648#section-3.2$ を見よ）
— すなわち、
尾部にある それらは，符号化された~stringからは除去される。
</li>
	<li>
~base64においては、
~RFC 4648 にて定義されるとおりの補充~文字を伴う。
</li>
	<li>
［
~base64url／~base64
］用の補充~bitは、
すべて 0 に設定される
（ `RFC4648$r `§ 3.5＠~RFCx/rfc4648#section-3.5$ を見よ）。
</li>
</ul>

<p>
これら~base-符号化法への変換は、
いずれも，当の`~byte~string$の内容に対し遂行され
（すなわち，［
改行／空白／その他の追加的な文字
］を追加しない）、
空な`~byte~string$を符号化した結果は，空な`~text~string$になることにも注意。
</p>

◎
These three tag numbers suggest conversions to three of the base data encodings defined in [RFC4648].＼
Tag number 21 suggests conversion to base64url encoding (Section 5 of [RFC4648])＼
where padding is not used (see Section 3.2 of [RFC4648]); that is, all trailing equals signs ("=") are removed from the encoded string.＼
Tag number 22 suggests conversion to classical base64 encoding (Section 4 of [RFC4648])＼
with padding as defined in RFC 4648.＼
For both base64url and base64, padding bits are set to zero (see Section 3.5 of [RFC4648]),＼
and the conversion to alternate encoding is performed on the contents of the byte string (that is, without adding any line breaks, whitespace, or other additional characters).＼
Tag number 23 suggests conversion to base16 (hex) encoding with uppercase alphabetics (see Section 8 of [RFC4648]).＼
Note that, for all three tag numbers, the encoding of the empty byte string is the empty text string.
</div>

				</section>
				<section id="encodedtext">
<h5 title="Encoded Text">3.4.5.3. 符号化された~text</h5>

<p>
一部の`~text~string$は、
~Internet上で広く利用されている形式による~dataを保持する
— これらの形式は，ときには、
復号器により［
検証され，適切な形で応用に呈示される
］こともある。
これらの形式のうち一部には、
それ用の`~tag$がある。
◎
Some text strings hold data that have formats widely used on the Internet, and sometimes those formats can be validated and presented to the application in appropriate form by the decoder. There are tags for some of these formats.
</p>
<ul>
	<li>
`~tag番号$
`32@tag
は、［
`RFC3986$r にて定義される~URI
］用である。
当の`~text~string$が `URI-reference^P 生成規則に合致しない場合、
それは`妥当$でない。
◎
Tag number 32 is for URIs, as defined in [RFC3986]. If the text string doesn't match the URI-reference production, the string is invalid.
</li>
	<li>
<p>
`~tag番号$［
`33@tag
／
`34@tag
］は、
`RFC4648$r にて定義される［
~base64url／~base64
］に符号化された`~text~string$用にある。
◎
Tag numbers 33 and 34 are for base64url- and base64-encoded text strings, respectively, as defined in [RFC4648].＼
</p>

<p>
次に挙げるいずれかに該当する場合、
当の~stringは`妥当$でない：
◎
If any of the following apply:
</p>
		<ul>
			<li>
<p>
符号化された`~text~string$を成す最後の 4 文字~blockが：
</p>
				<ul>
					<li>
［
0 個／ 1 個
］の~alphabet文字を包含している
</li>
					<li>
［
2 個／ 3 個
］の~alphabet文字を包含していて，
~block内の補充~bitに 0 でないものがある
</li>
				</ul>

<p>
（ `~tag番号$［
`33$tag ／ `34$tag
］用の~alphabetは、
`RFC4648$r ［
`§ 5＠~RFCx/rfc4648#section-5$ ／
`§ 4＠~RFCx/rfc4648#section-4$
］にて定義される）。
</p>

◎
the encoded text string contains non-alphabet characters or only 1 alphabet character in the last block of 4 (where alphabet is defined by Section 5 of [RFC4648] for tag number 33 and Section 4 of [RFC4648] for tag number 34), or
◎
the padding bits in a 2- or 3-character block are not 0, or
</li>
			<li>
~base64符号化において、
補充~文字（ "`=^c" ）の個数が間違っている
◎
the base64 encoding has the wrong number of padding characters, or
</li>
			<li>
~base64url符号化において、
補充~文字が在る
◎
the base64url encoding has padding characters,
◎
↑↑the string is invalid.
</li>
		</ul>
	</li>
	<li>
<p>
`~tag番号$
`36@tag
は、
 `RFC2045$r にて定義される
~MIME~message（すべての~headerも含む）用にある。
妥当な~MIME~messageでない`~text~string$は、
`妥当$でない。
◎
Tag number 36 is for MIME messages (including all headers), as defined in [RFC2045]. A text string that isn't a valid MIME message is invalid.＼
</p>

<p>
（この`~tag$用の妥当性~検査ngは、
汎用な復号器にとっては特に面倒になり得るので，提供されないかもしれない。
多くの~MIME~messageは、
一般な~binary~dataなので，`~text~string$では表現し得ないことに注意
— `IANA.cbor-tags$r は、`~tag番号$ `257^tag 用の登録を~listする
— それは、`~tag番号$ `36$tag に類似するが，その`~tag内容$として`~byte~string$を利用する。）
◎
(For this tag, validity checking may be particularly onerous for a generic decoder and might therefore not be offered. Note that many MIME messages are general binary data and therefore cannot be represented in a text string; [IANA.cbor-tags] lists a registration for tag number 257 that is similar to tag number 36 but uses a byte string as its tag content.)
</p>
	</li>
</ul>

<p>
`~tag番号$ ~IN { `33$tag, `34$tag } は，
`~tag内容$【！当の~data】が~base-符号化された形で~transportされる一方、
`~tag番号$ ~IN { `21$tag, `22$tag } は，
生な`~byte~string$の形で~transportされることに注意。
◎
Note that tag numbers 33 and 34 differ from 21 and 22 in that the data is transported in base-encoded form for the former and in raw byte string form for the latter.
</p>

<p>
`RFC7049$r は、［［
~PCRE／~PCRE2
］（ `Perl Compatible Regular Expressions^en ／ Perl 互換な正規表現 ） `PCRE$r ／
~JS正規表現~構文 `ECMA262$r 
］による正規表現~用に`~tag番号$ `35^tag も定義した。
これらの正規表現の最先端な仕様は，［
その頃から進歩した／断続的に進歩している
］ので、
この仕様は，当の参照を更新しようと試みない。
代わりに，この`~tag$は［
それらが帯域外に利用する，特定0の正規表現~変種
］を指定する応用~用に可用であり続ける
（ `RFC7049$r にて登録されたとおり）
（場合によっては、
その用法を［
~PCRE, ~ECMA262
］両者に定義される共通な下位集合に制限することにより）。
この仕様は，［
`RFC7049$r を超える~tagの妥当性
］を明確化するので、
この~tagが `RFC7049$r にて定義された~openな仕方に因り，
その`~tag内容$を成す【！contained】~string値も~CBOR~tag~levelにおいて`妥当$になる必要があることに注意
（応用~levelでは、
`期待され$ないものになり得るが）。
◎
[RFC7049] also defined a tag number 35 for regular expressions that are in Perl Compatible Regular Expressions (PCRE/PCRE2) form [PCRE] or in JavaScript regular expression syntax [ECMA262]. The state of the art in these regular expression specifications has since advanced and is continually advancing, so this specification does not attempt to update the references. Instead, this tag remains available (as registered in [RFC7049]) for applications that specify the particular regular expression variant they use out-of-band (possibly by limiting the usage to a defined common subset of both PCRE and ECMA262). As this specification clarifies tag validity beyond [RFC7049], we note that due to the open way the tag was defined in [RFC7049], any contained string value needs to be valid at the CBOR tag level (but then may not be "expected" at the application level).
</p>

				</section>
			</section>
			<section id="self-describe">
<h4 title="Self-Described CBOR">3.4.6. 自己を記述する~CBOR</h4>

<p>
多くの応用では、［
ある~data~itemを符号化するために~CBORが使役されていること
］は，文脈から明瞭になる。
一例として，［
特定の~protocolは、
~CBORの利用を指定するかもしれない／
ある~MIME型は、
~CBORの利用を指定することを指示した
］。
しかしながら，応用によっては、
そのような文脈~情報は可用でないこともある
— ［
【どの形式か】一義化するための~metadataを伴わない~file
］内に~CBOR~dataが格納されたときなど。
そのような所では、［
当の~data自身を判別するための，何らかの特徴
］があると助けになろう。
◎
In many applications, it will be clear from the context that CBOR is being employed for encoding a data item. For instance, a specific protocol might specify the use of CBOR, or a media type is indicated that specifies its use. However, there may be applications where such context information is not available, such as when CBOR data is stored in a file that does not have disambiguating metadata. Here, it may help to have some distinguishing characteristics for the data itself.
</p>

<p>
`~tag番号$
`55799@tag
は、
この目的~用に定義される
— 特定的に、［
ある応用により指定されるとおりに，
ある格納-済みな`符号化された~data~item$の開始に利用する
］ために。
この`~tag$は、
その`~tag内容$【！data item that it encloses】には，特別な意味論を何も添えない
— すなわち、
この`~tag$に封入された`~tag内容$の意味論は，当の内容~自身の意味論に正確に一致する。
◎
Tag number 55799 is defined for this purpose, specifically for use at the start of a stored encoded CBOR data item as specified by an application. It does not impart any special semantics on the data item that it encloses; that is, the semantics of the tag content enclosed in tag number 55799 is exactly identical to the semantics of the tag content itself.
</p>

<p>
この`~tag$の`~head$の直列化は `bf7^X になる。
それは、［
頻繁に利用される~file型において，利用-中にある判別-用の~mark
］として現れることはない。
特に， `d9d9f7^X は、
`妥当$な`~data~item$が後続するならば，［
~Unicode†に符号化された~Unicode~textの妥当な開始
］にはならない。
【† ~UTF-8のみならず， UTF-16 においても（ `d9d9^X は~surrogate符号位置になるので）】
◎
The serialization of this tag's head is 0xd9d9f7, which does not appear to be in use as a distinguishing mark for any frequently used file types. In particular, 0xd9d9f7 is not a valid start of a Unicode text in any Unicode encoding if it is followed by a valid CBOR data item.
</p>

<p>
一例として、
~CBOR, ~JSON
どちらも復号-可能な復号器もあるかもしれない。
そのような復号器は、
この 2 つの形式を機械的に判別する必要があろう。
符号化器が，そのような復号器を助ける容易な仕方は、［
当の`~data~item$全体を`~tag番号$ `55799$tag で~tag付ける
］ことになろう
— この直列化が，~JSON~textの始めに見出されることは、決してない。
◎
For instance, a decoder might be able to decode both CBOR and JSON. Such a decoder would need to mechanically distinguish the two formats. An easy way for an encoder to help the decoder would be to tag the entire CBOR item with tag number 55799, the serialization of which will never be found at the beginning of a JSON text.
</p>

			</section>
		</section>
	</section>
	<section id="serialization-considerations">
<h2 title="Serialization Considerations">4. 直列化の考慮点</h2>

		<section id="preferred">
<h3 title="Preferred Serialization">4.1. 選好される直列化</h3>

<p>
~CBORは、
~data~model~levelにおける一部の値に対し，複数種の直列化を供する。
多くの応用に対しては、
符号化器は，常に選好される直列化（選好される符号化法）を選ぶことが望ましい
— しかしながら，~CBORの現~versionは、［
符号化器, 復号器
］どちらにも，この選好を施行する負担を課さない。
◎
For some values at the data model level, CBOR provides multiple serializations. For many applications, it is desirable that an encoder always chooses a preferred serialization (preferred encoding); however, the present specification does not put the burden of enforcing this preference on either the encoder or decoder.
</p>

<p>
一部の拘束された復号器は、
選好されない直列化を復号する能が制限され得る
— 例えば，
ある応用にて`期待され$る`~integer$が 1000000000 （ 10 億）未満に限られる場合、
当の復号器は［
`~integer$における 64 ~bit`引数$を復号するために必要になる~code
］を外すこともあろう。
ある符号化器が，選好される直列化（ “選好される符号化器” ）を常に利用する場合、
この応用において生じ得る~numberは，この復号器と相互運用する。
選好される符号化器は、
一般に，より普遍的に
— 例えば，常に 64 ~bit`~integer$を利用するものよりも —
相互運用可能になる
（また、無駄にもなりにくい）。
◎
Some constrained decoders may be limited in their ability to decode non-preferred serializations: for example, if only integers below 1_000_000_000 (one billion) are expected in an application, the decoder may leave out the code that would be needed to decode 64-bit arguments in integers. An encoder that always uses preferred serialization ("preferred encoder") interoperates with this decoder for the numbers that can occur in this application. Generally speaking, a preferred encoder is more universally interoperable (and also less wasteful) than one that, say, always uses 64-bit integers.
</p>

<p>
類似に，拘束された符号化器は、
自身が~supportする表現~変種の多様さが制限されることもある
— 選好される直列化を発しないなど（ “変種~符号化器” ）。
一例として，ある拘束された符号化器は、
自身が符号化する`~integer$用には［
短い表現が可用な場合でも，常に 32 ~bit変種を利用する
］よう設計されることもあろう
（ 64 ~bit変種でしか表現し得ない`~integer$を必要とする応用は無いと見做すならば）。
したがって，
復号器のうち［
選好される直列化に限り受信する
］ことには依拠しないもの（ “多様性に寛容な復号器” ）は、
より普遍的に相互運用可能になると言える
（それは、
選好される直列化を受信している事例に対しては，
かなり上手く最適化できるかもしれないが）。
~CBOR復号器の全部的な実装は、
定義により，多様性に寛容である
— その区別が関連するのは、［
~CBOR復号器の拘束された実装が，変種~符号化器に出会った場合
］に限られる。
◎
Similarly, a constrained encoder may be limited in the variety of representation variants it supports such that it does not emit preferred serializations ("variant encoder"). For instance, a constrained encoder could be designed to always use the 32-bit variant for an integer that it encodes even if a short representation is available (assuming that there is no application need for integers that can only be represented with the 64-bit variant). A decoder that does not rely on receiving only preferred serializations ("variation-tolerant decoder") can therefore be said to be more universally interoperable (it might very well optimize for the case of receiving preferred serializations, though). Full implementations of CBOR decoders are by definition variation tolerant; the distinction is only relevant if a constrained implementation of a CBOR decoder meets a variant encoder.
</p>

<p>
選好される直列化は、
`引数$【！`3§ 】を表現するときに，常に最短な形を利用する。
それはまた、
`~float$の符号化法として［
符号化されている値を保全する最短な形
］を利用する。
◎
The preferred serialization always uses the shortest form of representing the argument (Section 3); it also uses the shortest floating-point encoding that preserves the value being encoded.
</p>

<p>
`~float$値用に選好される直列化は、
その値を保全する最短な`~float$に符号化することである
— 例：
~number 5.5 用には `f94580^X 【`半-精度$】／
~number 5555.5 用には `fa45ad9c00^X 【`倍-精度$】。
各種~NaN値に対しても、
符号化が短くなる方が選好される
— より短い方において、
仮数部の右側を~bit 0 で補充することにより，元の~NaN値を~~再構成できるならば
（多くの応用~用には、
単独の~NaN符号化 `f97e00^X 【`半-精度$】で足りる）。
【例：`倍-精度$ ~NaNは、等価な［`単-精度$／`半-精度$］~NaNが在るならば，それらのうち最短なものに符号化する。】
◎
The preferred serialization for a floating-point value is the shortest floating-point encoding that preserves its value, e.g., 0xf94580 for the number 5.5, and 0xfa45ad9c00 for the number 5555.5. For NaN values, a shorter encoding is preferred if zero-padding the shorter significand towards the right reconstitutes the original NaN value (for many applications, the single NaN encoding 0xf97e00 will suffice).
</p>

<p>
当の~itemの直列化を開始した時点で長さが既知であるときには、
`確定長$な符号化法が選好される。
◎
Definite-length encoding is preferred whenever the length is known at the time the serialization of the item starts.
</p>

		</section>
		<section id="det-enc">
<h3 title="Deterministically Encoded CBOR">4.2. 決定論的に符号化された~CBOR</h3>

<p>
一部の~protocolは、［
符号化器が発する~CBORは、特定0の決定論的な形式に限る
］よう求めることもあろう
— そのような~protocolは、
復号器も［
入力が，その決定論的な形式かどうか検査する
］よう求めるかもしれない。
そのような~protocolは、［
“決定論的な形式” が何を意味するか，どの［
符号化器／復号器
］が，それを行うものと`期待され$るか
］を定義してもかまわない。
この節は、［
そのような決定論的な形式の基底として~serveし得る，一群の制約
］を定義する。
◎
Some protocols may want encoders to only emit CBOR in a particular deterministic format; those protocols might also have the decoders check that their input is in that deterministic format. Those protocols are free to define what they mean by a "deterministic format" and what encoders and decoders are expected to do. This section defines a set of restrictions that can serve as the base of such a deterministic format.
</p>

			<section id="core-det">
<h4 title="Core Deterministic Encoding Requirements">4.2.1. 決定論的な符号化法の中核~要件</h4>

<p>
~CBOR符号化法は、
次に挙げる制約を満足するならば，
`決定論的な符号化法の中核~要件@
（ `Core Deterministic Encoding Requirements^en ）
を満足するとされる：
◎
A CBOR encoding satisfies the "core deterministic encoding requirements" if it satisfies the following restrictions:
</p>
<ul>
	<li>
<p>
選好される直列化を利用しなければナラナイ。
このことは特に，［
`7$mj 以外の`~major型$
］用の`引数$【！（ `3§ を見よ）】
（`~integer$／［
~string, `~map$, `~array$
］の長さ／`~tag番号$）
は、
アリな限り短くしなければナラナイことを意味する。
一例として：
◎
Preferred serialization MUST be used. In particular, this means that arguments (see Section 3) for integers, lengths in major types 2 through 5, and tags MUST be as short as possible, for instance:
</p>
		<ul>
			<li>
次の範囲に入るものは、
`先頭~byte$【！the same byte as the major type】内に表出しなければナラナイ
⇒＃
{ 0 〜 23 },
{ −1 〜 −24 }
◎
0 to 23 and -1 to -24 MUST be expressed in the same byte as the major type;
</li>
			<li>
次の範囲に入るものは、
追加的な ~uint8_t のみで表出しなければナラナイ
⇒＃
{ 24 〜 255 },
{ −25 〜 −256 }
◎
24 to 255 and -25 to -256 MUST be expressed only with an additional uint8_t;
</li>
			<li>
次の範囲に入るものは、
追加的な ~uint16_t のみで表出しなければナラナイ
⇒＃
{ 256 〜 65535 },
{ −257 〜 −65536 }
◎
256 to 65535 and -257 to -65536 MUST be expressed only with an additional uint16_t;
</li>
			<li>
次の範囲に入るものは、
追加的な~uint32_t のみで表出しなければナラナイ
⇒＃
{ 65536 〜 4294967295 },
{ −65537 〜 −4294967296 }
◎
65536 to 4294967295 and -65537 to -4294967296 MUST be expressed only with an additional uint32_t.
</li>
		</ul>

<p>
`~float$値（`~major型$ `7$mj ）は、
当の値を保全する最短な形を利用しなければナラナイ
— 例：
1.5 は `f93e00^X （`半-精度~float$）として，
1000000.5 は `fa49742408^X （`単-精度~float$）として
符号化される。
（これの実装を成す一つは、
すべての`~float$を`倍-精度~float$とすることから開始して，
`単-精度~float$への変換を~testすることである
— 結果が同じ数量-値になる場合、
より短い形を利用して，次は`半-精度~float$への変換を~testする。
これは、［
正な~Infinity／負な~Infinity
］用に`半-精度~float$を選定するときも働く。）
◎
Floating-point values also MUST use the shortest form that preserves the value, e.g., 1.5 is encoded as 0xf93e00 (binary16) and 1000000.5 as 0xfa49742408 (binary32). (One implementation of this is to have all floats start as a 64-bit float, then do a test conversion to a 32-bit float; if the result is the same numeric value, use the shorter form and repeat the process with a test conversion to a 16-bit float. This also works to select 16-bit float for positive and negative Infinity as well.)
</p>
	</li>
	<li>
`不定長$な~itemは、
現れてはナラナイ
— それは、
`確定長$な~itemとして符号化できるので。
◎
Indefinite-length items MUST NOT appear. They can be encoded as definite-length items instead.
</li>
	<li>
<p>
`~map$内の`~key$は、
各`~key$を決定論的に符号化した結果において，
~byteごとの辞書式~順序で~sortしなければナラナイ。
◎
The keys in every map MUST be sorted in the bytewise lexicographic order of their deterministic encodings.＼
</p>

<p>
例えば，次に挙げる`~key$は、
正しく~sortされている（括弧内は符号化した結果）：
◎
For example, the following keys are sorted correctly:
</p>
		<ol>
			<li>
10
（ `0a^X ）
◎
10, encoded as 0x0a.
</li>
			<li>
100
（ `1864^X ）
◎
100, encoded as 0x1864.
</li>
			<li>
−1
（ `20^X ）
◎
-1, encoded as 0x20.
</li>
			<li>
"z"
（ `617a^X ）
◎
"z", encoded as 0x617a.
</li>
			<li>
"aa"
（ `626161^X ）
◎
"aa", encoded as 0x626161.
</li>
			<li>
[100]
（ `811864^X ）
◎
[100], encoded as 0x811864.
</li>
			<li>
[−1]
（ `8120^X ）
◎
[-1], encoded as 0x8120.
</li>
			<li>
`false$i
（ `f4^X ）
◎
false, encoded as 0xf4.
</li>
		</ol>
	</li>
</ul>

<p class="note">実装~向け注記：
~CBOR符号化法の自己を区切る資質は、［
`整形式$な`~data~item$が，別のそれの接頭辞を成すことは無い
］ことを意味する。
したがって，異なる`~map~key$どうしの［
決定論的な符号化法における~byteごとの辞書式~比較
］は、
常に，どちらかの`~key$の終端に達する前の位置
— `~key$どうしで最初に~byteが相違する位置 —
で終端する。
◎
Implementation note: the self-delimiting nature of the CBOR encoding means that there are no two well-formed CBOR encoded data items where one is a prefix of the other. The bytewise lexicographic comparison of deterministic encodings of different map keys therefore always ends in a position where the byte differs between the keys, before the end of a key is reached.
</p>

			</section>
			<section id="additional-deterministic-encoding-considerations">
<h4 title="Additional Deterministic Encoding Considerations">4.2.2. 決定論的な符号化法に対する追加的な考慮点</h4>

<p>
~CBOR`~tag$には、
決定論的な符号化法に対する追加的な考慮点がある。
~CBORに基づく ある~protocolが，特定の`~tag$に対し［
所与の~data~itemを その~tagに封入してもしなくても同じ意味論を供する
］ものとした場合
（例：
ある日時~用の~dataが占める位置において［
`~tag番号$【！~tag】 `1$tag を伴う`~tag内容$【！~data~item】,
生な~number
］両者を
— 後者を~tag付きであるかのように扱って —
許容することにより）、
当の決定論的な形式は，
“最短な形” の原則に基づいて，~tag付きを許容しないことになる。
例えば，ある~protocolは、
~URLを［
`~text~string$,
`~text~string$を包含している`~tag番号$ `32$tag【！ `3.4.5.3§】
］どちらかとして表現する選択肢を符号化器に与えるかもしれない。
この~protocolの決定論的な符号化法は、
当の~tagを［
一律に利用すること, 一律に利用しないこと
］どちらかを要求する必要がある。
◎
CBOR tags present additional considerations for deterministic encoding. If a CBOR-based protocol were to provide the same semantics for the presence and absence of a specific tag (e.g., by allowing both tag 1 data items and raw numbers in a date/time position, treating the latter as if they were tagged), the deterministic format would not allow the presence of the tag, based on the "shortest form" principle. For example, a protocol might give encoders the choice of representing a URL as either a text string or, using Section 3.4.5.3, tag number 32 containing a text string. This protocol's deterministic encoding needs either to require that the tag is present or to require that it is absent, not allow either one.
</p>

<p>
ある~protocolにおいて［
ある種の箇所における`~tag$は、
特定の意味論を得すること
］が要求される場合、
当の~tagは，決定論的な形式においても現れる必要がある。
決定論的な符号化法の考慮点は、
`~tag内容$にも適用される。
◎
In a protocol that does require tags in certain places to obtain specific semantics, the tag needs to appear in the deterministic format as well. Deterministic encoding considerations also apply to the content of tags.
</p>

<p>
ある~protocolが含むある~fieldが［
絶対~値が ~POW( 2, 64 ) 以上になる`~integer$
］を`~tag番号$ ~IN { `2$tag, `3$tag } を利用して表出し得る場合、
当の~protocolの決定論的な符号化法は、
より小さい他の`~integer$が［
これらの`~tag$, `~major型$ ~IN { `0$mj, `1$mj }
］どちらを利用して表出されるかも指定する必要がある
— 選好される直列化は，後者を利用するので、
後者を選ぶ方が推奨される。
◎
If a protocol includes a field that can express integers with an absolute value of 264 or larger using tag numbers 2 or 3 (Section 3.4.3), the protocol's deterministic encoding needs to specify whether smaller integers are also expressed using these tags or using major types 0 and 1. Preferred serialization uses the latter choice, which is therefore recommended.
</p>

<p>
~protocolは、［
基本的な`~float$値／`~tag$
］（または，この両者）を利用して表現される`~float$値を含む場合、
自身の決定論的な符号化法について，~~追加の要件を定義する必要があろう
— 次に挙げるものなど：
◎
Protocols that include floating-point values, whether represented using basic floating-point values (Section 3.3) or using tags (or both), may need to define extra requirements on their deterministic encodings, such as:
</p>
<ul>
	<li>
~IEEE754【！~IEEE】`~float$値は，［
正な 0, 負な 0 
］を別個な値として表現できるが、
応用は，これらを判別しないものと
— すなわち、負な 0 を許容せず，すべての 0 値を正な正負符号で表現するものと —
裁定するかもしれない。
（当の応用は、
`~float$値の精度を［
`倍-精度~float$値で
— あるいは，`単-精度~float$値でも —
表現する必要は，決して無い仕方
］で制約したいと求めることもあろう。）
◎
Although IEEE floating-point values can represent both positive and negative zero as distinct values, the application might not distinguish these and might decide to represent all zero values with a positive sign, disallowing negative zero. (The application may also want to restrict the precision of floating-point values in such a way that there is never a need to represent 64-bit -- or even 32-bit -- floating-point values.)
</li>
	<li>
<p>
ある~protocolが含む ある~fieldが［［
`~integer$と`~float$値は交換-可能である
］ものと宣言するような，特定の~data~model
］で`~float$値を表出し得る場合、
当の~protocolの決定論的な符号化法は，
`~integer$（例： 1.0 ）を［
無符号`~integer$（例： `01^X ）,
`半-精度~float$（例： `f93c00^X ）,
`単-精度~float$（例： `fa3f800000^X ）,
`倍-精度~float$（例： `fb3ff0000000000000^X ）
］のうち どれに符号化するかを指定する必要がある。
これ用の規則の例は：
◎
If a protocol includes a field that can express floating-point values, with a specific data model that declares integer and floating-point values to be interchangeable, the protocol's deterministic encoding needs to specify whether, for example, the integer 1.0 is encoded as 0x01 (unsigned integer), 0xf93c00 (binary16), 0xfa3f800000 (binary32), or 0xfb3ff0000000000000 (binary64). Example rules for this are:
</p>
		<ul>
			<li>
規則 (1)
⇒
64 ~bitに収まる~integerに等しいものは、［
`~major型$ ~IN { `0$mj, `1$mj } による値
］として符号化する。
他の値は、
当の値を正確aかつ（［
`半-精度$, `単-精度$, `倍-精度$
］いずれかにより）
最も短く表現するような，選好される`~float$表現として符号化する。
◎
Encode integral values that fit in 64 bits as values from major types 0 and 1, and other values as the preferred (smallest of 16-, 32-, or 64-bit) floating-point representation that accurately represents the value,
</li>
			<li>
規則 (2)
⇒
すべての値を
— それが ある~integerに等しい場合でも —
当の値を正確aに表現するような，選好される`~float$表現として符号化する
◎
Encode all values as the preferred floating-point representation that accurately represents the value, even for integral values, or
</li>
			<li>
規則 (3)
⇒
すべての値を`倍-精度~float$表現として符号化する。
◎
Encode all values as 64-bit floating-point representations.
</li>
		</ul>

<p>
規則 (1) は、［
`~integer$値と`~float$値
］の境界をどっちつかずにする。
規則 (3) は、
選好される直列化を利用しない。
なので、
多くの事例では，規則 (2) が良い選択肢になろう。
◎
Rule 1 straddles the boundaries between integers and floating-point values, and Rule 3 does not use preferred serialization, so Rule 2 may be a good choice in many cases.
</p>
	</li>
	<li>
~NaNは許容される値であって［
`NaN payload^en 【当の~NaN内の “診断用の情報” を与える~bit列】 ／
`signaling NaN^en 【例外を生じさせる~NaN】
］を~supportする意図は無い場合、
当の~protocolは，
単独の表現
— 概して `f97e00^X —
に絞る必要がある。
そのような単純な選択肢はアリでない場合、
~NaNを取扱うために特有な注意が必要になる。
◎
If NaN is an allowed value, and there is no intent to support NaN payloads or signaling NaNs, the protocol needs to pick a single representation, typically 0xf97e00. If that simple choice is not possible, specific attention will be needed for NaN handling.
</li>
	<li>
~subnormal~number
（ 0 でない~numberのうち，［
所与の~IEEE754~number形式においてアリな指数
］が最低なものを伴うもの
【仮数が 1 以上になるよう正規化し得ないほど 0 に近い~number】）
は、
一部の`~float$実装においては［
0 化されて出力される／
入力されたときは 0 として扱われる
］こともある。
~protocolの決定論的な符号化法は、
そのような実装を特定的に収容するためとして，他の実装に対し［
~subnormal~numberを交換から除外して，代わりに 0 を交換する
］~~責任を課したいと求めることもあろう。
◎
Subnormal numbers (nonzero numbers with the lowest possible exponent of a given IEEE 754 number format) may be flushed to zero outputs or be treated as zero inputs in some floating-point implementations. A protocol's deterministic encoding may want to specifically accommodate such implementations while creating an onus on other implementations by excluding subnormal numbers from interchange, interchanging zero instead.
</li>
	<li>
同じ~numberは、
［
異なる`~decimal小数$／
異なる`~bigfloat$／
［
数量-値も表出し得るように定義された他の`~tag$
］の下で，異なる形
］により表現し得る。
［
これらの形（または基本的な`汎用~data~model$における各~形）のうち，どれが等価になるか
］を決定することは、
実装に依存して，常に実用的になるとは限らない。
応用~protocolのうち［
~numberの表現~形式~用に，この種類の選択肢を呈示するもの
］は、［
決定論的な符号化法~用の形式を どう選ぶか
］について，明示的に与える必要がある。
◎
The same number can be represented by different decimal fractions, by different bigfloats, and by different forms under other tags that may be defined to express numeric values. Depending on the implementation, it may not always be practical to determine whether any of these forms (or forms in the basic generic data model) are equivalent. An application protocol that presents choices of this kind for the representation format of numbers needs to be explicit about how the formats for deterministic encoding are to be chosen.
</li>
</ul>

			</section>
			<section id="length-first">
<h4 title="Length-First Map Key Ordering">4.2.3. ~map~keyの長さ優先な順序付け</h4>

<p>
`~map~key$が~sortされる順序は、［
`決定論的な符号化法の中核~要件$によるそれ
］と［
`RFC7049$r `§ 3.9＠~RFCx/rfc7049#section-3.9$ により示唆されたもの
（そこでは、 “正準的~CBOR”（ `Canonical CBOR^en ）と呼ばれる）
］とで異なる。
~protocolは、
`RFC7049$r にて指定された順序と互換になる必要がある場合は，
代わりに この仕様の用語
`長さ優先な決定論的な符号化法の中核~要件@
（ `length-first core deterministic encoding requirements^en ）
で指定できる：
◎
The core deterministic encoding requirements (Section 4.2.1) sort map keys in a different order from the one suggested by Section 3.9 of [RFC7049] (called "Canonical CBOR" there). Protocols that need to be compatible with the order specified in [RFC7049] can instead be specified in terms of this specification's "length-first core deterministic encoding requirements":
</p>

<p>
~CBOR符号化法は、［
`~map$内の`~key$たちは、
次に従って~sortされなければナラナイ
］ことを除いて［
`決定論的な符号化法の中核~要件$を満足する
］ならば，
`長さ優先な決定論的な符号化法の中核~要件$を満足するとされる：
◎
A CBOR encoding satisfies the "length-first core deterministic encoding requirements" if it satisfies the core deterministic encoding requirements except that the keys in every map MUST be sorted such that:
</p>
<ol>
	<li>
2 つの`~key$の長さが異なる場合
⇒
長さが短い方が先に来るよう~sortする
◎
If two keys have different lengths, the shorter one sorts earlier;
</li>
	<li>
2 つの`~key$の長さが同じ場合
⇒
~byteごとの辞書式~順序で~sortする
◎
If two keys have the same length, the one with the lower value in (bytewise) lexical order sorts earlier.
</li>
</ol>

<p>
例えば，
`長さ優先な決定論的な符号化法の中核~要件$の下では、
次に挙げる`~key$たちは，正しく~sortされている
（括弧内は符号化した結果）：
◎
For example, under the length-first core deterministic encoding requirements, the following keys are sorted correctly:
</p>
<ol>
	<li>
10
（ `0a^X ）
◎
10, encoded as 0x0a.
</li>
	<li>
−1
（ `20^X ）
◎
-1, encoded as 0x20.
</li>
	<li>
`false$i
（ `f4^X ）
◎
false, encoded as 0xf4.
</li>
	<li>
100
（ `1864^X ）
◎
100, encoded as 0x1864.
</li>
	<li>
"z"
（ `617a^X ）
◎
"z", encoded as 0x617a.
</li>
	<li>
[−1]
（ `8120^X ）
◎
[-1], encoded as 0x8120.
</li>
	<li>
"aa"
（ `626161^X ）
◎
"aa", encoded as 0x626161.
</li>
	<li>
[100]
（ `811864^X ）
◎
[100], encoded as 0x811864.
</li>
</ol>

<p class="note">注記：
`RFC7049$r は，
決定論的な符号化法に対する要件を成す形として用語 “正準的~CBOR” を利用していたが、
この文書は，この用語を避ける
— “正準-化” は，決定論的な符号化法の特定の利用に限って結付けられることが多いので。
これらの用語は，本質的には交換-可能であるが、
この文書における一群の中核~要件は，
“正準的~CBOR” とも呼ばれることもある一方で、
その長さ優先で順序付けられた~versionは，
“旧~正準的な~CBOR” と呼ばれることもある。
◎
Although [RFC7049] used the term "Canonical CBOR" for its form of requirements on deterministic encoding, this document avoids this term because "canonicalization" is often associated with specific uses of deterministic encoding only. The terms are essentially interchangeable, however, and the set of core requirements in this document could also be called "Canonical CBOR", while the length-first-ordered version of that could be called "Old Canonical CBOR".
</p>

			</section>
		</section>
	</section>
	<section id="creating-cbor-based-protocols">
<h2 title="Creating CBOR-Based Protocols">5. ~CBORに基づく~protocolの作成-法</h2>

<p>
~CBORなどの~data形式は、
形式~折衝が無い環境において利用されることが多い。
~CBORに特有な設計~目標は、
~schemaが［
含まれる／あると見做される
］ことを必要としない
— すなわち、
復号器は，所与の`~data~item$を他の知識が無い下で復号できるようにする —
ことにある。
◎
Data formats such as CBOR are often used in environments where there is no format negotiation. A specific design goal of CBOR is to not need any included or assumed schema: a decoder can take a CBOR item and decode it with no other knowledge.
</p>

<p>
もちろん，現実の実装においては、
符号化器と復号器は［
`~data~item$内に何があるべきかについて，見方を共有する
］ことになる。
合意される形式は、
例えば，次のようなものになるかもしれない：
◎
Of course, in real-world implementations, the encoder and the decoder will have a shared view of what should be in a CBOR data item. For example, an agreed-to format might be＼
</p>
<ul>
	<li>
“~itemは`~array$であり、
それを成す［
1 個目の値は`~UTF-8~string$,
2 個目の値は`~integer$,
後続の各~値は`~float$
］である。”
◎
"the item is an array whose first value is a UTF-8 string, second value is an integer, and subsequent values are zero or more floating-point numbers"＼
</li>
	<li>
“~itemは`~byte~string$を`~key$とする`~map$であり、
特に，`~key$として `ab01^X を伴う`~entry$を包含する。”
◎
or "the item is a map that has byte strings for keys and contains a pair whose key is 0xab01".
</li>
</ul>

<p>
~CBORに基づく~protocolは：
◎
↓</p>
<ul>
	<li>
それ用の復号器が［
`妥当$でない~data, 他の`期待され$ない~data
］をどう取扱うかを指定しなければナラナイ。
◎
CBOR-based protocols MUST specify how their decoders handle invalid and other unexpected data.＼
</li>
	<li>
任意な`妥当$な~dataに対し，それを`期待され$ないものとして扱うよう指定してもヨイ。
◎
CBOR-based protocols MAY specify that they treat arbitrary valid data as unexpected.＼
</li>
	<li>
それ用の符号化器は、
`妥当$でない~itemを生産してはナラナイ
— すなわち、
当の~protocolは，`妥当$でない~itemを用立てるようには設計し得ない。
◎
Encoders for CBOR-based protocols MUST produce only valid items, that is, the protocol cannot be designed to make use of invalid items.＼
</li>
	<li>
それ用の［
符号化器／復号器
］は、［
当の~protocolにより要求される値~型
］のうち，一部に限り［
符号化する／解する
］能力を備えるものにもなり得る。
この［
制約の欠如
］は、［
極めて拘束された環境において，~CBORを利用する
］ことを許容する。
◎
An encoder can be capable of encoding as many or as few types of values as is required by the protocol in which it is used; a decoder can be capable of understanding as many or as few types of values as is required by the protocols in which it is used. This lack of restrictions allows CBOR to be used in extremely constrained environments.
</li>
</ul>

<p>
この節の以降では、［
~CBORに基づく~protocolを作成するときの考慮点
］のうち一部を論じる。
それらは、
少数の例外†を除き，助言的でしかない
— ~BCP 14 `RFC2119$r `RFC8174$r による文言は、
その “〜してもヨイ（ `MAY^en ）” としても解釈できる語句を除いて，
明示的に除外される。
† これらの例外は、［
多様な［
符号化器／復号器
］を
— 汎用なもの, 応用に特有なもの どちらも —
用立てる
］ようにしつつ，［
~CBORに基づく~protocolの相互運用能を手助けする
］ことを目指す。
◎
The rest of this section discusses some considerations in creating CBOR-based protocols. With few exceptions, it is advisory only and explicitly excludes any language from BCP 14 [RFC2119] [RFC8174] other than words that could be interpreted as "MAY" in the sense of BCP 14. The exceptions aim at facilitating interoperability of CBOR-based protocols while making use of a wide variety of both generic and application-specific encoders and decoders.
</p>

		<section id="cbor-in-streaming-applications">
<h3 title="CBOR in Streaming Applications">5.1. ~streamしている応用における~CBOR</h3>

<p>
`~streamして$いる応用においては、
`~data~stream$は，［
~~連続するよう連結された，一連の`~data~item$
］から構成され得る。
そのような環境においては，復号器は、［
すでに得られた~data~itemの終端より後にも，~dataが見出された場合
］には，新たな~data~itemの復号を即時に始める。
◎
In a streaming application, a data stream may be composed of a sequence of CBOR data items concatenated back-to-back. In such an environment, the decoder immediately begins decoding a new data item if data is found after the end of a previous data item.
</p>

<p>
［
ある~data~itemを成している すべての~byte
］が，即時には復号器に可用にならないこともある。
一部の復号器は、
追加的な~dataを［
完全な~data~itemを応用に呈示できるようになる
］まで~bufferすることになる。
他の復号器は、
~top-level~data~itemについての部分的な情報を応用に呈示し得る
— すでに復号できた入子な~data~itemや，
まだ完全には到着していない`~byte~string$の各部など。
そのような応用は、［
そこで応用に呈示される増分的な~data
］用に欲される保護が可用になるよう，それに見合った［
~stream用の~securityの仕組み
］も備えなければナラナイ。
◎
Not all of the bytes making up a data item may be immediately available to the decoder; some decoders will buffer additional data until a complete data item can be presented to the application. Other decoders can present partial information about a top-level data item to an application, such as the nested data items that could already be decoded, or even parts of a byte string that hasn't completely arrived yet. Such an application also MUST have a matching streaming security mechanism, where the desired protection is available for incremental data presented to the application.
</p>

<p>
`不定長$な符号化法を利用しないよう求める［
応用／~protocol
］もあることに注意。
`不定長$な符号化法を利用することは，［
長さを集計するために，すべての~dataを結集する必要
］をなくすことを符号化器に許容するが、
復号器に［
当の~itemの終端を待機している間，割振る~memory量を増やす
］ことを要求する。
これは、
~~不都合な応用もあるかもしれない。
◎
Note that some applications and protocols will not want to use indefinite-length encoding. Using indefinite-length encoding allows an encoder to not need to marshal all the data for counting, but it requires a decoder to allocate increasing amounts of memory while waiting for the end of the item. This might be fine for some applications but not others.
</p>

		</section>
		<section id="generic">
<h3 title="Generic Encoders and Decoders">5.2. 汎用な符号化器と汎用な復号器</h3>

<p>
汎用な~CBOR復号器は、
すべての`整形式$な`~data~item$を復号でき，
結果の~data~itemを応用に呈示できる。
`C§ を見よ。
（ `8§ の診断用の記法は、
`整形式$な~CBOR値をヒトに呈示するときに利用され得る。）
◎
A generic CBOR decoder can decode all well-formed encoded CBOR data items and present the data items to an application. See Appendix C. (The diagnostic notation, Section 8, may be used to present well-formed CBOR values to humans.)
</p>

<p>
汎用な~CBOR符号化器は、
次を指定することを応用に許容する，応用~interfaceを供する
⇒
`整形式$な値は、
何であれ
— 当の符号化器に未知な［
`単純~値$／`~tag$
］を含めて —
`~data~item$として符号化されることになる
◎
Generic CBOR encoders provide an application interface that allows the application to specify any well-formed value to be encoded as a CBOR data item, including simple values and tags unknown to the encoder.
</p>

<p>
~CBOR~dataは、
`整形式$であっても`妥当$になるとは限らない
— ~CBORは、
そのような事例を最小化しようと試みるが。
例えば，符号化された`~text~string$ `62c0ae^X は、
妥当な~UTF-8を包含しないので，
`妥当$な`~data~item$ではない
（ `RFC3629$r は、
常に最短な形を利用することを要求するので）。
また，特定の`~tag$は、［
何かにより違反され得る意味論上の拘束
］を課すこともある
— 一例として、
別の`~tag$を封入している`~bignum$により／
`~tag番号$ `0$tag を伴う`~tag$のうち，`~tag内容$が［
`~byte~string$であるもの／
`~text~string$であるが `date-time^P 生成規則 `RFC3339$r に合致しないもの
］により。
汎用な［
符号化器／復号器
］には、
`妥当$でない~dataの処理を可能化するために，
応用~interface用に不自然な選択肢をとらせる要件は無い。
汎用な［
符号化器／復号器
］には、［
`単純~値$／`~tag$
］（順不同）を回送することが`期待され$る
— それらに特有な符号点が，当の［
符号化器／復号器
］が書かれた時点では登録されてなかったとしても（ `5.4§ ）。
◎
Even though CBOR attempts to minimize these cases, not all well-formed CBOR data is valid: for example, the encoded text string 0x62c0ae does not contain valid UTF-8 (because [RFC3629] requires always using the shortest form) and so is not a valid CBOR item. Also, specific tags may make semantic constraints that may be violated, for instance, by a bignum tag enclosing another tag or by an instance of tag number 0 containing a byte string or containing a text string with contents that do not match the date-time production of [RFC3339]. There is no requirement that generic encoders and decoders make unnatural choices for their application interface to enable the processing of invalid data. Generic encoders and decoders are expected to forward simple values and tags even if their specific codepoints are not registered at the time the encoder/decoder is written (Section 5.4).
</p>

		</section>
		<section id="semantic-errors">
<h3 title="Validity of Items">5.3. ~itemの妥当性</h3>

<p>
`整形式$であるが`妥当$でない`~data~item$【！`1.2§】内に符号化された~dataは、
~CBOR~data~modelにおいて解釈するときに，問題になる。
~CBORに基づく~protocolは、
何~層かにわたって
— より低い層は［
自身が回送する一部の~CBOR~dataの意味論
］を処理しないように —
指定することもできる。
これら各~層は、
自身が処理しない~dataにおける妥当性~errorには，気付き得ない
— そのような~dataは、
【より上の層へ】そのまま回送しなければナラナイ。
`妥当$でない`~data~item$の意味論を処理する最初の層は、
次に挙げるいずれかの選択肢に絞らなければなければナラナイ：
◎
A well-formed but invalid CBOR data item (Section 1.2) presents a problem with interpreting the data encoded in it in the CBOR data model. A CBOR-based protocol could be specified in several layers, in which the lower layers don't process the semantics of some of the CBOR data they forward. These layers can't notice any validity errors in data they don't process and MUST forward that data as-is. The first layer that does process the semantics of an invalid CBOR item MUST pick one of two choices:
</p>
<ol>
	<li>
問題になり得る~itemを~error~markerに置換して，
その次の~itemの処理を継続する
◎
Replace the problematic item with an error marker and continue with the next item, or
</li>
	<li>
~errorを発行して，処理をまるごと停止する。
◎
Issue an error and stop processing altogether.
</li>
</ol>

<p>
~CBORに基づく~protocolは、
各~種類の［
自身が遭遇するかもしれない`妥当$でない~item
］に対し，［
その復号器は，上に挙げた~optionのうちどれを採る
］かを指定しなければナラナイ。
◎
A CBOR-based protocol MUST specify which of these options its decoders take for each kind of invalid item they might encounter.
</p>

<p>
そのような問題は、［
~CBORの基本的な妥当性~level,
`~tag$の文脈（~tagの妥当性）
］どちらにおいても生じ得る。
◎
Such problems might occur at the basic validity level of CBOR or in the context of tags (tag validity).
</p>

			<section id="basic-validity">
<h4 title="Basic validity">5.3.1. 基本的な妥当性</h4>

<p>
基本的な`汎用~data~model$において生じ得る妥当性~errorには、
次に挙げる 2 種類がある：
◎
Two kinds of validity errors can occur in the basic generic data model:
</p>
<dl>
	<dt>
`~map$内の重複な`~key$：
◎
Duplicate keys in a map:
</dt>
	<dd>
汎用な復号器（ `5.2§ ）は、
~nativeな~CBOR~data~modelを利用して，
~dataを応用から可用にする。
その~data~modelは、
~multimapではなく，`~map$を含む
（どちらも，`~key$から`値$への対応付けであるが、
~mapを成す各`~key$は，当の~map内で一意になる一方、
~multimapは，複数の`~entry$が同じ~keyを伴い得る）。
したがって，汎用な復号器は、
`~map$内の複数の`~entry$が重複な`~key$を伴う場合には，［
それらのうち，どれか一つだけを含むよう復号する
］こともあれば，処理をまるごと停止することもある。
他方、
`~streamして$いる復号器は，重複に気付き得ないことすらある。
`~map$内の`~key$に関する さらなる論点は、
`5.6§ を見よ。
◎
Generic decoders (Section 5.2) make data available to applications using the native CBOR data model. That data model includes maps (key-value mappings with unique keys), not multimaps (key-value mappings where multiple entries can have the same key). Thus, a generic decoder that gets a CBOR map item that has duplicate keys will decode to a map with only one instance of that key, or it might stop processing altogether. On the other hand, a "streaming decoder" may not even be able to notice. See Section 5.6 for more discussion of keys in maps.
</dd>

	<dt>
妥当でない`~UTF-8~string$
◎
Invalid UTF-8 string:
</dt>
	<dd>
復号器は、［
`~UTF-8~string$内の~byte列（`~major型$ `3$mj ）が，実際に妥当な~UTF-8であること
］を［
検証yして，適切に反応する
］よう求めることも求めないこともある。
◎
A decoder might or might not want to verify that the sequence of bytes in a UTF-8 string (major type 3) is actually valid UTF-8 and react appropriately.
</dd>
</dl>

			</section>
			<section id="tag-validity">
<h4 title="Tag validity">5.3.2. ~tagの妥当性</h4>

<p>
追加的な妥当性~errorとして，次に挙げる 2 種類が
— 基本的な`汎用~data~model$に`~tag$を追加することにより —
導入される：
◎
Two additional kinds of validity errors are introduced by adding tags to the basic generic data model:
</p>
<dl>
	<dt>
`~tag内容$として受理不能な型：
◎
Inadmissible type for tag content:
</dt>
	<dd>
`~tag番号$は、［
`~tag内容$として利用される~data~itemの型
］として何が想定されるかを指定する。
例えば，［
無符号な／負な
］`~bignum$用の`~tag番号$は、
その`~tag内容$は`~byte~string$になるものと想定される。
当の`~tag内容$
（この例では、
~nativeな~big~integer）
を ある~native表現に復号する復号器には、
`~tag内容$の型を検査することが期待される。
復号器は、［
そのような~native表現を 自身の環境~内には可用にしない
］場合でも，［
それらの`~tag$のうち，自身に既知なもの
］に対し検査を遂行して適切に反応し得る。
◎
Tag numbers (Section 3.4) specify what type of data item is supposed to be used as their tag content; for example, the tag numbers for unsigned or negative bignums are supposed to be put on byte strings. A decoder that decodes the tagged data item into a native representation (a native big integer in this example) is expected to check the type of the data item being tagged. Even decoders that don't have such native representations available in their environment may perform the check on those tags known to them and react appropriately.
</dd>

	<dt>
`~tag内容$として受理不能な値：
◎
Inadmissible value for tag content:
</dt>
	<dd>
~data~itemの型が`~tag内容$として受理可能であっても、
特定の値は受理可能でないことはある
— 例：
値 `yesterday^l は、
`~text~string$として適正であっても，
`~tag番号$ `0$tag の`~tag内容$【日時~string】としては受容-可能でない。
復号器のうち［
通常は，そのような`~tag$を等価な~platform型の中へ取り込むもの
］は、
この~tagを
— 未知な`~tag番号$を伴う`~tag$を応用に呈示する仕方（ `5.4§ ）と類似に —
応用に呈示するかもしれない。
◎
The type of data item may be admissible for a tag's content, but the specific value may not be; e.g., a value of "yesterday" is not acceptable for the content of tag 0, even though it properly is a text string. A decoder that normally ingests such tags into equivalent platform types might present this tag to the application in a similar way to how it would present a tag with an unknown tag number (Section 5.4).
</dd>
</dl>

			</section>
		</section>
		<section id="validity-checking">
<h3 title="Validity and Evolution">5.4. 妥当性と発展</h3>

<p>
妥当性~検査ngを伴う復号器は、［
妥当性~errorを伴う~data~itemを依拠-可能に検出する労
］を費やすことになる。
例えば，そのような復号器は、［
これまでの各~下位節に挙げた いずれかの妥当性~error
］を伴う`~data~item$に対し［
~errorを報告する（かつ，~dataを返さない）~API
］を備える必要がある。
◎
A decoder with validity checking will expend the effort to reliably detect data items with validity errors. For example, such a decoder needs to have an API that reports an error (and does not return data) for a CBOR data item that contains any of the validity errors listed in the previous subsection.
</p>

<p>
［
`~CBOR~tag~registry^cite（ `9.2§ ）内に定義された，一群の`~tag$
］および［
`~CBOR単純~値~registry^cite （ `9.1§ ）内に定義された，一群の単純~値
］は、
いつでも［
ある汎用な復号器により解される集合
］を超えて成長し得る。
妥当性を検査する復号器は、
そのような自身が認識しない事例に遭遇したときには，
次に挙げる いずれかを行える：
◎
The set of tags defined in the "Concise Binary Object Representation (CBOR) Tags" registry (Section 9.2), as well as the set of simple values defined in the "Concise Binary Object Representation (CBOR) Simple Values" registry (Section 9.1), can grow at any time beyond the set understood by a generic decoder. A validity-checking decoder can do one of two things when it encounters such a case that it does not recognize:
</p>
<ul>
	<li>
~errorを報告する（~dataを返すことなく）。
この事例を~errorとして扱うことは、
硬直化の原因になり得るので，奨励されないことに注意。
この~error自体は、
妥当性~errorではない。
この種類の~errorは、［
これが復号器にとって既知な事例であったなら、
当の復号器は，妥当性~検査ngを遂行することになる
］場合に，当の復号器により提起される見込みが高い。
◎
It can report an error (and not return data). Note that treating this case as an error can cause ossification and is thus not encouraged. This error is not a validity error, per se. This kind of error is more likely to be raised by a decoder that would be performing validity checking if this were a known case.
</li>
	<li>
当の復号器を~callしている応用に向けて，
当の未知な~item（型, 値，および`~tag$用には復号した`~tag内容$）を発した上で、［
当の復号器は、
当の［
`~tag番号$／`単純~値$
］を認識しないこと
］を当の応用に指示する。
◎
It can emit the unknown item (type, value, and, for tags, the decoded tagged data item) to the application calling the decoder, and then give the application an indication that the decoder did not recognize that tag number or simple value.
</li>
</ul>

<p>
後者の~approachは、［
妥当性~検査ngを~supportしない復号器においても適切になる
］ことに加え、
新たに登録された［
`単純~値$／`~tag$
］に関して，前方-互換性を供する
— ~callしている応用と符号化器を同時に更新する要件を課すことなく
（このためには、
復号器の~APIは
— ~callしている応用が，未知な~itemを当の~programに適切な方式で取扱えるよう —
未知な~itemを~markする能が必要になる。）
◎
The latter approach, which is also appropriate for decoders that do not support validity checking, provides forward compatibility with newly registered tags and simple values without the requirement to update the encoder at the same time as the calling application. (For this, the decoder's API needs the ability to mark unknown items so that the calling application can handle them in a manner appropriate for the program.)
</p>

<p>
妥当性~検査ngに必要な処理のうち 一部のもの（特に，`~map$用の重複~検出）は，
目に見える~costを伴い得るので、
妥当性~検査ngの~supportは，
すべての~CBOR復号器に設置される要件ではない。
◎
Since some of the processing needed for validity checking may have an appreciable cost (in particular with duplicate detection for maps), support of validity checking is not a requirement placed on all CBOR decoders.
</p>

<p>
一部の符号化器は、
それらの応用が［
入力~dataを［
それを当の符号化器にかけた結果は、
`妥当$な~CBORになる
］ような仕方で供する
］ことに依拠する。
汎用な符号化器は、
妥当性を検査する~mode
— そこでの符号化器は、［
応用が，~~実際に~APIに適合tな~dataを供しているかどうか
］とは独立に［
自身の出力を`妥当$な~CBORに依拠-可能に制限する
］ような~mode —
も供したいと求めることもあろう。
◎
Some encoders will rely on their applications to provide input data in such a way that valid CBOR results from the encoder. A generic encoder may also want to provide a validity-checking mode where it reliably limits its output to valid CBOR, independent of whether or not its application is indeed providing API-conformant data.
</p>

		</section>
		<section id="numbers">
<h3 title="Numbers">5.5. ~number</h3>

<p>
~CBORに基づく~protocolは、［
表現-可能な~numberの範囲と精度に対し課される制約が，言語~環境に応じて異なること
］を織り込むべきである。
例えば，基本的な~JS~number~systemは、［
すべての~numberを`~float$値として扱う
］ので［
54 ~bit以上~要する`~integer$を復号した結果の精度
］は~~検知されずに喪失し得る。
別の例として、
~CBORは［
`~integer$表現~用の正負符号~bit
］を`~major型$内に保つので、
ある種の長さの有符号`~integer$【！~number】は，［
代表的な~platformにおける同じ長さの有符号`~integer$の表現
］より 1 ~bit多い
（例：
8 個の~byteからなる~int64_t
~IN { −~POW( 2, 63 ) 〜 ( ~POW( 2, 63 ) ~MINUS 1 ) }
に対し，［
先頭~byte + 8 個の~byte
］からなる`~integer$
~IN { −~POW( 2, 64 ) 〜 ( ~POW( 2, 64 ) ~MINUS 1 ) } ）。
~numberを利用する~protocolは、［［
復号器, 受信している応用
］における，~numberに対する自明でない取扱い
］に何を期待するかを定義するべきである。
◎
CBOR-based protocols should take into account that different language environments pose different restrictions on the range and precision of numbers that are representable. For example, the basic JavaScript number system treats all numbers as floating-point values, which may result in the silent loss of precision in decoding integers with more than 53 significant bits. Another example is that, since CBOR keeps the sign bit for its integer representation in the major type, it has one bit more for signed numbers of a certain length (e.g., -264..264-1 for 1+8-byte integers) than the typical platform signed integer representation of the same length (-263..263-1 for 8-byte int64_t). A protocol that uses numbers should define its expectations on the handling of nontrivial numbers in decoders and receiving applications.
</p>

<p>
~CBORに基づく~protocolのうち，`~float$を含むものは、［
`半-精度$, `単-精度$, `倍-精度$
］のうち，どの形式を~supportするかを制約できる。
ある~protocolは、
`~integer$しか利用しない応用に対しては，
`~float$値の利用を完全に除外したいと求めることもあろう。
◎
A CBOR-based protocol that includes floating-point numbers can restrict which of the three formats (half-precision, single-precision, and double-precision) are to be supported. For an integer-only application, a protocol may want to completely exclude the use of floating-point values.
</p>

<p>
~CBORに基づく~protocolのうち~compactさを得るために設計されたものは、
当の応用~用には［
必要とされるより長い特定の~integer符号化法
］を除外したいと求めることもあろう
—  64 ~bit`~integer$を実装する必要を節約するためなど。
これには、
その符号化器は［
所与の値を表現できる`~integer$表現のうち，最も~compactなもの
］を利用することになる期待がある。
しかしながら，［
~compactな応用のうち，決定論的な符号化法を要求しないもの
］は、
必要以上に長い符号化法
（ 0 を［ 
`000_11001^B, 後続する 2 個の~byte `00^X
］として符号化するなど）
を利用する値を
— 当の応用が所与の~sizeの`~integer$を復号できる限りにおいて —
受容するべきである。
類似な考慮点は、
`~float$値にも適用される
— ［
選好される直列化,
必要以上に長いもの
］どちらも復号することが推奨される。
◎
A CBOR-based protocol designed for compactness may want to exclude specific integer encodings that are longer than necessary for the application, such as to save the need to implement 64-bit integers. There is an expectation that encoders will use the most compact integer representation that can represent a given value. However, a compact application that does not require deterministic encoding should accept values that use a longer-than-needed encoding (such as encoding "0" as 0b000_11001 followed by two bytes of 0x00) as long as the application can decode an integer of the given size. Similar considerations apply to floating-point values; decoding both preferred serializations and longer-than-needed ones is recommended.
</p>

<p>
~CBORに基づく~protocolのうち，拘束された応用~用にあるもののうち，
特定の~number（指数が小さいかつ負でないものなど）を［
`~integer$, ［
`~decimal小数$／`~bigfloat$
］］いずれかとして表現する選択肢を供するものは、［
`~integer$表現が直に利用されるとする，実装~品質に対する期待
］を表出するかもしれない。
◎
CBOR-based protocols for constrained applications that provide a choice between representing a specific number as an integer and as a decimal fraction or bigfloat (such as when the exponent is small and nonnegative) might express a quality-of-implementation expectation that the integer representation is used directly.
</p>

		</section>
		<section id="map-keys">
<h3 title="Specifying Keys for Maps">5.6. ~map用~keyの指定-法</h3>

<p>
符号化~応用と復号~応用は、［
`~map$内に利用される`~key$の型
］について合意する必要がある。
ある応用が，~JSONに基づく応用と相互に作業する必要がある場合、
変換は，`~key$の形を`~text~string$に限るよう制限することにより単純~化される。
他の場合、
他の~CBOR型から`~text~string$への対応付けが指定される必要があり，
これは実装~errorに至らすことが多い。
応用においては、［
`~key$は資質において数量-であって，
`~key$の数量-順序付けは当の応用にとって重要である
］所では，`~key$用に直に~numberを利用することが有用になる。
◎
The encoding and decoding applications need to agree on what types of keys are going to be used in maps. In applications that need to interwork with JSON-based applications, conversion is simplified by limiting keys to text strings only; otherwise, there has to be a specified mapping from the other CBOR types to text strings, and this often leads to implementation errors. In applications where keys are numeric in nature, and numeric ordering of keys is important to the application, directly using the numbers for the keys is useful.
</p>

<p>
`~key$用に複数の型が利用される場合、［
利用される特定の~programming環境において，これらの型はどう表現されることになるか
］について考慮を与えるべきである。
例えば，~JS `Map^c `ECMA262$r においては、
`~key$としての［
`~integer$ 1,
`~float$ 1.0
］を判別し得ない。
このことは、
当の~protocolは，［
ある`~map$内で，`~key$として`~integer$が利用される所
］では［
`~integer$と等しくなり得る`~float$値を`~key$として利用すること
］を避ける必要があることを意味する。
◎
If multiple types of keys are to be used, consideration should be given to how these types would be represented in the specific programming environments that are to be used. For example, in JavaScript Maps [ECMA262], a key of integer 1 cannot be distinguished from a key of floating-point 1.0. This means that, if integer keys are used, the protocol needs to avoid the use of floating-point keys the values of which happen to be integer numbers in the same map.
</p>

<p>
復号器のうち［［
ある`~data~item$の中に入子にされた各~data~item
］を復号したなら即時に送達するもの
］（`~streamして$いる復号器）は、［
`~map$内の`~key$の一意性を見極めるために必要とされる状態
］を保たないことが多い。
類似に，符号化器のうち［
`~data~item$の符号化を［
それが入子にしている~data~itemすべてが可用になる前
］に開始し得るもの
］（`~streamして$いる符号化器）は、［
その~data源が一意性を保守することに依拠する
］ことにより，~overhead【すなわち，~keyの一意性を見極める手間】を有意に抑制したいと求めることもあろう。
◎
Decoders that deliver data items nested within a CBOR data item immediately on decoding them ("streaming decoders") often do not keep the state that is necessary to ascertain uniqueness of a key in a map. Similarly, an encoder that can start encoding data items before the enclosing data item is completely available ("streaming encoder") may want to reduce its overhead significantly by relying on its data source to maintain uniqueness.
</p>

<p>
~CBORに基づく~protocolは、［
受信している応用が ある`~map$内に複数個の一致する`~key$を見つけたとき，何を行うか
］を定義しなければナラナイ。
当の~protocolにおける結果の規則は、
~CBOR~data~modelを尊重しなければナラナイ
— それは、［
`~map$内に一致する`~key$がある場合、
不正形な`~map$を指示するので，復号器は~errorで停止する必要がある
］とする規則を課すかもしれないことを除いて，
一致する`~key$を伴う`~entry$たちに対し特定の取扱いを制定し得ない。
ある`~map$が重複な`~key$を伴う`~entry$を呈する場合、
汎用な復号器は，
それを次に挙げるいずれかにより処理するかもしれない：
◎
A CBOR-based protocol MUST define what to do when a receiving application sees multiple identical keys in a map. The resulting rule in the protocol MUST respect the CBOR data model: it cannot prescribe a specific handling of the entries with the identical keys, except that it might have a rule that having identical keys in a map indicates a malformed map and that the decoder has to stop with an error. When processing maps that exhibit entries with duplicate keys, a generic decoder might do one of the following:
</p>
<ul>
	<li>
重複な`~key$を伴う`~map$を受容しない
（すなわち，`~map$用の妥当性を施行する
— `5.4§ も見よ）。
これらの汎用な復号器は、
普遍的に有用になる。
それでも、
応用によっては，自身の規則に基づいて自前の重複~検査ngを遂行する必要はあろう
（一例として、
当の応用が，特定の`~map$に対しては［
`~map~key$における`~integer$値と`~float$値を同一視する
］場合）。
◎
Not accept maps with duplicate keys (that is, enforce validity for maps, see also Section 5.4). These generic decoders are universally useful. An application may still need to perform its own duplicate checking based on application rules (for instance, if the application equates integers and floating-point values in map key positions for specific maps).
</li>
	<li>
当の`~map$を成す すべての`~entry$を
— 重複な`~key$を伴っていようが —
当の応用に渡す。
これは、［
当の応用が，重複な`~key$を取扱う（それについて検査する）
］ことを要求する
— 当の応用の規則が，`汎用~data~model$の規則と一致する場合でも。
◎
Pass all map entries to the application, including ones with duplicate keys. This requires that the application handle (check against) duplicate keys, even if the application rules are identical to the generic data model rules.
</li>
	<li>
重複な`~key$を伴う`~entry$のうち一部に限り，当の応用に渡す
— 例：同じ`~key$を伴う`~entry$のうち，最後（あるいは最初）の`~entry$に限り外へ送達する。
応用は、
そのような汎用な復号器を特定の`~key$に対し走らす回ごとに異なる結果を取得し得る
— どの値が返されるかは、
汎用な復号器の実装に応じて，および当の`~map$内の`~key$の実際の順序に基づいて異なる。
特に，応用は、
それらすべての`~entry$を見れるとは限らないので，
それらの`~key$の一意性を自前では検証し得ない
— 応用は、
`~key$の一意性を検証する必要がある場合には，
そのような汎用な復号器を利用できないこともあろう。
これらの汎用な復号器を利用し得るのは、
当の［
~data源と転送
］が，【どちらも】常に`妥当$な`~map$を供する状況に限られ、
当の［
~data源と転送
］【いずれか】が攻撃され得る場合にはアリでない。
◎
Lose some entries with duplicate keys, e.g., deliver only the final (or first) entry out of the entries with the same key. With such a generic decoder, applications may get different results for a specific key on different runs, and with different generic decoders, which value is returned is based on generic decoder implementation and the actual order of keys in the map. In particular, applications cannot validate key uniqueness on their own as they do not necessarily see all entries; they may not be able to use such a generic decoder if they need to validate key uniqueness. These generic decoders can only be used in situations where the data source and transfer always provide valid maps; this is not possible if the data source and transfer can be attacked.
</li>
</ul>

<p>
汎用な復号器は、［
これら 3 種の~approachのうち どれを実装するか
］を文書化する必要がある。
◎
Generic decoders need to document which of these three approaches they implement.
</p>

<p>
`~map$用の~CBOR~data~modelは、［
`~map$表現における`~entry$の順序
］に何らかの意味論をあてがうことを許容しない。
したがって，~CBORに基づく~protocolは、［
ある`~map$内で`~entry$たちの順序が変更されたとき，意味論が変化する
］ものと指定してはナラナイ
— 一部の順序
（例えば、決定論的な符号化法の要件（ `4.2§ ）を満たさなくなる所など）
は許容しないものと指定することを除いて。
（~map順序付けによる副次的な効果
— その時機, ~cache用法, ~side-channelになり得る他のものなど —
は、
意味論の一部を成すとは見なされないが，［
ある~protocolが，自前で決定論的な符号化~形式を要求する
］ための十分な理由を成し得る。）
◎
The CBOR data model for maps does not allow ascribing semantics to the order of the key/value pairs in the map representation. Thus, a CBOR-based protocol MUST NOT specify that changing the key/value pair order in a map changes the semantics, except to specify that some orders are disallowed, for example, where they would not meet the requirements of a deterministic encoding (Section 4.2). (Any secondary effects of map ordering such as on timing, cache usage, and other potential side channels are not considered part of the semantics but may be enough reason on their own for a protocol to require a deterministic encoding format.)
</p>

<p>
拘束された機器~用の応用は、
`~map$に頻繁に利用される`~key$の個数が少ない場合には，
`~key$として小さな`~integer$を利用することを考慮するべきである。
一例として、
24 個以下の`~key$は，無符号`~integer$として
— 48 個以下の`~key$は，負な`~integer$も利用して —
1 個の~byte内に符号化でき、
さほど頻繁に生じない`~key$には，より長い符号化を伴う`~integer$を利用できる。
◎
Applications for constrained devices should consider using small integers as keys if they have maps with a small number of frequently used keys; for instance, a set of 24 or fewer keys can be encoded in a single byte as unsigned integers, up to 48 if negative integers are also used. Less frequently occurring keys can then use integers with longer encodings.
</p>

			<section id="equivalence-of-keys">
<h4 title="Equivalence of Keys">5.6.1. ~keyの等価性</h4>

<p>
`~data~item$に適用される特定の~data~modelは、
`~map$内に生じている`~key$どうしが［
重複, 別物
］どちらなのか決定するために利用される。
◎
The specific data model that applies to a CBOR data item is used to determine whether keys occurring in maps are duplicates or distinct.
</p>

<p>
`汎用~data~model$の~levelでは、［
`~integer$値, `~float$値
］は，数量的に等価であっても互いに別物である
— それらは、
【！various big numbers (Tags 2 to 5)】
`~bignum$（ `~tag番号$ ~IN { `2$tag, `3$tag } ）や`~decimal小数$（ `~tag番号$ ~IN { `4$tag, `5$tag } ）からも得られるので。
類似に，
`~text~string$と`~byte~string$は、
同じ~byte列から構成されていていても別物になる。
［
~tag付きな値と~tag付きでない値
］は別物であり、
~tag付きな値どうしは，
`~tag番号$が異なるならば別物である。
◎
At the generic data model level, numerically equivalent integer and floating-point values are distinct from each other, as they are from the various big numbers (Tags 2 to 5). Similarly, text strings are distinct from byte strings, even if composed of the same bytes. A tagged value is distinct from an untagged value or from a value tagged with a different tag number.
</p>

<p>
これらの各~group~の中では：
◎
Within each of these groups,＼
</p>
<ul>
	<li>
数量-値どうしは、
数量的に等しく（特定的に， −0.0 と 0.0 は等しい）ない限り，別物になる。
◎
numeric values are distinct unless they are numerically equal (specifically, -0.0 is equal to 0.0); for the purpose of map key equivalence,＼
</li>
	<li>
各種 ~NaN値どうしは、
`~map~key$の等価性の目的においては，［
両~仮数部の右側を 64 ~bit になるまで 0 で拡張した後
］に仮数部が同じになる場合には等価になる。
◎
NaN values are equivalent if they have the same significand after zero-extending both significands at the right to 64 bits.
</li>
	<li>
［
`~byte~string$どうし／`~text~string$どうし
］は、
~byteごとに比較され，［
同じ個数の~byteからなる, かつ
同じ位置にある~byteどうしが等しい
］ならば等しいとされる。
◎
Both byte strings and text strings are compared byte by byte,＼
</li>
	<li>
`~array$は、
要素ごとに比較され，［
同じ個数の要素からなる, かつ
同じ位置にある要素どうしが等しい
］ならば等しいとされる。
◎
arrays are compared element by element, and are equal if they have the same number of bytes/elements and the same values at the same positions.＼
</li>
	<li>
`~map$どうしは、
順序を問わず，それらの`~entry$たちが同じ集合を成すならば等しいとされる
— `~entry$どうしは、［
`~key$, `値$
］どちらも互いに等しいならば等しいとされる。
◎
Two maps are equal if they have the same set of pairs regardless of their order; pairs are equal if both the key and value are equal.
</li>
	<li>
`~tag$どうしは、［
`~tag番号$, `~tag内容$
］どちらも互いに等しいならば等しいとされる。
（特定の~tag用の処理を供する汎用な復号器は、
一部の［
意味論的に等価な値たち
］を判別-可能でない場合もあることに注意
— 例：
`~tag番号$［
`2$tag ／ `3$tag
］の`~tag内容$において頭部に 0 が生じる場合）。
◎
Tagged values are equal if both the tag number and the tag content are equal. (Note that a generic decoder that provides processing for a specific tag may not be able to distinguish some semantically equivalent values, e.g., if leading zeroes occur in the content of tag 2 or tag 3 (Section 3.4.3).)＼
</li>
	<li>
`単純~値$は、
単純に値が等しいならば等しいとされる。
◎
Simple values are equal if they simply have the same value.＼
</li>
</ul>

<p>
`汎用~data~model$において等しくなるものは、
他に無い
— `単純~値$ 2 と`~integer$ 2 は等価ではなく，
`~array$と`~map$が等価なることは決してない。
◎
Nothing else is equal in the generic data model; a simple value 2 is not equivalent to an integer 2, and an array is never equivalent to a map.
</p>

<p>
`2.2§ にて論じたとおり，
特定の~data~modelには、
`~map~key$を比較する目的において，［
`汎用~data~model$においては別物な値
］を等価に~~扱うものもある。
したがって，そのような~data~modelに基づく応用は、［
汎用な復号器から復号されて送達された`~map$に対し，
重複な`~map~key$を検査する必要があり得る
］ことに注意
（代替として、
当の復号器は，この~serviceを遂行するための~APIを応用に供することもできる）。
特定の~data~modelは、
`~map~key$用の値のうち［
`汎用~data~model$の~levelでは、
この目的において等しいもの
］どうしを判別-可能でない。
◎
As discussed in Section 2.2, specific data models can make values equivalent for the purpose of comparing map keys that are distinct in the generic data model. Note that this implies that a generic decoder may deliver a decoded map to an application that needs to be checked for duplicate map keys by that application (alternatively, the decoder may provide a programming interface to perform this service for the application). Specific data models are not able to distinguish values for map keys that are equal for this purpose at the generic data model level.
</p>

			</section>
		</section>
		<section id="undefined-values">
<h3 title="Undefined Values">5.7. `undefined^i 値</h3>

<p>
~CBORに基づく一部の~protocolにおいては、
符号化器により`単純~値$ `undefined$i が利用されるかもしれない
— ［
符号化に問題を伴う~data~item用の代用-
］として［
それを封入している~data~itemを成す他の部分に害が及ばないよう符号化する
］ことを許容するために。
◎
In some CBOR-based protocols, the simple value (Section 3.3) of undefined might be used by an encoder as a substitute for a data item with an encoding problem, in order to allow the rest of the enclosing data items to be encoded without harm.
</p>

		</section>
	</section>
	<section id="converting-data-between-cbor-and-json">
<h2 title="Converting Data between CBOR and JSON">6. ~CBORと~JSONの間の~dataの変換-法</h2>

<p>
この節は、
~CBORと~JSONの間の変換-法について，規範的でない助言を与える。
変換器の実装は、
ここに与える助言に自身が求めるものがあれば，何であれ利用してもヨイ。
◎
This section gives non-normative advice about converting between CBOR and JSON. Implementations of converters MAY use whichever advice here they want.
</p>

<p>
~JSON~textは（符号化された~byte列ではなく）一連の文字からなる一方で、
`~data~item$は（文字~並びではなく）一連の~byteからなることに~~留意すること。
◎
It is worth noting that a JSON text is a sequence of characters, not an encoded sequence of bytes, while a CBOR data item consists of bytes, not characters.
</p>

		<section id="converting-from-cbor-to-json">
<h3 title="Converting from CBOR to JSON">6.1. ~CBORから~JSONへの変換-法</h3>

<p>
~JSONは、
~CBORにおける ほとんどの型に対し，その相似物を直に備える。
しかしながら，一部の型はそうでない
— ~CBORから~JSONへの変換器を実装している者は、
それらの事例において何を行うか考慮する必要がある。
以下に挙げる規範的でない助言は、
そのような型を
1 個の代用-値
— ~JSON `null^c など —
に変換することにより，これらを処する。
◎
Most of the types in CBOR have direct analogs in JSON. However, some do not, and someone implementing a CBOR-to-JSON converter has to consider what to do in those cases. The following non-normative advice deals with these by converting them to a single substitute value, such as a JSON null.
</p>
<ul>
	<li>
`~integer$（`~major型$ ~IN { `0$mj, `1$mj } ）は、
~JSON~numberになる。
◎
An integer (major type 0 or 1) becomes a JSON number.
</li>
	<li>
`~byte~string$（`~major型$ `2$mj ）のうち［［
提案された符号化法を指定する`~tag$
］内に埋込まれたもの
］でないものは、
~base64url内に補充~文字を伴わずに符号化され，
~JSON~stringになる
◎
A byte string (major type 2) that is not embedded in a tag that specifies a proposed encoding is encoded in base64url without padding and becomes a JSON string.
</li>
	<li>
<p>
`~UTF-8~string$（`~major型$ `3$mj ）は、
~JSON~stringになる。
◎
A UTF-8 string (major type 3) becomes a JSON string.＼
</p>

<p>
~JSONは、
次に挙げる文字に対し，~escape法を要求することに注意
（ `RFC8259$r `§ 7＠~RFCx/rfc8259#section-7$ ）
⇒＃
`0022^U `"^smb（ `QUOTATION MARK^cn ／二重-引用符）,
`005C^U `\^smb（ `REVERSE SOLIDUS^cn ）,
`0000^U 〜 `001F^U （~C0制御~文字）
◎終
他の文字は、
~JSON~UTF-8~stringの中へそのまま複製される。
◎
Note that JSON requires escaping certain characters ([RFC8259], Section 7): quotation mark (U+0022), reverse solidus (U+005C), and the "C0 control characters" (U+0000 through U+001F). All other characters are copied unchanged into the JSON UTF-8 string.
</p>
	</li>
	<li>
`~array$（`~major型$ `4$mj ）は、
~JSON~arrayになる。
◎
An array (major type 4) becomes a JSON array.
</li>
	<li>
<p>
`~map$（`~major型$ `5$mj ）は、
~JSON~objectになる。
◎
A map (major type 5) becomes a JSON object.＼
</p>

<p>
これが直にアリになるのは、
すべての`~key$が`~UTF-8~string$である場合に限られる。
変換器は、
他の`~key$も`~UTF-8~string$に変換するかもしれない
（`~integer$を［
その~decimal表現を包含している~string
］に変換するなどにより）
— しかしながら，そうすることは、
~key衝突の危険性も導入する。
これはまた、［
`~UTF-8~string$に対する`~tag$が下に提案されるとおり無視される場合
］には［
当の`~tag$どうしは異なるが~stringどうしは同じである場合
］に~key衝突の原因になることにも注意。
◎
This is possible directly only if all keys are UTF-8 strings. A converter might also convert other keys into UTF-8 strings (such as by converting integers into strings containing their decimal representation); however, doing so introduces a danger of key collision. Note also that, if tags on UTF-8 strings are ignored as proposed below, this will cause a key collision if the tags are different but the strings are the same.
</p>
	</li>
	<li>
<p>
［
`単純~値$／`~float$値
］（`~major型$ `7$mj ）は：
◎
↓</p>
		<ul>
			<li>
`false$i
（`追加l情報$ `20^ai ）は、
~JSON `false^c になる。
◎
False (major type 7, additional information 20) becomes a JSON false.
</li>
			<li>
`true$i
（`追加l情報$ `21^ai ）は、
~JSON `true^c になる。
◎
True (major type 7, additional information 21) becomes a JSON true.
</li>
			<li>
`null$i
（`追加l情報$ `22^ai ）は、
~JSON `null^c になる。
◎
Null (major type 7, additional information 22) becomes a JSON null.
</li>
			<li>
<p>
`~float$値
（ `追加l情報$ ~IN { `25^ai, `26^ai, `27^ai } ）は、
当の値に応じて：
◎
A floating-point value (major type 7, additional information 25 through 27) becomes＼
</p>
				<ul>
					<li>
有限である場合、
~JSON~numberになる
（すなわち，~JSON~numberで表現できる）
◎
a JSON number if it is finite (that is, it can be represented in a JSON number);＼
</li>
					<li>
非-有限である場合
（~NaN ／ 正な~Infinity／負な~Infinity）、
代用-値により表現される。
◎
if the value is non-finite (NaN, or positive or negative Infinity), it is represented by the substitute value.
</li>
				</ul>
			</li>
			<li>
<p>
その他の`単純~値$
（`追加l情報$はまだ論じられていない他の値）
は、
代用-値により表現される。
</p>
◎
Any other simple value (major type 7, any additional information value not yet discussed) is represented by the substitute value.
</li>
		</ul>

<p class="trans-note">【
［
`単純~値$ `undefined$i ／
非-有限な`~float$値
］に対応するものは、
~JSには在るが，~JSONには無いことに注意。
】</p>

	</li>
	<li>
<p>
各種`~tag$（ `~major型$ `6$mj ）は：
◎
↓</p>
		<ul>
			<li>
`~bignum$
（ `~tag番号$ ~IN { `2$tag, `3$tag } ）は、［
その`~tag内容$を成す`~byte~string$を補充~文字を伴わない~base64urlに符号化する
］ことにより表現され，~JSON~stringになる。
`~tag番号$ `3$tag （負な`~bignum$）用には，
`007E^U `~^smb（~ASCII `tilde^en ）が~base-符号化された値の前に挿入される。
（~numberの代わりに~binary~blobへ変換することで、
~JSON復号器における数量-~overflowは防止されると見込まれる。）
◎
A bignum (major type 6, tag number 2 or 3) is represented by encoding its byte string in base64url without padding and becomes a JSON string. For tag number 3 (negative bignum), a "~" (ASCII tilde) is inserted before the base-encoded value. (The conversion to a binary blob instead of a number is to prevent a likely numeric overflow for the JSON decoder.)
</li>
			<li>
符号化法~hintを伴う`~byte~string$
（ `~tag番号$ ~IN { `21$tag, `22$tag, `23$tag } ）
は、
当の~hintにより述べられるとおりに符号化され，
~JSON~stringになる。【`3.4.5.2§】
◎
A byte string with an encoding hint (major type 6, tag number 21 through 23) is encoded as described by the hint and becomes a JSON string.
</li>
			<li>
他のすべての`~tag$
（その他の`~tag番号$）
用には、
当の`~tag内容$が~JSON値として表現され，`~tag番号$は無視される。
◎
For all other tags (major type 6, any other tag number), the tag content is represented as a JSON value; the tag number is ignored.
</li>
		</ul>
	</li>
	<li>
`不定長$な~itemは、
変換する前に`確定長$にされる。
◎
Indefinite-length items are made definite before conversion.
</li>
</ul>

<p>
~CBORから~JSONへの変換器は、［
相互運用能を最大化する
］ため, および［
~JSON出力を予測-可能な結果で処理できる~~確証を高める
］ために，
~JSON~profile ~I-JSON `RFC7493$r を保ちたいと求めることもあろう。
これには、
例えば，次に対する含意がある
⇒＃
依拠-可能に表現できる`~integer$の範囲／
旧い~JSON実装が~supportし得る~top-level~item
◎
A CBOR-to-JSON converter may want to keep to the JSON profile I-JSON [RFC7493], to maximize interoperability and increase confidence that the JSON output can be processed with predictable results. For example, this has implications on the range of integers that can be represented reliably, as well as on the top-level items that may be supported by older JSON implementations.
</p>

		</section>
		<section id="converting-from-json">
<h3 title="Converting from JSON to CBOR">6.2. ~JSONから~CBORへの変換-法</h3>

<p>
すべての~JSON値は、
復号されたなら，
1 個以上の~CBOR値に直に対応付けられる。
~CBORを生成するときと同じく，~number表現に関して裁定を下す必要がある。
示唆される変換は：
◎
All JSON values, once decoded, directly map into one or more CBOR values. As with any kind of CBOR generation, decisions have to be made with respect to number representation. In a suggested conversion:
</p>
<ul>
	<li>
小数部を伴わない~JSON~number（~integer~number）は、［
`~integer$
（`~major型$ ~IN { `0$mj, `1$mj } ）
あるいは，場合によっては`~bignum$
（ `~major型$ `6$mj, `~tag番号$ ~IN { `2$tag, `3$tag } ）
］として，最短な形を選んで表現される
— `~integer$のうち，実装~定義な~~上限より長いものは、
代わりに，`~float$値として表現され得る。
`~integer$として表現される既定の範囲は、
{ ( −~POW( 2, 53 ) ~PLUS 1 ) 〜 ( ~POW( 2, 53 ) ~MINUS 1 ) }
である
（これは、
~JSONを復号するときによく利用される，［
`倍-精度~float$表現における正確な~integer
］用の範囲 `RFC7493$r を全部的に活かす）。
［
~CBORに基づく~protocol／
汎用な変換器の実装
］は、［
{ −~POW( 2, 32 ) 〜 ( ~POW( 2, 32 ) ~MINUS 1 ) } ／
{ −~POW( 2, 64 ) 〜 ( ~POW( 2, 64 ) ~MINUS 1 ) }
］を選ぶ
（~CBORにおいて［
~uint32_t ／ ~uint64_t
］で可用な~integer範囲を全部的に利用する）
ことも【！or even】, ［
{ −~POW( 2, 31 ) 〜 ( ~POW( 2, 31 ) ~MINUS 1 ) } ／
{ −~POW( 2, 63 ) 〜 ( ~POW( 2, 63 ) ~MINUS 1 ) }
］を選ぶ
（［
2 の補数による有符号`~integer$
］用に普及している範囲を利用する）
こともある。
（当の~JSONが，ある~JS実装から生成されたものである場合、
その精度は，すでに最大 53 ~bitまでに制限される。）
◎
JSON numbers without fractional parts (integer numbers) are represented as integers (major types 0 and 1, possibly major type 6, tag number 2 and 3), choosing the shortest form; integers longer than an implementation-defined threshold may instead be represented as floating-point values. The default range that is represented as integer is -253+1..253-1 (fully exploiting the range for exact integers in the binary64 representation often used for decoding JSON [RFC7493]). A CBOR-based protocol, or a generic converter implementation, may choose -232..232-1 or -264..264-1 (fully using the integer ranges available in CBOR with uint32_t or uint64_t, respectively) or even -231..231-1 or -263..263-1 (using popular ranges for two's complement signed integers). (If the JSON was generated from a JavaScript implementation, its precision is already limited to 53 bits maximum.)
</li>
	<li>
小数部を伴う~numberは、
`~float$値として表現される
— ［
`倍-精度~float$により供される精度
］に基づく，~decimalから~binaryへの変換を遂行することにより。
［
~JSON~numberの `the mathematical value^en
］は、［
`IEEE754$r § 4.3.1 における `roundTiesToEven^en 手続-
］を利用して，`倍-精度~float$へ変換される。
この変換~結果を~CBOR内に符号化するときに選好される直列化は、
それを正確に表現している最短な`~float$表現を利用する
— 一例として， 1.5 は、
`半-精度~float$値で表現される
（最小な形を効率的に見出す能力が無い実装もあるが）。
この変換は、既定の`倍-精度~float$の精度を利用する代わりに，［
表現される値の精度に影響する，実装~定義な精度
］に制限され得る。
~CBOR側において~decimal表現を利用するのは、
~protocolにおいて，そう指定された場合に限るべきである。
◎
Numbers with fractional parts are represented as floating-point values, performing the decimal-to-binary conversion based on the precision provided by IEEE 754 binary64. The mathematical value of the JSON number is converted to binary64 using the roundTiesToEven procedure in Section 4.3.1 of [IEEE754]. Then, when encoding in CBOR, the preferred serialization uses the shortest floating-point representation exactly representing this conversion result; for instance, 1.5 is represented in a 16-bit floating-point value (not all implementations will be capable of efficiently finding the minimum form, though). Instead of using the default binary64 precision, there may be an implementation-defined limit to the precision of the conversion that will affect the precision of the represented values. Decimal representation should only be used on the CBOR side if that is specified in a protocol.
</li>
</ul>

<p>
~CBORは、
一般に［
~JSONより~compactな符号化法
］を供するよう設計された。
思い浮かぶであろう実装~策の一つは、
単独の~buffer内で, その場で，~JSONから~CBORへの符号化を遂行することである。
この策は、
いくつかの病的な事例を注意深く考慮する必要がある
— ~stringのうち［
~escapeは ごく少数に限られ，
255 ~byteより長く（または ずっと長く）表現されるもの
］のうち一部は、
~CBOR内で`~UTF-8~string$として符号化するとき展開され得るなど
【この事例の どこが “病的” とされるのかよくわからない】。
類似に，~binary`~float$表現のうち少数のものは、
~JSONにおける何らかの短い~decimal表現（例： 1.1, 1e9 ）からの展開をもたらすかもしれない。
これを~~正しく行うのは難しいこともあり、
それによる脆弱性は，攻撃者により悪用されよう。
◎
CBOR has been designed to generally provide a more compact encoding than JSON. One implementation strategy that might come to mind is to perform a JSON-to-CBOR encoding in place in a single buffer. This strategy would need to carefully consider a number of pathological cases, such as that some strings represented with no or very few escapes and longer (or much longer) than 255 bytes may expand when encoded as UTF-8 strings in CBOR. Similarly, a few of the binary floating-point representations might cause expansion from some short decimal representations (1.1, 1e9) in JSON. This may be hard to get right, and any ensuing vulnerabilities may be exploited by an attacker.
</p>

		</section>
	</section>
	<section id="future-evolution-of-cbor">
<h2 title="Future Evolution of CBOR">7. 将来における~CBORの発展</h2>

<p>
成功裡な~protocolは、
時間~越しに発展する
— 新たな案が現れる／
実装~platformが改善される／
関係する~protocolが開発され，発展する／
応用や~protocolからの新たな要件が追加される，
など。
したがって、
~protocolの発展を手助けすることは，
~protocolの開発においても重要な設計~上の考慮になる。
◎
Successful protocols evolve over time. New ideas appear, implementation platforms improve, related protocols are developed and evolve, and new requirements from applications and protocols are added. Facilitating protocol evolution is therefore an important design consideration for any protocol development.
</p>

<p>
~CBORは、
それを利用する~protocol用に，その発展を手助けする有用な仕組みをいくつか供する。
このための最善な実施は、
特に~JSONに基づく~protocolの~JSON形式の開発から周知である。
したがって，そのような最善な実施は、
この仕様の視野から外れる。
◎
For protocols that will use CBOR, CBOR provides some useful mechanisms to facilitate their evolution. Best practices for this are well known, particularly from JSON format development of JSON-based protocols. Therefore, such best practices are outside the scope of this specification.
</p>

<p>
しかしながら，~CBOR自身を手助けすることは、
この仕様の視野に入る。
~CBORは、［
~CBORに基づく~protocolの開発~用に安定的な基礎を供する
］かつ［
発展-可能になる
］よう設計されている。
成功裡な~protocolは，数十年にわたって生き続けることもあるので、
~CBORは，数十年にわたる利用と発展~用に設計される必要がある。
この節は、
~CBORの発展~用に，いくつかの指導を供する。
それは、
この文書の他の各部より主観的にならざるを得ない。
それはまた、
不完全にならざるを得ない
— ~protocol開発~用の教本の中へ転換されてしまいそうだが。
◎
However, facilitating the evolution of CBOR itself is very well within its scope. CBOR is designed to both provide a stable basis for development of CBOR-based protocols and to be able to evolve. Since a successful protocol may live for decades, CBOR needs to be designed for decades of use and evolution. This section provides some guidance for the evolution of CBOR. It is necessarily more subjective than other parts of this document. It is also necessarily incomplete, lest it turn into a textbook on protocol development.
</p>

		<section id="extension-points">
<h3 title="Extension Points">7.1. 拡張~地点</h3>

<p>
~protocol設計においては、
発展~用の機会は，拡張~地点の形で含まれることが多い。
例えば，ある符号点~空間は、
初めから全部的に割振られてはおらず，
当の~protocolは［
初期~時には割振られてはいなかった符号点を，初めから利用する実装
］を追認できるように設計されることもあろう。
◎
In a protocol design, opportunities for evolution are often included in the form of extension points. For example, there may be a codepoint space that is not fully allocated from the outset, and the protocol is designed to tolerate and embrace implementations that start using more codepoints than initially allocated.
</p>

<p>
符号点~空間の~sizingは、
困難なこともある
— その範囲を予測するのは難しいこともあるので。
~protocol設計は、［
~protocolに意図される存続期間の中で、
当の符号点~空間が簡単に埋め尽くされない
］よう，十分~大きくとるよう試みるべきである。
◎
Sizing the codepoint space may be difficult because the range required may be hard to predict. Protocol designs should attempt to make the codepoint space large enough so that it can slowly be filled over the intended lifetime of the protocol.
</p>

<p>
~CBORには、
主要な拡張~地点として，次に挙げる 3 種がある：
◎
CBOR has three major extension points:
</p>
<dl>
	<dt>
`単純~値$用の空間（`~major型$ `7$mj 内の値）
◎
the "simple" space (values in major type 7):
</dt>
	<dd>
小さな~numberに限って割振られた，
24 個の効率的な（および 224 個の少しだけ効率的でない）値。
その値の構造は，~~実際に単純なので、
実装は，受信した単純~data~itemが未知であっても容易に処理できよう。
［
`9.1§ における~IANA~registry
］が［
この符号点~空間の拡張能に取組むための適切な仕方
］になる。
◎
Of the 24 efficient (and 224 slightly less efficient) values, only a small number have been allocated. Implementations receiving an unknown simple data item may easily be able to process it as such, given that the structure of the value is indeed simple. The IANA registry in Section 9.1 is the appropriate way to address the extensibility of this codepoint space.
</dd>

	<dt>
`~tag$用の空間（`~major型$ `6$mj 内の値）
◎
the "tag" space (values in major type 6):
</dt>
	<dd>
符号点~空間の総量は膨大であり、
割振られた符号点は僅かしかない。
しかしながら，［
これらの符号点~すべてが等しく効率的
］ではない：
最初の 24 個は、
1 個の~byte（先頭~byteのみ）しか消費しない
— うち半分は，すでに割振られている。
その次の 232 個の値は、
2 個の~byte（先頭~byte + 1 ~byte）しか消費しない
— うち およそ 4 分の 1 はすでに割振られている。
これらの下位-空間は、
あと何十年かは残り続けるよう，何らかの精選が必要である。
未知な`~tag番号$を受信している実装は、［
封入された`~tag内容$だけを処理する
］か［
当の`~tag$を［
その`~tag内容$を包装している未知な`~tag番号$
］として処理する
］かを選べる
— 後者が好ましいが。
［
`9.2§ における~IANA~registry
］が［
この符号点~空間の拡張能に取組むための適切な仕方
］になる。
◎
The total codepoint space is abundant; only a tiny part of it has been allocated. However, not all of these codepoints are equally efficient: the first 24 only consume a single ("1+0") byte, and half of them have already been allocated. The next 232 values only consume two ("1+1") bytes, with nearly a quarter already allocated. These subspaces need some curation to last for a few more decades. Implementations receiving an unknown tag number can choose to process just the enclosed tag content or, preferably, to process the tag as an unknown tag number wrapping the tag content. The IANA registry in Section 9.2 is the appropriate way to address the extensibility of this codepoint space.
</dd>

	<dt>
`追加l情報$用の空間
◎
the "additional information" space:
</dt>
	<dd>
追加l情報として未知な値を受信している実装には，復号を継続する仕方は無いので、
この空間~内に符号点を割振ることは，［
拡張~地点を演習するだけに過ぎないもの
］を超える主要な段になる。
また、
残された符号点は，ごく少数しかない。
`7.2§ も見よ。
◎
An implementation receiving an unknown additional information value has no way to continue decoding, so allocating codepoints in this space is a major step beyond just exercising an extension point. There are also very few codepoints left. See also Section 7.2.
</dd>
</dl>

		</section>
		<section id="curating">
<h3 title="Curating the Additional Information Space">7.2. 追加l情報~用の空間の精選-法</h3>

<p>
ヒトはときには、
小さな “隙間” を知覚したとき，そこを埋めて白黒つけたがる。
`追加l情報$用の符号点~空間に残された値の隙間は、
その~~存在自体が新たな案を引き寄せるものになると予期される。
◎
The human mind is sometimes drawn to filling in little perceived gaps to make something neat. We expect the remaining gaps in the codepoint space for the additional information values to be an attractor for new ideas, just because they are there.
</p>

<p>
~CBORの現~versionは、
追加l情報~用の符号点~空間を~IANA~registryにより管理しない
— この空間の割振りを行い得るのは、
この仕様を更新することに限られる。
◎
The present specification does not manage the additional information codepoint space by an IANA registry. Instead, allocations out of this space can only be done by updating this specification.
</p>

<p>
`追加l情報$値 %n ~IN { `24^ai, `25^ai, `26^ai, `27^ai } の場合、
追加的な~dataの~sizeは ~POW( 2, %n ~MINUS 24 ) ~byteになる。
したがって、
`追加l情報$値［
`28^ai ／ `29^ai
］も，~CBOR~protocolに それらを追加する必要が発生する事例では［
128 ~bit ／ 256 ~bit
］~size用の候補と見るべきである。
一般的な割振り用に可用な`追加l情報$値は `30^ai のみであり、
特段に良い理由が無い限り，［
~CBORの現~versionの更新を通してアテガう前
］に割振るべきではない。
◎
For an additional information value of n &gt;= 24, the size of the additional data typically is 2n-24 bytes. Therefore, additional information values 28 and 29 should be viewed as candidates for 128-bit and 256-bit quantities, in case a need arises to add them to the protocol. Additional information value 30 is then the only additional information value available for general allocation, and there should be a very good reason for allocating it before assigning it through an update of the present specification.
</p>

		</section>
	</section>
	<section id="diagnostic-notation">
<h2 title="Diagnostic Notation">8. 診断用の記法</h2>

<p>
~CBORは、
~binary交換~形式である。
文書化と~debug法を手助けするため
— 特に，~debug時に協力している実体どうしの通信を手助けするため —
この節は、
ヒトが可読な単純な診断用の記法を定義する。
【すなわち、~CBOR~data~itemをヒトが可読な~textに変換するための規則を定義する。】
実際の交換は、
すべて，常に~binary形式~内に起こる。
◎
CBOR is a binary interchange format. To facilitate documentation and debugging, and in particular to facilitate communication between entities cooperating in debugging, this section defines a simple human-readable diagnostic notation. All actual interchange always happens in the binary format.
</p>

<p>
これは、
真に診断用の形式であり，
構文解析されることは意味されないことに注意。
したがって，この文書においては、
（~ABNFのような）正式な定義は与えられない。
（`~data~item$を環境設定~file内に表現するために，
~textに基づく形式を探している実装者は、
~YAML `YAML$r を考慮したいと求めることもあろう。）
◎
Note that this truly is a diagnostic format; it is not meant to be parsed. Therefore, no formal definition (as in ABNF) is given in this document. (Implementers looking for a text-based format for representing CBOR data items in configuration files may also want to consider YAML [YAML].)
</p>

<p>
診断用の記法は、
`RFC8259$r に定義される~JSONに緩く基づくが，
必要な所では それを拡張する。
◎
The diagnostic notation is loosely based on JSON as it is defined in RFC 8259, extending it where needed.
</p>

<ul>
	<li>
<p>
この記法は、
次に挙げるもの用に，~JSON構文を借用する
⇒＃
~number（`~integer$, `~float$）,
`true$i （ `true^dg ）,
`false$i （ `false^dg ）,
`null$i （ `null^dg ）,
`~UTF-8~string$,
`~array$,
`~map$
</p>

<p>
（`~map$は、
~JSONにおいては~objectと呼ばれる
— ここでの診断用の記法は、
`~key$が占める位置に どの~data~itemも許容するよう，~JSONを拡張する）。
</p>
◎
The notation borrows the JSON syntax for numbers (integer and floating-point), True (&gt;true&lt;), False (&gt;false&lt;), Null (&gt;null&lt;), UTF-8 strings, arrays, and maps (maps are called objects in JSON; the diagnostic notation extends JSON here by allowing any data item in the key position).＼
</li>
	<li>
`undefined$i は、
~JSと同じく `undefined^dg と書かれる。
◎
Undefined is written &gt;undefined&lt; as in JavaScript.＼
</li>
	<li>
非-有限な`~float$
— ~Infinity, −~Infinity, ~NaN —
は、
そのまま［
`Infinity^dg, `-Infinity^dg, `NaN^dg
］として書かれる
（これらは、
~JSONにおいては許容されないが，~JSおいて書かれ得る仕方でもある）。
◎
The non-finite floating-point numbers Infinity, -Infinity, and NaN are written exactly as in this sentence (this is also a way they can be written in JavaScript, although JSON does not allow them).＼
</li>
	<li>
<p>
`~tag$は、
`~tag番号$用の~integer~numberに［
丸括弧で括られた`~tag内容$
］が後続するものとして書かれる。
◎
A tag is written as an integer number for the tag number, followed by the tag content in parentheses;＼
</p>

<p>
一例として、
~RFC 3339 （~ISO 8601）に指定される形式による日付は，
次の (A) あるいは (A) に等価な相対~時刻 (B) として記すこともできる
⇒＃
(A) `0("2013-03-21T20:04:00Z")^dg ／
(B) `1(1363896240)^dg
◎
for instance, a date in the format specified by RFC 3339 (ISO 8601) could be notated as:
• 0("2013-03-21T20:04:00Z")
or the equivalent relative time as the following:
• 1(1363896240)
</p>
	</li>
	<li>
<p>
`~byte~string$は、
各種~base-符号化法のうちいずれかで記される
— それらは、
補充~文字を伴わず,
一重-引用符で括られ,
次が接頭される
⇒＃
~base16用には `h^dg ／
~base32用には `b32^dg ／
~base32hex用には `h32^dg ／
~base64用には `b64^dg ／
~base64url用には `b64^dg
◎
Byte strings are notated in one of the base encodings, without padding, enclosed in single quotes, prefixed by &gt;h&lt; for base16, &gt;b32&lt; for base32, &gt;h32&lt; for base32hex, &gt;b64&lt; for base64 or base64url＼
</p>

<p>
（実際の符号化法は重合しないので、
これらの~stringは【どの~base-符号化法によるかは】一義的であり続ける）。
例えば，`~byte~string$ `12345678^X は、
次に挙げるどれで書くこともできる
⇒＃
`h'12345678'^dg ／
`b32'CI2FM6A'^dg ／
`b64'EjRWeA'^dg
◎
(the actual encodings do not overlap, so the string remains unambiguous). For example, the byte string 0x12345678 could be written h'12345678', b32'CI2FM6A', or b64'EjRWeA'.
</p>

	</li>
	<li>
`単純~値$のうち，何も【意味論が】アテガわれていないものは、
`simple()^dg として
— 丸括弧~内に その値を与える~integerを伴って —
与えられる。
例えば `simple(42)^dg は、［
`~major型$ `7$mj, 値 42
］を指示する。
◎
Unassigned simple values are given as "simple()" with the appropriate integer in the parentheses. For example, "simple(42)" indicates major type 7, value 42.
</li>
</ul>

<p>
ここに定義される診断用の記法に有用な拡張のいくつかは、
`RFC8610$r `§ 拡張された診断用の記法（ EDN ）＠~RFCx/rfc8610#appendix-G$
にて供される。
類似に，この記法は、
別々な文書において， `NaN payload^en 用の文書化を供するために拡張され得る
— それについては、この文書は受持たない。
◎
A number of useful extensions to the diagnostic notation defined here are provided in Appendix G of [RFC8610], "Extended Diagnostic Notation" (EDN). Similarly, this notation could be extended in a separate document to provide documentation for NaN payloads, which are not covered in this document.
</p>

		<section id="encoding-indicators">
<h3 title="Encoding Indicators">8.1. 符号化法~指示子</h3>

<p>
ときには、［
いくつかある代替な表現のうち どれが実際に利用されたか
］を［
診断用の記法により指示する
］ことが有用になることもある
— 例えば，
診断用の復号器により `1.5^dg と書かれた ある~data~itemは、［
`半-精度$／`単-精度$／`倍-精度$
］のうち どの`~float$として符号化されたものか~~判別できない。
◎
Sometimes it is useful to indicate in the diagnostic notation which of several alternative representations were actually used; for example, a data item written &gt;1.5&lt; by a diagnostic decoder might have been encoded as a half-, single-, or double-precision float.
</p>

<p>
規約として、［［
英数字, ~underscore
］のみからなり，最初の文字は~underscoreである文字~並び
］
— 例： `_^dg ／ `_3^dg —
は，符号化法の指示子を成す
— この情報に関心がない者は、
それらを無視できる。
符号化法~指示子は、
常に省略可能である。
◎
The convention for encoding indicators is that anything starting with an underscore and all following characters that are alphanumeric or underscore is an encoding indicator, and can be ignored by anyone not interested in this information. For example, _ or _3. Encoding indicators are always optional.
</p>

<p>
［
~data~itemが`不定長$な形式で表現されたこと
］を指示するためとして、［
`~map$の左~波括弧／`~array$の左~角括弧
］の後に 1 個の単独の~underscoreを書ける。
例えば， `[_ 1, 2s]^dg は、［
`不定長$な表現が，~data~item [1, 2] を表現するために利用された
］ことを指示する。
◎
A single underscore can be written after the opening brace of a map or the opening bracket of an array to indicate that the data item was represented in indefinite-length format. For example, [_ 1, 2] contains an indicator that an indefinite-length representation was used to represent the data item [1, 2].
</p>

<p>
［
~underscoreのうち，数字 %n が後続するもの
］は、［
先行している~item
（あるいは、［
`~array$／`~map$
］用には，先行している［
角括弧／波括弧
］で開始している~item）
は、
`追加l情報$の値 ( 24 ~PLUS %n ) を伴って符号化されたこと
］を指示する。
例えば，
`1.5_1^dg は`半-精度~float$である一方、
`1.5_3^dg は`倍-精度~float$として符号化されたものである。
この符号化法~指示子は、
`A§ においては示されない。
（したがって、
符号化法~指示子 `_^dg は全部的な形 `_7^dg の略語であり【なぜ？】，利用されないことに注意。）
◎
An underscore followed by a decimal digit n indicates that the preceding item (or, for arrays and maps, the item starting with the preceding bracket or brace) was encoded with an additional information value of 24+n. For example, 1.5_1 is a half-precision floating-point number, while 1.5_3 is encoded as double precision. This encoding indicator is not shown in Appendix A. (Note that the encoding indicator "_" is thus an abbreviation of the full form "_7", which is not used.)
</p>

<p>
`不定長$な［
`~byte~string$／`~text~string$
］を成す~chunk構造の詳細は、［
`(_ h'0123', h'4567')^dg ／ `(_ "foo", "bar")^dg
］の形で記せる。
しかしながら，`不定長$な~stringが 0 個の~chunkからなる場合、
`(_ )^dg は［
`~byte~string$（ `5fff^X ）／`~text~string$（ `7fff^X ）
］どちらが意味されるのか多義的になるので，
この形は利用されない
— 代わりに，［
~chunkが無い事例~用に限るものとして予約される基本的な形
］［
`''_^dg ／ `""_^dg
］を利用できる。
これは、［
空な（許可されるが，本当に有用ではない）~chunkたち のみからなる符号化
］用の短い形ではない
— そのような符号化は、
当の~chunk構造を保全するよう，［
`(_ '')^dg ／ `(_ "")^dg
］, 等々として記される必要がある。
◎
The detailed chunk structure of byte and text strings of indefinite length can be notated in the form (_ h'0123', h'4567') and (_ "foo", "bar"). However, for an indefinite-length string with no chunks inside, (_ ) would be ambiguous as to whether a byte string (0x5fff) or a text string (0x7fff) is meant and is therefore not used. The basic forms ''_ and ""_ can be used instead and are reserved for the case of no chunks only -- not as short forms for the (permitted, but not really useful) encodings with only empty chunks, which need to be notated as (_ ''), (_ ""), etc., to preserve the chunk structure.
</p>

		</section>
	</section>
	<section id="ianacons">
<h2 title="IANA Considerations">9. ~IANA考慮点</h2>

<p>
~IANAは、
新たな~CBOR値~用として 2 つの~registryを作成した。
これらの~registryは，別々であり、
他の~registryの傘下にはないことに加え，
`RFC8126$r 内の規則に従う。
~IANAはまた、［
新たな~MIME型【 `9.3§ 】,
それに結付けられる~CoAP内容~形式~entry【 `9.4§ 】,
有構造~構文~接尾辞【 `9.5§ 】
］もアテガった。
◎
IANA has created two registries for new CBOR values. The registries are separate, that is, not under an umbrella registry, and follow the rules in [RFC8126]. IANA has also assigned a new media type, an associated CoAP Content-Format entry, and a structured syntax suffix.
</p>

		<section id="ianasimple">
<h3 title="CBOR Simple Values Registry">9.1. ~CBOR単純~値~registry</h3>

<p>
~IANAは、
`IANA.cbor-simple-values$r にて，
`~CBOR単純~値~registry^cite を作成した。
その初期~値は、
`表0 4＠#fpnoconttbl2$
に示される。
◎
IANA has created the "Concise Binary Object Representation (CBOR) Simple Values" registry at [IANA.cbor-simple-values]. The initial values are shown in Table 4.
</p>

<p>
範囲 { 0 〜 19 } 内の新たな~entryは、
`標準~化を通して$ `RFC8126$r アテガわれる。
~IANAが［
~~連続的な~block（もし在れば【？】）用に より低い【？】~numberを予約する
］ために［
~number 16 から開始する値
］を割振ることが示唆される。
◎
New entries in the range 0 to 19 are assigned by Standards Action [RFC8126]. It is suggested that IANA allocate values starting with the number 16 in order to reserve the lower numbers for contiguous blocks (if any).
</p>

<p>
範囲 { 32 〜 255 } 内の新たな~entryは、
`仕様が要求され$る下でアテガわれる。
【 `RFC8126$r 】。
◎
New entries in the range 32 to 255 are assigned by Specification Required.
</p>

		</section>
		<section id="ianatags">
<h3 title="CBOR Tags Registry">9.2. ~CBOR~tag~registry</h3>

<p>
~IANAは、
`IANA.cbor-tags$r にて
`~CBOR~tag~registry^cite を作成した。
`RFC7049$r にて定義された各`~tag$は、
`3.4§ にて詳細に述べられる
— 他の`~tag$は，そのときから すでに定義された。
◎
IANA has created the "Concise Binary Object Representation (CBOR) Tags" registry at [IANA.cbor-tags]. The tags that were defined in [RFC7049] are described in detail in Section 3.4, and other tags have already been defined since then.
</p>

<div class="p">
<p>
新たな~entryのうち：
</p>
<ul>
	<li>
範囲 { `0^tag 〜 `23^tag } （先頭~byteのみ）
に入るものは、
`標準~化を通して$アテガわれる。
</li>
	<li>
次に挙げる範囲に入るものは、
`仕様が要求され$る下でアテガわれる
⇒＃
{ `24^tag 〜 `255^tag } （先頭~byte + 1 ~byte）,
{ `256^tag 〜 `32767^tag } （先頭~byte + 2 ~byteの下~半分）
</li>
	<li>
次に挙げる範囲に入るものは、
`先着順に~serveされ$る下でアテガわれる
⇒＃
{ `32768^tag 〜 `65535^tag } （先頭~byte + 2 ~byte の上~半分）,
{ `65536^tag 〜 `4294967295^tag } （先頭~byte + 4 ~byte）,
{ `429496710^tag 〜 `18446744073709551615^tag } （先頭~byte + 8 ~byte）
</li>
</ul>
◎
New entries in the range 0 to 23 ("1+0") are assigned by Standards Action. New entries in the ranges 24 to 255 ("1+1") and 256 to 32767 (lower half of "1+2") are assigned by Specification Required. New entries in the range 32768 to 18446744073709551615 (upper half of "1+2", "1+4", and "1+8") are assigned by First Come First Served.＼
</div>

<p>
登録~要請~用の雛形は：
◎
The template for registration requests is:
</p>
<ul>
	<li>
~data~item
◎
Data item
</li>
	<li>
意味論（短い形）
◎
Semantics (short form)
</li>
</ul>

<p>
加えて、
`先着順に~serveされ$る要請は，次を含むべきである：
◎
In addition, First Come First Served requests should include:
</p>
<ul>
	<li>
連絡先
◎
Point of contact
</li>
	<li>
意味論の記述（~URL）
— この記述は省略可能であり、
~URLは［
~Internet-Draftや~web~page
］の様な何かを指せる。
◎
Description of semantics (URL) -- This description is optional; the URL can point to something like an Internet-Draft or a web page.
</li>
</ul>

<p>
申請者は、
`先着順に~serveされ$る範囲を演習していて，［
32 ~bitでは表現-可能でない（すなわち， `4294967295^tag を超える）`~tag番号$
］用に示唆を為している場合には、［
64 ~bit~numberを~supportしない実装との相互運用能も抑制され得る
］ことを自覚するべきである。
◎
Applicants exercising the First Come First Served range and making a suggestion for a tag number that is not representable in 32 bits (i.e., larger than 4294967295) should be aware that this could reduce interoperability with implementations that do not support 64-bit numbers.
</p>

		</section>
		<section id="media-type-mime-type">
<h3 title="Media Types Registry">9.3. ~MIME型~registry</h3>

<p>
［
単独の`符号化された~data~item$
］用の~MIME型 `RFC6838$r は、
~MIME型~registry `IANA.media-types$r にて定義されるとおり，
`application/cbor^c である：
◎
The Internet media type [RFC6838] ("MIME type") for a single encoded CBOR data item is "application/cbor" as defined in the "Media Types" registry [IANA.media-types]:
</p>
<ul>
	<li>
型~名
⇒
`application^c
◎
Type name:
• application
</li>
	<li>
下位-型~名
⇒
`cbor^c
◎
Subtype name:
• cbor
</li>
	<li>
要求される~parameter
⇒
可用でない
◎
Required parameters:
• n/a
</li>
	<li>
省略可能な~parameter
⇒
可用でない
◎
Optional parameters:
• n/a
</li>
	<li>
符号化法の考慮点
⇒
~binary
◎
Encoding considerations:
• Binary
</li>
	<li>
~securityの考慮点
⇒
~RFC 8949 （この仕様） `10§ を見よ。
◎
Security considerations:
• See Section 10 of RFC 8949.
</li>
	<li>
相互運用能の考慮点
⇒
可用でない
◎
Interoperability considerations:
• n/a
</li>
	<li>
公表された仕様
⇒
~RFC 8949
◎
Published specification:
• RFC 8949
</li>
	<li>
この~MIME型を利用する応用
⇒
多数
◎
Applications that use this media type:
• Many
</li>
	<li>
<p>
追加的な情報
◎
Additional information:
</p>
		<ul>
			<li>
`Magic number(s)^en
⇒
可用でない
◎
Magic number(s):
• n/a
</li>
			<li>
~file拡張子
⇒
`.cbor^c
◎
File extension(s):
• .cbor
</li>
			<li>
`Macintosh file type code(s)^en
⇒
可用でない
◎
Macintosh file type code(s):
• n/a
</li>
		</ul>
	</li>
	<li>
さらなる情報の連絡先を成す `Person &amp; email address^en
⇒
~IETF~CBOR~WG (cbor@ietf.org) ／
~IETF `Applications and Real-Time Area^en (art@ietf.org)
◎
Person &amp; email address to contact for further information
• IETF CBOR Working Group (cbor@ietf.org) or IETF Applications and Real-Time Area (art@ietf.org)
</li>
	<li>
意図される用法
⇒
共通（ `COMMON^en ）
◎
Intended usage:
• COMMON
</li>
	<li>
用法に対する制約
⇒
なし
◎
Restrictions on usage:
• none
</li>
	<li>
著作者
⇒
~IETF~CBOR~WG（ cbor@ietf.org ）
◎
Author:
• IETF CBOR Working Group (cbor@ietf.org)
</li>
	<li>
変更~制御者
⇒
~IESG（ iesg@ietf.org ）
◎
Change controller:
• The IESG (iesg@ietf.org)
</li>
</ul>

		</section>
		<section id="coap-content-format">
<h3 title="CoAP Content-Format Registry">9.4. ~CoAP内容~形式~registry</h3>

<p>
~CBOR用の~CoAP内容~形式
（ `Constrained Application Protocol^en（拘束された応用~protocol）用の `Content-Format^en ）
は、
`~CoRE~parameter~registry^cite
（ `Constrained RESTful Environments Parameters^en ）
`IANA.core-parameters$r の中の
`“~CoAP内容~形式” 下位-~registry＠~IANA-a/core-parameters#content-formats$
］内に登録された：
◎
The CoAP Content-Format for CBOR has been registered in the "CoAP Content-Formats" subregistry within the "Constrained RESTful Environments (CoRE) Parameters" registry [IANA.core-parameters]:
</p>
<ul>
	<li>
~MIME型
⇒
`application/cbor^c
◎
Media Type:
• application/cbor
</li>
	<li>
符号化法
⇒
—【記載なし】
◎
Encoding:
• -
</li>
	<li>
~ID
⇒
60
◎
ID:
• 60
</li>
	<li>
参照
⇒
~RFC 8949
◎
Reference:
• RFC 8949
</li>
</ul>

		</section>
		<section id="the-cbor-structured-syntax-suffix-registration">
<h3 title="Structured Syntax Suffix Registry">9.5. 有構造~構文~接尾辞~registry</h3>

<p>
［
単独の`符号化された~data~item$に基づく~MIME型
］用の有構造~構文~接尾辞 `RFC6838$r は、
`+cbor^c であり，~IANAが
有構造~構文~接尾辞（ `Structured Syntax Suffixes^en ）~registry `IANA.structured-suffix$r
内に登録した：
◎
The structured syntax suffix [RFC6838] for media types based on a single encoded CBOR data item is +cbor, which IANA has registered in the "Structured Syntax Suffixes" registry [IANA.structured-suffix]:
</p>
<ul>
	<li>
名前
⇒
~CBOR（ `Concise Binary Object Representation^en ）
◎
Name:
• Concise Binary Object Representation (CBOR)
</li>
	<li>
`+^c 接尾辞
⇒
`+cbor^c
◎
+suffix:
• +cbor
</li>
	<li>
参照
⇒
~RFC 8949
◎
References:
• RFC 8949
</li>
	<li>
符号化法の考慮点
⇒
~CBORは~binary形式である。
◎
Encoding Considerations:
• CBOR is a binary format.
</li>
	<li>
相互運用能の考慮点
⇒
可用でない
◎
Interoperability Considerations:
• n/a
</li>
	<li>
<p>
素片~識別子の考慮点：
◎
Fragment Identifier Considerations:
</p>
		<ul>
			<li>
`+cbor^c 用に指定される素片~識別子の［
構文と意味論
］は、
"`application/cbor^c" 用に指定されたものと同じになるベキである。
（ ~RFC 8949 の公表~当時は、
"`application/cbor^c" 用に定義された素片~識別~構文は無かった。）
◎
The syntax and semantics of fragment identifiers specified for +cbor SHOULD be as specified for "application/cbor". (At publication of RFC 8949, there is no fragment identification syntax defined for "application/cbor".)
</li>
			<li>
特定の "`xxx/yyy+cbor^c" 用の素片~識別子~用の［
構文と意味論
］は、［
次に該当する事例では `+cbor^c ／
他の事例では "`xxx/yyy+cbor^c"
］用の規則に指定されたとおりに処理するベキである
⇒
［
`+cbor^c にて定義される
］かつ［
当の素片~識別子は `+cbor^c 規則に従って解決される
］
◎
The syntax and semantics for fragment identifiers for a specific "xxx/yyy+cbor" SHOULD be processed as follows:
• For cases defined in +cbor, where the fragment identifier resolves per the +cbor rules, then process as specified in +cbor.
• For cases defined in +cbor, where the fragment identifier does not resolve per the +cbor rules, then process as specified in "xxx/yyy+cbor".
• For cases not defined in +cbor, then process as specified in "xxx/yyy+cbor".
</li>
		</ul>
	</li>
	<li>
~securityの考慮点
⇒
~RFC 8949 の `10§ を見よ。
◎
Security Considerations:
• See Section 10 of RFC 8949.
</li>
	<li>
連絡先
⇒＃
~IETF~CBOR~WG（ cbor@ietf.org ）／
~IETF `Applications and Real-Time Area^en（ art@ietf.org ）
◎
Contact:
• IETF CBOR Working Group (cbor@ietf.org) or IETF Applications and Real-Time Area (art@ietf.org)
</li>
	<li>
著作者／変更~制御者
⇒
~IETF
◎
Author/Change Controller:
• IETF
</li>
</ul>

		</section>
	</section>
	<section id="securitycons">
<h2 title="Security Considerations">10. ~securityの考慮点</h2>

<p>
~networkに面している応用は、
流入してくる~data用の処理~logic内に脆弱性を呈し得る。
複階的な構文解析器は、そのような脆弱性の源になる見込みが高いことが周知である
— ［
ある【~network】~nodeを，~remoteから~crashする能
］, さらには［
~node上で任意な~codeを，~remoteから実行する
］など。
~CBORは、［
アリな所では［
符号化-可能な値の範囲を成す すべてに意味を与える
］ことにより，構文解析器の複階性を抑制する
］ことにより，［
そのような脆弱性を導入する機会を狭める
］よう試みる。
◎
A network-facing application can exhibit vulnerabilities in its processing logic for incoming data. Complex parsers are well known as a likely source of such vulnerabilities, such as the ability to remotely crash a node, or even remotely execute arbitrary code on it. CBOR attempts to narrow the opportunities for introducing such vulnerabilities by reducing parser complexity, by giving the entire range of encodable values a meaning where possible.
</p>

<p>
~CBOR復号器は、［
未検証な入力を処理するときの最初の段
］として利用されることが多いので，
あらゆる型の敵対的な入力
— `~data~item$を復号している~system［
を［
破損する／~overrunする
］／
の制御を達成する
］よう設計され得る入力 —
に対し全部的に準備する必要がある。
~CBOR復号器は、［
すべての入力は敵対的であり得る
］と見做す必要がある
— ある~firewallにより検査されようが,
~TLSなどの~secureな~channel越しに来ようが,
暗号化されようが,
署名されていようが,
信用-済みと~~推定された他の何らかの源から来ようが。
◎
Because CBOR decoders are often used as a first step in processing unvalidated input, they need to be fully prepared for all types of hostile input that may be designed to corrupt, overrun, or achieve control of the system decoding the CBOR data item. A CBOR decoder needs to assume that all input may be hostile even if it has been checked by a firewall, has come over a secure channel such as TLS, is encrypted or signed, or has come from some other source that is presumed trusted.
</p>

<p>
`4.1§は、［
選好されない直列化を利用する~CBOR符号化器
］からの入力に対し［
拘束された~CBOR復号器を利用するとき
］の［
相互運用能における制限
］を成す例を与える。
ある~data~itemが［
そのような拘束された復号器, 全部的な復号器
］両者により消費されるとき、
それは［
内容を［
注入-／操作-
］できる攻撃者により悪用され得る
］~securityの課題に至り得る。
◎
Section 4.1 gives examples of limitations in interoperability when using a constrained CBOR decoder with input from a CBOR encoder that uses a non-preferred serialization. When a single data item is consumed both by such a constrained decoder and a full decoder, it can lead to security issues that can be exploited by an attacker who can inject or manipulate content.
</p>

<p>
この文書~全体を通して論じたとおり、［
一部の状況下においては “等価である” が，他においては “等価でない”
］と見なされ得る多くの値がある。
一つだけ例を挙げると、
~number “1” 用の数量-値は，［
`~integer$, `~bignum$
］どちらでも表出され得る。
~CBOR入力を解釈している~systemは、
~number “1” 用の形として，
両方とも受容するかもしれないし，片方だけ（または両方とも）却下するかもしれない。
そのような［
受容／却下
］には、
解釈された入力を利用している~programに対し，~securityの含意があり得る。
◎
As discussed throughout this document, there are many values that can be considered "equivalent" in some circumstances and "not equivalent" in others. As just one example, the numeric value for the number "one" might be expressed as an integer or a bignum. A system interpreting CBOR input might accept either form for the number "one", or might reject one (or both) forms. Such acceptance or rejection can have security implications in the program that is using the interpreted input.
</p>

<p>
敵対的な入力は、［
~bufferを~overrunする, ~integer算術を［
~overflow／~underflow
］させるその他，復号を妨害する原因になるよう構築され得る。
`~data~item$の［
長さ／~size
］は、
意図的に極めて大きいか, 短か過ぎるものにされるかもしれない。
資源~枯渇~攻撃は、［
~~巨大な~data~item（~string, `~array$, `~map$, 精度が任意な~number）を割振るよう，復号器を誘い込む／
深く入子にされた~itemを設定しておくことにより，~stackの深さを枯渇させる
］よう試みるかもしれない。
復号器は、
適切な資源~管理により，これらの攻撃を軽減する必要がある。
（~sizeが~~巨大な~itemは、
~integer~overflowの脆弱性を悪用しようと試みるものかもしれない。）
◎
Hostile input may be constructed to overrun buffers, to overflow or underflow integer arithmetic, or to cause other decoding disruption. CBOR data items might have lengths or sizes that are intentionally extremely large or too short. Resource exhaustion attacks might attempt to lure a decoder into allocating very big data items (strings, arrays, maps, or even arbitrary precision numbers) or exhaust the stack depth by setting up deeply nested items. Decoders need to have appropriate resource management to mitigate these attacks. (Items for which very large sizes are given can also attempt to exploit integer overflow vulnerabilities.)
</p>

<p>
~CBOR復号器が受容するのは、
定義により，`整形式$な~CBORに限られる
— これは、
その堅牢性を成す最初の段である。
入力が`整形式$な~CBORでない場合、
整形式性の欠如が検出された地点で処理を終わらすことになる。
アリな場合は、［
この地点までに復号された~dataは、
当の~CBOR復号器を利用している応用には何ら影響iしない
］べきである。
◎
A CBOR decoder, by definition, only accepts well-formed CBOR; this is the first step to its robustness. Input that is not well-formed CBOR causes no further processing from the point where the lack of well-formedness was detected. If possible, any data decoded up to this point should have no impact on the application using the CBOR decoder.
</p>

<p>
整形式性を見極めることに加えて、
~CBOR復号器は，~CBOR~dataに対し妥当性~検査も遂行するかもしれない。
代替として、
復号器は，そのような検査を当の復号器を利用している応用に委ねることもできる。
どちらを選ぶかは、
当の復号器において明瞭に文書化される必要がある。
応用は、［
~CBOR~levelにおける妥当性
］のみならず，［
~CBORに直列化された入力が応用~protocolに倣っていること
］も見極める必要もある。
◎
In addition to ascertaining well-formedness, a CBOR decoder might also perform validity checks on the CBOR data. Alternatively, it can leave those checks to the application using the decoder. This choice needs to be clearly documented in the decoder. Beyond the validity at the CBOR level, an application also needs to ascertain that the input is in alignment with the application protocol that is serialized in CBOR.
</p>

<p>
入力に対する検査~自体も，資源を消費し得る。
これは、
通例的には，入力の~sizeに線形である
— すなわち、
攻撃者は，［
防御者が入力~検証に費やした資源
］に比例する資源を費やすようになる必要がある。
しかしながら，攻撃者は、［
自身が生産するより，~target復号器が処理する方が長くかかる
］ように入力を細工-可能かもしれない。
精度が任意な~number用の処理は、
線形な労を超過し得る。
また，［
~memory内で`~map$の表現を築くために，
復号器により利用される一部の~hash~table実装
］は、
何らかの軽減
— ある秘匿な`~key$
（ `SIPHASH_LNCS$r § 7, および `SIPHASH_OPEN$r も見よ）
など —
が使役されない限り， 2 乗に比例する労を費やすよう攻撃され得る。
そのような線形を超える労は、［
入力~検証器，あるいは その前
］にて資源を枯渇させるよう，攻撃者により悪用され得る
— したがって、
~CBOR復号器~実装においては，それらを避ける必要がある。
［
`~tag番号$定義, その実装
］は、
この種類の~security考慮点を追加し得ることに注意
— これは、［
`~tag番号$定義の~security考慮点
］にて さらに論じられるべきである。
◎
The input check itself may consume resources. This is usually linear in the size of the input, which means that an attacker has to spend resources that are commensurate to the resources spent by the defender on input validation. However, an attacker might be able to craft inputs that will take longer for a target decoder to process than for the attacker to produce. Processing for arbitrary-precision numbers may exceed linear effort. Also, some hash-table implementations that are used by decoders to build in-memory representations of maps can be attacked to spend quadratic effort, unless a secret key (see Section 7 of [SIPHASH_LNCS], also [SIPHASH_OPEN]) or some other mitigation is employed. Such superlinear efforts can be exploited by an attacker to exhaust resources at or before the input validator; they therefore need to be avoided in a CBOR decoder implementation. Note that tag number definitions and their implementations can add security considerations of this kind; this should then be discussed in the security considerations of the tag number definition.
</p>

<p>
~CBOR符号化器は、
入力を~networkから直に受信しない
— したがって，~CBOR復号器と同じ仕方で直に攻撃-可能ではない。
しかしながら，~CBOR符号化器は、
実装~内の別の~levelから入力をとる~APIを備えることが多く，
その~APIを通して攻撃され得る。
その~APIの設計と実装は、［
その~call元~の挙動は［
敵対的な入力／~code化における誤ち
］に基づき得る
］ものと見做すべきである。
それは、［
~buffer~overrun, ~integer算術の~overflowや~underflow
］その他，そのような［
符号化器を妨害することを目指す~error
］用に入力を検査するべきである。
◎
CBOR encoders do not receive input directly from the network and are thus not directly attackable in the same way as CBOR decoders. However, CBOR encoders often have an API that takes input from another level in the implementation and can be attacked through that API. The design and implementation of that API should assume the behavior of its caller may be based on hostile input or on coding mistakes. It should check inputs for buffer overruns, overflow and underflow of integer arithmetic, and other such errors that are aimed to disrupt the encoder.
</p>

<p>
~protocolは［
複数の解釈があり得る所では，単独の解釈に依拠-可能に抑制される
］ような仕方で定義されるべきである。
例えば，攻撃者は、
`妥当$でない入力
— `~map$内の重複な`~key$など —
を用立てることも，
~numberの処理において精度が異なることを悪用することもできる
— ある応用が自身の裁定を［
別の応用により利用されるものと異なる解釈
］に基づくようにするために。
一貫した解釈を手助けするため、［
符号化器／復号器
］実装は，演算の妥当性を検査する~modeを供するべきである
（ `5.4§ ）。
しかしながら，汎用な復号器は、［
ある応用が入力~dataに対し課す すべての要件
］について知り得ないことに注意
— したがって、
応用は，［
自前の入力~検査ngを遂行すること
］から免れることはない。
また，定義-済みな`~tag番号$の集合は発展するので、
応用は，ある`~tag番号$
— それを利用する汎用な復号器による妥当性~検査ngにおいては，まだ~supportされないそれ —
を使役することもある。
したがって、
汎用な復号器は，自身が［
どの`~tag番号$を~supportするか，それに対し いかなる妥当性~検査ngを供するか
］を文書化する必要がある
— 基本的な~CBOR用のそれ（~UTF-8の検査ng, 重複な`~map~key$の検査ng）のみならず。
◎
Protocols should be defined in such a way that potential multiple interpretations are reliably reduced to a single interpretation. For example, an attacker could make use of invalid input such as duplicate keys in maps, or exploit different precision in processing numbers to make one application base its decisions on a different interpretation than the one that will be used by a second application. To facilitate consistent interpretation, encoder and decoder implementations should provide a validity-checking mode of operation (Section 5.4). Note, however, that a generic decoder cannot know about all requirements that an application poses on its input data; it is therefore not relieving the application from performing its own input checking. Also, since the set of defined tag numbers evolves, the application may employ a tag number that is not yet supported for validity checking by the generic decoder it uses. Generic decoders therefore need to document which tag numbers they support and what validity checking they provide for those tag numbers as well as for basic CBOR (UTF-8 checking, duplicate map key checking).
</p>

<p>
`3.4.3§ は、［
所与の~numberを符号化するときの選択肢として［
基本的な`~integer$に代えて，選好されない`~bignum$表現を利用すること
］には，応用~意味論があるものとは意図されないが、［
~CBOR~dataを受信している ある応用が，
基本的な`汎用~data~model$において復号器を利用している場合
］には，そのような意味論があり得る
］ことを注記する。
この~~不一致は、
この 2 つの意味論が相違する場合に，~securityの課題の原因になる。
したがって，~CBORを利用している応用は、
~CBOR~dataの各~利用に対し，自身が利用している~data~modelを指定する必要がある。
◎
Section 3.4.3 notes that using the non-preferred choice of a bignum representation instead of a basic integer for encoding a number is not intended to have application semantics, but it can have such semantics if an application receiving CBOR data is using a decoder in the basic generic data model. This disparity causes a security issue if the two sets of semantics differ. Thus, applications using CBOR need to specify the data model that they are using for each use of CBOR data.
</p>

<p>
~CBOR~dataを他の形式へ変換することは共通的にある。
多くの事例では、
~CBORは，他の形式より表現力が高い型を備える
— このことは特に、
共通的な~JSONへの変換に該当する。
型~情報の喪失は、［
表現力に劣る~dataを処理している~system
］において，~securityの課題の原因になり得る。
◎
It is common to convert CBOR data to other formats. In many cases, CBOR has more expressive types than other formats; this is particularly true for the common conversion to JSON. The loss of type information can cause security issues for the systems that are processing the less-expressive data.
</p>

<p>
`6.2§ は、
場合によっては共通な用法~局面を成す［
~CBORと~JSONの間での変換-法
］を述べる
— それは、
攻撃者が［
その変換を当の応用が遂行していること
］を知る場合に，攻撃を許容するものにもなる。
◎
Section 6.2 describes a possibly common usage scenario of converting between CBOR and JSON that could allow an attack if the attacker knows that the application is performing the conversion.
</p>

<p>
次における~securityの考慮点も，~CBORに関連する
⇒
`RFC4648$r による［
~base16／~base64
］の利用,
`RFC3629$r による~UTF-8の利用
◎
Security considerations for the use of base16 and base64 from [RFC4648], and the use of UTF-8 from [RFC3629], are relevant to CBOR as well.
</p>

	</section>
	<section id="examples">
<h2 title="Examples of Encoded CBOR Data Items">A. 符号化された~CBOR~data~itemの例</h2>

<p>
この節の `表0 6＠#table_examples$ は、
2 列目に［
~CBORに符号化された値
］を~hexadecimalで，
1 列目に それ用の診断用の記法を供する。
診断用の記法における~string［
"`\u00fc^dg" は，
1 個の~Unicode文字 `00FC^U `LATIN SMALL LETTER U WITH DIAERESIS^cn `ü^smb ／
"`\u6c34^dg" は，
1 個の~Unicode文字 `6C34^U `CJK UNIFIED IDEOGRAPH-6C34^cn `水^smb ／
"`\ud800\udd51^dg" は，
1 個の~Unicode文字 `10151^U (`GREEK ACROPHONIC ATTIC FIFTY STATERS^cn `𐅑^smb
］からなる`~UTF-8~string$を表すことに注意。
（これらの文字は、
~ASCIIのみによる指定が要求されない場合には，［
診断用の記法においては、
~nativeな~UTF-8
【すなわち、 "`ü^dg" 等々，~Unicode文字 そのまま】
でも表現できる
］ことに注意）。
`~bignum$用に供される診断用の記法においては、
それらに意図される数量-値は~decimal~number（例： 18446744073709551616 ）として示される
— ~tag付き`~byte~string$（例： `2(h'010000000000000000'^c ）ではなく。
◎
The following table provides some CBOR-encoded values in hexadecimal (right column), together with diagnostic notation for these values (left column). Note that the string "\u00fc" is one form of diagnostic notation for a UTF-8 string containing the single Unicode character U+00FC (LATIN SMALL LETTER U WITH DIAERESIS, "ü"). Similarly, "\u6c34" is a UTF-8 string in diagnostic notation with a single character U+6C34 (CJK UNIFIED IDEOGRAPH-6C34, "水"), often representing "water", and "\ud800\udd51" is a UTF-8 string in diagnostic notation with a single character U+10151 (GREEK ACROPHONIC ATTIC FIFTY STATERS, "𐅑"). (Note that all these single-character strings could also be represented in native UTF-8 in diagnostic notation, just not if an ASCII-only specification is required.) In the diagnostic notation provided for bignums, their intended numeric value is shown as a decimal number (such as 18446744073709551616) instead of a tagged byte string (such as 2(h'010000000000000000')).
</p>

<table id="table-6">
<caption id="table_examples">
表0 6：
`符号化された~data~item$の例
◎
Table 6: Examples of Encoded CBOR Data Items
</caption>
<thead><tr>
<th>
診断用の記法
◎
Diagnostic

<th>符号化した結果
◎
Encoded
</thead><tbody>

<tr><td>`0^dg
<td>`00^X

<tr><td>`1^dg
<td>`01^X

<tr><td>`10^dg
<td>`0a^X

<tr><td>`23^dg
<td>`17^X

<tr><td>`24^dg
<td>`1818^X

<tr><td>`25^dg
<td>`1819^X

<tr><td>`100^dg
<td>`1864^X

<tr><td>`1000^dg
<td>`1903e8^X

<tr><td>`1000000^dg
<td>`1a000f4240^X

<tr><td>`1000000000000^dg
<td>`1b000000e8d4a51000^X

<tr><td>`18446744073709551615^dg
<td>`1bffffffffffffffff^X

<tr><td>`18446744073709551616^dg
<td>`c249010000000000000000^X

<tr><td>`-18446744073709551616^dg
<td>`3bffffffffffffffff^X

<tr><td>`-18446744073709551617^dg
<td>`c349010000000000000000^X

<tr><td>`-1^dg
<td>`20^X

<tr><td>`-10^dg
<td>`29^X

<tr><td>`-100^dg
<td>`3863^X

<tr><td>`-1000^dg
<td>`3903e7^X

<tr><td>`0.0^dg
<td>`f90000^X

<tr><td>`-0.0^dg
<td>`f98000^X

<tr><td>`1.0^dg
<td>`f93c00^X

<tr><td>`1.1^dg
<td>`fb3ff199999999999a^X

<tr><td>`1.5^dg
<td>`f93e00^X

<tr><td>`65504.0^dg
<td>`f97bff^X

<tr><td>`100000.0^dg
<td>`fa47c35000^X

<tr><td>`3.4028234663852886e+38^dg
<td>`fa7f7fffff^X

<tr><td>`1.0e+300^dg
<td>`fb7e37e43c8800759c^X

<tr><td>`5.960464477539063e-8^dg
<td>`f90001^X

<tr><td>`0.00006103515625^dg
<td>`f90400^X

<tr><td>`-4.0^dg
<td>`f9c400^X

<tr><td>`-4.1^dg
<td>`fbc010666666666666^X

<tr><td>`Infinity^dg
<td>`f97c00^X

<tr><td>`NaN^dg
<td>`f97e00^X

<tr><td>`-Infinity^dg
<td>`f9fc00^X

<tr><td>`Infinity^dg
<td>`fa7f800000^X

<tr><td>`NaN^dg
<td>`fa7fc00000^X

<tr><td>`-Infinity^dg
<td>`faff800000^X

<tr><td>`Infinity^dg
<td>`fb7ff0000000000000^X

<tr><td>`NaN^dg
<td>`fb7ff8000000000000^X

<tr><td>`-Infinity^dg
<td>`fbfff0000000000000^X

<tr><td>`false^dg
<td>`f4^X

<tr><td>`true^dg
<td>`f5^X

<tr><td>`null^dg
<td>`f6^X

<tr><td>`undefined^dg
<td>`f7^X

<tr><td>`simple(16)^dg
<td>`f0^X

<tr><td>`simple(255)^dg
<td>`f8ff^X

<tr><td>`0("2013-03-21T20:04:00Z")^dg
<td>`c074323031332d30332d32315432303a 30343a30305a^X

<tr><td>`1(1363896240)^dg
<td>`c11a514b67b0^X

<tr><td>`1(1363896240.5)^dg
<td>`c1fb41d452d9ec200000^X

<tr><td>`23(h'01020304')^dg
<td>`d74401020304^X

<tr><td>`24(h'6449455446')^dg
<td>`d818456449455446^X

<tr><td>`32("http://www.example.com")^dg
<td>`d82076687474703a2f2f7777772e6578 616d706c652e636f6d^X

<tr><td>`h''^dg
<td>`40^X

<tr><td>`h'01020304'^dg
<td>`4401020304^X

<tr><td>`""^dg
<td>`60^X

<tr><td>`"a"^dg
<td>`6161^X

<tr><td>`"IETF"^dg
<td>`6449455446^X

<tr><td>`"\"\\"^dg
<td>`62225c^X

<tr><td>`"\u00fc"^dg
<td>`62c3bc^X

<tr><td>`"\u6c34"^dg
<td>`63e6b0b4^X

<tr><td>`"\ud800\udd51"^dg
<td>`64f0908591^X

<tr><td>`[]^dg
<td>`80^X

<tr><td>`[1, 2, 3]^dg
<td>`83010203^X

<tr><td>`[1, [2, 3], [4, 5]]^dg
<td>`8301820203820405^X

<tr><td>`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]^dg
<td>`98190102030405060708090a0b0c0d0e 0f101112131415161718181819^X

<tr><td>`{}^dg
<td>`a0^X

<tr><td>`{1: 2, 3: 4}^dg
<td>`a201020304^X

<tr><td>`{"a": 1, "b": [2, 3]}^dg
<td>`a26161016162820203^X

<tr><td>`["a", {"b": "c"}]^dg
<td>`826161a161626163^X

<tr><td>`{"a": "A", "b": "B", "c": "C", "d": "D", "e": "E"}^dg
<td>`a5616161416162614261636143616461 4461656145^X

<tr><td>`(_ h'0102', h'030405')^dg
<td>`5f42010243030405ff^X

<tr><td>`(_ "strea", "ming")^dg
<td>`7f657374726561646d696e67ff^X

<tr><td>`[_ ]^dg
<td>`9fff^X

<tr><td>`[_ 1, [2, 3], [_ 4, 5]]^dg
<td>`9f018202039f0405ffff^X

<tr><td>`[_ 1, [2, 3], [4, 5]]^dg
<td>`9f01820203820405ff^X

<tr><td>`[1, [2, 3], [_ 4, 5]]^dg
<td>`83018202039f0405ff^X

<tr><td>`[1, [_ 2, 3], [4, 5]]^dg
<td>`83019f0203ff820405^X

<tr><td>`[_ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]^dg
<td>`9f0102030405060708090a0b0c0d0e0f 101112131415161718181819ff^X

<tr><td>`{_ "a": 1, "b": [_ 2, 3]}^dg
<td>`bf61610161629f0203ffff^X

<tr><td>`["a", {_ "b": "c"}]^dg
<td>`826161bf61626163ff^X

<tr><td>`{_ "Fun": true, "Amt": -2}^dg
<td>`bf6346756ef563416d7421ff^X

</tbody>
</table>

	</section>
	<section id="jump-table">
<h2 title="Jump Table for Initial Byte">B. 先頭~byte用の分岐表</h2>

<p>
~~簡潔にするため、
この分岐表には，
将来の拡張~用に予約される`先頭~byte$
【すなわち、`追加l情報$ ~IN { `28^ai, `29^ai, `30^ai } ／一部の`~major型$における `追加l情報$ `31^ai 】
は示されない。
また、［
任意選択な特能~用に利用され得るもの
］として選定された`先頭~byte$【？】に限り示す。
（すべての無符号`~integer$は、~network~byte順序とする。）
◎
For brevity, this jump table does not show initial bytes that are reserved for future extension. It also only shows a selection of the initial bytes that can be used for optional features. (All unsigned integers are in network byte order.)
</p>

<div>
<table id="table-7">
<caption id="jumptable">
表0 7：
`先頭~byte$用の分岐表
【“構造” 列に現れる %n は`引数$を表す。】
</caption>
<thead>
<tr><th>`先頭~byte$
<th>意味論
<th>構造
</thead><tbody>

<tr><td>`00^X 〜 `17^X
<td>無符号`~integer$
<td>先頭~byteのみ（ %n ~IN { `00^X 〜 `17^X } ）

<tr><td>`18^X
<td>無符号`~integer$
<td>1 ~byteからなる ~uint8_t が後続する

<tr><td>`19^X
<td>無符号`~integer$
<td>2 ~byteからなる ~uint16_t が後続する

<tr><td>`1a^X
<td>無符号`~integer$
<td>4 ~byteからなる ~uint32_t が後続する

<tr><td>`1b^X
<td>無符号`~integer$
<td>8 ~byteからなる ~uint64_t が後続する

<tr><td>`20^X 〜 `37^X
<td>負な`~integer$
<td>先頭~byteのみ（ −1 ~MINUS %n が値を与える）

<tr><td>`38^X
<td>負な`~integer$
<td>%n 用に 1 ~byteからなる ~uint8_t が後続する

<tr><td>`39^X
<td>負な`~integer$
<td>%n 用に 2 ~byteからなる ~uint16_t が後続する

<tr><td>`3a^X
<td>負な`~integer$ 
<td>%n 用に 4 ~byteからなる ~uint32_t が後続する

<tr><td>`3b^X
<td>負な`~integer$
<td>%n 用に 8 ~byteからなる ~uint64_t が後続する

<tr><td>`40^X 〜 `57^X
<td>`~byte~string$
<td>%n 個の~byteが後続する
（ %n ~IN { `00^X 〜 `17^X } ）

<tr><td>`58^X
<td>`~byte~string$
<td>%n 用に 1 ~byteからなる ~uint8_t,
さらに %n 個の~byteが後続する

<tr><td>`59^X
<td>`~byte~string$
<td>%n 用に 2 ~byteからなる ~uint16_t,
さらに %n 個の~byteが後続する

<tr><td>`5a^X
<td>`~byte~string$
<td>%n 用に 4 ~byteからなる ~uint32_t,
さらに %n 個の~byteが後続する

<tr><td>`5b^X
<td>`~byte~string$
<td>%n 用に 8 ~byteからなる ~uint64_t, さらに %n 個の~byteが後続する

<tr><td>`5f^X
<td>`~byte~string$
<td>0 個以上の`~byte~string$が後続する／
`~break$ により終了される

<tr><td>`60^X 〜 `77^X
<td>`~UTF-8~string$
<td>%n 個の~byteが後続する
（ %n ~IN { `00^X 〜 `17^X } ）

<tr><td>`78^X
<td>`~UTF-8~string$
<td>%n 用に 1 ~byteからなる ~uint8_t,
さらに %n 個の~byteが後続する

<tr><td>`79^X
<td>`~UTF-8~string$
<td>%n 用に 2 ~byteからなる ~uint16_t,
さらに %n 個の~byteが後続する

<tr><td>`7a^X
<td>`~UTF-8~string$
<td>%n 用に 4 ~byteからなる ~uint32_t,
さらに %n 個の~byteが後続する

<tr><td>`7b^X
<td>`~UTF-8~string$
<td>%n 用に 8 ~byteからなる ~uint64_t,
さらに %n 個の~byteが後続する

<tr><td>`7f^X
<td>`~UTF-8~string$
<td>0 個以上の`~UTF-8~string$が後続する／
`~break$ により終了される

<tr><td>`80^X 〜 `97^X
<td>`~array$
<td>%n 個の~data~itemが後続する
（ %n ~IN { `00^X 〜 `17^X } ）

<tr><td>`98^X
<td>`~array$
<td>%n 用に 1 ~byteからなる ~uint8_t,
さらに %n 個の~data~itemが後続する

<tr><td>`99^X
<td>`~array$
<td>%n 用に 2 ~byteからなる ~uint16_t,
さらに %n 個の~data~itemが後続する

<tr><td>`9a^X
<td>`~array$
<td>%n 用に 4 ~byteからなる ~uint32_t,
さらに %n 個の~data~itemが後続する

<tr><td>`9b^X
<td>`~array$
<td>%n 用に 8 ~byteからなる ~uint64_t,
さらに %n 個の~data~itemが後続する

<tr><td>`9f^X
<td>`~array$
<td>0 個以上の~data~itemが後続する／
`~break$ により終了される

<tr><td>`a0^X 〜 `b7^X
<td>`~map$
<td>%n （ ~IN { `00^X 〜 `17^X } ）個の`~entry$が後続する
（各`~entry$は、~~連続する 2 個の`~data~item$からなる）

<tr><td>`b8^X
<td>`~map$
<td>%n 用に 1 ~byteからなる ~uint8_t,
さらに %n 個の`~entry$が後続する

<tr><td>`b9^X
<td>`~map$
<td>%n 用に 2 ~byteからなる ~uint16_t,
さらに %n 個の`~entry$が後続する

<tr><td>`ba^X
<td>`~map$
<td>%n 用に 4 ~byteからなる ~uint32_t,
さらに %n 個の`~entry$が後続する

<tr><td>`bb^X
<td>`~map$
<td>%n 用に 8 ~byteからなる ~uint64_t,
さらに %n 個の`~entry$が後続する

<tr><td>`bf^X
<td>`~map$
<td>0 個以上の`~entry$後続する／
`~break$ により終了される

<tr><td>`c0^X
<td>`~tag$（~textに基づく日時
<td>~data~itemが後続する
— `3.4.1§を見よ

<tr><td>`c1^X
<td>`~tag$（~epochに基づく日時
<td>~data~itemが後続する
— `3.4.2§を見よ

<tr><td>`c2^X
<td>`~tag$（無符号`~bignum$）
<td>`~byte~string$を成す 1 個の~data~itemが後続する
— `3.4.3§ を見よ

<tr><td>`c3^X
<td>`~tag$（負な`~bignum$）
<td>`~byte~string$を成す 1 個の~data~itemが後続する
— `3.4.3§ を見よ

<tr><td>`c4^X
<td>`~tag$（`~decimal小数$）
<td>`~array$を成す 1 個の~data~itemが後続する
— `3.4.4§ を見よ

<tr><td>`c5^X
<td>`~tag$（`~bigfloat$）
<td>`~array$を成す 1 個の~data~itemが後続する
— `3.4.4§ を見よ

<tr><td>`c6^X 〜 `d4^X
<td>`~tag$（他の~tag）
<td>1 個の~data~itemが後続する

<tr><td>`d5^X 〜 `d7^X
<td>`~tag$（期待される変換）
<td>1 個の~data~itemが後続する
— `3.4.5.2§ を見よ

<tr><td>`d8^X 〜 `db^X
<td>`~tag$（他の~tag）
<td>`~tag番号$を成す［
1／2／4／8
］個の~byte, さらに 1 個の~data~itemが後続する

<tr><td>`e0^X 〜 `f3^X
<td>`単純~値$
<td>先頭~byteのみ

<tr><td>`f4^X
<td>`単純~値$ `false$i
<td>先頭~byteのみ

<tr><td>`f5^X
<td>`単純~値$ `true$i
<td>先頭~byteのみ

<tr><td>`f6^X
<td>`単純~値$ `null$i
<td>先頭~byteのみ

<tr><td>`f7^X
<td>`単純~値$ `undefined$i
<td>先頭~byteのみ

<tr><td>`f8^X
<td>`単純~値$
<td>1 個の~byte が後続する

<tr><td>`f9^X
<td>`半-精度~float$
<td>2 ~byteからなる`~float$

<tr><td>`fa^X
<td>`単-精度~float$
<td>4 ~byteからなる`~float$

<tr><td>`fb^X
<td>`倍-精度~float$
<td>8 ~byteからなる`~float$

<tr><td>`ff^X
<td>`~break$
<td>

</tbody>
</table>
◎
Table 7: Jump Table for Initial Byte
◎
Byte｜Structure/Semantics
0x00..0x17｜unsigned integer 0x00..0x17 (0..23)
0x18｜unsigned integer (one-byte uint8_t follows)
0x19｜unsigned integer (two-byte uint16_t follows)
0x1a｜unsigned integer (four-byte uint32_t follows)
0x1b｜unsigned integer (eight-byte uint64_t follows)
0x20..0x37｜negative integer -1-0x00..-1-0x17 (-1..-24)
0x38｜negative integer -1-n (one-byte uint8_t for n follows)
0x39｜negative integer -1-n (two-byte uint16_t for n follows)
0x3a｜negative integer -1-n (four-byte uint32_t for n follows)
0x3b｜negative integer -1-n (eight-byte uint64_t for n follows)
0x40..0x57｜byte string (0x00..0x17 bytes follow)
0x58｜byte string (one-byte uint8_t for n, and then n bytes follow)
0x59｜byte string (two-byte uint16_t for n, and then n bytes follow)
0x5a｜byte string (four-byte uint32_t for n, and then n bytes follow)
0x5b｜byte string (eight-byte uint64_t for n, and then n bytes follow)
0x5f｜byte string, byte strings follow, terminated by "break"
0x60..0x77｜UTF-8 string (0x00..0x17 bytes follow)
0x78｜UTF-8 string (one-byte uint8_t for n, and then n bytes follow)
0x79｜UTF-8 string (two-byte uint16_t for n, and then n bytes follow)
0x7a｜UTF-8 string (four-byte uint32_t for n, and then n bytes follow)
0x7b｜UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)
0x7f｜UTF-8 string, UTF-8 strings follow, terminated by "break"
0x80..0x97｜array (0x00..0x17 data items follow)
0x98｜array (one-byte uint8_t for n, and then n data items follow)
0x99｜array (two-byte uint16_t for n, and then n data items follow)
0x9a｜array (four-byte uint32_t for n, and then n data items follow)
0x9b｜array (eight-byte uint64_t for n, and then n data items follow)
0x9f｜array, data items follow, terminated by "break"
0xa0..0xb7｜map (0x00..0x17 pairs of data items follow)
0xb8｜map (one-byte uint8_t for n, and then n pairs of data items follow)
0xb9｜map (two-byte uint16_t for n, and then n pairs of data items follow)
0xba｜map (four-byte uint32_t for n, and then n pairs of data items follow)
0xbb｜map (eight-byte uint64_t for n, and then n pairs of data items follow)
0xbf｜map, pairs of data items follow, terminated by "break"
0xc0｜text-based date/time (data item follows; see Section 3.4.1)
0xc1｜epoch-based date/time (data item follows; see Section 3.4.2)
0xc2｜unsigned bignum (data item "byte string" follows)
0xc3｜negative bignum (data item "byte string" follows)
0xc4｜decimal Fraction (data item "array" follows; see Section 3.4.4)
0xc5｜bigfloat (data item "array" follows; see Section 3.4.4)
0xc6..0xd4｜(tag)
0xd5..0xd7｜expected conversion (data item follows; see Section 3.4.5.2)
0xd8..0xdb｜(more tags; 1/2/4/8 bytes of tag number and then a data item follow)
0xe0..0xf3｜(simple value)
0xf4｜false
0xf5｜true
0xf6｜null
0xf7｜undefined
0xf8｜(simple value, one byte follows)
0xf9｜half-precision float (two-byte IEEE 754)
0xfa｜single-precision float (four-byte IEEE 754)
0xfb｜double-precision float (eight-byte IEEE 754)
0xff｜"break" stop code
</div>

	</section>
	<section id="pseudocode">
<h2 title="Pseudocode">C. 疑似-~code</h2>

<p>
`~data~item$の整形式性は、
下の`疑似-~code 1＠#pseudo$ により，検査できる。
入力~dataが`整形式$になるのは、［
この疑似-~codeが “失敗-” しない
【すなわち `fail()^c を~callしない】
］かつ［
この疑似-~codeを実行した後，当の入力~内に残された~byte列は無い
（`~streamして$いる応用~内を除く）
］とき, そのときに限られる。
◎
The well-formedness of a CBOR item can be checked by the pseudocode in Figure 1. The data is well-formed if and only if:
• the pseudocode does not "fail";
• after execution of the pseudocode, no bytes are left in the input (except in streaming applications).
</p>

<p>
この疑似-~codeにおいては：
◎
The pseudocode has the following prerequisites:
</p>
<ul>
	<li>
`take()^c 関数は、
所与の %n に対し，
入力~dataから %n 個の~byteを読取って`~byte~string$として返す。
%n 個の~byteは可用でない場合、
この関数は失敗する。
◎
take(n) reads n bytes from the input data and returns them as a byte string. If n bytes are no longer available, take(n) fails.
</li>
	<li>
`uint()^c 関数は、
所与の`~byte~string$を~network~byte順序で解釈することにより，無符号`~integer$に変換する。
◎
uint() converts a byte string into an unsigned integer by interpreting the byte string in network byte order.
</li>
	<li>
各種~算術は、
~C言語と同じに働く。
◎
Arithmetic works as in C.
</li>
	<li>
すべての変数は、
必要に足る範囲の無符号`~integer$である。
◎
All variables are unsigned integers of sufficient range.
</li>
</ul>

<p>
`well_formed()^c 関数は、
当の~itemは`整形式$とするとき，［
`確定長$な~itemに対しては その`~major型$／
`不定長$な~itemに対しては 99
］を返すことに注意
（ `~break$ に対しては， %breakable ~EQ ~T の場合に限り −1 を返す）。
これは、［
`不定長$な~stringは、
~chunkとして`確定長$な~stringしか包含しない
］ことを見極めるため，
`well_formed_indefinite()^c 内で利用される。
◎
Note that well_formed returns the major type for well-formed definite-length items, but 99 for an indefinite-length item (or -1 for a "break" stop code, only if breakable is set). This is used in well_formed_indefinite to ascertain that indefinite-length strings only contain definite-length strings as chunks.
</p>

<figure id="pseudo">
<pre class="sourcecode">
well_formed(%breakable = false) {
  // process initial bytes
  %ib = uint(take(1));
  %mt = %ib &gt;&gt; 5;
  %val = %ai = %ib &amp; 0x1f;
  switch (%ai) {
    case 24: %val = uint(take(1)); break;
    case 25: %val = uint(take(2)); break;
    case 26: %val = uint(take(4)); break;
    case 27: %val = uint(take(8)); break;
    case 28: case 29: case 30: fail();
    case 31:
      return well_formed_indefinite(%mt, %breakable);
  }
  // process content
  switch (%mt) {
    // case 0, 1, 7 do not have content; just use %val
    case 2: case 3: take(%val); break; // bytes/UTF-8
    case 4: for (%i = 0; %i &lt; %val; %i++) well_formed(); break;
    case 5: for (%i = 0; %i &lt; %val*2; %i++) well_formed(); break;
    case 6: well_formed(); break;     // 1 embedded data item
    case 7: if (%ai == 24 &amp;&amp; %val &lt; 32) fail(); // bad simple
  }
  return %mt;                    // definite-length data item
}

well_formed_indefinite(%mt, %breakable) {
  switch (%mt) {
    case 2: case 3:
      while ((%it = well_formed(true)) != -1)
        if (%it != %mt)           // need definite-length chunk
          fail();               //    of same type
      break;
    case 4: while (well_formed(true) != -1); break;
    case 5: while (well_formed(true) != -1) well_formed(); break;
    case 7:
      if (%breakable)
        return -1;              // signal break out
      else fail();              // no enclosing indefinite
    default: fail();            // wrong %mt
  }
  return 99;                    // indefinite-length data item
}
</pre>

<figcaption>疑似-~code 1：
整形式性 検査-用の疑似-~code
◎
Figure 1: Pseudocode for Well-Formedness Check
</figcaption></figure>

<p>
完全な~CBOR復号器における残りの複階性は、［
復号された~dataを適切な形で応用に呈示すること
］についてであることに注意。
◎
Note that the remaining complexity of a complete CBOR decoder is about presenting data that has been decoded to the application in an appropriate form.
</p>

<p>
`~major型$ ~IN { `0$mj, `1$mj } は、
~C言語においては，［
正な~integer／負な~integer
］に対する `if-then-else^en を実際に行うことなく，［
有符号な~integerから符号化できる仕方
］で設計される
（下の`疑似-~code 2＠#branchless$ ）。
これは、［
`~major型$ `1$mj 用の形式変換 ( −1 ~MINUS %n ) は、
~C言語の無符号~算術においては，
<code>~%n</code>（~bitごとの補数）と同じになる事実
］を利用する。
すなわち、
所与の~integer【！~number】 %n に対し，
%s は %n を［
その~bit長さ ~MINUS 1
］（例： 64 ~bit~integerなら 63 ）だけ算術~shiftした結果
］とするとき，
%n は <code>%s^%n</code> として表出できる
— %s は %n が［
負ならば −1 【全~bitが 1 】／
負でないならば 0 【全~bitが 0 】
］になり，
<code>%s^%n</code> は［
<code>~%n</code> ／ %n
］になるので。
◎
Major types 0 and 1 are designed in such a way that they can be encoded in C from a signed integer without actually doing an if-then-else for positive/negative (Figure 2). This uses the fact that (-1-n), the transformation for major type 1, is the same as ~n (bitwise complement) in C unsigned arithmetic; ~n can then be expressed as (-1)^n for the negative case, while 0^n leaves n unchanged for nonnegative. The sign of a number can be converted to -1 for negative and 0 for nonnegative (0 or positive) by arithmetic-shifting the number by one bit less than the bit length of the number (for example, by 63 for 64-bit numbers).
</p>

<figure id="branchless">
<pre class="sourcecode">
void encode_sint(int64_t %n) {
  uint64t %ui = %n &gt;&gt; 63;    // extend sign to whole length
  unsigned %mt = %ui &amp; 0x20; // extract (shifted) major type
  %ui ^= %n;                 // complement negatives
  if (%ui &lt; 24)
    *%p++ = %mt + %ui;
  else if (%ui &lt; 256) {
    *%p++ = %mt + 24;
    *%p++ = %ui;
  } else
       ...
</pre>

<figcaption>疑似-~code 2：
有符号~integerを符号化するための疑似-~code
◎
Figure 2: Pseudocode for Encoding a Signed Integer
</figcaption></figure>

<p>
この~code片にて利用される，
~C言語の~profileについての一部の特有な前提は、
`1.2§ を見よ。
◎
See Section 1.2 for some specific assumptions about the profile of the C language used in these pieces of code.
</p>

	</section>
	<section id="half-precision">
<h2 title="Half-Precision">D. 半-精度</h2>

<p>
`半-精度~float$が~IEEE754に追加されたのは， 2008年 `IEEE754$r なので、
今日の~programming~platformにおける その~supportは，まだ制限されていることが多い。
そのような~supportが無くても、
少なくとも［
半-精度~floatを復号するための~support
］を含めることは，ごく容易である。
~C言語における`半-精度~float$用の小さな復号器の例は、
下の`疑似-~code 3＠#decode-half-c$
に示される。
~Python用の類似な~programは、
下の`疑似-~code 4＠#decode-half-py$
にある
— この~codeは、
2 ~byteからなる値（無符号 `short^c 型）は，すでに
— ~network~byte順序で，`~integer$として —
（ `C§ の疑似-~codeにより行われるように）復号-済みと見做す。
◎
As half-precision floating-point numbers were only added to IEEE 754 in 2008 [IEEE754], today's programming platforms often still only have limited support for them. It is very easy to include at least decoding support for them even without such support. An example of a small decoder for half-precision floating-point numbers in the C language is shown in Figure 3. A similar program for Python is in Figure 4; this code assumes that the 2-byte value has already been decoded as an (unsigned short) integer in network byte order (as would be done by the pseudocode in Appendix C).
</p>

<figure id="decode-half-c">
<pre class="sourcecode">
#include &lt;math.h&gt;

double decode_half(unsigned char *%halfp) {
  unsigned %half = (%halfp[0] &lt;&lt; 8) + %halfp[1];
  unsigned %exp = (%half &gt;&gt; 10) &amp; 0x1f;
  unsigned %mant = %half &amp; 0x3ff;
  double %val;
  if (%exp == 0) %val = ldexp(%mant, -24);
  else if (%exp != 31) %val = ldexp(%mant + 1024, %exp - 25);
  else %val = %mant == 0 ? INFINITY : NAN;
  return %half &amp; 0x8000 ? -%val : %val;
}
</pre>

<figcaption>疑似-~code 3：
半-精度~復号器~用の~C言語~code
◎
Figure 3: C Code for a Half-Precision Decoder
</figcaption></figure>

<figure id="decode-half-py">
<pre class="sourcecode">
import struct
from math import ldexp

def decode_single(%single):
    return struct.unpack("!f", struct.pack("!I", %single))[0]

def decode_half(%half):
    %valu = (%half &amp; 0x7fff) &lt;&lt; 13 | (%half &amp; 0x8000) &lt;&lt; 16
    if ((%half &amp; 0x7c00) != 0x7c00):
        return ldexp(decode_single(%valu), 112)
    return decode_single(%valu | 0x7f800000)
</pre>

<figcaption>疑似-~code 4：
半-精度~復号器~用の~Python~code
◎
Figure 4: Python Code for a Half-Precision Decoder
</figcaption></figure>

	</section>
	<section id="comparison-app">
<h2 title="Comparison of Other Binary Formats to CBOR's Design Objectives">E. 他の~binary形式と~CBORの設計~目標群との比較</h2>

<p>
~binary形式には，
~computer自身と同じ長い歴史があり、
~CBOR用の提案は，その歴史に追従する。
個々の形式の目標群は、
形式に応じて異なる。
ほとんどの事例では、
当の形式の目標群は，決して言明されない
— ときには、
当の形式が最初に利用された文脈により含意されることもあるが。
一部の形式は、
普遍的に利用-可能になるものと意味される
— あらゆる［
~protocol／応用
］の必要性を満たす~binary形式が無いことは、
歴史から立証されたが。
◎
The proposal for CBOR follows a history of binary formats that is as long as the history of computers themselves. Different formats have had different objectives. In most cases, the objectives of the format were never stated, although they can sometimes be implied by the context where the format was first used. Some formats were meant to be universally usable, although history has proven that no binary format meets the needs of all protocols and applications.
</p>

<p>
~CBORは、
ある集合を成す目標群から開始して，
それらだけを満たすよう試みる
— そのことに因り，他の多くの形式と相違する。
この節は、
これら数多の形式のうち少数について，~CBORの目標群と比較する
— 読者が，特定0の［
~protocol／応用
］用に何らかの形式を利用したいと求める場合に、［
~CBOR, 他の形式
］どちらにするか裁定する助けになるよう。
◎
CBOR differs from many of these formats due to it starting with a set of objectives and attempting to meet just those. This section compares a few of the dozens of formats with CBOR's objectives in order to help the reader decide if they want to use CBOR or a different format for a particular protocol or application.
</p>

<p>
ここでの論点は、
他の形式に対する批判は意味されないことに注意。
知られる限り、
~CBORより前に，~CBORの目標群を
— それらにアテガわれた優先度の下で —
受持つものと意味された形式は無い。
`1.1§ に挙げた目標群の概要を再掲すると：
◎
Note that the discussion here is not meant to be a criticism of any format: to the best of our knowledge, no format before CBOR was meant to cover CBOR's objectives in the priority we have assigned them. A brief recap of the objectives from Section 1.1 is:
</p>
<ol>
	<li>
各種~Internet標準に最も共通な~data形式の一義的な符号化法
◎
unambiguous encoding of most common data formats from Internet standards
</li>
	<li>
［
符号化器／復号器
］用の~codeの~compactさ
◎
code compactness for encoder or decoder
</li>
	<li>
~schema記述を必要としない
◎
no schema description needed
</li>
	<li>
適度に~compactな直列化
◎
reasonably compact serialization
</li>
	<li>
［
拘束された／拘束されない
］応用への適用能
◎
applicability to constrained and unconstrained applications
</li>
	<li>
良い~JSON変換
◎
good JSON conversion
</li>
	<li>
拡張能
◎
extensibility
</li>
</ol>

<p>
~CBORと他の形式における設計~目標群に関する論点は、
`RFC8618$r ［
`§ 5＠~RFCx/rfc8618#section-5$,
`§ C＠~RFCx/rfc8618#appendix-C$
］にて供される。
◎
A discussion of CBOR and other formats with respect to a different set of design objectives is provided in Section 5 and Appendix C of [RFC8618].
</p>

	</section>
	<section id="asn1-der-ber-and-per">
<h2 title="ASN.1 DER, BER, and PER">E.1. ~ASN1の ~DER, ~BER, ~PER</h2>

<p>
`ASN.1$r には、
何種もの直列化がある。
~IETFにおいては、
~DERと~BERが最も共通的にある。
直列化された出力は，
多くの~itemに対しては特に~compactではなく、
数量-~itemを復号するために必要な~codeは，
拘束された機器~上では複階的になり得る。
◎
[ASN.1] has many serializations. In the IETF, DER and BER are the most common. The serialized output is not particularly compact for many items, and the code needed to decode numeric items can be complex on a constrained device.
</p>

<p>
いくつかある［
~PER（ `Packed Encoding Rules^en ）の変種
］のうち 1 つを採用した~IETF~protocolは、
（あったとしても）少数しかない。
その理由は，いくつも挙げられようが、
共通的に言明される理由は，［
~PERは、［
~data~itemの構造を表面的に構文解析するためでしかない場合でも，~schemaを用立てる
］ので，有意な~tool~supportを要求している
］ことにある。
利用-中にある~ASN1~schema言語には，いくつか異なる~versionがあり、
それもまた，~PERの採用の妨げになっている。
◎
Few (if any) IETF protocols have adopted one of the several variants of Packed Encoding Rules (PER). There could be many reasons for this, but one that is commonly stated is that PER makes use of the schema even for parsing the surface structure of the data item, requiring significant tool support. There are different versions of the ASN.1 schema language in use, which has also hampered adoption.
</p>

	</section>
	<section id="messagepack">
<h2 title="MessagePack">E.2. ~MessagePack</h2>

<p>
`MessagePack$r は、［
簡潔な, 広く実装された~binary直列化~形式
］として数えられ，
多くの特質において，~CBORに類似する
— さほど定例ではないが。
その~data~modelは，~JSON~dataを表現するために利用できるが、
~MessagePackは，
多くの~remote手続-~call（~RPC）応用において, および
~dataを長期的に格納するためにも利用されている。
◎
[MessagePack] is a concise, widely implemented counted binary serialization format, similar in many properties to CBOR, although somewhat less regular. While the data model can be used to represent JSON data, MessagePack has also been used in many remote procedure call (RPC) applications and for long-term storage of data.
</p>

<p>
~MessagePackは、
最初に公表された 2011年頃 以来，本質的に安定的である
— それは、
まだ移行期を経ていない。
~MessagePackの発展は、［
既存の格納-済み~dataとの完全な後方-互換性を保守する
］とする絶対要件により遅滞される一方で，［
拡張~用に依然として可用な~byte~code
］は少数に限られる。
~MessagePackは、
何年もの間，利用者~communityから［
符号化法において，~binary~stringと~text~stringを分離する
］よう要請が繰返された
— それは，近過去に拡張~提案に至ったが、
~MessagePackの “生な” ~dataの用法は，［
~binary~data用, ~text~data用
］の間で多義的なまま残されることになる。
~MessagePack用の拡張の仕組みは、
不明瞭であり続ける。
◎
MessagePack has been essentially stable since it was first published around 2011; it has not yet had a transition. The evolution of MessagePack is impeded by an imperative to maintain complete backwards compatibility with existing stored data, while only few bytecodes are still available for extension. Repeated requests over the years from the MessagePack user community to separate out binary and text strings in the encoding recently have led to an extension proposal that would leave MessagePack's "raw" data ambiguous between its usages for binary and text data. The extension mechanism for MessagePack remains unclear.
</p>

	</section>
	<section id="bson">
<h2 title="BSON">E.3. ~BSON</h2>

<p>
`BSON$r は、
~MongoDB~databaseにおいて，
~JSONの様な~map（~JSON~object）を格納するために開発された~data形式である。
その主要な際立った特能は，その場で更新する能力であり、
そのことが~compactな表現を~~妨げる。
~BSONは、
`~map~key$を除いて，ある `counted^en【？】 表現を利用する
— すなわち、 `null-byte^en で終了される。
~BSONは，伝送路において~JSONの様な~objを表現するために利用できるが、
その仕様は，~database応用の要件に支配され, いくぶん格式ばったものになった。
~BSON拡張がどう実装されるかの位置付けは不明瞭であり続ける。
◎
[BSON] is a data format that was developed for the storage of JSON-like maps (JSON objects) in the MongoDB database. Its major distinguishing feature is the capability for in-place update, which prevents a compact representation. BSON uses a counted representation except for map keys, which are null-byte terminated. While BSON can be used for the representation of JSON-like objects on the wire, its specification is dominated by the requirements of the database application and has become somewhat baroque. The status of how BSON extensions will be implemented remains unclear.
</p>

	</section>
	<section id="msdtp-rfc-713">
<h2 title="MSDTP: RFC 713">E.4. ~MSDTP： ~RFC 713</h2>

<p>
~MSDTP
— `Message Services Data Transmission^en（~message~service~data伝送） —
は、
ごく早期の~compactな~message形式の例であり，
1976年に書かれた `RFC0713$r にて述べられる。
ここに それを含めたのは、
広く利用されたことがあるからではなく，その歴史的な価値による。
◎
Message Services Data Transmission (MSDTP) is a very early example of a compact message format; it is described in [RFC0713], written in 1976. It is included here for its historical value, not because it was ever widely used.
</p>

	</section>
	<section id="conciseness-on-the-wire">
<h2 title="Conciseness on the Wire">E.5. 伝送路~上の簡潔さ</h2>

<p>
~CBORの設計~目標群のうち［
符号化器／復号器
］用~codeの~compactさは［
伝送路~上の簡潔さ
］よりも優先度が高いが、
多くの者は，伝送路~上の~sizeに注力する。
`表0 8＠#concise$ に，
単純な入子な`~array$ `[1, [2, 3]]^dg を符号化する例をいくつか示す
— そこでは、
一部の［
`不定長$な符号化を成す形
］は，
`[_ 1, [2, 3]]^dg （外縁`~array$は`不定長$）に符号化することにより~supportされることも示される。
◎
While CBOR's design objective of code compactness for encoders and decoders is a higher priority than its objective of conciseness on the wire, many people focus on the wire size. Table 8 shows some encoding examples for the simple nested array [1, [2, 3]]; where some form of indefinite-length encoding is supported by the encoding, [_ 1, [2, 3]] (indefinite length on the outer array) is also shown.
</p>

<div>
<table id="table-8">
<caption id="concise">
表0 8：
簡潔さの~levelが異なる例
</caption>
<thead><tr>
<th>形式
<th>`[1, [2, 3]]^dg
<th>`[_ 1, [2, 3]]^dg
</thead><tbody>

<tr><td>RFC 713
<td>`c2 05 81 c2 02 82 83^hex
<td>

<tr><td>ASN.1 BER
<td>`30 0b 02 01 01 30 06 02 01 02 02 01 03^hex
<td>`30 80 02 01 01 30 06 02 01 02 02 01 03 00 00^hex

<tr><td>MessagePack
<td>`92 01 92 02 03^hex
<td> 

<tr><td>BSON
<td>`22 00 00 00 10 30 00 01 00 00 00 04 31 00 13 00 00 00 10 30 00 02 00 00 00 10 31 00 03 00 00 00 00 00^hex
<td> 

<tr><td>CBOR
<td>`82 01 82 02 03^hex
<td>`9f 01 82 02 03 ff^hex

</tbody>
</table>
◎
Table 8: Examples for Different Levels of Conciseness
◎
Format｜[1, [2, 3]]｜[_ 1, [2, 3]]
RFC 713｜c2 05 81 c2 02 82 83｜
ASN.1 BER｜30 0b 02 01 01 30 06 02 01 02 02 01 03｜30 80 02 01 01 30 06 02 01 02 02 01 03 00 00
MessagePack｜92 01 92 02 03｜
BSON｜22 00 00 00 10 30 00 01 00 00 00 04 31 00 13 00 00 00 10 30 00 02 00 00 00 10 31 00 03 00 00 00 00 00｜
CBOR｜82 01 82 02 03｜9f 01 82 02 03 ff
</div>

	</section>
	<section id="errors">
<h2 title="Well-Formedness Errors and Examples">F. 整形式性~error, その例</h2>

<p>
`~data~item$の復号-時に生じ得る整形式性~errorには、
基本的な種類として，次に挙げる 3 つがある：
◎
There are three basic kinds of well-formedness errors that can occur in decoding a CBOR data item:
</p>
<dl>
	<dt>
種類 1：
~dataが多過ぎる
◎
Too much data:
</dt>
	<dd>
入力~byte列には，消費されなかったものが残されている。
これは、
当の応用が［
入力~byte列は、
正確に 1 個の~data~itemに~spanする
］ものと見做す場合に限り，~errorになる。
当の応用が
— ~CBOR連列 `RFC8742$r にて行われるのと同じく — 
［
~CBOR符号化法の自己を区切る資質
］を利用して［
~data~itemの後に追加的な~dataを許可する
］する所では、
当の~CBOR復号器は，例えば単純に［
入力を成すどの部分が消費されなかったか
］を指示できる。
◎
There are input bytes left that were not consumed. This is only an error if the application assumed that the input bytes would span exactly one data item. Where the application uses the self-delimiting nature of CBOR encoding to permit additional data after the data item, as is done in CBOR sequences [RFC8742], for example, the CBOR decoder can simply indicate which part of the input has not been consumed.
</dd>

	<dt>
種類 2：
~dataが少な過ぎる
◎
Too little data:
</dt>
	<dd>
`~data~item$が完全になるためには、
可用な入力~dataの終端に さらに~byte列を追加する必要がある。
これは、
入力が切落とされたことを指示することもあり，
また［
~randomな~dataを~CBORとして復号しようと試行したとき
］に共通的な~errorでもある。
しかしながら、
応用によっては，実際には~errorとされないこともある
— 当の応用は、
すべての~dataが得られたかどうか定かでないこともあり，
追加的な入力~byte列が得されるまで待機し得るので
【すなわち，`~streamして$いる場合】。
そのような応用には、［
追加的な~dataがどれだけ現れ得るか
］に上限を課すものもある
— そこでは、
当の復号器は［
`符号化された~data~item$は、
この上限までに完了し得ないこと
］を指示-可能になることもある。
◎
The input data available would need additional bytes added at their end for a complete CBOR data item. This may indicate the input is truncated; it is also a common error when trying to decode random data as CBOR. For some applications, however, this may not actually be an error, as the application may not be certain it has all the data yet and can obtain or wait for additional input bytes. Some of these applications may have an upper limit for how much additional data can appear; here the decoder may be able to indicate that the encoded CBOR data item cannot be completed within this limit.
</dd>

	<dt>
種類 3：
構文~error
◎
Syntax error:
</dt>
	<dd>
入力~dataは、
~CBOR符号化法の要件に整合でない
— これは、
~dataを終端に追加しようが（終端から除去しようが）救済し得ない。
◎
The input data are not consistent with the requirements of the CBOR encoding, and this cannot be remedied by adding (or removing) data at the end.
</dd>
</dl>

<p>
これらは、
`C§ においては：
◎
In Appendix C,＼
</p>
<ul>
	<li>
~dataが多過ぎる~errorは、
最初の段落（ “残された~byte列は無い” を要求している）にて取組まれる。
◎
errors of the first kind are addressed in the first paragraph and bullet list (requiring "no bytes are left"),＼
</li>
	<li>
~dataが少な過ぎる~errorは、
`take()^c 関数
（条項~listの 2 項目 “ %n 個の~byteは可用でない場合、失敗する” ）
にて取組まれる。
◎
and errors of the second kind are addressed in the second paragraph/bullet list (failing "if n bytes are no longer available").＼
</li>
	<li>
<p>
構文~errorは、
疑似-~codeにおいて，次に挙げる順序で
— `fail()^c を~callする各所により —
識別される：
◎
Errors of the third kind are identified in the pseudocode by specific instances of calling fail(), in order:
</p>
		<ol>
			<li>
`追加l情報$に予約-済みな値（ `28^ai, `29^ai, `30^ai ）が利用された
◎
a reserved value is used for additional information (28, 29, 30)
</li>
			<li>
［
`~major型$ 7,
`追加l情報$ `24^ai
］において、
値が 32 未満（不正）
◎
major type 7, additional information 24, value &lt; 32 (incorrect)
</li>
			<li>
下位-構造を成す［
`~byte~string$／`~text~string$
］【~chunk】が，`不定長$（不正）
（包含してよいのは、
同じ`~major型$の`確定長$な~stringに限られる）
◎
incorrect substructure of indefinite-length byte string or text string (may only contain definite-length strings of the same major type)
</li>
			<li>
`~break$ 【！`~major型$ `7$mj, `追加l情報$ `31^ai】が［
`~map$内の値が占める位置／次に該当する位置
］に生じた
⇒
`不定長$な［
`~map$／`~array$
］【！~item】内に直に含まれる位置
］を除く［
`~break$ 以外の【！別の】封入された~data~item
］も生じ得る所
◎
"break" stop code (major type 7, additional information 31) occurs in a value position of a map or except at a position directly in an indefinite-length item where also another enclosed data item could occur
</li>
			<li>
`~major型$ ~IN { `0$mj, `1$mj, `6$mj } において，
`追加l情報$として `31^ai が利用された
◎
additional information 31 used with major type 0, 1, or 6
</li>
		</ol>
	</li>
</ul>

	</section>
	<section id="examples-for-cbor-data-items-that-are-not-well-formed">
<h2 title="Examples of CBOR Data Items That Are Not Well-Formed">F.1. 整形式でない~CBOR~data~itemの例</h2>

<p>
この下位節は、
`整形式$でない`~data~item$の例を示す。
各~例は，~hexadecimalで示される~byte列であり、
複数の例からなる~listは，~commaで分離される。
◎
This subsection shows a few examples for CBOR data items that are not well-formed. Each example is a sequence of bytes, each shown in hexadecimal; multiple examples in a list are separated by commas.
</p>

<p>
［
~dataが多過ぎる整形式性~error
］用の例は、［
`整形式$な`~data~item$に~dataを追加する
］ことにより，容易に形成できる。
◎
Examples for well-formedness error kind 1 (too much data) can easily be formed by adding data to a well-formed encoded CBOR data item.
</p>

<p>
類似に，［
~dataが少な過ぎる整形式性~error
］用の例は、［
`整形式$な`~data~item$を切落とす
］ことにより形成できる。
~test一式においては、
特定的に［
多量な何かを追加しないと完全にならない，不完全な~data~item
］で~testすることが有益になり得る
（一例として、
~sizeが~~巨大な~stringの符号化を開始することにより）。
◎
Similarly, examples for well-formedness error kind 2 (too little data) can be formed by truncating a well-formed encoded CBOR data item. In test suites, it may be beneficial to specifically test with incomplete data items that would require large amounts of addition to be completed (for instance by starting the encoding of a string of a very large size).
</p>

<p>
入力の尚早な終端は［
`~head$内／封入された~dataの中
］で生じ得る
— それは、
裸の~stringや封入された~data~itemのうち［
`counted^en【？】 なもの ／ `~break$ により終端されるべきであったもの
］であり得る。
◎
A premature end of the input can occur in a head or within the enclosed data, which may be bare strings or enclosed data items that are either counted or should have been ended by a "break" stop code.
</p>
<ul>
	<li>
`~head$内の入力の終端
⇒＃
`18^hex,
`19^hex,
`1a^hex,
`1b^hex,
`19 01^hex,
`1a 01 02^hex,
`1b 01 02 03 04 05 06 07^hex,
`38^hex,
`58^hex,
`78^hex,
`98^hex,
`9a 01 ff 00^hex,
`b8^hex,
`d8^hex,
`f8^hex,
`f9 00^hex,
`fa 00 00^hex,
`fb 00 00 00^hex
◎
End of input in a head:
• 18, 19, 1a, 1b, 19 01, 1a 01 02, 1b 01 02 03 04 05 06 07, 38, 58, 78, 98, 9a 01 ff 00, b8, d8, f8, f9 00, fa 00 00, fb 00 00 00
</li>
	<li>
`確定長$な~stringを成す~dataが短か過ぎる
⇒＃
`41^hex,
`61^hex,
`5a ff ff ff ff 00^hex,
`5b ff ff ff ff ff ff ff ff 01 02 03^hex,
`7a ff ff ff ff 00^hex,
`7b 7f ff ff ff ff ff ff ff 01 02 03^hex
◎
Definite-length strings with short data:
• 41, 61, 5a ff ff ff ff 00, 5b ff ff ff ff ff ff ff ff 01 02 03, 7a ff ff ff ff 00, 7b 7f ff ff ff ff ff ff ff 01 02 03
</li>
	<li>
`確定長$な［
`~map$／`~array$
］を成す~itemの個数が足らない
⇒＃
`81^hex,
`81 81 81 81 81 81 81 81 81^hex,
`82 00^hex,
`a1^hex,
`a2 01 02^hex,
`a1 00^hex,
`a2 00 00 00^hex
◎
Definite-length maps and arrays not closed with enough items:
• 81, 81 81 81 81 81 81 81 81 81, 82 00, a1, a2 01 02, a1 00, a2 00 00 00
</li>
	<li>
`~tag$において，`~tag番号$に`~tag内容$が後続していない
⇒＃
`c0^hex
◎
Tag number not followed by tag content:
• c0
</li>
	<li>
`不定長$な~stringが `~break$ により閉じられていない
⇒＃
`5f 41 00^hex,
`7f 61 00^hex
◎
Indefinite-length strings not closed by a "break" stop code:
• 5f 41 00, 7f 61 00
</li>
	<li>
`不定長$な［
`~map$／`~array$
］が `~break$ により閉じられていない
⇒＃
`9f^hex,
`9f 01 02^hex,
`bf^hex,
`bf 01 02 01 02^hex,
`81 9f^hex,
`9f 80 00^hex,
`9f 9f 9f 9f 9f ff ff ff ff^hex,
`9f 81 9f 81 9f 9f ff ff ff^hex
◎
Indefinite-length maps and arrays not closed by a "break" stop code:
• 9f, 9f 01 02, bf, bf 01 02 01 02, 81 9f, 9f 80 00, 9f 9f 9f 9f 9f ff ff ff ff, 9f 81 9f 81 9f 9f ff ff ff
</li>
</ul>

<p>
構文~error（種類 3 の整形式性~error）は、
さらに 5 種類に分かれる
— その例を以下に示す。
◎
A few examples for the five subkinds of well-formedness error kind 3 (syntax error) are shown below.
</p>
<ul>
	<li>
(1)
`追加l情報$が予約-済みな値をとるもの
⇒＃
`1c^hex,
`1d^hex,
`1e^hex,
`3c^hex,
`3d^hex,
`3e^hex,
`5c^hex,
`5d^hex,
`5e^hex,
`7c^hex,
`7d^hex,
`7e^hex,
`9c^hex,
`9d^hex,
`9e^hex,
`bc^hex,
`bd^hex,
`be^hex,
`dc^hex,
`dd^hex,
`de^hex,
`fc^hex,
`fd^hex,
`fe^hex
◎
Subkind 1:
◎
Reserved additional information values:
• 1c, 1d, 1e, 3c, 3d, 3e, 5c, 5d, 5e, 7c, 7d, 7e, 9c, 9d, 9e, bc, bd, be, dc, dd, de, fc, fd, fe,
</li>
	<li>
(2)
`単純~値$を成す［
予約-済みな 2 ~byteによる符号化
］
⇒＃
`f8 00^hex,
`f8 01^hex,
`f8 18^hex,
`f8 1f^hex
◎
Subkind 2:
◎
Reserved two-byte encodings of simple values:
• f8 00, f8 01, f8 18, f8 1f
</li>
	<li>
<p>
(3)
`不定長$な~stringを成す~~不正な~chunk：
◎
Subkind 3:
</p>
		<ul>
			<li>
正しい型を成していない~chunk
⇒＃
`5f 00 ff^hex,
`5f 21 ff^hex,
`5f 61 00 ff^hex,
`5f 80 ff^hex,
`5f a0 ff^hex,
`5f c0 00 ff^hex,
`5f e0 ff^hex,
`7f 41 00 ff^hex
◎
Indefinite-length string chunks not of the correct type:
• 5f 00 ff, 5f 21 ff, 5f 61 00 ff, 5f 80 ff, 5f a0 ff, 5f c0 00 ff, 5f e0 ff, 7f 41 00 ff
</li>
			<li>
`確定長$でない~chunk
⇒＃
`5f 5f 41 00 ff ff^hex,
`7f 7f 61 00 ff ff^hex
◎
Indefinite-length string chunks not definite length:
• 5f 5f 41 00 ff ff, 7f 7f 61 00 ff ff
</li>
		</ul>
	</li>
	<li>
<p>
(4)
~~不正な `~break$：
◎
Subkind 4:
</p>
		<ul>
			<li>
`不定長$な~itemの外側で生じている `~break$
⇒＃
`ff^hex
◎
Break occurring on its own outside of an indefinite-length item:
• ff
</li>
			<li>
`確定長$な［
`~array$／`~map$【！／`~tag$】
］内に生じている `~break$
⇒＃
`81 ff^hex,
`82 00 ff^hex,
`a1 ff^hex,
`a1 ff 00^hex,
`a1 00 ff^hex,
`a2 00 00 ff^hex,
`9f 81 ff^hex,
`9f 82 9f 81 9f 9f ff ff ff ff^hex
◎
Break occurring in a definite-length array or map or a tag:
• 81 ff, 82 00 ff, a1 ff, a1 ff 00, a1 00 ff, a2 00 00 ff, 9f 81 ff, 9f 82 9f 81 9f 9f ff ff ff ff
</li>
			<li>
`不定長$な`~map$を成す`~entry$の`値$が占める位置に生じている `~break$
（`~map$を成す~itemが奇数個）
⇒＃
`bf 00 ff^hex,
`bf 00 00 00 ff^hex
◎
Break in an indefinite-length map that would lead to an odd number of items (break in a value position):
• bf 00 ff, bf 00 00 00 ff
</li>
		</ul>
	</li>
	<li>
(5)
`~major型$ ~IN { `0$mj, `1$mj, `6$mj } のうち
`追加l情報$ `31^ai を伴うもの
⇒＃
`1f^hex,
`3f^hex,
`df^hex
◎
Subkind 5:
◎
Major type 0, 1, 6 with additional information 31:
• 1f, 3f, df
</li>
</ul>

	</section>
	<section id="changes-from-rfc-7049">
<h2 title="Changes from RFC 7049">G. ~RFC 7049 からの変更点</h2>

<p>
序論にて論じたとおり，この文書は、
~RFC 7049 を
— それによる交換~形式との全部的な互換性は保ったまま —
正式に廃用にする。
この文書は、［
編集上の改善を供する／
詳細を追加した／
正誤表を修正した
］。
この文書は、
~CBOR形式の新たな~versionを作成するものではない。
◎
As discussed in the introduction, this document formally obsoletes RFC 7049 while keeping full compatibility with the interchange format from RFC 7049. This document provides editorial improvements, added detail, and fixed errata. This document does not create a new version of the format.
</p>

	</section>
	<section id="errata-processing-clerical-changes">
<h2 title="Errata Processing and Clerical Changes">G.1. 正誤表の処理と事務的な変更点</h2>

<p>
~RFC 7049 の正誤表の処理：
◎
↓</p>
<ul>
	<li>
`Err3764$r, `Err3770$r
⇒
これらは、
2 つの符号化~例を懸念した
— これらを検証yして正した
（ `3.4.3§： "`29^hex" → "`49^hex", `5.5§： "`000_11101^B" → "`000_11001^B" ）。
◎
The two verified errata on RFC 7049, [Err3764] and [Err3770], concerned two encoding examples in the text that have been corrected (Section 3.4.3: "29" -&gt; "49", Section 5.5: "0b000_11101" -&gt; "0b000_11001").＼
</li>
	<li>
`Err5917$r
⇒
~RFC 7049 が包含していた［
`単純~値$に`整形式$でない数量-値 24 を利用していた例
］を除去した。
◎
Also, RFC 7049 contained an example using the numeric value 24 for a simple value [Err5917], which is not well-formed; this example has been removed.＼
</li>
	<li>
`Err5763$r
⇒
これは、［
`~tag$の定義を成す言い回し内の誤り
］を指摘した
ー それは、
`3.4§ を書き直す間に解決された。
◎
Errata report 5763 [Err5763] pointed to an error in the wording of the definition of tags; this was resolved during a rewrite of Section 3.4.＼
</li>
	<li>
`Err5434$r
⇒
これは、
`E§ における~UBJSON（ `Universal Binary JSON^en, “普遍的な~binary~JSON” ）の例は，
もはや［
この正誤表~報告が提出された時点における，~UBJSONの~version
］に準拠しなくなったことを指摘した。
~UBJSON仕様は， 2013年~当時から完全に変更されたことが判明したので、
この例は除去された。
◎
Errata report 5434 [Err5434] pointed out that the Universal Binary JSON (UBJSON) example in Appendix E no longer complied with the version of UBJSON current at the time of the errata report submission. It turned out that the UBJSON specification had completely changed since 2013; this example therefore was removed.＼
</li>
	<li>
`Err4409$r `Err4963$r `Err4964$r
⇒
これは、［
正準的に符号化するために`~map~key$を~sortする規則は、
面倒である
］ことを訴えた
— これらは、
正準的な符号化法の示唆について考慮し直して，
決定論的な符号化法の示唆（下に述べる）に置換することに至った。
◎
Other errata reports [Err4409] [Err4963] [Err4964] complained that the map key sorting rules for canonical encoding were onerous; these led to a reconsideration of the canonical encoding suggestions and replacement by the deterministic encoding suggestions (described below).＼
</li>
	<li>
`Err4294$r
⇒
これによる編集上の示唆も実装された
（ `3.2.2§ の最後の例に対する~commentに “2 個目の値” を追加することにより，
対称性を改善した）。
◎
An editorial suggestion in errata report 4294 [Err4294] was also implemented (improved symmetry by adding "Second value" to a comment to the last example in Section 3.2.2).
</li>
</ul>

<p>
その他の事務的な変更点：
◎
Other clerical changes include:
</p>
<ul>
	<li>
新たな `xml2rfc^i 機能性 `RFC7991$r の利用。
◎
the use of new xml2rfc functionality [RFC7991];
</li>
	<li>
利用される記法についての説明をもっと加えた。
◎
more explanation of the notation used;
</li>
	<li>
<p>
次に挙げる参照の更新
— 例：
</p>
		<ul>
			<li>
`RFC4627^r を `RFC8259$r に更新した。
</li>
			<li>
`CNN-TERMS^r を `RFC7228$r に更新した。
</li>
			<li>
`ECMA262$r を第 5.1 版から第 11 版に更新した
</li>
			<li>
`IEEE754$r への参照を追加した。
要求される定義を取り込んだ。
</li>
			<li>
`C$r, `Cplusplus20$r への参照を追加した。
</li>
			<li>
`RFC8618$r への参照を追加した
— それは、
`E§ 内の論点を更に~~説明する。
</li>
		</ul>
◎
the update of references, e.g., from RFC 4627 to [RFC8259], from CNN-TERMS to [RFC7228], and from the 5.1 edition to the 11th edition of [ECMA262]; the addition of a reference to [IEEE754] and importation of required definitions; the addition of references to [C] and [Cplusplus20]; and the addition of a reference to [RFC8618] that further illustrates the discussion in Appendix E;
</li>
	<li>
診断用の記法の論点（ `8§ ）において
⇒＃
`RFC8610$r にて定義される “拡張された診断用の記法（ EDN ）” について言及した／
`NaN payload^en の表現-法については，この文書は受持たないことを強調した／
~chunkを伴わない`不定長$な~stringの表現-法について説明を追加した（ `8.1§ ）
◎
in the discussion of diagnostic notation (Section 8), the "Extended Diagnostic Notation" (EDN) defined in [RFC8610] is now mentioned, the gap in representing NaN payloads is now highlighted, and an explanation of representing indefinite-length strings with no chunks has been added (Section 8.1);
</li>
	<li>
この付録を追加した。
◎
the addition of this appendix.
</li>
</ul>

	</section>
	<section id="changes-in-iana-considerations">
<h2 title="Changes in IANA Considerations">G.2. ~IANA考慮点における変更点</h2>

<p>
~IANA考慮点は、
一般に，更新された
（事務的な変更点の例：今や，仕様の著作者として~CBOR~WGを指している）。
規範的でない参照として，~IANA~registryへの参照を追加した。
◎
The IANA considerations were generally updated (clerical changes, e.g., now pointing to the CBOR Working Group as the author of the specification). References to the respective IANA registries were added to the informative references.
</p>

<p>
`~CBOR~tag~registry^cite `IANA.cbor-tags$r における［
`~tag番号$ ~IN { `256^tag 〜 `32767^tag }
（先頭~byte + 2 ~byteの下~半分）
］は、
今や`先着順に~serveされ$なくなり，`仕様が要求され$る下でアテガわれることになった。
◎
In the "Concise Binary Object Representation (CBOR) Tags" registry [IANA.cbor-tags], tags in the space from 256 to 32767 (lower half of "1+2") are no longer assigned by First Come First Served; this range is now Specification Required.
</p>

	</section>
	<section id="changes-in-suggestions-and-other-informational-components">
<h2 title="Changes in Suggestions and Other Informational Components">G.3. 示唆, その他の規範的でない部分における変更点</h2>

<p>
この文書を改訂している間，~WGは、
正誤表~報告に取組むことを超えて，［
多岐にわたる応用における，およそ 7 年間の~CBORとの経験
］を引き出した。
これは、
いくつかの編集上の変更点
— ~~説明~用の表0を追加するなど —
のみならず，［
一部の側面を強勢して，他の側面を強勢しなくする
］に至った。
◎
While revising the document, beyond the addressing of the errata reports, the working group drew upon nearly seven years of experience with CBOR in a diverse set of applications. This led to a number of editorial changes, including adding tables for illustration, but also emphasizing some aspects and de-emphasizing others.
</p>

<p>
有意な追加は `2§ である
— それは、［
~CBOR~data~model, その処理に孕まれる小さな多様性
］について論じる。
それら多様性のための用語
（基本的な`汎用~data~model$, `拡張された汎用~data~model$, ~protocolに特有な~data~model）
の序論は、
文書の他の各所の文言を より簡潔にすることを可能化することに加え，［
実装の期待, ~CBOR形式の拡張能~特能
］を明確化する助けになる。
◎
A significant addition is Section 2, which discusses the CBOR data model and its small variations involved in the processing of CBOR. The introduction of terms for those variations (basic generic, extended generic, specific) enables more concise language in other places of the document and also helps to clarify expectations of implementations and of the extensibility features of the format.
</p>

<p>
~JSON~ecosystemから導出された形式としての~RFC 7049 には、
~JSON~number~system
— 当時の~JSから継承された~number~system —
が波及した。
~JSONは、［
`~integer$値, `~float$値
］を互いに別物になるように供さない
（加えて、
後者は，~JSON形式~内では~decimalになる）。
一方で，~CBORは、
~numberの~binary表現を供する
— そこでの［
`~integer$値と`~float$値
］は相違する。
実装の経験と利用の経験から、［
この 2 つの~number~domainの分離は、
当の文書【~CBOR仕様】内に もっと明瞭に引き出されるべきである
］ことが示唆された
— ［
`~integer$は、
継目なく`~float$値に替えることもできる
］と示唆していた文言は除去された。
また、［
~JSONから~CBORへ変換するときの，これらの型の取扱い
］用に，ある示唆（~I-JSON  `RFC7493$r に基づくそれ）を追加して，［
特有な丸めの仕組み
］の利用を推奨した。
◎
As a format derived from the JSON ecosystem, RFC 7049 was influenced by the JSON number system that was in turn inherited from JavaScript at the time. JSON does not provide distinct integers and floating-point values (and the latter are decimal in the format). CBOR provides binary representations of numbers, which do differ between integers and floating-point values. Experience from implementation and use suggested that the separation between these two number domains should be more clearly drawn in the document; language that suggested an integer could seamlessly stand in for a floating-point value was removed. Also, a suggestion (based on I-JSON [RFC7493]) was added for handling these types when converting JSON to CBOR, and the use of a specific rounding mechanism has been recommended.
</p>

<p>
~CBORは、
その~data~modelにおける単独の値に対し，
複数の符号化~optionを供することが多い。
新たな `4§ は、
様々な種類の~data~item用に定義される用語 “選好される直列化” （ `4.1§ ）を導入する。
その節は，さらに、
この各種用語を基礎に［
~CBORに基づく~protocolが “決定論的な符号化法” （ `4.2§ ）をどう定義できるか
］を論じる
— それは、
~RFC 7049 による用語［
“正準的”, “正準-化”
］を避ける。
`決定論的な符号化法の中核~要件$の示唆は、［
そのような~protocol定義な符号化~要件
］用の汎用な~supportを可能化する。
この文書は、［
~RFC 7049 にて示唆された，`~map$用の順序付け
］を単純な［
符号化された`~key$に対する辞書式による順序付け
］に単純~化することにより，［
決定論的な符号化法の実装
］をもっと容易にする。
旧い示唆の記述は，今や、
用語 `長さ優先な決定論的な符号化法の中核~要件$により，代替として保たれる（ `4.2.3§ ）。
◎
For a single value in the data model, CBOR often provides multiple encoding options. A new section (Section 4) introduces the term "preferred serialization" (Section 4.1) and defines it for various kinds of data items. On the basis of this terminology, the section then discusses how a CBOR-based protocol can define "deterministic encoding" (Section 4.2), which avoids terms "canonical" and "canonicalization" from RFC 7049. The suggestion of "Core Deterministic Encoding Requirements" (Section 4.2.1) enables generic support for such protocol-defined encoding requirements. This document further eases the implementation of deterministic encoding by simplifying the map ordering suggested in RFC 7049 to a simple lexicographic ordering of encoded keys. A description of the older suggestion is kept as an alternative, now termed "length-first map key ordering" (Section 4.2.3).
</p>

<p>
［
`整形式$な~data,
`妥当$な~data
］用の各種用語は、
鋭敏にされ，より厳格に利用される
— きちんと定義されていない代替な用語は
（ “構文~error”, “復号-時の~error”, “厳密~mode” など）、
各~例の外側では避けるよう。
また，ある応用が自身への入力~dataに課す［
~CBOR~levelの妥当性を超える第 3 ~levelの要件
］は，今や 【“期待される” という句として】明示的に称される。
［
`整形式$（処理-可能）,
`妥当$（妥当性を検査する汎用な復号器により検査-済み）,
`期待され$る入力（応用により検査-済み）
］は、
これら各~受容-能が成す階層を形成するものとして扱われる。
◎
The terminology for well-formed and valid data was sharpened and more stringently used, avoiding less well-defined alternative terms such as "syntax error", "decoding error", and "strict mode" outside of examples. Also, a third level of requirements that an application has on its input data beyond CBOR-level validity is now explicitly called out. Well-formed (processable at all), valid (checked by a validity-checking generic decoder), and expected input (as checked by the application) are treated as a hierarchy of layers of acceptability.
</p>

<p>
~textと疑似-~codeにおける［
`整形式$でない`単純~値$の取扱い
］を明確化した。
整形式性~errorを論じるため, および それらの例を供するため，
`F§ を追加した。
疑似-~codeを より~port可能になるよう更新した
— 加えて、
~port能に関する いくつかの考慮点を追加した。
◎
The handling of non-well-formed simple values was clarified in text and pseudocode. Appendix F was added to discuss well-formedness errors and provide examples for them. The pseudocode was updated to be more portable, and some portability considerations were added.
</p>

<p>
妥当性の論点を次の 2 つに関して鋭敏にした：
◎
The discussion of validity has been sharpened in two areas.＼
</p>
<ul>
	<li>
`~map$の妥当性（重複な`~key$の取扱い）を明確化して，
ある種の実装~選択肢が どこに適用されるかについて説明した。
◎
Map validity (handling of duplicate keys) was clarified, and the domain of applicability of certain implementation choices explained.＼
</li>
	<li>
~tagに関する各種用語を［
`~tag$, `~tag番号$, `~tag内容$
］に~~整理した一方で、
`~tag$の妥当性に関する論点を追加して，`~tag内容$に対する制約を
— 一般に, および特定的に`~tag番号$【！~tag】 `1$tag 用に —
明確化した。
◎
Also, while streamlining the terminology for tags, tag numbers, and tag content, discussion was added on tag validity, and the restrictions were clarified on tag content, in general and specifically for tag 1.
</li>
</ul>

<p>
［
直列化~順序に依存する意味論を伴う`~tag$
］の定義-法についての実装~注記
（および，将来の~tag定義~用の注記）を追加した。
（ `3.4§ ）
◎
An implementation note (and note for future tag definitions) was added to Section 3.4 about defining tags with semantics that depend on serialization order.
</p>

<p>
`~tag番号$ `35^tag は、
この文書により定義されない
— ~RFC 7049 における定義に基づく登録は、
その場にあり続ける。
◎
Tag 35 is not defined by this document; the registration based on the definition in RFC 7049 remains in place.
</p>

<p>
各種用語として［
`引数$, `~head$
］を導入して，更なる論を単純~化した。
（ `3§ ）
◎
Terminology was introduced in Section 3 for "argument" and "head", simplifying further discussion.
</p>

<p>
~securityの考慮点（ `10§ ）は、
ほとんどが書き直され，有意に拡げられた
— この文書は、
他の複数~箇所において，今や［
復号器は、
単純に，整形式性~errorを容認し得ない
］ことを明示的に~~述べた。
◎
The security considerations (Section 10) were mostly rewritten and significantly expanded; in multiple other places, the document is now more explicit that a decoder cannot simply condone well-formedness errors.
</p>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
~CBORは、
~MessagePackにより着想された。
~MessagePackは `Sadayuki Furuhashi^en （ “frsyuki” ）氏により開発され，推し進められた。
~MessagePackへの この参照は、
もっぱら帰属を示すためである
— ~CBORは、
~MessagePackの［
ある~version／それを置換するもの
］として意図されてはいない
— その［
設計~目標, 要件
］は、
~CBORとは異なるので。
◎
CBOR was inspired by MessagePack. MessagePack was developed and promoted by Sadayuki Furuhashi ("frsyuki"). This reference to MessagePack is solely for attribution; CBOR is not intended as a version of, or replacement for, MessagePack, as it has different design goals and requirements.
</p>

<p>
元の~MessagePack仕様を超える機能性の必要は、
2012年頃には，多くの人々に明白になった。
~BinaryPackは、
~MessagePackの小さな派生であり，
`Eric Zhang^en 氏により `binaryjs^i ~project用に開発された。
類似するが異なる拡張が，
`Tim Caswell^en 氏により彼の［
`msgpack-js^i, `msgpack-js-browser^i
］~project用に為された。
多くの人々が，［
~text~string表現を~byte~string表現から分離するために，~MessagePackを拡張する
］ことについての論に貢献した。
◎
The need for functionality beyond the original MessagePack specification became obvious to many people at about the same time around the year 2012. BinaryPack is a minor derivation of MessagePack that was developed by Eric Zhang for the binaryjs project. A similar, but different, extension was made by Tim Caswell for his msgpack-js and msgpack-js-browser projects. Many people have contributed to the discussion about extending MessagePack to separate text string representation from byte string representation.
</p>

<p>
~CBORにおける`追加l情報$の符号化法は、［
`Klaus Hartke^en 氏が~CoAP用に設計した，長さ情報の符号化法
］により着想された。
◎
The encoding of the additional information in CBOR was inspired by the encoding of length information designed by Klaus Hartke for CoAP.
</p>

<p>
この文書は、
多くの人々
— 特に次に挙げる方々 —
により為された示唆も組入れた：
◎
This document also incorporates suggestions made by many people, notably＼
</p>

<div lang="en">
Dan Frost,
James Manger,
Jeffrey Yasskin,
Joe Hildebrand,
Keith Moore,
Laurence Lundblade,
Matthew Lepinski,
Michael Richardson,
Nico Williams,
Peter Occil,
Phillip Hallam-Baker,
Ray Polk,
Stuart Cheshire,
Tim Bray,
Tony Finch,
Tony Hansen,
Yaron Sheffer
</div>

<p>
`Benjamin Kaduk^en 氏は、
~IESG `processing^en の間に，多方面な考査を供された。
◎
Benjamin Kaduk provided an extensive review during IESG processing.
</p>

<p>
`Éric Vyncke, Erik Kline, Robert Wilton, Roman Danyliw^en
各氏は、
更なる~IESG~commentを供された。
— それは、
`Eve Schooler^en 氏による~IoT `directorate^en 考査に含まれる。
◎
Éric Vyncke, Erik Kline, Robert Wilton, and Roman Danyliw provided further IESG comments, which included an IoT directorate review by Eve Schooler.
</p>

	</section>

<p id="authors-addresses">
【§ 著作者~addressの内容は、省略する。】
</p>

</main></div>

