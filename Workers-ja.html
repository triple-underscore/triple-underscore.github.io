<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Web Workers （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'workers',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
case 'coI':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'mc':
	text = 'constructor';
	href = `#dom-${key.toLowerCase()}`;
	break;
case 'm':
case 'mW':
case 'mMP':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text += ':';
	break;
case 'et':
	href = `~HTMLindex#event-${key}`;
	break;
case 'sl':
	text = `[[${text}]]`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2025-01-27
trans_update:2025-01-15
source_checked:240730
page_state_key:HTML
original_url:https://html.spec.whatwg.org/multipage/workers.html
	abbr_url:WORKERS
spec_status:LS
nav_prev:HTMLsse
nav_next:WORKLETS
trans_1st_pub:2012-03-11


●●class_map
e:element
a:attr
E:error
et:event-type
sc:scheme
h:header
jA:abstract
sl:js-slot

●●tag_map
I:code
m:code
mW:code
mMP:code
c:code
e:code
a:code
h:code
sc:code
et:code
E:code
jA:span
sl:span
V:var
i:i
cite:cite

●●original_id_map

	concept-WorkerGlobalScope-owner-set:the-worker's-documents
	'

●●mdn_urls
abstractworker:API/AbstractWorker
dedicatedworkerglobalscope:API/DedicatedWorkerGlobalScope
sharedworker:API/SharedWorker
sharedworkerglobalscope:API/SharedWorkerGlobalScope
worker:API/Worker
	workeroptions:API/WorkerOptions
	workertype:API/WorkerType
workerglobalscope:API/WorkerGlobalScope
workerlocation:API/WorkerLocation
workernavigator:API/WorkerNavigator
navigatorconcurrenthardware:API/NavigatorConcurrentHardware

●●link_map


	●IDL
object:~WEBIDL#idl-object

E.SyntaxError:~WEBIDL#syntaxerror
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.TrustedScriptURL:~TRUSTED-TYPES#trustedscripturl

I.AbstractWorker:#abstractworker
I.DedicatedWorkerGlobalScope:#dedicatedworkerglobalscope
I.MessageEventTarget:~HTMLcomms#messageeventtarget
I.StructuredSerializeOptions:~HTMLcomms#structuredserializeoptions
I.SharedWorker:#sharedworker
I.SharedWorkerGlobalScope:#sharedworkerglobalscope
I.Worker:#worker
I.WorkerOptions:#workeroptions
I.WorkerType:#workertype
I.RequestCredentials:~FETCH#requestcredentials
I.WorkerGlobalScope:#workerglobalscope
I.WorkerLocation:#workerlocation
I.WorkerNavigator:#workernavigator
I.Window:~WINDOW#window
I.Event:~DOM4#event
I.EventTarget:~DOM4#interface-eventtarget
I.EventHandler:~WAPI#eventhandler
I.OnErrorEventHandler:~WAPI#onerroreventhandler
I.ServiceWorkerContainer:~SW1#serviceworkercontainer
I.ServiceWorkerGlobalScope:~SW1#serviceworkerglobalscope

I.NavigatorID:~HTMLnavigator#navigatorid
I.NavigatorLanguage:~HTMLnavigator#navigatorlanguage
I.NavigatorOnLine:~HTMLnavigator#navigatoronline
I.NavigatorConcurrentHardware:#navigatorconcurrenthardware
I.URLUtilsReadOnly:~URL1#urlutilsreadonly
I.MessagePort:~HTMLcomms#messageport
I.MessageEvent:~HTMLcomms#messageevent
I.Document:~HTMLdom#document

	●IDL members
m.onmessage:~HTMLcomms#handler-messageeventtarget-onmessage
m.onmessageerror:~HTMLcomms#handler-messageeventtarget-onmessageerror

		■WorkerGlobalScope
m.self:#dom-workerglobalscope-self
m.location:#dom-workerglobalscope-location
m.navigator:#dom-worker-navigator
m.importScripts:#dom-workerglobalscope-importscripts
m.onerror:#handler-workerglobalscope-onerror
m.onlanguagechange:#handler-workerglobalscope-onlanguagechange
m.onoffline:#handler-workerglobalscope-onoffline
m.ononline:#handler-workerglobalscope-ononline
m.onrejectionhandled:#handler-workerglobalscope-onrejectionhandled
m.onunhandledrejection:#handler-workerglobalscope-onunhandledrejection

		■DedicatedWorkerGlobalScope
m.postMessage:#dom-dedicatedworkerglobalscope-postmessage
m.~postMessageO:#dom-dedicatedworkerglobalscope-postmessage-options
m.name:#dom-dedicatedworkerglobalscope-name
m.close:#dom-dedicatedworkerglobalscope-close

		■SharedWorkerGlobalScope
m.~closeS:#dom-sharedworkerglobalscope-close
m.~nameS:#dom-sharedworkerglobalscope-name
m.onconnect:#handler-sharedworkerglobalscope-onconnect

		■AbstractWorker
mW.onerror:#handler-abstractworker-onerror
		■Worker
m.new Worker:#dom-worker
mW.terminate:#dom-worker-terminate
mW.postMessage:#dom-worker-postmessage
mW.~postMessageO:#dom-worker-postmessage-options
		■SharedWorker
m.new SharedWorker:#dom-sharedworker
mW.port:#dom-sharedworker-port

		■WorkerLocation
m.href:#dom-workerlocation-href
m.origin:#dom-workerlocation-origin
m.protocol:#dom-workerlocation-protocol
m.host:#dom-workerlocation-host
m.hostname:#dom-workerlocation-hostname
m.port:#dom-workerlocation-port
m.pathname:#dom-workerlocation-pathname
m.search:#dom-workerlocation-search
m.hash:#dom-workerlocation-hash

		■NavigatorConcurrentHardware
m.hardwareConcurrency:#dom-navigator-hardwareconcurrency

		■外部
m.addEventListener:~DOM4#dom-eventtarget-addeventlistener

m.start:~HTMLcomms#dom-messageport-start
m.source:~HTMLcomms#dom-messageevent-source
m.ports:~HTMLcomms#dom-messageevent-ports
m.data:~HTMLcomms#dom-messageevent-data

m.transfer:~HTMLcomms#dom-structuredserializeoptions-transfer

mMP.postMessage:~HTMLcomms#dom-messageport-postmessage
mMP.~postMessageO:~HTMLcomms#dom-messageport-postmessage-options

coI.logical:~HTMLds#cross-origin-isolation-logical
coI.concrete:~HTMLds#cross-origin-isolation-concrete

	et.XXX:~HTMLindex#event-XXX
	languagechange
	message
	offline
	online
	error
	rejectionhandled
	unhandledrejection
et.connect:~HTMLindex#event-workerglobalscope-connect

sc.blob:~FILEAPI#url
	廃：~FILEAPI#DefinitionOfScheme
sc.data:~RFCx/rfc2397#section-2

e.iframe:~HEembed#the-iframe-element
e.script:~HEscripting#the-script-element

	●用語
内側~port:#inside-port
外側~port:#outside-port

V.~URL:#_location-url

~workerが終了され:#terminate-a-worker
~workerを終了させ:#terminate-a-worker
~workerを走らす:#run-a-worker
~workerを~closeする:#close-a-worker
休止-可能:#suspendable-worker
許可-可能:#permissible-worker
専用~worker:#dedicatedworkerglobalscope
保護され:#protected-worker
作動中なため必要:#active-needed-worker

~workerの環境~設定群~objを設定しておく:#set-up-a-worker-environment-settings-object

~scriptを~worker大域~scopeの中へ~importする:#import-scripts-into-worker-global-scope

~worker所在~obj:#concept-workerlocation-workerglobalscope
	~worker大域~scope:#concept-workerlocation-workerglobalscope
関連な所有者として追加するもの:#relevant-owner-to-add

wG.~close中か:#dom-workerglobalscope-closing
wG.所有者~集合:#concept-WorkerGlobalScope-owner-set
wG.~port~list:#the-worker's-ports
wG.名前:#concept-workerglobalscope-name
wG.~URL:#concept-workerglobalscope-url
wG.種別:#concept-workerglobalscope-type
wG.施策~容器:#concept-workerglobalscope-policy-container
wG.埋込元~施策:#concept-workerglobalscope-embedder-policy
wG.非同一-生成元~能力は隔離されるか:#concept-workerglobalscope-cross-origin-isolated-capability
wG.~module~map:#concept-workerglobalscope-module-map

wG.構築子~生成元:#concept-sharedworkerglobalscope-constructor-origin
wG.構築子~URL:#concept-sharedworkerglobalscope-constructor-url
wG.資格証:#concept-sharedworkerglobalscope-credentials

共用~worker管理器:#shared-worker-manager

	●用語（HTML

並列的:~HTMLINFRA#in-parallel
新たな並列~queueを開始する:~HTMLINFRA#starting-a-new-parallel-queue
手続きを~enqueueする:~HTMLINFRA#enqueue-the-following-steps

~URLを符号化法の下で相対的に構文解析する:~HTMLurl#encoding-parsing-a-url

文書:~HTMLdom#the-document-object

~portを連絡する:~HTMLcomms#entangle
連絡-:~HTMLcomms#entangle
~port~message~queue:~HTMLcomms#port-message-queue
~message~channel:~HTMLcomms#channel-messaging
~message~event~target:~HTMLcomms#message-event-target

~event~handler:~WAPI#event-handlers
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
~worker~event~loop:~WAPI#worker-event-loop-2
~event~loop:~WAPI#event-loop
aG.~event~loop:~WAPI#concept-agent-event-loop
~module~map:~WAPI#module-map
例外を報告する:~WAPI#report-an-exception
sC.再投出-用~error:~WAPI#concept-script-error-to-rethrow
~script:~WAPI#concept-script
古典~script:~WAPI#classic-script
~module~script:~WAPI#module-script
~worker用~古典~scriptを~fetchする:~WAPI#fetch-a-classic-worker-script
~module~worker~script~graphを~fetchする:~WAPI#fetch-a-module-worker-script-tree
~workerが~importした古典~scriptを~fetchする:~WAPI#fetch-a-classic-worker-imported-script

古典~scriptを走らす:~WAPI#run-a-classic-script
~module~scriptを走らす:~WAPI#run-a-module-script
~scriptを作成-:~WAPI#create-a-script
~realm実行~環境:~WAPI#realm-execution-environment
	~task~source:~WAPI#task-source
~task:~WAPI#concept-task
~taskを~queueする:~WAPI#queue-a-task
大域~taskを~queueする:~WAPI#queue-a-global-task
~task~queue:~WAPI#task-queue
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
大域~obj:~WAPI#global-object
関連な大域~obj:~WAPI#concept-relevant-global
rM.大域~obj:~WAPI#concept-realm-global

新たな~realmを作成する:~WAPI#creating-a-new-javascript-realm
環境を破棄する手続き:~WAPI#environment-discarding-steps
関連な~agent:~WAPI#relevant-agent
専用／共用~worker~agentを得する:~WAPI#obtain-a-dedicated/shared-worker-agent

enV.~secureな文脈:~WAPI#secure-context
enV.~realm:~WAPI#environment-settings-object's-realm
enV.大域~obj:~WAPI#concept-settings-object-global
enV.~ID:~WAPI#concept-environment-id
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.~target閲覧~文脈:~WAPI#concept-environment-target-browsing-context
enV.作動中な~sw:~WAPI#concept-environment-active-service-worker
enV.担当の~event~loop:~WAPI#responsible-event-loop
enV.生成元:~WAPI#concept-settings-object-origin
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.~module~map:~WAPI#concept-settings-object-module-map
enV.施策~容器:~WPAI#concept-settings-object-policy-container
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability
enV.~API用~基底~URL:~WAPI#api-base-url
enV.時刻~起点:~WAPI#concept-settings-object-time-origin

現在の設定群~obj:~WAPI#current-settings-object
設定群~obj:~WAPI#settings-object
関連な設定群~obj:~WAPI#relevant-settings-object
環境~設定群~obj:~WAPI#environment-settings-object
尚早に中止され:~WAPI#abort-a-running-script
走っている~scriptを中止する:~WAPI#abort-a-running-script
~fetch~hookを遂行する~algo:~WAPI#fetching-scripts-perform-fetch
~fetchを遂行する~hook:~WAPI#fetching-scripts-perform-fetch
V.~custom~fetch応答の処理n:~WAPI#fetching-scripts-processcustomfetchresponse
V.~top-levelか:~WAPI#fetching-scripts-is-top-level
実行は準備済みか:~WAPI#concept-environment-execution-ready-flag
agC.非同一-生成元~隔離~mode:~WAPI#agent-cluster-cross-origin-isolation

作動中な~timer群が成す~map:~HTMLGAPI#map-of-active-timers

~top-level辿可能:~HTMLds#top-level-traversable
~navigable:~HTMLds#navigable
nav.作動中な文書:~HTMLds#nav-document
全部的に作動中:~HTMLds#fully-active
閲覧~文脈:~HTMLds#browsing-context

結付けられた文書:~WINDOW#concept-document-window
~window:~WINDOW#the-window-object

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
同一-生成元:~ORIGIN#same-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
施策~容器:~ORIGIN#policy-container
埋込元~施策:~ORIGIN#embedder-policy
大域~objの埋込元~施策を検査する:~ORIGIN#check-a-global-object's-embedder-policy
~worker大域~scopeの施策~容器を初期化する:~ORIGIN#initialize-worker-policy-container
embP.値:~ORIGIN#embedder-policy-value-2
非同一-生成元~隔離と互換:~ORIGIN#compatible-with-cross-origin-isolation

完全に読込まれ:~HTMLlifecycle#completely-loaded

	●用語（他

実装定義:~INFRA#implementation-defined
set.付加する:~INFRA#set-append
集合:~INFRA#ordered-set
~list:~INFRA#list
空:~INFRA#list-is-empty
付加する:~INFRA#list-append
map.~clearする:~INFRA#map-clear
~scalar値~文字列:~INFRA#scalar-value-string
~byte列:~INFRA#byte-sequence
連結する:~INFRA#string-concatenate

凍結d配列:~WEBIDL#dfn-frozen-array-type
新たな~obj:~WEBIDLjs#new

~eventを発火する:~DOM4#concept-event-fire

安全でない共有される現在の時刻:~HRTIME#dfn-unsafe-shared-current-time
時刻を粗化する:~HRTIME#dfn-coarsen-time

非~storage目的~用に~storage~keyを得する:~STORAGE#obtain-a-storage-key-for-non-storage-purposes
同等な~storage~key:~STORAGE#storage-key-equal


~URL:~URL1#concept-url
同等な~URL:~URL1#concept-url-equals
url.~scheme:~URL1#concept-url-scheme
url.~host:~URL1#concept-url-host
url.~port:~URL1#concept-url-port
url.~query:~URL1#concept-url-query
url.素片:~URL1#concept-url-fragment
url.生成元:~URL1#concept-url-origin

整数を直列化する:~URL1#serialize-an-integer
~hostを直列化する:~URL1#concept-host-serializer
~URLを直列化する:~URL1#concept-url-serializer
~URL~pathを直列化する:~URL1#url-path-serializer

信用-済みな型に準拠な文字列を取得する:~TRUSTED-TYPES#get-trusted-type-compliant-string-algorithm

~fetchする:~FETCH#concept-fetch
~network~error:~FETCH#concept-network-error
rq.予約-済み~client:~FETCH#concept-request-reserved-client
i.応答の処理n:~FETCH#process-response
i.応答の本体を消費する処理n:~FETCH#process-response-end-of-body
応答:~FETCH#concept-response
rs.~URL:~FETCH#concept-response-url

~JS実行~文脈:~TC39#sec-execution-contexts
~agent~cluster:~TC39#sec-agent-clusters

~client~message~queue:~SW1#dfn-client-message-queue
~sw~client:~SW1#serviceworkercontainer-service-worker-client

大域~obj用に~CSP初期化を走らす:~CSP3#run-global-object-csp-initialization

●●words_table1
DEMO:https://html.spec.whatwg.org/demos/workers
	Document: <code>Document</code> 
closeS:close
nameS:name
postMessageO:postMessage

●●words_table



	●序論
	ユーザインタフェース
core::::コア
demo::::デモ
online::::オンライン
private::非公開
public::公開
chat::::チャット
routine::::ルーチン
strict:
tutorial::::チュートリアル
viewer::::ビューア
マップ:map::~

仕事:task::~::タスク
代理-:proxy:~
協同-:collaborate:~
	単純にする:simplicity
即応可能:responsive::~::レスポンシブ
原理:principle:~
告知-:announce:~
文:statement:~
漸進的:progressive:~
直な:directな:~
直通:direct:~
	different
立上げる:launchする:立ち上げる
素数:prime number:~
素朴:naïve:~
衝突-:collide:~
返信-:send back::~
返送:transfer back::~
輝度:luminance:~
	人の目は 赤, 青 に鈍感
	減衰-
比較的:relativeに:~

	通用:apply
	普及:becoming prevalent
	書かれ
	注意
	着目すべき点:key things worth noting
	興味を引く:interesting
	良い~~選択:better choice
	要する
	記し方:signature
	関係が深い:involved
	~~簡単:quick
	ここでの名称:called herein
	一律:turn all
	不要
	仕方:way
	~map
	保ち
	束ねる:coordinating
	動き回れ:move around
	示-:
	置かれ:
	見つか:found
	見る
	加える
	事を終え:is done with
	~~指名:naming
	付番
	付け加え:attach

	ごとに分別:by
	付与
	可能
	各升:tiles
	同様
	変数
	多数の同時利用:used in large numbers
	完成:finished
	明るく
	幾千万:mega-
	後続の:
	易い
	最新:recent
	望む限り
	本物
	様
	汚さな:polluting
	分業:split
	渡り
	~~状況
	生成-:spawn
	~~発見:found
	等分:farmed out
	親しみ易い:friendly
	計算:compute, calculation
	計算量の大きな:computationally expensive
	達
	違える:different
	選んで
	重い:heavy-weight
	長い:long
	長時間居残:long-lived
	長期:long
	開く:open
	開ける:open でき
	関して
	高くつく
	備わり
	形

	実行環境
	登場
	所
	推察
	理解-

	~~示唆
	考えれ
	~~個別的:specific

	■暗号 library
stub::::スタブ
負荷委譲-:offload::負荷を委譲
鍵:key::~
公開鍵:public key::~
私用鍵:private key::~
暗号:crypto::~
暗号化:cryptography::~
暗号化-:encrypt::~
復号化-:decrypt::復号
平文:plaintext::~
暗号文:ciphertext::~

	-:Notice how
	本当の:real
	以降は:remainder
	知る:know
	小分けに:little

	●fetch, url, network
同等:equal:~
	fetching
	予約-済み:reserved
	●通信
transaction::::トランザクション
	接続-法:connecting
連絡-:entangle::~::エンタングル
	連絡-を断つ:disentangle
	送信-法:sending
	通信-法:communicating
	転送-法:transferring

	●保安
	similar-origin:
迂回-:bypass:~

	●環境
下位worker:subworker::下位 worker
担当の:responsible::~
agent:
埋込元:embedder::埋め込み元

	●IDL／型／構造
孤立:orphan::~
	設定しておく:set up

	●処理
close:
	~close中:closing
稼働時の:runtime::~
再投出-:rethrow::~
timer::::タイマー
制限時間:timeout::~
	制限時間:timeout value
待機中:outstanding:~
background::::バックグラウンド
尚早:premature:~
並列:parallel::~
活動:activities::~
休止:suspending::~
作成時の:creation::~
作成元:creator::~
存続期間:lifetime::~
処理待ち:pending:~
開始時:start-up 時:~
生残れる:surviveできる:生き残れる
起点:origin::~
粗化-:coarsen:粗く
連結-:concatenate:~
	連結-:followed by

	~instance化-:instantiate
	最適化されていない:unoptimized
	開始し直す:restart
	不具合があれば:went amiss

	●変数
	%~worker大域~scope:workerGlobal
	%~worker大域~scope:worker global scope
	%G:-
	%P:-
	%Q:-
	%O:o
	%~worker:worker
	%~URL:-
	%~URL:url
	%~URL文字列:url
	%~URL群:urls
	%~URL~record群:urlRecords
	%~URL文字列
	%外側~設定群:outside settings
	%外側~port:outside port
	%options:options
	%共用か:is shared
	%所有者:owner
	%安全でない~worker作成~時刻:unsafeWorkerCreationTime
	%~agent:agent
	%~realm実行~文脈:realm execution context
	%内側~設定群:inside settings
	%行先:destination
	%要請:request
	%~top-levelか:isTopLevel
	%~top-levelか:isTopLevel
	%~custom~fetch応答の処理n:processCustomFetchResponse
	%応答:response
	%~script:script
	%内側~port:inside port
	%実行~文脈:execution context
	%継承した生成元:inherited origin
	%realm:realm
	%設定群~obj:settings object
	%worker:-
	%~worker~URL:worker URL
	%~URL~record:urlRecord
	%~call元は~secureな文脈か:callerIsSecureContext
	%外側~storage~key:outside storage key
	%~scope:scope
	%~worker~storage~key:worker storage key
	%~workerは~secureな文脈か:workerIsSecureContext
	%~errorは再投出するか
	%~host:host
	%~port:port
	%~query:query
	%素片:fragment
	%完了-時の手続き:onComplete
	%~fetchを遂行する:performFetch
	%本体~byte列:bodyBytes
	%準拠な~script~URL:compliantScriptURL
	%~URL文字列~群:urlStrings
	コレ:worker
	%共用か:shared

	●仕様
適応-:accommodate:~
給-:supply:~
保守的:conservative:~
協調-:coordinate:~
準拠な:compliantな:準拠する

	任意選択で:may
	観測され得:observably
	最新情報:the latest
	本当は:really
	されるべき:ought
	設計し直:redesign
	~~解明する:figure out
	深く関わる:involved

	●未分類
管理器:manager::~::マネージャ
繋がろ:contactしよ:~
import:
main::::メイン
database::::データベース
CPU:
CPUs:processor 数::CPU 数
	CPUs:processors
番号:number:~
	数値計算:number-crunching
	数:number
仕切り:partition::~
同一性:identity:~

	後続:following
	対応-
	生み出-:spawn
	:follow
	合致しない:mismatch
	位置:position
	方法
	時点:moment
	可能
	必要
	最~大:highest

	●指示語
現在:currently:~
	1 個だけ:single
	度
	何個
	他方:another
	の外:off-
		〜の代わりに:instead
	最後
	最初
	一方
	一部
	別々の:diffrent
	次第
	同様
	自身
	一連
	以下
	次
	全体
	複数
	もう:no longer
	唯一:only
	種類:kinds of
	また別の:third
	対象:
	以降:
	すでにある:already on
	もの:construct
	上述:
	外で
	少し
	一方の
	今の
	代わり
	何か
	何らか
	側
	最も
	範囲


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ Web Workers</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTML — web worker</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="workers">
<h2 title="Web Workers">10. ~web~worker</h2>

		<section id="introduction-14">
<h3 title="Introduction">10.1. 序論</h3>

			<section id="scope-2">
<h4 title="Scope">10.1.1. 視野</h4>

◎非規範的

<p>
この仕様は、
他の~UI~scriptから独立に，~backgroundで~scriptを走らすための~APIを定義する。
◎
This specification defines an API for running scripts in the background independently of any user interface scripts.
</p>

<p>
それは、
次を許容する
⇒
~clickその他 利用者-ヤリトリに応答する~scriptから中断されることなく，
長期に渡り~scriptを走らせる
— すなわち、
~pageを即応可能に保ちながら，長い~taskを実行する。
◎
This allows for long-running scripts that are not interrupted by scripts that respond to clicks or other user interactions, and allows long tasks to be executed without yielding to keep the page responsive.
</p>

<p>
~worker（これらの~background~scriptの ここでの名称）は、
比較的 重いので，多数の同時利用は意図されていない。
例えば、
画像~内に幾千万ある画素ごとに異なる~workerを立上げるのは不適切である。
下の例に~workerの適切な利用を示す：
◎
Workers (as these background scripts are called herein) are relatively heavy-weight, and are not intended to be used in large numbers. For example, it would be inappropriate to launch one worker for each pixel of a four megapixel image. The examples below show some appropriate uses of workers.
</p>

<p>
一般に，~workerは長時間居残り続けるので、
開始時の処理能~cost, および~instanceごとの~memory~costは，高くつくものと予期されている。
◎
Generally, workers are expected to be long-lived, have a high start-up performance cost, and a high per-instance memory cost.
</p>

			</section>
			<section id="examples-6">
<h4 title="Examples">10.1.2. 例</h4>

◎非規範的

<p>
~workerには様々な利用がある。
以下の各~下位節に，その利用を示す。
◎
There are a variety of uses that workers can be put to. The following subsections show various examples of this use.
</p>

				<section id="a-background-number-crunching-worker">
<h5 title="A background number-crunching worker">10.1.2.1. ~backgroundで数値計算し続ける~worker</h5>

◎非規範的

<p>
~workerの最も単純な利用は、
~UIを中断せずに計算量の大きな仕事を遂行するものである。
◎
The simplest use of workers is for performing a computationally expensive task without interrupting the user interface.
</p>

<p>
この例では、
~main文書が~workerを生み出して,
（素朴な）素数の~~計算を行い,
見つかった最新の素数を漸進的に表示し続ける。
◎
In this example, the main document spawns a worker to (naïvely) compute prime numbers, and progressively displays the most recently found prime number.
</p>

<p>
~main~pageは次で与えられる：
◎
The main page is as follows:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;~worker例： 単-~coreによる~~計算&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;これまでに見つかった最~大の素数は：&lt;output id="result"&gt;&lt;/output&gt;&lt;/p&gt;

&lt;script&gt;
   var %worker = new Worker('worker.js');
   %worker.onmessage = function (%event) {
     document.getElementById('result').textContent = %event.data;
   };
&lt;/script&gt;

 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
`new Worker()$m
構築子の~callにより，~workerが作成され、［
その~workerを表現し, その~workerと通信する， `Worker$I ~obj
］が返される。
~objの `onmessage$m ~event~handlerには、
~workerから~messageを受信する~codeを入れられる。
◎
The Worker() constructor call creates a worker and returns a Worker object representing that worker, which is used to communicate with the worker. That object's onmessage event handler allows the code to receive messages from the worker.
</p>

<p>
~worker自身は次で与えられる：
◎
The worker itself is as follows:
</p>

<pre class="lang-js">
var %n = 1;
search: while (true) {
  %n += 1;
  for (var %i = 2; %i &lt;= Math.sqrt(%n); %i += 1)
    if (%n % %i == 0)
     continue search;
  /* <span class="comment">
素数~~発見！
◎
found a prime!
</span> */
  postMessage(%n);
}
</pre>

<p class="trans-note">【
いきなり `postMessage()$m が大域~関数として登場している所からも推察されるように、
ちょうど通常時における~scriptの `Window^I ~objにあたる，
~worker用の~script実行~環境を与える大域~obj
（`§ 大域~scope＠#the-global-scope$）が，
（~workerを生み出した側の実行~環境とは別に）
存在している、
と考えれば，この仕様の残りの部分も理解し易い。
】</p>

<p>
この~codeは、
単純な，最適化されていない，素数の探索~routineである。
`postMessage()$m が、
見つかった素数を~messageにして~pageに返信する~methodである。
◎
The bulk of this code is simply an unoptimized search for a prime number. The postMessage() method is used to send a message back to the page when a prime is found.
</p>

<p>
`この例を~onlineで見る＠~DEMO/primes/page.html$
◎
View this example online.
</p>

				</section>
				<section id="module-worker-example">
<h5 title="Using a JavaScript module as a worker">10.1.2.2. ~JS~moduleを~workerとして利用する</h5>

◎非規範的

<div class="p">
<p>
これまでの どの例も`古典~script$を走らす~workerを示してきたが、
~workerは，`~module~script$を利用して~instance化することもできる
— これには、
通例的に，次に挙げる便益がある：
</p>
<ul>
	<li>
~JS `import^c 文を利用して他の~moduleを~importする能
</li>
	<li>
既定で~strict~modeになる
</li>
	<li>
~workerの大域~scopeを汚さない，~top-levelの宣言
</li>
</ul>
◎
All of our examples so far show workers that run classic scripts. Workers can instead be instantiated using module scripts, which have the usual benefits: the ability to use the JavaScript import statement to import other modules; strict mode by default; and top-level declarations not polluting the worker's global scope.
</div>

<p>
`import^c 文が可用になったことに伴い、
`importScripts()$m ~methodは，~module~workerの内側では自動的に失敗することになる。
◎
As the import statement is available, the importScripts() method will automatically fail inside module workers.
</p>

<p>
この例では、
~main文書が［
~main~threadの外で画像~操作を行う~worker
］を利用する。
それは、
別の~moduleから利用される~filterを~importする。
◎
In this example, the main document uses a worker to do off-main-thread image manipulation. It imports the filters used from another module.
</p>

<p>
~main~pageは：
◎
The main page is as follows:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;~worker例： 画像を復号する&lt;/title&gt;

&lt;p&gt;
  &lt;label&gt;
    復号する画像の URL を入れてください<!-- Type an image URL to decode -->
    &lt;input type="url" id="image-url" list="image-list"&gt;
    &lt;datalist id="image-list"&gt;
      &lt;option value="https://html.spec.whatwg.org/images/drawImage.png"&gt;
      &lt;option value="https://html.spec.whatwg.org/images/robots.jpeg"&gt;
      &lt;option value="https://html.spec.whatwg.org/images/arcTo2.png"&gt;
    &lt;/datalist&gt;
  &lt;/label&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;label&gt;
    適用する~filterを選んでください<!-- Choose a filter to apply -->
    &lt;select id="filter"&gt;
      &lt;option value="none"&gt;none&lt;/option&gt;
      &lt;option value="grayscale"&gt;grayscale&lt;/option&gt;
      &lt;option value="brighten"&gt;brighten by 20%&lt;/option&gt;
    &lt;/select&gt;
  &lt;/label&gt;
&lt;/p&gt;

&lt;div id="output"&gt;&lt;/div&gt;

&lt;script type="module"&gt;
  const %worker = new Worker("worker.js", { type: "module" });
  %worker.onmessage = receiveFromWorker;

  const %url = document.querySelector("#image-url");
  const %filter = document.querySelector("#filter");
  const %output = document.querySelector("#output");

  %url.oninput = updateImage;
  %filter.oninput = sendToWorker;

  let %imageData, %context;

  function updateImage() {
    const %img = new Image();
    %img.src = %url.value;

    %img.onload = () =&gt; {

      const %canvas = document.createElement("canvas");
      %canvas.width = %img.width;
      %canvas.height = %img.height;

      %context = %canvas.getContext("2d");
      %context.drawImage(%img, 0, 0);
      %imageData = %context.getImageData(0, 0, %canvas.width, %canvas.height);

      sendToWorker();
      %output.replaceChildren(%canvas);
    };
  }

  function sendToWorker() {
    %worker.postMessage({ %imageData, filter: %filter.value });
  }

  function receiveFromWorker(%e) {
    %context.putImageData(%e.data, 0, 0);
  }
&lt;/script&gt;
</pre>

<p>
~worker~fileは：
◎
The worker file is then:
</p>

<pre class="lang-js">
import * as filters from "./filters.js";

self.onmessage = %e =&gt; {
  const { %imageData, %filter } = %e.data;
  filters[%filter](%imageData);
  self.postMessage(%imageData, [%imageData.data.buffer]);
};
</pre>

<p>
これは、
次の~file `filters.js^c を~importする：
◎
Which imports the file filters.js:
</p>

<pre class="lang-js">
export function none() {}

export function grayscale({ data: %d }) {
  for (let %i = 0; %i &lt; %d.length; %i += 4) {
    const [%r, %g, %b] = [%d[%i], %d[%i + 1], %d[%i + 2]];
    /* <span class="comment">
RGB に対する CIE 輝度
— ヒトの目は 赤, 青 に鈍感なので，それらを減衰する
◎
CIE luminance for the RGB
— The human eye is bad at seeing red and blue, so we de-emphasize them.
</span> */
    %d[%i] = %d[%i + 1] = %d[%i + 2] = 0.2126 * %r + 0.7152 * %g + 0.0722 * %b;
  }
};

export function brighten({ data: %d }) {
  for (let %i = 0; %i &lt; %d.length; ++%i) {
    %d[%i] *= 1.2;
  }
};</pre>

<p>
`この例を~onlineで見る＠~DEMO/modules/page.html$
◎
View this example online.
</p>

				</section>
				<section id="shared-workers-introduction">
<h5 title="Shared workers introduction">10.1.2.3. 共用~worker序論</h5>

◎非規範的

<p>
この節では、
Hello World の例を利用して，共用~workerを導入する。
共用~workerにおいては、
各~workerが複数の接続を有し得るので，少し異なる~APIが利用される。
◎
This section introduces shared workers using a Hello World example. Shared workers use slightly different APIs, since each worker can have multiple connections.
</p>

<p>
この最初の例では、［
~pageから~workerに どう接続するか
］および［
接続-時に ~workerが~pageに向けて~messageを どう返信するか
］を示す。
受信された~messageは、
~logに表示される。
◎
This first example shows how you connect to a worker and how a worker can send a message back to the page when it connects to it. Received messages are displayed in a log.
</p>

<p>
~HTML~pageをここに示す：
◎
Here is the HTML page:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;共用~worker： ~demo 1&lt;/title&gt;
&lt;pre id="log"&gt;Log:&lt;/pre&gt;

&lt;script&gt;
  var %worker = new SharedWorker('test.js');
  var %log = document.getElementById('log');
  %worker.port.onmessage = function(%e) { /* <span class="comment">
<code >%worker.onmessage</code> ではないことに注意
◎
note: not worker.onmessage!
</span> */
    %log.textContent += '\n' + %e.data;
  }
&lt;/script&gt;
</pre>

<p>
~JS~workerは次になる：
◎
Here is the JavaScript worker:
</p>

<pre class="lang-js">
onconnect = function(%e) {
  var %port = %e.ports[0];
  %port.postMessage('Hello World!');
}
</pre>

<p class="trans-note">【
`onconnect^m の名が~~示唆するように、
接続が確立され次第，~workerの大域~scopeに属する `onconnect()^m が呼出される。
】</p>

<p>
`この例を~onlineで見る＠~DEMO/shared/001/test.html$
◎
View this example online.
</p>

<hr>

<p>
次の例は、
2 つの変更により，最初のものを拡張する：
まず，
~messageは`~event~handler~IDL属性$の代わりに `addEventListener()$m を利用して受信される。
次に，~messageは
~workerに<em>向けて</em>送信され，
それに対し~workerが別の~messageを返信するようにしている。
受信された~messageは再び~logに表示される。
◎
This second example extends the first one by changing two things: first, messages are received using addEventListener() instead of an event handler IDL attribute, and second, a message is sent to the worker, causing the worker to send another message in return. Received messages are again displayed in a log.
</p>

<p>
~HTML~pageは：
◎
Here is the HTML page:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;共用~worker： ~demo 2&lt;/title&gt;
&lt;pre id="log"&gt;Log:&lt;/pre&gt;

&lt;script&gt;
  var %worker = new SharedWorker('test.js');
  var %log = document.getElementById('log');
  %worker.port.addEventListener('message', function(%e) {
    %log.textContent += '\n' + %e.data;
  }, false);
  %worker.port.start(); /* <span class="comment">
注記： `addEventListener()^m を利用した場合はこれが必要になる
◎
note: need this when using addEventListener
</span> */
  %worker.port.postMessage('ping');
&lt;/script&gt;
</pre>

<p>
~JS~workerは：
◎
Here is the JavaScript worker:
</p>

<pre class="lang-js">
onconnect = function(%e) {
  var %port = %e.ports[0];
  %port.postMessage('Hello World!');
  %port.onmessage = function(%e) {
    %port.postMessage('pong'); /* <span class="comment">
<code>%e.ports[0].postMessage</code> ではないことに注意
◎
not e.ports[0].postMessage!
</span> */
    /* <span class="comment">
<code>%e.target.postMessage('pong');</code> でもいける
◎
e.target.postMessage('pong'); would work also
</span> */
  }
}
</pre>

<p>
`この例を~onlineで見る＠~DEMO/shared/002/test.html$
◎
View this example online.
</p>

<hr>

<p>
最後の例は、
2 つの~pageから同じ~workerに接続させる方法を示す。
この例では， 2 番目の~pageは 単に最初の~pageの `iframe$e に入れられているが、
同じ原理は，［
別々な`~top-level辿可能$に属する まったく別々な~page
］であっても通用する。
◎
Finally, the example is extended to show how two pages can connect to the same worker; in this case, the second page is merely in an iframe on the first page, but the same principle would apply to an entirely separate page in a separate top-level traversable.
</p>

<p>
外縁~HTML~page：
◎
Here is the outer HTML page:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;共用~worker： ~demo 3&lt;/title&gt;
&lt;pre id="log"&gt;Log:&lt;/pre&gt;

&lt;script&gt;
  var %worker = new SharedWorker('test.js');
  var %log = document.getElementById('log');
  %worker.port.addEventListener('message', function(%e) {
    %log.textContent += '\n' + %e.data;
  }, false);
  %worker.port.start();
  %worker.port.postMessage('ping');
&lt;/script&gt;

&lt;iframe src="inner.html"&gt;&lt;/iframe&gt;
</pre>

<p>
内縁~HTML~page：
◎
Here is the inner HTML page:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;共用~worker： ~demo 3 inner frame&lt;/title&gt;
&lt;pre id=log&gt;Inner log:&lt;/pre&gt;

&lt;script&gt;
  var %worker = new SharedWorker('test.js');
  var %log = document.getElementById('log');
  %worker.port.onmessage = function(%e) {
   %log.textContent += '\n' + %e.data;
  }
&lt;/script&gt;
</pre>

<p>
~JS~workerは：
◎
Here is the JavaScript worker:
</p>

<pre class="lang-js">
var %count = 0;
onconnect = function(%e) {
  %count += 1;
  var %port = %e.ports[0];
  %port.postMessage('Hello World! You are connection #' + %count);
  %port.onmessage = function(%e) {
    %port.postMessage('pong');
  }
}
</pre>

<p>
`この例を~onlineで見る＠~DEMO/shared/003/test.html$
◎
View this example online.
</p>

				</section>
				<section id="shared-state-using-a-shared-worker">
<h5 title="Shared state using a shared worker">10.1.2.4. 共用~workerの利用による状態の共有-</h5>

◎非規範的

<p>
次の例では、
同じマップを~~表示する複数の~window（~viewer）を開けるようになっている。
すべての~windowが同じマップ情報を共有し、
単独の~workerが すべての~viewerを協調する。
各~viewerの中では，他と独立にマップ内を動き回れ、
いずれかの~viewerにてマップ内に何らかの~dataが置かれたときは，
すべての~viewerが更新される。
◎
In this example, multiple windows (viewers) can be opened that are all viewing the same map. All the windows share the same map information, with a single worker coordinating all the viewers. Each viewer can move around independently, but if they set any data on the map, all the viewers are updated.
</p>

<p>
~main~pageは、
興味を引くものではなく，
~viewerを開く仕方を供するものでしかない：
◎
The main page isn't interesting, it merely provides a way to open the viewers:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;~worker例： Multiviewer&lt;/title&gt;

&lt;script&gt;
   function openViewer() {
     window.open('viewer.html');
   }
&lt;/script&gt;

 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;&lt;button type=button onclick="openViewer()"&gt;新たな~viewerを開く&lt;/button&gt;&lt;/p&gt;
  &lt;p&gt;各~viewerは新たな~windowを開きます。好きなだけ，いくつでも~viewerを開けます。それらはすべて同じ~dataを~~表示します。&lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<!-- 
Open a new viewer
Each viewer opens in a new window. You can have as many viewers as you like, they all view the same data.

 -->

<p>
より深く関わるのは、
~viewerである：
◎
The viewer is more involved:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;~worker例： Multiviewer ~viewer&lt;/title&gt;

&lt;script&gt;
   var %worker = new SharedWorker('worker.js', 'core');

   /* <span class="comment">
環境設定
◎
CONFIGURATION
</span> */
   function configure(%event) {
     if (%event.data.substr(0, 4) != 'cfg ') return;
     var %name = %event.data.substr(4).split(' ', 1)[0];
     /* <span class="comment">
名前が %name であることを示すために表示を更新する
◎
update display to mention our name is name
</span> */
     document.getElementsByTagName('h1')[0].textContent += ' ' + %name;
     /* <span class="comment">
この~listenerはもう不要
◎
no longer need this listener
</span> */
     %worker.port.removeEventListener('message', configure, false);
   }
   %worker.port.addEventListener('message', configure, false);

   /* <span class="comment">
マップ
◎
MAP
</span> */
   function paintMap(%event) {
     if (%event.data.substr(0, 4) != 'map ') return;
     var %data = %event.data.substr(4).split(',');
     /* <span class="comment">
<code >%data[0] .. %data[8]</code> の各升を表示する
◎
display tiles data[0] .. data[8]
</span> */
     var %canvas = document.getElementById('map');
     var %context = %canvas.getContext('2d');
     for (var %y = 0; %y &lt; 3; %y += 1) {
       for (var %x = 0; %x &lt; 3; %x += 1) {
         var %tile = data[%y * 3 + %x];
         if (%tile == '0')
           %context.fillStyle = 'green';
         else 
           %context.fillStyle = 'maroon';
         %context.fillRect(x * 50, y * 50, 50, 50);
       }
     }
   }
   %worker.port.addEventListener('message', paintMap, false);

   /* <span class="comment">
~public~chat
◎
PUBLIC CHAT
</span> */
   function updatePublicChat(%event) {
     if (%event.data.substr(0, 4) != 'txt ') return;
     var %name = %event.data.substr(4).split(' ', 1)[0];
     var %message = %event.data.substr(4 + %name.length + 1);
     /* <span class="comment">
~public~chatに "<code>&lt;%name&gt; %message</code>" を表示する
◎
display &quot;&lt;name&gt; message&quot; in public chat
</span> */
     var %public = document.getElementById('public');
     var %p = document.createElement('p');
     var %n = document.createElement('button');
     %n.textContent = '&lt;' + %name + '&gt; ';
     %n.onclick = function () { %worker.port.postMessage('msg ' + %name); };
     %p.appendChild(%n);
     var %m = document.createElement('span');
     %m.textContent = %message;
     %p.appendChild(%m);
     %public.appendChild(%p);
   }
   %worker.port.addEventListener('message', updatePublicChat, false);

   /* <span class="comment">
~private~chat
◎
PRIVATE CHAT
</span> */
   function startPrivateChat(%event) {
     if (%event.data.substr(0, 4) != 'msg ') return;
     var %name = %event.data.substr(4).split(' ', 1)[0];
     var %port = %event.ports[0];
     /* <span class="comment">
~private~chat~UIを表示する
◎
display a private chat UI
</span> */
     var %ul = document.getElementById('private');
     var %li = document.createElement('li');
     var %h3 = document.createElement('h3');
     %h3.textContent = 'Private chat with ' + %name;
     %li.appendChild(%h3);
     var %div = document.createElement('div');
     var %addMessage = function(%name, %message) {
       var %p = document.createElement('p');
       var %n = document.createElement('strong');
       %n.textContent = '&lt;' + %name + '&gt; ';
       %p.appendChild(%n);
       var %t = document.createElement('span');
       %t.textContent = %message;
       %p.appendChild(%t);
       %div.appendChild(%p);
     };
     %port.onmessage = function (%event) {
       addMessage(%name, %event.data);
     };
     %li.appendChild(%div);
     var %form = document.createElement('form');
     var %p = document.createElement('p');
     var %input = document.createElement('input');
     %input.size = 50;
     %p.appendChild(%input);
     %p.appendChild(document.createTextNode(' '));
     var %button = document.createElement('button');
     %button.textContent = 'Post';
     %p.appendChild(%button);
     %form.onsubmit = function () {
       %port.postMessage(%input.value);
       addMessage('me', %input.value);
       %input.value = '';
       return false;
     };
     %form.appendChild(%p);
     %li.appendChild(%form);
     %ul.appendChild(%li);
   }
   %worker.port.addEventListener('message', startPrivateChat, false);

   %worker.port.start();
&lt;/script&gt;

 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;Viewer&lt;/h1&gt;
  &lt;h2&gt;Map&lt;/h2&gt;
  &lt;p&gt;&lt;canvas id="map" height=150 width=150&gt;&lt;/canvas&gt;&lt;/p&gt;
  &lt;p&gt;
   &lt;button type=button onclick="%worker.port.postMessage('mov left')"
   &gt;Left&lt;/button&gt;
   &lt;button type=button onclick="%worker.port.postMessage('mov up')"
   &gt;Up&lt;/button&gt;
   &lt;button type=button onclick="%worker.port.postMessage('mov down')"
   &gt;Down&lt;/button&gt;
   &lt;button type=button onclick="%worker.port.postMessage('mov right')"
   &gt;Right&lt;/button&gt;
   &lt;button type=button onclick="%worker.port.postMessage('set 0')"
   &gt;Set 0&lt;/button&gt;
   &lt;button type=button onclick="%worker.port.postMessage('set 1')"
   &gt;Set 1&lt;/button&gt;
  &lt;/p&gt;
  &lt;h2&gt;Public Chat&lt;/h2&gt;
  &lt;div id="public"&gt;&lt;/div&gt;
  &lt;form onsubmit="%worker.port.postMessage('txt ' + %message.value);
    %message.value = ''; return false;"
  &gt;
   &lt;p&gt;
    &lt;input type="text" name="message" size="50"&gt;
    &lt;button&gt;Post&lt;/button&gt;
   &lt;/p&gt;
  &lt;/form&gt;
  &lt;h2&gt;Private Chat&lt;/h2&gt;
  &lt;ul id="private"&gt;&lt;/ul&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
~viewerの書かれ方には、
着目すべき点がいくつかある。
◎
There are several key things worth noting about the way the viewer is written.
</p>

<p>
<strong>複数の~listener</strong>：
この~codeは、
1 個の~message処理~関数の代わりに，
複数の~event~listenerを付け加えている
— それぞれが~messageに関連するかどうか~~簡単な検査を遂行するような。
この例では，さほど大きな相違は生じないが、
幾人かの作者~達が協同する中で，
~workerとの通信に単独の~portの利用が求まれる~~状況においても、
すべての変更を単独の~event取扱い関数に加えることなく，
独立な~codeでそれが可能になる。
◎
Multiple listeners. Instead of a single message processing function, the code here attaches multiple event listeners, each one performing a quick check to see if it is relevant for the message. In this example it doesn't make much difference, but if multiple authors wanted to collaborate using a single port to communicate with a worker, it would allow for independent code instead of changes having to all be made to a single event handling function.
</p>

<p>
このような仕方で~event~listenerを登録した場合、
この例の `configure()^c ~methodのように，
事を終えた~listenerを~~個別的に未登録にすることも可能になる。
◎
Registering event listeners in this way also allows you to unregister specific listeners when you are done with them, as is done with the configure() method in this example.
</p>

<p>
最後に，~worker：
◎
Finally, the worker:
</p>

<pre class="lang-js">
var %nextName = 0;
function getNextName() {
  /* <span class="comment">
もっと親しみ易い名前にすることもできたが、
今の所は，ただの番号。
◎
this could use more friendly names but for now just return a number
</span> */
  return %nextName++;
}

var %map = [
 [0, 0, 0, 0, 0, 0, 0],
 [1, 1, 0, 1, 0, 1, 1],
 [0, 1, 0, 1, 0, 0, 0],
 [0, 1, 0, 1, 0, 1, 1],
 [0, 0, 0, 1, 0, 0, 0],
 [1, 0, 0, 1, 1, 1, 1],
 [1, 1, 0, 1, 1, 0, 1],
];

function wrapX(%x) {
  if (%x &lt; 0) return wrapX(%x + %map[0].length);
  if (%x &gt;= %map[0].length) return wrapX(%x - %map[0].length);
  return %x;
}

function wrapY(%y) {
  if (%y &lt; 0) return wrapY(%y + %map.length);
  if (%y &gt;= %map[0].length) return wrapY(%y - %map.length);
  return %y;
}

function wrap(%val, %min, %max) {
  if (%val &lt; %min)
    return %val + (%max - %min) + 1;
  if (%val &gt; %max)
    return %val - (%max - %min) - 1;
  return %val;
}

function sendMapData(%viewer) {
  var %data = '';
  for (var %y = %viewer.y - 1; y &lt;= %viewer.y + 1; %y += 1) {
    for (var %x = %viewer.x - 1; %x &lt;= %viewer.x + 1; %x += 1) {
      if (%data != '')
        %data += ',';
      %data += %map[wrap(%y, 0, %map[0].length-1)][wrap(%x, 0, %map.length-1)];
    }
  }
  %viewer.port.postMessage('map ' + %data);
}

var %viewers = {};
onconnect = function (%event) {
  var %name = getNextName();
  %event.ports[0]._data = { port: event.ports[0], name: %name, x: 0, y: 0, };
  %viewers[%name] = %event.ports[0]._data;
  %event.ports[0].postMessage('cfg ' + %name);
  %event.ports[0].onmessage = getMessage;
  sendMapData(event.ports[0]._data);
};

function getMessage(%event) {
  switch (%event.data.substr(0, 4)) {
    case 'mov ':
      var %direction = %event.data.substr(4);
      var %dx = 0;
      var %dy = 0;
      switch (%direction) {
        case 'up': %dy = -1; break;
        case 'down': %dy = 1; break;
        case 'left': %dx = -1; break;
        case 'right': %dx = 1; break;
      }
      %event.target._data.x = wrapX(%event.target._data.x + %dx);
      %event.target._data.y = wrapY(%event.target._data.y + %dy);
      sendMapData(%event.target._data);
      break;
    case 'set ':
      var %value = %event.data.substr(4);
      map[%event.target._data.y][%event.target._data.x] = %value;
      for (var %viewer in %viewers)
        sendMapData(%viewers[%viewer]);
      break;
    case 'txt ':
      var %name = %event.target._data.name;
      var %message = %event.data.substr(4);
      for (var %viewer in %viewers)
        %viewers[%viewer].port.postMessage('txt ' + %name + ' ' + %message);
      break;
    case 'msg ':
      var %party1 = %event.target._data;
      var %party2 = %viewers[%event.data.substr(4).split(' ', 1)[0]];
      if (%party2) {
        var %channel = new MessageChannel();
        %party1.port.postMessage('msg ' + %party2.name, [%channel.port1]);
        %party2.port.postMessage('msg ' + %party1.name, [%channel.port2]);
      }
      break;
  }
}</pre>

<p>
<strong>複数の~pageへの接続-法</strong>：
この~scriptは、
複数の接続を~listenするために，
`onconnect$m ~event~listenerを利用している。
◎
Connecting to multiple pages. The script uses the onconnect event listener to listen for multiple connections.
</p>

<p>
<strong>直通~channel</strong>：
~workerが，
一方の~viewerから他方の~viewerを~~指名する `msg^l ~messageを受信したときには、
両者の間に直な接続が設定しておかれる
— ~workerがすべての~messageを代理しなくとも、
両~viewerは直に通信できる。
◎
Direct channels. When the worker receives a "msg" message from one viewer naming another viewer, it sets up a direct connection between the two, so that the two viewers can communicate directly without the worker having to proxy all the messages.
</p>

<p>
`この例を~onlineで見る＠~DEMO/multiviewer/page.html$
◎
View this example online.
</p>

				</section>
				<section id="delegation">
<h5 title="Delegation">10.1.2.5. 委任</h5>

◎非規範的

<p>
複-~core~CPUの普及に伴い、
計算量の大きな仕事を複数の~workerに分業させて，
より良い処理能が得されるようになっている。
この例では、
1 〜 10,000,000 に付番された計算量の大きな仕事を 10 等分して，
10 個の下位workerに遂行させる。
◎
With multicore CPUs becoming prevalent, one way to obtain better performance is to split computationally expensive tasks amongst multiple workers. In this example, a computationally expensive task that is to be performed for every number from 1 to 10,000,000 is farmed out to ten subworkers.
</p>

<p>
~main~pageは、
単に結果を報告する：
◎
The main page is as follows, it just reports the result:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;~worker例： 複-~coreによる~~計算&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;Result: &lt;output id="result"&gt;&lt;/output&gt;&lt;/p&gt;

&lt;script&gt;
   var %worker = new Worker('worker.js');
   %worker.onmessage = function (%event) {
     document.getElementById('result').textContent = %event.data;
   };
&lt;/script&gt;

 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
~worker自身は：
◎
The worker itself is as follows:
</p>

<pre class="lang-js">
/* <span class="comment">
設定
◎
settings
</span> */
var %num_workers = 10;
var %items_per_worker = 1000000;

/* <span class="comment">
~workerを開始する
◎
start the workers
</span> */
var %result = 0;
var %pending_workers = %num_workers;
for (var %i = 0; %i &lt; %num_workers; %i += 1) {
  var %worker = new Worker('core.js');
  %worker.postMessage(%i * %items_per_worker);
  %worker.postMessage((%i+1) * %items_per_worker);
  %worker.onmessage = storeResult;
}

/* <span class="comment">
結果を取扱う
◎
handle the results
</span> */
function storeResult(%event) {
  %result += 1*%event.data;
  %pending_workers -= 1;
  if (%pending_workers &lt;= 0)
    postMessage(%result); /* <span class="comment">
完成！
◎
finished!
</span> */
}
</pre>

<p>
それは、
一連の下位workerを開始させる~loopと,
各 下位workerから返される応答を待機する~handlerからなる。
◎
It consists of a loop to start the subworkers, and then a handler that waits for all the subworkers to respond.
</p>

<p>
下位workerの実装は：
◎
The subworkers are implemented as follows:
</p>

<pre class="lang-js">
var %start;
onmessage = getStart;
function getStart(%event) {
  %start = 1*%event.data;
  onmessage = getEnd;
}

var %end;
function getEnd(%event) {
  %end = 1*%event.data;
  onmessage = null;
  work();
}

function work() {
  var %result = 0;
  for (var %i = %start; i &lt; %end; %i += 1) {
    /* <span class="comment">
何か複階的な計算がここで遂行される
◎
perform some complex calculation here
</span> */
    %result += 1;
  }
  postMessage(%result);
  close();
}
</pre>

<p>
これらはそれぞれ、
2 度の~eventで 2 個の番号を受信して,
それにより指定される付番~範囲の~~計算を遂行して,
結果を親に報告する。
◎
They receive two numbers in two events, perform the computation for the range of numbers thus specified, and then report the result back to the parent.
</p>

<p>
`この例を~onlineで見る＠~DEMO/multicore/page.html$
◎
View this example online.
</p>

				</section>
				<section id="providing-libraries">
<h5 title="Providing libraries">10.1.2.6. ~libraryを供するとき</h5>

◎非規範的

<p>
次の 3 種の~taskを供する，ある暗号化~libraryが可用であるとする：
◎
Suppose that a cryptography library is made available that provides three tasks:
</p>

<dl>
	<dt>
( 公開鍵, 私用鍵 ) ~pairを生成する：
◎
Generate a public/private key pair
</dt>

	<dd>
渡された~portに， 2 個の~message
— 最初に公開鍵，次に私用鍵 —
を送信する。
◎
Takes a port, on which it will send two messages, first the public key and then the private key.
</dd>

	<dt>
所与の ( 平文, 公開鍵 ) から，対応する暗号文を返す：
◎
Given a plaintext and a public key, return the corresponding ciphertext
</dt>
	<dd>
渡された~portに，任意個数の~message
— 最初に公開鍵，以降は平文 —
を送信する。
各 平文は、
暗号化されてから暗号文と同じ~channelに送信される。
内容を暗号化し終えたなら，~portを~closeできる。
◎
Takes a port, to which any number of messages can be sent, the first giving the public key, and the remainder giving the plaintext, each of which is encrypted and then sent on that same channel as the ciphertext. The user can close the port when it is done encrypting content.
</dd>

	<dt>
所与の ( 暗号文, 私用鍵 ) 対応する平文を返す
◎
Given a ciphertext and a private key, return the corresponding plaintext
</dt>
	<dd>
渡された~portに，任意個数の~message
— 最初に私用鍵，以降は暗号文 —
を送信する。
各 暗号文は、
復号化されてから平文と同じ~channelに送信される。
内容を復号化し終えたなら，~portを~closeできる。
◎
Takes a port, to which any number of messages can be sent, the first giving the private key, and the remainder giving the ciphertext, each of which is decrypted and then sent on that same channel as the plaintext. The user can close the port when it is done decrypting content.
</dd>
</dl>

<p>
~library自身は：
◎
The library itself is as follows:
</p>

<pre class="lang-js">
function handleMessage(%e) {
  if (%e.data == "genkeys")
    genkeys(%e.ports[0]);
  else if (%e.data == "encrypt")
    encrypt(%e.ports[0]);
  else if (%e.data == "decrypt")
    decrypt(%e.ports[0]);
}

function genkeys(%p) {
  var %keys = _generateKeyPair();
  %p.postMessage(%keys[0]);
  %p.postMessage(%keys[1]);
}

function encrypt(%p) {
  var %key, %state = 0;
  %p.onmessage = function (%e) {
    if (%state == 0) {
      %key = %e.data;
      %state = 1;
    } else {
      %p.postMessage(_encrypt(%key, %e.data));
    }
  };
}

function decrypt(%p) {
  var %key, %state = 0;
  %p.onmessage = function (%e) {
    if (%state == 0) {
      %key = %e.data;
      %state = 1;
    } else {
      %p.postMessage(_decrypt(%key, %e.data));
    }
  };
}

/* <span class="comment">
共用~worker, 専用~workerどちらとして利用されていても，~supportする
◎
support being used as a shared worker as well as a dedicated worker
</span> */
if ('onmessage' in this) /* <span class="comment">専用~worker</span> */
  onmessage = handleMessage;
else /* <span class="comment">共用~worker</span> */
  onconnect = function (%e) { %e.port.onmessage = handleMessage; }

/* <span class="comment">
“暗号” 関数：
◎
the "crypto" functions:
</span> */

function _generateKeyPair() {
  return [Math.random(), Math.random()];
}

function _encrypt(%k, %s) {
  return 'encrypted-' + %k + ' ' + %s;
}

function _decrypt(%k, %s) {
  return %s.substr(%s.indexOf(' ')+1);
}
</pre>

<p>
ここでの暗号~関数は、
単なる~stubであり，本当の暗号化は行わないことに注意。
◎
Note that the crypto functions here are just stubs and don't do real cryptography.
</p>

<p>
この~libraryは、
次のようにも利用できる：
◎
This library could be used as follows:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Worker example: Crypto library&lt;/title&gt;
  &lt;script&gt;
   const cryptoLib = new Worker('libcrypto-v1.js'); /* <span class="comment">
あるいは 'libcrypto-v2.js' も利用できる
◎
or could use 'libcrypto-v2.js'
</span> */
   function startConversation(%source, %message) {
     const %messageChannel = new MessageChannel();
     %source.postMessage(%message, [%messageChannel.port2]);
     return %messageChannel.port1;
   }
   function getKeys() {
     let %state = 0;
     startConversation(cryptoLib, "genkeys").onmessage = function (%e) {
       if (%state === 0)
         document.getElementById('public').value = %e.data;
       else if (%state === 1)
         document.getElementById('private').value = %e.data;
       %state += 1;
     };
   }
   function enc() {
     const %port = startConversation(%cryptoLib, "encrypt");
     %port.postMessage(document.getElementById('public').value);
     %port.postMessage(document.getElementById('input').value);
     %port.onmessage = function (%e) {
       document.getElementById('input').value = %e.data;
       %port.close();
     };
   }
   function dec() {
     const %port = startConversation(%cryptoLib, "decrypt");
     %port.postMessage(document.getElementById('private').value);
     %port.postMessage(document.getElementById('input').value);
     %port.onmessage = function (%e) {
       document.getElementById('input').value = %e.data;
       %port.close();
     };
   }
  &lt;/script&gt;
  &lt;style&gt;
   textarea { display: block; }
  &lt;/style&gt;
 &lt;/head&gt;
 &lt;body onload="getKeys()"&gt;
  &lt;fieldset&gt;
   &lt;legend&gt;Keys&lt;/legend&gt;
   &lt;p&gt;&lt;label&gt;Public Key: &lt;textarea id="public"&gt;&lt;/textarea&gt;&lt;/label&gt;&lt;/p&gt;
   &lt;p&gt;&lt;label&gt;Private Key: &lt;textarea id="private"&gt;&lt;/textarea&gt;&lt;/label&gt;&lt;/p&gt;
  &lt;/fieldset&gt;
  &lt;p&gt;&lt;label&gt;Input: &lt;textarea id="input"&gt;&lt;/textarea&gt;&lt;/label&gt;&lt;/p&gt;
  &lt;p&gt;&lt;button onclick="enc()"&gt;Encrypt&lt;/button&gt; &lt;button onclick="dec()"&gt;Decrypt&lt;/button&gt;&lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
この~APIの後の~versionでは、
すべての暗号~作業を下位workerに負荷委譲するよう求まれるかもしれない。
これは、
次のように行うこともできる：
◎
A later version of the API, though, might want to offload all the crypto work onto subworkers. This could be done as follows:
</p>

<pre class="lang-js">
function handleMessage(%e) {
  if (%e.data == "genkeys")
    genkeys(%e.ports[0]);
  else if (%e.data == "encrypt")
    encrypt(%e.ports[0]);
  else if (%e.data == "decrypt")
    decrypt(%e.ports[0]);
}

function genkeys(%p) {
  var generator = new Worker('libcrypto-v2-generator.js');
  generator.postMessage('', [%p]);
}

function encrypt(%p) {
  %p.onmessage = function (%e) {
    var %key = %e.data;
    var encryptor = new Worker('libcrypto-v2-encryptor.js');
    encryptor.postMessage(%key, [%p]);
  };
}

function encrypt(%p) {
  %p.onmessage = function (%e) {
    var %key = %e.data;
    var decryptor = new Worker('libcrypto-v2-decryptor.js');
    decryptor.postMessage(%key, [%p]);
  };
}

/* <span class="comment">
共用~worker, 専用~workerどちらとして利用されていても，~supportする
◎
support being used as a shared worker as well as a dedicated worker
</span> */
if ('onmessage' in this) /* <span class="comment">
専用~worker
◎
dedicated worker
</span> */
  onmessage = handleMessage;
else /* <span class="comment">
共用~worker
◎
shared worker
</span> */
  onconnect = function (%e) { %e.ports[0].onmessage = handleMessage };
</pre>

<p>
小分けにされた下位workerは：
◎
The little subworkers would then be as follows.
</p>

<p>
鍵~pairの生成-用：
◎
For generating key pairs:
</p>

<pre class="lang-js">
onmessage = function (%e) {
  var %k = _generateKeyPair();
  %e.ports[0].postMessage(%k[0]);
  %e.ports[0].postMessage(%k[1]);
  close();
}

function _generateKeyPair() {
  return [Math.random(), Math.random()];
}
</pre>

<p>
暗号化-用：
◎
For encrypting:
</p>

  
<pre class="lang-js">
onmessage = function (%e) {
  var %key = %e.data;
  %e.ports[0].onmessage = function (%e) {
    var %s = %e.data;
    postMessage(_encrypt(%key, %s));
  }
}

function _encrypt(%k, %s) {
  return 'encrypted-' + %k + ' ' + %s;
}
</pre>

<p>
復号化-用：
◎
For decrypting:
</p>

<pre class="lang-js">
onmessage = function (%e) {
  var %key = %e.data;
  %e.ports[0].onmessage = function (%e) {
    var %s = %e.data;
    postMessage(_decrypt(%key, %s));
  }
}

function _decrypt(%k, %s) {
  return %s.substr(%s.indexOf(' ')+1);
}
</pre>

<p>
~APIは変更されてないので、
~APIの利用者は，これが起きていることを知る必要すらない。
~libraryは、
~message~channelを利用して~dataを受容しているが，
自身の~APIを変更することなく下位workerに委任できる。
◎
Notice how the users of the API don't have to even know that this is happening — the API hasn't changed; the library can delegate to subworkers without changing its API, even though it is accepting data using message channels.
</p>

<p>
`この例を~onlineで見る＠~DEMO/crypto/page.html$
。
◎
View this example online.
</p>

				</section>
			</section>
			<section id="tutorials">
<h4 title="Tutorials">10.1.3. ~tutorial</h4>

				<section id="creating-a-dedicated-worker">
<h5 title="Creating a dedicated worker">10.1.3.1. 専用~workerの作成-法</h5>

◎非規範的

<p>
~workerを作成するためには~JS~fileの~URLを要する。
その~fileの~URLのみを引数として `new Worker()$m 構築子を呼出せば、
~workerが作成されて返される：
◎
Creating a worker requires a URL to a JavaScript file. The Worker() constructor is invoked with the URL to that file as its only argument; a worker is then created and returned:
</p>

<pre class="lang-js">
var %worker = new Worker('helper.js');
</pre>

<p>
`古典~script$でなく`~module~script$として解釈させたいときは、
記し方を少し違える必要がある：
◎
If you want your worker script to be interpreted as a module script instead of the default classic script, you need to use a slightly different signature:
</p>

<pre class="lang-js">
var %worker = new Worker('helper.mjs', { type: "module" });
</pre>

				</section>
				<section id="communicating-with-a-dedicated-worker">
<h5 title="Communicating with a dedicated worker">10.1.3.2. 専用~workerとの通信-法</h5>

◎非規範的

<p>
専用~workerは暗黙的に `MessagePort$I ~objを利用する。
したがって、［
有構造~dataの送信-法, ~binary~dataの転送-法, 他の~portへの転送-法
］など，
`MessagePort$I と同じ特能を~supportする。
◎
Dedicated workers use MessagePort objects behind the scenes, and thus support all the same features, such as sending structured data, transferring binary data, and transferring other ports.
</p>

<p>
専用~workerから~messageを受信するためには、
`Worker$I ~objの `onmessage$m `~event~handler~IDL属性$を利用する：
◎
To receive messages from a dedicated worker, use the onmessage event handler IDL attribute on the Worker object:
</p>

<pre class="lang-js">
%worker.onmessage = function (%event) { ... };
</pre>

<p>
`addEventListener()$m
~methodも利用できる。
◎
You can also use the addEventListener() method.
</p>

<p class="note">注記：
専用~workerに利用される暗黙的な `MessagePort$I には、
その作成-時に`~port~message~queue$が暗黙的に備わり，可能化される。
したがって、
`Worker$I ~interfaceには，
`MessagePort$I ~interfaceの `start()$m ~methodに等価なものはない。
◎
The implicit MessagePort used by dedicated workers has its port message queue implicitly enabled when it is created, so there is no equivalent to the MessagePort interface's start() method on the Worker interface.
</p>

<p>
~dataを~workerへ送信するためには、
`postMessage()$mW ~methodを利用する。
有構造~dataもこの通信~channelを通して送信できる。
（何個かの） `ArrayBuffer$I ~objを効率的に送信する（~cloneせずに転送する）ためには、
それらを配列にして 2 個目の引数に渡す。
◎
To send data to a worker, use the postMessage() method. Structured data can be sent over this communication channel. To send ArrayBuffer objects efficiently (by transferring them rather than cloning them), list them in an array in the second argument.
</p>

<pre class="lang-js">
%worker.postMessage({
  operation: 'find-edges',
  input: %buffer, /* <span class="comment">
`ArrayBuffer^I ~obj
◎
an ArrayBuffer object
</span> */
  threshold: 0.6,
}, [%buffer]);
</pre>

<p>
~workerの内側で~messageを受信するときは、
`onmessage$m `~event~handler~IDL属性$を利用する。
◎
To receive a message inside the worker, the onmessage event handler IDL attribute is used.
</p>

<pre class="lang-js">
onmessage = function (%event) { ... };
</pre>

<p>
ここでもまた `addEventListener()$m ~methodを利用できる。
◎
You can again also use the addEventListener() method.
</p>

<p>
いずれの場合も，~dataは~event~objの `data$m 属性に供される。
◎
In either case, the data is provided in the event object's data attribute.
</p>

<p>
~messageの返信-時にも， `postMessage()$m を利用する。
有構造~dataも同じように~supportされる。
◎
To send messages back, you again use postMessage(). It supports the structured data in the same manner.
</p>

<pre class="lang-js">
postMessage(%event.data.input, [%event.data.input]); /* <span class="comment">
~bufferを返送
◎
transfer the buffer back
</span> */
</pre>

				</section>
				<section id="shared-workers">
<h5 title="Shared workers">10.1.3.3. 共用~worker</h5>

◎非規範的

<p>
共用~workerは、
その作成-時に利用した~scriptの~URLにより識別され，
名前（省略可能）も明示的に付与できる。
名前があれば、
特定0の共用~workerに対し複数の~instanceを開始することも可能になる。
◎
Shared workers are identified by the URL of the script used to create it, optionally with an explicit name. The name allows multiple instances of a particular shared worker to be started.
</p>

<p>
共用~workerは，生成元の~scopeに属する（生成元ごとに分別される）。
互いに異なる~siteが同じ名前のものを利用したとしても，衝突することはない。
しかしながら、
同じ~site内の 2 つの~pageで，
同じ共用~worker名に異なる~script~URLを伴わせて利用した場合、
失敗することになる。
◎
Shared workers are scoped by origin. Two different sites using the same names will not collide. However, if a page tries to use the same shared worker name as another page on the same site, but with a different script URL, it will fail.
</p>

<p>
共用~workerの作成には、
`new SharedWorker()$m 構築子を利用する。
この構築子は、
最初の 2 個の引数に［
利用する~scriptの~URL,  ~workerの名前（省略可能）
］をとる。
◎
Creating shared workers is done using the SharedWorker() constructor. This constructor takes the URL to the script to use for its first argument, and the name of the worker, if any, as the second argument.
</p>

<pre class="lang-js">
var %worker = new SharedWorker('service.js');
</pre>

<p>
共用~workerと通信するときは、
明示的な `MessagePort$I ~objを通して行う。
`new SharedWorker()$m 構築子から返される~objは、
その~portへの参照を `port$mW 属性に保持する。
◎
Communicating with shared workers is done with explicit MessagePort objects. The object returned by the SharedWorker() constructor holds a reference to the port on its port attribute.
</p>

<pre class="lang-js">
%worker.port.onmessage = function (%event) { ... };
%worker.port.postMessage('some message');
%worker.port.postMessage({
   foo: 'structured',
   bar: ['data', 'also', 'possible']
});
</pre>

<p>
共用~workerの内側では、
`connect$et ~eventを利用して，
新たな~clientからの接続が告知される。
新たな~client用の~portは、
この~event~objの `source$m 属性により与えられる。
◎
Inside the shared worker, new clients of the worker are announced using the connect event. The port for the new client is given by the event object's source attribute.
</p>

<pre class="lang-js">
onconnect = function (%event) {
  var %newPort = %event.source;
  /* <span class="comment">
~listenerを設定しておく
◎
set up a listener
</span> */
  %newPort.onmessage = function (%event) { ... };
  /* <span class="comment">
~portに~messageを返信する
◎
send a message back to the port
</span> */
  %newPort.postMessage('ready!'); /* <span class="comment">
もちろん、
有構造~dataも返信できる
◎
can also send structured data, of course
</span> */
};
</pre>

				</section>
			</section>
		</section>
		<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

◎表記記号

		</section>
		<section id="infrastructure-2">
<h3 title="Infrastructure">10.2. 基盤</h3>

<p>
この仕様は、
2 種類の~worker
— 専用~worker, 共用~worker —
を定義する。
専用~workerは，作成-時にその作成元へ~linkされるが、
~message~portを利用することで，
他の閲覧~文脈や~workerへも通信できる。
一方で、
共用~workerには，名前があり、
その作成-後に それへの参照を得しておけば，
同じ`生成元$上で走っているどの~scriptとも通信できる。
`Service Workers^cite は、
また別の種類の~workerを定義する。
`SW$r
◎
This standard defines two kinds of workers: dedicated workers, and shared workers. Dedicated workers, once created, are linked to their creator, but message ports can be used to communicate from a dedicated worker to multiple other browsing contexts or workers. Shared workers, on the other hand, are named, and once created any script running in the same origin can obtain a reference to that worker and communicate with it. Service Workers defines a third kind. [SW]
</p>

			<section id="the-global-scope">
<h4 title="The global scope">10.2.1. 大域~scope</h4>

<p>
大域~scopeが~workerの “内側” である。
◎
The global scope is the "inside" of a worker.
</p>

<p class="trans-note">【
すなわち、
同じ~workerが， “二つの顔”
— その内側で走っている~scriptに公開する `WorkerGlobalScope$I ~obj（大域~scope）, 
それを外側から利用する~scriptに公開する `Worker$I ~obj —
を持つ
（共用~workerの場合、
後者は，当の~workerを共有している大域~環境の個数だけ複数あり得る）。
】</p>

				<section id="the-workerglobalscope-common-interface">
<h5 title="The WorkerGlobalScope common interface">10.2.1.1. `WorkerGlobalScope^I 共通~interface</h5>

<pre class="idl">
[Exposed=Worker]
interface `WorkerGlobalScope@I : `EventTarget$I {
  readonly attribute `WorkerGlobalScope$I `self$m;
  readonly attribute `WorkerLocation$I `location$m;
  readonly attribute `WorkerNavigator$I `navigator$m;
  undefined `importScripts$m((`TrustedScriptURL$I or USVString)... %urls);

  attribute `OnErrorEventHandler$I `onerror$m;
  attribute `EventHandler$I `onlanguagechange$m;
  attribute `EventHandler$I `onoffline$m;
  attribute `EventHandler$I `ononline$m;
  attribute `EventHandler$I `onrejectionhandled$m;
  attribute `EventHandler$I `onunhandledrejection$m;
};
</pre>

<p>
`WorkerGlobalScope$I は、
各種~worker大域~scope~objの基底~classとして~serveする
— そのような~objの型には、
特定的に次に挙げるものが含まれる
⇒＃
`DedicatedWorkerGlobalScope$I,
`SharedWorkerGlobalScope$I,
`ServiceWorkerGlobalScope$I
◎
WorkerGlobalScope serves as the base class for specific types of worker global scope objects, including DedicatedWorkerGlobalScope, SharedWorkerGlobalScope, and ServiceWorkerGlobalScope.
</p>

<p>
各 `WorkerGlobalScope$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>
`所有者~集合@wG
◎
A WorkerGlobalScope object has an associated owner set＼
</dt>
	<dd>
［
`Document$I ／ `WorkerGlobalScope$I
］~objたちが成す`集合$
— 初期~時は空とする。
この~workerを［
作成する／得する
］ときに拡充される。
◎
(a set of Document and WorkerGlobalScope objects). It is initially empty and populated when the worker is created or obtained.
</dd>
	<dd class="note">注記：
単独の所有者ではなく`集合$にされているのは、
`SharedWorkerGlobalScope$I ~objに適応するためである。
◎
It is a set, instead of a single owner, to accommodate SharedWorkerGlobalScope objects.
</dd>

	<dt>
`種別@wG
◎
A WorkerGlobalScope object has an associated type＼
</dt>
	<dd>
作成-時に，次のいずれかに設定される
⇒＃
`classic^l ／
`module^l
◎
("classic" or "module"). It is set during creation.
</dd>

	<dt>
`~URL@wG
◎
A WorkerGlobalScope object has an associated url＼
</dt>
	<dd>
~NULL または`~URL$
— 初期~時は ~NULL とする。
◎
(null or a URL). It is initially null.
</dd>
	<dd class="trans-note">【
少なくとも，~APIから~accessされる時点までには、
~NULL 以外に設定されることになる。
】</dd>

	<dt>
`名前@wG
◎
A WorkerGlobalScope object has an associated name＼
</dt>
	<dd>
文字列
— 作成-時に設定される。
◎
(a string). It is set during creation.
</dd>
	<dd class="note">
<p>注記：
`名前$wGの意味論は、
`WorkerGlobalScope$I の下位classごとに異なり得る：
◎
The name can have different semantics for each subclass of WorkerGlobalScope.＼
</p>
		<ul>
			<li>
`DedicatedWorkerGlobalScope$I 用には、
単純に開発者が給する名前であり，ほぼ~debug目的に限り有用になる。
◎
For DedicatedWorkerGlobalScope instances, it is simply a developer-supplied name, useful mostly for debugging purposes.＼
</li>
			<li>
`SharedWorkerGlobalScope$I 用には、
共通な共用~workerへの参照を `new SharedWorker()$m 構築子を介して得することを許容する。
◎
For SharedWorkerGlobalScope instances, it allows obtaining a reference to a common shared worker via the SharedWorker() constructor.＼
</li>
			<li>
`ServiceWorkerGlobalScope$I 用には、
イミを成さない
（そのため、
~JS~APIを通して公開されることもない）。
◎
For ServiceWorkerGlobalScope objects, it doesn't make sense (and as such isn't exposed through the JavaScript API at all).
</li>
		</ul>
	</dd>

	<dt>
`施策~容器@wG
◎
A WorkerGlobalScope object has an associated policy container＼
</dt>
	<dd>
`施策~容器$
— 初期~時は新たな`施策~容器$とする。
◎
(a policy container). It is initially a new policy container.
</dd>

	<dt>
`埋込元~施策@wG
◎
A WorkerGlobalScope object has an associated embedder policy＼
</dt>
	<dd>
`埋込元~施策$
◎
(an embedder policy).
</dd>

	<dt>
`~module~map@wG
◎
A WorkerGlobalScope object has an associated module map.＼
</dt>
	<dd>
`~module~map$
— 初期~時は空とする。
◎
It is a module map, initially empty.
</dd>

	<dt>
`非同一-生成元~能力は隔離されるか@wG
◎
A WorkerGlobalScope object has an associated cross-origin isolated capability＼
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
boolean. It is initially false.
</dd>
</dl>

<dl class="domintro">
	<dt>%workerGlobal.`self$m</dt>
	<dd>
%workerGlobal 自身を返す。
◎
Returns workerGlobal.
</dd>

	<dt>%workerGlobal.`location$m</dt>
	<dd>
%workerGlobal の `WorkerLocation$I ~objを返す。
◎
Returns workerGlobal's WorkerLocation object.
</dd>

	<dt>%workerGlobal.`navigator$m</dt>
	<dd>
%workerGlobal の `WorkerNavigator$I ~objを返す。
◎
Returns workerGlobal's WorkerNavigator object.
</dd>

	<dt>%workerGlobal.`importScripts(...urls【！urls...】)$m</dt>
	<dd>
%urls を成す各~URLを
— 渡された順に一つずつ —
~fetchして, 実行して, 結果を返す
（あるいは、
どこかで不具合があれば例外を投出する）。
◎
Fetches each URL in urls, executes them one-by-one in the order they are passed, and then returns (or throws if something went amiss).
</dd>
</dl>

<div class="algo">
`self@m
取得子~手続きは
⇒
~RET コレ
◎
The self attribute must return the WorkerGlobalScope object itself.
</div>

<div class="algo">
<p>
`location@m
取得子~手続きは
</p>
<ol>
	<li>
~Assert：
コレの`~worker所在~obj$ ~NEQ ε
</li>
	<li>
~RET コレの`~worker所在~obj$
</li>
</ol>

<p class="note">注記：
`WorkerLocation$I ~objが作成されるのは，
`WorkerGlobalScope$I ~objより後になるが、
それは~scriptからは観測し得ないので，問題にはならない。
</p>
◎
The location attribute must return the WorkerLocation object whose associated WorkerGlobalScope object is the WorkerGlobalScope object.
◎
While the WorkerLocation object is created after the WorkerGlobalScope object, this is not problematic as it cannot be observed from script.
</div>

<hr>

<p>
`WorkerGlobalScope$I ~interfaceを実装する~objにおいては、
次に挙げる`~event~handler$（および，それらに対応する`~event~handler~event型$）を`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the WorkerGlobalScope interface:
</p>

<table><thead>
<tr><th>~event~handler
<th>~event~handler~event型
<tbody>

<tr><td>`onerror@m
<td>`error$et

<tr><td>`onlanguagechange@m
<td>`languagechange$et

<tr><td>`onoffline@m
<td>`offline$et

<tr><td>`ononline@m
<td>`online$et

<tr><td>`onrejectionhandled@m
<td>`rejectionhandled$et

<tr><td>`onunhandledrejection@m
<td>`unhandledrejection$et
</table>

				</section>
				<section id="dedicated-workers-and-the-dedicatedworkerglobalscope-interface">
<h5 title="Dedicated workers and the DedicatedWorkerGlobalScope interface">10.2.1.2. 専用~workerと `DedicatedWorkerGlobalScope^I ~interface</h5>

<pre class="idl">
[Global=(Worker,DedicatedWorker),Exposed=DedicatedWorker]
interface `DedicatedWorkerGlobalScope@I : `WorkerGlobalScope$I {
  [Replaceable] readonly attribute DOMString `name$m;

  undefined `postMessage$m(any %message, sequence&lt;`object$&gt; %transfer);
  undefined `~postMessageO$m(any %message, optional `StructuredSerializeOptions$I %options = {});
  undefined `close$m();

  `DedicatedWorkerGlobalScope$I includes `MessageEventTarget$I;
};
</pre>

<p>
各 `DedicatedWorkerGlobalScope$I ~objには、
`内側~port@
が結付けられる
— それは：
◎
DedicatedWorkerGlobalScope objects have an associated inside port＼
</p>
<ul>
	<li>
`MessagePort$I ~objである。
◎
(a MessagePort).＼
</li>
	<li>
当の~worker作成-時に設定しておかれる~channelの一部を成すが，公開されない。
◎
This port is part of a channel that is set up when the worker is created, but it is not exposed.＼
</li>
	<li>
当の `DedicatedWorkerGlobalScope$I ~objより先に~garbage収集されてはならない。
◎
This object must never be garbage collected before the DedicatedWorkerGlobalScope object.
</li>
</ul>

<dl class="domintro">
	<dt>%dedicatedWorkerGlobal.`name$m
	<dd>
%dedicatedWorkerGlobal の`名前$wG
— すなわち， `new Worker()$m 構築子に与えた値 —
を返す。
主に、
~debug時に有用になる。
◎
Returns dedicatedWorkerGlobal's name, i.e. the value given to the Worker constructor. Primarily useful for debugging.
</dd>

	<dt>%dedicatedWorkerGlobal.`postMessage(message, transfer【！[, transfer]】)$m</dt>
	<dt>%dedicatedWorkerGlobal.`~postMessageO(message [, options ])$m</dt>
	<dd>
~messageを~cloneして，それを
%dedicatedWorkerGlobal に結付けられた `Worker$I ~objへ伝送する。
［
%transfer ／ ［
%options の `transfer$m ~member
］］に、
~cloneせずに転送する~objの~listを渡せる。
◎
Clones message and transmits it to the Worker object associated with dedicatedWorkerGlobal. transfer can be passed as a list of objects that are to be transferred rather than cloned.
</dd>

	<dt>%dedicatedWorkerGlobal.`close()$m</dt>
	<dd>
%dedicatedWorkerGlobal を中止する。
◎
Aborts dedicatedWorkerGlobal.
</dd>
</dl>

<div class="algo">
<p>
`name@m
取得子~手続きは
⇒
~RET コレの`名前$wG
◎
The name getter steps are to return this's name.＼
</p>

<p>
返される値は、
`new Worker$m 構築子を利用して~workerに与えた名前を表現する
— これは首に、
~debug目的に利用される。
◎
Its value represents the name given to the worker using the Worker constructor, used primarily for debugging purposes.
</p>
</div>

<div class="algo">
<p>
`postMessage(message, transfer)@m
~method手続きは
⇒
~RET コレの`内側~port$【！the port】上の
`postMessage$mMP ~method手続き( %message, %transfer )
</p>

<p>
`~postMessageO(message, options)@m
~method手続きは
⇒
~RET コレの`内側~port$【！the port】上の
`~postMessageO$mMP ~method手続き( %message, %options )
</p>
◎
The postMessage(message, transfer) and postMessage(message, options) methods on DedicatedWorkerGlobalScope objects act as if, when invoked, it immediately invoked the respective postMessage(message, transfer) and postMessage(message, options) on the port, with the same arguments, and returned the same return value.
</div>

<div class="algo">
<p>
`~workerを~closeする@
ときは、
所与の
%~worker大域~scope
に対し，次の手続きを走らす：
◎
To close a worker, given a workerGlobal, run these steps:
</p>
<ol>
	<li>
%~worker大域~scope に`関連な~agent$の`~event~loop$aGの`~task~queue$に追加された`~task$は、
すべて破棄する
◎
Discard any tasks that have been added to workerGlobal's relevant agent's event loop's task queues.
</li>
	<li>
%~worker大域~scope の`~close中か$wG ~SET ~T
（これにより、
~taskがそれ以上~queueされることはなくなる。）
◎
Set workerGlobal's closing flag to true. (This prevents any further tasks from being queued.)
</li>
</ol>
</div>

<div class="algo">
`close()@m
~method手続きは
⇒
`~workerを~closeする$( コレ )
◎
The close() method steps are to close a worker given this.
</div>

				</section>
				<section id="shared-workers-and-the-sharedworkerglobalscope-interface">
<h5 title="Shared workers and the SharedWorkerGlobalScope interface">10.2.1.3. 共用~workerと `SharedWorkerGlobalScope^I ~interface</h5>

<pre class="idl">
[Global=(Worker,SharedWorker),Exposed=SharedWorker]
interface `SharedWorkerGlobalScope@I : `WorkerGlobalScope$I {
  [Replaceable] readonly attribute DOMString `~nameS$m;

  undefined `~closeS$m();

  attribute `EventHandler$I `onconnect$m;
};
</pre>

<p>
各 `SharedWorkerGlobalScope$I ~objには、
次に挙げるものが結付けられ，
当の~objの作成-時に`~workerを走らす$~algoにて初期化される
⇒＃
`構築子~生成元@wG,
`構築子~URL@wG,
`資格証@wG,
◎
A SharedWorkerGlobalScope object has an associated constructor origin, constructor url, and credentials. They are initialized when the SharedWorkerGlobalScope object is created, in the run a worker algorithm.
</p>

<p>
共用~workerは、
その `SharedWorkerGlobalScope$I ~obj上の `connect$et ~eventを通して，各~接続の~message~portを受信する。
◎
Shared workers receive message ports through connect events on their SharedWorkerGlobalScope object for each connection.
</p>

<dl class="domintro">
	<dt>%sharedWorkerGlobal.`~nameS$m</dt>
	<dd>
%sharedWorkerGlobal の`名前$wG
— すなわち， `new SharedWorker()$m 構築子に与えた値 —
を返す。
同じ名前を再利用すれば、
同じ共用~worker（および `SharedWorkerGlobalScope$I ）に複数の `SharedWorker$I ~objを対応させれる。
◎
Returns sharedWorkerGlobal's name, i.e. the value given to the SharedWorker constructor. Multiple SharedWorker objects can correspond to the same shared worker (and SharedWorkerGlobalScope), by reusing the same name.
</dd>

	<dt>%sharedWorkerGlobal.`~closeS()$m</dt>
	<dd>
%sharedWorkerGlobal を中止する。
◎
Aborts sharedWorkerGlobal.
</dd>
</dl>

<div class="algo">
<p>
`~nameS@m
取得子~手続きは
⇒
~RET コレの`名前$wG
◎
The name getter steps are to return this's name.＼
</p>

<p>
返される値は、
`new SharedWorker()$m 構築子を利用して~workerへの参照を得するときに利用できる名前を表現する。
◎
Its value represents the name that can be used to obtain a reference to the worker using the SharedWorker constructor.
</p>
</div>

<div class="algo">
`~closeS()@m
~method手続きは
⇒
`~workerを~closeする$( コレ )
◎
The close() method steps are to close a worker given this.
</div>

<hr>

<p>
`SharedWorkerGlobalScope$I ~interfaceを実装する~objにおいては、
次に挙げる`~event~handler$（および，それらに対応する`~event~handler~event型$）を`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the SharedWorkerGlobalScope interface:
</p>

<table><thead>
<tr><th>~event~handler
<th>~event~handler~event型
<tbody>

<tr><td>`onconnect@m
<td>`connect$et
</table>

				</section>
			</section>

			<section id="worker-event-loop">
<h4 title="The event loop">10.2.2. ~event~loop</h4>

<p>
`~worker~event~loop$の`~task~queue$内にあり得る`~task$は、［
~event, ~callback, ~networking活動
］に限られる。
これらの`~worker~event~loop$は、
`~workerを走らす$~algoにより作成される。
◎
A worker event loop's task queues only have events, callbacks, and networking activity as tasks. These worker event loops are created by the run a worker algorithm.
</p>

<p>
各 `WorkerGlobalScope$I ~objは、
真偽値をとる
`~close中か@wG
を有する：
◎
Each WorkerGlobalScope object has a closing flag,＼
</p>

<ul>
	<li>
初期~時には ~F になるモノトスル。
下の処理~model節の~algoにより， ~T にされ得る。
◎
which must be initially false, but which can get set to true by the algorithms in the processing model section below.
</li>
	<li>
~T にされたときは、
`~event~loop$の`~task~queue$に追加される それ以降の`~task$は，破棄するモノトスル
（~queue内にすでにある~taskは、
特に指定されない限り，影響されない）。
実質的には、
~T になったら，~timerは発火を止め, 処理待ちにあるすべての~background演算の通知は取り除かれる, 等々が行われることになる。
◎
Once the WorkerGlobalScope's closing flag is set to true, the event loop's task queues must discard any further tasks that would be added to them (tasks already on the queue are unaffected except where otherwise specified). Effectively, once the closing flag is true, timers stop firing, notifications for all pending background operations are dropped, etc.
</li>
</ul>

			</section>
			<section id="the-worker's-lifetime">
<h4 title="The worker's lifetime">10.2.3. ~workerの存続期間</h4>

<p>
~workerは、
`~message~channel$とそれらの
`MessagePort$I ~objを通して，他の~workerや`~window$と通信する。
◎
Workers communicate with other workers and with Windows through message channels and their MessagePort objects.
</p>

<p>
各 `WorkerGlobalScope$I ~obj %G は、
`~port~list@wG
を有する
— それは：
◎
Each WorkerGlobalScope object worker global scope has a list of the worker's ports,＼
<ul>
	<li>
<p>
次を満たす `MessagePort$I ~obj %P すべてからなる
⇒
［
%P は別の `MessagePort$I ~obj %Q と`連絡-$されている
］~AND［
%G は %P, %Q のうち %P のみを所有している†
］
◎
which consists of all the MessagePort objects that are entangled with another port and that have one (but only one) port owned by worker global scope.＼
</p>

<p class="trans-note">【†
おそらく，［
%P に`関連な大域~obj$ ~EQ %G ~NEQ %Q に`関連な大域~obj$
］を意味する。
】</p>
	</li>
	<li>
`専用~worker$の事例では
【すなわち， %G は `DedicatedWorkerGlobalScope$I ~objである】、
暗黙的な~port【 %G の`内側~port$】も含む。
【前~項の条件を満たす限り。】
◎
This list includes the implicit MessagePort in the case of dedicated workers.
</li>
</ul>

<p>
所与の`環境~設定群~obj$ %O の下で~workerを［
作成する／得する
］ときに
`関連な所有者として追加するもの@
は、
%O により指定される`大域~obj$enV %G に応じて，次のいずれかになる：
◎
Given an environment settings object o when creating or obtaining a worker, the relevant owner to add depends on the type of global object specified by o.＼
</p>
<ul>
	<li>
`WorkerGlobalScope$I である（すなわち，入子な専用~workerを作成している）場合
⇒
%G
◎
If o's global object is a WorkerGlobalScope object (i.e., if we are creating a nested dedicated worker), then the relevant owner is that global object.＼
</li>
	<li>
`Window$I である場合
⇒
%G に`結付けられた文書$
◎
Otherwise, o's global object is a Window object, and the relevant owner is that Window's associated Document.
</li>
</ul>

<hr>

<p>
~workerは、
その `WorkerGlobalScope$I を %G とするとき：
◎
↓</p>
<ul>
	<li>
<p>
~OR↓ を満たしている間は、
`許可-可能@
（ `permissible^en ）とされる：
◎
A worker is said to be a permissible worker if＼
</p>
		<ul>
			<li>
%G の`所有者~集合$wGは`空$でない
◎
its WorkerGlobalScope's owner set is not empty or:
</li>
			<li>
<p>
~AND↓
◎
↓</p>
				<ul>
					<li>
%G の`所有者~集合$wGは空であり続けているが、
`実装定義$な短い制限時間を過ぎていない
◎
its owner set has been empty for no more than a short implementation-defined timeout value,
</li>
					<li>
%G は `SharedWorkerGlobalScope$I ~objである（すなわち，~workerは共用~workerである）
◎
its WorkerGlobalScope object is a SharedWorkerGlobalScope object (i.e., the worker is a shared worker), and
</li>
					<li>
~UAの ある`~navigable$にて`作動中な文書$navは、
まだ`完全に読込まれ$ていない
◎
the user agent has a navigable whose active document is not completely loaded.
</li>
				</ul>

<p class="note">注記：
上の定義の 2 番目の項は、
読込まれている短い間に~pageが共用~workerに再び繋がろうとしている下でも，
共用~workerが生残れるようにする。
これを利用すれば，~UAは、
利用者が ある~siteの中で~pageから~pageへ~navigateするときに，
その~siteが利用している共用~workerを開始し直す~costを避けれるようになる。
◎
The second part of this definition allows a shared worker to survive for a short time while a page is loading, in case that page is going to contact the shared worker again. This can be used by user agents as a way to avoid the cost of restarting a shared worker used by a site when the user is navigating from page to page within that site.
</p>
			</li>
		</ul>
	</li>
	<li>
次を満たしている間は、
`作動中なため必要@
（ `active needed^en ）とされる
⇒
%G の`所有者~集合$wG内に次を満たす［
`文書$／~worker
］が在る
⇒
［
`全部的に作動中$／`作動中なため必要$
］である
◎
A worker is said to be an active needed worker if any of its owners are either Document objects that are fully active or active needed workers.
</li>
	<li>
<p>
~AND↓ を満たしている間は、
`保護され@
ている（ `protected^en ）とされる：
◎
A worker is said to be a protected worker if＼
</p>

		<ul>
			<li>
`作動中なため必要$である
◎
it is an active needed worker＼
</li>
			<li>
<p>
~OR↓：
◎
and either＼
</p>
				<ul>
					<li>
【%G 内に】待機中な~timerがある
◎
it has outstanding timers,＼
</li>
					<li>
【%G 内に】~database~transactionがある【 `INDEXEDDB$r 】
◎
database transactions, or＼
</li>
					<li>
【%G 内に】~network接続がある
◎
network connections, or＼
</li>
					<li>
%G の`~port~list$wGは空でない
◎
its list of the worker's ports is not empty, or＼
</li>
					<li>
%G は`SharedWorkerGlobalScope$I ~objである（すなわち，~workerは共用~workerである）
◎
its WorkerGlobalScope is actually a SharedWorkerGlobalScope object (i.e., the worker is a shared worker).
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
<p>
~AND↓ を満たしている間は、
`休止-可能@
（ `suspendable^en ）とされる
◎
A worker is said to be a suspendable worker if＼
</p>
		<ul>
			<li>
`作動中なため必要$ではない
◎
it is not an active needed worker＼
</li>
			<li>
`許可-可能$である
◎
but it is a permissible worker.
</li>
		</ul>
	</li>
</ul>

			</section>
			<section id="worker-processing-model">
<h4 title="Processing model">10.2.4. 処理~model</h4>

<div class="algo">
<p>
ある~script用の
`~workerを走らす@
ときは、
所与の
⇒＃
%~worker （ `Worker$I ／ `SharedWorker$I ~obj ）,
%~URL （ `~URL$ ）,
%外側~設定群 （ `環境~設定群~obj$ ）,
%外側~port （ `MessagePort$I ~obj ）,
%options （ `WorkerOptions$I 辞書 ）
◎終
に対し，次の手続きを走らすモノトスル：
◎
When a user agent is to run a worker for a script with Worker or SharedWorker object worker, URL url, environment settings object outside settings, MessagePort outside port, and a WorkerOptions dictionary options, it must run the following steps.
</p>
<ol>
	<li>
%共用か ~LET ~IS［
%~worker は `SharedWorker$I ~objである
］
◎
Let is shared be true if worker is a SharedWorker object, and false otherwise.
</li>
	<li>
%所有者 ~LET
%外側~設定群 から与えられる，`関連な所有者として追加するもの$
◎
Let owner be the relevant owner to add given outside settings.
</li>
	<li>
%安全でない~worker作成~時刻 ~LET `安全でない共有される現在の時刻$
◎
Let unsafeWorkerCreationTime be the unsafe shared current time.
</li>
	<li>
<p>
%~agent ~LET `専用／共用~worker~agentを得する$( %外側~設定群, %共用か )
◎
Let agent be the result of obtaining a dedicated/shared worker agent given outside settings and is shared.＼
</p>

<p>
この手続きの以降は， %~agent 内で走らすとする
◎
Run the rest of these steps in that agent.
</p>
	</li>
	<li>
%~realm実行~文脈 ~LET 次のように~custom化する下で，
%~agent 内で`新たな~realmを作成する$
⇒
大域~obj用には， %共用か に応じて次を作成する
⇒＃
~T ならば 新たな `SharedWorkerGlobalScope$I ~obj ／
~F ならば 新たな `DedicatedWorkerGlobalScope$I ~obj
◎
Let realm execution context be the result of creating a new realm given agent and the following customizations:
• For the global object, if is shared is true, create a new SharedWorkerGlobalScope object. Otherwise, create a new DedicatedWorkerGlobalScope object.
</li>
	<li>
<p>
%~worker大域~scope ~LET %~realm実行~文脈 の`大域~obj$rM成分
◎
Let worker global scope be the global object of realm execution context's Realm component.
</p>

<p class="note">注記：
これは、
前~段で作成した［
`SharedWorkerGlobalScope^I ／ `DedicatedWorkerGlobalScope^I
］~objになる。
◎
This is the DedicatedWorkerGlobalScope or SharedWorkerGlobalScope object created in the previous step.
</p>
	</li>
	<li>
%内側~設定群 ~LET `~workerの環境~設定群~objを設定しておく$( %~realm実行~環境, %外側~設定群, %安全でない~worker作成~時刻 )
◎
Set up a worker environment settings object with realm execution context, outside settings, and unsafeWorkerCreationTime, and let inside settings be the result.
</li>
	<li>
%~worker大域~scope の`名前$wG ~SET %options[ `name^l ]
◎
Set worker global scope's name to the value of options's name member.
</li>
	<li>
%~worker大域~scope の`所有者~集合$wGに
%所有者 を`付加する$set
◎
Append owner to worker global scope's owner set.
</li>
	<li>
~IF［
%共用か ~EQ ~T
］
⇒
%~worker大域~scope の
⇒＃
`構築子~生成元$wG ~SET %外側~設定群 の`生成元$enV,
`構築子~URL$wG ~SET %~URL,
`種別$wG ~SET %options[ `type^l ],
`資格証$wG ~SET %options[ `credentials^l ]
◎
If is shared is true, then:
• Set worker global scope's constructor origin to outside settings's origin.
• Set worker global scope's constructor url to url.
• Set worker global scope's type to the value of options's type member.
• Set worker global scope's credentials to the value of options's credentials member.
</li>
	<li>
%行先 ~LET %共用か に応じて
⇒＃
~T ならば `sharedworker^l ／
~F ならば `worker^l
◎
Let destination be "sharedworker" if is shared is true, and "worker" otherwise.
</li>
	<li>
<p>
次に従って~scriptを得する
— %options[ `type^l ] に応じて：
◎
Obtain script by switching on the value of options's type member:
</p>
		<ul class="switch">
			<li>
`classic^l
⇒
`~worker用~古典~scriptを~fetchする$( ↓ )
⇒＃
%~URL,
%外側~設定群,
%行先,
%内側~設定群,
%完了-時の手続き†,
%~fetchを遂行する†
◎
"classic"
• Fetch a classic worker script given url, outside settings, destination, inside settings, and with onComplete and performFetch as defined below.
</li>
			<li>
`module^l
⇒
`~module~worker~script~graphを~fetchする$( ↓ )
⇒＃
%~URL,
%外側~設定群,
%行先,
%options[ `credentials^l ],
%内側~設定群,
%完了-時の手続き†,
%~fetchを遂行する†
◎
"module"
• Fetch a module worker script graph given url, outside settings, destination, the value of the credentials member of options, inside settings, and with onComplete and performFetch as defined below.
</li>
		</ul>

<p>†
上で利用される［
%完了-時の手続き,
%~fetchを遂行する
］は、
以下に定義される：
◎
↑</p>

<div class="algo">
<p>
%~fetchを遂行する は，`~fetch~hookを遂行する~algo$であり、
所与の
( %要請, `~top-levelか$V, `~custom~fetch応答の処理n$V )
に対し，次を遂行する：
◎
In both cases, let performFetch be the following perform the fetch hook given request, isTopLevel and processCustomFetchResponse:
</p>
		<ol>
			<li>
<p>
~IF［
%~top-levelか ~EQ ~F
］：
</p>
				<ol>
					<li>
%要請 を`~fetchする$
— 次を与える下で
⇒
`応答の本体を消費する処理n$i ~SET %~custom~fetch応答の処理n
</li>
					<li>
~RET
</li>
				</ol>
◎
If isTopLevel is false, fetch request with processResponseConsumeBody set to processCustomFetchResponse, and abort these steps.
</li>
			<li>
%要請 の`予約-済み~client$rq ~SET %内側~設定群
◎
Set request's reserved client to inside settings.
</li>
			<li>
<p>
%要請 を`~fetchする$
— 次を与える下で：
◎
Fetch request with＼
</p>
				<ul>
					<li class="algo">
<p>
`応答の本体を消費する処理n$i ~SET 所与の
( `応答$ %応答, ［
~NULL ／ `失敗^i ／ `~byte列$
］ %本体~byte列 )
に対し，次を走らす手続き：
◎
processResponseConsumeBody set to the following steps given response response and null, failure, or a byte sequence bodyBytes:
</p>
						<ol>
							<li>
%~worker大域~scope の`~URL$wG ~SET %応答 の`~URL$rs
◎
Set worker global scope's url to response's url.
</li>
							<li>
`~worker大域~scopeの施策~容器を初期化する$( %~worker大域~scope, %応答, %内側~設定群 )
◎
Initialize worker global scope's policy container given worker global scope, response, and inside settings.
</li>
							<li>
~IF［
`大域~obj用に~CSP初期化を走らす$( %~worker大域~scope ) ~EQ `阻止される^i
`CSP$r
］
⇒
%応答 ~SET `~network~error$
◎
If the Run CSP initialization for a global object algorithm returns "Blocked" when executed upon worker global scope, set response to a network error. [CSP]
</li>
							<li>
<p>
~IF［
%~worker大域~scope の`埋込元~施策$wGの`値$embPは`非同一-生成元~隔離と互換$である
］~AND［
%共用か ~EQ ~T
］
⇒
%~agent の`~agent~cluster$の`非同一-生成元~隔離~mode$agC ~SET ［
`logical$coI ／ `concrete$coI
］
— どちらが選ばれるかは、
`実装定義$とする
◎
If worker global scope's embedder policy's value is compatible with cross-origin isolation and is shared is true, then set agent's agent cluster's cross-origin isolation mode to "logical" or "concrete". The one chosen is implementation-defined.
</p>

<p class="XXX">
これは，本当は当の~agent~clusterが作成されるとき設定されるべきだが、
この節を設計し直すことが要求される。
◎
This really ought to be set when the agent cluster is created, which requires a redesign of this section.
</p>
							</li>
							<li>
~IF［
`大域~objの埋込元~施策を検査する$( %~worker大域~scope, %外側~設定群, %応答 ) ~EQ ~F
］
⇒
%応答 ~SET `~network~error$
◎
If the result of checking a global object's embedder policy with worker global scope, outside settings, and response is false, then set response to a network error.
</li>
							<li>
~IF［
%~agent の`~agent~cluster$の`非同一-生成元~隔離~mode$agC ~EQ `concrete$coI
］
⇒
%~worker大域~scope の`非同一-生成元~能力は隔離されるか$wG ~SET ~T
◎
Set worker global scope's cross-origin isolated capability to true if agent's agent cluster's cross-origin isolation mode is "concrete".
</li>
							<li>
~IF［
%共用か ~EQ ~F
］~AND［
%所有者 の`非同一-生成元~能力は隔離されるか？$enV ~EQ ~F
］
⇒
%~worker大域~scope の`非同一-生成元~能力は隔離されるか$wG ~SET ~F
◎
If is shared is false and owner's cross-origin isolated capability is false, then set worker global scope's cross-origin isolated capability to false.
</li>
							<li>
<p>
~IF［
%共用か ~EQ ~F
］~AND［
%応答 の`~URL$rsの`~scheme$url ~EQ `data^l
］
⇒
%~worker大域~scope の`非同一-生成元~能力は隔離されるか$wG ~SET ~F
◎
If is shared is false and response's url's scheme is "data", then set worker global scope's cross-origin isolated capability to false.
</p>

<p class="note">注記：
これは、
今の所は，保守的な既定である。
~workerが一般に
— および［
`data$sc ~URL【から構築された】~worker（その所有者とは非同一-生成元になる）
］が特に —
許可~施策の文脈において，どう扱われることになるか~~解明されるまでの間の。
詳細は、
`w3c/webappsec-permissions-policy 課題 #207＠https://github.com/w3c/webappsec-permissions-policy/issues/207$
を見よ。
◎
This is a conservative default for now, while we figure out how workers in general, and data: URL workers in particular (which are cross-origin from their owner), will be treated in the context of permissions policies. See w3c/webappsec-permissions-policy issue #207 for more details.
</p>
							</li>
							<li>
%~custom~fetch応答の処理n( %応答, %本体~byte列 )
◎
Run processCustomFetchResponse with response and bodyBytes.
</li>
						</ol>
					</li>
				</ul>
			</li>
		</ol>
</div>

<div class="algo">
<p>
%完了-時の手続き は、
所与の
( %~script )
に対し：
◎
In both cases, let onComplete given script be the following steps:
</p>
		<ol>
			<li>
<p>
~IF［
%~script ~EQ ~NULL
］~OR［
%~script の`再投出-用~error$sC ~NEQ ~NULL
］：
◎
If script is null or if script's error to rethrow is non-null, then:
</p>
				<ol>
					<li>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %~worker に`関連な大域~obj$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~eventを発火する$( %~worker, `error$et )
</div>
◎
Queue a global task on the DOM manipulation task source given worker's relevant global object to fire an event named error at worker.
</li>
					<li>
%内側~設定群 用の`環境を破棄する手続き$()
◎
Run the environment discarding steps for inside settings.
</li>
					<li>
~RET
◎
Abort these steps.
</li>
				</ol>
			</li>
			<li>
%~worker を %~worker大域~scope に結付ける
◎
Associate worker with worker global scope.
</li>
			<li>
%内側~port ~LET `新たな~obj$( `MessagePort$I, %内側~設定群 の`~realm$enV )
◎
Let inside port be a new MessagePort object in inside settings's realm.
</li>
			<li>
<p>
~IF［
%共用か ~EQ ~F
］：
◎
If is shared is false, then:
</p>
				<ol>
					<li>
%内側~port の`~message~event~target$ ~SET %~worker大域~scope
◎
Set inside port's message event target to worker global scope.
</li>
					<li>
%~worker大域~scope の`内側~port$ ~SET %内側~port
◎
Set worker global scope's inside port to inside port.
</li>
				</ol>
			</li>
			<li>
`~portを連絡する$( %外側~port, %内側~port )
◎
Entangle outside port and inside port.
</li>
			<li>
%~worker大域~scope の`~worker所在~obj$ ~SET 新たな `WorkerLocation$I ~obj
◎
Create a new WorkerLocation object and associate it with worker global scope.
</li>
			<li>
<p>
~workerの監視を開始する：
◎
↓</p>
				<ul>
					<li>
<strong>孤立~workerは~close中</strong>
⇒
~workerが`保護され$なくなり次第、
`許可-可能$であり続ける間まで，
%~worker大域~scope の`~close中か$wGは ~T にする
◎
Closing orphan workers: Start monitoring the worker such that no sooner than it stops being a protected worker, and no later than it stops being a permissible worker, worker global scope's closing flag is set to true.
</li>
					<li>
<strong>~workerの休止</strong>
⇒
次が満たされるようになったときは、
満たされなくなるまで，~worker内の~scriptの実行を休止する
⇒
［
%~worker大域~scope の`~close中か$wG ~EQ ~F
］~AND［
~workerは`休止-可能$である
］
◎
Suspending workers: Start monitoring the worker, such that whenever worker global scope's closing flag is false and the worker is a suspendable worker, the user agent suspends execution of script in that worker until such time as either the closing flag switches to true or the worker stops being a suspendable worker.
</li>
				</ul>
			</li>
			<li>
%内側~設定群 の`実行は準備済みか$ ~SET ~T
◎
Set inside settings's execution ready flag.
</li>
			<li>
<div>
<p>
%~script に応じて：
</p>
				<ul class="switch">
					<li>
`古典~script$
⇒
`古典~scriptを走らす$( %~script )
</li>
					<li>
`~module~script$
⇒
`~module~scriptを走らす$( %~script )
</li>
				</ul>
◎
If script is a classic script, then run the classic script script. Otherwise, it is a module script; run the module script script.
</div>

<p class="note">注記：
通例の［
値を返す, 例外による失敗-
］に加えて，これは、
`~workerが終了され$たときも`尚早に中止され$得る。
◎
In addition to the usual possibilities of returning a value or failing due to an exception, this could be prematurely aborted by the terminate a worker algorithm defined below.
</p>
			</li>
			<li>
%外側~port の`~port~message~queue$を可能化する
◎
Enable outside port's port message queue.
</li>
			<li>
~IF［
%共用か ~EQ ~F
］
⇒
~workerの暗黙的な~port【 %内側~port 】の`~port~message~queue$を可能化する
◎
If is shared is false, enable the port message queue of the worker's implicit port.
</li>
			<li>
<p>
~ELSE
⇒
`大域~taskを~queueする$( `~DOM操作~task~source$, %~worker大域~scope, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~eventを発火する$( %~worker大域~scope, `connect$et, `MessageEvent$I )
— 次のように初期化して
⇒＃
`data$m 属性 ~SET 空~文字列,
`ports$m 属性 ~SET %内側~port のみを包含している新たな`凍結d配列$,
`source$m 属性 ~SET %内側~port
</div>
◎
If is shared is true, then queue a global task on DOM manipulation task source given worker global scope to fire an event named connect at worker global scope, using MessageEvent, with the data attribute initialized to the empty string, the ports attribute initialized to a new frozen array containing inside port, and the source attribute initialized to inside port.
</li>
			<li>
［
%~worker大域~scope に`関連な設定群~obj$を，`~sw~client$として結付けている
`ServiceWorkerContainer$I ~obj
］の`~client~message~queue$を可能化する
◎
Enable the client message queue of the ServiceWorkerContainer object whose associated service worker client is worker global scope's relevant settings object.
</li>
			<li>
<p>
［
%内側~設定群 により指定される`担当の~event~loop$enV
］を，破壊されるまで走らす
◎
Event loop: Run the responsible event loop specified by inside settings until it is destroyed.
</p>

<p class="note">注記：
`~event~loop$が走らす`~task$による，~eventの取扱いや~callbackの実行は、
`~workerが終了され$たときは，`尚早に中止され$得る。
◎
The handling of events or the execution of callbacks by tasks run by the event loop might get prematurely aborted by the terminate a worker algorithm defined below.
</p>

<p class="note">注記：
この段における~workerの処理~modelは、
`~event~loop$処理~modelに述べられるとおり，［
`~close中か$wGが ~T にされた後の，~event~loopが破壊される
］まで残り続ける。
◎
The worker processing model remains on this step until the event loop is destroyed, which happens after the closing flag is set to true, as described in the event loop processing model.
</p>

			</li>
			<li>
%~worker大域~scope の`作動中な~timer群が成す~map$を`~clearする$map
◎
Clear the worker global scope's map of active timers.
</li>
			<li>
%~worker大域~scope の`~port~list$wGを成す
~EACH( %~port )
に対し
⇒
%~port の`連絡-$を断つ
◎
Disentangle all the ports in the list of the worker's ports.
</li>
			<li>
%~worker大域~scope の`所有者~集合$wGを空にする
◎
Empty worker global scope's owner set.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
~UAが
`~workerを終了させ@
るときは、
~workerの~main~loop
— すなわち，上で定義した “`~workerを走らす$” 処理~model —
とは`並列的$に，次の手続きを走らすモノトスル：
◎
When a user agent is to terminate a worker it must run the following steps in parallel with the worker's main loop (the "run a worker" processing model defined above):
</p>
<ol>
	<li>
%~worker大域~scope ~LET 当の~workerの `WorkerGlobalScope$I ~obj
◎
↓</li>
	<li>
%~worker大域~scope の`~close中か$wG ~SET ~T
◎
Set the worker's WorkerGlobalScope object's closing flag to true.
</li>
	<li>
%~worker大域~scope に`関連な~agent$の`~event~loop$の`~task~queue$を成す
~EACH( `~task$ %~task )
に対し
⇒
%~task を処理することなく，破棄する【当の~task~queueから除去する】
◎
If there are any tasks queued in the WorkerGlobalScope object's relevant agent's event loop's task queues, discard them without processing them.
</li>
	<li>
~worker内で現在`走っている~scriptを中止する$
◎
Abort the script currently running in the worker.
</li>
	<li>
~IF［
%~worker大域~scope は `DedicatedWorkerGlobalScope$I ~objである
（すなわち，~workerは専用~workerである）
］
⇒
~workerの暗黙的な~port【 %~worker大域~scope の`内側~port$】の`~port~message~queue$を空にする
◎
If the worker's WorkerGlobalScope object is actually a DedicatedWorkerGlobalScope object (i.e. the worker is a dedicated worker), then empty the port message queue of the port that the worker's implicit port is entangled with.
</li>
</ol>
</div>

<div>
<p>
~UAは、
~AND↓ を満たす`~workerを終了させ$てもヨイ：
</p>
<ul>
	<li>
`作動中なため必要$ではない
</li>
	<li>
`~close中か$wG ~EQ ~T
</li>
	<li>
実行し続けている
</li>
</ul>
◎
User agents may invoke the terminate a worker algorithm when a worker stops being an active needed worker and the worker continues executing even after its closing flag was set to true.
</div>

			</section>
			<section id="runtime-script-errors-2">
<h4 title="Runtime script errors">10.2.5. 稼働時の~script~error</h4>

<p>
~workerの~scriptにおいて，
~catchされない稼働時の~script~errorが生じた場合、
それは［
それまでに~script~errorを取扱う間に生じたもの
］でないならば、
~UAは，次を遂行することになる
⇒
`例外を報告する$( 当の~error, 当の~workerの `WorkerGlobalScope$I ~obj )
◎
Whenever an uncaught runtime script error occurs in one of the worker's scripts, if the error did not occur while handling a previous script error, the user agent will report it for the worker's WorkerGlobalScope object.
</p>

			</section>
			<section id="creating-workers">
<h4 title="Creating workers">10.2.6. ~workerの作成-法</h4>

				<section id="the-abstractworker-mixin">
<h5 title="The AbstractWorker mixin">10.2.6.1. `AbstractWorker^I ~mixin</h5>

<pre class="idl">
interface mixin `AbstractWorker@I {
  attribute `EventHandler$I `onerror$mW;
};
</pre>

<p>
`AbstractWorker$I ~interfaceを実装する~objにおいては、
次に挙げる`~event~handler$（および，それらに対応する`~event~handler~event型$）を`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the AbstractWorker interface:
</p>

<table><thead>
<tr><th>`~event~handler$
<th>~event~handler~event型
<tbody>

<tr><td>`onerror@mW
<td>`error$et
</table>

				</section>
				<section id="script-settings-for-workers">
<h5 title="Script settings for workers">10.2.6.2. ~worker用の~script設定群</h5>

<div class="algo">
<p>
`~workerの環境~設定群~objを設定しておく@
ときは、
所与の
( `~JS実行~文脈$ %実行~文脈, `環境~設定群~obj$ %外側~設定群, 数 %安全でない~worker作成~時刻 )
に対し：
◎
To set up a worker environment settings object, given a JavaScript execution context execution context, an environment settings object outside settings, and a number unsafeWorkerCreationTime:
</p>
<ol>
	<li>
%継承した生成元 ~LET %外側~設定群 の`生成元$enV
◎
Let inherited origin be outside settings's origin.
</li>
	<li>
%realm ~LET %実行~文脈 の~Realm成分の値
◎
Let realm be the value of execution context's Realm component.
</li>
	<li>
%~worker大域~scope ~LET %realm の`大域~obj$rM
◎
Let worker global scope be realm's global object.
</li>
	<li>
<p>
%設定群~obj ~LET 新たな`環境~設定群~obj$
— その各種~algoは、
次に従って定義される：
◎
Let settings object be a new environment settings object whose algorithms are defined as follows:
</p>
		<ul>
			<li class="algo">
`~realm実行~環境$
⇒
~RET %実行~文脈
◎
The realm execution context
• Return execution context.
</li>
			<li class="algo">
`~module~map$enV
⇒
~RET %~worker大域~scope の`~module~map$wG
◎
The module map
• Return worker global scope's module map.
</li>
			<li class="algo">
`~API用~基底~URL$enV
⇒
~RET %~worker大域~scope の`~URL$wG
◎
The API base URL
• Return worker global scope's url.
</li>
			<li class="algo">
`生成元$enV
⇒
~RET ［
次が満たされるならば `不透明な生成元$ ／
~ELSE_ %継承した生成元
］
⇒
%~worker大域~scope の`~URL$wGの`~scheme$url ~EQ `data^l
◎
The origin
• Return a unique opaque origin if worker global scope's url's scheme is "data", and inherited origin otherwise.
</li>
			<li class="algo">
`施策~容器$enV
⇒
~RET %~worker大域~scope の`施策~容器$wG
◎
The policy container
• Return worker global scope's policy container.
</li>
			<li class="algo">
`非同一-生成元~能力は隔離されるか？$enV
⇒
~RET %~worker大域~scope の`非同一-生成元~能力は隔離されるか$wG
◎
The cross-origin isolated capability
• Return worker global scope's cross-origin isolated capability.
</li>
			<li class="algo">
`時刻~起点$enV
⇒
~RET `時刻を粗化する$( %安全でない~worker作成~時刻, %~worker大域~scope の`非同一-生成元~能力は隔離されるか$wG )
◎
The time origin
• Return the result of coarsening unsafeWorkerCreationTime with worker global scope's cross-origin isolated capability.
</li>
		</ul>
	</li>
	<li>
%設定群~obj の
⇒＃
`~ID$enV ~SET 新たな一意かつ不透明な文字列,
`作成時の~URL$enV ~SET %~worker大域~scope の`~URL$,
`~top-level作成時の~URL$enV ~SET ~NULL,
`~target閲覧~文脈$enV ~SET ~NULL,
`作動中な~sw$enV ~SET ~NULL
◎
Set settings object's id to a new unique opaque string, creation URL to worker global scope's url, top-level creation URL to null, target browsing context to null, and active service worker to null.
</li>
	<li>
<p>
%設定群~obj の`~top-level生成元$enV ~SET %~worker大域~scope に応じて
⇒＃
`DedicatedWorkerGlobalScope$I ~objであるならば %外側~設定群 の`~top-level生成元$enV ／
~ELSE_ `実装定義$な値
◎
If worker global scope is a DedicatedWorkerGlobalScope object, then set settings object's top-level origin to outside settings's top-level origin.
◎
Otherwise, set settings object's top-level origin to an implementation-defined value.
</p>

<p class="XXX">
これを適正に定義している最新情報は、
`~client側~storage仕切り法＠https://privacycg.github.io/storage-partitioning/$を見よ。
◎
See Client-Side Storage Partitioning for the latest on properly defining this.
</p>
	</li>
	<li>
%realm の `HostDefined^sl ~field ~SET %設定群~obj
◎
Set realm's [[HostDefined]] field to settings object.
</li>
	<li>
~RET %設定群~obj
◎
Return settings object.
</li>
</ol>
</div>

				</section>
				<section id="dedicated-workers-and-the-worker-interface">
<h5 title="Dedicated workers and the Worker interface">10.2.6.3. 専用~workerと `Worker^I ~interface</h5>

<pre class="idl">
[Exposed=(Window,DedicatedWorker,SharedWorker)]
interface `Worker@I : `EventTarget$I {
  `Worker$mc((`TrustedScriptURL$I or USVString) %scriptURL, optional `WorkerOptions$I %options = {});

  undefined `terminate$mW();

  undefined `postMessage$mW(any %message, sequence&lt;`object$&gt; %transfer);
  undefined `~postMessageO$mW(any %message, optional `StructuredSerializeOptions$I %options = {});
};

dictionary `WorkerOptions@I {
  `WorkerType$I type = "classic";
  `RequestCredentials$I credentials = "same-origin"; // †
  DOMString name = "";
};

enum `WorkerType@I { "classic", "module" };

`Worker$I includes `AbstractWorker$I;
`Worker$I includes `MessageEventTarget$I;
</pre>

<p class="note">注記：†
`credentials^m （`資格証$wG）は、［
`type^m （`種別$wG） ~EQ `module^l
］の場合に限り，利用される。
◎
credentials is only used if type is "module"
</p>

<dl class="domintro">

	<dt>%worker = `new Worker(scriptURL  [, options ])$m</dt>
	<dd>
新たな `Worker$I ~objを返す。
%scriptURL は~backgroundで~fetchされ, 実行され、
新たな大域~環境が作成される。
返される %worker は、
その大域~環境への通信~channelを表現する。
◎
Returns a new Worker object. scriptURL will be fetched and executed in the background, creating a new global environment for which worker represents the communication channel.＼
</dd>
	<dd>
<p>
%options を利用すれば：
◎
options can be used to＼
</p>
		<ul>
			<li>
`name^m ~memberを介して この大域~環境の`名前$wGを定義できる
— これは首に、
~debug目的にある。
◎
define the name of that global environment via the name option, primarily for debugging purposes.＼
</li>
			<li>
`type^m ~memberに `module^l を指定すれば、
この新たな大域~環境が~JS~moduleを~supportすることを確保できる
— その場合、
`credentials^m ~memberを通して， %scriptURL がどう~fetchされるかも指定できる。
◎
It can also ensure this new global environment supports JavaScript modules (specify type: "module"), and if that is specified, can also be used to specify how scriptURL is fetched through the credentials option.
</li>
		</ul>
	</dd>

	<dt>%worker.`terminate()$mW</dt>
	<dd>
%worker に結付けられた大域~環境を中止する。
◎
Aborts worker's associated global environment.
</dd>

	<dt>%worker.`postMessage(message, transfer)$mW</dt>
	<dt>%worker.`~postMessageO(message [, options ])$mW</dt>
	<dd>
%message を~cloneして %worker の大域~環境へ伝送する。
［
%transfer ／ ［
%options の `transfer$m ~member
］］には，一連の~objからなる~listを渡すことができ、
それらは~cloneされずに転送される。
◎
Clones message and transmits it to worker's global environment. transfer can be passed as a list of objects that are to be transferred rather than cloned.
</dd>
</dl>

<p>
各 `Worker$I ~objには、
`外側~port@
が結付けられる
— それは：
◎
Each Worker object has an associated outside port＼
</p>
<ul>
	<li>
`MessagePort$I ~objである。
◎
(a MessagePort).＼
</li>
	<li>
当の~worker作成-時に設定しておかれる~channelの一部を成すが，公開されない。
◎
This port is part of a channel that is set up when the worker is created, but it is not exposed.＼
</li>
	<li>
当の `Worker$I ~objより先に~garbage収集されてはならない。
◎
This object must never be garbage collected before the Worker object.
</li>
</ul>

<div class="algo">
`terminate()@mW
~method手続きは
⇒
コレを結付けている~worker上で`~workerを終了させ$る
◎
The terminate() method, when invoked, must cause the terminate a worker algorithm to be run on the worker with which the object is associated.
</div>

<div class="algo">
<p>
`postMessage(message, transfer)@mW
~method手続きは
⇒
~RET コレの`外側~port$上の
`postMessage$mMP ~method手続き( %message, %transfer )
</p>

<p>
`~postMessageO(message, options)@mW
~method手続きは
⇒
~RET コレの`外側~port$上の
`~postMessageO$mMP ~method手続き( %message, %options )
</p>
◎
The postMessage(message, transfer) and postMessage(message, options) methods on Worker objects act as if, when invoked, they immediately invoked the respective postMessage(message, transfer) and postMessage(message, options) on this's outside port, with the same arguments, and returned the same return value.
</div>

<div class="example">
<p>
この~methodの %message 引数は有構造~dataでもよい：
◎
The postMessage() method's first argument can be structured data:
</p>

<pre class="lang-js">
worker.postMessage({
   opcode: 'activate',
   device: 1938,
   parameters: [23, 102]
});
</pre>
</div>

<hr>

<div class="algo">
<p>
`new Worker(scriptURL, options)@m
構築子~手続きは：
◎
When the Worker(scriptURL, options) constructor is invoked, the user agent must run the following steps:
</p>
<ol>
	<li>
%準拠な~script~URL ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedScriptURL$I,
コレに`関連な大域~obj$,
%scriptURL,
`Worker constructor^l,
`script^l
◎
Let compliantScriptURL be the result of invoking the Get Trusted Type compliant string algorithm with TrustedScriptURL, this's relevant global object, scriptURL, "Worker constructor", and "script".
</li>
	<li>
%外側~設定群 ~LET `現在の設定群~obj$
◎
Let outside settings be the current settings object.
</li>
	<li>
<p>
%~worker~URL ~LET `~URLを符号化法の下で相対的に構文解析する$( %準拠な~script~URL, %外側~設定群 )
◎
Let worker URL be the result of encoding-parsing a URL given compliantScriptURL, relative to outside settings.
</p>

<p class="note">注記：
`blob$sc ~URLも含め，`同一-生成元$であれば どの~URLも利用できる。
`data$sc ~URLも利用できるが、
作成される~workerには`不透明な生成元$が伴われることになる。
◎
Any same-origin URL (including blob: URLs) can be used. data: URLs can also be used, but they create a worker with an opaque origin.
</p>
	</li>
	<li>
~IF［
%~worker~URL ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If worker URL is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
%外側~port ~LET `新たな~obj$( `MessagePort$I, %外側~設定群 の`~realm$enV )
◎
Let worker be a new Worker object.
◎
Let outside port be a new MessagePort in outside settings's realm.
</li>
	<li>
%外側~port の`~message~event~target$ ~SET コレ【！%~worker】
◎
Set outside port's message event target to worker.
</li>
	<li>
コレ【！%~worker】の`外側~port$ ~SET %外側~port
◎
Set worker's outside port to outside port.
</li>
	<li class="algo">
この段は、
`並列的$に走らす
⇒
`~workerを走らす$( ↓ )
⇒＃
コレ,
%~worker~URL,
%外側~設定群,
%外側~port,
%options
◎
Run this step in parallel:
• Run a worker given worker, worker URL, outside settings, outside port, and options.
◎
Return worker.
</li>
</ol>
</div>

				</section>
				<section id="shared-workers-and-the-sharedworker-interface">
<h5 title="Shared workers and the SharedWorker interface">10.2.6.4. 共用~workerと `SharedWorker^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `SharedWorker@I : `EventTarget$I {
  `SharedWorker$mc((`TrustedScriptURL$I or USVString) %scriptURL, optional (DOMString or `WorkerOptions$I) %options = {});

  readonly attribute `MessagePort$I `port$mW;
};
`SharedWorker$I includes `AbstractWorker$I;
</pre>

<dl class="domintro">
	<dt>%sharedWorker = `new SharedWorker(scriptURL [, name ])$m</dt>
	<dd>
新たな `SharedWorker$I ~objを返す。
%scriptURL は~backgroundで~fetchされ, 実行され、
新たな大域~環境が作成される。
返される %sharedWorker は、
その大域~環境への通信~channelを表現する。
%name を利用すれば，その大域~環境の`名前$wGを定義できる。
◎
Returns a new SharedWorker object. scriptURL will be fetched and executed in the background, creating a new global environment for which sharedWorker represents the communication channel. name can be used to define the name of that global environment.
</dd>

	<dt>%sharedWorker = `new SharedWorker(scriptURL [, options ])$m</dt>
	<dd>
新たな `SharedWorker$I ~objを返す。
%scriptURL は~backgroundで~fetchされ, 実行され、
新たな大域~環境が作成される。
返される %sharedWorker は、
その大域~環境への通信~channelを表現する。
◎
Returns a new SharedWorker object. scriptURL will be fetched and executed in the background, creating a new global environment for which sharedWorker represents the communication channel.＼
</dd>
	<dd>
<p>
%options を利用すれば：
◎
options can be used to＼
</p>
		<ul>
			<li>
`name^m ~memberを介して この大域~環境の`名前$wGを定義できる。
◎
define the name of that global environment via the name option.＼
</li>
			<li>
`type^m ~memberに `module^l を指定すれば、
この新たな大域~環境が~JS~moduleを~supportすることを確保できる
— その場合、
`credentials^m ~memberを通して， %scriptURL がどう~fetchされるかも指定できる。
◎
It can also ensure this new global environment supports JavaScript modules (specify type: "module"), and if that is specified, can also be used to specify how scriptURL is fetched through the credentials option.＼
</li>
		</ul>
<p>
%options の［
`type^m ／ `credentials^m
］いずれかの~memberに既存の共用~workerの［
`種別$wG ／ `資格証$wG
］と合致しない値を与える下で，共用~workerを構築しようと試みた場合、
返される `SharedWorker$I に向けて `error$et ~eventを発火させ，既存の共用~workerには接続されないことに注意。
◎
Note that attempting to construct a shared worker with options whose type or credentials values mismatch an existing shared worker will cause the returned sharedWorker to fire an error event and not connect to the existing shared worker.
</p>
	</dd>

	<dt>%sharedWorker.`port$mW</dt>
	<dd>
%sharedWorker の `MessagePort$I ~objを返す。
それを利用して大域~環境と通信できる。
◎
Returns sharedWorker's MessagePort object which can be used to communicate with the global environment.
</dd>
</dl>

<div class="algo">
<p>
`port@mW
取得子~手続きは
⇒
~RET コレの構築子によりアテガわれた値【すなわち， %外側~port 】
◎
The port attribute must return the value it was assigned by the object's constructor.＼
</p>

<p>
返される値は、
共用~workerと通信するための `MessagePort$I を表現する。
◎
It represents the MessagePort for communicating with the shared worker.
</p>
</div>

<p>
~UAには
`共用~worker管理器@
が結付けられる
— 初期~時は、
次の結果とする
⇒
`新たな並列~queueを開始する$()
◎
A user agent has an associated shared worker manager which is the result of starting a new parallel queue.
</p>

<p class="note">注記：
単純にするため、
各~UAに結付けられる`共用~worker管理器$は 1 個だけとする。
実装は、
`生成元$ごとに 1 個ずつ利用して，同時並行性を高めることもできる
— その相違は、
観測され得ないので。
◎
Each user agent has a single shared worker manager for simplicity. Implementations could use one per origin; that would not be observably different and enables more concurrency.
</p>

<div class="algo">
<p>
`new SharedWorker(scriptURL, options)@m
構築子~手続きは：
◎
When the SharedWorker(scriptURL, options) constructor is invoked:
</p>
<ol>
	<li>
%準拠な~script~URL ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedScriptURL$I,
コレに`関連な大域~obj$,
%scriptURL,
`SharedWorker constructor^l,
`script^l
◎
Let compliantScriptURL be the result of invoking the Get Trusted Type compliant string algorithm with TrustedScriptURL, this's relevant global object, scriptURL, "SharedWorker constructor", and "script".
</li>
	<li>
~IF［
%options は `DOMString^I である
］
⇒
%options ~SET 新たな `WorkerOptions^I 辞書
— その
⇒＃
`name^m ~member ~SET %options の値；
他の~member ~SET 各自の既定~値
◎
If options is a DOMString, set options to a new WorkerOptions dictionary whose name member is set to the value of options and whose other members are set to their default values.
</li>
	<li>
%外側~設定群 ~LET `現在の設定群~obj$
◎
Let outside settings be the current settings object.
</li>
	<li>
<p>
%~URL~record ~LET `~URLを符号化法の下で相対的に構文解析する$( %準拠な~script~URL, %外側~設定群 )
◎
Let urlRecord be the result of encoding-parsing a URL given compliantScriptURL, relative to outside settings.
</p>

<p class="note">注記：
`blob$sc ~URLも含め，`同一-生成元$であれば どの~URLも利用できる。
`data$sc ~URLも利用できるが、
作成される~workerには`不透明な生成元$が伴われることになる。
◎
Any same-origin URL (including blob: URLs) can be used. data: URLs can also be used, but they create a worker with an opaque origin.
</p>
	</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError^E
◎
If urlRecord is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
%外側~port ~LET `新たな~obj$( `MessagePort$I, %外側~設定群 の`~realm$enV )
◎
Let worker be a new SharedWorker object.
◎
Let outside port be a new MessagePort in outside settings's realm.
</li>
	<li>
コレの `port$mW 属性 ~SET %外側~port
◎
Assign outside port to the port attribute of worker.
</li>
	<li>
%~call元は~secureな文脈か ~LET ~IS［
%外側~設定群 は`~secureな文脈$enVである
］
◎
Let callerIsSecureContext be true if outside settings is a secure context; otherwise, false.
</li>
	<li>
%外側~storage~key ~LET `非~storage目的~用に~storage~keyを得する$( %外側~設定群 )
◎
Let outside storage key be the result of running obtain a storage key for non-storage purposes given outside settings.
</li>
	<li class="algo">
<p>
`共用~worker管理器$に 次の`手続きを~enqueueする$：
◎
Enqueue the following steps to the shared worker manager:
</p>
		<ol>
			<li>
%~worker大域~scope ~LET ~NULL
◎
Let worker global scope be null.
</li>
			<li>
<p>
すべての `SharedWorkerGlobalScope$I ~objからなる~listを成す
~EACH( %~scope )
に対し：
◎
For each scope in the list of all SharedWorkerGlobalScope objects:
</p>
				<ol>
					<li>
%~worker~storage~key ~LET `非~storage目的~用に~storage~keyを得する$( %~scope に`関連な設定群~obj$ )
◎
Let worker storage key be the result of running obtain a storage key for non-storage purposes given scope's relevant settings object.
</li>
					<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
						<ul>
							<li>
( %~worker~storage~key, %外側~storage~key ) は`同等な~storage~key$である
◎
worker storage key equals outside storage key;
</li>
							<li>
%~scope の`~close中か$wG ~EQ ~F
◎
scope's closing flag is false;
</li>
							<li>
( %~scope の`構築子~URL$wG, %~URL~record )
は`同等な~URL$である
◎
scope's constructor url equals urlRecord; and
</li>
							<li>
%~scope の`名前$wG ~EQ %options[ `name^l ]
◎
scope's name equals the value of options's name member,
</li>
						</ul>
<p>
…ならば：
◎
then:
</p>
						<ol>
							<li>
%~worker大域~scope ~SET %~scope
◎
Set worker global scope to scope.
</li>
							<li>
~BREAK
◎
Break.
</li>
						</ol>
					</li>
				</ol>

<p class="note">注記：
`data$sc ~URLは、
`不透明な生成元$が伴われる~workerを作成することになる。
`構築子~生成元$wG, `構築子~URL$wG の両者とも比較されるので，同じ `data$sc ~URLを利用して ある`生成元$の中で同じ `SharedWorkerGlobalScope$I ~objを取得できるが、
`同一-生成元$の制約を迂回することはできない。
◎
data: URLs create a worker with an opaque origin. Both the constructor origin and constructor url are compared so the same data: URL can be used within an origin to get to the same SharedWorkerGlobalScope object, but cannot be used to bypass the same origin restriction.
</p>

<p class="trans-note">【
この段には、
反復~順序が指定されていない
— 条件を満たす %~scope が複数ある場合、
どれが選ばれるかは実装定義になる。
】</p>
			</li>
			<li>
<p>
~IF［
%~worker大域~scope ~NEQ ~NULL
］：
◎
↓</p>
				<ol>
					<li>
<p>
~IF［
~UAは、［
%~worker大域~scope が表現する~workerと［
`~script$のうち［
その`設定群~obj$ ~EQ %外側~設定群
］を満たすもの
］との間の通信
］を許容しないよう環境設定されている
］
⇒
%~worker大域~scope ~SET ~NULL
◎
If worker global scope is not null, but the user agent has been configured to disallow communication between the worker represented by the worker global scope and the scripts whose settings object is outside settings, then set worker global scope to null.
</p>

<p class="note">注記：
例えば、
次のようなときが該当する
⇒
~UAは開発~mode下にあり，
そこでは 特定0の`~top-level辿可能$が 他のすべての~pageから隔離されていて、
その開発~mode下の~scriptから［
通常の閲覧~modeで走っている~worker
］へ接続することは阻止されている。
◎
For example, a user agent could have a development mode that isolates a particular top-level traversable from all other pages, and scripts in that development mode could be blocked from connecting to shared workers running in the normal browser mode.
</p>
					</li>
					<li>
<p>
~ELIF［
%~worker大域~scope の`種別$wG ~NEQ %options[ `type^l ]
］~OR［
%~worker大域~scope の`資格証$wG ~NEQ %options[ `credentials^l ]
］：
</p>
						<ol>
							<li>
<p>
`~taskを~queueする$( 【`~DOM操作~task~source$？】, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~eventを発火する$( 【コレ】, `error$et )
</div>
							</li>
							<li>
~RET
</li>
						</ol>
◎
If worker global scope is not null, then check if worker global scope's type and credentials match the options values. If not, queue a task to fire an event named error and abort these steps.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~worker大域~scope ~NEQ ~NULL
］：
◎
If worker global scope is not null, then run these subsubsteps:
</p>
				<ol>
					<li>
%設定群~obj ~LET %~worker大域~scope に`関連な設定群~obj$
◎
Let settings object be the relevant settings object for worker global scope.
</li>
					<li>
%~workerは~secureな文脈か ~LET ~IS［
%設定群~obj は`~secureな文脈$enVである
］
◎
Let workerIsSecureContext be true if settings object is a secure context; otherwise, false.
</li>
					<li>
<p>
~IF［
%~workerは~secureな文脈か ~NEQ %~call元は~secureな文脈か
］：
</p>
						<ol>
							<li>
<p>
`~taskを~queueする$( 【`~DOM操作~task~source$？】, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~eventを発火する$( コレ, `error$et )
</div>
							</li>
							<li>
~RET
</li>
					</ol>
`SECURE-CONTEXTS$r
◎
If workerIsSecureContext is not callerIsSecureContext, then queue a task to fire an event named error at worker and abort these steps. [SECURE-CONTEXTS]
</li>
					<li>
コレを %~worker大域~scope に結付ける
◎
Associate worker with worker global scope.
</li>
					<li>
%内側~port ~LET `新たな~obj$( `MessagePort$I, %設定群~obj の`~realm$enV )
◎
Let inside port be a new MessagePort in settings object's realm.
</li>
					<li>
`~portを連絡する$( %外側~port, %内側~port )
◎
Entangle outside port and inside port.
</li>
					<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~eventを発火する$( %~worker大域~scope, `connect$et, `MessageEvent$I )
— 次のように初期化して
⇒＃
`data$m 属性 ~SET 空~文字列,
`ports$m 属性 ~SET %内側~port のみを包含している新たな`凍結d配列$,
`source$m 属性 ~SET %内側~port
</div>
◎
Queue a task, using the DOM manipulation task source, to fire an event named connect at worker global scope, using MessageEvent, with the data attribute initialized to the empty string, the ports attribute initialized to a new frozen array containing only inside port, and the source attribute initialized to inside port.
</li>
					<li>
%~worker大域~scope の`所有者~集合$wGに［
%外側~設定群 から与えられる，`関連な所有者として追加するもの$
］を`付加する$set
◎
Append the relevant owner to add given outside settings to worker global scope's owner set.
</li>
				</ol>
			</li>
			<li class="algo">
~ELSE
⇒
次を`並列的$に走らす
⇒
`~workerを走らす$( ↓ )
⇒＃
コレ,
%~URL~record,
%外側~設定群,
%外側~port,
%options
◎
Otherwise, in parallel, run a worker given worker, urlRecord, outside settings, outside port, and options.
</li>
		</ol>
<p>
◎
Return worker.
</p>
	</li>
</ol>
</div>

				</section>
			</section>
			<section id="navigator.hardwareconcurrency">
<h4 title="Concurrent hardware capabilities">10.2.7. 同時並行な~hardware能力</h4>

<pre class="idl">
interface mixin `NavigatorConcurrentHardware@I {
  readonly attribute unsigned long long `hardwareConcurrency$m;
};
</pre>

<dl class="domintro">
	<dt>%self.`navigator$m.`hardwareConcurrency$m</dt>
	<dd>
~UAに可用になり得る論理的な~CPUsを返す。
◎
Returns the number of logical processors potentially available to the user agent.
</dd>
</dl>

<div class="algo">
<p>
◎追跡路
`hardwareConcurrency@m
取得子は：
◎
(This is a tracking vector.)
The navigator.hardwareConcurrency attribute's getter must＼
</p>
<ul>
	<li>
1 以上, ［
~UAに可用になり得る論理的な~CPUs
］以下の整数を返す
— ~UAがこれを決定できない場合は 1 を返すとする。
◎
return a number between 1 and the number of logical processors potentially available to the user agent. If this cannot be determined, the getter must return 1.
</li>
	<li>
~UAは、
次のいずれかに該当する事例に限って，
可用な論理的な~CPUsとしてより低い値を公開するべきである【！ err toward】
⇒＃
特有な制限sがあるとき（作成できる `Worker$I 数の上限など）／
指紋収集の可能性を制限したいと欲するとき
◎
User agents should err toward exposing the number of logical processors available, using lower values only in cases where there are user-agent specific limits in place (such as a limitation on the number of workers that can be created) or when the user agent desires to limit fingerprinting possibilities.
</li>
</ul>
</div>

			</section>
		</section>
		<section id="apis-available-to-workers">
<h3 title="APIs available to workers">10.3. ~workerから可用な~API</h3>

			<section id="importing-scripts-and-libraries">
<h4 title="Importing scripts and libraries">10.3.1. ~script／~libraryの~import法</h4>

<div class="algo">
<p>
`WorkerGlobalScope$I ~objの
`importScripts(...urls)@m
~method手続きは：
◎
The importScripts(...urls) method steps are:
</p>
<ol>
	<li>
%~URL文字列~群 ~LET « »
◎
Let urlStrings be « ».
</li>
	<li>
<p>
%urls を成す
~EACH( %~URL )
に対し：
◎
For each url of urls:
</p>
		<ol>
			<li>
%~URL文字列~群 に次の結果を`付加する$
⇒
`信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedScriptURL$I,
コレに`関連な大域~obj$,
%~URL,
`WorkerGlobalScope importScripts^l,
`script^l
◎
Append the result of invoking the Get Trusted Type compliant string algorithm with TrustedScriptURL, this's relevant global object, url, "WorkerGlobalScope importScripts", and "script" to urlStrings.
</li>
		</ol>
	</li>
	<li>
`~scriptを~worker大域~scopeの中へ~importする$( コレ, %~URL文字列~群 )
◎
Import scripts into worker global scope given this and urlStrings.
</li>
</ol>
</div>

<div class="algo">
<p>
`~scriptを~worker大域~scopeの中へ~importする@
ときは、
所与の
⇒＃
`WorkerGlobalScope$I ~obj %~worker大域~scope,
`~scalar値~文字列$の`~list$ %~URL群,
`~fetch~hookを遂行する~algo$ %~fetchを遂行する（省略時は ε ）
◎終
に対し，次の手続きを走らすモノトスル：
◎
To import scripts into worker global scope, given a WorkerGlobalScope object worker global scope, a list of scalar value strings urls, and an optional perform the fetch hook performFetch:
</p>
<ol>
	<li>
~IF［
%~worker大域~scope の`種別$wG ~EQ `module^l
］
⇒
~THROW `TypeError^E
◎
If worker global scope's type is "module", throw a TypeError exception.
</li>
	<li>
%設定群~obj ~LET `現在の設定群~obj$
◎
Let settings object be the current settings object.
</li>
	<li>
~IF［
%~URL群 は空である
］
⇒
~RET
◎
If urls is empty, return.
</li>
	<li>
%~URL~record群 ~LET « »
◎
Let urlRecords be « ».
</li>
	<li>
<p>
%~URL群 を成す
~EACH( %~URL文字列 )
に対し：
◎
For each url of urls:
</p>
		<ol>
			<li>
%~URL~record ~SET `~URLを符号化法の下で相対的に構文解析する$( %~URL文字列, %設定群~obj )
◎
Let urlRecord be the result of encoding-parsing a URL given url, relative to settings object.
</li>
			<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError^E
◎
If urlRecord is failure, then throw a "SyntaxError" DOMException.
</li>
			<li>
%~URL~record群 に %~URL~record を付加する
◎
Append urlRecord to urlRecords.
</li>
		</ol>
	</li>
	<li>
<p>
%~URL~record群 を成す
~EACH( %~URL~record )
に対し：
◎
For each urlRecord of urlRecords:
</p>
		<ol>
			<li>
%~script ~LET `~workerが~importした古典~scriptを~fetchする$( %~URL~record, %設定群~obj, %~fetchを遂行する )
（この段は、
例外を投出し得る）
◎
Fetch a classic worker-imported script given urlRecord and settings object, passing along performFetch if provided. If this succeeds, let script be the result. Otherwise, rethrow the exception.
</li>
			<li>
<p>
`古典~scriptを走らす$( %~script, %~errorは再投出するか ~SET ~T )
◎
Run the classic script script, with the rethrow errors argument set to true.
</p>

<p class="note">注記：
~scriptは、
次のいずれかが生じるまで走らすことになる
⇒＃
普通に返った／
構文解析-に失敗した／
投出された例外を~catchしなかった／
`~workerが終了され$たため，`尚早に中止され$た
◎
script will run until it either returns, fails to parse, fails to catch an exception, or gets prematurely aborted by the terminate a worker algorithm defined above.
</p>

<p>
［
~scriptから例外が投出された ／
~scriptは`尚早に中止され$た
］ときは
【普通に返らなかった場合】
⇒
この手続きすべてを中止した上で、
~call元~の~scriptにて，その［
例外／中止-
］の処理を継続させる
◎
If an exception was thrown or if the script was prematurely aborted, then abort all these steps, letting the exception or aborting continue to be processed by the calling script.
</p>
			</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
`Service Workers^cite `SW$r は、
自前の`~fetch~hookを遂行する~algo$を与えて この~algoを走らす仕様の例である。
◎
Service Workers is an example of a specification that runs this algorithm with its own perform the fetch hook. [SW]
</p>
</div>

			</section>
			<section id="the-workernavigator-object">
<h4 title="The WorkerNavigator interface">10.3.2. `WorkerNavigator^I ~interface</h4>

<div class="algo">
`WorkerGlobalScope$I ~interfaceの
`navigator@m
取得子~手続きは、
~UA（~client）の同一性と状態を表現する，
`WorkerNavigator$I ~interfaceの~instanceを返す。
◎
The navigator attribute of the WorkerGlobalScope interface must return an instance of the WorkerNavigator interface, which represents the identity and state of the user agent (the client):
</div>

<pre class="idl">
[Exposed=Worker]
interface `WorkerNavigator@I {};
`WorkerNavigator$I includes `NavigatorID$I;
`WorkerNavigator$I includes `NavigatorLanguage$I;
`WorkerNavigator$I includes `NavigatorOnLine$I;
`WorkerNavigator$I includes `NavigatorConcurrentHardware$I;
</pre>

			</section>
			<section id="worker-locations">
<h4 title="The WorkerLocation interface">10.3.3. `WorkerLocation^I ~interface</h4>

<pre class="idl">
[Exposed=Worker]
interface `WorkerLocation@I {
  stringifier readonly attribute USVString `href$m;
  readonly attribute USVString `origin$m;
  readonly attribute USVString `protocol$m;
  readonly attribute USVString `host$m;
  readonly attribute USVString `hostname$m;
  readonly attribute USVString `port$m;
  readonly attribute USVString `pathname$m;
  readonly attribute USVString `search$m;
  readonly attribute USVString `hash$m;
};
</pre>

<p>
各 `WorkerGlobalScope$I ~objは、
`~worker所在~obj@
を有する
— それは、
ある `WorkerLocation$I ~objであり，初期~時は ε とする。
◎
A WorkerLocation object has an associated WorkerGlobalScope object (a WorkerGlobalScope object).
</p>

<p class="trans-note">【
これらの~objは、
一対一に対応する。
】【
初期~値 ε は、
~~形式上のものであり，~accessされ得ない
— `location$m の注記を見よ。
】</p>

<p>
この節を通して、
`~URL@V
は，［
`~worker所在~obj$として当の `WorkerLocation$I ~objを有している `WorkerGlobalScope$I ~obj
］の`~URL$wGを指すとする。
◎
↓</p>

<div class="algo">
`href@m
取得子~手続きは
⇒
~RET `~URLを直列化する$( `~URL$V )
◎
The href getter steps are to return this's WorkerGlobalScope object's url, serialized.
</div>

<div class="algo">
`origin@m
取得子~手続きは
⇒
~RET `生成元を直列化する$( `~URL$V の`生成元$url )
◎
The origin getter steps are to return the serialization of this's WorkerGlobalScope object's url's origin.
</div>

<div class="algo">
`protocol@m
取得子~手続きは
⇒
~RET 次を順に`連結する$
⇒＃
`~URL$V の`~scheme$url,
`:^l
◎
The protocol getter steps are to return this's WorkerGlobalScope object's url's scheme, followed by ":".
</div>

<div class="algo">
<p>
`host@m
取得子~手続きは：
</p>
<ol>
	<li>
%~host ~LET `~URL$V の`~host$url
</li>
	<li>
~IF［
%~host ~EQ ~NULL
］
⇒
~RET 空~文字列
</li>
	<li>
%~host ~LET `~hostを直列化する$( %~host )
</li>
	<li>
%~port ~LET `~URL$V の`~port$url
</li>
	<li>
~IF［
%~port ~EQ ~NULL
］
⇒
~RET %~host
</li>
	<li>
%~port ~SET `整数を直列化する$( %~port )
</li>
	<li>
<p>
~RET 次を順に`連結する$
⇒＃
%~host,
`:^l,
%~port
</li>
</ol>
◎
The host getter steps are:
• Let url be this's WorkerGlobalScope object's url.
• If url's host is null, return the empty string.
• If url's port is null, return url's host, serialized.
• Return url's host, serialized, followed by ":" and url's port, serialized.
</div>

<div class="algo">
<p>
`hostname@m
取得子~手続きは：
◎
The hostname getter steps are:
</p>
<ol>
	<li>
%~host ~LET `~URL$V の`~host$url
◎
Let host be this's WorkerGlobalScope object's url's host.
</li>
	<li>
~IF［
%~host ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If host is null, return the empty string.
</li>
	<li>
~RET `~hostを直列化する$( %~host )
◎
Return host, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`port@m
取得子~手続きは：
◎
The port getter steps are:
</p>
<ol>
	<li>
%~port ~LET `~URL$V の`~port$url
◎
Let port be this's WorkerGlobalScope object's url's port.
</li>
	<li>
~IF ［
%~port ~EQ ~NULL 
］
⇒
~RET 空~文字列
◎
If port is null, return the empty string.
</li>
	<li>
~RET `整数を直列化する$( %~port )
◎
Return port, serialized.
</li>
</ol>
</div>

<div class="algo">
`pathname@m
取得子~手続きは
⇒
~RET `~URL~pathを直列化する$( `~URL$V )
◎
The pathname getter steps are to return the result of URL path serializing this's WorkerGlobalScope object's url.
</div>

<div class="algo">
<p>
`search@m
取得子~手続きは：
◎
The search getter steps are:
</p>
<ol>
	<li>
%~query ~LET `~URL$V の`~query$url
◎
Let query be this's WorkerGlobalScope object's url's query.
</li>
	<li>
~IF［
%~query ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If query is either null or the empty string, return the empty string.
</li>
	<li>
~RET 次を順に`連結する$
⇒＃
`?^l,
%~query
◎
Return "?", followed by query.
</li>
</ol>
</div>

<div class="algo">
<p>
`hash@m
取得子~手続きは：
◎
The hash getter steps are:
</p>
<ol>
	<li>
%素片 ~LET `~URL$V の`素片$url
◎
Let fragment be this's WorkerGlobalScope object's url's fragment.
</li>
	<li>
~IF［
%素片 ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If fragment is either null or the empty string, return the empty string.
</li>
	<li>
~RET 次を順に`連結する$
⇒＃
`#^l,
%素片
◎
Return "#", followed by fragment.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
</main>
