<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Animations Level 2 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">
<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^!])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'at':
	text = `@${key}`;
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'pe':
	text = `::${key}`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

</script>



<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Animations Level 2
spec_date:2023-04-05
trans_update:2023-04-06
source_checked:200304
page_state_key:CSS
original_url:https://w3c.github.io/csswg-drafts/css-animations-2/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-anim,css
conformance:css
copyright:2023,permissive
trans_1st_pub:2019-01-06

●●class_map
p:property
ps:pseudo
pe:pseudo
at:at-rule
t:type
v:value
et:event-type
E:error
css:css
f:func
op:op

●●tag_map
p:code
pe:code
ps:code
t:var
css:code
at:code
f:code
et:code
E:code
I:code
m:code
v:code
c:code
i:i
op:span

●●words_table1
SCROLL-ANIM:https://w3c.github.io/csswg-drafts/scroll-animations-1/
auto0:auto
none0:none

●●words_table

	●animation
WAnim:Web Animations
keyframe:
moment::時点
seek:
組成-:composite::~
組成法:composite::~
累積-:accumulate::~
稼働中:running::~
稼働中の:runningな::~
再生-:play::~
再生:playback::~
	再生し直す:replay
逆再生-:reverse::~
静止-:pause::~
静止中:paused::~
静止中の:pausedな::~
事後:after::~
事前:before::~
区間:interval::~
経過d:elapsed::経過
延伸:fill::~

相:phase::~
両方:both::~
作動:active::~::アクティブ
遊休:idle::~
遊休中:idle::~
未解決:unresolved::~
自動巻戻し:auto-rewind::~
現-:current:~
easing:
	~easing:timing
周回:cycle:~
瞬間的:instantaneous:~

	●一般処理
処理待ち:pending::~
繰返しの:repeating:繰り返しの
繰返して:repeatして:繰り返して
渡され:passされ::~
手続:procedure:手続き
換算-:convert:~
飛ばさ:skipさ:~

	逆順に:in reverse
	同時に:simultaneous
	間を置かずに:immediate succession
	し続ける:sticky
	以降は 〜 しても:after 〜 subsequent

	●CSS
出自の:originating::~
展開-:expand::~
協調-:coordinate:~

	下位prop:longhand／:subproperties／
	~~末端の下位prop:longhand subproperties
	-:encounter
	算出し直す:recomputing
	視野~法:scoping

	●仕様
	API:programming interface
	~level:Level
可能性:possibility:~
事実:fact:~
差分:delta:~
安定-:stable:~
際どい:edge:~
併合-:merge:~
切離され:disassociateされ:切り離され
孤立な:orphaned:孤立した

	対応関係:correspondance
	優先される:precedenceを take する
	よって:hence
	常にそうなるは限らない:this is not always the case
	であり、:meaning that
	以下における:subsequent references
	および:as well as
	指す:refer to
	あてがった:filling-in
	追い続ける:hang on
	“〜”:reference
	授ける:impart
	人に易しくなる:ergonomics

	●未分類
milli:milli-:::ミリ
	~milli秒数:millisecond
昇順:ascending order:~
	表:table
	図:chart
	A/B/C/D/E
	秒:seconds
	~CSS~animation:CSS Animation

	~live性:liveness
	計算し直す:recalculating
	始-:begin
	そうなる:enter
	なる:become
	現れる:appearする

	●指示語
	%N 個目:position
	前:earlier
	様々な:various
	片:fragment
	いずれか一つ:mutually-exclusive
	間近に:closer to
	それ以降:that point forwards
	他へ:out
	その時点から:after which point
	前回の:previous
	時点:point
	-:next
	より前:lower
	両方^i
	-:final

●●original_id_map

valdef-animation-composition-replace:
valdef-animation-composition-add:
valdef-animation-composition-accumulate:

●●mdn_urls
	propdef-animation-composition:CSS/animation-composition
	cssanimation:API/CSSAnimation

●●link_map

	●IDL

Exposed:~WEBIDLjs#Exposed
CSSOMString:~CSSOM1#cssomstring
unrestricted double:~WEBIDL#idl-unrestricted-double

I.AnimationEffect:~WANIMapi#animationeffect
I.KeyframeEffect:~WANIMapi#keyframeeffect
I.CSSAnimation:#cssanimation
I.Animation:~WANIMapi#animation
I.AnimationEvent:~CSSANIM#animationevent
I.DocumentTimeline:~WANIMapi#documenttimeline
I.KeyframeEffect:~WANIMapi#keyframeeffect
I.KeyframeEffectReadOnly:~WANIMapi#keyframeeffectreadonly
I.OptionalEffectTiming:~WANIMapi#dictdef-optionaleffecttiming

m.animationName:#dom-cssanimation-animationname
m.elapsedTime:~CSSANIM#dom-animationevent-elapsedtime
m.effect:~WANIMapi#dom-animation-effect
m.getAnimations:~WANIMapi#dom-animatable-getanimations
m.pause:~WANIMapi#dom-animation-pause
m.play:~WANIMapi#dom-animation-play
m.playState:~WANIMapi#dom-animation-playstate
m.reverse:~WANIMapi#dom-animation-reverse
m.setKeyframes:~WANIMapi#dom-keyframeeffect-setkeyframes
m.startTime:~WANIMapi#dom-animation-starttime
m.updateTiming:~WANIMapi#dom-animationeffect-updatetiming

	●et
et.animationcancel:~CSSANIM#eventdef-globaleventhandlers-animationcancel
et.animationend:~CSSANIM#eventdef-globaleventhandlers-animationend
et.animationiteration:~CSSANIM#eventdef-globaleventhandlers-animationiteration
et.animationstart:~CSSANIM#eventdef-globaleventhandlers-animationstart

	●css
at.keyframes:~CSSANIM#at-ruledef-keyframes

p.animation-composition:#propdef-animation-composition
p.animation-timeline:#propdef-animation-timeline
p.animation-delay:~CSSANIM#propdef-animation-delay
p.animation-direction:~CSSANIM#propdef-animation-direction
p.animation-duration:#propdef-animation-duration
p.animation-fill-mode:~CSSANIM#propdef-animation-fill-mode
p.animation-iteration-count:~CSSANIM#propdef-animation-iteration-count
p.animation-name:~CSSANIM#propdef-animation-name
p.animation-play-state:~CSSANIM#propdef-animation-play-state
p.animation-range:~SCROLL-ANIM#propdef-animation-range
p.animation-timing-function:~CSSANIM#propdef-animation-timing-function

p.animation:~CSSANIM#propdef-animation
p.scale:~TRANSFORM2#propdef-scale
	p.scale:https://w3c.github.io/csswg-drafts/css-transforms-2/#propdef-scale

t.custom-ident:~CSSVAL#identifier-value
t.easing-function:~CSSEASING#typedef-easing-function
t.keyframe-block:~CSSANIM#typedef-keyframe-block
t.keyframes-name:~CSSANIM#typedef-keyframes-name
t.keyframes-name:~CSSANIM#typedef-keyframes-name
t.single-animation:#typedef-single-animation
t.single-animation-composition:#typedef-single-animation-composition
t.single-animation-direction:~CSSANIM#typedef-single-animation-direction
t.single-animation-fill-mode:~CSSANIM#typedef-single-animation-fill-mode
t.single-animation-iteration-count:~CSSANIM#typedef-single-animation-iteration-count
t.single-animation-play-state:~CSSANIM#typedef-single-animation-play-state
t.single-animation-timeline:#typedef-single-animation-timeline
t.string:~CSSVAL#string-value
t.time:~CSSVAL#time-value
t.scroll():~SCROLL-ANIM#funcdef-scroll
t.view():~SCROLL-ANIM#funcdef-view
	f.scroll:~SCROLL-ANIM#funcdef-scroll
	f.view:~SCROLL-ANIM#funcdef-view


v.auto:#valdef-animation-timeline-auto
v.none:#valdef-animation-timeline-none

v.replace:#valdef-animation-composition-replace
v.add:#valdef-animation-composition-add
v.accumulate:#valdef-animation-composition-accumulate

v.~auto0:#valdef-animation-duration-auto
	t.time:#valdef-animation-duration-time-0s

v.backwards:~CSSANIM#valdef-animation-fill-mode-backwards
v.both:~CSSANIM#valdef-animation-fill-mode-both
v.forwards:~CSSANIM#valdef-animation-fill-mode-forwards
v.~none0:~CSSANIM#valdef-animation-fill-mode-none

	#valdef-animation-timeline-custom-ident
	#valdef-animation-timeline-scroll
	#valdef-animation-timeline-view

v.paused:~CSSANIM#valdef-animation-play-state-paused
v.running:~CSSANIM#valdef-animation-play-state-running
v.step-end:~CSSEASING#valdef-step-easing-function-step-end

	●用語
経過d時間:#elapsed-time
区間~終端:#interval-end
区間~始端:#interval-start
所有している要素:#owning-element

	*:#multiple-events-note
	:#animation-iteration-elapsed-time

	●用語（CSSANIM／WANIM
~animation~prop:~CSSANIM#_animation-properties
	~keyframe:~CSSANIM#keyframe
~keyframe選択子:~CSSANIM#_keyframe-selector
選択子の値:~CSSANIM#_keyframe-selector-value

計時~関数:~CSSEASING#easing-function

時列線:~WANIM#timeline
既定の文書~時列線:~WANIM#document-default-document-timeline
~animation:~WANIM#concept-animation
~animation~class:~WANIM#animation-class
~animation~frame:~WANIM#animation-frame
~animationを再生する:~WANIM#play-an-animation
~animationを静止する:~WANIM#pause-an-animation
~animation効果:~WANIM#animation-effect
大域~animation~list:~WANIM#global-animation-list
~keyframe:~WANIM#keyframe
~keyframe~offset:~WANIM#keyframe-offset
再生-状態:~WANIM#animation-play-state
再生~方向:~WANIM#playback-direction
反復~回数:~WANIM#iteration-count
反復~所要時間:~WANIM#iteration-duration
延伸~mode:~WANIM#fill-mode
開始-遅延:~WANIM#start-delay
i.静止中:~WANIM#play-state-paused
i.稼働中:~WANIM#play-state-running
i.遊休中:~WANIM#play-state-idle
結付けられている効果:~WANIM#animation-associated-effect
結付けられている効果の終端:~WANIM#associated-effect-end
~target要素:~WANIM#effect-target-target-element

i.作動~相:~WANIM#animation-effect-active-phase
i.事後~相:~WANIM#animation-effect-after-phase
i.事前~相:~WANIM#animation-effect-before-phase
i.遊休~相:~WANIM#animation-effect-idle-phase

作動~所要時間:~WANIM#active-duration
作動~時刻:~WANIM#active-time
組成-演算~型:~WANIM#composite-operation
~keyframeに特有な組成-演算~型:~WANIM#keyframe-specific-composite-operation
組成法:#_composite
現-反復:~WANIM#current-iteration
現-時刻:~WANIM#animation-current-time
反復~始端:~WANIM#iteration-start
未解決:~WANIM#unresolved

組成-順序:~WANIM#animation-composite-order
処理待ち再生-~task:~WANIM#pending-play-task
処理待ち静止-~task:~WANIM#pending-pause-task

~animation再生~event:~WANIM#animation-playback-events

~scroll進捗~時列線:~SCROLL-ANIM#scroll-progress-timelines
~view進捗~時列線:~SCROLL-ANIM#view-progress-timelines
~scroll駆動な~animation:~SCROLL-ANIM#scroll-driven-animations

	●用語（他 CSS
すべての要素:~CSSPSEUDO#generated-content
算出d値:~CASCADE#computed-value
略式~prop:~CASCADE#shorthand-property
下位prop:~CASCADE#longhand
解決d値:~CSSOM1#resolved-value
出自の要素:~SELECTORS4#originating-element

~CSS識別子:~CSSVAL#css-css-identifier
協調している~list~prop~group:~CSSVAL#coordinating-list-property
協調される値~list:~CSSVAL#coordinated-value-list
協調している基底~list~prop:~CSSVAL#coordinating-list-base-property

	●用語（他
~target:~DOM4#event-target
~tree順序:~DOM4#concept-tree-order

●●ref_key_map
CSS3ANIMATIONS:CSSANIMATIONS1
CSS3TRANSITIONS:CSSTRANSITIONS1

●●ref_normative

[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://w3c.github.io/csswg-drafts/css-cascade-5/
[CSS-EASING-2]
    CSS Easing Functions Level 2 URL: https://w3c.github.io/csswg-drafts/css-easing-2/
[CSS-TEXT-4]
    Elika Etemad; et al. ＜CSS Text Module Level 4＞. URL: https://w3c.github.io/csswg-drafts/css-text-4/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://w3c.github.io/csswg-drafts/css-values-4/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. URL: https://w3c.github.io/csswg-drafts/css-writing-modes-4/
[CSS3-ANIMATIONS]
    David Baron; et al. ＜CSS Animations Level 1＞. URL: https://w3c.github.io/csswg-drafts/css-animations/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://w3c.github.io/csswg-drafts/cssom/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SCROLL-ANIMATIONS-1]
    Brian Birtles; et al. ＜Scroll-linked Animations＞. URL: https://w3c.github.io/csswg-drafts/scroll-animations-1/
[WEB-ANIMATIONS]
    Brian Birtles; et al. ＜Web Animations＞. URL: https://w3c.github.io/csswg-drafts/web-animations-1/
[WEB-ANIMATIONS-2]
    Brian Birtles; Robert Flack. ＜Web Animations Level 2＞. URL: https://w3c.github.io/csswg-drafts/web-animations-2/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-MASKING-1]
    Dirk Schulze; Brian Birtles; Tab Atkins Jr.. ＜CSS Masking Module Level 1＞. URL: https://drafts.fxtf.org/css-masking-1/
[CSS-TRANSFORMS-2]
    Tab Atkins Jr.; et al. ＜CSS Transforms Module Level 2＞. URL: https://w3c.github.io/csswg-drafts/css-transforms-2/
[CSS3-TRANSITIONS]
    David Baron; et al. ＜CSS Transitions＞. URL: https://w3c.github.io/csswg-drafts/css-transitions/
[SCROLL-ANIMATIONS]
    ＜Scroll-linked Animations＞. cg-draft. URL: https://wicg.github.io/scroll-animations/


●●trans_metadata

<p>
~THIS_PAGEは、~W3Cにより
編集者草案として公開された
<a href="~SPEC_URL">CSS Animations Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-animations-2/
公表履歴
	https://www.w3.org/standards/history/css-animations-2
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-animations-2">CSSWG Issues Repository</a>
編集
	<a href="https://dbaron.org/">L. David Baron</a> (Google)
	<a href="mailto:brian@birchill.co.jp">Brian Birtles</a> (Invited Expert)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-animations-2/Overview.bs">GitHub Editor</a>
課題リスト
	https://github.com/w3c/csswg-drafts/labels/css-animations-2

commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-animations-2

</script>



<body>

<header>
	<hgroup>
<h1>CSS アニメーション 2 — CSS Animations Level 2</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この~CSS~moduleは、
作者が，~keyframeを利用して~CSS~propの値を時間とともに~animateする仕方を述べる。
これらの~keyframe~animationの挙動は［
所要時間, 繰返す回数, 繰返しの挙動
］を指定することにより制御できる。
◎
This CSS module describes a way for authors to animate the values of CSS properties over time, using keyframes. The behavior of these keyframe animations can be controlled by specifying their duration, number of repeats, and repeating behavior.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">
	<section id="delta">
<h2 title="Delta specification">1. 差分~仕様</h2>

<p>
これは差分~仕様であり、
現時点の ~level 1 仕様 `CSS3-ANIMATIONS$r からの相違点のみを包含する。
~level 1 仕様が完了-間近になったときは、
それとこの差分は，完全な~level 2 仕様として併合されることになる。
【したがって，以下に現れる “この仕様に定義される…” 等々の句は、~level 1 仕様も包摂する。】
◎
This is a delta specification, meaning that it currently contains only the differences from CSS Animations Level 1 [CSS3-ANIMATIONS]. Once the Level 1 specification is closer to complete, it will be merged with the additions here into a complete level 2 specification.
</p>

	</section>
	<section id="animations">
<h2 title="Animations">2. ~animation</h2>

<p>
この仕様に定義される各種~animation~propに対し，変化が生じたときは、［
対応する `CSSAnimation$I ~obj, それに結付けられている各種~obj
］も更新される
— これらの~propと~WAnimの各種~概念との対応関係は、
`§ ~keyframeの宣言-法＠#keyframes$
に則って定義される。
◎
Changes to any of the animation properties defined in this specification cause the corresponding CSSAnimation object and its associated objects to be updated according to the correspondence between these properties and Web Animations concepts defined in § 3 Declaring Keyframes.
</p>

<p>
しかしながら，作者が~WAnim~APIを利用して当の~animationを改変した場合、
~APIによる変更が以下に従うように優先される
— 以下における
%~animation は［
当の~animation, または それを表現する `CSSAnimation$I ~obj
］,
%~keyframe効果 は［
%~animation に結付けられている `KeyframeEffect$I ~obj
【すなわち， %~animation に`結付けられている効果$を表現する `AnimationEffect$I ~obj】
］を指すとする：
◎
However, if the author modifies the animation using the Web Animations programming interface, the changes from the programming interface take precedence as follows:
</p>

<ul>
	<li>
<p>
%~keyframe効果 に対し `setKeyframes()$m が成功裡に~callされて以降は、
%~keyframe効果 の`~target要素$用の［
【その引数に】合致している `keyframes$at 規則／
`animation-timing-function$p ~propの`解決d値$
］を変更しても， %~animation には反映されなくなる。
◎
After a successful call to setKeyframes() on the KeyframeEffect associated with a CSSAnimation, any subsequent change to matching @keyframes rules or the resolved value of the animation-timing-function property for the target element will not be reflected in that animation.
</p>

<p>
ただし，合致している最後の `keyframes$at 規則が除去された場合、
%~animation は 依然として取消されるモノトスル。
◎
However, if the last matching @keyframes rule is removed the animation must still be canceled.
</p>
	</li>
	<li>
<p>
%~keyframe効果 に対し `updateTiming()$m が成功裡に~callされて以降は、［
その %timing ~parameter に渡された `OptionalEffectTiming$I 辞書
【！%timing:~WANIM#dom-animationeffect-updatetiming-timing-timing】
］内に在る各~memberに対応する~animation~propを変更しても， %~animation には反映されなくなる。
◎
After a successful call to updateTiming() on the KeyframeEffect associated with a CSSAnimation, for each property included in the timing parameter, any subsequent change to a corresponding animation property will not be reflected in that animation.
</p>

<p class="example">
例えば，
`cssAnimation.effect.updateTiming({ duration: 1000 })^c
を~callした場合、
`animation-duration$p を変更しても無視されるようになる一方，
`animation-delay$p に対する変更は 依然として
%~keyframe効果 の計時に反映されることになる。
◎
For example, calling cssAnimation.effect.updateTiming({ duration: 1000 }) would cause subsequent changes to animation-duration to be ignored whilst changes to animation-delay would still be reflected in the KeyframeEffect's timing.
</p>
	</li>
	<li>
<p>
%~animation に対し，次のいずれかが生じたならば、
それ以降は， `animation-play-state$p を変更しても
— <a href="#animation-play-state">§ `animation-play-state^p ~prop</a>
に定義されるとおり —
%~animation は［
再生-／静止-
］されなくなる：
◎
↓</p>
		<ul>
			<li>
［
`play()$m ／ `pause()$m
］が成功裡に~callされた
◎
After a successful call to play() or pause() on a CSSAnimation, any subsequent change to the animation-play-state will no longer cause the CSSAnimation to be played or paused as defined in § 4.5 The animation-play-state property.
</li>
			<li>
<p>
［
`reverse()$m が成功裡に~callされた ／ `startTime$m が成功裡に設定された
］結果として、
%~animation の`再生-状態$が，他から`静止中$iに, またはその逆に変化した
◎
After a successful call to reverse() on a CSSAnimation or after successfully setting the startTime on a CSSAnimation, if, as a result of that call the play state of the CSSAnimation changes to or from the paused play state, any subsequent change to the animation-play-state will no longer cause the CSSAnimation to be played or paused as defined in § 3.5 The animation-play-state property.
</p>

<p class="note">【！ class="note" 追加】
変化の要件を`静止中$iとの行き来に限ることは、
次を確保する
⇒
%~animation が`稼働中$iにあるときは、
`reverse()$m を~callしても, `startTime$m を設定しても，
%~animation は `animation-play-state$p における変化を観測し続ける
◎
The requirement for a change to or from the paused play state ensures that even after calling reverse() or setting the startTime on a running animation, the animation continues to observe changes in animation-play-state.
</p>
			</li>
		</ul>
	</li>
	<li>
%~animation の `effect$m が［
~NULL ／ %~keyframe効果 以外の何らかの `AnimationEffect$I
］に成功裡に設定されて以降は、［
`animation-name$p, `animation-play-state$p
］以外の各種~animation~propを変更しても，
%~animation には反映されなくなる。
同様に，合致している `keyframes$at 規則に対する変更も，
%~animation には反映されなくなる。
ただし，最後に合致している `keyframes$at 規則が除去された場合、
%~animation は 依然として取消されるモノトスル。
◎
After successfully setting the effect of a CSSAnimation to null or some AnimationEffect other than the original KeyframeEffect, all subsequent changes to animation properties other than animation-name or animation-play-state will not be reflected in that animation. Similarly, any change to matching @keyframes rules will not be reflected in that animation. However, if the last matching @keyframes rule is removed the animation must still be canceled.
</li>
</ul>

<p class="note">注記：
上の規則における “成功裡” （に~callされた, 等）は、
次を確保するために必要とされる
⇒
当の~methodや設定子から例外が投出されたときは、
それらによる［
挙動の上書き
］は`適用されない^em
◎
Note, the reference to a successful call in the above rules is necessary to ensure that when an exception is thrown by any of these methods, the override behavior is not applied.
</p>

		<section id="owning-element-section">
<h3 title="Owning element">2.1. 所有している要素</h3>

<p>
`animation-name$p ~propが適用され，~animationを生成した［
要素／疑似要素
］は、
その~animationを
`所有している要素@
と呼ばれる。
◎
The owning element of an animation refers to the element or pseudo-element to which the animation-name property was applied that generated the animation.
</p>

<p>
~animationが［
この仕様が定義する~markup【すなわち，各種~animation~prop宣言】を利用して生成されていて、
それを`所有している要素$の `animation-name$p ~propの算出d値が後で更新されたことにより，その~markupから切離された
］場合、
~animationは，`所有している要素$から切離される
（すなわち、それ以降，~animationを所有している要素は無い）。
◎
If an animation generated using the markup defined in this specification is later disassociated from that markup by an update to the computed value of the animation-name property on the owning element, the animation is disassociated from its owning element (that is, it has no owning element from that point forwards).
</p>

<div class="note">
<p>注記：
下の例においては、
要素 %elem が初期~時の［
%animation を`所有している要素$
］になる。
%animation は、
%elem の `animation-name$p ~propの算出d値に対する更新-を通して，
%elem から切離される。
◎
In the example below, animation’s initial owning element is elem. animation is disassociated from element through an update to the computed value of elem’s animation-name property.
</p>

<pre class="lang-js">
%elem.style.animation = 'spin 1s';
let %animation = %elem.getAnimations()[0]; /* <span class="comment">
%animation を所有している要素は %elem
◎
animation’s owning element is elem
</span> */
%elem.style.animation = ''; /* <span class="comment">
%animation を所有している要素は もはや無い
◎
animation no longer has an owning element
</span> */
</pre>

<p>
~animationを`所有している要素$は、［
~animationに`結付けられている効果$の`~target要素$
］に等しくなることが多いが，
常にそうなるとは限らないことに注意。
この 2 つの要素が相違し得る状況を，次の例にデモる。
◎
Note that although the owning element is often equal to the target element of an animation’s associated effect, this is not always the case. The following example demonstrates some of the situations where these two elements may differ.
</p>

<pre class="lang-js">
%elem.style.animation = 'move 1s';
let %animation = %elem.getAnimations()[0];
/* <span class="comment">
%animation.`effect.target^c ~EQ %elem ~EQ %animation を所有している要素
◎
animation.effect.target == elem == animation’s owning element
</span> */

%animation.effect.target = elem2;
/* <span class="comment">
%animation.`effect.target^c ~EQ %elem2 ~NEQ %animation を所有している要素
◎
animation.effect.target == elem2 != animation’s owning element
</span> */

%animation.effect = null;
/* <span class="comment">
%animation.`effect【！?】.target^c ~EQ undefined ~NEQ %animation を所有している要素
◎
animation.effect?.target is undefined != animation’s owning element
</span> */
</pre>

</div>

		</section>
		<section id="animation-composite-order">
<h3 title="Animation composite order">2.2. ~animationの組成-順序</h3>

<p>
~markupや~interfaceから生成された`~animation$が属する`~animation~class$は、
`~CSS~animation^i とする。
◎
Animations generated from the markup defined in this specification have an animation class of ‘CSS Animation’.
</p>

<p class="trans-note">【
そのような~animationも、
単に “~CSS~animation（ `CSS Animation^en ）” と称される。
また，以下に現れる “`~CSS遷移^i（ `CSS Transition^en ）” は、
`CSS3-TRANSITIONS$r に定義される~animation／それらが属する`~animation~class$を表す。
】</p>

<p>
~CSS~animationの`組成-順序$は：
</p>

<ul>
	<li>
`所有している要素$が在るものは、
~CSS遷移よりも後, かつ［
特定の`~animation~class$に属さない~animation
］よりも前とする。
◎
CSS Animations with an owning element have a later composite order than CSS Transitions but an earlier composite order than animations without a specific animation class.
</li>
	<li>
<p>
`所有している要素$が在るものどうしは、
次に従って~sortする：
◎
Within the set of CSS Animations with an owning element, two animations A and B are sorted in composite order (first to last) as follows:
</p>
		<ul>
			<li>
`所有している要素$が相違するものどうしは、
`所有している要素$の`~tree順序$に従う。
同じ %要素 を`出自の要素$とする疑似要素どうしは、
次に挙げる順に~sortする
⇒＃
%要素,
`marker^pe,
`before^pe,
ここでは特定的に言及されない他の疑似要素 — ~Unicode符号位置の昇順で,
`after^pe,
%要素 の子
◎
If the owning element of A and B differs, sort A and B by tree order of their corresponding owning elements. With regard to pseudo-elements, the sort order is as follows:
• element
• ::marker
• ::before
• any other pseudo-elements not mentioned specifically in this list, sorted in ascending order by the Unicode codepoints that make up each selector
• ::after
• element children
</li>
			<li>
`所有している要素$も同じものどうしは、
各~animationの名前【 `animationName$m 】が，要素~上の `animation-name$p ~propの算出d値に現れる順に~sortする。
◎
Otherwise, sort A and B based on their position in the computed value of the animation-name property of the (common) owning element.
</li>
		</ul>
	</li>
	<li>
`所有している要素$が無いものどうしの順序は、
それらが`大域~animation~list$に現れる順に従う。
◎
The composite order of CSS Animations without an owning element is based on their position in the global animation list.
</li>
</ul>

<p class="issue">
これは、
遷移~用に定義された挙動から相違する。
おそらく，［
遷移, ~animation, 大域~animation~list
］の順に~sortするベキである。
その理由は、
開発者~tool等々が［
孤立な~animationや遷移を再生し直すために，それらを追い続ける
］とき，それらが概ね同じ`組成-順序$を保守するベキであることによる。
◎
This differs from the behavior defined for transitions. We should probably sort transitions first, then animation, then use the global animation list. The reason being that when developer tools etc. hang on to orphaned animations and transitions in order to replay them, they should maintain roughly the same composite order.
</p>

<p>
この仕様が定義する~markupを利用して生成された~CSS~animationは、
作成された時点では，`大域~animation~list$に`追加されない^em。
代わりに，これらの各~animationは、［
それを`所有している要素$から切離された後，`遊休中$iにある間
］は `組成-順序$は定義されず，
他へ遷移した最初の~momentで`大域~animation~list$に付加される。
◎
CSS Animations generated using the markup defined in this specification are not added to the global animation list when they are created. Instead, these animations are appended to the global animation list at the first moment when they transition out of the idle play state after being disassociated from their owning element. CSS Animations that have been disassociated from their owning element but are still idle do not have a defined composite order.
</p>

<p class="note">注記：
この挙動は、
`所有している要素$から切離された~animationは，
常に`遊休中$iになる（新たにそうなるか，そうであり続ける）事実に依拠する。
◎
Note, this behavior relies on the fact that disassociating an animation from its owning element always causes it to enter (or remain) in the idle play state.
</p>

		</section>
	</section>
	<section id="keyframes">
<h2 title="Declaring Keyframes">3. ~keyframeの宣言-法</h2>

		<section id="keyframe-processing">
<h3 title="Processing Keyframes">3.1. ~keyframeの処理-法</h3>

<p>
所与の
( ［
要素／疑似要素
］ %要素,
%要素 の `animation-name$p 値を成す %N 個目の~animation名 %名前
)
用の`~keyframe$ ~objたちは、
次に従って生成される：
◎
For a given target (pseudo-)element, element, an animation name, name, and the position of the animation in element’s animation-name list, position, keyframe objects are generated as follows:
</p>

<ol>
	<li>
<p>
%既定の計時~関数 ~LET %要素 の `animation-timing-function$p の解決d値†を成す %N 個目 の`計時~関数$
— 必要とされるなら、
~level 1 の
<a href="~CSSANIM#animation-name">§ `animation-name^p ~prop</a>
に述べられるとおり，［
値~listを繰返して，対応する %N 個目のそれを得る
］とする。
◎
Let default timing function be the timing function at position position of the resolved value of the animation-timing-function for element, repeating the list as necessary as described in CSS Animations 1 § 4.1 The animation-name property.
</p>

<p class="trans-note">【†
`解決d値$の定義~内には，この~propは言及されていないが、
`算出d値$と同じではない
（ § `animation-name^p ~propを見よ）。
】</p>

	</li>
	<li>
%既定の組成法 ~LET `replace$v
◎
Let default composite be replace.
</li>
	<li>
%~at-規則 ~LET ［
`keyframes-name$t が %名前 に合致している `keyframes$at ~at-規則
］は［
在るならば，それらのうち文書~順序で最後のもの ／
無いならば ε
］
◎
Find the last @keyframes at-rule in document order with &lt;keyframes-name&gt; matching name.
</li>
	<li>
~IF［
%~at-規則 ~EQ ε
］
⇒
~RET
— この事例では、
生成される~animationは無く，
%名前 に合致している既存の~animationは（もし在れば）取消される。
◎
If there is no @keyframes at-rule with &lt;keyframes-name&gt; matching name, abort this procedure. In this case no animation is generated, and any existing animation matching name is canceled.
</li>
	<li>
%~keyframe~list ~LET 空~list
— これは、
0 個以上の`~keyframe$からなる
◎
Let keyframes be an empty sequence of keyframe objects.
</li>
	<li>
%~animateされる~prop集合 ~LET 空~集合
— これは、
~~末端の下位prop名からなる
◎
Let animated properties be an empty set of longhand CSS property names.
</li>
	<li>
<p>
%~keyframe~block~list ~LET %~at-規則 内の `keyframe-block$t たちを，それらの`~keyframe選択子$内に指定された~offsetで安定-~sortした結果の~list
</p>

<p class="trans-note">【
`keyframe-block$t は複数個の~offset（`選択子の値$）を伴い得るので、
`keyframe-block^t を成す宣言~listは，各~offsetごとに複製した上で~listに含めることになる。
】</p>
◎
Perform a stable sort of the keyframe blocks in the @keyframes rule by the offset specified in the keyframe selector, and＼
</li>
	<li>
<p>
%~keyframe~block~list を成す
~EACH( %~keyframe~block )
に対し，逆順に：
◎
iterate over the result in reverse applying the following steps:
</p>
		<ol>
			<li>
%~keyframe~offset ~LET %~keyframe~block の`選択子の値$を範囲 0 以上 1 以下の値に換算した結果
◎
Let keyframe offset be the value of the keyframe selector converted to a value in the range 0 ≤ keyframe offset ≤ 1.
</li>
			<li>
%~keyframe計時~関数 ~LET %既定の計時~関数
◎
↓</li>
			<li>
~IF［
%~keyframe~block に妥当な `animation-timing-function$p 宣言が指定されている
］
⇒
%~keyframe計時~関数 ~SET それらのうち最後のものの値
◎
Let keyframe timing function be the value of the last valid declaration of animation-timing-function specified on the keyframe block, or, if there is no such valid declaration, default timing function.
</li>
			<li>
%~keyframe組成法 ~LET %既定の組成法
◎
↓</li>
			<li>
~IF［
%~keyframe~block に妥当な `animation-composition$p 宣言が指定されている
］
⇒
%~keyframe組成法 ~SET それらのうち最後のものの値
◎
Let keyframe composite be the value of the last valid declaration of animation-composition specified on the keyframe block, or, if there is no such valid declaration, default composite.
</li>
			<li>
%~keyframe計時~関数 を正準的な形に変換する（例： `step-end$v は `steps(1, end)^v になるよう）
◎
After converting keyframe timing function to its canonical form (e.g. such that step-end becomes steps(1, end))＼
</li>
			<li>
<p>
%~keyframe ~LET 
%~keyframe~list 内に［
`~keyframe~offset$, `計時~関数$, `組成法$
］いずれも合致している`~keyframe$は［
在るならば それ／
無いならば ε
］
</p>

<p class="trans-note">【
`~keyframe$の
`組成法@
（ `composite^en ）は，
`~keyframeに特有な組成-演算~型$を指すように思われるが、
明示的に参照されていない。
】</p>
◎
let keyframe refer to the existing keyframe in keyframes with matching keyframe offset, timing function and composite, if any.
</li>
			<li>
<p>
~IF［
%~keyframe ~EQ ε
］：
</p>
				<ol>
					<li>
%~keyframe ~SET 次のようにされた新たな~keyframe
⇒＃
`~keyframe~offset$ ~SET %~keyframe~offset,
`計時~関数$ ~SET %~keyframe計時~関数,
`組成法$ ~SET %~keyframe組成法,
宣言~list ~SET 空
</li>
					<li>
%~keyframe~list に %~keyframe を前付加する
</li>
				</ol>
◎
If there is no such existing keyframe, let keyframe be a new empty keyframe with offset, keyframe offset, timing function, keyframe timing function, composite, keyframe composite, and prepend it to keyframes.
</li>
			<li>
<p>
%~keyframe~block 内の【~animate不可でない】各 宣言に次を適用した上で，その結果を成す各 宣言を %~keyframe の宣言~listに追加する：
◎
Iterate over all declarations in the keyframe block and add them to keyframe such that:
</p>
				<ul>
					<li>
各 変数~参照【 `var(…)^v 】は、
その現在の値に解決する。
◎
All variable references are resolved to their current values.
</li>
					<li>
各 `略式~prop$は、
その~~末端の`下位prop$たちに展開する。
◎
Each shorthand property is expanded to its longhand subproperties.
</li>
					<li>
各 論理-~propは、
それに`等価な物理-~prop＠~CSSWM#logical-to-physical$に変換する。
◎
All logical properties are converted to their equivalent physical properties.
</li>
					<li>
<p>
同じ名前の【！物理-】下位propに展開されるものが，複数個~現れる場合、
~source順序において最後に宣言されたものに限り追加する。
◎
For any expanded physical longhand properties that appear more than once, only the last declaration in source order is added.
</p>

<p class="note">注記：
複数の~keyframe~blockが同じ %~keyframe~offset を指定することもあり，
この~algoは これらの~blockを逆順に反復するので、
これは［
%~keyframe~offset と同じ~keyframe~offsetにて すでに追加した~prop
］は飛ばされることを含意する。
【 “（~offsetで安定-~sortした結果の）逆順”, “すでに追加した”, “~source順序において最後” の論理的な関係が よくわからない。】
◎
Note, since multiple keyframe blocks may specify the same keyframe offset, and since this algorithm iterates over these blocks in reverse, this implies that if any properties are encountered that have already added at this same keyframe offset, they should be skipped.
</p>
					</li>
					<li>
各~propの値は，その算出d値に置換する。
◎
All property values are replaced with their computed values.
</li>
				</ul>
			</li>
			<li>
%~animateされる~prop集合 に前段にて %~keyframe に追加した各 【！物理-】下位prop名を追加する
◎
Add each physical longhand property name that was added to keyframe to animated properties.
</li>
		</ol>
	</li>
	<li>
<p>
~EACH( %~offset ~IN { 0, 1 } )
に対し：
</p>
		<ol>
			<li>
%~keyframe ~LET %~keyframe~list 内に次を満たす`~keyframe$が［
在るならば それ／
無いならば ε
］
⇒
［
`~keyframe~offset$ ~EQ %~offset
］~AND［
`計時~関数$ ~EQ %既定の計時~関数
］
</li>
			<li>
~IF［
%~keyframe ~EQ ε
］
⇒
%~keyframe ~SET 次のようにされた新たな~keyframe
⇒＃
`~keyframe~offset$ ~SET %~offset,
`計時~関数$ ~SET %既定の計時~関数,
`組成法$ ~SET %既定の組成法,
宣言~list ~SET 空
</li>
			<li>
<p>
%~animateされる~prop集合 内の
~EACH( %~prop )
に対し
</p>
				<ol>
					<li>
~IF［
%~prop は %~keyframe~list 内に ある~keyframeが在って，［
その`~keyframe~offset$ ~EQ %~offset
］~AND［
%~prop は~keyframeの宣言~list内に在る
］］
⇒
~CONTINUE
</li>
					<li>
%要素 用の %~prop の`算出d値$を %~keyframe に追加する
</li>
				</ol>
			</li>
			<li>
~IF［
%~keyframe ~NIN %~keyframe~list
］~AND［
%~keyframe の宣言~listは空でない
］
⇒
%~keyframe~list に %~keyframe を追加する
— `~keyframe~offset$ ~EQ %~offset なる~keyframeのうち最後のものの直後に
</li>
		</ol>
◎
If there is no keyframe in keyframes with offset 0, or if amongst the keyframes in keyframes with offset 0 not all of the properties in animated properties are present,
• Let initial keyframe be the keyframe in keyframes with offset 0, timing function default timing function and composite default composite.
• If there is no such keyframe, let initial keyframe be a new empty keyframe with offset 0, timing function default timing function, composite |default composite, and add it to keyframes after the last keyframe with offset 0.
• For each property in animated properties that is not present in some other keyframe with offset 0, add the computed value of that property for element to the keyframe.
◎
Similarly, if there is no keyframe in keyframes with offset 1, or if amongst the keyframes in keyframes with offset 1 not all of the properties in animated properties are present,
• Let final keyframe be the keyframe in keyframes with offset 1, timing function default timing function and composite default composite.
• If there is no such keyframe, let final keyframe be a new empty keyframe with offset 1, timing function default timing function and composite default composite, and add it to keyframes after the last keyframe with offset 1.
• For each property in animated properties that is not present in some other keyframe with offset 1, add the computed value of that property for element to the keyframe.
</li>
</ol>

<p class="issue">
上の手続は、
~keyframe~blockたちを逆順に反復することを要求する。
これが要求されないよう書き直すこともできるが、
一部の際どい事例において挙動が変化する見込みが高い。
現在の実装が何を行うか, および逆順に反復する要件を除去することはアリなのか検証yするベキである。
◎
The above procedure requires iterating over keyframe blocks in reverse. It could be rewritten so this is not required but that will likely change the behavior for some edge cases. We should verify what current implementations do and possible remove the requirement to iterate in reverse.
</p>


		</section>
	</section>
	<section id="animation-definition">
<h2 title="Declaring Animations">4. ~animationの宣言-法</h2>

<p>
~CSS~animationは、［
各種 `animation-*^p ~propを利用して，~keyframeを要素に束縛する
］ことにより，定義される。
これらの~list値をとる~prop
— `animation$p `略式~prop$の`下位prop$すべて —
は、
`協調している~list~prop~group$を形成する。
`animation-name$p が，`協調している基底~list~prop$になり、
`協調される値~list$を成す各~itemは， 1 個の~animation効果の~prop群を定義する。
◎
CSS Animations are defined by binding keyframes to an element using the animation-* properties. These list-valued properties, which are all longhands of the animation shorthand, form a coordinating list property group with animation-name as the coordinating list base property and each item in the coordinated value list defining the properties of a single animation effect.
</p>

<p>
個々の `animation-*^p ~propの値どうしが どう協調するかについては、
`CSS-VALUES-4$r `§ 協調している~list値をとる~prop群＠~CSSVAL#linked-properties$
を見よ。
◎
See CSS Values 4 § A Coordinating List-Valued Properties for how the individual animation-* property values coordinate.
</p>

		<section id="animation-duration">
<h3 title="The animation-duration property">4.1. `animation-duration^p ~prop</h3>

◎名 `animation-duration@p
◎値 [ `~auto0$v | `time[0s,∞]$t ]#
◎初 `~auto0$v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 
~list
— それを成す各~itemは［
`time$t ／~keyword `~auto0$v
］
◎
list, each item either a time or the keyword ~auto
◎順 文法に従う
◎ア ~animate不可
◎表終

<p>
`animation-duration$p は、
当の`~animation$に`結付けられている効果$の`反復~所要時間$を指定する。
◎
The animation-duration property specifies the iteration duration of the animation’s associated animation effect.
</p>

<dl>
	<dt>`~auto0@v</dt>
	<dd>
時間~駆動な~animation用には、
`0s^v と等価。
◎
For time-driven animations, equivalent to 0s.
</dd>
	<dd>
`~scroll駆動な~animation$用には、［
`animation-range$p,
`animation-delay$p,
`animation-iteration-count$p
］も考慮に入れる下で［
当の時列線を延伸するために必要とされる所要時間
］と等価。
`SCROLL-ANIMATIONS-1$r
`§ 有限な時列線の計算＠~SCROLL-ANIM#finite-attachment$
を見よ。
◎
For scroll-driven animations, equivalent to the duration necessary to fill the timeline in consideration of animation-range, animation-delay, and animation-iteration-count. See Scroll-linked Animations § 4.1 Finite Timeline Calculations.
</dd>

	<dt id="valdef-animation-duration-time-0s">`time[0s,∞]$t</dt>
	<dd>
<p>
時間~駆動な~animation用には、
~animationが 1 周回を完了するまにかかる時間の長さを指定する。
負な `time$t は無効。
◎
For time-driven animations, specifies the length of time that an animation takes to complete one cycle. A negative &lt;time&gt; is invalid.
</p>

<p>
`time$t ~EQ `0s^v の場合、
初期~値と同様に，当の~animationの~keyframeには効果は無いが、
それでも，当の~animationは瞬間的に生じる：
◎
If the &lt;time&gt; is 0s, like the initial value, the keyframes of the animation have no effect, but the animation itself still occurs instantaneously.＼
</p>
		<ul>
			<li>
特定的に，［
`animationend$et, `animationstart$et【！start and end】
］~eventは発火される。
◎
Specifically, start and end events are fired;＼
</li>
			<li>
`animation-fill-mode$p に応じて：
［
`backwards$v ／ `both$v ／ `both$v
］の場合，当の~animationの［
最初の~frame／最後の~frame／最初と最後の~frame
］が［
`animation-direction$p にて定義されるとおり，
`animation-delay$p の間に表示される
］ことになる／
`~none0$v の場合，
当の~animationによる可視な効果は無い。
◎
if animation-fill-mode is set to backwards or both, the first frame of the animation, as defined by animation-direction, will be displayed during the animation-delay. After the animation-delay the last frame of the animation, as defined by animation-direction, will be displayed if animation-fill-mode is set to forwards or both. If animation-fill-mode is set to none the animation will have no visible effect.
</li>
		</ul>
	</dd>
	<dd>
`~scroll駆動な~animation$用には、
`~auto0$v として扱われる。
◎
For scroll-driven animations, treated as auto.
</dd>
</dl>

		</section>
		<section id="animation-timing-function">
<h3 title="The animation-timing-function property">4.2. `animation-timing-function$p ~prop</h3>

<p>
`animation-timing-function$p は、
各`~keyframe$に適用される`計時~関数$を
— `§ ~keyframe＠#keyframes$
にて定義されるとおり —
決定するために利用される。
◎
The animation-timing-function is used to determine the timing function applied to each keyframe as defined in § 3 Declaring Keyframes.
</p>

		</section>
		<section id="animation-iteration-count">
<h3 title="The animation-iteration-count property">4.3. `animation-iteration-count$p ~prop</h3>

<p>
`animation-iteration-count$p は、
当の`~animation$に`結付けられている効果$の`反復~回数$を指定する。
◎
The animation-iteration-count property specifies the iteration count of the animation’s associated animation effect.
</p>

		</section>
		<section id="animation-direction">
<h3 title="The animation-direction property">4.4. `animation-direction$p ~prop</h3>

<p>
`animation-direction$p は、
当の`~animation$に`結付けられている効果$の`再生~方向$を指定する。
◎
The animation-direction property specifies the playback direction of the animation’s associated animation effect.
</p>

		</section>
		<section id="animation-play-state">
<h3 title="The animation-play-state property">4.5. `animation-play-state$p ~prop</h3>

<p>
`animation-play-state$p は、
当の`~animation$を［
静止する／再生する
］ために利用される。
◎
The animation-play-state is used to pause or play the animation.
</p>

<p>
実装は、
どの時点であれ
— 当の~animationが最初に生成されたときも含め —
所与の
( `~animation$ %~animation )
に対応する `animation-play-state$p の`解決d値$が新たに：
◎
↓</p>

<ul>
	<li>
`running$v になったときは，次を走らすモノトスル
⇒
`~animationを再生する$( %~animation, `自動巻戻しあり^i )
◎
If at any time, including when the animation is first generated, the resolved value of animation-play-state corresponding to an animation is newly running, the implementation must run the procedure to play an animation for the given animation with the auto-rewind flag set to false.
</li>
	<li>
`paused$v になったときは，次を走らすモノトスル
⇒
`~animationを静止する$( %~animation )
◎
If at any time, including when the animation is first generated, the resolved value of animation-play-state corresponding to an animation is newly paused, the implementation must run the procedure to pause an animation for the given animation.
</li>
</ul>

<p>
上の要件は、
~animationの`再生-状態$が
— `§ ~animation＠#animations$
にて述べられるとおり —
~WAnim~APIにより上書きされている場合には，適用されない。
◎
The above requirements do not apply if the animation’s play state is being overridden by the Web Animations API as described in § 2 Animations.
</p>

		</section>
		<section id="animation-delay">
<h3 title="The animation-delay property">4.6. `animation-delay$p ~prop</h3>

<p>
`animation-delay$p は、
当の`~animation$に`結付けられている効果$の`開始-遅延$を指定する。
◎
The animation-delay property specifies the start delay of the animation’s associated animation effect.
</p>

		</section>
		<section id="animation-fill-mode">
<h3 title="The animation-fill-mode property">4.7. `animation-fill-mode$p ~prop</h3>

<p>
`animation-fill-mode$p は、
当の`~animation$に`結付けられている効果$の`延伸~mode$を指定する。
◎
The animation-fill-mode property specifies the fill mode of the animation’s associated animation effect.
</p>

		</section>
		<section id="animation-composition">
<h3 title="The animation-composition property">4.8. `animation-composition^p ~prop</h3>

<p>
`animation-composition$p ~propは、［
複数の~animationが同じ~propに同時に影響する場合
］に利用される`組成-演算~型$を定義する。
◎
The animation-composition property defines the composite operation used when multiple animations affect the same property simultaneously.
</p>

◎名 `animation-composition@p
◎値 `single-animation-composition$t#
◎初 `replace$v
◎適 `すべての要素$
◎継 されない
◎百 受容しない
◎算 指定された一連の~keywordからなる~list
◎
list, each item a keyword as specified
◎順 文法に従う
◎ア ~animate不可
◎表終

<pre class="prod">
`single-animation-composition@t
	= `replace$v
	| `add$v
	| `accumulate$v
</pre>

<p>
各種 値［
`replace@v ／ `add@v ／ `accumulate@v
］の意味は、
~WAnimに定義される`組成-演算~型$［
置換-型 ／ 加算-型 ／ 累積-型
］と同じとする。
`WEB-ANIMATIONS$r
◎
The values of animation-composition have the meaning defined for the corresponding values of the composite operation defined in Web Animations [WEB-ANIMATIONS].
</p>

<p>
~keyframe内に指定された `animation-composition$p は、
その~keyframe内に指定された各~prop用に
— 各~propごとに，それを指定している次の~keyframeまで —
利用する組成-演算を定義する。
◎
When specified in a keyframe, animation-composition defines the composite operation to use for each property specified in that keyframe until the next keyframe specifying each property.
</p>

<div class="example">
<p>
例えば，次の~stylesheetは、
`scale$p ~propを~targetにする 2 個の異なる~animationを定義している。
◎
For example, the following stylesheet defines two different animations targetting the scale property.
</p>

<pre class="lang-css">
@keyframes heartbeat {
  from {
    scale: 1;
    animation-timing-function: ease-out;
  }
  30% {
    scale: 1.3;
  }
}
.heartbeat {
  animation: heartbeat 0.3s 2s infinite;
}

@keyframes throb {
  50% {
    scale: 1.8;
  }
}
.icon:mouseover {
  animation: throb 0.4s add;
}
</pre>

<p>
これら 2 個の~animationが同じ要素に適用された場合，
通常は片方の~animationだけ適用されることになるが、
2 個目の~animationの `animation-composition$p に `add$v を指定した場合，
この 2 個の~animationは結合されることになる。
◎
If these two animations are applied to the same element, normally only one animation would apply, but by specifying add as the animation-composition on the second animation, the result of the two animations will be combined.
</p>

<p>
~CSS遷移 `CSS3-TRANSITIONS$r の`組成-順序$は，~CSS~animationより前なので、
次の例のように
`animation-composition$p を利用して，~CSS~animationと下層の遷移とを結合することもアリになる：
◎
Since CSS Transitions [CSS3-TRANSITIONS] have a lower composite order, it is possible to use animation-composition to combine CSS Animations with underlying transitions as in the following example.
</p>

<pre class="lang-css">
.icon {
  filter: blur(20px);
  transition: filter 0.5s;
}
.icon:hover {
  filter: blur(0px);
  animation: brightness-pulse 3s infinite add;
}

@keyframes brightness-pulse {
  0% {
    scale: 1.1;
    filter: brightness(130%);
  }
  10% {
    scale: 1;
    filter: brightness(100%);
  }
}
</pre>

<p class="issue">
これらの例の絵図を作成して、
それらがイミを成すことを検証yする。
◎
Create pictures of these examples and verify they make sense.
</p>

</div>

		</section>
		<section id="animation-timeline">
<h3 title="The animation-timeline property">4.9. `animation-timeline^p ~prop</h3>

<p>
`animation-timeline$p ~propは、
~animationとともに利用される`時列線$を定義する。
◎
The animation-timeline property defines the timeline used with the animation.
</p>

<p class="note">注記：
この仕様は、
~animation用の時列線を指定するための構文は何も導入しない
— それは、
`SCROLL-ANIMATIONS-1$r【！`SCROLL-ANIMATIONS$r】 などの他の仕様に委ねられる。
◎
Note: This specification does not introduce any syntax to specify animation timelines but instead it is up to others specifications such as Scroll-linked Animations [SCROLL-ANIMATIONS] to do so.
</p>

◎名 `animation-timeline@p
◎値 `single-animation-timeline$t#
◎初 `auto^v
◎適 `すべての要素$
◎継 されない
◎百 受容しない
◎算 ~list
— 各~itemは、
次のいずれかを与える
⇒＃
`~CSS識別子$（文字大小区別）／
~keyword `none$v ／
~keyword `auto$v
◎
list, each item either a case-sensitive css identifier or the keywords none, auto.
◎順 文法に従う
◎ア ~animate不可
◎表終

<pre class="prod">
`single-animation-timeline@t
	= auto
	| none
	| `custom-ident$t
	| `scroll()$t
	| `view()$t
</pre>


<p>
`animation-timeline$p ~propは、［
`animation-name$p, `animation-duration$p
］の様な~propに類似する
— それは， 1 個以上の値をとり、
各~値は，当の要素~上の対応する`~animation$に時列線
— <a href="~CSSANIM#animation-name">§ `animation-name^p ~prop</a>
に述べられるとおり，当の~animationに合致しておかれたそれ —
を伴わせる，追加的な挙動を授ける。
◎
The animation-timeline property is similar to properties like animation-name and animation-duration in that it can have one or more values, each one imparting additional behavior to a corresponding animation on the element, with the timelines matched up with animations as described here.
</p>

<p>
各~値の型は `single-animation-timeline$t であり、
アリな値には，次に挙げる効果がある：
◎
Each value has type &lt;single-animation-timeline&gt;, whose possible values have the following effects:
</p>

<dl class="valdef">
	<dt>`auto@v</dt>
	<dd>
当の~animationの`時列線$は、
`DocumentTimeline$I
— より特定的には，`既定の文書~時列線$ —
になる。
◎
The animation’s timeline is a DocumentTimeline, more specifically the default document timeline.
</dd>

	<dt>`none@v</dt>
	<dd>
当の~animationには、
`時列線$は結付けられない。
◎
The animation is not associated with a timeline.
</dd>

	<dt id="valdef-animation-timeline-custom-ident">`custom-ident$t</dt>
	<dd>
［
`~scroll進捗~時列線$／
`~view進捗~時列線$
］のうち［
所与の名前で参照され, かつ
この要素を視野に入れるもの
］は在る場合、
それ【それらのうち最も優先されるもの】を利用する
— `SCROLL-ANIMATIONS-1$r
`§ 有名~時列線の視野~法＠~SCROLL-ANIM#timeline-scope$
にて定義されるとおり。
◎
If a named scroll progress timeline or view progress timeline is in scope on this element, use the referenced timeline as defined in Scroll-linked Animations § 4.2 Named Timeline Scoping.
</dd>
	<dd>
他の場合、
当の~animationには`時列線$は結付けられない。
◎
Otherwise the animation is not associated with a timeline.
</dd>

	<dt id="valdef-animation-timeline-scroll">`scroll()$t</dt>
	<dd>
所与の `scroll^f 関数により指示される`~scroll進捗~時列線$を利用する。
`SCROLL-ANIMATIONS-1$r
<a href="~SCROLL-ANIM#scroll-notation">§ `scroll^f 記法</a>
を見よ。
◎
Use the scroll progress timeline indicated by the given scroll() function. See Scroll-linked Animations § 2.2.1 The scroll() notation.
</dd>

	<dt id="valdef-animation-timeline-view">`view()$t</dt>
	<dd>
所与の `view^f 関数により指示される`~view進捗~時列線$を利用する。
`SCROLL-ANIMATIONS-1$r
<a href="~SCROLL-ANIM#view-notation">§ `view^f 記法</a>
を見よ。
◎
Use the view progress timeline indicated by the given view() function. See Scroll-linked Animations § 3.3.1 The view() notation.
</dd>
</dl>

<p class="issue">
［
`animation-timeline$p が指定されていないとき，
`animation-name$p を利用して時列線を選定する
］ことを もっと容易にする
— ［
最も共通的な~animationが，単純かつ人に易しくなる
］よう，［［
~animationが［
~keyframeたち, 時列線
］どちらにも同じ名前を利用すること
］を可能化するよう，時列線を選定すること
］を［
`animation-name$p に許容する
］ことにより。
`animation-timeline$p ~propが、［
必要とされるなら，［
~keyframeたち, 時列線
］を独立に選定する
］ための追加的な制御を作者に与える。
◎
Make it easier to use animation-name to select the timeline when animation-timeline is not specified. Allowing animation-name to be used for selecting timeline enables most common animations to have to use a single name for both their keyframes and timeline which is simple and ergonomics. The animation-timeline property gives authors additional control to independently select keyframes and timeline if necessary.
</p>

<p>
複数の `animation-*^p ~propが同時に設定されたときは、
`animation-timeline$p が，最初に更新される。
なので、
例えば `animation-play-state$p に対する変更は，
`animation-timeline$p にて指定された［
同時に適用される時列線
］に適用される。
◎
When multiple animation-* properties are set simultaneously, animation-timeline is updated first, so e.g. a change to animation-play-state applies to the simultaneously-applied timeline specified in animation-timeline.
</p>

		</section>
		<section id="animation-shorthand">
<h3 title="The animation shorthand property">4.10. `animation^p 略式~prop</h3>

<p>
`animation$p 略式~propの構文は、
次に従う
【ように，~level 1 から更新された（ `single-animation-timeline$t が追加された）】
：
◎
The animation shorthand property syntax is as follows:
</p>

<pre class="prod">
`single-animation@t
	= `time[0s,∞]$t
	|| `easing-function$t
	|| `time$t
	|| `single-animation-iteration-count$t
	|| `single-animation-direction$t
	|| `single-animation-fill-mode$t
	|| `single-animation-play-state$t
	|| [`none^v | `keyframes-name$t ]
	|| `single-animation-timeline$t
</pre>

		</section>
	</section>
	<section id="events">
<h2 title="Animation Events">5. ~animation~event</h2>

		<section id="event-dispatch">
<h3 title="Event dispatch">5.1. ~eventの配送-法</h3>

<p class="note">注記：
~WAnim~API `WEB-ANIMATIONS$r を利用して~animationが［
~seekされる／逆再生されている
］可能性を織り込むため、
この節の記述は，この仕様の~level 1 `CSS3-ANIMATIONS$r による~event配送-法より一般的である。
◎
Note, this is a more general description of event dispatch than that of CSS Animations Level 1 [CSS3-ANIMATIONS] since it must account for the possibility of animations being seeked or reversed using the Web Animations API [WEB-ANIMATIONS].
</p>

<p>
~CSS~animation~event用の`~target$は、
当の~animationを`所有している要素$になる。
`所有している要素$は無い場合、
配送される~CSS~animation~eventも無い
（それでも、
~WAnimに定義される`~animation再生~event$は，
対応している `CSSAnimation$I ~objに向けて配送されるが）。
◎
The target for a CSS animation event is the animation’s owning element. If there is no owning element, no CSS animation events are dispatched (although the animation playback events defined in Web Animations are still dispatched at the corresponding CSSAnimation object).
</p>

<p>
どの~eventを配送するか決定する目的においては、
~WAnim~modelにて定義される
`各種 相＠~WANIM#animation-effect-phases-and-states$が利用される。
相は，`~animation効果$に対し定義されるが、
~eventを配送する目的においては，~CSS~animationはそれに`結付けられている効果$と同じ相にあると見なされる。
例えば，所与の~CSS~animationは、
それに`結付けられている効果$は`事前~相$iにあるならば，`事前~相$iにあるとする。
◎
For the purpose of determining which events to dispatch, the phases defined in the Web Animations model are used. These definitions apply to an animation effect, however, for the purpose of dispatching events, we consider a CSS Animation to have the same phase as its associated effect. For example, a CSS Animation is in the before phase if its associated effect is in the before phase.
</p>

<p>
`結付けられている効果$が無い~CSS~animationの相は、
その`現-時刻$に応じて［
`未解決$ならば`遊休~相$i ／
0 未満ならば`事前~相$i ／
~ELSE_ `事後~相$i
］にあるものと見なされる。
◎
A CSS Animation that does not have an associated effect is considered to be in the idle phase if its current time is unresolved, in the before phase if its current time is less than zero, and in the after phase otherwise.
</p>

<p>
同様に，以下における~CSS~animationの［
`開始-遅延$,
`作動~所要時間$,
`現-反復$,
`反復~始端$,
`反復~所要時間$
］は、
当の~animationに`結付けられている効果$の各種~propを指すものと解するベキである。
◎
Similarly, subsequent references to the start delay, active duration, current iteration, iteration start, and iteration duration of a CSS animation should be understood to refer to the corresponding properties of the animation’s associated effect.
</p>

<p>
各~eventの `elapsedTime$m（`経過d時間$）を計算する際には、
次の定義が利用される：
◎
For calculating the elapsedTime of each event, the following definitions are used:
</p>

<ul>
	<li>
`区間~始端@
~EQ `max^op( `min^op( ~MINUS `開始-遅延$, `作動~所要時間$ ), 0)
◎
interval start = max(min(-start delay, active duration), 0)
</li>
	<li>
`区間~終端@
~EQ `max^op( `min^op( `結付けられている効果の終端$ ~MINUS `開始-遅延$, `作動~所要時間$ ), 0)
◎
interval end = max(min(associated effect end - start delay, active duration), 0)
</li>
</ul>

<p>
新たな`~animation~frame$が確立される各回にて配送する~event【, およびその`経過d時間$】は、
当の~animationの［
`処理待ち再生-~task$, `処理待ち静止-~task$
］は`どちらも^em ε （無い）ならば，
当の~frameを［
確立する前, 確立した後
］における~animationの相を次に従って比較することにより決定される：
◎
Each time a new animation frame is established and the animation does not have a pending play task or pending pause task, the events to dispatch are determined by comparing the animation’s phase before and after establishing the new animation frame as follows:
</p>

<div>
<table>
<thead><tr><td><td><th>確立-後
<tr><td><td><th>事前~相
<th>作動~相
<th>事後~相
<th>遊休~相
</thead><tbody>

<tr><th rowspan="4">確立-前
<th>事前~相
<td>
<td>Ss
<td>Ss, Se
<td>C

<tr><th>作動~相
<td>Es
<td>I
<td>Ee
<td>C

<tr><th>事後~相
<td>Se, Es
<td>Se
<td>
<td>

<tr><th>遊休~相
<td>
<td>Ss
<td>Ss, Se
<td>

</tbody></table>

<p id="multiple-events-note">
上の表の各欄に挙げられた記号は、
下の表に示す対応する~eventが，挙げられた順に間を置かずに配送されることを表す
（空欄は、配送される~eventは無いことを表す）。
</p>

<table>
<caption>
上の表の各欄に現れる記号の意味
</caption>
<thead><tr><th>記号
<th>配送される~event
<th>`経過d時間@
</thead><tbody>

<tr><td>Ss
<td>`animationstart$et
<td>`区間~始端$

<tr><td>Se
<td>`animationstart$et
<td>`区間~終端$

<tr><td>Es
<td>`animationend$et
<td>`区間~始端$

<tr><td>Ee
<td>`animationend$et
<td>`区間~終端$

<tr><td>C
<td>`animationcancel$et
<td>（下を見よ）

<tr><td>I
<td>`animationiteration$et
<td>（下を見よ）

</tbody></table>

◎
Change 	Events dispatched｜Elapsed time (ms)
idle or before → active｜animationstart｜interval start
idle or before → after *｜animationstart｜interval start
〃｜animationend｜interval end
active → before｜animationend｜interval start
active → active and the current iteration of the animation’s associated effect has changed since the previous animation frame｜animationiteration｜(See below) †
active → after｜animationend｜interval end
after → active｜animationstart｜interval end
after → before *｜animationstart｜interval end
〃｜animationend｜interval start
not idle and not after → idle｜animationcancel｜The active time of the animation at the moment it was cancelled calculated using a fill mode of both.
◎
* Where multiple events are listed for a state change, all events are dispatched in the order listed and in immediate succession.
</div>

<ul>
	<li>
C に対応する~eventの経過d時間は、
取消された~momentにおける~animationの`作動~時刻$として与えられ，
`延伸~mode$に `両方^i
【, および確立-前の相】
を利用する下で計算される。
◎
↑</li>
	<li>
<p id="animation-iteration-elapsed-time">
I に対応する~eventは、
~animationに`結付けられている効果$の`現-反復$が前回の`~animation~frame$から変化した場合に限り配送される。
その経過d時間は、
次に従って定義される：
◎
↑
◎
† The elapsed time for an animationiteration event is defined as follows:
</p>
		<ol>
			<li>
%前回の現-反復 ~LET 確立-前の~animation~frameにおける`現-反復$
◎
Let previous current iteration be the current iteration from the previous animation frame.
</li>
			<li>
%反復~境界 ~LET 確立-後の~animation~frameにおける`現-反復$
◎
↓</li>
			<li>
~IF［
%前回の現-反復 ~GT %反復~境界
］
⇒
%反復~境界 ~INCBY 1
◎
If previous current iteration is greater than current iteration, let iteration boundary be current iteration + 1, otherwise let it be current iteration.
</li>
			<li>
~RET ( %反復~境界 ~MINUS `反復~始端$ ) ~MUL `反復~所要時間$
◎
The elapsed time is the result of evaluating (iteration boundary - iteration start) × iteration duration).
</li>
		</ol>
	</li>
</ul>

<p>
上に定義される`経過d時間$は~milli秒数で表出されるので、
`AnimationEvent$I の `elapsedTime$m ~memberにアテガうときは，
その前に 1000 で除算して秒単位の値を生産するモノトスル。
◎
Since the elapsed time defined in the table and procedure above is expressed in milliseconds, it must be divided by 1,000 to produce a value in seconds before being assigned to the elapsedTime member of the AnimationEvent.
</p>

		</section>
	</section>
	<section id="interface-dom">
<h2 title="DOM Interfaces">6. ~DOM~interface</h2>

		<section id="the-CSSAnimation-interface">
<h3 title="The CSSAnimation interface">6.1. `CSSAnimation^I ~interface</h3>

<pre class="idl">
[`Exposed$=Window]
interface `CSSAnimation@I : `Animation$I {
  readonly attribute `CSSOMString$ `animationName$m;
};
</pre>

<dl class="idl-def">
	<dt>
`animationName@m
◎
animationName, of type CSSOMString, readonly
</dt>
	<dd>
~animationが作成された時点で，合致している［
`結付けられている効果$を定義する `keyframes$at 規則
］を見出すために利用された~keyを返す。
これは、
コレを生成させた `animation-name$p ~propの値【を成すいずれかの名前】になる。
◎
The key used to find matching keyframes rules that define the associated effect at the point when the animation was created. This is the value of the animation-name property that caused this object to be generated.
</dd>
</dl>

		</section>
		<section id="requirements-on-pending-style-changes">
<h3 title="Requirements on pending style changes">6.2. 処理待ち~style変化に対する要件</h3>

<div class="p">
<p>
様々な演算が要素~上の~propの`算出d値$に影響し得る。
~UAは、
最適化として，必要とされるまで これらの値を算出し直すのを先送りしてもヨイ。
しかしながら，次に挙げる演算は、［
算出d値に対する処理待ち変化を全部的に処理したとき
］と整合な結果を生産するモノトスル：
</p>

<ul>
	<li>
この仕様が定義する~APIに含まれる すべての演算
</li>
	<li>
~WAnim `WEB-ANIMATIONS$r に定義される演算のうち，この仕様が定義する［
~obj／~animation状態
］を返し得るもの
</li>
</ul>

◎
Various operations may affect the computed values of properties on elements. User agents may, as an optimization, defer recomputing these values until it becomes necessary. However, all operations included in programming interface defined in this specification, as well as those operations defined in Web Animations [WEB-ANIMATIONS] that may return objects or animation state defined by this specification, must produce a result consistent with having fully processed any such pending changes to computed values.
</div>

<div class="note">
<p>注記：
例えば次の~code片のように，要素 %elem に初期~時に指定された~styleが更新されたとき、
~UAは，%elem の `animation$p ~propの算出d値を計算し直すのを先送りしてもヨイ。
◎
As an example, in the following code fragment, when the specified style of elem is initially updated, a user agent may defer recalculating the computed value of the animation property.
</p>

<p>
しかしながら， %elem 上で~callされる `getAnimations()$m ~methodは、
~WAnimにより指定され，この仕様が定義する `CSSAnimation$I ~objを返し得る。
よって，この節の要件から、
~UAは
— 結果を返す前に —
%elem の `animation$p ~propの更新された値を計算してから，
要請された `CSSAnimation$I ~objを作成する必要がある。
◎
However, the getAnimations() method called on elem is specified by Web Animations and can return CSSAnimation objects as defined in this specification. Hence, as result of the requirements in this section, the user agent must calculate the updated value of elem’s animation property and create the requested CSSAnimation object before returning its result.
</p>

<pre class="example lang-js">
%elem.style.animation = 'fadeOut 1s';
%elem.getAnimations()[0].pause();
</pre>

<p>
同様に， `playState$m を読取った結果は、
処理待ち~style変化に依存し得る。
◎
Similarly, reading playState may depend on pending style changes.
</p>

<pre class="example lang-js">
%elem.style.animation = 'fadeOut 1s paused';
const %anim = %elem.getAnimations()[0];
%elem.style.animationPlayState = 'running';
console.log(%anim.playState); /* <span class="comment">
`running^l （ `稼働中$i ）になるべき。
◎
Should be 'running'.
</span> */
</pre>

</div>

		</section>
	</section>
	<section id="priv">
<h2 title="Privacy and Security Considerations">~privacyの考慮点</h2>

<p>
この仕様に対し報告された~privacyの懸念は、
無い。
◎
No privacy concerns have been reported on this specification.
</p>

	</section>
	<section id="sec">
<h2 title="Privacy and Security Considerations">~securityの考慮点</h2>

<p>
この仕様に対し報告された~securityの懸念は、
無い。
◎
No security concerns have been reported on this specification.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<dl>
	<dt id="changes-level-1">
~level 1 からの変更点
◎
9.1. Changes since CSS Animations, Level 1
</dt>
	<dd>
CSS Animations と~WAnimの相互作用を定義した。
［
`所有している要素$, ~animationの`組成-順序$
］の概念を導入した。
◎
The interaction between CSS Animations and Web Animations is defined, and the concepts of the owning element and animation composite order are introduced.
</dd>
	<dd>
~keyframe~objの生成を詳細に述べた。
◎
Generation of keyframe objects is described in detail.
</dd>
	<dd>
`animation-composition$p ~propを導入した
— それは、
複数の~animationが同じ~prop同時に影響するときに利用される組成-演算を定義する。
◎
The animation-composition property is introduced, which defines the composite operation used when multiple animations affect the same property simultaneously.
</dd>
	<dd>
`animation-timeline$p ~propを導入した
— それは、
~animationと伴に利用される時列線を定義する。
◎
The animation-timeline property is introduced, which defines the timeline used with the animation.
</dd>
	<dd>
上述した新たな~propを織り込むよう，
`animation$p 略式~propを更新した。
◎
The animation shorthand property is updated to account for these new properties.
</dd>
	<dd>
~animation~eventの配送-について述べた。
◎
Dispatch of animation events is described.
</dd>
	<dd>
`CSSAnimation$I ~interfaceを追加した。
◎
The CSSAnimation interface is added.
</dd>
	<dd>
処理待ち~style変化に対する要件を述べた。
◎
Requirements on pending style changes are described.
</dd>
</dl>

	</section>
</main></div>
