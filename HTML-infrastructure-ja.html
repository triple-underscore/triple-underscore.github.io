<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Terminology 他（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>
<style>

</style>


<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'infrastructure',
		generate: expand,
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170608 spec
}

function expand(){

	var class_map = {
		e: 'element',
		a: 'attr',
		p: 'property',
		v: 'value',
		P: 'production',
		E: 'error',
		jv: 'js-value',
		U: 'code-point',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		p: 'code',
		v: 'code',
		jv: 'span',
		P: 'code',
		dfn: 'dfn',
		i: 'i',
		U: 'span',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	break;
case 'U': // Unicode code point
	text = 'U+' + key;
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2017-10-06
trans_update:2017-09-23
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/infrastructure.html
nav_next:HTMLcms
trans_1st_pub:2016-01-28

●●original_urls
compliance-with-other-specifications:https://html.spec.whatwg.org/multipage/introduction.html
fingerprint:https://html.spec.whatwg.org/multipage/introduction.html'

●●original_id_map


●●link_map



		●idl
E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror

I.Node:~DOM4#node
I.Text:~DOM4#text
I.HTMLScriptElement:~HEscripting#htmlscriptelement
I.Document:~HTMLdom#document
文書:~HTMLdom#the-document-object
I.Screen:~CSSOMVIEW#the-screen-interface

m.elements:~HEforms#dom-form-elements
m.postMessage():~HTMLcomms#dom-window-postmessage

		●element
e.button:~HEforms#the-button-element
e.iframe:~HEembed#the-iframe-element
e.script:~HEscripting#the-script-element
e.blockquote:~HEgrouping#the-blockquote-element
e.address:~HEsections#the-address-element
e.div:~HEgrouping#the-div-element
e.b:~HEtextlevel#the-b-element
e.i:~HEtextlevel#the-i-element
e.span:~HEtextlevel#the-span-element

		●attr
a.sandbox:~HEembed#attr-iframe-sandbox
a.style:~HTMLdom#the-style-attribute

	●keywords, etc.

c.text/plain:~IETF/rfc2046#section-4.1.3
c.application/octet-stream:~IETF/rfc2046#section-4.5.1

P.Name:~TR/xml/#NT-Name
P.QName:~TR/REC-xml-names#NT-QName
P.expanded-name:~TR/1999/REC-xpath-19991116/#dt-expanded-name

	●

内容~属性:#_content-attribute
~IDL属性:#_idl-attribute

資源:#_resource

並列的:#in-parallel
即時:#immediately
並列~queue:#parallel-queue
新たな並列~queueを開始-:#starting-a-new-parallel-queue
手続きを~enqueueする:#enqueue-the-following-steps
~algo~queue:#algorithm-queue

必須の下位資源:#critical-subresources
~HTML要素:#html-elements
要素~型:#element-type
~XML互換:#xml-compatible
無視される:#ignore
文書~内に挿入された:#insert-an-element-into-a-document
文書から除去された:#remove-an-element-from-a-document

node.挿入される:#nodes-are-inserted
node.除去される:#nodes-are-removed
~liveである:#live
接続された:#becomes-connected
切断された:#becomes-disconnected
閲覧文脈に接続されて:#browsing-context-connected
閲覧文脈に接続された:#becomes-browsing-context-connected
閲覧文脈から切断された:#becomes-browsing-context-disconnected



~plugin:#plugin
保安化-:#concept-plugin-secure
	
文字~符号化方式:#encoding
符号化方式:#encoding
符号化方式~名:#encoding-name
符号化方式~label:#encoding-label
UTF-16:#utf-16-encoding

~ASCII互換:#ascii-compatible-encoding

適用し得る仕様:#other-applicable-specifications
	:#non-interactive
	:#renderingUA
	:#non-scripted
	:#conformance-checkers
	:#data-mining
	:#editors
	:#hardwareLimitations

黒地透明:#transparent-black

故意的な違反:#willful-violation
	~HTML5/introduction.html#willful-violation

~scripting~flag:~HTMLparsing#scripting-flag
文書の~outline:~HEsections#outline
適合~文書:#conforming-documents
~custom形式:~HTMLwriting#writing
~HTML構文解析器:~HTMLparsing#html-parser
~open要素~stack:~HTMLparsing#stack-of-open-elements
構文解析を停止-:~HTMLparsing#stop-parsing
文書の現在の準備度:~HTMLdom#current-document-readiness
~navi:~NAVI#navigate

	●Encoding
UTF-16BE:~ENCODING#utf-16be
UTF-16LE:~ENCODING#utf-16le

	●DOM
挿入-時の手続き:~DOM4#concept-node-insert-ext
除去-時の手続き:~DOM4#concept-node-remove-ext
~HTML文書:~DOM4#html-document
~XML文書:~DOM4#xml-document
文書~木~内:~DOM4#in-a-document-tree
接続されて:~DOM4#connected
~shadowも含む根:~DOM4#concept-shadow-including-root


	●文字列
文字大小区別:#case-sensitive
先頭一致:#prefix-match
制御~文字:~INFRA#control
~ASCII小文字~化:~INFRA#ascii-lowercase


	●HTML5
子~閲覧文脈:~BROWSERS#child-browsing-context
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
~HTML構文:~HTMLwriting#syntax
~XML構文:~HTMLxml#the-xhtml-syntax
~event-loop:~WAPI#event-loop

	●他
~list:~INFRA#list
付加-:~INFRA#list-append
~queue:~INFRA#queue
~dequeue:~INFRA#queue-dequeue
~enqueue:~INFRA#queue-enqueue

~HTML名前空間:~INFRA#html-namespace
~XML~MIME型:~MIMESNIFF#xml-mime-type
~HTML~MIME型:~MIMESNIFF#html-mime-type


●●words_table1


●●words_table



	●DOM／event
task::::タスク
handler::::ハンドラ
event::::イベント
event-loop:event loop:::イベントループ
shadow:
node::::ノード
要素:element:~
木:tree::~::ツリー
根:root::~::ルート
親:parent:~
子:child:~
子孫:descendant:~
除去-:remove:~
挿入-:insert:~
挿入:insertion:~
接続-:connect::~
切断-:disconnect::~
属性:attribute:~
文書:document:~
名前空間:namespace:~
変異-:mutate::~
継承-:inherit::~

	●UI／呈示／資源／媒体／CSS
DOM:
HTML:
HTTP:
MIME:
PDF:
XML:
XPath:
DTD:
SGML:
XSLT:
対話的:interactive::~
対話-:interact::やりとり
対話:interaction::~
UI:user interface:UI
CSS:
pixel::::ピクセル
媒体:media::~:メディア
	medium:~
寸法:dimension:~

色:color:~
視覚的:visual:~
具現化-:render:~:::レンダー
具現化:rendering:~:::レンダリング
表示:display:~
可視の:visible:~
黒地透明:transparent black:~

multimedia::::マルチメディア
pop-up-window:pop-up window:::ポップアップウィンドウ
plugin::::プラグイン
text::::テキスト
動画:video::~::ビデオ
	動画:movie
viewer::::ビューア
style::::スタイル
WYSIWYG:
呈示:presentation::~
contrast::::コントラスト
色:color:~
印刷機:printer:~:::プリンタ
媒体:media::~::メディア
媒体依存:media-independent::~::メディア依存
control::::コントロール
focus::::フォーカス
inline::::インライン
italic::::
red:
green:
blue:
alpha:
channel::::チャンネル
animation::::アニメーション
画像:image:~
動的:dynamic:~

部品:component:~
閲覧文脈:browsing context:~
本格的な:fully-fledged:~
小論:essay:~
報告書:report:~
	ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications
頭上display:overhead display:頭上 display::頭上ディスプレイ

navigate::::ナビゲート
navi:navigation:::ナビ
表現-:represent:~
表現:representation:~
資源:resource::~:リソース
下位資源:subresource::~:下位リソース
遠隔操作の:remote::~::リモート

	●構文
Unicode:
ASCII:
open
open::::
stack::::スタック
文字:character:~
文字列:string:~
文字大小区別:case-sensitive:~
小文字:lowercase:~
	文字大小区別の有無:case-sensitivity
符号位置:code point::~
	符号:sign

構文:syntax::~::シンタックス
直列化-:serialize::~::シリアル化
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ

符号化方式:encoding::~::エンコーディング
label::::ラベル
復号-:decode::~::デコード
合致-:match:~
生成規則:production:~
生成-:generate:~
生成器:generator::~::ジェネレータ
生産-:produce:~
展開-:expand:~
展開:expansion:~
宣言-:declare:~
宣言:declaration:~
tag::::タグ
式:expression::~
成功裡:successful:~
接頭辞:prefix:~
	MARK
	UTF-16
	UTF-8

	●処理
	multitasking, fibers, threads, processes
	hyperthread, core, CPU, machine
instance::::インスタンス
	instance化:instantiate
snapshot::::スナップショット
interface::::インタフェース
live::::
obj:object:::オブジェクト
logic::::ロジック
algo:algorithm:::アルゴリズム
call::::
script::::スクリプト
scripting::::スクリプト処理
処理-:process:~
処理:processing:~

変換-:convert:~
変換器:converter:~
動作-:act:~
協調的:cooperative:~
変更-:change:~
変更:changes:~
変化:changes:~
変化-:change:~

再開-:resume:~
呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
被呼出時:被 invoke 時:~
取得子:getter:~
設定子:setter:~
設定-:set:~
走って:run して:~
走らせ:run し:~
走らす:run する:~
走る:run する:走る
	返す:return:~
並列的:parallel::~
並列:parallel::~
並列処理:parallelism::~
即時:immediate::~
同時的:simultaneous:~
競合:race condition::~
	競合:race
queue::::キュー
enqueue::::エンキュー
dequeue::::デキュー
promise:
却下-:reject::~
解決-:resolve::~
loop:::ループ
undefined:
開始-:start:~
中断-:interrupt:~
新たな:new:~
	新たに:newly:~

演算-:operate:~
演算:operation:~
	~~起動-:launch:~
中止-:abort:~
停止-:stop:~
完了-:complete:~
実行-:execute:~
実行:execution:~
不能化-:disable:~
投出:throw:~
構築-:construct:~
演算-:operate:~
入力:input:~
出力:output:~
所与の:given:与えられた
例外:exception::~
初期:initial:~
	~~同時並行的:, at the same time
継続的:continuous:~

	●仕様／適合（動詞
access::::アクセス
support::::サポート
依存-:depend:~
依存関係:dependencies:~
利用-:use:~
利用:use:~
利用者:user:~
尊守-:honor:~
提供-:provide:~
無視-:ignore:~
禁制-:prohibit:~
移行:migration:~
見なし:consider し:~
見なさ:consider さ:~
達成-:achieve:~
同意-:agree:~
伝達-:convey:~
忌避-:discourage:~
矛盾-:contradict:~
示唆-:suggest::~
保全-:preserve:~
句され:phrase され:記され
作者:author:~
著作者:author:~
著作-:author:~
著作:authoring:~
主張-:claim:~
予期-:expect:~
期待-:expect:~
仕事:work:~
働く:work する:~
免除-:exempt:~
処理-:process:~
処理:processing:~
処理器:processor::~::プロセッサ
制約:restriction:~
取扱う:handle する:取り扱う
取扱われ:handle され:取り扱われ
可読性:readability:~
変更点:changes:~
奨励-:encourage:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
実装者:implementor:~
影響-:affect:~
往来-:round-trip:~
意味-:mean:~
意味:meaning:~
導入-:introduce:~
拡張:extension:~
拡張-:extend:~
拡張性:extensibility:~
指名-:designate:~
指定-:specify:~
挙動:behavior:ふるまい
	behavior
提供0-:offer:提供
推定-:infer:~
援助-:aid:~
改善-:improve:~
既存の:existing:~
既定:default:~:::デフォルト
	既定~法:defaulting
既定の:default:~:::デフォルト
定めら:state さ:~
検査:check:~
検査器:checker:~
検出-:detect:~
検証器:validator:~
検証-:validate:~
検証0-:verify:検証
決定-:determine:~
	決定-法:determining
準拠-:comply:~
準拠性:compliance:~
相互作用-:interact:~
相互作用:interaction:~
相互運用性:interoperability:~
相違:difference:~
	外され:omit:~
結付けら:associate さ:~
自動化-:automate:~
自動的:automatic:~
要件:requirements:~
要求-:require:~
見做され:assume され:~
動機:motivation:~
	motivated
解さな:understand しな:~
解釈-:interpret:~
解釈:interpretation:~
許容-:allow:~
証明-:prove:~
	認める:recognize する:~
誤用-:misuse:~
説明-:explain:~
軽減-:mitigate:~
違反-:violate:~
違反:violation:~
違反行為:transgressions:~
適合-:conform:~
適合性:conformance:~
適合:conforming:~
	適合しない:non-conforming／non-conformant
	適合しなくなる:causes the non-conformance
適合性:conformance:~
適用-:apply:~
	適用し得る:applicable:~
選好-:prefer:~
開発:development:~
関係-:relate:~
関係性:relationship:~
含意-:imply:~
欠く:lack する:~
述べる:describe する:~
述べら:describe さ:~
欲-:desire:~
決めた:decide した:~
収まる:fit する:~
言及-:mention:~
意図-:intend:~
意図:intent:~
組込みの:built-in:~
上書き:override:~
競合-:conflict:~
依拠-:rely:~
理解:understand:~
有用:useful:~
	知-:know
	知識を有さない:unbeknownst
	称され:refer
	課す:impose
	扱う:treat
	前述の:aforementioned
	opt to
	判断する:judgement:~
	選ぶ際の判断材料:make informed choices 
	~~不足
	最大限に活用する:making liberal use of
	~~悪化-:reduce
	利用者~層の細分化を招くfragments the user base
	互いに重なり合う:overlapping
	~~分類される:category／fall into
	種類に分けられる:fall into 〜 categories
	でき得る限り努める:best effort attempt
	大別され:come in two broad varieties
	:left off
	:opt to
	-:meant
	できなく:prevent
	:said
	:say

	●仕様／適合
API:
UA:user agent:UA
model::::モデル
app:application:::アプリ
platform::::プラットフォーム
proprietary::::プロプライエタリ
応用:application:::~
data-mining:data mining:::データマイニング
junk::::ジャンク
browser::::ブラウザ
tool::::ツール
vendor::::ベンダ
version::::バージョン
system::::システム
comment::::コメント
community::::コミュニティ
custom::::カスタム
一般:general:~
主体:party:~
側面:aspect:~
制御:control:~
危険に:dangerous に:~
可用:available:~
各種用語:terminology:~
用語:term:~
多義的:ambiguous:~
	容易:ease:~
手段:means:~
手続き:steps:~
段:step:~
明瞭:clear:~
概して:typical に:~
正確:exact:~
標準:standard:~
機会:chance:~
正しく:correct に:~
特権:privilege:~
特色機能:feature:~
第三者主体:third-party:~
状況:situation:~
必須:critical:~
必須の:critical な:~
不可欠:integral:~
対象0:subject:対象
	conformity::::
皆:everyone:~
正当:legitimate:~
	legitimate
	effort::::
区別:distinguish:~
事例:case:~
類別:class:~
故意的な:willful:故意による
任意選択:option::~::オプション
不十分:insufficient:~
	不可能:impossible:~
	可能:possible
中立的:neutral:~
互換:compatible:~
	-compatible
互換性:compatibility:~
仕様:spec:~
仕組み:mechanism:~
代表的:typical:~
処理能:performance::~::パフォーマンス
判定基準:criteria:~
厳格:strict:~
問題0:matter:問題
問題:problem:~
基盤:infrastructure:~
多彩:rich:~
実際:actual:~
強く:strong に:~
情報:information:~
意味論:semantics:~:::セマンティクス
意味論上の:semantic:~:::セマンティックな
意味論的:semantical:~:::セマンティック的
措置:measure:~
方式:manner:~
旧来の:legacy:~
明示的:explicit:~
暗黙的:implicit:~
	最善:best:~
本当に:real に:~
概念:concept:~
機械的に:machine で:~
機能性:functionality:~
活動:activity:~
無関係:irrelevant:~
特定0の:particular:ある特定の
特定の:specific:~
特有の:-specific な:~
特有:-specific:~
	特に:specifically
	特段の注意を払う:take extreme care:
特色機能:feature::~::フィーチャ
理由:reason:~
目的:purpose:~
精確:precise:~
純粋:pure:~
素材:material:~
緊急の:emergency:~
自由:free:~
規則:rule:~
規範的:normative:~
視覚的:visual:~
適切:appropriate:~
関連する:relevant な:~
非互換:incompatible:~
範囲0:extent:範囲
	し得るまでの範囲0:same extent
体験:experience:~
段落:paragraph:~
極端:extreme:~
仕方:way:~
能力:capability:~
	能力を有する:capable of
状況下:circumstances:~
解消-:solve:~
	その限りにおいて:As far as conformance goes
	別の仕方で記すなら、:To put it another way
	好きに:please
	必要性:needs:~
	必要-:need
	必要とされ:necessarily
	一方で、:On the other hand
	べき:should
	例:example
	例えば:for instance
	例えば:say
	:retrieve
	-:accurate
	関わらず:regardless
	しかしながら，:however
	したがって:therefore
	にあたっては、:In terms of
	つつ／依然として:still
	場合によっては:possibly
	決して:never
	人:human
	注記
	に~~識別され:label
	対照的に:By contrast
	様々な:wide variety
	あいにく:unfortunately
	ことになる:ends up
	〜易く:easy
	重きを置く:great for
	したとする:imagine
	策定:solution
	難が生じる:suffers from

	●privacy／保安
DOS:denial-of-service:DOS
環境:environment:~
再帰:recursion:~
脆弱性:vulnerabilities:~
保安:security::~:セキュリティ
地域時間帯:time zone::~
最大深さ:maximum depth:~
list::::リスト
memory::::メモリ
保安化-:secure に::~:セキュア化
攻撃:attack:~
防護-:guard:~
枯渇:running out:~
対処-:work around:~
一意:unique:~
識別-:identify:~
識別子:identifier:~
防止-:prevent:~
拘束-:constrain:~
制限-:limit:~
制限:limitation:~

指紋収集:fingerprinting::~
	fingerprinting vector:指紋収集の~~手段
指紋収集-:fingerprint::~
privacy::::プライバシー
懸念:concern:~
sandbox::::サンドボックス

site::::サイト
直接的:direct:~
通信:communication::~
通信-:communicate::~
	一見すると:at first glance
~~新たな道を開く:open a new way
実施:practice:~
	登場以前から:predate
存在-:exist:~
埋込んで:embed して::埋め込んで
送信-:send:~
server::::サーバ
	~server側:server-side
	既知の:known な
cross-site::::サイト間
要請:request::~::リクエスト
交換-:exchange:~
起動-:initiate:~
技法:technique:~
来訪者:visitor:~
根本的:fundamental:~
尊重-:respect:~
信用-:trust:~
訪問-:visit:~
避ける:avoid する:~
避けら:avoid さ:~

	●未分類（動詞

共有-:share:~
内側:inside:~
内容:content:~
包含-:contain:~
増やす:increase する:~
比較-:compare:~
比較:comparison:~
構造:structure:~
登録-:register:~
	登録-済み:registered
	渡-:pass:~
	-:past する
作成-:create:~
提出-:submit::~
置換-:replace:~
出現-:appear:~
入子:nesting:入れ子
引用-:quote:~
引用:quote:~
設定群:settings::~
形成-:form:~
更新-:update:~
編集-:edit:~
編集:editing:~
見出され:find され:~
見出した:find した:~
追加-:add:~
追加の:additional:~
選択-:select:~
変形-:transform::変換
変形:transformation::変換
変形結果:transformation::変換結果
付加-:append:~
	-:informed
	生じ:occur
	表す:express
	返す:return
	追い:follow
	除-:except
	書-:write
	置く:put
	対応-:correspond
	与-:give:~
	あてがわれ:assign
	:having
	含-:include
	含めて:including
	対応-:correspond
	指す:refer する
	数えら:count
	示す:show
	置いた:put

	●未分類
IDL:
JS:JavaScript
Web:
	-:basis
block::::ブロック
byte::::バイト
error::::エラー
editor::::エディタ
	erron含みの:erroneous
flag::::フラグ
flow::::フロー
form::::フォーム
level::::レベル
markup::::マークアップ
node-test:node test:::ノードテスト
outline::::アウトライン
program::::プログラム
session::::セッション
source::::ソース
template::::テンプレート
browser::::ブラウザ
data::::データ
file::::ファイル
下層の:underlying:~
prop:property:::プロパティ
method::::メソッド
hyperlink::::ハイパーリンク
metadata::::メタデータ
mode::::モード
pattern::::パタン
web:
	part
	time
software::::ソフトウェア
stream::::ストリーム
battery-life:battery life:::バッテリ寿命
局所:local::~::ローカル
文脈:context:~
名:name:~
値:value:~
型:type:~
空:empty:~
集合:set:~
単純:simple:~
圧縮:compression:~
外部:external:~
引数:argument:~
形式:format:~:::フォーマット
	後続の:subsequent:~
	:place
	時間を共有する:time-sharing
等価:equivalent:~
精確:precise:~
言語:language:~
長さ:length:~
増分的:incremental:~
無作為な:random:~
配列:array::~
準備度:readiness::~
不透明:opaque:~
内容:content:~
単純:simple:~
名:name:~
名前:name:~
値:value:~
型:type:~

	場所-:place:~
局所:local::~::ローカル
構造:structure:~
	きちんと構造~化された:well-structured
状態:state:~
連絡先:contact::~
静的:static::~
頁:page:::ページ
閲覧文脈:browsing context::~
文脈:context::~

	●指示語
新たな:new:~
一定の:certain:~
現在:currently:~
現在の:current:~
現在の:current:~
全部的:full:~
一時的:transient:~
	介:via
	-:second
	-:themselves
	2 個／二つ:two
	2 回:twice
	:respectively
	もある:sometimes
	一部の:some
	:using
	oldParent
	qualified
	~~選択的に組み込める:opt
	〜に基づく:based
	〜の代わりに:instead
	ある種の:certain
	いくつかの:several
	およそ:likely
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	それら:they
	それら:their／those／them
	まったく:whatsoever
	まるごと:entirely
	一部:part of
	上:above
	下:below
	与-:give
	両者:both
	今や:now
	他の:other
	他の場合:otherwise
	以前の:previous
	任意の:arbitrary
	何か:something
	元の
	旧:old
	全く:quite／at all
	別の:another
	別個の:distinct
	前者／:former:~
	各:each
	同じ:same
	同様に:similarly
	多い:often
	少数:few
	常に:always
	後:after
	後者:
	最初の:first
	異なる:different
	短い:short
	等々:etc
	節:section
	片:fragment
	一節:section
	一員:a member
	結果:result
	自身:itself
	複数の:multiple
	逆に:as opposed to
	間:between
	前:before
	順々に:in series
	一連の:series of
	何も〜ない:nothing


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
Common infrastructure 章の
<a href="~SPEC_URL">Terminology その他</a>
の節を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header id="head">
	<hgroup>
<h1>各種用語 — Terminology</h1>

	</hgroup>
</header>

<main id="MAIN" style="display:none;">

			<section id="compliance-with-other-specifications">
<h3 title="Compliance with other specifications">1.7.2. 他の仕様への準拠性</h3>

<p class="trans-note">【
編集の都合により、原文の Introduction 章の一部をここに述べる。
】</p>

~INFORMATIVE

<p>
この仕様は、様々な他の仕様と相互作用し, それらに依拠する。
あいにく，ある種の状況下においては、競合する必要性を満たすため，この仕様は 他の仕様が課す要件に違反せざるを得なくなっている。
そのような違反行為が生じる各所には、
`故意的な違反@
と記され，その理由が注記される。
◎
This specification interacts with and relies on a wide variety of other specifications. In certain circumstances, unfortunately, conflicting needs have led to this specification violating the requirements of these other specifications. Whenever this has occurred, the transgressions have each been noted as a "willful violation", and the reason for the violation has been noted.
</p>

			</section>
		<section id="fingerprint">
<h2 title="Privacy concerns">1.10. ~privacy上の懸念</h2>

<p class="trans-note">【
編集の都合により、原文の Introduction 章の一部をここに述べる。
】【
この節の，次の段落より前の内容は、未訳（
<a href="https://momdo.github.io/html/introduction.html#fingerprint">他サイトによる訳</a>
）。
】</p>

~INFORMATIVE

<p>
~FINGERPRINTING
この仕様における，
<dfn id="fingerprinting-vector">利用者を指紋収集するために利用できる</dfn>
特色機能には、この段落に示される印が付与される。
◎
Features in this specification which can be used to fingerprint the user are marked as this paragraph is.
(This is a fingerprinting vector.)
</p>

<p>
次に挙げるものに止まらず，同じ目的に利用できる特色機能は、~platformにいくつもある：
◎
Other features in the platform can be used for the same purpose, though, including, though not limited to:
</p>

<ul>
	<li>
~UAがどの特色機能を~supportしているかの，正確な~list。
◎
The exact list of which features a user agents supports.
</li>
	<li>
~scriptの再帰に許容される，~stackの最大深さ。
◎
The maximum allowed stack depth for recursion in script.
</li>
	<li>
利用者の環境を述べるような特色機能
— 例： Media Queries `MQ$r ／ `Screen$I ~obj `CSSOMVIEW$r 。
◎
Features that describe the user's environment, like Media Queries and the Screen object. [MQ] [CSSOMVIEW]
</li>
	<li>
利用者の地域時間帯。
◎
The user's time zone.
</li>
</ul>

			<section id="fingerprint-postMessage">
<h3 title="Cross-site communication">1.10.1. ~cross-site通信</h3>

<div class="p">
<p>
`postMessage()$m ~APIは、 2 つの~siteが直接的に通信できるような仕組みを提供する。
これは、一見すると，上に述べた問題が生じ得るような~~新たな道を開くものに思えるかもしれない。
しかしながら，実施においては、この~APIの登場以前から， 2 つの~siteが通信できるような仕組みは複数~存在する：
</p>
<ul ><li>別~siteを埋込んでいる~siteは、 `iframe$e 要素の寸法を介して，~dataを送信できる。
</li><li>~siteは、［
~serverに既知の一意な識別子
］を伴わせた ~cross-site画像~要請を利用して，~server側~data交換-を起動できる。
</li><li>2 つの~siteは、~~実際に上に述べた指紋収集~技法を用いて 来訪者を一意に識別してから，~server側で情報を交換できる。
</li></ul>

◎
The postMessage() API provides a mechanism by which two sites can communicate directly. At first glance, this might appear to open a new way by which the problems described above can occur. However, in practice, multiple mechanisms exist by which two sites can communicate that predate this API: a site embedding another can send data via an iframe element's dimensions; a site can use a cross-site image request with a unique identifier known to the server to initiate a server-side data exchange; or indeed the fingerprinting techniques described above can be used by two sites to uniquely identify a visitor such that information can then be exchanged on the server side.
</div>

<p>
根本的に、自身の情報を~siteが尊重して扱うものと信用しない利用者は，その~siteの訪問-を避けるよりない。
◎
Fundamentally, users that do not trust a site to treat their information with respect have to avoid visiting that site at all.
</p>

			</section>
		</section>

	<section id="infrastructure">
<h1 title="Common infrastructure">2. 共通基盤</h1>

		<section id="terminology">
<h2 title="Terminology">2.1. 各種用語</h2>

<p>
この仕様は、同じ文脈~内で［
~HTML／~XML
］属性, および~IDL属性（ ~IDL~interfaceに定義される属性）の両者を指すことが多い。
どちらを指すか明瞭でない所では、［
~HTML／~XML
］属性を指すときは
`内容~属性@
と記され、~IDL属性を指すときは
`~IDL属性@
と記される。
同様に、用語 “~prop” も［
~JS~obj~prop, ~CSS~prop
］の両者に利用される。
多義的になる所では、順に
`~obj~prop^dfn,
`~CSS~prop^dfn
と記される。
◎
This specification refers to both HTML and XML attributes and IDL attributes, often in the same context. When it is not clear which is being referred to, they are referred to as content attributes for HTML and XML attributes, and IDL attributes for those defined on IDL interfaces. Similarly, the term "properties" is used for both JavaScript object properties and CSS properties. When these are ambiguous they are qualified as object properties and CSS properties respectively.
</p>

<p>
仕様にて，ある特色機能を［
`~HTML構文$, `~XML構文$
］のいずれかに適用するよう定められる所では、一般に，他方も含まれる。
特色機能を，この二つの言語の片方にのみ特に適用する所では、次のように，他方の形式には適用されないものと定められる
⇒
“~HTML に対しては、 ... （これは~XMLには適用されない）”。
◎
Generally, when the specification states that a feature applies to the HTML syntax or the XML syntax, it also includes the other. When a feature specifically only applies to one of the two languages, it is called out by explicitly stating that it does not apply to the other format, as in "for HTML, ... (this does not apply to XML)".
</p>

<p>
この仕様における用語
<dfn>文書</dfn>
は、~HTMLの~~任意の利用を指す
— 短い静的な文書から 多彩な~multimediaを伴う長い小論や報告書，更には本格的な対話的~appまでににわたるような。
この用語は、文脈に依存して［
`Document$I ~objとその 子孫~DOM木,
］, ［
`~HTML構文$ ／ `~XML構文$ を利用して直列化された~byte~stream
］のいずれかを指す：
◎
This specification uses the term document to refer to any use of HTML, ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications. The term is used to refer both to Document objects and their descendant DOM trees, and to serialized byte streams using the HTML syntax or the XML syntax, depending on context.
</p>

<ul>
	<li>
~DOM構造の文脈における用語
`~HTML文書$ ／ `~XML文書$
は、~DOM仕様 `DOM$r にて定義される，二つの異なる~modeを指す。
`文書$は、このいずれかの~mode下に属する。
（そのような利用は、常にその定義に~hyperlinkされる）
◎
In the context of the DOM structures, the terms HTML document and XML document are used as defined in the DOM specification, and refer specifically to two different modes that Document objects can find themselves in. [DOM] (Such uses are always hyperlinked to their definition.)
</li>
	<li>
~byte~streamの文脈における用語［
~HTML文書 ／ ~XML文書
］は、［
`~HTML~MIME型$ ／ `~XML~MIME型$
］の資源を指す。
◎
In the context of byte streams, the term HTML document refers to resources labeled as text/html, and the term XML document refers to resources labeled with an XML MIME type.
</li>
</ul>

<hr>

<p>
~~記述を単純にするため、利用者~向けに文書を具現化する仕方を指す際に［
“示される（ shown ）” ／ “表示される（ displayed ）” ／ “可視の（ visible ）”
］などの語が利用されることもある。
これらの用語は、視覚的~媒体のみを含意するものではなく、他の媒体にも，等価な仕方で適用されるものと見なされ~MUST。
◎
For simplicity, terms such as shown, displayed, and visible might sometimes be used when referring to the way a document is rendered to the user. These terms are not meant to imply a visual medium; they must be considered to apply to other media in equivalent ways.
</p>

<p>
`黒地透明@
は、
( ~red, ~green, ~blue, ~alpha )
各~channelがすべて 0 にされた色を指す。
◎
Transparent black refers to the color with red, green, blue, and alpha channels all set to zero.
</p>


			<section id="parallelism">
<h4 title="Parallelism">2.1.1 並列処理</h4>

<p>
所与の手続きを
`並列的@
に走らすとは、その手続きを，この標準~内の他の~logicと~~同時並行的に走らすことを意味する（例えば `~event-loop$と~~同時並行的に）。
この標準は、これが達成される精確な仕組みは定義しない
— 例えば、時間を共有する協調的［
multitasking, fibers, threads, processes
］, あるいは異なる［
hyperthread, core, CPU, machine
］の利用, 等々。
対照的に、
`即時@
に走らすような演算は、現在~走っている~taskを中断して,
その演算を走らせ終えてから, 中断した~taskを再開し~MUST。
◎
To run steps in parallel means those steps are to be run, one after another, at the same time as other logic in the standard (e.g., at the same time as the event loop). This standard does not define the precise mechanism by which this is achieved, be it time-sharing cooperative multitasking, fibers, threads, processes, using different hyperthreads, cores, CPUs, machines, etc. By contrast, an operation that is to run immediately must interrupt the currently running task, run itself, and then resume the previously running task.
</p>

<p>
異なる`並列的$~algoが同じ~data上で演算するときの競合を避けるためには、`並列~queue$を利用できる。
◎
To avoid race conditions between different in parallel algorithms that operate on the same data, a parallel queue can be used.
</p>

<p>
`並列~queue@
は、［
順々に走らすことが要求される，~algo手続きたち
］からなる~queueを表現する。
◎
A parallel queue represents a queue of algorithm steps that must be run in series.
</p>

<p>
各`並列~queue$は、
`~algo~queue@
を持つ
— それは、`~queue$であり，初期~時には空とする。
◎
A parallel queue has an algorithm queue (a queue), initially empty.
</p>

<p class="algo-head">
`並列~queue$ %並列~queue に，所与の
`手続きを~enqueueする@
ときは
⇒
%並列~queue の`~algo~queue$に，その手続きを`~enqueue$する
◎
To enqueue steps to a parallel queue, enqueue the algorithm steps to the parallel queue's algorithm queue.
</p>

<p class="algo-head">
`新たな並列~queueを開始-@
するときは、次の手続きを走らす：
◎
To start a new parallel queue, run the following steps:
</p>

<ol>
	<li>
%並列~queue ~LET 新たな`並列~queue$
◎
Let parallelQueue be a new parallel queue.
</li>
	<li>
<p>
次の手続きを`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
<p>
~WHILE 無条件：
◎
While true:
</p>

				<ol>
					<li>
%手続き ~LET %並列~queue の`~algo~queue$から`~dequeue$した結果
◎
Let steps be the result of dequeueing from parallelQueue's algorithm queue.
</li>
					<li>
%手続き を走らす
（ %手続き が空なら何もしないことになる）
◎
If steps is not nothing, then run steps.
</li>
					<li>
~Assert：
%手続き を走らせても例外は投出されない
— `並列的$に走っている手続きには、投出することは許容されないので。
◎
Assert: running steps did not throw an exception, as steps running in parallel are not allowed to throw.
</li>
				</ol>

<p class="note">注記：
これは、継続的に走らす~loopとして実装することを実装に期待するものではない。
標準における~algoには、理解し易くなるよう，~battery-lifeや処理能に重きを置くことは必要とされないので。
◎
Implementations are not expected to implement this as a continuously running loop. Algorithms in standards are to be easy to understand and are not necessarily great for battery life or performance.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %並列~queue
◎
Return parallelQueue.
</li>
</ol>

<p class="note">注記：
`並列的$に走っている手続き自身も，他の手続きを`並列的$に走らすことができる。
例：
`並列~queue$の内側で、一連の段を，当の~queueにて並列的に走らすことも有用になり得る。
◎
Steps running in parallel can themselves run other steps in in parallel. E.g., inside a parallel queue it can be useful to run a series of steps in parallel with the queue.
</p>

<div class="example">

<p>
ある標準が［
`~list$ %名前~list と,
%名前 を %名前~list に追加する~method
］を定義しようとしているとする
— この~methodは、［
%名前 ~IN %名前~list
］のときは却下するとする。
◎
Imagine a standard defined nameList (a list), along with a method to add a name to nameList, unless nameList already contains name, in which case it rejects.
</p>

<p>
次のように策定した場合、競合の難が生じる：
◎
The following solution suffers from race conditions:
</p>

<ol>
	<li>
%p ~LET 新たな~promise
◎
Let p be a new promise.
</li>
	<li>
<p>
次の手続きを`並列的$に走らす：
◎
Run the following steps in parallel:
</p>

		<ol>
			<li>
~IF［
%名前 ~IN %名前~list
］
⇒＃
`TypeError$E で %p を却下する；
~RET
◎
If nameList contains name, reject p with a TypeError and abort these steps.
</li>
			<li>
（何らかの長くかかり得る仕事を行う）
◎
Do some potentially lengthy work.
</li>
			<li>
%名前~list に %名前 を`付加-$する
◎
Append name to nameList.
</li>
			<li>
`undefined^jv で %p を解決する
◎
Resolve p with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>

<p>
上の手続きを 2 回~呼出した場合， 2 つが同時的に走っている間、段 2.1 のときは %名前 は %名前~list 内にないが，段 2.3 が走る前に 他方により<em>追加されるかもしれない</em>
— その結果、 %名前~list 内に %名前 が 2 回~現れることになる。
◎
Two invocations of the above could run simultaneously, meaning name isn't in nameList during step 2.1, but it might be added before step 2.3 runs, meaning name ends up in nameList twice.
</p>

<p>
並列~queueは、これを解消する。
その標準は、`新たな並列~queueを開始-$した結果の`並列~queue$ %名前~list~queue を得ておいた上で：
◎
Parallel queues solve this. The standard would let nameListQueue be the result of starting a new parallel queue, then:
</p>

<ol>
	<li>
%p ~LET 新たな~promise
◎
Let p be a new promise.
</li>
	<li>
<p>
<mark>
%名前~list~queue に，次に与える`手続きを~enqueueする$：
</mark>
◎
Enqueue the following steps to nameListQueue:
</p>

		<ol>
			<li>
~IF［
%名前 ~IN %名前~list
］
⇒＃
`TypeError$E で %p を却下する；
~RET

◎
If nameList contains name, reject p with a TypeError and abort these steps.
</li>
			<li>
（何らかの長くかかり得る仕事を行う）
◎
Do some potentially lengthy work.
</li>
			<li>
%名前~list に %名前 を`付加-$する
◎
Append name to nameList.
</li>
			<li>
`undefined^jv で %p を解決する
◎
Resolve p with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>

<p>
上の手続きは，今や~queue内にあり、競合は避けられる。
◎
The steps would now queue and the race is avoided.
</p>
</div>

			</section>
			<section id="resources">
<h3 title="Resources">2.1.2. 資源</h3>

<p>
資源に対する用語
`~support^dfn
される, 〜されている, 〜する, 等々は、~UAの実装が当の外部~資源の意味論を復号する能力を有することを指す。
実装は、外部~資源の［
形式／型
］を，その形式／型において必須とされる側面を無視することなく処理できるならば、~supportするという。
特定の資源が~supportされるかどうかは、その資源の形式に備わる どの特色機能が利用-中にあるかにも依存し得る。
◎
The specification uses the term supported when referring to whether a user agent has an implementation capable of decoding the semantics of an external resource. A format or type is said to be supported if the implementation can process an external resource of that format or type without critical aspects of the resource being ignored. Whether a specific resource is supported can depend on what features of the resource's format are in use.
</p>

<p class="example">
例えば PNG 画像は、その~pixel~dataを復号して具現化できるならば、その画像に，実装が知識を有さない~animation~dataが包含されていたとしても、~supportされる形式と見なされるであろう。
◎
For example, a PNG image would be considered to be in a supported format if its pixel data could be decoded and rendered, even if, unbeknownst to the implementation, the image also contained animation data.
</p>

<p class="example">
実装は、 MPEG-4 動画~fileの~metadataから動画の寸法を決定できたとしても，利用されている圧縮~形式を~supportしないならば、その形式を~supportするとは見なされないことになる。
◎
An MPEG-4 video file would not be considered to be in a supported format if the compression format used was not supported, even if the implementation could determine the dimensions of the movie from the file's metadata.
</p>

<p>
一部の他の仕様
— 特に~HTTP仕様 —
において `表現^i （ representation ）と称されるもの
【<a href="~RFC7231#section-3" >参照先</a>】
は、この仕様では
`資源@
と称される。
`HTTP$r
◎
What some specifications, in particular the HTTP specification, refer to as a representation is referred to in this specification as a resource. [HTTP]
</p>

<p>
資源の
`必須の下位資源@
とは、その資源を正しく処理するためには，可用になる必要がある資源である。
どの資源が必須（ critical ）と見なされるかは、当の資源の形式を定義する仕様により定義される。
◎
A resource's critical subresources are those that the resource needs to have available to be correctly processed. Which resources are considered critical or not is defined by the specification that defines the resource's format.
</p>

			</section>
			<section id="xml">
<h3 title="XML compatibility">2.1.3. ~XMLとの互換性</h3>

<p id="html-namespace">
~HTMLから~XMLへの移行を容易にするため、この仕様に適合している~UAは、少なくとも ~DOM／~CSSの目的においては，~HTML内の要素を`~HTML名前空間$（
`http://www.w3.org/1999/xhtml^l
）に属させることになる。
用語
`~HTML要素@
は、その名前空間に属する~~任意の要素を指す
— 要素が~XML文書~内にある場合でも。
◎
To ease migration from HTML to XML, UAs conforming to this specification will place elements in HTML in the http://www.w3.org/1999/xhtml namespace, at least for the purposes of the DOM and CSS. The term "HTML elements" refers to any element in that namespace, even in XML documents.
</p>


<div class="p">
<p>
他から定められない限り、この仕様に言及される：
</p>

<ul><li>どの要素も， `~HTML名前空間$に属する。
</li><li>どの属性も，属する名前空間はない。
</li></ul>

◎
Except where otherwise stated, all elements defined or mentioned in this specification are in the HTML namespace ("http://www.w3.org/1999/xhtml"), and all attributes defined or mentioned in this specification have no namespace.
</div>

<div class="p">
<p>
用語
`要素~型@
とは、［
所与の局所~名を持つ, かつ
所与の名前空間に属する
］ような要素からなる集合を指す。
例えば `button$e 要素の要素~型は `button$e であり、次を意味する：
</p>

<ul>
	<li>
その局所~名は `button^l である，かつ
</li>
	<li>
（上述にて暗黙的に定義したように） `~HTML名前空間$に属する。
</li>
</ul>

◎
The term element type is used to refer to the set of elements that have a given local name and namespace. For example, button elements are elements with the element type button, meaning they have the local name "button" and (implicitly as defined above) the HTML namespace.
</div>


<div class="p">
<p>
次を満たす属性~名は、
`~XML互換@
とされる：
</p>

<ul>
	<li>
`XML$r にて定義される `Name$P 生成規則に合致する，かつ
</li>
	<li>
`003A^U COLON (:) は包含しない。
</li>
</ul>

◎
Attribute names are said to be XML-compatible if they match the Name production defined in XML and they contain no U+003A COLON characters (:). [XML]
</div>


			</section>
			<section id="dom-trees">
<h3 title="DOM trees">2.1.4. DOM 木</h3>


<p>
要素または属性
が［
`無視される@
／
何か他の値として扱われる ／
それが他の何かであったかのように取扱われる
］ものと定められる所は、［
当の~nodeが~DOM内にある後における~nodeの処理
］のみを指す。
~UAは、そのような状況において~DOMを変異させては~MUST_NOT。
◎
When it is stated that some element or attribute is ignored, or treated as some other value, or handled as if it was something else, this refers only to the processing of the node after it is in the DOM. A user agent must not mutate the DOM in such situations.
</p>

<p>
内容~属性が所与の値 %V に
`変更される／変化した^dfn
と記されるのは、
%V が元の値と異なる場合に限られる
— 属性に その元の値と同じ値を設定しても，それは変化しない。
◎
A content attribute is said to change value only if its new value is different than its previous value; setting an attribute to a value it already has does not change it.
</p>

<p>
［
属性~値 ／
`Text$I ~node ／
文字列
］に対し利用される用語
`空^dfn
は、~textの長さが 0 であることを意味する（すなわち、 `0020^U SPACE や`制御~文字$も包含しない）。
◎
The term empty, when used for an attribute value, Text node, or string, means that the length of the text is zero (i.e., not even containing controls or U+0020 SPACE).
</p>

<p>
所与の~node %A, %B に対し：
◎
↓</p>

<ul>
	<li>
%A が %B の中へ
`挿入される@node
とは、
( ~node %A, 新たな親 %B )
を引数に`挿入-時の手続き$が呼出されることをいう。
◎
A node A is inserted into a node B when the insertion steps are invoked with A as the argument and A's new parent is B.＼
</li>
	<li>
逆に，
%A が %B から
`除去される@node
とは、
( 除去される~node %A, ~nodeの旧~親 %B )
を引数に`除去-時の手続き$が呼出されることをいう。
◎
Similarly, a node A is removed from a node B when the removing steps are invoked with A as the removedNode argument and B as the oldParent argument.
</li>
</ul>

<p>
所与の~node %N に対し：
◎
↓</p>

<ul>
	<li>
<p>
%N は
`文書~内に挿入された@
とは
⇒
%N は`文書~木~内$にない下で、
%N を引数に`挿入-時の手続き$が呼出され，
%N は`文書~木~内$にあるようになったことをいう。
◎
A node is inserted into a document when the insertion steps are invoked with it as the argument and it is now in a document tree.＼
</li>
	<li>
%N は
`文書から除去された@
とは、逆に
⇒
%N は`文書~木~内$にある下で、
%N を引数に`除去-時の手続き$が呼出され，
%N は`文書~木~内$にないようになったことをいう。
◎
Analogously, a node is removed from a document when the removing steps are invoked with it as the argument and it is now no longer in a document tree.
</li>
</ul>

<p class="trans-note">【
~nodeが元々`文書~木~内$にあったとしても，
“挿入し直される”
ような処理-時には、除去-, 挿入- 2 つの~eventが連続して生じるかもしれない。
】【
この定義が、変化させる手段も含めているのか，［
単に，状態の変化のみに基づくものであって、状態を変化させる手段は述べられたものに限られる
］ことを述べているのか、判別できない。
下の定義も同様。
】</p>


<p>
所与の~node %N に対し：
◎
↓</p>

<ul>
	<li>
%N は
`接続された@
（ becomes connected ）とは
⇒
%N は`接続されて$いない下で、
%N を引数に`挿入-時の手続き$が呼出され，
%N は`接続されて$いるようになったことをいう。
◎
A node becomes connected when the insertion steps are invoked with it as the argument and it is now connected.＼
</li>
	<li>
%N は
`切断された@
（ becomes disconnected ）とは、逆に
⇒
%N は`接続されて$いる下で、
%N を引数に`除去-時の手続き$が呼出され，
%N は`接続されて$いないようになったことをいう。
◎
Analogously, a node becomes disconnected when the removing steps are invoked with it as the argument and it is now no longer connected.
</li>
</ul>

<p class="trans-note">【
~nodeが元々`接続されて$いたとしても，
“接続し直される”
ような処理-時には、切断-, 接続- 2 つの~eventが連続して生じるかもしれない。
】</p>


<p>
所与の~node %N に対し：
◎
↓</p>

<ul>
	<li>
<p>
%N は
`閲覧文脈に接続されて@
いるとは、 %N が次を満たすことをいう：
</p>

<ul ><li>%N は`接続されて$いる~AND
</li><li>%N の`~shadowも含む根$が`属する閲覧文脈$ ~NEQ ε
</li></ul>
◎
A node is browsing-context connected when it is connected and its shadow-including root has a browsing context.＼
</li>
	<li>
%N は
`閲覧文脈に接続された@
（ becomes browsing-context connected ）とは
⇒
%N は`閲覧文脈に接続されて$いない下で、
%N を引数に`挿入-時の手続き$が呼出され，
%N は`閲覧文脈に接続されて$いるようになったことをいう。
◎
A node becomes browsing-context connected when the insertion steps are invoked with it as the argument and it is now browsing-context connected.＼
</li>
	<li>
%N は
`閲覧文脈から切断された@
（ becomes browsing-context disconnected ）とは、逆に
⇒
%N は`閲覧文脈に接続されて$いる下で、［
%N を引数に`除去-時の手続き$が呼出された
］か, または［
%N の`~shadowも含む根$が`属する閲覧文脈$ ~EQ ε
］になった結果，
%N は`閲覧文脈に接続されて$いないようになったことをいう。
◎
A node becomes browsing-context disconnected either when the removing steps are invoked with it as the argument and it is now no longer browsing-context connected, or when its shadow-including root no longer has a browsing context. 
</li>
</ul>


			</section>
			<section id="scripting-2">
<h3 title="Scripting">2.1.5. ~scripting</h3>

<p>
所与の~interface `Foo^I に対する句
“`Foo^I ~obj”
は、
“~interface `Foo^I を実装している~obj”
の略記である。
◎
The construction "a Foo object", where Foo is actually an interface, is sometimes used instead of the more accurate "an object implementing the interface Foo".
</p>

<p class="trans-note">【
`Foo^I を継承する~interfaceを実装している~objも含まれる。
】</p>


<div>
<p>
~IDL属性に対し、（例えば作者~scriptから）［
その値を得ようと／新たな値をあてがおうと
］~~試みられるときの挙動を記すときは、［
`取得子は…^dfn ／
`設定子は…^dfn
］のように表記される。
</p>

<p class="trans-note">【
“~~取得子（ ...’s getter ）” は，原文では “On getting, ...” 
（訳すなら “被取得時” ）であるが、同じ文脈で前者の getter も利用されている。
設定子（ “...’s setter” ／ “On setting, ...” ）についても同様。
~web~platform全般にわたり，この 2 種類のどちらで表記しても特に違いはない／区別を要する箇所はないと見られるので、和訳では “取得子”, “設定子” の表記に統一している。
】【
~IDL~methodにおける対応する表記（ “..., when invoked, ...” ）は、
“被呼出時には…”
と記される。
】</p>

◎
An IDL attribute is said to be getting when its value is being retrieved (e.g. by author script), and is said to be setting when a new value is assigned to it.
</div>

<p>
`~liveである@
とされた~DOM~objに対しては、その~obj上の［
属性, ~method
］は、~dataの~snapshotではなく，実際の
【すなわち，現在の】
下層の~dataに対し演算され~MUST。
◎
If a DOM object is said to be live, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data.
</p>

			</section>
			<section id="plugins">
<h3 title="Plugins">2.1.6. ~plugin</h3>

<p>
用語
`~plugin@
は、~UAが利用し, ~UAにより定義される内容~handlerであって、~UAによる`文書$の具現化の一部を成し得るが，［
`文書$の`子~閲覧文脈$として動作する
］ことも, ［
`文書$の~DOMに `Node$I ~objを導入する
］こともないものを指す。
◎
The term plugin refers to a user-agent defined set of content handlers used by the user agent that can take part in the user agent's rendering of a Document object, but that neither act as child browsing contexts of the Document nor introduce any Node objects to the Document's DOM.
</p>

<p>
そのような内容~handlerは、概して
第三者主体から提供される
— ~UAも，自身に組込みの内容~handlerを~pluginとして指名できるが。
◎
Typically such content handlers are provided by third parties, though a user agent can also designate built-in content handlers as plugins.
</p>


<p>
~UAは、~MIME型［
`text/plain$c ／ `application/octet-stream$c
］に対しては、登録-済みの`~plugin$があるものと見なしては~MUST_NOT。
◎
A user agent must not consider the types text/plain and application/octet-stream as having a registered plugin.
</p> 

<p class="example">
~pluginの一例として、利用者が~PDF~fileへ~navigateしたときに`閲覧文脈$内で~instance化される~PDF~viewerが挙げられる。
これは、~UA自身が~PDF~viewer部品を実装した主体であるかどうかに関わらず，~pluginに数えられることになる。
一方で、~UAが（自身の~UIは利用せずに，）別々の~PDF~viewer~appを~~起動させる場合、その~appは，この定義においては~pluginではない。
◎
One example of a plugin would be a PDF viewer that is instantiated in a browsing context when the user navigates to a PDF file. This would count as a plugin regardless of whether the party that implemented the PDF viewer component was the same as that which implemented the user agent itself. However, a PDF viewer application that launches separate from the user agent (as opposed to using the same interface) is not a plugin by this definition.
</p>

<p class="note">注記：
この仕様は、~pluginと対話する仕組みは定義しない
— それは［
~UA／~platform
］特有と予期されているので。
~UAには、
Netscape Plugin ~API などの~pluginを~~選択的に組み込める仕組みを~supportするものもあれば、遠隔操作の内容~変換器を利用するものや, 一定の内容~型に対しては組込みの~pluginで~supportするものもある。
~~実際、この仕様では，~UAによる~pluginの~supportは全く要求されない。
`NPAPI$r
◎
This specification does not define a mechanism for interacting with plugins, as it is expected to be user-agent- and platform-specific. Some UAs might opt to support a plugin mechanism such as the Netscape Plugin API; others might use remote content converters or have built-in support for certain types. Indeed, this specification doesn't require user agents to support plugins at all. [NPAPI]
</p>

<p>
~pluginは、 `sandbox$a 属性の意味論を尊守するならば，
`保安化-@
できる。
◎
A plugin can be secured if it honors the semantics of the sandbox attribute.
</p>

<p class="example">
例えば，保安化された~pluginは、~sandbox化された `iframe$e の内側で~instance化されたときには，その内容は~pop-up-windowを作成できなくされることになる。
◎
For example, a secured plugin would prevent its contents from creating pop-up windows when the plugin is instantiated inside a sandboxed iframe.
</p>

<p class="warning">
~browserは、`~plugin$用に意図される外部~内容と対話するときには，特段の注意を払うべきである。
第三者主体の手による~softwareを~UA自身と同じ特権で走らせた場合、その~software内の脆弱性は，~UA内のそれと同等に危険になる。
◎
Browsers should take extreme care when interacting with external content intended for plugins. When third-party software is run with the same privileges as the user agent itself, vulnerabilities in the third-party software become as dangerous as those in the user agent.
</p>

<p>
~FINGERPRINTING
利用者が有する`~plugin$の集合は利用者ごとに異なり、利用者が一意に識別されるような機会を増やすような指紋収集の~~手段を提供するので、~UAには，どの利用者に対しても 正確に同じ`~plugin$の集合を~supportすることが奨励される。
◎
Since different users having different sets of plugins provides a fingerprinting vector that increases the chances of users being uniquely identified, user agents are encouraged to support the exact same set of plugins for each user.
</p>


			</section>
			<section id="encoding-terminology">
<h3 title="Character encodings">2.1.7. 文字~符号化方式</h3>

<p>
`文字~符号化方式@（
<a href="~ENCODING#encoding">参照先</a>
）は、~byte~streamと~Unicode文字列との間で相互に変換する仕方であり，
WHATWG Encoding 標準 `ENCODING$r にて定義される。
多義的にならない所では、単に “符号化方式” とも称される。
各 `符号化方式$には、［
`符号化方式~名@（
<a href="~ENCODING#name">参照先</a>
）と 1 個以上の
`符号化方式~label@（
<a href="~ENCODING#label">参照先</a>
）
］が~~定義されている。
◎
A character encoding, or just encoding where that is not ambiguous, is a defined way to convert between byte streams and Unicode strings, as defined in the WHATWG Encoding standard. An encoding has an encoding name and one or more encoding labels, referred to as the encoding's name and labels in the Encoding standard. [ENCODING]
</p>

<p>
`UTF-16@
符号化方式とは、`符号化方式~名$が［
`UTF-16BE$, または `UTF-16LE$
］である符号化方式を指す。
`ENCODING$r
◎
A UTF-16 encoding is UTF-16BE or UTF-16LE. [ENCODING]
</p>

<p>
`符号化方式$のうち，`UTF-16$ でないものは、
`~ASCII互換@
という。
`ENCODING$r
◎
An ASCII-compatible encoding is any encoding that is not a UTF-16 encoding. [ENCODING]
</p>

<p class="note">注記：
WHATWG Encoding 標準にて定義されていない`符号化方式$に対する~supportは禁制されるので、この仕様が`~ASCII互換$でないものとして扱う必要がある符号化方式は、 `UTF-16$ に限られる。
◎
Since support for encodings that are not defined in the WHATWG Encoding standard is prohibited, UTF-16 encodings are the only encodings that this specification needs to treat as not being ASCII-compatible encodings.
</p>

			</section>
			<section id="conformance-classes">
<h3 title="Conformance classes">2.1.8. 各種 適合性の類別</h3>

<p>
この仕様は、次の二つに対する適合性~判定基準を述べる：
◎
This specification describes the conformance criteria for＼
</p>

<ul>
	<li>
~UA（実装者に関連する）
◎
user agents (relevant to implementors) and＼
</li>
	<li>
文書（作者／著作~tool実装者に関連する）
◎
documents (relevant to authors and authoring tool implementors).
</li>
</ul>

<p>
`適合~文書@
は、文書に課されるすべての適合性~判定基準に準拠するものである。
可読性のため、これらの適合性~要件のうち一部は，作者に対する適合性~要件として句される。
そのような要件は、暗黙的に文書に課されるものとされる。
定義により、すべての文書には，その作者があるものと見做される。
（一部の事例では、~UA自身がその作者になることもある
— そのような~UAは、下に説明されるように，追加の規則の対象0になる。）
◎
Conforming documents are those that comply with all the conformance criteria for documents. For readability, some of these conformance requirements are phrased as conformance requirements on authors; such requirements are implicitly requirements on documents: by definition, all documents are assumed to have had an author. (In some cases, that author may itself be a user agent — such user agents are subject to additional rules, as explained below.)
</p>

<p class="example">
例えば、要件にて
“作者は `foobar^e 要素を利用しては~MUST_NOT”
と定められている場合、それは［
文書が，名前 `foobar^e の要素を包含することは、許容されない
］ことを含意することになる。
◎
For example, if a requirement states that "authors must not use the foobar element", it would imply that documents are not allowed to contain elements named foobar.
</p>

<p class="note impl">
文書, 実装
に課される適合性~要件の間には、含意される関係性はない。
~UAは、適合しない文書を好きに取扱う自由はない
— この仕様にて述べる処理~modelは、入力~文書が適合するかどうかに関わらず，実装に適用される。
◎
There is no implied relationship between document conformance requirements and implementation conformance requirements. User agents are not free to handle non-conformant documents as they please; the processing model described in this specification applies to implementations regardless of the conformity of the input documents.
</p>

<p class="trans-note">【
しかしながら，適合しないあらゆる事例に対し処理~modelが指定されているわけではないので（おそらく，そうするのは現実的でない）、文書が適合しない場合の各 実装~間の挙動の一貫性は，原則的に仕様からは保障されないと考えるべきであろう。
】</p>

<p>
~UAは、適合性~要件が互いに異なるような，いくつかの（互いに重なり合う）種類に分けられる：
◎
User agents fall into several (overlapping) categories with different conformance requirements.
</p>

<dl>
	<dt id="interactive">
~web~browserその他の，対話的~UA
◎
Web browsers and other interactive user agents
</dt>
	<dd>
`~XML構文$を~supportする~web~browserは、`~HTML名前空間$に属する
~XML文書~内に見出された［
要素, 属性
］を
— 他の仕様により，それらの要素の意味論が上書きされていない限り —
この仕様にて述べるように処理して，利用者がそれらと対話できるようにし~MUST。
◎
Web browsers that support the XML syntax must process elements and attributes from the HTML namespace found in XML documents as described in this specification, so that users can interact with them, unless the semantics of those elements have been overridden by other specifications.
</dd>

	<dd class="example">
適合~Web~browserは、~XML文書~内に `script$e 要素を見出した際に，その要素に包含されている~scriptを実行することになる。
しかしながら，要素が ~XSLTによる変形結果に見出された場合（~UAは~XSLTも~supportするとする）、代わりに~XML処理器は， `script$e 要素を変形結果の一部を形成する不透明な要素として扱うことになる。
◎
A conforming Web browser would, upon finding a script element in an XML document, execute the script contained in that element. However, if the element is found within a transformation expressed in XSLT (assuming the user agent also supports XSLT), then the processor would instead treat the script element as an opaque element that forms part of the transform.
</dd>
	<dd>
`~HTML構文$における~scriptingを~supportする~web~browserは、`~HTML~MIME型$に~~識別される文書を この仕様にて述べるように処理して，利用者が文書と対話できるようにし~MUST。
◎
Web browsers that support the HTML syntax must process documents labeled with an HTML MIME type as described in this specification, so that users can interact with them.
</dd>
	<dd>
~scriptingを~supportする~UAは、この仕様における~IDL片に対しても，
`WEBIDL$r 仕様に述べられる適合~実装で~MUST。
◎
User agents that support scripting must also be conforming implementations of the IDL fragments in this specification, as described in the Web IDL specification. [WEBIDL]
</dd>
	<dd class="note">注記：
明示的に定められない限り、~HTML要素の意味論を上書きする仕様であっても，その要素を表現している~DOM~objに課されている要件は上書きしないとする。
例えば，上の例の `script$e 要素は、依然として，
`HTMLScriptElement$I ~interfaceを実装することになる。
◎
Unless explicitly stated, specifications that override the semantics of HTML elements do not override the requirements on DOM objects representing those elements. For example, the script element in the example above would still implement the HTMLScriptElement interface.
</dd>
	<dt id="non-interactive">
対話的でない呈示のみの~UA
◎
Non-interactive presentation user agents
</dt>
	<dd>
純粋に，
~HTML／~XML
文書の対話的でない~versionを具現化するために処理する~UAは、利用者~対話に関する要件については免除されることを除き，~Web~browserと同じ適合性~判定基準に準拠し~MUST。
◎
User agents that process HTML and XML documents purely to render non-interactive versions of them must comply to the same conformance criteria as Web browsers, except that they are exempt from requirements regarding user interaction.
</dd>
	<dd class="note">注記：
対話的でない呈示~UAの代表的な例として、印刷機（静的~UA）や頭上display（動的~UA）が挙げられる。
静的であって対話的でない呈示~UAのほとんどは、
<a href="#non-scripted">~scripting~supportも欠く</a>
ことが予期される。
◎
Typical examples of non-interactive presentation user agents are printers (static UAs) and overhead displays (dynamic UAs). It is expected that most static non-interactive presentation user agents will also opt to lack scripting support.
</dd>
	<dd class="example">
対話的でないが，動的な呈示~UAは、依然として［
~scriptを実行する, ~formを動的に提出する, 等々
］を許容する。
しかしながら、利用者が文書と対話できない下では， “~focus” の概念は無関係なので、~UAは，~focusに関係するどの~DOM~APIも~supportする必要はないことになる。
◎
A non-interactive but dynamic presentation UA would still execute scripts, allowing forms to be dynamically submitted, and so forth. However, since the concept of "focus" is irrelevant when the user cannot interact with the document, the UA would not need to support any of the focus-related DOM APIs.
</dd>

	<dt id="renderingUA">
示唆される既定の具現化を~supportする視覚的~UA
◎
Visual user agents that support the suggested default rendering
</dt>
	<dd>
対話的かどうかにかかわらず、~UAは、この仕様に定義され, 示唆される（ suggested ），既定の具現化（ rendering ）を~supportするものとして指名され得る（場合によっては 利用者の任意選択として）。
◎
User agents, whether interactive or not, may be designated (possibly as a user option) as supporting the suggested default rendering defined by this specification.
</dd>
	<dd>
このことは要求されてはいない。
特に，~UAには、示唆される既定の具現化を実装するとしても，利用者~体験を改善するためとして，既定の具現化を上書きするような設定群を提供0することが奨励される。
例えば、色の~contrastを変更する,
~focusに異なる~styleを利用する,
その他、利用者がより~accessし易く, 利用し易くするものなど。
◎
This is not required. In particular, even user agents that do implement the suggested default rendering are encouraged to offer settings that override this default to improve the experience for the user, e.g. changing the color contrast, using different focus styles, or otherwise making the experience more accessible and usable to the user.
</dd>
	<dd>
示唆される既定の具現化を~supportするものと指名された~UAは、そう指名されている間は，
<a href="~HTMLrendering#rendering">具現化~節</a>
にて［
~UAに実装することが<em>期待される</em>（ expected ）挙動
］として定義されている規則を実装し~MUST。
◎
User agents that are designated as supporting the suggested default rendering must, while so designated, implement the rules the rendering section defines as the behavior that user agents are expected to implement.
</dd>

	<dt id="non-scripted">
~scriptingを~supportしない~UA
◎
User agents with no scripting support
</dt>
	<dd>
~scriptingを~supportしない（または，まるごと不能化されている）実装は、この仕様に言及される［
~event＆~DOM~interface
］を~supportすることは，免除される。
そのような~UAは、この仕様の~event~modelや~DOMの用語で定義される各部分に対しては、依然として ~event＆~DOMを~supportしていたかのように動作し~MUST。
◎
Implementations that do not support scripting (or which have their scripting features disabled entirely) are exempt from supporting the events and DOM interfaces mentioned in this specification. For the parts of this specification that are defined in terms of an events model or in terms of the DOM, such user agents must still act as if events and the DOM were supported.
</dd>
	<dd class="note">注記：
~scriptingが、~appの不可欠な部分を形成することもある。
~scriptingを~supportしない（または不能化されている）~web~browserは、作者の意図を全部的に伝達できないかもしれない。
◎
Scripting can form an integral part of an application. Web browsers that do not support scripting, or that have scripting disabled, might be unable to fully convey the author's intent.
</dd>

	<dt>
適合性~検査器
◎
Conformance checkers
</dt>
	<dd id="conformance-checkers">
適合性~検査器は、この仕様にて述べる適合性~判定基準のうち 適用し得るものについて，文書が適合するかどうかを検証0し~MUST。
自動化された適合性~検査器には、作者の意図の解釈を要求するような~errorを検出することは免除される（例えば、［
内容が引用でない `blockquote$e 要素
］を含むような文書は，適合しないが、人による判断の下で走らせてない適合性~検査器には， `blockquote$e 要素が引用された素材のみを包含していることを検査する必要はない）。
◎
Conformance checkers must verify that a document conforms to the applicable conformance criteria described in this specification. Automated conformance checkers are exempt from detecting errors that require interpretation of the author's intent (for example, while a document is non-conforming if the content of a blockquote element is not a quote, conformance checkers running without the input of human judgement do not have to check that blockquote elements only contain quoted material).
</dd>
	<dd>
<p >
適合性~検査器は、入力~文書に対し：
</p>

<ul>
	<li>
`属する閲覧文脈$がない下で（~scriptを走らせてない, かつ
構文解析器の`~scripting~flag$は不能化されていることを意味する）構文解析して、適合するかどうかを検査し~MUST。
</li>
	<li>
また，`属する閲覧文脈$がある下で構文解析して、適合するかどうかを
— その中で~scriptを実行して，~scriptが適合しない状態を（~script実行の間に一時的にそうなるときを除いて）決して生じさせないかどうかを —
検査するべきである（この要件は “~SHOULD” までに限られ， “~MUST” ではない
— それは不可能なことが証明されているので `COMPUTABLE$r ）
</li>
</ul>

◎
Conformance checkers must check that the input document conforms when parsed without a browsing context (meaning that no scripts are run, and that the parser's scripting flag is disabled), and should also check that the input document conforms when parsed with a browsing context in which scripts execute, and that the scripts never cause non-conforming states to occur other than transiently during script execution itself. (This is only a "SHOULD" and not a "MUST" requirement because it has been proven to be impossible. [COMPUTABLE])
</dd>
	<dd>
この仕様による要件のうち，適用し得るものに適合するような適合性~検査器は、
“~HTML検証器” とも称される。
◎
The term "HTML validator" can be used to refer to a conformance checker that itself conforms to the applicable requirements of this specification.
</dd>

	<dd class="note">
<p>注記：
~XML~DTDは、この仕様の適合性~要件すべてを表すことはできない。
したがって、~XML処理器と~DTDだけでは，適合性~検査器として~~不足になる。
また、この仕様にて定義される
<a href="#_authoring-formats">二つの著作~形式</a>
のいずれも，~SGMLの応用ではないので、それらを検証する~SGML~systemも，適合性~検査器としては~~不足になる。
◎
XML DTDs cannot express all the conformance requirements of this specification. Therefore, a validating XML processor and a DTD cannot constitute a conformance checker. Also, since neither of the two authoring formats defined in this specification are applications of SGML, a validating SGML system cannot constitute a conformance checker either.
</p>

<p>
別の仕方で記すなら、適合性~判定基準には次の三種がある：
◎
To put it another way, there are three types of conformance criteria:
</p>

		<ol>
			<li>
~DTDで表せるもの。
◎
Criteria that can be expressed in a DTD.
</li>
			<li>
~DTDでは表せないが、機械的に検査できるもの。
◎
Criteria that cannot be expressed by a DTD, but can still be checked by a machine.
</li>
			<li>
人によってのみ検査できるもの。
◎
Criteria that can only be checked by a human.
</li>
		</ol>

<p>
適合性~検査器は、最初の二項目に対しては検査し~MUST。
~DTDのみに基づく単純な検証器は、最初の類別の~errorしか検査しないので、この仕様に則る適合性~検査器には適合しない。
◎
A conformance checker must check for the first two. A simple DTD-based validator only checks for the first class of errors and is therefore not a conforming conformance checker according to this specification.
</p>
	</dd>

	<dt>
~data-mining~tool
◎
Data mining tools
</dt>
	<dd id="data-mining">
［
文書を具現化する, 適合性を検査する
］以外の理由で［
~HTML／~XML
］文書を処理する~appや~toolは、自身が処理する文書の意味論に則って動作するべきである。
◎
Applications and tools that process HTML and XML documents for reasons other than to either render the documents or check them for conformance should act in accordance with the semantics of the documents that they process.
</dd>
	<dd class="example">
`文書の~outline$を生成する~toolであって、入子~levelを 各~段落に対しては増やしつつ，各~節に対しては増やさないものは、適合しない。
◎
A tool that generates document outlines but increases the nesting level for each paragraph and does not increase the nesting level for each section would not be conforming.
</dd>

	<dt id="editors">
著作~tool／~markup生成器
◎
Authoring tools and markup generators
</dt>
	<dd>
著作~tool／~markup生成器
は、`適合~文書$を生成し~MUST。
作者に適用される適合性~判定基準は、適切になる所では，著作~toolにも適用される。
◎
Authoring tools and markup generators must generate conforming documents. Conformance criteria that apply to authors also apply to authoring tools, where appropriate.
</dd>
	<dd>
著作~toolには、~tool自身が作者の意図を決定できない範囲0に限り，［
要素をそれに指定された目的に限って利用するとする，厳格な要件
］からは免除される。
しかしながら，著作~toolは、要素を自動的に誤用したり，利用者にそうするよう奨励しては~MUST_NOT。
◎
Authoring tools are exempt from the strict requirements of using elements only for their specified purpose, but only to the extent that authoring tools are not yet able to determine author intent. However, authoring tools must not automatically misuse elements or encourage their users to do so.
</dd>
	<dd class="example">
例えば、 `address$e 要素を任意の連絡先~情報に利用することは適合でない
— その要素は、文書またはその一節の著作者に対する連絡先~情報を~markupするために限って利用できるので。
しかしながら、著作~toolは，およそ その相違は決定できないであろうから、その要件は免除される。
そうであっても，これは、著作~toolが［
（例えば）~italic体の~textのどの~blockにも `address$e 要素を利用できる
］ことを意味するわけではない
— それは単に、著作~toolが，［
利用者が~toolを利用して連絡先~情報を挿入するときに，利用者が本当にそれを行っていて 何か別のものを挿入していない
］ことを検証0する必要はないことを意味する。
◎
For example, it is not conforming to use an address element for arbitrary contact information; that element can only be used for marking up contact information for the author of the document or section. However, since an authoring tool is likely unable to determine the difference, an authoring tool is exempt from that requirement. This does not mean, though, that authoring tools can use address elements for any block of italics text (for instance); it just means that the authoring tool doesn't have to verify that when the user uses a tool for inserting contact information for a section, that the user really is doing that and not inserting something else instead.
</dd>
	<dd class="note">注記：
適合性を検査するにあたっては、~editorは，［
適合性~検査器が検証0するのと同じ範囲0までにおいて，適合する
］ような文書を出力する必要がある。
◎
In terms of conformance checking, an editor has to output documents that conform to the same extent that a conformance checker will verify.
</dd>
	<dd>
著作~toolが適合しない文書を編集するために利用されるときは、編集~sessionの間に，文書~内の未~編集-部分における適合性~errorを保全しても~MAY（すなわち、編集~toolには、~error含みの内容を往来することは許容される）。
しかしながら，著作~toolは、そのように~errorが保全された出力を，適合するものと主張しては~MUST_NOT。
◎
When an authoring tool is used to edit a non-conforming document, it may preserve the conformance errors in sections of the document that were not edited during the editing session (i.e. an editing tool is allowed to round-trip erroneous content). However, an authoring tool must not claim that the output is conformant if errors have been so preserved.
</dd>
	<dd>
<p>
著作~toolは、次の二つに大別されることが予期される：
◎
Authoring tools are expected to come in two broad varieties:＼
</p>

		<ul>
			<li>
構造~上のまたは意味論上の~dataに対し働くもの。
◎
tools that work from structure or semantic data, and＼
</li>
			<li>
媒体~特有の~WYSIWYG（ What-You-See-Is-What-You-Get ）編集に基づいて働くもの。
◎
tools that work on a What-You-See-Is-What-You-Get media-specific editing basis (WYSIWYG).
</li>
		</ul>

<p >
前者は、~HTMLを著作する~toolに選好される仕組みである
— 最も適切な~HTML要素／属性を選ぶ際の判断材料に，~source情報~内の構造を利用できるので。
◎
The former is the preferred mechanism for tools that author HTML, since the structure in the source information can be used to make informed choices regarding which HTML elements and attributes are most appropriate.
</p>

<p>
しかしながら，~WYSIWYG~toolは legitimate である 【？】 。
~WYSIWYG~toolは、適切であると知る要素のみを利用するべきであり，そうでない要素は利用するべきでない。
これは、ある種の極端な事例では，~flow要素の利用を［
`div$e, `b$e, `i$e, `span$e
］の様な，ごく少数のものに制限した上で， `style$a 属性を最大限に活用することを意味するかもしれない。
◎
However, WYSIWYG tools are legitimate. WYSIWYG tools should use elements they know are appropriate, and should not use elements that they do not know to be appropriate. This might in certain extreme cases mean limiting the use of flow elements to just a few elements, like div, b, i, and span and making liberal use of the style attribute.
</p>
	</dd>
	<dd>
~WYSIWYGかどうかにかかわらず，すべての著作~toolは、利用者が［
きちんと構造~化され, 意味論的に多彩な，媒体依存の内容
］を作成できるようにすべく，でき得る限り努めるべきである。
◎
All authoring tools, whether WYSIWYG or not, should make a best effort attempt at enabling users to create well-structured, semantically rich, media-independent content.
</dd>

</dl>

<p id="hardwareLimitations">
~FINGERPRINTING
~UAは、さもなければ拘束されない入力に，実装~特有の制限-を課して~MAY。
例えば［
~DOS攻撃を防止する ／
~memoryの枯渇に抗して防護する ／
~platform特有の制限に対処する
］など。
◎
User agents may impose implementation-specific limits on otherwise unconstrained inputs, e.g. to prevent denial of service attacks, to guard against running out of memory, or to work around platform-specific limitations.
</p>

<p id="_authoring-formats">
［
既存の内容や, 先立つ仕様
］との互換性をとるため、この仕様は，次の二つの著作~形式を述べる：
◎
For compatibility with existing content and prior specifications, this specification describes two authoring formats:＼
</p>

<ul>
	<li>
`~XML構文$に基づくもの。
◎
one based on XML, and＼
</li>
	<li>
~SGMLに~~由来する`~custom形式$を利用するもの（`~HTML構文$とも称される）。
◎
one using a custom format inspired by SGML (referred to as the HTML syntax).＼
</li>
</ul>

<p>
実装は、これら二つの形式のうち，少なくとも一方は~supportし~MUST
— 両者とも~supportすることが奨励されるが。
◎
Implementations must support at least one of these two formats, although supporting both is encouraged.
</p>

<p>
適合性~要件のうち一部は、［
要素 ／ 属性 ／ ~method ／ ~obj
］に課される要件として句される。
そのような要件は、次の二つに~~分類される：
◎
Some conformance requirements are phrased as requirements on elements, attributes, methods or objects. Such requirements fall into two categories: those describing content model restrictions, and those describing implementation behavior.＼
</p>

<ul>
	<li>
内容~modelに対する制約について述べるもの。
これは、［
文書／著作~tool
］に課される要件になる。
◎
Those in the former category are requirements on documents and authoring tools.＼
</li>
	<li>
実装の挙動について述べるもの。
これは、~UAに課される要件になる。
◎
Those in the second category are requirements on user agents.＼
</li>
</ul>

<p>
同様に，適合性~要件のうち一部は、作者に課される要件として句される。
そのような要件は、作者が生産する文書に課される適合性~要件として解釈されることになる（言い換えれば、この仕様は，作者に課される適合性~判定基準と, 文書に課されるそれとを区別しない）。
◎
Similarly, some conformance requirements are phrased as requirements on authors; such requirements are to be interpreted as conformance requirements on the documents that authors produce. (In other words, this specification does not distinguish between conformance criteria on authors and conformance criteria on documents.)
</p>

			</section>
			<section id="dependencies">
<h3 title="Dependencies">2.1.9. 依存関係</h3>

<p class="trans-note">【
この節の和訳は
<a href="~HTMLdep#dependencies">別ページにて</a>
】</p>

			</section>
			<section id="extensibility-2">
<h3 title="Extensibility">2.1.10. 拡張性</h3>

<p>
この仕様に対する~vendor特有の~proprietaryな~UA拡張は、強く忌避される。
文書は、そのような拡張を利用しては~MUST_NOT。
そのような行為は、当の内容への~accessが特定の~UAの利用者に限られてしまい，相互運用性の悪化と利用者~層の細分化を招くことになるので。
◎
Vendor-specific proprietary user agent extensions to this specification are strongly discouraged. Documents must not use such extensions, as doing so reduces interoperability and fragments the user base, allowing only users of specific user agents to access the content in question.
</p>

<p>
すべての拡張は、その利用が，この仕様にて定義される機能性に矛盾したり適合しなくなるように定義されては~MUST_NOT。
◎
All extensions must be defined so that the use of extensions neither contradicts nor causes the non-conformance of functionality defined in the specification.
</p>

<p class="example">
例えば，そうすることは強く忌避されてはいるが、実装は，ある~controlに［
利用者が その~controlの現在の値を選択するときにかかった時間
］を返すような，新たな~IDL属性 `typeTime^m を追加することもできる。
一方で、~formの `elements$m 配列に出現するような，新たな~controlを定義することは、上の要件に対する違反になる
— それは、この仕様が与える `elements$m の定義に違反するので。
◎
For example, while strongly discouraged from doing so, an implementation could add a new IDL attribute "typeTime" to a control that returned the time it took the user to select the current value of a control (say). On the other hand, defining a new control that appears in a form's elements array would be in violation of the above requirement, as it would violate the definition of elements given in this specification.
</p>

<hr>

<p>
この仕様に対し ~vendorに中立的な拡張が必要されるときは、それに則って，この仕様が更新されるか，この仕様の要件を上書きするような拡張~仕様が記され得る。
自身の活動にこの仕様を適用している誰かが、そのような拡張~仕様の要件を認めるものと決めたとき、それは，この仕様に対する適合性~要件の目的において
`適用し得る仕様@
になる。
◎
When vendor-neutral extensions to this specification are needed, either this specification can be updated accordingly, or an extension specification can be written that overrides the requirements in this specification. When someone applying this specification to their activities decides that they will recognize the requirements of such an extension specification, it becomes an applicable specification for the purposes of conformance requirements in this specification.
</p>

<p class="note">注記：
誰かが，［
任意の~byte~streamは適合である
］と定義するような仕様を書いた上で，そのような無作為な~junkを適合であると主張することもできる。
しかしながらそれは、その無作為な~junkが皆の目的に適合であることを実際に意味するものではない。
他の誰かが，その仕様を自身の仕事に適用しないものと決めたなら、その誰かは，全く正当に［
前述の~junkは，単に~junkであり全く適合でない
］と言える。
特定0の~communityにおいて何が問題0とされるかは，その~communityが何に<em>同意するか</em>であり、適合性が適用し得るのは，その限りにおいてである。
◎
Someone could write a specification that defines any arbitrary byte stream as conforming, and then claim that their random junk is conforming. However, that does not mean that their random junk actually is conforming for everyone's purposes: if someone else decides that that specification does not apply to their work, then they can quite legitimately say that the aforementioned random junk is just that, junk, and not conforming at all. As far as conformance goes, what matters in a particular community is what that community agrees is applicable.
</p>

<hr>

<p>
~UAは、自身が解さない要素や属性を，次のように意味論的に中立的であるものと扱わ~MUST：
◎
User agents must treat elements and attributes that they do not understand as semantically neutral;＼
</p>

<ul >
	<li>
~DOM処理器においては、それらを~DOM内に残すこと。
◎
leaving them in the DOM (for DOM processors), and＼
</li>
	<li>
~CSS処理器においては、~CSSに則ってそれらに~styleをあてがうこと。
◎
 styling them according to CSS (for CSS processors), but＼
 </li>
	<li>
それらから いかなる意味も推定しないこと。
◎
not inferring any meaning from them.
</li>
</ul>

<p>
~UAは、特色機能の~supportを不能化するときは（例：
保安~問題を軽減するための緊急の措置として ／
開発を援助するため ／
処理能~上の理由から），［
その特色機能をまったく~supportしていなかった ／
その特色機能は，この仕様に言及されていなかった
］かのように動作し~MUST。
例えば、特定0の特色機能が ~Web~IDL~interface内の属性を介して~accessされる場合、属性~自身は，その~interfaceを実装する~objから外されることになる
— ~obj上にその属性を残した上で，~NULL を返したり, 例外を投出させるのでは、不十分である。
◎
When support for a feature is disabled (e.g. as an emergency measure to mitigate a security problem, or to aid in development, or for performance reasons), user agents must act as if they had no support for the feature whatsoever, and as if the feature was not mentioned in this specification. For example, if a particular feature is accessed via an attribute in a Web IDL interface, the attribute itself would be omitted from the objects that implement that interface — leaving the attribute on the object but making it return null or throw an exception is insufficient.
</p>


			</section>
			<section id="interactions-with-xpath-and-xslt">
<h3 title="Interactions with XPath and XSLT">2.1.11. ~XPath＆~XSLT との相互作用</h3>

<p id="xpath-1.0-processors">
この仕様に述べる方式で［
構文解析される／作成される `~HTML文書$
］上で演算する XPath 1.0 実装（例：
`document.evaluate()^c ~APIの一部で）は、
XPath 1.0 仕様に，次の編集-が適用されたかのように動作し~MUST：
◎
Implementations of XPath 1.0 that operate on HTML documents parsed or created in the manners described in this specification (e.g. as part of the document.evaluate() API) must act as if the following edit was applied to the XPath 1.0 specification.
</p>



<p>
先ず，次の段落を除去した上で：
◎
First, remove this paragraph:
</p>

<blockquote
	lang="en-x-a0"
	cite="https://www.w3.org/TR/1999/REC-xpath-19991116/#node-tests"
>
<p>
A QName in the node test is expanded into an expanded-name using the namespace declarations from the expression context. This is the same way expansion is done for element type names in start and end-tags except that the default namespace declared with xmlns is not used: if the QName does not have a prefix, then the namespace URI is null (this is the same way attribute names are expanded). It is an error if the QName has a prefix for which there is no namespace declaration in the expression context.
</p>
</blockquote>

<div class="trans-note">
<p>
~node-testにおける `QName^P は、~XPath式~文脈（ the expression context ）からの名前空間~宣言を利用して， `expanded-name$P に展開される。
これは、［
`xmlns^a により宣言される，既定の名前空間
］は利用されないことは除いて，
開始~tag／終了~tag
における要素~型~名に対する展開と同じ仕方で行われる：
</p>

<ul>
	<li>
`QName$P に接頭辞（ prefix ）がない場合、名前空間 URI （ namespace URI ）は ~NULL とする（これは、属性~名（ attribute name ）が展開されるときと同じ仕方になる）。
</li>
	<li>
`QName$P に接頭辞がある場合、対する~XPath式~文脈に名前空間~宣言がないならば，~errorとする。
</li>
</ul>

</div>


<p>
その場所に次を挿入する：
◎
Then, insert in its place the following:
</p>

<blockquote
	lang="en-x-a0"
	cite="https://www.w3.org/Bugs/Public/show_bug.cgi?id=7059#c37"
>
<p>
A QName in the node test is expanded into an expanded-name using the namespace declarations from the expression context. If the QName has a prefix, then there must be a namespace declaration for this prefix in the expression context, and the corresponding namespace URI is the one that is associated with this prefix. It is an error if the QName has a prefix for which there is no namespace declaration in the expression context.
</p>

<p>
If the QName has no prefix and the principal node type of the axis is element, then the default element namespace is used. Otherwise if the QName has no prefix, the namespace URI is null. The default element namespace is a member of the context for the XPath expression. The value of the default element namespace when executing an XPath expression through the DOM3 XPath API is determined in the following way:
</p>

<ol ><li>If the context node is from an HTML DOM, the default element namespace is "http://www.w3.org/1999/xhtml".
</li><li>Otherwise, the default element namespace URI is null.
</li></ol>

</blockquote>

<div class="trans-note">
<p>
~node-testにおける `QName^P は、~XPath式~文脈からの名前空間~宣言を利用して
`expanded-name$P に展開される。
</p>

<ul>
	<li>
`QName^P に接頭辞がある場合、~XPath式~文脈に，この接頭辞に対する名前空間~宣言が~~存在し~MUST
— 存在しない場合は~errorとする。
この接頭辞には、その宣言により宣言される名前空間 URI が結付けられる。
</li>
	<li>
<p >
`QName^P に接頭辞がない場合の名前空間 URI は：
</p>
		<ul>
			<li>
the axis の the principal ~node型は要素である場合、要素に対する既定の名前空間が利用される。
</li>
			<li>
他の場合、~NULL とする。
</li>
		</ul>
	</li>
</ul>

<p>
要素に対する既定の名前空間は、~XPath式が属する文脈の一員である。
DOM3 XPath API を通して~XPath式を実行するときの，要素に対する既定の名前空間の値は、次に従って決定される：
</p>

<ol>
	<li>
文脈~nodeが~HTML~DOMに属するならば：
`http://www.w3.org/1999/xhtml^l
</li>
	<li>
他の場合：
~NULL
</li>
</ol>
</div>

<div class="note">
<p>注記：
これは、 XPath 2.0 の特色機能である［
要素に対する既定の名前空間（ the default element namespace ）
］を XPath 1.0 に追加した上で、~HTML文書においては，~HTML名前空間を［
要素に対する既定の名前空間
］として利用することに等価である。
それは、次が欲されることが動機にある：
◎
This is equivalent to adding the default element namespace feature of XPath 2.0 to XPath 1.0, and using the HTML namespace as the default element namespace for HTML documents. It is motivated by the desire to＼
</p>

<ul>
	<li>
実装が旧来の~HTML内容と互換であり続けること。
◎
have implementations be compatible with legacy HTML content＼
</li>
	<li>
ただし、この仕様により~HTMLに導入される，~HTML要素に利用される名前空間に関する変更点は~supportすること。
◎
while still supporting the changes that this specification introduces to HTML regarding the namespace used for HTML elements, and＼
</li>
	<li>
XPath 2.0 ではなく XPath 1.0 を利用すること。
◎
by the desire to use XPath 1.0 rather than XPath 2.0.
</li>
</ul>

</div>

<p class="note">注記：
この変更は、上述の最初の 2 項目を動機とする，
`XPATH10$r 仕様に対する`故意的な違反$である。
◎
This change is a willful violation of the XPath 1.0 specification, motivated by desire to have implementations be compatible with legacy content while still supporting the changes that this specification introduces to HTML regarding which namespace is used for HTML elements. [XPATH10]
</p>

<hr>

<p id="dom-based-xslt-1.0-processors">
~XSLT 1.0 処理器が，（ 明示的に, または XSLT 1.0 の規則による既定~法を介して）出力~method `html^l の下で~DOMを出力するときは、次のように影響される：
◎
XSLT 1.0 processors outputting to a DOM when the output method is "html" (either explicitly or via the defaulting rule in XSLT 1.0) are affected as follows:
</p>

<p>
変形~programが 名前空間に属さない要素を出力する場合、処理器は，対応する~DOM要素~nodeを構築するに先立って，次を行わ~MUST：
◎
If the transformation program outputs an element in no namespace, the processor must, prior to constructing the corresponding DOM element node,＼</p>

<ul>
	<li>
要素の名前空間を`~HTML名前空間$に変更する
◎
change the namespace of the element to the HTML namespace,＼
</li>
	<li>
要素の局所~名を`~ASCII小文字~化$する
◎
ASCII-lowercase the element's local name, and＼
</li>
	<li>
要素~上のどの属性 %A に対しても、
%A が名前空間に属さないならば， %A の名前を`~ASCII小文字~化$する。
◎
ASCII-lowercase the names of any non-namespaced attributes on the element.
</li>
</ul>

<p class="note">注記：
この要件は、 `XSLT10$r に対する`故意的な違反$である
— これが要求されるのは、そうしなければ，この仕様による~HTMLの名前空間と文字大小区別の有無に関する変更が，~DOMに基づく~XSLT変形と非互換になるためである。
（出力を直列化する処理器は影響されない。）
◎
This requirement is a willful violation of the XSLT 1.0 specification, required because this specification changes the namespaces and case-sensitivity rules of HTML in a manner that would otherwise be incompatible with DOM-based XSLT transformations. (Processors that serialize the output are unaffected.) [XSLT10]
</p>

<hr>

<p>
この仕様は、~XSLT処理と`~HTML構文解析器$ 基盤とがどう相互作用するかについては、精確に指定しない（例えば、~XSLT処理器は，要素を`~open要素~stack$の中へ置いたかのように動作するのかどうか）。
しかしながら，~XSLT処理器は：
◎
This specification does not specify precisely how XSLT processing interacts with the HTML parser infrastructure (for example, whether an XSLT processor acts as if it puts any elements into a stack of open elements). However, XSLT processors＼
</p>

<ul>
	<li>
成功裡に完了したときには、`構文解析を停止-$し~MUST。
◎
must stop parsing if they successfully complete, and＼
</li>
	<li>
加えて，`文書の現在の準備度$は、先ず `interactive^l に設定した上で，中止された場合は `complete^l に設定し~MUST。
◎
must set the current document readiness first to "interactive" and then to "complete" if they are aborted.
</li>
</ul>


<hr>

<p>
この仕様は、次については指定しない：
◎
This specification does not specify＼
</p>

<ul>
	<li>
~XSLTと`~navi$~algoとが，どう相互作用するか。
◎
how XSLT interacts with the navigation algorithm,＼
</li>
	<li>
~XSLTが`~event-loop$内にどう収まるか。
◎
how it fits in with the event loop, nor＼
</li>
	<li>
~error頁がどう取扱われることになるか（例：~XSLT~errorは，~XSLTによる増分的~出力を置換するのか, ~inlineに具現化されるのか, 等々）。
◎
how error pages are to be handled (e.g. whether XSLT errors are to replace an incremental XSLT output, or are rendered inline, etc).
</li>
</ul>

<p>注記：
~HTMLとの相互作用に関する，追加の規範的でない~commentもある：
◎
There are also additional non-normative comments regarding＼
</p>

<ul>
	<li>
~XSLTに対するそれは
<a href="~HEscripting#scriptTagXSLT">~script要素~節</a>
にある。
◎
the interaction of XSLT and HTML in the script element section, and＼
</li>
	<li>
［
~XSLT, ~XPath, ~HTML
］に対するそれは
<a href="~HEscripting#template-XSLT-XPath">~template要素~節</a>
にある。
◎
of XSLT, XPath, and HTML in the template element section.
</li>
</ul>

			</section>
		</section>
		<section id="case-sensitivity-and-string-comparison">
<h2 title="Case-sensitivity and string comparison">2.2. 文字大小区別の有無と文字列の比較</h2>


<p class="algo-head">
2 つの文字列を
`文字大小区別@
で比較するとは、符号位置ごとに正確に比較することを意味する。
◎
Comparing two strings in a case-sensitive manner means comparing them exactly, code point for code point.
</p>


<p>
他から定められない限り，文字列は`文字大小区別$で比較され~MUST。
◎
Except where otherwise stated, string comparisons must be performed in a case-sensitive manner.
</p>

<p class="trans-note">【
この訳（または他の仕様の和訳）では、`文字大小区別$による比較は，単に
“~EQ” や “~NEQ”
で表現する（特に明示する必要がある場合を除いて）。
】</p>

<p class="algo-head">
文字列 %~pattern が文字列 %S に
`先頭一致@
するとは、
%L を %~pattern の文字~数とするとき，［
%~pattern ~EQ ［
%S の中の，先頭から %L 個までの文字が成す文字列
］］であることを意味する。
◎
A string pattern is a prefix match for a string s when pattern is not longer than s and truncating s to pattern's length leaves the two strings as matches of each other.
</p>


		</section>
	</section>
</main><!-- id="MAIN" -->

