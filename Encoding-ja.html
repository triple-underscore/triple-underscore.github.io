<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Encoding Standard â€” ç¬¦å·åŒ–æ³• æ¨™æº–ï¼ˆæ—¥æœ¬èªè¨³ï¼‰</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>
#encoding-labels td + td {
	white-space: pre;
	white-space: pre-line;
}


.algo {
	color:#404;
	font-style: italic;
}

i {
	color: #808;
}

.coder {
	font-family: sans-serif0, sans-serif;
}

.label {
	color: #666;
}

b.ename {
	font-weight: normal;
	font-family: sans-serif0, sans-serif;
	color: black;
}

.hex-value {
	font-family: sans-serif0, sans-serif;
}

.xattr {
	font-family: monospace0, monospace;
	color: black;
}

#_big5-lead > tr > td:nth-child(2) {
	white-space: nowrap;
}

</style>


<style>
/* based on the style at
https://encoding.spec.whatwg.org/visualization-colors.css
(2017-01-22)
*/

._vis-visualizationlegend > tr > :first-child > div {
	box-sizing: border-box;
	width: 2em;
	height: 2em;
}

._vis-unmapped {
  background-color: #920000;
  color: white;
}

._vis-astral {
  background-color: #6db6fe;
  color: black;
}

._vis-mid {
  background-color: #ffff6d;
  color: black;
}

._vis-upper, ._vis-byte {
  background-color: #d4d5db;
  color: black;
}

._vis-pua {
  background-color: #db6d00;
  color: black;
}

._vis-mid._vis-contiguous {
  background-color: #009292;
  color: black;
}

._vis-upper._vis-contiguous {
  background-color: #24fe23;
  color: black;
}

._vis-pua._vis-contiguous {
  background-color: #924900;
  color: white;
}

._vis-astral._vis-contiguous {
  background-color: #480091;
  color: white;
}

._vis-duplicate {
  border-style: solid ;
  border-color: #920000;
  color: black;
}

._vis-compatibility {
  border-style: dashed;
  border-color: black;
}

._vis-duplicate._vis-compatibility {
  border-style: dashed;
  border-color: #920000;
}

._vis-ext {
  border-style: dotted;
  border-color: black;
}

._vis-ext._vis-compatibility {
  border-style: dotted;
  border-color: #920000;
}

._vis-surrogate {
  background-color: #b4b4b6;
}



@supports (display: grid) and (display: contents) {

#_index_list {
	min-width: 30em;
	max-width: 70em;
}

#_index_list tr {
	grid-template-areas:
		"åå‰ ç´¢å¼• è¦–è¦šåŒ– è¢«è¦†åŸŸ"
		"åå‰ å‚™è€ƒ å‚™è€ƒ å‚™è€ƒ"
	;
	grid-template-columns: 10em 1fr 1fr 1fr;
}

#_index_list tr > *:nth-child(1) {
	grid-area: åå‰;
	border-left-width: 0;
}

#_index_list tr > *:nth-child(2) {
	grid-area: ç´¢å¼•;
}

#_index_list tr > *:nth-child(3) {
	grid-area: è¦–è¦šåŒ–;
}

#_index_list tr > *:nth-child(4) {
	grid-area: è¢«è¦†åŸŸ;
}

#_index_list tr > *:nth-child(5) {
	grid-area: å‚™è€ƒ;
}

}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		persisted_parts: { _acks1: E('_acks1') },
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~ä¸€-é¿†ã‚-ã‚“]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'lb':
	text = `"<code class="label">${text}</code>"`;
	break;
case 'mc':
	text = "constructor";
	href = `#dom-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'n': // encoding name
	href = `#${key.toLowerCase()}`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'X':
	text = `0x${key}`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'idx':
	return idx_html(key);
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}

	function idx_html(key){
		const k = key.toLowerCase();
		const url = 'https://encoding.spec.whatwg.org/';

		let txt = `
<a href="${url}index-${k}.txt">index-${k}.txt</a>`;
		let vis = `
<td><a href="${url}${k}.html">ç´¢å¼• <b class="ename">${key}</b> è¦–è¦š-åŒ–</a>`;
		let cover = `
<td><a href="${url}${k}-bmp.html">ç´¢å¼• <b class="ename">${key}</b> BMP è¢«è¦†åŸŸ</a>`;

		switch(key){
			case 'jis0208':
				vis += `,
<a href="${url}shift_jis.html">ç´¢å¼•~Shift_JISè¦–è¦š-åŒ–</a>`;
			break;
			case 'gb18030-ranges':
			case 'iso-2022-jp-katakana':
				vis = cover = '<td>';
			break;
//			case 'ISO-8859-8-I'
		}

		return txt + vis + cover;
	}
}

</script>

<script type="text/plain" id="_source_data">


â—â—options

spec_title:Encoding
spec_date:2020-01-20
trans_update:2020-01-20
source_checked:180823
spec_status:LS
original_url:https://encoding.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
copyright:2020,whatwg
trans_1st_pub:2012-10-22


â—â—class_map
E:error
n:ename
U:code-point
X:hex-value
sl:js-slot
jA:abstract
jv:js-value
xA:xattr

â—â—tag_map
I:code
m:code
mb:code
E:code
n:b
U:span
X:span
i:i
i1:i
V:var
sl:span
jA:span
jv:code
xA:code
em:em

â—â—mdn_urls
textdecoder:API/TextDecoder
textencoder:API/TextEncoder
	textdecoderoptions:API/TextDecoderOptions
	textdecodeoptions:API/TextDecodeOptions
	dictdef-textencoderencodeintoresult:API/TextEncoderEncodeIntoResult
	textencodeoptions:API/TextEncodeOptions
	generictransformstream:API/GenericTransformStream
	textdecodercommon:API/TextDecoderCommon
	textdecoderstream:API/TextDecoderStream
	textencodercommon:API/TextEncoderCommon
	textencoderstream:API/TextEncoderStream

â—â—link_map


	â—IDL
Exposed:~WEBIDL#Exposed
AllowShared:~WEBIDL#AllowShared
xA.AllowShared:~WEBIDL#AllowShared

E.RangeError:~WEBIDL#exceptiondef-rangeerror
E.TypeError:~WEBIDL#exceptiondef-typeerror

I.TextDecoderOptions:#textdecoderoptions
I.TextDecodeOptions:#textdecodeoptions
I.TextDecoder:#textdecoder
I.TextEncoderEncodeIntoResult:#dictdef-textencoderencodeintoresult
I.TextEncodeOptions:#textencodeoptions
I.TextEncoder:#textencoder
I.BufferSource:~WEBIDL#BufferSource
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array
I.Uint32Array:~WEBIDL#idl-Uint32Array

I.GenericTransformStream:#generictransformstream
I.TextDecoderCommon:#textdecodercommon
I.TextDecoderStream:#textdecoderstream
I.TextEncoderCommon:#textencodercommon
I.TextEncoderStream:#textencoderstream

I.ReadableStream:~STREAMS#rs-class
I.WritableStream:~STREAMS#ws-class
I.TransformStream:~STREAMS#ts-class

Uint8Array:~WEBIDL#idl-Uint8Array
USVString:~WEBIDL#idl-USVString
DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean
unsigned long long:~WEBIDL#idl-unsigned-long-long

m.TextDecoder:#dom-textdecoder
m.encoding:#dom-textdecoder-encoding
m.fatal:#dom-textdecoder-fatal
m.ignoreBOM:#dom-textdecoder-ignorebom

m.TextEncoder:#dom-textencoder
m.decode:#dom-textdecoder-decode
m.~encoding0:#dom-textencoder-encoding
m.encode:#dom-textencoder-encode
m.encodeInto:#dom-textencoder-encodeinto

m.read:#dom-textencoderencodeintoresult-read
m.written:#dom-textencoderencodeintoresult-written

m.TextEncoderStream:#dom-textencoderstream
m.TextDecoderStream:#dom-textdecoderstream
m.readable:#dom-generictransformstream-readable
m.writable:#dom-generictransformstream-writable

m.pipeThrough:~STREAMS#rs-pipe-through

mb.fatal:#dom-textdecoderoptions-fatal
mb.ignoreBOM:#dom-textdecoderoptions-ignorebom

mb.stream:#dom-textdecodeoptions-stream

	%input:#dom-textdecoder-decode-input-options-input
	%label:#dom-textdecoder-textdecoder-label-options-label
	%label:#dom-textdecoderstream-textdecoderstream-label-options-label
	%options:#dom-textdecoder-decode-input-options-options
	%options:#dom-textdecoder-textdecoder-label-options-options
	%options:#dom-textdecoderstream-textdecoderstream-label-options-options

	â—ç”¨èª

ç¬¦å·åŒ–æ³•:#encoding
åå‰:#name
~label:#label
å¾©å·å™¨:#decoder
~Unicodeã«å¾©å·ã™ã‚‹:#decode
~UTF-8å¾©å·ã™ã‚‹:#utf-8-decode
~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹:#utf-8-decode-without-bom
~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹:#utf-8-decode-without-bom-or-fail
~UTF-8ç¬¦å·åŒ–ã™ã‚‹:#utf-8-encode
ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹:#encode
ç¬¦å·åŒ–å™¨:#encoder
~handler:#handler
~error~mode:#error-mode
~error:#error
å®Œé‚d:#finished
ç¶™ç¶š-:#continue
~EoS:#end-of-stream
~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹:#concept-encoding-get
ç¬¦å·åŒ–æ³•ã‹ã‚‰å‡ºåŠ›~ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹:#get-an-output-encoding
~token:#concept-token
~stream:#concept-stream
~tokenã‚’èª­å–ã‚‹:#concept-stream-read
å‰ä»˜åŠ ã™ã‚‹:#concept-stream-prepend
å‰ä»˜åŠ -:#concept-stream-prepend
~pushã™ã‚‹:#concept-stream-push
èµ°ã‚‰ã™:#concept-encoding-run
~tokenã‚’å‡¦ç†ã™ã‚‹:#concept-encoding-process

	â—
ç´¢å¼•:#index
ç´¢å¼•~cp:#index-code-point
ç´¢å¼•~pointer:#index-pointer
ç´¢å¼•~Big5~pointer:#index-big5-pointer
ç´¢å¼•~Big5:#index-big5
ç´¢å¼•~EUC-KR:#index-euc-kr
ç´¢å¼•~jis0208:#index-jis0208
ç´¢å¼•~jis0212:#index-jis0212
ç´¢å¼•~Shift_JIS~pointer:#index-shift_jis-pointer
ç´¢å¼•~ISO-2022-JP~katakana:#index-iso-2022-jp-katakana
ç´¢å¼•~gb18030ç¯„å›²é›†:#index-gb18030-ranges
ç´¢å¼•~gb18030ç¯„å›²é›†~cp:#index-gb18030-ranges-code-point
ç´¢å¼•~gb18030ç¯„å›²é›†~pointer:#index-gb18030-ranges-pointer

ç´¢å¼•~gb18030:#index-gb18030

~UTF-8~cp:#utf-8-code-point
~UTF-8å‡ºç¾~byteæ•°:#utf-8-bytes-seen
~UTF-8è¦~byteæ•°:#utf-8-bytes-needed
~UTF-8ä¸‹é™:#utf-8-lower-boundary
~UTF-8ä¸Šé™:#utf-8-upper-boundary

å˜byteç¬¦å·åŒ–æ³•:#single-byte-encoding
å˜byteç´¢å¼•:#index-single-byte


	â—åå‰
	n.UTF-8:#utf-8
	n.IBM866:#ibm866
	n.ISO-8859-2:#iso-8859-2
	n.ISO-8859-3:#iso-8859-3
	n.ISO-8859-4:#iso-8859-4
	n.ISO-8859-5:#iso-8859-5
	n.ISO-8859-6:#iso-8859-6
	n.ISO-8859-7:#iso-8859-7
	n.ISO-8859-8:#iso-8859-8
	n.ISO-8859-8-I:#iso-8859-8-i
	n.ISO-8859-10:#iso-8859-10
	n.ISO-8859-13:#iso-8859-13
	n.ISO-8859-14:#iso-8859-14
	n.ISO-8859-15:#iso-8859-15
	n.ISO-8859-16:#iso-8859-16
	n.KOI8-R:#koi8-r
	n.KOI8-U:#koi8-u
	n.macintosh:#macintosh
	n.windows-874:#windows-874
	n.windows-1250:#windows-1250
	n.windows-1251:#windows-1251
	n.windows-1252:#windows-1252
	n.windows-1253:#windows-1253
	n.windows-1254:#windows-1254
	n.windows-1255:#windows-1255
	n.windows-1256:#windows-1256
	n.windows-1257:#windows-1257
	n.windows-1258:#windows-1258
	n.x-mac-cyrillic:#x-mac-cyrillic

	n.GBK:#gbk
	n.gb18030:#gb18030
	n.Big5:#big5
	n.EUC-JP:#euc-jp
	n.ISO-2022-JP:#iso-2022-jp
	n.Shift_JIS:#shift_jis
	n.EUC-KR:#euc-kr
	n.replacement:#replacement
	n.UTF-16LE:#utf-16le
	n.UTF-16BE:#utf-16be
	n.x-user-defined:#x-user-defined

	â—encoderï¼decoder IDL
dec.ç¬¦å·åŒ–æ³•:#textdecoder-encoding
dec.å¾©å·å™¨:#textdecoder-decoder
dec.~stream:#textdecoder-stream
dec.~BOMignore~flag:#textdecoder-ignore-bom-flag
dec.~BOMseen~flag:#textdecoder-bom-seen-flag
dec.~error~mode:#textdecoder-error-mode
dec.~no_flush~flag:#textdecoder-do-not-flush-flag
dec.~streamã‚’ç›´åˆ—åŒ–ã™ã‚‹:#concept-td-serialize

ts.å¾©å·å™¨:#textdecoderstream-decoder
ts.ç¬¦å·åŒ–å™¨:#textencoderstream-encoder
ts.~stream:#textdecoderstream-stream

~cuã‚’~scalarå€¤ã«å¤‰æ›ã™ã‚‹:#convert-code-unit-to-scalar-value
~chunkã‚’å¾©å·ã—ã¦~enqueueã™ã‚‹:#decode-and-enqueue-a-chunk
~chunkã‚’ç¬¦å·åŒ–ã—ã¦~enqueueã™ã‚‹:#encode-and-enqueue-a-chunk
ç¬¦å·åŒ–ã—ã¦ä¸€æƒã™ã‚‹:#encode-and-flush
ä¸€æƒã—ã¦~enqueueã™ã‚‹:#flush-and-enqueue

å‡¦ç†å¾…ã¡é«˜ä½~surrogate:#textencoderstream-pending-high-surrogate
å½¢å¼å¤‰æ›:#generictransformstream-transform


	â—å„ç¨® encoderï¼decoder

~UTF-8å¾©å·å™¨:#utf-8-decoder
~UTF-8ç¬¦å·åŒ–å™¨:#utf-8-encoder
å…±ç”¨~UTF-16å¾©å·å™¨:#shared-utf-16-decoder
~replacementå¾©å·å™¨:#replacement-decoder
~replacementã«ã‚ˆã‚‹~errorã¯ã™ã§ã«è¿”ã—ãŸ~flag:#replacement-error-returned-flag

å˜byteå¾©å·å™¨:#single-byte-decoder
å˜byteç¬¦å·åŒ–å™¨:#single-byte-encoder

~GBK~flag:#gbk-flag

~gb1:#gb18030-first
~gb2:#gb18030-second
~gb3:#gb18030-third

~gb18030å¾©å·å™¨:#gb18030-decoder
~gb18030ç¬¦å·åŒ–å™¨:#gb18030-encoder

~Big5~lead:#big5-lead
~Big5å¾©å·å™¨:#big5-decoder
~Big5ç¬¦å·åŒ–å™¨:#big5-encoder

~EUC-JP~lead:#euc-jp-lead
~EUC-JP~jis0212~flag:#euc-jp-jis0212-flag
~EUC-JPå¾©å·å™¨:#euc-jp-decoder
~EUC-JPç¬¦å·åŒ–å™¨:#euc-jp-encoder

~ISO-2022-JPå¾©å·å™¨:#iso-2022-jp-decoder
~ISO-2022-JPç¬¦å·åŒ–å™¨:#iso-2022-jp-encoder

~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹:#iso-2022-jp-decoder-state
~ISO-2022-JPå¾©å·å™¨~å‡ºåŠ›~çŠ¶æ…‹:#iso-2022-jp-decoder-output-state
~ISO-2022-JP~lead:#iso-2022-jp-lead
~ISO-2022-JPå‡ºåŠ›~flag:#iso-2022-jp-output-flag

i.ASCII:#iso-2022-jp-decoder-ascii
i.Roman:#iso-2022-jp-decoder-roman
i.katakana:#iso-2022-jp-decoder-katakana
i.~lead~byte:#iso-2022-jp-decoder-lead-byte
i.~trail~byte:#iso-2022-jp-decoder-trail-byte
i.~escapeé–‹å§‹:#iso-2022-jp-decoder-escape-start
i.~escape:#iso-2022-jp-decoder-escape

~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹:#iso-2022-jp-encoder-state
i1.ASCII:#iso-2022-jp-encoder-ascii
i1.Roman:#iso-2022-jp-encoder-roman
i1.jis0208:#iso-2022-jp-encoder-jis0208

~Shift_JIS~lead:#shift_jis-lead
~Shift_JISå¾©å·å™¨:#shift_jis-decoder
~Shift_JISç¬¦å·åŒ–å™¨:#shift_jis-encoder

~EUC-KR~lead:#euc-kr-lead
~EUC-KRå¾©å·å™¨:#euc-kr-decoder
~EUC-KRç¬¦å·åŒ–å™¨:#euc-kr-encoder

~UTF-16~lead~byte:#utf-16-lead-byte
~UTF-16~lead~surrogate:#utf-16-lead-surrogate
~UTF-16å¾©å·å™¨:#utf-16-decoder
~UTF-16LEå¾©å·å™¨:#utf-16le-decoder
~UTF-16BEå¾©å·å™¨:#utf-16be-decoder
~UTF-16BEå¾©å·å™¨~flag:#utf-16be-decoder-flag

~x-user-definedå¾©å·å™¨:#x-user-defined-decoder
~x-user-definedç¬¦å·åŒ–å™¨:#x-user-defined-encoder

	~byteåˆ—ã«å¤‰æ›-:#convert-a-code-unit-to-bytes

indexes.json:https://encoding.spec.whatwg.org/indexes.json

	â—ç”¨èªï¼ˆå¤–éƒ¨
jA.CreateTransformStream:~STREAMS#create-transform-stream
jA.TransformStreamDefaultControllerEnqueue:~STREAMS#transform-stream-default-controller-enqueue

~ASCII~byte:~INFRA#ascii-byte
~byte:~INFRA#byte
byte.é•·ã•:~INFRA#byte-sequence-length
~JSæ–‡å­—åˆ—:~INFRA#javascript-string
~scalarå€¤~æ–‡å­—åˆ—:~INFRA#scalar-value-string
~cu:~INFRA#code-unit
~cp:~INFRA#code-point
~scalarå€¤:~INFRA#scalar-value
~surrogate:~INFRA#surrogate
~ASCII~cp:~INFRA#ascii-code-point
	~ASCIIç©ºç™½:~INFRA#ascii-whitespace
~ASCIIæ•°å­—:~INFRA#ascii-digit
~ASCIIå¤§å°ç„¡è¦–:~INFRA#ascii-case-insensitive
~ASCIIå°æ–‡å­—~åŒ–:~INFRA#ascii-lowercase
~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹:~INFRA#ascii-lowercase
å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã:~INFRA#strip-leading-and-trailing-ascii-whitespace

å´ä¸‹ã•ã‚Œã‚‹~promise:~WEBIDL#a-promise-rejected-with
è§£æ±ºã•ã‚Œã‚‹~promise:~WEBIDL#a-promise-resolved-with

æŠ•å‡º-:~WEBIDL#dfn-throw
~IDLå€¤ã«å¤‰æ›-:~WEBIDL#dfn-convert-ecmascript-to-idl-value
è¤‡è£½ã‚’å–å¾—ã™ã‚‹:~WEBIDL#dfn-get-buffer-source-copy
~byteåˆ—ã¸ã®å‚ç…§ã‚’å–å¾—-:~WEBIDL#dfn-get-buffer-source-reference

~chunk:~STREAMS#chunk
å¯èª­~stream:~STREAMS#readable-stream
å¯æ›¸~stream:~STREAMS#writable-stream
å½¢å¼å¤‰æ›~stream:~STREAMS#transform-stream

_acks1:#_acks1

â—â—words_table1

bAND: <span class="op">&amp;</span> 
bOR: <span class="op">|</span> 
Lshift: <span class="op">&lt;&lt;</span>
Rshift: <span class="op">&gt;&gt;</span>

encoding0:encoding
UTF-8:<b class="ename">UTF-8</b> 
GBK:<b class="ename">GBK</b> 
gb18030:<b class="ename">gb18030</b> 
Big5:<b class="ename">Big5</b> 
EUC-JP:<b class="ename">EUC-JP</b> 
ISO-2022-JP:<b class="ename">ISO-2022-JP</b> 
Shift_JIS:<b class="ename">Shift_JIS</b> 
EUC-KR:<b class="ename">EUC-KR</b> 
jis0208:<b class="ename">jis0208</b> 
jis0212:<b class="ename">jis0212</b> 
replacement:<b class="ename">replacement</b> 
UTF-16BE:<b class="ename">UTF-16BE</b> 
UTF-16LE:<b class="ename">UTF-16LE</b> 
x-user-defined:<b class="ename">x-user-defined</b> 


â—â—words_table


	â—ä»•æ§˜
çµ±ä¸€çš„:universal:~
é•æ³•:illegal:~
è‡ªæ˜:trivial:~
ç¶²ç¾…çš„:exhaustive:~
ä¿å®ˆçš„:conservative:~
åˆæ³•:legitimate:~
ç§»è¡Œ-:move:~
å®Œå…¨ã•:completeness:~
	æ¨™æº–:Standard
	é–¢é€£ã—ãªã„:irrelevant
	çœç•¥æ™‚ã¯:optional
proprietary::::ãƒ—ãƒ­ãƒ—ãƒ©ã‚¤ã‚¨ã‚¿ãƒª
reverse-engineer:reverse engineer:::ãƒªãƒãƒ¼ã‚¹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢

èƒŒæ™¯:background:~
ç°¡æ˜:clear:~
éš”ãŸã‚Š:gap:~
é€²è¡Œä¸­:ongoing:~
éå»:past:~
å‡¡ä¾‹:legend:~
ç‰¹è³ª:property:~
å›ºå®ˆ-:adhere:~
è­¦å‘Š:warning:~
æ’ä»–çš„:exclusive:~
åæŸ:converge:~
ç©¶æ˜:investigation:~
æœ«ç«¯åˆ©ç”¨è€…:end user:~:::ã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶
æ‹¡æ•£-:spread:~
é€¸è„±-:deviate:~
æµå¸ƒ-:deploy:~
ç”Ÿç”£å´:producer:~
æ¶ˆè²»å´:consumer:~
æ¶ˆè²»è€…:consumer:~
è¦æ—¨-:outline:~
éœ§æ¶ˆ-:go away:~
åŒ…è£…-:wrap:~
	ã€œã‚’åŒ…è£…ã™ã‚‹:wrapper
å‘¨çŸ¥ã®:knownãª:~
	-:known
èª­è€…:reader:~
æ¼”ç¿’:exercise:~

	åŠ©åŠ›:help
	~~æ¨™æº–ã®:The
	~~è€ƒæ…®
	ä¸€å¼ã§:in combination with
	ã‚ˆã‚Š~~ä¸€èˆ¬çš„ã«ã¯:larger
	å‚™è€ƒ
	å…¥æ‰‹ã§ãã‚‹:available
	~~ååˆ†:fine
	åºƒã:widespread
	åº:Preface
	è¦ã€œ:ã€œ needed
	ä¸è¦:no need
	å¿…è¦:have to
	è¦‹ã‹ã‘ä¸Š:superficially
	èª¬æ˜:Notes
	å¸¸ã«ã€œé™ã‚‰ãªã„:not always
	ã«ã‚‚ã‹ã‹ã‚ã‚‰ãš:nonetheless
	å¾Œã®:future
	~~ä¸æ­£ãª:bogus
	é–¢ã™ã‚‹:-
	~~ç¾åœ¨ã®å§¿:what it is today
	ä»•ç«‹ã¦ä¸Šã’:-
	é…å‚™-æ¸ˆã¿:deployed
	ä¾›ã™ã‚‹:-
	ä¿ƒã™
	åˆ©ç”¨-ä¸­:in use
	åˆ©ç”¨ã•ã‚Œãªã„:unused
	ç”¨-æ³•ã®ä¸€ã¤ã‚’ç¤ºã™:demonstrates an approach one could take to use
	~~å¯¾å‡¦-:deal with
	~~å¯¾å‡¦:dealing with
	æº–ã˜ã‚‹:match
	çŸ¥ã‚‰ã‚Œ:knownï¼
		è¿½ã„æ˜“ã:easy to follow
	ç¤ºã•ã‚Œ:-
	å‘¼ã¶:-
	åŸ‹ã‚ã‚‹:-
	å£Šã™:break
	å¤‰ã‚ã£ã¦:change
	è¦‹ãˆãªã„:not see
	è¨˜ã•ã‚Œ
	è¨˜ã™
	ä¸€æ–¹ã§:whereas
	æ®‹ã—ã¦ãŠã:left as


	â—æœªåˆ†é¡
memory::::ãƒ¡ãƒ¢ãƒª
ä¸å¯åˆ†:atomic::~
åˆ†å‰²-:split:~
æ–­ç‰‡åŒ–:fragment åŒ–:~
å‰ç½®-:prefix::~
é‡è¤‡-:duplicate:~
é–‹å§‹:start:~

	ä¸€æ–°-:set anew
	è»¢æ›-:turn
	å¤±ã‚ã›:loss
	æˆ»ã™:back
	å‡ºãã‚ã—:hit
	~~ç©ºã„ãŸ:newly-vacated
	è¡¨ã™:signify
	å¯¾:combination
	è¢«ã›ãŸ:Layering ã€œ  on top
	åŠ ãˆ
	æŒ‡-:-
	å¾—ã‚‰ã‚Œ:-
	å¾—ã‚‹:-
	è¡Œã†

	â—networkï¼ä¿å®‰
é˜²ã:preventã™ã‚‹:~
ç´°å·¥:craft:~
æƒ…å ±å–ªå¤±:information loss:~
åˆæ„-:agree:~
ä¸ä¸€è‡´:mismatch:~
äº¤æ›:interchange:~
éš ã™:maskã™ã‚‹:~
éš ã›ãª:maskã§ããª:~
	çªã:abuse
	è‡³ã‚‰ã›:resulting in
	~~æ¤œçŸ¥ã•ã‚Œãšã«:silent

	â—ç¬¦å·åŒ–æ³•
CJK:
ç§ç”¨é ˜åŸŸ:Private Use Area:~
	é¦™æ¸¯å¢—è£œå­—ç¬¦é›†
	åŸºæœ¬å¤šè¨€èªé¢
	äº’æ›æ¼¢å­—

gb1:
gb2:
gb3:
jis0212:
jis0208:
	Roman
utf-16be:
UTF-16:
Hangul::::ãƒãƒ³ã‚°ãƒ«

å˜byte:single-byte::å˜ byte:å˜ãƒã‚¤ãƒˆ:ã‚·ãƒ³ã‚°ãƒ«ãƒã‚¤ãƒˆ
è¤‡byte:multi-byte::è¤‡ byte:è¤‡ãƒã‚¤ãƒˆ:ãƒãƒ«ãƒãƒã‚¤ãƒˆ
surrogate::::ã‚µãƒ­ã‚²ãƒ¼ãƒˆ
scalar::::ã‚¹ã‚«ãƒ©ãƒ¼
cp:code point::ç¬¦å·ä½ç½®::ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
cu:code unit::ç¬¦å·å˜ä½::ã‚³ãƒ¼ãƒ‰ãƒ¦ãƒ‹ãƒƒãƒˆ
æœ‰ç¬¦å·:coded::~::æœ‰ã‚³ãƒ¼ãƒ‰
ç´¢å¼•:index::~::ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
BOM:
BOMseen:BOM seen:BOM ç¢ºèªæ¸ˆã¿
BOMignore:ignore BOM:BOM ç„¡è¦–
ç°¡ä½“å­—:simplified::~
ç¹ä½“å­—:traditional::~
ç¯„å›²é›†:ranges::~
æ•°å­—:digit:~

ç¬¦å·åŒ–å™¨:encoder::~::ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€
å¾©å·å™¨:decoder::~::ãƒ‡ã‚³ãƒ¼ãƒ€
å½¢å¼:format::ãƒ‡ãƒ¼ã‚¿å½¢å¼::ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

åŠè§’:halfwidth::~
å…¨è§’:fullwidth::~
katakana::::ã‚«ã‚¿ã‚«ãƒŠ
Korean:
Japanese:
Chinese:

	ç©º~è¡Œl:empty string

	â—stream
streaming::::ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†
å¯èª­:readable::èª­ã¿å–ã‚Œã‚‹
èª­å–ã‚Œã‚‹:readã§ãã‚‹::èª­ã¿å–ã‚Œã‚‹
èª­å–ã‚‹:readã™ã‚‹::èª­ã¿å–ã‚‹
èª­å–ã‚‰ã‚Œ:readã•ã‚Œ::èª­ã¿å–ã‚‰ã‚Œ
èª­å–ã£:readã—::èª­ã¿å–ã£
	unread:ã€œã‚’å…ƒã«æˆ»ã™
å¯æ›¸:writable::æ›¸ãè¾¼ã‚ã‚‹
æ›¸è¾¼ã¾ã‚Œ:writeã•ã‚Œ::æ›¸ãè¾¼ã¾ã‚Œ
æ›¸è¾¼ã‚€:writeã™ã‚‹::æ›¸ãè¾¼ã‚€
åˆ¶å¾¡å™¨:controller::~
å½¢å¼å¤‰æ›:transform::~
EoS:end-of-stream::stream çµ‚ç«¯:ã‚¹ãƒˆãƒªãƒ¼ãƒ çµ‚ç«¯
chunk::::ãƒãƒ£ãƒ³ã‚¯
enqueue:
coder:
ä¸€æƒ-:flush::~
flush:
lead:::é ­éƒ¨
trail:::å°¾éƒ¨
é€£çµ-:concatenate:~

	å‰å¾Œã®:leading and trailing
	~bufferæº:bufferSource
	å‡ºåŠ›~chunk:outputChunk
	ä¸€æƒã™ã‚‹~algo:flushAlgorithm
	å½¢å¼å¤‰æ›~algo:transformAlgorithm
	é–‹å§‹~algo:startAlgorithm

	â—ä¸€èˆ¬å‡¦ç†
no_flush:do not flush:çŠ¶æ…‹ç¶­æŒ
ç¹°è¿”ã™:ç¹°ã‚Šè¿”ã™
å‡¦ç†å¾…ã¡:pending::~
æ¼”ç®—å¯¾è±¡:operand:~
çµ‚äº†-:terminate:~
å¾€æ¥-:roundtrip::~

ä¸‹é™:lower boundary::~
ä¸Šé™:upper boundary::~
åŒºåˆ‡å­:delimiter:~
ç¯„å›²æ¤œæŸ»:limit check:~
	ã€œãŒè¿”ã™å€¤:ã€œã® return value
	ã‹ã‘ãŸ:run through
	ã€œã«ã‹ã‘ã‚‹:runs them through
	å‡ºç¾~byteæ•°:byte seen
	fatal:
ç™ºã•ã‚Œ:emitã•ã‚Œ:~
	invocation
	æ¸¡ã™:pass


	â—ãƒ‡ãƒ¼ã‚¿å‹ï¼æ“ä½œï¼IDL
table::::ãƒ†ãƒ¼ãƒ–ãƒ«
shift::::ã‚·ãƒ•ãƒˆ
å†…åŒ…-:include::~
åŠ ç®—:addition:~
æ¸›ç®—:subtraction:~
ä¹—ç®—:multiplication:~
é™¤ç®—:division:~
å‰°ä½™:remainder:~
åŸºæ•°:base:~
å‰¥ã:stripã™ã‚‹:~

	â—æœªåˆ†é¡
è¢«è¦†åŸŸ:coverage:~
è¦†ã†:coverã™ã‚‹:~
ä¸€è¦§:table:~
ç²¾åº¦:precision:~
å§”è­²-:delegate:~
çµ„ç«‹ç›´ã›:reassembleã§ã:çµ„ã¿ç«‹ã¦ç›´ã›

	è¦–è¦š-åŒ–:visualize
	è¦–è¦š-åŒ–:visualization
	ç®—è¡“å¼:equation
	~~çµ±åˆ:Unified
	ä¼´ã‚ã‚Œãªã„:no ã€œ present
	å„ªå…ˆã•ã‚Œã‚‹:has priority overï¼more authoritative
	æ•°
	æ•°å€¤:number
	æ¡:digit
	ã€œé€²æ•°
	ã€œé€²è¡¨è¨˜
	~~å­¤ç«‹ã—ãŸ:lone

	â—æŒ‡ç¤ºèª
æœ€åˆã®:first:~
æœ€å¾Œã®:last:~
é«˜ä½:high:~

	å…¨ä½“çš„:overall
	å·¦ä¸Šéš…:top left corner
	ã‚ã‚‹ç¨‹åº¦:some extent
	æœªæº€:less than
	ä»–
	åŒã˜:ï¼
	å‰è¿°ã®:aforementioned
	å¾Œç¶šã®:later
	æœ€çŸ­:shortest
	ã‹ã¤ã¦ã®:former
	å…¨ãã®:fully
	è‹¥å¹²ã®:slight
	ä¸‹ä½:least significant
	é€†æ–¹å‘:vice versa
	ä¸¦ã³ï¼åˆ—:sequence
	ç›´å¾Œã«ç¶šã:follows immediately
	æˆç«‹-:true
	3 ç¨®ã®:three
	è‡ªèº«:themselves
	ä¸€éƒ¨ã‚’æˆã™:part of
	2 ã¤ã®ã€œã«:between
	å”¯ä¸€ã®ï¼ã®ã¿:only
	è¤‡æ•°:ï¼
	2 å›:twice
	æ§˜ã€…ãª:various
	å³è¾º:-
	å·¦è¾º:-
	å„ç¨®:-
	å¤šãã®:a lot of
	é™¤ã:but
	è¶…ãˆ:over
	è¶…ãˆãªã„:less than or equal to
	éš›ã—ã¦:-
	ãã®ç¨®ã®:such
	ä»–æ‰€:the rest of
	é …ç›®æ•°:items
	æ¬¡é …:-
	æ‹¬å¼§å†…:-
	çœç•¥-:without
	è¡Œ:row
	å†’é ­:-
	ç›¸äº’ã«:go from ã€œ and back
	ä¸€ã¤:one ofï¼:-
	ä¸»ã«:mostly
	æ¬¡å›:next
	ä¸€é€£ã®:ã€œs
	ä¸Š
	ä¸‹
	ã“ã‚Œä»¥ä¸Šã€œãªã„:To stop
	ãã‚Œä»¥ä¸Š:no more
	ä»¥ä¸‹:below
	ä¸­
	ä»¥å¤–:excluding
	ãã‚Œä»¥å¤–ã§ã¯:other than that
	ä½•ã‹:something
	ä½•ã‚‚:nothing
	å…¥ã‚‹:in
	åˆ—ç›®:-
	åˆ¥ã¨ã—ã¦
	å…ˆé ­:firstï¼
	å±ã™ã‚‹
	å¾Œè€…:-
	æ¬¡
	æ¬¡ã®
	ç¯€
	é¢
	è©²å½“-
	é–“
	å›
	å¾Œã¯
	æ™‚
	æœ€ã‚‚
	æœ«å°¾
	å€‹
	ä¸€æ–¹ã§
	ä¼´-
	å‚™ãˆã‚‹
	å³ï¼å·¦
	å¹´
	å¿œã˜ã¦
	æ–¹
	æ¸ˆã‚€
	æœ‰ç„¡:-
	ç„¡ã„
	ç‚¹ã§
	ç‰‡
	çš„
	ç•°ãªã‚‹
	æœ‰-
	ä¸‡
	çµ„
	è¡¨
	èª

	â—è¨³æ³¨
	ä¸‹è¨˜
	å…ˆã®
	ç·æ•°
	ä»£ç”¨å¯¾
	å«æ„-
	å›ºæœ‰ã®
	ä¿æŒ-
	å†…éƒ¨çŠ¶æ…‹
	åˆ¶ç´„-
	åŒºç‚¹ç•ªå·
	æ•°å€¤ã¨ã—ã¦
	æ•°å­—åˆ—
	è­˜åˆ¥å­
	æ—¥ä»˜
	æ™‚ç³»åˆ—çš„
	æ§‹é€ 
	æ©Ÿèƒ½
	å¤–å­—
	è§’æ‹¬å¼§
	è¨˜å·
	è¨˜æ³•
	è¨˜è¿°
	è¨³
	è¨³è€…
	è©¦ã™
	é›†åˆ
	é™çš„
	å¤‰æ•°
	è¿½åŠ 
	æ„å‘³
	æ„å‘³-
	è¡¨è¨˜è¦ç´„
	ç”¨ã„


â—â—ref_normative

[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[STREAMS]
    Adam Rice; Domenic Denicola; å‰é‡å‰›å² (Takeshi Yoshino). Streams Standard. Living Standard. URL: https://streams.spec.whatwg.org/ 
[UNICODE]
    The Unicode Standard. URL: https://www.unicode.org/versions/latest/ 
[WEBIDL]
    Boris Zbarsky. Web IDL. URL: https://heycam.github.io/webidl/

â—â—ref_informative

[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[XML]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml/


â—â—trans_metadata
<p>
~THIS_PAGEã¯ã€~WHATWGã«ã‚ˆã‚‹
<a href="https://encoding.spec.whatwg.org/">Encoding Standard</a>
ã‚’æ—¥æœ¬èªã«ç¿»è¨³ã—ãŸã‚‚ã®ã§ã™ã€‚
~PUB
</p>


â—â—spec_metadata

Participate:
	<a href="https://github.com/whatwg/encoding">GitHub whatwg/encoding</a> (<a href="https://github.com/whatwg/encoding/issues/new">new issue</a>, <a href="https://github.com/whatwg/encoding/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	https://github.com/whatwg/encoding/commits
	<a href="https://encoding.spec.whatwg.org/commit-snapshots/47c667e23f1002f26e4835d1d79ab0432add0e41/">Snapshot as of this commit</a>
	<a href="https://twitter.com/encodings">@encodings</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/encoding">web-platform-tests encoding/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/encoding">ongoing work</a>)

å„å›½èªç¿»è¨³ï¼ˆéè¦ç¯„çš„ï¼‰
	æ—¥æœ¬èªï¼ˆã“ã®ãƒšãƒ¼ã‚¸ï¼‰

</script>



</head>

<body>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxwYXRoIGQ9Im01MCwwbDUwLDUwLTUwLDUwLTUwLTUwIiBmaWxsPSIjM2M3OTBhIi8+DQo8cGF0aCBkPSJtMzgsNDBjMC0xMiwyNC0xNSwyMy0yYzAsOS0xNiwxMy0xNiwyM3Y3aDEwdi00YzAtOSwxNy0xMiwxNy0yN2MtMi0yMi00NS0yMi00NSwzem03LDMyaDEwdjEwaC0xMCIgZmlsbD0iI2ZmZiIvPg0KPC9zdmc+DQo="
></a>

	<hgroup>
<h1>Encoding â€” ç¬¦å·åŒ–æ³•</h1>
	</hgroup>

</header>

<main id="MAIN" hidden>
	<section id="preface">

<h2 title="Preface">1. åº</h2>

<p>
~UTF-8ç¬¦å·åŒ–æ³•ã¯ã€çµ±ä¸€çš„ãªæœ‰ç¬¦å·~æ–‡å­—~é›†åˆã§ã‚ã‚‹~Unicodeã®äº¤æ›ã«æœ€ã‚‚é©åˆ‡ãªç¬¦å·åŒ–æ³•ã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ï¼Œã“ã®ä»•æ§˜ã¯ã€æ–°ãŸãªï¼»
~protocolã¨å½¢å¼
ï¼½, ãŠã‚ˆã³ï¼»
æ–°ãŸãªæ–‡è„ˆ~ä¸‹ã§æµå¸ƒã•ã‚Œã‚‹æ—¢å­˜ã®å½¢å¼
ï¼½ã«å¯¾ã—ã€~UTF-8ç¬¦å·åŒ–æ³•ã‚’è¦æ±‚ã™ã‚‹ï¼ˆã¾ãŸï¼Œå®šç¾©ã™ã‚‹ï¼‰ã€‚
â—
The UTF-8 encoding is the most appropriate encoding for interchange of Unicode, the universal coded character set. Therefore for new protocols and formats, as well as existing formats deployed in new contexts, this specification requires (and defines) the UTF-8 encoding.
</p>

<p>
ç¬¦å·åŒ–æ³•ã«ã¯ï¼Œä»–ã®ã‚‚ã®ï¼ˆæ—§æ¥ã®ç¬¦å·åŒ–æ³•ï¼‰ã‚‚ã‚ã‚Šï¼Œéå»ã«ã‚ã‚‹ç¨‹åº¦ã¾ã§ã¯å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŒã€~UAé–“ã§å¸¸ã«åŒã˜ä»•æ–¹ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã¨ã¯é™ã‚‰ãªã„ã€‚
ã¾ãŸã€å¸¸ã«åŒã˜~labelã‚’åˆ©ç”¨ã™ã‚‹ã¨ã¯é™ã‚‰ãšã€ç¬¦å·åŒ–æ³•ã®ä¸­ã®æœªå®šç¾©ã®åŒºç”», ã‚ã‚‹ã„ã¯ ã‹ã¤ã¦ã®~proprietaryãªåŒºç”»ã¸ã®~~å¯¾å‡¦ã‚‚ï¼Œç›¸é•ã™ã‚‹ã“ã¨ãŒå¤šã„ã€‚
ã“ã®ä»•æ§˜ã¯ã€æ–°ãŸãªå®Ÿè£…ãŒç¬¦å·åŒ–æ³•~å®Ÿè£…ã‚’~reverse-engineerã›ãšã«æ¸ˆã‚€ã‚ˆã†ã«ï¼Œã¾ãŸ, æ—¢å­˜ã®~UAãŒä¸€ã¤ã«åæŸã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€ã“ã‚Œã‚‰ã®éš”ãŸã‚Šã‚’åŸ‹ã‚ã‚‹ã“ã¨ã«å–çµ„ã‚€ã€‚
â—
The other (legacy) encodings have been defined to some extent in the past. However, user agents have not always implemented them in the same way, have not always used the same labels, and often differ in dealing with undefined and former proprietary areas of encodings. This specification addresses those gaps so that new user agents do not have to reverse engineer encoding implementations and existing user agents can converge.
</p>

<p>
ç‰¹ã«ï¼Œã“ã®ä»•æ§˜ã¯ã€ãã‚Œã‚‰ã®ç¬¦å·åŒ–æ³•ã¨ï¼Œãã®ãã‚Œãã‚Œã«ãŠã‘ã‚‹ï¼»
~byteåˆ—ã¨`~scalarå€¤$ åˆ—ã‚’ç›¸äº’ã«å¤‰æ›ã™ã‚‹~algo
ï¼½, ãŠã‚ˆã³ä¸€é€£ã®ï¼»
`~label$ã‚’è­˜åˆ¥ã™ã‚‹æ­£æº–çš„ãªåå‰
ï¼½ã‚’å®šç¾©ã™ã‚‹ã€‚
ã¾ãŸã€ç¬¦å·åŒ–æ³•ã®å„ç¨®~algoã®ã†ã¡ä¸€éƒ¨ã‚’~JSã«å…¬é–‹ã™ã‚‹~APIã‚‚å®šç¾©ã™ã‚‹ã€‚
â—
In particular, this specification defines all those encodings, their algorithms to go from bytes to scalar values and back, and their canonical names and identifying labels. This specification also defines an API to expose part of the encoding algorithms to JavaScript.
</p>

<p>
~UAã¯ï¼Œã™ã§ã«
<a href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">IANA Character Sets registry</a>
ã«æŒ™ã’ã‚‰ã‚Œã¦ã„ã‚‹~labelã‹ã‚‰ã‚‚ æœ‰æ„ã«é€¸è„±ã—ã¦ã„ã‚‹ã€‚
æ—§æ¥ã®ç¬¦å·åŒ–æ³•ã‚’ ã“ã‚Œä»¥ä¸Š~æ‹¡æ•£ã•ã›ãªã„ãŸã‚ã€ã“ã®ä»•æ§˜ã¯ï¼Œå‰è¿°ã®è©³ç´°~ã«ã¤ã„ã¦ç¶²ç¾…çš„ã§ã‚ã‚Šï¼Œ registry ã¯ã‚‚ã†ä¸è¦ã§ã‚ã‚‹ã€‚
ç‰¹ã«ï¼Œã“ã®ä»•æ§˜ã¯ã€ç¬¦å·åŒ–æ³•ã‚’æ‹¡å¼µã™ã‚‹ãŸã‚ã®ä»•çµ„ã¿ã¯ä¾›ã•ãªã„ã€‚
â—
User agents have also significantly deviated from the labels listed in the IANA Character Sets registry. To stop spreading legacy encodings further, this specification is exhaustive about the aforementioned details and therefore has no need for the registry. In particular, this specification does not provide a mechanism for extending any aspect of encodings.
</p>

	</section>
	<section id="security-background">

<h2 title="Security background">2. ~securityã«é–¢ã™ã‚‹èƒŒæ™¯</h2>

<p>
ç¬¦å·åŒ–æ³•ã«ã¯ã€ã„ãã¤ã‹ï¼Œ~securityã®èª²é¡ŒãŒã‚ã‚‹
â€” ç”Ÿç”£å´ã¨æ¶ˆè²»å´ã®é–“ã§ï¼Œï¼»
åˆ©ç”¨-ä¸­ã®ç¬¦å·åŒ–æ³•, ã‚ã‚‹ã„ã¯æ‰€ä¸ã®ç¬¦å·åŒ–æ³•ã®å®Ÿè£…-æ³•
ï¼½ã«ã¤ã„ã¦åˆæ„ã•ã‚Œã¦ãªã„ã¨ãã«ã€‚
ä¾‹ãˆã° 2011 å¹´ã«ã¯ã€æ¬¡ã®ã‚ˆã†ãªæ”»æ’ƒãŒå ±å‘Šã•ã‚Œã¦ã„ã‚‹ï¼š
ãã“ã§ã¯ã€ï¼»
æ”»æ’ƒè€…ãŒä½•ã‚‰ã‹ã®~fieldã‚’åˆ¶å¾¡ã—å¾—ã‚‹ã‚ˆã†ãªï¼Œ JSON è³‡æº
ï¼½å†…ã® `22^X ~trail~byteã‚’ â€œéš ã™â€ ãŸã‚ã«ï¼Œ`Shift_JIS$n ã®~lead~byte `82^X ãŒåˆ©ç”¨ã•ã‚ŒãŸã€‚
ç”Ÿç”£å´ã‹ã‚‰ã¯ï¼Œã“ã‚ŒãŒé•æ³•ãª~byteå¯¾ã§ã‚ã£ã¦ã‚‚å•é¡ŒãŒè¦‹ãˆãªã„ä¸€æ–¹ã§ã€æ¶ˆè²»å´ã§ã¯ï¼Œã“ã®~byteå¯¾ã‚’å˜ç‹¬ã® `FFFD^U ã¨ã—ã¦å¾©å·ã™ã‚‹~~çµæœã€å…¨ä½“çš„ãªè§£é‡ˆãŒå¤‰ã‚ã£ã¦ã—ã¾ã† â€” `0022^U ã¯é‡è¦ãªåŒºåˆ‡å­ãªã®ã§ã€‚
ï¼»
`~scalarå€¤$ã«å¯¾ã—è¤‡æ•°~byteã‚’åˆ©ç”¨ã™ã‚‹ç¬¦å·åŒ–æ³•
ï¼½ã®å¾©å·å™¨ã«ã¯ã€ä»Šã‚„ï¼Œé•æ³•ãª~byteå¯¾ã®äº‹ä¾‹ã§ã¯ï¼Œï¼»
ç¯„å›² `0000^U ã€œ `007F^U ã«å…¥ã‚‹~scalarå€¤
ï¼½ã‚’ â€œéš ã›ãªã„â€ ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒè¦æ±‚ã•ã‚Œã‚‹
â€” å‰è¿°ã®~byteå¯¾ã«å¯¾ã—ã¦ã¯ã€å‡ºåŠ›ãŒï¼»
`FFFD^U `0022^U
ï¼½ã«ãªã‚‹ã‚ˆã†ã«ã€‚
â—
There is a set of encoding security issues when the producer and consumer do not agree on the encoding in use, or on the way a given encoding is to be implemented. For instance, an attack was reported in 2011 where a Shift_JIS lead byte 0x82 was used to â€œmaskâ€ a 0x22 trail byte in a JSON resource of which an attacker could control some field. The producer did not see the problem even though this is an illegal byte combination. The consumer decoded it as a single U+FFFD and therefore changed the overall interpretation as U+0022 is an important delimiter. Decoders of encodings that use multiple bytes for scalar values now require that in case of an illegal byte combination, a scalar value in the range U+0000 to U+007F, inclusive, cannot be â€œmaskedâ€. For the aforementioned sequence the output would be U+FFFD U+0022.
</p>

<p>
ã“ã‚Œã¯ã€ã‚ˆã‚Š~~ä¸€èˆ¬çš„ã«ã¯ï¼Œï¼»
~lead~byteãŒä¼´ã‚ã‚Œãªã„ã¨ãã«ï¼Œ`~ASCII~byte$ã‚’`~ASCII~cp$ã§ãªã„ä½•ã‹ã«å¯¾å¿œä»˜ã‘ã‚‹
ï¼½ã‚ˆã†ãªç¬¦å·åŒ–æ³•ã«ãŠã‘ã‚‹èª²é¡Œã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚‰ã¯ï¼Œ â€œ~ASCIIäº’æ›ã§ãªã„â€ ç¬¦å·åŒ–æ³•ã§ã‚ã‚Šã€ã‚ã„ã«ãï¼Œã™ã§ã«æµå¸ƒã•ã‚ŒãŸå†…å®¹ã®ãŸã‚ã«è¦æ±‚ã•ã‚Œã‚‹ãŒã€ï¼»
`ISO-2022-JP$n, `UTF-16BE$n, `UTF-16LE$n
ï¼½ä»¥å¤–ã®ã‚‚ã®ã¯ï¼Œ~supportã•ã‚Œãªã„ã€‚
ï¼ˆãã®ç¨®ã®ä»–ã®ç¬¦å·åŒ–æ³•`~label$ã«ã¤ã„ã¦ã‚‚ã€æœªçŸ¥ãªç¬¦å·åŒ–æ³•ã¸~fallbackã›ãšã«ï¼Œ`replacement$n ç¬¦å·åŒ–æ³•ã«å¯¾å¿œä»˜ã‘ã¦ã‚ˆã„ã‹ã©ã†ã‹ã®ç©¶æ˜ãŒ
<a href="https://github.com/whatwg/encoding/issues/8" title="Add more labels to the replacement encoding">é€²è¡Œä¸­ã«ã‚ã‚‹</a>
ã€‚ï¼‰
æ”»æ’ƒã®ä¸€~ä¾‹ã¨ã—ã¦ã€æ³¨æ„æ·±ãç´°å·¥ã•ã‚ŒãŸå†…å®¹ã‚’è³‡æºã®ä¸­ã¸æ³¨å…¥ã—ã¦ï¼Œåˆ©ç”¨è€…ã«ç¬¦å·åŒ–æ³•ã‚’ä¸Šæ›¸ãã™ã‚‹ã‚ˆã†ä¿ƒã™~~çµæœã€ä¾‹ãˆã°~scriptã®å®Ÿè¡Œã«è‡³ã‚‰ã›ã‚‹ã‚‚ã®ãŒã‚ã‚‹ã€‚
â—
This is a larger issue for encodings that map anything that is an ASCII byte to something that is not an ASCII code point, when there is no lead byte present. These are â€œASCII-incompatibleâ€ encodings and other than ISO-2022-JP, UTF-16BE, and UTF-16LE, which are unfortunately required due to deployed content, they are not supported. (Investigation is ongoing whether more labels of other such encodings can be mapped to the replacement encoding, rather than the unknown encoding fallback.) An example attack is injecting carefully crafted content into a resource and then encouraging the user to override the encoding, resulting in e.g. script execution.
</p>

<p>
~HTMLã‚„~HTMLã®~formç‰¹èƒ½ã«è¦‹å‡ºã•ã‚Œã‚‹~URLã«åˆ©ç”¨ã•ã‚Œã‚‹ç¬¦å·åŒ–å™¨ã‚‚ã€ãã®ç¬¦å·åŒ–æ³•ã«ã‚ˆã‚Šè¡¨ç¾ã§ããªã„~scalarå€¤ãŒã‚ã‚‹å ´åˆã«ã¯ï¼Œè‹¥å¹²ã®æƒ…å ±å–ªå¤±ã«ã¤ãªãŒã‚Šå¾—ã‚‹ã€‚
ä¾‹ãˆã°ï¼Œè³‡æºãŒ `windows-1252$n ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ã¨ãã€~serverã¯ï¼Œæœ«ç«¯åˆ©ç”¨è€…ãŒ~formã«æ‰‹å…¥åŠ›ã—ãŸ â€œğŸ’©â€ ã¨ â€œ&amp;#128169;â€ ã¨ã‚’åˆ¤åˆ¥ã§ããªããªã‚‹ã€‚
â—
Encoders used by URLs found in HTML and HTMLâ€™s form feature can also result in slight information loss when an encoding is used that cannot represent all scalar values. E.g. when a resource uses the windows-1252 encoding a server will not be able to distinguish between an end user entering â€œğŸ’©â€ and â€œ&amp;#128169;â€ into a form.
</p>

<p>
ã“ã“ã«è¦æ—¨ã—ãŸå•é¡Œã¯ã€~UTF-8ã‚’æ’ä»–çš„ã«åˆ©ç”¨ã—ã¦ã„ã‚‹ã¨ãã¯ï¼Œéœ§æ¶ˆã™ã‚‹ã€‚
ãã‚ŒãŒã€ä»Šã‚„ã™ã¹ã¦ã«å¯¾ã—~UTF-8ç¬¦å·åŒ–æ³•ãŒç¾©å‹™ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ç†ç”±ã®ä¸€ã¤ã§ã‚ã‚‹ã€‚
â—
The problems outlined here go away when exclusively using UTF-8, which is one of the many reasons that is now the mandatory encoding for all things.
</p>

<p class="note">æ³¨è¨˜ï¼š
<a href="#browser-ui">~browser UI</a> ç¯€ã‚‚è¦‹ã‚ˆã€‚
â—
See also the Browser UI chapter.
</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">3. å„ç¨®ç”¨èª</h2>

<p>
ã“ã®ä»•æ§˜ã¯ Infra Standard `INFRA$r ã«ä¾å­˜ã™ã‚‹ã€‚
â—
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
16 é€²æ•°ã«ã¯ "0x" ãŒå‰ç½®ã•ã‚Œã‚‹ã€‚
â—
Hexadecimal numbers are prefixed with "0x".
</p>

<div class="p">
<p>
ç®—è¡“å¼ã®ä¸­ã®ã™ã¹ã¦ã®æ•°å€¤ã¯æ•´æ•°ã§ã‚ã‚Šã€å„ç¨®~~æ¼”ç®—ã¯æ¬¡ã®è¨˜å·ã§è¡¨ç¾ã•ã‚Œã‚‹ï¼š
</p>

<table>
<thead><tr><th>è¨˜å·
<th>æ„å‘³
</thead><tbody>

<tr><th>~PLUS
<td>åŠ ç®—

<tr><th>~MINUS
<td>æ¸›ç®—

<tr><th>~INCBY
<td>å·¦è¾º~å€¤ã«å¯¾ã™ã‚‹å³è¾º~å€¤ã«ã‚ˆã‚‹åŠ ç®—

<tr><th>~DECBY
<td>å·¦è¾º~å€¤ã«å¯¾ã™ã‚‹å³è¾º~å€¤ã«ã‚ˆã‚‹æ¸›ç®—

<tr><th>~MUL
<td>ä¹—ç®—

<tr><th>~DIV
<td>æ•´æ•°ã®é™¤ç®—ï¼ˆå°æ•°åˆ‡ã‚Šæ¨ã¦ï¼‰

<tr><th>~MOD
<td>æ•´æ•°ã®é™¤ç®—ã®å‰°ä½™ï¼ˆ modulo ï¼‰

<tr><th>~Lshift
<td>è«–ç†-å·¦~shift

<tr><th>~Rshift
<td>è«–ç†-å³~shift

<tr><th>~bAND
<td>~bit AND

<tr><th>~bOR
<td>~bit OR

</tbody></table>

<p class="trans-note">ã€
è¨˜å· ~INCBY, ~DECBY ã¯è¨³è€…ã«ã‚ˆã‚‹è¿½åŠ ã€‚
ã€‘</p>

â—
In equations, all numbers are integers, addition is represented by "+", subtraction by "âˆ’", multiplication by "Ã—", integer division by "/" (returns the quotient), modulo by "%" (returns the remainder of an integer division), logical left shifts by "&lt;&lt;", logical right shifts by "&gt;&gt;", bitwise AND by "&amp;", and bitwise OR by "|".
</div>

<p>
è«–ç†-å³~shiftã®æ¼”ç®—å¯¾è±¡ã®ç²¾åº¦ã¯ã€å°‘ãªãã¨ã‚‚ 21 ~bitä»¥ä¸Šã«ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
For logical right shifts operands must have at least twenty-one bits precision.
</p>

<p>
`~token@
ã¯ã€`~byte$ã‚„`~scalarå€¤$ãªã©ã®ï¼Œ 1 å€‹ã®~dataç‰‡ã§ã‚ã‚‹ã€‚
â—
A token is a piece of data, such as a byte or scalar value.
</p>

<p>
`~stream@
ã¯ã€æœ‰é †åº`~token$åˆ—ã‚’è¡¨ç¾ã™ã‚‹ã€‚
`~EoS@
ã¯ã€`~stream$ã«ãã‚Œä»¥ä¸Š èª­å–ã‚Œã‚‹`~token$ã¯ç„¡ã„ã“ã¨ã‚’è¡¨ã™ï¼Œç‰¹åˆ¥ãª`~token$ã§ã‚ã‚‹ã€‚
â—
A stream represents an ordered sequence of tokens. End-of-stream is a special token that signifies no more tokens are in the stream.
</p>

<p class="trans-note">ã€
~streamã¨~tokenåˆ—ã¯ï¼ˆ â€œé™çš„ãªâ€ ï¼‰~dataæ§‹é€ ã¨ã—ã¦ã¯åŒã˜ã§ã‚‚ï¼Œ
 â€œ~streamâ€ ã«ã¯ï¼Œãã®~accessãŒï¼»
å…ˆé ­ï¼ˆå…¥åŠ›ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸå ´åˆï¼‰ï¼æœ«å°¾ï¼ˆå‡ºåŠ›~å…ˆã®å ´åˆï¼‰
ï¼½ã«ï¼ˆ â€œæ™‚ç³»åˆ—çš„ã«â€ ï¼‰åˆ¶ç´„ã•ã‚Œã‚‹ã“ã¨ãŒå«æ„ã•ã‚Œã‚‹ã€‚
ã€‘</p>

<div class="algorithm">
<p>
~streamã‹ã‚‰
`~tokenã‚’èª­å–ã‚‹@
ã¨ãã¯ã€æ‰€ä¸ã®
( `~stream$ %~stream )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
</p>
<ol>
	<li>
~IFï¼»
%~stream ã¯ç©ºã§ã‚ã‚‹
ï¼½
â‡’
~RET `~EoS$
</li>
	<li>
%~stream ã®å…ˆé ­ã‹ã‚‰ 1 å€‹ã®~tokenã‚’é™¤å»ã™ã‚‹
</li>
	<li>
~RET å‰~æ®µã§é™¤å»ã—ãŸ~token
</li>
</ol>

<!-- this means read is blocking on e.g. networking activity; SimonSapin thinks this is fine, curse him if not -->
â—
When a token is read from a stream, the first token in the stream must be returned and subsequently removed, and end-of-stream must be returned otherwise.
</div>

<div class="algorithm">
<p>
`~stream$ã« 1 å€‹~ä»¥ä¸Šã®`~token$ã‚’
`å‰ä»˜åŠ ã™ã‚‹@
ã¨ãã¯ã€ãã‚Œã‚‰ã®~tokenã‚’ï¼Œ~streamã®å…ˆé ­ã«, æ‰€ä¸ã®é †åºã‚’ä¿ã£ãŸã¾ã¾æŒ¿å…¥ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
When one or more tokens are prepended to a stream, those tokens must be inserted, in given order, before the first token in the stream.
</p>
</div>

<p class="example">
~tokenåˆ— "<code>&amp;#128169;</code>" ã‚’~stream "<code> hello world</code>" ã®å…ˆé ­ã«æŒ¿å…¥ã—ãŸçµæœã¯ï¼Œ~stream "<code>&amp;#128169; hello world</code>" ã«ãªã‚Šã€æ¬¡å›ã«èª­å–ã‚‰ã‚Œã‚‹~tokenã¯ <code>&amp;</code> ã«ãªã‚‹ã€‚
<!-- ğŸ’© --><!-- #x1F4A9 = 128169 decimal -->
â—
Inserting the sequence of tokens &amp;#128169; in a stream " hello world", results in a stream "&amp;#128169; hello world". The next token to be read would be &amp;.
</p>

<div class="algorithm">
<p>
`~stream$ã« 1 å€‹~ä»¥ä¸Šã®`~token$ã‚’
`~pushã™ã‚‹@
ã¨ãã¯ã€ãã‚Œã‚‰ã®~tokenã‚’ï¼Œ~streamã®æœ«å°¾ã«, æ‰€ä¸ã®é †åºã‚’ä¿ã£ãŸã¾ã¾ä»˜åŠ ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
When one or more tokens are pushed to a stream, those tokens must be inserted, in given order, after the last token in the stream.
</p>
</div>

	</section>
	<section id="_conventions">
<h2>ã€ã“ã®è¨³ã«å›ºæœ‰ã®è¡¨è¨˜è¦ç´„ã€‘</h2>

<p>
ã“ã®è¨³ã®ï¼Œ~algoã®è¨˜è¿°ã«åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹å„ç¨®è¨˜å·ï¼ˆæ­¤ã‚Œ, ~LET, ~IF, ~RET, ç­‰ã€…ï¼‰ã®æ„å‘³ã‚„å®šç¾©ã®è©³ç´°ã¯ã€~SYMBOL_DEF_REFã‚’~~å‚ç…§ã•ã‚ŒãŸã—ã€‚
åŠ ãˆã¦ã€æ¬¡ã®è¨˜æ³•ã‚‚ç”¨ã„ã‚‰ã‚Œã‚‹ï¼š
</p>

<table><thead><tr><th style="min-width: 10em;">è¨˜æ³•
<th>æ„å‘³
</thead>

<tbody>
<tr><th style="white-space:nowrap;">~byteåˆ— [ %value1, %value2, â€¦ ]
<td>
æ•°å€¤ã¨ã—ã¦ %value1, %value2 â€¦ ã¨åŒã˜å€¤ã‚’ã¨ã‚‹ä¸€é€£ã®`~byte$ã‹ã‚‰ãªã‚‹, æ‰€ä¸ã®é †åºã«ã‚ˆã‚‹ï¼Œæ–°ãŸãª`~token$åˆ—ã®~instanceã‚’è¡¨ã™ã€‚
è§’æ‹¬å¼§ã®ä¸­ãŒç©º
â€” â€œ~byteåˆ— [] â€ â€”
ã¨è¨˜ã•ã‚ŒãŸã¨ãã¯ï¼Œç©ºã®`~token$åˆ—ã‚’è¡¨ã™ã€‚

<tr><th style="white-space:nowrap;">~cp [ %value ]
<td>
æ•°å€¤ã¨ã—ã¦ %value ã¨åŒã˜å€¤ã‚’ã¨ã‚‹ 1 å€‹ã®`~cp$ã‹ã‚‰ãªã‚‹ï¼Œæ–°ãŸãª`~token$åˆ—ã®~instanceã‚’è¡¨ã™ã€‚

</tbody></table>

	</section>
	<section id="encodings">
<h2 title="Encodings">4. ç¬¦å·åŒ–æ³•</h2>

<p>
`ç¬¦å·åŒ–æ³•@
ï¼ˆ `encoding^en ï¼‰ã¯ã€`~scalarå€¤$ åˆ—ã‹ã‚‰~byteåˆ—ã¸ã®å¯¾å¿œä»˜ã‘
ã€ç¬¦å·åŒ–-ã€‘
ãŠã‚ˆã³é€†æ–¹å‘ã¸ã®å¯¾å¿œä»˜ã‘
ã€å¾©å·-ã€‘
ã‚’å®šç¾©ã™ã‚‹ã€‚
å„ `ç¬¦å·åŒ–æ³•$ã«ã¯ã€
`åå‰@
ãŠã‚ˆã³ï¼Œ 1 å€‹~ä»¥ä¸Šã®
`~label@
ãŒ<a href="#encoding-labels">ã‚ã¦ãŒã‚ã‚Œã¦ã„ã‚‹</a>ã€‚
â—
An encoding defines a mapping from a scalar value sequence to a byte sequence (and vice versa). Each encoding has a name, and one or more labels.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®ä»•æ§˜ã¯ã€~Unicodeæ¨™æº–ã«å®šç¾©ã•ã‚Œã‚‹ `encoding scheme^en ã¨ã—ã¦ï¼ŒåŒã˜åå‰ã‚’ä¼´ã† 3 ç¨®ã®`ç¬¦å·åŒ–æ³•$
â€” `UTF-8$n, `UTF-16LE$n, `UTF-16BE$n â€”
ã‚’å®šç¾©ã™ã‚‹ã€‚
`ç¬¦å·åŒ–æ³•$ã¯ã€~BOMï¼ˆ `byte order mark^en, â€œãƒã‚¤ãƒˆé †ãƒãƒ¼ã‚¯â€ ï¼‰ã®å–æ‰±ã„ã«ãŠã„ã¦ `encoding scheme^en ã‹ã‚‰ç›¸é•ã™ã‚‹
â€” ~BOMã®å–æ‰±ã„ã¯ã€ã“ã®ä»•æ§˜ã«ãŠã„ã¦ã¯ï¼»
`ç¬¦å·åŒ–æ³•$è‡ªèº«ã®ä¸€éƒ¨ã‚’æˆã™ä»£ã‚ã‚Šã«ï¼Œãã‚Œã‚’åŒ…è£…ã™ã‚‹~algoã®ä¸€éƒ¨ã‚’æˆã—ã¦ã„ã‚‹
ï¼½ä¸€æ–¹ã§ï¼Œ
~Unicodeæ¨™æº–ã«ãŠã„ã¦ã¯ `encoding scheme^en ã®å®šç¾©ã®ä¸€éƒ¨ã‚’æˆã™ã€‚
`~UTF-8å¾©å·ã™ã‚‹$~algoã¨ä¸€ç·’ã«åˆ©ç”¨ã•ã‚Œã‚‹ `UTF-8$n ã¯ã€åŒã˜åå‰ã® `encoding scheme^en ã«åˆè‡´ã™ã‚‹ã€‚
ã“ã®ä»•æ§˜ã¯ã€åŒæ§˜ã«å‘½åã•ã‚Œã‚‹ `encoding scheme^en ã«åˆè‡´ã™ã‚‹ã‚ˆã†ãªï¼»
`UTF-16LE$n ï¼ `UTF-16BE$n
ï¼½ã¨çµ„åˆã›ã¦åŒ…è£…ã™ã‚‹~algoã¯ï¼Œä¾›ã•ãªã„ã€‚
`UNICODE$r
â—
This specification defines three encodings with the same names as encoding schemes defined in the Unicode standard: UTF-8, UTF-16LE, and UTF-16BE. The encodings differ from the encoding schemes by byte order mark (also known as BOM) handling not being part of the encodings themselves and instead being part of wrapper algorithms in this specification, whereas byte order mark handling is part of the definition of the encoding schemes in the Unicode Standard. UTF-8 used together with the UTF-8 decode algorithm matches the encoding scheme of the same name. This specification does not provide wrapper algorithms that would combine with UTF-16LE and UTF-16BE to match the similarly-named encoding schemes. [UNICODE]
</p>

		<section id="encoders-and-decoders">
<h3 title="Encoders and decoders">4.1. ç¬¦å·åŒ–å™¨ã¨å¾©å·å™¨</h3>

<p>
å„ç¨® `ç¬¦å·åŒ–æ³•$ã«ã¯ã€ï¼»
`å¾©å·å™¨@
ï¼ˆ `decoder^en ï¼‰,
`ç¬¦å·åŒ–å™¨@
ï¼ˆ `encoder^en ï¼‰
ï¼½ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
å„ï¼»
`å¾©å·å™¨$ ï¼ `ç¬¦å·åŒ–å™¨$
ï¼½ã«ã¯ã€
`~handler@
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
`~handler$ã¯ã€
( `~stream$, 1 å€‹ã®`~token$ )
ã‚’å…¥åŠ›ã«ã¨ã‚Šï¼Œæ¬¡ã®ã„ãšã‚Œã‹ã‚’è¿”ã™~algoã§ã‚ã‚‹
â‡’ï¼ƒ
`å®Œé‚d@ ï¼
ç©ºã§ãªã„`~token$åˆ—â€  ï¼
`~error@ â€” ~optionã§`~cp$ã‚‚ä¼´ã„å¾—ã‚‹â€ â€  ï¼
`ç¶™ç¶š-@
â—
Each encoding has an associated decoder and most of them have an associated encoder. Each decoder and encoder have a handler algorithm. A handler algorithm takes an input stream and a token, and returns finished, one or more tokens, error optionally with a code point, or continue.
</p>

<p class="trans-note">ã€â€ 
ã»ã¨ã‚“ã©ã®å¾©å·å™¨ã®~handlerã¯ï¼Œ 1 å€‹ã®~cpã‹ã‚‰ãªã‚‹~tokenåˆ—ã‚’è¿”ã™ãŒã€
`~Big5å¾©å·å™¨$ã®~handlerã ã‘ï¼Œ 2 å€‹ã®~cpã‚’è¿”ã™å ´åˆãŒã‚ã‚‹ã€‚
ã€‘ã€â€ â€ 
ç¬¦å·åŒ–å™¨ã®~handlerã«é™ã‚Šã€å¸¸ã«ï¼Œ~cpã‚‚ä¼´ã†~errorã‚’è¿”ã™ã€‚
ã€‘</p>

<p class="note">æ³¨è¨˜ï¼š
ï¼»
`replacement$n, `UTF-16BE$n, `UTF-16LE$n
ï¼½`ç¬¦å·åŒ–æ³•$ã«ã¯ã€`ç¬¦å·åŒ–å™¨$ã¯ãªã„ã€‚
â—
The replacement, UTF-16BE, and UTF-16LE encodings have no encoder.
</p>

<p>
ä»¥ä¸‹ã§åˆ©ç”¨ã•ã‚Œã‚‹
`~error~mode@
ã¯ï¼š
â—
An error mode as used below isï¼¼
</p>
<ul>
	<li>
`å¾©å·å™¨$ã«ãŠã„ã¦ã¯ã€æ¬¡ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚‹
â‡’
`replacement^lï¼ˆæ—¢å®šï¼‰,
`fatal^l
â—
"replacement" (default) or "fatal" for a decoder andï¼¼
</li>
	<li>
`ç¬¦å·åŒ–å™¨$ã«ãŠã„ã¦ã¯ã€æ¬¡ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚‹
â‡’
`fatal^lï¼ˆæ—¢å®šï¼‰,
`html^l
â—
"fatal" (default) or "html" for an encoder.
</li>
</ul>

<p class="note">æ³¨è¨˜ï¼š
XML å‡¦ç†å™¨ã¯ã€ãã®`å¾©å·å™¨$ã®`~error~mode$ã‚’ `fatal^l ã«è¨­å®šã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
`XML$r
â—
An XML processor would set error mode to "fatal". [XML]
</p>

<p class="note">æ³¨è¨˜ï¼š
`~error~mode$ã« `html^l ãŒå­˜åœ¨ã™ã‚‹ã‚ã‘ã¯ã€~URLã‚„~HTML~formã«ãŠã„ã¦ã¯ï¼Œ`~error$ã«éš›ã—ã¦ã‚‚æ—§æ¥ã®`ç¬¦å·åŒ–å™¨$ã¯çµ‚äº†ã•ã›ãªã„å–æ‰±ã„ãŒè¦æ±‚ã•ã‚Œã‚‹ã“ã¨ã«å› ã‚‹ã€‚
`html^l `~error~mode$ã®ä¸‹ã§ã¯ã€åˆæ³•ãªå…¥åŠ›ã¨åˆ¤åˆ¥ã§ããªã„é€£åˆ—ãŒç™ºã•ã‚Œï¼Œ~~æ¤œçŸ¥ã•ã‚Œãšã«~dataãŒå¤±ã‚ã‚Œã‚‹ã€‚
ã“ã‚Œã‚’é˜²ããŸã‚ã€é–‹ç™ºè€…ã«ã¯ `UTF-8$n `ç¬¦å·åŒ–æ³•$ã®åˆ©ç”¨ãŒå¼·ãå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
`URL$r
`HTML$r
â—
html exists as error mode due to URLs and HTML forms requiring a non-terminating legacy encoder. The "html" error mode causes a sequence to be emitted that cannot be distinguished from legitimate input and can therefore lead to silent data loss. Developers are strongly encouraged to use the UTF-8 encoding to prevent this from happening. [URL] [HTML]
</p>

<div class="algorithm">
<p>
`ç¬¦å·åŒ–æ³•$ã®ï¼»
`å¾©å·å™¨$ ï¼ `ç¬¦å·åŒ–å™¨$
ï¼½ %~coder ã‚’
`èµ°ã‚‰ã™@
ã¨ãã¯ã€æ‰€ä¸ã®
â‡’ï¼ƒ
å…¥åŠ›`~stream$ %å…¥åŠ›,
å‡ºåŠ›`~stream$ %å‡ºåŠ›,
`~error~mode$ %~mode ï¼ˆçœç•¥æ™‚ã¯ Îµ ï¼‰
â—çµ‚
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To run an encodingâ€™s decoder or encoder encoderDecoder with input stream input, output stream output, and optional error mode mode, run these steps:
</p>
<ol>
	<li>
~IFï¼»
%~mode ~EQ Îµ
ï¼½
â‡’
%~mode ~SET %~coder ã«å¿œã˜ã¦
â‡’ï¼ƒ
`å¾©å·å™¨$ã§ã‚ã‚‹ãªã‚‰ã° `replacement^l ï¼
`ç¬¦å·åŒ–å™¨$ã§ã‚ã‚‹ãªã‚‰ã° `fatal^l
â—
If mode is not given, set it to "replacement", if encoderDecoder is a decoder, and "fatal" otherwise.
</li>
	<li>
%~coder~instance ~LET æ–°ãŸãª %~coder ã®~instance
â—
Let encoderDecoderInstance be a new encoderDecoder.
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
		<ol>
			<li>
%çµæœ ~LET  `~tokenã‚’å‡¦ç†ã™ã‚‹$( `~tokenã‚’èª­å–ã‚‹$( %å…¥åŠ› ), %~coder~instance, %å…¥åŠ›, %å‡ºåŠ›, %~mode )
â—
Let result be the result of processing the result of reading from input for encoderDecoderInstance, input, output, and mode.
</li>
			<li>
~IFï¼»
%çµæœ ~NEQ `ç¶™ç¶š-$
ï¼½
â‡’
~RET %çµæœ
â—
If result is not continue, return result.
â—
Otherwise, do nothing.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">
<p>
`~tokenã‚’å‡¦ç†ã™ã‚‹@
ã¨ãã¯ã€æ‰€ä¸ã®
â‡’ï¼ƒ
`~token$ %~token,
`ç¬¦å·åŒ–æ³•$ã®ï¼» `ç¬¦å·åŒ–å™¨$ï¼`å¾©å·å™¨$ ï¼½ã®~instance %~coder~instance,
å…¥åŠ›`~stream$ %å…¥åŠ›,
å‡ºåŠ›`~stream$ %å‡ºåŠ›,
`~error~mode$ %~modeï¼ˆçœç•¥æ™‚ã¯ Îµ ï¼‰
â—çµ‚
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To process a token token for an encodingâ€™s encoder or decoder instance encoderDecoderInstance, stream input, output stream output, and optional error mode mode, run these steps:
</p>
<ol>
	<li>
~IFï¼»
%~mode ~EQ Îµ
ï¼½
â‡’
%~mode ~SET %~coder~instance ã«å¿œã˜ã¦
â‡’ï¼ƒ
`å¾©å·å™¨$ã®~instanceã§ã‚ã‚‹ãªã‚‰ã° `replacement^l ï¼
`ç¬¦å·åŒ–å™¨$ã®~instanceã§ã‚ã‚‹ãªã‚‰ã° `fatal^l
â—
If mode is not given, set it to "replacement", if encoderDecoderInstance is a decoder instance, and "fatal" otherwise.
</li>
	<li>
~Assertï¼š
%~coder~instance ã¯`ç¬¦å·åŒ–å™¨$ã®~instanceã§ã‚ã‚‹ãªã‚‰ã°ã€
%~token ã¯`~surrogate$ã§ã¯ãªã„ã€‚
â—
Assert: if encoderDecoderInstance is an encoder instance, token is not a surrogate.
</li>
	<li>
%çµæœ ~LET æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ %~coder~instance ã®`~handler$ã‚’èµ°ã‚‰ã›ãŸçµæœ
â‡’
( %å…¥åŠ›, %~token )
â—
Let result be the result of running encoderDecoderInstanceâ€™s handler on input and token.
</li>
	<li>
~IFï¼»
%çµæœ ~IN { `ç¶™ç¶š-$, `å®Œé‚d$ }
ï¼½
â‡’
~RET %çµæœ
â—
If result is continue or finished, return result.
</li>
	<li>
<p>
~IFï¼»
%çµæœ ã¯ 1 å€‹~ä»¥ä¸Šã®`~token$ã§ã‚ã‚‹
ï¼½ï¼š
â—
Otherwise, if result is one or more tokens:
</p>
		<ol>
			<li>
%~coder~instance ã¯`å¾©å·å™¨$ã®~instanceã§ã‚ã‚‹ãªã‚‰ã°ã€
%çµæœ ã¯`~surrogate$ã‚’åŒ…å«ã—ãªã„ã€‚
â—
Assert: if encoderDecoderInstance is a decoder instance, result does not contain any surrogates.
</li>
			<li>
%å‡ºåŠ› ã« %çµæœ ã‚’`~pushã™ã‚‹$ï¼›
â—
Push result to output.
</li>
			<li>
~RET `ç¶™ç¶š-$
â—
â†“â†“</li>
		</ol>
	</li>
	<li>
~Assertï¼š
%çµæœ ã¯`~error$ã§ã‚ã‚‹
â—
Otherwise, if result is error,ï¼¼
</li>
	<li>
<p>
%~mode ã«å¿œã˜ã¦ï¼š
â—
switch on mode and run the associated steps:
</p>
		<dl class="switch">
			<dt>`replacement^l</dt>
			<dd>
%å‡ºåŠ› ã« `FFFD^U ã‚’`~pushã™ã‚‹$
â—
Push U+FFFD to output.
</dd>

			<dt>`html^l</dt>
			<dd>
%å…¥åŠ› ã«æ¬¡ã«ä¸ãˆã‚‹~cpåˆ—ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â‡’ï¼ƒ
`0026^U,
`0023^U,
%çµæœ ã®`~cp$ã‚’åŸºæ•° 10 ã«ã‚ˆã‚Šæœ€çŸ­ã§è¡¨ç¾ã™ã‚‹`~ASCIIæ•°å­—$åˆ—,
`003B^U
â—
Prepend U+0026, U+0023, followed by the shortest sequence of ASCII digits representing resultâ€™s code point in base ten, followed by U+003B to input.
</dd>
			<dd>
ã€ã™ãªã‚ã¡ã€ `&amp;#<var>æ•°å­—åˆ—</var>;^l ã€‘
</dd>

			<dt>`fatal^l</dt>
			<dd>
~RET `~error$
â—
Return error.
</dd>
		</dl>
	</li>
	<li>
~RET `ç¶™ç¶š-$
â—
Return continue.
</li>
</ol>
</div>

		</section>
		<section id="names-and-labels">
<h3 title="Names and labels">4.2. åå‰ã¨~label</h3>

<p>
~UAã¯ã€ä¸‹ã®ä¸€è¦§ã«æŒ™ã’ã‚‹`ç¬¦å·åŒ–æ³•$ã¨ãã‚Œã‚‰ã®`~label$ã™ã¹ã¦ã‚’~supportã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
~UAã¯ã€ä»–ã®`ç¬¦å·åŒ–æ³•$ã‚„`~label$ã¯~supportã—ãªã„ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The table below lists all encodings and their labels user agents must support. User agents must not support any other encodings or labels.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã©ã®ç¬¦å·åŒ–æ³•ã«ã¤ã„ã¦ã‚‚ã€ãã®`~label$ã®ã†ã¡ä¸€ã¤ã¯ï¼Œ`åå‰$ã‚’`~ASCIIå°æ–‡å­—~åŒ–$ã—ã¦å¾—ã‚‰ã‚Œã‚‹ã€‚
â—
For each encoding, ASCII-lowercasing its name yields one of its labels.
</p>

<p>
ä½œè€…ã¯ã€ `UTF-8$n `ç¬¦å·åŒ–æ³•$ã‚’åˆ©ç”¨ã—ãŸä¸Šã§ï¼Œãã®åˆ©ç”¨ãŒè­˜åˆ¥ã•ã‚Œã‚‹ã‚ˆã†ã«ï¼»
`~ASCIIå¤§å°ç„¡è¦–$ã§ `utf-8^lb ã«åˆè‡´ã™ã‚‹`~label$
ï¼½ã‚’åˆ©ç”¨ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
Authors must use the UTF-8 encoding and must use the ASCII case-insensitive "utf-8" label to identify it.
</p>

<p>
æ–°ãŸãªï¼»
~protocolã¨å½¢å¼
ï¼½, ã‚ã‚‹ã„ã¯ï¼»
æ–°ãŸãªæ–‡è„ˆ~ä¸‹ã§æµå¸ƒã•ã‚Œã‚‹æ—¢å­˜ã®å½¢å¼
ï¼½ã«ã¯ã€ `UTF-8$n `ç¬¦å·åŒ–æ³•$ãŒæ’ä»–çš„ã«åˆ©ç”¨ã•ã‚Œãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
ã“ã‚Œã‚‰ã®ï¼»
~protocolã‚„å½¢å¼
ï¼½ã®`ç¬¦å·åŒ–æ³•$ã®ï¼»
`åå‰$ã‚„`~label$
ï¼½ã¯ã€ `utf-8^lb ã¨ã—ã¦å…¬é–‹ã•ã‚Œãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
New protocols and formats, as well as existing formats deployed in new contexts, must use the UTF-8 encoding exclusively. If these protocols and formats need to expose the encodingâ€™s name or label, they must expose it as "utf-8".
</p>

<div class="algorithm">
<p>
`~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹@
ã¨ãã¯ã€æ‰€ä¸ã®
( æ–‡å­—åˆ— %~label )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To get an encoding from a string label, run these steps:
</p>
<ol>
	<li>
%~label ~SET `å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã$( %~label )
â—
Remove any leading and trailing ASCII whitespace from label.
</li>
	<li>
~IFï¼»
%~label ãŒä¸‹ã®ä¸€è¦§ã®ã„ãšã‚Œã‹ã®`~label$ã«`~ASCIIå¤§å°ç„¡è¦–$ã§åˆè‡´ã™ã‚‹
ï¼½
â‡’
~RET åˆè‡´ã—ãŸ`~label$ã«å¯¾å¿œã™ã‚‹`ç¬¦å·åŒ–æ³•$
â—
If label is an ASCII case-insensitive match for any of the labels listed in the table below, return the corresponding encoding, and failure otherwise.
</li>
	<li>
~RET `å¤±æ•—^i
â—
â†‘</li>
</ol>
</div>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®ï¼»
`~label$ã‚’`ç¬¦å·åŒ–æ³•$ã«å¯¾å¿œä»˜ã‘ã‚‹~algo
ï¼½ã¯ã€
<a href="https://www.unicode.org/reports/tr22/tr22-8.html#Charset_Alias_Matching">Unicode Technical Standard #22, 1.4 ç¯€</a>
ã«ã‚ˆã‚‹ã‚‚ã®ã‚ˆã‚ŠåŸºæœ¬çš„ã‹ã¤åˆ¶ç´„çš„ã§ã‚ã‚‹
â€” é…å‚™-æ¸ˆã¿ã®å†…å®¹ã¨äº’æ›ã«ãªã‚‹ã“ã¨ãŒå¿…è¦ã¨ã•ã‚Œã‚‹ã®ã§ã€‚
â—
This is a more basic and restrictive algorithm of mapping labels to encodings than section 1.4 of Unicode Technical Standard #22 prescribes, as that is necessary to be compatible with deployed content.
</p>

<table id="encoding-labels">
<thead><tr><th>`åå‰$â— Name
<th>`~label$â— Labels
</thead>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#the-encoding">~~æ¨™æº–ã®ç¬¦å·åŒ–æ³•</a>
â—
The Encoding
<tr><td>`UTF-8$n
<td>`unicode-1-1-utf-8^lb
`utf-8^lb
`utf8^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-single-byte-encodings">æ—§æ¥ã®å˜byteç¬¦å·åŒ–æ³•</a>
â—
Legacy single-byte encodings
<tr><td>`IBM866$n
<td>`866^lb
`cp866^lb
`csibm866^lb
`ibm866^lb
<tr><td>`ISO-8859-2$n
<td>`csisolatin2^lb
`iso-8859-2^lb
`iso-ir-101^lb
`iso8859-2^lb
`iso88592^lb
`iso_8859-2^lb
`iso_8859-2:1987^lb
`l2^lb
`latin2^lb
<tr><td>`ISO-8859-3$n
<td>`csisolatin3^lb
`iso-8859-3^lb
`iso-ir-109^lb
`iso8859-3^lb
`iso88593^lb
`iso_8859-3^lb
`iso_8859-3:1988^lb
`l3^lb
`latin3^lb
<tr><td>`ISO-8859-4$n
<td>`csisolatin4^lb
`iso-8859-4^lb
`iso-ir-110^lb
`iso8859-4^lb
`iso88594^lb
`iso_8859-4^lb
`iso_8859-4:1988^lb
`l4^lb
`latin4^lb
<tr><td>`ISO-8859-5$n
<td>`csisolatincyrillic^lb
`cyrillic^lb
`iso-8859-5^lb
`iso-ir-144^lb
`iso8859-5^lb
`iso88595^lb
`iso_8859-5^lb
`iso_8859-5:1988^lb
<tr><td>`ISO-8859-6$n
<td>`arabic^lb
`asmo-708^lb
`csiso88596e^lb
`csiso88596i^lb
`csisolatinarabic^lb
`ecma-114^lb
`iso-8859-6^lb
`iso-8859-6-e^lb
`iso-8859-6-i^lb
`iso-ir-127^lb
`iso8859-6^lb
`iso88596^lb
`iso_8859-6^lb
`iso_8859-6:1987^lb
<tr><td>`ISO-8859-7$n
<td>`csisolatingreek^lb
`ecma-118^lb
`elot_928^lb
`greek^lb
`greek8^lb
`iso-8859-7^lb
`iso-ir-126^lb
`iso8859-7^lb
`iso88597^lb
`iso_8859-7^lb
`iso_8859-7:1987^lb
`sun_eu_greek^lb
<tr><td>`ISO-8859-8$n
<td>`csiso88598e^lb
`csisolatinhebrew^lb
`hebrew^lb
`iso-8859-8^lb
`iso-8859-8-e^lb
`iso-ir-138^lb
`iso8859-8^lb
`iso88598^lb
`iso_8859-8^lb
`iso_8859-8:1988^lb
`visual^lb
<tr><td>`ISO-8859-8-I$n
<td>`csiso88598i^lb
`iso-8859-8-i^lb
`logical^lb
<tr><td>`ISO-8859-10$n
<td>`csisolatin6^lb
`iso-8859-10^lb
`iso-ir-157^lb
`iso8859-10^lb
`iso885910^lb
`l6^lb
`latin6^lb
<tr><td>`ISO-8859-13$n
<td>`iso-8859-13^lb
`iso8859-13^lb
`iso885913^lb
<tr><td>`ISO-8859-14$n
<td>`iso-8859-14^lb
`iso8859-14^lb
`iso885914^lb
<tr><td>`ISO-8859-15$n
<td>`csisolatin9^lb
`iso-8859-15^lb
`iso8859-15^lb
`iso885915^lb
`iso_8859-15^lb
`l9^lb
<tr><td>`ISO-8859-16$n
<td>`iso-8859-16^lb
<tr><td>`KOI8-R$n
<td>`cskoi8r^lb
`koi^lb
`koi8^lb
`koi8-r^lb
`koi8_r^lb
<tr><td>`KOI8-U$n
<td>`koi8-ru^lb
`koi8-u^lb
<tr><td>`macintosh$n
<td>`csmacintosh^lb
`mac^lb
`macintosh^lb
`x-mac-roman^lb
<tr><td>`windows-874$n
<td>`dos-874^lb
`iso-8859-11^lb
`iso8859-11^lb
`iso885911^lb
`tis-620^lb
`windows-874^lb
<tr><td>`windows-1250$n
<td>`cp1250^lb
`windows-1250^lb
`x-cp1250^lb
<tr><td>`windows-1251$n
<td>`cp1251^lb
`windows-1251^lb
`x-cp1251^lb
<tr><td>`windows-1252$n
<td>`ansi_x3.4-1968^lb
`ascii^lb
`cp1252^lb
`cp819^lb
`csisolatin1^lb
`ibm819^lb
`iso-8859-1^lb
`iso-ir-100^lb
`iso8859-1^lb
`iso88591^lb
`iso_8859-1^lb
`iso_8859-1:1987^lb
`l1^lb
`latin1^lb
`us-ascii^lb
`windows-1252^lb
`x-cp1252^lb
<tr><td>`windows-1253$n
<td>`cp1253^lb
`windows-1253^lb
`x-cp1253^lb
<tr><td>`windows-1254$n
<td>`cp1254^lb
`csisolatin5^lb
`iso-8859-9^lb
`iso-ir-148^lb
`iso8859-9^lb
`iso88599^lb
`iso_8859-9^lb
`iso_8859-9:1989^lb
`l5^lb
`latin5^lb
`windows-1254^lb
`x-cp1254^lb
<tr><td>`windows-1255$n
<td>`cp1255^lb
`windows-1255^lb
`x-cp1255^lb
<tr><td>`windows-1256$n
<td>`cp1256^lb
`windows-1256^lb
`x-cp1256^lb
<tr><td>`windows-1257$n
<td>`cp1257^lb
`windows-1257^lb
`x-cp1257^lb
<tr><td>`windows-1258$n
<td>`cp1258^lb
`windows-1258^lb
`x-cp1258^lb
<tr><td>`x-mac-cyrillic$n
<td>`x-mac-cyrillic^lb
`x-mac-ukrainian^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-chinese-(simplified)-encodings">æ—§æ¥ã®è¤‡byte~Chineseï¼ˆç°¡ä½“å­—ï¼‰ ç¬¦å·åŒ–æ³•</a>
â—
Legacy multi-byte Chinese (simplified) encodings
<tr><td>`GBK$n
<td>`chinese^lb
`csgb2312^lb
`csiso58gb231280^lb
`gb2312^lb
`gb_2312^lb
`gb_2312-80^lb
`gbk^lb
`iso-ir-58^lb
`x-gbk^lb
<tr><td>`gb18030$n
<td>`gb18030^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-chinese-(traditional)-encodings">æ—§æ¥ã®è¤‡byte~Chineseï¼ˆç¹ä½“å­—ï¼‰ç¬¦å·åŒ–æ³•</a>
â—
Legacy multi-byte Chinese (traditional) encodings
<tr><td>`Big5$n
<td>`big5^lb
`big5-hkscs^lb
`cn-big5^lb
`csbig5^lb
`x-x-big5^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-japanese-encodings">æ—§æ¥ã®è¤‡byte~Japaneseç¬¦å·åŒ–æ³•</a>
â—
Legacy multi-byte Japanese encodings
<tr><td>`EUC-JP$n
<td>`cseucpkdfmtjapanese^lb
`euc-jp^lb
`x-euc-jp^lb
<tr><td>`ISO-2022-JP$n
<td>`csiso2022jp^lb
`iso-2022-jp^lb
<tr><td>`Shift_JIS$n
<td>`csshiftjis^lb
`ms932^lb
`ms_kanji^lb
`shift-jis^lb
`shift_jis^lb
`sjis^lb
`windows-31j^lb
`x-sjis^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-korean-encodings">æ—§æ¥ã®è¤‡byte~Koreanç¬¦å·åŒ–æ³•</a>
â—
Legacy multi-byte Korean encodings
<tr><td>`EUC-KR$n
<td>`cseuckr^lb
`csksc56011987^lb
`euc-kr^lb
`iso-ir-149^lb
`korean^lb
`ks_c_5601-1987^lb
`ks_c_5601-1989^lb
`ksc5601^lb
`ksc_5601^lb
`windows-949^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-miscellaneous-encodings">æ—§æ¥ã®è«¸ã€…ã®ç¬¦å·åŒ–æ³•</a>
â—
Legacy miscellaneous encodings
<tr><td>`replacement$n
<td>`csiso2022kr^lb
`hz-gb-2312^lb
`iso-2022-cn^lb
`iso-2022-cn-ext^lb
`iso-2022-kr^lb
`replacement^lb
<tr><td>`UTF-16BE$n
<td>`utf-16be^lb
<tr><td>`UTF-16LE$n
<td>`utf-16^lb
`utf-16le^lb
<tr><td>`x-user-defined$n
<td>`x-user-defined^lb
	</tbody>
</table>

<p class="note">æ³¨è¨˜ï¼š
ã™ã¹ã¦ã®`ç¬¦å·åŒ–æ³•$ã¨ãã‚Œã‚‰ã®`~label$ã¯ã€è¦ç¯„çš„ã§ãªã„è³‡æº
`indexes.json$
ã‹ã‚‰ã‚‚å…¥æ‰‹ã§ãã‚‹ã€‚
â—
All encodings and their labels are also available as non-normative encodings.json resource.
</p>

		</section>
		<section id="output-encodings">
<h3 title="Output encodings">4.3 å‡ºåŠ›~ç¬¦å·åŒ–æ³•</h3>

<div class="algorithm">
<p>
`ç¬¦å·åŒ–æ³•ã‹ã‚‰å‡ºåŠ›~ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹@
ã¨ãã¯ã€æ‰€ä¸ã®
( `ç¬¦å·åŒ–æ³•$ %ç¬¦å·åŒ–æ³• )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To get an output encoding from an encoding encoding, run these steps:
</p>
<ol>
	<li>
~IFï¼»
%ç¬¦å·åŒ–æ³• ~IN
{ `replacement$n, `UTF-16BE$n, `UTF-16LE$n }
ï¼½
â‡’
~RET `UTF-8$n
â—
If encoding is replacement, UTF-16BE, or UTF-16LE, return UTF-8.
</li>
	<li>
~RET %ç¬¦å·åŒ–æ³•
â—
Return encoding.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®~algoã¯ã€ãã‚Œã‚’å¿…è¦ã¨ã™ã‚‹ï¼»
~URLã®æ§‹æ–‡è§£æ ï¼ ~HTML~formæå‡º
ï¼½ã«ã¦æœ‰ç”¨ã«ãªã‚‹ã€‚
â—
The get an output encoding algorithm is useful for URL parsing and HTML form submission, which both need exactly this.
</p>
</div>

		</section>
	</section>
	<section id="indexes">
<h2 title="Indexes">5. ç´¢å¼•</h2>

<p>
ã»ã¨ã‚“ã©ã®æ—§æ¥ã®`ç¬¦å·åŒ–æ³•$ã§ã¯ã€
ã€ç¬¦å·åŒ–æ³•ã”ã¨ã«å›ºæœ‰ã®ã€‘
`ç´¢å¼•@
ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
`ç´¢å¼•$ã¨ã¯ã€ä¸€é€£ã®~entryã‹ã‚‰ãªã‚‹æœ‰é †åº~listã§ã‚ã‚Šã€å„~entryã¯ï¼»
~pointerã¨, ãã‚Œã«å¯¾å¿œã™ã‚‹~cp
ï¼½ã‹ã‚‰ãªã‚‹çµ„ã§ã‚ã‚‹ã€‚
`ç´¢å¼•$ã®ä¸­ã§ã¯ã€~pointerã¯ä¸€æ„ã§ã‚ã‚Šï¼Œ~cpã¯é‡è¤‡ã—å¾—ã‚‹ã€‚
â—
Most legacy encodings make use of an index. An index is an ordered list of entries, each entry consisting of a pointer and a corresponding code point. Within an index pointers are unique and code points can be duplicated.
</p>

<p class="note">æ³¨è¨˜ï¼š
åŠ¹ç‡çš„ãªå®Ÿè£…ã¯ã€`ç¬¦å·åŒ–æ³•$ã”ã¨ã«ï¼Œãã®`å¾©å·å™¨$ã¨`ç¬¦å·åŒ–å™¨$ã®ãã‚Œãã‚Œã«æœ€é©åŒ–ã•ã‚ŒãŸï¼Œ 2 ã¤ã®`ç´¢å¼•$ã‚’å‚™ãˆã‚‹ã“ã¨ã«ãªã‚‹ã§ã‚ã‚ã†ã€‚
â—
An efficient implementation likely has two indexes per encoding. One optimized for its decoder and one for its encoder.
</p>

<div class="algorithm">
<p>
`ç´¢å¼•$
ã€ã®~dataã‚’ä¾›ã™ã‚‹ä¸‹è¨˜ã®è³‡æºã€‘
ã‹ã‚‰ï¼Œ~pointerã¨ãã‚Œã«å¯¾å¿œã™ã‚‹~cpã‚’è¦‹å‡ºã™ãŸã‚ã«ã¯ï¼š
</p>
<ol>
	<li>
ã¾ãšã€ %è¡Œl~list ã‚’ãã®è³‡æºã®å†…å®¹ã‚’ `000A^U ã§ä¸€é€£ã® â€œè¡Œlâ€ ã«åˆ†å‰²ã—ãŸçµæœã¨ã™ã‚‹ã€‚
</li>
	<li>
%è¡Œl~list ã‹ã‚‰ï¼»
ç©º~è¡Œl ï¼ `0023^U ã§é–‹å§‹ã•ã‚Œã‚‹è¡Œl
ï¼½ã‚’ã™ã¹ã¦é™¤å»ã™ã‚‹ã€‚
</li>
	<li>
<p>
%è¡Œl~list ã®å„~è¡Œlã«å¯¾ã—ï¼Œè¡Œlã‚’ `0009^U ã§åˆ†å‰²ã—ãŸã¨ãã®ï¼š
</p>

<ul ><li>1 å€‹ç›®ã®~itemãŒ~pointerï¼ˆ 10 é€²è¡¨è¨˜ï¼‰ã‚’ä¸ãˆã‚‹ã€‚
</li><li>2 å€‹ç›®ã®~itemãŒå¯¾å¿œã™ã‚‹~cpï¼ˆ 16 é€²è¡¨è¨˜ï¼‰ã‚’ä¸ãˆã‚‹ã€‚
</li><li>ä»–ã®~itemã¯é–¢é€£ã—ãªã„ã€‚
</li></ul>
	</li>
</ol>

â—
To find the pointers and their corresponding code points in an index, let lines be the result of splitting the resourceâ€™s contents on U+000A. Then remove each item in lines that is the empty string or starts with U+0023. Then the pointers and their corresponding code points are found by splitting each item in lines on U+0009. The first subitem is the pointer (as a decimal number) and the second is the corresponding code point (as a hexadecimal number). Other subitems are not relevant.
</div>

<p class="note">æ³¨è¨˜ï¼š
å„`ç´¢å¼•$ã®å†’é ­ã«ã¯ã€å¤‰æ›´ã®æœ‰ç„¡ã‚’è¨˜ã™ãŸã‚ï¼Œ
`Identifier^i ã¨ `Date^i
ã€è­˜åˆ¥å­ã¨æ—¥ä»˜ã€‘
ãŒè¨˜ã•ã‚Œã¦ã„ã‚‹ã€‚
`Identifier^i ã®å¤‰åŒ–ã¯ã€`ç´¢å¼•$ã«å¤‰æ›´ãŒåŠ ãˆã‚‰ã‚ŒãŸã“ã¨ã‚’è¡¨ã™ã€‚
â—
To signify changes an index includes an Identifier and a Date. If an Identifier has changed, so has the index.
</p>

<p>
%ç´¢å¼• ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™
`ç´¢å¼•~cp@
ã¨ã¯ã€
%ç´¢å¼• å†…ã« %~pointer ãŒï¼»
åœ¨ã‚‹ãªã‚‰ã°ï¼Œãã‚Œã«å¯¾å¿œã™ã‚‹~cp ï¼
ç„¡ã‘ã‚Œã° ~NULL
ï¼½ã§ã‚ã‚‹ã€‚
â—
The index code point for pointer in index is the code point corresponding to pointer in index, or null if pointer is not in index.
</p>

<p>
%ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™
`ç´¢å¼•~pointer@
ã¨ã¯ã€
%ç´¢å¼• å†…ã« %~cp ã«å¯¾å¿œã™ã‚‹~pointerãŒï¼»
åœ¨ã‚‹ãªã‚‰ã°ï¼Œãã‚Œã‚‰ã®ã†ã¡ã®`æœ€åˆã®^em ~pointer ï¼
ç„¡ã‘ã‚Œã° ~NULL
ï¼½ã§ã‚ã‚‹ã€‚
â—
The index pointer for code point in index is the first pointer corresponding to code point in index, or null if code point is not in index.
</p>

<div class="note" id="visualization">
<p>æ³¨è¨˜ï¼š
å„ ç´¢å¼•ã«ã¯ï¼Œè¦ç¯„çš„ã§ãªã„è¦–è¦š-åŒ–ãŒã‚ã‚Šã€`ç´¢å¼•~jis0208$ã«ã¯ï¼Œ `Shift_JIS$n è¦–è¦š-åŒ–ã‚‚åˆ¥ã«ã‚ã‚‹ã€‚
åŠ ãˆã¦ï¼ŒåŸºæœ¬å¤šè¨€èªé¢ï¼ˆ
BMPï¼ˆ `Basic Multilingual Plane^en ï¼‰,
`0000^U ã€œ `FFFF^U
ï¼‰ã«ãŠã‘ã‚‹è¢«è¦†åŸŸã®è¦–è¦š-åŒ–ã‚‚ã‚ã‚‹ã€‚
ãŸã ã—ã€ï¼»
`ç´¢å¼•~gb18030ç¯„å›²é›†$ ï¼ `ç´¢å¼•~ISO-2022-JP~katakana$
ï¼½ã«ã¯ï¼Œã“ã‚Œã‚‰ã®è¦–è¦š-åŒ–ã¯ãªã„ã€‚
â—
There is a non-normative visualization for each index other than index gb18030 ranges and index ISO-2022-JP katakana. index jis0208 also has an alternative Shift_JIS visualization. Additionally, there is visualization of the Basic Multilingual Plane coverage of each index other than index gb18030 ranges and index ISO-2022-JP katakana.
</p>

<table>
<caption>
è¦–è¦š-åŒ–ã«ãŠã‘ã‚‹å‡¡ä¾‹
â—
The legend for the visualizations is:
</caption>

<thead><tr><th>è¡¨ç¤º
<th>~~èª¬æ˜
</thead>

<tbody class="_vis-visualizationlegend">
<tr><td><div class="_vis-unmapped"></div><td>
å¯¾å¿œã™ã‚‹~cpã¯ç„¡ã„ã€‚
â—
Unmapped

<tr><td><div class="_vis-mid"></div><td>
~UTF-8ã§ 2 ~byteã€‚
â—
Two bytes in UTF-8

<tr><td><div class="_vis-mid _vis-contiguous"></div><td>
~UTF-8ã§ 2 ~byte, ã‹ã¤
~cpã¯ã€å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Two bytes in UTF-8, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-upper"></div><td>
~UTF-8ã§ 3 ~byteï¼ˆç§ç”¨é ˜åŸŸã§ãªã„ï¼‰
â—
Three bytes in UTF-8 (non-PUA)

<tr><td><div class="_vis-upper _vis-contiguous"></div><td>
~UTF-8ã§ 3 ~byteï¼ˆç§ç”¨é ˜åŸŸã§ãªã„ï¼‰, ã‹ã¤
~cpã¯ã€å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Three bytes in UTF-8 (non-PUA), code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-pua"></div><td>
ç§ç”¨é ˜åŸŸ
â—
Private Use

<tr><td><div class="_vis-pua _vis-contiguous"></div><td>
ç§ç”¨é ˜åŸŸ, ã‹ã¤
~cpã¯ã€å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Private Use, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-astral"></div><td>
~UTF-8ã§ 4 ~byte
â—
Four bytes in UTF-8

<tr><td><div class="_vis-astral _vis-contiguous"></div><td>
~UTF-8ã§ 4 ~byte, ã‹ã¤
~cpã¯ã€å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Four bytes in UTF-8, code point follows immediately the code point
of previous pointer

<tr><td><div class="_vis-duplicate"></div><td>
å…ˆã«ç¾ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨é‡è¤‡ã™ã‚‹~cpã«å¯¾å¿œã™ã‚‹ã€‚
â—
Duplicate code point already mapped at an earlier index

<tr><td><div class="_vis-compatibility"></div><td>
~CJKäº’æ›æ¼¢å­—ï¼ˆ `CJK Compatibility Ideograph^en ï¼‰
â—
CJK Compatibility Ideograph

<tr><td><div class="_vis-ext"></div><td>
~CJKçµ±åˆæ¼¢å­—æ‹¡å¼µ A
â—
CJK Unified Ideographs Extension A

</tbody>
</table>

</div>

<p>
ã“ã®ä»•æ§˜ãŒå®šç¾©ã™ã‚‹`ç´¢å¼•$ã®ã†ã¡ï¼Œ`å˜byteç´¢å¼•$ã§ãªã„ã‚‚ã®ã«ã¯ã€ãã‚Œãã‚Œã«è‡ªå‰ã®~tableãŒã‚ã‚Šï¼Œä»¥ä¸‹ã«ä¸ãˆã‚‰ã‚Œã‚‹ï¼š
ã€è¦–è¦š-åŒ–ï¼è¢«è¦†åŸŸã®~tableã¯å·¨å¤§ãªã“ã¨ã«æ³¨æ„ã€‘
â—
These are the indexes defined by this specification, excluding index single-byte, which have their own table:
</p>

<table id="_index_list" class="grid-table">
<thead><tr><th>`åå‰$
<th>`ç´¢å¼•$
<th>è¦–è¦š-åŒ–
<th>åŸºæœ¬å¤šè¨€èªé¢ï¼ˆ BMP ï¼‰ã®è¢«è¦†åŸŸ
<th>å‚™è€ƒ
</thead><tbody>

<tr><td>`ç´¢å¼•~Big5@
<td>`Big5$idx
<td>
ã“ã‚Œã¯ã€é¦™æ¸¯å¢—è£œå­—ç¬¦é›†ï¼ˆ `Hong Kong Supplementary Character Set^en ï¼‰, ãŠã‚ˆã³ä»–ã®å…±é€šã®æ‹¡å¼µã¨ä¸€å¼ã§ã€~Big5æ¨™æº–ã«åˆè‡´ã™ã‚‹ã€‚
â—
This matches the Big5 standard in combination with the Hong Kong Supplementary Character Set and other common extensions.

<tr><td>`ç´¢å¼•~EUC-KR@
<td>`EUC-KR$idx
<td>
ã“ã‚Œã¯ã€ KS X 1001 æ¨™æº–ã¨~~çµ±åˆ~Hangul~codeï¼ˆ `Unified Hangul Code^en ï¼‰ã«åˆè‡´ã™ã‚‹ã€‚
Windows Codepage 949 ã¨ã—ã¦ã‚‚å…±é€šçš„ã«çŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
ã“ã‚Œå…¨ä½“ã§ã€~Unicodeã®~HanguléŸ³ç¯€æ–‡å­—ï¼ˆ `Hangul Syllables^en ï¼‰~blockã‚’è¦†ã†ã€‚
~Hangul~blockã®ã†ã¡ï¼Œè¦–è¦š-åŒ–ã«ãŠã‘ã‚‹å·¦ä¸Šéš…ãŒ~pointer 9026 ã«ã‚ã‚‹ã‚‚ã®
ã€ï¼Ÿã€‘
ã¯ã€~Unicodeé †ã«ä¸¦ã¶ã€‚
`Taken separately^en ã€ï¼Ÿã€‘,
ã“ã®ç´¢å¼•ã«ãŠã‘ã‚‹æ®‹ã‚Šã®~HanguléŸ³ç¯€æ–‡å­—ã‚‚ã€~Unicodeé †ã«ä¸¦ã¶ã€‚
â—
This matches the KS X 1001 standard and the Unified Hangul Code, more commonly known together as Windows Codepage 949. It covers the Hangul Syllables block of Unicode in its entirety. The Hangul block whose top left corner in the visualization is at pointer 9026 is in the Unicode order. Taken separately, the rest of the Hangul syllables in this index are in the Unicode order, too.

<tr><td>`ç´¢å¼•~gb18030@
<td>`gb18030$idx
<td>
ã“ã‚Œã¯ã€å„~cpãŒ 2 ~byteã«ç¬¦å·åŒ–ã•ã‚Œã‚‹ GB18030-2005 æ¨™æº–ã«åˆè‡´ã™ã‚‹
â€” ãŸã ã—ï¼Œé…å‚™-æ¸ˆã¿ã®å†…å®¹ã¨äº’æ›ã«ãªã‚‹ã‚ˆã†ã€ `A3^X `A0^X ã¯ `3000^U ã«å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
ã“ã®ç´¢å¼•~å…¨ä½“ã§ã€~Unicodeã®~CJKçµ±åˆæ¼¢å­—ï¼ˆ `CJK Unified Ideographs^en ï¼‰~blockã‚’è¦†ã†ã€‚
ãã®~blockå†…ã®~entryã®ã†ã¡ï¼Œè¦–è¦š-åŒ–ã«ãŠã‘ã‚‹ï¼ˆæœ€åˆã®ï¼‰ `3000^U ã‚ˆã‚Šä¸Šã¾ãŸã¯å·¦ã«ã‚ã‚‹ã‚‚ã®ã¯ã€~Unicodeé †ã«ä¸¦ã¶ã€‚
â—
This matches the GB18030-2005 standard for code points encoded as two bytes, except for 0xA3 0xA0 which maps to U+3000 to be compatible with deployed content. This index covers the CJK Unified Ideographs block of Unicode in its entirety. Entries from that block that are above or to the left of (the first) U+3000 in the visualization are in the Unicode order.

<tr><td>`ç´¢å¼•~gb18030ç¯„å›²é›†@
<td>`gb18030-ranges$idx
<td>
ã“ã®`ç´¢å¼•$ã¯ã€ã™ã¹ã¦ã®~cpã‚’æŒ™ã’ã¦ã„ãã¨é …ç›®æ•°ãŒ 100 ä¸‡ã‚’è¶…ãˆã¦ã—ã¾ã†ç‚¹ã§ï¼Œä»–ã®ã™ã¹ã¦ã¨ç•°ãªã‚‹ï¼ˆ 207 é¢ã®ç¯„å›²ã¨è‡ªæ˜ãªç¯„å›²æ¤œæŸ»ã«ã‚ˆã‚Šï¼Œãã‚Œã„ã«è¡¨ç¾ã§ãã‚‹ãŒï¼‰ã€‚
ã—ãŸãŒã£ã¦ã€ 4 ~byte ã«ç¬¦å·åŒ–ã•ã‚Œã‚‹~cpã«ã¤ã„ã¦ã®ã¿ï¼Œè¦‹ã‹ã‘ä¸Š GB18030-2005 æ¨™æº–ã«åˆè‡´ã™ã‚‹ã€‚
ä¸‹ã®ï¼»
`ç´¢å¼•~gb18030ç¯„å›²é›†~cp$ ï¼
`ç´¢å¼•~gb18030ç¯„å›²é›†~pointer$
ï¼½ã‚‚è¦‹ã‚ˆã€‚
â—
This index works different from all others. Listing all code points would result in over a million items whereas they can be represented neatly in 207 ranges combined with trivial limit checks. It therefore only superficially matches the GB18030-2005 standard for code points encoded as four bytes. See also index gb18030 ranges code point and index gb18030 ranges pointer below.

<tr><td>`ç´¢å¼•~jis0208@
<td>`jis0208$idx
<td>
IBM ã¨ NEC ã«ã‚ˆã‚‹ã‹ã¤ã¦ã®~proprietaryæ‹¡å¼µã‚‚å«ã¾ã‚Œã¦ã„ã‚‹ï¼Œ JIS X 0208 æ¨™æº–ã€‚
â—
This is the JIS X 0208 standard including formerly proprietary extensions from IBM and NEC.

<tr><td>`ç´¢å¼•~jis0212@
<td>`jis0212$idx
<td>
JIS X 0212 æ¨™æº–ã€‚
ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã®ã¯ã€`~EUC-JPå¾©å·å™¨$ã«é™ã‚‰ã‚Œã‚‹ï¼ˆç¬¦å·åŒ–å™¨ã‹ã‚‰ã¯åˆ©ç”¨ã•ã‚Œãªã„ï¼‰
â€” åºƒã~supportã•ã‚Œã¦ã„ãªã„ã®ã§ã€‚
â—
This is the JIS X 0212 standard. It is only used by the EUC-JP decoder due to lack of widespread support elsewhere.

<tr><td>`ç´¢å¼•~ISO-2022-JP~katakana@
<td>`iso-2022-jp-katakana$idx
<td>
ã“ã‚Œã¯ã€
`Unicode Normalization Form KC^en
ã«å¾“ã£ã¦ï¼ŒåŠè§’~katakanaã‚’å…¨è§’~katakanaã«å¯¾å¿œä»˜ã‘ã‚‹ã€‚
ãŸã ã—ã€ï¼»
`FF9E^U ï¼ `FF9F^U
ï¼½ã¯ï¼»
`309B^U ï¼ `309C^U
ï¼½ã«å¯¾å¿œä»˜ã‘ã‚‹
â€” ï¼»
`3099^U ï¼ `309A^U
ï¼½ã§ã¯ãªã
ã€ã“ã‚Œã‚‰ã¯ã„ãšã‚Œã‚‚ã€æ¿ç‚¹ï¼åŠæ¿ç‚¹ã€‘
ã€‚
ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã®ã¯ã€`~ISO-2022-JPç¬¦å·åŒ–å™¨$ã«é™ã‚‰ã‚Œã‚‹ã€‚
`UNICODE$r
â—
This maps halfwidth to fullwidth katakana as per Unicode Normalization Form KC, except that U+FF9E and U+FF9F map to U+309B and U+309C rather than U+3099 and U+309A. It is only used by the ISO-2022-JP encoder. [UNICODE]

</tbody></table>

<div class="algorithm">
<p>
%~pointer ãŒæŒ‡ã™
`ç´¢å¼•~gb18030ç¯„å›²é›†~cp@
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~cpã§ã‚ã‚‹ï¼š
â—
The index gb18030 ranges code point for pointer is the return value of these steps:
</p>
<ol>
	<li>
~IFï¼»
39419 ~LT %~pointer ~LT 189000
ï¼½~ORï¼»
1237575 ~LT %~pointer
ï¼½
â‡’
~RET ~NULL
â—
If pointer is greater than 39419 and less than 189000, or pointer is greater than 1237575, return null.
</li>
	<li>
~IFï¼»
%~pointer ~EQ 7457
ï¼½
â‡’
~RET ~cp `E7C7^U
â—
If pointer is 7457, return code point U+E7C7.
</li>
	<li>
%~offset ~LET `ç´¢å¼•~gb18030ç¯„å›²é›†$ã®ä¸­ã§ %~pointer ã‚’è¶…ãˆãªã„æœ€å¾Œã®~pointer
â—
Let offset be the last pointer in index gb18030 ranges that is less than or equal to pointer and let code point offset be its corresponding code point.
</li>
	<li>
%~cp~offset ~LET %~offset ãŒæŒ‡ã—ã¦ã„ã‚‹~cp
â—
â†‘</li>
	<li>
~RET å€¤ãŒï¼»
%~cp~offset ~PLUS %~pointer ~MINUS %~offset
ï¼½ãªã‚‹~cp
â—
Return a code point whose value is code point offset + pointer âˆ’ offset.
</li>
</ol>
</div>

<div class="algorithm">
<p>
%~cp ã‚’æŒ‡ã™
`ç´¢å¼•~gb18030ç¯„å›²é›†~pointer@
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index gb18030 ranges pointer for code point is the return value of these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `E7C7^U
ï¼½
â‡’
~RET ~pointer 7457
â—
If code point is U+E7C7, return pointer 7457.
</li>
	<li>
%~offset ~LET `ç´¢å¼•~gb18030ç¯„å›²é›†$ã®ä¸­ã§ %~cp ã‚’è¶…ãˆãªã„æœ€å¾Œã®~cp
â—
Let offset be the last code point in index gb18030 ranges that is less than or equal to code point and let pointer offset be its corresponding pointer.
</li>
	<li>
%~pointer~offset ~LET %~offset ã«å¯¾å¿œã™ã‚‹~pointer
â—
â†‘</li>
	<li>
~RET å€¤ãŒï¼»
%~pointer~offset ~PLUS %~cp ~MINUS %~offset
ï¼½ãªã‚‹~pointer
â—
Return a pointer whose value is pointer offset + code point âˆ’ offset.
</li>
</ol>
</div>

<div class="algorithm">
<p>
%~cp ã‚’æŒ‡ã™
`ç´¢å¼•~Shift_JIS~pointer@
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index Shift_JIS pointer for code point is the return value of these steps:
</p>
<ol>
	<li>
<p>
%ç´¢å¼• ~LET `ç´¢å¼•~jis0208$ ã‹ã‚‰ï¼»
~pointerãŒç¯„å›² { 8272 ã€œ 8835 } ã«å…¥ã‚‹~entry
ï¼½ã™ã¹ã¦ã‚’é™¤å¤–ã—ãŸç´¢å¼•
â—
Let index be index jis0208 excluding all entries whose pointer is in the range 8272 to 8835, inclusive.
</p>

<p class="note">
`ç´¢å¼•~jis0208$ã¯ã€é‡è¤‡ã™ã‚‹~cpã‚’åŒ…å«ã™ã‚‹ã®ã§ã€ã“ã‚Œã‚‰ã®~entryã®é™¤å¤–ã«ã‚ˆã‚Šï¼Œå¾Œç¶šã®~cpãŒåˆ©ç”¨ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
The index jis0208 contains duplicate code points so the exclusion of these entries causes later code points to be used.
</p>
	</li>
	<li>
~RET %ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Return the index pointer for code point in index.
</li>
</ol>
</div>

<div class="algorithm">
<p>
%~cp ã‚’æŒ‡ã™
`ç´¢å¼•~Big5~pointer@
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index Big5 pointer for code point is the return value of these steps:
</p>
<ol>
	<li>
<p>
%ç´¢å¼• ~LET `ç´¢å¼•~Big5$ã‹ã‚‰ï¼»
~pointerãŒ ( (`A1^X ~MINUS `81^X) ~MUL 157 ) æœªæº€ã®~entry
ï¼½ã™ã¹ã¦ã‚’é™¤å¤–ã—ãŸç´¢å¼•
â—
Let index be index Big5 excluding all entries whose pointer is less than (0xA1 - 0x81) Ã— 157.
</p>

<p class="note">æ³¨è¨˜ï¼š
é¦™æ¸¯å¢—è£œå­—ç¬¦é›†ï¼ˆ `Hong Kong Supplementary Character Set^en ï¼‰æ‹¡å¼µã‚’~literalã¨ã—ã¦è¿”ã•ãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚
â—
Avoid returning Hong Kong Supplementary Character Set extensions literally.
</p>
	</li>
	<li>
<p>
~IFï¼»
%~cp ~IN
{ `2550^U, `255E^U, `2561^U, `256A^U, `5341^U, `5345^U }
ï¼½
â‡’
~RET
%ç´¢å¼• ã®ä¸­ã§ %~cp ã«å¯¾å¿œã™ã‚‹`æœ€å¾Œã®^em ~pointer
â—
If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345, return the last pointer corresponding to code point in index.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä»–ã«ã‚‚é‡è¤‡ã—ã¦ã„ã‚‹~cpã¯ã‚ã‚‹ãŒã€ãã‚Œã‚‰ç”¨ã«ã¯ï¼Œ`æœ€åˆã®^em ~pointerãŒåˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
There are other duplicate code points, but for those the first pointer is to be used.
</p>
	</li>
	<li>
~RET
%ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Return the index pointer for code point in index.
</li>
</ol>
</div>

<hr>

<p class="note">æ³¨è¨˜ï¼š
ã™ã¹ã¦ã®`ç´¢å¼•$ã¯ã€è¦ç¯„çš„ã§ãªã„è³‡æº
`indexes.json$
ã‹ã‚‰ã‚‚å…¥æ‰‹ã§ãã‚‹ï¼ˆ `ç´¢å¼•~gb18030ç¯„å›²é›†$ã®å½¢å¼ã¯ã€ç¯„å›²ã‚’è¡¨ç¾ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ï¼Œå°‘ã—ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ï¼‰ã€‚
â—
All indexes are also available as a non-normative indexes.json resource. (Index gb18030 ranges has a slightly different format here, to be able to represent ranges.)
</p>

	</section>
	<section id="specification-hooks">
<h2 title="Hooks for standards">6. ä»–ã®æ¨™æº–~ç”¨ã®~hook</h2>

<div class="note">
<p>æ³¨è¨˜ï¼š
æ¬¡ã«æŒ™ã’ã‚‹å„ç¨®~algoï¼ˆä»¥ä¸‹ã«å®šç¾©ã•ã‚Œã‚‹ï¼‰ã¯ã€ä»–ã®ä»•æ§˜ã‹ã‚‰ã®~~åˆ©ç”¨ãŒæ„å›³ã•ã‚Œã¦ã„ã‚‹ï¼š
â—
The algorithms defined below (decode, UTF-8 decode, UTF-8 decode without BOM, UTF-8 decode without BOM or fail, encode, and UTF-8 encode) are intended for usage by other standards.
</p>

<dl>
	<dt>`~UTF-8å¾©å·ã™ã‚‹$</dt>
	<dd>
æ–°ãŸãªå½¢å¼ã¯ã€å¾©å·ã™ã‚‹ã¨ãã¯ï¼Œã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ï¼ˆæ¬¡é …ã¯åˆ¥ã¨ã—ã¦ï¼‰ã€‚
â—
For decoding, UTF-8 decode is to be used by new formats.ï¼¼
</dd>

	<dt>`~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$</dt>
	<dt>`~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$</dt>
	<dd>
å½¢å¼ã‚„~protocolã®ä¸­ã®è­˜åˆ¥å­ã‚„~byteåˆ—~ç”¨ã«ã¯ã€ã“ã‚Œã‚‰ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã€‚
â—
For identifiers or byte sequences within a format or protocol, use UTF-8 decode without BOM or UTF-8 decode without BOM or fail.
</dd>

	<dt>`~UTF-8ç¬¦å·åŒ–ã™ã‚‹$</dt>
	<dd>
ç¬¦å·åŒ–ã™ã‚‹ã¨ãã¯ã€ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã€‚
â—
For encoding, UTF-8 encode is to be used.
</dd>

	<dt>`ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹$</dt>
	<dt>`~Unicodeã«å¾©å·ã™ã‚‹$</dt>
	<dd>
æ¨™æº–ã¯ã€äº’æ›æ€§ã‚’å¾—ã‚‹ãŸã‚ã«å¿…è¦ãªå ´åˆã‚’é™¤ãï¼Œã“ã‚Œã‚‰ã¯åˆ©ç”¨ã—ãªã„ã“ã¨ãŒå¼·ãå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
â—
Standards are strongly discouraged from using decode and encode, except as needed for compatibility.
</dd>
</dl>

<p>
`~label$ã‚’`ç¬¦å·åŒ–æ³•$ã«è»¢æ›ã™ã‚‹ã¨ãã¯ã€`~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹$~algoã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã€‚
â—
The get an encoding algorithm is to be used to turn a label into an encoding.
</p>

<p>
æ¨™æº–ã¯ã€ï¼»
`ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹$ï¼`~UTF-8ç¬¦å·åŒ–ã™ã‚‹$
ï¼½~algoã«æ¸¡ã™~streamãŒï¼Œå®Ÿè³ªçš„ã«ã¯`~scalarå€¤$ã®~streamã§ã‚ã‚‹
â€” ã™ãªã‚ã¡ã€`~surrogate$ã‚’åŒ…å«ã—ãªã„ â€”
ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹ã“ã¨ã€‚
â—
Standards are to ensure that the streams they pass to the encode and UTF-8 encode algorithms are effectively scalar value streams, i.e., they contain no surrogates.
</p>

</div>

<div class="algorithm">
<p>
`~Unicodeã«å¾©å·ã™ã‚‹@
ã¨ãã¯ã€æ‰€ä¸ã®
( ~byte~stream %~stream, ~fallbackç¬¦å·åŒ–æ³• %ç¬¦å·åŒ–æ³• )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To decode a byte stream stream using fallback encoding encoding, run these steps:
</p>
<ol>
	<li>
%buffer ~LET ~byteåˆ— []
â—
Let buffer be an empty byte sequence.
</li>
	<li>
%~BOMseen~flag ~LET ~F
â—
Let BOM seen flag be unset.
</li>
	<li>
<p>
æ¬¡ã‚’ 3 å›ã¾ã§ç¹°è¿”ã™ï¼š
</p>
		<ol>
			<li>
%~byte ~LET `~tokenã‚’èª­å–ã‚‹$( %~stream )
</li>
			<li>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½
â‡’
~BREAK
</li>
			<li>
%buffer ã« %~byte ã‚’ä»˜åŠ ã™ã‚‹
</li>
		</ol>
â—
Read bytes from stream into buffer until either buffer contains three bytes or read returns end-of-stream.
</li>
	<li>
<p>
~IFï¼»
æ¬¡ã®è¡¨ã®ä¸­ã§ï¼Œ 1 åˆ—ç›®ã«ç¤ºã•ã‚ŒãŸ~byteåˆ—ãŒ %buffer ã®å…ˆé ­ã®~byteåˆ—ã«åˆè‡´ã™ã‚‹è¡ŒãŒã‚ã‚‹
ï¼½
â‡’ï¼ƒ
%ç¬¦å·åŒ–æ³• ~SET ãã®è¡Œã® 2 åˆ—ç›®ã«ä¸ãˆã‚‰ã‚Œã‚‹ `ç¬¦å·åŒ–æ³•$ï¼›
%~BOMseen~flag ~LET ~T
â—
For each of the rows in the table below, starting with the first one and going down, if the first bytes of buffer match all the bytes given in the first column, then set encoding to the encoding given in the cell in the second column of that row and set BOM seen flag.
</p>

<table>
<thead><tr><th>~BOMâ— Byte order mark
<th>ç¬¦å·åŒ–æ³•â— Encoding
</thead>

<tbody><tr><td>`EF^X `BB^X `BF^X
<td>`UTF-8$n

<tr><td>`FE^X `FF^X
<td>`UTF-16BE$n

<tr><td>`FF^X `FE^X
<td>`UTF-16LE$n

</tbody></table>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™-æ¸ˆã¿ã®å†…å®¹ã¨ã®äº’æ›æ€§ã‚’å¾—ã‚‹ãŸã‚ã€~BOMã¯ä»–ã‚ˆã‚Š~~å„ªå…ˆã•ã‚Œã‚‹ã€‚
HTTP ãŒåˆ©ç”¨ã•ã‚Œã‚‹æ–‡è„ˆã«ãŠã„ã¦ã¯ã€ã“ã‚Œã¯ï¼Œ
`<code class="header">Content-Type</code>`
~headerã®æ„å‘³è«–ã«å¯¾ã™ã‚‹é•åã§ã‚ã‚‹ã€‚
â—
For compatibility with deployed content, the byte order mark is more authoritative than anything else. In a context where HTTP is used this is in violation of the semantics of the `Content-Type` header.
</p>
	</li>
	<li>
~IFï¼»
%~BOMseen~flag ~EQ ~F
ï¼½
â‡’
%~stream ã« %buffer ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
If BOM seen flag is unset, prepend buffer to stream.
</li>
	<li>
~ELIF ï¼»
%ç¬¦å·åŒ–æ³• ~NEQ `UTF-8$n
ï¼½~ANDï¼»
%buffer ã®é•·ã• ~EQ 3
ï¼½
â‡’
%~stream ã« %buffer ã®æœ€å¾Œã®~byteã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
Otherwise, if BOM seen flag is set, encoding is not UTF-8, and buffer contains three bytes, prepend the last byte of buffer to stream.
</li>
	<li>
%å‡ºåŠ› ~LET æ–°ãŸãª~scalarå€¤`~stream$
â—
Let output be a scalar value stream.
</li>
	<li>
%ç¬¦å·åŒ–æ³• ã®`å¾©å·å™¨$ã‚’`èµ°ã‚‰ã™$( %~stream, %å‡ºåŠ› )
â—
Run encodingâ€™s decoder with stream and output.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~UTF-8å¾©å·ã™ã‚‹@
ã¨ãã¯ã€æ‰€ä¸ã®
( ~byte~stream %~stream )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To UTF-8 decode a byte stream stream, run these steps:
</p>
<ol>
	<li>
%buffer ~LET ~byteåˆ— []
â—
Let buffer be an empty byte sequence.
</li>
	<li>
<p>
æ¬¡ã‚’ 3 å›ã¾ã§ç¹°è¿”ã™ï¼š
</p>
		<ol>
			<li>
%~byte ~LET `~tokenã‚’èª­å–ã‚‹$( %~stream )
</li>
			<li>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½
â‡’
~BREAK
</li>
			<li>
%buffer ã« %~byte ã‚’ä»˜åŠ ã™ã‚‹
</li>
		</ol>
â—
Read three bytes from stream into buffer.
</li>
	<li>
~IFï¼»
%buffer ~NEQ ~byteåˆ— [ `EF^X, `BB^X, `BF^X ]
ï¼½
â‡’
%~stream ã« %buffer ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
If buffer does not match 0xEF 0xBB 0xBF, prepend buffer to stream.
</li>
	<li>
%å‡ºåŠ› ~LET æ–°ãŸãª~scalarå€¤`~stream$
â—
Let output be a scalar value stream.
</li>
	<li>
`UTF-8$n ã®`å¾©å·å™¨$ã‚’`èµ°ã‚‰ã™$( %~stream, %å‡ºåŠ› )
â—
Run UTF-8â€™s decoder with stream and output.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹@
ã¨ãã¯ã€æ‰€ä¸ã®
( ~byte~stream %~stream )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To UTF-8 decode without BOM a byte stream stream, run these steps:
</p>
<ol>
	<li>
%å‡ºåŠ› ~LET æ–°ãŸãª~scalarå€¤`~stream$
â—
Let output be a scalar value stream.
</li>
	<li>
`UTF-8$n ã®`å¾©å·å™¨$ã‚’`èµ°ã‚‰ã™$( %~stream, %å‡ºåŠ› )
â—
Run UTF-8â€™s decoder with stream and output.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹@
ã¨ãã¯ã€æ‰€ä¸ã®
( ~byte~stream %~stream )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To UTF-8 decode without BOM or fail a byte stream stream, run these steps:
</p>
<ol>
	<li>
%å‡ºåŠ› ~LET æ–°ãŸãª~scalarå€¤`~stream$
â—
Let output be a scalar value stream.
</li>
	<li>
`UTF-8$n ã®`å¾©å·å™¨$ã‚’`èµ°ã‚‰ã™$( %~stream, %å‡ºåŠ›, `fatal^l )
â—
Let potentialError be the result of running UTF-8â€™s decoder with stream, output, and "fatal".
</li>
	<li>
~IFï¼»
å‰~æ®µã®çµæœ ~EQ `~error$
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If potentialError is error, return failure.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹@
ã¨ãã¯ã€æ‰€ä¸ã®
( ç¬¦å·åŒ–æ³• %ç¬¦å·åŒ–æ³•,
~scalarå€¤~stream %~stream
) ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To encode a scalar value stream stream using encoding encoding, run these steps:
</p>
<ol>
	<li>
~Assertï¼š
%ç¬¦å·åŒ–æ³• ~NIN
{ `replacement$n, `UTF-16BE$n, `UTF-16LE$n }
â—
Assert: encoding is not replacement, UTF-16BE or UTF-16LE.
</li>
	<li>
%å‡ºåŠ› ~LET æ–°ãŸãª~byte`~stream$
â—
Let output be a byte stream.
</li>
	<li>
 %ç¬¦å·åŒ–æ³• ã®`ç¬¦å·åŒ–å™¨$ã‚’`èµ°ã‚‰ã™$( %~stream, %å‡ºåŠ›, `html^l )
â—
Run encodingâ€™s encoder with stream, output, and "html".
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ä¸»ã«ã€~URLã¨~HTML~formç”¨ã®æ—§æ¥ã®~hookã§ã‚ã‚‹ã€‚
`~UTF-8ç¬¦å·åŒ–ã™ã‚‹$ã‚’è¢«ã›ãŸæ–¹ãŒã€æ±ºã—ã¦`~error$ã‚’èª˜ç™ºã—ãªã„ã®ã§å®‰å…¨ã§ã‚ã‚‹ã€‚
`URL$r
`HTML$r
â—
This is mostly a legacy hook for URLs and HTML forms. Layering UTF-8 encode on top is safe as it never triggers errors. [URL] [HTML]
</p>
</div>

<div class="algorithm">
<p>
`~UTF-8ç¬¦å·åŒ–ã™ã‚‹@
ã¨ãã¯ã€æ‰€ä¸ã®
( ~scalarå€¤~stream %~stream )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™
â‡’
~RET `ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹$( `UTF-8$n, %~stream )
â—
To UTF-8 encode a scalar value stream stream, return the result of encoding stream using encoding UTF-8.
</p>
</div>

	</section>
	<section id="api">
<h2 title="API">7. ~API</h2>

<p>
ã“ã®ç¯€ã§ã¯ Web IDL `WEBIDL$r ã®å„ç¨®ç”¨èªã‚’åˆ©ç”¨ã™ã‚‹ã€‚
~browser~UAã¯ã€ã“ã®~APIã‚’~supportã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
~JSå®Ÿè£…ã¯ã€ã“ã®~APIã‚’~supportã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹ã€‚
ä»–ã®~UAï¼~programmingè¨€èªã¯ã€å¿…è¦ã«å¿œã˜ã¦ç›¸å¿œã—ã„~APIï¼ˆã“ã‚Œã§ã¯ãªã„ã‹ã‚‚ã—ã‚Œãªã„ï¼‰ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
â—
This section uses terminology from Web IDL. Browser user agents must support this API. JavaScript implementations should support this API. Other user agents or programming languages are encouraged to use an API suitable to their needs, which might not be this one. [WEBIDL]
</p>

<div class="example">
<p>
æ¬¡ã®ä¾‹ã¯ã€ `TextEncoder$I ~objã‚’åˆ©ç”¨ã—ã¦ï¼Œæ–‡å­—åˆ—ã®é…åˆ—ã‚’ `ArrayBuffer$I ã«ç¬¦å·åŒ–ã™ã‚‹ã€‚
çµæœã¯æ¬¡ã‚’å†…å®¹ã¨ã™ã‚‹ `Uint8Array$I ã«ãªã‚‹ï¼š
<span class="block">
å…ˆé ­ãŒï¼ˆ `Uint32Array$I ã¨ã—ã¦ã®ï¼‰æ–‡å­—åˆ—ã®å€‹æ•°ï¼Œãã®å¾Œã¯ï¼š
<span class="block">
æœ€åˆã®æ–‡å­—åˆ—ã®ï¼ˆ `Uint32Array$I ã¨ã—ã¦ã®ï¼‰é•·ã•,
`UTF-8$n ã«ç¬¦å·åŒ–ã•ã‚ŒãŸãã®æ–‡å­—åˆ—~dataï¼Œ<br>
2 ç•ªç›®ã®æ–‡å­—åˆ—ã®ï¼ˆ `Uint32Array$I ã¨ã—ã¦ã®ï¼‰é•·ã•,
ãã®æ–‡å­—åˆ—~dataï¼Œ<br>
â€¦
</span>
ç­‰ã€…ã¨ç¶šãã€‚
</span>
â—
The following example uses the TextEncoder object to encode an array of strings into an ArrayBuffer. The result is a Uint8Array containing the number of strings (as a Uint32Array), followed by the length of the first string (as a Uint32Array), the UTF-8 encoded string data, the length of the second string (as a Uint32Array), the string data, and so on.
</p>

<pre>
function encodeArrayOfStrings(%strings) {
  var %encoder, %encoded, %len, %bytes, %view, %offset;

  %encoder = new TextEncoder();
  %encoded = [];

  %len = Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %strings.length; %i++) {
    %len += Uint32Array.BYTES_PER_ELEMENT;
    %encoded[%i] = %encoder.encode(%strings[%i]);
    %len += %encoded[%i].byteLength;
  }

  %bytes = new Uint8Array(%len);
  %view = new DataView(%bytes.buffer);
  %offset = 0;

  %view.setUint32(%offset, %strings.length);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %encoded.length; %i += 1) {
    %len = %encoded[%i].byteLength;
    %view.setUint32(%offset, %len);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %bytes.set(%encoded[%i], %offset);
    %offset += %len;
  }
  return %bytes.buffer;
}
</pre>

<p>
æ¬¡ã®ä¾‹ã¯ã€ï¼»ï¼»
å‰ã®ä¾‹, ã¾ãŸã¯ `UTF-8$n ä»¥å¤–ã®ç¬¦å·åŒ–æ³•ã«ç­‰ä¾¡ãª~algo
ï¼½ã«ã‚ˆã‚Šç”Ÿç”£ã•ã‚Œã‚‹å½¢å¼ã«ç¬¦å·åŒ–ã•ã‚ŒãŸ~data
ï¼½ã‚’å«ã‚“ã§ã„ã‚‹ `ArrayBuffer$I ã‚’å¾©å·ã—ã¦ã€~~å…ƒã®ï¼Œä¸€é€£ã®æ–‡å­—åˆ—ã‹ã‚‰ãªã‚‹é…åˆ—ã«æˆ»ã™ã€‚
â—
The following example decodes an ArrayBuffer containing data encoded in the format produced by the previous example, or an equivalent algorithm for encodings other than UTF-8, back into an array of strings.
</p>

<pre>
function decodeArrayOfStrings(%buffer, %encoding) {
  var %decoder, %view, %offset, %num_strings, %strings, %len;

  %decoder = new TextDecoder(%encoding);
  %view = new DataView(%buffer);
  %offset = 0;
  %strings = [];

  %num_strings = %view.getUint32(%offset);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %num_strings; %i++) {
    %len = %view.getUint32(%offset);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %strings[%i] = %decoder.decode(
      new DataView(%view.buffer, %offset, %len));
    %offset += %len;
  }
  return %strings;
}
</pre>
</div>

		<section id="interface-mixin-textdecodercommon">
<h3 title="Interface mixin TextDecoderCommon">7.1. ~interface~mixin `TextDecoderCommon^I</h3>

<pre class="idl">
interface mixin `TextDecoderCommon@I {
  readonly attribute `DOMString$ `encoding$m;
  readonly attribute `boolean$ `fatal$m;
  readonly attribute `boolean$ `ignoreBOM$m;
};
</pre>

<p>
`TextDecoderCommon$I ~interface~mixinã¯ã€ï¼»
`TextDecoder$I, `TextDecoderStream$I
ï¼½~objã«å…±é€šãªå±æ€§ã‚’å®šç¾©ã™ã‚‹ã€‚
ã“ã‚Œã‚‰ã®~objã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼ˆæ‹¬å¼§å†…ã¯åˆæœŸ~å€¤ï¼‰
â‡’ï¼ƒ
`ç¬¦å·åŒ–æ³•@dec,
`~BOMignore~flag@decï¼ˆ ~F ï¼‰,
`~BOMseen~flag@decï¼ˆ ~F ï¼‰,
`~error~mode@decï¼ˆ `replacement^l ï¼‰
â—
The TextDecoderCommon interface mixin defines common attributes that are shared between TextDecoder and TextDecoderStream objects. These objects have an associated encoding, ignore BOM flag (initially unset), BOM seen flag (initially unset), and error mode (initially "replacement").
</p>

<div class="algorithm">
<p>
ã“ã‚Œã‚‰ã®~objã«ã¯ã€
`~streamã‚’ç›´åˆ—åŒ–ã™ã‚‹@dec
~algoã‚‚çµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
ãã‚Œã¯ã€æ‰€ä¸ã®`~stream$ %~stream ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
These objects also have an associated serialize stream algorithm, that given a stream stream, runs these steps:
</p>
<ol>
	<li>
%å‡ºåŠ› ~LET ç©º~æ–‡å­—åˆ—
â—
Let output be the empty string.
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
		<ol>
			<li>
%~token ~LET `~tokenã‚’èª­å–ã‚‹$( %~stream )
â—
Let token be the result of reading from stream.
</li>
			<li>
<p>
~IFï¼»
`ç¬¦å·åŒ–æ³•$dec ~IN { `UTF-8$n, `UTF-16BE$n, `UTF-16LE$n }
ï¼½~ANDï¼»
`~BOMignore~flag$dec ~EQ ~F
ï¼½~ANDï¼»
`~BOMseen~flag$dec ~EQ ~F
ï¼½ï¼š
â—
If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore BOM flag and BOM seen flag are unset, then:
</p>
				<ol>
					<li>
~IFï¼»
%~token ~EQ `FEFF^U
ï¼½
â‡’
`~BOMseen~flag$dec ~SET ~T
â—
If token is U+FEFF, then set BOM seen flag.
</li>
					<li>
~ELIFï¼»
%~token ~NEQ `~EoS$
ï¼½
â‡’ï¼ƒ
`~BOMseen~flag$dec ~SET ~Tï¼›
%å‡ºåŠ› ã« %~token ã‚’ä»˜åŠ ã™ã‚‹
â—
Otherwise, if token is not end-of-stream, then set BOM seen flag and append token to output.
</li>
					<li>
~ELSE
â‡’
~RET %å‡ºåŠ›
â—
Otherwise, return output.
</li>
				</ol>
			</li>
			<li>
~ELIFï¼»
%~token ~NEQ `~EoS$
ï¼½
â‡’
%å‡ºåŠ› ã« %~token ã‚’ä»˜åŠ ã™ã‚‹
â—
Otherwise, if token is not end-of-stream, then append token to output.
</li>
			<li>
~ELSE
â‡’
~RET %å‡ºåŠ›
â—
Otherwise, return output.
</li>
		</ol>
	</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®~algoã¯ã€~APIã®åˆ©ç”¨è€…ã« ã‚‚ã£ã¨åˆ¶å¾¡ã‚’ä¸ãˆã‚‹ãŸã‚ï¼Œï¼»
~platformã®ä»–æ‰€ã§åˆ©ç”¨ã•ã‚Œã‚‹ï¼Œ`~Unicodeã«å¾©å·ã™ã‚‹$ ~algo
ï¼½ã¨ã¯ã€~BOMã®å–æ‰±ã„ã®ç‚¹ã§æ„å›³çš„ã«ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
This algorithm is intentionally different with respect to BOM handling from the decode algorithm used by the rest of the platform to give API users more control.
</p>
</div>

<hr>

<dl class="idl-def">
	<dt>`encoding@m</dt>
	<dd>
å–å¾—å­ã¯ã€æ¬¡ã®çµæœã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«
â‡’
`~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹$( æ­¤ã‚Œã®`ç¬¦å·åŒ–æ³•$decã®`åå‰$ )
â—
The encoding attributeâ€™s getter, when invoked, must return this objectâ€™s encodingâ€™s name in ASCII lowercase.
</dd>

	<dt>`fatal@m</dt>
	<dd>
å–å¾—å­ã¯ã€ï¼»
æ­¤ã‚Œã®`~error~mode$dec ~EQ `fatal^l ãªã‚‰ã° ~T ï¼ ~ELSE_ ~F
ï¼½ã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The fatal attributeâ€™s getter, when invoked, must return true if this objectâ€™s error mode is "fatal", and false otherwise.
</dd>

	<dt>`ignoreBOM@m</dt>
	<dd>
å–å¾—å­ã¯ã€ï¼»
æ­¤ã‚Œã®`~BOMignore~flag$dec ~EQ ~T ãªã‚‰ã° ~T ï¼
~ELSE_ ~F
ï¼½ã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The ignoreBOM attributeâ€™s getter, when invoked, must return true if this objectâ€™s ignore BOM flag is set, and false otherwise.
</dd>
</dl>

		</section>
		<section id="interface-textdecoder">
<h3 title="Interface TextDecoder">7.2. ~interface `TextDecoder^I</h3>

<pre class="idl">
dictionary `TextDecoderOptions@I {
  `boolean$ `fatal@mb = false;
  `boolean$ `ignoreBOM@mb = false;
};

dictionary `TextDecodeOptions@I {
  `boolean$ `stream@mb = false;
};

[`Exposed$=(Window,Worker)]
interface `TextDecoder@I {
  `TextDecoder$mc(
    optional `DOMString$ %label = "utf-8",
    optional `TextDecoderOptions$I %options = {}
  );

  `USVString$ `decode$m(
    optional [`AllowShared$] `BufferSource$I %input,
    optional `TextDecodeOptions$I %options = {}
  );
};

`TextDecoder$I includes `TextDecoderCommon$I;
</pre>

<p class="trans-note">ã€
<a href="Encoding-test.html">åˆ©ç”¨-ä¸­ã®~browserã§ã“ã®ç‰¹èƒ½ã‚’è©¦ã™</a>
ã€‘</p>

<p>
å„ `TextDecoder$I ~objã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼ˆæ‹¬å¼§å†…ã¯åˆæœŸ~å€¤ï¼‰
â‡’ï¼ƒ
`å¾©å·å™¨@dec â€ ,
`~stream@dec,
`~no_flush~flag@decï¼ˆ ~F ï¼‰
â—
A TextDecoder object has an associated decoder, stream, and do not flush flag (initially unset).
</p>

<p class="trans-note">ã€â€ 
`ç¬¦å·åŒ–æ³•$decã«å¯¾å¿œã™ã‚‹`å¾©å·å™¨$ã®ï¼Œã‚ã‚‹~instanceã€‚
`å¾©å·å™¨$ã«ã¯ï¼Œå†…éƒ¨çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹å¤‰æ•°ã‚’ä¼´ã†ã‚‚ã®ã‚‚ã‚ã‚‹ã®ã§ã€~objã”ã¨ã«~instanceã‚’è¦ã™ã‚‹ã€‚
ã€‘</p>

<dl class="domintro">
	<dt>%decoder = new `TextDecoder$m([%label = "utf-8" [, %options]])</dt>
	<dd>
æ–°ãŸãª `TextDecoder$I ~obj ã‚’è¿”ã™ã€‚
â—
Returns a new TextDecoder object.
</dd>
	<dd>
%label ãŒ`~label$ã§ãªã„, ã¾ãŸã¯
%label ãŒ `replacement$n ã§ã‚ã‚‹å ´åˆã€
`RangeError$E ãŒ`æŠ•å‡º-$ã•ã‚Œã‚‹ã€‚
â—
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`ç¬¦å·åŒ–æ³•$decã®`åå‰$ã‚’å°æ–‡å­—~åŒ–ã—ã¦è¿”ã™ã€‚
â—
Returns encodingâ€™s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
`~error~mode$decãŒ `fatal^l ãªã‚‰ã° ~T ã‚’, ä»–ã®å ´åˆã¯ ~F ã‚’è¿”ã™ã€‚
â—
Returns true if error mode is "fatal", and false otherwise.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
`~BOMignore~flag$decã‚’è¿”ã™ã€‚
â—
Returns true if ignore BOM flag is set, and false otherwise.
</dd>

	<dt>%decoder . `decode([input [, options]])$m</dt>
	<dd>
<p>
%input ã‚’ `ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ã«ã‹ã‘ãŸçµæœã‚’è¿”ã™ã€‚
~streamã‚’æ–­ç‰‡åŒ–ã—ã¦å‡¦ç†ã™ã‚‹ã¨ãã¯ã€
%options ã® `stream$mb ~memberã‚’ ~T ã«ã—ãŸä¸‹ã§ï¼Œã“ã®~method 0 å›~ä»¥ä¸Š~å‘¼å‡ºã—ã¦ã‹ã‚‰ï¼Œ %options ã‚’çœç•¥ã—ã¦ï¼ˆã¾ãŸã¯ ãã® `stream$mb ~memberã‚’ ~F ã«ã—ã¦ï¼‰
1 å›ã ã‘å‘¼å‡ºã™ã“ã¨ã§è¡Œãˆã‚‹ã€‚
å¾Œè€…ã®å‘¼å‡ºnã« %input ã‚‚ãªã„ãªã‚‰ã°ã€ä¸¡~å¼•æ•°ã¨ã‚‚çœç•¥ã™ã‚‹ã®ãŒæœ€ã‚‚ç°¡æ˜ã«ãªã‚‹ã€‚
â—
Returns the result of running encodingâ€™s decoder. The method can be invoked zero or more times with optionsâ€™s stream set to true, and then once without optionsâ€™s stream (or set to false), to process a fragmented stream. If the invocation without optionsâ€™s stream (or set to false) has no input, itâ€™s clearest to omit both arguments.
</p>

<pre class="example">
var %string = "", %decoder = new TextDecoder(%encoding), %buffer;
while(%buffer = next_chunk()) {
  %string += %decoder.decode(%buffer, {stream:true});
}
%string += %decoder.decode(); // ~EoS
</pre>

	</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l ã®ä¸‹ã§ï¼Œ
`ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ãŒ`~error$ã‚’è¿”ã—ãŸå ´åˆã€
`TypeError$E ãŒ`æŠ•å‡º-$ã•ã‚Œã‚‹ã€‚
â—
If the error mode is "fatal" and encodingâ€™s decoder returns error, throws a TypeError.
</dd>
</dl>

<dl class="idl-def">
	<dt>`TextDecoder(label, options)@m</dt>
	<dd>
<p>
ã“ã®æ§‹ç¯‰å­ã®è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
The TextDecoder(label, options) constructor, when invoked, must run these steps:
</p>
		<ol>
			<li>
%ç¬¦å·åŒ–æ³• ~LET `~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹$( %label )
â—
Let encoding be the result of getting an encoding from label.
</li>
			<li>
~IFï¼»
%ç¬¦å·åŒ–æ³• ~IN { `å¤±æ•—^i, `replacement$n }
ï¼½
â‡’
~THROW `RangeError$E
â—
If encoding is failure or replacement, then throw a RangeError.
</li>
			<li>
%dec ~LET æ–°ãŸãª `TextDecoder$I ~obj
â—
Let dec be a new TextDecoder object.
</li>
			<li>
%dec ã® `ç¬¦å·åŒ–æ³•$dec ~SET %ç¬¦å·åŒ–æ³•
â—
Set decâ€™s encoding to encoding.
</li>
			<li>
~IFï¼»
%options ã® `fatal$mb ~member ~EQ ~T
ï¼½
â‡’
%dec ã® `~error~mode$dec ~SET `fatal^l
â—
If optionsâ€™s fatal member is true, then set decâ€™s error mode to "fatal".
</li>
			<li>
~IFï¼»
%options ã® `ignoreBOM$mb ~member ~EQ ~T
ï¼½
â‡’
%dec ã® `~BOMignore~flag$dec ~SET `fatal^l
â—
If optionsâ€™s ignoreBOM member is true, then set decâ€™s ignore BOM flag.
</li>
			<li>
~RET %dec
â—
Return dec.
</li>
		</ol>
	</dd>

	<dt>`decode(input, options)@m</dt>
	<dd>
<p>
è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
The decode(input, options) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IFï¼»
æ­¤ã‚Œã®`~no_flush~flag$dec ~EQ ~F
ï¼½
â‡’ï¼ƒ
æ­¤ã‚Œã®`å¾©å·å™¨$dec ~SET æ–°ãŸãªï¼» æ­¤ã‚Œã®`ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ ï¼½ï¼›
æ­¤ã‚Œã®`~stream$dec ~SET æ–°ãŸãª`~stream$ï¼›
æ­¤ã‚Œã®`~BOMseen~flag$dec ~SET ~F
â—
If the do not flush flag is unset, set decoder to a new encodingâ€™s decoder, set stream to a new stream, and unset the BOM seen flag.
</li>
			<li>
æ­¤ã‚Œã®`~no_flush~flag$dec ~SETï¼»
%options ã® `stream$mb ~EQ ~T ãªã‚‰ã° ~T ï¼
~ELSE_ ~F
ï¼½
â—
If optionsâ€™s stream is true, set the do not flush flag, and unset the do not flush flag otherwise.
</li>
			<li>
<p>
~IFï¼»
%input ~NEQ Îµ
ï¼½
â‡’
æ­¤ã‚Œã®`~stream$decã« %input ã®<a href="~WEBIDL#dfn-get-buffer-source-copy">è¤‡è£½</a>ã‚’`~pushã™ã‚‹$
â—
If input is given, then push a copy of input to stream.
</p>
<p class="note">æ³¨è¨˜ï¼š
å®Ÿè£…ã«ã¯ã€ã“ã®è¤‡è£½ã‚’é¿ã‘ã‚‹ã‚ˆã†å®Ÿè£…ã™ã‚‹ã“ã¨ãŒå¼·ãå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
ãã†ã™ã‚‹ã¨ãã¯ã€ %input ãŒå¤‰æ›´ã•ã‚Œã¦ã‚‚ï¼Œå¾Œã® `decode()$m ã®~callã«å½±éŸ¿ã—ãªã„ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
Implementations are strongly encouraged to use an implementation strategy that avoids this copy. When doing so they will have to make sure that changes to input do not affect future calls to decode().
</p>

<p class="warning" id="sharedarraybuffer-warning">
`SharedArrayBuffer^I ~objã«ã‚ˆã‚Šå…¬é–‹ã•ã‚Œã‚‹~memoryã¯ã€ï¼»
å®Ÿè£…~ç”¨ã«æ¦‚ã—ã¦åˆ©ç”¨ã•ã‚Œã‚‹~programmingè¨€èª
ï¼½ã®~memory~modelã«è¦æ±‚ã•ã‚Œã‚‹ `data race freedom^en ãªç‰¹è³ªã‚’å›ºå®ˆã—ãªã„ã€‚
å®Ÿè£…ã™ã‚‹ã¨ãã¯ã€ `SharedArrayBuffer^I ~objãŒå…¬é–‹ã™ã‚‹~memoryã«~accessã™ã‚‹ã¨ãã«é©åˆ‡ãªä¾¿å®œæ€§â€ ã‚’åˆ©ç”¨ã™ã‚‹ã‚ˆã†~careã™ã‚‹ã“ã¨ã€‚
ã€â€ ãã®ã‚ˆã†ãª~accessã« ãã®ç¨®ã®ç‰¹è³ªãŒå‚™ã‚ã‚‹ã‚ˆã†æŒ‡ç¤ºã™ã‚‹ï¼Œè¨€èª~ç‰¹æœ‰ãªæ§‹æ–‡ãªã©ã€‘
â—
The memory exposed by SharedArrayBuffer objects does not adhere to data race freedom properties required by the memory model of programming languages typically used for implementations. When implementing, take care to use the appropriate facilities when accessing memory exposed by SharedArrayBuffer objects.
</p>
			</li>
			<li>
%å‡ºåŠ› ~LET æ–°ãŸãª`~stream$
â—
Let output be a new stream.
</li>
			<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
				<ol>
					<li>
%~token ~LET `~tokenã‚’èª­å–ã‚‹$( æ­¤ã‚Œã®`~stream$dec )
â—
Let token be the result of reading from stream.
</li>
					<li>
<p>
~IFï¼»
%~token ~EQ `~EoS$
ï¼½~ANDï¼»
æ­¤ã‚Œã®`~no_flush~flag$dec ~EQ ~T
ï¼½
â‡’
~RET `~streamã‚’ç›´åˆ—åŒ–ã™ã‚‹$dec( %å‡ºåŠ› )
â—
If token is end-of-stream and the do not flush flag is set, then return output, serialized.
</p>

<p class="note">
~streamingã§ã¯ã€ï¼»
`~no_flush~flag$dec ~EQ ~T
ï¼½ã®ã¨ãã«ï¼Œã“ã“ã§`~EoS$ã‚’å–æ‰±ã†ã“ã¨ãªãï¼Œãã®~flagã‚’ ~F ã«ã—ãªã„ä»•æ–¹ã§åƒãã€‚
ã“ã®ä»•æ–¹ã«ã‚ˆã‚Šï¼Œ`å¾©å·å™¨$decã¯ã€å¾Œç¶šã®å‘¼å‡ºnã«ãŠã„ã¦ï¼Œã“ã®~algoã®æœ€åˆã®æ®µã§ä¸€æ–°ã•ã‚Œã‚‹ã“ã¨ãªãï¼Œãã®çŠ¶æ…‹ã¯ä¿å…¨ã•ã‚Œã‚‹ã€‚
â—
The way streaming works is to not handle end-of-stream here when the do not flush flag is set and to not unset that flag. That way in a subsequent invocation decoder is not set anew in the first step of the algorithm and its state is preserved.
</p>
					</li>
					<li>
%çµæœ ~LET `~tokenã‚’å‡¦ç†ã™ã‚‹$( %~token, æ­¤ã‚Œã®`å¾©å·å™¨$dec, æ­¤ã‚Œã®`~stream$dec, %å‡ºåŠ›, æ­¤ã‚Œã®`~error~mode$dec )
â—
Otherwise:
â—
Let result be the result of processing token for decoder, stream, output, and error mode.
</li>
					<li>
~IFï¼»
%çµæœ ~EQ `å®Œé‚d$
ï¼½
â‡’
~RET `~streamã‚’ç›´åˆ—åŒ–ã™ã‚‹$dec( %å‡ºåŠ› )
â—
If result is finished, then return output, serialized.
</li>
					<li>
~IFï¼»
%çµæœ ~EQ `~error$
ï¼½
â‡’
~THROW `TypeError$E
â—
Otherwise, if result is error, then throw a TypeError.
</li>
				</ol>
			</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="interface-mixin-textencodercommon">
<h3 title="Interface mixin TextEncoderCommon">7.3. ~interface~mixin `TextEncoderCommon^I</h3>

<pre class="idl">
interface mixin `TextEncoderCommon@I {
  readonly attribute `DOMString$ `~encoding0$m;
};
</pre>

<p>
`TextEncoderCommon$I ~interface~mixinã¯ã€ï¼»
`TextEncoder$I, `TextEncoderStream$I
ï¼½~objã«å…±é€šãªå±æ€§ã‚’å®šç¾©ã™ã‚‹ã€‚
â—
The TextEncoderCommon interface mixin defines common attributes that are shared between TextEncoder and TextEncoderStream objects.
</p>

<dl class="idl-def">
	<dt>`~encoding0@m</dt>
	<dd>
å–å¾—å­ã¯ã€ `utf-8^l ã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The encoding attributeâ€™s getter, when invoked, must return "utf-8".
</dd>
</dl>

		</section>
		<section id="interface-textencoder">
<h3 title="Interface TextEncoder">7.4. ~interface `TextEncoder^I</h3>

<pre class="idl">
dictionary `TextEncoderEncodeIntoResult@I {
  `unsigned long long$ `read@m;
  `unsigned long long$ `written@m;
};

[`Exposed$=(Window,Worker)]
interface `TextEncoder@I {
  `TextEncoder$mc();

  [NewObject] `Uint8Array$ `encode$m(optional `USVString$ %input = "");
  `TextEncoderEncodeIntoResult$I `encodeInto$m(`USVString$ %source, [`AllowShared$] `Uint8Array$ %destination);
};
`TextEncoder$I includes `TextEncoderCommon$I;
</pre>

<p class="note">æ³¨è¨˜ï¼š
`TextEncoder$I ~objã¯ã€`UTF-8$n ã—ã‹~supportã—ãªã„ã®ã§ï¼Œæ§‹ç¯‰å­ã« %label å¼•æ•°ã¯ç„¡ã„ã€‚
ã¾ãŸã€~scalarå€¤~bufferã‚’è¦æ±‚ã™ã‚‹`ç¬¦å·åŒ–å™¨$ã¯ç„¡ã„ã®ã§ï¼Œ `stream^mb ~optionã‚‚ãªã„ã€‚
â—
A TextEncoder object offers no label argument as it only supports UTF-8. It also offers no stream option as no encoder requires buffering of scalar values.
</p>

<hr>

<dl class="domintro">
	<dt>%encoder = new `TextEncoder()$m</dt>
	<dd>
æ–°ãŸãª `TextEncoder$I ~obj ã‚’è¿”ã™ã€‚
â—
Returns a new TextEncoder object.
</dd>

	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l ã‚’è¿”ã™ã€‚
â—
Returns "utf-8".
</dd>

	<dt>%encoder . `encode([input = ""])$m</dt>
	<dd>
%input ã‚’ `UTF-8$n ã®`ç¬¦å·åŒ–å™¨$ã«ã‹ã‘ãŸçµæœã‚’è¿”ã™ã€‚
â—
Returns the result of running UTF-8â€™s encoder.
</dd>

	<dt>%encoder . `encodeInto(source, destination)$m</dt>
	<dd>
%source ã‚’æ¸¡ã—ã¦`~UTF-8ç¬¦å·åŒ–å™¨$ã‚’èµ°ã‚‰ã›ãŸçµæœã‚’ %destination ã®ä¸­ã«æ ¼ç´ã—ã¦ï¼Œãã®é€²æ—ã‚’ `TextEncoderEncodeIntoResult$I è¾æ›¸ã¨ã—ã¦è¿”ã™
â€” çµæœã®
â‡’ï¼ƒ
`read$m ã¯ %source ã‹ã‚‰å¤‰æ›ã•ã‚ŒãŸ`~cu$æ•°ã«ãªã‚‹ ï¼
`written$m ã¯ %destination å†…ã§æ”¹å¤‰ã•ã‚ŒãŸ~byteæ•°ã«ãªã‚‹
â—
Runs the UTF-8 encoder on source, stores the result of that operation into destination, and returns the progress made as a dictionary whereby read is the number of converted code units of source and written is the number of bytes modified in destination.
</dd>
</dl>

<dl class="idl-def">
	<dt>`TextEncoder()@m</dt>
	<dd>
ã“ã®æ§‹ç¯‰å­ã®è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ–°ãŸãª `TextEncoder$I ~objã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The TextEncoder() constructor, when invoked, must return a new TextEncoder object.
</dd>

	<dt>`encode(input)@m</dt>
	<dd>
<p>
è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
The encode(input) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%å…¥åŠ› ~LET %input ã‚’`~stream$ã«å¤‰æ›ã—ãŸçµæœ
â—
Convert input to a stream.
</li>
			<li>
%å‡ºåŠ› ~LET æ–°ãŸãª`~stream$
â—
Let output be a new stream.
</li>
			<li>
<p>
~WHILE ç„¡æ¡ä»¶ ï¼š
â—
While true:
</p>
				<ol>
					<li>
%~token ~LET `~tokenã‚’èª­å–ã‚‹$( %å…¥åŠ› )
â—
Let token be the result of reading from input.
</li>
					<li>
%çµæœ ~LET `~tokenã‚’å‡¦ç†ã™ã‚‹$( %~token, `~UTF-8ç¬¦å·åŒ–å™¨$, %å…¥åŠ›, %å‡ºåŠ› )
â—
Let result be the result of processing token for the UTF-8 encoder, input, output.
</li>
					<li>
<p>
~Assertï¼š
%çµæœ ~NEQ `~error$
â—
Assert: result is not error.
</p>

<p class="note">æ³¨è¨˜ï¼š
`~UTF-8ç¬¦å·åŒ–å™¨$ãŒ`~error$ã‚’è¿”ã™ã“ã¨ã¯ãªã„ã€‚
â—
The UTF-8 encoder cannot return error.
</p>
					</li>
					<li>
~IFï¼»
%çµæœ ~EQ `å®Œé‚d$
ï¼½
â‡’
~RET ï¼»ï¼»
%å‡ºåŠ› ã‚’~byteåˆ—ã«å¤‰æ›ã—ãŸçµæœ
ï¼½ã‚’åŒ…å«ã™ã‚‹ `ArrayBuffer$I
ï¼½ã‚’åŒ…è£…ã™ã‚‹ï¼Œæ–°ãŸãª `Uint8Array$I ~obj
â—
If result is finished, convert output into a byte sequence, and then return a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt>`encodeInto(source, destination)@m</dt>
	<dd>
<p>
è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
The encodeInto(source, destination) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%read ~LET 0
â—
Let read be 0.
</li>
			<li>
%written ~LET 0
â—
Let written be 0.
</li>
			<li>
%è¡Œå…ˆ~byteåˆ— ~LET %destination ãŒä¿æŒã—ã¦ã„ã‚‹`~byteåˆ—ã¸ã®å‚ç…§ã‚’å–å¾—-$ã—ãŸçµæœ
â—
Let destinationBytes be the result of getting a reference to the bytes held by destination.
</li>
			<li>
%~~ä¸Šé™ ~LET %è¡Œå…ˆ~byteåˆ— ã®`é•·ã•$byte
â—
â†“</li>
			<li>
<p>
%åˆ©ç”¨ã•ã‚Œãªã„ ~LET æ–°ãŸãª`~stream$
â—
Let unused be a new stream.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä¸‹ã«ã¦å‘¼å‡ºã•ã‚Œã‚‹`~handler$~algoã¯
ã“ã®å¼•æ•°ã‚’è¦æ±‚ã™ã‚‹ãŒã€`~UTF-8ç¬¦å·åŒ–å™¨$ã¯ãã‚Œã‚’åˆ©ç”¨ã—ãªã„ã€‚
â—
The handler algorithm invoked below requires this argument, but it is not used by the UTF-8 encoder.
</p>
			</li>
			<li>
%source ~SET %source ã‚’`~stream$ã«å¤‰æ›ã—ãŸçµæœ
â—
Convert source to a stream.
</li>
			<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
				<ol>
					<li>
%~token ~LET `~tokenã‚’èª­å–ã‚‹$( %source )
â—
Let token be the result of reading from source.
</li>
					<li>
%çµæœ ~LET æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ`~UTF-8ç¬¦å·åŒ–å™¨$ã®`~handler$ã‚’èµ°ã‚‰ã›ãŸçµæœ
â‡’
( %åˆ©ç”¨ã•ã‚Œãªã„, %~token )
â—
Let result be the result of running the UTF-8 encoderâ€™s handler on unused and token.
</li>
					<li>
~IFï¼»
%çµæœ ~EQ `å®Œé‚d$
ï¼½
â‡’
~BREAK
â—
If result is finished, then break.
â—
Otherwise:
</li>
					<li>
~IFï¼»
%written ~PLUS %çµæœ ã‚’æˆã™~byteæ•° ~GT %~~ä¸Šé™
ï¼½
â‡’
~BREAK
â—
If destinationBytesâ€™s length âˆ’ written is greater than or equal to the number of bytes in result, then:
</li>
					<li>
%read ~INCBY ï¼»
%~token ~LTE `FFFF^U ãªã‚‰ã° 1 ï¼
~ELSE_ 2
ï¼½
â—
â€¢ If token is greater than U+FFFF, then increment read by 2.
â€¢ Otherwise, increment read by 1.
</li>
					<li>
<p>
%è¡Œå…ˆ~byteåˆ— ã®ä¸­ã¸ï¼Œ~byte~offset %written ã®æ‰€ã‹ã‚‰ %çµæœ ã‚’æ›¸è¾¼ã‚€
â—
â€¢ Write the bytes in result into destinationBytes, from byte offset written.
</p>

<p class="warning">
ä¸Šè¿°ã—ãŸ
<a href="#sharedarraybuffer-warning">`SharedArrayBuffer^I ~objç”¨ã®è­¦å‘Š</a>
ã‚’è¦‹ã‚ˆã€‚
â—
See the warning for SharedArrayBuffer objects above.
</p>

					</li>
					<li>
%written ~INCBY %çµæœ ã‚’æˆã™~byteæ•°
â—
â€¢ Increment written by the number of bytes in result.
â—
Otherwise, break.
</li>
				</ol>
			</li>
			<li>
~RET æ¬¡ã®ã‚ˆã†ã«ã•ã‚ŒãŸæ–°ãŸãª `TextEncoderEncodeIntoResult$I è¾æ›¸
â‡’ï¼ƒ
`read$m ~member ~SET %read,
`written$m ~member ~SET %written
â—
Return a new TextEncoderEncodeIntoResult dictionary whose read member is read and written member is written.
</li>
		</ol>
	</dd>
</dl>

<div class="example">
<p>
`encodeInto()$m ~methodã‚’åˆ©ç”¨ã™ã‚Œã°ã€æ–‡å­—åˆ—ã‚’æ—¢å­˜ã® `ArrayBuffer$I ~objã®ä¸­ã¸ç¬¦å·åŒ–ã§ãã‚‹ã€‚
ä¸‹ã«ãŠã‘ã‚‹æ§˜ã€…ãªè©³ç´°ã¯ï¼Œèª­è€…~å‘ã‘ã®æ¼”ç¿’ã¨ã—ã¦æ®‹ã—ã¦ãŠããŒã€ã“ã®ä¾‹ã¯ï¼Œã“ã®~methodã®ç”¨-æ³•ã®ä¸€ã¤ã‚’ç¤ºã™ã‚‚ã®ã§ã‚ã‚‹ï¼š
â—
The encodeInto() method can be used to encode a string into an existing ArrayBuffer object. Various details below are left as an exercise for the reader, but this demonstrates an approach one could take to use this method:
</p>

<pre>
function convertString(%buffer, %input, %callback) {
  let %bufferSize = 256,
      %bufferStart = malloc(%buffer, %bufferSize),
      %writeOffset = 0,
      %readOffset = 0;
  while (true) {
    const view = new Uint8Array(%buffer, %bufferStart + %writeOffset, %bufferSize - %writeOffset),
          {%read, %written} = cachedEncoder.encodeInto(%input.substring(%readOffset), view);
    %readOffset += %read;
    %writeOffset += %written;
    if (%readOffset === %input.length) {
      %callback(%bufferStart, %writeOffset);
      free(%buffer, %bufferStart);
      return;
    }
    %bufferSize *= 2;
    %bufferStart = realloc(%buffer, %bufferStart, %bufferSize);
  }
}
</pre>
</div>

		</section>
		<section id="interface-mixin-generictransformstream">
<h3 title="Interface mixin GenericTransformStream">7.5. ~interface~mixin `GenericTransformStream^I</h3>

<p>
`GenericTransformStream$I ~interface~mixinã¯ã€~IDLã«ãŠã„ã¦`å½¢å¼å¤‰æ›~stream$ã®æ¦‚å¿µã‚’è¡¨ç¾ã™ã‚‹ã€‚
ãã‚Œã¯ã€ `TransformStream$I ã§ã¯ãªã„
â€” åŒã˜~interfaceã‚’å‚™ãˆï¼Œãã®ä¸€ã¤ã¸å§”è­²ã•ã‚Œã‚‹ãŒã€‚
â—
The GenericTransformStream interface mixin represents the concept of a transform stream in IDL. It is not a TransformStream, though it has the same interface and it delegates to one.
</p>

<pre class="idl">
interface mixin `GenericTransformStream@I {
  readonly attribute `ReadableStream$I `readable$m;
  readonly attribute `WritableStream$I `writable$m;
};
</pre>

<p>
`GenericTransformStream$I ã‚’å†…åŒ…ã™ã‚‹å„~objã«ã¯ã€ `TransformStream$I å‹ã®
`å½¢å¼å¤‰æ›@
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
â—
An object that includes GenericTransformStream has an associated transform of type TransformStream.
</p>

<dl>
	<dt>`readable@m</dt>
	<dd>
å–å¾—å­ã¯ã€æ¬¡ã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«
â‡’
æ­¤ã‚Œã®`å½¢å¼å¤‰æ›$ . `readable^sl
â—
The readable attributeâ€™s getter, when invoked, must return this objectâ€™s transform.[[readable]].
</dd>

	<dt>`writable@m</dt>
	<dd>
å–å¾—å­ã¯æ¬¡ã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«
â‡’
æ­¤ã‚Œã®`å½¢å¼å¤‰æ›$ . `writable^sl
â—
The writable attributeâ€™s getter, when invoked, must return this objectâ€™s transform.[[writable]].
</dd>
</dl>

		</section>
		<section id="interface-textdecoderstream">
<h3 title="Interface TextDecoderStream">7.6. Interface `TextDecoderStream$I</h3>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `TextDecoderStream@I {
  `TextDecoderStream$mc(
    optional `DOMString$ %label = "utf-8",
    optional `TextDecoderOptions$I %options
  );
};
`TextDecoderStream$I includes `TextDecoderCommon$I;
`TextDecoderStream$I includes `GenericTransformStream$I;
</pre>

<p>
å„ `TextDecoderStream$I ~objã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`å¾©å·å™¨@ts,
`~stream@ts
â—
A TextDecoderStream object has an associated decoder, and stream.
</p>

<dl class="domintro">
	<dt>%decoder = new <a href="#dom-textdecoderstream">TextDecoderStream([%label = "utf-8" [, %options]])</a></dt>
	<dd>
æ–°ãŸãª `TextDecoderStream$I ~objã‚’è¿”ã™ã€‚
â—
Returns a new TextDecoderStream object.
</dd>
	<dd>
%label ãŒï¼»
`~label$ã§ãªã„ï¼
`replacement$n ç”¨ã®`~label$ã§ã‚ã‚‹
ï¼½å ´åˆã€ `RangeError$E ãŒ`æŠ•å‡º-$ã•ã‚Œã‚‹ã€‚
â—
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`ç¬¦å·åŒ–æ³•$decã®`åå‰$ã‚’ï¼Œå°æ–‡å­—~åŒ–ã—ãŸä¸Šã§è¿”ã™ã€‚
â—
Returns encodingâ€™s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
ï¼»
`~error~mode$dec ~EQ `fatal^l ãªã‚‰ã° ~T ï¼
~ELSE_ ~F
ï¼½ã‚’è¿”ã™ã€‚
â—
Returns true if error mode is "fatal", and false otherwise.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
ï¼»
`~BOMignore~flag$dec ~EQ ~T ãªã‚‰ã° ~T ï¼
~ELSE_ ~F
ï¼½ã‚’è¿”ã™ã€‚
â—
Returns true if ignore BOM flag is set, and false otherwise.
</dd>

	<dt>%decoder . `readable$m</dt>
	<dd>
`å¯èª­~stream$ã‚’è¿”ã™ã€‚
ãã®`~chunk$ãŸã¡ã¯ã€ `writable$m ã«æ›¸è¾¼ã¾ã‚ŒãŸ~chunkãŸã¡ã«å¯¾ã—ï¼Œ`ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ã‚’èµ°ã‚‰ã›ãŸçµæœã®æ–‡å­—åˆ—ãŸã¡ã«ãªã‚‹ã€‚
â—
Returns a readable stream whose chunks are strings resulting from running encodingâ€™s decoder on the chunks written to writable.
</dd>

	<dt>%decoder . `writable$m</dt>
	<dd>
`å¯æ›¸~stream$ã‚’è¿”ã™ã€‚
ãã‚Œã¯ã€ï¼»
[`AllowShared$xA] `BufferSource$I
ï¼½å‹ã®~chunkãŸã¡ã‚’å—å®¹ã—ã¦
â€” `readable$m ã«å¯ç”¨ã«ã•ã‚Œã‚‹å‰ã« â€”
`ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ã«ã‹ã‘ã‚‹ã€‚

â—
Returns a writable stream which accepts [AllowShared] BufferSource chunks and runs them through encodingâ€™s decoder before making them available to readable.
</dd>
	<dd>
<p>
ã“ã‚Œã¯æ¦‚ã—ã¦ã€ `ReadableStream$I æºã® `pipeThrough$m ~methodã‚’ä»‹ã—ã¦åˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
Typically this will be used via the pipeThrough() method on a ReadableStream source.
</p>

<pre class="example">
var %decoder = new TextDecoderStream(%encoding);
byteReadable
  .pipeThrough(%decoder)
  .pipeTo(%textWritable);
</pre>

</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l
ã‹ã¤`ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ã¯`~error$ã‚’è¿”ã™å ´åˆã€
`readable$m, `writable$m
ã¨ã‚‚ `TypeError$E ã§~errorã«ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
If the error mode is "fatal" and encodingâ€™s decoder returns error, both readable and writable will be errored with a TypeError.
</dd>
</dl>

<dl class="idl-def">
	<dt>`TextDecoderStream(label, options)@m</dt>
	<dd>
<p>
ã“ã®æ§‹ç¯‰å­ã®è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
The TextDecoderStream(label, options) constructor, when invoked, must run these steps:
</p>
		<ol>
			<li>
%ç¬¦å·åŒ–æ³• ~LET `~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹$( %label )
â—
Let encoding be the result of getting an encoding from label.
</li>
			<li>
~IFï¼»
%ç¬¦å·åŒ–æ³• ~IN { `å¤±æ•—^i, `replacement$n }
ï¼½
â‡’
~THROW `RangeError$E
â—
If encoding is failure or replacement, then throw a RangeError.
</li>
			<li>
%dec ~LET æ–°ãŸãª `TextDecoderStream$I ~obj
â—
Let dec be a new TextDecoderStream object.
</li>
			<li>
%dec ã®`ç¬¦å·åŒ–æ³•$dec ~SET %ç¬¦å·åŒ–æ³•
â—
Set decâ€™s encoding to encoding.
</li>
			<li>
~IFï¼»
%options ã® `fatal$mb ~member ~EQ ~T
ï¼½
â‡’
%dec ã®`~error~mode$dec ~SET `fatal^l
â—
If optionsâ€™s fatal member is true, then set decâ€™s error mode to "fatal".
</li>
			<li>
~IFï¼»
%options ã®`ignoreBOM$mb ~member ~EQ ~T
ï¼½
â‡’
%dec ã®`~BOMignore~flag$dec ~SET ~T
â—
If optionsâ€™s ignoreBOM member is true, then set decâ€™s ignore BOM flag.
</li>
			<li>
%dec ã®`å¾©å·å™¨$ts ~SET %dec ã®`ç¬¦å·åŒ–æ³•$decç”¨ã®æ–°ãŸãª`å¾©å·å™¨$
â—
Set decâ€™s decoder to a new decoder for decâ€™s encoding, andï¼¼
</li>
			<li>
%dec ã®`~stream$ts ~SET æ–°ãŸãª`~stream$
â—
set decâ€™s stream to a new stream.
</li>
			<li>
%é–‹å§‹~algo ~LET å¼•æ•°ã‚’ã¨ã‚‰ãšï¼Œä½•ã‚‚è¿”ã•ãªã„~algo
â—
Let startAlgorithm be an algorithm that takes no arguments and returns nothing.
</li>
			<li>
%å½¢å¼å¤‰æ›~algo ~LET
( %~chunk ) ã‚’å¼•æ•°ã«ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™~algo
â‡’
`~chunkã‚’å¾©å·ã—ã¦~enqueueã™ã‚‹$( %dec, %~chunk )
â—
Let transformAlgorithm be an algorithm which takes a chunk argument and runs the decode and enqueue a chunk algorithm with dec and chunk.
</li>
			<li>
%ä¸€æƒã™ã‚‹~algo ~LET å¼•æ•°ã‚’ã¨ã‚‰ãšï¼Œæ¬¡ã‚’èµ°ã‚‰ã™~algo
â‡’
`ä¸€æƒã—ã¦~enqueueã™ã‚‹$( %dec )
â—
Let flushAlgorithm be an algorithm which takes no arguments and runs the flush and enqueue algorithm with dec.
</li>
			<li>
%dec ã®`å½¢å¼å¤‰æ›$ ~SET æ¬¡ã‚’~callã—ãŸçµæœ
â‡’
`CreateTransformStream$jA( %é–‹å§‹~algo, %å½¢å¼å¤‰æ›~algo, %ä¸€æƒã™ã‚‹~algo )
â—
Let transform be the result of calling CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm).
â—
Set decâ€™s transform to transform.
</li>
			<li>
~RET %dec
â—
Return dec.
</li>
		</ol>
	</dd>
</dl>

<div class="algorithm">
<p>
`~chunkã‚’å¾©å·ã—ã¦~enqueueã™ã‚‹@
~algoã¯ã€æ‰€ä¸ã®
( `TextDecoderStream$I ~obj %dec, %~chunk )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
The decode and enqueue a chunk algorithm, given a TextDecoderStream object dec and a chunk, runs these steps:
</p>
<ol>
	<li>
%~bufferæº ~LET %~chunk ã‚’ï¼»
[`AllowShared$xA] `BufferSource$I
ï¼½å‹ã®`~IDLå€¤ã«å¤‰æ›-$ã—ãŸçµæœ
â‡’
ä¾‹å¤–ãŒæŠ•å‡ºã•ã‚ŒãŸã¨ãã¯
â‡’
~RET ãã®ä¾‹å¤–ã§`å´ä¸‹ã•ã‚Œã‚‹~promise$
â—
Let bufferSource be the result of converting chunk to an [AllowShared] BufferSource. If this throws an exception, then return a promise rejected with that exception.
</li>
	<li>
<p>
%dec ã®`~stream$tsã«æ¬¡ã®çµæœã‚’`~pushã™ã‚‹$
â‡’
`è¤‡è£½ã‚’å–å¾—ã™ã‚‹$( %~bufferæº )
â‡’
ä¾‹å¤–ãŒæŠ•å‡ºã•ã‚ŒãŸã¨ãã¯
â‡’
~RET ãã®ä¾‹å¤–ã§`å´ä¸‹ã•ã‚Œã‚‹~promise$
â—
Push a copy of bufferSource to decâ€™s stream. If this throws an exception, then return a promise rejected with that exception.
</p>

<p class="warning">
ä¸Šè¿°ã—ãŸ
<a href="#sharedarraybuffer-warning">`SharedArrayBuffer^I ~objç”¨ã®è­¦å‘Š</a>
ã‚’è¦‹ã‚ˆã€‚
â—
See the warning for SharedArrayBuffer objects above.
</p>

	</li>
	<li>
%åˆ¶å¾¡å™¨ ~LET
%dec ã®`å½¢å¼å¤‰æ›$ . `transformStreamController^sl
â—
Let controller be decâ€™s transform.[[transformStreamController]].
</li>
	<li>
%å‡ºåŠ› ~LET æ–°ãŸãª`~stream$
â—
Let output be a new stream.
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶
â—
While true, run these steps:
</p>
		<ol>
			<li>
%~token ~LET `~tokenã‚’èª­å–ã‚‹$( %dec ã®`~stream$ts )
â—
Let token be the result of reading from decâ€™s stream.
</li>
			<li>
<p>
~IFï¼»
%~token ~EQ `~EoS$
ï¼½ï¼š
â—
If token is end-of-stream, run these steps:
</p>
				<ol>
					<li>
%å‡ºåŠ›~chunk ~LET `~streamã‚’ç›´åˆ—åŒ–ã™ã‚‹$dec( %å‡ºåŠ› )
â—
Let outputChunk be output, serialized.
</li>
					<li>
~IFï¼»
%å‡ºåŠ›~chunk ã¯ç©ºã§ãªã„
ï¼½
â‡’
æ¬¡ã‚’~callã™ã‚‹
â‡’
`TransformStreamDefaultControllerEnqueue$jA( %åˆ¶å¾¡å™¨, %å‡ºåŠ›~chunk )
â—
if outputChunk is non-empty, call TransformStreamDefaultControllerEnqueue(controller, outputChunk).
</li>
					<li>
~RET `undefined^jv ã§`è§£æ±ºã•ã‚Œã‚‹~promise$
â—
Return a new promise resolved with undefined.
</li>
				</ol>
			</li>
			<li>
%çµæœ ~LET `~tokenã‚’å‡¦ç†ã™ã‚‹$( %~token, %dec ã®`å¾©å·å™¨$ts, %dec ã®`~stream$ts, %å‡ºåŠ›, %dec ã®`~error~mode$dec )
â—
Let result be the result of processing token for decâ€™s decoder, decâ€™s stream, output, and decâ€™s error mode.
</li>
			<li>
~IFï¼»
%çµæœ ~EQ `~error$
ï¼½
â‡’
~RET `TypeError$E ä¾‹å¤–ã§`å´ä¸‹ã•ã‚Œã‚‹~promise$
â—
If result is error, then return a new promise rejected with a TypeError exception.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">
<p>
`ä¸€æƒã—ã¦~enqueueã™ã‚‹@
~algoã¯ã€
å…¥åŠ› `ReadableStream$I ~objã‹ã‚‰ã®~dataã®çµ‚ç«¯ã‚’å–æ‰±ã†
â€” ãã‚Œã¯ã€æ‰€ä¸ã®
( `TextDecoderStream$I ~obj %dec )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
The flush and enqueue algorithm, which handles the end of data from the input ReadableStream object, given a TextDecoderStream object dec, runs these steps:
</p>
<ol>
	<li>
%å‡ºåŠ› ~LET æ–°ãŸãª`~stream$
â—
Let output be a new stream.
</li>
	<li>
%çµæœ ~LET `~tokenã‚’å‡¦ç†ã™ã‚‹$( `~EoS$, %dec ã®`å¾©å·å™¨$ts, %dec ã®`~stream$ts, %å‡ºåŠ›, %dec ã®`~error~mode$dec )
â—
Let result be the result of processing end-of-stream for decâ€™s decoder and decâ€™s stream, output, and decâ€™s error mode.
</li>
	<li>
<p>
~IFï¼»
%çµæœ ~EQ `å®Œé‚d$
ï¼½ï¼š
â—
If result is finished, run these steps:
</p>
		<ol>
			<li>
%å‡ºåŠ›~chunk ~LET `~streamã‚’ç›´åˆ—åŒ–ã™ã‚‹$dec( %å‡ºåŠ› )
â—
Let outputChunk be output, serialized.
</li>
			<li>
%åˆ¶å¾¡å™¨ ~LET
%dec ã®`å½¢å¼å¤‰æ›$ . `transformStreamController^sl
â—
Let controller be decâ€™s transform.[[transformStreamController]].
</li>
			<li>
~IFï¼»
%å‡ºåŠ›~chunk ã¯ç©ºã§ãªã„
ï¼½
â‡’
æ¬¡ã‚’~callã™ã‚‹
â‡’
`TransformStreamDefaultControllerEnqueue$jA( %åˆ¶å¾¡å™¨, %å‡ºåŠ›~chunk )
â—
If outputChunk is non-empty, call TransformStreamDefaultControllerEnqueue(controller, outputChunk).
</li>
			<li>
~RET `undefined^jv ã§`è§£æ±ºã•ã‚Œã‚‹~promise$
â—
Return a new promise resolved with undefined.
</li>
		</ol>
	</li>
	<li>
~ELSE
â‡’
~RET `TypeError$E ä¾‹å¤–ã§`å´ä¸‹ã•ã‚Œã‚‹~promise$
â—
Otherwise, return a new promise rejected with a TypeError exception.
</li>
	</ol>
</div>

		</section>
		<section id="interface-textencoderstream">
<h3 title="Interface TextEncoderStream">7.7. ~interface `TextEncoderStream^I</h3>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `TextEncoderStream@I {
  `TextEncoderStream$mc();
};

`TextEncoderStream$I includes `TextEncoderCommon$I;
`TextEncoderStream$I includes `GenericTransformStream$I;
</pre>

<p>
å„ `TextEncoderStream$I ~objã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`ç¬¦å·åŒ–å™¨@ts,
`å‡¦ç†å¾…ã¡é«˜ä½~surrogate@ ï¼ˆåˆæœŸ~æ™‚ã«ã¯~NULL)
â—
A TextEncoderStream object has an associated encoder, and pending high surrogate (initially null).
</p>

<p class="note">æ³¨è¨˜ï¼š
`TextEncoderStream$I ~objã¯ `UTF-8$n ã—ã‹~supportã—ãªã„ã®ã§ã€
%~label å¼•æ•° ã‚’æä¾›ã—ãªã„ã€‚
â—
A TextEncoderStream object offers no label argument as it only supports UTF-8.
</p>

<dl class="domintro">
	<dt>%encoder = new `TextEncoderStream()$m</dt>
	<dd>
æ–°ãŸãª `TextEncoderStream$I ~objã‚’è¿”ã™ã€‚
â—
Returns a new TextEncoderStream object.
</dd>
	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l ã‚’è¿”ã™ã€‚
â—
Returns "utf-8".
</dd>

	<dt>%encoder . `readable$m</dt>
	<dd>
`å¯èª­~stream$ã‚’è¿”ã™ã€‚
ãã®å„`~chunk$ã¯ã€ `writable$m ã«æ›¸è¾¼ã¾ã‚ŒãŸ~chunkãŸã¡ã«å¯¾ã—
`UTF-8$n ã®`ç¬¦å·åŒ–å™¨$ã‚’èµ°ã‚‰ã›ãŸçµæœã® `Uint8Array$I ã«ãªã‚‹ã€‚
â—
Returns a readable stream whose chunks are Uint8Arrays resulting from running UTF-8â€™s encoder on the chunks written to writable.
</dd>

	<dt>%encoder . `writable$m</dt>
	<dd>
`å¯æ›¸~stream$ã‚’è¿”ã™ã€‚
ãã‚Œã¯ã€æ–‡å­—åˆ—~chunkãŸã¡ã‚’å—å®¹ã—ã¦
â€” `readable$m ã«å¯ç”¨ã«ã•ã‚Œã‚‹å‰ã« â€”
`UTF-8$n ã®`ç¬¦å·åŒ–å™¨$ã«ã‹ã‘ã‚‹ã€‚
â—
Returns a writable stream which accepts string chunks and runs them through UTF-8â€™s encoder before making them available to readable.
</dd>
	<dd>
<p>
ã“ã‚Œã¯æ¦‚ã—ã¦ã€
`ReadableStream$I æºã® `pipeThrough$m ~methodã‚’ä»‹ã—ã¦åˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
Typically this will be used via the pipeThrough() method on a ReadableStream source.
</p>

<pre class="example">
%textReadable
  .pipeThrough(new TextEncoderStream())
  .pipeTo(%byteWritable);
</pre>

	</dd>
</dl>

<dl class="idl-def">
	<dt>`TextEncoderStream()@m</dt>
	<dd>
<p>
ã“ã®æ§‹ç¯‰å­ã®è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
The TextEncoderStream() constructor, when invoked, must run these steps:
</p>
		<ol>
			<li>
%enc ~LET æ–°ãŸãª `TextEncoderStream$I ~obj
â—
Let enc be a new TextEncoderStream object.
</li>
			<li>
%enc ã®`ç¬¦å·åŒ–å™¨$ts ~SET `UTF-8$n ã®`ç¬¦å·åŒ–å™¨$
â—
Set encâ€™s encoder to UTF-8â€™s encoder.
</li>
			<li>
%é–‹å§‹~algo ~LET å¼•æ•°ã‚’ã¨ã‚‰ãšï¼Œä½•ã‚‚è¿”ã•ãªã„~algo
â—
Let startAlgorithm be an algorithm that takes no arguments and returns nothing.
</li>
			<li>
%å½¢å¼å¤‰æ›~algo ~LET ( %~chunk ) ã‚’å¼•æ•°ã«ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™~algo
â‡’
`~chunkã‚’ç¬¦å·åŒ–ã—ã¦~enqueueã™ã‚‹$( %enc, %~chunk )
â—
Let transformAlgorithm be an algorithm which takes a chunk argument and runs the encode and enqueue a chunk algorithm with enc and chunk.
</li>
			<li>
%ä¸€æƒã™ã‚‹~algo ~LET æ¬¡ã‚’èµ°ã‚‰ã™~algo
â‡’
`ç¬¦å·åŒ–ã—ã¦ä¸€æƒã™ã‚‹$( %enc )
â—
Let flushAlgorithm be an algorithm which runs the encode and flush algorithm with enc.
</li>
			<li>
%enc ã®`å½¢å¼å¤‰æ›$ ~SET æ¬¡ã‚’~callã—ãŸçµæœ
â‡’
`CreateTransformStream$jA( %é–‹å§‹~algo, %å½¢å¼å¤‰æ›~algo, %ä¸€æƒã™ã‚‹~algo )
â—
Let transform be the result of calling CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm).
â—
Set encâ€™s transform to transform.
</li>
			<li>
~RET %enc
â—
Return enc.
</li>
		</ol>
	</dd>
</dl>

<hr>

<div class="algorithm">
<p>
`~chunkã‚’ç¬¦å·åŒ–ã—ã¦~enqueueã™ã‚‹@
~algoã¯ã€æ‰€ä¸ã®
( `TextEncoderStream$I ~obj %enc, %~chunk )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
The encode and enqueue a chunk algorithm, given a TextEncoderStream object enc and chunk, runs these steps:
</p>
<ol>
	<li>
<p>
%å…¥åŠ› ~LET %~chunk ã‚’ `DOMString^I å‹ã®`~IDLå€¤ã«å¤‰æ›-$ã—ãŸçµæœ
â‡’
ä¾‹å¤–ãŒæŠ•å‡ºã•ã‚ŒãŸã¨ãã¯
â‡’
~RET ãã®ä¾‹å¤–ã§`å´ä¸‹ã•ã‚Œã‚‹~promise$
â—
Let input be the result of converting chunk to a DOMString. If this throws an exception, then return a promise rejected with that exception.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã“ã§ã¯ `DOMString^I ãŒåˆ©ç”¨ã•ã‚Œã‚‹
â€” 2 ã¤ã®~chunkã«åˆ†å‰²ã•ã‚ŒãŸ~surrogate~pairã‚’ï¼Œé©åˆ‡ãª~scalarå€¤ã«çµ„ç«‹ç›´ã›ã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€‚
ä»–ã®æŒ™å‹•ã¯ `USVString^I ã¨ä¸€è‡´ã™ã‚‹
â€” ç‰¹ã«ï¼Œ~~å­¤ç«‹ã—ãŸ~surrogateã¯ `FFFD^U ã«ç½®æ›ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
DOMString is used here so that a surrogate pair that is split between chunks can be reassembled into the appropriate scalar value. The behavior is otherwise identical to USVString. In particular, lone surrogates will be replaced with U+FFFD.
</p>
	</li>
	<li>
%å…¥åŠ› ã‚’`~stream$ã«å¤‰æ›ã™ã‚‹
â—
Convert input to a stream.
</li>
	<li>
%å‡ºåŠ› ~LET æ–°ãŸãª`~stream$
â—
Let output be a new stream.
</li>
	<li>
%åˆ¶å¾¡å™¨ ~LET
%enc ã®`å½¢å¼å¤‰æ›$ . `transformStreamController^sl
â—
Let controller be encâ€™s transform.[[transformStreamController]].
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶
â—
While true, run these steps:
</p>
		<ol>
			<li>
%~token ~LET `~tokenã‚’èª­å–ã‚‹$( %å…¥åŠ› )
â—
Let token be the result of reading from input.
</li>
			<li>
<p>
~IFï¼»
%~token ~EQ `~EoS$
ï¼½ï¼š
â—
If token is end-of-stream, run these steps:
</p>
				<ol>
					<li>
%å‡ºåŠ› ~SET %å‡ºåŠ› ã‚’~byteåˆ—ã«å¤‰æ›ã—ãŸçµæœ
â—
Convert output into a byte sequence.
</li>
					<li>
<p>
~IFï¼»
%å‡ºåŠ› ã¯ç©ºã§ãªã„
ï¼½ï¼š
â—
If output is non-empty, run these steps:
</p>
						<ol>
							<li>
%~chunk ~LET %å‡ºåŠ› ã‚’åŒ…å«ã—ã¦ã„ã‚‹ `ArrayBuffer$I ã‚’åŒ…è£…ã™ã‚‹ï¼Œæ–°ãŸãª `Uint8Array$I ~obj
â—
Let chunk be a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
							<li>
æ¬¡ã‚’~callã™ã‚‹
â‡’
`TransformStreamDefaultControllerEnqueue$jA( %åˆ¶å¾¡å™¨, %~chunk )
â—
Call TransformStreamDefaultControllerEnqueue(controller, chunk).
</li>
						</ol>
					</li>
					<li>
~RET `undefined^jv ã§`è§£æ±ºã•ã‚Œã‚‹~promise$
â—
Return a new promise resolved with undefined.
</li>
				</ol>
			</li>
			<li>
%çµæœ ~LET `~cuã‚’~scalarå€¤ã«å¤‰æ›ã™ã‚‹$( %enc, %~token, %å…¥åŠ› )
â—
Let result be the result of executing the convert code unit to scalar value algorithm with enc, token and input.
</li>
			<li>
~IFï¼»
%çµæœ ~NEQ `ç¶™ç¶š-$
ï¼½
â‡’
`~tokenã‚’å‡¦ç†ã™ã‚‹$( %çµæœ, `ç¬¦å·åŒ–å™¨$ts, %å…¥åŠ›, %å‡ºåŠ› )
â—
If result is not continue, then process result for encoder, input, output.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">
<p>
`~cuã‚’~scalarå€¤ã«å¤‰æ›ã™ã‚‹@
~algoã¯ã€æ‰€ä¸ã®
( `TextEncoderStream$I ~obj %enc, %~token, ~stream %å…¥åŠ› )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
The convert code unit to scalar value algorithm, given a TextEncoderStream object enc, token, and stream input, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%enc ã®`å‡¦ç†å¾…ã¡é«˜ä½~surrogate$ ~NEQ ~NULL
ï¼½ï¼š
â—
If encâ€™s pending high surrogate is non-null, run these steps:
</p>
		<ol>
			<li>
%é«˜ä½~surrogate ~LET
%enc ã®`å‡¦ç†å¾…ã¡é«˜ä½~surrogate$

â—
Let high surrogate be encâ€™s pending high surrogate.
</li>
			<li>
%enc ã®`å‡¦ç†å¾…ã¡é«˜ä½~surrogate$ ~SET ~NULL
â—
Set encâ€™s pending high surrogate to null.
</li>
			<li>
~IFï¼»
%~token ~IN { `DC00^U ã€œ `DFFF^U }
ï¼½
â‡’
~RET ~cp [ `10000^X + (( %é«˜ä½~surrogate ~MINUS `D800^X ) ~Lshift 10) + ( %~token ~MINUS `DC00^X ) ]
â—
If token is in the range U+DC00 to U+DFFF, inclusive, then return a code point whose value is 0x10000 + ((high surrogate âˆ’ 0xD800) &lt;&lt; 10) + (token âˆ’ 0xDC00).
</li>
			<li>
%å…¥åŠ› ã« %~token ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend token to input.
</li>
			<li>
~RET `FFFD^U
â—
Return U+FFFD.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~token ~IN { `D800^U ã€œ `DBFF^U }
ï¼½
â‡’ï¼ƒ
`å‡¦ç†å¾…ã¡é«˜ä½~surrogate$ ~SET %~tokenï¼›
~RET `ç¶™ç¶š-$
â—
If token is in the range U+D800 to U+DBFF, inclusive, then set pending high surrogate to token and return continue.
</li>
	<li>
~IFï¼»
%~token ~IN { `DC00^U ã€œ `DFFF^U }
ï¼½
â‡’
~RET `FFFD^U
â—
If token is in the range U+DC00 to U+DFFF, inclusive, then return U+FFFD.
</li>
	<li>
~RET %~token
â—
Return token.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ `INFRA$r ã«ã‚ˆã‚‹
`~JSæ–‡å­—åˆ—$ã‚’`~scalarå€¤~æ–‡å­—åˆ—$ã«
<a href="~INFRA#javascript-string-convert">å¤‰æ›ã™ã‚‹~algo</a>ã¨ç­‰ä¾¡ã«ãªã‚‹ãŒã€
2 ã¤ã®æ–‡å­—åˆ—ã«åˆ†å‰²ã•ã‚ŒãŸ~surrogate~pairã‚‚è¨±å®¹ã™ã‚‹ã€‚
`INFRA$r
â—
This is equivalent to the "convert a JavaScript string into a scalar value string" algorithm from the Infra Standard, but allows for surrogate pairs that are split between strings. [INFRA]
</p>
</div>

<div class="algorithm">
<p>
`ç¬¦å·åŒ–ã—ã¦ä¸€æƒã™ã‚‹@
~algoã¯ã€æ‰€ä¸ã®
( `TextEncoderStream$I ~obj %enc )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
The encode and flush algorithm, given a TextEncoderStream object enc, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%enc ã®`å‡¦ç†å¾…ã¡é«˜ä½~surrogate$ ~NEQ ~NULL
ï¼½ï¼š
â—
If encâ€™s pending high surrogate is non-null, run these steps:
</p>
		<ol>
			<li>
%åˆ¶å¾¡å™¨ ~LET %enc ã®`å½¢å¼å¤‰æ›$ . `transformStreamController^sl
â—
Let controller be encâ€™s transform.[[transformStreamController]].
</li>
			<li>
<p>
%å‡ºåŠ› ~LET ~byteåˆ— `EF^X `BF^X `BD^X
â—
Let output be the byte sequence 0xEF 0xBF 0xBD.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€~replacementæ–‡å­— `FFFD^U ã‚’~UTF-8ã«ç¬¦å·åŒ–ã—ãŸã‚‚ã®ã«ãªã‚‹ã€‚
â—
This is the replacement character U+FFFD encoded as UTF-8.
</p>
			</li>
			<li>
%~chunk ~LET %å‡ºåŠ› ã‚’åŒ…å«ã—ã¦ã„ã‚‹ `ArrayBuffer$I ã‚’åŒ…è£…ã™ã‚‹ï¼Œæ–°ãŸãª `Uint8Array$I ~obj
â—
Let chunk be a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
			<li>
æ¬¡ã‚’~callã™ã‚‹
â‡’
`TransformStreamDefaultControllerEnqueue$jA( %åˆ¶å¾¡å™¨, %~chunk )
â—
Call TransformStreamDefaultControllerEnqueue(controller, chunk).
</li>
		</ol>
	</li>
	<li>
~RET `undefined^jv ã§`è§£æ±ºã•ã‚Œã‚‹~promise$
â—
Return a new promise resolved with undefined.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="the-encoding">
<h2 title="The encoding">8. ~~æ¨™æº–ã®ç¬¦å·åŒ–æ³•</h2>

<p class="trans-note">ã€
ã“ã® â€œ~~æ¨™æº–ã®â€ ã¯ â€œTheâ€ ã®å¯¾è¨³ã§ã‚ã‚Šã€ãŠã‚ˆãï¼Œ
â€œè¦ç¯„ã¨ã•ã‚Œã‚‹ã¹ãå”¯ä¸€ç„¡äºŒã®â€
ã‚’æ„å‘³ã™ã‚‹ã€‚
ã€‘</p>

		<section id="utf-8">
<h3>8.1. ~UTF-8</h3>

			<section id="utf-8-decoder">
<h4 title="UTF-8 decoder">8.1.1. ~UTF-8å¾©å·å™¨</h4>

<p class="note">æ³¨è¨˜ï¼š
~BOMã¯ã€`~label$ã‚ˆã‚Š~~å„ªå…ˆã•ã‚Œã‚‹
â€” ãã®æ–¹ãŒé…å‚™-æ¸ˆã¿ã®å†…å®¹ã«ãŠã„ã¦æ­£ç¢ºaã«ãªã‚‹ã‚‚ã®ã¨è¦‹å‡ºã•ã‚ŒãŸã®ã§ã€‚
ã—ãŸãŒã£ã¦ãã‚Œã¯ã€`~UTF-8å¾©å·å™¨$~algoã®ä¸€éƒ¨ã‚’æˆã•ãªã„
â€” ä»£ã‚ã‚Šã«ï¼»
`~Unicodeã«å¾©å·ã™ã‚‹$ ï¼ `~UTF-8å¾©å·ã™ã‚‹$
ï¼½~algoã®ä¸€éƒ¨ã‚’æˆã™ã€‚
â—
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the UTF-8 decoder algorithm but rather the decode and UTF-8 decode algorithms.
</p>

<p>
å„ï¼»
`UTF-8$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`~UTF-8~cp@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰,
`~UTF-8å‡ºç¾~byteæ•°@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰,
`~UTF-8è¦~byteæ•°@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰,
`~UTF-8ä¸‹é™@ï¼ˆåˆæœŸ~æ™‚ `80^X ï¼‰,
`~UTF-8ä¸Šé™@ï¼ˆåˆæœŸ~æ™‚ `BF^X ï¼‰
â—
UTF-8â€™s decoderâ€™s has an associated UTF-8 code point, UTF-8 bytes seen, and UTF-8 bytes needed (all initially 0), a UTF-8 lower boundary (initially 0x80), and a UTF-8 upper boundary (initially 0xBF).
</p>

<p>
`UTF-8$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
UTF-8â€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½~ANDï¼»
`~UTF-8è¦~byteæ•°$ ~NEQ 0
ï¼½
â‡’ï¼ƒ
`~UTF-8è¦~byteæ•°$ ~SET 0ï¼›
~RET `~error$
â—
If byte is end-of-stream and UTF-8 bytes needed is not 0, set UTF-8 bytes needed to 0 and return error.
</li>
	<li>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚d$
â—
If byte is end-of-stream, return finished.
</li>
	<li>
<p>
~IFï¼»
`~UTF-8è¦~byteæ•°$ ~EQ 0
ï¼½ï¼š
â—
If UTF-8 bytes needed is 0, based on byte:
</p>
		<ol>
			<li>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
â†‘</p>

				<dl class="switch">
					<dt>`00^X ã€œ `7F^X</dt>
					<dd>
~RET ~cp [ %~byte ]
â—
Return a code point whose value is byte.
</dd>

					<dt>`C2^X ã€œ `DF^X</dt>
					<dd>
						<ol>
							<li>
`~UTF-8è¦~byteæ•°$ ~SET 1
â—
Set UTF-8 bytes needed to 1.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `1F^X
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 5 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte &amp; 0x1F.
â—
The five least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`E0^X ã€œ `EF^X</dt>
					<dd>
						<ol>
							<li>
~IFï¼»
%~byte ~EQ `E0^X
ï¼½
â‡’
`~UTF-8ä¸‹é™$ ~SET `A0^X
â—
If byte is 0xE0, set UTF-8 lower boundary to 0xA0.
</li>
							<li>
~IFï¼»
%~byte ~EQ `ED^X
ï¼½
â‡’
`~UTF-8ä¸Šé™$ ~SET `9F^X
â—
If byte is 0xED, set UTF-8 upper boundary to 0x9F.
</li>
							<li>
`~UTF-8è¦~byteæ•°$ ~SET 2
â—
Set UTF-8 bytes needed to 2.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `F^X
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 4 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte &amp; 0xF.
â—
The four least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`F0^X ã€œ `F4^X</dt>
					<dd>
						<ol>
							<li>
~IFï¼»
%~byte ~EQ `F0^X
ï¼½
â‡’
`~UTF-8ä¸‹é™$ ~SET `90^X
â—
If byte is 0xF0, set UTF-8 lower boundary to 0x90.
</li>
							<li>
~IFï¼»
%~byte ~EQ `F4^X
ï¼½
â‡’
`~UTF-8ä¸Šé™$ ~SET `8F^X
â—
If byte is 0xF4, set UTF-8 upper boundary to 0x8F.
</li>
							<li>
`~UTF-8è¦~byteæ•°$ ~SET 3
â—
Set UTF-8 bytes needed to 3.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `7^X
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 3 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte &amp; 0x7.
â—
The three least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>
ãã®ä»–
â—
Otherwise
</dt>
					<dd>
~RET `~error$
â—
Return error.
</dd>
				</dl>
			</li>
			<li>
~RET `ç¶™ç¶š-$
â—
Return continue.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
%~byte ~NIN { `~UTF-8ä¸‹é™$ ã€œ `~UTF-8ä¸Šé™$ }
ï¼½ï¼š
â—
If byte is not in the range UTF-8 lower boundary to UTF-8 upper boundary, inclusive, then:
</p>
		<ol>
			<li>
( `~UTF-8~cp$, `~UTF-8è¦~byteæ•°$, `~UTF-8å‡ºç¾~byteæ•°$ ) ~SET ( 0, 0, 0 )
â—
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0,ï¼¼
</li>
			<li>
( `~UTF-8ä¸‹é™$, `~UTF-8ä¸Šé™$ ) ~SET ( `80^X, `BF^X )
â—
set UTF-8 lower boundary to 0x80, and set UTF-8 upper boundary to 0xBF.
</li>
			<li>
%~stream ã« %~byte ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend byte to stream.
</li>
			<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
( `~UTF-8ä¸‹é™$, `~UTF-8ä¸Šé™$ ) ~SET ( `80^X, `BF^X )
â—
Set UTF-8 lower boundary to 0x80 and UTF-8 upper boundary to 0xBF.
</li>
	<li>
<p>
`~UTF-8~cp$ ~SET (`~UTF-8~cp$ ~Lshift 6) ~bOR (%~byte ~bAND `3F^X)
â—
Set UTF-8 code point to (UTF-8 code point &lt;&lt; 6) | (byte &amp; 0x3F)
</p>

<p class="note">
`~UTF-8~cp$å†…ã®æ—¢å­˜ã®~bitã‚’å·¦ã¸ 6 ~bit ~shiftã—ã¦ï¼Œ~~ç©ºã„ãŸä¸‹ä½ 6 ~bitã« %~byte ã®ä¸‹ä½ 6 ~bitã‚’ã‚ã¦ãŒã†ã€‚
â—
Shift the existing bits of UTF-8 code point left by six places and set the newly-vacated six least significant bits to the six least significant bits of byte.
</p>
	</li>
	<li>
`~UTF-8å‡ºç¾~byteæ•°$ ~INCBY 1
â—
Increase UTF-8 bytes seen by one.
</li>
	<li>
~IFï¼»
`~UTF-8å‡ºç¾~byteæ•°$ ~NEQ `~UTF-8è¦~byteæ•°$
ï¼½
â‡’
~RET `ç¶™ç¶š-$
â—
If UTF-8 bytes seen is not equal to UTF-8 bytes needed, return continue.
</li>
	<li>
%~cp ~LET `~UTF-8~cp$
â—
Let code point be UTF-8 code point.
</li>
	<li>
( `~UTF-8~cp$, `~UTF-8è¦~byteæ•°$, `~UTF-8å‡ºç¾~byteæ•°$ ) ~SET ( 0, 0, 0 )
â—
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0.
</li>
	<li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ä¸Šã®`~UTF-8å¾©å·å™¨$ã«ãŠã‘ã‚‹æ‹˜æŸã¯ã€~Unicodeæ¨™æº–ã®
â€œ`Best Practices for Using U+FFFD^enâ€
ã«æº–ã˜ã‚‹ã€‚
ä»–ã®ãµã‚‹ã¾ã„ã¯ Encoding æ¨™æº–ã®ä¸‹ã§ã¯è¨±å¯ã•ã‚Œãªã„ï¼ˆåŒã˜çµæœãŒå¾—ã‚‰ã‚Œã‚‹ãªã‚‰ã€ä»–ã®~algoã§ã‚‚~~ååˆ†ã§ã‚ã‚Šï¼Œã‚€ã—ã‚å¥¨åŠ±ã•ã‚Œã‚‹ï¼‰ã€‚
`UNICODE$r
â—
The constraints in the UTF-8 decoder above match â€œBest Practices for Using U+FFFDâ€ from the Unicode standard. No other behavior is permitted per the Encoding Standard (other algorithms that achieve the same result are fine, even encouraged). [UNICODE]
</p>

			</section>
			<section id="utf-8-encoder">
<h4 title="UTF-8 encoder">8.1.2. ~UTF-8ç¬¦å·åŒ–å™¨</h4>

<p>
`UTF-8$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
UTF-8â€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚d$
â—
If code point is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
( %count, %~offset ) ~SET %~cp ãŒå±ã™ã‚‹ç¯„å›²ã«å¿œã˜ã¦
â‡’ï¼ƒ
{ `0080^U ã€œ `07FF^U } ãªã‚‰ã° ( 1, `C0^X ) ï¼
{ `0800^U ã€œ `FFFF^U } ãªã‚‰ã° ( 2, `E0^X ) ï¼
{ `10000^U ã€œ `10FFFF^U } ãªã‚‰ã° ( 3, `F0^X )
â—
Set count and offset based on the range code point is in:
â—
U+0080 to U+07FF, inclusive
â€¢ 1 and 0xC0
U+0800 to U+FFFF, inclusive
â€¢ 2 and 0xE0
U+10000 to U+10FFFF, inclusive
â€¢ 3 and 0xF0
</li>
	<li>
%~byteåˆ— ~LET ~byteåˆ— [ ( %~cp ~Rshift ( 6 ~MUL %count ) ) ~PLUS %~offset ]
â—
Let bytes be a byte sequence whose first byte is (code point &gt;&gt; (6 Ã— count)) + offset.
</li>
	<li>
<p>
~WHILE %count ~GT 0
ï¼š
â—
While count is greater than 0:
</p>
		<ol>
			<li>
%temp ~SET %~cp ~Rshift ( 6 ~MUL ( %count ~MINUS 1 ) )
â—
Set temp to code point &gt;&gt; (6 Ã— (count âˆ’ 1)).
</li>
	<li>
%~byteåˆ— ã«
( `80^X ~bOR ( %temp ~bAND `3F^X ) )
ã‚’ä»˜åŠ ã™ã‚‹
â—
Append to bytes 0x80 | (temp &amp; 0x3F).
</li>
	<li>
%count ~DECBY 1
â—
Decrease count by one.
</li>
		</ol>
	</li>
	<li>
~RET %~byteåˆ—
â—
Return bytes bytes, in order.
</li>
</ol>

<p class="note">
ã“ã®~algoã¯ã€~Unicodeæ¨™æº–ã«è¿°ã¹ã‚‰ã‚Œã‚‹ã‚‚ã®ã¨ä¸€è‡´ã™ã‚‹çµæœã‚’å¾—ã‚‹ãŒï¼Œå®Œå…¨ã•ã®ãŸã‚ã“ã“ã«å«ã‚ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
`UNICODE$r
â—
This algorithm has identical results to the one described in the Unicode standard. It is included here for completeness. [UNICODE]
</p>

			</section>
		</section>
	</section>
	<section id="legacy-single-byte-encodings">
<h2 title="Legacy single-byte encodings">9. æ—§æ¥ã®å˜byteç¬¦å·åŒ–æ³•</h2>

<p>
å„~byteãŒï¼»
ï¼‘å€‹ã®~cpã«å¯¾å¿œã™ã‚‹ã‹, ã¾ãŸã¯å¯¾å¿œã™ã‚‹~cpã¯ç„¡ã„
ï¼½ã‚ˆã†ãª`ç¬¦å·åŒ–æ³•$ã‚’
`å˜byteç¬¦å·åŒ–æ³•@
ã¨å‘¼ã¶ã€‚
ã™ã¹ã¦ã®`å˜byteç¬¦å·åŒ–æ³•$ãŒã€åŒã˜ï¼»
`å¾©å·å™¨$, `ç¬¦å·åŒ–å™¨$
ï¼½ã‚’å…±æœ‰ã™ã‚‹ã€‚
`å˜byteå¾©å·å™¨$ï¼`å˜byteç¬¦å·åŒ–å™¨$ã‹ã‚‰å‚ç…§ã•ã‚Œã‚‹
`å˜byteç´¢å¼•@
ã¯ã€åˆ©ç”¨ã•ã‚Œã‚‹`å˜byteç¬¦å·åŒ–æ³•$ã«ä¾å­˜ã—ï¼Œæ¬¡ã®ä¸€è¦§ã§å®šç¾©ã•ã‚Œã‚‹ã€‚
ï¼»
`ISO-8859-8^n, `ISO-8859-8-I^n
ï¼½ã‚’é™¤ãã™ã¹ã¦ã®`å˜byteç¬¦å·åŒ–æ³•$ã¯ã€ãã‚Œãã‚Œã«ä¸€æ„ãª`ç´¢å¼•$ã‚’æŒã¤ã€‚
â—
An encoding where each byte is either a single code point or nothing, is a single-byte encoding. Single-byte encodings share the decoder and encoder. Index single-byte, as referenced by the single-byte decoder and single-byte encoder, is defined by the following table, and depends on the single-byte encoding in use. All but two single-byte encodings have a unique index.
</p>

<p class="trans-note">ã€
è¢«è¦†åŸŸã®~tableã¯å·¨å¤§ãªã“ã¨ã«æ³¨æ„ã€‚
ã€‘</p>

<table>
<thead><tr><th>`åå‰$
<th>`ç´¢å¼•$
<th>è¦–è¦š-åŒ–
<th>åŸºæœ¬å¤šè¨€èªé¢ï¼ˆ BMP ï¼‰ã®è¢«è¦†åŸŸ
</thead>

<tbody>
<tr><td>`IBM866@n<td>`IBM866$idx
<tr><td>`ISO-8859-2@n<td>`ISO-8859-2$idx
<tr><td>`ISO-8859-3@n<td>`ISO-8859-3$idx
<tr><td>`ISO-8859-4@n<td>`ISO-8859-4$idx
<tr><td>`ISO-8859-5@n<td>`ISO-8859-5$idx
<tr><td>`ISO-8859-6@n<td>`ISO-8859-6$idx
<tr><td>`ISO-8859-7@n<td>`ISO-8859-7$idx
<tr><td>`ISO-8859-8@n<td>`ISO-8859-8$idx
<tr><td>`ISO-8859-8-I@n<td colspan="3">`ISO-8859-8$n ã¨åŒã˜
<tr><td>`ISO-8859-10@n<td>`ISO-8859-10$idx
<tr><td>`ISO-8859-13@n<td>`ISO-8859-13$idx
<tr><td>`ISO-8859-14@n<td>`ISO-8859-14$idx
<tr><td>`ISO-8859-15@n<td>`ISO-8859-15$idx
<tr><td>`ISO-8859-16@n<td>`ISO-8859-16$idx
<tr><td>`KOI8-R@n<td>`KOI8-R$idx
<tr><td>`KOI8-U@n<td>`KOI8-U$idx
<tr><td>`macintosh@n<td>`macintosh$idx
<tr><td>`windows-874@n<td>`windows-874$idx
<tr><td>`windows-1250@n<td>`windows-1250$idx
<tr><td>`windows-1251@n<td>`windows-1251$idx
<tr><td>`windows-1252@n<td>`windows-1252$idx
<tr><td>`windows-1253@n<td>`windows-1253$idx
<tr><td>`windows-1254@n<td>`windows-1254$idx
<tr><td>`windows-1255@n<td>`windows-1255$idx
<tr><td>`windows-1256@n<td>`windows-1256$idx
<tr><td>`windows-1257@n<td>`windows-1257$idx
<tr><td>`windows-1258@n<td>`windows-1258$idx
<tr><td>`x-mac-cyrillic@n<td>`x-mac-cyrillic$idx
</tbody>
</table>

<p class="note">æ³¨è¨˜ï¼š
~layoutæ–¹å‘ã«æ³¢åŠã™ã‚‹ã“ã¨ã‹ã‚‰ã€ `ISO-8859-8$n ã¨ `ISO-8859-8-I$n ã®`ç¬¦å·åŒ–æ³•$ã®`åå‰$ã¯ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ã€‚
æ­´å²çš„ã«ã€ã“ã®ã“ã¨ã¯ `ISO-8859-6$n ã¨ "ISO-8859-6-I" ã«ã¤ã„ã¦ã‚‚è©²å½“ã—ã¦ã„ãŸãŒã€ãã‚Œã¯ã‚‚ã¯ã‚„æˆç«‹ã—ãªã„ã€‚
ã€ï¼ https://www.w3.org/Bugs/Public/show_bug.cgi?id=19505 ã€‘
â—
ISO-8859-8 and ISO-8859-8-I are distinct encoding names, because ISO-8859-8 has influence on the layout direction. And although historically this might have been the case for ISO-8859-6 and "ISO-8859-6-I" as well, that is no longer true.
</p>

		<section id="single-byte-decoder">
<h3 title="single-byte decoder">9.1. å˜byteå¾©å·å™¨</h3>

<p>
`å˜byteç¬¦å·åŒ–æ³•$ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Single-byte encodingsâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚d$
â—
If byte is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
%~cp ~LET
`å˜byteç´¢å¼•$ ã®ä¸­ã§
( %~byte ~MINUS `80^X )
ãŒæŒ‡ã™`ç´¢å¼•~cp$
â—
Let code point be the index code point for byte âˆ’ 0x80 in index single-byte.
</li>
	<li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET `~error$
â—
If code point is null, return error.
</li>
	<li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
</ol>

		</section>
		<section id="single-byte-encoder">
<h3 title="single-byte encoder">9.2. å˜byteç¬¦å·åŒ–å™¨</h3>

<p>
`å˜byteç¬¦å·åŒ–æ³•$ ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Single-byte encodingsâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚d$
â—
If code point is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET
`å˜byteç´¢å¼•$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for code point in index single-byte.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
~RET ~byteåˆ— [ %~pointer ~PLUS `80^X ]
â—
Return a byte whose value is pointer + 0x80.
</li>
</ol>

		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(simplified)-encodings">
<h2 title="Legacy multi-byte Chinese (simplified) encodings">10. æ—§æ¥ã®è¤‡byte~Chineseï¼ˆç°¡ä½“å­—ï¼‰ ç¬¦å·åŒ–æ³•</h2>

		<section id="gbk">
<h3 title="GBK">10.1 ~GBK</h3>

			<section id="gbk-decoder">
<h4 title="GBK decoder">10.1.1 ~GBKå¾©å·å™¨</h4>

<p>
`GBK$n ã®`å¾©å·å™¨$ã¯ï¼Œ`gb18030$n ã®`å¾©å·å™¨$ã§ã‚ã‚‹ã€‚
â—
GBKâ€™s decoder is gb18030â€™s decoder.
</p>

			</section>
			<section id="gbk-encoder">
<h4 title="GBK encoder">10.1.2 ~GBKç¬¦å·åŒ–å™¨</h4>

<p>
`GBK$n ã®ç¬¦å·åŒ–å™¨ã¯ï¼Œï¼»
`~GBK~flag$ ~SET ~T
ï¼½ã«ã•ã‚ŒãŸ`gb18030$n ã®`ç¬¦å·åŒ–å™¨$ã§ã‚ã‚‹ã€‚
â—
GBKâ€™s encoder is gb18030â€™s encoder with its GBK flag set.
</p>

<p class="note">æ³¨è¨˜ï¼š
`GBK$n ã‚’`gb18030$nã«å¯¾ã™ã‚‹å…¨ãã®åˆ¥åã«ã—ãªã„ã®ã¯ã€
`GBK$n ã®`ç¬¦å·åŒ–å™¨$ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚ŒãŸå†…å®¹ã‚’ï¼Œæ—§æ¥ã®~serverã‚„ä»–ã®æ¶ˆè²»è€…ã‚’ãªã‚‹ã¹ãå£Šã™ã“ã¨ãªãï¼Œä¿å®ˆçš„ã«ç§»è¡Œã™ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
â—
Not fully aliasing GBK with gb18030 is a conservative move to decrease the chances of breaking legacy servers and other consumers of content generated with GBKâ€™s encoder.
</p>
			</section>
		</section>
		<section id="gb18030">
<h3 title="gb18030">10.2. ~gb18030</h3>

			<section id="gb18030-decoder">
<h4 title="gb18030 decoder">10.2.1. ~gb18030å¾©å·å™¨</h4>

<p>
å„ï¼»
`gb18030$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`~gb1@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰,
`~gb2@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰,
`~gb3@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰
â—
gb18030â€™s decoder has an associated gb18030 first, gb18030 second, and gb18030 third (all initially 0x00).
</p>

<p>
`gb18030$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
gb18030â€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
( `~gb1$, `~gb2$, `~gb3$ ) ~EQ ( `00^X, `00^X, `00^X )
ï¼½
â‡’
~RET `å®Œé‚d$
â—
If byte is end-of-stream and gb18030 first, gb18030 second, and gb18030 third are 0x00, return finished.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
â—
If byte is end-of-stream, and gb18030 first, gb18030 second, or gb18030 third is not 0x00, set gb18030 first, gb18030 second, and gb18030 third to 0x00, andï¼¼
</li>
			<li>
~RET `~error$
â—
return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~gb3$ ~NEQ `00^X
ï¼½ï¼š
â—
If gb18030 third is not 0x00, then:
</p>
		<ol>
			<li>
<p>
~IFï¼»
%~byte ~NIN { `30^X ã€œ `39^X }
ï¼½ï¼š
â—
If byte is not in the range 0x30 to 0x39, inclusive, then:
</p>
				<ol>
					<li>
%~stream ã«~byteåˆ— [ `~gb2$, `~gb3$, %~byte ] ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend gb18030 second, gb18030 third, and byte to stream.
</li>
					<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
â—
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
					<li>
~RET `~error$
â—
Return error.
</li>
				</ol>
			</li>
			<li>
%~cp ~LET æ¬¡ã«ä¸ãˆã‚‹~pointerãŒæŒ‡ã™`ç´¢å¼•~gb18030ç¯„å›²é›†~cp$
â‡’
(( `~gb1$ ~MINUS `81^X ) ~MUL ( 10 ~MUL 126 ~MUL 10 )) ~PLUS
(( `~gb2$ ~MINUS `30^X ) ~MUL ( 10 ~MUL 126 )) ~PLUS
(( `~gb3$ ~MINUS `81^X ) ~MUL 10 ) ~PLUS
( %~byte ~MINUS `30^X )
â—
Let code point be the index gb18030 ranges code point for ((gb18030 first âˆ’ 0x81) Ã— (10 Ã— 126 Ã— 10)) + ((gb18030 second âˆ’ 0x30) Ã— (10 Ã— 126)) + ((gb18030 third âˆ’ 0x81) Ã— 10) + byte âˆ’ 0x30.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
â—
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
			<li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET `~error$
â—
If code point is null, return error.
</li>
			<li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~gb2$ ~NEQ `00^X
ï¼½ï¼š
â—
If gb18030 second is not 0x00, then:
</p>
		<ol>
			<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~gb3$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$
â—
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 third to byte and return continue.
</li>
			<li>
%~stream ã«~byteåˆ— [ `~gb2$, %~byte ] ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend gb18030 second followed by byte to stream,ï¼¼
</li>
			<li>
( `~gb1$, `~gb2$ ) ~SET ( `00^X, `00^X )
â—
set gb18030 first and gb18030 second to 0x00, andï¼¼
</li>
			<li>
~RET `~error$
â—
return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~gb1$ ~NEQ `00^X
ï¼½ï¼š
â—
If gb18030 first is not 0x00, then:
</p>
		<ol>
			<li>
~IFï¼»
%~byte ~IN { `30^X ã€œ `39^X }
ï¼½
â‡’ï¼ƒ
`~gb2$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$
â—
If byte is in the range 0x30 to 0x39, inclusive, set gb18030 second to byte and return continue.
</li>
			<li>
%~lead ~LET `~gb1$
â—
Let lead be gb18030 first,ï¼¼
</li>
			<li>
%~pointer ~LET ~NULL
â—
let pointer be null, andï¼¼
</li>
			<li>
`~gb1$ ~SET `00^X
â—
set gb18030 first to 0x00.
</li>
			<li>
%~offset ~LET ï¼»
%~byte ~IN { `00^X ã€œ `7E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40 if byte is less than 0x7F and 0x41 otherwise.
</li>
			<li>
~IFï¼»
%~byte ~IN { `40^X ã€œ `7E^X, `80^X ã€œ `FE^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS %~offset )
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 190 + (byte âˆ’ offset).
</li>
			<li>
%~cp ~LET %~pointer ã«å¿œã˜ã¦
â‡’
~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ `ç´¢å¼•~gb18030$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
â—
Let code point be null if pointer is null and the index code point for pointer in index gb18030 otherwise.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp [ %~cp ]
â—
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
%~stream ã« %~byte ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~gb1$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$
â—
â†“</li>
	<li>
~RET %~byte ã«å¿œã˜ã¦
â‡’ï¼ƒ
`~ASCII~byte$ãªã‚‰ã° ~cp [ %~byte ] ï¼
`80^X ãªã‚‰ã° ~cp [ `20AC^U ] ï¼
 `FF^X  ãªã‚‰ã° `~error$
â—
If byte is an ASCII byte, return a code point whose value is byte.
â—
If byte is 0x80, return code point U+20AC.
â—
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 first to byte and return continue.
â—
Return error.
</li>
</ol>

			</section>
			<section id="gb18030-encoder">
<h4 title="gb18030 encoder">10.2.2. ~gb18030ç¬¦å·åŒ–å™¨</h4>

<p>
å„ï¼»
`gb18030$n ã®`ç¬¦å·åŒ–å™¨$
ï¼½ã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~GBK~flag@ï¼ˆåˆæœŸ~æ™‚ ~F ï¼‰
â—
gb18030â€™s encoder has an associated GBK flag (initially unset).
</p>

<p>
`gb18030$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
gb18030â€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚d$
â—
If code point is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
~IFï¼»
%~cp ~EQ `E5E5^U
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If code point is U+E5E5, return error with code point.
</p>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™-æ¸ˆã¿ã®å†…å®¹ã¨ã®äº’æ›æ€§ã‚’å¾—ã‚‹ãŸã‚ã€ `ç´¢å¼•~gb18030$ ã¯ï¼»
`A3^X `A0^X
ï¼½ã‚’ `E5E5^U ã§ã¯ãªã `3000^U ã«å¯¾å¿œä»˜ã‘ã¦ã„ã‚‹ã€‚
ã—ãŸãŒã£ã¦å¾€æ¥ã§ããªã„ã€‚
â—
Index gb18030 maps 0xA3 0xA0 to U+3000 rather than U+E5E5 for compatibility with deployed content. Therefore it cannot roundtrip.
</p>

</li>
	<li>
~IFï¼»
`~GBK~flag$ ~EQ ~T
ï¼½~ANDï¼»
%~cp ~EQ `20AC^U
ï¼½
â‡’
~RET ~byteåˆ— [ `80^X ]
â—
If the GBK flag is set and code point is U+20AC, return byte 0x80.
</li>
	<li>
%~pointer ~LET
`ç´¢å¼•~gb18030$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for code point in index gb18030.
</li>
	<li>
<p>
~IFï¼»
%~pointer ~NEQ ~NULL
ï¼½ï¼š
â—
If pointer is non-null, then:
</p>
		<ol>
			<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
â—
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET %~pointer ~MOD 190
â—
Let trail be pointer % 190.
</li>
			<li>
%~offset ~LET ï¼»
%~trail  ~IN { `00^X ã€œ `3E^X } ãªã‚‰ã° `40^Xã€ï¼0x7F-0x40 ã€‘ ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.
</li>
			<li>
~RET ~byteåˆ— [ %~lead, ( %~trail ~PLUS %~offset ) ]
â—
Return two bytes whose values are lead and trail + offset.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
`~GBK~flag$ ~EQ ~T
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If GBK flag is set, return error with code point.
</li>
	<li>
%~pointer ~SET
%~cp
ã‚’æŒ‡ã™`ç´¢å¼•~gb18030ç¯„å›²é›†~pointer$
â—
Set pointer to the index gb18030 ranges pointer for code point.
</li>
	<li>
%byte1 ~LET %~pointer ~DIV ( 10 ~MUL 126 ~MUL 10 )
â—
Let byte1 be pointer / (10 Ã— 126 Ã— 10).
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 ~MUL 10 )
â—
Set pointer to pointer % (10 Ã— 126 Ã— 10).
</li>
	<li>
%byte2 ~LET %~pointer ~DIV ( 10 ~MUL 126 )
â—
Let byte2 be pointer / (10 Ã— 126).
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 )
â—
Set pointer to pointer % (10 Ã— 126).
</li>
	<li>
%byte3 ~LET %~pointer ~DIV 10
â—
Let byte3 be pointer / 10.
</li>
	<li>
%byte4 ~LET %~pointer ~MOD 10
â—
Let byte4 be pointer % 10.
</li>
	<li>
~RET ~byteåˆ— [
( %byte1 ~PLUS `81^X ),
( %byte2 ~PLUS `30^X ),
( %byte3 ~PLUS `81^X ),
( %byte4 ~PLUS `30^X )
]
â—
Return four bytes whose values are byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(traditional)-encodings">
<h2 title="Legacy multi-byte Chinese (traditional) encodings">11. æ—§æ¥ã®è¤‡byte~Chineseï¼ˆç¹ä½“å­—ï¼‰ç¬¦å·åŒ–æ³•</h2>

ã€ï¼ Lead:  0x81 to 0xFE ï¼ Trail: 0x40 to 0x7E or 0xA1 to 0xFE ã€‘

		<section id="big5">
<h3 title="Big5">11.1. ~Big5</h3>

			<section id="big5-decoder">
<h4 title="Big5 decoder">11.1.1. ~Big5å¾©å·å™¨</h4>

<p>
å„ï¼»
`Big5$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~Big5~lead@ï¼ˆåˆæœŸ~æ™‚ `00^X ï¼‰
â—
Big5â€™s decoder has an associated Big5 lead (initially 0x00).
</p>

<p>
`Big5$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Big5â€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
</p>
		<ol>
			<li>
~IFï¼»
`~Big5~lead$ ~NEQ `00^X
ï¼½
â‡’ï¼ƒ
`~Big5~lead$ ~SET `00^X ï¼›
~RET `~error$
</li>
			<li>
~RET `å®Œé‚d$
</li>
		</ol>
â—
If byte is end-of-stream and Big5 lead is not 0x00, set Big5 lead to 0x00 and return error.
â—
If byte is end-of-stream and Big5 lead is 0x00, return finished.
</li>
	<li>
<p>
~IFï¼»
`~Big5~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If Big5 lead is not 0x00,ï¼¼
</p>
		<ol>
			<li>
%~lead ~LET `~Big5~lead$
â—
 let lead be Big5 lead,ï¼¼
</li>
			<li>
%~pointer ~LET ~NULL
â—
let pointer be null,ï¼¼
</li>
			<li>
`~Big5~lead$ ~SET `00^X
â—
set Big5 lead to 0x00, and then:
</li>
			<li>
%~offset ~LET ï¼»
%~byte ~IN { `00^X ã€œ `7E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `62^X ã€ï¼ 0x62 = 0xA1-0x7E+1+0x40 ã€‘
ï¼½
â—
Let offset be 0x40 if byte is less than 0x7F and 0x62 otherwise.
</li>
			<li>
~IFï¼»
%~byte ~IN { `40^X ã€œ `7E^X, `A1^X ã€œ `FE^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 157 ~PLUS ( %~byte ~MINUS %~offset )
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 157 + (byte âˆ’ offset).
</li>
			<li>
<p>
~IFï¼»
ä¸‹ã®è¡¨ã®ä¸­ã§ï¼Œ 1 åˆ—ç›®ãŒ %~pointer ã«ç­‰ã—ã„è¡ŒãŒã‚ã‚‹
ï¼½
â‡’
~RET åŒã˜è¡Œã® 2 åˆ—ç›®ã® `2 å€‹ã®^em ~cpã‹ã‚‰ãªã‚‹`~token$åˆ—
â—
If there is a row in the table below whose first column is pointer, return the two code points listed in its second column (the third column is irrelevant):
</p>

ã€ï¼ https://www.unicode.org/Public/UNIDATA/NamedSequences.txt ã€‘
<table><thead><tr><th>~pointerâ— Pointer
<th>~cpâ— Code points
<th>~~èª¬æ˜ï¼ˆã“ã®æ®µã«ã¯é–¢é€£ã—ãªã„ï¼‰â— Notes
</thead>

<tbody id="_big5-lead"><tr><td>1133ã€ï¼ 0x88 0x62 ã€‘
<td>`00CA^U `0304^U
<td>ÃŠÌ„ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON)

<tr><td>1135ã€ï¼ 0x88 0x64 ã€‘
<td>`00CA^U `030C^U
<td>ÃŠÌŒ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON)

<tr><td>1164ã€ï¼ 0x88 0xA3 ã€‘
<td>`00EA^U `0304^U
<td>ÃªÌ„ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON)

<tr><td>1166ã€ï¼ 0x88 0xA5 ã€‘
<td>`00EA^U `030C^U
<td>ÃªÌŒ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON)

</tbody></table>

ã€ï¼ we do this to avoid PUA ã€‘

<p class="note">æ³¨è¨˜ï¼š
`ç´¢å¼•$ ã¯å˜ç‹¬ã®~cpã«åˆ¶é™ã•ã‚Œã‚‹ã®ã§ã€ã“ã‚Œã‚‰ã®~pointerã«ã¯ã“ã®è¡¨ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
Since indexes are limited to single code points this table is used for these pointers.
</p>
			</li>
			<li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ `ç´¢å¼•~Big5$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
ï¼½
â—
Let code point be null if pointer is null and the index code point for pointer in index Big5 otherwise.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp [ %~cp ]
â—
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
%~stream ã« %~byte ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~Big5~lead$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$
â—
If byte is in the range 0x81 to 0xFE, inclusive, set Big5 lead to byte and return continue.
</li>
	<li>
~RET `~error$
â—
Return error.
</li>
</ol>

			</section>
			<section id="big5-encoder">
<h4 title="Big5 encoder">11.1.2. ~Big5ç¬¦å·åŒ–å™¨</h4>

<p>
`Big5$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Big5â€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚d$
â—
If code point is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET %~cp ã‚’æŒ‡ã™`ç´¢å¼•~Big5~pointer$
â—
Let pointer be the index Big5 pointer for code point.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 157 ) ~PLUS `81^X
â—
Let lead be pointer / 157 + 0x81.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 157
â—
Let trail be pointer % 157.
</li>
	<li>
%~offset ~LET ï¼»
%~trail ~IN { `00^X ã€œ `3E^X } ãªã‚‰ã° `40^Xã€ï¼0x7F-0x40 ã€‘ ï¼
~ELSE_ `62^Xã€ï¼0xA1-0x3F ã€‘
ï¼½
â—
Let offset be 0x40 if trail is less than 0x3F and 0x62 otherwise.
</li>
	<li>
~RET ~byteåˆ— [ %~lead, ( %~trail ~PLUS %~offset) ]
â—
Return two bytes whose values are lead and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-japanese-encodings">
<h2 title="Legacy multi-byte Japanese encodings">12. æ—§æ¥ã®è¤‡byte~Japaneseç¬¦å·åŒ–æ³•</h2>

		<section id="euc-jp">
<h3 title="EUC-JP">12.1. ~EUC-JP</h3>

ã€ï¼ https://www.iana.org/assignments/charset-reg/CP51932 ã€‘

			<section id="euc-jp-decoder">
<h4 title="EUC-JP decoder">12.1.1. ~EUC-JPå¾©å·å™¨</h4>

<p>
å„ï¼»
`EUC-JP$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`~EUC-JP~jis0212~flag@ï¼ˆåˆæœŸ~æ™‚ ~F ï¼‰ï¼›
`~EUC-JP~lead@ï¼ˆåˆæœŸ~æ™‚ `00^X ï¼‰
â—
EUC-JPâ€™s decoder has an associated EUC-JP jis0212 flag (initially unset) and EUC-JP lead (initially 0x00).
</p>

<p>
`EUC-JP$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-JPâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
`~EUC-JP~lead$ ~NEQ `00^X
ï¼½
â‡’ï¼ƒ
`~EUC-JP~lead$ ~SET `00^X ï¼›
~RET `~error$
â—
If byte is end-of-stream and EUC-JP lead is not 0x00, set EUC-JP lead to 0x00, and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚d$
â—
If byte is end-of-stream and EUC-JP lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
`~EUC-JP~lead$ ~EQ `8E^X
ï¼½~ANDï¼»
%~byte ~IN { `A1^X ã€œ `DF^X }
ï¼½
ã€ï¼ katakana; subtraction is done first to avoid upsetting compilers ã€‘
â‡’ï¼ƒ
`~EUC-JP~lead$ ~SET `00^X ï¼›
~RET ~cp [ `FF61^X ~MINUS `A1^X ~PLUS %~byte ]
â—
If EUC-JP lead is 0x8E and byte is in the range 0xA1 to 0xDF, inclusive, set EUC-JP lead to 0x00 and return a code point whose value is 0xFF61 âˆ’ 0xA1 + byte.
</li>
	<li>
~IFï¼»
`~EUC-JP~lead$ ~EQ `8F^X
ï¼½~ANDï¼»
%~byte ~IN { `A1^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~EUC-JP~jis0212~flag$ ~SET ~T ï¼›
`~EUC-JP~lead$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$
â—
If EUC-JP lead is 0x8F and byte is in the range 0xA1 to 0xFE, inclusive, set the EUC-JP jis0212 flag, set EUC-JP lead to byte, and return continue.
</li>
	<li>
<p>
~IFï¼»
`~EUC-JP~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If EUC-JP lead is not 0x00,ï¼¼
</p>
		<ol>
			<li>
%~lead ~LET `~EUC-JP~lead$
â—
let lead be EUC-JP lead,ï¼¼
</li>
			<li>
`~EUC-JP~lead$ ~SET `00^X
â—
set EUC-JP lead to 0x00, and then:
</li>
			<li>
%~cp ~LET ~NULL
â—
Let code point be null.
</li>
			<li>
<p>
~IFï¼»
%~lead ~IN { `A1^X ã€œ `FE^X }
ï¼½~ANDï¼»
%~byte ~IN { `A1^X ã€œ `FE^X }
ï¼½ï¼š
</p>
				<ol>
					<li>
%ç´¢å¼• ~LET `~EUC-JP~jis0212~flag$ã«å¿œã˜ã¦
â‡’ï¼ƒ
~F ãªã‚‰ã°`ç´¢å¼•~jis0208$ ï¼
~T ãªã‚‰ã° `ç´¢å¼•~jis0212$
</li>
					<li>
%~cp ~SET %ç´¢å¼• ã®ä¸­ã§
( ( %~lead ~MINUS `A1^X ) ~MUL 94 ~PLUS %~byte ~MINUS `A1^X )
ãŒæŒ‡ã™`ç´¢å¼•~cp$
</li>
				</ol>
â—
If lead and byte are both in the range 0xA1 to 0xFE, inclusive, set code point to the index code point for (lead âˆ’ 0xA1) Ã— 94 + byte âˆ’ 0xA1 in index jis0208 if the EUC-JP jis0212 flag is unset and in index jis0212 otherwise.
</li>
			<li>
`~EUC-JP~jis0212~flag$ ~SET ~F
â—
Unset the EUC-JP jis0212 flag.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp [ %~cp ]
â—
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
%~stream ã« %~byte ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `8E^X, `8F^X, `A1^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~EUC-JP~lead$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$
â—
If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE, inclusive, set EUC-JP lead to byte and return continue.
</li>
	<li>
~RET `~error$
â—
Return error.
</li>
</ol>

			</section>
			<section id="euc-jp-encoder">
<h4 title="EUC-JP encoder">12.1.2. ~EUC-JPç¬¦å·åŒ–å™¨</h4>

<p>
`EUC-JP$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-JPâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>
<ol>
	<li>
%çµæœ ~LET %~cp ã«å¿œã˜ã¦
â‡’ï¼ƒ
`~EoS$ ãªã‚‰ã° `å®Œé‚d$ ï¼
`~ASCII~cp$ãªã‚‰ã° ~byteåˆ— [ %~cp ] ï¼
`00A5^U ãªã‚‰ã° ~byteåˆ— [ `5C^X ] ï¼
`203E^U ãªã‚‰ã° ~byteåˆ— [ `7E^X ] ï¼
`FF61^U ã€œ `FF9F^U ãªã‚‰ã° ~byteåˆ— [ `8E^X, ( %~cp ~MINUS `FF61^X ~PLUS `A1^X ) ] ï¼
~ELSE_ ~NULL
â—
If code point is end-of-stream, return finished.
â—
If code point is an ASCII code point, return a byte whose value is code point.
â—
If code point is U+00A5, return byte 0x5C.
â—
If code point is U+203E, return byte 0x7E.
â—
If code point is in the range U+FF61 to U+FF9F, inclusive, return two bytes whose values are 0x8E and code point âˆ’ 0xFF61 + 0xA1.
</li>
	<li>
~IFï¼»
%çµæœ ~NEQ ~NULL
ï¼½
â‡’
~RET %çµæœ
â—
â†‘</li>
	<li>
~IFï¼»
%~cp ~EQ `2212^U
ï¼½
â‡’
%~cp ~SET `FF0D^U
â—
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
<p>
%~pointer ~LET `ç´¢å¼•~jis0208$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for code point in index jis0208.
</p>

<p class="note">æ³¨è¨˜ï¼š
%~pointer ã¯ã€ ~NULL ã§ãªã‘ã‚Œã°ï¼Œ`ç´¢å¼•~jis0208$ã¨~pointeræ¼”ç®—ã®è³‡è³ªã«å› ã‚Š 8836 æœªæº€ã«ãªã‚‹ã€‚
â—
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `A1^X
â—
Let lead be pointer / 94 + 0xA1.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `A1^X
â—
Let trail be pointer % 94 + 0xA1.
</li>
	<li>
~RET ~byteåˆ— [ %~lead, %~trail ]
â—
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="iso-2022-jp">
<h3 title="ISO-2022-JP">12.2. ~ISO-2022-JP</h3>

ã€ï¼ https://tools.ietf.org/html/rfc1468ã€‘
ã€ï¼ https://tools.ietf.org/html/rfc2237 (iso-2022-jp-1; not used)ã€‘
ã€ï¼ "ESC ) I" is from iso-2022-jp-3 reportedlyã€‘

			<section id="iso-2022-jp-decoder">
<h4 title="ISO-2022-JP decoder">12.2.1. ~ISO-2022-JPå¾©å·å™¨</h4>

<p>
å„ï¼»
`ISO-2022-JP$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹@ï¼ˆåˆæœŸ~æ™‚ `ASCII$iï¼‰,
`~ISO-2022-JPå¾©å·å™¨~å‡ºåŠ›~çŠ¶æ…‹@ï¼ˆåˆæœŸ~æ™‚ `ASCII$i ï¼‰,
`~ISO-2022-JP~lead@ï¼ˆåˆæœŸ~æ™‚ `00^X ï¼‰,
`~ISO-2022-JPå‡ºåŠ›~flag@ï¼ˆåˆæœŸ~æ™‚ ~F ï¼‰
â—
ISO-2022-JPâ€™s decoder has an associated ISO-2022-JP decoder state (initially ASCII), ISO-2022-JP decoder output state (initially ASCII), ISO-2022-JP lead (initially 0x00), and ISO-2022-JP output flag (initially unset).
</p>

<p>
`ISO-2022-JP$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œ`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ã«å¿œã˜ã¦ æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
ISO-2022-JPâ€™s decoderâ€™s handler, given a stream and byte, runs these steps, switching on ISO-2022-JP decoder state:
</p>

<dl class="switch">
	<dt>`ASCII@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ï¼›
~RET `ç¶™ç¶š-$
â—
0x1B
â€¢ Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`0E^X, `0F^X, `1B^X ä»¥å¤–ã®`~ASCII~byte$
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F ï¼›
~RET ~cp [ %~byte ]
â—
0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B
â€¢ Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</li>
			<li>
`~EoS$
â‡’ï¼ƒ
~RET `å®Œé‚d$
â—
end-of-stream
â€¢ Return finished.
</li>
			<li>
ãã®ä»–
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F ï¼›
~RET `~error$
â—
Otherwise
â€¢ Unset the ISO-2022-JP output flag and return error.
</li>
		</ol>
	</dd>

	<dt>`Roman@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ï¼›
~RET `ç¶™ç¶š-$
â—
0x1B
â€¢ Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`5C^X
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F ï¼›
~RET ~cp [ `00A5^U ]
â—
0x5C
â€¢ Unset the ISO-2022-JP output flag and return code point U+00A5.
</li>
			<li>
`7E^X
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F ï¼›
~RET ~cp [ `203E^U ]
â—
0x7E
â€¢ Unset the ISO-2022-JP output flag and return code point U+203E.
</li>
			<li>
`0E^X, `0F^X, `1B^X, `5C^X, `7E^X
ä»¥å¤–ã®`~ASCII~byte$
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F ï¼›
~RET ~cp [ %~byte ]
â—
0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E
â€¢ Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</li>
			<li>
`~EoS$
â‡’ï¼ƒ
~RET `å®Œé‚d$
â—
end-of-stream
â€¢ Return finished.
</li>
			<li>
ãã®ä»–
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F ï¼›
~RET `~error$
â—
Otherwise
â€¢ Unset the ISO-2022-JP output flag and return error.
</li>
		</ol>
	</dd>

	<dt>`katakana@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ï¼›
~RET `ç¶™ç¶š-$
â—
0x1B
â€¢ Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`21^X ã€œ `5F^X
ã€ï¼ katakana; subtraction is done first to avoid upsetting compilers ã€‘
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F ï¼›
~RET ~cp [ `FF61^X ~MINUS `21^X ~PLUS %~byte ]
â—
0x21 to 0x5F
â€¢ Unset the ISO-2022-JP output flag and return a code point whose value is 0xFF61 âˆ’ 0x21 + byte.
</li>
			<li>
`~EoS$
â‡’ï¼ƒ
~RET `å®Œé‚d$
â—
end-of-stream
â€¢ Return finished.
</li>
			<li>
ãã®ä»–
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F ï¼›
~RET `~error$
â—
Otherwise
â€¢ Unset the ISO-2022-JP output flag and return error.
</li>
		</ol>
	</dd>

	<dt>`~lead~byte@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ï¼›
~RET `ç¶™ç¶š-$
â—
0x1B
â€¢ Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`21^X ã€œ `7E^X
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F ï¼›
`~ISO-2022-JP~lead$ ~SET %~byte ï¼›
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~trail~byte$i ï¼›
~RET `ç¶™ç¶š-$
â—
0x21 to 0x7E
â€¢ Unset the ISO-2022-JP output flag, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to trail byte, and return continue.
</li>
			<li>
`~EoS$
â‡’ï¼ƒ
~RET `å®Œé‚d$
â—
end-of-stream
â€¢ Return finished.
</li>
			<li>
ãã®ä»–
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F ï¼›
~RET `~error$
â—
Otherwise
â€¢ Unset the ISO-2022-JP output flag and return error.
</li>
		</ol>
	</dd>

	<dt>`~trail~byte@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
ã€ï¼ iso-2022-jp decoder output state is still lead byte ã€‘
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ï¼›
~RET `~error$
â—
0x1B
â€¢ Set ISO-2022-JP decoder state to escape start and return error.
</li>
			<li>
<p>
`21^X ã€œ `7E^X
ï¼š
â—
0x21 to 0x7E
</p>
				<ol>
					<li>
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~lead~byte$i
â—
Set the ISO-2022-JP decoder state to lead byte.
</li>
					<li>
%pointer ~LET ( `~ISO-2022-JP~lead$ ~MINUS `21^X ) ~MUL 94 ~PLUS %~byte ~MINUS `21^X
â—
Let pointer be (ISO-2022-JP lead âˆ’ 0x21) Ã— 94 + byte âˆ’ 0x21.
</li>
					<li>
%~cp ~LET
`ç´¢å¼•~jis0208$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
â—
Let code point be the index code point for pointer in index jis0208.
</li>
					<li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET `~error$
â—
If code point is null, return error.
</li>
					<li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
				</ol>
			</li>
			<li>
`~EoS$
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~lead~byte$i ï¼›
%~stream ã« %~byte ã‚’`å‰ä»˜åŠ ã™ã‚‹$ ï¼›
~RET `~error$
â—
end-of-stream
â€¢ Set the ISO-2022-JP decoder state to lead byte, prepend byte to stream, and return error.
</li>
			<li>
ãã®ä»–
ã€ï¼ iso-2022-jp decoder output state is still lead byte ã€‘
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~lead~byte$i ï¼›
~RET `~error$
â—
Otherwise
â€¢ Set ISO-2022-JP decoder state to lead byte and return error.
</li>
		</ol>
	</dd>

	<dt>`~escapeé–‹å§‹@i</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
%~byte ~IN { `24^Xã€ï¼ $ ã€‘, `28^Xã€ï¼ ( ã€‘ }
ï¼½
â‡’ï¼ƒ
`~ISO-2022-JP~lead$ ~SET %~byte ï¼›
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escape$i ï¼›
~RET `ç¶™ç¶š-$
â—
If byte is either 0x24 or 0x28, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to escape, and return continue.
</li>
			<li>
%~stream ã« %~byte ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend byte to stream.
</li>
			<li>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F
â—
Unset the ISO-2022-JP output flag,ï¼¼
</li>
			<li>
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~ISO-2022-JPå¾©å·å™¨~å‡ºåŠ›~çŠ¶æ…‹$
â—
set ISO-2022-JP decoder state to ISO-2022-JP decoder output state, andï¼¼
</li>
			<li>
~RET `~error$
â—
return error.
</li>
		</ol>
	</dd>

	<dt>`~escape@i</dt>
	<dd>
		<ol>
			<li>
%~lead ~LET `~ISO-2022-JP~lead$
â—
Let lead be ISO-2022-JP lead andï¼¼
</li>
			<li>
`~ISO-2022-JP~lead$ ~SET `00^X
â—
set ISO-2022-JP lead to 0x00.
</li>
			<li>
%çŠ¶æ…‹ ~LET
( %~lead, %~byte )
ã«å¿œã˜ã¦
â‡’ï¼ƒ
( `28^X, `42^Xã€ï¼B ã€‘ ) ãªã‚‰ã° `ASCII$i ï¼
( `28^X, `4A^Xã€ï¼J ã€‘ ) ãªã‚‰ã° `Roman$i1 ï¼
( `28^X, `49^Xã€ï¼I ã€‘ ) ãªã‚‰ã° `katakana$i ï¼
( `24^X, `40^Xã€ï¼@ ã€‘ ) ãªã‚‰ã° `~lead~byte$i ï¼
( `24^X, `42^Xã€ï¼B ã€‘ ) ãªã‚‰ã° `~lead~byte$i ï¼
~ELSE_ ~NULL
â—
Let state be null.
â—
If lead is 0x28 and byte is 0x42, set state to ASCII.
â—
If lead is 0x28 and byte is 0x4A, set state to Roman.
â—
If lead is 0x28 and byte is 0x49, set state to katakana.
â—
If lead is 0x24 and byte is either 0x40 or 0x42, set state to lead byte.
</li>
			<li>
<p>
~IFï¼»
%çŠ¶æ…‹ ~NEQ ~NULL
ï¼½ï¼š
â—
If state is non-null, then:
</p>
				<ol>
					<li>
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET %çŠ¶æ…‹
â—
â†“</li>
					<li>
`~ISO-2022-JPå¾©å·å™¨~å‡ºåŠ›~çŠ¶æ…‹$ ~SET %çŠ¶æ…‹
â—
Set ISO-2022-JP decoder state and ISO-2022-JP decoder output state to state.
</li>
					<li>
%å‡ºåŠ›~flag ~LET `~ISO-2022-JPå‡ºåŠ›~flag$
â—
Let output flag be the ISO-2022-JP output flag.
</li>
					<li>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~T
â—
Set the ISO-2022-JP output flag.
</li>
					<li>
~RET ï¼»
%å‡ºåŠ›~flag ~EQ ~F ãªã‚‰ã° `ç¶™ç¶š-$ ï¼
~ELSE_ `~error$
ï¼½
â—
Return continue, if output flag is unset, and error otherwise.
</li>
				</ol>
			</li>
			<li>
%~stream ã«~byteåˆ— [ %~lead, %~byte ] ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend lead and byte to stream.
</li>
			<li>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~F
â—
Unset the ISO-2022-JP output flag,ï¼¼
</li>
					<li>
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~ISO-2022-JPå¾©å·å™¨~å‡ºåŠ›~çŠ¶æ…‹$
â—
set ISO-2022-JP decoder state to ISO-2022-JP decoder output state andï¼¼
</li>
					<li>
~RET `~error$
â—
return error.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="iso-2022-jp-encoder">
<h4 title="ISO-2022-JP encoder">12.2.2. ~ISO-2022-JPç¬¦å·åŒ–å™¨</h4>

<div class="note">

<p>æ³¨è¨˜ï¼š
`~ISO-2022-JPç¬¦å·åŒ–å™¨$ã¯ã€ï¼»
è¤‡æ•°ã®å‡ºåŠ›ã‚’é€£çµã—ãŸçµæœã‚’å¯¾å¿œã™ã‚‹`å¾©å·å™¨$ã«ã‹ã‘ãŸã¨ãï¼Œ`~error$ã«ãªã‚Šå¾—ã‚‹
ï¼½ã‚ˆã†ãªï¼Œå”¯ä¸€ã®`ç¬¦å·åŒ–å™¨$ã§ã‚ã‚‹ã€‚
â—
The ISO-2022-JP encoder is the only encoder for which the concatenation of multiple outputs can result in an error when run through the corresponding decoder.
</p>

<p class="example">
`00A5^U ã‚’ç¬¦å·åŒ–ã—ãŸçµæœã¯
[ `1B^X `28^X `4A^X `5C^X `1B^X `28^X `42^X ]
ã‚’ä¸ãˆã‚‹ã€‚
ãã‚Œã‚’ 2 å›~è¡Œã£ãŸçµæœã‚’é€£çµã—ã¦ã‹ã‚‰å¾©å·ã—ãŸçµæœã¯ã€
[ `00A5^U `FFFD^U `00A5^U ]
ã«ãªã‚‹ã€‚
â—
Encoding U+00A5 gives 0x1B 0x28 0x4A 0x5C 0x1B 0x28 0x42. Doing that twice, concatenating the results, and then decoding yields U+00A5 U+FFFD U+00A5.
</p>

</div>

<p>
å„ï¼»
`ISO-2022-JP$n ã®`ç¬¦å·åŒ–å™¨$
ï¼½ã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹@
â€” æ¬¡ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚Šå¾—ã‚‹ï¼ˆåˆæœŸ~æ™‚ `ASCII$i1 ï¼‰
â‡’
`ASCII@i1 ï¼
`Roman@i1 ï¼
`jis0208@i1
â—
ISO-2022-JPâ€™s encoder has an associated ISO-2022-JP encoder state which is ASCII, Roman, or jis0208 (initially ASCII).
</p>

<p>
`ISO-2022-JP$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
ISO-2022-JPâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~NEQ `ASCII$i1
ï¼½
â‡’ï¼ƒ
%~stream ã« %~cp ã‚’`å‰ä»˜åŠ ã™ã‚‹$ ï¼›
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~SET `ASCII$i1 ï¼›
~RET ~byteåˆ— [ `1B^X, `28^X, `42^X ]
â—
If code point is end-of-stream and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
			<li>
~RET `å®Œé‚d$
â—
If code point is end-of-stream and ISO-2022-JP encoder state is ASCII, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~IN
{ `ASCII$i1, `Roman$i1 }
ï¼½~ANDï¼»
%~cp ~IN { `000E^U, `000F^U, `001B^U }
ï¼½
â‡’
~RET `FFFD^U ã‚’ä¼´ã†`~error$
â—
If ISO-2022-JP encoder state is ASCII or Roman, and code point is U+000E, U+000F, or U+001B, return error with U+FFFD.
</p>

<p class="note">
æ”»æ’ƒã‚’é˜²ããŸã‚ã€ã“ã‚Œã¯ %~cp ã§ã¯ãªãï¼Œ `FFFD^U ã‚’è¿”ã™ã€‚
â—
This returns U+FFFD rather than code point to prevent attacks.
</p>
ã€ï¼ https://github.com/whatwg/encoding/issues/15 ã€‘
	</li>
	<li>
~IFï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~EQ `ASCII$i1
ï¼½~ANDï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If ISO-2022-JP encoder state is ASCII and code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
~IFï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~EQ `Roman$i1
ï¼½ï¼š
</p>
		<ol>
			<li>
%çµæœ ~LET %~cp ã«å¿œã˜ã¦
â‡’ï¼ƒ
`005C^U, `007E^U ä»¥å¤–ã®`~ASCII~cp$ãªã‚‰ã° ~byteåˆ— [ %~cp ] ï¼
`00A5^U ãªã‚‰ã° ~byteåˆ— [ `5C^X ] ï¼
`203E^U ãªã‚‰ã° ~byteåˆ— [ `7E^X ] ï¼
~ELSE_ ~NULL
</li>
			<li>
~IFï¼»
%çµæœ ~NEQ ~NULL
ï¼½
â‡’
~RET %çµæœ
â—
â†‘</li>
		</ol>
â—
If ISO-2022-JP encoder state is Roman and code point is an ASCII code point, excluding U+005C and U+007E, or is U+00A5 or U+203E, then:
â€¢ If code point is an ASCII code point, return a byte whose value is code point.
â€¢ If code point is U+00A5, return byte 0x5C.
â€¢ If code point is U+203E, return byte 0x7E.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½~ANDï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~NEQ `ASCII$i1
ï¼½
â‡’ï¼ƒ
%~stream ã« %~cp ã‚’`å‰ä»˜åŠ ã™ã‚‹$ ï¼›
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~SET `ASCII$i1 ï¼›
~RET ~byteåˆ— [ `1B^X, `28^X, `42^X ]
â—
If code point is an ASCII code point, and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
	<li>
~IFï¼»
%~cp ~NIN { `00A5^U, `203E^U }
ï¼½~ANDï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~NEQ `Roman$i1
ï¼½
â‡’ï¼ƒ
%~stream ã« %~cp ã‚’`å‰ä»˜åŠ ã™ã‚‹$ ï¼›
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~SET `Roman$i1 ï¼›
~RET ~byteåˆ— [ `1B^X, `28^X, `4A^X ]
â—
If code point is either U+00A5 or U+203E, and ISO-2022-JP encoder state is not Roman, prepend code point to stream, set ISO-2022-JP encoder state to Roman, and return three bytes 0x1B 0x28 0x4A.
</li>
	<li>
~IFï¼»
%~cp ~EQ `2212^U
ï¼½
â‡’
%~cp ~SET `FF0D^U
â—
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
~IFï¼»
%~cp ~IN { `FF61^U ã€œ `FF9F^U }
ï¼½
â‡’
%~cp ~SET `ç´¢å¼•~ISO-2022-JP~katakana$ã®ä¸­ã§
( %~cp ~MINUS `FF61^X )
ãŒæŒ‡ã™`ç´¢å¼•~cp$
â—
If code point is in the range U+FF61 to U+FF9F, inclusive, set it to the index code point for code point âˆ’ 0xFF61 in index ISO-2022-JP katakana.
</li>
	<li>
<p>
%~pointer ~LET `ç´¢å¼•~jis0208$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for code point in index jis0208.
</p>

<p class="note">æ³¨è¨˜ï¼š
%~pointer ã¯ã€ ~NULL ã§ãªã‘ã‚Œã°ï¼Œ`ç´¢å¼•~jis0208$ã¨~pointeræ¼”ç®—ã®è³‡è³ªã«å› ã‚Š 8836 æœªæº€ã«ãªã‚‹ã€‚
â—
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
~IFï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~NEQ `jis0208$i1
ï¼½
â‡’ï¼ƒ
%~stream ã« %~cp ã‚’`å‰ä»˜åŠ ã™ã‚‹$ ï¼›
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~SET `jis0208$i1 ï¼›
~RET ~byteåˆ— [ `1B^X, `24^X, `42^X ]
â—
If ISO-2022-JP encoder state is not jis0208, prepend code point to stream, set ISO-2022-JP encoder state to jis0208, and return three bytes 0x1B 0x24 0x42.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `21^X
â—
Let lead be pointer / 94 + 0x21.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `21^X
â—
Let trail be pointer % 94 + 0x21.
</li>
	<li>
~RET ~byteåˆ— [ %~lead, %~trail ]
â—
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="shift_jis">
<h3 title="Shift_JIS">12.3. ~Shift_JIS</h3>

			<section id="shift_jis-decoder">
<h4 title="Shift_JIS decoder">12.3.1. ~Shift_JISå¾©å·å™¨</h4>

<p>
å„ï¼»
`Shift_JIS$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~Shift_JIS~lead@ï¼ˆåˆæœŸ~æ™‚ `00^X ï¼‰
â—
Shift_JISâ€™s decoder has an associated Shift_JIS lead (initially 0x00).
</p>

<p>
`Shift_JIS$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Shift_JISâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
`~Shift_JIS~lead$ ~NEQ `00^X
ï¼½
â‡’ï¼ƒ
`~Shift_JIS~lead$ ~SET `00^X ï¼›
~RET `~error$
â—
If byte is end-of-stream and Shift_JIS lead is not 0x00, set Shift_JIS lead to 0x00 and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚d$
â—
If byte is end-of-stream and Shift_JIS lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~Shift_JIS~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If Shift_JIS lead is not 0x00,ï¼¼
</p>
		<ol>
			<li>
%~lead ~LET `~Shift_JIS~lead$
â—
let lead be Shift_JIS lead,ï¼¼
</li>
			<li>
%~pointer ~LET ~NULL
â—
let pointer be null,ï¼¼
</li>
			<li>
`~Shift_JIS~lead$ ~SET `00^X
â—
set Shift_JIS lead to 0x00, and then:
</li>
			<li>
%~offset ~LET ï¼»
%~byte ~IN { `00^X ã€œ `7E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40, if byte is less than 0x7F, and 0x41 otherwise.
</li>
			<li>
%~lead~offset ~LET ï¼»
%~lead ~IN { `00^X ã€œ `BF^X } ãªã‚‰ã° `81^X ï¼
~ELSE_ `C1^X
ï¼½
â—
Let lead offset be 0x81, if lead is less than 0xA0, and 0xC1 otherwise.
</li>
			<li>
~IFï¼»
%~byte ~IN { `40^X ã€œ `7E^X, `80^X ã€œ `FC^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS %~lead~offset ) ~MUL 188 ~PLUS %~byte ~MINUS %~offset
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFC, inclusive, set pointer to (lead âˆ’ lead offset) Ã— 188 + byte âˆ’ offset.
</li>
			<li>
<p>
~IFï¼»
%~pointer ~IN { 8836 ã€œ 10715 }
ï¼½
ã€ï¼ subtraction is done first to avoid upsetting compilers ã€‘
â‡’
~RET ~cp [ `E000^X ~MINUS 8836 ~PLUS %~pointer ]
â—
If pointer is in the range 8836 to 10715, inclusive, return a code point whose value is 0xE000 âˆ’ 8836 + pointer.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ EUDC ã¨ã—ã¦å‘¨çŸ¥ã®ï¼Œæ—§æ¥ã® Windows ã«ã‚ˆã‚‹ã‚‚ã®ã¨ç›¸äº’é‹ç”¨å¯èƒ½ã«ã™ã‚‹ã€‚
ã€ï¼ PUA ã€‘
â—
This is interoperable legacy from Windows known as EUDC.
</p>

<p class="trans-note">ã€
EUDC â€” ã„ã‚ã‚†ã‚‹å¤–å­—ã®ãŸã‚ã®æ©Ÿèƒ½ã€‚
ã€‘ã€
8836 = 94 ~MUL 94 ã¯~Shift_JISï¼ˆ JIS X 0208 ï¼‰ã®
`<a href="https://ja.wikipedia.org/wiki/%E5%8C%BA%E7%82%B9%E7%95%AA%E5%8F%B7">åŒºç‚¹ç•ªå·</a>^_
ã®ç·æ•°ã€‚
çµæœã®~cpã¯~Unicodeç§ç”¨é ˜åŸŸã«å…¥ã‚‹ã€‚
ã€‘</p>

			</li>
			<li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ `ç´¢å¼•~jis0208$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
ï¼½
â—
Let code point be null, if pointer is null, and the index code point for pointer in index jis0208 otherwise.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp [ %~cp ]
â—
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
%~stream ã« %~byte ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN { `~ASCII~byte$, `80^X}
ï¼½
â‡’
~RET ~cp [ %~byte ]
ã€ï¼ Opera has 0x7E ã€‘
â—
If byte is an ASCII byte or 0x80, return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `A1^X ã€œ `DF^X }
ï¼½
ã€ï¼ katakana; subtraction is done first to avoid upsetting compilers ã€‘
â‡’
~RET ~cp [ `FF61^X ~PLUS ( %~byte ~MINUS `A1^X ) ]
â—
If byte is in the range 0xA1 to 0xDF, inclusive, return a code point whose value is 0xFF61 âˆ’ 0xA1 + byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `9F^X, `E0^X ã€œ `FC^X }
ï¼½
â‡’ï¼ƒ
`~Shift_JIS~lead$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$
â—
If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0 to 0xFC, inclusive, set Shift_JIS lead to byte and return continue.
</li>
	<li>
~RET `~error$
â—
Return error.
</li>
</ol>

			</section>
			<section id="shift_jis-encoder">
<h4 title="Shift_JIS encoder">12.3.2. ~Shift_JISç¬¦å·åŒ–å™¨</h4>

<p>
`Shift_JIS$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Shift_JISâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>
<ol>
	<li>
%çµæœ ~LET %~cp ã«å¿œã˜ã¦
â‡’ï¼ƒ
`~EoS$ ãªã‚‰ã° `å®Œé‚d$ ï¼
`~ASCII~cp$ãªã‚‰ã° ~byteåˆ— [ %~cp ] ï¼
`0080^U ãªã‚‰ã° ~byteåˆ— [ %~cp ] ï¼
`00A5^U ãªã‚‰ã° ~byteåˆ— [ `5C^X ] ï¼
`203E^U ãªã‚‰ã° ~byteåˆ— [ `7E^X ] ï¼
`FF61^U ã€œ `FF9F^U ãªã‚‰ã° ~byteåˆ— [ ( %~cp ~MINUS `FF61^X ) ~PLUS `A1^X ] ï¼
~ELSE_ ~NULL
â—
If code point is end-of-stream, return finished.
â—
If code point is an ASCII code point or U+0080, return a byte whose value is code point.
â—
If code point is U+00A5, return byte 0x5C.
â—
If code point is U+203E, return byte 0x7E.
â—
If code point is in the range U+FF61 to U+FF9F, inclusive, return a byte whose value is code point âˆ’ 0xFF61 + 0xA1.
</li>
	<li>
~IFï¼»
%çµæœ ~NEQ ~NULL
ï¼½
â‡’
~RET %çµæœ
â—
â†‘</li>
	<li>
~IFï¼»
%~cp ~EQ `2212^U
ï¼½
â‡’
%~cp ~SET `FF0D^U
â—
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
%~pointer ~LET
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~Shift_JIS~pointer$
â—
Let pointer be the index Shift_JIS pointer for code point.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 188 )
â—
Let lead be pointer / 188.
</li>
	<li>
%~lead~offset ~LET ï¼»
%~lead ~IN { `00^X ã€œ `1E^X } ãªã‚‰ã° `81^X ï¼
~ELSE_ `C1^Xã€ï¼ 0xA0-0x81 ã€‘
ï¼½
â—
Let lead offset be 0x81, if lead is less than 0x1F, and 0xC1 otherwise.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 188
â—
Let trail be pointer % 188.
</li>
	<li>
%~offset ~LET ï¼»
%~trail ~IN { `00^X ã€œ `3E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40, if trail is less than 0x3F, and 0x41 otherwise.
</li>
	<li>
~RET ~byteåˆ— [ ( %~lead ~PLUS %~lead~offset ), ( %~trail ~PLUS %~offset ) ]
â—
Return two bytes whose values are lead + lead offset and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-korean-encodings">
<h2 title="Legacy multi-byte Korean encodings">13. æ—§æ¥ã®è¤‡byte~Koreanç¬¦å·åŒ–æ³•</h2>

		<section id="euc-kr">
<h3 title="EUC-KR">13.1. ~EUC-KR</h3>

			<section id="euc-kr-decoder">
<h4 title="EUC-KR decoder">13.1.1. ~EUC-KRå¾©å·å™¨</h4>

<p>
å„ï¼»
`EUC-KR$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~EUC-KR~lead@ï¼ˆåˆæœŸ~æ™‚ `00^X ï¼‰
â—
EUC-KRâ€™s decoder has an associated EUC-KR lead (initially 0x00).
</p>

<p>
`EUC-KR$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-KRâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
`~EUC-KR~lead$ ~NEQ `00^X
ï¼½
â‡’ï¼ƒ
`~EUC-KR~lead$ ~SET `00^X ï¼›
~RET `~error$
â—
If byte is end-of-stream and EUC-KR lead is not 0x00, set EUC-KR lead to 0x00 and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚d$
â—
If byte is end-of-stream and EUC-KR lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~EUC-KR~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If EUC-KR lead is not 0x00,ï¼¼
</p>
		<ol>
			<li>
%~lead ~LET `~EUC-KR~lead$
â—
let lead be EUC-KR lead,ï¼¼
</li>
			<li>
%~pointer ~LET ~NULL
â—
let pointer be null,ï¼¼
</li>
			<li>
`~EUC-KR~lead$ ~SET `00^X
â—
set EUC-KR lead to 0x00, and then:
</li>
			<li>
~IFï¼»
%~byte ~IN { `41^X ã€œ `FE^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS `41^X )
â—
If byte is in the range 0x41 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 190 + (byte âˆ’ 0x41).
</li>
			<li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ `ç´¢å¼•~EUC-KR$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
ï¼½
â—
Let code point be null, if pointer is null, and the index code point for pointer in index EUC-KR otherwise.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp [ %~cp ]
â—
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
%~stream ã« %~byte ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~EUC-KR~lead$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$
â—
If byte is in the range 0x81 to 0xFE, inclusive, set EUC-KR lead to byte and return continue.
</li>
	<li>
~RET `~error$
â—
Return error.
</li>
</ol>

			</section>
			<section id="euc-kr-encoder">
<h4 title="EUC-KR encoder">13.1.2. ~EUC-KRç¬¦å·åŒ–å™¨</h4>

<p>
`EUC-KR$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-KRâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚d$
â—
If code point is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET
`ç´¢å¼•~EUC-KR$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for code point in index EUC-KR.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
â—
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET ( %~pointer ~MOD 190 ) ~PLUS `41^X
â—
Let trail be pointer % 190 + 0x41.
</li>
	<li>
~RET ~byteåˆ— [ %~lead, %~trail ]
â—
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>

ã€ï¼ removed from the spec 2013-08-23: 13.2 iso-2022-kr id="iso-2022-kr" ã€‘

	</section>
	<section id="legacy-miscellaneous-encodings">
<h2 title="Legacy miscellaneous encodings">14. æ—§æ¥ã®è«¸ã€…ã®ç¬¦å·åŒ–æ³•</h2>

		<section id="replacement">
<h3 title="replacement">14.1. ~replacement</h3>

<p class="note">æ³¨è¨˜ï¼š
`replacement$n `ç¬¦å·åŒ–æ³•$ã¯ã€~serverã¨~clientã«ãŠã‘ã‚‹ `ç¬¦å·åŒ–æ³•$ã®~supportã®ä¸ä¸€è‡´ã‚’çªãï¼Œã‚ã‚‹ç¨®ã®æ”»æ’ƒã‚’é˜²ããŸã‚ã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
â—
The replacement encoding exists to prevent certain attacks that abuse a mismatch between encodings supported on the server and the client.
</p>

			<section id="replacement-decoder">
<h4 title="replacement decoder">14.1.1. ~replacementå¾©å·å™¨</h4>

<p>
å„ï¼»
`replacement$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~replacementã«ã‚ˆã‚‹~errorã¯ã™ã§ã«è¿”ã—ãŸ~flag@ï¼ˆåˆæœŸ~æ™‚ ~F ï¼‰
â—
replacementâ€™s decoder has an associated replacement error returned flag (initially unset).
</p>

<p>
`replacement$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
replacementâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚d$
â—
If byte is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
`~replacementã«ã‚ˆã‚‹~errorã¯ã™ã§ã«è¿”ã—ãŸ~flag$ ~EQ ~F
ï¼½
â‡’ï¼ƒ
`~replacementã«ã‚ˆã‚‹~errorã¯ã™ã§ã«è¿”ã—ãŸ~flag$ ~SET ~T ï¼›
~RET `~error$
â—
If replacement error returned flag is unset, set the replacement error returned flag and return error.
</li>
	<li>
~RET `å®Œé‚d$
â—
Return finished.
</li>
</ol>

<p class="trans-note">ã€
`replacement$n ã«ã¯ã€`ç¬¦å·åŒ–å™¨$ã¯ãªã„ã€‚
ã€‘</p>

			</section>
		</section>
		<section id="common-infrastructure-for-utf-16be-and-utf-16le">
<h3 title="Common infrastructure for UTF-16BE and UTF-16LE">14.2. ~UTF-16BEã¨~UTF-16LEã«å…±é€šã®åŸºç›¤</h3>

			<section id="shared-utf-16-decoder">
<h4 title="shared UTF-16 decoder">14.2.1. å…±ç”¨~UTF-16å¾©å·å™¨</h4>

<p class="note">æ³¨è¨˜ï¼š
~BOMã¯`~label$ã‚ˆã‚Šå„ªå…ˆã•ã‚Œã‚‹ã€‚
ãã‚Œã¯ï¼Œé…å‚™-æ¸ˆã¿ã®å†…å®¹ã«ãŠã„ã¦ã€ã©ã®`~label$ã‚ˆã‚Šã‚‚æ­£ç¢ºaã§ã‚ã‚‹ã“ã¨ãŒè¦‹å‡ºã•ã‚Œã¦ã„ã‚‹ã®ã§ã€‚
ã—ãŸãŒã£ã¦ ãã‚Œã¯ã€`å…±ç”¨~UTF-16å¾©å·å™¨$ã®ä¸€éƒ¨ã§ã¯ãªãï¼Œ`~Unicodeã«å¾©å·ã™ã‚‹$ ~algoã®ä¸€éƒ¨ã‚’æˆã™ã€‚
â—
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the shared UTF-16 decoder algorithm but rather the decode algorithm.
</p>

<p>
å„ï¼»
`å…±ç”¨~UTF-16å¾©å·å™¨$
ï¼½ã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`~UTF-16~lead~byte@ï¼ˆåˆæœŸ~æ™‚ ~NULL ï¼‰,
`~UTF-16~lead~surrogate@ï¼ˆåˆæœŸ~æ™‚ ~NULL ï¼‰,
`~UTF-16BEå¾©å·å™¨~flag@ï¼ˆåˆæœŸ~æ™‚ ~F ï¼‰
â—
shared UTF-16 decoder has an associated UTF-16 lead byte and UTF-16 lead surrogate (both initially null), and UTF-16BE decoder flag (initially unset).
</p>

<p>
`å…±ç”¨~UTF-16å¾©å·å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
shared UTF-16 decoderâ€™s handler, given a stream and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
`~UTF-16~lead~byte$ ~NEQ ~NULL
ï¼½~ORï¼»
`~UTF-16~lead~surrogate$ ~NEQ ~NULL
ï¼½
â‡’ï¼ƒ
`~UTF-16~lead~byte$ ~SET ~NULLï¼›
`~UTF-16~lead~surrogate$ ~SET ~NULLï¼›
~RET `~error$
â—
If byte is end-of-stream and either UTF-16 lead byte or UTF-16 lead surrogate is non-null, set UTF-16 lead byte and UTF-16 lead surrogate to null, and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚d$
â—
If byte is end-of-stream and UTF-16 lead byte and UTF-16 lead surrogate are null, return finished.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
`~UTF-16~lead~byte$ ~EQ ~NULL
ï¼½
â‡’ï¼ƒ
`~UTF-16~lead~byte$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$
â—
If UTF-16 lead byte is null, set UTF-16 lead byte to byte and return continue.
</li>
	<li>
%~cu ~LET `~UTF-16BEå¾©å·å™¨~flag$ã«å¿œã˜ã¦
â‡’ï¼ƒ
~T ãªã‚‰ã° ( ( `~UTF-16~lead~byte$ ~Lshift 8 ) ~PLUS %~byte ) ï¼
~F ãªã‚‰ã° ( ( %~byte ~Lshift 8 ) ~PLUS `~UTF-16~lead~byte$ )
â—
Let code unit be the result of:
â€¢ UTF-16BE decoder flag is set
â€¢â€¢ (UTF-16 lead byte &lt;&lt; 8) + byte.
â€¢ UTF-16BE decoder flag is unset
â€¢â€¢ (byte &lt;&lt; 8) + UTF-16 lead byte.
</li>
	<li>
`~UTF-16~lead~byte$ ~SET ~NULL
â—
Then set UTF-16 lead byte to null.
</li>
	<li>
<p>
~IFï¼»
`~UTF-16~lead~surrogate$ ~NEQ ~NULL
ï¼½ï¼š
â—
If UTF-16 lead surrogate is non-null,ï¼¼
</p>
		<ol>
			<li>
%~lead~surrogate ~LET `~UTF-16~lead~surrogate$
â—
let lead surrogate be UTF-16 lead surrogate,ï¼¼
</li>
			<li>
`~UTF-16~lead~surrogate$ ~SET ~NULL
â—
set UTF-16 lead surrogate to null, and then:
</li>
			<li>
~IFï¼»
%~cu ~IN { `DC00^U ã€œ `DFFF^U }
ï¼½
â‡’
~RET ~cp [
`10000^X ~PLUS ( ( %~lead~surrogate ~MINUS `D800^X ) ~Lshift 10 ) ~PLUS ( %~cu ~MINUS `DC00^X )
]
â—
If code unit is in the range U+DC00 to U+DFFF, inclusive, return a code point whose value is 0x10000 + ((lead surrogate âˆ’ 0xD800) &lt;&lt; 10) + (code unit âˆ’ 0xDC00).
</li>
			<li>
%byte1 ~LET %~cu ~Rshift 8
â—
Let byte1 be code unit &gt;&gt; 8.
</li>
			<li>
%byte2 ~LET %~cu ~bAND `00FF^X
â—
Let byte2 be code unit &amp; 0x00FF.
</li>
			<li>
%~byteåˆ— ~LET %~utf-16be~flag ã«å¿œã˜ã¦
â‡’ï¼ƒ
~T ãªã‚‰ã° ~byteåˆ— [ %byte1, %byte2 ] ï¼
~F ãªã‚‰ã° ~byteåˆ— [ %byte2, %byte1 ]
â—
Let bytes be two bytes whose values are byte1 and byte2, if the UTF-16BE decoder flag is set, and byte2 and byte1 otherwise.
</li>
			<li>
%~stream ã« %~byteåˆ— ã‚’`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend the bytes to stream and return error.
</li>
			<li>
~RET `~error$
â—
â†‘</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~cu ~IN { `D800^U ã€œ `DBFF^U }
ï¼½
â‡’ï¼ƒ
`~UTF-16~lead~surrogate$ ~SET %~cu ï¼›
~RET `ç¶™ç¶š-$
â—
If code unit is in the range U+D800 to U+DBFF, inclusive, set UTF-16 lead surrogate to code unit and return continue.
</li>
	<li>
~IFï¼»
%~cu ~IN { `DC00^U ã€œ `DFFF^U }
ï¼½
ã€ï¼ unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them ã€‘
â‡’
~RET `~error$
â—
If code unit is in the range U+DC00 to U+DFFF, inclusive, return error.
</li>
	<li>
~RET ~cp [ %~cu ]
â—
Return code point code unit.
</li>
</ol>

			</section>
		</section>
		<section id="utf-16be">
<h3 title="UTF-16BE">14.3. ~UTF-16BE</h3>

			<section id="utf-16be-decoder">
<h4 title="UTF-16BE decoder">14.3.1. ~UTF-16BEå¾©å·å™¨</h4>

<p>
`UTF-16BE$n ã®`å¾©å·å™¨$ã¯ã€ï¼»
`~UTF-16BEå¾©å·å™¨~flag$ ~SET ~T
ï¼½ã«ã•ã‚ŒãŸ`å…±ç”¨~UTF-16å¾©å·å™¨$ã§ã‚ã‚‹ã€‚
â—
UTF-16BEâ€™s decoder is shared UTF-16 decoder with its UTF-16BE decoder flag set.
</p>

			</section>
		</section>
		<section id="utf-16le">
<h3 title="UTF-16LE">14.4. ~UTF-16LE</h3>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™-æ¸ˆã¿ã®å†…å®¹ã«~~å¯¾å‡¦ã™ã‚‹ãŸã‚ã€ `utf-16^lb, `utf-16le^lb ã®ã„ãšã‚Œã‚‚ `UTF-16LE$n ç”¨ã®`~label$ã«ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
Both "utf-16" and "utf-16le" are labels for UTF-16LE to deal with deployed content.
</p>

			<section id="utf-16le-decoder">
<h4 title="UTF-16LE decoder">14.4.1. ~UTF-16LEå¾©å·å™¨</h4>

<p>
`UTF-16BE$n ã®`å¾©å·å™¨$ã¯ã€`å…±ç”¨~UTF-16å¾©å·å™¨$ã§ã‚ã‚‹ã€‚
â—
UTF-16LEâ€™s decoder is shared UTF-16 decoder.
</p>

			</section>
		</section>
		<section id="x-user-defined">
<h3 title="x-user-defined">14.5. ~x-user-defined</h3>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯å½¢ä¸Šã§ã¯`å˜byteç¬¦å·åŒ–æ³•$ã§ã‚ã‚‹ãŒã€~algoçš„ã«å®Ÿè£…ã§ãã‚‹ã®ã§ï¼Œåˆ¥ã€…ã«å®šç¾©ã•ã‚Œã‚‹ã€‚
â—
While technically this is a single-byte encoding, it is defined separately as it can be implemented algorithmically.
</p>

			<section id="x-user-defined-decoder">
<h4 title="x-user-defined decoder">14.5.1. ~x-user-definedå¾©å·å™¨</h4>

<p>
`x-user-defined$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
x-user-definedâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>
<ol>
	<li>
~RET %~byte ã«å¿œã˜ã¦
â‡’ï¼ƒ
`~EoS$ãªã‚‰ã° `å®Œé‚d$ ï¼
`~ASCII~byte$ã§ã‚ã‚‹ãªã‚‰ã° ~cp [ %~byte ] ï¼
~ELSE_ ~cp [ `F780^X ~PLUS %~byte ~MINUS `80^X ]
â—
If byte is end-of-stream, return finished.
â—
If byte is an ASCII byte, return a code point whose value is byte.
â—
Return a code point whose value is 0xF780 + byte âˆ’ 0x80.
</li>
</ol>

			</section>
			<section id="x-user-defined-encoder">
<h4 title="x-user-defined encoder">14.5.2. ~x-user-definedç¬¦å·åŒ–å™¨</h4>

<p>
`x-user-defined$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
x-user-definedâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>
<ol>
	<li>
~RET %~cp ã«å¿œã˜ã¦
â‡’ï¼ƒ
`~EoS$ãªã‚‰ã° `å®Œé‚d$ ï¼
`~ASCII~cp$ãªã‚‰ã° ~byteåˆ— [ %~cp ] ï¼
`F780^U ã€œ `F7FF^U ãªã‚‰ã° ~byteåˆ— [ %~cp ~MINUS `F780^X ~PLUS `80^X ] ï¼
~ELSE_ %~cp ã‚’ä¼´ã†`~error$
â—
If code point is end-of-stream, return finished.
â—
If code point is an ASCII code point, return a byte whose value is code point.
â—
If code point is in the range U+F780 to U+F7FF, inclusive, return a byte whose value is code point âˆ’ 0xF780 + 0x80.
â—
Return error with code point.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="browser-ui">
<h2 title="Browser UI">15. ~browser UI</h2>

<p>
~browserã«ã¯ã€è³‡æºã®ç¬¦å·åŒ–æ³•ã«å¯¾ã™ã‚‹ä¸Šæ›¸ãã‚’å¯èƒ½åŒ–ã•ã›ãªã„ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšï¼Œãã®ç¨®ã®ç‰¹èƒ½ãŒåœ¨ã‚‹å ´åˆã€å‰è¿°ã®
<a href="#security-background">~securityä¸Šã®èª²é¡Œ</a>
ã‹ã‚‰ï¼Œ~browserã¯ï¼Œ `UTF-16BE$nï¼`UTF-16LE$n ã‚’~optionã¨ã—ã¦æä¾›ã™ã‚‹ãƒ™ã‚­ã§ãªã„ã€‚
~browserã¯ã€è³‡æºãŒ `UTF-16BE$nï¼`UTF-16LE$n ã‚’åˆ©ç”¨ã—ã¦å¾©å·ã•ã‚ŒãŸå ´åˆã§ã‚‚ï¼Œã“ã®ç‰¹èƒ½ã‚’ä¸èƒ½åŒ–ã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹ã€‚
â—
Browsers are encouraged to not enable overriding the encoding of a resource. If such a feature is nonetheless present, browsers should not offer either UTF-16BE or UTF-16LE as option due to aforementioned security issues. Browsers also should disable this feature if the resource was decoded using either UTF-16BE or UTF-16LE.
</p>

	</section>
	<section id="implementation-considerations">
<h2 title="Implementation considerations">å®Ÿè£…~ä¸Šã®è€ƒæ…®ç‚¹</h2>

<p>
ã“ã®æ¨™æº–ã«ãŠã‘ã‚‹`ç¬¦å·åŒ–æ³•$ç”¨ã®`å¾©å·å™¨$ã¯ã€ä»»æ„ãª`å‰ä»˜åŠ -$ã‚’å‚™ãˆã‚‹`~stream$ã‚’~supportã™ã‚‹ä»£ã‚ã‚Šã«ï¼Œæ¬¡ã«ã‚ˆã‚Šå®Ÿè£…ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ï¼š
â—
Instead of supporting streams with arbitrary prepend, the decoders for encodings in this standard could be implemented with:
</p>
<ol>
	<li>
èª­å–ã£ãŸç¾åœ¨ã®~byteã‚’å…ƒã«æˆ»ã™èƒ½ã€‚
â—
The ability to unread the current byte.
</li>
	<li>
`ISO-2022-JP$n ç”¨ã®å˜byteï¼ˆ `24^X ï¼ `28^X ï¼‰~bufferã€‚
â—
â†“</li>
	<li>
<p>
`gb18030$n ç”¨ã®å˜byteï¼ˆ `~ASCII~byte$ ï¼‰~bufferã€‚
â—
A single-byte buffer for gb18030 (an ASCII byte) and ISO-2022-JP (0x24 or 0x28).
</p>

<p class="example" id="example-gb18030-implementation-strategy">
`gb18030$n ã«å¯¾ã—ã¦ã¯ã€ï¼»
`~gb3$ ~NEQ `00^X
ï¼½ã®é–“ã«~~ä¸æ­£ãª~byteã«å‡ºãã‚ã—ãŸã¨ãã¯ã€`~gb2$ã¯ï¼Œæ¬¡å›ã«è¿”ã™ã“ã¨ã«ãªã‚‹å˜byte~bufferã®ä¸­ã«ç§»å‹•ã§ãã€`~gb3$ãŒ
â€” å˜byte~bufferã‚’è¿”ã—ã¦ç©ºã«ã—ãŸå¾Œï¼Œ `00^X ã§ãªã„ã“ã¨ã‚’æ¤œæŸ»ã—ãŸãªã‚‰ â€”
æ–°ãŸãª`~gb1$ã«ãªã‚‹ã€‚
ã“ã‚Œã¯ã€ `gb18030$n ã«ãŠã‘ã‚‹ 1 å€‹ç›®ã¨ 3 å€‹ç›®ã®~byteç¯„å›²ãŒä¸€è‡´ã™ã‚‹ã®ã§å¯èƒ½ã«ãªã‚‹ã€‚
â—
For gb18030 when hitting a bogus byte while gb18030 third is not 0x00, gb18030 second could be moved into the single-byte buffer to be returned next, and gb18030 third would be the new gb18030 first, checked for not being 0x00 after the single-byte buffer was returned and emptied. This is possible as the range for the first and third byte in gb18030 is identical.
</p>
	</li>
</ol>

<p>
`~ISO-2022-JPç¬¦å·åŒ–å™¨$ã«ã¯ï¼Œè¿½åŠ çš„ãªçŠ¶æ…‹ã¨ã—ã¦`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ãŒå¿…è¦ã«ãªã‚‹ãŒã€ãã‚Œä»¥å¤–ã§ã¯ï¼Œã“ã®æ¨™æº–ã«ãŠã‘ã‚‹`ç¬¦å·åŒ–æ³•$ç”¨ã®ã©ã®`ç¬¦å·åŒ–å™¨$ã«ã‚‚ è¿½åŠ çš„ãªçŠ¶æ…‹ã‚„~bufferã¯è¦æ±‚ã•ã‚Œãªã„ã€‚
â—
The ISO-2022-JP encoder needs ISO-2022-JP encoder state as additional state, but other than that, none of the encoders for encodings in this standard require additional state or buffers.
</p>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">è¬è¾</h2>

<p>
å¹´æœˆã«æ¸¡ã‚Šã€ç¬¦å·åŒ–æ³•ã‚’ç›¸äº’é‹ç”¨å¯èƒ½ãªã‚‚ã®ã«ã™ã‚‹ãŸã‚ã«ï¼ŒãŸãã•ã‚“ã®æ–¹ã€…ãŒåŠ©åŠ›ã•ã‚Œã€ã“ã®æ¨™æº–ã®ç›®æ¨™ã¸è¿‘ä»˜ã‘ã¦ããŸã€‚
åŒæ§˜ã«å¤šãã®æ–¹ã€…ã®åŠ©åŠ›ãŒï¼Œã“ã®æ¨™æº–ã‚’~~ç¾åœ¨ã®å§¿ã«ä»•ç«‹ã¦ä¸Šã’ã¦ããŸã€‚
ç‰¹ã«ï¼Œæ¬¡ã®æ–¹ã€…ã«æ„Ÿè¬ã™ã‚‹ï¼š
â—
There have been a lot of people that have helped make encodings more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</p>

`_acks1@

	</section>
</main>

<div hidden>
<div lang="en-x-a0" id="_acks1">
<p>
With that, many thanks to

Adam Rice,
Alan Chaney,
Alexander Shtuchkin,
Allen Wirfs-Brock,
Andreu Botella,
Aneesh Agrawal,
Arkadiusz Michalski,
Asmus Freytag,
Ben Noordhuis,
Bnaya Peretz,
Boris Zbarsky,
Bruno Haible,
Cameron McCormack,
Charles McCathieNeville,
Christopher Foo,
David Carlisle,
Domenic Denicola,
Dominique HazaÃ«l-Massieux,
Doug Ewell,
Erik van der Poel,
<span lang="zh">è­šæ°¸é‹’</span> (Frank Yung-Fong Tang),
Glenn Maynard,
Gordon P. Hemsley,
Henri Sivonen,
Ian Hickson,
James Graham,
Jeffrey Yasskin,
John Tamplin,
Joshua Bell,
<span lang="ja">æ‘äº•ç´”</span> (Jun Murai),
<span lang="ko">ì‹ ì •ì‹</span> (Jungshik Shin),
Jxck,
<span lang="ko">ê°• ì„±í›ˆ</span> (Kang Seonghoon),
<span lang="ja">å·å¹¡å¤ªä¸€</span> (Kawabata Taichi),
Ken Lunde,
Ken Whistler,
Kenneth Russell,
<span lang="ja">ç”°æ‘å¥äºº</span> (Kent Tamura),
Leif Halvard Silli,
Luke Wagner,
Maciej Hirsz,
Makoto Kato,
Mark Callow,
Mark Crispin,
Mark Davis,
Martin DÃ¼rst,
Masatoshi Kimura,
Mattias Buelens,
Ms2ger,
Nigel Megitt,
Nigel Tao,
Norbert Lindenberg,
Ã˜istein E. Andersen,
Peter Krefting,
Philip JÃ¤genstedt,
Philip Taylor,
Richard Ishida,
Robbert Broersma,
Robert Mustacchi,
Ryan Dahl,
Sam Sneddon,
Shawn Steele,
Simon Montagu,
Simon Pieters,
Simon Sapin,
<span lang="ja">å¯ºç”°å¥</span> (Takeshi Terada),
Vyacheslav Matva, and
<span lang="ja">æˆç€¬ã‚†ã„</span> (Yui Naruse)

for being awesome.
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>
).
The <a href="#api">API</a> chapter was initially written by Joshua Bell
(<a href="https://www.google.com/">Google</a>).
</p>

<p>
Copyright Â© 2020 WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.
</p>
</div>
</div>
