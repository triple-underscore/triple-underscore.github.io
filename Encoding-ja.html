<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Encodingï¼ˆæ—¥æœ¬èªè¨³ï¼‰</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
#encoding-labels td + td {
	white-space: pre;
	white-space: pre-line;
}

.coder {
	font-family: sans-serif0, sans-serif;
}

b.ename {
	font-weight: normal;
	font-family: sans-serif0, sans-serif;
	color: var(--K-color);
}

#_big5-lead > tr > td:nth-child(2) {
	white-space: nowrap;
}

</style>


<style>
/* based on the style at
https://encoding.spec.whatwg.org/visualization-colors.css
(2017-01-22)
*/

._vis-visualizationlegend {
	> tr {
		vertical-align: top;
		> :first-child {
			background: white;
			> :first-child {
				box-sizing: border-box;
				width: 2em;
				height: 2em;
			}
		}
	}
}

._vis-unmapped {
  background-color: #920000;
  color: white;
}

._vis-astral {
  background-color: #6db6fe;
  color: black;
}

._vis-mid {
  background-color: #ffff6d;
  color: black;
}

._vis-upper, ._vis-byte {
  background-color: #d4d5db;
  color: black;
}

._vis-pua {
  background-color: #db6d00;
  color: black;
}

._vis-mid._vis-contiguous {
  background-color: #009292;
  color: black;
}

._vis-upper._vis-contiguous {
  background-color: #24fe23;
  color: black;
}

._vis-pua._vis-contiguous {
  background-color: #924900;
  color: white;
}

._vis-astral._vis-contiguous {
  background-color: #480091;
  color: white;
}

._vis-duplicate {
  border-style: solid ;
  border-color: #920000;
  color: black;
}

._vis-compatibility {
  border-style: dashed;
  border-color: black;
}

._vis-duplicate._vis-compatibility {
  border-style: dashed;
  border-color: #920000;
}

._vis-ext {
  border-style: dotted;
  border-color: black;
}

._vis-ext._vis-compatibility {
  border-style: dotted;
  border-color: #920000;
}

._vis-surrogate {
  background-color: #b4b4b6;
}



@supports (grid-template-columns: subgrid) and (display: contents) {

#_index_list {
	grid-template-columns: 10em 1fr 1fr 1fr;
	min-width: 30em;
	max-width: 70em;
	tr {
		grid-template-areas:
			"åå‰ ç´¢å¼• è¦–è¦šåŒ– è¢«è¦†åŸŸ"
			"åå‰ å‚™è€ƒ å‚™è€ƒ å‚™è€ƒ"
		;
		> *:nth-child(1) {
			grid-area: åå‰;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: ç´¢å¼•;
		}
		> *:nth-child(3) {
			grid-area: è¦–è¦šåŒ–;
		}
		> *:nth-child(4) {
			grid-area: è¢«è¦†åŸŸ;
		}
		> *:nth-child(5) {
			grid-area: å‚™è€ƒ;
		}
	}
}

}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~ä¸€-é¿†ã‚-ã‚“]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('ï¼ ');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
case 'lb': // label
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'mc':
	text = "constructor";
	href = `#dom-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'n': // encoding name
	href = `#${key.toLowerCase()}`;
	break;
case 'tA': // å‹æ³¨é‡ˆ
	text = `&lt;${key}&gt;`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'X':
	text = `0x${key}`;
	break;
case 'idx':
	return idx_html(key);
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}

	function idx_html(key){
		const k = key.toLowerCase();
		const url = 'https://encoding.spec.whatwg.org/';

		let txt = `
<a href="${url}index-${k}.txt">index-${k}.txt</a>`;
		let vis = `
<td><a href="${url}${k}.html">ç´¢å¼• <b class="ename">${key}</b> è¦–è¦š-åŒ–</a>`;
		let cover = `
<td><a href="${url}${k}-bmp.html">ç´¢å¼• <b class="ename">${key}</b> BMP è¢«è¦†åŸŸ</a>`;

		switch(key){
			case 'jis0208':
				vis += `,
<a href="${url}shift_jis.html">ç´¢å¼•~Shift_JISè¦–è¦š-åŒ–</a>`;
			break;
			case 'gb18030-ranges':
			case 'iso-2022-jp-katakana':
				vis = cover = '<td>';
			break;
//			case 'ISO-8859-8-I'
		}

		return txt + vis + cover;
	}
}

</script>

<script type="text/plain" id="_source_data">


â—â—options

spec_title:Encoding
spec_date:2025-04-23
trans_update:2025-04-23
source_checked:240613
spec_status:LS
original_url:https://encoding.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
copyright:,whatwg
trans_1st_pub:2012-10-22


â—â—class_map
E:error
n:ename
U:code-point
cn:cp-name
X:hex-value

â—â—tag_map
I:code
m:code
mb:code
E:code
n:b
U:span
cn:span
X:span
i:i
i1:i
V:var
tA:sub
c:code
em:em
cite:cite

â—â—mdn_urls
textdecoder:API/TextDecoder
textencoder:API/TextEncoder
	textdecoderoptions:API/TextDecoderOptions
	textdecodeoptions:API/TextDecodeOptions
	dictdef-textencoderencodeintoresult:API/TextEncoderEncodeIntoResult
	textencodeoptions:API/TextEncodeOptions
	textdecodercommon:API/TextDecoderCommon
	textdecoderstream:API/TextDecoderStream
	textencodercommon:API/TextEncoderCommon
	textencoderstream:API/TextEncoderStream


â—â—original_id_map
	æ—§ id
	textdecodercommon-decoder:textdecoderstream-decoder
	textdecodercommon-decoder:textdecoder-decoder
	textdecodercommon-i-o-queue:textdecodercommon-stream
	textdecodercommon-i-o-queue:textdecoderstream-stream
	textdecodercommon-i-o-queue:textdecoder-stream

â—â—link_map


	â—IDL
Exposed:~WEBIDLjs#Exposed
AllowShared:~WEBIDLjs#AllowShared

E.RangeError:~WEBIDL#exceptiondef-rangeerror
E.TypeError:~WEBIDL#exceptiondef-typeerror

I.TextDecoderOptions:#textdecoderoptions
I.TextDecodeOptions:#textdecodeoptions
I.TextDecoder:#textdecoder
I.TextEncoderEncodeIntoResult:#dictdef-textencoderencodeintoresult
I.TextEncodeOptions:#textencodeoptions
I.TextEncoder:#textencoder
I.AllowSharedBufferSource:~WEBIDL#AllowSharedBufferSource
I.BufferSource:~WEBIDL#BufferSource
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array
I.Uint32Array:~WEBIDL#idl-Uint32Array

I.TextDecoderCommon:#textdecodercommon
I.TextDecoderStream:#textdecoderstream
I.TextEncoderCommon:#textencodercommon
I.TextEncoderStream:#textencoderstream

I.GenericTransformStream:~STREAMS#generictransformstream
I.ReadableStream:~STREAMS#readablestream
I.WritableStream:~STREAMS#writablestream
I.TransformStream:~STREAMS#transformstream

Uint8Array:~WEBIDL#idl-Uint8Array
USVString:~WEBIDL#idl-USVString
DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean
unsigned long long:~WEBIDL#idl-unsigned-long-long

m.new TextDecoder:#dom-textdecoder
m.encoding:#dom-textdecoder-encoding
m.fatal:#dom-textdecoder-fatal
m.ignoreBOM:#dom-textdecoder-ignorebom

m.new TextEncoder:#dom-textencoder
m.decode:#dom-textdecoder-decode
m.~encoding0:#dom-textencoder-encoding
m.encode:#dom-textencoder-encode
m.encodeInto:#dom-textencoder-encodeinto

m.read:#dom-textencoderencodeintoresult-read
m.written:#dom-textencoderencodeintoresult-written

m.new TextEncoderStream:#dom-textencoderstream
m.new TextDecoderStream:#dom-textdecoderstream

m.readable:~STREAMS#dom-generictransformstream-readable
m.writable:~STREAMS#dom-generictransformstream-writable

m.pipeThrough:~STREAMS#rs-pipe-through

mb.fatal:#dom-textdecoderoptions-fatal
mb.ignoreBOM:#dom-textdecoderoptions-ignorebom

mb.stream:#dom-textdecodeoptions-stream

	%input:#dom-textdecoder-decode-input-options-input
	%label:#dom-textdecoder-textdecoder-label-options-label
	%label:#dom-textdecoderstream-textdecoderstream-label-options-label
	%options:#dom-textdecoder-decode-input-options-options
	%options:#dom-textdecoder-textdecoder-label-options-options
	%options:#dom-textdecoderstream-textdecoderstream-label-options-options

	â—ç”¨èª

ç¬¦å·åŒ–æ³•:#encoding
åå‰:#name
~label:#label
~label:#_labels
å¾©å·å™¨:#decoder
~Unicodeã«å¾©å·ã™ã‚‹:#decode
~UTF-8å¾©å·ã™ã‚‹:#utf-8-decode
~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹:#utf-8-decode-without-bom
~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹:#utf-8-decode-without-bom-or-fail
~BOMã‚’~sniffã™ã‚‹:#bom-sniff
~UTF-8ç¬¦å·åŒ–ã™ã‚‹:#utf-8-encode
ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹:#encode
ç¬¦å·åŒ–å™¨ã‚’å–å¾—ã™ã‚‹:#get-an-encoder
ç¬¦å·åŒ–ã™ã‚‹ã‹å¤±æ•—ã™ã‚‹:#encode-or-fail

ç¬¦å·åŒ–å™¨:#encoder
~handler:#handler
~error~mode:#error-mode
i.~error:#error
i.å®Œé‚d:#finished
i.ç¶™ç¶š-:#continue
~EoQ:#end-of-stream
~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹:#concept-encoding-get
ç¬¦å·åŒ–æ³•ã‹ã‚‰å‡ºåŠ›~ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹:#get-an-output-encoding
å…¥å‡ºåŠ›~queue:#concept-stream
å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹:#concept-stream-read
å…¥å‡ºåŠ›~queueã‹ã‚‰~itemåˆ—ã‚’èª­å–ã‚‹:#_concept-stream-read
å…¥å‡ºåŠ›~queueã‚’è¦—è¦‹ã‚‹:#i-o-queue-peek
å…¥å‡ºåŠ›~queueã«~pushã™ã‚‹:#concept-stream-push
ioQ.~push:#concept-stream-push
å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™:#concept-stream-prepend
æ ¼ç´ã—ç›´ã™æ¼”ç®—:#concept-stream-prepend
å¤‰æ›ã™ã‚‹:#from-i-o-queue-convert
å…¥å‡ºåŠ›~queueã«å¤‰æ›ã™ã‚‹:#to-i-o-queue-convert

~queueã‚’å‡¦ç†ã™ã‚‹:#concept-encoding-run
	èµ°ã‚‰ã™:#concept-encoding-run
~itemã‚’å‡¦ç†ã™ã‚‹:#concept-encoding-process

~surrogateå¯¾ã‹ã‚‰~scalarå€¤ã‚’å¾—ã™ã‚‹:#scalar-value-from-surrogates

	â—
ç´¢å¼•:#index
ç´¢å¼•~cp:#index-code-point
ç´¢å¼•~pointer:#index-pointer
ç´¢å¼•~Big5~pointer:#index-big5-pointer
ç´¢å¼•~Big5:#index-big5
ç´¢å¼•~EUC-KR:#index-euc-kr
ç´¢å¼•~jis0208:#index-jis0208
ç´¢å¼•~jis0212:#index-jis0212
ç´¢å¼•~Shift_JIS~pointer:#index-shift_jis-pointer
ç´¢å¼•~ISO-2022-JP~katakana:#index-iso-2022-jp-katakana
ç´¢å¼•~gb18030ç¯„å›²~ç¾¤:#index-gb18030-ranges
ç´¢å¼•~gb18030ç¯„å›²~ç¾¤~cp:#index-gb18030-ranges-code-point
ç´¢å¼•~gb18030ç¯„å›²~ç¾¤~pointer:#index-gb18030-ranges-pointer

ç´¢å¼•~gb18030:#index-gb18030

~UTF-8~cp:#utf-8-code-point
~UTF-8å‡ºç¾~byteæ•°:#utf-8-bytes-seen
~UTF-8è¦~byteæ•°:#utf-8-bytes-needed
~UTF-8ä¸‹é™:#utf-8-lower-boundary
~UTF-8ä¸Šé™:#utf-8-upper-boundary

å˜-~byteç¬¦å·åŒ–æ³•:#single-byte-encoding
å˜-~byteç´¢å¼•:#index-single-byte


	â—åå‰
	n.UTF-8:#utf-8
	n.IBM866:#ibm866
	n.ISO-8859-2:#iso-8859-2
	n.ISO-8859-3:#iso-8859-3
	n.ISO-8859-4:#iso-8859-4
	n.ISO-8859-5:#iso-8859-5
	n.ISO-8859-6:#iso-8859-6
	n.ISO-8859-7:#iso-8859-7
	n.ISO-8859-8:#iso-8859-8
	n.ISO-8859-8-I:#iso-8859-8-i
	n.ISO-8859-10:#iso-8859-10
	n.ISO-8859-13:#iso-8859-13
	n.ISO-8859-14:#iso-8859-14
	n.ISO-8859-15:#iso-8859-15
	n.ISO-8859-16:#iso-8859-16
	n.KOI8-R:#koi8-r
	n.KOI8-U:#koi8-u
	n.macintosh:#macintosh
	n.windows-874:#windows-874
	n.windows-1250:#windows-1250
	n.windows-1251:#windows-1251
	n.windows-1252:#windows-1252
	n.windows-1253:#windows-1253
	n.windows-1254:#windows-1254
	n.windows-1255:#windows-1255
	n.windows-1256:#windows-1256
	n.windows-1257:#windows-1257
	n.windows-1258:#windows-1258
	n.x-mac-cyrillic:#x-mac-cyrillic

	n.GBK:#gbk
	n.gb18030:#gb18030
	n.Big5:#big5
	n.EUC-JP:#euc-jp
	n.ISO-2022-JP:#iso-2022-jp
	n.Shift_JIS:#shift_jis
	n.EUC-KR:#euc-kr
	n.replacement:#replacement
	n.UTF-16LE:#utf-16le
	n.UTF-16BE:#utf-16be
	n.x-user-defined:#x-user-defined

n.UTF-16BE/LE:#utf-16be-le

	â—encoderï¼decoder IDL
dec.ç¬¦å·åŒ–æ³•:#textdecoder-encoding
dec.å¾©å·å™¨:#textdecodercommon-decoder
dec.å…¥å‡ºåŠ›~queue:#textdecodercommon-i-o-queue
dec.æ›¸å‡ºã•ãªã„ã‹:#textdecoder-do-not-flush-flag
dec.~BOMã¯ç„¡è¦–ã™ã‚‹ã‹:#textdecoder-ignore-bom-flag
dec.~BOMã‚’è¦‹ã¤ã‘ãŸã‹:#textdecoder-bom-seen-flag
dec.~error~mode:#textdecoder-error-mode

å…¥å‡ºåŠ›~queueã‚’ç›´åˆ—åŒ–ã™ã‚‹:#concept-td-serialize

enc.ç¬¦å·åŒ–å™¨:#textencoderstream-encoder
enc.é ­éƒ¨~surrogate:#textencoderstream-pending-high-surrogate

~cuã‚’~scalarå€¤ã«å¤‰æ›ã™ã‚‹:#convert-code-unit-to-scalar-value
~chunkã‚’å¾©å·ã—ã¦~enqueueã™ã‚‹:#decode-and-enqueue-a-chunk
~chunkã‚’ç¬¦å·åŒ–ã—ã¦~enqueueã™ã‚‹:#encode-and-enqueue-a-chunk
ç¬¦å·åŒ–ã—ã¦æ›¸å‡ºã™:#encode-and-flush
æ›¸å‡ºã—ã¦~enqueueã™ã‚‹:#flush-and-enqueue


	â—å„ç¨® encoderï¼decoder

~UTF-8å¾©å·å™¨:#utf-8-decoder
~UTF-8ç¬¦å·åŒ–å™¨:#utf-8-encoder
å…±ç”¨~UTF-16å¾©å·å™¨:#shared-utf-16-decoder
~replacementå¾©å·å™¨:#replacement-decoder
~replacement~errorã¯è¿”ã—ãŸã‹:#replacement-error-returned-flag

å˜-~byteå¾©å·å™¨:#single-byte-decoder
å˜-~byteç¬¦å·åŒ–å™¨:#single-byte-encoder

~GBKç”¨ã‹:#gbk-flag

~gb1:#gb18030-first
~gb2:#gb18030-second
~gb3:#gb18030-third

~gb18030å¾©å·å™¨:#gb18030-decoder
~gb18030ç¬¦å·åŒ–å™¨:#gb18030-encoder

~Big5~lead:#big5-lead
~Big5å¾©å·å™¨:#big5-decoder
~Big5ç¬¦å·åŒ–å™¨:#big5-encoder

~EUC-JP~lead:#euc-jp-lead
~EUC-JP~jis0212:#euc-jp-jis0212-flag
~EUC-JPå¾©å·å™¨:#euc-jp-decoder
~EUC-JPç¬¦å·åŒ–å™¨:#euc-jp-encoder

~ISO-2022-JPå¾©å·å™¨:#iso-2022-jp-decoder
~ISO-2022-JPç¬¦å·åŒ–å™¨:#iso-2022-jp-encoder

~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹:#iso-2022-jp-decoder-state
~ISO-2022-JPå¾©å·å™¨~å‡ºåŠ›~çŠ¶æ…‹:#iso-2022-jp-decoder-output-state
~ISO-2022-JP~lead:#iso-2022-jp-lead
~ISO-2022-JPå‡ºåŠ›:#iso-2022-jp-output-flag

i.ASCII:#iso-2022-jp-decoder-ascii
i.Roman:#iso-2022-jp-decoder-roman
i.katakana:#iso-2022-jp-decoder-katakana
i.~lead~byte:#iso-2022-jp-decoder-lead-byte
i.~trail~byte:#iso-2022-jp-decoder-trail-byte
i.~escapeé–‹å§‹:#iso-2022-jp-decoder-escape-start
i.~escape:#iso-2022-jp-decoder-escape

~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹:#iso-2022-jp-encoder-state
i1.ASCII:#iso-2022-jp-encoder-ascii
i1.Roman:#iso-2022-jp-encoder-roman
i1.jis0208:#iso-2022-jp-encoder-jis0208

~Shift_JIS~lead:#shift_jis-lead
~Shift_JISå¾©å·å™¨:#shift_jis-decoder
~Shift_JISç¬¦å·åŒ–å™¨:#shift_jis-encoder

~EUC-KR~lead:#euc-kr-lead
~EUC-KRå¾©å·å™¨:#euc-kr-decoder
~EUC-KRç¬¦å·åŒ–å™¨:#euc-kr-encoder

~UTF-16~lead~byte:#utf-16-lead-byte
~UTF-16é ­éƒ¨~surrogate:#utf-16-lead-surrogate
~UTF-16å¾©å·å™¨:#utf-16-decoder
~UTF-16LEå¾©å·å™¨:#utf-16le-decoder
~UTF-16BEå¾©å·å™¨:#utf-16be-decoder
~UTF-16BEå¾©å·å™¨~ç”¨ã‹:#utf-16be-decoder-flag

~x-user-definedå¾©å·å™¨:#x-user-defined-decoder
~x-user-definedç¬¦å·åŒ–å™¨:#x-user-defined-encoder

	~byteåˆ—ã«å¤‰æ›-:#convert-a-code-unit-to-bytes

indexes.json:https://encoding.spec.whatwg.org/indexes.json

	â—ç”¨èªï¼ˆå¤–éƒ¨

å½¢å¼å¤‰æ›:~STREAMS#generictransformstream-transform
TS.è¨­å®šã—ã¦ãŠã:~STREAMS#transformstream-set-up
	V.å½¢å¼å¤‰æ›~algo:~STREAMS#transformstream-set-up-transformalgorithm
	V.æ›¸å‡ºn~algo:~STREAMS#transformstream-set-up-flushalgorithm
TS.~chunkã‚’~enqueueã™ã‚‹:~STREAMS#transformstream-enqueue

~list:~INFRA#list
~item:~INFRA#list-item
ä»˜åŠ ã™ã‚‹:~INFRA#list-append
ç©º:~INFRA#list-is-empty
æŒ¿å…¥ã™ã‚‹:~INFRA#list-insert
é™¤å»ã™ã‚‹:~INFRA#list-remove
~size:~INFRA#list-size
~queue:~INFRA#queue
ç¯„å›²:~INFRA#the-range

~ASCII~byte:~INFRA#ascii-byte
~byte:~INFRA#byte
~byteåˆ—:~INFRA#byte-sequence
byte.é•·ã•:~INFRA#byte-sequence-length
æ–‡å­—åˆ—:~INFRA#string
~scalarå€¤~æ–‡å­—åˆ—:~INFRA#scalar-value-string
~cu:~INFRA#code-unit
~cp:~INFRA#code-point
cp.å€¤:~INFRA#code-point-value
~scalarå€¤:~INFRA#scalar-value
~surrogate:~INFRA#surrogate
é ­éƒ¨~surrogate:~INFRA#leading-surrogate
å°¾éƒ¨~surrogate:~INFRA#trailing-surrogate
~ASCII~cp:~INFRA#ascii-code-point
	~ASCIIç©ºç™½:~INFRA#ascii-whitespace
~ASCIIæ•°å­—:~INFRA#ascii-digit
~ASCIIå¤§å°ç„¡è¦–:~INFRA#ascii-case-insensitive
~ASCIIå°æ–‡å­—~åŒ–:~INFRA#ascii-lowercase
~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹:~INFRA#ascii-lowercase
å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã:~INFRA#strip-leading-and-trailing-ascii-whitespace
byte.ã‹ã‚‰é–‹å§‹ã—ã¦:~INFRA#byte-sequence-starts-with

æ–°ãŸãª~obj:~WEBIDLjs#new
æŠ•å‡º-:~WEBIDL#dfn-throw
~IDLå€¤ã«å¤‰æ›ã™ã‚‹:~WEBIDLjs#dfn-convert-javascript-to-idl-value
ä¿æŒã•ã‚ŒãŸ~byteåˆ—ã®è¤‡è£½ã‚’å–å¾—ã™ã‚‹:~WEBIDLjs#dfn-get-buffer-source-copy
BS.~byteé•·ã•:~WEBIDLjs#buffersource-byte-length
é…åˆ—~buffer~viewã®ä¸­ã¸~byteåˆ—ã‚’æ›¸è¾¼ã‚€:~WEBIDLjs#arraybufferview-write
	:~WEBIDLjs#arraybufferview-write-startingoffset
~buffer~sourceã‚’ä½œæˆã™ã‚‹:~WEBIDLjs#_buffersource-create

~chunk:~STREAMS#chunk
å¯èª­~stream:~STREAMS#readable-stream
å¯æ›¸~stream:~STREAMS#writable-stream

ä¸¦åˆ—çš„:~HTMLINFRA#in-parallel
ç¬¦å·åŒ–æ³•ã‚’~sniffã™ã‚‹~algo:~HTMLparsing#encoding-sniffing-algorithm
~event~loop:~WAPI#event-loop
é–¢é€£ãª~realm:~WAPI#concept-relevant-realm

_acks1:#_acks1
_ipr1:#_ipr1

â—â—words_table1

bAND: <span class="op">&amp;</span> 
bOR: <span class="op">|</span> 
Lshift: <span class="op">&lt;&lt;</span>
Rshift: <span class="op">&gt;&gt;</span>

encoding0:encoding
UTF-8:<b class="ename">UTF-8</b> 
GBK:<b class="ename">GBK</b> 
gb18030:<b class="ename">gb18030</b> 
Big5:<b class="ename">Big5</b> 
EUC-JP:<b class="ename">EUC-JP</b> 
ISO-2022-JP:<b class="ename">ISO-2022-JP</b> 
Shift_JIS:<b class="ename">Shift_JIS</b> 
EUC-KR:<b class="ename">EUC-KR</b> 
jis0208:<b class="ename">jis0208</b> 
jis0212:<b class="ename">jis0212</b> 
replacement:<b class="ename">replacement</b> 
UTF-16BE:<b class="ename">UTF-16BE</b> 
UTF-16LE:<b class="ename">UTF-16LE</b> 
x-user-defined:<b class="ename">x-user-defined</b> 


â—â—words_table


	â—ä»•æ§˜
æ™®éçš„:universal:~
é•æ³•:illegal:~
è‡ªæ˜:trivial:~
ç¶²ç¾…çš„:exhaustive:~
ä¿å®ˆçš„:conservative:~
åˆæ³•:legitimate:~
ç§»è¡Œ-:move:~
å®Œå…¨ã•:completeness:~
	æ¨™æº–:Standard
	é–¢é€£ã—ãªã„:irrelevant
	çœç•¥æ™‚ã¯:optional
proprietary::::ãƒ—ãƒ­ãƒ—ãƒ©ã‚¤ã‚¨ã‚¿ãƒª
reverse-engineer:reverse engineer:::ãƒªãƒãƒ¼ã‚¹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢
ç°¡æ˜:clear:~
éš”ãŸã‚Š:gap:~
éå»:past:~
å‡¡ä¾‹:legend:~
ç‰¹è³ª:property:~
å›ºå®ˆ-:adhere:~
è­¦å‘Š:warning:~
æ’ä»–çš„:exclusive:~
åæŸ-:converge:~
ç©¶æ˜:investigation:~
æœ«ç«¯åˆ©ç”¨è€…:end user:~:::ã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶
æ‹¡æ•£-:spread:~
é€¸è„±-:deviate:~
ç”Ÿç”£å™¨:producer::~
æ¶ˆè²»å™¨:consumer::~
	ã€œã‚’åŒ…è£…ã™ã‚‹:wrapper
å‘¨çŸ¥ãª:knownãª:~
	-:known
å®¿é¡Œ:exercise:~
å¯¾å‡¦æ³•:workaround:~
ç¨€:rare:~
æ­£å½“:legitimate:~
æ„æ¬²çš„:eager:~
è¨ˆç”»:plan:~
è¨¼æ‹ :evidence:~
	~~ç¢ºãŸã‚‹è¨¼æ‹ ã¯ãªã:in the light of anecdotal evidence of the level of
è¡¨é¢çš„:superficial:~
ä»˜éš-:accompany:~

	æ¶ˆãˆå»ã‚‹:go away
	åŠ©åŠ›:help
	~~æ¨™æº–ã®:The
	~~è€ƒæ…®
	ä¸€å¼ã§:in combination with
	ã‚ˆã‚Š~~ä¸€èˆ¬çš„ã«ã¯:larger
	å‚™è€ƒ
	~~ååˆ†:fine
	åºƒã:widespread
	åº:Preface
	è¦ã€œ:ã€œ needed
	ä¸è¦:no need
	å¿…è¦:have to
	èª¬æ˜:Notes
	å¸¸ã«ã€œé™ã‚‰ãªã„:not always
	ã«ã‚‚ã‹ã‹ã‚ã‚‰ãš:nonetheless
	å¾Œã®:future
	~~ä¸æ­£ãª:bogus
	é–¢ã™ã‚‹:-
	~~ç¾åœ¨ã®å§¿:what it is today
	ä»•ç«‹ã¦ä¸Šã’:-
	é…å‚™-æ¸ˆã¿:deployed
	ä¾›ã™ã‚‹:-
	ä¿ƒã™
	åˆ©ç”¨ã•ã‚Œãªã„:unused
	ç”¨-æ³•ã®ä¸€ã¤:an approach one could take to use
	~~å¯¾å‡¦-:deal with
	~~å¯¾å‡¦:dealing with
	æº–ã˜ã‚‹:match
	çŸ¥ã‚‰ã‚Œ:knownï¼
		è¿½ã„æ˜“ã:easy to follow
	ç¤ºã•ã‚Œ:-
	å‘¼ã¶:-
	åŸ‹ã‚ã‚‹:-
	å¤‰ã‚ã£ã¦:change
	è¦‹ãˆãªã„:not see
	è¨˜ã•ã‚Œ
	è¨˜ã™
	ä¸€æ–¹ã§:whereas
	æ®‹ã—ã¦ãŠã:left as
	äº‹:fact
	ç–‘å•ãŒã‚ã‚‹:questionable
	åºƒã:broadly
	~~æ—:series
	ç‚ºã•ã‚Œ:made
	å¿…è¦æ€§:necessity
	ç–‘ã‚ã—ã„:doubtful
	ä¸»è¦ãª:major
	å«ã‚ã‚‹ï¼å«ã‚ã‚‹ã“ã¨:inclusion
	-:feature
	ã€œå‘¨ã‚Š:around
	ã‹ã¾ã‚ãªã„:free to
	ã•ã‚Œãªããªã‚‹:will prevent ã€œ from ever being
	ãªã‚‹ã¨è¦‹è¾¼ã¾ã‚Œã‚‹:will most likely
	ä½µç”¨ã—ãªã„:prevent the use of ã€œ in combination with
	å¿…ãšã€œã‚ˆã†ã«ã™ã‚‹~make~sure
	ã¨ã¯å¯¾ç…§çš„ã«:in contrast to
	è¡Œã†ã“ã¨ã€‚ï¼šought
	æ¥µã‚ã¦:extremeã«
	~~é™å®šçš„:niche
	ã€œä»–ã¨ç•°ãªã‚‹:differently
	-:side

	â—æœªåˆ†é¡
ä¸å¯åˆ†:atomic::~
é‡è¤‡-:duplicate:~
è«¸ã€…ã®:miscellaneousãª:~
éå¯¾ç§°:asymmetric:~

	ä¸€æ–°-:set anew
	è»¢æ›-:turn
	å¤±ã‚ã›:loss
	æˆ»ã™:back
	å‡ºãã‚ã—:hit
	~~ç©ºã„ãŸ:newly-vacated
	è¡¨ã™:signify
	å¯¾:combination
	è¢«ã›ãŸ:Layering ã€œ  on top
	åŠ ãˆ
	æŒ‡-:-
	å¾—ã‚‰ã‚Œ:-
	å¾—ã‚‹:-
	è¡Œã†
	æ¸›ã‚‰ã™:decrease
	å¢—ã‚„ã•:increase

	â—networkï¼ä¿å®‰
é˜²ã:preventã™ã‚‹:~
ç´°å·¥:craft:~
å–ªå¤±:loss:~
åˆæ„-:agree:~
ä¸ä¸€è‡´:mismatch:~
äº¤æ›:interchange:~
éš ã™:maskã™ã‚‹:~
éš ã—ã¦:maskã—ã¦:~
éš ã›ãª:maskã§ããª:~
	çªã:abuse
	è‡³ã‚‰ã›:resulting in
	~~æ¤œçŸ¥ã•ã‚Œãšã«:silent

	â—ç¬¦å·åŒ–æ³•
CJK:
ç§ç”¨é ˜åŸŸ:Private Use Area:~
	ç§ç”¨é ˜åŸŸã«å±ã™ã‚‹ã€œ:Private Use ã€œ
	é¦™æ¸¯å¢—è£œå­—ç¬¦é›†
	åŸºæœ¬å¤šè¨€èªé¢
	äº’æ›æ¼¢å­—

gb1:
gb2:
gb3:
jis0212:
jis0208:
	Roman
utf-16be:
UTF-16:
Hangul::::ãƒãƒ³ã‚°ãƒ«
surrogate::::ã‚µãƒ­ã‚²ãƒ¼ãƒˆ
cp:code point::ç¬¦å·ä½ç½®::ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
cu:code unit::ç¬¦å·å˜ä½::ã‚³ãƒ¼ãƒ‰ãƒ¦ãƒ‹ãƒƒãƒˆ
æœ‰ç¬¦å·:coded::~::æœ‰ã‚³ãƒ¼ãƒ‰
ç´¢å¼•:index::~::ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
BOM:
	~BOMã¯ç„¡è¦–ã™ã‚‹ã‹:ignore BOM
	~BOMã‚’è¦‹ã¤ã‘ãŸã‹:BOM seen
	BOM:byte order mark
BOMseen:BOM seen:BOM ç¢ºèªæ¸ˆã¿
ç°¡ä½“å­—:simplified::~
ç¹ä½“å­—:traditional::~
	ç¯„å›²~ç¾¤:ranges

åŠè§’:halfwidth::~
å…¨è§’:fullwidth::~
katakana::::ã‚«ã‚¿ã‚«ãƒŠ
Korean:
Japanese:
Chinese:
percent-::: %-

	ç©º~è¡Œl:empty string

	â—I/O queueï¼stream
å…¥å‡ºåŠ›:I/O:~
close:
streaming::::ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†
	~streamã—ã¦ã„ã‚‹:streaming
	~streamã—ã¦ã„ãªã„:immediate
å¯èª­:readable::~
	unread:ã€œã‚’å…ƒã«æˆ»ã™
å¯æ›¸:writable::~
æ›¸è¾¼ã¾ã‚Œ:writeã•ã‚Œ::æ›¸ãè¾¼ã¾ã‚Œ
æ›¸è¾¼ã‚€:writeã™ã‚‹::æ›¸ãè¾¼ã‚€
å½¢å¼å¤‰æ›:transform::~
EoQ:end-of-queue::queue çµ‚ç«¯:ã‚­ãƒ¥ãƒ¼çµ‚ç«¯
chunk::::ãƒãƒ£ãƒ³ã‚¯
enqueue::::ã‚¨ãƒ³ã‚­ãƒ¥ãƒ¼
coder:
æ›¸å‡ºã™:flushã™ã‚‹::æ›¸ãå‡ºã™
æ›¸å‡ºã•ãª:flushã—ãª::æ›¸ãå‡ºã•ãª
æ›¸å‡ºã—ã¦:flushã—ã¦::æ›¸ãå‡ºã—ã¦
æ›¸å‡ºn:flush::æ›¸ãå‡ºã—

ä¸€æƒ-:flush::~
	æ›¸å‡ºã•ãªã„ã‹:do not flush
è¦—è¦‹ã‚‹:peekã™ã‚‹:è¦—ãè¦‹ã‚‹
lead::é ­éƒ¨
trail::å°¾éƒ¨
é ­éƒ¨:leading:~
å°¾éƒ¨:trailing:~
é€£çµ-:concatenate:~
sniff:
ä¸å®š:indefinite:~

	å‰å¾Œã®:leading and trailing
	~buffer~source:bufferSource
	å‡ºåŠ›~chunk:outputChunk
	æ›¸å‡ºn~algo:flushAlgorithm
	å½¢å¼å¤‰æ›~algo:transformAlgorithm
	æ¥ã¦:coming
	æ¥ã‚‹:come
	å€‹æ•°:number

	â—ä¸€èˆ¬å‡¦ç†
ç¹°è¿”ã™:ç¹°ã‚Šè¿”ã™
æ¼”ç®—å¯¾è±¡:operand:~
ä¸‹é™:lower boundary::~
ä¸Šé™:upper boundary::~
ç¯„å›²æ¤œæŸ»:limit check:~
ç™ºã•ã‚Œ:emitã•ã‚Œ:~
ç™ºã™ã‚‹:emitã™ã‚‹:~
çµ¦-:supply:~

	æ ¼ç´ã—ç›´ã™:restore
	ã€œãŒè¿”ã™å€¤:ã€œã® return value
	ã‹ã‘ãŸ:run through
	ã€œã«ã‹ã‘ã‚‹:runs them through
	å‡ºç¾~byteæ•°:byte seen
	fatal:
	invocation
	æ¸¡ã™:pass
	é€šéã™ã‚‹:pass ã€œ through
	æŒ™ã’ã‚‰ã‚ŒãŸé †ã«:starting with the first one and going down
	æ¬¡ã®ã„ãšã‚Œã‹ãŒç”Ÿã˜ã‚‹ã¾ã§:whichever comes first
	~callå…ƒ:caller
	ä¿ã¤:keepã™ã‚‹:~
	ç”ŸããŸã¾ã¾:alive
	é †åºã‚’~~ä¿ã£ãŸã¾ã¾:in the given order

	â—ãƒ‡ãƒ¼ã‚¿å‹ï¼æ“ä½œï¼IDL
shift::::ã‚·ãƒ•ãƒˆ
å†…åŒ…-:include::~
å‰°ä½™:remainder:~
åŸºæ•°:base:~
å‰¥ã:stripã™ã‚‹:~
JSON:

	â—å¤‰æ•°
	%å…¥å‡ºåŠ›~queue:ioQueue
	%çµæœ:-
	%çµæœ:result
	%å€‹æ•°:number
	%çµæœ:readItems
	%~item:-
	%~item:item
	%æ¥é ­è¾:prefix
	%n:n
	%~itemåˆ—:items
	%æœ€å¾Œã®~index
	%å…¥åŠ›:input
	%é ­éƒ¨:leading
	%å°¾éƒ¨:trailing
	%~coder:encoderDecoder
	%å‡ºåŠ›:output
	%~mode:mode
	%æ•°å­—åˆ—:-
	%~label:label
	%ç¬¦å·åŒ–æ³•:encoding
	%è¡Œl~list:lines
	%ç´¢å¼•:index
	%ç´¢å¼•:-
	%~pointer:pointer
	%~cp:codePoint
	%~offset:offset
	%~cp~offset:-
	%~pointer~offset:-
	%~buffer:buffer
	%å¾©å·å™¨:-
	%å¾©å·å™¨:decoder
	%~errorã«ãªã‚Šå¾—ã‚‹:potentialError
	%~BOMç¬¦å·åŒ–æ³•:BOMEncoding
	%N:-
	%~BOM:BOM
	%è¡Œ
	%ç¬¦å·åŒ–å™¨:encoder
	%è¤‡è£½:-
	%read:read
	%written:written
	%åˆ©ç”¨ã•ã‚Œãªã„~queue:unused
	%å½¢å¼å¤‰æ›~stream:transformStream
	%~chunk:chunk
	%~buffer~source:bufferSource
	%å‡ºåŠ›~chunk:outputChunk
	%é ­éƒ¨~surrogate:leadingSurrogate
	%~byteåˆ—:chunk
	%~byteåˆ—:bytes
	%~byte:byte
	%temp
	%~lead:lead
	%~trail:trail
	%byte1
	%byte2
	%byte3:byte3
	%byte4:byte4
	%çŠ¶æ…‹:state
	%~lead~offset:lead offset
	%~cu:codeUnit
	%~utf-16be

	â—æœªåˆ†é¡
XML:
è¢«è¦†åŸŸ:coverage:~
è¦†ã†:coverã™ã‚‹:~
çµ„ç«‹ç›´ã›:reassembleã§ã:çµ„ã¿ç«‹ã¦ç›´ã›

	è¦–è¦š-åŒ–:visualize
	è¦–è¦š-åŒ–:visualization
	ç®—è¡“å¼:equation
	~~çµ±åˆ:Unified
	ä¼´ã‚ã‚Œãªã„:no ã€œ present
	å„ªå…ˆã•ã‚Œã‚‹:has priority overï¼more authoritative
	æ•°
	æ•°å€¤:number
	æ¡:digit
	ã€œé€²æ•°
	ã€œé€²è¡¨è¨˜
	~~å­¤ç«‹ã—ãŸ:lone
	ã€œç”¨:is ã€œ
	å…¥åŠ›~ç”¨ã®:input
	å‡ºåŠ›~ç”¨ã®:output

	æœ€åˆã®:first
	æœ€å¾Œã®:last
	å…¨ä½“çš„:overall
	ã€œã®å…¨ä½“ãŒ:in its entirety
	å·¦ä¸Šéš…:top left corner
	ã‚ã‚‹ç¨‹åº¦:some extent
	æœªæº€:less than
	ä»–
	åŒã˜:ï¼
	å‰è¿°ã®:aforementioned
	å¾Œç¶šã®:later
	æœ€çŸ­:shortest
	ã‹ã¤ã¦ã®:former
	å…¨ãã®:fully
	è‹¥å¹²ã®:slight
	ä¸‹ä½:least significant
	é€†æ–¹å‘:vice versa
	ä¸¦ã³ï¼åˆ—ï¼é€£åˆ—:sequence
	ç›´å¾Œã«ç¶šã:follows immediately
	æˆç«‹-:true
	3 ç¨®ã®:three
	è‡ªèº«:themselves
	ä¸€éƒ¨ã‚’æˆã™:part of
	2 ã¤ã®ã€œã«:between
	å”¯ä¸€ã®ï¼ã®ã¿:only
	è¤‡æ•°:ï¼
	2 å›:twice
	æ§˜ã€…ãª:various
	å³è¾º:-
	å·¦è¾º:-
	å„ç¨®:-
	å¤šãã®:a lot of
	é™¤ã:but
	è¶…ãˆ:over
	è¶…ãˆãªã„:less than or equal to
	éš›ã—ã¦:-
	ãã®ç¨®ã®:such
	ä»–æ‰€:the rest of
	é …ç›®æ•°:items
	æ¬¡é …:-
	æ‹¬å¼§å†…:-
	çœç•¥-:without
	è¡Œ:row
	å†’é ­:-
	ç›¸äº’ã«:go from ã€œ and back
	ä¸€ã¤:one ofï¼:-
	å°‘ã—:some
	æ¬¡å›:next
	ä¸€é€£ã®:ã€œs
	ä¸Š
	ä¸‹
	ã“ã‚Œä»¥ä¸Šã€œãªã„:To stop
	ãã‚Œä»¥ä¸Š:no more
	ä»¥ä¸‹:below
	ä¸­
	ä»¥å¤–:excluding
	ãã‚Œä»¥å¤–ã§ã¯:other than that
	ä½•ã‹:something
	ä½•ã‚‚:nothing
	å…¥ã‚‹:in
	åˆ—ç›®:-
	åˆ¥ã¨ã—ã¦
	å…ˆé ­:firstï¼
	å±ã™ã‚‹
	å¾Œè€…:-
	æ¬¡
	æ¬¡ã®
	ç¯€
	é¢
	è©²å½“-
	é–“
	å›
	å¾Œã¯
	æ™‚
	æœ€ã‚‚
	æœ«å°¾
	å€‹
	ä¸€æ–¹ã§
	ä¼´-
	å‚™ãˆã‚‹
	å³ï¼å·¦
	å¹´
	å¿œã˜ã¦
	æ–¹
	æ¸ˆã‚€
	æœ‰ç„¡:-
	ç„¡ã„
	ç‚¹ã§
	çš„
	ç•°ãªã‚‹
	æœ‰-
	ä¸‡
	çµ„
	è¡¨
	èª

	â—è¨³æ³¨
	ä¸‹è¨˜
	å…ˆã®
	ç·æ•°
	ä»£ç”¨å¯¾
	å«æ„-
	å›ºæœ‰ã®
	ä¿æŒ-
	å†…éƒ¨çŠ¶æ…‹
	åˆ¶ç´„-
	åŒºç‚¹ç•ªå·
	æ•°å€¤ã¨ã—ã¦
	æ•°å­—åˆ—
	è­˜åˆ¥å­
	æ—¥ä»˜
	æ™‚ç³»åˆ—çš„
	æ§‹é€ 
	æ©Ÿèƒ½
	å¤–å­—
	è§’æ‹¬å¼§
	è¨˜å·
	è¨˜æ³•
	è¨˜è¿°
	è¨³
	è¨³è€…
	è©¦ã™
	é›†åˆ
	é™çš„
	å¤‰æ•°
	è¿½åŠ 
	æ„å‘³
	æ„å‘³-
	è¡¨è¨˜è¦ç´„
	ç”¨ã„


â—â—ref_normative

[INFRA]
    Anne van Kesteren; Domenic Denicola. ï¼œInfra Standardï¼. Living Standard. URL: https://infra.spec.whatwg.org/
[STREAMS]
    Adam Rice; et al. ï¼œStreams Standardï¼. Living Standard. URL: https://streams.spec.whatwg.org/
[UNICODE]
    ï¼œThe Unicode Standardï¼. URL: https://www.unicode.org/versions/latest/
[WEBIDL]
    Edgar Chen; Timothy Gu. ï¼œWeb IDL Standardï¼. Living Standard. URL: https://webidl.spec.whatwg.org/

â—â—ref_informative

[HTML]
    Anne van Kesteren; et al. ï¼œHTML Standardï¼. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[URL]
    Anne van Kesteren. ï¼œURL Standardï¼. Living Standard. URL: https://url.spec.whatwg.org/
[XML]
    Tim Bray; et al. ï¼œExtensible Markup Language (XML) 1.0 (Fifth Edition)ï¼. 26 November 2008. REC. URL: https://www.w3.org/TR/xml/


â—â—trans_metadata
<p>
~THIS_PAGEã¯ã€~WHATWGã«ã‚ˆã‚‹
<a href="https://encoding.spec.whatwg.org/">Encoding Standard</a>
ã‚’æ—¥æœ¬èªã«ç¿»è¨³ã—ãŸã‚‚ã®ã§ã™ã€‚
~PUB
</p>


â—â—spec_metadata

Participate:
	<a href="https://github.com/whatwg/encoding">GitHub whatwg/encoding</a> (<a href="https://github.com/whatwg/encoding/issues/new/choose">new issue</a>, <a href="https://github.com/whatwg/encoding/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	https://github.com/whatwg/encoding/commits
	<a href="https://encoding.spec.whatwg.org/commit-snapshots/36fb4e7a5582873b3700a5a72912a8e91163a092/">Snapshot as of this commit</a>
	<a href="https://twitter.com/encodings">@encodings</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/encoding">web-platform-tests encoding/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/encoding">ongoing work</a>)

å„å›½èªç¿»è¨³ï¼ˆéè¦ç¯„çš„ï¼‰
	æ—¥æœ¬èªï¼ˆã“ã®ãƒšãƒ¼ã‚¸ï¼‰

</script>

</head>
<body>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxwYXRoIGQ9Im01MCwwbDUwLDUwLTUwLDUwLTUwLTUwIiBmaWxsPSIjM2M3OTBhIi8+DQo8cGF0aCBkPSJtMzgsNDBjMC0xMiwyNC0xNSwyMy0yYzAsOS0xNiwxMy0xNiwyM3Y3aDEwdi00YzAtOSwxNy0xMiwxNy0yN2MtMi0yMi00NS0yMi00NSwzem03LDMyaDEwdjEwaC0xMCIgZmlsbD0iI2ZmZiIvPg0KPC9zdmc+DQo="
></a>

	<hgroup>
<h1>Encoding â€” ç¬¦å·åŒ–æ³•</h1>
	</hgroup>

</header>

<main id="MAIN" hidden>
	<section id="preface">

<h2 title="Preface">1. åº</h2>

<p>
~UTF-8ç¬¦å·åŒ–æ³•ã¯ã€
æ™®éçš„ãªæœ‰ç¬¦å·~æ–‡å­—~é›†åˆã§ã‚ã‚‹~Unicodeã®äº¤æ›ã«æœ€ã‚‚é©åˆ‡ãªç¬¦å·åŒ–æ³•ã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ï¼Œã“ã®ä»•æ§˜ã¯ã€
æ–°ãŸãªï¼»
~protocol, å½¢å¼
ï¼½ãŠã‚ˆã³ï¼»
æ–°ãŸãªæ–‡è„ˆã«ãŠã„ã¦é…å‚™ã•ã‚Œã‚‹æ—¢å­˜ã®å½¢å¼
ï¼½ã«å¯¾ã—ï¼Œ~UTF-8ç¬¦å·åŒ–æ³•ã‚’è¦æ±‚ã™ã‚‹
ï¼ˆã¾ãŸï¼Œãã‚Œã‚’å®šç¾©ã™ã‚‹ï¼‰ã€‚
â—
The UTF-8 encoding is the most appropriate encoding for interchange of Unicode, the universal coded character set. Therefore for new protocols and formats, as well as existing formats deployed in new contexts, this specification requires (and defines) the UTF-8 encoding.
</p>

<p>
ç¬¦å·åŒ–æ³•ã«ã¯ï¼Œä»–ã®ã‚‚ã®ï¼ˆæ—§æ¥ã®ç¬¦å·åŒ–æ³•ï¼‰ã‚‚ã‚ã‚Šã€
éå»ã«ã‚ã‚‹ç¨‹åº¦ã¾ã§ã¯å®šç¾©ã•ã‚ŒãŸãŒï¼Œ
~UAé–“ã§å¸¸ã«åŒã˜ä»•æ–¹ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã¨ã¯é™ã‚‰ãªã„ã€‚
ã¾ãŸã€
å¸¸ã«åŒã˜~labelã‚’åˆ©ç”¨ã™ã‚‹ã¨ã¯é™ã‚‰ãšï¼Œï¼»
ç¬¦å·åŒ–æ³•ã®ä¸­ã®æœªå®šç¾©ãªåŒºç”», ã‚ã‚‹ã„ã¯ ã‹ã¤ã¦ã®~proprietaryãªåŒºç”»ã¸ã®~~å¯¾å‡¦
ï¼½ã‚‚ç›¸é•ã™ã‚‹ã“ã¨ãŒå¤šã„ã€‚
ã“ã®ä»•æ§˜ã¯ã€ï¼»
æ–°ãŸãªå®Ÿè£…ãŒç¬¦å·åŒ–æ³•~å®Ÿè£…ã‚’~reverse-engineerã›ãšã«æ¸ˆã‚€
ï¼½ã‚ˆã†ï¼ŒãŠã‚ˆã³ï¼»
æ—¢å­˜ã®~UAãŒä¸€ã¤ã«åæŸã§ãã‚‹
ï¼½ã‚ˆã†ï¼Œã“ã‚Œã‚‰ã®éš”ãŸã‚Šã‚’åŸ‹ã‚ã‚‹ã“ã¨ã«å–çµ„ã‚€ã€‚
â—
The other (legacy) encodings have been defined to some extent in the past. However, user agents have not always implemented them in the same way, have not always used the same labels, and often differ in dealing with undefined and former proprietary areas of encodings. This specification addresses those gaps so that new user agents do not have to reverse engineer encoding implementations and existing user agents can converge.
</p>

<p>
ç‰¹ã«ï¼Œã“ã®ä»•æ§˜ã¯ã€
ãã‚Œã‚‰ã™ã¹ã¦ã®ç¬¦å·åŒ–æ³•ã‚’ï¼Œå„~ç¬¦å·åŒ–æ³•ã®ï¼»
`~byteåˆ—$ã¨`~scalarå€¤$åˆ—ã‚’ç›¸äº’ã«å¤‰æ›ã™ã‚‹~algo,
æ­£æº–çš„ãªåå‰,
è­˜åˆ¥-ç”¨ã®`~label$ãŸã¡
ï¼½ã¨ã¨ã‚‚ã«å®šç¾©ã™ã‚‹ã€‚
ã¾ãŸã€
ç¬¦å·åŒ–æ³•ã‚’æˆã™å„ç¨®~algoã®ã†ã¡ä¸€éƒ¨ã‚’~JSã«å…¬é–‹ã™ã‚‹~APIã‚‚å®šç¾©ã™ã‚‹ã€‚
â—
In particular, this specification defines all those encodings, their algorithms to go from bytes to scalar values and back, and their canonical names and identifying labels. This specification also defines an API to expose part of the encoding algorithms to JavaScript.
</p>

<p>
~UAã¯ã€
ã™ã§ã«
`IANA Character Setsï¼ ~IANA-a/character-sets/character-sets.xhtml$en
~registryã«æŒ™ã’ã‚‰ã‚Œã¦ã„ã‚‹~labelã‹ã‚‰ã‚‚æœ‰æ„ã«é€¸è„±ã—ã¦ã„ã‚‹ã€‚
æ—§æ¥ã®ç¬¦å·åŒ–æ³•ã‚’ ã“ã‚Œä»¥ä¸Š~æ‹¡æ•£ã•ã›ãªã„ãŸã‚ã€
ã“ã®ä»•æ§˜ã¯å‰è¿°ã®è©³ç´°~ã«ã¤ã„ã¦ç¶²ç¾…çš„ã§ã‚ã‚Šï¼Œ
~registryã¯ã‚‚ã†ä¸è¦ã§ã‚ã‚‹ã€‚
ç‰¹ã«ï¼Œã“ã®ä»•æ§˜ã¯ã€
ç¬¦å·åŒ–æ³•ã‚’æ‹¡å¼µã™ã‚‹ãŸã‚ã®ä»•çµ„ã¿ã¯ä¾›ã•ãªã„ã€‚
â—
User agents have also significantly deviated from the labels listed in the IANA Character Sets registry. To stop spreading legacy encodings further, this specification is exhaustive about the aforementioned details and therefore has no need for the registry. In particular, this specification does not provide a mechanism for extending any aspect of encodings.
</p>

	</section>
	<section id="security-background">

<h2 title="Security background">2. ~securityã«é–¢ã™ã‚‹èƒŒæ™¯0</h2>

<p>
ç¬¦å·åŒ–æ³•ã«ã¯ã€
ã„ãã¤ã‹ï¼Œ~securityã®èª²é¡ŒãŒã‚ã‚‹
â€” ç”Ÿç”£å™¨ã¨æ¶ˆè²»å™¨ã®é–“ã§ï¼Œï¼»
åˆ©ç”¨-ä¸­ã«ã‚ã‚‹ç¬¦å·åŒ–æ³•, ã‚ã‚‹ã„ã¯æ‰€ä¸ã®ç¬¦å·åŒ–æ³•ã®å®Ÿè£…-æ³•
ï¼½ã«ã¤ã„ã¦åˆæ„ã•ã‚Œã¦ãªã„ã¨ãã«ã€‚
ä¾‹ãˆã°ã€
2011 å¹´ã«ã¯ï¼Œæ¬¡ã®ã‚ˆã†ãªæ”»æ’ƒãŒå ±å‘Šã•ã‚ŒãŸï¼š
ãã“ã§ã¯ã€ï¼»
æ”»æ’ƒè€…ãŒä½•ã‚‰ã‹ã®~fieldã‚’åˆ¶å¾¡ã—å¾—ã‚‹ã‚ˆã†ãªï¼Œ~JSONè³‡æº
ï¼½å†…ã§ï¼Œ
`Shift_JIS$n ã®~lead~byte `82^X ãŒ~trail~byte `22^X ã‚’ â€œéš ã™â€ ãŸã‚ã«åˆ©ç”¨ã•ã‚ŒãŸã€‚
ç”Ÿç”£å™¨ã‹ã‚‰ã¯ï¼Œã“ã‚ŒãŒé•æ³•ãª~byteå¯¾ã§ã‚ã£ã¦ã‚‚å•é¡ŒãŒè¦‹ãˆãªã„ä¸€æ–¹ã§ã€
æ¶ˆè²»å™¨ã¯ï¼Œã“ã®~byteå¯¾ã‚’ 1 å€‹ã® `FFFD^U `ï¿½^smb ã¨ã—ã¦å¾©å·ã™ã‚‹~~çµæœã€
å…¨ä½“çš„ãªè§£é‡ˆãŒå¤‰ã‚ã£ã¦ã—ã¾ã†
â€” `0022^U `"^smb ã¯é‡è¦ãªåŒºåˆ‡å­ãªã®ã§ã€‚
ï¼»
`~scalarå€¤$ã«å¯¾ã—è¤‡æ•°~byteã‚’åˆ©ç”¨ã™ã‚‹ç¬¦å·åŒ–æ³•
ï¼½ã®å¾©å·å™¨ã«ã¯ã€
ä»Šã‚„ï¼Œé•æ³•ãª~byteå¯¾ã®äº‹ä¾‹ã§ã¯ï¼»
ç¯„å›² `0000^U ã€œ `007F^U ã«å…¥ã‚‹~scalarå€¤
ï¼½ã‚’ â€œéš ã›ãªã„â€ ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒè¦æ±‚ã•ã‚Œã‚‹
â€” å‰è¿°ã®~byteå¯¾ã«å¯¾ã—ã¦ã¯ã€
å‡ºåŠ›ãŒï¼»
`FFFD^U `0022^U
ï¼½ã«ãªã‚‹ã‚ˆã†
ï¼ˆã‚ã„ã«ãï¼Œã“ã‚Œã«ã¯ä¾‹å¤–ãŒã‚ã‚Šã€
`~gb18030å¾©å·å™¨$ã¯ï¼Œ`~EoQ$ã«ã‚ã‚‹ ãã®ã‚ˆã†ãª~byte 1 å€‹ã‚’ â€œéš ã—ã¦â€ ã—ã¾ã†ï¼‰ã€‚
â—
There is a set of encoding security issues when the producer and consumer do not agree on the encoding in use, or on the way a given encoding is to be implemented. For instance, an attack was reported in 2011 where a Shift_JIS lead byte 0x82 was used to â€œmaskâ€ a 0x22 trail byte in a JSON resource of which an attacker could control some field. The producer did not see the problem even though this is an illegal byte combination. The consumer decoded it as a single U+FFFD (ï¿½) and therefore changed the overall interpretation as U+0022 (") is an important delimiter. Decoders of encodings that use multiple bytes for scalar values now require that in case of an illegal byte combination, a scalar value in the range U+0000 to U+007F, inclusive, cannot be â€œmaskedâ€. For the aforementioned sequence the output would be U+FFFD U+0022. (As an unfortunate exception to this, the gb18030 decoder will â€œmaskâ€ up to one such byte at end-of-queue.)
</p>

<p>
ã“ã‚Œã¯ã€
ã‚ˆã‚Š~~ä¸€èˆ¬çš„ã«ã¯ï¼Œï¼»
~lead~byteãŒä¼´ã‚ã‚Œãªã„ã¨ãã«ï¼Œ`~ASCII~byte$ã‚’`~ASCII~cp$ã§ãªã„ä½•ã‹ã«å¯¾å¿œä»˜ã‘ã‚‹
ï¼½ã‚ˆã†ãªç¬¦å·åŒ–æ³•ã«ãŠã‘ã‚‹èª²é¡Œã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚‰ã¯ï¼Œ â€œ~ASCIIäº’æ›ã§ãªã„â€ ç¬¦å·åŒ–æ³•ã§ã‚ã‚Šã€
ã‚ã„ã«ãï¼Œé…å‚™-æ¸ˆã¿ãªå†…å®¹ã«å› ã‚Šè¦æ±‚ã•ã‚Œã‚‹ãŒã€ï¼»
`ISO-2022-JP$n, `UTF-16BE/LE$n
ï¼½ä»¥å¤–ã®ã‚‚ã®ã¯ï¼Œ~supportã•ã‚Œãªã„ã€‚
ï¼ˆä»–ã® ãã®ã‚ˆã†ãªç¬¦å·åŒ–æ³•ã«ã¤ã„ã¦ã‚‚ã€
ãã®~labelã‚’ï¼»
æœªçŸ¥ãªç¬¦å·åŒ–æ³•ã¸~fallbackã™ã‚‹ã“ã¨ãªãï¼Œ
`replacement$n ç¬¦å·åŒ–æ³•ã«å¯¾å¿œä»˜ã‘ã‚Œã‚‹ã‹ã©ã†ã‹
ï¼½ã®ç©¶æ˜ãŒ`é€²è¡Œä¸­ã«ã‚ã‚‹ï¼ https://github.com/whatwg/encoding/issues/8$ã€‚ï¼‰
æ”»æ’ƒã®ä¾‹ã¨ã—ã¦ã€
æ³¨æ„æ·±ãç´°å·¥ã•ã‚ŒãŸå†…å®¹ã‚’è³‡æºã®ä¸­ã¸æ³¨å…¥ã—ã¦ï¼Œåˆ©ç”¨è€…ã«ç¬¦å·åŒ–æ³•ã‚’ä¸Šæ›¸ãã™ã‚‹ã‚ˆã†ä¿ƒã™~~çµæœã€
ä¾‹ãˆã°ï¼Œ~scriptã®å®Ÿè¡Œã¸è‡³ã‚‰ã™ã‚‚ã®ãŒã‚ã‚‹ã€‚
â—
This is a larger issue for encodings that map anything that is an ASCII byte to something that is not an ASCII code point, when there is no lead byte present. These are â€œASCII-incompatibleâ€ encodings and other than ISO-2022-JP and UTF-16BE/LE, which are unfortunately required due to deployed content, they are not supported. (Investigation is ongoing whether more labels of other such encodings can be mapped to the replacement encoding, rather than the unknown encoding fallback.) An example attack is injecting carefully crafted content into a resource and then encouraging the user to override the encoding, resulting in, e.g., script execution.
</p>

<p>
ï¼»
~HTMLã‚„~HTMLã®~formç‰¹èƒ½
ï¼½ã«ãŠã„ã¦è¦‹å‡ºã•ã‚Œã‚‹~URLã«åˆ©ç”¨ã•ã‚Œã‚‹ç¬¦å·åŒ–å™¨ã‚‚ã€
ãã®ç¬¦å·åŒ–æ³•ã«ã‚ˆã‚Šè¡¨ç¾ã§ããªã„~scalarå€¤ãŒã‚ã‚‹å ´åˆã«ã¯ï¼Œè‹¥å¹²ã®æƒ…å ±~å–ªå¤±ã«è‡³ã‚‰ã›å¾—ã‚‹ã€‚
ä¾‹ãˆã°ï¼Œè³‡æºãŒ `windows-1252$n ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ã¨ãã€
~serverã¯ï¼Œæœ«ç«¯åˆ©ç”¨è€…ãŒ~formã«æ‰‹å…¥åŠ›ã—ãŸ "ğŸ’©" ã¨ "&amp;#128169;" ã¨ã‚’åˆ¤åˆ¥ã§ããªããªã‚‹ã€‚
â—
Encoders used by URLs found in HTML and HTMLâ€™s form feature can also result in slight information loss when an encoding is used that cannot represent all scalar values. E.g., when a resource uses the windows-1252 encoding a server will not be able to distinguish between an end user entering â€œğŸ’©â€ and â€œ&amp;#128169;â€ into a form.
</p>

<p>
ã“ã“ã«è¦æ—¨ã—ãŸå•é¡Œã¯ã€
~UTF-8ã‚’æ’ä»–çš„ã«åˆ©ç”¨ã—ã¦ã„ã‚‹ã¨ãã¯ï¼Œæ¶ˆãˆå»ã‚‹ã€‚
ãã‚ŒãŒã€
ä»Šã‚„ï¼Œã™ã¹ã¦ã«å¯¾ã—~UTF-8ç¬¦å·åŒ–æ³•ãŒç¾©å‹™ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ç†ç”±ã®ä¸€ã¤ã§ã‚ã‚‹ã€‚
â—
The problems outlined here go away when exclusively using UTF-8, which is one of the many reasons that is now the mandatory encoding for all things.
</p>

<p class="note">æ³¨è¨˜ï¼š
`Â§ ~browser~UIï¼ #browser-ui$
ã‚‚è¦‹ã‚ˆã€‚
â—
See also the Browser UI chapter.
</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">3. å„ç¨®ç”¨èª</h2>

<p>
ã“ã®ä»•æ§˜ã¯ã€
`Infra Standard^cite `INFRA$r ã«ä¾å­˜ã™ã‚‹ã€‚
â—
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
16 é€²æ•°ã«ã¯ "0x" ãŒæ¥é ­ã•ã‚Œã‚‹ã€‚
â—
Hexadecimal numbers are prefixed with "0x".
</p>

<div class="p">
<p>
ç®—è¡“å¼ã®ä¸­ã®ã™ã¹ã¦ã®æ•°å€¤ã¯æ•´æ•°ã§ã‚ã‚Šã€
å„ç¨®~æ¼”ç®—ã¯ï¼Œæ¬¡ã«æŒ™ã’ã‚‹è¨˜å·ã§è¡¨ç¾ã•ã‚Œã‚‹ï¼š
</p>

<table><thead>
<tr><th>è¨˜å·
<th>æ„å‘³
<tbody>

<tr><th>~PLUS
<td>åŠ ç®—

<tr><th>~MINUS
<td>æ¸›ç®—

<tr><th>~INCBY
<td>å·¦è¾º~å€¤ã«å¯¾ã™ã‚‹å³è¾º~å€¤ã«ã‚ˆã‚‹åŠ ç®—ã€ã“ã®è¨³ã«ã‚ˆã‚‹è¿½åŠ ã€‘

<tr><th>~DECBY
<td>å·¦è¾º~å€¤ã«å¯¾ã™ã‚‹å³è¾º~å€¤ã«ã‚ˆã‚‹æ¸›ç®—ã€ã“ã®è¨³ã«ã‚ˆã‚‹è¿½åŠ ã€‘

<tr><th>~MUL
<td>ä¹—ç®—

<tr><th>~DIV
<td>æ•´æ•°ã®é™¤ç®—ã€å°æ•°åˆ‡ã‚Šæ¨ã¦ã€‘

<tr><th>~MOD
<td>æ•´æ•°ã®é™¤ç®—ã®å‰°ä½™ï¼ˆ modulo ï¼‰ã€å¸¸ã« 0 ä»¥ä¸Šï¼ˆè² ãªæ•°ã«ã¯æ¼”ç®—ã•ã‚Œå¾—ãªã„ï¼‰ã€‘

<tr><th>~Lshift
<td>è«–ç†-å·¦~shift

<tr><th>~Rshift
<td>è«–ç†-å³~shift

<tr><th>~bAND
<td>~bit AND

<tr><th>~bOR
<td>~bit OR
</table>

â—
In equations, all numbers are integers, addition is represented by "+", subtraction by "âˆ’", multiplication by "Ã—", integer division by "/" (returns the quotient), modulo by "%" (returns the remainder of an integer division), logical left shifts by "&lt;&lt;", logical right shifts by "&gt;&gt;", bitwise AND by "&amp;", and bitwise OR by "|".
</div>

<p>
è«–ç†-å³~shiftã®æ¼”ç®—å¯¾è±¡ã®ç²¾åº¦ã¯ã€
å°‘ãªãã¨ã‚‚ 21 ~bitä»¥ä¸Šã«ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
For logical right shifts operands must have at least twenty-one bits precision.
</p>

<hr>

<p>
`å…¥å‡ºåŠ›~queue@
ï¼ˆ `I/O queue^en ï¼‰ã¯ã€
ç‰¹å®š0ã®å‹ï¼ˆ `~byte$, `~scalarå€¤$, `~cu$ ãªã©ï¼‰ã®`~item$ãŸã¡ãŒæˆã™`~list$ã§ã‚ã‚‹ã€‚
~itemå‹ã‚‚å«ã‚ã¦æŒ‡å®šã™ã‚‹ã¨ãã¯ã€
â€œ`å…¥å‡ºåŠ›~queue$`~byte^tAâ€ ç­‰ã€…ã¨è¨˜ã•ã‚Œã‚‹â€ ã€‚
ã€â€ ã“ã®è¡¨è¨˜è¦ç´„ã¯ã€ã“ã®è¨³ã«ç‰¹æœ‰ã€‚ã€‘
â—
An I/O queue is a type of list with items of a particular type (i.e., bytes or scalar values).ï¼¼
</p>

<p>
`å…¥å‡ºåŠ›~queue$ã¯ã€
ç‰¹åˆ¥ãª`~item$ã¨ã—ã¦
`~EoQ@
ï¼ˆ `end-of-queue^en ï¼‰ã‚‚å«ã¿å¾—ã‚‹
â€” ãã‚Œã¯ã€
å½“ã®~queueå†…ã«ã¯ï¼Œãã‚Œã‚ˆã‚Šå¾Œã«`~item$ã¯ç„¡ã„ã“ã¨ã‚’å¾´ã™ã€‚
ã€`~EoQ$ã®å‹ã¯ã€å½¢å¼çš„ã«ï¼Œãã‚ŒãŒå±ã™ã‚‹`å…¥å‡ºåŠ›~queue$ã®~itemå‹ã¨è¦‹ãªã•ã‚Œã‚‹ã€‚ã€‘
â—
End-of-queue is a special item that can be present in I/O queues of any type and it signifies that there are no more items in the queue.
</p>

<div class="note">
<p>æ³¨è¨˜ï¼š
`å…¥å‡ºåŠ›~queue$ã¯ã€
2 ã¤ã®ä»•æ–¹
â€” â€œ~streamã—ã¦ã„ã‚‹â€ ~modeï¼Œã—ã¦ã„ãªã„~mode â€”
ã§åˆ©ç”¨ã•ã‚Œã€
é †ã«ï¼»
~networkã‹ã‚‰æ¥ã¦ã„ã‚‹~data,
~memoryå†…ã«æ ¼ç´ã•ã‚ŒãŸå…¥å‡ºåŠ›~data
ï¼½ã‚’è¡¨ç¾ã™ã‚‹ã€‚
~streamã—ã¦ã„ãªã„~queueå†…ã«ã¯ã€
æœ€å¾Œã®~itemã¨ã—ã¦ã€å¸¸ã«ã€‘`~EoQ$ãŒåœ¨ã‚‹ã€‚
ä¸€æ–¹ã§ï¼Œ~streamã—ã¦ã„ã‚‹`å…¥å‡ºåŠ›~queue$ã¯ï¼š
â—
There are two ways to use an I/O queue: in immediate mode, to represent I/O data stored in memory, and in streaming mode, to represent data coming in from the network. Immediate queues have end-of-queue as their last item, whereas streaming queuesï¼¼
</p>
<ul>
	<li>
`~EoQ$ã¯ç„¡ã„ã“ã¨ã‚‚ã‚ã‚Šã€ï¼»
`å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹$ï¼
`å…¥å‡ºåŠ›~queueã‹ã‚‰~itemåˆ—ã‚’èª­å–ã‚‹$
ï¼½æ¼”ç®—ã¯ï¼Œ
ã€ä½•ã‚‰ã‹ã®~itemãŒå¯ç”¨ã«ãªã‚‹ã¾ã§ã€‘é˜»ã¾ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
â—
need not have it, and so their read operation might block.
</li>
	<li>
æ¬¡ã®é †ã«æ¼”ç®—ã•ã‚Œã‚‹ã‚‚ã®ã¨æœŸå¾…ã•ã‚Œã‚‹
â‡’ï¼ƒ
ç©ºã¨ã—ã¦ä½œæˆã•ã‚Œã‚‹,
~networkã‹ã‚‰~dataãŒæ¥ã‚‹ã«ä¼´ã„ï¼Œæ–°ãŸãª`~item$ãŒ`~push$ioQã•ã‚Œã‚‹,
ä¸‹å±¤ã®~network~streamãŒ~closeã•ã‚Œã‚‹ã¨ãï¼Œ`~EoQ$ãŒ`~push$ioQã•ã‚Œã‚‹
â—
It is expected that streaming I/O queues will be created empty, and that new items will be pushed to it as data comes in from the network. When the underlying network stream closes, an end-of-queue item is to be pushed into the queue.
</li>
	<li>
ãã“ã‹ã‚‰èª­å–ã‚‹ã¨ãã¯ï¼Œé˜»ã¾ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã€
`~event~loop$ã‹ã‚‰ã¯åˆ©ç”¨ã•ã‚Œãšï¼Œä»£ã‚ã‚Šã«`ä¸¦åˆ—çš„$ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
Since reading from a streaming I/O queue might block, streaming I/O queues are not to be used from an event loop. They are to be used in parallel instead.
</li>
</ul>
</div>

<div class="algo">
<p>
`å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$ %å…¥å‡ºåŠ›~queue )
ã«å¯¾ã—ï¼š
â—
To read an item from an I/O queue ioQueue, run these steps:
</p>
<ol>
	<li>
~IFï¼»
%å…¥å‡ºåŠ›~queue ã¯`ç©º$ã§ã‚ã‚‹
ï¼½
â‡’
æ¬¡ãŒæº€ãŸã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã™ã‚‹
â‡’
%å…¥å‡ºåŠ›~queue ã®`~size$ ~GTE 1
â—
If ioQueue is empty, then wait until its size is at least 1.
</li>
	<li>
%çµæœ ~LET %å…¥å‡ºåŠ›~queue[ 0 ]
â—
â†“</li>
	<li>
~IFï¼»
%çµæœ ~NEQ `~EoQ$
ï¼½
â‡’
%å…¥å‡ºåŠ›~queue ã‹ã‚‰æœ€åˆã®~itemã‚’`é™¤å»ã™ã‚‹$
â—
If ioQueue[0] is end-of-queue, then return end-of-queue.
â—
Remove ioQueue[0] and return it.
</li>
	<li>
~RET %çµæœ
â—
â†‘</li>
</ol>
</div>

<div class="algo">
<p>
`å…¥å‡ºåŠ›~queueã‹ã‚‰~itemåˆ—ã‚’èª­å–ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$ %å…¥å‡ºåŠ›~queue, %å€‹æ•° )
ã«å¯¾ã—ï¼š
â—
To read a number number of items from ioQueue, run these steps:
</p>
<ol>
	<li>
~Assertï¼šï¼»
%å€‹æ•° ã¯è² ã§ãªã„æ•´æ•°ã§ã‚ã‚‹
ï¼½~ORï¼»
%å€‹æ•° ~EQ `ä¸å®š^i
ï¼½
â—
â†‘</li>
	<li>
%çµæœ ~LET Â« Â»
â—
Let readItems be Â« Â».
</li>
	<li>
<p>
~WHILEï¼»
%çµæœ ã®`~size$ ~NEQ %å€‹æ•°
ï¼½ï¼š
</p>
		<ol>
			<li>
%~item ~LET `å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹$( %å…¥å‡ºåŠ›~queue )
</li>
			<li>
~IFï¼»
%~item ~EQ `~EoQ$
ï¼½
â‡’
~BREAK
</li>
			<li>
%çµæœ ã« %~item ã‚’`ä»˜åŠ ã™ã‚‹$
</li>
		</ol>
â—
Perform the following step number times:
â€¢ Append to readItems the result of reading an item from ioQueue.
â—
Remove end-of-queue from readItems.
</li>
	<li>
~RET %çµæœ
â—
Return readItems.
</li>
</ol>
</div>

<p class="trans-note">ã€
ï¼»
`å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹$,
`å…¥å‡ºåŠ›~queueã‹ã‚‰~itemåˆ—ã‚’èª­å–ã‚‹$
ï¼½~algoã¯ã€
åŸæ–‡ã§ã¯åŒã˜ï¼»
åå‰, ~ID
ï¼½ã‚’ä¼´ã† 2 å€‹ã®~algoã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŒï¼Œ
ã“ã®è¨³ã§ã¯ç•°ãªã‚‹ï¼»
åå‰, ~ID
ï¼½ã‚’ä¸ãˆã‚‹ã“ã¨ã«ã™ã‚‹ã€‚
ã€‘</p>

<div class="algo">
<p>
`å…¥å‡ºåŠ›~queueã‚’è¦—è¦‹ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$ %å…¥å‡ºåŠ›~queue, æ•´æ•° %å€‹æ•° )
ã«å¯¾ã—ï¼š
â—
To peek a number number of items from an I/O queue ioQueue, run these steps:
</p>
<ol>
	<li>
æ¬¡ãŒæº€ãŸã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã™ã‚‹
â‡’
ï¼»
%å…¥å‡ºåŠ›~queue ã®`~size$ ~GTE %å€‹æ•°
ï¼½~ORï¼»
`~EoQ$ ~IN %å…¥å‡ºåŠ›~queue
ï¼½
â—
Wait until either ioQueueâ€™s size is equal to or greater than number, or ioQueue contains end-of-queue, whichever comes first.
</li>
	<li>
%æ¥é ­è¾ ~LET Â« Â»
â—
Let prefix be Â« Â».
</li>
	<li>
<p>
`ç¯„å›²$ { 0 ã€œ %å€‹æ•° ~MINUS 1 }ã€ï¼range 1 to numberã€‘ ã‚’æˆã™
~EACH( %n )
ã«å¯¾ã—ï¼š
â—
For each n in the range 1 to number, inclusive:
</p>
		<ol>
			<li>
~IFï¼»
%å…¥å‡ºåŠ›~queue[ %n ] ~EQ `~EoQ$
ï¼½
â‡’
~BREAK
â—
If ioQueue[n] is end-of-queue, break.
</li>
			<li>
%æ¥é ­è¾ ã« %å…¥å‡ºåŠ›~queue[ %n ] ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Otherwise, append ioQueue[n] to prefix.
</li>
		</ol>
	</li>
	<li>
~RET %æ¥é ­è¾
â—
Return prefix.
</li>
</ol>
</div>

<div class="algo">
<p>
`å…¥å‡ºåŠ›~queueã«~pushã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$ %å…¥å‡ºåŠ›~queue, %~itemåˆ— )
ã«å¯¾ã—ï¼š
</p>
<ol>
	<li>
~Assertï¼šï¼»
%~itemåˆ— ã¯ 1 å€‹ã®~itemã§ã‚ã‚‹ã‹ï¼»
~itemãŸã¡ãŒæˆã™é€£åˆ—
ï¼½ã§ã‚ã‚‹
ï¼½~ANDï¼»
%~itemåˆ— ã‚’æˆã™ ã©ã®~itemã‚‚ï¼Œãã®å‹ã¯ %å…¥å‡ºåŠ›~queue ã®~itemå‹ã§ã‚ã‚‹
ï¼½
</li>
	<li>
<p>
%~itemåˆ— ã‚’æˆã™
~EACH( %~item )
ã«å¯¾ã—ï¼š
</p>
		<ol>
			<li>
%æœ€å¾Œã®~index ~LET %å…¥å‡ºåŠ›~queue ã®`~size$ ~MINUS 1
</li>
			<li>
<p>
~IFï¼»
%å…¥å‡ºåŠ›~queue[ %æœ€å¾Œã®~index ] ~EQ `~EoQ$
ï¼½ï¼š
</p>
				<ol>
					<li>
~IFï¼»
%~item ~NEQ `~EoQ$
ï¼½
â‡’
%å…¥å‡ºåŠ›~queue ã®ä¸­ã¸ %~item ã‚’ %æœ€å¾Œã®~index ã®å‰ã«`æŒ¿å…¥ã™ã‚‹$
</li>
				</ol>
			</li>
			<li>
~ELSE
â‡’
%å…¥å‡ºåŠ›~queue ã« %~item ã‚’`ä»˜åŠ ã™ã‚‹$
</li>
		</ol>
	</li>
</ol>

â—
To push an item item to an I/O queue ioQueue, run these steps:
â€¢ If the last item in ioQueue is end-of-queue:
â€¢â€¢ If item is end-of-queue, do nothing.
â€¢â€¢ Otherwise, insert item before the last item in ioQueue.
â€¢ Otherwise, append item to ioQueue.
â—
To push a sequence of items to an I/O queue ioQueue is to push each item in the sequence to ioQueue, in the given order.
</div>

<div class="algo">
<p>
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$ %å…¥å‡ºåŠ›~queue, %~itemåˆ— )
ã«å¯¾ã—ï¼š
</p>
<ol>
	<li>
<p>
~Assertï¼š
</p>
		<ul>
			<li>
%~itemåˆ— ã¯ 1 å€‹ã®~itemã§ã‚ã‚‹ã‹ï¼»
~itemãŸã¡ãŒæˆã™é€£åˆ—
ï¼½ã§ã‚ã‚‹
</li>
			<li>
%~itemåˆ— å†…ã«`~EoQ$ã¯ç„¡ã„
</li>
			<li>
%~itemåˆ— ã‚’æˆã™ ã©ã®~itemã‚‚ï¼Œãã®å‹ã¯ %å…¥å‡ºåŠ›~queue ã®~itemå‹ã§ã‚ã‚‹
</li>
		</ul>
	</li>
	<li>
%å…¥å‡ºåŠ›~queue ã®å…ˆé ­ã« %~itemåˆ— ã‚’
â€” ~itemãŸã¡ã®é †åºã‚’~~ä¿ã£ãŸã¾ã¾ â€”
æŒ¿å…¥ã™ã‚‹
</li>
</ol>
â—
To restore an item other than end-of-queue to an I/O queue, perform the list prepend operation. To restore a list of items excluding end-of-queue to an I/O queue, insert those items, in the given order, before the first item in the queue.
</div>

<p class="example">
å…¥å‡ºåŠ›~queue`~byte^tA Â« `92^X, `A9^X, ~EoQ Â» ã«
~byteåˆ— Â« `F0^X, `9F^X Â» ã‚’æŒ¿å…¥ã—ãŸã€ï¼Insertingã€‘ãªã‚‰ã€
çµæœã®å…¥å‡ºåŠ›~queueã¯
Â« `F0^X, `9F^X, `92^X, `A9^X, ~EoQ Â» ã«ãªã‚Šï¼Œ
æ¬¡å›ã«èª­å–ã‚‰ã‚Œã‚‹~itemã¯ `F0^X ã«ãªã‚‹ã€‚
â—
Inserting the bytes Â« 0xF0, 0x9F Â» in an I/O queue Â« 0x92 0xA9, end-of-queue Â», results in an I/O queue Â« 0xF0, 0x9F, 0x92 0xA9, end-of-queue Â». The next item to be read would be 0xF0.
</p>

<div class="algo">
<p>
`å…¥å‡ºåŠ›~queue$ %å…¥å‡ºåŠ›~queue ã‚’ï¼»
`~list$ï¼`æ–‡å­—åˆ—$ï¼`~byteåˆ—$
ï¼½ã«
`å¤‰æ›ã™ã‚‹@
~algoã¯
â‡’
~RET `å…¥å‡ºåŠ›~queueã‹ã‚‰~itemåˆ—ã‚’èª­å–ã‚‹$( %å…¥å‡ºåŠ›~queue, `ä¸å®š^i )
â—
To convert an I/O queue ioQueue into a list, string, or byte sequence, return the result of reading an indefinite number of items from ioQueue.
</div>

<div class="algo">
<p>
`å…¥å‡ºåŠ›~queueã«å¤‰æ›ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( %å…¥åŠ› )
ã«å¯¾ã—ï¼š
</p>
<ol>
	<li>
~Assertï¼š
%å…¥åŠ› ã¯æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹ã§ã‚ã‚‹
â‡’ï¼ƒ
`æ–‡å­—åˆ—$ï¼ˆ `DOMString^I ï¼‰ï¼
`~scalarå€¤~æ–‡å­—åˆ—$ï¼ˆ `USVString^I ï¼‰ï¼
`~byteåˆ—$ï¼
`~list$
</li>
	<li>
~Assertï¼š
%å…¥åŠ› ã¯`~list$ã§ã‚ã‚‹ãªã‚‰ã°ã€
æ¬¡ã‚’æº€ãŸã™
â‡’
ï¼»
%å…¥åŠ› ã‚’æˆã™ ã™ã¹ã¦ã®~itemã¯åŒã˜å‹ã§ã‚ã‚‹
ï¼½~ANDï¼»
`~EoQ$ ~NIN %å…¥åŠ›
ï¼½
</li>
	<li>
%å…¥å‡ºåŠ›~queue ~LET æ–°ãŸãª`å…¥å‡ºåŠ›~queue$`<var>å…¥åŠ›</var> ã‚’æˆã™~itemã®å‹^tA
</li>
	<li>
%å…¥åŠ› ã‚’æˆã™
~EACH( %~item )
ã«å¯¾ã—
â‡’
%å…¥å‡ºåŠ›~queue ã« %~item ã‚’`ä»˜åŠ ã™ã‚‹$
</li>
	<li>
%å…¥å‡ºåŠ›~queue ã«`~EoQ$ã‚’`ä»˜åŠ ã™ã‚‹$
</li>
	<li>
~RET %å…¥å‡ºåŠ›~queue
</li>
</ol>
â—
To convert a list, string, or byte sequence input into an I/O queue, run these steps:
â€¢ Assert: if input is a list, then it does not contain end-of-queue.
â€¢ Return an I/O queue containing the items in input, in order, followed by end-of-queue.
</div>

<p class="XXX">
`INFRA$r æ¨™æº–ãŒå‹~å¤‰æ›~å‘¨ã‚Šã®ä½•ã‚‰ã‹ã®åŸºç›¤ã‚’å®šç¾©ã™ã‚‹ã‚‚ã®ã¨æœŸå¾…ã•ã‚Œã‚‹ã€‚
`whatwg/infra èª²é¡Œ #319ï¼ https://github.com/whatwg/infra/issues/319$
ã‚’è¦‹ã‚ˆã€‚
â—
The Infra standard is expected to define some infrastructure around type conversions. See whatwg/infra issue #319. [INFRA]
</p>

<p class="note">æ³¨è¨˜ï¼š
`å…¥å‡ºåŠ›~queue$ãŒ`~queue$ã§ã¯ãªã`~list$ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã®ã¯ã€
`æ ¼ç´ã—ç›´ã™æ¼”ç®—$ã‚’è¦ã™ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ãªãŒã‚‰ï¼Œã“ã®æ¼”ç®—ã¯ã€
ã“ã®ä»•æ§˜ãŒä¸ãˆã‚‹~algoã®å†…éƒ¨çš„ãªè©³ç´°ã§ã‚ã‚Šï¼Œä»–ã®æ¨™æº–ã‹ã‚‰ã¯åˆ©ç”¨ã•ã‚Œãªã„ã€‚
å®Ÿè£…ã¯ã€
ãã®ã‚ˆã†ãª~algoã‚’ä»£æ›¿ãªä»•æ–¹ã‚’è¦‹å‡ºã—ã¦å®Ÿè£…ã—ã¦ã‚‚ã‹ã¾ã‚ãªã„
â€” è©³ç´°ã¯ã€
`Â§ å®Ÿè£…ã®è€ƒæ…®ç‚¹ï¼ #implementation-considerations$
ã«ã€‚
â—
I/O queues are defined as lists, not queues, because they feature a restore operation. However, this restore operation is an internal detail of the algorithms in this specification, and is not to be used by other standards. Implementations are free to find alternative ways to implement such algorithms, as detailed in Implementation considerations.
</p>

<hr>

<div class="algo">
`~surrogateå¯¾ã‹ã‚‰~scalarå€¤ã‚’å¾—ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `é ­éƒ¨~surrogate$ %é ­éƒ¨, `å°¾éƒ¨~surrogate$ %å°¾éƒ¨ )
ã«å¯¾ã—
â‡’
~RET `10000^X ~PLUS ( ( %é ­éƒ¨ ~MINUS `D800^X ) ~Lshift 10 ) ~PLUS ( %å°¾éƒ¨ ~MINUS `DC00^X )
â—
To obtain a scalar value from surrogates, given a leading surrogate leading and a trailing surrogate trailing, return 0x10000 + ((leading âˆ’ 0xD800) &lt;&lt; 10) + (trailing âˆ’ 0xDC00).
</div>

	</section>
	<section id="_conventions">
<h2>ã€ã“ã®è¨³ã«ç‰¹æœ‰ãªè¡¨è¨˜è¦ç´„ã€‘</h2>

â—è¡¨è¨˜è¨˜å·

<p>
åŠ ãˆã¦ã€
æ¬¡ã«æŒ™ã’ã‚‹è¨˜æ³•ã‚‚åˆ©ç”¨ã•ã‚Œã‚‹ï¼š
</p>
<dl>
	<dt>
~byteåˆ— Â« %n1, %n2, â€¦ Â»
</dt>
	<dd>
æ•°å€¤ã¨ã—ã¦ %n1, %n2 â€¦ ã¨åŒã˜å€¤ã‚’ã¨ã‚‹`~byte$ãŸã¡ãŒæˆã™, æŒ™ã’ã‚‰ã‚ŒãŸé †ã«ã‚ˆã‚‹ï¼Œæ–°ãŸãª`~item$åˆ—ã‚’è¡¨ã™
ï¼ˆæ‹¬å¼§ã®ä¸­ãŒç©ºãª â€œÂ« Â»â€ ã¨è¨˜ã•ã‚ŒãŸã¨ãã¯ã€
ç©ºãª`~item$åˆ—ã‚’è¡¨ã™ï¼‰ã€‚
</dd>

	<dt>
~byte Â« %n Â»
</dt>
	<dd>
~byteåˆ— Â« %n Â» ã¨åŒç¾©ã ãŒã€
~itemãŒ 1 å€‹ã ã‘ã®å ´åˆã¯ï¼Œã“ã®ã‚ˆã†ã«è¨˜ã•ã‚Œã‚‹ã€‚
</dd>

	<dt>
~cp Â« %n Â»
</dt>
	<dd>
æ•°å€¤ã¨ã—ã¦ %n ã¨åŒã˜å€¤ã‚’ã¨ã‚‹ 1 å€‹ã®`~cp$ã‹ã‚‰ãªã‚‹ï¼Œæ–°ãŸãª`~item$åˆ—ã‚’è¡¨ã™ã€‚
</dd>
</dl>

<p><small>
ï¼ˆåŸæ–‡ã§ã¯ï¼Œ~itemãŒ 1 å€‹ã ã‘ã®å ´åˆã¯
â€” 1 å€‹ã®~itemã‚’ ãã‚Œã®ã¿ã‹ã‚‰ãªã‚‹~itemåˆ—ã¨ã—ã¦é€éçš„ã«æ‰±ã†ä»•çµ„ã¿
ï¼ˆ`å…¥å‡ºåŠ›~queue$ã«å¯¾ã™ã‚‹å„ç¨®~æ¼”ç®—ã‚’è¦‹ã‚ˆï¼‰
ã‚’åˆ©ç”¨ã—ã¦ â€”
æ‹¬å¼§ï¼ˆ Â«, Â» ï¼‰ã§æ‹¬ã‚‰ãšã«è¨˜ã•ã‚Œã¦ã„ã‚‹ãŒã€
ã“ã®è¨³ã§ã¯
â€” â€œåŒã˜å€¤ã‚’ã¨ã‚‹â€ ã¨ã„ã†å«æ„ã‚’ç°¡æ½”ã«è¡¨ã™ãŸã‚ â€”
æ‹¬å¼§ã§æ‹¬ã‚‹ã“ã¨ã«ã™ã‚‹ã€‚ï¼‰
ï¼ˆ â€œ~cpåˆ— Â« â€¦ Â»â€ ã¨ã„ã†è¨˜æ³•ãŒç„¡ã„ã®ã¯ã€
è¤‡æ•°å€‹ã®~cpã‹ã‚‰ãªã‚‹~itemåˆ—ãŒåˆ©ç”¨ã•ã‚Œã‚‹æ‰€ãŒï¼Œä¸€ç®‡æ‰€ã—ã‹ãªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚ï¼‰
</small></p>

	</section>
	<section id="encodings">
<h2 title="Encodings">4. ç¬¦å·åŒ–æ³•</h2>

<p>
`ç¬¦å·åŒ–æ³•@
ï¼ˆ `encoding^en ï¼‰ã¯ã€
`~scalarå€¤$ åˆ—ã‹ã‚‰~byteåˆ—ã¸ã®å¯¾å¿œä»˜ã‘
ã€ç¬¦å·åŒ–-ã€‘
ãŠã‚ˆã³é€†æ–¹å‘ã¸ã®å¯¾å¿œä»˜ã‘
ã€å¾©å·-ã€‘
ã‚’å®šç¾©ã™ã‚‹ã€‚
å„ `ç¬¦å·åŒ–æ³•$ã«ã¯ã€
`åå‰@
ãŠã‚ˆã³ï¼Œ 1 å€‹~ä»¥ä¸Šã®
`~label@
ãŒ`ã‚ã¦ãŒã‚ã‚Œã¦ã„ã‚‹ï¼ #encoding-labels$ã€‚
â—
An encoding defines a mapping from a scalar value sequence to a byte sequence (and vice versa). Each encoding has a name, and one or more labels.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®ä»•æ§˜ã¯ã€
~Unicodeæ¨™æº–ã«å®šç¾©ã•ã‚Œã‚‹ç¬¦å·åŒ–~schemeï¼ˆ `encoding scheme^en ï¼‰ã¨ã—ã¦ï¼ŒåŒã˜åå‰ã‚’ä¼´ã† 3 ç¨®ã®`ç¬¦å·åŒ–æ³•$
â€” `UTF-8$n, `UTF-16LE$n, `UTF-16BE$n â€”
ã‚’å®šç¾©ã™ã‚‹ã€‚
`ç¬¦å·åŒ–æ³•$ã¯ã€
~BOMï¼ˆ `byte order mark^en, â€œãƒã‚¤ãƒˆé †ãƒãƒ¼ã‚¯â€ ï¼‰ã®å–æ‰±ã„ã«ãŠã„ã¦ç¬¦å·åŒ–~schemeã‹ã‚‰ç›¸é•ã™ã‚‹
â€” ~BOMã®å–æ‰±ã„ã¯ã€
ã“ã®ä»•æ§˜ã«ãŠã„ã¦ã¯ï¼»
`ç¬¦å·åŒ–æ³•$è‡ªèº«ã®ä¸€éƒ¨ã‚’æˆã™ä»£ã‚ã‚Šã«ï¼Œãã‚Œã‚’åŒ…è£…ã™ã‚‹~algoã®ä¸€éƒ¨ã‚’æˆã—ã¦ã„ã‚‹
ï¼½ä¸€æ–¹ã§ï¼Œ
~Unicodeæ¨™æº–ã«ãŠã„ã¦ã¯ç¬¦å·åŒ–~schemeã®å®šç¾©ã®ä¸€éƒ¨ã‚’æˆã™ã€‚
`~UTF-8å¾©å·ã™ã‚‹$~algoã¨ä¸€ç·’ã«åˆ©ç”¨ã•ã‚Œã‚‹ `UTF-8$n ã¯ã€
åŒã˜åå‰ã®ç¬¦å·åŒ–~schemeã«åˆè‡´ã™ã‚‹ã€‚
ã“ã®ä»•æ§˜ã¯ã€
åŒæ§˜ã«å‘½åã•ã‚Œã‚‹ç¬¦å·åŒ–~schemeã«åˆè‡´ã™ã‚‹ã‚ˆã†ãªï¼»
`UTF-16LE$n ï¼ `UTF-16BE$n
ï¼½ã¨çµ„åˆã›ã¦åŒ…è£…ã™ã‚‹~algoã¯ï¼Œä¾›ã•ãªã„ã€‚
`UNICODE$r
â—
This specification defines three encodings with the same names as encoding schemes defined in the Unicode standard: UTF-8, UTF-16LE, and UTF-16BE. The encodings differ from the encoding schemes by byte order mark (also known as BOM) handling not being part of the encodings themselves and instead being part of wrapper algorithms in this specification, whereas byte order mark handling is part of the definition of the encoding schemes in the Unicode Standard. UTF-8 used together with the UTF-8 decode algorithm matches the encoding scheme of the same name. This specification does not provide wrapper algorithms that would combine with UTF-16LE and UTF-16BE to match the similarly-named encoding schemes. [UNICODE]
</p>

		<section id="encoders-and-decoders">
<h3 title="Encoders and decoders">4.1. ç¬¦å·åŒ–å™¨ã¨å¾©å·å™¨</h3>

<p>
å„ `ç¬¦å·åŒ–æ³•$ã«ã¯ã€
`å¾©å·å™¨@
ï¼ˆ `decoder^en ï¼‰ãŒçµä»˜ã‘ã‚‰ã‚Œï¼Œ
`ç¬¦å·åŒ–å™¨@
ï¼ˆ `encoder^en ï¼‰ãŒçµä»˜ã‘ã‚‰ã‚Œå¾—ã‚‹ã€‚
â—
Each encoding has an associated decoder and most of them have an associated encoder.ï¼¼
</p>

<p>
ï¼»
`å¾©å·å™¨$ ï¼ `ç¬¦å·åŒ–å™¨$
ï¼½ã®å„~instanceã¯ã€
`~handler@
~algoãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ã“ã¨ã«åŠ ãˆï¼ŒçŠ¶æ…‹ã‚‚ä¼´ã„å¾—ã‚‹ã€‚
ã€çŠ¶æ…‹ã‚’ä¼´ã†ãŒã‚†ãˆã«ã€çŠ¶æ…‹ãŒç•°ãªã‚‹ ãã‚Œã‚‰ã‚’åˆ¥å€‹ãª~instanceã¨ã—ã¦æ‰±ã†å¿…è¦ãŒã‚ã‚‹ã€‚ã€‘
â—
Instances of decoders and encoders have a handler algorithm and might also have state.ï¼¼
</p>

<div class="p">
<p>
`~handler$ã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$, 1 å€‹ã®`~item$ )
ã«å¯¾ã—ï¼Œæ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹ã‚’è¿”ã™~algoã§ã‚ã‚‹ï¼š
</p>
<ul>
	<li>
`å®Œé‚d@i
</li>
	<li>
<p>
1 å€‹ä»¥ä¸Šã®`~item$
</p>

<p class="trans-note">ã€
~itemå‹ã¯ã€ï¼»
ç¬¦å·åŒ–å™¨ã®å ´åˆã¯`~byte$ ï¼ å¾©å·å™¨ã®å ´åˆã¯`~cp$
ï¼½ã«ãªã‚‹ã€‚
ã€‘ã€
`~Big5å¾©å·å™¨$ç”¨ã®~handlerã ã‘ï¼Œ 2 å€‹ã®~cpã‚’è¿”ã™å ´åˆãŒã‚ã‚Šã€
ä»–ã®å¾©å·å™¨~ç”¨ã®~handlerã¯ï¼Œå¸¸ã« 1 å€‹ã®~cpã‹ã‚‰ãªã‚‹~itemåˆ—ã‚’è¿”ã™ã€‚
ã€‘</p>
	</li>
	<li>
<p>
`~error@i
</p>

<p>
`ç¬¦å·åŒ–å™¨$ç”¨ã®`~handler$ãŒè¿”ã™ `~error$i ã¯ã€
å¸¸ã«ï¼Œ~cpã‚’ä¼´ã†
ï¼ˆ`å¾©å·å™¨$ç”¨ã®`~handler$ãŒè¿”ã™ `~error$i ãŒ~cpã‚’ä¼´ã†ã“ã¨ã¯ç„¡ã„ï¼‰ã€‚
æ‰€ä¸ã®`~cp$ %~cp ã‚’ä¼´ã† `~error$i ã‚’ä½œæˆã™ã‚‹æ‰€ã§ã¯ã€
â€œ`~error$i( %~cp )â€
ã®ã‚ˆã†ã«è¡¨è¨˜ã•ã‚Œã‚‹ã€‚
</p>

<p class="trans-note">ã€
ã“ã‚Œã‚‰ã®è¨˜è¿°ã¯ã€
ã“ã®è¨³ã«ã‚ˆã‚‹è£œå®Œ
â€” åŸæ–‡ã§ã¯ã€
ï¼ˆ~errorã¯ï¼Œï¼‰
â€œçœç•¥å¯èƒ½ãª`~cp$ã‚‚ä¼´ã„å¾—ã‚‹â€
ã¨ã—ã‹è¨˜ã•ã‚Œã¦ã„ãªã„ã€‚
ã€‘</p>

	</li>
	<li>
`ç¶™ç¶š-@i
</li>
</ul>
â—
A handler algorithm takes an input I/O queue and an item, and returns finished, one or more items, error optionally with a code point, or continue.
</div>

<p class="note">æ³¨è¨˜ï¼š
æ¬¡ã«æŒ™ã’ã‚‹`ç¬¦å·åŒ–æ³•$ã«ã¯ã€
`ç¬¦å·åŒ–å™¨$ã¯ç„¡ã„
â‡’ï¼ƒ
`replacement$n,
`UTF-16BE/LE$n
â—
The replacement and UTF-16BE/LE encodings have no encoder.
</p>

<p>
ä»¥ä¸‹ã§åˆ©ç”¨ã•ã‚Œã‚‹
`~error~mode@
ã¯ï¼š
â—
An error mode as used below isï¼¼
</p>
<ul>
	<li>
`å¾©å·å™¨$ã«ãŠã„ã¦ã¯ã€
æ¬¡ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚‹
â‡’
`replacement^l,
`fatal^l
â—
"replacement" or "fatal" for a decoder andï¼¼
</li>
	<li>
`ç¬¦å·åŒ–å™¨$ã«ãŠã„ã¦ã¯ã€
æ¬¡ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚‹
â‡’
`fatal^l,
`html^l
â—
"fatal" or "html" for an encoder.
</li>
</ul>

<p class="note">æ³¨è¨˜ï¼š
~XMLå‡¦ç†å™¨ã¯ã€
ãã®`å¾©å·å™¨$ã®`~error~mode$ã‚’ `fatal^l ã«è¨­å®šã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
`XML$r
â—
An XML processor would set error mode to "fatal". [XML]
</p>

<p class="note">æ³¨è¨˜ï¼š
`~error~mode$ã« `html^l ãŒå­˜åœ¨ã™ã‚‹ã‚ã‘ã¯ã€
~HTML~formã«ãŠã„ã¦ã¯ï¼Œ
`~error$i ã«éš›ã—ã¦ã‚‚æ—§æ¥ã®`ç¬¦å·åŒ–å™¨$ã¯çµ‚äº†ã•ã›ãªã„å–æ‰±ã„ãŒè¦æ±‚ã•ã‚Œã‚‹ã“ã¨ã«å› ã‚‹ã€‚
`html^l `~error~mode$ã®ä¸‹ã§ã¯ã€
åˆæ³•ãªå…¥åŠ›ã¨åˆ¤åˆ¥ã§ããªã„é€£åˆ—ãŒç™ºã•ã‚Œå¾—ã‚‹çµæœï¼Œ~~æ¤œçŸ¥ã•ã‚Œãšã«~dataãŒå¤±ã‚ã‚Œå¾—ã‚‹ã€‚
ã“ã‚Œã‚’é˜²ããŸã‚ã€
é–‹ç™ºè€…ã«ã¯ `UTF-8$n `ç¬¦å·åŒ–æ³•$ã®åˆ©ç”¨ãŒå¼·ãå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
`HTML$r
â—
"html" exists as error mode due to HTML forms requiring a non-terminating legacy encoder. The "html" error mode causes a sequence to be emitted that cannot be distinguished from legitimate input and can therefore lead to silent data loss. Developers are strongly encouraged to use the UTF-8 encoding to prevent this from happening. [HTML]
</p>

<hr>

<div class="algo">
<p>
`~queueã‚’å‡¦ç†ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`ç¬¦å·åŒ–æ³•$ã®ï¼» `å¾©å·å™¨$ ï¼ `ç¬¦å·åŒ–å™¨$ ï¼½ã®~instance %~coder
`å…¥å‡ºåŠ›~queue$ %å…¥åŠ›,
`å…¥å‡ºåŠ›~queue$ %å‡ºåŠ›,
`~error~mode$ %~mode
â—çµ‚
ã«å¯¾ã—ï¼š
â—
To process a queue given an encodingâ€™s decoder or encoder instance encoderDecoder, I/O queue input, I/O queue output, and error mode mode:
</p>
<ol>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
		<ol>
			<li>
%~item ~LET `å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹$( %å…¥åŠ› )
â—
â†“</li>
			<li>
%çµæœ ~LET `~itemã‚’å‡¦ç†ã™ã‚‹$( %~item, %~coder, %å…¥åŠ›, %å‡ºåŠ›, %~mode )
â—
Let result be the result of processing an item with the result of reading from input, encoderDecoder, input, output, and mode.
</li>
			<li>
~IFï¼»
%çµæœ ~NEQ `ç¶™ç¶š-$i
ï¼½
â‡’
~RET %çµæœ
â—
If result is not continue, then return result.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~itemã‚’å‡¦ç†ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`~item$ %~item,
`ç¬¦å·åŒ–æ³•$ã®ï¼» `ç¬¦å·åŒ–å™¨$ï¼`å¾©å·å™¨$ ï¼½ã®~instance %~coder,
`å…¥å‡ºåŠ›~queue$ %å…¥åŠ›,
`å…¥å‡ºåŠ›~queue$ %å‡ºåŠ›,
`~error~mode$ %~mode
â—çµ‚
ã«å¯¾ã—ï¼š
â—
To process an item given an item item, encodingâ€™s encoder or decoder instance encoderDecoder, I/O queue input, I/O queue output, and error mode mode:
</p>
<ol>
	<li>
~Assertï¼š
%~coder ã¯`ç¬¦å·åŒ–å™¨$ã®~instanceã§ã‚ã‚‹ãªã‚‰ã°ã€
%~mode ~NEQ `replacement^l
â—
Assert: if encoderDecoder is an encoder instance, mode is not "replacement".
</li>
	<li>
~Assertï¼š
%~coder ã¯`å¾©å·å™¨$ã®~instanceã§ã‚ã‚‹ãªã‚‰ã°ã€
%~mode ~NEQ `html^l
â—
Assert: if encoderDecoder is a decoder instance, mode is not "html".
</li>
	<li>
~Assertï¼š
%~coder ã¯`ç¬¦å·åŒ–å™¨$ã®~instanceã§ã‚ã‚‹ãªã‚‰ã°ã€
%~item ã¯`~surrogate$ã§ã¯ãªã„ã€‚
â—
Assert: if encoderDecoder is an encoder instance, item is not a surrogate.
</li>
	<li>
%çµæœ ~LET %~coder ã®`~handler$( %å…¥åŠ›, %~item )
â—
Let result be the result of running encoderDecoderâ€™s handler on input and item.
</li>
	<li>
~IFï¼»
%çµæœ ~EQ `å®Œé‚d$i
ï¼½
â‡’ï¼ƒ
`å…¥å‡ºåŠ›~queueã«~pushã™ã‚‹$( %å‡ºåŠ›, Â« `~EoQ$ Â» )ï¼›
~RET %çµæœ
â—
If result is finished:
â€¢ Push end-of-queue to output.
â€¢ Return result.
</li>
	<li>
<p>
~IFï¼»
%çµæœ ã¯ 1 å€‹~ä»¥ä¸Šã®`~item$ã‹ã‚‰ãªã‚‹
ï¼½ï¼š
â—
Otherwise, if result is one or more items:
</p>
		<ol>
			<li>
~Assertï¼š
%~coder ã¯`å¾©å·å™¨$ã®~instanceã§ã‚ã‚‹ãªã‚‰ã°ã€
%çµæœ ã¯`~surrogate$ã‚’åŒ…å«ã—ãªã„ã€‚
â—
Assert: if encoderDecoder is a decoder instance, result does not contain any surrogates.
</li>
			<li>
`å…¥å‡ºåŠ›~queueã«~pushã™ã‚‹$( %å‡ºåŠ›, %çµæœ )
â—
Push result to output.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIFï¼»
%çµæœ ã¯ `~error$i ã§ã‚ã‚‹
ï¼½ï¼š
â—
Otherwise, if result is an error,ï¼¼
</p>
		<ol>
			<li>
<p>
%~mode ã«å¿œã˜ã¦ï¼š
â—
switch on mode and run the associated steps:
</p>
				<ul class="switch">
					<li>
`replacement^l
â‡’
`å…¥å‡ºåŠ›~queueã«~pushã™ã‚‹$( %å‡ºåŠ›, Â« `FFFD^U `ï¿½^smb Â» )
â—
"replacement"
â€¢ Push U+FFFD (ï¿½) to output.
</li>
					<li>
<p>
`html^lï¼š
</p>
						<ol>
							<li>
%æ•°å­—åˆ— ~LET ï¼»
%çµæœ ã‚’æˆã™`~cp$
ï¼½ã®`å€¤$cpã‚’åŸºæ•° 10 ã§æœ€çŸ­ã«è¡¨ç¾ã™ã‚‹ã‚ˆã†ãªï¼Œï¼»
1 å€‹ä»¥ä¸Šã®ï¼»
`30^X `0^smb ã€œ `39^X `9^smb
ï¼½ãŸã¡ãŒæˆã™~byteåˆ—
</li>
							<li>
`å…¥å‡ºåŠ›~queueã«~pushã™ã‚‹$( %å‡ºåŠ›, æ¬¡ã®ä¸¦ã³ãŒæˆã™~byteåˆ— )
â‡’ï¼ƒ
`26^X `&amp;^smb,
`23^X `#^smb,
%æ•°å­—åˆ—,
`3B^X `;^smb
</li>
						</ol>
â—
"html"
â€¢ Push 0x26 (&amp;), 0x23 (#), followed by the shortest sequence of 0x30 (0) to 0x39 (9), inclusive, representing resultâ€™s code pointâ€™s value in base ten, followed by 0x3B (;) to output.
</li>
					<li>
`fatal^l
â‡’
~RET %çµæœ
â—
"fatal"
â€¢ Return result.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
~RET `ç¶™ç¶š-$i
â—
Return continue.
</li>
</ol>
</div>

		</section>
		<section id="names-and-labels">
<h3 title="Names and labels">4.2. åå‰ã¨~label</h3>

<p>
~UAã¯ã€
ä¸‹ã®è¡¨tã«æŒ™ã’ã‚‹å„ï¼»
`ç¬¦å·åŒ–æ³•$, ãã‚Œç”¨ã®`~label$ã™ã¹ã¦
ï¼½ã‚’~supportã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«
â€” ä»–ã®`ç¬¦å·åŒ–æ³•$ã‚„`~label$ã¯~supportã—ãªã„ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The table below lists all encodings and their labels user agents must support. User agents must not support any other encodings or labels.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã©ã®ç¬¦å·åŒ–æ³•ã«ã¤ã„ã¦ã‚‚ã€
æ¬¡ãŒæº€ãŸã•ã‚Œã‚‹
â‡’
ãã®`åå‰$ã‚’`~ASCIIå°æ–‡å­—~åŒ–$ã—ãŸçµæœ ~IN ãã‚Œç”¨ã®`~label$ãŸã¡ãŒæˆã™é›†åˆ
â—
For each encoding, ASCII-lowercasing its name yields one of its labels.
</p>

<p class="trans-note">ã€
åŠ ãˆã¦ã€
ç•°ãªã‚‹ç¬¦å·åŒ–æ³•~ç”¨ã®~labelã©ã†ã—ãŒä¸€è‡´ã™ã‚‹ã“ã¨ã¯ãªã„ã€‚
ã€‘</p>

<p>
ä½œè€…ã¯ã€
`UTF-8$n `ç¬¦å·åŒ–æ³•$ã‚’åˆ©ç”¨ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤
â€” ãã®åˆ©ç”¨ãŒè­˜åˆ¥ã•ã‚Œã‚‹ã‚ˆã†ï¼Œ
ãã‚Œç”¨ã®`~label$ã®ã†ã¡ `utf-8^lb ï¼ˆ`~ASCIIå¤§å°ç„¡è¦–$ï¼‰ã‚’åˆ©ç”¨ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
Authors must use the UTF-8 encoding and must use its (ASCII case-insensitive) "utf-8" label to identify it.
</p>

<p>
ï¼»
æ–°ãŸãª~protocolï¼
æ–°ãŸãªå½¢å¼ï¼
æ–°ãŸãªæ–‡è„ˆã«ãŠã„ã¦é…å‚™ã•ã‚Œã‚‹æ—¢å­˜ã®å½¢å¼
ï¼½ã«ã¯ã€
`UTF-8$n `ç¬¦å·åŒ–æ³•$ã‚’æ’ä»–çš„ã«åˆ©ç”¨ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
ãã®ã‚ˆã†ãªï¼»
~protocolã‚„å½¢å¼
ï¼½ãŒå…¬é–‹ã™ã‚‹`ç¬¦å·åŒ–æ³•$ã®ï¼»
`åå‰$ï¼`~label$
ï¼½ã¯ã€
`utf-8^lb ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
New protocols and formats, as well as existing formats deployed in new contexts, must use the UTF-8 encoding exclusively. If these protocols and formats need to expose the encodingâ€™s name or label, they must expose it as "utf-8".
</p>

<div class="algo">
<p>
`~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( æ–‡å­—åˆ— %~label )
ã«å¯¾ã—ï¼š
â—
To get an encoding from a string label, run these steps:
</p>
<ol>
	<li>
%~label ~SET `å‰å¾Œã®~ASCIIç©ºç™½~åˆ—ã‚’å‰¥ã$( %~label )
â—
Remove any leading and trailing ASCII whitespace from label.
</li>
	<li>
~IFï¼»
%~label ã¯ï¼»
ä¸‹ã®è¡¨tã‚’æˆã™ã„ãšã‚Œã‹ã®~label
ï¼½ã«`~ASCIIå¤§å°ç„¡è¦–$ã§åˆè‡´ã™ã‚‹
ï¼½
â‡’
~RET åˆè‡´ã—ãŸ~labelã«å¯¾å¿œã™ã‚‹`ç¬¦å·åŒ–æ³•$
â—
If label is an ASCII case-insensitive match for any of the labels listed in the table below, then return the corresponding encoding;ï¼¼
</li>
	<li>
~RET `å¤±æ•—^i
â—
otherwise return failure.
</li>
</ol>
</div>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®ï¼»
~labelã‚’`ç¬¦å·åŒ–æ³•$ã«å¯¾å¿œä»˜ã‘ã‚‹~algo
ï¼½ã¯ã€
`Unicode Technical Standard #22 Â§ 1.4ï¼ https://www.unicode.org/reports/tr22/tr22-8.html#Charset_Alias_Matching$
ã«ã‚ˆã‚‹ã‚‚ã®ã‚ˆã‚ŠåŸºæœ¬çš„ã‹ã¤åˆ¶ç´„çš„ã§ã‚ã‚‹
â€” é…å‚™-æ¸ˆã¿ãªå†…å®¹ã¨äº’æ›ã«ãªã‚‹ã“ã¨ãŒå¿…è¦yãªã®ã§ã€‚
â—
This is a more basic and restrictive algorithm of mapping labels to encodings than section 1.4 of Unicode Technical Standard #22 prescribes, as that is necessary to be compatible with deployed content.
</p>

<table id="encoding-labels"><thead>
<tr><th>
åå‰
â—
Name
<th>
~label
â—
Labels

<tbody><tr><th colspan="2" scope="rowgroup">
`~~æ¨™æº–ã®ç¬¦å·åŒ–æ³•ï¼ #the-encoding$
â—
The Encoding
<tr><td>`UTF-8$n
<td>`unicode-1-1-utf-8^lb
`unicode11utf8^lb
`unicode20utf8^lb
`utf-8^lb
`utf8^lb
`x-unicode20utf8^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`æ—§æ¥ã®å˜-~byteç¬¦å·åŒ–æ³•ï¼ #legacy-single-byte-encodings$
â—
Legacy single-byte encodings
<tr><td>`IBM866$n
<td>`866^lb
`cp866^lb
`csibm866^lb
`ibm866^lb
<tr><td>`ISO-8859-2$n
<td>`csisolatin2^lb
`iso-8859-2^lb
`iso-ir-101^lb
`iso8859-2^lb
`iso88592^lb
`iso_8859-2^lb
`iso_8859-2:1987^lb
`l2^lb
`latin2^lb
<tr><td>`ISO-8859-3$n
<td>`csisolatin3^lb
`iso-8859-3^lb
`iso-ir-109^lb
`iso8859-3^lb
`iso88593^lb
`iso_8859-3^lb
`iso_8859-3:1988^lb
`l3^lb
`latin3^lb
<tr><td>`ISO-8859-4$n
<td>`csisolatin4^lb
`iso-8859-4^lb
`iso-ir-110^lb
`iso8859-4^lb
`iso88594^lb
`iso_8859-4^lb
`iso_8859-4:1988^lb
`l4^lb
`latin4^lb
<tr><td>`ISO-8859-5$n
<td>`csisolatincyrillic^lb
`cyrillic^lb
`iso-8859-5^lb
`iso-ir-144^lb
`iso8859-5^lb
`iso88595^lb
`iso_8859-5^lb
`iso_8859-5:1988^lb
<tr><td>`ISO-8859-6$n
<td>`arabic^lb
`asmo-708^lb
`csiso88596e^lb
`csiso88596i^lb
`csisolatinarabic^lb
`ecma-114^lb
`iso-8859-6^lb
`iso-8859-6-e^lb
`iso-8859-6-i^lb
`iso-ir-127^lb
`iso8859-6^lb
`iso88596^lb
`iso_8859-6^lb
`iso_8859-6:1987^lb
<tr><td>`ISO-8859-7$n
<td>`csisolatingreek^lb
`ecma-118^lb
`elot_928^lb
`greek^lb
`greek8^lb
`iso-8859-7^lb
`iso-ir-126^lb
`iso8859-7^lb
`iso88597^lb
`iso_8859-7^lb
`iso_8859-7:1987^lb
`sun_eu_greek^lb
<tr><td>`ISO-8859-8$n
<td>`csiso88598e^lb
`csisolatinhebrew^lb
`hebrew^lb
`iso-8859-8^lb
`iso-8859-8-e^lb
`iso-ir-138^lb
`iso8859-8^lb
`iso88598^lb
`iso_8859-8^lb
`iso_8859-8:1988^lb
`visual^lb
<tr><td>`ISO-8859-8-I$n
<td>`csiso88598i^lb
`iso-8859-8-i^lb
`logical^lb
<tr><td>`ISO-8859-10$n
<td>`csisolatin6^lb
`iso-8859-10^lb
`iso-ir-157^lb
`iso8859-10^lb
`iso885910^lb
`l6^lb
`latin6^lb
<tr><td>`ISO-8859-13$n
<td>`iso-8859-13^lb
`iso8859-13^lb
`iso885913^lb
<tr><td>`ISO-8859-14$n
<td>`iso-8859-14^lb
`iso8859-14^lb
`iso885914^lb
<tr><td>`ISO-8859-15$n
<td>`csisolatin9^lb
`iso-8859-15^lb
`iso8859-15^lb
`iso885915^lb
`iso_8859-15^lb
`l9^lb
<tr><td>`ISO-8859-16$n
<td>`iso-8859-16^lb
<tr><td>`KOI8-R$n
<td>`cskoi8r^lb
`koi^lb
`koi8^lb
`koi8-r^lb
`koi8_r^lb
<tr><td>`KOI8-U$n
<td>`koi8-ru^lb
`koi8-u^lb
<tr><td>`macintosh$n
<td>`csmacintosh^lb
`mac^lb
`macintosh^lb
`x-mac-roman^lb
<tr><td>`windows-874$n
<td>`dos-874^lb
`iso-8859-11^lb
`iso8859-11^lb
`iso885911^lb
`tis-620^lb
`windows-874^lb
<tr><td>`windows-1250$n
<td>`cp1250^lb
`windows-1250^lb
`x-cp1250^lb
<tr><td>`windows-1251$n
<td>`cp1251^lb
`windows-1251^lb
`x-cp1251^lb
<tr><td>`windows-1252$n
<td>`ansi_x3.4-1968^lb
`ascii^lb
`cp1252^lb
`cp819^lb
`csisolatin1^lb
`ibm819^lb
`iso-8859-1^lb
`iso-ir-100^lb
`iso8859-1^lb
`iso88591^lb
`iso_8859-1^lb
`iso_8859-1:1987^lb
`l1^lb
`latin1^lb
`us-ascii^lb
`windows-1252^lb
`x-cp1252^lb
<tr><td>`windows-1253$n
<td>`cp1253^lb
`windows-1253^lb
`x-cp1253^lb
<tr><td>`windows-1254$n
<td>`cp1254^lb
`csisolatin5^lb
`iso-8859-9^lb
`iso-ir-148^lb
`iso8859-9^lb
`iso88599^lb
`iso_8859-9^lb
`iso_8859-9:1989^lb
`l5^lb
`latin5^lb
`windows-1254^lb
`x-cp1254^lb
<tr><td>`windows-1255$n
<td>`cp1255^lb
`windows-1255^lb
`x-cp1255^lb
<tr><td>`windows-1256$n
<td>`cp1256^lb
`windows-1256^lb
`x-cp1256^lb
<tr><td>`windows-1257$n
<td>`cp1257^lb
`windows-1257^lb
`x-cp1257^lb
<tr><td>`windows-1258$n
<td>`cp1258^lb
`windows-1258^lb
`x-cp1258^lb
<tr><td>`x-mac-cyrillic$n
<td>`x-mac-cyrillic^lb
`x-mac-ukrainian^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`æ—§æ¥ã®è¤‡-~byte~Chineseï¼ˆç°¡ä½“å­—ï¼‰ ç¬¦å·åŒ–æ³•ï¼ #legacy-multi-byte-chinese-(simplified)-encodings$
â—
Legacy multi-byte Chinese (simplified) encodings
<tr><td>`GBK$n
<td>`chinese^lb
`csgb2312^lb
`csiso58gb231280^lb
`gb2312^lb
`gb_2312^lb
`gb_2312-80^lb
`gbk^lb
`iso-ir-58^lb
`x-gbk^lb
<tr><td>`gb18030$n
<td>`gb18030^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`æ—§æ¥ã®è¤‡-~byte~Chineseï¼ˆç¹ä½“å­—ï¼‰ç¬¦å·åŒ–æ³•ï¼ #legacy-multi-byte-chinese-(traditional)-encodings$
â—
Legacy multi-byte Chinese (traditional) encodings
<tr><td>`Big5$n
<td>`big5^lb
`big5-hkscs^lb
`cn-big5^lb
`csbig5^lb
`x-x-big5^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`æ—§æ¥ã®è¤‡-~byte~Japaneseç¬¦å·åŒ–æ³•ï¼ #legacy-multi-byte-japanese-encodings$
â—
Legacy multi-byte Japanese encodings
<tr><td>`EUC-JP$n
<td>`cseucpkdfmtjapanese^lb
`euc-jp^lb
`x-euc-jp^lb
<tr><td>`ISO-2022-JP$n
<td>`csiso2022jp^lb
`iso-2022-jp^lb
<tr><td>`Shift_JIS$n
<td>`csshiftjis^lb
`ms932^lb
`ms_kanji^lb
`shift-jis^lb
`shift_jis^lb
`sjis^lb
`windows-31j^lb
`x-sjis^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`æ—§æ¥ã®è¤‡-~byte~Koreanç¬¦å·åŒ–æ³•ï¼ #legacy-multi-byte-korean-encodings$
â—
Legacy multi-byte Korean encodings
<tr><td>`EUC-KR$n
<td>`cseuckr^lb
`csksc56011987^lb
`euc-kr^lb
`iso-ir-149^lb
`korean^lb
`ks_c_5601-1987^lb
`ks_c_5601-1989^lb
`ksc5601^lb
`ksc_5601^lb
`windows-949^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`æ—§æ¥ã®è«¸ã€…ã®ç¬¦å·åŒ–æ³•ï¼ #legacy-miscellaneous-encodings$
â—
Legacy miscellaneous encodings
<tr><td>`replacement$n
<td>`csiso2022kr^lb
`hz-gb-2312^lb
`iso-2022-cn^lb
`iso-2022-cn-ext^lb
`iso-2022-kr^lb
`replacement^lb
<tr><td>`UTF-16BE$n
<td>`unicodefffe^lb
`utf-16be^lb
<tr><td>`UTF-16LE$n
<td>`csunicode^lb
`iso-10646-ucs-2^lb
`ucs-2^lb
`unicode^lb
`unicodefeff^lb
`utf-16^lb
`utf-16le^lb
<tr><td>`x-user-defined$n
<td>`x-user-defined^lb
</table>

<p class="note">æ³¨è¨˜ï¼š
ã™ã¹ã¦ã®`ç¬¦å·åŒ–æ³•$ã¨ãã‚Œã‚‰ç”¨ã®`~label$ã¯ã€
è¦ç¯„çš„ã§ãªã„è³‡æº
`indexes.json$
ã¨ã—ã¦ã‚‚å¯ç”¨ã§ã‚ã‚‹ã€‚
â—
All encodings and their labels are also available as non-normative encodings.json resource.
</p>

<p class="note" id="supported-encodings">æ³¨è¨˜ï¼š
~supportã•ã‚Œã‚‹`ç¬¦å·åŒ–æ³•$ãŸã¡ãŒæˆã™é›†åˆã¯ã€
é¦–ã«ï¼»
ã“ã®æ¨™æº–ã®é–‹ç™ºã‚’é–‹å§‹ã—ãŸæ™‚ç‚¹ã§ï¼Œä¸»è¦ãªå„~browser~engineãŒ~supportã—ã¦ã„ãŸé›†åˆ
ï¼½ãŸã¡ã®äº¤å·®é›†åˆã«åŸºã¥ããŒï¼Œç¬¦å·åŒ–æ³•ã®ã†ã¡ï¼»
ç¨€ã«ã—ã‹æ­£å½“ã«åˆ©ç”¨ã•ã‚Œã¦ã„ãªã„
ï¼½ã‹ã¤ï¼»
æ”»æ’ƒã«ã‚‚åˆ©ç”¨ã•ã‚Œå¾—ã‚‹
ï¼½ã‚‚ã®ã¯é™¤å»ã—ã¦ã‚ã‚‹ã€‚
ä¸€éƒ¨ã®ç¬¦å·åŒ–æ³•ã«ã¤ã„ã¦ã¯ã€
æ—¢å­˜ã®~Webå†…å®¹ãŒåˆ©ç”¨ã—ã¦ã„ã‚‹~~ç¢ºãŸã‚‹è¨¼æ‹ ã¯ãªãï¼Œãã‚Œã‚’å«ã‚ã‚‹ã“ã¨ã«ã¯ç–‘å•ãŒã‚ã‚‹ã€‚
ã™ãªã‚ã¡ã€
ãã‚Œã‚‰ã¯ï¼Œå„~browserã‹ã‚‰åºƒã~supportã•ã‚Œã¦ã„ãŸãŒã€
~Webå†…å®¹ã‹ã‚‰åºƒãåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã¯ä¸æ˜ç­ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ãªãŒã‚‰ã€
`å˜-~byteç¬¦å·åŒ–æ³•$ã®ã†ã¡ï¼»
å„~browserãŒåºƒã~supportã—ã¦ã„ãŸã‚‚ã®ï¼
ISO 8859 ~~æ—ã®ä¸€éƒ¨ã‚’æˆã™ã‚‚ã®
ï¼½ã‚’æ„æ¬²çš„ã«é™¤å»ã™ã‚‹åŠ´ã¯ï¼Œç‚ºã•ã‚Œã¦ã„ãªã„ã€‚
ç‰¹ã«ï¼Œæ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ã‚’å«ã‚ã‚‹å¿…è¦æ€§ã¯ã€
æ—¢å­˜ã®å†…å®¹ã‚’~supportã™ã‚‹ç›®çš„ã«ãŠã„ã¦ã¯ç–‘ã‚ã—ã„ãŒï¼Œé™¤å»ã™ã‚‹è¨ˆç”»ã¯ç„¡ã„
â‡’ï¼ƒ
`IBM866$n,
`macintosh$n,
`x-mac-cyrillic$n,
`ISO-8859-3$n,
`ISO-8859-10$n,
`ISO-8859-14$n,
`ISO-8859-16$n
â—
The set of supported encodings is primarily based on the intersection of the sets supported by major browser engines when the development of this standard started, while removing encodings that were rarely used legitimately but that could be used in attacks. The inclusion of some encodings is questionable in the light of anecdotal evidence of the level of use by existing Web content. That is, while they have been broadly supported by browsers, it is unclear if they are broadly used by Web content. However, an effort has not been made to eagerly remove single-byte encodings that were broadly supported by browsers or are part of the ISO 8859 series. In particular, the necessity of the inclusion of IBM866, macintosh, x-mac-cyrillic, ISO-8859-3, ISO-8859-10, ISO-8859-14, and ISO-8859-16 is doubtful for the purpose of supporting existing content, but there are no plans to remove these.
</p>

		</section>
		<section id="output-encodings">
<h3 title="Output encodings">4.3. å‡ºåŠ›~ç¬¦å·åŒ–æ³•</h3>

<div class="algo">
<p>
`ç¬¦å·åŒ–æ³•ã‹ã‚‰å‡ºåŠ›~ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `ç¬¦å·åŒ–æ³•$ %ç¬¦å·åŒ–æ³• )
ã«å¯¾ã—ï¼š
â—
To get an output encoding from an encoding encoding, run these steps:
</p>
<ol>
	<li>
~IFï¼»
%ç¬¦å·åŒ–æ³• ~IN
{ `replacement$n, `UTF-16BE$n, `UTF-16LE$nã€ï¼`UTF-16BE/LE$nã€‘ }
ï¼½
â‡’
~RET `UTF-8$n
â—
If encoding is replacement or UTF-16BE/LE, then return UTF-8.
</li>
	<li>
~RET %ç¬¦å·åŒ–æ³•
â—
Return encoding.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®~algoã¯ã€
ãã‚Œã‚’å¿…è¦ã¨ã™ã‚‹ï¼»
~URLæ§‹æ–‡è§£æ ï¼ ~HTML~formæå‡º
ï¼½ã«ã¦æœ‰ç”¨ã«ãªã‚‹ã€‚
â—
The get an output encoding algorithm is useful for URL parsing and HTML form submission, which both need exactly this.
</p>
</div>

		</section>
	</section>
	<section id="indexes">
<h2 title="Indexes">5. ç´¢å¼•</h2>

<p>
ã»ã¨ã‚“ã©ã®æ—§æ¥ã®`ç¬¦å·åŒ–æ³•$ã§ã¯ã€
ã€å½“ã®ç¬¦å·åŒ–æ³•ã«ç‰¹æœ‰ãªã€‘
`ç´¢å¼•@
ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
`ç´¢å¼•$ã¨ã¯ã€
~entryãŸã¡ãŒæˆã™æœ‰é †åº~listã§ã‚ã‚Šï¼Œãã‚Œã‚’æˆã™å„~entryã¯ï¼»
~pointer, ãã‚Œã«å¯¾å¿œã™ã‚‹~cp
ï¼½ã‹ã‚‰ãªã‚‹ã€‚
`ç´¢å¼•$ã®ä¸­ã§ã¯ã€
~pointerã¯ä¸€æ„ã§ã‚ã‚Šï¼Œ~cpã¯é‡è¤‡ã—å¾—ã‚‹ã€‚
â—
Most legacy encodings make use of an index. An index is an ordered list of entries, each entry consisting of a pointer and a corresponding code point. Within an index pointers are unique and code points can be duplicated.
</p>

<p class="note">æ³¨è¨˜ï¼š
åŠ¹ç‡çš„ãªå®Ÿè£…ã¯ã€
å„`ç¬¦å·åŒ–æ³•$ã«å¯¾ã—ï¼Œ
2 ã¤ã®`ç´¢å¼•$
â€” ãã®`å¾©å·å™¨$ã«æœ€é©åŒ–ã•ã‚ŒãŸãã‚Œ, ãã®`ç¬¦å·åŒ–å™¨$ã«æœ€é©åŒ–ã•ã‚ŒãŸãã‚Œ â€”
ã‚’å‚™ãˆã‚‹ã“ã¨ã«ãªã‚ã†ã€‚
â—
An efficient implementation likely has two indexes per encoding. One optimized for its decoder and one for its encoder.
</p>

<div class="algo">
<p>
`ç´¢å¼•$
ã€ã®~dataã‚’ä¾›ã™ã‚‹è³‡æºï¼ˆä»¥ä¸‹ã‚’è¦‹ã‚ˆï¼‰ã€‘
ã‹ã‚‰ï¼Œ~pointerã¨ãã‚Œã«å¯¾å¿œã™ã‚‹~cpã‚’è¦‹å‡ºã™ãŸã‚ã«ã¯ï¼š
</p>
<ol>
	<li>
%è¡Œl~list ã¯ï¼Œãã®è³‡æºã®å†…å®¹ã‚’ `000A^U `LF^cn ã§ä¸€é€£ã® â€œè¡Œlâ€ ã«åˆ†å‰²ã—ãŸçµæœã¨ã™ã‚‹ã€‚
</li>
	<li>
%è¡Œl~list ã‹ã‚‰ï¼»
ç©º~è¡Œl ï¼ `0023^U `#^smb ã§é–‹å§‹ã•ã‚Œã‚‹è¡Œl
ï¼½ã‚’ã™ã¹ã¦é™¤å»ã™ã‚‹ã€‚
</li>
	<li>
<p>
%è¡Œl~list ã®å„~è¡Œlã«å¯¾ã—ï¼Œè¡Œlã‚’ `0009^U `TAB^cn ã§åˆ†å‰²ã—ãŸçµæœã‚’æˆã™ï¼š
</p>
		<ul>
			<li>
1 å€‹ç›®ã®~itemãŒ~pointerï¼ˆ 10 é€²è¡¨è¨˜ï¼‰ã‚’ä¸ãˆã‚‹ã€‚
</li>
			<li>
2 å€‹ç›®ã®~itemãŒå¯¾å¿œã™ã‚‹~cpï¼ˆ 16 é€²è¡¨è¨˜ï¼‰ã‚’ä¸ãˆã‚‹ã€‚
</li>
			<li>
ä»–ã®~itemã¯é–¢é€£ã—ãªã„ã€‚
</li>
		</ul>
	</li>
</ol>

â—
To find the pointers and their corresponding code points in an index, let lines be the result of splitting the resourceâ€™s contents on U+000A LF. Then remove each item in lines that is the empty string or starts with U+0023 (#). Then the pointers and their corresponding code points are found by splitting each item in lines on U+0009 TAB. The first subitem is the pointer (as a decimal number) and the second is the corresponding code point (as a hexadecimal number). Other subitems are not relevant.
</div>

<p class="note">æ³¨è¨˜ï¼š
å„`ç´¢å¼•$ã®å†’é ­ã«ã¯ã€
å¤‰æ›´ã®æœ‰ç„¡ã‚’è¨˜ã™ãŸã‚ï¼Œ
`Identifier^i ã¨ `Date^i
ã€è­˜åˆ¥å­ã¨æ—¥ä»˜ã€‘
ãŒè¨˜ã•ã‚Œã¦ã„ã‚‹ã€‚
`Identifier^i ã®å¤‰åŒ–ã¯ã€
`ç´¢å¼•$ã«å¤‰æ›´ãŒåŠ ãˆã‚‰ã‚ŒãŸã“ã¨ã‚’è¡¨ã™ã€‚
â—
To signify changes an index includes an Identifier and a Date. If an Identifier has changed, so has the index.
</p>

<div class="algo">
%ç´¢å¼• ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™
`ç´¢å¼•~cp@
ã¨ã¯ã€
%ç´¢å¼• å†…ã« %~pointer ã¯ï¼»
åœ¨ã‚‹ãªã‚‰ã°ï¼Œãã‚Œã«å¯¾å¿œã™ã‚‹~cp ï¼
ç„¡ã„ãªã‚‰ã° ~NULL
ï¼½ã§ã‚ã‚‹ã€‚
â—
The index code point for pointer in index is the code point corresponding to pointer in index, or null if pointer is not in index.
</div>

<div class="algo">
%ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™
`ç´¢å¼•~pointer@
ã¨ã¯ã€
%ç´¢å¼• å†…ã« %~cp ã«å¯¾å¿œã™ã‚‹~pointerã¯ï¼»
åœ¨ã‚‹ãªã‚‰ã°ï¼Œãã‚Œã‚‰ã®ã†ã¡`æœ€åˆã®^em ~pointer ï¼
ç„¡ã„ãªã‚‰ã° ~NULL
ï¼½ã§ã‚ã‚‹ã€‚
â—
The index pointer for codePoint in index is the first pointer corresponding to codePoint in index, or null if codePoint is not in index.
</div>

<div class="note" id="visualization">
<p>æ³¨è¨˜ï¼š
å„ ç´¢å¼•ã«ã¯ï¼Œè¦ç¯„çš„ã§ãªã„è¦–è¦š-åŒ–ãŒã‚ã‚Šã€
`ç´¢å¼•~jis0208$ã«ã¯ï¼Œ `Shift_JIS$n è¦–è¦š-åŒ–ã‚‚åˆ¥ã«ã‚ã‚‹ã€‚
åŠ ãˆã¦ï¼ŒåŸºæœ¬å¤šè¨€èªé¢ï¼ˆ
BMPï¼ˆ `Basic Multilingual Plane^en ï¼‰,
`0000^U ã€œ `FFFF^U
ï¼‰ã«ãŠã‘ã‚‹è¢«è¦†åŸŸã®è¦–è¦š-åŒ–ã‚‚ã‚ã‚‹ã€‚
ãŸã ã—ã€ï¼»
`ç´¢å¼•~gb18030ç¯„å›²~ç¾¤$ ï¼ `ç´¢å¼•~ISO-2022-JP~katakana$
ï¼½ã«ã¯ï¼Œã“ã‚Œã‚‰ã®è¦–è¦š-åŒ–ã¯ãªã„ã€‚
â—
There is a non-normative visualization for each index other than index gb18030 ranges and index ISO-2022-JP katakana. index jis0208 also has an alternative Shift_JIS visualization. Additionally, there is visualization of the Basic Multilingual Plane coverage of each index other than index gb18030 ranges and index ISO-2022-JP katakana.
</p>

<table>
<caption>
è¦–è¦š-åŒ–ã«ãŠã‘ã‚‹å‡¡ä¾‹
â—
The legend for the visualizations is:
</caption>
<thead>
<tr><th>è¡¨ç¤º
<th>~~èª¬æ˜

<tbody class="_vis-visualizationlegend">
<tr><td><div class="_vis-unmapped"></div><td>
å¯¾å¿œã™ã‚‹~cpã¯ç„¡ã„ã€‚
â—
Unmapped

<tr><td><div class="_vis-mid"></div><td>
~UTF-8ã§ 2 ~byteã€‚
â—
Two bytes in UTF-8

<tr><td><div class="_vis-mid _vis-contiguous"></div><td>
~UTF-8ã§ 2 ~byte, ã‹ã¤
~cpã¯ã€
å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Two bytes in UTF-8, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-upper"></div><td>
~UTF-8ã§ 3 ~byteï¼ˆç§ç”¨é ˜åŸŸã§ãªã„ï¼‰
â—
Three bytes in UTF-8 (non-PUA)

<tr><td><div class="_vis-upper _vis-contiguous"></div><td>
~UTF-8ã§ 3 ~byteï¼ˆç§ç”¨é ˜åŸŸã§ãªã„ï¼‰, ã‹ã¤
~cpã¯ã€
å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Three bytes in UTF-8 (non-PUA), code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-pua"></div><td>
ç§ç”¨é ˜åŸŸ
â—
Private Use

<tr><td><div class="_vis-pua _vis-contiguous"></div><td>
ç§ç”¨é ˜åŸŸ, ã‹ã¤
~cpã¯ã€
å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Private Use, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-astral"></div><td>
~UTF-8ã§ 4 ~byte
â—
Four bytes in UTF-8

<tr><td><div class="_vis-astral _vis-contiguous"></div><td>
~UTF-8ã§ 4 ~byte, ã‹ã¤
~cpã¯ã€
å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Four bytes in UTF-8, code point follows immediately the code point
of previous pointer

<tr><td><div class="_vis-duplicate"></div><td>
å…ˆã«ç¾ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨é‡è¤‡ã™ã‚‹~cpã«å¯¾å¿œã™ã‚‹ã€‚
â—
Duplicate code point already mapped at an earlier index

<tr><td><div class="_vis-compatibility"></div><td>
~CJKäº’æ›æ¼¢å­—ï¼ˆ `CJK Compatibility Ideograph^en ï¼‰
â—
CJK Compatibility Ideograph

<tr><td><div class="_vis-ext"></div><td>
~CJKçµ±åˆæ¼¢å­—æ‹¡å¼µ A
â—
CJK Unified Ideographs Extension A
</table>

</div>

<p>
ã“ã®ä»•æ§˜ãŒå®šç¾©ã™ã‚‹`ç´¢å¼•$ã®ã†ã¡ï¼Œ`å˜-~byteç´¢å¼•$ã§ãªã„ã‚‚ã®ã«ã¯ã€
ãã‚Œãã‚Œã«è‡ªå‰ã®~tableãŒã‚ã‚Šï¼Œä»¥ä¸‹ã«ä¸ãˆã‚‰ã‚Œã‚‹ï¼š
ã€è¦–è¦š-åŒ–ï¼è¢«è¦†åŸŸã®~tableã¯å·¨å¤§ãªã“ã¨ã«æ³¨æ„ã€‘
â—
These are the indexes defined by this specification, excluding index single-byte, which have their own table:
</p>

<table id="_index_list" class="grid-table"><thead>
<tr><th>`åå‰$
<th>`ç´¢å¼•$
<th>è¦–è¦š-åŒ–
<th>åŸºæœ¬å¤šè¨€èªé¢ï¼ˆ BMP ï¼‰ã®è¢«è¦†åŸŸ
<th>å‚™è€ƒ
<tbody>

<tr><td>`ç´¢å¼•~Big5@
<td>`Big5$idx
<td>
ã“ã‚Œã¯ã€
é¦™æ¸¯å¢—è£œå­—ç¬¦é›†ï¼ˆ `Hong Kong Supplementary Character Set^en ï¼‰, ãŠã‚ˆã³ä»–ã®å…±é€šãªæ‹¡å¼µã¨ä¸€å¼ã§ã€
~Big5æ¨™æº–ã«åˆè‡´ã™ã‚‹ã€‚
â—
This matches the Big5 standard in combination with the Hong Kong Supplementary Character Set and other common extensions.

<tr><td>`ç´¢å¼•~EUC-KR@
<td>`EUC-KR$idx
<td>
ã“ã‚Œã¯ã€
KS X 1001 æ¨™æº–ã¨~~çµ±åˆ~Hangul~codeï¼ˆ `Unified Hangul Code^en ï¼‰ã«åˆè‡´ã™ã‚‹ã€‚
Windows Codepage 949 ã¨ã—ã¦ã‚‚å…±é€šçš„ã«çŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
ã“ã‚Œå…¨ä½“ã§ã€
~Unicodeã®~HanguléŸ³ç¯€æ–‡å­—ï¼ˆ `Hangul Syllables^en ï¼‰~blockã‚’è¦†ã†ã€‚
~Hangul~blockã®ã†ã¡ï¼Œè¦–è¦š-åŒ–ã«ãŠã‘ã‚‹å·¦ä¸Šéš…ãŒ~pointer 9026 ã«ã‚ã‚‹ã‚‚ã®
ã€ï¼Ÿã€‘
ã¯ã€
~Unicodeé †ã«ä¸¦ã¶ã€‚
`Taken separately^en ã€ï¼Ÿã€‘,
ã“ã®ç´¢å¼•ã«ãŠã‘ã‚‹æ®‹ã‚Šã®~HanguléŸ³ç¯€æ–‡å­—ã‚‚ã€
~Unicodeé †ã«ä¸¦ã¶ã€‚
â—
This matches the KS X 1001 standard and the Unified Hangul Code, more commonly known together as Windows Codepage 949. It covers the Hangul Syllables block of Unicode in its entirety. The Hangul block whose top left corner in the visualization is at pointer 9026 is in the Unicode order. Taken separately, the rest of the Hangul syllables in this index are in the Unicode order, too.

<tr><td>`ç´¢å¼•~gb18030@
<td>`gb18030$idx
<td>
ã“ã‚Œã¯ã€
2 ~byteã«ç¬¦å·åŒ–ã•ã‚Œã‚‹~cpç”¨ã® GB18030-2022 æ¨™æº–ã«åˆè‡´ã™ã‚‹
â€” ãŸã ã—ï¼Œé…å‚™-æ¸ˆã¿ãªå†…å®¹ã¨äº’æ›ã«ãªã‚‹ã‚ˆã†ã€
`A3^X `A0^X ã¯ `3000^U ã«å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
ã“ã®ç´¢å¼•~å…¨ä½“ã§ã€
~Unicodeã®~CJKçµ±åˆæ¼¢å­—ï¼ˆ `CJK Unified Ideographs^en ï¼‰~blockã‚’è¦†ã†ã€‚
ãã®~blockå†…ã®~entryã®ã†ã¡ï¼Œè¦–è¦š-åŒ–ã«ãŠã‘ã‚‹ï¼ˆæœ€åˆã®ï¼‰ `3000^U ã‚ˆã‚Šä¸Šã¾ãŸã¯å·¦ã«ã‚ã‚‹ã‚‚ã®ã¯ã€
~Unicodeé †ã«ä¸¦ã¶ã€‚
â—
This matches the GB18030-2022 standard for code points encoded as two bytes, except for 0xA3 0xA0 which maps to U+3000 to be compatible with deployed content. This index covers the CJK Unified Ideographs block of Unicode in its entirety. Entries from that block that are above or to the left of (the first) U+3000 in the visualization are in the Unicode order.

<tr><td>`ç´¢å¼•~gb18030ç¯„å›²~ç¾¤@
<td>`gb18030-ranges$idx
<td>
ã“ã®`ç´¢å¼•$ã¯ã€
ã™ã¹ã¦ã®~cpã‚’æŒ™ã’ã¦ã„ãã¨é …ç›®æ•°ãŒ 100 ä¸‡ã‚’è¶…ãˆã¦ã—ã¾ã†ç‚¹ã§ï¼Œä»–ã®ã™ã¹ã¦ã¨ç•°ãªã‚‹
ï¼ˆ 207 é¢ã®ç¯„å›²ã¨è‡ªæ˜ãªç¯„å›²æ¤œæŸ»ã«ã‚ˆã‚Šï¼Œãã‚Œã„ã«è¡¨ç¾ã§ãã‚‹ãŒï¼‰ã€‚
ã—ãŸãŒã£ã¦ã€
4 ~byteã«ç¬¦å·åŒ–ã•ã‚Œã‚‹~cpç”¨ã«é™ã‚Šï¼Œè¡¨é¢çš„ã«ã¯ GB18030-2000 æ¨™æº–ã«åˆè‡´ã™ã‚‹ã€‚
ãã®æ”¹è¨‚ GB18030-2005 ç”¨ã®å¤‰æ›´ã¯ã€
ã“ã®ç´¢å¼•ãŒä»˜éšã™ã‚‹ï¼»
`ç´¢å¼•~gb18030ç¯„å›²~ç¾¤~cp$, `ç´¢å¼•~gb18030ç¯„å›²~ç¾¤~pointer$
ï¼½ç”¨ã®~algoã«ã‚ˆã‚Šï¼Œ~inlineã«å–æ‰±ã‚ã‚Œã‚‹ã€‚
ãã®æ”¹è¨‚ GB18030-2022 ç”¨ã®å¤‰æ›´ã«é–¢ã™ã‚‹å–æ‰±ã„ã‚‚ã€
ç§ç”¨é ˜åŸŸã«å±ã™ã‚‹~cpã¸å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã‚‹~byteåˆ—ã®å€‹æ•°ã‚’ã“ã‚Œä»¥ä¸Š~å¢—ã‚„ã•ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ï¼Œä»–ã¨ç•°ãªã‚‹
â€” é–¢é€£ãªï¼»
ç§ç”¨é ˜åŸŸã«å±ã™ã‚‹å„~cp
ï¼½ã¯ã€
ãã‚Œã¾ã§ã®å¯¾å¿œä»˜ã‘ã¨ã®äº’æ›æ€§ã‚’ä¿å…¨ã™ã‚‹ã‚ˆã†ï¼Œ
`~gb18030ç¬¦å·åŒ–å™¨$ã«ãŠã„ã¦ ã‚ã‚‹è¡¨tã‚’é€šã—ã¦ç›´ã«å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
â—
This index works different from all others. Listing all code points would result in over a million items whereas they can be represented neatly in 207 ranges combined with trivial limit checks. It therefore only superficially matches the GB18030-2000 standard for code points encoded as four bytes. The change for the GB18030-2005 revision is handled inline by the index gb18030 ranges code point and index gb18030 ranges pointer algorithms below that accompany this index. And the changes for the GB18030-2022 revision are handled differently again to not further increase the number of byte sequences mapping to Private Use code points. The relevant Private Use code points are mapped in the gb18030 encoder directly through a side table to preserve compatibility with how they were mapped before.

<tr><td>`ç´¢å¼•~jis0208@
<td>`jis0208$idx
<td>
IBM ã¨ NEC ã«ã‚ˆã‚‹ã‹ã¤ã¦ã®~proprietaryæ‹¡å¼µã‚‚å«ã¾ã‚Œã¦ã„ã‚‹ï¼Œ JIS X 0208 æ¨™æº–ã€‚
â—
This is the JIS X 0208 standard including formerly proprietary extensions from IBM and NEC.

<tr><td>`ç´¢å¼•~jis0212@
<td>`jis0212$idx
<td>
JIS X 0212 æ¨™æº–ã€‚
ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã®ã¯ã€
`~EUC-JPå¾©å·å™¨$ã«é™ã‚‰ã‚Œã‚‹
ï¼ˆç¬¦å·åŒ–å™¨ã‹ã‚‰ã¯åˆ©ç”¨ã•ã‚Œãªã„ï¼‰
â€” åºƒã~supportã•ã‚Œã¦ã„ãªã„ã®ã§ã€‚
â—
This is the JIS X 0212 standard. It is only used by the EUC-JP decoder due to lack of widespread support elsewhere.

<tr><td>`ç´¢å¼•~ISO-2022-JP~katakana@
<td>`iso-2022-jp-katakana$idx
<td>
ã“ã‚Œã¯ã€
~Unicodeæ­£è¦åŒ–~å½¢ï¼ˆ `Normalization Form^en ï¼‰ KC ã«å¾“ã£ã¦ï¼ŒåŠè§’~katakanaã‚’å…¨è§’~katakanaã«å¯¾å¿œä»˜ã‘ã‚‹ã€‚
ãŸã ã—ã€ï¼»
`FF9E^U ï¼ `FF9F^U
ï¼½ã¯ï¼»
`309B^U ï¼ `309C^U
ï¼½ã«å¯¾å¿œä»˜ã‘ã‚‹
â€” ï¼»
`3099^U ï¼ `309A^U
ï¼½ã§ã¯ãªã
ã€ã“ã‚Œã‚‰ã¯ã„ãšã‚Œã‚‚ã€æ¿ç‚¹ï¼åŠæ¿ç‚¹ã€‘
ã€‚
ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã®ã¯ã€
`~ISO-2022-JPç¬¦å·åŒ–å™¨$ã«é™ã‚‰ã‚Œã‚‹ã€‚
`UNICODE$r
â—
This maps halfwidth to fullwidth katakana as per Unicode Normalization Form KC, except that U+FF9E and U+FF9F map to U+309B and U+309C rather than U+3099 and U+309A. It is only used by the ISO-2022-JP encoder. [UNICODE]
</table>

<div class="algo">
<p>
%~pointer ãŒæŒ‡ã™
`ç´¢å¼•~gb18030ç¯„å›²~ç¾¤~cp@
ã¯ã€
æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~cpã§ã‚ã‚‹ï¼š
â—
The index gb18030 ranges code point for pointer is the return value of these steps:
</p>
<ol>
	<li>
~IFï¼»
39419 ~LT %~pointer ~LT 189000
ï¼½~ORï¼»
1237575 ~LT %~pointer
ï¼½
â‡’
~RET ~NULL
â—
If pointer is greater than 39419 and less than 189000, or pointer is greater than 1237575, then return null.
</li>
	<li>
~IFï¼»
%~pointer ~EQ 7457
ï¼½
â‡’
~RET ~cp `E7C7^U
â—
If pointer is 7457, then return code point U+E7C7.
</li>
	<li>
%~offset ~LET `ç´¢å¼•~gb18030ç¯„å›²~ç¾¤$ã®ä¸­ã§ %~pointer ã‚’è¶…ãˆãªã„æœ€å¾Œã®~pointer
â—
Let offset be the last pointer in index gb18030 ranges that is less than or equal to pointer and let code point offset be its corresponding code point.
</li>
	<li>
%~cp~offset ~LET %~offset ãŒæŒ‡ã—ã¦ã„ã‚‹~cp
â—
â†‘</li>
	<li>
~RET å€¤ãŒï¼»
%~cp~offset ~PLUS %~pointer ~MINUS %~offset
ï¼½ãªã‚‹~cp
â—
Return a code point whose value is code point offset + pointer âˆ’ offset.
</li>
</ol>
</div>

<div class="algo">
<p>
%~cp ã‚’æŒ‡ã™
`ç´¢å¼•~gb18030ç¯„å›²~ç¾¤~pointer@
ã¯ã€
æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index gb18030 ranges pointer for codePoint is the return value of these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `E7C7^U
ï¼½
â‡’
~RET ~pointer 7457
â—
If codePoint is U+E7C7, then return pointer 7457.
</li>
	<li>
%~offset ~LET `ç´¢å¼•~gb18030ç¯„å›²~ç¾¤$ã®ä¸­ã§ %~cp ã‚’è¶…ãˆãªã„æœ€å¾Œã®~cp
â—
Let offset be the last code point in index gb18030 ranges that is less than or equal to codePoint and let pointer offset be its corresponding pointer.
</li>
	<li>
%~pointer~offset ~LET %~offset ã«å¯¾å¿œã™ã‚‹~pointer
â—
â†‘</li>
	<li>
~RET å€¤ãŒï¼»
%~pointer~offset ~PLUS %~cp ~MINUS %~offset
ï¼½ãªã‚‹~pointer
â—
Return a pointer whose value is pointer offset + codePoint âˆ’ offset.
</li>
</ol>
</div>

<div class="algo">
<p>
%~cp ã‚’æŒ‡ã™
`ç´¢å¼•~Shift_JIS~pointer@
ã¯ã€
æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index Shift_JIS pointer for codePoint is the return value of these steps:
</p>
<ol>
	<li>
<p>
%ç´¢å¼• ~LET `ç´¢å¼•~jis0208$ ã‹ã‚‰ï¼»
~pointerãŒç¯„å›² { 8272 ã€œ 8835 } ã«å…¥ã‚‹~entry
ï¼½ã™ã¹ã¦ã‚’é™¤å¤–ã—ãŸç´¢å¼•
â—
Let index be index jis0208 excluding all entries whose pointer is in the range 8272 to 8835, inclusive.
</p>

<p class="note">æ³¨è¨˜ï¼š
`ç´¢å¼•~jis0208$ã¯ã€
é‡è¤‡ã™ã‚‹~cpã‚’åŒ…å«ã™ã‚‹ã®ã§ã€
ã“ã‚Œã‚‰ã®~entryã®é™¤å¤–ã«ã‚ˆã‚Šï¼Œå¾Œç¶šã®~cpãŒåˆ©ç”¨ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
The index jis0208 contains duplicate code points so the exclusion of these entries causes later code points to be used.
</p>
	</li>
	<li>
~RET %ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Return the index pointer for codePoint in index.
</li>
</ol>
</div>

<div class="algo">
<p>
%~cp ã‚’æŒ‡ã™
`ç´¢å¼•~Big5~pointer@
ã¯ã€
æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index Big5 pointer for codePoint is the return value of these steps:
</p>
<ol>
	<li>
<p>
%ç´¢å¼• ~LET `ç´¢å¼•~Big5$ã‹ã‚‰ï¼»
~pointerãŒ ( (`A1^X ~MINUS `81^X) ~MUL 157 ) æœªæº€ã®~entry
ï¼½ã™ã¹ã¦ã‚’é™¤å¤–ã—ãŸç´¢å¼•
â—
Let index be index Big5 excluding all entries whose pointer is less than (0xA1 - 0x81) Ã— 157.
</p>

<p class="note">æ³¨è¨˜ï¼š
é¦™æ¸¯å¢—è£œå­—ç¬¦é›†ï¼ˆ `Hong Kong Supplementary Character Set^en ï¼‰æ‹¡å¼µã‚’~literalã¨ã—ã¦è¿”ã•ãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚
â—
Avoid returning Hong Kong Supplementary Character Set extensions literally.
</p>
	</li>
	<li>
<p>
~IFï¼»
%~cp ~IN
{ `2550^U, `255E^U, `2561^U, `256A^U, `5341^U, `5345^U }
ï¼½
â‡’
~RET
%ç´¢å¼• ã®ä¸­ã§ %~cp ã«å¯¾å¿œã™ã‚‹`æœ€å¾Œã®^em ~pointer
â—
If codePoint is U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345, return the last pointer corresponding to codePoint in index.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä»–ã«ã‚‚é‡è¤‡ã—ã¦ã„ã‚‹~cpã¯ã‚ã‚‹ãŒã€
ãã‚Œã‚‰ç”¨ã«ã¯ï¼Œ`æœ€åˆã®^em ~pointerãŒåˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
There are other duplicate code points, but for those the first pointer is to be used.
</p>
	</li>
	<li>
~RET
%ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Return the index pointer for codePoint in index.
</li>
</ol>
</div>

<hr>

<p class="note">æ³¨è¨˜ï¼š
ã™ã¹ã¦ã®`ç´¢å¼•$ã¯ã€
è¦ç¯„çš„ã§ãªã„è³‡æº
`indexes.json$
ã¨ã—ã¦ã‚‚å¯ç”¨ã§ã‚ã‚‹
ï¼ˆ`ç´¢å¼•~gb18030ç¯„å›²~ç¾¤$ã®å½¢å¼ã¯ã€
ç¯„å›²ã‚’è¡¨ç¾ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ï¼Œå°‘ã—ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ï¼‰ã€‚
â—
All indexes are also available as a non-normative indexes.json resource. (Index gb18030 ranges has a slightly different format here, to be able to represent ranges.)
</p>

	</section>
	<section id="specification-hooks">
<h2 title="Hooks for standards">6. ä»–ã®æ¨™æº–~ç”¨ã®~hook</h2>

<div class="note">

<p>æ³¨è¨˜ï¼š
æ¬¡ã«æŒ™ã’ã‚‹å„ç¨®~algoï¼ˆä»¥ä¸‹ã«å®šç¾©ã•ã‚Œã‚‹ï¼‰ã¯ã€
ä»–ã®ä»•æ§˜ã‹ã‚‰ã®~~åˆ©ç”¨ãŒæ„å›³ã•ã‚Œã¦ã„ã‚‹ï¼š
â—
The algorithms defined below (UTF-8 decode, UTF-8 decode without BOM, UTF-8 decode without BOM or fail, and UTF-8 encode) are intended for usage by other standards.
</p>

<ul>
	<li>
`~UTF-8å¾©å·ã™ã‚‹$
â‡’
æ–°ãŸãªå½¢å¼ã¯ã€
å¾©å·ã™ã‚‹ã¨ãã¯ï¼Œã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨
ï¼ˆæ¬¡é …ã¯åˆ¥ã¨ã—ã¦ï¼‰ã€‚
â—
For decoding, UTF-8 decode is to be used by new formats.ï¼¼
</li>
	<li>
`~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$ï¼
`~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$
â‡’
å½¢å¼ã‚„~protocolã®ä¸­ã®è­˜åˆ¥å­ã‚„~byteåˆ—~ç”¨ã«ã¯ã€
ã“ã‚Œã‚‰ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã€‚
â—
For identifiers or byte sequences within a format or protocol, use UTF-8 decode without BOM or UTF-8 decode without BOM or fail.
</li>
	<li>
`~UTF-8ç¬¦å·åŒ–ã™ã‚‹$
â‡’
ç¬¦å·åŒ–ã™ã‚‹ã¨ãã¯ã€
ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã€‚
â—
For encoding, UTF-8 encode is to be used.
</li>
</ul>

<p>
å„~æ¨™æº–ã¯ã€
`~UTF-8ç¬¦å·åŒ–ã™ã‚‹$ï¼ˆãŠã‚ˆã³ï¼Œæ—§æ¥ã®`ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹$ï¼‰~algoã«æ¸¡ã™ï¼»
å…¥åŠ›~ç”¨ã®`å…¥å‡ºåŠ›~queue$â€ 
ï¼½ãŒï¼Œå®Ÿè³ªçš„ã«ã¯`~scalarå€¤$ãŒæˆã™å…¥å‡ºåŠ›~queueã§ã‚ã‚‹
â€” ã™ãªã‚ã¡`~surrogate$ã¯åŒ…å«ã—ãªã„ â€”
ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹ã“ã¨ã€‚
â—
Standards are to ensure that the input I/O queues they pass to UTF-8 encode (as well as the legacy encode) are effectively I/O queues of scalar values, i.e., they contain no surrogates.
</p>

<p>
ã“ã‚Œã‚‰ã®~hook
ï¼ˆãŠã‚ˆã³ï¼Œ`~Unicodeã«å¾©å·ã™ã‚‹$, `ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹$ï¼‰ã¯ã€ï¼»
å…¥åŠ›~ç”¨ã®å…¥å‡ºåŠ›~queueâ€ 
ï¼½ã®å…¨ä½“ãŒæ¶ˆè²»ã•ã‚Œã‚‹ã¾ã§~callå…ƒã‚’é˜»ã‚€ã€‚
å„~å‡ºåŠ›~tokenã‚’ï¼Œ~streamã®ä¸­ã«~pushã•ã‚Œã‚‹ãŸã³ã«åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ã¯ã€
~callå…ƒã¯ï¼Œï¼»
å½“ã®~hookã‚’å‘¼å‡ºã™ã¨ãã«ï¼Œç©ºãªï¼»
å‡ºåŠ›~ç”¨ã®å…¥å‡ºåŠ›~queueâ€ â€ 
ï¼½ã‚’ä¼´ã‚ã›ã¦ã€
ãã“ã‹ã‚‰`ä¸¦åˆ—çš„$ã«èª­å–ã‚‹
ï¼½ã“ã¨ã€‚
`~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹$ã‚’åˆ©ç”¨ã™ã‚‹ã¨ãã«ã¯ï¼Œå°‘ã—~careãŒå¿…è¦ã«ãªã‚‹ã“ã¨ã«æ³¨æ„
â€” å¾©å·ã—ã¦ã„ã‚‹é–“ã«~errorãŒè¦‹å‡ºã•ã‚ŒãŸå ´åˆã€
`~EoQ$ã¯ï¼Œï¼»
å‡ºåŠ›~ç”¨ã®å…¥å‡ºåŠ›~queue
ï¼½ã®ä¸­ã¸~pushã•ã‚Œãªããªã‚‹ã®ã§ã€‚
ã€â€  å„~algoã«ãŠã‘ã‚‹ %å…¥å‡ºåŠ›~queue å¼•æ•°ï¼â€ â€  %å‡ºåŠ› å¼•æ•°ã€‘
â—
These hooks (as well as decode and encode) will block until the input I/O queue has been consumed in its entirety. In order to use the output tokens as they are pushed into the stream, callers are to invoke the hooks with an empty output I/O queue and read from it in parallel. Note that some care is needed when using UTF-8 decode without BOM or fail, as any error found during decoding will prevent the end-of-queue item from ever being pushed into the output I/O queue.
</p>
</div>

<div class="algo">
<p>
`~UTF-8å¾©å·ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$`~byte^tA %å…¥å‡ºåŠ›~queue, `å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA %å‡ºåŠ›ï¼ˆçœç•¥æ™‚ã¯ Â« Â» ï¼‰)
ã«å¯¾ã—ï¼š
â—
To UTF-8 decode an I/O queue of bytes ioQueue given an optional I/O queue of scalar values output (default Â« Â»), run these steps:
</p>
<ol>
	<li>
%~buffer ~LET `å…¥å‡ºåŠ›~queueã‚’è¦—è¦‹ã‚‹$( %å…¥å‡ºåŠ›~queue, 3 )
â—
Let buffer be the result of peeking three bytes from ioQueue,ï¼¼
â†“converted to a byte sequence.
</li>
	<li>
~IFï¼»
( %~buffer[0], %~buffer[1], %~buffer[2] ) ~EQ ( `EF^X, `BB^X, `BF^X )
ï¼½
â‡’
`å…¥å‡ºåŠ›~queueã‹ã‚‰~itemåˆ—ã‚’èª­å–ã‚‹$( %å…¥å‡ºåŠ›~queue, 3 )
ï¼ˆçµæœã¯åˆ©ç”¨ã—ãªã„ã€‚ï¼‰
â—
If buffer is 0xEF 0xBB 0xBF, then read three bytes from ioQueue. (Do nothing with those bytes.)
</li>
	<li>
%å¾©å·å™¨ ~LET `UTF-8$n ã®`å¾©å·å™¨$ã®æ–°ãŸãª~instance
â—
â†“</li>
	<li>
`~queueã‚’å‡¦ç†ã™ã‚‹$( %å¾©å·å™¨, %å…¥å‡ºåŠ›~queue, %å‡ºåŠ›, `replacement^l )
â—
Process a queue with an instance of UTF-8â€™s decoder, ioQueue, output, and "replacement".
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~BOMã¯ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$`~byte^tA %å…¥å‡ºåŠ›~queue, `å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA %å‡ºåŠ›ï¼ˆçœç•¥æ™‚ã¯ Â« Â» ï¼‰)
ã«å¯¾ã—ï¼š
â—
To UTF-8 decode without BOM an I/O queue of bytes ioQueue given an optional I/O queue of scalar values output (default Â« Â»), run these steps:
</p>
<ol>
	<li>
%å¾©å·å™¨ ~LET `UTF-8$n ã®`å¾©å·å™¨$ã®æ–°ãŸãª~instance
â—
â†“</li>
	<li>
`~queueã‚’å‡¦ç†ã™ã‚‹$( %å¾©å·å™¨, %å…¥å‡ºåŠ›~queue, %å‡ºåŠ›, `replacement^l )
â—
Process a queue with an instance of UTF-8â€™s decoder, ioQueue, output, and "replacement".
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8å¾©å·ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$`~byte^tA %å…¥å‡ºåŠ›~queue, `å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA %å‡ºåŠ›ï¼ˆçœç•¥æ™‚ã¯ Â« Â» ï¼‰)
ã«å¯¾ã—ï¼š
â—
To UTF-8 decode without BOM or fail an I/O queue of bytes ioQueue given an optional I/O queue of scalar values output (default Â« Â»), run these steps:
</p>
<ol>
	<li>
%å¾©å·å™¨ ~LET `UTF-8$n ã®`å¾©å·å™¨$ã®æ–°ãŸãª~instance
â—
â†“</li>
	<li>
%~errorã«ãªã‚Šå¾—ã‚‹ ~LET `~queueã‚’å‡¦ç†ã™ã‚‹$( %å¾©å·å™¨, %å…¥å‡ºåŠ›~queue, %å‡ºåŠ›, `fatal^l )
â—
Let potentialError be the result of processing a queue with an instance of UTF-8â€™s decoder, ioQueue, output, and "fatal".
</li>
	<li>
~IFï¼»
%~errorã«ãªã‚Šå¾—ã‚‹ ~EQ `~error$i
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If potentialError is an error, then return failure.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~UTF-8ç¬¦å·åŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA %å…¥å‡ºåŠ›~queue, `å…¥å‡ºåŠ›~queue$`~byte^tA %å‡ºåŠ›ï¼ˆçœç•¥æ™‚ã¯ Â« Â» ï¼‰)
ã«å¯¾ã—
â‡’
~RET `ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹$( %å…¥å‡ºåŠ›~queue, `UTF-8$n, %å‡ºåŠ› )
â—
To UTF-8 encode an I/O queue of scalar values ioQueue given an optional I/O queue of bytes output (default Â« Â»), return the result of encoding ioQueue with encoding UTF-8 and output.
</p>
</div>

		<section id="legacy-hooks">
<h3 title="Legacy hooks for standards">6.1. å„~æ¨™æº–~ç”¨ã®æ—§æ¥ã®~hook</h3>

<div class="note">
<p>æ³¨è¨˜ï¼š
å„~æ¨™æº–ã¯ã€
äº’æ›æ€§ã‚’å¾—ã‚‹ãŸã‚ã«å¿…è¦ãªå ´åˆã‚’é™¤ãï¼Œæ¬¡ã«æŒ™ã’ã‚‹~algoã‚’åˆ©ç”¨ã—ãªã„ã“ã¨ãŒå¼·ãå¥¨åŠ±ã•ã‚Œã‚‹
â‡’ï¼ƒ
`~Unicodeã«å¾©å·ã™ã‚‹$ï¼
`~BOMã‚’~sniffã™ã‚‹$ï¼
`ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹$
â—
Standards are strongly discouraged from using decode, BOM sniff, and encode, except as needed for compatibility.ï¼¼
</p>

<p>
ã“ã‚Œã‚‰ã®æ—§æ¥ã®~hookã‚’å¿…è¦ã¨ã—ã¦ã„ã‚‹æ¨™æº–ã¯ã€
æ¬¡ã®åˆ©ç”¨ã‚‚å¿…è¦ã«ãªã‚‹ã¨è¦‹è¾¼ã¾ã‚Œã‚‹
â‡’ï¼ƒ
`~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹$ï¼ˆ~labelã‚’`ç¬¦å·åŒ–æ³•$ã«è»¢æ›ã™ã‚‹ãŸã‚ï¼‰ï¼
`ç¬¦å·åŒ–æ³•ã‹ã‚‰å‡ºåŠ›~ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹$ï¼ˆ`ç¬¦å·åŒ–æ³•$ã‚’åˆ¥ã®`ç¬¦å·åŒ–æ³•$ â€” `ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹$ã¨ãã«æ¸¡ã™ãã‚Œã«ç›¸å¿œã—ã„ã‚‚ã® â€” ã«è»¢æ›ã™ã‚‹ãŸã‚ï¼‰
â—
Standards needing these legacy hooks will most likely also need to use get an encoding (to turn a label into an encoding) and get an output encoding (to turn an encoding into another encoding that is suitable to pass into encode).
</p>

<p>
ï¼»
~URL~percent-ç¬¦å·åŒ–æ³•ã®æ¥µã‚ã¦~~é™å®šçš„ãªäº‹ä¾‹
ï¼½ç”¨ã«ï¼Œç¬¦å·åŒ–å™¨~errorã«å¯¾ã™ã‚‹~customãªå–æ‰±ã„ãŒå¿…è¦ã«ãªã‚‹ã€‚
ï¼»
`ç¬¦å·åŒ–å™¨ã‚’å–å¾—ã™ã‚‹$ï¼`ç¬¦å·åŒ–ã™ã‚‹ã‹å¤±æ•—ã™ã‚‹$
ï¼½~algoã¯ã€
ãã®ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
ä»–ã®~algoã¯ã€
ç›´ã«åˆ©ç”¨ã•ã‚Œãªã„ã“ã¨ã«ãªã‚‹ã€‚
â—
For the extremely niche case of URL percent-encoding, custom encoder error handling is needed. The get an encoder and encode or fail algorithms are to be used for that. Other algorithms are not to be used directly.
</p>
</div>

<div class="algo">
<p>
`~Unicodeã«å¾©å·ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$`~byte^tA %å…¥å‡ºåŠ›~queue, ~fallbackç¬¦å·åŒ–æ³• %ç¬¦å·åŒ–æ³•, `å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA %å‡ºåŠ›ï¼ˆçœç•¥æ™‚ã¯ Â« Â» ï¼‰)
ã«å¯¾ã—ï¼š
â—
To decode an I/O queue of bytes ioQueue given a fallback encoding encoding and an optional I/O queue of scalar values output (default Â« Â»), run these steps:
</p>
<ol>
	<li>
%~BOMç¬¦å·åŒ–æ³• ~LET `~BOMã‚’~sniffã™ã‚‹$( %å…¥å‡ºåŠ›~queue )
â—
Let BOMEncoding be the result of BOM sniffing ioQueue.
</li>
	<li>
<p>
~IFï¼»
%~BOMç¬¦å·åŒ–æ³• ~NEQ ~NULL
ï¼½ï¼š
â—
If BOMEncoding is non-null:
</p>
		<ol>
			<li>
%ç¬¦å·åŒ–æ³• ~SET %~BOMç¬¦å·åŒ–æ³•
â—
Set encoding to BOMEncoding.
</li>
			<li>
%N ~LET ï¼»
%~BOMç¬¦å·åŒ–æ³• ~EQ `UTF-8$n ãªã‚‰ã° 3 ï¼
~ELSE_ 2
ï¼½
â—
â†“</li>
			<li>
`å…¥å‡ºåŠ›~queueã‹ã‚‰~itemåˆ—ã‚’èª­å–ã‚‹$( %å…¥å‡ºåŠ›~queue, %N )
ï¼ˆçµæœã¯åˆ©ç”¨ã—ãªã„ã€‚ï¼‰
â—
Read three bytes from ioQueue, if BOMEncoding is UTF-8; otherwise read two bytes. (Do nothing with those bytes.)
</li>
		</ol>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™-æ¸ˆã¿ãªå†…å®¹ã¨ã®äº’æ›æ€§ã‚’å¾—ã‚‹ãŸã‚ã€
~BOMã¯ä»–ã‚ˆã‚Š~~å„ªå…ˆã•ã‚Œã‚‹ã€‚
HTTP ãŒåˆ©ç”¨ã•ã‚Œã‚‹æ–‡è„ˆã«ãŠã„ã¦ã¯ã€
ã“ã‚Œã¯ï¼Œ
`<code class="header">Content-Type</code>`
~headerã®æ„å‘³è«–ã«å¯¾ã™ã‚‹é•åã§ã‚ã‚‹ã€‚
â—
For compatibility with deployed content, the byte order mark is more authoritative than anything else. In a context where HTTP is used this is in violation of the semantics of the `Content-Type` header.
</p>
	</li>
	<li>
%å¾©å·å™¨ ~LET %ç¬¦å·åŒ–æ³• ã®`å¾©å·å™¨$ã®æ–°ãŸãª~instance
â—
â†“</li>
	<li>
`~queueã‚’å‡¦ç†ã™ã‚‹$( %å¾©å·å™¨, %å…¥å‡ºåŠ›~queue, %å‡ºåŠ›, `replacement^l )
â—
Process a queue with an instance of encodingâ€™s decoder, ioQueue, output, and "replacement".
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~BOMã‚’~sniffã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$`~byte^tA %å…¥å‡ºåŠ›~queue )
ã«å¯¾ã—ï¼š
â—
To BOM sniff an I/O queue of bytes ioQueue, run these steps:
</p>
<ol>
	<li>
%~BOM ~LET æ¬¡ã®çµæœã‚’~byteåˆ—ã«å¤‰æ›ã—ãŸçµæœ
â‡’
`å…¥å‡ºåŠ›~queueã‚’è¦—è¦‹ã‚‹$( %å…¥å‡ºåŠ›~queue, 3 )
â—
Let BOM be the result of peeking 3 bytes from ioQueue, converted to a byte sequence.
</li>
	<li>
<p>
ä¸‹ã®è¡¨tå†…ã®
~EACH( %è¡Œ )
ã«å¯¾ã—ï¼ŒæŒ™ã’ã‚‰ã‚ŒãŸé †ã«
â‡’
~IFï¼»
%~BOM ã¯ %è¡Œ ã® 1 åˆ—ç›®ã«ä¸ãˆã‚‹~byteåˆ—`ã‹ã‚‰é–‹å§‹ã—ã¦$byteã„ã‚‹
ï¼½
â‡’
~RET %è¡Œ ã® 2 åˆ—ç›®ã«ä¸ãˆã‚‹`ç¬¦å·åŒ–æ³•$
â—
For each of the rows in the table below, starting with the first one and going down, if BOM starts with the bytes given in the first column, then return the encoding given in the cell in the second column of that row. Otherwise, return null.
</p>

<div>
<table><thead>
<tr>
<th>~BOM
<th>ç¬¦å·åŒ–æ³•
<tbody>

<tr><td>`EF^X `BB^X `BF^X
<td>`UTF-8$n

<tr><td>`FE^X `FF^X
<td>`UTF-16BE$n

<tr><td>`FF^X `FE^X
<td>`UTF-16LE$n
</table>

â—
Byte order markï½œEncoding
0xEF 0xBB 0xBFï½œUTF-8
0xFE 0xFFï½œUTF-16BE
0xFF 0xFEï½œUTF-16LE
</div>

	</li>
	<li>
~RET ~NULL
â—
â†‘</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
`~Unicodeã«å¾©å·ã™ã‚‹$~algoã«ã¯ã€ï¼»
~BOMãŒè¦‹å‡ºã•ã‚ŒãŸã®ã§ã€
ä¾›ã•ã‚ŒãŸç¬¦å·åŒ–æ³•ã¯åˆ©ç”¨ã—ã¦ã„ãªã„ã“ã¨
ï¼½ã‚’~callå…ƒã«é€šä¿¡ã™ã‚‹ä»•æ–¹ãŒç„¡ã„ã€‚
ã“ã®~hookã¯ã€
ãã®äº‹ã¸ã®å¯¾å‡¦æ³•ã§ã‚ã‚Šï¼Œ`~Unicodeã«å¾©å·ã™ã‚‹$å‰ã«å‘¼å‡ºã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹â€ ã€‚
ãã‚Œã¯ã€ï¼»
~BOMãŒè¦‹å‡ºã•ã‚ŒãŸãªã‚‰ ãã‚Œã«å¯¾å¿œã™ã‚‹ç¬¦å·åŒ–æ³• ï¼
~ELSE_ ~NULL
ï¼½ã‚’è¿”ã™ã€‚
ã€â€ ç‰¹ã«ï¼Œ~HTMLã®æ§‹æ–‡è§£æ~algoã¯ã€å…¥åŠ›~streamã‚’~Unicodeã«å¾©å·ã™ã‚‹å‰ã«ï¼Œ`ç¬¦å·åŒ–æ³•ã‚’~sniffã™ã‚‹~algo$ã«ã¦ ã“ã‚Œã‚’å‘¼å‡ºã™ã€‚ã€‘
â—
This hook is a workaround for the fact that decode has no way to communicate back to the caller that it has found a byte order mark and is therefore not using the provided encoding. The hook is to be invoked before decode, and it will return an encoding corresponding to the byte order mark found, or null otherwise.
</p>
</div>

<hr>

<div class="algo">
<p>
`ç¬¦å·åŒ–æ³•ã‚’åˆ©ç”¨ã—ã¦ç¬¦å·åŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
(
`å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA %å…¥å‡ºåŠ›~queue,
`ç¬¦å·åŒ–æ³•$ %ç¬¦å·åŒ–æ³•,
`å…¥å‡ºåŠ›~queue$`~byte^tA %å‡ºåŠ›ï¼ˆçœç•¥æ™‚ã¯ Â« Â» ï¼‰
)
ã«å¯¾ã—ï¼š
â—
To encode an I/O queue of scalar values ioQueue given an encoding encoding and an optional I/O queue of bytes output (default Â« Â»), run these steps:
</p>
<ol>
	<li>
%ç¬¦å·åŒ–å™¨ ~LET `ç¬¦å·åŒ–å™¨ã‚’å–å¾—ã™ã‚‹$( %ç¬¦å·åŒ–æ³• )
â—
Let encoder be the result of getting an encoder from encoding.
</li>
	<li>
`~queueã‚’å‡¦ç†ã™ã‚‹$( %ç¬¦å·åŒ–å™¨, %å…¥å‡ºåŠ›~queue, %å‡ºåŠ›, `html^l )
â—
Process a queue with encoder, ioQueue, output, and "html".
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
~HTML~formç”¨ã®æ—§æ¥ã®~hookã§ã‚ã‚‹ã€‚
`~UTF-8ç¬¦å·åŒ–ã™ã‚‹$ã‚’è¢«ã›ãŸæ–¹ãŒã€
æ±ºã—ã¦ `~error$i ã‚’èª˜ç™ºã—ãªã„ã®ã§å®‰å…¨ã§ã‚ã‚‹ã€‚
`URL$r
â—
This is a legacy hook for HTML forms. Layering UTF-8 encode on top is safe as it never triggers errors. [HTML]
</p>
</div>

<hr>

<div class="algo">
<p>
`ç¬¦å·åŒ–å™¨ã‚’å–å¾—ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `ç¬¦å·åŒ–æ³•$ %ç¬¦å·åŒ–æ³• )
ã«å¯¾ã—ï¼š
â—
To get an encoder from an encoding encoding:
</p>
<ol>
	<li>
~Assertï¼š
%ç¬¦å·åŒ–æ³• ~NIN { `replacement$n, `UTF-16BE$n, `UTF-16LE$nã€ï¼`UTF-16BE/LE$nã€‘ }
â—
Assert: encoding is not replacement or UTF-16BE/LE.
</li>
	<li>
~RET %ç¬¦å·åŒ–æ³• ã®`ç¬¦å·åŒ–å™¨$ã®~instance
â—
Return an instance of encodingâ€™s encoder.
</li>
</ol>
</div>

<div class="algo">
<p>
`ç¬¦å·åŒ–ã™ã‚‹ã‹å¤±æ•—ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA %å…¥å‡ºåŠ›~queue, `ç¬¦å·åŒ–å™¨$ã®~instance %ç¬¦å·åŒ–å™¨ , `å…¥å‡ºåŠ›~queue$`~byte^tA %å‡ºåŠ› )
ã«å¯¾ã—ï¼š
â—
To encode or fail an I/O queue of scalar values ioQueue given an encoder instance encoder and an I/O queue of bytes output, run these steps:
</p>
<ol>
	<li>
%~errorã«ãªã‚Šå¾—ã‚‹ ~LET `~queueã‚’å‡¦ç†ã™ã‚‹$( %ç¬¦å·åŒ–å™¨, %å…¥å‡ºåŠ›~queue, %å‡ºåŠ›, `fatal^l )
â—
Let potentialError be the result of processing a queue with encoder, ioQueue, output, and "fatal".
</li>
	<li>
`å…¥å‡ºåŠ›~queueã«~pushã™ã‚‹$( %å‡ºåŠ›, Â« `~EoQ$ Â» )
â—
Push end-of-queue to output.
</li>
	<li>
~IFï¼»
%~errorã«ãªã‚Šå¾—ã‚‹ ã¯ `~error$i ã§ã‚ã‚‹
ï¼½
â‡’
~RET `~error$i ã®`~cp$ã®`å€¤$cp
â—
If potentialError is an error, then return errorâ€™s code pointâ€™s value.
</li>
	<li>
~RET ~NULL
â—
Return null.
</li>
</ol>

<div class="note" id="pit-of-iso-2022-jp">

<p>æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
~URL~percent-ç¬¦å·åŒ–æ³• `URL$r
ç”¨ã®æ—§æ¥ã®~hookã§ã‚ã‚‹ã€‚
~callå…ƒã¯ã€
`ç¬¦å·åŒ–å™¨$ã®~instanceã‚’ç”ŸããŸã¾ã¾ä¿ã¤å¿…è¦ãŒã‚ã‚‹
â€” `~ISO-2022-JPç¬¦å·åŒ–å™¨$ãŒ `~error$i ã‚’è¿”ã™ã¨ãã« ã¨ã‚Šå¾—ã‚‹çŠ¶æ…‹ã¯ã€
2 ã¤ã‚ã‚‹ã®ã§ã€‚
ãã‚Œã¯ã¾ãŸï¼Œ~callå…ƒãŒï¼»
~errorã‚’ä½•ã‚‰ã‹ã®ä»•æ–¹ã§ç¬¦å·åŒ–ã™ã‚‹ã‚ˆã†ãª~byteåˆ—
ï¼½ã‚’ç™ºã™ã‚‹å ´åˆã€
ãã‚Œã‚‰ã®å„~byteã¯ï¼Œ
ç¯„å›² { `00^X ã€œ `7F^X } ã«å…¥ã‚‹, ã‹ã¤ï¼»
`0E^X, `0F^X, `1B^X, `5C^X, `7E^X
ï¼½ä»¥å¤–ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
â—
This is a legacy hook for URL percent-encoding. The caller will have to keep an encoder instance alive as the ISO-2022-JP encoder can be in two different states when returning an error. That also means that if the caller emits bytes to encode the error in some way, these have to be in the range 0x00 to 0x7F, inclusive, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E. [URL]
</p>

<p>
ç‰¹ã«ï¼Œ`~ISO-2022-JPç¬¦å·åŒ–å™¨$ãŒ `Roman$i çŠ¶æ…‹ã«ã‚ã‚‹ä¸‹ã§ `~error$i ã‚’è¿”ã™å ´åˆã€
~callå…ƒã¯ï¼Œ
`5C^X `\^smb ã‚’å‡ºåŠ›ã—å¾—ãªã„
â€” ãã‚Œã¯ã€
`005C^U `\^smb ã¨ã—ã¦å¾©å·ã•ã‚Œãªããªã‚‹ã®ã§ã€‚
ã“ã®ç†ç”±ã‹ã‚‰ï¼Œ`ç¬¦å·åŒ–ã™ã‚‹ã‹å¤±æ•—ã™ã‚‹$ã‚’æ„å›³ã•ã‚Œãªã„ç›®çš„ã«åˆ©ç”¨ã—ã¦ã„ã‚‹å¿œç”¨
â€” `005C^U `\^smb ã‚’ç½®æ›~æ§‹æ–‡ã€~escapeæ³•ã€‘ï¼ˆä¾‹ï¼š `\u2603^c ï¼‰ã®ä¸€éƒ¨ã¨ã—ã¦åˆ©ç”¨ã—ã¦ã„ã‚‹ï¼Œ~JSã‚„~CSSãªã© â€”
ã¯ã€
æ¬¡ã®ã„ãšã‚Œã‹ã§~~å¯¾å‡¦ã™ã‚‹ã“ã¨
â‡’ï¼ƒ
`~ISO-2022-JPç¬¦å·åŒ–å™¨$ã‚’ ãã®ã‚ˆã†ãªç½®æ›~schemeã¨ä½µç”¨ã—ãªã„ã‚ˆã†ï¼Œ~careã™ã‚‹ï¼
ç½®æ›~æ§‹æ–‡ãŒï¼Œç¬¦å·åŒ–å™¨ã‚’å¿…ãšé€šéã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼ˆ~URL~percent-ç¬¦å·åŒ–æ³•ã¨ã¯å¯¾ç…§çš„ã«ï¼‰
â—
In particular, if upon returning an error the ISO-2022-JP encoder is in the Roman state, the caller cannot output 0x5C (\) as it will not decode as U+005C (\). For this reason, applications using encode or fail for unintended purposes ought to take care to prevent the use of the ISO-2022-JP encoder in combination with replacement schemes, such as those of JavaScript and CSS, that use U+005C (\) as part of the replacement syntax (e.g., \u2603) or make sure to pass the replacement syntax through the encoder (in contrast to URL percent-encoding).
</p>

<p>
è¿”ã‚Šå€¤ã¯ã€ï¼»
`~error$i ãŒç”Ÿã˜ãªã‘ã‚Œã° ~NULL ï¼
~ELSE_ ç¬¦å·åŒ–ã—å¾—ãªã„`~cp$ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹æ•°å€¤
ï¼½ã«ãªã‚‹ã€‚
æ•°å€¤ãŒè¿”ã•ã‚ŒãŸå ´åˆï¼Œ~callå…ƒã¯ã€ï¼»
åŒã˜`ç¬¦å·åŒ–å™¨$ã®~instance, æ–°ãŸãªå‡ºåŠ›~ç”¨ã®`å…¥å‡ºåŠ›~queue$
ï¼½ã‚’çµ¦ã—ã¦ï¼Œå†ã³å‘¼å‡ºã™å¿…è¦ãŒã‚ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
The return value is either the number representing the code point that could not be encoded or null, if there was no error. When it returns non-null the caller will have to invoke it again, supplying the same encoder instance and a new output I/O queue.
</p>
</div>
</div>

		</section>
	</section>
	<section id="api">
<h2 title="API">7. ~API</h2>

<p>
ã“ã®ç¯€ã§ã¯ Web IDL `WEBIDL$r ã®å„ç¨®ç”¨èªã‚’åˆ©ç”¨ã™ã‚‹ã€‚
~browser~UAã¯ã€
ã“ã®~APIã‚’~supportã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
~JSå®Ÿè£…ã¯ã€
ã“ã®~APIã‚’~supportã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹ã€‚
ä»–ã®~UAï¼~programmingè¨€èªã¯ã€
å¿…è¦ã«å¿œã˜ã¦ç›¸å¿œã—ã„~APIï¼ˆã“ã‚Œã§ã¯ãªã„ã‹ã‚‚ã—ã‚Œãªã„ï¼‰ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
â—
This section uses terminology from Web IDL. Browser user agents must support this API. JavaScript implementations should support this API. Other user agents or programming languages are encouraged to use an API suitable to their needs, which might not be this one. [WEBIDL]
</p>

<div class="example">
<p>
æ¬¡ã®ä¾‹ã¯ã€
`TextEncoder$I ~objã‚’åˆ©ç”¨ã—ã¦ï¼Œæ–‡å­—åˆ—ã®é…åˆ—ã‚’ `ArrayBuffer$I ã«ç¬¦å·åŒ–ã™ã‚‹ã€‚
çµæœã¯æ¬¡ã‚’å†…å®¹ã¨ã™ã‚‹ `Uint8Array$I ã«ãªã‚‹ï¼š
<span class="block">
å…ˆé ­ãŒï¼ˆ `Uint32Array$I ã¨ã—ã¦ã®ï¼‰æ–‡å­—åˆ—ã®å€‹æ•°ï¼Œãã®å¾Œã¯ï¼š
<span class="block">
æœ€åˆã®æ–‡å­—åˆ—ã®ï¼ˆ `Uint32Array$I ã¨ã—ã¦ã®ï¼‰é•·ã•,
`UTF-8$n ã«ç¬¦å·åŒ–ã•ã‚ŒãŸãã®æ–‡å­—åˆ—~dataï¼Œ<br>
2 ç•ªç›®ã®æ–‡å­—åˆ—ã®ï¼ˆ `Uint32Array$I ã¨ã—ã¦ã®ï¼‰é•·ã•,
ãã®æ–‡å­—åˆ—~dataï¼Œ<br>
â€¦
</span>
ç­‰ã€…ã¨ç¶šãã€‚
</span>
â—
The following example uses the TextEncoder object to encode an array of strings into an ArrayBuffer. The result is a Uint8Array containing the number of strings (as a Uint32Array), followed by the length of the first string (as a Uint32Array), the UTF-8 encoded string data, the length of the second string (as a Uint32Array), the string data, and so on.
</p>

<pre class="lang-js">
function encodeArrayOfStrings(%strings) {
  var %encoder, %encoded, %len, %bytes, %view, %offset;

  %encoder = new TextEncoder();
  %encoded = [];

  %len = Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %strings.length; %i++) {
    %len += Uint32Array.BYTES_PER_ELEMENT;
    %encoded[%i] = %encoder.encode(%strings[%i]);
    %len += %encoded[%i].byteLength;
  }

  %bytes = new Uint8Array(%len);
  %view = new DataView(%bytes.buffer);
  %offset = 0;

  %view.setUint32(%offset, %strings.length);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %encoded.length; %i += 1) {
    %len = %encoded[%i].byteLength;
    %view.setUint32(%offset, %len);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %bytes.set(%encoded[%i], %offset);
    %offset += %len;
  }
  return %bytes.buffer;
}
</pre>

<p>
æ¬¡ã®ä¾‹ã¯ã€ï¼»ï¼»
å‰ã®ä¾‹, ã¾ãŸã¯ `UTF-8$n ä»¥å¤–ã®ç¬¦å·åŒ–æ³•ã«ç­‰ä¾¡ãª~algo
ï¼½ã«ã‚ˆã‚Šç”Ÿç”£ã•ã‚Œã‚‹å½¢å¼ã«ç¬¦å·åŒ–ã•ã‚ŒãŸ~data
ï¼½ã‚’å«ã‚“ã§ã„ã‚‹ `ArrayBuffer$I ã‚’å¾©å·ã—ã¦ã€
~~å…ƒã®ï¼Œæ–‡å­—åˆ—ãŸã¡ãŒæˆã™é…åˆ—ã«æˆ»ã™ã€‚
â—
The following example decodes an ArrayBuffer containing data encoded in the format produced by the previous example, or an equivalent algorithm for encodings other than UTF-8, back into an array of strings.
</p>

<pre class="lang-js">
function decodeArrayOfStrings(%buffer, %encoding) {
  var %decoder, %view, %offset, %num_strings, %strings, %len;

  %decoder = new TextDecoder(%encoding);
  %view = new DataView(%buffer);
  %offset = 0;
  %strings = [];

  %num_strings = %view.getUint32(%offset);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %num_strings; %i++) {
    %len = %view.getUint32(%offset);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %strings[%i] = %decoder.decode(
      new DataView(%view.buffer, %offset, %len));
    %offset += %len;
  }
  return %strings;
}
</pre>
</div>

		<section id="interface-mixin-textdecodercommon">
<h3 title="Interface mixin TextDecoderCommon">7.1. ~interface~mixin `TextDecoderCommon^I</h3>

<pre class="idl">
interface mixin `TextDecoderCommon@I {
  readonly attribute `DOMString$ `encoding$m;
  readonly attribute `boolean$ `fatal$m;
  readonly attribute `boolean$ `ignoreBOM$m;
};
</pre>

<p>
`TextDecoderCommon$I ~interface~mixinã¯ã€ï¼»
`TextDecoder$I, `TextDecoderStream$I
ï¼½~objã§å…±æœ‰ã•ã‚Œã‚‹å…±é€šãªå–å¾—å­ã‚’å®šç¾©ã™ã‚‹ã€‚
ã“ã‚Œã‚‰ã®å„~objã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼š

â—
The TextDecoderCommon interface mixin defines common getters that are shared between TextDecoder and TextDecoderStream objects. These objects have an associated:
</p>

<dl class="def-list">
	<dt>
`ç¬¦å·åŒ–æ³•@dec
â—
encoding
</dt>
	<dd>
`ç¬¦å·åŒ–æ³•$ã€‚
â—
An encoding.
</dd>

	<dt>
`å¾©å·å™¨@dec
â—
decoder
</dt>
	<dd>
`å¾©å·å™¨$ã®~instanceã€‚
â—
A decoder instance.
</dd>

	<dt>
`å…¥å‡ºåŠ›~queue@dec
â—
I/O queue
</dt>
	<dd>
`å…¥å‡ºåŠ›~queue$`~byte^tAã€‚
â—
An I/O queue of bytes.
</dd>

	<dt>
`~BOMã¯ç„¡è¦–ã™ã‚‹ã‹@dec
â—
ignore BOM
</dt>
	<dd>
çœŸå½å€¤
â€” åˆæœŸ~æ™‚ã¯ ~F ã¨ã™ã‚‹ã€‚
â—
A boolean, initially false.
</dd>

	<dt>
`~BOMã‚’è¦‹ã¤ã‘ãŸã‹@dec
â—
BOM seen
</dt>
	<dd>
çœŸå½å€¤
â€” åˆæœŸ~æ™‚ã¯ ~F ã¨ã™ã‚‹ã€‚
â—
A boolean, initially false.
</dd>

	<dt>
`~error~mode@dec
â—
error mode
</dt>
	<dd>
`~error~mode$
â€” åˆæœŸ~æ™‚ã¯ `replacement^l ã¨ã™ã‚‹ã€‚
â—
An error mode, initially "replacement".
</dd>
</dl>

<div class="algo">
<p>
`å…¥å‡ºåŠ›~queueã‚’ç›´åˆ—åŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `TextDecoderCommon$I %å¾©å·å™¨, `å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA %å…¥å‡ºåŠ›~queue )
ã«å¯¾ã—ï¼š
â—
The serialize I/O queue algorithm, given a TextDecoderCommon decoder and an I/O queue of scalar values ioQueue, runs these steps:
</p>
<ol>
	<li>
%å‡ºåŠ› ~LET ç©º~æ–‡å­—åˆ—
â—
Let output be the empty string.
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
		<ol>
			<li>
%~item ~LET `å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹$( %å…¥å‡ºåŠ›~queue )
â—
Let item be the result of reading from ioQueue.
</li>
			<li>
~IFï¼»
%~item ~NEQ `~EoQ$
ï¼½
â‡’
~RET %å‡ºåŠ›
â—
If item is end-of-queue, then return output.
</li>
			<li>
<p>
~IFï¼»
%å¾©å·å™¨ ã®`ç¬¦å·åŒ–æ³•$dec ~IN { `UTF-8$n, `UTF-16BE$n, `UTF-16LE$nã€ï¼`UTF-16BE/LE$nã€‘ }
ï¼½~ANDï¼»
%å¾©å·å™¨ ã®`~BOMã¯ç„¡è¦–ã™ã‚‹ã‹$dec ~EQ ~F
ï¼½~ANDï¼»
%å¾©å·å™¨ ã®`~BOMã‚’è¦‹ã¤ã‘ãŸã‹$dec ~EQ ~F
ï¼½ï¼š
â—
If decoderâ€™s encoding is UTF-8 or UTF-16BE/LE, and decoderâ€™s ignore BOM and BOM seen are false:
</p>
				<ol>
					<li>
%å¾©å·å™¨ ã®`~BOMã‚’è¦‹ã¤ã‘ãŸã‹$dec ~SET ~T
â—
Set decoderâ€™s BOM seen to true.
</li>
					<li>
~IFï¼»
%~item ~EQ `FEFF^U `BOM^cn
ï¼½
â‡’
~CONTINUE
â—
If item is U+FEFF, then continue.
</li>
				</ol>
			</li>
			<li>
%å‡ºåŠ› ã« %~item ã‚’ä»˜åŠ ã™ã‚‹
â—
Append item to output.
</li>
		</ol>
	</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®~algoã¯ã€
~APIã®åˆ©ç”¨è€…ã« ã‚‚ã£ã¨åˆ¶å¾¡ã‚’ä¸ãˆã‚‹ãŸã‚ï¼Œï¼»
~platformã®ä»–æ‰€ã§åˆ©ç”¨ã•ã‚Œã‚‹ï¼Œ`~Unicodeã«å¾©å·ã™ã‚‹$ ~algo
ï¼½ã¨ã¯ã€
~BOMã®å–æ‰±ã„ã«é–¢ã—ã¦æ„å›³çš„ã«ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
This algorithm is intentionally different with respect to BOM handling from the decode algorithm used by the rest of the platform to give API users more control.
</p>
</div>

<hr>

<p class="algo">
`encoding@m
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET `~ASCIIå°æ–‡å­—~åŒ–ã™ã‚‹$( ã‚³ãƒ¬ã®`ç¬¦å·åŒ–æ³•$decã®`åå‰$ )
â—
The encoding getter steps are to return thisâ€™s encodingâ€™s name, ASCII lowercased.
</p>

<p class="algo">
`fatal@m
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ~ISï¼»
ã‚³ãƒ¬ã®`~error~mode$dec ~EQ `fatal^l
ï¼½
â—
The fatal getter steps are to return true if thisâ€™s error mode is "fatal"; otherwise false.
</p>

<p class="algo">
`ignoreBOM@m
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`~BOMã¯ç„¡è¦–ã™ã‚‹ã‹$dec
â—
The ignoreBOM getter steps are to return thisâ€™s ignore BOM.
</p>

		</section>
		<section id="interface-textdecoder">
<h3 title="Interface TextDecoder">7.2. ~interface `TextDecoder^I</h3>

<pre class="idl">
dictionary `TextDecoderOptions@I {
  `boolean$ `fatal@mb = false;
  `boolean$ `ignoreBOM@mb = false;
};

dictionary `TextDecodeOptions@I {
  `boolean$ `stream@mb = false;
};

[`Exposed$=*]
interface `TextDecoder@I {
  `TextDecoder$mc(optional `DOMString$ %label = "utf-8", optional `TextDecoderOptions$I %options = {});

  `USVString$ `decode$m(optional `AllowSharedBufferSource$I %input, optional `TextDecodeOptions$I %options = {});
};

`TextDecoder$I includes `TextDecoderCommon$I;
</pre>

<p class="trans-note">ã€
`åˆ©ç”¨-ä¸­ãª~browserã§ã“ã®ç‰¹èƒ½ã‚’è©¦ã™ï¼ Encoding-test.html$
ã€‘</p>

<p>
å„ `TextDecoder$I ~objã«ã¯ã€
çœŸå½å€¤ã‚’ã¨ã‚‹
`æ›¸å‡ºã•ãªã„ã‹@dec
ãŒçµä»˜ã‘ã‚‰ã‚Œï¼ŒåˆæœŸ~æ™‚ã¯ ~F ã‚’ã¨ã‚‹ã¨ã™ã‚‹ã€‚
â—
A TextDecoder object has an associated do not flush, which is a boolean, initially false.
</p>

<dl class="domintro">
	<dt>%decoder = `new TextDecoder$m([%label = "utf-8" [, %options]])</dt>
	<dd>
æ–°ãŸãª `TextDecoder$I ~obj ã‚’è¿”ã™ã€‚
â—
Returns a new TextDecoder object.
</dd>
	<dd>
%label ãŒæ¬¡ã‚’æº€ãŸã™å ´åˆã€
`RangeError$E ãŒ`æŠ•å‡º-$ã•ã‚Œã‚‹
â‡’
ï¼»
~labelã§ãªã„
ï¼½~ORï¼»
`replacement$n ç”¨ã®~labelã§ã‚ã‚‹
ï¼½
â—
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`ç¬¦å·åŒ–æ³•$decã®`åå‰$ã‚’å°æ–‡å­—~åŒ–ã—ã¦è¿”ã™ã€‚
â—
Returns encodingâ€™s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
`~error~mode$dec ~EQ `fatal^l ãªã‚‰ã° ~T ã‚’è¿”ã™ã€‚
ä»–ã®å ´åˆã¯ ~F ã‚’è¿”ã™ã€‚
â—
Returns true if error mode is "fatal"; otherwise false.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
`~BOMã¯ç„¡è¦–ã™ã‚‹ã‹$decã®å€¤ã‚’è¿”ã™ã€‚
â—
Returns the value of ignore BOM.
</dd>

	<dt>%decoder . `decode([input [, options]])$m</dt>
	<dd>
%input ã‚’ `ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ã«ã‹ã‘ãŸçµæœã‚’è¿”ã™ã€‚
%input ã‚’æ–­ç‰‡åŒ–ã—ã¦å‡¦ç†ã™ã‚‹ã¨ãã¯ã€
%options ã® `stream$mb ~memberã‚’ ~T ã«ã—ãŸä¸‹ã§ï¼Œã“ã®~method 0 å›~ä»¥ä¸Š~å‘¼å‡ºã—ã¦ã‹ã‚‰ï¼Œ %options ã‚’çœç•¥ã—ã¦ï¼ˆã¾ãŸã¯ ãã® `stream$mb ~memberã‚’ ~F ã«ã—ã¦ï¼‰
1 å›ã ã‘å‘¼å‡ºã™ã“ã¨ã§è¡Œãˆã‚‹ã€‚
å¾Œè€…ã®å‘¼å‡ºnã« %input ã‚‚ãªã„ãªã‚‰ã°ã€
ä¸¡~å¼•æ•°ã¨ã‚‚çœç•¥ã™ã‚‹ã®ãŒæœ€ã‚‚ç°¡æ˜ã«ãªã‚‹ã€‚
â—
Returns the result of running encodingâ€™s decoder. The method can be invoked zero or more times with optionsâ€™s stream set to true, and then once without optionsâ€™s stream (or set to false), to process a fragmented input. If the invocation without optionsâ€™s stream (or set to false) has no input, itâ€™s clearest to omit both arguments.
</dd>
	<dd class="example">
<pre class="lang-js">
var %string = "", %decoder = new TextDecoder(%encoding), %buffer;
while(%buffer = next_chunk()) {
  %string += %decoder.decode(%buffer, {stream:true});
}
%string += %decoder.decode(); // ~EoQ
</pre>

	</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l ã®ä¸‹ã§ï¼Œ
`ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ãŒ `~error$i ã‚’è¿”ã—ãŸå ´åˆã€
`TypeError$E ãŒ`æŠ•å‡º-$ã•ã‚Œã‚‹ã€‚
â—
If the error mode is "fatal" and encodingâ€™s decoder returns error, throws a TypeError.
</dd>
</dl>

<div class="algo">
<p>
`new TextDecoder(label, options)@m
æ§‹ç¯‰å­~æ‰‹ç¶šãã¯ï¼š
â—
The new TextDecoder(label, options) constructor steps are:
</p>
<ol>
	<li>
%ç¬¦å·åŒ–æ³• ~LET `~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹$( %label )
â—
Let encoding be the result of getting an encoding from label.
</li>
	<li>
~IFï¼»
%ç¬¦å·åŒ–æ³• ~IN { `å¤±æ•—^i, `replacement$n }
ï¼½
â‡’
~THROW `RangeError$E
â—
If encoding is failure or replacement, then throw a RangeError.
</li>
	<li>
ã‚³ãƒ¬ã® `ç¬¦å·åŒ–æ³•$dec ~SET %ç¬¦å·åŒ–æ³•
â—
Set thisâ€™s encoding to encoding.
</li>
	<li>
~IFï¼»
%options[ "`fatal$mb" ] ~EQ ~T
ï¼½
â‡’
ã‚³ãƒ¬ã®`~error~mode$dec ~SET `fatal^l
â—
If options["fatal"] is true, then set thisâ€™s error mode to "fatal".
</li>
	<li>
ã‚³ãƒ¬ã® `~BOMã¯ç„¡è¦–ã™ã‚‹ã‹$dec ~SET %options[ "`ignoreBOM$mb" ]
â—
Set thisâ€™s ignore BOM to options["ignoreBOM"].
</li>
</ol>
</div>

<div class="algo">
<p>
`decode(input, options)@m
~method~æ‰‹ç¶šãã¯ï¼š
â—
The decode(input, options) method steps are:
</p>
<ol>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`æ›¸å‡ºã•ãªã„ã‹$dec ~EQ ~F
ï¼½
â‡’ï¼ƒ
ã‚³ãƒ¬ã®`å¾©å·å™¨$dec ~SET ã‚³ãƒ¬ã®`ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ã®æ–°ãŸãª~instanceï¼›
ã‚³ãƒ¬ã®`å…¥å‡ºåŠ›~queue$dec ~SET `å…¥å‡ºåŠ›~queue$`~byte^tA Â« `~EoQ$ Â»ï¼›
ã‚³ãƒ¬ã®`~BOMã‚’è¦‹ã¤ã‘ãŸã‹$dec ~SET ~F
â—
If thisâ€™s do not flush is false, then set thisâ€™s decoder to a new instance of thisâ€™s encodingâ€™s decoder, thisâ€™s I/O queue to the I/O queue of bytes Â« end-of-queue Â», and thisâ€™s BOM seen to false.
</li>
	<li>
ã‚³ãƒ¬ã®`æ›¸å‡ºã•ãªã„ã‹$dec ~SET %options[ "`stream$mb" ]
â—
Set thisâ€™s do not flush to options["stream"].
</li>
	<li>
<p>
~IFï¼»
%input ~NEQ Îµ
ï¼½ï¼š
â—
If input is given,ï¼¼
</p>
		<ol>
			<li>
%è¤‡è£½ ~LET %input ã«`ä¿æŒã•ã‚ŒãŸ~byteåˆ—ã®è¤‡è£½ã‚’å–å¾—ã™ã‚‹$
â—
â†“</li>
			<li>
`å…¥å‡ºåŠ›~queueã«~pushã™ã‚‹$( ã‚³ãƒ¬ã®`å…¥å‡ºåŠ›~queue$dec, %è¤‡è£½ )
â—
then push a copy of input to thisâ€™s I/O queue.
</li>
		</ol>

<p class="note">æ³¨è¨˜ï¼š
å®Ÿè£…ã«ã¯ã€
ã“ã®è¤‡è£½ã‚’é¿ã‘ã‚‹ã‚ˆã†å®Ÿè£…ã™ã‚‹ã“ã¨ãŒå¼·ãå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
ãã†ã™ã‚‹ã¨ãã¯ã€
%input ãŒå¤‰æ›´ã•ã‚Œã¦ã‚‚ï¼Œå¾Œã® `decode()$m ã®~callã«å½±éŸ¿ã—ãªã„ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
Implementations are strongly encouraged to use an implementation strategy that avoids this copy. When doing so they will have to make sure that changes to input do not affect future calls to decode().
</p>

<p class="warning" id="sharedarraybuffer-warning">
`SharedArrayBuffer^I ~objã«ã‚ˆã‚Šå…¬é–‹ã•ã‚Œã‚‹~memoryã¯ã€ï¼»
å®Ÿè£…~ç”¨ã«æ¦‚ã—ã¦åˆ©ç”¨ã•ã‚Œã‚‹~programmingè¨€èª
ï¼½ã®~memory~modelã«è¦æ±‚ã•ã‚Œã‚‹ `data race freedom^en ãªç‰¹è³ªã‚’å›ºå®ˆã—ãªã„ã€‚
å®Ÿè£…ã™ã‚‹ã¨ãã¯ã€
`SharedArrayBuffer^I ~objãŒå…¬é–‹ã™ã‚‹~memoryã«~accessã™ã‚‹ã¨ãã«é©åˆ‡ãªä¾¿å®œæ€§â€ ã‚’åˆ©ç”¨ã™ã‚‹ã‚ˆã†~careã™ã‚‹ã“ã¨ã€‚
ã€â€ ãã®ã‚ˆã†ãª~accessã« ãã®ç¨®ã®ç‰¹è³ªãŒå‚™ã‚ã‚‹ã‚ˆã†æŒ‡ç¤ºã™ã‚‹ï¼Œè¨€èª~ç‰¹æœ‰ãªæ§‹æ–‡ãªã©ã€‘
â—
The memory exposed by SharedArrayBuffer objects does not adhere to data race freedom properties required by the memory model of programming languages typically used for implementations. When implementing, take care to use the appropriate facilities when accessing memory exposed by SharedArrayBuffer objects.
</p>
	</li>
	<li>
%å‡ºåŠ› ~LET `å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA Â« `~EoQ$ Â»
â—
Let output be the I/O queue of scalar values Â« end-of-queue Â».
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
		<ol>
			<li>
%~item ~LET `å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹$( ã‚³ãƒ¬ã®`å…¥å‡ºåŠ›~queue$dec )
â—
Let item be the result of reading from thisâ€™s I/O queue.
</li>
			<li>
<p>
~IFï¼»
%~item ~EQ `~EoQ$
ï¼½~ANDï¼»
ã‚³ãƒ¬ã®`æ›¸å‡ºã•ãªã„ã‹$dec ~EQ ~T
ï¼½
â‡’
~RET `å…¥å‡ºåŠ›~queueã‚’ç›´åˆ—åŒ–ã™ã‚‹$( ã‚³ãƒ¬, %å‡ºåŠ› )
â—
If item is end-of-queue and thisâ€™s do not flush is true, then return the result of running serialize I/O queue with this and output.
</p>

<p class="note">æ³¨è¨˜ï¼š
~streamingã§ã¯ã€ï¼»
ã‚³ãƒ¬ã®`æ›¸å‡ºã•ãªã„ã‹$dec ~EQ ~T
ï¼½ã®ã¨ãï¼Œã“ã“ã§`~EoQ$ã‚’å–æ‰±ã†ã“ã¨ãªãï¼Œãã‚Œã‚’ ~F ã«ã—ãªã„ä»•æ–¹ã§åƒãã€‚
ã“ã®ä»•æ–¹ã«ã‚ˆã‚Šï¼Œã‚³ãƒ¬ã®`å¾©å·å™¨$decã¯ã€
å¾Œç¶šãªå‘¼å‡ºnã«ãŠã„ã¦ï¼Œã“ã®~algoã®æœ€åˆã®æ®µã§ä¸€æ–°ã•ã‚Œã‚‹ã“ã¨ãªãï¼Œãã®çŠ¶æ…‹ã¯ä¿å…¨ã•ã‚Œã‚‹ã€‚
â—
The way streaming works is to not handle end-of-queue here when thisâ€™s do not flush is true and to not set it to false. That way in a subsequent invocation thisâ€™s decoder is not set anew in the first step of the algorithm and its state is preserved.
</p>
			</li>
			<li>
%çµæœ ~LET `~itemã‚’å‡¦ç†ã™ã‚‹$( %~item, ã‚³ãƒ¬ã®`å¾©å·å™¨$dec, ã‚³ãƒ¬ã®`å…¥å‡ºåŠ›~queue$dec, %å‡ºåŠ›, ã‚³ãƒ¬ã®`~error~mode$dec )
â—
Otherwise:
â—
Let result be the result of processing an item with item, thisâ€™s decoder, thisâ€™s I/O queue, output, and thisâ€™s error mode.
</li>
			<li>
~IFï¼»
%çµæœ ~EQ `å®Œé‚d$i
ï¼½
â‡’
~RET `å…¥å‡ºåŠ›~queueã‚’ç›´åˆ—åŒ–ã™ã‚‹$( ã‚³ãƒ¬, %å‡ºåŠ› )
â—
If result is finished, then return the result of running serialize I/O queue with this and output.
</li>
			<li>
~IFï¼»
%çµæœ ~EQ `~error$i
ï¼½
â‡’
~THROW `TypeError$E
â—
Otherwise, if result is error, throw a TypeError.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="interface-mixin-textencodercommon">
<h3 title="Interface mixin TextEncoderCommon">7.3. ~interface~mixin `TextEncoderCommon^I</h3>

<pre class="idl">
interface mixin `TextEncoderCommon@I {
  readonly attribute `DOMString$ `~encoding0$m;
};
</pre>

<p>
`TextEncoderCommon$I ~interface~mixinã¯ã€ï¼»
`TextEncoder$I, `TextEncoderStream$I
ï¼½~objã§å…±æœ‰ã•ã‚Œã‚‹å…±é€šãªå–å¾—å­ã‚’å®šç¾©ã™ã‚‹ã€‚
â—
The TextEncoderCommon interface mixin defines common getters that are shared between TextEncoder and TextEncoderStream objects.
</p>

<p class="algo">
`~encoding0@m
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET `utf-8^l
â—
The encoding getter steps are to return "utf-8".
</p>

		</section>
		<section id="interface-textencoder">
<h3 title="Interface TextEncoder">7.4. ~interface `TextEncoder^I</h3>

<pre class="idl">
dictionary `TextEncoderEncodeIntoResult@I {
  `unsigned long long$ `read@m;
  `unsigned long long$ `written@m;
};

[`Exposed$=*]
interface `TextEncoder@I {
  `TextEncoder$mc();

  [NewObject] `Uint8Array$ `encode$m(optional `USVString$ %input = "");
  `TextEncoderEncodeIntoResult$I `encodeInto$m(`USVString$ %source, [`AllowShared$] `Uint8Array$ %destination);
};
`TextEncoder$I includes `TextEncoderCommon$I;
</pre>

<p class="note">æ³¨è¨˜ï¼š
`TextEncoder$I ~objã¯ã€
`UTF-8$n ã—ã‹~supportã—ãªã„ã®ã§ï¼Œæ§‹ç¯‰å­ã« %label å¼•æ•°ã¯ç„¡ã„ã€‚
ã¾ãŸã€
~scalarå€¤~bufferã‚’è¦æ±‚ã™ã‚‹`ç¬¦å·åŒ–å™¨$ã¯ç„¡ã„ã®ã§ï¼Œ `stream^mb ~optionã‚‚ãªã„ã€‚
â—
A TextEncoder object offers no label argument as it only supports UTF-8. It also offers no stream option as no encoder requires buffering of scalar values.
</p>

<hr>

<dl class="domintro">
	<dt>%encoder = `new TextEncoder()$m</dt>
	<dd>
æ–°ãŸãª `TextEncoder$I ~obj ã‚’è¿”ã™ã€‚
â—
Returns a new TextEncoder object.
</dd>

	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l ã‚’è¿”ã™ã€‚
â—
Returns "utf-8".
</dd>

	<dt>%encoder . `encode([input = ""])$m</dt>
	<dd>
%input ã‚’ `UTF-8$n ã®`ç¬¦å·åŒ–å™¨$ã«ã‹ã‘ãŸçµæœã‚’è¿”ã™ã€‚
â—
Returns the result of running UTF-8â€™s encoder.
</dd>

	<dt>%encoder . `encodeInto(source, destination)$m</dt>
	<dd>
%source ã‚’æ¸¡ã—ã¦`~UTF-8ç¬¦å·åŒ–å™¨$ã‚’èµ°ã‚‰ã›ãŸçµæœã‚’ %destination ã®ä¸­ã«æ ¼ç´ã—ã¦ï¼Œãã®é€²æ—ã‚’~objã¨ã—ã¦è¿”ã™
â€” çµæœã®
â‡’ï¼ƒ
`read$m ã¯ %source ã‹ã‚‰å¤‰æ›ã•ã‚ŒãŸ`~cu$æ•°ã«ãªã‚‹ ï¼
`written$m ã¯ %destination å†…ã§æ”¹å¤‰ã•ã‚ŒãŸ~byteæ•°ã«ãªã‚‹
â—
Runs the UTF-8 encoder on source, stores the result of that operation into destination, and returns the progress made as an object wherein read is the number of converted code units of source and written is the number of bytes modified in destination.
</dd>
</dl>

<p class="algo">
`new TextEncoder()@m
æ§‹ç¯‰å­~æ‰‹ç¶šãã¯ã€
ä½•ã‚‚ã—ãªã„ã€‚
â—
The new TextEncoder() constructor steps are to do nothing.
</p>

<div class="algo">
<p>
`encode(input)@m
~method~æ‰‹ç¶šãã¯ï¼š
â—
The encode(input) method steps are:
</p>
<ol>
	<li>
%å…¥åŠ› ~LET `å…¥å‡ºåŠ›~queueã«å¤‰æ›ã™ã‚‹$( %input )
â—
Convert input to an I/O queue of scalar values.
</li>
	<li>
%å‡ºåŠ› ~LET `å…¥å‡ºåŠ›~queue$`~byte^tA Â« `~EoQ$ Â»
â—
Let output be the I/O queue of bytes Â« end-of-queue Â».
</li>
	<li>
%ç¬¦å·åŒ–å™¨ ~LET `UTF-8$n ã®`ç¬¦å·åŒ–å™¨$ã®æ–°ãŸãª~instance
â—
â†“</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
		<ol>
			<li>
%~item ~LET `å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹$( %å…¥åŠ› )
â—
Let item be the result of reading from input.
</li>
			<li>
%çµæœ ~LET `~itemã‚’å‡¦ç†ã™ã‚‹$( %~item, %ç¬¦å·åŒ–å™¨, %å…¥åŠ›, %å‡ºåŠ›, `fatal^l )
â—
Let result be the result of processing an item with item, an instance of the UTF-8 encoder, input, output, and "fatal".
</li>
			<li>
<p>
~Assertï¼š
%çµæœ ã¯ `~error$i ã§ãªã„
â—
Assert: result is not an error.
</p>

<p class="note">æ³¨è¨˜ï¼š
`~UTF-8ç¬¦å·åŒ–å™¨$ãŒ `~error$i ã‚’è¿”ã™ã“ã¨ã¯ãªã„ã€‚
â—
The UTF-8 encoder cannot return error.
</p>
			</li>
			<li>
<p>
~IFï¼»
%çµæœ ~EQ `å®Œé‚d$i
ï¼½ï¼š
</p>
				<ol>
					<li>
%å‡ºåŠ› ~SET %å‡ºåŠ› ã‚’~byteåˆ—ã«`å¤‰æ›ã™ã‚‹$
</li>
					<li>
~RET `~buffer~sourceã‚’ä½œæˆã™ã‚‹$( `Uint8Array$I, %å‡ºåŠ›, ã‚³ãƒ¬ã«`é–¢é€£ãª~realm$ )
</li>
				</ol>
â—
If result is finished, then convert output into a byte sequence and return a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`encodeInto(source, destination)@m
~method~æ‰‹ç¶šãã¯ï¼š
â—
The encodeInto(source, destination) method steps are:
</p>
<ol>
	<li>
%read ~LET 0
â—
Let read be 0.
</li>
	<li>
%written ~LET 0
â—
Let written be 0.
</li>
	<li>
%ç¬¦å·åŒ–å™¨ ~LET `~UTF-8ç¬¦å·åŒ–å™¨$ã®æ–°ãŸãª~instance
â—
Let encoder be an instance of the UTF-8 encoder.
</li>
	<li>
<p>
%åˆ©ç”¨ã•ã‚Œãªã„~queue ~LET `å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA Â« `~EoQ$ Â»
â—
Let unused be the I/O queue of scalar values Â« end-of-queue Â».
</p>

<p class="note">æ³¨è¨˜ï¼š
ä»¥ä¸‹ã§å‘¼å‡ºã•ã‚Œã‚‹`~handler$~algoã«ã¯ï¼Œã“ã®å¼•æ•°ãŒè¦æ±‚ã•ã‚Œã‚‹ãŒã€
`~UTF-8ç¬¦å·åŒ–å™¨$ã¯ï¼Œãã‚Œã‚’åˆ©ç”¨ã—ãªã„ã€‚
â—
The handler algorithm invoked below requires this argument, but it is not used by the UTF-8 encoder.
</p>
	</li>
	<li>
%source ~SET `å…¥å‡ºåŠ›~queueã«å¤‰æ›ã™ã‚‹$( %source )
â—
Convert source to an I/O queue of scalar values.
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
		<ol>
			<li>
%~item ~LET `å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹$( %source )
â—
Let item be the result of reading from source.
</li>
			<li>
%çµæœ ~LET %ç¬¦å·åŒ–å™¨ ã®`~handler$( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~item )
â—
Let result be the result of running encoderâ€™s handler on unused and item.
</li>
			<li>
~IFï¼»
%çµæœ ~EQ `å®Œé‚d$i
ï¼½
â‡’
~BREAK
â—
If result is finished, then break.
â—
Otherwise:
</li>
			<li>
~IFï¼»
%written ~PLUS %çµæœ ã‚’æˆã™~byteæ•° ~GT %destination ã®`~byteé•·ã•$BS
ï¼½
â‡’
~BREAK
â—
If destinationâ€™s byte length âˆ’ written is greater than or equal to the number of bytes in result:
</li>
			<li>
%read ~INCBY ï¼»
%~item ~LTE `FFFF^U ãªã‚‰ã° 1 ï¼
~ELSE_ 2
ï¼½
â—
â€¢ If item is greater than U+FFFF, then increment read by 2.
â€¢ Otherwise, increment read by 1.
</li>
			<li>
<p>
`é…åˆ—~buffer~viewã®ä¸­ã¸~byteåˆ—ã‚’æ›¸è¾¼ã‚€$( %destination, %çµæœ, %written )
â—
â€¢ Write the bytes in result into destination, with startingOffset set to written.
</p>

<p class="warning">
ä¸Šè¿°ã—ãŸ `SharedArrayBuffer^I ~objç”¨ã®`è­¦å‘Šï¼ #sharedarraybuffer-warning$ã‚’è¦‹ã‚ˆã€‚
â—
See the warning for SharedArrayBuffer objects above.
</p>

			</li>
			<li>
%written ~INCBY %çµæœ ã‚’æˆã™~byteæ•°
â—
â€¢ Increment written by the number of bytes in result.
â—
Otherwise, break.
</li>
		</ol>
	</li>
	<li>
~RET Â« `read$m â†’ %read, `written$m â†’ %written Â»
â—
Return Â«[ "read" â†’ read, "written" â†’ written ]Â».
</li>
</ol>
</div>

<div class="example">
<p>
`encodeInto()$m ~methodã‚’åˆ©ç”¨ã™ã‚Œã°ã€
æ–‡å­—åˆ—ã‚’æ—¢å­˜ã® `ArrayBuffer$I ~objã®ä¸­ã¸ç¬¦å·åŒ–ã§ãã‚‹ã€‚
ä¸‹ã«ãŠã‘ã‚‹æ§˜ã€…ãªè©³ç´°ã¯ï¼Œèª­è€…ã¸ã®å®¿é¡Œã¨ã—ã¦æ®‹ã—ã¦ãŠããŒã€
ã“ã®ä¾‹ã¯ï¼Œã“ã®~methodã®ç”¨-æ³•ã®ä¸€ã¤ã‚’ãƒ‡ãƒ¢ã‚‹ï¼š
â—
The encodeInto() method can be used to encode a string into an existing ArrayBuffer object. Various details below are left as an exercise for the reader, but this demonstrates an approach one could take to use this method:
</p>

<pre class="lang-js">
function convertString(%buffer, %input, %callback) {
  let %bufferSize = 256,
      %bufferStart = malloc(%buffer, %bufferSize),
      %writeOffset = 0,
      %readOffset = 0;
  while (true) {
    const view = new Uint8Array(%buffer, %bufferStart + %writeOffset, %bufferSize - %writeOffset),
          {%read, %written} = cachedEncoder.encodeInto(%input.substring(%readOffset), view);
    %readOffset += %read;
    %writeOffset += %written;
    if (%readOffset === %input.length) {
      %callback(%bufferStart, %writeOffset);
      free(%buffer, %bufferStart);
      return;
    }
    %bufferSize *= 2;
    %bufferStart = realloc(%buffer, %bufferStart, %bufferSize);
  }
}
</pre>
</div>

		</section>
		<section id="interface-textdecoderstream">
<h3 title="Interface TextDecoderStream">7.5. ~interface `TextDecoderStream$I</h3>

<pre class="idl">
[`Exposed$=*]
interface `TextDecoderStream@I {
  `TextDecoderStream$mc(optional `DOMString$ %label = "utf-8", optional `TextDecoderOptions$I %options = {});
};
`TextDecoderStream$I includes `TextDecoderCommon$I;
`TextDecoderStream$I includes `GenericTransformStream$I;
</pre>

<dl class="domintro">
	<dt>%decoder = new <a href="#dom-textdecoderstream">TextDecoderStream([%label = "utf-8" [, %options]])</a></dt>
	<dd>
æ–°ãŸãª `TextDecoderStream$I ~objã‚’è¿”ã™ã€‚
â—
Returns a new TextDecoderStream object.
</dd>
	<dd>
%label ãŒæ¬¡ã‚’æº€ãŸã™å ´åˆã€
`RangeError$E ãŒ`æŠ•å‡º-$ã•ã‚Œã‚‹
â‡’
ï¼»
~labelã§ãªã„
ï¼½~ORï¼»
`replacement$n ç”¨ã®~labelã§ã‚ã‚‹
ï¼½
â—
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`ç¬¦å·åŒ–æ³•$decã®`åå‰$ã‚’å°æ–‡å­—~åŒ–ã—ã¦è¿”ã™ã€‚
â—
Returns encodingâ€™s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
`~error~mode$dec ~EQ `fatal^l ãªã‚‰ã° ~T ã‚’è¿”ã™ã€‚
ä»–ã®å ´åˆã¯ ~F ã‚’è¿”ã™ã€‚
â—
Returns true if error mode is "fatal", and false otherwise.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
`~BOMã¯ç„¡è¦–ã™ã‚‹ã‹$decã®å€¤ã‚’è¿”ã™ã€‚
â—
Returns the value of ignore BOM.
</dd>

	<dt>%decoder . `readable$m</dt>
	<dd>
`å¯èª­~stream$ã‚’è¿”ã™ã€‚
ãã®`~chunk$ãŸã¡ã¯ã€
`writable$m ã«æ›¸è¾¼ã¾ã‚ŒãŸ~chunkãŸã¡ã«å¯¾ã—ï¼Œ`ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ã‚’èµ°ã‚‰ã›ãŸçµæœã®æ–‡å­—åˆ—ãŸã¡ã«ãªã‚‹ã€‚
â—
Returns a readable stream whose chunks are strings resulting from running encodingâ€™s decoder on the chunks written to writable.
</dd>

	<dt>%decoder . `writable$m</dt>
	<dd>
`å¯æ›¸~stream$ã‚’è¿”ã™ã€‚
ãã‚Œã¯ã€
`AllowSharedBufferSource$I å‹ã®~chunkãŸã¡ã‚’å—å®¹ã—ã¦
â€” `readable$m ã«å¯ç”¨ã«ã•ã‚Œã‚‹å‰ã« â€”
`ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ã«ã‹ã‘ã‚‹ã€‚

â—
Returns a writable stream which accepts AllowSharedBufferSource chunks and runs them through encodingâ€™s decoder before making them available to readable.
</dd>
	<dd class="example">
<p>
ã“ã‚Œã¯æ¦‚ã—ã¦ã€
`ReadableStream$I ~sourceã® `pipeThrough$m ~methodã‚’ä»‹ã—ã¦åˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
Typically this will be used via the pipeThrough() method on a ReadableStream source.
</p>

<pre class="lang-js">
var %decoder = new TextDecoderStream(%encoding);
byteReadable
  .pipeThrough(%decoder)
  .pipeTo(%textWritable);
</pre>

</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l
ã‹ã¤`ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ã¯ `~error$i ã‚’è¿”ã™å ´åˆã€
`readable$m, `writable$m
ã¨ã‚‚ `TypeError$E ã§~errorã«ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
If the error mode is "fatal" and encodingâ€™s decoder returns error, both readable and writable will be errored with a TypeError.
</dd>
</dl>

<div class="algo">
<p>
`new TextDecoderStream(label, options)@m
æ§‹ç¯‰å­~æ‰‹ç¶šãã¯ï¼š
â—
The new TextDecoderStream(label, options) constructor steps are:
</p>
<ol>
	<li>
%ç¬¦å·åŒ–æ³• ~LET `~labelã‹ã‚‰ç¬¦å·åŒ–æ³•ã‚’å–å¾—ã™ã‚‹$( %label )
â—
Let encoding be the result of getting an encoding from label.
</li>
	<li>
~IFï¼»
%ç¬¦å·åŒ–æ³• ~IN { `å¤±æ•—^i, `replacement$n }
ï¼½
â‡’
~THROW `RangeError$E
â—
If encoding is failure or replacement, then throw a RangeError.
</li>
	<li>
ã‚³ãƒ¬ã®`ç¬¦å·åŒ–æ³•$dec ~SET %ç¬¦å·åŒ–æ³•
â—
Set thisâ€™s encoding to encoding.
</li>
	<li>
~IFï¼»
%options[ "`fatal$mb" ] ~EQ ~T
ï¼½
â‡’
ã‚³ãƒ¬ã®`~error~mode$dec ~SET `fatal^l
â—
If options["fatal"] is true, then set thisâ€™s error mode to "fatal".
</li>
	<li>
ã‚³ãƒ¬ã®`~BOMã¯ç„¡è¦–ã™ã‚‹ã‹$dec ~SET %options[ "`ignoreBOM$mb" ]
â—
Set thisâ€™s ignore BOM to options["ignoreBOM"].
</li>
	<li>
ã‚³ãƒ¬ã®`å¾©å·å™¨$dec ~SET ã‚³ãƒ¬ã®`ç¬¦å·åŒ–æ³•$decã®`å¾©å·å™¨$ã®æ–°ãŸãª~instance
â—
Set thisâ€™s decoder to a new instance of thisâ€™s encodingâ€™s decoder,ï¼¼
</li>
	<li>
ã‚³ãƒ¬ã®`å…¥å‡ºåŠ›~queue$dec ~SET æ–°ãŸãª`å…¥å‡ºåŠ›~queue$`~byte^tA
â—
and set thisâ€™s I/O queue to a new I/O queue.
</li>
	<li>
%å½¢å¼å¤‰æ›~stream ~SET `æ–°ãŸãª~obj$( `TransformStream$I, ã‚³ãƒ¬ã«`é–¢é€£ãª~realm$ )
â—
â†“</li>
	<li>
<p>
%å½¢å¼å¤‰æ›~stream ã‚’`è¨­å®šã—ã¦ãŠã$TS
â€” æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼š
</p>
		<ul>
			<li class="algo">
`å½¢å¼å¤‰æ›~algo^i ~SET æ‰€ä¸ã®
( %~chunk )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™~algo
â‡’
`~chunkã‚’å¾©å·ã—ã¦~enqueueã™ã‚‹$( ã‚³ãƒ¬, %~chunk )
</li>
			<li class="algo">
`æ›¸å‡ºn~algo^i ~SET æ¬¡ã‚’èµ°ã‚‰ã™~algo
â‡’
`æ›¸å‡ºã—ã¦~enqueueã™ã‚‹$( ã‚³ãƒ¬ )
</li>
		</ul>
â—
Let transformAlgorithm be an algorithm which takes a chunk argument and runs the decode and enqueue a chunk algorithm with this and chunk.
â—
Let flushAlgorithm be an algorithm which takes no arguments and runs the flush and enqueue algorithm with this.
â—
Let transformStream be a new TransformStream.
â—
Set up transformStream with transformAlgorithm set to transformAlgorithm and flushAlgorithm set to flushAlgorithm.
</li>
	<li>
ã‚³ãƒ¬ã®`å½¢å¼å¤‰æ›$ ~SET %å½¢å¼å¤‰æ›~stream
â—
â—
Set thisâ€™s transform to transformStream.
</li>
</ol>
</div>

<div class="algo">
<p>
`~chunkã‚’å¾©å·ã—ã¦~enqueueã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `TextDecoderStream$I ~obj %å¾©å·å™¨, %~chunk )
ã«å¯¾ã—ï¼š
â—
The decode and enqueue a chunk algorithm, given a TextDecoderStream object decoder and a chunk, runs these steps:
</p>
<ol>
	<li>
%~buffer~source ~LET `~IDLå€¤ã«å¤‰æ›ã™ã‚‹$( %~chunk, `AllowSharedBufferSource$I )
â—
Let bufferSource be the result of converting chunk to an AllowSharedBufferSource.
</li>
	<li>
<p>
`å…¥å‡ºåŠ›~queueã«~pushã™ã‚‹$( %å¾©å·å™¨ ã®`å…¥å‡ºåŠ›~queue$dec, æ¬¡ã®çµæœ )
â‡’
%~buffer~source ã«`ä¿æŒã•ã‚ŒãŸ~byteåˆ—ã®è¤‡è£½ã‚’å–å¾—ã™ã‚‹$
â—
Push a copy of bufferSource to decoderâ€™s I/O queue.
</p>

<p class="warning">
ä¸Šè¿°ã—ãŸ `SharedArrayBuffer^I ~objç”¨ã®`è­¦å‘Šï¼ #sharedarraybuffer-warning$ã‚’è¦‹ã‚ˆã€‚
â—
See the warning for SharedArrayBuffer objects above.
</p>
	</li>
	<li>
%å‡ºåŠ› ~LET `å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA Â« `~EoQ$ Â»
â—
Let output be the I/O queue of scalar values Â« end-of-queue Â».
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
		<ol>
			<li>
%~item ~LET `å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹$( %å¾©å·å™¨ ã®`å…¥å‡ºåŠ›~queue$dec )
â—
Let item be the result of reading from decoderâ€™s I/O queue.
</li>
			<li>
<p>
~IFï¼»
%~item ~EQ `~EoQ$
ï¼½ï¼š
â—
If item is end-of-queue:
</p>
				<ol>
					<li>
%å‡ºåŠ›~chunk ~LET `å…¥å‡ºåŠ›~queueã‚’ç›´åˆ—åŒ–ã™ã‚‹$( ã‚³ãƒ¬, %å‡ºåŠ› )
â—
Let outputChunk be the result of running serialize I/O queue with decoder and output.
</li>
					<li>
~IFï¼»
%å‡ºåŠ›~chunk ã¯ç©ºã§ãªã„
ï¼½
â‡’
%å¾©å·å™¨ ã®`å½¢å¼å¤‰æ›$ã«`~chunkã‚’~enqueueã™ã‚‹$TS( %å‡ºåŠ›~chunk )
â—
If outputChunk is non-empty, then enqueue outputChunk in decoderâ€™s transform.
</li>
					<li>
~RET
â—
Return.
</li>
				</ol>
			</li>
			<li>
%çµæœ ~LET `~itemã‚’å‡¦ç†ã™ã‚‹$( %~item, %å¾©å·å™¨ ã®`å¾©å·å™¨$dec, %å¾©å·å™¨ ã®`å…¥å‡ºåŠ›~queue$dec, %å‡ºåŠ›, %å¾©å·å™¨ ã®`~error~mode$dec )
â—
Let result be the result of processing an item with item, decoderâ€™s decoder, decoderâ€™s I/O queue, output, and decoderâ€™s error mode.
</li>
			<li>
~IFï¼»
%çµæœ ~EQ `~error$i
ï¼½
â‡’
~THROW `TypeError$E
â—
If result is error, then throw a TypeError.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`æ›¸å‡ºã—ã¦~enqueueã™ã‚‹@
~algoã¯ã€
å…¥åŠ› `ReadableStream$I ~objã‹ã‚‰ã®~dataã®çµ‚ç«¯ã‚’å–æ‰±ã†
â€” ãã‚Œã¯ã€
æ‰€ä¸ã®
( `TextDecoderStream$I ~obj %å¾©å·å™¨ )
ã«å¯¾ã—ï¼š
â—
The flush and enqueue algorithm, which handles the end of data from the input ReadableStream object, given a TextDecoderStream object decoder, runs these steps:
</p>
<ol>
	<li>
%å‡ºåŠ› ~LET `å…¥å‡ºåŠ›~queue$`~scalarå€¤^tA Â« `~EoQ$ Â»
â—
Let output be the I/O queue of scalar values Â« end-of-queue Â».
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
		<ol>
			<li>
%~item ~LET `å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹$( %å¾©å·å™¨ ã®`å…¥å‡ºåŠ›~queue$dec )
â—
Let item be the result of reading from decoderâ€™s I/O queue.
</li>
			<li>
%çµæœ ~LET `~itemã‚’å‡¦ç†ã™ã‚‹$( %~item, %å¾©å·å™¨ ã®`å¾©å·å™¨$dec, %å¾©å·å™¨ ã®`å…¥å‡ºåŠ›~queue$dec, %å‡ºåŠ›, %å¾©å·å™¨ ã®`~error~mode$dec )
â—
Let result be the result of processing an item with item, decoderâ€™s decoder, decoderâ€™s I/O queue, output, and decoderâ€™s error mode.
</li>
			<li>
<p>
~IFï¼»
%çµæœ ~EQ `å®Œé‚d$i
ï¼½ï¼š
â—
If result is finished:
</p>
				<ol>
					<li>
%å‡ºåŠ›~chunk ~LET `å…¥å‡ºåŠ›~queueã‚’ç›´åˆ—åŒ–ã™ã‚‹$( ã‚³ãƒ¬, %å‡ºåŠ› )
â—
Let outputChunk be the result of running serialize I/O queue with decoder and output.
</li>
					<li>
~IFï¼»
%å‡ºåŠ›~chunk ã¯ç©ºã§ãªã„
ï¼½
â‡’
%å¾©å·å™¨ ã®`å½¢å¼å¤‰æ›$ã«`~chunkã‚’~enqueueã™ã‚‹$TS( %å‡ºåŠ›~chunk )
â—
If outputChunk is non-empty, then enqueue outputChunk in decoderâ€™s transform.
</li>
					<li>
~RET
â—
Return.
</li>
				</ol>
			</li>
			<li>
~ELIFï¼»
%çµæœ ~EQ `~error$i
ï¼½
â‡’
~THROW `TypeError$E
â—
Otherwise, if result is error, throw a TypeError.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="interface-textencoderstream">
<h3 title="Interface TextEncoderStream">7.6. ~interface `TextEncoderStream^I</h3>

<pre class="idl">
[`Exposed$=*]
interface `TextEncoderStream@I {
  `TextEncoderStream$mc();
};

`TextEncoderStream$I includes `TextEncoderCommon$I;
`TextEncoderStream$I includes `GenericTransformStream$I;
</pre>

<p>
å„ `TextEncoderStream$I ~objã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
A TextEncoderStream object has an associated:
</p>

<dl class="def-list">
	<dt>
`ç¬¦å·åŒ–å™¨@enc
â—
encoder
</dt>
	<dd>
`ç¬¦å·åŒ–å™¨$ã®~instance
â—
An encoder instance.
</dd>
	<dd class="trans-note">ã€
ä¸‹ã«æ³¨è¨˜ã•ã‚Œã‚‹ã¨ãŠã‚Šï¼Œ `UTF-8$n ã®ãã‚Œã—ã‹ã¨ã‚‰ãªã„ã€‚
ã¾ãŸã€
`å¾©å·å™¨$decã®ã¨ãã¨é•ã£ã¦ï¼ŒçŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹~fieldã¯ç„¡ã„ã€‚
ã€‘</dd>

	<dt>
`é ­éƒ¨~surrogate@enc
â—
leading surrogate
</dt>
	<dd>
~NULL ï¼`é ­éƒ¨~surrogate$
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
Null or a surrogate, initially null.
</dd>
</dl>

<p class="note">æ³¨è¨˜ï¼š
`TextEncoderStream$I ~objã¯ `UTF-8$n ã—ã‹~supportã—ãªã„ã®ã§ã€
%~label å¼•æ•°ã‚’æä¾›ã—ãªã„ã€‚
â—
A TextEncoderStream object offers no label argument as it only supports UTF-8.
</p>

<dl class="domintro">
	<dt>%encoder = `new TextEncoderStream()$m</dt>
	<dd>
æ–°ãŸãª `TextEncoderStream$I ~objã‚’è¿”ã™ã€‚
â—
Returns a new TextEncoderStream object.
</dd>
	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l ã‚’è¿”ã™ã€‚
â—
Returns "utf-8".
</dd>

	<dt>%encoder . `readable$m</dt>
	<dd>
`å¯èª­~stream$ã‚’è¿”ã™ã€‚
ãã®å„`~chunk$ã¯ã€
`writable$m ã«æ›¸è¾¼ã¾ã‚ŒãŸ~chunkãŸã¡ã«å¯¾ã—
`UTF-8$n ã®`ç¬¦å·åŒ–å™¨$ã‚’èµ°ã‚‰ã›ãŸçµæœã® `Uint8Array$I ã«ãªã‚‹ã€‚
â—
Returns a readable stream whose chunks are Uint8Arrays resulting from running UTF-8â€™s encoder on the chunks written to writable.
</dd>

	<dt>%encoder . `writable$m</dt>
	<dd>
`å¯æ›¸~stream$ã‚’è¿”ã™ã€‚
ãã‚Œã¯ã€
æ–‡å­—åˆ—~chunkãŸã¡ã‚’å—å®¹ã—ã¦
â€” `readable$m ã«å¯ç”¨ã«ã•ã‚Œã‚‹å‰ã« â€”
`UTF-8$n ã®`ç¬¦å·åŒ–å™¨$ã«ã‹ã‘ã‚‹ã€‚
â—
Returns a writable stream which accepts string chunks and runs them through UTF-8â€™s encoder before making them available to readable.
</dd>
	<dd class="example">
<p>
ã“ã‚Œã¯æ¦‚ã—ã¦ã€
`ReadableStream$I ~sourceã® `pipeThrough$m ~methodã‚’ä»‹ã—ã¦åˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
Typically this will be used via the pipeThrough() method on a ReadableStream source.
</p>

<pre class="lang-js">
%textReadable
  .pipeThrough(new TextEncoderStream())
  .pipeTo(%byteWritable);
</pre>

	</dd>
</dl>

<div class="algo">
<p>
`new TextEncoderStream()@m
æ§‹ç¯‰å­~æ‰‹ç¶šãã¯ï¼š
â—
The new TextEncoderStream() constructor steps are:
</p>
<ol>
	<li>
ã‚³ãƒ¬ã®`ç¬¦å·åŒ–å™¨$enc ~SET `UTF-8$n ã®`ç¬¦å·åŒ–å™¨$ã®æ–°ãŸãª~instance
â—
Set thisâ€™s encoder to an instance of the UTF-8 encoder.
</li>
	<li>
%å½¢å¼å¤‰æ›~stream ~SET `æ–°ãŸãª~obj$( `TransformStream$I, ã‚³ãƒ¬ã«`é–¢é€£ãª~realm$ )
â—
â†“</li>
	<li>
<p>
%å½¢å¼å¤‰æ›~stream ã‚’`è¨­å®šã—ã¦ãŠã$TS
â€” æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼š
</p>
		<ul>
			<li class="algo">
`å½¢å¼å¤‰æ›~algo^i ~SET æ‰€ä¸ã®
( %~chunk )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™~algo
â‡’
`~chunkã‚’ç¬¦å·åŒ–ã—ã¦~enqueueã™ã‚‹$( ã‚³ãƒ¬, %~chunk )
</li>
			<li class="algo">
`æ›¸å‡ºn~algo^i ~SET æ¬¡ã‚’èµ°ã‚‰ã™~algo
â‡’
`ç¬¦å·åŒ–ã—ã¦æ›¸å‡ºã™$( ã‚³ãƒ¬ )
</li>
		</ul>
â—
Let transformAlgorithm be an algorithm which takes a chunk argument and runs the encode and enqueue a chunk algorithm with this and chunk.
â—
Let flushAlgorithm be an algorithm which runs the encode and flush algorithm with this.
â—
Let transformStream be a new TransformStream.
â—
Set up transformStream with transformAlgorithm set to transformAlgorithm and flushAlgorithm set to flushAlgorithm.
</li>
	<li>
ã‚³ãƒ¬ã®`å½¢å¼å¤‰æ›$ ~SET %å½¢å¼å¤‰æ›~stream
â—
Set thisâ€™s transform to transformStream.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`~chunkã‚’ç¬¦å·åŒ–ã—ã¦~enqueueã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `TextEncoderStream$I ~obj %ç¬¦å·åŒ–å™¨, %~chunk )
ã«å¯¾ã—ï¼š
â—
The encode and enqueue a chunk algorithm, given a TextEncoderStream object encoder and chunk, runs these steps:
</p>
<ol>
	<li>
%å…¥åŠ› ~LET `~IDLå€¤ã«å¤‰æ›ã™ã‚‹$( %~chunk, `DOMString^I )
â—
Let input be the result of converting chunk to a DOMString.
</li>
	<li>
<p>
%å…¥åŠ› ~SET `å…¥å‡ºåŠ›~queueã«å¤‰æ›ã™ã‚‹$( %å…¥åŠ› )
â—
Convert input to an I/O queue of code units.
</p>

<p class="note">æ³¨è¨˜ï¼š
`DOMString^I å‹ã‹ã‚‰å¤‰æ›ã—ã¦ã„ã‚‹ã®ã§ã€
çµæœã®`å…¥å‡ºåŠ›~queue$ã®~itemå‹ã¯ï¼Œ~scalarå€¤ã§ã¯ãªã`~cu$ã«ãªã‚‹ã€‚
ãã®ã‚ˆã†ã«ã—ã¦ã„ã‚‹ã®ã¯ã€ï¼»
2 ã¤ã®~chunkã«åˆ†å‰²ã•ã‚ŒãŸ~surrogate~pairã‚’ï¼Œé©åˆ‡ãª~scalarå€¤ã«çµ„ç«‹ç›´ã›ã‚‹ã‚ˆã†ã«ã™ã‚‹
ï¼½ãŸã‚ã§ã‚ã‚Šï¼Œä»–ã®æŒ™å‹•ã¯ `USVString^I ã¨ä¸€è‡´ã™ã‚‹ã€‚
ç‰¹ã«ï¼Œ~~å­¤ç«‹ã—ãŸ~surrogateã¯ `FFFD^U `ï¿½^smb ã«ç½®æ›ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
DOMString, as well as an I/O queue of code units rather than scalar values, are used here so that a surrogate pair that is split between chunks can be reassembled into the appropriate scalar value. The behavior is otherwise identical to USVString. In particular, lone surrogates will be replaced with U+FFFD (ï¿½).
</p>
	</li>
	<li>
%å‡ºåŠ› ~LET `å…¥å‡ºåŠ›~queue$`~byte^tA Â« `~EoQ$ Â»
â—
Let output be the I/O queue of bytes Â« end-of-queue Â».
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>
		<ol>
			<li>
%~item ~LET `å…¥å‡ºåŠ›~queueã‹ã‚‰~itemã‚’èª­å–ã‚‹$( %å…¥åŠ› )
â—
Let item be the result of reading from input.
</li>
			<li>
<p>
~IFï¼»
%~item ~EQ `~EoQ$
ï¼½ï¼š
â—
If item is end-of-queue:
</p>
				<ol>
					<li>
%å‡ºåŠ› ~SET %å‡ºåŠ› ã‚’~byteåˆ—ã«`å¤‰æ›ã™ã‚‹$
â—
Convert output into a byte sequence.
</li>
					<li>
<p>
~IFï¼»
%å‡ºåŠ› ã¯ç©ºã§ãªã„
ï¼½ï¼š
â—
If output is non-empty:
</p>
						<ol>
							<li>
%~chunk ~LET `~buffer~sourceã‚’ä½œæˆã™ã‚‹$( `Uint8Array$I, %å‡ºåŠ›, %ç¬¦å·åŒ–å™¨ ã«`é–¢é€£ãª~realm$ )
â—
Let chunk be a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
	<li>
%ç¬¦å·åŒ–å™¨ ã®`å½¢å¼å¤‰æ›$ã«`~chunkã‚’~enqueueã™ã‚‹$TS( %~chunk )
â—
Enqueue chunk into encoderâ€™s transform.
</li>
						</ol>
					</li>
					<li>
~RET
â—
Return.
</li>
				</ol>
			</li>
			<li>
%çµæœ ~LET `~cuã‚’~scalarå€¤ã«å¤‰æ›ã™ã‚‹$( %ç¬¦å·åŒ–å™¨, %~item, %å…¥åŠ› )
â—
Let result be the result of executing the convert code unit to scalar value algorithm with encoder, item and input.
</li>
			<li>
~IFï¼»
%çµæœ ~NEQ `ç¶™ç¶š-$i
ï¼½
â‡’
`~itemã‚’å‡¦ç†ã™ã‚‹$( %çµæœ, %ç¬¦å·åŒ–å™¨ ã®`ç¬¦å·åŒ–å™¨$enc, %å…¥åŠ›, %å‡ºåŠ›, `fatal^l )
â—
If result is not continue, then process an item with result, encoderâ€™s encoder, input, output, and "fatal".
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~cuã‚’~scalarå€¤ã«å¤‰æ›ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `TextEncoderStream$I ~obj %ç¬¦å·åŒ–å™¨, `~cu$ %~item, `å…¥å‡ºåŠ›~queue$`~cu^tA %å…¥åŠ› )
ã«å¯¾ã—ï¼š
â—
The convert code unit to scalar value algorithm, given a TextEncoderStream object encoder, a code unit item, and an I/O queue of code units input, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%ç¬¦å·åŒ–å™¨ ã®`é ­éƒ¨~surrogate$enc ~NEQ ~NULL
ï¼½ï¼š
â—
If encoderâ€™s leading surrogate is non-null:
</p>
		<ol>
			<li>
%é ­éƒ¨~surrogate ~LET %ç¬¦å·åŒ–å™¨ ã®`é ­éƒ¨~surrogate$enc
â—
Let leadingSurrogate be encoderâ€™s leading surrogate.
</li>
			<li>
%ç¬¦å·åŒ–å™¨ ã®`é ­éƒ¨~surrogate$enc ~SET ~NULL
â—
Set encoderâ€™s leading surrogate to null.
</li>
			<li>
~IFï¼»
%~item ã¯`å°¾éƒ¨~surrogate$ã§ã‚ã‚‹
ï¼½
â‡’
~RET `~surrogateå¯¾ã‹ã‚‰~scalarå€¤ã‚’å¾—ã™ã‚‹$( %é ­éƒ¨~surrogate, %~item )
â—
If item is a trailing surrogate, then return a scalar value from surrogates given leadingSurrogate and item.
</li>
			<li>
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥åŠ›, %~item )
â—
Restore item to input.
</li>
			<li>
~RET `FFFD^U `ï¿½^smb
â—
Return U+FFFD (ï¿½).
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~item ã¯`é ­éƒ¨~surrogate$ã§ã‚ã‚‹
ï¼½
â‡’ï¼ƒ
%ç¬¦å·åŒ–å™¨ ã®`é ­éƒ¨~surrogate$enc ~SET %~itemï¼›
~RET `ç¶™ç¶š-$i
â—
If item is a leading surrogate, then set encoderâ€™s leading surrogate to item and return continue.
</li>
	<li>
~IFï¼»
%~item ã¯`å°¾éƒ¨~surrogate$ã§ã‚ã‚‹
ï¼½
â‡’
~RET `FFFD^U `ï¿½^smb
â—
If item is a trailing surrogate, then return U+FFFD (ï¿½).
</li>
	<li>
~RET %~item
â—
Return item.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ï¼Œ `INFRA$r ã«ã‚ˆã‚‹ï¼»
`æ–‡å­—åˆ—$ã‚’`~scalarå€¤~æ–‡å­—åˆ—$ã«`å¤‰æ›ã™ã‚‹~algoï¼ ~INFRA#javascript-string-convert$
ï¼½ã¨ç­‰ä¾¡ã«ãªã‚‹ãŒã€
2 ã¤ã®æ–‡å­—åˆ—ã«åˆ†å‰²ã•ã‚ŒãŸ~surrogate~pairã‚‚è¨±å®¹ã™ã‚‹ã€‚
`INFRA$r
â—
This is equivalent to the "convert a string into a scalar value string" algorithm from the Infra Standard, but allows for surrogate pairs that are split between strings. [INFRA]
</p>
</div>

<div class="algo">
<p>
`ç¬¦å·åŒ–ã—ã¦æ›¸å‡ºã™@
~algoã¯ã€
æ‰€ä¸ã®
( `TextEncoderStream$I ~obj %ç¬¦å·åŒ–å™¨ )
ã«å¯¾ã—ï¼š
â—
The encode and flush algorithm, given a TextEncoderStream object encoder, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%ç¬¦å·åŒ–å™¨ ã®`é ­éƒ¨~surrogate$enc ~NEQ ~NULL
ï¼½ï¼š
â—
If encoderâ€™s leading surrogate is non-null:
</p>
		<ol>
			<li>
<p>
%~byteåˆ— ~LET ~byteåˆ— `EF^X `BF^X `BD^X
â—
Let chunk be a Uint8Array object wrapping an ArrayBuffer containingï¼¼
0xEF 0xBF 0xBD.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
`FFFD^U `ï¿½^smb ã‚’æˆã™~UTF-8~byteåˆ—ã§ã‚ã‚‹ã€‚
â—
This is U+FFFD (ï¿½) in UTF-8 bytes.
</p>
			</li>
			<li>
<p>
%~chunk ~LET `~buffer~sourceã‚’ä½œæˆã™ã‚‹$( `Uint8Array$I, %~byteåˆ—, %ç¬¦å·åŒ–å™¨ ã«`é–¢é€£ãª~realm$ )
â—
â†‘</li>
			<li>
%ç¬¦å·åŒ–å™¨ ã®`å½¢å¼å¤‰æ›$ã«`~chunkã‚’~enqueueã™ã‚‹$TS( %~chunk )
â—
Enqueue chunk into encoderâ€™s transform.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
	</section>
	<section id="the-encoding">
<h2 title="The encoding">8. ~~æ¨™æº–ã®ç¬¦å·åŒ–æ³•</h2>

<p class="trans-note">ã€
ã“ã® â€œ~~æ¨™æº–ã®â€ ã¯ â€œTheâ€ ã®å¯¾è¨³ã§ã‚ã‚Šã€
ãŠã‚ˆãï¼Œ
â€œè¦ç¯„ã¨ã•ã‚Œã‚‹ã¹ãå”¯ä¸€ç„¡äºŒã®â€
ã‚’æ„å‘³ã™ã‚‹ã€‚
ã€‘</p>

		<section id="utf-8">
<h3>8.1. ~UTF-8</h3>

			<section id="utf-8-decoder">
<h4 title="UTF-8 decoder">8.1.1. ~UTF-8å¾©å·å™¨</h4>

<p class="note">æ³¨è¨˜ï¼š
~BOMã¯ã€
~labelã‚ˆã‚Š~~å„ªå…ˆã•ã‚Œã‚‹
â€” ãã®æ–¹ãŒé…å‚™-æ¸ˆã¿ãªå†…å®¹ã«ãŠã„ã¦æ­£ç¢ºaã«ãªã‚‹ã‚‚ã®ã¨è¦‹å‡ºã•ã‚ŒãŸã®ã§ã€‚
ã—ãŸãŒã£ã¦ãã‚Œã¯ã€
`~UTF-8å¾©å·å™¨$~algoã®ä¸€éƒ¨ã‚’æˆã•ãªã„
â€” ä»£ã‚ã‚Šã«ï¼»
`~Unicodeã«å¾©å·ã™ã‚‹$ ï¼ `~UTF-8å¾©å·ã™ã‚‹$
ï¼½~algoã®ä¸€éƒ¨ã‚’æˆã™ã€‚
â—
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the UTF-8 decoder algorithm but rather the decode and UTF-8 decode algorithms.
</p>

<p>
å„ï¼»
`UTF-8$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`~UTF-8~cp@ï¼ˆåˆæœŸ~æ™‚ã¯ 0 ï¼‰,
`~UTF-8å‡ºç¾~byteæ•°@ï¼ˆåˆæœŸ~æ™‚ã¯ 0 ï¼‰,
`~UTF-8è¦~byteæ•°@ï¼ˆåˆæœŸ~æ™‚ã¯ 0 ï¼‰,
`~UTF-8ä¸‹é™@ï¼ˆåˆæœŸ~æ™‚ã¯ `80^X ï¼‰,
`~UTF-8ä¸Šé™@ï¼ˆåˆæœŸ~æ™‚ã¯ `BF^X ï¼‰
â—
UTF-8â€™s decoder has an associated UTF-8 code point, UTF-8 bytes seen, and UTF-8 bytes needed (all initially 0), a UTF-8 lower boundary (initially 0x80), and a UTF-8 upper boundary (initially 0xBF).
</p>

<div class="algo">
<p>
`UTF-8$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %å…¥å‡ºåŠ›~queue, %~byte )
ã«å¯¾ã—ï¼š
â—
UTF-8â€™s decoderâ€™s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~byte ~EQ `~EoQ$
ï¼½~ANDï¼»
`~UTF-8è¦~byteæ•°$ ~NEQ 0
ï¼½
â‡’ï¼ƒ
`~UTF-8è¦~byteæ•°$ ~SET 0ï¼›
~RET `~error$i
â—
If byte is end-of-queue and UTF-8 bytes needed is not 0, set UTF-8 bytes needed to 0 and return error.
</li>
	<li>
~IFï¼»
%~byte ~EQ `~EoQ$
ï¼½
â‡’
~RET `å®Œé‚d$i
â—
If byte is end-of-queue, then return finished.
</li>
	<li>
<p>
~IFï¼»
`~UTF-8è¦~byteæ•°$ ~EQ 0
ï¼½ï¼š
â—
If UTF-8 bytes needed is 0, based on byte:
</p>
		<ol>
			<li>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
â†‘</p>

				<dl class="switch">
					<dt>`00^X ã€œ `7F^X</dt>
					<dd>
~RET ~cp Â« %~byte Â»
â—
Return a code point whose value is byte.
</dd>

					<dt>`C2^X ã€œ `DF^X</dt>
					<dd>
						<ol>
							<li>
`~UTF-8è¦~byteæ•°$ ~SET 1
â—
Set UTF-8 bytes needed to 1.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `1F^X
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 5 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte &amp; 0x1F.
â—
The five least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`E0^X ã€œ `EF^X</dt>
					<dd>
						<ol>
							<li>
~IFï¼»
%~byte ~EQ `E0^X
ï¼½
â‡’
`~UTF-8ä¸‹é™$ ~SET `A0^X
â—
If byte is 0xE0, set UTF-8 lower boundary to 0xA0.
</li>
							<li>
~IFï¼»
%~byte ~EQ `ED^X
ï¼½
â‡’
`~UTF-8ä¸Šé™$ ~SET `9F^X
â—
If byte is 0xED, set UTF-8 upper boundary to 0x9F.
</li>
							<li>
`~UTF-8è¦~byteæ•°$ ~SET 2
â—
Set UTF-8 bytes needed to 2.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `F^X
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 4 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte &amp; 0xF.
â—
The four least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`F0^X ã€œ `F4^X</dt>
					<dd>
						<ol>
							<li>
~IFï¼»
%~byte ~EQ `F0^X
ï¼½
â‡’
`~UTF-8ä¸‹é™$ ~SET `90^X
â—
If byte is 0xF0, set UTF-8 lower boundary to 0x90.
</li>
							<li>
~IFï¼»
%~byte ~EQ `F4^X
ï¼½
â‡’
`~UTF-8ä¸Šé™$ ~SET `8F^X
â—
If byte is 0xF4, set UTF-8 upper boundary to 0x8F.
</li>
							<li>
`~UTF-8è¦~byteæ•°$ ~SET 3
â—
Set UTF-8 bytes needed to 3.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `7^X
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 3 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte &amp; 0x7.
â—
The three least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>
ãã®ä»–
â—
Otherwise
</dt>
					<dd>
~RET `~error$i
â—
Return error.
</dd>
				</dl>
			</li>
			<li>
~RET `ç¶™ç¶š-$i
â—
Return continue.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
%~byte ~NIN { `~UTF-8ä¸‹é™$ ã€œ `~UTF-8ä¸Šé™$ }
ï¼½ï¼š
â—
If byte is not in the range UTF-8 lower boundary to UTF-8 upper boundary, inclusive:
</p>
		<ol>
			<li>
( `~UTF-8~cp$, `~UTF-8è¦~byteæ•°$, `~UTF-8å‡ºç¾~byteæ•°$ ) ~SET ( 0, 0, 0 )
â—
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0,ï¼¼
</li>
			<li>
( `~UTF-8ä¸‹é™$, `~UTF-8ä¸Šé™$ ) ~SET ( `80^X, `BF^X )
â—
set UTF-8 lower boundary to 0x80, and set UTF-8 upper boundary to 0xBF.
</li>
			<li>
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~byte )
â—
Restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
â—
Return error.
</li>
		</ol>
	</li>
	<li>
( `~UTF-8ä¸‹é™$, `~UTF-8ä¸Šé™$ ) ~SET ( `80^X, `BF^X )
â—
Set UTF-8 lower boundary to 0x80 and UTF-8 upper boundary to 0xBF.
</li>
	<li>
<p>
`~UTF-8~cp$ ~SET (`~UTF-8~cp$ ~Lshift 6) ~bOR (%~byte ~bAND `3F^X)
â—
Set UTF-8 code point to (UTF-8 code point &lt;&lt; 6) | (byte &amp; 0x3F)
</p>

<p class="note">æ³¨è¨˜ï¼š
`~UTF-8~cp$å†…ã®æ—¢å­˜ã®~bitã‚’å·¦ã¸ 6 ~bit ~shiftã—ã¦ï¼Œ~~ç©ºã„ãŸä¸‹ä½ 6 ~bitã« %~byte ã®ä¸‹ä½ 6 ~bitã‚’ã‚ã¦ãŒã†ã€‚
â—
Shift the existing bits of UTF-8 code point left by six places and set the newly-vacated six least significant bits to the six least significant bits of byte.
</p>
	</li>
	<li>
`~UTF-8å‡ºç¾~byteæ•°$ ~INCBY 1
â—
Increase UTF-8 bytes seen by one.
</li>
	<li>
~IFï¼»
`~UTF-8å‡ºç¾~byteæ•°$ ~NEQ `~UTF-8è¦~byteæ•°$
ï¼½
â‡’
~RET `ç¶™ç¶š-$i
â—
If UTF-8 bytes seen is not equal to UTF-8 bytes needed, then return continue.
</li>
	<li>
%~cp ~LET `~UTF-8~cp$
â—
Let codePoint be UTF-8 code point.
</li>
	<li>
( `~UTF-8~cp$, `~UTF-8è¦~byteæ•°$, `~UTF-8å‡ºç¾~byteæ•°$ ) ~SET ( 0, 0, 0 )
â—
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0.
</li>
	<li>
~RET ~cp Â« %~cp Â»
â—
Return a code point whose value is codePoint.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
`~UTF-8å¾©å·å™¨$ã«ãŠã‘ã‚‹ä¸Šã®æ‹˜æŸã¯ã€
~Unicodeæ¨™æº–ã®
â€œ`Best Practices for Using U+FFFD^enâ€
ã«æº–ã˜ã‚‹ã€‚
ä»–ã®æŒ™å‹•ã¯ã€
Encoding æ¨™æº–ã®ä¸‹ã§ã¯è¨±å¯ã•ã‚Œãªã„
ï¼ˆåŒã˜çµæœã‚’é”æˆã™ã‚‹ãªã‚‰ã€
ä»–ã®~algoã§ã‚‚~~ååˆ†ã§ã‚ã‚Šï¼Œã‚€ã—ã‚å¥¨åŠ±ã•ã‚Œã‚‹ï¼‰ã€‚
`UNICODE$r
â—
The constraints in the UTF-8 decoder above match â€œBest Practices for Using U+FFFDâ€ from the Unicode standard. No other behavior is permitted per the Encoding Standard (other algorithms that achieve the same result are fine, even encouraged). [UNICODE]
</p>
</div>

			</section>
			<section id="utf-8-encoder">
<h4 title="UTF-8 encoder">8.1.2. ~UTF-8ç¬¦å·åŒ–å™¨</h4>

<div class="algo">
<p>
`UTF-8$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~cp )
ã«å¯¾ã—ï¼š
â—
UTF-8â€™s encoderâ€™s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoQ$
ï¼½
â‡’
~RET `å®Œé‚d$i
â—
If codePoint is end-of-queue, then return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byte Â« %~cp Â»
â—
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
<p>
( %count, %~offset ) ~SET %~cp ãŒå±ã™ã‚‹ç¯„å›²ã«å¿œã˜ã¦
â‡’ï¼ƒ
{ `0080^U ã€œ `07FF^U } ãªã‚‰ã° ( 1, `C0^X ) ï¼
{ `0800^U ã€œ `FFFF^U } ãªã‚‰ã° ( 2, `E0^X ) ï¼
{ `10000^U ã€œ `10FFFF^U } ãªã‚‰ã° ( 3, `F0^X )
â—
Set count and offset based on the range codePoint is in:
â—
U+0080 to U+07FF, inclusive
â€¢ 1 and 0xC0
U+0800 to U+FFFF, inclusive
â€¢ 2 and 0xE0
U+10000 to U+10FFFF, inclusive
â€¢ 3 and 0xF0
</li>
	<li>
%~byteåˆ— ~LET ~byte Â« ( %~cp ~Rshift ( 6 ~MUL %count ) ) ~PLUS %~offset Â»
â—
Let bytes be a byte sequence whose first byte is (codePoint &gt;&gt; (6 Ã— count)) + offset.
</li>
	<li>
<p>
~WHILEï¼»
%count ~GT 0
ï¼½ï¼š
â—
While count is greater than 0:
</p>
		<ol>
			<li>
%temp ~SET %~cp ~Rshift ( 6 ~MUL ( %count ~MINUS 1 ) )
â—
Set temp to codePoint &gt;&gt; (6 Ã— (count âˆ’ 1)).
</li>
			<li>
%~byteåˆ— ã«
( `80^X ~bOR ( %temp ~bAND `3F^X ) )
ã‚’ä»˜åŠ ã™ã‚‹
â—
Append to bytes 0x80 | (temp &amp; 0x3F).
</li>
			<li>
%count ~DECBY 1
â—
Decrease count by one.
</li>
		</ol>
	</li>
	<li>
~RET %~byteåˆ—
â—
Return bytes bytes, in order.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®~algoã¯ã€
~Unicodeæ¨™æº–ã«è¿°ã¹ã‚‰ã‚Œã‚‹ã‚‚ã®ã¨ä¸€è‡´ã™ã‚‹çµæœã‚’å¾—ã‚‹ãŒï¼Œå®Œå…¨ã•ã®ãŸã‚ã“ã“ã«å«ã‚ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
`UNICODE$r
â—
This algorithm has identical results to the one described in the Unicode standard. It is included here for completeness. [UNICODE]
</p>
</div>

			</section>
		</section>
	</section>
	<section id="legacy-single-byte-encodings">
<h2 title="Legacy single-byte encodings">9. æ—§æ¥ã®å˜-~byteç¬¦å·åŒ–æ³•</h2>

<p>
`ç¬¦å·åŒ–æ³•$ã®ã†ã¡ï¼»
å„~byteãŒï¼Œ 1 å€‹ã®~cpã«å¯¾å¿œã™ã‚‹ã‹, ã©ã®~cpã«ã‚‚å¯¾å¿œã—ãªã„ã‚‚ã®
ï¼½ã¯ã€
`å˜-~byteç¬¦å·åŒ–æ³•@
ã¨ç·ç§°ã•ã‚Œã‚‹ã€‚
ã™ã¹ã¦ã®`å˜-~byteç¬¦å·åŒ–æ³•$ãŒã€
åŒã˜ï¼»
`å¾©å·å™¨$, `ç¬¦å·åŒ–å™¨$
ï¼½ã‚’å…±æœ‰ã™ã‚‹ã€‚
`å˜-~byteå¾©å·å™¨$ï¼`å˜-~byteç¬¦å·åŒ–å™¨$ã‹ã‚‰å‚ç…§ã•ã‚Œã‚‹
`å˜-~byteç´¢å¼•@
ã¯ã€
åˆ©ç”¨-ä¸­ã«ã‚ã‚‹`å˜-~byteç¬¦å·åŒ–æ³•$ã«ä¾å­˜ã—ï¼Œæ¬¡ã®è¡¨tã§å®šç¾©ã•ã‚Œã‚‹ã€‚
ï¼»
`ISO-8859-8^n, `ISO-8859-8-I^n
ï¼½ã‚’é™¤ãã™ã¹ã¦ã®`å˜-~byteç¬¦å·åŒ–æ³•$ã¯ã€
ãã‚Œãã‚Œã«ä¸€æ„ãª`ç´¢å¼•$ã‚’æŒã¤ã€‚
â—
An encoding where each byte is either a single code point or nothing, is a single-byte encoding. Single-byte encodings share the decoder and encoder. Index single-byte, as referenced by the single-byte decoder and single-byte encoder, is defined by the following table, and depends on the single-byte encoding in use. All but two single-byte encodings have a unique index.
</p>

<p class="trans-note">ã€
è¢«è¦†åŸŸã®~tableã¯å·¨å¤§ãªã“ã¨ã«æ³¨æ„ã€‚
ã€‘ã€
è¦–è¦š-åŒ–~tableã®å„~cellã®è‰²ã«ã¤ã„ã¦ã¯ã€
`å‡¡ä¾‹ï¼ #visualization$ã‚’è¦‹ã‚ˆã€‚
ã€‘</p>

<table><thead>
<tr><th>`åå‰$
<th>`ç´¢å¼•$
<th>è¦–è¦š-åŒ–
<th>åŸºæœ¬å¤šè¨€èªé¢ï¼ˆ BMP ï¼‰ã®è¢«è¦†åŸŸ
<tbody>

<tr><td>`IBM866@n<td>`IBM866$idx
<tr><td>`ISO-8859-2@n<td>`ISO-8859-2$idx
<tr><td>`ISO-8859-3@n<td>`ISO-8859-3$idx
<tr><td>`ISO-8859-4@n<td>`ISO-8859-4$idx
<tr><td>`ISO-8859-5@n<td>`ISO-8859-5$idx
<tr><td>`ISO-8859-6@n<td>`ISO-8859-6$idx
<tr><td>`ISO-8859-7@n<td>`ISO-8859-7$idx
<tr><td>`ISO-8859-8@n<td>`ISO-8859-8$idx
<tr><td>`ISO-8859-8-I@n<td colspan="3">`ISO-8859-8$n ã¨åŒã˜
<tr><td>`ISO-8859-10@n<td>`ISO-8859-10$idx
<tr><td>`ISO-8859-13@n<td>`ISO-8859-13$idx
<tr><td>`ISO-8859-14@n<td>`ISO-8859-14$idx
<tr><td>`ISO-8859-15@n<td>`ISO-8859-15$idx
<tr><td>`ISO-8859-16@n<td>`ISO-8859-16$idx
<tr><td>`KOI8-R@n<td>`KOI8-R$idx
<tr><td>`KOI8-U@n<td>`KOI8-U$idx
<tr><td>`macintosh@n<td>`macintosh$idx
<tr><td>`windows-874@n<td>`windows-874$idx
<tr><td>`windows-1250@n<td>`windows-1250$idx
<tr><td>`windows-1251@n<td>`windows-1251$idx
<tr><td>`windows-1252@n<td>`windows-1252$idx
<tr><td>`windows-1253@n<td>`windows-1253$idx
<tr><td>`windows-1254@n<td>`windows-1254$idx
<tr><td>`windows-1255@n<td>`windows-1255$idx
<tr><td>`windows-1256@n<td>`windows-1256$idx
<tr><td>`windows-1257@n<td>`windows-1257$idx
<tr><td>`windows-1258@n<td>`windows-1258$idx
<tr><td>`x-mac-cyrillic@n<td>`x-mac-cyrillic$idx
</table>

<p class="note">æ³¨è¨˜ï¼š
~layoutæ–¹å‘ã«æ³¢åŠã™ã‚‹ã“ã¨ã‹ã‚‰ã€
`ISO-8859-8$n ã¨ `ISO-8859-8-I$n ã®`ç¬¦å·åŒ–æ³•$ã®`åå‰$ã¯ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ã€‚
æ­´å²çš„ã«ã€
ã“ã®ã“ã¨ã¯ `ISO-8859-6$n ã¨ "ISO-8859-6-I" ã«ã¤ã„ã¦ã‚‚è©²å½“ã—ã¦ã„ãŸãŒã€
ãã‚Œã¯ã‚‚ã¯ã‚„æˆç«‹ã—ãªã„ã€‚
ã€ï¼ https://www.w3.org/Bugs/Public/show_bug.cgi?id=19505 ã€‘
â—
ISO-8859-8 and ISO-8859-8-I are distinct encoding names, because ISO-8859-8 has influence on the layout direction. And although historically this might have been the case for ISO-8859-6 and "ISO-8859-6-I" as well, that is no longer true.
</p>

		<section id="single-byte-decoder">
<h3 title="single-byte decoder">9.1. å˜-~byteå¾©å·å™¨</h3>

<div class="algo">
<p>
`å˜-~byteç¬¦å·åŒ–æ³•$ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~byte )
ã«å¯¾ã—ï¼š
â—
Single-byte encodingsâ€™s decoderâ€™s handler, given unused and byte, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~byte ~EQ `~EoQ$
ï¼½
â‡’
~RET `å®Œé‚d$i
â—
If byte is end-of-queue, then return finished.
</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp Â« %~byte Â»
â—
If byte is an ASCII byte, then return a code point whose value is byte.
</li>
	<li>
%~cp ~LET
`å˜-~byteç´¢å¼•$ ã®ä¸­ã§
( %~byte ~MINUS `80^X )
ãŒæŒ‡ã™`ç´¢å¼•~cp$
â—
Let codePoint be the index code point for byte âˆ’ 0x80 in index single-byte.
</li>
	<li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET `~error$i
â—
If codePoint is null, then return error.
</li>
	<li>
~RET ~cp Â« %~cp Â»
â—
Return a code point whose value is codePoint.
</li>
</ol>
</div>

		</section>
		<section id="single-byte-encoder">
<h3 title="single-byte encoder">9.2. å˜-~byteç¬¦å·åŒ–å™¨</h3>

<div class="algo">
<p>
`å˜-~byteç¬¦å·åŒ–æ³•$ ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~cp )
ã«å¯¾ã—ï¼š
â—
Single-byte encodingsâ€™s encoderâ€™s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoQ$
ï¼½
â‡’
~RET `å®Œé‚d$i
â—
If codePoint is end-of-queue, then return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byte Â« %~cp Â»
â—
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
%~pointer ~LET
`å˜-~byteç´¢å¼•$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for codePoint in index single-byte.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET `~error$i( %~cp )
â—
If pointer is null, then return error with codePoint.
</li>
	<li>
~RET ~byte Â« %~pointer ~PLUS `80^X Â»
â—
Return a byte whose value is pointer + 0x80.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(simplified)-encodings">
<h2 title="Legacy multi-byte Chinese (simplified) encodings">10. æ—§æ¥ã®è¤‡-~byte~Chineseï¼ˆç°¡ä½“å­—ï¼‰ ç¬¦å·åŒ–æ³•</h2>

		<section id="gbk">
<h3 title="GBK">10.1. ~GBK</h3>

			<section id="gbk-decoder">
<h4 title="GBK decoder">10.1.1. ~GBKå¾©å·å™¨</h4>

<p>
`GBK$n ã®`å¾©å·å™¨$ã¯ï¼Œ`gb18030$n ã®`å¾©å·å™¨$ã§ã‚ã‚‹ã€‚
â—
GBKâ€™s decoder is gb18030â€™s decoder.
</p>

			</section>
			<section id="gbk-encoder">
<h4 title="GBK encoder">10.1.2. ~GBKç¬¦å·åŒ–å™¨</h4>

<p>
`GBK$n ã®ç¬¦å·åŒ–å™¨ã¯ï¼Œï¼»
`~GBKç”¨ã‹$ ~SET ~T
ï¼½ã«ã•ã‚ŒãŸ`gb18030$n ã®`ç¬¦å·åŒ–å™¨$ã§ã‚ã‚‹ã€‚
â—
GBKâ€™s encoder is gb18030â€™s encoder with its is GBK set to true.
</p>

<p class="note">æ³¨è¨˜ï¼š
`GBK$n ã‚’`gb18030$nã«å¯¾ã™ã‚‹å…¨ãã®åˆ¥åã«ã—ãªã„ã®ã¯ã€
`GBK$n ã®`ç¬¦å·åŒ–å™¨$ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚ŒãŸå†…å®¹ã‚’ï¼»
æ—§æ¥ã®~serverã‚„ä»–ã®æ¶ˆè²»å™¨ã‚’éäº’æ›åŒ–ã™ã‚‹æ©Ÿä¼šcã‚’æ¸›ã‚‰ã™ã‚ˆã†ï¼Œä¿å®ˆçš„ã«ç§»è¡Œã™ã‚‹
ï¼½ãŸã‚ã§ã‚ã‚‹ã€‚
â—
Not fully aliasing GBK with gb18030 is a conservative move to decrease the chances of breaking legacy servers and other consumers of content generated with GBKâ€™s encoder.
</p>

			</section>
		</section>
		<section id="gb18030">
<h3 title="gb18030">10.2. ~gb18030</h3>

			<section id="gb18030-decoder">
<h4 title="gb18030 decoder">10.2.1. ~gb18030å¾©å·å™¨</h4>

<p>
å„ï¼»
`gb18030$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`~gb1@ï¼ˆåˆæœŸ~æ™‚ã¯ 0 ï¼‰,
`~gb2@ï¼ˆåˆæœŸ~æ™‚ã¯ 0 ï¼‰,
`~gb3@ï¼ˆåˆæœŸ~æ™‚ã¯ 0 ï¼‰
â—
gb18030â€™s decoder has an associated gb18030 first, gb18030 second, and gb18030 third (all initially 0x00).
</p>

<div class="algo">
<p>
`gb18030$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %å…¥å‡ºåŠ›~queue, %~byte )
ã«å¯¾ã—ï¼š
â—
gb18030â€™s decoderâ€™s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoQ$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
( `~gb1$, `~gb2$, `~gb3$ ) ~EQ ( `00^X, `00^X, `00^X )
ï¼½
â‡’
~RET `å®Œé‚d$i
â—
If byte is end-of-queue and gb18030 first, gb18030 second, and gb18030 third are 0x00, then return finished.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
â—
If byte is end-of-queue, and gb18030 first, gb18030 second, or gb18030 third is not 0x00, then set gb18030 first, gb18030 second, and gb18030 third to 0x00, andï¼¼
</li>
			<li>
~RET `~error$i
â—
return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~gb3$ ~NEQ `00^X
ï¼½ï¼š
â—
If gb18030 third is not 0x00:
</p>
		<ol>
			<li>
<p>
~IFï¼»
%~byte ~NIN { `30^X ã€œ `39^X }
ï¼½ï¼š
â—
If byte is not in the range 0x30 to 0x39, inclusive:
</p>
				<ol>
					<li>
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, ~byteåˆ— Â« `~gb2$, `~gb3$, %~byte Â» ) 
â—
Restore Â« gb18030 second, gb18030 third, byte Â» to ioQueue.
</li>
					<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
â—
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
					<li>
~RET `~error$i
â—
Return error.
</li>
				</ol>
			</li>
			<li>
%~cp ~LET æ¬¡ã«ä¸ãˆã‚‹~pointerãŒæŒ‡ã™`ç´¢å¼•~gb18030ç¯„å›²~ç¾¤~cp$
â‡’
(( `~gb1$ ~MINUS `81^X ) ~MUL ( 10 ~MUL 126 ~MUL 10 )) ~PLUS
(( `~gb2$ ~MINUS `30^X ) ~MUL ( 10 ~MUL 126 )) ~PLUS
(( `~gb3$ ~MINUS `81^X ) ~MUL 10 ) ~PLUS
( %~byte ~MINUS `30^X )
â—
Let codePoint be the index gb18030 ranges code point for ((gb18030 first âˆ’ 0x81) Ã— (10 Ã— 126 Ã— 10)) + ((gb18030 second âˆ’ 0x30) Ã— (10 Ã— 126)) + ((gb18030 third âˆ’ 0x81) Ã— 10) + byte âˆ’ 0x30.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
â—
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
			<li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET `~error$i
â—
If codePoint is null, then return error.
</li>
			<li>
~RET ~cp Â« %~cp Â»
â—
Return a code point whose value is codePoint.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~gb2$ ~NEQ `00^X
ï¼½ï¼š
â—
If gb18030 second is not 0x00:
</p>
		<ol>
			<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~gb3$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$i
â—
If byte is in the range 0x81 to 0xFE, inclusive, then set gb18030 third to byte and return continue.
</li>
			<li>
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, ~byteåˆ— Â« `~gb2$, %~byte Â» )
â—
Restore Â« gb18030 second, byte Â» to ioQueueï¼¼
</li>
			<li>
( `~gb1$, `~gb2$ ) ~SET ( `00^X, `00^X )
â—
set gb18030 first and gb18030 second to 0x00, andï¼¼
</li>
			<li>
~RET `~error$i
â—
return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~gb1$ ~NEQ `00^X
ï¼½ï¼š
â—
If gb18030 first is not 0x00:
</p>
		<ol>
			<li>
~IFï¼»
%~byte ~IN { `30^X ã€œ `39^X }
ï¼½
â‡’ï¼ƒ
`~gb2$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$i
â—
If byte is in the range 0x30 to 0x39, inclusive, set gb18030 second to byte and return continue.
</li>
			<li>
%~lead ~LET `~gb1$
â—
Let lead be gb18030 first,ï¼¼
</li>
			<li>
%~pointer ~LET ~NULL
â—
let pointer be null, andï¼¼
</li>
			<li>
`~gb1$ ~SET `00^X
â—
set gb18030 first to 0x00.
</li>
			<li>
%~offset ~LET ï¼»
%~byte ~IN { `00^X ã€œ `7E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40 if byte is less than 0x7F; otherwise 0x41.
</li>
			<li>
~IFï¼»
%~byte ~IN { `40^X ã€œ `7E^X, `80^X ã€œ `FE^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS %~offset )
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 190 + (byte âˆ’ offset).
</li>
			<li>
%~cp ~LET %~pointer ã«å¿œã˜ã¦
â‡’
~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ `ç´¢å¼•~gb18030$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
â—
Let codePoint be null if pointer is null; otherwise the index code point for pointer in index gb18030.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp Â« %~cp Â»
â—
If codePoint is non-null, then return a code point whose value is codePoint.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~byte )
â—
If byte is an ASCII byte, then restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~gb1$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$i
â—
â†“</li>
	<li>
~RET %~byte ã«å¿œã˜ã¦
â‡’ï¼ƒ
`~ASCII~byte$ãªã‚‰ã° ~cp Â« %~byte Â» ï¼
`80^X ãªã‚‰ã° ~cp Â« `20AC^U `â‚¬^smb Â» ï¼
`FF^X ãªã‚‰ã° `~error$i
â—
If byte is an ASCII byte, then return a code point whose value is byte.
â—
If byte is 0x80, then return code point U+20AC (â‚¬).
â—
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 first to byte and return continue.
â—
Return error.
</li>
</ol>
</div>

			</section>
			<section id="gb18030-encoder">
<h4 title="gb18030 encoder">10.2.2. ~gb18030ç¬¦å·åŒ–å™¨</h4>

<p>
å„ï¼»
`gb18030$n ã®`ç¬¦å·åŒ–å™¨$
ï¼½ã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~GBKç”¨ã‹@
ï¼ˆåˆæœŸ~æ™‚ã¯ ~F ï¼‰
â—
gb18030â€™s encoder has an associated is GBK (initially false).
</p>

<div class="algo">
<p>
`gb18030$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~cp )
ã«å¯¾ã—ï¼š
â—
gb18030â€™s encoderâ€™s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoQ$
ï¼½
â‡’
~RET `å®Œé‚d$i
â—
If codePoint is end-of-queue, then return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byte Â« %~cp Â»
â—
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
<p>
~IFï¼»
%~cp ~EQ `E5E5^U
ï¼½
â‡’
~RET `~error$i( %~cp )
â—
If codePoint is U+E5E5, then return error with codePoint.
</p>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™-æ¸ˆã¿ãªå†…å®¹ã¨ã®äº’æ›æ€§ã‚’å¾—ã‚‹ãŸã‚ã€
`ç´¢å¼•~gb18030$ ã¯ï¼»
`A3^X `A0^X
ï¼½ã‚’ `E5E5^U ã§ã¯ãªã `3000^U ã«å¯¾å¿œä»˜ã‘ã¦ã„ã‚‹ã€‚
ã—ãŸãŒã£ã¦ã€
ãã‚Œã¯å¾€å¾©ã—å¾—ãªã„ã€‚
â—
Index gb18030 maps 0xA3 0xA0 to U+3000 rather than U+E5E5 for compatibility with deployed content. Therefore it cannot roundtrip.
</p>

</li>
	<li>
~IFï¼»
`~GBKç”¨ã‹$ ~EQ ~T
ï¼½~ANDï¼»
%~cp ~EQ `20AC^U `â‚¬^smb
ï¼½
â‡’
~RET ~byte Â« `80^X Â»
â—
If is GBK is true and codePoint is U+20AC (â‚¬), then return byte 0x80.
</li>
	<li>
<p>
ä¸‹ã®è¡¨tã‚’æˆã™
~EACH( %è¡Œ )
ã«å¯¾ã—
â‡’
~IFï¼»
%~cp ~EQ %è¡Œ ã® 1 åˆ—ç›®ã«æŒ™ã’ã‚‰ã‚Œã‚‹~cp
ï¼½
â‡’
~RET %è¡Œ ã® 2 åˆ—ç›®ã«æŒ™ã’ã‚‰ã‚Œã‚‹~byteåˆ—
â—
If there is a row in the table below whose first column is codePoint, then return the two bytes on the same row listed in the second column:
</p>

<table><tbody>
<tr><th>~cp
<th>~byteåˆ—

<tr><td>`E78D^U
<td>`A6^X `D9^X

<tr><td>`E78E^U
<td>`A6^X `DA^X

<tr><td>`E78F^U
<td>`A6^X `DB^X

<tr><td>`E790^U
<td>`A6^X `DC^X

<tr><td>`E791^U
<td>`A6^X `DD^X

<tr><td>`E792^U
<td>`A6^X `DE^X

<tr><td>`E793^U
<td>`A6^X `DF^X

<tr><td>`E794^U
<td>`A6^X `EC^X

<tr><td>`E795^U
<td>`A6^X `ED^X

<tr><td>`E796^U
<td>`A6^X `F3^X

<tr><td>`E81E^U
<td>`FE^X `59^X

<tr><td>`E826^U
<td>`FE^X `61^X

<tr><td>`E82B^U
<td>`FE^X `66^X

<tr><td>`E82C^U
<td>`FE^X `67^X

<tr><td>`E832^U
<td>`FE^X `6D^X

<tr><td>`E843^U
<td>`FE^X `7E^X

<tr><td>`E854^U
<td>`FE^X `90^X

<tr><td>`E864^U
<td>`FE^X `A0^X
</table>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®éå¯¾ç§°ãªç¬¦å·åŒ–å™¨~è¡¨tã¯ã€
GB18030-2005 æ¨™æº–ã¨ã®äº’æ›æ€§ã‚’ä¿å…¨ã™ã‚‹ã€‚
`ç´¢å¼•~gb18030ç¯„å›²~ç¾¤$ã«ãŠã‘ã‚‹èª¬æ˜ã‚‚è¦‹ã‚ˆã€‚
â—
This asymmetric encoder table preserves compatibility with the GB18030-2005 standard. See also the explanation at index gb18030 ranges.
</p>
	</li>
	<li>
%~pointer ~LET
`ç´¢å¼•~gb18030$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for codePoint in index gb18030.
</li>
	<li>
<p>
~IFï¼»
%~pointer ~NEQ ~NULL
ï¼½ï¼š
â—
If pointer is non-null:
</p>
		<ol>
			<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
â—
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET %~pointer ~MOD 190
â—
Let trail be pointer % 190.
</li>
			<li>
%~offset ~LET ï¼»
%~trail ~IN { `00^X ã€œ `3E^X } ãªã‚‰ã° `40^Xã€ï¼0x7F-0x40 ã€‘ ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40 if trail is less than 0x3F, otherwise 0x41.
</li>
			<li>
~RET ~byteåˆ— Â« %~lead, ( %~trail ~PLUS %~offset ) Â»
â—
Return two bytes whose values are lead and trail + offset.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
`~GBKç”¨ã‹$ ~EQ ~T
ï¼½
â‡’
~RET `~error$i( %~cp )
â—
If is GBK is true, then return error with codePoint.
</li>
	<li>
%~pointer ~SET
%~cp
ã‚’æŒ‡ã™`ç´¢å¼•~gb18030ç¯„å›²~ç¾¤~pointer$
â—
Set pointer to the index gb18030 ranges pointer for codePoint.
</li>
	<li>
%byte1 ~LET %~pointer ~DIV ( 10 ~MUL 126 ~MUL 10 )
â—
Let byte1 be pointer / (10 Ã— 126 Ã— 10).
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 ~MUL 10 )
â—
Set pointer to pointer % (10 Ã— 126 Ã— 10).
</li>
	<li>
%byte2 ~LET %~pointer ~DIV ( 10 ~MUL 126 )
â—
Let byte2 be pointer / (10 Ã— 126).
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 )
â—
Set pointer to pointer % (10 Ã— 126).
</li>
	<li>
%byte3 ~LET %~pointer ~DIV 10
â—
Let byte3 be pointer / 10.
</li>
	<li>
%byte4 ~LET %~pointer ~MOD 10
â—
Let byte4 be pointer % 10.
</li>
	<li>
~RET ~byteåˆ— Â«
( %byte1 ~PLUS `81^X ),
( %byte2 ~PLUS `30^X ),
( %byte3 ~PLUS `81^X ),
( %byte4 ~PLUS `30^X )
Â»
â—
Return four bytes whose values are byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(traditional)-encodings">
<h2 title="Legacy multi-byte Chinese (traditional) encodings">11. æ—§æ¥ã®è¤‡-~byte~Chineseï¼ˆç¹ä½“å­—ï¼‰ç¬¦å·åŒ–æ³•</h2>

ã€ï¼ Lead:  0x81 to 0xFE ï¼ Trail: 0x40 to 0x7E or 0xA1 to 0xFE ã€‘

		<section id="big5">
<h3 title="Big5">11.1. ~Big5</h3>

			<section id="big5-decoder">
<h4 title="Big5 decoder">11.1.1. ~Big5å¾©å·å™¨</h4>

<p>
å„ï¼»
`Big5$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~Big5~lead@ï¼ˆåˆæœŸ~æ™‚ã¯ `00^X ï¼‰
â—
Big5â€™s decoder has an associated Big5 lead (initially 0x00).
</p>

<div class="algo">
<p>
`Big5$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %å…¥å‡ºåŠ›~queue, %~byte )
ã«å¯¾ã—ï¼š
â—
Big5â€™s decoderâ€™s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoQ$
ï¼½ï¼š
</p>
		<ol>
			<li>
~IFï¼»
`~Big5~lead$ ~NEQ `00^X
ï¼½
â‡’ï¼ƒ
`~Big5~lead$ ~SET `00^X ï¼›
~RET `~error$i
</li>
			<li>
~RET `å®Œé‚d$i
</li>
		</ol>
â—
If byte is end-of-queue and Big5 lead is not 0x00, then set Big5 lead to 0x00 and return error.
â—
If byte is end-of-queue and Big5 lead is 0x00, then return finished.
</li>
	<li>
<p>
~IFï¼»
`~Big5~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If Big5 lead is not 0x00:
</p>
		<ol>
			<li>
%~lead ~LET `~Big5~lead$
â—
Let lead be Big5 lead.
</li>
			<li>
`~Big5~lead$ ~SET `00^X
â—
Set Big5 lead to 0x00.
</li>
			<li>
%~pointer ~LET ~NULL
â—
Let pointer be null.
</li>
			<li>
%~offset ~LET ï¼»
%~byte ~IN { `00^X ã€œ `7E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `62^X ã€ï¼ 0x62 = 0xA1-0x7E+1+0x40 ã€‘
ï¼½
â—
Let offset be 0x40 if byte is less than 0x7F; otherwise 0x62.
</li>
			<li>
~IFï¼»
%~byte ~IN { `40^X ã€œ `7E^X, `A1^X ã€œ `FE^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 157 ~PLUS ( %~byte ~MINUS %~offset )
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 157 + (byte âˆ’ offset).
</li>
			<li>
<p>
~IFï¼»
ä¸‹ã®è¡¨tã®ä¸­ã§ï¼Œ 1 åˆ—ç›®ãŒ %~pointer ã«ç­‰ã—ã„è¡ŒãŒã‚ã‚‹
ï¼½
â‡’
~RET åŒã˜è¡Œã® 2 åˆ—ç›®ã«ä¸ãˆã‚‹~cpåˆ—ï¼ˆ `2 å€‹ã®^em ~cpã‹ã‚‰ãªã‚‹ï¼‰
â—
If there is a row in the table below whose first column is pointer, then return the two code points listed in its second column (the third column is irrelevant):
</p>

ã€ï¼ https://www.unicode.org/Public/UNIDATA/NamedSequences.txt ã€‘
<div>
<table><thead>
<tr><th>~pointer
<th>~cp
<th>æ³¨è¨˜ï¼ˆã“ã®æ®µã«ã¯é–¢é€£ã—ãªã„ï¼‰
<tbody id="_big5-lead">

<tr><td>1133ã€ï¼ 0x88 0x62 ã€‘
<td>`00CA^U `0304^U
<td>ÃŠÌ„ 
( `LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON^cn )

<tr><td>1135ã€ï¼ 0x88 0x64 ã€‘
<td>`00CA^U `030C^U
<td>ÃŠÌŒ 
( `LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON^cn )

<tr><td>1164ã€ï¼ 0x88 0xA3 ã€‘
<td>`00EA^U `0304^U
<td>ÃªÌ„ 
( `LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON^cn )

<tr><td>1166ã€ï¼ 0x88 0xA5 ã€‘
<td>`00EA^U `030C^U
<td>ÃªÌŒ 
( `LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON^cn )
</table>

ã€ï¼~UAï¼ç’°å¢ƒï¼è¨€èª~codeã«ã‚ˆã£ã¦ã¯ã€~glyphãŒçµåˆã•ã‚Œãšï¼Œæ­£ã—ãè¡¨ç¤ºã•ã‚Œãªã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚ã€‘
ã€ï¼lang=ja ã®ä¸‹ã§ã¯æ­£ã—ãè¡¨ç¤ºã•ã‚Œãªã„~UAãŒã‚ã‚‹ã€‘
ã€ï¼lang=en ã®ä¸‹ã§ã‚‚æ­£ã—ãè¡¨ç¤ºã—ãªã„~UAãŒã‚ã‚‹ã€‘
ã€ï¼æ–‡å­—å‚ç…§ï¼ˆ&#x00EA;&#x030C;ï¼‰ã‚’åˆ©ç”¨ã™ã‚‹ã¨ç•°ãªã‚‹è¡¨ç¤ºã«ãªã‚‹~UAã‚‚ã‚ã‚‹ã€‘

â—
Pointerï½œCode pointsï½œNotes
1133ï½œU+00CA U+0304ï½œÃŠÌ„ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON)
1135ï½œU+00CA U+030Cï½œÃŠÌŒ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON)
1164ï½œU+00EA U+0304ï½œÃªÌ„ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON)
1166ï½œU+00EA U+030Cï½œÃªÌŒ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON)
</div>

<p class="note">æ³¨è¨˜ï¼š
`ç´¢å¼•$ã¯å˜ç‹¬ã®~cpã«åˆ¶é™ã•ã‚Œã‚‹ã®ã§ã€
ã“ã‚Œã‚‰ã®~pointerã«ã¯ã“ã®è¡¨tãŒåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
Since indexes are limited to single code points this table is used for these pointers.
</p>
			</li>
			<li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ `ç´¢å¼•~Big5$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
ï¼½
â—
Let codePoint be null if pointer is null; otherwise the index code point for pointer in index Big5.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp Â« %~cp Â»
â—
If codePoint is non-null, then return a code point whose value is codePoint.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~byte )
â—
If byte is an ASCII byte, restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp Â« %~byte Â»
â—
If byte is an ASCII byte, then return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~Big5~lead$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$i
â—
If byte is in the range 0x81 to 0xFE, inclusive, then set Big5 lead to byte and return continue.
</li>
	<li>
~RET `~error$i
â—
Return error.
</li>
</ol>
</div>

			</section>
			<section id="big5-encoder">
<h4 title="Big5 encoder">11.1.2. ~Big5ç¬¦å·åŒ–å™¨</h4>

<div class="algo">
<p>
`Big5$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~cp )
ã«å¯¾ã—ï¼š
â—
Big5â€™s encoderâ€™s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoQ$
ï¼½
â‡’
~RET `å®Œé‚d$i
â—
If codePoint is end-of-queue, then return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byte Â« %~cp Â»
â—
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
%~pointer ~LET %~cp ã‚’æŒ‡ã™`ç´¢å¼•~Big5~pointer$
â—
Let pointer be the index Big5 pointer for codePoint.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET `~error$i( %~cp )
â—
If pointer is null, then return error with codePoint.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 157 ) ~PLUS `81^X
â—
Let lead be pointer / 157 + 0x81.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 157
â—
Let trail be pointer % 157.
</li>
	<li>
%~offset ~LET ï¼»
%~trail ~IN { `00^X ã€œ `3E^X } ãªã‚‰ã° `40^Xã€ï¼0x7F-0x40 ã€‘ ï¼
~ELSE_ `62^Xã€ï¼0xA1-0x3F ã€‘
ï¼½
â—
Let offset be 0x40 if trail is less than 0x3F, otherwise 0x62.
</li>
	<li>
~RET ~byteåˆ— Â« %~lead, ( %~trail ~PLUS %~offset) Â»Â»
â—
Return two bytes whose values are lead and trail + offset.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-japanese-encodings">
<h2 title="Legacy multi-byte Japanese encodings">12. æ—§æ¥ã®è¤‡-~byte~Japaneseç¬¦å·åŒ–æ³•</h2>

		<section id="euc-jp">
<h3 title="EUC-JP">12.1. ~EUC-JP</h3>

ã€ï¼ ~IANA-a/charset-reg/CP51932 ã€‘

			<section id="euc-jp-decoder">
<h4 title="EUC-JP decoder">12.1.1. ~EUC-JPå¾©å·å™¨</h4>

<p>
å„ï¼»
`EUC-JP$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`~EUC-JP~jis0212@ï¼ˆåˆæœŸ~æ™‚ã¯ ~F ï¼‰ï¼›
`~EUC-JP~lead@ï¼ˆåˆæœŸ~æ™‚ã¯ `00^X ï¼‰
â—
EUC-JPâ€™s decoder has an associated EUC-JP jis0212 (initially false) and EUC-JP lead (initially 0x00).
</p>

<div class="algo">
<p>
`EUC-JP$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %å…¥å‡ºåŠ›~queue, %~byte )
ã«å¯¾ã—ï¼š
â—
EUC-JPâ€™s decoderâ€™s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoQ$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
`~EUC-JP~lead$ ~NEQ `00^X
ï¼½
â‡’ï¼ƒ
`~EUC-JP~lead$ ~SET `00^X ï¼›
~RET `~error$i
â—
If byte is end-of-queue and EUC-JP lead is not 0x00, then set EUC-JP lead to 0x00, and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚d$i
â—
If byte is end-of-queue and EUC-JP lead is 0x00, then return finished.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
`~EUC-JP~lead$ ~EQ `8E^X
ï¼½~ANDï¼»
%~byte ~IN { `A1^X ã€œ `DF^X }
ï¼½
ã€ï¼ katakana; subtraction is done first to avoid upsetting compilers ã€‘
â‡’ï¼ƒ
`~EUC-JP~lead$ ~SET `00^X ï¼›
~RET ~cp Â« `FF61^X ~MINUS `A1^X ~PLUS %~byte Â»
â—
If EUC-JP lead is 0x8E and byte is in the range 0xA1 to 0xDF, inclusive, set EUC-JP lead to 0x00 and return a code point whose value is 0xFF61 âˆ’ 0xA1 + byte.
</li>
	<li>
~IFï¼»
`~EUC-JP~lead$ ~EQ `8F^X
ï¼½~ANDï¼»
%~byte ~IN { `A1^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~EUC-JP~jis0212$ ~SET ~T ï¼›
`~EUC-JP~lead$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$i
â—
If EUC-JP lead is 0x8F and byte is in the range 0xA1 to 0xFE, inclusive, set EUC-JP jis0212 to true, set EUC-JP lead to byte, and return continue.
</li>
	<li>
<p>
~IFï¼»
`~EUC-JP~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If EUC-JP lead is not 0x00:
</p>
		<ol>
			<li>
%~lead ~LET `~EUC-JP~lead$
â—
Let lead be EUC-JP lead.
</li>
			<li>
`~EUC-JP~lead$ ~SET `00^X
â—
Set EUC-JP lead to 0x00.
</li>
			<li>
%~cp ~LET ~NULL
â—
Let codePoint be null.
</li>
			<li>
<p>
~IFï¼»
%~lead ~IN { `A1^X ã€œ `FE^X }
ï¼½~ANDï¼»
%~byte ~IN { `A1^X ã€œ `FE^X }
ï¼½ï¼š
</p>
				<ol>
					<li>
%ç´¢å¼• ~LET `~EUC-JP~jis0212$ã«å¿œã˜ã¦
â‡’ï¼ƒ
~F ãªã‚‰ã°`ç´¢å¼•~jis0208$ ï¼
~T ãªã‚‰ã° `ç´¢å¼•~jis0212$
</li>
					<li>
%~cp ~SET %ç´¢å¼• ã®ä¸­ã§
( ( %~lead ~MINUS `A1^X ) ~MUL 94 ~PLUS %~byte ~MINUS `A1^X )
ãŒæŒ‡ã™`ç´¢å¼•~cp$
</li>
				</ol>
â—
If lead and byte are both in the range 0xA1 to 0xFE, inclusive, then set codePoint to the index code point for (lead âˆ’ 0xA1) Ã— 94 + byte âˆ’ 0xA1 in index jis0208 if EUC-JP jis0212 is false and in index jis0212 otherwise.
</li>
			<li>
`~EUC-JP~jis0212$ ~SET ~F
â—
Set EUC-JP jis0212 to false.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp Â« %~cp Â»
â—
If codePoint is non-null, then return a code point whose value is codePoint.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~byte )
â—
If byte is an ASCII byte, restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp Â« %~byte Â»
â—
If byte is an ASCII byte, then return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `8E^X, `8F^X, `A1^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~EUC-JP~lead$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$i
â—
If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE, inclusive, then set EUC-JP lead to byte and return continue.
</li>
	<li>
~RET `~error$i
â—
Return error.
</li>
</ol>
</div>

			</section>
			<section id="euc-jp-encoder">
<h4 title="EUC-JP encoder">12.1.2. ~EUC-JPç¬¦å·åŒ–å™¨</h4>

<div class="algo">
<p>
`EUC-JP$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~cp )
ã«å¯¾ã—ï¼š
â—
EUC-JPâ€™s encoderâ€™s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
%çµæœ ~LET %~cp ã«å¿œã˜ã¦
â‡’ï¼ƒ
`~EoQ$ ãªã‚‰ã° `å®Œé‚d$i ï¼
`~ASCII~cp$ãªã‚‰ã° ~byte Â« %~cp Â» ï¼
`00A5^U `Â¥^smb ãªã‚‰ã° ~byte Â« `5C^X Â» ï¼
`203E^U `â€¾^smb ãªã‚‰ã° ~byte Â« `7E^X Â» ï¼
`FF61^U ã€œ `FF9F^U ãªã‚‰ã° ~byteåˆ— Â« `8E^X, ( %~cp ~MINUS `FF61^X ~PLUS `A1^X ) Â» ï¼
~ELSE_ ~NULL
â—
If codePoint is end-of-queue, then return finished.
â—
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
â—
If codePoint is U+00A5 (Â¥), then return byte 0x5C.
â—
If codePoint is U+203E (â€¾), then return byte 0x7E.
â—
If codePoint is in the range U+FF61 to U+FF9F, inclusive, then return two bytes whose values are 0x8E and codePoint âˆ’ 0xFF61 + 0xA1.
</li>
	<li>
~IFï¼»
%çµæœ ~NEQ ~NULL
ï¼½
â‡’
~RET %çµæœ
â—
â†‘</li>
	<li>
~IFï¼»
%~cp ~EQ `2212^U `âˆ’^smb
ï¼½
â‡’
%~cp ~SET `FF0D^U `ï¼^smb
â—
If codePoint is U+2212 (âˆ’), then set it to U+FF0D (ï¼).
</li>
	<li>
<p>
%~pointer ~LET `ç´¢å¼•~jis0208$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for codePoint in index jis0208.
</p>

<p class="note">æ³¨è¨˜ï¼š
%~pointer ã¯ã€
~NULL ã§ãªã‘ã‚Œã°ï¼Œ`ç´¢å¼•~jis0208$ã¨~pointeræ¼”ç®—ã®è³‡è³ªã«å› ã‚Š 8836 æœªæº€ã«ãªã‚‹ã€‚
â—
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET `~error$i( %~cp )
â—
If pointer is null, then return error with codePoint.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `A1^X
â—
Let lead be pointer / 94 + 0xA1.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `A1^X
â—
Let trail be pointer % 94 + 0xA1.
</li>
	<li>
~RET ~byteåˆ— Â« %~lead, %~trail Â»
â—
Return two bytes whose values are lead and trail.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="iso-2022-jp">
<h3 title="ISO-2022-JP">12.2. ~ISO-2022-JP</h3>

ã€ï¼ https://tools.ietf.org/html/rfc1468ã€‘
ã€ï¼ https://tools.ietf.org/html/rfc2237 (iso-2022-jp-1; not used)ã€‘
ã€ï¼ "ESC ) I" is from iso-2022-jp-3 reportedlyã€‘

			<section id="iso-2022-jp-decoder">
<h4 title="ISO-2022-JP decoder">12.2.1. ~ISO-2022-JPå¾©å·å™¨</h4>

<p>
å„ï¼»
`ISO-2022-JP$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹@ï¼ˆåˆæœŸ~æ™‚ã¯ `ASCII$i ï¼‰,
`~ISO-2022-JPå¾©å·å™¨~å‡ºåŠ›~çŠ¶æ…‹@ï¼ˆåˆæœŸ~æ™‚ã¯ `ASCII$i ï¼‰,
`~ISO-2022-JP~lead@ï¼ˆåˆæœŸ~æ™‚ã¯ `00^X ï¼‰,
`~ISO-2022-JPå‡ºåŠ›@ï¼ˆåˆæœŸ~æ™‚ã¯ ~F ï¼‰
â—
ISO-2022-JPâ€™s decoder has an associated ISO-2022-JP decoder state (initially ASCII), ISO-2022-JP decoder output state (initially ASCII), ISO-2022-JP lead (initially 0x00), and ISO-2022-JP output (initially false).
</p>

<div class="algo">
<p>
`ISO-2022-JP$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %å…¥å‡ºåŠ›~queue, %~byte )
ã«å¯¾ã—ï¼Œ`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ã«å¿œã˜ã¦ï¼š
â—
ISO-2022-JPâ€™s decoderâ€™s handler, given ioQueue and byte, runs these steps, switching on ISO-2022-JP decoder state:
</p>

<dl class="switch">
	<dt>`ASCII@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ï¼›
~RET `ç¶™ç¶š-$i
â—
0x1B
â€¢ Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`0E^X, `0F^X, `1B^X ä»¥å¤–ã®`~ASCII~byte$
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F ï¼›
~RET ~cp Â« %~byte Â»
â—
0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B
â€¢ Set ISO-2022-JP output to false and return a code point whose value is byte.
</li>
			<li>
`~EoQ$
â‡’ï¼ƒ
~RET `å®Œé‚d$i
â—
end-of-queue
â€¢ Return finished.
</li>
			<li>
ãã®ä»–
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F ï¼›
~RET `~error$i
â—
Otherwise
â€¢ Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`Roman@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ï¼›
~RET `ç¶™ç¶š-$i
â—
0x1B
â€¢ Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`5C^X
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F ï¼›
~RET ~cp Â« `00A5^U `Â¥^smb Â»
â—
0x5C
â€¢ Set ISO-2022-JP output to false and return code point U+00A5 (Â¥).
</li>
			<li>
`7E^X
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F ï¼›
~RET ~cp Â« `203E^U `â€¾^smb Â»
â—
0x7E
â€¢ Set ISO-2022-JP output to false and return code point U+203E (â€¾).
</li>
			<li>
`0E^X, `0F^X, `1B^X, `5C^X, `7E^X
ä»¥å¤–ã®`~ASCII~byte$
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F ï¼›
~RET ~cp Â« %~byte Â»
â—
0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E
â€¢ Set ISO-2022-JP output to false and return a code point whose value is byte.
</li>
			<li>
`~EoQ$
â‡’ï¼ƒ
~RET `å®Œé‚d$i
â—
end-of-queue
â€¢ Return finished.
</li>
			<li>
ãã®ä»–
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F ï¼›
~RET `~error$i
â—
Otherwise
â€¢ Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`katakana@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ï¼›
~RET `ç¶™ç¶š-$i
â—
0x1B
â€¢ Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`21^X ã€œ `5F^X
ã€ï¼ katakana; subtraction is done first to avoid upsetting compilers ã€‘
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F ï¼›
~RET ~cp Â« `FF61^X ~MINUS `21^X ~PLUS %~byte Â»
â—
0x21 to 0x5F
â€¢ Set ISO-2022-JP output to false and return a code point whose value is 0xFF61 âˆ’ 0x21 + byte.
</li>
			<li>
`~EoQ$
â‡’ï¼ƒ
~RET `å®Œé‚d$i
â—
end-of-queue
â€¢ Return finished.
</li>
			<li>
ãã®ä»–
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F ï¼›
~RET `~error$i
â—
Otherwise
â€¢ Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`~lead~byte@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ï¼›
~RET `ç¶™ç¶š-$i
â—
0x1B
â€¢ Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`21^X ã€œ `7E^X
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F ï¼›
`~ISO-2022-JP~lead$ ~SET %~byte ï¼›
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~trail~byte$i ï¼›
~RET `ç¶™ç¶š-$i
â—
0x21 to 0x7E
â€¢ Set ISO-2022-JP output to false, ISO-2022-JP lead to byte, ISO-2022-JP decoder state to trail byte, and return continue.
</li>
			<li>
`~EoQ$
â‡’ï¼ƒ
~RET `å®Œé‚d$i
â—
end-of-queue
â€¢ Return finished.
</li>
			<li>
ãã®ä»–
â‡’ï¼ƒ
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F ï¼›
~RET `~error$i
â—
Otherwise
â€¢ Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`~trail~byte@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
ã€ï¼ iso-2022-jp decoder output state is still lead byte ã€‘
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ï¼›
~RET `~error$i
â—
0x1B
â€¢ Set ISO-2022-JP decoder state to escape start and return error.
</li>
			<li>
<p>
`21^X ã€œ `7E^X
ï¼š
â—
0x21 to 0x7E
</p>
				<ol>
					<li>
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~lead~byte$i
â—
Set the ISO-2022-JP decoder state to lead byte.
</li>
					<li>
%~pointer ~LET ( `~ISO-2022-JP~lead$ ~MINUS `21^X ) ~MUL 94 ~PLUS %~byte ~MINUS `21^X
â—
Let pointer be (ISO-2022-JP lead âˆ’ 0x21) Ã— 94 + byte âˆ’ 0x21.
</li>
					<li>
%~cp ~LET
`ç´¢å¼•~jis0208$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
â—
Let codePoint be the index code point for pointer in index jis0208.
</li>
					<li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET `~error$i
â—
If codePoint is null, then return error.
</li>
					<li>
~RET ~cp Â« %~cp Â»
â—
Return a code point whose value is codePoint.
</li>
				</ol>
			</li>
			<li>
`~EoQ$
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~lead~byte$i ï¼›
~RET `~error$i
â—
end-of-queue
â€¢ Set the ISO-2022-JP decoder state to lead byte and return error.
</li>
			<li>
ãã®ä»–
ã€ï¼ iso-2022-jp decoder output state is still lead byte ã€‘
â‡’ï¼ƒ
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~lead~byte$i ï¼›
~RET `~error$i
â—
Otherwise
â€¢ Set ISO-2022-JP decoder state to lead byte and return error.
</li>
		</ol>
	</dd>

	<dt>`~escapeé–‹å§‹@i</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
%~byte ~IN { `24^Xã€ï¼ $ ã€‘, `28^Xã€ï¼ ( ã€‘ }
ï¼½
â‡’ï¼ƒ
`~ISO-2022-JP~lead$ ~SET %~byte ï¼›
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~escape$i ï¼›
~RET `ç¶™ç¶š-$i
â—
If byte is either 0x24 or 0x28, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to escape, and return continue.
</li>
			<li>
~IFï¼»
%~byte ~NEQ `~EoQ$
ï¼½
â‡’
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~byte )
â—
If byte is not end-of-queue, then restore byte to ioQueue.
</li>
			<li>
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F
â—
Set ISO-2022-JP output to false,ï¼¼
</li>
			<li>
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~ISO-2022-JPå¾©å·å™¨~å‡ºåŠ›~çŠ¶æ…‹$
â—
ISO-2022-JP decoder state to ISO-2022-JP decoder output state, andï¼¼
</li>
			<li>
~RET `~error$i
â—
return error.
</li>
		</ol>
	</dd>

	<dt>`~escape@i</dt>
	<dd>
		<ol>
			<li>
%~lead ~LET `~ISO-2022-JP~lead$
â—
Let lead be ISO-2022-JP lead andï¼¼
</li>
			<li>
`~ISO-2022-JP~lead$ ~SET `00^X
â—
set ISO-2022-JP lead to 0x00.
</li>
			<li>
%çŠ¶æ…‹ ~LET
( %~lead, %~byte )
ã«å¿œã˜ã¦
â‡’ï¼ƒ
( `28^X, `42^Xã€ï¼B ã€‘ ) ãªã‚‰ã° `ASCII$i ï¼
( `28^X, `4A^Xã€ï¼J ã€‘ ) ãªã‚‰ã° `Roman$i1 ï¼
( `28^X, `49^Xã€ï¼I ã€‘ ) ãªã‚‰ã° `katakana$i ï¼
( `24^X, `40^Xã€ï¼@ ã€‘ ) ãªã‚‰ã° `~lead~byte$i ï¼
( `24^X, `42^Xã€ï¼B ã€‘ ) ãªã‚‰ã° `~lead~byte$i ï¼
~ELSE_ ~NULL
â—
Let state be null.
â—
If lead is 0x28 and byte is 0x42, set state to ASCII.
â—
If lead is 0x28 and byte is 0x4A, set state to Roman.
â—
If lead is 0x28 and byte is 0x49, set state to katakana.
â—
If lead is 0x24 and byte is either 0x40 or 0x42, set state to lead byte.
</li>
			<li>
<p>
~IFï¼»
%çŠ¶æ…‹ ~NEQ ~NULL
ï¼½ï¼š
â—
If state is non-null:
</p>
				<ol>
					<li>
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET %çŠ¶æ…‹
â—
â†“</li>
					<li>
`~ISO-2022-JPå¾©å·å™¨~å‡ºåŠ›~çŠ¶æ…‹$ ~SET %çŠ¶æ…‹
â—
Set ISO-2022-JP decoder state and ISO-2022-JP decoder output state to state.
</li>
					<li>
%å‡ºåŠ› ~LET `~ISO-2022-JPå‡ºåŠ›$
â—
Let output be the value of ISO-2022-JP output.
</li>
					<li>
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~T
â—
Set ISO-2022-JP output to true.
</li>
					<li>
~RET %å‡ºåŠ› ã«å¿œã˜ã¦
â‡’ï¼ƒ
~F ãªã‚‰ã° `ç¶™ç¶š-$i ï¼
~T ãªã‚‰ã° `~error$i
â—
Return continue, if output is false, and error otherwise.
</li>
				</ol>
			</li>
			<li>
~IFï¼»
%~byte ~EQ `~EoQ$
ï¼½
â‡’
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~lead )
â—
If byte is end-of-queue, then restore lead to ioQueue;ï¼¼
</li>
			<li>
~ELSE
â‡’
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, ~byteåˆ— Â« %~lead, %~byte Â» )
â—
otherwise, restore Â« lead, byte Â» to ioQueue.
</li>
			<li>
`~ISO-2022-JPå‡ºåŠ›$ ~SET ~F
â—
Set ISO-2022-JP output to false,ï¼¼
</li>
			<li>
`~ISO-2022-JPå¾©å·å™¨~çŠ¶æ…‹$ ~SET `~ISO-2022-JPå¾©å·å™¨~å‡ºåŠ›~çŠ¶æ…‹$
â—
ISO-2022-JP decoder state to ISO-2022-JP decoder output state andï¼¼
</li>
			<li>
~RET `~error$i
â—
return error.
</li>
		</ol>
	</dd>
</dl>
</div>

			</section>
			<section id="iso-2022-jp-encoder">
<h4 title="ISO-2022-JP encoder">12.2.2. ~ISO-2022-JPç¬¦å·åŒ–å™¨</h4>

<div class="note">

<p>æ³¨è¨˜ï¼š
`~ISO-2022-JPç¬¦å·åŒ–å™¨$ã¯ã€ï¼»
è¤‡æ•°ã®å‡ºåŠ›ã‚’é€£çµã—ãŸçµæœã‚’å¯¾å¿œã™ã‚‹`å¾©å·å™¨$ã«ã‹ã‘ãŸã¨ãï¼Œ
`~error$i ã«ãªã‚Šå¾—ã‚‹
ï¼½ã‚ˆã†ãªï¼Œå”¯ä¸€ã®`ç¬¦å·åŒ–å™¨$ã§ã‚ã‚‹ã€‚
â—
The ISO-2022-JP encoder is the only encoder for which the concatenation of multiple outputs can result in an error when run through the corresponding decoder.
</p>

<p class="example">
`00A5^U ã‚’ç¬¦å·åŒ–ã—ãŸçµæœã¯
[ `1B^X `28^X `4A^X `5C^X `1B^X `28^X `42^X ]
ã«ãªã‚‹ã€‚
ãã®çµæœã«åŒã˜çµæœã‚’é€£çµã—ã¦ã‹ã‚‰å¾©å·ã—ãŸçµæœã¯ã€
[ `00A5^U `FFFD^U `00A5^U ]
ã«ãªã‚‹ã€‚
â—
Encoding U+00A5 gives 0x1B 0x28 0x4A 0x5C 0x1B 0x28 0x42. Doing that twice, concatenating the results, and then decoding yields U+00A5 U+FFFD U+00A5.
</p>

</div>

<p>
å„ï¼»
`ISO-2022-JP$n ã®`ç¬¦å·åŒ–å™¨$
ï¼½ã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹@
â€” æ¬¡ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚Šå¾—ã‚‹ï¼ˆåˆæœŸ~æ™‚ã¯ `ASCII$i1 ï¼‰
â‡’
`ASCII@i1 ï¼
`Roman@i1 ï¼
`jis0208@i1
â—
ISO-2022-JPâ€™s encoder has an associated ISO-2022-JP encoder state which is ASCII, Roman, or jis0208 (initially ASCII).
</p>

<div class="algo">
<p>
`ISO-2022-JP$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %å…¥å‡ºåŠ›~queue, %~cp )
ã«å¯¾ã—ï¼š
â—
ISO-2022-JPâ€™s encoderâ€™s handler, given ioQueue and codePoint, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~cp ~EQ `~EoQ$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~NEQ `ASCII$i1
ï¼½
â‡’ï¼ƒ
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~SET `ASCII$i1 ï¼›
~RET ~byteåˆ— Â« `1B^X, `28^X, `42^X Â»
â—
If codePoint is end-of-queue and ISO-2022-JP encoder state is not ASCII, then set ISO-2022-JP encoder state to ASCII and return three bytes 0x1B 0x28 0x42.
</li>
			<li>
~RET `å®Œé‚d$i
â—
If codePoint is end-of-queue and ISO-2022-JP encoder state is ASCII, then return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~IN
{ `ASCII$i1, `Roman$i1 }
ï¼½~ANDï¼»
%~cp ~IN { `000E^U, `000F^U, `001B^U }
ï¼½
â‡’
~RET `~error$i( `FFFD^U `ï¿½^smb )
â—
If ISO-2022-JP encoder state is ASCII or Roman, and codePoint is U+000E, U+000F, or U+001B, then return error with U+FFFD (ï¿½).
</p>

<p class="note">æ³¨è¨˜ï¼š
æ”»æ’ƒã‚’é˜²ããŸã‚ã€
ã“ã“ã§ã¯ï¼Œï¼»
%~cp ã§ã¯ãªãï¼Œ `FFFD^U `ï¿½^smb
ï¼½ã‚’è¿”ã™ã€‚
â—
This returns U+FFFD (ï¿½) rather than codePoint to prevent attacks.
</p>
ã€ï¼ https://github.com/whatwg/encoding/issues/15 ã€‘
	</li>
	<li>
~IFï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~EQ `ASCII$i1
ï¼½~ANDï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byte Â« %~cp Â»
â—
If ISO-2022-JP encoder state is ASCII and codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
<p>
~IFï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~EQ `Roman$i1
ï¼½ï¼š
</p>
		<ol>
			<li>
%çµæœ ~LET %~cp ã«å¿œã˜ã¦
â‡’ï¼ƒ
`005C^U `\^smb, `007E^U `~^smb ä»¥å¤–ã®`~ASCII~cp$ãªã‚‰ã° ~byte Â« %~cp Â» ï¼
`00A5^U `Â¥^smb ãªã‚‰ã° ~byte Â« `5C^X Â» ï¼
`203E^U `â€¾^smb ãªã‚‰ã° ~byte Â« `7E^X Â» ï¼
~ELSE_ ~NULL
</li>
			<li>
~IFï¼»
%çµæœ ~NEQ ~NULL
ï¼½
â‡’
~RET %çµæœ
â—
â†‘</li>
		</ol>
â—
If ISO-2022-JP encoder state is Roman and codePoint is an ASCII code point, excluding U+005C (\) and U+007E (~), or is U+00A5 (Â¥) or U+203E (â€¾):
â€¢ If codePoint is an ASCII code point, then return a byte whose value is codePoint.
â€¢ If codePoint is U+00A5 (Â¥), then return byte 0x5C.
â€¢ If codePoint is U+203E (â€¾), then return byte 0x7E.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½~ANDï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~NEQ `ASCII$i1
ï¼½
â‡’ï¼ƒ
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~cp )ï¼›
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~SET `ASCII$i1 ï¼›
~RET ~byteåˆ— Â« `1B^X, `28^X, `42^X Â»
â—
If codePoint is an ASCII code point, and ISO-2022-JP encoder state is not ASCII, then restore codePoint to ioQueue, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
	<li>
~IFï¼»
%~cp ~NIN { `00A5^U `Â¥^smb, `203E^U `â€¾^smb }
ï¼½~ANDï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~NEQ `Roman$i1
ï¼½
â‡’ï¼ƒ
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~cp )ï¼›
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~SET `Roman$i1 ï¼›
~RET ~byteåˆ— Â« `1B^X, `28^X, `4A^X Â»
â—
If codePoint is either U+00A5 (Â¥) or U+203E (â€¾), and ISO-2022-JP encoder state is not Roman, then restore codePoint to ioQueue, set ISO-2022-JP encoder state to Roman, and return three bytes 0x1B 0x28 0x4A.
</li>
	<li>
~IFï¼»
%~cp ~EQ `2212^U `âˆ’^smb
ï¼½
â‡’
%~cp ~SET `FF0D^U `ï¼^smb
â—
If codePoint is U+2212 (âˆ’), then set it to U+FF0D (ï¼).
</li>
	<li>
~IFï¼»
%~cp ~IN { `FF61^U ã€œ `FF9F^U }
ï¼½
â‡’
%~cp ~SET `ç´¢å¼•~ISO-2022-JP~katakana$ã®ä¸­ã§
( %~cp ~MINUS `FF61^X )
ãŒæŒ‡ã™`ç´¢å¼•~cp$
â—
If codePoint is in the range U+FF61 to U+FF9F, inclusive, then set it to the index code point for codePoint âˆ’ 0xFF61 in index ISO-2022-JP katakana.
</li>
	<li>
<p>
%~pointer ~LET `ç´¢å¼•~jis0208$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for codePoint in index jis0208.
</p>

<p class="note">æ³¨è¨˜ï¼š
%~pointer ã¯ã€
~NULL ã§ãªã‘ã‚Œã°ï¼Œ`ç´¢å¼•~jis0208$ã¨~pointeræ¼”ç®—ã®è³‡è³ªã«å› ã‚Š 8836 æœªæº€ã«ãªã‚‹ã€‚
â—
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
<p>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½ï¼š
â—
If pointer is null:
</p>
		<ol>
			<li>
~IFï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~EQ `jis0208$i1
ï¼½
â‡’ï¼ƒ
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~cp )ï¼›
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~SET `ASCII$i1 ï¼›
~RET ~byteåˆ— Â« `1B^X, `28^X, `42^X Â»
â—
If ISO-2022-JP encoder state is jis0208, then restore codePoint to ioQueue, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
			<li>
~RET `~error$i( %~cp )
â—
Return error with codePoint.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~NEQ `jis0208$i1
ï¼½
â‡’ï¼ƒ
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~cp )ï¼›
`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ ~SET `jis0208$i1 ï¼›
~RET ~byteåˆ— Â« `1B^X, `24^X, `42^X Â»
â—
If ISO-2022-JP encoder state is not jis0208, restore codePoint to ioQueue, set ISO-2022-JP encoder state to jis0208, and return three bytes 0x1B 0x24 0x42.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `21^X
â—
Let lead be pointer / 94 + 0x21.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `21^X
â—
Let trail be pointer % 94 + 0x21.
</li>
	<li>
~RET ~byteåˆ— Â« %~lead, %~trail Â»
â—
Return two bytes whose values are lead and trail.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="shift_jis">
<h3 title="Shift_JIS">12.3. ~Shift_JIS</h3>

			<section id="shift_jis-decoder">
<h4 title="Shift_JIS decoder">12.3.1. ~Shift_JISå¾©å·å™¨</h4>

<p>
å„ï¼»
`Shift_JIS$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~Shift_JIS~lead@ï¼ˆåˆæœŸ~æ™‚ã¯ `00^X ï¼‰
â—
Shift_JISâ€™s decoder has an associated Shift_JIS lead (initially 0x00).
</p>

<div class="algo">
<p>
`Shift_JIS$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %å…¥å‡ºåŠ›~queue, %~byte )
ã«å¯¾ã—ï¼š
â—
Shift_JISâ€™s decoderâ€™s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoQ$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
`~Shift_JIS~lead$ ~NEQ `00^X
ï¼½
â‡’ï¼ƒ
`~Shift_JIS~lead$ ~SET `00^X ï¼›
~RET `~error$i
â—
If byte is end-of-queue and Shift_JIS lead is not 0x00, set Shift_JIS lead to 0x00 and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚d$i
â—
If byte is end-of-queue and Shift_JIS lead is 0x00, then return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~Shift_JIS~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If Shift_JIS lead is not 0x00:
</p>
		<ol>
			<li>
%~lead ~LET `~Shift_JIS~lead$
â—
Let lead be Shift_JIS lead.
</li>
			<li>
`~Shift_JIS~lead$ ~SET `00^X
â—
Set Shift_JIS lead to 0x00.
</li>
			<li>
%~pointer ~LET ~NULL
â—
Let pointer be null.
</li>
			<li>
%~offset ~LET ï¼»
%~byte ~IN { `00^X ã€œ `7E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40 if byte is less than 0x7F; otherwise 0x41.
</li>
			<li>
%~lead~offset ~LET ï¼»
%~lead ~IN { `00^X ã€œ `9F^X } ãªã‚‰ã° `81^X ï¼
~ELSE_ `C1^X
ï¼½
â—
Let lead offset be 0x81 if lead is less than 0xA0; otherwise 0xC1.
</li>
			<li>
~IFï¼»
%~byte ~IN { `40^X ã€œ `7E^X, `80^X ã€œ `FC^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS %~lead~offset ) ~MUL 188 ~PLUS %~byte ~MINUS %~offset
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFC, inclusive, then set pointer to (lead âˆ’ lead offset) Ã— 188 + byte âˆ’ offset.
</li>
			<li>
<p>
~IFï¼»
%~pointer ~IN { 8836 ã€œ 10715 }
ï¼½
ã€ï¼ subtraction is done first to avoid upsetting compilers ã€‘
â‡’
~RET ~cp Â« `E000^X ~MINUS 8836 ~PLUS %~pointer Â»
â—
If pointer is in the range 8836 to 10715, inclusive, then return a code point whose value is 0xE000 âˆ’ 8836 + pointer.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ EUDC ã¨ã—ã¦å‘¨çŸ¥ãªï¼Œæ—§æ¥ã® Windows ã«ã‚ˆã‚‹ã‚‚ã®ã¨ç›¸äº’é‹ç”¨å¯èƒ½ã«ã™ã‚‹ã€‚
ã€ï¼ PUA ã€‘
â—
This is interoperable legacy from Windows known as EUDC.
</p>

<p class="trans-note">ã€
EUDC â€” ã„ã‚ã‚†ã‚‹å¤–å­—~ç”¨ã®æ©Ÿèƒ½ã€‚
ã€‘ã€
8836 = 94 ~MUL 94 ã¯~Shift_JISï¼ˆ JIS X 0208 ï¼‰ã®`åŒºç‚¹ç•ªå·ï¼ https://ja.wikipedia.org/wiki/%E5%8C%BA%E7%82%B9%E7%95%AA%E5%8F%B7$ã®ç·æ•°ã€‚
çµæœã®~cpã¯~Unicodeç§ç”¨é ˜åŸŸã«å…¥ã‚‹ã€‚
ã€‘</p>

			</li>
			<li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ `ç´¢å¼•~jis0208$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
ï¼½
â—
Let codePoint be null if pointer is null; otherwise the index code point for pointer in index jis0208.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp Â« %~cp Â»
â—
If codePoint is non-null, then return a code point whose value is codePoint.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~byte )
â—
If byte is an ASCII byte, then restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN { `~ASCII~byte$, `80^X}
ï¼½
â‡’
~RET ~cp Â« %~byte Â»
ã€ï¼ Opera has 0x7E ã€‘
â—
If byte is an ASCII byte or 0x80, then return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `A1^X ã€œ `DF^X }
ï¼½
ã€ï¼ katakana; subtraction is done first to avoid upsetting compilers ã€‘
â‡’
~RET ~cp Â« `FF61^X ~PLUS ( %~byte ~MINUS `A1^X ) Â»
â—
If byte is in the range 0xA1 to 0xDF, inclusive, then return a code point whose value is 0xFF61 âˆ’ 0xA1 + byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `9F^X, `E0^X ã€œ `FC^X }
ï¼½
â‡’ï¼ƒ
`~Shift_JIS~lead$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$i
â—
If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0 to 0xFC, inclusive, then set Shift_JIS lead to byte and return continue.
</li>
	<li>
~RET `~error$i
â—
Return error.
</li>
</ol>
</div>

			</section>
			<section id="shift_jis-encoder">
<h4 title="Shift_JIS encoder">12.3.2. ~Shift_JISç¬¦å·åŒ–å™¨</h4>

<div class="algo">
<p>
`Shift_JIS$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~cp )
ã«å¯¾ã—ï¼š
â—
Shift_JISâ€™s encoderâ€™s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
%çµæœ ~LET %~cp ã«å¿œã˜ã¦
â‡’ï¼ƒ
`~EoQ$ ãªã‚‰ã° `å®Œé‚d$i ï¼
`~ASCII~cp$ãªã‚‰ã° ~byte Â« %~cp Â» ï¼
`0080^U ãªã‚‰ã° ~byte Â« %~cp Â» ï¼
`00A5^U `Â¥^smb ãªã‚‰ã° ~byte Â« `5C^X Â» ï¼
`203E^U `â€¾^smb ãªã‚‰ã° ~byte Â« `7E^X Â» ï¼
`FF61^U ã€œ `FF9F^U ãªã‚‰ã° ~byte Â« ( %~cp ~MINUS `FF61^X ) ~PLUS `A1^X Â» ï¼
~ELSE_ ~NULL
â—
If codePoint is end-of-queue, then return finished.
â—
If codePoint is an ASCII code point or U+0080, then return a byte whose value is codePoint.
â—
If codePoint is U+00A5 (Â¥), then return byte 0x5C.
â—
If codePoint is U+203E (â€¾), then return byte 0x7E.
â—
If codePoint is in the range U+FF61 to U+FF9F, inclusive, then return a byte whose value is codePoint âˆ’ 0xFF61 + 0xA1.
</li>
	<li>
~IFï¼»
%çµæœ ~NEQ ~NULL
ï¼½
â‡’
~RET %çµæœ
â—
â†‘</li>
	<li>
~IFï¼»
%~cp ~EQ `2212^U `âˆ’^smb
ï¼½
â‡’
%~cp ~SET `FF0D^U `ï¼^smb
â—
If codePoint is U+2212 (âˆ’), then set it to U+FF0D (ï¼).
</li>
	<li>
%~pointer ~LET
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~Shift_JIS~pointer$
â—
Let pointer be the index Shift_JIS pointer for codePoint.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET `~error$i( %~cp )
â—
If pointer is null, then return error with codePoint.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 188 )
â—
Let lead be pointer / 188.
</li>
	<li>
%~lead~offset ~LET ï¼»
%~lead ~IN { `00^X ã€œ `1E^X } ãªã‚‰ã° `81^X ï¼
~ELSE_ `C1^Xã€ï¼ 0xA0-0x81 ã€‘
ï¼½
â—
Let lead offset be 0x81 if lead is less than 0x1F; otherwise 0xC1.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 188
â—
Let trail be pointer % 188.
</li>
	<li>
%~offset ~LET ï¼»
%~trail ~IN { `00^X ã€œ `3E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40 if trail is less than 0x3F; otherwise 0x41.
</li>
	<li>
~RET ~byteåˆ— Â« ( %~lead ~PLUS %~lead~offset ), ( %~trail ~PLUS %~offset ) Â»
â—
Return two bytes whose values are lead + lead offset and trail + offset.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-korean-encodings">
<h2 title="Legacy multi-byte Korean encodings">13. æ—§æ¥ã®è¤‡-~byte~Koreanç¬¦å·åŒ–æ³•</h2>

		<section id="euc-kr">
<h3 title="EUC-KR">13.1. ~EUC-KR</h3>

			<section id="euc-kr-decoder">
<h4 title="EUC-KR decoder">13.1.1. ~EUC-KRå¾©å·å™¨</h4>

<p>
å„ï¼»
`EUC-KR$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~EUC-KR~lead@ï¼ˆåˆæœŸ~æ™‚ã¯ `00^X ï¼‰
â—
EUC-KRâ€™s decoder has an associated EUC-KR lead (initially 0x00).
</p>

<div class="algo">
<p>
`EUC-KR$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %å…¥å‡ºåŠ›~queue, %~byte )
ã«å¯¾ã—ï¼š
â—
EUC-KRâ€™s decoderâ€™s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoQ$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
`~EUC-KR~lead$ ~NEQ `00^X
ï¼½
â‡’ï¼ƒ
`~EUC-KR~lead$ ~SET `00^X ï¼›
~RET `~error$i
â—
If byte is end-of-queue and EUC-KR lead is not 0x00, then set EUC-KR lead to 0x00 and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚d$i
â—
If byte is end-of-queue and EUC-KR lead is 0x00, then return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~EUC-KR~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If EUC-KR lead is not 0x00:
</p>
		<ol>
			<li>
%~lead ~LET `~EUC-KR~lead$
â—
Let lead be EUC-KR lead.
</li>
			<li>
`~EUC-KR~lead$ ~SET `00^X
â—
Set EUC-KR lead to 0x00.
</li>
			<li>
%~pointer ~LET ~NULL
â—
Let pointer be null.
</li>
			<li>
~IFï¼»
%~byte ~IN { `41^X ã€œ `FE^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS `41^X )
â—
If byte is in the range 0x41 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 190 + (byte âˆ’ 0x41).
</li>
			<li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ `ç´¢å¼•~EUC-KR$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
ï¼½
â—
Let codePoint be null if pointer is null; otherwise the index code point for pointer in index EUC-KR.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp Â« %~cp Â»
â—
If codePoint is non-null, then return a code point whose value is codePoint.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~byte )
â—
If byte is an ASCII byte, then restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp Â« %~byte Â»
â—
If byte is an ASCII byte, then return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `FE^X }
ï¼½
â‡’ï¼ƒ
`~EUC-KR~lead$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$i
â—
If byte is in the range 0x81 to 0xFE, inclusive, then set EUC-KR lead to byte and return continue.
</li>
	<li>
~RET `~error$i
â—
Return error.
</li>
</ol>
</div>

			</section>
			<section id="euc-kr-encoder">
<h4 title="EUC-KR encoder">13.1.2. ~EUC-KRç¬¦å·åŒ–å™¨</h4>

<div class="algo">
<p>
`EUC-KR$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~cp )
ã«å¯¾ã—ï¼š
â—
EUC-KRâ€™s encoderâ€™s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoQ$
ï¼½
â‡’
~RET `å®Œé‚d$i
â—
If codePoint is end-of-queue, then return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byte Â« %~cp Â»
â—
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
%~pointer ~LET
`ç´¢å¼•~EUC-KR$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for codePoint in index EUC-KR.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET `~error$i( %~cp )
â—
If pointer is null, then return error with codePoint.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
â—
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET ( %~pointer ~MOD 190 ) ~PLUS `41^X
â—
Let trail be pointer % 190 + 0x41.
</li>
	<li>
~RET ~byteåˆ— Â« %~lead, %~trail Â»
â—
Return two bytes whose values are lead and trail.
</li>
</ol>
</div>

			</section>
		</section>

ã€ï¼ removed from the spec 2013-08-23: 13.2 iso-2022-kr id="iso-2022-kr" ã€‘

	</section>
	<section id="legacy-miscellaneous-encodings">
<h2 title="Legacy miscellaneous encodings">14. æ—§æ¥ã®è«¸ã€…ã®ç¬¦å·åŒ–æ³•</h2>

		<section id="replacement">
<h3 title="replacement">14.1. ~replacement</h3>

<p class="note">æ³¨è¨˜ï¼š
`replacement$n `ç¬¦å·åŒ–æ³•$ã¯ã€
~serverã¨~clientã«ãŠã‘ã‚‹ `ç¬¦å·åŒ–æ³•$ã®~supportã®ä¸ä¸€è‡´ã‚’çªãï¼Œã‚ã‚‹ç¨®ã®æ”»æ’ƒã‚’é˜²ããŸã‚ã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
â—
The replacement encoding exists to prevent certain attacks that abuse a mismatch between encodings supported on the server and the client.
</p>

			<section id="replacement-decoder">
<h4 title="replacement decoder">14.1.1. ~replacementå¾©å·å™¨</h4>

<p>
å„ï¼»
`replacement$n ã®`å¾©å·å™¨$
ï¼½ã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~replacement~errorã¯è¿”ã—ãŸã‹@ï¼ˆåˆæœŸ~æ™‚ã¯ ~F ï¼‰
â—
replacementâ€™s decoder has an associated replacement error returned (initially false).
</p>

<div class="algo">
<p>
`replacement$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~byte )
ã«å¯¾ã—ï¼š
â—
replacementâ€™s decoderâ€™s handler, given unused and byte, runs these steps:
</p>
<ol>
	<li>
~IFï¼»
%~byte ~EQ `~EoQ$
ï¼½
â‡’
~RET `å®Œé‚d$i
â—
If byte is end-of-queue, then return finished.
</li>
	<li>
~IFï¼»
`~replacement~errorã¯è¿”ã—ãŸã‹$ ~EQ ~F
ï¼½
â‡’ï¼ƒ
`~replacement~errorã¯è¿”ã—ãŸã‹$ ~SET ~T ï¼›
~RET `~error$i
â—
If replacement error returned is false, then set replacement error returned to true and return error.
</li>
	<li>
~RET `å®Œé‚d$i
â—
Return finished.
</li>
</ol>
</div>

<p class="trans-note">ã€
`replacement$n ã«ã¯ã€
`ç¬¦å·åŒ–å™¨$ã¯ç„¡ã„ã€‚
ã€‘</p>

			</section>
		</section>
		<section id="common-infrastructure-for-utf-16be-and-utf-16le">
<h3 title="Common infrastructure for UTF-16BE/LE">14.2. `UTF-16BE/LE$n ã«å…±é€šãªåŸºç›¤</h3>

<p>
`UTF-16BE/LE@n
ã¯ã€ï¼»
`UTF-16BE$n ï¼ `UTF-16LE$n
ï¼½ã®ç·ç§°ã§ã‚ã‚‹ã€‚
â—
UTF-16BE/LE is UTF-16BE or UTF-16LE.
</p>

			<section id="shared-utf-16-decoder">
<h4 title="shared UTF-16 decoder">14.2.1. å…±ç”¨~UTF-16å¾©å·å™¨</h4>

<p class="note">æ³¨è¨˜ï¼š
~BOMã¯~labelã‚ˆã‚Šå„ªå…ˆã•ã‚Œã‚‹ã€‚
ãã‚Œã¯ï¼Œé…å‚™-æ¸ˆã¿ãªå†…å®¹ã«ãŠã„ã¦ã€
ã©ã®~labelã‚ˆã‚Šã‚‚æ­£ç¢ºaã§ã‚ã‚‹ã“ã¨ãŒè¦‹å‡ºã•ã‚Œã¦ã„ã‚‹ã®ã§ã€‚
ã—ãŸãŒã£ã¦ ãã‚Œã¯ã€
`å…±ç”¨~UTF-16å¾©å·å™¨$ã®ä¸€éƒ¨ã§ã¯ãªãï¼Œ`~Unicodeã«å¾©å·ã™ã‚‹$ ~algoã®ä¸€éƒ¨ã‚’æˆã™ã€‚
â—
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the shared UTF-16 decoder algorithm but rather the decode algorithm.
</p>

<p>
å„ï¼»
`å…±ç”¨~UTF-16å¾©å·å™¨$
ï¼½ã«ã¯ã€
æ¬¡ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’ï¼ƒ
`~UTF-16~lead~byte@ï¼ˆåˆæœŸ~æ™‚ã¯ ~NULL ï¼‰,
`~UTF-16é ­éƒ¨~surrogate@ï¼ˆåˆæœŸ~æ™‚ã¯ ~NULL ï¼‰,
`~UTF-16BEå¾©å·å™¨~ç”¨ã‹@ï¼ˆåˆæœŸ~æ™‚ã¯ ~F ï¼‰
â—
shared UTF-16 decoder has an associated UTF-16 lead byte and UTF-16 leading surrogate (both initially null), and is UTF-16BE decoder (initially false).
</p>

<div class="algo">
<p>
`å…±ç”¨~UTF-16å¾©å·å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %å…¥å‡ºåŠ›~queue, %~byte )
ã«å¯¾ã—ï¼š
â—
shared UTF-16 decoderâ€™s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoQ$
ï¼½ï¼š
â—
â†“</p>
		<ol>
			<li>
~IFï¼»
`~UTF-16~lead~byte$ ~NEQ ~NULL
ï¼½~ORï¼»
`~UTF-16é ­éƒ¨~surrogate$ ~NEQ ~NULL
ï¼½
â‡’ï¼ƒ
`~UTF-16~lead~byte$ ~SET ~NULLï¼›
`~UTF-16é ­éƒ¨~surrogate$ ~SET ~NULLï¼›
~RET `~error$i
â—
If byte is end-of-queue and either UTF-16 lead byte or UTF-16 leading surrogate is non-null, set UTF-16 lead byte and UTF-16 leading surrogate to null, and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚d$i
â—
If byte is end-of-queue and UTF-16 lead byte and UTF-16 leading surrogate are null, then return finished.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
`~UTF-16~lead~byte$ ~EQ ~NULL
ï¼½
â‡’ï¼ƒ
`~UTF-16~lead~byte$ ~SET %~byte ï¼›
~RET `ç¶™ç¶š-$i
â—
If UTF-16 lead byte is null, then set UTF-16 lead byte to byte and return continue.
</li>
	<li>
%~cu ~LET `~UTF-16BEå¾©å·å™¨~ç”¨ã‹$ã«å¿œã˜ã¦
â‡’ï¼ƒ
~T ãªã‚‰ã° ( ( `~UTF-16~lead~byte$ ~Lshift 8 ) ~PLUS %~byte ) ï¼
~F ãªã‚‰ã° ( ( %~byte ~Lshift 8 ) ~PLUS `~UTF-16~lead~byte$ )
â—
Let codeUnit be the result of:
â€¢ is UTF-16BE decoder is true
â€¢â€¢ (UTF-16 lead byte &lt;&lt; 8) + byte.
â€¢ is UTF-16BE decoder is false
â€¢â€¢ (byte &lt;&lt; 8) + UTF-16 lead byte.
</li>
	<li>
`~UTF-16~lead~byte$ ~SET ~NULL
â—
Then set UTF-16 lead byte to null.
</li>
	<li>
<p>
~IFï¼»
`~UTF-16é ­éƒ¨~surrogate$ ~NEQ ~NULL
ï¼½ï¼š
â—
If UTF-16 leading surrogate is non-null:
</p>
		<ol>
			<li>
%é ­éƒ¨~surrogate ~LET `~UTF-16é ­éƒ¨~surrogate$
â—
Let leadingSurrogate be UTF-16 leading surrogate.
</li>
			<li>
`~UTF-16é ­éƒ¨~surrogate$ ~SET ~NULL
â—
Set UTF-16 leading surrogate to null.
</li>
			<li>
~IFï¼»
%~cu ã¯`å°¾éƒ¨~surrogate$ã§ã‚ã‚‹
ï¼½
â‡’
~RET `~surrogateå¯¾ã‹ã‚‰~scalarå€¤ã‚’å¾—ã™ã‚‹$( %é ­éƒ¨~surrogate, %~cu )
â—
If codeUnit is a trailing surrogate, then return a scalar value from surrogates given leadingSurrogate and codeUnit.
</li>
			<li>
%byte1 ~LET %~cu ~Rshift 8
â—
Let byte1 be codeUnit &gt;&gt; 8.
</li>
			<li>
%byte2 ~LET %~cu ~bAND `00FF^X
â—
Let byte2 be codeUnit &amp; 0x00FF.
</li>
			<li>
%~byteåˆ— ~LET `~UTF-16BEå¾©å·å™¨~ç”¨ã‹$ã«å¿œã˜ã¦
â‡’ï¼ƒ
~T ãªã‚‰ã° ~byteåˆ— Â« %byte1, %byte2 Â» ï¼
~F ãªã‚‰ã° ~byteåˆ— Â« %byte2, %byte1 Â»
â—
Let bytes be a list of two bytes whose values are byte1 and byte2, if is UTF-16BE decoder is true; otherwise byte2 and byte1.
</li>
			<li>
`å…¥å‡ºåŠ›~queueã«æ ¼ç´ã—ç›´ã™$( %å…¥å‡ºåŠ›~queue, %~byteåˆ— )
â—
Restore bytes to ioQueue and return error.
</li>
			<li>
~RET `~error$i
â—
â†‘</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~cu ã¯`é ­éƒ¨~surrogate$ã§ã‚ã‚‹
ï¼½
â‡’ï¼ƒ
`~UTF-16é ­éƒ¨~surrogate$ ~SET %~cu ï¼›
~RET `ç¶™ç¶š-$i
â—
If codeUnit is a leading surrogate, then set UTF-16 leading surrogate to codeUnit and return continue.
</li>
	<li>
~IFï¼»
%~cu ã¯`å°¾éƒ¨~surrogate$ã§ã‚ã‚‹
ï¼½
â‡’
~RET `~error$i
â—
If codeUnit is a trailing surrogate, then return error.
</li>
	<li>
~RET ~cp Â« %~cu Â»
â—
Return code point codeUnit.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="utf-16be">
<h3 title="UTF-16BE">14.3. ~UTF-16BE</h3>

			<section id="utf-16be-decoder">
<h4 title="UTF-16BE decoder">14.3.1. ~UTF-16BEå¾©å·å™¨</h4>

<p>
`UTF-16BE$n ã®`å¾©å·å™¨$ã¯ã€ï¼»
`~UTF-16BEå¾©å·å™¨~ç”¨ã‹$ ~SET ~T
ï¼½ã«ã•ã‚ŒãŸ`å…±ç”¨~UTF-16å¾©å·å™¨$ã§ã‚ã‚‹ã€‚
â—
UTF-16BEâ€™s decoder is shared UTF-16 decoder with its is UTF-16BE decoder set to true.
</p>

			</section>
		</section>
		<section id="utf-16le">
<h3 title="UTF-16LE">14.4. ~UTF-16LE</h3>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™-æ¸ˆã¿ãªå†…å®¹ã«~~å¯¾å‡¦ã™ã‚‹ãŸã‚ã€
`utf-16^lb ã¯ `UTF-16LE$n ç”¨ã®`~label$ã«ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
"utf-16" is a label for UTF-16LE to deal with deployed content.
</p>

			<section id="utf-16le-decoder">
<h4 title="UTF-16LE decoder">14.4.1. ~UTF-16LEå¾©å·å™¨</h4>

<p>
`UTF-16BE$n ã®`å¾©å·å™¨$ã¯ã€
`å…±ç”¨~UTF-16å¾©å·å™¨$ã§ã‚ã‚‹ã€‚
â—
UTF-16LEâ€™s decoder is shared UTF-16 decoder.
</p>

			</section>
		</section>
		<section id="x-user-defined">
<h3 title="x-user-defined">14.5. ~x-user-defined</h3>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯å½¢ä¸Šã§ã¯`å˜-~byteç¬¦å·åŒ–æ³•$ã§ã‚ã‚‹ãŒã€
~algoçš„ã«å®Ÿè£…ã§ãã‚‹ã®ã§ï¼Œåˆ¥ã€…ã«å®šç¾©ã•ã‚Œã‚‹ã€‚
â—
While technically this is a single-byte encoding, it is defined separately as it can be implemented algorithmically.
</p>

			<section id="x-user-defined-decoder">
<h4 title="x-user-defined decoder">14.5.1. ~x-user-definedå¾©å·å™¨</h4>

<div class="algo">
<p>
`x-user-defined$n ã®`å¾©å·å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~byte )
ã«å¯¾ã—ï¼š
â—
x-user-definedâ€™s decoderâ€™s handler, given unused and byte, runs these steps:
</p>
<ol>
	<li>
~RET %~byte ã«å¿œã˜ã¦
â‡’ï¼ƒ
`~EoQ$ãªã‚‰ã° `å®Œé‚d$i ï¼
`~ASCII~byte$ã§ã‚ã‚‹ãªã‚‰ã° ~cp Â« %~byte Â» ï¼
~ELSE_ ~cp Â« `F780^X ~PLUS %~byte ~MINUS `80^X Â»
â—
If byte is end-of-queue, then return finished.
â—
If byte is an ASCII byte, then return a code point whose value is byte.
â—
Return a code point whose value is 0xF780 + byte âˆ’ 0x80.
</li>
</ol>
</div>

			</section>
			<section id="x-user-defined-encoder">
<h4 title="x-user-defined encoder">14.5.2. ~x-user-definedç¬¦å·åŒ–å™¨</h4>

<div class="algo">
<p>
`x-user-defined$n ã®`ç¬¦å·åŒ–å™¨$ã®`~handler$ã¯ã€
æ‰€ä¸ã®
( %åˆ©ç”¨ã•ã‚Œãªã„~queue, %~cp )
ã«å¯¾ã—ï¼š
â—
x-user-definedâ€™s encoderâ€™s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~RET %~cp ã«å¿œã˜ã¦
â‡’ï¼ƒ
`~EoQ$ãªã‚‰ã° `å®Œé‚d$i ï¼
`~ASCII~cp$ãªã‚‰ã° ~byte Â« %~cp Â» ï¼
`F780^U ã€œ `F7FF^U ãªã‚‰ã° ~byte Â« %~cp ~MINUS `F780^X ~PLUS `80^X Â» ï¼
~ELSE_ `~error$i( %~cp )
â—
If codePoint is end-of-queue, then return finished.
â—
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
â—
If codePoint is in the range U+F780 to U+F7FF, inclusive, then return a byte whose value is codePoint âˆ’ 0xF780 + 0x80.
â—
Return error with codePoint.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="browser-ui">
<h2 title="Browser UI">15. ~browser~UI</h2>

<p>
~browserã«ã¯ã€
è³‡æºã®ç¬¦å·åŒ–æ³•ã«å¯¾ã™ã‚‹ä¸Šæ›¸ãã‚’å¯èƒ½åŒ–ã•ã›ãªã„ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšï¼Œãã®ç¨®ã®ç‰¹èƒ½ãŒåœ¨ã‚‹å ´åˆã€
å‰è¿°ã—ãŸ`~securityã®èª²é¡Œï¼ #security-background$ã‹ã‚‰ï¼Œ
~browserã¯ `UTF-16BE/LE$n ã‚’~optionã¨ã—ã¦æä¾›ã™ã‚‹ãƒ™ã‚­ã§ãªã„ã€‚
~browserã¯ã€
è³‡æºãŒ `UTF-16BE/LE$n ã‚’åˆ©ç”¨ã—ã¦å¾©å·ã•ã‚ŒãŸå ´åˆã§ã‚‚ï¼Œ
ã“ã®ç‰¹èƒ½ã‚’ä¸èƒ½åŒ–ã™ã‚‹ãƒ™ã‚­ã§ã‚ã‚‹ã€‚
â—
Browsers are encouraged to not enable overriding the encoding of a resource. If such a feature is nonetheless present, browsers should not offer UTF-16BE/LE as an option, due to the aforementioned security issues. Browsers should also disable this feature if the resource was decoded using UTF-16BE/LE.
</p>

	</section>
	<section id="implementation-considerations">
<h2 title="Implementation considerations">å®Ÿè£…ã®è€ƒæ…®ç‚¹</h2>

<p>
ã“ã®æ¨™æº–ã«ãŠã‘ã‚‹`ç¬¦å·åŒ–æ³•$ç”¨ã®`å¾©å·å™¨$ã¯ã€
`æ ¼ç´ã—ç›´ã™æ¼”ç®—$ã‚’å‚™ãˆã‚‹`å…¥å‡ºåŠ›~queue$ã‚’~supportã™ã‚‹ä»£ã‚ã‚Šã«ï¼Œ
æ¬¡ã«ã‚ˆã‚Šå®Ÿè£…ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ï¼š
â—
Instead of supporting I/O queues with arbitrary restore, the decoders for encodings in this standard could be implemented with:
</p>
<ol>
	<li>
èª­å–ã£ãŸç¾åœ¨ã®~byteã‚’å…ƒã«æˆ»ã™èƒ½
â—
The ability to unread the current byte.
</li>
	<li>
`ISO-2022-JP$n ç”¨ã®å˜-~byteï¼ˆ `24^X ï¼ `28^X ï¼‰~buffer
â—
â†“</li>
	<li>
<p>
`gb18030$n ç”¨ã®å˜-~byteï¼ˆ `~ASCII~byte$ ï¼‰~buffer
â—
A single-byte buffer for gb18030 (an ASCII byte) and ISO-2022-JP (0x24 or 0x28).
</p>

<p class="example" id="example-gb18030-implementation-strategy">
`gb18030$n ã«å¯¾ã—ã¦ã¯ã€ï¼»
`~gb3$ ~NEQ `00^X
ï¼½ã®é–“ã«~~ä¸æ­£ãª~byteã«å‡ºãã‚ã—ãŸã¨ãã¯ã€
`~gb2$ã¯ï¼Œæ¬¡å›ã«è¿”ã™ã“ã¨ã«ãªã‚‹å˜-~byte~bufferã®ä¸­ã«ç§»å‹•ã§ãã€
`~gb3$ãŒ
â€” å˜-~byte~bufferã‚’è¿”ã—ã¦ç©ºã«ã—ãŸå¾Œï¼Œ `00^X ã§ãªã„ã“ã¨ã‚’æ¤œæŸ»ã—ãŸãªã‚‰ â€”
æ–°ãŸãª`~gb1$ã«ãªã‚‹ã€‚
ã“ã‚Œã¯ã€
`gb18030$n ã«ãŠã‘ã‚‹ 1 å€‹ç›®ã¨ 3 å€‹ç›®ã®~byteç¯„å›²ãŒä¸€è‡´ã™ã‚‹ã®ã§å¯èƒ½ã«ãªã‚‹ã€‚
â—
For gb18030 when hitting a bogus byte while gb18030 third is not 0x00, gb18030 second could be moved into the single-byte buffer to be returned next, and gb18030 third would be the new gb18030 first, checked for not being 0x00 after the single-byte buffer was returned and emptied. This is possible as the range for the first and third byte in gb18030 is identical.
</p>
	</li>
</ol>

<p>
`~ISO-2022-JPç¬¦å·åŒ–å™¨$ã«ã¯ï¼Œè¿½åŠ çš„ãªçŠ¶æ…‹ã¨ã—ã¦`~ISO-2022-JPç¬¦å·åŒ–å™¨~çŠ¶æ…‹$ãŒå¿…è¦ã«ãªã‚‹ãŒã€
ãã‚Œä»¥å¤–ã§ã¯ã€
ã“ã®æ¨™æº–ã«ãŠã‘ã‚‹ã©ã®`ç¬¦å·åŒ–æ³•$ç”¨ã«ã‚‚ï¼Œãã®`ç¬¦å·åŒ–å™¨$ã«è¿½åŠ çš„ãªï¼»
çŠ¶æ…‹ï¼~buffer
ï¼½ã¯è¦æ±‚ã•ã‚Œãªã„ã€‚
â—
The ISO-2022-JP encoder needs ISO-2022-JP encoder state as additional state, but other than that, none of the encoders for encodings in this standard require additional state or buffers.
</p>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">è¬è¾</h2>

<p>
å¹´æœˆã«æ¸¡ã‚Šã€
ç¬¦å·åŒ–æ³•ã‚’ç›¸äº’é‹ç”¨å¯èƒ½ãªã‚‚ã®ã«ã™ã‚‹ãŸã‚ã«ï¼ŒãŸãã•ã‚“ã®æ–¹ã€…ãŒåŠ©åŠ›ã•ã‚Œã€
ã“ã®æ¨™æº–ã®ç›®æ¨™ã¸è¿‘ä»˜ã‘ã¦ããŸã€‚
åŒæ§˜ã«å¤šãã®æ–¹ã€…ã®åŠ©åŠ›ãŒï¼Œã“ã®æ¨™æº–ã‚’~~ç¾åœ¨ã®å§¿ã«ä»•ç«‹ã¦ä¸Šã’ã¦ããŸã€‚
ç‰¹ã«ï¼Œæ¬¡ã®æ–¹ã€…ã«æ„Ÿè¬ã™ã‚‹ï¼š
â—
There have been a lot of people that have helped make encodings more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</p>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">çŸ¥çš„è²¡ç”£æ¨©</h2>

`_ipr1@

	</section>
</main>

<div hidden>
<div lang="en" id="_acks1">
<p>
With that, many thanks to

Adam Rice,
Alan Chaney,
Alexander Shtuchkin,
Allen Wirfs-Brock,
Andreu Botella,
Aneesh Agrawal,
Arkadiusz Michalski,
Asmus Freytag,
Ben Noordhuis,
Bnaya Peretz,
Boris Zbarsky,
Bruno Haible,
Cameron McCormack,
Charles McCathieNeville,
Christopher Foo,
CodifierNL,
David Carlisle,
Domenic Denicola,
Dominique HazaÃ«l-Massieux,
Doug Ewell,
Erik van der Poel,
<span lang="zh">è­šæ°¸é‹’</span> (Frank Yung-Fong Tang),
Glenn Maynard,
Gordon P. Hemsley,
Henri Sivonen,
Ian Hickson,
J. King,
James Graham,
Jeffrey Yasskin,
John Tamplin,
Joshua Bell,
<span lang="ja">æ‘äº•ç´”</span> (Jun Murai),
<span lang="ko">ì‹ ì •ì‹</span> (Jungshik Shin),
Jxck,
<span lang="ko">ê°• ì„±í›ˆ</span> (Kang Seonghoon),
<span lang="ja">å·å¹¡å¤ªä¸€</span> (Kawabata Taichi),
Ken Lunde,
Ken Whistler,
Kenneth Russell,
<span lang="ja">ç”°æ‘å¥äºº</span> (Kent Tamura),
Leif Halvard Silli,
Luke Wagner,
Maciej Hirsz,
Makoto Kato,
Mark Callow,
Mark Crispin,
Mark Davis,
Martin DÃ¼rst,
Masatoshi Kimura,
Mattias Buelens,
Ms2ger,
Nigel Megitt,
Nigel Tao,
Norbert Lindenberg,
Ã˜istein E. Andersen,
Peter Krefting,
Philip JÃ¤genstedt,
Philip Taylor,
Richard Ishida,
Robbert Broersma,
Robert Mustacchi,
Ryan Dahl,
Sam Sneddon,
Shawn Steele,
Simon Montagu,
Simon Pieters,
Simon Sapin,
Stephen Checkoway,
<span lang="ja">å¯ºç”°å¥</span> (Takeshi Terada),
Vyacheslav Matva,
Wolf Lammen, and
<span lang="ja">æˆç€¬ã‚†ã„</span> (Yui Naruse)

for being awesome.
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.apple.com/">Apple</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
The <a href="#api">API</a> chapter was initially written by Joshua Bell
(<a href="https://www.google.com/">Google</a>).
</p>
</div>

<div lang="en" id="_ipr1">
<p>
Copyright Â© WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://encoding.spec.whatwg.org/review-drafts/2024-12/">Living Standard Review Draft</a>.
</p>
</div>

</div>
