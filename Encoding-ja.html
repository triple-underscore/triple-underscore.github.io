<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Encoding Standard — 符号化法 標準（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
#encoding-labels td + td {
	white-space: pre;
	white-space: pre-line;
}

.coder {
	font-family: sans-serif0, sans-serif;
}

.label {
	color: #666;
}

b.ename {
	font-weight: normal;
	font-family: sans-serif0, sans-serif;
	color: black;
}

#_big5-lead > tr > td:nth-child(2) {
	white-space: nowrap;
}

</style>


<style>
/* based on the style at
https://encoding.spec.whatwg.org/visualization-colors.css
(2017-01-22)
*/

._vis-visualizationlegend > tr > :first-child > div {
	box-sizing: border-box;
	width: 2em;
	height: 2em;
}

._vis-unmapped {
  background-color: #920000;
  color: white;
}

._vis-astral {
  background-color: #6db6fe;
  color: black;
}

._vis-mid {
  background-color: #ffff6d;
  color: black;
}

._vis-upper, ._vis-byte {
  background-color: #d4d5db;
  color: black;
}

._vis-pua {
  background-color: #db6d00;
  color: black;
}

._vis-mid._vis-contiguous {
  background-color: #009292;
  color: black;
}

._vis-upper._vis-contiguous {
  background-color: #24fe23;
  color: black;
}

._vis-pua._vis-contiguous {
  background-color: #924900;
  color: white;
}

._vis-astral._vis-contiguous {
  background-color: #480091;
  color: white;
}

._vis-duplicate {
  border-style: solid ;
  border-color: #920000;
  color: black;
}

._vis-compatibility {
  border-style: dashed;
  border-color: black;
}

._vis-duplicate._vis-compatibility {
  border-style: dashed;
  border-color: #920000;
}

._vis-ext {
  border-style: dotted;
  border-color: black;
}

._vis-ext._vis-compatibility {
  border-style: dotted;
  border-color: #920000;
}

._vis-surrogate {
  background-color: #b4b4b6;
}



@supports (display: grid) and (display: contents) {

#_index_list {
	min-width: 30em;
	max-width: 70em;
}

#_index_list tr {
	grid-template-areas:
		"名前 索引 視覚化 被覆域"
		"名前 備考 備考 備考"
	;
	grid-template-columns: 10em 1fr 1fr 1fr;
}

#_index_list tr > *:nth-child(1) {
	grid-area: 名前;
	border-left-width: 0;
}

#_index_list tr > *:nth-child(2) {
	grid-area: 索引;
}

#_index_list tr > *:nth-child(3) {
	grid-area: 視覚化;
}

#_index_list tr > *:nth-child(4) {
	grid-area: 被覆域;
}

#_index_list tr > *:nth-child(5) {
	grid-area: 備考;
}

}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'lb':
	text = `"<code class="label">${text}</code>"`;
	break;
case 'mc':
	text = "constructor";
	href = `#dom-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'n': // encoding name
	href = `#${key.toLowerCase()}`;
	break;
case 'tA': // 型注釈
	text = `&lt;${key}&gt;`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'X':
	text = `0x${key}`;
	break;
case 'idx':
	return idx_html(key);
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}

	function idx_html(key){
		const k = key.toLowerCase();
		const url = 'https://encoding.spec.whatwg.org/';

		let txt = `
<a href="${url}index-${k}.txt">index-${k}.txt</a>`;
		let vis = `
<td><a href="${url}${k}.html">索引 <b class="ename">${key}</b> 視覚-化</a>`;
		let cover = `
<td><a href="${url}${k}-bmp.html">索引 <b class="ename">${key}</b> BMP 被覆域</a>`;

		switch(key){
			case 'jis0208':
				vis += `,
<a href="${url}shift_jis.html">索引~Shift_JIS視覚-化</a>`;
			break;
			case 'gb18030-ranges':
			case 'iso-2022-jp-katakana':
				vis = cover = '<td>';
			break;
//			case 'ISO-8859-8-I'
		}

		return txt + vis + cover;
	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:Encoding
spec_date:2023-06-19
trans_update:2023-06-16
source_checked:210621
spec_status:LS
original_url:https://encoding.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
copyright:,whatwg
trans_1st_pub:2012-10-22


●●class_map
E:error
n:ename
U:code-point
cn:cp-name
X:hex-value

●●tag_map
I:code
m:code
mb:code
E:code
n:b
U:span
cn:span
X:span
i:i
i1:i
V:var
tA:sub
c:code
em:em
cite:cite

●●mdn_urls
textdecoder:API/TextDecoder
textencoder:API/TextEncoder
	textdecoderoptions:API/TextDecoderOptions
	textdecodeoptions:API/TextDecodeOptions
	dictdef-textencoderencodeintoresult:API/TextEncoderEncodeIntoResult
	textencodeoptions:API/TextEncodeOptions
	textdecodercommon:API/TextDecoderCommon
	textdecoderstream:API/TextDecoderStream
	textencodercommon:API/TextEncoderCommon
	textencoderstream:API/TextEncoderStream


●●original_id_map
	旧 id
	textdecodercommon-decoder:textdecoder-decoder
	textdecodercommon-decoder:textdecoderstream-decoder
	textdecodercommon-i-o-queue:textdecodercommon-stream
	textdecodercommon-i-o-queue:textdecoder-stream

●●link_map


	●IDL
Exposed:~WEBIDLjs#Exposed
AllowShared:~WEBIDLjs#AllowShared

E.RangeError:~WEBIDL#exceptiondef-rangeerror
E.TypeError:~WEBIDL#exceptiondef-typeerror

I.TextDecoderOptions:#textdecoderoptions
I.TextDecodeOptions:#textdecodeoptions
I.TextDecoder:#textdecoder
I.TextEncoderEncodeIntoResult:#dictdef-textencoderencodeintoresult
I.TextEncodeOptions:#textencodeoptions
I.TextEncoder:#textencoder
I.AllowSharedBufferSource:~WEBIDL#AllowSharedBufferSource
I.BufferSource:~WEBIDL#BufferSource
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array
I.Uint32Array:~WEBIDL#idl-Uint32Array

I.TextDecoderCommon:#textdecodercommon
I.TextDecoderStream:#textdecoderstream
I.TextEncoderCommon:#textencodercommon
I.TextEncoderStream:#textencoderstream

I.GenericTransformStream:~STREAMS#generictransformstream
I.ReadableStream:~STREAMS#readablestream
I.WritableStream:~STREAMS#writablestream
I.TransformStream:~STREAMS#transformstream

Uint8Array:~WEBIDL#idl-Uint8Array
USVString:~WEBIDL#idl-USVString
DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean
unsigned long long:~WEBIDL#idl-unsigned-long-long

m.new TextDecoder:#dom-textdecoder
m.encoding:#dom-textdecoder-encoding
m.fatal:#dom-textdecoder-fatal
m.ignoreBOM:#dom-textdecoder-ignorebom

m.new TextEncoder:#dom-textencoder
m.decode:#dom-textdecoder-decode
m.~encoding0:#dom-textencoder-encoding
m.encode:#dom-textencoder-encode
m.encodeInto:#dom-textencoder-encodeinto

m.read:#dom-textencoderencodeintoresult-read
m.written:#dom-textencoderencodeintoresult-written

m.new TextEncoderStream:#dom-textencoderstream
m.new TextDecoderStream:#dom-textdecoderstream

m.readable:~STREAMS#dom-generictransformstream-readable
m.writable:~STREAMS#dom-generictransformstream-writable

m.pipeThrough:~STREAMS#rs-pipe-through

mb.fatal:#dom-textdecoderoptions-fatal
mb.ignoreBOM:#dom-textdecoderoptions-ignorebom

mb.stream:#dom-textdecodeoptions-stream

	%input:#dom-textdecoder-decode-input-options-input
	%label:#dom-textdecoder-textdecoder-label-options-label
	%label:#dom-textdecoderstream-textdecoderstream-label-options-label
	%options:#dom-textdecoder-decode-input-options-options
	%options:#dom-textdecoder-textdecoder-label-options-options
	%options:#dom-textdecoderstream-textdecoderstream-label-options-options

	●用語

符号化法:#encoding
名前:#name
~label:#label
~label:#_labels
復号器:#decoder
~Unicodeに復号する:#decode
~UTF-8復号する:#utf-8-decode
~BOMはそのままに~UTF-8復号する:#utf-8-decode-without-bom
~BOMも失敗-もそのままに~UTF-8復号する:#utf-8-decode-without-bom-or-fail
~BOMを~sniffする:#bom-sniff
~UTF-8符号化する:#utf-8-encode
符号化法を利用して符号化する:#encode
符号化器を取得する:#get-an-encoder
符号化するか失敗する:#encode-or-fail

符号化器:#encoder
~handler:#handler
~error~mode:#error-mode
i.~error:#error
i.完遂d:#finished
i.継続-:#continue
~EoQ:#end-of-stream
~labelから符号化法を取得する:#concept-encoding-get
符号化法から出力~符号化法を取得する:#get-an-output-encoding
入出力~queue:#concept-stream
入出力~queueから~itemを読取る:#concept-stream-read
入出力~queueを覗見る:#i-o-queue-peek
入出力~queueに~pushする:#concept-stream-push
ioQ.~push:#concept-stream-push
入出力~queueに前付加する:#concept-stream-prepend
変換する:#from-i-o-queue-convert
入出力~queueに変換する:#to-i-o-queue-convert

~queueを処理する:#concept-encoding-run
	走らす:#concept-encoding-run
~itemを処理する:#concept-encoding-process

	●
索引:#index
索引~cp:#index-code-point
索引~pointer:#index-pointer
索引~Big5~pointer:#index-big5-pointer
索引~Big5:#index-big5
索引~EUC-KR:#index-euc-kr
索引~jis0208:#index-jis0208
索引~jis0212:#index-jis0212
索引~Shift_JIS~pointer:#index-shift_jis-pointer
索引~ISO-2022-JP~katakana:#index-iso-2022-jp-katakana
索引~gb18030範囲集:#index-gb18030-ranges
索引~gb18030範囲集~cp:#index-gb18030-ranges-code-point
索引~gb18030範囲集~pointer:#index-gb18030-ranges-pointer

索引~gb18030:#index-gb18030

~UTF-8~cp:#utf-8-code-point
~UTF-8出現~byte数:#utf-8-bytes-seen
~UTF-8要~byte数:#utf-8-bytes-needed
~UTF-8下限:#utf-8-lower-boundary
~UTF-8上限:#utf-8-upper-boundary

単-~byte符号化法:#single-byte-encoding
単-~byte索引:#index-single-byte


	●名前
	n.UTF-8:#utf-8
	n.IBM866:#ibm866
	n.ISO-8859-2:#iso-8859-2
	n.ISO-8859-3:#iso-8859-3
	n.ISO-8859-4:#iso-8859-4
	n.ISO-8859-5:#iso-8859-5
	n.ISO-8859-6:#iso-8859-6
	n.ISO-8859-7:#iso-8859-7
	n.ISO-8859-8:#iso-8859-8
	n.ISO-8859-8-I:#iso-8859-8-i
	n.ISO-8859-10:#iso-8859-10
	n.ISO-8859-13:#iso-8859-13
	n.ISO-8859-14:#iso-8859-14
	n.ISO-8859-15:#iso-8859-15
	n.ISO-8859-16:#iso-8859-16
	n.KOI8-R:#koi8-r
	n.KOI8-U:#koi8-u
	n.macintosh:#macintosh
	n.windows-874:#windows-874
	n.windows-1250:#windows-1250
	n.windows-1251:#windows-1251
	n.windows-1252:#windows-1252
	n.windows-1253:#windows-1253
	n.windows-1254:#windows-1254
	n.windows-1255:#windows-1255
	n.windows-1256:#windows-1256
	n.windows-1257:#windows-1257
	n.windows-1258:#windows-1258
	n.x-mac-cyrillic:#x-mac-cyrillic

	n.GBK:#gbk
	n.gb18030:#gb18030
	n.Big5:#big5
	n.EUC-JP:#euc-jp
	n.ISO-2022-JP:#iso-2022-jp
	n.Shift_JIS:#shift_jis
	n.EUC-KR:#euc-kr
	n.replacement:#replacement
	n.UTF-16LE:#utf-16le
	n.UTF-16BE:#utf-16be
	n.x-user-defined:#x-user-defined

n.UTF-16BE/LE:#utf-16be-le

	●encoder／decoder IDL
dec.符号化法:#textdecoder-encoding
dec.復号器:#textdecodercommon-decoder
dec.入出力~queue:#textdecodercommon-i-o-queue
dec.書出さないか:#textdecoder-do-not-flush-flag
dec.~BOMは無視するか:#textdecoder-ignore-bom-flag
dec.~BOMを見つけたか:#textdecoder-bom-seen-flag
dec.~error~mode:#textdecoder-error-mode

入出力~queueを直列化する:#concept-td-serialize

enc.符号化器:#textencoderstream-encoder
enc.処理待ち高位~surrogate:#textencoderstream-pending-high-surrogate

~cuを~scalar値に変換する:#convert-code-unit-to-scalar-value
~chunkを復号して~enqueueする:#decode-and-enqueue-a-chunk
~chunkを符号化して~enqueueする:#encode-and-enqueue-a-chunk
符号化して書出す:#encode-and-flush
書出して~enqueueする:#flush-and-enqueue


	●各種 encoder／decoder

~UTF-8復号器:#utf-8-decoder
~UTF-8符号化器:#utf-8-encoder
共用~UTF-16復号器:#shared-utf-16-decoder
~replacement復号器:#replacement-decoder
~replacement~errorは返した:#replacement-error-returned-flag

単-~byte復号器:#single-byte-decoder
単-~byte符号化器:#single-byte-encoder

~GBK用か:#gbk-flag

~gb1:#gb18030-first
~gb2:#gb18030-second
~gb3:#gb18030-third

~gb18030復号器:#gb18030-decoder
~gb18030符号化器:#gb18030-encoder

~Big5~lead:#big5-lead
~Big5復号器:#big5-decoder
~Big5符号化器:#big5-encoder

~EUC-JP~lead:#euc-jp-lead
~EUC-JP~jis0212:#euc-jp-jis0212-flag
~EUC-JP復号器:#euc-jp-decoder
~EUC-JP符号化器:#euc-jp-encoder

~ISO-2022-JP復号器:#iso-2022-jp-decoder
~ISO-2022-JP符号化器:#iso-2022-jp-encoder

~ISO-2022-JP復号器~状態:#iso-2022-jp-decoder-state
~ISO-2022-JP復号器~出力~状態:#iso-2022-jp-decoder-output-state
~ISO-2022-JP~lead:#iso-2022-jp-lead
~ISO-2022-JP出力:#iso-2022-jp-output-flag

i.ASCII:#iso-2022-jp-decoder-ascii
i.Roman:#iso-2022-jp-decoder-roman
i.katakana:#iso-2022-jp-decoder-katakana
i.~lead~byte:#iso-2022-jp-decoder-lead-byte
i.~trail~byte:#iso-2022-jp-decoder-trail-byte
i.~escape開始:#iso-2022-jp-decoder-escape-start
i.~escape:#iso-2022-jp-decoder-escape

~ISO-2022-JP符号化器~状態:#iso-2022-jp-encoder-state
i1.ASCII:#iso-2022-jp-encoder-ascii
i1.Roman:#iso-2022-jp-encoder-roman
i1.jis0208:#iso-2022-jp-encoder-jis0208

~Shift_JIS~lead:#shift_jis-lead
~Shift_JIS復号器:#shift_jis-decoder
~Shift_JIS符号化器:#shift_jis-encoder

~EUC-KR~lead:#euc-kr-lead
~EUC-KR復号器:#euc-kr-decoder
~EUC-KR符号化器:#euc-kr-encoder

~UTF-16~lead~byte:#utf-16-lead-byte
~UTF-16~lead~surrogate:#utf-16-lead-surrogate
~UTF-16復号器:#utf-16-decoder
~UTF-16LE復号器:#utf-16le-decoder
~UTF-16BE復号器:#utf-16be-decoder
~UTF-16BE復号器~用か:#utf-16be-decoder-flag

~x-user-defined復号器:#x-user-defined-decoder
~x-user-defined符号化器:#x-user-defined-encoder

	~byte列に変換-:#convert-a-code-unit-to-bytes

indexes.json:https://encoding.spec.whatwg.org/indexes.json

	●用語（外部

形式変換:~STREAMS#generictransformstream-transform
TS.設定しておく:~STREAMS#transformstream-set-up
	V.形式変換~algo:~STREAMS#transformstream-set-up-transformalgorithm
	V.書出n~algo:~STREAMS#transformstream-set-up-flushalgorithm
TS.~chunkを~enqueueする:~STREAMS#transformstream-enqueue

~list:~INFRA#list
~item:~INFRA#list-item
付加する:~INFRA#list-append
空:~INFRA#list-empty
挿入する:~INFRA#list-insert
前付加する:~INFRA#list-prepend
除去する:~INFRA#list-remove
~size:~INFRA#list-size
~queue:~INFRA#queue
範囲:~INFRA#the-range

~ASCII~byte:~INFRA#ascii-byte
~byte:~INFRA#byte
~byte列:~INFRA#byte-sequence
byte.長さ:~INFRA#byte-sequence-length
文字列:~INFRA#string
~scalar値~文字列:~INFRA#scalar-value-string
~cu:~INFRA#code-unit
~cp:~INFRA#code-point
cp.値:~INFRA#code-point-value
~scalar値:~INFRA#scalar-value
~surrogate:~INFRA#surrogate
~ASCII~cp:~INFRA#ascii-code-point
	~ASCII空白:~INFRA#ascii-whitespace
~ASCII数字:~INFRA#ascii-digit
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化:~INFRA#ascii-lowercase
~ASCII小文字~化する:~INFRA#ascii-lowercase
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
byte.から開始して:~INFRA#byte-sequence-starts-with

新たな:~WEBIDLjs#new
投出-:~WEBIDL#dfn-throw
~IDL値に変換する:~WEBIDLjs#dfn-convert-ecmascript-to-idl-value
複製を取得する:~WEBIDLjs#dfn-get-buffer-source-copy
BS.~byte長さ:~WEBIDLjs#buffersource-byte-length
配列~buffer~viewの中へ~byte列を書込む:~WEBIDLjs#arraybufferview-write
	:~WEBIDLjs#arraybufferview-write-startingoffset
~chunk:~STREAMS#chunk
可読~stream:~STREAMS#readable-stream
可書~stream:~STREAMS#writable-stream

並列的:~HTMLINFRA#in-parallel
符号化法を~sniffする~algo:~HTMLparsing#encoding-sniffing-algorithm
~event~loop:~WAPI#event-loop

_acks1:#_acks1
_ipr1:#_ipr1

●●words_table1

bAND: <span class="op">&amp;</span> 
bOR: <span class="op">|</span> 
Lshift: <span class="op">&lt;&lt;</span>
Rshift: <span class="op">&gt;&gt;</span>

encoding0:encoding
UTF-8:<b class="ename">UTF-8</b> 
GBK:<b class="ename">GBK</b> 
gb18030:<b class="ename">gb18030</b> 
Big5:<b class="ename">Big5</b> 
EUC-JP:<b class="ename">EUC-JP</b> 
ISO-2022-JP:<b class="ename">ISO-2022-JP</b> 
Shift_JIS:<b class="ename">Shift_JIS</b> 
EUC-KR:<b class="ename">EUC-KR</b> 
jis0208:<b class="ename">jis0208</b> 
jis0212:<b class="ename">jis0212</b> 
replacement:<b class="ename">replacement</b> 
UTF-16BE:<b class="ename">UTF-16BE</b> 
UTF-16LE:<b class="ename">UTF-16LE</b> 
x-user-defined:<b class="ename">x-user-defined</b> 


●●words_table


	●仕様
普遍的:universal:~
違法:illegal:~
自明:trivial:~
網羅的:exhaustive:~
保守的:conservative:~
合法:legitimate:~
移行-:move:~
完全さ:completeness:~
	標準:Standard
	関連しない:irrelevant
	省略時は:optional
proprietary::::プロプライエタリ
reverse-engineer:reverse engineer:::リバースエンジニア
簡明:clear:~
隔たり:gap:~
過去:past:~
凡例:legend:~
特質:property:~
固守-:adhere:~
警告:warning:~
排他的:exclusive:~
収束-:converge:~
究明:investigation:~
末端利用者:end user:~:::エンドユーザ
拡散-:spread:~
逸脱-:deviate:~
流布-:deploy:~
生産器:producer::~
消費器:consumer::~
霧消-:go away:~
	〜を包装する:wrapper
周知な:knownな:~
	-:known
宿題:exercise:~
対処法:workaround:~
稀:rare:~
正当:legitimate:~
意欲的:eager:~
計画:plan:~
証拠:evidence:~
	~~確たる証拠はなく:in the light of anecdotal evidence of the level of

	助力:help
	~~標準の:The
	~~考慮
	一式で:in combination with
	より~~一般的には:larger
	備考
	入手できる:available
	~~十分:fine
	広く:widespread
	序:Preface
	要〜:〜 needed
	不要:no need
	必要:have to
	見かけ上:superficially
	説明:Notes
	常に〜限らない:not always
	にもかかわらず:nonetheless
	後の:future
	~~不正な:bogus
	関する:-
	~~現在の姿:what it is today
	仕立て上げ:-
	配備-済み:deployed
	供する:-
	促す
	利用-中:in use
	利用されない:unused
	用-法の一つ:an approach one could take to use
	~~対処-:deal with
	~~対処:dealing with
	準じる:match
	知られ:known／
		追い易く:easy to follow
	示され:-
	呼ぶ:-
	埋める:-
	変わって:change
	見えない:not see
	記され
	記す
	一方で:whereas
	残しておく:left as
	事:fact
	疑問がある:questionable
	広く:broadly
	~~族:series
	為され:made
	必要性:necessity
	疑わしい:doubtful
	主要な:major
	含める／含めること:inclusion
	-:feature
	〜周り:around
	かまわない:free to
	されなくなる:will prevent 〜 from ever being
	なると見込まれる:will most likely
	併用しない:prevent the use of 〜 in combination with
	必ず〜ようにする~make~sure
	とは対照的に:in contrast to
	行うこと。：ought
	極めて:extremeに
	~~限定的:niche

	●未分類
不可分:atomic::~
前置-:prefix::~
重複-:duplicate:~

	一新-:set anew
	転換-:turn
	失わせ:loss
	戻す:back
	出くわし:hit
	~~空いた:newly-vacated
	表す:signify
	対:combination
	被せた:Layering 〜  on top
	加え
	指-:-
	得られ:-
	得る:-
	行う
	減らす:decrease

	●network／保安
防ぐ:preventする:~
細工:craft:~
情報喪失:information loss:~
合意-:agree:~
不一致:mismatch:~
交換:interchange:~
隠す:maskする:~
隠して:maskして:~
隠せな:maskできな:~
	突く:abuse
	至らせ:resulting in
	~~検知されずに:silent

	●符号化法
CJK:
私用領域:Private Use Area:~
	香港増補字符集
	基本多言語面
	互換漢字

gb1:
gb2:
gb3:
jis0212:
jis0208:
	Roman
utf-16be:
UTF-16:
Hangul::::ハングル
surrogate::::サロゲート
cp:code point::符号位置::コードポイント
cu:code unit::符号単位::コードユニット
有符号:coded::~::有コード
索引:index::~::インデックス
BOM:
	~BOMは無視するか:ignore BOM
	~BOMを見つけたか:BOM seen
	BOM:byte order mark
BOMseen:BOM seen:BOM 確認済み
簡体字:simplified::~
繁体字:traditional::~
範囲集:ranges::~

符号化器:encoder::~::エンコーダ
復号器:decoder::~::デコーダ

半角:halfwidth::~
全角:fullwidth::~
katakana::::カタカナ
Korean:
Japanese:
Chinese:
percent-::: %-

	空~行l:empty string

	●I/O queue／stream
入出力:I/O:~
close:
streaming::::ストリーム処理
	~streamしている:streaming
	~streamしていない:immediate
可読:readable::~
	unread:〜を元に戻す
可書:writable::~
書込まれ:writeされ::書き込まれ
書込む:writeする::書き込む
形式変換:transform::~
EoQ:end-of-queue::queue 終端:キュー終端
chunk::::チャンク
enqueue::::エンキュー
coder:
書出す:flushする::書き出す
書出さな:flushしな::書き出さな
書出して:flushして::書き出して
書出n:flush::書き出し

一掃-:flush::~
	書出さないか:do not flush
覗見る:peekする:覗き見る
lead:::頭部
trail:::尾部
連結-:concatenate:~
sniff:
不定:indefinite:~

	前後の:leading and trailing
	~buffer源:bufferSource
	出力~chunk:outputChunk
	書出n~algo:flushAlgorithm
	形式変換~algo:transformAlgorithm
	来て:coming
	来る:come
	個数:number

	●一般処理
繰返す:繰り返す
処理待ち:pending::~
演算対象:operand:~
往来-:roundtrip::~

下限:lower boundary::~
上限:upper boundary::~
範囲検査:limit check:~
発され:emitされ:~
発する:emitする:~
給-:supply:~

	〜が返す値:〜の return value
	かけた:run through
	〜にかける:runs them through
	出現~byte数:byte seen
	fatal:
	invocation
	渡す:pass
	通過する:pass 〜 through
	挙げられた順に:starting with the first one and going down
	次のいずれかが生じるまで:whichever comes first
	~call元:caller
	保つ:keepする:~
	生きたまま:alive

	%~BOM符号化法:BOMEncoding
	%入出力~queue:ioQueue
	%読取った~item群:readItems
	%~errorになり得る:potentialError
	%形式変換~stream:transformStream

	●データ型／操作／IDL
shift::::シフト
内包-:include::~
剰余:remainder:~
基数:base:~
剥ぐ:stripする:~
JSON:

	●未分類
XML:
被覆域:coverage:~
覆う:coverする:~
一覧:table:~
組立直せ:reassembleでき:組み立て直せ
cell::::セル
glyph::::グリフ

	視覚-化:visualize
	視覚-化:visualization
	算術式:equation
	~~統合:Unified
	伴われない:no 〜 present
	優先される:has priority over／more authoritative
	数
	数値:number
	桁:digit
	〜進数
	〜進表記
	~~孤立した:lone
	〜用:is 〜
	入力~用の:input
	出力~用の:output

	●指示語
最初の:first:~
最後の:last:~
高位:high:~

	全体的:overall
	〜の全体が:in its entirety
	左上隅:top left corner
	ある程度:some extent
	未満:less than
	他
	同じ:／
	前述の:aforementioned
	後続の:later
	最短:shortest
	かつての:former
	全くの:fully
	若干の:slight
	下位:least significant
	逆方向:vice versa
	並び／列／連列:sequence
	直後に続く:follows immediately
	成立-:true
	3 種の:three
	自身:themselves
	一部を成す:part of
	2 つの〜に:between
	唯一の／のみ:only
	複数:／
	2 回:twice
	様々な:various
	右辺:-
	左辺:-
	各種:-
	多くの:a lot of
	除く:but
	超え:over
	超えない:less than or equal to
	際して:-
	その種の:such
	他所:the rest of
	項目数:items
	次項:-
	括弧内:-
	省略-:without
	行:row
	冒頭:-
	相互に:go from 〜 and back
	一つ:one of／:-
	少し:some
	次回:next
	一連の:〜s
	上
	下
	これ以上〜ない:To stop
	それ以上:no more
	以下:below
	中
	以外:excluding
	それ以外では:other than that
	何か:something
	何も:nothing
	入る:in
	列目:-
	別として
	先頭:first／
	属する
	後者:-
	次
	次の
	節
	面
	該当-
	間
	回
	後は
	時
	最も
	末尾
	個
	一方で
	伴-
	備える
	右／左
	年
	応じて
	方
	済む
	有無:-
	無い
	点で
	的
	異なる
	有-
	万
	組
	表
	語

	●訳注
	下記
	先の
	総数
	代用対
	含意-
	固有の
	保持-
	内部状態
	制約-
	区点番号
	数値として
	数字列
	識別子
	日付
	時系列的
	構造
	機能
	外字
	角括弧
	記号
	記法
	記述
	訳
	訳者
	試す
	集合
	静的
	変数
	追加
	意味
	意味-
	表記規約
	用い


●●ref_normative

[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[STREAMS]
    Adam Rice; et al. ＜Streams Standard＞. Living Standard. URL: https://streams.spec.whatwg.org/
[UNICODE]
    ＜The Unicode Standard＞. URL: https://www.unicode.org/versions/latest/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[XML]
    Tim Bray; et al. ＜Extensible Markup Language (XML) 1.0 (Fifth Edition)＞. 26 November 2008. REC. URL: https://www.w3.org/TR/xml/


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://encoding.spec.whatwg.org/">Encoding Standard</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/encoding">GitHub whatwg/encoding</a> (<a href="https://github.com/whatwg/encoding/issues/new">new issue</a>, <a href="https://github.com/whatwg/encoding/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	https://github.com/whatwg/encoding/commits
	<a href="https://encoding.spec.whatwg.org/commit-snapshots/27e22cd5babd02547ca991e08a46d39a7c675377/">Snapshot as of this commit</a>
	<a href="https://twitter.com/encodings">@encodings</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/encoding">web-platform-tests encoding/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/encoding">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>
<body>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxwYXRoIGQ9Im01MCwwbDUwLDUwLTUwLDUwLTUwLTUwIiBmaWxsPSIjM2M3OTBhIi8+DQo8cGF0aCBkPSJtMzgsNDBjMC0xMiwyNC0xNSwyMy0yYzAsOS0xNiwxMy0xNiwyM3Y3aDEwdi00YzAtOSwxNy0xMiwxNy0yN2MtMi0yMi00NS0yMi00NSwzem03LDMyaDEwdjEwaC0xMCIgZmlsbD0iI2ZmZiIvPg0KPC9zdmc+DQo="
></a>

	<hgroup>
<h1>Encoding — 符号化法</h1>
	</hgroup>

</header>

<main id="MAIN" hidden>
	<section id="preface">

<h2 title="Preface">1. 序</h2>

<p>
~UTF-8符号化法は、
普遍的な有符号~文字~集合である~Unicodeの交換に最も適切な符号化法である。
よって，この仕様は、
新たな［
~protocol, 形式
］および［
新たな文脈~下で流布される既存の形式
］に対し，~UTF-8符号化法を要求する
（また，定義する）。
◎
The UTF-8 encoding is the most appropriate encoding for interchange of Unicode, the universal coded character set. Therefore for new protocols and formats, as well as existing formats deployed in new contexts, this specification requires (and defines) the UTF-8 encoding.
</p>

<p>
符号化法には，他のもの（旧来の符号化法）もあり、
過去にある程度までは定義されているが，
~UA間で常に同じ仕方で実装されているとは限らない。
また、
常に同じ~labelを利用するとは限らず，［
符号化法の中の未定義な区画, あるいは かつての~proprietaryな区画への~~対処
］も相違することが多い。
この仕様は、［
新たな実装が符号化法~実装を~reverse-engineerせずに済む
］よう，および［
既存の~UAが一つに収束できる
］よう，これらの隔たりを埋めることに取組む。
◎
The other (legacy) encodings have been defined to some extent in the past. However, user agents have not always implemented them in the same way, have not always used the same labels, and often differ in dealing with undefined and former proprietary areas of encodings. This specification addresses those gaps so that new user agents do not have to reverse engineer encoding implementations and existing user agents can converge.
</p>

<p>
特に，この仕様は、
それらの符号化法と，各~符号化法による［
~byte列と`~scalar値$列を相互に変換する~algo
］に加え，各~符号化法の［
正準的な名前, その識別-用の`~label$たち
］を定義する。
また、
符号化法の各種~algoのうち一部を~JSに公開する~APIも定義する。
◎
In particular, this specification defines all those encodings, their algorithms to go from bytes to scalar values and back, and their canonical names and identifying labels. This specification also defines an API to expose part of the encoding algorithms to JavaScript.
</p>

<p>
~UAは、
すでに
<a href="~IANA-a/character-sets/character-sets.xhtml">IANA Character Sets</a>
~registryに挙げられている~labelからも有意に逸脱している。
旧来の符号化法を これ以上~拡散させないため、
この仕様は前述の詳細~について網羅的であり，
~registryはもう不要である。
特に，この仕様は、
符号化法を拡張するための仕組みは供さない。
◎
User agents have also significantly deviated from the labels listed in the IANA Character Sets registry. To stop spreading legacy encodings further, this specification is exhaustive about the aforementioned details and therefore has no need for the registry. In particular, this specification does not provide a mechanism for extending any aspect of encodings.
</p>

	</section>
	<section id="security-background">

<h2 title="Security background">2. ~securityに関する背景0</h2>

<p>
符号化法には、
いくつか，~securityの課題がある
— 生産器と消費器の間で，［
利用-中の符号化法, あるいは所与の符号化法の実装-法
］について合意されてないときに。
例えば、
2011 年には，次のような攻撃が報告されている：
そこでは、［
攻撃者が何らかの~fieldを制御し得るような，~JSON資源
］内の `22^X ~trail~byteを “隠す” ために，
`Shift_JIS$n の~lead~byte `82^X が利用された。
生産器からは，これが違法な~byte対であっても問題が見えない一方で、
消費器は，この~byte対を単独の `FFFD^U として復号する~~結果、
全体的な解釈が変わってしまう
— `0022^U は重要な区切子なので。
［
`~scalar値$に対し複数~byteを利用する符号化法
］の復号器には、
今や，違法な~byte対の事例では［
範囲 `0000^U 〜 `007F^U に入る~scalar値
］を “隠せない” ようにすることが要求される
— 前述の~byte対に対しては、
出力が［
`FFFD^U `0022^U
］になるよう
（あいにく，これには例外があり、
`~gb18030復号器$は，`~EoQ$にある そのような~byte 1 個を “隠して” しまう）。
◎
There is a set of encoding security issues when the producer and consumer do not agree on the encoding in use, or on the way a given encoding is to be implemented. For instance, an attack was reported in 2011 where a Shift_JIS lead byte 0x82 was used to “mask” a 0x22 trail byte in a JSON resource of which an attacker could control some field. The producer did not see the problem even though this is an illegal byte combination. The consumer decoded it as a single U+FFFD and therefore changed the overall interpretation as U+0022 is an important delimiter. Decoders of encodings that use multiple bytes for scalar values now require that in case of an illegal byte combination, a scalar value in the range U+0000 to U+007F, inclusive, cannot be “masked”. For the aforementioned sequence the output would be U+FFFD U+0022. (As an unfortunate exception to this, the gb18030 decoder will “mask” up to one such byte at end-of-queue.)
</p>

<p>
これは、
より~~一般的には，［
~lead~byteが伴われないときに，`~ASCII~byte$を`~ASCII~cp$でない何かに対応付ける
］ような符号化法における課題である。
これらは， “~ASCII互換でない” 符号化法であり、
あいにく，すでに流布された内容のために要求されるが、［
`ISO-2022-JP$n, `UTF-16BE/LE$n
］以外のものは，~supportされない。
（その種の他の符号化法~labelについても、［
未知な符号化法へ~fallbackせずに，
`replacement$n 符号化法に対応付けてよいかどうか
］の究明が
<a href="https://github.com/whatwg/encoding/issues/8" title="Add more labels to the replacement encoding">進行中にある</a>。）
攻撃の一~例として、
注意深く細工された内容を資源の中へ注入して，利用者に符号化法を上書きするよう促す~~結果、
例えば~scriptの実行に至らせるものがある。
◎
This is a larger issue for encodings that map anything that is an ASCII byte to something that is not an ASCII code point, when there is no lead byte present. These are “ASCII-incompatible” encodings and other than ISO-2022-JP and UTF-16BE/LE, which are unfortunately required due to deployed content, they are not supported. (Investigation is ongoing whether more labels of other such encodings can be mapped to the replacement encoding, rather than the unknown encoding fallback.) An example attack is injecting carefully crafted content into a resource and then encouraging the user to override the encoding, resulting in, e.g., script execution.
</p>

<p>
~HTMLや~HTMLの~form特能に見出される~URLに利用される符号化器も、
その符号化法により表現できない~scalar値がある場合には，若干の情報喪失につながり得る。
例えば，資源が `windows-1252$n 符号化法を利用しているとき、
~serverは，末端利用者が~formに手入力した "💩" と "&amp;#128169;" とを判別できなくなる。
◎
Encoders used by URLs found in HTML and HTML’s form feature can also result in slight information loss when an encoding is used that cannot represent all scalar values. E.g., when a resource uses the windows-1252 encoding a server will not be able to distinguish between an end user entering “💩” and “&amp;#128169;” into a form.
</p>

<p>
ここに要旨した問題は、
~UTF-8を排他的に利用しているときは，霧消する。
それが、
今や，すべてに対し~UTF-8符号化法が義務付けられている理由の一つである。
◎
The problems outlined here go away when exclusively using UTF-8, which is one of the many reasons that is now the mandatory encoding for all things.
</p>

<p class="note">注記：
<a href="#browser-ui">§ ~browser~UI</a>も見よ。
◎
See also the Browser UI chapter.
</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p>
この仕様は、
`Infra Standard^cite `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
16 進数には "0x" が前置される。
◎
Hexadecimal numbers are prefixed with "0x".
</p>

<div class="p">
<p>
算術式の中のすべての数値は整数であり、
各種~~演算は次の記号で表現される：
</p>

<table><thead>
<tr><th>記号
<th>意味
<tbody>

<tr><th>~PLUS
<td>加算

<tr><th>~MINUS
<td>減算

<tr><th>~INCBY
<td>左辺~値に対する右辺~値による加算【この訳による追加】

<tr><th>~DECBY
<td>左辺~値に対する右辺~値による減算【この訳による追加】

<tr><th>~MUL
<td>乗算

<tr><th>~DIV
<td>整数の除算【小数切り捨て】

<tr><th>~MOD
<td>整数の除算の剰余（ modulo ）【常に正（負数には利用されない）】

<tr><th>~Lshift
<td>論理-左~shift

<tr><th>~Rshift
<td>論理-右~shift

<tr><th>~bAND
<td>~bit AND

<tr><th>~bOR
<td>~bit OR
</table>

◎
In equations, all numbers are integers, addition is represented by "+", subtraction by "−", multiplication by "×", integer division by "/" (returns the quotient), modulo by "%" (returns the remainder of an integer division), logical left shifts by "&lt;&lt;", logical right shifts by "&gt;&gt;", bitwise AND by "&amp;", and bitwise OR by "|".
</div>

<p>
論理-右~shiftの演算対象の精度は、
少なくとも 21 ~bit以上にするモノトスル。
◎
For logical right shifts operands must have at least twenty-one bits precision.
</p>

<hr>

<p>
`入出力~queue@
（ `I/O queue^en ）は、
各`~item$が特定0の型の値（ `~byte$ ／ `~scalar値$ ／ `~cu$ など）をとる`~list$である。
~item型も含めて指定するときは、
“`入出力~queue$`~byte^tA” 等々と記される†。
【†この表記規約は、この訳による。】
◎
An I/O queue is a type of list with items of a particular type (i.e., bytes or scalar values).＼
</p>

<p>
`入出力~queue$は、
特別な`~item$として
`~EoQ@
（ `end-of-queue^en ）も含み得る
— それは、
当の~queue内には，それより後に`~item$は無いことを徴す。
【`~EoQ$の型は、形式的に，それが属する`入出力~queue$の~item型と見なされる。】
◎
End-of-queue is a special item that can be present in I/O queues of any type and it signifies that there are no more items in the queue.
</p>

<div class="note">
<p>注記：
`入出力~queue$は、
2 つの仕方
— “~streamしている” ~mode，していない~mode —
で利用され、
順に［
~networkから来ている~data,
~memory内に格納された入出力~data
］を表現する。
~streamしていない~queue内には、
最後の~itemとして【常に】`~EoQ$が在る。
一方で，~streamしている`入出力~queue$は：
◎
There are two ways to use an I/O queue: in immediate mode, to represent I/O data stored in memory, and in streaming mode, to represent data coming in from the network. Immediate queues have end-of-queue as their last item, whereas streaming queues＼
</p>
<ul>
	<li>
`~EoQ$は無いこともあり、
`入出力~queueから~itemを読取る$演算は，
【何らかの~itemが可用になるまで】阻まれるかもしれない。
◎
need not have it, and so their read operation might block.
</li>
	<li>
次の順に演算されるものと期待される
⇒＃
空として作成される,
~networkから~dataが来るに伴い，新たな`~item$が`~push$ioQされる,
下層の~network~streamが~closeされるとき，`~EoQ$が`~push$ioQされる
◎
It is expected that streaming I/O queues will be created empty, and that new items will be pushed to it as data comes in from the network. When the underlying network stream closes, an end-of-queue item is to be pushed into the queue.
</li>
	<li>
そこから何かを読取るとき，阻まれるかもしれないので、
`~event~loop$からは利用されず，代わりに`並列的$に利用される。
◎
Since reading from a streaming I/O queue might block, streaming I/O queues are not to be used from an event loop. They are to be used in parallel instead.
</li>
</ul>
</div>

<div class="algo">
<p>
`入出力~queueから~itemを読取る@
ときは、
所与の
( `入出力~queue$ %入出力~queue, %個数 （省略時は ε ） )
に対し，次を走らす：
</p>
<ol>
	<li>
<p>
~IF［
%個数 ~EQ ε
］：
</p>
		<ol>
			<li>
~IF［
%入出力~queue は`空$である
］
⇒
次が満たされるまで待機する
⇒
%入出力~queue の`~size$ ~GTE 1
</li>
			<li>
%結果 ~LET %入出力~queue[ 0 ]
</li>
			<li>
~IF［
%結果 ~NEQ `~EoQ$
］
⇒
%入出力~queue から最初の~itemを`除去する$
</li>
			<li>
~RET %結果
</li>
		</ol>
	</li>
	<li>
~Assert：［
%個数 は負でない整数である
］~OR［
%個数 ~EQ `不定^i
］
</li>
	<li>
%読取った~item群 ~LET 新たな`~list$
</li>
	<li>
%n ~LET 0
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
~IF［
%個数 ~NEQ `不定^i
］~AND［
%n ~GTE %個数
］
⇒
~BREAK
</li>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %入出力~queue )
</li>
			<li>
~IF［
%~item ~EQ `~EoQ$
］
⇒
~BREAK
</li>
			<li>
%読取った~item群 に %~item を`付加する$
</li>
			<li>
%n ~INCBY 1
</li>
		</ol>
	</li>
	<li>
~RET %読取った~item群
</li>
</ol>

◎
To read an item from an I/O queue ioQueue, run these steps:
• If ioQueue is empty, then wait until its size is at least 1.
• If ioQueue[0] is end-of-queue, then return end-of-queue.
• Remove ioQueue[0] and return it.
◎
To read a number number of items from ioQueue, run these steps:
• Let readItems be an empty list.
•• Perform the following step number times:
•• Append to readItems the result of reading an item from ioQueue.
• Remove end-of-queue from readItems.
• Return readItems.
</div>

<div class="algo">
<p>
`入出力~queueを覗見る@
ときは、
所与の
( `入出力~queue$ %入出力~queue, 整数 %個数 )
に対し，次を走らす：
◎
To peek a number number of items from an I/O queue ioQueue, run these steps:
</p>
<ol>
	<li>
次が満たされるまで待機する
⇒
［
%入出力~queue の`~size$ ~GTE %個数
］~OR［
`~EoQ$ ~IN %入出力~queue
］
◎
Wait until either ioQueue’s size is equal to or greater than number, or ioQueue contains end-of-queue, whichever comes first.
</li>
	<li>
%接頭辞 ~LET 新たな`~list$
◎
Let prefix be an empty list.
</li>
	<li>
<p>
`範囲$ { 0 〜 %個数 ~MINUS 1 }【！range 1 to number】 を成す
~EACH( %n )
に対し：
◎
For each n in the range 1 to number, inclusive:
</p>
		<ol>
			<li>
~IF［
%入出力~queue[ %n ] ~EQ `~EoQ$
］
⇒
~BREAK
◎
If ioQueue[n] is end-of-queue, break.
</li>
			<li>
%接頭辞 に %入出力~queue[ %n ] を`付加する$
◎
Otherwise, append ioQueue[n] to prefix.
</li>
		</ol>
	</li>
	<li>
~RET %接頭辞
◎
Return prefix.
</li>
</ol>
</div>

<div class="algo">
<p>
`入出力~queueに~pushする@
ときは、
所与の
( `入出力~queue$ %入出力~queue, %~item列 )
に対し，次を走らす：
</p>
<ol>
	<li>
~Assert：［
%~item列 は 1 個の~itemであるか［
0 個以上の~itemからなる連列
］である
］~AND［
%~item列 を成す どの~itemも，その型は %入出力~queue の~item型である
］
</li>
	<li>
<p>
%~item列 を成す
~EACH( %~item )
に対し：
</p>
		<ol>
			<li>
%最後の~index ~LET %入出力~queue の`~size$ ~MINUS 1
</li>
			<li>
<p>
~IF［
%入出力~queue[ %最後の~index ] ~EQ `~EoQ$
］：
</p>
				<ol>
					<li>
~IF［
%~item ~NEQ `~EoQ$
］
⇒
%入出力~queue の中の %最後の~index の前に %~item を`挿入する$
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%入出力~queue に %~item を`付加する$
</li>
		</ol>
	</li>
</ol>

◎
To push an item item to an I/O queue ioQueue, run these steps:
• If the last item in ioQueue is end-of-queue, then:
•• If item is end-of-queue, do nothing.
•• Otherwise, insert item before the last item in ioQueue.
• Otherwise, append item to ioQueue.
◎
To push a sequence of items to an I/O queue ioQueue is to push each item in the sequence to ioQueue, in the given order.
</div>

<div class="algo">
<p>
`入出力~queueに前付加する@
ときは、
所与の
( `入出力~queue$ %入出力~queue, %~item列 )
に対し，次を走らす：
</p>
<ol>
	<li>
~Assert：［
%~item列 は 1 個の~itemであるか［
0 個以上の~itemからなる連列
］である
］~AND［
%~item列 内に`~EoQ$は無い
］~AND［
%~item列 を成す どの~itemも，その型は %入出力~queue の~item型である
］
</li>
	<li>
%~item列 を成す
~EACH( %~item )
に対し，逆順に
⇒
%入出力~queue に %~item を`前付加する$
</li>
</ol>
◎
To prepend an item other than end-of-queue to an I/O queue, perform the normal list prepend operation. To prepend a sequence of items not containing end-of-queue, insert those items, in the given order, before the first item in the queue.
</div>


<p class="example">
~scalar値~itemが成す連列
"<code>&amp;#128169;</code>"
を`入出力~queue$`~scalar値^tA
"<code> hello world</code>"
の先頭に挿入した結果は，入出力~queue
"<code>&amp;#128169; hello world</code>"
になり、
次回に読取られる~itemは <code>&amp;</code> になる。
<!-- 💩 --><!-- #x1F4A9 = 128169 decimal -->
◎
Inserting the sequence of scalar value items &amp;#128169; in an I/O queue of scalar values " hello world", results in an I/O queue "&amp;#128169; hello world". The next item to be read would be &amp;.
</p>

<div class="algo">
<p>
`入出力~queue$ %入出力~queue を［
`~list$／`文字列$／`~byte列$
］に
`変換する@
ときは、
次の結果を返す
⇒
`入出力~queueから~itemを読取る$( %入出力~queue, `不定^i )
◎
To convert an I/O queue ioQueue into a list, string, or byte sequence, return the result of reading an indefinite number of items from ioQueue.
</div>

<div class="algo">
<p>
`入出力~queueに変換する@
ときは、
所与の
( %入力 )
に対し：
</p>
<ol>
	<li>
~Assert：
%入力 は次に挙げるいずれかである
⇒＃
`文字列$（ `DOMString^I ）／
`~scalar値~文字列$（ `USVString^I ）／
`~byte列$／
`~list$
</li>
	<li>
~Assert：
%入力 は`~list$であるならば、
次を満たす
⇒
［
%入力 を成す すべての~itemは同じ型である
］~AND［
`~EoQ$ ~NIN %入力
］
</li>
	<li>
%入出力~queue ~LET 新たな`入出力~queue$`<var>入力</var> を成す~itemの型^tA
</li>
	<li>
%入力 を成す
~EACH( %~item )
に対し
⇒
%入出力~queue に %~item を`付加する$
</li>
	<li>
%入出力~queue に`~EoQ$を`付加する$
</li>
	<li>
~RET %入出力~queue
</li>
</ol>
◎
To convert a list, string, or byte sequence input into an I/O queue, run these steps:
• Assert: if input is a list, then it does not contain end-of-queue.
• Return an I/O queue containing the items in input, in order, followed by end-of-queue.
</div>

<p class="XXX">
`INFRA$r 標準が型~変換~周りの何らかの基盤を定義するものと期待される。
<a href="https://github.com/whatwg/infra/issues/319">whatwg/infra 課題 #319</a>
を見よ。
◎
The Infra standard is expected to define some infrastructure around type conversions. See whatwg/infra issue #319. [INFRA]
</p>

<p class="note">注記：
`入出力~queue$が，`~queue$ではなく`~list$として定義されているのは、
`入出力~queueに前付加する$演算を要するからである。
しかしながら，この前付加-演算は、
この仕様が与える~algoの内部的な詳細であり，他の標準からは利用されない。
実装は、
そのような~algoを代替な仕方を見出して実装してもかまわない
— 詳細は、
<a href="#implementation-considerations">§ 実装の考慮点</a>に。
◎
I/O queues are defined as lists, not queues, because they feature a prepend operation. However, this prepend operation is an internal detail of the algorithms in this specification, and is not to be used by other standards. Implementations are free to find alternative ways to implement such algorithms, as detailed in Implementation considerations.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

<p>
加えて、
次に挙げる記法も利用される：
</p>

<table><thead>
<tr><th style="min-width: 10em;">記法
<th>意味

<tbody>
<tr><th style="white-space:nowrap;">~byte列 [ %n1, %n2, … ]
<td>
数値として %n1, %n2 … と同じ値をとる一連の`~byte$からなる, 同順の，新たな`~item$列を表す。
角括弧の中が空
— “~byte列 [] ” —
と記されたときは，空な`~item$列を表す。

<tr><th style="white-space:nowrap;">~cp [ %n ]
<td>数値として %n と同じ値をとる 1 個の`~cp$からなる，新たな`~item$列を表す。
</table>

	</section>
	<section id="encodings">
<h2 title="Encodings">4. 符号化法</h2>

<p>
`符号化法@
（ `encoding^en ）は、
`~scalar値$ 列から~byte列への対応付け
【符号化-】
および逆方向への対応付け
【復号-】
を定義する。
各 `符号化法$には、
`名前@
および， 1 個~以上の
`~label@
が<a href="#encoding-labels">あてがわれている</a>。
◎
An encoding defines a mapping from a scalar value sequence to a byte sequence (and vice versa). Each encoding has a name, and one or more labels.
</p>

<p class="note">注記：
この仕様は、
~Unicode標準に定義される `encoding scheme^en として，同じ名前を伴う 3 種の`符号化法$
— `UTF-8$n, `UTF-16LE$n, `UTF-16BE$n —
を定義する。
`符号化法$は、
~BOM（ `byte order mark^en, “バイト順マーク” ）の取扱いにおいて `encoding scheme^en から相違する
— ~BOMの取扱いは、
この仕様においては［
`符号化法$自身の一部を成す代わりに，それを包装する~algoの一部を成している
］一方で，
~Unicode標準においては `encoding scheme^en の定義の一部を成す。
`~UTF-8復号する$~algoと一緒に利用される `UTF-8$n は、
同じ名前の `encoding scheme^en に合致する。
この仕様は、
同様に命名される `encoding scheme^en に合致するような［
`UTF-16LE$n ／ `UTF-16BE$n
］と組合せて包装する~algoは，供さない。
`UNICODE$r
◎
This specification defines three encodings with the same names as encoding schemes defined in the Unicode standard: UTF-8, UTF-16LE, and UTF-16BE. The encodings differ from the encoding schemes by byte order mark (also known as BOM) handling not being part of the encodings themselves and instead being part of wrapper algorithms in this specification, whereas byte order mark handling is part of the definition of the encoding schemes in the Unicode Standard. UTF-8 used together with the UTF-8 decode algorithm matches the encoding scheme of the same name. This specification does not provide wrapper algorithms that would combine with UTF-16LE and UTF-16BE to match the similarly-named encoding schemes. [UNICODE]
</p>

		<section id="encoders-and-decoders">
<h3 title="Encoders and decoders">4.1. 符号化器と復号器</h3>

<p>
各 `符号化法$には、
`復号器@
（ `decoder^en ）が結付けられ，
`符号化器@
（ `encoder^en ）が結付けられ得る。
◎
Each encoding has an associated decoder and most of them have an associated encoder.＼
</p>

<p>
［
`復号器$ ／ `符号化器$
］の各~instanceは、
`~handler@
~algoが結付けられることに加え，状態も伴い得る。
【状態を伴うがゆえに、状態が異なる それらを別個な~instanceとして扱う必要がある。】
◎
Instances of decoders and encoders have a handler algorithm and might also have state.＼
</p>

<div class="p">
<p>
`~handler$は、
所与の
( `入出力~queue$, 1 個の`~item$ )
に対し，次に挙げるいずれかを返す~algoである：
</p>
<ul>
	<li>
`完遂d@i
</li>
	<li>
<p>
1 個以上の`~item$
</p>

<p class="trans-note">【
~item型は、［
符号化器の場合は`~byte$ ／ 復号器の場合は`~cp$
］になる。
】【
`~Big5復号器$用の~handlerだけ， 2 個の~cpを返す場合があり、
他の復号器~用の~handlerは，常に 1 個の~cpからなる~item列を返す。
】</p>
	</li>
	<li>
<p>
`~error@i
</p>

<p>
`符号化器$用の`~handler$が返す `~error$i は、
常に，~cpを伴う
（`復号器$用の`~handler$が返す `~error$i が~cpを伴うことは無い）。
所与の`~cp$ %~cp を伴う `~error$i を作成する所では、
“`~error$i( %~cp )”
のように表記される。
</p>

<p class="trans-note">【
これらの記述は、
この訳による補完
— 原文では、
（~errorは，）
“省略可能な`~cp$も伴い得る”
としか記されていない。
】</p>

	</li>
	<li>
`継続-@i
</li>
</ul>
◎
A handler algorithm takes an input I/O queue and an item, and returns finished, one or more items, error optionally with a code point, or continue.
</div>

<p class="note">注記：
次に挙げる`符号化法$には、
`符号化器$はない
⇒＃
`replacement$n,
`UTF-16BE/LE$n
◎
The replacement and UTF-16BE/LE encodings have no encoder.
</p>

<p>
以下で利用される
`~error~mode@
は：
◎
An error mode as used below is＼
</p>
<ul>
	<li>
`復号器$においては、
次のいずれかをとる
⇒
`replacement^l,
`fatal^l
◎
"replacement" or "fatal" for a decoder and＼
</li>
	<li>
`符号化器$においては、
次のいずれかをとる
⇒
`fatal^l,
`html^l
◎
"fatal" or "html" for an encoder.
</li>
</ul>

<p class="note">注記：
~XML処理器は、
その`復号器$の`~error~mode$を `fatal^l に設定することになる。
`XML$r
◎
An XML processor would set error mode to "fatal". [XML]
</p>

<p class="note">注記：
`~error~mode$に `html^l が存在するわけは、
~HTML~formにおいては，
`~error$i に際しても旧来の`符号化器$は終了させない取扱いが要求されることに因る。
`html^l `~error~mode$の下では、
合法な入力と判別できない連列が発され得る結果，~~検知されずに~dataが失われ得る。
これを防ぐため、
開発者には `UTF-8$n `符号化法$の利用が強く奨励される。
`HTML$r
◎
"html" exists as error mode due to HTML forms requiring a non-terminating legacy encoder. The "html" error mode causes a sequence to be emitted that cannot be distinguished from legitimate input and can therefore lead to silent data loss. Developers are strongly encouraged to use the UTF-8 encoding to prevent this from happening. [HTML]
</p>

<hr>

<div class="algo">
<p>
`~queueを処理する@
ときは、
所与の
⇒＃
`符号化法$の［ `復号器$ ／ `符号化器$ ］の~instance %~coder
`入出力~queue$ %入力,
`入出力~queue$ %出力,
`~error~mode$ %~mode
◎終
に対し：
◎
To process a queue given an encoding’s decoder or encoder instance encoderDecoder, I/O queue input, I/O queue output, and error mode mode:
</p>
<ol>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%結果 ~LET `~itemを処理する$( 次の結果, %~coder, %入力, %出力, %~mode )
⇒
`入出力~queueから~itemを読取る$( %入力 )
◎
Let result be the result of processing an item with the result of reading from input, encoderDecoder, input, output, and mode.
</li>
			<li>
~IF［
%結果 ~NEQ `継続-$i
］
⇒
~RET %結果
◎
If result is not continue, then return result.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~itemを処理する@
ときは、
所与の
⇒＃
`~item$ %~item,
`符号化法$の［ `符号化器$／`復号器$ ］の~instance %~coder,
`入出力~queue$ %入力,
`入出力~queue$ %出力,
`~error~mode$ %~mode
◎終
に対し：
◎
To process an item given an item item, encoding’s encoder or decoder instance encoderDecoder, I/O queue input, I/O queue output, and error mode mode:
</p>
<ol>
	<li>
~Assert：
%~coder は`符号化器$の~instanceであるならば、
%~mode ~NEQ `replacement^l
◎
Assert: if encoderDecoder is an encoder instance, mode is not "replacement".
</li>
	<li>
~Assert：
%~coder は`復号器$の~instanceであるならば、
%~mode ~NEQ `html^l
◎
Assert: if encoderDecoder is a decoder instance, mode is not "html".
</li>
	<li>
~Assert：
%~coder は`符号化器$の~instanceであるならば、
%~item は`~surrogate$ではない。
◎
Assert: if encoderDecoder is an encoder instance, item is not a surrogate.
</li>
	<li>
%結果 ~LET 次を与える下で， %~coder の`~handler$を走らせた結果
⇒
( %入力, %~item )
◎
Let result be the result of running encoderDecoder’s handler on input and item.
</li>
	<li>
~IF［
%結果 ~EQ `完遂d$i
］
⇒＃
`入出力~queueに~pushする$( %出力, « `~EoQ$ » )；
~RET %結果
◎
If result is finished:
• Push end-of-queue to output.
• Return result.
</li>
	<li>
<p>
~IF［
%結果 は 1 個~以上の`~item$からなる
］：
◎
Otherwise, if result is one or more items:
</p>
		<ol>
			<li>
~Assert：
%~coder は`復号器$の~instanceであるならば、
%結果 は`~surrogate$を包含しない。
◎
Assert: if encoderDecoder is a decoder instance, result does not contain any surrogates.
</li>
			<li>
`入出力~queueに~pushする$( %出力, %結果 )；
◎
Push result to output.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%結果 は `~error$i である
］：
◎
Otherwise, if result is an error,＼
</p>
		<ol>
			<li>
<p>
%~mode に応じて：
◎
switch on mode and run the associated steps:
</p>
				<ul class="switch">
					<li>
`replacement^l
⇒
`入出力~queueに~pushする$( %出力, « `FFFD^U `�^smb » )
◎
"replacement"
• Push U+FFFD (�) to output.
</li>
					<li>
<p>
`html^l：
</p>
						<ol>
							<li>
%数字列 ~LET ［
%結果 を成す`~cp$
］の`値$cpを基数 10 で最短に表現するような，［
1 個以上の［
`30^X `0^smb 〜 `39^X `9^smb
］からなる~byte列
</li>
							<li>
`入出力~queueに~pushする$( %出力, 次の並びが成す~byte列 )
⇒＃
`26^X `&amp;^smb,
`23^X `#^smb,
%数字列,
`3B^X `;^smb
</li>
						</ol>
◎
"html"
• Push 0x26 (&amp;), 0x23 (#), followed by the shortest sequence of 0x30 (0) to 0x39 (9), inclusive, representing result’s code point’s value in base ten, followed by 0x3B (;) to output.
</li>
					<li>
`fatal^l
⇒
~RET %結果
◎
"fatal"
• Return result.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
~RET `継続-$i
◎
Return continue.
</li>
</ol>
</div>

		</section>
		<section id="names-and-labels">
<h3 title="Names and labels">4.2. 名前と~label</h3>

<p>
~UAは、
下の一覧に挙げる各［
`符号化法$, それ用の`~label$すべて
］を~supportするモノトスル
— 他の`符号化法$や`~label$は~supportしないモノトスル。
◎
The table below lists all encodings and their labels user agents must support. User agents must not support any other encodings or labels.
</p>

<p class="note">注記：
どの符号化法についても、
次が満たされる
⇒
その`名前$を`~ASCII小文字~化$した結果 ~IN それ用の`~label$たちが成す集合
◎
For each encoding, ASCII-lowercasing its name yields one of its labels.
</p>

<p class="trans-note">【
加えて、
異なる符号化法~用の~labelどうしが一致することはない。
】</p>

<p>
作者は、
`UTF-8$n `符号化法$を利用しなければナラナイ
— その利用が識別されるよう，
それ用の`~label$のうち `utf-8^lb （`~ASCII大小無視$）を利用しなければナラナイ。
◎
Authors must use the UTF-8 encoding and must use its (ASCII case-insensitive) "utf-8" label to identify it.
</p>

<p>
新たな［
~protocolや形式
］, あるいは［
新たな文脈~下で流布される既存の形式
］には、
`UTF-8$n `符号化法$を排他的に利用しなければナラナイ。
そのような［
~protocolや形式
］が公開する`符号化法$の［
`名前$／`~label$
］は、
`utf-8^lb でなければナラナイ。
◎
New protocols and formats, as well as existing formats deployed in new contexts, must use the UTF-8 encoding exclusively. If these protocols and formats need to expose the encoding’s name or label, they must expose it as "utf-8".
</p>

<div class="algo">
<p>
`~labelから符号化法を取得する@
ときは、
所与の
( 文字列 %~label )
に対し，次を走らす：
◎
To get an encoding from a string label, run these steps:
</p>
<ol>
	<li>
%~label ~SET `前後の~ASCII空白~列を剥ぐ$( %~label )
◎
Remove any leading and trailing ASCII whitespace from label.
</li>
	<li>
~IF［
%~label は［
下の一覧を成すいずれかの~label
］に`~ASCII大小無視$で合致する
］
⇒
~RET 合致した~labelに対応する`符号化法$
◎
If label is an ASCII case-insensitive match for any of the labels listed in the table below, then return the corresponding encoding;＼
</li>
	<li>
~RET `失敗^i
◎
otherwise return failure.
</li>
</ol>
</div>

<p class="note">注記：
この［
~labelを`符号化法$に対応付ける~algo
］は、
<a href="https://www.unicode.org/reports/tr22/tr22-8.html#Charset_Alias_Matching">Unicode Technical Standard #22 § 1.4</a>
によるものより基本的かつ制約的である
— 配備-済みな内容と互換になることが必要とされるので。
◎
This is a more basic and restrictive algorithm of mapping labels to encodings than section 1.4 of Unicode Technical Standard #22 prescribes, as that is necessary to be compatible with deployed content.
</p>

<table id="encoding-labels"><thead>
<tr><th>
名前
◎
Name
<th>
~label
◎
Labels

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#the-encoding">~~標準の符号化法</a>
◎
The Encoding
<tr><td>`UTF-8$n
<td>`unicode-1-1-utf-8^lb
`unicode11utf8^lb
`unicode20utf8^lb
`utf-8^lb
`utf8^lb
`x-unicode20utf8^lb

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-single-byte-encodings">旧来の単-~byte符号化法</a>
◎
Legacy single-byte encodings
<tr><td>`IBM866$n
<td>`866^lb
`cp866^lb
`csibm866^lb
`ibm866^lb
<tr><td>`ISO-8859-2$n
<td>`csisolatin2^lb
`iso-8859-2^lb
`iso-ir-101^lb
`iso8859-2^lb
`iso88592^lb
`iso_8859-2^lb
`iso_8859-2:1987^lb
`l2^lb
`latin2^lb
<tr><td>`ISO-8859-3$n
<td>`csisolatin3^lb
`iso-8859-3^lb
`iso-ir-109^lb
`iso8859-3^lb
`iso88593^lb
`iso_8859-3^lb
`iso_8859-3:1988^lb
`l3^lb
`latin3^lb
<tr><td>`ISO-8859-4$n
<td>`csisolatin4^lb
`iso-8859-4^lb
`iso-ir-110^lb
`iso8859-4^lb
`iso88594^lb
`iso_8859-4^lb
`iso_8859-4:1988^lb
`l4^lb
`latin4^lb
<tr><td>`ISO-8859-5$n
<td>`csisolatincyrillic^lb
`cyrillic^lb
`iso-8859-5^lb
`iso-ir-144^lb
`iso8859-5^lb
`iso88595^lb
`iso_8859-5^lb
`iso_8859-5:1988^lb
<tr><td>`ISO-8859-6$n
<td>`arabic^lb
`asmo-708^lb
`csiso88596e^lb
`csiso88596i^lb
`csisolatinarabic^lb
`ecma-114^lb
`iso-8859-6^lb
`iso-8859-6-e^lb
`iso-8859-6-i^lb
`iso-ir-127^lb
`iso8859-6^lb
`iso88596^lb
`iso_8859-6^lb
`iso_8859-6:1987^lb
<tr><td>`ISO-8859-7$n
<td>`csisolatingreek^lb
`ecma-118^lb
`elot_928^lb
`greek^lb
`greek8^lb
`iso-8859-7^lb
`iso-ir-126^lb
`iso8859-7^lb
`iso88597^lb
`iso_8859-7^lb
`iso_8859-7:1987^lb
`sun_eu_greek^lb
<tr><td>`ISO-8859-8$n
<td>`csiso88598e^lb
`csisolatinhebrew^lb
`hebrew^lb
`iso-8859-8^lb
`iso-8859-8-e^lb
`iso-ir-138^lb
`iso8859-8^lb
`iso88598^lb
`iso_8859-8^lb
`iso_8859-8:1988^lb
`visual^lb
<tr><td>`ISO-8859-8-I$n
<td>`csiso88598i^lb
`iso-8859-8-i^lb
`logical^lb
<tr><td>`ISO-8859-10$n
<td>`csisolatin6^lb
`iso-8859-10^lb
`iso-ir-157^lb
`iso8859-10^lb
`iso885910^lb
`l6^lb
`latin6^lb
<tr><td>`ISO-8859-13$n
<td>`iso-8859-13^lb
`iso8859-13^lb
`iso885913^lb
<tr><td>`ISO-8859-14$n
<td>`iso-8859-14^lb
`iso8859-14^lb
`iso885914^lb
<tr><td>`ISO-8859-15$n
<td>`csisolatin9^lb
`iso-8859-15^lb
`iso8859-15^lb
`iso885915^lb
`iso_8859-15^lb
`l9^lb
<tr><td>`ISO-8859-16$n
<td>`iso-8859-16^lb
<tr><td>`KOI8-R$n
<td>`cskoi8r^lb
`koi^lb
`koi8^lb
`koi8-r^lb
`koi8_r^lb
<tr><td>`KOI8-U$n
<td>`koi8-ru^lb
`koi8-u^lb
<tr><td>`macintosh$n
<td>`csmacintosh^lb
`mac^lb
`macintosh^lb
`x-mac-roman^lb
<tr><td>`windows-874$n
<td>`dos-874^lb
`iso-8859-11^lb
`iso8859-11^lb
`iso885911^lb
`tis-620^lb
`windows-874^lb
<tr><td>`windows-1250$n
<td>`cp1250^lb
`windows-1250^lb
`x-cp1250^lb
<tr><td>`windows-1251$n
<td>`cp1251^lb
`windows-1251^lb
`x-cp1251^lb
<tr><td>`windows-1252$n
<td>`ansi_x3.4-1968^lb
`ascii^lb
`cp1252^lb
`cp819^lb
`csisolatin1^lb
`ibm819^lb
`iso-8859-1^lb
`iso-ir-100^lb
`iso8859-1^lb
`iso88591^lb
`iso_8859-1^lb
`iso_8859-1:1987^lb
`l1^lb
`latin1^lb
`us-ascii^lb
`windows-1252^lb
`x-cp1252^lb
<tr><td>`windows-1253$n
<td>`cp1253^lb
`windows-1253^lb
`x-cp1253^lb
<tr><td>`windows-1254$n
<td>`cp1254^lb
`csisolatin5^lb
`iso-8859-9^lb
`iso-ir-148^lb
`iso8859-9^lb
`iso88599^lb
`iso_8859-9^lb
`iso_8859-9:1989^lb
`l5^lb
`latin5^lb
`windows-1254^lb
`x-cp1254^lb
<tr><td>`windows-1255$n
<td>`cp1255^lb
`windows-1255^lb
`x-cp1255^lb
<tr><td>`windows-1256$n
<td>`cp1256^lb
`windows-1256^lb
`x-cp1256^lb
<tr><td>`windows-1257$n
<td>`cp1257^lb
`windows-1257^lb
`x-cp1257^lb
<tr><td>`windows-1258$n
<td>`cp1258^lb
`windows-1258^lb
`x-cp1258^lb
<tr><td>`x-mac-cyrillic$n
<td>`x-mac-cyrillic^lb
`x-mac-ukrainian^lb

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-chinese-(simplified)-encodings">旧来の複-~byte~Chinese（簡体字） 符号化法</a>
◎
Legacy multi-byte Chinese (simplified) encodings
<tr><td>`GBK$n
<td>`chinese^lb
`csgb2312^lb
`csiso58gb231280^lb
`gb2312^lb
`gb_2312^lb
`gb_2312-80^lb
`gbk^lb
`iso-ir-58^lb
`x-gbk^lb
<tr><td>`gb18030$n
<td>`gb18030^lb

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-chinese-(traditional)-encodings">旧来の複-~byte~Chinese（繁体字）符号化法</a>
◎
Legacy multi-byte Chinese (traditional) encodings
<tr><td>`Big5$n
<td>`big5^lb
`big5-hkscs^lb
`cn-big5^lb
`csbig5^lb
`x-x-big5^lb

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-japanese-encodings">旧来の複-~byte~Japanese符号化法</a>
◎
Legacy multi-byte Japanese encodings
<tr><td>`EUC-JP$n
<td>`cseucpkdfmtjapanese^lb
`euc-jp^lb
`x-euc-jp^lb
<tr><td>`ISO-2022-JP$n
<td>`csiso2022jp^lb
`iso-2022-jp^lb
<tr><td>`Shift_JIS$n
<td>`csshiftjis^lb
`ms932^lb
`ms_kanji^lb
`shift-jis^lb
`shift_jis^lb
`sjis^lb
`windows-31j^lb
`x-sjis^lb

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-korean-encodings">旧来の複-~byte~Korean符号化法</a>
◎
Legacy multi-byte Korean encodings
<tr><td>`EUC-KR$n
<td>`cseuckr^lb
`csksc56011987^lb
`euc-kr^lb
`iso-ir-149^lb
`korean^lb
`ks_c_5601-1987^lb
`ks_c_5601-1989^lb
`ksc5601^lb
`ksc_5601^lb
`windows-949^lb

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-miscellaneous-encodings">旧来の諸々の符号化法</a>
◎
Legacy miscellaneous encodings
<tr><td>`replacement$n
<td>`csiso2022kr^lb
`hz-gb-2312^lb
`iso-2022-cn^lb
`iso-2022-cn-ext^lb
`iso-2022-kr^lb
`replacement^lb
<tr><td>`UTF-16BE$n
<td>`unicodefffe^lb
`utf-16be^lb
<tr><td>`UTF-16LE$n
<td>`csunicode^lb
`iso-10646-ucs-2^lb
`ucs-2^lb
`unicode^lb
`unicodefeff^lb
`utf-16^lb
`utf-16le^lb
<tr><td>`x-user-defined$n
<td>`x-user-defined^lb
</table>

<p class="note">注記：
すべての`符号化法$とそれら用の`~label$は、
規範的でない資源
`indexes.json$
からも入手できる。
◎
All encodings and their labels are also available as non-normative encodings.json resource.
</p>

<p class="note" id="supported-encodings">注記：
~supportされる`符号化法$の集合は、
首に，［
この標準の開発を開始した時点で，主要な各種~browser~engineが~supportしていた集合
］の交差集合に基づくが、［
稀にしか正当に利用されていない, かつ攻撃にも利用され得る符号化法
］は除去してある。
一部の符号化法については、
既存の~Web内容が利用している~~確たる証拠はなく，それを含めることには疑問がある。
すなわち、
各種~browserは それらを広く~supportしてきたが，~Web内容から広く利用されているかどうかは不明瞭である。
しかしながら，`単-~byte符号化法$のうち［
各種~browserが広く~supportしていたもの／
ISO 8859 ~~族の一部を成すもの
］を意欲的に除去する労は、
為されていない。
特に，次に挙げるものを含める必要性は、
既存の内容を~supportする目的においては疑わしいが，除去する計画は無い
⇒＃
`IBM866$n,
`macintosh$n,
`x-mac-cyrillic$n,
`ISO-8859-3$n,
`ISO-8859-10$n,
`ISO-8859-14$n,
`ISO-8859-16$n
◎
The set of supported encodings is primarily based on the intersection of the sets supported by major browser engines when the development of this standard started, while removing encodings that were rarely used legitimately but that could be used in attacks. The inclusion of some encodings is questionable in the light of anecdotal evidence of the level of use by existing Web content. That is, while they have been broadly supported by browsers, it is unclear if they are broadly used by Web content. However, an effort has not been made to eagerly remove single-byte encodings that were broadly supported by browsers or are part of the ISO 8859 series. In particular, the necessity of the inclusion of IBM866, macintosh, x-mac-cyrillic, ISO-8859-3, ISO-8859-10, ISO-8859-14, and ISO-8859-16 is doubtful for the purpose of supporting existing content, but there are no plans to remove these.
</p>

		</section>
		<section id="output-encodings">
<h3 title="Output encodings">4.3. 出力~符号化法</h3>

<div class="algo">
<p>
`符号化法から出力~符号化法を取得する@
ときは、
所与の
( `符号化法$ %符号化法 )
に対し，次を走らす：
◎
To get an output encoding from an encoding encoding, run these steps:
</p>
<ol>
	<li>
~IF［
%符号化法 ~IN
{ `replacement$n, `UTF-16BE$n, `UTF-16LE$n【！`UTF-16BE/LE$n】 }
］
⇒
~RET `UTF-8$n
◎
If encoding is replacement or UTF-16BE/LE, then return UTF-8.
</li>
	<li>
~RET %符号化法
◎
Return encoding.
</li>
</ol>

<p class="note">注記：
この~algoは、
それを必要とする［
~URL構文解析 ／ ~HTML~form提出
］にて有用になる。
◎
The get an output encoding algorithm is useful for URL parsing and HTML form submission, which both need exactly this.
</p>
</div>

		</section>
	</section>
	<section id="indexes">
<h2 title="Indexes">5. 索引</h2>

<p>
ほとんどの旧来の`符号化法$では、
【当の符号化法に特有な】
`索引@
が利用される。
`索引$とは、
一連の~entryからなる有順序~listであり，それを成す各~entryは［
~pointerと, それに対応する~cp
］からなる組である。
`索引$の中では、
~pointerは一意であり，~cpは重複し得る。
◎
Most legacy encodings make use of an index. An index is an ordered list of entries, each entry consisting of a pointer and a corresponding code point. Within an index pointers are unique and code points can be duplicated.
</p>

<p class="note">注記：
効率的な実装は、
各`符号化法$に対し，
2 つの`索引$
— その`復号器$に最適化されたそれ, その`符号化器$に最適化されたそれ —
を備えることになろう。
◎
An efficient implementation likely has two indexes per encoding. One optimized for its decoder and one for its encoder.
</p>

<div class="algo">
<p>
`索引$
【の~dataを供する資源（以下を見よ）】
から，~pointerとそれに対応する~cpを見出すためには：
</p>
<ol>
	<li>
まず、
%行l~list をその資源の内容を `000A^U で一連の “行l” に分割した結果とする。
</li>
	<li>
%行l~list から［
空~行l ／ `0023^U で開始される行l
］をすべて除去する。
</li>
	<li>
<p>
%行l~list の各~行lに対し，行lを `0009^U で分割したときの：
</p>

<ul ><li>1 個目の~itemが~pointer（ 10 進表記）を与える。
</li><li>2 個目の~itemが対応する~cp（ 16 進表記）を与える。
</li><li>他の~itemは関連しない。
</li></ul>
	</li>
</ol>

◎
To find the pointers and their corresponding code points in an index, let lines be the result of splitting the resource’s contents on U+000A. Then remove each item in lines that is the empty string or starts with U+0023. Then the pointers and their corresponding code points are found by splitting each item in lines on U+0009. The first subitem is the pointer (as a decimal number) and the second is the corresponding code point (as a hexadecimal number). Other subitems are not relevant.
</div>

<p class="note">注記：
各`索引$の冒頭には、
変更の有無を記すため，
`Identifier^i と `Date^i
【識別子と日付】
が記されている。
`Identifier^i の変化は、
`索引$に変更が加えられたことを表す。
◎
To signify changes an index includes an Identifier and a Date. If an Identifier has changed, so has the index.
</p>

<p>
%索引 の中で %~pointer が指す
`索引~cp@
とは、
%索引 内に %~pointer が［
在るならば，それに対応する~cp ／
無いならば ~NULL
］である。
◎
The index code point for pointer in index is the code point corresponding to pointer in index, or null if pointer is not in index.
</p>

<p>
%索引 の中で %~cp を指す
`索引~pointer@
とは、
%索引 内に %~cp に対応する~pointerが［
在るならば，それらのうち`最初の^em ~pointer ／
無いならば ~NULL
］である。
◎
The index pointer for code point in index is the first pointer corresponding to code point in index, or null if code point is not in index.
</p>

<div class="note" id="visualization">
<p>注記：
各 索引には，規範的でない視覚-化があり、
`索引~jis0208$には， `Shift_JIS$n 視覚-化も別にある。
加えて，基本多言語面（
BMP（ `Basic Multilingual Plane^en ）,
`0000^U 〜 `FFFF^U
）における被覆域の視覚-化もある。
ただし、［
`索引~gb18030範囲集$ ／ `索引~ISO-2022-JP~katakana$
］には，これらの視覚-化はない。
◎
There is a non-normative visualization for each index other than index gb18030 ranges and index ISO-2022-JP katakana. index jis0208 also has an alternative Shift_JIS visualization. Additionally, there is visualization of the Basic Multilingual Plane coverage of each index other than index gb18030 ranges and index ISO-2022-JP katakana.
</p>

<table>
<caption>
視覚-化における凡例
◎
The legend for the visualizations is:
</caption>
<thead>
<tr><th>表示
<th>~~説明

<tbody class="_vis-visualizationlegend">
<tr><td><div class="_vis-unmapped"></div><td>
対応する~cpは無い。
◎
Unmapped

<tr><td><div class="_vis-mid"></div><td>
~UTF-8で 2 ~byte。
◎
Two bytes in UTF-8

<tr><td><div class="_vis-mid _vis-contiguous"></div><td>
~UTF-8で 2 ~byte, かつ
~cpは、
前の~pointerの~cpの直後に続く。
◎
Two bytes in UTF-8, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-upper"></div><td>
~UTF-8で 3 ~byte（私用領域でない）
◎
Three bytes in UTF-8 (non-PUA)

<tr><td><div class="_vis-upper _vis-contiguous"></div><td>
~UTF-8で 3 ~byte（私用領域でない）, かつ
~cpは、
前の~pointerの~cpの直後に続く。
◎
Three bytes in UTF-8 (non-PUA), code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-pua"></div><td>
私用領域
◎
Private Use

<tr><td><div class="_vis-pua _vis-contiguous"></div><td>
私用領域, かつ
~cpは、
前の~pointerの~cpの直後に続く。
◎
Private Use, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-astral"></div><td>
~UTF-8で 4 ~byte
◎
Four bytes in UTF-8

<tr><td><div class="_vis-astral _vis-contiguous"></div><td>
~UTF-8で 4 ~byte, かつ
~cpは、
前の~pointerの~cpの直後に続く。
◎
Four bytes in UTF-8, code point follows immediately the code point
of previous pointer

<tr><td><div class="_vis-duplicate"></div><td>
先に現れているものと重複する~cpに対応する。
◎
Duplicate code point already mapped at an earlier index

<tr><td><div class="_vis-compatibility"></div><td>
~CJK互換漢字（ `CJK Compatibility Ideograph^en ）
◎
CJK Compatibility Ideograph

<tr><td><div class="_vis-ext"></div><td>
~CJK統合漢字拡張 A
◎
CJK Unified Ideographs Extension A
</table>

</div>

<p>
この仕様が定義する`索引$のうち，`単-~byte索引$でないものには、
それぞれに自前の~tableがあり，以下に与えられる：
【視覚-化／被覆域の~tableは巨大なことに注意】
◎
These are the indexes defined by this specification, excluding index single-byte, which have their own table:
</p>

<table id="_index_list" class="grid-table"><thead>
<tr><th>`名前$
<th>`索引$
<th>視覚-化
<th>基本多言語面（ BMP ）の被覆域
<th>備考
<tbody>

<tr><td>`索引~Big5@
<td>`Big5$idx
<td>
これは、
香港増補字符集（ `Hong Kong Supplementary Character Set^en ）, および他の共通な拡張と一式で、
~Big5標準に合致する。
◎
This matches the Big5 standard in combination with the Hong Kong Supplementary Character Set and other common extensions.

<tr><td>`索引~EUC-KR@
<td>`EUC-KR$idx
<td>
これは、
KS X 1001 標準と~~統合~Hangul~code（ `Unified Hangul Code^en ）に合致する。
Windows Codepage 949 としても共通的に知られている。
これ全体で、
~Unicodeの~Hangul音節文字（ `Hangul Syllables^en ）~blockを覆う。
~Hangul~blockのうち，視覚-化における左上隅が~pointer 9026 にあるもの
【？】
は、
~Unicode順に並ぶ。
`Taken separately^en 【？】,
この索引における残りの~Hangul音節文字も、
~Unicode順に並ぶ。
◎
This matches the KS X 1001 standard and the Unified Hangul Code, more commonly known together as Windows Codepage 949. It covers the Hangul Syllables block of Unicode in its entirety. The Hangul block whose top left corner in the visualization is at pointer 9026 is in the Unicode order. Taken separately, the rest of the Hangul syllables in this index are in the Unicode order, too.

<tr><td>`索引~gb18030@
<td>`gb18030$idx
<td>
これは、
各~cpが 2 ~byteに符号化される GB18030-2005 標準に合致する
— ただし，配備-済みな内容と互換になるよう、
`A3^X `A0^X は `3000^U に対応付けられる。
この索引~全体で、
~Unicodeの~CJK統合漢字（ `CJK Unified Ideographs^en ）~blockを覆う。
その~block内の~entryのうち，視覚-化における（最初の） `3000^U より上または左にあるものは、
~Unicode順に並ぶ。
◎
This matches the GB18030-2005 standard for code points encoded as two bytes, except for 0xA3 0xA0 which maps to U+3000 to be compatible with deployed content. This index covers the CJK Unified Ideographs block of Unicode in its entirety. Entries from that block that are above or to the left of (the first) U+3000 in the visualization are in the Unicode order.

<tr><td>`索引~gb18030範囲集@
<td>`gb18030-ranges$idx
<td>
この`索引$は、
すべての~cpを挙げていくと項目数が 100 万を超えてしまう点で，他のすべてと異なる（ 207 面の範囲と自明な範囲検査により，きれいに表現できるが）。
したがって、
4 ~byte に符号化される~cpについてのみ，見かけ上 GB18030-2005 標準に合致する。
下の［
`索引~gb18030範囲集~cp$ ／
`索引~gb18030範囲集~pointer$
］も見よ。
◎
This index works different from all others. Listing all code points would result in over a million items whereas they can be represented neatly in 207 ranges combined with trivial limit checks. It therefore only superficially matches the GB18030-2005 standard for code points encoded as four bytes. See also index gb18030 ranges code point and index gb18030 ranges pointer below.

<tr><td>`索引~jis0208@
<td>`jis0208$idx
<td>
IBM と NEC によるかつての~proprietary拡張も含まれている， JIS X 0208 標準。
◎
This is the JIS X 0208 standard including formerly proprietary extensions from IBM and NEC.

<tr><td>`索引~jis0212@
<td>`jis0212$idx
<td>
JIS X 0212 標準。
これを利用するのは、
`~EUC-JP復号器$に限られる（符号化器からは利用されない）
— 広く~supportされていないので。
◎
This is the JIS X 0212 standard. It is only used by the EUC-JP decoder due to lack of widespread support elsewhere.

<tr><td>`索引~ISO-2022-JP~katakana@
<td>`iso-2022-jp-katakana$idx
<td>
これは、
~Unicode正規化~形（ `Normalization Form^en ） KC に従って，半角~katakanaを全角~katakanaに対応付ける。
ただし、［
`FF9E^U ／ `FF9F^U
］は［
`309B^U ／ `309C^U
］に対応付ける
— ［
`3099^U ／ `309A^U
］ではなく
【これらはいずれも、濁点／半濁点】
。
これを利用するのは、
`~ISO-2022-JP符号化器$に限られる。
`UNICODE$r
◎
This maps halfwidth to fullwidth katakana as per Unicode Normalization Form KC, except that U+FF9E and U+FF9F map to U+309B and U+309C rather than U+3099 and U+309A. It is only used by the ISO-2022-JP encoder. [UNICODE]
</table>

<div class="algo">
<p>
%~pointer が指す
`索引~gb18030範囲集~cp@
は、
次の手続きが返す~cpである：
◎
The index gb18030 ranges code point for pointer is the return value of these steps:
</p>
<ol>
	<li>
~IF［
39419 ~LT %~pointer ~LT 189000
］~OR［
1237575 ~LT %~pointer
］
⇒
~RET ~NULL
◎
If pointer is greater than 39419 and less than 189000, or pointer is greater than 1237575, return null.
</li>
	<li>
~IF［
%~pointer ~EQ 7457
］
⇒
~RET ~cp `E7C7^U
◎
If pointer is 7457, return code point U+E7C7.
</li>
	<li>
%~offset ~LET `索引~gb18030範囲集$の中で %~pointer を超えない最後の~pointer
◎
Let offset be the last pointer in index gb18030 ranges that is less than or equal to pointer and let code point offset be its corresponding code point.
</li>
	<li>
%~cp~offset ~LET %~offset が指している~cp
◎
↑</li>
	<li>
~RET 値が［
%~cp~offset ~PLUS %~pointer ~MINUS %~offset
］なる~cp
◎
Return a code point whose value is code point offset + pointer − offset.
</li>
</ol>
</div>

<div class="algo">
<p>
%~cp を指す
`索引~gb18030範囲集~pointer@
は、
次の手続きが返す~pointerである：
◎
The index gb18030 ranges pointer for code point is the return value of these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `E7C7^U
］
⇒
~RET ~pointer 7457
◎
If code point is U+E7C7, return pointer 7457.
</li>
	<li>
%~offset ~LET `索引~gb18030範囲集$の中で %~cp を超えない最後の~cp
◎
Let offset be the last code point in index gb18030 ranges that is less than or equal to code point and let pointer offset be its corresponding pointer.
</li>
	<li>
%~pointer~offset ~LET %~offset に対応する~pointer
◎
↑</li>
	<li>
~RET 値が［
%~pointer~offset ~PLUS %~cp ~MINUS %~offset
］なる~pointer
◎
Return a pointer whose value is pointer offset + code point − offset.
</li>
</ol>
</div>

<div class="algo">
<p>
%~cp を指す
`索引~Shift_JIS~pointer@
は、
次の手続きが返す~pointerである：
◎
The index Shift_JIS pointer for code point is the return value of these steps:
</p>
<ol>
	<li>
<p>
%索引 ~LET `索引~jis0208$ から［
~pointerが範囲 { 8272 〜 8835 } に入る~entry
］すべてを除外した索引
◎
Let index be index jis0208 excluding all entries whose pointer is in the range 8272 to 8835, inclusive.
</p>

<p class="note">注記：
`索引~jis0208$は、
重複する~cpを包含するので、
これらの~entryの除外により，後続の~cpが利用されるようになる。
◎
The index jis0208 contains duplicate code points so the exclusion of these entries causes later code points to be used.
</p>
	</li>
	<li>
~RET %索引 の中で %~cp を指す`索引~pointer$
◎
Return the index pointer for code point in index.
</li>
</ol>
</div>

<div class="algo">
<p>
%~cp を指す
`索引~Big5~pointer@
は、
次の手続きが返す~pointerである：
◎
The index Big5 pointer for code point is the return value of these steps:
</p>
<ol>
	<li>
<p>
%索引 ~LET `索引~Big5$から［
~pointerが ( (`A1^X ~MINUS `81^X) ~MUL 157 ) 未満の~entry
］すべてを除外した索引
◎
Let index be index Big5 excluding all entries whose pointer is less than (0xA1 - 0x81) × 157.
</p>

<p class="note">注記：
香港増補字符集（ `Hong Kong Supplementary Character Set^en ）拡張を~literalとして返さないようにする。
◎
Avoid returning Hong Kong Supplementary Character Set extensions literally.
</p>
	</li>
	<li>
<p>
~IF［
%~cp ~IN
{ `2550^U, `255E^U, `2561^U, `256A^U, `5341^U, `5345^U }
］
⇒
~RET
%索引 の中で %~cp に対応する`最後の^em ~pointer
◎
If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345, return the last pointer corresponding to code point in index.
</p>

<p class="note">注記：
他にも重複している~cpはあるが、
それら用には，`最初の^em ~pointerが利用されることになる。
◎
There are other duplicate code points, but for those the first pointer is to be used.
</p>
	</li>
	<li>
~RET
%索引 の中で %~cp を指す`索引~pointer$
◎
Return the index pointer for code point in index.
</li>
</ol>
</div>

<hr>

<p class="note">注記：
すべての`索引$は、
規範的でない資源
`indexes.json$
からも入手できる
（`索引~gb18030範囲集$の形式は、
範囲を表現できるようにするため，少し異なるものにされている）。
◎
All indexes are also available as a non-normative indexes.json resource. (Index gb18030 ranges has a slightly different format here, to be able to represent ranges.)
</p>

	</section>
	<section id="specification-hooks">
<h2 title="Hooks for standards">6. 他の標準~用の~hook</h2>

<div class="note">

<p>注記：
次に挙げる各種~algo（以下に定義される）は、
他の仕様からの~~利用が意図されている：
◎
The algorithms defined below (UTF-8 decode, UTF-8 decode without BOM, UTF-8 decode without BOM or fail, and UTF-8 encode) are intended for usage by other standards.
</p>

<ul>
	<li>
`~UTF-8復号する$
⇒
新たな形式は、
復号するときは，これを利用すること（次項は別として）。
◎
For decoding, UTF-8 decode is to be used by new formats.＼
</li>
	<li>
`~BOMはそのままに~UTF-8復号する$／
`~BOMも失敗-もそのままに~UTF-8復号する$
⇒
形式や~protocolの中の識別子や~byte列~用には、
これらを利用すること。
◎
For identifiers or byte sequences within a format or protocol, use UTF-8 decode without BOM or UTF-8 decode without BOM or fail.
</li>
	<li>
`~UTF-8符号化する$
⇒
符号化するときは、
これを利用すること。
◎
For encoding, UTF-8 encode is to be used.
</li>
</ul>

<p>
各~標準は、
`~UTF-8符号化する$（および，旧来の`符号化法を利用して符号化する$）~algoに渡す［
入力~用の`入出力~queue$†
］が，実質的には`~scalar値$が成す入出力~queueである
— すなわち`~surrogate$は包含しない —
ことを確保すること。
◎
Standards are to ensure that the input I/O queues they pass to UTF-8 encode (as well as the legacy encode) are effectively I/O queues of scalar values, i.e., they contain no surrogates.
</p>

<p>
これらの~hook
（および，`~Unicodeに復号する$, `符号化法を利用して符号化する$）は、［
入力~用の入出力~queue†
］の全体が消費されるまで~call元を阻む。
各~出力~tokenを，~streamの中に~pushされるたびに利用するためには、
~call元は，［
当の~hookを呼出すときに，空な［
出力~用の入出力~queue††
］を伴わせて、
そこから`並列的$に読取る
］こと。
`~BOMも失敗-もそのままに~UTF-8復号する$を利用するときには，少し~careが必要になることに注意
— 復号している間に~errorが見出された場合、
`~EoQ$は，［
出力~用の入出力~queue
］の中へ~pushされなくなるので。
【† 各~algoにおける %入出力~queue 引数／†† %出力 引数】
◎
These hooks (as well as decode and encode) will block until the input I/O queue has been consumed in its entirety. In order to use the output tokens as they are pushed into the stream, callers are to invoke the hooks with an empty output I/O queue and read from it in parallel. Note that some care is needed when using UTF-8 decode without BOM or fail, as any error found during decoding will prevent the end-of-queue item from ever being pushed into the output I/O queue.
</p>
</div>

<div class="algo">
<p>
`~UTF-8復号する@
ときは、
所与の
( `入出力~queue$`~byte^tA %入出力~queue, `入出力~queue$`~scalar値^tA %出力（省略時は « » ）)
に対し，次を走らす：
◎
To UTF-8 decode an I/O queue of bytes ioQueue given an optional I/O queue of scalar values output (default « »), run these steps:
</p>
<ol>
	<li>
%~buffer ~LET `入出力~queueを覗見る$( %入出力~queue, 3 )
◎
Let buffer be the result of peeking three bytes from ioQueue,＼
↓converted to a byte sequence.
</li>
	<li>
~IF［
( %~buffer[0], %~buffer[1], %~buffer[2] ) ~EQ ( `EF^X, `BB^X, `BF^X )
］
⇒
`入出力~queueから~itemを読取る$( %入出力~queue, 3 )
（結果は利用しない。）
◎
If buffer is 0xEF 0xBB 0xBF, then read three bytes from ioQueue. (Do nothing with those bytes.)
</li>
	<li>
%復号器 ~LET `UTF-8$n の`復号器$の新たな~instance
◎
↓</li>
	<li>
`~queueを処理する$( %復号器, %入出力~queue, %出力, `replacement^l )
◎
Process a queue with an instance of UTF-8’s decoder, ioQueue, output, and "replacement".
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~BOMはそのままに~UTF-8復号する@
ときは、
所与の
( `入出力~queue$`~byte^tA %入出力~queue, `入出力~queue$`~scalar値^tA %出力（省略時は « » ）)
に対し，次を走らす：
◎
To UTF-8 decode without BOM an I/O queue of bytes ioQueue given an optional I/O queue of scalar values output (default « »), run these steps:
</p>
<ol>
	<li>
%復号器 ~LET `UTF-8$n の`復号器$の新たな~instance
◎
↓</li>
	<li>
`~queueを処理する$( %復号器, %入出力~queue, %出力, `replacement^l )
◎
Process a queue with an instance of UTF-8’s decoder, ioQueue, output, and "replacement".
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~BOMも失敗-もそのままに~UTF-8復号する@
ときは、
所与の
( `入出力~queue$`~byte^tA %入出力~queue, `入出力~queue$`~scalar値^tA %出力（省略時は « » ）)
に対し，次を走らす：
◎
To UTF-8 decode without BOM or fail an I/O queue of bytes ioQueue given an optional I/O queue of scalar values output (default « »), run these steps:
</p>
<ol>
	<li>
%復号器 ~LET `UTF-8$n の`復号器$の新たな~instance
◎
↓</li>
	<li>
%~errorになり得る ~LET `~queueを処理する$( %復号器, %入出力~queue, %出力, `fatal^l )
◎
Let potentialError be the result of processing a queue with an instance of UTF-8’s decoder, ioQueue, output, and "fatal".
</li>
	<li>
~IF［
%~errorになり得る ~EQ `~error$i
］
⇒
~RET `失敗^i
◎
If potentialError is an error, then return failure.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~UTF-8符号化する@
ときは、
所与の
( `入出力~queue$`~scalar値^tA %入出力~queue, `入出力~queue$`~byte^tA %出力（省略時は « » ）)
に対し，次を走らす
⇒
~RET `符号化法を利用して符号化する$( %入出力~queue, `UTF-8$n, %出力 )
◎
To UTF-8 encode an I/O queue of scalar values ioQueue given an optional I/O queue of bytes output (default « »), return the result of encoding ioQueue with encoding UTF-8 and output.
</p>
</div>

		<section id="legacy-hooks">
<h3 title="Legacy hooks for standards">6.1. 各~標準~用の旧来の~hook</h3>

<div class="note">
<p>注記：
各~標準は、
互換性を得るために必要な場合を除き，次に挙げる~algoを利用しないことが強く奨励される
⇒＃
`~Unicodeに復号する$／
`~BOMを~sniffする$／
`符号化法を利用して符号化する$
◎
Standards are strongly discouraged from using decode, BOM sniff, and encode, except as needed for compatibility.＼
</p>

<p>
これらの旧来の~hookを必要としている標準は、
次の利用も必要になると見込まれる
⇒＃
`~labelから符号化法を取得する$（~labelを`符号化法$に転換するため）／
`符号化法から出力~符号化法を取得する$（`符号化法$を別の`符号化法$ — `符号化法を利用して符号化する$ときに渡すそれに相応しいもの — に転換するため）
◎
Standards needing these legacy hooks will most likely also need to use get an encoding (to turn a label into an encoding) and get an output encoding (to turn an encoding into another encoding that is suitable to pass into encode).
</p>

<p>
［
~URL~percent-符号化法の極めて~~限定的な事例
］用に，符号化器~errorに対する~customな取扱いが必要になる。
［
`符号化器を取得する$／`符号化するか失敗する$
］~algoは、
そのために利用される。
他の~algoは、
直に利用されないことになる。
◎
For the extremely niche case of URL percent-encoding, custom encoder error handling is needed. The get an encoder and encode or fail algorithms are to be used for that. Other algorithms are not to be used directly.
</p>
</div>

<div class="algo">
<p>
`~Unicodeに復号する@
ときは、
所与の
( `入出力~queue$`~byte^tA %入出力~queue, ~fallback符号化法 %符号化法, `入出力~queue$`~scalar値^tA %出力（省略時は « » ）)
に対し，次を走らす：
◎
To decode an I/O queue of bytes ioQueue given a fallback encoding encoding and an optional I/O queue of scalar values output (default « »), run these steps:
</p>
<ol>
	<li>
%~BOM符号化法 ~LET `~BOMを~sniffする$( %入出力~queue )
◎
Let BOMEncoding be the result of BOM sniffing ioQueue.
</li>
	<li>
<p>
~IF［
%~BOM符号化法 ~NEQ ~NULL
］：
◎
If BOMEncoding is non-null:
</p>
		<ol>
			<li>
%符号化法 ~SET %~BOM符号化法
◎
Set encoding to BOMEncoding.
</li>
			<li>
%N ~LET ［
%~BOM符号化法 ~EQ `UTF-8$n ならば 3 ／
~ELSE_ 2
］
◎
↓</li>
			<li>
`入出力~queueから~itemを読取る$( %入出力~queue, %N )
◎
Read three bytes from ioQueue, if BOMEncoding is UTF-8; otherwise read two bytes. (Do nothing with those bytes.)
</li>
		</ol>

<p class="note">注記：
配備-済みな内容との互換性を得るため、
~BOMは他より~~優先される。
HTTP が利用される文脈においては、
これは，
`<code class="header">Content-Type</code>`
~headerの意味論に対する違反である。
◎
For compatibility with deployed content, the byte order mark is more authoritative than anything else. In a context where HTTP is used this is in violation of the semantics of the `Content-Type` header.
</p>
	</li>
	<li>
%復号器 ~LET %符号化法 の`復号器$の新たな~instance
◎
↓</li>
	<li>
`~queueを処理する$( %復号器, %入出力~queue, %出力, `replacement^l )
◎
Process a queue with an instance of encoding’s decoder, ioQueue, output, and "replacement".
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~BOMを~sniffする@
ときは、
所与の
( `入出力~queue$`~byte^tA %入出力~queue )
に対し，次を走らす：
◎
To BOM sniff an I/O queue of bytes ioQueue, run these steps:
</p>
<ol>
	<li>
%~BOM ~LET 次の結果を~byte列に変換した結果
⇒
`入出力~queueを覗見る$( %入出力~queue, 3 )
◎
Let BOM be the result of peeking 3 bytes from ioQueue, converted to a byte sequence.
</li>
	<li>
<p>
下の表~内の
~EACH( %行 )
に対し，挙げられた順に
⇒
~IF［
%~BOM は %行 の 1 列目に与える~byte列`から開始して$byteいる
］
⇒
~RET %行 の 2 列目に与える`符号化法$
◎
For each of the rows in the table below, starting with the first one and going down, if BOM starts with the bytes given in the first column, then return the encoding given in the cell in the second column of that row. Otherwise, return null.
</p>

<div>
<table><thead>
<tr>
<th>~BOM
<th>符号化法
<tbody>

<tr><td>`EF^X `BB^X `BF^X
<td>`UTF-8$n

<tr><td>`FE^X `FF^X
<td>`UTF-16BE$n

<tr><td>`FF^X `FE^X
<td>`UTF-16LE$n
</table>

◎
Byte order mark｜Encoding
0xEF 0xBB 0xBF｜UTF-8
0xFE 0xFF｜UTF-16BE
0xFF 0xFE｜UTF-16LE
</div>

	</li>
	<li>
~RET ~NULL
◎
↑</li>
</ol>

<p class="note">注記：
`~Unicodeに復号する$~algoには、［
~BOMが見出されたので、
供された符号化法は利用していないこと
］を~call元に通信する仕方が無い。
この~hookは、
その事への対処法であり，`~Unicodeに復号する$前に呼出されることになる†。
それは、［
~BOMが見出されたなら それに対応する符号化法 ／
~ELSE_ ~NULL
］を返す。
【†特に，~HTMLの構文解析~algoは、入力~streamを~Unicodeに復号する前に，`符号化法を~sniffする~algo$にて これを呼出す。】
◎
This hook is a workaround for the fact that decode has no way to communicate back to the caller that it has found a byte order mark and is therefore not using the provided encoding. The hook is to be invoked before decode, and it will return an encoding corresponding to the byte order mark found, or null otherwise.
</p>
</div>

<hr>

<div class="algo">
<p>
`符号化法を利用して符号化する@
ときは、
所与の
(
`入出力~queue$`~scalar値^tA %入出力~queue,
`符号化法$ %符号化法,
`入出力~queue$`~byte^tA %出力（省略時は « » ）
)
に対し，次を走らす：
◎
To encode an I/O queue of scalar values ioQueue given an encoding encoding and an optional I/O queue of bytes output (default « »), run these steps:
</p>
<ol>
	<li>
%符号化器 ~LET `符号化器を取得する$( %符号化法 )
◎
Let encoder be the result of getting an encoder from encoding.
</li>
	<li>
`~queueを処理する$( %符号化器, %入出力~queue, %出力, `html^l )
◎
Process a queue with encoder, ioQueue, output, and "html".
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
これは、
~HTML~form用の旧来の~hookである。
`~UTF-8符号化する$を被せた方が、
決して `~error$i を誘発しないので安全である。
`URL$r
◎
This is a legacy hook for HTML forms. Layering UTF-8 encode on top is safe as it never triggers errors. [HTML]
</p>
</div>

<hr>

<div class="algo">
<p>
`符号化器を取得する@
ときは、
所与の
( `符号化法$ %符号化法 )
に対し：
◎
To get an encoder from an encoding encoding:
</p>
<ol>
	<li>
~Assert：
%符号化法 ~NIN { `replacement$n, `UTF-16BE$n, `UTF-16LE$n【！`UTF-16BE/LE$n】 }
◎
Assert: encoding is not replacement or UTF-16BE/LE.
</li>
	<li>
~RET %符号化法 の`符号化器$の~instance
◎
Return an instance of encoding’s encoder.
</li>
</ol>
</div>

<div class="algo">
<p>
`符号化するか失敗する@
ときは、
所与の
( `入出力~queue$`~scalar値^tA %入出力~queue, `符号化器$の~instance %符号化器 , `入出力~queue$`~byte^tA %出力 )
に対し，次の手続きを走らす：
◎
To encode or fail an I/O queue of scalar values ioQueue given an encoder instance encoder and an I/O queue of bytes output, run these steps:
</p>
<ol>
	<li>
%~errorになり得る ~LET `~queueを処理する$( %符号化器, %入出力~queue, %出力, `fatal^l )
◎
Let potentialError be the result of processing a queue with encoder, ioQueue, output, and "fatal".
</li>
	<li>
`入出力~queueに~pushする$( %出力, « `~EoQ$ » )
◎
Push end-of-queue to output.
</li>
	<li>
~IF［
%~errorになり得る は `~error$i である
］
⇒
~RET `~error$i の`~cp$の`値$cp
◎
If potentialError is an error, then return error’s code point’s value.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

<div class="note" id="pit-of-iso-2022-jp">

<p>注記：
これは、
~URL~percent-符号化法 `URL$r
用の旧来の~hookである。
~call元は、
`符号化器$の~instanceを生きたまま保つ必要がある
— `~ISO-2022-JP符号化器$が `~error$i を返すときに とり得る状態は、
2 つあるので。
それはまた，~call元が［
~errorを何らかの仕方で符号化するような~byte列
］を発する場合、
それらの各~byteは，
範囲 { `00^X 〜 `7F^X } に入る, かつ［
`0E^X, `0F^X, `1B^X, `5C^X, `7E^X
］以外にする必要があることを意味する。
◎
This is a legacy hook for URL percent-encoding. The caller will have to keep an encoder instance alive as the ISO-2022-JP encoder can be in two different states when returning an error. That also means that if the caller emits bytes to encode the error in some way, these have to be in the range 0x00 to 0x7F, inclusive, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E. [URL]
</p>

<p>
特に，`~ISO-2022-JP符号化器$が `Roman$i 状態にある下で `~error$i を返す場合、
~call元は，
`5C^X `\^smb を出力し得ない
— それは、
`005C^U `\^smb として復号されなくなるので。
この理由から，`符号化するか失敗する$を意図されない目的に利用している応用
— `005C^U `\^smb を置換~構文【~escape法】（例： `\u2603^c ）の一部として利用している，~JSや~CSSなど —
は、
次のいずれかで~~対処すること
⇒＃
`~ISO-2022-JP符号化器$を そのような置換~schemeと併用しないよう，~careする／
置換~構文が，符号化器を必ず通過するようにする（~URL~percent-符号化法とは対照的に）
◎
In particular, if upon returning an error the ISO-2022-JP encoder is in the Roman state, the caller cannot output 0x5C (\) as it will not decode as U+005C (\). For this reason, applications using encode or fail for unintended purposes ought to take care to prevent the use of the ISO-2022-JP encoder in combination with replacement schemes, such as those of JavaScript and CSS, that use U+005C (\) as part of the replacement syntax (e.g., \u2603) or make sure to pass the replacement syntax through the encoder (in contrast to URL percent-encoding).
</p>

<p>
返り値は、［
`~error$i が生じなければ ~NULL ／
~ELSE_ 符号化し得ない`~cp$を表現している数値
］になる。
数値が返された場合，~call元は、［
同じ`符号化器$の~instance, 新たな出力~用の`入出力~queue$
］を給して，再び呼出す必要があることになる。
◎
The return value is either the number representing the code point that could not be encoded or null, if there was no error. When it returns non-null the caller will have to invoke it again, supplying the same encoder instance and a new output I/O queue.
</p>
</div>
</div>

		</section>
	</section>
	<section id="api">
<h2 title="API">7. ~API</h2>

<p>
この節では Web IDL `WEBIDL$r の各種用語を利用する。
~browser~UAは、
この~APIを~supportするモノトスル。
~JS実装は、
この~APIを~supportするベキである。
他の~UA／~programming言語は、
必要に応じて相応しい~API（これではないかもしれない）を利用することが奨励される。
◎
This section uses terminology from Web IDL. Browser user agents must support this API. JavaScript implementations should support this API. Other user agents or programming languages are encouraged to use an API suitable to their needs, which might not be this one. [WEBIDL]
</p>

<div class="example">
<p>
次の例は、
`TextEncoder$I ~objを利用して，文字列の配列を `ArrayBuffer$I に符号化する。
結果は次を内容とする `Uint8Array$I になる：
<span class="block">
先頭が（ `Uint32Array$I としての）文字列の個数，その後は：
<span class="block">
最初の文字列の（ `Uint32Array$I としての）長さ,
`UTF-8$n に符号化されたその文字列~data，<br>
2 番目の文字列の（ `Uint32Array$I としての）長さ,
その文字列~data，<br>
…
</span>
等々と続く。
</span>
◎
The following example uses the TextEncoder object to encode an array of strings into an ArrayBuffer. The result is a Uint8Array containing the number of strings (as a Uint32Array), followed by the length of the first string (as a Uint32Array), the UTF-8 encoded string data, the length of the second string (as a Uint32Array), the string data, and so on.
</p>

<pre class="lang-js">
function encodeArrayOfStrings(%strings) {
  var %encoder, %encoded, %len, %bytes, %view, %offset;

  %encoder = new TextEncoder();
  %encoded = [];

  %len = Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %strings.length; %i++) {
    %len += Uint32Array.BYTES_PER_ELEMENT;
    %encoded[%i] = %encoder.encode(%strings[%i]);
    %len += %encoded[%i].byteLength;
  }

  %bytes = new Uint8Array(%len);
  %view = new DataView(%bytes.buffer);
  %offset = 0;

  %view.setUint32(%offset, %strings.length);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %encoded.length; %i += 1) {
    %len = %encoded[%i].byteLength;
    %view.setUint32(%offset, %len);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %bytes.set(%encoded[%i], %offset);
    %offset += %len;
  }
  return %bytes.buffer;
}
</pre>

<p>
次の例は、［［
前の例, または `UTF-8$n 以外の符号化法に等価な~algo
］により生産される形式に符号化された~data
］を含んでいる `ArrayBuffer$I を復号して、
~~元の，一連の文字列からなる配列に戻す。
◎
The following example decodes an ArrayBuffer containing data encoded in the format produced by the previous example, or an equivalent algorithm for encodings other than UTF-8, back into an array of strings.
</p>

<pre class="lang-js">
function decodeArrayOfStrings(%buffer, %encoding) {
  var %decoder, %view, %offset, %num_strings, %strings, %len;

  %decoder = new TextDecoder(%encoding);
  %view = new DataView(%buffer);
  %offset = 0;
  %strings = [];

  %num_strings = %view.getUint32(%offset);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %num_strings; %i++) {
    %len = %view.getUint32(%offset);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %strings[%i] = %decoder.decode(
      new DataView(%view.buffer, %offset, %len));
    %offset += %len;
  }
  return %strings;
}
</pre>
</div>

		<section id="interface-mixin-textdecodercommon">
<h3 title="Interface mixin TextDecoderCommon">7.1. ~interface~mixin `TextDecoderCommon^I</h3>

<pre class="idl">
interface mixin `TextDecoderCommon@I {
  readonly attribute `DOMString$ `encoding$m;
  readonly attribute `boolean$ `fatal$m;
  readonly attribute `boolean$ `ignoreBOM$m;
};
</pre>

<p>
`TextDecoderCommon$I ~interface~mixinは、［
`TextDecoder$I, `TextDecoderStream$I
］~objで共有される共通な取得子を定義する。
これらの各~objには、
次が結付けられる：

◎
The TextDecoderCommon interface mixin defines common getters that are shared between TextDecoder and TextDecoderStream objects. These objects have an associated:
</p>

<dl class="def-list">
	<dt>
`符号化法@dec
◎
encoding
</dt>
	<dd>
`符号化法$。
◎
An encoding.
</dd>

	<dt>
`復号器@dec
◎
decoder
</dt>
	<dd>
`復号器$の~instance。
◎
A decoder instance.
</dd>

	<dt>
`入出力~queue@dec
◎
I/O queue
</dt>
	<dd>
`入出力~queue$`~byte^tA。
◎
An I/O queue of bytes.
</dd>

	<dt>
`~BOMは無視するか@dec
◎
ignore BOM
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
A boolean, initially false.
</dd>

	<dt>
`~BOMを見つけたか@dec
◎
BOM seen
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
A boolean, initially false.
</dd>

	<dt>
`~error~mode@dec
◎
error mode
</dt>
	<dd>
`~error~mode$
— 初期~時は `replacement^l とする。
◎
An error mode, initially "replacement".
</dd>
</dl>

<div class="algo">
<p>
`入出力~queueを直列化する@
~algoは、
所与の
( `TextDecoderCommon$I %復号器, `入出力~queue$`~scalar値^tA %入出力~queue )
に対し，次を走らす：
◎
The serialize I/O queue algorithm, given a TextDecoderCommon decoder and an I/O queue of scalar values ioQueue, runs these steps:
</p>
<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
`入出力~queueから~itemを読取る$( %~item ~LET %入出力~queue )
◎
Let item be the result of reading from ioQueue.
</li>
			<li>
~IF［
%~item ~NEQ `~EoQ$
］
⇒
~RET %出力
◎
If item is end-of-queue, then return output.
</li>
			<li>
<p>
~IF［
%復号器 の`符号化法$dec ~IN { `UTF-8$n, `UTF-16BE$n, `UTF-16LE$n【！`UTF-16BE/LE$n】 }
］~AND［
%復号器 の`~BOMは無視するか$dec ~EQ ~F
］~AND［
%復号器 の`~BOMを見つけたか$dec ~EQ ~F
］：
◎
If decoder’s encoding is UTF-8 or UTF-16BE/LE, and decoder’s ignore BOM and BOM seen are false, then:
</p>
				<ol>
					<li>
%復号器 の`~BOMを見つけたか$dec ~SET ~T
◎
Set decoder’s BOM seen to true.
</li>
					<li>
~IF［
%~item ~EQ `FEFF^U
］
⇒
~CONTINUE
◎
If item is U+FEFF, then continue.
</li>
				</ol>
			</li>
			<li>
%出力 に %~item を付加する
◎
Append item to output.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
この~algoは、
~APIの利用者に もっと制御を与えるため，［
~platformの他所で利用される，`~Unicodeに復号する$ ~algo
］とは、
~BOMの取扱いの点で意図的に異なるものにされている。
◎
This algorithm is intentionally different with respect to BOM handling from the decode algorithm used by the rest of the platform to give API users more control.
</p>
</div>

<hr>

<p class="algo">
`encoding@m
取得子~手続きは
⇒
~RET `~ASCII小文字~化する$( コレの`符号化法$decの`名前$ )
◎
The encoding getter steps are to return this’s encoding’s name, ASCII lowercased.
</p>

<p class="algo">
`fatal@m
取得子~手続きは
⇒
~RET コレの`~error~mode$decに応じて
⇒＃
`fatal^l ならば ~T ／
~ELSE_ ~F
◎
The fatal getter steps are to return true if this’s error mode is "fatal", otherwise false.
</p>

<p class="algo">
`ignoreBOM@m
取得子~手続きは
⇒
~RET コレの`~BOMは無視するか$dec
◎
The ignoreBOM getter steps are to return this’s ignore BOM.
</p>

		</section>
		<section id="interface-textdecoder">
<h3 title="Interface TextDecoder">7.2. ~interface `TextDecoder^I</h3>

<pre class="idl">
dictionary `TextDecoderOptions@I {
  `boolean$ `fatal@mb = false;
  `boolean$ `ignoreBOM@mb = false;
};

dictionary `TextDecodeOptions@I {
  `boolean$ `stream@mb = false;
};

[`Exposed$=*]
interface `TextDecoder@I {
  `TextDecoder$mc(optional `DOMString$ %label = "utf-8", optional `TextDecoderOptions$I %options = {});

  `USVString$ `decode$m(optional `AllowSharedBufferSource$I %input, optional `TextDecodeOptions$I %options = {});
};

`TextDecoder$I includes `TextDecoderCommon$I;
</pre>

<p class="trans-note">【
<a href="Encoding-test.html">利用-中の~browserでこの特能を試す</a>
】</p>

<p>
各 `TextDecoder$I ~objには、
真偽値をとる
`書出さないか@dec
が結付けられ，初期~時は ~F をとるとする。
◎
A TextDecoder object has an associated do not flush, which is a boolean, initially false.
</p>

<dl class="domintro">
	<dt>%decoder = `new TextDecoder$m([%label = "utf-8" [, %options]])</dt>
	<dd>
新たな `TextDecoder$I ~obj を返す。
◎
Returns a new TextDecoder object.
</dd>
	<dd>
%label が次を満たす場合、
`RangeError$E が`投出-$される
⇒
［
~labelでない
］~OR［
`replacement$n 用の~labelである
］
◎
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`符号化法$decの`名前$を小文字~化して返す。
◎
Returns encoding’s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
`~error~mode$decに応じて［
`fatal^l ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if error mode is "fatal", otherwise false.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
`~BOMは無視するか$decの値を返す。
◎
Returns the value of ignore BOM.
</dd>

	<dt>%decoder . `decode([input [, options]])$m</dt>
	<dd>
%input を `符号化法$decの`復号器$にかけた結果を返す。
%input を断片化して処理するときは、
%options の `stream$mb ~memberを ~T にした下で，この~method 0 回~以上~呼出してから， %options を省略して（または その `stream$mb ~memberを ~F にして）
1 回だけ呼出すことで行える。
後者の呼出nに %input もないならば、
両~引数とも省略するのが最も簡明になる。
◎
Returns the result of running encoding’s decoder. The method can be invoked zero or more times with options’s stream set to true, and then once without options’s stream (or set to false), to process a fragmented input. If the invocation without options’s stream (or set to false) has no input, it’s clearest to omit both arguments.
</dd>
	<dd class="example">
<pre class="lang-js">
var %string = "", %decoder = new TextDecoder(%encoding), %buffer;
while(%buffer = next_chunk()) {
  %string += %decoder.decode(%buffer, {stream:true});
}
%string += %decoder.decode(); // ~EoQ
</pre>

	</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l の下で，
`符号化法$decの`復号器$が `~error$i を返した場合、
`TypeError$E が`投出-$される。
◎
If the error mode is "fatal" and encoding’s decoder returns error, throws a TypeError.
</dd>
</dl>

<div class="algo">
<p>
`new TextDecoder(label, options)@m
構築子~手続きは：
◎
The new TextDecoder(label, options) constructor steps are:
</p>
<ol>
	<li>
%符号化法 ~LET `~labelから符号化法を取得する$( %label )
◎
Let encoding be the result of getting an encoding from label.
</li>
	<li>
~IF［
%符号化法 ~IN { `失敗^i, `replacement$n }
］
⇒
~THROW `RangeError$E
◎
If encoding is failure or replacement, then throw a RangeError.
</li>
	<li>
コレの `符号化法$dec ~SET %符号化法
◎
Set this’s encoding to encoding.
</li>
	<li>
~IF［
%options[ "`fatal$mb" ] ~EQ ~T
］
⇒
コレの`~error~mode$dec ~SET `fatal^l
◎
If options["fatal"] is true, then set this’s error mode to "fatal".
</li>
	<li>
コレの `~BOMは無視するか$dec ~SET %options[ "`ignoreBOM$mb" ]
◎
Set this’s ignore BOM to options["ignoreBOM"].
</li>
</ol>
</div>

<div class="algo">
<p>
`decode(input, options)@m
~method~手続きは：
◎
The decode(input, options) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`書出さないか$dec ~EQ ~F
］
⇒＃
コレの`復号器$dec ~SET コレの`符号化法$decの`復号器$の新たな~instance；
コレの`入出力~queue$dec ~SET `入出力~queue$`~byte^tA « `~EoQ$ »；
コレの`~BOMを見つけたか$dec ~SET ~F
◎
If this’s do not flush is false, then set this’s decoder to a new instance of this’s encoding’s decoder, this’s I/O queue to the I/O queue of bytes « end-of-queue », and this’s BOM seen to false.
</li>
	<li>
コレの`書出さないか$dec ~SET %options[ "`stream$mb" ]
◎
Set this’s do not flush to options["stream"].
</li>
	<li>
<p>
~IF［
%input ~NEQ ε
］
⇒
`入出力~queueに~pushする$( コレの`入出力~queue$dec, %input の<a href="~WEBIDL#dfn-get-buffer-source-copy">複製</a> )
◎
If input is given, then push a copy of input to this’s I/O queue.
</p>

<p class="note">注記：
実装には、
この複製を避けるよう実装することが強く奨励される。
そうするときは、
%input が変更されても，後の `decode()$m の~callに影響しないようにする必要がある。
◎
Implementations are strongly encouraged to use an implementation strategy that avoids this copy. When doing so they will have to make sure that changes to input do not affect future calls to decode().
</p>

<p class="warning" id="sharedarraybuffer-warning">
`SharedArrayBuffer^I ~objにより公開される~memoryは、［
実装~用に概して利用される~programming言語
］の~memory~modelに要求される `data race freedom^en な特質を固守しない。
実装するときは、
`SharedArrayBuffer^I ~objが公開する~memoryに~accessするときに適切な便宜性†を利用するよう~careすること。
【†そのような~accessに その種の特質が備わるよう指示する，言語~特有な構文など】
◎
The memory exposed by SharedArrayBuffer objects does not adhere to data race freedom properties required by the memory model of programming languages typically used for implementations. When implementing, take care to use the appropriate facilities when accessing memory exposed by SharedArrayBuffer objects.
</p>
	</li>
	<li>
%出力 ~LET `入出力~queue$`~scalar値^tA « `~EoQ$ »
◎
Let output be the I/O queue of scalar values « end-of-queue ».
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( コレの`入出力~queue$dec )
◎
Let item be the result of reading from this’s I/O queue.
</li>
			<li>
<p>
~IF［
%~item ~EQ `~EoQ$
］~AND［
コレの`書出さないか$dec ~EQ ~T
］
⇒
~RET `入出力~queueを直列化する$( コレ, %出力 )
◎
If item is end-of-queue and this’s do not flush is true, then return the result of running serialize I/O queue with this and output.
</p>

<p class="note">注記：
~streamingでは、［
コレの`書出さないか$dec ~EQ ~T
］のとき，ここで`~EoQ$を取扱うことなく，それを ~F にしない仕方で働く。
この仕方により，コレの`復号器$decは、
後続な呼出nにおいて，この~algoの最初の段で一新されることなく，その状態は保全される。
◎
The way streaming works is to not handle end-of-queue here when this’s do not flush is true and to not set it to false. That way in a subsequent invocation this’s decoder is not set anew in the first step of the algorithm and its state is preserved.
</p>
			</li>
			<li>
%結果 ~LET `~itemを処理する$( %~item, コレの`復号器$dec, コレの`入出力~queue$dec, %出力, コレの`~error~mode$dec )
◎
Otherwise:
◎
Let result be the result of processing an item with item, this’s decoder, this’s I/O queue, output, and this’s error mode.
</li>
			<li>
~IF［
%結果 ~EQ `完遂d$i
］
⇒
~RET `入出力~queueを直列化する$( コレ, %出力 )
◎
If result is finished, then return the result of running serialize I/O queue with this and output.
</li>
			<li>
~IF［
%結果 ~EQ `~error$i
］
⇒
~THROW `TypeError$E
◎
Otherwise, if result is error, throw a TypeError.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="interface-mixin-textencodercommon">
<h3 title="Interface mixin TextEncoderCommon">7.3. ~interface~mixin `TextEncoderCommon^I</h3>

<pre class="idl">
interface mixin `TextEncoderCommon@I {
  readonly attribute `DOMString$ `~encoding0$m;
};
</pre>

<p>
`TextEncoderCommon$I ~interface~mixinは、［
`TextEncoder$I, `TextEncoderStream$I
］~objで共有される共通な取得子を定義する。
◎
The TextEncoderCommon interface mixin defines common getters that are shared between TextEncoder and TextEncoderStream objects.
</p>

<p class="algo">
`~encoding0@m
取得子~手続きは
⇒
~RET `utf-8^l
◎
The encoding getter steps are to return "utf-8".
</p>

		</section>
		<section id="interface-textencoder">
<h3 title="Interface TextEncoder">7.4. ~interface `TextEncoder^I</h3>

<pre class="idl">
dictionary `TextEncoderEncodeIntoResult@I {
  `unsigned long long$ `read@m;
  `unsigned long long$ `written@m;
};

[`Exposed$=*]
interface `TextEncoder@I {
  `TextEncoder$mc();

  [NewObject] `Uint8Array$ `encode$m(optional `USVString$ %input = "");
  `TextEncoderEncodeIntoResult$I `encodeInto$m(`USVString$ %source, [`AllowShared$] `Uint8Array$ %destination);
};
`TextEncoder$I includes `TextEncoderCommon$I;
</pre>

<p class="note">注記：
`TextEncoder$I ~objは、
`UTF-8$n しか~supportしないので，構築子に %label 引数は無い。
また、
~scalar値~bufferを要求する`符号化器$は無いので， `stream^mb ~optionもない。
◎
A TextEncoder object offers no label argument as it only supports UTF-8. It also offers no stream option as no encoder requires buffering of scalar values.
</p>

<hr>

<dl class="domintro">
	<dt>%encoder = `new TextEncoder()$m</dt>
	<dd>
新たな `TextEncoder$I ~obj を返す。
◎
Returns a new TextEncoder object.
</dd>

	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l を返す。
◎
Returns "utf-8".
</dd>

	<dt>%encoder . `encode([input = ""])$m</dt>
	<dd>
%input を `UTF-8$n の`符号化器$にかけた結果を返す。
◎
Returns the result of running UTF-8’s encoder.
</dd>

	<dt>%encoder . `encodeInto(source, destination)$m</dt>
	<dd>
%source を渡して`~UTF-8符号化器$を走らせた結果を %destination の中に格納して，その進捗を~objとして返す
— 結果の
⇒＃
`read$m は %source から変換された`~cu$数になる ／
`written$m は %destination 内で改変された~byte数になる
◎
Runs the UTF-8 encoder on source, stores the result of that operation into destination, and returns the progress made as an object wherein read is the number of converted code units of source and written is the number of bytes modified in destination.
</dd>
</dl>

<p class="algo">
`new TextEncoder()@m
構築子~手続きは、
何もしない。
◎
The new TextEncoder() constructor steps are to do nothing.
</p>

<div class="algo">
<p>
`encode(input)@m
~method~手続きは：
◎
The encode(input) method steps are:
</p>
<ol>
	<li>
%入力 ~LET `入出力~queueに変換する$( %input )
◎
Convert input to an I/O queue of scalar values.
</li>
	<li>
%出力 ~LET `入出力~queue$`~byte^tA « `~EoQ$ »
◎
Let output be the I/O queue of bytes « end-of-queue ».
</li>
	<li>
%符号化器 ~LET `UTF-8$n の`符号化器$の新たな~instance
◎
↓</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %入力 )
◎
Let item be the result of reading from input.
</li>
			<li>
%結果 ~LET `~itemを処理する$( %~item, %符号化器, %入力, %出力, `fatal^l )
◎
Let result be the result of processing an item with item, an instance of the UTF-8 encoder, input, output, and "fatal".
</li>
			<li>
<p>
~Assert：
%結果 は `~error$i でない
◎
Assert: result is not an error.
</p>

<p class="note">注記：
`~UTF-8符号化器$が `~error$i を返すことはない。
◎
The UTF-8 encoder cannot return error.
</p>
			</li>
			<li>
~IF［
%結果 ~EQ `完遂d$i
］
⇒
~RET 次を包装する，新たな `Uint8Array$I ~obj
⇒
次の結果を包含する `ArrayBuffer$I
⇒
%出力 を~byte列に`変換する$
◎
If result is finished, then convert output into a byte sequence and return a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`encodeInto(source, destination)@m
~method~手続きは：
◎
The encodeInto(source, destination) method steps are:
</p>
<ol>
	<li>
%read ~LET 0
◎
Let read be 0.
</li>
	<li>
%written ~LET 0
◎
Let written be 0.
</li>
	<li>
%符号化器 ~LET `~UTF-8符号化器$の新たな~instance
◎
Let encoder be an instance of the UTF-8 encoder.
</li>
	<li>
<p>
%利用されない~queue ~LET `入出力~queue$`~scalar値^tA « `~EoQ$ »
◎
Let unused be the I/O queue of scalar values « end-of-queue ».
</p>

<p class="note">注記：
以下で呼出される`~handler$~algoには，この引数が要求されるが、
`~UTF-8符号化器$は，それを利用しない。
◎
The handler algorithm invoked below requires this argument, but it is not used by the UTF-8 encoder.
</p>
	</li>
	<li>
%source ~SET `入出力~queueに変換する$( %source )
◎
Convert source to an I/O queue of scalar values.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %source )
◎
Let item be the result of reading from source.
</li>
			<li>
%結果 ~LET %符号化器 の`~handler$( %利用されない~queue, %~item )
◎
Let result be the result of running encoder’s handler on unused and item.
</li>
			<li>
~IF［
%結果 ~EQ `完遂d$i
］
⇒
~BREAK
◎
If result is finished, then break.
◎
Otherwise:
</li>
			<li>
~IF［
%written ~PLUS %結果 を成す~byte数 ~GT %destination の`~byte長さ$BS
］
⇒
~BREAK
◎
If destination’s byte length − written is greater than or equal to the number of bytes in result, then:
</li>
			<li>
%read ~INCBY ［
%~item ~LTE `FFFF^U ならば 1 ／
~ELSE_ 2
］
◎
• If item is greater than U+FFFF, then increment read by 2.
• Otherwise, increment read by 1.
</li>
			<li>
<p>
`配列~buffer~viewの中へ~byte列を書込む$( %destination, %結果, %written )
◎
• Write the bytes in result into destination, with startingOffset set to written.
</p>

<p class="warning">
上述した
<a href="#sharedarraybuffer-warning">`SharedArrayBuffer^I ~obj用の警告</a>
を見よ。
◎
See the warning for SharedArrayBuffer objects above.
</p>

			</li>
			<li>
%written ~INCBY %結果 を成す~byte数
◎
• Increment written by the number of bytes in result.
◎
Otherwise, break.
</li>
		</ol>
	</li>
	<li>
~RET « `read$m → %read, `written$m → %written »
◎
Return «[ "read" → read, "written" → written ]».
</li>
</ol>
</div>

<div class="example">
<p>
`encodeInto()$m ~methodを利用すれば、
文字列を既存の `ArrayBuffer$I ~objの中へ符号化できる。
下における様々な詳細は，読者への宿題として残しておくが、
この例は，この~methodの用-法の一つをデモる：
◎
The encodeInto() method can be used to encode a string into an existing ArrayBuffer object. Various details below are left as an exercise for the reader, but this demonstrates an approach one could take to use this method:
</p>

<pre class="lang-js">
function convertString(%buffer, %input, %callback) {
  let %bufferSize = 256,
      %bufferStart = malloc(%buffer, %bufferSize),
      %writeOffset = 0,
      %readOffset = 0;
  while (true) {
    const view = new Uint8Array(%buffer, %bufferStart + %writeOffset, %bufferSize - %writeOffset),
          {%read, %written} = cachedEncoder.encodeInto(%input.substring(%readOffset), view);
    %readOffset += %read;
    %writeOffset += %written;
    if (%readOffset === %input.length) {
      %callback(%bufferStart, %writeOffset);
      free(%buffer, %bufferStart);
      return;
    }
    %bufferSize *= 2;
    %bufferStart = realloc(%buffer, %bufferStart, %bufferSize);
  }
}
</pre>
</div>

		</section>
		<section id="interface-textdecoderstream">
<h3 title="Interface TextDecoderStream">7.5. ~interface `TextDecoderStream$I</h3>

<pre class="idl">
[`Exposed$=*]
interface `TextDecoderStream@I {
  `TextDecoderStream$mc(optional `DOMString$ %label = "utf-8", optional `TextDecoderOptions$I %options = {});
};
`TextDecoderStream$I includes `TextDecoderCommon$I;
`TextDecoderStream$I includes `GenericTransformStream$I;
</pre>

<dl class="domintro">
	<dt>%decoder = new <a href="#dom-textdecoderstream">TextDecoderStream([%label = "utf-8" [, %options]])</a></dt>
	<dd>
新たな `TextDecoderStream$I ~objを返す。
◎
Returns a new TextDecoderStream object.
</dd>
	<dd>
%label が次を満たす場合、
`RangeError$E が`投出-$される
⇒
［
~labelでない
］~OR［
`replacement$n 用の~labelである
］
◎
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`符号化法$decの`名前$を小文字~化して返す。
◎
Returns encoding’s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
［
`~error~mode$dec ~EQ `fatal^l ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if error mode is "fatal", and false otherwise.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
`~BOMは無視するか$decの値を返す。
◎
Returns the value of ignore BOM.
</dd>

	<dt>%decoder . `readable$m</dt>
	<dd>
`可読~stream$を返す。
その`~chunk$たちは、
`writable$m に書込まれた~chunkたちに対し，`符号化法$decの`復号器$を走らせた結果の文字列たちになる。
◎
Returns a readable stream whose chunks are strings resulting from running encoding’s decoder on the chunks written to writable.
</dd>

	<dt>%decoder . `writable$m</dt>
	<dd>
`可書~stream$を返す。
それは、
`AllowSharedBufferSource$I 型の~chunkたちを受容して
— `readable$m に可用にされる前に —
`符号化法$decの`復号器$にかける。

◎
Returns a writable stream which accepts AllowSharedBufferSource chunks and runs them through encoding’s decoder before making them available to readable.
</dd>
	<dd class="example">
<p>
これは概して、
`ReadableStream$I 源の `pipeThrough$m ~methodを介して利用されることになる。
◎
Typically this will be used via the pipeThrough() method on a ReadableStream source.
</p>

<pre class="lang-js">
var %decoder = new TextDecoderStream(%encoding);
byteReadable
  .pipeThrough(%decoder)
  .pipeTo(%textWritable);
</pre>

</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l
かつ`符号化法$decの`復号器$は `~error$i を返す場合、
`readable$m, `writable$m
とも `TypeError$E で~errorにされることになる。
◎
If the error mode is "fatal" and encoding’s decoder returns error, both readable and writable will be errored with a TypeError.
</dd>
</dl>

<div class="algo">
<p>
`new TextDecoderStream(label, options)@m
構築子~手続きは：
◎
The new TextDecoderStream(label, options) constructor steps are:
</p>
<ol>
	<li>
%符号化法 ~LET `~labelから符号化法を取得する$( %label )
◎
Let encoding be the result of getting an encoding from label.
</li>
	<li>
~IF［
%符号化法 ~IN { `失敗^i, `replacement$n }
］
⇒
~THROW `RangeError$E
◎
If encoding is failure or replacement, then throw a RangeError.
</li>
	<li>
コレの`符号化法$dec ~SET %符号化法
◎
Set this’s encoding to encoding.
</li>
	<li>
~IF［
%options[ "`fatal$mb" ] ~EQ ~T
］
⇒
コレの`~error~mode$dec ~SET `fatal^l
◎
If options["fatal"] is true, then set this’s error mode to "fatal".
</li>
	<li>
コレの`~BOMは無視するか$dec ~SET %options[ "`ignoreBOM$mb" ]
◎
Set this’s ignore BOM to options["ignoreBOM"].
</li>
	<li>
コレの`復号器$dec ~SET コレの`符号化法$decの`復号器$の新たな~instance
◎
Set this’s decoder to a new instance of this’s encoding’s decoder,＼
</li>
	<li>
コレの`入出力~queue$dec ~SET 新たな`入出力~queue$`~byte^tA
◎
and set this’s I/O queue to a new I/O queue.
</li>
	<li>
%形式変換~algo ~LET
( %~chunk ) を引数に，次を走らす~algo
⇒
`~chunkを復号して~enqueueする$( コレ, %~chunk )
◎
Let transformAlgorithm be an algorithm which takes a chunk argument and runs the decode and enqueue a chunk algorithm with this and chunk.
</li>
	<li>
%書出n~algo ~LET 引数をとらず，次を走らす~algo
⇒
`書出して~enqueueする$( コレ )
◎
Let flushAlgorithm be an algorithm which takes no arguments and runs the flush and enqueue algorithm with this.
</li>
	<li>
%形式変換~stream ~LET `新たな$ `TransformStream$I
◎
Let transformStream be a new TransformStream.
</li>
	<li>
コレの`形式変換$を`設定しておく$TS( %形式変換~algo, %書出n~algo )
◎
Set up transformStream with transformAlgorithm set to transformAlgorithm and flushAlgorithm set to flushAlgorithm.
</li>
	<li>
コレの`形式変換$ ~SET %形式変換~stream
◎
Set this’s transform to transformStream.
</li>
</ol>
</div>

<div class="algo">
<p>
`~chunkを復号して~enqueueする@
~algoは、
所与の
( `TextDecoderStream$I ~obj %復号器, %~chunk )
に対し，次を走らす：
◎
The decode and enqueue a chunk algorithm, given a TextDecoderStream object decoder and a chunk, runs these steps:
</p>
<ol>
	<li>
%~buffer源 ~LET `~IDL値に変換する$( %~chunk, `AllowSharedBufferSource$I )
◎
Let bufferSource be the result of converting chunk to an AllowSharedBufferSource.
</li>
	<li>
<p>
`入出力~queueに~pushする$( %復号器 の`入出力~queue$dec, 次の結果 )
⇒
`複製を取得する$( %~buffer源 )
◎
Push a copy of bufferSource to decoder’s I/O queue.
</p>

<p class="warning">
上述した
<a href="#sharedarraybuffer-warning">`SharedArrayBuffer^I ~obj用の警告</a>
を見よ。
◎
See the warning for SharedArrayBuffer objects above.
</p>
	</li>
	<li>
%出力 ~LET `入出力~queue$`~scalar値^tA « `~EoQ$ »
◎
Let output be the I/O queue of scalar values « end-of-queue ».
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %復号器 の`入出力~queue$dec )
◎
Let item be the result of reading from decoder’s I/O queue.
</li>
			<li>
<p>
~IF［
%~item ~EQ `~EoQ$
］：
◎
If item is end-of-queue, then:
</p>
				<ol>
					<li>
%出力~chunk ~LET `入出力~queueを直列化する$( コレ, %出力 )
◎
Let outputChunk be the result of running serialize I/O queue with decoder and output.
</li>
					<li>
~IF［
%出力~chunk は空でない
］
⇒
%復号器 の`形式変換$に`~chunkを~enqueueする$TS( %出力~chunk )
◎
If outputChunk is non-empty, then enqueue outputChunk in decoder’s transform.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
%結果 ~LET `~itemを処理する$( %~item, %復号器 の`復号器$dec, %復号器 の`入出力~queue$dec, %出力, %復号器 の`~error~mode$dec )
◎
Let result be the result of processing an item with item, decoder’s decoder, decoder’s I/O queue, output, and decoder’s error mode.
</li>
			<li>
~IF［
%結果 ~EQ `~error$i
］
⇒
~THROW `TypeError$E
◎
If result is error, then throw a TypeError.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`書出して~enqueueする@
~algoは、
入力 `ReadableStream$I ~objからの~dataの終端を取扱う
— それは、
所与の
( `TextDecoderStream$I ~obj %復号器 )
に対し，次を走らす：
◎
The flush and enqueue algorithm, which handles the end of data from the input ReadableStream object, given a TextDecoderStream object decoder, runs these steps:
</p>
<ol>
	<li>
%出力 ~LET `入出力~queue$`~scalar値^tA « `~EoQ$ »
◎
Let output be the I/O queue of scalar values « end-of-queue ».
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %復号器 の`入出力~queue$dec )
◎
Let item be the result of reading from decoder’s I/O queue.
</li>
			<li>
%結果 ~LET `~itemを処理する$( %~item, %復号器 の`復号器$dec, %復号器 の`入出力~queue$dec, %出力, %復号器 の`~error~mode$dec )
◎
Otherwise:
◎
Let result be the result of processing an item with item, decoder’s decoder, decoder’s I/O queue, output, and decoder’s error mode.
</li>
			<li>
<p>
~IF［
%結果 ~EQ `完遂d$i
］：
◎
If result is finished, then:
</p>
				<ol>
					<li>
%出力~chunk ~LET `入出力~queueを直列化する$( コレ, %出力 )
◎
Let outputChunk be the result of running serialize I/O queue with decoder and output.
</li>
					<li>
~IF［
%出力~chunk は空でない
］
⇒
%復号器 の`形式変換$に`~chunkを~enqueueする$TS( %出力~chunk )
◎
If outputChunk is non-empty, then enqueue outputChunk in decoder’s transform.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%結果 ~EQ `~error$i
］
⇒
~THROW `TypeError$E
◎
Otherwise, if result is error, throw a TypeError.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="interface-textencoderstream">
<h3 title="Interface TextEncoderStream">7.6. ~interface `TextEncoderStream^I</h3>

<pre class="idl">
[`Exposed$=*]
interface `TextEncoderStream@I {
  `TextEncoderStream$mc();
};

`TextEncoderStream$I includes `TextEncoderCommon$I;
`TextEncoderStream$I includes `GenericTransformStream$I;
</pre>

<p>
各 `TextEncoderStream$I ~objには、
次が結付けられる：
◎
A TextEncoderStream object has an associated:
</p>

<dl class="def-list">
	<dt>
`符号化器@enc
◎
encoder
</dt>
	<dd>
`符号化器$の~instance
◎
An encoder instance.
</dd>
	<dd class="trans-note">【
下に注記されるように， `UTF-8$n のそれしかとらない。
また、
`復号器$decのときと違って，内部状態を保持する変数は無い。
】</dd>

	<dt>
`処理待ち高位~surrogate@enc
◎
pending high surrogate
</dt>
	<dd>
~NULL または`~surrogate$
— 初期~時には~NULL とする。
◎
Null or a surrogate, initially null.
</dd>
</dl>

<p class="note">注記：
`TextEncoderStream$I ~objは `UTF-8$n しか~supportしないので、
%~label 引数を提供しない。
◎
A TextEncoderStream object offers no label argument as it only supports UTF-8.
</p>

<dl class="domintro">
	<dt>%encoder = `new TextEncoderStream()$m</dt>
	<dd>
新たな `TextEncoderStream$I ~objを返す。
◎
Returns a new TextEncoderStream object.
</dd>
	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l を返す。
◎
Returns "utf-8".
</dd>

	<dt>%encoder . `readable$m</dt>
	<dd>
`可読~stream$を返す。
その各`~chunk$は、
`writable$m に書込まれた~chunkたちに対し
`UTF-8$n の`符号化器$を走らせた結果の `Uint8Array$I になる。
◎
Returns a readable stream whose chunks are Uint8Arrays resulting from running UTF-8’s encoder on the chunks written to writable.
</dd>

	<dt>%encoder . `writable$m</dt>
	<dd>
`可書~stream$を返す。
それは、
文字列~chunkたちを受容して
— `readable$m に可用にされる前に —
`UTF-8$n の`符号化器$にかける。
◎
Returns a writable stream which accepts string chunks and runs them through UTF-8’s encoder before making them available to readable.
</dd>
	<dd class="example">
<p>
これは概して、
`ReadableStream$I 源の `pipeThrough$m ~methodを介して利用されることになる。
◎
Typically this will be used via the pipeThrough() method on a ReadableStream source.
</p>

<pre class="lang-js">
%textReadable
  .pipeThrough(new TextEncoderStream())
  .pipeTo(%byteWritable);
</pre>

	</dd>
</dl>

<div class="algo">
<p>
`new TextEncoderStream()@m
構築子~手続きは：
◎
The new TextEncoderStream() constructor steps are:
</p>
<ol>
	<li>
コレの`符号化器$enc ~SET `UTF-8$n の`符号化器$の新たな~instance
◎
Set this’s encoder to an instance of the UTF-8 encoder.
</li>
	<li>
%形式変換~algo ~LET ( %~chunk ) を引数に，次を走らす~algo
⇒
`~chunkを符号化して~enqueueする$( コレ, %~chunk )
◎
Let transformAlgorithm be an algorithm which takes a chunk argument and runs the encode and enqueue a chunk algorithm with this and chunk.
</li>
	<li>
%書出n~algo ~LET 次を走らす~algo
⇒
`符号化して書出す$( コレ )
◎
Let flushAlgorithm be an algorithm which runs the encode and flush algorithm with this.
</li>
	<li>
%形式変換~stream ~LET `新たな$ `TransformStream$I
◎
Let transformStream be a new TransformStream.
</li>
	<li>
コレの`形式変換$を`設定しておく$TS( %形式変換~algo, %書出n~algo )
◎
Set up transformStream with transformAlgorithm set to transformAlgorithm and flushAlgorithm set to flushAlgorithm.
</li>
	<li>
コレの`形式変換$ ~SET %形式変換~stream
◎
Set this’s transform to transformStream.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`~chunkを符号化して~enqueueする@
~algoは、
所与の
( `TextEncoderStream$I ~obj %符号化器, %~chunk )
に対し，次を走らす：
◎
The encode and enqueue a chunk algorithm, given a TextEncoderStream object encoder and chunk, runs these steps:
</p>
<ol>
	<li>
%入力 ~LET `~IDL値に変換する$( %~chunk, `DOMString^I )
◎
Let input be the result of converting chunk to a DOMString.
</li>
	<li>
<p>
%入力 ~SET `入出力~queueに変換する$( %入力 )
◎
Convert input to an I/O queue of code units.
</p>

<p class="note">注記：
`DOMString^I 型から変換しているので、
結果の`入出力~queue$の~item型は，~scalar値ではなく`~cu$になる。
そのようにしているのは、［
2 つの~chunkに分割された~surrogate~pairを，適切な~scalar値に組立直せるようにする
］ためであり，他の挙動は `USVString^I と一致する。
特に，~~孤立した~surrogateは `FFFD^U に置換されることになる。
◎
DOMString, as well as an I/O queue of code units rather than scalar values, are used here so that a surrogate pair that is split between chunks can be reassembled into the appropriate scalar value. The behavior is otherwise identical to USVString. In particular, lone surrogates will be replaced with U+FFFD.
</p>
	</li>
	<li>
%出力 ~LET `入出力~queue$`~byte^tA « `~EoQ$ »
◎
Let output be the I/O queue of bytes « end-of-queue ».
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %入力 )
◎
Let item be the result of reading from input.
</li>
			<li>
<p>
~IF［
%~item ~EQ `~EoQ$
］：
◎
If item is end-of-queue, then:
</p>
				<ol>
					<li>
%出力 ~SET %出力 を~byte列に`変換する$
◎
Convert output into a byte sequence.
</li>
					<li>
<p>
~IF［
%出力 は空でない
］：
◎
If output is non-empty, then:
</p>
						<ol>
							<li>
%~chunk ~LET %出力 を包含している `ArrayBuffer$I を包装する，新たな `Uint8Array$I ~obj
◎
Let chunk be a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
	<li>
%符号化器 の`形式変換$に`~chunkを~enqueueする$TS( %~chunk )
◎
Enqueue chunk into encoder’s transform.
</li>
						</ol>
					</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
%結果 ~LET `~cuを~scalar値に変換する$( %符号化器, %~item, %入力 )
◎
Let result be the result of executing the convert code unit to scalar value algorithm with encoder, item and input.
</li>
			<li>
~IF［
%結果 ~NEQ `継続-$i
］
⇒
`~itemを処理する$( %結果, %符号化器 の`符号化器$enc, %入力, %出力, `fatal^l )
◎
If result is not continue, then process an item with result, encoder’s encoder, input, output, and "fatal".
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~cuを~scalar値に変換する@
~algoは、
所与の
( `TextEncoderStream$I ~obj %符号化器, `~cu$ %~item, `入出力~queue$`~cu^tA %入力 )
に対し，次を走らす：
◎
The convert code unit to scalar value algorithm, given a TextEncoderStream object encoder, a code unit item, and an I/O queue of code units input, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%符号化器 の`処理待ち高位~surrogate$enc ~NEQ ~NULL
］：
◎
If encoder’s pending high surrogate is non-null, then:
</p>
		<ol>
			<li>
%高位~surrogate ~LET
%符号化器 の`処理待ち高位~surrogate$enc

◎
Let high surrogate be encoder’s pending high surrogate.
</li>
			<li>
%符号化器 の`処理待ち高位~surrogate$enc ~SET ~NULL
◎
Set encoder’s pending high surrogate to null.
</li>
			<li>
~IF［
%~item ~IN { `DC00^U 〜 `DFFF^U }
］
⇒
~RET 【！~scalar値】~cp [ `10000^X + (( %高位~surrogate ~MINUS `D800^X ) ~Lshift 10) + ( %~item ~MINUS `DC00^X ) ]
◎
If item is in the range U+DC00 to U+DFFF, inclusive, then return a scalar value whose value is 0x10000 + ((high surrogate − 0xD800) &lt;&lt; 10) + (item − 0xDC00).
</li>
			<li>
`入出力~queueに前付加する$( %入力, %~item )
◎
Prepend item to input.
</li>
			<li>
~RET `FFFD^U
◎
Return U+FFFD.
</li>
		</ol>
	</li>
	<li>
~IF［
%~item ~IN { `D800^U 〜 `DBFF^U }
］
⇒＃
`処理待ち高位~surrogate$enc ~SET %~item；
~RET `継続-$i
◎
If item is in the range U+D800 to U+DBFF, inclusive, then set pending high surrogate to item and return continue.
</li>
	<li>
~IF［
%~item ~IN { `DC00^U 〜 `DFFF^U }
］
⇒
~RET `FFFD^U
◎
If item is in the range U+DC00 to U+DFFF, inclusive, then return U+FFFD.
</li>
	<li>
~RET %~item
◎
Return item.
</li>
</ol>

<p class="note">注記：
これは， `INFRA$r による［
`文字列$を`~scalar値~文字列$に
<a href="~INFRA#javascript-string-convert">変換する~algo</a>
］と等価になるが、
2 つの文字列に分割された~surrogate~pairも許容する。
`INFRA$r
◎
This is equivalent to the "convert a string into a scalar value string" algorithm from the Infra Standard, but allows for surrogate pairs that are split between strings. [INFRA]
</p>
</div>

<div class="algo">
<p>
`符号化して書出す@
~algoは、
所与の
( `TextEncoderStream$I ~obj %符号化器 )
に対し，次を走らす：
◎
The encode and flush algorithm, given a TextEncoderStream object encoder, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%符号化器 の`処理待ち高位~surrogate$enc ~NEQ ~NULL
］：
◎
If encoder’s pending high surrogate is non-null, then:
</p>
		<ol>
			<li>
<p>
%~chunk ~LET ［
~byte列 `EF^X `BF^X `BD^X
］を包含している `ArrayBuffer$I を包装する，新たな `Uint8Array$I ~obj
◎
Let chunk be a Uint8Array object wrapping an ArrayBuffer containing 0xEF 0xBF 0xBD.
</p>

<p class="note">注記：
これは、
`FFFD^U `�^smb を成す~UTF-8~byte列である。
◎
This is U+FFFD (�) in UTF-8 bytes.
</p>
			</li>
			<li>
%符号化器 の`形式変換$に`~chunkを~enqueueする$TS( %~chunk )
◎
Enqueue chunk into encoder’s transform.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
	</section>
	<section id="the-encoding">
<h2 title="The encoding">8. ~~標準の符号化法</h2>

<p class="trans-note">【
この “~~標準の” は “The” の対訳であり、
およそ，
“規範とされるべき唯一無二の”
を意味する。
】</p>

		<section id="utf-8">
<h3>8.1. ~UTF-8</h3>

			<section id="utf-8-decoder">
<h4 title="UTF-8 decoder">8.1.1. ~UTF-8復号器</h4>

<p class="note">注記：
~BOMは、
~labelより~~優先される
— その方が配備-済みな内容において正確aになるものと見出されたので。
したがってそれは、
`~UTF-8復号器$~algoの一部を成さない
— 代わりに［
`~Unicodeに復号する$ ／ `~UTF-8復号する$
］~algoの一部を成す。
◎
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the UTF-8 decoder algorithm but rather the decode and UTF-8 decode algorithms.
</p>

<p>
各［
`UTF-8$n の`復号器$
］には、
次が結付けられる
⇒＃
`~UTF-8~cp@（初期~時 0 ）,
`~UTF-8出現~byte数@（初期~時 0 ）,
`~UTF-8要~byte数@（初期~時 0 ）,
`~UTF-8下限@（初期~時 `80^X ）,
`~UTF-8上限@（初期~時 `BF^X ）
◎
UTF-8’s decoder has an associated UTF-8 code point, UTF-8 bytes seen, and UTF-8 bytes needed (all initially 0), a UTF-8 lower boundary (initially 0x80), and a UTF-8 upper boundary (initially 0xBF).
</p>

<p>
`UTF-8$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，次を走らす：
◎
UTF-8’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
~IF［
%~byte ~EQ `~EoQ$
］~AND［
`~UTF-8要~byte数$ ~NEQ 0
］
⇒＃
`~UTF-8要~byte数$ ~SET 0；
~RET `~error$i
◎
If byte is end-of-queue and UTF-8 bytes needed is not 0, set UTF-8 bytes needed to 0 and return error.
</li>
	<li>
~IF［
%~byte ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If byte is end-of-queue, return finished.
</li>
	<li>
<p>
~IF［
`~UTF-8要~byte数$ ~EQ 0
］：
◎
If UTF-8 bytes needed is 0, based on byte:
</p>
		<ol>
			<li>
<p>
%~byte に応じて：
◎
↑</p>

				<dl class="switch">
					<dt>`00^X 〜 `7F^X</dt>
					<dd>
~RET ~cp [ %~byte ]
◎
Return a code point whose value is byte.
</dd>

					<dt>`C2^X 〜 `DF^X</dt>
					<dd>
						<ol>
							<li>
`~UTF-8要~byte数$ ~SET 1
◎
Set UTF-8 bytes needed to 1.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `1F^X
<span class="note">（ %~byte の下位 5 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0x1F.
◎
The five least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`E0^X 〜 `EF^X</dt>
					<dd>
						<ol>
							<li>
~IF［
%~byte ~EQ `E0^X
］
⇒
`~UTF-8下限$ ~SET `A0^X
◎
If byte is 0xE0, set UTF-8 lower boundary to 0xA0.
</li>
							<li>
~IF［
%~byte ~EQ `ED^X
］
⇒
`~UTF-8上限$ ~SET `9F^X
◎
If byte is 0xED, set UTF-8 upper boundary to 0x9F.
</li>
							<li>
`~UTF-8要~byte数$ ~SET 2
◎
Set UTF-8 bytes needed to 2.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `F^X
<span class="note">（ %~byte の下位 4 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0xF.
◎
The four least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`F0^X 〜 `F4^X</dt>
					<dd>
						<ol>
							<li>
~IF［
%~byte ~EQ `F0^X
］
⇒
`~UTF-8下限$ ~SET `90^X
◎
If byte is 0xF0, set UTF-8 lower boundary to 0x90.
</li>
							<li>
~IF［
%~byte ~EQ `F4^X
］
⇒
`~UTF-8上限$ ~SET `8F^X
◎
If byte is 0xF4, set UTF-8 upper boundary to 0x8F.
</li>
							<li>
`~UTF-8要~byte数$ ~SET 3
◎
Set UTF-8 bytes needed to 3.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `7^X
<span class="note">（ %~byte の下位 3 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0x7.
◎
The three least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>
その他
◎
Otherwise
</dt>
					<dd>
~RET `~error$i
◎
Return error.
</dd>
				</dl>
			</li>
			<li>
~RET `継続-$i
◎
Return continue.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~byte ~NIN { `~UTF-8下限$ 〜 `~UTF-8上限$ }
］：
◎
If byte is not in the range UTF-8 lower boundary to UTF-8 upper boundary, inclusive, then:
</p>
		<ol>
			<li>
( `~UTF-8~cp$, `~UTF-8要~byte数$, `~UTF-8出現~byte数$ ) ~SET ( 0, 0, 0 )
◎
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0,＼
</li>
			<li>
( `~UTF-8下限$, `~UTF-8上限$ ) ~SET ( `80^X, `BF^X )
◎
set UTF-8 lower boundary to 0x80, and set UTF-8 upper boundary to 0xBF.
</li>
			<li>
`入出力~queueに前付加する$( %入出力~queue, %~byte )
◎
Prepend byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
( `~UTF-8下限$, `~UTF-8上限$ ) ~SET ( `80^X, `BF^X )
◎
Set UTF-8 lower boundary to 0x80 and UTF-8 upper boundary to 0xBF.
</li>
	<li>
<p>
`~UTF-8~cp$ ~SET (`~UTF-8~cp$ ~Lshift 6) ~bOR (%~byte ~bAND `3F^X)
◎
Set UTF-8 code point to (UTF-8 code point &lt;&lt; 6) | (byte &amp; 0x3F)
</p>

<p class="note">注記：
`~UTF-8~cp$内の既存の~bitを左へ 6 ~bit ~shiftして，~~空いた下位 6 ~bitに %~byte の下位 6 ~bitをあてがう。
◎
Shift the existing bits of UTF-8 code point left by six places and set the newly-vacated six least significant bits to the six least significant bits of byte.
</p>
	</li>
	<li>
`~UTF-8出現~byte数$ ~INCBY 1
◎
Increase UTF-8 bytes seen by one.
</li>
	<li>
~IF［
`~UTF-8出現~byte数$ ~NEQ `~UTF-8要~byte数$
］
⇒
~RET `継続-$i
◎
If UTF-8 bytes seen is not equal to UTF-8 bytes needed, return continue.
</li>
	<li>
%~cp ~LET `~UTF-8~cp$
◎
Let code point be UTF-8 code point.
</li>
	<li>
( `~UTF-8~cp$, `~UTF-8要~byte数$, `~UTF-8出現~byte数$ ) ~SET ( 0, 0, 0 )
◎
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0.
</li>
	<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
</ol>

<p class="note">注記：
上の`~UTF-8復号器$における拘束は、
~Unicode標準の
“`Best Practices for Using U+FFFD^en”
に準じる。
他のふるまいは Encoding 標準の下では許可されない（同じ結果が得られるなら、
他の~algoでも~~十分であり，むしろ奨励される）。
`UNICODE$r
◎
The constraints in the UTF-8 decoder above match “Best Practices for Using U+FFFD” from the Unicode standard. No other behavior is permitted per the Encoding Standard (other algorithms that achieve the same result are fine, even encouraged). [UNICODE]
</p>

			</section>
			<section id="utf-8-encoder">
<h4 title="UTF-8 encoder">8.1.2. ~UTF-8符号化器</h4>

<p>
`UTF-8$n の`符号化器$の`~handler$は、
所与の
( %入出力~queue, %~cp )
に対し，次を走らす：
◎
UTF-8’s encoder’s handler, given ioQueue and code point, runs these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If code point is end-of-queue, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
( %count, %~offset ) ~SET %~cp が属する範囲に応じて
⇒＃
{ `0080^U 〜 `07FF^U } ならば ( 1, `C0^X ) ／
{ `0800^U 〜 `FFFF^U } ならば ( 2, `E0^X ) ／
{ `10000^U 〜 `10FFFF^U } ならば ( 3, `F0^X )
◎
Set count and offset based on the range code point is in:
◎
U+0080 to U+07FF, inclusive
• 1 and 0xC0
U+0800 to U+FFFF, inclusive
• 2 and 0xE0
U+10000 to U+10FFFF, inclusive
• 3 and 0xF0
</li>
	<li>
%~byte列 ~LET ~byte列 [ ( %~cp ~Rshift ( 6 ~MUL %count ) ) ~PLUS %~offset ]
◎
Let bytes be a byte sequence whose first byte is (code point &gt;&gt; (6 × count)) + offset.
</li>
	<li>
<p>
~WHILE［
%count ~GT 0
］：
◎
While count is greater than 0:
</p>
		<ol>
			<li>
%temp ~SET %~cp ~Rshift ( 6 ~MUL ( %count ~MINUS 1 ) )
◎
Set temp to code point &gt;&gt; (6 × (count − 1)).
</li>
	<li>
%~byte列 に
( `80^X ~bOR ( %temp ~bAND `3F^X ) )
を付加する
◎
Append to bytes 0x80 | (temp &amp; 0x3F).
</li>
	<li>
%count ~DECBY 1
◎
Decrease count by one.
</li>
		</ol>
	</li>
	<li>
~RET %~byte列
◎
Return bytes bytes, in order.
</li>
</ol>

<p class="note">注記：
この~algoは、
~Unicode標準に述べられるものと一致する結果を得るが，完全さのためここに含められている。
`UNICODE$r
◎
This algorithm has identical results to the one described in the Unicode standard. It is included here for completeness. [UNICODE]
</p>

			</section>
		</section>
	</section>
	<section id="legacy-single-byte-encodings">
<h2 title="Legacy single-byte encodings">9. 旧来の単-~byte符号化法</h2>

<p>
`符号化法$のうち［
各~byteが， 1 個の~cpに対応するか, どの~cpにも対応しないもの
］は、
`単-~byte符号化法@
と総称される。
すべての`単-~byte符号化法$が、
同じ［
`復号器$, `符号化器$
］を共有する。
`単-~byte復号器$／`単-~byte符号化器$から参照される
`単-~byte索引@
は、
利用される`単-~byte符号化法$に依存し，次の一覧で定義される。
［
`ISO-8859-8^n, `ISO-8859-8-I^n
］を除くすべての`単-~byte符号化法$は、
それぞれに一意な`索引$を持つ。
◎
An encoding where each byte is either a single code point or nothing, is a single-byte encoding. Single-byte encodings share the decoder and encoder. Index single-byte, as referenced by the single-byte decoder and single-byte encoder, is defined by the following table, and depends on the single-byte encoding in use. All but two single-byte encodings have a unique index.
</p>

<p class="trans-note">【
被覆域の~tableは巨大なことに注意。
】【
視覚-化~tableの各~cellの色については、
<a href="#visualization">凡例</a>を見よ。
】</p>

<table><thead>
<tr><th>`名前$
<th>`索引$
<th>視覚-化
<th>基本多言語面（ BMP ）の被覆域
<tbody>

<tr><td>`IBM866@n<td>`IBM866$idx
<tr><td>`ISO-8859-2@n<td>`ISO-8859-2$idx
<tr><td>`ISO-8859-3@n<td>`ISO-8859-3$idx
<tr><td>`ISO-8859-4@n<td>`ISO-8859-4$idx
<tr><td>`ISO-8859-5@n<td>`ISO-8859-5$idx
<tr><td>`ISO-8859-6@n<td>`ISO-8859-6$idx
<tr><td>`ISO-8859-7@n<td>`ISO-8859-7$idx
<tr><td>`ISO-8859-8@n<td>`ISO-8859-8$idx
<tr><td>`ISO-8859-8-I@n<td colspan="3">`ISO-8859-8$n と同じ
<tr><td>`ISO-8859-10@n<td>`ISO-8859-10$idx
<tr><td>`ISO-8859-13@n<td>`ISO-8859-13$idx
<tr><td>`ISO-8859-14@n<td>`ISO-8859-14$idx
<tr><td>`ISO-8859-15@n<td>`ISO-8859-15$idx
<tr><td>`ISO-8859-16@n<td>`ISO-8859-16$idx
<tr><td>`KOI8-R@n<td>`KOI8-R$idx
<tr><td>`KOI8-U@n<td>`KOI8-U$idx
<tr><td>`macintosh@n<td>`macintosh$idx
<tr><td>`windows-874@n<td>`windows-874$idx
<tr><td>`windows-1250@n<td>`windows-1250$idx
<tr><td>`windows-1251@n<td>`windows-1251$idx
<tr><td>`windows-1252@n<td>`windows-1252$idx
<tr><td>`windows-1253@n<td>`windows-1253$idx
<tr><td>`windows-1254@n<td>`windows-1254$idx
<tr><td>`windows-1255@n<td>`windows-1255$idx
<tr><td>`windows-1256@n<td>`windows-1256$idx
<tr><td>`windows-1257@n<td>`windows-1257$idx
<tr><td>`windows-1258@n<td>`windows-1258$idx
<tr><td>`x-mac-cyrillic@n<td>`x-mac-cyrillic$idx
</table>

<p class="note">注記：
~layout方向に波及することから、
`ISO-8859-8$n と `ISO-8859-8-I$n の`符号化法$の`名前$は異なるものにされている。
歴史的に、
このことは `ISO-8859-6$n と "ISO-8859-6-I" についても該当していたが、
それはもはや成立しない。
【！ https://www.w3.org/Bugs/Public/show_bug.cgi?id=19505 】
◎
ISO-8859-8 and ISO-8859-8-I are distinct encoding names, because ISO-8859-8 has influence on the layout direction. And although historically this might have been the case for ISO-8859-6 and "ISO-8859-6-I" as well, that is no longer true.
</p>

		<section id="single-byte-decoder">
<h3 title="single-byte decoder">9.1. 単-~byte復号器</h3>

<p>
`単-~byte符号化法$の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，次を走らす：
◎
Single-byte encodings’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
~IF［
%~byte ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If byte is end-of-queue, return finished.
</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
%~cp ~LET
`単-~byte索引$ の中で
( %~byte ~MINUS `80^X )
が指す`索引~cp$
◎
Let code point be the index code point for byte − 0x80 in index single-byte.
</li>
	<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$i
◎
If code point is null, return error.
</li>
	<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
</ol>

		</section>
		<section id="single-byte-encoder">
<h3 title="single-byte encoder">9.2. 単-~byte符号化器</h3>

<p>
`単-~byte符号化法$ の`符号化器$の`~handler$は、
所与の
( %入出力~queue, %~cp )
に対し，次を走らす：
◎
Single-byte encodings’s encoder’s handler, given ioQueue and code point, runs these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If code point is end-of-queue, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET
`単-~byte索引$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index single-byte.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET `~error$i( %~cp )
◎
If pointer is null, return error with code point.
</li>
	<li>
~RET ~byte列 [ %~pointer ~PLUS `80^X ]
◎
Return a byte whose value is pointer + 0x80.
</li>
</ol>

		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(simplified)-encodings">
<h2 title="Legacy multi-byte Chinese (simplified) encodings">10. 旧来の複-~byte~Chinese（簡体字） 符号化法</h2>

		<section id="gbk">
<h3 title="GBK">10.1. ~GBK</h3>

			<section id="gbk-decoder">
<h4 title="GBK decoder">10.1.1. ~GBK復号器</h4>

<p>
`GBK$n の`復号器$は，`gb18030$n の`復号器$である。
◎
GBK’s decoder is gb18030’s decoder.
</p>

			</section>
			<section id="gbk-encoder">
<h4 title="GBK encoder">10.1.2. ~GBK符号化器</h4>

<p>
`GBK$n の符号化器は，［
`~GBK用か$ ~SET ~T
］にされた`gb18030$n の`符号化器$である。
◎
GBK’s encoder is gb18030’s encoder with its is GBK set to true.
</p>

<p class="note">注記：
`GBK$n を`gb18030$nに対する全くの別名にしないのは、
`GBK$n の`符号化器$により生成された内容を［
旧来の~serverや他の消費器を非互換化する機会cを減らすよう，保守的に移行する
］ためである。
◎
Not fully aliasing GBK with gb18030 is a conservative move to decrease the chances of breaking legacy servers and other consumers of content generated with GBK’s encoder.
</p>

			</section>
		</section>
		<section id="gb18030">
<h3 title="gb18030">10.2. ~gb18030</h3>

			<section id="gb18030-decoder">
<h4 title="gb18030 decoder">10.2.1. ~gb18030復号器</h4>

<p>
各［
`gb18030$n の`復号器$
］には、
次が結付けられる
⇒＃
`~gb1@（初期~時 0 ）,
`~gb2@（初期~時 0 ）,
`~gb3@（初期~時 0 ）
◎
gb18030’s decoder has an associated gb18030 first, gb18030 second, and gb18030 third (all initially 0x00).
</p>

<p>
`gb18030$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，次を走らす：
◎
gb18030’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
( `~gb1$, `~gb2$, `~gb3$ ) ~EQ ( `00^X, `00^X, `00^X )
］
⇒
~RET `完遂d$i
◎
If byte is end-of-queue and gb18030 first, gb18030 second, and gb18030 third are 0x00, return finished.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
◎
If byte is end-of-queue, and gb18030 first, gb18030 second, or gb18030 third is not 0x00, set gb18030 first, gb18030 second, and gb18030 third to 0x00, and＼
</li>
			<li>
~RET `~error$i
◎
return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb3$ ~NEQ `00^X
］：
◎
If gb18030 third is not 0x00, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~byte ~NIN { `30^X 〜 `39^X }
］：
◎
If byte is not in the range 0x30 to 0x39, inclusive, then:
</p>
				<ol>
					<li>
`入出力~queueに前付加する$( %入出力~queue, ~byte列 [ `~gb2$, `~gb3$, %~byte ] ) 
◎
Prepend gb18030 second, gb18030 third, and byte to ioQueue.
</li>
					<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
◎
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
					<li>
~RET `~error$i
◎
Return error.
</li>
				</ol>
			</li>
			<li>
%~cp ~LET 次に与える~pointerが指す`索引~gb18030範囲集~cp$
⇒
(( `~gb1$ ~MINUS `81^X ) ~MUL ( 10 ~MUL 126 ~MUL 10 )) ~PLUS
(( `~gb2$ ~MINUS `30^X ) ~MUL ( 10 ~MUL 126 )) ~PLUS
(( `~gb3$ ~MINUS `81^X ) ~MUL 10 ) ~PLUS
( %~byte ~MINUS `30^X )
◎
Let code point be the index gb18030 ranges code point for ((gb18030 first − 0x81) × (10 × 126 × 10)) + ((gb18030 second − 0x30) × (10 × 126)) + ((gb18030 third − 0x81) × 10) + byte − 0x30.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
◎
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
			<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$i
◎
If code point is null, return error.
</li>
			<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb2$ ~NEQ `00^X
］：
◎
If gb18030 second is not 0x00, then:
</p>
		<ol>
			<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~gb3$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 third to byte and return continue.
</li>
			<li>
`入出力~queueに前付加する$( %入出力~queue, ~byte列 [ `~gb2$, %~byte ] )
◎
Prepend gb18030 second followed by byte to ioQueue,＼
</li>
			<li>
( `~gb1$, `~gb2$ ) ~SET ( `00^X, `00^X )
◎
set gb18030 first and gb18030 second to 0x00, and＼
</li>
			<li>
~RET `~error$i
◎
return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb1$ ~NEQ `00^X
］：
◎
If gb18030 first is not 0x00, then:
</p>
		<ol>
			<li>
~IF［
%~byte ~IN { `30^X 〜 `39^X }
］
⇒＃
`~gb2$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is in the range 0x30 to 0x39, inclusive, set gb18030 second to byte and return continue.
</li>
			<li>
%~lead ~LET `~gb1$
◎
Let lead be gb18030 first,＼
</li>
			<li>
%~pointer ~LET ~NULL
◎
let pointer be null, and＼
</li>
			<li>
`~gb1$ ~SET `00^X
◎
set gb18030 first to 0x00.
</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if byte is less than 0x7F, otherwise 0x41.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `80^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS %~offset )
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 + (byte − offset).
</li>
			<li>
%~cp ~LET %~pointer に応じて
⇒
~NULL ならば ~NULL ／
~ELSE_ `索引~gb18030$ の中で %~pointer が指す`索引~cp$
◎
Let code point be null if pointer is null, otherwise the index code point for pointer in index gb18030.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
`入出力~queueに前付加する$( %入出力~queue, %~byte )
◎
If byte is an ASCII byte, prepend byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~gb1$ ~SET %~byte ；
~RET `継続-$i
◎
↓</li>
	<li>
~RET %~byte に応じて
⇒＃
`~ASCII~byte$ならば ~cp [ %~byte ] ／
`80^X ならば ~cp [ `20AC^U ] ／
`FF^X ならば `~error$i
◎
If byte is an ASCII byte, return a code point whose value is byte.
◎
If byte is 0x80, return code point U+20AC.
◎
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 first to byte and return continue.
◎
Return error.
</li>
</ol>

			</section>
			<section id="gb18030-encoder">
<h4 title="gb18030 encoder">10.2.2. ~gb18030符号化器</h4>

<p>
各［
`gb18030$n の`符号化器$
］には、
次が結付けられる
⇒
`~GBK用か@
（初期~時 ~F ）
◎
gb18030’s encoder has an associated is GBK (initially false).
</p>

<p>
`gb18030$n の`符号化器$の`~handler$は、
所与の
( %入出力~queue, %~cp )
に対し，次を走らす：
◎
gb18030’s encoder’s handler, given ioQueue and code point, runs these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If code point is end-of-queue, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
~IF［
%~cp ~EQ `E5E5^U
］
⇒
~RET `~error$i( %~cp )
◎
If code point is U+E5E5, return error with code point.
</p>

<p class="note">注記：
配備-済みな内容との互換性を得るため、
`索引~gb18030$ は［
`A3^X `A0^X
］を `E5E5^U ではなく `3000^U に対応付けている。
したがって往来できない。
◎
Index gb18030 maps 0xA3 0xA0 to U+3000 rather than U+E5E5 for compatibility with deployed content. Therefore it cannot roundtrip.
</p>

</li>
	<li>
~IF［
`~GBK用か$ ~EQ ~T
］~AND［
%~cp ~EQ `20AC^U
］
⇒
~RET ~byte列 [ `80^X ]
◎
If is GBK is true and code point is U+20AC, return byte 0x80.
</li>
	<li>
%~pointer ~LET
`索引~gb18030$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index gb18030.
</li>
	<li>
<p>
~IF［
%~pointer ~NEQ ~NULL
］：
◎
If pointer is non-null, then:
</p>
		<ol>
			<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
◎
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET %~pointer ~MOD 190
◎
Let trail be pointer % 190.
</li>
			<li>
%~offset ~LET ［
%~trail ~IN { `00^X 〜 `3E^X } ならば `40^X【！0x7F-0x40 】 ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if trail is less than 0x3F, otherwise 0x41.
</li>
			<li>
~RET ~byte列 [ %~lead, ( %~trail ~PLUS %~offset ) ]
◎
Return two bytes whose values are lead and trail + offset.
</li>
		</ol>
	</li>
	<li>
~IF［
`~GBK用か$ ~EQ ~T
］
⇒
~RET `~error$i( %~cp )
◎
If is GBK is true, return error with code point.
</li>
	<li>
%~pointer ~SET
%~cp
を指す`索引~gb18030範囲集~pointer$
◎
Set pointer to the index gb18030 ranges pointer for code point.
</li>
	<li>
%byte1 ~LET %~pointer ~DIV ( 10 ~MUL 126 ~MUL 10 )
◎
Let byte1 be pointer / (10 × 126 × 10).
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 ~MUL 10 )
◎
Set pointer to pointer % (10 × 126 × 10).
</li>
	<li>
%byte2 ~LET %~pointer ~DIV ( 10 ~MUL 126 )
◎
Let byte2 be pointer / (10 × 126).
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 )
◎
Set pointer to pointer % (10 × 126).
</li>
	<li>
%byte3 ~LET %~pointer ~DIV 10
◎
Let byte3 be pointer / 10.
</li>
	<li>
%byte4 ~LET %~pointer ~MOD 10
◎
Let byte4 be pointer % 10.
</li>
	<li>
~RET ~byte列 [
( %byte1 ~PLUS `81^X ),
( %byte2 ~PLUS `30^X ),
( %byte3 ~PLUS `81^X ),
( %byte4 ~PLUS `30^X )
]
◎
Return four bytes whose values are byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(traditional)-encodings">
<h2 title="Legacy multi-byte Chinese (traditional) encodings">11. 旧来の複-~byte~Chinese（繁体字）符号化法</h2>

【！ Lead:  0x81 to 0xFE ／ Trail: 0x40 to 0x7E or 0xA1 to 0xFE 】

		<section id="big5">
<h3 title="Big5">11.1. ~Big5</h3>

			<section id="big5-decoder">
<h4 title="Big5 decoder">11.1.1. ~Big5復号器</h4>

<p>
各［
`Big5$n の`復号器$
］には、
次が結付けられる
⇒
`~Big5~lead@（初期~時 `00^X ）
◎
Big5’s decoder has an associated Big5 lead (initially 0x00).
</p>

<p>
`Big5$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，次を走らす：
◎
Big5’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
</p>
		<ol>
			<li>
~IF［
`~Big5~lead$ ~NEQ `00^X
］
⇒＃
`~Big5~lead$ ~SET `00^X ；
~RET `~error$i
</li>
			<li>
~RET `完遂d$i
</li>
		</ol>
◎
If byte is end-of-queue and Big5 lead is not 0x00, set Big5 lead to 0x00 and return error.
◎
If byte is end-of-queue and Big5 lead is 0x00, return finished.
</li>
	<li>
<p>
~IF［
`~Big5~lead$ ~NEQ `00^X
］：
◎
If Big5 lead is not 0x00,＼
</p>
		<ol>
			<li>
%~lead ~LET `~Big5~lead$
◎
 let lead be Big5 lead,＼
</li>
			<li>
%~pointer ~LET ~NULL
◎
let pointer be null,＼
</li>
			<li>
`~Big5~lead$ ~SET `00^X
◎
set Big5 lead to 0x00, and then:
</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `62^X 【！ 0x62 = 0xA1-0x7E+1+0x40 】
］
◎
Let offset be 0x40 if byte is less than 0x7F, otherwise 0x62.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `A1^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 157 ~PLUS ( %~byte ~MINUS %~offset )
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1 to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 + (byte − offset).
</li>
			<li>
<p>
~IF［
下の表の中で， 1 列目が %~pointer に等しい行がある
］
⇒
~RET 同じ行の 2 列目に与える~cp列（ `2 個の^em ~cpからなる）
◎
If there is a row in the table below whose first column is pointer, return the two code points listed in its second column (the third column is irrelevant):
</p>

【！ https://www.unicode.org/Public/UNIDATA/NamedSequences.txt 】
<div>
<table><thead>
<tr><th>~pointer
<th>~cp
<th>注記（この段には関連しない）
<tbody id="_big5-lead">

<tr><td>1133【！ 0x88 0x62 】
<td>`00CA^U `0304^U
<td>Ê̄ 
( `LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON^cn )

<tr><td>1135【！ 0x88 0x64 】
<td>`00CA^U `030C^U
<td>Ê̌ 
( `LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON^cn )

<tr><td>1164【！ 0x88 0xA3 】
<td>`00EA^U `0304^U
<td>ê̄ 
( `LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON^cn )

<tr><td>1166【！ 0x88 0xA5 】
<td>`00EA^U `030C^U
<td>ê̌ 
( `LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON^cn )
</table>

【！~UA／環境／言語~codeによっては、~glyphが結合されず，正しく表示されないかもしれない。】
【！lang=ja の下では正しく表示されない~UAがある】
【！lang=en の下でも正しく表示しない~UAがある】
【！文字参照（&#x00EA;&#x030C;）を利用すると異なる表示になる~UAもある】

◎
Pointer｜Code points｜Notes
1133｜U+00CA U+0304｜Ê̄ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON)
1135｜U+00CA U+030C｜Ê̌ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON)
1164｜U+00EA U+0304｜ê̄ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON)
1166｜U+00EA U+030C｜ê̌ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON)
</div>

<p class="note">注記：
`索引$ は単独の~cpに制限されるので、
これらの~pointerにはこの表が利用される。
◎
Since indexes are limited to single code points this table is used for these pointers.
</p>
			</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~Big5$ の中で %~pointer が指す`索引~cp$
］
◎
Let code point be null if pointer is null, otherwise the index code point for pointer in index Big5.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
`入出力~queueに前付加する$( %入出力~queue, %~byte )
◎
If byte is an ASCII byte, prepend byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~Big5~lead$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is in the range 0x81 to 0xFE, inclusive, set Big5 lead to byte and return continue.
</li>
	<li>
~RET `~error$i
◎
Return error.
</li>
</ol>

			</section>
			<section id="big5-encoder">
<h4 title="Big5 encoder">11.1.2. ~Big5符号化器</h4>

<p>
`Big5$n の`符号化器$の`~handler$は、
所与の
( %入出力~queue, %~cp )
に対し，次を走らす：
◎
Big5’s encoder’s handler, given ioQueue and code point, runs these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If code point is end-of-queue, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET %~cp を指す`索引~Big5~pointer$
◎
Let pointer be the index Big5 pointer for code point.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET `~error$i( %~cp )
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 157 ) ~PLUS `81^X
◎
Let lead be pointer / 157 + 0x81.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 157
◎
Let trail be pointer % 157.
</li>
	<li>
%~offset ~LET ［
%~trail ~IN { `00^X 〜 `3E^X } ならば `40^X【！0x7F-0x40 】 ／
~ELSE_ `62^X【！0xA1-0x3F 】
］
◎
Let offset be 0x40 if trail is less than 0x3F, otherwise 0x62.
</li>
	<li>
~RET ~byte列 [ %~lead, ( %~trail ~PLUS %~offset) ]
◎
Return two bytes whose values are lead and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-japanese-encodings">
<h2 title="Legacy multi-byte Japanese encodings">12. 旧来の複-~byte~Japanese符号化法</h2>

		<section id="euc-jp">
<h3 title="EUC-JP">12.1. ~EUC-JP</h3>

【！ ~IANA-a/charset-reg/CP51932 】

			<section id="euc-jp-decoder">
<h4 title="EUC-JP decoder">12.1.1. ~EUC-JP復号器</h4>

<p>
各［
`EUC-JP$n の`復号器$
］には、
次が結付けられる
⇒＃
`~EUC-JP~jis0212@（初期~時 ~F ）；
`~EUC-JP~lead@（初期~時 `00^X ）
◎
EUC-JP’s decoder has an associated EUC-JP jis0212 (initially false) and EUC-JP lead (initially 0x00).
</p>

<p>
`EUC-JP$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，次を走らす：
◎
EUC-JP’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
`~EUC-JP~lead$ ~NEQ `00^X
］
⇒＃
`~EUC-JP~lead$ ~SET `00^X ；
~RET `~error$i
◎
If byte is end-of-queue and EUC-JP lead is not 0x00, set EUC-JP lead to 0x00, and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$i
◎
If byte is end-of-queue and EUC-JP lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
~IF［
`~EUC-JP~lead$ ~EQ `8E^X
］~AND［
%~byte ~IN { `A1^X 〜 `DF^X }
］
【！ katakana; subtraction is done first to avoid upsetting compilers 】
⇒＃
`~EUC-JP~lead$ ~SET `00^X ；
~RET ~cp [ `FF61^X ~MINUS `A1^X ~PLUS %~byte ]
◎
If EUC-JP lead is 0x8E and byte is in the range 0xA1 to 0xDF, inclusive, set EUC-JP lead to 0x00 and return a code point whose value is 0xFF61 − 0xA1 + byte.
</li>
	<li>
~IF［
`~EUC-JP~lead$ ~EQ `8F^X
］~AND［
%~byte ~IN { `A1^X 〜 `FE^X }
］
⇒＃
`~EUC-JP~jis0212$ ~SET ~T ；
`~EUC-JP~lead$ ~SET %~byte ；
~RET `継続-$i
◎
If EUC-JP lead is 0x8F and byte is in the range 0xA1 to 0xFE, inclusive, set EUC-JP jis0212 to true, set EUC-JP lead to byte, and return continue.
</li>
	<li>
<p>
~IF［
`~EUC-JP~lead$ ~NEQ `00^X
］：
◎
If EUC-JP lead is not 0x00,＼
</p>
		<ol>
			<li>
%~lead ~LET `~EUC-JP~lead$
◎
let lead be EUC-JP lead,＼
</li>
			<li>
`~EUC-JP~lead$ ~SET `00^X
◎
set EUC-JP lead to 0x00, and then:
</li>
			<li>
%~cp ~LET ~NULL
◎
Let code point be null.
</li>
			<li>
<p>
~IF［
%~lead ~IN { `A1^X 〜 `FE^X }
］~AND［
%~byte ~IN { `A1^X 〜 `FE^X }
］：
</p>
				<ol>
					<li>
%索引 ~LET `~EUC-JP~jis0212$に応じて
⇒＃
~F ならば`索引~jis0208$ ／
~T ならば `索引~jis0212$
</li>
					<li>
%~cp ~SET %索引 の中で
( ( %~lead ~MINUS `A1^X ) ~MUL 94 ~PLUS %~byte ~MINUS `A1^X )
が指す`索引~cp$
</li>
				</ol>
◎
If lead and byte are both in the range 0xA1 to 0xFE, inclusive, then set code point to the index code point for (lead − 0xA1) × 94 + byte − 0xA1 in index jis0208 if EUC-JP jis0212 is false and in index jis0212 otherwise.
</li>
			<li>
`~EUC-JP~jis0212$ ~SET ~F
◎
Set EUC-JP jis0212 to false.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
`入出力~queueに前付加する$( %入出力~queue, %~byte )
◎
If byte is an ASCII byte, prepend byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `8E^X, `8F^X, `A1^X 〜 `FE^X }
］
⇒＃
`~EUC-JP~lead$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE, inclusive, set EUC-JP lead to byte and return continue.
</li>
	<li>
~RET `~error$i
◎
Return error.
</li>
</ol>

			</section>
			<section id="euc-jp-encoder">
<h4 title="EUC-JP encoder">12.1.2. ~EUC-JP符号化器</h4>

<p>
`EUC-JP$n の`符号化器$の`~handler$は、
所与の
( %入出力~queue, %~cp )
に対し，次を走らす：
◎
EUC-JP’s encoder’s handler, given ioQueue and code point, runs these steps:
</p>
<ol>
	<li>
%結果 ~LET %~cp に応じて
⇒＃
`~EoQ$ ならば `完遂d$i ／
`~ASCII~cp$ならば ~byte列 [ %~cp ] ／
`00A5^U ならば ~byte列 [ `5C^X ] ／
`203E^U ならば ~byte列 [ `7E^X ] ／
`FF61^U 〜 `FF9F^U ならば ~byte列 [ `8E^X, ( %~cp ~MINUS `FF61^X ~PLUS `A1^X ) ] ／
~ELSE_ ~NULL
◎
If code point is end-of-queue, return finished.
◎
If code point is an ASCII code point, return a byte whose value is code point.
◎
If code point is U+00A5, return byte 0x5C.
◎
If code point is U+203E, return byte 0x7E.
◎
If code point is in the range U+FF61 to U+FF9F, inclusive, return two bytes whose values are 0x8E and code point − 0xFF61 + 0xA1.
</li>
	<li>
~IF［
%結果 ~NEQ ~NULL
］
⇒
~RET %結果
◎
↑</li>
	<li>
~IF［
%~cp ~EQ `2212^U
］
⇒
%~cp ~SET `FF0D^U
◎
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
<p>
%~pointer ~LET `索引~jis0208$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index jis0208.
</p>

<p class="note">注記：
%~pointer は、
~NULL でなければ，`索引~jis0208$と~pointer演算の資質に因り 8836 未満になる。
◎
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET `~error$i( %~cp )
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `A1^X
◎
Let lead be pointer / 94 + 0xA1.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `A1^X
◎
Let trail be pointer % 94 + 0xA1.
</li>
	<li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="iso-2022-jp">
<h3 title="ISO-2022-JP">12.2. ~ISO-2022-JP</h3>

【！ https://tools.ietf.org/html/rfc1468】
【！ https://tools.ietf.org/html/rfc2237 (iso-2022-jp-1; not used)】
【！ "ESC ) I" is from iso-2022-jp-3 reportedly】

			<section id="iso-2022-jp-decoder">
<h4 title="ISO-2022-JP decoder">12.2.1. ~ISO-2022-JP復号器</h4>

<p>
各［
`ISO-2022-JP$n の`復号器$
］には、
次が結付けられる
⇒＃
`~ISO-2022-JP復号器~状態@（初期~時 `ASCII$i ）,
`~ISO-2022-JP復号器~出力~状態@（初期~時 `ASCII$i ）,
`~ISO-2022-JP~lead@（初期~時 `00^X ）,
`~ISO-2022-JP出力@（初期~時 ~F ）
◎
ISO-2022-JP’s decoder has an associated ISO-2022-JP decoder state (initially ASCII), ISO-2022-JP decoder output state (initially ASCII), ISO-2022-JP lead (initially 0x00), and ISO-2022-JP output (initially false).
</p>

<p>
`ISO-2022-JP$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，`~ISO-2022-JP復号器~状態$に応じて 次を走らす：
◎
ISO-2022-JP’s decoder’s handler, given ioQueue and byte, runs these steps, switching on ISO-2022-JP decoder state:
</p>

<dl class="switch">
	<dt>`ASCII@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~escape開始$i ；
~RET `継続-$i
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`0E^X, `0F^X, `1B^X 以外の`~ASCII~byte$
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET ~cp [ %~byte ]
◎
0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B
• Set ISO-2022-JP output to false and return a code point whose value is byte.
</li>
			<li>
`~EoQ$
⇒＃
~RET `完遂d$i
◎
end-of-queue
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET `~error$i
◎
Otherwise
• Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`Roman@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~escape開始$i ；
~RET `継続-$i
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`5C^X
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET ~cp [ `00A5^U ]
◎
0x5C
• Set ISO-2022-JP output to false and return code point U+00A5.
</li>
			<li>
`7E^X
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET ~cp [ `203E^U ]
◎
0x7E
• Set ISO-2022-JP output to false and return code point U+203E.
</li>
			<li>
`0E^X, `0F^X, `1B^X, `5C^X, `7E^X
以外の`~ASCII~byte$
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET ~cp [ %~byte ]
◎
0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E
• Set ISO-2022-JP output to false and return a code point whose value is byte.
</li>
			<li>
`~EoQ$
⇒＃
~RET `完遂d$i
◎
end-of-queue
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET `~error$i
◎
Otherwise
• Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`katakana@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~escape開始$i ；
~RET `継続-$i
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`21^X 〜 `5F^X
【！ katakana; subtraction is done first to avoid upsetting compilers 】
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET ~cp [ `FF61^X ~MINUS `21^X ~PLUS %~byte ]
◎
0x21 to 0x5F
• Set ISO-2022-JP output to false and return a code point whose value is 0xFF61 − 0x21 + byte.
</li>
			<li>
`~EoQ$
⇒＃
~RET `完遂d$i
◎
end-of-queue
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET `~error$i
◎
Otherwise
• Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`~lead~byte@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~escape開始$i ；
~RET `継続-$i
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`21^X 〜 `7E^X
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
`~ISO-2022-JP~lead$ ~SET %~byte ；
`~ISO-2022-JP復号器~状態$ ~SET `~trail~byte$i ；
~RET `継続-$i
◎
0x21 to 0x7E
• Set ISO-2022-JP output to false, ISO-2022-JP lead to byte, ISO-2022-JP decoder state to trail byte, and return continue.
</li>
			<li>
`~EoQ$
⇒＃
~RET `完遂d$i
◎
end-of-queue
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET `~error$i
◎
Otherwise
• Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`~trail~byte@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
【！ iso-2022-jp decoder output state is still lead byte 】
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~escape開始$i ；
~RET `~error$i
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return error.
</li>
			<li>
<p>
`21^X 〜 `7E^X
：
◎
0x21 to 0x7E
</p>
				<ol>
					<li>
`~ISO-2022-JP復号器~状態$ ~SET `~lead~byte$i
◎
Set the ISO-2022-JP decoder state to lead byte.
</li>
					<li>
%pointer ~LET ( `~ISO-2022-JP~lead$ ~MINUS `21^X ) ~MUL 94 ~PLUS %~byte ~MINUS `21^X
◎
Let pointer be (ISO-2022-JP lead − 0x21) × 94 + byte − 0x21.
</li>
					<li>
%~cp ~LET
`索引~jis0208$ の中で %~pointer が指す`索引~cp$
◎
Let code point be the index code point for pointer in index jis0208.
</li>
					<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$i
◎
If code point is null, return error.
</li>
					<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
				</ol>
			</li>
			<li>
`~EoQ$
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~lead~byte$i ；
~RET `~error$i
◎
end-of-queue
• Set the ISO-2022-JP decoder state to lead byte and return error.
</li>
			<li>
その他
【！ iso-2022-jp decoder output state is still lead byte 】
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~lead~byte$i ；
~RET `~error$i
◎
Otherwise
• Set ISO-2022-JP decoder state to lead byte and return error.
</li>
		</ol>
	</dd>

	<dt>`~escape開始@i</dt>
	<dd>
		<ol>
			<li>
~IF［
%~byte ~IN { `24^X【！ $ 】, `28^X【！ ( 】 }
］
⇒＃
`~ISO-2022-JP~lead$ ~SET %~byte ；
`~ISO-2022-JP復号器~状態$ ~SET `~escape$i ；
~RET `継続-$i
◎
If byte is either 0x24 or 0x28, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to escape, and return continue.
</li>
			<li>
~IF［
%~byte ~NEQ `~EoQ$
］
⇒
`入出力~queueに前付加する$( %入出力~queue, %~byte )
◎
If byte is not end-of-queue, then prepend byte to ioQueue.
</li>
			<li>
`~ISO-2022-JP出力$ ~SET ~F
◎
Set ISO-2022-JP output to false,＼
</li>
			<li>
`~ISO-2022-JP復号器~状態$ ~SET `~ISO-2022-JP復号器~出力~状態$
◎
ISO-2022-JP decoder state to ISO-2022-JP decoder output state, and＼
</li>
			<li>
~RET `~error$i
◎
return error.
</li>
		</ol>
	</dd>

	<dt>`~escape@i</dt>
	<dd>
		<ol>
			<li>
%~lead ~LET `~ISO-2022-JP~lead$
◎
Let lead be ISO-2022-JP lead and＼
</li>
			<li>
`~ISO-2022-JP~lead$ ~SET `00^X
◎
set ISO-2022-JP lead to 0x00.
</li>
			<li>
%状態 ~LET
( %~lead, %~byte )
に応じて
⇒＃
( `28^X, `42^X【！B 】 ) ならば `ASCII$i ／
( `28^X, `4A^X【！J 】 ) ならば `Roman$i1 ／
( `28^X, `49^X【！I 】 ) ならば `katakana$i ／
( `24^X, `40^X【！@ 】 ) ならば `~lead~byte$i ／
( `24^X, `42^X【！B 】 ) ならば `~lead~byte$i ／
~ELSE_ ~NULL
◎
Let state be null.
◎
If lead is 0x28 and byte is 0x42, set state to ASCII.
◎
If lead is 0x28 and byte is 0x4A, set state to Roman.
◎
If lead is 0x28 and byte is 0x49, set state to katakana.
◎
If lead is 0x24 and byte is either 0x40 or 0x42, set state to lead byte.
</li>
			<li>
<p>
~IF［
%状態 ~NEQ ~NULL
］：
◎
If state is non-null, then:
</p>
				<ol>
					<li>
`~ISO-2022-JP復号器~状態$ ~SET %状態
◎
↓</li>
					<li>
`~ISO-2022-JP復号器~出力~状態$ ~SET %状態
◎
Set ISO-2022-JP decoder state and ISO-2022-JP decoder output state to state.
</li>
					<li>
%出力 ~LET `~ISO-2022-JP出力$
◎
Let output be the value of ISO-2022-JP output.
</li>
					<li>
`~ISO-2022-JP出力$ ~SET ~T
◎
Set ISO-2022-JP output to true.
</li>
					<li>
~RET %出力 に応じて
⇒＃
~F ならば `継続-$i ／
~T ならば `~error$i
◎
Return continue, if output is false, and error otherwise.
</li>
				</ol>
			</li>
			<li>
~IF［
%~byte ~EQ `~EoQ$
］
⇒
`入出力~queueに前付加する$( %入出力~queue, %~lead )
◎
If byte is end-of-queue, then prepend lead to ioQueue.＼
</li>
			<li>
~ELSE
⇒
`入出力~queueに前付加する$( %入出力~queue, ~byte列 [ %~lead, %~byte ] )
◎
Otherwise, prepend lead and byte to ioQueue.
</li>
			<li>
`~ISO-2022-JP出力$ ~SET ~F
◎
Set ISO-2022-JP output to false,＼
</li>
			<li>
`~ISO-2022-JP復号器~状態$ ~SET `~ISO-2022-JP復号器~出力~状態$
◎
ISO-2022-JP decoder state to ISO-2022-JP decoder output state and＼
</li>
			<li>
~RET `~error$i
◎
return error.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="iso-2022-jp-encoder">
<h4 title="ISO-2022-JP encoder">12.2.2. ~ISO-2022-JP符号化器</h4>

<div class="note">

<p>注記：
`~ISO-2022-JP符号化器$は、［
複数の出力を連結した結果を対応する`復号器$にかけたとき，
`~error$i になり得る
］ような，唯一の`符号化器$である。
◎
The ISO-2022-JP encoder is the only encoder for which the concatenation of multiple outputs can result in an error when run through the corresponding decoder.
</p>

<p class="example">
`00A5^U を符号化した結果は
[ `1B^X `28^X `4A^X `5C^X `1B^X `28^X `42^X ]
になる。
その結果に同じ結果を連結してから復号した結果は、
[ `00A5^U `FFFD^U `00A5^U ]
になる。
◎
Encoding U+00A5 gives 0x1B 0x28 0x4A 0x5C 0x1B 0x28 0x42. Doing that twice, concatenating the results, and then decoding yields U+00A5 U+FFFD U+00A5.
</p>

</div>

<p>
各［
`ISO-2022-JP$n の`符号化器$
］には、
次が結付けられる
⇒
`~ISO-2022-JP符号化器~状態@
— 次のいずれかをとり得る（初期~時 `ASCII$i1 ）
⇒
`ASCII@i1 ／
`Roman@i1 ／
`jis0208@i1
◎
ISO-2022-JP’s encoder has an associated ISO-2022-JP encoder state which is ASCII, Roman, or jis0208 (initially ASCII).
</p>

<p>
`ISO-2022-JP$n の`符号化器$の`~handler$は、
所与の
( %入出力~queue, %~cp )
に対し，次を走らす：
◎
ISO-2022-JP’s encoder’s handler, given ioQueue and code point, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~cp ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
`~ISO-2022-JP符号化器~状態$ ~NEQ `ASCII$i1
］
⇒＃
`~ISO-2022-JP符号化器~状態$ ~SET `ASCII$i1 ；
~RET ~byte列 [ `1B^X, `28^X, `42^X ]
◎
If code point is end-of-queue and ISO-2022-JP encoder state is not ASCII, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
			<li>
~RET `完遂d$i
◎
If code point is end-of-queue and ISO-2022-JP encoder state is ASCII, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~ISO-2022-JP符号化器~状態$ ~IN
{ `ASCII$i1, `Roman$i1 }
］~AND［
%~cp ~IN { `000E^U, `000F^U, `001B^U }
］
⇒
~RET `~error$i( `FFFD^U )
◎
If ISO-2022-JP encoder state is ASCII or Roman, and code point is U+000E, U+000F, or U+001B, return error with U+FFFD.
</p>

<p class="note">注記：
攻撃を防ぐため、
ここでは，［
%~cp ではなく， `FFFD^U
］を返す。
◎
This returns U+FFFD rather than code point to prevent attacks.
</p>
【！ https://github.com/whatwg/encoding/issues/15 】
	</li>
	<li>
~IF［
`~ISO-2022-JP符号化器~状態$ ~EQ `ASCII$i1
］~AND［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If ISO-2022-JP encoder state is ASCII and code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
~IF［
`~ISO-2022-JP符号化器~状態$ ~EQ `Roman$i1
］：
</p>
		<ol>
			<li>
%結果 ~LET %~cp に応じて
⇒＃
`005C^U, `007E^U 以外の`~ASCII~cp$ならば ~byte列 [ %~cp ] ／
`00A5^U ならば ~byte列 [ `5C^X ] ／
`203E^U ならば ~byte列 [ `7E^X ] ／
~ELSE_ ~NULL
</li>
			<li>
~IF［
%結果 ~NEQ ~NULL
］
⇒
~RET %結果
◎
↑</li>
		</ol>
◎
If ISO-2022-JP encoder state is Roman and code point is an ASCII code point, excluding U+005C and U+007E, or is U+00A5 or U+203E, then:
• If code point is an ASCII code point, return a byte whose value is code point.
• If code point is U+00A5, return byte 0x5C.
• If code point is U+203E, return byte 0x7E.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］~AND［
`~ISO-2022-JP符号化器~状態$ ~NEQ `ASCII$i1
］
⇒＃
`入出力~queueに前付加する$( %入出力~queue, %~cp )；
`~ISO-2022-JP符号化器~状態$ ~SET `ASCII$i1 ；
~RET ~byte列 [ `1B^X, `28^X, `42^X ]
◎
If code point is an ASCII code point, and ISO-2022-JP encoder state is not ASCII, prepend code point to ioQueue, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
	<li>
~IF［
%~cp ~NIN { `00A5^U, `203E^U }
］~AND［
`~ISO-2022-JP符号化器~状態$ ~NEQ `Roman$i1
］
⇒＃
`入出力~queueに前付加する$( %入出力~queue, %~cp )；
`~ISO-2022-JP符号化器~状態$ ~SET `Roman$i1 ；
~RET ~byte列 [ `1B^X, `28^X, `4A^X ]
◎
If code point is either U+00A5 or U+203E, and ISO-2022-JP encoder state is not Roman, prepend code point to ioQueue, set ISO-2022-JP encoder state to Roman, and return three bytes 0x1B 0x28 0x4A.
</li>
	<li>
~IF［
%~cp ~EQ `2212^U
］
⇒
%~cp ~SET `FF0D^U
◎
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
~IF［
%~cp ~IN { `FF61^U 〜 `FF9F^U }
］
⇒
%~cp ~SET `索引~ISO-2022-JP~katakana$の中で
( %~cp ~MINUS `FF61^X )
が指す`索引~cp$
◎
If code point is in the range U+FF61 to U+FF9F, inclusive, set it to the index code point for code point − 0xFF61 in index ISO-2022-JP katakana.
</li>
	<li>
<p>
%~pointer ~LET `索引~jis0208$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index jis0208.
</p>

<p class="note">注記：
%~pointer は、
~NULL でなければ，`索引~jis0208$と~pointer演算の資質に因り 8836 未満になる。
◎
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
<p>
~IF［
%~pointer ~EQ ~NULL
］：
◎
If pointer is null, then:
</p>
		<ol>
			<li>
~IF［
`~ISO-2022-JP符号化器~状態$ ~EQ `jis0208$i1
］
⇒＃
`入出力~queueに前付加する$( %入出力~queue, %~cp )；
`~ISO-2022-JP符号化器~状態$ ~SET `ASCII$i1 ；
~RET ~byte列 [ `1B^X, `28^X, `42^X ]
◎
If ISO-2022-JP encoder state is jis0208, then prepend code point to ioQueue, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
			<li>
~RET `~error$i( %~cp )
◎
Return error with code point.
</li>
		</ol>
	</li>
	<li>
~IF［
`~ISO-2022-JP符号化器~状態$ ~NEQ `jis0208$i1
］
⇒＃
`入出力~queueに前付加する$( %入出力~queue, %~cp )；
`~ISO-2022-JP符号化器~状態$ ~SET `jis0208$i1 ；
~RET ~byte列 [ `1B^X, `24^X, `42^X ]
◎
If ISO-2022-JP encoder state is not jis0208, prepend code point to ioQueue, set ISO-2022-JP encoder state to jis0208, and return three bytes 0x1B 0x24 0x42.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `21^X
◎
Let lead be pointer / 94 + 0x21.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `21^X
◎
Let trail be pointer % 94 + 0x21.
</li>
	<li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="shift_jis">
<h3 title="Shift_JIS">12.3. ~Shift_JIS</h3>

			<section id="shift_jis-decoder">
<h4 title="Shift_JIS decoder">12.3.1. ~Shift_JIS復号器</h4>

<p>
各［
`Shift_JIS$n の`復号器$
］には、
次が結付けられる
⇒
`~Shift_JIS~lead@（初期~時 `00^X ）
◎
Shift_JIS’s decoder has an associated Shift_JIS lead (initially 0x00).
</p>

<p>
`Shift_JIS$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，次を走らす：
◎
Shift_JIS’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
`~Shift_JIS~lead$ ~NEQ `00^X
］
⇒＃
`~Shift_JIS~lead$ ~SET `00^X ；
~RET `~error$i
◎
If byte is end-of-queue and Shift_JIS lead is not 0x00, set Shift_JIS lead to 0x00 and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$i
◎
If byte is end-of-queue and Shift_JIS lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~Shift_JIS~lead$ ~NEQ `00^X
］：
◎
If Shift_JIS lead is not 0x00,＼
</p>
		<ol>
			<li>
%~lead ~LET `~Shift_JIS~lead$
◎
let lead be Shift_JIS lead,＼
</li>
			<li>
%~pointer ~LET ~NULL
◎
let pointer be null,＼
</li>
			<li>
`~Shift_JIS~lead$ ~SET `00^X
◎
set Shift_JIS lead to 0x00, and then:
</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if byte is less than 0x7F, otherwise 0x41.
</li>
			<li>
%~lead~offset ~LET ［
%~lead ~IN { `00^X 〜 `9F^X } ならば `81^X ／
~ELSE_ `C1^X
］
◎
Let lead offset be 0x81 if lead is less than 0xA0, otherwise 0xC1.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `80^X 〜 `FC^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS %~lead~offset ) ~MUL 188 ~PLUS %~byte ~MINUS %~offset
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFC, inclusive, set pointer to (lead − lead offset) × 188 + byte − offset.
</li>
			<li>
<p>
~IF［
%~pointer ~IN { 8836 〜 10715 }
］
【！ subtraction is done first to avoid upsetting compilers 】
⇒
~RET ~cp [ `E000^X ~MINUS 8836 ~PLUS %~pointer ]
◎
If pointer is in the range 8836 to 10715, inclusive, return a code point whose value is 0xE000 − 8836 + pointer.
</p>

<p class="note">注記：
これは EUDC として周知な，旧来の Windows によるものと相互運用可能にする。
【！ PUA 】
◎
This is interoperable legacy from Windows known as EUDC.
</p>

<p class="trans-note">【
EUDC — いわゆる外字~用の機能。
】【
8836 = 94 ~MUL 94 は~Shift_JIS（ JIS X 0208 ）の
`<a href="https://ja.wikipedia.org/wiki/%E5%8C%BA%E7%82%B9%E7%95%AA%E5%8F%B7">区点番号</a>^_
の総数。
結果の~cpは~Unicode私用領域に入る。
】</p>

			</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~jis0208$ の中で %~pointer が指す`索引~cp$
］
◎
Let code point be null if pointer is null, otherwise the index code point for pointer in index jis0208.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
`入出力~queueに前付加する$( %入出力~queue, %~byte )
◎
If byte is an ASCII byte, prepend byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN { `~ASCII~byte$, `80^X}
］
⇒
~RET ~cp [ %~byte ]
【！ Opera has 0x7E 】
◎
If byte is an ASCII byte or 0x80, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `A1^X 〜 `DF^X }
］
【！ katakana; subtraction is done first to avoid upsetting compilers 】
⇒
~RET ~cp [ `FF61^X ~PLUS ( %~byte ~MINUS `A1^X ) ]
◎
If byte is in the range 0xA1 to 0xDF, inclusive, return a code point whose value is 0xFF61 − 0xA1 + byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `9F^X, `E0^X 〜 `FC^X }
］
⇒＃
`~Shift_JIS~lead$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0 to 0xFC, inclusive, set Shift_JIS lead to byte and return continue.
</li>
	<li>
~RET `~error$i
◎
Return error.
</li>
</ol>

			</section>
			<section id="shift_jis-encoder">
<h4 title="Shift_JIS encoder">12.3.2. ~Shift_JIS符号化器</h4>

<p>
`Shift_JIS$n の`符号化器$の`~handler$は、
所与の
( %入出力~queue, %~cp )
に対し，次を走らす：
◎
Shift_JIS’s encoder’s handler, given ioQueue and code point, runs these steps:
</p>
<ol>
	<li>
%結果 ~LET %~cp に応じて
⇒＃
`~EoQ$ ならば `完遂d$i ／
`~ASCII~cp$ならば ~byte列 [ %~cp ] ／
`0080^U ならば ~byte列 [ %~cp ] ／
`00A5^U ならば ~byte列 [ `5C^X ] ／
`203E^U ならば ~byte列 [ `7E^X ] ／
`FF61^U 〜 `FF9F^U ならば ~byte列 [ ( %~cp ~MINUS `FF61^X ) ~PLUS `A1^X ] ／
~ELSE_ ~NULL
◎
If code point is end-of-queue, return finished.
◎
If code point is an ASCII code point or U+0080, return a byte whose value is code point.
◎
If code point is U+00A5, return byte 0x5C.
◎
If code point is U+203E, return byte 0x7E.
◎
If code point is in the range U+FF61 to U+FF9F, inclusive, return a byte whose value is code point − 0xFF61 + 0xA1.
</li>
	<li>
~IF［
%結果 ~NEQ ~NULL
］
⇒
~RET %結果
◎
↑</li>
	<li>
~IF［
%~cp ~EQ `2212^U
］
⇒
%~cp ~SET `FF0D^U
◎
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
%~pointer ~LET
%~cp を指す`索引~Shift_JIS~pointer$
◎
Let pointer be the index Shift_JIS pointer for code point.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET `~error$i( %~cp )
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 188 )
◎
Let lead be pointer / 188.
</li>
	<li>
%~lead~offset ~LET ［
%~lead ~IN { `00^X 〜 `1E^X } ならば `81^X ／
~ELSE_ `C1^X【！ 0xA0-0x81 】
］
◎
Let lead offset be 0x81 if lead is less than 0x1F, otherwise 0xC1.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 188
◎
Let trail be pointer % 188.
</li>
	<li>
%~offset ~LET ［
%~trail ~IN { `00^X 〜 `3E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if trail is less than 0x3F, otherwise 0x41.
</li>
	<li>
~RET ~byte列 [ ( %~lead ~PLUS %~lead~offset ), ( %~trail ~PLUS %~offset ) ]
◎
Return two bytes whose values are lead + lead offset and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-korean-encodings">
<h2 title="Legacy multi-byte Korean encodings">13. 旧来の複-~byte~Korean符号化法</h2>

		<section id="euc-kr">
<h3 title="EUC-KR">13.1. ~EUC-KR</h3>

			<section id="euc-kr-decoder">
<h4 title="EUC-KR decoder">13.1.1. ~EUC-KR復号器</h4>

<p>
各［
`EUC-KR$n の`復号器$
］には、
次が結付けられる
⇒
`~EUC-KR~lead@（初期~時 `00^X ）
◎
EUC-KR’s decoder has an associated EUC-KR lead (initially 0x00).
</p>

<p>
`EUC-KR$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，次を走らす：
◎
EUC-KR’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
`~EUC-KR~lead$ ~NEQ `00^X
］
⇒＃
`~EUC-KR~lead$ ~SET `00^X ；
~RET `~error$i
◎
If byte is end-of-queue and EUC-KR lead is not 0x00, set EUC-KR lead to 0x00 and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$i
◎
If byte is end-of-queue and EUC-KR lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~EUC-KR~lead$ ~NEQ `00^X
］：
◎
If EUC-KR lead is not 0x00,＼
</p>
		<ol>
			<li>
%~lead ~LET `~EUC-KR~lead$
◎
let lead be EUC-KR lead,＼
</li>
			<li>
%~pointer ~LET ~NULL
◎
let pointer be null,＼
</li>
			<li>
`~EUC-KR~lead$ ~SET `00^X
◎
set EUC-KR lead to 0x00, and then:
</li>
			<li>
~IF［
%~byte ~IN { `41^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS `41^X )
◎
If byte is in the range 0x41 to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 + (byte − 0x41).
</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~EUC-KR$ の中で %~pointer が指す`索引~cp$
］
◎
Let code point be null if pointer is null, otherwise the index code point for pointer in index EUC-KR.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
`入出力~queueに前付加する$( %入出力~queue, %~byte )
◎
If byte is an ASCII byte, prepend byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~EUC-KR~lead$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is in the range 0x81 to 0xFE, inclusive, set EUC-KR lead to byte and return continue.
</li>
	<li>
~RET `~error$i
◎
Return error.
</li>
</ol>

			</section>
			<section id="euc-kr-encoder">
<h4 title="EUC-KR encoder">13.1.2. ~EUC-KR符号化器</h4>

<p>
`EUC-KR$n の`符号化器$の`~handler$は、
所与の
( %入出力~queue, %~cp )
に対し，次を走らす：
◎
EUC-KR’s encoder’s handler, given ioQueue and code point, runs these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If code point is end-of-queue, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET
`索引~EUC-KR$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index EUC-KR.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET `~error$i( %~cp )
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
◎
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET ( %~pointer ~MOD 190 ) ~PLUS `41^X
◎
Let trail be pointer % 190 + 0x41.
</li>
	<li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>

【！ removed from the spec 2013-08-23: 13.2 iso-2022-kr id="iso-2022-kr" 】

	</section>
	<section id="legacy-miscellaneous-encodings">
<h2 title="Legacy miscellaneous encodings">14. 旧来の諸々の符号化法</h2>

		<section id="replacement">
<h3 title="replacement">14.1. ~replacement</h3>

<p class="note">注記：
`replacement$n `符号化法$は、
~serverと~clientにおける `符号化法$の~supportの不一致を突く，ある種の攻撃を防ぐためのものである。
◎
The replacement encoding exists to prevent certain attacks that abuse a mismatch between encodings supported on the server and the client.
</p>

			<section id="replacement-decoder">
<h4 title="replacement decoder">14.1.1. ~replacement復号器</h4>

<p>
各［
`replacement$n の`復号器$
］には、
次が結付けられる
⇒
`~replacement~errorは返した@（初期~時 ~F ）
◎
replacement’s decoder has an associated replacement error returned (initially false).
</p>

<p>
`replacement$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，次を走らす：
◎
replacement’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
~IF［
%~byte ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If byte is end-of-queue, return finished.
</li>
	<li>
~IF［
`~replacement~errorは返した$ ~EQ ~F
］
⇒＃
`~replacement~errorは返した$ ~SET ~T ；
~RET `~error$i
◎
If replacement error returned is false, set replacement error returned to true and return error.
</li>
	<li>
~RET `完遂d$i
◎
Return finished.
</li>
</ol>

<p class="trans-note">【
`replacement$n には、
`符号化器$はない。
】</p>

			</section>
		</section>
		<section id="common-infrastructure-for-utf-16be-and-utf-16le">
<h3 title="Common infrastructure for UTF-16BE/LE">14.2. `UTF-16BE/LE$n に共通な基盤</h3>

<p>
`UTF-16BE/LE@n
は、［
`UTF-16BE$n ／ `UTF-16LE$n
］の総称である。
◎
UTF-16BE/LE is UTF-16BE or UTF-16LE.
</p>

			<section id="shared-utf-16-decoder">
<h4 title="shared UTF-16 decoder">14.2.1. 共用~UTF-16復号器</h4>

<p class="note">注記：
~BOMは~labelより優先される。
それは，配備-済みな内容において、
どの~labelよりも正確aであることが見出されているので。
したがって それは、
`共用~UTF-16復号器$の一部ではなく，`~Unicodeに復号する$ ~algoの一部を成す。
◎
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the shared UTF-16 decoder algorithm but rather the decode algorithm.
</p>

<p>
各［
`共用~UTF-16復号器$
］には、
次が結付けられる
⇒＃
`~UTF-16~lead~byte@（初期~時 ~NULL ）,
`~UTF-16~lead~surrogate@（初期~時 ~NULL ）,
`~UTF-16BE復号器~用か@（初期~時 ~F ）
◎
shared UTF-16 decoder has an associated UTF-16 lead byte and UTF-16 lead surrogate (both initially null), and is UTF-16BE decoder (initially false).
</p>

<p>
`共用~UTF-16復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，次を走らす：
◎
shared UTF-16 decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
`~UTF-16~lead~byte$ ~NEQ ~NULL
］~OR［
`~UTF-16~lead~surrogate$ ~NEQ ~NULL
］
⇒＃
`~UTF-16~lead~byte$ ~SET ~NULL；
`~UTF-16~lead~surrogate$ ~SET ~NULL；
~RET `~error$i
◎
If byte is end-of-queue and either UTF-16 lead byte or UTF-16 lead surrogate is non-null, set UTF-16 lead byte and UTF-16 lead surrogate to null, and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$i
◎
If byte is end-of-queue and UTF-16 lead byte and UTF-16 lead surrogate are null, return finished.
</li>
		</ol>
	</li>
	<li>
~IF［
`~UTF-16~lead~byte$ ~EQ ~NULL
］
⇒＃
`~UTF-16~lead~byte$ ~SET %~byte ；
~RET `継続-$i
◎
If UTF-16 lead byte is null, set UTF-16 lead byte to byte and return continue.
</li>
	<li>
%~cu ~LET `~UTF-16BE復号器~用か$に応じて
⇒＃
~T ならば ( ( `~UTF-16~lead~byte$ ~Lshift 8 ) ~PLUS %~byte ) ／
~F ならば ( ( %~byte ~Lshift 8 ) ~PLUS `~UTF-16~lead~byte$ )
◎
Let code unit be the result of:
• is UTF-16BE decoder is true
•• (UTF-16 lead byte &lt;&lt; 8) + byte.
• is UTF-16BE decoder is false
•• (byte &lt;&lt; 8) + UTF-16 lead byte.
</li>
	<li>
`~UTF-16~lead~byte$ ~SET ~NULL
◎
Then set UTF-16 lead byte to null.
</li>
	<li>
<p>
~IF［
`~UTF-16~lead~surrogate$ ~NEQ ~NULL
］：
◎
If UTF-16 lead surrogate is non-null,＼
</p>
		<ol>
			<li>
%~lead~surrogate ~LET `~UTF-16~lead~surrogate$
◎
let lead surrogate be UTF-16 lead surrogate,＼
</li>
			<li>
`~UTF-16~lead~surrogate$ ~SET ~NULL
◎
set UTF-16 lead surrogate to null, and then:
</li>
			<li>
~IF［
%~cu ~IN { `DC00^U 〜 `DFFF^U }
］
⇒
~RET ~cp [
`10000^X ~PLUS ( ( %~lead~surrogate ~MINUS `D800^X ) ~Lshift 10 ) ~PLUS ( %~cu ~MINUS `DC00^X )
]
◎
If code unit is in the range U+DC00 to U+DFFF, inclusive, return a code point whose value is 0x10000 + ((lead surrogate − 0xD800) &lt;&lt; 10) + (code unit − 0xDC00).
</li>
			<li>
%byte1 ~LET %~cu ~Rshift 8
◎
Let byte1 be code unit &gt;&gt; 8.
</li>
			<li>
%byte2 ~LET %~cu ~bAND `00FF^X
◎
Let byte2 be code unit &amp; 0x00FF.
</li>
			<li>
%~byte列 ~LET %~utf-16be に応じて
⇒＃
~T ならば ~byte列 [ %byte1, %byte2 ] ／
~F ならば ~byte列 [ %byte2, %byte1 ]
◎
Let bytes be two bytes whose values are byte1 and byte2, if is UTF-16BE decoder is true, and byte2 and byte1 otherwise.
</li>
			<li>
`入出力~queueに前付加する$( %入出力~queue, %~byte列 )
◎
Prepend the bytes to ioQueue and return error.
</li>
			<li>
~RET `~error$i
◎
↑</li>
		</ol>
	</li>
	<li>
~IF［
%~cu ~IN { `D800^U 〜 `DBFF^U }
］
⇒＃
`~UTF-16~lead~surrogate$ ~SET %~cu ；
~RET `継続-$i
◎
If code unit is in the range U+D800 to U+DBFF, inclusive, set UTF-16 lead surrogate to code unit and return continue.
</li>
	<li>
~IF［
%~cu ~IN { `DC00^U 〜 `DFFF^U }
］
【！ unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them 】
⇒
~RET `~error$i
◎
If code unit is in the range U+DC00 to U+DFFF, inclusive, return error.
</li>
	<li>
~RET ~cp [ %~cu ]
◎
Return code point code unit.
</li>
</ol>

			</section>
		</section>
		<section id="utf-16be">
<h3 title="UTF-16BE">14.3. ~UTF-16BE</h3>

			<section id="utf-16be-decoder">
<h4 title="UTF-16BE decoder">14.3.1. ~UTF-16BE復号器</h4>

<p>
`UTF-16BE$n の`復号器$は、［
`~UTF-16BE復号器~用か$ ~SET ~T
］にされた`共用~UTF-16復号器$である。
◎
UTF-16BE’s decoder is shared UTF-16 decoder with its is UTF-16BE decoder set to true.
</p>

			</section>
		</section>
		<section id="utf-16le">
<h3 title="UTF-16LE">14.4. ~UTF-16LE</h3>

<p class="note">注記：
配備-済みな内容に~~対処するため、
`utf-16^lb は `UTF-16LE$n 用の`~label$にされている。
◎
"utf-16" is a label for UTF-16LE to deal with deployed content.
</p>

			<section id="utf-16le-decoder">
<h4 title="UTF-16LE decoder">14.4.1. ~UTF-16LE復号器</h4>

<p>
`UTF-16BE$n の`復号器$は、
`共用~UTF-16復号器$である。
◎
UTF-16LE’s decoder is shared UTF-16 decoder.
</p>

			</section>
		</section>
		<section id="x-user-defined">
<h3 title="x-user-defined">14.5. ~x-user-defined</h3>

<p class="note">注記：
これは形上では`単-~byte符号化法$であるが、
~algo的に実装できるので，別々に定義される。
◎
While technically this is a single-byte encoding, it is defined separately as it can be implemented algorithmically.
</p>

			<section id="x-user-defined-decoder">
<h4 title="x-user-defined decoder">14.5.1. ~x-user-defined復号器</h4>

<p>
`x-user-defined$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，次を走らす：
◎
x-user-defined’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
~RET %~byte に応じて
⇒＃
`~EoQ$ならば `完遂d$i ／
`~ASCII~byte$であるならば ~cp [ %~byte ] ／
~ELSE_ ~cp [ `F780^X ~PLUS %~byte ~MINUS `80^X ]
◎
If byte is end-of-queue, return finished.
◎
If byte is an ASCII byte, return a code point whose value is byte.
◎
Return a code point whose value is 0xF780 + byte − 0x80.
</li>
</ol>

			</section>
			<section id="x-user-defined-encoder">
<h4 title="x-user-defined encoder">14.5.2. ~x-user-defined符号化器</h4>

<p>
`x-user-defined$n の`符号化器$の`~handler$は、
所与の
( %入出力~queue, %~cp )
に対し，次を走らす：
◎
x-user-defined’s encoder’s handler, given ioQueue and code point, runs these steps:
</p>
<ol>
	<li>
~RET %~cp に応じて
⇒＃
`~EoQ$ならば `完遂d$i ／
`~ASCII~cp$ならば ~byte列 [ %~cp ] ／
`F780^U 〜 `F7FF^U ならば ~byte列 [ %~cp ~MINUS `F780^X ~PLUS `80^X ] ／
~ELSE_ `~error$i( %~cp )
◎
If code point is end-of-queue, return finished.
◎
If code point is an ASCII code point, return a byte whose value is code point.
◎
If code point is in the range U+F780 to U+F7FF, inclusive, return a byte whose value is code point − 0xF780 + 0x80.
◎
Return error with code point.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="browser-ui">
<h2 title="Browser UI">15. ~browser~UI</h2>

<p>
~browserには、
資源の符号化法に対する上書きを可能化させないことが奨励される。
にもかかわらず，その種の特能が在る場合、
前述の
<a href="#security-background">~securityの課題</a>
から，~browserは `UTF-16BE/LE$n を~optionとして提供するベキでない。
~browserは、
資源が `UTF-16BE/LE$n を利用して復号された場合でも，この特能を不能化するベキである。
◎
Browsers are encouraged to not enable overriding the encoding of a resource. If such a feature is nonetheless present, browsers should not offer UTF-16BE/LE as an option, due to the aforementioned security issues. Browsers should also disable this feature if the resource was decoded using UTF-16BE/LE.
</p>

	</section>
	<section id="implementation-considerations">
<h2 title="Implementation considerations">実装の考慮点</h2>

<p>
この標準における`符号化法$用の`復号器$は、
`入出力~queueに前付加する$( ) を備える`入出力~queue$を~supportする代わりに，次により実装することもできる：
◎
Instead of supporting I/O queues with arbitrary prepend, the decoders for encodings in this standard could be implemented with:
</p>
<ol>
	<li>
読取った現在の~byteを元に戻す能。
◎
The ability to unread the current byte.
</li>
	<li>
`ISO-2022-JP$n 用の単-~byte（ `24^X ／ `28^X ）~buffer。
◎
↓</li>
	<li>
<p>
`gb18030$n 用の単-~byte（ `~ASCII~byte$ ）~buffer。
◎
A single-byte buffer for gb18030 (an ASCII byte) and ISO-2022-JP (0x24 or 0x28).
</p>

<p class="example" id="example-gb18030-implementation-strategy">
`gb18030$n に対しては、［
`~gb3$ ~NEQ `00^X
］の間に~~不正な~byteに出くわしたときは、
`~gb2$は，次回に返すことになる単-~byte~bufferの中に移動でき、
`~gb3$が
— 単-~byte~bufferを返して空にした後， `00^X でないことを検査したなら —
新たな`~gb1$になる。
これは、
`gb18030$n における 1 個目と 3 個目の~byte範囲が一致するので可能になる。
◎
For gb18030 when hitting a bogus byte while gb18030 third is not 0x00, gb18030 second could be moved into the single-byte buffer to be returned next, and gb18030 third would be the new gb18030 first, checked for not being 0x00 after the single-byte buffer was returned and emptied. This is possible as the range for the first and third byte in gb18030 is identical.
</p>
	</li>
</ol>

<p>
`~ISO-2022-JP符号化器$には，追加的な状態として`~ISO-2022-JP符号化器~状態$が必要になるが、
それ以外では，この標準におけるどの`符号化法$に対しても，それ用の`符号化器$に［
追加的な状態／~buffer
］は要求されない。
◎
The ISO-2022-JP encoder needs ISO-2022-JP encoder state as additional state, but other than that, none of the encoders for encodings in this standard require additional state or buffers.
</p>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り、
符号化法を相互運用可能なものにするために，たくさんの方々が助力され、
この標準の目標へ近付けてきた。
同様に多くの方々の助力が，この標準を~~現在の姿に仕立て上げてきた。
特に，次の方々に感謝する：
◎
There have been a lot of people that have helped make encodings more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</p>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main>

<div hidden>
<div lang="en" id="_acks1">
<p>
With that, many thanks to

Adam Rice,
Alan Chaney,
Alexander Shtuchkin,
Allen Wirfs-Brock,
Andreu Botella,
Aneesh Agrawal,
Arkadiusz Michalski,
Asmus Freytag,
Ben Noordhuis,
Bnaya Peretz,
Boris Zbarsky,
Bruno Haible,
Cameron McCormack,
Charles McCathieNeville,
Christopher Foo,
CodifierNL,
David Carlisle,
Domenic Denicola,
Dominique Hazaël-Massieux,
Doug Ewell,
Erik van der Poel,
<span lang="zh">譚永鋒</span> (Frank Yung-Fong Tang),
Glenn Maynard,
Gordon P. Hemsley,
Henri Sivonen,
Ian Hickson,
J. King,
James Graham,
Jeffrey Yasskin,
John Tamplin,
Joshua Bell,
<span lang="ja">村井純</span> (Jun Murai),
<span lang="ko">신정식</span> (Jungshik Shin),
Jxck,
<span lang="ko">강 성훈</span> (Kang Seonghoon),
<span lang="ja">川幡太一</span> (Kawabata Taichi),
Ken Lunde,
Ken Whistler,
Kenneth Russell,
<span lang="ja">田村健人</span> (Kent Tamura),
Leif Halvard Silli,
Luke Wagner,
Maciej Hirsz,
Makoto Kato,
Mark Callow,
Mark Crispin,
Mark Davis,
Martin Dürst,
Masatoshi Kimura,
Mattias Buelens,
Ms2ger,
Nigel Megitt,
Nigel Tao,
Norbert Lindenberg,
Øistein E. Andersen,
Peter Krefting,
Philip Jägenstedt,
Philip Taylor,
Richard Ishida,
Robbert Broersma,
Robert Mustacchi,
Ryan Dahl,
Sam Sneddon,
Shawn Steele,
Simon Montagu,
Simon Pieters,
Simon Sapin,
Stephen Checkoway,
<span lang="ja">寺田健</span> (Takeshi Terada),
Vyacheslav Matva,
Wolf Lammen, and
<span lang="ja">成瀬ゆい</span> (Yui Naruse)

for being awesome.
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.apple.com/">Apple</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
The <a href="#api">API</a> chapter was initially written by Joshua Bell
(<a href="https://www.google.com/">Google</a>).
</p>
</div>

<div lang="en" id="_ipr1">
<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://encoding.spec.whatwg.org/review-drafts/2023-06/">Living Standard Review Draft</a>.
</p>
</div>

</div>
