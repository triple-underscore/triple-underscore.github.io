<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Encoding Standard â€” ç¬¦å·åŒ–æ–¹å¼ æ¨™æº–ï¼ˆæ—¥æœ¬èªè¨³ï¼‰</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://encoding.spec.whatwg.org/',
		main: 'MAIN',
		ref_data: '.ref_data',
		ref_id_prefix: 'refs'
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN',
		levels: 'ã»ã¼è‹±èª:è‹±èªä¸»ä½“:æ¼¢å­—+è‹±èª:æ¼¢å­—ä¸»ä½“:ã‚«ãƒŠä¸»ä½“',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked 170505 spec.

	return options;
}

function expand(mapping1){

	var class_map = {
		E: 'error',
		n: 'ename',
		U: 'code-point',
		X: 'hex-value',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		n: 'b',
		U: 'span',
		X: 'span',
		i: 'i',
		i1: 'i',
		V: 'var',
	};

	var link_map = this.link_map;
	var index_template = '\
<a href="~ENCSPEC/index-ï½.txt">index-ï½.txt</a>\
<td><a href="~ENCSPEC/ï½.html">ç´¢å¼• <b class="ename">ï¼®</b> è¦–è¦šåŒ–</a>\
<td><a href="~ENCSPEC/ï½-bmp.html">ç´¢å¼• <b class="ename">ï¼®</b> BMP è¢«è¦†åŸŸ</a>\
';

	E('MAIN').innerHTML = Util.generateSource(this, mapping1, function(source){
		return source.replace(
			/%[\w\-~ä¸€-é¿†]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		);
	});
	return;

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return '<var>' + match.slice(1) + '</var>'
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'lb': // label
	text = '"<code class="label">' + text + '</code>"';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'n': // encoding name
	href = '#' + key.toLowerCase();
	break;
case 'U': // Unicode code point
	text = 'U+' + key;
	break;
case 'X': // byte value
	text = '0x' + key;
	break;
case 'idx':
	return ( index_template
		.replace(/ï½/g, key.toLowerCase())
		.replace(/ï¼®/g, key)
	);
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<!--% ãƒªãƒ³ã‚¯ç½®æ›ãƒ‡ãƒ¼ã‚¿ -->

<script type="text/plain" id="_link_map">
	â—IDL
E.RangeError:~WEBIDL#exceptiondef-rangeerror
E.TypeError:~WEBIDL#exceptiondef-typeerror

I.TextDecoderOptions:#textdecoderoptions
I.TextDecodeOptions:#textdecodeoptions
I.TextDecoder:#textdecoder
I.TextEncodeOptions:#textencodeoptions
I.TextEncoder:#textencoder
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array
I.Uint32Array:~WEBIDL#idl-Uint32Array

Uint8Array:~WEBIDL#idl-Uint8Array
USVString:~WEBIDL#idl-USVString
DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean


m.TextDecoder:#dom-textdecoder
m.encoding:#dom-textdecoder-encoding
m.fatal:#dom-textdecoder-fatal
m.ignoreBOM:#dom-textdecoder-ignorebom

m.decode:#dom-textdecoder-decode
m.TextEncoder:#dom-textencoder
m.~encoding0:#dom-textencoder-encoding
m.encode:#dom-textencoder-encode

	â—
æŠ•å‡º-:~WEBIDL#dfn-throw

~byte:~INFRA#byte
~ASCII~byte:~INFRA#ascii-byte
~cp:~INFRA#code-point
~scalarå€¤:~INFRA#scalar-value
~ASCII~cp:~INFRA#ascii-code-point
~ASCIIç©ºç™½:~INFRA#ascii-whitespace
~ASCIIæ•°å­—:~INFRA#ascii-digit
~ASCIIå¤§å°ç„¡è¦–:~INFRA#ascii-case-insensitive
~ASCIIå°æ–‡å­—~åŒ–:~INFRA#ascii-lowercase

~encoding:#encoding
åå‰:#name
~label:#label
~decoder:#decoder
~decode:#decode
~UTF-8~decode:#utf-8-decode
~BOMã¯ãã®ã¾ã¾ã«~UTF-8~decode:#utf-8-decode-without-bom
~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8~decode:#utf-8-decode-without-bom-or-fail
~UTF-8~encode:#utf-8-encode
~encode:#encode
~encoder:#encoder
~handler:#handler
~error~mode:#error-mode
~error:#error
å®Œé‚:#finished
ç¶™ç¶š:#continue
~EoS:#end-of-stream

~encodingã‚’å–å¾—-:#concept-encoding-get
å‡ºåŠ›~encodingã‚’å–å¾—-:#get-an-output-encoding
~token:#concept-token
~stream:#concept-stream
èª­å–ã£ãŸçµæœ:#concept-stream-read
å‰ä»˜åŠ ã™ã‚‹:#concept-stream-prepend
å‰ä»˜åŠ -:#concept-stream-prepend
~pushã™ã‚‹:#concept-stream-push
èµ°ã‚‰ã™:#concept-encoding-run
~tokenã‚’å‡¦ç†-:#concept-encoding-process

	â—
ç´¢å¼•:#index
ç´¢å¼•~cp:#index-code-point
ç´¢å¼•~pointer:#index-pointer
ç´¢å¼•~Big5~pointer:#index-big5-pointer
ç´¢å¼•~Big5:#index-big5
ç´¢å¼•~EUC-KR:#index-euc-kr
ç´¢å¼•~jis0208:#index-jis0208
ç´¢å¼•~jis0212:#index-jis0212
ç´¢å¼•~Shift_JIS~pointer:#index-shift_jis-pointer
ç´¢å¼•~ISO-2022-JP~katakana:#index-iso-2022-jp-katakana
ç´¢å¼•~gb18030ç¯„å›²é›†:#index-gb18030-ranges
ç´¢å¼•~gb18030ç¯„å›²é›†~cp:#index-gb18030-ranges-code-point
ç´¢å¼•~gb18030ç¯„å›²é›†~pointer:#index-gb18030-ranges-pointer

ç´¢å¼•~gb18030:#index-gb18030

~UTF-8~cp:#utf-8-code-point
~UTF-8å‡ºç¾~byteæ•°:#utf-8-bytes-seen
~UTF-8è¦~byteæ•°:#utf-8-bytes-needed
~UTF-8ä¸‹é™:#utf-8-lower-boundary
~UTF-8ä¸Šé™:#utf-8-upper-boundary

å˜byte~encoding:#single-byte-encoding
å˜byteç´¢å¼•:#index-single-byte


	â—åå‰
	n.UTF-8:#utf-8
	n.IBM866:#ibm866
	n.ISO-8859-2:#iso-8859-2
	n.ISO-8859-3:#iso-8859-3
	n.ISO-8859-4:#iso-8859-4
	n.ISO-8859-5:#iso-8859-5
	n.ISO-8859-6:#iso-8859-6
	n.ISO-8859-7:#iso-8859-7
	n.ISO-8859-8:#iso-8859-8
	n.ISO-8859-8-I:#iso-8859-8-i
	n.ISO-8859-10:#iso-8859-10
	n.ISO-8859-13:#iso-8859-13
	n.ISO-8859-14:#iso-8859-14
	n.ISO-8859-15:#iso-8859-15
	n.ISO-8859-16:#iso-8859-16
	n.KOI8-R:#koi8-r
	n.KOI8-U:#koi8-u
	n.macintosh:#macintosh
	n.windows-874:#windows-874
	n.windows-1250:#windows-1250
	n.windows-1251:#windows-1251
	n.windows-1252:#windows-1252
	n.windows-1253:#windows-1253
	n.windows-1254:#windows-1254
	n.windows-1255:#windows-1255
	n.windows-1256:#windows-1256
	n.windows-1257:#windows-1257
	n.windows-1258:#windows-1258
	n.x-mac-cyrillic:#x-mac-cyrillic

	n.GBK:#gbk
	n.gb18030:#gb18030
	n.Big5:#big5
	n.EUC-JP:#euc-jp
	n.ISO-2022-JP:#iso-2022-jp
	n.Shift_JIS:#shift_jis
	n.EUC-KR:#euc-kr
	n.replacement:#replacement
	n.UTF-16LE:#utf-16le
	n.UTF-16BE:#utf-16be
	n.x-user-defined:#x-user-defined

	â—encoderï¼decoder IDL
dec.~encoding:#textdecoder-encoding
dec.~decoder:#textdecoder-decoder
dec.~stream:#textdecoder-stream
dec.~BOMignore~flag:#textdecoder-ignore-bom-flag
dec.~BOMseen~flag:#textdecoder-bom-seen-flag
dec.~error~mode:#textdecoder-error-mode
dec.~no_flush~flag:#textdecoder-do-not-flush-flag
dec.ç›´åˆ—åŒ–-:#concept-td-serialize

enc.~encoder:#textencoder-encoder

	â—å„ç¨® encoderï¼decoder

~UTF-8~decoder:#utf-8-decoder
~UTF-8~encoder:#utf-8-encoder
å…±ç”¨~UTF-16~decoder:#shared-utf-16-decoder
~replacement~decoder:#replacement-decoder
~replacementã«ã‚ˆã‚‹~errorã¯ã™ã§ã«è¿”ã—ãŸ~flag:#replacement-error-returned-flag

å˜byte~decoder:#single-byte-decoder
å˜byte~encoder:#single-byte-encoder

~GBK~flag:#gbk-flag

~gb1:#gb18030-first
~gb2:#gb18030-second
~gb3:#gb18030-third

~gb18030~decoder:#gb18030-decoder
~gb18030~encoder:#gb18030-encoder

~Big5~lead:#big5-lead
~Big5~decoder:#big5-decoder
~Big5~encoder:#big5-encoder

~EUC-JP~lead:#euc-jp-lead
~EUC-JP~jis0212~flag:#euc-jp-jis0212-flag
~EUC-JP~decoder:#euc-jp-decoder
~EUC-JP~encoder:#euc-jp-encoder

~ISO-2022-JP~decoder:#iso-2022-jp-decoder
~ISO-2022-JP~encoder:#iso-2022-jp-encoder

~ISO-2022-JP~decoderçŠ¶æ…‹:#iso-2022-jp-decoder-state
~ISO-2022-JP~decoderå‡ºåŠ›~çŠ¶æ…‹:#iso-2022-jp-decoder-output-state
~ISO-2022-JP~lead:#iso-2022-jp-lead
~ISO-2022-JPå‡ºåŠ›~flag:#iso-2022-jp-output-flag

i.ASCII:#iso-2022-jp-decoder-ascii
i.Roman:#iso-2022-jp-decoder-roman
i.katakana:#iso-2022-jp-decoder-katakana
i.~lead~byte:#iso-2022-jp-decoder-lead-byte
i.~trail~byte:#iso-2022-jp-decoder-trail-byte
i.~escapeé–‹å§‹:#iso-2022-jp-decoder-escape-start
i.~escape:#iso-2022-jp-decoder-escape

~ISO-2022-JP~encoderçŠ¶æ…‹:#iso-2022-jp-encoder-state
i1.ASCII:#iso-2022-jp-encoder-ascii
i1.Roman:#iso-2022-jp-encoder-roman
i1.jis0208:#iso-2022-jp-encoder-jis0208

~Shift_JIS~lead:#shift_jis-lead
~Shift_JIS~decoder:#shift_jis-decoder
~Shift_JIS~encoder:#shift_jis-encoder

~EUC-KR~lead:#euc-kr-lead
~EUC-KR~decoder:#euc-kr-decoder
~EUC-KR~encoder:#euc-kr-encoder

~UTF-16~lead~byte:#utf-16-lead-byte
~UTF-16~lead~surrogate:#utf-16-lead-surrogate
~UTF-16~decoder:#utf-16-decoder
~UTF-16LE~decoder:#utf-16le-decoder
~UTF-16BE~decoder:#utf-16be-decoder
~UTF-16BE~decoder~flag:#utf-16be-decoder-flag

~x-user-defined~decoder:#x-user-defined-decoder
~x-user-defined~encoder:#x-user-defined-encoder

	~byteåˆ—ã«å¤‰æ›-:#convert-a-code-unit-to-bytes

indexes.json:~ENCSPEC/indexes.json


</script>


<!--% ç½®æ›ãƒ‡ãƒ¼ã‚¿ -->

<script type="text/plain" id="words_table1">
ENCSPEC:https://encoding.spec.whatwg.org
BR:ï¼›<br>
bAND: <span class="op">&amp;</span> 
bOR: <span class="op">|</span> 
Lshift: <span class="op">&lt;&lt;</span>
Rshift: <span class="op">&gt;&gt;</span>

encoding0:encoding
UTF-8:<b class="ename">UTF-8</b> 
GBK:<b class="ename">GBK</b> 
gb18030:<b class="ename">gb18030</b> 
Big5:<b class="ename">Big5</b> 
EUC-JP:<b class="ename">EUC-JP</b> 
ISO-2022-JP:<b class="ename">ISO-2022-JP</b> 
Shift_JIS:<b class="ename">Shift_JIS</b> 
EUC-KR:<b class="ename">EUC-KR</b> 
jis0208:<b class="ename">jis0208</b> 
jis0212:<b class="ename">jis0212</b> 
replacement:<b class="ename">replacement</b> 
UTF-16BE:<b class="ename">UTF-16BE</b> 
UTF-16LE:<b class="ename">UTF-16LE</b> 
x-user-defined:<b class="ename">x-user-defined</b> 
</script>


<!--% èªå½™ç½®æ›ãƒ‡ãƒ¼ã‚¿ -->
<script type="text/plain" id="words_table">
	â—ä»•æ§˜
API:
algo:algorithm:::ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
æ‰‹ç¶šã:steps:~
æ®µ:step:~
UA:user agent:UA:::ãƒ¦ãƒ¼ã‚¶ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
æŠ€è¡“çš„ã«ã¯:technical ã«ã¯:å½¢ã®ä¸Šã§ã¯
æ­´å²çš„:historical:~
è¦ç¯„çš„:normative:~
	è¦ç¯„çš„ã§ãªã„:non-normative:~
çµ±ä¸€çš„:universal:~
é©åˆ‡:appropriate:~
äº’æ›æ€§:compatibility:~
äº’æ›:compatible:~
éäº’æ›:incompatible:~
ç†ç”±:reason:~
ç‰¹è‰²æ©Ÿèƒ½:feature:~
èª²é¡Œ:issue:~
å•é¡Œ:problem:~
é•æ³•:illegal:~
è‡ªæ˜:trivial:~
åŸºæœ¬çš„:basic:~
ç¶²ç¾…çš„:exhaustive:~
å…±é€šã®:common:~
åŸºç›¤:infrastructure:~
æœ‰æ„:significant:~
ä¿å®ˆçš„:conservative:~
åˆæ³•:legitimate:~
ç§»è¡Œ-:move:~
é‡è¦:important:~
ç‰¹åˆ¥ãª:special:~
å®Œå…¨ã•:completeness:~
ä»•çµ„ã¿:mechanism:~
äº‹ä¾‹:case:~
å„ç¨®ç”¨èª:terminology:~
æ„å‘³è«–:semantics:~
æ—§æ¥ã®:legacy:~
æ¨™æº–:standard:~
é–¢ä¿‚ãªã„:irrelevant:~
ä»•æ§˜:spec:~
	çœç•¥æ™‚ã¯:optional
æ–‡è„ˆ:context:~
browser::::ãƒ–ãƒ©ã‚¦ã‚¶
proprietary::::ãƒ—ãƒ­ãƒ—ãƒ©ã‚¤ã‚¨ã‚¿ãƒª
platform::::ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 
ãƒªãƒãƒ¼ã‚¹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢:reverse engineer:~
ä¿å®‰:security::~:ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
åŠ¹ç‡çš„:efficient:~

èƒŒæ™¯:background:~
æœ‰ç”¨:useful:~
å¼·ã:strong ã«:~
ä»•æ–¹:way:~
ç°¡æ˜:clear:~
éš”ãŸã‚Š:gap:~
è©³ç´°:details:~
é€²è¡Œä¸­:ongoing:~
éå»:past:~
å…±é€šçš„ã«:common ã«:ã‚ˆã
è³‡è³ª:nature:~
å‡¡ä¾‹:legend:~
è€ƒæ…®ç‚¹:considerations:~
èƒ½:ability:~
	ç›®æ¨™:goal
	åŠ©åŠ›:help
	~~æ¨™æº–ã®:The
	~~è€ƒæ…®
	ä¸€å¼ã§:in combination with
	ã‚ˆã‚Š~~ä¸€èˆ¬çš„ã«ã¯:larger
	å‚™è€ƒ
	å…¥æ‰‹ã§ãã‚‹:available
	å‰‡ã£ã¦
	~~ååˆ†:fine
	æ§˜ã«
	åºƒã:widespread
	åº:Preface
	è¦-
	ä¸è¦:no need
	å¿…è¦:necessaryï¼needï¼
	æ±ºã—ã¦
	è¦‹ã‹ã‘ä¸Š:superficially
	èª¬æ˜:Notes
	é™ã‚‰ãªã„
	ã«ã‚‚ã‹ã‹ã‚ã‚‰ãš:nonetheless
	ã‚ã„ã«ã:unfortunately
	å¾Œã®:future
	~~ä¸æ­£ãª:bogus
	ä¾‹
	ä¾‹ãˆã°
	æ³¨è¨˜
	ç‰¹ã«:In particular
	é–¢ã™ã‚‹:-

	â—ä»•æ§˜ï¼ˆå‹•è©
support::::ã‚µãƒãƒ¼ãƒˆ
è¿½åŠ ã®:additional:~
é¿ã‘ã‚‹:avoid ã™ã‚‹:~
å½±éŸ¿-:affect:~
åˆ©ç”¨è€…:user:~
åˆ©ç”¨-:use:~
åˆ©ç”¨:use:~
åˆ©ç”¨ä¸­ã®:in use ã®:~
æ³¢åŠ-:influence:~
æ„å›³çš„:intentional:~
æ„å›³-:intend:~
é™¤å¤–-:exclude:~
é™¤å¤–:exclusion:~
æ’ä»–çš„:exclusive:~
æ—¢å­˜ã®:existing:~
ä½œè€…:author:~
æä¾›-:provide:~
æä¾›0-:offer:æä¾›
åæŸ:converge:~
ç›¸äº’é‹ç”¨å¯èƒ½:interoperable:~
ç©¶æ˜:investigation:~
æœ«ç«¯åˆ©ç”¨è€…:end user:~
å¯èƒ½åŒ–-:enable:~
ä¸èƒ½åŒ–-:disable:~
å ±å‘Š-:report:~
è§£é‡ˆ:interpretation:~
åˆ¶å¾¡:control:~
æœªçŸ¥ã®:unknown:~
æ‹˜æŸ:constraints:~
æ‹˜æŸ-:constrain:~
åˆ¶ç´„çš„:restrictive:~
å¥¨åŠ±-:encourage:~
	ä¿ƒã™
æ‹¡æ•£-:spread:~
é€¸è„±-:deviate:~
åˆ¤åˆ¥-:distinguish:~
é–‹ç™ºè€…:developer:~
ç¾©å‹™ä»˜ã‘ã‚‰:mandate ã•:~
è¦æ±‚-:require:~
å–çµ„ã‚€:address ã™ã‚‹:å–ã‚Šçµ„ã‚€
åˆ¶é™-:limit:~
åƒã:work ã™ã‚‹:~
æ‹¡å¼µ-:extend:~
æ‹¡å¼µ:extension:~
æ—¢å®š:default:~
fallback:::ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
å®Ÿè£…-:implement:~
å®Ÿè£…:implementation:~
å®šç¾©-:define:~
å®šç¾©:definition:~
æœªå®šç¾©:undefined:~
æœ€é©åŒ–-:optimize:~
ä¾å­˜-:depend:~
å…¬é–‹-:expose:~
å…±ç”¨:shared::~
å…±æœ‰-:share:~
æµå¸ƒ-:deploy:~
é…å‚™æ¸ˆã¿ã®:deployed:~
è¨±å¯-:permit:~
ç”Ÿç”£å´:producer:ç”Ÿç”£å´
ç”Ÿç”£-:produce:ç”Ÿç”£
æ¶ˆè²»å´:consumer:~
æ¶ˆè²»è€…:consumer:~
èª˜ç™º-:trigger:~
é•å:violation:~
å–æ‰±ã„:handling:å–ã‚Šæ‰±ã„
å–æ‰±ã†:handle ã™ã‚‹:å–ã‚Šæ‰±ã†
è¦æ—¨ã—ãŸ:outline ã—ãŸ:è¦æ—¨ã‚’è¿°ã¹ãŸ
éœ§æ¶ˆ-:go away:~
æŒ™å‹•:behavior:ãµã‚‹ã¾ã„
	å‘¨çŸ¥ã®:known:
	å¯¾å‡¦-:deal with
	æ‰±ã„:dealing with
	æº–ã˜ã‚‹:match
	çŸ¥ã‚‰ã‚Œ:knownï¼
		è¿½ã„æ˜“ã:easy to follow
	æŒ™ã’-:list
	ç¤ºã•ã‚Œ:-
	å‘¼ã¶:-
	åŸ‹ã‚ã‚‹:-
	å£Šã™:break
	å¤‰ã‚ã£ã¦:change
	è¦‹ãˆãªã„:not see
	è¦‹ã‚ˆ:see
	è¨˜ã•ã‚Œ
	è¨˜ã™

	â—å‹•è©ï¼ˆæœªåˆ†é¡
ç¶™ç¶š:continue::~
å®Œé‚:finished::~
å®Ÿè¡Œ:execution:~
èµ°ã‚‰ã™:run ã™ã‚‹:èµ°ã‚‰ã›ã‚‹
èµ°ã‚‰ã›:run ã—:~
è¿”ã™:return ã™ã‚‹:~
è¿”ã•:return ã—:~
è¿”ã•ã‚Œ:return ã•ã‚Œ:~
è¿”ã—ãŸ:return ã—ãŸ:~
ç¹°è¿”:ç¹°ã‚Šè¿”
èª­å–ã‚Œã‚‹:read ã§ãã‚‹::èª­ã¿å–ã‚Œã‚‹
èª­å–ã‚‹:read ã™ã‚‹::èª­ã¿å–ã‚‹
èª­å–ã‚‰ã‚Œ:read ã•ã‚Œ::èª­ã¿å–ã‚‰ã‚Œ
èª­å–ã£ãŸ:read ã—ãŸ::èª­ã¿å–ã£ãŸ
	èª­å–çµæœ:èª­ã¿å–ã£ãŸçµæœ
	unread:ã€œã‚’å…ƒã«æˆ»ã™
push:::::ãƒ—ãƒƒã‚·ãƒ¥
å‰ä»˜åŠ -:prepend::~
ä»˜åŠ -:append::~
æŒ¿å…¥-:insert::~
åˆè‡´-:match:~
æ–­ç‰‡åŒ–:fragment åŒ–:~
å¯¾å¿œé–¢ä¿‚:mapping:~
å¯¾å¿œä»˜ã‘ã‚‹:map ã™ã‚‹:~
å¯¾å¿œä»˜ã‘ã¦:map ã—ã¦:~
å¯¾å¿œä»˜ã‘ã‚‰:map ã•:~
å¤‰æ›-:convert:~
è¡¨ç¾-:represent:~
è­˜åˆ¥-:identify:~
é™¤å»-:remove:~
å‰ç½®-:prefix::~
é‡è¤‡-:duplicate:~
åˆ†å‰²:split:~
è¨­å®š-:set:~
æ§‹æ–‡è§£æ:parsing::~::ãƒ‘ãƒ¼ã‚¹å‡¦ç†
ç›´åˆ—åŒ–-:serialize::~::ã‚·ãƒªã‚¢ãƒ«åŒ–
å‡¦ç†-:process::~
å‡¦ç†å™¨:processor::~::ãƒ—ãƒ­ã‚»ãƒƒã‚µ
å…¥åŠ›:input::~
å‡ºåŠ›:output::~
	~~å‡ºåŠ›:emit
é–‹å§‹:start:~
åŒ…å«-:contain:~
ç”Ÿæˆ-:generate:~
çµä»˜ã‘ã‚‰:associate ã•:çµã³ä»˜ã‘ã‚‰
è¦‹å‡ºã™:find ã™ã‚‹:~
è¦‹å‡ºã•ã‚Œ:find ã•ã‚Œ:~
çµ‚äº†-:terminate:~
ä¿å…¨-:preserve:~
å¾€æ¥-:roundtrip:~
å‚ç…§-:reference:~
å­˜åœ¨-:exist:~
åŒ…è£…-:wrap:~
åœ¨ã™ã‚‹:present ã™ã‚‹:åœ¨ã‚‹
å‘¼å‡ºã—ã¦:invoke ã—ã¦:å‘¼ã³å‡ºã—ã¦
å‘¼å‡ºã™:invoke ã™ã‚‹:å‘¼ã³å‡ºã™
å‘¼å‡ºæ™‚:invoke æ™‚:å‘¼ã³å‡ºã—æ™‚
å¤‰åŒ–:changes:~
å¤‰æ›´:changes:~
å¤‰æ›´-:change:~
æ¤œæŸ»-:check:~
ç§»å‹•-:move:~
call:
	æŒã¤
	ä¸€æ–°-:set anew
	æ‰€ä¸ã®:given
	ä¸ãˆ:give
	è»¢æ›-:turn
	å¤±ã‚ã›:loss
	æˆ»ã™:back
	å‡ºãã‚ã—:hit
	~~ç©ºã„ãŸ:newly-vacated
	å«ã¾ã‚Œï¼å«ã‚ã‚‰ã‚Œï¼å«ã‚“ã§:include
	è¡¨ã™:signify
	å¯¾:combination
	è¢«ã›ãŸ:Layering ã€œ  on top
	ä¾›ã™ã‚‹:-
	åŠ ãˆ
	æŒ‡-:-
	å¾—ã‚‰ã‚Œ:-
	å¾—ã‚‹:-
	çµ‚ãˆã‚‹:-
	è¡Œã†

	â—networkï¼ä¿å®‰
URL:
protocol::::ãƒ—ãƒ­ãƒˆã‚³ãƒ«
header::::ãƒ˜ãƒƒãƒ€
server::::ã‚µãƒ¼ãƒ
client::::ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
è³‡æº:resource::~:ãƒªã‚½ãƒ¼ã‚¹
form::::ãƒ•ã‚©ãƒ¼ãƒ 
æå‡º:submission::~
æ‰‹å…¥åŠ›:enter:~
æ”»æ’ƒ:attack:~
æ”»æ’ƒè€…:attacker:~
é˜²ã:prevent ã™ã‚‹:~
æ³¨å…¥-:inject:~
æ³¨æ„æ·±ã:careful ã«:~
ç´°å·¥:craft:~
æƒ…å ±å–ªå¤±:information loss:~
å®‰å…¨:safe:~
ä¸Šæ›¸ã:override:~
åˆæ„:agree:~
ä¸ä¸€è‡´:mismatch:~
äº¤æ›:interchange:~
éš ã™:mask ã™ã‚‹:~
éš ã›ãª:mask ã§ããª:~
	çªã:abuse
	è‡³ã‚‰ã›:resulting in
	~~æ¤œçŸ¥ã•ã‚Œã‚‹ã“ã¨ãªã:silent

	â—ç¬¦å·åŒ–æ–¹å¼
Unicode:
CJK:
block::::ãƒ–ãƒ­ãƒƒã‚¯
ç§ç”¨é ˜åŸŸ:Private Use Area:~
	é¦™æ¸¯å¢—è£œå­—ç¬¦é›†
	åŸºæœ¬å¤šè¨€èªé¢
	äº’æ›æ¼¢å­—

gb1:
gb2:
gb3:
jis0212:
jis0208:
	Roman
utf-16be:
UTF-16:
Hangul:::ãƒãƒ³ã‚°ãƒ«

byte::::ãƒã‚¤ãƒˆ
å˜byte:single-byte::å˜ byte:å˜ãƒã‚¤ãƒˆ:ã‚·ãƒ³ã‚°ãƒ«ãƒã‚¤ãƒˆ
è¤‡byte:multi-byte::è¤‡ byte:è¤‡ãƒã‚¤ãƒˆ:ãƒãƒ«ãƒãƒã‚¤ãƒˆ
surrogate::::ã‚µãƒ­ã‚²ãƒ¼ãƒˆ
scalar::::ã‚¹ã‚«ãƒ©ãƒ¼
flag::::ãƒ•ãƒ©ã‚°
cp:code point::ç¬¦å·ä½ç½®::ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
cu:code unit::ç¬¦å·å˜ä½::ã‚³ãƒ¼ãƒ‰ãƒ¦ãƒ‹ãƒƒãƒˆ
ç´¢å¼•:index::~::ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
pointer::::ãƒã‚¤ãƒ³ã‚¿
ç¬¦å·åŒ–æ–‡å­—é›†åˆ:coded character set::~

BOM:
BOMseen:BOM seen:BOM ç¢ºèªæ¸ˆã¿
BOMignore:ignore BOM:BOM ç„¡è¦–
ç°¡ä½“å­—:simplified::~
ç¹ä½“å­—:traditional::~
ASCII:
ç©º:empty:~
æ–‡å­—åˆ—:string:~
æ–‡å­—:character:~
å°æ–‡å­—:lowercase:~
å†…å®¹:content:~
ç¯„å›²:range::~
ç¯„å›²é›†:ranges::~
ç©ºç™½:whitespace:~
å¤§å°ç„¡è¦–:case-insensitive:~
æ•°å­—:digit:~

code::::ã‚³ãƒ¼ãƒ‰
encode:::ç¬¦å·åŒ–::ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
encoding:::ç¬¦å·åŒ–æ–¹å¼::ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
encoder:::ç¬¦å·åŒ–å™¨::ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€
decode:::å¾©å·::ãƒ‡ã‚³ãƒ¼ãƒ‰
decoder:::å¾©å·å™¨::ãƒ‡ã‚³ãƒ¼ãƒ€
label::::ãƒ©ãƒ™ãƒ«
æ­£æº–çš„:canonical::~
å½¢å¼:format::ãƒ‡ãƒ¼ã‚¿å½¢å¼::ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

åŠè§’:halfwidth::~
å…¨è§’:fullwidth::~
katakana::::ã‚«ã‚¿ã‚«ãƒŠ

	â—
list::::ãƒªã‚¹ãƒˆ
table::::ãƒ†ãƒ¼ãƒ–ãƒ«
entry::::ã‚¨ãƒ³ãƒˆãƒª

error::::ã‚¨ãƒ©ãƒ¼
åå‰:name::~
å:name::~
ä¸‹é™:lower boundary::~
ä¸Šé™:upper boundary::~
offset:
token::::ãƒˆãƒ¼ã‚¯ãƒ³
stream::::ã‚¹ãƒˆãƒªãƒ¼ãƒ 
streaming::::ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†
no_flush:do not flush:çŠ¶æ…‹ç¶­æŒ
EoS:end-of-stream::stream çµ‚ç«¯:ã‚¹ãƒˆãƒªãƒ¼ãƒ çµ‚ç«¯
çŠ¶æ…‹:state::~::ã‚¹ãƒ†ãƒ¼ãƒˆ
escape:escape 
lead:::é ­éƒ¨
trail:::å°¾éƒ¨
	é ­éƒ¨ã¨å°¾éƒ¨:leading and trailing
handler::::ãƒãƒ³ãƒ‰ãƒ©
instance::::ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
mode::::ãƒ¢ãƒ¼ãƒ‰
coder:
	å‡ºç¾~byteæ•°:byte seen
	fatal:
å¤±æ•—-:fail::~
å¤±æ•—:failure::~


è¦–è¦šåŒ–:visualization:~
è¢«è¦†åŸŸ:coverage:~
è¦†ã†:cover ã™ã‚‹:~
layout::::ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
literal::::ãƒªãƒ†ãƒ©ãƒ«
data::::ãƒ‡ãƒ¼ã‚¿
bit::::ãƒ“ãƒƒãƒˆ
shift::::ã‚·ãƒ•ãƒˆ
hook::::ãƒ•ãƒƒã‚¯
buffer::::ãƒãƒƒãƒ•ã‚¡
option::::ã‚ªãƒ—ã‚·ãƒ§ãƒ³
script::::ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
field::::ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰

è«–ç†:logical:~
ç¯„å›²æ¤œæŸ»:limit check:~
åŒºç”»:area::~
è¤‡è£½:copy:~
ä¸€æ„:unique:~
ä¸€è¦§:table:~
å€¤:value:~
	ã€œãŒè¿”ã™å€¤:ã€œã® return value
é…åˆ—:array::~
	ç®—è¡“å¼:equation:~
é †åº:order:~
æœ‰é †åº:ordered:~
åŠ ç®—:addition:~
æ¸›ç®—:subtraction:~
ä¹—ç®—:multiplication:~
é™¤ç®—:division:~
å‰°ä½™:remainder:~
åŒºåˆ‡å­:delimiter:~

æ•´æ•°:integer:~
åŸºæ•°:base:~
	é•·ã•:length

	â—
HTML:
obj:object:::ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
method:::ãƒ¡ã‚½ãƒƒãƒ‰
interface:::ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹
æ§‹ç¯‰å­:constructor::~::ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
å–å¾—å­:getter:~
å–å¾—-:get:~
è¢«å‘¼å‡ºæ™‚:è¢« invoke æ™‚:~
	invocation
æŠ•å‡º-:throw:~
member::::ãƒ¡ãƒ³ãƒ

åˆ¥å:alias:~
æ­£ç¢ºa:accurate:æ­£ç¢º
ç­‰ä¾¡:equivalent:~
ç²¾åº¦:precision:~
å¼•æ•°:argument:~
æ–¹å‘:direction:~
	ä¼´ã‚ã‚Œãªã„ no ã€œ present
	ä¸€è‡´-:identical
	å„ªå…ˆã•ã‚Œã‚‹:has priority overï¼more authoritative

	â—æŒ‡ç¤ºèª
æ–°ãŸãª:new:~
åˆæœŸ:initial:~
å˜ç‹¬ã®:single:~
è‡ªå‰ã®:own:~
ç¾åœ¨ã®:current:~
æœ€åˆã®:first:~
æœ€å¾Œã®:last:~
å…¨ä½“çš„ãª:overall:~
	çµæœ:result:~
	å·¦ä¸Šéš…:top left corner
	ã‚ã‚‹ç¨‹åº¦:some extent
	ã‚ˆã‚Šå°ã•ã„:less than
	å†’é ­
	è¤‡æ•°
	ä¸€ã¤
	ä¸€
	ä¸€é€£ã®
	ä¸€éƒ¨
	ä¸Š
	ä¸‹
	ä»¥ä¸Š
	ä»¥ä¸‹
	ä¸‹ä½:least significant
	ä¸‹è¨˜
	ä¸­
	ä¸»ã«
	ä»Šã‚„
	ä»–
	ä»–ã®
	ãã®ä»–ã®:miscellaneous
	ä»¥å¤–
	ä½•ã‹
	ä½•ã‚‚
	ä½•ã‚‰ã‹
	å…ƒã®
	å…ˆã®
	å…¥ã‚‰ãªã„
	å…¥ã‚‹
	å†…
	åˆ—ç›®
	åˆ¥
	å…ˆé ­
	å‰
	å‰è¿°ã®:aforementioned
	å³è¾º
	å·¦è¾º
	å„
	å„ç¨®
	å„è¡Œ
	åŒã˜
	å¤šãã®
	å¯¾è±¡
	å¯¾å¿œ-:corresponding
	å°‘ãªãã¨ã‚‚:at least
	å±ã™ã‚‹
	å¾Œç¶šã®:subsequentï¼later
	å¾Œè€…
	å°¾éƒ¨ã®:trailing
	æœ€åˆ
	æœ€å¤§
	æœ€çŸ­:shortest
	é ­éƒ¨ã®:leading
	ã‹ã¤ã¦ã®:former
	å…¨ãã®:fully
	æ¬¡
	æ¬¡ã®
	æ¬¡å›
	ç•ªç›®
	ç¯€
	é€†æ–¹å‘:vice versa
	é¢
	é …
	é™¤ã„ã¦ï¼é™¤ãï¼é™¤ã
	è©²å½“-
	è¶…ãˆ
	éƒ¨åˆ†
	é–“
	éš›ã—
	é
	ç¨®ã®
	è‹¥å¹²ã®:slight
	è‹¥å¹²:slighty
	å›
	å¸¸ã«
	å¾Œã¯
	æ™‚
	æœ€ã‚‚
	æœ«å°¾
	ç­‰ã€…ã¨ç¶šã:and so on
	å€‹
	å€‹æ•°

</script>


<!--% style -->

<style>
#encoding-labels td + td {
	white-space: pre;
	white-space: pre-line;
}


.algo {
	color:#404;
	font-style: italic;
}

i {
	color: #808;
}

.coder {
	font-family: sans-serif0, sans-serif;
}

.label {
	color: #666;
}

b.ename {
	font-weight: normal;
	font-family: sans-serif0, sans-serif;
	color: black;
}

code > dfn {
	color: inherit;
}

.code-point,
.hex-value {
	font-family: sans-serif0, sans-serif;
}

#_big5-lead > tr > td:nth-child(2) {
	white-space: nowrap;
}

</style>


<style>
/* based on the style at
https://encoding.spec.whatwg.org/visualization-colors.css
(2017-01-22)
*/

._vis-visualizationlegend > tr > :first-child > div {
	box-sizing: border-box;
	width: 2em;
	height: 2em;
}

._vis-unmapped {
  background-color: #920000;
  color: white;
}

._vis-astral {
  background-color: #6db6fe;
  color: black;
}

._vis-mid {
  background-color: #ffff6d;
  color: black;
}

._vis-upper, ._vis-byte {
  background-color: #d4d5db;
  color: black;
}

._vis-pua {
  background-color: #db6d00;
  color: black;
}

._vis-mid._vis-contiguous {
  background-color: #009292;
  color: black;
}

._vis-upper._vis-contiguous {
  background-color: #24fe23;
  color: black;
}

._vis-pua._vis-contiguous {
  background-color: #924900;
  color: white;
}

._vis-astral._vis-contiguous {
  background-color: #480091;
  color: white;
}

._vis-duplicate {
  border-style: solid ;
  border-color: #920000;
  color: black;
}

._vis-compatibility {
  border-style: dashed;
  border-color: black;
}

._vis-duplicate._vis-compatibility {
  border-style: dashed;
  border-color: #920000;
}

._vis-ext {
  border-style: dotted;
  border-color: black;
}

._vis-ext._vis-compatibility {
  border-style: dotted;
  border-color: #920000;
}

._vis-surrogate {
  background-color: #b4b4b6;
}

</style>

</head>

<body>

<!--%UI -->
<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">

<h1>Encoding Standard æ—¥æœ¬èªè¨³</h1>
<p>
<a id="_THIS_PAGE">ã“ã®ãƒšãƒ¼ã‚¸</a>
ã¯ã€
<a href="https://whatwg.org/" >WHATWG</a>
ã«ã‚ˆã‚‹ï¼Œå‰¯é¡Œã®æ—¥ä»˜ã®
<a href="https://encoding.spec.whatwg.org/" >Encoding Standard</a>
ã‚’æ—¥æœ¬èªã«ç¿»è¨³ã—ãŸã‚‚ã®ã§ã™ã€‚
<strong >ã“ã®ç¿»è¨³ã®æ­£ç¢ºæ€§ã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“ã€‚</strong>
ã“ã®ä»•æ§˜ã®å…¬å¼ãªæ–‡æ›¸ã¯è‹±èªç‰ˆã§ã‚ã‚Šã€ã“ã®æ—¥æœ¬èªè¨³ã¯å…¬å¼ã®ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã€ ã¨ ã€‘ã§å›²ã¾ã‚ŒãŸéƒ¨åˆ†ã¯<span class="trans-note">ã€è¨³è€…ã«ã‚ˆã‚‹æ³¨é‡ˆã€‘</span>ã§ã™ã€‚
ï¼ˆ<a href="index.html">ä»–ã®ã‚¦ã‚§ãƒ–é–¢é€£ä»•æ§˜ã®ä¸€è¦§ã¨å…±é€šæ©Ÿèƒ½ã®è©³ç´°</a>ï¼‰
</p>

<p>
æ›´æ–°ï¼š <time>2017-08-17</time>
ï¼ˆå…¬é–‹ï¼š <time>2012-10-22</time>ï¼‰
</p>

<p >
ã“ã®ãƒšãƒ¼ã‚¸ã®å¤§éƒ¨åˆ†ã¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ã‚ˆã‚Šç”Ÿæˆã•ã‚Œã¦ã„ã¾ã™ï¼ˆ
å¤ã„ãƒ–ãƒ©ã‚¦ã‚¶ãªã©ï¼Œä¸€éƒ¨ã®ãƒ–ãƒ©ã‚¦ã‚¶ã«ã¯å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ï¼š
<span id="_GENERATING"></span>ï¼‰ã€‚
</p>

<p>
æœ¬æ–‡ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§å½“è©²ç®‡æ‰€ã®åŸæ–‡ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ï¼ˆå·¦ä¸‹éš…ã«å„ç¨® è¡¨ç¤ºåˆ‡æ›¿ãƒœã‚¿ãƒ³ â€” CSS ã‚„ DOM ã®å¯¾å¿œãŒå¤ã„ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã€ä¸€éƒ¨æ©Ÿèƒ½ã—ãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ï¼‰ã€‚
</p>

<address id="_CONTACT">ã€€</address>

</aside>


<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxwYXRoIGQ9Im01MCwwbDUwLDUwLTUwLDUwLTUwLTUwIiBmaWxsPSIjM2M3OTBhIi8+DQo8cGF0aCBkPSJtMzgsNDBjMC0xMiwyNC0xNSwyMy0yYzAsOS0xNiwxMy0xNiwyM3Y3aDEwdi00YzAtOSwxNy0xMiwxNy0yN2MtMi0yMi00NS0yMi00NSwzem03LDMyaDEwdjEwaC0xMCIgZmlsbD0iI2ZmZiIvPg0KPC9zdmc+DQo="
></a>

	<hgroup>
<h1>Encoding â€” ç¬¦å·åŒ–æ–¹å¼</h1>
<h2>Living Standard â€” æœ€çµ‚æ›´æ–° 2017 å¹´ 8 æœˆ 17 æ—¥</h2>
	</hgroup>
<dl>
	<dt>Participate:</dt>
	<dd>
<a href="https://github.com/whatwg/encoding">GitHub whatwg/encoding</a>
(<a href="https://github.com/whatwg/encoding/issues/new">file an issue</a>,
<a href="https://github.com/whatwg/encoding/issues">open issues</a>)</dd>
	<dd><a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a></dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/encoding/commits">GitHub whatwg/encoding/commits</a></dd>
	<dd><a href="https://encoding.spec.whatwg.org/commit-snapshots/debe869a71b0ec32fdcbf99b00f50f260c1d4403/">Snapshot as of this commit</a></dd>
	<dd><a href="https://twitter.com/encodings">@encodings</a></dd>

	<dt>Tests:</dt>
	<dd><a href="https://github.com/w3c/web-platform-tests/tree/master/encoding">web-platform-tests encoding/</a> (<a href="https://github.com/w3c/web-platform-tests/labels/encoding">ongoing work</a>)</dd>

	<dt>å„å›½èªç¿»è¨³ï¼ˆéè¦ç¯„çš„ï¼‰</dt>
	<dd>æ—¥æœ¬èªï¼ˆã“ã®ãƒšãƒ¼ã‚¸ï¼‰</dd>

</dl>


</header>


<main id="MAIN" style="display:none;">


	<section id="preface">

<h2 title="Preface">1. åº</h2>

<p>
~UTF-8~encodingã¯ã€çµ±ä¸€çš„ãªç¬¦å·åŒ–æ–‡å­—é›†åˆã§ã‚ã‚‹~Unicodeã®äº¤æ›ã«æœ€ã‚‚é©åˆ‡ãª~encodingã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ï¼Œã“ã®ä»•æ§˜ã¯ã€æ–°ãŸãªï¼»
~protocolã¨å½¢å¼
ï¼½, ãŠã‚ˆã³ï¼»
æ–°ãŸãªæ–‡è„ˆ~ä¸‹ã§æµå¸ƒã•ã‚Œã‚‹æ—¢å­˜ã®å½¢å¼
ï¼½ã«å¯¾ã—ã€~UTF-8~encodingã‚’è¦æ±‚ã™ã‚‹ï¼ˆã¾ãŸï¼Œå®šç¾©ã™ã‚‹ï¼‰ã€‚
â—
The UTF-8 encoding is the most appropriate encoding for interchange of Unicode, the universal coded character set. Therefore for new protocols and formats, as well as existing formats deployed in new contexts, this specification requires (and defines) the UTF-8 encoding.
</p>

<p>
~encodingã«ã¯ï¼Œä»–ã®ã‚‚ã®ï¼ˆæ—§æ¥ã®~encodingï¼‰ã‚‚ã‚ã‚Šï¼Œéå»ã«ã‚ã‚‹ç¨‹åº¦ã¾ã§ã¯å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŒã€~UAé–“ã§å¸¸ã«åŒã˜ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã¨ã¯é™ã‚‰ãªã„ã€‚
ã¾ãŸã€å¸¸ã«åŒã˜~labelã‚’åˆ©ç”¨ã—ã¦ã‚‹ã‚ã‘ã§ã‚‚ãªãã€~encodingã®ä¸­ã®æœªå®šç¾©ã®åŒºç”», ã‚ã‚‹ã„ã¯ ã‹ã¤ã¦ã®~proprietaryãªåŒºç”»ã«ã¤ã„ã¦ã®æ‰±ã„ã‚‚ï¼Œã—ã°ã—ã°ç•°ãªã£ã¦ã„ã‚‹ã€‚
ã“ã®ä»•æ§˜ã¯ã€æ–°ãŸãªå®Ÿè£…ãŒ~encodingå®Ÿè£…ã‚’ãƒªãƒãƒ¼ã‚¹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã›ãšã«æ¸ˆã‚€ã‚ˆã†ã«ï¼Œã¾ãŸ, æ—¢å­˜ã®~UAãŒä¸€ã¤ã«åæŸã—å¾—ã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€ã“ã‚Œã‚‰ã®éš”ãŸã‚Šã‚’åŸ‹ã‚ã‚‹ã“ã¨ã«å–çµ„ã‚€ã€‚
â—
The other (legacy) encodings have been defined to some extent in the past. However, user agents have not always implemented them in the same way, have not always used the same labels, and often differ in dealing with undefined and former proprietary areas of encodings. This specification addresses those gaps so that new user agents do not have to reverse engineer encoding implementations and existing user agents can converge.
</p>

<p>
ç‰¹ã«ï¼Œã“ã®ä»•æ§˜ã¯ã€ãã‚Œã‚‰ã®~encodingã¨ï¼Œãã®ãã‚Œãã‚Œã«ãŠã‘ã‚‹ï¼»
~byteåˆ—ã¨`~scalarå€¤$ åˆ—ã‚’ç›¸äº’ã«å¤‰æ›ã™ã‚‹~algo
ï¼½, ãŠã‚ˆã³ï¼»
ä¸€é€£ã®`~label$ã‚’è­˜åˆ¥ã™ã‚‹æ­£æº–çš„ãªåå‰
ï¼½ã‚’å®šç¾©ã™ã‚‹ã€‚
ã¾ãŸã€~encodingã®å„ç¨®~algoã®ã†ã¡ä¸€éƒ¨ã‚’ JavaScript ã«å…¬é–‹ã™ã‚‹~APIã‚‚å®šç¾©ã™ã‚‹ã€‚
â—
In particular, this specification defines all those encodings, their algorithms to go from bytes to scalar values and back, and their canonical names and identifying labels. This specification also defines an API to expose part of the encoding algorithms to JavaScript.
</p>

<p>
~UAã¯ï¼Œã™ã§ã«
<a href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">IANA Character Sets registry</a>
ã«æŒ™ã’ã‚‰ã‚Œã¦ã„ã‚‹~labelã‹ã‚‰ã‚‚ æœ‰æ„ã«é€¸è„±ã—ã¦ã„ã‚‹ã€‚
æ—§æ¥ã®~encodingã‚’ ã“ã‚Œä»¥ä¸Š~æ‹¡æ•£ã•ã›ãªã„ãŸã‚ã€ã“ã®ä»•æ§˜ã¯ï¼Œå‰è¿°ã®è©³ç´°ã«ã¤ã„ã¦ç¶²ç¾…çš„ã§ã‚ã‚Šï¼Œ registry ã¯ã‚‚ã†ä¸è¦ã§ã‚ã‚‹ã€‚
ç‰¹ã«ï¼Œã“ã®ä»•æ§˜ã¯ã€~encodingã‚’æ‹¡å¼µã™ã‚‹ãŸã‚ã®ä»•çµ„ã¿ã¯æä¾›ã—ãªã„ã€‚
â—
User agents have also significantly deviated from the labels listed in the IANA Character Sets registry. To stop spreading legacy encodings further, this specification is exhaustive about the aforementioned details and therefore has no need for the registry. In particular, this specification does not provide a mechanism for extending any aspect of encodings.
</p>

	</section>
	<section id="security-background">

<h2 title="Security background">2. ä¿å®‰ã«é–¢ã™ã‚‹èƒŒæ™¯</h2>

<p>
~encodingã«ã¯ã€ã„ãã¤ã‹ã®ä¿å®‰~ä¸Šã®èª²é¡ŒãŒã‚ã‚‹
â€” ç”Ÿç”£å´ã¨æ¶ˆè²»å´ã®é–“ã§ï¼Œï¼»
åˆ©ç”¨ä¸­ã®~encoding, ã‚ã‚‹ã„ã¯æ‰€ä¸ã®~encodingã®å®Ÿè£…-æ³•
ï¼½ã«ã¤ã„ã¦åˆæ„ã•ã‚Œã¦ãªã„ã¨ãã«ã€‚
ä¾‹ãˆã° 2011 å¹´ã«ã¯ã€æ¬¡ã®ã‚ˆã†ãªæ”»æ’ƒãŒå ±å‘Šã•ã‚Œã¦ã„ã‚‹ï¼š
ãã“ã§ã¯ã€ï¼»
æ”»æ’ƒè€…ãŒä½•ã‚‰ã‹ã®~fieldã‚’åˆ¶å¾¡ã—å¾—ã‚‹ã‚ˆã†ãªï¼Œ JSON è³‡æº
ï¼½å†…ã® `22^X ~trail~byteã‚’ â€œéš ã™â€ ãŸã‚ã«ï¼Œ`Shift_JIS$n ã®~lead~byte `82^X ãŒåˆ©ç”¨ã•ã‚ŒãŸã€‚
ç”Ÿç”£å´ã‹ã‚‰ã¯ï¼Œã“ã‚ŒãŒé•æ³•ãª~byteå¯¾ã§ã‚ã£ã¦ã‚‚å•é¡ŒãŒè¦‹ãˆãªã„ä¸€æ–¹ã§ã€æ¶ˆè²»å´ã§ã¯ï¼Œã“ã®~byteå¯¾ã‚’å˜ç‹¬ã® `FFFD^U ã¨ã—ã¦~decodeã™ã‚‹~~çµæœã€å…¨ä½“çš„ãªè§£é‡ˆãŒå¤‰ã‚ã£ã¦ã—ã¾ã† â€” `0022^U ã¯é‡è¦ãªåŒºåˆ‡å­ãªã®ã§ã€‚
ï¼»
`~scalarå€¤$ã«å¯¾ã—è¤‡æ•°~byteã‚’åˆ©ç”¨ã™ã‚‹~encoding
ï¼½ã®~decoderã«ã¯ã€ä»Šã‚„ï¼Œé•æ³•ãª~byteå¯¾ã®äº‹ä¾‹ã§ã¯ï¼Œï¼»
ç¯„å›² `0000^U ã€œ `007F^U ã«å…¥ã‚‹~scalarå€¤
ï¼½ã‚’ â€œéš ã›ãªã„â€ ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒè¦æ±‚ã•ã‚Œã‚‹
â€” å‰è¿°ã®~byteå¯¾ã«å¯¾ã—ã¦ã¯ã€å‡ºåŠ›ãŒï¼»
`FFFD^U `0022^U
ï¼½ã«ãªã‚‹ã‚ˆã†ã«ã€‚
â—
There is a set of encoding security issues when the producer and consumer do not agree on the encoding in use, or on the way a given encoding is to be implemented. For instance, an attack was reported in 2011 where a Shift_JIS lead byte 0x82 was used to â€œmaskâ€ a 0x22 trail byte in a JSON resource of which an attacker could control some field. The producer did not see the problem even though this is an illegal byte combination. The consumer decoded it as a single U+FFFD and therefore changed the overall interpretation as U+0022 is an important delimiter. Decoders of encodings that use multiple bytes for scalar values now require that in case of an illegal byte combination, a scalar value in the range U+0000 to U+007F, inclusive, cannot be â€œmaskedâ€. For the aforementioned sequence the output would be U+FFFD U+0022.
</p>

<p>
ã“ã‚Œã¯ã€ã‚ˆã‚Š~~ä¸€èˆ¬çš„ã«ã¯ï¼Œï¼»
~lead~byteãŒä¼´ã‚ã‚Œãªã„ã¨ãã«ï¼Œ`~ASCII~byte$ã‚’`~ASCII~cp$ã§ãªã„ä½•ã‹ã«å¯¾å¿œä»˜ã‘ã‚‹
ï¼½ã‚ˆã†ãª~encodingã«ãŠã‘ã‚‹èª²é¡Œã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚‰ã¯ï¼Œ â€œ~ASCIIéäº’æ›â€ ã®~encodingã§ã‚ã‚Šã€ã‚ã„ã«ãï¼Œã™ã§ã«æµå¸ƒã•ã‚ŒãŸå†…å®¹ã®ãŸã‚ã«è¦æ±‚ã•ã‚Œã‚‹ãŒã€ï¼»
`ISO-2022-JP$n, `UTF-16BE$n, `UTF-16LE$n
ï¼½ä»¥å¤–ã®ã‚‚ã®ã¯ï¼Œ~supportã•ã‚Œãªã„ã€‚
ï¼ˆãã®ç¨®ã® ä»–ã®~encoding`~label$ã«ã¤ã„ã¦ã‚‚ã€æœªçŸ¥ã®~encodingã¸~fallbackã›ãšã«ï¼Œ`replacement$n ~encodingã«å¯¾å¿œä»˜ã‘ã¦ã‚ˆã„ã‹ã©ã†ã‹ã®ç©¶æ˜ãŒ
<a href="https://github.com/whatwg/encoding/issues/8" title="Add more labels to the replacement encoding">é€²è¡Œä¸­ã«ã‚ã‚‹</a>
ã€‚ï¼‰
æ”»æ’ƒã®ä¸€~ä¾‹ã¨ã—ã¦ã€æ³¨æ„æ·±ãç´°å·¥ã•ã‚ŒãŸå†…å®¹ã‚’è³‡æºã®ä¸­ã¸æ³¨å…¥ã—ã¦ï¼Œåˆ©ç”¨è€…ã«~encodingã‚’ä¸Šæ›¸ãã™ã‚‹ã‚ˆã†ä¿ƒã™~~çµæœã€ä¾‹ãˆã°~scriptã®å®Ÿè¡Œã«è‡³ã‚‰ã›ã‚‹ã‚‚ã®ãŒã‚ã‚‹ã€‚
â—
This is a larger issue for encodings that map anything that is an ASCII byte to something that is not an ASCII code point, when there is no lead byte present. These are â€œASCII-incompatibleâ€ encodings and other than ISO-2022-JP, UTF-16BE, and UTF-16LE, which are unfortunately required due to deployed content, they are not supported. (Investigation is ongoing whether more labels of other such encodings can be mapped to the replacement encoding, rather than the unknown encoding fallback.) An example attack is injecting carefully crafted content into a resource and then encouraging the user to override the encoding, resulting in e.g. script execution. 
</p>

<p>
~HTMLã‚„~HTMLã®~formç‰¹è‰²æ©Ÿèƒ½ã«è¦‹å‡ºã•ã‚Œã‚‹~URLã«åˆ©ç”¨ã•ã‚Œã‚‹~encoderã‚‚ã€ãã®~encodingã«ã‚ˆã‚Šè¡¨ç¾ã§ããªã„~scalarå€¤ãŒã‚ã‚‹å ´åˆã«ã¯ï¼Œè‹¥å¹²ã®æƒ…å ±å–ªå¤±ã«ã¤ãªãŒã‚Šå¾—ã‚‹ã€‚
ä¾‹ãˆã°ï¼Œè³‡æºãŒ `windows-1252$n ~encodingã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ã¨ãã€~serverã¯ï¼Œæœ«ç«¯åˆ©ç”¨è€…ãŒ~formã«æ‰‹å…¥åŠ›ã—ãŸ â€œğŸ’©â€ ã¨ â€œ&amp;#128169;â€ ã¨ã‚’åˆ¤åˆ¥ã§ããªããªã‚‹ã€‚
â—
Encoders used by URLs found in HTML and HTMLâ€™s form feature can also result in slight information loss when an encoding is used that cannot represent all scalar values. E.g. when a resource uses the windows-1252 encoding a server will not be able to distinguish between an end user entering â€œğŸ’©â€ and â€œ&amp;#128169;â€ into a form.
</p>

<p>
ã“ã“ã«è¦æ—¨ã—ãŸå•é¡Œã¯ã€~UTF-8ã‚’æ’ä»–çš„ã«åˆ©ç”¨ã—ã¦ã„ã‚‹ã¨ãã¯ï¼Œéœ§æ¶ˆã™ã‚‹ã€‚
ãã‚ŒãŒã€ä»Šã‚„ã™ã¹ã¦ã«å¯¾ã—~UTF-8~encodingãŒç¾©å‹™ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ç†ç”±ã®ä¸€ã¤ã§ã‚ã‚‹ã€‚
â—
The problems outlined here go away when exclusively using UTF-8, which is one of the many reasons that is now the mandatory encoding for all things.
</p>

<p class="note">æ³¨è¨˜ï¼š
<a href="#browser-ui">~browser UI</a> ç¯€ã‚‚è¦‹ã‚ˆã€‚
â—
See also the Browser UI chapter.
</p>

	</section>
	<section id="terminology">

<h2 title="Terminology">3. å„ç¨®ç”¨èª</h2>

<p>
ã“ã®ä»•æ§˜ã¯ Infra Standard `INFRA$r ã«ä¾å­˜ã™ã‚‹ã€‚
â—
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
16 é€²æ•°ã«ã¯ "0x" ãŒå‰ç½®ã•ã‚Œã‚‹ã€‚
â—
Hexadecimal numbers are prefixed with "0x".
</p>

<div class="p">
<p>
ç®—è¡“å¼ã®ä¸­ã®ã™ã¹ã¦ã®æ•°å€¤ã¯æ•´æ•°ã§ã‚ã‚Šã€å„ç¨®~æ¼”ç®—ã¯æ¬¡ã®è¨˜å·ã§è¡¨ç¾ã•ã‚Œã‚‹ï¼š
</p>

<table>
<thead><tr><th>è¨˜å·
<th>æ„å‘³
</thead><tbody>

<tr><th>~PLUS
<td>åŠ ç®—

<tr><th>~MINUS
<td>æ¸›ç®—

<tr><th>~INCBY
<td>å·¦è¾º~å€¤ã«å¯¾ã™ã‚‹å³è¾º~å€¤ã«ã‚ˆã‚‹åŠ ç®—

<tr><th>~DECBY
<td>å·¦è¾º~å€¤ã«å¯¾ã™ã‚‹å³è¾º~å€¤ã«ã‚ˆã‚‹æ¸›ç®—

<tr><th>~MUL
<td>ä¹—ç®—

<tr><th>~DIV
<td>æ•´æ•°ã®é™¤ç®—ï¼ˆå°æ•°åˆ‡ã‚Šæ¨ã¦ï¼‰

<tr><th>~MOD
<td>æ•´æ•°ã®é™¤ç®—ã®å‰°ä½™ï¼ˆ modulo ï¼‰

<tr><th>~Lshift
<td>è«–ç†~å·¦~shift

<tr><th>~Rshift
<td>è«–ç†~å³~shift

<tr><th>~bAND
<td>~bit AND

<tr><th>~bOR
<td>~bit OR

</tbody></table>

<p class="trans-note">ã€
è¨˜å· ~INCBY, ~DECBY ã¯è¨³è€…ã«ã‚ˆã‚‹è¿½åŠ ã€‚
ã€‘</p>

â—
In equations, all numbers are integers, addition is represented by "+", subtraction by "âˆ’", multiplication by "Ã—", integer division by "/" (returns the quotient), modulo by "%" (returns the remainder of an integer division), logical left shifts by "&lt;&lt;", logical right shifts by "&gt;&gt;", bitwise AND by "&amp;", and bitwise OR by "|". 
</div>

<p>
è«–ç†~å³~shiftã®æ¼”ç®—~å¯¾è±¡ã®ç²¾åº¦ã¯ã€å°‘ãªãã¨ã‚‚ 21 ~bitä»¥ä¸Šã§~MUSTã€‚
â—
For logical right shifts operands must have at least twenty-one bits precision.
</p>

<p>
`~token@
ã¯ã€`~byte$ã‚„`~cp$ãªã©ã®ï¼Œ 1 å€‹ã®~dataç‰‡ã§ã‚ã‚‹ã€‚
â—
A token is a piece of data, such as a byte or code point.
</p>

<p>
`~stream@
ã¯ã€æœ‰é †åº`~token$åˆ—ã‚’è¡¨ç¾ã™ã‚‹ã€‚
`~EoS@
ã¯ã€`~stream$ã«ãã‚Œä»¥ä¸Š èª­å–ã‚Œã‚‹`~token$ã¯ç„¡ã„ã“ã¨ã‚’è¡¨ã™ï¼Œç‰¹åˆ¥ãª`~token$ã§ã‚ã‚‹ã€‚
â—
A stream represents an ordered sequence of tokens. End-of-stream is a special token that signifies no more tokens are in the stream.
</p>

<p class="trans-note">ã€
~streamã¨~tokenåˆ—ã¯ï¼ˆ â€œé™çš„ãªâ€ ï¼‰~dataæ§‹é€ ã¨ã—ã¦ã¯åŒã˜ã§ã‚‚ï¼Œ
 â€œ~streamâ€ ã«ã¯ï¼Œãã®ã‚¢ã‚¯ã‚»ã‚¹ãŒ
å…ˆé ­ï¼ˆå…¥åŠ›ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸå ´åˆï¼‰ï¼æœ«å°¾ï¼ˆå‡ºåŠ›~å…ˆã®å ´åˆï¼‰
ã«ï¼ˆ â€œæ™‚ç³»åˆ—çš„ã«â€ ï¼‰åˆ¶ç´„ã•ã‚Œã‚‹ã“ã¨ãŒå«æ„ã•ã‚Œã‚‹ã€‚
ã€‘</p>

<div class="algo-head">
<p>
`~stream$ã‹ã‚‰`~token$ã‚’
<dfn id="concept-stream-read">èª­å–ã‚‹</dfn>
ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã›~MUSTï¼š
</p>
<ol>
	<li>
~IFï¼»
~streamã¯ç©ºã§ã‚ã‚‹
ï¼½
â‡’
~RET `~EoS$
</li>
	<li>
~streamã®å…ˆé ­ã‹ã‚‰ 1 å€‹ã®~tokenã‚’é™¤å»ã™ã‚‹
</li>
	<li>
~RET å‰~æ®µã§é™¤å»ã—ãŸ~token
</li>
</ol>

<!-- this means read is blocking on e.g. networking activity;
     SimonSapin thinks this is fine, curse him if not -->
â—
When a token is read from a stream, the first token in the stream must be returned and subsequently removed, and end-of-stream must be returned otherwise.
</div>

<p>
1 å€‹~ä»¥ä¸Šã®`~token$ã‚’`~stream$ã«
`å‰ä»˜åŠ ã™ã‚‹@
ã¨ãã¯ã€ãã‚Œã‚‰ã®~tokenã‚’ï¼Œ~streamã®å…ˆé ­ã«, æ‰€ä¸ã®é †åºã‚’ä¿ã£ãŸã¾ã¾æŒ¿å…¥ã—~MUSTã€‚
â—
When one or more tokens are prepended to a stream, those tokens must be inserted, in given order, before the first token in the stream.
</p>

<p class="example">
~tokenåˆ— "<code>&amp;#128169;</code>" ã‚’~stream "<code> hello world</code>" ã®å…ˆé ­ã«æŒ¿å…¥ã—ãŸçµæœã¯ï¼Œ~stream "<code>&amp;#128169; hello world</code>" ã«ãªã‚Šã€æ¬¡å›ã«èª­å–ã‚‰ã‚Œã‚‹~tokenã¯ <code>&amp;</code> ã«ãªã‚‹ã€‚
<!-- ğŸ’© --><!-- #x1F4A9 = 128169 decimal -->
â—
Inserting the sequence of tokens &amp;#128169; in a stream " hello world", results in a stream "&amp;#128169; hello world". The next token to be read would be &amp;.
</p>

<p>
1 å€‹~ä»¥ä¸Šã®`~token$ã‚’`~stream$ã«
`~pushã™ã‚‹@
ã¨ãã¯ã€ãã‚Œã‚‰ã®~tokenã‚’ï¼Œ~streamã®æœ«å°¾ã«, æ‰€ä¸ã®é †åºã‚’ä¿ã£ãŸã¾ã¾ä»˜åŠ ã—~MUSTã€‚
â—
When one or more tokens are pushed to a stream, those tokens must be inserted, in given order, after the last token in the stream.
</p>



	</section>

	<section id="_conventions">
<h2>ã€ã“ã®è¨³ã«å›ºæœ‰ã®è¡¨è¨˜è¦ç´„ã€‘</h2>

<p>
ã“ã®è¨³ã®ï¼Œ~algoã®è¨˜è¿°ã«åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹å„ç¨®è¨˜å·ï¼ˆæ­¤ã‚Œ, ~LET, ~ON, ~IF, ~RET, ç­‰ã€…ï¼‰ã®æ„å‘³ã‚„å®šç¾©ã®è©³ç´°ã¯ã€~SYMBOL_DEF_REFã‚’~~å‚ç…§ã•ã‚ŒãŸã—ã€‚
åŠ ãˆã¦ã€æ¬¡ã®è¨˜æ³•ã‚‚ç”¨ã„ã‚‰ã‚Œã‚‹ï¼š
</p>

<table><thead><tr><th style="min-width: 10em;">è¨˜æ³•
<th>æ„å‘³
</thead>

<tbody>
<tr><th style="white-space:nowrap;">~byteåˆ— [ %value1, %value2, â€¦ ]
<td>
æ•°å€¤çš„ã« %value1, %value2 â€¦ ã¨åŒã˜å€¤ã‚’ã¨ã‚‹ä¸€é€£ã®`~byte$ã‹ã‚‰ãªã‚‹, æ‰€ä¸ã®é †åºã«ã‚ˆã‚‹ï¼Œæ–°ãŸãª`~token$åˆ—ã®~instanceã‚’æ„å‘³ã™ã‚‹ã€‚
è§’æ‹¬å¼§ã®ä¸­ãŒç©º
â€” â€œ~byteåˆ— [] â€ â€”
ã¨è¨˜ã•ã‚ŒãŸã¨ãã¯ï¼Œç©ºã®`~token$åˆ—ã‚’æ„å‘³ã™ã‚‹ã€‚

<tr><th style="white-space:nowrap;">~cp [ %value ]
<td>
æ•°å€¤çš„ã« %value ã¨åŒã˜å€¤ã‚’ã¨ã‚‹ 1 å€‹ã®`~cp$ã‹ã‚‰ãªã‚‹ï¼Œæ–°ãŸãª`~token$åˆ—ã®~instanceã‚’æ„å‘³ã™ã‚‹ã€‚

</tbody></table>

	</section>
	<section id="encodings">

<h2 title="Encodings">4. ~encoding</h2>

<p>
`~encoding@
ã¯ã€`~scalarå€¤$ åˆ—ã‹ã‚‰~byteåˆ—ã¸ã®å¯¾å¿œé–¢ä¿‚
ã€~encodeã€‘
ãŠã‚ˆã³é€†æ–¹å‘ã¸ã®å¯¾å¿œé–¢ä¿‚
ã€~decodeã€‘
ã‚’å®šç¾©ã™ã‚‹ã€‚
ãã‚Œãã‚Œã®`~encoding$ã«ã¯ã€
`åå‰@
ãŠã‚ˆã³ï¼Œ 1 å€‹~ä»¥ä¸Šã®
`~label@
ãŒ<a href="#encoding-labels">ã‚ã¦ãŒã‚ã‚Œã¦ã„ã‚‹</a>ã€‚
â—
An encoding defines a mapping from a scalar value sequence to a byte sequence (and vice versa). Each encoding has a name, and one or more labels.
</p>

		<section id="encoders-and-decoders">
<h3 title="Encoders and decoders">4.1. ~encoderã¨~decoder</h3>

<div class="p">
<p>
å„ç¨® `~encoding$ã«ã¯ã€
`~decoder@
ã¨
`~encoder@
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
å„ `~decoder$ ï¼ å„ `~encoder$ã«ã¯ã€
`~handler@
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
`~handler$ã¯ã€
( `~stream$, 1 å€‹ã®`~token$ )
ã‚’å…¥åŠ›ã«ã¨ã‚Šï¼Œæ¬¡ã®ã„ãšã‚Œã‹ã‚’è¿”ã™~algoã§ã‚ã‚‹ï¼š
</p>

<ul>
	<li>`å®Œé‚@</li>
	<li>
<p>
ç©ºã§ãªã„`~token$åˆ—
</p>

<p class="trans-note">ã€
ã»ã¨ã‚“ã©ã®~decoderã®~handlerã¯ï¼Œ 1 å€‹ã®~cpã‹ã‚‰ãªã‚‹~tokenåˆ—ã‚’è¿”ã™ãŒã€
`~Big5~decoder$ã®~handlerã ã‘ï¼Œ 2 å€‹ã®~cpã‚’è¿”ã™å ´åˆãŒã‚ã‚‹ã€‚
ã€‘</p>
	</li>
	<li>
<p>
~optionã§`~cp$ã‚‚ä¼´ã„å¾—ã‚‹ï¼Œ`~error@
</p>
<p class="trans-note">ã€
~encoderã®~handlerã®ã¿ãŒã€å¸¸ã«ï¼Œ~cpã‚‚ä¼´ã†~errorã‚’è¿”ã™ã€‚
ã€‘</p>
	</li>
	<li>`ç¶™ç¶š@</li>
</ul>

â—
Each encoding has an associated decoder and most of them have an associated encoder. Each decoder and encoder have a handler algorithm. A handler algorithm takes an input stream and a token, and returns finished, one or more tokens, error optionally with a code point, or continue.
</div>


<p class="note">æ³¨è¨˜ï¼š
ï¼»
`replacement$n, `UTF-16BE$n, `UTF-16LE$n
ï¼½`~encoding$ã«ã¯ã€`~encoder$ã¯ãªã„ã€‚
â—
The replacement, UTF-16BE, and UTF-16LE encodings have no encoder.
</p>


<div class="p">

<p>
ä»¥ä¸‹ã§ç”¨ã„ã‚‰ã‚Œã‚‹
`~error~mode@
ã¯ï¼š
</p>

<ul>
	<li>
`~decoder$ã«å¯¾ã—ã¦ã¯ï¼Œï¼»
`replacement^lï¼ˆæ—¢å®šï¼‰,
`fatal^l
ï¼½ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚‹ã€‚
</li>
	<li>
`~encoder$ã«å¯¾ã—ã¦ã¯ï¼Œï¼»
`fatal^lï¼ˆæ—¢å®šï¼‰ ,
`html^l
ï¼½ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚‹ã€‚
</li>

</ul>

â—
An error mode as used below is "replacement" (default) or "fatal" for a decoder and "fatal" (default) or "html" for an encoder.
</div>

<p class="note">æ³¨è¨˜ï¼š
XML å‡¦ç†å™¨ã¯ã€ãã®`~decoder$ã®`~error~mode$ã‚’ `fatal^l ã«è¨­å®šã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
`XML$r
â—
An XML processor would set error mode to "fatal". [XML]
</p>

<p class="note">æ³¨è¨˜ï¼š
`~error~mode$ã« `html^l ãŒå­˜åœ¨ã™ã‚‹ç†ç”±ã¯ã€
~URLã‚„~HTML~formã«ãŠã„ã¦ã¯ï¼Œ`~error$ã«éš›ã—æ—§æ¥ã®`~encoder$ã‚’çµ‚äº†ã•ã›ãªã„ã‚ˆã†ã«ã™ã‚‹å–æ‰±ã„ã‚’è¦ã™ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
`html^l `~error~mode$ã¯ã€åˆæ³•ãªå…¥åŠ›ã¨åˆ¤åˆ¥ã§ããªã„åˆ—ã‚’~~å‡ºåŠ›ã•ã›ï¼Œ~~æ¤œçŸ¥ã•ã‚Œã‚‹ã“ã¨ãªã~dataã‚’å¤±ã‚ã›ã‚‹ã€‚
ã“ã‚Œã‚’é˜²ããŸã‚ã€é–‹ç™ºè€…ã«ã¯ `UTF-8$n `~encoding$ã®åˆ©ç”¨ãŒå¼·ãå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
`URL$r
`HTML$r
â—
html exists as error mode due to URLs and HTML forms requiring a non-terminating legacy encoder. The "html" error mode causes a sequence to be emitted that cannot be distinguished from legitimate input and can therefore lead to silent data loss. Developers are strongly encouraged to use the UTF-8 encoding to prevent this from happening. [URL] [HTML]
</p>

<div class="algo-head">
<p>
`~encoding$ã®ï¼»
`~decoder$ ï¼ `~encoder$
ï¼½ %~coder ã‚’
`èµ°ã‚‰ã™@
ã¨ãã¯ã€æ‰€ä¸ã®ï¼š
</p>

<ul><li>å…¥åŠ›`~stream$ : %å…¥åŠ›
</li><li>å‡ºåŠ›`~stream$ : %å‡ºåŠ›
</li><li>`~error~mode$ : %~mode ï¼ˆçœç•¥æ™‚ã¯ Îµ ï¼‰
</li></ul>

<p>
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
</p>
â—
To run an encodingâ€™s decoder or encoder encoderDecoder with input stream input, output stream output, and optional error mode mode, run these steps:
</div>

<ol>
	<li>
~IFï¼»
%~mode ~EQ Îµ
ï¼½
â‡’
%~mode ~SET %~coder ã«å¿œã˜ã¦
â‡’
`~decoder$ã§ã‚ã‚‹ãªã‚‰ã° `replacement^l ~BR
`~encoder$ã§ã‚ã‚‹ãªã‚‰ã° `fatal^l
â—
If mode is not given, set it to "replacement", if encoderDecoder is a decoder, and "fatal" otherwise.
</li>
	<li>
%~coder~instance ~LET æ–°ãŸãª %~coder ã®~instance
â—
Let encoderDecoderInstance be a new encoderDecoder.
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>

		<ol>
			<li>
%çµæœ ~LET  æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ`~tokenã‚’å‡¦ç†-$ã—ãŸçµæœ
â‡’
( %å…¥åŠ› ã‹ã‚‰`èª­å–ã£ãŸçµæœ$, %~coder~instance, %å…¥åŠ›, %å‡ºåŠ›, %~mode )
â—
Let result be the result of processing the result of reading from input for encoderDecoderInstance, input, output, and mode.
</li>
			<li>
~IFï¼»
%çµæœ ~NEQ `ç¶™ç¶š$
ï¼½
â‡’
~RET %çµæœ
â—
If result is not continue, return result.
â—
Otherwise, do nothing. 
</li>
		</ol>
	</li>
</ol>

<div class="algo-head">
<p>
`~tokenã‚’å‡¦ç†-@
ã™ã‚‹ã¨ãã¯ã€æ‰€ä¸ã®ï¼š
</p>

<ul><li>`~token$ : %~token 
</li><li>`~encoding$ã®ï¼»
`~encoder$ï¼`~decoder$
ï¼½ã®~instance : %~coder~instance
</li><li>
å…¥åŠ›`~stream$ : %å…¥åŠ›
</li><li>
å‡ºåŠ›`~stream$ : %å‡ºåŠ›
</li><li>
`~error~mode$ : %~modeï¼ˆçœç•¥æ™‚ã¯ Îµ ï¼‰
</li></ul>

<p>
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
</p>
â—
To process a token token for an encodingâ€™s encoder or decoder instance encoderDecoderInstance, stream input, output stream output, and optional error mode mode, run these steps:
</div>

<ol>
	<li>
~IFï¼»
%~mode ~EQ Îµ
ï¼½
â‡’
%~mode ~SET %~coder~instance ã«å¿œã˜ã¦
â‡’
`~decoder$ã®~instanceã§ã‚ã‚‹ãªã‚‰ã° `replacement^l ï¼
`~encoder$ã®~instanceã§ã‚ã‚‹ãªã‚‰ã° `fatal^l
â—
If mode is not given, set it to "replacement", if encoderDecoderInstance is a decoder instance, and "fatal" otherwise.
</li>
	<li>
%çµæœ ~LET
( %å…¥åŠ›, %~token )
ã«å¯¾ã—ï¼Œ %~coder~instance ã«ã‚ˆã‚‹`~handler$ã‚’èµ°ã‚‰ã›ãŸçµæœ
â—
Let result be the result of running encoderDecoderInstanceâ€™s handler on input and token.
</li>
	<li>
~IFï¼»
%çµæœ ~IN { `ç¶™ç¶š$, `å®Œé‚$ }
ï¼½
â‡’
~RET %çµæœ
â—
If result is continue or finished, return result.
</li>
	<li>
~IFï¼»
%çµæœ ã« 1 å€‹~ä»¥ä¸Šã®`~token$ãŒã‚ã‚‹
ï¼½
â‡’
%çµæœ ã‚’ %å‡ºåŠ› ã«`~pushã™ã‚‹$
â—
Otherwise, if result is one or more tokens, push result to output.
</li>
	<li>
<p>
~ELIFï¼»
%çµæœ ~EQ `~error$
ï¼½
â‡’
%~mode ã«å¿œã˜ã¦ï¼š
â—
Otherwise, if result is error, switch on mode and run the associated steps:
</p>

		<dl class="switch">
			<dt>`replacement^l</dt>
			<dd>
`FFFD^U ã‚’ %å‡ºåŠ› ã«`~pushã™ã‚‹$
â—
Push U+FFFD to output.
</dd>

			<dt>`html^l</dt>
			<dd>
~cpåˆ—ï¼»
`0026^U, `0023^U, ï¼»
%çµæœ ã®`~cp$ã‚’åŸºæ•° 10 ã«ã‚ˆã‚Šæœ€çŸ­ã§è¡¨ç¾ã™ã‚‹`~ASCIIæ•°å­—$åˆ—
ï¼½, `003B^U
ï¼½
ã€ "<code>&amp;#<var>æ•°å­—åˆ—</var>;</code>" ã€‘
ã‚’
%å…¥åŠ› ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend U+0026, U+0023, followed by the shortest sequence of ASCII digits representing resultâ€™s code point in base ten, followed by U+003B to input.
</dd>

			<dt>`fatal^l</dt>
			<dd>
~RET `~error$
â—
Return error.
</dd>
		</dl>
	</li>
	<li>
~RET `ç¶™ç¶š$
â—
Return continue.
</li>
</ol>



		</section>
		<section id="names-and-labels">

<h3 title="Names and labels">4.2. åå‰ã¨~label</h3>

<p>
ä¸‹ã®ä¸€è¦§ã«ã€~UAãŒ~supportã—~MUSTï¼Œã™ã¹ã¦ã®`~encoding$ã¨ãã‚Œã‚‰ã®`~label$ã‚’æŒ™ã’ã‚‹ã€‚
~UA ã¯ã€ä»–ã®`~encoding$ã‚„`~label$ã‚’~supportã—ã¦ã¯~MUST_NOTã€‚
â—
The table below lists all encodings and their labels user agents must support. User agents must not support any other encodings or labels.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã©ã®~encodingã«ã¤ã„ã¦ã‚‚ã€ãã®`~label$ã®é›†åˆã¯ï¼Œ`åå‰$ã‚’`~ASCIIå°æ–‡å­—~åŒ–$ã—ãŸã‚‚ã®ã‚’å«ã‚“ã§ã„ã‚‹ã€‚
â—
For each encoding, ASCII-lowercasing its name yields one of its labels.
</p>

<p>
ä½œè€…ã¯ã€ `UTF-8$n `~encoding$ã‚’åˆ©ç”¨ã—ãŸä¸Šã§ï¼Œãã®åˆ©ç”¨ãŒè­˜åˆ¥ã•ã‚Œã‚‹ã‚ˆã†ã«ï¼»
`~ASCIIå¤§å°ç„¡è¦–$ã§ `utf-8^lb ã«åˆè‡´ã™ã‚‹`~label$
ï¼½ã‚’åˆ©ç”¨ã—~MUSTã€‚
â—
Authors must use the UTF-8 encoding and must use the ASCII case-insensitive "utf-8" label to identify it.
</p>

<p>
æ–°ãŸãªï¼»
~protocolã¨å½¢å¼
ï¼½, ã‚ã‚‹ã„ã¯ï¼»
æ–°ãŸãªæ–‡è„ˆ~ä¸‹ã§æµå¸ƒã•ã‚Œã‚‹æ—¢å­˜ã®å½¢å¼
ï¼½ã«ã¯ã€ `UTF-8$n `~encoding$ãŒæ’ä»–çš„ã«åˆ©ç”¨ã•ã‚Œ~MUSTã€‚
ã“ã‚Œã‚‰ã®ï¼»
~protocolã‚„å½¢å¼
ï¼½ã®`~encoding$ã®ï¼»
`åå‰$ã‚„`~label$
ï¼½ã¯ã€ `utf-8^lb ã¨ã—ã¦å…¬é–‹ã•ã‚Œ~MUSTã€‚
â—
New protocols and formats, as well as existing formats deployed in new contexts, must use the UTF-8 encoding exclusively. If these protocols and formats need to expose the encodingâ€™s name or label, they must expose it as "utf-8".
</p>

<p class="algo-head">
æ–‡å­—åˆ— %~label ã‹ã‚‰
`~encodingã‚’å–å¾—-@
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To get an encoding from a string label, run these steps:
</p>

<ol>
	<li>
%~label ã‹ã‚‰é ­éƒ¨ã¨å°¾éƒ¨ã®`~ASCIIç©ºç™½$ã‚’é™¤å»ã™ã‚‹
â—
Remove any leading and trailing ASCII whitespace from label.
</li>
	<li>
~IFï¼»
%~label ãŒä¸‹ã®ä¸€è¦§ã®ã„ãšã‚Œã‹ã®`~label$ã«`~ASCIIå¤§å°ç„¡è¦–$ã§åˆè‡´ã™ã‚‹
ï¼½
â‡’
~RET åˆè‡´ã—ãŸ`~label$ã«å¯¾å¿œã™ã‚‹`~encoding$
â—
If label is an ASCII case-insensitive match for any of the labels listed in the table below, return the corresponding encoding, and failure otherwise.
</li>
	<li>
~RET `å¤±æ•—^i
â—
â†‘</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™æ¸ˆã¿ã®å†…å®¹ã¨äº’æ›ã«ã™ã‚‹å¿…è¦ã‹ã‚‰ã€ã“ã®ï¼»
`~label$ã‚’`~encoding$ã«å¯¾å¿œä»˜ã‘ã‚‹~algo
ï¼½ã¯ï¼Œ
<a href="https://www.unicode.org/reports/tr22/tr22-7.html#Charset_Alias_Matching">Unicode Technical Standard #22, 1.4 ç¯€</a>
ã«ã‚ˆã‚‹ã‚‚ã®ã‚ˆã‚ŠåŸºæœ¬çš„ã‹ã¤åˆ¶ç´„çš„ã§ã‚ã‚‹ã€‚
â—
This is a more basic and restrictive algorithm of mapping labels to encodings than section 1.4 of Unicode Technical Standard #22 prescribes, as that is necessary to be compatible with deployed content.
</p>

<table id="encoding-labels">
<thead><tr><th>`åå‰$â—Name
<th>`~label$â—Labels
</thead>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#the-encoding">~~æ¨™æº–ã®~encoding</a>
â—
The Encoding
<tr><td>`UTF-8$n
<td>`unicode-1-1-utf-8^lb
`utf-8^lb
`utf8^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-single-byte-encodings">æ—§æ¥ã®å˜byte~encoding</a>
â—
Legacy single-byte encodings
<tr><td>`IBM866$n
<td>`866^lb
`cp866^lb
`csibm866^lb
`ibm866^lb
<tr><td>`ISO-8859-2$n
<td>`csisolatin2^lb
`iso-8859-2^lb
`iso-ir-101^lb
`iso8859-2^lb
`iso88592^lb
`iso_8859-2^lb
`iso_8859-2:1987^lb
`l2^lb
`latin2^lb
<tr><td>`ISO-8859-3$n
<td>`csisolatin3^lb
`iso-8859-3^lb
`iso-ir-109^lb
`iso8859-3^lb
`iso88593^lb
`iso_8859-3^lb
`iso_8859-3:1988^lb
`l3^lb
`latin3^lb
<tr><td>`ISO-8859-4$n
<td>`csisolatin4^lb
`iso-8859-4^lb
`iso-ir-110^lb
`iso8859-4^lb
`iso88594^lb
`iso_8859-4^lb
`iso_8859-4:1988^lb
`l4^lb
`latin4^lb
<tr><td>`ISO-8859-5$n
<td>`csisolatincyrillic^lb
`cyrillic^lb
`iso-8859-5^lb
`iso-ir-144^lb
`iso8859-5^lb
`iso88595^lb
`iso_8859-5^lb
`iso_8859-5:1988^lb
<tr><td>`ISO-8859-6$n
<td>`arabic^lb
`asmo-708^lb
`csiso88596e^lb
`csiso88596i^lb
`csisolatinarabic^lb
`ecma-114^lb
`iso-8859-6^lb
`iso-8859-6-e^lb
`iso-8859-6-i^lb
`iso-ir-127^lb
`iso8859-6^lb
`iso88596^lb
`iso_8859-6^lb
`iso_8859-6:1987^lb
<tr><td>`ISO-8859-7$n
<td>`csisolatingreek^lb
`ecma-118^lb
`elot_928^lb
`greek^lb
`greek8^lb
`iso-8859-7^lb
`iso-ir-126^lb
`iso8859-7^lb
`iso88597^lb
`iso_8859-7^lb
`iso_8859-7:1987^lb
`sun_eu_greek^lb
<tr><td>`ISO-8859-8$n
<td>`csiso88598e^lb
`csisolatinhebrew^lb
`hebrew^lb
`iso-8859-8^lb
`iso-8859-8-e^lb
`iso-ir-138^lb
`iso8859-8^lb
`iso88598^lb
`iso_8859-8^lb
`iso_8859-8:1988^lb
`visual^lb
<tr><td>`ISO-8859-8-I$n
<td>`csiso88598i^lb
`iso-8859-8-i^lb
`logical^lb
<tr><td>`ISO-8859-10$n
<td>`csisolatin6^lb
`iso-8859-10^lb
`iso-ir-157^lb
`iso8859-10^lb
`iso885910^lb
`l6^lb
`latin6^lb
<tr><td>`ISO-8859-13$n
<td>`iso-8859-13^lb
`iso8859-13^lb
`iso885913^lb
<tr><td>`ISO-8859-14$n
<td>`iso-8859-14^lb
`iso8859-14^lb
`iso885914^lb
<tr><td>`ISO-8859-15$n
<td>`csisolatin9^lb
`iso-8859-15^lb
`iso8859-15^lb
`iso885915^lb
`iso_8859-15^lb
`l9^lb
<tr><td>`ISO-8859-16$n
<td>`iso-8859-16^lb
<tr><td>`KOI8-R$n
<td>`cskoi8r^lb
`koi^lb
`koi8^lb
`koi8-r^lb
`koi8_r^lb
<tr><td>`KOI8-U$n
<td>`koi8-ru^lb
`koi8-u^lb
<tr><td>`macintosh$n
<td>`csmacintosh^lb
`mac^lb
`macintosh^lb
`x-mac-roman^lb
<tr><td>`windows-874$n
<td>`dos-874^lb
`iso-8859-11^lb
`iso8859-11^lb
`iso885911^lb
`tis-620^lb
`windows-874^lb
<tr><td>`windows-1250$n
<td>`cp1250^lb
`windows-1250^lb
`x-cp1250^lb
<tr><td>`windows-1251$n
<td>`cp1251^lb
`windows-1251^lb
`x-cp1251^lb
<tr><td>`windows-1252$n
<td>`ansi_x3.4-1968^lb
`ascii^lb
`cp1252^lb
`cp819^lb
`csisolatin1^lb
`ibm819^lb
`iso-8859-1^lb
`iso-ir-100^lb
`iso8859-1^lb
`iso88591^lb
`iso_8859-1^lb
`iso_8859-1:1987^lb
`l1^lb
`latin1^lb
`us-ascii^lb
`windows-1252^lb
`x-cp1252^lb
<tr><td>`windows-1253$n
<td>`cp1253^lb
`windows-1253^lb
`x-cp1253^lb
<tr><td>`windows-1254$n
<td>`cp1254^lb
`csisolatin5^lb
`iso-8859-9^lb
`iso-ir-148^lb
`iso8859-9^lb
`iso88599^lb
`iso_8859-9^lb
`iso_8859-9:1989^lb
`l5^lb
`latin5^lb
`windows-1254^lb
`x-cp1254^lb
<tr><td>`windows-1255$n
<td>`cp1255^lb
`windows-1255^lb
`x-cp1255^lb
<tr><td>`windows-1256$n
<td>`cp1256^lb
`windows-1256^lb
`x-cp1256^lb
<tr><td>`windows-1257$n
<td>`cp1257^lb
`windows-1257^lb
`x-cp1257^lb
<tr><td>`windows-1258$n
<td>`cp1258^lb
`windows-1258^lb
`x-cp1258^lb
<tr><td>`x-mac-cyrillic$n
<td>`x-mac-cyrillic^lb
`x-mac-ukrainian^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-chinese-(simplified)-encodings">æ—§æ¥ã®è¤‡byte Chinese ï¼ˆç°¡ä½“å­—ï¼‰ ~encoding</a>
â—
Legacy multi-byte Chinese (simplified) encodings
<tr><td>`GBK$n
<td>`chinese^lb
`csgb2312^lb
`csiso58gb231280^lb
`gb2312^lb
`gb_2312^lb
`gb_2312-80^lb
`gbk^lb
`iso-ir-58^lb
`x-gbk^lb
<tr><td>`gb18030$n
<td>`gb18030^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-chinese-(traditional)-encodings">æ—§æ¥ã®è¤‡byte Chinese ï¼ˆç¹ä½“å­—ï¼‰~encoding</a>
â—
Legacy multi-byte Chinese (traditional) encodings
<tr><td>`Big5$n
<td>`big5^lb
`big5-hkscs^lb
`cn-big5^lb
`csbig5^lb
`x-x-big5^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-japanese-encodings">æ—§æ¥ã®è¤‡byte Japanese ~encoding</a>
â—
Legacy multi-byte Japanese encodings
<tr><td>`EUC-JP$n
<td>`cseucpkdfmtjapanese^lb
`euc-jp^lb
`x-euc-jp^lb
<tr><td>`ISO-2022-JP$n
<td>`csiso2022jp^lb
`iso-2022-jp^lb
<tr><td>`Shift_JIS$n
<td>`csshiftjis^lb
`ms932^lb
`ms_kanji^lb
`shift-jis^lb
`shift_jis^lb
`sjis^lb
`windows-31j^lb
`x-sjis^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-korean-encodings">æ—§æ¥ã®è¤‡byte Korean ~encoding</a>
â—
Legacy multi-byte Korean encodings
<tr><td>`EUC-KR$n
<td>`cseuckr^lb
`csksc56011987^lb
`euc-kr^lb
`iso-ir-149^lb
`korean^lb
`ks_c_5601-1987^lb
`ks_c_5601-1989^lb
`ksc5601^lb
`ksc_5601^lb
`windows-949^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-miscellaneous-encodings">æ—§æ¥ã®ãã®ä»–ã®~encoding</a>
â—
Legacy miscellaneous encodings
<tr><td>`replacement$n
<td>`csiso2022kr^lb
`hz-gb-2312^lb
`iso-2022-cn^lb
`iso-2022-cn-ext^lb
`iso-2022-kr^lb
`replacement^lb
<tr><td>`UTF-16BE$n
<td>`utf-16be^lb
<tr><td>`UTF-16LE$n
<td>`utf-16^lb
`utf-16le^lb
<tr><td>`x-user-defined$n
<td>`x-user-defined^lb
	</tbody>
</table>

<p class="note">æ³¨è¨˜ï¼š
ã™ã¹ã¦ã®`~encoding$ã¨ãã‚Œã‚‰ã®`~label$ã¯ã€è¦ç¯„çš„ã§ãªã„è³‡æº
`indexes.json$
ã‹ã‚‰ã‚‚å…¥æ‰‹ã§ãã‚‹ã€‚
â—
All encodings and their labels are also available as non-normative encodings.json resource.
</p>

		</section>
		<section id="output-encodings">

<h3 title="Output encodings">4.3 å‡ºåŠ›~encoding</h3>

<p>
`~encoding$ %~encoding ã‹ã‚‰
`å‡ºåŠ›~encodingã‚’å–å¾—-@
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To get an output encoding from an encoding encoding, run these steps:
</p>

<ol>
	<li>
~IFï¼»
%~encoding ~IN
{ `replacement$n, `UTF-16BE$n, `UTF-16LE$n }
ï¼½
â‡’
~RET `UTF-8$n
â—
If encoding is replacement, UTF-16BE, or UTF-16LE, return UTF-8.
</li>
	<li>
~RET %~encoding
â—
Return encoding.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
`å‡ºåŠ›~encodingã‚’å–å¾—-$ã™ã‚‹~algoã¯ã€ãã‚Œã‚’å¿…è¦ã¨ã™ã‚‹ï¼»
~URLã®æ§‹æ–‡è§£æ ï¼ ~HTML~formæå‡º
ï¼½ã«ã¦æœ‰ç”¨ã«ãªã‚‹ã€‚
â—
The get an output encoding algorithm is useful for URL parsing and HTML form submission, which both need exactly this.
</p>

		</section>
	</section>
	<section id="indexes">

<h2 title="Indexes">5. ç´¢å¼•</h2>

<p>
ã»ã¨ã‚“ã©ã®æ—§æ¥ã®`~encoding$ã§ã¯ã€
ã€~encodingã”ã¨ã«å›ºæœ‰ã®ã€‘
`ç´¢å¼•@
ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
`ç´¢å¼•$ã¨ã¯ã€ä¸€é€£ã®~entryã‹ã‚‰ãªã‚‹æœ‰é †åº~listã§ã‚ã‚Šã€å„~entryã¯ï¼»
~pointerã¨, ãã‚Œã«å¯¾å¿œã™ã‚‹~cp
ï¼½ã‹ã‚‰ãªã‚‹çµ„ã§ã‚ã‚‹ã€‚
`ç´¢å¼•$ã®ä¸­ã§ã¯ã€~pointerã¯ä¸€æ„ã§ã‚ã‚Šï¼Œ~cpã¯é‡è¤‡ã—å¾—ã‚‹ã€‚
â—
Most legacy encodings make use of an index. An index is an ordered list of entries, each entry consisting of a pointer and a corresponding code point. Within an index pointers are unique and code points can be duplicated.
</p>

<p class="note">æ³¨è¨˜ï¼š
åŠ¹ç‡çš„ãªå®Ÿè£…ã¯ã€`~encoding$ã”ã¨ã«ï¼Œãã®`~decoder$ã¨`~encoder$ã®ãã‚Œãã‚Œã«æœ€é©åŒ–ã•ã‚ŒãŸï¼Œ 2 ã¤ã®`ç´¢å¼•$ã‚’å‚™ãˆã‚‹ã“ã¨ã«ãªã‚‹ã§ã‚ã‚ã†ã€‚
â—
An efficient implementation likely has two indexes per encoding. One optimized for its decoder and one for its encoder.
</p>

<div class="p">

<p class="algo-head">
`ç´¢å¼•$
ã€ã®~dataã‚’ä¾›ã™ã‚‹ä¸‹è¨˜ã®è³‡æºã€‘
ã‹ã‚‰ï¼Œ~pointerã¨ãã‚Œã«å¯¾å¿œã™ã‚‹~cpã‚’è¦‹å‡ºã™ãŸã‚ã«ã¯ï¼š
</p>

<ol>
	<li>
ã¾ãšã€ %è¡Œ~list ã‚’ãã®è³‡æºã®å†…å®¹ã‚’ `000A^U ã§ä¸€é€£ã® â€œè¡Œâ€ ã«åˆ†å‰²ã—ãŸçµæœã¨ã™ã‚‹ã€‚
</li>
	<li>
%è¡Œ~list ã‹ã‚‰ï¼»
ç©ºè¡Œ ï¼ `0023^U ã§é–‹å§‹ã•ã‚Œã‚‹è¡Œ
ï¼½ã‚’ã™ã¹ã¦é™¤å»ã™ã‚‹ã€‚
</li>
	<li>
<p>
%è¡Œ~list ã®å„~è¡Œã«å¯¾ã—ï¼Œè¡Œã‚’ `0009^U ã§åˆ†å‰²ã—ãŸã¨ãã®ï¼š
</p>

<ul><li>æœ€åˆã®é …ãŒ~pointerï¼ˆ 10 é€²è¡¨è¨˜ï¼‰ã‚’ä¸ãˆã‚‹ã€‚
</li><li>æ¬¡ã®é …ãŒå¯¾å¿œã™ã‚‹~cpï¼ˆ 16 é€²è¡¨è¨˜ï¼‰ã‚’ä¸ãˆã‚‹ã€‚
</li><li>ä»–ã®é …ã¯é–¢ä¿‚ãªã„ã€‚
</li></ul>
	</li>
</ol>

â—
To find the pointers and their corresponding code points in an index, let lines be the result of splitting the resourceâ€™s contents on U+000A. Then remove each item in lines that is the empty string or starts with U+0023. Then the pointers and their corresponding code points are found by splitting each item in lines on U+0009. The first subitem is the pointer (as a decimal number) and the second is the corresponding code point (as a hexadecimal number). Other subitems are not relevant.
</div>

<p class="note">æ³¨è¨˜ï¼š
å„`ç´¢å¼•$ã®å†’é ­ã«ã¯ã€å¤‰æ›´ã®æœ‰ç„¡ã‚’è¨˜ã™ãŸã‚ï¼Œ
<i>Identifier</i> ã¨ <i>Date</i>
ã€è­˜åˆ¥å­ã¨æ—¥ä»˜ã€‘
ãŒè¨˜ã•ã‚Œã¦ã„ã‚‹ã€‚
<i>Identifier</i> ã®å¤‰åŒ–ã¯ã€`ç´¢å¼•$ã«å¤‰æ›´ãŒåŠ ãˆã‚‰ã‚ŒãŸã“ã¨ã‚’è¡¨ã™ã€‚
â—
To signify changes an index includes an Identifier and a Date. If an Identifier has changed, so has the index.
</p>

<p>
%ç´¢å¼• ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™
`ç´¢å¼•~cp@
ã¨ã¯ã€
%ç´¢å¼• å†…ã« %~pointer ãŒï¼»
åœ¨ã‚‹ãªã‚‰ã°ï¼Œãã‚Œã«å¯¾å¿œã™ã‚‹~cp ï¼
ç„¡ã‘ã‚Œã° ~NULL
ï¼½ã§ã‚ã‚‹ã€‚
â—
The index code point for pointer in index is the code point corresponding to pointer in index, or null if pointer is not in index.
</p>

<p>
%ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™
`ç´¢å¼•~pointer@
ã¨ã¯ã€
%ç´¢å¼• å†…ã« %~cp ã«å¯¾å¿œã™ã‚‹~pointerãŒï¼»
åœ¨ã‚‹ãªã‚‰ã°ï¼Œãã‚Œã‚‰ã®ã†ã¡ã® <em>æœ€åˆã®</em> ~pointer ï¼
ç„¡ã‘ã‚Œã° ~NULL
ï¼½ã§ã‚ã‚‹ã€‚
â—
The index pointer for code point in index is the first pointer corresponding to code point in index, or null if code point is not in index.
</p>

<div class="note" id="visualization">
<p>æ³¨è¨˜ï¼š
å„ ç´¢å¼•ã«ã¯ï¼Œè¦ç¯„çš„ã§ãªã„è¦–è¦šåŒ–ãŒã‚ã‚Šã€`ç´¢å¼•~jis0208$ã«ã¯ï¼Œ `Shift_JIS$n è¦–è¦šåŒ–ã‚‚åˆ¥ã«ã‚ã‚‹ã€‚
åŠ ãˆã¦ï¼ŒåŸºæœ¬å¤šè¨€èªé¢ï¼ˆ
BMP ï¼ Basic Multilingual Plane ï¼ `0000^U ã€œ `FFFF^U
ï¼‰ã«ãŠã‘ã‚‹è¢«è¦†åŸŸã®è¦–è¦šåŒ–ã‚‚ã‚ã‚‹ã€‚
ãŸã ã—ã€ï¼»
`ç´¢å¼•~gb18030ç¯„å›²é›†$ ï¼ `ç´¢å¼•~ISO-2022-JP~katakana$
ï¼½ã«ã¯ï¼Œã“ã‚Œã‚‰ã®è¦–è¦šåŒ–ã¯ãªã„ã€‚
â—
There is a non-normative visualization for each index other than index gb18030 ranges and index ISO-2022-JP katakana. index jis0208 also has an alternative Shift_JIS visualization. Additionally, there is visualization of the Basic Multilingual Plane coverage of each index other than index gb18030 ranges and index ISO-2022-JP katakana.
</p>

<table>
<caption>
è¦–è¦šåŒ–ã«ãŠã‘ã‚‹å‡¡ä¾‹
â—
The legend for the visualizations is:
</caption>

<thead><tr><th>è¡¨ç¤º
<th>èª¬æ˜
</thead>

<tbody class="_vis-visualizationlegend">
<tr><td><div class="_vis-unmapped"></div><td>
å¯¾å¿œã™ã‚‹~cpãªã—ã€‚
â—
Unmapped

<tr><td><div class="_vis-mid"></div><td>
~UTF-8ã§ 2 ~byteã€‚
â—
Two bytes in UTF-8

<tr><td><div class="_vis-mid _vis-contiguous"></div><td>
~UTF-8ã§ 2 ~byte, ã‹ã¤
~cpã¯ã€å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Two bytes in UTF-8, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-upper"></div><td>
~UTF-8ã§ 3 ~byteï¼ˆç§ç”¨é ˜åŸŸã§ãªã„ï¼‰
â—
Three bytes in UTF-8 (non-PUA)

<tr><td><div class="_vis-upper _vis-contiguous"></div><td>
~UTF-8ã§ 3 ~byteï¼ˆç§ç”¨é ˜åŸŸã§ãªã„ï¼‰, ã‹ã¤
~cpã¯ã€å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Three bytes in UTF-8 (non-PUA), code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-pua"></div><td>
ç§ç”¨é ˜åŸŸ
â—
Private Use

<tr><td><div class="_vis-pua _vis-contiguous"></div><td>
ç§ç”¨é ˜åŸŸ, ã‹ã¤
~cpã¯ã€å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Private Use, code point follows immediately the code point of previous
pointer

<tr><td><div class="_vis-astral"></div><td>
~UTF-8ã§ 4 ~byte
â—
Four bytes in UTF-8

<tr><td><div class="_vis-astral _vis-contiguous"></div><td>
~UTF-8ã§ 4 ~byte, ã‹ã¤
~cpã¯ã€å‰ã®~pointerã®~cpã®ç›´å¾Œã«ç¶šãã€‚
â—
Four bytes in UTF-8, code point follows immediately the code point
of previous pointer

<tr><td><div class="_vis-duplicate"></div><td>
å…ˆã«ç¾ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨é‡è¤‡ã™ã‚‹~cpã«å¯¾å¿œã™ã‚‹ã€‚
â—
Duplicate code point already mapped at an earlier index

<tr><td><div class="_vis-compatibility"></div><td>
~CJKäº’æ›æ¼¢å­—ï¼ˆ CJK Compatibility Ideograph ï¼‰
â—
CJK Compatibility Ideograph

<tr><td><div class="_vis-ext"></div><td>
~CJKçµ±åˆæ¼¢å­—æ‹¡å¼µ A
â—
CJK Unified Ideographs Extension A

</tbody>
</table>

</div>


<p>
ä»¥ä¸‹ã¯ã€ã“ã®ä»•æ§˜ã§å®šç¾©ã•ã‚Œã‚‹`ç´¢å¼•$ã®ã†ã¡ï¼Œ`å˜byteç´¢å¼•$ã§ãªã„ã‚‚ã®ã§ã‚ã‚Šã€ãã‚Œãã‚Œã«è‡ªå‰ã®~tableãŒã‚ã‚‹ï¼š
ã€è¦–è¦šåŒ–ï¼è¢«è¦†åŸŸã®~tableã¯å·¨å¤§ãªã“ã¨ã«æ³¨æ„ã€‘
â—
These are the indexes defined by this specification, excluding index single-byte, which have their own table:
</p>

<table id="_index_list">
<thead><tr><th rowspan="2">`åå‰$
<th>`ç´¢å¼•$
<th>è¦–è¦šåŒ–
<th>åŸºæœ¬å¤šè¨€èªé¢ï¼ˆ BMP ï¼‰ã®è¢«è¦†åŸŸ
<tr><th colspan="3">å‚™è€ƒ
</thead>

<tbody><tr><td rowspan="2">`ç´¢å¼•~Big5@
<td>`Big5$idx
<tr><td colspan="3">
ã“ã‚Œã¯ã€é¦™æ¸¯å¢—è£œå­—ç¬¦é›†ï¼ˆ Hong Kong Supplementary Character Set ï¼‰, ãŠã‚ˆã³ä»–ã®å…±é€šã®æ‹¡å¼µã¨ä¸€å¼ã§ã€~Big5æ¨™æº–ã«åˆè‡´ã™ã‚‹ã€‚
â—
This matches the Big5 standard in combination with the Hong Kong Supplementary Character Set and other common extensions.

<tbody><tr><td rowspan="2">`ç´¢å¼•~EUC-KR@
<td>`EUC-KR$idx
<tr><td colspan="3">
ã“ã‚Œã¯ã€ KS X 1001 æ¨™æº–ã¨ çµ±åˆ~Hangul~codeï¼ˆ Unified Hangul Code ï¼‰ã«åˆè‡´ã™ã‚‹ã€‚
Windows Codepage 949 ã¨ã—ã¦ã‚‚å…±é€šçš„ã«çŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
ã“ã‚Œå…¨ä½“ã§ã€~Unicodeã®~HanguléŸ³ç¯€æ–‡å­—ï¼ˆ Hangul Syllables ï¼‰~blockã‚’è¦†ã†ã€‚
~Hangul~blockã®ã†ã¡ï¼Œè¦–è¦šåŒ–ã«ãŠã‘ã‚‹å·¦ä¸Šéš…ãŒ~pointer 9026 ã«ã‚ã‚‹ã‚‚ã®
ã€ï¼Ÿã€‘
ã¯ã€~Unicodeé †ã«ä¸¦ã¶ã€‚
Taken separately ã€ï¼Ÿã€‘,
ã“ã®ç´¢å¼•ã«ãŠã‘ã‚‹æ®‹ã‚Šã®~HanguléŸ³ç¯€æ–‡å­—ã‚‚ã€~Unicodeé †ã«ä¸¦ã¶ã€‚
â—
This matches the KS X 1001 standard and the Unified Hangul Code, more commonly known together as Windows Codepage 949. It covers the Hangul Syllables block of Unicode in its entirety. The Hangul block whose top left corner in the visualization is at pointer 9026 is in the Unicode order. Taken separately, the rest of the Hangul syllables in this index are in the Unicode order, too. 

<tbody><tr><td rowspan="2">`ç´¢å¼•~gb18030@
<td>`gb18030$idx
<tr><td colspan="3">
ã“ã‚Œã¯ã€å„~cpãŒ 2 ~byteã«~encodeã•ã‚Œã‚‹ GB18030-2005 æ¨™æº–ã«åˆè‡´ã™ã‚‹
â€” ãŸã ã—ï¼Œé…å‚™æ¸ˆã¿ã®å†…å®¹ã¨äº’æ›ã«ã™ã‚‹å¿…è¦ã‹ã‚‰ã€ `A3^X `A0^X ã¯ `3000^U ã«å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
ã“ã®ç´¢å¼•~å…¨ä½“ã§ã€~Unicodeã®~CJKçµ±åˆæ¼¢å­—ï¼ˆ CJK Unified Ideographs ï¼‰~blockã‚’è¦†ã†ã€‚
ãã®~blockå†…ã®~entryã®ã†ã¡ï¼Œè¦–è¦šåŒ–ã«ãŠã‘ã‚‹ï¼ˆæœ€åˆã®ï¼‰ `3000^U ã‚ˆã‚Šä¸Šã¾ãŸã¯å·¦ã«ã‚ã‚‹ã‚‚ã®ã¯ã€~Unicodeé †ã«ä¸¦ã¶ã€‚
â—
This matches the GB18030-2005 standard for code points encoded as two bytes, except for 0xA3 0xA0 which maps to U+3000 to be compatible with deployed content. This index covers the CJK Unified Ideographs block of Unicode in its entirety. Entries from that block that are above or to the left of (the first) U+3000 in the visualization are in the Unicode order.

<tbody><tr><td rowspan="2">`ç´¢å¼•~gb18030ç¯„å›²é›†@
<td><a href="~ENCSPEC/index-gb18030-ranges.txt">index-gb18030-ranges.txt</a>
<td><td>
<tr><td colspan="3">
ã“ã®`ç´¢å¼•$ã¯ã€ã™ã¹ã¦ã®~cpã‚’æŒ™ã’ã¦ã„ãã¨é …ç›®æ•°ãŒ 100 ä¸‡ã‚’è¶…ãˆã¦ã—ã¾ã†ç‚¹ã§ï¼Œä»–ã®ã™ã¹ã¦ã¨ç•°ãªã‚‹ï¼ˆ 207 é¢ã®ç¯„å›²ã¨è‡ªæ˜ãªç¯„å›²æ¤œæŸ»ã«ã‚ˆã‚Šï¼Œãã‚Œã„ã«è¡¨ç¾ã—å¾—ã‚‹ãŒï¼‰ã€‚
ã—ãŸãŒã£ã¦ã€ 4 ~byte ã«~encodeã•ã‚Œã‚‹~cpã«ã¤ã„ã¦ã®ã¿ï¼Œè¦‹ã‹ã‘ä¸Š GB18030-2005 æ¨™æº–ã«åˆè‡´ã™ã‚‹ã€‚
ä¸‹ã®ï¼»
`ç´¢å¼•~gb18030ç¯„å›²é›†~cp$ ï¼
`ç´¢å¼•~gb18030ç¯„å›²é›†~pointer$
ï¼½ã‚‚è¦‹ã‚ˆã€‚
â—
This index works different from all others. Listing all code points would result in over a million items whereas they can be represented neatly in 207 ranges combined with trivial limit checks. It therefore only superficially matches the GB18030-2005 standard for code points encoded as four bytes. See also index gb18030 ranges code point and index gb18030 ranges pointer below.

<tbody><tr><td rowspan="3">`ç´¢å¼•~jis0208@
<td>`jis0208$idx
<tr><td><td><a href="~ENCSPEC/shift_jis.html">ç´¢å¼•~Shift_JISè¦–è¦šåŒ–</a><td>
<tr><td colspan="3">
IBM ã¨ NEC ã«ã‚ˆã‚‹ã‹ã¤ã¦ã®~proprietaryæ‹¡å¼µã‚‚å«ã¾ã‚Œã¦ã„ã‚‹ï¼Œ JIS X 0208 æ¨™æº–ã€‚
â—
This is the JIS X 0208 standard including formerly proprietary extensions from IBM and NEC.

<tbody><tr><td rowspan="2">`ç´¢å¼•~jis0212@
<td>`jis0212$idx
<tr><td colspan="3">
JIS X 0212 æ¨™æº–ã€‚
ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã®ã¯ã€`~EUC-JP~decoder$ã«é™ã‚‰ã‚Œã‚‹ï¼ˆ~encoderã‹ã‚‰ã¯åˆ©ç”¨ã•ã‚Œãªã„ï¼‰
â€” åºƒã~supportã•ã‚Œã¦ã„ãªã„ã®ã§ã€‚
â—
This is the JIS X 0212 standard. It is only used by the EUC-JP decoder due to lack of widespread support elsewhere.

<tbody><tr><td rowspan="2">`ç´¢å¼•~ISO-2022-JP~katakana@
<td><a href="~ENCSPEC/index-iso-2022-jp-katakana.txt">index-gb18030-ranges.txt</a>
<td><td>
<tr><td colspan="3">
ã“ã‚Œã¯ã€
Unicode Normalization Form KC
ã«å¾“ã£ã¦ï¼ŒåŠè§’~katakanaã‚’å…¨è§’~katakanaã«å¯¾å¿œä»˜ã‘ã‚‹ã€‚
ãŸã ã—ã€ï¼»
`FF9E^U ï¼ `FF9F^U
ï¼½ã¯ï¼»
`309B^U ï¼ `309C^U
ï¼½ã«å¯¾å¿œä»˜ã‘ã‚‹
â€” ï¼»
`3099^U ï¼ `309A^U
ï¼½ã§ã¯ãªã
ã€ã“ã‚Œã‚‰ã¯ã„ãšã‚Œã‚‚ã€æ¿ç‚¹ï¼åŠæ¿ç‚¹ã€‘
ã€‚
ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã®ã¯ã€`~ISO-2022-JP~encoder$ã«é™ã‚‰ã‚Œã‚‹ã€‚
`UNICODE$r
â—
This maps halfwidth to fullwidth katakana as per Unicode Normalization Form KC, except that U+FF9E and U+FF9F map to U+309B and U+309C rather than U+3099 and U+309A. It is only used by the ISO-2022-JP encoder. [UNICODE]

</tbody></table>


<p class="algo-head">
%~pointer ãŒæŒ‡ã™
`ç´¢å¼•~gb18030ç¯„å›²é›†~cp@
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~cpã§ã‚ã‚‹ï¼š
â—
The index gb18030 ranges code point for pointer is the return value of these steps:
</p>

<ol>
	<li>
~IFï¼»
39419 ~LT %~pointer ~LT 189000
ï¼½~ORï¼»
1237575 ~LT %~pointer
ï¼½
â‡’
~RET ~NULL
â—
If pointer is greater than 39419 and less than 189000, or pointer is greater than 1237575, return null.
</li>
	<li>
~IFï¼»
%~pointer ~EQ 7457
ï¼½
â‡’
~RET ~cp `E7C7^U
â—
If pointer is 7457, return code point U+E7C7. 
</li>
	<li>
%~offset ~LET `ç´¢å¼•~gb18030ç¯„å›²é›†$ ã®ä¸­ã§ %~pointer ã‚’è¶…ãˆãªã„æœ€å¾Œã®~pointer â—
Let offset be the last pointer in index gb18030 ranges that is equal to or less than pointer and let code point offset be its corresponding code point.
</li>
	<li>
%~cp~offset ~LET %~offset ãŒæŒ‡ã—ã¦ã„ã‚‹~cp
â—
â†‘</li>
	<li>
~RET å€¤ãŒï¼»
%~cp~offset ~PLUS %~pointer ~MINUS %~offset
ï¼½ãªã‚‹~cp
â—
Return a code point whose value is code point offset + pointer âˆ’ offset.
</li>
</ol>

<p class="algo-head">
%~cp ã‚’æŒ‡ã™
`ç´¢å¼•~gb18030ç¯„å›²é›†~pointer@
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index gb18030 ranges pointer for code point is the return value of these steps:
</p>

<ol>
	<li>
~IFï¼»
%~cp ~EQ `E7C7^U
ï¼½
â‡’
~RET ~pointer 7457
â—
If code point is U+E7C7, return pointer 7457.
</li>

	<li>
%~offset ~LET `ç´¢å¼•~gb18030ç¯„å›²é›†$ ã®ä¸­ã§ %~cp ã‚’è¶…ãˆãªã„æœ€å¾Œã®~cp
â—
Let offset be the last code point in index gb18030 ranges that is equal to or less than code point and let pointer offset be its corresponding pointer.
</li>
	<li>
%~pointer~offset ~LET %~offset ã«å¯¾å¿œã™ã‚‹~pointer
â—
â†‘</li>
	<li>
~RET å€¤ãŒï¼»
%~pointer~offset ~PLUS %~cp ~MINUS %~offset
ï¼½ãªã‚‹~pointer
â—
Return a pointer whose value is pointer offset + code point âˆ’ offset.
</li>
</ol>

<p class="algo-head">
%~cp ã‚’æŒ‡ã™
`ç´¢å¼•~Shift_JIS~pointer@
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index Shift_JIS pointer for code point is the return value of these steps:
</p>

<ol>
	<li>
<p>
%ç´¢å¼• ~LET `ç´¢å¼•~jis0208$ ã‹ã‚‰ï¼Œï¼»
~pointerãŒç¯„å›² { 8272 ã€œ 8835 } ã«å…¥ã‚‹~entry
ï¼½ã™ã¹ã¦ã‚’é™¤å¤–ã—ãŸç´¢å¼•
â—
Let index be index jis0208 excluding all entries whose pointer is in the range 8272 to 8835, inclusive.
</p>

<p class="note">
`ç´¢å¼•~jis0208$ã¯ã€é‡è¤‡ã™ã‚‹~cpã‚’åŒ…å«ã™ã‚‹ã®ã§ã€ã“ã‚Œã‚‰ã®~entryã®é™¤å¤–ã«ã‚ˆã‚Šï¼Œå¾Œç¶šã®~cpãŒåˆ©ç”¨ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
The index jis0208 contains duplicate code points so the exclusion of these entries causes later code points to be used.
</p>
	</li>
	<li>
~RET %ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Return the index pointer for code point in index.
</li>
</ol>

<p class="algo-head">
%~cp ã‚’æŒ‡ã™
`ç´¢å¼•~Big5~pointer@
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index Big5 pointer for code point is the return value of these steps:
</p>


<ol>
	<li>
<p>
%ç´¢å¼• ~LET `ç´¢å¼•~Big5$ã‹ã‚‰ï¼»
~pointerãŒ ( (`A1^X ~MINUS `81^X) ~MUL 157 ) ã‚ˆã‚Šå°ã•ã„~entry
ï¼½ã™ã¹ã¦ã‚’é™¤å¤–ã—ãŸç´¢å¼•
â—
Let index be index Big5 excluding all entries whose pointer is less than (0xA1 - 0x81) Ã— 157. 
</p>

<p class="note">æ³¨è¨˜ï¼š
é¦™æ¸¯å¢—è£œå­—ç¬¦é›†ï¼ˆ Hong Kong Supplementary Character Set ï¼‰æ‹¡å¼µã‚’~literalã¨ã—ã¦è¿”ã•ãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚
â—
Avoid returning Hong Kong Supplementary Character Set extensions literally.
</p>
	</li>
	<li>
<p>
~IFï¼»
%~cp ~IN 
{ `2550^U, `255E^U, `2561^U, `256A^U, `5341^U, `5345^U }
ï¼½
â‡’
~RET
%ç´¢å¼• ã®ä¸­ã§ %~cp ã«å¯¾å¿œã™ã‚‹ <em>æœ€å¾Œã®</em> ~pointer
â—
If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345, return the last pointer corresponding to code point in index.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä»–ã«ã‚‚é‡è¤‡ã—ã¦ã„ã‚‹~cpã¯ã‚ã‚‹ãŒã€ãã‚Œã‚‰ã«å¯¾ã—ã¦ã¯ï¼Œ<em>æœ€åˆã®</em> ~pointerãŒåˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
There are other duplicate code points, but for those the first pointer is to be used.
</p>
	</li>
	<li>
~RET
%ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Return the index pointer for code point in index.
</li>
</ol>



<hr>


<p class="note">æ³¨è¨˜ï¼š
ã™ã¹ã¦ã®`ç´¢å¼•$ã¯è¦ç¯„çš„ã§ãªã„è³‡æº
`indexes.json$
ã‹ã‚‰ã‚‚å…¥æ‰‹ã§ãã‚‹ï¼ˆ `ç´¢å¼•~gb18030ç¯„å›²é›†$ ã®å½¢å¼ã¯ã€ç¯„å›²ã‚’è¡¨ç¾ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ï¼Œè‹¥å¹²~ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ï¼‰ã€‚
â—
All indexes are also available as a non-normative indexes.json resource. (Index gb18030 ranges has a slightly different format here, to be able to represent ranges.)
</p>

	</section>
	<section id="specification-hooks">

<h2 title="Specification hooks">6. ä»–ã®ä»•æ§˜ã®ãŸã‚ã®~hook</h2>

<div class="note">
<p>æ³¨è¨˜ï¼š
æ¬¡ã«æŒ™ã’ã‚‹å„ç¨®~algoã¯ã€ä»–ã®ä»•æ§˜ã‹ã‚‰ã®~~åˆ©ç”¨ãŒæ„å›³ã•ã‚Œã¦ã„ã‚‹ï¼š
</p>

<ul><li>`~decode$
</li><li>`~UTF-8~decode$
</li><li>`~BOMã¯ãã®ã¾ã¾ã«~UTF-8~decode$
</li><li>`~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8~decode$
</li><li>`~encode$
</li><li>`~UTF-8~encode$
</li></ul>

<p>
æ–°ãŸãªå½¢å¼ã«ã¯ã€`~UTF-8~decode$ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
æœ€åˆã«`~label$ã‚’`~encoding$ã«è»¢æ›ã™ã‚‹ã¨ãã¯ã€`~encodingã‚’å–å¾—-$ã™ã‚‹~algoã‚’åˆ©ç”¨ã§ãã‚‹ã€‚
</p>
â—
The algorithms decode, UTF-8 decode, UTF-8 decode without BOM, UTF-8 decode without BOM or fail, encode, and UTF-8 encode are intended for usage by other specifications. UTF-8 decode is to be used by new formats. The get an encoding algorithm can be used first to turn a label into an encoding.
</div>

<p class="algo-head">
~fallback~encoding %~encoding ã‚’åˆ©ç”¨ã—ã¦ï¼Œ~byte~stream %~stream ã‚’
`~decode@
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To decode a byte stream stream using fallback encoding encoding, run these steps:
</p>

<ol>
	<li>
%buffer ~LET ~byteåˆ— []
â—
Let buffer be an empty byte sequence.
</li>
	<li>
%~BOMseen~flag ~LET ~OFF
â—
Let BOM seen flag be unset.
</li>
	<li>
æ¬¡ã‚’ 3 å› ç¹°è¿”ã™
â‡’
%~stream ã‹ã‚‰`èª­å–ã£ãŸçµæœ$ã‚’ %buffer ã«ä»˜åŠ ã™ã‚‹
â€” ãŸã ã—ï¼Œ`~EoS$ ãŒè¿”ã•ã‚ŒãŸã¨ãã¯ã€ä»˜åŠ ã›ãšã«ç¹°è¿”ã—ã‚’çµ‚ãˆã‚‹
â—
Read bytes from stream into buffer until either buffer contains three bytes or read returns end-of-stream.
</li>
	<li>
<p>
~IFï¼»
æ¬¡ã®è¡¨ã®ä¸­ã§ï¼Œ 1 åˆ—ç›®ã«ç¤ºã•ã‚ŒãŸ~byteåˆ—ãŒ %buffer ã®å…ˆé ­ã®~byteåˆ—ã«åˆè‡´ã™ã‚‹è¡ŒãŒã‚ã‚‹
ï¼½
â‡’
%~encoding ~SET ãã®è¡Œã® 2 åˆ—ç›®ã«ä¸ãˆã‚‰ã‚Œã‚‹ `~encoding$ ~BR
%~BOMseen~flag ~LET ~ON
â—
For each of the rows in the table below, starting with the first one and going down, if the first bytes of buffer match all the bytes given in the first column, then set encoding to the encoding given in the cell in the second column of that row and set BOM seen flag.
</p>


<table>

<thead><tr><th>~BOMâ—Byte order mark
<th>~encodingâ—Encoding
</thead>

<tbody><tr><td>`EF^X `BB^X `BF^X
<td>`UTF-8$n

<tr><td>`FE^X `FF^X
<td>`UTF-16BE$n

<tr><td>`FF^X `FE^X
<td>`UTF-16LE$n

</tbody></table>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™æ¸ˆã¿ã®å†…å®¹ã¨äº’æ›æ€§ã‚’ã¨ã‚‹ãŸã‚ã€~BOMï¼ˆ byte order mark ï¼‰ã¯ä»–ã‚ˆã‚Š~~å„ªå…ˆã•ã‚Œã‚‹ã€‚
HTTP ãŒåˆ©ç”¨ã•ã‚Œã‚‹æ–‡è„ˆ~ä¸‹ã§ã¯ã€ã“ã‚Œã¯ï¼Œ
`<code class="header">Content-Type</code>`
~headerã®æ„å‘³è«–ã«å¯¾ã™ã‚‹é•åã§ã‚ã‚‹ã€‚
â—
For compatibility with deployed content, the byte order mark (also known as BOM) is more authoritative than anything else. In a context where HTTP is used this is in violation of the semantics of the `Content-Type` header.
</p>
	</li>
	<li>
~IFï¼»
%~BOMseen~flag ~EQ ~OFF
ï¼½
â‡’
%buffer ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
If BOM seen flag is unset, prepend buffer to stream.
</li>
	<li>
~ELIF ï¼»
%~encoding ~NEQ `UTF-8$n
ï¼½~ANDï¼»
%buffer ã®é•·ã• ~EQ 3
ï¼½
â‡’
%buffer ã®æœ€å¾Œã®~byteã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
Otherwise, if BOM seen flag is set, encoding is not UTF-8, and buffer contains three bytes, prepend the last byte of buffer to stream.
</li>
	<li>
%å‡ºåŠ› ~LET ~cp`~stream$
â—
Let output be a code point stream.
</li>
	<li>
( %~stream, %å‡ºåŠ› )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
%~encoding ã®`~decoder$ã‚’`èµ°ã‚‰ã™$
â—
Run encodingâ€™s decoder with stream and output.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>

<p class="algo-head">
~byte~stream %~stream ã‚’
`~UTF-8~decode@
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To UTF-8 decode a byte stream stream, run these steps:
</p>

<ol>
	<li>
%buffer ~LET ~byteåˆ— []
â—
Let buffer be an empty byte sequence.
</li>
	<li>
æ¬¡ã‚’ 3 å› ç¹°è¿”ã™
â‡’
%~stream ã‹ã‚‰`èª­å–ã£ãŸçµæœ$ã‚’ %buffer ã«ä»˜åŠ ã™ã‚‹
ã€ â€” ãŸã ã—ï¼Œ`~EoS$ ãŒè¿”ã•ã‚ŒãŸã¨ãã¯ã€ä»˜åŠ ã›ãšã«ç¹°è¿”ã—ã‚’çµ‚ãˆã‚‹ ã€‘
â—
Read three bytes from stream into buffer.
</li>
	<li>
~IFï¼»
%buffer ~NEQ ~byteåˆ— [ `EF^X, `BB^X, `BF^X ]
ï¼½
â‡’
%buffer ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
If buffer does not match 0xEF 0xBB 0xBF, prepend buffer to stream.
</li>
	<li>
%å‡ºåŠ› ~LET ~cp`~stream$
â—
Let output be a code point stream.
</li>
	<li>
( %~stream, %å‡ºåŠ› )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
`UTF-8$n ã®`~decoder$ã‚’`èµ°ã‚‰ã™$
â—
Run UTF-8â€™s decoder with stream and output.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>

<p class="algo-head">
~byte~stream %~stream ã‚’
`~BOMã¯ãã®ã¾ã¾ã«~UTF-8~decode@
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To UTF-8 decode without BOM a byte stream stream, run these steps:
</p>

<ol>
	<li>
%å‡ºåŠ› ~LET ~cp`~stream$
â—
Let output be a code point stream.
</li>
	<li>
( %~stream, %å‡ºåŠ› )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
`UTF-8$n ã®`~decoder$ã‚’`èµ°ã‚‰ã™$
â—
Run UTF-8â€™s decoder with stream and output.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>


<p class="algo-head">
~byte~stream %~stream ã‚’
`~BOMã‚‚å¤±æ•—-ã‚‚ãã®ã¾ã¾ã«~UTF-8~decode@
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To UTF-8 decode without BOM or fail a byte stream stream, run these steps:
</p>

<ol>
	<li>
%å‡ºåŠ› ~LET ~cp`~stream$
â—
Let output be a code point stream.
</li>
	<li>
( %~stream, %å‡ºåŠ›, `fatal^l )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
`UTF-8$n ã®`~decoder$ã‚’`èµ°ã‚‰ã™$
â—
Let potentialError be the result of running UTF-8â€™s decoder with stream, output, and "fatal".
</li>
	<li>
~IFï¼»
å‰~æ®µã®çµæœ ~EQ `~error$
ï¼½
â‡’
~RET `å¤±æ•—^i
â—
If potentialError is error, return failure.
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>


<p class="algo-head">
~encoding %~encoding ã‚’åˆ©ç”¨ã—ã¦ ~cp~stream %~stream ã‚’
`~encode@
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To encode a code point stream stream using encoding encoding, run these steps:
</p>

<ol>
	<li>
~Assertï¼š
%~encoding ~NIN 
{ `replacement$n, `UTF-16BE$n, `UTF-16LE$n }
â—
Assert: encoding is not replacement, UTF-16BE or UTF-16LE.
</li>
	<li>
%å‡ºåŠ› ~LET ~byte`~stream$
â—
Let output be a byte stream.
</li>
	<li>
( %~stream, %å‡ºåŠ›, `html^l )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
 %~encoding ã®`~encoder$ã‚’`èµ°ã‚‰ã™$
â—
Run encodingâ€™s encoder with stream, output, and "html".
</li>
	<li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>


<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ä¸»ã«ã€~URLã¨~HTML~formç”¨ã®æ—§æ¥ã®~hookã§ã‚ã‚‹ã€‚
`~UTF-8~encode$ã‚’è¢«ã›ãŸæ–¹ãŒã€æ±ºã—ã¦`~error$ã‚’èª˜ç™ºã•ã›ãªã„ã®ã§å®‰å…¨ã§ã‚ã‚‹ã€‚
`URL$r
`HTML$r
â—
This is mostly a legacy hook for URLs and HTML forms. Layering UTF-8 encode on top is safe as it never triggers errors. [URL] [HTML]
</p>

<div class="p">
<p class="algo-head">
~cp~stream %~stream ã‚’
`~UTF-8~encode@
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
</p>

<ol>
	<li>
~RET `UTF-8$n ã‚’~encodingã«åˆ©ç”¨ã—ã¦ %~stream ã‚’`~encode$ã—ãŸçµæœ
</li>
</ol>

â—
To UTF-8 encode a code point stream stream, return the result of encoding stream using encoding UTF-8.
</div>

	</section>
	<section id="api">

<h2 title="API">7. ~API</h2>

<p>
ã“ã®ç¯€ã§ã¯ Web IDL ã®å„ç¨®ç”¨èªãŒç”¨ã„ã‚‰ã‚Œã‚‹ã€‚
é~browser~UAã«å¯¾ã—ã¦ã¯ã€ã“ã®~APIã®~supportã¯è¦æ±‚ã•ã‚Œãªã„ã€‚
`WEBIDL$r
â—
This section uses terminology from Web IDL. Non-browser user agents are not required to support this API.
â—
[WEBIDL]
</p>

<div class="example">
<p>
æ¬¡ã®ä¾‹ã¯ã€ `TextEncoder$I ~objã‚’åˆ©ç”¨ã—ã¦ï¼Œæ–‡å­—åˆ—ã®é…åˆ—ã‚’ `ArrayBuffer$I ã«~encodeã™ã‚‹ã€‚
çµæœã¯æ¬¡ã‚’å†…å®¹ã¨ã™ã‚‹ `Uint8Array$I ã«ãªã‚‹ï¼š
<span class="block">
å…ˆé ­ãŒï¼ˆ `Uint32Array$I ã¨ã—ã¦ã®ï¼‰æ–‡å­—åˆ—ã®å€‹æ•°ï¼Œãã®å¾Œã¯ï¼š
<span class="block">
æœ€åˆã®æ–‡å­—åˆ—ã®ï¼ˆ `Uint32Array$I ã¨ã—ã¦ã®ï¼‰é•·ã•,
`UTF-8$n ã«~encodeã•ã‚ŒãŸãã®æ–‡å­—åˆ—~dataï¼Œ<br>
2 ç•ªç›®ã®æ–‡å­—åˆ—ã®ï¼ˆ `Uint32Array$I ã¨ã—ã¦ã®ï¼‰é•·ã•,
ãã®æ–‡å­—åˆ—~dataï¼Œ<br>
â€¦
</span>
ç­‰ã€…ã¨ç¶šãã€‚
</span>
â—
The following example uses the TextEncoder object to encode an array of strings into an ArrayBuffer. The result is a Uint8Array containing the number of strings (as a Uint32Array), followed by the length of the first string (as a Uint32Array), the UTF-8 encoded string data, the length of the second string (as a Uint32Array), the string data, and so on.
</p>

<pre>
function encodeArrayOfStrings(%strings) {
  var %encoder, %encoded, %len, %bytes, %view, %offset;

  %encoder = new TextEncoder();
  %encoded = [];

  %len = Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %strings.length; %i++) {
    %len += Uint32Array.BYTES_PER_ELEMENT;
    %encoded[%i] = %encoder.encode(%strings[%i]);
    %len += %encoded[%i].byteLength;
  }

  %bytes = new Uint8Array(%len);
  %view = new DataView(%bytes.buffer);
  %offset = 0;

  %view.setUint32(%offset, %strings.length);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %encoded.length; %i += 1) {
    %len = %encoded[%i].byteLength;
    %view.setUint32(%offset, %len);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %bytes.set(%encoded[%i], %offset);
    %offset += %len;
  }
  return %bytes.buffer;
}
</pre>

<p>
æ¬¡ã®ä¾‹ã¯ã€ï¼»ï¼»
å‰ã®ä¾‹, ã¾ãŸã¯ `UTF-8$n ä»¥å¤–ã®~encodingã«ç­‰ä¾¡ãª~algo
ï¼½ã«ã‚ˆã‚Šç”Ÿç”£ã•ã‚Œã‚‹å½¢å¼ã«~encodeã•ã‚ŒãŸ~data
ï¼½ã‚’å«ã‚“ã§ã„ã‚‹ `ArrayBuffer$I ã‚’~decodeã—ã¦ã€å…ƒã®ï¼Œä¸€é€£ã®æ–‡å­—åˆ—ã‹ã‚‰ãªã‚‹é…åˆ—ã«æˆ»ã™ã€‚
â—
The following example decodes an ArrayBuffer containing data encoded in the format produced by the previous example, or an equivalent algorithm for encodings other than UTF-8, back into an array of strings.
</p>

<pre>
function decodeArrayOfStrings(%buffer, %encoding) {
  var %decoder, %view, %offset, %num_strings, %strings, %len;

  %decoder = new TextDecoder(%encoding);
  %view = new DataView(%buffer);
  %offset = 0;
  %strings = [];

  %num_strings = %view.getUint32(%offset);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %num_strings; %i++) {
    %len = %view.getUint32(%offset);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %strings[%i] = %decoder.decode(
      new DataView(%view.buffer, %offset, %len));
    %offset += %len;
  }
  return %strings;
}
</pre>
</div>

		<section id="interface-textdecoder">

<h3 title="Interface TextDecoder">7.1. ~interface `TextDecoder^I</h3>

<pre class="idl">
dictionary `TextDecoderOptions@I {
  `boolean$ fatal = false;
  `boolean$ ignoreBOM = false;
};

dictionary `TextDecodeOptions@I {
  `boolean$ stream = false;
};

[<a href="#dom-textdecoder">Constructor</a>(
    optional `DOMString$ %label = "utf-8",
    optional `TextDecoderOptions$I %options
),
 Exposed=(Window,Worker)]
interface `TextDecoder@I {
  readonly attribute `DOMString$ `encoding$m;
  readonly attribute `boolean$ `fatal$m;
  readonly attribute `boolean$ `ignoreBOM$m;
  `USVString$ `decode$m(
      optional BufferSource %input,
      optional `TextDecodeOptions$I %options
  );
};
</pre>

<p class="trans-note">ã€
<a href="Encoding-test.html">åˆ©ç”¨ä¸­ã®~browserã§ã“ã®ç‰¹è‰²æ©Ÿèƒ½ã‚’è©¦ã™</a>
ã€‘</p>

<div class="p">
<p>
å„ `TextDecoder$I ~objã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼ˆæ‹¬å¼§å†…ã¯åˆæœŸ~å€¤ï¼‰ï¼š
</p>

<ul><li>`~encoding@dec
</li><li>`~decoder@dec
<p class="trans-note">ã€
`~encoding^ecã«å¯¾å¿œã™ã‚‹`~decoder$ã®ï¼Œ~instanceã€‚
`~decoder$ã«ã¯ï¼Œå†…éƒ¨çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹å¤‰æ•°ãŸã¡ã‚’ä¼´ã†ã‚‚ã®ã‚‚ã‚ã‚‹ã®ã§ã€~objã”ã¨ã«~instanceã‚’è¦ã™ã‚‹ã€‚
ã€‘</p>

</li><li>`~stream@dec
</li><li>`~BOMignore~flag@decï¼ˆ ~OFF ï¼‰
</li><li>`~BOMseen~flag@decï¼ˆ ~OFF ï¼‰
</li><li>`~error~mode@decï¼ˆ `replacement^l ï¼‰
</li><li>`~no_flush~flag@decï¼ˆ ~OFF ï¼‰
</li></ul>

â—
A TextDecoder object has an associated encoding, decoder, stream, ignore BOM flag (initially unset), BOM seen flag (initially unset), error mode (initially "replacement"), and do not flush flag (initially unset).
</div>


<p class="algo-head">
å„ `TextDecoder$I ~objã«ã¯ã€~streamã‚’
`ç›´åˆ—åŒ–-@dec
ã™ã‚‹~algoã‚‚çµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
ãã‚Œã¯ã€æ‰€ä¸ã®`~stream$ %~stream ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
A TextDecoder object also has an associated serialize stream algorithm, that given a stream stream, runs these steps:
</p>

<ol>
	<li>
%å‡ºåŠ› ~LET ç©º~æ–‡å­—åˆ—
â—
Let output be the empty string.
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>


		<ol>
			<li>
%~token ~LET %~stream ã‹ã‚‰`èª­å–ã£ãŸçµæœ$
â—
Let token be the result of reading from stream.
</li>
			<li>
<p>
~IFï¼»
`~encoding$dec ~IN { `UTF-8$n, `UTF-16BE$n, `UTF-16LE$n }
ï¼½~ANDï¼»
`~BOMignore~flag$dec ~EQ ~OFF
ï¼½~ANDï¼»
`~BOMseen~flag$dec ~EQ ~OFF
ï¼½ï¼š
â—
If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore BOM flag and BOM seen flag are unset, then:
</p>

				<ol>
					<li>
~IFï¼»
%~token ~EQ `FEFF^U
ï¼½
â‡’
`~BOMseen~flag$dec ~SET ~ON
â—
If token is U+FEFF, then set BOM seen flag.
</li>
					<li>
~ELIFï¼»
%~token ~NEQ `~EoS$
ï¼½
â‡’
`~BOMseen~flag$dec ~SET ~ON ~BR
%~token ã‚’ %å‡ºåŠ› ã«ä»˜åŠ ã™ã‚‹
â—
Otherwise, if token is not end-of-stream, then set BOM seen flag and append token to output.
</li>
					<li>
~ELSE
â‡’
~RET %å‡ºåŠ›
â—
Otherwise, return output.
</li>
				</ol>
			</li>
			<li>
~ELIFï¼»
%~token ~NEQ `~EoS$
ï¼½
â‡’
%~token ã‚’ %å‡ºåŠ› ã«ä»˜åŠ ã™ã‚‹
â—
Otherwise, if token is not end-of-stream, then append token to output.
</li>
			<li>
~ELSE
â‡’
~RET %å‡ºåŠ›
â—
Otherwise, return output.
</li>
		</ol>
	</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®~algoã¯ã€~APIã®åˆ©ç”¨è€…ã« ã‚ˆã‚Šå¤šãã®åˆ¶å¾¡ã‚’ä¾›ã™ã‚‹ãŸã‚ï¼Œ~platformã®ä»–ã®å ´æ‰€ã§åˆ©ç”¨ã•ã‚Œã‚‹`~decode$ ~algoã¨ã¯ã€~BOMã®å–æ‰±ã„ã®ç‚¹ã§æ„å›³çš„ã«ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
This algorithm is intentionally different with respect to BOM handling from the decode algorithm used by the rest of the platform to give API users more control.
</p>

<hr>

<dl class="domintro">
	<dt>%decoder = new `TextDecoder$m([%label = "utf-8" [, %options]])</dt>
	<dd>
æ–°ãŸãª `TextDecoder$I ~obj ã‚’è¿”ã™ã€‚
â—
Returns a new TextDecoder object.
</dd>
	<dd>
%label ãŒ`~label$ã§ãªã„, ã¾ãŸã¯
%label ãŒ`replacement$nã§ã‚ã‚‹å ´åˆã€
`RangeError$E ãŒ`æŠ•å‡º-$ã•ã‚Œã‚‹ã€‚
â—
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`~encoding$decã®`åå‰$ã‚’å°æ–‡å­—~åŒ–ã—ã¦è¿”ã™ã€‚
â—
Returns encodingâ€™s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
`~error~mode$decãŒ `fatal^l ãªã‚‰ã° ~T ã‚’, ä»–ã®å ´åˆã¯ ~F ã‚’è¿”ã™ã€‚
â—
Returns true if error mode is "fatal", and false otherwise.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
`~BOMignore~flag$dec ã«å¿œã˜ã¦ï¼»
~ON ãªã‚‰ã° ~T ï¼
~OFF ãªã‚‰ã° ~F
ï¼½ã‚’è¿”ã™ã€‚
â—
Returns true if ignore BOM flag is set, and false otherwise.
</dd>

	<dt>%decoder . `decode([input [, options]])$m</dt>
	<dd>
<p>
%input ã‚’ `~encoding$decã®`~decoder$ã«ã‹ã‘ãŸçµæœã‚’è¿”ã™ã€‚
~streamã‚’æ–­ç‰‡åŒ–ã—ã¦å‡¦ç†ã™ã‚‹ã¨ãã¯ã€
%options ã® `stream^m ~memberã‚’ ~T ã«ã—ãŸä¸‹ã§ï¼Œã“ã®~method 0 å›~ä»¥ä¸Š~å‘¼å‡ºã—ã¦ã‹ã‚‰ï¼Œ %options ã‚’çœç•¥ã—ã¦ï¼ˆã¾ãŸã¯ ãã® `stream^m ~memberã‚’ ~F ã«ã—ã¦ï¼‰
1 å›ã ã‘å‘¼å‡ºã™ã“ã¨ã§è¡Œãˆã‚‹ã€‚
å¾Œè€…ã®å‘¼å‡ºæ™‚ã« %input ã‚‚ãªã„ãªã‚‰ã°ã€ä¸¡~å¼•æ•°ã¨ã‚‚çœç•¥ã™ã‚‹ã®ãŒæœ€ã‚‚ç°¡æ˜ã«ãªã‚‹ã€‚
â—
Returns the result of running encodingâ€™s decoder. The method can be invoked zero or more times with optionsâ€™s stream set to true, and then once without optionsâ€™s stream (or set to false), to process a fragmented stream. If the invocation without optionsâ€™s stream (or set to false) has no input, itâ€™s clearest to omit both arguments.
</p>

<pre class="example">
var %string = "", %decoder = new TextDecoder(%encoding), %buffer;
while(%buffer = next_chunk()) {
  %string += %decoder.decode(%buffer, {stream:true});
}
%string += %decoder.decode(); // ~EoS
</pre>

	</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l ã®ä¸‹ã§ï¼Œ
`~encoding$decã®`~decoder$ãŒ`~error$ã‚’è¿”ã—ãŸå ´åˆã€
`TypeError$E ãŒ`æŠ•å‡º-$ã•ã‚Œã‚‹ã€‚
â—
If the error mode is "fatal" and encodingâ€™s decoder returns error, throws a TypeError.
</dd>
</dl>

<dl class="idl-def">
	<dt>`TextDecoder(label, options)@m</dt>
	<dd>
<p>
ã“ã®æ§‹ç¯‰å­ã®è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã›~MUSTï¼š
â—
The TextDecoder(label, options) constructor, when invoked, must run these steps:
</p>

<ol>
	<li>
%~encoding ~LET %label ã‹ã‚‰`~encodingã‚’å–å¾—-$ã—ãŸçµæœ
â—
Let encoding be the result of getting an encoding from label.
</li>
	<li>
~IFï¼»
%~encoding ~IN { `å¤±æ•—^i, `replacement$n }
ï¼½
â‡’
~THROW `RangeError$E
â—
If encoding is failure or replacement, then throw a RangeError.
</li>
	<li>
%dec ~LET æ–°ãŸãª `TextDecoder$I ~obj
â—
Let dec be a new TextDecoder object.
</li>
	<li>
%dec ã® `~encoding$dec ~SET %~encoding
â—
Set decâ€™s encoding to encoding.
</li>
	<li>
~IFï¼»
%options ã® `fatal^m ~member ~EQ ~T
ï¼½
â‡’
%dec ã® `~error~mode$dec ~SET `fatal^l
â—
If optionsâ€™s fatal member is true, then set decâ€™s error mode to "fatal".
</li>
	<li>
~IFï¼»
%options ã® `ignoreBOM^m ~member ~EQ ~T
ï¼½
â‡’
%dec ã® `~BOMignore~flag$dec ~SET `fatal^l
â—
If optionsâ€™s ignoreBOM member is true, then set decâ€™s ignore BOM flag.
</li>
	<li>
~RET %dec
â—
Return dec.
</li>
</ol>

	</dd>

	<dt>`encoding@m</dt>
	<dd>
å–å¾—å­ã¯ã€æ­¤ã‚Œã®`~encoding$decã®`åå‰$ã‚’`~ASCIIå°æ–‡å­—~åŒ–$ã—ãŸçµæœã‚’è¿”ã•~MUSTã€‚
â—
The encoding attributeâ€™s getter must return encodingâ€™s name in ASCII lowercase.
</dd>

	<dt>`fatal@m</dt>
	<dd>
å–å¾—å­ã¯ã€ï¼»
æ­¤ã‚Œã®`~error~mode$dec ~EQ `fatal^l ãªã‚‰ã° ~T ï¼ ~ELSE_ ~F
ï¼½ã‚’è¿”ã•~MUSTã€‚
â—
The fatal attributeâ€™s getter must return true if error mode is "fatal", and false otherwise.
</dd>

	<dt>`ignoreBOM@m</dt>
	<dd>
å–å¾—å­ã¯ã€ï¼»
æ­¤ã‚Œã®`~BOMignore~flag$dec ~EQ ~ON ãªã‚‰ã° ~T ï¼
~ELSE_ ~F
ï¼½ã‚’è¿”ã•~MUSTã€‚
â—
The ignoreBOM attributeâ€™s getter must return true if ignore BOM flag is set, and false otherwise.
</dd>

	<dt>`decode(input, options)@m</dt>
	<dd>
<p>
è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã›~MUSTï¼š
â—
The decode(input, options) method, when invoked, must run these steps:
</p>

<ol>
	<li>
~IFï¼»
æ­¤ã‚Œã®`~no_flush~flag$dec ~EQ ~OFF
ï¼½
â‡’
æ­¤ã‚Œã®`~decoder$dec ~SET æ–°ãŸãªï¼»
æ­¤ã‚Œã®`~encoding$decã®`~decoder$
ï¼½ ~BR
æ­¤ã‚Œã®`~stream$dec ~SET æ–°ãŸãª`~stream$ ~BR
æ­¤ã‚Œã®`~BOMseen~flag$dec ~SET ~OFF
â—
If the do not flush flag is unset, set decoder to a new encodingâ€™s decoder, set stream to a new stream, and unset the BOM seen flag.
</li>
	<li>
æ­¤ã‚Œã®`~no_flush~flag$dec ~SETï¼»
%options ã® `stream^m ~EQ ~T ãªã‚‰ã° ~ON ï¼
~ELSE_ ~OFF
ï¼½
â—
If optionsâ€™s stream is true, set the do not flush flag, and unset the do not flush flag otherwise.
</li>
	<li>
<p>
~IFï¼»
%input ã¯ä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹
ï¼½
â‡’
%input ã®<a href="~WEBIDL#dfn-get-buffer-source-copy">è¤‡è£½</a>ã‚’ æ­¤ã‚Œã®`~stream$decã«`~pushã™ã‚‹$
â—
If input is given, then push a copy of input to stream.
</p>
<p class="note">æ³¨è¨˜ï¼š
å®Ÿè£…ã«ã¯ã€ã“ã®è¤‡è£½ã‚’é¿ã‘ã‚‹ã‚ˆã†å®Ÿè£…ã™ã‚‹ã“ã¨ãŒå¼·ãå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
ãã†ã™ã‚‹ã¨ãã¯ã€ %input ãŒå¤‰æ›´ã•ã‚Œã¦ã‚‚ï¼Œå¾Œã® `decode()$m ã®~callã«å½±éŸ¿ã—ãªã„ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
â—
Implementations are strongly encouraged to use an implementation strategy that avoids this copy. When doing so they will have to make sure that changes to input do not affect future calls to decode().
</p>
	</li>
	<li>
%å‡ºåŠ› ~LET æ–°ãŸãª`~stream$
â—
Let output be a new stream.
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ï¼š
â—
While true:
</p>


		<ol>
			<li>
%~token ~LET æ­¤ã‚Œã®`~stream$decã‹ã‚‰`èª­å–ã£ãŸçµæœ$
â—
Let token be the result of reading from stream.
</li>
			<li>
<p>
~IFï¼»
%~token ~EQ `~EoS$
ï¼½~ANDï¼»
æ­¤ã‚Œã®`~no_flush~flag$dec ~EQ ~ON
ï¼½
â‡’
~RET %å‡ºåŠ› ã‚’`ç›´åˆ—åŒ–-$decã—ãŸçµæœ
â—
If token is end-of-stream and the do not flush flag is set, then return output, serialized.
</p>

<p class="note">
~streamingã§ã¯ã€ï¼»
`~no_flush~flag$dec ~EQ ~ON
ï¼½ã®ã¨ãã«ï¼Œã“ã“ã§`~EoS$ã‚’å–æ‰±ã†ã“ã¨ãªãï¼Œãã®~flagã‚’ ~OFF ã«ã—ãªã„ä»•æ–¹ã§åƒãã€‚
ã“ã®ä»•æ–¹ã«ã‚ˆã‚Šã€å¾Œç¶šã®å‘¼å‡ºæ™‚ã«ã¯ï¼Œ`~decoder$decã¯ ã“ã®~algoã®æœ€åˆã®æ®µã§ä¸€æ–°ã•ã‚Œãšã€ãã®çŠ¶æ…‹ã¯ä¿å…¨ã•ã‚Œã‚‹ã€‚
â—
The way streaming works is to not handle end-of-stream here when the do not flush flag is set and to not unset that flag. That way in a subsequent invocation decoder is not set anew in the first step of the algorithm and its state is preserved.
</p>
			</li>
			<li>
%çµæœ ~LET æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ`~tokenã‚’å‡¦ç†-$ã—ãŸçµæœ
â‡’
( %~token, æ­¤ã‚Œã®`~decoder$dec, æ­¤ã‚Œã®`~stream$dec, %å‡ºåŠ›, æ­¤ã‚Œã®`~error~mode$dec )
â—
Otherwise:
â—
Let result be the result of processing token for decoder, stream, output, and error mode.
</li>
			<li>
~IFï¼»
%çµæœ ~EQ `å®Œé‚$
ï¼½
â‡’
~RET %å‡ºåŠ› ã‚’`ç›´åˆ—åŒ–-$decã—ãŸçµæœ
â—
If result is finished, then return output, serialized.
</li>
			<li>
~IFï¼»
%çµæœ ~EQ `~error$
ï¼½
â‡’
~THROW `TypeError$E
â—
Otherwise, if result is error, then throw a TypeError.
</li>
		</ol>
	</li>
</ol>

	</dd>
</dl>

		</section>
		<section id="interface-textencoder">

<h3 title="Interface TextEncoder">7.2. ~interface `TextEncoder^I</h3>

<pre class="idl">
[<a href="#dom-textencoder" title="dom-TextEncoder">Constructor</a><!--
We cannot add an argument here that is not the label argument it had previously. That would break content.
-->, Exposed=(Window,Worker)]
interface `TextEncoder@I {
  readonly attribute `DOMString$ `~encoding0$m;
  [NewObject] `Uint8Array$ `encode$m(optional `USVString$ %input = "");
};
</pre>


<p>
å„ `TextEncoder$I ~objã«ã¯ã€
`~encoder@enc
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
A TextEncoder object has an associated encoder.
</p>

<p class="note">æ³¨è¨˜ï¼š
`TextEncoder$I ~objã®æ§‹ç¯‰å­ã«ã¯ã€ %label å¼•æ•°ã¯ãªãï¼Œ~supportã™ã‚‹ã®ã¯ `UTF-8$n ã®ã¿ã§ã‚ã‚‹ã€‚
ã¾ãŸã€~scalarå€¤~bufferã‚’è¦ã™ã‚‹`~encoder$ã¯ç„¡ã„ã®ã§ï¼Œ `stream^m ã®~optionã‚‚ãªã„ã€‚
â—
A TextEncoder object offers no label argument as it only supports UTF-8. It also offers no stream option as no encoder requires buffering of scalar values.
</p>

<hr>

<dl class="domintro">
	<dt>%encoder = new `TextEncoder()$m</dt>
	<dd>
æ–°ãŸãª `TextEncoder$I ~obj ã‚’è¿”ã™ã€‚
â—
Returns a new TextEncoder object.
</dd>

	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l ã‚’è¿”ã™ã€‚
â—
Returns "utf-8".
</dd>

	<dt>%encoder . `encode([input = ""])$m</dt>
	<dd>
%input ã‚’ `UTF-8$n ã®`~encoder$ã«ã‹ã‘ãŸçµæœã‚’è¿”ã™ã€‚
â—
Returns the result of running UTF-8â€™s encoder.
</dd>

</dl>


<dl class="idl-def">
	<dt>`TextEncoder()@m</dt>
	<dd>
<p>
ã“ã®æ§‹ç¯‰å­ã®è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã›~MUSTï¼š
â—
The TextEncoder() constructor, when invoked, must run these steps:
</p>

<ol>
	<li>
%enc ~LET æ–°ãŸãª `TextEncoder$I ~obj
â—
Let enc be a new TextEncoder object.
</li>
	<li>
%enc ã® æ­¤ã‚Œã®`~encoder$enc ~SET `UTF-8$n ã®`~encoder$
â—
Set encâ€™s encoder to UTF-8â€™s encoder.
</li>
	<li>
~RET %enc
â—
Return enc.
</li>
</ol>

	</dd>

	<dt>`~encoding0@m</dt>
	<dd>
å–å¾—å­ã¯ã€ `utf-8^l ã‚’è¿”ã•~MUSTã€‚
â—
The encoding attributeâ€™s getter must return "utf-8".
</dd>

	<dt>`encode(input)@m</dt>
	<dd>
<p>
è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã›~MUSTï¼š
â—
The encode(input) method, when invoked, must run these steps:
</p>


<ol>
	<li>
%å…¥åŠ› ~LET %input ã‚’`~stream$ã«å¤‰æ›ã—ãŸçµæœ
â—
Convert input to a stream.
</li>
	<li>
%å‡ºåŠ› ~LET æ–°ãŸãª`~stream$
â—
Let output be a new stream.
</li>
	<li>
<p>
~WHILE ç„¡æ¡ä»¶ ï¼š
â—
While true:
</p>

		<ol>
			<li>
%~token ~LET %å…¥åŠ› ã‹ã‚‰`èª­å–ã£ãŸçµæœ$
â—
Let token be the result of reading from input.
</li>
			<li>
%çµæœ ~LET æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ`~tokenã‚’å‡¦ç†-$ã—ãŸçµæœ
â‡’
( %~token, æ­¤ã‚Œã®`~encoder$enc, %å…¥åŠ›, %å‡ºåŠ› )
â—
Let result be the result of processing token for encoder, input, output.
</li>
			<li>
~IFï¼»
%çµæœ ~EQ `å®Œé‚$
ï¼½
â‡’
~RET ï¼»ï¼»
%å‡ºåŠ› ã‚’~byteåˆ—ã«å¤‰æ›ã—ãŸçµæœ
ï¼½ã‚’åŒ…å«ã™ã‚‹ `ArrayBuffer$I
ï¼½ã‚’åŒ…è£…ã™ã‚‹ã‚ˆã†ãªï¼Œæ–°ãŸãª `Uint8Array$I ~obj
â—
If result is finished, convert output into a byte sequence, and then return a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
		</ol>

<p class="note">æ³¨è¨˜ï¼š
`UTF-8$n ãŒ`~error$ã‚’è¿”ã™ã“ã¨ã¯ãªã„ã€‚
â—
UTF-8 cannot return error.
</p>
	</li>
</ol>
	</dd>
</dl>

		</section>
	</section>
	<section id="the-encoding">

<h2 title="The encoding">8. ~~æ¨™æº–ã®~encoding</h2>

<p class="trans-note">ã€
ã“ã® â€œ~~æ¨™æº–ã®â€ ã¯ â€œTheâ€ ã®å¯¾è¨³ã§ã‚ã‚Šã€ãŠã‚ˆãï¼Œ
â€œè¦ç¯„ã¨ã•ã‚Œã‚‹ã¹ãå”¯ä¸€ç„¡äºŒã®â€
ã‚’æ„å‘³ã™ã‚‹ã€‚
ã€‘</p>

		<section id="utf-8">

<h3>8.1. ~UTF-8</h3>

			<section id="utf-8-decoder">
<h4 title="UTF-8 decoder">8.1.1. ~UTF-8~decoder</h4>


<p>
`UTF-8$n ã®`~decoder$ã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~UTF-8~cp@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰~BR
`~UTF-8å‡ºç¾~byteæ•°@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰~BR
`~UTF-8è¦~byteæ•°@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰~BR
`~UTF-8ä¸‹é™@ï¼ˆåˆæœŸ~æ™‚ `80^X ï¼‰~BR
`~UTF-8ä¸Šé™@ï¼ˆåˆæœŸ~æ™‚ `BF^X ï¼‰
â—
UTF-8â€™s decoderâ€™s has an associated UTF-8 code point, UTF-8 bytes seen, and UTF-8 bytes needed (all initially 0), a UTF-8 lower boundary (initially 0x80), and a UTF-8 upper boundary (initially 0xBF).
</p>

<p>
`UTF-8$n ã®`~decoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
UTF-8â€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½~ANDï¼»
`~UTF-8è¦~byteæ•°$ ~NEQ 0
ï¼½
â‡’
`~UTF-8è¦~byteæ•°$ ~SET 0 ~BR
~RET `~error$
â—
If byte is end-of-stream and UTF-8 bytes needed is not 0, set UTF-8 bytes needed to 0 and return error.
</li>
	<li>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚$
â—
If byte is end-of-stream, return finished.
</li>
	<li>
<p>
~IFï¼»
`~UTF-8è¦~byteæ•°$ ~EQ 0
ï¼½ï¼š
â—
If UTF-8 bytes needed is 0, based on byte:
</p>

		<ol>
			<li>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
â†‘</p>

				<dl class="switch">
					<dt>`00^X ã€œ `7F^X</dt>
					<dd>
~RET ~cp [ %~byte ]
â—
Return a code point whose value is byte.
</dd>

					<dt>`C2^X ã€œ `DF^X</dt>
					<dd>
						<ol>
							<li>
`~UTF-8è¦~byteæ•°$ ~SET 1
â—
Set UTF-8 bytes needed to 1.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `1F^X
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 5 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte &amp; 0x1F.
â—
The five least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`E0^X ã€œ `EF^X</dt>
					<dd>
						<ol>
							<li>
~IFï¼»
%~byte ~EQ `E0^X
ï¼½
â‡’
`~UTF-8ä¸‹é™$ ~SET `A0^X
â—
If byte is 0xE0, set UTF-8 lower boundary to 0xA0.
</li>
							<li>
~IFï¼»
%~byte ~EQ `ED^X
ï¼½
â‡’
`~UTF-8ä¸Šé™$ ~SET `9F^X
â—
If byte is 0xED, set UTF-8 upper boundary to 0x9F.
</li>
							<li>
`~UTF-8è¦~byteæ•°$ ~SET 2
â—
Set UTF-8 bytes needed to 2.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `F^X
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 4 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte &amp; 0xF.
â—
The four least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`F0^X ã€œ `F4^X</dt>
					<dd>
						<ol>
							<li>
~IFï¼»
%~byte ~EQ `F0^X
ï¼½
â‡’
`~UTF-8ä¸‹é™$ ~SET `90^X
â—
If byte is 0xF0, set UTF-8 lower boundary to 0x90.
</li>
							<li>
~IFï¼»
%~byte ~EQ `F4^X
ï¼½
â‡’
`~UTF-8ä¸Šé™$ ~SET `8F^X
â—
If byte is 0xF4, set UTF-8 upper boundary to 0x8F.
</li>
							<li>
`~UTF-8è¦~byteæ•°$ ~SET 3
â—
Set UTF-8 bytes needed to 3.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `7^X
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 3 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte &amp; 0x7.
â—
The three least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>~OTHERâ—Otherwise</dt>
					<dd>
~RET `~error$
â—
Return error.
</dd>
				</dl>
			</li>
			<li>
~RET `ç¶™ç¶š$
â—
Return continue.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
%~byte ~NIN { `~UTF-8ä¸‹é™$ ã€œ `~UTF-8ä¸Šé™$ }
ï¼½ï¼š
â—
If byte is not in the range UTF-8 lower boundary to UTF-8 upper boundary, inclusive, then:
</p>

		<ol>
			<li>
( `~UTF-8~cp$, `~UTF-8è¦~byteæ•°$, `~UTF-8å‡ºç¾~byteæ•°$ ) ~SET ( 0, 0, 0 ) ~BR
( `~UTF-8ä¸‹é™$, `~UTF-8ä¸Šé™$ ) ~SET ( `80^X, `BF^X )
â—
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0, set UTF-8 lower boundary to 0x80, and set UTF-8 upper boundary to 0xBF.
</li>
	<li>
%~byte ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend byte to stream.
</li>
	<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
( `~UTF-8ä¸‹é™$, `~UTF-8ä¸Šé™$ ) ~SET ( `80^X, `BF^X )
â—
Set UTF-8 lower boundary to 0x80 and UTF-8 upper boundary to 0xBF.
</li>
	<li>
<p>
`~UTF-8~cp$ ~SET (`~UTF-8~cp$ ~Lshift 6) ~bOR (%~byte ~bAND `3F^X)
â—
Set UTF-8 code point to (UTF-8 code point &lt;&lt; 6) | (byte &amp; 0x3F)
</p>

<p class="note">
`~UTF-8~cp$å†…ã®æ—¢å­˜ã®~bitã‚’å·¦ã¸ 6 ~bit ~shiftã—ã¦ï¼Œ~~ç©ºã„ãŸä¸‹ä½ 6 ~bitã« %~byte ã®ä¸‹ä½ 6 ~bitã‚’ã‚ã¦ãŒã†ã€‚
â—
Shift the existing bits of UTF-8 code point left by six places and set the newly-vacated six least significant bits to the six least significant bits of byte.
</p>
	</li>
	<li>
`~UTF-8å‡ºç¾~byteæ•°$ ~INCBY 1
â—
Increase UTF-8 bytes seen by one.
</li>
	<li>
~IFï¼»
`~UTF-8å‡ºç¾~byteæ•°$ ~NEQ `~UTF-8è¦~byteæ•°$
ï¼½
â‡’
~RET `ç¶™ç¶š$
â—
If UTF-8 bytes seen is not equal to UTF-8 bytes needed, return continue.
</li>
	<li>
%~cp ~LET `~UTF-8~cp$
â—
Let code point be UTF-8 code point.
</li>
	<li>
( `~UTF-8~cp$, `~UTF-8è¦~byteæ•°$, `~UTF-8å‡ºç¾~byteæ•°$ ) ~SET ( 0, 0, 0 ) 
â—
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0.
</li>
	<li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ä¸Šã®`~UTF-8~decoder$ã«ãŠã‘ã‚‹æ‹˜æŸã¯ã€~Unicodeæ¨™æº–ã®
â€œBest Practices for Using U+FFFDâ€
ã«æº–ã˜ã‚‹ã€‚
ä»–ã®ãµã‚‹ã¾ã„ã¯ Encoding æ¨™æº–ã®ä¸‹ã§ã¯è¨±å¯ã•ã‚Œãªã„ï¼ˆåŒã˜çµæœãŒå¾—ã‚‰ã‚Œã‚‹ãªã‚‰ã€ä»–ã®~algoã§ã‚‚~~ååˆ†ã§ã‚ã‚Šï¼Œã‚€ã—ã‚å¥¨åŠ±ã•ã‚Œã‚‹ï¼‰ã€‚
`UNICODE$r
â—
The constraints in the UTF-8 decoder above match â€œBest Practices for Using U+FFFDâ€ from the Unicode standard. No other behavior is permitted per the Encoding Standard (other algorithms that achieve the same result are fine, even encouraged). [UNICODE]
</p>

			</section>
			<section id="utf-8-encoder">
<h4 title="UTF-8 encoder">8.1.2. ~UTF-8~encoder</h4>

<p>
`UTF-8$n ã®`~encoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
UTF-8â€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚$
â—
If code point is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
( %count, %~offset ) ~SET %~cp ãŒå±ã™ã‚‹ç¯„å›²ã«å¿œã˜ã¦ï¼Œæ¬¡ã§ä¸ãˆã‚‰ã‚Œã‚‹å€¤ï¼š
â—
Set count and offset based on the range code point is in:
</p>

<div>

		<dl class="switch">
			<dt>`0080^U ã€œ `07FF^U</dt>
			<dd>
( 1, `C0^X )
</dd>
			<dt>`0800^U ã€œ `FFFF^U</dt>
			<dd>
( 2, `E0^X )
</dd>
			<dt>`10000^U ã€œ `10FFFF^U</dt>
			<dd>
( 3, `F0^X )
</dd>
		</dl>

â—
U+0080 to U+07FF, inclusive
â€¢ 1 and 0xC0
U+0800 to U+FFFF, inclusive
â€¢ 2 and 0xE0
U+10000 to U+10FFFF, inclusive
â€¢ 3 and 0xF0
</div>

	</li>
	<li>
%~byteåˆ— ~LET ~byteåˆ— [ ( %~cp ~Rshift ( 6 ~MUL %count ) ) ~PLUS %~offset ]
â—
Let bytes be a byte sequence whose first byte is (code point &gt;&gt; (6 Ã— count)) + offset.
</li>
	<li>
<p>
~WHILE %count ~GT 0
ï¼š
â—
While count is greater than 0:
</p>

		<ol>
			<li>
%temp ~SET %~cp ~Rshift ( 6 ~MUL ( %count ~MINUS 1 ) )
â—
Set temp to code point &gt;&gt; (6 Ã— (count âˆ’ 1)).
</li>
	<li>
( `80^X ~bOR ( %temp ~bAND `3F^X ) ) ã‚’ %~byteåˆ— ã«ä»˜åŠ ã™ã‚‹
â—
Append to bytes 0x80 | (temp &amp; 0x3F).
</li>
	<li>
%count ~DECBY 1
â—
Decrease count by one.
</li>
		</ol>
	</li>
	<li>
~RET %~byteåˆ—
â—
Return bytes bytes, in order.
</li>
</ol>

<p class="note">
ã“ã®~algoã¯ã€~Unicodeæ¨™æº–ã«è¿°ã¹ã‚‰ã‚Œã‚‹ã‚‚ã®ã¨ä¸€è‡´ã™ã‚‹çµæœã‚’å¾—ã‚‹ãŒã€å®Œå…¨ã•ã®ãŸã‚ã“ã“ã«å«ã‚ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
`UNICODE$r
â—
This algorithm has identical results to the one described in the Unicode standard. It is included here for completeness. [UNICODE]
</p>


			</section>
		</section>
	</section>
	<section id="legacy-single-byte-encodings">

<h2 title="Legacy single-byte encodings">9. æ—§æ¥ã®å˜byte~encoding</h2>

<p>
å„~byteãŒï¼»
ï¼‘å€‹ã®~cpã«å¯¾å¿œã™ã‚‹ã‹, ã¾ãŸã¯å¯¾å¿œã™ã‚‹~cpã¯ç„¡ã„
ï¼½ã‚ˆã†ãª`~encoding$ã‚’
`å˜byte~encoding@
ã¨å‘¼ã¶ã€‚
ã™ã¹ã¦ã®`å˜byte~encoding$ãŒã€åŒã˜ï¼»
`~decoder$, `~encoder$
ï¼½ã‚’å…±æœ‰ã™ã‚‹ã€‚
`å˜byte~decoder$ï¼`å˜byte~encoder$ã‹ã‚‰å‚ç…§ã•ã‚Œã‚‹
`å˜byteç´¢å¼•@
ã¯ã€åˆ©ç”¨ã•ã‚Œã‚‹`å˜byte~encoding$ã«ä¾å­˜ã—ï¼Œæ¬¡ã®ä¸€è¦§ã§å®šç¾©ã•ã‚Œã‚‹ã€‚
ï¼»
`ISO-8859-8^n, `ISO-8859-8-I^n
ï¼½ã‚’é™¤ãã™ã¹ã¦ã®`å˜byte~encoding$ã¯ã€ãã‚Œãã‚Œã«ä¸€æ„ãª`ç´¢å¼•$ã‚’æŒã¤ã€‚
â—
An encoding where each byte is either a single code point or nothing, is a single-byte encoding. Single-byte encodings share the decoder and encoder. Index single-byte, as referenced by the single-byte decoder and single-byte encoder, is defined by the following table, and depends on the single-byte encoding in use. All but two single-byte encodings have a unique index.
</p>

<p class="trans-note">ã€
è¢«è¦†åŸŸã®~tableã¯å·¨å¤§ãªã“ã¨ã«æ³¨æ„ã€‚
ã€‘</p>

<table>
<thead><tr><th>`åå‰$
<th>`ç´¢å¼•$
<th>è¦–è¦šåŒ–
<th>åŸºæœ¬å¤šè¨€èªé¢ï¼ˆ BMP ï¼‰ã®è¢«è¦†åŸŸ
</thead>

<tbody>
<tr><td>`IBM866@n<td>`IBM866$idx
<tr><td>`ISO-8859-2@n<td>`ISO-8859-2$idx
<tr><td>`ISO-8859-3@n<td>`ISO-8859-3$idx
<tr><td>`ISO-8859-4@n<td>`ISO-8859-4$idx
<tr><td>`ISO-8859-5@n<td>`ISO-8859-5$idx
<tr><td>`ISO-8859-6@n<td>`ISO-8859-6$idx
<tr><td>`ISO-8859-7@n<td>`ISO-8859-7$idx
<tr><td>`ISO-8859-8@n<td>`ISO-8859-8$idx
<tr><td>`ISO-8859-8-I@n<td colspan="3">`ISO-8859-8$n ã¨åŒã˜
<tr><td>`ISO-8859-10@n<td>`ISO-8859-10$idx
<tr><td>`ISO-8859-13@n<td>`ISO-8859-13$idx
<tr><td>`ISO-8859-14@n<td>`ISO-8859-14$idx
<tr><td>`ISO-8859-15@n<td>`ISO-8859-15$idx
<tr><td>`ISO-8859-16@n<td>`ISO-8859-16$idx
<tr><td>`KOI8-R@n<td>`KOI8-R$idx
<tr><td>`KOI8-U@n<td>`KOI8-U$idx
<tr><td>`macintosh@n<td>`macintosh$idx
<tr><td>`windows-874@n<td>`windows-874$idx
<tr><td>`windows-1250@n<td>`windows-1250$idx
<tr><td>`windows-1251@n<td>`windows-1251$idx
<tr><td>`windows-1252@n<td>`windows-1252$idx
<tr><td>`windows-1253@n<td>`windows-1253$idx
<tr><td>`windows-1254@n<td>`windows-1254$idx
<tr><td>`windows-1255@n<td>`windows-1255$idx
<tr><td>`windows-1256@n<td>`windows-1256$idx
<tr><td>`windows-1257@n<td>`windows-1257$idx
<tr><td>`windows-1258@n<td>`windows-1258$idx
<tr><td>`x-mac-cyrillic@n<td>`x-mac-cyrillic$idx
</tbody>
</table>

<p class="note">æ³¨è¨˜ï¼š
~layoutæ–¹å‘ã«æ³¢åŠã™ã‚‹ã“ã¨ã‹ã‚‰ã€ `ISO-8859-8$n ã¨ `ISO-8859-8-I$n ã®`~encoding$ã®`åå‰$ã¯ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ã€‚
æ­´å²çš„ã«ã€ã“ã®ã“ã¨ã¯ `ISO-8859-6$n ã¨ "ISO-8859-6-I" ã«ã¤ã„ã¦ã‚‚è©²å½“ã—ã¦ã„ãŸãŒã€ãã‚Œã¯ä»Šã‚„æˆç«‹ã—ãªã„ã€‚
<!-- https://www.w3.org/Bugs/Public/show_bug.cgi?id=19505 -->
â—
ISO-8859-8 and ISO-8859-8-I are distinct encoding names, because ISO-8859-8 has influence on the layout direction. And although historically this might have been the case for ISO-8859-6 and "ISO-8859-6-I" as well, that is no longer true.
</p>



		<section id="single-byte-decoder">
<h3 title="single-byte decoder">9.1. å˜byte~decoder</h3>

<p>
`å˜byte~encoding$ã®`~decoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Single-byte encodingsâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚$
â—
If byte is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
%~cp ~LET
`å˜byteç´¢å¼•$ ã®ä¸­ã§
( %~byte ~MINUS `80^X )
ãŒæŒ‡ã™`ç´¢å¼•~cp$
â—
Let code point be the index code point for byte âˆ’ 0x80 in index single-byte.
</li>
	<li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET `~error$
â—
If code point is null, return error.
</li>
	<li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
</ol>

		</section>
		<section id="single-byte-encoder">
<h3 title="single-byte encoder">9.2. å˜byte~encoder</h3>

<p>
`å˜byte~encoding$ ã®`~encoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Single-byte encodingsâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚$
â—
If code point is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET
`å˜byteç´¢å¼•$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for code point in index single-byte.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
~RET ~byteåˆ— [ %~pointer ~PLUS `80^X ]
â—
Return a byte whose value is pointer + 0x80.
</li>
</ol>

		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(simplified)-encodings">

<h2 title="Legacy multi-byte Chinese (simplified) encodings">10. æ—§æ¥ã®è¤‡byte Chinese ï¼ˆç°¡ä½“å­—ï¼‰ ~encoding</h2>

		<section id="gbk">
<h3 title="GBK">10.1 ~GBK</h3>

			<section id="gbk-decoder">
<h4 title="GBK decoder">10.1.1 ~GBK~decoder</h4>

<p>
`GBK$nã®`~decoder$ã¯ï¼Œ`gb18030$nã®`~decoder$ã§ã‚ã‚‹ã€‚
â—
GBKâ€™s decoder is gb18030â€™s decoder.
</p>

			</section>
			<section id="gbk-encoder">
<h4 title="GBK encoder">10.1.2 ~GBK~encoder</h4>

<p>
GBK ã®~encoderã¯ï¼Œï¼»
`~GBK~flag$ ~SET ~ON
ï¼½ã«ã•ã‚ŒãŸ`gb18030$nã®`~encoder$ã§ã‚ã‚‹ã€‚
â—
GBKâ€™s encoder is gb18030â€™s encoder with its GBK flag set.
</p>


<p class="note">æ³¨è¨˜ï¼š
`GBK$nã‚’`gb18030$nã«å¯¾ã™ã‚‹å…¨ãã®åˆ¥åã«ã—ãªã„ã®ã¯ã€
`GBK$nã®`~encoder$ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚ŒãŸå†…å®¹ã‚’ï¼Œæ—§æ¥ã®~serverã‚„ä»–ã®æ¶ˆè²»è€…ã‚’ãªã‚‹ã¹ãå£Šã™ã“ã¨ãªãï¼Œä¿å®ˆçš„ã«ç§»è¡Œã™ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
â—
Not fully aliasing GBK with gb18030 is a conservative move to decrease the chances of breaking legacy servers and other consumers of content generated with GBKâ€™s encoder.
</p>
			</section>
		</section>


		<section id="gb18030">

<h3 title="gb18030">10.2. ~gb18030</h3>


			<section id="gb18030-decoder">
<h4 title="gb18030 decoder">10.2.1. ~gb18030~decoder</h4>

<p>
`gb18030$n ã®`~decoder$ã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~gb1@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰~BR
`~gb2@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰~BR
`~gb3@ï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰
â—
gb18030â€™s decoder has an associated gb18030 first, gb18030 second, and gb18030 third (all initially 0x00).
</p>

<p>
`gb18030$n ã®`~decoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
gb18030â€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>

		<ol>
			<li>
~IFï¼»
( `~gb1$, `~gb2$, `~gb3$ ) ~EQ ( `00^X, `00^X, `00^X )
ï¼½
â‡’
~RET `å®Œé‚$
â—
If byte is end-of-stream and gb18030 first, gb18030 second, and gb18030 third are 0x00, return finished.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X ) ~BR
~RET `~error$
â—
If byte is end-of-stream, and gb18030 first, gb18030 second, or gb18030 third is not 0x00, set gb18030 first, gb18030 second, and gb18030 third to 0x00, and return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~gb3$ ~NEQ `00^X
ï¼½ï¼š
â—
If gb18030 third is not 0x00, then:
</p>
		<ol>
			<li>
<p>
~IFï¼»
%~byte ~NIN { `30^X ã€œ `39^X }
ï¼½ï¼š
â—
If byte is not in the range 0x30 to 0x39, inclusive, then:
</p>
				<ol>
					<li>
~byteåˆ— [ `~gb2$, `~gb3$, %~byte ] ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend gb18030 second, gb18030 third, and byte to stream.
</li>
					<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
â—
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
					<li>
~RET `~error$
â—
Return error.
</li>
				</ol>
			</li>
			<li>
%~cp ~LET æ¬¡ã«ä¸ãˆã‚‹~pointerãŒæŒ‡ã™`ç´¢å¼•~gb18030ç¯„å›²é›†~cp$
â‡’
(( `~gb1$ ~MINUS `81^X ) ~MUL ( 10 ~MUL 126 ~MUL 10 )) ~PLUS
(( `~gb2$ ~MINUS `30^X ) ~MUL ( 10 ~MUL 126 )) ~PLUS
(( `~gb3$ ~MINUS `81^X ) ~MUL 10 ) ~PLUS
( %~byte ~MINUS `30^X )
â—
Let code point be the index gb18030 ranges code point for ((gb18030 first âˆ’ 0x81) Ã— (10 Ã— 126 Ã— 10)) + ((gb18030 second âˆ’ 0x30) Ã— (10 Ã— 126)) + ((gb18030 third âˆ’ 0x81) Ã— 10) + byte âˆ’ 0x30.
</li>
			<li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET `~error$
â—
If code point is null, return error.
</li>
			<li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~gb2$ ~NEQ `00^X
ï¼½ï¼š
â—
If gb18030 second is not 0x00, then:
</p>

		<ol>
			<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `FE^X }
ï¼½
â‡’
`~gb3$ ~SET %~byte ~BR
~RET `ç¶™ç¶š$
â—
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 third to byte and return continue.
</li>
			<li>
~byteåˆ— [ `~gb2$, %~byte ] ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$ ~BR
( `~gb1$, `~gb2$ ) ~SET ( `00^X, `00^X ) ~BR
~RET `~error$
â—
Prepend gb18030 second followed by byte to stream, set gb18030 first and gb18030 second to 0x00, and return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~gb1$ ~NEQ `00^X
ï¼½ï¼š
â—
If gb18030 first is not 0x00, then:
</p>

		<ol>
			<li>
~IFï¼»
%~byte ~IN { `30^X ã€œ `39^X }
ï¼½
â‡’
`~gb2$ ~SET %~byte ~BR
~RET `ç¶™ç¶š$
â—
If byte is in the range 0x30 to 0x39, inclusive, set gb18030 second to byte and return continue.
</li>
			<li>
%~lead ~LET `~gb1$ ~BR
%~pointer ~LET ~NULL ~BR
`~gb1$ ~SET `00^X
â—
Let lead be gb18030 first, let pointer be null, and set gb18030 first to 0x00.
</li>
			<li>
%~offset ~LET ï¼»
%~byte ~IN { `00^X ã€œ `7E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40 if byte is less than 0x7F and 0x41 otherwise.
</li>
			<li>
~IFï¼»
%~byte ~IN { `40^X ã€œ `7E^X, `80^X ã€œ `FE^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS %~offset )
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 190 + (byte âˆ’ offset).
</li>
			<li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_
`ç´¢å¼•~gb18030$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
ï¼½
â—
Let code point be null if pointer is null and the index code point for pointer in index gb18030 otherwise.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp [ %~cp ]
â—
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
%~byte ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
â†“</p>

		<dl class="switch">
			<dt>`~ASCII~byte$</dt>
			<dd>
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</dd>

			<dt>`80^X</dt>
			<dd>
~RET ~cp [ `20AC^U ]
â—
If byte is 0x80, return code point U+20AC.
</dd>

			<dt>`81^X ã€œ `FE^X</dt>
			<dd>
`~gb1$ ~SET %~byte ~BR
~RET `ç¶™ç¶š$
â—
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 first to byte and return continue.
</dd>

			<dt>ãã®ä»–ï¼ˆ `FF^X ï¼‰</dt>
			<dd>
~RET `~error$
â—
Return error.
</dd>

		</dl>
	</li>
</ol>


			</section>
			<section id="gb18030-encoder">
<h4 title="gb18030 encoder">10.2.2. ~gb18030~encoder</h4>

<p>
`gb18030$nã® `~encoder$ã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~GBK~flag@ï¼ˆåˆæœŸ~æ™‚ ~OFF ï¼‰
â—
gb18030â€™s encoder has an associated GBK flag (initially unset).
</p>

<p>
`gb18030$n ã®`~encoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
gb18030â€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚$
â—
If code point is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
~IFï¼»
%~cp ~EQ `E5E5^U
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If code point is U+E5E5, return error with code point.
</p>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™æ¸ˆã¿ã®å†…å®¹ã¨ã®äº’æ›æ€§ã‚’ã¨ã‚‹ãŸã‚ã€ `ç´¢å¼•~gb18030$ ã¯ï¼»
`A3^X `A0^X
ï¼½ã‚’ `E5E5^U ã§ã¯ãªã `3000^U ã«å¯¾å¿œä»˜ã‘ã¦ã„ã‚‹ã€‚
ã—ãŸãŒã£ã¦å¾€æ¥ã§ããªã„ã€‚
â—
Index gb18030 maps 0xA3 0xA0 to U+3000 rather than U+E5E5 for compatibility with deployed content. Therefore it cannot roundtrip.
</p>

</li>
	<li>
~IFï¼»
`~GBK~flag$ ~EQ ~ON
ï¼½~ANDï¼»
%~cp ~EQ `20AC^U
ï¼½
â‡’
~RET ~byteåˆ— [ `80^X ]
â—
If the GBK flag is set and code point is U+20AC, return byte 0x80.
</li>
	<li>
%~pointer ~LET
`ç´¢å¼•~gb18030$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for code point in index gb18030.
</li>
	<li>
<p>
~IFï¼»
%~pointer ~NEQ ~NULL
ï¼½ï¼š
â—
If pointer is non-null, then:
</p>

		<ol>
			<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
â—
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET %~pointer ~MOD 190
â—
Let trail be pointer % 190.
</li>
			<li>
%~offset ~LET ï¼»
%~trail  ~IN { `00^X ã€œ `3E^X } ãªã‚‰ã° `40^X<!--0x7F-0x40--> ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.
</li>
			<li>
~RET ~byteåˆ— [ %~lead, ( %~trail ~PLUS %~offset ) ]
â—
Return two bytes whose values are lead and trail + offset.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
`~GBK~flag$ ~EQ ~ON
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If GBK flag is set, return error with code point.
</li>
	<li>
%~pointer ~SET
%~cp
ã‚’æŒ‡ã™`ç´¢å¼•~gb18030ç¯„å›²é›†~pointer$
â—
Set pointer to the index gb18030 ranges pointer for code point.
</li>
	<li>
%byte1 ~LET %~pointer ~DIV ( 10 ~MUL 126 ~MUL 10 )
â—
Let byte1 be pointer / (10 Ã— 126 Ã— 10).
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 ~MUL 10 )
â—
Set pointer to pointer % (10 Ã— 126 Ã— 10).
</li>
	<li>
%byte2 ~LET %~pointer ~DIV ( 10 ~MUL 126 )
â—
Let byte2 be pointer / (10 Ã— 126). 
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 )
â—
Set pointer to pointer % (10 Ã— 126). 
</li>
	<li>
%byte3 ~LET %~pointer ~DIV 10
â—
Let byte3 be pointer / 10.
</li>
	<li>
%byte4 ~LET %~pointer ~MOD 10
â—
Let byte4 be pointer % 10. 
</li>
	<li>
~RET ~byteåˆ— [
( %byte1 ~PLUS `81^X ),
( %byte2 ~PLUS `30^X ),
( %byte3 ~PLUS `81^X ),
( %byte4 ~PLUS `30^X )
]
â—
Return four bytes whose values are byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(traditional)-encodings">

<h2 title="Legacy multi-byte Chinese (traditional) encodings">11. æ—§æ¥ã®è¤‡byte Chinese ï¼ˆç¹ä½“å­—ï¼‰~encoding</h2>

<!--
 Lead:  0x81 to 0xFE
 Trail: 0x40 to 0x7E or 0xA1 to 0xFE
-->


		<section id="big5">

<h3 title="Big5">11.1. ~Big5</h3>

			<section id="big5-decoder">
<h4 title="Big5 decoder">11.1.1. ~Big5~decoder</h4>

<p>
`Big5$n ã®`~decoder$ã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~Big5~lead@ï¼ˆåˆæœŸ~æ™‚ `00^X ï¼‰
â—
Big5â€™s decoder has an associated Big5 lead (initially 0x00).
</p>

<p>
`Big5$n ã®`~decoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Big5â€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
</p>

		<ol>
			<li>
~IFï¼»
`~Big5~lead$ ~NEQ `00^X
ï¼½
â‡’
`~Big5~lead$ ~SET `00^X ~BR
~RET `~error$
</li>
			<li>
~RET `å®Œé‚$
</li>
		</ol>
â—
If byte is end-of-stream and Big5 lead is not 0x00, set Big5 lead to 0x00 and return error.
â—
If byte is end-of-stream and Big5 lead is 0x00, return finished.
</li>
	<li>
<p>
~IFï¼»
`~Big5~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If Big5 lead is not 0x00, let lead be Big5 lead, let pointer be null, set Big5 lead to 0x00, and then:
</p>

		<ol>
			<li>
%~lead ~LET `~Big5~lead$ ~BR
%~pointer ~LET ~NULL ~BR
`~Big5~lead$ ~SET `00^X
â—
â†‘</li>
			<li>
%~offset ~LET ï¼»
%~byte ~IN { `00^X ã€œ `7E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `62^X <!-- 0x62 = 0xA1-0x7E+1+0x40 -->
ï¼½
â—
Let offset be 0x40 if byte is less than 0x7F and 0x62 otherwise.
</li>
			<li>
~IFï¼»
%~byte ~IN { `40^X ã€œ `7E^X, `A1^X ã€œ `FE^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 157 ~PLUS ( %~byte ~MINUS %~offset )
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 157 ~PLUS (byte âˆ’ offset).
</li>
			<li>
<p>
~IFï¼»
ä¸‹ã®è¡¨ã®ä¸­ã§ï¼Œ 1 åˆ—ç›®ãŒ %~pointer ã«ç­‰ã—ã„è¡ŒãŒã‚ã‚‹
ï¼½
â‡’
~RET åŒã˜è¡Œã® 2 åˆ—ç›®ã® <em>2 å€‹ã®</em> ~cpã‹ã‚‰ãªã‚‹`~token$åˆ—
â—
If there is a row in the table below whose first column is pointer, return the two code points listed in its second column (the third column is irrelevant):
</p>

<!-- https://www.unicode.org/Public/UNIDATA/NamedSequences.txt -->
<table><thead><tr><th>~pointerâ—Pointer
<th>~cpâ—Code points
<th>èª¬æ˜ï¼ˆã“ã®æ®µã«ã¯é–¢ä¿‚ãªã„ï¼‰â—Notes
</thead>

<tbody id="_big5-lead"><tr><td>1133<!-- 0x88 0x62 -->
<td>`00CA^U `0304^U
<td>ÃŠÌ„ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON)

<tr><td>1135<!-- 0x88 0x64 -->
<td>`00CA^U `030C^U
<td>ÃŠÌŒ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON)

<tr><td>1164<!-- 0x88 0xA3 -->
<td>`00EA^U `0304^U
<td>ÃªÌ„ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON)

<tr><td>1166<!-- 0x88 0xA5 -->
<td>`00EA^U `030C^U
<td>ÃªÌŒ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON)

</tbody></table>
<!-- we do this to avoid PUA -->


<p class="note">æ³¨è¨˜ï¼š
`ç´¢å¼•$ ã¯å˜ç‹¬ã®~cpã«åˆ¶é™ã•ã‚Œã‚‹ã®ã§ã€ã“ã‚Œã‚‰ã®~pointerã«ã¯ã“ã®è¡¨ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
Since indexes are limited to single code points this table is used for these pointers.
</p>
			</li>
			<li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ `ç´¢å¼•~Big5$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
ï¼½
â—
Let code point be null if pointer is null and the index code point for pointer in index Big5 otherwise.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp [ %~cp ]
â—
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
%~byte ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `FE^X }
ï¼½
â‡’
`~Big5~lead$ ~SET %~byte ~BR
~RET `ç¶™ç¶š$
â—
If byte is in the range 0x81 to 0xFE, inclusive, set Big5 lead to byte and return continue.
</li>
	<li>
~RET `~error$
â—
Return error.
</li>
</ol>

			</section>
			<section id="big5-encoder">
<h4 title="Big5 encoder">11.1.2. ~Big5~encoder</h4>

<p>
`Big5$n ã®`~encoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Big5â€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚$
â—
If code point is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET %~cp ã‚’æŒ‡ã™`ç´¢å¼•~Big5~pointer$
â—
Let pointer be the index Big5 pointer for code point.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 157 ) ~PLUS `81^X
â—
Let lead be pointer / 157 + 0x81.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 157
â—
Let trail be pointer % 157.
</li>
	<li>
%~offset ~LET ï¼»
%~trail ~IN { `00^X ã€œ `3E^X } ãªã‚‰ã° `40^X<!--0x7F-0x40--> ï¼
~ELSE_ `62^X<!--0xA1-0x3F-->
ï¼½
â—
Let offset be 0x40 if trail is less than 0x3F and 0x62 otherwise.
</li>
	<li>
~RET ~byteåˆ— [ %~lead, ( %~trail ~PLUS %~offset) ]
â—
Return two bytes whose values are lead and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-japanese-encodings">

<h2 title="Legacy multi-byte Japanese encodings">12. æ—§æ¥ã®è¤‡byte Japanese ~encoding</h2>


		<section id="euc-jp">

<h3 title="EUC-JP">12.1. ~EUC-JP</h3>

<!-- https://www.iana.org/assignments/charset-reg/CP51932 -->

			<section id="euc-jp-decoder">
<h4 title="EUC-JP decoder">12.1.1. ~EUC-JP~decoder</h4>

<p>
`EUC-JP$n ã®`~decoder$ã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~EUC-JP~jis0212~flag@ï¼ˆåˆæœŸ~æ™‚ ~OFF ï¼‰~BR
`~EUC-JP~lead@ï¼ˆåˆæœŸ~æ™‚ `00^Xï¼‰
â—
EUC-JPâ€™s decoder has an associated EUC-JP jis0212 flag (initially unset) and EUC-JP lead (initially 0x00).
</p>

<p>
`EUC-JP$n ã®`~decoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-JPâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>

		<ol>
			<li>
~IFï¼»
`~EUC-JP~lead$ ~NEQ `00^X
ï¼½
â‡’
`~EUC-JP~lead$ ~SET `00^X ~BR
~RET `~error$
â—
If byte is end-of-stream and EUC-JP lead is not 0x00, set EUC-JP lead to 0x00, and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚$
â—
If byte is end-of-stream and EUC-JP lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
`~EUC-JP~lead$ ~EQ `8E^X
ï¼½~ANDï¼»
%~byte ~IN { `A1^X ã€œ `DF^X }
ï¼½
â‡’
`~EUC-JP~lead$ ~SET `00^X ~BR
~RET ~cp [ `FF61^X ~MINUS `A1^X ~PLUS %~byte ]
<!-- katakana; subtraction is done first to avoid upsetting compilers -->
â—
If EUC-JP lead is 0x8E and byte is in the range 0xA1 to 0xDF, inclusive, set EUC-JP lead to 0x00 and return a code point whose value is 0xFF61 âˆ’ 0xA1 + byte.
</li>
	<li>
~IFï¼»
`~EUC-JP~lead$ ~EQ `8F^X
ï¼½~ANDï¼»
%~byte ~IN { `A1^X ã€œ `FE^X }
ï¼½
â‡’
`~EUC-JP~jis0212~flag$ ~SET ~ON ~BR
`~EUC-JP~lead$ ~SET %~byte ~BR
~RET `ç¶™ç¶š$
â—
If EUC-JP lead is 0x8F and byte is in the range 0xA1 to 0xFE, inclusive, set the EUC-JP jis0212 flag, set EUC-JP lead to byte, and return continue.
</li>
	<li>
<p>
~IFï¼»
`~EUC-JP~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If EUC-JP lead is not 0x00, let lead be EUC-JP lead, set EUC-JP lead to 0x00, and then:
</p>

		<ol>
			<li>
%~lead ~LET `~EUC-JP~lead$ ~BR
`~EUC-JP~lead$ ~SET `00^X
â—
â†‘</li>
			<li>
%~cp ~LET ~NULL
â—
Let code point be null.
</li>
			<li>
~IFï¼»
%~lead, %~byte ãŒã„ãšã‚Œã‚‚ ~IN { `A1^X ã€œ `FE^X }
ï¼½
â‡’
%ç´¢å¼• ~LET ï¼»
`~EUC-JP~jis0212~flag$ ~EQ ~OFF ãªã‚‰ã°`ç´¢å¼•~jis0208$ ï¼
~ON ãªã‚‰ã°ï¼»
`ç´¢å¼•~jis0212$
ï¼½~BR
%~cp ~SET %ç´¢å¼• ã®ä¸­ã§
( ( %~lead ~MINUS `A1^X ) ~MUL 94 ~PLUS %~byte ~MINUS `A1^X )
ãŒæŒ‡ã™`ç´¢å¼•~cp$
â—
If lead and byte are both in the range 0xA1 to 0xFE, inclusive, set code point to the index code point for (lead âˆ’ 0xA1) Ã— 94 + byte âˆ’ 0xA1 in index jis0208 if the EUC-JP jis0212 flag is unset and in index jis0212 otherwise.
</li>
			<li>
`~EUC-JP~jis0212~flag$ ~SET ~OFF
â—
Unset the EUC-JP jis0212 flag.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp [ %~cp ]
â—
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
%~byte ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `8E^X, `8F^X, `A1^X ã€œ `FE^X }
ï¼½
â‡’
`~EUC-JP~lead$ ~SET %~byte ~BR
~RET `ç¶™ç¶š$
â—
If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE, inclusive, set EUC-JP lead to byte and return continue.
</li>
	<li>
~RET `~error$
â—
Return error.
</li>
</ol>


			</section>
			<section id="euc-jp-encoder">
<h4 title="EUC-JP encoder">12.1.2. ~EUC-JP~encoder</h4>

<p>
`EUC-JP$n ã®`~encoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-JPâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
<p>
%~cp ã«å¿œã˜ã¦ï¼š
â—
â†“</p>
		<dl class="switch">
			<dt>`~EoS$</dt>
			<dd>
~RET `å®Œé‚$
â—
If code point is end-of-stream, return finished.
</dd>

			<dt>`~ASCII~cp$</dt>
			<dd>
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

			<dt>`00A5^U</dt>
			<dd>
~RET ~byteåˆ— [ `5C^X ]
â—
If code point is U+00A5, return byte 0x5C.
</dd>

			<dt>`203E^U</dt>
			<dd>
~RET ~byteåˆ— [ `7E^X ]
â—
If code point is U+203E, return byte 0x7E.
</dd>

			<dt>`FF61^U ã€œ `FF9F^U</dt>
			<dd>
~RET ~byteåˆ— [ `8E^X, ( %~cp ~MINUS `FF61^X ~PLUS `A1^X ) ]
â—
If code point is in the range U+FF61 to U+FF9F, inclusive, return two bytes whose values are 0x8E and code point âˆ’ 0xFF61 + 0xA1.
</dd>

			<dt>~OTHER</dt>
			<dd>ä½•ã‚‚ã—ãªã„</dd>
		</dl>
	</li>
	<li>
~IFï¼»
%~cp ~EQ `2212^U
ï¼½
â‡’
%~cp ~SET `FF0D^U
â—
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
<p>
%~pointer ~LET `ç´¢å¼•~jis0208$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for code point in index jis0208.
</p>

<p class="note">æ³¨è¨˜ï¼š
%~pointer ã¯ã€ ~NULL ã§ãªã‘ã‚Œã°ï¼Œ`ç´¢å¼•~jis0208$ã¨~pointeræ¼”ç®—ã®è³‡è³ªã«å› ã‚Š 8836 æœªæº€ã«ãªã‚‹ã€‚
â—
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `A1^X
â—
Let lead be pointer / 94 + 0xA1.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `A1^X
â—
Let trail be pointer % 94 + 0xA1.
</li>
	<li>
~RET ~byteåˆ— [ %~lead, %~trail ]
â—
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="iso-2022-jp">

<h3 title="ISO-2022-JP">12.2. ~ISO-2022-JP</h3>

<!--
 https://tools.ietf.org/html/rfc1468
 https://tools.ietf.org/html/rfc2237 (iso-2022-jp-1; not used)
 "ESC ) I" is from iso-2022-jp-3 reportedly
-->

			<section id="iso-2022-jp-decoder">
<h4 title="ISO-2022-JP decoder">12.2.1. ~ISO-2022-JP~decoder</h4>

<p>
`ISO-2022-JP$n ã®`~decoder$ã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~ISO-2022-JP~decoderçŠ¶æ…‹@ï¼ˆåˆæœŸ~æ™‚ `ASCII$iï¼‰~BR
`~ISO-2022-JP~decoderå‡ºåŠ›~çŠ¶æ…‹@ï¼ˆåˆæœŸ~æ™‚ `ASCII$i ï¼‰~BR
`~ISO-2022-JP~lead@ï¼ˆåˆæœŸ~æ™‚ `00^X ï¼‰~BR
`~ISO-2022-JPå‡ºåŠ›~flag@ï¼ˆåˆæœŸ~æ™‚ ~OFF ï¼‰
â—
ISO-2022-JPâ€™s decoder has an associated ISO-2022-JP decoder state (initially ASCII), ISO-2022-JP decoder output state (initially ASCII), ISO-2022-JP lead (initially 0x00), and ISO-2022-JP output flag (initially unset).
</p>

<p>
`ISO-2022-JP$n ã®`~decoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œ`~ISO-2022-JP~decoderçŠ¶æ…‹$ã«å¿œã˜ã¦ æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
ISO-2022-JPâ€™s decoderâ€™s handler, given a stream and byte, runs these steps, switching on ISO-2022-JP decoder state:
</p>

<dl class="switch">
	<dt>`ASCII@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>

		<dl class="switch">
			<dt>`1B^X</dt>
			<dd>
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ~BR
~RET `ç¶™ç¶š$
â—
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

			<dt>`~ASCII~byte$ â€” ãŸã ã—ï¼Œ `0E^X, `0F^X, `1B^X ã¯é™¤ã</dt>
			<dd>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
~RET ~cp [ %~byte ]
â—
Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</dd>

			<dt>`~EoS$</dt>
			<dd>
~RET `å®Œé‚$
â—
Return finished.
</dd>

			<dt>~OTHER</dt>
			<dd>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
~RET `~error$
â—
Unset the ISO-2022-JP output flag and return error.
</dd>
		</dl>
	</dd>

	<dt>`Roman@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>

		<dl class="switch">
			<dt>`1B^X</dt>
			<dd>
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ~BR
~RET `ç¶™ç¶š$
â—
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

			<dt>`5C^X</dt>
			<dd>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
~RET ~cp [ `00A5^U ]
â—
Unset the ISO-2022-JP output flag and return code point U+00A5.
</dd>

			<dt>`7E^X</dt>
			<dd>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
~RET ~cp [ `203E^U ]
â—
Unset the ISO-2022-JP output flag and return code point U+203E.
</dd>

			<dt>`~ASCII~byte$ â€” ãŸã ã—ï¼Œ `0E^X, `0F^X, `1B^X, `5C^X, `7E^X ã¯é™¤ã</dt>
			<dd>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
~RET a ~cp [ %~byte ]
â—
Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</dd>

			<dt>`~EoS$</dt>
			<dd>
~RET `å®Œé‚$
â—
Return finished.
</dd>

			<dt>~OTHER</dt>
			<dd>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
~RET `~error$
â—
Unset the ISO-2022-JP output flag and return error.
</dd>
		</dl>
	</dd>

	<dt>`katakana@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>

		<dl class="switch">
			<dt>`1B^X</dt>
			<dd>
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ~BR
~RET `ç¶™ç¶š$
â—
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

			<dt>`21^X ã€œ `5F^X</dt>
			<dd>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
~RET ~cp [ `FF61^X ~MINUS `21^X ~PLUS %~byte ]
<!-- katakana; subtraction is done first to avoid upsetting compilers -->
â—
Unset the ISO-2022-JP output flag and return a code point whose value is 0xFF61 âˆ’ 0x21 + byte.
</dd>

			<dt>`~EoS$</dt>
			<dd>
~RET `å®Œé‚$
â—
Return finished.
</dd>

			<dt>~OTHER</dt>
			<dd>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
~RET `~error$
â—
Unset the ISO-2022-JP output flag and return error.
</dd>
		</dl>
	</dd>

	<dt>`~lead~byte@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>

		<dl class="switch">
			<dt>`1B^X</dt>
			<dd>
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ~BR
~RET `ç¶™ç¶š$
â—
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

			<dt>`21^X ã€œ `7E^X</dt>
			<dd>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
`~ISO-2022-JP~lead$ ~SET %~byte ~BR
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~trail~byte$i ~BR
~RET `ç¶™ç¶š$
â—
Unset the ISO-2022-JP output flag, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to trail byte, and return continue.
</dd>

			<dt>`~EoS$</dt>
			<dd>
~RET `å®Œé‚$
â—
Return finished.
</dd>

			<dt>~OTHER</dt>
			<dd>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
~RET `~error$
â—
Unset the ISO-2022-JP output flag and return error.
</dd>
		</dl>
	</dd>

	<dt>`~trail~byte@i</dt>
	<dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>

		<dl class="switch">
			<dt>`1B^X</dt>
			<dd>
<p>
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~escapeé–‹å§‹$i ~BR
~RET `~error$
<!-- iso-2022-jp decoder output state is still lead byte -->
â—
Set ISO-2022-JP decoder state to escape start and return error.
</p>

			</dd><dt>`21^X ã€œ `7E^X</dt>
			<dd>
				<ol>
					<li>
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~lead~byte$i
â—
Set the ISO-2022-JP decoder state to lead byte.
</li>
					<li>
%pointer ~LET ( `~ISO-2022-JP~lead$ ~MINUS `21^X ) ~MUL 94 ~PLUS %~byte ~MINUS `21^X
â—
Let pointer be (ISO-2022-JP lead âˆ’ 0x21) Ã— 94 + byte âˆ’ 0x21.
</li>
					<li>
%~cp ~LET
`ç´¢å¼•~jis0208$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
â—
Let code point be the index code point for pointer in index jis0208.
</li>
					<li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET `~error$
â—
If code point is null, return error.
</li>
					<li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
				</ol>
			</dd>

			<dt>`~EoS$</dt>
			<dd>
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~lead~byte$i ~BR
%~byte ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$ ~BR
~RET `~error$
â—
Set the ISO-2022-JP decoder state to lead byte, prepend byte to stream, and return error.
</dd>

			<dt>~OTHER</dt>
			<dd>
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~lead~byte$i ~BR
~RET `~error$
<!-- iso-2022-jp decoder output state is still lead byte -->
â—
Set ISO-2022-JP decoder state to lead byte and return error.
</dd>
		</dl>
	</dd>

	<dt>`~escapeé–‹å§‹@i</dt>
	<dd>
		<ol>
			<li>
~IFï¼»
%~byte ~IN { `24^X<!--ï¼„-->, `28^X<!--(--> }
ï¼½
â‡’
`~ISO-2022-JP~lead$ ~SET %~byte ~BR
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~escape$i ~BR
~RET `ç¶™ç¶š$
â—
If byte is either 0x24 or 0x28, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to escape, and return continue.
</li>
			<li>
%~byte ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend byte to stream.
</li>
			<li>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~ISO-2022-JP~decoderå‡ºåŠ›~çŠ¶æ…‹$ ~BR
~RET `~error$
â—
Unset the ISO-2022-JP output flag, set ISO-2022-JP decoder state to ISO-2022-JP decoder output state, and return error.
</li>
		</ol>
	</dd>

	<dt>`~escape@i</dt>
	<dd>
		<ol>
			<li>
%~lead ~LET `~ISO-2022-JP~lead$ ~BR
`~ISO-2022-JP~lead$ ~SET `00^X
â—
Let lead be ISO-2022-JP lead and set ISO-2022-JP lead to 0x00.
</li>
			<li>
%çŠ¶æ…‹ ~LET ~NULL
â—
Let state be null.
</li>
			<li>
~IFï¼»
%~lead ~EQ `28^X
ï¼½~ANDï¼»
%~byte ~EQ `42^X<!--B-->
ï¼½
â‡’
%çŠ¶æ…‹ ~SET `ASCII$i
â—
If lead is 0x28 and byte is 0x42, set state to ASCII.
</li>
			<li>
~IFï¼»
%~lead ~EQ `28^X
ï¼½~ANDï¼»
%~byte ~EQ `4A^X<!--J-->
ï¼½
â‡’
%çŠ¶æ…‹ ~SET `Roman$i1
â—
If lead is 0x28 and byte is 0x4A, set state to Roman.
</li>
			<li>
~IFï¼»
%~lead ~EQ `28^X
ï¼½~ANDï¼»
%~byte ~EQ `49^X<!--I-->
ï¼½
â‡’
%çŠ¶æ…‹ ~SET `katakana$i
â—
If lead is 0x28 and byte is 0x49, set state to katakana.
</li>
			<li>
~IFï¼»
%~lead ~EQ `24^X
ï¼½~ANDï¼»
%~byte ~IN { `40^X<!--ï¼ -->, `42^X<!--B--> }
ï¼½
â‡’
%çŠ¶æ…‹ ~SET `~lead~byte$i
â—
If lead is 0x24 and byte is either 0x40 or 0x42, set state to lead byte.
</li>
			<li>
<p>
~IFï¼»
%çŠ¶æ…‹ ~NEQ ~NULL
ï¼½ï¼š
â—
If state is non-null, then:
</p>

				<ol>
					<li>
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET %çŠ¶æ…‹ ~BR
`~ISO-2022-JP~decoderå‡ºåŠ›~çŠ¶æ…‹$ ~SET %çŠ¶æ…‹
â—
Set ISO-2022-JP decoder state and ISO-2022-JP decoder output state to state.
</li>
					<li>
%å‡ºåŠ›~flag ~LET `~ISO-2022-JPå‡ºåŠ›~flag$
â—
Let output flag be the ISO-2022-JP output flag.
</li>
					<li>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~ON
â—
Set the ISO-2022-JP output flag.
</li>
					<li>
~RET ï¼»
%å‡ºåŠ›~flag ~EQ ~OFF ãªã‚‰ã° `ç¶™ç¶š$ ï¼
~ELSE_ `~error$
ï¼½
â—
Return continue, if output flag is unset, and error otherwise.
</li>
				</ol>
			</li>
			<li>
~byteåˆ— [ %~lead, %~byte ] ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend lead and byte to stream.
</li>
			<li>
`~ISO-2022-JPå‡ºåŠ›~flag$ ~SET ~OFF ~BR
`~ISO-2022-JP~decoderçŠ¶æ…‹$ ~SET `~ISO-2022-JP~decoderå‡ºåŠ›~çŠ¶æ…‹$ ~BR
~RET `~error$
â—
Unset the ISO-2022-JP output flag, set ISO-2022-JP decoder state to ISO-2022-JP decoder output state and return error.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="iso-2022-jp-encoder">
<h4 title="ISO-2022-JP encoder">12.2.2. ~ISO-2022-JP~encoder</h4>

<p>
`ISO-2022-JP$n ã®`~encoder$ã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~ISO-2022-JP~encoderçŠ¶æ…‹@
â€” ã“ã‚Œã¯ï¼Œï¼»
`ASCII@i1 ï¼
`Roman@i1 ï¼
`jis0208@i1
ï¼½ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚Šå¾—ã‚‹ï¼ˆåˆæœŸ~æ™‚ `ASCII$i1 ï¼‰ã€‚
â—
ISO-2022-JPâ€™s encoder has an associated ISO-2022-JP encoder state which is ASCII, Roman, or jis0208 (initially ASCII).
</p>

<p>
`ISO-2022-JP$n ã®`~encoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
ISO-2022-JPâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
<p>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>

		<ol>
			<li>
~IFï¼»
`~ISO-2022-JP~encoderçŠ¶æ…‹$ ~NEQ `ASCII$i1
ï¼½
â‡’
%~cp ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$ ~BR
`~ISO-2022-JP~encoderçŠ¶æ…‹$ ~SET `ASCII$i1 ~BR
~RET ~byteåˆ— [ `1B^X, `28^X, `42^X ]
â—
If code point is end-of-stream and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
			<li>
~RET `å®Œé‚$
â—
If code point is end-of-stream and ISO-2022-JP encoder state is ASCII, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~ISO-2022-JP~encoderçŠ¶æ…‹$ ~IN
{ `ASCII$i1, `Roman$i1 }
ï¼½~ANDï¼»
%~cp ~IN { `000E^U, `000F^U, `001B^U }
ï¼½
â‡’
~RET `FFFD^U ã‚’ä¼´ã†`~error$
â—
If ISO-2022-JP encoder state is ASCII or Roman, and code point is U+000E, U+000F, or U+001B, return error with U+FFFD.
</p>

<p class="note">
æ”»æ’ƒã‚’é˜²ããŸã‚ã€ã“ã‚Œã¯ %~cp ã§ã¯ãªãï¼Œ `FFFD^U ã‚’è¿”ã™ã€‚
â—
This returns U+FFFD rather than code point to prevent attacks.
</p>
<!-- https://github.com/whatwg/encoding/issues/15 -->
	</li>
	<li>
~IFï¼»
`~ISO-2022-JP~encoderçŠ¶æ…‹$ ~EQ `ASCII$i1
ï¼½~ANDï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If ISO-2022-JP encoder state is ASCII and code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
~IFï¼»
`~ISO-2022-JP~encoderçŠ¶æ…‹$ ~EQ `Roman$i1
ï¼½
â‡’
%~cp ã«å¿œã˜ã¦ï¼š
â—
If ISO-2022-JP encoder state is Roman and code point is an ASCII code point, excluding U+005C and U+007E, or is U+00A5 or U+203E, then:
</p>

		<dl class="switch">
			<dt>`~ASCII~cp$ â€” ãŸã ã—ï¼Œ `005C^U, `007E^U ã¯é™¤å¤–ã™ã‚‹</dt>
			<dd>
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

			<dt>`00A5^U</dt>
			<dd>
~RET ~byteåˆ— [ `5C^X ]
â—
If code point is U+00A5, return byte 0x5C.
</dd>

			<dt>`203E^U</dt>
			<dd>
~RET ~byteåˆ— [ `7E^X ]
â—
If code point is U+203E, return byte 0x7E.
</dd>

			<dt>~OTHER</dt>
			<dd>ä½•ã‚‚ã—ãªã„</dd>
		</dl>
	</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½~ANDï¼»
`~ISO-2022-JP~encoderçŠ¶æ…‹$ ~NEQ `ASCII$i1
ï¼½
â‡’
%~cp ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$ ~BR
`~ISO-2022-JP~encoderçŠ¶æ…‹$ ~SET `ASCII$i1 ~BR
~RET ~byteåˆ— [ `1B^X, `28^X, `42^X ]
â—
If code point is an ASCII code point, and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
	<li>
~IFï¼»
%~cp ~NIN { `00A5^U, `203E^U }
ï¼½~ANDï¼»
`~ISO-2022-JP~encoderçŠ¶æ…‹$ ~NEQ `Roman$i1
ï¼½
â‡’
%~cp ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$ ~BR
`~ISO-2022-JP~encoderçŠ¶æ…‹$ ~SET `Roman$i1 ~BR
~RET ~byteåˆ— [ `1B^X, `28^X, `4A^X ]
â—
If code point is either U+00A5 or U+203E, and ISO-2022-JP encoder state is not Roman, prepend code point to stream, set ISO-2022-JP encoder state to Roman, and return three bytes 0x1B 0x28 0x4A.
</li>
	<li>
~IFï¼»
%~cp ~EQ `2212^U
ï¼½
â‡’
%~cp ~SET `FF0D^U
â—
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
~IFï¼»
%~cp ~IN { `FF61^U ã€œ `FF9F^U }
ï¼½
â‡’
%~cp ~SET `ç´¢å¼•~ISO-2022-JP~katakana$ã®ä¸­ã§
( %~cp ~MINUS `FF61^X )
ãŒæŒ‡ã™`ç´¢å¼•~cp$ 
â—
If code point is in the range U+FF61 to U+FF9F, inclusive, set it to the index code point for code point âˆ’ 0xFF61 in index ISO-2022-JP katakana.
</li>
	<li>
<p>
%~pointer ~LET `ç´¢å¼•~jis0208$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for code point in index jis0208.
</p>

<p class="note">æ³¨è¨˜ï¼š
%~pointer ã¯ã€ ~NULL ã§ãªã‘ã‚Œã°ï¼Œ`ç´¢å¼•~jis0208$ã¨~pointeræ¼”ç®—ã®è³‡è³ªã«å› ã‚Š 8836 æœªæº€ã«ãªã‚‹ã€‚
â—
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
~IFï¼»
`~ISO-2022-JP~encoderçŠ¶æ…‹$ ~NEQ `jis0208$i1
ï¼½
â‡’
%~cp ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$ ~BR
`~ISO-2022-JP~encoderçŠ¶æ…‹$ ~SET `jis0208$i1 ~BR
~RET ~byteåˆ— [ `1B^X, `24^X, `42^X ]
â—
If ISO-2022-JP encoder state is not jis0208, prepend code point to stream, set ISO-2022-JP encoder state to jis0208, and return three bytes 0x1B 0x24 0x42.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `21^X
â—
Let lead be pointer / 94 + 0x21.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `21^X
â—
Let trail be pointer % 94 + 0x21.
</li>
	<li>
~RET ~byteåˆ— [ %~lead, %~trail ]
â—
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="shift_jis">

<h3 title="Shift_JIS">12.3. ~Shift_JIS</h3>


			<section id="shift_jis-decoder">
<h4 title="Shift_JIS decoder">12.3.1. ~Shift_JIS~decoder</h4>


<p>
`Shift_JIS$n ã®`~decoder$ã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~Shift_JIS~lead@ï¼ˆåˆæœŸ~æ™‚ `00^X ï¼‰
â—
Shift_JISâ€™s decoder has an associated Shift_JIS lead (initially 0x00).
</p>

<p>
`Shift_JIS$n ã®`~decoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Shift_JISâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>

		<ol>
			<li>
~IFï¼»
`~Shift_JIS~lead$ ~NEQ `00^X
ï¼½
â‡’
`~Shift_JIS~lead$ ~SET `00^X ~BR
~RET `~error$
â—
If byte is end-of-stream and Shift_JIS lead is not 0x00, set Shift_JIS lead to 0x00 and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚$
â—
If byte is end-of-stream and Shift_JIS lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~Shift_JIS~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead, let pointer be null, set Shift_JIS lead to 0x00, and then:
</p>

		<ol>
			<li>
%~lead ~LET `~Shift_JIS~lead$ ~BR
%~pointer ~LET ~NULL ~BR
`~Shift_JIS~lead$ ~SET `00^X
â—
â†‘</li>
			<li>
%~offset ~LET ï¼»
%~byte ~IN { `00^X ã€œ `7E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40, if byte is less than 0x7F, and 0x41 otherwise.
</li>
			<li>
%~lead~offset ~LET ï¼»
%~lead ~IN { `00^X ã€œ `BF^X } ãªã‚‰ã° `81^X ï¼
~ELSE_ `C1^X
ï¼½
â—
Let lead offset be 0x81, if lead is less than 0xA0, and 0xC1 otherwise.
</li>
			<li>
~IFï¼»
%~byte ~IN { `40^X ã€œ `7E^X, `80^X ã€œ `FC^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS %~lead~offset ) ~MUL 188 ~PLUS %~byte ~MINUS %~offset
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFC, inclusive, set pointer to (lead âˆ’ lead offset) Ã— 188 + byte âˆ’ offset.
</li>
			<li>
<p>
~IFï¼»
%~pointer ~IN { 8836 ã€œ 10715 }
ï¼½
â‡’
~RET ~cp [ `E000^X ~MINUS 8836 ~PLUS %~pointer ]
<!-- subtraction is done first to avoid upsetting compilers -->
â—
If pointer is in the range 8836 to 10715, inclusive, return a code point whose value is 0xE000 âˆ’ 8836 + pointer.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ EUDC ã¨ã—ã¦å‘¨çŸ¥ã®ï¼Œæ—§æ¥ã® Windows ã«ã‚ˆã‚‹ã‚‚ã®ã¨ç›¸äº’é‹ç”¨å¯èƒ½ã«ã™ã‚‹ã€‚
<!-- PUA -->
â—
This is interoperable legacy from Windows known as EUDC.
</p>

<p class="trans-note">ã€
EUDC â€” ã„ã‚ã‚†ã‚‹å¤–å­—ã®ãŸã‚ã®æ©Ÿèƒ½ã€‚
ã€‘ã€
8836 = 94 ~MUL 94 ã¯~Shift_JISï¼ˆ JIS X 0208 ï¼‰ã®
`<a href="https://ja.wikipedia.org/wiki/%E5%8C%BA%E7%82%B9%E7%95%AA%E5%8F%B7">åŒºç‚¹ç•ªå·</a>^_
ã®ç·æ•°ã€‚
çµæœã®~cpã¯~Unicodeç§ç”¨é ˜åŸŸã«å…¥ã‚‹ã€‚
ã€‘</p>

			</li>
			<li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ `ç´¢å¼•~jis0208$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
ï¼½
â—
Let code point be null, if pointer is null, and the index code point for pointer in index jis0208 otherwise.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp [ %~cp ]
â—
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
%~byte ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN { `~ASCII~byte$, `80^X}
ï¼½
â‡’
~RET ~cp [ %~byte ]
<!-- Opera has 0x7E -->
â—
If byte is an ASCII byte or 0x80, return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `A1^X ã€œ `DF^X }
ï¼½
â‡’
~RET ~cp [ `FF61^X ~PLUS ( %~byte ~MINUS `A1^X ) ]
<!-- katakana; subtraction is done first to avoid upsetting compilers -->
â—
If byte is in the range 0xA1 to 0xDF, inclusive, return a code point whose value is 0xFF61 âˆ’ 0xA1 + byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `9F^X, `E0^X ã€œ `FC^X }
ï¼½
â‡’
`~Shift_JIS~lead$ ~SET %~byte ~BR
~RET `ç¶™ç¶š$
â—
If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0 to 0xFC, inclusive, set Shift_JIS lead to byte and return continue.
</li>
	<li>
~RET `~error$
â—
Return error.
</li>
</ol>

			</section>
			<section id="shift_jis-encoder">
<h4 title="Shift_JIS encoder">12.3.2. ~Shift_JIS~encoder</h4>

<p>
`Shift_JIS$n ã®`~encoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Shift_JISâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
<p>
%~cp ã«å¿œã˜ã¦ï¼š
â—
â†“</p>
		<dl class="switch">
			<dt>`~EoS$</dt>
			<dd>
~RET `å®Œé‚$
â—
If code point is end-of-stream, return finished.
</dd>

			<dt>`~ASCII~cp$</dt>
			<dt>`0080^U</dt>
			<dd>
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point or U+0080, return a byte whose value is code point.
</dd>

			<dt>`00A5^U</dt>
			<dd>
~RET ~byteåˆ— [ `5C^X ]
â—
If code point is U+00A5, return byte 0x5C.
</dd>

			<dt>`203E^U</dt>
			<dd>
~RET ~byteåˆ— [ `7E^X ]
â—
If code point is U+203E, return byte 0x7E.
</dd>

			<dt>`FF61^U ã€œ `FF9F^U</dt>
			<dd>
~RET ~byteåˆ— [ ( %~cp ~MINUS `FF61^X ) ~PLUS `A1^X ]
â—
If code point is in the range U+FF61 to U+FF9F, inclusive, return a byte whose value is code point âˆ’ 0xFF61 + 0xA1.
</dd>

			<dt>~OTHER</dt>
			<dd>ä½•ã‚‚ã—ãªã„</dd>
		</dl>
	</li>
	<li>
~IFï¼»
%~cp ~EQ `2212^U
ï¼½
â‡’
%~cp ~SET `FF0D^U
â—
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
%~pointer ~LET
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~Shift_JIS~pointer$
â—
Let pointer be the index Shift_JIS pointer for code point.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 188 )
â—
Let lead be pointer / 188.
</li>
	<li>
%~lead~offset ~LET ï¼»
%~lead ~IN { `00^X ã€œ `1E^X } ãªã‚‰ã° `81^X ï¼
~ELSE_ `C1^X<!-- 0xA0-0x81 -->
ï¼½
â—
Let lead offset be 0x81, if lead is less than 0x1F, and 0xC1 otherwise.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 188
â—
Let trail be pointer % 188.
</li>
	<li>
%~offset ~LET ï¼»
%~trail ~IN { `00^X ã€œ `3E^X } ãªã‚‰ã° `40^X ï¼
~ELSE_ `41^X
ï¼½
â—
Let offset be 0x40, if trail is less than 0x3F, and 0x41 otherwise.
</li>
	<li>
~RET ~byteåˆ— [ ( %~lead ~PLUS %~lead~offset ), ( %~trail ~PLUS %~offset ) ]
â—
Return two bytes whose values are lead + lead offset and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-korean-encodings">

<h2 title="Legacy multi-byte Korean encodings">13. æ—§æ¥ã®è¤‡byte Korean ~encoding</h2>


		<section id="euc-kr">

<h3 title="EUC-KR">13.1. ~EUC-KR</h3>

			<section id="euc-kr-decoder">
<h4 title="EUC-KR decoder">13.1.1. ~EUC-KR~decoder</h4>

<p>
`EUC-KR$n ã®`~decoder$ã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~EUC-KR~lead@ï¼ˆåˆæœŸ~æ™‚ `00^X ï¼‰
â—
EUC-KRâ€™s decoder has an associated EUC-KR lead (initially 0x00).
</p>

<p>
`EUC-KR$n ã®`~decoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-KRâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>

		<ol>
			<li>
~IFï¼»
`~EUC-KR~lead$ ~NEQ `00^X
ï¼½
â‡’
`~EUC-KR~lead$ ~SET `00^X ~BR
~RET `~error$
â—
If byte is end-of-stream and EUC-KR lead is not 0x00, set EUC-KR lead to 0x00 and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚$
â—
If byte is end-of-stream and EUC-KR lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
`~EUC-KR~lead$ ~NEQ `00^X
ï¼½ï¼š
â—
If EUC-KR lead is not 0x00, let lead be EUC-KR lead, let pointer be null, set EUC-KR lead to 0x00, and then:
</p>

		<ol>
			<li>
%~lead ~LET `~EUC-KR~lead$ ~BR
%~pointer ~LET ~NULL ~BR
`~EUC-KR~lead$ ~SET `00^X
â—
â†‘</li>
			<li>
~IFï¼»
%~byte ~IN { `41^X ã€œ `FE^X }
ï¼½
â‡’
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS `41^X )
â—
If byte is in the range 0x41 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 190 + (byte âˆ’ 0x41).
</li>
			<li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ `ç´¢å¼•~EUC-KR$ ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™`ç´¢å¼•~cp$
ï¼½
â—
Let code point be null, if pointer is null, and the index code point for pointer in index EUC-KR otherwise.
</li>
			<li>
~IFï¼»
%~cp ~NEQ ~NULL
ï¼½
â‡’
~RET ~cp [ %~cp ]
â—
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
%~byte ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
â—
Return error.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~byte ~IN `~ASCII~byte$
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IFï¼»
%~byte ~IN { `81^X ã€œ `FE^X }
ï¼½
â‡’
`~EUC-KR~lead$ ~SET %~byte ~BR
~RET `ç¶™ç¶š$
â—
If byte is in the range 0x81 to 0xFE, inclusive, set EUC-KR lead to byte and return continue.
</li>
	<li>
~RET `~error$
â—
Return error.
</li>
</ol>

			</section>
			<section id="euc-kr-encoder">
<h4 title="EUC-KR encoder">13.1.2. ~EUC-KR~encoder</h4>

<p>
`EUC-KR$n ã®`~encoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-KRâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IFï¼»
%~cp ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚$
â—
If code point is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
%~cp ~IN `~ASCII~cp$
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET
`ç´¢å¼•~EUC-KR$ ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™`ç´¢å¼•~pointer$
â—
Let pointer be the index pointer for code point in index EUC-KR.
</li>
	<li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†`~error$
â—
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
â—
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET ( %~pointer ~MOD 190 ) ~PLUS `41^X
â—
Let trail be pointer % 190 + 0x41.
</li>
	<li>
~RET ~byteåˆ— [ %~lead, %~trail ]
â—
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>

<!-- removed from the spec 20130823
13.2 iso-2022-kr id="iso-2022-kr"
-->

	</section>
	<section id="legacy-miscellaneous-encodings">

<h2 title="Legacy miscellaneous encodings">14. ãã®ä»–ã®æ—§æ¥ã®~encoding</h2>

		<section id="replacement">
<h3 title="replacement">14.1. ~replacement</h3>

<p class="note">æ³¨è¨˜ï¼š
`replacement$n `~encoding$ã¯ã€~serverã¨~clientã«ãŠã‘ã‚‹ `~encoding$ã®~supportã®ä¸ä¸€è‡´ã‚’çªãï¼Œã‚ã‚‹ç¨®ã®æ”»æ’ƒã‚’é˜²ããŸã‚ã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
â—
The replacement encoding exists to prevent certain attacks that abuse a mismatch between encodings supported on the server and the client.
</p>

			<section id="replacement-decoder">
<h4 title="replacement decoder">14.1.1. ~replacement~decoder</h4>

<p>
`replacement$n ã®`~decoder$ã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~replacementã«ã‚ˆã‚‹~errorã¯ã™ã§ã«è¿”ã—ãŸ~flag@ï¼ˆåˆæœŸ~æ™‚ ~OFF ï¼‰
â—
replacementâ€™s decoder has an associated replacement error returned flag (initially unset).
</p>

<p>
`replacement$n ã®`~decoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
replacementâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½
â‡’
~RET `å®Œé‚$
â—
If byte is end-of-stream, return finished.
</li>
	<li>
~IFï¼»
`~replacementã«ã‚ˆã‚‹~errorã¯ã™ã§ã«è¿”ã—ãŸ~flag$ ~EQ ~OFF
ï¼½
â‡’
`~replacementã«ã‚ˆã‚‹~errorã¯ã™ã§ã«è¿”ã—ãŸ~flag$ ~SET ~ON ~BR
~RET `~error$
â—
If replacement error returned flag is unset, set the replacement error returned flag and return error.
</li>
	<li>
~RET `å®Œé‚$
â—
Return finished.
</li>
</ol>

<p class="trans-note">ã€
`replacement$n ã«ã¯ã€`~encoder$ã¯ãªã„ã€‚
ã€‘</p>


			</section>
		</section>
		<section id="common-infrastructure-for-utf-16be-and-utf-16le">

<h3 title="Common infrastructure for UTF-16BE and UTF-16LE">14.2. ~UTF-16BEã¨~UTF-16LEã«å…±é€šã®åŸºç›¤</h3>

			<section id="shared-utf-16-decoder">
<h4 title="shared UTF-16 decoder">14.2.1. å…±ç”¨~UTF-16~decoder</h4>

<p class="note">æ³¨è¨˜ï¼š
~BOMï¼ˆ byte order mark, â€œãƒã‚¤ãƒˆé †ãƒãƒ¼ã‚¯â€ ï¼‰ã¯`~label$ã‚ˆã‚Šå„ªå…ˆã•ã‚Œã‚‹ã€‚
ãã‚Œã¯ï¼Œé…å‚™æ¸ˆã¿ã®å†…å®¹ã«ãŠã„ã¦ã€ã©ã®`~label$ã‚ˆã‚Šã‚‚æ­£ç¢ºaã§ã‚ã‚‹ã“ã¨ãŒè¦‹å‡ºã•ã‚Œã¦ã„ã‚‹ã®ã§ã€‚
ã—ãŸãŒã£ã¦ ãã‚Œã¯ã€`å…±ç”¨~UTF-16~decoder$ã®ä¸€éƒ¨ã§ã¯ãªãï¼Œ`~decode$ ~algoã®ä¸€éƒ¨ã«ãªã‚‹ã€‚
â—
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the shared UTF-16 decoder algorithm but rather the decode algorithm.
</p>

<p>
`å…±ç”¨~UTF-16~decoder$ã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
`~UTF-16~lead~byte@ï¼ˆåˆæœŸ~æ™‚ ~NULL ï¼‰~BR
`~UTF-16~lead~surrogate@ï¼ˆåˆæœŸ~æ™‚ ~NULL ï¼‰~BR
`~UTF-16BE~decoder~flag@ï¼ˆåˆæœŸ~æ™‚ ~OFF ï¼‰
â—
shared UTF-16 decoder has an associated UTF-16 lead byte and UTF-16 lead surrogate (both initially null), and UTF-16BE decoder flag (initially unset).
</p>

<p>
`å…±ç”¨~UTF-16~decoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
shared UTF-16 decoderâ€™s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IFï¼»
%~byte ~EQ `~EoS$
ï¼½ï¼š
â—
â†“</p>

		<ol>
			<li>
~IFï¼»
`~UTF-16~lead~byte$ ~NEQ ~NULL
ï¼½~ORï¼»
`~UTF-16~lead~surrogate$ ~NEQ ~NULL
ï¼½
â‡’
( `~UTF-16~lead~byte$, `~UTF-16~lead~surrogate$ ) ~SET ( ~NULL, ~NULL ) ~BR
~RET `~error$
â—
If byte is end-of-stream and either UTF-16 lead byte or UTF-16 lead surrogate is non-null, set UTF-16 lead byte and UTF-16 lead surrogate to null, and return error.
</li>
			<li>
~ELSE
â‡’
~RET `å®Œé‚$
â—
If byte is end-of-stream and UTF-16 lead byte and UTF-16 lead surrogate are null, return finished.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
`~UTF-16~lead~byte$ ~EQ ~NULL
ï¼½
â‡’
`~UTF-16~lead~byte$ ~SET %~byte ~BR
~RET `ç¶™ç¶š$
â—
If UTF-16 lead byte is null, set UTF-16 lead byte to byte and return continue.
</li>
	<li>
<p>
%~cu ~LET `~UTF-16BE~decoder~flag$ã«å¿œã˜ã¦ï¼Œæ¬¡ã§ä¸ãˆã‚‰ã‚Œã‚‹å€¤ï¼š
â—
Let code unit be the result of:
</p>
		<dl class="switch">
			<dt>~ONâ—UTF-16BE decoder flag is set</dt>
			<dd>
( `~UTF-16~lead~byte$ ~Lshift 8 ) ~PLUS %~byte
â—
(UTF-16 lead byte &lt;&lt; 8) + byte.
</dd>
			<dt>~OFFâ—UTF-16BE decoder flag is unset</dt>
			<dd>
( %~byte ~Lshift 8 ) ~PLUS `~UTF-16~lead~byte$
â—
(byte &lt;&lt; 8) + UTF-16 lead byte.
</dd>
		</dl>
	</li>
	<li>
`~UTF-16~lead~byte$ ~SET ~NULL
â—
Then set UTF-16 lead byte to null.
</li>
	<li>
<p>
~IFï¼»
`~UTF-16~lead~surrogate$ ~NEQ ~NULL
ï¼½ï¼š
â—
If UTF-16 lead surrogate is non-null, let lead surrogate be UTF-16 lead surrogate, set UTF-16 lead surrogate to null, and then:
</p>

		<ol>
			<li>
%~lead~surrogate ~LET `~UTF-16~lead~surrogate$ ~BR
`~UTF-16~lead~surrogate$ ~SET ~NULL
â—
â†‘</li>
			<li>
~IFï¼»
%~cu ~IN { `DC00^U ã€œ `DFFF^U }
ï¼½
â‡’
~RET ~cp [
`10000^X ~PLUS ( ( %~lead~surrogate ~MINUS `D800^X ) ~Lshift 10 ) ~PLUS ( %~cu ~MINUS `DC00^X )
]
â—
If code unit is in the range U+DC00 to U+DFFF, inclusive, return a code point whose value is 0x10000 + ((lead surrogate âˆ’ 0xD800) &lt;&lt; 10) + (code unit âˆ’ 0xDC00).
</li>
			<li>
%byte1 ~LET %~cu ~Rshift 8
â—
Let byte1 be code unit &gt;&gt; 8.
</li>
			<li>
%byte2 ~LET %~cu ~bAND `00FF^X
â—
Let byte2 be code unit &amp; 0x00FF.
</li>
			<li>
%~byteåˆ— ~LET %~utf-16be~flag ã«å¿œã˜ã¦ï¼»
~ON ãªã‚‰ã° ~byteåˆ— [ %byte1, %byte2 ] ï¼
~OFF ãªã‚‰ã° ~byteåˆ— [ %byte2, %byte1 ]
ï¼½
â—
Let bytes be two bytes whose values are byte1 and byte2, if the UTF-16BE decoder flag is set, and byte2 and byte1 otherwise.
</li>
			<li>
%~byteåˆ— ã‚’ %~stream ã«`å‰ä»˜åŠ ã™ã‚‹$
â—
Prepend the bytes to stream and return error.
</li>
			<li>
~RET `~error$
â—
â†‘</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~cu ~IN { `D800^U ã€œ `DBFF^U }
ï¼½
â‡’
`~UTF-16~lead~surrogate$ ~SET %~cu ~BR
~RET `ç¶™ç¶š$
â—
If code unit is in the range U+D800 to U+DBFF, inclusive, set UTF-16 lead surrogate to code unit and return continue.
</li>
	<li>
~IFï¼»
%~cu ~IN { `DC00^U ã€œ `DFFF^U }
ï¼½
â‡’
~RET `~error$
<!-- unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them -->
â—
If code unit is in the range U+DC00 to U+DFFF, inclusive, return error.
</li>
	<li>
~RET ~cp [ %~cu ]
â—
Return code point code unit.
</li>
</ol>


			</section>
		</section>
		<section id="utf-16be">

<h3 title="UTF-16BE">14.3. ~UTF-16BE</h3>


			<section id="utf-16be-decoder">
<h4 title="UTF-16BE decoder">14.3.1. ~UTF-16BE~decoder</h4>


<p>
`UTF-16BE$n ã®`~decoder$ã¯ã€ï¼»
`~UTF-16BE~decoder~flag$ ~SET ~ON
ï¼½ã«ã•ã‚ŒãŸ`å…±ç”¨~UTF-16~decoder$ã§ã‚ã‚‹ã€‚
â—
UTF-16BEâ€™s decoder is shared UTF-16 decoder with its UTF-16BE decoder flag set.
</p>


			</section>
		</section>

		<section id="utf-16le">

<h3 title="UTF-16LE">14.4. ~UTF-16LE</h3>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™æ¸ˆã¿ã®å†…å®¹ã«å¯¾å‡¦ã™ã‚‹ãŸã‚ã€ `utf-16^lb, `utf-16le^lb ã®ã„ãšã‚Œã‚‚ `UTF-16LE$n ç”¨ã®`~label$ã«ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
Both "utf-16" and "utf-16le" are labels for UTF-16LE to deal with deployed content.
</p>

			<section id="utf-16le-decoder">
<h4 title="UTF-16LE decoder">14.4.1. ~UTF-16LE~decoder</h4>


<p>
`UTF-16BE$n ã®`~decoder$ã¯ã€`å…±ç”¨~UTF-16~decoder$ã§ã‚ã‚‹ã€‚
â—
UTF-16LEâ€™s decoder is shared UTF-16 decoder.
</p>

			</section>
		</section>

		<section id="x-user-defined">

<h3 title="x-user-defined">14.5. ~x-user-defined</h3>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯æŠ€è¡“çš„ã«ã¯`å˜byte~encoding$ã§ã‚ã‚‹ãŒã€~algoçš„ã«å®Ÿè£…ã—å¾—ã‚‹ã®ã§ï¼Œåˆ¥ã€…ã«å®šç¾©ã•ã‚Œã‚‹ã€‚
â—
While technically this is a single-byte encoding, it is defined separately as it can be implemented algorithmically.
</p>

			<section id="x-user-defined-decoder">
<h4 title="x-user-defined decoder">14.5.1. ~x-user-defined~decoder</h4>

<p>
`x-user-defined$n ã®`~decoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
x-user-definedâ€™s decoderâ€™s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
â†“</p>
		<dl class="switch">
			<dt>`~EoS$</dt>
			<dd>
~RET `å®Œé‚$
â—
If byte is end-of-stream, return finished.
</dd>

			<dt>`~ASCII~byte$</dt>
			<dd>
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</dd>

			<dt>~OTHER</dt>
			<dd>
~RET ~cp [ `F780^X ~PLUS %~byte ~MINUS `80^X ]
â—
Return a code point whose value is 0xF780 + byte âˆ’ 0x80.
</dd>
		</dl>
	</li>
</ol>

			</section>
			<section id="x-user-defined-encoder">
<h4 title="x-user-defined encoder">14.5.2. ~x-user-defined~encoder</h4>

<p>
`x-user-defined$n ã®`~encoder$ã®`~handler$ã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
x-user-definedâ€™s encoderâ€™s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
<p>
%~cp ã«å¿œã˜ã¦ï¼š
â—
â†“</p>
		<dl class="switch">
			<dt>`~EoS$</dt>
			<dd>
~RET `å®Œé‚$
â—
If code point is end-of-stream, return finished.
</dd>

			<dt>`~ASCII~cp$</dt>
			<dd>
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

			<dt>`F780^U ã€œ `F7FF^U</dt>
			<dd>
~RET ~byteåˆ— [ %~cp ~MINUS `F780^X ~PLUS `80^X ]
â—
If code point is in the range U+F780 to U+F7FF, inclusive, return a byte whose value is code point âˆ’ 0xF780 + 0x80.
</dd>

			<dt>~OTHER</dt>
			<dd>
~RET %~cp ã‚’ä¼´ã†`~error$
â—
Return error with code point.
</dd>
		</dl>
	</li>
</ol>

			</section>
		</section>
	</section>
	<section id="browser-ui">

<h2 title="Browser UI">15. ~browser UI</h2>

<p>
~browserã«ã¯ã€è³‡æºã®~encodingã«å¯¾ã™ã‚‹ä¸Šæ›¸ãã‚’å¯èƒ½åŒ–ã•ã›ãªã„ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšï¼Œãã®ç¨®ã®ç‰¹è‰²æ©Ÿèƒ½ãŒåœ¨ã™ã‚‹å ´åˆã€å‰è¿°ã®
<a href="#security-background">ä¿å®‰~ä¸Šã®èª²é¡Œ</a>
ã‹ã‚‰ï¼Œ~browserã¯ï¼Œ `UTF-16BE$nï¼`UTF-16LE$n ã‚’~optionã¨ã—ã¦æä¾›0ã™ã‚‹~SHOULDã§ãªã„ã€‚
~browserã¯ã€è³‡æºãŒ `UTF-16BE$nï¼`UTF-16LE$n ã‚’åˆ©ç”¨ã—ã¦~decodeã•ã‚ŒãŸå ´åˆã§ã‚‚ï¼Œã“ã®ç‰¹è‰²æ©Ÿèƒ½ã‚’ä¸èƒ½åŒ–ã™ã‚‹~SHOULDã§ã‚ã‚‹ã€‚
â—
Browsers are encouraged to not enable overriding the encoding of a resource. If such a feature is nonetheless present, browsers should not offer either UTF-16BE or UTF-16LE as option due to aforementioned security issues. Browsers also should disable this feature if the resource was decoded using either UTF-16BE or UTF-16LE.
</p>

	</section>
	<section id="implementation-considerations">
<h2 title="Implementation considerations">å®Ÿè£…~ä¸Šã®è€ƒæ…®ç‚¹</h2>

<p>
ã“ã®æ¨™æº–ã«ãŠã‘ã‚‹`~encoding$ç”¨ã®`~decoder$ã¯ã€ä»»æ„ã®`å‰ä»˜åŠ -$ã‚’å‚™ãˆã‚‹`~stream$ã‚’~supportã™ã‚‹ä»£ã‚ã‚Šã«ï¼Œæ¬¡ã«ã‚ˆã‚Šå®Ÿè£…ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ï¼š
â—
Instead of supporting streams with arbitrary prepend, the decoders for encodings in this standard could be implemented with:
</p>

<ol>
	<li>
èª­å–ã£ãŸç¾åœ¨ã®~byteã‚’å…ƒã«æˆ»ã™èƒ½ã€‚
â—
The ability to unread the current byte.
</li>
	<li>
`ISO-2022-JP$n ç”¨ã®å˜byteï¼ˆ `24^X ï¼ `28^X ï¼‰~bufferã€‚
â—
â†“</li>
	<li>
<p>
`gb18030$n ç”¨ã®å˜byteï¼ˆ `~ASCII~byte$ ï¼‰~bufferã€‚
â—
A single-byte buffer for gb18030 (an ASCII byte) and ISO-2022-JP (0x24 or 0x28).
</p>

<p class="example" id="example-gb18030-implementation-strategy">
`gb18030$n ã«å¯¾ã—ã¦ã¯ã€ï¼»
`~gb3$ ~NEQ `00^X
ï¼½ã®é–“ã«~~ä¸æ­£ãª~byteã«å‡ºãã‚ã—ãŸã¨ãã¯ã€`~gb2$ã¯ï¼Œæ¬¡ã«è¿”ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹å˜byte~bufferã®ä¸­ã«ç§»å‹•ã§ãã€`~gb3$ãŒ
â€” å˜byte~bufferãŒè¿”ã•ã‚Œã¦ç©ºã«ã•ã‚ŒãŸå¾Œï¼Œ `00^X ã§ãªã„ã“ã¨ãŒæ¤œæŸ»ã•ã‚ŒãŸãªã‚‰ â€”
æ–°ãŸãª`~gb1$ã«ãªã‚‹ã€‚
ã“ã‚Œã¯ã€ `gb18030$n ã«ãŠã‘ã‚‹ 1 å€‹ç›®ã¨ 3 å€‹ç›®ã®~byteç¯„å›²ãŒä¸€è‡´ã™ã‚‹ã®ã§å¯èƒ½ã«ãªã‚‹ã€‚
â—
For gb18030 when hitting a bogus byte while gb18030 third is not 0x00, gb18030 second could be moved into the single-byte buffer to be returned next, and gb18030 third would be the new gb18030 first, checked for not being 0x00 after the single-byte buffer was returned and emptied. This is possible as the range for the first and third byte in gb18030 is identical.
</p>
	</li>
</ol>

<p>
`~ISO-2022-JP~encoder$ã«ã¯ï¼Œè¿½åŠ ã®çŠ¶æ…‹ã¨ã—ã¦`~ISO-2022-JP~encoderçŠ¶æ…‹$ãŒå¿…è¦ã«ãªã‚‹ãŒã€ãã‚Œä»¥å¤–ã§ã¯ï¼Œã“ã®æ¨™æº–ã«ãŠã‘ã‚‹`~encoding$ç”¨ã®ã©ã®`~encoder$ã«ã‚‚ è¿½åŠ ã®çŠ¶æ…‹ã‚„~bufferã¯è¦æ±‚ã•ã‚Œãªã„ã€‚
â—
The ISO-2022-JP encoder needs ISO-2022-JP encoder state as additional state, but other than that, none of the encoders for encodings in this standard require additional state or buffers.
</p>

	</section>
	<section id="acknowledgments">

<h2 title="Acknowledgments">è¬è¾</h2>

<p>
å¹´æœˆã«æ¸¡ã‚Šã€~encodingã‚’ç›¸äº’é‹ç”¨å¯èƒ½ãªã‚‚ã®ã«ã™ã‚‹ãŸã‚ã«ï¼ŒãŸãã•ã‚“ã®æ–¹ã€…ãŒåŠ©åŠ›ã•ã‚Œã€ã“ã®æ¨™æº–ã®ç›®æ¨™ã¸è¿‘ä»˜ã‘ã¦ããŸã€‚
åŒæ§˜ã«å¤šãã®æ–¹ã€…ã®åŠ©åŠ›ãŒï¼Œã“ã®æ¨™æº–ã‚’~~ç¾åœ¨ã®å§¿ã«ä»•ç«‹ã¦ä¸Šã’ã¦ããŸã€‚
ç‰¹ã«ï¼Œæ¬¡ã®æ–¹ã€…ã«æ„Ÿè¬ã™ã‚‹ï¼š
â—
There have been a lot of people that have helped make encodings more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</p>

<div lang="en-x-a0">

<p>
With that, many thanks to

Adam Rice,
Alan Chaney,
Alexander Shtuchkin,
Allen Wirfs-Brock,
Aneesh Agrawal,
Arkadiusz Michalski,
Asmus Freytag,
Ben Noordhuis,
Boris Zbarsky,
Bruno Haible,
Cameron McCormack,
Charles McCathieNeville,
David Carlisle,
Domenic Denicola,
Dominique HazaÃ«l-Massieux,
Doug Ewell,
Erik van der Poel,
<span lang="zh">è­šæ°¸é‹’</span> (Frank Yung-Fong Tang),
Geoffrey Sneddon,
Glenn Maynard,
Gordon P. Hemsley,
Henri Sivonen,
Ian Hickson,
James Graham,
Jeffrey Yasskin,
John Tamplin,
Joshua Bell,
<span lang="ja">æ‘äº•ç´”</span> (Jun Murai),
<span lang="ko">ì‹ ì •ì‹</span> (Jungshik Shin),
Jxck,
<span lang="ko">ê°• ì„±í›ˆ</span> (Kang Seonghoon),
<span lang="ja">å·å¹¡å¤ªä¸€</span> (Kawabata Taichi),
Ken Lunde,
Ken Whistler,
Kenneth Russell,
<span lang="ja">ç”°æ‘å¥äºº</span> (Kent Tamura),
Leif Halvard Silli,
Makoto Kato,
Mark Callow,
Mark Crispin,
Mark Davis,
Martin DÃ¼rst,
Masatoshi Kimura,
Ms2ger,
Nigel Megitt,
Nigel Tao,
Norbert Lindenberg,
Ã˜istein E. Andersen,
Peter Krefting,
Philip JÃ¤genstedt,
Philip Taylor,
Richard Ishida,
Robbert Broersma,
Robert Mustacchi,
Ryan Dahl,
Shawn Steele,
Simon Montagu,
Simon Pieters,
Simon Sapin,
<span lang="ja">å¯ºç”°å¥</span> (Takeshi Terada),
Vyacheslav Matva, and
<span lang="ja">æˆç€¬ã‚†ã„</span> (Yui Naruse)

for being awesome.
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>
).
The <a href="#api">API</a> chapter was initially written by Joshua Bell
(<a href="https://www.google.com/">Google</a>).
</p>

<p>
Per <a href="https://creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>, to the extent possible under law, the editors have waived all copyright and related or neighboring rights to this work.
</p>
</div>

	</section>

</main><!-- id="MAIN" -->

	<section id="section-index">
<h2 title="Index">ç´¢å¼•</h2>
<p class="trans-note">ã€
ã“ã®ç¯€ã®å†…å®¹ã¯çœç•¥ï¼ˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä¸‹ç«¯ã®ç´¢å¼•æ©Ÿèƒ½ã‚’åˆ©ç”¨ã•ã‚ŒãŸã—ï¼‰ã€‚
ã€‘</p>
	</section>
	<section id="references">

<h2 title="References">å‚ç…§æ–‡çŒ®</h2>

		<section id="normative">
<h3 title="Normative References">æ–‡çŒ®ï¼ˆè¦ç¯„ï¼‰</h3>

<script type="text/plain" class="ref_data">

[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[UNICODE]
    The Unicode Standard. URL: http://www.unicode.org/versions/latest/ 
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/ 
</script>

		</section>
		<section id="informative">
<h3 title="Informative References">æ–‡çŒ®ï¼ˆå‚è€ƒï¼‰</h3>

<script type="text/plain" class="ref_data">

[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[XML]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml 
</script>


		</section>
	</section>
</body>


<!--%ä»–ã®èª

	â—è¨³æ³¨
å‚ç…§
å‚ç…§å…ˆ
ä»£å…¥
ä»£ç”¨å¯¾
å«æ„-
å›ºæœ‰ã®
ä¿æŒ-
å†…éƒ¨çŠ¶æ…‹
åˆæœŸåŒ–
åˆ¶ç´„ã•ã‚Œã‚‹ã“ã¨ãŒ
åŒºç‚¹ç•ªå·
å®Ÿè¡Œåˆ¶å¾¡
æ‰€å±
æ•°å€¤çš„
æ•°å­—åˆ—
æ—¥ä»˜
æ™‚ç³»åˆ—çš„
æœ‰åŠ¹
æ§‹é€ 
æ©Ÿèƒ½
æ­£è¦åŒ–ã•ã‚Œ
ç‰¹æœ‰
å¤–å­—
ç¬¦å·ç‚¹
~~ç¬¦å·ä½ç½®
è¦‹ãªã›ã‚‹
è§’æ‹¬å¼§
è¨˜å·
è¨˜æ³•
è¨˜è¿°
è¨˜è¿°ã•ã‚Œ
è¨³
è¨³è€…
è¨³èª
è©¦ã™
èª²-:impose
è­˜åˆ¥å­
é›†åˆ
é™çš„
å¤‰æ•°
è¿½åŠ 
æ„å‘³
æ„å‘³-
è¡¨è¨˜è¦ç´„
	â—
ç­‰ã—ã„
ä¸€æ–¹ã§
ä¼´-
å‚™ãˆã‚‹
åŒ–
åŒ–-
å ´åˆ
å ´æ‰€
å¯¾ã—ï¼å¯¾ã™ã‚‹
åˆ—:sequence
é …ç›®æ•°
å³ï¼å·¦
ä¸‡
ä¸¦ã³
å¹´
æ•°
æ•°å€¤:number
å¿œã˜ã¦
æˆç«‹-
æ‹¬å¼§å†…
æ–¹
æ¡:digit:~
æ³•
æ¼”ç®—
æœ‰-
æœ‰ç„¡
æ¸ˆã‚€
ç‚¹ã§
ç„¡ã„
ç„¡ã‘ã‚Œ
ç‰‡
çš„
ç”¨ã„
ç•°ãª
ç›¸äº’ã«
çœç•¥-:without
ç©ºè¡Œ:empty string
çµ„
çµ±åˆ:Unified
ã‚³ãƒ¼ãƒ‰
ç·æ•°
è¡Œ:rowï¼line
è¡¨
èª
ã€œé€²æ•°
ã€œé€²è¡¨è¨˜

-->
