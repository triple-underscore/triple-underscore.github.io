<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Encoding（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
#encoding-labels td + td {
	white-space: pre;
	white-space: pre-line;
}

.coder {
	font-family: sans-serif0, sans-serif;
}

b.ename {
	font-weight: normal;
	font-family: sans-serif0, sans-serif;
	color: var(--K-color);
}

#_big5-lead > tr > td:nth-child(2) {
	white-space: nowrap;
}

</style>


<style>
/* based on the style at
https://encoding.spec.whatwg.org/visualization-colors.css
(2017-01-22)
*/

._vis-visualizationlegend {
	> tr {
		vertical-align: top;
		> :first-child {
			background: white;
			> :first-child {
				box-sizing: border-box;
				width: 2em;
				height: 2em;
			}
		}
	}
}

._vis-unmapped {
  background-color: #920000;
  color: white;
}

._vis-astral {
  background-color: #6db6fe;
  color: black;
}

._vis-mid {
  background-color: #ffff6d;
  color: black;
}

._vis-upper, ._vis-byte {
  background-color: #d4d5db;
  color: black;
}

._vis-pua {
  background-color: #db6d00;
  color: black;
}

._vis-mid._vis-contiguous {
  background-color: #009292;
  color: black;
}

._vis-upper._vis-contiguous {
  background-color: #24fe23;
  color: black;
}

._vis-pua._vis-contiguous {
  background-color: #924900;
  color: white;
}

._vis-astral._vis-contiguous {
  background-color: #480091;
  color: white;
}

._vis-duplicate {
  border-style: solid ;
  border-color: #920000;
  color: black;
}

._vis-compatibility {
  border-style: dashed;
  border-color: black;
}

._vis-duplicate._vis-compatibility {
  border-style: dashed;
  border-color: #920000;
}

._vis-ext {
  border-style: dotted;
  border-color: black;
}

._vis-ext._vis-compatibility {
  border-style: dotted;
  border-color: #920000;
}

._vis-surrogate {
  background-color: #b4b4b6;
}



@supports (grid-template-columns: subgrid) and (display: contents) {

#_index_list {
	grid-template-columns: 10em 1fr 1fr 1fr;
	min-width: 30em;
	max-width: 70em;
	tr {
		grid-template-areas:
			"名前 索引 視覚化 被覆域"
			"名前 備考 備考 備考"
		;
		> *:nth-child(1) {
			grid-area: 名前;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: 索引;
		}
		> *:nth-child(3) {
			grid-area: 視覚化;
		}
		> *:nth-child(4) {
			grid-area: 被覆域;
		}
		> *:nth-child(5) {
			grid-area: 備考;
		}
	}
}

}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
case 'lb': // label
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'mc':
	text = "constructor";
	href = `#dom-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'n': // encoding name
	href = `#${key.toLowerCase()}`;
	break;
case 'tA': // 型注釈
	text = `&lt;${key}&gt;`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'X':
	text = `0x${key}`;
	break;
case 'idx':
	return idx_html(key);
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}

	function idx_html(key){
		const k = key.toLowerCase();
		const url = 'https://encoding.spec.whatwg.org/';

		let txt = `
<a href="${url}index-${k}.txt">index-${k}.txt</a>`;
		let vis = `
<td><a href="${url}${k}.html">索引 <b class="ename">${key}</b> 視覚-化</a>`;
		let cover = `
<td><a href="${url}${k}-bmp.html">索引 <b class="ename">${key}</b> BMP 被覆域</a>`;

		switch(key){
			case 'jis0208':
				vis += `,
<a href="${url}shift_jis.html">索引~Shift_JIS視覚-化</a>`;
			break;
			case 'gb18030-ranges':
			case 'iso-2022-jp-katakana':
				vis = cover = '<td>';
			break;
//			case 'ISO-8859-8-I'
		}

		return txt + vis + cover;
	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:Encoding
spec_date:2025-04-23
trans_update:2025-04-23
source_checked:240613
spec_status:LS
original_url:https://encoding.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
copyright:,whatwg
trans_1st_pub:2012-10-22


●●class_map
E:error
n:ename
U:code-point
cn:cp-name
X:hex-value

●●tag_map
I:code
m:code
mb:code
E:code
n:b
U:span
cn:span
X:span
i:i
i1:i
V:var
tA:sub
c:code
em:em
cite:cite

●●mdn_urls
textdecoder:API/TextDecoder
textencoder:API/TextEncoder
	textdecoderoptions:API/TextDecoderOptions
	textdecodeoptions:API/TextDecodeOptions
	dictdef-textencoderencodeintoresult:API/TextEncoderEncodeIntoResult
	textencodeoptions:API/TextEncodeOptions
	textdecodercommon:API/TextDecoderCommon
	textdecoderstream:API/TextDecoderStream
	textencodercommon:API/TextEncoderCommon
	textencoderstream:API/TextEncoderStream


●●original_id_map
	旧 id
	textdecodercommon-decoder:textdecoderstream-decoder
	textdecodercommon-decoder:textdecoder-decoder
	textdecodercommon-i-o-queue:textdecodercommon-stream
	textdecodercommon-i-o-queue:textdecoderstream-stream
	textdecodercommon-i-o-queue:textdecoder-stream

●●link_map


	●IDL
Exposed:~WEBIDLjs#Exposed
AllowShared:~WEBIDLjs#AllowShared

E.RangeError:~WEBIDL#exceptiondef-rangeerror
E.TypeError:~WEBIDL#exceptiondef-typeerror

I.TextDecoderOptions:#textdecoderoptions
I.TextDecodeOptions:#textdecodeoptions
I.TextDecoder:#textdecoder
I.TextEncoderEncodeIntoResult:#dictdef-textencoderencodeintoresult
I.TextEncodeOptions:#textencodeoptions
I.TextEncoder:#textencoder
I.AllowSharedBufferSource:~WEBIDL#AllowSharedBufferSource
I.BufferSource:~WEBIDL#BufferSource
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array
I.Uint32Array:~WEBIDL#idl-Uint32Array

I.TextDecoderCommon:#textdecodercommon
I.TextDecoderStream:#textdecoderstream
I.TextEncoderCommon:#textencodercommon
I.TextEncoderStream:#textencoderstream

I.GenericTransformStream:~STREAMS#generictransformstream
I.ReadableStream:~STREAMS#readablestream
I.WritableStream:~STREAMS#writablestream
I.TransformStream:~STREAMS#transformstream

Uint8Array:~WEBIDL#idl-Uint8Array
USVString:~WEBIDL#idl-USVString
DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean
unsigned long long:~WEBIDL#idl-unsigned-long-long

m.new TextDecoder:#dom-textdecoder
m.encoding:#dom-textdecoder-encoding
m.fatal:#dom-textdecoder-fatal
m.ignoreBOM:#dom-textdecoder-ignorebom

m.new TextEncoder:#dom-textencoder
m.decode:#dom-textdecoder-decode
m.~encoding0:#dom-textencoder-encoding
m.encode:#dom-textencoder-encode
m.encodeInto:#dom-textencoder-encodeinto

m.read:#dom-textencoderencodeintoresult-read
m.written:#dom-textencoderencodeintoresult-written

m.new TextEncoderStream:#dom-textencoderstream
m.new TextDecoderStream:#dom-textdecoderstream

m.readable:~STREAMS#dom-generictransformstream-readable
m.writable:~STREAMS#dom-generictransformstream-writable

m.pipeThrough:~STREAMS#rs-pipe-through

mb.fatal:#dom-textdecoderoptions-fatal
mb.ignoreBOM:#dom-textdecoderoptions-ignorebom

mb.stream:#dom-textdecodeoptions-stream

	%input:#dom-textdecoder-decode-input-options-input
	%label:#dom-textdecoder-textdecoder-label-options-label
	%label:#dom-textdecoderstream-textdecoderstream-label-options-label
	%options:#dom-textdecoder-decode-input-options-options
	%options:#dom-textdecoder-textdecoder-label-options-options
	%options:#dom-textdecoderstream-textdecoderstream-label-options-options

	●用語

符号化法:#encoding
名前:#name
~label:#label
~label:#_labels
復号器:#decoder
~Unicodeに復号する:#decode
~UTF-8復号する:#utf-8-decode
~BOMはそのままに~UTF-8復号する:#utf-8-decode-without-bom
~BOMも失敗-もそのままに~UTF-8復号する:#utf-8-decode-without-bom-or-fail
~BOMを~sniffする:#bom-sniff
~UTF-8符号化する:#utf-8-encode
符号化法を利用して符号化する:#encode
符号化器を取得する:#get-an-encoder
符号化するか失敗する:#encode-or-fail

符号化器:#encoder
~handler:#handler
~error~mode:#error-mode
i.~error:#error
i.完遂d:#finished
i.継続-:#continue
~EoQ:#end-of-stream
~labelから符号化法を取得する:#concept-encoding-get
符号化法から出力~符号化法を取得する:#get-an-output-encoding
入出力~queue:#concept-stream
入出力~queueから~itemを読取る:#concept-stream-read
入出力~queueから~item列を読取る:#_concept-stream-read
入出力~queueを覗見る:#i-o-queue-peek
入出力~queueに~pushする:#concept-stream-push
ioQ.~push:#concept-stream-push
入出力~queueに格納し直す:#concept-stream-prepend
格納し直す演算:#concept-stream-prepend
変換する:#from-i-o-queue-convert
入出力~queueに変換する:#to-i-o-queue-convert

~queueを処理する:#concept-encoding-run
	走らす:#concept-encoding-run
~itemを処理する:#concept-encoding-process

~surrogate対から~scalar値を得する:#scalar-value-from-surrogates

	●
索引:#index
索引~cp:#index-code-point
索引~pointer:#index-pointer
索引~Big5~pointer:#index-big5-pointer
索引~Big5:#index-big5
索引~EUC-KR:#index-euc-kr
索引~jis0208:#index-jis0208
索引~jis0212:#index-jis0212
索引~Shift_JIS~pointer:#index-shift_jis-pointer
索引~ISO-2022-JP~katakana:#index-iso-2022-jp-katakana
索引~gb18030範囲~群:#index-gb18030-ranges
索引~gb18030範囲~群~cp:#index-gb18030-ranges-code-point
索引~gb18030範囲~群~pointer:#index-gb18030-ranges-pointer

索引~gb18030:#index-gb18030

~UTF-8~cp:#utf-8-code-point
~UTF-8出現~byte数:#utf-8-bytes-seen
~UTF-8要~byte数:#utf-8-bytes-needed
~UTF-8下限:#utf-8-lower-boundary
~UTF-8上限:#utf-8-upper-boundary

単-~byte符号化法:#single-byte-encoding
単-~byte索引:#index-single-byte


	●名前
	n.UTF-8:#utf-8
	n.IBM866:#ibm866
	n.ISO-8859-2:#iso-8859-2
	n.ISO-8859-3:#iso-8859-3
	n.ISO-8859-4:#iso-8859-4
	n.ISO-8859-5:#iso-8859-5
	n.ISO-8859-6:#iso-8859-6
	n.ISO-8859-7:#iso-8859-7
	n.ISO-8859-8:#iso-8859-8
	n.ISO-8859-8-I:#iso-8859-8-i
	n.ISO-8859-10:#iso-8859-10
	n.ISO-8859-13:#iso-8859-13
	n.ISO-8859-14:#iso-8859-14
	n.ISO-8859-15:#iso-8859-15
	n.ISO-8859-16:#iso-8859-16
	n.KOI8-R:#koi8-r
	n.KOI8-U:#koi8-u
	n.macintosh:#macintosh
	n.windows-874:#windows-874
	n.windows-1250:#windows-1250
	n.windows-1251:#windows-1251
	n.windows-1252:#windows-1252
	n.windows-1253:#windows-1253
	n.windows-1254:#windows-1254
	n.windows-1255:#windows-1255
	n.windows-1256:#windows-1256
	n.windows-1257:#windows-1257
	n.windows-1258:#windows-1258
	n.x-mac-cyrillic:#x-mac-cyrillic

	n.GBK:#gbk
	n.gb18030:#gb18030
	n.Big5:#big5
	n.EUC-JP:#euc-jp
	n.ISO-2022-JP:#iso-2022-jp
	n.Shift_JIS:#shift_jis
	n.EUC-KR:#euc-kr
	n.replacement:#replacement
	n.UTF-16LE:#utf-16le
	n.UTF-16BE:#utf-16be
	n.x-user-defined:#x-user-defined

n.UTF-16BE/LE:#utf-16be-le

	●encoder／decoder IDL
dec.符号化法:#textdecoder-encoding
dec.復号器:#textdecodercommon-decoder
dec.入出力~queue:#textdecodercommon-i-o-queue
dec.書出さないか:#textdecoder-do-not-flush-flag
dec.~BOMは無視するか:#textdecoder-ignore-bom-flag
dec.~BOMを見つけたか:#textdecoder-bom-seen-flag
dec.~error~mode:#textdecoder-error-mode

入出力~queueを直列化する:#concept-td-serialize

enc.符号化器:#textencoderstream-encoder
enc.頭部~surrogate:#textencoderstream-pending-high-surrogate

~cuを~scalar値に変換する:#convert-code-unit-to-scalar-value
~chunkを復号して~enqueueする:#decode-and-enqueue-a-chunk
~chunkを符号化して~enqueueする:#encode-and-enqueue-a-chunk
符号化して書出す:#encode-and-flush
書出して~enqueueする:#flush-and-enqueue


	●各種 encoder／decoder

~UTF-8復号器:#utf-8-decoder
~UTF-8符号化器:#utf-8-encoder
共用~UTF-16復号器:#shared-utf-16-decoder
~replacement復号器:#replacement-decoder
~replacement~errorは返したか:#replacement-error-returned-flag

単-~byte復号器:#single-byte-decoder
単-~byte符号化器:#single-byte-encoder

~GBK用か:#gbk-flag

~gb1:#gb18030-first
~gb2:#gb18030-second
~gb3:#gb18030-third

~gb18030復号器:#gb18030-decoder
~gb18030符号化器:#gb18030-encoder

~Big5~lead:#big5-lead
~Big5復号器:#big5-decoder
~Big5符号化器:#big5-encoder

~EUC-JP~lead:#euc-jp-lead
~EUC-JP~jis0212:#euc-jp-jis0212-flag
~EUC-JP復号器:#euc-jp-decoder
~EUC-JP符号化器:#euc-jp-encoder

~ISO-2022-JP復号器:#iso-2022-jp-decoder
~ISO-2022-JP符号化器:#iso-2022-jp-encoder

~ISO-2022-JP復号器~状態:#iso-2022-jp-decoder-state
~ISO-2022-JP復号器~出力~状態:#iso-2022-jp-decoder-output-state
~ISO-2022-JP~lead:#iso-2022-jp-lead
~ISO-2022-JP出力:#iso-2022-jp-output-flag

i.ASCII:#iso-2022-jp-decoder-ascii
i.Roman:#iso-2022-jp-decoder-roman
i.katakana:#iso-2022-jp-decoder-katakana
i.~lead~byte:#iso-2022-jp-decoder-lead-byte
i.~trail~byte:#iso-2022-jp-decoder-trail-byte
i.~escape開始:#iso-2022-jp-decoder-escape-start
i.~escape:#iso-2022-jp-decoder-escape

~ISO-2022-JP符号化器~状態:#iso-2022-jp-encoder-state
i1.ASCII:#iso-2022-jp-encoder-ascii
i1.Roman:#iso-2022-jp-encoder-roman
i1.jis0208:#iso-2022-jp-encoder-jis0208

~Shift_JIS~lead:#shift_jis-lead
~Shift_JIS復号器:#shift_jis-decoder
~Shift_JIS符号化器:#shift_jis-encoder

~EUC-KR~lead:#euc-kr-lead
~EUC-KR復号器:#euc-kr-decoder
~EUC-KR符号化器:#euc-kr-encoder

~UTF-16~lead~byte:#utf-16-lead-byte
~UTF-16頭部~surrogate:#utf-16-lead-surrogate
~UTF-16復号器:#utf-16-decoder
~UTF-16LE復号器:#utf-16le-decoder
~UTF-16BE復号器:#utf-16be-decoder
~UTF-16BE復号器~用か:#utf-16be-decoder-flag

~x-user-defined復号器:#x-user-defined-decoder
~x-user-defined符号化器:#x-user-defined-encoder

	~byte列に変換-:#convert-a-code-unit-to-bytes

indexes.json:https://encoding.spec.whatwg.org/indexes.json

	●用語（外部

形式変換:~STREAMS#generictransformstream-transform
TS.設定しておく:~STREAMS#transformstream-set-up
	V.形式変換~algo:~STREAMS#transformstream-set-up-transformalgorithm
	V.書出n~algo:~STREAMS#transformstream-set-up-flushalgorithm
TS.~chunkを~enqueueする:~STREAMS#transformstream-enqueue

~list:~INFRA#list
~item:~INFRA#list-item
付加する:~INFRA#list-append
空:~INFRA#list-is-empty
挿入する:~INFRA#list-insert
除去する:~INFRA#list-remove
~size:~INFRA#list-size
~queue:~INFRA#queue
範囲:~INFRA#the-range

~ASCII~byte:~INFRA#ascii-byte
~byte:~INFRA#byte
~byte列:~INFRA#byte-sequence
byte.長さ:~INFRA#byte-sequence-length
文字列:~INFRA#string
~scalar値~文字列:~INFRA#scalar-value-string
~cu:~INFRA#code-unit
~cp:~INFRA#code-point
cp.値:~INFRA#code-point-value
~scalar値:~INFRA#scalar-value
~surrogate:~INFRA#surrogate
頭部~surrogate:~INFRA#leading-surrogate
尾部~surrogate:~INFRA#trailing-surrogate
~ASCII~cp:~INFRA#ascii-code-point
	~ASCII空白:~INFRA#ascii-whitespace
~ASCII数字:~INFRA#ascii-digit
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化:~INFRA#ascii-lowercase
~ASCII小文字~化する:~INFRA#ascii-lowercase
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
byte.から開始して:~INFRA#byte-sequence-starts-with

新たな~obj:~WEBIDLjs#new
投出-:~WEBIDL#dfn-throw
~IDL値に変換する:~WEBIDLjs#dfn-convert-javascript-to-idl-value
保持された~byte列の複製を取得する:~WEBIDLjs#dfn-get-buffer-source-copy
BS.~byte長さ:~WEBIDLjs#buffersource-byte-length
配列~buffer~viewの中へ~byte列を書込む:~WEBIDLjs#arraybufferview-write
	:~WEBIDLjs#arraybufferview-write-startingoffset
~buffer~sourceを作成する:~WEBIDLjs#_buffersource-create

~chunk:~STREAMS#chunk
可読~stream:~STREAMS#readable-stream
可書~stream:~STREAMS#writable-stream

並列的:~HTMLINFRA#in-parallel
符号化法を~sniffする~algo:~HTMLparsing#encoding-sniffing-algorithm
~event~loop:~WAPI#event-loop
関連な~realm:~WAPI#concept-relevant-realm

_acks1:#_acks1
_ipr1:#_ipr1

●●words_table1

bAND: <span class="op">&amp;</span> 
bOR: <span class="op">|</span> 
Lshift: <span class="op">&lt;&lt;</span>
Rshift: <span class="op">&gt;&gt;</span>

encoding0:encoding
UTF-8:<b class="ename">UTF-8</b> 
GBK:<b class="ename">GBK</b> 
gb18030:<b class="ename">gb18030</b> 
Big5:<b class="ename">Big5</b> 
EUC-JP:<b class="ename">EUC-JP</b> 
ISO-2022-JP:<b class="ename">ISO-2022-JP</b> 
Shift_JIS:<b class="ename">Shift_JIS</b> 
EUC-KR:<b class="ename">EUC-KR</b> 
jis0208:<b class="ename">jis0208</b> 
jis0212:<b class="ename">jis0212</b> 
replacement:<b class="ename">replacement</b> 
UTF-16BE:<b class="ename">UTF-16BE</b> 
UTF-16LE:<b class="ename">UTF-16LE</b> 
x-user-defined:<b class="ename">x-user-defined</b> 


●●words_table


	●仕様
普遍的:universal:~
違法:illegal:~
自明:trivial:~
網羅的:exhaustive:~
保守的:conservative:~
合法:legitimate:~
移行-:move:~
完全さ:completeness:~
	標準:Standard
	関連しない:irrelevant
	省略時は:optional
proprietary::::プロプライエタリ
reverse-engineer:reverse engineer:::リバースエンジニア
簡明:clear:~
隔たり:gap:~
過去:past:~
凡例:legend:~
特質:property:~
固守-:adhere:~
警告:warning:~
排他的:exclusive:~
収束-:converge:~
究明:investigation:~
末端利用者:end user:~:::エンドユーザ
拡散-:spread:~
逸脱-:deviate:~
生産器:producer::~
消費器:consumer::~
	〜を包装する:wrapper
周知な:knownな:~
	-:known
宿題:exercise:~
対処法:workaround:~
稀:rare:~
正当:legitimate:~
意欲的:eager:~
計画:plan:~
証拠:evidence:~
	~~確たる証拠はなく:in the light of anecdotal evidence of the level of
表面的:superficial:~
付随-:accompany:~

	消え去る:go away
	助力:help
	~~標準の:The
	~~考慮
	一式で:in combination with
	より~~一般的には:larger
	備考
	~~十分:fine
	広く:widespread
	序:Preface
	要〜:〜 needed
	不要:no need
	必要:have to
	説明:Notes
	常に〜限らない:not always
	にもかかわらず:nonetheless
	後の:future
	~~不正な:bogus
	関する:-
	~~現在の姿:what it is today
	仕立て上げ:-
	配備-済み:deployed
	供する:-
	促す
	利用されない:unused
	用-法の一つ:an approach one could take to use
	~~対処-:deal with
	~~対処:dealing with
	準じる:match
	知られ:known／
		追い易く:easy to follow
	示され:-
	呼ぶ:-
	埋める:-
	変わって:change
	見えない:not see
	記され
	記す
	一方で:whereas
	残しておく:left as
	事:fact
	疑問がある:questionable
	広く:broadly
	~~族:series
	為され:made
	必要性:necessity
	疑わしい:doubtful
	主要な:major
	含める／含めること:inclusion
	-:feature
	〜周り:around
	かまわない:free to
	されなくなる:will prevent 〜 from ever being
	なると見込まれる:will most likely
	併用しない:prevent the use of 〜 in combination with
	必ず〜ようにする~make~sure
	とは対照的に:in contrast to
	行うこと。：ought
	極めて:extremeに
	~~限定的:niche
	〜他と異なる:differently
	-:side

	●未分類
不可分:atomic::~
重複-:duplicate:~
諸々の:miscellaneousな:~
非対称:asymmetric:~

	一新-:set anew
	転換-:turn
	失わせ:loss
	戻す:back
	出くわし:hit
	~~空いた:newly-vacated
	表す:signify
	対:combination
	被せた:Layering 〜  on top
	加え
	指-:-
	得られ:-
	得る:-
	行う
	減らす:decrease
	増やさ:increase

	●network／保安
防ぐ:preventする:~
細工:craft:~
喪失:loss:~
合意-:agree:~
不一致:mismatch:~
交換:interchange:~
隠す:maskする:~
隠して:maskして:~
隠せな:maskできな:~
	突く:abuse
	至らせ:resulting in
	~~検知されずに:silent

	●符号化法
CJK:
私用領域:Private Use Area:~
	私用領域に属する〜:Private Use 〜
	香港増補字符集
	基本多言語面
	互換漢字

gb1:
gb2:
gb3:
jis0212:
jis0208:
	Roman
utf-16be:
UTF-16:
Hangul::::ハングル
surrogate::::サロゲート
cp:code point::符号位置::コードポイント
cu:code unit::符号単位::コードユニット
有符号:coded::~::有コード
索引:index::~::インデックス
BOM:
	~BOMは無視するか:ignore BOM
	~BOMを見つけたか:BOM seen
	BOM:byte order mark
BOMseen:BOM seen:BOM 確認済み
簡体字:simplified::~
繁体字:traditional::~
	範囲~群:ranges

半角:halfwidth::~
全角:fullwidth::~
katakana::::カタカナ
Korean:
Japanese:
Chinese:
percent-::: %-

	空~行l:empty string

	●I/O queue／stream
入出力:I/O:~
close:
streaming::::ストリーム処理
	~streamしている:streaming
	~streamしていない:immediate
可読:readable::~
	unread:〜を元に戻す
可書:writable::~
書込まれ:writeされ::書き込まれ
書込む:writeする::書き込む
形式変換:transform::~
EoQ:end-of-queue::queue 終端:キュー終端
chunk::::チャンク
enqueue::::エンキュー
coder:
書出す:flushする::書き出す
書出さな:flushしな::書き出さな
書出して:flushして::書き出して
書出n:flush::書き出し

一掃-:flush::~
	書出さないか:do not flush
覗見る:peekする:覗き見る
lead::頭部
trail::尾部
頭部:leading:~
尾部:trailing:~
連結-:concatenate:~
sniff:
不定:indefinite:~

	前後の:leading and trailing
	~buffer~source:bufferSource
	出力~chunk:outputChunk
	書出n~algo:flushAlgorithm
	形式変換~algo:transformAlgorithm
	来て:coming
	来る:come
	個数:number

	●一般処理
繰返す:繰り返す
演算対象:operand:~
下限:lower boundary::~
上限:upper boundary::~
範囲検査:limit check:~
発され:emitされ:~
発する:emitする:~
給-:supply:~

	格納し直す:restore
	〜が返す値:〜の return value
	かけた:run through
	〜にかける:runs them through
	出現~byte数:byte seen
	fatal:
	invocation
	渡す:pass
	通過する:pass 〜 through
	挙げられた順に:starting with the first one and going down
	次のいずれかが生じるまで:whichever comes first
	~call元:caller
	保つ:keepする:~
	生きたまま:alive
	順序を~~保ったまま:in the given order

	●データ型／操作／IDL
shift::::シフト
内包-:include::~
剰余:remainder:~
基数:base:~
剥ぐ:stripする:~
JSON:

	●変数
	%入出力~queue:ioQueue
	%結果:-
	%結果:result
	%個数:number
	%結果:readItems
	%~item:-
	%~item:item
	%接頭辞:prefix
	%n:n
	%~item列:items
	%最後の~index
	%入力:input
	%頭部:leading
	%尾部:trailing
	%~coder:encoderDecoder
	%出力:output
	%~mode:mode
	%数字列:-
	%~label:label
	%符号化法:encoding
	%行l~list:lines
	%索引:index
	%索引:-
	%~pointer:pointer
	%~cp:codePoint
	%~offset:offset
	%~cp~offset:-
	%~pointer~offset:-
	%~buffer:buffer
	%復号器:-
	%復号器:decoder
	%~errorになり得る:potentialError
	%~BOM符号化法:BOMEncoding
	%N:-
	%~BOM:BOM
	%行
	%符号化器:encoder
	%複製:-
	%read:read
	%written:written
	%利用されない~queue:unused
	%形式変換~stream:transformStream
	%~chunk:chunk
	%~buffer~source:bufferSource
	%出力~chunk:outputChunk
	%頭部~surrogate:leadingSurrogate
	%~byte列:chunk
	%~byte列:bytes
	%~byte:byte
	%temp
	%~lead:lead
	%~trail:trail
	%byte1
	%byte2
	%byte3:byte3
	%byte4:byte4
	%状態:state
	%~lead~offset:lead offset
	%~cu:codeUnit
	%~utf-16be

	●未分類
XML:
被覆域:coverage:~
覆う:coverする:~
組立直せ:reassembleでき:組み立て直せ

	視覚-化:visualize
	視覚-化:visualization
	算術式:equation
	~~統合:Unified
	伴われない:no 〜 present
	優先される:has priority over／more authoritative
	数
	数値:number
	桁:digit
	〜進数
	〜進表記
	~~孤立した:lone
	〜用:is 〜
	入力~用の:input
	出力~用の:output

	最初の:first
	最後の:last
	全体的:overall
	〜の全体が:in its entirety
	左上隅:top left corner
	ある程度:some extent
	未満:less than
	他
	同じ:／
	前述の:aforementioned
	後続の:later
	最短:shortest
	かつての:former
	全くの:fully
	若干の:slight
	下位:least significant
	逆方向:vice versa
	並び／列／連列:sequence
	直後に続く:follows immediately
	成立-:true
	3 種の:three
	自身:themselves
	一部を成す:part of
	2 つの〜に:between
	唯一の／のみ:only
	複数:／
	2 回:twice
	様々な:various
	右辺:-
	左辺:-
	各種:-
	多くの:a lot of
	除く:but
	超え:over
	超えない:less than or equal to
	際して:-
	その種の:such
	他所:the rest of
	項目数:items
	次項:-
	括弧内:-
	省略-:without
	行:row
	冒頭:-
	相互に:go from 〜 and back
	一つ:one of／:-
	少し:some
	次回:next
	一連の:〜s
	上
	下
	これ以上〜ない:To stop
	それ以上:no more
	以下:below
	中
	以外:excluding
	それ以外では:other than that
	何か:something
	何も:nothing
	入る:in
	列目:-
	別として
	先頭:first／
	属する
	後者:-
	次
	次の
	節
	面
	該当-
	間
	回
	後は
	時
	最も
	末尾
	個
	一方で
	伴-
	備える
	右／左
	年
	応じて
	方
	済む
	有無:-
	無い
	点で
	的
	異なる
	有-
	万
	組
	表
	語

	●訳注
	下記
	先の
	総数
	代用対
	含意-
	固有の
	保持-
	内部状態
	制約-
	区点番号
	数値として
	数字列
	識別子
	日付
	時系列的
	構造
	機能
	外字
	角括弧
	記号
	記法
	記述
	訳
	訳者
	試す
	集合
	静的
	変数
	追加
	意味
	意味-
	表記規約
	用い


●●ref_normative

[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[STREAMS]
    Adam Rice; et al. ＜Streams Standard＞. Living Standard. URL: https://streams.spec.whatwg.org/
[UNICODE]
    ＜The Unicode Standard＞. URL: https://www.unicode.org/versions/latest/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[XML]
    Tim Bray; et al. ＜Extensible Markup Language (XML) 1.0 (Fifth Edition)＞. 26 November 2008. REC. URL: https://www.w3.org/TR/xml/


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://encoding.spec.whatwg.org/">Encoding Standard</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/encoding">GitHub whatwg/encoding</a> (<a href="https://github.com/whatwg/encoding/issues/new/choose">new issue</a>, <a href="https://github.com/whatwg/encoding/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	https://github.com/whatwg/encoding/commits
	<a href="https://encoding.spec.whatwg.org/commit-snapshots/36fb4e7a5582873b3700a5a72912a8e91163a092/">Snapshot as of this commit</a>
	<a href="https://twitter.com/encodings">@encodings</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/encoding">web-platform-tests encoding/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/encoding">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>
<body>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxwYXRoIGQ9Im01MCwwbDUwLDUwLTUwLDUwLTUwLTUwIiBmaWxsPSIjM2M3OTBhIi8+DQo8cGF0aCBkPSJtMzgsNDBjMC0xMiwyNC0xNSwyMy0yYzAsOS0xNiwxMy0xNiwyM3Y3aDEwdi00YzAtOSwxNy0xMiwxNy0yN2MtMi0yMi00NS0yMi00NSwzem03LDMyaDEwdjEwaC0xMCIgZmlsbD0iI2ZmZiIvPg0KPC9zdmc+DQo="
></a>

	<hgroup>
<h1>Encoding — 符号化法</h1>
	</hgroup>

</header>

<main id="MAIN" hidden>
	<section id="preface">

<h2 title="Preface">1. 序</h2>

<p>
~UTF-8符号化法は、
普遍的な有符号~文字~集合である~Unicodeの交換に最も適切な符号化法である。
よって，この仕様は、
新たな［
~protocol, 形式
］および［
新たな文脈において配備される既存の形式
］に対し，~UTF-8符号化法を要求する
（また，それを定義する）。
◎
The UTF-8 encoding is the most appropriate encoding for interchange of Unicode, the universal coded character set. Therefore for new protocols and formats, as well as existing formats deployed in new contexts, this specification requires (and defines) the UTF-8 encoding.
</p>

<p>
符号化法には，他のもの（旧来の符号化法）もあり、
過去にある程度までは定義されたが，
~UA間で常に同じ仕方で実装されているとは限らない。
また、
常に同じ~labelを利用するとは限らず，［
符号化法の中の未定義な区画, あるいは かつての~proprietaryな区画への~~対処
］も相違することが多い。
この仕様は、［
新たな実装が符号化法~実装を~reverse-engineerせずに済む
］よう，および［
既存の~UAが一つに収束できる
］よう，これらの隔たりを埋めることに取組む。
◎
The other (legacy) encodings have been defined to some extent in the past. However, user agents have not always implemented them in the same way, have not always used the same labels, and often differ in dealing with undefined and former proprietary areas of encodings. This specification addresses those gaps so that new user agents do not have to reverse engineer encoding implementations and existing user agents can converge.
</p>

<p>
特に，この仕様は、
それらすべての符号化法を，各~符号化法の［
`~byte列$と`~scalar値$列を相互に変換する~algo,
正準的な名前,
識別-用の`~label$たち
］とともに定義する。
また、
符号化法を成す各種~algoのうち一部を~JSに公開する~APIも定義する。
◎
In particular, this specification defines all those encodings, their algorithms to go from bytes to scalar values and back, and their canonical names and identifying labels. This specification also defines an API to expose part of the encoding algorithms to JavaScript.
</p>

<p>
~UAは、
すでに
`IANA Character Sets＠~IANA-a/character-sets/character-sets.xhtml$en
~registryに挙げられている~labelからも有意に逸脱している。
旧来の符号化法を これ以上~拡散させないため、
この仕様は前述の詳細~について網羅的であり，
~registryはもう不要である。
特に，この仕様は、
符号化法を拡張するための仕組みは供さない。
◎
User agents have also significantly deviated from the labels listed in the IANA Character Sets registry. To stop spreading legacy encodings further, this specification is exhaustive about the aforementioned details and therefore has no need for the registry. In particular, this specification does not provide a mechanism for extending any aspect of encodings.
</p>

	</section>
	<section id="security-background">

<h2 title="Security background">2. ~securityに関する背景0</h2>

<p>
符号化法には、
いくつか，~securityの課題がある
— 生産器と消費器の間で，［
利用-中にある符号化法, あるいは所与の符号化法の実装-法
］について合意されてないときに。
例えば、
2011 年には，次のような攻撃が報告された：
そこでは、［
攻撃者が何らかの~fieldを制御し得るような，~JSON資源
］内で，
`Shift_JIS$n の~lead~byte `82^X が~trail~byte `22^X を “隠す” ために利用された。
生産器からは，これが違法な~byte対であっても問題が見えない一方で、
消費器は，この~byte対を 1 個の `FFFD^U `�^smb として復号する~~結果、
全体的な解釈が変わってしまう
— `0022^U `"^smb は重要な区切子なので。
［
`~scalar値$に対し複数~byteを利用する符号化法
］の復号器には、
今や，違法な~byte対の事例では［
範囲 `0000^U 〜 `007F^U に入る~scalar値
］を “隠せない” ようにすることが要求される
— 前述の~byte対に対しては、
出力が［
`FFFD^U `0022^U
］になるよう
（あいにく，これには例外があり、
`~gb18030復号器$は，`~EoQ$にある そのような~byte 1 個を “隠して” しまう）。
◎
There is a set of encoding security issues when the producer and consumer do not agree on the encoding in use, or on the way a given encoding is to be implemented. For instance, an attack was reported in 2011 where a Shift_JIS lead byte 0x82 was used to “mask” a 0x22 trail byte in a JSON resource of which an attacker could control some field. The producer did not see the problem even though this is an illegal byte combination. The consumer decoded it as a single U+FFFD (�) and therefore changed the overall interpretation as U+0022 (") is an important delimiter. Decoders of encodings that use multiple bytes for scalar values now require that in case of an illegal byte combination, a scalar value in the range U+0000 to U+007F, inclusive, cannot be “masked”. For the aforementioned sequence the output would be U+FFFD U+0022. (As an unfortunate exception to this, the gb18030 decoder will “mask” up to one such byte at end-of-queue.)
</p>

<p>
これは、
より~~一般的には，［
~lead~byteが伴われないときに，`~ASCII~byte$を`~ASCII~cp$でない何かに対応付ける
］ような符号化法における課題である。
これらは， “~ASCII互換でない” 符号化法であり、
あいにく，配備-済みな内容に因り要求されるが、［
`ISO-2022-JP$n, `UTF-16BE/LE$n
］以外のものは，~supportされない。
（他の そのような符号化法についても、
その~labelを［
未知な符号化法へ~fallbackすることなく，
`replacement$n 符号化法に対応付けれるかどうか
］の究明が`進行中にある＠https://github.com/whatwg/encoding/issues/8$。）
攻撃の例として、
注意深く細工された内容を資源の中へ注入して，利用者に符号化法を上書きするよう促す~~結果、
例えば，~scriptの実行へ至らすものがある。
◎
This is a larger issue for encodings that map anything that is an ASCII byte to something that is not an ASCII code point, when there is no lead byte present. These are “ASCII-incompatible” encodings and other than ISO-2022-JP and UTF-16BE/LE, which are unfortunately required due to deployed content, they are not supported. (Investigation is ongoing whether more labels of other such encodings can be mapped to the replacement encoding, rather than the unknown encoding fallback.) An example attack is injecting carefully crafted content into a resource and then encouraging the user to override the encoding, resulting in, e.g., script execution.
</p>

<p>
［
~HTMLや~HTMLの~form特能
］において見出される~URLに利用される符号化器も、
その符号化法により表現できない~scalar値がある場合には，若干の情報~喪失に至らせ得る。
例えば，資源が `windows-1252$n 符号化法を利用しているとき、
~serverは，末端利用者が~formに手入力した "💩" と "&amp;#128169;" とを判別できなくなる。
◎
Encoders used by URLs found in HTML and HTML’s form feature can also result in slight information loss when an encoding is used that cannot represent all scalar values. E.g., when a resource uses the windows-1252 encoding a server will not be able to distinguish between an end user entering “💩” and “&amp;#128169;” into a form.
</p>

<p>
ここに要旨した問題は、
~UTF-8を排他的に利用しているときは，消え去る。
それが、
今や，すべてに対し~UTF-8符号化法が義務付けられている理由の一つである。
◎
The problems outlined here go away when exclusively using UTF-8, which is one of the many reasons that is now the mandatory encoding for all things.
</p>

<p class="note">注記：
`§ ~browser~UI＠#browser-ui$
も見よ。
◎
See also the Browser UI chapter.
</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p>
この仕様は、
`Infra Standard^cite `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
16 進数には "0x" が接頭される。
◎
Hexadecimal numbers are prefixed with "0x".
</p>

<div class="p">
<p>
算術式の中のすべての数値は整数であり、
各種~演算は，次に挙げる記号で表現される：
</p>

<table><thead>
<tr><th>記号
<th>意味
<tbody>

<tr><th>~PLUS
<td>加算

<tr><th>~MINUS
<td>減算

<tr><th>~INCBY
<td>左辺~値に対する右辺~値による加算【この訳による追加】

<tr><th>~DECBY
<td>左辺~値に対する右辺~値による減算【この訳による追加】

<tr><th>~MUL
<td>乗算

<tr><th>~DIV
<td>整数の除算【小数切り捨て】

<tr><th>~MOD
<td>整数の除算の剰余（ modulo ）【常に 0 以上（負な数には演算され得ない）】

<tr><th>~Lshift
<td>論理-左~shift

<tr><th>~Rshift
<td>論理-右~shift

<tr><th>~bAND
<td>~bit AND

<tr><th>~bOR
<td>~bit OR
</table>

◎
In equations, all numbers are integers, addition is represented by "+", subtraction by "−", multiplication by "×", integer division by "/" (returns the quotient), modulo by "%" (returns the remainder of an integer division), logical left shifts by "&lt;&lt;", logical right shifts by "&gt;&gt;", bitwise AND by "&amp;", and bitwise OR by "|".
</div>

<p>
論理-右~shiftの演算対象の精度は、
少なくとも 21 ~bit以上にするモノトスル。
◎
For logical right shifts operands must have at least twenty-one bits precision.
</p>

<hr>

<p>
`入出力~queue@
（ `I/O queue^en ）は、
特定0の型（ `~byte$, `~scalar値$, `~cu$ など）の`~item$たちが成す`~list$である。
~item型も含めて指定するときは、
“`入出力~queue$`~byte^tA” 等々と記される†。
【†この表記規約は、この訳に特有。】
◎
An I/O queue is a type of list with items of a particular type (i.e., bytes or scalar values).＼
</p>

<p>
`入出力~queue$は、
特別な`~item$として
`~EoQ@
（ `end-of-queue^en ）も含み得る
— それは、
当の~queue内には，それより後に`~item$は無いことを徴す。
【`~EoQ$の型は、形式的に，それが属する`入出力~queue$の~item型と見なされる。】
◎
End-of-queue is a special item that can be present in I/O queues of any type and it signifies that there are no more items in the queue.
</p>

<div class="note">
<p>注記：
`入出力~queue$は、
2 つの仕方
— “~streamしている” ~mode，していない~mode —
で利用され、
順に［
~networkから来ている~data,
~memory内に格納された入出力~data
］を表現する。
~streamしていない~queue内には、
最後の~itemとして【常に】`~EoQ$が在る。
一方で，~streamしている`入出力~queue$は：
◎
There are two ways to use an I/O queue: in immediate mode, to represent I/O data stored in memory, and in streaming mode, to represent data coming in from the network. Immediate queues have end-of-queue as their last item, whereas streaming queues＼
</p>
<ul>
	<li>
`~EoQ$は無いこともあり、［
`入出力~queueから~itemを読取る$／
`入出力~queueから~item列を読取る$
］演算は，
【何らかの~itemが可用になるまで】阻まれるかもしれない。
◎
need not have it, and so their read operation might block.
</li>
	<li>
次の順に演算されるものと期待される
⇒＃
空として作成される,
~networkから~dataが来るに伴い，新たな`~item$が`~push$ioQされる,
下層の~network~streamが~closeされるとき，`~EoQ$が`~push$ioQされる
◎
It is expected that streaming I/O queues will be created empty, and that new items will be pushed to it as data comes in from the network. When the underlying network stream closes, an end-of-queue item is to be pushed into the queue.
</li>
	<li>
そこから読取るときは，阻まれるかもしれないので、
`~event~loop$からは利用されず，代わりに`並列的$に利用される。
◎
Since reading from a streaming I/O queue might block, streaming I/O queues are not to be used from an event loop. They are to be used in parallel instead.
</li>
</ul>
</div>

<div class="algo">
<p>
`入出力~queueから~itemを読取る@
~algoは、
所与の
( `入出力~queue$ %入出力~queue )
に対し：
◎
To read an item from an I/O queue ioQueue, run these steps:
</p>
<ol>
	<li>
~IF［
%入出力~queue は`空$である
］
⇒
次が満たされるまで待機する
⇒
%入出力~queue の`~size$ ~GTE 1
◎
If ioQueue is empty, then wait until its size is at least 1.
</li>
	<li>
%結果 ~LET %入出力~queue[ 0 ]
◎
↓</li>
	<li>
~IF［
%結果 ~NEQ `~EoQ$
］
⇒
%入出力~queue から最初の~itemを`除去する$
◎
If ioQueue[0] is end-of-queue, then return end-of-queue.
◎
Remove ioQueue[0] and return it.
</li>
	<li>
~RET %結果
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
`入出力~queueから~item列を読取る@
~algoは、
所与の
( `入出力~queue$ %入出力~queue, %個数 )
に対し：
◎
To read a number number of items from ioQueue, run these steps:
</p>
<ol>
	<li>
~Assert：［
%個数 は負でない整数である
］~OR［
%個数 ~EQ `不定^i
］
◎
↑</li>
	<li>
%結果 ~LET « »
◎
Let readItems be « ».
</li>
	<li>
<p>
~WHILE［
%結果 の`~size$ ~NEQ %個数
］：
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %入出力~queue )
</li>
			<li>
~IF［
%~item ~EQ `~EoQ$
］
⇒
~BREAK
</li>
			<li>
%結果 に %~item を`付加する$
</li>
		</ol>
◎
Perform the following step number times:
• Append to readItems the result of reading an item from ioQueue.
◎
Remove end-of-queue from readItems.
</li>
	<li>
~RET %結果
◎
Return readItems.
</li>
</ol>
</div>

<p class="trans-note">【
［
`入出力~queueから~itemを読取る$,
`入出力~queueから~item列を読取る$
］~algoは、
原文では同じ［
名前, ~ID
］を伴う 2 個の~algoとして定義されているが，
この訳では異なる［
名前, ~ID
］を与えることにする。
】</p>

<div class="algo">
<p>
`入出力~queueを覗見る@
~algoは、
所与の
( `入出力~queue$ %入出力~queue, 整数 %個数 )
に対し：
◎
To peek a number number of items from an I/O queue ioQueue, run these steps:
</p>
<ol>
	<li>
次が満たされるまで待機する
⇒
［
%入出力~queue の`~size$ ~GTE %個数
］~OR［
`~EoQ$ ~IN %入出力~queue
］
◎
Wait until either ioQueue’s size is equal to or greater than number, or ioQueue contains end-of-queue, whichever comes first.
</li>
	<li>
%接頭辞 ~LET « »
◎
Let prefix be « ».
</li>
	<li>
<p>
`範囲$ { 0 〜 %個数 ~MINUS 1 }【！range 1 to number】 を成す
~EACH( %n )
に対し：
◎
For each n in the range 1 to number, inclusive:
</p>
		<ol>
			<li>
~IF［
%入出力~queue[ %n ] ~EQ `~EoQ$
］
⇒
~BREAK
◎
If ioQueue[n] is end-of-queue, break.
</li>
			<li>
%接頭辞 に %入出力~queue[ %n ] を`付加する$
◎
Otherwise, append ioQueue[n] to prefix.
</li>
		</ol>
	</li>
	<li>
~RET %接頭辞
◎
Return prefix.
</li>
</ol>
</div>

<div class="algo">
<p>
`入出力~queueに~pushする@
~algoは、
所与の
( `入出力~queue$ %入出力~queue, %~item列 )
に対し：
</p>
<ol>
	<li>
~Assert：［
%~item列 は 1 個の~itemであるか［
~itemたちが成す連列
］である
］~AND［
%~item列 を成す どの~itemも，その型は %入出力~queue の~item型である
］
</li>
	<li>
<p>
%~item列 を成す
~EACH( %~item )
に対し：
</p>
		<ol>
			<li>
%最後の~index ~LET %入出力~queue の`~size$ ~MINUS 1
</li>
			<li>
<p>
~IF［
%入出力~queue[ %最後の~index ] ~EQ `~EoQ$
］：
</p>
				<ol>
					<li>
~IF［
%~item ~NEQ `~EoQ$
］
⇒
%入出力~queue の中へ %~item を %最後の~index の前に`挿入する$
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%入出力~queue に %~item を`付加する$
</li>
		</ol>
	</li>
</ol>

◎
To push an item item to an I/O queue ioQueue, run these steps:
• If the last item in ioQueue is end-of-queue:
•• If item is end-of-queue, do nothing.
•• Otherwise, insert item before the last item in ioQueue.
• Otherwise, append item to ioQueue.
◎
To push a sequence of items to an I/O queue ioQueue is to push each item in the sequence to ioQueue, in the given order.
</div>

<div class="algo">
<p>
`入出力~queueに格納し直す@
~algoは、
所与の
( `入出力~queue$ %入出力~queue, %~item列 )
に対し：
</p>
<ol>
	<li>
<p>
~Assert：
</p>
		<ul>
			<li>
%~item列 は 1 個の~itemであるか［
~itemたちが成す連列
］である
</li>
			<li>
%~item列 内に`~EoQ$は無い
</li>
			<li>
%~item列 を成す どの~itemも，その型は %入出力~queue の~item型である
</li>
		</ul>
	</li>
	<li>
%入出力~queue の先頭に %~item列 を
— ~itemたちの順序を~~保ったまま —
挿入する
</li>
</ol>
◎
To restore an item other than end-of-queue to an I/O queue, perform the list prepend operation. To restore a list of items excluding end-of-queue to an I/O queue, insert those items, in the given order, before the first item in the queue.
</div>

<p class="example">
入出力~queue`~byte^tA « `92^X, `A9^X, ~EoQ » に
~byte列 « `F0^X, `9F^X » を挿入した【！Inserting】なら、
結果の入出力~queueは
« `F0^X, `9F^X, `92^X, `A9^X, ~EoQ » になり，
次回に読取られる~itemは `F0^X になる。
◎
Inserting the bytes « 0xF0, 0x9F » in an I/O queue « 0x92 0xA9, end-of-queue », results in an I/O queue « 0xF0, 0x9F, 0x92 0xA9, end-of-queue ». The next item to be read would be 0xF0.
</p>

<div class="algo">
<p>
`入出力~queue$ %入出力~queue を［
`~list$／`文字列$／`~byte列$
］に
`変換する@
~algoは
⇒
~RET `入出力~queueから~item列を読取る$( %入出力~queue, `不定^i )
◎
To convert an I/O queue ioQueue into a list, string, or byte sequence, return the result of reading an indefinite number of items from ioQueue.
</div>

<div class="algo">
<p>
`入出力~queueに変換する@
~algoは、
所与の
( %入力 )
に対し：
</p>
<ol>
	<li>
~Assert：
%入力 は次に挙げるいずれかである
⇒＃
`文字列$（ `DOMString^I ）／
`~scalar値~文字列$（ `USVString^I ）／
`~byte列$／
`~list$
</li>
	<li>
~Assert：
%入力 は`~list$であるならば、
次を満たす
⇒
［
%入力 を成す すべての~itemは同じ型である
］~AND［
`~EoQ$ ~NIN %入力
］
</li>
	<li>
%入出力~queue ~LET 新たな`入出力~queue$`<var>入力</var> を成す~itemの型^tA
</li>
	<li>
%入力 を成す
~EACH( %~item )
に対し
⇒
%入出力~queue に %~item を`付加する$
</li>
	<li>
%入出力~queue に`~EoQ$を`付加する$
</li>
	<li>
~RET %入出力~queue
</li>
</ol>
◎
To convert a list, string, or byte sequence input into an I/O queue, run these steps:
• Assert: if input is a list, then it does not contain end-of-queue.
• Return an I/O queue containing the items in input, in order, followed by end-of-queue.
</div>

<p class="XXX">
`INFRA$r 標準が型~変換~周りの何らかの基盤を定義するものと期待される。
`whatwg/infra 課題 #319＠https://github.com/whatwg/infra/issues/319$
を見よ。
◎
The Infra standard is expected to define some infrastructure around type conversions. See whatwg/infra issue #319. [INFRA]
</p>

<p class="note">注記：
`入出力~queue$が`~queue$ではなく`~list$として定義されているのは、
`格納し直す演算$を要するからである。
しかしながら，この演算は、
この仕様が与える~algoの内部的な詳細であり，他の標準からは利用されない。
実装は、
そのような~algoを代替な仕方を見出して実装してもかまわない
— 詳細は、
`§ 実装の考慮点＠#implementation-considerations$
に。
◎
I/O queues are defined as lists, not queues, because they feature a restore operation. However, this restore operation is an internal detail of the algorithms in this specification, and is not to be used by other standards. Implementations are free to find alternative ways to implement such algorithms, as detailed in Implementation considerations.
</p>

<hr>

<div class="algo">
`~surrogate対から~scalar値を得する@
~algoは、
所与の
( `頭部~surrogate$ %頭部, `尾部~surrogate$ %尾部 )
に対し
⇒
~RET `10000^X ~PLUS ( ( %頭部 ~MINUS `D800^X ) ~Lshift 10 ) ~PLUS ( %尾部 ~MINUS `DC00^X )
◎
To obtain a scalar value from surrogates, given a leading surrogate leading and a trailing surrogate trailing, return 0x10000 + ((leading − 0xD800) &lt;&lt; 10) + (trailing − 0xDC00).
</div>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

<p>
加えて、
次に挙げる記法も利用される：
</p>
<dl>
	<dt>
~byte列 « %n1, %n2, … »
</dt>
	<dd>
数値として %n1, %n2 … と同じ値をとる`~byte$たちが成す, 挙げられた順による，新たな`~item$列を表す
（括弧の中が空な “« »” と記されたときは、
空な`~item$列を表す）。
</dd>

	<dt>
~byte « %n »
</dt>
	<dd>
~byte列 « %n » と同義だが、
~itemが 1 個だけの場合は，このように記される。
</dd>

	<dt>
~cp « %n »
</dt>
	<dd>
数値として %n と同じ値をとる 1 個の`~cp$からなる，新たな`~item$列を表す。
</dd>
</dl>

<p><small>
（原文では，~itemが 1 個だけの場合は
— 1 個の~itemを それのみからなる~item列として透過的に扱う仕組み
（`入出力~queue$に対する各種~演算を見よ）
を利用して —
括弧（ «, » ）で括らずに記されているが、
この訳では
— “同じ値をとる” という含意を簡潔に表すため —
括弧で括ることにする。）
（ “~cp列 « … »” という記法が無いのは、
複数個の~cpからなる~item列が利用される所が，一箇所しかないからである。）
</small></p>

	</section>
	<section id="encodings">
<h2 title="Encodings">4. 符号化法</h2>

<p>
`符号化法@
（ `encoding^en ）は、
`~scalar値$ 列から~byte列への対応付け
【符号化-】
および逆方向への対応付け
【復号-】
を定義する。
各 `符号化法$には、
`名前@
および， 1 個~以上の
`~label@
が`あてがわれている＠#encoding-labels$。
◎
An encoding defines a mapping from a scalar value sequence to a byte sequence (and vice versa). Each encoding has a name, and one or more labels.
</p>

<p class="note">注記：
この仕様は、
~Unicode標準に定義される符号化~scheme（ `encoding scheme^en ）として，同じ名前を伴う 3 種の`符号化法$
— `UTF-8$n, `UTF-16LE$n, `UTF-16BE$n —
を定義する。
`符号化法$は、
~BOM（ `byte order mark^en, “バイト順マーク” ）の取扱いにおいて符号化~schemeから相違する
— ~BOMの取扱いは、
この仕様においては［
`符号化法$自身の一部を成す代わりに，それを包装する~algoの一部を成している
］一方で，
~Unicode標準においては符号化~schemeの定義の一部を成す。
`~UTF-8復号する$~algoと一緒に利用される `UTF-8$n は、
同じ名前の符号化~schemeに合致する。
この仕様は、
同様に命名される符号化~schemeに合致するような［
`UTF-16LE$n ／ `UTF-16BE$n
］と組合せて包装する~algoは，供さない。
`UNICODE$r
◎
This specification defines three encodings with the same names as encoding schemes defined in the Unicode standard: UTF-8, UTF-16LE, and UTF-16BE. The encodings differ from the encoding schemes by byte order mark (also known as BOM) handling not being part of the encodings themselves and instead being part of wrapper algorithms in this specification, whereas byte order mark handling is part of the definition of the encoding schemes in the Unicode Standard. UTF-8 used together with the UTF-8 decode algorithm matches the encoding scheme of the same name. This specification does not provide wrapper algorithms that would combine with UTF-16LE and UTF-16BE to match the similarly-named encoding schemes. [UNICODE]
</p>

		<section id="encoders-and-decoders">
<h3 title="Encoders and decoders">4.1. 符号化器と復号器</h3>

<p>
各 `符号化法$には、
`復号器@
（ `decoder^en ）が結付けられ，
`符号化器@
（ `encoder^en ）が結付けられ得る。
◎
Each encoding has an associated decoder and most of them have an associated encoder.＼
</p>

<p>
［
`復号器$ ／ `符号化器$
］の各~instanceは、
`~handler@
~algoが結付けられることに加え，状態も伴い得る。
【状態を伴うがゆえに、状態が異なる それらを別個な~instanceとして扱う必要がある。】
◎
Instances of decoders and encoders have a handler algorithm and might also have state.＼
</p>

<div class="p">
<p>
`~handler$は、
所与の
( `入出力~queue$, 1 個の`~item$ )
に対し，次に挙げるいずれかを返す~algoである：
</p>
<ul>
	<li>
`完遂d@i
</li>
	<li>
<p>
1 個以上の`~item$
</p>

<p class="trans-note">【
~item型は、［
符号化器の場合は`~byte$ ／ 復号器の場合は`~cp$
］になる。
】【
`~Big5復号器$用の~handlerだけ， 2 個の~cpを返す場合があり、
他の復号器~用の~handlerは，常に 1 個の~cpからなる~item列を返す。
】</p>
	</li>
	<li>
<p>
`~error@i
</p>

<p>
`符号化器$用の`~handler$が返す `~error$i は、
常に，~cpを伴う
（`復号器$用の`~handler$が返す `~error$i が~cpを伴うことは無い）。
所与の`~cp$ %~cp を伴う `~error$i を作成する所では、
“`~error$i( %~cp )”
のように表記される。
</p>

<p class="trans-note">【
これらの記述は、
この訳による補完
— 原文では、
（~errorは，）
“省略可能な`~cp$も伴い得る”
としか記されていない。
】</p>

	</li>
	<li>
`継続-@i
</li>
</ul>
◎
A handler algorithm takes an input I/O queue and an item, and returns finished, one or more items, error optionally with a code point, or continue.
</div>

<p class="note">注記：
次に挙げる`符号化法$には、
`符号化器$は無い
⇒＃
`replacement$n,
`UTF-16BE/LE$n
◎
The replacement and UTF-16BE/LE encodings have no encoder.
</p>

<p>
以下で利用される
`~error~mode@
は：
◎
An error mode as used below is＼
</p>
<ul>
	<li>
`復号器$においては、
次のいずれかをとる
⇒
`replacement^l,
`fatal^l
◎
"replacement" or "fatal" for a decoder and＼
</li>
	<li>
`符号化器$においては、
次のいずれかをとる
⇒
`fatal^l,
`html^l
◎
"fatal" or "html" for an encoder.
</li>
</ul>

<p class="note">注記：
~XML処理器は、
その`復号器$の`~error~mode$を `fatal^l に設定することになる。
`XML$r
◎
An XML processor would set error mode to "fatal". [XML]
</p>

<p class="note">注記：
`~error~mode$に `html^l が存在するわけは、
~HTML~formにおいては，
`~error$i に際しても旧来の`符号化器$は終了させない取扱いが要求されることに因る。
`html^l `~error~mode$の下では、
合法な入力と判別できない連列が発され得る結果，~~検知されずに~dataが失われ得る。
これを防ぐため、
開発者には `UTF-8$n `符号化法$の利用が強く奨励される。
`HTML$r
◎
"html" exists as error mode due to HTML forms requiring a non-terminating legacy encoder. The "html" error mode causes a sequence to be emitted that cannot be distinguished from legitimate input and can therefore lead to silent data loss. Developers are strongly encouraged to use the UTF-8 encoding to prevent this from happening. [HTML]
</p>

<hr>

<div class="algo">
<p>
`~queueを処理する@
~algoは、
所与の
⇒＃
`符号化法$の［ `復号器$ ／ `符号化器$ ］の~instance %~coder
`入出力~queue$ %入力,
`入出力~queue$ %出力,
`~error~mode$ %~mode
◎終
に対し：
◎
To process a queue given an encoding’s decoder or encoder instance encoderDecoder, I/O queue input, I/O queue output, and error mode mode:
</p>
<ol>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %入力 )
◎
↓</li>
			<li>
%結果 ~LET `~itemを処理する$( %~item, %~coder, %入力, %出力, %~mode )
◎
Let result be the result of processing an item with the result of reading from input, encoderDecoder, input, output, and mode.
</li>
			<li>
~IF［
%結果 ~NEQ `継続-$i
］
⇒
~RET %結果
◎
If result is not continue, then return result.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~itemを処理する@
~algoは、
所与の
⇒＃
`~item$ %~item,
`符号化法$の［ `符号化器$／`復号器$ ］の~instance %~coder,
`入出力~queue$ %入力,
`入出力~queue$ %出力,
`~error~mode$ %~mode
◎終
に対し：
◎
To process an item given an item item, encoding’s encoder or decoder instance encoderDecoder, I/O queue input, I/O queue output, and error mode mode:
</p>
<ol>
	<li>
~Assert：
%~coder は`符号化器$の~instanceであるならば、
%~mode ~NEQ `replacement^l
◎
Assert: if encoderDecoder is an encoder instance, mode is not "replacement".
</li>
	<li>
~Assert：
%~coder は`復号器$の~instanceであるならば、
%~mode ~NEQ `html^l
◎
Assert: if encoderDecoder is a decoder instance, mode is not "html".
</li>
	<li>
~Assert：
%~coder は`符号化器$の~instanceであるならば、
%~item は`~surrogate$ではない。
◎
Assert: if encoderDecoder is an encoder instance, item is not a surrogate.
</li>
	<li>
%結果 ~LET %~coder の`~handler$( %入力, %~item )
◎
Let result be the result of running encoderDecoder’s handler on input and item.
</li>
	<li>
~IF［
%結果 ~EQ `完遂d$i
］
⇒＃
`入出力~queueに~pushする$( %出力, « `~EoQ$ » )；
~RET %結果
◎
If result is finished:
• Push end-of-queue to output.
• Return result.
</li>
	<li>
<p>
~IF［
%結果 は 1 個~以上の`~item$からなる
］：
◎
Otherwise, if result is one or more items:
</p>
		<ol>
			<li>
~Assert：
%~coder は`復号器$の~instanceであるならば、
%結果 は`~surrogate$を包含しない。
◎
Assert: if encoderDecoder is a decoder instance, result does not contain any surrogates.
</li>
			<li>
`入出力~queueに~pushする$( %出力, %結果 )
◎
Push result to output.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%結果 は `~error$i である
］：
◎
Otherwise, if result is an error,＼
</p>
		<ol>
			<li>
<p>
%~mode に応じて：
◎
switch on mode and run the associated steps:
</p>
				<ul class="switch">
					<li>
`replacement^l
⇒
`入出力~queueに~pushする$( %出力, « `FFFD^U `�^smb » )
◎
"replacement"
• Push U+FFFD (�) to output.
</li>
					<li>
<p>
`html^l：
</p>
						<ol>
							<li>
%数字列 ~LET ［
%結果 を成す`~cp$
］の`値$cpを基数 10 で最短に表現するような，［
1 個以上の［
`30^X `0^smb 〜 `39^X `9^smb
］たちが成す~byte列
</li>
							<li>
`入出力~queueに~pushする$( %出力, 次の並びが成す~byte列 )
⇒＃
`26^X `&amp;^smb,
`23^X `#^smb,
%数字列,
`3B^X `;^smb
</li>
						</ol>
◎
"html"
• Push 0x26 (&amp;), 0x23 (#), followed by the shortest sequence of 0x30 (0) to 0x39 (9), inclusive, representing result’s code point’s value in base ten, followed by 0x3B (;) to output.
</li>
					<li>
`fatal^l
⇒
~RET %結果
◎
"fatal"
• Return result.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
~RET `継続-$i
◎
Return continue.
</li>
</ol>
</div>

		</section>
		<section id="names-and-labels">
<h3 title="Names and labels">4.2. 名前と~label</h3>

<p>
~UAは、
下の表tに挙げる各［
`符号化法$, それ用の`~label$すべて
］を~supportするモノトスル
— 他の`符号化法$や`~label$は~supportしないモノトスル。
◎
The table below lists all encodings and their labels user agents must support. User agents must not support any other encodings or labels.
</p>

<p class="note">注記：
どの符号化法についても、
次が満たされる
⇒
その`名前$を`~ASCII小文字~化$した結果 ~IN それ用の`~label$たちが成す集合
◎
For each encoding, ASCII-lowercasing its name yields one of its labels.
</p>

<p class="trans-note">【
加えて、
異なる符号化法~用の~labelどうしが一致することはない。
】</p>

<p>
作者は、
`UTF-8$n `符号化法$を利用しなければナラナイ
— その利用が識別されるよう，
それ用の`~label$のうち `utf-8^lb （`~ASCII大小無視$）を利用しなければナラナイ。
◎
Authors must use the UTF-8 encoding and must use its (ASCII case-insensitive) "utf-8" label to identify it.
</p>

<p>
［
新たな~protocol／
新たな形式／
新たな文脈において配備される既存の形式
］には、
`UTF-8$n `符号化法$を排他的に利用しなければナラナイ。
そのような［
~protocolや形式
］が公開する`符号化法$の［
`名前$／`~label$
］は、
`utf-8^lb でなければナラナイ。
◎
New protocols and formats, as well as existing formats deployed in new contexts, must use the UTF-8 encoding exclusively. If these protocols and formats need to expose the encoding’s name or label, they must expose it as "utf-8".
</p>

<div class="algo">
<p>
`~labelから符号化法を取得する@
~algoは、
所与の
( 文字列 %~label )
に対し：
◎
To get an encoding from a string label, run these steps:
</p>
<ol>
	<li>
%~label ~SET `前後の~ASCII空白~列を剥ぐ$( %~label )
◎
Remove any leading and trailing ASCII whitespace from label.
</li>
	<li>
~IF［
%~label は［
下の表tを成すいずれかの~label
］に`~ASCII大小無視$で合致する
］
⇒
~RET 合致した~labelに対応する`符号化法$
◎
If label is an ASCII case-insensitive match for any of the labels listed in the table below, then return the corresponding encoding;＼
</li>
	<li>
~RET `失敗^i
◎
otherwise return failure.
</li>
</ol>
</div>

<p class="note">注記：
この［
~labelを`符号化法$に対応付ける~algo
］は、
`Unicode Technical Standard #22 § 1.4＠https://www.unicode.org/reports/tr22/tr22-8.html#Charset_Alias_Matching$
によるものより基本的かつ制約的である
— 配備-済みな内容と互換になることが必要yなので。
◎
This is a more basic and restrictive algorithm of mapping labels to encodings than section 1.4 of Unicode Technical Standard #22 prescribes, as that is necessary to be compatible with deployed content.
</p>

<table id="encoding-labels"><thead>
<tr><th>
名前
◎
Name
<th>
~label
◎
Labels

<tbody><tr><th colspan="2" scope="rowgroup">
`~~標準の符号化法＠#the-encoding$
◎
The Encoding
<tr><td>`UTF-8$n
<td>`unicode-1-1-utf-8^lb
`unicode11utf8^lb
`unicode20utf8^lb
`utf-8^lb
`utf8^lb
`x-unicode20utf8^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`旧来の単-~byte符号化法＠#legacy-single-byte-encodings$
◎
Legacy single-byte encodings
<tr><td>`IBM866$n
<td>`866^lb
`cp866^lb
`csibm866^lb
`ibm866^lb
<tr><td>`ISO-8859-2$n
<td>`csisolatin2^lb
`iso-8859-2^lb
`iso-ir-101^lb
`iso8859-2^lb
`iso88592^lb
`iso_8859-2^lb
`iso_8859-2:1987^lb
`l2^lb
`latin2^lb
<tr><td>`ISO-8859-3$n
<td>`csisolatin3^lb
`iso-8859-3^lb
`iso-ir-109^lb
`iso8859-3^lb
`iso88593^lb
`iso_8859-3^lb
`iso_8859-3:1988^lb
`l3^lb
`latin3^lb
<tr><td>`ISO-8859-4$n
<td>`csisolatin4^lb
`iso-8859-4^lb
`iso-ir-110^lb
`iso8859-4^lb
`iso88594^lb
`iso_8859-4^lb
`iso_8859-4:1988^lb
`l4^lb
`latin4^lb
<tr><td>`ISO-8859-5$n
<td>`csisolatincyrillic^lb
`cyrillic^lb
`iso-8859-5^lb
`iso-ir-144^lb
`iso8859-5^lb
`iso88595^lb
`iso_8859-5^lb
`iso_8859-5:1988^lb
<tr><td>`ISO-8859-6$n
<td>`arabic^lb
`asmo-708^lb
`csiso88596e^lb
`csiso88596i^lb
`csisolatinarabic^lb
`ecma-114^lb
`iso-8859-6^lb
`iso-8859-6-e^lb
`iso-8859-6-i^lb
`iso-ir-127^lb
`iso8859-6^lb
`iso88596^lb
`iso_8859-6^lb
`iso_8859-6:1987^lb
<tr><td>`ISO-8859-7$n
<td>`csisolatingreek^lb
`ecma-118^lb
`elot_928^lb
`greek^lb
`greek8^lb
`iso-8859-7^lb
`iso-ir-126^lb
`iso8859-7^lb
`iso88597^lb
`iso_8859-7^lb
`iso_8859-7:1987^lb
`sun_eu_greek^lb
<tr><td>`ISO-8859-8$n
<td>`csiso88598e^lb
`csisolatinhebrew^lb
`hebrew^lb
`iso-8859-8^lb
`iso-8859-8-e^lb
`iso-ir-138^lb
`iso8859-8^lb
`iso88598^lb
`iso_8859-8^lb
`iso_8859-8:1988^lb
`visual^lb
<tr><td>`ISO-8859-8-I$n
<td>`csiso88598i^lb
`iso-8859-8-i^lb
`logical^lb
<tr><td>`ISO-8859-10$n
<td>`csisolatin6^lb
`iso-8859-10^lb
`iso-ir-157^lb
`iso8859-10^lb
`iso885910^lb
`l6^lb
`latin6^lb
<tr><td>`ISO-8859-13$n
<td>`iso-8859-13^lb
`iso8859-13^lb
`iso885913^lb
<tr><td>`ISO-8859-14$n
<td>`iso-8859-14^lb
`iso8859-14^lb
`iso885914^lb
<tr><td>`ISO-8859-15$n
<td>`csisolatin9^lb
`iso-8859-15^lb
`iso8859-15^lb
`iso885915^lb
`iso_8859-15^lb
`l9^lb
<tr><td>`ISO-8859-16$n
<td>`iso-8859-16^lb
<tr><td>`KOI8-R$n
<td>`cskoi8r^lb
`koi^lb
`koi8^lb
`koi8-r^lb
`koi8_r^lb
<tr><td>`KOI8-U$n
<td>`koi8-ru^lb
`koi8-u^lb
<tr><td>`macintosh$n
<td>`csmacintosh^lb
`mac^lb
`macintosh^lb
`x-mac-roman^lb
<tr><td>`windows-874$n
<td>`dos-874^lb
`iso-8859-11^lb
`iso8859-11^lb
`iso885911^lb
`tis-620^lb
`windows-874^lb
<tr><td>`windows-1250$n
<td>`cp1250^lb
`windows-1250^lb
`x-cp1250^lb
<tr><td>`windows-1251$n
<td>`cp1251^lb
`windows-1251^lb
`x-cp1251^lb
<tr><td>`windows-1252$n
<td>`ansi_x3.4-1968^lb
`ascii^lb
`cp1252^lb
`cp819^lb
`csisolatin1^lb
`ibm819^lb
`iso-8859-1^lb
`iso-ir-100^lb
`iso8859-1^lb
`iso88591^lb
`iso_8859-1^lb
`iso_8859-1:1987^lb
`l1^lb
`latin1^lb
`us-ascii^lb
`windows-1252^lb
`x-cp1252^lb
<tr><td>`windows-1253$n
<td>`cp1253^lb
`windows-1253^lb
`x-cp1253^lb
<tr><td>`windows-1254$n
<td>`cp1254^lb
`csisolatin5^lb
`iso-8859-9^lb
`iso-ir-148^lb
`iso8859-9^lb
`iso88599^lb
`iso_8859-9^lb
`iso_8859-9:1989^lb
`l5^lb
`latin5^lb
`windows-1254^lb
`x-cp1254^lb
<tr><td>`windows-1255$n
<td>`cp1255^lb
`windows-1255^lb
`x-cp1255^lb
<tr><td>`windows-1256$n
<td>`cp1256^lb
`windows-1256^lb
`x-cp1256^lb
<tr><td>`windows-1257$n
<td>`cp1257^lb
`windows-1257^lb
`x-cp1257^lb
<tr><td>`windows-1258$n
<td>`cp1258^lb
`windows-1258^lb
`x-cp1258^lb
<tr><td>`x-mac-cyrillic$n
<td>`x-mac-cyrillic^lb
`x-mac-ukrainian^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`旧来の複-~byte~Chinese（簡体字） 符号化法＠#legacy-multi-byte-chinese-(simplified)-encodings$
◎
Legacy multi-byte Chinese (simplified) encodings
<tr><td>`GBK$n
<td>`chinese^lb
`csgb2312^lb
`csiso58gb231280^lb
`gb2312^lb
`gb_2312^lb
`gb_2312-80^lb
`gbk^lb
`iso-ir-58^lb
`x-gbk^lb
<tr><td>`gb18030$n
<td>`gb18030^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`旧来の複-~byte~Chinese（繁体字）符号化法＠#legacy-multi-byte-chinese-(traditional)-encodings$
◎
Legacy multi-byte Chinese (traditional) encodings
<tr><td>`Big5$n
<td>`big5^lb
`big5-hkscs^lb
`cn-big5^lb
`csbig5^lb
`x-x-big5^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`旧来の複-~byte~Japanese符号化法＠#legacy-multi-byte-japanese-encodings$
◎
Legacy multi-byte Japanese encodings
<tr><td>`EUC-JP$n
<td>`cseucpkdfmtjapanese^lb
`euc-jp^lb
`x-euc-jp^lb
<tr><td>`ISO-2022-JP$n
<td>`csiso2022jp^lb
`iso-2022-jp^lb
<tr><td>`Shift_JIS$n
<td>`csshiftjis^lb
`ms932^lb
`ms_kanji^lb
`shift-jis^lb
`shift_jis^lb
`sjis^lb
`windows-31j^lb
`x-sjis^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`旧来の複-~byte~Korean符号化法＠#legacy-multi-byte-korean-encodings$
◎
Legacy multi-byte Korean encodings
<tr><td>`EUC-KR$n
<td>`cseuckr^lb
`csksc56011987^lb
`euc-kr^lb
`iso-ir-149^lb
`korean^lb
`ks_c_5601-1987^lb
`ks_c_5601-1989^lb
`ksc5601^lb
`ksc_5601^lb
`windows-949^lb

<tbody><tr><th colspan="2" scope="rowgroup">
`旧来の諸々の符号化法＠#legacy-miscellaneous-encodings$
◎
Legacy miscellaneous encodings
<tr><td>`replacement$n
<td>`csiso2022kr^lb
`hz-gb-2312^lb
`iso-2022-cn^lb
`iso-2022-cn-ext^lb
`iso-2022-kr^lb
`replacement^lb
<tr><td>`UTF-16BE$n
<td>`unicodefffe^lb
`utf-16be^lb
<tr><td>`UTF-16LE$n
<td>`csunicode^lb
`iso-10646-ucs-2^lb
`ucs-2^lb
`unicode^lb
`unicodefeff^lb
`utf-16^lb
`utf-16le^lb
<tr><td>`x-user-defined$n
<td>`x-user-defined^lb
</table>

<p class="note">注記：
すべての`符号化法$とそれら用の`~label$は、
規範的でない資源
`indexes.json$
としても可用である。
◎
All encodings and their labels are also available as non-normative encodings.json resource.
</p>

<p class="note" id="supported-encodings">注記：
~supportされる`符号化法$たちが成す集合は、
首に［
この標準の開発を開始した時点で，主要な各~browser~engineが~supportしていた集合
］たちの交差集合に基づくが，符号化法のうち［
稀にしか正当に利用されていない
］かつ［
攻撃にも利用され得る
］ものは除去してある。
一部の符号化法については、
既存の~Web内容が利用している~~確たる証拠はなく，それを含めることには疑問がある。
すなわち、
それらは，各~browserから広く~supportされていたが、
~Web内容から広く利用されているかどうかは不明瞭である。
しかしながら、
`単-~byte符号化法$のうち［
各~browserが広く~supportしていたもの／
ISO 8859 ~~族の一部を成すもの
］を意欲的に除去する労は，為されていない。
特に，次に挙げるものを含める必要性は、
既存の内容を~supportする目的においては疑わしいが，除去する計画は無い
⇒＃
`IBM866$n,
`macintosh$n,
`x-mac-cyrillic$n,
`ISO-8859-3$n,
`ISO-8859-10$n,
`ISO-8859-14$n,
`ISO-8859-16$n
◎
The set of supported encodings is primarily based on the intersection of the sets supported by major browser engines when the development of this standard started, while removing encodings that were rarely used legitimately but that could be used in attacks. The inclusion of some encodings is questionable in the light of anecdotal evidence of the level of use by existing Web content. That is, while they have been broadly supported by browsers, it is unclear if they are broadly used by Web content. However, an effort has not been made to eagerly remove single-byte encodings that were broadly supported by browsers or are part of the ISO 8859 series. In particular, the necessity of the inclusion of IBM866, macintosh, x-mac-cyrillic, ISO-8859-3, ISO-8859-10, ISO-8859-14, and ISO-8859-16 is doubtful for the purpose of supporting existing content, but there are no plans to remove these.
</p>

		</section>
		<section id="output-encodings">
<h3 title="Output encodings">4.3. 出力~符号化法</h3>

<div class="algo">
<p>
`符号化法から出力~符号化法を取得する@
~algoは、
所与の
( `符号化法$ %符号化法 )
に対し：
◎
To get an output encoding from an encoding encoding, run these steps:
</p>
<ol>
	<li>
~IF［
%符号化法 ~IN
{ `replacement$n, `UTF-16BE$n, `UTF-16LE$n【！`UTF-16BE/LE$n】 }
］
⇒
~RET `UTF-8$n
◎
If encoding is replacement or UTF-16BE/LE, then return UTF-8.
</li>
	<li>
~RET %符号化法
◎
Return encoding.
</li>
</ol>

<p class="note">注記：
この~algoは、
それを必要とする［
~URL構文解析 ／ ~HTML~form提出
］にて有用になる。
◎
The get an output encoding algorithm is useful for URL parsing and HTML form submission, which both need exactly this.
</p>
</div>

		</section>
	</section>
	<section id="indexes">
<h2 title="Indexes">5. 索引</h2>

<p>
ほとんどの旧来の`符号化法$では、
【当の符号化法に特有な】
`索引@
が利用される。
`索引$とは、
~entryたちが成す有順序~listであり，それを成す各~entryは［
~pointer, それに対応する~cp
］からなる。
`索引$の中では、
~pointerは一意であり，~cpは重複し得る。
◎
Most legacy encodings make use of an index. An index is an ordered list of entries, each entry consisting of a pointer and a corresponding code point. Within an index pointers are unique and code points can be duplicated.
</p>

<p class="note">注記：
効率的な実装は、
各`符号化法$に対し，
2 つの`索引$
— その`復号器$に最適化されたそれ, その`符号化器$に最適化されたそれ —
を備えることになろう。
◎
An efficient implementation likely has two indexes per encoding. One optimized for its decoder and one for its encoder.
</p>

<div class="algo">
<p>
`索引$
【の~dataを供する資源（以下を見よ）】
から，~pointerとそれに対応する~cpを見出すためには：
</p>
<ol>
	<li>
%行l~list は，その資源の内容を `000A^U `LF^cn で一連の “行l” に分割した結果とする。
</li>
	<li>
%行l~list から［
空~行l ／ `0023^U `#^smb で開始される行l
］をすべて除去する。
</li>
	<li>
<p>
%行l~list の各~行lに対し，行lを `0009^U `TAB^cn で分割した結果を成す：
</p>
		<ul>
			<li>
1 個目の~itemが~pointer（ 10 進表記）を与える。
</li>
			<li>
2 個目の~itemが対応する~cp（ 16 進表記）を与える。
</li>
			<li>
他の~itemは関連しない。
</li>
		</ul>
	</li>
</ol>

◎
To find the pointers and their corresponding code points in an index, let lines be the result of splitting the resource’s contents on U+000A LF. Then remove each item in lines that is the empty string or starts with U+0023 (#). Then the pointers and their corresponding code points are found by splitting each item in lines on U+0009 TAB. The first subitem is the pointer (as a decimal number) and the second is the corresponding code point (as a hexadecimal number). Other subitems are not relevant.
</div>

<p class="note">注記：
各`索引$の冒頭には、
変更の有無を記すため，
`Identifier^i と `Date^i
【識別子と日付】
が記されている。
`Identifier^i の変化は、
`索引$に変更が加えられたことを表す。
◎
To signify changes an index includes an Identifier and a Date. If an Identifier has changed, so has the index.
</p>

<div class="algo">
%索引 の中で %~pointer が指す
`索引~cp@
とは、
%索引 内に %~pointer は［
在るならば，それに対応する~cp ／
無いならば ~NULL
］である。
◎
The index code point for pointer in index is the code point corresponding to pointer in index, or null if pointer is not in index.
</div>

<div class="algo">
%索引 の中で %~cp を指す
`索引~pointer@
とは、
%索引 内に %~cp に対応する~pointerは［
在るならば，それらのうち`最初の^em ~pointer ／
無いならば ~NULL
］である。
◎
The index pointer for codePoint in index is the first pointer corresponding to codePoint in index, or null if codePoint is not in index.
</div>

<div class="note" id="visualization">
<p>注記：
各 索引には，規範的でない視覚-化があり、
`索引~jis0208$には， `Shift_JIS$n 視覚-化も別にある。
加えて，基本多言語面（
BMP（ `Basic Multilingual Plane^en ）,
`0000^U 〜 `FFFF^U
）における被覆域の視覚-化もある。
ただし、［
`索引~gb18030範囲~群$ ／ `索引~ISO-2022-JP~katakana$
］には，これらの視覚-化はない。
◎
There is a non-normative visualization for each index other than index gb18030 ranges and index ISO-2022-JP katakana. index jis0208 also has an alternative Shift_JIS visualization. Additionally, there is visualization of the Basic Multilingual Plane coverage of each index other than index gb18030 ranges and index ISO-2022-JP katakana.
</p>

<table>
<caption>
視覚-化における凡例
◎
The legend for the visualizations is:
</caption>
<thead>
<tr><th>表示
<th>~~説明

<tbody class="_vis-visualizationlegend">
<tr><td><div class="_vis-unmapped"></div><td>
対応する~cpは無い。
◎
Unmapped

<tr><td><div class="_vis-mid"></div><td>
~UTF-8で 2 ~byte。
◎
Two bytes in UTF-8

<tr><td><div class="_vis-mid _vis-contiguous"></div><td>
~UTF-8で 2 ~byte, かつ
~cpは、
前の~pointerの~cpの直後に続く。
◎
Two bytes in UTF-8, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-upper"></div><td>
~UTF-8で 3 ~byte（私用領域でない）
◎
Three bytes in UTF-8 (non-PUA)

<tr><td><div class="_vis-upper _vis-contiguous"></div><td>
~UTF-8で 3 ~byte（私用領域でない）, かつ
~cpは、
前の~pointerの~cpの直後に続く。
◎
Three bytes in UTF-8 (non-PUA), code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-pua"></div><td>
私用領域
◎
Private Use

<tr><td><div class="_vis-pua _vis-contiguous"></div><td>
私用領域, かつ
~cpは、
前の~pointerの~cpの直後に続く。
◎
Private Use, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-astral"></div><td>
~UTF-8で 4 ~byte
◎
Four bytes in UTF-8

<tr><td><div class="_vis-astral _vis-contiguous"></div><td>
~UTF-8で 4 ~byte, かつ
~cpは、
前の~pointerの~cpの直後に続く。
◎
Four bytes in UTF-8, code point follows immediately the code point
of previous pointer

<tr><td><div class="_vis-duplicate"></div><td>
先に現れているものと重複する~cpに対応する。
◎
Duplicate code point already mapped at an earlier index

<tr><td><div class="_vis-compatibility"></div><td>
~CJK互換漢字（ `CJK Compatibility Ideograph^en ）
◎
CJK Compatibility Ideograph

<tr><td><div class="_vis-ext"></div><td>
~CJK統合漢字拡張 A
◎
CJK Unified Ideographs Extension A
</table>

</div>

<p>
この仕様が定義する`索引$のうち，`単-~byte索引$でないものには、
それぞれに自前の~tableがあり，以下に与えられる：
【視覚-化／被覆域の~tableは巨大なことに注意】
◎
These are the indexes defined by this specification, excluding index single-byte, which have their own table:
</p>

<table id="_index_list" class="grid-table"><thead>
<tr><th>`名前$
<th>`索引$
<th>視覚-化
<th>基本多言語面（ BMP ）の被覆域
<th>備考
<tbody>

<tr><td>`索引~Big5@
<td>`Big5$idx
<td>
これは、
香港増補字符集（ `Hong Kong Supplementary Character Set^en ）, および他の共通な拡張と一式で、
~Big5標準に合致する。
◎
This matches the Big5 standard in combination with the Hong Kong Supplementary Character Set and other common extensions.

<tr><td>`索引~EUC-KR@
<td>`EUC-KR$idx
<td>
これは、
KS X 1001 標準と~~統合~Hangul~code（ `Unified Hangul Code^en ）に合致する。
Windows Codepage 949 としても共通的に知られている。
これ全体で、
~Unicodeの~Hangul音節文字（ `Hangul Syllables^en ）~blockを覆う。
~Hangul~blockのうち，視覚-化における左上隅が~pointer 9026 にあるもの
【？】
は、
~Unicode順に並ぶ。
`Taken separately^en 【？】,
この索引における残りの~Hangul音節文字も、
~Unicode順に並ぶ。
◎
This matches the KS X 1001 standard and the Unified Hangul Code, more commonly known together as Windows Codepage 949. It covers the Hangul Syllables block of Unicode in its entirety. The Hangul block whose top left corner in the visualization is at pointer 9026 is in the Unicode order. Taken separately, the rest of the Hangul syllables in this index are in the Unicode order, too.

<tr><td>`索引~gb18030@
<td>`gb18030$idx
<td>
これは、
2 ~byteに符号化される~cp用の GB18030-2022 標準に合致する
— ただし，配備-済みな内容と互換になるよう、
`A3^X `A0^X は `3000^U に対応付けられる。
この索引~全体で、
~Unicodeの~CJK統合漢字（ `CJK Unified Ideographs^en ）~blockを覆う。
その~block内の~entryのうち，視覚-化における（最初の） `3000^U より上または左にあるものは、
~Unicode順に並ぶ。
◎
This matches the GB18030-2022 standard for code points encoded as two bytes, except for 0xA3 0xA0 which maps to U+3000 to be compatible with deployed content. This index covers the CJK Unified Ideographs block of Unicode in its entirety. Entries from that block that are above or to the left of (the first) U+3000 in the visualization are in the Unicode order.

<tr><td>`索引~gb18030範囲~群@
<td>`gb18030-ranges$idx
<td>
この`索引$は、
すべての~cpを挙げていくと項目数が 100 万を超えてしまう点で，他のすべてと異なる
（ 207 面の範囲と自明な範囲検査により，きれいに表現できるが）。
したがって、
4 ~byteに符号化される~cp用に限り，表面的には GB18030-2000 標準に合致する。
その改訂 GB18030-2005 用の変更は、
この索引が付随する［
`索引~gb18030範囲~群~cp$, `索引~gb18030範囲~群~pointer$
］用の~algoにより，~inlineに取扱われる。
その改訂 GB18030-2022 用の変更に関する取扱いも、
私用領域に属する~cpへ対応付けられる~byte列の個数をこれ以上~増やさないようにするため，他と異なる
— 関連な［
私用領域に属する各~cp
］は、
それまでの対応付けとの互換性を保全するよう，
`~gb18030符号化器$において ある表tを通して直に対応付けられる。
◎
This index works different from all others. Listing all code points would result in over a million items whereas they can be represented neatly in 207 ranges combined with trivial limit checks. It therefore only superficially matches the GB18030-2000 standard for code points encoded as four bytes. The change for the GB18030-2005 revision is handled inline by the index gb18030 ranges code point and index gb18030 ranges pointer algorithms below that accompany this index. And the changes for the GB18030-2022 revision are handled differently again to not further increase the number of byte sequences mapping to Private Use code points. The relevant Private Use code points are mapped in the gb18030 encoder directly through a side table to preserve compatibility with how they were mapped before.

<tr><td>`索引~jis0208@
<td>`jis0208$idx
<td>
IBM と NEC によるかつての~proprietary拡張も含まれている， JIS X 0208 標準。
◎
This is the JIS X 0208 standard including formerly proprietary extensions from IBM and NEC.

<tr><td>`索引~jis0212@
<td>`jis0212$idx
<td>
JIS X 0212 標準。
これを利用するのは、
`~EUC-JP復号器$に限られる
（符号化器からは利用されない）
— 広く~supportされていないので。
◎
This is the JIS X 0212 standard. It is only used by the EUC-JP decoder due to lack of widespread support elsewhere.

<tr><td>`索引~ISO-2022-JP~katakana@
<td>`iso-2022-jp-katakana$idx
<td>
これは、
~Unicode正規化~形（ `Normalization Form^en ） KC に従って，半角~katakanaを全角~katakanaに対応付ける。
ただし、［
`FF9E^U ／ `FF9F^U
］は［
`309B^U ／ `309C^U
］に対応付ける
— ［
`3099^U ／ `309A^U
］ではなく
【これらはいずれも、濁点／半濁点】
。
これを利用するのは、
`~ISO-2022-JP符号化器$に限られる。
`UNICODE$r
◎
This maps halfwidth to fullwidth katakana as per Unicode Normalization Form KC, except that U+FF9E and U+FF9F map to U+309B and U+309C rather than U+3099 and U+309A. It is only used by the ISO-2022-JP encoder. [UNICODE]
</table>

<div class="algo">
<p>
%~pointer が指す
`索引~gb18030範囲~群~cp@
は、
次の手続きが返す~cpである：
◎
The index gb18030 ranges code point for pointer is the return value of these steps:
</p>
<ol>
	<li>
~IF［
39419 ~LT %~pointer ~LT 189000
］~OR［
1237575 ~LT %~pointer
］
⇒
~RET ~NULL
◎
If pointer is greater than 39419 and less than 189000, or pointer is greater than 1237575, then return null.
</li>
	<li>
~IF［
%~pointer ~EQ 7457
］
⇒
~RET ~cp `E7C7^U
◎
If pointer is 7457, then return code point U+E7C7.
</li>
	<li>
%~offset ~LET `索引~gb18030範囲~群$の中で %~pointer を超えない最後の~pointer
◎
Let offset be the last pointer in index gb18030 ranges that is less than or equal to pointer and let code point offset be its corresponding code point.
</li>
	<li>
%~cp~offset ~LET %~offset が指している~cp
◎
↑</li>
	<li>
~RET 値が［
%~cp~offset ~PLUS %~pointer ~MINUS %~offset
］なる~cp
◎
Return a code point whose value is code point offset + pointer − offset.
</li>
</ol>
</div>

<div class="algo">
<p>
%~cp を指す
`索引~gb18030範囲~群~pointer@
は、
次の手続きが返す~pointerである：
◎
The index gb18030 ranges pointer for codePoint is the return value of these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `E7C7^U
］
⇒
~RET ~pointer 7457
◎
If codePoint is U+E7C7, then return pointer 7457.
</li>
	<li>
%~offset ~LET `索引~gb18030範囲~群$の中で %~cp を超えない最後の~cp
◎
Let offset be the last code point in index gb18030 ranges that is less than or equal to codePoint and let pointer offset be its corresponding pointer.
</li>
	<li>
%~pointer~offset ~LET %~offset に対応する~pointer
◎
↑</li>
	<li>
~RET 値が［
%~pointer~offset ~PLUS %~cp ~MINUS %~offset
］なる~pointer
◎
Return a pointer whose value is pointer offset + codePoint − offset.
</li>
</ol>
</div>

<div class="algo">
<p>
%~cp を指す
`索引~Shift_JIS~pointer@
は、
次の手続きが返す~pointerである：
◎
The index Shift_JIS pointer for codePoint is the return value of these steps:
</p>
<ol>
	<li>
<p>
%索引 ~LET `索引~jis0208$ から［
~pointerが範囲 { 8272 〜 8835 } に入る~entry
］すべてを除外した索引
◎
Let index be index jis0208 excluding all entries whose pointer is in the range 8272 to 8835, inclusive.
</p>

<p class="note">注記：
`索引~jis0208$は、
重複する~cpを包含するので、
これらの~entryの除外により，後続の~cpが利用されるようになる。
◎
The index jis0208 contains duplicate code points so the exclusion of these entries causes later code points to be used.
</p>
	</li>
	<li>
~RET %索引 の中で %~cp を指す`索引~pointer$
◎
Return the index pointer for codePoint in index.
</li>
</ol>
</div>

<div class="algo">
<p>
%~cp を指す
`索引~Big5~pointer@
は、
次の手続きが返す~pointerである：
◎
The index Big5 pointer for codePoint is the return value of these steps:
</p>
<ol>
	<li>
<p>
%索引 ~LET `索引~Big5$から［
~pointerが ( (`A1^X ~MINUS `81^X) ~MUL 157 ) 未満の~entry
］すべてを除外した索引
◎
Let index be index Big5 excluding all entries whose pointer is less than (0xA1 - 0x81) × 157.
</p>

<p class="note">注記：
香港増補字符集（ `Hong Kong Supplementary Character Set^en ）拡張を~literalとして返さないようにする。
◎
Avoid returning Hong Kong Supplementary Character Set extensions literally.
</p>
	</li>
	<li>
<p>
~IF［
%~cp ~IN
{ `2550^U, `255E^U, `2561^U, `256A^U, `5341^U, `5345^U }
］
⇒
~RET
%索引 の中で %~cp に対応する`最後の^em ~pointer
◎
If codePoint is U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345, return the last pointer corresponding to codePoint in index.
</p>

<p class="note">注記：
他にも重複している~cpはあるが、
それら用には，`最初の^em ~pointerが利用されることになる。
◎
There are other duplicate code points, but for those the first pointer is to be used.
</p>
	</li>
	<li>
~RET
%索引 の中で %~cp を指す`索引~pointer$
◎
Return the index pointer for codePoint in index.
</li>
</ol>
</div>

<hr>

<p class="note">注記：
すべての`索引$は、
規範的でない資源
`indexes.json$
としても可用である
（`索引~gb18030範囲~群$の形式は、
範囲を表現できるようにするため，少し異なるものにされている）。
◎
All indexes are also available as a non-normative indexes.json resource. (Index gb18030 ranges has a slightly different format here, to be able to represent ranges.)
</p>

	</section>
	<section id="specification-hooks">
<h2 title="Hooks for standards">6. 他の標準~用の~hook</h2>

<div class="note">

<p>注記：
次に挙げる各種~algo（以下に定義される）は、
他の仕様からの~~利用が意図されている：
◎
The algorithms defined below (UTF-8 decode, UTF-8 decode without BOM, UTF-8 decode without BOM or fail, and UTF-8 encode) are intended for usage by other standards.
</p>

<ul>
	<li>
`~UTF-8復号する$
⇒
新たな形式は、
復号するときは，これを利用すること
（次項は別として）。
◎
For decoding, UTF-8 decode is to be used by new formats.＼
</li>
	<li>
`~BOMはそのままに~UTF-8復号する$／
`~BOMも失敗-もそのままに~UTF-8復号する$
⇒
形式や~protocolの中の識別子や~byte列~用には、
これらを利用すること。
◎
For identifiers or byte sequences within a format or protocol, use UTF-8 decode without BOM or UTF-8 decode without BOM or fail.
</li>
	<li>
`~UTF-8符号化する$
⇒
符号化するときは、
これを利用すること。
◎
For encoding, UTF-8 encode is to be used.
</li>
</ul>

<p>
各~標準は、
`~UTF-8符号化する$（および，旧来の`符号化法を利用して符号化する$）~algoに渡す［
入力~用の`入出力~queue$†
］が，実質的には`~scalar値$が成す入出力~queueである
— すなわち`~surrogate$は包含しない —
ことを確保すること。
◎
Standards are to ensure that the input I/O queues they pass to UTF-8 encode (as well as the legacy encode) are effectively I/O queues of scalar values, i.e., they contain no surrogates.
</p>

<p>
これらの~hook
（および，`~Unicodeに復号する$, `符号化法を利用して符号化する$）は、［
入力~用の入出力~queue†
］の全体が消費されるまで~call元を阻む。
各~出力~tokenを，~streamの中に~pushされるたびに利用するためには、
~call元は，［
当の~hookを呼出すときに，空な［
出力~用の入出力~queue††
］を伴わせて、
そこから`並列的$に読取る
］こと。
`~BOMも失敗-もそのままに~UTF-8復号する$を利用するときには，少し~careが必要になることに注意
— 復号している間に~errorが見出された場合、
`~EoQ$は，［
出力~用の入出力~queue
］の中へ~pushされなくなるので。
【† 各~algoにおける %入出力~queue 引数／†† %出力 引数】
◎
These hooks (as well as decode and encode) will block until the input I/O queue has been consumed in its entirety. In order to use the output tokens as they are pushed into the stream, callers are to invoke the hooks with an empty output I/O queue and read from it in parallel. Note that some care is needed when using UTF-8 decode without BOM or fail, as any error found during decoding will prevent the end-of-queue item from ever being pushed into the output I/O queue.
</p>
</div>

<div class="algo">
<p>
`~UTF-8復号する@
~algoは、
所与の
( `入出力~queue$`~byte^tA %入出力~queue, `入出力~queue$`~scalar値^tA %出力（省略時は « » ）)
に対し：
◎
To UTF-8 decode an I/O queue of bytes ioQueue given an optional I/O queue of scalar values output (default « »), run these steps:
</p>
<ol>
	<li>
%~buffer ~LET `入出力~queueを覗見る$( %入出力~queue, 3 )
◎
Let buffer be the result of peeking three bytes from ioQueue,＼
↓converted to a byte sequence.
</li>
	<li>
~IF［
( %~buffer[0], %~buffer[1], %~buffer[2] ) ~EQ ( `EF^X, `BB^X, `BF^X )
］
⇒
`入出力~queueから~item列を読取る$( %入出力~queue, 3 )
（結果は利用しない。）
◎
If buffer is 0xEF 0xBB 0xBF, then read three bytes from ioQueue. (Do nothing with those bytes.)
</li>
	<li>
%復号器 ~LET `UTF-8$n の`復号器$の新たな~instance
◎
↓</li>
	<li>
`~queueを処理する$( %復号器, %入出力~queue, %出力, `replacement^l )
◎
Process a queue with an instance of UTF-8’s decoder, ioQueue, output, and "replacement".
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~BOMはそのままに~UTF-8復号する@
~algoは、
所与の
( `入出力~queue$`~byte^tA %入出力~queue, `入出力~queue$`~scalar値^tA %出力（省略時は « » ）)
に対し：
◎
To UTF-8 decode without BOM an I/O queue of bytes ioQueue given an optional I/O queue of scalar values output (default « »), run these steps:
</p>
<ol>
	<li>
%復号器 ~LET `UTF-8$n の`復号器$の新たな~instance
◎
↓</li>
	<li>
`~queueを処理する$( %復号器, %入出力~queue, %出力, `replacement^l )
◎
Process a queue with an instance of UTF-8’s decoder, ioQueue, output, and "replacement".
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~BOMも失敗-もそのままに~UTF-8復号する@
~algoは、
所与の
( `入出力~queue$`~byte^tA %入出力~queue, `入出力~queue$`~scalar値^tA %出力（省略時は « » ）)
に対し：
◎
To UTF-8 decode without BOM or fail an I/O queue of bytes ioQueue given an optional I/O queue of scalar values output (default « »), run these steps:
</p>
<ol>
	<li>
%復号器 ~LET `UTF-8$n の`復号器$の新たな~instance
◎
↓</li>
	<li>
%~errorになり得る ~LET `~queueを処理する$( %復号器, %入出力~queue, %出力, `fatal^l )
◎
Let potentialError be the result of processing a queue with an instance of UTF-8’s decoder, ioQueue, output, and "fatal".
</li>
	<li>
~IF［
%~errorになり得る ~EQ `~error$i
］
⇒
~RET `失敗^i
◎
If potentialError is an error, then return failure.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~UTF-8符号化する@
~algoは、
所与の
( `入出力~queue$`~scalar値^tA %入出力~queue, `入出力~queue$`~byte^tA %出力（省略時は « » ）)
に対し
⇒
~RET `符号化法を利用して符号化する$( %入出力~queue, `UTF-8$n, %出力 )
◎
To UTF-8 encode an I/O queue of scalar values ioQueue given an optional I/O queue of bytes output (default « »), return the result of encoding ioQueue with encoding UTF-8 and output.
</p>
</div>

		<section id="legacy-hooks">
<h3 title="Legacy hooks for standards">6.1. 各~標準~用の旧来の~hook</h3>

<div class="note">
<p>注記：
各~標準は、
互換性を得るために必要な場合を除き，次に挙げる~algoを利用しないことが強く奨励される
⇒＃
`~Unicodeに復号する$／
`~BOMを~sniffする$／
`符号化法を利用して符号化する$
◎
Standards are strongly discouraged from using decode, BOM sniff, and encode, except as needed for compatibility.＼
</p>

<p>
これらの旧来の~hookを必要としている標準は、
次の利用も必要になると見込まれる
⇒＃
`~labelから符号化法を取得する$（~labelを`符号化法$に転換するため）／
`符号化法から出力~符号化法を取得する$（`符号化法$を別の`符号化法$ — `符号化法を利用して符号化する$ときに渡すそれに相応しいもの — に転換するため）
◎
Standards needing these legacy hooks will most likely also need to use get an encoding (to turn a label into an encoding) and get an output encoding (to turn an encoding into another encoding that is suitable to pass into encode).
</p>

<p>
［
~URL~percent-符号化法の極めて~~限定的な事例
］用に，符号化器~errorに対する~customな取扱いが必要になる。
［
`符号化器を取得する$／`符号化するか失敗する$
］~algoは、
そのために利用される。
他の~algoは、
直に利用されないことになる。
◎
For the extremely niche case of URL percent-encoding, custom encoder error handling is needed. The get an encoder and encode or fail algorithms are to be used for that. Other algorithms are not to be used directly.
</p>
</div>

<div class="algo">
<p>
`~Unicodeに復号する@
~algoは、
所与の
( `入出力~queue$`~byte^tA %入出力~queue, ~fallback符号化法 %符号化法, `入出力~queue$`~scalar値^tA %出力（省略時は « » ）)
に対し：
◎
To decode an I/O queue of bytes ioQueue given a fallback encoding encoding and an optional I/O queue of scalar values output (default « »), run these steps:
</p>
<ol>
	<li>
%~BOM符号化法 ~LET `~BOMを~sniffする$( %入出力~queue )
◎
Let BOMEncoding be the result of BOM sniffing ioQueue.
</li>
	<li>
<p>
~IF［
%~BOM符号化法 ~NEQ ~NULL
］：
◎
If BOMEncoding is non-null:
</p>
		<ol>
			<li>
%符号化法 ~SET %~BOM符号化法
◎
Set encoding to BOMEncoding.
</li>
			<li>
%N ~LET ［
%~BOM符号化法 ~EQ `UTF-8$n ならば 3 ／
~ELSE_ 2
］
◎
↓</li>
			<li>
`入出力~queueから~item列を読取る$( %入出力~queue, %N )
（結果は利用しない。）
◎
Read three bytes from ioQueue, if BOMEncoding is UTF-8; otherwise read two bytes. (Do nothing with those bytes.)
</li>
		</ol>

<p class="note">注記：
配備-済みな内容との互換性を得るため、
~BOMは他より~~優先される。
HTTP が利用される文脈においては、
これは，
`<code class="header">Content-Type</code>`
~headerの意味論に対する違反である。
◎
For compatibility with deployed content, the byte order mark is more authoritative than anything else. In a context where HTTP is used this is in violation of the semantics of the `Content-Type` header.
</p>
	</li>
	<li>
%復号器 ~LET %符号化法 の`復号器$の新たな~instance
◎
↓</li>
	<li>
`~queueを処理する$( %復号器, %入出力~queue, %出力, `replacement^l )
◎
Process a queue with an instance of encoding’s decoder, ioQueue, output, and "replacement".
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~BOMを~sniffする@
~algoは、
所与の
( `入出力~queue$`~byte^tA %入出力~queue )
に対し：
◎
To BOM sniff an I/O queue of bytes ioQueue, run these steps:
</p>
<ol>
	<li>
%~BOM ~LET 次の結果を~byte列に変換した結果
⇒
`入出力~queueを覗見る$( %入出力~queue, 3 )
◎
Let BOM be the result of peeking 3 bytes from ioQueue, converted to a byte sequence.
</li>
	<li>
<p>
下の表t内の
~EACH( %行 )
に対し，挙げられた順に
⇒
~IF［
%~BOM は %行 の 1 列目に与える~byte列`から開始して$byteいる
］
⇒
~RET %行 の 2 列目に与える`符号化法$
◎
For each of the rows in the table below, starting with the first one and going down, if BOM starts with the bytes given in the first column, then return the encoding given in the cell in the second column of that row. Otherwise, return null.
</p>

<div>
<table><thead>
<tr>
<th>~BOM
<th>符号化法
<tbody>

<tr><td>`EF^X `BB^X `BF^X
<td>`UTF-8$n

<tr><td>`FE^X `FF^X
<td>`UTF-16BE$n

<tr><td>`FF^X `FE^X
<td>`UTF-16LE$n
</table>

◎
Byte order mark｜Encoding
0xEF 0xBB 0xBF｜UTF-8
0xFE 0xFF｜UTF-16BE
0xFF 0xFE｜UTF-16LE
</div>

	</li>
	<li>
~RET ~NULL
◎
↑</li>
</ol>

<p class="note">注記：
`~Unicodeに復号する$~algoには、［
~BOMが見出されたので、
供された符号化法は利用していないこと
］を~call元に通信する仕方が無い。
この~hookは、
その事への対処法であり，`~Unicodeに復号する$前に呼出されることになる†。
それは、［
~BOMが見出されたなら それに対応する符号化法 ／
~ELSE_ ~NULL
］を返す。
【†特に，~HTMLの構文解析~algoは、入力~streamを~Unicodeに復号する前に，`符号化法を~sniffする~algo$にて これを呼出す。】
◎
This hook is a workaround for the fact that decode has no way to communicate back to the caller that it has found a byte order mark and is therefore not using the provided encoding. The hook is to be invoked before decode, and it will return an encoding corresponding to the byte order mark found, or null otherwise.
</p>
</div>

<hr>

<div class="algo">
<p>
`符号化法を利用して符号化する@
~algoは、
所与の
(
`入出力~queue$`~scalar値^tA %入出力~queue,
`符号化法$ %符号化法,
`入出力~queue$`~byte^tA %出力（省略時は « » ）
)
に対し：
◎
To encode an I/O queue of scalar values ioQueue given an encoding encoding and an optional I/O queue of bytes output (default « »), run these steps:
</p>
<ol>
	<li>
%符号化器 ~LET `符号化器を取得する$( %符号化法 )
◎
Let encoder be the result of getting an encoder from encoding.
</li>
	<li>
`~queueを処理する$( %符号化器, %入出力~queue, %出力, `html^l )
◎
Process a queue with encoder, ioQueue, output, and "html".
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
これは、
~HTML~form用の旧来の~hookである。
`~UTF-8符号化する$を被せた方が、
決して `~error$i を誘発しないので安全である。
`URL$r
◎
This is a legacy hook for HTML forms. Layering UTF-8 encode on top is safe as it never triggers errors. [HTML]
</p>
</div>

<hr>

<div class="algo">
<p>
`符号化器を取得する@
~algoは、
所与の
( `符号化法$ %符号化法 )
に対し：
◎
To get an encoder from an encoding encoding:
</p>
<ol>
	<li>
~Assert：
%符号化法 ~NIN { `replacement$n, `UTF-16BE$n, `UTF-16LE$n【！`UTF-16BE/LE$n】 }
◎
Assert: encoding is not replacement or UTF-16BE/LE.
</li>
	<li>
~RET %符号化法 の`符号化器$の~instance
◎
Return an instance of encoding’s encoder.
</li>
</ol>
</div>

<div class="algo">
<p>
`符号化するか失敗する@
~algoは、
所与の
( `入出力~queue$`~scalar値^tA %入出力~queue, `符号化器$の~instance %符号化器 , `入出力~queue$`~byte^tA %出力 )
に対し：
◎
To encode or fail an I/O queue of scalar values ioQueue given an encoder instance encoder and an I/O queue of bytes output, run these steps:
</p>
<ol>
	<li>
%~errorになり得る ~LET `~queueを処理する$( %符号化器, %入出力~queue, %出力, `fatal^l )
◎
Let potentialError be the result of processing a queue with encoder, ioQueue, output, and "fatal".
</li>
	<li>
`入出力~queueに~pushする$( %出力, « `~EoQ$ » )
◎
Push end-of-queue to output.
</li>
	<li>
~IF［
%~errorになり得る は `~error$i である
］
⇒
~RET `~error$i の`~cp$の`値$cp
◎
If potentialError is an error, then return error’s code point’s value.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

<div class="note" id="pit-of-iso-2022-jp">

<p>注記：
これは、
~URL~percent-符号化法 `URL$r
用の旧来の~hookである。
~call元は、
`符号化器$の~instanceを生きたまま保つ必要がある
— `~ISO-2022-JP符号化器$が `~error$i を返すときに とり得る状態は、
2 つあるので。
それはまた，~call元が［
~errorを何らかの仕方で符号化するような~byte列
］を発する場合、
それらの各~byteは，
範囲 { `00^X 〜 `7F^X } に入る, かつ［
`0E^X, `0F^X, `1B^X, `5C^X, `7E^X
］以外にする必要があることを意味する。
◎
This is a legacy hook for URL percent-encoding. The caller will have to keep an encoder instance alive as the ISO-2022-JP encoder can be in two different states when returning an error. That also means that if the caller emits bytes to encode the error in some way, these have to be in the range 0x00 to 0x7F, inclusive, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E. [URL]
</p>

<p>
特に，`~ISO-2022-JP符号化器$が `Roman$i 状態にある下で `~error$i を返す場合、
~call元は，
`5C^X `\^smb を出力し得ない
— それは、
`005C^U `\^smb として復号されなくなるので。
この理由から，`符号化するか失敗する$を意図されない目的に利用している応用
— `005C^U `\^smb を置換~構文【~escape法】（例： `\u2603^c ）の一部として利用している，~JSや~CSSなど —
は、
次のいずれかで~~対処すること
⇒＃
`~ISO-2022-JP符号化器$を そのような置換~schemeと併用しないよう，~careする／
置換~構文が，符号化器を必ず通過するようにする（~URL~percent-符号化法とは対照的に）
◎
In particular, if upon returning an error the ISO-2022-JP encoder is in the Roman state, the caller cannot output 0x5C (\) as it will not decode as U+005C (\). For this reason, applications using encode or fail for unintended purposes ought to take care to prevent the use of the ISO-2022-JP encoder in combination with replacement schemes, such as those of JavaScript and CSS, that use U+005C (\) as part of the replacement syntax (e.g., \u2603) or make sure to pass the replacement syntax through the encoder (in contrast to URL percent-encoding).
</p>

<p>
返り値は、［
`~error$i が生じなければ ~NULL ／
~ELSE_ 符号化し得ない`~cp$を表現している数値
］になる。
数値が返された場合，~call元は、［
同じ`符号化器$の~instance, 新たな出力~用の`入出力~queue$
］を給して，再び呼出す必要があることになる。
◎
The return value is either the number representing the code point that could not be encoded or null, if there was no error. When it returns non-null the caller will have to invoke it again, supplying the same encoder instance and a new output I/O queue.
</p>
</div>
</div>

		</section>
	</section>
	<section id="api">
<h2 title="API">7. ~API</h2>

<p>
この節では Web IDL `WEBIDL$r の各種用語を利用する。
~browser~UAは、
この~APIを~supportするモノトスル。
~JS実装は、
この~APIを~supportするベキである。
他の~UA／~programming言語は、
必要に応じて相応しい~API（これではないかもしれない）を利用することが奨励される。
◎
This section uses terminology from Web IDL. Browser user agents must support this API. JavaScript implementations should support this API. Other user agents or programming languages are encouraged to use an API suitable to their needs, which might not be this one. [WEBIDL]
</p>

<div class="example">
<p>
次の例は、
`TextEncoder$I ~objを利用して，文字列の配列を `ArrayBuffer$I に符号化する。
結果は次を内容とする `Uint8Array$I になる：
<span class="block">
先頭が（ `Uint32Array$I としての）文字列の個数，その後は：
<span class="block">
最初の文字列の（ `Uint32Array$I としての）長さ,
`UTF-8$n に符号化されたその文字列~data，<br>
2 番目の文字列の（ `Uint32Array$I としての）長さ,
その文字列~data，<br>
…
</span>
等々と続く。
</span>
◎
The following example uses the TextEncoder object to encode an array of strings into an ArrayBuffer. The result is a Uint8Array containing the number of strings (as a Uint32Array), followed by the length of the first string (as a Uint32Array), the UTF-8 encoded string data, the length of the second string (as a Uint32Array), the string data, and so on.
</p>

<pre class="lang-js">
function encodeArrayOfStrings(%strings) {
  var %encoder, %encoded, %len, %bytes, %view, %offset;

  %encoder = new TextEncoder();
  %encoded = [];

  %len = Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %strings.length; %i++) {
    %len += Uint32Array.BYTES_PER_ELEMENT;
    %encoded[%i] = %encoder.encode(%strings[%i]);
    %len += %encoded[%i].byteLength;
  }

  %bytes = new Uint8Array(%len);
  %view = new DataView(%bytes.buffer);
  %offset = 0;

  %view.setUint32(%offset, %strings.length);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %encoded.length; %i += 1) {
    %len = %encoded[%i].byteLength;
    %view.setUint32(%offset, %len);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %bytes.set(%encoded[%i], %offset);
    %offset += %len;
  }
  return %bytes.buffer;
}
</pre>

<p>
次の例は、［［
前の例, または `UTF-8$n 以外の符号化法に等価な~algo
］により生産される形式に符号化された~data
］を含んでいる `ArrayBuffer$I を復号して、
~~元の，文字列たちが成す配列に戻す。
◎
The following example decodes an ArrayBuffer containing data encoded in the format produced by the previous example, or an equivalent algorithm for encodings other than UTF-8, back into an array of strings.
</p>

<pre class="lang-js">
function decodeArrayOfStrings(%buffer, %encoding) {
  var %decoder, %view, %offset, %num_strings, %strings, %len;

  %decoder = new TextDecoder(%encoding);
  %view = new DataView(%buffer);
  %offset = 0;
  %strings = [];

  %num_strings = %view.getUint32(%offset);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %num_strings; %i++) {
    %len = %view.getUint32(%offset);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %strings[%i] = %decoder.decode(
      new DataView(%view.buffer, %offset, %len));
    %offset += %len;
  }
  return %strings;
}
</pre>
</div>

		<section id="interface-mixin-textdecodercommon">
<h3 title="Interface mixin TextDecoderCommon">7.1. ~interface~mixin `TextDecoderCommon^I</h3>

<pre class="idl">
interface mixin `TextDecoderCommon@I {
  readonly attribute `DOMString$ `encoding$m;
  readonly attribute `boolean$ `fatal$m;
  readonly attribute `boolean$ `ignoreBOM$m;
};
</pre>

<p>
`TextDecoderCommon$I ~interface~mixinは、［
`TextDecoder$I, `TextDecoderStream$I
］~objで共有される共通な取得子を定義する。
これらの各~objには、
次が結付けられる：

◎
The TextDecoderCommon interface mixin defines common getters that are shared between TextDecoder and TextDecoderStream objects. These objects have an associated:
</p>

<dl class="def-list">
	<dt>
`符号化法@dec
◎
encoding
</dt>
	<dd>
`符号化法$。
◎
An encoding.
</dd>

	<dt>
`復号器@dec
◎
decoder
</dt>
	<dd>
`復号器$の~instance。
◎
A decoder instance.
</dd>

	<dt>
`入出力~queue@dec
◎
I/O queue
</dt>
	<dd>
`入出力~queue$`~byte^tA。
◎
An I/O queue of bytes.
</dd>

	<dt>
`~BOMは無視するか@dec
◎
ignore BOM
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
A boolean, initially false.
</dd>

	<dt>
`~BOMを見つけたか@dec
◎
BOM seen
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
A boolean, initially false.
</dd>

	<dt>
`~error~mode@dec
◎
error mode
</dt>
	<dd>
`~error~mode$
— 初期~時は `replacement^l とする。
◎
An error mode, initially "replacement".
</dd>
</dl>

<div class="algo">
<p>
`入出力~queueを直列化する@
~algoは、
所与の
( `TextDecoderCommon$I %復号器, `入出力~queue$`~scalar値^tA %入出力~queue )
に対し：
◎
The serialize I/O queue algorithm, given a TextDecoderCommon decoder and an I/O queue of scalar values ioQueue, runs these steps:
</p>
<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %入出力~queue )
◎
Let item be the result of reading from ioQueue.
</li>
			<li>
~IF［
%~item ~NEQ `~EoQ$
］
⇒
~RET %出力
◎
If item is end-of-queue, then return output.
</li>
			<li>
<p>
~IF［
%復号器 の`符号化法$dec ~IN { `UTF-8$n, `UTF-16BE$n, `UTF-16LE$n【！`UTF-16BE/LE$n】 }
］~AND［
%復号器 の`~BOMは無視するか$dec ~EQ ~F
］~AND［
%復号器 の`~BOMを見つけたか$dec ~EQ ~F
］：
◎
If decoder’s encoding is UTF-8 or UTF-16BE/LE, and decoder’s ignore BOM and BOM seen are false:
</p>
				<ol>
					<li>
%復号器 の`~BOMを見つけたか$dec ~SET ~T
◎
Set decoder’s BOM seen to true.
</li>
					<li>
~IF［
%~item ~EQ `FEFF^U `BOM^cn
］
⇒
~CONTINUE
◎
If item is U+FEFF, then continue.
</li>
				</ol>
			</li>
			<li>
%出力 に %~item を付加する
◎
Append item to output.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
この~algoは、
~APIの利用者に もっと制御を与えるため，［
~platformの他所で利用される，`~Unicodeに復号する$ ~algo
］とは、
~BOMの取扱いに関して意図的に異なるものにされている。
◎
This algorithm is intentionally different with respect to BOM handling from the decode algorithm used by the rest of the platform to give API users more control.
</p>
</div>

<hr>

<p class="algo">
`encoding@m
取得子~手続きは
⇒
~RET `~ASCII小文字~化する$( コレの`符号化法$decの`名前$ )
◎
The encoding getter steps are to return this’s encoding’s name, ASCII lowercased.
</p>

<p class="algo">
`fatal@m
取得子~手続きは
⇒
~RET ~IS［
コレの`~error~mode$dec ~EQ `fatal^l
］
◎
The fatal getter steps are to return true if this’s error mode is "fatal"; otherwise false.
</p>

<p class="algo">
`ignoreBOM@m
取得子~手続きは
⇒
~RET コレの`~BOMは無視するか$dec
◎
The ignoreBOM getter steps are to return this’s ignore BOM.
</p>

		</section>
		<section id="interface-textdecoder">
<h3 title="Interface TextDecoder">7.2. ~interface `TextDecoder^I</h3>

<pre class="idl">
dictionary `TextDecoderOptions@I {
  `boolean$ `fatal@mb = false;
  `boolean$ `ignoreBOM@mb = false;
};

dictionary `TextDecodeOptions@I {
  `boolean$ `stream@mb = false;
};

[`Exposed$=*]
interface `TextDecoder@I {
  `TextDecoder$mc(optional `DOMString$ %label = "utf-8", optional `TextDecoderOptions$I %options = {});

  `USVString$ `decode$m(optional `AllowSharedBufferSource$I %input, optional `TextDecodeOptions$I %options = {});
};

`TextDecoder$I includes `TextDecoderCommon$I;
</pre>

<p class="trans-note">【
`利用-中な~browserでこの特能を試す＠Encoding-test.html$
】</p>

<p>
各 `TextDecoder$I ~objには、
真偽値をとる
`書出さないか@dec
が結付けられ，初期~時は ~F をとるとする。
◎
A TextDecoder object has an associated do not flush, which is a boolean, initially false.
</p>

<dl class="domintro">
	<dt>%decoder = `new TextDecoder$m([%label = "utf-8" [, %options]])</dt>
	<dd>
新たな `TextDecoder$I ~obj を返す。
◎
Returns a new TextDecoder object.
</dd>
	<dd>
%label が次を満たす場合、
`RangeError$E が`投出-$される
⇒
［
~labelでない
］~OR［
`replacement$n 用の~labelである
］
◎
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`符号化法$decの`名前$を小文字~化して返す。
◎
Returns encoding’s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
`~error~mode$dec ~EQ `fatal^l ならば ~T を返す。
他の場合は ~F を返す。
◎
Returns true if error mode is "fatal"; otherwise false.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
`~BOMは無視するか$decの値を返す。
◎
Returns the value of ignore BOM.
</dd>

	<dt>%decoder . `decode([input [, options]])$m</dt>
	<dd>
%input を `符号化法$decの`復号器$にかけた結果を返す。
%input を断片化して処理するときは、
%options の `stream$mb ~memberを ~T にした下で，この~method 0 回~以上~呼出してから， %options を省略して（または その `stream$mb ~memberを ~F にして）
1 回だけ呼出すことで行える。
後者の呼出nに %input もないならば、
両~引数とも省略するのが最も簡明になる。
◎
Returns the result of running encoding’s decoder. The method can be invoked zero or more times with options’s stream set to true, and then once without options’s stream (or set to false), to process a fragmented input. If the invocation without options’s stream (or set to false) has no input, it’s clearest to omit both arguments.
</dd>
	<dd class="example">
<pre class="lang-js">
var %string = "", %decoder = new TextDecoder(%encoding), %buffer;
while(%buffer = next_chunk()) {
  %string += %decoder.decode(%buffer, {stream:true});
}
%string += %decoder.decode(); // ~EoQ
</pre>

	</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l の下で，
`符号化法$decの`復号器$が `~error$i を返した場合、
`TypeError$E が`投出-$される。
◎
If the error mode is "fatal" and encoding’s decoder returns error, throws a TypeError.
</dd>
</dl>

<div class="algo">
<p>
`new TextDecoder(label, options)@m
構築子~手続きは：
◎
The new TextDecoder(label, options) constructor steps are:
</p>
<ol>
	<li>
%符号化法 ~LET `~labelから符号化法を取得する$( %label )
◎
Let encoding be the result of getting an encoding from label.
</li>
	<li>
~IF［
%符号化法 ~IN { `失敗^i, `replacement$n }
］
⇒
~THROW `RangeError$E
◎
If encoding is failure or replacement, then throw a RangeError.
</li>
	<li>
コレの `符号化法$dec ~SET %符号化法
◎
Set this’s encoding to encoding.
</li>
	<li>
~IF［
%options[ "`fatal$mb" ] ~EQ ~T
］
⇒
コレの`~error~mode$dec ~SET `fatal^l
◎
If options["fatal"] is true, then set this’s error mode to "fatal".
</li>
	<li>
コレの `~BOMは無視するか$dec ~SET %options[ "`ignoreBOM$mb" ]
◎
Set this’s ignore BOM to options["ignoreBOM"].
</li>
</ol>
</div>

<div class="algo">
<p>
`decode(input, options)@m
~method~手続きは：
◎
The decode(input, options) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`書出さないか$dec ~EQ ~F
］
⇒＃
コレの`復号器$dec ~SET コレの`符号化法$decの`復号器$の新たな~instance；
コレの`入出力~queue$dec ~SET `入出力~queue$`~byte^tA « `~EoQ$ »；
コレの`~BOMを見つけたか$dec ~SET ~F
◎
If this’s do not flush is false, then set this’s decoder to a new instance of this’s encoding’s decoder, this’s I/O queue to the I/O queue of bytes « end-of-queue », and this’s BOM seen to false.
</li>
	<li>
コレの`書出さないか$dec ~SET %options[ "`stream$mb" ]
◎
Set this’s do not flush to options["stream"].
</li>
	<li>
<p>
~IF［
%input ~NEQ ε
］：
◎
If input is given,＼
</p>
		<ol>
			<li>
%複製 ~LET %input に`保持された~byte列の複製を取得する$
◎
↓</li>
			<li>
`入出力~queueに~pushする$( コレの`入出力~queue$dec, %複製 )
◎
then push a copy of input to this’s I/O queue.
</li>
		</ol>

<p class="note">注記：
実装には、
この複製を避けるよう実装することが強く奨励される。
そうするときは、
%input が変更されても，後の `decode()$m の~callに影響しないようにする必要がある。
◎
Implementations are strongly encouraged to use an implementation strategy that avoids this copy. When doing so they will have to make sure that changes to input do not affect future calls to decode().
</p>

<p class="warning" id="sharedarraybuffer-warning">
`SharedArrayBuffer^I ~objにより公開される~memoryは、［
実装~用に概して利用される~programming言語
］の~memory~modelに要求される `data race freedom^en な特質を固守しない。
実装するときは、
`SharedArrayBuffer^I ~objが公開する~memoryに~accessするときに適切な便宜性†を利用するよう~careすること。
【†そのような~accessに その種の特質が備わるよう指示する，言語~特有な構文など】
◎
The memory exposed by SharedArrayBuffer objects does not adhere to data race freedom properties required by the memory model of programming languages typically used for implementations. When implementing, take care to use the appropriate facilities when accessing memory exposed by SharedArrayBuffer objects.
</p>
	</li>
	<li>
%出力 ~LET `入出力~queue$`~scalar値^tA « `~EoQ$ »
◎
Let output be the I/O queue of scalar values « end-of-queue ».
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( コレの`入出力~queue$dec )
◎
Let item be the result of reading from this’s I/O queue.
</li>
			<li>
<p>
~IF［
%~item ~EQ `~EoQ$
］~AND［
コレの`書出さないか$dec ~EQ ~T
］
⇒
~RET `入出力~queueを直列化する$( コレ, %出力 )
◎
If item is end-of-queue and this’s do not flush is true, then return the result of running serialize I/O queue with this and output.
</p>

<p class="note">注記：
~streamingでは、［
コレの`書出さないか$dec ~EQ ~T
］のとき，ここで`~EoQ$を取扱うことなく，それを ~F にしない仕方で働く。
この仕方により，コレの`復号器$decは、
後続な呼出nにおいて，この~algoの最初の段で一新されることなく，その状態は保全される。
◎
The way streaming works is to not handle end-of-queue here when this’s do not flush is true and to not set it to false. That way in a subsequent invocation this’s decoder is not set anew in the first step of the algorithm and its state is preserved.
</p>
			</li>
			<li>
%結果 ~LET `~itemを処理する$( %~item, コレの`復号器$dec, コレの`入出力~queue$dec, %出力, コレの`~error~mode$dec )
◎
Otherwise:
◎
Let result be the result of processing an item with item, this’s decoder, this’s I/O queue, output, and this’s error mode.
</li>
			<li>
~IF［
%結果 ~EQ `完遂d$i
］
⇒
~RET `入出力~queueを直列化する$( コレ, %出力 )
◎
If result is finished, then return the result of running serialize I/O queue with this and output.
</li>
			<li>
~IF［
%結果 ~EQ `~error$i
］
⇒
~THROW `TypeError$E
◎
Otherwise, if result is error, throw a TypeError.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="interface-mixin-textencodercommon">
<h3 title="Interface mixin TextEncoderCommon">7.3. ~interface~mixin `TextEncoderCommon^I</h3>

<pre class="idl">
interface mixin `TextEncoderCommon@I {
  readonly attribute `DOMString$ `~encoding0$m;
};
</pre>

<p>
`TextEncoderCommon$I ~interface~mixinは、［
`TextEncoder$I, `TextEncoderStream$I
］~objで共有される共通な取得子を定義する。
◎
The TextEncoderCommon interface mixin defines common getters that are shared between TextEncoder and TextEncoderStream objects.
</p>

<p class="algo">
`~encoding0@m
取得子~手続きは
⇒
~RET `utf-8^l
◎
The encoding getter steps are to return "utf-8".
</p>

		</section>
		<section id="interface-textencoder">
<h3 title="Interface TextEncoder">7.4. ~interface `TextEncoder^I</h3>

<pre class="idl">
dictionary `TextEncoderEncodeIntoResult@I {
  `unsigned long long$ `read@m;
  `unsigned long long$ `written@m;
};

[`Exposed$=*]
interface `TextEncoder@I {
  `TextEncoder$mc();

  [NewObject] `Uint8Array$ `encode$m(optional `USVString$ %input = "");
  `TextEncoderEncodeIntoResult$I `encodeInto$m(`USVString$ %source, [`AllowShared$] `Uint8Array$ %destination);
};
`TextEncoder$I includes `TextEncoderCommon$I;
</pre>

<p class="note">注記：
`TextEncoder$I ~objは、
`UTF-8$n しか~supportしないので，構築子に %label 引数は無い。
また、
~scalar値~bufferを要求する`符号化器$は無いので， `stream^mb ~optionもない。
◎
A TextEncoder object offers no label argument as it only supports UTF-8. It also offers no stream option as no encoder requires buffering of scalar values.
</p>

<hr>

<dl class="domintro">
	<dt>%encoder = `new TextEncoder()$m</dt>
	<dd>
新たな `TextEncoder$I ~obj を返す。
◎
Returns a new TextEncoder object.
</dd>

	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l を返す。
◎
Returns "utf-8".
</dd>

	<dt>%encoder . `encode([input = ""])$m</dt>
	<dd>
%input を `UTF-8$n の`符号化器$にかけた結果を返す。
◎
Returns the result of running UTF-8’s encoder.
</dd>

	<dt>%encoder . `encodeInto(source, destination)$m</dt>
	<dd>
%source を渡して`~UTF-8符号化器$を走らせた結果を %destination の中に格納して，その進捗を~objとして返す
— 結果の
⇒＃
`read$m は %source から変換された`~cu$数になる ／
`written$m は %destination 内で改変された~byte数になる
◎
Runs the UTF-8 encoder on source, stores the result of that operation into destination, and returns the progress made as an object wherein read is the number of converted code units of source and written is the number of bytes modified in destination.
</dd>
</dl>

<p class="algo">
`new TextEncoder()@m
構築子~手続きは、
何もしない。
◎
The new TextEncoder() constructor steps are to do nothing.
</p>

<div class="algo">
<p>
`encode(input)@m
~method~手続きは：
◎
The encode(input) method steps are:
</p>
<ol>
	<li>
%入力 ~LET `入出力~queueに変換する$( %input )
◎
Convert input to an I/O queue of scalar values.
</li>
	<li>
%出力 ~LET `入出力~queue$`~byte^tA « `~EoQ$ »
◎
Let output be the I/O queue of bytes « end-of-queue ».
</li>
	<li>
%符号化器 ~LET `UTF-8$n の`符号化器$の新たな~instance
◎
↓</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %入力 )
◎
Let item be the result of reading from input.
</li>
			<li>
%結果 ~LET `~itemを処理する$( %~item, %符号化器, %入力, %出力, `fatal^l )
◎
Let result be the result of processing an item with item, an instance of the UTF-8 encoder, input, output, and "fatal".
</li>
			<li>
<p>
~Assert：
%結果 は `~error$i でない
◎
Assert: result is not an error.
</p>

<p class="note">注記：
`~UTF-8符号化器$が `~error$i を返すことはない。
◎
The UTF-8 encoder cannot return error.
</p>
			</li>
			<li>
<p>
~IF［
%結果 ~EQ `完遂d$i
］：
</p>
				<ol>
					<li>
%出力 ~SET %出力 を~byte列に`変換する$
</li>
					<li>
~RET `~buffer~sourceを作成する$( `Uint8Array$I, %出力, コレに`関連な~realm$ )
</li>
				</ol>
◎
If result is finished, then convert output into a byte sequence and return a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`encodeInto(source, destination)@m
~method~手続きは：
◎
The encodeInto(source, destination) method steps are:
</p>
<ol>
	<li>
%read ~LET 0
◎
Let read be 0.
</li>
	<li>
%written ~LET 0
◎
Let written be 0.
</li>
	<li>
%符号化器 ~LET `~UTF-8符号化器$の新たな~instance
◎
Let encoder be an instance of the UTF-8 encoder.
</li>
	<li>
<p>
%利用されない~queue ~LET `入出力~queue$`~scalar値^tA « `~EoQ$ »
◎
Let unused be the I/O queue of scalar values « end-of-queue ».
</p>

<p class="note">注記：
以下で呼出される`~handler$~algoには，この引数が要求されるが、
`~UTF-8符号化器$は，それを利用しない。
◎
The handler algorithm invoked below requires this argument, but it is not used by the UTF-8 encoder.
</p>
	</li>
	<li>
%source ~SET `入出力~queueに変換する$( %source )
◎
Convert source to an I/O queue of scalar values.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %source )
◎
Let item be the result of reading from source.
</li>
			<li>
%結果 ~LET %符号化器 の`~handler$( %利用されない~queue, %~item )
◎
Let result be the result of running encoder’s handler on unused and item.
</li>
			<li>
~IF［
%結果 ~EQ `完遂d$i
］
⇒
~BREAK
◎
If result is finished, then break.
◎
Otherwise:
</li>
			<li>
~IF［
%written ~PLUS %結果 を成す~byte数 ~GT %destination の`~byte長さ$BS
］
⇒
~BREAK
◎
If destination’s byte length − written is greater than or equal to the number of bytes in result:
</li>
			<li>
%read ~INCBY ［
%~item ~LTE `FFFF^U ならば 1 ／
~ELSE_ 2
］
◎
• If item is greater than U+FFFF, then increment read by 2.
• Otherwise, increment read by 1.
</li>
			<li>
<p>
`配列~buffer~viewの中へ~byte列を書込む$( %destination, %結果, %written )
◎
• Write the bytes in result into destination, with startingOffset set to written.
</p>

<p class="warning">
上述した `SharedArrayBuffer^I ~obj用の`警告＠#sharedarraybuffer-warning$を見よ。
◎
See the warning for SharedArrayBuffer objects above.
</p>

			</li>
			<li>
%written ~INCBY %結果 を成す~byte数
◎
• Increment written by the number of bytes in result.
◎
Otherwise, break.
</li>
		</ol>
	</li>
	<li>
~RET « `read$m → %read, `written$m → %written »
◎
Return «[ "read" → read, "written" → written ]».
</li>
</ol>
</div>

<div class="example">
<p>
`encodeInto()$m ~methodを利用すれば、
文字列を既存の `ArrayBuffer$I ~objの中へ符号化できる。
下における様々な詳細は，読者への宿題として残しておくが、
この例は，この~methodの用-法の一つをデモる：
◎
The encodeInto() method can be used to encode a string into an existing ArrayBuffer object. Various details below are left as an exercise for the reader, but this demonstrates an approach one could take to use this method:
</p>

<pre class="lang-js">
function convertString(%buffer, %input, %callback) {
  let %bufferSize = 256,
      %bufferStart = malloc(%buffer, %bufferSize),
      %writeOffset = 0,
      %readOffset = 0;
  while (true) {
    const view = new Uint8Array(%buffer, %bufferStart + %writeOffset, %bufferSize - %writeOffset),
          {%read, %written} = cachedEncoder.encodeInto(%input.substring(%readOffset), view);
    %readOffset += %read;
    %writeOffset += %written;
    if (%readOffset === %input.length) {
      %callback(%bufferStart, %writeOffset);
      free(%buffer, %bufferStart);
      return;
    }
    %bufferSize *= 2;
    %bufferStart = realloc(%buffer, %bufferStart, %bufferSize);
  }
}
</pre>
</div>

		</section>
		<section id="interface-textdecoderstream">
<h3 title="Interface TextDecoderStream">7.5. ~interface `TextDecoderStream$I</h3>

<pre class="idl">
[`Exposed$=*]
interface `TextDecoderStream@I {
  `TextDecoderStream$mc(optional `DOMString$ %label = "utf-8", optional `TextDecoderOptions$I %options = {});
};
`TextDecoderStream$I includes `TextDecoderCommon$I;
`TextDecoderStream$I includes `GenericTransformStream$I;
</pre>

<dl class="domintro">
	<dt>%decoder = new <a href="#dom-textdecoderstream">TextDecoderStream([%label = "utf-8" [, %options]])</a></dt>
	<dd>
新たな `TextDecoderStream$I ~objを返す。
◎
Returns a new TextDecoderStream object.
</dd>
	<dd>
%label が次を満たす場合、
`RangeError$E が`投出-$される
⇒
［
~labelでない
］~OR［
`replacement$n 用の~labelである
］
◎
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`符号化法$decの`名前$を小文字~化して返す。
◎
Returns encoding’s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
`~error~mode$dec ~EQ `fatal^l ならば ~T を返す。
他の場合は ~F を返す。
◎
Returns true if error mode is "fatal", and false otherwise.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
`~BOMは無視するか$decの値を返す。
◎
Returns the value of ignore BOM.
</dd>

	<dt>%decoder . `readable$m</dt>
	<dd>
`可読~stream$を返す。
その`~chunk$たちは、
`writable$m に書込まれた~chunkたちに対し，`符号化法$decの`復号器$を走らせた結果の文字列たちになる。
◎
Returns a readable stream whose chunks are strings resulting from running encoding’s decoder on the chunks written to writable.
</dd>

	<dt>%decoder . `writable$m</dt>
	<dd>
`可書~stream$を返す。
それは、
`AllowSharedBufferSource$I 型の~chunkたちを受容して
— `readable$m に可用にされる前に —
`符号化法$decの`復号器$にかける。

◎
Returns a writable stream which accepts AllowSharedBufferSource chunks and runs them through encoding’s decoder before making them available to readable.
</dd>
	<dd class="example">
<p>
これは概して、
`ReadableStream$I ~sourceの `pipeThrough$m ~methodを介して利用されることになる。
◎
Typically this will be used via the pipeThrough() method on a ReadableStream source.
</p>

<pre class="lang-js">
var %decoder = new TextDecoderStream(%encoding);
byteReadable
  .pipeThrough(%decoder)
  .pipeTo(%textWritable);
</pre>

</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l
かつ`符号化法$decの`復号器$は `~error$i を返す場合、
`readable$m, `writable$m
とも `TypeError$E で~errorにされることになる。
◎
If the error mode is "fatal" and encoding’s decoder returns error, both readable and writable will be errored with a TypeError.
</dd>
</dl>

<div class="algo">
<p>
`new TextDecoderStream(label, options)@m
構築子~手続きは：
◎
The new TextDecoderStream(label, options) constructor steps are:
</p>
<ol>
	<li>
%符号化法 ~LET `~labelから符号化法を取得する$( %label )
◎
Let encoding be the result of getting an encoding from label.
</li>
	<li>
~IF［
%符号化法 ~IN { `失敗^i, `replacement$n }
］
⇒
~THROW `RangeError$E
◎
If encoding is failure or replacement, then throw a RangeError.
</li>
	<li>
コレの`符号化法$dec ~SET %符号化法
◎
Set this’s encoding to encoding.
</li>
	<li>
~IF［
%options[ "`fatal$mb" ] ~EQ ~T
］
⇒
コレの`~error~mode$dec ~SET `fatal^l
◎
If options["fatal"] is true, then set this’s error mode to "fatal".
</li>
	<li>
コレの`~BOMは無視するか$dec ~SET %options[ "`ignoreBOM$mb" ]
◎
Set this’s ignore BOM to options["ignoreBOM"].
</li>
	<li>
コレの`復号器$dec ~SET コレの`符号化法$decの`復号器$の新たな~instance
◎
Set this’s decoder to a new instance of this’s encoding’s decoder,＼
</li>
	<li>
コレの`入出力~queue$dec ~SET 新たな`入出力~queue$`~byte^tA
◎
and set this’s I/O queue to a new I/O queue.
</li>
	<li>
%形式変換~stream ~SET `新たな~obj$( `TransformStream$I, コレに`関連な~realm$ )
◎
↓</li>
	<li>
<p>
%形式変換~stream を`設定しておく$TS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`形式変換~algo^i ~SET 所与の
( %~chunk )
に対し，次を走らす~algo
⇒
`~chunkを復号して~enqueueする$( コレ, %~chunk )
</li>
			<li class="algo">
`書出n~algo^i ~SET 次を走らす~algo
⇒
`書出して~enqueueする$( コレ )
</li>
		</ul>
◎
Let transformAlgorithm be an algorithm which takes a chunk argument and runs the decode and enqueue a chunk algorithm with this and chunk.
◎
Let flushAlgorithm be an algorithm which takes no arguments and runs the flush and enqueue algorithm with this.
◎
Let transformStream be a new TransformStream.
◎
Set up transformStream with transformAlgorithm set to transformAlgorithm and flushAlgorithm set to flushAlgorithm.
</li>
	<li>
コレの`形式変換$ ~SET %形式変換~stream
◎
◎
Set this’s transform to transformStream.
</li>
</ol>
</div>

<div class="algo">
<p>
`~chunkを復号して~enqueueする@
~algoは、
所与の
( `TextDecoderStream$I ~obj %復号器, %~chunk )
に対し：
◎
The decode and enqueue a chunk algorithm, given a TextDecoderStream object decoder and a chunk, runs these steps:
</p>
<ol>
	<li>
%~buffer~source ~LET `~IDL値に変換する$( %~chunk, `AllowSharedBufferSource$I )
◎
Let bufferSource be the result of converting chunk to an AllowSharedBufferSource.
</li>
	<li>
<p>
`入出力~queueに~pushする$( %復号器 の`入出力~queue$dec, 次の結果 )
⇒
%~buffer~source に`保持された~byte列の複製を取得する$
◎
Push a copy of bufferSource to decoder’s I/O queue.
</p>

<p class="warning">
上述した `SharedArrayBuffer^I ~obj用の`警告＠#sharedarraybuffer-warning$を見よ。
◎
See the warning for SharedArrayBuffer objects above.
</p>
	</li>
	<li>
%出力 ~LET `入出力~queue$`~scalar値^tA « `~EoQ$ »
◎
Let output be the I/O queue of scalar values « end-of-queue ».
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %復号器 の`入出力~queue$dec )
◎
Let item be the result of reading from decoder’s I/O queue.
</li>
			<li>
<p>
~IF［
%~item ~EQ `~EoQ$
］：
◎
If item is end-of-queue:
</p>
				<ol>
					<li>
%出力~chunk ~LET `入出力~queueを直列化する$( コレ, %出力 )
◎
Let outputChunk be the result of running serialize I/O queue with decoder and output.
</li>
					<li>
~IF［
%出力~chunk は空でない
］
⇒
%復号器 の`形式変換$に`~chunkを~enqueueする$TS( %出力~chunk )
◎
If outputChunk is non-empty, then enqueue outputChunk in decoder’s transform.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
%結果 ~LET `~itemを処理する$( %~item, %復号器 の`復号器$dec, %復号器 の`入出力~queue$dec, %出力, %復号器 の`~error~mode$dec )
◎
Let result be the result of processing an item with item, decoder’s decoder, decoder’s I/O queue, output, and decoder’s error mode.
</li>
			<li>
~IF［
%結果 ~EQ `~error$i
］
⇒
~THROW `TypeError$E
◎
If result is error, then throw a TypeError.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`書出して~enqueueする@
~algoは、
入力 `ReadableStream$I ~objからの~dataの終端を取扱う
— それは、
所与の
( `TextDecoderStream$I ~obj %復号器 )
に対し：
◎
The flush and enqueue algorithm, which handles the end of data from the input ReadableStream object, given a TextDecoderStream object decoder, runs these steps:
</p>
<ol>
	<li>
%出力 ~LET `入出力~queue$`~scalar値^tA « `~EoQ$ »
◎
Let output be the I/O queue of scalar values « end-of-queue ».
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %復号器 の`入出力~queue$dec )
◎
Let item be the result of reading from decoder’s I/O queue.
</li>
			<li>
%結果 ~LET `~itemを処理する$( %~item, %復号器 の`復号器$dec, %復号器 の`入出力~queue$dec, %出力, %復号器 の`~error~mode$dec )
◎
Let result be the result of processing an item with item, decoder’s decoder, decoder’s I/O queue, output, and decoder’s error mode.
</li>
			<li>
<p>
~IF［
%結果 ~EQ `完遂d$i
］：
◎
If result is finished:
</p>
				<ol>
					<li>
%出力~chunk ~LET `入出力~queueを直列化する$( コレ, %出力 )
◎
Let outputChunk be the result of running serialize I/O queue with decoder and output.
</li>
					<li>
~IF［
%出力~chunk は空でない
］
⇒
%復号器 の`形式変換$に`~chunkを~enqueueする$TS( %出力~chunk )
◎
If outputChunk is non-empty, then enqueue outputChunk in decoder’s transform.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%結果 ~EQ `~error$i
］
⇒
~THROW `TypeError$E
◎
Otherwise, if result is error, throw a TypeError.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="interface-textencoderstream">
<h3 title="Interface TextEncoderStream">7.6. ~interface `TextEncoderStream^I</h3>

<pre class="idl">
[`Exposed$=*]
interface `TextEncoderStream@I {
  `TextEncoderStream$mc();
};

`TextEncoderStream$I includes `TextEncoderCommon$I;
`TextEncoderStream$I includes `GenericTransformStream$I;
</pre>

<p>
各 `TextEncoderStream$I ~objには、
次が結付けられる：
◎
A TextEncoderStream object has an associated:
</p>

<dl class="def-list">
	<dt>
`符号化器@enc
◎
encoder
</dt>
	<dd>
`符号化器$の~instance
◎
An encoder instance.
</dd>
	<dd class="trans-note">【
下に注記されるとおり， `UTF-8$n のそれしかとらない。
また、
`復号器$decのときと違って，状態を保持する~fieldは無い。
】</dd>

	<dt>
`頭部~surrogate@enc
◎
leading surrogate
</dt>
	<dd>
~NULL ／`頭部~surrogate$
— 初期~時は ~NULL とする。
◎
Null or a surrogate, initially null.
</dd>
</dl>

<p class="note">注記：
`TextEncoderStream$I ~objは `UTF-8$n しか~supportしないので、
%~label 引数を提供しない。
◎
A TextEncoderStream object offers no label argument as it only supports UTF-8.
</p>

<dl class="domintro">
	<dt>%encoder = `new TextEncoderStream()$m</dt>
	<dd>
新たな `TextEncoderStream$I ~objを返す。
◎
Returns a new TextEncoderStream object.
</dd>
	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l を返す。
◎
Returns "utf-8".
</dd>

	<dt>%encoder . `readable$m</dt>
	<dd>
`可読~stream$を返す。
その各`~chunk$は、
`writable$m に書込まれた~chunkたちに対し
`UTF-8$n の`符号化器$を走らせた結果の `Uint8Array$I になる。
◎
Returns a readable stream whose chunks are Uint8Arrays resulting from running UTF-8’s encoder on the chunks written to writable.
</dd>

	<dt>%encoder . `writable$m</dt>
	<dd>
`可書~stream$を返す。
それは、
文字列~chunkたちを受容して
— `readable$m に可用にされる前に —
`UTF-8$n の`符号化器$にかける。
◎
Returns a writable stream which accepts string chunks and runs them through UTF-8’s encoder before making them available to readable.
</dd>
	<dd class="example">
<p>
これは概して、
`ReadableStream$I ~sourceの `pipeThrough$m ~methodを介して利用されることになる。
◎
Typically this will be used via the pipeThrough() method on a ReadableStream source.
</p>

<pre class="lang-js">
%textReadable
  .pipeThrough(new TextEncoderStream())
  .pipeTo(%byteWritable);
</pre>

	</dd>
</dl>

<div class="algo">
<p>
`new TextEncoderStream()@m
構築子~手続きは：
◎
The new TextEncoderStream() constructor steps are:
</p>
<ol>
	<li>
コレの`符号化器$enc ~SET `UTF-8$n の`符号化器$の新たな~instance
◎
Set this’s encoder to an instance of the UTF-8 encoder.
</li>
	<li>
%形式変換~stream ~SET `新たな~obj$( `TransformStream$I, コレに`関連な~realm$ )
◎
↓</li>
	<li>
<p>
%形式変換~stream を`設定しておく$TS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`形式変換~algo^i ~SET 所与の
( %~chunk )
に対し，次を走らす~algo
⇒
`~chunkを符号化して~enqueueする$( コレ, %~chunk )
</li>
			<li class="algo">
`書出n~algo^i ~SET 次を走らす~algo
⇒
`符号化して書出す$( コレ )
</li>
		</ul>
◎
Let transformAlgorithm be an algorithm which takes a chunk argument and runs the encode and enqueue a chunk algorithm with this and chunk.
◎
Let flushAlgorithm be an algorithm which runs the encode and flush algorithm with this.
◎
Let transformStream be a new TransformStream.
◎
Set up transformStream with transformAlgorithm set to transformAlgorithm and flushAlgorithm set to flushAlgorithm.
</li>
	<li>
コレの`形式変換$ ~SET %形式変換~stream
◎
Set this’s transform to transformStream.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`~chunkを符号化して~enqueueする@
~algoは、
所与の
( `TextEncoderStream$I ~obj %符号化器, %~chunk )
に対し：
◎
The encode and enqueue a chunk algorithm, given a TextEncoderStream object encoder and chunk, runs these steps:
</p>
<ol>
	<li>
%入力 ~LET `~IDL値に変換する$( %~chunk, `DOMString^I )
◎
Let input be the result of converting chunk to a DOMString.
</li>
	<li>
<p>
%入力 ~SET `入出力~queueに変換する$( %入力 )
◎
Convert input to an I/O queue of code units.
</p>

<p class="note">注記：
`DOMString^I 型から変換しているので、
結果の`入出力~queue$の~item型は，~scalar値ではなく`~cu$になる。
そのようにしているのは、［
2 つの~chunkに分割された~surrogate~pairを，適切な~scalar値に組立直せるようにする
］ためであり，他の挙動は `USVString^I と一致する。
特に，~~孤立した~surrogateは `FFFD^U `�^smb に置換されることになる。
◎
DOMString, as well as an I/O queue of code units rather than scalar values, are used here so that a surrogate pair that is split between chunks can be reassembled into the appropriate scalar value. The behavior is otherwise identical to USVString. In particular, lone surrogates will be replaced with U+FFFD (�).
</p>
	</li>
	<li>
%出力 ~LET `入出力~queue$`~byte^tA « `~EoQ$ »
◎
Let output be the I/O queue of bytes « end-of-queue ».
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~item ~LET `入出力~queueから~itemを読取る$( %入力 )
◎
Let item be the result of reading from input.
</li>
			<li>
<p>
~IF［
%~item ~EQ `~EoQ$
］：
◎
If item is end-of-queue:
</p>
				<ol>
					<li>
%出力 ~SET %出力 を~byte列に`変換する$
◎
Convert output into a byte sequence.
</li>
					<li>
<p>
~IF［
%出力 は空でない
］：
◎
If output is non-empty:
</p>
						<ol>
							<li>
%~chunk ~LET `~buffer~sourceを作成する$( `Uint8Array$I, %出力, %符号化器 に`関連な~realm$ )
◎
Let chunk be a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
	<li>
%符号化器 の`形式変換$に`~chunkを~enqueueする$TS( %~chunk )
◎
Enqueue chunk into encoder’s transform.
</li>
						</ol>
					</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
%結果 ~LET `~cuを~scalar値に変換する$( %符号化器, %~item, %入力 )
◎
Let result be the result of executing the convert code unit to scalar value algorithm with encoder, item and input.
</li>
			<li>
~IF［
%結果 ~NEQ `継続-$i
］
⇒
`~itemを処理する$( %結果, %符号化器 の`符号化器$enc, %入力, %出力, `fatal^l )
◎
If result is not continue, then process an item with result, encoder’s encoder, input, output, and "fatal".
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~cuを~scalar値に変換する@
~algoは、
所与の
( `TextEncoderStream$I ~obj %符号化器, `~cu$ %~item, `入出力~queue$`~cu^tA %入力 )
に対し：
◎
The convert code unit to scalar value algorithm, given a TextEncoderStream object encoder, a code unit item, and an I/O queue of code units input, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%符号化器 の`頭部~surrogate$enc ~NEQ ~NULL
］：
◎
If encoder’s leading surrogate is non-null:
</p>
		<ol>
			<li>
%頭部~surrogate ~LET %符号化器 の`頭部~surrogate$enc
◎
Let leadingSurrogate be encoder’s leading surrogate.
</li>
			<li>
%符号化器 の`頭部~surrogate$enc ~SET ~NULL
◎
Set encoder’s leading surrogate to null.
</li>
			<li>
~IF［
%~item は`尾部~surrogate$である
］
⇒
~RET `~surrogate対から~scalar値を得する$( %頭部~surrogate, %~item )
◎
If item is a trailing surrogate, then return a scalar value from surrogates given leadingSurrogate and item.
</li>
			<li>
`入出力~queueに格納し直す$( %入力, %~item )
◎
Restore item to input.
</li>
			<li>
~RET `FFFD^U `�^smb
◎
Return U+FFFD (�).
</li>
		</ol>
	</li>
	<li>
~IF［
%~item は`頭部~surrogate$である
］
⇒＃
%符号化器 の`頭部~surrogate$enc ~SET %~item；
~RET `継続-$i
◎
If item is a leading surrogate, then set encoder’s leading surrogate to item and return continue.
</li>
	<li>
~IF［
%~item は`尾部~surrogate$である
］
⇒
~RET `FFFD^U `�^smb
◎
If item is a trailing surrogate, then return U+FFFD (�).
</li>
	<li>
~RET %~item
◎
Return item.
</li>
</ol>

<p class="note">注記：
これは， `INFRA$r による［
`文字列$を`~scalar値~文字列$に`変換する~algo＠~INFRA#javascript-string-convert$
］と等価になるが、
2 つの文字列に分割された~surrogate~pairも許容する。
`INFRA$r
◎
This is equivalent to the "convert a string into a scalar value string" algorithm from the Infra Standard, but allows for surrogate pairs that are split between strings. [INFRA]
</p>
</div>

<div class="algo">
<p>
`符号化して書出す@
~algoは、
所与の
( `TextEncoderStream$I ~obj %符号化器 )
に対し：
◎
The encode and flush algorithm, given a TextEncoderStream object encoder, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%符号化器 の`頭部~surrogate$enc ~NEQ ~NULL
］：
◎
If encoder’s leading surrogate is non-null:
</p>
		<ol>
			<li>
<p>
%~byte列 ~LET ~byte列 `EF^X `BF^X `BD^X
◎
Let chunk be a Uint8Array object wrapping an ArrayBuffer containing＼
0xEF 0xBF 0xBD.
</p>

<p class="note">注記：
これは、
`FFFD^U `�^smb を成す~UTF-8~byte列である。
◎
This is U+FFFD (�) in UTF-8 bytes.
</p>
			</li>
			<li>
<p>
%~chunk ~LET `~buffer~sourceを作成する$( `Uint8Array$I, %~byte列, %符号化器 に`関連な~realm$ )
◎
↑</li>
			<li>
%符号化器 の`形式変換$に`~chunkを~enqueueする$TS( %~chunk )
◎
Enqueue chunk into encoder’s transform.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
	</section>
	<section id="the-encoding">
<h2 title="The encoding">8. ~~標準の符号化法</h2>

<p class="trans-note">【
この “~~標準の” は “The” の対訳であり、
およそ，
“規範とされるべき唯一無二の”
を意味する。
】</p>

		<section id="utf-8">
<h3>8.1. ~UTF-8</h3>

			<section id="utf-8-decoder">
<h4 title="UTF-8 decoder">8.1.1. ~UTF-8復号器</h4>

<p class="note">注記：
~BOMは、
~labelより~~優先される
— その方が配備-済みな内容において正確aになるものと見出されたので。
したがってそれは、
`~UTF-8復号器$~algoの一部を成さない
— 代わりに［
`~Unicodeに復号する$ ／ `~UTF-8復号する$
］~algoの一部を成す。
◎
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the UTF-8 decoder algorithm but rather the decode and UTF-8 decode algorithms.
</p>

<p>
各［
`UTF-8$n の`復号器$
］には、
次が結付けられる
⇒＃
`~UTF-8~cp@（初期~時は 0 ）,
`~UTF-8出現~byte数@（初期~時は 0 ）,
`~UTF-8要~byte数@（初期~時は 0 ）,
`~UTF-8下限@（初期~時は `80^X ）,
`~UTF-8上限@（初期~時は `BF^X ）
◎
UTF-8’s decoder has an associated UTF-8 code point, UTF-8 bytes seen, and UTF-8 bytes needed (all initially 0), a UTF-8 lower boundary (initially 0x80), and a UTF-8 upper boundary (initially 0xBF).
</p>

<div class="algo">
<p>
`UTF-8$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し：
◎
UTF-8’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
~IF［
%~byte ~EQ `~EoQ$
］~AND［
`~UTF-8要~byte数$ ~NEQ 0
］
⇒＃
`~UTF-8要~byte数$ ~SET 0；
~RET `~error$i
◎
If byte is end-of-queue and UTF-8 bytes needed is not 0, set UTF-8 bytes needed to 0 and return error.
</li>
	<li>
~IF［
%~byte ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If byte is end-of-queue, then return finished.
</li>
	<li>
<p>
~IF［
`~UTF-8要~byte数$ ~EQ 0
］：
◎
If UTF-8 bytes needed is 0, based on byte:
</p>
		<ol>
			<li>
<p>
%~byte に応じて：
◎
↑</p>

				<dl class="switch">
					<dt>`00^X 〜 `7F^X</dt>
					<dd>
~RET ~cp « %~byte »
◎
Return a code point whose value is byte.
</dd>

					<dt>`C2^X 〜 `DF^X</dt>
					<dd>
						<ol>
							<li>
`~UTF-8要~byte数$ ~SET 1
◎
Set UTF-8 bytes needed to 1.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `1F^X
<span class="note">（ %~byte の下位 5 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0x1F.
◎
The five least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`E0^X 〜 `EF^X</dt>
					<dd>
						<ol>
							<li>
~IF［
%~byte ~EQ `E0^X
］
⇒
`~UTF-8下限$ ~SET `A0^X
◎
If byte is 0xE0, set UTF-8 lower boundary to 0xA0.
</li>
							<li>
~IF［
%~byte ~EQ `ED^X
］
⇒
`~UTF-8上限$ ~SET `9F^X
◎
If byte is 0xED, set UTF-8 upper boundary to 0x9F.
</li>
							<li>
`~UTF-8要~byte数$ ~SET 2
◎
Set UTF-8 bytes needed to 2.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `F^X
<span class="note">（ %~byte の下位 4 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0xF.
◎
The four least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`F0^X 〜 `F4^X</dt>
					<dd>
						<ol>
							<li>
~IF［
%~byte ~EQ `F0^X
］
⇒
`~UTF-8下限$ ~SET `90^X
◎
If byte is 0xF0, set UTF-8 lower boundary to 0x90.
</li>
							<li>
~IF［
%~byte ~EQ `F4^X
］
⇒
`~UTF-8上限$ ~SET `8F^X
◎
If byte is 0xF4, set UTF-8 upper boundary to 0x8F.
</li>
							<li>
`~UTF-8要~byte数$ ~SET 3
◎
Set UTF-8 bytes needed to 3.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `7^X
<span class="note">（ %~byte の下位 3 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0x7.
◎
The three least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>
その他
◎
Otherwise
</dt>
					<dd>
~RET `~error$i
◎
Return error.
</dd>
				</dl>
			</li>
			<li>
~RET `継続-$i
◎
Return continue.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~byte ~NIN { `~UTF-8下限$ 〜 `~UTF-8上限$ }
］：
◎
If byte is not in the range UTF-8 lower boundary to UTF-8 upper boundary, inclusive:
</p>
		<ol>
			<li>
( `~UTF-8~cp$, `~UTF-8要~byte数$, `~UTF-8出現~byte数$ ) ~SET ( 0, 0, 0 )
◎
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0,＼
</li>
			<li>
( `~UTF-8下限$, `~UTF-8上限$ ) ~SET ( `80^X, `BF^X )
◎
set UTF-8 lower boundary to 0x80, and set UTF-8 upper boundary to 0xBF.
</li>
			<li>
`入出力~queueに格納し直す$( %入出力~queue, %~byte )
◎
Restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
( `~UTF-8下限$, `~UTF-8上限$ ) ~SET ( `80^X, `BF^X )
◎
Set UTF-8 lower boundary to 0x80 and UTF-8 upper boundary to 0xBF.
</li>
	<li>
<p>
`~UTF-8~cp$ ~SET (`~UTF-8~cp$ ~Lshift 6) ~bOR (%~byte ~bAND `3F^X)
◎
Set UTF-8 code point to (UTF-8 code point &lt;&lt; 6) | (byte &amp; 0x3F)
</p>

<p class="note">注記：
`~UTF-8~cp$内の既存の~bitを左へ 6 ~bit ~shiftして，~~空いた下位 6 ~bitに %~byte の下位 6 ~bitをあてがう。
◎
Shift the existing bits of UTF-8 code point left by six places and set the newly-vacated six least significant bits to the six least significant bits of byte.
</p>
	</li>
	<li>
`~UTF-8出現~byte数$ ~INCBY 1
◎
Increase UTF-8 bytes seen by one.
</li>
	<li>
~IF［
`~UTF-8出現~byte数$ ~NEQ `~UTF-8要~byte数$
］
⇒
~RET `継続-$i
◎
If UTF-8 bytes seen is not equal to UTF-8 bytes needed, then return continue.
</li>
	<li>
%~cp ~LET `~UTF-8~cp$
◎
Let codePoint be UTF-8 code point.
</li>
	<li>
( `~UTF-8~cp$, `~UTF-8要~byte数$, `~UTF-8出現~byte数$ ) ~SET ( 0, 0, 0 )
◎
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0.
</li>
	<li>
~RET ~cp « %~cp »
◎
Return a code point whose value is codePoint.
</li>
</ol>

<p class="note">注記：
`~UTF-8復号器$における上の拘束は、
~Unicode標準の
“`Best Practices for Using U+FFFD^en”
に準じる。
他の挙動は、
Encoding 標準の下では許可されない
（同じ結果を達成するなら、
他の~algoでも~~十分であり，むしろ奨励される）。
`UNICODE$r
◎
The constraints in the UTF-8 decoder above match “Best Practices for Using U+FFFD” from the Unicode standard. No other behavior is permitted per the Encoding Standard (other algorithms that achieve the same result are fine, even encouraged). [UNICODE]
</p>
</div>

			</section>
			<section id="utf-8-encoder">
<h4 title="UTF-8 encoder">8.1.2. ~UTF-8符号化器</h4>

<div class="algo">
<p>
`UTF-8$n の`符号化器$の`~handler$は、
所与の
( %利用されない~queue, %~cp )
に対し：
◎
UTF-8’s encoder’s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If codePoint is end-of-queue, then return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte « %~cp »
◎
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
<p>
( %count, %~offset ) ~SET %~cp が属する範囲に応じて
⇒＃
{ `0080^U 〜 `07FF^U } ならば ( 1, `C0^X ) ／
{ `0800^U 〜 `FFFF^U } ならば ( 2, `E0^X ) ／
{ `10000^U 〜 `10FFFF^U } ならば ( 3, `F0^X )
◎
Set count and offset based on the range codePoint is in:
◎
U+0080 to U+07FF, inclusive
• 1 and 0xC0
U+0800 to U+FFFF, inclusive
• 2 and 0xE0
U+10000 to U+10FFFF, inclusive
• 3 and 0xF0
</li>
	<li>
%~byte列 ~LET ~byte « ( %~cp ~Rshift ( 6 ~MUL %count ) ) ~PLUS %~offset »
◎
Let bytes be a byte sequence whose first byte is (codePoint &gt;&gt; (6 × count)) + offset.
</li>
	<li>
<p>
~WHILE［
%count ~GT 0
］：
◎
While count is greater than 0:
</p>
		<ol>
			<li>
%temp ~SET %~cp ~Rshift ( 6 ~MUL ( %count ~MINUS 1 ) )
◎
Set temp to codePoint &gt;&gt; (6 × (count − 1)).
</li>
			<li>
%~byte列 に
( `80^X ~bOR ( %temp ~bAND `3F^X ) )
を付加する
◎
Append to bytes 0x80 | (temp &amp; 0x3F).
</li>
			<li>
%count ~DECBY 1
◎
Decrease count by one.
</li>
		</ol>
	</li>
	<li>
~RET %~byte列
◎
Return bytes bytes, in order.
</li>
</ol>

<p class="note">注記：
この~algoは、
~Unicode標準に述べられるものと一致する結果を得るが，完全さのためここに含められている。
`UNICODE$r
◎
This algorithm has identical results to the one described in the Unicode standard. It is included here for completeness. [UNICODE]
</p>
</div>

			</section>
		</section>
	</section>
	<section id="legacy-single-byte-encodings">
<h2 title="Legacy single-byte encodings">9. 旧来の単-~byte符号化法</h2>

<p>
`符号化法$のうち［
各~byteが， 1 個の~cpに対応するか, どの~cpにも対応しないもの
］は、
`単-~byte符号化法@
と総称される。
すべての`単-~byte符号化法$が、
同じ［
`復号器$, `符号化器$
］を共有する。
`単-~byte復号器$／`単-~byte符号化器$から参照される
`単-~byte索引@
は、
利用-中にある`単-~byte符号化法$に依存し，次の表tで定義される。
［
`ISO-8859-8^n, `ISO-8859-8-I^n
］を除くすべての`単-~byte符号化法$は、
それぞれに一意な`索引$を持つ。
◎
An encoding where each byte is either a single code point or nothing, is a single-byte encoding. Single-byte encodings share the decoder and encoder. Index single-byte, as referenced by the single-byte decoder and single-byte encoder, is defined by the following table, and depends on the single-byte encoding in use. All but two single-byte encodings have a unique index.
</p>

<p class="trans-note">【
被覆域の~tableは巨大なことに注意。
】【
視覚-化~tableの各~cellの色については、
`凡例＠#visualization$を見よ。
】</p>

<table><thead>
<tr><th>`名前$
<th>`索引$
<th>視覚-化
<th>基本多言語面（ BMP ）の被覆域
<tbody>

<tr><td>`IBM866@n<td>`IBM866$idx
<tr><td>`ISO-8859-2@n<td>`ISO-8859-2$idx
<tr><td>`ISO-8859-3@n<td>`ISO-8859-3$idx
<tr><td>`ISO-8859-4@n<td>`ISO-8859-4$idx
<tr><td>`ISO-8859-5@n<td>`ISO-8859-5$idx
<tr><td>`ISO-8859-6@n<td>`ISO-8859-6$idx
<tr><td>`ISO-8859-7@n<td>`ISO-8859-7$idx
<tr><td>`ISO-8859-8@n<td>`ISO-8859-8$idx
<tr><td>`ISO-8859-8-I@n<td colspan="3">`ISO-8859-8$n と同じ
<tr><td>`ISO-8859-10@n<td>`ISO-8859-10$idx
<tr><td>`ISO-8859-13@n<td>`ISO-8859-13$idx
<tr><td>`ISO-8859-14@n<td>`ISO-8859-14$idx
<tr><td>`ISO-8859-15@n<td>`ISO-8859-15$idx
<tr><td>`ISO-8859-16@n<td>`ISO-8859-16$idx
<tr><td>`KOI8-R@n<td>`KOI8-R$idx
<tr><td>`KOI8-U@n<td>`KOI8-U$idx
<tr><td>`macintosh@n<td>`macintosh$idx
<tr><td>`windows-874@n<td>`windows-874$idx
<tr><td>`windows-1250@n<td>`windows-1250$idx
<tr><td>`windows-1251@n<td>`windows-1251$idx
<tr><td>`windows-1252@n<td>`windows-1252$idx
<tr><td>`windows-1253@n<td>`windows-1253$idx
<tr><td>`windows-1254@n<td>`windows-1254$idx
<tr><td>`windows-1255@n<td>`windows-1255$idx
<tr><td>`windows-1256@n<td>`windows-1256$idx
<tr><td>`windows-1257@n<td>`windows-1257$idx
<tr><td>`windows-1258@n<td>`windows-1258$idx
<tr><td>`x-mac-cyrillic@n<td>`x-mac-cyrillic$idx
</table>

<p class="note">注記：
~layout方向に波及することから、
`ISO-8859-8$n と `ISO-8859-8-I$n の`符号化法$の`名前$は異なるものにされている。
歴史的に、
このことは `ISO-8859-6$n と "ISO-8859-6-I" についても該当していたが、
それはもはや成立しない。
【！ https://www.w3.org/Bugs/Public/show_bug.cgi?id=19505 】
◎
ISO-8859-8 and ISO-8859-8-I are distinct encoding names, because ISO-8859-8 has influence on the layout direction. And although historically this might have been the case for ISO-8859-6 and "ISO-8859-6-I" as well, that is no longer true.
</p>

		<section id="single-byte-decoder">
<h3 title="single-byte decoder">9.1. 単-~byte復号器</h3>

<div class="algo">
<p>
`単-~byte符号化法$の`復号器$の`~handler$は、
所与の
( %利用されない~queue, %~byte )
に対し：
◎
Single-byte encodings’s decoder’s handler, given unused and byte, runs these steps:
</p>
<ol>
	<li>
~IF［
%~byte ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If byte is end-of-queue, then return finished.
</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp « %~byte »
◎
If byte is an ASCII byte, then return a code point whose value is byte.
</li>
	<li>
%~cp ~LET
`単-~byte索引$ の中で
( %~byte ~MINUS `80^X )
が指す`索引~cp$
◎
Let codePoint be the index code point for byte − 0x80 in index single-byte.
</li>
	<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$i
◎
If codePoint is null, then return error.
</li>
	<li>
~RET ~cp « %~cp »
◎
Return a code point whose value is codePoint.
</li>
</ol>
</div>

		</section>
		<section id="single-byte-encoder">
<h3 title="single-byte encoder">9.2. 単-~byte符号化器</h3>

<div class="algo">
<p>
`単-~byte符号化法$ の`符号化器$の`~handler$は、
所与の
( %利用されない~queue, %~cp )
に対し：
◎
Single-byte encodings’s encoder’s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If codePoint is end-of-queue, then return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte « %~cp »
◎
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
%~pointer ~LET
`単-~byte索引$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for codePoint in index single-byte.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET `~error$i( %~cp )
◎
If pointer is null, then return error with codePoint.
</li>
	<li>
~RET ~byte « %~pointer ~PLUS `80^X »
◎
Return a byte whose value is pointer + 0x80.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(simplified)-encodings">
<h2 title="Legacy multi-byte Chinese (simplified) encodings">10. 旧来の複-~byte~Chinese（簡体字） 符号化法</h2>

		<section id="gbk">
<h3 title="GBK">10.1. ~GBK</h3>

			<section id="gbk-decoder">
<h4 title="GBK decoder">10.1.1. ~GBK復号器</h4>

<p>
`GBK$n の`復号器$は，`gb18030$n の`復号器$である。
◎
GBK’s decoder is gb18030’s decoder.
</p>

			</section>
			<section id="gbk-encoder">
<h4 title="GBK encoder">10.1.2. ~GBK符号化器</h4>

<p>
`GBK$n の符号化器は，［
`~GBK用か$ ~SET ~T
］にされた`gb18030$n の`符号化器$である。
◎
GBK’s encoder is gb18030’s encoder with its is GBK set to true.
</p>

<p class="note">注記：
`GBK$n を`gb18030$nに対する全くの別名にしないのは、
`GBK$n の`符号化器$により生成された内容を［
旧来の~serverや他の消費器を非互換化する機会cを減らすよう，保守的に移行する
］ためである。
◎
Not fully aliasing GBK with gb18030 is a conservative move to decrease the chances of breaking legacy servers and other consumers of content generated with GBK’s encoder.
</p>

			</section>
		</section>
		<section id="gb18030">
<h3 title="gb18030">10.2. ~gb18030</h3>

			<section id="gb18030-decoder">
<h4 title="gb18030 decoder">10.2.1. ~gb18030復号器</h4>

<p>
各［
`gb18030$n の`復号器$
］には、
次が結付けられる
⇒＃
`~gb1@（初期~時は 0 ）,
`~gb2@（初期~時は 0 ）,
`~gb3@（初期~時は 0 ）
◎
gb18030’s decoder has an associated gb18030 first, gb18030 second, and gb18030 third (all initially 0x00).
</p>

<div class="algo">
<p>
`gb18030$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し：
◎
gb18030’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
( `~gb1$, `~gb2$, `~gb3$ ) ~EQ ( `00^X, `00^X, `00^X )
］
⇒
~RET `完遂d$i
◎
If byte is end-of-queue and gb18030 first, gb18030 second, and gb18030 third are 0x00, then return finished.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
◎
If byte is end-of-queue, and gb18030 first, gb18030 second, or gb18030 third is not 0x00, then set gb18030 first, gb18030 second, and gb18030 third to 0x00, and＼
</li>
			<li>
~RET `~error$i
◎
return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb3$ ~NEQ `00^X
］：
◎
If gb18030 third is not 0x00:
</p>
		<ol>
			<li>
<p>
~IF［
%~byte ~NIN { `30^X 〜 `39^X }
］：
◎
If byte is not in the range 0x30 to 0x39, inclusive:
</p>
				<ol>
					<li>
`入出力~queueに格納し直す$( %入出力~queue, ~byte列 « `~gb2$, `~gb3$, %~byte » ) 
◎
Restore « gb18030 second, gb18030 third, byte » to ioQueue.
</li>
					<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
◎
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
					<li>
~RET `~error$i
◎
Return error.
</li>
				</ol>
			</li>
			<li>
%~cp ~LET 次に与える~pointerが指す`索引~gb18030範囲~群~cp$
⇒
(( `~gb1$ ~MINUS `81^X ) ~MUL ( 10 ~MUL 126 ~MUL 10 )) ~PLUS
(( `~gb2$ ~MINUS `30^X ) ~MUL ( 10 ~MUL 126 )) ~PLUS
(( `~gb3$ ~MINUS `81^X ) ~MUL 10 ) ~PLUS
( %~byte ~MINUS `30^X )
◎
Let codePoint be the index gb18030 ranges code point for ((gb18030 first − 0x81) × (10 × 126 × 10)) + ((gb18030 second − 0x30) × (10 × 126)) + ((gb18030 third − 0x81) × 10) + byte − 0x30.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
◎
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
			<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$i
◎
If codePoint is null, then return error.
</li>
			<li>
~RET ~cp « %~cp »
◎
Return a code point whose value is codePoint.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb2$ ~NEQ `00^X
］：
◎
If gb18030 second is not 0x00:
</p>
		<ol>
			<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~gb3$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is in the range 0x81 to 0xFE, inclusive, then set gb18030 third to byte and return continue.
</li>
			<li>
`入出力~queueに格納し直す$( %入出力~queue, ~byte列 « `~gb2$, %~byte » )
◎
Restore « gb18030 second, byte » to ioQueue＼
</li>
			<li>
( `~gb1$, `~gb2$ ) ~SET ( `00^X, `00^X )
◎
set gb18030 first and gb18030 second to 0x00, and＼
</li>
			<li>
~RET `~error$i
◎
return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb1$ ~NEQ `00^X
］：
◎
If gb18030 first is not 0x00:
</p>
		<ol>
			<li>
~IF［
%~byte ~IN { `30^X 〜 `39^X }
］
⇒＃
`~gb2$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is in the range 0x30 to 0x39, inclusive, set gb18030 second to byte and return continue.
</li>
			<li>
%~lead ~LET `~gb1$
◎
Let lead be gb18030 first,＼
</li>
			<li>
%~pointer ~LET ~NULL
◎
let pointer be null, and＼
</li>
			<li>
`~gb1$ ~SET `00^X
◎
set gb18030 first to 0x00.
</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if byte is less than 0x7F; otherwise 0x41.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `80^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS %~offset )
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 + (byte − offset).
</li>
			<li>
%~cp ~LET %~pointer に応じて
⇒
~NULL ならば ~NULL ／
~ELSE_ `索引~gb18030$ の中で %~pointer が指す`索引~cp$
◎
Let codePoint be null if pointer is null; otherwise the index code point for pointer in index gb18030.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp « %~cp »
◎
If codePoint is non-null, then return a code point whose value is codePoint.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
`入出力~queueに格納し直す$( %入出力~queue, %~byte )
◎
If byte is an ASCII byte, then restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~gb1$ ~SET %~byte ；
~RET `継続-$i
◎
↓</li>
	<li>
~RET %~byte に応じて
⇒＃
`~ASCII~byte$ならば ~cp « %~byte » ／
`80^X ならば ~cp « `20AC^U `€^smb » ／
`FF^X ならば `~error$i
◎
If byte is an ASCII byte, then return a code point whose value is byte.
◎
If byte is 0x80, then return code point U+20AC (€).
◎
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 first to byte and return continue.
◎
Return error.
</li>
</ol>
</div>

			</section>
			<section id="gb18030-encoder">
<h4 title="gb18030 encoder">10.2.2. ~gb18030符号化器</h4>

<p>
各［
`gb18030$n の`符号化器$
］には、
次が結付けられる
⇒
`~GBK用か@
（初期~時は ~F ）
◎
gb18030’s encoder has an associated is GBK (initially false).
</p>

<div class="algo">
<p>
`gb18030$n の`符号化器$の`~handler$は、
所与の
( %利用されない~queue, %~cp )
に対し：
◎
gb18030’s encoder’s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If codePoint is end-of-queue, then return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte « %~cp »
◎
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
<p>
~IF［
%~cp ~EQ `E5E5^U
］
⇒
~RET `~error$i( %~cp )
◎
If codePoint is U+E5E5, then return error with codePoint.
</p>

<p class="note">注記：
配備-済みな内容との互換性を得るため、
`索引~gb18030$ は［
`A3^X `A0^X
］を `E5E5^U ではなく `3000^U に対応付けている。
したがって、
それは往復し得ない。
◎
Index gb18030 maps 0xA3 0xA0 to U+3000 rather than U+E5E5 for compatibility with deployed content. Therefore it cannot roundtrip.
</p>

</li>
	<li>
~IF［
`~GBK用か$ ~EQ ~T
］~AND［
%~cp ~EQ `20AC^U `€^smb
］
⇒
~RET ~byte « `80^X »
◎
If is GBK is true and codePoint is U+20AC (€), then return byte 0x80.
</li>
	<li>
<p>
下の表tを成す
~EACH( %行 )
に対し
⇒
~IF［
%~cp ~EQ %行 の 1 列目に挙げられる~cp
］
⇒
~RET %行 の 2 列目に挙げられる~byte列
◎
If there is a row in the table below whose first column is codePoint, then return the two bytes on the same row listed in the second column:
</p>

<table><tbody>
<tr><th>~cp
<th>~byte列

<tr><td>`E78D^U
<td>`A6^X `D9^X

<tr><td>`E78E^U
<td>`A6^X `DA^X

<tr><td>`E78F^U
<td>`A6^X `DB^X

<tr><td>`E790^U
<td>`A6^X `DC^X

<tr><td>`E791^U
<td>`A6^X `DD^X

<tr><td>`E792^U
<td>`A6^X `DE^X

<tr><td>`E793^U
<td>`A6^X `DF^X

<tr><td>`E794^U
<td>`A6^X `EC^X

<tr><td>`E795^U
<td>`A6^X `ED^X

<tr><td>`E796^U
<td>`A6^X `F3^X

<tr><td>`E81E^U
<td>`FE^X `59^X

<tr><td>`E826^U
<td>`FE^X `61^X

<tr><td>`E82B^U
<td>`FE^X `66^X

<tr><td>`E82C^U
<td>`FE^X `67^X

<tr><td>`E832^U
<td>`FE^X `6D^X

<tr><td>`E843^U
<td>`FE^X `7E^X

<tr><td>`E854^U
<td>`FE^X `90^X

<tr><td>`E864^U
<td>`FE^X `A0^X
</table>

<p class="note">注記：
この非対称な符号化器~表tは、
GB18030-2005 標準との互換性を保全する。
`索引~gb18030範囲~群$における説明も見よ。
◎
This asymmetric encoder table preserves compatibility with the GB18030-2005 standard. See also the explanation at index gb18030 ranges.
</p>
	</li>
	<li>
%~pointer ~LET
`索引~gb18030$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for codePoint in index gb18030.
</li>
	<li>
<p>
~IF［
%~pointer ~NEQ ~NULL
］：
◎
If pointer is non-null:
</p>
		<ol>
			<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
◎
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET %~pointer ~MOD 190
◎
Let trail be pointer % 190.
</li>
			<li>
%~offset ~LET ［
%~trail ~IN { `00^X 〜 `3E^X } ならば `40^X【！0x7F-0x40 】 ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if trail is less than 0x3F, otherwise 0x41.
</li>
			<li>
~RET ~byte列 « %~lead, ( %~trail ~PLUS %~offset ) »
◎
Return two bytes whose values are lead and trail + offset.
</li>
		</ol>
	</li>
	<li>
~IF［
`~GBK用か$ ~EQ ~T
］
⇒
~RET `~error$i( %~cp )
◎
If is GBK is true, then return error with codePoint.
</li>
	<li>
%~pointer ~SET
%~cp
を指す`索引~gb18030範囲~群~pointer$
◎
Set pointer to the index gb18030 ranges pointer for codePoint.
</li>
	<li>
%byte1 ~LET %~pointer ~DIV ( 10 ~MUL 126 ~MUL 10 )
◎
Let byte1 be pointer / (10 × 126 × 10).
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 ~MUL 10 )
◎
Set pointer to pointer % (10 × 126 × 10).
</li>
	<li>
%byte2 ~LET %~pointer ~DIV ( 10 ~MUL 126 )
◎
Let byte2 be pointer / (10 × 126).
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 )
◎
Set pointer to pointer % (10 × 126).
</li>
	<li>
%byte3 ~LET %~pointer ~DIV 10
◎
Let byte3 be pointer / 10.
</li>
	<li>
%byte4 ~LET %~pointer ~MOD 10
◎
Let byte4 be pointer % 10.
</li>
	<li>
~RET ~byte列 «
( %byte1 ~PLUS `81^X ),
( %byte2 ~PLUS `30^X ),
( %byte3 ~PLUS `81^X ),
( %byte4 ~PLUS `30^X )
»
◎
Return four bytes whose values are byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(traditional)-encodings">
<h2 title="Legacy multi-byte Chinese (traditional) encodings">11. 旧来の複-~byte~Chinese（繁体字）符号化法</h2>

【！ Lead:  0x81 to 0xFE ／ Trail: 0x40 to 0x7E or 0xA1 to 0xFE 】

		<section id="big5">
<h3 title="Big5">11.1. ~Big5</h3>

			<section id="big5-decoder">
<h4 title="Big5 decoder">11.1.1. ~Big5復号器</h4>

<p>
各［
`Big5$n の`復号器$
］には、
次が結付けられる
⇒
`~Big5~lead@（初期~時は `00^X ）
◎
Big5’s decoder has an associated Big5 lead (initially 0x00).
</p>

<div class="algo">
<p>
`Big5$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し：
◎
Big5’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
</p>
		<ol>
			<li>
~IF［
`~Big5~lead$ ~NEQ `00^X
］
⇒＃
`~Big5~lead$ ~SET `00^X ；
~RET `~error$i
</li>
			<li>
~RET `完遂d$i
</li>
		</ol>
◎
If byte is end-of-queue and Big5 lead is not 0x00, then set Big5 lead to 0x00 and return error.
◎
If byte is end-of-queue and Big5 lead is 0x00, then return finished.
</li>
	<li>
<p>
~IF［
`~Big5~lead$ ~NEQ `00^X
］：
◎
If Big5 lead is not 0x00:
</p>
		<ol>
			<li>
%~lead ~LET `~Big5~lead$
◎
Let lead be Big5 lead.
</li>
			<li>
`~Big5~lead$ ~SET `00^X
◎
Set Big5 lead to 0x00.
</li>
			<li>
%~pointer ~LET ~NULL
◎
Let pointer be null.
</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `62^X 【！ 0x62 = 0xA1-0x7E+1+0x40 】
］
◎
Let offset be 0x40 if byte is less than 0x7F; otherwise 0x62.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `A1^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 157 ~PLUS ( %~byte ~MINUS %~offset )
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1 to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 + (byte − offset).
</li>
			<li>
<p>
~IF［
下の表tの中で， 1 列目が %~pointer に等しい行がある
］
⇒
~RET 同じ行の 2 列目に与える~cp列（ `2 個の^em ~cpからなる）
◎
If there is a row in the table below whose first column is pointer, then return the two code points listed in its second column (the third column is irrelevant):
</p>

【！ https://www.unicode.org/Public/UNIDATA/NamedSequences.txt 】
<div>
<table><thead>
<tr><th>~pointer
<th>~cp
<th>注記（この段には関連しない）
<tbody id="_big5-lead">

<tr><td>1133【！ 0x88 0x62 】
<td>`00CA^U `0304^U
<td>Ê̄ 
( `LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON^cn )

<tr><td>1135【！ 0x88 0x64 】
<td>`00CA^U `030C^U
<td>Ê̌ 
( `LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON^cn )

<tr><td>1164【！ 0x88 0xA3 】
<td>`00EA^U `0304^U
<td>ê̄ 
( `LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON^cn )

<tr><td>1166【！ 0x88 0xA5 】
<td>`00EA^U `030C^U
<td>ê̌ 
( `LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON^cn )
</table>

【！~UA／環境／言語~codeによっては、~glyphが結合されず，正しく表示されないかもしれない。】
【！lang=ja の下では正しく表示されない~UAがある】
【！lang=en の下でも正しく表示しない~UAがある】
【！文字参照（&#x00EA;&#x030C;）を利用すると異なる表示になる~UAもある】

◎
Pointer｜Code points｜Notes
1133｜U+00CA U+0304｜Ê̄ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON)
1135｜U+00CA U+030C｜Ê̌ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON)
1164｜U+00EA U+0304｜ê̄ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON)
1166｜U+00EA U+030C｜ê̌ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON)
</div>

<p class="note">注記：
`索引$は単独の~cpに制限されるので、
これらの~pointerにはこの表tが利用される。
◎
Since indexes are limited to single code points this table is used for these pointers.
</p>
			</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~Big5$ の中で %~pointer が指す`索引~cp$
］
◎
Let codePoint be null if pointer is null; otherwise the index code point for pointer in index Big5.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp « %~cp »
◎
If codePoint is non-null, then return a code point whose value is codePoint.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
`入出力~queueに格納し直す$( %入出力~queue, %~byte )
◎
If byte is an ASCII byte, restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp « %~byte »
◎
If byte is an ASCII byte, then return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~Big5~lead$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is in the range 0x81 to 0xFE, inclusive, then set Big5 lead to byte and return continue.
</li>
	<li>
~RET `~error$i
◎
Return error.
</li>
</ol>
</div>

			</section>
			<section id="big5-encoder">
<h4 title="Big5 encoder">11.1.2. ~Big5符号化器</h4>

<div class="algo">
<p>
`Big5$n の`符号化器$の`~handler$は、
所与の
( %利用されない~queue, %~cp )
に対し：
◎
Big5’s encoder’s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If codePoint is end-of-queue, then return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte « %~cp »
◎
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
%~pointer ~LET %~cp を指す`索引~Big5~pointer$
◎
Let pointer be the index Big5 pointer for codePoint.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET `~error$i( %~cp )
◎
If pointer is null, then return error with codePoint.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 157 ) ~PLUS `81^X
◎
Let lead be pointer / 157 + 0x81.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 157
◎
Let trail be pointer % 157.
</li>
	<li>
%~offset ~LET ［
%~trail ~IN { `00^X 〜 `3E^X } ならば `40^X【！0x7F-0x40 】 ／
~ELSE_ `62^X【！0xA1-0x3F 】
］
◎
Let offset be 0x40 if trail is less than 0x3F, otherwise 0x62.
</li>
	<li>
~RET ~byte列 « %~lead, ( %~trail ~PLUS %~offset) »»
◎
Return two bytes whose values are lead and trail + offset.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-japanese-encodings">
<h2 title="Legacy multi-byte Japanese encodings">12. 旧来の複-~byte~Japanese符号化法</h2>

		<section id="euc-jp">
<h3 title="EUC-JP">12.1. ~EUC-JP</h3>

【！ ~IANA-a/charset-reg/CP51932 】

			<section id="euc-jp-decoder">
<h4 title="EUC-JP decoder">12.1.1. ~EUC-JP復号器</h4>

<p>
各［
`EUC-JP$n の`復号器$
］には、
次が結付けられる
⇒＃
`~EUC-JP~jis0212@（初期~時は ~F ）；
`~EUC-JP~lead@（初期~時は `00^X ）
◎
EUC-JP’s decoder has an associated EUC-JP jis0212 (initially false) and EUC-JP lead (initially 0x00).
</p>

<div class="algo">
<p>
`EUC-JP$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し：
◎
EUC-JP’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
`~EUC-JP~lead$ ~NEQ `00^X
］
⇒＃
`~EUC-JP~lead$ ~SET `00^X ；
~RET `~error$i
◎
If byte is end-of-queue and EUC-JP lead is not 0x00, then set EUC-JP lead to 0x00, and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$i
◎
If byte is end-of-queue and EUC-JP lead is 0x00, then return finished.
</li>
		</ol>
	</li>
	<li>
~IF［
`~EUC-JP~lead$ ~EQ `8E^X
］~AND［
%~byte ~IN { `A1^X 〜 `DF^X }
］
【！ katakana; subtraction is done first to avoid upsetting compilers 】
⇒＃
`~EUC-JP~lead$ ~SET `00^X ；
~RET ~cp « `FF61^X ~MINUS `A1^X ~PLUS %~byte »
◎
If EUC-JP lead is 0x8E and byte is in the range 0xA1 to 0xDF, inclusive, set EUC-JP lead to 0x00 and return a code point whose value is 0xFF61 − 0xA1 + byte.
</li>
	<li>
~IF［
`~EUC-JP~lead$ ~EQ `8F^X
］~AND［
%~byte ~IN { `A1^X 〜 `FE^X }
］
⇒＃
`~EUC-JP~jis0212$ ~SET ~T ；
`~EUC-JP~lead$ ~SET %~byte ；
~RET `継続-$i
◎
If EUC-JP lead is 0x8F and byte is in the range 0xA1 to 0xFE, inclusive, set EUC-JP jis0212 to true, set EUC-JP lead to byte, and return continue.
</li>
	<li>
<p>
~IF［
`~EUC-JP~lead$ ~NEQ `00^X
］：
◎
If EUC-JP lead is not 0x00:
</p>
		<ol>
			<li>
%~lead ~LET `~EUC-JP~lead$
◎
Let lead be EUC-JP lead.
</li>
			<li>
`~EUC-JP~lead$ ~SET `00^X
◎
Set EUC-JP lead to 0x00.
</li>
			<li>
%~cp ~LET ~NULL
◎
Let codePoint be null.
</li>
			<li>
<p>
~IF［
%~lead ~IN { `A1^X 〜 `FE^X }
］~AND［
%~byte ~IN { `A1^X 〜 `FE^X }
］：
</p>
				<ol>
					<li>
%索引 ~LET `~EUC-JP~jis0212$に応じて
⇒＃
~F ならば`索引~jis0208$ ／
~T ならば `索引~jis0212$
</li>
					<li>
%~cp ~SET %索引 の中で
( ( %~lead ~MINUS `A1^X ) ~MUL 94 ~PLUS %~byte ~MINUS `A1^X )
が指す`索引~cp$
</li>
				</ol>
◎
If lead and byte are both in the range 0xA1 to 0xFE, inclusive, then set codePoint to the index code point for (lead − 0xA1) × 94 + byte − 0xA1 in index jis0208 if EUC-JP jis0212 is false and in index jis0212 otherwise.
</li>
			<li>
`~EUC-JP~jis0212$ ~SET ~F
◎
Set EUC-JP jis0212 to false.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp « %~cp »
◎
If codePoint is non-null, then return a code point whose value is codePoint.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
`入出力~queueに格納し直す$( %入出力~queue, %~byte )
◎
If byte is an ASCII byte, restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp « %~byte »
◎
If byte is an ASCII byte, then return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `8E^X, `8F^X, `A1^X 〜 `FE^X }
］
⇒＃
`~EUC-JP~lead$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE, inclusive, then set EUC-JP lead to byte and return continue.
</li>
	<li>
~RET `~error$i
◎
Return error.
</li>
</ol>
</div>

			</section>
			<section id="euc-jp-encoder">
<h4 title="EUC-JP encoder">12.1.2. ~EUC-JP符号化器</h4>

<div class="algo">
<p>
`EUC-JP$n の`符号化器$の`~handler$は、
所与の
( %利用されない~queue, %~cp )
に対し：
◎
EUC-JP’s encoder’s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
%結果 ~LET %~cp に応じて
⇒＃
`~EoQ$ ならば `完遂d$i ／
`~ASCII~cp$ならば ~byte « %~cp » ／
`00A5^U `¥^smb ならば ~byte « `5C^X » ／
`203E^U `‾^smb ならば ~byte « `7E^X » ／
`FF61^U 〜 `FF9F^U ならば ~byte列 « `8E^X, ( %~cp ~MINUS `FF61^X ~PLUS `A1^X ) » ／
~ELSE_ ~NULL
◎
If codePoint is end-of-queue, then return finished.
◎
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
◎
If codePoint is U+00A5 (¥), then return byte 0x5C.
◎
If codePoint is U+203E (‾), then return byte 0x7E.
◎
If codePoint is in the range U+FF61 to U+FF9F, inclusive, then return two bytes whose values are 0x8E and codePoint − 0xFF61 + 0xA1.
</li>
	<li>
~IF［
%結果 ~NEQ ~NULL
］
⇒
~RET %結果
◎
↑</li>
	<li>
~IF［
%~cp ~EQ `2212^U `−^smb
］
⇒
%~cp ~SET `FF0D^U `－^smb
◎
If codePoint is U+2212 (−), then set it to U+FF0D (－).
</li>
	<li>
<p>
%~pointer ~LET `索引~jis0208$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for codePoint in index jis0208.
</p>

<p class="note">注記：
%~pointer は、
~NULL でなければ，`索引~jis0208$と~pointer演算の資質に因り 8836 未満になる。
◎
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET `~error$i( %~cp )
◎
If pointer is null, then return error with codePoint.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `A1^X
◎
Let lead be pointer / 94 + 0xA1.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `A1^X
◎
Let trail be pointer % 94 + 0xA1.
</li>
	<li>
~RET ~byte列 « %~lead, %~trail »
◎
Return two bytes whose values are lead and trail.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="iso-2022-jp">
<h3 title="ISO-2022-JP">12.2. ~ISO-2022-JP</h3>

【！ https://tools.ietf.org/html/rfc1468】
【！ https://tools.ietf.org/html/rfc2237 (iso-2022-jp-1; not used)】
【！ "ESC ) I" is from iso-2022-jp-3 reportedly】

			<section id="iso-2022-jp-decoder">
<h4 title="ISO-2022-JP decoder">12.2.1. ~ISO-2022-JP復号器</h4>

<p>
各［
`ISO-2022-JP$n の`復号器$
］には、
次が結付けられる
⇒＃
`~ISO-2022-JP復号器~状態@（初期~時は `ASCII$i ）,
`~ISO-2022-JP復号器~出力~状態@（初期~時は `ASCII$i ）,
`~ISO-2022-JP~lead@（初期~時は `00^X ）,
`~ISO-2022-JP出力@（初期~時は ~F ）
◎
ISO-2022-JP’s decoder has an associated ISO-2022-JP decoder state (initially ASCII), ISO-2022-JP decoder output state (initially ASCII), ISO-2022-JP lead (initially 0x00), and ISO-2022-JP output (initially false).
</p>

<div class="algo">
<p>
`ISO-2022-JP$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し，`~ISO-2022-JP復号器~状態$に応じて：
◎
ISO-2022-JP’s decoder’s handler, given ioQueue and byte, runs these steps, switching on ISO-2022-JP decoder state:
</p>

<dl class="switch">
	<dt>`ASCII@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~escape開始$i ；
~RET `継続-$i
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`0E^X, `0F^X, `1B^X 以外の`~ASCII~byte$
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET ~cp « %~byte »
◎
0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B
• Set ISO-2022-JP output to false and return a code point whose value is byte.
</li>
			<li>
`~EoQ$
⇒＃
~RET `完遂d$i
◎
end-of-queue
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET `~error$i
◎
Otherwise
• Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`Roman@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~escape開始$i ；
~RET `継続-$i
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`5C^X
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET ~cp « `00A5^U `¥^smb »
◎
0x5C
• Set ISO-2022-JP output to false and return code point U+00A5 (¥).
</li>
			<li>
`7E^X
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET ~cp « `203E^U `‾^smb »
◎
0x7E
• Set ISO-2022-JP output to false and return code point U+203E (‾).
</li>
			<li>
`0E^X, `0F^X, `1B^X, `5C^X, `7E^X
以外の`~ASCII~byte$
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET ~cp « %~byte »
◎
0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E
• Set ISO-2022-JP output to false and return a code point whose value is byte.
</li>
			<li>
`~EoQ$
⇒＃
~RET `完遂d$i
◎
end-of-queue
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET `~error$i
◎
Otherwise
• Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`katakana@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~escape開始$i ；
~RET `継続-$i
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`21^X 〜 `5F^X
【！ katakana; subtraction is done first to avoid upsetting compilers 】
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET ~cp « `FF61^X ~MINUS `21^X ~PLUS %~byte »
◎
0x21 to 0x5F
• Set ISO-2022-JP output to false and return a code point whose value is 0xFF61 − 0x21 + byte.
</li>
			<li>
`~EoQ$
⇒＃
~RET `完遂d$i
◎
end-of-queue
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET `~error$i
◎
Otherwise
• Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`~lead~byte@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~escape開始$i ；
~RET `継続-$i
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`21^X 〜 `7E^X
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
`~ISO-2022-JP~lead$ ~SET %~byte ；
`~ISO-2022-JP復号器~状態$ ~SET `~trail~byte$i ；
~RET `継続-$i
◎
0x21 to 0x7E
• Set ISO-2022-JP output to false, ISO-2022-JP lead to byte, ISO-2022-JP decoder state to trail byte, and return continue.
</li>
			<li>
`~EoQ$
⇒＃
~RET `完遂d$i
◎
end-of-queue
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力$ ~SET ~F ；
~RET `~error$i
◎
Otherwise
• Set ISO-2022-JP output to false and return error.
</li>
		</ol>
	</dd>

	<dt>`~trail~byte@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>
		<ol class="switch">
			<li>
`1B^X
【！ iso-2022-jp decoder output state is still lead byte 】
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~escape開始$i ；
~RET `~error$i
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return error.
</li>
			<li>
<p>
`21^X 〜 `7E^X
：
◎
0x21 to 0x7E
</p>
				<ol>
					<li>
`~ISO-2022-JP復号器~状態$ ~SET `~lead~byte$i
◎
Set the ISO-2022-JP decoder state to lead byte.
</li>
					<li>
%~pointer ~LET ( `~ISO-2022-JP~lead$ ~MINUS `21^X ) ~MUL 94 ~PLUS %~byte ~MINUS `21^X
◎
Let pointer be (ISO-2022-JP lead − 0x21) × 94 + byte − 0x21.
</li>
					<li>
%~cp ~LET
`索引~jis0208$ の中で %~pointer が指す`索引~cp$
◎
Let codePoint be the index code point for pointer in index jis0208.
</li>
					<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$i
◎
If codePoint is null, then return error.
</li>
					<li>
~RET ~cp « %~cp »
◎
Return a code point whose value is codePoint.
</li>
				</ol>
			</li>
			<li>
`~EoQ$
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~lead~byte$i ；
~RET `~error$i
◎
end-of-queue
• Set the ISO-2022-JP decoder state to lead byte and return error.
</li>
			<li>
その他
【！ iso-2022-jp decoder output state is still lead byte 】
⇒＃
`~ISO-2022-JP復号器~状態$ ~SET `~lead~byte$i ；
~RET `~error$i
◎
Otherwise
• Set ISO-2022-JP decoder state to lead byte and return error.
</li>
		</ol>
	</dd>

	<dt>`~escape開始@i</dt>
	<dd>
		<ol>
			<li>
~IF［
%~byte ~IN { `24^X【！ $ 】, `28^X【！ ( 】 }
］
⇒＃
`~ISO-2022-JP~lead$ ~SET %~byte ；
`~ISO-2022-JP復号器~状態$ ~SET `~escape$i ；
~RET `継続-$i
◎
If byte is either 0x24 or 0x28, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to escape, and return continue.
</li>
			<li>
~IF［
%~byte ~NEQ `~EoQ$
］
⇒
`入出力~queueに格納し直す$( %入出力~queue, %~byte )
◎
If byte is not end-of-queue, then restore byte to ioQueue.
</li>
			<li>
`~ISO-2022-JP出力$ ~SET ~F
◎
Set ISO-2022-JP output to false,＼
</li>
			<li>
`~ISO-2022-JP復号器~状態$ ~SET `~ISO-2022-JP復号器~出力~状態$
◎
ISO-2022-JP decoder state to ISO-2022-JP decoder output state, and＼
</li>
			<li>
~RET `~error$i
◎
return error.
</li>
		</ol>
	</dd>

	<dt>`~escape@i</dt>
	<dd>
		<ol>
			<li>
%~lead ~LET `~ISO-2022-JP~lead$
◎
Let lead be ISO-2022-JP lead and＼
</li>
			<li>
`~ISO-2022-JP~lead$ ~SET `00^X
◎
set ISO-2022-JP lead to 0x00.
</li>
			<li>
%状態 ~LET
( %~lead, %~byte )
に応じて
⇒＃
( `28^X, `42^X【！B 】 ) ならば `ASCII$i ／
( `28^X, `4A^X【！J 】 ) ならば `Roman$i1 ／
( `28^X, `49^X【！I 】 ) ならば `katakana$i ／
( `24^X, `40^X【！@ 】 ) ならば `~lead~byte$i ／
( `24^X, `42^X【！B 】 ) ならば `~lead~byte$i ／
~ELSE_ ~NULL
◎
Let state be null.
◎
If lead is 0x28 and byte is 0x42, set state to ASCII.
◎
If lead is 0x28 and byte is 0x4A, set state to Roman.
◎
If lead is 0x28 and byte is 0x49, set state to katakana.
◎
If lead is 0x24 and byte is either 0x40 or 0x42, set state to lead byte.
</li>
			<li>
<p>
~IF［
%状態 ~NEQ ~NULL
］：
◎
If state is non-null:
</p>
				<ol>
					<li>
`~ISO-2022-JP復号器~状態$ ~SET %状態
◎
↓</li>
					<li>
`~ISO-2022-JP復号器~出力~状態$ ~SET %状態
◎
Set ISO-2022-JP decoder state and ISO-2022-JP decoder output state to state.
</li>
					<li>
%出力 ~LET `~ISO-2022-JP出力$
◎
Let output be the value of ISO-2022-JP output.
</li>
					<li>
`~ISO-2022-JP出力$ ~SET ~T
◎
Set ISO-2022-JP output to true.
</li>
					<li>
~RET %出力 に応じて
⇒＃
~F ならば `継続-$i ／
~T ならば `~error$i
◎
Return continue, if output is false, and error otherwise.
</li>
				</ol>
			</li>
			<li>
~IF［
%~byte ~EQ `~EoQ$
］
⇒
`入出力~queueに格納し直す$( %入出力~queue, %~lead )
◎
If byte is end-of-queue, then restore lead to ioQueue;＼
</li>
			<li>
~ELSE
⇒
`入出力~queueに格納し直す$( %入出力~queue, ~byte列 « %~lead, %~byte » )
◎
otherwise, restore « lead, byte » to ioQueue.
</li>
			<li>
`~ISO-2022-JP出力$ ~SET ~F
◎
Set ISO-2022-JP output to false,＼
</li>
			<li>
`~ISO-2022-JP復号器~状態$ ~SET `~ISO-2022-JP復号器~出力~状態$
◎
ISO-2022-JP decoder state to ISO-2022-JP decoder output state and＼
</li>
			<li>
~RET `~error$i
◎
return error.
</li>
		</ol>
	</dd>
</dl>
</div>

			</section>
			<section id="iso-2022-jp-encoder">
<h4 title="ISO-2022-JP encoder">12.2.2. ~ISO-2022-JP符号化器</h4>

<div class="note">

<p>注記：
`~ISO-2022-JP符号化器$は、［
複数の出力を連結した結果を対応する`復号器$にかけたとき，
`~error$i になり得る
］ような，唯一の`符号化器$である。
◎
The ISO-2022-JP encoder is the only encoder for which the concatenation of multiple outputs can result in an error when run through the corresponding decoder.
</p>

<p class="example">
`00A5^U を符号化した結果は
[ `1B^X `28^X `4A^X `5C^X `1B^X `28^X `42^X ]
になる。
その結果に同じ結果を連結してから復号した結果は、
[ `00A5^U `FFFD^U `00A5^U ]
になる。
◎
Encoding U+00A5 gives 0x1B 0x28 0x4A 0x5C 0x1B 0x28 0x42. Doing that twice, concatenating the results, and then decoding yields U+00A5 U+FFFD U+00A5.
</p>

</div>

<p>
各［
`ISO-2022-JP$n の`符号化器$
］には、
次が結付けられる
⇒
`~ISO-2022-JP符号化器~状態@
— 次のいずれかをとり得る（初期~時は `ASCII$i1 ）
⇒
`ASCII@i1 ／
`Roman@i1 ／
`jis0208@i1
◎
ISO-2022-JP’s encoder has an associated ISO-2022-JP encoder state which is ASCII, Roman, or jis0208 (initially ASCII).
</p>

<div class="algo">
<p>
`ISO-2022-JP$n の`符号化器$の`~handler$は、
所与の
( %入出力~queue, %~cp )
に対し：
◎
ISO-2022-JP’s encoder’s handler, given ioQueue and codePoint, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~cp ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
`~ISO-2022-JP符号化器~状態$ ~NEQ `ASCII$i1
］
⇒＃
`~ISO-2022-JP符号化器~状態$ ~SET `ASCII$i1 ；
~RET ~byte列 « `1B^X, `28^X, `42^X »
◎
If codePoint is end-of-queue and ISO-2022-JP encoder state is not ASCII, then set ISO-2022-JP encoder state to ASCII and return three bytes 0x1B 0x28 0x42.
</li>
			<li>
~RET `完遂d$i
◎
If codePoint is end-of-queue and ISO-2022-JP encoder state is ASCII, then return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~ISO-2022-JP符号化器~状態$ ~IN
{ `ASCII$i1, `Roman$i1 }
］~AND［
%~cp ~IN { `000E^U, `000F^U, `001B^U }
］
⇒
~RET `~error$i( `FFFD^U `�^smb )
◎
If ISO-2022-JP encoder state is ASCII or Roman, and codePoint is U+000E, U+000F, or U+001B, then return error with U+FFFD (�).
</p>

<p class="note">注記：
攻撃を防ぐため、
ここでは，［
%~cp ではなく， `FFFD^U `�^smb
］を返す。
◎
This returns U+FFFD (�) rather than codePoint to prevent attacks.
</p>
【！ https://github.com/whatwg/encoding/issues/15 】
	</li>
	<li>
~IF［
`~ISO-2022-JP符号化器~状態$ ~EQ `ASCII$i1
］~AND［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte « %~cp »
◎
If ISO-2022-JP encoder state is ASCII and codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
<p>
~IF［
`~ISO-2022-JP符号化器~状態$ ~EQ `Roman$i1
］：
</p>
		<ol>
			<li>
%結果 ~LET %~cp に応じて
⇒＃
`005C^U `\^smb, `007E^U `~^smb 以外の`~ASCII~cp$ならば ~byte « %~cp » ／
`00A5^U `¥^smb ならば ~byte « `5C^X » ／
`203E^U `‾^smb ならば ~byte « `7E^X » ／
~ELSE_ ~NULL
</li>
			<li>
~IF［
%結果 ~NEQ ~NULL
］
⇒
~RET %結果
◎
↑</li>
		</ol>
◎
If ISO-2022-JP encoder state is Roman and codePoint is an ASCII code point, excluding U+005C (\) and U+007E (~), or is U+00A5 (¥) or U+203E (‾):
• If codePoint is an ASCII code point, then return a byte whose value is codePoint.
• If codePoint is U+00A5 (¥), then return byte 0x5C.
• If codePoint is U+203E (‾), then return byte 0x7E.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］~AND［
`~ISO-2022-JP符号化器~状態$ ~NEQ `ASCII$i1
］
⇒＃
`入出力~queueに格納し直す$( %入出力~queue, %~cp )；
`~ISO-2022-JP符号化器~状態$ ~SET `ASCII$i1 ；
~RET ~byte列 « `1B^X, `28^X, `42^X »
◎
If codePoint is an ASCII code point, and ISO-2022-JP encoder state is not ASCII, then restore codePoint to ioQueue, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
	<li>
~IF［
%~cp ~NIN { `00A5^U `¥^smb, `203E^U `‾^smb }
］~AND［
`~ISO-2022-JP符号化器~状態$ ~NEQ `Roman$i1
］
⇒＃
`入出力~queueに格納し直す$( %入出力~queue, %~cp )；
`~ISO-2022-JP符号化器~状態$ ~SET `Roman$i1 ；
~RET ~byte列 « `1B^X, `28^X, `4A^X »
◎
If codePoint is either U+00A5 (¥) or U+203E (‾), and ISO-2022-JP encoder state is not Roman, then restore codePoint to ioQueue, set ISO-2022-JP encoder state to Roman, and return three bytes 0x1B 0x28 0x4A.
</li>
	<li>
~IF［
%~cp ~EQ `2212^U `−^smb
］
⇒
%~cp ~SET `FF0D^U `－^smb
◎
If codePoint is U+2212 (−), then set it to U+FF0D (－).
</li>
	<li>
~IF［
%~cp ~IN { `FF61^U 〜 `FF9F^U }
］
⇒
%~cp ~SET `索引~ISO-2022-JP~katakana$の中で
( %~cp ~MINUS `FF61^X )
が指す`索引~cp$
◎
If codePoint is in the range U+FF61 to U+FF9F, inclusive, then set it to the index code point for codePoint − 0xFF61 in index ISO-2022-JP katakana.
</li>
	<li>
<p>
%~pointer ~LET `索引~jis0208$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for codePoint in index jis0208.
</p>

<p class="note">注記：
%~pointer は、
~NULL でなければ，`索引~jis0208$と~pointer演算の資質に因り 8836 未満になる。
◎
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
<p>
~IF［
%~pointer ~EQ ~NULL
］：
◎
If pointer is null:
</p>
		<ol>
			<li>
~IF［
`~ISO-2022-JP符号化器~状態$ ~EQ `jis0208$i1
］
⇒＃
`入出力~queueに格納し直す$( %入出力~queue, %~cp )；
`~ISO-2022-JP符号化器~状態$ ~SET `ASCII$i1 ；
~RET ~byte列 « `1B^X, `28^X, `42^X »
◎
If ISO-2022-JP encoder state is jis0208, then restore codePoint to ioQueue, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
			<li>
~RET `~error$i( %~cp )
◎
Return error with codePoint.
</li>
		</ol>
	</li>
	<li>
~IF［
`~ISO-2022-JP符号化器~状態$ ~NEQ `jis0208$i1
］
⇒＃
`入出力~queueに格納し直す$( %入出力~queue, %~cp )；
`~ISO-2022-JP符号化器~状態$ ~SET `jis0208$i1 ；
~RET ~byte列 « `1B^X, `24^X, `42^X »
◎
If ISO-2022-JP encoder state is not jis0208, restore codePoint to ioQueue, set ISO-2022-JP encoder state to jis0208, and return three bytes 0x1B 0x24 0x42.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `21^X
◎
Let lead be pointer / 94 + 0x21.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `21^X
◎
Let trail be pointer % 94 + 0x21.
</li>
	<li>
~RET ~byte列 « %~lead, %~trail »
◎
Return two bytes whose values are lead and trail.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="shift_jis">
<h3 title="Shift_JIS">12.3. ~Shift_JIS</h3>

			<section id="shift_jis-decoder">
<h4 title="Shift_JIS decoder">12.3.1. ~Shift_JIS復号器</h4>

<p>
各［
`Shift_JIS$n の`復号器$
］には、
次が結付けられる
⇒
`~Shift_JIS~lead@（初期~時は `00^X ）
◎
Shift_JIS’s decoder has an associated Shift_JIS lead (initially 0x00).
</p>

<div class="algo">
<p>
`Shift_JIS$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し：
◎
Shift_JIS’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
`~Shift_JIS~lead$ ~NEQ `00^X
］
⇒＃
`~Shift_JIS~lead$ ~SET `00^X ；
~RET `~error$i
◎
If byte is end-of-queue and Shift_JIS lead is not 0x00, set Shift_JIS lead to 0x00 and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$i
◎
If byte is end-of-queue and Shift_JIS lead is 0x00, then return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~Shift_JIS~lead$ ~NEQ `00^X
］：
◎
If Shift_JIS lead is not 0x00:
</p>
		<ol>
			<li>
%~lead ~LET `~Shift_JIS~lead$
◎
Let lead be Shift_JIS lead.
</li>
			<li>
`~Shift_JIS~lead$ ~SET `00^X
◎
Set Shift_JIS lead to 0x00.
</li>
			<li>
%~pointer ~LET ~NULL
◎
Let pointer be null.
</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if byte is less than 0x7F; otherwise 0x41.
</li>
			<li>
%~lead~offset ~LET ［
%~lead ~IN { `00^X 〜 `9F^X } ならば `81^X ／
~ELSE_ `C1^X
］
◎
Let lead offset be 0x81 if lead is less than 0xA0; otherwise 0xC1.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `80^X 〜 `FC^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS %~lead~offset ) ~MUL 188 ~PLUS %~byte ~MINUS %~offset
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFC, inclusive, then set pointer to (lead − lead offset) × 188 + byte − offset.
</li>
			<li>
<p>
~IF［
%~pointer ~IN { 8836 〜 10715 }
］
【！ subtraction is done first to avoid upsetting compilers 】
⇒
~RET ~cp « `E000^X ~MINUS 8836 ~PLUS %~pointer »
◎
If pointer is in the range 8836 to 10715, inclusive, then return a code point whose value is 0xE000 − 8836 + pointer.
</p>

<p class="note">注記：
これは EUDC として周知な，旧来の Windows によるものと相互運用可能にする。
【！ PUA 】
◎
This is interoperable legacy from Windows known as EUDC.
</p>

<p class="trans-note">【
EUDC — いわゆる外字~用の機能。
】【
8836 = 94 ~MUL 94 は~Shift_JIS（ JIS X 0208 ）の`区点番号＠https://ja.wikipedia.org/wiki/%E5%8C%BA%E7%82%B9%E7%95%AA%E5%8F%B7$の総数。
結果の~cpは~Unicode私用領域に入る。
】</p>

			</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~jis0208$ の中で %~pointer が指す`索引~cp$
］
◎
Let codePoint be null if pointer is null; otherwise the index code point for pointer in index jis0208.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp « %~cp »
◎
If codePoint is non-null, then return a code point whose value is codePoint.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
`入出力~queueに格納し直す$( %入出力~queue, %~byte )
◎
If byte is an ASCII byte, then restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN { `~ASCII~byte$, `80^X}
］
⇒
~RET ~cp « %~byte »
【！ Opera has 0x7E 】
◎
If byte is an ASCII byte or 0x80, then return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `A1^X 〜 `DF^X }
］
【！ katakana; subtraction is done first to avoid upsetting compilers 】
⇒
~RET ~cp « `FF61^X ~PLUS ( %~byte ~MINUS `A1^X ) »
◎
If byte is in the range 0xA1 to 0xDF, inclusive, then return a code point whose value is 0xFF61 − 0xA1 + byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `9F^X, `E0^X 〜 `FC^X }
］
⇒＃
`~Shift_JIS~lead$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0 to 0xFC, inclusive, then set Shift_JIS lead to byte and return continue.
</li>
	<li>
~RET `~error$i
◎
Return error.
</li>
</ol>
</div>

			</section>
			<section id="shift_jis-encoder">
<h4 title="Shift_JIS encoder">12.3.2. ~Shift_JIS符号化器</h4>

<div class="algo">
<p>
`Shift_JIS$n の`符号化器$の`~handler$は、
所与の
( %利用されない~queue, %~cp )
に対し：
◎
Shift_JIS’s encoder’s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
%結果 ~LET %~cp に応じて
⇒＃
`~EoQ$ ならば `完遂d$i ／
`~ASCII~cp$ならば ~byte « %~cp » ／
`0080^U ならば ~byte « %~cp » ／
`00A5^U `¥^smb ならば ~byte « `5C^X » ／
`203E^U `‾^smb ならば ~byte « `7E^X » ／
`FF61^U 〜 `FF9F^U ならば ~byte « ( %~cp ~MINUS `FF61^X ) ~PLUS `A1^X » ／
~ELSE_ ~NULL
◎
If codePoint is end-of-queue, then return finished.
◎
If codePoint is an ASCII code point or U+0080, then return a byte whose value is codePoint.
◎
If codePoint is U+00A5 (¥), then return byte 0x5C.
◎
If codePoint is U+203E (‾), then return byte 0x7E.
◎
If codePoint is in the range U+FF61 to U+FF9F, inclusive, then return a byte whose value is codePoint − 0xFF61 + 0xA1.
</li>
	<li>
~IF［
%結果 ~NEQ ~NULL
］
⇒
~RET %結果
◎
↑</li>
	<li>
~IF［
%~cp ~EQ `2212^U `−^smb
］
⇒
%~cp ~SET `FF0D^U `－^smb
◎
If codePoint is U+2212 (−), then set it to U+FF0D (－).
</li>
	<li>
%~pointer ~LET
%~cp を指す`索引~Shift_JIS~pointer$
◎
Let pointer be the index Shift_JIS pointer for codePoint.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET `~error$i( %~cp )
◎
If pointer is null, then return error with codePoint.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 188 )
◎
Let lead be pointer / 188.
</li>
	<li>
%~lead~offset ~LET ［
%~lead ~IN { `00^X 〜 `1E^X } ならば `81^X ／
~ELSE_ `C1^X【！ 0xA0-0x81 】
］
◎
Let lead offset be 0x81 if lead is less than 0x1F; otherwise 0xC1.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 188
◎
Let trail be pointer % 188.
</li>
	<li>
%~offset ~LET ［
%~trail ~IN { `00^X 〜 `3E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if trail is less than 0x3F; otherwise 0x41.
</li>
	<li>
~RET ~byte列 « ( %~lead ~PLUS %~lead~offset ), ( %~trail ~PLUS %~offset ) »
◎
Return two bytes whose values are lead + lead offset and trail + offset.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-korean-encodings">
<h2 title="Legacy multi-byte Korean encodings">13. 旧来の複-~byte~Korean符号化法</h2>

		<section id="euc-kr">
<h3 title="EUC-KR">13.1. ~EUC-KR</h3>

			<section id="euc-kr-decoder">
<h4 title="EUC-KR decoder">13.1.1. ~EUC-KR復号器</h4>

<p>
各［
`EUC-KR$n の`復号器$
］には、
次が結付けられる
⇒
`~EUC-KR~lead@（初期~時は `00^X ）
◎
EUC-KR’s decoder has an associated EUC-KR lead (initially 0x00).
</p>

<div class="algo">
<p>
`EUC-KR$n の`復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し：
◎
EUC-KR’s decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
`~EUC-KR~lead$ ~NEQ `00^X
］
⇒＃
`~EUC-KR~lead$ ~SET `00^X ；
~RET `~error$i
◎
If byte is end-of-queue and EUC-KR lead is not 0x00, then set EUC-KR lead to 0x00 and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$i
◎
If byte is end-of-queue and EUC-KR lead is 0x00, then return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~EUC-KR~lead$ ~NEQ `00^X
］：
◎
If EUC-KR lead is not 0x00:
</p>
		<ol>
			<li>
%~lead ~LET `~EUC-KR~lead$
◎
Let lead be EUC-KR lead.
</li>
			<li>
`~EUC-KR~lead$ ~SET `00^X
◎
Set EUC-KR lead to 0x00.
</li>
			<li>
%~pointer ~LET ~NULL
◎
Let pointer be null.
</li>
			<li>
~IF［
%~byte ~IN { `41^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS `41^X )
◎
If byte is in the range 0x41 to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 + (byte − 0x41).
</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~EUC-KR$ の中で %~pointer が指す`索引~cp$
］
◎
Let codePoint be null if pointer is null; otherwise the index code point for pointer in index EUC-KR.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp « %~cp »
◎
If codePoint is non-null, then return a code point whose value is codePoint.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
`入出力~queueに格納し直す$( %入出力~queue, %~byte )
◎
If byte is an ASCII byte, then restore byte to ioQueue.
</li>
			<li>
~RET `~error$i
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp « %~byte »
◎
If byte is an ASCII byte, then return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~EUC-KR~lead$ ~SET %~byte ；
~RET `継続-$i
◎
If byte is in the range 0x81 to 0xFE, inclusive, then set EUC-KR lead to byte and return continue.
</li>
	<li>
~RET `~error$i
◎
Return error.
</li>
</ol>
</div>

			</section>
			<section id="euc-kr-encoder">
<h4 title="EUC-KR encoder">13.1.2. ~EUC-KR符号化器</h4>

<div class="algo">
<p>
`EUC-KR$n の`符号化器$の`~handler$は、
所与の
( %利用されない~queue, %~cp )
に対し：
◎
EUC-KR’s encoder’s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~IF［
%~cp ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If codePoint is end-of-queue, then return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte « %~cp »
◎
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
</li>
	<li>
%~pointer ~LET
`索引~EUC-KR$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for codePoint in index EUC-KR.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET `~error$i( %~cp )
◎
If pointer is null, then return error with codePoint.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
◎
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET ( %~pointer ~MOD 190 ) ~PLUS `41^X
◎
Let trail be pointer % 190 + 0x41.
</li>
	<li>
~RET ~byte列 « %~lead, %~trail »
◎
Return two bytes whose values are lead and trail.
</li>
</ol>
</div>

			</section>
		</section>

【！ removed from the spec 2013-08-23: 13.2 iso-2022-kr id="iso-2022-kr" 】

	</section>
	<section id="legacy-miscellaneous-encodings">
<h2 title="Legacy miscellaneous encodings">14. 旧来の諸々の符号化法</h2>

		<section id="replacement">
<h3 title="replacement">14.1. ~replacement</h3>

<p class="note">注記：
`replacement$n `符号化法$は、
~serverと~clientにおける `符号化法$の~supportの不一致を突く，ある種の攻撃を防ぐためのものである。
◎
The replacement encoding exists to prevent certain attacks that abuse a mismatch between encodings supported on the server and the client.
</p>

			<section id="replacement-decoder">
<h4 title="replacement decoder">14.1.1. ~replacement復号器</h4>

<p>
各［
`replacement$n の`復号器$
］には、
次が結付けられる
⇒
`~replacement~errorは返したか@（初期~時は ~F ）
◎
replacement’s decoder has an associated replacement error returned (initially false).
</p>

<div class="algo">
<p>
`replacement$n の`復号器$の`~handler$は、
所与の
( %利用されない~queue, %~byte )
に対し：
◎
replacement’s decoder’s handler, given unused and byte, runs these steps:
</p>
<ol>
	<li>
~IF［
%~byte ~EQ `~EoQ$
］
⇒
~RET `完遂d$i
◎
If byte is end-of-queue, then return finished.
</li>
	<li>
~IF［
`~replacement~errorは返したか$ ~EQ ~F
］
⇒＃
`~replacement~errorは返したか$ ~SET ~T ；
~RET `~error$i
◎
If replacement error returned is false, then set replacement error returned to true and return error.
</li>
	<li>
~RET `完遂d$i
◎
Return finished.
</li>
</ol>
</div>

<p class="trans-note">【
`replacement$n には、
`符号化器$は無い。
】</p>

			</section>
		</section>
		<section id="common-infrastructure-for-utf-16be-and-utf-16le">
<h3 title="Common infrastructure for UTF-16BE/LE">14.2. `UTF-16BE/LE$n に共通な基盤</h3>

<p>
`UTF-16BE/LE@n
は、［
`UTF-16BE$n ／ `UTF-16LE$n
］の総称である。
◎
UTF-16BE/LE is UTF-16BE or UTF-16LE.
</p>

			<section id="shared-utf-16-decoder">
<h4 title="shared UTF-16 decoder">14.2.1. 共用~UTF-16復号器</h4>

<p class="note">注記：
~BOMは~labelより優先される。
それは，配備-済みな内容において、
どの~labelよりも正確aであることが見出されているので。
したがって それは、
`共用~UTF-16復号器$の一部ではなく，`~Unicodeに復号する$ ~algoの一部を成す。
◎
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the shared UTF-16 decoder algorithm but rather the decode algorithm.
</p>

<p>
各［
`共用~UTF-16復号器$
］には、
次が結付けられる
⇒＃
`~UTF-16~lead~byte@（初期~時は ~NULL ）,
`~UTF-16頭部~surrogate@（初期~時は ~NULL ）,
`~UTF-16BE復号器~用か@（初期~時は ~F ）
◎
shared UTF-16 decoder has an associated UTF-16 lead byte and UTF-16 leading surrogate (both initially null), and is UTF-16BE decoder (initially false).
</p>

<div class="algo">
<p>
`共用~UTF-16復号器$の`~handler$は、
所与の
( %入出力~queue, %~byte )
に対し：
◎
shared UTF-16 decoder’s handler, given ioQueue and byte, runs these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoQ$
］：
◎
↓</p>
		<ol>
			<li>
~IF［
`~UTF-16~lead~byte$ ~NEQ ~NULL
］~OR［
`~UTF-16頭部~surrogate$ ~NEQ ~NULL
］
⇒＃
`~UTF-16~lead~byte$ ~SET ~NULL；
`~UTF-16頭部~surrogate$ ~SET ~NULL；
~RET `~error$i
◎
If byte is end-of-queue and either UTF-16 lead byte or UTF-16 leading surrogate is non-null, set UTF-16 lead byte and UTF-16 leading surrogate to null, and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$i
◎
If byte is end-of-queue and UTF-16 lead byte and UTF-16 leading surrogate are null, then return finished.
</li>
		</ol>
	</li>
	<li>
~IF［
`~UTF-16~lead~byte$ ~EQ ~NULL
］
⇒＃
`~UTF-16~lead~byte$ ~SET %~byte ；
~RET `継続-$i
◎
If UTF-16 lead byte is null, then set UTF-16 lead byte to byte and return continue.
</li>
	<li>
%~cu ~LET `~UTF-16BE復号器~用か$に応じて
⇒＃
~T ならば ( ( `~UTF-16~lead~byte$ ~Lshift 8 ) ~PLUS %~byte ) ／
~F ならば ( ( %~byte ~Lshift 8 ) ~PLUS `~UTF-16~lead~byte$ )
◎
Let codeUnit be the result of:
• is UTF-16BE decoder is true
•• (UTF-16 lead byte &lt;&lt; 8) + byte.
• is UTF-16BE decoder is false
•• (byte &lt;&lt; 8) + UTF-16 lead byte.
</li>
	<li>
`~UTF-16~lead~byte$ ~SET ~NULL
◎
Then set UTF-16 lead byte to null.
</li>
	<li>
<p>
~IF［
`~UTF-16頭部~surrogate$ ~NEQ ~NULL
］：
◎
If UTF-16 leading surrogate is non-null:
</p>
		<ol>
			<li>
%頭部~surrogate ~LET `~UTF-16頭部~surrogate$
◎
Let leadingSurrogate be UTF-16 leading surrogate.
</li>
			<li>
`~UTF-16頭部~surrogate$ ~SET ~NULL
◎
Set UTF-16 leading surrogate to null.
</li>
			<li>
~IF［
%~cu は`尾部~surrogate$である
］
⇒
~RET `~surrogate対から~scalar値を得する$( %頭部~surrogate, %~cu )
◎
If codeUnit is a trailing surrogate, then return a scalar value from surrogates given leadingSurrogate and codeUnit.
</li>
			<li>
%byte1 ~LET %~cu ~Rshift 8
◎
Let byte1 be codeUnit &gt;&gt; 8.
</li>
			<li>
%byte2 ~LET %~cu ~bAND `00FF^X
◎
Let byte2 be codeUnit &amp; 0x00FF.
</li>
			<li>
%~byte列 ~LET `~UTF-16BE復号器~用か$に応じて
⇒＃
~T ならば ~byte列 « %byte1, %byte2 » ／
~F ならば ~byte列 « %byte2, %byte1 »
◎
Let bytes be a list of two bytes whose values are byte1 and byte2, if is UTF-16BE decoder is true; otherwise byte2 and byte1.
</li>
			<li>
`入出力~queueに格納し直す$( %入出力~queue, %~byte列 )
◎
Restore bytes to ioQueue and return error.
</li>
			<li>
~RET `~error$i
◎
↑</li>
		</ol>
	</li>
	<li>
~IF［
%~cu は`頭部~surrogate$である
］
⇒＃
`~UTF-16頭部~surrogate$ ~SET %~cu ；
~RET `継続-$i
◎
If codeUnit is a leading surrogate, then set UTF-16 leading surrogate to codeUnit and return continue.
</li>
	<li>
~IF［
%~cu は`尾部~surrogate$である
］
⇒
~RET `~error$i
◎
If codeUnit is a trailing surrogate, then return error.
</li>
	<li>
~RET ~cp « %~cu »
◎
Return code point codeUnit.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="utf-16be">
<h3 title="UTF-16BE">14.3. ~UTF-16BE</h3>

			<section id="utf-16be-decoder">
<h4 title="UTF-16BE decoder">14.3.1. ~UTF-16BE復号器</h4>

<p>
`UTF-16BE$n の`復号器$は、［
`~UTF-16BE復号器~用か$ ~SET ~T
］にされた`共用~UTF-16復号器$である。
◎
UTF-16BE’s decoder is shared UTF-16 decoder with its is UTF-16BE decoder set to true.
</p>

			</section>
		</section>
		<section id="utf-16le">
<h3 title="UTF-16LE">14.4. ~UTF-16LE</h3>

<p class="note">注記：
配備-済みな内容に~~対処するため、
`utf-16^lb は `UTF-16LE$n 用の`~label$にされている。
◎
"utf-16" is a label for UTF-16LE to deal with deployed content.
</p>

			<section id="utf-16le-decoder">
<h4 title="UTF-16LE decoder">14.4.1. ~UTF-16LE復号器</h4>

<p>
`UTF-16BE$n の`復号器$は、
`共用~UTF-16復号器$である。
◎
UTF-16LE’s decoder is shared UTF-16 decoder.
</p>

			</section>
		</section>
		<section id="x-user-defined">
<h3 title="x-user-defined">14.5. ~x-user-defined</h3>

<p class="note">注記：
これは形上では`単-~byte符号化法$であるが、
~algo的に実装できるので，別々に定義される。
◎
While technically this is a single-byte encoding, it is defined separately as it can be implemented algorithmically.
</p>

			<section id="x-user-defined-decoder">
<h4 title="x-user-defined decoder">14.5.1. ~x-user-defined復号器</h4>

<div class="algo">
<p>
`x-user-defined$n の`復号器$の`~handler$は、
所与の
( %利用されない~queue, %~byte )
に対し：
◎
x-user-defined’s decoder’s handler, given unused and byte, runs these steps:
</p>
<ol>
	<li>
~RET %~byte に応じて
⇒＃
`~EoQ$ならば `完遂d$i ／
`~ASCII~byte$であるならば ~cp « %~byte » ／
~ELSE_ ~cp « `F780^X ~PLUS %~byte ~MINUS `80^X »
◎
If byte is end-of-queue, then return finished.
◎
If byte is an ASCII byte, then return a code point whose value is byte.
◎
Return a code point whose value is 0xF780 + byte − 0x80.
</li>
</ol>
</div>

			</section>
			<section id="x-user-defined-encoder">
<h4 title="x-user-defined encoder">14.5.2. ~x-user-defined符号化器</h4>

<div class="algo">
<p>
`x-user-defined$n の`符号化器$の`~handler$は、
所与の
( %利用されない~queue, %~cp )
に対し：
◎
x-user-defined’s encoder’s handler, given unused and codePoint, runs these steps:
</p>
<ol>
	<li>
~RET %~cp に応じて
⇒＃
`~EoQ$ならば `完遂d$i ／
`~ASCII~cp$ならば ~byte « %~cp » ／
`F780^U 〜 `F7FF^U ならば ~byte « %~cp ~MINUS `F780^X ~PLUS `80^X » ／
~ELSE_ `~error$i( %~cp )
◎
If codePoint is end-of-queue, then return finished.
◎
If codePoint is an ASCII code point, then return a byte whose value is codePoint.
◎
If codePoint is in the range U+F780 to U+F7FF, inclusive, then return a byte whose value is codePoint − 0xF780 + 0x80.
◎
Return error with codePoint.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="browser-ui">
<h2 title="Browser UI">15. ~browser~UI</h2>

<p>
~browserには、
資源の符号化法に対する上書きを可能化させないことが奨励される。
にもかかわらず，その種の特能が在る場合、
前述した`~securityの課題＠#security-background$から，
~browserは `UTF-16BE/LE$n を~optionとして提供するベキでない。
~browserは、
資源が `UTF-16BE/LE$n を利用して復号された場合でも，
この特能を不能化するベキである。
◎
Browsers are encouraged to not enable overriding the encoding of a resource. If such a feature is nonetheless present, browsers should not offer UTF-16BE/LE as an option, due to the aforementioned security issues. Browsers should also disable this feature if the resource was decoded using UTF-16BE/LE.
</p>

	</section>
	<section id="implementation-considerations">
<h2 title="Implementation considerations">実装の考慮点</h2>

<p>
この標準における`符号化法$用の`復号器$は、
`格納し直す演算$を備える`入出力~queue$を~supportする代わりに，
次により実装することもできる：
◎
Instead of supporting I/O queues with arbitrary restore, the decoders for encodings in this standard could be implemented with:
</p>
<ol>
	<li>
読取った現在の~byteを元に戻す能
◎
The ability to unread the current byte.
</li>
	<li>
`ISO-2022-JP$n 用の単-~byte（ `24^X ／ `28^X ）~buffer
◎
↓</li>
	<li>
<p>
`gb18030$n 用の単-~byte（ `~ASCII~byte$ ）~buffer
◎
A single-byte buffer for gb18030 (an ASCII byte) and ISO-2022-JP (0x24 or 0x28).
</p>

<p class="example" id="example-gb18030-implementation-strategy">
`gb18030$n に対しては、［
`~gb3$ ~NEQ `00^X
］の間に~~不正な~byteに出くわしたときは、
`~gb2$は，次回に返すことになる単-~byte~bufferの中に移動でき、
`~gb3$が
— 単-~byte~bufferを返して空にした後， `00^X でないことを検査したなら —
新たな`~gb1$になる。
これは、
`gb18030$n における 1 個目と 3 個目の~byte範囲が一致するので可能になる。
◎
For gb18030 when hitting a bogus byte while gb18030 third is not 0x00, gb18030 second could be moved into the single-byte buffer to be returned next, and gb18030 third would be the new gb18030 first, checked for not being 0x00 after the single-byte buffer was returned and emptied. This is possible as the range for the first and third byte in gb18030 is identical.
</p>
	</li>
</ol>

<p>
`~ISO-2022-JP符号化器$には，追加的な状態として`~ISO-2022-JP符号化器~状態$が必要になるが、
それ以外では、
この標準におけるどの`符号化法$用にも，その`符号化器$に追加的な［
状態／~buffer
］は要求されない。
◎
The ISO-2022-JP encoder needs ISO-2022-JP encoder state as additional state, but other than that, none of the encoders for encodings in this standard require additional state or buffers.
</p>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り、
符号化法を相互運用可能なものにするために，たくさんの方々が助力され、
この標準の目標へ近付けてきた。
同様に多くの方々の助力が，この標準を~~現在の姿に仕立て上げてきた。
特に，次の方々に感謝する：
◎
There have been a lot of people that have helped make encodings more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</p>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main>

<div hidden>
<div lang="en" id="_acks1">
<p>
With that, many thanks to

Adam Rice,
Alan Chaney,
Alexander Shtuchkin,
Allen Wirfs-Brock,
Andreu Botella,
Aneesh Agrawal,
Arkadiusz Michalski,
Asmus Freytag,
Ben Noordhuis,
Bnaya Peretz,
Boris Zbarsky,
Bruno Haible,
Cameron McCormack,
Charles McCathieNeville,
Christopher Foo,
CodifierNL,
David Carlisle,
Domenic Denicola,
Dominique Hazaël-Massieux,
Doug Ewell,
Erik van der Poel,
<span lang="zh">譚永鋒</span> (Frank Yung-Fong Tang),
Glenn Maynard,
Gordon P. Hemsley,
Henri Sivonen,
Ian Hickson,
J. King,
James Graham,
Jeffrey Yasskin,
John Tamplin,
Joshua Bell,
<span lang="ja">村井純</span> (Jun Murai),
<span lang="ko">신정식</span> (Jungshik Shin),
Jxck,
<span lang="ko">강 성훈</span> (Kang Seonghoon),
<span lang="ja">川幡太一</span> (Kawabata Taichi),
Ken Lunde,
Ken Whistler,
Kenneth Russell,
<span lang="ja">田村健人</span> (Kent Tamura),
Leif Halvard Silli,
Luke Wagner,
Maciej Hirsz,
Makoto Kato,
Mark Callow,
Mark Crispin,
Mark Davis,
Martin Dürst,
Masatoshi Kimura,
Mattias Buelens,
Ms2ger,
Nigel Megitt,
Nigel Tao,
Norbert Lindenberg,
Øistein E. Andersen,
Peter Krefting,
Philip Jägenstedt,
Philip Taylor,
Richard Ishida,
Robbert Broersma,
Robert Mustacchi,
Ryan Dahl,
Sam Sneddon,
Shawn Steele,
Simon Montagu,
Simon Pieters,
Simon Sapin,
Stephen Checkoway,
<span lang="ja">寺田健</span> (Takeshi Terada),
Vyacheslav Matva,
Wolf Lammen, and
<span lang="ja">成瀬ゆい</span> (Yui Naruse)

for being awesome.
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.apple.com/">Apple</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
The <a href="#api">API</a> chapter was initially written by Joshua Bell
(<a href="https://www.google.com/">Google</a>).
</p>
</div>

<div lang="en" id="_ipr1">
<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://encoding.spec.whatwg.org/review-drafts/2024-12/">Living Standard Review Draft</a>.
</p>
</div>

</div>
