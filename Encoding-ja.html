<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Encoding Standard â€” ç¬¦å·åŒ–æ–¹å¼ æ¨™æº–ï¼ˆæ—¥æœ¬èªè¨³ï¼‰</title>
<meta name="keywords" content="æ–‡å­—ç¬¦å·åŒ–,ç¬¦å·åŒ–,ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°,æ¨™æº–,ä»•æ§˜,WHATWG">

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://encoding.spec.whatwg.org/',
		main: 'MAIN',
		alt_refs: 'references',
		ref_id_prefix: 'refs'
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: 'è‹±èªä¸»ä½“:è‹±èªå¯„ã‚Š:æ¼¢å­—ä¸»ä½“:ã‚«ãƒŠä¸»ä½“',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked 160331 spec.

	return options;
}


function expand(mapping1){

	var link_map = this.link_map;
	var nesting = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/â‡’|â—[^<â—]*|%[~\w\-ä¸€-é¿†]+|([`@$][\^!@$%]?)([~\w\-\.:]+)/g,
			create_html
		),
		mapping1
	);
	// ç›®æ¬¡æ§‹ç¯‰
	Util.rebuildToc('MAIN');

function create_html(t, t0, key){

	if(!t0) {
		switch(t[0]){
		case '%':
			return '<var>' + t.slice(1) + '</var>';
		case 'â‡’':
			nesting += '<\/span>';
			return  'ï¼š<span class="block">';
		}
		var result = nesting + '<span lang="en">' + t.slice(1) + '<\/span>';
		nesting = '';
		return result;
	}

	switch(t0){
	case '`':
		return '<code>' + key + '</code>';
	case '`%':
		return '"<code class="label">' + key + '</code>"';
	case '`!': // IDL object model property
		return '<b class="coder">' + key.replace(/\-/g, ' ') + '</b>';
	case '`^': // literal å®šæ•°
		return '"<code class="literal">' + key + '</code>"';
	case '$!': // å„ç¨®ãƒªã‚½ãƒ¼ã‚¹
		return '<a href="https://encoding.spec.whatwg.org/' +
			key + '">' + key + '</a>';
	}

	var text = link_map[key] || key;
//	if(!text) return t;

	switch(t0){
	case '`$':
	case '$':
		t = '<a href="#' + key + '">' + text + '</a>';
		break;
//	case '%@':
	case '`@':
	case '@':
		t = '<dfn id="' + key + '">' + text + '</dfn>';
		break;
	default:
		return t;
	}

	switch(t0.charAt(0)){
	case '`':
		return '<code>' + t + '</code>';
	}
	return t;
}

}

</script>


<!--% ç½®æ›ãƒ‡ãƒ¼ã‚¿ -->

<script type="text/plain" id="words_table1">
BR:ï¼›<br>
FAIL:<i>failure</i>
TA:http://www.khronos.org/registry/typedarray/specs/latest/
Assert:<b>Assert</b>
</script>

<!--% ãƒªãƒ³ã‚¯ç½®æ›ãƒ‡ãƒ¼ã‚¿ -->
<script type="text/plain" id="_link_map">
byte:~byte
ascii-byte:ASCII ~byte
code-point:~cp
scalar-value:~scalarå€¤
string:æ–‡å­—åˆ—
ascii-code-point:ASCII ~cp
ascii-whitespace:ASCII ç©ºç™½é¡
ascii-digits:ASCII æ•°å­—
ascii-case-insensitive:ASCII æ–‡å­—å¤§å°ç„¡è¦–
ascii-lowercase:ASCII å°æ–‡å­—åŒ–
encoding:~encoding
name:åå‰
label:~label
decoder:~decoder
decode:~decode
utf-8-decode:UTF-8 ~decode
utf-8-decode-without-bom:BOM ã‚’å–æ‰±ã‚ãšã« UTF-8 ~decode
utf-8-decode-without-bom-or-fail:BOM ã‚‚å¤±æ•—ã‚‚å–æ‰±ã‚ãšã« UTF-8 ~decode
utf-8-encode:UTF-8 ~encode
encode:~encode
encoder:~encoder
handler:~handler
error-mode:~error~mode
error:~error
finished:å®Œé‚
continue:ç¶™ç¶š
end-of-stream:~EoS

concept-encoding-get:~encodingã‚’å–å¾—
get-an-output-encoding:å‡ºåŠ›~encodingã‚’å–å¾—
concept-token:~token
concept-stream:~stream
concept-stream-read:èª­å–ã£ãŸçµæœ
concept-stream-prepend:æŒ¿è¾¼ã‚€
concept-stream-push:æŠ¼è¾¼ã‚€
concept-encoding-run:èµ°ã‚‰ã™
concept-encoding-process:å‡¦ç†
concept-td-serialize:ç›´åˆ—åŒ–-
concept-te-serialize:ç›´åˆ—åŒ–-

index:ç´¢å¼•
index-code-point:ç´¢å¼•~cp
index-pointer:ç´¢å¼•~pointer
index-big5-pointer:ç´¢å¼• Big5 ~pointer
index-big5:ç´¢å¼• Big5
index-euc-kr:ç´¢å¼• EUC-KR
index-jis0208:ç´¢å¼• jis0208
index-jis0212:ç´¢å¼• jis0212
index-shift_jis-pointer:ç´¢å¼• Shift_JIS ~pointer
index-gb18030-ranges:ç´¢å¼• gb18030 ç¯„å›²é›†
index-gb18030-ranges-code-point:ç´¢å¼• gb18030 ç¯„å›²é›† ~cp
index-gb18030-ranges-pointer:ç´¢å¼• gb18030 ç¯„å›²é›†~pointer

index-gb18030:ç´¢å¼• gb18030

utf-8-code-point:UTF-8 ~cp
utf-8-bytes-seen:UTF-8 å‡ºç¾~byteæ•°
utf-8-bytes-needed:UTF-8 è¦~byteæ•°
utf-8-lower-boundary:UTF-8 ä¸‹é™
utf-8-upper-boundary:UTF-8 ä¸Šé™

single-byte-encoding:å˜byte~encoding
index-single-byte:å˜byteç´¢å¼•


	â—åå‰ï¼Š
utf-8:UTF-8
ibm866:IBM866
iso-8859-2:ISO-8859-2
iso-8859-3:ISO-8859-3
iso-8859-4:ISO-8859-4
iso-8859-5:ISO-8859-5
iso-8859-6:ISO-8859-6
iso-8859-7:ISO-8859-7
iso-8859-8:ISO-8859-8
iso-8859-8-i:ISO-8859-8-I
iso-8859-10:ISO-8859-10
iso-8859-13:ISO-8859-13
iso-8859-14:ISO-8859-14
iso-8859-15:ISO-8859-15
iso-8859-16:ISO-8859-16
koi8-r:KOI8-R
koi8-u:KOI8-U
macintosh:macintosh
windows-874:windows-874
windows-1250:windows-1250
windows-1251:windows-1251
windows-1252:windows-1252
windows-1253:windows-1253
windows-1254:windows-1254
windows-1255:windows-1255
windows-1256:windows-1256
windows-1257:windows-1257
windows-1258:windows-1258
x-mac-cyrillic:x-mac-cyrillic
gbk:GBK
gb18030:gb18030
big5:Big5
euc-jp:EUC-JP
iso-2022-jp:ISO-2022-JP
shift_jis:Shift_JIS
euc-kr:EUC-KR
replacement:~replacement
utf-16le:UTF-16LE
utf-16be:UTF-16BE
x-user-defined:x-user-defined


	â—

utf-8-decoder:UTF-8 ~decoder
utf-8-encoder:UTF-8 ~encoder
shared-utf-16-decoder:å…±ç”¨ UTF-16 ~decoder
replacement-decoder:~replacement~decoder
replacement-error-returned-flag:~replacementã«ã‚ˆã‚‹~errorã¯ã™ã§ã«è¿”ã—ãŸ~flag

single-byte-decoder:å˜byte~decoder
single-byte-encoder:å˜byte~encoder

gbk-flag:GBK ~flag

gb18030-first:gb1
gb18030-second:gb2
gb18030-third:gb3
gb18030-decoder:gb18030 ~decoder
gb18030-encoder:gb18030 ~encoder

big5-lead:Big5 ~lead
big5-decoder:Big5 ~decoder
big5-encoder:Big5 ~encoder

euc-jp-lead:EUC-JP ~lead
euc-jp-jis0212-flag:EUC-JP jis0212 ~flag
euc-jp-decoder:EUC-JP ~decoder
euc-jp-encoder:EUC-JP ~encoder

iso-2022-jp-decoder:ISO-2022-JP ~decoder
iso-2022-jp-encoder:ISO-2022-JP ~encoder

iso-2022-jp-decoder-state:ISO-2022-JP ~decoderçŠ¶æ…‹
iso-2022-jp-decoder-output-state:ISO-2022-JP ~decoderå‡ºåŠ›~çŠ¶æ…‹
iso-2022-jp-lead:ISO-2022-JP ~lead
iso-2022-jp-output-flag:ISO-2022-JP å‡ºåŠ›~flag

iso-2022-jp-decoder-ascii:<i>ASCII</i>
iso-2022-jp-decoder-roman:<i>Roman</i>
iso-2022-jp-decoder-katakana:<i>Katakana</i>
iso-2022-jp-decoder-lead-byte:<i>~lead~byte</i>
iso-2022-jp-decoder-trail-byte:<i>~trail~byte</i>
iso-2022-jp-decoder-escape-start:<i>~escapeé–‹å§‹</i>
iso-2022-jp-decoder-escape:<i>~escape</i>

iso-2022-jp-encoder-state:ISO-2022-JP ~encoderçŠ¶æ…‹
iso-2022-jp-encoder-ascii:<i>ASCII</i>
iso-2022-jp-encoder-roman:<i>Roman</i>
iso-2022-jp-encoder-jis0208:<i>jis0208</i>

shift_jis-lead:Shift_JIS ~lead
shift_jis-decoder:Shift_JIS ~decoder
shift_jis-encoder:Shift_JIS ~encoder

euc-kr-lead:EUC-KR ~lead
euc-kr-decoder:EUC-KR ~decoder
euc-kr-encoder:EUC-KR ~encoder

utf-16-lead-byte:UTF-16 ~lead~byte
utf-16-lead-surrogate:UTF-16 ~lead~surrogate
utf-16-decoder:UTF-16 ~decoder
utf-16le-decoder:UTF-16LE ~decoder
utf-16be-decoder:UTF-16BE ~decoder
utf-16be-decoder-flag:UTF-16BE ~decoder~flag

x-user-defined-decoder:x-user-defined ~decoder
x-user-defined-encoder:x-user-defined ~encoder

convert-a-code-unit-to-bytes:~byteåˆ—ã«å¤‰æ›

textdecoderoptions:TextDecoderOptions
textdecodeoptions:TextDecodeOptions
textdecoder:TextDecoder
textencodeoptions:TextEncodeOptions
textencoder:TextEncoder

dom-textdecoder:TextDecoder
dom-textdecoder-encoding:encoding
dom-textdecoder-fatal:fatal
dom-textdecoder-ignorebom:ignoreBOM

dom-textdecoder-decode:decode
dom-textencoder:TextEncoder
dom-textencoder-encoding:encoding
dom-textencoder-encode:encode

</script>

<!-- ï¼Šå»ƒ
	shared-utf-16-encoder:å…±ç”¨ UTF-16 ~encoder
	replacement-encoder:~replacement~encoder
	utf-16-encoder:UTF-16 ~encoder
	utf-16le-encoder:UTF-16LE ~encoder
	utf-16be-encoder:UTF-16BE ~encoder
	utf-16be-encoder-flag:UTF-16BE ~encoder~flag

-->

<!--% èªå½™ç½®æ›ãƒ‡ãƒ¼ã‚¿ 
è‹±æ•°_, ã¾ãŸã¯æ¼¢å­—ã®ã¿
-->
<script type="text/plain" id="words_table">

	â—ä»•æ§˜
algo:algorithm::ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
æ‰‹ç¶šã:steps:~
æ®µ:step:~
UA:user agent:UA::ãƒ¦ãƒ¼ã‚¶ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
åˆ©ç”¨è€…:user:~
åˆ©ç”¨-:use:~
åˆ©ç”¨:use:~
åˆ©ç”¨ä¸­ã®:in use ã®:~
æŠ€è¡“çš„ã«ã¯:technical ã«ã¯:å½¢ã®ä¸Šã§ã¯
æ³¢åŠ-:influence:~
æ„å›³çš„:intentional:~
æ„å›³-:intend:~
æ’ä»–çš„:exclusive:~
æ—¢å­˜ã®:existing:~
ä½œè€…:author:~
æ­´å²çš„:historical:~
è¦ç¯„çš„:normative:~
	è¦ç¯„çš„ã§ãªã„:non-normative:~
	å‚è€ƒ:non-normative
çµ±ä¸€çš„:universal:~
é©åˆ‡:appropriate:~
æä¾›-:provide:~
æä¾›0-:offer:æä¾›
åæŸ:converge:~
ç›¸äº’é‹ç”¨å¯èƒ½:interoperable:~
äº’æ›æ€§:compatibility:~
äº’æ›:compatible:~
ç†ç”±:reason:~
ç©¶æ˜:investigation:~
æœ«ç«¯åˆ©ç”¨è€…:end user:~
ç‰¹è‰²æ©Ÿèƒ½:feature:~
å¯èƒ½åŒ–-:enable:~
ä¸èƒ½åŒ–-:disable:~
èª²é¡Œ:issue:~
å ±å‘Š:report:~
å•é¡Œ:problem:~
é•æ³•:illegal:~
è§£é‡ˆ:interpretation:~
éäº’æ›:incompatible:~
æœªçŸ¥ã®:unknown:~
æ˜ç¤ºçš„:explicit:~
è‡ªæ˜:trivial:~
åˆ¶å¾¡:control:~
æ‹˜æŸ:constraints:~
æ‹˜æŸ-:constrain:~
å˜ç´”:simple:~
åˆ¶ç´„çš„:restrictive:~
å¥¨åŠ±:encourage:~
	ä¿ƒã™
æ‹¡æ•£-:spread:~
ç¶²ç¾…çš„:exhaustive:~
é€¸è„±-:deviate:~
åˆ¤åˆ¥-:distinguish:~
é–‹ç™ºè€…:developer:~
å…±é€šã®:common:~
åŸºç›¤:infrastructure:~
ç¾©å‹™ä»˜ã‘ã‚‰:mandate ã•:~
è¦ä»¶:requirements:~
è¦æ±‚-:require:~
æœ‰æ„:significant:~
å–çµ„ã‚€:address ã™ã‚‹:å–ã‚Šçµ„ã‚€
æ¦‚ã—ã¦:typical ã«ã¯:~
ä¿å®ˆçš„:conservative:~
åˆæ³•:legitimate:~
ç§»è¡Œ-:move:~
é‡è¦:important:~
ç‰¹åˆ¥ãª:special:~
å®Œå…¨ã•:completeness:~
ä»•çµ„ã¿:mechanism:~
äº‹ä¾‹:case:~
é©åˆæ€§:conformance:~
é©åˆæ€§ã®:conformance:~
å‡¦ç†èƒ½:performance:~
åˆ¶é™-:limit:~
åˆ¶é™:limitations:~
å„ç¨®ç”¨èª:terminology:~
åƒã:work ã™ã‚‹:~
æ„å‘³è«–:semantics:~
æ—§æ¥ã®:legacy:~
æ¨™æº–:standard:~
æ‹¡å¼µ-:extend:~
æ‹¡å¼µ:extension:~
æ—¢å®š:default:~
fallback:::ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
ç„¡é–¢ä¿‚:irrelevant:é–¢ä¿‚ãªã„
ä»•æ§˜:spec:~
å®Ÿè£…-:implement:~
å®Ÿè£…:implementation:~
å®šç¾©-:define:~
å®šç¾©:definition:~
æœªå®šç¾©:undefined:~
çœç•¥å¯:optional:~
æ–‡è„ˆ:context:~
browser:::ãƒ–ãƒ©ã‚¦ã‚¶
proprietary:::ãƒ—ãƒ­ãƒ—ãƒ©ã‚¤ã‚¨ã‚¿ãƒª
platform:::ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 
ãƒªãƒãƒ¼ã‚¹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢:reverse engineer:~
security:::ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
åŠ¹ç‡çš„:efficient:~
æœ€é©åŒ–-:optimize:~
ä¾å­˜-:depend:~
å…¬é–‹-:expose:~
å…±ç”¨:shared::~
å…±æœ‰-:share:~
æµå¸ƒ-:deploy:~
é…å‚™æ¸ˆã¿ã®:deployed:~
è¨±å¯-:permit:~
é™¤å¤–-:exclude:~
é™¤å¤–:exclusion:~
ç”Ÿç”£å´:producer:ç”Ÿç”£å´
ç”Ÿç”£-:produce:ç”Ÿç”£
æ¶ˆè²»å´:consumer:~
æ¶ˆè²»è€…:consumer:~
èƒŒæ™¯:background:~
èª˜ç™º-:trigger:~
é•å:violation:~
æœ‰ç”¨:useful:~
å–æ‰±ã„:handling:å–ã‚Šæ‰±ã„
å–æ‰±ã‚ãš:handle ã›ãš:å–ã‚Šæ‰±ã‚ãš
å–æ‰±ã†:handle ã™ã‚‹:å–ã‚Šæ‰±ã†
å¼·ã:strong ã«:~
ä»•æ–¹:way:~
ç‰¹å®šã®:specific:~
ç‰¹æœ‰ã®:-specific:~
ç°¡æ˜:clear:~
è¦æ—¨ã—ãŸ:outline ã—ãŸ:è¦æ—¨ã‚’è¿°ã¹ãŸ
éš”ãŸã‚Š:gap:~
è©³ç´°:details:~
é€²è¡Œä¸­:ongoing:~
éœ§æ¶ˆ-:go away:~
è‡ªå‰ã®:own:~
éå»:past:~

	â—networkï¼ä¿å®‰
protocol:::ãƒ—ãƒ­ãƒˆã‚³ãƒ«
server:::ã‚µãƒ¼ãƒ
client:::ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
è³‡æº:resource::ãƒªã‚½ãƒ¼ã‚¹
form:::ãƒ•ã‚©ãƒ¼ãƒ 
submission:::é€ä¿¡
æ‰‹å…¥åŠ›:enter:~
æ”»æ’ƒ:attack:~
æ”»æ’ƒè€…:attacker:~
é˜²æ­¢-:prevent:~
é˜²ã:prevent ã™ã‚‹:~
æ³¨å…¥-:inject:~
æ³¨æ„æ·±ã:careful ã«:~
ç´°å·¥:craft:~
æƒ…å ±å–ªå¤±:information loss:~
å®‰å…¨:safe:~
ä¸Šæ›¸ã:override:~
åˆæ„:agree:~
ä¸ä¸€è‡´:mismatch:~
äº¤æ›:interchange:~
éš ã™:mask ã™ã‚‹:~
éš ã›ãª:mask ã§ããª:~

	â—
obj:object::ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
method::ãƒ¡ã‚½ãƒƒãƒ‰
interface::ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹
æ§‹ç¯‰å­:constructor::~:ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
å±æ€§:attribute:~
å–å¾—å­:getter:~
å–å¾—:get:~
è¨­å®šå­:setter:~
è¢«å‘¼å‡ºæ™‚:è¢« invoke æ™‚:~
æŠ•å‡º:throw:~
member:::ãƒ¡ãƒ³ãƒ

çµæœ:result:~

å‘¼å‡ºã—ã¦:invoke ã—ã¦:å‘¼ã³å‡ºã—ã¦
å‘¼å‡ºã™:invoke ã™ã‚‹:å‘¼ã³å‡ºã™
å‘¼å‡ºæ™‚:invoke æ™‚:å‘¼ã³å‡ºã—æ™‚
	invocation
list:::ãƒªã‚¹ãƒˆ
support:::ã‚µãƒãƒ¼ãƒˆ
table:::ãƒ†ãƒ¼ãƒ–ãƒ«
entry:::ã‚¨ãƒ³ãƒˆãƒª

byte:::ãƒã‚¤ãƒˆ
å˜byte:single-byte::å˜ãƒã‚¤ãƒˆ:ã‚·ãƒ³ã‚°ãƒ«ãƒã‚¤ãƒˆ
è¤‡byte:multi-byte::è¤‡ãƒã‚¤ãƒˆ:ãƒãƒ«ãƒãƒã‚¤ãƒˆ
surrogate:::ã‚µãƒ­ã‚²ãƒ¼ãƒˆ
scalar:::ã‚¹ã‚«ãƒ©ãƒ¼
flag:::ãƒ•ãƒ©ã‚°
cp:code point::ç¬¦å·ä½ç½®:ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
cu:code unit::ç¬¦å·å˜ä½:ã‚³ãƒ¼ãƒ‰ãƒ¦ãƒ‹ãƒƒãƒˆ
encode:::ç¬¦å·åŒ–:ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
encoding:::ç¬¦å·åŒ–æ–¹å¼:ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
encoder:encoder::ç¬¦å·åŒ–å™¨:ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€
decode:::å¾©å·:ãƒ‡ã‚³ãƒ¼ãƒ‰
decoder:::å¾©å·å™¨:ãƒ‡ã‚³ãƒ¼ãƒ€
label:::ãƒ©ãƒ™ãƒ«
ç´¢å¼•:index::~:ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
index:::ç´¢å¼•:ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
pointer:::ãƒã‚¤ãƒ³ã‚¿
error:::ã‚¨ãƒ©ãƒ¼
æ­£æº–çš„:canonical::~
åå‰:name::~
ä¸‹é™:lower boundary::~
ä¸Šé™:upper boundary::~
offset:
token:::ãƒˆãƒ¼ã‚¯ãƒ³
stream:::ã‚¹ãƒˆãƒªãƒ¼ãƒ 
streaming:::ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†
no_flush:do not flush:çŠ¶æ…‹ç¶­æŒ
EoS:end-of-stream::ã‚¹ãƒˆãƒªãƒ¼ãƒ çµ‚ç«¯
utf-16be:

çŠ¶æ…‹:state::~:ã‚¹ãƒ†ãƒ¼ãƒˆ
escape:escape 
lead:::é ­éƒ¨
trail:::å°¾éƒ¨
	é ­éƒ¨ã¨å°¾éƒ¨:leading and trailing
handler:::ãƒãƒ³ãƒ‰ãƒ©
instance:::ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
mode:::ãƒ¢ãƒ¼ãƒ‰
ç¶™ç¶š:continue::~
å®Œé‚:finished::~
å®Ÿè¡Œ:execution:~
èµ°ã‚‰ã™:run ã™ã‚‹:èµ°ã‚‰ã›ã‚‹
èµ°ã‚‰ã›:run ã—:~
æ‰€ä¸ã®:given:ä¸ãˆã‚‰ã‚ŒãŸ
è¿”ã™:return ã™ã‚‹:~
è¿”ã•:return ã—:~
è¿”ã•ã‚Œ:return ã•ã‚Œ:~
è¿”ã—ãŸ:return ã—ãŸ:~
ç¹°è¿”:ç¹°ã‚Šè¿”
èª­å–ã‚Œã‚‹:read ã§ãã‚‹:èª­ã¿å–ã‚Œã‚‹
èª­å–ã‚‹:read ã™ã‚‹:èª­ã¿å–ã‚‹
èª­å–ã‚‰ã‚Œ:read ã•ã‚Œ:èª­ã¿å–ã‚‰ã‚Œ
èª­å–ã£ãŸ:read ã—ãŸ:èª­ã¿å–ã£ãŸ
	èª­å–çµæœ:èª­ã¿å–ã£ãŸçµæœ
æŠ¼è¾¼ã‚€:ã« push ã™ã‚‹::ã®æœ«å°¾ã«ä»˜åŠ ã™ã‚‹:ã«ãƒ—ãƒƒã‚·ãƒ¥ã™ã‚‹
æŒ¿è¾¼ã‚€:ã« prepend ã™ã‚‹::ã®å…ˆé ­ã«æŒ¿å…¥ã™ã‚‹:ã«ãƒ—ãƒªãƒšãƒ³ãƒ‰ã™ã‚‹
ä»˜åŠ -:append:~
æŒ¿å…¥-:insert:~

æ§‹æ–‡è§£æ:parsing::~:ãƒ‘ãƒ¼ã‚¹å‡¦ç†
ç›´åˆ—åŒ–-:serialize::~:ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
å‡¦ç†:process::~
å‡¦ç†å™¨:processor::~:ãƒ—ãƒ­ã‚»ãƒƒã‚µ
coder:
å…¥åŠ›:input:~
å‡ºåŠ›:output:~
output:::å‡ºåŠ›
	~~å‡ºåŠ›:emit
	~output
	%input
	%å…¥åŠ›
BOMseen:BOM seen:BOM ç¢ºèªæ¸ˆã¿
BOMignore:ignore BOM:BOM ç„¡è¦–
replacement:
	fatal:
	å¤±æ•—ï¼Šfailï¼failure

BOM:byte order mark::ãƒã‚¤ãƒˆé †ãƒãƒ¼ã‚¯
åˆè‡´-:match:~

å½¢å¼:format::ãƒ‡ãƒ¼ã‚¿å½¢å¼:ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
ç°¡ä½“å­—:simplified:~
ç¹ä½“å­—:traditional:~
æ–‡å­—åˆ—:string:~
æ–‡å­—:character:~
å°æ–‡å­—åŒ–:lowercase åŒ–:~
å†…å®¹:content:~
ç¯„å›²é›†:ranges:~
ç©ºç™½é¡:whitespace:~
æ–‡å­—å¤§å°ç„¡è¦–:case-insensitive:~
æ•°å­—:digit:~
layout:::ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
literal:::ãƒªãƒ†ãƒ©ãƒ«
data:::ãƒ‡ãƒ¼ã‚¿
bit:::ãƒ“ãƒƒãƒˆ
shift:::ã‚·ãƒ•ãƒˆ
hook:::ãƒ•ãƒƒã‚¯
buffer:::ãƒãƒƒãƒ•ã‚¡
option:::ã‚ªãƒ—ã‚·ãƒ§ãƒ³
script:::ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
field:::ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰

è«–ç†:logical:~
æ–­ç‰‡åŒ–:fragment åŒ–:~
å¯¾å¿œé–¢ä¿‚:mapping:~
å¯¾å¿œä»˜ã‘ã‚‹:map ã™ã‚‹:~
å¯¾å¿œä»˜ã‘ã¦:map ã—ã¦:~
å¯¾å¿œä»˜ã‘ã‚‰:map ã•:~

ç¯„å›²:range:~
ç¯„å›²æ¤œæŸ»:limit check:~
å¤‰æ›:convert:~
åŒºç”»:area:~
è¤‡è£½:copy:~

è¡¨ç¾-:represent:~
è¡¨ç¾:representation:~
ä¸€æ„:unique:~
ä¸€è¦§:table:~
å€¤:value:~
	ã€œãŒè¿”ã™å€¤:ã€œã® return value
é…åˆ—:array:~
è­˜åˆ¥-:identify:~
é™¤å»-:remove:~
	ç®—è¡“å¼:equation:~
å‰ç½®-:prefix:~
é‡è¤‡-:duplicate:~
é †åº:order:~
æœ‰é †åº:ordered:~
åˆ†å‰²:split:~
è¨­å®š-:set:~
ç¬¦å·åŒ–æ–‡å­—é›†åˆ:coded character set:~
åŠ ç®—:addition:~
æ¸›ç®—:subtraction:~
ä¹—ç®—:multiplication:~
é™¤ç®—:division:~
å‰°ä½™:remainder:~
é–‹å§‹:start:~
åŒ…å«-:contain:~
ç”Ÿæˆ-:generate:~
åŒºåˆ‡å­:delimiter:~
çµä»˜ã‘ã‚‰:associate ã•:çµã³ä»˜ã‘ã‚‰
æ–°ãŸãª:new:~
è¦‹å‡ºã™:find ã™ã‚‹:~
è¦‹å‡ºã•ã‚Œ:find ã•ã‚Œ:~

æ•´æ•°:integer:~
åŸºæ•°:base:~
çµ‚äº†-:terminate:~
åˆæœŸ:initial:~
å˜ç‹¬ã®:single:~

ä¿å…¨-:preserve:~
å¾€æ¥-:roundtrip:~
header:::ãƒ˜ãƒƒãƒ€

æ­£ç¢º:exact:~
æ­£ç¢ºa:accurate:æ­£ç¢º
ç­‰ä¾¡:equivalent:~
ç²¾åº¦:precision:~
ç½®æ›-:replace:~
åŒ…è£…-:wrap:~
å¼•æ•°:argument:~
æ–¹å‘:direction:~
æœ€åˆã®:first:~
æœ€å¾Œã®:last:~
å…¨ä½“çš„ãª:overall:~
å‚ç…§-:reference:~
å­˜åœ¨-:exist:~
åœ¨ã™ã‚‹:present ã™ã‚‹:åœ¨ã‚‹
	ä¼´ã‚ã‚Œãªã„ no ã€œ present

</script>

<!--%ä»–ã®èª

å…¨ãã®:fully
åˆ¥å:alias:~
~~æ¤œçŸ¥ã•ã‚Œã‚‹ã“ã¨ãªã:silent
~~æ¨™æº–ã®:The
~~è€ƒæ…®
ã‚ã‚‹ç¨‹åº¦:some extent
ã‚ˆã‚Šå°ã•ã„:less than
ä¸€ã¤
ä¸€
ä¸€å¼ã§:in combination with
ä¸€æ–°-:set anew:~
ä¸€æ–¹
ä¸€è‡´-
ã‚ˆã‚Š~~ä¸€èˆ¬çš„ã«ã¯:larger
ä¸€é€£ã®
ä¸€éƒ¨
ä¸‡
ä¸Š
ä¸‹
ä¸‹ä½:least significant
ä¸‹è¨˜
ä¸è¦
ä¸ãˆ
ä¸¦ã³
ä¸­
ä¸»ã«
ä»Šã‚„
ä»–
ä»–ã®
ãã®ä»–ã®:miscellaneous
ä»¥ä¸Š
ä»¥ä¸‹
ä»¥å¤–
ä»»æ„é¸æŠ
ä¼´-
ä½•ã‹
ä½•ã‚‚
ä½•ã‚‰ã‹
ä½¿ã„åˆ‡ã‚Š
ä¾‹
ä¾‹ãˆã°
ä¾›-
ä¿ƒã™
ä¿è­·
å€‹
å€‹æ•°
å‚™ãˆã‚‹
å‚™è€ƒ
å„ªå…ˆã•ã‚Œã‚‹:has priority overï¼more authoritative
å…ƒã®
å…ˆã®
å…ˆé ­
å…¥ã‚‰ãªã„
å…¥ã‚‹
å…¥æ‰‹ã§ãã‚‹:available
å†…
å†’é ­
å‡ºç¾~byteæ•°:byte seen
åˆ—:sequence
åˆ—ç›®
åˆ¥
å‰‡ã£ã¦
å‰
å‰ã®
å‰è¿°ã®:aforementioned
åŠ ãˆ
åŒ–
åŒ–-
~~ååˆ†:fine
å–ã‚Š
å¯èª­æ€§:readability:~
å³ï¼å·¦ã‚·ãƒ•ãƒˆ
å³è¾º
å·¦è¾º
å„
å„ç¨®
å„è¡Œã‚’
åˆè‡´-
åŒã˜
å«ã¾ã‚Œ
å«ã‚ã‚‰ã‚Œ
å«ã‚“ã§
å‘¨çŸ¥ã®:known:
å‘¼ã³
å‘¼ã¶
å›
å›é¿
å›³å¼
åŸ‹ã‚ã‚‹
å ´åˆ
å ´æ‰€
å£Šã™
å¤‰ã‚ã£ã¦
å¤‰åŒ–:changes
å¤‰æ›´:change
å¤‰æ›-
å¤–å­—
å¤šãã®
å¤±ã‚ã›
å¯¾:combination
å¯¾ã—ï¼å¯¾ã™ã‚‹
å¯¾å‡¦-:deal with
å¯¾å¿œ-:corresponding
å¯¾è±¡
å°‘ãªãã¨ã‚‚:at least
å°¾éƒ¨ã®:trailing
å±ã™ã‚‹
å¸¸ã«
å¹´
åºƒã:widespread
åº:Preface
å¾Œã¯
å¾Œç¶šã®:subsequentï¼later
å¾Œè€…
å¾—ã‚‰ã‚Œ
å¾—ã‚‹
å¿…è¦:necessaryï¼needï¼
å¿œã˜ã¦
æ„å‘³
æ„å‘³-
æˆç«‹-
æˆ»ã™:back
æ‰±ã„:dealing with
æ‹¬å¼§å†…
æŒã¤
æŒ‡-
æŒ™ã’-
æ•°
æ•°å€¤:number
æ–¹
æ™‚
æœ€ã‚‚
æœ€åˆ
æœ€å¤§ã®
æœ€çŸ­:shortest
æœ€çµ‚çš„:the end
æœ‰-
æœ‰ç„¡
æœ«å°¾
æ¡:digit:~
æ§˜ã«
æ¬¡
æ¬¡ã®
æ¬¡å›
æ¯”è¼ƒcomparing
æ±ºã—ã¦
æ³•
æ³¨è¨˜
æ¸ˆã‚€
æº–ãšã‚‹
æ¼”ç®—
ç‚¹ã§
ç„¡ã„
ç„¡ã‘ã‚Œ
ç‰‡
ç‰¹ã«
	ç”¨ã„
ç•ªç›®
ç•°ãª
çš„
ç›¸äº’
çœç•¥-:without
çŸ¥ã‚‰ã‚Œ:knownï¼
ç¤ºã•ã‚Œ
ç§ç”¨é ˜åŸŸ
ç¨®ã®
ç©º
ç©ºã„ãŸ:newly-vacated
ç©ºè¡Œ:empty string 1
çªã:abuse
ç­‰
ç­‰ã€…ã¨ç¶šã:and so on
ç­‰ã—ã„
ç®—è¡“å¼:equations
ç¯€
çµ‚ãˆã‚‹
çµ„
çµ±åˆãƒãƒ³ã‚°ãƒ«ã‚³ãƒ¼ãƒ‰
ç·æ•°
è‡³ã‚‰ã›
è‹¥å¹²ã®:slight
è‹¥å¹²:slighty
è¡Œ:rowï¼line
è¡Œ-
è¡¨
è¡¨ã™
è¡¨è¨˜
è¡¨è¨˜è¦ç´„
è¢«
è¢«ã›ãŸ:Layering ã€œ  on top
è¤‡æ•°
è¦
è¦-
è¦‹ãˆãªã„
è¦‹ã‹ã‘ä¸Š:superficially
è¦‹ã‚ˆ
è¨˜ã•ã‚Œ
è¨˜ã™
è©²å½“-
èª
èª¬æ˜:Notes
è¶…ãˆ
	è¿½ã„æ˜“ã:easy to follow
è¿½åŠ 
é€†æ–¹å‘:vice versa
é€²æ•°
é€²~è¡¨è¨˜
éƒ¨åˆ†
é•·ã•:length:~
é–“
é–¢-
é™ã‚‰ãªã„
é™¤ã„ã¦ï¼é™¤ãï¼é™¤ã
éš›ã—
é
é¢
é …
é …ç›®æ•°
é ­éƒ¨ã®:leading
é¦™æ¸¯å¢—è£œå­—ç¬¦é›†
ãƒ¡ãƒ¢ãƒª:
ã«ã‚‚ã‹ã‹ã‚ã‚‰ãš~nonetheless
ã‚ã„ã«ã:unfortunately
ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
ã‹ã¤ã¦ã®:former
æ¨å¥¨ã•ã‚Œ

	â—è¨³æ³¨
å‚ç…§
å‚ç…§å…ˆ
ä»£å…¥
ä»£ç”¨å¯¾
å«æ„-
å›ºæœ‰ã®
ä¿æŒ-
å†…éƒ¨çŠ¶æ…‹
å‡ºç¾-
åˆæœŸåŒ–
åˆ¶ç´„ã•ã‚Œã‚‹ã“ã¨ãŒ
åŒºç‚¹ç•ªå·
å‚è€ƒ
å¤§å°æ¯”è¼ƒ
å¤§æ–‡å­—:uppercase
å®Ÿè¡Œåˆ¶å¾¡
æ‰€å±
æ•°å€¤çš„
æ•°å­—åˆ—
æ—¥ä»˜
æ™‚ç³»åˆ—çš„
æœ‰åŠ¹
æ§‹é€ 
æ©Ÿèƒ½
æ­£è¦åŒ–ã•ã‚Œ
ç‰¹æœ‰
~~ç¬¦å·ä½ç½®
ç¬¦å·ç‚¹
ç¯„å›²
è¦‹ãªã›ã‚‹
è§’æ‹¬å¼§
è¨˜å·
è¨˜æ³•
è¨˜è¿°
è¨˜è¿°ã•ã‚Œ
è¨³
è¨³è€…
è¨³èª
è©¦ã™
èª²-:impose
è­˜åˆ¥å­
é›†åˆ
é™çš„
å¤‰æ•°

-->

<!--% style -->

<style>
#encoding-labels td + td {
	white-space: pre;
	white-space: pre-line;
}


.algo {
	color:#404;
	font-style: italic;
}

i {
	color: #808;
}
.coder {
	color: maroon;
	font-family: serif0, serif;
}

.label {
	color: #666;
}

code > dfn {
	color: inherit;
}

</style>

</head>

<body>

<!--%UI -->
<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">

<h1>Encoding Standard æ—¥æœ¬èªè¨³</h1>
<p>
<a id="_THIS_PAGE">ã“ã®ãƒšãƒ¼ã‚¸</a>
ã¯ã€
<a href="https://whatwg.org/" >WHATWG</a>
ã«ã‚ˆã‚‹ï¼Œå‰¯é¡Œã®æ—¥ä»˜ã®
<a href="https://encoding.spec.whatwg.org/" >Encoding Standard</a>
ã‚’æ—¥æœ¬èªã«ç¿»è¨³ã—ãŸã‚‚ã®ã§ã™ã€‚
<strong >ã“ã®ç¿»è¨³ã®æ­£ç¢ºæ€§ã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“ã€‚</strong>
ã“ã®ä»•æ§˜ã®å…¬å¼ãªæ–‡æ›¸ã¯è‹±èªç‰ˆã§ã‚ã‚Šã€ã“ã®æ—¥æœ¬èªè¨³ã¯å…¬å¼ã®ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã€ ã¨ ã€‘ã§å›²ã¾ã‚ŒãŸéƒ¨åˆ†ã¯<span class="trans-note">ã€è¨³è€…ã«ã‚ˆã‚‹æ³¨é‡ˆã€‘</span>ã§ã™ã€‚
ï¼ˆ<a href="index.html">ä»–ã®ã‚¦ã‚§ãƒ–é–¢é€£ä»•æ§˜ã®ä¸€è¦§ã¨å…±é€šæ©Ÿèƒ½ã®è©³ç´°</a>ï¼‰
</p>

<p>
æ›´æ–°ï¼š <time>2016-07-29</time>
ï¼ˆå…¬é–‹ï¼š <time>2012-10-22</time>ï¼‰
</p>

<p >
ã“ã®ãƒšãƒ¼ã‚¸ã®å¤§éƒ¨åˆ†ã¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ã‚ˆã‚Šç”Ÿæˆã•ã‚Œã¦ã„ã¾ã™ï¼ˆ
å¤ã„ãƒ–ãƒ©ã‚¦ã‚¶ãªã©ï¼Œä¸€éƒ¨ã®ãƒ–ãƒ©ã‚¦ã‚¶ã«ã¯å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ï¼š
<span id="_GENERATING"></span>ï¼‰ã€‚
</p>

<p>
æœ¬æ–‡ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§å½“è©²ç®‡æ‰€ã®åŸæ–‡ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ï¼ˆå·¦ä¸‹éš…ã«å„ç¨® è¡¨ç¤ºåˆ‡æ›¿ãƒœã‚¿ãƒ³ â€” CSS ã‚„ DOM ã®å¯¾å¿œãŒå¤ã„ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã€ä¸€éƒ¨æ©Ÿèƒ½ã—ãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ï¼‰ã€‚
</p>

<address id="_CONTACT">ã€€</address>

</aside>


<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxwYXRoIGQ9Im01MCwwbDUwLDUwLTUwLDUwLTUwLTUwIiBmaWxsPSIjM2M3OTBhIi8+DQo8cGF0aCBkPSJtMzgsNDBjMC0xMiwyNC0xNSwyMy0yYzAsOS0xNiwxMy0xNiwyM3Y3aDEwdi00YzAtOSwxNy0xMiwxNy0yN2MtMi0yMi00NS0yMi00NSwzem03LDMyaDEwdjEwaC0xMCIgZmlsbD0iI2ZmZiIvPg0KPC9zdmc+DQo="
></a>


<h1>Encoding â€” ç¬¦å·åŒ–æ–¹å¼</h1>
<h2>Living Standard â€” æœ€çµ‚æ›´æ–° 2016 å¹´ 7 æœˆ 29 æ—¥</h2>

<dl>
	<dt>Participate:</dt>
	<dd>
<a href="https://github.com/whatwg/encoding">GitHub whatwg/encoding</a>
(<a href="https://github.com/whatwg/encoding/issues/new">file an issue</a>,
<a href="https://github.com/whatwg/encoding/issues">open issues</a>)</dd>
	<dd><a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a></dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/encoding/commits">GitHub whatwg/encoding/commits</a></dd>
	<dd><a href="https://twitter.com/encodings">@encodings</a></dd>

	<dt>å„å›½èªç¿»è¨³ï¼ˆéè¦ç¯„çš„ï¼‰</dt>
	<dd>æ—¥æœ¬èªï¼ˆã“ã®ãƒšãƒ¼ã‚¸ï¼‰</dd>

</dl>


</header>


<nav class="toc" id="table-of-contents">
<h2 title="Table of Contents">ç›®æ¬¡</h2>
<ol id="_toc_list"></ol>

<ol><li><a href="#references">å‚ç…§æ–‡çŒ®</a></li><li
><a href="#acknowledgments">è¬è¾</a></li></ol>
</nav>


<main id="MAIN" style="display:none;">

	<section id="preface">

<h2 title="Preface">1. åº</h2>

<p>
UTF-8 ~encodingã¯ã€çµ±ä¸€çš„ãªç¬¦å·åŒ–æ–‡å­—é›†åˆã§ã‚ã‚‹ Unicode ã®äº¤æ›ã«æœ€ã‚‚é©åˆ‡ãª~encodingã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ï¼Œã“ã®ä»•æ§˜ã¯ã€æ–°ãŸãªï¼»
~protocolã¨å½¢å¼
ï¼½, ãŠã‚ˆã³ï¼»
æ–°ãŸãªæ–‡è„ˆ~ä¸‹ã§æµå¸ƒã•ã‚Œã‚‹æ—¢å­˜ã®å½¢å¼
ï¼½ã«å¯¾ã—ã€ UTF-8 ~encodingã‚’è¦æ±‚ã™ã‚‹ï¼ˆã¾ãŸï¼Œå®šç¾©ã™ã‚‹ï¼‰ã€‚
â—
The UTF-8 encoding is the most appropriate encoding for interchange of Unicode, the universal coded character set. Therefore for new protocols and formats, as well as existing formats deployed in new contexts, this specification requires (and defines) the UTF-8 encoding.
</p>

<p>
~encodingã«ã¯ï¼Œä»–ã®ã‚‚ã®ï¼ˆæ—§æ¥ã®~encodingï¼‰ã‚‚ã‚ã‚Šï¼Œéå»ã«ã‚ã‚‹ç¨‹åº¦ã¾ã§ã¯å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŒã€~UAé–“ã§å¸¸ã«åŒã˜ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã¨ã¯é™ã‚‰ãªã„ã€‚
ã¾ãŸã€å¸¸ã«åŒã˜~labelã‚’åˆ©ç”¨ã—ã¦ã‚‹ã‚ã‘ã§ã‚‚ãªãã€~encodingã®ä¸­ã®æœªå®šç¾©ã®åŒºç”», ã‚ã‚‹ã„ã¯ ã‹ã¤ã¦ã®~proprietaryãªåŒºç”»ã«ã¤ã„ã¦ã®æ‰±ã„ã‚‚ï¼Œã—ã°ã—ã°ç•°ãªã£ã¦ã„ã‚‹ã€‚
ã“ã®ä»•æ§˜ã¯ã€æ–°ãŸãªå®Ÿè£…ãŒ~encodingå®Ÿè£…ã‚’ãƒªãƒãƒ¼ã‚¹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã›ãšã«æ¸ˆã‚€ã‚ˆã†ã«ï¼Œã¾ãŸ, æ—¢å­˜ã®~UAãŒä¸€ã¤ã«åæŸã—å¾—ã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€ã“ã‚Œã‚‰ã®éš”ãŸã‚Šã‚’åŸ‹ã‚ã‚‹ã“ã¨ã«å–çµ„ã‚€ã€‚
â—
The other (legacy) encodings have been defined to some extent in the past. However, user agents have not always implemented them in the same way, have not always used the same labels, and often differ in dealing with undefined and former proprietary areas of encodings. This specification addresses those gaps so that new user agents do not have to reverse engineer encoding implementations and existing user agents can converge.
</p>

<p>
ç‰¹ã«ï¼Œã“ã®ä»•æ§˜ã¯ã€ãã‚Œã‚‰ã®~encodingã¨ï¼Œãã®ãã‚Œãã‚Œã«ãŠã‘ã‚‹ï¼»
~byteåˆ—ã¨$scalar-value åˆ—ã‚’ç›¸äº’ã«å¤‰æ›ã™ã‚‹~algo
ï¼½, ãŠã‚ˆã³ï¼»
ä¸€é€£ã®$labelã‚’è­˜åˆ¥ã™ã‚‹æ­£æº–çš„ãªåå‰
ï¼½ã‚’å®šç¾©ã™ã‚‹ã€‚
ã¾ãŸã€~encodingã®å„ç¨®~algoã®ã†ã¡ä¸€éƒ¨ã‚’ JavaScript ã«å…¬é–‹ã™ã‚‹ API ã‚‚å®šç¾©ã™ã‚‹ã€‚
â—
In particular, this specification defines all those encodings, their algorithms to go from bytes to scalar values and back, and their canonical names and identifying labels. This specification also defines an API to expose part of the encoding algorithms to JavaScript.
</p>

<p>
~UAã¯ï¼Œã™ã§ã«
<a href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">IANA Character Sets registry</a>
ã«æŒ™ã’ã‚‰ã‚Œã¦ã„ã‚‹~labelã‹ã‚‰ã‚‚ æœ‰æ„ã«é€¸è„±ã—ã¦ã„ã‚‹ã€‚
æ—§æ¥ã®~encodingã‚’ ã“ã‚Œä»¥ä¸Š~æ‹¡æ•£ã•ã›ãªã„ãŸã‚ã€ã“ã®ä»•æ§˜ã¯ï¼Œå‰è¿°ã®è©³ç´°ã«ã¤ã„ã¦ç¶²ç¾…çš„ã§ã‚ã‚Šï¼Œ registry ã¯ã‚‚ã†ä¸è¦ã§ã‚ã‚‹ã€‚
ç‰¹ã«ã€ã“ã®ä»•æ§˜ã¯ï¼Œ~encodingã‚’æ‹¡å¼µã™ã‚‹ãŸã‚ã®ä»•çµ„ã¿ã¯æä¾›ã—ãªã„ã€‚
â—
User agents have also significantly deviated from the labels listed in the IANA Character Sets registry. To stop spreading legacy encodings further, this specification is exhaustive about the aforementioned details and therefore has no need for the registry. In particular, this specification does not provide a mechanism for extending any aspect of encodings.
</p>

	</section>
	<section id="security-background">

<h2 title="Security background">2. ~securityã«é–¢ã™ã‚‹èƒŒæ™¯</h2>

<p>
~encodingã«ã¯ã€ã„ãã¤ã‹ã®~securityä¸Šã®èª²é¡ŒãŒã‚ã‚‹
â€” ç”Ÿç”£å´ã¨æ¶ˆè²»å´ã®é–“ã§ï¼Œï¼»
åˆ©ç”¨ä¸­ã®~encoding, ã‚ã‚‹ã„ã¯æ‰€ä¸ã®~encodingã®å®Ÿè£…-æ³•
ï¼½ã«ã¤ã„ã¦åˆæ„ã•ã‚Œã¦ãªã„ã¨ãã«ã€‚
ä¾‹ãˆã° 2011 å¹´ã«ã¯ã€æ¬¡ã®ã‚ˆã†ãªæ”»æ’ƒãŒå ±å‘Šã•ã‚Œã¦ã„ã‚‹ï¼š
ãã“ã§ã¯ã€ï¼»
æ”»æ’ƒè€…ãŒä½•ã‚‰ã‹ã®~fieldã‚’åˆ¶å¾¡ã—å¾—ã‚‹ã‚ˆã†ãªï¼Œ JSON è³‡æº
ï¼½å†…ã® 0x22 ~trail~byteã‚’ â€œéš ã™â€ ãŸã‚ã«ï¼Œ$shift_jis ã®~lead~byte 0x82 ãŒåˆ©ç”¨ã•ã‚ŒãŸã€‚
ç”Ÿç”£å´ã‹ã‚‰ã¯ï¼Œã“ã‚ŒãŒé•æ³•ãª~byteå¯¾ã§ã‚ã£ã¦ã‚‚å•é¡ŒãŒè¦‹ãˆãªã„ä¸€æ–¹ã§ã€æ¶ˆè²»å´ã§ã¯ï¼Œã“ã®~byteå¯¾ã‚’å˜ç‹¬ã® U+FFFD ã¨ã—ã¦~decodeã™ã‚‹~~çµæœã€å…¨ä½“çš„ãªè§£é‡ˆãŒå¤‰ã‚ã£ã¦ã—ã¾ã† â€” U+0022 ã¯é‡è¦ãªåŒºåˆ‡å­ãªã®ã§ã€‚
ï¼»
$scalar-valueã«å¯¾ã—è¤‡æ•°~byteã‚’åˆ©ç”¨ã™ã‚‹~encoding
ï¼½ã®~decoderã«ã¯ã€ä»Šã‚„ï¼Œé•æ³•ãª~byteå¯¾ã®äº‹ä¾‹ã§ã¯ï¼Œï¼»
ç¯„å›² U+0000 ã€œ U+007F ã«å…¥ã‚‹~scalarå€¤
ï¼½ã‚’ â€œéš ã›ãªã„â€ ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒè¦æ±‚ã•ã‚Œã‚‹
â€” å‰è¿°ã®~byteå¯¾ã«å¯¾ã—ã¦ã¯ã€å‡ºåŠ›ãŒï¼»
U+FFFD U+0022
ï¼½ã«ãªã‚‹ã‚ˆã†ã«ã€‚
â—
There is a set of encoding security issues when the producer and consumer do not agree on the encoding in use, or on the way a given encoding is to be implemented. For instance, an attack was reported in 2011 where a Shift_JIS lead byte 0x82 was used to â€œmaskâ€ a 0x22 trail byte in a JSON resource of which an attacker could control some field. The producer did not see the problem even though this is an illegal byte combination. The consumer decoded it as a single U+FFFD and therefore changed the overall interpretation as U+0022 is an important delimiter. Decoders of encodings that use multiple bytes for scalar values now require that in case of an illegal byte combination, a scalar value in the range U+0000 to U+007F, inclusive, cannot be â€œmaskedâ€. For the aforementioned sequence the output would be U+FFFD U+0022.
</p>

<p>
ã“ã‚Œã¯ã€ã‚ˆã‚Š~~ä¸€èˆ¬çš„ã«ã¯ï¼Œï¼»
~lead~byteãŒä¼´ã‚ã‚Œãªã„ã¨ãã«ï¼Œ$ascii-byteã‚’$ascii-code-pointã§ãªã„ä½•ã‹ã«å¯¾å¿œä»˜ã‘ã‚‹
ï¼½ã‚ˆã†ãª~encodingã«ãŠã‘ã‚‹èª²é¡Œã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚‰ã¯ï¼Œ â€œASCII éäº’æ›â€ ã®~encodingã§ã‚ã‚Šã€ã‚ã„ã«ãï¼Œã™ã§ã«æµå¸ƒã•ã‚ŒãŸå†…å®¹ã®ãŸã‚ã«è¦æ±‚ã•ã‚Œã‚‹ãŒã€ï¼»
$iso-2022-jp, $utf-16be, $utf-16le
ï¼½ä»¥å¤–ã®ã‚‚ã®ã¯ï¼Œ~supportã•ã‚Œãªã„ã€‚
ï¼ˆãã®ç¨®ã® ä»–ã®~encoding$labelã«ã¤ã„ã¦ã‚‚ã€æœªçŸ¥ã®~encodingã¸~fallbackã›ãšã«ï¼Œ$replacement ~encodingã«å¯¾å¿œä»˜ã‘ã¦ã‚ˆã„ã‹ã©ã†ã‹ã®ç©¶æ˜ãŒ
<a href="https://github.com/whatwg/encoding/issues/8" title="Add more labels to the replacement encoding">é€²è¡Œä¸­ã«ã‚ã‚‹</a>
ã€‚ï¼‰
æ”»æ’ƒã®ä¸€~ä¾‹ã¨ã—ã¦ã€æ³¨æ„æ·±ãç´°å·¥ã•ã‚ŒãŸå†…å®¹ã‚’è³‡æºã®ä¸­ã¸æ³¨å…¥ã—ã¦ï¼Œåˆ©ç”¨è€…ã«~encodingã‚’ä¸Šæ›¸ãã™ã‚‹ã‚ˆã†ä¿ƒã™~~çµæœã€ä¾‹ãˆã°~scriptã®å®Ÿè¡Œã«è‡³ã‚‰ã›ã‚‹ã‚‚ã®ãŒã‚ã‚‹ã€‚
â—
This is a larger issue for encodings that map anything that is an ASCII byte to something that is not an ASCII code point, when there is no lead byte present. These are â€œASCII-incompatibleâ€ encodings and other than ISO-2022-JP, UTF-16BE, and UTF-16LE, which are unfortunately required due to deployed content, they are not supported. (Investigation is ongoing whether more labels of other such encodings can be mapped to the replacement encoding, rather than the unknown encoding fallback.) An example attack is injecting carefully crafted content into a resource and then encouraging the user to override the encoding, resulting in e.g. script execution. 
</p>

<p>
HTML ã‚„ HTML ã®~formç‰¹è‰²æ©Ÿèƒ½ã«è¦‹å‡ºã•ã‚Œã‚‹ URL ã«åˆ©ç”¨ã•ã‚Œã‚‹~encoderã‚‚ã€ã™ã¹ã¦ã®~scalarå€¤ã‚’è¡¨ç¾ã§ããªã„~encodingãŒåˆ©ç”¨ã•ã‚Œã‚‹ã¨ãã«ï¼Œè‹¥å¹²ã®æƒ…å ±å–ªå¤±ã«ã¤ãªãŒã‚Šå¾—ã‚‹ã€‚
ä¾‹ãˆã°ï¼Œè³‡æºãŒ $windows-1252 ~encodingã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ã¨ãã€~serverã¯ï¼Œæœ«ç«¯åˆ©ç”¨è€…ãŒ~formã«æ‰‹å…¥åŠ›ã—ãŸ â€œ&#128169;â€ ã¨ â€œ&amp;#128169;â€ ã¨ã‚’åˆ¤åˆ¥ã§ããªããªã‚‹ã€‚
â—
Encoders used by URLs found in HTML and HTML's form feature can also result in slight information loss when an encoding is used that cannot represent all scalar values. E.g. when a resource uses the windows-1252 encoding a server will not be able to distinguish between an end user entering â€œ&#128169;â€ and â€œ&amp;#128169;â€ into a form.
</p>

<p>
ã“ã“ã«è¦æ—¨ã—ãŸå•é¡Œã¯ã€ UTF-8 ã‚’æ’ä»–çš„ã«åˆ©ç”¨ã—ã¦ã„ã‚‹ã¨ãã¯ï¼Œéœ§æ¶ˆã™ã‚‹ã€‚
ãã‚ŒãŒã€ä»Šã‚„ã™ã¹ã¦ã«å¯¾ã— UTF-8 ~encodingãŒç¾©å‹™ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ç†ç”±ã®ä¸€ã¤ã§ã‚ã‚‹ã€‚
â—
The problems outlined here go away when exclusively using UTF-8, which is one of the many reasons that is now the mandatory encoding for all things.
</p>

<p class="note">æ³¨è¨˜ï¼š
<a href="#browser-ui">~browser UI</a> ç¯€ã‚‚è¦‹ã‚ˆã€‚
â—
See also the Browser UI chapter.
</p>

	</section>
	<section id="conformance">

<h2 title="Conformance">3. é©åˆæ€§</h2>

<p>
æ˜ç¤ºçš„ã«å‚è€ƒï¼ˆè¦ç¯„çš„ã§ãªã„ï¼‰ã¨è¨˜ã•ã‚ŒãŸç¯€ã«åŠ ãˆï¼Œã“ã®ä»•æ§˜ã«ãŠã‘ã‚‹ã™ã¹ã¦ã®å›³å¼, ä¾‹, æ³¨è¨˜ã¯è¦ç¯„çš„ã§ã¯ãªã„ã€‚
ä»–ã®ã™ã¹ã¦ã¯è¦ç¯„çš„ã§ã‚ã‚‹ã€‚
â—
All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
</p>

<p>
ã“ã®ä»•æ§˜ã®è¦ç¯„çš„~éƒ¨åˆ†ã«ãŠã‘ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼š
ã€Œã€œã—ãªã‘ã‚Œã°ï¼ˆã€œã—ã¦ã¯ï¼‰<em class="rfc2119">ãªã‚‰ãªã„</em>ã€ = â€œMUST (NOT)â€,
ã€Œ<em class="rfc2119">è¦æ±‚ã•ã‚Œã‚‹</em>ã€= REQUIRED,
ã€Œã€œã™<em class="rfc2119">ã¹ã</em>ã§ã‚ã‚‹ï¼ˆã§ãªã„ï¼‰ã€ = â€œSHOULD (NOT)â€,
ã€Œ<em class="rfc2119" title="recommended">æ¨å¥¨ã•ã‚Œã‚‹</em>ã€ = â€œRECOMMENDEDâ€,
ã€Œã€œã—ã¦ã‚‚<em class="rfc2119">ã‚ˆã„</em>ã€ = â€œMAYâ€,
ã€Œ<em class="rfc2119" title="optional">ä»»æ„é¸æŠ</em> ã€ = â€œOPTIONALâ€,
ã¯ã€ RFC 2119 ã«å‰‡ã£ã¦è§£é‡ˆã•ã‚Œã‚‹ã‚‚ã®ã¨ã™ã‚‹ã€‚
å¯èª­æ€§ã®ãŸã‚ï¼Œã“ã®ä»•æ§˜ã§ã¯ã“ã‚Œã‚‰ã®èªãŒå¤§æ–‡å­—ã§å‡ºç¾ã™ã‚‹ã“ã¨ã¯ãªã„ã€‚
<a href="#refsRFC2119">[RFC2119]</a>
â—
The key words "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in RFC2119. For readability, these words do not appear in all uppercase letters in this specification. [RFC2119]
</p>

<p>
~algoã¾ãŸã¯ç‰¹å®šã®æ‰‹ç¶šãã¨ã—ã¦è¨˜ã•ã‚Œã‚‹é©åˆæ€§ã®è¦ä»¶ã¯ã€æœ€çµ‚çš„ãªçµæœãŒç­‰ä¾¡ã«ãªã‚‹ãªã‚‰ã°ï¼Œã©ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã‚‚ã‚ˆã„ã€‚
ï¼ˆç‰¹ã«ã€ã“ã®ä»•æ§˜ã§å®šç¾©ã•ã‚Œã‚‹~algoã¯è¿½ã„æ˜“ããªã‚‹ã‚ˆã†ã«è¨˜è¿°ã•ã‚Œã¦ãŠã‚Šï¼Œå‡¦ç†èƒ½ã¯~~è€ƒæ…®ã•ã‚Œã¦ã„ãªã„ã€‚ï¼‰
â—
Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow, and not intended to be performant.)
</p>
<p id="hardwareLimitations">
~UA ã¯æ‹˜æŸãŒèª²ã•ã‚Œã¦ã„ãªã„å…¥åŠ›ã«å®Ÿè£…~ç‰¹æœ‰ã®åˆ¶é™-ã‚’èª²ã—ã¦ã‚‚ã‚ˆã„ã€‚
ä¾‹ãˆã°ã€ DoS æ”»æ’ƒã®é˜²æ­¢-, ãƒ¡ãƒ¢ãƒªä½¿ã„åˆ‡ã‚Šã«æŠ—ã™ã‚‹~~ä¿è­·, ~platformç‰¹æœ‰ã®åˆ¶é™ã®å›é¿ãªã©ã€‚
â—
User agents may impose implementation-specific limits on otherwise unconstrained inputs, e.g. to prevent denial of service attacks, to guard against running out of memory, or to work around platform-specific limitations.
</p>

	</section>
	<section id="terminology">

<h2 title="Terminology">4. å„ç¨®ç”¨èª</h2>

<p>
16 é€²æ•°ã«ã¯ "0x" ãŒå‰ç½®ã•ã‚Œã‚‹ã€‚
â—
Hexadecimal numbers are prefixed with "0x".
</p>

<div class="p">
<p>
ç®—è¡“å¼ã®ä¸­ã®ã™ã¹ã¦ã®æ•°å€¤ã¯æ•´æ•°ã§ã‚ã‚Šã€å„ç¨®~æ¼”ç®—ã¯æ¬¡ã®è¨˜å·ã§è¡¨ç¾ã•ã‚Œã‚‹ï¼š
</p>

<!-- 
PLUS:
MINUS:
MUL:
DIV:
MOD:
-->

<table>
<thead><tr><th>è¨˜å·
</th><th>æ„å‘³
</th></tr></thead>

<tbody><tr><th>+
</th><td>åŠ ç®—

</td></tr><tr><th>âˆ’
</th><td>æ¸›ç®—

</td></tr><tr><th>~INCBY
</th><td>å·¦è¾º~å€¤ã«å¯¾ã™ã‚‹å³è¾º~å€¤ã«ã‚ˆã‚‹åŠ ç®—

</td></tr><tr><th>~DECBY
</th><td>å·¦è¾º~å€¤ã«å¯¾ã™ã‚‹å³è¾º~å€¤ã«ã‚ˆã‚‹æ¸›ç®—

</td></tr><tr><th>Ã—
</th><td>ä¹—ç®—

</td></tr><tr><th>Ã·
</th><td>é™¤ç®—

</td></tr><tr><th>%
</th><td>é™¤ç®—ã®å‰°ä½™ï¼ˆ modulo ï¼‰

</td></tr><tr><th>&lt;&lt;
</th><td>è«–ç†~å·¦~shift

</td></tr><tr><th>&gt;&gt;
</th><td>è«–ç†~å³~shift

</td></tr><tr><th>&amp;
</th><td>~bit AND

</td></tr><tr><th>|
</th><td>~bit OR

</td></tr><tr><th>floor( %x )
</th><td>%x ã‚’è¶…ãˆãªã„æœ€å¤§ã®æ•´æ•°

</td></tr></tbody></table>

<p class="trans-note">ã€
è¨˜å· ~INCBY, ~DECBY ã¯è¨³è€…ã«ã‚ˆã‚‹è¿½åŠ ã€‚
ã€‘</p>

â—
In equations, all numbers are integers, addition is represented by "+", subtraction by "âˆ’", multiplication by "Ã—", division by "/", calculating the remainder of a division (also known as modulo) by "%", logical left shifts by "&lt;&lt;", logical right shifts by "&gt;&gt;", bitwise AND by "&amp;", and bitwise OR by "|". floor(x) is the largest integer not greater than x.
</div>

<p>
è«–ç†~å³~shiftã®æ¼”ç®—~å¯¾è±¡ã®ç²¾åº¦ã¯ã€å°‘ãªãã¨ã‚‚ 21 ~bitä»¥ä¸Šã§~MUSTã€‚
â—
For logical right shifts operands must have at least twenty-one bits precision.
</p>

<p>
@byte
ã¯ 8 å€‹ã®~bitã®ä¸¦ã³ã§ã‚ã‚Šã€ 2 æ¡ã® 16 é€²æ•°ã§è¡¨ç¾ã•ã‚Œã‚‹ï¼Œç¯„å›² { 0x00 ã€œ 0xFF } ã«å…¥ã‚‹æ•°ã‚’ã¨ã‚‹ã€‚
â—
A byte is a sequence of eight bits, represented as a double-digit hexadecimal number in the range 0x00 to 0xFF, inclusive.
</p>

<p>
@ascii-byte
ã¯ã€ç¯„å›² { 0x00 ã€œ 0x7F } ã«å…¥ã‚‹$byteã§ã‚ã‚‹ã€‚
â—
An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive. 
</p>

<p>
@code-point
ã¯ Unicode ~cpã§ã‚ã‚Šï¼Œ 4 ã€œ 6 æ¡ã® 16 é€²æ•°ã§è¡¨ç¾ã•ã‚Œã‚‹ã€‚
æ¦‚ã—ã¦ "U+" ãŒå‰ç½®ã•ã‚Œã‚‹ãŒã€ç®—è¡“å¼ã‚„$indexã®ä¸­ã§ã¯ "0x" ãŒå‰ç½®ã•ã‚Œã‚‹ã€‚
<a href="#refsUNICODE">[UNICODE]</a>
â—
A code point is a Unicode code point and is represented as a four-to-six digit hexadecimal number, typically prefixed with "U+". In equations and indexes code points are prefixed with "0x". [UNICODE]
</p>

<p class="trans-note">ã€
ç¯„å›²ã¯ 0x0 ã€œ 0x10FFFF
ã€‘ã€
è¨³èªã® â€œ~~ç¬¦å·ä½ç½®ï¼ˆ code point ï¼‰â€ ã¯ Unicode ç‰¹æœ‰ã§ã‚ã‚Šï¼Œä»–ã®~encodingã® â€œç¬¦å·ç‚¹â€ ã«è©²å½“ã™ã‚‹ã€‚
ã€‘</p>

<p>
@scalar-value
ã¨ã¯ã€ç¯„å›²
{ U+D800 ã€œ U+DFFF }
ã«å…¥ã‚‰ãªã„
<span class="trans-note">ã€ã™ãªã‚ã¡ï¼Œä»£ç”¨å¯¾ï¼ˆ surrogate ï¼‰ã‚’é™¤ãã€‘</span>
$code-pointã§ã‚ã‚‹ã€‚
â—
A scalar value is a code point that is not in the range U+D800 to U+DFFF, inclusive.
</p>

<p>
@ascii-code-point
ã¨ã¯ã€ç¯„å›²
{ U+0000 ã€œ U+007F }
ã«å…¥ã‚‹~cpã§ã‚ã‚‹ã€‚
â—
An ASCII code point is a code point in the range U+0000 to U+007F, inclusive.
</p>

<p>
@ascii-whitespace
ã¨ã¯ã€ç¯„å›²
{ U+0009, U+000A, U+000C, +U+000D, U+0020 }
ã«å…¥ã‚‹~cpã§ã‚ã‚‹ã€‚
â—
The ASCII whitespace are code points U+0009, U+000A, U+000C, U+000D, and U+0020.
</p>

<p>
@ascii-digits
ã¨ã¯ã€ç¯„å›²
{ U+0030 ã€œ U+0039 }
ã«å…¥ã‚‹~cpã§ã‚ã‚‹ã€‚
â—
The ASCII digits are code points in the range U+0030 to U+0039, inclusive.
</p>

<p>
@string
ã¨ã¯ã€~cpã®ä¸¦ã³ã§ã‚ã‚‹ã€‚
â—
A string is a sequence of code points.
</p>

<p>
ï¼’ã¤ã®æ–‡å­—åˆ—ã®
@ascii-case-insensitive
ã«ã‚ˆã‚‹æ¯”è¼ƒã¨ã¯ã€
{ U+0041 ã€œ U+005A }
ï¼ˆã™ãªã‚ã¡ LATIN CAPITAL LETTER A ã€œ LATIN CAPITAL LETTER Z ï¼‰ã®ç¯„å›²ã®æ–‡å­—ã¨å¯¾å¿œã™ã‚‹
{ U+0061 ã€œ U+007A }
ï¼ˆã™ãªã‚ã¡ LATIN SMALL LETTER A ã€œ LATIN SMALL LETTER Z ï¼‰ã®ç¯„å›²ã®æ–‡å­—ã¯åˆè‡´ã•ã›ã‚‹ã“ã¨ã‚’é™¤ãã€ãã‚Œãã‚Œã®æ–‡å­—ã®~cpã”ã¨ã«æ­£ç¢ºã«æ¯”è¼ƒã™ã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
â—
Comparing two strings in an ASCII case-insensitive manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z), inclusive, and the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z), inclusive, are considered to also match.
</p>

<p>
æ–‡å­—åˆ—ã‚’
@ascii-lowercase
ã™ã‚‹ã¨ãã¯ã€ç¯„å›²
{ U+0041 ã€œ U+005A }
ã«å…¥ã‚‹ã™ã¹ã¦ã®~cpã®ãã‚Œãã‚Œã‚’ï¼Œå¯¾å¿œã™ã‚‹ç¯„å›²
{ U+0061 ã€œ U+007A }
ã«å…¥ã‚‹~cpã«ç½®æ›ã™ã‚‹ã€‚
â—
To ASCII lowercase a string, replace all code points in the range U+0041 to U+005A, inclusive, with the corresponding code points in the range U+0061 to U+007A, inclusive.
</p>

<hr>

<p>
@concept-token
ã¯ã€$byteã‚„$code-pointãªã©ã®ï¼Œ 1 å€‹ã®~dataç‰‡ã§ã‚ã‚‹ã€‚
â—
A token is a piece of data, such as a byte or code point.
</p>

<p>
@concept-stream
ã¯ã€æœ‰é †åº$concept-tokenåˆ—ã‚’è¡¨ç¾ã™ã‚‹ã€‚
@end-of-stream
ã¯ã€$concept-streamãŒç©ºã§ã‚ã‚‹ï¼ˆãã‚Œä»¥ä¸Š èª­å–ã‚Œã‚‹$concept-tokenãŒç„¡ã„ï¼‰ã“ã¨ã‚’æ„å‘³ã™ã‚‹ï¼Œç‰¹åˆ¥ãª$concept-tokenã§ã‚ã‚‹ã€‚
â—
A stream represents an ordered sequence of tokens. End-of-stream is a special token that signifies no more tokens are in the stream.
</p>

<p class="trans-note">ã€
~streamã¨~tokenåˆ—ã¯ï¼ˆ â€œé™çš„ãªâ€ ï¼‰~dataæ§‹é€ ã¨ã—ã¦ã¯åŒã˜ã§ã‚‚ï¼Œ
 â€œ~streamâ€ ã«ã¯ï¼Œãã®ã‚¢ã‚¯ã‚»ã‚¹ãŒ
å…ˆé ­ï¼ˆå…¥åŠ›ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸå ´åˆï¼‰ï¼æœ«å°¾ï¼ˆå‡ºåŠ›~å…ˆã®å ´åˆï¼‰
ã«ï¼ˆ â€œæ™‚ç³»åˆ—çš„ã«â€ ï¼‰åˆ¶ç´„ã•ã‚Œã‚‹ã“ã¨ãŒå«æ„ã•ã‚Œã‚‹ã€‚
ã€‘</p>

<div class="algo-head">
<p>
$concept-streamã‹ã‚‰$concept-tokenã‚’
<dfn id="concept-stream-read">èª­å–ã‚‹</dfn>
ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã›~MUSTï¼š
</p>
<ol>
	<li>
~IFï¼»
~streamã¯ç©ºã§ã‚ã‚‹
ï¼½
â‡’
~RET $end-of-stream
</li>
	<li>
~streamã®å…ˆé ­ã‹ã‚‰ 1 å€‹ã®~tokenã‚’é™¤å»ã™ã‚‹
</li>
	<li>
~RET å‰~æ®µã§é™¤å»ã—ãŸ~token
</li>
</ol>

<!-- this means read is blocking on e.g. networking activity;
     SimonSapin thinks this is fine, curse him if not -->
â—
When a token is read from a stream, the first token in the stream must be returned and subsequently removed, and end-of-stream must be returned otherwise.
</div>

<p>
1 å€‹~ä»¥ä¸Šã®$concept-tokenã‚’$concept-stream
@concept-stream-prepend
ã¨ãã¯ã€ãã‚Œã‚‰ã®~tokenã‚’ï¼Œ~streamã®å…ˆé ­ã«, æ‰€ä¸ã®é †åºã§æŒ¿å…¥ã—~MUSTã€‚
â—
When one or more tokens are prepended to a stream, those tokens must be inserted, in given order, before the first token in the stream.
</p>

<p class="example">
~tokenåˆ— "<code>&amp;#128169;</code>" ã‚’~stream "<code> hello world</code>" ã®å…ˆé ­ã«æŒ¿å…¥ã—ãŸçµæœã¯ï¼Œ~stream "<code>&amp;#128169; hello world</code>" ã«ãªã‚Šã€æ¬¡å›ã«èª­å–ã‚‰ã‚Œã‚‹~tokenã¯ <code>&amp;</code> ã«ãªã‚‹ã€‚
<!-- ğŸ’© --><!-- #x1F4A9 = 128169 decimal -->
â—
Inserting the sequence of tokens &amp;#128169; in a stream " hello world", results in a stream "&amp;#128169; hello world". The next token to be read would be &amp;.
</p>

<p>
1 å€‹~ä»¥ä¸Šã®$concept-tokenã‚’$concept-stream
@concept-stream-push
ã¨ãã¯ã€ãã‚Œã‚‰ã®~tokenã‚’ï¼Œ~streamã®æœ«å°¾ã«, æ‰€ä¸ã®é †åºã§ä»˜åŠ ã—~MUSTã€‚
â—
When one or more tokens are pushed to a stream, those tokens must be inserted, in given order, after the last token in the stream.
</p>



	</section>

	<section id="_conventions">
<h2 class="trans-note">ã€ã“ã®è¨³ã«å›ºæœ‰ã®è¡¨è¨˜è¦ç´„ã€‘</h2>

<p>
ã“ã®è¨³ã§ã¯ï¼Œã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®è¨˜è¿°ã«æ¬¡ã®è¨˜å·ã‚’ç”¨ã„ã‚‹ï¼š
</p>

<div style="margin-left:2em">
~LET ï¼ˆåˆæœŸåŒ–-ï¼‰, ~SET ï¼ˆä»£å…¥ï¼‰, ~ON, ~OFF ï¼ˆ~flagå€¤ï¼‰,<br />
~EQ, ~NEQ ï¼ˆæ¯”è¼ƒï¼‰, ~LT, ~GT, ~LTE, ~GTE ï¼ˆå¤§å°æ¯”è¼ƒï¼‰,<br />
ã€œ ï¼ˆ~~ç¯„å›²ï¼‰, { <var>â€¦</var> } ï¼ˆé›†åˆï¼‰, ~IN, ~NIN ï¼ˆé›†åˆã¸ã®æ‰€å±ï¼‰,<br />
~IF, ~ELSE, ~WHILE, ~RET, ~THROWï¼ˆå®Ÿè¡Œåˆ¶å¾¡ï¼‰
</div>

<p>
ã“ã‚Œã‚‰ã®æ„å‘³ã‚„å®šç¾©ã®è©³ç´°ã¯ï¼Œ~SYMBOL_DEF_REFã‚’å‚ç…§ã€‚
åŠ ãˆã¦ã€æ¬¡ã®è¨˜æ³•ã‚‚ç”¨ã„ã‚‰ã‚Œã‚‹ï¼š
</p>


<table><thead><tr><th style="min-width: 10em;">è¨˜æ³•
</th><th >æ„å‘³
</th></tr></thead>

<tbody>
<tr><th style="white-space:nowrap;">~byteåˆ— [ %value1, %value2, â€¦ ]
</th><td><p>
æ•°å€¤çš„ã« %value1, %value2 â€¦ ã¨åŒã˜å€¤ã‚’ã¨ã‚‹ä¸€é€£ã®$byteã‹ã‚‰ãªã‚‹, æ‰€ä¸ã®é †åºã«ã‚ˆã‚‹ï¼Œæ–°ãŸãª$concept-tokenåˆ—ã®~instanceã‚’æ„å‘³ã™ã‚‹ã€‚
è§’æ‹¬å¼§ã®ä¸­ãŒç©º
â€” â€œ~byteåˆ— [] â€ â€”
ã¨è¨˜ã•ã‚ŒãŸã¨ãã¯ï¼Œç©ºã®$concept-tokenåˆ—ã‚’æ„å‘³ã™ã‚‹ã€‚
</p></td></tr>

<tr><th style="white-space:nowrap;">~cp [ %value ]
</th><td><p>
æ•°å€¤çš„ã« %value ã¨åŒã˜å€¤ã‚’ã¨ã‚‹ 1 å€‹ã®$code-pointã‹ã‚‰ãªã‚‹ï¼Œæ–°ãŸãª$concept-tokenåˆ—ã®~instanceã‚’æ„å‘³ã™ã‚‹ã€‚
</p></td></tr>

</tbody></table>


	</section>
	<section id="encodings">

<h2 title="Encodings">5. ~encoding</h2>



<p>
@encoding
ã¯ã€$scalar-value åˆ—ã‹ã‚‰~byteåˆ—ã¸ã®å¯¾å¿œé–¢ä¿‚
<span class="trans-note">ã€~encodeã€‘</span>,
ãŠã‚ˆã³é€†æ–¹å‘ã¸ã®å¯¾å¿œé–¢ä¿‚
<span class="trans-note">ã€~decodeã€‘</span>
ã‚’å®šç¾©ã™ã‚‹ã€‚
ãã‚Œãã‚Œã®$encodingã«ã¯ã€
@name
ãŠã‚ˆã³ï¼Œ 1 å€‹~ä»¥ä¸Šã®
@label
ãŒ<a href="#encoding-labels">ã‚ã¦ãŒã‚ã‚Œã¦ã„ã‚‹</a>ã€‚
â—
An encoding defines a mapping from a scalar value sequence to a byte sequence (and vice versa). Each encoding has a name, and one or more labels.
</p>

		<section id="encoders-and-decoders">
<h3 title="Encoders and decoders">5.1. ~encoderã¨~decoder</h3>

<div class="p">
<p>
å„ç¨® $encodingã«ã¯ã€
@decoder
ã¨
@encoder
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
å„ $decoder ï¼ å„ $encoderã«ã¯ã€
@handler
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
$handlerã¯ã€
( $concept-stream, 1 å€‹ã®$concept-token )
ã‚’å…¥åŠ›ã«ã¨ã‚Šï¼Œæ¬¡ã®ã„ãšã‚Œã‹ã‚’è¿”ã™~algoã§ã‚ã‚‹ï¼š
</p>

<ul>
 <li>@finished</li>
 <li>
<p>
ç©ºã§ãªã„$concept-tokenåˆ—
</p>

<p class="trans-note">ã€
ã»ã¨ã‚“ã©ã®~decoderã®~handlerã¯ï¼Œ 1 å€‹ã®~cpã‹ã‚‰ãªã‚‹~tokenåˆ—ã‚’è¿”ã™ãŒã€
$big5-decoderã®~handlerã ã‘ï¼Œ 2 å€‹ã®~cpã‚’è¿”ã™å ´åˆãŒã‚ã‚‹ã€‚
ã€‘</p>
 </li>

 <li>
<p>
~optionã§$code-pointã‚‚ä¼´ã„å¾—ã‚‹ï¼Œ@error
</p>
<p class="trans-note">ã€
~encoderã®~handlerã®ã¿ãŒã€å¸¸ã«ï¼Œ~cpã‚‚ä¼´ã†~errorã‚’è¿”ã™ã€‚
ã€‘</p>
 </li>
 <li>@continue</li>
</ul>

â—
Each encoding has an associated decoder and most of them have an associated encoder. Each decoder and encoder have a handler algorithm. A handler algorithm takes an input stream and a token, and returns finished, one or more tokens, error optionally with a code point, or continue.
</div>


<p class="note">æ³¨è¨˜ï¼š
ï¼»
$replacement, $utf-16be, $utf-16le
ï¼½$encodingã«ã¯ã€$encoderã¯ãªã„ã€‚
â—
The replacement, UTF-16BE, and UTF-16LE encodings have no encoder.
</p>


<div class="p">

<p>
@error-mode
ã¯ã€ä»¥ä¸‹ã§ç”¨ã„ã‚‰ã‚Œã‚‹æ§˜ã«ï¼š
</p>

<ul>
 <li>
$decoderã«å¯¾ã—ã¦ã¯ï¼Œï¼»
`^replacementï¼ˆæ—¢å®šï¼‰,
`^fatal
ï¼½ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚‹ã€‚
</li>

 <li>
$encoderã«å¯¾ã—ã¦ã¯ï¼Œï¼»
`^fatalï¼ˆæ—¢å®šï¼‰ ,
`^html
ï¼½ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚‹ã€‚
</li>

</ul>

â—
An error mode as used below is "replacement" (default) or "fatal" for a decoder and "fatal" (default) or "html" for an encoder.
</div>

<p class="note">æ³¨è¨˜ï¼š
XML å‡¦ç†å™¨ã¯ã€ãã®$decoderã®$error-modeã‚’ `^fatal ã«è¨­å®šã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
<a href="#refsXML">[XML]</a>
â—
An XML processor would set error mode to "fatal". [XML]
</p>

<p class="note">æ³¨è¨˜ï¼š
$error-modeã« `^html ãŒå­˜åœ¨ã™ã‚‹ç†ç”±ã¯ã€
URL ã‚„ HTML form ã«ãŠã„ã¦ã¯ï¼Œ$errorã«éš›ã—æ—§æ¥ã®$encoderã‚’çµ‚äº†ã•ã›ãªã„ã‚ˆã†ã«ã™ã‚‹å–æ‰±ã„ã‚’è¦ã™ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
`^html $error-modeã¯ã€åˆæ³•ãªå…¥åŠ›ã¨åˆ¤åˆ¥ã§ããªã„åˆ—ã‚’~~å‡ºåŠ›ã•ã›ï¼Œ~~æ¤œçŸ¥ã•ã‚Œã‚‹ã“ã¨ãªã~dataã‚’å¤±ã‚ã›ã‚‹ã€‚
ã“ã‚Œã‚’é˜²ããŸã‚ã€é–‹ç™ºè€…ã«ã¯ $utf-8 $encodingã®åˆ©ç”¨ãŒå¼·ãå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
<a href="#refsURL">[URL]</a>
<a href="#refsHTML">[HTML]</a>
â—
"html" exists as error mode due to URLs and HTML forms requiring a non-terminating legacy encoder. The "html" error mode causes a sequence to be emitted that cannot be distinguished from legitimate input and can therefore lead to silent data loss. Developers are strongly encouraged to use the UTF-8 encoding to prevent this from happening. [URL] [HTML]
</p>

<div class="algo-head">
<p>
æ¬¡ãŒä¸ãˆã‚‰ã‚ŒãŸä¸‹ã§ï¼š
</p>

<ul ><li>å…¥åŠ›$concept-stream : %å…¥åŠ›
</li><li>å‡ºåŠ›$concept-stream : %å‡ºåŠ›
</li><li>$error-mode : %~mode ï¼ˆçœç•¥å¯ï¼‰
</li></ul>

<p>
$encodingã®ï¼»
$decoder ï¼ $encoder
ï¼½ %~coder ã‚’
@concept-encoding-run
ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
</p>
â—
To run an encoding's decoder or encoder encoderDecoder with input stream input, output stream output, and optional error mode mode, run these steps:
</div>

<ol>
 <li>
~IFï¼»
%~mode ã¯ä¸ãˆã‚‰ã‚Œã¦ã„ãªã„
ï¼½
â‡’
%~mode ~SET %~coder ã«å¿œã˜ã¦
â‡’
$decoderã§ã‚ã‚‹ãªã‚‰ã° `^replacement ~BR
$encoderã§ã‚ã‚‹ãªã‚‰ã° `^fatal
â—
If mode is not given, set it to "replacement", if encoderDecoder is a decoder, and "fatal" otherwise.
</li>

 <li>
%~coder~instance ~LET æ–°ãŸãª %~coder ã®~instance
â—
Let encoderDecoderInstance be a new encoderDecoder.
</li>

 <li>
<p>
~WHILE ( true )
â—
While true:
</p>

  <ol>
   <li>
%çµæœ ~LET
( %~coder~instance, %å…¥åŠ›, %å‡ºåŠ›, %~mode )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œï¼»
%å…¥åŠ› ã‹ã‚‰$concept-stream-read
ï¼½ã‚’$concept-encoding-processã—ãŸçµæœ
â—
Let result be the result of processing the result of reading from input for encoderDecoderInstance, input, output, and mode.
</li>

   <li>
~IFï¼»
%çµæœ ~NEQ $continue
ï¼½
â‡’
~RET %çµæœ
â—
If result is not continue, return result.
â—
Otherwise, do nothing. 
</li>
  </ol>
</ol>

<div class="algo-head">
<p>
æ¬¡ãŒä¸ãˆã‚‰ã‚ŒãŸä¸‹ã§ï¼š
</p>

<ul><li>$encodingã®ï¼»
$encoderï¼$decoder
ï¼½ã®~instance : %~coder~instance
</li><li>
å…¥åŠ›$concept-stream : %å…¥åŠ›
</li><li>
å‡ºåŠ›$concept-stream : %å‡ºåŠ›
</li><li>
$error-mode : %~modeï¼ˆçœç•¥å¯ï¼‰
</li></ul>

<p>
$concept-token %~token ã‚’
@concept-encoding-process
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
</p>
â—
To process a token token for an encoding's encoder or decoder instance encoderDecoderInstance, stream input, output stream output, and optional error mode mode, run these steps:
</div>

<ol>
 <li>
~IFï¼»
%~mode ã¯ä¸ãˆã‚‰ã‚Œã¦ã„ãªã„
ï¼½
â‡’
%~mode ~SET %~coder~instance ã«å¿œã˜ã¦
â‡’
$decoderã®~instanceã§ã‚ã‚‹ãªã‚‰ã° `^replacement ~BR
$encoderã®~instanceã§ã‚ã‚‹ãªã‚‰ã° `^fatal
â—
If mode is not given, set it to "replacement", if encoderDecoderInstance is a decoder instance, and "fatal" otherwise.
</li>

 <li>
%çµæœ ~LET
( %å…¥åŠ›, %~token )
ã«å¯¾ã—ï¼Œ %~coder~instance ã«ã‚ˆã‚‹$handlerã‚’èµ°ã‚‰ã›ãŸçµæœ
â—
Let result be the result of running encoderDecoderInstance's handler on input and token.
</li>

 <li>
~IFï¼»
%çµæœ ~IN { $continue, $finished }
ï¼½
â‡’
~RET %çµæœ
â—
If result is continue or finished, return result.
</li>

 <li>
~IFï¼»
%çµæœ ã« 1 å€‹~ä»¥ä¸Šã®$concept-tokenãŒã‚ã‚‹
ï¼½
â‡’
%çµæœ ã‚’ %å‡ºåŠ› $concept-stream-push
â—
Otherwise, if result is one or more tokens, push result to output.
</li>

 <li>
<p>
~ELIFï¼»
%çµæœ ~EQ $error
ï¼½
â‡’
%~mode ã«å¿œã˜ã¦ï¼š
â—
Otherwise, if result is error, switch on mode and run the associated steps:
</p>

  <dl class="switch">
   <dt>`^replacement</dt>
   <dd>
U+FFFD ã‚’ %å‡ºåŠ› $concept-stream-push
â—
Push U+FFFD to output.
</dd>

   <dt>`^html</dt>
   <dd>
~cpåˆ—ï¼»
U+0026, U+0023, ï¼»
%çµæœ ã®$code-pointã‚’åŸºæ•° 10 ã«ã‚ˆã‚Šæœ€çŸ­ã§è¡¨ç¾ã™ã‚‹$ascii-digitsåˆ—
ï¼½, U+003B
ï¼½
<span class="trans-note">ã€ "<code>&amp;#<var>æ•°å­—åˆ—</var>;</code>" ã€‘</span>
ã‚’
%å…¥åŠ› $concept-stream-prepend
â—
Prepend U+0026, U+0023, followed by the shortest sequence of ASCII digits representing result's code point in base ten, followed by U+003B to input.
</dd>

   <dt>`^fatal</dt>
   <dd>
~RET $error
â—
Return error.
</dd>
  </dl>
 </li>

 <li>
~RET $continue
â—
Return continue.
</li>

</ol>



		</section>
		<section id="names-and-labels">

<h3 title="Names and labels">5.2. åå‰ã¨~label</h3>

<p>
ä¸‹ã®ä¸€è¦§ã«ã€~UAãŒ~supportã—~MUSTï¼Œã™ã¹ã¦ã®$encodingã¨ãã‚Œã‚‰ã®$labelã‚’æŒ™ã’ã‚‹ã€‚
~UA ã¯ã€ä»–ã®$encodingã‚„$labelã‚’~supportã—ã¦ã¯~MUST_NOTã€‚
â—
The table below lists all encodings and their labels user agents must support. User agents must not support any other encodings or labels.
</p>

<p>
ä½œè€…ã¯ã€ $utf-8 $encodingã‚’åˆ©ç”¨ã—ãŸä¸Šã§ï¼Œãã®åˆ©ç”¨ãŒè­˜åˆ¥ã•ã‚Œã‚‹ã‚ˆã†ã«ï¼»
$ascii-case-insensitive ã§ `%utf-8 ã«~~åˆè‡´ã™ã‚‹$label
ï¼½ã‚’åˆ©ç”¨ã—~MUSTã€‚
â—
Authors must use the UTF-8 encoding and must use the ASCII case-insensitive "utf-8" label to identify it.
</p>

<p>
æ–°ãŸãªï¼»
~protocolã¨å½¢å¼
ï¼½, ã‚ã‚‹ã„ã¯ï¼»
æ–°ãŸãªæ–‡è„ˆ~ä¸‹ã§æµå¸ƒã•ã‚Œã‚‹æ—¢å­˜ã®å½¢å¼
ï¼½ã«ã¯ã€ $utf-8 $encodingãŒæ’ä»–çš„ã«åˆ©ç”¨ã•ã‚Œ~MUSTã€‚
ã“ã‚Œã‚‰ã®ï¼»
~protocolã‚„å½¢å¼
ï¼½ã®$encodingã®ï¼»
$nameã‚„$label
ï¼½ã¯ã€ `%utf-8 ã¨ã—ã¦å…¬é–‹ã•ã‚Œ~MUSTã€‚
â—
New protocols and formats, as well as existing formats deployed in new contexts, must use the UTF-8 encoding exclusively. If these protocols and formats need to expose the encoding's name or label, they must expose it as "utf-8".
</p>

<p class="algo-head">
æ–‡å­—åˆ— %~label ã‹ã‚‰
@concept-encoding-get
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To get an encoding from a string label, run these steps:
</p>

<ol>
 <li>
%~label ã‹ã‚‰é ­éƒ¨ã¨å°¾éƒ¨ã®$ascii-whitespaceã‚’é™¤å»ã™ã‚‹
â—
Remove any leading and trailing ASCII whitespace from label.
</li>

 <li>
~IFï¼»
%~label ãŒä¸‹ã®ä¸€è¦§ã®ã„ãšã‚Œã‹ã®$labelã«$ascii-case-insensitiveã§åˆè‡´ã™ã‚‹
ï¼½
â‡’
~RET åˆè‡´ã—ãŸ$labelã«å¯¾å¿œã™ã‚‹$encoding
â—
If label is an ASCII case-insensitive match for any of the labels listed in the table below, return the corresponding encoding, and failure otherwise.
</li>

 <li>
~RET ~FAIL
â—
â†‘</li>

</ol>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™æ¸ˆã¿ã®å†…å®¹ã¨äº’æ›ã«ã™ã‚‹å¿…è¦ã‹ã‚‰ã€ã“ã®ï¼»
$labelã‚’$encodingã«å¯¾å¿œä»˜ã‘ã‚‹~algo
ï¼½ã¯ï¼Œ
<a href="http://www.unicode.org/reports/tr22/tr22-7.html#Charset_Alias_Matching">Unicode Technical Standard #22, 1.4 ç¯€</a>
ã«ã‚ˆã‚‹ã‚‚ã®ã‚ˆã‚Šã‚‚ãšã£ã¨å˜ç´”ã‹ã¤åˆ¶ç´„çš„ãªã‚‚ã®ã§ã‚ã‚‹ã€‚
â—
This is a much simpler and more restrictive algorithm of mapping labels to encodings than section 1.4 of Unicode Technical Standard #22 prescribes, as that is found to be necessary to be compatible with deployed content.
</p>

<table id="encoding-labels">
 <thead>
  <tr><th>$nameâ—Name</th><th>$labelâ—Labels</th></tr>
 </thead>
 <tbody>

  <tr><th colspan="2"><a href="#the-encoding">~~æ¨™æº–ã®~encoding</a>â—The Encoding</th></tr>

  <tr><td>$utf-8</td><td
>`%unicode-1-1-utf-8
`%utf-8
`%utf8</td></tr>
 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-single-byte-encodings">æ—§æ¥ã®å˜byte~encoding</a>â—Legacy single-byte encodings</th></tr>

  <tr><td>$ibm866</td><td
>`%866
`%cp866
`%csibm866
`%ibm866</td></tr>

  <tr><td>$iso-8859-2</td><td
>`%csisolatin2
`%iso-8859-2
`%iso-ir-101
`%iso8859-2
`%iso88592
`%iso_8859-2
`%iso_8859-2:1987
`%l2
`%latin2</td></tr>

  <tr><td>$iso-8859-3</td><td
>`%csisolatin3
`%iso-8859-3
`%iso-ir-109
`%iso8859-3
`%iso88593
`%iso_8859-3
`%iso_8859-3:1988
`%l3
`%latin3</td></tr>

  <tr><td>$iso-8859-4</td><td
>`%csisolatin4
`%iso-8859-4
`%iso-ir-110
`%iso8859-4
`%iso88594
`%iso_8859-4
`%iso_8859-4:1988
`%l4
`%latin4</td></tr>

  <tr><td>$iso-8859-5</td><td
>`%csisolatincyrillic
`%cyrillic
`%iso-8859-5
`%iso-ir-144
`%iso8859-5
`%iso88595
`%iso_8859-5
`%iso_8859-5:1988</td></tr>

  <tr><td>$iso-8859-6</td><td
>`%arabic
`%asmo-708
`%csiso88596e
`%csiso88596i
`%csisolatinarabic
`%ecma-114
`%iso-8859-6
`%iso-8859-6-e
`%iso-8859-6-i
`%iso-ir-127
`%iso8859-6
`%iso88596
`%iso_8859-6
`%iso_8859-6:1987</td></tr>

  <tr><td>$iso-8859-7</td><td
>`%csisolatingreek
`%ecma-118
`%elot_928
`%greek
`%greek8
`%iso-8859-7
`%iso-ir-126
`%iso8859-7
`%iso88597
`%iso_8859-7
`%iso_8859-7:1987
`%sun_eu_greek</td></tr>

  <tr><td>$iso-8859-8</td><td
>`%csiso88598e
`%csisolatinhebrew
`%hebrew
`%iso-8859-8
`%iso-8859-8-e
`%iso-ir-138
`%iso8859-8
`%iso88598
`%iso_8859-8
`%iso_8859-8:1988
`%visual</td></tr>

  <tr><td>$iso-8859-8-i</td><td
>`%csiso88598i
`%iso-8859-8-i
`%logical</td></tr>

  <tr><td>$iso-8859-10</td><td
>`%csisolatin6
`%iso-8859-10
`%iso-ir-157
`%iso8859-10
`%iso885910
`%l6
`%latin6</td></tr>

  <tr><td>$iso-8859-13</td><td
>`%iso-8859-13
`%iso8859-13
`%iso885913</td></tr>

  <tr><td>$iso-8859-14</td><td
>`%iso-8859-14
`%iso8859-14
`%iso885914</td></tr>

  <tr><td>$iso-8859-15</td><td
>`%csisolatin9
`%iso-8859-15
`%iso8859-15
`%iso885915
`%iso_8859-15
`%l9</td></tr>

  <tr><td>$iso-8859-16</td><td
>`%iso-8859-16</td></tr>

  <tr><td>$koi8-r</td><td
>`%cskoi8r
`%koi
`%koi8
`%koi8-r
`%koi8_r</td></tr>

  <tr><td>$koi8-u</td><td
>`%koi8-ru
`%koi8-u</td></tr>

  <tr><td>$macintosh</td><td
>`%csmacintosh
`%mac
`%macintosh
`%x-mac-roman</td></tr>

  <tr><td>$windows-874</td><td
>`%dos-874
`%iso-8859-11
`%iso8859-11
`%iso885911
`%tis-620
`%windows-874</td></tr>

  <tr><td>$windows-1250</td><td
>`%cp1250
`%windows-1250
`%x-cp1250</td></tr>

  <tr><td>$windows-1251</td><td
>`%cp1251
`%windows-1251
`%x-cp1251</td></tr>

  <tr><td>$windows-1252</td><td
>`%ansi_x3.4-1968
`%ascii
`%cp1252
`%cp819
`%csisolatin1
`%ibm819
`%iso-8859-1
`%iso-ir-100
`%iso8859-1
`%iso88591
`%iso_8859-1
`%iso_8859-1:1987
`%l1
`%latin1
`%us-ascii
`%windows-1252
`%x-cp1252</td></tr>

  <tr><td>$windows-1253</td><td
>`%cp1253
`%windows-1253
`%x-cp1253</td></tr>

  <tr><td>$windows-1254</td><td
>`%cp1254
`%csisolatin5
`%iso-8859-9
`%iso-ir-148
`%iso8859-9
`%iso88599
`%iso_8859-9
`%iso_8859-9:1989
`%l5
`%latin5
`%windows-1254
`%x-cp1254</td></tr>

  <tr><td>$windows-1255</td><td
>`%cp1255
`%windows-1255
`%x-cp1255</td></tr>

  <tr><td>$windows-1256</td><td
>`%cp1256
`%windows-1256
`%x-cp1256</td></tr>

  <tr><td>$windows-1257</td><td
>`%cp1257
`%windows-1257
`%x-cp1257</td></tr>

  <tr><td>$windows-1258</td><td
>`%cp1258
`%windows-1258
`%x-cp1258</td></tr>

  <tr><td>$x-mac-cyrillic</td><td
>`%x-mac-cyrillic
`%x-mac-ukrainian</td></tr>
 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-multi-byte-chinese-(simplified)-encodings">æ—§æ¥ã®è¤‡byte Chinese ï¼ˆç°¡ä½“å­—ï¼‰ ~encoding</a>â—Legacy multi-byte Chinese (simplified) encodings</th></tr>

  <tr><td>$gbk</td><td
>`%chinese
`%csgb2312
`%csiso58gb231280
`%gb2312
`%gb_2312
`%gb_2312-80
`%gbk
`%iso-ir-58
`%x-gbk</td></tr>

  <tr><td>$gb18030</td><td
>`%gb18030
</td></tr>
 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-multi-byte-chinese-(traditional)-encodings">æ—§æ¥ã®è¤‡byte Chinese ï¼ˆç¹ä½“å­—ï¼‰~encoding</a>â—Legacy multi-byte Chinese (traditional) encodings</th></tr>

  <tr><td>$big5</td><td
>`%big5
`%big5-hkscs
`%cn-big5
`%csbig5
`%x-x-big5</td></tr>
 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-multi-byte-japanese-encodings">æ—§æ¥ã®è¤‡byte Japanese ~encoding</a>â—Legacy multi-byte Japanese encodings</th></tr>

  <tr><td>$euc-jp</td><td
>`%cseucpkdfmtjapanese
`%euc-jp
`%x-euc-jp</td></tr>

  <tr><td>$iso-2022-jp</td><td
>`%csiso2022jp
`%iso-2022-jp</td></tr>

  <tr><td>$shift_jis</td><td
>`%csshiftjis
`%ms932
`%ms_kanji
`%shift-jis
`%shift_jis
`%sjis
`%windows-31j
`%x-sjis</td></tr>
 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-multi-byte-korean-encodings">æ—§æ¥ã®è¤‡byte Korean ~encoding</a>â—Legacy multi-byte Korean encodings</th></tr>

  <tr><td>$euc-kr</td><td
>`%cseuckr
`%csksc56011987
`%euc-kr
`%iso-ir-149
`%korean
`%ks_c_5601-1987
`%ks_c_5601-1989
`%ksc5601
`%ksc_5601
`%windows-949</td></tr>

 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-miscellaneous-encodings">æ—§æ¥ã®ãã®ä»–ã®~encoding</a>â—Legacy miscellaneous encodings</th></tr>
  <tr><td>$replacement</td><td
>`%csiso2022kr
`%hz-gb-2312
`%iso-2022-cn
`%iso-2022-cn-ext
`%iso-2022-kr</td></tr>

  <tr><td>$utf-16be</td><td
>`%utf-16be</td></tr>

  <tr><td>$utf-16le</td><td
>`%utf-16
`%utf-16le</td></tr>

  <tr><td>$x-user-defined</td><td
>`%x-user-defined</td></tr>
 </tbody>
</table>

<p class="note">æ³¨è¨˜ï¼š
ã™ã¹ã¦ã®$encodingã¨ãã‚Œã‚‰ã®$labelã¯ã€è¦ç¯„çš„ã§ãªã„è³‡æº
$!encodings.json
ã‹ã‚‰ã‚‚å…¥æ‰‹ã§ãã‚‹ã€‚
â—
All encodings and their labels are also available as non-normative encodings.json resource.
</p>

<p class="trans-note">ã€
åå‰ã¯æ­£è¦åŒ–ã•ã‚ŒãŸ~labelã¨è¦‹ãªã›ã‚‹ â€”
â€œreplacementâ€ ã‚’é™¤ãä¸Šã®ä¸€è¦§ã®ã©ã®åå‰ã‚‚ï¼Œ~labelã¨ã—ã¦æœ‰åŠ¹ã«ãªã‚‹ï¼ˆå°æ–‡å­—åŒ–ã—ãŸçµæœã¯ï¼Œå¯¾å¿œã™ã‚‹~labelã®é›†åˆã«å«ã¾ã‚Œã¦ã„ã‚‹ï¼‰ã€‚
ã€‘</p>

		</section>
		<section id="output-encodings">

<h3 title="Output encodings">5.3 å‡ºåŠ›~encoding</h3>

<p>
$encoding %~encoding ã‹ã‚‰
@get-an-output-encoding
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To get an output encoding from an encoding encoding, run these steps:
</p>

<ol>
 <li>
~IFï¼»
%~encoding ~IN
{ $replacement, $utf-16be, $utf-16le }
ï¼½
â‡’
~RET $utf-8
â—
If encoding is replacement, UTF-16BE, or UTF-16LE, return UTF-8.
</li>

 <li>
~RET %~encoding
â—
Return encoding.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
$get-an-output-encodingã™ã‚‹~algoã¯ã€ãã‚Œã‚’å¿…è¦ã¨ã™ã‚‹ï¼»
URL ã®æ§‹æ–‡è§£æ ï¼ HTML ~form~submission
ï¼½ã«ã¦æœ‰ç”¨ã«ãªã‚‹ã€‚
â—
The get an output encoding algorithm is useful for URL parsing and HTML form submission, which both need exactly this.
</p>

		</section>
	</section>
	<section id="indexes">

<h2 title="Indexes">6. ç´¢å¼•</h2>

<p>
ã»ã¨ã‚“ã©ã®æ—§æ¥ã®$encodingã§ã¯ã€
<span class="trans-note">ã€~encodingã”ã¨ã«å›ºæœ‰ã®ã€‘</span>
@index
ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
$indexã¨ã¯ã€ä¸€é€£ã®~entryã‹ã‚‰ãªã‚‹æœ‰é †åº~listã§ã‚ã‚Šã€å„~entryã¯ï¼»
~pointerã¨, ãã‚Œã«å¯¾å¿œã™ã‚‹~cp
ï¼½ã‹ã‚‰ãªã‚‹çµ„ã§ã‚ã‚‹ã€‚
$indexã®ä¸­ã§ã¯ã€~pointerã¯ä¸€æ„ã§ã‚ã‚Šï¼Œ~cpã¯é‡è¤‡ã—å¾—ã‚‹ã€‚
â—
Most legacy encodings make use of an index. An index is an ordered list of entries, each entry consisting of a pointer and a corresponding code point. Within an index pointers are unique and code points can be duplicated.
</p>

<p class="note">æ³¨è¨˜ï¼š
åŠ¹ç‡çš„ãªå®Ÿè£…ã¯ã€$encodingã”ã¨ã«ï¼Œãã®$decoderã¨$encoderã®ãã‚Œãã‚Œã«æœ€é©åŒ–ã•ã‚ŒãŸï¼Œ 2 ã¤ã®$indexã‚’å‚™ãˆã‚‹ã“ã¨ã«ãªã‚‹ã§ã‚ã‚ã†ã€‚
â—
An efficient implementation likely has two indexes per encoding. One optimized for its decoder and one for its encoder.
</p>

<div class="p">

<p class="algo-head">
$index
<span class="trans-note">ã€ã®~dataã‚’ä¾›ã™ã‚‹ä¸‹è¨˜ã®è³‡æºã€‘</span>
ã‹ã‚‰ï¼Œ~pointerã¨ãã‚Œã«å¯¾å¿œã™ã‚‹~cpã‚’è¦‹å‡ºã™ãŸã‚ã«ã¯ï¼š
</p>

<ol >
	<li>
ã¾ãšã€ %lines ã‚’ãã®è³‡æºã®å†…å®¹ã‚’ U+000A ã§ä¸€é€£ã® â€œè¡Œâ€ ã«åˆ†å‰²ã—ãŸçµæœã¨ã™ã‚‹ã€‚
</li>
	<li>
ç©ºè¡Œã‚„, U+0023 ã§é–‹å§‹ã•ã‚Œã‚‹è¡Œã¯ï¼Œ %lines ã‹ã‚‰é™¤å»ã™ã‚‹ã€‚
</li>
	<li>
%lines ã®å„~è¡Œã‚’ U+0009 ã§åˆ†å‰²ã—ãŸã¨ãã®ã€æœ€åˆã®é …ãŒ~pointerï¼ˆ 10 é€²è¡¨è¨˜ï¼‰ã§ã‚ã‚Šï¼Œï¼’ç•ªç›®ã®é …ãŒå¯¾å¿œã™ã‚‹~cpï¼ˆ 16 é€²è¡¨è¨˜ï¼‰ã«ãªã‚‹ã€‚
ä»–ã®é …ã¯ç„¡é–¢ä¿‚ã€‚
</li>
</ol>

â—
To find the pointers and their corresponding code points in an index, let lines be the result of splitting the resource's contents on U+000A. Then remove each item in lines that is the empty string or starts with U+0023. Then the pointers and their corresponding code points are found by splitting each item in lines on U+0009. The first subitem is the pointer (as a decimal number) and the second is the corresponding code point (as a hexadecimal number). Other subitems are not relevant.
</div>

<p class="note">æ³¨è¨˜ï¼š
å„$indexã®å†’é ­ã«ã¯ã€å¤‰æ›´ã®æœ‰ç„¡ã‚’è¨˜ã™ãŸã‚ï¼Œ
<i>Identifier</i> ã¨ <i>Date</i>
<span class="trans-note">ã€è­˜åˆ¥å­ã¨æ—¥ä»˜ã€‘</span>
ãŒè¨˜ã•ã‚Œã¦ã„ã‚‹ã€‚
<i>Identifier</i> ã®å¤‰åŒ–ã¯ã€$indexã«å¤‰æ›´ãŒåŠ ãˆã‚‰ã‚ŒãŸã“ã¨ã‚’è¡¨ã™ã€‚
â—
To signify changes an index includes an Identifier and a Date. If an Identifier has changed, so has the index.
</p>

<p>
%ç´¢å¼• ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™
@index-code-point
ã¨ã¯ã€
%ç´¢å¼• å†…ã« %~pointer ãŒï¼»
åœ¨ã‚‹ãªã‚‰ã°ï¼Œãã‚Œã«å¯¾å¿œã™ã‚‹~cp ï¼
ç„¡ã‘ã‚Œã° ~NULL
ï¼½ã§ã‚ã‚‹ã€‚
â—
The index code point for pointer in index is the code point corresponding to pointer in index, or null if pointer is not in index.
</p>

<p>
%ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™
@index-pointer
ã¨ã¯ã€
%ç´¢å¼• å†…ã« %~cp ã«å¯¾å¿œã™ã‚‹~pointerãŒï¼»
åœ¨ã‚‹ãªã‚‰ã°ï¼Œãã‚Œã‚‰ã®ã†ã¡ã® <em>æœ€åˆã®</em> ~pointer ï¼
ç„¡ã‘ã‚Œã° ~NULL
ï¼½ã§ã‚ã‚‹ã€‚
â—
The index pointer for code point in index is the first pointer corresponding to code point in index, or null if code point is not in index.
</p>

<p>
ä»¥ä¸‹ã¯ã€$index-single-byteã¯é™¤å¤–ã—ãŸï¼Œã“ã®ä»•æ§˜ã§å®šç¾©ã•ã‚Œã‚‹$indexã§ã‚ã‚Šï¼Œãã‚Œãã‚Œã«è‡ªå‰ã®~tableãŒã‚ã‚‹ï¼š
â—
These are the indexes defined by this specification, excluding index single-byte, which have their own table:
</p>

<table id="_index_list">
<col style="min-width:8em;"/>
<col style="min-width:9em;"/>
<col/>

<thead><tr><th>$index
</th><th>å‚ç…§å…ˆ
</th><th>å‚™è€ƒ
</th></tr></thead>

<tbody><tr><td>@index-big5
</td><td>$!index-big5.txt
</td><td>
ã“ã‚Œã¯ã€é¦™æ¸¯å¢—è£œå­—ç¬¦é›†ï¼ˆ Hong Kong Supplementary Character Set ï¼‰, ãŠã‚ˆã³ä»–ã®å…±é€šã®æ‹¡å¼µã¨ä¸€å¼ã§ã€
Big5 æ¨™æº–ã«åˆè‡´ã™ã‚‹ã€‚
â—
This matches the Big5 standard in combination with the Hong Kong Supplementary Character Set and other common extensions.

</td></tr><tr><td>@index-euc-kr
</td><td>$!index-euc-kr.txt
</td><td>
ã“ã‚Œã¯ Windows Codepage 949 ã¨ã—ã¦ã‚ˆã‚ŠåºƒãçŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ï¼Œ
KS X 1001 æ¨™æº–ã¨ çµ±åˆãƒãƒ³ã‚°ãƒ«ã‚³ãƒ¼ãƒ‰ï¼ˆ Unified Hangul Code ï¼‰ã«åˆè‡´ã™ã‚‹ã€‚
â—
This matches the KS X 1001 standard and the Unified Hangul Code, more commonly known together as Windows Codepage 949.

</td></tr><tr><td>@index-gb18030
</td><td>$!index-gb18030.txt
</td><td>
ã“ã‚Œã¯ã€ï¼»
é…å‚™æ¸ˆã¿ã®å†…å®¹ã¨äº’æ›ã«ã™ã‚‹å¿…è¦ã‹ã‚‰ï¼Œ 0xA3 0xA0 ã¯ U+3000 ã«å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã‚‹
ï¼½ã“ã¨ã‚’é™¤ã„ã¦ã€å„~cpãŒ 2 ~byteã«~encodeã•ã‚Œã‚‹ GB18030-2005 æ¨™æº–ã«åˆè‡´ã™ã‚‹ã€‚
  <!-- https://bugzilla.mozilla.org/show_bug.cgi?id=131837
       https://bugs.webkit.org/show_bug.cgi?id=17014
       https://www.w3.org/Bugs/Public/show_bug.cgi?id=25396
       https://github.com/whatwg/encoding/issues/17 -->
â—
This matches the GB18030-2005 standard for code points encoded as two bytes, except for 0xA3 0xA0 which maps to U+3000 to be compatible with deployed content.

</td></tr><tr><td>@index-gb18030-ranges
</td><td>$!index-gb18030-ranges.txt
</td><td>
ã“ã®$indexã¯ã€ã™ã¹ã¦ã®~cpã‚’æŒ™ã’ã¦ã„ãã¨é …ç›®æ•°ãŒ 100 ä¸‡ã‚’è¶…ãˆã¦ã—ã¾ã†ç‚¹ã§ï¼Œä»–ã®ã™ã¹ã¦ã¨ç•°ãªã‚‹ï¼ˆ 207 é¢ã®ç¯„å›²ã¨è‡ªæ˜ãªç¯„å›²æ¤œæŸ»ã«ã‚ˆã‚Šï¼Œãã‚Œã„ã«è¡¨ç¾ã—å¾—ã‚‹ãŒï¼‰ã€‚
ã—ãŸãŒã£ã¦ã€ 4 ~byte ã«~encodeã•ã‚Œã‚‹~cpã«ã¤ã„ã¦ã®ã¿ï¼Œè¦‹ã‹ã‘ä¸Š GB18030-2005 æ¨™æº–ã«åˆè‡´ã™ã‚‹ã€‚
ä¸‹ã®ï¼»
$index-gb18030-ranges-code-point ï¼
$index-gb18030-ranges-pointer
ï¼½ã‚‚è¦‹ã‚ˆã€‚
â—
This index works different from all others. Listing all code points would result in over a million items whereas they can be represented neatly in 207 ranges combined with trivial limit checks. It therefore only superficially matches the GB18030-2005 standard for code points encoded as four bytes. See also index gb18030 ranges code point and index gb18030 ranges pointer below.

</td></tr><tr><td>@index-jis0208
</td><td>$!index-jis0208.txt
</td><td>
IBM ã¨ NEC ã«ã‚ˆã‚‹ã‹ã¤ã¦ã®~proprietaryæ‹¡å¼µã‚‚å«ã¾ã‚Œã¦ã„ã‚‹ï¼Œ JIS X 0208 æ¨™æº–ã€‚
â—
This is the JIS X 0208 standard including formerly proprietary extensions from IBM and NEC.
<!-- NEC = Nippon Electronics Corporation -->

</td></tr><tr><td>@index-jis0212
</td><td>$!index-jis0212.txt
</td><td>
JIS X 0212 æ¨™æº–ã€‚
ã“ã‚Œã¯ã€åºƒã~supportã•ã‚Œã¦ã„ãªã„ã®ã§ï¼Œ$euc-jp-decoderã§ã®ã¿åˆ©ç”¨ã•ã‚Œã‚‹ï¼ˆ~encoderã‹ã‚‰ã¯åˆ©ç”¨ã•ã‚Œãªã„ï¼‰ã€‚
â—
This is the JIS X 0212 standard. It is only used by the EUC-JP decoder due to lack of widespread support elsewhere.
  <!--
   No JIX X 0212 euc-jp encoder support:
     https://bugzilla.mozilla.org/show_bug.cgi?id=600715
     https://code.google.com/p/chromium/issues/detail?id=78847

   No JIX X 0212 iso-2022-jp support:
     https://www.w3.org/Bugs/Public/show_bug.cgi?id=26885
  -->

</td></tr></tbody></table>


<p class="algo-head">
%~pointer ãŒæŒ‡ã™
@index-gb18030-ranges-code-point
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~cpã§ã‚ã‚‹ï¼š
â—
The index gb18030 ranges code point for pointer is the return value of these steps:
</p>

<ol>
 <li>
~IFï¼»
39419 ~LT %~pointer ~LT 189000
ï¼½~ORï¼»
1237575 ~LT %~pointer
ï¼½
â‡’
~RET ~NULL
â—
If pointer is greater than 39419 and less than 189000, or pointer is greater than 1237575, return null.
</li>

 <li>
~IFï¼»
%~pointer ~EQ 7457
ï¼½
â‡’
~RET ~cp [ U+E7C7 ]
â—
If pointer is 7457, return code point U+E7C7. 
</li>

 <li>
%~offset ~LET $index-gb18030-ranges ã®ä¸­ã§ %~pointer ã‚’è¶…ãˆãªã„æœ€å¾Œã®~pointer â—
Let offset be the last pointer in index gb18030 ranges that is equal to or less than pointer and let code point offset be its corresponding code point.
</li>

 <li>
%~cp~offset ~LET %~offset ãŒæŒ‡ã—ã¦ã„ã‚‹~cp
â—
â†‘</li>

 <li>
~RET å€¤ãŒï¼»
%~cp~offset + %~pointer âˆ’ %~offset
ï¼½ãªã‚‹~cp
â—
Return a code point whose value is code point offset + pointer âˆ’ offset.
</li>
</ol>

<p class="algo-head">
%~cp ã‚’æŒ‡ã™
@index-gb18030-ranges-pointer
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index gb18030 ranges pointer for code point is the return value of these steps:
</p>

<ol>
 <li>
%~offset ~LET $index-gb18030-ranges ã®ä¸­ã§ %~cp ã‚’è¶…ãˆãªã„æœ€å¾Œã®~cp
â—
Let offset be the last code point in index gb18030 ranges that is equal to or less than code point and let pointer offset be its corresponding pointer.
</li>

 <li>
%~pointer~offset ~LET %~offset ã«å¯¾å¿œã™ã‚‹~pointer
â—
â†‘</li>

 <li>
~RET å€¤ãŒï¼»
%~pointer~offset + %~cp âˆ’ %~offset
ï¼½ãªã‚‹~pointer
â—
Return a pointer whose value is pointer offset + code point âˆ’ offset.
</li>
</ol>

<p class="algo-head">
%~cp ã‚’æŒ‡ã™
@index-shift_jis-pointer
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index Shift_JIS pointer for code point is the return value of these steps:
</p>

<ol>
 <li>
<p>
%ç´¢å¼• ~LET $index-jis0208 ã‹ã‚‰ï¼Œï¼»
~pointerãŒç¯„å›² { 8272 ã€œ 8835 } ã«å…¥ã‚‹~entry
ï¼½ã™ã¹ã¦ã‚’é™¤å¤–ã—ãŸç´¢å¼•
â—
Let index be index jis0208 excluding all entries whose pointer is in the range 8272 to 8835, inclusive.
</p>
 <!-- selected NEC duplicates from IBM extensions later in the index; need to use IBM
      extensions when going back to bytes -->

<p class="note">
$index-jis0208ã¯ã€é‡è¤‡ã™ã‚‹~cpã‚’åŒ…å«ã™ã‚‹ã®ã§ã€ã“ã‚Œã‚‰ã®~entryã®é™¤å¤–ã«ã‚ˆã‚Šï¼Œå¾Œç¶šã®~cpãŒåˆ©ç”¨ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
The index jis0208 contains duplicate code points so the exclusion of these entries causes later code points to be used.
</p>
 </li>

 <li>
~RET %ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™$index-pointer
â—
Return the index pointer for code point in index.
</li>
</ol>

<p class="algo-head">
%~cp ã‚’æŒ‡ã™
@index-big5-pointer
ã¯ã€æ¬¡ã®æ‰‹ç¶šããŒè¿”ã™~pointerã§ã‚ã‚‹ï¼š
â—
The index Big5 pointer for code point is the return value of these steps:
</p>


<ol>
 <li>
<p>
%ç´¢å¼• ~LET $index-big5ã‹ã‚‰ï¼»
~pointerãŒ (0xA1 âˆ’ 0x81) Ã— 157 ã‚ˆã‚Šå°ã•ã„~entry
ï¼½ã™ã¹ã¦ã‚’é™¤å¤–ã—ãŸç´¢å¼•
â—
Let index be index Big5 excluding all entries whose pointer is less than (0xA1 - 0x81) Ã— 157. 
</p>

<p class="note">æ³¨è¨˜ï¼š
é¦™æ¸¯å¢—è£œå­—ç¬¦é›†ï¼ˆ Hong Kong Supplementary Character Set ï¼‰æ‹¡å¼µã‚’~literalã¨ã—ã¦è¿”ã•ãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚
â—
Avoid returning Hong Kong Supplementary Character Set extensions literally.
</p>
 </li>

 <li>
<p >~IFï¼»
%~cp ~IN 
{ U+2550, U+255E, U+2561, U+256A, U+5341, U+5345 }
ï¼½
â‡’
~RET
%ç´¢å¼• ã®ä¸­ã§ %~cp ã«å¯¾å¿œã™ã‚‹ <em>æœ€å¾Œã®</em> ~pointer
<!-- https://www.w3.org/Bugs/Public/show_bug.cgi?id=27878 -->
â—
If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345, return the last pointer corresponding to code point in index.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä»–ã«ã‚‚é‡è¤‡ã—ã¦ã„ã‚‹~cpã¯ã‚ã‚‹ãŒã€ãã‚Œã‚‰ã«å¯¾ã—ã¦ã¯ï¼Œ<em>æœ€åˆã®</em> ~pointerãŒåˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
There are other duplicate code points, but for those the first pointer is to be used.
</p>
 </li>

 <li>
~RET
%ç´¢å¼• ã®ä¸­ã§ %~cp ã‚’æŒ‡ã™$index-pointer
â—
Return the index pointer for code point in index.
</li>

</ol>



<hr>


<p class="note">æ³¨è¨˜ï¼š
ã™ã¹ã¦ã®$indexã¯è¦ç¯„çš„ã§ãªã„è³‡æº
$!indexes.json
ã‹ã‚‰ã‚‚å…¥æ‰‹ã§ãã‚‹ï¼ˆ $index-gb18030-ranges ã®å½¢å¼ã¯ã€ç¯„å›²ã‚’è¡¨ç¾ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ï¼Œè‹¥å¹²~ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ï¼‰ã€‚
â—
All indexes are also available as non-normative indexes.json resource. (index gb18030 ranges has a slightly different format here, to be able to represent ranges.)
</p>

	</section>
	<section id="specification-hooks">

<h2 title="Specification hooks">7. ä»–ã®ä»•æ§˜ã®ãŸã‚ã®~hook</h2>

<div class="note">
<p>æ³¨è¨˜ï¼š
æ¬¡ã«æŒ™ã’ã‚‹å„ç¨®~algoã¯ã€ä»–ã®ä»•æ§˜ã‹ã‚‰ã®~~åˆ©ç”¨ãŒæ„å›³ã•ã‚Œã¦ã„ã‚‹ï¼š
</p>

<ul ><li>$decode
</li><li>$utf-8-decode
</li><li>$utf-8-decode-without-bom
</li><li>$utf-8-decode-without-bom-or-fail
</li><li>$encode
</li><li>$utf-8-encode
</li></ul>

<p>
æ–°ãŸãªå½¢å¼ã«ã¯ã€$utf-8-decodeãŒåˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
æœ€åˆã«$labelã‚’$encodingã«~~å¤‰æ›ã™ã‚‹ã¨ãã¯ã€$concept-encoding-getã™ã‚‹~algoã‚’åˆ©ç”¨ã§ãã‚‹ã€‚
</p>
â—
The algorithms decode, UTF-8 decode, UTF-8 decode without BOM, UTF-8 decode without BOM or fail, encode, and UTF-8 encode are intended for usage by other specifications. UTF-8 decode is to be used by new formats. The get an encoding algorithm can be used first to turn a label into an encoding.
</div>

<p class="algo-head">
~fallback~encoding %~encoding ã‚’åˆ©ç”¨ã—ã¦ï¼Œ~byte~stream %~stream ã‚’
@decode
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To decode a byte stream stream using fallback encoding encoding, run these steps:
</p>

<ol>
 <li>
%buffer ~LET ~byteåˆ— []
â—
Let buffer be an empty byte sequence.
</li>

 <li>
%~BOMseen~flag ~LET ~OFF
â—
Let BOM seen flag be unset.
</li>

 <li>
æ¬¡ã‚’ 3 å› ç¹°è¿”ã™
â‡’
%~stream ã‹ã‚‰$concept-stream-readã‚’ %buffer ã«ä»˜åŠ ã™ã‚‹
â€” ãŸã ã—ï¼Œ$end-of-stream ãŒè¿”ã•ã‚ŒãŸã¨ãã¯ã€ä»˜åŠ ã›ãšã«ç¹°è¿”ã—ã‚’çµ‚ãˆã‚‹
â—
Read bytes from stream into buffer until either buffer contains three bytes or read returns end-of-stream.
</li>

 <li>
<p>
~IFï¼»
æ¬¡ã®è¡¨ã®ä¸­ã§ï¼Œ 1 åˆ—ç›®ã«ç¤ºã•ã‚ŒãŸ~byteåˆ—ãŒ %buffer ã®å…ˆé ­ã®~byteåˆ—ã«åˆè‡´ã™ã‚‹è¡ŒãŒã‚ã‚‹
ï¼½
â‡’
%~encoding ~SET ãã®è¡Œã® 2 åˆ—ç›®ã«ä¸ãˆã‚‰ã‚Œã‚‹ $encoding ~BR
%~BOMseen~flag ~LET ~ON
â—
For each of the rows in the table below, starting with the first one and going down, if the first bytes of buffer match all the bytes given in the first column, then set encoding to the encoding given in the cell in the second column of that row and set BOM seen flag.
</p>


<table>

<thead><tr><th>~BOMâ—Byte order mark
</th><th>~encodingâ—Encoding
</th></tr></thead>

<tbody><tr><td>0xEF 0xBB 0xBF
</td><td>$utf-8

</td></tr><tr><td>0xFE 0xFF
</td><td>$utf-16be

</td></tr><tr><td>0xFF 0xFE
</td><td>$utf-16le

</td></tr></tbody></table>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™æ¸ˆã¿ã®å†…å®¹ã¨äº’æ›æ€§ã‚’ã¨ã‚‹ãŸã‚ã€~BOMï¼ˆ BOM ï¼‰ã¯ä»–ã‚ˆã‚Š~~å„ªå…ˆã•ã‚Œã‚‹ã€‚
HTTP ãŒåˆ©ç”¨ã•ã‚Œã‚‹æ–‡è„ˆ~ä¸‹ã§ã¯ã€ã“ã‚Œã¯ï¼Œ
`<code class="header">Content-Type</code>`
~headerã®æ„å‘³è«–ã«å¯¾ã™ã‚‹é•åã§ã‚ã‚‹ã€‚
â—
For compatibility with deployed content, the byte order mark (also known as BOM) is more authoritative than anything else. In a context where HTTP is used this is in violation of the semantics of the `Content-Type` header.
</li>

 <li>
~IFï¼»
%~BOMseen~flag ~EQ ~OFF
ï¼½
â‡’
%buffer ã‚’ %~stream $concept-stream-prepend
â—
If BOM seen flag is unset prepend buffer to stream.
</li>

 <li>
~ELIF ï¼»
%~encoding ~NEQ $utf-8
ï¼½~ANDï¼»
%buffer ã®é•·ã• ~EQ 3
ï¼½
â‡’
%buffer ã®æœ€å¾Œã®~byteã‚’ %~stream $concept-stream-prepend
â—
Otherwise, if BOM seen flag is set, encoding is not UTF-8, and buffer contains three bytes, prepend the last byte of buffer to stream.
</li>

 <li>
%å‡ºåŠ› ~LET ~cp$concept-stream
â—
Let output be a code point stream.
</li>

 <li>
( %~stream, %å‡ºåŠ› )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
%~encoding ã®$decoderã‚’$concept-encoding-run
â—
Run encoding's decoder with stream and output.
</li>

 <li>
~RET %å‡ºåŠ›
â—
Return output.
</li>

</ol>

<p class="algo-head">
~byte~stream %~stream ã‚’
@utf-8-decode
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To UTF-8 decode a byte stream stream, run these steps:
</p>

<ol>
 <li>
%buffer ~LET ~byteåˆ— []
â—
Let buffer be an empty byte sequence.
</li>

 <li>
æ¬¡ã‚’ 3 å› ç¹°è¿”ã™
â‡’
%~stream ã‹ã‚‰$concept-stream-readã‚’ %buffer ã«ä»˜åŠ ã™ã‚‹
<span class="trans-note">ã€
â€” ãŸã ã—ï¼Œ$end-of-stream ãŒè¿”ã•ã‚ŒãŸã¨ãã¯ã€ä»˜åŠ ã›ãšã«ç¹°è¿”ã—ã‚’çµ‚ãˆã‚‹
ã€‘</span>
â—
Read three bytes from stream into buffer.
</li>

 <li>
~IFï¼»
%buffer ~NEQ ~byteåˆ— [ 0xEF, 0xBB, 0xBF ]
ï¼½
â‡’
%buffer ã‚’ %~stream $concept-stream-prepend
â—
If buffer does not match 0xEF 0xBB 0xBF, prepend buffer to stream.
</li>

 <li>
%å‡ºåŠ› ~LET ~cp$concept-stream
â—
Let output be a code point stream.
</li>

 <li>
( %~stream, %å‡ºåŠ› )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
$utf-8 ã®$decoderã‚’$concept-encoding-run
â—
Run UTF-8's decoder with stream and output.
</li>

 <li>
~RET %å‡ºåŠ›
â—
Return output.
</li>

</ol>

<p class="algo-head">
~byte~stream %~stream ã‚’
@utf-8-decode-without-bom
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To UTF-8 decode without BOM a byte stream stream, run these steps:
</p>

<ol>
 <li>
%å‡ºåŠ› ~LET ~cp$concept-stream
â—
Let output be a code point stream.
</li>

 <li>
( %~stream, %å‡ºåŠ› )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
$utf-8 ã®$decoderã‚’$concept-encoding-run
â—
Run UTF-8's decoder with stream and output.
</li>

 <li>
~RET %å‡ºåŠ›
â—
Return output.
</li>

</ol>


<p class="algo-head">
~byte~stream %~stream ã‚’
@utf-8-decode-without-bom-or-fail
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To UTF-8 decode without BOM or fail a byte stream stream, run these steps:
</p>

<ol>
 <li>
%å‡ºåŠ› ~LET ~cp$concept-stream
â—
Let output be a code point stream.
</li>

 <li>
( %~stream, %å‡ºåŠ›, `^fatal )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
$utf-8 ã®$decoderã‚’$concept-encoding-run
â—
Let potentialError be the result of running UTF-8's decoder with stream, output, and "fatal".
</li>

 <li>
~IFï¼»
å‰~æ®µã®çµæœ ~EQ $error
ï¼½
â‡’
~RET ~FAIL
â—
If potentialError is error, return failure.
</li>

 <li>
~RET %å‡ºåŠ›
â—
Return output.
</li>

</ol>


<p class="algo-head">
~encoding %~encoding ã‚’åˆ©ç”¨ã—ã¦ ~cp~stream %~stream ã‚’
@encode
ã™ã‚‹ã¨ãã¯ã€æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
To encode a code point stream stream using encoding encoding, run these steps:
</p>

<ol>
 <li>
~Assertï¼š
%~encoding ~NIN 
{ $replacement, $utf-16be, $utf-16le }
â—
Assert: encoding is not replacement, UTF-16BE or UTF-16LE.
</li>

 <li>
%å‡ºåŠ› ~LET ~byte$concept-stream
â—
Let output be a byte stream.
</li>

 <li>
( %~stream, %å‡ºåŠ›, `^html )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
 %~encoding ã®$encoderã‚’$concept-encoding-run
â—
Run encoding's encoder with stream, output, and "html".
</li>

 <li>
~RET %å‡ºåŠ›
â—
Return output.
</li>
</ol>


<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€ä¸»ã« URL ã¨ HTML ~formã®ãŸã‚ã®æ—§æ¥ã®~hookã§ã‚ã‚‹ã€‚
$utf-8-encodeã‚’è¢«ã›ãŸæ–¹ãŒã€æ±ºã—ã¦$errorã‚’èª˜ç™ºã•ã›ãªã„ã®ã§å®‰å…¨ã§ã‚ã‚‹ã€‚
<a href="#refsURL">[URL]</a>
<a href="#refsHTML">[HTML]</a>
â—
This is mostly a legacy hook for URLs and HTML forms. Layering UTF-8 encode on top is safe as it never triggers errors. [URL] [HTML]
</p>

<p class="algo-head">
~cp~stream %~stream ã‚’
@utf-8-encode
ã™ã‚‹ã¨ãã¯
â‡’
$utf-8 ã‚’~encodingã«åˆ©ç”¨ã—ã¦ %~stream ã‚’$encodeã—ãŸçµæœã‚’è¿”ã™ã€‚
â—
To UTF-8 encode a code point stream stream, return the result of encoding stream using encoding UTF-8.
</p>

	</section>
	<section id="api">

<h2 title="API">8. API</h2>

<!-- https://wiki.whatwg.org/wiki/StringEncoding  -->

<p>
ã“ã®ç¯€ã§ã¯ DOM, Web IDL ã®å„ç¨®ç”¨èªãŒç”¨ã„ã‚‰ã‚Œã‚‹ã€‚
é~browser~UAã«å¯¾ã—ã¦ã¯ã€ã“ã® API ã®~supportã¯è¦æ±‚ã•ã‚Œãªã„ã€‚
<a href="#refsDOM">[DOM]</a>
<a href="#refsWEBIDL">[WEBIDL]</a>
â—
This section uses terminology from the DOM and Web IDL. Non-browser user agents are not required to support this API. [DOM] [WEBIDL]
</p>

<div class="example">
<p>
æ¬¡ã®ä¾‹ã¯ã€ `$textencoder ~objã‚’åˆ©ç”¨ã—ã¦ï¼Œæ–‡å­—åˆ—ã®é…åˆ—ã‚’ `ArrayBuffer ã«~encodeã™ã‚‹ã€‚
çµæœã¯æ¬¡ã‚’å†…å®¹ã¨ã™ã‚‹ `Uint8Array ã«ãªã‚‹ï¼š
<span class="block">
å…ˆé ­ãŒï¼ˆ `Uint32Array ã¨ã—ã¦ã®ï¼‰æ–‡å­—åˆ—ã®å€‹æ•°ï¼Œãã®å¾Œã¯ï¼š
<span class="block">
æœ€åˆã®æ–‡å­—åˆ—ã®ï¼ˆ `Uint32Array ã¨ã—ã¦ã®ï¼‰é•·ã•,
$utf-8 ã«~encodeã•ã‚ŒãŸãã®æ–‡å­—åˆ—~dataï¼Œ<br />
ï¼’ç•ªç›®ã®æ–‡å­—åˆ—ã®ï¼ˆ `Uint32Array ã¨ã—ã¦ã®ï¼‰é•·ã•,
ãã®æ–‡å­—åˆ—~dataï¼Œ<br />
â€¦
</span>
ç­‰ã€…ã¨ç¶šãã€‚
</span>
â—
The following example uses the TextEncoder object to encode an array of strings into an ArrayBuffer. The result is a Uint8Array containing the number of strings (as a Uint32Array), followed by the length of the first string (as a Uint32Array), the UTF-8 encoded string data, the length of the second string (as a Uint32Array), the string data, and so on.
</p>

<pre>
function encodeArrayOfStrings(%strings) {
  var %encoder, %encoded, %len, %bytes, %view, %offset;

  %encoder = new TextEncoder();
  %encoded = [];

  %len = Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %strings.length; %i++) {
    %len += Uint32Array.BYTES_PER_ELEMENT;
    %encoded[%i] = %encoder.encode(%strings[%i]);
    %len += %encoded[%i].byteLength;
  }

  %bytes = new Uint8Array(%len);
  %view = new DataView(%bytes.buffer);
  %offset = 0;

  %view.setUint32(%offset, %strings.length);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %encoded.length; %i++) {
    %len = %encoded[%i].byteLength;
    %view.setUint32(%offset, %len);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %bytes.set(%encoded[%i], %offset);
    %offset += %len;
  }
  return %bytes.buffer;
}</pre>

<p>
æ¬¡ã®ä¾‹ã¯ã€ï¼»ï¼»
å‰ã®ä¾‹, ã¾ãŸã¯ $utf-8 ä»¥å¤–ã®~encodingã«ç­‰ä¾¡ãª~algo
ï¼½ã«ã‚ˆã‚Šç”Ÿç”£ã•ã‚Œã‚‹å½¢å¼ã«~encodeã•ã‚ŒãŸ~data
ï¼½ã‚’å«ã‚“ã§ã„ã‚‹ `ArrayBuffer ã‚’~decodeã—ã¦ã€å…ƒã®ï¼Œä¸€é€£ã®æ–‡å­—åˆ—ã‹ã‚‰ãªã‚‹é…åˆ—ã«æˆ»ã™ã€‚
â—
The following example decodes an ArrayBuffer containing data encoded in the format produced by the previous example, or an equivalent algorithm for encodings other than UTF-8, back into an array of strings.
</p>

<pre>
function decodeArrayOfStrings(%buffer, %encoding) {
  var %decoder, %view, %offset, %num_strings, %strings, %len;

  %decoder = new TextDecoder(%encoding);
  %view = new DataView(%buffer);
  %offset = 0;
  %strings = [];

  %num_strings = %view.getUint32(%offset);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %num_strings; %i += 1) {
    %len = %view.getUint32(%offset);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %strings[%i] = %decoder.decode(
      new DataView(%view.buffer, %offset, %len));
    %offset += %len;
  }
  return %strings;
}</pre>
</div>

		<section id="interface-textdecoder">

<h3 title="Interface TextDecoder">8.1. ~interface `TextDecoder</h3>

<pre class="idl">
dictionary @textdecoderoptions {
  boolean fatal = false;
  boolean ignoreBOM = false;
};

dictionary @textdecodeoptions {
  boolean stream = false;
};

[<a href="#dom-textdecoder" title="dom-TextDecoder">Constructor</a>(
    optional DOMString %label = "utf-8",
    optional $textdecoderoptions %options
),
 Exposed=(Window,Worker)]
interface @textdecoder {
  readonly attribute DOMString $dom-textdecoder-encoding;
  readonly attribute boolean $dom-textdecoder-fatal;
  readonly attribute boolean $dom-textdecoder-ignorebom;
  USVString $dom-textdecoder-decode(
      optional BufferSource %input,
      optional $textdecodeoptions %options
  );
};</pre>

<p class="trans-note">ã€
<a href="Encoding-test.html" >åˆ©ç”¨ä¸­ã®~browserã§ã“ã®ç‰¹è‰²æ©Ÿèƒ½ã‚’è©¦ã™</a>
ã€‘</p>

<div class="p">
<p>
å„ `$textdecoder ~objã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼ˆæ‹¬å¼§å†…ã¯åˆæœŸ~å€¤ï¼‰ï¼š
</p>

<ul>
	<li>`!~encoding</li>
	<li>`!~decoder
<p class="trans-note">ã€
`!~encodingã«å¯¾å¿œã™ã‚‹$decoderã®ï¼Œ~instanceã€‚
$decoderã«ã¯ï¼Œå†…éƒ¨çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹å¤‰æ•°ãŸã¡ã‚’ä¼´ã†ã‚‚ã®ã‚‚ã‚ã‚‹ã®ã§ã€~objã”ã¨ã«~instanceã‚’è¦ã™ã‚‹ã€‚
ã€‘</p>
</li>
	<li>`!~stream</li>
	<li>`!~BOMignore~flagï¼ˆ ~OFF ï¼‰</li>
	<li>`!~BOMseen~flagï¼ˆ ~OFF ï¼‰</li>
	<li>`!~error~modeï¼ˆ `^replacement ï¼‰</li>
	<li>`!~no_flush~flagï¼ˆ ~OFF ï¼‰</li>
</ul>

â—
A TextDecoder object has an associated encoding, decoder, stream, ignore BOM flag (initially unset), BOM seen flag (initially unset), error mode (initially "replacement"), and do not flush flag (initially unset).
</div>


<p class="algo-head">
å„ `$textdecoder ~objã«ã¯ã€~streamã‚’
@concept-td-serialize
ã™ã‚‹~algoã‚‚çµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
ãã‚Œã¯ã€æ‰€ä¸ã®$concept-stream %~stream ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
A TextDecoder object also has an associated serialize stream algorithm, that given a stream stream, runs these steps:
</p>

<ol>
 <li>
%å‡ºåŠ› ~LET ç©º$string
â—
Let output be the empty string.
</li>

 <li>
<p>
~WHILE ( true )
â—
While true:
</p>


  <ol>
   <li>
%~token ~LET %~stream ã‹ã‚‰$concept-stream-read
â—
Let token be the result of reading from stream.
</li>

   <li>
<p>
~IFï¼»
`!~encoding ~IN { $utf-8, $utf-16be, $utf-16le }
ï¼½~ANDï¼»
`!~BOMignore~flag ~EQ ~OFF
ï¼½~ANDï¼»
`!~BOMseen~flag ~EQ ~OFF
ï¼½ï¼š
â—
If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore BOM flag and BOM seen flag are unset, run these subsubsteps:
</p>

    <ol>
     <li>
~IFï¼»
%~token ~EQ U+FEFF
ï¼½
â‡’
`!~BOMseen~flag ~SET ~ON
â—
If token is U+FEFF, set BOM seen flag.
</li>

     <li>
~ELIFï¼»
%~token ~NEQ $end-of-stream
ï¼½
â‡’
`!~BOMseen~flag ~SET ~ON ~BR
%~token ã‚’ %å‡ºåŠ› ã«ä»˜åŠ ã™ã‚‹
â—
Otherwise, if token is not end-of-stream, set BOM seen flag and append token to output.
</li>

     <li>
~ELSE
â‡’
~RET %å‡ºåŠ›
â—
Otherwise, return output.
</li>
    </ol>
   </li>

   <li>
~ELIFï¼»
%~token ~NEQ $end-of-stream
ï¼½
â‡’
%~token ã‚’ %å‡ºåŠ› ã«ä»˜åŠ ã™ã‚‹
â—
Otherwise, if token is not end-of-stream, append token to output.
</li>

   <li>
~ELSE
â‡’
~RET %å‡ºåŠ›
â—
Otherwise, return output.
</li>
  </ol>
 </li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®~algoã¯ã€ API ã®åˆ©ç”¨è€…ã« ã‚ˆã‚Šå¤šãã®åˆ¶å¾¡ã‚’ä¾›ã™ã‚‹ãŸã‚ï¼Œ~platformã®ä»–ã®å ´æ‰€ã§åˆ©ç”¨ã•ã‚Œã‚‹$decode ~algoã¨ã¯ã€BOM ã®å–æ‰±ã„ã®ç‚¹ã§æ„å›³çš„ã«ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
This algorithm is intentionally different with respect to BOM handling from the decode algorithm used by the rest of the platform to give API users more control.
</p>

<hr>

<dl class="domintro">
 <dt><code>%decoder = new $dom-textdecoder([%label = "utf-8" [, %options]])</code></dt>
 <dd>
<p>
æ–°ãŸãª `$textdecoder ~obj ã‚’è¿”ã™ã€‚
â—
Returns a new TextDecoder object.
</p>

<p>
%label ãŒ$labelã§ãªã„, ã¾ãŸã¯
%label ãŒ$replacementã§ã‚ã‚‹å ´åˆã€
`RangeError ãŒ<a href="~WEBIDL#dfn-throw">æŠ•å‡º</a>ã•ã‚Œã‚‹ã€‚
â—
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

 <dt><code>%decoder . $dom-textdecoder-encoding</code></dt>
 <dd>
`!~encodingã®$nameã‚’å°æ–‡å­—åŒ–ã—ã¦è¿”ã™ã€‚
â—
Returns encoding's name, lowercased.
</dd>


 <dt><code>%decoder . $dom-textdecoder-fatal</code></dt>
 <dd>
`!~error~modeãŒ `^fatal ãªã‚‰ã° ~T ã‚’, ä»–ã®å ´åˆã¯ ~F ã‚’è¿”ã™ã€‚
â—
Returns true if error mode is "fatal", and false otherwise.
</dd>

 <dt><code>%decoder . $dom-textdecoder-ignorebom</code></dt>
 <dd>
`!~BOMignore~flagãŒ ~ON ãªã‚‰ã° ~T ã‚’, ä»–ã®å ´åˆã¯ ~F ã‚’è¿”ã™ã€‚
â—
Returns true if ignore BOM flag is set, and false otherwise.
</dd>


 <dt><code>%decoder . $dom-textdecoder-decode([%input [, %options]])</code></dt>
 <dd>
<p>
%input ã‚’ `!~encodingã®$decoderã«ã‹ã‘ãŸçµæœã‚’è¿”ã™ã€‚
~streamã‚’æ–­ç‰‡åŒ–ã—ã¦å‡¦ç†ã™ã‚‹ã¨ãã¯ã€
%options ã® `stream ~memberã‚’ ~T ã«ã—ãŸä¸‹ã§ï¼Œã“ã®~method 0 å›~ä»¥ä¸Š~å‘¼å‡ºã—ã¦ã‹ã‚‰ï¼Œ %options ã‚’çœç•¥ã—ã¦ï¼ˆã¾ãŸã¯ ãã® `stream ~memberã‚’ ~F ã«ã—ã¦ï¼‰
1 å›ã ã‘å‘¼å‡ºã™ã“ã¨ã§è¡Œãˆã‚‹ã€‚
å¾Œè€…ã®å‘¼å‡ºæ™‚ã« %input ã‚‚ãªã„ãªã‚‰ã°ã€ä¸¡~å¼•æ•°ã¨ã‚‚çœç•¥ã™ã‚‹ã®ãŒæœ€ã‚‚ç°¡æ˜ã«ãªã‚‹ã€‚
â—
Returns the result of running encoding's decoder. The method can be invoked zero or more times with options's stream set to true, and then once without options's stream (or set to false), to process a fragmented stream. If the invocation without options's stream (or set to false) has no input, it's clearest to omit both arguments.
</p>

<pre class="example">
var %string = "", %decoder = TextDecoder(%encoding), %buffer;
while(%buffer = next_chunk()) {
  %string += %decoder.decode(%buffer, {stream:true});
}
%string += %decoder.decode(); // ~EoS
</pre>

<p>
`!~error~mode ~EQ `^fatal ã®ä¸‹ã§ï¼Œ
`!~encodingã®$decoderãŒ$errorã‚’è¿”ã—ãŸå ´åˆã€
`TypeError ãŒ<a href="~WEBIDL#dfn-throw">æŠ•å‡º</a>ã•ã‚Œã‚‹ã€‚
â—
If the error mode is "fatal" and encoding's decoder returns error, throws a TypeError.
</p>
 </dd>
</dl>



<p>
<code >@dom-textdecoder(%label, %options)</code>
æ§‹ç¯‰å­ã®è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã›~MUSTï¼š
â—
The TextDecoder(label, options) constructor, when invoked, must run these steps:
</p>

<ol>
 <li>
%~encoding ~LET %label ã‹ã‚‰$concept-encoding-getã—ãŸçµæœ
â—
Let encoding be the result of getting an encoding from label.
</li>

 <li>
~IFï¼»
%~encoding ~IN { ~FAIL, $replacement }
ï¼½
â‡’
~THROW `RangeError
â—
If encoding is failure or replacement, throw a RangeError.
</li>

 <li>
%dec ~LET æ–°ãŸãª `$textdecoder ~obj
â—
Let dec be a new TextDecoder object.
</li>

 <li>
%dec ã® `!~encoding ~SET %~encoding
â—
Set dec's encoding to encoding.
</li>

 <li>
~IFï¼»
%options ã® `fatal ~member ~EQ ~T
ï¼½
â‡’
%dec ã® `!~error~mode ~SET `^fatal
â—
If options's fatal member is true, set dec's error mode to "fatal".
</li>

 <li>
~IFï¼»
%options ã® `ignoreBOM ~member ~EQ ~T
ï¼½
â‡’
%dec ã® `!~BOMignore~flag ~SET `^fatal
â—
If options's ignoreBOM member is true, set dec's ignore BOM flag.
</li>

 <li>
~RET %dec
â—
Return dec.
</li>
</ol>

<p>
`@dom-textdecoder-encoding
å±æ€§ã®å–å¾—å­ã¯ã€
`!~encodingã®$nameã‚’$ascii-lowercaseã—ãŸçµæœã‚’è¿”ã•~MUSTã€‚
â—
The encoding attribute's getter must return encoding's name in ASCII lowercase.
</p>

<p>
`@dom-textdecoder-fatal
å±æ€§ã®å–å¾—å­ã¯ã€ï¼»
`!~error~mode ~EQ `^fatal ãªã‚‰ã° ~T ï¼ ~ELSE_ ~F
ï¼½ã‚’è¿”ã•~MUSTã€‚
â—
The fatal attribute's getter must return true if error mode is "fatal", and false otherwise.
</p>

<p>
`@dom-textdecoder-ignorebom
å±æ€§ã®å–å¾—å­ã¯ã€ï¼»
`!~BOMignore~flag ~EQ ~ON ãªã‚‰ã° ~T ï¼
~ELSE_ ~F
ï¼½ã‚’è¿”ã•~MUSTã€‚
â—
The ignoreBOM attribute's getter must return true if ignore BOM flag is set, and false otherwise.
</p>

<p>
<code >@dom-textdecoder-decode(%input, %options)</code>
~methodã®è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã›~MUSTï¼š
â—
The decode(input, options) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IFï¼»
`!~no_flush~flag ~EQ ~OFF
ï¼½
â‡’
`!~decoder ~SET æ–°ãŸãªï¼»
`!~encoding ã®$decoder
ï¼½ ~BR
`!~stream ~SET æ–°ãŸãª$concept-stream ~BR
`!~BOMseen~flag ~SET ~OFF
â—
If the do not flush flag is unset, set decoder to a new encoding's decoder, set stream to a new stream, and unset the BOM seen flag.
</li>

 <li>
`!~no_flush~flag ~SETï¼»
%options ã® `stream ~EQ ~T ãªã‚‰ã° ~ON ï¼
~ELSE_ ~OFF
ï¼½
â—
If options's stream is true, set the do not flush flag, and unset the do not flush flag otherwise.
</li>

 <li>
~IFï¼»
%input ã¯ä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹
ï¼½
â‡’
%input ã®<a href="~WEBIDL#dfn-get-buffer-source-copy">è¤‡è£½</a>ã‚’ `!~stream$concept-stream-push
â—
If input is given, push a copy of input to stream.
</li>

 <li>
%å‡ºåŠ› ~LET æ–°ãŸãª$concept-stream
â—
Let output be a new stream.
</li>

 <li>
<p>
~WHILE ( true )
â—
While true:
</p>


  <ol>
   <li>
%~token ~LET `!~streamã‹ã‚‰$concept-stream-read
â—
Let token be the result of reading from stream.
</li>

   <li>
<p>
~IFï¼»
%~token ~EQ $end-of-stream
ï¼½~ANDï¼»
`!~no_flush~flag ~EQ ~ON
ï¼½
â‡’
~RET %å‡ºåŠ› ã‚’$concept-td-serializeã—ãŸçµæœ
â—
If token is end-of-stream and the do not flush flag is set, return output, serialized.
</p>

<p class="note">
~streamingã§ã¯ã€ï¼»
`!~no_flush~flag ~EQ ~ON
ï¼½ã®ã¨ãã«ï¼Œã“ã“ã§$end-of-streamã‚’å–æ‰±ã†ã“ã¨ãªãï¼Œãã®~flagã‚’ ~OFF ã«ã—ãªã„ä»•æ–¹ã§åƒãã€‚
ã“ã®ä»•æ–¹ã«ã‚ˆã‚Šã€å¾Œç¶šã®å‘¼å‡ºæ™‚ã«ã¯ï¼Œã“ã®~algoã®æœ€åˆã®æ®µã§ `!decoderã¯ä¸€æ–°ã•ã‚Œãšã€ãã®çŠ¶æ…‹ã¯ä¿å…¨ã•ã‚Œã‚‹ã€‚
â—
The way streaming works is to not handle end-of-stream here when the do not flush flag is set and to not unset that flag. That way in a subsequent invocation decoder is not set anew in the first step of the algorithm and its state is preserved.
</p>
   </li>

   <li>
%çµæœ ~LET
( `!~decoder, `!~stream, %å‡ºåŠ›, `!~error~mode )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
%~token ã‚’$concept-encoding-processã—ãŸçµæœ
â—
Otherwise, run these subsubsteps:
â—
Let result be the result of processing token for decoder, stream, output, and error mode.
</li>

   <li>
~IFï¼»
%çµæœ ~EQ $finished
ï¼½
â‡’
~RET %å‡ºåŠ› ã‚’$concept-td-serializeã—ãŸçµæœ
â—
If result is finished, return output, serialized.
</li>

   <li>
~ELIFï¼»
%çµæœ ~EQ $error
ï¼½
â‡’
~THROW `TypeError
â—
Otherwise, if result is error, throw a TypeError.
â—
Otherwise, do nothing.
</li>
  </ol>
 </li>
</ol>


		</section>
		<section id="interface-textencoder">

<h3 title="Interface TextEncoder">8.2. ~interface `TextEncoder</h3>

<pre class="idl">
[<a href="#dom-textencoder" title="dom-TextEncoder">Constructor</a><!--
We cannot add an argument here that is not the label argument it had previously. That would break content.
-->, Exposed=(Window,Worker)]
interface @textencoder {
  readonly attribute DOMString $dom-textencoder-encoding;
  [NewObject] Uint8Array $dom-textencoder-encode(optional USVString %input = "");
};</pre>


<p>
å„ `$textencoder ~objã«ã¯ã€ `!~encoder ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
A TextEncoder object has an associated encoder.
</p>

<p class="note">æ³¨è¨˜ï¼š
`$textencoder ~objã®æ§‹ç¯‰å­ã«ã¯ã€ %label å¼•æ•°ã¯ãªãï¼Œ~supportã™ã‚‹ã®ã¯ $utf-8 ã®ã¿ã§ã‚ã‚‹ã€‚
ã¾ãŸã€~scalarå€¤~bufferã‚’è¦ã™ã‚‹$encoderã¯ç„¡ã„ã®ã§ï¼Œ `stream ã®~optionã‚‚ãªã„ã€‚
â—
A TextEncoder object offers no label argument as it only supports UTF-8. It also offers no stream option as no encoder requires buffering of scalar values.
</p>

<hr>

<dl class="domintro">
 <dt><code>%encoder = new $dom-textencoder()</code></dt>
 <dd>
æ–°ãŸãª `$textencoder ~obj ã‚’è¿”ã™ã€‚
â—
Returns a new TextEncoder object.
</dd>

 <dt><code>%encoder . $dom-textencoder-encoding</code></dt>
 <dd>
`^utf-8 ã‚’è¿”ã™ã€‚
â—
Returns "utf-8".
</dd>

 <dt><code>%encoder . $dom-textencoder-encode([%input = ""])</code></dt>
 <dd>
%input ã‚’ $utf-8 ã®$encoderã«ã‹ã‘ãŸçµæœã‚’è¿”ã™ã€‚
â—
Returns the result of running UTF-8's encoder.
</dd>

</dl>



<p>
<code>@dom-textencoder()</code>
æ§‹ç¯‰å­ã®è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã›~MUSTï¼š
â—
The TextEncoder() constructor, when invoked, must run these steps:
</p>

<ol>
 <li>
%enc ~LET æ–°ãŸãª `$textencoder ~obj
â—
Let enc be a new TextEncoder object.
</li>
 <li>
%enc ã® `!~encoder ~SET $utf-8 ã®$encoder
â—
Set enc's encoder to UTF-8's encoder.
</li>
 <li>
~RET %enc
â—
Return enc.
</li>
</ol>

<p>
`@dom-textencoder-encoding
å±æ€§ã®å–å¾—å­ã¯ã€ `^utf-8 ã‚’è¿”ã•~MUSTã€‚
â—
The encoding attribute's getter must return "utf-8".
</p>

<p>
<code >@dom-textencoder-encode(%input)</code>
~methodã®è¢«å‘¼å‡ºæ™‚ã«ã¯ã€æ¬¡ã‚’èµ°ã‚‰ã›~MUSTï¼š
â—
The encode(input) method, when invoked, must run these steps:
</p>


<ol>
 <li>
%å…¥åŠ› ~LET %input ã‚’$concept-streamã«å¤‰æ›ã—ãŸçµæœ
â—
Convert input to a stream.
</li>

 <li>
%å‡ºåŠ› ~LET æ–°ãŸãª$concept-stream
â—
Let output be a new stream.
</li>

 <li>
<p>
~WHILE ( true ) ï¼š
â—
While true, run these substeps:
</p>

  <ol>
   <li>
%~token ~LET %å…¥åŠ› ã‹ã‚‰$concept-stream-read
â—
Let token be the result of reading from input.
</li>

   <li>
%çµæœ ~LET 
( `!~encoder, %å…¥åŠ›, %å‡ºåŠ› )
ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼Œ
%~token ã‚’$concept-encoding-processã—ãŸçµæœ
â—
Let result be the result of processing token for encoder, input, output.
</li>

   <li>
~IFï¼»
%çµæœ ~EQ $finished
ï¼½
â‡’
~RET ï¼»ï¼»
%å‡ºåŠ› ã‚’~byteåˆ—ã«å¤‰æ›ã—ãŸçµæœ
ï¼½ã‚’åŒ…å«ã™ã‚‹ `ArrayBuffer
ï¼½ã‚’åŒ…è£…ã™ã‚‹ã‚ˆã†ãªï¼Œæ–°ãŸãª `Uint8Array ~obj
<!-- XXX https://www.w3.org/Bugs/Public/show_bug.cgi?id=26966 -->
â—
If result is finished, convert output into a byte sequence, and then return a Uint8Array object wrapping an ArrayBuffer containing output.
</li>

  </ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã‚‰ã®$encodingãŒ$errorã‚’è¿”ã™ã“ã¨ã¯ãªã„ã€‚
â—
These encodings cannot return error.
</p>

 </li>
</ol>

		</section>
	</section>
	<section id="the-encoding">

<h2 title="The encoding">9. ~~æ¨™æº–ã®~encoding</h2>

<p class="trans-note">ã€
ã“ã® â€œ~~æ¨™æº–ã®â€ ã¯ â€œTheâ€ ã®å¯¾è¨³ã§ã‚ã‚Šã€ãŠã‚ˆãï¼Œ
â€œè¦ç¯„ã¨ã•ã‚Œã‚‹ã¹ãå”¯ä¸€ç„¡äºŒã®â€
ã‚’æ„å‘³ã™ã‚‹ã€‚
ã€‘</p>

		<section id="utf-8">

<h3>9.1. <b>UTF-8</b></h3>

			<section id="utf-8-decoder">
<h4 title="UTF-8 decoder">9.1.1. UTF-8 ~decoder</h4>


<p>
$utf-8 ã®$decoderã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
@utf-8-code-pointï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰~BR
@utf-8-bytes-seenï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰~BR
@utf-8-bytes-neededï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰~BR
@utf-8-lower-boundaryï¼ˆåˆæœŸ~æ™‚ 0x80 ï¼‰~BR
@utf-8-upper-boundaryï¼ˆåˆæœŸ~æ™‚ 0xBF ï¼‰
â—
UTF-8's decoder's has an associated UTF-8 code point, UTF-8 bytes seen, and UTF-8 bytes needed (all initially 0), a UTF-8 lower boundary (initially 0x80), and a UTF-8 upper boundary (initially 0xBF).
</p>

<p>
$utf-8 ã®$decoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
UTF-8's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
~IFï¼»
%~byte ~EQ $end-of-stream
ï¼½~ANDï¼»
$utf-8-bytes-needed ~NEQ 0
ï¼½
â‡’
$utf-8-bytes-needed ~SET 0 ~BR
~RET $error
â—
If byte is end-of-stream and UTF-8 bytes needed is not 0, set UTF-8 bytes needed to 0 and return error.
</li>

 <li>
~IFï¼»
%~byte ~EQ $end-of-stream
ï¼½
â‡’
~RET $finished
â—
If byte is end-of-stream, return finished.
</li>

 <li>
<p>
~IFï¼»
$utf-8-bytes-needed ~EQ 0
ï¼½ï¼š
â—
If UTF-8 bytes needed is 0, based on byte:
</p>

  <ol>
   <li>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
â†‘</p>

    <dl class="switch">
     <dt>$ascii-byte</dt>
     <dd>
~RET ~cp [ %~byte ]
â—
Return a code point whose value is byte.
</dd>

     <dt>0xC2 ã€œ 0xDF</dt>
     <dd>
      <ol>
       <li>
$utf-8-bytes-needed ~SET 1
â—
Set UTF-8 bytes needed to 1.
</li>
       <li>
$utf-8-code-point ~SET %~byte &amp; 0x1F
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 5 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte &amp; 0x1F.
â—
The five least significant bits of byte.
</li>
      </ol>
     </dd>

     <dt>0xE0 ã€œ 0xEF</dt>
     <dd>
      <ol>
       <li>
~IFï¼»
%~byte ~EQ 0xE0
ï¼½
â‡’
$utf-8-lower-boundary ~SET 0xA0
â—
If byte is 0xE0, set UTF-8 lower boundary to 0xA0.
</li>

       <li>
~IFï¼»
%~byte ~EQ 0xED
ï¼½
â‡’
$utf-8-upper-boundary ~SET 0x9F
â—
If byte is 0xED, set UTF-8 upper boundary to 0x9F.
</li>

       <li>
$utf-8-bytes-needed ~SET 2
â—
Set UTF-8 bytes needed to 2.
</li>

       <li>
$utf-8-code-point ~SET %~byte &amp; 0xF
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 4 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte &amp; 0xF.
â—
The four least significant bits of byte.
</li>
      </ol>
     </dd>

     <dt>0xF0 ã€œ 0xF4</dt>
     <dd>
      <ol>
       <li>
~IFï¼»
%~byte ~EQ 0xF0
ï¼½
â‡’
$utf-8-lower-boundary ~SET 0x90
â—
If byte is 0xF0, set UTF-8 lower boundary to 0x90.
</li>
       <li>
~IFï¼»
%~byte ~EQ 0xF4
ï¼½
â‡’
$utf-8-upper-boundary ~SET 0x8F
â—
If byte is 0xF4, set UTF-8 upper boundary to 0x8F.
</li>
       <li>
$utf-8-bytes-needed ~SET 3
â—
Set UTF-8 bytes needed to 3.
</li>

       <li>
$utf-8-code-point ~SET %~byte &amp; 0x7
<span class="note">ï¼ˆ %~byte ã®ä¸‹ä½ 3 ~bit ï¼‰</span>
â—
Set UTF-8 code point to byte & 0x7.
â—
The three least significant bits of byte.
</li>
      </ol>
     </dd>

     <dt>~OTHERâ—Otherwise</dt>
     <dd>
~RET $error
â—
Return error.
</dd>
    </dl>
   </li>
   <li>
~RET $continue
â—
Return continue.
</li>
  </ol>
 </li>

 <li>
<p>
~IFï¼»
%~byte ~NIN { $utf-8-lower-boundary ã€œ $utf-8-upper-boundary }
ï¼š
â—
If byte is not in the range UTF-8 lower boundary to UTF-8 upper boundary, inclusive, run these substeps:
</p>

  <ol>
   <li>
( $utf-8-code-point, $utf-8-bytes-needed, $utf-8-bytes-seen ) ~SET ( 0, 0, 0 ) ~BR
( $utf-8-lower-boundary, $utf-8-upper-boundary ) ~SET ( 0x80, 0xBF )
â—
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0, set UTF-8 lower boundary to 0x80, and set UTF-8 upper boundary to 0xBF.
</li>

 <li>
%~byte ã‚’ %~stream $concept-stream-prepend
â—
Prepend byte to stream.
</li>

 <li>
~RET $error
â—
Return error.
</li>
  </ol>
 </li>

 <li>
( $utf-8-lower-boundary, $utf-8-upper-boundary ) ~SET ( 0x80, 0xBF )
â—
Set UTF-8 lower boundary to 0x80 and UTF-8 upper boundary to 0xBF.
</li>

 <li>
<p>
$utf-8-code-point ~SET ($utf-8-code-point &lt;&lt; 6) | (%~byte &amp; 0x3F)
â—
Set UTF-8 code point to (UTF-8 code point &lt;&lt; 6) | (byte &amp; 0x3F)
</p>

<p class="note">
$utf-8-code-pointå†…ã®æ—¢å­˜ã®~bitã‚’å·¦ã¸ 6 ~bit ~shiftã—ã¦ï¼Œç©ºã„ãŸä¸‹ä½ 6 ~bitã« %~byte ã®ä¸‹ä½ 6 ~bitã‚’ã‚ã¦ãŒã†ã€‚
â—
Shift the existing bits of UTF-8 code point left by six places and set the newly-vacated six least significant bits to the six least significant bits of byte.
</p>
 </li>

 <li>
<p>
$utf-8-bytes-seen ~INCBY 1
â—
Increase UTF-8 bytes seen by one.
</li>

 <li>
~IFï¼»
$utf-8-bytes-seen ~NEQ $utf-8-bytes-needed
ï¼½
â‡’
~RET $continue
â—
If UTF-8 bytes seen is not equal to UTF-8 bytes needed, return continue.
</li>

 <li>
%~cp ~LET $utf-8-code-point
â—
Let code point be UTF-8 code point.
</li>

 <li>
( $utf-8-code-point, $utf-8-bytes-needed, $utf-8-bytes-seen ) ~SET ( 0, 0, 0 ) 
â—
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0.
</li>

 <li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
</ol>

<p class="note">æ³¨è¨˜ï¼š
ä¸Šã®$utf-8-decoderã«ãŠã‘ã‚‹æ‹˜æŸã¯ã€ Unicode æ¨™æº–ã®
â€œBest Practices for Using U+FFFDâ€
ã«æº–ãšã‚‹ã€‚
ä»–ã®ãµã‚‹ã¾ã„ã¯ Encoding æ¨™æº–ã®ä¸‹ã§ã¯è¨±å¯ã•ã‚Œãªã„ï¼ˆåŒã˜çµæœãŒå¾—ã‚‰ã‚Œã‚‹ãªã‚‰ï¼Œä»–ã®~algoã§ã‚‚ ã‚‚ã¡ã‚ã‚“~~ååˆ†ã§ã‚ã‚Šã€ã‚€ã—ã‚å¥¨åŠ±ã•ã‚Œã‚‹ï¼‰ã€‚
<a href="#refsUNICODE">[UNICODE]</a>
â—
The constraints in the UTF-8 decoder above match â€œBest Practices for Using U+FFFDâ€ from the Unicode standard. No other behavior is permitted per the Encoding Standard (other algorithms that achieve the same result are obviously fine, even encouraged). [UNICODE]
</p>

			</section>
			<section id="utf-8-encoder">
<h4 title="UTF-8 encoder">9.1.2. UTF-8 ~encoder</h4>

<p>
$utf-8 ã®$encoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
UTF-8's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
~IFï¼»
%~cp ~EQ $end-of-stream
ï¼½
â‡’
~RET $finished
â—
If code point is end-of-stream, return finished.
</li>

 <li>
~IFï¼»
%~cp ~IN $ascii-code-point
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
<p>
( %count, %~offset ) ~SET %~cp ãŒå±ã™ã‚‹ç¯„å›²ã«å¿œã˜ã¦ï¼Œæ¬¡ã§ä¸ãˆã‚‰ã‚Œã‚‹å€¤ï¼š
â—
Set count and offset based on the range code point is in:
</p>
  <dl class="switch">
   <dt>U+0080 ã€œ U+07FF</dt>
   <dd>
( 1, 0xC0 )
â—
1 and 0xC0
</dd>
   <dt>U+0800 ã€œ U+FFFF</dt>
   <dd>
( 2, 0xE0 )
â—
2 and 0xE0
</dd>
   <dt>U+10000 ã€œ U+10FFFF</dt>
   <dd>
( 3, 0xF0 )
â—
3 and 0xF0
</dd>
  </dl>
<!--
   <dt>U+0080 to U+07FF, inclusive</dt>
   <dd>1 and 0xC0
   </dd><dt>U+0800 to U+FFFF, inclusive</dt>
   <dd>2 and 0xE0
   </dd><dt>U+10000 to U+10FFFF, inclusive</dt>
   <dd>3 and 0xF0
 -->

 </li>

 <li>
%~byteåˆ— ~LET ~byteåˆ— [ ( %~cp &gt;&gt; ( 6 Ã— %count ) ) + %~offset ]
â—
Let bytes be a byte sequence whose first byte is (code point &gt;&gt; (6 Ã— count)) + offset.
</li>

 <li>
<p>
~WHILE %count ~GT 0
ï¼š
â—
Run these substeps while count is greater than 0:
</p>

  <ol>
   <li>
%temp ~SET %~cp &gt;&gt; ( 6 Ã— ( %count âˆ’ 1 ) )
â—
Set temp to code point &gt;&gt; (6 Ã— (count âˆ’ 1)).
</li>

 <li>
( 0x80 | ( %temp &amp; 0x3F ) ) ã‚’ %~byteåˆ— ã«ä»˜åŠ ã™ã‚‹
â—
Append to bytes 0x80 | (temp &amp; 0x3F).
</li>

 <li>
%count ~DECBY 1
â—
Decrease count by one.
</li>
  </ol>
 </li>

 <li>
~RET %~byteåˆ—
â—
Return bytes bytes, in order.
</li>
</ol>

<p class="note">
ã“ã®~algoã¯ã€ Unicode æ¨™æº–ã«è¿°ã¹ã‚‰ã‚Œã‚‹ã‚‚ã®ã¨ä¸€è‡´ã™ã‚‹çµæœã‚’å¾—ã‚‹ãŒã€å®Œå…¨ã•ã®ãŸã‚ã“ã“ã«å«ã‚ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
<a href="#refsUNICODE">[UNICODE]</a>
â—
This algorithm has identical results to the one described in the Unicode standard. It is included here for completeness. [UNICODE]
</p>


			</section>
		</section>
	</section>
	<section id="legacy-single-byte-encodings">

<h2 title="Legacy single-byte encodings">10. æ—§æ¥ã®å˜byte~encoding</h2>

<p>
å„~byteãŒï¼»
ï¼‘å€‹ã®~cpã«å¯¾å¿œã™ã‚‹ã‹, ã¾ãŸã¯å¯¾å¿œã™ã‚‹~cpã¯ç„¡ã„
ï¼½ã‚ˆã†ãª$encodingã‚’
@single-byte-encoding
ã¨å‘¼ã¶ã€‚
ã™ã¹ã¦ã®$single-byte-encodingãŒã€åŒã˜ï¼»
$decoder, $encoder
ï¼½ã‚’å…±æœ‰ã™ã‚‹ã€‚
$single-byte-decoderï¼$single-byte-encoderã‹ã‚‰å‚ç…§ã•ã‚Œã‚‹
@index-single-byte
ã¯ã€åˆ©ç”¨ã•ã‚Œã‚‹$single-byte-encodingã«ä¾å­˜ã—ï¼Œæ¬¡ã®ä¸€è¦§ã§å®šç¾©ã•ã‚Œã‚‹ã€‚
ï¼’ã¤
<span class="trans-note">ã€ ISO-8859-8, ISO-8859-8-I ã€‘</span>
ã‚’é™¤ãã™ã¹ã¦ã®$single-byte-encodingã¯ã€ãã‚Œãã‚Œã«ä¸€æ„ãª$indexã‚’æŒã¤ã€‚
â—
An encoding where each byte is either a single code point or nothing, is a single-byte encoding. Single-byte encodings share the decoder and encoder. Index single-byte, as referenced by the single-byte decoder and single-byte encoder, is defined by the following table, and depends on the single-byte encoding in use. All but two single-byte encodings have a unique index.
</p>
<table>

<thead><tr><th>$nameâ—Name
</th><th>$indexâ—Index
</th></tr></thead>

<tbody>
<tr><td>@ibm866</td><td>$!index-ibm866.txt</td></tr>
<tr><td>@iso-8859-2</td><td>$!index-iso-8859-2.txt</td></tr>
<tr><td>@iso-8859-3</td><td>$!index-iso-8859-3.txt</td></tr>
<tr><td>@iso-8859-4</td><td>$!index-iso-8859-4.txt</td></tr>
<tr><td>@iso-8859-5</td><td>$!index-iso-8859-5.txt</td></tr>
<tr><td>@iso-8859-6</td><td>$!index-iso-8859-6.txt</td></tr>
<tr><td>@iso-8859-7</td><td>$!index-iso-8859-7.txt</td></tr>
<tr><td>@iso-8859-8</td><td rowspan="2">$!index-iso-8859-8.txt</td></tr>
<tr><td>@iso-8859-8-i</td></tr>
<tr><td>@iso-8859-10</td><td>$!index-iso-8859-10.txt</td></tr>
<tr><td>@iso-8859-13</td><td>$!index-iso-8859-13.txt</td></tr>
<tr><td>@iso-8859-14</td><td>$!index-iso-8859-14.txt</td></tr>
<tr><td>@iso-8859-15</td><td>$!index-iso-8859-15.txt</td></tr>
<tr><td>@iso-8859-16</td><td>$!index-iso-8859-16.txt</td></tr>
<tr><td>@koi8-r</td><td>$!index-koi8-r.txt</td></tr>
<tr><td>@koi8-u</td><td>$!index-koi8-u.txt</td></tr>
<tr><td>@macintosh</td><td>$!index-macintosh.txt</td></tr>
<tr><td>@windows-874</td><td>$!index-windows-874.txt</td></tr>
<tr><td>@windows-1250</td><td>$!index-windows-1250.txt</td></tr>
<tr><td>@windows-1251</td><td>$!index-windows-1251.txt</td></tr>
<tr><td>@windows-1252</td><td>$!index-windows-1252.txt</td></tr>
<tr><td>@windows-1253</td><td>$!index-windows-1253.txt</td></tr>
<tr><td>@windows-1254</td><td>$!index-windows-1254.txt</td></tr>
<tr><td>@windows-1255</td><td>$!index-windows-1255.txt</td></tr>
<tr><td>@windows-1256</td><td>$!index-windows-1256.txt</td></tr>
<tr><td>@windows-1257</td><td>$!index-windows-1257.txt</td></tr>
<tr><td>@windows-1258</td><td>$!index-windows-1258.txt</td></tr>
<tr><td>@x-mac-cyrillic</td><td>$!index-x-mac-cyrillic.txt</td></tr>
</tbody>
</table>

<p class="note">æ³¨è¨˜ï¼š
~layoutæ–¹å‘ã«æ³¢åŠã™ã‚‹ã“ã¨ã‹ã‚‰ã€ $iso-8859-8 ã¨ $iso-8859-8-i ã®$encodingã®$nameã¯ç•°ãªã‚‹ã‚‚ã®ã«ã•ã‚Œã¦ã„ã‚‹ã€‚
æ­´å²çš„ã«ã€ã“ã®ã“ã¨ã¯ $iso-8859-6 ã¨ "iso-8859-6-i" ã«ã¤ã„ã¦ã‚‚è©²å½“ã—ã¦ã„ãŸãŒã€ãã‚Œã¯ä»Šã‚„æˆç«‹ã—ãªã„ã€‚
<!-- https://www.w3.org/Bugs/Public/show_bug.cgi?id=19505 -->
â—
ISO-8859-8 and ISO-8859-8-I are distinct encoding names, because ISO-8859-8 has influence on the layout direction. And although historically this might have been the case for ISO-8859-6 and "iso-8859-6-i" as well, that is no longer true.
</p>



		<section id="single-byte-decoder">
<h3 title="single-byte decoder">10.1. å˜byte~decoder</h3>

<p>
$single-byte-encodingã®$decoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Single-byte encodings's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
~IFï¼»
%~byte ~EQ $end-of-stream
ï¼½
â‡’
~RET $finished
â—
If byte is end-of-stream, return finished.
</li>


 <li>
~IFï¼»
%~byte ~IN $ascii-byte
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>

 <li>
%~cp ~LET
$index-single-byte ã®ä¸­ã§
( %~byte âˆ’ 0x80 )
ãŒæŒ‡ã™$index-code-point
â—
Let code point be the index code point for byte âˆ’ 0x80 in index single-byte.
</li>

 <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET $error
â—
If code point is null, return error.
</li>

 <li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
</ol>

		</section>
		<section id="single-byte-encoder">
<h3 title="single-byte encoder">10.2. å˜byte~encoder</h3>

<p>
$single-byte-encoding ã®$encoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Single-byte encodings's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
~IFï¼»
%~cp ~EQ $end-of-stream
ï¼½
â‡’
~RET $finished
â—
If code point is end-of-stream, return finished.
</li>

 <li>
~IFï¼»
%~cp ~IN $ascii-code-point
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
%~pointer ~LET
$index-single-byte ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™$index-pointer
â—
Let pointer be the index pointer for code point in index single-byte.
</li>

 <li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†$error
â—
If pointer is null, return error with code point.
</li>

 <li>
~RET ~byteåˆ— [ %~pointer + 0x80 ]
â—
Return a byte whose value is pointer + 0x80.
</li>
</ol>

		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(simplified)-encodings">

<h2 title="Legacy multi-byte Chinese (simplified) encodings">11. æ—§æ¥ã®è¤‡byte Chinese ï¼ˆç°¡ä½“å­—ï¼‰ ~encoding</h2>

		<section id="gbk">
<h3 title="GBK">11.1 <b>GBK</b></h3>

			<section id="gbk-decoder">
<h4 title="GBK decoder">11.1.1 GBK ~decoder</h4>

<p>
$gbk ã®$decoderã¯ï¼Œ $gb18030 ã®$decoderã§ã‚ã‚‹ã€‚
â—
GBK's decoder is gb18030's decoder.
</p>

			</section>
			<section id="gbk-encoder">
<h4 title="GBK encoder">11.1.2 GBK ~encoder</h4>

<p>
GBK ã®~encoderã¯ï¼Œï¼»
$gbk-flag ~SET ~ON
ï¼½ã«ã•ã‚ŒãŸ $gb18030 ã®$encoderã§ã‚ã‚‹ã€‚
â—
GBK's encoder is gb18030's encoder with its GBK flag set.
</p>


<p class="note">æ³¨è¨˜ï¼š
$gbk ã‚’ $gb18030 ã«å¯¾ã™ã‚‹å…¨ãã®åˆ¥åã«ã—ãªã„ã®ã¯ã€
$gbk ã®$encoderã«ã‚ˆã‚Šç”Ÿæˆã•ã‚ŒãŸå†…å®¹ã‚’ï¼Œæ—§æ¥ã®~serverã‚„ä»–ã®æ¶ˆè²»è€…ã‚’ãªã‚‹ã¹ãå£Šã™ã“ã¨ãªãï¼Œä¿å®ˆçš„ã«ç§»è¡Œã™ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
â—
Not fully aliasing GBK with gb18030 is a conservative move to decrease the chances of breaking legacy servers and other consumers of content generated with GBK's encoder.
</p>
			</section>
		</section>


		<section id="gb18030">

<h3 title="gb18030">11.2. <b>gb18030</b></h3>


			<section id="gb18030-decoder">
<h4 title="gb18030 decoder">11.2.1. gb18030 ~decoder</h4>

<p>
$gb18030 ã®$decoderã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
@gb18030-firstï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰~BR
@gb18030-secondï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰~BR
@gb18030-thirdï¼ˆåˆæœŸ~æ™‚ 0 ï¼‰
â—
gb18030's decoder has an associated gb18030 first, gb18030 second, and gb18030 third (all initially 0x00).
</p>

<p>
$gb18030 ã®$decoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
gb18030's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
~IFï¼»
%~byte ~EQ $end-of-stream
ï¼½ï¼š
â—
â†“</p>

  <ol>
   <li>
~IFï¼»
( $gb18030-first, $gb18030-second, $gb18030-third ) ~EQ ( 0x00, 0x00, 0x00 )
ï¼½
â‡’
~RET $finished
â—
If byte is end-of-stream and gb18030 first, gb18030 second, and gb18030 third are 0x00, return finished.
</li>

   <li>
( $gb18030-first, $gb18030-second, $gb18030-third ) ~SET ( 0x00, 0x00, 0x00 ) ~BR
~RET $error
â—
If byte is end-of-stream, and gb18030 first, gb18030 second, or gb18030 third is not 0x00, set gb18030 first, gb18030 second, and gb18030 third to 0x00, and return error.
</li>

  </ol>
 </li>

 <li>
<p>
~IFï¼»
$gb18030-third ~NEQ 0x00
ï¼½ï¼š
â—
If gb18030 third is not 0x00, run these substeps:
</p>

  <ol>
   <li>
%~cp ~LET ~NULL
â—
Let code point be null.
</li>

   <li>
~IFï¼»
%~byte ~IN { 0x30 ã€œ 0x39 }
ï¼½
â‡’
%~cp ~SET ï¼»
((( $gb18030-first âˆ’ 0x81 ) Ã— 10 + $gb18030-second âˆ’ 0x30 ) Ã— 126 + $gb18030-third âˆ’ 0x81 ) Ã— 10 + %~byte âˆ’ 0x30
ï¼½ãŒæŒ‡ã™$index-gb18030-ranges-code-point
â—
If byte is in the range 0x30 to 0x39, inclusive, set code point to the index gb18030 ranges code point for (((gb18030 first âˆ’ 0x81) Ã— 10 + gb18030 second âˆ’ 0x30) Ã— 126 + gb18030 third âˆ’ 0x81) Ã— 10 + byte âˆ’ 0x30.
</li>

   <li>
%buffer ~LET ~byteåˆ— [ $gb18030-first, $gb18030-second, %~byte ]
â—
Let buffer be a byte sequence consisting of gb18030 second, gb18030 third, and byte, in order.
</li>

   <li>
( $gb18030-first, $gb18030-second, $gb18030-third ) ~SET ( 0x00, 0x00, 0x00 )
â—
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>

   <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
%buffer ã‚’ %~stream $concept-stream-prepend ~BR
~RET $error
â—
If code point is null, prepend buffer to stream and return error.
</li>

   <li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>

  </ol>

 </li>

 <li>
<p>
~IFï¼»
$gb18030-second ~NEQ 0x00
ï¼½ï¼š
â—
If gb18030 second is not 0x00, run these substeps:
</p>

  <ol>
   <li>
~IFï¼»
%~byte ~IN { 0x81 ã€œ 0xFE }
ï¼½
â‡’
$gb18030-third ~SET %~byte ~BR
~RET $continue
â—
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 third to byte and return continue.
</li>

   <li>
~byteåˆ— [ $gb18030-second, %~byte ] ã‚’ %~stream $concept-stream-prepend ~BR
( $gb18030-first, $gb18030-second ) ~SET ( 0x00, 0x00 ) ~BR
~RET $error
â—
Prepend gb18030 second followed by byte to stream, set gb18030 first and gb18030 second to 0x00, and return error.
</li>

  </ol>

 </li>

 <li>
<p>
~IFï¼»
$gb18030-first ~NEQ 0x00
ï¼½ï¼š
â—
If gb18030 first is not 0x00, run these substeps:
</p>

  <ol>
   <li>
~IFï¼»
%~byte ~IN { 0x30 ã€œ 0x39 }
ï¼½
â‡’
$gb18030-second ~SET %~byte ~BR
~RET $continue
â—
If byte is in the range 0x30 to 0x39, inclusive, set gb18030 second to byte and return continue.
</li>

   <li>
%~lead ~LET $gb18030-first ~BR
%~pointer ~LET ~NULL ~BR
$gb18030-first ~SET 0x00
â—
Let lead be gb18030 first, let pointer be null, and set gb18030 first to 0x00.
</li>

   <li>
%~offset ~LET ï¼»
%~byte ~IN { 0x00 ã€œ 0x7E } ãªã‚‰ã° 0x40 ï¼
~ELSE_ 0x41
ï¼½
â—
Let offset be 0x40 if byte is less than 0x7F and 0x41 otherwise.
</li>

   <li>
~IFï¼»
%~byte ~IN { 0x40 ã€œ 0x7E, 0x80 ã€œ 0xFE }
ï¼½
â‡’
%~pointer ~SET ( %~lead âˆ’ 0x81 ) Ã— 190 + ( %~byte âˆ’ %~offset )
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 190 + (byte âˆ’ offset).
</li>

   <li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_
$index-gb18030 ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™$index-code-point
ï¼½
â—
Let code point be null if pointer is null and the index code point for pointer in index gb18030 otherwise.
</li>

   <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½~ANDï¼»
%~byte ~IN $ascii-byte
ï¼½
â‡’
%~byte ã‚’ %~stream $concept-stream-prepend
â—
If code point is null and byte is an ASCII byte, prepend byte to stream.
</li>

   <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET $error
â—
If code point is null, return error.
</li>

   <li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>

  </ol>

 </li>

 <li>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
â†“</p>

  <dl class="switch">
   <dt>$ascii-byte</dt>
   <dd>
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</dd>

   <dt>0x80</dt>
   <dd>
~RET ~cp [ U+20AC ]
â—
If byte is 0x80, return code point U+20AC.
</dd>

   <dt>0x81 ã€œ 0xFE</dt>
   <dd>
$gb18030-first ~SET %~byte ~BR
~RET $continue
â—
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 first to byte and return continue.
</dd>

   <dt>ãã®ä»–ï¼ˆ 0xFF ï¼‰</dt>
   <dd>
~RET $error
â—
Return error.
</dd>

  </dl>
 </li>
</ol>


			</section>
			<section id="gb18030-encoder">
<h4 title="gb18030 encoder">11.2.2. gb18030 ~encoder</h4>

<p>
$gb18030ã® $encoderã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
@gbk-flagï¼ˆåˆæœŸ~æ™‚ ~OFF ï¼‰
â—
gb18030's encoder has an associated GBK flag (initially unset).
</p>

<p>
$gb18030 ã®$encoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
gb18030's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
~IFï¼»
%~cp ~EQ $end-of-stream
ï¼½
â‡’
~RET $finished
â—
If code point is end-of-stream, return finished.
</li>

 <li>
~IFï¼»
%~cp ~IN $ascii-code-point
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
<p>
~IFï¼»
%~cp ~EQ U+E5E5
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†$error
â—
If code point is U+E5E5, return error with code point.
</p>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™æ¸ˆã¿ã®å†…å®¹ã¨ã®äº’æ›æ€§ã‚’ã¨ã‚‹ãŸã‚ã€ $index-gb18030 ã¯ï¼»
0xA3 0xA0
ï¼½ã‚’ U+E5E5 ã§ã¯ãªã U+3000 ã«å¯¾å¿œä»˜ã‘ã¦ã„ã‚‹ã€‚
ã—ãŸãŒã£ã¦å¾€æ¥ã§ããªã„ã€‚
â—
Index gb18030 maps 0xA3 0xA0 to U+3000 rather than U+E5E5 for compatibility with deployed content. Therefore it cannot roundtrip.
</p>

</li>

 <li>
~IFï¼»
$gbk-flag ~EQ ~ON
ï¼½~ANDï¼»
%~cp ~EQ U+20AC
ï¼½
â‡’
~RET ~byteåˆ— [ 0x80 ]
â—
If the GBK flag is set and code point is U+20AC, return byte 0x80.
</li>

 <li>
%~pointer ~LET
$index-gb18030 ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™$index-pointer
â—
Let pointer be the index pointer for code point in index gb18030.
</li>

 <li>
<p>
~IFï¼»
%~pointer ~NEQ ~NULL
ï¼½ï¼š
â—
If pointer is not null, run these substeps:
</p>

  <ol>
   <li>
%~lead ~LET floor( %~pointer Ã· 190 ) + 0x81
â—
Let lead be floor(pointer / 190) + 0x81.
</li>

   <li>
%~trail ~LET %~pointer % 190
â—
Let trail be pointer % 190.
</li>

   <li>
%~offset ~LET ï¼»
%~trail  ~IN { 0x00 ã€œ 0x3E } ãªã‚‰ã° 0x40<!--0x7F-0x40--> ï¼
~ELSE_ 0x41
ï¼½
â—
Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.
</li>

   <li>
~RET ~byteåˆ— [ %~lead, ( %~trail + %~offset ) ]
â—
Return two bytes whose values are lead and trail + offset.
</li>

  </ol>
 </li>

 <li>
~IFï¼»
$gbk-flag ~EQ ~ON
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†$error
â—
If GBK flag is set, return error with code point.
</li>

 <li>
%~pointer ~SET
%~cp
ã‚’æŒ‡ã™$index-gb18030-ranges-pointer
â—
Set pointer to the index gb18030 ranges pointer for code point.
</li>

 <li>
%byte1 ~LET floor( %~pointer Ã· 10 Ã· 126 Ã· 10 )
â—
Let byte1 be floor(pointer / 10 / 126 / 10).
</li>

 <li>
%~pointer ~SET %~pointer âˆ’ %byte1 Ã— 10 Ã— 126 Ã— 10
â—
Set pointer to pointer âˆ’ byte1 Ã— 10 Ã— 126 Ã— 10.
</li>

 <li>
%byte2 ~LET floor( %~pointer Ã· 10 Ã· 126 )
â—
Let byte2 be floor(pointer / 10 / 126).
</li>

 <li>
%~pointer ~SET %~pointer âˆ’ %byte2 Ã— 10 Ã— 126
â—
Set pointer to pointer âˆ’ byte2 Ã— 10 Ã— 126.
</li>

 <li>
%byte3 ~LET floor( %~pointer Ã· 10 )
â—
Let byte3 be floor(pointer / 10).
</li>

 <li>
%byte4 ~LET %~pointer âˆ’ %byte3 Ã— 10
â—
Let byte4 be pointer âˆ’ byte3 Ã— 10.
</li>

 <li>
~RET ~byteåˆ— [
( %byte1 + 0x81 ),
( %byte2 + 0x30 ),
( %byte3 + 0x81 ),
( %byte4 + 0x30 )
]
â—
Return four bytes whose values are byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(traditional)-encodings">

<h2 title="Legacy multi-byte Chinese (traditional) encodings">12. æ—§æ¥ã®è¤‡byte Chinese ï¼ˆç¹ä½“å­—ï¼‰~encoding</h2>

<!--
 Lead:  0x81 to 0xFE
 Trail: 0x40 to 0x7E or 0xA1 to 0xFE
-->


		<section id="big5">

<h3 title="Big5">12.1. <b>Big5</b></h3>

			<section id="big5-decoder">
<h4 title="Big5 decoder">12.1.1. Big5 ~decoder</h4>

<div class="p">
<p>
$big5 ã®$decoderã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
@big5-leadï¼ˆåˆæœŸ~æ™‚ 0x00 ï¼‰
</p>
<p>
$big5 ã®$decoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
</p>
â—
Big5's decoder has an associated Big5 lead (initially 0x00). Big5's decoder's handler, given a stream and byte, runs these steps:
</div>

<ol>
 <li>
<p>
~IFï¼»
%~byte ~EQ $end-of-stream
ï¼½ï¼š
â—
â†“</p>

  <ol>
   <li>
~IFï¼»
$big5-lead ~NEQ 0x00
ï¼½
â‡’
$big5-lead ~SET 0x00 ~BR
~RET $error
â—
If byte is end-of-stream and Big5 lead is not 0x00, set Big5 lead to 0x00 and return error.
</li>

   <li>
~RET $finished
â—
If byte is end-of-stream and Big5 lead is 0x00, return finished.
</li>

  </ol>
 </li>

 <li>
<p>
~IFï¼»
$big5-lead ~NEQ 0x00
ï¼½ï¼š
â—
If Big5 lead is not 0x00, let lead be Big5 lead, let pointer be null, set Big5 lead to 0x00, and then run these substeps:
</p>

  <ol>
   <li>
%~lead ~LET $big5-lead ~BR
%~pointer ~LET ~NULL ~BR
$big5-lead ~SET 0x00
â—
â†‘</li>

   <li>
%~offset ~LET ï¼»
%~byte ~IN { 0x00 ã€œ 0x7E } ãªã‚‰ã° 0x40 ï¼
~ELSE_ 0x62 <!-- 0x62 = 0xA1-0x7E+1+0x40 -->
ï¼½
â—
Let offset be 0x40 if byte is less than 0x7F and 0x62 otherwise.
</li>

   <li>
~IFï¼»
%~byte ~IN { 0x40 ã€œ 0x7E, 0xA1 ã€œ 0xFE }
ï¼½
â‡’
%~pointer ~SET ( %~lead âˆ’ 0x81 ) Ã— 157 + ( %~byte âˆ’ %~offset )
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 157 + (byte âˆ’ offset).
</li>

   <li>
<p>
~IFï¼»
ä¸‹ã®è¡¨ã®ä¸­ã§ï¼Œ 1 åˆ—ç›®ãŒ %~pointer ã«ç­‰ã—ã„è¡ŒãŒã‚ã‚‹
ï¼½
â‡’
~RET åŒã˜è¡Œã® 2 åˆ—ç›®ã® <em>2 å€‹ã®</em> ~cpã‹ã‚‰ãªã‚‹$concept-tokenåˆ—
â—
If there is a row in the table below whose first column is pointer, return the two code points listed in its second column (the third column is irrelevant):
</p>

<!-- http://www.unicode.org/Public/UNIDATA/NamedSequences.txt -->
<table><thead><tr><th>~pointerâ—Pointer
</th><th>~cpâ—Code points
</th><th>èª¬æ˜ï¼ˆã“ã®æ®µã«ã¯ç„¡é–¢ä¿‚ï¼‰â—Notes
</th></tr></thead>

<tbody><tr><td>1133<!-- 0x88 0x62 -->
</td><td>U+00CA U+0304
</td><td>ÃŠÌ„ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON)

</td></tr><tr><td>1135<!-- 0x88 0x64 -->
</td><td>U+00CA U+030C
</td><td>ÃŠÌŒ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON)

</td></tr><tr><td>1164<!-- 0x88 0xA3 -->
</td><td>U+00EA U+0304
</td><td>ÃªÌ„ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON)

</td></tr><tr><td>1166<!-- 0x88 0xA5 -->
</td><td>U+00EA U+030C
</td><td>ÃªÌŒ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON)

</td></tr></tbody></table>
<!-- we do this to avoid PUA -->


<p class="note">æ³¨è¨˜ï¼š
$index ã¯å˜ç‹¬ã®~cpã«åˆ¶é™ã•ã‚Œã‚‹ã®ã§ã€ã“ã‚Œã‚‰ã®~pointerã«ã¯ã“ã®è¡¨ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
â—
Since indexes are limited to single code points this table is used for these pointers.
</li>

   <li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ $index-big5 ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™$index-code-point
ï¼½
â—
Let code point be null if pointer is null and the index code point for pointer in index Big5 otherwise.
</li>

   <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½~ANDï¼»
%~byte ~IN $ascii-byte
ï¼½
â‡’
%~byte ã‚’ %~stream $concept-stream-prepend
â—
If code point is null and byte is an ASCII byte, prepend byte to stream.
</li>

   <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET $error
â—
If code point is null, return error.
</li>

   <li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>

  </ol>

 </li>

 <li>
~IFï¼»
%~byte ~IN $ascii-byte
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>

 <li>
~IFï¼»
%~byte ~IN { 0x81 ã€œ 0xFE }
ï¼½
â‡’
$big5-lead ~SET %~byte ~BR
~RET $continue
â—
If byte is in the range 0x81 to 0xFE, inclusive, set Big5 lead to byte and return continue.
</li>

 <li>
~RET $error
â—
Return error.
</li>
</ol>

			</section>
			<section id="big5-encoder">
<h4 title="Big5 encoder">12.1.2. Big5 ~encoder</h4>

<p>
$big5 ã®$encoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Big5's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
~IFï¼»
%~cp ~EQ $end-of-stream
ï¼½
â‡’
~RET $finished
â—
If code point is end-of-stream, return finished.
</li>

 <li>
~IFï¼»
%~cp ~IN $ascii-code-point
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
%~pointer ~LET %~cp ã‚’æŒ‡ã™$index-big5-pointer
â—
Let pointer be the index Big5 pointer for code point.
</li>

 <li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†$error
â—
If pointer is null, return error with code point.
</li>

 <li>
%~lead ~LET floor( %~pointer Ã· 157 ) + 0x81
â—
Let lead be floor(pointer / 157) + 0x81.
</li>

 <li>
%~trail ~LET %~pointer % 157
â—
Let trail be pointer % 157.
</li>

 <li>
%~offset ~LET ï¼»
%~trail ~IN { 0x00 ã€œ 0x3E } ãªã‚‰ã° 0x40<!--0x7F-0x40--> ï¼
~ELSE_ 0x62<!--0xA1-0x3F-->
ï¼½
â—
Let offset be 0x40 if trail is less than 0x3F and 0x62 otherwise.
</li>

 <li>
~RET ~byteåˆ— [ %~lead, ( %~trail + %~offset) ]
â—
Return two bytes whose values are lead and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-japanese-encodings">

<h2 title="Legacy multi-byte Japanese encodings">13. æ—§æ¥ã®è¤‡byte Japanese ~encoding</h2>


		<section id="euc-jp">

<h3 title="EUC-JP">13.1. <b>EUC-JP</b></h3>

<!-- https://www.iana.org/assignments/charset-reg/CP51932 -->

			<section id="euc-jp-decoder">
<h4 title="EUC-JP decoder">13.1.1. EUC-JP ~decoder</h4>

<p>
$euc-jp ã®$decoderã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
@euc-jp-jis0212-flagï¼ˆåˆæœŸ~æ™‚ ~OFF ï¼‰~BR
@euc-jp-leadï¼ˆåˆæœŸ~æ™‚ 0x00ï¼‰
â—
EUC-JP's decoder has an associated EUC-JP jis0212 flag (initially unset) and EUC-JP lead (initially 0x00).
</p>

<p>
$euc-jp ã®$decoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-JP's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
~IFï¼»
%~byte ~EQ $end-of-stream
ï¼½ï¼š
â—
â†“</p>

  <ol >
   <li>
~IFï¼»
$euc-jp-lead ~NEQ 0x00
ï¼½
â‡’
$euc-jp-lead ~SET 0x00 ~BR
~RET $error
â—
If byte is end-of-stream and EUC-JP lead is not 0x00, set EUC-JP lead to 0x00, and return error.
</li>

   <li>
~ELSE
â‡’
~RET $finished
â—
If byte is end-of-stream and EUC-JP lead is 0x00, return finished.
</li>
  </ol>
 </li>

 <li>
~IFï¼»
$euc-jp-lead ~EQ 0x8E
ï¼½~ANDï¼»
%~byte ~IN { 0xA1 ã€œ 0xDF }
ï¼½
â‡’
$euc-jp-lead ~SET 0x00 ~BR
~RET ~cp [ 0xFF61 âˆ’ 0xA1 + %~byte ]
   <!-- katakana; subtraction is done first to avoid upsetting compilers -->
â—
If EUC-JP lead is 0x8E and byte is in the range 0xA1 to 0xDF, inclusive, set EUC-JP lead to 0x00 and return a code point whose value is 0xFF61 âˆ’ 0xA1 + byte.
</li>

 <li>
~IFï¼»
$euc-jp-lead ~EQ 0x8F
ï¼½~ANDï¼»
%~byte ~IN { 0xA1 ã€œ 0xFE }
ï¼½
â‡’
$euc-jp-jis0212-flag ~SET ~ON ~BR
$euc-jp-lead ~SET %~byte ~BR
~RET $continue
â—
If EUC-JP lead is 0x8F and byte is in the range 0xA1 to 0xFE, inclusive, set the EUC-JP jis0212 flag, set EUC-JP lead to byte, and return continue.
</li>

 <li>
<p>
~IFï¼»
$euc-jp-lead ~NEQ 0x00
ï¼½ï¼š
â—
If EUC-JP lead is not 0x00, let lead be EUC-JP lead, set EUC-JP lead to 0x00, and run these substeps:
</p>

  <ol>
   <li>
%~lead ~LET $euc-jp-lead ~BR
$euc-jp-lead ~SET 0x00
â—
â†‘</li>

   <li>
%~cp ~LET ~NULL
â—
Let code point be null.
</li>

   <li>
~IFï¼»
%~lead, %~byte ãŒã„ãšã‚Œã‚‚ ~IN { 0xA1 ã€œ 0xFE }
ï¼½
â‡’
%ç´¢å¼• ~LET ï¼»
$euc-jp-jis0212-flag ~EQ ~OFF ãªã‚‰ã°$index-jis0208 ï¼
~ON ãªã‚‰ã°ï¼»
$index-jis0212
ï¼½~BR
%~cp ~SET %ç´¢å¼• ã®ä¸­ã§
( ( %~lead âˆ’ 0xA1 ) Ã— 94 + %~byte âˆ’ 0xA1 )
ãŒæŒ‡ã™$index-code-point
â—
If lead and byte are both in the range 0xA1 to 0xFE, inclusive, set code point to the index code point for (lead âˆ’ 0xA1) Ã— 94 + byte âˆ’ 0xA1 in index jis0208 if the EUC-JP jis0212 flag is unset and in index jis0212 otherwise.
</li>

   <li>
$euc-jp-jis0212-flag ~SET ~OFF
â—
Unset the EUC-JP jis0212 flag.
</li>

   <li>
~IFï¼»
%~byte ~NIN { 0xA1 ã€œ 0xFE }
ï¼½
â‡’
%~byte ã‚’ %~stream $concept-stream-prepend
â—
If byte is not in the range 0xA1 to 0xFE, inclusive, prepend byte to stream.
</li>

   <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET $error
â—
If code point is null, return error.
</li>

   <li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>

  </ol>

 </li>

 <li>
~IFï¼»
%~byte ~IN $ascii-byte
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>

 <li>
~IFï¼»
%~byte ~IN { 0x8E, 0x8F, 0xA1 ã€œ 0xFE }
ï¼½
â‡’
$euc-jp-lead ~SET %~byte ~BR
~RET $continue
â—
If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE, inclusive, set EUC-JP lead to byte and return continue.
</li>

 <li>
~RET $error
â—
Return error.
</li>

</ol>


			</section>
			<section id="euc-jp-encoder">
<h4 title="EUC-JP encoder">13.1.2. EUC-JP ~encoder</h4>

<p>
$euc-jp ã®$encoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-JP's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
<p>
%~cp ã«å¿œã˜ã¦ï¼š
â—
â†“</p>
  <dl class="switch">
   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
â—
If code point is end-of-stream, return finished.
</dd>

   <dt>$ascii-code-point</dt>
   <dd>
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

   <dt>U+00A5</dt>
   <dd>
~RET ~byteåˆ— [ 0x5C ]
â—
If code point is U+00A5, return byte 0x5C.
</dd>

   <dt>U+203E</dt>
   <dd>
~RET ~byteåˆ— [ 0x7E ]
â—
If code point is U+203E, return byte 0x7E.
</dd>

   <dt>U+FF61 ã€œ U+FF9F</dt>
   <dd>
~RET ~byteåˆ— [ 0x8E, ( %~cp âˆ’ 0xFF61 + 0xA1 ) ]
â—
If code point is in the range U+FF61 to U+FF9F, inclusive, return two bytes whose values are 0x8E and code point âˆ’ 0xFF61 + 0xA1.
</dd>

   <dt>~OTHER</dt>
   <dd>ä½•ã‚‚ã—ãªã„</dd>
  </dl>
 </li>

 <li>
~IFï¼»
%~cp ~EQ U+2212
ï¼½
â‡’
%~cp ~SET U+FF0D
â—
If code point is U+2212, set it to U+FF0D.
</li>

 <li>
%~pointer ~LET $index-jis0208 ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™$index-pointer
â—
Let pointer be the index pointer for code point in index jis0208.
</li>

 <li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†$error
â—
If pointer is null, return error with code point.
</li>

 <li>
%~lead ~LET floor( %~pointer Ã· 94 ) + 0xA1
â—
Let lead be floor(pointer / 94) + 0xA1.
</li>

 <li>
%~trail ~LET ( %~pointer % 94 ) + 0xA1
â—
Let trail be pointer % 94 + 0xA1.
</li>

 <li>
~RET ~byteåˆ— [ %~lead, %~trail ]
â—
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="iso-2022-jp">

<h3 title="ISO-2022-JP">13.2. <b>ISO-2022-JP</b></h3>

<!--
 https://tools.ietf.org/html/rfc1468
 https://tools.ietf.org/html/rfc2237 (iso-2022-jp-1; not used)
 "ESC ) I" is from iso-2022-jp-3 reportedly
-->

			<section id="iso-2022-jp-decoder">
<h4 title="ISO-2022-JP decoder">13.2.1. ISO-2022-JP ~decoder</h4>

<p>
$iso-2022-jp ã®$decoderã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
@iso-2022-jp-decoder-stateï¼ˆåˆæœŸ~æ™‚ $iso-2022-jp-decoder-asciiï¼‰~BR
@iso-2022-jp-decoder-output-stateï¼ˆåˆæœŸ~æ™‚ $iso-2022-jp-decoder-ascii ï¼‰~BR
@iso-2022-jp-leadï¼ˆåˆæœŸ~æ™‚ 0x00 ï¼‰~BR
@iso-2022-jp-output-flagï¼ˆåˆæœŸ~æ™‚ ~OFF ï¼‰
â—
ISO-2022-JP's decoder has an associated ISO-2022-JP decoder state (initially ASCII), ISO-2022-JP decoder output state (initially ASCII), ISO-2022-JP lead (initially 0x00), and ISO-2022-JP output flag (initially unset).
</p>

<p>
$iso-2022-jp ã®$decoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œ$iso-2022-jp-decoder-stateã«å¿œã˜ã¦ æ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
ISO-2022-JP's decoder's handler, given a stream and byte, runs these steps, switching on ISO-2022-JP decoder state:
</p>

<dl class="switch">
 <dt>@iso-2022-jp-decoder-ascii</dt>
 <dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>

  <dl class="switch">
   <dt>0x1B</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape-start ~BR
~RET $continue
â—
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

   <dt>$ascii-byte â€” ãŸã ã—ï¼Œ 0x0E, 0x0F, 0x1B ã¯é™¤ã</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET ~cp [ %~byte ]
â—
Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</dd>

   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
â—
Return finished.
</dd>

   <dt>~OTHER</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET $error
â—
Unset the ISO-2022-JP output flag and return error.
</dd>
  </dl>
 </dd>

 <dt>@iso-2022-jp-decoder-roman</dt>
 <dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>

  <dl class="switch">
   <dt>0x1B</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape-start ~BR
~RET $continue
â—
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

   <dt>0x5C</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET ~cp [ U+00A5 ]
â—
Unset the ISO-2022-JP output flag and return code point U+00A5.
</dd>

   <dt>0x7E</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET ~cp [ U+203E ]
â—
Unset the ISO-2022-JP output flag and return code point U+203E.
</dd>

   <dt>$ascii-byte â€” ãŸã ã—ï¼Œ 0x0E, 0x0F, 0x1B, 0x5C, 0x7E ã¯é™¤ã</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET a ~cp [ %~byte ]
â—
Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</dd>

   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
â—
Return finished.
</dd>

   <dt>~OTHER</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET $error
â—
Unset the ISO-2022-JP output flag and return error.
</dd>
  </dl>
 </dd>

 <dt>@iso-2022-jp-decoder-katakana</dt>
 <dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>

  <dl class="switch">
   <dt>0x1B</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape-start ~BR
~RET $continue
â—
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

   <dt>0x21 ã€œ 0x5F</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET ~cp [ 0xFF61 âˆ’ 0x21 + %~byte ]
   <!-- katakana; subtraction is done first to avoid upsetting compilers -->
â—
Unset the ISO-2022-JP output flag and return a code point whose value is 0xFF61 âˆ’ 0x21 + byte.
</dd>

   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
â—
Return finished.
</dd>

   <dt>~OTHER</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET $error
â—
Unset the ISO-2022-JP output flag and return error.
</dd>
  </dl>
 </dd>

 <dt>@iso-2022-jp-decoder-lead-byte</dt>
 <dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>

  <dl class="switch">
   <dt>0x1B</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape-start ~BR
~RET $continue
â—
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

   <dt>0x21 ã€œ 0x7E</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
$iso-2022-jp-lead ~SET %~byte ~BR
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-trail-byte ~BR
~RET $continue
â—
Unset the ISO-2022-JP output flag, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to trail byte, and return continue.
</dd>

   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
â—
Return finished.
</dd>

   <dt>~OTHER</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET $error
â—
Unset the ISO-2022-JP output flag and return error.
</dd>
  </dl>
 </dd>

 <dt>@iso-2022-jp-decoder-trail-byte</dt>
 <dd>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
Based on byte:
</p>

  <dl class="switch">
   <dt>0x1B</dt>
   <dd>
<p>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape-start ~BR
~RET $error
<!-- iso-2022-jp decoder output state is still lead byte -->
â—
Set ISO-2022-JP decoder state to escape start and return error.
</p>

   <dt>0x21 ã€œ 0x7E</dt>
   <dd>
    <ol>
     <li>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-lead-byte
â—
Set the ISO-2022-JP decoder state to lead byte.
</li>

     <li>
%pointer ~LET ( $iso-2022-jp-lead âˆ’ 0x21 ) Ã— 94 + %~byte âˆ’ 0x21
â—
Let pointer be (ISO-2022-JP lead âˆ’ 0x21) Ã— 94 + byte âˆ’ 0x21.
</li>
     <li>
%~cp ~LET
$index-jis0208 ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™$index-code-point
â—
Let code point be the index code point for pointer in index jis0208.
</li>
     <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET $error
â—
If code point is null, return error.
</li>
     <li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
    </ol>
   </dd>

   <dt>$end-of-stream</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-lead-byte ~BR
%~byte ã‚’ %~stream $concept-stream-prepend ~BR
~RET $error
â—
Set the ISO-2022-JP decoder state to lead byte, prepend byte to stream, and return error.
</dd>

   <dt>~OTHER</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-lead-byte ~BR
~RET $error
<!-- iso-2022-jp decoder output state is still lead byte -->
â—
Set ISO-2022-JP decoder state to lead byte and return error.
</dd>
  </dl>
 </dd>

 <dt>@iso-2022-jp-decoder-escape-start</dt>
 <dd>
  <ol>
   <li>
~IFï¼»
%~byte ~IN { 0x24<!--ï¼„-->, 0x28<!--(--> }
ï¼½
â‡’
$iso-2022-jp-lead ~SET %~byte ~BR
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape ~BR
~RET $continue
â—
If byte is either 0x24 or 0x28, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to escape, and return continue.
</li>

   <li>
%~byte ã‚’ %~stream $concept-stream-prepend
â—
Prepend byte to stream.
</li>

   <li>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-output-state ~BR
~RET $error
â—
Unset the ISO-2022-JP output flag, set ISO-2022-JP decoder state to ISO-2022-JP decoder output state, and return error.
</li>
  </ol>
 </dd>

 <dt>@iso-2022-jp-decoder-escape</dt>
 <dd>
  <ol>
   <li>
%~lead ~LET $iso-2022-jp-lead ~BR
$iso-2022-jp-lead ~SET 0x00
â—
Let lead be ISO-2022-JP lead and set ISO-2022-JP lead to 0x00.
</li>

   <li>
%çŠ¶æ…‹ ~LET ~NULL
â—
Let state be null.
</li>

   <li>
~IFï¼»
%~lead ~EQ 0x28
ï¼½~ANDï¼»
%~byte ~EQ 0x42<!--B-->
ï¼½
â‡’
%çŠ¶æ…‹ ~SET $iso-2022-jp-decoder-ascii
â—
If lead is 0x28 and byte is 0x42, set state to ASCII.
</li>

   <li>
~IFï¼»
%~lead ~EQ 0x28
ï¼½~ANDï¼»
%~byte ~EQ 0x4A<!--J-->
ï¼½
â‡’
%çŠ¶æ…‹ ~SET $iso-2022-jp-encoder-roman
â—
If lead is 0x28 and byte is 0x4A, set state to Roman.
</li>

   <li>
~IFï¼»
%~lead ~EQ 0x28
ï¼½~ANDï¼»
%~byte ~EQ 0x49<!--I-->
ï¼½
â‡’
%çŠ¶æ…‹ ~SET $iso-2022-jp-decoder-katakana
â—
If lead is 0x28 and byte is 0x49, set state to Katakana.
</li>

   <li>
~IFï¼»
%~lead ~EQ 0x24
ï¼½~ANDï¼»
%~byte ~IN { 0x40<!--ï¼ -->, 0x42<!--B--> }
ï¼½
â‡’
%çŠ¶æ…‹ ~SET $iso-2022-jp-decoder-lead-byte
â—
If lead is 0x24 and byte is either 0x40 or 0x42, set state to lead byte.
</li>

   <li>
<p>
~IFï¼»
%çŠ¶æ…‹ ~NEQ ~NULL
ï¼½ï¼š
â—
If state is non-null, run these substeps:
</p>

    <ol>
     <li>
$iso-2022-jp-decoder-state ~SET %çŠ¶æ…‹ ~BR
$iso-2022-jp-decoder-output-state ~SET %çŠ¶æ…‹
â—
Set ISO-2022-JP decoder state and ISO-2022-JP decoder output state to state.
</li>

     <li>
%å‡ºåŠ›~flag ~LET $iso-2022-jp-output-flag
â—
Let output flag be the ISO-2022-JP output flag.
</li>

     <li>
$iso-2022-jp-output-flag ~SET ~ON
â—
Set the ISO-2022-JP output flag.
</li>

     <li>
~RET ï¼»
%å‡ºåŠ›~flag ~EQ ~OFF ãªã‚‰ã° $continue ï¼
~ELSE_ $error
ï¼½
â—
Return continue, if output flag is unset, and error otherwise.
</li>
    </ol>
   </li>

   <li>
~byteåˆ— [ %~lead, %~byte ] ã‚’ %~stream $concept-stream-prepend
â—
Prepend lead and byte to stream.
</li>

   <li>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-output-state ~BR
~RET $error
â—
Unset the ISO-2022-JP output flag, set ISO-2022-JP decoder state to ISO-2022-JP decoder output state and return error.
</li>
  </ol>
 </dd>
</dl>

			</section>
			<section id="iso-2022-jp-encoder">
<h4 title="ISO-2022-JP encoder">13.2.2. ISO-2022-JP ~encoder</h4>

<p>
$iso-2022-jp ã®$encoderã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
@iso-2022-jp-encoder-state
â€” ã“ã‚Œã¯ï¼Œï¼»
@iso-2022-jp-encoder-ascii ï¼
@iso-2022-jp-encoder-roman ï¼
@iso-2022-jp-encoder-jis0208
ï¼½ã®ã„ãšã‚Œã‹ã‚’ã¨ã‚Šå¾—ã‚‹ï¼ˆåˆæœŸ~æ™‚ $iso-2022-jp-encoder-ascii ï¼‰ã€‚
â—
ISO-2022-JP's encoder has an associated ISO-2022-JP encoder state which is ASCII, Roman, or jis0208 (initially ASCII).
</p>

<p>
$iso-2022-jp ã®$encoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
ISO-2022-JP's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
<p>
~IFï¼»
%~cp ~EQ $end-of-stream
ï¼½ï¼š
â—
â†“</p>

  <ol>
   <li>
~IFï¼»
$iso-2022-jp-encoder-state ~NEQ $iso-2022-jp-encoder-ascii
ï¼½
â‡’
%~cp ã‚’ %~stream $concept-stream-prepend ~BR
$iso-2022-jp-encoder-state ~SET $iso-2022-jp-encoder-ascii ~BR
~RET ~byteåˆ— [ 0x1B, 0x28, 0x42 ]
â—
If code point is end-of-stream and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>

   <li>
~RET $finished
â—
If code point is end-of-stream and ISO-2022-JP encoder state is ASCII, return finished.
</li>
  </ol>
 </li>

 <li>
<p>
~IFï¼»
$iso-2022-jp-encoder-state ~IN
{ $iso-2022-jp-encoder-ascii, $iso-2022-jp-encoder-roman }
ï¼½~ANDï¼»
%~cp ~IN { U+000E, U+000F, U+001B }
ï¼½
â‡’
~RET U+FFFD ã‚’ä¼´ã†$error
â—
If ISO-2022-JP encoder state is ASCII or Roman, and code point is U+000E, U+000F, or U+001B, return error with U+FFFD.
</p>

<p class="note">
æ”»æ’ƒã‚’é˜²ããŸã‚ã€ã“ã‚Œã¯ %~cp ã§ã¯ãªãï¼Œ U+FFFD ã‚’è¿”ã™ã€‚
â—
This returns U+FFFD rather than the code point to prevent attacks.
</p>
  <!-- https://github.com/whatwg/encoding/issues/15 -->

 <li>
~IFï¼»
$iso-2022-jp-encoder-state ~EQ $iso-2022-jp-encoder-ascii
ï¼½~ANDï¼»
%~cp ~IN $ascii-code-point
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If ISO-2022-JP encoder state is ASCII and code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
<p>
~IFï¼»
$iso-2022-jp-encoder-state ~EQ $iso-2022-jp-encoder-roman
ï¼½
â‡’
%~cp ã«å¿œã˜ã¦ï¼š
â—
If ISO-2022-JP encoder state is Roman and code point is an ASCII code point, excluding U+005C and U+007E, or is U+00A5 or U+203E, run these substeps:
</p>

  <dl class="switch">
   <dt>$ascii-code-point â€” ãŸã ã—ï¼Œ U+005C, U+007E ã¯é™¤å¤–ã™ã‚‹</dt>
   <dd>
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

   <dt>U+00A5</dt>
   <dd>
~RET ~byteåˆ— [ 0x5C ]
â—
If code point is U+00A5, return byte 0x5C.
</dd>

   <dt>U+203E</dt>
   <dd>
~RET ~byteåˆ— [ 0x7E ]
â—
If code point is U+203E, return byte 0x7E.
</dd>

   <dt>~OTHER</dt>
   <dd>ä½•ã‚‚ã—ãªã„</dd>
  </dl>
 </li>

 <li>
~IFï¼»
%~cp ~IN $ascii-code-point
ï¼½~ANDï¼»
$iso-2022-jp-encoder-state ~NEQ $iso-2022-jp-encoder-ascii
ï¼½
â‡’
%~cp ã‚’ %~stream $concept-stream-prepend ~BR
$iso-2022-jp-encoder-state ~SET $iso-2022-jp-encoder-ascii ~BR
~RET ~byteåˆ— [ 0x1B, 0x28, 0x42 ]
â—
If code point is an ASCII code point, and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>

 <li>
~IFï¼»
%~cp ~NIN { U+00A5, U+203E }
ï¼½~ANDï¼»
$iso-2022-jp-encoder-state ~NEQ $iso-2022-jp-encoder-roman
ï¼½
â‡’
%~cp ã‚’ %~stream $concept-stream-prepend ~BR
$iso-2022-jp-encoder-state ~SET $iso-2022-jp-encoder-roman ~BR
~RET ~byteåˆ— [ 0x1B, 0x28, 0x4A ]
â—
If code point is either U+00A5 or U+203E, and ISO-2022-JP encoder state is not Roman, prepend code point to stream, set ISO-2022-JP encoder state to Roman, and return three bytes 0x1B 0x28 0x4A.
</li>

 <li>
~IFï¼»
%~cp ~EQ U+2212
ï¼½
â‡’
%~cp ~SET U+FF0D
â—
If code point is U+2212, set it to U+FF0D.
</li>

 <li>
%~pointer ~LET
$index-jis0208 ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™$index-pointer
â—
Let pointer be the index pointer for code point in index jis0208.
</li>

 <li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†$error
â—
If pointer is null, return error with code point.
</li>

 <li>
~IFï¼»
$iso-2022-jp-encoder-state ~NEQ $iso-2022-jp-encoder-jis0208
ï¼½
â‡’
%~cp ã‚’ %~stream $concept-stream-prepend ~BR
$iso-2022-jp-encoder-state ~SET $iso-2022-jp-encoder-jis0208 ~BR
~RET ~byteåˆ— [ 0x1B, 0x24, 0x42 ]
â—
If ISO-2022-JP encoder state is not jis0208, prepend code point to stream, set ISO-2022-JP encoder state to jis0208, and return three bytes 0x1B 0x24 0x42.
</li>

 <li>
%~lead ~LET floor( %~pointer Ã· 94 ) + 0x21
â—
Let lead be floor(pointer / 94) + 0x21.
</li>

 <li>
%~trail ~LET ( %~pointer % 94 ) + 0x21
â—
Let trail be pointer % 94 + 0x21.
</li>

 <li>
~RET ~byteåˆ— [ %~lead, %~trail ]
â—
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="shift_jis">

<h3 title="Shift_JIS">13.3. <b>Shift_JIS</b></h3>


			<section id="shift_jis-decoder">
<h4 title="Shift_JIS decoder">13.3.1. Shift_JIS ~decoder</h4>


<p>
$shift_jis ã®$decoderã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
@shift_jis-leadï¼ˆåˆæœŸ~æ™‚ 0x00 ï¼‰
â—
Shift_JIS's decoder has an associated Shift_JIS lead (initially 0x00).
</p>

<p>
$shift_jis ã®$decoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Shift_JIS's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
~IFï¼»
%~byte ~EQ $end-of-stream
ï¼½ï¼š
â—
â†“</p>

  <ol>
   <li>
~IFï¼»
$shift_jis-lead ~NEQ 0x00
ï¼½
â‡’
$shift_jis-lead ~SET 0x00 ~BR
~RET $error
â—
If byte is end-of-stream and Shift_JIS lead is not 0x00, set Shift_JIS lead to 0x00 and return error.
</li>

   <li>
~ELSE
â‡’
~RET $finished
â—
If byte is end-of-stream and Shift_JIS lead is 0x00, return finished.
</li>

  </ol>
 </li>

 <li>
<p>
~IFï¼»
$shift_jis-lead ~NEQ 0x00
ï¼½ï¼š
â—
If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead, let pointer be null, set Shift_JIS lead to 0x00, and then run these substeps:
</p>

  <ol>
   <li>
%~lead ~LET $shift_jis-lead ~BR
%~pointer ~LET ~NULL ~BR
$shift_jis-lead ~SET 0x00
â—
â†‘</li>

   <li>
%~offset ~LET ï¼»
%~byte ~IN { 0x00 ã€œ 0x7E } ãªã‚‰ã° 0x40 ï¼
~ELSE_ 0x41
ï¼½
â—
Let offset be 0x40, if byte is less than 0x7F, and 0x41 otherwise.
</li>

   <li>
%~lead~offset ~LET ï¼»
%~lead ~IN { 0x00 ã€œ 0xBF } ãªã‚‰ã° 0x81 ï¼
~ELSE_ 0xC1
ï¼½
â—
Let lead offset be 0x81, if lead is less than 0xA0, and 0xC1 otherwise.
</li>

   <li>
~IFï¼»
%~byte ~IN { 0x40 ã€œ 0x7E, 0x80 ã€œ 0xFC }
ï¼½
â‡’
%~pointer ~SET ( %~lead âˆ’ %~lead~offset ) Ã— 188 + %~byte âˆ’ %~offset
â—
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFC, inclusive, set pointer to (lead âˆ’ lead offset) Ã— 188 + byte âˆ’ offset.
</li>
   <li>
<p>
~IFï¼»
%~pointer ~IN { 8836 ã€œ 10715 }
ï¼½
â‡’
~RET ~cp [ 0xE000 âˆ’ 8836 + %~pointer ]
<!-- subtraction is done first to avoid upsetting compilers -->
â—
If pointer is in the range 8836 to 10715, inclusive, return a code point whose value is 0xE000 âˆ’ 8836 + pointer.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ EUDC ã¨ã—ã¦å‘¨çŸ¥ã®ï¼Œæ—§æ¥ã® Windows ã«ã‚ˆã‚‹ã‚‚ã®ã¨ç›¸äº’é‹ç”¨å¯èƒ½ã«ã™ã‚‹ã€‚
<!-- PUA -->
â—
This is interoperable legacy from Windows known as EUDC.
</p>


<p class="trans-note">ã€
EUDC â€” ã„ã‚ã‚†ã‚‹å¤–å­—ã®ãŸã‚ã®æ©Ÿèƒ½ã€‚
ã€‘ã€
8836 = 94 Ã— 94 ã¯ Shift_JISï¼ˆ JIS X 0208 ï¼‰ã®
<a href="http://ja.wikipedia.org/wiki/%E5%8C%BA%E7%82%B9%E7%95%AA%E5%8F%B7" >åŒºç‚¹ç•ªå·</a>
ã®ç·æ•°ã€‚
çµæœã®~cpã¯ Unicode ç§ç”¨é ˜åŸŸã«å…¥ã‚‹ã€‚
ã€‘</p>

   </li>

   <li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ $index-jis0208 ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™$index-code-point
ï¼½
â—
Let code point be null, if pointer is null, and the index code point for pointer in index jis0208 otherwise.
</li>

   <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½~ANDï¼»
%~byte ~IN $ascii-byte
ï¼½
â‡’
%~byte ã‚’ %~stream $concept-stream-prepend
â—
If code point is null and byte is an ASCII byte, prepend byte to stream.
</li>

   <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET $error
â—
If code point is null, return error.
</li>

   <li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>

  </ol>

 </li>

 <li>
~IFï¼»
%~byte ~IN { $ascii-byte, 0x80}
ï¼½
â‡’
~RET ~cp [ %~byte ]
<!-- Opera has 0x7E -->
â—
If byte is an ASCII byte or 0x80, return a code point whose value is byte.
</li>

 <li>
~IFï¼»
%~byte ~IN { 0xA1 ã€œ 0xDF }
ï¼½
â‡’
~RET ~cp [ 0xFF61 âˆ’ 0xA1 + %~byte ]
 <!-- katakana; subtraction is done first to avoid upsetting compilers -->
â—
If byte is in the range 0xA1 to 0xDF, inclusive, return a code point whose value is 0xFF61 âˆ’ 0xA1 + byte.
</li>

 <li>
~IFï¼»
%~byte ~IN { 0x81 ã€œ 0x9F, 0xE0 ã€œ 0xFC }
ï¼½
â‡’
$shift_jis-lead ~SET %~byte ~BR
~RET $continue
â—
If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0 to 0xFC, inclusive, set Shift_JIS lead to byte and return continue.
</li>

 <li>
~RET $error
â—
Return error.
</li>
</ol>

			</section>
			<section id="shift_jis-encoder">
<h4 title="Shift_JIS encoder">13.3.2. Shift_JIS ~encoder</h4>

<p>
$shift_jis ã®$encoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
Shift_JIS's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
<p>
%~cp ã«å¿œã˜ã¦ï¼š
â—
â†“</p>
  <dl class="switch">
   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
â—
If code point is end-of-stream, return finished.
</dd>

   <dt>$ascii-code-point</dt>
   <dt>U+0080</dt>
   <dd>
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point or U+0080, return a byte whose value is code point.
</dd>

   <dt>U+00A5</dt>
   <dd>
~RET ~byteåˆ— [ 0x5C ]
â—
If code point is U+00A5, return byte 0x5C.
</dd>

   <dt>U+203E</dt>
   <dd>
~RET ~byteåˆ— [ 0x7E ]
â—
If code point is U+203E, return byte 0x7E.
</dd>

   <dt>U+FF61 ã€œ U+FF9F</dt>
   <dd>
~RET ~byteåˆ— [ %~cp âˆ’ 0xFF61 + 0xA1 ]
â—
If code point is in the range U+FF61 to U+FF9F, inclusive, return a byte whose value is code point âˆ’ 0xFF61 + 0xA1.
</dd>

   <dt>~OTHER</dt>
   <dd>ä½•ã‚‚ã—ãªã„</dd>
  </dl>
 </li>

 <li>
~IFï¼»
%~cp ~EQ U+2212
ï¼½
â‡’
%~cp ~SET U+FF0D
â—
If code point is U+2212, set it to U+FF0D.
</li>

 <li>
%~pointer ~LET
%~cp ã‚’æŒ‡ã™$index-shift_jis-pointer
â—
Let pointer be the index Shift_JIS pointer for code point.
</li>

 <li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†$error
â—
If pointer is null, return error with code point.
</li>

 <li>
%~lead ~LET floor( %~pointer Ã· 188 )
â—
Let lead be floor(pointer / 188).
</li>

 <li>
%~lead~offset ~LET ï¼»
%~lead ~IN { 0x00 ã€œ 0x1E } ãªã‚‰ã° 0x81 ï¼
~ELSE_ 0xC1<!-- 0xA0-0x81 -->
ï¼½
â—
Let lead offset be 0x81, if lead is less than 0x1F, and 0xC1 otherwise.
</li>

 <li>
%~trail ~LET %~pointer % 188
â—
Let trail be pointer % 188.
</li>

 <li>
%~offset ~LET ï¼»
%~trail ~IN { 0x00 ã€œ 0x3E } ãªã‚‰ã° 0x40 ï¼
~ELSE_ 0x41
ï¼½
â—
Let offset be 0x40, if trail is less than 0x3F, and 0x41 otherwise.
</li>

 <li>
~RET ~byteåˆ— [ ( %~lead + %~lead~offset ), ( %~trail + %~offset ) ]
â—
Return two bytes whose values are lead + lead offset and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-korean-encodings">

<h2 title="Legacy multi-byte Korean encodings">14. æ—§æ¥ã®è¤‡byte Korean ~encoding</h2>


		<section id="euc-kr">

<h3 title="EUC-KR">14.1. <b>EUC-KR</b></h3>

			<section id="euc-kr-decoder">
<h4 title="EUC-KR decoder">14.1.1. EUC-KR ~decoder</h4>

<p>
$euc-kr ã®$decoderã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
@euc-kr-leadï¼ˆåˆæœŸ~æ™‚ 0x00 ï¼‰
â—
EUC-KR's decoder has an associated EUC-KR lead (initially 0x00).
</p>

<p>
$euc-kr ã®$decoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-KR's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
~IFï¼»
%~byte ~EQ $end-of-stream
ï¼½ï¼š
â—
â†“</p>

  <ol>
   <li>
~IFï¼»
$euc-kr-lead ~NEQ 0x00
ï¼½
â‡’
$euc-kr-lead ~SET 0x00 ~BR
~RET $error
â—
If byte is end-of-stream and EUC-KR lead is not 0x00, set EUC-KR lead to 0x00 and return error.
</li>

   <li>
~ELSE
â‡’
~RET $finished
â—
If byte is end-of-stream and EUC-KR lead is 0x00, return finished.
</li>
  </ol>
 </li>

 <li>
<p>
~IFï¼»
$euc-kr-lead ~NEQ 0x00
ï¼½ï¼š
â—
If EUC-KR lead is not 0x00, let lead be EUC-KR lead, let pointer be null, set EUC-KR lead to 0x00, and then run these substeps:
</p>

  <ol>
   <li>
%~lead ~LET $euc-kr-lead ~BR
%~pointer ~LET ~NULL ~BR
$euc-kr-lead ~SET 0x00
â—
â†‘</li>

   <li>
~IFï¼»
%~byte ~IN { 0x41 ã€œ 0xFE }
ï¼½
â‡’
%~pointer ~SET ( %~lead âˆ’ 0x81 ) Ã— 190 + ( %~byte âˆ’ 0x41 )
â—
If byte is in the range 0x41 to 0xFE, inclusive, set pointer to (lead âˆ’ 0x81) Ã— 190 + (byte âˆ’ 0x41).
</li>

   <li>
%~cp ~LET ï¼»
%~pointer ~EQ ~NULL ãªã‚‰ã° ~NULL ï¼
~ELSE_ $index-euc-kr ã®ä¸­ã§ %~pointer ãŒæŒ‡ã™$index-code-point
ï¼½
â—
Let code point be null, if pointer is null, and the index code point for pointer in index EUC-KR otherwise.
</li>

   <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½~ANDï¼»
%~byte ~IN $ascii-byte
ï¼½
â‡’
%~byte ã‚’ %~stream $concept-stream-prepend
â—
If code point is null and byte is an ASCII byte, prepend byte to stream.
</li>

   <li>
~IFï¼»
%~cp ~EQ ~NULL
ï¼½
â‡’
~RET $error
â—
If code point is null, return error.
</li>

   <li>
~RET ~cp [ %~cp ]
â—
Return a code point whose value is code point.
</li>
  </ol>

 <li>
~IFï¼»
%~byte ~IN $ascii-byte
ï¼½
â‡’
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</li>


 <li>
~IFï¼»
%~byte ~IN { 0x81 ã€œ 0xFE }
ï¼½
â‡’
$euc-kr-lead ~SET %~byte ~BR
~RET $continue
â—
If byte is in the range 0x81 to 0xFE, inclusive, set EUC-KR lead to byte and return continue.
</li>

 <li>
~RET $error
â—
Return error.
</li>
</ol>

			</section>
			<section id="euc-kr-encoder">
<h4 title="EUC-KR encoder">14.1.2. EUC-KR ~encoder</h4>

<p>
$euc-kr ã®$encoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
EUC-KR's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
~IFï¼»
%~cp ~EQ $end-of-stream
ï¼½
â‡’
~RET $finished
â—
If code point is end-of-stream, return finished.
</li>

 <li>
~IFï¼»
%~cp ~IN $ascii-code-point
ï¼½
â‡’
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
%~pointer ~LET
$index-euc-kr ã®ä¸­ã§
%~cp ã‚’æŒ‡ã™$index-pointer
â—
Let pointer be the index pointer for code point in index EUC-KR.
</li>

 <li>
~IFï¼»
%~pointer ~EQ ~NULL
ï¼½
â‡’
~RET %~cp ã‚’ä¼´ã†$error
â—
If pointer is null, return error with code point.
</li>

 <li>
%~lead ~LET floor( %~pointer Ã· 190 ) + 0x81
â—
Let lead be floor(pointer / 190) + 0x81.
</li>


   <li>
%~trail ~LET ( %~pointer % 190 ) + 0x41
â—
Let trail be pointer % 190 + 0x41.
</li>

 <li>
~RET ~byteåˆ— [ %~lead, %~trail ]
â—
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>

<!-- removed from the spec 20130823
13.2 iso-2022-kr id="iso-2022-kr"
-->

	</section>
	<section id="legacy-miscellaneous-encodings">

<h2 title="Legacy miscellaneous encodings">15. ãã®ä»–ã®æ—§æ¥ã®~encoding</h2>

		<section id="replacement">
<h3 title="replacement">15.1. ~replacement</h3>

<p class="note">æ³¨è¨˜ï¼š
$replacement $encodingã¯ã€~serverã¨~clientã«ãŠã‘ã‚‹ $encodingã®~supportã®ä¸ä¸€è‡´ã‚’çªãï¼Œã‚ã‚‹ç¨®ã®æ”»æ’ƒã‚’é˜²ããŸã‚ã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
â—
The replacement encoding exists to prevent certain attacks that abuse a mismatch between encodings supported on the server and the client.
</p>

			<section id="replacement-decoder">
<h4 title="replacement decoder">15.1.1. ~replacement~decoder</h4>

<p>
$replacement ã®$decoderã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
@replacement-error-returned-flagï¼ˆåˆæœŸ~æ™‚ ~OFF ï¼‰
â—
replacement's decoder has an associated replacement error returned flag (initially unset).
</p>

<p>
$replacement ã®$decoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
replacement's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
~IFï¼»
%~byte ~EQ $end-of-stream
ï¼½
â‡’
~RET $finished
â—
If byte is end-of-stream, return finished.
</li>

 <li>
~IFï¼»
$replacement-error-returned-flag ~EQ ~OFF
ï¼½
â‡’
$replacement-error-returned-flag ~SET ~ON ~BR
~RET $error
â—
If replacement error returned flag is unset, set the replacement error returned flag and return error.
</li>

 <li>
~RET $finished
â—
Return finished.
</li>
</ol>

<p class="trans-note">ã€
$replacement ã«ã¯ã€$encoderã¯ãªã„ã€‚
ã€‘</p>


			</section>
		</section>
		<section id="common-infrastructure-for-utf-16be-and-utf-16le">

<h3 title="Common infrastructure for UTF-16BE and UTF-16LE">15.2. <span >UTF-16BE</span> ã¨ <span >UTF-16LE</span> ã«å…±é€šã®åŸºç›¤</h3>

			<section id="shared-utf-16-decoder">
<h4 title="shared UTF-16 decoder">15.2.1. å…±ç”¨ UTF-16 ~decoder</h4>

<p class="note">æ³¨è¨˜ï¼š
~BOMï¼ˆ BOM ï¼‰ã¯$labelã‚ˆã‚Šå„ªå…ˆã•ã‚Œã‚‹ã€‚
ãã‚Œã¯ï¼Œé…å‚™æ¸ˆã¿ã®å†…å®¹ã«ãŠã„ã¦ã€ã©ã®$labelã‚ˆã‚Šã‚‚æ­£ç¢ºaã§ã‚ã‚‹ã“ã¨ãŒè¦‹å‡ºã•ã‚Œã¦ã„ã‚‹ã®ã§ã€‚
ã—ãŸãŒã£ã¦ ãã‚Œã¯ã€$shared-utf-16-decoderã®ä¸€éƒ¨ã§ã¯ãªãï¼Œ$decode ~algoã®ä¸€éƒ¨ã«ãªã‚‹ã€‚
â—
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the shared UTF-16 decoder algorithm but rather the decode algorithm.
</p>

<p>
$shared-utf-16-decoderã®å„~instanceã«ã¯ã€æ¬¡ã®ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â‡’
@utf-16-lead-byteï¼ˆåˆæœŸ~æ™‚ ~NULL ï¼‰~BR
@utf-16-lead-surrogateï¼ˆåˆæœŸ~æ™‚ ~NULL ï¼‰~BR
@utf-16be-decoder-flagï¼ˆåˆæœŸ~æ™‚ ~OFF ï¼‰
â—
shared UTF-16 decoder has an associated UTF-16 lead byte and UTF-16 lead surrogate (both initially null), and UTF-16BE decoder flag (initially unset).
</p>

<p>
$shared-utf-16-decoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
shared UTF-16 decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
~IFï¼»
%~byte ~EQ $end-of-stream
ï¼½ï¼š
â—
â†“</p>

  <ol>
   <li>
~IFï¼»
$utf-16-lead-byte ~NEQ ~NULL
ï¼½~ORï¼»
$utf-16-lead-surrogate ~NEQ ~NULL
ï¼½
â‡’
( $utf-16-lead-byte, $utf-16-lead-surrogate ) ~SET ( ~NULL, ~NULL ) ~BR
~RET $error
â—
If byte is end-of-stream and either UTF-16 lead byte or UTF-16 lead surrogate is not null, set UTF-16 lead byte and UTF-16 lead surrogate to null, and return error.
</li>

   <li>
~ELSE
â‡’
~RET $finished
â—
If byte is end-of-stream and UTF-16 lead byte and UTF-16 lead surrogate are null, return finished.
</li>
  </ol>
 </li>

 <li>
~IFï¼»
$utf-16-lead-byte ~EQ ~NULL
ï¼½
â‡’
$utf-16-lead-byte ~SET %~byte ~BR
~RET $continue
â—
If UTF-16 lead byte is null, set UTF-16 lead byte to byte and return continue.
</li>

 <li>
<p>
%~cu ~LET $utf-16be-decoder-flagã«å¿œã˜ã¦ï¼Œæ¬¡ã§ä¸ãˆã‚‰ã‚Œã‚‹å€¤ï¼š
â—
Let code unit be the result of:
</p>
  <dl class="switch">
   <dt>~ONâ—UTF-16BE decoder flag is set</dt>
   <dd>
( $utf-16-lead-byte &lt;&lt; 8 ) + %~byte
â—
(UTF-16 lead byte &lt;&lt; 8) + byte.
</dd>
   <dt>~OFFâ—UTF-16BE decoder flag is unset</dt>
   <dd>
( %~byte &lt;&lt; 8 ) + $utf-16-lead-byte
â—
(byte &lt;&lt; 8) + UTF-16 lead byte.
</dd>
  </dl>
 </li>

 <li>
$utf-16-lead-byte ~SET ~NULL
â—
Then set UTF-16 lead byte to null.
</li>

 <li>
<p>
~IFï¼»
$utf-16-lead-surrogate ~NEQ ~NULL
ï¼½ï¼š
â—
If UTF-16 lead surrogate is not null, let lead surrogate be UTF-16 lead surrogate, set UTF-16 lead surrogate to null, and then run these substeps:
</p>

  <ol>
   <li>
%~lead~surrogate ~LET $utf-16-lead-surrogate ~BR
$utf-16-lead-surrogate ~SET ~NULL
â—
â†‘</li>

   <li>
~IFï¼»
%~cu ~IN { U+DC00 ã€œ U+DFFF }
ï¼½
â‡’
~RET ~cp [
0x10000 + ( ( %~lead~surrogate âˆ’ 0xD800 ) &lt;&lt; 10 ) + ( %~cu âˆ’ 0xDC00 )
]
â—
If code unit is in the range U+DC00 to U+DFFF, inclusive, return a code point whose value is 0x10000 + ((lead surrogate âˆ’ 0xD800) &lt;&lt; 10) + (code unit âˆ’ 0xDC00).
</li>
   <li>
%byte1 ~LET %~cu &gt;&gt; 8
â—
Let bytes be the return value of running these subsubsteps:
â—
Let byte1 be code unit &gt;&gt; 8.
</li>
   <li>
%byte2 ~LET %~cu &amp; 0x00FF
â—
Let byte2 be code unit &amp; 0x00FF.
</li>
   <li>
<p>
ï¼»
%~utf-16be~flag ã«å¿œã˜ã¦ï¼Œæ¬¡ã§ä¸ãˆã‚‰ã‚Œã‚‹~byteåˆ—
ï¼½ã‚’ %~stream $concept-stream-prependï¼š
â—
Then return the bytes in order, switching on UTF-16BE decoder flag:
</p>
     <dl class="switch">
      <dt>~ONâ—Set</dt>
      <dd>
~byteåˆ— [ %byte1, %byte2 ]
â—
byte1, then byte2.
</dd>
      <dt>~OFFâ—Unset</dt>
      <dd>
~byteåˆ— [ %byte2, %byte1 ]
â—
byte2, then byte1.
</dd>
     </dl>
   </li>
   <li>
~RET $error
â—
Prepend the bytes to stream and return error.
</li>
   <!-- unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them -->

  </ol>
 </li>

 <li>
~IFï¼»
%~cu ~IN { U+D800 ã€œ U+DBFF }
ï¼½
â‡’
$utf-16-lead-surrogate ~SET %~cu ~BR
~RET $continue
â—
If code unit is in the range U+D800 to U+DBFF, inclusive, set UTF-16 lead surrogate to code unit and return continue.
</li>

 <li>
~IFï¼»
%~cu ~IN { U+DC00 ã€œ U+DFFF }
ï¼½
â‡’
~RET $error
<!-- unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them -->
â—
If code unit is in the range U+DC00 to U+DFFF, inclusive, return error.
</li>

 <li>
~RET ~cp [ %~cu ]
â—
Return code point code unit.
</li>
</ol>


			</section>
		</section>
		<section id="utf-16be">

<h3 title="UTF-16BE">15.3. <b>UTF-16BE</b></h3>


			<section id="utf-16be-decoder">
<h4 title="UTF-16BE decoder">15.3.1. UTF-16BE ~decoder</h4>


<p>
$utf-16be ã®$decoderã¯ã€ï¼»
$utf-16be-decoder-flag ~SET ~ON
ï¼½ã«ã•ã‚ŒãŸ$shared-utf-16-decoderã§ã‚ã‚‹ã€‚
â—
UTF-16BE's decoder is shared UTF-16 decoder with its UTF-16BE decoder flag set.
</p>


			</section>
		</section>

		<section id="utf-16le">

<h3 title="UTF-16LE">15.4. <b>UTF-16LE</b></h3>

<p class="note">æ³¨è¨˜ï¼š
é…å‚™æ¸ˆã¿ã®å†…å®¹ã«å¯¾å‡¦ã™ã‚‹ãŸã‚ã€ `%utf-16, `%utf-16le ã®ã„ãšã‚Œã‚‚ $utf-16le ã®ãŸã‚ã®$labelã«ã•ã‚Œã¦ã„ã‚‹ã€‚
â—
Both "utf-16" and "utf-16le" are labels for UTF-16LE to deal with deployed content.
</p>

			<section id="utf-16le-decoder">
<h4 title="UTF-16LE decoder">15.4.1. UTF-16LE ~decoder</h4>


<p>
$utf-16be ã®$decoderã¯ã€$shared-utf-16-decoderã§ã‚ã‚‹ã€‚
â—
UTF-16LE's decoder is shared UTF-16 decoder.
</p>

			</section>
		</section>

		<section id="x-user-defined">

<h3 title="x-user-defined">15.5. <b>x-user-defined</b></h3>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯æŠ€è¡“çš„ã«ã¯$single-byte-encodingã§ã‚ã‚‹ãŒã€~algoçš„ã«å®Ÿè£…ã—å¾—ã‚‹ã®ã§ï¼Œåˆ¥ã€…ã«å®šç¾©ã•ã‚Œã‚‹ã€‚
<!--
This encoding is silly, however, the web depends on it:

http://krijnhoetmer.nl/irc-logs/whatwg/20121003#l-461
http://krijnhoetmer.nl/irc-logs/whatwg/20121010#l-812

https://stackoverflow.com/questions/6986789/why-are-some-bytes-prefixed-with-0xf7-when-using-charset-x-user-defined-with-xm
-->
â—
While technically this is a single-byte encoding, it is defined separately as it can be implemented algorithmically.
</p>

			<section id="x-user-defined-decoder">
<h4 title="x-user-defined decoder">15.5.1. x-user-defined ~decoder</h4>

<p>
$x-user-defined ã®$decoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~byte )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
x-user-defined's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
%~byte ã«å¿œã˜ã¦ï¼š
â—
â†“</p>
  <dl class="switch">
   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
â—
If byte is end-of-stream, return finished.
</dd>

   <dt>$ascii-byte</dt>
   <dd>
~RET ~cp [ %~byte ]
â—
If byte is an ASCII byte, return a code point whose value is byte.
</dd>

   <dt>~OTHER</dt>
   <dd><p >
~RET ~cp [ 0xF780 + %~byte âˆ’ 0x80 ]
â—
Return a code point whose value is 0xF780 + byte âˆ’ 0x80.
</dd>
  </dl>
 </li>
</ol>

			</section>
			<section id="x-user-defined-encoder">
<h4 title="x-user-defined encoder">15.5.2. x-user-defined ~encoder</h4>

<p>
$x-user-defined ã®$encoderã®$handlerã¯ã€æ‰€ä¸ã®
( %~stream, %~cp )
ã«å¯¾ã—ï¼Œæ¬¡ã‚’èµ°ã‚‰ã™ï¼š
â—
x-user-defined's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>

 <li>
<p>
%~cp ã«å¿œã˜ã¦ï¼š
â—
â†“</p>
  <dl class="switch">
   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
â—
If code point is end-of-stream, return finished.
</dd>

   <dt>$ascii-code-point</dt>
   <dd>
~RET ~byteåˆ— [ %~cp ]
â—
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

   <dt>U+F780 ã€œ U+F7FF</dt>
   <dd>
~RET ~byteåˆ— [ %~cp âˆ’ 0xF780 + 0x80 ]
â—
If code point is in the range U+F780 to U+F7FF, inclusive, return a byte whose value is code point âˆ’ 0xF780 + 0x80.
</dd>

   <dt>~OTHER</dt>
   <dd>
~RET %~cp ã‚’ä¼´ã†$error
â—
Return error with code point.
</dd>
  </dl>
 </li>
</ol>

			</section>
		</section>
	</section>
	<section id="browser-ui">

<h2 title="Browser UI">16. ~browser UI</h2>

<p>
~browserã«ã¯ã€è³‡æºã®~encodingã«å¯¾ã™ã‚‹ä¸Šæ›¸ãã‚’å¯èƒ½åŒ–ã•ã›ãªã„ã“ã¨ãŒå¥¨åŠ±ã•ã‚Œã‚‹ã€‚
ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšï¼Œãã®ç¨®ã®ç‰¹è‰²æ©Ÿèƒ½ãŒåœ¨ã™ã‚‹å ´åˆã€å‰è¿°ã®
<a href="#security-background">~securityä¸Šã®èª²é¡Œ</a>
ã‹ã‚‰ï¼Œ~browserã¯ï¼Œ $utf-16beï¼$utf-16le ã‚’~optionã¨ã—ã¦æä¾›0ã™ã‚‹~SHOULDã§ãªã„ã€‚
~browserã¯ã€è³‡æºãŒ$utf-16beï¼$utf-16leã‚’åˆ©ç”¨ã—ã¦~decodeã•ã‚ŒãŸå ´åˆã§ã‚‚ï¼Œã“ã®ç‰¹è‰²æ©Ÿèƒ½ã‚’ä¸èƒ½åŒ–ã™ã‚‹~SHOULDã§ã‚ã‚‹ã€‚
â—
Browsers are encouraged to not enable overriding the encoding of a resource. If such a feature is nonetheless present, browsers should not offer either UTF-16BE or UTF-16LE as option due to aforementioned security issues. Browsers also should disable this feature if the resource was decoded using either UTF-16BE or UTF-16LE.
</p>

	</section>

</main><!-- id="MAIN" -->

	<section id="references">

<h2 title="References">å‚ç…§æ–‡çŒ®</h2>

<dl>
 <dt>[DOM]</dt>
 <dd>
<cite><a href="https://dom.spec.whatwg.org/">DOM</a></cite>, Anne van Kesteren, Aryeh Gregor and Ms2ger. WHATWG.</dd>

 <dt>[HTML]</dt>
 <dd>
(Non-normative) <cite><a href="https://html.spec.whatwg.org/multipage/">HTML</a></cite>, Ian Hickson. WHATWG.</dd>

 <dt>[RFC2119]</dt>
 <dd>
<cite><a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a></cite>, Scott Bradner. IETF.</dd>

 <dt>[UNICODE]</dt>
 <dd>
<cite><a href="http://www.unicode.org/versions/latest/">Unicode Standard</a></cite>. Unicode Consortium.</dd>

 <dt>[URL]</dt>
 <dd>
(Non-normative) <cite><a href="https://url.spec.whatwg.org/">URL</a></cite>, Anne van Kesteren. WHATWG.</dd>

 <dt>[WEBIDL]</dt>
 <dd>
<cite><a href="https://heycam.github.io/webidl/">Web IDL</a></cite>, Cameron McCormack. W3C.
 </dd>

 <dt>[XML]</dt>
 <dd>
(Non-normative) <cite><a href="https://www.w3.org/TR/xml/">Extensible Markup Language</a></cite>, Tim Bray, Jean Paoli, C. M. Sperberg-McQueen et al.. W3C.</dd>

</dl>

	</section>
	<section id="acknowledgments">

<h2 title="Acknowledgments">è¬è¾</h2>

<p>
å¹´æœˆã«æ¸¡ã‚Šã€ç¬¦å·åŒ–æ–¹å¼ã‚’ç›¸äº’é‹ç”¨å¯èƒ½ãªã‚‚ã®ã«ã™ã‚‹ãŸã‚ã«ï¼ŒãŸãã•ã‚“ã®æ–¹ã€…ãŒåŠ©åŠ›ã•ã‚Œã€ã“ã®æ¨™æº–ã®ç›®æ¨™ã¸è¿‘ä»˜ã‘ã¦ããŸã€‚
åŒæ§˜ã«å¤šãã®æ–¹ã€…ã®åŠ©åŠ›ãŒï¼Œã“ã®æ¨™æº–ã‚’ç¾åœ¨ã®å§¿ã«ä»•ç«‹ã¦ä¸Šã’ã¦ããŸã€‚
ç‰¹ã«ï¼Œæ¬¡ã®æ–¹ã€…ã«æ„Ÿè¬ã™ã‚‹ï¼š
<span lang="en">
There have been a lot of people that have helped make encodings more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</span></p>

<p>
With that, many thanks to

Adam Rice,
Alan Chaney,
Alexander Shtuchkin,
Allen Wirfs-Brock,
Aneesh Agrawal,
Arkadiusz Michalski,
Asmus Freytag,
Ben Noordhuis,
Boris Zbarsky,
Cameron McCormack,
Charles McCathieNeville,
David Carlisle,
Domenic Denicola,
Dominique HazaÃ«l-Massieux,
Doug Ewell,
Erik van der Poel,
è­šæ°¸é‹’ (Frank Yung-Fong Tang),
Geoffrey Sneddon,
Glenn Maynard,
Gordon P. Hemsley,
Henri Sivonen,
Ian Hickson,
James Graham,
Jeffrey Yasskin,
John Tamplin,
Joshua Bell,
æ‘äº•ç´” (Jun Murai),
ì‹ ì •ì‹ (Jungshik Shin),
Jxck,
ê°• ì„±í›ˆ (Kang Seonghoon),<!-- space is intentional: https://www.w3.org/Bugs/Public/show_bug.cgi?id=27675#c2 -->
å·å¹¡å¤ªä¸€ (Kawabata Taichi),
Ken Lunde,
Ken Whistler,
Kenneth Russell,
ç”°æ‘å¥äºº (Kent Tamura),
Leif Halvard Silli,
Makoto Kato,
Mark Callow,
Mark Crispin,
Mark Davis,
Martin DÃ¼rst,
Masatoshi Kimura,
Ms2ger,
Nigel Megitt,
Nigel Tao,
Norbert Lindenberg,
Ã˜istein E. Andersen,
Peter Krefting,
Philip JÃ¤genstedt,
Philip Taylor,
Richard Ishida,
Robbert Broersma,
Robert Mustacchi,
Ryan Dahl,
Shawn Steele,
Simon Montagu,
Simon Pieters,
Simon Sapin,
å¯ºç”°å¥ (Takeshi Terada),
Vyacheslav Matva, and
æˆç€¬ã‚†ã„ (Yui Naruse)

for being awesome.
</p>

	</section>

<p>
ã“ã®æ¨™æº–ã¯ã€
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a> ï¼ˆ
<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>
ï¼‰ã«ã‚ˆã‚Šæ›¸ã‹ã‚ŒãŸã€‚
å½“åˆã® <a href="#api">API</a> ç¯€ã¯ã€
Joshua Bell ï¼ˆ
<a href="https://www.google.com/">Google</a>)
ï¼‰ã«ã‚ˆã‚Šæ›¸ã‹ã‚ŒãŸã€‚
<span lang="en">
This standard is written by Anne van Kesteren (Mozilla, annevk@annevk.nl). The API chapter was initially written by Joshua Bell (Google).
</span></p>

<p>
Per <a href="https://creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>, to
the extent possible under law, the editors have waived all copyright and related or
neighboring rights to this work.
</p>

</body>
