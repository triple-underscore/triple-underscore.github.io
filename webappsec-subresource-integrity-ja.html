<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">

<title>Subresource Integrity</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">

<style>

samp {
	white-space: nowrap;
	background: var(--bg-color-1);
	margin-left: 0.5em;
	margin-right: 0.5em;
}

.hash-func {
	font-family: sans-serif0, sans-serif;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'U':
	text = `U+${text}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2025-05-27
trans_update:2025-05-28
source_checked:210222
page_state_key:WEBAPPSEC
original_url:https://w3c.github.io/webappsec-subresource-integrity/
	abbr_url:SRI1
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:w3c
copyright:2025,permissive
trans_1st_pub:2016-06-22


●●class_map
P:production
h:header
e:element
a:attr
et:event-type
hS:hash-func
dir:directive
v:value
U:code-point
cn:cp-name

●●tag_map
p:var
P:code
h:code
m:code
I:code
e:code
a:code
et:code
m:code
dir:code
v:code
c:code
s:samp
hS:span
V:var
U:span
cn:span
em:em
i:i

●●words_table

	●network
CDN:
DNS:
TLS:
HSTS:
log-in::::ログイン
payload::::ペイロード
媒介:intermediate::~
sri:SRI

低速:slow:~
優先度:priority:~
	優先度:prioritization
報告先:endpoint::~::レポート先
	完全性~施策~header:Integrity-Policy header

	:loading
	経路上で:in-flight:
	要請-者:requestor

	●処理
main:
剥ぐ:stripする:~

	`阻止される^i:"Blocked"
	`許容される^i:"Allowed"

	走っている:running
	%式と~option群:expression-and-options
	%~algo式:algorithm-expression
	%~base64値:base64-value
	%~algoと値:algorithm-and-value
	%期待される値:expectedValue
	%~metadata:metadata
	%~metadata~list:metadataList
	%~metadata文字列:metadata
	%最強~index:strongest
	%最強~index:currentAlgorithmIndex
	%~index:newAlgorithm
	%~index:newAlgorithmIndex
	%~token:currentAlgorithm
	%~token:token
	%~byte列:bytes
	%結果:result
	%構文解析-済み~metadata:parsedMetadata
	%実際の値:actualValue
	%阻止されるか:block
	%報告のみか:reportBlock
	%~header群:headers
	%~header名:headerName
	%完全性~施策:integrityPolicy
	%辞書:dictionary
	%応答:response
	%容器:container
	%要請:request
	%施策~容器:policyContainer
	%施策:policy
	%施策:-
	%報告のみ施策:-
	%報告~施策:reportPolicy
	%大域~obj:global
	%文書~URL:documentURL
	%阻止された~URL:blockedURL
	%報告-本体:reportBody
	%設定群~obj:settingsObject
	%報告先:endpoint
	%報告先~群:-
	%阻止される行先~群:-
	%~URL:url


	●保安
	CORS-enabled
	NIST
	Integrity
	SHA-1
	SHA-384
	SHA384
	MD5
pin:
base64:
username::::ユーザ名
digest::::ダイジェスト
hash::::ハッシュ
hashing::::ハッシュ
衝突:collision::~
衝突耐性:collision-resistant::~
推測-:guess:~
推定-:surmise:~
認証-:authenticate::~
警告:warning:~
注視-:watch:~
洞察:insight:~
	洞察を得る:gain some insight into
管理者:administrator::~
弱い:weakな::~
最強:strongest::~
弱体化-:compromise::~
弱体化:compromise::~
暗号上の:cryptographic::~
暗号用:cryptographic::~
汚染:poisoning::~
高特権:high-privilege::~
総当たり:brute-force::~
	総当たり:brute-forcing
式:expression:~
露呈-:reveal::~
騙せる:trickできる::~
	~secure化法:securing
	~secureでない:insecure
	~secureな文脈:Secure Context
	ほど強い:weaker
	方が強い:weaker
	自身が通話相手と信じる~serverが~~本物である:indeed speaking with the server it believes it’s talking to
	抗する:against

	●仕様
utility::::ユーティリティ
切替えれ:switchでき:切り替えれ
即応性:agility:~
機敏:agile:~
	機敏に対応できる:provide agility
古い:older:~
拒否-:refuse:~
拡げる:expandする:~
枠組み:scheme:~
定期的:regular basis:~
煮詰める:boil downする:~
移行-:migrate::~
稀:rare:~
選択肢:option:~
直面-:face:~
誤り:error:~
不幸:unfortunate:~

	評価し直-:re-evaluate
	無論:of course:もちろん
	咎め無く:impunity
	対象にしている:meant to
	対象範囲 this coverage
	多様な:wide variety of
	現時点では:at the moment
	縛られることなく:being held back by
	〜ない見込みが高い:unlikely:
	着想を得た:heavily inspired
	無論:of course
	~~主要な:key
	~~判明した:show
	~~実際に:in fact
	に関する:regarding
	選ぶ:choose

	●未分類
一重引用符:single quote::~
印字可能:printing:~
改ざん:alter:~
構成-:compose:~
確認-:confirm:~
解析:analytics:~
全世界の:globally-distributed:~
代用-:substitute::~
繰返し:repeatedly:繰り返し
command-line:command line::コマンド行::コマンドライン
bookmarklet:

	文法~上の:grammatical
	最終的:eventual
	新たな~UItab:New Tab
	~algo:alg
	良好な~~基準:good baseline
	~entryの値:member-value
	1 個以上:at least one
	片:piece
	~~判明:shown
	`0020^U `SPACE^cn:space
	~~十分:sufficient
	し続ける:stays in
	~supportしない:unsupported
	全体を通して:throughout
	かなりの部分:much of
	ごく:quite
	ずっと:much
	たまたま:happen
	なり次第:begin
	広く:broadly
	予め算出-:precompute
	二次的な:secondary
	伝える:informする
	何でもできる:do absolutely anything else
	前:previous
	加えて:additionally
	壊れて:broken
	指す:refer
	更には:moreover
	書-:write
	直前の:immediately precede
	相応の~~確証を得られる:fairly certain
	様々な:a variety of
	ことごとく:every
	も:extra
	-:extra
	-:expand


●●original_id_map


●●words_table1

RFC6454:RFC6454-ja.html
sf:<sub>sf-</sub>


●●link_map

	●IDL

Exposed:~WEBIDLjs#Exposed
Default:~WEBIDLjs#Default

USVString:~WEBIDL#idl-USVString
boolean:~WEBIDL#idl-boolean
object:~WEBIDL#idl-object

I.Window:~WINDOW#window
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.ReportBody:~REPORTING#reportbody
I.IntegrityPolicyViolationReportBody:#integritypolicyviolationreportbody

m.toJSON:#dom-integritypolicyviolationreportbody-tojson
m.documentURL:#dom-integritypolicyviolationreportbody-documenturl
m.blockedURL:#dom-integritypolicyviolationreportbody-blockedurl
m.destination:#dom-integritypolicyviolationreportbody-destination
m.reportOnly:#dom-integritypolicyviolationreportbody-reportonly

	●code
P.integrity-metadata:#grammardef-integrity-metadata
P.hash-with-options:#grammardef-hash-with-options
P.option-expression:#grammardef-option-expression
P.hash-expression:#grammardef-hash-expression
P.hash-source:~CSP3#grammardef-hash-source
P.hash-algorithm:~CSP3#grammardef-hash-algorithm
P.base64-value:~CSP3#grammardef-base64-value

P.VCHAR:~RFCx/rfc5234#appendix-B.1
P.WSP:~RFCx/rfc5234#appendix-B.1
P.link-param:~HTTPweblink#p.link-param

h.Link:~HTTPweblink#field.link
h.Cache-Control:~HTTPcache#field.cache-control

dir.no-transform:~HTTPcache#cache-response-directive.no-transform

a.integrity:#the-integrity-attribute

e.script:~HEscripting#the-script-element
e.link:~HEmetadata#the-link-element

et.error:~HTMLindex#event-error

hS.SHA-256:#_sha-2
hS.SHA-384:#_sha-2
hS.SHA-512:#_sha-2
hS.SHA-2:#_sha-2
	SHA-XXX:https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf#

	●用語
~digest:#digest
V.…( ~digest )…:#digest

完全性~metadata:#integrity-metadata
iM.~algo:#_integrity-metadata-hash-algo
iM.値:#_integrity-metadata-digest
iM.~option群:#_integrity-metadata-options
	alg/val/opt

~base64符号化法:#base64-encoding
~byte列に~algoを適用する:#apply-algorithm-to-response
妥当な~sri~hash~algo~token集合:#valid-sri-hash-algorithm-token-set
妥当な~sri~hash~algo~token:#valid-sri-hash-algorithm-token
最も強い~metadataを取得する:#get-the-strongest-metadata
完全性~metadataを構文解析する:#parse-metadata
~byte列は~metadata~listに合致するか？:#does-response-match-metadatalist

~source:#source
行先:#destination
完全性~施策:#integrity-policy
報告のみの完全性~施策:#report-only-integrity-policy
完全性~施策~構造体:#integrity-policy-struct
iPs.~source群:#sources
iPs.阻止される行先~群:#blocked-destinations
iPs.報告先~群:#endpoints
完全性~施策を処理する:#processing-an-integrity-policy
完全性~施策~headerを構文解析する:#parse-integrity-policy-headers
要請は完全性~施策により阻止されるべきか？:#should-request-be-blocked-by-integrity-policy
違反を報告する:#report-violation

	●用語（外部

~ASCII小文字~化する:~INFRA#ascii-lowercase
区切子で厳密に分割する:~INFRA#strictly-split
~byte列:~INFRA#byte-sequence
~list:~INFRA#list
~size:~INFRA#list-size
空:~INFRA#list-is-empty
空にする:~INFRA#list-empty
付加する:~INFRA#list-append
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
構造体:~INFRA#struct
	~IN:~INFRA#list-contain
	~NEQ ε:~INFRA#map-exists
	~Assert:~INFRA#assert
	~EACH:~INFRA#list-iterate

新たな~obj:~WEBIDLjs#new

~URL~record:~URL1#concept-url

~network~error:~FETCH#concept-network-error
~header~list:~FETCH#concept-header-list
~header名:~FETCH#header-name
有構造~field値を取得する:~FETCH#concept-header-list-get-structured-header
応答:~FETCH#concept-response
rs.~header~list:~FETCH#concept-response-header-list
	包含する:~FETCH#header-list-contains
~header値:~FETCH#header-value
要請:~FETCH#concept-request
rq.施策~容器:~FETCH#concept-request-policy-container
rq.~mode:~FETCH#concept-request-mode
rq.~client:~FETCH#concept-request-client
rq.行先:~FETCH#concept-request-destination
rq.~URL:~FETCH#concept-request-url
rq.完全性~metadata:~FETCH#concept-request-integrity-metadata
~main~fetch:~FETCH#concept-main-fetch
	~main~fetch:~FETCH#main-fetch

有構造~header:~STRUCTURED-FIELDS#structured-header
~sf辞書:~STRUCTURED-FIELDS#sf-dictionary
~sf内縁~list:~STRUCTURED-FIELDS#sf-inner-list
~sf~token:~STRUCTURED-FIELDS#sf-token

~field値:~HTTPinfra#field-value

施策~容器:~ORIGIN#policy-container
~fetch応答から施策~容器を作成する:~ORIGIN#creating-a-policy-container-from-a-fetch-response
結付けられた文書:~WINDOW#concept-document-window
enV.~secureな文脈:~WAPI#secure-context
enV.大域~obj:~WAPI#concept-settings-object-global
wG.~URL:~WORKERS#concept-workerglobalscope-url
doc.~URL:~DOM4#concept-document-url
	doc.~URL:~DOM4#dom-document-url
報告~内の利用-用に~URLを剥ぐ:~CSP3#strip-url-for-use-in-reports
	報告~内の利用-用に~URLを剥ぐ:~TR/CSP3/#strip-url-for-use-in-reports
報告を生成して~queueする:~REPORTING#generate-and-queue-a-report
	~REPORTING#generate-and-queue-a-report-context
	~REPORTING#generate-and-queue-a-report-type
	~REPORTING#generate-and-queue-a-report-destination
	~REPORTING#generate-and-queue-a-report-data


	＠要請の一部:~FETCH#concept-request-integrity-metadata
	＠https://www.w3.org/Security/wiki/Same_Origin_Policy
	＠~CSP3#framework-directive-source-list
		~CSP#source-list-syntax
		~CSP2#source-list-syntax
	＠https://www.eff.org/https-everywhere
	＠https://www.gerv.net/security/link-fingerprints/
	＠https://wiki.whatwg.org/wiki/Link_Hashes
	＠https://www.openssl.org/
	＠~RFCx/rfc4648#section-4
	＠https://www.w3.org/2001/tag/doc/web-https
	pinned public keys:~RFCx/rfc7469
	rq.完全性~metadata
	~ORIGIN#concept-origin
	~ORIGIN#same-origin


●●ref_normative

[ABNF]
    D. Crocker, Ed.; P. Overell. ＜Augmented BNF for Syntax Specifications: ABNF＞. January 2008. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc5234
[CSP]
    Mike West; Antonio Sartori. ＜Content Security Policy Level 3＞. URL: https://w3c.github.io/webappsec-csp/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[Fetch]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MIME-TYPES]
    N. Freed; N. Borenstein. ＜Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types＞. November 1996. Draft Standard. URL: https://www.rfc-editor.org/rfc/rfc2046
[REPORTING-1]
    Douglas Creager; Ian Clelland; Mike West. ＜Reporting API＞. URL: https://w3c.github.io/reporting/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[RFC4648]
    S. Josefsson. ＜The Base16, Base32, and Base64 Data Encodings＞. October 2006. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc4648
[RFC7234]
    R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. ＜Hypertext Transfer Protocol (HTTP/1.1): Caching＞. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7234.html
[RFC8288]
    M. Nottingham. ＜Web Linking＞. October 2017. Proposed Standard. URL: https://httpwg.org/specs/rfc8288.html
[RFC9651]
    M. Nottingham; P-H. Kamp. ＜Structured Field Values for HTTP＞. September 2024. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc9651
[SHA2]
    ＜FIPS PUB 180-4, Secure Hash Standard＞. URL: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[RFC1035]
    P. Mockapetris. ＜Domain names - implementation and specification＞. November 1987. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc1035
[RFC6797]
    J. Hodges; C. Jackson; A. Barth. ＜HTTP Strict Transport Security (HSTS)＞. November 2012. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6797
[RFC7469]
    C. Evans; C. Palmer; R. Sleevi. ＜Public Key Pinning Extension for HTTP＞. April 2015. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc7469
[TLS]
    E. Rescorla. ＜The Transport Layer Security (TLS) Protocol Version 1.3＞. August 2018. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc8446


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Subresource Integrity</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/sri-2/
公表履歴
	https://www.w3.org/standards/history/sri-2/
commit 履歴
	https://github.com/w3c/webappsec-subresource-integrity/commits/main
フィードバック
	<a href="mailto:public-webappsec@w3.org?subject=%5BSRI%5D%20YOUR%20TOPIC%20HERE">public-webappsec@w3.org</a> with subject line “<kbd>[SRI] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-webappsec/" rel="discussion">archives</a>)
	<a href="https://github.com/w3c/webappsec-subresource-integrity/issues/">GitHub</a>

編集
	<a href="https://frederik-braun.com/">Frederik Braun</a> (Mozilla) <a href="mailto:fbraun@mozilla.com">fbraun@mozilla.com</a>
前任編集者
	<a href="http://devd.me">Devdatta Akhawe</a> (Dropbox Inc.) <a href="mailto:dev.akhawe@gmail.com">dev.akhawe@gmail.com</a>
	<a href="https://fmarier.org">François Marier</a> (Mozilla) <a href="mailto:francois@mozilla.com">francois@mozilla.com</a>
	<a href="https://joelweinberger.us">Joel Weinberger</a> (Google Inc.) <a href="mailto:jww@google.com">jww@google.com</a>
テスト一式
	https://wpt.fyi/results/subresource-integrity/
公表者
	<a href="https://www.w3.org/groups/wg/webappsec">Web Application Security WG</a>

</script>

<body>

<header>
	<hgroup>
<h1>下位資源の完全性 — Subresource Integrity</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この仕様は、［
~fetchした資源は，期待されない操作により送達されていない
］ことを，~UAが検証yできるようにする仕組みを定義する。
◎
This specification defines a mechanism by which user agents may verify that a fetched resource has been delivered without unexpected manipulation.
</p>
	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
~web上の~siteや~appが，単独の生成元のみからの資源で構成されることは稀である。
例えば，作者は、
多様な［
~service／ ~CDN（ `Content Delivery Network^en, “内容~送達~network” ）
］から，~scriptや~stylesheetを~pullする
— 作者は、
送達された表現が［
読込まれるものと自身が期待するものと，~~実際に~~相違ない
］ことを信用しなければナラナイ。
攻撃者が［
敵対的~serverからの内容を~downloadする
］よう利用者を騙せる場合
（~DNS `RFC1035$r 汚染, その他の手段を介して）、
作者にできる手立てはない。
同様に、
~CDN~server上の~fileを置換できる攻撃者は，任意な内容を注入できる能を有する。
◎
Sites and applications on the web are rarely composed of resources from only a single origin. For example, authors pull scripts and styles from a wide variety of services and content delivery networks, and must trust that the delivered representation is, in fact, what they expected to load. If an attacker can trick a user into downloading content from a hostile server (via DNS [RFC1035] poisoning, or other such means), the author has no recourse. Likewise, an attacker who can replace the file on the Content Delivery Network (CDN) server has the ability to inject arbitrary content.
</p>

<p>
この~riskの一部は、
資源を~secure~channel
— ~TLS `TLS$r, ~HSTS `RFC6797$r, `pinned public keys^en `RFC7469$r —
越しに送達することで軽減される。
~UAは、
自身が通話相手と信じる~serverが~~本物であることについて，相応の~~確証を得られるので。
しかしながら，これらの仕組みが認証するものは、
`内容ではなく^em，`~serverに限られる^em。
~serverへの~accessを有する攻撃者（あるいは管理者）は、
咎め無く内容を操作できる。
理想は、
作者が~serverの~keyを~pin†可能になるのみならず，
`内容^emについても資源~表現の正確~性を確保するよう~pin可能にして、
`そのような表現に限り^em，読込んで実行するようになることである。
◎
Delivering resources over a secure channel mitigates some of this risk: with TLS [TLS], HSTS [RFC6797], and pinned public keys [RFC7469], a user agent can be fairly certain that it is indeed speaking with the server it believes it’s talking to. These mechanisms, however, authenticate only the server, not the content. An attacker (or administrator) with access to the server can manipulate content with impunity. Ideally, authors would not only be able to pin the keys of a server, but also pin the content, ensuring that an exact representation of a resource, and only that representation, loads and executes.
</p>

<p class="trans-note">【†
“~keyを~pinする”
— 相手（ ~server ）の身元を随時確認できるよう，その証明情報の “真正な写し” （ ~key ）を手元（ ~UA側）に “ピン留め” しておく。
（したがって、
最初に “写し” を得る段階で，その真正性が確保される必要がある。）
】</p>

<p>
この文書は、
そのような検証の枠組みを指定する。
また、
2 個の~HTML要素
— `script$e, `link$e —
を `integrity$a 属性で拡張する。
この属性は、［
作者が読込むものと期待する資源の表現
］に対する暗号用~hashを包含する。
一例として、
作者は，ある~frameworkを
— 自前の生成元で~hostすることなく —
共用~serverから読込むよう望むとする。
`https://example.com/example-framework.js^s
に`期待される^em `SHA-384$hS ~hashとして`~digest$
`Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7^s
を指定することは、
~UAが［
その~URLから読込む~dataが包含している~JSを実行する前
］に［
当の~dataが期待された~hashに合致するか否かを検証yできる
］ことを意味する。
この完全性~検証yは、［
攻撃者により資源が悪意的な内容で代用される~risk
］を有意に抑制する。
◎
This document specifies such a validation scheme, extending two HTML elements with an integrity attribute that contains a cryptographic hash of the representation of the resource the author expects to load. For instance, an author may wish to load some framework from a shared server rather than hosting it on their own origin. Specifying that the expected SHA-384 hash of https://example.com/example-framework.js is Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7 means that the user agent can verify that the data it loads from that URL matches that expected hash before executing the JavaScript it contains. This integrity verification significantly reduces the risk that an attacker can substitute malicious content.
</p>

<div class="example">
<p>
例えば， `script^e 要素に次の様に~hashを追加すれば、
~UAへ向けて~hashを通信できる：
◎
This example can be communicated to a user agent by adding the hash to a script element, like so:
</p>

<pre class="lang-html">
&lt;script src="https://example.com/example-framework.js"
        integrity="sha384-Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7"
        crossorigin="anonymous"&gt;&lt;/script&gt;
</pre>
</div>

<p>
無論、
~scriptだけが 完全性~検証からの便益を得られる応答~種別ではない。
ここで指定される枠組みは、
`link^e にも適用され、
また，この仕様の将来の~versionでは、
対象範囲を拡げる見込みが高い。
◎
Scripts, of course, are not the only response type which would benefit from integrity validation. The scheme specified here also applies to link and future versions of this specification are likely to expand this coverage.
</p>

		<section id="goals">
<h3 title="Goals">1.1. 目標</h3>

<ol>
	<li>
第三者-主体~serviceが弱体化されても，自動的に その~scriptを含む~siteまで ことごとく弱体化されるべきでない。
内容~作者が、
自身が読込む内容に対する期待を指定できる仕組みを与える
— 例えば、
当の~URLにたまたま あてがわれた `~~任意の^em ~scriptではなく，`特定の^em ~scriptに限って読込めるような。
◎
Compromise of a third-party service should not automatically mean compromise of every site which includes its scripts. Content authors will have a mechanism by which they can specify expectations for content they load, meaning for example that they could load a specific script, and not any script that happens to have a particular URL.
</li>
	<li>
検証yの仕組みは、
受信された応答が妥当でないときは，それを作者に伝えるような、
~errorを報告する機能性を備えるべきである。
◎
The verification mechanism should have error-reporting functionality which would inform the author that an invalid response was received.
</li>
</ol>

		</section>
		<section id="use-casesexamples">
<h3 title="Use Cases/Examples">1.2. 利用事例と例</h3>

			<section id="resource-integrity">
<h4 title="Resource Integrity">1.2.1. 資源の完全性</h4>

<ul>
	<li>
<p>
作者は、［
全世界の利用者のために処理能を改善するため，~CDNを利用する
］よう望んでいるとする。
しかしながら、［
~CDNの~serverが，作者が`期待する~codeのみ^emを送達する
］ことを確保することも重要である。
~CDNが弱体化されて（あるいは期待されない悪意的な挙動により），
~siteが不幸な仕方で変更される~riskを軽減するためには、
~pageに含まれる `link$e 要素に次の`完全性~metadata$を追加する：
◎
An author wishes to use a content delivery network to improve performance for globally-distributed users. It is important, however, to ensure that the CDN’s servers deliver only the code the author expects them to deliver. To mitigate the risk that a CDN compromise (or unexpectedly malicious behavior) would change that site in unfortunate ways, the following integrity metadata is added to the link element included on the page:
</p>

<pre class="lang-html">
&lt;link
    rel="stylesheet"
    href="https://site53.example.net/style.css"
    integrity="sha384-`…( ~digest )…$V"
    crossorigin="anonymous"
&gt;
</pre>

	</li>
	<li>
<p>
作者は、［
第三者-主体が解析~service用に供した~JSを~pageに含める
］よう求めているとする。
注意深く考査された~codeに限り実行されることを確保するためには、
~script用の`完全性~metadata$を生成して，それを `script$e 要素に追加する：
◎
An author wants to include JavaScript provided by a third-party analytics service. To ensure that only the code that has been carefully reviewed is executed, the author generates integrity metadata for the script, and adds it to the script element:
</p>

<pre class="lang-html">
&lt;script
    src="https://analytics-r-us.example.com/v1.0/include.js"
    integrity="sha384-`…( ~digest )…$V"
    crossorigin="anonymous"
&gt;&lt;/script&gt;
</pre>
	</li>
	<li>
~UAは、
高特権な~HTML文脈（例えば，~browserの新たな~UItab~page）内で走っている~JS~codeが，表示される前に操作されないことを確保するよう望む。
`完全性~metadata$は、
改ざんされた~JSが そのような高特権な文脈~下で走る~riskを軽減する。
◎
A user agent wishes to ensure that JavaScript code running in high-privilege HTML contexts (for example, a browser’s New Tab page) aren’t manipulated before display. Integrity metadata mitigates the risk that altered JavaScript will run in these pages' high-privilege contexts.
</li>
</ul>

			</section>
		</section>
	</section>
	<section id="key-concepts-and-terminology">
<h2 title="Key Concepts and Terminology">2. ~~主要な概念と各種用語</h2>

<p>
この節では、
文書~全体を通して利用されるいくつかの用語を定義する。
◎
This section defines several terms used throughout the document.
</p>

<p>
用語
`~digest@
は、
任意な~data~blockに暗号用~hash関数を適用した結果を~base64に符号化した結果を指す。
◎
The term digest refers to the base64 encoded result of executing a cryptographic hash function on an arbitrary block of data.
</p>

<p>
用語［
生成元, 同一-生成元
］は、
`HTML$r にて定義される。
◎
The terms origin and same origin are defined in HTML. [HTML]
</p>

<p>
`~base64符号化法@
は、
`RFC4648$r `§ 4＠~RFCx/rfc4648#section-4$
にて定義される。
◎
A base64 encoding is defined in Section 4 of RFC 4648. [RFC4648]
</p>

<p>
`SHA-256^hS, `SHA-384^hS, `SHA-512^hS
は、
暗号用~hash関数
`SHA-2@hS
の一部を成し，
`SHA2$r にて定義される。
◎
The SHA-256, SHA-384, and SHA-512 are part of the SHA-2 set of cryptographic hash functions defined by the NIST. [SHA2]
</p>

<p>
`妥当な~sri~hash~algo~token集合@
は、
`有順序~集合$ « `sha256^l, `sha384^l, `sha512^l » である
（順に，［
`SHA-256$hS, `SHA-384$hS, `SHA-512$hS
］に対応する）。
この集合の順序付けは有意義であり，
この集合~内で後に現れるものほど強い~algoとされる。
追加的な情報は、［
`§ 優先度＠#priority$, `最も強い~metadataを取得する$
］を見よ。
◎
The valid SRI hash algorithm token set is the ordered set « "sha256", "sha384", "sha512" » (corresponding to SHA-256, SHA-384, and SHA-512 respectively). The ordering of this set is meaningful, with stronger algorithms appearing later in the set. See § 3.2.2 Priority and § 3.3.3 Get the strongest metadata from set for additional information.
</p>

<p>
所与の文字列 %文字列 が
`妥当な~sri~hash~algo~token@
であるとは、
次を満たすことをいう
⇒
`~ASCII小文字~化する$( %文字列 ) ~IN `妥当な~sri~hash~algo~token集合$
◎
A string is a valid SRI hash algorithm token if its ASCII lowercase is contained in the valid SRI hash algorithm token set.
</p>

		<section id="grammatical-concepts">
<h3 title="Grammatical Concepts">2.1. 文法~上の概念</h3>

<p class="trans-note">【
この節の内容は、
関連な節に直に記すことにする。
】
◎
The Augmented Backus-Naur Form (ABNF) notation used in this document is specified in RFC5234. [ABNF]
◎
Appendix B.1 of [ABNF] defines the VCHAR (printing characters) and WSP (whitespace) rules.
◎
Content Security Policy defines the base64-value and hash-algorithm rules. [CSP]
</p>

		</section>
	</section>
	<section id="framework">
<h2 title="Framework">3. ~framework</h2>

<div class="p">
<p>
ここで指定する 完全性~検証yの仕組みは、
次の処理-を煮詰める：
</p>

<ul ><li>資源から~~十分に強い暗号用~digestを生成する。
</li><li>生成した~digestを，応答を検証yするために利用できるよう，~UAへ伝送する。
</li></ul>
◎
The integrity verification mechanism specified here boils down to the process of generating a sufficiently strong cryptographic digest for a resource, and transmitting that digest to a user agent so that it may be used to verify the response.
</div>

		<section id="integrity-metadata-description">
<h3 title="Integrity metadata">3.1. 完全性~metadata</h3>

<p>
応答の完全性を検証yするため、
~UAは，
`要請の一部＠~FETCH#concept-request-integrity-metadata$として
`完全性~metadata@
を要求する。
この~metadataは、
次に挙げる情報~片からなる：
◎
To verify the integrity of a response, a user agent requires integrity metadata as part of the request. This metadata consists of the following pieces of information:
</p>
<ul>
	<li>
`~algo@iM
⇒
ある暗号用~hash関数【を識別する名前】
◎
cryptographic hash function ("alg")
</li>
	<li>
`値@iM
⇒
ある`~digest$
◎
digest ("val")
</li>
	<li>
`~option群@iM
◎
options ("opt")
</li>
</ul>

<p>
これらのうち，`~algo$iMと`値$iM は、
供されなければナラナイ
— 応答の完全性を検証するためには必須なので。
◎
The hash function and digest MUST be provided in order to validate a response’s integrity.
</p>

<p class="note">注記：
現時点では，定義された~optionはないが、
この仕様は，将来の~versionにて~optionを定義し得る
— ~MIME型 `MIME-TYPES$r など。
◎
Note: At the moment, no options are defined. However, future versions of the spec may define options, such as MIME types [MIME-TYPES].
</p>

<p>
この~metadataは、
~CSP `§ ~source~list＠~CSP3#framework-directive-source-list$の
 `hash-source$P と同じ形式に符号化されなければナラナイ
（ただし、
一重引用符は含めない）。
◎
This metadata MUST be encoded in the same format as the hash-source (without the single quotes) in section 4.2 of the Content Security Policy Level 2 specification.
</p>

<div class="example">
<p>
例えば、
~script資源の内容が文字列
`alert(\'Hello, world.\');^l
で，作者が~hash関数として `SHA-384$hS を選んだなら、
~base64に符号化された結果の~digestは、
`H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO^s
になる。
これは、
次のように符号化できる：
◎
For example, given a script resource containing only the string alert('Hello, world.');, an author might choose SHA-384 as a hash function. H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO is the base64 encoded digest that results. This can be encoded as follows:
</p>

<pre class="lang-http">
sha384-H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO
</pre>
</div>

<div class="note">
<p>注記：
~digestを生成するために利用できる~utilityは、
いくつもある。
例えば `OpenSSL＠https://www.openssl.org/$ は、
ごく共通に可用である。
この節の例は、
次の~command-lineによる結果である：
◎
Digests may be generated using any number of utilities. OpenSSL, for example, is quite commonly available. The example in this section is the result of the following command line:
</p>

<pre class="lang-other">
echo -n "alert('Hello, world.');" | \
   openssl dgst -sha384 -binary | \
   openssl base64 -A
</pre>
</div>

		</section>
		<section id="cryptographic-hash-functions">
<h3 title="Cryptographic hash functions">3.2. 暗号用~hash関数</h3>

<p>
適合t~UAは、
要請の`完全性~metadata$の一部として利用する暗号用~hash関数として［
`SHA-256$hS,
`SHA-384$hS,
`SHA-512$hS
］を~supportするモノトスル。
また、
この文書にて将来に定義される追加的な~hash関数を~supportしてもヨイ。
◎
Conformant user agents MUST support the SHA-256, SHA-384, and SHA-512 cryptographic hash functions for use as part of a request’s integrity metadata and MAY support additional hash functions defined in future iterations of this document.
</p>

<div class="p">
<p>
~UAは、
自身が~supportする~hashing関数を，次に従って制約するベキである
（ `§ ~hash衝突~攻撃＠#hash-collision-attacks$を見よ）：
</p>
<ul>
	<li>
`MD5^hS や `SHA-1^hS の様な弱いことが既知なものは~supportしない。
</li>
	<li>
衝突耐性があることが既知なものに限る。
</li>
	<li>
~supportしている~hashing関数を定期的に評価し直して、
~secureでなくなったものは非推奨にする。
</li>
</ul>
◎
User agents SHOULD refuse to support known-weak hashing functions like MD5 or SHA-1 and SHOULD restrict supported hashing functions to those known to be collision-resistant. Additionally, user agents SHOULD re-evaluate their supported hash functions on a regular basis and deprecate support for those functions that have become insecure. See § 5.2 Hash collision attacks.
</div>

			<section id="agility">
<h4 title="Agility">3.2.1. 即応性</h4>

<p>
将来，暗号上の発見に直面したときに 機敏に対応できるよう、
同じ資源に複数個の［
`完全性~metadata$たちが成す集合
］を結付けてもよい†。
◎
Multiple sets of integrity metadata may be associated with a single resource in order to provide agility in the face of future cryptographic discoveries. For example, the resource described in the previous section may be described by either of the following hash expressions:
</p>

<div class="example">
<p>
作者は、
同じ資源に対し，例えば `SHA-384$hS, `SHA-512$hS ~hashの 2 つを指定してよい：
◎
sha384-H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO
◎
sha512-Q2bFTOhEALkN8hOms2FKTDLy7eugP2zFZ1T8LCvX42Fp3WoNr3bjZSAHeOsHrbV1Fu9/A0EzCinRE7Af1ofPrw==
◎
Authors may choose to specify both, for example:
</p>

<pre class="lang-html">
&lt;script src="hello_world.js"
   integrity="sha384-`…( ~digest )…$V
              sha512-`…( ~digest )…$V"
   crossorigin="anonymous"&gt;&lt;/script&gt;
</pre>
</div>

<p class="trans-note">【†
複数個の集合（ `multiple sets of^en 〜 ）：
各~hash関数に対しても，複数個の~hash値を与え得る
— `後述の例＠#_multi-hash$のように。
】</p>

<p>
この事例では、
~UAは，応答を検証するときに~list内の最も強い~hash関数を選んで，
その~metadataを利用することになる
（後述の［
`完全性~metadataを構文解析する$／ `最も強い~metadataを取得する$
］~algoに則って）。
◎
In this case, the user agent will choose the strongest hash function in the list, and use that metadata to validate the response (as described below in the § 3.3.2 Parse metadata and § 3.3.3 Get the strongest metadata from set algorithms).
</p>

<p>
~secureでないと決定された~hash関数に対しては、
~UAは，それを非推奨にした上で、
最終的には，~secureでないな~hash関数を利用している完全性~検証の~supportを除去するベキである。
~UAは、
応答の妥当性を検査する際に，非推奨にされた関数に基づく~digestを利用してもヨイ。
◎
When a hash function is determined to be insecure, user agents SHOULD deprecate and eventually remove support for integrity validation using the insecure hash function. User agents MAY check the validity of responses using a digest based on a deprecated function.
</p>

<p>
作者が，古い~UAに縛られることなく より強い~hash関数に切替えれるよう、
~UAは，自身が~supportしない~hash関数を利用している検証に対しては，その完全性~値は供されなかったかの様に動作することになる
（後述の，`~byte列は~metadata~listに合致するか？$を見よ）。
作者には、
強い~hash関数を利用することに加え，より強い~hash関数が可用になり次第 それへ移行することが奨励される。
◎
To allow authors to switch to stronger hash functions without being held back by older user agents, validation using unsupported hash functions acts like no integrity value was provided (see the § 3.3.4 Do bytes match metadataList? algorithm below). Authors are encouraged to use strong hash functions, and to begin migrating to stronger hash functions as they become available.
</p>

			</section>
			<section id="priority">
<h4 title="Priority">3.2.2. 優先度</h4>

<p>
各~hash~algoの優先度は、
`妥当な~sri~hash~algo~token集合$における順序付けを介して指定される。
この集合~内で後に現れる~tokenほど強い~algoとされる。
◎
The prioritization of hash algorithms is specified via the ordering of their respective tokens in the valid SRI hash algorithm token set. Algorithms appearing earlier in that set are weaker than algorithms appearing later in that set.
</p>

<p>
現時点で指定されるとおり，
`SHA-256$hS よりも `SHA-384$hS の方が,
それよりも `SHA-512$hS の方が強い。
この仕様は、
現時点では，他の~hashing~algoを~supportしない。
◎
As currently specified, SHA-256 is weaker than SHA-384, which is in turn weaker than SHA-512. No other hashing algorithms are currently supported by this specification.
</p>

			</section>
		</section>
		<section id="response-verification-algorithms">
<h3 title="Response verification algorithms">3.3. 応答【の本体~data】を検証yする~algo</h3>

			<section id="apply-algorithm-to-response">
<h4 title="Apply algorithm to bytes">3.3.1. ~byte列に~algoを適用する</h4>

<div class="algo">
<p>
所与の
( `~byte列$ %~byte列, ~algo %~algo )
に対し：
</p>
<ol>
	<li>
%結果 ~LET %~byte列 に %~algo を適用した結果
◎
Let result be the result of applying algorithm to bytes.
</li>
	<li>
~RET %結果 に`~base64符号化法$を適用した結果
◎
Return the result of base64 encoding result.
</li>
</ol>
</div>

			</section>
			<section id="parse-metadata-section">
<h4 title="Parse metadata">3.3.2. ~metadataを構文解析する</h4>

<div class="algo">
<p>
`完全性~metadataを構文解析する@
~algoは、
所与の
( 文字列 %~metadata文字列 )
に対し：
◎
When asked to parse metadata given a string metadata, run the following steps:
</p>

<p class="note">注記：
この~algoは、
一連の［
~UAが解する~hash関数を伴う~hash式【`完全性~metadata$】
］を返す。
◎
Note: the algorithm returns a set of hash expressions whose hash functions are understood by the user agent.
</p>
<ol>
	<li>
<p>
%結果 ~LET 空~集合
◎
Let result be the empty set＼
</p>

<p class="trans-note">【
ではなく`~list$？
— 以下で %結果 に付加する演算は，`~list$用なので。
加えて，集合であるならば、［
2 つの`完全性~metadata$の同等性
］を定義する必要もあるが，指定されていない。
】</p>
◎
Let result be the empty set.
</li>
	<li>
%~token~list ~LET `区切子で厳密に分割する$( %~metadata文字列, `0020^U `SPACE^cn )
◎
↓</li>
	<li>
<p>
%~token~list を成す
~EACH( %~token )
に対し：
◎
For each item returned by splitting metadata on spaces:
</p>
		<ol>
			<li>
%式と~option群 ~LET `区切子で厳密に分割する$( %~item, `003F^U `?^smb )
◎
Let expression-and-options be the result of splitting item on U+003F (?).
</li>
			<li>
%~algo式 ~LET %式と~option群[ 0 ]
◎
Let algorithm-expression be expression-and-options[0].
</li>
			<li>
%~base64値 ~LET 空~文字列
◎
Let base64-value be the empty string.
</li>
			<li>
%~algoと値 ~LET `区切子で厳密に分割する$( %~algo式, `002D^U `-^smb )
◎
Let algorithm-and-value be the result of splitting algorithm-expression on U+002D (-).
</li>
			<li>
%~algo ~LET %~algoと値[ 0 ]
◎
Let algorithm be algorithm-and-value[0].
</li>
			<li>
~IF［
%~algoと値 の`~size$ ~GTE 2
］
⇒
%~base64値 ~SET %~algoと値[ 1 ]
◎
If algorithm-and-value[1] exists, set base64-value to algorithm-and-value[1].
</li>
			<li>
~IF［
%~algo は`妥当な~sri~hash~algo~token$でない
］
⇒
~CONTINUE
◎
If algorithm is not a valid SRI hash algorithm token, then continue.
</li>
			<li>
<p>
%~metadata ~LET 新たな`完全性~metadata$
— その
⇒＃
`~algo$iM ~SET %~algo,
`値$iM ~SET %~base64値
◎
Let metadata be the ordered map «["alg" → algorithm, "val" → base64-value]».
</p>

<p class="note">注記：
定義された~optionは無いので
（`§ 完全性~metadata＠#integrity-metadata-description$を見よ）、
%~metadata の`~option群$iMは設定されない。
将来の~versionにおいて，~optionが定義されたなら、
%式と~option群[ 1 ] が`~option群$iMとして用立てられ得る。
◎
Note: Since no options are defined (see the § 3.1 Integrity metadata), a corresponding entry is not set in metadata. If options are defined in a future version, expression-and-options[1] can be utilized as options.
</p>
			</li>
			<li>
%結果 に %~metadata を`付加する$
◎
Append metadata to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

			</section>
			<section id="get-the-strongest-metadata">
<h4 title="Get the strongest metadata from set.">3.3.3. 集合から最も強い~metadataを取得する</h4>

<div class="algo">
<p>
所与の
( `完全性~metadata$たちが成す集合 %集合 )
に対し：
</p>
<ol>
	<li>
<p>
%結果 ~LET 空~集合
</p>

<p class="trans-note">【
`完全性~metadataを構文解析する$ときと同様に，本当は`~list$？
】</p>
◎
Let result be the empty set＼
</li>
	<li>
%最強~index ~LET −1
◎
and strongest be the empty string.
◎
↓</li>
	<li>
<p>
%集合 を成す
~EACH( %~item )
に対し：
</p>
		<ol>
			<li>
%~token ~LET %~item の`~algo$iM
</li>
			<li>
~Assert：
%~token は`妥当な~sri~hash~algo~token$である。
</li>
			<li>
%~token ~LET `~ASCII小文字~化する$( %~token )
</li>
			<li>
%~index ~LET `妥当な~sri~hash~algo~token集合$内における %~token の~index
</li>
			<li>
~IF［
%~index ~LT %最強~index
］
⇒
~CONTINUE
</li>
			<li>
<p>
~IF［
%~index ~GT %最強~index
］：
</p>
				<ol>
					<li>
%最強~index ~SET %~index
</li>
					<li>
%結果 を`空にする$
</li>
				</ol>
</li>
			<li>
%結果 に %~item を`付加する$set
</li>
		</ol>
◎
For each item in set:
• Assert: item["alg"] is a valid SRI hash algorithm token.
• If result is the empty set, then:
•• Append item to result.
•• Set strongest to item.
•• Continue.
• Let currentAlgorithm be strongest["alg"], and currentAlgorithmIndex be the index of currentAlgorithm in the valid SRI hash algorithm token set.
• Let newAlgorithm be the item["alg"], and newAlgorithmIndex be the index of newAlgorithm in the valid SRI hash algorithm token set.
• If newAlgorithmIndex is less than currentAlgorithmIndex, continue.
• Otherwise, if newAlgorithmIndex is greater than currentAlgorithmIndex:
•• Set strongest to item.
•• Set result to « item ».
• Otherwise, newAlgorithmIndex and currentAlgorithmIndex are the same value. Append item to result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

			</section>
			<section id="does-response-match-metadatalist">
<h4 title="Do bytes match metadataList?">3.3.4. ~byte列は~metadata~listに合致するか？</h4>

<div class="algo">
<p>
所与の
( `~byte列$ %~byte列, 文字列 %~metadata~list )
に対し：
</p>
<ol>
	<li>
%構文解析-済み~metadata ~LET `完全性~metadataを構文解析する$( %~metadata~list )
◎
Let parsedMetadata be the result of parsing metadataList.
</li>
	<li>
~IF［
%構文解析-済み~metadata は`空$である
］
⇒
~RET ~T
◎
If parsedMetadata is empty set, return true.
</li>
	<li>
%~metadata ~LET `最も強い~metadataを取得する$( %構文解析-済み~metadata )
◎
Let metadata be the result of getting the strongest metadata from parsedMetadata.
</li>
	<li>
<p>
%~metadata を成す
~EACH( %~item )
に対し：
◎
For each item in metadata:
</p>
		<ol>
			<li>
%~algo ~LET %~item の`~algo$iM
◎
Let algorithm be the item["alg"].
</li>
			<li>
%期待される値 ~LET %~item の`値$iM
◎
Let expectedValue be the item["val"].
</li>
			<li>
%実際の値 ~LET `~byte列に~algoを適用する$( %~byte列, %~algo )
◎
Let actualValue be the result of applying algorithm to bytes .
</li>
			<li>
~IF［
%実際の値 ~EQ %期待される値
］
⇒
~RET ~T
◎
If actualValue is a case-sensitive match for expectedValue, return true.
</li>
		</ol>
	</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<p id="_multi-hash">
この~algoは、
複数個の［
妥当かつ強い~hash関数
］を受容することを~UAに許容する。
◎
This algorithm allows the user agent to accept multiple, valid strong hash functions.＼
</p>

<div class="example">
<p>
例えば，開発者は、
`script$e 要素を次のようにも記せる：
◎
For example, a developer might write a script element such as:
</p>

<pre class="lang-html">
&lt;script src="https://example.com/example-framework.js"
        integrity="sha384-`…( ~digest )…$V
                   sha384-`…( ~digest )…$V"
        crossorigin="anonymous"&gt;&lt;/script&gt;
</pre>

<p>
これは、
2 つの異なる内容~payload
— 1 個目, 2 個目どちらかの `SHA-384$hS ~hash値に合致するもの —
を~UAに受容させる。
◎
which would allow the user agent to accept two different content payloads, one of which matches the first SHA-384 hash value and the other matches the second SHA-384 hash value.
</p>
</div>

<p class="note">注記：
~UAは、
この~algoの結果を改変することを利用者に許容してよい
— ［
利用者-選好,
~bookmarklet,
第三者-主体による~UAに対する追加,
その他の同類の仕組み
］を介して。
例えば、
`HTTPS Everywhere＠https://www.eff.org/https-everywhere$en
の様な拡張により生成される~redirectは、
資源の［
~HTTPS, ~HTTP
］~versionが相違する場合でも，正しく読込んで実行する。
◎
Note: User agents may allow users to modify the result of this algorithm via user preferences, bookmarklets, third-party additions to the user agent, and other such mechanisms. For example, redirects generated by an extension like HTTPS Everywhere could load and execute correctly, even if the HTTPS version of a resource differs from the HTTP version.
</p>

<p class="note">注記：
下位資源の完全性には、
~CORSが要求される
— ~CORSを伴わずにそれを利用しようとする試みるのは、
論理的な誤りである。
それが生じた場合、
~UAには［
開発者~consoleに，この失敗を説明する警告~messageを報告すること
］が奨励される。
`Fetch$r
◎
Note: Subresource Integrity requires CORS and it is a logical error to attempt to use it without CORS. User agents are encouraged to report a warning message to the developer console to explain this failure. [Fetch]
</p>

			</section>
		</section>
		<section id="verification-of-html-document-subresources">
<h3 title="Verification of HTML document subresources">3.4. ~HTML文書の下位資源に対する検証y</h3>

<p>
様々な~HTML要素が，［
文書の中へ埋込まれる／文書の文脈において実行される
］ことになる資源を要請する。
その種の要素に対し，完全性~metadataを~supportする一環として、［
`link$e ／ `script$e
］要素には，新たな内容~属性 `integrity$a が追加される。
`HTML$r
◎
A variety of HTML elements result in requests for resources that are to be embedded into the document, or executed in its context. To support integrity metadata for some of these elements, a new integrity attribute is added to the list of content attributes for the link and script elements. [HTML]
</p>

<p class="note">注記：
この仕様の将来の改訂版は、
アリなすべての下位資源
— すなわち，次に挙げる要素 —
に対しても，完全性の~supportを含める見込みが高い
⇒
`a^e, `audio^e, `embed^e, `iframe^e, `img^e, `link^e, `object^e, `script^e,
`source^e, `track^e, `video^e
◎
Note: A future revision of this specification is likely to include integrity support for all possible subresources, i.e., a, audio, embed, iframe, img, link, object, script, source, track, and video elements.
</p>

		</section>
		<section id="the-integrity-attribute">
<h3 title="The integrity attribute">3.5. `integrity^a 属性</h3>

<p>
`integrity^a 属性は、
要素~用の`完全性~metadata$を表現する。
この属性の値は、
空~文字列か, または［
1 個以上の，次の~ABNF `ABNF$r 文法に則って妥当な~metadata
］を含んでいなければナラナイ
◎
The integrity attribute represents integrity metadata for an element. The value of the attribute MUST be either the empty string, or at least one valid metadata as described by the following ABNF grammar:
</p>

<pre class="bnf">
`integrity-metadata@P
	= *`WSP$P `hash-with-options$P *( 1*`WSP$P `hash-with-options$P ) *`WSP$P
	/ *`WSP$P
`hash-with-options@P
	= `hash-expression$P *("?" `option-expression$P)
`option-expression@P
	= *`VCHAR$P
`hash-expression@P
	= `hash-algorithm$P "-" `base64-value$P
</pre>

<p>
`option-expression$P は、
各 `hash-expression$P ごとに結付けられ，当の `hash-expression^P に限り適用される。
◎
option-expressions are associated on a per hash-expression basis and are applied only to the hash-expression that immediately precedes it.
</p>

<p>
~UAは、
将来の~optionと全部的に前方-互換であり続けるようにするため，自身が認識しない `option-expression$P を無視するモノトスル。
◎
In order for user agents to remain fully forwards compatible with future options, the user agent MUST ignore all unrecognized option-expressions.
</p>

<p class="note">注記：
構文~内では `option-expression$P が予約されているが、
定義された~optionはまだないことに注意。
この仕様の将来の~versionでは，~optionに対しより特定な構文を定義することになる見込みが高いので、
アリな限り広く定義されている。
◎
Note: Note that while the option-expression has been reserved in the syntax, no options have been defined. It is likely that a future version of the spec will define a more specific syntax for options, so it is defined here as broadly as possible.
</p>

		</section>
		<section id="the-integrity-link-processing-option">
<h3 title="The integrity link processing option">3.6. `integrity^P ~link処理~option</h3>

<p>
`Link$h ~HTTP応答~headerには、
`完全性~metadata$も，名前 `integrity^P を伴う~link~parameter【 `link-param$P 】として指定できる
— それは、
要素の `integrity^a 属性 に適用される `integrity-metadata$P と同じ文法を利用して指定されなければナラナイ。
例えば：
◎
Integrity metadata can also be specified for `link` HTTP response headers as an integrity link parameter which MUST be specified using the same integrity-metadata grammar that applies to integrity attributes on elements. For example:
</p>

<div class="example">
<pre class="lang-http">
Link: &lt;/style.css&gt;; rel=preload; as=style;  crossorigin="anonymous"; integrity="sha256-`…( ~digest )…$V"
</pre>
</div>

		</section>
		<section id="handling-integrity-violations">
<h3 title="Handling integrity violations">3.7. 完全性~違反の取扱い</h3>

<p>
~UAは、
完全性~検査に失敗した応答を［
具現化する／実行する
］のを拒否して，
代わりに`~network~error$ `Fetch$r を返すことになる。
◎
The user agent will refuse to render or execute responses that fail an integrity check, instead returning a network error as defined in Fetch [Fetch].
</p>

<p class="note">注記：
完全性~検査の失敗-時には、
`error^et ~eventが発火される。
開発者は、
正準的~fallback資源
（例： ~CDNから~serveされていない，たぶん［
二次的な，信用-済みだが より低速な~source
］からの資源など）
を供するよう望むなら、［
この `error^et ~eventを~catchして，失敗した当の資源を異なるものに置換する
］ような適切な~handlerを供せる。
◎
Note: On a failed integrity check, an error event is fired. Developers wishing to provide a canonical fallback resource (e.g., a resource not served from a CDN, perhaps from a secondary, trusted, but slower source) can catch this error event and provide an appropriate handler to replace the failed resource with a different one.
</p>

		</section>
		<section id="integrity-policy-section">
<h3 title="Integrity-Policy">3.8. 完全性~施策~header</h3>

<p>
［
`Integrity-Policy^h ／ `Integrity-Policy-Report-Only^h
］~HTTP~header
— これらは、
【この訳においては，】完全性~施策~headerと総称される —
は、［
文書が読込む下位資源のうち，ある種の`行先$rqを成すものすべて
］に対し［
完全性~metadata要件に関する施策を施行する
］ことを可能化する。
◎
The Integrity-Policy and Integrity-Policy-Report-Only HTTP headers enable a document to enforce a policy regarding the integrity metadata requirements on all the subresources it loads of certain destinations.
</p>

<p>
完全性~施策~headerは、
`有構造~header$であり，
その`~field値$の型は`~sf辞書$である
— それを成す各~entry【！~member】の値は、［
`~sf内縁~list$／`~sf~token$
］である。
`RFC9651$r
◎
The headers' value is a Dictionary [RFC9651], with every member-value being an inner list of tokens.
</p>

<p>
`~source@
は、
文字列であり，
アリな値は `inline^l に限られる。
◎
A source is a string. The only possible value for it is "inline".
</p>

<p>
`行先@
は、
文字列であり，
アリな値は `script^l に限られる。
◎
A destination is a string. The only possible value for it is "script".
</p>

<p>
`完全性~施策~構造体@
は、
次に挙げる~itemからなる`構造体$である：
◎
An integrity policy struct, is a struct that contains the following:
</p>
<ul>
	<li>
`~source群@iPs
⇒
`~source$たちが成す`~list$
— 初期~時は空とする。
◎
sources, a list of sources, initially empty.
</li>
	<li>
`阻止される行先~群@iPs
⇒
`行先$たちが成す`~list$
— 初期~時は空とする。
◎
blocked destinations, a list of destinations, initially empty.
</li>
	<li>
`報告先~群@iPs
⇒
文字列たちが成す`~list$
— 初期~時は空とする。
◎
endpoints, a list of strings, initially empty.
</li>
</ul>

<div class="algo">
<p>
`完全性~施策を処理する@
~algoは、
所与の
( `~header~list$ %~header群, `~header名$ %~header名 )
に対し：
◎
When processing an integrity policy, with a header list headers and a header name headerName, do the following:
</p>
<ol>
	<li>
%完全性~施策 ~LET 新たな`完全性~施策~構造体$
◎
Let integrityPolicy be a new integrity policy struct.
</li>
	<li>
%辞書 ~LET %~header群 から`有構造~field値を取得する$( %~header名, `辞書^i )
◎
Let dictionary be the result of getting a structured field value from headers given headerName and "dictionary".
</li>
	<li>
<p>
~IF［
%辞書 ~EQ ~NULL
］
⇒
~RET ~NULL
</p>

<p class="trans-note">【
この段は、
この訳による補完
（原文は、
この事例をきちんと取扱っていない）
— それに伴い，この~algoを利用している箇所も改めている。
】</p>
	</li>
	<li>
%~source群 ~LET %辞書[ `sources^l ]
◎
↓</li>
	<li>
~IF［
%~source群 ~EQ ε
］~OR［
`inline^l ~IN %~source群
］
⇒
%完全性~施策 の`~source群$iPsに `inline^l を`付加する$
◎
If dictionary["sources"] does not exist or if its value contains "inline", append "inline" to integrityPolicy’s sources.
</li>
	<li>
%阻止される行先~群 ~LET %辞書[ `blocked-destinations^l ]
◎
↓</li>
	<li>
~IF［
%阻止される行先~群 ~NEQ ε
］~AND［
`script^l ~IN %阻止される行先~群
］
⇒
%完全性~施策 の`阻止される行先~群$iPsに `script^l を`付加する$
◎
If dictionary["blocked-destinations"] exists:
• If its value contains "script", append "script" to integrityPolicy’s blocked destinations.
</li>
	<li>
%報告先~群 ~LET %辞書[ `endpoints^l ]
◎
↓</li>
	<li>
~IF［
%報告先~群 ~NEQ ε
］
⇒
%完全性~施策 の`報告先~群$iPs ~SET %報告先~群
◎
If dictionary["endpoints"] exists:
• Set integrityPolicy’s endpoints to dictionary['endpoints'].
</li>
	<li>
~RET %完全性~施策
◎
Return integrityPolicy.
</li>
</ol>
</div>

			<section id="parse-integrity-policy-headers-section">
<h4 title="Parse Integrity-Policy headers">3.8.1. 完全性~施策~headerを構文解析する</h4>

<div class="algo">
<p>
`完全性~施策~headerを構文解析する@
~algoは、
所与の
( `応答$ %応答, `施策~容器$ %容器 )
に対し：
◎
To parse Integrity-Policy headers, given a Response response and a policy container container, do the following:
</p>
<ol>
	<li>
%~header群 ~LET %応答 の`~header~list$rs
◎
Let headers be response’s header list.
</li>
	<li>
%施策 ~LET `完全性~施策を処理する$( %~header群, `integrity-policy^bl )
◎
↓</li>
	<li>
~IF［
%施策 ~NEQ ~NULL
］
⇒
%容器 の`完全性~施策$ ~SET %施策
◎
If headers contains integrity-policy, set container’s integrity policy be the result of running processing an integrity policy with the corresponding header value.
</li>
	<li>
%報告のみ施策 ~LET `完全性~施策を処理する$( %~header群, `integrity-policy-report-only^bl )
◎
↓</li>
	<li>
~IF［
%報告のみ施策 ~NEQ ~NULL
］
⇒
%容器 の`報告のみの完全性~施策$ ~SET %報告のみ施策
◎
↑↑ If headers contains integrity-policy-report-only, set container’s report only integrity policy be the result of running processing an integrity policy with the corresponding header value.
</li>
</ol>
</div>

			</section>
			<section id="should-request-be-blocked-by-integrity-policy-section">
<h4 title="Should request be blocked by Integrity Policy">3.8.2. 要請は完全性~施策により阻止されるべきか？</h4>

<div class="algo">
<p>
`要請は完全性~施策により阻止されるべきか？@
を決定する~algoは、
所与の
( `要請$ %要請 )
に対し：
◎
To determine should request be blocked by integrity policy, given a request request, do the following:
</p>
<ol>
	<li>
%施策~容器 ~LET %要請 の`施策~容器$rq
◎
Let policyContainer be request’s policy container.
</li>
	<li>
%構文解析-済み~metadata ~LET `完全性~metadataを構文解析する$( %要請 の`完全性~metadata$rq )
◎
Let parsedMetadata be the result of calling parse metadata with request’s integrity metadata.
</li>
	<li>
~IF［
%構文解析-済み~metadata は`空$でない
］~AND［
%要請 の`~mode$rq ~IN { `cors^l, `same-origin^l }
］
⇒
~RET `許容される^i
◎
If parsedMetadata is not the empty set and request’s mode is either "cors" or "same-origin", return "Allowed".
◎
↓ Let policy be policyContainer’s integrity policy.
◎
↓ Let reportPolicy be policyContainer’s report only integrity policy.
◎
↓ （不要）If both policy and reportPolicy are empty integrity policy structs, return "Allowed".
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%要請 の`~client$rq ~EQ ~NULL
【この条件は、この訳による補完。】
</li>
			<li>
%要請 の`~client$rqの`大域~obj$enVは［
`Window$I ／ `WorkerGlobalScope$I
］でない
</li>
		</ul>
<p>
…ならば
⇒
~RET `許容される^i
</p>
◎
Let global be request’s client’s global object.
◎
If global is not a Window nor a WorkerGlobalScope, return "Allowed".
</li>
	<li>
%結果 ~LET `許容される^i
◎
↓</li>
	<li>
%報告のみか ~LET ~F
◎
↓</li>
	<li>
<p>
« %施策~容器 の`完全性~施策$, %施策~容器 の`報告のみの完全性~施策$ »
を成す
~EACH( %施策 )
に対し：
</p>
		<ol>
			<li>
<p>
~IF［
`inline^l ~IN %施策 の`~source群$iPs
］~AND［
%要請 の`行先$rq ~IN %施策 の`阻止される行先~群$iPs
］：
</p>
				<ol>
					<li>
`違反を報告する$( %要請, %施策, %報告のみか )
</li>
					<li>
~IF［
%報告のみか ~EQ ~F
］
⇒
%結果 ~SET `阻止される^i
</li>
				</ol>
			</li>
			<li>
%報告のみか ~SET ~T
</li>
		</ol>
◎
Let block be a boolean, initially false.
◎
Let reportBlock be a boolean, initially false.
◎
If policy’s sources contains "inline" and policy’s blocked destinations contains request’s destination, set block to true.
◎
If reportPolicy’s sources contains "inline" and reportPolicy’s blocked destinations contains request’s destination, set reportBlock to true.
◎
If block is true or reportBlock is true, then report violation with request, block, reportBlock, policy and reportPolicy.
</li>
	<li>
~RET %結果
◎
If block is true, then return "Blocked"; otherwise "Allowed".
</li>
</ol>
</div>

			</section>
			<section id="report-violations">
<h4 title="Report violations">3.8.3. 違反を報告する</h4>

<pre class="idl">
[`Exposed$=Window]
interface `IntegrityPolicyViolationReportBody@I : `ReportBody$I {
  [`Default$] `object$ `toJSON@m();
  readonly attribute `USVString$ `documentURL@m;
  readonly attribute `USVString$ `blockedURL@m;
  readonly attribute `USVString$ `destination@m;
  readonly attribute `boolean$   `reportOnly@m;
};
</pre>

<div class="algo">
<p>
`違反を報告する@
~algoは、
所与の
( `要請$ %要請, `完全性~施策~構造体$ %施策, 真偽値 %報告のみか )
に対し：
◎
To report violation given a Request request, a boolean block, a boolean reportBlock, an integrity policy struct policy, and an integrity policy struct reportPolicy, do the following:
</p>

<p class="trans-note">【
この~algoは、
原文では， %報告のみか が［
~T の場合, ~F の場合
］を一括して遂行しているが、
この訳では，別々に遂行する（この~algoを利用する箇所で，それら各場合を遂行する）よう改める。
】</p>

<ol>
	<li>
%設定群~obj ~LET %要請 の`~client$rq
◎
↓</li>
	<li>
~Assert：
%設定群~obj ~NEQ ~NULL
◎
Assert: request’s client is not null.
◎
Let settingsObject be request’s client.
</li>
	<li>
%大域~obj ~LET %設定群~obj の`大域~obj$enV
◎
Let global be settingsObject’s global object.
</li>
	<li>
~Assert：
%大域~obj は［
`Window$I ／ `WorkerGlobalScope$I
］である。
◎
Assert: global is a Window or a WorkerGlobalScope.
</li>
	<li>
%~URL ~LET %大域~obj に応じて
⇒＃
`Window$I であるならば %大域~obj に`結付けられた文書$の`~URL$doc／
`WorkerGlobalScope$I であるならば %大域~obj の`~URL$wG
◎
Let url be null.
◎
If global is a Window, set url to global’s associated Document’s URL.
◎
If global is a WorkerGlobalScope, set url to global’s URL.
</li>
	<li>
~Assert：
%~URL は`~URL~record$である
◎
Assert: url is a URL.
</li>
	<li>
%文書~URL ~LET `報告~内の利用-用に~URLを剥ぐ$( %~URL )
◎
Let documentURL be the result of strip URL for use in reports on url.
</li>
	<li>
%阻止された~URL ~LET `報告~内の利用-用に~URLを剥ぐ$( %要請 の`~URL$rq )
◎
Let blockedURL be the result of strip URL for use in reports on request’s URL.
</li>
	<li>
<p>
%施策 の`報告先~群$iPsを成す
~EACH( %報告先 )
に対し：
</p>
		<ol>
			<li>
%本体 ~LET `新たな~obj$( `IntegrityPolicyViolationReportBody$I )
</li>
			<li>
%本体 の各種~属性を次に従って初期化する
⇒＃
`documentURL$m ~SET %文書~URL,
`blockedURL$m ~SET %阻止された~URL,
`destination$m ~SET %要請 の`行先$rq,
`reportOnly$m ~SET %報告のみか
</li>
			<li>
`報告を生成して~queueする$( ↓ )
⇒＃
%設定群~obj,
`integrity-policy-violation^l,
%報告先,
%本体
</li>
		</ol>
◎
If block is true, for each endpoint in policy’s endpoints:
• Let body be a new IntegrityPolicyViolationReportBody, initialized as follows:
•• documentURL
••• documentURL
•• blockedURL
••• blockedURL
•• destination
••• request’s destination
•• reportOnly
••• false
• Generate and queue a report with the following arguments:
•• context
••• settingsObject
•• type
••• "integrity-policy-violation"
•• destination
••• endpoint
•• data
••• body
◎
If reportBlock is true, for each endpoint in reportPolicy’s endpoints:
• Let reportBody be a new IntegrityPolicyViolationReportBody, initialized as follows:
•• documentURL
••• documentURL
•• blockedURL
••• blockedURL
•• destination
••• request’s destination
•• reportOnly
••• true
• Generate and queue a report with the following arguments:
•• context
••• settingsObject
•• type
••• "integrity-policy-violation"
•• destination
••• endpoint
•• data
••• reportBody
</li>
</ol>
</div>

			</section>
			<section id="integration">
<h4 title="Integration">3.8.4. 【他の仕様への】統合</h4>

<p>
各`施策~容器$は、
次に挙げる~itemも有する：
◎
A policy container has extra items:
</p>
<ul>
	<li>
`完全性~施策@
⇒
ある`完全性~施策~構造体$
◎
integrity policy, an integrity policy struct.
</li>
	<li>
`報告のみの完全性~施策@
⇒
ある`完全性~施策~構造体$
◎
report only integrity policy, an integrity policy struct.
</li>
</ul>

<p>
`~fetch応答から施策~容器を作成する$ ~algo `HTML$r を成す “%結果 を返す段” 【最後の段】の前に，次を走らす段を追加する
⇒
`完全性~施策~headerを構文解析する$( %応答, %結果 )
◎
Add an extra step to create a policy container from a fetch response before it returns, that runs parse Integrity-Policy headers with response and result.
</p>

<p>
`~main~fetch$ `FETCH$r を成す段 7 を成す条件~群に次の条件を追加する
（満たされる場合、`~network~error$を返すことになる）
⇒
`要請は完全性~施策により阻止されるべきか？$( %要請 ) ~EQ `阻止される^i 
◎
Expand step 7 of main fetch to call should request be blocked by integrity policy and return a network error if it returns "Blocked".
</p>

			</section>
		</section>
	</section>
	<section id="proxies">
<h2 title="Proxies">4. ~proxy</h2>

<div class="p">
<p>
応答を改変するような~proxyその他の媒介~serverを最適化するときは、
当の応答に結付けられた~digestが新たな内容にも同期cし続けることを確保しなければナラナイ。
選択肢としては、
次が挙げられる：
</p>
<ul>
	<li>
資源に結付けられた`完全性~metadata$が更新されることを確保する。
</li>
	<li>
単純に，~page作者が完全性の検証yを要請した際には，当の資源の正準的~versionのみを送達する。
</li>
</ul>
◎
Optimizing proxies and other intermediate servers which modify the responses MUST ensure that the digest associated with those responses stays in sync with the new content. One option is to ensure that the integrity metadata associated with resources is updated. Another would be simply to deliver only the canonical version of resources for which a page author has requested integrity verification.
</div>

<p>
媒介~serverに伝わり易くするため、
資源を~serveしている~serverは，自身が送信する資源に，値 `no-transform$dir を伴う `Cache-Control$h ~headerを伴わせるベキである。
◎
To help inform intermediate servers, those serving the resources SHOULD send along with the resource a Cache-Control header with a value of no-transform.
</p>

	</section>
	<section id="security-considerations">
<h2 title="Security and Privacy Considerations">5. ~securityと~privacyの考慮点</h2>

◎非規範的

		<section id="non-secure-contexts-remain-non-secure">
<h3 title="Non-secure contexts remain non-secure">5.1. ~secureでない文脈は~secureでないであり続ける</h3>

<p>
［
`~secureな文脈$enVでない文脈
— ~HTTP【~HTTPSでない】~pageなど —
により送達される`完全性~metadata$
］が保護する生成元は，［
外部~資源を~hostしている~serverの弱体化に抗する
］ことに限られる。
~network攻撃者は、
~hashの検証-対象である応答を，その経路上で改ざんできるのと同じく，~~元の~digestも改ざんできる
（あるいは，それを除去するなど，文書に対し何でもできる）。
したがって，作者は、
完全性~metadataを`~secureな文脈$enV下にある場合に限り送達するベキである。
`~webの~secure化法＠https://www.w3.org/2001/tag/doc/web-https$も見よ。
◎
Integrity metadata delivered by a context that is not a Secure Context such as an HTTP page, only protects an origin against a compromise of the server where an external resources is hosted. Network attackers can alter the digest in-flight (or remove it entirely, or do absolutely anything else to the document), just as they could alter the response the hash is meant to validate. Thus, it is recommended that authors deliver integrity metadata only to a Secure Context. See also Securing the Web.
</p>

		</section>
		<section id="hash-collision-attacks">
<h3 title="Hash collision attacks">5.2. ~hash衝突~攻撃</h3>

<p>
~digestの強さは、
それを生成する~hash関数に基づく。
~UAには、［
弱いことが既知である~hashing関数~用の~supportは拒否すること
］, および［
~supportする~algoを，衝突耐性があることが既知であるものに制限すること
］が推奨される。
推奨されない~hashing関数の例としては、
`MD5^hS や `SHA-1^hS が挙げられる。
これを書いている時点では、
`SHA-384$hS は良好な~~基準である。
◎
Digests are only as strong as the hash function used to generate them. It is recommended that user agents refuse to support known-weak hashing functions and limit supported algorithms to those known to be collision resistant. Examples of hashing functions that are not recommended include MD5 and SHA-1. At the time of writing, SHA-384 is a good baseline.
</p>

<p>
更には、
~UAには，［
定期的に，自身が~supportしている~hash関数を評価し直すこと
］, および［
~secureでないと~~判明した関数に対しては，~supportを非推奨にすること
］が推奨される。
~hash関数は，時を経て［
期待されるより ずっと弱い, あるいは 一部の事例では壊れている
］ものと~~判明することがあるので、
~UAは，開発にあたって そのことを自覚し続けることが重要である。
◎
Moreover, it is recommended that user agents re-evaluate their supported hash functions on a regular basis and deprecate support for those functions shown to be insecure. Over time, hash functions may be shown to be much weaker than expected and, in some cases, broken, so it is important that user agents stay aware of these developments.
</p>

		</section>
		<section id="cross-origin-data-leakage">
<h3 title="Cross-origin data leakage">5.3. 非同一-生成元~data漏洩e</h3>

<p>
この仕様は、
完全性が保護される非同一-生成元な要請には，［
`~CORS~protocol＠~FETCH#cors-protocol$を利用して，
資源の内容が要請-者と明示的に共有されることを確保する
］ことを要求する。
この要件が無ければ、
攻撃者は`同一-生成元~施策＠https://www.w3.org/Security/wiki/Same_Origin_Policy$に違反することもでき、［
非同一-生成元な資源が，ある種の内容を有するかどうか
］を決定できてしまう：
◎
This specification requires integrity-protected cross-origin requests to use the CORS protocol to ensure that the resource’s content is explicitly shared with the requestor. If that requirement were omitted, attackers could violate the same-origin policy and determine whether a cross-origin resource has certain content.
</p>
<ul>
	<li>
攻撃者は、
既知な~digestで資源の読込nを試みながら，その失敗を注視する。
読込nに失敗したなら、
応答はその~hashに合致しないものと推定でき，それにより その内容についての洞察を得られる。
これは例えば、
利用者が特定0の~serviceに~log-inしたかどうかを露呈するかもしれない。
◎
Attackers would attempt to load the resource with a known digest, and watch for load failures. If the load fails, the attacker could surmise that the response didn’t match the hash and thereby gain some insight into its contents. This might reveal, for example, whether or not a user is logged into a particular service.
</li>
	<li>
<p>
更には，攻撃者は、
静的な資源~内の特定の値を総当たりできる。
◎
Moreover, attackers could brute-force specific values in an otherwise static resource.＼
</p>

<div class="example">
<p>
次の様な~JSON応答を考える：
◎
Consider a JSON response that looks like this:
</p>

<pre class="lang-json">
{'status': 'authenticated', 'username': 'admin'}
</pre>

<p>
攻撃者は、
様々な共通的な~username（ `username^c ）から，応答~用の~hashたちを予め算出しておいて、
それらの~hashを順々に指定しながら繰返し文書の読込nを試みれる。
読込nに成功したなら、
~usernameを正しく推測できたことが確認されたことになる。
◎
An attacker could precompute hashes for the response with a variety of common usernames, and specify those hashes while repeatedly attempting to load the document. A successful load would confirm that the attacker has correctly guessed the username.
</p>
</div>

	</li>
</ul>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕様を成す かなりの部分は、
`Gervase Markham^en 氏による
`Link Fingerprints＠https://www.gerv.net/security/link-fingerprints/$en
の概念, および WHATWG による
`Link Hashes＠https://wiki.whatwg.org/wiki/Link_Hashes$en
から着想を得た。
◎
Much of the content here is inspired heavily by Gervase Markham’s Link Fingerprints concept as well as WHATWG’s Link Hashes.
</p>

<p>
この仕様の初期~versionに貴重な貢献された `Mike West^en 氏に特別な謝意を。
貴重な~feedbackを寄せられた次の方々にも：
◎
A special thanks to Mike West for his invaluable contributions to the initial version of this spec.＼
</p>

<div lang="en">
Thanks to Brad Hill, Anne van Kesteren, Jonathan Kingston, Mark Nottingham, Sergey Shekyan , Dan Veditz, Eduardo Vela, Tanvi Vyas, and Michal Zalewski for providing invaluable feedback.
</div>

	</section>
</main></div>
