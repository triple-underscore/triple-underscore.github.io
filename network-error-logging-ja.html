<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Network Error Loggingï¼ˆæ—¥æœ¬èªè¨³ï¼‰</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
.report {
	color: var(--text-color-2);
}

samp {
	white-space: nowrap;
	background: var(--bg-color-1);
	margin-left: 0.5em;
	margin-right: 0.5em;
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~ä¸€-é¿†ã‚-ã‚“]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('ï¼ ');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


â—â—options

spec_date:2025-05-05
trans_update:2025-05-14
source_checked:230703
page_state_key:WEBAPPSEC
original_url:https://w3c.github.io/network-error-logging/
page_state_key:WEBAPPSEC
site_nav:network,security,performance
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
	conformance:w3c
copyright:2023,permissive
trans_1st_pub:2015-04-11


â—â—class_map
h:header
e:element
st:status
P:production
jt:js-type
jv:js-value

â—â—tag_map
c:code
m:code
st:code
jt:code
jv:code
h:code
e:code
P:var
v:var
i:i
s:samp
em:em

â—â—original_id_map

â—â—mdn_urls
	dfn-nel:HTTP/Headers/NEL

â—â—link_map

st.4xx:~HTTPsem#status.4xx
st.5xx:~HTTPsem#status.5xx
st.200:~HTTPsem#status.200
st.304:~HTTPsem#status.304

h.NEL:#dfn-nel
h.Set-Cookie:~HTTPcookie#sane-set-cookie
h.Report-To:#_report-to
h.Reporting-Endpoints:~REPORTING#reporting-endpoints
h.Content-Length:~HTTPsem#field.content-length
h.ETag:~HTTPsem#field.etag
h.If-None-Match:~HTTPsem#field.if-none-match

c.failure_fraction:#dfn-failure_fraction
c.include_subdomains:#dfn-include_subdomains
c.max_age:#dfn-max_age
c.success_fraction:#dfn-success_fraction
c.report_to:#dfn-report_to
c.request_headers:#dfn-request_headers
c.response_headers:#dfn-response_headers

	ï¼ https://datatracker.ietf.org/doc/html/draft-reschke-http-jfv#json-field-value

	â—ç”¨èª
~networkè¦è«‹:#dfn-network-requests
ç›¸:#dfn-phase
~DNSè§£æ±º:#dfn-dns-resolution
~secureæ¥ç¶šã®ç¢ºç«‹:#dfn-secure-connection-establishment
è¦è«‹ã¨å¿œç­”ã®ä¼é€:#dfn-transmission-of-request-and-response


~NELæ–½ç­–:#dfn-nel-policies
nP.å—ä¿¡ã—ãŸ~IP~address:#dfn-received-ip-address
nP.ç”Ÿæˆå…ƒ:#dfn-policy-origin
nP.ä¸‹ä½domainã‚’å«ã‚€ã‹:#dfn-subdomains
nP.å ±å‘Šç”¨~group:#dfn-reporting-group
nP.æœ‰åŠ¹ç§’æ•°:#dfn-ttl
nP.ä½œæˆæ™‚åˆ»:#dfn-creation
nP.è¦è«‹~headerå~list:#dfn-policy-request-headers
nP.å¿œç­”~headerå~list:#dfn-policy-response-headers

è¦è«‹~headerãŸã¡ã‚’æŠ½å‡ºã™ã‚‹:#extract-request-headers
å¿œç­”~headerãŸã¡ã‚’æŠ½å‡ºã™ã‚‹:#extract-response-headers
~network~errorå ±å‘Šã‚’ç”Ÿæˆã™ã‚‹:#generate-a-network-error-report

å¤±åŠ¹ã—ãŸ:#dfn-expired
å¤±åŠ¹ã—ã¦:#dfn-expired
éæ–°é®®:#dfn-stale

è¦‹æœ¬æŠ½å‡ºç‡:#dfn-sampling-rate
æˆåŠŸ~æ™‚ã®è¦‹æœ¬æŠ½å‡ºç‡:#dfn-successful-sampling-rate
å¤±æ•—~æ™‚ã®è¦‹æœ¬æŠ½å‡ºç‡:#dfn-failure-sampling-rate

æˆåŠŸ-:#dfn-succeed
æˆåŠŸã—ãŸ:#dfn-succeed
å¤±æ•—-:#dfn-fail
å¤±æ•—ã—ãŸ:#dfn-fail
	~fail:#dfn-fail
	~failures:#dfn-fail
	~succeeded:#dfn-succeed


~network~error:#dfn-network-errors
~network~errorå ±å‘Š:#dfn-network-error-reports
nE.ç¨®åˆ¥:#dfn-types
nE.ç›¸:#dfn-type-phase

æ–½ç­–~cache:#dfn-policy-cache
è¦è«‹~ç”¨ã®æ–½ç­–ã‚’é¸ã¶:#choose-a-policy-for-a-request
	Â§~Predefined~network~error~types:#predefined-network-error-types
	Â§~DNSç’°å¢ƒè¨­å®šã®èª¤ã‚Š:#dns-misconfiguration
	Â§~Origins~with~multiple~IP~address:#origins-with-multiple-ip-addresses
	Â§~Privacy~Considerations:#privacy-considerations

	â—ç”¨èªï¼ˆFETCH
~HTTP~network~fetch:~FETCH#concept-http-network-fetch
	~HTTP~network~fetch:~FETCH#http-network-fetch
~CORSäºˆè¡Œ~è¦è«‹:~FETCH#cors-preflight-request
~HTTP~network~fetch:~FETCH#http-network-fetch

è¦è«‹:~FETCH#concept-request
rq.~client:~FETCH#concept-request-client
	rq.~referrer:~FETCH#concept-request-referrer
rq.äºˆç´„-æ¸ˆã¿~client:~FETCH#concept-request-reserved-client
rq.~header~list:~FETCH#concept-request-header-list
rq.~URL:~FETCH#concept-request-url
rq.ç”Ÿæˆå…ƒ:~FETCH#concept-request-origin
å¿œç­”:~FETCH#concept-response
rs.~header~list:~FETCH#concept-response-header-list

hd.åå‰:~FETCH#concept-header-name
hd.å€¤:~FETCH#concept-header-value
åå‰ã«æŒã¤~header:~FETCH#_headers-of-name
	åå‰ã«æŒã¤~header:~FETCH#header-list-contains
~networkåŒºåˆ†~key:~FETCH#network-partition-key
	ï¼ ~FETCH#request-determine-the-network-partition-key
è¦è«‹ã®~networkåŒºåˆ†~keyã‚’æ±ºå®šã™ã‚‹:~FETCH#request-determine-the-network-partition-key
~networkåŒºåˆ†~keyã‚’æ±ºå®šã™ã‚‹:~FETCH#determine-the-network-partition-key

	â—ç”¨èªï¼ˆå¤–éƒ¨
url.ç´ ç‰‡:~URL1#concept-url-fragment
url.~path:~URL1#concept-url-path
url.~query:~URL1#concept-url-query
~URLã‚’ç›´åˆ—åŒ–ã™ã‚‹:~URL1#concept-url-serializer
~IP~address:~URL1#ip-address

å£~æ™‚è¨ˆã®å®‰å…¨ã§ãªã„ç¾åœ¨ã®æ™‚åˆ»:~HRTIME#wall-clock-unsafe-current-time
	ã‹ã‚‰ã€œã¾ã§ã®æ‰€è¦æ™‚é–“:~HRTIME#dfn-duration-from

å ±å‘Š:~REPORTING#report
å ±å‘Š~æœ¬ä½“:~REPORTING#report-body
å ±å‘Š~ç¨®åˆ¥:~REPORTING#report-type
å ±å‘Šå…ˆ~group:#_endpoint-group
	å ±å‘Šå…ˆ~group:~REPORTING#endpoint-group
è¡Œå…ˆ:~REPORTING#report-destination
å ±å‘Šç”¨~è¦³æ¸¬å™¨ã‹ã‚‰å¯è¦–:~REPORTING#visible-to-reportingobservers
	å ±å‘Šç”¨~è¦³æ¸¬å™¨ã‹ã‚‰å¯è¦–:~REPORTING#visible-to-reporting-observers

~networkå ±å‘Šã‚’ç”Ÿæˆã™ã‚‹:~NETWORK-REPORTING#generate-a-network-report

~domainå:~RFCx/rfc1034#section-3.1
~domainåå‰ç©ºé–“~tree:~RFCx/rfc1034#section-3.1
~DNSè§£æ±ºå™¨:~RFCx/rfc1034#section-5

ç”Ÿæˆå…ƒ:~ORIGIN#origin
åŒä¸€-ç”Ÿæˆå…ƒ:~ORIGIN#same-origin
åŒã˜~site:~ORIGIN#concept-site-same-site

	ï¼ ~HTMLnavigator#dom-navigator-online

	~network~protocol:~RESOURCE-TIMING#dom-performanceresourcetiming-nexthopprotocol
	m.nextHopProtocol:~RESOURCE-TIMING#dom-performanceresourcetiming-nexthopprotocol


	SECURE-CONTEXT:https://www.w3.org/TR/secure-contexts/
ç”Ÿæˆå…ƒã¯ä¿¡ç”¨ã«ä¾¡ã—å¾—ã‚‹ã‹ï¼Ÿ:~SECURE-CONTEXT#is-origin-trustworthy
ä¿¡ç”¨ã«ä¾¡ã—å¾—ã‚‹ç”Ÿæˆå…ƒ:~SECURE-CONTEXT#potentially-trustworthy-origin

~referreræ–½ç­–:~REFERRER-POLICY#referrer-policy
	https://www.w3.org/TR/referrer-policy/#referrer-policy

æŒç¶šçš„ãªæ¥ç¶š:~HTTPv1#persistent.connections
~server:~HTTPinfra#server
è¦è«‹~method:~HTTPsem#methods
å¿œç­”~header:~HTTPsem#response-header
çŠ¶æ…‹s~code:~HTTPsem#status-code
	ï¼ ~RFCx/rfc6797#section-8.2

	â—è£œå®Œ
~map:~INFRA#ordered-map
map.~keyç¾¤:~INFRA#map-getting-the-keys
æ··åœ¨~å†…å®¹:~MIXED-CONTENT#mixed-content

èƒ½åŠ›~URL:~CAPABILITY-URLS#dfn-capability-urls

å†…å®¹:~HTTPinfra#message-content
å†…å®¹~ç¬¦å·æ³•:~HTTPsem#content.codings

pC.~referreræ–½ç­–:~ORIGIN#policy-container-referrer-policy
enV.æ–½ç­–~å®¹å™¨:~WAPI#concept-settings-object-policy-container

	è¦è«‹ã®~referrerã‚’æ±ºå®šã™ã‚‹~algo:~REFERRER-POLICY#determine-requests-referrer

â—â—words_table1
NETWORK-REPORTING:https://w3c.github.io/reporting/network-reporting.html
CAPABILITY-URLS:capability-urls-ja.html

â—â—words_table

	â—netowork
	~HTTP~network:HTTP-network
TLS:
TCP:
DNS:
IP:
IPv4:
IPv6:
open:
	serverå´:server-side
ä¸Šä½domain:superdomain::ä¸Šä½ domain:ä¸Šä½ãƒ‰ãƒ¡ã‚¤ãƒ³
ä¸‹ä½domain:subdomain::ä¸‹ä½ domain:ä¸‹ä½ãƒ‰ãƒ¡ã‚¤ãƒ³
close::::
	content-length
	~clientå´:client-side
	errorãªã error-free:::
äº¤æ›:exchange:~
routing:::çµŒè·¯åˆ¶å¾¡:ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
offline::::ã‚ªãƒ•ãƒ©ã‚¤ãƒ³
downtime::::ç¨¼åƒåœæ­¢æœŸé–“:ãƒ€ã‚¦ãƒ³æœŸé–“
pinning:
pinned:
payload::::ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰

ç¢ºç«‹:establishment::~

äºˆè¡Œ:preflight::~
æ¥ç¶šæ€§:connectivity::~
	ã«é€ä¿¡ã—ãŸ:received response from
	åˆ°é”-ä¸èƒ½:unreachable
è§£æ±ºå™¨:resolver::~
æ¤œç´¢:lookup::~
é‹ç”¨-:operate::~
èƒŒå¾Œ:behind:~
è² è·åˆ†æ•£å™¨:load balancer::~::ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚µ
é€éçš„:transparent:~

	ALPN Protocol ID

	â—ä¿å®‰ï¼privacy
scan::::ã‚¹ã‚­ãƒ£ãƒ³
scripting::::
malware::::ãƒãƒ«ã‚¦ã‚§ã‚¢
æŒç¶šçš„:persistent::~
è¿½è·¡å™¨:tracker::~::ãƒˆãƒ©ãƒƒã‚«ãƒ¼
è‡ªæ˜:trivial::~
ä¹—å–ã‚Š:hijacking::~
æš—å·:cipher::~
è¨¼æ˜æ›¸:certificate::~
æ¨©é™:authority::~
æ¢æŸ»-:probe::~
ç©¶æ˜-:investigate::~
å½±éŸ¿n:implications:å½±éŸ¿
	æ¤œè¨¼yã—ãªã„:Without ã€œ verification
	~supercookie
é™æ ¼-:downgrade::~
äºˆé˜²ç­–:precautions:~
	collectors
æ··åœ¨:mixed::~

	ä¿¡ç”¨ã«ä¾¡ã—å¾—ã‚‹:potentially trustworthy
MITM:
	~MITM:MitM
	^en:rebinding
	^en:Capability
	HSTS, HPKP, ~pinned CSP

	â—NELï¼æ–½ç­–ï¼å‡¦ç†model
NEL:
	~cacheæ³•:caching
åé›†å™¨:collector::~
	`REPORTING$r:Reporting
	å ±å‘Š-æ³•:reporting
å ±å‘Šå‡¦ç†:reporting::~::ãƒ¬ãƒãƒ¼ãƒˆå‡¦ç†
å ±å‘Šç”¨:reporting::~::ãƒ¬ãƒãƒ¼ãƒˆç”¨
å ±å‘Šå…ˆ:endpoint::~
	å ±å‘Šå…ˆ:Reporting endpoint
	ç™»éŒ²-æ¸ˆã¿:registered

ç›¸:phase::~
å¤±åŠ¹-:expire::~
éæ–°é®®:stale::~
å­˜ç¶šæœŸé–“:lifetime::~
æ¯”ç‡:rate::~
è¦‹æœ¬æŠ½å‡ºç‡:sampling rate::~
åŒºåˆ†:partition:~
åŒºåˆ†-:partition:~

	â—è¨ˆæ™‚
æœ‰åŠ¹ç§’æ•°:ttl::~
å®Ÿæ™‚é–“:real-time::~::ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ 
æ™‚é–“åˆ‡ã‚Œ:timeout::~
	æ™‚é–“åˆ‡ã‚Œã«:timed out
ä½œæˆæ™‚åˆ»:creation::~
çµŒé-:elapse:~
è¨ˆæ¸¬-:instrument:~
age:::
milli::::ãƒŸãƒª
	milliseconds:::ãƒŸãƒªç§’
éå»:past:~
è¿‘éå»:recent:~
	æ—¥é–“:days
	ç§’é–“:seconds
	ç§’æ•°:number of seconds
	ç§’:seconds
æ™‚é–“t:hours:æ™‚é–“
æ™‚è¨ˆ:clock::~::ã‚¯ãƒ­ãƒƒã‚¯
å£:wall::~

	â—ä¸€èˆ¬å‡¦ç†
	ã«ã‚ˆã‚Šèµ·å‹•ã•ã‚ŒãŸ:-initiated
èµ·å‹•å…ƒo:originator:èµ·å‹•å…ƒ
	å‡¦ç†-æ³•:processing
ç‚ºã•ã‚Œ:makeã•ã‚Œ:~
ç‚ºã™:makeã™ã‚‹:~

	â—dataæ§‹é€ ï¼æ“ä½œ
ä¸‹ä½group:subgroup::ä¸‹ä½ã‚°ãƒ«ãƒ¼ãƒ—
å®Ÿæ•°:number::~
	`Boolean^jt:boolean
	`String^jt:string
	`Number^jt:number
	`number^jt:number
	`Object^jt:ECMAScript object
	ä¸¦ã³:sequence

	â—æ§‹æ–‡ï¼
ç¬¦å·æ³•:coding::~::ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
	~URL:URI

	~NIN ç©º `string^jt:non-empty
dot::::ãƒ‰ãƒƒãƒˆ
	dot-delimited
	dotted-decimal
è¡¨è¨˜æ³•:notation:~
æœ‰åŠ¹:valid::~
ä¸ä¸€è‡´:mismatch::~
åŒºåˆ‡ã‚‰ã‚Œ:delimitã•ã‚Œ:~
	ä¸¦ã³:sequence
	ç‰‡:piece
	è² ã§ãªã„:non-negative

	â—ä»•æ§˜
æœ«ç«¯åˆ©ç”¨è€…:end user:~:::ã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶
å¯ç”¨æ€§:availability:~
ä»»æ„é¸æŠã§ã:opt inã§ã:ä»»æ„ã«é¸æŠã§ã
	OPTIONAL
å¿…é ˆ:required:~
	å¿…é ˆ:REQUIRED
license:
æœ€æ‚ª:worst:~
é›†å›£:populations:~
æ’ä¹…çš„:permanent:~
äº‹å®Ÿ:fact:~
å®ŸåŠ¹æ€§:effectiveness:æœ‰åŠ¹æ€§
æ‰±ã„:treatment:~
æ°—ä»˜ã:awareã™ã‚‹:~
æ°—ä»˜ã‹ãª:awareã—ãª:~
	æ°—ä»˜ã‹ãªã„ã¾ã¾:left unaware
äº‹å‰æ±ºå®š-:predetermine:~

è§£æ¶ˆ-:solve:~
è§£æ±ºç­–:solution:~
çµ¦-:supply:~
æŒ‡å›³-:instruct:~
æ”¯æ´:assistance:~
é©å¿œ-:accommodate:~
æ¿«ç”¨-:abuse:~
å¼·ã„ã‚‰:forceã•:~
æ‰‹åŠ©ã‘:facilitate:~
å¢—è£œ-:augment:~

	é©æ­£ã§ãªã„:improper
	æ˜“ãã™ã‚‹:facilitate
	å®Ÿè·µçš„ãª:hands-on
	become:::
	ã¾ã :still
	å•ã‚ãš:regardless of
	å¿…è¦æ€§:need
	ä¸è¦ã«ãªã‚‹:eliminating
	å…¨èˆ¬:overall
	~~æœ‰ç›Šãª:helpful
	ã•ã‚‚ãªã‘ã‚Œã°:otherwise
	ã®ã§:therefore
	ãªãœ:why
	ä»Šæ—¥ã®:today
	è£œåŠ©:helping
	sincere
	thank
	ã§ããªã„:unable
	-å¯èƒ½ï¼ã§ãã‚‹:able
	-:we
	ã—ãŸã„æ‰€:ideally
	ç¾©å‹™ä»˜ã‘ã‚‰ã‚Œ:mandatory
	ä»¥ä¸‹ã§ã¯:This rationale
	ã¯ãšã§ã‚ã‚‹:must
	å‡ºæ¥äº‹:event
	çœŸã«:truly
	å¿…è¦ãŒã‚ã‚‹:must
	åŸå› :cause
	å†ã³è©¦ã¿ã‚‹:reattempting
	ã¨ã™ã‚‹:assume ã™ã‚‹
	æ®‹ã‚Šã®:additional
	è¨±å®¹ã—ãªã„ã‚ˆã†ã«ã™ã‚‹:disallow
	ãã‚Œã«ã‚ˆã‚Šã€œå¯èƒ½ã«:allow
	æ˜ã‚Šä¸‹ã’ã‚‹:Plumb this through
	å¿˜ã‚ŒãŸ:forget ã—ãŸ
	ä¸»ç”¨é€”:primarily used to
	å–ã‚Šè¾¼ã‚€:ingest
	å‚™ãˆ:equipped
	-:help
	é¸ã¶:choose
	æ°—ä»˜ã:notice

	â—æœªåˆ†é¡
æ‹’å¦-:refuse::~
å»ƒæ­¢-:revoke::~
ä¸€éæ€§:transient:~
å•é¡Œi:issue::å•é¡Œ
ç™ºè¡Œ:issuing::~
	æ‰€æœ‰è€…ãŒèª°ã‹:ownership
ç®¡ç†è€…:administrator::~
é­é‡-:encounter:~

é›†ç´„-:aggregate::~
é›†ç´„:aggregation::~
æ”¾æ£„-:abandon::~
	^en:synthetic monitoring
æ·±ã•:depth:~
ES:ECMAScript
è³½:rollğŸ²:ã‚µã‚¤ğŸ²
	opt:::
category::::ã‚«ãƒ†ã‚´ãƒª
éƒ¨ä½:portion:~
å®Ÿåœ¨ã®:real:~
å…¨åŸŸçš„:global:~
æŠ•è³‡:investment:~
åœ°ç†çš„:geographic:~


	ç’°å¢ƒè¨­å®šã®èª¤ã‚Š:misconfiguration
	ç’°å¢ƒè¨­å®šã‚’èª¤ã£ãŸ:misconfigure
	ä¼ãˆã‚‹:inform
	~T:include
	~F:exclude
	å±-:belong
	ã¾ã¾:left
	ç„¡ã„:not present
	é•·ç”Ÿãã™ã‚‹:long-lived
	è¿‘ã„:near
	ååˆ†é«˜ã„:sufficiently high
	HTMLï¼CSSï¼JavaScript
	IANA
	~NIN:equal
	~consist

	Îµ:no policy
	æ¸›ã‚‰ã™:less
	ã“ã¨ã‚‚ã‚ã‚‹:sometimes
	end:
	~RET:skip the remaining stepsï¼abort these steps


	â—æŒ‡ç¤ºèª
	ãã‚Œã ã‘ã§:own
	åˆ¥ã®:second
	ä»¥å¤–ã®:not covered
	ã€œä»¥ä¸Šã¯:at a minimum
	æ•°å¤šãã®:dozens of
	ã©ã‚Œã ã‘:how many
	ä¸€éƒ¨:part-of
	ã®ã¿ãªã‚‰ãš:not just
	å¤šé‡ã®:large volume of
	æœ€å¾Œã«:finally
	ãšã£ã¨å¤šã„:greatly outnumber
	ã‚ãŸã£ã¦:across
	éš”ãŸã‚ŒãŸ:not coupled with
	ã«å¯¾ã™ã‚‹:against
	å¤§æ¦‚ã¯:most
	-:if ever
	ã”ã¨ã«:per-
	ã‚ã‚‰ã‚†ã‚‹:every
	ã€œã‹ã‚‰:out of
	ã¾ãŸã‚‚ã‚„:once again
	å¿œç­”ã‚’å—ä¿¡ã—ãŸæ™‚ç‚¹:presently
	æ™‚ç‚¹:time
	æœ€æ–°:up to date
	ç›´å¾Œ:immediately after
	ã‚ã‚‹æ™‚ç‚¹ã§:at some point
	ä»Šå›:this time
	ã„ãã°ãã‹å¾Œ:some time later
	ã—ã°ã‚‰ãã—ã¦å¾Œ:Even later
	ä»¥å‰ã«:previously
	ä»¥å‰ã®ï¼å‰ã®:previous


â—â—ref_normative

[CAPABILITY-URLS]
    Good Practices for Capability URLs. Jeni Tennison. W3C. 18 February 2014. FPWD. URL: https://www.w3.org/TR/capability-urls/ 
[CSP]
    Content Security Policy Level 3. Mike West; Antonio Sartori. W3C. 30 April 2025. W3C Working Draft. URL: https://www.w3.org/TR/CSP3/ 
[ECMA-262]
    ECMAScript Language Specification. Ecma International. URL: https://tc39.es/ecma262/multipage/ 
[fetch]
    Fetch Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[hr-time]
    High Resolution Time. Yoav Weiss. W3C. 7 November 2024. W3C Working Draft. URL: https://www.w3.org/TR/hr-time-3/ 
[html]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Dominic Farolino; Ian Hickson; Philip JÃ¤genstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[HTTP-JFV]
    A JSON Encoding for HTTP Header Field Values. J. Reschke. IETF. 24 October 2017. Active Internet-Draft. URL: https://datatracker.ietf.org/doc/html/draft-reschke-http-jfv 
[infra]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/ 
[mixed-content]
    Mixed Content. Emily Stark; Mike West; Carlos IbarraLopez. W3C. 23 February 2023. CRD. URL: https://www.w3.org/TR/mixed-content/ 
[network-reporting]
    Network Reporting API. W3C. Editor's Draft. URL: https://w3c.github.io/reporting/network-reporting.html 
[referrer-policy]
    Referrer Policy. Jochen Eisinger; Emily Stark. W3C. 26 January 2017. W3C Candidate Recommendation. URL: https://www.w3.org/TR/referrer-policy/ 
[REPORTING]
    Reporting API. Douglas Creager; Ian Clelland; Mike West. W3C. 13 August 2024. W3C Working Draft. URL: https://www.w3.org/TR/reporting-1/ 
[RESOURCE-TIMING-2]
    Resource Timing. Yoav Weiss; Noam Rosenthal. W3C. 13 February 2025. CRD. URL: https://www.w3.org/TR/resource-timing/ 
[RFC1034]
    Domain names - concepts and facilities. P. Mockapetris. IETF. November 1987. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc1034 
[RFC1123]
    Requirements for Internet Hosts - Application and Support. R. Braden, Ed. IETF. October 1989. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc1123 
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119 
[RFC3864]
    Registration Procedures for Message Header Fields. G. Klyne; M. Nottingham; J. Mogul. IETF. September 2004. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc3864 
[RFC4291]
    IP Version 6 Addressing Architecture. R. Hinden; S. Deering. IETF. February 2006. Draft Standard. URL: https://www.rfc-editor.org/rfc/rfc4291 
[RFC5234]
    Augmented BNF for Syntax Specifications: ABNF. D. Crocker, Ed.; P. Overell. IETF. January 2008. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc5234 
[RFC6797]
    HTTP Strict Transport Security (HSTS). J. Hodges; C. Jackson; A. Barth. IETF. November 2012. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6797 
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174 
[RFC9110]
    HTTP Semantics. R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed. IETF. June 2022. Internet Standard. URL: https://httpwg.org/specs/rfc9110.html 
[RFC9112]
    HTTP/1.1. R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed. IETF. June 2022. Internet Standard. URL: https://httpwg.org/specs/rfc9112.html 
[secure-contexts]
    Secure Contexts. Mike West. W3C. 10 November 2023. CRD. URL: https://www.w3.org/TR/secure-contexts/ 
[url]
    URL Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://url.spec.whatwg.org/ 


â—â—
ref_informative

â—â—trans_metadata
<p>
~THIS_PAGEã¯ã€
~W3Cã«ã‚ˆã‚Šç·¨é›†è€…è‰æ¡ˆã¨ã—ã¦å…¬é–‹ã•ã‚ŒãŸ
<a href="~SPEC_URL">Network Error Logging</a>
ã‚’æ—¥æœ¬èªã«ç¿»è¨³ã—ãŸã‚‚ã®ã§ã™ã€‚
~PUB
</p>


â—â—spec_metadata

æœ€æ–°å…¬è¡¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³
	https://www.w3.org/TR/network-error-logging/
å…¬è¡¨å±¥æ­´
	https://www.w3.org/standards/history/network-error-logging/
ç·¨é›†è€…è‰æ¡ˆ
	https://w3c.github.io/network-error-logging/
commit å±¥æ­´
	https://github.com/w3c/network-error-logging/commits/
ç·¨é›†
	<a href="https://dcreager.net/">Douglas Creager</a> (GitHub)
	Ian Clelland (Google)
å‰ä»»ç·¨é›†è€…
	<a href="https://www.igvita.com/">Ilya Grigorik</a> (Google) (Until August 2019)
	Julia Tuttle (Google) (Until September 2017)
	Arvind Jain (Google) (Until January 2015)
	Alois Reitbauer (Compuware Corp.) (Until October 2014)
	Jatinder Mann (Microsoft) (Until February 2014)
ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
	<a href="https://github.com/w3c/network-error-logging/">GitHub w3c/network-error-logging</a> (<a href="https://github.com/w3c/network-error-logging/pulls/">pull requests</a>, <a href="https://github.com/w3c/network-error-logging/issues/new/choose">new issue</a>, <a href="https://github.com/w3c/network-error-logging/issues/">open issues</a>)
å…¬è¡¨è€…
	<a href="https://www.w3.org/groups/wg/webperf">Web Performance WG</a>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>Network Error Logging</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
â—è¦ç´„

<p>
ã“ã®æ–‡æ›¸ã¯ï¼»
é–‹ç™ºè€…ãŒï¼Œ~web~appç”¨ã«~network~errorã‚’å ±å‘Šã™ã‚‹æ–½ç­–ã‚’å®£è¨€ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
ï¼½ãŸã‚ã®ä»•çµ„ã¿ã‚’å®šç¾©ã™ã‚‹ã€‚
~UAã¯ã€
ã“ã®æ–½ç­–ã‚’ï¼»
è¦è«‹ã•ã‚ŒãŸè³‡æºã‚’æˆåŠŸè£¡ã«~fetchã§ããªãã™ã‚‹~network~errorã«é­é‡ã—ãŸã¨ãã«
å ±å‘Šã™ã‚‹
ï¼½ãŸã‚ã«åˆ©ç”¨ã§ãã‚‹ã€‚
â—
This document defines a mechanism that enables developers to declare a network error reporting policy for a web application. A user agent can use this policy to report encountered network errors that prevented it from successfully fetching requested resources.
</p>

	</section>
	<section id="sotd">
â—ä½ç½®ä»˜ã‘

<p>
ã“ã®ç¯€ã§ã¯ã€
å…¬è¡¨~æ™‚ç‚¹ã«ãŠã‘ã‚‹â€¦
ã€ä»¥ä¸‹ã€ã“ã®ç¯€ã®å†…å®¹ã¯ï¼Œ~SOTD-W3Cã«ç§»è­²ã€‚ã€‘
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. åºè«–</h2>

<p>
~web~appã®å‡¦ç†èƒ½~ç‰¹æ€§ã‚’æ­£ç¢ºaã«æ¸¬å®šã™ã‚‹ã“ã¨ã¯ã€
~siteé–‹ç™ºè€…ãŒï¼Œ~web~appã‚’æ”¹å–„ã™ã‚‹æ–¹æ³•ã‚’è§£ã™ã‚‹è£œåŠ©ã¨ã—ã¦é‡è¦ãªå´é¢ã‚’æˆã™ã€‚
~network~errorã«å› ã‚‹ï¼»
~appï¼ç‰¹å®š0ã®è³‡æº
ï¼½èª­è¾¼nã®å¤±æ•—ã¯ã€
æœ€æ‚ªãªå±€é¢ã§ã‚ã‚‹ã€‚
é–‹ç™ºè€…ãŸã¡ãŒãã®ã‚ˆã†ãªå¤±æ•—ã«å–çµ„ã‚€ãŸã‚ã«ã¯ã€
ãã®ã‚ˆã†ãªå¤±æ•—ãŒï¼»
ã„ã¤ï¼Œã©ã“ã§ï¼Œãªãœ
ï¼½ç”Ÿã˜ãŸã‹ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã«ï¼Œ~UAã‹ã‚‰ã®æ”¯æ´ã‚’è¦ã™ã‚‹ã€‚
â—
Accurately measuring performance characteristics of web applications is an important aspect in helping site developers understand how to improve their web applications. The worst case scenario is the failure to load the application, or a particular resource, due to a network error, and to address such failures the developer requires assistance from the user agent to identify when, where, and why such failures are occurring.
</p>

<p>
ä»Šæ—¥ã®~appé–‹ç™ºè€…ã¯ã€ï¼»
æœ«ç«¯åˆ©ç”¨è€…ã‹ã‚‰ã®ï¼Œ~web~appã®å¯ç”¨æ€§
ï¼½ã«ã¤ã„ã¦ã®~dataã‚’å®Ÿæ™‚é–“ã«å¾—ã‚‹ã“ã¨ã¯ã§ããªã„ã€‚
ä¾‹ãˆã°ã€
åˆ©ç”¨è€…ãŒ~network~errorã«å› ã‚Š ~pageã®èª­è¾¼ngã«å¤±æ•—ã—ãŸå ´åˆ
â€” ï¼»
~DNSæ¤œç´¢ã«å¤±æ•—ã—ãŸ, æ¥ç¶šãŒæ™‚é–“åˆ‡ã‚Œã«ãªã£ãŸ, æ¥ç¶šã®å†è¨­å®š-, ãã®ä»–ã®äº‹ç”±
ï¼½ãªã© â€”
~siteé–‹ç™ºè€…ã¯ï¼Œãã®å•é¡Œiã‚’æ¤œå‡ºã—ã¦å–çµ„ã‚€ã“ã¨ã¯ã§ããªã„ã€‚
ã“ã‚Œã‚‰ã®ç¨®é¡ã®~network~errorã¯ã€
ç´”ç²‹ã«~serverå´ã®ã¿ã‹ã‚‰ã¯ï¼Œæ¤œå‡ºã§ããªã„ã“ã¨ã«æ³¨æ„
â€” å®šç¾©ã«ã‚ˆã‚Šï¼Œ~clientã¯ ~serverã¨ã®æ¥ç¶šã‚’æˆåŠŸè£¡ã«ç¢ºç«‹ã§ããªã„ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã€‚
â—
Today, application developers do not have real-time web application availability data from their end users. For example, if the user fails to load the page due to a network error, such as a failed DNS lookup, a connection timeout, a reset connection, or other reasons, the site developer is unable to detect and address this issue. Note that these kinds of network errors cannot be detected purely server-side, since by definition the client might not have been able to successfully establish a connection with the server.
</p>

<p>
æ—¢å­˜ã®æ‰‹æ³•ï¼ˆäººå·¥çš„ãªç›£è¦–
ã€ `synthetic monitoringï¼ https://en.wikipedia.org/wiki/Synthetic_monitoring$en ã€‘
ãªã©ï¼‰ã¯ã€
äº‹å‰æ±ºå®šã•ã‚ŒãŸåœ°ç†çš„~æ‰€åœ¨ã«ç›£è¦–~nodeã‚’é…ç½®ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šï¼Œéƒ¨åˆ†çš„ãªè§£æ±ºç­–ã‚’ä¾›ã™ã‚‹ãŒã€
è¿½åŠ çš„ãªåŸºç›¤~æŠ•è³‡ãŒè¦æ±‚ã•ã‚Œï¼Œï¼»
å®Ÿåœ¨ã®æœ«ç«¯åˆ©ç”¨è€…ã«ã¨ã£ã¦ã®å¯ç”¨æ€§ã«ã¤ã„ã¦ï¼ŒçœŸã«å…¨åŸŸçš„ã‹ã¤å®Ÿæ™‚é–“ã«è¿‘ã„~data
ï¼½ã¯ä¾›ã›ãªã„ã€‚
â—
Existing methods (such as synthetic monitoring) provide a partial solution by placing monitoring nodes in predetermined geographic locations, but require additional infrastructure investments, and cannot provide truly global and near real-time availability data for real end users.
</p>

<p>
<abbr>~NEL</abbr>ï¼ˆ `Network Error Logging^en ï¼‰ã¯ã€ï¼»ï¼»ï¼»ï¼»
~UAãŒï¼»
æ‰€ä¸ã®ç”Ÿæˆå…ƒã«å¯¾ã™ã‚‹~network~errorã‚’å ±å‘Šã™ã‚‹
ï¼½ã¨ãã«åˆ©ç”¨ã§ãã‚‹å ±å‘Šç”¨~æ–½ç­–
ï¼½ã‚’ï¼Œ~web~appãŒå®£è¨€ã™ã‚‹ã“ã¨
ï¼½ã‚’å¯èƒ½åŒ–ã™ã‚‹ä»•çµ„ã¿
ï¼½ã‚’å®šç¾©ã™ã‚‹
ï¼½ã“ã¨ã«ã‚ˆã‚Šï¼Œã“ã®å¿…è¦æ€§ã«å–çµ„ã‚€ã€‚
~web~appã¯ã€ï¼»
æ¬²ã•ã‚Œã‚‹`~NELæ–½ç­–$ã‚’è¿°ã¹ã‚‹ `NEL$h ~HTTPå¿œç­”~headerã‚’çµ¦ã™ã‚‹
ï¼½ã“ã¨ã«ã‚ˆã‚Šï¼Œ~NELã®åˆ©ç”¨ã‚’ä»»æ„é¸æŠã§ãã‚‹ã€‚
ã“ã®æ–½ç­–ã¯ã€
ãã®ç”Ÿæˆå…ƒã¸ã®è¦è«‹ã«ã¤ã„ã¦ã®æƒ…å ±ã‚’~logã—ã¦ã‹ã‚‰,
ãã®æƒ…å ±ã‚’ `REPORTING$r ~APIã‚’åˆ©ç”¨ã—ã¦ ä»¥å‰ã«ç’°å¢ƒè¨­å®šã•ã‚ŒãŸ`å ±å‘Šå…ˆ~group$ã¸é€é”ã™ã‚‹ã‚ˆã†è©¦ã¿ã‚‹ã‚ˆã†ã€
~UAã«æŒ‡å›³ã™ã‚‹ã€‚
ãã®åãŒå«æ„ã™ã‚‹ã‚ˆã†ã«ï¼Œ~NELå ±å‘Šã®ä¸»ç”¨é€”ã¯ `~error^emã‚’è¿°ã¹ã‚‹ã“ã¨ã«ã‚ã‚‹ãŒã€
ç•°ãªã‚‹~clienté›†å›£ã«ã‚ãŸã‚‹~errorã®`æ¯”ç‡^emã‚’æ±ºå®šã™ã‚‹ãŸã‚ã«ã¯ï¼Œ`æˆåŠŸã—ãŸ^emè¦è«‹ãŒ ã©ã‚Œã ã‘ç”Ÿã˜ã¦ã„ã‚‹ã‹ã‚‚çŸ¥ã‚‹å¿…è¦ãŒã‚ã‚‹
â€” ã“ã‚Œã‚‰ã®æˆåŠŸã—ãŸè¦è«‹ã‚‚ï¼Œ~NELã®ä»•çµ„ã¿ã‚’ä»‹ã—ã¦å ±å‘Šã§ãã‚‹ã€‚
â—
Network Error Logging (NEL) addresses this need by defining a mechanism enabling web applications to declare a reporting policy that can be used by the user agent to report network errors for a given origin. A web application opts into using NEL by supplying a NEL HTTP response header field that describes the desired NEL policy. This policy instructs the user agent to log information about requests to that origin, and to attempt to deliver that information to a group of endpoints previously configured using the Reporting API. As the name implies, NEL reports are primarily used to describe errors. However, in order to determine rates of errors across different client populations, we must also know how many successful requests are occurring; these successful requests can also be reported via the NEL mechanism.
</p>

<div class="example">
<p>
ä¾‹ãˆã°ã€
~TCPæ¥ç¶šãŒä¸­æ­¢ã•ã‚ŒãŸã“ã¨ã«å› ã‚Šï¼Œ
~UAãŒ `https://www.example.com^s ã‹ã‚‰è³‡æºã®~fetchã«å¤±æ•—ã—ãŸå ´åˆã€
~UAã¯ï¼Œ
`REPORTING$r ~APIã‚’ä»‹ã—ã¦æ¬¡ã®æ§˜ãªå ±å‘Šã‚’~queueã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
For example, if the user agent fails to fetch a resource from https://www.example.com due to an aborted TCP connection, the user agent would queue the following report via the Reporting API:
</p>

<dl>
	<dt>
`ç¨®åˆ¥$nE
â—
type
</dt>
	<dd>
`network-error^l
</dd>

	<dt>
`å ±å‘Šç”¨~group$nP
â—
endpoint group
</dt>
	<dd>
`report_to$c ~fieldã«ã‚ˆã‚Šç’°å¢ƒè¨­å®šã•ã‚ŒãŸ`å ±å‘Šå…ˆ~group$
â—
the endpoint group configured by the report_to field
</dd>

	<dt>
~data
â—
data
</dt>
	<dd>
<pre class="lang-json">
{
  "referrer": "https://referrer.com/",
  "sampling_fraction": 1.0,
  "server_ip": "192.0.2.42",
  "protocol": "http/1.1",
  "elapsed_time": 321,
  "phase": "connection",
  "type": "tcp.aborted"
}
</pre>
	</dd>
</dl>
</div>

<p>
é€šä¿¡ã•ã‚Œã‚‹å ±å‘Šã‚’æˆã™å„~field, ãŠã‚ˆã³å ±å‘Šã®å½¢å¼ã«ã¤ã„ã¦ã®èª¬æ˜ã¯ã€
`Â§ ~network~errorå ±å‘Šã®ç”Ÿæˆ-æ³•ï¼ #generate-a-network-error-report$
ã«è¦‹ã‚‰ã‚Œã‚‹ã€‚
ã‚ˆã‚Š~~å®Ÿè·µçš„ãªï¼Œ~NELç™»éŒ²ã¨å ±å‘Š-æ™‚ã®å‡¦ç†-ä¾‹ã¯ã€
`Â§ ä¾‹ï¼ #examples$
ã«è¦‹ã‚‰ã‚Œã‚‹ã€‚
â—
See 5.4 Generate a network error report for an explanation of the communicated fields and format of the report, and 7. Examples for more hands-on examples of NEL registration and reporting process.
</p>

	</section>
	<section id="_conventions">
<h2>ã€ã“ã®è¨³ã«ç‰¹æœ‰ãªè¡¨è¨˜è¦ç´„ã€‘</h2>

â—è¡¨è¨˜è¨˜å·

<p>
ã“ã®ä»•æ§˜ã«åˆ©ç”¨ã•ã‚Œã‚‹ç”¨èªï¼»
è¦è«‹ï¼å¿œç­”
ï¼½ã¯ã€
ä¸€èˆ¬ã« `FETCH$r ã«å®šç¾©ã•ã‚Œã‚‹ï¼»
`è¦è«‹$ï¼`å¿œç­”$
ï¼½ã‚’å‚ç…§ã™ã‚‹ãŒï¼Œ
`RFC9110$r ãŒå®šç¾©ã™ã‚‹ï¼»
`è¦è«‹ï¼ ~HTTPinfra#request$ï¼
`å¿œç­”ï¼ ~HTTPinfra#response$
ï¼½ã‚’æŒ‡ã™ç®‡æ‰€ã‚‚ã‚ã‚‹
ï¼ˆã©ã¡ã‚‰ã‚’æŒ‡ã™ã‹ã¯ï¼ŒæŸ”è»Ÿã«è§£é‡ˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€
å ´åˆã«ã‚ˆã£ã¦ã¯ï¼Œä¸¡ç¾©çš„ã«ã‚‚è§£é‡ˆã—å¾—ã‚‹ï¼‰ã€‚
</p>

<p>
ã“ã®ä»•æ§˜ã«ç¾ã‚Œã‚‹ç”¨èª
`å ±å‘Šå…ˆ~group@
ã¯ã€
`REPORTING$r ã«å®šç¾©ã•ã‚Œã¦ã„ãŸãŒï¼Œãã®ä»•æ§˜ã®æ›´æ–°ã«ã‚ˆã‚Šå»ƒã•ã‚ŒãŸ
â€” ä»£ã‚ã‚‹ç”¨èªã¯ï¼ˆ`å ±å‘Š$ã®ï¼‰`è¡Œå…ˆ$ã«ãªã‚‹ã¨æ€ã‚ã‚Œã‚‹ãŒã€
ã¯ã£ãã‚Šã—ãªã„ã€‚
</p>

	</section>
	<section id="conformance-requirements">
<h2 title="Conformance requirements">2. é©åˆæ€§~è¦ä»¶</h2>

<p class="trans-note">ã€
ã“ã®ç¯€ã®å†…å®¹ã¯ã€
`~W3Cæ—¥æœ¬èªè¨³ å…±é€š~pageï¼ ~W3Ccommon#conformance$ã«ç§»è­²ã€‚
ã€‘</p>

	</section>
	<section id="concepts">
<h2 title="Concepts">3. æ¦‚å¿µ</h2>

		<section id="network-requests">
<h3 title="Network requests">3.1. ~networkè¦è«‹</h3>

<p>
`~networkè¦è«‹@
ï¼ˆ `network request^en ï¼‰ã¯ã€
~UAãŒæ‰€ä¸ã®`è¦è«‹$ç”¨ã«~networkè¶Šã—ã«è³‡æºã‚’`~HTTP~network~fetch$ã™ã‚‹ã‚ˆã†è©¦ã¿ã‚‹ã¨ãã«ç”Ÿã˜ã‚‹ã€‚
â—
A network request occurs when the user agent attempts to HTTP-network fetch a resource over the network for a given request.
</p>

<p>
æ¬¡ã®ã„ãšã‚Œã‹ã«è©²å½“ã™ã‚‹`è¦è«‹$ã¯ã€
`~networkè¦è«‹$ã«ãªã‚‰ãªã„ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
â†“</p>
<ul>
	<li>
~UAãŒ~offlineã«ã‚ã‚‹ã“ã¨ãŒæ—¢çŸ¥ã§ã‚ã‚‹ä¸‹ã§ã®è¦è«‹
ï¼ˆã™ãªã‚ã¡ `navigator.onLineï¼ ~HTMLnavigator#dom-navigator-online$c ãŒ ~F ã‚’è¿”ã™ã¨ãï¼‰ã€‚
â—
A request MUST NOT result in a network request if the user agent is known to be offline (i.e., when navigator. onLine returns false).
</li>
	<li>
`æ··åœ¨~å†…å®¹$ã‚„`~CORSï¼ ~FETCH#cors-protocol$ã®å¤±æ•—ã«å› ã‚Šï¼Œé˜»æ­¢ã•ã‚ŒãŸè¦è«‹ã€‚
â—
A request MUST NOT result in a network request if it is blocked due to mixed content or CORS failures.ï¼¼
</li>
</ul>

<p>
å„`~CORSäºˆè¡Œ~è¦è«‹$ã¯ã€
ãã‚Œã ã‘ã§`~networkè¦è«‹$ã«ãªã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
Any CORS-preflight request MUST result in its own network request.
</p>

<p class="note">æ³¨è¨˜ï¼š
`FETCH$r æ¨™æº–ã«å‰‡ã£ã¦`è¦è«‹$ã‚’~serviceã™ã‚‹~UAã«ãŠã„ã¦ã¯ã€
å„`~networkè¦è«‹$ã¯ï¼Œ`~HTTP~network~fetch$ ~algoã® 1 å›ã®å®Ÿè¡Œã«å¯¾å¿œã™ã‚‹ã€‚
â—
Note

For user agents that service requests according to the [FETCH] standard, a network request corresponds to one execution of the HTTP-network fetch algorithm.
</p>

<p>
ã©ã®ï¼»
~fetch~algo, ä¸‹å±¤ã®~app, ~transport~protocol
ï¼½ã‚’åˆ©ç”¨ã™ã‚‹ã‹ã‚’å•ã‚ãšã€
`~networkè¦è«‹$ã‚’~serviceã™ã‚‹~~éç¨‹ã¯ï¼Œæ¬¡ã«æŒ™ã’ã‚‹
`ç›¸@
ï¼ˆ `phase^en ï¼‰ã‹ã‚‰ãªã‚‹ï¼š
â—
Regardless of which fetch algorithm and which underlying application and transport protocols are used, servicing a network request consists of the following phases:
</p>

<ol>
	<li>
`~DNSè§£æ±º@
â‡’
~UAãŒ~DNSï¼ˆ `Domain Name System^en `RFC1034$r ï¼‰ã‚’åˆ©ç”¨ã—ã¦ã€
~domainåã‚’ï¼»
ãã®~domainã¸å‘ã‘ãŸ~HTTPè¦è«‹ã«å¯¾ã—~serviceã§ãã‚‹`~server$
ï¼½ã®`~IP~address$ã«è§£æ±ºã™ã‚‹ã¾ã§ã®é–“ã€‚
â—
DNS resolution: The user agent uses the Domain Name System [RFC1034] to resolve a domain name into an IP address of a server can that service HTTP requests to that domain.
</li>
	<li>
`~secureæ¥ç¶šã®ç¢ºç«‹@
â‡’
~UAãŒ`~server$ã¸ã®æ¥ç¶šã‚’~openã—ã¦ã€
ãã®æ¥ç¶š~è¶Šã—ã«~secure~channelã‚’ç¢ºç«‹ã™ã‚‹ã¾ã§ã®é–“ã€‚
â—
Secure connection establishment: The user agent opens a connection to the server, and establishes a secure channel over this connection.
</li>
	<li>
`è¦è«‹ã¨å¿œç­”ã®ä¼é€@
â‡’
~secure~channelãŒç¢ºç«‹ã•ã‚ŒãŸãªã‚‰ã€
~UAã¯ï¼Œ~HTTPè¦è«‹ã‚’ä¼é€ã—ã¦`~server$ã‹ã‚‰ã®å¿œç­”ã‚’å—ä¿¡ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
Transmission of request and response: Once the secure channel is established, the user agent can transmit the HTTP request, and receive the response from the server.
</li>
</ol>

<p>
`~networkè¦è«‹$ã‚’æˆã™ãŸã‚ã«ç¾©å‹™ä»˜ã‘ã‚‰ã‚Œã‚‹`ç›¸$ã¯ï¼Œã“ã‚Œã‚‰ã®ã†ã¡`è¦è«‹ã¨å¿œç­”ã®ä¼é€$ã®ã¿ã§ã‚ã‚Šã€
ä»–ã®`ç›¸$ã¯ï¼Œå¿…è¦ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ä¸€ä¾‹ã¨ã—ã¦ï¼Œ~DNSã®çµæœã¯ã€
~UAã«ãŠã„ã¦å±€æ‰€çš„ã«~cacheã§ãã‚‹
â€” ãã®å ´åˆã€
åŒã˜~domainå‘ã‘ã®æœªæ¥ã®è¦è«‹ã«å¯¾ã™ã‚‹`~DNSè§£æ±º$ã¯ä¸è¦ã«ãªã‚‹ã€‚
åŒæ§˜ã«ï¼Œ~HTTPã®`æŒç¶šçš„ãªæ¥ç¶š$ã¯ã€
åŒã˜`~networkåŒºåˆ†~keyï¼ ~FETCH#request-determine-the-network-partition-key$ã‚’ä¼´ã†è¤‡æ•°ã®è¦è«‹ãŒåŒã˜~openæ¥ç¶šã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã‚’è¨±å®¹ã™ã‚‹ã€‚
ã—ã‹ã—ãªãŒã‚‰ï¼Œè¤‡æ•°ã®`ç›¸$ãŒç”Ÿã˜ã‚‹å ´åˆã€
ä¸Šã®é †åºã§ç”Ÿã˜ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
The only mandatory phase is the transmission of request and response; the other phases might not be needed for every network request. For instance, DNS results can be cached locally in the user agent, eliminating DNS resolution for future requests to the same domain. Similarly, HTTP persistent connections allow open connections to be shared for multiple requests to the same network partition key. However, if multiple phases occur, they will occur in the above order.
</p>

<p class="note">ç·¨é›†è€…æ³¨è¨˜ï¼š
ã“ã‚Œã‚‰ã®`ç›¸$ãŸã¡ã‚’æˆã™å®šç¾©ã¯ã€
ã‚‚ã£ã¨å†åˆ©ç”¨-å¯èƒ½ã«ãªã‚‹ã‚ˆã† `FETCH$r ã®ä¸­ã¸ç§»å‹•ã—ãŸã„æ‰€ã€‚
â—
Editor's note

We would like to move the definition of these phases into [FETCH] so that they are more reusable.
</p>

<p>
`~networkè¦è«‹$ã¯ã€
æ¬¡ãŒ~~åˆ¤æ˜ã—ãŸæ™‚ç‚¹ã§
`æˆåŠŸã—ãŸ@
ï¼ˆ `successful^en ï¼‰ã¨ã•ã‚Œã‚‹
â‡’
ï¼»
~UAã¯ã€
~serverã‹ã‚‰å¦¥å½“ãª~HTTPå¿œç­”ã‚’å—ä¿¡ã§ããŸ
ï¼½~ANDï¼»
ãã®å¿œç­”ã®çŠ¶æ…‹s~codeã¯ï¼»
`4xx$st ï¼ `5xx$st
ï¼½ã§ãªã„
ï¼½
â—
A network request is successful if the user agent is able to receive a valid HTTP response from the server, and that response does not have a 4xx or 5xx status code.
</p>

<p>
`~networkè¦è«‹$ã¯ã€
`æˆåŠŸ-$ã—ãªã‹ã£ãŸã“ã¨ãŒ~~åˆ¤æ˜ã—ãŸæ™‚ç‚¹ã§
`å¤±æ•—ã—ãŸ@
ï¼ˆ `failed^en ï¼‰ã¨ã•ã‚Œã‚‹ã€‚
â—
A network request is failed if it is not successful.
</p>

<p class="note">æ³¨è¨˜ï¼š
~HTTP~errorå¿œç­”ï¼ˆã™ãªã‚ã¡ çŠ¶æ…‹s~codeã«ï¼»
`4xx$st ï¼ `5xx$st
ï¼½ã‚’ä¼´ã†ã‚‚ã®ï¼‰ã¯ã€
ãã‚ŒãŒ `~NELæ–½ç­–$ã®`æˆåŠŸ~æ™‚ã®è¦‹æœ¬æŠ½å‡ºç‡$ã«ä»£ãˆã¦`å¤±æ•—~æ™‚ã®è¦‹æœ¬æŠ½å‡ºç‡$ã®~subjectã«ãªã‚‹ã‚ˆã†ï¼Œ`å¤±æ•—ã—ãŸ$ã‚‚ã®ã¨è¦‹ãªã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã€‚
â—
Note

Note that HTTP error responses (i.e., those with a 4xx or 5xx status code) are considered failures, so that they are subject to a NEL policy's failure sampling rate instead of its successful sampling rate.
</p>

		</section>
		<section id="network-errors">
<h3 title="Network errors">3.2. ~network~error</h3>

<p>
`~networkè¦è«‹$ã‚’ `å¤±æ•—-$ã•ã›ãŸ~erroræ¡ä»¶ã‚’
`~network~error@
ã¨ã„ã†ã€‚
â—
A network error is the error condition that caused a network request to fail.
</p>

<p>
å„`~network~error$ã«ã¯ã€
æ–‡å­—åˆ—ã¨ã—ã¦ä¸ãˆã‚‰ã‚Œã‚‹
`ç¨®åˆ¥@nE
ï¼ˆ `type^en ï¼‰ãŒã‚ã‚‹ã€‚
â—
Each network error has a type, which is a string.
</p>

<p>
å„`~network~error$ã«ã¯ã€
å½“ã®~errorã¯ã©ã®`ç›¸$ã§ç”Ÿã˜ãŸã‹ã‚’è¿°ã¹ã‚‹
`ç›¸@nE
ï¼ˆ `phase^en ï¼‰ãŒã‚ã‚‹ï¼š
â—
Each network error has a phase, which describes which phase the error occurred in:
</p>

<dl>
	<dt>`dns^l</dt>
	<dd>
å½“ã®~errorã¯ã€
`~DNSè§£æ±º$ã®é–“ã«ç”Ÿã˜ãŸ
â—
the error occurred during DNS resolution
</dd>

	<dt>`connection^l</dt>
	<dd>
å½“ã®~errorã¯ã€
`~secureæ¥ç¶šã®ç¢ºç«‹$ã®é–“ã«ç”Ÿã˜ãŸ
â—
the error occurred during secure connection establishment
</dd>

	<dt>`application^l</dt>
	<dd>
å½“ã®~errorã¯ã€
`è¦è«‹ã¨å¿œç­”ã®ä¼é€$ã®é–“ã«ç”Ÿã˜ãŸ
â—
the error occurred during the transmission of request and response
</dd>

</dl>

<p>
`~network~error$ã®`ç¨®åˆ¥$nEã¨ã—ã¦å®šç¾©æ¸ˆã¿ãªã‚‚ã®ãŒã„ãã¤ã‹ã‚ã‚Šã€
`å®šç¾©æ¸ˆã¿~network~errorç¨®åˆ¥ï¼ #predefined-network-error-types$ã«ã¦å®šç¾©ã•ã‚Œã‚‹ã€‚
â—
There are several predefined network error types defined in 6. Predefined network error types.
</p>

		</section>
		<section id="network-error-reports">
<h3 title="Network error reports">3.3. ~network~errorå ±å‘Š</h3>

<p>
`~network~error$ã‚’è¿°ã¹ã‚‹`å ±å‘Š$ `REPORTING$r ã¯ã€
`~network~errorå ±å‘Š@
ï¼ˆ `network error report^en ï¼‰ã¨å‘¼ã°ã‚Œã‚‹ã€‚
â—
A network error report is a Reporting API report that describes a network error.
</p>

<p>
`~network~errorå ±å‘Š$ã®`å ±å‘Š~ç¨®åˆ¥$ã¯ã€
 `network-error^l ã¨ã™ã‚‹ã€‚
â—
Network error reports have a report type of network-error.
</p>

<p>
`~network~errorå ±å‘Š$ã¯ã€
`å ±å‘Šç”¨~è¦³æ¸¬å™¨ã‹ã‚‰å¯è¦–$ã§ãªã„ã€‚
â—
Network error reports are NOT visible to ReportingObservers.
</p>

<p class="note">æ³¨è¨˜ï¼š
`å ±å‘Šç”¨~è¦³æ¸¬å™¨ã‹ã‚‰å¯è¦–$ã§ãªã„ã¨ã•ã‚Œã¦ã„ã‚‹ã®ã¯ã€
`~network~errorå ±å‘Š$ã¯ï¼Œè¦è«‹ã‚’`å—ä¿¡ã—ã¦ã„ã‚‹^em~serverã®ï¼»
ç®¡ç†è€…ï¼æ‰€æœ‰è€…
ï¼½ã‹ã‚‰ã«é™ã‚Šå¯è¦–ã«ãªã‚‹ã“ã¨ãŒæ„å›³ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
å ±å‘ŠãŒ`å ±å‘Šç”¨~è¦³æ¸¬å™¨ã‹ã‚‰å¯è¦–$ã«ãªã£ãŸå ´åˆã€
è¦è«‹ã®`èµ·å‹•å…ƒo^emã‹ã‚‰ã‚‚å¯è¦–ã«ãªã‚‹ã€‚
ãã®çµæœï¼ŒéåŒä¸€-ç”Ÿæˆå…ƒãªè¦è«‹ã«å¯¾ã—ã¦ã¯ã€
ãã®~serverã®åˆ¶å¾¡ã®å¤–å´ã«ã‚ã‚‹ä¸»ä½“ã«ã‚‚ï¼Œï¼»
~serverã®~networkç’°å¢ƒè¨­å®šã«ã¤ã„ã¦ã®æƒ…å ±
ï¼½ãŒæ¼æ´©ã•ã‚Œå¾—ã‚‹ã“ã¨ã«ã‚‚ãªã‚‹ã€‚
â—
Note

Network error reports are not visible to ReportingObservers because they are only intended to be visible to the administrator or owner of the server receiving the requests. If they were visible to ReportingObservers, then the reports would also be visible to the originator of the request. For cross-origin requests, this could leak information about the server's network configuration to parties outside of its control.
</p>

		</section>
		<section id="nel-policies">
<h3 title="NEL policies">3.4. ~NELæ–½ç­–</h3>

<p>
`~NELæ–½ç­–@
ï¼ˆ `NEL policy^en ï¼‰ã¯ã€
ã‚ã‚‹`ç”Ÿæˆå…ƒ$ã¸ã®`~networkè¦è«‹$ã«ã¤ã„ã¦ã®å ±å‘Šã‚’åé›†ã™ã‚‹ã‹ã©ã†ã‹ï¼Œ
åé›†ã—ãŸå ±å‘Šã¯ã©ã“ã¸é€ä¿¡ã™ã‚‹ã‹ã‚’ã€
~UAã«æŒ‡å›³ã™ã‚‹ã€‚
`~NELæ–½ç­–$ã¯ï¼Œ `NEL$h ~HTTP`å¿œç­”~header$ã‚’ä»‹ã—ã¦~UAã«é€é”ã•ã‚Œã‚‹ã€‚
â—
A NEL policy instructs a user agent whether to collect reports about network requests to an origin, and if so, where to send them. NEL policies are delivered to the user agent via HTTP response headers.
</p>

<p>
å„`~NELæ–½ç­–$ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ã‚’æœ‰ã™ã‚‹ï¼š
â—
â†“</p>
<ul>
	<li>
`å—ä¿¡ã—ãŸ~IP~address@nP
â‡’
~UAãŒã“ã®`~NELæ–½ç­–$ã‚’å—ä¿¡ã—ãŸ`~server$ã®`~IP~address$ã€‚
â—
Each NEL policy has a received IP address,ï¼¼
which is the IP address of the server that the user agent received this NEL policy from.
</li>
	<li>
`ç”Ÿæˆå…ƒ@nP
ï¼ˆ `policy origin^en ï¼‰
â‡’
`ç”Ÿæˆå…ƒ$
â—
Each NEL policy has an origin.
</li>
	<li>
`ä¸‹ä½domainã‚’å«ã‚€ã‹@nP
ï¼ˆ `subdomains flag^en ï¼‰
â‡’
çœŸå½å€¤ã€ï¼include or excludeã€‘
ã€åŸæ–‡ã¯ `include^en ï¼ `exclude^en ã‚’ã¨ã‚‹ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŒã€ã“ã®è¨³ã§ã¯çœŸå½å€¤ã«æ”¹ã‚ã‚‹ã€‚ã€‘
â—
Each NEL policy has a subdomains flag,ï¼¼
which is either include or exclude.
</li>
	<li>
`è¦è«‹~headerå~list@nP
ï¼ˆ `list of request headers^en ï¼‰
â‡’
`åå‰$hdãŸã¡ãŒæˆã™~listã€‚
â—
â†“</li>
	<li>
`å¿œç­”~headerå~list@nP
ï¼ˆ `list of response headers^en ï¼‰
â‡’
`åå‰$hdãŸã¡ãŒæˆã™~listã€‚
â—
Each NEL policy hasï¼¼
a list of request headers and a list of response headers,ï¼¼
each of which is a list of header names.
</li>
	<li>
`å ±å‘Šç”¨~group@nP
ï¼ˆ `reporting group^en ï¼‰
â‡’
ã“ã®æ–½ç­–~ç”¨ã®å ±å‘Šã®é€ä¿¡-å…ˆã«ãªã‚‹`å ±å‘Šå…ˆ~group$ã®åå‰ã‚’ä¸ãˆã‚‹ã€‚
â—
Each NEL policy has a reporting group,ï¼¼
which is the name of the Reporting endpoint group that reports for this policy will be sent to.
</li>
	<li>
`æœ‰åŠ¹ç§’æ•°@nP
ï¼ˆ `ttl^en ï¼‰
â‡’
æ–½ç­–ãŒæœ‰åŠ¹ã§ã‚ã‚Šç¶šã‘ã‚‹ç§’æ•°ã‚’è¡¨ç¾ã™ã‚‹ã€‚
â—
Each NEL policy has a ttlï¼¼
representing the number of seconds the policy remains valid.
</li>
	<li>
`ä½œæˆæ™‚åˆ»@nP
ï¼ˆ `creation^en ï¼‰
â‡’
~UAãŒã“ã®æ–½ç­–ã‚’å—ä¿¡ã—ãŸã¨ãã®æ™‚åˆ»å°ã€‚
â—
Each NEL policy has a creationï¼¼
which is the timestamp when the user agent received the policy.
</li>
</ul>

<p>
æ¬¡ã‚’æº€ãŸã™
`~NELæ–½ç­–$ã¯ã€
`éæ–°é®®@
ï¼ˆ `stale^en ï¼‰ã¨ã•ã‚Œã‚‹
â‡’
ãã®`ä½œæˆæ™‚åˆ»$nPã‹ã‚‰`å£~æ™‚è¨ˆã®å®‰å…¨ã§ãªã„ç¾åœ¨ã®æ™‚åˆ»$ã¾ã§ã®æ‰€è¦æ™‚é–“ ~GT 172800 ç§’ ï¼ˆ 48 æ™‚é–“tï¼‰
â—
A NEL policy is stale if the duration from its creation to the wall clock's unsafe current time is greater than 172800 seconds (48 hours).
</p>

<p>
æ¬¡ã‚’æº€ãŸã™
`~NELæ–½ç­–$ã¯ã€
`å¤±åŠ¹ã—ãŸ@
ï¼ˆ `expired^en ï¼‰ã¨ã•ã‚Œã‚‹
â‡’
ãã®`ä½œæˆæ™‚åˆ»$nPã‹ã‚‰`å£~æ™‚è¨ˆã®å®‰å…¨ã§ãªã„ç¾åœ¨ã®æ™‚åˆ»$ã¾ã§ã®æ‰€è¦æ™‚é–“ ~GT `æœ‰åŠ¹ç§’æ•°$nP
â—
A NEL policy is expired if the duration from its creation to the wall clock's unsafe current time is greater than its ttl (in seconds).
</p>

		</section>
		<section id="sampling-rates">
<h3 title="Sampling rates">3.5. è¦‹æœ¬æŠ½å‡ºç‡</h3>

<p>
å¤šé‡ã®æµé€šã‚’~serveã™ã‚‹ã“ã¨ãŒäºˆæœŸã•ã‚Œã‚‹`ç”Ÿæˆå…ƒ$ã¯ã€
ãã®ç”Ÿæˆå…ƒã«å‘ã‘ã¦ç‚ºã•ã‚ŒãŸ ã‚ã‚‰ã‚†ã‚‹`~networkè¦è«‹$ã«å¯¾ã™ã‚‹~NELå ±å‘Šã‚’å–ã‚Šè¾¼ã‚€å‚™ãˆã¯ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ç”Ÿæˆå…ƒã¯ã€
`è¦‹æœ¬æŠ½å‡ºç‡@
ï¼ˆ `sampling rate^en ï¼‰ã‚’å®šç¾©ã—ã¦ï¼Œå„~UAãŒæå‡ºã™ã‚‹ ~NELå ±å‘Šã®å€‹æ•°ã‚’åˆ¶é™ã§ãã‚‹ã€‚
æ¦‚ã—ã¦ï¼Œ`æˆåŠŸã—ãŸ$è¦è«‹ã®æ–¹ãŒ`å¤±æ•—ã—ãŸ$è¦è«‹ã‚ˆã‚Š ãšã£ã¨å¤šã„ã¯ãšãªã®ã§ã€
ç”Ÿæˆå…ƒã¯ï¼Œãã‚Œãã‚Œã«ç•°ãªã‚‹è¦‹æœ¬æŠ½å‡ºç‡ã‚’æŒ‡å®šã§ãã‚‹ã€‚
â—
An origin that expects to serve a large volume of traffic might not be equipped to ingest NEL reports for every network request made to the origin. The origin can define sampling rates to limit the number of NEL reports that each user agent submits. Since successful requests should typically greatly outnumber failed requests, the origin can specify different sampling rates for each.
</p>

<p>
å„`~NELæ–½ç­–$ã¯ã€
`æˆåŠŸ~æ™‚ã®è¦‹æœ¬æŠ½å‡ºç‡@,
`å¤±æ•—~æ™‚ã®è¦‹æœ¬æŠ½å‡ºç‡@
ã‚’æœ‰ã™ã‚‹
â€” ã©ã¡ã‚‰ã‚‚ 0.0 ä»¥ä¸Š 1.0 ä»¥ä¸‹ã®å®Ÿæ•°ã¨ã™ã‚‹ã€‚
â—
Each NEL policy has a successful sampling rate, which is a number between 0.0 and 1.0 inclusive.
â—
Each NEL policy has a failure sampling rate, which is a number between 0.0 and 1.0 inclusive.
</p>

		</section>
		<section id="policy-cache">
<h3 title="Policy cache">3.6. æ–½ç­–~cache</h3>

<p>
é©åˆt~UAã¯ã€
`~NELæ–½ç­–$ã®é›†åˆã‚’ä¿å®ˆã™ã‚‹~storageã®ä»•çµ„ã¿ã‚’æˆã™
`æ–½ç­–~cache@
ï¼ˆ `policy cache^en ï¼‰ã‚’ä¾›ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
ãã‚Œã¯ã€
( `~networkåŒºåˆ†~key$, `ç”Ÿæˆå…ƒ$ )
ãŒæˆã™~tupleã‚’~keyã«ï¼Œæ–½ç­–ã‚’æ ¼ç´ã™ã‚‹ã€‚
â—
A conformant user agent MUST provide a policy cache, which is a storage mechanism that maintains a set of NEL policies, keyed by (network partition key, origin) tuples.
</p>

<p class="trans-note">ã€
ã“ã®è¨³ã§ã¯ã€
`æ–½ç­–~cache$ã¯ï¼»
å„ ( `~networkåŒºåˆ†~key$, `ç”Ÿæˆå…ƒ$ ) ã‚’`~NELæ–½ç­–$ã«å¯¾å¿œä»˜ã‘ã‚‹`~map$
ï¼½ã§ã‚ã‚‹ã¨è¦‹ãªã—ãŸä¸Šã§ï¼Œ
`~map$ç”¨ã«å®šç¾©ã•ã‚ŒãŸå„ç¨®ï¼»
æ¼”ç®—ï¼è¡¨è¨˜æ³•
ï¼½ã‚’åˆ©ç”¨ã™ã‚‹ã€‚
ä»¥ä¸‹ã«æŒ™ã’ã‚‰ã‚Œã‚‹è¦ä»¶ã‚’æº€ãŸã™ãŸã‚ã«ã¯ã€
~mapã§è¶³ã‚‹ã®ã§
ï¼ˆã“ã®~mapã‚’æˆã™~entryãŸã¡ã®é †åºã¯æœ‰æ„ã§ãªã„ï¼‰ã€‚
ã“ã®~mapã«ãŠã‘ã‚‹ã€
~keyã©ã†ã—ã®æ¯”è¼ƒã¯æˆåˆ†ã”ã¨ï¼Œãã‚Œã‚‰ã‚’æˆã™ï¼»
`~networkåŒºåˆ†~key$ï¼`ç”Ÿæˆå…ƒ$
ï¼½ã©ã†ã—ã®æ¯”è¼ƒã¯ï¼»
`åŒã˜~site$ï¼`åŒä¸€-ç”Ÿæˆå…ƒ$
ï¼½ã®å®šç¾©ã«åŸºã¥ãã“ã¨ã«ãªã‚ã†ã€‚
ã€‘</p>

<p>
ã“ã®~storageã®ä»•çµ„ã¿ã¯ã€
ä¸é€æ˜ã‹ã¤~vendorã«ç‰¹æœ‰ã§ã‚ã‚Šï¼Œ~webã«ã¯å…¬é–‹ã•ã‚Œãªã„ãŒã€
æ¬¡ã®~methodã‚’ä¾›ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«
â€” ãã‚Œã¯ã€
ã“ã®æ–‡æ›¸ãŒå®šç¾©ã™ã‚‹å„ç¨®~algoã‹ã‚‰åˆ©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
This storage mechanism is opaque, vendor-specific, and not exposed to the web, but it MUST provide the following methods which will be used in the algorithms this document defines:
</p>

<ul>
	<li>
`~NELæ–½ç­–$ã‚’ï¼»
æŒ¿å…¥- ï¼ æ›´æ–°- ï¼ å‰Šé™¤-
ï¼½ã™ã‚‹ã€‚
â—
Insert, update, and delete NEL policies.
</li>
	<li>
æ‰€ä¸ã®
( `~networkåŒºåˆ†~key$, `ç”Ÿæˆå…ƒ$ )
ç”¨ã®`~NELæ–½ç­–$ãŒã‚ã‚Œã° ãã‚Œã‚’æ¤œç´¢å–å¾—ã™ã‚‹ã€‚
â—
Retrieve the NEL policy, if any, for a given origin and network partition key.
</li>
	<li>
~cacheã‚’~clearã™ã‚‹ã€‚
â—
Clear the cache.
</li>
</ul>

		</section>
	</section>
	<section id="policy-delivery">
<h2 title="Policy delivery">4. æ–½ç­–ã®é€é”</h2>

<p>
`~server$ã¯ã€
è‡ªèº«ãŒåˆ¶å¾¡ã™ã‚‹ç”Ÿæˆå…ƒ~ç”¨ã®`~NELæ–½ç­–$ã‚’ï¼Œ`NEL$h ~HTTP `å¿œç­”~header$ã‚’ä»‹ã—ã¦å®šç¾©ã—ã¦ã‚‚ãƒ¨ã‚¤ã€‚
â—
A server MAY define a NEL policy for an origin it controls via the NEL HTTP response header.
</p>

		<section id="nel-response-header">
<h3 title="NEL response header">4.1. `NEL^h å¿œç­”~header</h3>

<p>
`ç”Ÿæˆå…ƒ$ã®`~NELæ–½ç­–$ã‚’~UAã«å‘ã‘ã¦é€šä¿¡ã™ã‚‹ãŸã‚ã«ã¯ã€
`NEL@h
`å¿œç­”~header$ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã€‚
ãã®~ABNF `RFC5234$r æ§‹æ–‡ã¯ï¼š
â—
The NEL response header is used to communicate an origin's NEL policy to the user agent. The ABNF (Augmented Backus-Naur Form) [RFC5234] syntax for the NEL header is as follows:
</p>

<pre class="bnf">
NEL
	= json-field-value
</pre>

<p>
ã“ã®~headerã®å€¤ã¯ã€
~JSON~objã®é…åˆ—ã¨ã—ã¦ï¼Œ
`json-field-valueï¼ https://datatracker.ietf.org/doc/html/draft-reschke-http-jfv#json-field-value$P
ã«å®šç¾©ã•ã‚Œã‚‹ã¨ãŠã‚Šã«è§£é‡ˆã•ã‚Œã‚‹ã€‚
ã“ã®é…åˆ—~å†…ã®å„~objã¯ã€
ã‚ã‚‹`~NELæ–½ç­–$ã‚’ç”Ÿæˆå…ƒ~ç”¨ã«å®šç¾©ã™ã‚‹ã€‚
~UAã¯ã€
é…åˆ—~å†…ã®æœ€åˆã®æ–½ç­–ãŒå¦¥å½“ã§ã‚ã‚‹â€ ãªã‚‰ã°ï¼Œãã‚Œã‚’å‡¦ç†ã—ãŸä¸Šã§ã€
æ®‹ã‚Šã®æ–½ç­–ã¯ç„¡è¦–ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The header's value is interpreted as an array of JSON objects, as defined by json-field-value. Each object in the array defines an NEL policy for the origin. The user agent MUST process the first valid policy in the array and ignore any additional policies in the array.
</p>

<p class="trans-note">ã€â€ 
åŸæ–‡ã¯ â€œå¦¥å½“ãªæ–½ç­–ã®ã†ã¡æœ€åˆã®ã‚‚ã®â€ ã¨è§£é‡ˆã§ãã¦ã—ã¾ã†ãŒã€
`å®Ÿéš›ã®å®šç¾©ï¼ #process-policy-headers$ã§ã¯ï¼Œ
é…åˆ—~å†…ã®æœ€åˆã®~itemä»¥å¤–ã¯ã™ã¹ã¦ç„¡è¦–ã—ã¦ã„ã‚‹ã€‚
ã€‘</p>

<p>
~UAã¯ã€
~fieldã‚„å€¤ã®ã†ã¡ï¼»
ã“ã®ä»•æ§˜ã«å®šç¾©ã™ã‚‹æ§‹æ–‡ã«é©åˆã—ãªã„ã‚‚ã®ï¼
æœªçŸ¥ãªã‚‚ã®ï¼
å¦¥å½“ã§ãªã„ã‚‚ã®
ï¼½ã‚’ç„¡è¦–ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
å¦¥å½“ãª `NEL$h ~headerã¯ã€ï¼»
ã“ã®ä»•æ§˜ãŒå¿…é ˆã§ã‚ã‚‹ã¨å®šç¾©ã™ã‚‹~field
ï¼½ã™ã¹ã¦ã‚’ä¼´ã†~objã‚’ï¼Œ 1 å€‹~ä»¥ä¸Šã¯åŒ…å«ã—ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
User agents MUST ignore any unknown or invalid field(s) or value(s) that do not conform to the syntax defined in this specification. A valid NEL header field MUST, at a minimum, contain one object with all of the "REQUIRED" fields defined in this specification.
</p>

<p>
ï¼»
~scripting ã€ XSS ã€‘ æ”»æ’ƒã«ã‚ˆã‚‹ï¼Œ~errorå ±å‘Šå‡¦ç†ã®ä¹—å–ã‚Š
ï¼½ã‚’è»½æ¸›ã™ã‚‹ãŸã‚ã€
~UAã¯ï¼Œ
`meta^e è¦ç´ ã‚’ä»‹ã—ã¦æŒ‡å®šã•ã‚ŒãŸ `NEL$h ~headerã¯ï¼Œç„¡è¦–ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
`~NELæ–½ç­–$ã¯ã€
 `NEL$h `å¿œç­”~header$ã‚’ä»‹ã—ã¦é€é”ã•ã‚Œãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The user agent MUST ignore the NEL header specified via a meta element to mitigate hijacking of error reporting via scripting attacks. The NEL policy MUST be delivered via the NEL response header.
</p>

<p class="note">æ³¨è¨˜ï¼š
`meta^e è¦ç´ ã«å¯¾ã™ã‚‹åˆ¶ç´„ã¯ã€
 `CSP$r ä»•æ§˜ã«æ•´åˆã™ã‚‹
â€” ãã‚Œã‚‚ã€
åŒã˜äº‹ç”±ã‹ã‚‰ï¼Œå ±å‘Šå‡¦ç† ç™»éŒ²ã‚’~HTTP~headerã®ã¿ã«åˆ¶ç´„ã—ã¦ã„ã‚‹ã€‚
â—
Note

The restriction on meta element is consistent with the [CSP] specification, which restricts reporting registration to HTTP header fields only for the same reasons.
</p>

			<section id="the-report_to-member">
<h4 title="The report_to member">4.1.1. `report_to^c ~member</h4>

<p>
`report_to@c
~memberã¯ã€
ã“ã®`~NELæ–½ç­–$ç”¨ã®å ±å‘Šã®é€ä¿¡-å…ˆã«ãªã‚‹`å ±å‘Šå…ˆ~group$ã‚’æŒ‡å®šã™ã‚‹ã€‚
`report_to$c ~memberã¯ã€
`~NELæ–½ç­–$ã‚’ç™»éŒ²ã™ã‚‹ã¨ãã«ã¯å¿…é ˆã§ã‚ã‚Šã€
ä»¥å‰ã®ç™»éŒ²ã‚’é™¤å»ã™ã‚‹ã“ã¨ãŒæ„å›³ã«ã‚ã‚‹ãªã‚‰ã°ä»»æ„é¸æŠ~ã§ã‚ã‚‹
â€” `max_age$c ã‚’è¦‹ã‚ˆã€‚
åœ¨ã‚‹å ´åˆã€
ãã®å€¤ã¯æ–‡å­—åˆ—ï¼ˆ `String^jt å‹ï¼‰ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤
â€” ä»–ã®å‹ã¯ã€
æ§‹æ–‡è§£æ-~errorã«ãªã‚‹ã¨ã™ã‚‹ã€‚
â—
The report_to member specifies the endpoint group that reports for this NEL policy will be sent to. The report_to member is REQUIRED to register a NEL policy, and OPTIONAL if the intent is to remove a previous registration â€“ see max_age. If present, its value MUST be a string; any other type will result in a parse error.
</p>

<p class="note">æ³¨è¨˜ï¼š
~NELå ±å‘Šã®é€é”ã‚’æ”¹å–„ã™ã‚‹ãŸã‚ã€
`~server$ã¯ï¼Œ
`report_to^c ã«è¨­å®šã™ã‚‹`å ±å‘Šå…ˆ~group$ã«ï¼»
~fetchã—ãŸè³‡æºã®ç”Ÿæˆå…ƒã¨ã¯éš”ãŸã‚ŒãŸåŸºç›¤ã«å±ã™ã‚‹ï¼Œä»£æ›¿~ç”Ÿæˆå…ƒ
ï¼½å†…ã«ã‚ã‚‹å ±å‘Šå…ˆã‚’ 1 å€‹~ä»¥ä¸Šã¯åŒ…å«ã™ã‚‹ã¹ãã§ã‚ã‚‹
â€” ã•ã‚‚ãªã‘ã‚Œã°ã€
å•é¡ŒãŒè§£æ¶ˆã•ã‚Œã‚‹ã¾ã§~network~errorã‚’å ±å‘Šã—å¾—ãªããªã‚‹ã®ã§ã€‚
åŠ ãˆã¦ã€ï¼»
ä¸€éƒ¨ã®å ±å‘Šå…ˆã«åˆ°é”-ä¸èƒ½ãªå ´åˆã®ä»£æ›¿
ï¼½ã¨ã—ã¦è¤‡æ•°ã®å ±å‘Šå…ˆã‚’ä¾›ã™ã‚‹ã¹ãã§ã‚ã‚‹ã€‚
â—
Note

To improve delivery of NEL reports, the server should set report_to to an endpoint group containing at least one endpoint in an alternative origin whose infrastructure is not coupled with the origin from which the resource is being fetched â€” otherwise network errors cannot be reported until the problem is solved, if ever â€” and provide multiple endpoints to provide alternatives if some endpoints are unreachable.
</p>

			</section>
			<section id="the-max_age-member">
<h4 title="The max_age member">4.1.2. `max_age^c ~member</h4>

<p>
`max_age@c
~memberã¯ã€
å¿…é ˆã§ã‚ã‚Šï¼Œã“ã®`~NELæ–½ç­–$ã®å­˜ç¶šæœŸé–“ã‚’ç§’æ•°ã§æŒ‡å®šã™ã‚‹ã€‚
ãã®å€¤ã¯ã€
è² ã§ãªã„æ•´æ•°ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤
â€” ä»–ã®å‹ã¯ã€
æ§‹æ–‡è§£æ-~errorã«ãªã‚‹ã¨ã™ã‚‹ã€‚
â—
The REQUIRED max_age member specifies the lifetime of this NEL policy, as a non-negative integer number of seconds. Its value MUST be an non-negative integer; any other type will result in a parse error.
</p>

<p>
å€¤ã‚’ 0 ã«ã™ã‚‹ã¨ã€
ã“ã®`ç”Ÿæˆå…ƒ$ç”¨ã®`~NELæ–½ç­–$ã¯ï¼Œ
`æ–½ç­–~cache$ã‹ã‚‰é™¤å»ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
A value of 0 will cause any NEL policy for this origin to be removed from the policy cache.
</p>

<p class="note">æ³¨è¨˜ï¼š
~NELå ±å‘Šã®é€é”ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã€
`~server$ã¯ï¼Œï¼»
`å ±å‘Šå…ˆ~group$ã‚‚ï¼Œååˆ†é«˜ã„ `max_age^c ã§ç’°å¢ƒè¨­å®šã•ã‚Œã‚‹
ï¼½ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹ã¹ãã§ã‚ã‚‹ã€‚
<!-- ~Reportingæ–½ç­– -->
ã“ã®ç”Ÿæˆå…ƒ~ç”¨ã®`å ±å‘Šå…ˆ~group$ãŒå¤±åŠ¹ã—ãŸå ´åˆã€
~NELæ–½ç­–ãŒå¤±åŠ¹ã—ã¦ã„ãªãã¨ã‚‚ï¼Œ~NELå ±å‘Šã¯é€é”ã•ã‚Œãªããªã‚‹ã€‚
â—
Note

To ensure delivery of NEL reports, the server should ensure that the Reporting endpoint group is also configured with a sufficiently high max_age. If the Reporting policy expires, NEL reports will not be delivered, even if the NEL policy has not expired.
</p>

			</section>
			<section id="the-include_subdomains-member">
<h4 title="The include_subdomains member">4.1.3. `include_subdomains^c ~member</h4>

<p>
`include_subdomains@c
~memberã¯ã€
ä»»æ„é¸æŠ~ã§ã‚ã‚Šï¼Œï¼»
~objå†…ã«ã“ã®~memberãŒåœ¨ã£ã¦, ã‹ã¤ ãã®å€¤ã¯çœŸå½å€¤ï¼ˆ `Boolean^jt å‹ ï¼‰ `true^jv
ï¼½ãªã‚‰ã°ï¼Œã“ã®`~NELæ–½ç­–$ã‚’ï¼Œã“ã®ç”Ÿæˆå…ƒã®ã™ã¹ã¦ã®ä¸‹ä½domainç”¨ã«ã‚‚å¯èƒ½åŒ–ã™ã‚‹
ï¼ˆä¸‹ä½domainã®æ·±ã•ã¯åˆ¶é™ã•ã‚Œãªã„ï¼‰
â€” ä»–ã®å ´åˆã€
ã“ã®`~NELæ–½ç­–$ã¯ä¸‹ä½domainç”¨ã«ã¯å¯èƒ½åŒ–ã•ã‚Œãªã„ã€‚
â—
The OPTIONAL include_subdomains member is a boolean that enables this NEL policy for all subdomains of this origin (to an unlimited subdomain depth). If no member named include_subdomains is present in the object, or its value is not true, the NEL policy will not be enabled for subdomains.
</p>

<p class="note">æ³¨è¨˜ï¼š
~appã¯ã€
ä¸‹ä½domainç”¨ã®~NELå ±å‘Šã®é€é”ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«ã¯ã€ï¼»
ãã®`å ±å‘Šå…ˆ~group$ã‚‚ï¼Œ `include_subdomains^c ãŒå¯èƒ½åŒ–ã•ã‚Œã‚‹ã‚ˆã†ç’°å¢ƒè¨­å®šã•ã‚Œã‚‹
ï¼½ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹ã¹ãã§ã‚ã‚‹ã€‚
ã“ã®ç”Ÿæˆå…ƒ~ç”¨ã®`å ±å‘Šå…ˆ~group$ãŒç„¡ã„ã‹ï¼Œæ‰€ä¸ã®ä¸‹ä½domainç”¨ã«åˆ¥ã€…ãª`å ±å‘Šå…ˆ~group$ã€ï¼~Reportingæ–½ç­–ã€‘ã¯ç„¡ã„å ´åˆã€
ãã®ä¸‹ä½domainç”¨ã®~NELå ±å‘Šã¯é€é”ã•ã‚Œãªããªã‚‹
â€” ~NELæ–½ç­–ã«ã¦ä¸‹ä½domainã‚’å«ã‚“ã§ã„ãŸã¨ã—ã¦ã‚‚ã€‚
â—
Note

To ensure delivery of NEL reports for subdomains, the application should ensure that the Reporting endpoint group is also configured with include_subdomains enabled. If the Reporting policy is not, and there is not a separate Reporting policy for a given subdomain, NEL reports for that subdomain will not be delivered, even if the NEL policy includes the subdomain.
</p>
			</section>
			<section id="the-success_fraction-member">
<h4 title="The success_fraction member">4.1.4. `success_fraction^c ~member</h4>

<p>
`success_fraction@c
~memberã¯ã€
ä»»æ„é¸æŠ~ã§ã‚ã‚Šï¼Œï¼»
ã“ã®ç”Ÿæˆå…ƒ~ç”¨ã®`~networkè¦è«‹$ã®ã†ã¡`æˆåŠŸã—ãŸ$ã‚‚ã®
ï¼½ã«ã¤ã„ã¦ã®å ±å‘Šã«é©ç”¨ã•ã‚Œã‚‹ã¹ãã§ã‚ã‚‹`è¦‹æœ¬æŠ½å‡ºç‡$ã‚’å®šç¾©ã™ã‚‹ã€‚
åœ¨ã‚‹å ´åˆã®å€¤ã¯ 0.0 ä»¥ä¸Š 1.0 ä»¥ä¸‹ã®å®Ÿæ•°ï¼ˆ `Number^jt å‹ï¼‰ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤
â€” ä»–ã®å€¤ã¯ã€
æ§‹æ–‡è§£æ-~errorã«ãªã‚‹ã¨ã™ã‚‹ã€‚
ã“ã®~memberãŒç„¡ã„å ´åˆã€
~UAã¯ï¼»
ã“ã®ç”Ÿæˆå…ƒ~ç”¨ã®`~networkè¦è«‹$ã®ã†ã¡`æˆåŠŸã—ãŸ$ã‚‚ã®
ï¼½ã«ã¤ã„ã¦ã¯~NELå ±å‘Šã‚’`åé›†ã—ãªã„^emã“ã¨ã«ãªã‚‹ã€‚
â—
The OPTIONAL success_fraction member defines the sampling rate that should be applied to reports about successful network requests for this origin. If present, its value MUST be a number between 0.0 and 1.0, inclusive; any other value will result in a parse error. If this member is not present, the user agent will not collect NEL reports about successful network requests for this origin.
</p>

			</section>
			<section id="the-failure_fraction-member">
<h4 title="The failure_fraction member">4.1.5. `failure_fraction^c ~member</h4>

<p>
`failure_fraction@c
~memberã¯ã€
ä»»æ„é¸æŠ~ã§ã‚ã‚Šï¼Œï¼»
ã“ã®ç”Ÿæˆå…ƒ~ç”¨ã®`~networkè¦è«‹$ã®ã†ã¡`å¤±æ•—ã—ãŸ$ã‚‚ã®
ï¼½ã«ã¤ã„ã¦ã®å ±å‘Šã«é©ç”¨ã•ã‚Œã‚‹ã¹ãã§ã‚ã‚‹`è¦‹æœ¬æŠ½å‡ºç‡$ã‚’å®šç¾©ã™ã‚‹ã€‚
åœ¨ã‚‹å ´åˆã®å€¤ã¯ 0.0 ä»¥ä¸Š 1.0 ä»¥ä¸‹ã®å®Ÿæ•°ï¼ˆ `Number^jt å‹ï¼‰ã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤
â€” ä»–ã®å€¤ã¯ã€
æ§‹æ–‡è§£æ-~errorã«ãªã‚‹ã¨ã™ã‚‹ã€‚
ã“ã®~memberãŒç„¡ã„å ´åˆã€
~UAã¯ï¼»
ã“ã®ç”Ÿæˆå…ƒ~ç”¨ã®`~networkè¦è«‹$ã®ã†ã¡`å¤±æ•—ã—ãŸ$ã‚‚ã®
ï¼½`ã™ã¹ã¦^emã«ã¤ã„ã¦ã®~NELå ±å‘Šã‚’åé›†ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
The OPTIONAL failure_fraction member defines the sampling rate that should be applied to reports about failed network requests for this origin. If present, its value MUST be a number between 0.0 and 1.0, inclusive; any other value will result in a parse error. If this member is not present, the user agent will collect NEL reports about all failed network requests for this origin.
</p>

			</section>
			<section id="the-request_headers-member">
<h4 title="The request_headers member">4.1.6. `request_headers^c ~member</h4>

<p>
`request_headers@c
~memberã¯ã€
ä»»æ„é¸æŠ~ã§ã‚ã‚Šï¼Œ`è¦è«‹~headerå~list$nPã‚’å®šç¾©ã™ã‚‹ã€‚
ãã‚Œã‚’æˆã™å„`åå‰$hdã¨å¯¾å¿œã™ã‚‹`å€¤$hdã¯ã€
ã“ã®`ç”Ÿæˆå…ƒ$ã«ã¤ã„ã¦ã®`~network~errorå ±å‘Š$å†…ã«å«ã¾ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
åœ¨ã‚‹å ´åˆã®å€¤ã¯ï¼Œæ–‡å­—åˆ—ãŸã¡ãŒæˆã™~listã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The OPTIONAL request_headers member defines the list of request headers whose names and values will be included in network error reports about this origin. If present, its value MUST be a list of strings.
</p>

			</section>
			<section id="the-response_headers-member">
<h4 title="The response_headers member">4.1.7. `response_headers^c ~member</h4>

<p>
`response_headers@c
~memberã¯ã€
ä»»æ„é¸æŠ~ã§ã‚ã‚Šï¼Œ`å¿œç­”~headerå~list$nPã‚’å®šç¾©ã™ã‚‹ã€‚
ãã‚Œã‚’æˆã™å„`åå‰$hdã¨å¯¾å¿œã™ã‚‹`å€¤$hdã¯ã€
ã“ã®`ç”Ÿæˆå…ƒ$ã«ã¤ã„ã¦ã®`~network~errorå ±å‘Š$å†…ã«å«ã¾ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
åœ¨ã‚‹å ´åˆã®å€¤ã¯ï¼Œæ–‡å­—åˆ—ãŸã¡ãŒæˆã™~listã§ãªã‘ã‚Œã°ãƒŠãƒ©ãƒŠã‚¤ã€‚
â—
The OPTIONAL response_headers member defines the list of response headers whose names and values will be included in network error reports about this origin. If present, its value MUST be a list of strings.
</p>

			</section>
		</section>
		<section id="process-policy-headers">
<h3 title="Process policy headers">4.2. æ–½ç­–~headerã®å‡¦ç†-æ³•</h3>

<div class="algo">
<p>
ã“ã®~algoã¯ã€
æ‰€ä¸ã®
( `~networkè¦è«‹$ %è¦è«‹, %è¦è«‹ ã«å¯¾ã™ã‚‹`å¿œç­”$ %å¿œç­” )
ã«å¯¾ã—ï¼Œï¼»
%è¦è«‹ ã®`ç”Ÿæˆå…ƒ$ç”¨ã®`~NELæ–½ç­–$ã‚’æŠ½å‡ºã—ãŸçµæœ
ï¼½ã«å‰‡ã£ã¦`æ–½ç­–~cache$ã‚’æ›´æ–°ã™ã‚‹ï¼š
â—
Given a network request (request) and its corresponding response (response), this algorithm extracts a NEL policy for request's origin, and updates the policy cache accordingly.
</p>
<ol>
	<li>
%ç”Ÿæˆå…ƒ ~LET %è¦è«‹ ã®`ç”Ÿæˆå…ƒ$
â—
â†“</li>
	<li>
~IFï¼»
`ç”Ÿæˆå…ƒã¯ä¿¡ç”¨ã«ä¾¡ã—å¾—ã‚‹ã‹ï¼Ÿ$( %ç”Ÿæˆå…ƒ ) ~EQ `ä¾¡ã—ãªã„^i
ï¼½
â‡’
~RET
â—
Abort these steps if any of the following conditions are true:
â—
The result of executing the "Is origin potentially trustworthy?" algorithm on request's origin is not Potentially Trustworthy.
</li>
	<li>
~IFï¼»
%å¿œç­” ã®`~header~list$rså†…ã« `NEL^h ã‚’`åå‰ã«æŒã¤~header$ã¯ç„¡ã„
ã€ï¼`NEL^h ã‚’åå‰ã«æŒã¤`å¿œç­”~header$ã‚’åŒ…å«ã—ãªã„ã€‘
ï¼½
â‡’
~RET
â—
response does not contain a response header whose name is NEL.
â—
â†‘Let origin be request's origin.
</li>
	<li>
<p>
%~key ~LET `~networkåŒºåˆ†~keyã‚’æ±ºå®šã™ã‚‹$( %è¦è«‹ ã®`äºˆç´„-æ¸ˆã¿~client$rq )
</p>

<p class="trans-note">ã€
äºˆç´„-æ¸ˆã¿~client ~EQ ~NULL ã®å ´åˆã®çµæœãŒå®šç¾©ã•ã‚Œãªã„ã€‚
ãã®ã‚ˆã†ãªäº‹ä¾‹ã¯ç”Ÿã˜å¾—ãªã„ã‹ï¼Œ
`è¦è«‹ã®~networkåŒºåˆ†~keyã‚’æ±ºå®šã™ã‚‹$( %è¦è«‹ )
ã«æ”¹ã‚ã‚‰ã‚Œã‚‹ã¹ãã§ã‚ã‚ã†ã€‚
ã€‘</p>
â—
Let key be the result of calling determine the network partition key, given request's reserved client.
</li>
	<li>
%~header ~LET  å `NEL^h ã®`å¿œç­”~header$ã®å€¤
â—
Let header be the value of the response header whose name is NEL.
</li>
	<li>
%~list ~LET 
%~header ã‚’ä¸ãˆã‚‹ä¸‹ã§
`HTTP-JFV$r Â§ 4 ã«å®šç¾©ã•ã‚Œã‚‹~algoã‚’å®Ÿè¡Œã—ãŸçµæœ
â—
Let list be the result of executing the algorithm defined in Section 4 of [HTTP-JFV] on header.ï¼¼
</li>
	<li>
~IFï¼»
%~list ã¯~errorã§ã‚ã‚‹
ï¼½~ORï¼»
%~list ã¯ç©ºã§ã‚ã‚‹
ï¼½
â‡’
~RET
â—
If that algorithm results in an error, or if list is empty, abort these steps.
</li>
	<li>
%~item ~LET %~list[ 0 ]
â—
Let item be the first element of list.
</li>
	<li>
%max_age ~LET %~item å†…ã« `max_age$c ~memberã¯ï¼»
åœ¨ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
ç„¡ã„ãªã‚‰ã° Îµ
ï¼½
â—
â†“</li>
	<li>
%report_to ~LET %~item å†…ã« `report_to$c ~memberã¯ï¼»
åœ¨ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
ç„¡ã„ãªã‚‰ã° Îµ
ï¼½
â—
â†“</li>
	<li>
%success_fraction ~LET %~item å†…ã« `success_fraction$c ~memberã¯ï¼»
åœ¨ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
ç„¡ã„ãªã‚‰ã° 0.0
ï¼½
â—
â†“</li>
	<li>
%failure_fraction ~LET %~item å†…ã« `failure_fraction$c ~memberã¯ï¼»
åœ¨ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
ç„¡ã„ãªã‚‰ã° 1.0
ï¼½
â—
â†“</li>
	<li>
%include_subdomains ~LET ~ISï¼»
%~item å†…ã« `include_subdomains$c ~memberã¯åœ¨ã£ã¦ï¼Œãã®å€¤ ~EQ `true^jv
ï¼½
â—
â†“</li>
	<li>
<p>
%request_headers ~LET %~item å†…ã« `request_headers$c ~memberã¯ï¼»
åœ¨ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
ç„¡ã„ãªã‚‰ã° Â« Â» â€ 
ï¼½
</p>

<p class="trans-note">ã€â€ 
åŸæ–‡ã«ã¯ç„¡ã„å ´åˆã®å€¤ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ãŒã€
ä»–æ‰€ã®å®šç¾©ã‹ã‚‰ï¼Œ~listã«ãªã‚‹å¿…è¦ãŒã‚ã‚‹
ï¼ˆæ¬¡ã®æ®µã‚‚åŒæ§˜ï¼‰ã€‚
ã€‘</p>
â—
â†“</li>
	<li>
%response_headers ~LET %~item å†…ã« `response_headers$c ~memberã¯ï¼»
åœ¨ã‚‹ãªã‚‰ã° ãã®å€¤ ï¼
ç„¡ã„ãªã‚‰ã° Â« Â»
ï¼½
â—
â†“</li>
	<li>
<p>
~IFï¼»
%max_age ã¯å®Ÿæ•°ã§ãªã„
ï¼½~ORï¼»
%max_age ~LT 0 â€ 
ï¼½
â‡’
~RET
</p>

<p class="trans-note">ã€â€ 
ã“ã®æ¡ä»¶ã¯ã€
ã“ã®è¨³ã«ã‚ˆã‚‹è£œå®Œï¼ˆ `max_age$c ã®è¨˜è¿°ã‚’è¦‹ã‚ˆï¼‰ã€‚
ã€‘</p>
â—
If item has no member named max_age, or that member's value is not a number, abort these steps.
</li>
	<li>
<p>
~IFï¼»
%max_age ~EQ 0
ï¼½ï¼š
</p>
		<ol>
			<li>
<p>
`æ–½ç­–~cache$ã®`~keyç¾¤$mapã‚’æˆã™
~EACH( %~cache~key )
ã«å¯¾ã—
â‡’
~IFï¼»
%~cache~key ã®ç”Ÿæˆå…ƒ ~EQ %ç”Ÿæˆå…ƒ
ï¼½
â‡’
`æ–½ç­–~cache$[ %~cache~key ] ~SET Îµ
</p>

<p class="trans-note">ã€
æœ¬å½“ã¯ã€
å˜ã«ï¼»
`æ–½ç­–~cache$[ ( %~key, %ç”Ÿæˆå…ƒ ) ] ~SET Îµ
ï¼½ã‹ã‚‚ã—ã‚Œãªã„
â€” æ–½ç­–~cacheã«`~networkåŒºåˆ†~key$ãŒè¿½åŠ ã•ã‚ŒãŸæ›´æ–°ã«ä¼´ã„ï¼Œ
ã“ã®æ®µã‚‚æ›´æ–°ã•ã‚Œã‚‹ã¹ããªã‚‰ã°ã€‚
ã€‘</p>

			</li>
			<li>
~RET
</li>
		</ol>
â—
If the value of item's max_age member is 0, then remove any NEL policy from the policy cache whose origin is origin, and skip the remaining steps.
</li>
	<li>
<p>
~IFï¼»
~NOT ~ANDâ†“
ï¼½â€¦
</p>
		<ul>
			<li>
%report_to ã¯æ–‡å­—åˆ—ã§ã‚ã‚‹
</li>
			<li>
%success_fraction ã¯å®Ÿæ•°ã§ã‚ã‚‹
</li>
			<li>
%success_fraction ~GTE 0.0
</li>
			<li>
%success_fraction ~LTE 1.0
</li>
			<li>
%failure_fraction ã¯å®Ÿæ•°ã§ã‚ã‚‹
</li>
			<li>
%failure_fraction ~GTE 0.0
</li>
			<li>
%failure_fraction ~LTE 1.0
</li>
			<li>
%request_headers ã‚’æˆã™ã©ã®~itemã‚‚æ–‡å­—åˆ—ã§ã‚ã‚‹
</li>
			<li>
%response_headers ã‚’æˆã™ã©ã®~itemã‚‚æ–‡å­—åˆ—ã§ã‚ã‚‹
</li>
		</ul>
<p>
â€¦ãªã‚‰ã°
â‡’
~RET
</p>
â—
If item has no member named report_to, or that member's value is not a string, abort these steps.
â—
If item has a member named success_fraction, whose value is not a number in the range 0.0 to 1.0, inclusive, abort these steps.
â—
If item has a member named failure_fraction, whose value is not a number in the range 0.0 to 1.0, inclusive, abort these steps.
â—
If item has a member named request_headers, whose value is not a list, or if any element of that list is not a string, abort these steps.
â—
If item has a member named response_headers, whose value is not a list, or if any element of that list is not a string, abort these steps.
</li>
	<li>
<p>
%æ–½ç­– ~LET æ–°ãŸãª`~NELæ–½ç­–$
â€” ãã®
â‡’ï¼ƒ
`å—ä¿¡ã—ãŸ~IP~address$nP ~SET ~UAã« %å¿œç­” ã‚’é€ä¿¡ã—ãŸ`~server$ã®~IP~addressâ€ ,
`ç”Ÿæˆå…ƒ$ ~SET %ç”Ÿæˆå…ƒ,
`ä¸‹ä½domainã‚’å«ã‚€ã‹$nP ~SET %include_subdomains,
`è¦è«‹~headerå~list$nP ~SET %request_headers,
`å¿œç­”~headerå~list$nP ~SET %response_headers,
`å ±å‘Šç”¨~group$nP ~SET %report_to,
`æœ‰åŠ¹ç§’æ•°$nP ~SET %max_age,
`ä½œæˆæ™‚åˆ»$nP ~SET `å£~æ™‚è¨ˆã®å®‰å…¨ã§ãªã„ç¾åœ¨ã®æ™‚åˆ»$,
`æˆåŠŸ~æ™‚ã®è¦‹æœ¬æŠ½å‡ºç‡$ ~SET %success_fraction,
`å¤±æ•—~æ™‚ã®è¦‹æœ¬æŠ½å‡ºç‡$ ~SET %failure_fraction
â—
Let policy be a new NEL policy whose properties are set as follows:
â—
received IP address
â€¢ the IP address of the server that the user agent received response from
â€¢ Editor's note
â€¢ Plumb this through more explicitly in [FETCH].
origin
â€¢ origin
subdomains flag
â€¢ include if item has a member named include_subdomains whose value is true, exclude otherwise
request headers
â€¢ the value of item's request_headers member
response headers
â€¢ the value of item's response_headers member
reporting group
â€¢ the value of item's report_to member
ttl
â€¢ the value of item's max_age member
creation
â€¢ the wall clock's unsafe current time
successful sampling rate
â€¢ the value of item's success_fraction member, if present; 0.0 otherwise 
failure sampling rate
â€¢ the value of item's failure_fraction member, if present; 1.0 otherwise 
</p>

<p class="note">â€ ç·¨é›†è€…æ³¨è¨˜ï¼š
ã“ã‚Œã‚’ `FETCH$r ã«ãŠã„ã¦ï¼Œã‚ˆã‚Šæ˜ç¤ºçš„ã«æ˜ã‚Šä¸‹ã’ã‚‹ã€‚
â—
â†‘</p>

	</li>
	<li>
`æ–½ç­–~cache$[ ( %~key, %ç”Ÿæˆå…ƒ ) ] ~SET %æ–½ç­–
â—
If there is already an entry in the policy cache for (key, origin), replace it with policy; otherwise, insert policy into the policy cache for (key, origin).
</li>
</ol>
</div>

		</section>
	</section>
	<section id="report-delivery">
<h2 title="Report delivery">5. å ±å‘Šã®é€é”</h2>

		<section id="choose-a-policy-for-a-request">
<h3 title="Choose a policy for a request">5.1. è¦è«‹~ç”¨ã®æ–½ç­–ã‚’é¸ã¶</h3>

<div class="algo">
<p>
ã“ã®~algoã¯ã€
æ‰€ä¸ã®
( `~networkè¦è«‹$ %è¦è«‹ )
ã«å¯¾ã—ï¼Œ`æ–½ç­–~cache$å†…ã®ã©ã®`~NELæ–½ç­–$ã‚’ %è¦è«‹ ç”¨ã®å ±å‘Šã‚’ç”Ÿæˆã™ã‚‹ã¨ãã«åˆ©ç”¨ã™ã‚‹ã¹ãã‹ã‚’æ±ºå®šã™ã‚‹ï¼š
â—
Given a network request (request), this algorithm determines which NEL policy in the policy cache should be used to generate reports for that network request.
</p>
<ol>
	<li>
%ç”Ÿæˆå…ƒ ~LET %è¦è«‹ ã®`ç”Ÿæˆå…ƒ$rq
â—
Let origin be request's origin.
</li>
	<li>
<p>
%~key ~LET `~networkåŒºåˆ†~keyã‚’æ±ºå®šã™ã‚‹$( %è¦è«‹ ã®`äºˆç´„-æ¸ˆã¿~client$rq )
</p>

<p class="trans-note">ã€
äºˆç´„-æ¸ˆã¿~client ~EQ ~NULL ã®å ´åˆã®çµæœãŒå®šç¾©ã•ã‚Œãªã„ã€‚
ãã®ã‚ˆã†ãªäº‹ä¾‹ã¯ç”Ÿã˜å¾—ãªã„ã‹ï¼Œ
`è¦è«‹ã®~networkåŒºåˆ†~keyã‚’æ±ºå®šã™ã‚‹$( %è¦è«‹ )
ã«æ”¹ã‚ã‚‰ã‚Œã‚‹ã¹ãã§ã‚ã‚ã†ã€‚
ã€‘</p>
â—
Let key be the result of calling determine the network partition key, given request's' reserved client.
</li>
	<li>
%æ–½ç­– ~LET `æ–½ç­–~cache$[ ( %~key, %ç”Ÿæˆå…ƒ ) ]
â—
â†“</li>
	<li>
~IFï¼»
%æ–½ç­– ~NEQ Îµ
ï¼½~ANDï¼»
%æ–½ç­– ã¯`å¤±åŠ¹ã—ã¦$ã„ãªã„
ï¼½
â‡’
~RET %æ–½ç­–
â—
If there is an entry in the policy cache for (key, origin):
â€¢ Let policy be that entry.
â€¢ If policy is not expired, return it.
</li>
	<li>
<p>
%ç”Ÿæˆå…ƒ ã«`ä¸Šä½domainåˆè‡´ã™ã‚‹ï¼ ~RFCx/rfc6797#section-8.2$
~EACH( %è¦ª~ç”Ÿæˆå…ƒ )
ã«å¯¾ã—ï¼š
â—
For each parent origin that is a superdomain match of origin:
</p>
		<ol>
			<li>
%è¦ª~æ–½ç­– ~LET `æ–½ç­–~cache$[ ( %~key, %è¦ª~ç”Ÿæˆå…ƒ ) ]
â—
â†“</li>
			<li>
~IFï¼»
%è¦ª~æ–½ç­– ~NEQ Îµ
ï¼½~ANDï¼»
%è¦ª~æ–½ç­– ã¯`å¤±åŠ¹ã—ã¦$ã„ãªã„
ï¼½~ANDï¼»
%è¦ª~æ–½ç­– ã®`ä¸‹ä½domainã‚’å«ã‚€ã‹$nP ~EQ ~T
ï¼½
â‡’
~RET %è¦ª~æ–½ç­–
â—
If there is an entry in the policy cache for (key, parent origin):
â€¢ Let policy be that entry.
â€¢ If policy is not expired, and its subdomains flag is include, return it.
</li>
		</ol>
	</li>
	<li>
~RET Îµ
â—
Return no policy.
</li>
</ol>
</div>

		</section>
		<section id="extract-request-headers">
<h3 title="Extract request headers">5.2. è¦è«‹~headerãŸã¡ã‚’æŠ½å‡ºã™ã‚‹</h3>

<div class="algo">
<p>
ã“ã®~algoã¯ã€
æ‰€ä¸ã®
( `~networkè¦è«‹$ %è¦è«‹, `~NELæ–½ç­–$ %æ–½ç­– )
ã«å¯¾ã—ï¼Œï¼»
%æ–½ç­– ã‹ã‚‰æŒ‡å›³ã•ã‚ŒãŸä¸€é€£ã®~header
ï¼½ã®å€¤ã‚’ %è¦è«‹ ã‹ã‚‰æŠ½å‡ºã™ã‚‹ï¼š
â—
Given a network request (request) and a NEL policy (policy), this algorithm extracts header values from the request as instructed by the policy.
</p>
<ol>
	<li>
%~headerç¾¤ ~LET æ–°ãŸãª `Object^jt
â—
Let headers be a new empty ECMAScript object.
</li>
	<li>
<p>
%æ–½ç­– ã®`è¦è«‹~headerå~list$nPã‚’æˆã™
~EACH( %~headerå )
ã«å¯¾ã—ï¼š
â—
For each header name in policy's request headers list:
</p>
		<ol>
			<li>
%å€¤~ç¾¤ ~LET Â« Â»ã€ï¼ECMAScript listã€‘
â—
If request's header list does not contain header name, skip to the next header name in the list.
â—
Let values be an empty ECMAScript list.
</li>
			<li>
%è¦è«‹ ã®`~header~list$rqã‚’æˆã™
~EACH( %~headerå ã‚’`åå‰ã«æŒã¤~header$ %~header )
ã«å¯¾ã—
â‡’
%å€¤~ç¾¤ ã« %~header ã®`å€¤$hdã‚’ä»˜åŠ ã™ã‚‹
â—
For each header in request's header list whose name is header name, append header's value to values.
</li>
			<li>
~IFï¼»
%å€¤~ç¾¤ ã¯ç©ºã§ãªã„
ï¼½
â‡’
%~headerç¾¤ ã«
æ–°ãŸãª~prop( åå‰ %~headerå, å€¤ %å€¤~ç¾¤ )
ã‚’è¿½åŠ ã™ã‚‹
â—
Add a new property to headers whose name is header name and whose value is values.
</li>
		</ol>
	</li>
	<li>
~RET %~headerç¾¤
â—
Return headers.
</li>
</ol>
</div>

		</section>
		<section id="extract-response-headers">
<h3 title="Extract response headers">5.3. å¿œç­”~headerãŸã¡ã‚’æŠ½å‡ºã™ã‚‹</h3>

<div class="algo">
<p>
ã“ã®~algoã¯ã€
æ‰€ä¸ã®
( `å¿œç­”$ %å¿œç­”, `~NELæ–½ç­–$ %æ–½ç­– )
ã«å¯¾ã—ï¼Œï¼»
%æ–½ç­– ã‹ã‚‰æŒ‡å›³ã•ã‚ŒãŸ~headerãŸã¡
ï¼½ã®å€¤ã‚’ %å¿œç­” ã‹ã‚‰æŠ½å‡ºã™ã‚‹ï¼š
â—
Given a response (response) and a NEL policy (policy), this algorithm extracts header values from the response as instructed by the policy.
</p>
<ol>
	<li>
%~headerç¾¤ ~LET æ–°ãŸãª `Object^jt
â—
Let headers be a new empty ECMAScript object.
</li>
	<li>
<p>
%æ–½ç­– ã®`å¿œç­”~headerå~list$nPã‚’æˆã™
~EACH( %~headerå )
ã«å¯¾ã—ï¼š
â—
For each header name in policy's response headers list:
</p>
		<ol>
			<li>
%å€¤~ç¾¤ ~LET Â« Â»ã€ï¼ECMAScript listã€‘
â—
If response's header list does not contain header name, skip to the next header name in the list.
â—
Let values be an empty ECMAScript list.
</li>
			<li>
%å¿œç­” ã®`~header~list$rsã‚’æˆã™
~EACH( %~headerå ã‚’`åå‰ã«æŒã¤~header$ %~header )
ã«å¯¾ã—
â‡’
%å€¤~ç¾¤ ã« %~header ã®`å€¤$hdã‚’ä»˜åŠ ã™ã‚‹
â—
For each header in response's header list whose name is header name, append header's value to values.
</li>
			<li>
~IFï¼»
%å€¤~ç¾¤ ã¯ç©ºã§ãªã„
ï¼½
â‡’
%~headerç¾¤ ã«
æ–°ãŸãª~prop( åå‰ %~headerå, å€¤ %å€¤~ç¾¤ )
ã‚’è¿½åŠ ã™ã‚‹
â—
Add a new property to headers whose name is header name and whose value is values.
</li>
		</ol>
	</li>
	<li>
~RET %~headerç¾¤
â—
Return headers.
</li>
</ol>
</div>

		</section>
		<section id="generate-a-network-error-report">
<h3 title="Generate a network error report">5.4. ~network~errorå ±å‘Šã®ç”Ÿæˆ-æ³•</h3>

<div class="algo">
<p>
ã“ã®~algoã¯ã€
æ‰€ä¸ã®
( `~networkè¦è«‹$ %è¦è«‹, %è¦è«‹ ã«å¯¾ã™ã‚‹`å¿œç­”$ %å¿œç­” )
ã«å¯¾ã—ï¼Œ
åˆè‡´ã—ã¦ã„ã‚‹`~NELæ–½ç­–$ãŒåœ¨ã£ã¦æŒ‡å›³ã•ã‚ŒãŸãªã‚‰ã°
%è¦è«‹ ã«ã¤ã„ã¦ã®å ±å‘Šã‚’ç”Ÿæˆã—ã¦ï¼Œ
( çµæœã®å ±å‘Š, `~NELæ–½ç­–$ )
çµ„ã‚’è¿”ã™
â€” ä»–ã®å ´åˆã¯ ~NULL ã‚’è¿”ã™ï¼š
â—
Given a network request (request) and its corresponding response (response), this algorithm generates a report about request if instructed to by any matching NEL policy, and returns the report and the NEL policy. Otherwise this algorithm returns null.
</p>
<ol>
	<li>
~IFï¼»
`ç”Ÿæˆå…ƒã¯ä¿¡ç”¨ã«ä¾¡ã—å¾—ã‚‹ã‹ï¼Ÿ$( %è¦è«‹ ã®`ç”Ÿæˆå…ƒ$rq ) ~EQ `ä¾¡ã—ãªã„^i
ï¼½
â‡’
~RET ~NULL
â—
If the result of executing the "Is origin potentially trustworthy?" algorithm on request's origin is not Potentially Trustworthy, return null.
</li>
	<li>
%ç”Ÿæˆå…ƒ ~LET %è¦è«‹ ã®`ç”Ÿæˆå…ƒ$rq
â—
Let origin be request's origin.
</li>
	<li>
%æ–½ç­– ~LET `è¦è«‹~ç”¨ã®æ–½ç­–ã‚’é¸ã¶$( %è¦è«‹ )
â—
Let policy be the result of executing 5.1 Choose a policy for a request on request.ï¼¼
</li>
	<li>
~IFï¼»
%æ–½ç­– ~EQ Îµ
ï¼½
â‡’
~RET ~NULL
â—
If policy is no policy, return null.
</li>

	<li>
%è¦‹æœ¬æŠ½å‡ºç‡ ~LET ï¼»
%è¦è«‹ ã¯`æˆåŠŸã—ãŸ$ãªã‚‰ã° %æ–½ç­– ã®`æˆåŠŸ~æ™‚ã®è¦‹æœ¬æŠ½å‡ºç‡$ ï¼
%è¦è«‹ ã¯`å¤±æ•—ã—ãŸ$ãªã‚‰ã° %æ–½ç­– ã®`å¤±æ•—~æ™‚ã®è¦‹æœ¬æŠ½å‡ºç‡$
ï¼½
â—
Determine the active sampling rate for this request:
â€¢ If request succeeded, let sampling rate be policy's successful sampling rate.
â€¢ If request failed, let sampling rate be policy's failure sampling rate.
</li>
	<li>
%è³½ ~LET 0.0 ä»¥ä¸Š 1.0 ä»¥ä¸‹ã®~randomãªå®Ÿæ•°
ï¼ˆ %è¦è«‹ ã‚’å ±å‘Šã™ã‚‹ã‹ã©ã†ã‹è£å®šã™ã‚‹ï¼‰
â—
Decide whether or not to report on this request. Let roll be a random number between 0.0 and 1.0, inclusive.ï¼¼
</li>
	<li>
~IFï¼»
%è³½ ~GT %è¦‹æœ¬æŠ½å‡ºç‡
ï¼½
â‡’
~RET ~NULL
â—
If roll &gt; sampling rate, return null.
</li>
	<li>
<p>
%å ±å‘Š~æœ¬ä½“ ~LET æ¬¡ã«æŒ™ã’ã‚‹~propã‚’ä¼´ã†ï¼Œæ–°ãŸãª `Object^jt `ECMA-262$r ï¼š
â—
Let report body be a new ECMAScript object with the following properties: [ECMA-262]
</p>
		<dl>
			<dt>`sampling_fraction^c</dt>
			<dd>
%è¦‹æœ¬æŠ½å‡ºç‡
â—
sampling rate
</dd>

			<dt>`elapsed_time^c</dt>
			<dd>
~UAãŒï¼»
å½“ã®è³‡æº~fetchã‚’é–‹å§‹ã—ã¦ã‹ã‚‰ï¼Œå®Œäº†ã—ãŸã‹ä¸­æ­¢ã—ãŸã¨ã
ï¼½ã¾ã§ã«çµŒéã—ãŸ~milliç§’æ•°
â—
The elapsed number of milliseconds between the start of the resource fetch and when it was completed or aborted by the user agent.
</dd>

			<dt>`phase^c</dt>
			<dd>
%è¦è«‹ ã¯`å¤±æ•—ã—ãŸ$ãªã‚‰ã° ãã®`~network~error$ã®`ç›¸$nE ï¼
%è¦è«‹ ã¯`æˆåŠŸã—ãŸ$ãªã‚‰ã° `application^l
â—
If request failed, the phase of its network error. If request succeeded, "application".
</dd>

			<dt>`type^c</dt>
			<dd>
%è¦è«‹ ã¯`å¤±æ•—ã—ãŸ$ãªã‚‰ã° ãã®`~network~error$ã®`ç¨®åˆ¥$nE ï¼
%è¦è«‹ ã¯`æˆåŠŸã—ãŸ$ãªã‚‰ã° `ok^l
â—
If request failed, the type of its network error. If request succeeded, "ok".
</dd>
		</dl>
	</li>
	<li>
<p>
~IFï¼»
%å ±å‘Š~æœ¬ä½“ ã® `phase^c ~prop ~NEQ `dns^l
ï¼½
â‡’
%å ±å‘Š~æœ¬ä½“ ã«æ¬¡ã«æŒ™ã’ã‚‹~propã‚’ä»˜åŠ ã™ã‚‹ï¼š
â—
If report body's phase property is not dns, append the following properties to report body:
</p>
		<dl>
			<dt>`server_ip^c</dt>
			<dd>
<p>
~UAãŒ %è¦è«‹ ã‚’é€ä¿¡ã—ãŸå…ˆã®`~server$ã®~IP~address
â€” å¯ç”¨ã§ãªã„å ´åˆã€
ç©º~æ–‡å­—åˆ—ã€‚
â—
The IP address of the server to which the user agent sent the request, if available. Otherwise, an empty string.
</p>
				<ul>
					<li>
~IPv4~addressã§è­˜åˆ¥ã•ã‚Œã‚‹~hostã¯ã€ï¼»
ç¯„å›² 0 ã€œ 255 ã® 4 å€‹ã® 10 é€²~æ•°ã‚’ "." ã§åˆ†é›¢ã—ãŸä¸¦ã³
ï¼½ï¼ˆ `dotted-decimal^en è¡¨è¨˜æ³•ï¼‰
`RFC1123$r ã§è¡¨ç¾ã•ã‚Œã‚‹ã€‚
â—
A host identified by an IPv4 address is represented in dotted-decimal notation (a sequence of four decimal numbers in the range 0 to 255, separated by "."). [RFC1123]
</li>
					<li>
~IPv6~addressã§è­˜åˆ¥ã•ã‚Œã‚‹~hostã¯ã€
é †åºä»˜ã‘ã‚‰ã‚ŒãŸ
8 å€‹ã® 16-bit ç‰‡ãŒæˆã™~list ï¼ˆ `x:x:x:x:x:x:x:x^c ã®~~å½¢ã«ã‚ˆã‚‹ä¸¦ã³ï¼‰ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã‚‹
â€” ã“ã“ã§ã€
å„ "x" ã¯ã€
 16-bit ç‰‡ã‚’è¡¨ã™ï¼»
1 ã€œ 4 å€‹ã® 16 é€²æ•°å­—
ï¼½ã‹ã‚‰ãªã‚‹ï¼‰
`RFC4291$r
â—
A host identified by an IPv6 address is represented as an ordered list of eight 16-bit pieces (a sequence of x:x:x:x:x:x:x:x, where the 'x's are one to four hexadecimal digits of the eight 16-bit pieces of the address). [RFC4291]
</li>
				</ul>
			</dd>

			<dt>`protocol^c</dt>
			<dd>
å½“ã®è³‡æºã‚’~fetchã™ã‚‹ã¨ãã«åˆ©ç”¨ã—ãŸ
<abbr title="Application Layer Protocol Negotiation">ALPN</abbr> Protocol ID
ã«ã‚ˆã‚Šè­˜åˆ¥ã•ã‚Œã‚‹`~network~protocolï¼ ~RESOURCE-TIMING#dom-performanceresourcetiming-nexthopprotocol$
â€” å¯ç”¨ã§ãªã„å ´åˆã€
ç©º~æ–‡å­—åˆ—ã€‚
â—
The network protocol used to fetch the resource as identified by the ALPN Protocol ID, if available. Otherwise, "".
</dd>
		</dl>
	</li>
	<li>
<p>
~IFï¼»
%å ±å‘Š~æœ¬ä½“ ã® `phase^c ~prop ~NIN { `dns^l, `connection^l }
ï¼½
â‡’
%å ±å‘Š~æœ¬ä½“ ã«æ¬¡ã«æŒ™ã’ã‚‹~propã‚’ä»˜åŠ ã™ã‚‹ï¼š
â—
If report body's phase property is not dns or connection, append the following properties to report body:
</p>
		<dl>
			<dt>`referrer^c</dt>
			<dd>
%è¦è«‹ ã®`~client$rqã«çµä»˜ã‘ã‚‰ã‚ŒãŸ`~referreræ–½ç­–$â€ ã«ã‚ˆã‚Šæ±ºå®šã•ã‚Œã‚‹â€ â€ ï¼Œ
%è¦è«‹ ã®~referrerâ€ â€ â€ 
â—
request's referrer, as determined by the referrer policy associated with its client.
</dd>
			<dd class="trans-note">ã€â€ 
~clientã®`æ–½ç­–~å®¹å™¨$enVã®`~referreræ–½ç­–$pC
ã€‘ã€â€ â€ 
`è¦è«‹ã®~referrerã‚’æ±ºå®šã™ã‚‹~algoï¼ ~REFERRER-POLICY#determine-requests-referrer$
ã€‘ã€â€ â€ â€ 
`è¦è«‹ã®~referrerï¼ ~FETCH#concept-request-referrer$
ã€‘</dd>

			<dt>`method^c</dt>
			<dd>
%è¦è«‹ ã®`è¦è«‹~method$
â—
request's request method.
</dd>

			<dt>`request_headers^c</dt>
			<dd>
`è¦è«‹~headerãŸã¡ã‚’æŠ½å‡ºã™ã‚‹$( %è¦è«‹, %æ–½ç­– )
â—
The result of executing 5.2 Extract request headers on request and policy.
</dd>

			<dt>`response_headers^c</dt>
			<dd>
`å¿œç­”~headerãŸã¡ã‚’æŠ½å‡ºã™ã‚‹$( %å¿œç­”, %æ–½ç­– )
â—
The result of executing 5.3 Extract response headers on response and policy.
</dd>

			<dt>`status_code^c</dt>
			<dd>
~HTTPå¿œç­”ã®`çŠ¶æ…‹s~code$
â€” å¯ç”¨ã§ãªã„å ´åˆã€
 0 ã€‚
â—
The status code of the HTTP response, if available. Otherwise, 0.
</dd>
			<dd class="trans-note">ã€
ã—ãŸãŒã£ã¦ã€
å¯ç”¨ãªå ´åˆã‚‚ï¼Œ~dataå‹ã¯ï¼ˆ `String^jt ã§ã¯ãªãï¼‰ `Number^jt ã«ãªã‚‹ã§ã‚ã‚ã†ã€‚
ã€‘</dd>
		</dl>
	</li>
	<li>
<p>
~IFï¼»
( %ç”Ÿæˆå…ƒ, %æ–½ç­– ã®`ç”Ÿæˆå…ƒ$nP )
<!-- ï¼Šis not equal to â†’ not same-origin
https://github.com/w3c/network-error-logging/commit/56fdd4c985fc62ec8d41d912ffa3dd7193de0a3b#diff-eacf331f0ffc35d4b482f1d15a887d3b
-->
ã¯`åŒä¸€-ç”Ÿæˆå…ƒ$ã§ãªã„
ï¼½~ANDï¼»
%æ–½ç­– ã®`ä¸‹ä½domainã‚’å«ã‚€ã‹$nP ~EQ ~T
ï¼½~ANDï¼»
%å ±å‘Š~æœ¬ä½“ ã® `phase^c ~prop ~NEQ `dns^l
ï¼½
â‡’
~RET ~NULL
â—
If origin is not equal to policy's origin, policy's subdomains flag is include, and report body's phase property is not dns, return null.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ®µã¯ã€ï¼»
`ä¸‹ä½domainã‚’å«ã‚“ã§ï¼ #dfn-subdomains$ã„ã‚‹`~NELæ–½ç­–$
ï¼½ã‚’åˆ©ç”¨ã—å¾—ã‚‹ã®ã¯ï¼Œï¼»
`è¦è«‹$ã®`~DNSè§£æ±º$`ç›¸$ã®é–“ã«ï¼Œ
å½“ã®æ–½ç­–ã®`ç”Ÿæˆå…ƒ$nPã®ä¸‹ä½domainã«ã¤ã„ã¦å ±å‘Šã‚’ç”Ÿæˆã™ã‚‹
ï¼½ãŸã‚ã«é™ã‚‰ã‚Œã‚‹ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹ã€‚
è©³ç´°ã¯ã€
`Â§ ~privacyã®è€ƒæ…®ç‚¹ï¼ #privacy-considerations$ã‚’è¦‹ã‚ˆã€‚
â—
Note

This step ensures that subdomain NEL policies can only be used to generate reports about subdomains of the policy origin during the DNS resolution phase of a request. See 9. Privacy Considerations for more details.
</p>
	</li>
	<li>
<p>
~IFï¼»
%å ±å‘Š~æœ¬ä½“ ã® `phase^c ~prop ~NEQ `dns^l
ï¼½~ANDï¼»
%å ±å‘Š~æœ¬ä½“ ã® `server_ip^c ~prop ~NIN { ç©º~æ–‡å­—åˆ—, %æ–½ç­– ã®`å—ä¿¡ã—ãŸ~IP~address$nP }
ï¼½ï¼š
â—
If report body's phase property is not dns, and report body's server_ip property is non-empty and not equal to policy's received IP address:
</p>
		<ol>
			<li>
%å ±å‘Š~æœ¬ä½“ ã® `phase^c ~SET `dns^l
â—
Set report body's phase to dns.
</li>
			<li>
%å ±å‘Š~æœ¬ä½“ ã® `type^c ~SET `dns.address_changed^l
â—
Set report body's type to dns.address_changed.
</li>
			<li>
%å ±å‘Š~æœ¬ä½“ ã®æ¬¡ã«æŒ™ã’ã‚‹~propã‚’~clearã™ã‚‹
â‡’ï¼ƒ
`request_headers^c,
`response_headers^c,
`status_code^c,
`elapsed_time^c
â—
Clear report body's request_headers, response_headers, status_code, and elapsed_time properties.
</li>
			<li>
~Assertï¼š
ï¼»
`~DNSè§£æ±º$ã®é–“ã«å¯ç”¨ã§ãªã„æƒ…å ±
ï¼½ã‹ã‚‰å°å‡ºã•ã‚ŒãŸ %å ±å‘Š~æœ¬ä½“ å†…ã®~fieldã¯ã€
ã™ã¹ã¦~clearæ¸ˆã¿ã§ã‚ã‚‹ã€‚
â—
Assert: All fields in report body that are derived from information not available during DNS resolution have been cleared.
</li>
		</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ®µã¯ã€
`~server$ã®~IP~addressã¨`~NELæ–½ç­–$ %æ–½ç­– ãŒåˆè‡´ã—ãªã„å ´åˆã«ï¼Œ~NELå ±å‘Šã‚’ â€œé™æ ¼ã™ã‚‹â€ ã€‚
ã“ã‚Œã¯ã€ï¼»
~NELå ±å‘Šã¯ï¼Œãã‚ŒãŒè¿°ã¹ã‚‹ï¼»
~serviceã®æ‰€æœ‰è€…
ï¼½ã®ã¿ã«é€ä¿¡ã•ã‚Œã‚‹
ï¼½ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã®ï¼Œ~privacyä¿è­·ã§ã‚ã‚‹ã€‚
~IP~addressãŒåˆè‡´ã—ãªã„å ´åˆã€
~UAã¯ï¼»
%æ–½ç­– ãŒ`ç”Ÿæˆå…ƒ$ã®`~domainå$ã®æ‰€æœ‰è€…ã«ã‚ˆã‚Šé€ä¿¡ã•ã‚ŒãŸã‹å¦ã‹
ï¼½ã ã‘ã‚’æ¤œè¨¼yã§ãï¼Œï¼»
%æ–½ç­– ã¯ï¼»
ã“ã®`~domainå$ã‚’è§£æ±ºã—ã¦å¾—ã‚‰ã‚ŒãŸ`~server$
ï¼½ã®æ‰€æœ‰è€…ã‹ã‚‰é€ä¿¡ã•ã‚ŒãŸã‹å¦ã‹
ï¼½ã¯æ¤œè¨¼yã§ããªã„ã€‚
ã—ãŸãŒã£ã¦ã€
`~DNSè§£æ±º$ã«ã¤ã„ã¦ã®æƒ…å ±ã®ã¿åŒ…å«ã™ã‚‹ã‚ˆã†ï¼Œå ±å‘Šã‚’é™æ ¼ã™ã‚‹ã€‚
ã‚ˆã‚Šè©³ç´°ã¯ã€ï¼»
`Â§ ~privacyã®è€ƒæ…®ç‚¹ï¼ #privacy-considerations$,
`Â§ è¤‡æ•°ã®~IP~addressã‚’ä¼´ã†ç”Ÿæˆå…ƒï¼ #origins-with-multiple-ip-addresses$
ï¼½ã‚’è¦‹ã‚ˆã€‚
â—
Note

This step "downgrades" a NEL report if the IP addresses of the server and the policy don't match. This is a privacy protection, ensuring that NEL reports are only sent to the owner of the service that the report describes. If the IP addresses don't match, then the user agent can only verify that the NEL policy was sent by the owner of the origin's domain name; it cannot verify that the policy was sent by the owner of the server this domain name resolves to. We therefore downgrade the report to only contain information about DNS resolution. See 9. Privacy Considerations and 7.5 Origins with multiple IP addresses for more details.
</p>
	</li>
	<li>
~IFï¼»
%æ–½ç­– ã¯`éæ–°é®®$ã§ã‚ã‚‹
ï¼½
â‡’
`æ–½ç­–~cache$ã‹ã‚‰ %æ–½ç­– ã‚’å‰Šé™¤ã™ã‚‹
â—
If policy is stale, then delete policy from the policy cache.
</li>
	<li>
~RET ( %å ±å‘Š~æœ¬ä½“, %æ–½ç­– )
â—
Return report body and policy.
</li>
</ol>
</div>

		</section>
		<section id="deliver-a-network-report">
<h2 title="Deliver a network report">5.5. ~networkå ±å‘Šã‚’é€é”ã™ã‚‹</h2>

<div class="algo">
<p>
ã“ã®~algoã¯ã€
æ‰€ä¸ã®
( `Object^jt %å ±å‘Š~æœ¬ä½“, `~NELæ–½ç­–$ %æ–½ç­–, `~networkè¦è«‹$ %è¦è«‹ )
ã«å¯¾ã—ï¼Œå ±å‘Šã‚’é€é”~ç”¨ã«~queueã™ã‚‹
ï¼ˆé€šä¾‹çš„ã«ã€
%å ±å‘Š~æœ¬ä½“ ã¯ï¼»
`~network~errorå ±å‘Šã‚’ç”Ÿæˆã™ã‚‹$ ~algoã‹ã‚‰è¿”ã•ã‚ŒãŸï¼Œ
ã“ã‚Œã‚’~callã—ã¦ã„ã‚‹ä»•æ§˜ã«ã‚ˆã‚Šå¢—è£œã•ã‚ŒãŸã‚‚ã®
ï¼½ã§ã‚ã‚Šï¼Œ
%æ–½ç­– ã¯ï¼»
ãã®~algoã«ã¦ %è¦è«‹ ã«åˆè‡´ã—ãŸã‚‚ã®
ï¼½ã§ã‚ã‚‹ï¼‰ï¼š
â—
Given a ECMAScript object (report body, usually returned from Generate a network error report and then augmented by the calling specification) and its matching NEL policy (policy) and network request (request), this algorithm queues the report for delivery.
</p>
<ol>
	<li>
%~URL ~LET %è¦è«‹ ã®`~URL$rq
â—
Let url be request's URL.
</li>
	<li>
%~URL ã®`ç´ ç‰‡$url ~SET ~NULLã€ï¼Clearã€‘
â—
Clear url's fragment.
</li>
	<li>
~IFï¼»
%å ±å‘Š~æœ¬ä½“ ã® `phase^c ~prop ~IN { `dns^l, `connection^l }
ï¼½
â‡’ï¼ƒ
%~URL ã®`~path$url ~SET Â« Â»ã€ï¼Clearã€‘ï¼›
%~URL ã®`~query$url ~SET ~NULLã€ï¼Clearã€‘
â—
If report body's phase property is dns or connection:
â€¢ Clear url's path and query.
</li>
	<li>
%ç›´åˆ—åŒ–ã—ãŸ~URL ~LET `~URLã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %~URL )
â—
â†“</li>
	<li>
`~networkå ±å‘Šã‚’ç”Ÿæˆã™ã‚‹$( `network-error^l, %æ–½ç­– ã®`å ±å‘Šç”¨~group$nP, %å ±å‘Š~æœ¬ä½“, %ç›´åˆ—åŒ–ã—ãŸ~URL )
ã€æœ€å¾Œã®å¼•æ•°ã®å‹ãŒåˆè‡´ã—ã¦ã„ãªã„ã€‘
â—
Generate a network report given these parameters:
â—
type
â€¢ network-error
data
â€¢ report body
endpoint group
â€¢ policy's reporting group
url
â€¢ The result of running the URL serializer on url.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="predefined-network-error-types">
<h2 title="Predefined network error types">6. å®šç¾©æ¸ˆã¿~network~errorç¨®åˆ¥</h2>

<p>
`~network~error$ã®`ç¨®åˆ¥$nEã«ã¯ã€
å®šç¾©æ¸ˆã¿ãªã‚‚ã®ãŒã„ãã¤ã‹ã‚ã‚‹ã€‚
â—
There are several predefined network error types.
</p>

<p>
~UAã¯ã€
ä»¥ä¸‹ã®~listã‚’~custom`~network~error$`ç¨®åˆ¥$nEã§æ‹¡å¼µã—ã¦ã‚‚ãƒ¨ã‚¤
â€” ä¾‹ï¼šæ–°ãŸãª~protocolã«é©å¿œã™ã‚‹ãŸã‚ï¼æ—¢å­˜ã®ã‚‚ã®ã‚’ã‚ˆã‚Šè©³ç´°ã«è¨˜è¿°ã™ã‚‹ãŸã‚ãªã©ã€‚
ãã†ã™ã‚‹å ´åˆã€
~errorå ±å‘Šã®å˜ç´”ã‹ã¤ä¸€è²«ã—ãŸå‡¦ç†ã‚’æ‰‹åŠ©ã‘ã™ã‚‹ãŸã‚ã€
~UAã¯ï¼Œ`ç¨®åˆ¥$nEåã¯~dotã§åŒºåˆ‡ã‚‰ã‚Œã‚‹~pattern
ï¼ˆ <code>`[group]^v.`[optional-subgroup]^v.`[error-name]^v</code> ï¼‰
ã«å¾“ã†ã¹ãã§ã‚ã‚‹
â€” ä¾‹ãˆã°ï¼Œã€å ±å‘Šã®ã€‘åé›†å™¨ãŒä¾›ã™ã‚‹é›†ç´„ã¯ã€
~categoryã”ã¨ã«, ã‚ã‚‹ã„ã¯ ã„ãã¤ã‹ã®ä¸‹ä½groupã«~~åˆ†åˆ¥ã•ã‚Œã¦ã‚ˆã„ã€‚
â—
The user agent MAY extend this list with custom network error types â€” e.g. to accommodate new protocols, or more detailed error descriptions of existing ones. When doing so, the user agent SHOULD follow the dot-delimited pattern ([group].[optional-subgroup].[error-name]) for the type names to facilitate simple and consistent processing of the error reports â€” e.g. the collector may provide aggregation by category and/or one or multiple subgroups.
</p>

		<section id="dns-resolution-errors">
<h3 title="DNS resolution errors">6.1. ~DNSè§£æ±º~error</h3>

<p>
ã“ã®ç¯€ã«æŒ™ã’ã‚‹ã™ã¹ã¦ã®`~network~error$ã¯ã€
`~DNSè§£æ±º$ã®é–“ã«ç”Ÿã˜ã‚‹ã®ã§ï¼Œãã®`ç›¸$nEã¯ `dns^l ã«ãªã‚‹ã€‚
â—
All of the network errors in this section occur during DNS resolution, and therefore have a phase of dns.
</p>

<dl class="reportTypeGroup">
	<dt>`dns.unreachable^l</dt>
	<dd>
~DNS~serverã«åˆ°é”-ä¸èƒ½ã€‚
â—
DNS server is unreachable
</dd>

	<dt>`dns.name_not_resolved^l</dt>
	<dd>
~DNS~serverã¯å¿œç­”ã—ã¦ããŸãŒï¼Œ~addressã¯è§£æ±ºã§ããªã‹ã£ãŸã€‚
â—
DNS server responded but is unable to resolve the address
</dd>

	<dt>`dns.failed^l</dt>
	<dd>
ä¸Šã®å„é …ã«æŒ™ã’ãŸ~errorã«å› ã‚‹äº‹ç”±ã‚’é™¤ãï¼Œ
~DNS~serverã¸ã®è¦è«‹ã«éš›ã—ã¦ã®å¤±æ•—ã€‚
â—
Request to the DNS server failed due to reasons not covered by previous errors
</dd>

	<dt>`dns.address_changed^l</dt>
	<dd>
è¦è«‹ã®`ç”Ÿæˆå…ƒ$rqç”¨ã«è§£æ±ºã•ã‚ŒãŸ~IP~addressã¯ã€
å¯¾å¿œã™ã‚‹`~NELæ–½ç­–$ã‚’å—ä¿¡ã—ãŸã¨ãã‹ã‚‰å¤‰åŒ–ã—ãŸã“ã¨ã‚’
æŒ‡ç¤ºã™ã‚‹ã€‚
â—
Indicates that the resolved IP address for a request's origin has changed since the corresponding NEL policy was received
</dd>
</dl>

		</section>
		<section id="secure-connection-establishment-errors">
<h3 title="Secure connection establishment errors">6.2. ~secureæ¥ç¶š~ç¢ºç«‹ã®~error</h3>

<p>
ã“ã®ç¯€ã«æŒ™ã’ã‚‹ã™ã¹ã¦ã®`~network~error$ã¯ã€
`~secureæ¥ç¶šã®ç¢ºç«‹$ã®é–“ã«ç”Ÿã˜ã‚‹ã®ã§ï¼Œãã®`ç›¸$nEã¯ `connection^l ã«ãªã‚‹ã€‚
â—
All of the network errors in this section occur during secure connection establishment, and therefore have a phase of connection.
</p>

<dl class="reportTypeGroup">
	<dt>`tcp.timed_out^l</dt>
	<dd>
~serverã¸ã®~TCPæ¥ç¶šãŒæ™‚é–“åˆ‡ã‚Œã«ãªã£ãŸã€‚
â—
TCP connection to the server timed out
</dd>

	<dt>`tcp.closed^l</dt>
	<dd>
~TCPæ¥ç¶šãŒ~serverã«ã‚ˆã‚Š~closeã•ã‚ŒãŸã€‚
â—
The TCP connection was closed by the server
</dd>

	<dt>`tcp.reset^l</dt>
	<dd>
~TCPæ¥ç¶šãŒå†è¨­å®šã•ã‚ŒãŸã€‚
â—
The TCP connection was reset
</dd>

	<dt>`tcp.refused^l</dt>
	<dd>
~TCPæ¥ç¶šã¯
~serverã«ã‚ˆã‚Šæ‹’å¦ã•ã‚ŒãŸã€‚
â—
The TCP connection was refused by the server
</dd>

	<dt>`tcp.aborted^l</dt>
	<dd>
~TCPæ¥ç¶šã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The TCP connection was aborted
</dd>

	<dt>`tcp.address_invalid^l</dt>
	<dd>
ç„¡åŠ¹ãª~IP~addressã€‚
â—
The IP address is invalid
</dd>

	<dt>`tcp.address_unreachable^l</dt>
	<dd>
~IP~addressã«åˆ°é”-ä¸èƒ½ã€‚
â—
The IP address is unreachable
</dd>

	<dt>`tcp.failed^l</dt>
	<dd>
ä¸Šã®å„é …ã«æŒ™ã’ãŸ~errorã«ã‚ˆã‚‹ã‚‚ã®ä»¥å¤–ã®äº‹ç”±ã«å› ã‚Šï¼Œ
~TCPæ¥ç¶šã«å¤±æ•—ã—ãŸã€‚
â—
The TCP connection failed due to reasons not covered by previous errors
</dd>
</dl>

<dl class="reportTypeGroup">
	<dt>`tls.version_or_cipher_mismatch^l</dt>
	<dd>
~versionã¾ãŸã¯æš—å·ã®ä¸ä¸€è‡´ã«å› ã‚Šï¼Œ
~TLSæ¥ç¶šã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The TLS connection was aborted due to version or cipher mismatch
</dd>

	<dt>`tls.bad_client_auth_cert^l</dt>
	<dd>
ç„¡åŠ¹ãª~clientè¨¼æ˜æ›¸ã«å› ã‚Šï¼Œ
~TLSæ¥ç¶šã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The TLS connection was aborted due to invalid client certificate
</dd>

	<dt>`tls.cert.name_invalid^l</dt>
	<dd>
ç„¡åŠ¹ãªåå‰ã«å› ã‚Šï¼Œ
~TLSæ¥ç¶šã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The TLS connection was aborted due to invalid name
</dd>

	<dt>`tls.cert.date_invalid^l</dt>
	<dd>
ç„¡åŠ¹ãªè¨¼æ˜æ›¸~æ—¥ä»˜ã«å› ã‚Šï¼Œ
~TLSæ¥ç¶šã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The TLS connection was aborted due to invalid certificate date
</dd>

	<dt>`tls.cert.authority_invalid^l</dt>
	<dd>
ç„¡åŠ¹ãªç™ºè¡Œ~æ¨©é™ã«å› ã‚Šï¼Œ
~TLSæ¥ç¶šã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The TLS connection was aborted due to invalid issuing authority
</dd>

	<dt>`tls.cert.invalid^l</dt>
	<dd>
ç„¡åŠ¹ãªè¨¼æ˜æ›¸ã«å› ã‚Šï¼Œ
~TLSæ¥ç¶šã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The TLS connection was aborted due to invalid certificate
</dd>

	<dt>`tls.cert.revoked^l</dt>
	<dd>
å»ƒæ­¢ã•ã‚ŒãŸ~serverè¨¼æ˜æ›¸ã«å› ã‚Šï¼Œ
~TLSæ¥ç¶šã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The TLS connection was aborted due to revoked server certificate
</dd>

	<dt>`tls.cert.pinned_key_not_in_cert_chain^l</dt>
	<dd>
~key~pinning~errorã«å› ã‚Šï¼Œ
~TLSæ¥ç¶šã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The TLS connection was aborted due to a key pinning error
</dd>

	<dt>`tls.protocol.error^l</dt>
	<dd>
~TLS~protocol~errorã«å› ã‚Šï¼Œ
~TLSæ¥ç¶šã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The TLS connection was aborted due to a TLS protocol error
</dd>

	<dt>`tls.failed^l</dt>
	<dd>
ä¸Šã®å„é …ã«æŒ™ã’ãŸ~errorã«ã‚ˆã‚‹ã‚‚ã®ä»¥å¤–ã®äº‹ç”±ã«å› ã‚Šï¼Œ
~TLSæ¥ç¶šã«å¤±æ•—ã—ãŸã€‚
â—
The TLS connection failed due to reasons not covered by previous errors
</dd>
</dl>

		</section>
		<section id="transmission-of-request-and-response-errors">
<h3 title="Transmission of request and response errors">6.3. è¦è«‹ï¼å¿œç­” ~errorã®ä¼é€</h3>

<p>
ã“ã®ç¯€ã«æŒ™ã’ã‚‹ã™ã¹ã¦ã®`~network~error$ã¯ã€
`è¦è«‹ã¨å¿œç­”ã®ä¼é€$ã®é–“ã«ç”Ÿã˜ã‚‹ã®ã§ï¼Œãã®`ç›¸$nEã¯ `application^l ã«ãªã‚‹ã€‚
â—
All of the network errors in this section occur during the transmission of request and response, and therefore have a phase of application.
</p>

<dl class="reportTypeGroup">
	<dt>`http.error^l</dt>
	<dd>
~UAã¯å¿œç­”ã‚’æˆåŠŸè£¡ã«å—ä¿¡ã—ãŸãŒï¼Œãã®çŠ¶æ…‹s~codeã¯ï¼»
`4xx$st ï¼ `5xx$st
ï¼½ã§ã‚ã£ãŸã€‚
â—
The user agent successfully received a response, but it had a 4xx or 5xx status code
</dd>

	<dt>`http.protocol.error^l</dt>
	<dd>
~HTTP~protocol~errorã«å› ã‚Šï¼Œ
æ¥ç¶šã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The connection was aborted due to an HTTP protocol error
</dd>

	<dt>`http.response.invalid^l</dt>
	<dd>
å¿œç­”ã€ã®`å†…å®¹$ã€‘ãŒç©ºã§ã‚ã‚‹ ï¼
`Content-Length$h ã«ä¸ä¸€è‡´ãŒã‚ã‚‹ ï¼
ç¬¦å·åŒ–æ³•ã€`å†…å®¹~ç¬¦å·æ³•$ã€‘ãŒé©æ­£ã§ãªã„ ï¼
~UAãŒå¿œç­”ã‚’å‡¦ç†ã§ããªãã•ã›ã‚‹ã‚ˆã†ãªä»–ã®æ¡ä»¶ã€‚
â—
Response is empty, has a content-length mismatch, has improper encoding, and/or other conditions that prevent user agent from processing the response
</dd>

	<dt>`http.response.redirect_loop^l</dt>
	<dd>
~redirect~loopãŒæ¤œå‡ºã•ã‚ŒãŸã“ã¨ã«å› ã‚Šï¼Œ
è¦è«‹ã¯ä¸­æ­¢ã•ã‚ŒãŸã€‚
â—
The request was aborted due to a detected redirect loop
</dd>

	<dt>`http.failed^l</dt>
	<dd>
ä¸Šã®å„é …ã«æŒ™ã’ãŸ~HTTP~protocolã«ãŠã‘ã‚‹~errorã«å› ã‚‹ã‚‚ã®ä»¥å¤–ã®äº‹ç”±ã«å› ã‚Šï¼Œ
æ¥ç¶šã«å¤±æ•—ã—ãŸã€‚
â—
The connection failed due to errors in HTTP protocol not covered by previous errors
</dd>
</dl>

<dl class="reportTypeGroup">
	<dt>`abandoned^l</dt>
	<dd>
åˆ©ç”¨è€…ãŒï¼Œè³‡æº~fetchã‚’å®Œäº†ã™ã‚‹å‰ã«ä¸­æ­¢ã—ãŸã€‚
â—
User aborted the resource fetch before it is complete
</dd>

	<dt>`unknown^l</dt>
	<dd>
æœªçŸ¥ãª~errorç¨®åˆ¥ã€‚
â—
error type is unknown
</dd>
</dl>

		</section>
	</section>
	<section id="examples">
<h2 title="Examples">7. ä¾‹</h2>

		<section id="sample-policy-definitions">
<h3 title="Sample Policy Definitions">7.1. æ–½ç­–~å®šç¾©ã®è¦‹æœ¬</h3>

<p class="trans-note">ã€
ä»¥ä¸‹ã«ç¤ºã•ã‚Œã‚‹~codeå†…ã®è¡Œé ­ã«ç¾ã‚Œã‚‹ï¼»
"&gt;" ï¼ "&lt;"
ï¼½ã¯ã€ï¼»
è¦è«‹ï¼å¿œç­”
ï¼½ã®~dataã‚’è¡¨ã™
ï¼ˆãã‚Œã‚‰ã®æ–‡å­—~è‡ªä½“ã¯~dataã®ä¸€éƒ¨ã‚’æˆã•ãªã„ï¼‰ã€‚
ãã‚Œãã‚Œï¼Œä»¥é™ã«é€£ãªã‚‹ï¼»
"&gt;" ï¼ "&lt;"
ï¼½ãŒç„¡ã„è¡Œã¨ã¨ã‚‚ã« â€œå˜ç‹¬ã®è¡Œâ€ ã‚’æˆã™
ï¼ˆãã‚Œã‚‰ã®ä¸­ã®æ”¹è¡Œã¯ã€
è¦‹æ˜“ãã™ã‚‹ãŸã‚ã®æ•´å½¢ï¼‰ã€‚
ã€‘ã€
ä»¥ä¸‹ã«ç¾ã‚Œã‚‹
`Report-To@h
~headerã¯ï¼Œ `REPORTING$r ã«å®šç¾©ã•ã‚Œã¦ã„ãŸãŒã€
ãã®ä»•æ§˜ã®æ›´æ–°ã«ã‚ˆã‚Š
`Reporting-Endpoints$h ~headerã«å–ã£ã¦ä»£ã‚ã‚‰ã‚Œï¼Œãã®å€¤ã‚‚ç•°ãªã‚‹ã‚‚ã®ã‚’ã¨ã‚‹ã€‚
ã€‘</p>

<div class="example">
<pre class="lang-http">
&gt; GET / HTTP/1.1
&gt; Host: example.com

&lt; HTTP/1.1 200 OK
&lt; ...
&lt; `Report-To$h: {
    "group": "network-errors",
    "max_age": 2592000,
    "endpoints": [{"url": "https://example.com/upload-reports"}]
}
&lt; `NEL$h: {
    "report_to": "network-errors",
    "max_age": 2592000
}
</pre>

<p>
ã“ã® `NEL^h ~headerãŒå®šç¾©ã™ã‚‹`~NELæ–½ç­–$ã¯ã€ï¼»
`example.com^s ã«ã¤ã„ã¦ã®~network~errorã‚’ï¼Œåå‰ `network-errors^l ã®`å ±å‘Šå…ˆ~group$ã«å ±å‘Šã™ã‚‹
ï¼½ã‚ˆã†ï¼Œ~UAã«æŒ‡å›³ã™ã‚‹ã€‚
ã“ã®æ–½ç­–ã¯ 2592000 ç§’é–“ï¼ˆ 30 æ—¥é–“ï¼‰é©ç”¨ã•ã‚Œã‚‹ã€‚
â—
This NEL header defines a NEL policy, instructing the user agent to report network errors about example.com to the endpoint group named network-errors. The policy applies for 2592000 seconds (30 days).
</p>

<p>
ä¸Šã®ç™»éŒ²ã¯ã€
å½“ã®å¿œç­”ãŒ`ä¿¡ç”¨ã«ä¾¡ã—å¾—ã‚‹ç”Ÿæˆå…ƒ$ã‹ã‚‰é€šä¿¡ã•ã‚ŒãŸå ´åˆã«é™ã‚ŠæˆåŠŸã™ã‚‹ã“ã¨ã«æ³¨æ„ã€‚
â—
Note that above registration will only succeed if the response is communicated from a potentially trustworthy origin.
</p>
</div>

<div class="example">
<pre class="lang-http">
&gt; GET / HTTP/1.1
&gt; Host: example.com

&lt; HTTP/1.1 200 OK
&lt; ...
&lt; `NEL$h: {"max_age": 0}
</pre>

<p>
ã“ã® `NEL^h ~headerã¯ã€ï¼»
`example.com^s ç”¨ã®`~NELæ–½ç­–$ãŒå­˜åœ¨ã™ã‚‹ãªã‚‰ã°ï¼Œãã‚Œã‚’é™¤å»ã™ã‚‹
ï¼½ã‚ˆã†ï¼Œ~UAã«æŒ‡å›³ã™ã‚‹ã€‚
â—
This NEL header instructs the user agent to remove any existing NEL policy for example.com.
</p>
</div>

		</section>
		<section id="sample-network-error-reports">
<h3 title="Sample Network Error Reports">7.2. ~network~errorå ±å‘Šã®è¦‹æœ¬</h3>

<p>
ã“ã®ç¯€ã§ã¯ã€
~UAãŒï¼»
`~NELæ–½ç­–$ãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹`ç”Ÿæˆå…ƒ$ã«å¯¾ã—ï¼Œ~network~errorã«é­é‡ã—ãŸ
ï¼½ã¨ãã«~queueã—å¾—ã‚‹ï¼Œ`~network~error$`å ±å‘Š$ã®ä¾‹ã‚’ç¤ºã™ã€‚
ã“ã“ã§ã¯ã€
å ±å‘Šã‚’~uploadã™ã‚‹ã¨ã `REPORTING$r ~APIã«ã‚ˆã‚Šä½œæˆã•ã‚Œã‚‹å…¨éƒ¨çš„ãªå ±å‘Š~payloadã‚’ç¤ºã™ã€‚
~payloadã® `body^c ~fieldãŒ`~network~error$ã®`å ±å‘Š~æœ¬ä½“$ã‚’åŒ…å«ã™ã‚‹ã€‚
â—
This section contains example network error reports the user agent might queue when a network error is encountered for an origin with a registered NEL policy. We show the full report payload that would be created by the [REPORTING] API when uploading the report; the payload's body field contains the network error report body.
</p>

<p class="trans-note">ã€
ä»–ã®~fieldã«é–¢ã™ã‚‹è¨˜è¿°ã¯ã€
 `REPORTING$r ã®`å ±å‘Šå…ˆã¸å ±å‘Šã‚’é€é”ã™ã‚‹æ‰‹ç¶šãï¼ ~REPORTING#try-delivery$ã«ã‚ã‚‹ã€‚
ã€‘</p>

<div class="example">
<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://www.example.com/",
  "body": {
    "sampling_fraction": 0.5,
    "referrer": "http://example.com/",
    "server_ip": "2001:DB8:0:0:0:0:0:42",
    "protocol": "h2",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 200,
    "elapsed_time": 823,
    "phase": "application",
    "type": "http.protocol.error"
  }
}
</pre>

<div class="p">
<p>
ä¸Šã®å ±å‘Šã¯ã€
~UAãŒæ¬¡ã‚’è¡Œã£ãŸã“ã¨ã‚’æŒ‡ç¤ºã™ã‚‹ï¼š
</p>
<ol>
	<li>
`example.com^s
ã‹ã‚‰
`www.example.com^s
ã¸~navigateã™ã‚‹ã‚ˆã†è©¦ã¿ã¦ã€
</li>
	<li>
ãã®~IP~addressã¯
`2001:DB8::42^s
ã«æˆåŠŸè£¡ã«è§£æ±ºã•ã‚Œã€
</li>
	<li>
HTTP/2ï¼ˆ `h2^s ï¼‰~protocolã‚’ä»‹ã—ã¦~serverã‹ã‚‰ `200$st å¿œç­”ã‚’å—ä¿¡ã—ãŸãŒã€
</li>
	<li>
äº¤æ›ã«éš›ã—~protocol~errorã«é­é‡ã—ãŸãŸã‚ï¼ˆ `http.protocol.error^l ï¼‰ï¼Œ~naviã‚’æ”¾æ£„ã™ã‚‹ã‚ˆã†å¼·ã„ã‚‰ã‚ŒãŸã€‚
</li>
	<li>
~naviã‚’é–‹å§‹ã—ã¦ã‹ã‚‰ä¸­æ­¢ã™ã‚‹ã¾ã§ï¼Œ 823 ~milliç§’ çµŒéã—ã€
</li>
	<li>
æœ€å¾Œã«ï¼Œã“ã®å ±å‘Šã‚’~network~errorã«é­é‡ã—ãŸç›´å¾Œã«é€ä¿¡ã—ãŸ
â€” ã™ãªã‚ã¡ã€
å ±å‘Š~ageã¯ 0
</li>
</ol>

â—
This report indicates that the user agent attempted to navigate from example.com to www.example.com, which successfully resolved to 2001:DB8::42. However, while the user agent received a 200 response from the server via the HTTP/2 (h2) protocol, it encountered a protocol error in the exchange and was forced to abandon the navigation. The user agent aborted the navigation 823 milliseconds after it started. Finally, the user agent sent this report immediately after the network error was encountered â€“ i.e. the report age is 0.
</div>
</div>

<div class="example">
<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://widget.com/thing.js",
  "body": {
    "sampling_fraction": 1.0,
    "referrer": "https://www.example.com/",
    "server_ip": "",
    "protocol": "",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 0,
    "elapsed_time": 143,
    "phase": "dns",
    "type": "dns.name_not_resolved"
  }
}
</pre>

<div class="p">
<p>
ä¸Šã®å ±å‘Šã¯ã€
~UAãŒæ¬¡ã‚’è¡Œã£ãŸã“ã¨ã‚’æŒ‡ç¤ºã™ã‚‹ï¼š
</p>
<ol>
	<li>
`https://www.example.com/^s ã‹ã‚‰ `https://widget.com/thing.js^s ã‚’~fetchã™ã‚‹ã‚ˆã†è©¦ã¿ãŸãŒã€
</li>
	<li>
~DNSåï¼ˆ `widget.com^s ï¼‰ã‚’è§£æ±ºã§ããªã‹ã£ãŸãŸã‚ã€
 143 ~milliç§’å¾Œã«è¦è«‹ã‚’ä¸­æ­¢ã—ãŸã€‚
</li>
	<li>
`widget.com^s ã¸ã®ä»¥å‰ã®è¦è«‹ã¯ å¦¥å½“ãª`~NELæ–½ç­–$ã‚’é€é”ã—ãŸã®ã§ã€
ã“ã®è¦è«‹~ç”¨ã«`~network~error$`å ±å‘Š$ã‚’ç”Ÿæˆã—ãŸã€‚
</li>
	<li>
ãã®å ±å‘Šã¯`~network~error$ã«é­é‡ã—ãŸç›´å¾Œã«~uploadã•ã‚ŒãŸ
â€” ã™ãªã‚ã¡ã€
å ±å‘Š~ageã¯ 0
</li>
</ol>
â—
The above report indicates that the user agent attempted to fetch https://widget.com/thing.js from https://www.example.com/. However, the user agent was unable to resolve the DNS name (widget.com) and the request was aborted by the user agent after 143 milliseconds. Because a previous request to widget.com delivered a valid NEL policy, the user agent generates a network error report for this request. The report was uploaded immediately after the network error was encountered â€“ i.e. the report age is 0.
</div>
</div>

		</section>
		<section id="dns-misconfiguration">
<h3 title="DNS misconfiguration">7.3. ~DNSç’°å¢ƒè¨­å®šã®èª¤ã‚Š</h3>

<div class="example">
<pre class="lang-http">
&gt; GET / HTTP/1.1
&gt; Host: example.com

&lt; HTTP/1.1 200 OK
&lt; ...
&lt; `Report-To$h: {
    "group": "network-errors",
    "max_age": 2592000,
    "endpoints": [{"url": "https://example.com/upload-reports"}]
}
&lt; `NEL$h: {
    "report_to": "network-errors",
    "max_age": 2592000,
    "include_subdomains": true
}
</pre>

<p>
ã“ã® `NEL^h ~headerã¯ã€
~DNS~serverã®ç’°å¢ƒè¨­å®šã‚’èª¤ã£ãŸã¨ãï¼Œãã‚Œã‚’æ¤œå‡ºã™ã‚‹ã“ã¨ã‚’ `example.com^s ã®æ‰€æœ‰è€…ã«è¨±å®¹ã™ã‚‹
â€” ä¸€ä¾‹ã¨ã—ã¦,
`new-subdomain.example.com^s ã‚’~IP~addressã«è§£æ±ºã™ã‚‹ãŸã‚ã®æ–°ãŸãªè³‡æº~recordã‚’è¿½åŠ ã—å¿˜ã‚ŒãŸã¨ããªã©ã€‚
~UAã¯ã€
 `new-subdomain.example.com^s ã¸ã®è¦è«‹ã‚’ç‚ºã™ã‚ˆã†è©¦è¡Œã—ãŸå ´åˆï¼Œæ¬¡ã®ã‚ˆã†ãªå ±å‘Šã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã«ãªã‚ã†ï¼š
â—
This NEL header allows the owner of example.com to detect when they have misconfigured their DNS servers â€” for instance, when they have forgotten to add a new resource record resolving new-subdomain.example.com to an IP address. If a user agent tries to make a request to new-subdomain.example.com, it might generate the following report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://new-subdomain.example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 0,
    "elapsed_time": 48,
    "phase": "dns",
    "type": "dns.name_not_resolved"
  }
}
</pre>
</div>

		</section>

		<section id="monitoring-cache-validation">
<h3 title="Monitoring cache validation">7.4. ~cacheæ¤œè¨¼ã®ç›£è¦–-æ³•</h3>

<div class="example">
<pre class="lang-http">
&gt; GET / HTTP/1.1
&gt; Host: example.com

&lt; HTTP/1.1 200 OK
&lt; ...
&lt; Report-To: {"group": "network-errors", "max_age": 2592000,
              "endpoints": [{"url": "https://example.com/upload-reports"}]}
&lt; NEL: {"report_to": "network-errors", "max_age": 2592000, "success_fraction": 1.0,
        "request_headers": ["If-None-Match"], "response_headers": ["ETag"]}
&lt; ETag: 01234abcd
</pre>

<p>
ã“ã®ä¾‹ã§ã¯ã€
`example.com^s ã®æ‰€æœ‰è€…ã¯ï¼Œ
`ETag$h å¿œç­”~headerã‚’åˆ©ç”¨ã—ã¦~serverä¸Šã§~hostã•ã‚Œã‚‹è³‡æºã®å„~versionã‚’è­˜åˆ¥ã™ã‚‹ã€‚
~UAã¯ã€ï¼»
å¿œç­”ã‚’å—ä¿¡ã—ãŸæ™‚ç‚¹ã§ï¼Œãã®è³‡æºã®ã©ã®~versionãŒ~clientå´ã«~cacheã•ã‚Œã¦ã„ã‚‹ã‹
ï¼½ã‚’ï¼Œ `If-None-Match$h è¦è«‹~headerã‚’åˆ©ç”¨ã—ã¦~serverã«ä¼ãˆã‚Œã‚‹ã€‚
ãã‚Œã«ã‚ˆã‚Šï¼Œ~serverã¯ã€ï¼»
~clientã®æ—¢å­˜ã®è¤‡è£½ãŒæœ€æ–°ã®å ´åˆã«ã¯ã€
è³‡æºã®å†…å®¹ã‚’ç”Ÿæˆã—ã¦é€ä¿¡ã™ã‚‹ã®ã‚’é¿ã‘ã‚‹
ï¼½ã“ã¨ãŒå¯èƒ½ã«ãªã‚‹ã€‚
â—
In this example, the owner of example.com uses ETag response headers to identify different versions of the resources hosted on the server. User agents can then use If-None-Match request headers to inform the server which version of a resource is presently cached client-side, allowing the server to avoid generating and sending the content of the resource if the client's existing copy is up to date.
</p>

<p>
ã“ã®~domainç”¨ã®ï¼»
`request_headers$c, `response_headers$c
ï¼½~fieldã‚’ `NEL^h ~headerå†…ã«å«ã‚ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€
~browserã¯ï¼Œ~NELå ±å‘Š~å†…ã« `If-None-Match$h è¦è«‹~headerã®è¤‡è£½ã¨è‡ªèº«ãŒãã®è¦è«‹~ç”¨ã«ä½œæˆã™ã‚‹ `ETag$h å¿œç­”~headerã‚’å«ã‚ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
ãã‚Œã«ã‚ˆã‚Šï¼Œ~siteæ‰€æœ‰è€…ã¯ã€
è‡ªèº«ã«ã‚ˆã‚‹~cacheæ³•~æ–½ç­–ã®å®ŸåŠ¹æ€§ã‚’è¿½è·¡-å¯èƒ½ã«ãªã‚‹ã€‚
â—
By including request_headers and response_headers fields in the NEL header for this domain, the browser will include a copy of the If-None-Match request header and ETag response header in any NEL report that it creates for that request, allowing the site owner to track the effectiveness of their caching policies.
</p>

<p>
ä¸ŠãŒä¸ãˆã‚‰ã‚ŒãŸä¸‹ã§ã€
ä»¥ä¸‹ã®é †ã«ç”Ÿã˜ã‚‹å‡ºæ¥äº‹ã‚’è€ƒãˆã‚‹ï¼š
â—
Given the above, consider the following sequence of events:
</p>
<ol>
	<li>
<p>
~UAã¯ `example.com^s ã¸å‘ã‘ã¦`è¦è«‹$ã‚’é€ä¿¡ã—ã¦ï¼Œ`~server$ã‹ã‚‰`å¿œç­”$ã‚’æˆåŠŸè£¡ã«å—ä¿¡ã—ãŸã¨ã™ã‚‹
â€” ãã‚Œã¯ã€
å½“ã®è³‡æºã®~versionã‚’æŒ‡ç¤ºã—ã¦ã„ã‚‹ `ETag$h ~headerã‚’ä¼´ã†ã€‚
~UAã¯ã€
æ¬¡ã®~NELå ±å‘Šã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
The user agent sends a request to example.com, and receives a successful response from the server, with an ETag header indicating the version of the resource. The user agent will generate the following NEL report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.1",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {
      "ETag": ["01234abcd"]
    },
    "status_code": 200,
    "elapsed_time": 1392,
    "phase": "application",
    "type": "ok"
  }
}
</pre>

	</li>
	<li>
<p>
ã„ãã°ãã‹å¾Œï¼Œ~UAã¯ `example.com^s ã«å‘ã‘ã¦åˆ¥ã®`è¦è«‹$ã‚’é€ä¿¡ã™ã‚‹ã€‚
~UAã®å±€æ‰€~cacheå†…ã«ã¯ã€
å…ƒã®è³‡æºã®è¤‡è£½ãŒã¾ã åœ¨ã‚‹ã®ã§ï¼Œãã®~versionã‚’ `If-None-Match$h è¦è«‹~headerå†…ã«å«ã‚ã‚‹ã€‚
~serverã¯ã€
ã“ã®~versionã‚’æ¤œæŸ»ã—ã¦ï¼Œãã‚ŒãŒã¾ã åœ¨ã‚‹ã“ã¨ã«æ°—ä»˜ã„ãŸã®ã§ã€
`304$st å¿œç­”ã‚’é€ä¿¡ã—ã¦ï¼Œ~UAã«~cacheã•ã‚Œã¦ã„ã‚‹è³‡æºã®è¤‡è£½ã¯ä¾ç„¶ã¨ã—ã¦æœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ã‚’~UAã«ä¼ãˆã‚‹ã€‚
~UAã¯ã€
æ¬¡ã®å ±å‘Šã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
Some time later, the user agent sends another request to example.com. The user agent still has a copy of the original resource in its local cache, and includes its version in a If-None-Match request header. The server checks this version, notices that it is still current, and sends a 304 response informing the user agent that its cached copy of the resource is still valid. The user agent will generate the following report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.1",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {
      "If-None-Match": ["01234abcd"]
    },
    "response_headers": {
      "ETag": ["01234abcd"]
    },
    "status_code": 304,
    "elapsed_time": 45,
    "phase": "application",
    "type": "ok"
  }
}
</pre>

	</li>
	<li>

<p>
ã—ã°ã‚‰ãã—ã¦å¾Œã€
~UAã¯ `example.com^s ã«å‘ã‘ã¦ï¼Œã¾ãŸåˆ¥ã®`è¦è«‹$ã‚’é€ä¿¡ã™ã‚‹ã€‚
~UAã®å±€æ‰€~cacheå†…ã«ã¯åŒã˜è³‡æºã®è¤‡è£½ãŒã¾ã åœ¨ã‚Šã€
å‰ã®ä¾‹ã¨åŒã˜ã‚ˆã†ã«
`If-None-Match$h è¦è«‹~headerå†…ã« ãã®~versionã‚’å«ã‚ã‚‹ã€‚
ã—ã‹ã—ãªãŒã‚‰ä»Šå›ã¯ã€
~serverã¯ï¼Œè³‡æºã«æ–°ãŸãª~versionãŒå¯ç”¨ã§ã‚ã‚‹ã“ã¨ã«æ°—ä»˜ã„ãŸã®ã§ã€
ã“ã®è³‡æºã®å†…å®¹ã‚’ç”Ÿæˆã—ï¼Œæ–°ãŸãª~versionã‚’å¿œç­”ã® `ETag$h å¿œç­”~headerå€¤~å†…ã«ç¬¦å·åŒ–ã—ãŸä¸Šã§~clientã«é€ä¿¡ã™ã‚‹ã€‚
~UAã¯ã€
æ¬¡ã®å ±å‘Šã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
Even later, the user agent sends yet another request to example.com. The user agent still has the same copy of the resource in its local cache, and includes its version in a If-None-Match request header, as in the previous example. However, this time the server notices that there is a new version of the resource available. It generates the content of this resource, and sends it to the client, with the new version encoded in a new ETag response header value. The user agent will generate the following report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.1",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {
      "If-None-Match": ["01234abcd"]
    },
    "response_headers": {
      "ETag": ["56789ef01"]
    },
    "status_code": 200,
    "elapsed_time": 935,
    "phase": "application",
    "type": "ok"
  }
}
</pre>

	</li>
</ol>
</div>

		</section>
		<section id="origins-with-multiple-ip-addresses">
<h3 title="Origins with multiple IP addresses">7.5. è¤‡æ•°ã®~IP~addressã‚’ä¼´ã†ç”Ÿæˆå…ƒ</h3>

<p>
`ç”Ÿæˆå…ƒ$ã®`~domainå$ãŒè¤‡æ•°ã®~IP~addressã«è§£æ±ºã•ã‚Œã‚‹å ´åˆã€
~NELã¯ï¼Œ~errorå ±å‘Šã‚’ â€œé™æ ¼ã—ã¦â€ ï¼»
~errorã®åŸå› ã«ã¤ã„ã¦ä¾›ã™ã‚‹æƒ…å ±
ï¼½ã‚’æ¸›ã‚‰ã™ã“ã¨ã‚‚ã‚ã‚‹
â€” å½“ã®ç”Ÿæˆå…ƒã®æ‰€æœ‰è€…ãŒï¼»
å½“ã®`è¦è«‹$ã‚’å–æ‰±ã£ã¦ã„ã‚‹`~server$
ï¼½ã®æ‰€æœ‰è€…ã¨åŒã˜ã‹ã©ã†ã‹ã‚’æ¤œè¨¼yã§ããªã„ã®ã§ã€‚
â—
For origins whose domain name resolves to multiple IP addresses, NEL will sometimes "downgrade" an error report, providing less information about the cause of the error, since it cannot verify that the owner of the origin is the same as the owner of the server handling the request.
</p>

<div class="example">
<p>
ä¾‹ã¨ã—ã¦ã€
`example.com^s ã¯ï¼Œäº’ã„ã«~IP~addressãŒç•°ãªã‚‹ 3 ã¤ã®`~server$ã§å–æ‰±ã‚ã‚Œã¦ã„ã¦ã€
ãã®~serviceã®æ‰€æœ‰è€…ã¯
`example.com^s ã¯ï¼»
`192.0.2.1^s ï¼ `192.0.2.2^s ï¼ `192.0.2.3^s
ï¼½ã«è§£æ±ºã•ã‚Œã‚‹ã‚ˆã†~DNSã‚’ç’°å¢ƒè¨­å®šã—ã¦ã„ã¦ã€
å„~UAãŒ ãã‚Œã‚‰ã®è¦è«‹ã‚’ ã“ã‚Œã‚‰ã® 3 ã¤ã®~IP~addressã«åˆ†æ•£ã™ã‚‹ã“ã¨ã«ä¾æ‹ ã—ã¦ã„ã¦ã‚‹ã¨ã™ã‚‹ã€‚
~serviceã®æ‰€æœ‰è€…ã¯ã€
æ¬¡ã®`~NELæ–½ç­–$ã‚’é€é”ã™ã‚‹ã‚ˆã†ã«ã—ãŸã¨ã™ã‚‹ï¼š
â—
As an example, assume that example.com is handled by three servers, each with a different IP address. The owner of the service configures DNS to resolve example.com to 192.0.2.1, 192.0.2.2, and 192.0.2.3, and relies on user agents to balance their requests across these three IP addresses. The service owner delivers the following NEL policy:
</p>

<pre class="lang-http">
&gt; GET / HTTP/1.1
&gt; Host: example.com

&lt; HTTP/1.1 200 OK
&lt; ...
&lt; `Report-To$h: {
    "group": "network-errors",
    "max_age": 2592000,
    "endpoints": [{"url": "https://example.com/upload-reports"}]
}
&lt; `NEL$h: {
    "report_to": "network-errors",
    "max_age": 2592000,
    "success_fraction": 1.0,
    "failure_fraction": 1.0
}
</pre>

<p>
ä¸ŠãŒä¸ãˆã‚‰ã‚ŒãŸä¸‹ã§ã€
ä»¥ä¸‹ã®é †ã«ç”Ÿã˜ã‚‹å‡ºæ¥äº‹ã‚’è€ƒãˆã‚‹ï¼š
â—
Given the above, consider the following sequence of events:
</p>
<ol>
	<li>
<p>
~UAã¯ã€
`è¦è«‹$ã‚’ `192.0.2.1^s ã«å‘ã‘ã¦é€ä¿¡ã—ã¦ï¼Œ`~server$ã‹ã‚‰`å¿œç­”$ã‚’æˆåŠŸè£¡ã«å—ä¿¡ã—ãŸã€‚
ã“ã®å¿œç­”ã¯ï¼Œä¸Šã®`~NELæ–½ç­–$ã‚’å«ã‚€ã®ã§ã€
~UAã¯ï¼Œæ–½ç­–ã®`å—ä¿¡ã—ãŸ~IP~address$nPã‚’ `192.0.2.1^s ã«è¨­å®šã™ã‚‹ã€‚
`å—ä¿¡ã—ãŸ~IP~address$nPã¯`~server$ã®~IP~addressã«åˆè‡´ã™ã‚‹ã®ã§
ï¼ˆæˆåŠŸã—ãŸã©ã®è¦è«‹ã‚‚ï¼Œãã†ãªã‚‹ã¯ãšã§ã‚ã‚‹ï¼‰ã€
æ¬¡ã®~NELå ±å‘Šã‚’ç”Ÿæˆã™ã‚‹ï¼š
â—
The user agent sends a request to 192.0.2.1, and receives a successful response from the server. This response includes the above NEL policy, and the user agent sets the policy's received IP address to 192.0.2.1. Since the received IP address matches the server's IP address (which it must for any successful request), it generates the following NEL report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.1",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 200,
    "elapsed_time": 57,
    "phase": "application",
    "type": "ok"
  }
}
</pre>

	</li>
	<li>

<p>
~UAã¯ã€
æ–°ãŸãª`è¦è«‹$ã‚’ `192.0.2.2^s ã¸é€ä¿¡ã—ã¦ï¼Œåˆ¥ã®`å¿œç­”$ã‚’æˆåŠŸè£¡ã«å—ä¿¡ã—ãŸã€‚
ã“ã®å¿œç­”ã‚‚åŒã˜`~NELæ–½ç­–$ã‚’å«ã‚€ã€‚
~UAã¯ã€
æ–½ç­–ã®`å—ä¿¡ã—ãŸ~IP~address$nPã‚’ `192.0.2.2^s ã«æ›´æ–°ã™ã‚‹ã€‚
`å—ä¿¡ã—ãŸ~IP~address$nPã¯ï¼Œ`~server$ã®~IP~addressã«åˆè‡´ã™ã‚‹ã®ã§
ï¼ˆæˆåŠŸã—ãŸã©ã®è¦è«‹ã‚‚ï¼Œãã†ãªã‚‹ã¯ãšã§ã‚ã‚‹ï¼‰ã€
æ¬¡ã®~NELå ±å‘Šã‚’ç”Ÿæˆã™ã‚‹ï¼š
â—
The user agent sends a new request to 192.0.2.2, and receives another successful response. This response also includes the NEL policy, and the user agent updates the policy's received IP address to 192.0.2.2. Since the received IP address matches the server's IP address (which it must for any successful request), it generates the following NEL report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.2",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 200,
    "elapsed_time": 34,
    "phase": "application",
    "type": "ok"
  }
}
</pre>

	</li>
	<li>
<p>
~UAã¯ã€
`è¦è«‹$ã‚’ `192.0.2.3^s ã¸é€ä¿¡ã™ã‚‹ã‚ˆã†è©¦è¡Œã—ãŸãŒï¼Œ~serverã¸ã®æ¥ç¶šã¯ç¢ºç«‹ã§ããªã‹ã£ãŸã€‚
~UAã®`æ–½ç­–~cache$å†…ã«ã¯ï¼Œä¾ç„¶ã¨ã—ã¦`~NELæ–½ç­–$ãŒã‚ã‚‹ã®ã§ã€
ã“ã®æ–½ç­–ã‚’åˆ©ç”¨ã—ã¦ï¼Œ`å¤±æ•—ã—ãŸ$`~networkè¦è«‹$ã«ã¤ã„ã¦ã®å ±å‘Šã‚’
â€” ãã®`ç¨®åˆ¥$nEã‚’ `tcp.timed_out^l ã«ã—ã¦ â€”
ç”Ÿæˆã—ãŸã„æ‰€ã ãŒâ€¦
å½“ã®æ–½ç­–ã®`å—ä¿¡ã—ãŸ~IP~address$nPï¼ˆ `192.0.2.2^s ï¼‰ã¯ï¼Œã“ã®`è¦è«‹$ã‚’é€ä¿¡-å…ƒ~ã®~IP~addressã«åˆè‡´ã—ãªã„ãŸã‚ï¼Œ `192.0.2.3^s ã«ã‚ã‚‹~serverãŒå®Ÿéš›ã« `example.com^s ã®æ‰€æœ‰è€…ãŒæ‰€æœ‰ã—ã¦ã„ã‚‹ã‹æ¤œè¨¼yã§ããªã„ã€‚
ã—ãŸãŒã£ã¦ï¼Œ~UAã¯ã€
å ±å‘Šã‚’ `dns.address_changed^l ã«é™æ ¼ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
The user agent then tries to send a request to 192.0.2.3, but isn't able to establish a connection to the server. The user agent still has the NEL policy in the policy cache, and would ideally use this policy to generate a tcp.timed_out report about the failed network request. However, the because policy's received IP address (192.0.2.2) doesn't match the IP address that this request was sent to, the user agent cannot verify that the server at 192.0.2.3 is actually owned by the owners of example.com. The user agent must therefore downgrade the report to dns.address_changed:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.3",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 0,
    "elapsed_time": 0,
    "phase": "dns",
    "type": "dns.address_changed"
  }
}
</pre>

	</li>
	<li>
<p>
~UAã¯ã€
åˆ¥ã®`è¦è«‹$ã‚’ `192.0.2.1^s ã¸é€ä¿¡ã™ã‚‹ã‚ˆã†è©¦è¡Œã—ãŸãŒï¼Œ
ã¾ãŸã‚‚ã‚„~serverã¸ã®æ¥ç¶šã¯ç¢ºç«‹ã§ããªã‹ã£ãŸã€‚
~UAã¯éå»ã®ã‚ã‚‹æ™‚ç‚¹ã§ `192.0.2.1^s ã‹ã‚‰`~NELæ–½ç­–$ã‚’å—ä¿¡ã—ã¦ã„ãŸã¨ã—ã¦ã‚‚ã€
æ–½ç­–ã®`å—ä¿¡ã—ãŸ~IP~address$nPã«ã¯ï¼Œãã“
ã€ã™ãªã‚ã¡ `https://example.com^s ï¼ˆã‹ã‚‰å°å‡ºã•ã‚Œã‚‹ç”Ÿæˆå…ƒï¼‰ã€‘
ã‹ã‚‰`æœ€ã‚‚è¿‘éå»^emã«å—ä¿¡ã—ãŸãã‚Œ
â€” ã“ã®äº‹ä¾‹ã§ã¯ `192.0.2.2^s â€”
ã—ã‹è¨˜éŒ²ã•ã‚Œãªã„ã€‚
ã—ãŸãŒã£ã¦ï¼Œ~UAã¯ã€
å ±å‘Šã‚’ `dns.address_changed^l ã«é™æ ¼ã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
The user agent then tries to send another request to 192.0.2.1, but once again isn't able to establish a connection to the server. Even though the user agent received the NEL policy from 192.0.2.1 at some point in the past, the policy's received IP address only records where it was most recently received from â€” in this case, 192.0.2.2. The user agent must therefore downgrade the report to dns.address_changed:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.1",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 0,
    "elapsed_time": 0,
    "phase": "dns",
    "type": "dns.address_changed"
  }
}
</pre>
	</li>
</ol>
</div>

		</section>
	</section>
	<section id="use-cases">
<h2 title="Use cases">8. åˆ©ç”¨äº‹ä¾‹</h2>

		<section id="reporting-of-navigation-failures">
<h4 title="Reporting of Navigation Failures">8.1. ~naviå¤±æ•—~æ™‚ã®å ±å‘Š-æ³•</h4>

<p>
åˆ©ç”¨è€…ã«ã‚ˆã‚Šèµ·å‹•ã•ã‚Œã‚‹~naviè¦è«‹
ï¼ˆä¾‹ï¼š
~linkã®~clickï¼
~URL~barã‚’ä»‹ã—ãŸç›´ãªå…¥åŠ›ï¼
åˆ©ç”¨è€…-ãƒ¤ãƒªãƒˆãƒªã«å› ã‚Š~scriptã‹ã‚‰èµ·å‹•ã•ã‚ŒãŸã‚‚ã®ï¼
ç­‰ã€…ï¼‰
ã¯ã€
ã„ãã¤ã‚‚ã®æ¥ç¶šæ€§ã®äº‹ç”±ã«å› ã‚Šå¤±æ•—ã—å¾—ã‚‹
â€” ~DNSã«ãŠã‘ã‚‹å¤±æ•—, ~TCP~error, ~TLS~protocolé•å, ç­‰ã€…ã€‚
ã“ã‚Œã‚‰ã®~errorã¯ã€ï¼»
~networkç’°å¢ƒè¨­å®šã®èª¤ã‚Š,
ä¸€éæ€§ãª~routingã®å•é¡Œi,
~serverã®~downtime,
~malware,
åˆ©ç”¨è€…ã«å¯¾ã™ã‚‹ä»–ã®æ”»æ’ƒ,
ç­‰ã€…
ï¼½ã«ã‚ˆã‚Š~~ç”Ÿã˜å¾—ã‚‹ã€‚
â—
A navigation request initiated by the user (e.g. via a click on a link, direct input via the location bar, script-initiated due to user interaction, etc.) may fail due any number of connectivity reasons: DNS failure, TCP error, TLS protocol violation, and so on. These errors may be caused by network misconfiguration, transient routing issues, server downtime, malware or other attacks against the user, etc.
</p>

<p>
ãã®ã‚ˆã†ãªäº‹ä¾‹ã§ã¯ã€
è¡Œå…ˆã®~hostã¯ï¼Œå¤±æ•—ã—ãŸ~naviã«æ°—ä»˜ã‹ãªã„ã¾ã¾ã«ãªã‚‹ã“ã¨ãŒå¤šã„
â€” å®šç¾©ã«ã‚ˆã‚Šã€
è¦è«‹ãŒ~hostã®åŸºç›¤ã¾ã§åˆ°é”ã—ãŸã‹ã©ã†ã‹ã‚’è¦‹ã‚Œãšï¼Œå•é¡Œã‚’ç©¶æ˜ã§ããªã„ã®ã§ã€‚
ã“ã‚Œã«å–çµ„ã‚€ãŸã‚ã€
~hostã¯ï¼Œï¼»
ãã®ã‚ˆã†ãªç©¶æ˜ã§ããªã„å¤±æ•—~å ±å‘Šã‚’ ã©ã“ã¸é€é”ã™ã‚‹ã¹ãã‹ã‚’æŒ‡å®šã™ã‚‹ï¼Œ`~NELæ–½ç­–$
ï¼½ã‚’~UAã«ç™»éŒ²ã§ãã‚‹ã€‚
â—
In such cases the destination host is often left unaware of the failed navigation since, by definition, it cannot see the request reach its infrastructure and it is unable to investigate the problem. To address this, the host can register an NEL policy with the user agent, which specifies where reports of such failures should be delivered such that they can be investigated.
</p>

		</section>
		<section id="reporting-of-first-party-subresource-fetch-failures">
<h3 title="Reporting of First-party Subresource Fetch Failures">8.2. å½“äº‹è€…-ä¸»ä½“ã«å±ã™ã‚‹ä¸‹ä½è³‡æºã«å¯¾ã™ã‚‹~fetchå¤±æ•—~æ™‚ã®å ±å‘Š-æ³•</h3>

<p>
å…¸å‹çš„ãª~appã¯ã€
æ•°å¤šãã®è³‡æºã‚’è¦æ±‚ã™ã‚‹ã€‚
ãã®~fetchingã¯ã€
æ¦‚ã—ã¦ï¼»
HTMLï¼CSSï¼JavaScript
ï¼½ã‚’ä»‹ã—ã¦èµ·å‹•ã•ã‚Œã‚‹ã€‚
ãã®ã‚ˆã†ãªè³‡æºã‚’è¦è«‹ã—ã¦ã„ã‚‹~appã¯ã€
å¤§æ¦‚ã¯ï¼Œãã®~fetchã®å¤±æ•—ã‚’è¦³æ¸¬ã§ãã‚‹ãŒ
ï¼ˆä¾‹ï¼š `onerror^c ~callbackã‚’ä»‹ã—ã¦ï¼‰ã€
å¤±æ•—ãŒãªãœç”Ÿã˜ãŸã‹ã«ã¤ã„ã¦ã®ï¼Œè©³ç´°ãª~network~errorå ±å‘Š
â€” ä¾‹ï¼š ~DNSå¤±æ•—, ~TCP~error, ~TLS~protocolé•å, ç­‰ã€… â€”
ã«ã¯~accessã§ããªã„ã€‚
â—
A typical application requires dozens of resources, the fetching of which is typically initiated via HTML, CSS, or JavaScript. The application requesting such resources can observe failures of most such fetches (e.g. via onerror callbacks), but it does not have access to the detailed network error report of why the failure has occurred - e.g. DNS failure, TCP error, TLS protocol violation, etc.
</p>

<p>
ã“ã‚Œã«å–çµ„ã‚€ãŸã‚ã€
~appã¯ï¼Œï¼»
~fetchä¸­ã«ã‚ã‚‹ä¸‹ä½è³‡æºãŒå±ã™ã‚‹å½“äº‹è€…-ä¸»ä½“~hostç”¨ã®ï¼Œé–¢é€£ãª`~NELæ–½ç­–$
ï¼½ã‚’~UAã«ç™»éŒ²ã§ãã‚‹ã€‚
ãã®ã‚ˆã†ãª`~NELæ–½ç­–$ãŒåœ¨ã‚‹ä¸‹ã§ã¯ã€
ãã‚ŒãŒç™»éŒ²ã•ã‚ŒãŸ`ç”Ÿæˆå…ƒ$ã‹ã‚‰ã®è³‡æºã«å¯¾ã—~network~errorã«é­é‡ã—ãŸå ´åˆï¼Œ~UAã¯è©³ç´°ãª~network~errorå ±å‘Šã‚’å ±å‘Šã™ã‚‹ã“ã¨ã‚’å¯èƒ½åŒ–ã™ã‚‹ã“ã¨ã«ãªã‚Šã€
~appé–‹ç™ºè€…ã¯ï¼Œ~errorã«ã¤ã„ã¦ç©¶æ˜ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
To address this, the application can register relevant NEL policies with the user agent for the first-party hosts from which the subresources are being fetched. Then, if such a policy is present and a network error is encountered for a resource from an origin with a registered NEL policy, the user agent will report the detailed network error report and enable the application developers to investigate the error.
</p>

		</section>
		<section id="reporting-of-third-party-subresource-fetch-failures">
<h3 title="Reporting of Third-party Subresource Fetch Failures">8.3. ç¬¬ä¸‰è€…-ä¸»ä½“ã«å±ã™ã‚‹ä¸‹ä½è³‡æºã«å¯¾ã™ã‚‹~fetchå¤±æ•—~æ™‚ã®å ±å‘Š-æ³•</h3>

<p>
è³‡æºãŒç¬¬ä¸‰è€…-ä¸»ä½“ã«ã‚ˆã‚ŠåŸ‹è¾¼ã¾ã‚Œã¦ã„ã‚‹äº‹ä¾‹ã§ã¯ã€
è³‡æºã‚’ä¾›ã™ã‚‹å´ã¯ã€
å¤±æ•—ã‚’ï¼»
è¨ˆæ¸¬ã§ããªã„ï¼è¦³æ¸¬ã§ããªã„
ï¼½ã“ã¨ãŒå¤šã„ã€‚
`example.com^s ãŒ è‡ªèº«ã®~siteã«è³‡æº
`widget.com/thing.js^s ã‚’åŸ‹è¾¼ã‚“ã§ã„ã¦ï¼Œ
`example.com^s
ã‚’è¨ªå•ã—ã¦ã„ã‚‹åˆ©ç”¨è€…ãŒï¼Œ~network~errorã«å› ã‚Šãã®ã‚ˆã†ãªè³‡æºã®~fetchã«å¤±æ•—ã—ãŸå ´åˆã€
~host
`widget.com^s
ã¯ã€
å¤±æ•—ã«æ°—ä»˜ãã“ã¨ã‚‚ï¼Œãã‚Œã‚’æ¤œå‡ºã™ã‚‹ã“ã¨ã‚‚ã§ããªã„ã€‚
â—
In the case where a resource is embedded by a third party, the provider of the resource is often unable to instrument and observe the failure. For example, if example.com embeds a widget.com/thing.js resource on its site, and the user visiting example.com fails to fetch such resource due to a network error, the `widget.com` host is both unaware of the failure and unable to detect it.
</p>

<p>
`widget.com^s ã¯ã€
ã“ã‚Œã«å–çµ„ã‚€ãŸã‚ï¼Œè‡ªèº«ã®~hostç”¨ã«`~NELæ–½ç­–$ã‚’ç™»éŒ²ã§ãã‚‹ã€‚
ãã®ã‚ˆã†ãªæ–½ç­–ãŒåœ¨ã‚‹ä¸‹ã§ï¼Œãã‚ŒãŒç™»éŒ²ã•ã‚ŒãŸ`ç”Ÿæˆå…ƒ$ã‹ã‚‰è³‡æºã‚’~fetchã™ã‚‹éš›ã«~network~errorã«é­é‡ã—ãŸå ´åˆ
â€” å½“äº‹è€…-ä¸»ä½“, ç¬¬ä¸‰è€…-ä¸»ä½“ã©ã¡ã‚‰ã®ç”Ÿæˆå…ƒã‹ã‚‰è¦è«‹ã•ã‚ŒãŸã‹ã‚’å•ã‚ãš â€”
~UAã¯~network~errorã‚’å ±å‘Šã™ã‚‹ã“ã¨ã«ãªã‚Šï¼Œè³‡æºã‚’ä¾›ã™ã‚‹å´ã¯~errorã‚’ç©¶æ˜-å¯èƒ½ã«ãªã‚‹ã€‚
â—
To address this, widget.com can register an NEL policy for its host. Then, if such policy is present and a network error is encountered while fetching a resource â€” regardless of whether it is being requested from a first-party or third-party origin â€” from the origin with a registered NEL policy, the user agent will report the network error and enable the provider to investigate the error.
</p>

		</section>
	</section>
	<section id="privacy-considerations">
<h2 title="Privacy Considerations">9. ~privacyã®è€ƒæ…®ç‚¹</h2>

<p>
~NELã¯ã€ï¼»
åˆ©ç”¨è€…ã®~networkç’°å¢ƒè¨­å®šã«ã¤ã„ã¦ã®æ–°ãŸãªæƒ…å ±
ï¼½ã‚‚å…¬é–‹ã—å¾—ã‚‹ã‚ˆã†ãªï¼Œ~network~errorå ±å‘Šã‚’ä¾›ã™ã‚‹ã€‚
ä¾‹ãˆã°ï¼Œæ”»æ’ƒè€…ã¯ã€ï¼»
åˆ©ç”¨è€…ã®~networkç’°å¢ƒè¨­å®šã‚’æ¢æŸ»ã—ãŸã‚Šï¼Œåˆ©ç”¨è€…ã®å†…éƒ¨~networkä¸Šã®~serverã‚’~scanã™ã‚‹
ï¼½ãŸã‚ã«~NELå ±å‘Š-æ³•ã‚’æ¿«ç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
ã¾ãŸï¼Œï¼»
HSTS, HPKP, ~pinned CSP æ–½ç­–
ï¼½ã¨é¡ä¼¼ã«ã€
æ ¼ç´ã•ã‚Œã‚‹`~NELæ–½ç­–$ã¯ï¼Œï¼»
ï¼ˆåˆ©ç”¨è€…ã”ã¨ã«ç•°ãªã‚‹ï¼‰~customãªå ±å‘Š~å…ˆ~URLã‚’ä¼´ã†ï¼Œåˆ¥å€‹ãªæ–½ç­–ã‚’è¨­å®šã™ã‚‹
ï¼½ã“ã¨ã«ã‚ˆã‚Šï¼»
~HTTP~cookieã¨ã®çµ„åˆnã§ï¼ˆã¾ãŸã¯ ãã‚Œã«ä»£ã‚ã‚‹ï¼‰ï¼Œè­˜åˆ¥å­ã¨ã—ã¦å‹•ä½œã™ã‚‹ã‚ˆã†ãª â€œ`supercookie^enâ€
ï¼½ã«ã‚‚åˆ©ç”¨ã§ãã‚‹ã€‚
â—
NEL provides network error reports that could expose new information about the user's network configuration. For example, an attacker could abuse NEL reporting to probe the user's network configuration, or to scan for servers on the user's internal network. Also, similar to HSTS, HPKP, and pinned CSP policies, the stored NEL policy could be used as a "supercookie" by setting a distinct policy with a custom (per-user) reporting URI to act as an identifier in combination with (or instead of) HTTP cookies.
</p>

<p>
ä¸Šè¿°ã®~riskã®ä¸€éƒ¨ã‚’è»½æ¸›ã™ã‚‹ãŸã‚ã€
~NELç™»éŒ²ã¯ï¼Œ`ä¿¡ç”¨ã«ä¾¡ã—å¾—ã‚‹ç”Ÿæˆå…ƒ$ã«åˆ¶ç´„ã•ã‚Œã€
~network~errorå ±å‘Šã®é€é”ã‚‚ï¼ŒåŒæ§˜ã«`ä¿¡ç”¨ã«ä¾¡ã—å¾—ã‚‹ç”Ÿæˆå…ƒ$ã«åˆ¶ç´„ã•ã‚Œã‚‹ã€‚
ã“ã‚Œã¯ã€
~NELã‚’æŒç¶šçš„ãªè¿½è·¡å™¨ã¨ã—ã¦è‡ªæ˜ã«æ¿«ç”¨ã™ã‚‹ã‚ˆã†ãªï¼Œ
ä¸€éæ€§ãª~HTTP~MITMâ€ ã‚’è¨±å®¹ã—ãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚
â—
To mitigate some of the above risks, NEL registration is restricted to potentially trustworthy origins, and delivery of network error reports is similarly restricted to potentially trustworthy origins. This disallows a transient HTTP MITM from trivially abusing NEL as a persistent tracker.
</p>

<p class="trans-note">ã€â€ 
MIIMï¼ˆ `Man In The Middle^en, ä¸­é–“è€…ï¼‰
â€” çµŒè·¯ä¸Šã®æ”»æ’ƒè€…ï¼ˆ `on-path attacker^en ï¼‰
ã€‘</p>

<p>
åŠ ãˆã¦ï¼Œ~NEL`æ–½ç­–~cache$ã¯ã€
`~networkåŒºåˆ†~key$ã‚’åˆ©ç”¨ã—ã¦åŒºåˆ†ã•ã‚Œã‚‹
â€” ä½•ã‹ã‚’åŸ‹è¾¼ã‚“ã§ã„ã‚‹æ–‡è„ˆ~å†…ã§ï¼Œã‚ã‚‹~siteç”¨ã«æ ¼ç´ã•ã‚ŒãŸ`~NELæ–½ç­–$ãŒã€
ç•°ãªã‚‹æ–‡è„ˆ~å†…ã§ã¯åˆ©ç”¨ã•ã‚Œãªã„ã‚ˆã†
ï¼ˆä¸€ä¾‹ã¨ã—ã¦ï¼Œç•°ãªã‚‹~top-level~siteã«ã‚ˆã‚ŠåŸ‹è¾¼ã¾ã‚ŒãŸã¨ãï¼‰ã€‚
â—
Additionally, the NEL policy cache is partitioned using the network partition key, so that a NEL policy stored for a site in one embedding context will not be used in a different context (for instance, when embedded by a different top-level site.)
</p>

<p>
~NELã¯ã€
æ—¢å­˜ã®~serverå´~ç›£è¦–ã‚’å¢—è£œã™ã‚‹ã“ã¨ãŒæ„å›³ã•ã‚Œã¦ã„ã‚‹ã€‚
~NELå ±å‘Šã®é€ä¿¡-å…ˆã¯ã€
è¦è«‹ã•ã‚Œã¦ã„ã‚‹~serviceã®æ‰€æœ‰è€…ã«é™ã‚‰ã‚Œã‚‹ã¹ãã§ã‚ã‚‹ã€‚
`~DNSè§£æ±º$ã®é–“ã«ç”Ÿã˜ãŸ~errorã«å¯¾ã—ã¦ã¯ã€
~NELå ±å‘Šã¯ï¼»
å½“ã®`~NELæ–½ç­–$ãŒï¼»
ãã®`ç”Ÿæˆå…ƒ$nPã‚’åŒ…å«ã™ã‚‹`~domainåå‰ç©ºé–“~tree$
ï¼½ã®æ‰€æœ‰è€…ã‹ã‚‰å—ä¿¡ã•ã‚ŒãŸã¨ã
ï¼½ã«é™ã‚Šç”Ÿæˆã•ã‚Œã‚‹ã€‚
ï¼»
`~secureæ¥ç¶šã®ç¢ºç«‹$ï¼`è¦è«‹ã¨å¿œç­”ã®ä¼é€$
ï¼½ã®é–“ã«ç”Ÿã˜ãŸ~errorã«å¯¾ã—ã¦ã¯ã€
~NELå ±å‘Šã¯ï¼»
`è¦è«‹$ã‚’é€ä¿¡ã—ãŸå…ˆã®`~server$ã®æ‰€æœ‰è€…ã‹ã‚‰`~NELæ–½ç­–$ãŒå—ä¿¡ã•ã‚ŒãŸã¨ã
ï¼½ã«é™ã‚Šç”Ÿæˆã•ã‚Œã‚‹ã€‚
â—
NEL is intended to augment existing server-side monitoring. NEL reports should only be sent to the owner of the service being requested. For errors that occur during DNS resolution, NEL reports are only generated when the NEL policy was received from the owner of the domain namespace tree that contains the policy origin. For errors that occur during secure connection establishment or transmission of request and response, NEL reports are only generated when the NEL policy was received from the owner of the server that the request was sent to.
</p>

<p>
ä»¥ä¸‹ã§ã¯ã€
`~NELæ–½ç­–$ã®ï¼»
`å—ä¿¡ã—ãŸ~IP~address$nPï¼`ä¸‹ä½domainã‚’å«ã‚€ã‹$nP
ï¼½ã®æ‰±ã„ã‚’èª¬æ˜ã™ã‚‹ã€‚
~NELã¯ã€ï¼»
æ–½ç­–ã®`å—ä¿¡ã—ãŸ~IP~address$nPãŒ`~server$ã®~IP~addressã«åˆè‡´ã™ã‚‹ã‹å¦ã‹æ¤œæŸ»ã™ã‚‹
ï¼½ã“ã¨ã«ã‚ˆã‚Šï¼Œ
æ–½ç­–ã®ä¿¡ç”¨-å¢ƒç•Œã‚’ï¼»
æ–½ç­–ã®`ç”Ÿæˆå…ƒ$nPã®ã¿ãªã‚‰ãšï¼Œ~UAãŒé€šä¿¡ã—ã¦ã„ã‚‹ç‰¹å®šã®~serverã‚‚å«ã‚€
ï¼½ã‚ˆã†æ‹¡å¼µã™ã‚‹ã€‚
ã“ã®æ¤œæŸ»ã¯ã€
ï¼ˆä¸€ä¾‹ã¨ã—ã¦ï¼‰
`DNS rebinding^enã€ ~domainåã‚’åˆ¥ã®~IP~addressã« â€œæŸç¸›ã—ç›´ã™â€ ã€‘æ”»æ’ƒã‚’é˜²æ­¢ã™ã‚‹ãŸã‚ã«ã‚ã‚‹ï¼š
ãã“ã§ã¯ï¼Œæ”»æ’ƒè€…ã¯ã€
è‡ªèº«ãŒæ‰€æœ‰ã™ã‚‹~serverã‹ã‚‰ï¼»
é•·ç”Ÿãã™ã‚‹`~NELæ–½ç­–$
ï¼½ã‚’é€é”ã—ãŸä¸Šã§ï¼Œè‡ªèº«ã®åå‰~serverï¼ˆ `name server^en ï¼‰ã‚’ï¼»
å½“ã®æ–½ç­–ã®`ç”Ÿæˆå…ƒ$nPãŒï¼»
è‡ªèº«ãŒåˆ¶å¾¡ã—ãªã„åˆ¥ã®~server
ï¼½ã«è§£æ±ºã•ã‚Œã‚‹
ï¼½ã‚ˆã†å¤‰æ›´ã™ã‚‹ã€‚
`å—ä¿¡ã—ãŸ~IP~address$nPã‚’æ¤œè¨¼yã—ãªã‹ã£ãŸå ´åˆã€
~UAã¯ï¼Œåˆ¥ã®~serverã«ã¤ã„ã¦ã®å ±å‘Šã‚’æ”»æ’ƒè€…ã¸é€ä¿¡ã•ã›ã‚‰ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
This rationale explains the treatment of the received IP address and subdomains flag of a NEL policy. By checking that the policy's received IP address matches the IP address of the server, NEL extends the trust boundary of the policy to include not just the policy's origin, but also the specific server that the user agent is communicating with. This helps prevent (for instance) DNS rebinding attacks, where an attacker delivers a long-lived NEL policy from a server that they own, and then changes their name servers to resolve the policy origin to a server they don't control. Without the received IP address verification, this would cause user agents to send reports about the second server to the attacker.
</p>

<p>
åŒæ§˜ã«ï¼Œ`ä¸‹ä½domainã‚’å«ã‚“ã§ï¼ #dfn-subdomains$ã„ã‚‹`~NELæ–½ç­–$ã¯ã€ï¼»
`è¦è«‹$ã®`~DNSè§£æ±º$ã®é–“ã«ï¼Œæ–½ç­–ã®`ç”Ÿæˆå…ƒ$nPã®ä¸‹ä½domainã«ã¤ã„ã¦ã®å ±å‘Šã‚’ç”Ÿæˆã™ã‚‹ã¨ã
ï¼½ã«é™ã‚Šåˆ©ç”¨ã§ãã‚‹ã‚ˆã†åˆ¶é™ã•ã‚Œã‚‹ã€‚
ã“ã®`ç›¸$ã®é–“ã¯ã€
~errorã®æ‰€æœ‰è€…ãŒèª°ãªã®ã‹æ¤œè¨¼yã™ã‚‹ãŸã‚ã®`è¦è«‹$ã¯ç„¡ã„
â€” ãã‚Œã‚’ç¢ºç«‹ã™ã‚‹ã«ã¯ï¼»
å½“ã®æ–½ç­–ãŒ`è¦è«‹$ã®`ç”Ÿæˆå…ƒ$rqã®ä¸Šä½domainã‹ã‚‰å—ä¿¡ã•ã‚ŒãŸäº‹å®Ÿ
ï¼½ã ã‘ã§ååˆ†ã«ãªã‚‹ã€‚
ã“ã‚Œã¯ã€
`~domainåå‰ç©ºé–“~tree$ã®ç‰¹å®š0ã®éƒ¨ä½ã®æ‰€æœ‰è€…ã«ï¼»
~NELã‚’åˆ©ç”¨ã—ã¦ï¼Œ`~DNSç’°å¢ƒè¨­å®šã®èª¤ã‚Šï¼ #dns-misconfiguration$ã‚’æ¤œå‡ºã™ã‚‹
ï¼½ã“ã¨ã‚’è¨±å®¹ã™ã‚‹ä¸€æ–¹ã§ã€
æ‰€æœ‰è€…ãŒï¼»
è‡ªèº«ãŒåˆ¶å¾¡ã—ãªã„~serverã«ã¤ã„ã¦ã®æƒ…å ±ã‚’ï¼Œæ‚ªæ„çš„ãª~DNS~entryã‚’åˆ©ç”¨ã—ã¦åé›†ã™ã‚‹
ï¼½ã“ã¨ã‚’é˜²æ­¢ã™ã‚‹ã€‚
â—
Similarly, subdomain NEL policies are limited, and can only be used to generate reports about subdomains of the policy origin during the DNS resolution phase of a request. During this phase, there is no server to verify ownership of, and the fact that the policy was received from a superdomain of the request's origin is enough to establish ownership of the error. This allows the owners of a particular portion of the domain namespace tree to use NEL to detect 7.3 DNS misconfiguration errors, while preventing them from using malicious DNS entries to collect information about servers they don't control.
</p>

<p>
æƒ…å ±~æ¼æ´©eã‚’é˜²æ­¢ã™ã‚‹ãŸã‚ã€
`è¦è«‹$ã«ã¤ã„ã¦ã®~NELå ±å‘Šã¯ï¼Œï¼»
`è¦è«‹$ã‚’å‡¦ç†ã™ã‚‹ã¨ãã«ï¼Œ`~server$ã‹ã‚‰ã¯å¯è¦–ã§ãªã„æƒ…å ±
ï¼½ã¯åŒ…å«ã—ãªã„ã€‚
`~DNSè§£æ±º$ã®é–“ã®~errorã«å¯¾ã—ã¦ã¯ã€
~NELå ±å‘Šã¯ï¼Œï¼»
~DNSè‡ªèº«ã‹ã‚‰å¯ç”¨ãªæƒ…å ±
ï¼½ã®ã¿ã‚’åŒ…å«ã™ã‚‹ã€‚
ã“ã‚Œã¯ã€
`~server$ãŒ~NELã‚’æ¿«ç”¨ã—ã¦ï¼Œï¼»
åˆ©ç”¨è€…ã«ã¤ã„ã¦ï¼Œã™ã§ã«~accessã‚’æœ‰ã—ã¦ã„ã‚‹ã‚‚ã®
ï¼½ã‚’è¶…ãˆã‚‹æƒ…å ±ã‚’åé›†ã™ã‚‹ã“ã¨ã‚’é˜²æ­¢ã™ã‚‹ã€‚
~NELå ±å‘Šã¯ã€
`å ±å‘Š~æœ¬ä½“$ã® `server_ip^c ~fieldå†…ã«~web~siteã®å…¬ãª~IP~addressã‚’å«ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã€‚
ãã‚Œã¯ã€
`NEL$h ~headerã‚’ç”Ÿæˆã™ã‚‹~serviceã«ã¯ï¼Œå¸¸ã«æ—¢çŸ¥ã«ãªã‚‹ã¨ã¯é™ã‚‰ãªã„
â€” ä¾‹ãˆã°ã€
å½“ã®~serviceãŒï¼»
è² è·åˆ†æ•£å™¨ã‚„ä»–ã®é€éçš„ãª~MITM~proxy
ï¼½ã®èƒŒå¾Œã«ã‚ã‚‹å ´åˆã€‚
â—
To prevent information leakage, NEL reports about a request do not contain any information that is not visible to the server when processing the request. For errors during DNS resolution, a NEL report only contains information available from DNS itself. This prevents servers from abusing NEL to collect more information about their users than they already have access to. Note that NEL reports will include a web site's public IP address in the report body's server_ip field, which may not always be known to the service which generates the NEL header, for example if it is behind a load balancer or other transparent MitM proxy.
</p>

<p class="note">æ³¨è¨˜ï¼š
ä¾‹ã¨ã—ã¦ï¼Œ~NELå ±å‘Šã¯ã€ï¼»
`è¦è«‹$ã®`~domainå$ã‚’~IP~addressã«è§£æ±ºã™ã‚‹ã¨ãã«ï¼Œã©ã®`~DNSè§£æ±ºå™¨$ãŒåˆ©ç”¨ã•ã‚ŒãŸã‹
ï¼½ã«ã¤ã„ã¦ã®æƒ…å ±ã¯ï¼Œç‰¹å®šçš„ã«åŒ…å«ã—ãªã„ã€‚
â—
Note

As an example, NEL reports specifically do not contain any information about which DNS resolver was used to resolve a request's domain name into an IP address.
</p>

<p>
ä¸Šã®åˆ¶ç´„ã«åŠ ãˆã¦ã€
~UAã¯ï¼Œæ¬¡ã«å¾“ã†ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
In addition to above restrictions, the user agents MUST:
</p>
<ul>
	<li>
åˆ©ç”¨è€…ãŒè‡ªèº«ã®é–²è¦§~dataï¼ˆ ~cookie, ~site~data, å±¥æ­´, ç­‰ã€…ï¼‰ã‚’~clearã—ãŸã¨ãã¯ã€
æ ¼ç´-æ¸ˆã¿ãª`~NELæ–½ç­–$ã‚‚~clearã™ã‚‹ã€‚
â—
Clear the stored NEL policies when the user clears their browsing data (cookies, site data, history, etc).
</li>
	<li>
~network~errorå ±å‘Šã‚’é€é”ã™ã‚‹ã¨ãã¯ã€
`Set-Cookie$h å¿œç­”~headerã‚’å‡¦ç†ã™ã‚‹ã®ã‚’æ‹’å¦ã™ã‚‹ã€‚
â—
Refuse to process Set-Cookie response headers when delivering network error reports.
</li>
</ul>

<p>
é–‹ç™ºè€…ã¯ã€
~NELã‚’é…å‚™ã™ã‚‹ã¨ãã«ã¯ï¼Œï¼»
æŒ‡å®šã—ãŸåé›†å™¨ã«~NELå ±å‘Šã‚’é€é”ã™ã‚‹ã“ã¨ã«ã‚ˆã‚‹~privacyã¸ã®å½±éŸ¿n
ï¼½ã‚’è€ƒæ…®ã™ã‚‹ã¹ãã§ã‚ã‚‹ã€‚
ä¾‹ãˆã°ã€
å ±å‘Šã¯ï¼Œï¼»
ç‰¹åˆ¥ãªäºˆé˜²ç­–ãŒå¿…è¦ãªæ•æ„Ÿãª~data
ï¼½ã‚’ä¼´ã†~URLï¼ˆä¾‹ï¼š `èƒ½åŠ›~URL$ `CAPABILITY-URLS$r ï¼‰ã‚’åŒ…å«ã™ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã€
é–‹ç™ºè€…ã«ã¯ï¼Œï¼»
ãã®ã‚ˆã†ãª~URLãŒç¬¬ä¸‰è€…-ä¸»ä½“ã¸å ±å‘Šã•ã‚Œã‚‹ã“ã¨ã‚’é˜²æ­¢ã™ã‚‹
ï¼½ã‚ˆã†ï¼»
è‡ªå‰ã®~NELåé›†å™¨ã‚’é‹ç”¨ã™ã‚‹
ï¼½ã“ã¨ãŒè¦æ±‚ã•ã‚Œå¾—ã‚‹ã€‚
â—
When deploying NEL the developer SHOULD consider privacy implications of NEL reports delivered to the specified collectors. For example, reports may contain URLs with sensitive data (e.g. "Capability URLs") that may need special precautions (see [CAPABILITY-URLS]), and may require the developer to operate their own NEL collectors to prevent reporting of such URLs to third parties.
</p>

	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">10. IANA è€ƒæ…®ç‚¹</h2>

<p>
æ’ä¹…çš„~message~header~registryã¯ã€
ä»¥ä¸‹ã®ç™»éŒ²ã«ã‚ˆã‚Šæ›´æ–°ã•ã‚Œã‚‹ã¹ãã§ã‚ã‚‹
`RFC3864$r ï¼š
â—
The permanent message header field registry should be updated with the following registrations ([RFC3864]):
â—
10.1. NEL
</p>

<div>
<dl id="nel">
	<dt>~headerå</dt>
	<dd>`NEL$h</dd>
	<dt>é©ç”¨-å¯èƒ½ãª~protocol</dt>
	<dd>http</dd>
	<dt>ä½ç½®ä»˜ã‘</dt>
	<dd>æ¨™æº–</dd>
	<dt>è‘—ä½œè€…ï¼å¤‰æ›´~åˆ¶å¾¡è€…</dt>
	<dd>W3C</dd>
	<dt>ä»•æ§˜~æ–‡æ›¸</dt>
	<dd>ã“ã®ä»•æ§˜ï¼ˆ `NEL$h å¿œç­”~headerã‚’è¦‹ã‚ˆï¼‰</dd>
</dl>
â—
Header field name
â€¢ NEL
Applicable protocol
â€¢ http
Status
â€¢ standard
Author/Change controller
â€¢ W3C
Specification document
â€¢ This specification (see NEL response header)
</div>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">è¬è¾</h2>

<p>
ã“ã®æ–‡æ›¸ã¯
`CSP$r, `RFC6797$r
ä»•æ§˜ã®~textã‚’ï¼Œãã®~licenseã«å¾“ã£ã¦å†åˆ©ç”¨ã—ã¦ã„ã‚‹ã€‚
åŠ ãˆã¦ã€
ã“ã®ä½œæ¥­ã«~~æœ‰ç›Šãª~commentã‚’å¯„ã›ã‚‰ã‚Œè²¢çŒ®ã•ã‚ŒãŸï¼Œæ¬¡ã«æŒ™ã’ã‚‹å„æ°ã«æ„Ÿè¬ã™ã‚‹
â‡’
`Julia Tuttle, Chris Bentzel, Todd Reifsteck, Aaron Heady, Mark Nottingham^en
â—
This document reuses text from the [CSP] and [RFC6797] specification, as permitted by the licenses of those specifications. Additionally, sincere thanks to Julia Tuttle, Chris Bentzel, Todd Reifsteck, Aaron Heady, and Mark Nottingham for their helpful comments and contributions to this work.
</p>
	</section>
</main></div>
