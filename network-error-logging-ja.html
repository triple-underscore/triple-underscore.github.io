<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Network Error Logging（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<style>
.report {
	color: var(--text-color-2);
}

samp {
	white-space: nowrap;
	background: #F0F0F0;
	margin-left: 0.5em;
	margin-right: 0.5em;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2020-04-21
trans_update:2021-07-30
source_checked:180718
page_state_key:WEBAPPSEC
original_url:https://w3c.github.io/network-error-logging/
page_state_key:WEBAPPSEC
site_nav:network,security,performance
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
	conformance:w3c
copyright:2020,permissive
trans_1st_pub:2015-04-11


●●class_map
h:header
e:element
st:status
P:production
jt:js-type
jv:js-value

●●tag_map
c:code
m:code
st:code
jt:code
jv:code
h:code
e:code
P:var
v:var
i:i
s:samp
em:em

●●original_id_map

●●mdn_urls
	dfn-nel:HTTP/Headers/NEL

●●link_map

st.4xx:~HTTPsem#status.4xx
	st.4xx:~RFC7231#section-6.5
st.5xx:~HTTPsem#status.5xx
	st.5xx:~RFC7231#section-6.6
st.200:~HTTPsem#status.200
	st.200:~RFC7231#section-6.3.1
st.304:~HTTPsem#status.304
	st.304:~RFC7232#section-4.1


h.NEL:#dfn-nel
h.Set-Cookie:~HTTPcookie#sane-set-cookie
	~RFCx/rfc6265#section-4.1
h.Report-To:#_report-to
h.Reporting-Endpoints:~REPORTING#reporting-endpoints
h.Content-Length:~HTTPsem#field.content-length
	h.Content-Length:~RFC7230#section-3.3.2
h.ETag:~HTTPsem#field.etag
	h.ETag:~RFC7232#section-2.3
h.If-None-Match:~HTTPsem#field.if-none-match
	h.If-None-Match:~RFC7232#section-3.2


P.json-field-value:~RFCx/draft-reschke-http-jfv#json-field-value

c.failure_fraction:#dfn-failure_fraction
c.include_subdomains:#dfn-include_subdomains
c.max_age:#dfn-max_age
c.success_fraction:#dfn-success_fraction
c.report_to:#dfn-report_to
c.request_headers:#dfn-request_headers
c.response_headers:#dfn-response_headers


	●用語

~network要請:#dfn-network-requests
相:#dfn-phase
~DNS解決:#dfn-dns-resolution
~secure接続の確立:#dfn-secure-connection-establishment
要請と応答の伝送:#dfn-transmission-of-request-and-response


~NEL施策:#dfn-nel-policies
nP.受信した~IP~address:#dfn-received-ip-address
nP.生成元:#dfn-policy-origin
nP.施策~生成元:#dfn-policy-origin
nP.下位domainを含むか:#dfn-subdomains
nP.報告用~group:#dfn-reporting-group
nP.有効秒数:#dfn-ttl
nP.作成時刻:#dfn-creation
nP.要請~header名~list:#dfn-policy-request-headers
nP.応答~header名~list:#dfn-policy-response-headers

要請~headerたちを抽出する:#extract-request-headers
応答~headerたちを抽出する:#extract-response-headers

失効した:#dfn-expired
失効して:#dfn-expired

見本抽出率:#dfn-sampling-rate
成功~時の見本抽出率:#dfn-successful-sampling-rate
失敗~時の見本抽出率:#dfn-failure-sampling-rate

成功-:#dfn-succeed
成功した:#dfn-succeed
失敗-:#dfn-fail
失敗した:#dfn-fail
	~fail:#dfn-fail
	~failures:#dfn-fail
	~succeeded:#dfn-succeed


~network~error:#dfn-network-errors
~network~error報告:#dfn-network-error-reports
nE.種別:#dfn-types
nE.相:#dfn-type-phase

施策~cache:#dfn-policy-cache

生成元~用の施策を選ぶ:#choose-a-policy-for-an-origin
	§~Predefined~network~error~types:#predefined-network-error-types
	§~DNS環境設定の誤り:#dns-misconfiguration
	§~Origins~with~multiple~IP~address:#origins-with-multiple-ip-addresses
	§~Privacy~Considerations:#privacy-considerations


~CORS予行~要請:~FETCH#cors-preflight-request
~HTTP~network~fetch:~FETCH#http-network-fetch
~redirect:~FETCH#redirect-status
応答:~FETCH#concept-response

rq.~client:~FETCH#concept-request-client
	rq.~referrer:~FETCH#concept-request-referrer
rq.~header~list:~FETCH#concept-request-header-list
rs.~header~list:~FETCH#concept-response-header-list
	廃：rs.~trailer:~FETCH#concept-response-trailer

hd.名前:~FETCH#concept-header-name
hd.値:~FETCH#concept-header-value
名前に持つ~header:~FETCH#_headers-of-name
	名前に持つ~header:~FETCH#header-list-contains

報告:~REPORTING#report
報告~種別:~REPORTING#report-type
報告を~queueする:~REPORTING#reporting-queue
	報告先~group用に~dataを~queueする:~REPORTING#queue-report
報告先~group:#_endpoint-group
	報告先~group:~REPORTING#endpoint-group
行先:~REPORTING#report-destination
	報告~本体:~REPORTING#report-body
	eG.有効秒数:~REPORTING#dom-endpoint-group-ttl
報告用~観測器から可視:~REPORTING#visible-to-reportingobservers
	:~REPORTING#visible-to-reporting-observers


~domain名:~RFCx/rfc1034#section-3.1
~domain名前空間~tree:~RFCx/rfc1034#section-3.1
~DNS解決器:~RFCx/rfc1034#section-5

環境~設定群~obj:~WAPI#environment-settings-object


~navi:~NAVI#navigate
生成元:~ORIGIN#origin
同一-生成元:~ORIGIN#same-origin

m.navigator.onLine:~HTMLnavigator#dom-navigator-online

	~network~protocol:~RESOURCE-TIMING#dom-performanceresourcetiming-nexthopprotocol
	m.nextHopProtocol:~RESOURCE-TIMING#dom-performanceresourcetiming-nexthopprotocol


	SECURE-CONTEXT:https://www.w3.org/TR/secure-contexts/
生成元は信用に価し得るか？:~SECURE-CONTEXT#is-origin-trustworthy
信用に価し得る生成元:~SECURE-CONTEXT#potentially-trustworthy-origin

~referrer施策:~REFERRER-POLICY#referrer-policy
	https://www.w3.org/TR/referrer-policy/#referrer-policy

持続的な接続:~HTTPmsg#persistent.connections
	~RFC7230#section-6.3
要請:#_request
	~RFC7230#section-2.1
~server:~HTTPinfra#server
	~RFC7230#section-2.1
要請~method:~HTTPsem#methods
	~RFC7231#section-4
	~RFC7230#section-2.1
応答~header:~HTTPsem#response-header
	~RFC7231#section-7
状態s~code:~HTTPsem#status-code
	~RFC7231#section-6
	~HTTP要請:~HTTPsem#request
	~RFC7230#section-2.1

上位domain合致-:~RFCx/rfc6797#section-8.2

	●補完
~map:~INFRA#ordered-map
混在~内容:~MIXED-CONTENT#mixed-content

内容:~HTTPinfra#message-content
内容~符号法:~HTTPsem#content.codings

pC.~referrer施策:~ORIGIN#policy-container-referrer-policy
enV.施策~容器:~WAPI#concept-settings-object-policy-container

	要請の~referrerを決定する~algo:~REFERRER-POLICY#determine-requests-referrer

●●words_table1

●●words_table

	●netowork
	~HTTP~network:HTTP-network
TLS:
TCP:
DNS:
IP:
IPv4:
IPv6:
open:
trailer:
	server側:server-side
上位domain:superdomain::上位 domain:上位ドメイン
下位domain:subdomain::下位 domain:下位ドメイン
close::::
	content-length
	~client側:client-side
	errorなく error-free:::
交換:exchange:~
routing:::経路制御:ルーティング
offline::::オフライン
downtime::::稼働停止期間:ダウン期間
pinning:
pinned:


確立:establishment::~

予行:preflight::~
接続性:connectivity::~
	に送信した:received response from
	到達-不能:unreachable
解決器:resolver::~
検索:lookup::~
運用-:operate::~
為され:makeされ:~
為そ:makeしよ:~

	ALPN Protocol ID

	●保安／privacy
scan::::スキャン
scripting::::
malware::::マルウェア
持続的:persistent::~
追跡器:tracker::~
自明:trivial::~
乗取り:hijacking::~
暗号:cipher::~
証明書:certificate::~
権限:authority::~
探査-:probe::~
閲覧:browsing::~
究明-:investigate::~
影響n:implications:影響
	検証yしない:Without 〜 verification
	~supercookie
降格-:downgrade::~
防ぐ:preventする:~
予防策:precautions:~
	collectors
混在:mixed::~

	信用に価し得る:potentially trustworthy
	MITM
	^en:rebinding
	^en:Capability
	HSTS, HPKP, ~pinned CSP

	●NEL／施策／処理model
NEL:
	~cache法:caching
収集器:collector::~
	`REPORTING$r:Reporting
	報告-法:reporting
報告処理:reporting::~::レポート処理
報告用:reporting::~::レポート用
報告先:endpoint::~
	報告先:Reporting endpoint
	登録-済み:registered

相:phase::~
失効-:expire::~
存続期間:lifetime::~
有効秒数:ttl::~
実時間:real-time::~::リアルタイム
時間切れ:timeout::~
	時間切れに:timed out
作成時刻:creation::~
経過-:elapse:~
計測-:instrument:~
age:::
milli::::ミリ
	milliseconds:::ミリ秒
過去:past:~
近過去:recent:~
	日間:days
	秒間:seconds
	秒数:number of seconds
	秒:seconds

random::::ランダム
比率:rate::~
見本抽出率:sampling rate::~

	●一般処理
	により起動された:-initiated
起動元o:originator:起動元
	処理-法:processing

	●data構造／操作
下位group:subgroup::下位グループ
実数:number::~
	`Boolean^jt:boolean
	`String^jt:string
	`Number^jt:number
	`number^jt:number
	並び:sequence

	●構文／
符号法:coding::~::コーディング
	~URL:URI

	~NIN 空 `string^jt:non-empty
dot::::ドット
	dot-delimited
	dotted-decimal
表記法:notation:~
有効:valid::~
不一致:mismatch::~
区切られ:delimitされ:~
	並び:sequence
	片:piece
	負でない:non-negative

	●仕様
末端利用者:end user:~:::エンドユーザ
可用性:availability:~
任意選択でき:opt inでき:任意に選択でき
	OPTIONAL
必須:required:~
	必須:REQUIRED
仕事:work:~
license::::
最悪の:worstな:~
集団:populations:~
恒久的:permanent:~
事実:fact:~
実効性:effectiveness:有効性
扱い:treatment:~
寄与:contribution:~
気付く:awareする:~
気付かな:awareしな:~
	気付かないまま:left unaware
事前決定-:predetermine:~

解消-:solve:~
解決策:solution:~
給-:supply:~
指図-:instruct:~
支援:assistance:~
適応-:accommodate:~
濫用-:abuse:~
強いら:forceさ:~
手助け:facilitate:~
増補-:augment:~
著作者:author:~
変更管理者:change controller:~
位置付け:status:~

	適正でない:improper
	易くする:facilitate
	実践的な:hands-on
	become:::
	まだ:still
	問わず:regardless of
	必要性:need
	不要になる:eliminating
	全般:overall
	~~有益な:helpful
	さもなければ:otherwise
	ので:therefore
	なぜ:why
	今日の:today
	補助:helping
	sincere
	thank
	できない:unable
	-可能／できる:able
	-:we
	したい所:ideally
	義務付けられ:mandatory
	以下では:This rationale
	はずである:must
	出来事:event
	真に:truly
	必要がある:must
	~~要因:cause
	再び試みる:reattempting
	とする:assume する
	残りの:additional
	許容しないようにする:disallow
	それにより〜可能に:allow
	掘り下げる:Plumb this through
	忘れた:forget した
	主用途:primarily used to
	取り込む:ingest
	備え:equipped
	-:help
	選ぶ:choose
	気付く:notice

	●未分類（動詞
拒否-:refuse::~
廃止-:revoke::~
一過性の:transientな:~
問題i:issue::問題
発行:issuing::~
	所有者が誰か:ownership
管理者:administrator::~
条態:condition::~
遭遇-:encounter:~

集約-:aggregate::~
集約:aggregation::~
放棄-:abandon::~
	^en:synthetic monitoring

	環境設定の誤り:misconfiguration
	環境設定を誤った:misconfigure
	伝える:inform
	~T:include
	~F:exclude
	属-:belong
	まま:left
	無い:not present
	長生きする:long-lived

	●未分類
ES:ECMAScript
location-bar:location bar:::ロケーションバー
賽:roll🎲:サイ🎲
	opt:::
category::::カテゴリ
部位:portion:~
特性:characteristic:~
実在の:real:~
全域的:global:~
投資:investment:~
地理的:geographic:~
	近い:near
	十分高い:sufficiently high
	HTML／CSS／JavaScript
	IANA
	~NIN:equal
	~consist

	ε:no policy
	減らす:less
	こともある:sometimes
	end:
	~RET:skip the remaining steps／abort these steps


	●指示語
	それだけで:own
	別の:second
	以外の:not covered
	〜以上は:at a minimum
	数多くの:dozens of
	どれだけ:how many
	一部:part-of
	のみならず:not just
	多量の:large volume of
	最後に:finally
	ずっと多い:greatly outnumber
	わたって:across
	隔たれた:not coupled with
	に対する:against
	大概は:most
	-:if ever
	ごとに:per-
	あらゆる:every
	〜から:out of
	またもや:once again
	応答を受信した時点:presently
	時点:time
	最新:up to date
	直後:immediately after
	ある時点で:at some point
	今回:this time
	いくばくか後:some time later
	しばらくして後:Even later
	以前に:previously
	以前の／前の:previous

●●ref_data
CAPABILITYURLS=副   ~/capability-urls-ja.html

●●ref_normative

[CAPABILITY-URLS]
    Good Practices for Capability URLs. Jeni Tennison. W3C. 18 February 2014. W3C Working Draft. URL: https://www.w3.org/TR/capability-urls/
[CSP]
    Content Security Policy Level 3. Mike West. W3C. 29 June 2021. W3C Working Draft. URL: https://www.w3.org/TR/CSP3/
[ECMA-262]
    ECMAScript Language Specification. Ecma International. URL: https://tc39.es/ecma262/multipage/
[FETCH]
    Fetch Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://fetch.spec.whatwg.org/
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[HTTP-JFV]
    A JSON Encoding for HTTP Header Field Values. J. Reschke. IETF. 24 October 2017. Active Internet-Draft. URL: https://datatracker.ietf.org/doc/html/draft-reschke-http-jfv
[REFERRER-POLICY]
    Referrer Policy. Jochen Eisinger; Emily Stark. W3C. 26 January 2017. W3C Candidate Recommendation. URL: https://www.w3.org/TR/referrer-policy/
[REPORTING]
    Reporting API. Douglas Creager; Ilya Grigorik; Paul Meyer; Mike West. W3C. 25 September 2018. W3C Working Draft. URL: https://www.w3.org/TR/reporting-1/
[RESOURCE-TIMING-2]
    Resource Timing Level 2. Yoav Weiss; Noam Rosenthal; Ilya Grigorik; Todd Reifsteck; Arvind Jain; Jatinder Mann; Zhiheng Wang; Anderson Quach. W3C. 14 April 2021. W3C Working Draft. URL: https://www.w3.org/TR/resource-timing-2/
[RFC1034]
    Domain names - concepts and facilities. P.V. Mockapetris. IETF. November 1987. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc1034
[RFC1123]
    Requirements for Internet Hosts - Application and Support. R. Braden, Ed.. IETF. October 1989. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc1123
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119
[RFC3864]
    Registration Procedures for Message Header Fields. G. Klyne; M. Nottingham; J. Mogul. IETF. September 2004. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc3864
[RFC4291]
    IP Version 6 Addressing Architecture. R. Hinden; S. Deering. IETF. February 2006. Draft Standard. URL: https://www.rfc-editor.org/rfc/rfc4291
[RFC6797]
    HTTP Strict Transport Security (HSTS). J. Hodges; C. Jackson; A. Barth. IETF. November 2012. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6797
[RFC7159]
    The JavaScript Object Notation (JSON) Data Interchange Format. T. Bray, Ed.. IETF. March 2014. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc7159
[RFC7230]
    Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7230.html
[RFC7231]
    Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7231.html
[RFC7232]
    Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7232.html
[RFC7234]
    Hypertext Transfer Protocol (HTTP/1.1): Caching. R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7234.html
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174
[SECURE-CONTEXTS]
    Secure Contexts. Mike West. W3C. 15 September 2016. W3C Candidate Recommendation. URL: https://www.w3.org/TR/secure-contexts/
[URL]
    URL Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://url.spec.whatwg.org/

●●
ref_informative

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより，副題に日付にて編集者草案として公開された
<a href="~SPEC_URL">Network Error Logging</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/network-error-logging/
公表履歴
	https://www.w3.org/standards/history/network-error-logging-1
編集者草案
	https://w3c.github.io/network-error-logging/
commit 履歴
	https://github.com/w3c/network-error-logging/commits/
編集
	<a href="https://dcreager.net/">Douglas Creager</a> (GitHub)
	Ian Clelland (Google)
前任編集者
	<a href="https://www.igvita.com/">Ilya Grigorik</a> (Google) (Until August 2019)
	Julia Tuttle (Google) (Until September 2017)
	Arvind Jain (Google) (Until January 2015)
	Alois Reitbauer (Compuware Corp.) (Until October 2014)
	Jatinder Mann (Microsoft) (Until February 2014)
フィードバック
	<a href="https://github.com/w3c/network-error-logging/">GitHub w3c/network-error-logging</a> (<a href="https://github.com/w3c/network-error-logging/pulls/">pull requests</a>, <a href="https://github.com/w3c/network-error-logging/issues/new/choose">new issue</a>, <a href="https://github.com/w3c/network-error-logging/issues/">open issues</a>)
公表者
	<a href="https://www.w3.org/groups/wg/webperf">Web Performance WG</a>

</script>




</head>

<body>

<header>
	<hgroup>
<h1 id="title">Network Error Logging</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この文書は［
開発者が，~web~app用に~network~errorを報告する施策を宣言できるようにする
］ための仕組みを定義する。
~UAは、この施策を［
要請された資源を成功裡に~fetchできなくする~network~errorに遭遇したときに
報告する
］ために利用できる。
◎
This document defines a mechanism that enables developers to declare a network error reporting policy for a web application. A user agent can use this policy to report encountered network errors that prevented it from successfully fetching requested resources.
</p>

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
この節では、公表~時点における…
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~web~appの処理能~特性を正確aに測定することは、~site開発者が，~web~appを改善する方法を解する補助として重要な側面を成す。
~network~errorに因る［
~app／特定0の資源
］読込nの失敗は、最悪の局面である。
開発者たちがそのような失敗に取組むためには、そのような失敗が［
いつ，どこで，なぜ
］生じたかを識別するために，~UAからの支援を要する。
◎
Accurately measuring performance characteristics of web applications is an important aspect in helping site developers understand how to improve their web applications. The worst case scenario is the failure to load the application, or a particular resource, due to a network error, and to address such failures the developer requires assistance from the user agent to identify when, where, and why such failures are occurring.
</p>

<p>
今日の~app開発者は、［
末端利用者からの，~web~appの可用性
］についての~dataを実時間に得ることはできない。
例えば、利用者が~network~errorに因り ~pageの読込ngに失敗した場合
— ［
~DNS検索に失敗した, 接続が時間切れになった, 接続の再設定-, その他の事由
］など —
~site開発者は，その問題iを検出して取組むことはできない。
これらの種類の~network~errorは、純粋に~server側のみからは，検出できないことに注意
— 定義により，~clientは ~serverとの接続を成功裡に確立できないかもしれないので。
◎
Today, application developers do not have real-time web application availability data from their end users. For example, if the user fails to load the page due to a network error, such as a failed DNS lookup, a connection timeout, a reset connection, or other reasons, the site developer is unable to detect and address this issue. Note that these kinds of network errors cannot be detected purely server-side, since by definition the client might not have been able to successfully establish a connection with the server.
</p>

<p>
既存の手法（人工的な監視
【`<a href="https://en.wikipedia.org/wiki/Synthetic_monitoring">synthetic monitoring</a>^en】
など）は、事前決定された地理的~所在に監視~nodeを配置することにより，部分的な解決策を供するが、追加的な基盤~投資が要求され，［
実在の末端利用者にとっての可用性について，真に全域的かつ実時間に近い~data
］は供せない。
◎
Existing methods (such as synthetic monitoring) provide a partial solution by placing monitoring nodes in predetermined geographic locations, but require additional infrastructure investments, and cannot provide truly global and near real-time availability data for real end users.
</p>

<p>
<abbr>~NEL</abbr>（ `Network Error Logging^en ）は、［［［［
~UAが［
所与の生成元に対する~network~errorを報告する
］ときに利用できる報告用~施策
］を，~web~appが宣言すること
］を可能化する仕組み
］を定義する
］ことにより，この必要性に取組む。
~web~appは、［
欲される`~NEL施策$を述べる `NEL$h ~HTTP応答~headerを給する
］ことにより，~NELの利用を任意選択できる。
この施策は、その生成元への要請についての情報を~logしてから,
その情報を `REPORTING$r ~APIを利用して 以前に環境設定された`報告先~group$へ送達しようと試みるよう、~UAに指図する。
その名が含意するように，~NEL報告の主用途は `~error^emを述べることにあるが、異なる~client集団にわたる~errorの`比率^emを決定するためには，`成功した^em要請が どれだけ生じているかも知る必要がある
— これらの成功した要請も，~NELの仕組みを介して報告できる。
◎
Network Error Logging (NEL) addresses this need by defining a mechanism enabling web applications to declare a reporting policy that can be used by the user agent to report network errors for a given origin. A web application opts into using NEL by supplying a NEL HTTP response header field that describes the desired NEL policy. This policy instructs the user agent to log information about requests to that origin, and to attempt to deliver that information to a group of endpoints previously configured using the Reporting API [REPORTING]. As the name implies, NEL reports are primarily used to describe errors. However, in order to determine rates of errors across different client populations, we must also know how many successful requests are occurring; these successful requests can also be reported via the NEL mechanism.
</p>


<div class="example">
<p>
例えば、~TCP接続が中止されたことに因り，
~UAが `https://www.example.com^s から資源の~fetchに失敗した場合、~UAは，
`REPORTING$r ~APIを介して次の様な報告を~queueすることになる：
◎
For example, if the user agent fails to fetch a resource from https://www.example.com due to an aborted TCP connection, the user agent would queue the following report via the Reporting API:
</p>

<dl>
	<dt>`種別$nE</dt>
	<dd>`network-error^l
</dd>
	<dt>
`報告用~group$nP
◎
endpoint group
</dt>
	<dd>
`report_to$c ~fieldにより環境設定された`報告先~group$
◎
the endpoint group configured by the report_to field
</dd>
	<dt>設定群</dt>
	<dd>TODO</dd>
	<dt>~data</dt>
	<dd>
<pre class="lang-json">
{
  "referrer": "https://referrer.com/",
  "sampling_fraction": 1.0,
  "server_ip": "192.0.2.42",
  "protocol": "http/1.1",
  "elapsed_time": 321,
  "phase": "connection",
  "type": "tcp.aborted"
}
</pre>
	</dd>
</dl>

</div>

<p>
通信される報告を成す各~field, および報告の形式についての説明は、
<a href="#generate-a-network-error-report">§ ~network~error報告の生成-法</a>
に見られる。
より~~実践的な，~NEL登録と報告-時の処理-例は、
<a href="#examples">§ 例</a>
に見られる。
◎
See 5.2 Generate a network error report for an explanation of the communicated fields and format of the report, and 7. Examples for more hands-on examples of NEL registration and reporting process.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p>
この訳の~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~EACH(…), 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
この仕様に現れる
`要請@
（ `request^en ）は、［
~HTTPが定義する
<a href="~HTTPinfra#messages">要請</a>【！~RFC7231#introduction】,
`FETCH$r が定義する
<a href="~FETCH#concept-request">要請</a>
］いずれかを指す。
どちらを指すかは、柔軟に解釈する必要がある（原文では、一律に~HTTP要請を参照しているが）。
</p>

<p>
この仕様に現れる用語
`報告先~group@
は、
`REPORTING$r に定義されていたが，その仕様の更新により廃された
— 代わる用語は（`報告$の）`行先$になると思われるが、はっきりしない。
</p>

	</section>
	<section id="conformance-requirements">
<h2 title="Conformance requirements">2. 適合性~要件</h2>

【この節の内容は、<a href="~W3Ccommon#conformance">~W3C日本語訳 共通~page</a>に移譲。】


		<section id="dependencies">
<h3 title="Dependencies">2.1. 依存関係</h3>

【この節の内容（他の仕様に定義される用語の一覧）は、省略する。】

		</section>
	</section>
	<section id="concepts">
<h2 title="Concepts">3. 概念</h2>

		<section id="network-requests">
<h3 title="Network requests">3.1. ~network要請</h3>


<p>
`~network要請@
（ `network request^en ）は、~UAが単独の`要請$を~serviceするときに~networkを利用する必要があるときに生じる：
◎
A network request occurs when the user agent must use the network to service a single request.
</p>

<ul>
	<li>
~UAが局所~cacheから~serviceできる`要請$は、`~network要請$を成さないモノトスル。
◎
If the user agent can service a request out of a local cache, that request MUST NOT result in a network request.
</li>
	<li>
~UAが`~navi$の一部として`~redirect$に追従する場合、~redirect連鎖を成す各`要請$ごとに 別々な`~network要請$を成すモノトスル。
◎
If the user agent follows redirects as part of a navigation, there MUST be separate network requests for each request in the redirect chain.
</li>
	<li>
<p>
次のいずれかに該当する`要請$は、`~network要請$を成さないモノトスル：
</p>

		<ul>
			<li>
~UAは~offlineにあることが既知であるもの（すなわち `navigator.onLine$m が ~F を返すとき）。
◎
A request MUST NOT result in a network request if the user agent is known to be offline (i.e., when navigator.onLine returns false).
</li>
			<li>
`混在~内容$や
<a href="~FETCH#cors-protocol">~CORS</a>
の失敗に因り，阻止されたもの。
◎
A request MUST NOT result in a network request if it is blocked due to mixed content or CORS failures.＼
</li>
		</ul>
	</li>
	<li>
各`~CORS予行~要請$は、それだけで`~network要請$を成すモノトスル。
◎
Any CORS-preflight request MUST result in its own network request.
</li>
</ul>

<p class="note">注記：
`FETCH$r 標準に則って`要請$を~serviceする~UAにおいては、各`~network要請$は，`~HTTP~network~fetch$ ~algoの 1 回の実行に対応する。
◎
Note
For user agents that service requests according to the [FETCH] standard, a network request corresponds to one execution of the HTTP-network fetch algorithm.
</p>

<p>
どの［
~fetch~algo, 下層の~app, ~transport~protocol
］を利用するかを問わず、`~network要請$を~serviceする~~過程は，次に挙げる
`相@
（ `phase^en ）からなる：
◎
Regardless of which fetch algorithm and which underlying application and transport protocols are used, servicing a network request consists of the following phases:
</p>

<ol>
	<li>
`~DNS解決@
⇒
~UAが~DNS（ `Domain Name System^en `RFC1034$r ）を利用して、~domain名を［
その~domainへ向けた~HTTP要請に対し~serviceできる`~server$
］の~IP~addressに解決するまでの間。
◎
DNS resolution: The user agent uses the Domain Name System [RFC1034] to resolve a domain name into an IP address of a server can that service HTTP requests to that domain.
</li>
	<li>
`~secure接続の確立@
⇒
~UAが`~server$への接続を~openして、その接続~越しに~secure~channelを確立するまでの間。
◎
Secure connection establishment: The user agent opens a connection to the server, and establishes a secure channel over this connection.
</li>
	<li>
`要請と応答の伝送@
⇒
~secure~channelが確立されたなら、~UAは，~HTTP要請を伝送して`~server$からの応答を受信できるようになる。
◎
Transmission of request and response: Once the secure channel is established, the user agent can transmit the HTTP request, and receive the response from the server.
</li>
</ol>

<p>
`~network要請$を成すために義務付けられる`相$は，これらのうち`要請と応答の伝送$のみであり、他の相は，
必要ないかもしれない。
一例として，~DNSの結果は、~UAにおいて局所的に~cacheできる
— その場合、同じ~domain向けの未来の要請に対する`~DNS解決$は不要になる。
同様に，~HTTPの`持続的な接続$は、同じ`生成元$への複数の要請が同じ~open接続を共有することを許容する。
しかしながら，複数の`相$が生じる場合、上の順序で生じることになる。
◎
The only mandatory phase is the transmission of request and response; the other phases might not be needed for every network request. For instance, DNS results can be cached locally in the user agent, eliminating DNS resolution for future requests to the same domain. Similarly, HTTP persistent connections allow open connections to be shared for multiple requests to the same origin. However, if multiple phases occur, they will occur in the above order.
</p>

<p class="note">編集者注記：
これらの相の定義は、もっと再利用できるよう `FETCH$r に移動したい所。
◎
We would like to move the definition of these phases into [FETCH] so that they are more reusable.
</p>


<p>
`~network要請$は、次が~~判明した時点で
`成功した@
（ `successful^en ）とされる
⇒
［
~UAは、~serverから妥当な~HTTP応答を受信できた
］~AND［
その応答の状態s~codeは［
`4xx$st ／ `5xx$st
］でない
］
◎
A network request is successful if the user agent is able to receive a valid HTTP response from the server, and that response does not have a 4xx or 5xx status code.
</p>

<p>
`~network要請$は、`成功-$しなかったことが~~判明した時点で
`失敗した@
（ `failed^en ）とされる。
◎
A network request is failed if it is not successful.
</p>

<p class="note">注記：
~HTTP~error応答（すなわち 状態s~codeに［
`4xx$st ／ `5xx$st
］を伴うもの）は、それが `~NEL施策$の`成功~時の見本抽出率$に代えて`失敗~時の見本抽出率$の~subjectになるよう，`失敗した$ものと見なされることに注意。
◎
Note
Note that HTTP error responses (i.e., those with a 4xx or 5xx status code) are considered failures, so that they are subject to a NEL policy's failure sampling rate instead of its successful sampling rate.
</p>

		</section>
		<section id="network-errors">
<h3 title="Network errors">3.2. ~network~error</h3>

<p>
`~network要請$を `失敗-$させた~error条態を
`~network~error@
という。
◎
A network error is the error condition that caused a network request to fail.
</p>


<p>
各`~network~error$には、文字列として与えられる
`種別@nE
（ `type^en ）がある。
◎
Each network error has a type, which is a string.
</p>

<p>
各`~network~error$には、当の~errorはどの`相$で生じたかを述べる
`相@nE
（ `phase^en ）がある：
◎
Each network error has a phase, which describes which phase the error occurred in:
</p>

<dl>
	<dt>`dns^l</dt>
	<dd>
当の~errorは、`~DNS解決$の間に生じた
◎
the error occurred during DNS resolution
</dd>

	<dt>`connection^l</dt>
	<dd>
当の~errorは、`~secure接続の確立$の間に生じた
◎
the error occurred during secure connection establishment
</dd>

	<dt>`application^l</dt>
	<dd>
当の~errorは、`要請と応答の伝送$の間に生じた
◎
the error occurred during the transmission of request and response
</dd>

</dl>

<p>
`~network~error$の`種別$nEとして定義済みなものがいくつかあり、
<a href="#predefined-network-error-types">定義済み~network~error種別</a>
にて定義される。
◎
There are several predefined network error types defined in 6. Predefined network error types.
</p>

		</section>
		<section id="network-error-reports">
<h3 title="Network error reports">3.3. ~network~error報告</h3>

<p>
`~network~error$を述べる`報告$ `REPORTING$r は、
`~network~error報告@
（ `network error report^en ）と呼ばれる。
◎
A network error report is a Reporting API report that describes a network error.
</p>

<p>
`~network~error報告$の`報告~種別$は、 `network-error^l とする。
◎
Network error reports have a report type of network-error.
</p>

<p>
`~network~error報告$は、`報告用~観測器から可視$でない。
◎
Network error reports are NOT visible to ReportingObservers.
</p>

<p class="note">注記：
`報告用~観測器から可視$でないとされているのは、`~network~error報告$は，要請を`受信している^em~serverの［
管理者／所有者
］からに限り可視になることが意図されているからである。
報告が`報告用~観測器から可視$にされたなら、要請の`起動元o^emからも可視になる。
その結果，非同一-生成元~要請に対しては、その~serverの制御の外側にある主体にも，~serverの~network環境設定についての情報が漏洩され得ることにもなる。
◎
Note
Network error reports are not visible to ReportingObservers because they are only intended to be visible to the administrator or owner of the server receiving the requests. If they were visible to ReportingObservers, then the reports would also be visible to the originator of the request. For cross-origin requests, this could leak information about the server's network configuration to parties outside of its control.
</p>

		</section>
		<section id="nel-policies">
<h3 title="NEL policies">3.4. ~NEL施策</h3>

<p>
`~NEL施策@
（ `NEL policy^en ）は、`生成元$への`~network要請$についての報告を収集するかどうか，収集した報告はどこへ送信するかを、~UAに指図する。
`~NEL施策$は， `NEL$h ~HTTP`応答~header$を介して~UAに送達される。
◎
A NEL policy instructs a user agent whether to collect reports about network requests to an origin, and if so, where to send them. NEL policies are delivered to the user agent via HTTP response headers.
</p>

<p>
各`~NEL施策$は、次に挙げるものを持つ：
◎
↓</p>

<dl>
	<dt>
`受信した~IP~address@nP
◎
Each NEL policy has a received IP address,＼
</dt>
	<dd>
~UAがこの`~NEL施策$を受信した`~server$の~IP~address。
◎
which is the IP address of the server that the user agent received this NEL policy from.
</dd>

	<dt>
`施策~生成元@nP
（ `policy origin^en ）
◎
Each NEL policy has an origin.
</dt>
	<dd>
`生成元$
◎
</dd>

	<dt>
`下位domainを含むか@nP
（ `subdomains flag^en ）
◎
Each NEL policy has a subdomains flag,＼
</dt>
	<dd>
真偽値【！include or exclude】
【原文は `include^en ／ `exclude^en をとるように定義されているが、この訳では真偽値に改める。】
◎
which is either include or exclude.
</dd>

	<dt>
`要請~header名~list@nP（ `list of request headers^en ）
◎
Each NEL policy has a list of request headers＼
</dt>
	<dt>
`応答~header名~list@nP（ `list of response headers^en ）
◎
and a list of response headers,＼
</dt>
	<dd>
両者とも、それぞれ， 0 個以上の`名前$hdからなる~list。
◎
each of which is a list of header names.
</dd>

	<dt>
`報告用~group@nP
（ `reporting group^en ）
◎
Each NEL policy has a reporting group,＼
</dt>
	<dd>
この施策~用の報告の送信-先になる`報告先~group$の名前を与える。
◎
which is the name of the Reporting endpoint group that reports for this policy will be sent to.
</dd>

	<dt>
`有効秒数@nP
（ `ttl^en ）
◎
Each NEL policy has a ttl＼
</dt>
	<dd>
施策が有効であり続ける秒数を表現する。
◎
representing the number of seconds the policy remains valid.
</dd>

	<dt>
`作成時刻@nP
（ `creation^en ）
◎
Each NEL policy has a creation＼
</dt>
	<dd>
~UAがこの施策を受信したときの時刻印。
◎
which is the timestamp when the user agent received the policy.
</dd>
</dl>

<p>
`~NEL施策$は、所与の時点で
( `作成時刻$nP ~PLUS `有効秒数$nP )
が過去の時刻を表現するならば，
`失効した@
（ `expired^en ）とされる。
◎
A NEL policy is expired if its creation plus its ttl represents a time in the past.
</p>


		</section>
		<section id="sampling-rates">
<h3 title="Sampling rates">3.5. 見本抽出率</h3>

<p>
多量の流通を~serveすることが予期される`生成元$は、その生成元に向けて為された あらゆる`~network要請$に対する~NEL報告を取り込む備えはないかもしれない。
生成元は、
`見本抽出率@
（ `sampling rate^en ）を定義して，各~UAが提出する ~NEL報告の個数を制限できる。
概して，`成功した$要請の方が`失敗した$要請より ずっと多いはずなので、生成元は それぞれに異なる見本抽出率を指定できる。
◎
An origin that expects to serve a large volume of traffic might not be equipped to ingest NEL reports for every network request made to the origin. The origin can define sampling rates to limit the number of NEL reports that each user agent submits. Since successful requests should typically greatly outnumber failed requests, the origin can specify different sampling rates for each.
</p>


<p>
各 `~NEL施策$は
`成功~時の見本抽出率@,
`失敗~時の見本抽出率@
を持つ
— 両者とも 0.0 以上 1.0 以下の実数とする。
◎
Each NEL policy has a successful sampling rate, which is a number between 0.0 and 1.0 inclusive.
◎
Each NEL policy has a failure sampling rate, which is a number between 0.0 and 1.0 inclusive.
</p>


		</section>
		<section id="policy-cache">
<h3 title="Policy cache">3.6. 施策~cache</h3>


<p>
適合t~UAは、`~NEL施策$の集合を保守する~storageの仕組みを成す
`施策~cache@
（ `policy cache^en ）を供するモノトスル。
それは、`生成元$nPを~keyに，施策を格納する。
◎
A conformant user agent MUST provide a policy cache, which is a storage mechanism that maintains a set of NEL policies, keyed by their origins.
</p>

<p class="trans-note">【
この訳では、`施策~cache$は［
各 `施策~生成元$nPを`~NEL施策$に対応付ける`~map$
］であると見なした上で，`~map$用に定義された各種~演算／表記法を利用する。
以下の要件を満たすには、~mapで足りるので（また、この~mapにおいては，順序も有意でない）。
】</p>

<p>
この~storageの仕組みは、不透明かつ~vendorに特有であり，~webには公開されないが、次の~methodを供するモノトスル
— それは、この文書が定義する各種~algoから利用されることになる：
◎
This storage mechanism is opaque, vendor-specific, and not exposed to the web, but it MUST provide the following methods which will be used in the algorithms this document defines:
</p>

<ul>
	<li>
`~NEL施策$を［
挿入- ／ 更新- ／ 削除-
］する。
◎
Insert, update, and delete NEL policies.
</li>
	<li>
所与の`生成元$用の`~NEL施策$があれば それを検索取得する。
◎
Retrieve the NEL policy, if any, for an origin.
</li>
	<li>
~cacheを~clearする。
◎
Clear the cache.
</li>
</ul>


		</section>
	</section>
	<section id="policy-delivery">
<h2 title="Policy delivery">4. 施策の送達</h2>

<p>
`~server$は、自身が制御する生成元~用の`~NEL施策$を，`NEL$h ~HTTP `応答~header$を介して定義してもヨイ。
◎
A server MAY define a NEL policy for an origin it controls via the NEL HTTP response header.
</p>

		<section id="nel-response-header">
<h3 title="NEL response header">4.1. `NEL^h 応答~header</h3>


<p>
`生成元$の`~NEL施策$を~UAに向けて通信するためには、
`NEL@h
`応答~header$が利用される。
その~ABNF構文は：
◎
The NEL response header is used to communicate an origin's NEL policy to the user agent. The ABNF (Augmented Backus-Naur Form) syntax for the NEL header is as follows:
</p>

<pre class="bnf">
NEL = json-field-value
</pre>

<p>
この~headerの値は、~JSON~objの配列として， `json-field-value$P に定義されるように解釈される。
この配列~内の各~objは、ある`~NEL施策$を生成元~用に定義する。
~UAは、配列~内の最初の妥当な施策†を処理した上で、残りの施策は無視するモノトスル。
【† “妥当な施策のうち最初のもの” と解釈できてしまうが、<a href="#process-policy-headers">実際の定義</a>では，配列~内の最初の~item以外はすべて無視している。】
◎
The header's value is interpreted as an array of JSON objects, as defined by json-field-value. Each object in the array defines an NEL policy for the origin. The user agent MUST process the first valid policy in the array and ignore any additional policies in the array.
</p>


<p>
~UAは、［
この仕様に定義する構文に適合しない，未知な, あるいは妥当でない~fieldや値
］を無視するモノトスル。
妥当な `NEL$h ~headerは、［
この仕様が必須であると定義する~field
］すべてを伴う~objを， 1 個~以上は包含しなければナラナイ。
◎
User agents MUST ignore any unknown or invalid field(s) or value(s) that do not conform to the syntax defined in this specification. A valid NEL header field MUST, at a minimum, contain one object with all of the "REQUIRED" fields defined in this specification.
</p>

<p>
［
~scripting 【 XSS 】 攻撃による，~error報告処理の乗取り
］を軽減するため、~UAは，
`meta^e 要素を介して指定された `NEL$h ~headerは，無視するモノトスル。
`~NEL施策$は、 `NEL$h `応答~header$を介して送達されなければナラナイ。
◎
The user agent MUST ignore the NEL header specified via a meta element to mitigate hijacking of error reporting via scripting attacks. The NEL policy MUST be delivered via the NEL response header.
</p>

<p class="note">注記：
`meta^e 要素に対する制約は、 `CSP$r 仕様に整合する
— それも、同じ事由から，報告処理 登録を~HTTP~headerのみに制約している。
◎
Note
The restriction on meta element is consistent with the [CSP] specification, which restricts reporting registration to HTTP header fields only for the same reasons.
</p>


			<section id="the-report_to-member">
<h4 title="The report_to member">4.1.1. `report_to^c ~member</h4>

<p>
`report_to@c
~memberは、この`~NEL施策$用の報告の送信-先になる`報告先~group$を指定する。
`report_to$c ~memberは、`~NEL施策$を登録するときには必須であり、以前の登録を除去することが意図にあるならば任意選択~である
— `max_age$c を見よ。
在る場合、その値は文字列（ `String^jt 型）でなければナラナイ
— 他の型は、構文解析-~errorになるとする。
◎
The report_to member specifies the endpoint group that reports for this NEL policy will be sent to. The report_to member is REQUIRED to register a NEL policy, and OPTIONAL if the intent is to remove a previous registration – see max_age. If present, its value MUST be a string; any other type will result in a parse error.
</p>

<p class="note">注記：
~NEL報告の送達を改善するため、`~server$は `report_to^c に設定する`報告先~group$に［
~fetchした資源の生成元とは隔たれた基盤に属する，代替~生成元
］内にある報告先を 1 個~以上は包含させるべきである
— さもなければ、問題が解消されるまで~network~errorを報告し得なくなるので。
加えて、一部の報告先に到達-不能な場合の代替として複数の報告先を供するべきである。
◎
Note
To improve delivery of NEL reports, the server should set report_to to an endpoint group containing at least one endpoint in an alternative origin whose infrastructure is not coupled with the origin from which the resource is being fetched — otherwise network errors cannot be reported until the problem is solved, if ever — and provide multiple endpoints to provide alternatives if some endpoints are unreachable.
</p>


			</section>
			<section id="the-max_age-member">
<h4 title="The max_age member">4.1.2. `max_age^c ~member</h4>


<p>
`max_age@c
~memberは、必須であり，この`~NEL施策$の存続期間を秒数で指定する。
その値は、負でない整数でなければナラナイ
— 他の型は、構文解析-~errorになるとする。
◎
The REQUIRED max_age member specifies the lifetime of this NEL policy, as a non-negative integer number of seconds. Its value MUST be an non-negative integer; any other type will result in a parse error.
</p>


<p>
値 0 にすると、この`生成元$用の`~NEL施策$は，すべて`施策~cache$から除去されることになる。
◎
A value of 0 will cause any NEL policy for this origin to be removed from the policy cache.
</p>

<p class="note">注記：
~NEL報告の送達を確保するため、`~server$は，［
`報告先~group$も，十分高い `max_age^c で環境設定される
］ことを確保するべきである。
<!-- ~Reporting施策 -->
この生成元~用の`報告先~group$が失効した場合、~NEL施策が失効していなくとも，~NEL報告は送達されなくなる。
◎
Note
To ensure delivery of NEL reports, the server should ensure that the Reporting endpoint group is also configured with a sufficiently high max_age. If the Reporting policy expires, NEL reports will not be delivered, even if the NEL policy has not expired.
</p>

			</section>
			<section id="the-include_subdomains-member">
<h4 title="The include_subdomains member">4.1.3. `include_subdomains^c ~member</h4>

<p>
`include_subdomains@c
~memberは、任意選択~であり，［
~obj内にこの~memberが在って, かつ その値は真偽値（ `Boolean^jt 型 ） `true^jv
］ならば，この`~NEL施策$を，この生成元のすべての下位domain用にも可能化する
— 他の場合、この`~NEL施策$は下位domain用には可能化されない。
◎
The OPTIONAL include_subdomains member is a boolean that enables this NEL policy for all subdomains of this origin. If no member named include_subdomains is present in the object, or its value is not true, the NEL policy will not be enabled for subdomains.
</p>

<p class="note">注記：
~appは、下位domain用の~NEL報告の送達を確保するためには、［
その`報告先~group$も， `include_subdomains^c が可能化されるよう環境設定される
］ことを確保するべきである。
この生成元~用の`報告先~group$が無いか，所与の下位domain用に別々な`報告先~group$【！~Reporting施策】は無い場合、その下位domain用の~NEL報告は送達されなくなる
— ~NEL施策にて下位domainを含んでいたとしても。
◎
Note
To ensure delivery of NEL reports for subdomains, the application should ensure that the Reporting endpoint group is also configured with include_subdomains enabled. If the Reporting policy is not, and there is not a separate Reporting policy for a given subdomain, NEL reports for that subdomain will not be delivered, even if the NEL policy includes the subdomain.
</p>
			</section>
			<section id="the-success_fraction-member">
<h4 title="The success_fraction member">4.1.4. `success_fraction^c ~member</h4>


<p>
`success_fraction@c
~memberは、任意選択~であり，［
この生成元~用の`~network要請$のうち`成功した$もの
］についての報告に適用されるべきである`見本抽出率$を定義する。
在る場合の値は 0.0 以上 1.0 以下の実数（ `Number^jt 型）でなければナラナイ
— 他の値は、構文解析-~errorになるとする。
この~memberが無い場合、~UAは［
この生成元~用の`~network要請$のうち`成功した$もの
］については~NEL報告を`収集しない^emことになる。
◎
The OPTIONAL success_fraction member defines the sampling rate that should be applied to reports about successful network requests for this origin. If present, its value MUST be a number between 0.0 and 1.0, inclusive; any other value will result in a parse error. If this member is not present, the user agent will not collect NEL reports about successful network requests for this origin.
</p>

			</section>
			<section id="the-failure_fraction-member">
<h4 title="The failure_fraction member">4.1.5. `failure_fraction^c ~member</h4>

<p>
`failure_fraction@c
~memberは、任意選択~であり，［
この生成元~用の`~network要請$のうち`失敗した$もの
］についての報告に適用されるべきである`見本抽出率$を定義する。
在る場合の値は 0.0 以上 1.0 以下の実数（ `Number^jt 型）でなければナラナイ
— 他の値は、構文解析-~errorになるとする。
この~memberが無い場合、~UAは［
この生成元~用の`~network要請$のうち`失敗した$もの
］`すべて^emについての~NEL報告を収集することになる。
◎
The OPTIONAL failure_fraction member defines the sampling rate that should be applied to reports about failed network requests for this origin. If present, its value MUST be a number between 0.0 and 1.0, inclusive; any other value will result in a parse error. If this member is not present, the user agent will collect NEL reports about all failed network requests for this origin.
</p>

			</section>
			<section id="the-request_headers-member">
<h4 title="The request_headers member">4.1.6. `request_headers^c ~member</h4>

<p>
`request_headers@c
~memberは、任意選択~であり，`要請~header名~list$nPを定義する。
それを成す各`名前$hdと対応する`値$hdは、この`生成元$についての`~network~error報告$内に含まれることになる。
在る場合の値は，何個かの文字列からなる~listでなければナラナイ。
◎
The OPTIONAL request_headers member defines the list of request headers whose names and values will be included in network error reports about this origin. If present, its value MUST be a list of strings.
</p>

			</section>
			<section id="the-response_headers-member">
<h4 title="The response_headers member">4.1.7. `response_headers^c ~member</h4>

<p>
`response_headers@c
~memberは、任意選択~であり，`応答~header名~list$nPを定義する。
それを成す各`名前$hdと対応する`値$hdは、この`生成元$についての`~network~error報告$内に含まれることになる。
在る場合の値は，何個かの文字列からなる~listでなければナラナイ。
◎
The OPTIONAL response_headers member defines the list of response headers whose names and values will be included in network error reports about this origin. If present, its value MUST be a list of strings.
</p>

			</section>
		</section>
		<section id="process-policy-headers">
<h3 title="Process policy headers">4.2. 施策~headerの処理-法</h3>

<p>
この~algoは、所与の
( `~network要請$ %要請, その要請に対する`応答$ %応答 )
に対し，［
%要請 の`生成元$用の`~NEL施策$を抽出した結果
］に則って`施策~cache$を更新する：
◎
Given a network request (request) and its corresponding response (response), this algorithm extracts a NEL policy for request's origin, and updates the policy cache accordingly.
</p>

<ol>
	<li>
%生成元 ~LET %要請 の`生成元$
◎
↓</li>
	<li>
~IF［
`生成元は信用に価し得るか？$( %生成元 ) ~EQ `価しない^i
］
⇒
~RET
◎
Abort these steps if any of the following conditions are true:
◎
The result of executing the "Is origin potentially trustworthy?" algorithm on request's origin is not Potentially Trustworthy.
</li>
	<li>
~IF［
%応答 は `NEL^h を名前に持つ`応答~header$を包含しない
］
⇒
~RET
◎
response does not contain a response header whose name is NEL.
◎
↑Let origin be request's origin.
</li>
	<li>
%~header ~LET  名 `NEL^h の`応答~header$の値
◎
Let header be the value of the response header whose name is NEL.
</li>
	<li>
%~list ~LET 
%~header を与える下で
`HTTP-JFV$r § 4 に定義される~algoを実行した結果
◎
Let list be the result of executing the algorithm defined in Section 4 of [HTTP-JFV] on header.＼
</li>
	<li>
~IF［
%~list は~errorである
］~OR［
%~list は空である
］
⇒
~RET
◎
If that algorithm results in an error, or if list is empty, abort these steps.
</li>
	<li>
%~item ~LET %~list[ 0 ]
◎
Let item be the first element of list.
</li>
	<li>
%max_age ~LET %~item 内に `max_age$c ~memberは在るならば その値 ／
無いならば ε
◎
↓</li>
	<li>
%report_to ~LET %~item 内に `report_to$c ~memberは在るならば その値 ／
無いならば ε
◎
↓</li>
	<li>
%success_fraction ~LET %~item 内に `success_fraction$c ~memberは在るならば その値 ／
無いならば 0.0
◎
↓</li>
	<li>
%failure_fraction ~LET %~item 内に `failure_fraction$c ~memberは在るならば その値 ／
無いならば 1.0
◎
↓</li>
	<li>
%include_subdomains ~LET %~item 内に `include_subdomains$c ~memberは在って その値 ~EQ `true^jv ならば ~T ／
~ELSE_ ~F
◎
↓</li>
	<li>
%request_headers ~LET %~item 内に `request_headers$c ~memberは在るならば その値 ／
無いならば 空~list
【原文には無い場合の値が指定されていないが、他所の定義から~listにする必要がある（次の段も同様）。】
◎
↓</li>
	<li>
%response_headers ~LET %~item 内に `response_headers$c ~memberは在るならば その値 ／
無いならば 空~list
◎
↓</li>
	<li>
~IF［
%max_age は実数でない
］~OR［
%max_age ~LT 0 【この条件は、この訳による補完】
］
⇒
~RET
◎
If item has no member named max_age, or that member's value is not a number, abort these steps.
</li>
	<li>
<p>
~IF［
%max_age ~EQ 0
］：
</p>
		<ol>
			<li>
`施策~cache$[ %生成元 ] ~SET ε
</li>
			<li>
~RET
</li>
		</ol>
◎
If the value of item's max_age member is 0, then remove any NEL policy from the policy cache whose origin is origin, and skip the remaining steps.
</li>
	<li>
~IF［
%report_to は文字列でない
］
⇒
~RET
◎
If item has no member named report_to, or that member's value is not a string, abort these steps.
</li>
	<li>
~IF［
%success_fraction は 0.0 以上 1.0 以下の実数でない
］
⇒
~RET
◎
If item has a member named success_fraction, whose value is not a number in the range 0.0 to 1.0, inclusive, abort these steps.
</li>
	<li>
~IF［
%failure_fraction は 0.0 以上 1.0 以下の実数でない
］
⇒
~RET
◎
If item has a member named failure_fraction, whose value is not a number in the range 0.0 to 1.0, inclusive, abort these steps.
</li>
	<li>
~IF［
%request_headers 内に文字列でない~itemがある
］
⇒
~RET
◎
If item has a member named request_headers, whose value is not a list, or if any element of that list is not a string, abort these steps.
</li>
	<li>
~IF［
%response_headers 内に文字列でない~itemがある
］
⇒
~RET
◎
If item has a member named response_headers, whose value is not a list, or if any element of that list is not a string, abort these steps.
</li>
	<li>
<p>
%施策 ~LET 各種~propが次のように設定された，新たな`~NEL施策$
⇒＃
`受信した~IP~address$nP ~SET ~UAに %応答 を送信した`~server$の~IP~address†,
`生成元$ ~SET %生成元,
`下位domainを含むか$nP ~SET %include_subdomains,
`要請~header名~list$nP ~SET %request_headers,
`応答~header名~list$nP ~SET %response_headers,
`報告用~group$nP ~SET %report_to,
`有効秒数$nP ~SET %max_age,
`作成時刻$nP ~SET 現在の時刻印,
`成功~時の見本抽出率$ ~SET %success_fraction,
`失敗~時の見本抽出率$ ~SET %failure_fraction
◎
Let policy be a new NEL policy whose properties are set as follows:
◎
received IP address
• the IP address of the server that the user agent received response from
• Editor's note
• Plumb this through more explicitly in [FETCH].
origin
• origin
subdomains flag
• include if item has a member named include_subdomains whose value is true, exclude otherwise
request headers
• the value of item's request_headers member
response headers
• the value of item's response_headers member
reporting group
• the value of item's report_to member
ttl
• the value of item's max_age member
creation
• the current timestamp
successful sampling rate
• the value of item's success_fraction member, if present; 0.0 otherwise 
failure sampling rate
• the value of item's failure_fraction member, if present; 1.0 otherwise 
</p>

<p class="note">†編集者注記：
これを `FETCH$r において，より明示的に掘り下げる。
◎
↑</p>

	</li>
	<li>
`施策~cache$[ %生成元 ] ~SET %施策
◎
If there is already an entry in the policy cache for origin, replace it with policy; otherwise, insert policy into the policy cache for origin.
</li>
</ol>


		</section>
	</section>
	<section id="report-delivery">
<h2 title="Report delivery">5. 報告の送達</h2>

		<section id="choose-a-policy-for-an-origin">
<h3 title="Choose a policy for an origin">5.1. 生成元~用の施策を選ぶ</h3>


<p>
この~algoは所与の
( `生成元$ %生成元 )
に対し，`施策~cache$内のどの`~NEL施策$が［
%生成元 への`~network要請$用の報告
］を生成するときに利用されるべきかを決定する。
◎
Given an origin (origin), this algorithm determines which NEL policy in the policy cache should be used to generate reports for network requests to origin.
</p>

<ol>
	<li>
%施策 ~LET `施策~cache$[ %生成元 ]
◎
↓</li>
	<li>
~IF［
%施策 ~NEQ ε
］~AND［
%施策 は`失効して$いない
］
⇒
~RET %施策
◎
If there is an entry in the policy cache for origin:
• Let policy be that entry.
• If policy is not expired, return it.
</li>
	<li>
<p>
%生成元 に`上位domain合致-$する
~EACH( %親~生成元 )
に対し：
◎
For each parent origin that is a superdomain match of origin:
</p>
		<ol>
			<li>
%施策 ~LET `施策~cache$[ %親~生成元 ]
◎
↓</li>
			<li>
~IF［
%施策 ~NEQ ε
］~AND［
%施策 は`失効して$いない
］~AND［
%施策 の`下位domainを含むか$nP ~EQ ~T
］
⇒
~RET %施策
◎
If there is an entry in the policy cache for parent origin:
◎
Let policy be that entry.
◎
If policy is not expired, and its subdomains flag is include, return it.
</li>
		</ol>
	</li>
	<li>
~RET ε
◎
Return no policy.
</li>
</ol>

		</section>
		<section id="extract-request-headers">
<h3 title="Extract request headers">5.2. 要請~headerたちを抽出する</h3>

<p>
この~algoは、所与の
( `~network要請$ %要請, `~NEL施策$ %施策 )
に対し，［
%施策 から指図された一連の~header
］の値を %要請 から抽出する：
◎
Given a network request (request) and a NEL policy (policy), this algorithm extracts header values from the request as instructed by the policy.
</p>

<ol>
	<li>
%~headerたち ~LET 新たな~ES~obj
◎
Let headers be a new empty ECMAScript object.
</li>
	<li>
<p>
%施策 の`要請~header名~list$nP内の
~EACH( %~header名 )
に対し：
◎
For each header name in policy's request headers list:
</p>
		<ol>
			<li>
%値~list ~LET 新たな~ES~list
◎
If request's header list does not contain header name, skip to the next header name in the list.
◎
Let values be an empty ECMAScript list.
</li>
			<li>
%要請 の`~header~list$rq内の
~EACH( %~header名 を`名前に持つ~header$ %~header )
に対し
⇒
%値~list に %~header の`値$hdを付加する
◎
For each header in request's header list whose name is header name, append header's value to values.
</li>
			<li>
~IF［
%値~list は空でない
］
⇒
%~headerたち に
新たな~prop( 名前 %~header名, 値 %値~list )
を追加する
◎
Add a new property to headers whose name is header name and whose value is values.
</li>
		</ol>
	</li>
	<li>
~RET %~headerたち
◎
Return headers.
</li>
</ol>

		</section>
		<section id="extract-response-headers">
<h3 title="Extract response headers">5.3. 応答~headerたちを抽出する</h3>

<p>
この~algoは、所与の
( `応答$ %応答, `~NEL施策$ %施策 )
に対し，［
%施策 から指図された一連の~header
］の値を， %応答 から抽出する：
◎
Given a response (response) and a NEL policy (policy), this algorithm extracts header values from the response as instructed by the policy.
</p>

<ol>
	<li>
%~headerたち ~LET 新たな~ES~obj
◎
Let headers be a new empty ECMAScript object.
</li>
	<li>
<p>
%施策 の`応答~header名~list$nP内の
~EACH( %~header名 )
に対し：
◎
For each header name in policy's response headers list:
</p>
		<ol>
			<li>
%値~list ~LET 新たな~ES~list
◎
If response's header list does not contain header name, AND response's trailer does not contain header name, skip to the next header name in the list.
◎
Let values be an empty ECMAScript list.
</li>
			<li>
%応答 の`~header~list$rs内の
~EACH( %~header名 を`名前に持つ~header$ %~header )
に対し
⇒
%値~list に %~header の`値$hdを付加する
◎
For each header in response's header list whose name is header name, append header's value to values.
</li>
			<li>
<p>
%応答 の~trailer†内の
~EACH( %~header名 を`名前に持つ~header$ %~header )
に対し
⇒
%値~list に %~header の`値$hdを付加する
</p>
【† ~trailerは `FETCH$r から<a href="https://github.com/whatwg/fetch/commit/b93383c877b1a359a46b08267f91ed599e2d487f">除去された</a>ので、この段は削除される必要がある。】
◎
For each header in response's trailer whose name is header name, append header's value to values.
</li>
			<li>
~IF［
%値~list は空でない
］
⇒
%~headerたち に
新たな~prop( 名前 %~header名, 値 %値~list )
を追加する
◎
Add a new property to headers whose name is header name and whose value is values.
</li>
		</ol>
	</li>
	<li>
~RET %~headerたち
◎
Return headers.
</li>
</ol>

		</section>
		<section id="generate-a-network-error-report">
<h3 title="Generate a network error report">5.4. ~network~error報告の生成-法</h3>

<p>
この~algoは、所与の
( `~network要請$ %要請, その要請に対する`応答$ %応答 )
に対し，
合致している`~NEL施策$が在って指図されたならば
%要請 についての報告を生成して，
( 結果の報告, `~NEL施策$ )
組を返す
— 他の場合は ~NULL を返す：
◎
Given a network request (request) and its corresponding response (response), this algorithm generates a report about request if instructed to by any matching NEL policy, and returns the report and the NEL policy. Otherwise this algorithm returns null.
</p>

<ol>
	<li>
~IF［
`生成元は信用に価し得るか？$( %要請 の`生成元$ ) ~EQ `価しない^i
］
⇒
~RET
◎
If the result of executing the "Is origin potentially trustworthy?" algorithm on request's origin is not Potentially Trustworthy, abort these steps.
</li>
	<li>
%生成元 ~LET %要請 の`生成元$
◎
Let origin be request's origin.
</li>
	<li>
%施策 ~LET `生成元~用の施策を選ぶ$( %生成元 )
◎
Let policy be the result of executing § 5.1 Choose a policy for an origin on origin.＼
</li>
	<li>
~IF［
%施策 ~EQ ε
］
⇒
~RET ~NULL
◎
If policy is no policy, return null.
</li>

	<li>
%見本抽出率 ~LET ［
%要請 は`成功した$ならば %施策 の`成功~時の見本抽出率$ ／
%要請 は`失敗した$ならば %施策 の`失敗~時の見本抽出率$
］
◎
Determine the active sampling rate for this request:
• If request succeeded, let sampling rate be policy's successful sampling rate.
• If request failed, let sampling rate be policy's failure sampling rate.
</li>
	<li>
%賽 ~LET 0.0 以上 1.0 以下の~randomな実数（この要請を報告するかどうか裁定する）
◎
Decide whether or not to report on this request. Let roll be a random number between 0.0 and 1.0, inclusive.＼
</li>
	<li>
~IF［
%賽 ~GTE %見本抽出率
］
⇒
~RET ~NULL
◎
If roll ≥ sampling rate, return null.
</li>
	<li>
<p>
%報告~本体 ~LET 次の~propを伴う，新たな~ES~obj `ECMA-262$r 
：
◎
Let report body be a new ECMAScript object with the following properties: [ECMA-262]
</p>
		<dl>
			<dt>`referrer^c</dt>
			<dd>
%要請 の`~client$rqに結付けられている`~referrer施策$により決定される，
%要請 の~referrer
◎
request's referrer, as determined by the referrer policy associated with its client.
</dd>
			<dd class="trans-note">【
~clientの`施策~容器$enVの`~referrer施策$pC ／
<a href="~REFERRER-POLICY#determine-requests-referrer">要請の~referrerを決定する~algo</a> ／
<a href="~FETCH#concept-request-referrer">要請の~referrer</a>
】</dd>

			<dt>`sampling_fraction^c</dt>
			<dd>
%見本抽出率
◎
sampling rate
</dd>

			<dt>`server_ip^c</dt>
			<dd>
<p>
~UAが %要請 を送信した先の`~server$の~IP~address
— 可用でなければ、空~文字列
◎
The IP address of the server to which the user agent sent the request, if available. Otherwise, an empty string.
</p>
				<ul>
					<li>
~IPv4~addressで識別される~hostは、［
範囲 0 〜 255 の 4 個の 10 進~数を "." で分離した並び
］（ `dotted-decimal^en 表記法）
`RFC1123$r で表現される。
◎
A host identified by an IPv4 address is represented in dotted-decimal notation (a sequence of four decimal numbers in the range 0 to 255, separated by "."). [RFC1123]
</li>
	<li>
~IPv6~addressで識別される~hostは、順序付けられた
8 個の 16-bit 片が成す~list （ `x:x:x:x:x:x:x:x^c の~~形による並び）として表現される
— ここで、各 "x" は、 16-bit 片を表す［
1 〜 4 個の 16 進数字
］からなる）
`RFC4291$r
◎
A host identified by an IPv6 address is represented as an ordered list of eight 16-bit pieces (a sequence of `x:x:x:x:x:x:x:x`, where the 'x's are one to four hexadecimal digits of the eight 16-bit pieces of the address). [RFC4291]
</li>
				</ul>
			</dd>

			<dt>`protocol^c</dt>
			<dd>
当の資源を~fetchするときに利用した
<abbr title="Application Layer Protocol Negotiation">ALPN</abbr> Protocol ID
により識別される
<a href="~RESOURCE-TIMING#dom-performanceresourcetiming-nexthopprotocol">~network~protocol</a>
— 可用でなければ、空~文字列。
◎
The network protocol used to fetch the resource as identified by the ALPN Protocol ID, if available. Otherwise, "".
</dd>

			<dt>`method^c</dt>
			<dd>
%要請 の`要請~method$
◎
request's request method.
</dd>

			<dt>`request_headers^c</dt>
			<dd>
`要請~headerたちを抽出する$( %要請, %施策 )
◎
The result of executing 5.2 Extract request headers on request and policy.
</dd>

			<dt>`response_headers^c</dt>
			<dd>
`応答~headerたちを抽出する$( %応答, %施策 )
◎
The result of executing 5.3 Extract response headers on response and policy.
</dd>

			<dt>`status_code^c</dt>
			<dd>
~HTTP応答の`状態s~code$
— 可用でなければ、 0 。
【したがって、可用なときも~data型は（文字列ではなく） `Number^jt になるであろう】
◎
The status code of the HTTP response, if available. Otherwise, 0.
</dd>

			<dt>`elapsed_time^c</dt>
			<dd>
~UAが［
当の資源~fetchを開始してから，完了したか中止したとき
］までに経過した~milli秒数
◎
The elapsed number of milliseconds between the start of the resource fetch and when it was completed or aborted by the user agent.
</dd>

			<dt>`phase^c</dt>
			<dd>
%要請 は`失敗した$ならば その`~network~error$の`相$nE ／
%要請 は`成功した$ならば `application^l
◎
If request failed, the phase of its network error. If request succeeded, "application".
</dd>

			<dt>`type^c</dt>
			<dd>
%要請 は`失敗した$ならば その`~network~error$の`種別$nE ／
%要請 は`成功した$ならば `ok^l
◎
If request failed, the type of its network error. If request succeeded, "ok".
</dd>
		</dl>
	</li>
	<li>
<p>
~IF［
%報告~本体 の `phase^c ~prop ~NEQ `dns^l
］~AND［
%報告~本体 の `server_ip^c ~prop ~NIN { 空~文字列, %施策 の`受信した~IP~address$nP }
］：
◎
If report body's phase property is not dns, and report body's server_ip property is non-empty and not equal to policy's received IP address:
</p>
		<ol>
			<li>
%報告~本体 の `phase^c ~SET `dns^l
◎
Set report body's phase to dns.
</li>
			<li>
%報告~本体 の `type^c ~SET `dns.address_changed^l
◎
Set report body's type to dns.address_changed.
</li>
			<li>
%報告~本体 の次に挙げる~propを~clearする
⇒＃
`request_headers^c,
`response_headers^c,
`status_code^c,
`elapsed_time^c
◎
Clear report body's request_headers, response_headers, status_code, and elapsed_time properties.
</li>
			<li>
~Assert：
`~DNS解決$の間に可用でない情報から導出された %報告~本体 内の~fieldは、すべて~clearされている。
◎
Assert: All fields in report body that are derived from information not available during DNS resolution have been cleared.
</li>
		</ol>

<p class="note">注記：
この段は、`~server$の~IP~addressと`~NEL施策$ %施策 が合致しない場合に，~NEL報告を “降格する” 。
これは、［
~NEL報告は，それが述べる［
~serviceの所有者
］のみに送信される
］ことを確保するための，~privacy保護である。
~IP~addressが合致しない場合、~UAは［
%施策 が`生成元$の`~domain名$の所有者により送信されたか
］だけを検証yでき，［
%施策 は［
この`~domain名$を解決して得られた`~server$
］の所有者から送信された
］かは検証yできない。
したがって、`~DNS解決$についての情報のみ包含するよう，報告を降格する。
より詳細は、
<a href="#privacy-considerations">§ ~privacy考慮点</a>,
<a href="#origins-with-multiple-ip-addresses">§ 複数の~IP~addressを伴う生成元</a>
を見よ。
◎
Note
This step "downgrades" a NEL report if the IP addresses of the server and the policy don't match. This is a privacy protection, ensuring that NEL reports are only sent to the owner of the service that the report describes. If the IP addresses don't match, then the user agent can only verify that the NEL policy was sent by the owner of the origin's domain name; it cannot verify that the policy was sent by the owner of the server this domain name resolves to. We therefore downgrade the report to only contain information about DNS resolution. See 9. Privacy Considerations and 7.4 Origins with multiple IP addresses for more details.
</p>
	</li>
	<li>
~IF［
( %生成元, %施策 の`生成元$nP )
<!-- ＊is not equal to → not same-origin
https://github.com/w3c/network-error-logging/commit/56fdd4c985fc62ec8d41d912ffa3dd7193de0a3b#diff-eacf331f0ffc35d4b482f1d15a887d3b
-->
は`同一-生成元$でない
］~AND［
%施策 の`下位domainを含むか$nP ~EQ ~T
］~AND［
%報告~本体 の `phase^c ~prop ~NEQ `dns^l
］
⇒
~RET ~NULL
◎
If origin is not equal to policy's origin, policy's subdomains flag is include, and report body's phase property is not dns, return null.
</li>
	<li>
~RET ( %報告~本体, %施策 )
◎
Return report body and policy.
</li>
</ol>

		</section>
		<section id="deliver-a-network-report">
<h2 title="Deliver a network report">5.5. ~network報告を送達する</h2>

<p>
この~algoは、所与の
( ~ES~obj %報告~本体, `~NEL施策$ %施策, `~network要請$ %要請 )
に対し，報告を送達~用に~queueする（通例的に、
%報告~本体 は［
<a href="#generate-a-network-error-report">~network~error報告を生成する</a>
~algoから返され，これを~callしている仕様により増補されたもの
］であり， %施策 は その~algoにて %要請 に合致したものである）：
◎
Given a ECMAScript object (report body, usually returned from Generate a network error report and then augmented by the calling specification) and its matching NEL policy (policy) and network request (request), this algorithm queues the report for delivery.
</p>

<ol>
	<li>
`報告を~queueする$(
%報告~本体,
`network-error^l,
%施策 の`報告用~group$nP,
%要請 の`環境~設定群~obj$【 %要請 の`~client$rq？】,
%要請 の~URL
)
`REPORTING$r
◎
Queue the report for delivery via the Reporting API. [REPORTING]
◎
type
• network-error
data
• report body
endpoint group
• policy's reporting group
settings
• request's environment settings object
url
• request's URL
</li>
</ol>

		</section>
	</section>
	<section id="predefined-network-error-types">
<h2 title="Predefined network error types">6. 定義済み~network~error種別</h2>

<p>
`~network~error$の`種別$nEには、定義済みなものがいくつかある。
◎
There are several predefined network error types.
</p>

<p>
~UAは、以下の~listを~custom`~network~error$`種別$nEで拡張してもヨイ
— 例：新たな~protocolに適応するため／既存のものをより詳細に記述するためなど。
そうする場合、~error報告の単純かつ一貫した処理を手助けするため、~UAは，`種別$nE名は~dotで区切られる~pattern（
<code>`[group]^v.`[optional-subgroup]^v.`[error-name]^v</code>
）に従うべきである
— 例えば，【報告の】収集器が供する集約は、~categoryごとに, あるいは いくつかの下位groupに~~分別されてよい。
◎
The user agent MAY extend this list with custom network error types — e.g. to accommodate new protocols, or more detailed error descriptions of existing ones. When doing so, the user agent SHOULD follow the dot-delimited pattern ([group].[optional-subgroup].[error-name]) for the type names to facilitate simple and consistent processing of the error reports — e.g. the collector may provide aggregation by category and/or one or multiple subgroups.
</p>

		<section id="dns-resolution-errors">
<h3 title="DNS resolution errors">6.1. ~DNS解決~error</h3>

<p>
この節に挙げるすべての`~network~error$は、`~DNS解決$の間に生じるので，その`相$nEは `dns^l になる。
◎
All of the network errors in this section occur during DNS resolution, and therefore have a phase of dns.
</p>


<dl class="reportTypeGroup">
	<dt>`dns.unreachable^l</dt>
	<dd>
~DNS~serverに到達-不能。
◎
DNS server is unreachable
</dd>

	<dt>`dns.name_not_resolved^l</dt>
	<dd>
~DNS~serverは応答してきたが，~addressは解決できなかった。
◎
DNS server responded but is unable to resolve the address
</dd>

	<dt>`dns.failed^l</dt>
	<dd>
上の各項に挙げた~errorに因る事由を除く，
~DNS~serverへの要請に際しての失敗。
◎
Request to the DNS server failed due to reasons not covered by previous errors
</dd>

	<dt>`dns.address_changed^l</dt>
	<dd>
要請の`生成元$用に解決された~IP~addressは、対応する`~NEL施策$を受信したときから変化したことを
指示する。
◎
Indicates that the resolved IP address for a request's origin has changed since the corresponding NEL policy was received
</dd>
</dl>

		</section>
		<section id="secure-connection-establishment-errors">
<h3 title="Secure connection establishment errors">6.2. ~secure接続~確立の~error</h3>

<p>
この節に挙げるすべての`~network~error$は、`~secure接続の確立$の間に生じるので，その`相$nEは `connection^l になる。
◎
All of the network errors in this section occur during secure connection establishment, and therefore have a phase of connection.
</p>


<dl class="reportTypeGroup">
	<dt>`tcp.timed_out^l</dt>
	<dd>
~serverへの~TCP接続が時間切れになった。
◎
TCP connection to the server timed out
</dd>

	<dt>`tcp.closed^l</dt>
	<dd>
~TCP接続が~serverにより~closeされた。
◎
The TCP connection was closed by the server
</dd>

	<dt>`tcp.reset^l</dt>
	<dd>
~TCP接続が再設定された。
◎
The TCP connection was reset
</dd>

	<dt>`tcp.refused^l</dt>
	<dd>
~TCP接続は
~serverにより拒否された。
◎
The TCP connection was refused by the server
</dd>

	<dt>`tcp.aborted^l</dt>
	<dd>
~TCP接続は中止された。
◎
The TCP connection was aborted
</dd>

	<dt>`tcp.address_invalid^l</dt>
	<dd>
無効な~IP~address。
◎
The IP address is invalid
</dd>

	<dt>`tcp.address_unreachable^l</dt>
	<dd>
~IP~addressに到達-不能。
◎
The IP address is unreachable
</dd>

	<dt>`tcp.failed^l</dt>
	<dd>
上の各項に挙げた~errorによるもの以外の事由に因り，
~TCP接続に失敗した。
◎
The TCP connection failed due to reasons not covered by previous errors
</dd>
</dl>

<dl class="reportTypeGroup">
	<dt>`tls.version_or_cipher_mismatch^l</dt>
	<dd>
~versionまたは暗号の不一致に因り，
~TLS接続は中止された。
◎
The TLS connection was aborted due to version or cipher mismatch
</dd>

	<dt>`tls.bad_client_auth_cert^l</dt>
	<dd>
無効な~client証明書に因り，
~TLS接続は中止された。
◎
The TLS connection was aborted due to invalid client certificate
</dd>

	<dt>`tls.cert.name_invalid^l</dt>
	<dd>
無効な名前に因り，
~TLS接続は中止された。
◎
The TLS connection was aborted due to invalid name
</dd>

	<dt>`tls.cert.date_invalid^l</dt>
	<dd>
無効な証明書~日付に因り，
~TLS接続は中止された。
◎
The TLS connection was aborted due to invalid certificate date
</dd>

	<dt>`tls.cert.authority_invalid^l</dt>
	<dd>
無効な発行~権限に因り，
~TLS接続は中止された。
◎
The TLS connection was aborted due to invalid issuing authority
</dd>

	<dt>`tls.cert.invalid^l</dt>
	<dd>
無効な証明書に因り，
~TLS接続は中止された。
◎
The TLS connection was aborted due to invalid certificate
</dd>

	<dt>`tls.cert.revoked^l</dt>
	<dd>
廃止された~server証明書に因り，
~TLS接続は中止された。
◎
The TLS connection was aborted due to revoked server certificate
</dd>

	<dt>`tls.cert.pinned_key_not_in_cert_chain^l</dt>
	<dd>
~key~pinning~errorに因り，
~TLS接続は中止された。
◎
The TLS connection was aborted due to a key pinning error
</dd>

	<dt>`tls.protocol.error^l</dt>
	<dd>
~TLS~protocol~errorに因り，
~TLS接続は中止された。
◎
The TLS connection was aborted due to a TLS protocol error
</dd>

	<dt>`tls.failed^l</dt>
	<dd>
上の各項に挙げた~errorによるもの以外の事由に因り，
~TLS接続に失敗した。
◎
The TLS connection failed due to reasons not covered by previous errors
</dd>
</dl>


		</section>
		<section id="transmission-of-request-and-response-errors">
<h3 title="Transmission of request and response errors">6.3. 要請／応答 ~errorの伝送</h3>

<p>
この節に挙げるすべての`~network~error$は、`要請と応答の伝送$の間に生じるので，その`相$nEは `application^l になる。
◎
All of the network errors in this section occur during the transmission of request and response, and therefore have a phase of application.
</p>

<dl class="reportTypeGroup">
	<dt>`http.error^l</dt>
	<dd>
~UAは応答を成功裡に受信したが，その状態s~codeは［
`4xx$st ／ `5xx$st
］であった。
◎
The user agent successfully received a response, but it had a 4xx or 5xx status code
</dd>

	<dt>`http.protocol.error^l</dt>
	<dd>
~HTTP~protocol~errorに因り，
接続は中止された。
◎
The connection was aborted due to an HTTP protocol error
</dd>

	<dt>`http.response.invalid^l</dt>
	<dd>
応答【の`内容$】が空である ／
`Content-Length$h に不一致がある ／
符号化法【`内容~符号法$】が適正でない ／
~UAが応答を処理できなくさせるような他の条態。
◎
Response is empty, has a content-length mismatch, has improper encoding, and/or other conditions that prevent user agent from processing the response
</dd>

	<dt>`http.response.redirect_loop^l</dt>
	<dd>
~redirect~loopが検出されたことに因り，
要請は中止された。
◎
The request was aborted due to a detected redirect loop
</dd>

	<dt>`http.failed^l</dt>
	<dd>
上の各項に挙げた~HTTP~protocolにおける~errorに因るもの以外の事由に因り，
接続に失敗した。
◎
The connection failed due to errors in HTTP protocol not covered by previous errors
</dd>
</dl>


<dl class="reportTypeGroup">

	<dt>`abandoned^l</dt>
	<dd>
利用者が，資源~fetchを完了する前に中止した。
◎
User aborted the resource fetch before it is complete
</dd>

	<dt>`unknown^l</dt>
	<dd>
未知な~error種別。
◎
error type is unknown
</dd>
</dl>


		</section>
	</section>
	<section id="examples">
<h2 title="Examples">7. 例</h2>

		<section id="sample-policy-definitions">
<h3 title="Sample Policy Definitions">7.1. 施策~定義の見本</h3>

<p class="trans-note">【
以下に示される~code内の行頭に現れる［
"&gt;" ／ "&lt;"
］は、［
要請／応答
］の~dataを表す（それらの文字~自体は~dataの一部を成さない）。
それぞれ，以降に連なる［
"&gt;" ／ "&lt;"
］が無い行とともに “単独の行” を成す（それらの中の改行は、見易くするための整形）。
】【
以下に現れる
`Report-To@h
~headerは， `REPORTING$r に定義されていたが、その仕様の更新により
`Reporting-Endpoints$h ~headerに取って代わられ，その値も異なるものをとる。
】</p>

<div class="example">

<pre class="lang-http">
&gt; GET / HTTP/1.1
&gt; Host: example.com

&lt; HTTP/1.1 200 OK
&lt; ...
&lt; `Report-To$h: {
    "group": "network-errors",
    "max_age": 2592000,
    "endpoints": [{"url": "https://example.com/upload-reports"}]
}
&lt; `NEL$h: {
    "report_to": "network-errors",
    "max_age": 2592000
}
</pre>

<p>
この `NEL^h ~headerが定義する`~NEL施策$は、［
`example.com^s についての~network~errorを，名前 `network-errors^l の`報告先~group$に報告する
］よう，~UAに指図する。
この施策は 2592000 秒間（ 30 日間）適用される。
◎
This NEL header defines a NEL policy, instructing the user agent to report network errors about example.com to the endpoint group named network-errors. The policy applies for 2592000 seconds (30 days).
</p>

<p>
上の登録は、当の応答が`信用に価し得る生成元$から通信された場合に限り成功することに注意。
◎
Note that above registration will only succeed if the response is communicated from a potentially trustworthy origin.
</p>

</div>

<div class="example">

<pre class="lang-http">
&gt; GET / HTTP/1.1
&gt; Host: example.com

&lt; HTTP/1.1 200 OK
&lt; ...
&lt; `NEL$h: {"max_age": 0}
</pre>

<p>
この `NEL^h ~headerは、［
`example.com^s 用の`~NEL施策$が存在するならば，それを除去する
］よう，~UAに指図する。
◎
This NEL header instructs the user agent to remove any existing NEL policy for example.com.
</p>

</div>

		</section>
		<section id="sample-network-error-reports">
<h3 title="Sample Network Error Reports">7.2. ~network~error報告の見本</h3>

<p>
この節では、~UAが［
`~NEL施策$が登録されている`生成元$に対し，~network~errorに遭遇した
］ときに~queueし得る，`~network~error$`報告$の例を示す。
ここでは、報告を~uploadするとき `REPORTING$r ~APIにより作成される全部的な報告~payloadを示す。
~payloadの `body^c ~fieldが`~network~error$の報告~本体を包含する。
◎
This section contains example network error reports the user agent might queue when a network error is encountered for an origin with a registered NEL policy. We show the full report payload that would be created by the [REPORTING] API when uploading the report; the payload's body field contains the network error report body.
</p>

<p class="trans-note">【
他の~fieldに関する記述は、 `REPORTING$r の
<a href="~REPORTING#try-delivery">報告先へ報告を送達する手続き</a>
にある。
】</p>

<div class="example">

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://www.example.com/",
  "body": {
    "sampling_fraction": 0.5,
    "referrer": "http://example.com/",
    "server_ip": "2001:DB8:0:0:0:0:0:42",
    "protocol": "h2",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 200,
    "elapsed_time": 823,
    "phase": "application",
    "type": "http.protocol.error"
  }
}
</pre>

<div class="p">
<p>
上の報告は、~UAが次を行ったことを指示する：
</p>

<ol>
	<li>
`example.com^s
から
`www.example.com^s
へ~navigateしようと試みて、
</li>
	<li>
その~IP~addressは
`2001:DB8::42^s
に成功裡に解決され、
</li>
	<li>
HTTP/2（ `h2^s ）~protocolを介して~serverから `200$st 応答を受信したが、
</li>
	<li>
交換に際し~protocol~errorに遭遇したため（ `http.protocol.error^l ），~naviを放棄するよう強いられた。
</li>
	<li>
~naviを開始してから中止するまで， 823 ~milli秒 経過し、
</li>
	<li>
最後に，この報告を~network~errorに遭遇した直後に送信した
— すなわち、報告~ageは 0
</li>
</ol>

◎
This report indicates that the user agent attempted to navigate from example.com to www.example.com, which successfully resolved to 123.122.121.120. However, while the user agent received a 200 response from the server via the HTTP/2 (h2) protocol, it encountered a protocol error in the exchange and was forced to abandon the navigation. The user agent aborted the navigation 823 milliseconds after it started. Finally, the user agent sent this report immediately after the network error was encountered – i.e. the report age is 0.
</div>

</div>

<div class="example">

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://widget.com/thing.js",
  "body": {
    "sampling_fraction": 1.0,
    "referrer": "https://www.example.com/",
    "server_ip": "",
    "protocol": "",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 0,
    "elapsed_time": 143,
    "phase": "dns",
    "type": "dns.name_not_resolved"
  }
}
</pre>

<div class="p">
<p>
上の報告は、~UAが次を行ったことを指示する：
</p>
<ol>
	<li>
`https://www.example.com/^s から `https://widget.com/thing.js^s を~fetchしようと試みたが、
</li>
	<li>
~DNS名（ `widget.com^s ）を解決できなかったため、 143 ~milli秒後に要請を中止した。
</li>
	<li>
`widget.com^s への以前の要請は 妥当な`~NEL施策$を送達したので、この要請~用に`~network~error$`報告$を生成した。
</li>
	<li>
その報告は`~network~error$に遭遇した直後に~uploadされた
— すなわち、報告~ageは 0
</li>
</ol>
◎
The above report indicates that the user agent attempted to fetch https://widget.com/thing.js from https://www.example.com/. However, the user agent was unable to resolve the DNS name (widget.com) and the request was aborted by the user agent after 143 milliseconds. Because a previous request to widget.com delivered a valid NEL policy, the user agent generates a network error report for this request. The report was uploaded immediately after the network error was encountered – i.e. the report age is 0.
</div>

</div>

		</section>
		<section id="dns-misconfiguration">
<h3 title="DNS misconfiguration">7.3. ~DNS環境設定の誤り</h3>

<div class="example">

<pre class="lang-http">
&gt; GET / HTTP/1.1
&gt; Host: example.com

&lt; HTTP/1.1 200 OK
&lt; ...
&lt; `Report-To$h: {
    "group": "network-errors",
    "max_age": 2592000,
    "endpoints": [{"url": "https://example.com/upload-reports"}]
}
&lt; `NEL$h: {
    "report_to": "network-errors",
    "max_age": 2592000,
    "include_subdomains": true
}
</pre>

<p>
この `NEL^h ~headerは、~DNS~serverの環境設定を誤ったとき，それを検出することを `example.com^s の所有者に許容する
— 一例として,
`new-subdomain.example.com^s を~IP~addressに解決するための新たな資源~recordを追加し忘れたときなど。
~UAは、 `new-subdomain.example.com^s への要請を為そうと試行した場合，次のような報告を生成することになろう：
◎
This NEL header allows the owner of example.com to detect when they have misconfigured their DNS servers — for instance, when they have forgotten to add a new resource record resolving new-subdomain.example.com to an IP address. If a user agent tries to make a request to new-subdomain.example.com, it might generate the following report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://new-subdomain.example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 0,
    "elapsed_time": 48,
    "phase": "dns",
    "type": "dns.name_not_resolved"
  }
}
</pre>

</div>

		</section>

		<section id="monitoring-cache-validation">
<h3 title="Monitoring cache validation">7.4. ~cache検証の監視-法</h3>

<div class="example">

<pre class="lang-http">
&gt; GET / HTTP/1.1
&gt; Host: example.com

&lt; HTTP/1.1 200 OK
&lt; ...
&lt; Report-To: {"group": "network-errors", "max_age": 2592000,
              "endpoints": [{"url": "https://example.com/upload-reports"}]}
&lt; NEL: {"report_to": "network-errors", "max_age": 2592000, "success_fraction": 1.0,
        "request_headers": ["If-None-Match"], "response_headers": ["ETag"]}
&lt; ETag: 01234abcd
</pre>

<p>
この例では、 `example.com^s の所有者は，
`ETag$h 応答~headerを利用して~server上で~hostされる資源の各~versionを識別する。
~UAは、［
応答を受信した時点で，その資源のどの~versionが~client側に~cacheされているか
］を， `If-None-Match$h 要請~headerを利用して~serverに伝えれる。
それにより，~serverは、［
~clientの既存の複製が最新の場合には、資源の内容を生成して送信するのを避ける
］ことが可能になる。
◎
In this example, the owner of example.com uses ETag response headers to identify different versions of the resources hosted on the server. User agents can then use If-None-Match request headers to inform the server which version of a resource is presently cached client-side, allowing the server to avoid generating and sending the content of the resource if the client's existing copy is up to date.
</p>

<p>
この~domain用の［
`request_headers$c, `response_headers$c
］~fieldを `NEL^h ~header内に含めることにより、~browserは，~NEL報告~内に `If-None-Match$h 要請~headerの複製と自身がその要請~用に作成する `ETag$h 応答~headerを含めることになる。
それにより，~site所有者は、自身による~cache法~施策の実効性を追跡-可能になる。
◎
By including request_headers and response_headers fields in the NEL header for this domain, the browser will include a copy of the If-None-Match request header and ETag response header in any NEL report that it creates for that request, allowing the site owner to track the effectiveness of their caching policies.
</p>

<p>
上が与えられた下で、以下の順に生じる出来事を考える：
◎
Given the above, consider the following sequence of events:
</p>

<ol>
	<li>
<p>
~UAは `example.com^s へ向けて`要請$を送信して，`~server$から`応答$を成功裡に受信したとする
— それは、当の資源の~versionを指示している `ETag$h ~headerを伴う。
~UAは、次の~NEL報告を生成することになる：
◎
The user agent sends a request to example.com, and receives a successful response from the server, with an ETag header indicating the version of the resource. The user agent will generate the following NEL report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.1",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {
      "ETag": ["01234abcd"]
    },
    "status_code": 200,
    "elapsed_time": 1392,
    "phase": "application",
    "type": "ok"
  }
}
</pre>

	</li>
	<li>
<p>
いくばくか後，~UAは `example.com^s に向けて別の`要請$を送信する。
~UAの局所~cache内には、元の資源の複製がまだ在るので，その~versionを `If-None-Match$h 要請~header内に含める。
~serverは、この~versionを検査して，それがまだ在ることに気付いたので、
`304$st 応答を送信して，~UAに~cacheされている資源の複製は依然として有効であることを~UAに伝える。
~UAは、次の報告を生成することになる：
◎
Some time later, the user agent sends another request to example.com. The user agent still has a copy of the original resource in its local cache, and includes its version in a If-None-Match request header. The server checks this version, notices that it is still current, and sends a 304 response informing the user agent that its cached copy of the resource is still valid. The user agent will generate the following report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.1",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {
      "If-None-Match": ["01234abcd"]
    },
    "response_headers": {
      "ETag": ["01234abcd"]
    },
    "status_code": 304,
    "elapsed_time": 45,
    "phase": "application",
    "type": "ok"
  }
}
</pre>

	</li>
	<li>

<p>
しばらくして後、~UAは `example.com^s に向けて，また別の`要請$を送信する。
~UAの局所~cache内には同じ資源の複製がまだ在り、前の例と同じように
`If-None-Match$h 要請~header内に その~versionを含める。
しかしながら今回は、~serverは，資源に新たな~versionが可用であることに気付いたので、この資源の内容を生成し，新たな~versionを応答の `ETag$h 応答~header値~内に符号化した上で~clientに送信する。
~UAは、次の報告を生成することになる：
◎
Even later, the user agent sends yet another request to example.com. The user agent still has the same copy of the resource in its local cache, and includes its version in a If-None-Match request header, as in the previous example. However, this time the server notices that there is a new version of the resource available. It generates the content of this resource, and sends it to the client, with the new version encoded in a new ETag response header value. The user agent will generate the following report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.1",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {
      "If-None-Match": ["01234abcd"]
    },
    "response_headers": {
      "ETag": ["56789ef01"]
    },
    "status_code": 200,
    "elapsed_time": 935,
    "phase": "application",
    "type": "ok"
  }
}
</pre>

	</li>
</ol>

</div>

		</section>
		<section id="origins-with-multiple-ip-addresses">
<h3 title="Origins with multiple IP addresses">7.5. 複数の~IP~addressを伴う生成元</h3>


<p>
`生成元$のうち，その`~domain名$が複数の~IP~addressに解決されるものに対しては、~NELは，~error報告を “降格して” ~error~~要因について供する情報を減らすこともある
— ［
`生成元$の所有者が，`要請$を取扱っている`~server$の所有者と同じかどうか
］を検証yできない場合に。
◎
For origins whose domain name resolves to multiple IP addresses, NEL will sometimes "downgrade" an error report, providing less information about the cause of the error, since it cannot verify that the owner of the origin is the same as the owner of the server handling the request.
</p>

<div class="example">

<p>
例として、
`example.com^s は，互いに~IP~addressが異なる 3 つの`~server$で取扱われていて、その~serviceの所有者は
`example.com^s は［
`192.0.2.1^s ／ `192.0.2.2^s ／ `192.0.2.3^s
］に解決されるよう~DNSを環境設定していて、各~UAが それらの要請を これらの 3 つの~IP~addressに分散することに依拠していてるとする。
~serviceの所有者は、次の`~NEL施策$を送達するようにしたとする：
◎
As an example, assume that example.com is handled by three servers, each with a different IP address. The owner of the service configures DNS to resolve example.com to 192.0.2.1, 192.0.2.2, and 192.0.2.3, and relies on user agents to balance their requests across these three IP addresses. The service owner delivers the following NEL policy:
</p>

<pre class="lang-http">
&gt; GET / HTTP/1.1
&gt; Host: example.com

&lt; HTTP/1.1 200 OK
&lt; ...
&lt; `Report-To$h: {
    "group": "network-errors",
    "max_age": 2592000,
    "endpoints": [{"url": "https://example.com/upload-reports"}]
}
&lt; `NEL$h: {
    "report_to": "network-errors",
    "max_age": 2592000,
    "success_fraction": 1.0,
    "failure_fraction": 1.0
}
</pre>

<p>
上が与えられた下で、以下の順に生じる出来事を考える：
◎
Given the above, consider the following sequence of events:
</p>

<ol>
	<li>
<p>
~UAは、`要請$を `192.0.2.1^s に向けて送信して，`~server$から`応答$を成功裡に受信した。
この応答は，上の`~NEL施策$を含むので、~UAは，施策の`受信した~IP~address$nPを `192.0.2.1^s に設定する。
`受信した~IP~address$nPは`~server$の~IP~addressに合致するので（成功したどの要請も，そうなるはずである）、次の~NEL報告を生成する：
◎
The user agent sends a request to 192.0.2.1, and receives a successful response from the server. This response includes the above NEL policy, and the user agent sets the policy's received IP address to 192.0.2.1. Since the received IP address matches the server's IP address (which it must for any successful request), it generates the following NEL report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.1",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 200,
    "elapsed_time": 57,
    "phase": "application",
    "type": "ok"
  }
}
</pre>

	</li>
	<li>


<p>
~UAは、新たな`要請$を `192.0.2.2^s へ送信して，別の`応答$を成功裡に受信した。
この応答も同じ`~NEL施策$を含む。
~UAは、施策の`受信した~IP~address$nPを `192.0.2.2^s に更新する。
`受信した~IP~address$nPは，`~server$の~IP~addressに合致するので（成功したどの要請も，そうなるはずである）、次の~NEL報告を生成する：
◎
The user agent sends a new request to 192.0.2.2, and receives another successful response. This response also includes the NEL policy, and the user agent updates the policy's received IP address to 192.0.2.2. Since the received IP address matches the server's IP address (which it must for any successful request), it generates the following NEL report:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.2",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 200,
    "elapsed_time": 34,
    "phase": "application",
    "type": "ok"
  }
}
</pre>

	</li>
	<li>
<p>
~UAは、`要請$を `192.0.2.3^s へ送信しようと試行したが，~serverへの接続は確立できなかった。
~UAの`施策~cache$内には，依然として`~NEL施策$があるので、この施策を利用して，`失敗した$`~network要請$についての報告を
— その`種別$nEを `tcp.timed_out^l にして —
生成したい所だが…
当の施策の`受信した~IP~address$nP（ `192.0.2.2^s ）は，この`要請$を送信-元~の~IP~addressに合致しないため， `192.0.2.3^s にある~serverが実際に `example.com^s の所有者が所有しているか検証yできない。
したがって，~UAは、報告を `dns.address_changed^l に降格するモノトスル：
◎
The user agent then tries to send a request to 192.0.2.3, but isn't able to establish a connection to the server. The user agent still has the NEL policy in the policy cache, and would ideally use this policy to generate a tcp.timed_out report about the failed network request. However, the because policy's received IP address (192.0.2.2) doesn't match the IP address that this request was sent to, the user agent cannot verify that the server at 192.0.2.3 is actually owned by the owners of example.com. The user agent must therefore downgrade the report to dns.address_changed:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.3",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 0,
    "elapsed_time": 0,
    "phase": "dns",
    "type": "dns.address_changed"
  }
}
</pre>

	</li>
	<li>
<p>
~UAは、別の`要請$を `192.0.2.1^s へ送信しようと試行したが，またもや~serverへの接続は確立できなかった。
~UAは過去のある時点で `192.0.2.1^s から`~NEL施策$を受信していたとしても、施策の`受信した~IP~address$nPには，そこ【すなわち `https://example.com^s （から導出される生成元）】から`最も近過去^emに受信したそれ
— この事例では `192.0.2.2^s —
しか記録されない。
したがって，~UAは、報告を `dns.address_changed^l に降格するモノトスル：
◎
The user agent then tries to send another request to 192.0.2.1, but once again isn't able to establish a connection to the server. Even though the user agent received the NEL policy from 192.0.2.1 at some point in the past, the policy's received IP address only records where it was most recently received from — in this case, 192.0.2.2. The user agent must therefore downgrade the report to dns.address_changed:
</p>

<pre class="lang-json">
{
  "age": 0,
  "type": "network-error",
  "url": "https://example.com/",
  "body": {
    "sampling_fraction": 1.0,
    "server_ip": "192.0.2.1",
    "protocol": "http/1.1",
    "method": "GET",
    "request_headers": {},
    "response_headers": {},
    "status_code": 0,
    "elapsed_time": 0,
    "phase": "dns",
    "type": "dns.address_changed"
  }
}
</pre>
	</li>
</ol>

</div>


		</section>
	</section>
	<section id="use-cases">
<h2 title="Use cases">8. 利用事例</h2>

		<section id="reporting-of-navigation-failures">
<h4 title="Reporting of Navigation Failures">8.1. ~navi失敗~時の報告-法</h4>

<p>
利用者により起動される~navi要請（例：
~linkの~click ／
~location-barを介する直接的な入力 ／
利用者との対話に因り~scriptから起動されたもの ／
等々）は、いくつもの接続性の事由に因り失敗し得る
— ~DNSにおける失敗, ~TCP~error, ~TLS~protocol違反, 等々。
これらの~errorは、［
~network環境設定の誤り,
一過性の~routingの問題i,
~serverの~downtime,
~malware,
利用者に対する他の攻撃,
等々
］により~~生じ得る。
◎
A navigation request initiated by the user (e.g. via a click on a link, direct input via the location bar, script-initiated due to user interaction, etc.) may fail due any number of connectivity reasons: DNS failure, TCP error, TLS protocol violation, and so on. These errors may be caused by network misconfiguration, transient routing issues, server downtime, malware or other attacks against the user, etc.
</p>

<p>
そのような事例では、行先の~hostは，失敗した~naviに気付かないままになることが多い
— 定義により、要請が~hostの基盤まで到達したかどうかを見れず，問題を究明できないので。
これに取組むため、~hostは，［
そのような究明できない失敗~報告を どこへ送達するべきかを指定する，`~NEL施策$
］を~UAに登録できる。
◎
In such cases the destination host is often left unaware of the failed navigation since, by definition, it cannot see the request reach its infrastructure and it is unable to investigate the problem. To address this, the host can register an NEL policy with the user agent, which specifies where reports of such failures should be delivered such that they can be investigated.
</p>

		</section>
		<section id="reporting-of-first-party-subresource-fetch-failures">
<h3 title="Reporting of First-party Subresource Fetch Failures">8.2. 当事者-主体に属する下位資源に対する~fetch失敗~時の報告-法</h3>

<p>
典型的な~appは、数多くの資源を要求する。
その~fetchingは、概して［
HTML／CSS／JavaScript
］を介して起動される。
そのような資源を要請している~appは、大概は，その~fetchの失敗を観測できるが（例えば、 `onerror^c ~callbackを介して）、失敗がなぜ生じたかについての，詳細な~network~error報告
— 例： ~DNS失敗, ~TCP~error, ~TLS~protocol違反, 等々 —
には~accessできない。
◎
A typical application requires dozens of resources, the fetching of which is typically initiated via HTML, CSS, or JavaScript. The application requesting such resources can observe failures of most such fetches (e.g. via `onerror` callbacks), but it does not have access to the detailed network error report of why the failure has occurred - e.g. DNS failure, TCP error, TLS protocol violation, etc.
</p>

<p>
これに取組むため、~appは，［
~fetch中にある下位資源が属する当事者-主体~host用の，関連な`~NEL施策$
］を~UAに登録できる。
そのような`~NEL施策$が在る下では、
それが登録された`生成元$からの資源に対し~network~errorに遭遇した場合，~UAは詳細な~network~error報告を報告することを可能化することになり、~app開発者は，~errorについて究明できるようになる。
◎
To address this, the application can register relevant NEL policies with the user agent for the first-party hosts from which the subresources are being fetched. Then, if such a policy is present and a network error is encountered for a resource from an origin with a registered NEL policy, the user agent will report the detailed network error report and enable the application developers to investigate the error.
</p>

		</section>
		<section id="reporting-of-third-party-subresource-fetch-failures">
<h3 title="Reporting of Third-party Subresource Fetch Failures">8.3. 第三者-主体に属する下位資源に対する~fetch失敗~時の報告-法</h3>

<p>
資源が第三者-主体により埋込まれている事例では、資源を供する側は、失敗を［
計測できない／観測できない
］ことが多い。
`example.com^s が 自身の~siteに資源
`widget.com/thing.js^s を埋込んでいて，
`example.com^s
を訪問している利用者が，~network~errorに因りそのような資源の~fetchに失敗した場合、~host
`widget.com^s
は、失敗に気付くことも，それを検出することもできない。
◎
In the case where a resource is embedded by a third party, the provider of the resource is often unable to instrument and observe the failure. For example, if `example.com` embeds a `widget.com/thing.js` resource on its site, and the user visiting `example.com` fails to fetch such resource due to a network error, the `widget.com` host is both unaware of the failure and unable to detect it.
</p>

<p>
`widget.com^s は、これに取組むため，自身の~host用に`~NEL施策$を登録できる。
そのような施策が在る下で，それが登録された`生成元$から資源を~fetchする際に~network~errorに遭遇した場合
— 当事者-主体, 第三者-主体どちらの生成元から要請されたかを問わず —
~UAは~network~errorを報告することになり，資源を供する側は~errorを究明-可能になる。
◎
To address this, `widget.com` can register an NEL policy for its host. Then, if such policy is present and a network error is encountered while fetching a resource — regardless of whether it is being requested from a first-party or third-party origin — from the origin with a registered NEL policy, the user agent will report the network error and enable the provider to investigate the error.
</p>

		</section>
	</section>
	<section id="privacy-considerations">
<h2 title="Privacy Considerations">9. ~privacy上の考慮点</h2>

<p>
~NELは、［
利用者の~network環境設定についての新たな情報
］も公開し得るような，~network~error報告を供する。
例えば，攻撃者は、［
利用者の~network環境設定を探査したり，利用者の内部~network上の~serverを~scanする
］ために~NEL報告-法を濫用することもできる。
また，［
HSTS, HPKP, ~pinned CSP 施策
］と類似に、格納される`~NEL施策$は，［
（利用者ごとに異なる）~customな報告~先~URLを伴う，別個な施策を設定する
］ことにより［
~HTTP~cookieとの組合nで（または それに代わる），識別子として動作するような “`supercookie^en”
］にも利用できる。
◎
NEL provides network error reports that could expose new information about the user's network configuration. For example, an attacker could abuse NEL reporting to probe the user's network configuration, or to scan for servers on the user's internal network. Also, similar to HSTS, HPKP, and pinned CSP policies, the stored NEL policy could be used as a "supercookie" by setting a distinct policy with a custom (per-user) reporting URI to act as an identifier in combination with (or instead of) HTTP cookies.
</p>

<p>
上述の~riskの一部を軽減するため、~NEL登録は，`信用に価し得る生成元$に制約され、~network~error報告の送達も，同様に`信用に価し得る生成元$に制約される。
これは、~NELを持続的な追跡器として自明に濫用するような，
一過性の~HTTP MITM† を許容しないようにする。
【MIIM — `Man In The Middle^en — 中間者（攻撃）】
◎
To mitigate some of the above risks, NEL registration is restricted to potentially trustworthy origins, and delivery of network error reports is similarly restricted to potentially trustworthy origins. This disallows a transient HTTP MITM from trivially abusing NEL as a persistent tracker.
</p>

<p>
~NELは、既存の~server側~監視を増補することが意図されている。
~NEL報告が送信される先は、要請している~serviceの所有者に限られるべきである。
`~DNS解決$の間に生じた~errorに対しては、~NEL報告は［
`~NEL施策$が［
`施策~生成元$nPを包含する`~domain名前空間~tree$
］の所有者から受信されたとき
］に限り生成される。
［
`~secure接続の確立$ ／ `要請と応答の伝送$
］の間に生じた~errorに対しては、~NEL報告は［
`要請$を送信した先の`~server$の所有者から`~NEL施策$が受信されたとき
］に限り生成される。
◎
NEL is intended to augment existing server-side monitoring. NEL reports should only be sent to the owner of the service being requested. For errors that occur during DNS resolution, NEL reports are only generated when the NEL policy was received from the owner of the domain namespace tree that contains the policy origin. For errors that occur during secure connection establishment or transmission of request and response, NEL reports are only generated when the NEL policy was received from the owner of the server that the request was sent to.
</p>

<p>
以下では、`~NEL施策$の［
`受信した~IP~address$nP ／ `下位domainを含むか$nP
］の扱いを説明する。
［
施策の`受信した~IP~address$nPが`~server$の~IP~addressに合致するか検査する
］ことにより、~NELは，施策の信用-境界を［
施策の`施策~生成元$nPのみならず，~UAが通信している特定の~serverも含む
］ように拡張する。
この検査は、（一例として） `DNS rebinding^en【 ~domain名を別の~IP~addressに “束縛し直す” 】攻撃を防ぐためにある：
そこでは，攻撃者は、自身が所有する ある~serverから長生きする`~NEL施策$を送達した上で，その名前~server（ `name server^en ）を［
`施策~生成元$nPを，自身が制御しない別の~serverに解決する
］ように変更する。
`受信した~IP~address$nPを検証yしなかった場合、~UAは，別の~serverについての報告を攻撃者へ送信させられることになる。
◎
This rationale explains the treatment of the received IP address and subdomains flag of a NEL policy. By checking that the policy's received IP address matches the IP address of the server, NEL extends the trust boundary of the policy to include not just the policy's origin, but also the specific server that the user agent is communicating with. This helps prevent (for instance) DNS rebinding attacks, where an attacker delivers a long-lived NEL policy from a server that they own, and then changes their name servers to resolve the policy origin to a server they don't control. Without the received IP address verification, this would cause user agents to send reports about the second server to the attacker.
</p>

<p>
同様に，`~NEL施策$のうち［
`下位domainを含むか$nP ~EQ ~T
］なるものは、［
`要請$の`~DNS解決$の間に，`施策~生成元$nPの下位domainについての報告を生成するとき
］に限り利用できるよう制限される。
この`相$の間は、~errorの所有者が誰なのか検証yするための`要請$は無い
— それを確立するには［
当の施策が `要請$の`生成元$の上位domainから受信された事実
］だけで十分になる。
これは、`~domain名前空間~tree$の特定0の部位の所有者に［
~NELを利用して，<a href="#dns-misconfiguration">~DNS環境設定の誤り</a>を検出する
］ことを許容する一方で、所有者が［
自身が制御しない~serverについての情報を，悪意的な~DNS~entryを利用して収集する
］のは防ぐ。
◎
Similarly, subdomain NEL policies are limited, and can only be used to generate reports about subdomains of the policy origin during the DNS resolution phase of a request. During this phase, there is no server to verify ownership of, and the fact that the policy was received from a superdomain of the request's origin is enough to establish ownership of the error. This allows the owners of a particular portion of the domain namespace tree to use NEL to detect 7.3 DNS misconfiguration errors, while preventing them from using malicious DNS entries to collect information about servers they don't control.
</p>

<p>
情報~漏洩eを防ぐため、`要請$についての~NEL報告は，［
`要請$を処理するときに，`~server$からは可視でない情報
］は包含しない。
`~DNS解決$の間の~errorに対しては、~NEL報告は，~DNS自身から可用な情報のみを包含する。
これは、`~server$が，~NELを濫用して［
利用者についてすでに~accessを有しているもの
］を超える情報を収集するのを防ぐ。
◎
To prevent information leakage, NEL reports about a request do not contain any information that is not visible to the server when processing the request. For errors during DNS resolution, a NEL report only contains information available from DNS itself. This prevents servers from abusing NEL to collect more information about their users than they already have access to.
</p>

<p class="note">注記：
例として，~NEL報告は、［
`要請$の`~domain名$を~IP~addressに解決するときに，どの`~DNS解決器$が利用されたか
］についての情報は，特定的に包含しない。
◎
Note
As an example, NEL reports specifically do not contain any information about which DNS resolver was used to resolve a request's domain name into an IP address.
</p>

<p>
上の制約に加えて、~UAは，次に従うモノトスル：
◎
In addition to above restrictions, the user agents MUST:
</p>

<ul>
	<li>
利用者が自身の閲覧~data（ ~cookie, ~site~data, 履歴, 等々）を~clearしたときは、格納-済み`~NEL施策$も~clearする。
◎
Clear the stored NEL policies when the user clears their browsing data (cookies, site data, history, etc).
</li>
	<li>
~network~error報告を送達するときは、
`Set-Cookie$h 応答~headerを処理するのを拒否する。
◎
Refuse to process Set-Cookie response headers when delivering network error reports.
</li>
</ul>

<p>
開発者は、~NELを配備するときには，指定した収集器に~NEL報告を送達することによる~privacyへの影響nを考慮するべきである。
例えば，報告は、特別な予防策が必要な，敏感な~dataを伴う~URL（例： “能力~URL（ `Capability URLs^en ）” ）を包含することもあり（ `CAPABILITY-URLS$r を見よ）、開発者には，［
自前の~NEL収集器を，そのような~URLが第三者-主体へ報告されるのを防ぐように運用する
］ことが要求され得る。
◎
When deploying NEL the developer SHOULD consider privacy implications of NEL reports delivered to the specified collectors. For example, reports may contain URLs with sensitive data (e.g. "Capability URLs") that may need special precautions (see [CAPABILITY-URLS]), and may require the developer to operate their own NEL collectors to prevent reporting of such URLs to third parties.
</p>

	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">10. IANA 考慮点</h2>

<p>
恒久的~message~header~registryは、以下の登録により更新されるべきである
`RFC3864$r ：
◎
The permanent message header field registry should be updated with the following registrations ([RFC3864]):
◎
10.1. NEL
</p>

<div>
<dl id="nel">
	<dt>~header名</dt>
	<dd>`NEL$h</dd>
	<dt>適用-可能な~protocol</dt>
	<dd>http</dd>
	<dt>位置付け</dt>
	<dd>標準</dd>
	<dt>著作者／変更管理者</dt>
	<dd>W3C</dd>
	<dt>仕様~文書</dt>
	<dd>この仕様（ `NEL$h 応答~headerを見よ）</dd>
</dl>
◎
Header field name
• NEL
Applicable protocol
• http
Status
• standard
Author/Change controller
• W3C
Specification document
• This specification (see NEL response header)
</div>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この文書は
`CSP$r, `RFC6797$r
仕様の~textを，その~licenseに従って再利用している。
加えて、この仕事に~~有益な~commentを寄せられ，寄与された，次の各氏に感謝する：
`Julia Tuttle, Chris Bentzel, Todd Reifsteck, Aaron Heady, Mark Nottingham^en

◎
This document reuses text from the [CSP] and [RFC6797] specification, as permitted by the licenses of those specifications. Additionally, sincere thanks to Julia Tuttle, Chris Bentzel, Todd Reifsteck, Aaron Heady, and Mark Nottingham for their helpful comments and contributions to this work.
</p>
	</section>

</main></div>
