<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Indexed Database API 3.0 （日本語訳）</title>

<link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAMAAABHPGVmAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAABgUExURUxpcQBZnABZnABZnABZnABZnABZnABZnABanABZnABanP///yh0rMLX6AxioUmJueDs9BRnpPj6/LbQ457A2a3K32edxPz9/l+XwfD2+Xanysze6zh+soKvz5G41Yy106pHecQAAAAKdFJOUwAUi3E5WaPW7rwERGx1AAACSElEQVRo3u2a2ZKDIBBF3RUBkXEJbsn//+UYJhM1iisw88B9syrFqW7ovqnqtqxN2Z7vOgEAYRhGb/UfAASO63u2dUn96Q4I402FwDnH8txgx/ETVOB6hwAgis8JOLtAfnAW8FIU+BsxOBcJL85KPG4YS1PoLudJIoJj5lnzJCM45iNpTqxEzrjqwNovE0TK+p5nuEnT6qU0bXCWP+qSoGT1Sb9r1BalipI6byq4oarJa0JFKbPXGG1dpPCA0qJuVyjBPAKWVfCEqqycRxTwp/t5BQzf4Hk1M87zKU+ThfIveFFfOZom7CMQVEApKtA0lPGNdDcoSbducitDiVAMJQoP9QOsoe1KZUCYDU3ZGqLKVEHiESRRla4xRNnFTyGKnvAHREkxziFX28otY/Peby22+NMNki22fEtkN7Ja/SqEZ64t71m6lbwK52W76o/WDqee2C8/drf97odclm4IknsyWoRATOQhCIbLkCWDPiVaNv1hIkjfEwp2kUNZ8dOZxJBnZ2g6kpwDJKRr3mW1CuEB4Qc7+BAQe+BJc92E/JZyvaPY+v/KdY7nzW4f5Lcr4eLelYS0CFHKkQmlCLWElN29wMIOtwgxHm883ni88Xjj8cbjjccbjzcebzzeeLzxeOPxxuONx/93j4/Ue3w0Gm0k6kYbWoY0WsZNWgZnkkeACx7vyx5mMsEwU89YVjxgluDxob1vVH7F44Gtd+ivaH0BeH+xiMGjAUqj0Lgco2nN5+rCUgQObkYpXr3StkQmXIfjWTm4DvcNlJOM1BIp59cAAAAASUVORK5CYII=">
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style>

/* Examples */
aside.example {
	margin-bottom: 0.5em;
}

table._row > thead > tr {
	border-bottom: solid silver medium;
}
table._row > tbody > tr {
	border-bottom: solid silver thin;
}

.constant {
	text-decoration: underline;
}

.domintro > dl > dt {
	font-family: monospace0, monospace;
}
.domintro > dl > dt code {
	color: black;
}

#_hierarchy td {
	text-align: center;
	border: none;
}

.domintro:before {
	display: block;
	content: 'Web 開発者向け（規範的ではない）';
	color: var(--note-label-color);
	font-size: smaller;
	font-family: sans-serif0, sans-serif;
	height: 2em;
	position: relative;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let idl_ifc = '';

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let quote;
let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'I':
	if((indicator === '@') || (indicator === '!')){
		idl_ifc = key;
	}
	href = `#dom-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/(\w+)(\s=\s["\w]+)?/g, '<var>$1</var>$2');
}
	href = key.indexOf('.');
	if(href >=0 ){
		href = `${key.slice(0, href)}-${key.slice(href + 1)}`;
//		console.log(href);
	} else {
		href = (key === idl_ifc) ? idl_ifc : `${idl_ifc}-${key}`;
	}
	href = `#dom-${href.toLowerCase()}`;
	break;
case 'E':
	href = `#_${key}`;
	break;
case 'sl':
	text = `[[${text}]]`;
	break;
case 'l':
	quote = '"'
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`
	break;
case 'issue':
	href = `~IDBISSUES/${key}`;
	text = `課題 #${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}


if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return (quote ? quote + text + quote : text);

	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Indexed Database API 3.0
spec_date:2021-10-06
trans_update:2022-05-13
source_checked:211006
original_url:https://w3c.github.io/IndexedDB/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:storage
conformance:w3c
copyright:2021,permissive
trans_1st_pub:2015-08-06


●●class_map
e:element
a:attr
et:event-type
E:error
l:literal
i:constant
sl:js-slot
jT:js-type
jv:js-value
js:js-other
jA:abstract
U:code-point

●●tag_map
I:code
m:code
mF:code
mb:code
et:code
E:code
l:code
e:code
i:i
p:code
c:code
sl:span
jT:code
jv:code
js:code
jA:span
U:span
em:em
sub:sub
cite:cite

●●original_id_map

●●mdn_urls
idbcursor:API/IDBCursor
idbcursorwithvalue:API/IDBCursorWithValue
idbdatabase:API/IDBDatabase
idbfactory:API/IDBFactory
idbindex:API/IDBIndex
idbkeyrange:API/IDBKeyRange
idbobjectstore:API/IDBObjectStore
idbopendbrequest:API/IDBOpenDBRequest
idbrequest:API/IDBRequest
idbtransaction:API/IDBTransaction
idbversionchangeevent:API/IDBVersionChangeEvent
	dictdef-idbdatabaseinfo:API/IDBDatabaseInfo
	dictdef-idbindexparameters:API/IDBIndexParameters
	dictdef-idbobjectstoreparameters:API/IDBObjectStoreParameters
	dictdef-idbtransactionoptions:API/IDBTransactionOptions
	dictdef-idbversionchangeeventinit:API/IDBVersionChangeEventInit
	enumdef-idbcursordirection:API/IDBCursorDirection
	enumdef-idbrequestreadystate:API/IDBRequestReadyState
	enumdef-idbtransactionmode:API/IDBTransactionMode

eventdef-connection-versionchange:API/IDBDatabase/versionchange_event
_eventdef-connection-close:API/IDBDatabase/close_event
eventdef-request-upgradeneeded:API/IDBOpenDBRequest/upgradeneeded_event
eventdef-request-blocked:API/IDBOpenDBRequest/blocked_event
eventdef-request-success:API/IDBRequest/success_event
eventdef-request-error:API/IDBRequest/error_event
eventdef-transaction-complete:API/IDBTransaction/complete_event
eventdef-transaction-abort:API/IDBTransaction/abort_event

●●link_map


専属する:#_belong
専属しない:#_belong
値を保持し続ける:#_remain
可換性:#_commutative-requirement
一意性:#_uniqueness-requirement
~access先:#_to-access

	●IDL
Exposed:~WEBIDLjs#Exposed
EnforceRange:~WEBIDLjs#EnforceRange
SameObject:~WEBIDLjs#SameObject
NewObject:~WEBIDLjs#NewObject

E.SecurityError:~WEBIDL#securityerror
	E.AbortError
	E.ConstraintError
	E.DataCloneError
	E.DataError
	E.InvalidAccessError
	E.InvalidStateError
	E.NotFoundError
	E.QuotaExceededError
	E.SyntaxError
	E.ReadOnlyError
	E.TransactionInactiveError
	E.UnknownError
	E.VersionError

~SeqDS:~WEBIDL#idl-sequence
~SeqAny:~WEBIDL#idl-sequence

undefined:~WEBIDL#idl-undefined
any:~WEBIDL#idl-any
DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean
unsigned long long:~WEBIDL#idl-unsigned-long-long
unsigned long:~WEBIDL#idl-unsigned-long
Promise:~WEBIDL#idl-promise
sequence:~WEBIDL#idl-sequence


I.DOMString:~WEBIDL#idl-DOMString
I.unrestricted double:~WEBIDL#idl-unrestricted-double

I.IDBCursor:#idbcursor
I.IDBCursorDirection:#enumdef-idbcursordirection
I.IDBCursorWithValue:#idbcursorwithvalue
I.IDBDatabase:#idbdatabase
I.IDBFactory:#idbfactory
I.IDBDatabaseInfo:#dictdef-idbdatabaseinfo
I.IDBIndex:#idbindex
I.IDBIndexParameters:#dictdef-idbindexparameters
I.IDBKeyRange:#idbkeyrange
I.IDBObjectStore:#idbobjectstore
I.IDBObjectStoreParameters:#dictdef-idbobjectstoreparameters
I.IDBOpenDBRequest:#idbopendbrequest
I.IDBRequest:#idbrequest
I.IDBRequestReadyState:#enumdef-idbrequestreadystate
I.IDBTransaction:#idbtransaction
I.IDBTransactionMode:#enumdef-idbtransactionmode
I.IDBTransactionOptions:#dictdef-idbtransactionoptions
I.IDBVersionChangeEvent:#idbversionchangeevent
I.IDBVersionChangeEventInit:#dictdef-idbversionchangeeventinit

I.DOMStringList:~HTMLcdom#domstringlist

I.Blob:~FILEAPI#blob
I.File:~FILEAPI#file
I.DOMException:~WEBIDL#idl-DOMException
I.Document:~HTMLdom#document
I.Event:~DOM4#event
I.Event:~DOM4#concept-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.EventHandler:~WAPI#eventhandler
I.ImageData:~HEcanvas#imagedata
I.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope

constructor:#dom-idbversionchangeevent-idbversionchangeevent

m.close:#dom-idbdatabase-close
m.indexedDB:#dom-windoworworkerglobalscope-indexeddb
m.result:#dom-idbrequest-result
	m.error:#dom-idbrequest-error

m.domain:~ORIGIN#dom-document-domain
m.preventDefault:~DOM4#dom-event-preventdefault
m.bubbles:~DOM4#dom-event-bubbles
m.type:~DOM4#dom-event-type
m.cancelable:~DOM4#dom-event-cancelable

mF.size:~FILEAPI#dfn-size
mF.lastModified:~FILEAPI#dfn-lastModified
mF.name:~FILEAPI#dfn-name
mF.type:~FILEAPI#dfn-type

	●dict
mb.durability:#dom-idbtransactionoptions-durability
mb.keyPath:#dom-idbobjectstoreparameters-keypath
mb.autoIncrement:#dom-idbobjectstoreparameters-autoincrement
mb.unique:#dom-idbindexparameters-unique
mb.multiEntry:#dom-idbindexparameters-multientry

	●enum
l.done:#dom-idbrequestreadystate-done
l.pending:#dom-idbrequestreadystate-pending

l.next:#dom-idbcursordirection-next
l.nextunique:#dom-idbcursordirection-nextunique
l.prev:#dom-idbcursordirection-prev
l.prevunique:#dom-idbcursordirection-prevunique

l.readonly:#dom-idbtransactionmode-readonly
l.readwrite:#dom-idbtransactionmode-readwrite
l.versionchange:#dom-idbtransactionmode-versionchange

l.strict:#dom-idbtransactiondurability-strict
l.relaxed:#dom-idbtransactiondurability-relaxed
l.default:#dom-idbtransactiondurability-default

et.versionchange:#eventdef-connection-versionchange
et.close:#_eventdef-connection-close
	et.close:~HTMLindex#event-close
et.complete:#eventdef-transaction-complete
et.abort:#eventdef-transaction-abort
et.upgradeneeded:#eventdef-request-upgradeneeded
et.blocked:#eventdef-request-blocked
阻まれ:#eventdef-request-blocked
et.success:#eventdef-request-success
et.error:#eventdef-request-error

	●js
~Record:~TC39#sec-list-and-record-specification-type
中途完了:~TC39#sec-completion-record-specification-type
~NOABRUPT:~TC39#sec-algorithm-conventions
~Array~exotic~obj:~TC39#array-exotic-objects
jT.string:~TC39#sec-terms-and-definitions-string-type
jT.Array:~TC39#sec-array-objects
jT.ArrayBuffer:~TC39#sec-arraybuffer-objects
jT.Date:~TC39#sec-date-objects
jT.IdentifierName:~TC39#prod-IdentifierName
jT.Number:~TC39#sec-terms-and-definitions-number-type
jT.Object:~TC39#sec-object-objects
jT.String:~TC39#sec-terms-and-definitions-string-type
jT.RegExp:~TC39#sec-regexp-regular-expression-objects
jT.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror
jT.Uint8Array:~TC39#sec-typedarray-objects
	jT.Proxy

jA.CreateDataProperty:~TC39#sec-createdataproperty
jA.Type:~TC39#sec-ecmascript-data-types-and-values
jA.ReturnIfAbrupt:~TC39#sec-returnifabrupt
jA.ToString:~TC39#sec-tostring
jA.ToLength:~TC39#sec-tolength
jA.Get:~TC39#sec-get-o-p
jA.HasOwnProperty:~TC39#sec-hasownproperty

	Assert

	●es 言語束縛
jA.StructuredSerializeForStorage:~HTMLcloning#structuredserializeforstorage
jA.StructuredSerialize:~HTMLcloning#structuredserialize
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
直列化-可能:~HTMLcloning#serializable-objects
~Realm:~TC39#realm
現在の~Realm:~TC39#current-realm

~clone:#clone
~txの間に値を~cloneする:#clone

~keyを値の中へ注入できるか検査-:#check-that-a-key-could-be-injected-into-a-value
~keyを値の中へ注入できるか検査する:#check-that-a-key-could-be-injected-into-a-value
~keyを値の中へ注入する:#inject-a-key-into-a-value-using-a-key-path
~keyを抽出-:#extract-a-key-from-a-value-using-a-key-path
抽出される~key:#_ExtractedKeys
~key~pathを用いて値に~keyを注入-:#inject-a-key-into-a-value-using-a-key-path

値から~keyを抽出する:#extract-a-key-from-a-value-using-a-key-path
値から~key集合を抽出する:#_extract-keys-from-a-value
	Inject:#inject-a-key-into-a-value-using-a-key-path
~keyを値に変換する:#convert-a-key-to-a-value
値を~keyに変換する:#convert-a-value-to-a-key
~key~pathを評価する:#evaluate-a-key-path-on-a-value
Evaluate:#evaluate-a-key-path-on-a-value
配列を~key集合に変換する:#convert-a-value-to-a-multientry-key

Key:#_X-Key
Value:#_X-Value
Error:#_X-Error
Extract:#_X-Extract
状態を検査する:#_X-CheckState
Dispatch:#_X-Dispatch

名前:#name
~sort済み名前~listを作成する:#create-a-sorted-name-list

	●database, 接続
~db:#database
db.名前:#database-name
db.~version:#database-version
~db~access~task源:#database-access-task-source
db.昇格~tx:#database-upgrade-transaction

接続:#connection
	接続先~db:#connection
Cn.~version:#connection-version
Cn.保管庫~集合:#connection-object-store-set
Cn.状態:#connection-close-pending-flag
	~close待ちか:#connection-close-pending-flag
i.~open中:#connection-opened
i.~close済み:#connection-closed
i.~close待ち:#connection-close
~close:#connection-closed

接続~queue:#request-connection-queue

	●transaction
~tx:#transaction-concept
tx.接続:#transaction-connection
	専属する接続:#transaction-connection
視野:#transaction-scope
視野が重合して:#transaction-overlap
~mode:#transaction-mode

tx.状態:#transaction-state
i.~commit中:#transaction-committing
i.非作動中:#transaction-inactive
i.作動中:#transaction-active
i.完遂d:#transaction-finished
完遂-:#transaction-finished

耐久能~hint:#transaction-durability-hint
片付ける~event~loop:#transaction-cleanup-event-loop
索引付き~db~txを片付ける:#cleanup-indexed-database-transactions
要請~list:#transaction-request-list
tx.~error:#transaction-error
存続期間:#transaction-lifetime
作成-:#transaction-created
開始-:#transaction-start
中止-:#transaction-abort
~commit:#transaction-commit
昇格~tx:#upgrade-transaction
稼働して:#_transaction-running
昇格~txの中:#_within-an-upgrade-transaction
昇格~txの外:#_within-an-upgrade-transaction

~readwrite~tx:#transaction-read-write-transaction
~readonly~tx:#transaction-read-only-transaction


	●要請
要請:#request
済んだか:#request-done-flag
~source:#request-source
結果:#request-result
~error:#request-error
~open要請:#request-open-request
演算:#_operation
設置-先~tx:#request-transaction
設置-:#request-placed
処理-済み:#request-processed
処理-済みか:#request-processed-flag


	●保管庫, 索引
保管庫:#object-store
Os.~record~list:#object-store-list-of-records
	Os.~record:#object-store-record
Os.名前:#object-store-name
Os.~key~path:#object-store-key-path
	Os.~in-line~key:#object-store-in-line-keys
	~key~pathを持つ:#object-store-in-line-keys
	Os.~out-of-line~key:#object-store-out-of-line-keys
	~key~pathを持たない:#object-store-out-of-line-keys

保管庫~handle:#object-store-handle
OsH.保管庫:#object-store-handle-object-store
OsH.索引~集合:#object-store-handle-index-set
OsH.名前:#object-store-handle-name
OsH.専属する~tx:#object-store-handle-transaction
OsH.~tx:#object-store-handle-transaction

索引:#index-concept
参照-:#index-referenced
参照先の保管庫:#index-referenced
参照先の値:#index-referenced-value
参照先~record:#_index-referenced-record
Ix.~record~list:#index-list-of-records
Ix.~key~path:#index-key-path
Ix.名前:#index-name
Ix.一意か:#index-unique-flag
Ix.複-~entryか:#index-multientry-flag

	＊未利用
	Ix.~record:#index-records
	Ix.~key:#index-keys
	Ix.値:#index-values

索引~handle:#index-handle
IxH.索引:#index-handle-index
IxH.名前:#index-handle-name
IxH.保管庫~handle:#index-handle-object-store-handle
IxH.~tx:#index-handle-transaction



	●crusor
~cursor:#cursor
Cs.範囲:#cursor-range
Cs.~source:#cursor-source
Cs.方向:#cursor-direction
Cs.~tx:#cursor-transaction
Cs.位置:#cursor-position
Cs.保管庫~位置:#cursor-object-store-position
Cs.~key:#cursor-key
Cs.値:#cursor-value
Cs.値は取得-済みか:#cursor-got-value-flag
Cs.実効~保管庫:#cursor-effective-object-store
Cs.実効~key:#cursor-effective-key
Cs.要請:#cursor-request
Cs.~keyのみか:#cursor-key-only-flag


	●record, value, key, key範囲, key path
~record:#_record
値:#value
~key:#key

i.number:#_keytype-number
i.date:#_keytype-date
i.string:#_keytype-string
i.binary:#_keytype-binary
i.array:#_keytype-array


~key範囲:#key-range
下界:#key-range-lower-bound
上界:#key-range-upper-bound
下界openか:#key-range-lower-open-flag
上界openか:#key-range-upper-open-flag
のみを包含する:#containing-only
全範囲:#unbounded-key-range
Only:#containing-only
入る:#in
Range:#convert-a-value-to-a-key-range
表現する~key範囲:#convert-a-value-to-a-key-range

~key生成器:#key-generator
現在の番号:#key-generator-current-number
最大の番号:#_max-number
		NUMBER.MAX_SAFE_INTEGER
		9007199254740992

key.種別:#key-type
key.値:#key-value
配列~key:#array-key
下位key:#subkeys
key.比較-:#compare-two-keys
Compare:#compare-two-keys
昇順:#greater-than
より大きい:#greater-than
より小さい:#less-than
等しい:#equal-to
等しく:#equal-to
~key~path:#key-path
妥当な~key~path:#valid-key-path
識別子:#identifier


	●手続き

addするかputする:#add-or-put

保管庫~用の~keyを生成する:#generate-a-key
保管庫~用の~key生成器を可能なら更新する:#possibly-update-the-key-generator

	event
~success~eventを発火する:#fire-a-success-event
~error~eventを発火する:#fire-an-error-event
~version変更~eventを発火する:#fire-a-version-change-event

~dbを~openする:#open-a-database
~db接続を~closeする:#close-a-database-connection
~dbを削除する:#delete-a-database

~txを~commitする:#commit-a-transaction
~txを~commit:#commit-a-transaction
~txを中止する:#abort-a-transaction
~txを中止-:#abort-a-transaction

要請を非同期に実行する:#asynchronously-execute-a-request
非同期に実行する:#asynchronously-execute-a-request

昇格~txを稼働する:#run-an-upgrade-transaction
昇格~txを稼働-:#run-an-upgrade-transaction
昇格~txを中止する:#abort-an-upgrade-transaction
昇格~txが中止-:#abort-an-upgrade-transaction

保管庫に~recordを格納する:#store-a-record-into-an-object-store

	Retrieval Operations
範囲に入る~entryたちを検索取得する:#_retrieve-multiple-x-from-y
範囲に入る最初の~entryを検索取得する:#_retrieve-a-x-from-y

保管庫から~recordを削除する:#delete-records-from-an-object-store
範囲に入る~recordを数える:#count-the-records-in-a-range
保管庫を~clearする:#clear-an-object-store

~cursorを反復する:#iterate-a-cursor
~cursorを作成する:#_crtate-a-cursor

	LI:#version-change-close-block
	LI:#delete-close-block
（旧来の）~listenerは投出したか:#_legacyOutputDidListenersThrowFlag

	●外部
ev.取消されたか:~DOM4#canceled-flag
~eventを発火する:~DOM4#concept-event-fire
~eventを作成する:~DOM4#concept-event-create
~eventを配送する:~DOM4#concept-event-dispatch
配送-:~DOM4#concept-event-dispatch
文書:~DOM4#concept-document
親~標的を取得する:~DOM4#get-the-parent

並列的:~HTMLINFRA#in-parallel

新たな~promise:~WEBIDLjs#a-new-promise
却下する:~WEBIDLjs#reject
解決する:~WEBIDLjs#resolve
却下される~promise:~WEBIDLjs#a-promise-rejected-with
所与の値:~WEBIDL#the-given-value

~taskを~queueする:~WAPI#queue-a-task
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
aG.~event~loop:~WAPI#concept-agent-event-loop
~event~loop:~WAPI#event-loop
~task:~WAPI#concept-task
~task源:~WAPI#task-source
~task~queue:~WAPI#task-queue
関連な設定群~obj:~WAPI#relevant-settings-object
enV.生成元:~WAPI#concept-settings-object-origin

~worker:~WORKERS#worker
閲覧文脈:~BROWSERS#browsing-context
生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque

区切子で厳密に分割する:~INFRA#strictly-split
~byte:~INFRA#byte
~byte列:~INFRA#byte-sequence
byte.長さ:~INFRA#byte-sequence-length
未満の符号単位~列:~INFRA#code-unit-less-than
未満の~byte列:~INFRA#byte-less-than
str.長さ:~INFRA#string-length

~list:~INFRA#list
~size:~INFRA#list-size
~item:~INFRA#list-item
集合:~INFRA#ordered-set
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
set.付加する:~INFRA#set-append
~listを昇順に~sortする:~INFRA#list-sort-in-ascending-order
sub.符号単位:~INFRA#code-unit-less-than

投出-:~WEBIDL#dfn-throw
	:~WEBIDL#dfn-create-exception
~buffer~source型:~WEBIDL#idl-buffer-source-types
	~buffer~source型:~WEBIDL#dfn-buffer-source-type
~buffer~sourceに保持されている~byte列の複製を取得-:~WEBIDL#dfn-get-buffer-source-copy

~storage~bucket:~STORAGE#storage-bucket

●●words_table1

SeqDS:<code>sequence&lt;DOMString&gt;</code>
SeqAny:<code>sequence&lt;any&gt;</code>
IDBISSUES:https://github.com/w3c/IndexedDB/issues
cmpkey:<a href="#_key_comparison"><sub>key</sub></a>
cmpRec:<a href="#_index_record_comparison"><sub>rec</sub></a>

varV:<var>V</var>

●●words_table

	●IDL／データ／構造
Record:
Array:
exotic:
作成ng:creating:作成
	queue-up
	queuing
	cloning
	copying
	構築し直す:reconstruct
	構築-法:constructing

	didThrow
	（旧来の）~listenerは投出したか:legacyOutputDidListenersThrowFlag
	空でない:non-empty

	~~一定の順序で:in-order:
	-:exclude
	-:child

	●文字データ
alphabet::::アルファベット
16-bit:
正規化形:normalization form:~
制御文字:control:~
字句的:lexicographical:~
代用対:surrogate pair::~::サロゲートペア
末尾:end:~
逆直列化-:deserialize::~::逆シリアル化
直列形:serialized::~::シリアル形
escaping::::エスケープ処理

	●一般処理
標的:target:::ターゲット
同時並行的:concurrent:~
区間:interval:~
時機:timing:~
稼働-:run::~
	稼働している:running
	成功した:successful
不可分:atomic::~
例外的:exceptional:~
非作動中:inactive::~::非アクティブ
	作動中でなくなる:deactivate
上書-:overwrite::上書き
上書不可:no-overwrite::上書き不可
	完了していない:pending

呼出時:invoke 時:呼び出し時
投出あり:did throw::~
schedule::::スケジュール
	~schedule法:scheduling
要求mode:required mode:要求 mode::要求モード

異常:abnormal:~
排他的:exclusive:~
crash::::クラッシュ
	crashing
snapshot::::スナップショット
	収集-順:sequencing of the collection
中途完了:abrupt completion::~

片付ける:clean upする:~
片付けら:clean upさ:~
	片付ける:cleanup
再帰-:recurse:~
続行-:proceed:~
条件付きで:conditionalに:~
競合:conflict:~
	~tx間で互いに競合:merge conflicts:
処理待ち:pending:~
未決な:outstanding:~
素早く:quickに:~
一時的:temporary:~
優先-:prioritize:~

為した:makeした:~
為され:makeされ:~
為せる:makeできる:~
為せな:makeできな:~

	一定期間:period of time
	-:recursive
	渡す:pass する
	飛ばす:skip する
	終え:done
	~RET:terminate these steps
	〜になる:enter
	blocking
	unblock
	failed
	executing
	target
	発火-法:firing

	●一般処理（storage
bucket::::バケット
巻戻され:roll backされ::~
巻戻し:rollback::~
復帰-:revert::~
復帰させ:revertす::~
喪失:loss:~
	starting
耐久能:durability::~
lifecycle:
成長-:grow:~
一掃-:flush::~
存続期間:lifetime:~
短命:ephemeral:~
	~~短命:short lived


	●db／接続／tx／event
db:database:::データベース

接続先:connected::~
切断-:disconnect::~
	out-of-line
	in-line
open:
	opening
close:
	~close待ち:close pending
	error:
success:
readonly:
readwrite:read/write
済んだ:done:~
commit::::コミット
	~commit中:committing
handle::::ハンドル
	新~version
	旧~version
tx: transaction:::トランザクション
	transactionに基づくtransactional:
保管庫:object store::~::オブジェクトストア
設置-:place::~
	設置-先:place 先
索引:index::~::インデックス
索引付き:indexed::~::インデックス付き
併合-:merge::~

	●演算

昇格:upgrade::~
昇格-:upgrade::~
保存-:save::~

書込n:write::書き込み
書込む:writeする::書き込む
書込まれ:writeされ::書き込まれ
書込め:writeでき::書き込め
書込まな:writeしな::書き込まな
書込んで:writeして::書き込んで
書込も:writeしよ::書き込も
書込み:writing::書き込み

読取らせ:readさせ::読み取らせ
参照先:referenced::~
参照先の:referenced::~


結果:result:~

	●key 生成／cursor／走査
反復対象に:iterate over::~::イテレート対象に
	~sort済み:sorted
自動:auto:~
cursor::::カーソル
生成key:generated key::生成 key
下位key:subkey::下位 key
首key:primaryKey::首 key
	首key:primary key
only:
path:
全範囲:unbounded key range:~
下界:lower bound::~
上界:upper bound::~
下界open:lower open::下界は open
上界open:lower open::上界は open
増加-:increase:~
増分-:increment:~
減少-:decrease:~
	retrieval
検索-:look up::~
検索:look-up::~
単調:monotonic::~
番号:number::~
抽出d:extracted::抽出
走査-:traverse::~
	traversal
昇順:ascending order:~
降順:descending order:~
	{key:value}:key-value
	複-~entry:multiEntry
	値は取得-済み:got value

	●環境
off-line::::オフライン
disk::::ディスク
言語束縛:binding::~
machine::::マシン
compile::::コンパイル
compiler::::コンパイラ
quota::::クォータ
環境設定:configuration settings:~
宛先:target::~
電力:power:~
携帯:portable:~
battery-life:battery life:::バッテリー寿命

	●保安
	URL~path:pathname
	TLS
	DNS
証明書:certificate:~
cross-directory::::クロスディレクトリ
健康診断記録:health record:~
	site-specific:
ログイン:log in:::~
購入:purchase:~
行動:action:~
	client-side
活動:activities:~
認証-:authenticate::~
	認証-済み:authenticated
電子商取引:e-commerce:~
失効-:expire:~
	expiring:
権限付与-:authorize:~
クレジットカード:credit card:~
住所:address:~
識別情報:identifying information:~
	~~識別情報:id object
阻止list:blocklist::阻止 list:阻止リスト:ブロックリスト
安全list:safe-listing::安全 list:安全リスト
	~~提案:suggestion
自明:trivial:~
協力-:cooperate:~
協力:cooperation:~
転用-:repurpose:~
遡及的:retroactive:~
訪問者:visitor:~
復活:resurrection:~

冗長:redundant:~
backup::::バックアップ
打破-:defeat:~
首尾一貫した:coherentな:~
	敏感~性:sensitivity
メール:e-mail:~
機密的:confidential:~
迂回-:bypass:~
敵対者:adversary:~
購買:shopping:~
広告:advertising:~
文書作成:word-processing:~
作業中の:work-in-progres:~
競合企業:competing company:~
危険:dangerous:~
被害者:victim:~
配布-:distribute:~
本当:real:~
本当の:realな:~
文書作成:word-processing:~
圧政的団体:oppressive group:~
共有d:shared:共有
予定表:calendar appointments:~
不揮発:non-volatile:~
	媒体:medium
持続性:persistence:~
持続化-:persist:~
持続的:persistent:~
運用上の:operationalな:~
	旧:older
正規表現:regular expression:~
	~~命令:instruction
遭遇-:encounter:~
各個人:individual:~

	残り続ける:remain
	生じる／:arise
	scripting
	覗き見る:examine
	同等に:equal に
	letting
	組み合わされ:in conjunction with
	即座に:promptly
	capable:
	知る:aware
	差し障りない:innocuous
	純粋:purely
	晒す:put
	quite:
	責を負う:responsible
	world
	greater
	ずっと正確aに:with greater accuracy
	stored
	he
	~~健全な疑い:healthy suspicion
	生成元~追跡:origin-tracking
	取り除く:prune
	情報を吟味した上で〜裁定を下せる:informed decisions

	●accessibility
末端利用者:end-user:~
必要性:needs:~
prompt:
念頭:mind:~
制作-:produce:~
screen-reader:screen reader:::スクリーンリーダ
	代替を成す〜:〜alternatives
	時間に基づく:time-based
	他の:non-textual
	~~一部分:fraction

	●仕様
targeted:
	common:
機会:chance:~
参考:informative:~
優位性:advantage:~
適度:reasonable:~
決定的:deterministic:~
高度な:advanced:~
心臓部:heart:~
優先順位:precedence:~
版:edition:~
確度:confidence:~
monkey-patching:monkey patching
組織化-:organize:~
洗練-:sophisticate:~
提言:suggestion:~
上限:limit:~
辞退-:decline:~
重視-:weigh:~
	勝る:outweigh:~
人為的:artificial:~
課-:impose:~

	~~課す
	際どい:edge
	易く:easy
	該当:cover
	最終的に:ultimately
	妨げ:too disruptive
	ゆえに:To this end
	~~厳密にrigorous
	強い影響力を及ぼした:extremely influential in:
	それに加え:additionally
	ごく普通に:quite
	あり得る:possible
	可能性／potential
	なり得る:potentially
	practical
	prepare:
	primarily:
	respective:
	publish:
	publishing:
	-:similar
	suffice:
	sure:
	thank:
	一切なくても:whatsoever
	work-in-progres:
	year:
	user-specific:
	variation:
	welcome:
	先ず初めに:before proceding with rest of
	~~要約すると、:practical result of this is
	~~協同して:act together
	speaking:
	-:scenario
	secondarily:
	proposed:
	~~説明:illustrate
	employ:
	~fashion:
	follow:
	appreciation:
	capable
	との間で:with respect to
	高める:provides greater
	nonsupported
	できなくなる:prevent
	できるように:allowed to／:allowing
	自覚できるようにしておく:make sure 〜 is aware
	authoring:
	aware:
	保-:keep
	required:
	realize:
	regarding:
	wrote:
	称され:said
	勧められ:advise
	~~見直す:introspect
	満たす:satisfy

	●未分類（動詞
出自に:originate:~
合致:match::~::マッチ
	-:evaluate
固定-:fix:~
	保ち続け:keep track
読込直す:reloadする::読み込み直す::リロードする
読込直-:reload::読み込み直::リロード
捜出す:locateする:捜し出す
隠す:hideする:~
閉じて:closeして:~
衝突-:clash:~
移行-:migrate:~
重合する:overlapする:重なり合う
重合して:overlapして:重なり合って
一意性:uniqueness:~
	一意性の
破損:corruption:~
入出力:I/O:~

	-:assign
	duplicate:
	進める:advance
	存在-:exist
	高効率:highly efficient
	類する:or something similar
	成る:comprise
	欠-:lack
	保たれ:kept
	請う／請われ:ask
	bound
	chain
	continue:
	continuing:
	数えるcount:
	end:
	equal:
	exceeding:
	満たすfulfill:
	inspect:
	leading:
	left:
	letting:
	marked
	~~合致:meet
	met:
	指す:point
	pointed
	processed:
	put:
	~refer:
	〜し続けremain:
	stay
	taken
	tell
	結び付け:tie
	別~pageへ移動:navigating away

	●未分類
ES:ECMAScript
	JS:ECMAScript
実効:effective:~
B-tree::::B-ツリー
関係db:relational database:::関係データベース:リレーショナルデータベース
	time:
modal::::モーダル
	non-modal
無符号:unsigned:~
有符号:signed:~
式:expression:~
総数:total number:~
連続的:continuous:~
最大:最大
最小:最小

	刊行頻度:frequency
	access可能:accessible
	返信:communicates back
	-:numeric
	-:non-numeric
	小さな差異:minor variation
	result
	extreme
	-:concrete
	across
	存続する限り固定され続ける:remains fixed for the life
	~~時間を要する:durable
	although
	also
	anyone
	apart
	away
	back
	~~悪化-:lead to a poor
	become
	本:book
	~class
	due
	early
	ever
	false
	片:fragment
	go
	he
	in-order
	in
	infinite
	infinity
	likely
	night:
	option:
	options:
	parameter:
	そのような:pattern
	片:piece
	product:
	row:
	series:
	~~容量space:

	thread:
	true:
	unchanged:
	~undo:
	unpacked:
	yield:
	区別され:sensitive／

	●指示語
元の:

	同時に:at the same time
	すべて:altogether
	長い:long
	旧:older
	次:next
	総数:how many
	大多数の:most
	後続-:follow
	より大きな:larger
	より小さな:smaller
	最も小さな:smallest
	重ねて:twice／:more than once
	最も低い:lowest
	最も高い:highest
	より高い:higher
	大きい:high／larger
	他の〜:others
	結果の:resulted／resulting
	始-:begin
	種々の:various
	様々な:variety
	inner
	間に:in the middle
	moreover:
	部分:everything
	ちょうど:exact
	ある~~範囲:some extent
	最後に:finally
	ずっと:greater
	neither
	once
	逆:opposite
	outer-most:
	part:
	past:
	slight:
	preceding
	previous:
	前回:previous
	いくつかの:several:
	小さな~small:
	大きな~large
	something:
	sometime:
	such:
	unlike:
	until:
	very:
	one and only one
	一階層:one level
	日夜:day and night
	large:
	later:
	今後の:later
	早期:earlier
	に対し:against
	後続の:subsequent

●●ref_normative

[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMA-262]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[FileAPI]
    Marijn Kruisselbrink; Arun Ranganathan. ＜File API＞. 4 June 2021. WD. URL: https://www.w3.org/TR/FileAPI/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[STORAGE]
    Anne van Kesteren. ＜Storage Standard＞. Living Standard. URL: https://storage.spec.whatwg.org/
[WEBIDL]
    Boris Zbarsky. ＜Web IDL＞. 15 December 2016. ED. URL: https://heycam.github.io/webidl/

●●ref_informative

[Charmod-Norm]
    Addison Phillips; et al. ＜Character Model for the World Wide Web: String Matching＞. 11 August 2021. NOTE. URL: https://www.w3.org/TR/charmod-norm/
[COOKIES]
    A. Barth. ＜HTTP State Management Mechanism＞. April 2011. Proposed Standard. URL: https://httpwg.org/specs/rfc6265.html
[WEBSTORAGE]
    Ian Hickson. ＜Web Storage (Second Edition)＞. 28 January 2021. REC. URL: https://www.w3.org/TR/webstorage/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Indexed Database API 3.0</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/IndexedDB/
公表履歴
	https://www.w3.org/standards/history/IndexedDB-3
編集者草案
	https://w3c.github.io/IndexedDB/
テスト一式
	https://github.com/web-platform-tests/wpt/tree/master/IndexedDB
課題追跡
	<a href="https://github.com/w3c/IndexedDB/issues/">GitHub</a>
編集
	<a href="mailto:alia@microsoft.com">Ali Alabbas</a> (Microsoft Corp.)
	<a href="mailto:jsbell@google.com">Joshua Bell</a> (Google Inc.)

commit 履歴
	https://github.com/w3c/IndexedDB/commits/main
実装報告
	http://wpt.fyi/IndexedDB
フィードバック
	https://github.com/w3c/IndexedDB/issues/
過去 ML アーカイブ
	https://lists.w3.org/Archives/Public/public-webapps/
公表者
	<a href="https://www.w3.org/groups/wg/webapps">Web Applications WG</a>

</script>

</head>

<body>

<header>
	<hgroup>
<h1 id="title">索引付きデータベース API — Indexed Database API 3.0</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この文書は、
一連の~recordからなる~db用の~APIを定義する。
ここでの各~recordは、［
~keyと, 対応する［
単純な値, または階層的な~objを保持する
］ような何らかの値
］の組みからなる†。
加えて、
~dbは，［
格納される一連の~recordたちにわたる，いくつかの索引
］も保守する。
~app開発者は、
~APIを直に利用して，［
~keyにより，または索引を利用して
］，格納されている~recordを捜出す。
また、
この~API上に~query言語の層を~~重ねられる。
索引付き~dbは、
持続的な~B-tree~data構造を利用して実装し得る。
◎
This document defines APIs for a database of records holding simple values and hierarchical objects. Each record consists of a key and some value. Moreover, the database maintains indexes over records it stores. An application developer directly uses an API to locate records either by their key or by using an index. A query language can be layered on this API. An indexed database can be implemented using a persistent B-tree data structure.
</p>

<p class="trans-note">【†
この仕様が対象にする~recordは、
CSV や
`<a href="https://ja.wikipedia.org/wiki/%E9%96%A2%E4%BF%82%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9">関係db</a>^_
の様な平坦な~fieldの並びではない。
~recordの値である~objが首な~data源であり
（数値や文字列のような “単純な” 値は “一階層のみの~obj” と捉えられる）、
~recordの~keyは，もっぱら それらの値を~~検索したり, ~recordたちを~sortするために働くものとして~~意図されている。
】</p>

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、
編集者草案の公な複製です…
【以下，この節の他の内容は、~SOTD-W3Cに移譲。】
</p>

<p>
これは、
Indexed Database API の第 3 版です。
<a href="~TR/2015/REC-IndexedDB-20150108/">初版</a>
（ `Indexed Database API^cite ）は
2015年 1月 8日に W3C 勧告になっています。
<a href="~TR/2018/REC-IndexedDB-2-20180130/">第 2 版</a>
（ `Indexed Database API 2.0^cite ）は
2018年 1月 30日に W3C 勧告になっています。
◎
This is the Third Edition of Indexed Database API. The First Edition, simply titled "Indexed Database API", became a W3C Recommendation on 8 January 2015. The Second Edition, titled "Indexed Database API 2.0", became a W3C Recommendation on 30 January 2018.
</p>

<p>
この第 3 版は、
第 2 版に取って代わることが意図されています。
◎
Indexed Database API 3.0 is intended to supersede Indexed Database API 2.0.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~UAは、
~web~appの~off-line~data要件を満たすため，多数の~objを局所に格納する必要がある。
`WEBSTORAGE$r は、
一連の［
~keyと対応する値
］の~pairを格納するために有用ではあるが、［
~keyを~~一定の順序で検索取得する／
多数の値にわたり効率的に探索する／
一つの~keyに対し複合的な値を格納する
］方法は 供していない。
◎
User agents need to store large numbers of objects locally in order to satisfy off-line data requirements of Web applications. [WEBSTORAGE] is useful for storing pairs of keys and their corresponding values. However, it does not provide in-order retrieval of keys, efficient searching over values, or storage of duplicate values for a key.
</p>

<p>
この仕様は、［
大多数の洗練された~query処理器の心臓部である，高度な { ~key: 値 } ~data管理
］を遂行する~APIを供する
— ~txに基づく~dbを利用して，一連の［
~keyと（~keyごとに一つ以上の）対応する値
］を格納し，各~keyを決定的 順序で走査する手段を供することにより。
これは、
持続的な~B-tree~data構造を利用して実装されることが多い
— それは、
挿入と削除に加えて，大量の~data~recordを~~一定の順序で走査するときにも効率的であると考えられているので。
◎
This specification provides a concrete API to perform advanced key-value data management that is at the heart of most sophisticated query processors. It does so by using transactional databases to store keys and their corresponding values (one or more per key), and providing a means of traversing keys in a deterministic order. This is often implemented through the use of persistent B-tree data structures that are considered efficient for insertion and deletion as well as in-order traversal of very large numbers of data records.
</p>

<aside class="example" id="example-open-connection">

<p>
次の例は、
~APIを利用して，`書庫^l ~dbに~accessする。
この~dbは、
名前 `書棚^l の`保管庫$を持つ。
この書棚には、
`isbn^l ~propを首keyに用いて，一群の`~record$ （すなわち， “本” ）が格納される。
◎
The following example uses the API to access a "library" database. It has a "books" object store that holds books records stored by their "isbn" property as the primary key.
</p>

<p>
各 本には、
`書名^l ~propもある。
この例では、
書名が【書棚~内で】一意になることを，人為的に要求する。
この~codeは、［
<a href="#dom-idbindexparameters-unique">`unique^m</a>
~optionが ~T に設定された，名前 `書名索引^l の`索引$を作成する
］ことにより，これを施行する。
この索引は、
各 本を書名で検索するために利用され，書名が一意でない本を追加するのも防止することになる。
◎
Book records have a "title" property. This example artificially requires that book titles are unique. The code enforces this by creating an index named "by_title" with the unique option set. This index is used to look up books by title, and will prevent adding books with non-unique titles.
</p>

<p>
各 本には、
`著者名^l ~propもあり，一意になることは要求されない。
この~codeは、
名前 `著者名索引^l の`索引$も作成して，この~propによる検索を許容する。
◎
Book records also have an "author" property, which is not required to be unique. The code creates another index named "by_author" to allow look-ups by this property.
</p>

<p>
この~codeは、
まず，~dbへの接続を~openする。
`upgradeneeded$et ~event~handlerの~codeが，必要なら保管庫と（それに`専属する$）索引たちを作成する。
`success$et ~event~handlerの~codeは、
~openした接続を後の利用-用に保存する。
◎
The code first opens a connection to the database. The upgradeneeded event handler code creates the object store and indexes, if needed. The success event handler code saves the opened connection for use in later examples.
</p>

<pre class="lang-js">
const %request = `indexedDB$m.open(`書庫^l);
let %書庫;

%request.onupgradeneeded = function() {
  /* <span class="comment">
書庫~dbはまだ存在しないので，保管庫と索引を作成する。
◎
The database did not previously exist, so create object stores and indexes.
</span> */
  const %書庫 = %request.result;
  const %書棚 = %書庫.createObjectStore(`書棚^l, {keyPath: `isbn^l});
  const %書名索引 = %書棚.createIndex(`書名索引^l, `書名^l, {unique: true});
  const %著者名索引 = %書棚.createIndex(`著者名索引^l, `著者名^l);

  /* <span class="comment">
初期~dataで保管庫を拡充する
（索引は自動的に拡充される）。
◎
Populate with initial data.
</span> */
  %書棚.put({書名: `Quarry Memories^l, 著者名: `Fred^l, isbn: `123456^lt});
  %書棚.put({書名: `Water Buffaloes^l, 著者名: `Fred^l, isbn: `234567^lt});
  %書棚.put({書名: `Bedrock Nights^l, 著者名: `Barney^l, isbn: `345678^lt});
};

%request.onsuccess = function() {
  %書庫 = %request.result;
};</pre>

<p>
次の例は、
~txを利用して~dbを拡充する。
◎
The following example populates the database using a transaction.
</p>

<pre class="lang-js">
const %tx = %書庫.transaction(`書棚^l, `readwrite$l);
const %書棚 = %tx.objectStore(`書棚^l);

%書棚.put({書名: `Quarry Memories^l, 著者名: `Fred^l, isbn: `123456^lt});
%書棚.put({書名: `Water Buffaloes^l, 著者名: `Fred^l, isbn: `234567^lt});
%書棚.put({書名: `Bedrock Nights^l, 著者名: `Barney^l, isbn: `345678^lt});

%tx.oncomplete = function() {
  /* <span class="comment">
すべての要請は成功し，~txは~commitされた。
◎
All requests have succeeded and the transaction has committed.
</span> */
};</pre>

<p>
次の例は、
索引を利用して，~db内の単独の本を書名で検索する：
◎
The following example looks up a single book in the database by title using an index.
</p>

<pre class="lang-js">
const %tx = %書庫.transaction(`書棚^l, `readonly$l);
const %書棚 = %tx.objectStore(`書棚^l);
const %書名索引 = %書棚.index(`書名索引^l);

const %request = %書名索引.get(`Bedrock Nights^l);
%request.onsuccess = function() {
  const %matching = %request.result;
  if (%matching !== undefined) {
    /* <span class="comment">
合致するものが見出された。
◎
A match was found.
</span> */
    report(%matching.isbn, %matching.書名, %matching.著者名);
  } else {
    /* <span class="comment">
合致するものは見出されなかった。
◎
No match was found.
</span> */
    report(null);
  }
};</pre>

<p>
次の例は、
索引と~cursorを利用して，~db内のすべての本から，著者名が合致するものを検索する：
◎
The following example looks up all books in the database by author using an index and a cursor.
</p>

<pre class="lang-js">
const %tx = %書庫.transaction(`書棚^l, `readonly$l);
const %書棚 = %tx.objectStore(`書棚^l);
const %著者名索引 = %書棚.index(`著者名索引^l);

const %request = %著者名索引.openCursor(<span class="typ">IDBKeyRange</span>.only(`Fred^l));
%request.onsuccess = function() {
  const %cursor = %request.result;
  if (%cursor) {
    /* <span class="comment">
合致する各~recordごとに~callされる。
◎
Called for each matching record.
</span> */
    report(%cursor.value.isbn, %cursor.value.書名, %cursor.value.著者名);
    %cursor.continue();
  } else {
    /* <span class="comment">
合致する~recordはもうない。
◎
No more matching records.
</span> */
    report(null);
  }
};</pre>

<p>
要請が失敗したとき~errorを取扱う仕方の一つを、
次の例に示す：
◎
The following example shows one way to handle errors when a request fails.
</p>

<pre class="lang-js">
const %tx = %書庫.transaction(`書棚^l, `readwrite$l);
const %書棚 = %tx.objectStore(`書棚^l);
const %request = %書棚.put({書名: `Water Buffaloes^l, 著者名: `Slate^l, isbn: `987654^lt});
%request.onerror = function(%event) {
  /* <span class="comment">
索引 `書名索引^l に対する一意性の拘束は失敗した。
◎
The uniqueness constraint of the "by_title" index failed.
</span> */
  report(%request.error);
  /* <span class="comment">
~txを中止させたくなければ，
%event の `preventDefault()$m を~callすることもできる。
◎
Could call event.preventDefault() to prevent the transaction from aborting.
</span> */
};
%tx.onabort = function() {
  /* <span class="comment">
他の場合、
失敗した要請に因り，~txは自動的に中止されることになる。
◎
Otherwise the transaction will automatically abort due the failed request.
</span> */
  report(%tx.error);
};</pre>

<p>
必要なくなったなら、
~db接続は~closeできる。
◎
The database connection can be closed when it is no longer needed.
</p>

<pre class="lang-js">
%書庫.close();
</pre>

<p>
~dbは，未来に他の保管庫／索引を包含するように成長させれる。
より古い~versionから移行するときに取扱う仕方の一例を次に示す。
◎
In the future, the database might have grown to contain other object stores and indexes. The following example shows one way to handle migrating from an older version.
</p>

<pre class="lang-js">
const %request = `indexedDB$m.open(`書庫^l, `3^lt); /* <span class="comment">
~version 3 を要請する。
◎
Request version 3.
</span> */
let %書庫;

%request.onupgradeneeded = function(%event) {
  const %書庫 = %request.result;
  if (%event.oldVersion &lt; `1^lt) {
    /* <span class="comment">
~version 1 が~dbの最初の~version。
◎
Version 1 is the first version of the database.
</span> */
    const %書棚 = %書庫.createObjectStore(`書棚^l, {keyPath: `isbn^l});
    const %書名索引 = %書棚.createIndex(`書名索引^l, `書名^l, {unique: true});
    const %著者名索引 = %書棚.createIndex(`著者名索引^l, `著者名^l);
  }
  if (%event.oldVersion &lt; `2^lt) {
    /* <span class="comment">
~version 2 は、
`出版年^l で本を検索できるようにする，新たな索引を導入する。
◎
Version 2 introduces a new index of books by year.
</span> */
    const %書棚 = %request.transaction.objectStore(`書棚^l);
    const %出版年索引 = %書棚.createIndex(`出版年索引^l, `出版年^l);
  }
  if (%event.oldVersion &lt; `3^lt) {
    /* <span class="comment">
~version 3 は、
`定期刊行物^l ）用に 2 つの索引を伴う新たな保管庫を導入する。
◎
Version 3 introduces a new object store for magazines with two indexes.
</span> */
    const %定期刊行物 = %書庫.createObjectStore(`定期刊行物^l);
    const %出版元索引 = %定期刊行物.createIndex(`出版元索引^l, `出版元^l);
    const %刊行頻度索引 = %定期刊行物.createIndex(`刊行頻度索引^l, `刊行頻度^l);
  }
};

%request.onsuccess = function() {
  %書庫 = %request.result; /* <span class="comment">
%書庫.`version^m は 3 になる。
◎
db.version will be 3.
</span> */
};</pre>

</aside>

<aside class="example" id="handling-versionchange">

<p>
複数の~client（~pageと~worker）が、
同じ~dbを同時に利用できる
— 互いの読取り／書込みが衝突しないことは、
~txにより確保される。
新たな~clientが（ `upgradeneeded$et ~eventを介して）当の~dbを昇格したいと求めた場合、
他のすべての~clientが その~dbの現在の~versionへの接続を~closeするまでは，それを行えない。
◎
A single database can be used by multiple clients (pages and workers) simultaneously — transactions ensure they don’t clash while reading and writing. If a new client wants to upgrade the database (via the upgradeneeded event), it cannot do so until all other clients close their connection to the current version of the database.
</p>

<p>
`versionchange$et ~eventを~listenすれば、
~clientは，新たな~clientが昇格-時に阻まれるのを避けれる。
これは、
別の~clientが当の~dbを昇格したいと求めているときに発火される。
その昇格を継続できるようにするためには、
`versionchange$et ~eventに対し，この~clientによる~dbへの`接続$が最終的に~closeされるような何かを行って反応する。
◎
To avoid blocking a new client from upgrading, clients can listen for the versionchange event. This fires when another client is wanting to upgrade the database. To allow this to continue, react to the versionchange event by doing something that ultimately closes this client’s connection to the database.
</p>

<p>
これを行う仕方の一つは、
~pageを読込直すことである：
◎
One way of doing this is to reload the page:
</p>

<pre class="lang-js">
%db.onversionchange = function() {
  /* <span class="comment">
先ず、
保存-済みでない~dataを保存する：
◎
First, save any unsaved data:
</span> */
  saveUnsavedData().then(function() {
    /* <span class="comment">
~pageが利用者からヤリトリされてない場合、
読込直す方が適切になろう。
◎
If the document isn’t being actively used, it could be appropriate to reload the page without the user’s interaction.
</span> */
    if (!document.hasFocus()) {
      location.reload();
      /* <span class="comment">
読込直すことで、
~dbは~closeされ，新たな~JSと~db定義が読込直されることになる。
◎
Reloading will close the database, and also reload with the new JavaScript and database definitions.
</span> */
    } else {
      /* <span class="comment">
文書が~focusを得ている場合、
~pageを読込直すと利用者の妨げになり得るので，手動でそうしてもらうよう利用者に依頼する：
◎
If the document has focus, it can be too disruptive to reload the page. Maybe ask the user to do it manually:
</span> */
      displayMessage("最新~versionに昇格するため、
この~pageを読込直してください。");
    }
  });
};

function saveUnsavedData() {
  /* <span class="comment">
これをどう行うかは、
~appに依存する。
◎
How you do this depends on your app.
</span> */
}

function displayMessage() {
  /* <span class="comment">
利用者に非~modal~messageを示す。
◎
Show a non-modal message to the user.
</span> */
}</pre>

<p>
もう一つの仕方は、
`接続$の `close()$m ~methodを~callすることである。
しかしながら，当の~dbに~accessしようとする後続の試みは失敗することになるので、
~appがそれを自覚できるようにしておく必要がある。
◎
Another way is to call the connection's close() method. However, you need to make sure your app is aware of this, as subsequent attempts to access the database will fail.
</p>

<pre class="lang-js">
%db.onversionchange = function() {
  saveUnsavedData().then(function() {
    %db.close();
    stopUsingTheDatabase();
  });
};

function stopUsingTheDatabase() {
  /* <span class="comment">
~appをそれ以上~dbを利用しない状態に置く。
◎
Put the app into a state where it no longer uses the database.
</span> */
}</pre>

<p>
（昇格を試みている）新たな~clientは、
`blocked$et ~eventを利用して，他の~clientが昇格を防止しているかどうか検出できる。
この~eventは、
`versionchange$et ~eventが発火された後も，他の~clientが 依然として~dbへの接続を保持しているときに発火される。
◎
The new client (the one attempting the upgrade) can use the blocked event to detect if other clients are preventing the upgrade from happening. The blocked event fires if other clients still hold a connection to the database after their versionchange events have fired.
</p>

<pre class="lang-js">
const %request = indexedDB.open("library", 4); /* <span class="comment">
~version 4 を要請する。
◎
Request version 4.
</span> */
let %blockedTimeout;

%request.onblocked = function() {
  /* <span class="comment">
他の~clientに，~dataを非同期に保存する時間を与える。
◎
Give the other clients time to save data asynchronously.
</span> */
  %blockedTimeout = setTimeout(function() {
    displayMessage("昇格が阻まれています。この~siteを表示している他の~UItabを閉じてください。");
  }, 1000);
};

%request.onupgradeneeded = function(%event) {
  clearTimeout(%blockedTimeout);
  hideMessage();
  // ...
};

function hideMessage() {
  /* <span class="comment">
以前に表示した~messageを隠す。
◎
Hide a previously displayed message.
</span> */
}</pre>

<p>
利用者は、
別の~clientが~dbを切断するのに失敗した場合に限り，上の~messageを見ることになる。
利用者がこれを見ることは決してないのが理想的だが。
◎
The user will only see the above message if another client fails to disconnect from the database. Ideally the user will never see this.
</p>
</aside>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p><small>（
この節の表記規約は、
この仕様が~UAに~~課す要件（〜するモノトスル）を集約するものでもある。
）</small></p>

<p>
この訳に利用される コレ, ~LET, ~IF, ~THROW, ~Assert, 等々の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
この仕様の~APIが定義する各種~interfaceの各~instanceは、
それが表現する抽象-~objと常に一対一に対応するので，同一視される
（例： `IDBDatabase$I ~objと，それが表現する`接続$ ）。
</p>

<p>
加えて、
次の記法も用いる：
</p>

<dl class="def-list">
	<dt>
%演算( %引数 )？
</dt>
	<dd>
~algoの中で %演算 を呼出す所の末尾に付与される記号 ？ は、
その %演算 から例外が投出され得ることを表す
（一種の ~Assert ）。
</dd>

	<dt>
%O↗
（ %O の
`~access先@
）
</dt>
	<dd>
~APIに公開される一部の型の~objは、
ある型の抽象-~objへの~accessを間接的に供するものとして定義される
（具体的には、
次項 “`専属する$” の図式に示される）。
%O がそのような型の~instanceであるとき、
%O を通して~accessされる抽象-~objは， %O↗ とも記される。
%O から %O↗ への対応関係は、
一般に多対一になることに注意。
また、
%O に対する %O↗ が別の~instanceに変わることは，決してない。
</dd>
	<dd>
%O は、
ある時点を過ぎて以降， %O↗ に~accessできなくなることもある
— %O↗ が %O よりも先に破壊された ／ %O↗ への~accessが “~closeされた” ときなど。
そうなったとしても、
%O↗ が持つ~propを反映するような，
%O が持つ~IDL属性には、
その
`値を保持し続ける@
とされるものもある。
そのような属性は、［
%O↗ を~access先とする別の~objを通して %O↗ に変更が加えられた
］としても，元の属性~値を保つ。
</dd>

	<dt>
`専属する@
</dt>
	<dd>
<p>
一部の型の~obj間には、
“専属する”
という語で，その結び付けの関係が表記される。
ある型 %A の~instance %a が，別の型 %B の~instance %b に`専属する$という関係には、
一般に，次が含意される：
</p>

<ul>
	<li>
%a は、
自身が存在し続ける限り， %b 以外の型 %B の~instanceには`専属しない$。
</li>
	<li>
%a が存在し続ける限り， %b も存在し続ける
（ %b が破壊される時点で， %a も破壊される）。
【！ （ %a は %b への強い参照を持つ） 】
</li>
</ul>

<p>
ある~instanceに`専属する$ような~instanceは，一般に複数 存在し得る。
</p>

</dd>
	<dd>
この専属するという関係は，同じ型の~instance間で定義されたり, 循環することは決してないので、
推移的に拡張して利用される。
例えば %b が また別の型 %C の~instance %c に`専属する$とき、
“%a が`専属する$ %C ~obj”
という記述は、
%c を指すことになる。
</dd>
	<dd>
<p>
次の図式に、
この関係を持つ, および
上述の~accessを供する関係を持つような，各種~objを要約する：
</p>

<table id="_hierarchy">
<caption style="font-style:italic;">
<ul>
<li>上向き矢印 “↑” を挟んだ下の~objが，上の~objに`専属する$。
<li>斜め矢印 “↗” を挟んだ右の~objが，左の~objを通して~accessされる。
</ul>
</caption>

<tbody><tr><td>【！ JS Realm？ 】
<td>【！ ↗ 】
<td>`生成元$

<tr><td>【！ ↑ 】
<td>
<td>↑

<tr><td>`接続$（ `IDBDatabase$I ）
<td>↗
<td>`~db$

<tr><td>↑
<td>
<td>

<tr><td>`~tx$（ `IDBTransaction$I ）
<td>
<td>↑

<tr><td>↑
<td>
<td>

<tr><td>`保管庫~handle$（ `IDBObjectStore$I ）
<td>↗
<td>`保管庫$

<tr><td>↑
<td>
<td>↑

<tr><td>`索引~handle$（ `IDBIndex$I ）
<td>↗
<td>`索引$

</tbody></table>

	</dd>
	<dd>

<p>
これらの型の~obj~instanceたちは、
常に，次の可換性と一意性の要件を満たすモノトスル：
</p>

		<dl>
			<dt>
`可換性@
</dt>
			<dd>
<p>
上の図式は
`<a href="https://ja.wikipedia.org/wiki/%E5%8F%AF%E6%8F%9B%E5%9B%B3%E5%BC%8F">可換</a>^_
になる。
すなわち：
</p>
				<ul>
					<li>
どの`保管庫~handle$ %H に対しても
⇒
( %H が`専属する$`接続$ ) ↗ ~EQ
( %H↗ が`専属する$`~db$ )
</li>
					<li>
どの`索引~handle$ %H に対しても
⇒
( %H が`専属する$`保管庫~handle$ ) ↗ ~EQ ( %H↗ が`専属する$`保管庫$ )
</li>
				</ul>
			</dd>

			<dt>
`一意性@
</dt>
			<dd>
2 つの`保管庫~handle$（または 2 つの`索引~handle$）
%H1, %H2 が与えられたとき
⇒
［
%H1↗, %H2↗ は，同じ~instanceに`専属する$
］~AND［
%H1↗ ~EQ %H2↗
］ならば，
%H1 ~EQ %H2
になる。
</dd>
		</dl>

<p>
この要件の目的においては、
%H↗, %H1↗, %H2↗ は、
破壊されて以降も，他と区別できる個としては（何ら~accessできる実体はないが）存在し続けるとする。
</p>

	</dd>
	<dd>
所与の型の~obj~instanceが［
作成される／取得される
］ときに［
どの~instanceに`専属する$, あるいは
どの~instanceを`~access先$にする
］ようにされるか，については、
上述の要件を満たすように，当の~objを［
作成する／取得する
］~APIの記述にて定義される。
</dd>

	<dt>
ε
</dt>
	<dd>
存在しないことを表現する特別な定数
（<a href="index.html#epsilon">詳細</a>）。
~API~methodに渡された引数がとる値 ε は、
その~methodの呼出時に，引数が省略されたことを表す
（<a href="index.html#missing-arg">詳細</a>）。
</dd>
</dl>

	</section>
	<section id="constructs">
<h2 title="Constructs">2. 各種~構成子</h2>

<p>
`名前@
は、
`DOMString$I に等価な `string$jT である。
すなわち、
空~文字列も含め，任意の長さの任意の~16-bit符号単位~列になり得る。
`名前$は常に不透明な~16-bit符号単位~列として比較される。
◎
A name is a string equivalent to a DOMString; that is, an arbitrary sequence of 16-bit code units of any length, including the empty string. Names are always compared as opaque sequences of 16-bit code units.
</p>

<div class="note">
<p>注記：
その~~結果，`名前$の比較では、
文字大小のみならず，~Unicode~textにおける他の小さな差異
— 正規化形, 制御文字の有無, その他 —
も区別される。
`Charmod-Norm$r
◎
As a result, name comparison is sensitive to variations in case as well as other minor variations such as normalization form, the inclusion or omission of controls, and other variations in Unicode text. [Charmod-Norm]
</p>

<p>
利用する~storageの仕組みの下では~supportされない名前に対しては、
実装は，~escapingに類する仕組みを利用して 格納できる名前に対応付けれる。
◎
If an implementation uses a storage mechanism which does not support arbitrary strings, the implementation can use an escaping mechanism or something similar to map the provided name to a string that it can store.
</p>
</div>

<div class="algo">
<p>
`~sort済み名前~listを作成する@
ときは、
所与の
( `~list$ %名前~群 )
に対し：
◎
To create a sorted name list from a list names, run these steps:
</p>
<ol>
	<li>
%~sort済み ~LET `~listを昇順に~sortする$( %名前~群, ~LT`符号単位$sub )
◎
Let sorted be names sorted in ascending order with the code unit less than algorithm.
</li>
	<li>
~RET %~sort済み が結付けられた新たな `DOMStringList$I ~obj
◎
Return a new DOMStringList associated with sorted.
</li>
</ol>

<p class="note">注記：
【！ details 】
これは、
`String$jT からなる `Array$jT ~obj上の
<a href="~TC39#sec-array.prototype.sort">`Array.prototype.sort^c</a>
に合致する。
この順序付けは、
各~文字列~内の~16-bit符号単位どうしを比較するための［
高効率で, 一貫した, 決定的な，~sort順序
］を与える。
この~sortは、
~alphabet順その他 どの字句的~順序にも
— 特に，代用対で表現される符号位置に対しては —
合致しない。
◎
Details
◎
This matches the Array.prototype.sort on an Array of Strings. This ordering compares the 16-bit code units in each string, producing a highly efficient, consistent, and deterministic sort order. The resulting list will not match any particular alphabet or lexicographical order, particularly for code points represented by a surrogate pair.
</p>
</div>

		<section id="database-construct">
<h3 title="Database">2.1. ~db</h3>

<div class="p">
<p>
各 `生成元$には、
0 個~以上の`~db$が結付けられる
— `~db$は，その生成元に`専属する$。
</p>

<p class="trans-note">【
過去にどの~dbを作成したか調べたいときは、
`IDBFactory$I の `databases()^m ~methodを利用できる。
】</p>

<p>
各
`~db@
は，自身に格納される~dataを保持する， 0 個~以上の`保管庫$からなる。
各`~db$ %~db は、
次に挙げるものを持つ：
</p>
◎
Each origin has an associated set of databases. A database has zero or more object stores which hold the data stored in the database.
</div>

<dl class="def-list">
	<dt>
`名前@db
◎
A database has a name＼
</dt>
	<dd>
特定の`生成元$の中で， %~db を一意に識別する`名前$であり、
%~db が存続する間 変化しない。
◎
which identifies it within a specific origin. The name is a name, and stays constant for the lifetime of the database.
</dd>

	<dt>
`~version@db
◎
A database has a version.＼
</dt>
	<dd>
%~db の~versionを表現する負でない整数。
%~db 作成-時の`~version$dbは， 0 である。
◎
When a database is first created, its version is 0 (zero).
</dd>
	<dd class="trans-note">【
%~db の作成-時には，自動的に`昇格~tx$が生じるので、
実質的には 1 （以上）として公開される（そのときに~errorが生じない限り）。
】</dd>
	<dd class="note">注記：
`~db$が同時に持ち得る~versionは一つだけである
— 同時に複数の~versionを持つような~dbは存在し得ない。
~versionは、
`昇格~tx$を通してのみ変更し得る。
◎
Each database has one version at a time; a database can’t exist in multiple versions at once. The only way to change the version is using an upgrade transaction.
</dd>

	<dt>
`昇格~tx@db
◎
A database has at most one associated upgrade transaction,＼
</dt>
	<dd>
`昇格~tx$または ε （存在しない）
— 初期~時は ε とする。
◎
 which is either null or an upgrade transaction, and is initially null.
</dd>
	<dd class="trans-note">【
所与の時点で`~db$に生じている`昇格~tx$を指す。
そのような~txは，あっても一つに限られ、
この`~db$を`~access先$とする，ある`接続$に`専属する$。
】</dd>
	<dd class="trans-note">【
“昇格~txは
`稼働して@
いる（ `running^en ）”
という，未定義な句も現れるが、
おそらく，これが ε でないことを意味する。
】</dd>
</dl>

			<section id="database-connection">
<h5 title="Database connection">2.1.1. ~db接続</h5>

<p>
~scriptが`~db$と直にヤリトリすることはない。
代わりに
`接続@
（ `connection^en ）を介して間接的に~accessする。
`接続$を利用すれば，`~db$の~objたちを操作できる。
それはまた、
その`~db$用の`~tx$を得する唯一の仕方である
◎
Script does not interact with databases directly. Instead, script has indirect access via a connection. A connection object can be used to manipulate the objects of that database. It is also the only way to obtain a transaction for that database.
</p>

<p class="trans-note">【
この訳では、
`接続$ %接続 の`~access先$の`~db$を %接続↗ とも記す。
】</p>

<p>
`接続$は，`~db$を~openすることにより作成される。
所与の`~db$を`~access先$とする，複数の`接続$が同時にあってもヨイ。
◎
The act of opening a database creates a connection. There may be multiple connections to a given database at any given time.
</p>

<p>
`接続$が~accessできる`~db$は、
その接続を~openした大域~scopeの`生成元$に`専属する$ものに限られる。
◎
A connection can only access databases associated with the origin of the global scope from which the connection is opened.
</p>

<p class="note">注記：
これは、
`Document$I の `domain$m が変更されても影響されない。
◎
This is not affected by changes to the Document's domain.
</p>

<p>
各 `接続$ %接続 には、
次に挙げるものが結付けられる
（括弧内は、
`接続$を表現する `IDBDatabase!I ~interfaceの，対応する~member）：
◎
↓</p>

<dl class="def-list">
<!-- 
	<dt>
名前
（ name$m ）
</dt>
	<dd>
~openした~dbの名前$と同じであるが、
接続$は，~dbが削除されようが その名前を保持し続ける。
</dd>
 -->

	<dt>
`~version@Cn
（ `version$m ）
◎
A connection has a version,＼
</dt>
	<dd>
作成-時に設定され、
それ以降，変化しない。
ただし，`昇格~txが中止-$された場合、
%接続↗ である`~db$は，その元の~versionに戻される。
%接続 が`~close$されて以降は変化しない。
◎
which is set when the connection is created. It remains constant for the lifetime of the connection unless an upgrade is aborted, in which case it is set to the previous version of the database. Once the connection is closed the version does not change.
</dd>
	<dd class="trans-note">【
より詳細には、
%接続↗ の`昇格~tx$dbが`完遂-$して以降は変化しない。
】</dd>

	<dt>
`状態@Cn
◎
Each connection has a close pending flag＼
</dt>
	<dd>
%接続 の`状態$Cnは［
`~open中@i
→
`~close待ち@i
→
`~close済み@i
］の順に推移する。
後戻りすることはない。
◎
which is initially false.
</dd>
	<dd class="trans-note">【
この “状態” は，原文では
“`close pending flag^en（~close待ちか）”
という（上の `~open中$i と `~close待ち$i を区別する）真偽値で表現されているが、
原文の語
“`open^en”, “`close pending^en”, “`closed^en”
と状態遷移との対応関係を明瞭にするため，この訳では上のような定義に代えている
（ “後戻りしない” もこの訳による補完）。
】</dd>
	<dd>
<p>
状態が `~close済み$i になった %接続 は
<dfn>~closeされた</dfn>
ともいう
（そのようにする試みを<dfn>~closeする</dfn>という）。
%接続 は、
次のときに，`~close$され得る／させれる：
◎
When a connection is initially created it is in an opened state. The connection can be closed through several means.＼
</p>
		<ul>
			<li>
%接続 は、
それを作成した実行~文脈が破壊された場合には
（例えば、
利用者が別~pageへ~~移動したことに因り），
`~close$される。
◎
If the execution context where the connection was created is destroyed (for example due to the user navigating away from that page), the connection is closed.＼
</li>
			<li>
`~db接続を~closeする$手続きを利用すれば、
%接続 を明示的に`~close$させれる。
◎
The connection can also be closed explicitly using the steps to close a database connection. When the connection is closed its close pending flag is always set to true if it hasn’t already been.
</li>
			<li>
<p>
%接続 は、
例外的な状況下でも~UAにより~closeされてよい／され得る
— 例えば、
~file~systemへの~accessを失ったか, ~access許可が変更されたとき，あるいは当の生成元に対する~storageが~clearされたことに因り。
これが生じた場合、
~UAは次を走らすモノトスル
⇒
`~db接続を~closeする$( %接続, `強制する^i )
◎
A connection may be closed by a user agent in exceptional circumstances, for example due to loss of access to the file system, a permission change, or clearing of the origin’s storage. If this occurs the user agent must run close a database connection with the connection and with the forced flag set to true.
</p>

<p>
`close@et
~eventは、
そのような例外的な状況下において当の`接続$に向けて発火される。
【この段落は、この訳による補完。原文における `close^et の<a href="~HTMLindex#event-close">参照-先（~HTML仕様）</a>の記述は、全く~~関係ないので。】
</p>

			</li>
		</ul>
	</dd>

	<dt>
`保管庫~集合@Cn
（ `objectStoreNames$m ）
◎
A connection has an object store set,＼
</dt>
	<dd>
%接続 の作成-時に， %接続↗ に`専属する$`保管庫$たちの集合に初期化される。
この集合の内容は、
%接続↗ の`昇格~tx$dbが`稼働して$いる間を除いて，一定であり続ける。
◎
which is initialized to the set of object stores in the associated database when the connection is created. The contents of the set will remain constant except when an upgrade transaction is running.
</dd>
</dl>

<p>
`接続$の`親~標的を取得する$~algoは、
~NULL を返す。
◎
A connection's get the parent algorithm returns null.
</p>

<p>
`versionchange@et
~eventは、
`~db$を昇格する／削除するよう試みたとき，その~dbを~openしている各 `接続$
（それを試みている当の`接続$は除く）
に向けて発火される。
これは、
昇格／削除-を続行できるようにするために，`接続$を~closeする~~機会を与える。
◎
A versionchange will be fired at an open connection if an attempt is made to upgrade or delete the database. This gives the connection the opportunity to close to allow the upgrade or delete to proceed.
</p>

			</section>
		</section>
		<section id="object-store-construct">
<h3 title="Object store">2.2. 保管庫</h3>

<p>
`保管庫@
（ `object store^en ）が、
`~db$に~dataを格納するための，首な~storageの仕組みである。
◎
An object store is the primary storage mechanism for storing data in a database.
</p>

<p>
どの`保管庫$も，ある`~db$に`専属する$。
`~db$に専属する`保管庫$の集合は、
`昇格~tx$を利用することを通して
— すなわち，`upgradeneeded$et ~eventに呼応して —
のみ変更できる。
新たな~dbが作成された時点では，それに`専属する$`保管庫$はない。
◎
Each database has a set of object stores. The set of object stores can be changed, but only using an upgrade transaction, i.e. in response to an upgradeneeded event. When a new database is created it doesn’t contain any object stores.
</p>

<p>
各 `保管庫$ %保管庫 は、
次に挙げるものを持つ
（括弧内は、
保管庫を`~access先$とする `IDBObjectStore!I ~objの対応する~member）：
◎
↓</p>

<dl class="def-list">
	<dt>
`~record~list@Os
◎
An object store has a list of records＼
</dt>
	<dd>
%保管庫 内に格納される`~record$の~listを保持する。
~list内の`~record$どうしは、
それらの`~key$の`昇順$に~sortされる。
同じ保管庫~内で，複数の~recordの`~key$が`等しく$なることは、
決してない。
◎
which hold the data stored in the object store. Each record consists of a key and a value. The list is sorted according to key in ascending order. There can never be multiple records in a given object store with the same key.
</dd>

	<dt>
`名前@Os
（ `name$m ）
◎
An object store has a name,＼
</dt>
	<dd>
`名前$。
この名前は、
どの時点においても， %保管庫 が`専属する$`~db$に`専属する$`保管庫$たちにわたって一意になる。
◎
which is a name. At any one time, the name is unique within the database to which it belongs.
</dd>

	<dt>
`~key~path@Os
（ `keyPath$m ）
◎
An object store optionally has a key path.＼
</dt>
	<dd>
`妥当な~key~path$, または ε 。
%保管庫 の作成-時に設定され、
それ以降（ ε かどうかも含め），変化しない。
◎
↓</dd>
	<dd>
`~key~path$Osが［
非 ε ／ ε
］であることは、
`~record$の`~key$として，`~record$の`値$の［
内にある／外から与えられた
］それを利用すること
（ <dfn id="dfn-in-line-keys">`use in-line keys^en</dfn>† ／
<dfn id="dfn-out-of-line-keys">`use out-of-line keys^en</dfn>† ）
を意味する。
◎
If the object store has a key path it is said to use in-line keys. Otherwise it is said to use out-of-line keys.
</dd>
	<dd class="trans-note">【†
この訳では、
これらの用語は利用せず，単に［
非 ε ／ ε
］で区別する。
】</dd>
	<dd class="trans-note">【
索引の`~key~path$Ixと違って、
`保管庫$の~key~pathは，空~文字列をとり得ない。
また、
`~key生成器$を持つ場合は，文字列の~listもとり得ない。
】</dd>
	<dd class="trans-note">【
`~key~path$Os %P ~NEQ ε の場合、
%保管庫 の`~record~list$Osは，それを成すどの`~record$ %R も［
%R の`~key$ ~EQ~cmpkey `値から~keyを抽出する$( %R の`値$, %P )
］を満たすように拘束される。
】</dd>

	<dt>
`~key生成器$
◎
An object store optionally has a key generator.
</dt>
	<dd>
%保管庫 が~key生成器を持つかどうか（ `autoIncrement$m ）は、
%保管庫 の作成-時に設定され，それ以降は変化しない。
◎
↓</dd>
</dl>

<p>
`保管庫$を成す~recordの`~key$は、
次に挙げるいずれかの~sourceから導出され得る。
◎
An object store can derive a key for a record from one of three sources:
</p>

<p class="trans-note">【
すなわち，`~record~list$Osは、
外部から与えられる一連の値から，一連の［
~record｛ 導出された~key ： 値 ｝
］で拡充される。
】</p>

<ul>
	<li>
~keyが必要になる度に，単調に増加する番号による~keyを`~key生成器$から自動的に生成する。
◎
A key generator. A key generator generates a monotonically increasing numbers every time a key is needed.
</li>
	<li>
所与の値から，`~key~path$Osを用いて`~keyを抽出-$する。
◎
Keys can be derived via a key path.
</li>
	<li>
保管庫に値を格納するときに，明示的に
【すなわち，格納-用の~API~methodの引数にて】
~keyを指定する。
◎
Keys can also be explicitly specified when a value is stored in the object store.
</li>
</ul>

			<section id="object-store-handle-construct">
<h5 title="Object store handle">2.2.1. 保管庫~handle</h5>

<p>
~scriptが`保管庫$と直にヤリトリすることはない。
代わりに，ある`~tx$の中で
`保管庫~handle@
を介して間接的に~accessする。
◎
Script does not interact with object stores directly. Instead, within a transaction, script has indirect access via an object store handle.
</p>

<p>
各 `保管庫~handle$ %H には、
次に挙げるものが結付けられる
（括弧内は、
対応する `IDBObjectStore!I ~interface~member）：
◎
↓</p>

<dl class="def-list">
	<dt>
`保管庫@OsH
◎
An object store handle has an associated object store＼
</dt>
	<dd>
%H の`~access先$とされる`保管庫$。
【この訳では、もっぱら %H↗ と記す。】
◎
↑↑</dd>

	<dt>
`~tx@OsH
（ `transaction$m ）
◎
and an associated transaction.＼
</dt>
	<dd>
%H が`専属する$`~tx$。
【この訳では、この用語は利用せず，単にこのように記す。】
◎
↑↑</dd>
	<dd>
%H の［
取得-時／作成-時
］に，`可換性$と`一意性$の要件が満たされるように設定される。
◎
Multiple handles may be associated with the same object store in different transactions, but there must be only one object store handle associated with a particular object store within a transaction.
</dd>
	<dt>
`索引~集合@OsH
（ `indexNames$m ）
◎
An object store handle has an index set,＼
</dt>
	<dd>
%H の作成-時に，［
%H↗ に`専属する$`索引$たちからなる集合
］に初期化される。
◎
which is initialized to the set of indexes that reference the associated object store when the object store handle is created.＼
</dd>
	<dd>
この集合の内容は、
%H が`専属する$~txが［
`昇格~tx$であって, `稼働して$いる間
］を除いて，一定であり続ける。
◎
The contents of the set will remain constant except when an upgrade transaction is running.
</dd>
	<dt>
`名前@OsH
（ `name$m ）
◎
An object store handle has a name,＼
</dt>
	<dd>
%H の作成-時に %H↗ の`名前$Osに初期化される。
◎
which is initialized to the name of the associated object store when the object store handle is created.＼
</dd>
	<dd>
この名前は、
%H が`専属する$~txが［
`昇格~tx$であって, `稼働して$いる間
］を除いて，一定であり続ける。
◎
The name will remain constant except when an upgrade transaction is running.
</dd>
</dl>

			</section>
		</section>
		<section id="_record-construct">
<h3 class="trans-note">2.X. ~record</h3>

<p>
［
`保管庫$の`~record~list$Os ／
`索引$の`~record~list$Ix
］内に格納される各
`~record@
は、
以下の節に述べる［
`~key$, および`値$
］からなる。
</p>

<p>
所与の
( %~key, %値 )
を
( `~key$, `値$ )
とする`~record$は、
｛ %~key ： %値 ｝
とも表記される。
</p>

<p class="trans-note">【
この用語は，原文では保管庫のそれと索引のそれとで区別して定義されているが、
それらの総称を表す箇所も多いため，この訳では総称として定義する。
】</p>

		</section>
		<section id="value-construct">
<h3 title="Values">2.3. 値</h3>

<p>
各`~record$には
`値@
が結付けられる。
~UAは、
`直列化-可能$な どの~objも~supportするモノトスル†。
これには、
少なくとも次に挙げるものが含まれる
⇒＃
`String$jT などの単純~型の~primitive値,
`Date$jT,
`Object$jT,
`Array$jT,
`File$I,
`Blob$I,
`ImageData$I,
等々
◎
Each record is associated with a value. User agents must support any serializable object. This includes simple types such as String primitive values and Date objects as well as Object and Array instances, File objects, Blob objects, ImageData objects, and so on.＼
</p>

<p class="trans-note">【†
この要件は、
`保管庫$内の`~record$に限られる。
`索引$内の`~record$の`値$は、
常に その`参照先~record$の`~key$として与えられるので。
】</p>

<p>
~recordの`値$は、
参照~渡しではなく，値~渡しにより［
格納される／検索取得される
］。
［
格納-時に渡した／検索取得して得られた
］値が後で変更されても、
~db内に格納されている~recordには影響しない。
◎
Record values are stored and retrieved by value rather than by reference; later changes to a value have no effect on the record stored in the database.
</p>

<p>
~recordの`値$は、
`StructuredSerializeForStorage$jA 演算から出力される`~Record$である。
◎
Record values are Records output by the StructuredSerializeForStorage operation.
</p>

		</section>
		<section id="key-construct">
<h3 title="Keys">2.4. ~key</h3>

<p>
索引付き~db内に格納されている`~record$たちを効率的に検索取得するため、
`~record$たちは，各自の
`~key@
に則って組織化される。
◎
In order to efficiently retrieve records stored in an indexed database, each record is organized according to its key.
</p>

<p>
各 `~key$には、
次に挙げるものが結付けられる
◎
↓</p>
<dl class="def-list">
	<dt>
`種別@key
◎
A key has an associated type＼
</dt>
	<dd>
`number@i
／
`date@i
／
`string@i
／
`binary@i
／
`array@i
◎
which is one of: number, date, string, binary, or array.
</dd>

	<dt>
`値@key
◎
A key also has an associated value,＼
</dt>
	<dd>
<p>
~keyの`種別$keyに応じて，次に挙げる型の値をとる：
</p>
		<ul class="switch">
			<li>
`number$i ／ `date$i
⇒
`unrestricted double$I
</li>
			<li>
`string$i
⇒
`DOMString$I
</li>
			<li>
`binary$i
⇒
`~byte列$
</li>
			<li>
`array$i
⇒
0 個以上の他の`~key$（種別 `array$i のものも含む）からなる`~list$
</li>
		</ul>
◎
which will be either: an unrestricted double if type is number or date, a DOMString if type is string, a byte sequence if type is binary, or a list of other keys if type is array.
</dd>
</dl>

<p>
~ES `ECMA-262$r 値は、
`値を~keyに変換する$手続きに従って`~key$に変換される。
◎
An ECMAScript [ECMA-262] value can be converted to a key by following the steps to convert a value to a key.
</p>

<div class="note">
<p>
次に挙げる~ES型が，~keyとして妥当になる：
◎
The following ECMAScript types are valid keys:
</p>

<ul>
	<li>
`NaN^jv 以外の `Number$jT ~primitive値。
`Infinity^jv, `-Infinity^jv も含まれる。
◎
Number primitive values, except NaN. This includes Infinity and -Infinity.
</li>
	<li>
`Date$jT ~objであって，その
`DateValue^sl 内部~slotは `NaN^jv でないもの。
◎
Date objects, except where the [[DateValue]] internal slot is NaN.
</li>
	<li>
`String$jT ~primitive値。
◎
String primitive values.
</li>
	<li>
各種 `~buffer~source型$に対応する型の~obj
（ `ArrayBuffer$jT, あるいは `Uint8Array$jT などの~buffer~view）。
◎
ArrayBuffer objects (or views on buffers such as Uint8Array).
</li>
	<li>
`Array$jT ~objであって、［
配列~内の どの~itemも定義されていて，~keyとして妥当である
］, かつ［
（直接的にも間接的にも）自身を包含していない
］もの。
特に，空な配列は妥当である。
配列は，他の配列を包含し得る。
◎
Array objects, where every item is defined, is itself a valid key, and does not directly or indirectly contain itself. This includes empty arrays. Arrays can contain other arrays.
</li>
</ul>

<p>
他の~ES値を`~key$に変換しようと試みても失敗することになる。
◎
Attempting to convert other ECMAScript values to a key will fail.
</p>

</div>

<p>
`種別$key `array$i の`~key$を特に
`配列~key@
という。
`配列~key$の`値$keyを成す各`~item$を
`下位key@
という。
◎
An array key is a key with type array. The subkeys of an array key are the items of the array key's value.
</p>

<div class="algo">
<p>
2 つの`~key$ %a, %b を比較する関数
`Compare@( %a, %b )
は、
次で定義される：
◎
To compare two keys a and b, run these steps:
</p>

<ol>
	<li>
<p>
`~key$の各 `種別$key 間の大小関係を［
`number$i ~LT `date$i ~LT `string$i ~LT `binary$i ~LT `array$i
］と定義する下で：
</p>
		<ol>
			<li>
~IF ［
%a の`種別$key ~GT %b の`種別$key
］
⇒
~RET 1
</li>
			<li>
~IF ［
%a の`種別$key ~LT %b の`種別$key
］
⇒
~RET −1
</li>
		</ol>
◎
Let ta be the type of a.
◎
Let tb be the type of b.
◎
If ta does not equal tb, then run these steps:
◎
If ta is array, then return 1.
◎
If tb is array, then return -1.
◎
If ta is binary, then return 1.
◎
If tb is binary, then return -1.
◎
If ta is string, then return 1.
◎
If tb is string, then return -1.
◎
If ta is date, then return 1.
◎
Assert: tb is date.
◎
Return -1.
</li>
	<li>
%va ~LET %a の`値$key
◎
Let va be the value of a.
</li>
	<li>
%vb ~LET %b の`値$key
◎
Let vb be the value of b.
</li>
	<li>
<p>
%a の`種別$keyに応じて：
◎
Switch on ta:
</p>
		<dl class="switch">
			<dt>`number$i</dt>
			<dt>`date$i</dt>
			<dd>
				<ol>
					<li>
~IF［
%va ~GT %vb
］
⇒
~RET 1
◎
If va is greater than vb, then return 1.
</li>
					<li>
~IF［
%va ~LT %vb
］
⇒
~RET −1
◎
If va is less than vb, then return -1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>

			<dt>`string$i</dt>
			<dd>
				<ol>
					<li>
~IF［
%va は %vb `未満の符号単位~列$である
］
⇒
~RET −1
◎
If va is code unit less than vb, then return -1.
</li>
					<li>
~IF［
%vb は %va `未満の符号単位~列$である
］
⇒
~RET 1
◎
If vb is code unit less than va, then return 1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>

			<dt>`binary$i</dt>
			<dd>
				<ol>
					<li>
~IF［
%va は %vb `未満の~byte列$である
］
⇒
~RET −1
◎
If va is byte less than vb, then return -1.
</li>
					<li>
~IF［
%vb は %va `未満の~byte列$である
］
⇒
~RET 1
◎
If vb is byte less than va, then return 1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>

			<dt>`array$i</dt>
			<dd>
				<ol>
					<li>
<p>
~EACH( 整数 %i ~IN { 0 〜 min( %va の`~size$, %vb の`~size$ ) ~MINUS 1 } )
に対し，昇順に
◎
Let length be the lesser of va’s size and vb’s size.
◎
Let i be 0.
◎
While i is less than length, then:
</p>
						<ol>
							<li>
%c ~LET `Compare$( %va[ %i ], %vb[ %i ] )
◎
Let c be the result of recursively comparing two keys with va[i] and vb[i].
</li>
							<li>
~IF［
%c ~NEQ 0
］
⇒
~RET %c
◎
If c is not 0, return c.
◎
Increase i by 1.
</li>
						</ol>
					</li>
					<li>
~IF［
%va の`~size$ ~GT %vb の`~size$
］
⇒
~RET 1
◎
If va’s size is greater than vb’s size, then return 1.
</li>
					<li>
~IF［
%va の`~size$ ~LT %vb の`~size$
］
⇒
~RET −1
◎
If va’s size is less than vb’s size, then return -1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>
</div>

<div class="algo">
<p>
2 つの`~key$ %a, %b の大小関係は、
`Compare$( %a, %b ) の結果に応じて：
◎
↓</p>

<ul class="switch">
	<li>
1 ならば
⇒
%a は %b
`より大きい@
とされる。
◎
The key a is greater than the key b if the result of comparing two keys with a and b is 1.
</li>
	<li>
−1 ならば
⇒
%a は %b
`より小さい@
とされる。
◎
The key a is less than the key b if the result of comparing two keys with a and b is -1.
</li>
	<li>
0 ならば
⇒
%a は %b に
`等しい@
とされる。
◎
The key a is equal to the key b if the result of comparing two keys with a and b is 0.
</li>
</ul>
</div>

<p class="note">注記：
上の規則の結果として、
`-Infinity^jv が， `~key$がとり得る最小な値になる。
【！ Number keys are less than ... ↑】
`~key$がとり得る最大な値は無い
— いかなる`配列~key$に対しても、
その末尾に新たな`~key$を付加した結果の配列は，より大きくなるので。
◎
As a result of the above rules, negative infinity is the lowest possible value for a key. Number keys are less than date keys. Date keys are less than string keys. String keys are less than binary keys. Binary keys are less than array keys. There is no highest possible key value. This is because an array of any candidate highest key followed by another key is even higher.
</p>

<p class="note">注記：
種別 `binary$i の`~key$を成す各`~byte$は、
無符号~値（範囲 { 0 〜 255 } ）として比較される
— 有符号~値（範囲 { −128 〜 127 }）ではなく。
◎
Members of binary keys are compared as unsigned byte values (in the range 0 to 255 inclusive) rather than signed byte values (in the range -128 to 127 inclusive).
</p>

<p>
この訳では、
表記
“<dfn id="_key_comparison">%関係記号<sub>key</sub></dfn>”
を用いて、
次を表すことにする：
</p>

<ul>
	<li>
2 つの`~key$ %a, %b の比較（ `Compare$ ）
</li>
	<li>
2 つの`~key$~pair %p ~EQ ( %a1, %a2 ), %q ~EQ ( %b1, %b2 ) の比較†
</li>
	<li>
`~key$ %k が`~key範囲$ %R に`入る$かどうか
</li>
	<li>
`~key$ %k が`~key$の集合 %K に含まれるかどうか
</li>
</ul>

<table class="_row"><thead><tr><th>表記
<th>定義
</thead>

<tbody><tr><th style="min-width: 7em;">%a ~GT~cmpkey %b
<td>%a は %b `より大きい$

<tr><th>%a ~LT~cmpkey %b
<td>%a は %b `より小さい$

<tr><th>%a ~EQ~cmpkey %b
<td>%a は %b に`等しい$

<tr><th>%a ~GTE~cmpkey %b
<td>
［
%a ~GT~cmpkey %b
］~OR［
%a ~EQ~cmpkey %b
］

<tr><th>%a ~LTE~cmpkey %b
<td>
［
%a ~LT~cmpkey %b
］~OR［
%a ~EQ~cmpkey %b
］

<tr><th>%p ~GT~cmpkey %q
<td>
［
%a1 ~GT~cmpkey %b1
］~OR［［
%a1 ~EQ~cmpkey %b1
］~AND［
%a2 ~GT~cmpkey %b2
］］

<tr><th>%p ~LT~cmpkey %q
<td>
［
%a1 ~LT~cmpkey %b1
］~OR［［
%a1 ~EQ~cmpkey %b1
］~AND［
%a2 ~LT~cmpkey %b2
］］

<tr><th>%p ~EQ~cmpkey %q
<td>
［
%a1 ~EQ~cmpkey %b1
］~AND［
%a2 ~EQ~cmpkey %b2
］

<tr><th>%p ~GTE~cmpkey %q
<td>
［
%p ~GT~cmpkey %q
］~OR［
%p ~EQ~cmpkey %q
］

<tr><th>%p ~LTE~cmpkey %q
<td>
［
%p ~LT~cmpkey %q
］~OR［
%p ~EQ~cmpkey %q
］

<tr><th>%k ~IN~cmpkey %R
<td>%k は %R に`入る$

<tr><th>%k ~NIN~cmpkey %R
<td>%k ~IN~cmpkey %R の否定

<tr><th>%k ~IN~cmpkey %K
<td>ある %key ~IN %K に対し， %k ~EQ~cmpkey %key

<tr><th>%k ~NIN~cmpkey %K
<td>%k ~IN~cmpkey %K の否定

</tbody></table>

<p>†
`~key$~pairの比較は、
簡潔に記すための，この訳による追加的な定義であり、
もっぱら，`索引$の~record
（または，［
それを意図して, あるいは それとの比較を意図して
］与えられる~key値~pair）
を比較するときに用いられる。
</p>

		</section>
		<section id="key-path-construct">
<h3 title="Key path">2.5. ~key~path</h3>

<p>
`~key~path@
は文字列，または文字列の~listであり、
`値$から`~key$を抽出する方法を定義する。
次に挙げるものが
`妥当な~key~path@
とされる：
◎
A key path is a string or list of strings that defines how to extract a key from a value. A valid key path is one of:
</p>

<ul>
	<li>
空~文字列
◎
An empty string.
</li>
	<li>
`識別子@
— すなわち，~ESの `IdentifierName$jT 生成規則に合致する文字列
◎
An identifier, which is a string matching the IdentifierName production from the ECMAScript Language Specification [ECMA-262].
</li>
	<li>
複数個の`識別子$を `002E^U (`.^l) で分離して~~連結して得られる，文字列
◎
A string consisting of two or more identifiers separated by periods (U+002E FULL STOP).
</li>
	<li>
上の要件に適合する文字列のみを包含するような，空でない~list
◎
A non-empty list containing only strings conforming to the above requirements.
</li>
</ul>

<p class="note">注記：
~key~pathの中では space は許容されない。
◎
Spaces are not allowed within a key path.
</p>

<p>
`~key~path$で~accessできる部位は、
`StructuredSerializeForStorage$jA により明示的に複製される~propに限られる
— 次に挙げる各種~型に特有な~propも含まれる：
◎
Key path values can only be accessed from properties explicitly copied by StructuredSerializeForStorage, as well as the following type-specific properties:
</p>

<table class="_row">
<thead><tr><th>型
◎
Type
<th>~prop
◎
Properties
</thead>

<tbody><tr><td>`Blob$I
<td>`size^m, `type^m

<tr><td>`File$I
<td>`name^m, `lastModified^m

<tr><td>`Array$jT
<td>`length^js

<tr><td>`String$jT
<td>`length^js

</tbody></table>

<p class="trans-note">【
`File^I に対しては、
`Blob^I を継承するので，上に挙げた `Blob^I の~propも含まれることになる。
】</p>

<aside class="trans-note">
<p>【補記：】</p>

<p>
`~key~path$は、
~~任意に与えられる値（ ~obj ）の中のある一定の部位を表現する。
その目的は、
外から与える一連の値で，`保管庫$を`拡充する^emとき
— すなわち，値を`保管庫$の`~record~list$Osの中に`~record$の`値$として格納するとき —
に、
それらの値の中の［
~key~pathが指す部位に与えられている~data
］から，自動的に`~key$を導出することである。
あるいは、
`索引$を，それが`専属する$`保管庫$の`~record~list$Osに基づいて拡充するときにも、
同様に利用される。
例えば：
</p>

<ul>
	<li>
文字列による~key~path `a.b^l は、
任意の値 ~varV に対し，
`~varV.a.b^jv で~accessされる部位を表す
（文字列の中の各 `002E^U (`.^l) が階層を辿る~pathの分離子を表す）。
~varV ~EQ `{ a: { b: "c" }}^jv であれば、
この~key~pathは，`~key$として `c^l を抽出する。
［
`~varV.a.b^jv に~accessし得ない場合
（例： `~varV.a^jv は~objでない）／
`~varV.a.b^jv の値が~keyとして妥当でない場合
（例： `undefined^jv ）
］、
~varV からは~keyは抽出されないことになる
— これらの事例は、
この仕様では［
前者は `失敗^i（ `failure^en ）／
後者は `妥当でない^i（ `invalid^en ）
］という定数で表現されている。
</li>
	<li>
空~文字列も~key~pathとして妥当であり、
それが指す部位は，値が何であろうと値~全体になる
（この~key~pathは`保管庫$には許容されないが）。
すなわち、
抽出される~keyは，常に値そのものになる。
</li>
	<li>
文字列の~listによる~key~pathが指す部位は、
その中の［
~key~pathとしての各 文字列が指すが部位
］からなる配列になる。
例えば~key~path
« `a.b^l, `x.y.z^l »
は、
値 ~varV から，`配列~key$
`[ ~varV.a.b, ~varV.x.y.z ]^jv
を~keyとして抽出する。
</li>
</ul>

</aside>

		</section>
		<section id="index-construct">
<h3 title="Index">2.6. 索引</h3>

<p>
`~key$以外の手段を通して，`保管庫$内の`~record$たちを検索取得できると有用になることもときどきある。
`索引@
（ `index^en ）により、
`保管庫$内の`~record$たちを，それらの`値$の~propを通して検索できるようになる。
◎
It is sometimes useful to retrieve records in an object store through other means than their key. An index allows looking up records in an object store using properties of the values in the object stores records.
</p>

<p>
索引は、
ある~~目的に特化された`~record$たちからなる持続的な~storageであり、
その~dataは，以下に述べるように
索引が`専属する$`保管庫$の~dataに基いて拡充される。
各 索引は、
次に挙げるものを持つ
（括弧内は、
索引を`~access先$とする `IDBIndex!I ~objの対応する~member ）：
◎
An index is a specialized persistent key-value storage and has a referenced object store. The index has a list of records which hold the data stored in the index. The records in an index are automatically populated whenever records in the referenced object store are inserted, updated or deleted. There can be several indexes referencing the same object store, in which changes to the object store cause all such indexes to get updated.
</p>

<dl class="def-list">
	<dt>
`参照先の保管庫@
◎
↑</dt>
	<dd>
索引が`専属する$`保管庫$。
【この訳では、この用語は利用せず，単にこのように記す。】
索引の作成-時に設定される。
以下の各項では、
単に %保管庫 と記す。
◎
↑↑</dd>

	<dt>
`~record~list@Ix
◎
↓</dt>
	<dd>
<a id="index-records"></a>
<a id="index-keys"></a>
<a id="index-values"></a>
<p>
索引に格納される~dataを保持する，一連の`~record$からなる~list。
この~listは、
%保管庫 の`~record~list$Os %L から自動的に拡充される：
</p>

		<ul>
			<li>
索引の作成-時に， %L に基づいて自動的に拡充される。
</li>
			<li>
%L ［
に~recordが挿入される ／
から~recordが削除される ／
の~recordの`値$が更新される
］度に，自動的に拡充される。
</li>
		</ul>

<p>
%L に変更が加えられる度に， %保管庫 に`専属する$すべての索引は更新されることになる。
</p>

<p class="trans-note">【
どのような規則に基づいて更新されるかの詳細は、
<a href="#_populating-an-index">§ 索引の拡充-法</a>
に述べる。
】</p>

◎
↑↓</dd>

	<dt>
`~key~path@Ix （ `keyPath$m ）
◎
↓</dt>
	<dd>
<p>
`~key~path$。
</p>

<p>
索引~内のどの~record %R1 についても：
</p>
		<ul>
			<li>
<p>
%R1 の`値$は  %保管庫 内のある~record %R の`~key$で与えられる。
</p>

<div class="trans-note">
<p>【
したがって，`保管庫$における`~key$の一意性から、
索引の`~record~list$Ix から %保管庫 の`~record~list$Os %L へは，次の対応関係がある
⇒
%R1 → %R ~EQ ［
%R1 の`値$を`~key$とする %L 内の~record
］
</p>

<p>
この訳では、
この %R を指して %R1 の
`参照先~record@
と称する。
】</p>
</div>
			</li>
			<li>
%R1 の`~key$は［
%R の`値$の中の，この`~key~path$Ixが指す部位
］から`抽出される~key$（たちのいずれか）で与えられる。
</li>
		</ul>
<p>
索引の`~record~list$Ixは，そのように %R から導出される %R1 たちで拡充される。
</p>

◎
The values in the index’s records are always values of keys in the index’s referenced object store. The keys are derived from the referenced object store’s values using a key path. If a given record with key X in the object store referenced by the index has the value A, and evaluating the index’s key path on A yields the result Y, then the index will contain a record with key Y and value X.
</dd>

	<dd>
<aside class="example" id="example-index-entries">

<p>
例えば，
%R ~EQ ｛ `123^c ： `{ name: "Alice", title: "CEO" }^c ｝
で，索引の`~key~path$Ixが `name^l ならば、
~key `Alice^l が抽出され，索引は
%R1 ~EQ｛ `Alice^l ： `123^c ｝
を包含することになる。
◎
For example, if an index’s referenced object store contains a record with the key 123 and the value { name: "Alice", title: "CEO" }, and the index’s key path is "name" then the index would contain a record with the key "Alice" and the value 123.
</p>

</aside>

<p>
上述の %R （すなわち， %R1 の`参照先~record$）の`値$は、
%R1 の
`参照先の値@
と呼ばれる。
【この訳では、この用語は利用せず，単に`参照先~record$の値と記す。】
◎
Records in an index are said to have a referenced value. This is the value of the record in the index’s referenced object store which has a key equal to the index’s record’s value. So in the example above, the record in the index whose key is Y and value is X has a referenced value of A.
</p>

<aside class="example" id="example-index-referenced-values">

<p>
先の例の
%R1 ~EQ｛ `Alice^l ： `123^c ｝
の`参照先~record$の値は，
`{ name: "Alice", title: "CEO" }^c
になる。
◎
In the preceding example, the record in the index with key "Alice" and value 123 would have a referenced value of { name: "Alice", title: "CEO" }.
</p>

</aside>

<p class="note">注記：
【この段落の内容は、<a href="#_populating-an-index">§ 索引の拡充-法</a>に移譲。】
◎
Each record in an index references one and only one record in the index’s referenced object store. However there can be multiple records in an index which reference the same record in the object store. And there can also be no records in an index which reference a given record in an object store.
</p>

<p>
索引~内の`~record$たちは、
常にその~keyに則って~sortされる。
保管庫と違い、
索引は，同じ~keyを伴う複数の~recordを包含し得るので、
それらの~recordは更に，それらの`値$（すなわち，`参照先~record$の~key）に則って~sortされる。
◎
The records in an index are always sorted according to the record's key. However unlike object stores, a given index can contain multiple records with the same key. Such records are additionally sorted according to the index's record's value (meaning the key of the record in the referenced object store).
</p>
	</dd>

	<dt>
`名前@Ix
（ `name$m ）
◎
An index has a name,＼
</dt>
	<dd>
`名前$。
この名前は、
どの時点においても，同じ`保管庫$に`専属する$索引たちにわたって一意になる。
◎
which is a name. At any one time, the name is unique within index’s referenced object store.
</dd>

	<dt>
`一意か@Ix
（ `unique$m ）
◎
An index has a unique flag.＼
</dt>
	<dd>
真偽値。
~T にされた下では、
索引の~record~listは［
索引~内のどの 2 つの`~record$も同じ~keyを持たない
］条件の下で拡充される。
索引が`専属する$`保管庫$にて［
`~record$を 挿入する／改変する
］ような試みは、［
索引の`~key~path$Ixを用いて その~recordの値から`抽出される~key$（たちのいずれか）
］が［
索引~内のある~recordの~key
］と同じになる（`等しい$）ならば，失敗する。
◎
When true, the index enforces that no two records in the index has the same key. If a record in the index’s referenced object store is attempted to be inserted or modified such that evaluating the index’s key path on the records new value yields a result which already exists in the index, then the attempted modification to the object store fails.
</dd>
	<dd class="trans-note">【
新たな`索引$を作成する試みも，この条件を満たせないときは同様に失敗する。
この場合の取扱いは
`IDBObjectStore.createIndex()$m
にて述べられる。
】</dd>

	<dt>
`複-~entryか@Ix
（ `multiEntry$m ）
◎
An index has a multiEntry flag.＼
</dt>
	<dd>
<p>
真偽値。
これは、
索引の`~key~path$Ixが指す（ %保管庫 に追加された`~record$の）部位が配列であるとき，索引がどう挙動するかに影響する：
◎
This flag affects how the index behaves when the result of evaluating the index’s key path yields an array key.＼
</p>
		<ul>
			<li>
~F の場合
⇒
索引には，その配列をそのまま`配列~key$とするような，単独の`~record$が追加される。
◎
If its multiEntry flag is false, then a single record whose key is an array key is added to the index.＼
</li>
			<li>
~T の場合
⇒
索引には，その配列~内の重複を除いた各`~key$ %key ごとに，［
%key を`~key$にするような，`~record$
］が追加される。
この場合、
`~key~path$Ixは文字列の~listをとり得ない。
◎
If its multiEntry flag is true, then one record is added to the index for each of the subkeys.
</li>
		</ul>
	</dd>
	<dd class="trans-note">【
この機能により、
各~recordに複数の “タグ” が付与されているような`~record~list$Osに対し，タグで検索するための索引を作成したり、
ある部位においてのみ異なる多数の`~record$を，一つに集約した上で取扱うことが可能になる。
】</dd>
</dl>

			<section id="_populating-an-index">
<h5>【索引の拡充-法】</h5>

<p class="trans-note">【
この節は、
原文の記述から導出した，この訳による補完である。
】</p>

<p>
所与の`索引$ %索引 に対し，［
%索引 の`~record~list$Ix %L1
］が［
%索引 が`専属する$`保管庫$の`~record~list$Os %L
］から精確にどう拡充されるかの詳細を、
以下に定式化する
（具体的な~algoは、
<a href="#database-operations">§ 各種~db演算</a>
にて定義される）。
</p>

<p>
まず、
%L 内の`~record$ %R に対し，
`抽出される~key@
の集合 K( %R ) は，次で定義される：
</p>

<blockquote>
K( %R ) ~EQ `値から~key集合を抽出する$(
%R の`値$ ,
%索引 の`~key~path$Ix,
%索引 の`複-~entryか$Ix
)
</blockquote>

<p>
%L1 は，常に次の拘束が満たされるように拡充される：
</p>

<ul>
	<li>
<p>
%L 内のどの %R に対しても、
各`~key$ %key ~IN K( %R ) に対し，次の両~条件を満たす~record %R1 が %L1 内に唯一つ~~存在する：
</p>

		<ul>
			<li>
%R1 の`~key$ ~EQ~cmpkey %key
</li>
			<li>
%R1 の`値$ ~EQ~cmpkey %R の`~key$
</li>
		</ul>
	</li>
	<li>
%L1 は、
前項により導出されるもの以外の`~record$は含まない。
</li>
</ul>

<p>
%R が %R1 の`参照先~record$を与える。
［
%索引 の`複-~entryか$Ix ~EQ ~F
］ならば、
集合 K( %R ) は，常に 0 〜 1 個の~keyからなるので、
%L1 から %L への対応関係［
%R1 → %R1 の`参照先~record$
］は 単射になる。
また、
K( %R ) が常に空でないならば、
この対応関係は全射になる。
</p>

<p>
したがって、
索引の`~record~list$Ixは，索引が専属する保管庫の`~record~list$Osから一意に定まることになる。
例えば、
保管庫に~recordを追加してから新たな索引を作成した結果と，これを逆順で行った結果は
（~errorが生じなければ）
同じになる。
よって、
索引の~record~listを実際に構築しない実装も，原理的には可能になる
（処理能
— 例えば~recordの~sortなど —
との引き換えになるが）
（また，そのように~model化すれば、
この仕様の記述は，もっと簡略化できるであろう）。
</p>

			</section>
			<section id="index-handle-construct">
<h5 title="Index handle">2.6.1. 索引~handle</h5>

<p>
~scriptが`索引$と直にヤリトリすることはない。
代わりに`~tx$の中で
`索引~handle@
を介して間接的に~accessする。
◎
Script does not interact with indexes directly. Instead, within a transaction, script has indirect access via an index handle.
</p>

<p>
各`索引~handle$ %I には、
次に挙げるものが結付けられる
（括弧内は、
対応する `IDBIndex!I ~interface~member ）：
◎
↓</p>

<dl class="def-list">
	<dt>
`索引@IxH
◎
An index handle has an associated index＼
</dt>
	<dd>
%I の`~access先$とされる`索引$。
【この訳では、もっぱら %I↗ と記す。】
◎
↑↑</dd>

	<dt>
`保管庫~handle@IxH
（ `objectStore$m ）
◎
and an associated object store handle.＼
</dt>
	<dd>
%I が`専属する$`保管庫~handle$。
【この訳では、この用語は利用せず，単にこのように記す。】
◎
↑↑
</dd>

	<dt>
`~tx@IxH
◎
The transaction of an index handle＼
</dt>
	<dd>
%I （が`専属する$`保管庫~handle$）が`専属する$`~tx$。
【この訳では、この用語は利用せず，単にこのように記す。】
◎
is the transaction of its associated object store handle.＼
</dd>
	<dd>
上に挙げた %I の［
索引, 保管庫~handle, ~tx
］は、
%I の［
取得-時／作成-時
］に，`可換性$と`一意性$の要件が満たされるように設定される。
◎
Multiple handles may be associated with the same index in different transactions, but there must be only one index handle associated with a particular index within a transaction.
</dd>

	<dt>
`名前@IxH
（ `name$m ）
◎
An index handle has a name,＼
</dt>
	<dd>
%I の作成-時に %I↗ の`名前$Ixに初期化される。
この名前は、
%I が`専属する$`~tx$が［
`昇格~tx$であって, `稼働して$いる間
］を除いて，一定であり続ける。
◎
which is initialized to the name of the associated index when the index handle is created. The name will remain constant except when an upgrade transaction is running.
</dd>
</dl>

			</section>
		</section>
		<section id="transaction-construct">
<h3 title="Transactions">2.7. ~tx</h3>

<p>
`~db$内の~dataとヤリトリするとき
— すなわち，~dataを読取る／書込むとき —
は、
常に
`~tx@
（ `transaction^en, “トランス動作” ）が利用される。
◎
A transaction is used to interact with the data in a database. Whenever data is read or written to the database it is done by using a transaction.
</p>

<div class="p">
<p>
`~tx$は、［
~app／~system
］の失敗に対する一定の保護を提供する：
</p>

<ul>
	<li>
一度に複数の~data~recordを格納したり，~data~recordを条件付きで改変するために利用できる。
</li>
	<li>
~~時間を要する［
~data~access／~data変異
］演算からなる，不可分な集合を表現する。
</li>
</ul>

<p class="trans-note">【
すなわち，失敗-時には、
中途半端な状態にならないよう，これらによる変異~すべてが元の状態に復帰される。
】</p>
◎
Transactions offer some protection from application and system failures. A transaction may be used to store multiple data records or to conditionally modify certain data records. A transaction represents an atomic and durable set of data access and data mutation operations.
</div>

<p>
各 `~tx$には、
次に挙げるものが結付けられる
（括弧内は、
対応する `IDBTransaction!I ~interface~member ）：
◎
↓</p>

<dl class="def-list">
	<dt>
`接続@tx
（ `db$m ）
◎
↓</dt>
	<dd>
すべての`~tx$は、
ある`接続$を通して`作成-$される
（後述の`存続期間$を見よ）。
~txは、
その`接続$に`専属する$。
◎
All transactions are created through a connection, which is the transaction’s connection.
</dd>
	<dd class="trans-note">【
この訳では、
この接続を指すときは，もっぱら
“（~txが）専属する接続”
と記す。
】</dd>

	<dt>
`視野@
（ `objectStoreNames$m ）
◎
A transaction has a scope＼
</dt>
	<dd>
`~tx$がヤリトリし得る`保管庫$たちからなる集合。
◎
which is a set of object stores that the transaction may interact with.
</dd>
	<dd class="note">注記：
視野は、
`昇格~tx$でない限り，固定され続ける。
◎
Note: A transaction's scope remains fixed unless the transaction is an upgrade transaction.
</dd>
	<dd class="trans-note">【
視野は、
`~tx$の作成-時に決定され，内容は変化しない。
`昇格~tx$の視野は、
`常に^em，それが`専属する$`接続$の`保管庫~集合$Cnになる。
】</dd>
	<dd>
2 つの`~tx$は、
ある`保管庫$が両`~tx$の`視野$に入るならば，
`視野が重合して@
いるとされる
◎
Two transactions have overlapping scope if any object store is in both transactions' scope.
</dd>

	<dd class="trans-note">【
各~txは、
同じ`保管庫$を，
<strong>別々な`保管庫~handle$を通して</strong>
各自の
“視野に入れる”
ことに注意。
】</dd>

	<dt>
`~mode@
（ `mode$m ）
◎
A transaction has a mode＼
</dt>
	<dd>
<p>
`~tx$が，どの型のヤリトリを遂行できるかを決定する。
`~mode$は，~txの作成-時に設定され、
~txが存続する間，変化しない。
次のいずれか：
◎
that determines which types of interactions can be performed upon that transaction. The mode is set when the transaction is created and remains fixed for the life of the transaction. A transaction's mode is one of the following:
</p>

		<dl>
			<dt>`readonly@l</dt>
			<dd>
この型の`~tx$には、
~dataを読取ることのみが許容され，改変は行えない。
`readonly^l ~txには、
複数のそれらを同時に稼働できる優位性がある
— 互いの`視野が重合して$いようが
（すなわち，同じ保管庫を利用していても）。
この型の~txは、
~dbが~openされたなら，いつでも作成できる。
【！ 手短に言えば、［ 同じ保管庫を視野に入れている，この型の~txたち ］は，その保管庫を排他的に占有する。】
◎
The transaction is only allowed to read data. No modifications can be done by this type of transaction. This has the advantage that several read-only transactions can run at the same time even if their scopes are overlapping, i.e. if they are using the same object stores. This type of transaction can be created any time once a database has been opened.
</dd>

			<dt>`readwrite@l</dt>
			<dd>
この型の`~tx$には、
既存の保管庫から~dataを読取ることに加えて，~dataを［
改変する／削除する
］ことも許容される。
しかしながら、
保管庫や索引を［
追加する, 除去する
］ことはできない。
また、［
互いの`視野が重合して$いる複数の `readwrite^l `~tx$
］を同時に稼働させることはできない
— そうすると，~txの間に互いの~dataを改変し得ることになるので。
この型の~txは、
~dbが~openされたなら，いつでも作成できる。
◎
The transaction is allowed to read, modify and delete data from existing object stores. However object stores and indexes can’t be added or removed. Multiple "readwrite" transactions can’t run at the same time if their scopes are overlapping since that would mean that they can modify each other’s data in the middle of the transaction. This type of transaction can be created any time once a database has been opened.
</dd>
			<dd class="trans-note">【
手短に言えば、
視野に入れている保管庫たちを排他的に占有する。
】</dd>

			<dt>`versionchange@l</dt>
			<dd>
この型の`~tx$には、
既存の保管庫から~dataを［
読取る, 改変する, 削除する
］ことに加えて，保管庫や索引を［
作成する, 除去する
］こともできる。
それは、
この型の~txのみが行い得る。
この型の~txは、
手動では作成できない
— 代わりに `upgradeneeded$et ~eventが発火されるときに自動的に作成される。
◎
The transaction is allowed to read, modify and delete data from existing object stores, and can also create and remove object stores and indexes. It is the only type of transaction that can do so. This type of transaction can’t be manually created, but instead is created automatically when an upgradeneeded event is fired.
</dd>
			<dd class="trans-note">【
手短に言えば、
接続先~db全体を排他的に占有する。
`昇格~tx$とも呼ばれる。
】</dd>

		</dl>
	</dd>

	<dt>
`耐久能~hint@
（ `durability$m ）
◎
A transaction has a durability hint.＼
</dt>
	<dd>
<p>
これは、
当の~txを~commitするときに，［
処理能, 耐久能
］のどちらを優先するかを~UAに~hintする。
次のいずれかをとる：
◎
This is a hint to the user agent of whether to prioritize performance or durability when committing the transaction. The durability hint is one of the following:
</p>
		<dl>
			<dt>`strict$l</dt>
			<dd>
~UAは、［
未決な変更~すべてが持続的な~storage媒体に成功裡に書込まれたことを検証yした後
］に限り，`~tx$は成功裡に`~commit$されたものと見なしてヨイ。
◎
The user agent may consider that the transaction has successfully committed only after verifying that all outstanding changes have been successfully written to a persistent storage medium.
</dd>

			<dt>`relaxed$l</dt>
			<dd>
~UAは、
未決な変更~すべてが~OSに書込まれ次第
— 後続の検証yは伴わずに —
`~tx$は成功裡に`~commit$されたものと見なしてヨイ。
◎
The user agent may consider that the transaction has successfully committed as soon as all outstanding changes have been written to the operating system, without subsequent verification.
</dd>

			<dt>`default$l</dt>
			<dd>
~UAは、
自身による既定の［
`~storage~bucket$用の耐久能の挙動
］を利用するベキである。
これは、
`~tx$用に他が指定されない場合の既定になる。
◎
The user agent should use its default durability behavior for the storage bucket. This is the default for transactions if not otherwise specified.
</dd>
		</dl>
	</dd>
	<dd class="note">
<p>注記：
代表的な実装においては、
`strict$l は，［
`complete$et ~eventが発火される前に~OSの入出力~bufferを一掃する
］よう~UAに~hintする。
これは、［
後続の［
~OS~crash／電力~喪失
］事例においても，変更は持続化する
］ことになる確度を高めるが、
~bufferを一掃するのに有意な時間がかかり得るため，携帯~機器の~battery-lifeを消費し得る。
◎
In a typical implementation, "strict" is a hint to the user agent to flush any operating system I/O buffers before a "complete" event is fired. While this provides greater confidence that the changes will be persisted in case of subsequent operating system crash or power loss, flushing buffers can take significant time and consume battery life on portable devices.
</p>

<p>
~web~appには、［
~cacheや~recordが素早く変化するなどの短命な~data用には `relaxed$l ／
~data喪失の~riskを抑制することが処理能や電力への影響iに勝る事例においては `strict$l
］を利用するよう奨励される。
実装には、
~appからの耐久能~hintを利用者や機器に対する影響iより重視することが奨励される。
◎
Web applications are encouraged to use "relaxed" for ephemeral data such as caches or quickly changing records, and "strict" in cases where reducing the risk of data loss outweighs the impact to performance and power. Implementations are encouraged to weigh the durability hint from applications against the impact to users and devices.
</p>
	</dd>

	<dt>
`片付ける~event~loop@
◎
A transaction optionally has a cleanup event loop＼
</dt>
	<dd>
`~event~loop$, または ε （初期-時）
◎
which is an event loop.
</dd>

	<dt>
`要請~list@
◎
A transaction has a request list of pending requests＼
</dt>
	<dd>
~txに`設置-$された処理待ち`要請$たちからなる, 【設置された順による】~list。
◎
which have been made against the transaction.
</dd>

	<dt>
`~error@tx
（ `error$m ）
◎
A transaction has a error＼
</dt>
	<dd>
初期時は ε 。
`~tx$が~errorにより`中止-$されたときに設定される。
◎
which is set if the transaction is aborted.
</dl>

<p>
`~tx$の`親~標的を取得する$~algoは、
~txが`専属する$`接続$を返す。
◎
A transaction's get the parent algorithm returns the transaction’s connection.
</p>

<p>
`~mode$が `readonly$l にされた`~tx$を
`~readonly~tx@
という。
◎
A read-only transaction is a transaction with mode "readonly".
</p>

<p>
`~mode$が `readwrite$l にされた`~tx$を
`~readwrite~tx@
という。
◎
A read/write transaction is a transaction with mode "readwrite".
</p>

			<section id="transaction-lifecycle">
<h4 title="Transaction lifecycle">2.7.1. ~txの~lifecycle</h4>

<p>
`~tx$の
`状態@tx
は、
次のいずれかをとる：
◎
A transaction has a state, which is one of the following:
</p>

<dl>
	<dt>
`作動中@i
◎
active
</dt>
	<dd>
~txは、
新たに`作成-$されてから，それに`設置-$された`要請$からの~eventが配送される間は、
この状態にある。
◎
A transaction is in this state when it is first created, and during dispatch of an event from a request associated with the transaction.
</dd>
	<dd>
この状態にある~txに対しては、
新たな`要請$を為せる。
◎
New requests can be made against the transaction when it is in this state.
</dd>

	<dt>
`非作動中@i
◎
inactive
</dt>
	<dd>
~txは、
その作成~後［
~event~loopに制御が返され，~eventが配送されていない間
］は、
この状態にある。
◎
A transaction is in this state after control returns to the event loop after its creation, and when events are not being dispatched.
</dd>
	<dd>
この状態にある~txに対しては、
`要請$は為せない。
◎
No requests can be made against the transaction when it is in this state.
</dd>

	<dt>
`~commit中@i
◎
committing
</dt>
	<dd>
~txは、
それに設置されたすべての`要請$が完了したとき
— `~commit$しようと試みるに伴い —
この状態になる。
◎
Once all requests associated with a transaction have completed, the transaction will enter this state as it attempts to commit.
</dd>
	<dd>
この状態にある~txに対しては、
`要請$は為せない。
◎
No requests can be made against the transaction when it is in this state.
</dd>

	<dt>
`完遂d@i
◎
finished
</dt>
	<dd>
［
~commitされた／中止された
］~txは、
それ以降，この状態になる。
◎
Once a transaction has committed or aborted, it enters this state.
</dd>
	<dd>
この状態にある~txに対しては、
`要請$は為せない。
◎
No requests can be made against the transaction when it is in this state.
</dd>
</dl>

<p>
`~tx$は~~短命であるものと期待されている。
これは、
下に述べる自動`~commit$の機能性により促される。
◎
Transactions are expected to be short lived. This is encouraged by the automatic committing functionality described below.
</p>

<p class="note">注記：
それでも、
作者は，~txを長い間 稼働させれるが、
そのような用法は，利用者~体験を~~悪化させ得るので，勧められない。
◎
Authors can still cause transactions to run for a long time; however, this usage pattern is not advised as it can lead to a poor user experience.
</p>

<p>
`~tx$はその
`存続期間@
にわたり、
以下のように変遷する：
◎
The lifetime of a transaction is as follows:
</p>

<ol>
	<li>
`~tx$は、
`~mode$と`視野$を伴って
`作成-@
される。
その初期~時の`状態$txは、
`作動中$i になる。
◎
A transaction is created with a scope and a mode. When a transaction is created its state is initially active.
</li>
	<li>
実装は、［
<a href="#transaction-scheduling">~txの~schedule法</a>にて定義される，`~tx$の［
`~mode$と`視野$
］に定義される拘束
］を施行-可能になったときは，~txを非同期に
`開始-@
する`~taskを~queueする$モノトスル。
◎
When an implementation is able to enforce the constraints for the transaction’s scope and mode, defined below, the implementation must queue a task to start the transaction asynchronously.
</li>
	<li>
<p>
`~tx$が`開始-$されたなら、
その~txに設置された各`要請$を実行し始めれるようになる。
それらの要請は、
`設置-$された順序で実行するモノトスル。
同様に，それらの結果も、
同じ順序で返すモノトスル
【返すとは、要請に向けてその完了を報告する~eventを発火することを意味する】
— 異なる~txに`設置-$された要請たちの間では，返される順序は保証されないが。
◎
Once the transaction has been started the implementation can begin executing the requests placed against the transaction. Requests must be executed in the order in which they were made against the transaction. Likewise, their results must be returned in the order the requests were placed against a specific transaction. There is no guarantee about the order that results from requests in different transactions are returned.
</p>

<p class="note">注記：
~txの`~mode$は、［
互いに異なる~txに対し， 2 つの要請の どちらが先に設置された
］としても，［
~db内に格納される結果の~dataには影響しない
］ことを確保する。
◎
Transaction modes ensure that two requests placed against different transactions can execute in any order without affecting what resulting data is stored in the database.
</p>

	</li>
	<li>
~txに設置された各`要請$は、
`処理-済み$になったとき，［
`success$et ／ `error$et
］~eventが発火されることになる。
この~eventが`配送-$される間、
当の~txの`状態$txは `作動中$i になり，~txに対して追加的な要請を為せるようになる。
~event配送-が完了したなら、
~txの`状態$txは，再び `非作動中$i になる。
◎
When each request associated with a transaction is processed, a success or error event will be fired. While the event is being dispatched, the transaction state is set to active, allowing additional requests to be made against the transaction. Once the event dispatch is complete, the transaction’s state is set to inactive again.
</li>
	<li>
<p>
`~tx$は、
`完遂-$する前に，いつでも
`中止-@
され得る／できる
— ~txが `作動中$i であろうと，まだ`開始-$されていなくても。
◎
A transaction can be aborted at any time before it is finished, even if the transaction isn’t currently active or hasn’t yet started.
</p>

<p>
明示的に `abort()$m を~callすれば、
`中止-$を起動することになる。
中止-は、
失敗した 要請が~scriptにより取扱われなかった場合も，それに後続して起動される。
◎
An explicit call to abort() will initiate an abort. An abort will also be initiated following a failed request that is not handled by script.
</p>

<p>
~txが中止されたときは、
実装は，［
その~txの間に`~db$に為されたすべての変更
］を元に復帰させるモノトスル
【“巻戻し（ `roll back^en ）” とも称される】。
これには、［
`保管庫$の内容に対する変更 ／
`保管庫$や`索引$の［
追加／除去
］］も含まれる。
◎
When a transaction is aborted the implementation must undo (roll back) any changes that were made to the database during that transaction. This includes both changes to the contents of object stores as well as additions and removals of object stores and indexes.
</p>

	</li>
	<li>
<p>
実装は、
~txが次を満たすならば
`~commit@
しようと試みるモノトスル
⇒
［
設置されたすべての`要請$は完了した
］~AND［
それらの要請が返した結果は取扱われた
］~AND［
新たな要請は設置されていない
］~AND［
`中止-$されていない
］
◎
The implementation must attempt to commit a transaction when all requests placed against the transaction have completed and their returned results handled, no new requests have been placed against the transaction, and the transaction has not been aborted
</p>

<p>
明示的に `commit()$m を~callすれば、
要請の結果が~scriptにより取扱われるのを待機することなく`~commit$を起動することになる。
◎
An explicit call to commit() will initiate a commit without waiting for request results to be handled by script.
</p>

<p>
~txを~commitするとき、
`状態$txは `~commit中$i になる。
実装は，~txに対し設置された要請により`~db$に為されたすべての変更を，不可分に書込むモノトスル
— すなわち、［
すべての変更を書込む
］か［
~disk書込n~errorなどが生じた場合には、
いかなる変更も~dbに書込まない
］かになるモノトスル。
それに伴い，`~txを中止-$する手続きが後続することになる。
◎
When committing, the transaction state is set to committing. The implementation must atomically write any changes to the database made by requests placed against the transaction. That is, either all of the changes must be written, or if an error occurs, such as a disk write error, the implementation must not write any of the changes to the database, and the steps to abort a transaction will be followed.
</p>
	</li>
	<li>
~txが［
`~commit$された／`中止-$された
］ときは、
その`状態$txは `完遂d$i になる。
◎
When a transaction is committed or aborted, its state is set to finished.
</li>
</ol>

<p>
実装は、
`作動中$i にある`~tx$に対しては
— まだ`開始-$されていなくても —
`要請$を`設置-$できるようにするモノトスル。
`開始-$される前に設置された`要請$たちは、
開始されるまでは実行せずに，その順序も込みで保ち続けるモノトスル。
◎
The implementation must allow requests to be placed against the transaction whenever it is active. This is the case even if the transaction has not yet been started. Until the transaction is started the implementation must not execute these requests; however, the implementation must keep track of the requests and their order.
</p>

<div class="algo">
<p>
`索引付き~db~txを片付ける@
ときは、
次を走らす
— これは、
片付けられた~txが［
在れば ~T ／
無ければ ~F
］を返す：
◎
To cleanup Indexed Database transactions, run the following steps. They will return true if any transactions were cleaned up, or false otherwise.
</p>

<ol>
	<li>
%結果 ~LET ~F
◎
↓If there are no transactions with cleanup event loop matching the current event loop, return false.
</li>
	<li>
<p>
`~tx$のうち［
その`片付ける~event~loop$ ~EQ 現在の`~event~loop$
］を満たす
~EACH( %~tx )
に対し：
◎
For each transaction transaction with cleanup event loop matching the current event loop:
</p>
		<ol>
			<li>
%結果 ~SET ~T
◎
↑↓</li>
			<li>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</li>
			<li>
%~tx の`片付ける~event~loop$ ~SET ε
◎
Clear transaction’s cleanup event loop.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return true.
</li>
</ol>

<p class="note">注記：
この手続きは、
`HTML$r から呼出される。
それは、
~scriptから~callされた
<a href="#dom-idbdatabase-transaction">`transaction()^m</a>
により作成された`~tx$は，~scriptが呼出した~taskが完了した時点で作動中でなくなることを確保する。
この手続きが走るのは、
`~tx$ごとに高々 1 回限りになる。
◎
These steps are invoked by [HTML]. They ensure that transactions created by a script call to transaction() are deactivated once the task that invoked the script has completed. The steps are run at most once for each transaction.
</p>
</div>

<p>
`complete@et
~eventは、
成功裡に`~commit$された`~tx$に向けて発火される。
◎
An event with type complete is fired at a transaction that has successfully committed.
</p>

<p>
`abort@et
~eventは、
`中止-$された`~tx$に向けて発火される。
◎
An event with type abort is fired at a transaction that has aborted.
</p>

			</section>
			<section id="transaction-scheduling">
<h4 title="Transaction scheduling">2.7.2. ~txの~schedule法</h4>

<p>
`~tx$がいつ`開始-$できるかは、
次の拘束により定義される：
◎
The following constraints define when a transaction can be started:
</p>

<ul>
	<li>
<p>
`~readonly~tx$ %~tx は、［
次をすべて満たす`~readwrite~tx$は無い
］ならば`開始-$できる：
◎
A read-only transactions tx can start when there are no read/write transactions which:
</p>
		<ul>
			<li>
%~tx より前に`作成-$された
◎
Were created before tx; and
</li>
			<li>
%~tx と`視野が重合して$いる
◎
have overlapping scopes with tx; and
</li>
			<li>
`完遂-$していない
◎
are not finished.
</li>
		</ul>
	</li>
	<li>
<p>
`~readwrite~tx$ %~tx は［
次をすべて満たす`~tx$は無い
］ならば`開始-$できる：
◎
A read/write transaction tx can start when there are no transactions which:
</p>
		<ul>
			<li>
%~tx より前に`作成-$された
◎
Were created before tx; and
</li>
			<li>
%~tx と`視野が重合して$いる
◎
have overlapping scopes with tx; and
</li>
			<li>
`完遂-$していない
◎
are not finished.
</li>
		</ul>
	</li>
</ul>

<p>
実装は追加的な拘束を課してもヨイ。
例えば，実装は
⇒＃
`視野が重合して$いない`~readwrite~tx$を並列的に稼働することは要求されない／
同時に稼働している~txの個数に制限sを課してもヨイ
◎
Implementations may impose additional constraints. For example, implementations are not required to run non-overlapping read/write transactions in parallel, or may impose limits on the number of running transactions.
</p>


<div class="note">

<p>注記：
これらの拘束は、
次を含意する：
◎
These constraints imply the following:
</p>

<ul>
	<li>
`~readonly~tx$は、
同時並行的にいくつでも
— 互いの`視野が重合して$いようが —
稼働することが許容される。
◎
Any number of read-only transactions are allowed to run concurrently, even if they have overlapping scopes.
</li>
	<li>
`~readonly~tx$は、
稼働している限り，［
実装が その~txにより作成された`要請$を通して返す~data
］は一定であり続ける。
すなわち，同じ~data片を読取る 2 つの要請からは、
~dataが見出されるかどうかも含め，同じ結果を得られる。
◎
As long as a read-only transaction is running, the data that the implementation returns through requests created with that transaction remains constant. That is, two requests to read the same piece of data yield the same result both for the case when data is found and the result is that data, and for the case when data is not found and a lack of data is indicated.
</li>
	<li>
<p>
`~readwrite~tx$は、
他の`~tx$を利用して為された`保管庫$への変更からは影響されない。
実装は、
次を確保することになる：
</p>
		<ul>
			<li>
別の~txが，`~readwrite~tx$の`視野$に入る`保管庫$の内容を改変しない。
</li>
			<li>
`~readwrite~tx$が成功裡に完了したなら，その~txを利用して`保管庫$に書込まれた変更を
— 併合する際に競合することなく —
`~db$に~commitできる。
</li>
		</ul>
◎
A read/write transaction is only affected by changes to object stores that are made using the transaction itself. The implementation ensures that another transaction does not modify the contents of object stores in the read/write transaction’s scope. The implementation also ensures that if the read/write transaction completes successfully, the changes written to object stores using the transaction can be committed to the database without merge conflicts.
</li>
	<li>
複数の`~readwrite~tx$が同じ保管庫に~accessしようと試みた場合
（すなわち，それらの`視野が重合して$いる）、
先に`作成-$された~txが保管庫への~accessを先に取得する
— 当の~txが`完遂-$するまで、
保管庫に~accessできるのは，当の~txに限られる。
◎
If multiple read/write transactions are attempting to access the same object store (i.e. if they have overlapping scopes), the transaction that was created first is the transaction which gets access to the object store first, and it is the only transaction which has access to the object store until the transaction is finished.
</li>
	<li>
`~readwrite~tx$ %A の後に`作成-$された，~tx %B は、
%A と`視野が重合して$いる`保管庫$ %O があるならば，
%A により書込まれた %O への変更を見ることになる。
これはまた，［
%A が`完遂-$するまでは、
%B は， %A の`視野$に入る どの`保管庫$にも~accessできない
］ことを意味する。
◎
Any transaction created after a read/write transaction sees the changes written by the read/write transaction. For example, if a read/write transaction A, is created, and later another transaction B, is created, and the two transactions have overlapping scopes, then transaction B sees any changes made to any object stores that are part of that overlapping scope. This also means that transaction B does not have access to any object stores in that overlapping scope until transaction A is finished.
</li>
</ul>
</div>

			</section>
			<section id="upgrade-transaction-construct">
<h4 title="Upgrade transactions">2.7.3. 昇格~tx</h4>

<p>
`~mode$が `versionchange$l にされた`~tx$を
`昇格~tx@
（ `upgrade transaction^en ）という。
◎
An upgrade transaction is a transaction with mode "versionchange".
</p>

<p>
`昇格~tx$は、
`~db$への`接続$が~openされた後，`昇格~txを稼働する$間に、
指定された`~version$dbが現在の`~version$dbより大きい場合に，自動的に作成される†。
この`~tx$は、
`upgradeneeded$et ~event~handlerの内側で `作動中$i になる。
◎
An upgrade transaction is automatically created when running the steps to run an upgrade transaction after a connection is opened to a database, if a version greater than the current version is specified. This transaction will be active inside the upgradeneeded event handler.
</p>

<p class="trans-note">【†
このとき以外に，`接続$に`専属する$`昇格~tx$が作成される機会はない。
したがってそれは、
同じ接続に`専属する$他のどの`~tx$よりも先に`開始-$されることになる。
】</p>

<div class="note">

<p>注記：
`昇格~tx$は、
`~db$内の［
`保管庫$ ／ `索引$
］の［
作成, 名前の変更, 削除
］を可能化する。
◎
An upgrade transaction enables the creation, renaming, and deletion of object stores and indexes in a database.
</p>

<p>
`昇格~tx$は、
排他的である。
`~dbを~openする$手続きは、［
`昇格~tx$が`稼働して$いる間，~dbを~openしている`接続$
］は，唯一に限られることを確保する。
同じ`~db$への他のすべての`接続$が~closeされるまでは、
`upgradeneeded$et ~eventは発火されず，
したがって`昇格~tx$も開始されない。
これは、
以前のすべての~txが`完遂-$されることを確保する。
`昇格~tx$が稼働している限り、
同じ`~db$への他の`接続$を~openしようとする試みは遅延され、
同じ`接続$を利用するために
<a href="#dom-idbdatabase-transaction">`transaction()^m</a>
を~callして追加的な~txを開始しようとする試みに対しては，
例外が投出されることになる。
したがって，`昇格~tx$は、［
他の~txが同時並行的に稼働しない
］ことに加え，
稼働している間は［
同じ`~db$に対し，他の~txは~queueされない
］ことを確保する。
◎
An upgrade transaction is exclusive. The steps to open a database ensure that only one connection to the database is open when an upgrade transaction is running. The upgradeneeded event isn’t fired, and thus the upgrade transaction isn’t started, until all other connections to the same database are closed. This ensures that all previous transactions are finished. As long as an upgrade transaction is running, attempts to open more connections to the same database are delayed, and any attempts to use the same connection to start additional transactions by calling transaction() will throw an exception. Thus upgrade transactions not only ensure that no other transactions are running concurrently, but also ensure that no new transactions are queued against the same database as long as the transaction is running.
</p>

<p>
これは、
`昇格~tx$が完了したなら，`~db$内の［
`保管庫$, `索引$
］の集合は、
後続のすべての［
`接続$, `~tx$
］の存続期間において，一定であり続けることを確保する。
◎
This ensures that once an upgrade transaction is complete, the set of object stores and indexes in a database remain constant for the lifetime of all subsequent connections and transactions.
</p>

</div>

<p class="trans-note">【
この仕様に現れる，
`昇格~txの中@
という句は、［
`upgradeneeded$et ~eventにより呼出される~event~handlerの中
］を意味する。
“昇格~txの外”
という句は、
その否定を意味する。
】</p>

			</section>
		</section>
		<section id="request-construct">
<h3 title="Requests">2.8. 要請</h3>

<p>
`~db$に対する各 非同期の`演算$は、
`要請@
（ `request^en ）を利用して行われる。
どの %要請 も，ある一つの`演算$（以下， %演算 と記す）を表現し、
次に挙げるものが結付けられる
（括弧内は、
対応する `IDBRequest!I ~interface~member ）：
◎
Each asynchronous operation on a database is done using a request. Every request represents one operation.
</p>

<dl class="def-list">
	<dt>
`処理-済みか@
◎
A request has a processed flag＼
</dt>
	<dd>
真偽値。
初期~時は ~F とする。
これは、
%演算 が実行されたとき ~T に設定される。
◎
which is initially false. This flag is set to true when the operation associated with the request has been executed.
</dd>
	<dd>
`要請$は、
その`処理-済みか$ ~EQ ~T のとき，
`処理-済み@
という。
◎
A request is said to be processed when its processed flag is true.
</dd>

	<dt>
`済んだか@
（ `readyState$m ）
◎
A request has a done flag＼
</dt>
	<dd>
真偽値。
初期~時は ~F とする。
%演算 の結果が可用になったとき ~T に設定される。
◎
which is initially false. This flag is set to true when the result of the operation associated with the request is available.
</dd>

	<dt>
`~source@
（ `source$m ）
◎
A request has a source object.
</dt>
	<dd class="trans-note">【
%演算 の対象
— 次のいずれか：［
`保管庫~handle$／`索引~handle$／`~cursor$／ε
］。
%要請 の作成-時に設定され
（設定されない場合は ε ）、
それ以降は変化しない。
】</dd>

	<dt>
`結果@
（ `result$m ）
◎
A request has a result＼
</dt>
	<dt>
`~error@
（ `error$m ）
◎
and an error,＼
</dt>
	<dd>
`済んだか$ ~EQ ~T になるまでは~accessできない。
~T の時点で，どうなるかについては、
下記に。
◎
neither of which are accessible until its done flag is true.
</dd>

	<dt>
`設置-先~tx@
（ `transaction$m ）
◎
A request has a transaction＼
</dt>
	<dd>
初期~時は ε 。
%要請 は、
%演算 を走らす`要請を非同期に実行する$手続きを利用して，`~tx$に
`設置-@
される。
同時に， %要請 は設置-先~txの`要請~list$に追加される。
◎
which is initially null. This will be set when a request is placed against a transaction using the steps to asynchronously execute a request.
</dd>
</dl>

<div class="p">
<p>
`要請$が為されるときは、
新たな`要請$が その［
`済んだか$ ~SET ~F
］にされた上で返される。
`要請$が表現する
`演算@
は、
要請が非同期に実行する手続きの~instance
— すなわち，
( 手続き, それに対する入力, その結果 )
が成す組 —
である。
</p>

<p>
`要請$ %要請 がその`演算$の手続きを終えたときは、
先ず［
%要請 の`済んだか$ ~SET ~T
］にされた上で、
演算から返された %結果 に応じて：
</p>

<ul class="switch">
	<li>
<p>
~errorでない場合
（演算は成功した）：
</p>
		<ol>
			<li>
%要請 の`結果$は %結果 に設定され、
%要請 の`~error$は ε に設定される。
</li>
			<li>
%要請 に向けて
`success@et
~eventが発火される。
</li>
		</ol>
	</li>

	<li>
<p>
~errorである場合
（演算は失敗した）：
</p>
		<ol>
			<li>
%要請 の`結果$は ε に設定され、
%要請 の`~error$は %結果 に設定される。
</li>
			<li>
%要請 に向けて
`error@et
~eventが発火される。
</li>
		</ol>
	</li>
</ul>

◎
When a request is made, a new request is returned with its done flag set to false. If a request completes successfully, its done flag is set to true, its result is set to the result of the request, and an event with type success is fired at the request.
◎
If an error occurs while performing the operation, the request’s done flag is set to true, the request’s error is set to the error, and an event with type error is fired at the request.
</div>

<p>
`要請$の`親~標的を取得する$~algoは、
要請の`設置-先~tx$を返す。
◎
A request's get the parent algorithm returns the request’s transaction.
</p>

<p class="note">注記：
要請は概して，再利用されないが、
例外もある。
`~cursor$が反復されるときは、
その~cursorを~openするときに利用した同じ`要請$に向けて，反復の成功が報告される。
また，`昇格~tx$が必要とされる場合も、
同じ`~open要請$が［
`upgradeneeded$et ~event, ~open演算~自身の最終~結果
］の両者に利用される。
事例によっては、
要請の`済んだか$は ~F に設定されてから再び ~T に設定され，
`結果$は変化する, あるいは`~error$が設定されることもある。
◎
Requests are not typically re-used, but there are exceptions. When a cursor is iterated, the success of the iteration is reported on the same request object used to open the cursor. And when an upgrade transaction is necessary, the same open request is used for both the upgradeneeded event and final result of the open operation itself. In some cases, the request’s done flag will be set to false, then set to true again, and the result can change or error could be set instead.
</p>

			<section id="open-requests">
<h4 title="Open requests">2.8.1. ~open要請</h4>

<p>
`~open要請@
は、［
`接続$を~openする, あるいは`~db$を削除する
］ときに利用される，特別な型の`要請$である。
`~open要請$に対しては：
◎
An open request is a special type of request used when opening a connection or deleting a database.＼
</p>

<ul>
	<li>
［
`success$et, `error$et
］~eventに加え，進捗を指示する［
`blocked@et,
`upgradeneeded@et
］~eventも発火され得る。
◎
In addition to success and error events, blocked and upgradeneeded events may be fired at an open request to indicate progress.
</li>
	<li>
その`~source$は常に ε である。
◎
The source of an open request is always null.
</li>
	<li>
その`設置-先~tx$は、
`upgradeneeded$et ~eventが発火されない限り， ε にされる。
【！ その~txが完遂したときも ε に戻される】
◎
The transaction of an open request is null unless an upgradeneeded event has been fired.
</li>
	<li>
その`親~標的を取得する$~algoは、
~NULL を返す。
◎
An open request's get the parent algorithm returns null.
</li>
</ul>

<p>
`~open要請$は
`接続~queue@
にて処理される。
この~queueは、
( `生成元$, `名前$db )
が成す組に結付けられる，すべての`~open要請$を包含する†。
`接続~queue$に追加された各 要請は、
順序どおりに処理され，次の要請が処理される前に完了するモノトスル。
~open要請は、
【それが~openしようとしている~dbを~openしている】
他の`接続$により阻まれ得る
— それらの接続が`~close$されるまで、
その要請は完了せず，更なる要請は処理できないことになる。
◎
Open requests are processed in a connection queue. The queue contains all open requests associated with an origin and a name. Requests added to the connection queue processed in order and each request must run to completion before the next request is processed. An open request may be blocked on other connections, requiring those connections to close before the request can complete and allow further requests to be processed.
</p>

<p class="trans-note">【†
言い換えれば，接続~queueは、
同じ`~db$
（その生成元に`専属する$, かつ その名前を持つものとして一意に定まる）
に対し，
それを`~access先$とする`接続$を~openしようとする`要請$すべてからなる。
】</p>

<p class="note">注記：
`接続~queue$は、
`~event~loop$に結付けられる`~task~queue$ではない
— 要請は、
すべての`閲覧文脈$の外側で処理されるので。
それでも、
完了した`~open要請$向けの~eventは，［
要請を為した文脈~下の`~event~loop$に結付けられている`~task~queue$
］を通して送達される。
◎
A connection queue is not a task queue associated with an event loop, as the requests are processed outside any specific browsing context. The delivery of events to completed open request still goes through a task queue associated with the event loop of the context where the request was made.
</p>

			</section>
		</section>
		<section id="range-construct">
<h3 title="Key range">2.9. ~key範囲</h3>

<p>
`保管庫$や`索引$から一連の`~record$を検索取得するためには、［
単独の`~key$, または`~key範囲$
］を利用する。
`~key範囲@
とは、
~keyに利用される ある~data型にわたる連続的な区間である。
◎
Records can be retrieved from object stores and indexes using either keys or key ranges. A key range is a continuous interval over some data type used for keys.
</p>

<p>
各 `~key範囲$には、
次に挙げるものが結付けられる
（括弧内は、
対応する `IDBKeyRange!I ~interface~member）
【これらは、作成-時に設定され，それ以降は変化しない】
：
</p>

<dl class="def-list">
	<dt>
`下界@
（ `lower$m ）
◎
A key range has an associated lower bound＼
</dt>
	<dd>
`~key$, または ε 。
◎
(null or a key).
</dd>
	<dt>
`上界@
（ `upper$m ）
◎
A key range has an associated upper bound＼
</dt>
	<dd>
`~key$, または ε 。
◎
(null or a key).
</dd>

	<dt>
`下界openか@
（ `lowerOpen$m ）
◎
A key range has an associated lower open flag.＼
</dt>
	<dd>
真偽値。
他が指定されない限り ~F とする。
◎
Unless otherwise stated it is false.
</dd>
	<dd class="trans-note">【
`下界$ ~EQ ε の場合は、
必ず ~T にされる。
】</dd>

	<dt>
`上界openか@
（ `upperOpen$m ）
◎
A key range has an associated upper open flag.＼
</dt>
	<dd>
真偽値。
他が指定されない限り ~F とする。
◎
Unless otherwise stated it is false.
</dd>
	<dd class="trans-note">【
`上界$ ~EQ ε の場合は、
必ず ~T にされる。
】</dd>
</dl>

<p>
［
`下界$ ~GT~cmpkey `上界$
］にはならないモノトスル。
◎
A key range may have a lower bound equal to its upper bound. A key range must not have a lower bound greater than its upper bound.
</p>

<p>
`Only@
( %key )
と記される，所与の`~key$ %key のみを包含する`~key範囲$は、
次のようにされた`~key範囲$として定義される
⇒＃
`下界$ ~SET %key,
`上界$ ~SET %key,
`上界openか$ ~SET ~F,
`下界openか$ ~SET ~F
◎
A key range containing only key has both lower bound and upper bound equal to key.
</p>

<p>
所与の`~key$ %key は、
次の両~条件を満たすとき，`~key範囲$ %範囲 に
`入る@
とされる：
◎
A key is in a key range range if both of the following conditions are fulfilled:
</p>

<ul>
	<li>
<p>
次のいずれかが満たされる：
</p>
		<ul>
			<li>
%範囲 の`下界$ ~EQ ε
</li>
			<li>
%範囲 の`下界$ ~LT~cmpkey %key
</li>
			<li>
［
%範囲 の`下界$ ~EQ~cmpkey %key
］~AND［
%範囲 の`下界openか$ ~EQ ~F
］
</li>
</ul>

◎
The range’s lower bound is null, or it is less than key, or it is both equal to key and the range’s lower open flag is false.
</li>
	<li>
<p>
次のいずれかが満たされる：
</p>
		<ul>
			<li>
%範囲 の`上界$ ~EQ ε
</li>
			<li>
%範囲 の`上界$ ~GT~cmpkey %key
</li>
			<li>
［
%範囲 の`上界$ ~EQ~cmpkey %key
］~AND［
%範囲 の`上界openか$ ~EQ ~F
］
</li>
		</ul>
◎
The range’s upper bound is null, or it is greater than key, or it is both equal to key and the range’s upper open flag is false.
</li>
</ul>

<div class="note">
<p>注記：
［
`下界$ ／ `上界$
］は、
`~key範囲$に`入る$とされる`~key$の［
“~~下限” ／ “~~上限”
］を与える。
［
`下界$ ／ `上界$
］に対する ε は［
~~下限／~~上限
］が無いことを表す。
</p>

<p>
`下界$は、［
`下界openか$ ~EQ ~F
］のとき, そのときに限り，`~key範囲$に`入る$。
`上界openか$についても同様になる。
</p>

◎
If a key range's lower open flag is false, the lower bound key of the key range is included in the range itself.
◎
If a key range's lower open flag is true, the lower bound key of the key range is excluded from the range itself.
◎
If a key range's upper open flag is false, the upper bound key of the key range is included in the range itself.
◎
If a key range's upper open flag is true, the upper bound key of the key range is excluded from the range itself.
</div>

<p>
`全範囲@
とは、［
`下界$ ~EQ `上界$ ~EQ ε
］なる`~key範囲$である。
任意の`~key$に対し［
`~key$ ~IN `全範囲$
］は真になる。
◎
An unbounded key range is a key range that has both lower bound and upper bound equal to null. All keys are in an unbounded key range.
</p>

<p class="trans-note">【
`全範囲$は `IDBKeyRange$I ~objとしては~instance化され得ない
— ~modelにのみ存在する~objである。
】</p>

<div class="algo">
<p>
`Range@
( %値, %~NULL不可 （省略時は ε ） )
は、
次を走らす：
◎
To convert a value to a key range with value and optional null disallowed flag, run these steps:
</p>

<ol>
	<li>
<p>
%値 に応じて：
</p>
		<dl class="switch">
			<dt>`~key範囲$である</dt>
			<dd>
~RET %値
◎
If value is a key range, return value.
</dd>

			<dt>ε</dt>
			<dt>~NULL†</dt>
			<dd>
				<ol>
					<li>
~IF ［
%~NULL不可 ~NEQ ε
］
⇒
~THROW `DataError$E
</li>
					<li>
~RET `全範囲$
</li>
				</ol>
◎
If value is undefined or is null, then throw a "DataError" DOMException if null disallowed flag is true, or return an unbounded key range otherwise.
</dd>

			<dt>その他</dt>
			<dd>
~RET `Only$( `Key$( %値 ) ) ？
◎
Let key be the result of converting a value to a key with value. Rethrow any exceptions.
◎
If key is invalid, throw a "DataError" DOMException.
◎
Return a key range containing only key.
</dd>
		</dl>
	</li>
</ol>

<p class="trans-note">【†
この手続きは、
~key範囲を期待する引数
（この仕様では，名前 %query の引数として記される）
をとる~API~methodから呼び出される。
その引数が省略可能であって, ~NULL が渡された場合、
特別に，引数が省略されたとき（ ε ）と同じに扱われることになる。
】</p>
</div>

		</section>
		<section id="cursor-construct">
<h3 title="Cursor">2.10. ~cursor</h3>

<p>
`~cursor@
は、
ある~dbに`専属する$［
`索引$／`保管庫$
］の中の ある範囲に入る~recordたちを，特定の方向に反復するために利用される。
◎
A cursor is used to iterate over a range of records in an index or an object store in a specific direction.
</p>

<p>
`~cursor$
は、
次に挙げるものを持つ
（括弧内は、
対応する `IDBCursor!I ~interface~member）
— これらは、
`~cursorを作成する$ときに設定される：
</p>

<dl class="def-list">
	<dt>
`~tx@Cs
◎
A cursor has a transaction,＼
</dt>
	<dd>
~cursorの`~source$Csが`専属する$`~tx$。
【この訳では、この用語は利用せず，単にこのように記す。】
◎
the transaction that was active when the cursor was created.
</dd>
	<dt>
`範囲@Cs
◎
A cursor has a range＼
</dt>
	<dd>
`~key範囲$。
~cursorは、［
`~source$Cs↗内の`~record$のうち，`~key$がこの範囲に`入る$もの
］を反復対象にする。
◎
of records in either an index or an object store.
</dd>
	<dd class="trans-note">【
~cursorの作成-時に指定されなかった場合、
`全範囲$が指定されたものと見なされる。
】</dd>

	<dt>
`~source@Cs
（ `source$m ）
◎
A cursor has a source＼
</dt>
	<dd>
`保管庫~handle$, または`索引~handle$。
~cursorは， ~source↗（ ~sourceの`~access先$）の~record~listを反復対象にする。
◎
that indicates which index or an object store is associated with the records over which the cursor is iterating.
</dd>

	<dd class="trans-note">【
原文における`~source$Csは、［
`保管庫$, または`索引$
］として定義されているが、
~modelの記述を簡潔にするため，この訳では 上述のように改めている
— ~cursorを利用するどの演算も，保管庫~handle／索引~handleを通した~accessを要しており、
まわりくどい記述になっているので。
】</dd>

	<dt>
`方向@Cs
（ `direction$m ）
◎
A cursor has a direction＼
</dt>
	<dd>
<p>
次の 2 つを指示する：
</p>
		<ul>
			<li>
反復-時に~cursorの`位置$Csを移動させる方向
— すなわち，`~record$たちを その`~key$の
昇順, 降順
いずれの順序で反復するか。
~cursor初期~位置は［
前者／後者
］に応じて，`~source$Cs↗の［
始端／終端
］側に位置することになる。
</li>
			<li>
~keyが重複する~recordがあるとき，最初のもの以外を飛ばすかどうか。
</li>
		</ul>
◎
that determines whether it moves in monotonically increasing or decreasing order of the record keys when iterated, and if it skips duplicated values when iterating indexes. The direction of a cursor also determines if the cursor initial position is at the start of its source or at its end. A cursor’s direction is one of the following:
</dd>

	<dd>
<p>
~cursorの`方向$Csは、
次の値をとり得る：
</p>
		<dl>
			<dt>`next@l</dt>
			<dd>
`~cursor$を`~source$Cs↗の始端~側から，`~key$の昇順に反復する。
</dd>
			<dt>`prev@l</dt>
			<dd>
`~cursor$を`~source$Cs↗の終端~側から，~keyの降順に反復する。
</dd>
			<dd>
`next$l, `prev$l のいずれも、
反復-時には、
`~key$が`等しい$もの†も含め，`範囲$Csに`入る$すべての~recordを得るべきである††。
</dd>
			<dd class="trans-note">【†
重複する~keyを伴う~record間の反復-順序については、
`保管庫~位置$Csを見よ。
】【††
“べき”
— `位置$Csの記述を見よ。
】</dd>

			<dt>`nextunique@l</dt>
			<dd>
`~key$が互いに`等しい$~recordたちについては，それらのうち最初の~record以外は飛ばすことを除いて、
`next$l と同じ。
</dd>

			<dt>`prevunique@l</dt>
			<dd>
`~key$が互いに`等しい$~recordたちについては，それらのうち
<strong >最初の</strong>
~record以外は飛ばすことを除いて、
`prev$l と同じ。
</dd>
			<dd>
［
`nextunique$l ／ `prevunique$l
］に対しては、
`~source$Cs↗が`保管庫$であるか［
`索引$であって，その`一意か$Ix ~EQ ~T
］である場合の挙動は，［
`next$l ／ `prev$l
］と正確に同じになる。
</dd>
		</dl>

◎
This direction causes the cursor to be opened at the start of the source. When iterated, the cursor should yield all records, including duplicates, in monotonically increasing order of keys.
◎
This direction causes the cursor to be opened at the start of the source. When iterated, the cursor should not yield records with the same key, but otherwise yield all records, in monotonically increasing order of keys. For every key with duplicate values, only the first record is yielded. When the source is an object store or an index with its unique flag set to true, this direction has exactly the same behavior as "next".
◎
This direction causes the cursor to be opened at the end of the source. When iterated, the cursor should yield all records, including duplicates, in monotonically decreasing order of keys.
◎
This direction causes the cursor to be opened at the end of the source. When iterated, the cursor should not yield records with the same key, but otherwise yield all records, in monotonically decreasing order of keys. For every key with duplicate values, only the first record is yielded. When the source is an object store or an index with its unique flag set to true, this direction has exactly the same behavior as "prev".
</dd>

	<dt>
`位置@Cs
◎
A cursor has a position＼
</dt>
	<dd>
`範囲$Csに`入る$どこかを指す†。
~cursorが反復対象にしている~record~listは、
~cursorの`範囲$Csが全部的に反復される前に変更されることもある。
これを取扱うため、
~cursorは自身の`位置$Csを，~indexとしてではなく，前回に返した†~recordの`~key$として保守する。
~cursorが次の~recordへ反復するよう請われたとき、
`方向$Csが~keyの昇順なら、
前回に反復した~recordの~key`より大きい$~keyを持つ~recordのうち，最小の`~key$を持つものを返すことになる††。
`方向$Csが~keyの降順なら、
それとは逆に，前回に反復した~recordの~key`より小さい$~keyを持つ~recordのうち，最大の`~key$を持つものを返すことになる。
◎
within its range. It is possible for the list of records which the cursor is iterating over to change before the full range of the cursor has been iterated. In order to handle this, cursors maintain their position not as an index, but rather as a key of the previously returned record. For a forward iterating cursor, the next time the cursor is asked to iterate to the next record it returns the record with the lowest key greater than the one previously returned. For a backwards iterating cursor, the situation is opposite and it returns the record with the highest key less than the one previously returned.
</dd>
	<dd class="trans-note">【†
位置は、
初期~時には，反復~順序における仮想の先頭（ ε ）をとるが、
`~cursorを作成する$要請の結果として，この位置のまま~APIに公開されることはない
— `範囲$Csに入る~recordが無い場合、
要請の`結果$は ~NULL になる。
】【
~cursorがすべてを反復し終えて，次の~recordへの反復が試みられた場合、
ε に設定され，それ以上~反復できなくなる。
】【††
索引における~keyの重複を無視するならば。
次項を見よ。
】</dd>

	<dt>
`保管庫~位置@Cs
◎
For cursors iterating indexes＼
</dt>
	<dd>
`索引$においては、
複数の~recordが同じ~keyを持つこともあり，`値$によっても~sortされることから、
`索引$を反復する~cursorについては，少しばかり複雑になる。
この場合、
`~cursor$は，前回の反復にて索引~内に見出された`~record$の`値$を指示する，`保管庫~位置^emも持つ†。
次の~recordを見出すときには、
`位置$Csに加え，`保管庫~位置$Csも利用される。
◎
the situation is a little bit more complicated since multiple records can have the same key and are therefore also sorted by value. When iterating indexes the cursor also has an object store position, which indicates the value of the previously found record in the index. Both position and the object store position are used when finding the next appropriate record.
</dd>
	<dd class="trans-note">【†
すなわち，`参照先~record$の`~key$
— ゆえに “保管庫~位置” と称されている。
】</dd>

	<dt>
`~key@Cs
（ `key$m ）
◎
↓</dt>
	<dd>
~cursorが最後に反復した`~record$の`~key$を表現する。
◎
↓</dd>
	<dd class="trans-note">【
これは，実質的に`位置$Csの別名。
】</dd>

	<dt>
`値@Cs
（ `IDBCursorWithValue.value$m ）
◎
↓</dt>
	<dd>
~cursorが最後に反復した`~record$の`値$†を表現する。
◎
A cursor has a key and a value which represent the key and the value of the last iterated record.
</dd>
	<dd class="trans-note">【†
`~source$Cs↗が`索引$の場合は`参照先~record$の値。
】</dd>

	<dt>
`値は取得-済みか@Cs
◎
A cursor has a got value flag.＼
</dt>
	<dd>
真偽値。
~T は、［［
~cursorを利用する`要請$
］が`非同期に実行する$`演算$
］が完了し，新たな
( `~key$Cs, `値$Cs )
を得た
（新たな ( `位置$Cs, `保管庫~位置$Cs ) に移動した）
ことを指示する。
◎
↓</dd>
	<dd class="trans-note">【
新たな~cursorを取得した時点では、
その前に，`範囲$Csに入る最初の~recordが検索取得されるので、
これも ~T になる。
】</dd>
	<dd>
<p>
したがって， ~F の場合、
次のいずれかを指示する：
</p>
		<ul>
			<li>
~cursorを利用する`要請$が`非同期に実行する$`演算$は、
完了していない。
</li>
			<li>
~cursorは，その`範囲$Csに入るすべての~recordを反復し終えて，次の~recordへの反復が一回でも試みられた。
</li>
		</ul>

<p class="trans-note">【
後者の場合のみ，［
`~key$Cs, `値$Cs
］は ε にされるので、
`key$m を調べれば前者と区別できる。
後者の場合、
それ以上~cursorは利用できなくなる
— 例えば `範囲$Csに入る新たな~recordが追加されても，
`値は取得-済みか$Csが ~T に戻ることはない
（そうしてから もう一回~反復を試みても，例外が投出されることになる）。
】</p>

◎
When this flag is false, the cursor is either in the process of loading the next value or it has reached the end of its range. When it is true, it indicates that the cursor is currently holding a value and that it is ready to iterate to the next one.
</dd>

	<dt>
`実効~保管庫@Cs
◎
↓</dt>
	<dd>
~cursorの`~source$Cs↗が［
`保管庫$ならば それ／
`索引$ならば それが`専属する$`保管庫$
］。
◎
↓</dd>
	<dt>
`実効~key@Cs
（ `primaryKey$m ）
◎
↓</dt>
	<dd>
~cursorの`~source$Cs↗が［
`保管庫$ならば ~cursorの`位置$Cs ／
`索引$ならば ~cursorの`保管庫~位置$Cs
］。
◎
If the source of a cursor is an object store, the effective object store of the cursor is that object store and the effective key of the cursor is the cursor’s position. If the source of a cursor is an index, the effective object store of the cursor is that index’s referenced object store and the effective key is the cursor’s object store position.
</dd>

	<dt>
`要請@Cs
◎
A cursor has a request,＼
</dt>
	<dd>
~cursorを~openするときに利用された`要請$。
◎
which is the request used to open the cursor.
</dd>

	<dt>
`~keyのみか@Cs
◎
A cursor also has a key only flag,＼
</dt>
	<dd>
~cursorの`値$Csも~APIに公開されるかどうかを指示する真偽値。
◎
that indicates whether the cursor’s value is exposed via the API.
</dd>
	<dd class="trans-note">【
~F ならば、
値も~APIに公開する
— すなわち、
~cursorは `IDBCursorWithValue$I ~interfaceを実装することになる。
】</dd>
</dl>

		</section>
		<section id="key-generator-construct">
<h3 title="Key generators">2.11. ~key生成器</h3>

<p>
`保管庫$の作成-時には、
`~key生成器@
を利用するようにも指定できる。
~key生成器は、
保管庫の中へ挿入される~record用の~keyが指定されていない場合に，それを生成するために利用される。
◎
When a object store is created it can be specified to use a key generator. A key generator is used to generate keys for records inserted into an object store if not otherwise specified.
</p>

<p>
`~key生成器$は
`現在の番号@
を持つ。
`現在の番号$は、
`保管庫$の作成-時には 1 に設定され，常に［［
`最大の番号@
~EQ ( 2 の 53 乗（  9007199254740992 ） + 1 )
］以下の整数になる
【実際に利用される~keyは最大の番号~以下になる】
。
`現在の番号$は、
~keyが生成される度に増分される。
また，明示的な~keyを利用して特定の値に更新できる。
◎
A key generator has a current number. The current number is always a positive integer less than or equal to 253 (9007199254740992) + 1. The initial value of a key generator's current number is 1, set when the associated object store is created. The current number is incremented as keys are generated, and may be updated to a specific value by using explicit keys.
</p>

<p class="note">注記：
どの保管庫も，~~自前の`~key生成器$を利用する。
ある保管庫とのヤリトリが，他の保管庫の`~key生成器$に影響することは、
決してない。
◎
Every object store that uses key generators uses a separate generator. That is, interacting with one object store never affects the key generator of any other object store.
</p>

<div >
<p>
`現在の番号$に対する改変は、
~db演算の一部と見なされる：
</p>
<ul>
	<li>
演算が何であれ、
それが失敗して，それによる変更が復帰された場合、
`現在の番号$も元の値に復帰される。
</li>
	<li>
`~tx$が中止された場合、
~txの`視野$に入る各`保管庫$の`~key生成器$の`現在の番号$は，その~txの開始-前の値に復帰される。
</li>
</ul>
◎
Modifying a key generator’s current number is considered part of a database operation. This means that if the operation fails and the operation is reverted, the current number is reverted to the value it had before the operation started. This applies both to modifications that happen due to the current number getting increased by 1 when the key generator is used, and to modifications that happen due to a record being stored with a key value specified in the call to store the record.
◎
Likewise, if a transaction is aborted, the current number of the key generator for each object store in the transaction’s scope is reverted to the value it had before the transaction was started.
</div>

<p>
`現在の番号$は、
~db演算の結果が復帰される場合を除き，決して減少しない。
`保管庫$から`~record$を削除しようが， `IDBObjectStore.clear()$m ~methodを利用して全~recordを~clearしようが、
保管庫の`~key生成器$には決して影響しない。
◎
The current number for a key generator never decreases, other than as a result of database operations being reverted. Deleting a record from an object store never affects the object store’s key generator. Even clearing all records from an object store, for example using the clear() method, does not affect the current number of the object store’s key generator.
</p>

<p>
`~record$を格納する~callにて明示的に`~key$が指定されていない場合、
~keyは生成される。
◎
When a record is stored and a key is not specified in the call to store the record, a key is generated.
</p>

<div class="algo">
<p>
`保管庫~用の~keyを生成する@
ときは、
所与の
( `保管庫$ %保管庫 )
に対し，次を走らす：
◎
To generate a key for an object store store, run these steps:
</p>

<ol>
	<li>
%生成器 ~LET %保管庫 の`~key生成器$
◎
Let generator be store’s key generator.
</li>
	<li>
%~key ~LET %生成器 の`現在の番号$
◎
Let key be generator’s current number.
</li>
	<li>
~IF［
%~key ~GT `最大の番号$
］
⇒
~RET `失敗^i
◎
If key is greater than 253 (9007199254740992), then return failure.
</li>
	<li>
%生成器 の`現在の番号$ ~INCBY 1
◎
Increase generator’s current number by 1.
</li>
	<li>
~RET %~key
◎
Return key.
</li>
</ol>
</div>

<p>
`~record$を格納する~callにて`~key$が明示的に指定された場合、
`~key生成器$は更新され得る。
◎
When a record is stored and a key is specified in the call to store the record, the associated key generator may be updated.
</p>

<div class="algo">
<p>
`保管庫~用の~key生成器を可能なら更新する@
ときは、
所与の
( `保管庫$ %保管庫, `~key$ %~key )
に対し，次を走らす：
◎
To possibly update the key generator for an object store store with key, run these steps:
</p>

<ol>
	<li>
~IF［
%~key の`種別$key ~NEQ `number$i
］
⇒
~RET
◎
If the type of key is not number, abort these steps.
</li>
	<li>
%値 ~LET %~key の`値$key
◎
Let value be the value of key.
</li>
	<li>
%値 ~LET［
%値, `最大の番号$
］の両者を超えない最大の整数
◎
Let value be the minimum of value and 253 (9007199254740992).
◎
Let value be the largest integer not greater than value.
</li>
	<li>
%生成器 ~LET %保管庫 の`~key生成器$
◎
Let generator be store’s key generator.
</li>
	<li>
~IF［
%値 ~GTE %生成器 の`現在の番号$
］
⇒
%生成器 の`現在の番号$ ~SET %値 + 1
◎
If value is greater than or equal to generator’s current number, then set generator’s current number to value + 1.
</li>
</ol>
</div>

<div class="note">

<div class="p">
<p>注記：
~keyは、
を持つかどうかに応じて，次のいずれかにより指定できる：
</p>
<ul>
	<li>
`保管庫$の`~key~path$Os ~NEQ ε の場合
⇒
［
保管庫に格納する`~record$の`値$
］の［
~key~pathが指す部位にある~prop
］に~keyを設定する。
</li>
	<li>
他の場合
⇒
~recordを格納する~callの引数として，~keyを渡す。
</li>
</ul>
◎
A key can be specified both for object stores which use in-line keys, by setting the property on the stored value which the object store’s key path points to, and for object stores which use out-of-line keys, by passing a key argument to the call to store the record.
</div>

<p>
指定された~keyが`現在の番号$に影響するのは、
その`種別$keyが `number$i の場合に限られ、
他の`種別$keyの~keyは影響しない
— `string$i 値を `number$i 値に構文解析するような，暗黙的な変換の類は行われない。
また、
1 より小さい `number$i ~keyも，`現在の番号$より常に低いので影響しない。
◎
Only specified keys of type number can affect the current number of the key generator. Keys of type date, array (regardless of the other keys they contain), binary, or string (regardless of whether they could be parsed as numbers) have no effect on the current number of the key generator. Keys of type number with value less than 1 do not affect the current number since they are always lower than the current number.
</p>
</div>

<p>
`現在の番号$が`最大の番号$を超えた下では、
`~key生成器$を利用して新たな`~key$を生成させるような 後続のどの試みに対しても `ConstraintError$E 例外が投出される。
それでも、
明示的な~keyを指定すれば，`~record$を保管庫に挿入できるが、
`~key生成器$を再び利用するためには，保管庫を削除して新たに作成し直す他にない。
◎
When the current number of a key generator reaches above the value 253 (9007199254740992) any subsequent attempts to use the key generator to generate a new key will result in a "ConstraintError" DOMException. It is still possible to insert records into the object store by specifying an explicit key, however the only way to use a key generator again for such records is to delete the object store and create a new one.
</p>

<div class="note">

<p>注記：
この上限は、
`最大の番号$を超える整数は~ES `Number$jT では一意に表現できないことによる。
例えば~ESにおいては、［
`9007199254740992 + 1 === 9007199254740992^c
］になる。
◎
This limit arises because integers greater than 9007199254740992 cannot be uniquely represented as ECMAScript Numbers. As an example, 9007199254740992 + 1 === 9007199254740992 in ECMAScript.
</p>

<p>
`~key生成器$を普通に利用している限り、
この上限は問題にはならない。
新たな~keyを毎秒 1000 回~生成し続けても，この上限に至るのは 285000 年後である。
◎
As long as key generators are used in a normal fashion this limit will not be a problem. If you generate a new key 1000 times per second day and night, you won’t run into this limit for over 285000 years.
</p>
</div>

<div class="p">
<p>
~~要約すると、
`~key生成器$を持つような保管庫に対しては：
</p>
<ul>
	<li>
最初に生成される~keyは
（他の `number$i ~keyが明示的に挿入されない限り）
常に 1 になる。
</li>
	<li>
生成される~keyは、
常に，保管庫~内の最大の `number$i ~keyより大きい，正な整数になる。
</li>
	<li>
同じ保管庫に対し，同じ~keyが重ねて生成されることは、
~txが巻戻されない限り，決してない。
</li>
</ul>

◎
A practical result of this is that the first key generated for an object store is always 1 (unless a higher numeric key is inserted first) and the key generated for an object store is always a positive integer higher than the highest numeric key in the store. The same key is never generated twice for the same object store unless a transaction is rolled back.
</div>

<aside class="example" id="example-key-generator">

<p>
`~key生成器$は、
保管庫ごとに別々に~~維持される：
◎
Each object store gets its own key generator:
</p>

<pre class="lang-js">
%store1 = db.createObjectStore(`store1^l, { autoIncrement: true });
%store1.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store2 = db.createObjectStore(`store2^l, { autoIncrement: true });
%store2.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store1.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span>
%store2.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span></pre>

<p>
挿入が，拘束~違反や IO ~errorに因り失敗した場合、
`~key生成器$は更新されない。
◎
If an insertion fails due to constraint violations or IO error, the key generator is not updated.
</p>

<pre class="lang-js">
%transaction.onerror = function(%e) { %e.preventDefault() };
%store = %db.createObjectStore(`store1^l, { autoIncrement: true });
%index = %store.createIndex(`index1^l, `ix^l, { unique: true });
%store.put({ ix: `a^l}); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store.put({ ix: `a^l}); // <span class="comment"
	title="Will fail">失敗することになる</span>
%store.put({ ix: `b^l}); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span></pre>

<p>
保管庫から~itemを除去しようが，`~key生成器$には影響しない
— `clear()^m が~callされたときも含め。
◎
Removing items from an objectStore never affects the key generator. Including when clear() is called.
</p>

<pre class="lang-js">
%store = %db.createObjectStore(`store1^l, { autoIncrement: true });
%store.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store.delete(`1^lt);
%store.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span>
%store.clear();
%store.put(`c^l); // <span class="comment"
	title="Will get key 3">~key `3^jv があてがわれる</span>
%store.delete(IDBKeyRange.lowerBound(`0^lt));
%store.put(`d^l); // <span class="comment"
	title="Will get key 4">~key `4^jv があてがわれる</span></pre>

<p>
明示的な~keyを伴わせて~itemを挿入した場合、［
その~keyは `number$i である，かつ 最後に生成された~keyより大きい
］とき，そのときに限り，`~key生成器$に影響する。
◎
Inserting an item with an explicit key affects the key generator if, and only if, the key is numeric and higher than the last generated key.
</p>

<pre class="lang-js">
%store = %db.createObjectStore(`store1^l, { autoIncrement: true });
%store.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store.put(`b^l, `3^lt); // <span class="comment"
	title="Will use key 3">~key `3^jv を利用する</span>
%store.put(`c^l); // <span class="comment"
	title="Will get key 4">~key `4^jv があてがわれる</span>
%store.put(`d^l, -`10^lt); // <span class="comment"
	title="Will use key -10">~key `-10^jv を利用する</span>
%store.put(`e^l); // <span class="comment"
	title="Will get key 5">~key `5^jv があてがわれる</span>
%store.put(`f^l, `6.00001^lt); // <span class="comment"
	title="Will use key 6.0001">~key `6.0001^jv を利用する</span>
%store.put(`g^l); // <span class="comment"
	title="Will get key 7">~key `7^jv があてがわれる</span>
%store.put(`f^l, `8.9999^lt); // <span class="comment"
	title="Will use key 8.9999">~key `8.9999^jv を利用する</span>
%store.put(`g^l); // <span class="comment"
	title="Will get key 9">~key `9^jv があてがわれる</span>
%store.put(`h^l, `foo^l); // <span class="comment"
	title="Will use key &quot;foo&quot;">~key `foo^l を利用する</span>
%store.put(`i^l); // <span class="comment"
	title="Will get key 10">~key `10^jv があてがわれる</span>
%store.put(`j^l, [`1000^lt]); // <span class="comment"
	title="Will use key [1000]">~key `[1000]^jv を利用する</span>
%store.put(`k^l); // <span class="comment"
	title="Will get key 11">~key `11^jv があてがわれる</span>
/* <span class="comment">
これらはどれも、
保管庫が~key~pathを利用している下で，~objの中に明示的に~keyを埋め込んで渡したときと，同じに挙動することになる。
◎
All of these would behave the same if the objectStore used a keyPath and the explicit key was passed inline in the object
</span> */
</pre>

<p>
~txが中止された場合、
その間に起きた`~key生成器$に対する増加-は巻戻される。
これにより、
すべての巻戻しは一貫するようになる
— ~crashに因る巻戻しは、
増加された~key生成器の`現在の番号$を`~commit$する機会を得ることは決してないので。
◎
Aborting a transaction rolls back any increases to the key generator which happened during the transaction. This is to make all rollbacks consistent since rollbacks that happen due to crash never has a chance to commit the increased key generator value.
</p>

<pre class="lang-js">
%db.createObjectStore(`store^l, { autoIncrement: true });
%trans1 = %db.transaction([`store^l], `readwrite$l);
%store_t1 = %trans1.objectStore(`store^l);
%store_t1.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store_t1.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span>
%trans1.abort();
%trans2 = %db.transaction([`store^l], `readwrite$l);
%store_t2 = trans2.objectStore(`store^l);
%store_t2.put(`c^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store_t2.put(`d^l); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span>
</pre>
</aside>

<aside class="example" id="example-inline-keygen">

<p>
ある~objを保管庫に保存するときに
（例えば `IDBObjectStore.put()$m を用いて），［
`~key~path$Osを利用するとき
］と, ［
`~key生成器$を利用するとき
］との挙動の相違を、
以下の例にて~~説明する。
◎
The following examples illustrate the different behaviors when trying to use in-line keys and key generators to save an object to an object store.
</p>

<p>
以下では：
</p>

<ul>
	<li>
保管庫に保存する ~objを %O と記す。
</li>
	<li>
%O を保管庫に保存した結果の`~record$を %R と記す。
%O は
（ `StructuredSerializeForStorage$jA された上で）
%R の`値$として保存される。
</li>
	<li>
保管庫は`~key生成器$を持つとする。
この生成器が次回に供する値を、
%生成key と記す。
</li>
</ul>

<p>
保管庫の`~key~path$Os ~EQ ε ならば、
%R の`~key$には %生成key があてがわれることになる。
以降、
保管庫の`~key~path$ %keyPath ~NEQ ε とする。
</p>

<p>
次の様に %O が %keyPath が指す部位に~propを持たないならば：
</p>

<pre class="lang-js">
%keyPath = `foo.bar^l
%O = { foo: {} }
</pre>

<p>
%O が保管庫に保存されるときには， %生成key がその~prop
（ここでは %O`.foo.bar^c ）
の値にあてがわれる：
</p>

<pre class="lang-js">
%R の`値$ = { foo: { <mark>bar: %生成key</mark> } }
</pre>

<p>
逆に、
%O が %keyPath が指す部位に~propを持つ場合：
</p>

<pre class="lang-js">
%O = { foo: { bar: <mark>10</mark> } }
</pre>

<p>
%生成key は利用されず、
%R の~keyには %keyPath が指す部位の値が
（この例では <mark>10</mark> ），利用される。
</p>

<p>
~systemは、
~prop階層を満たすに必要な分の~propを作成する責を負う。
例えば：
</p>

<pre class="lang-js">
%keyPath = `foo.bar.baz^l
%O = {}
</pre>

<p>
であれば、
%O が`保管庫$に保存されるときには，［
`foo^c, `bar^c, `baz^c
］~propが順に入れ~~子にされた上で，
%keyPath が指す部位に %生成key があてがわれる：
</p>

<pre class="lang-js">
%R の`値$ = { foo: { bar: { baz: %生成key } } }
</pre>

<p>
~primitive値~上に~propを格納しようと試みられた場合、
失敗して~errorが投出されることになる。
例えば：
</p>

<pre class="lang-js">
%keyPath = `foo^l
%O = 4
</pre>

<p>
であれば、
%O は~primitive値なので~propを定義できず，失敗する。
これは、
配列（ 例えば %O = `[10]^c ）にも該当する。
配列~上にも~propは許容されないので、
~propを定義しようと試行しても失敗する：
</p>

<p class="trans-note">【
原文の記述構成は（少なくとも，そのまま訳すと）解りにくいので、
この例の訳は等価な記述に全面的に構成し直している。
】</p>

<div lang="en" class="_en">

<p>If the following conditions are true:</p>
<ul>
<li>The object store has a key generator.</li>
<li>There is no in-line value for the key path property.</li>
</ul>
<p>
Then the value provided by the key generator is used to populate the key value.
In the example below the key path for the object store is "foo.bar".
The actual object has no value for the bar property, { foo: {} }.
When the object is saved in the object store the bar property is assigned a value of 1
because that is the next key generated by the key generator.
</p>
<pre class="lang-js">
const store = db.createObjectStore("store", { keyPath: "foo.bar", autoIncrement: true });
store.put({ foo: {} }).onsuccess = function(e) {
  const key = e.target.result;
  console.assert(key === 1);
};
</pre>
<p>If the following conditions are true:</p>
<ul>
<li>The object store has a key generator.</li>
<li>There is a value for the key path property.</li>
</ul>
<p>
Then the value associated with the key path property is used.
The auto-generated key is not used.
In the example below the key path for the object store is "foo.bar".
The actual object has a value of 10 for the bar property, { foo: { bar: 10} }.
When the object is saved in the object store the bar property keeps its value of 10, because that is the key value.
</p>

<pre class="lang-js">
const store = db.createObjectStore("store", { keyPath: "foo.bar", autoIncrement: true });
store.put({ foo: { bar: 10 } }).onsuccess = function(e) {
  const key = e.target.result;
  console.assert(key === 10);
};
</pre>
<p>
The following example illustrates the scenario when the specified in-line key is defined through a key path but there is no property matching it.
The value provided by the key generator is then used to populate the key value and the system is responsible
for creating as many properties as it requires to suffice the property dependencies on the hierarchy chain.
In the example below the key path for the object store is "foo.bar.baz".
The actual object has no value for the foo property, { zip: {} }.
When the object is saved in the object store the foo, bar, and baz properties
are created each as a child of the other until a value for foo.bar.baz can be assigned.
The value for foo.bar.baz is the next key generated by the object store.
</p>
<pre class="lang-js">
const store = db.createObjectStore("store", { keyPath: "foo.bar.baz", autoIncrement: true });
store.put({ zip: {} }).onsuccess = function(e) {
  const key = e.target.result;
  console.assert(key === 1);
  store.get(key).onsuccess = function(e) {
    const value = e.target.result;
    // value will be: { zip: {}, foo: { bar: { baz: 1 } } }
    console.assert(value.foo.bar.baz === 1);
  };
};
</pre>
<p>
Attempting to store a property on a primitive value will fail and throw an error.
In the first example below the key path for the object store is "foo".
The actual object is a primitive with the value, 4.
Trying to define a property on that primitive value fails.
The same is true for arrays.  Properties are not allowed on an array.
In the second example below, the actual object is an array, [10].
Trying to define a property on the array fails.
</p>
<pre class="lang-js">
const store = db.createObjectStore("store", { keyPath: "foo", autoIncrement: true });

// The key generation will attempt to create and store the key path property on this primitive.
store.put(4); // will throw DataError

// The key generation will attempt to create and store the key path property on this array.
store.put([10]); // will throw DataError
</pre>

</div>
</aside>

		</section>
	</section>
	<section id="exceptions">
<h3 title="Exceptions">3. 例外</h3>

<p>
この文書が利用する各種 例外は，特定の名前の `DOMException$I である。
例外の名前と その旧来の~code値などの~propは `WEBIDL$r
【<a href="~WEBIDL#dfn-error-names-table">~error名~一覧</a>】
にて定義されている。
◎
Each of the exceptions used in this document is a DOMException with a specific type. The exception types and properties such as legacy code value are defined in [WEBIDL].
</p>

<p>
以下の一覧に、
この文書が利用する 例外~名, および その用法を述べる：
◎
The table below lists the DOMExceptions used in this document along with a description of the exception type’s usage.
</p>

<table class="_row">
<thead><tr><th>例外~名
<th>意味
</thead>

<tbody><tr><td>`AbortError@E
<td>
`要請$は中止された。
◎
A request was aborted.

<tr><td>`ConstraintError@E
<td>
~txにおける変異~演算は、
拘束が満たされないため，失敗した。
◎
A mutation operation in the transaction failed because a constraint was not satisfied.

<tr><td>`DataCloneError@E
<td>
格納しようと試みた~dataは、
内部~有構造~clone~algoにより~cloneできなかった。
◎
The data being stored could not be cloned by the internal structured cloning algorithm.

<tr><td>`DataError@E
<td>
演算に供された~dataは、
要件を満たしていない。
◎
Data provided to an operation does not meet requirements.

<tr><td>`InvalidAccessError@E
<td>
~objに対し妥当でない演算が遂行された。
◎
An invalid operation was performed on an object.

<tr><td>`InvalidStateError@E
<td>
~objに対する所与の演算は、
許容されない, あるいは許容されない時機に~callされた。
または、
すでに［
削除された／除去された
］~source~objに対し要請が為された。
◎
An operation was called on an object on which it is not allowed or at a time when it is not allowed, or if a request is made on a source object that has been deleted or removed.

<tr><td>`NotFoundError@E
<td>
要請された~db~objを見出せなかったため、
演算は失敗した。
◎
The operation failed because the requested database object could not be found.

<tr><td>`QuotaExceededError@E
<td>
残りの~storage~~容量が十分でないため、
あるいは，~storage~quotaに達したが，利用者が~dbへの容量追加を辞退しため、
演算は失敗した。
◎
The operation failed because there was not enough remaining storage space, or the storage quota was reached and the user declined to give more space to the database.

<tr><td>`SyntaxError@E
<td>
渡された %keyPath 引数は，`妥当な~key~path$でない。
◎
The keyPath argument contains an invalid key path.

<tr><td>`ReadOnlyError@E
<td>
`~readonly~tx$において，変異~演算が試みられた。
◎
The mutating operation was attempted in a read-only transaction.

<tr><td>`TransactionInactiveError@E
<td>
［
現在は`作動中$i でない／すでに`完遂-$した
］~txに対し，要請が設置された。
◎
A request was placed against a transaction which is currently not active, or which is finished.

<tr><td>`UnknownError@E
<td>
演算は、［
~db自身に無関係な，他の~errorにも該当しない事由
］で失敗した。
◎
The operation failed for reasons unrelated to the database itself and not covered by any other errors.

<tr><td>`VersionError@E
<td>
既存の~versionより低い~versionで~dbを~openしようと試みられた。
◎
An attempt was made to open a database using a lower version than the existing version.
</tbody></table>

<p class="note">注記：
複数の Indexed DB 演算が，同じ型の~errorを投出したり、
単独の演算であっても，複数の事由に対し同じ型の~errorを投出し得るので、
実装には、
より~~詳細な~messageを供して，~errorを~debugし易くすることが奨励される。
◎
Given that multiple Indexed DB operations can throw the same type of error, and that even a single operation can throw the same type of error for multiple reasons, implementations are encouraged to provide more specific messages to enable developers to identify the cause of errors.
</p>

	</section>
	<section id="async-api">
<h2 title="APIs">4. ~API</h2>

<p>
各種~API~methodは、
それを~callした~threadを阻むことなく返す。
すべての非同期的な演算は、
即時に `IDBRequest$I ~instanceを返す。
この~objは、
初期~時には，演算の結果について，いかなる情報も包含しない。
情報が可用になったなら、
要請に向けて~eventが発火され，情報は `IDBRequest$I ~instanceの各種~属性を通して可用になる。
◎
The API methods return without blocking the calling thread. All asynchronous operations immediately return an IDBRequest instance. This object does not initially contain any information about the result of the operation. Once information becomes available, an event is fired on the request and the information becomes available through the properties of the IDBRequest instance.
</p>

<p>
`~db~access~task源@
が、
これらの~taskの`~task源$である。
◎
The task source for these tasks is the database access task source.
 </p>

		<section id="request-api">
<h3 title="The IDBRequest interface">4.1. `IDBRequest^I ~interface</h3>

<p>
`IDBRequest$I ~interfaceが、
`~db$や, それに専属する各種~objに対する非同期的な`要請$の結果に~accessする手段を，`~event~handler~IDL属性$ `HTML$r を利用して供する。
◎
The IDBRequest interface provides the means to access results of asynchronous requests to databases and database objects using event handler IDL attributes [HTML].
</p>

<p>
~dbに対し`演算$を要請するような どの~methodも，［
~eventを通して，要請している~appに`結果$を~~返信する
］ような， `IDBRequest$I ~objを返す。
すなわち，`演算$は非同期に実行される。
この設計は、
どの`~db$に対しても，いくつもの要請が同時に作動中になり得ることを意味する。
◎
Every method for making asynchronous requests returns an IDBRequest object that communicates back to the requesting application through events. This design means that any number of requests can be active on any database at a time.
</p>

<aside class="example" id="example-async-requests">

<p>
次の例では、
`~db$を非同期に~openする。
種々の状況に応答するために、
種々の~event~handlerが登録される。
◎
In the following example, we open a database asynchronously. Various event handlers are registered for responding to various situations.
</p>

<pre class="lang-js">
const %request = `indexedDB$m.open('AddressBook', `15^lt);
%request.onsuccess = function(%evt) {...};
%request.onerror = function(%evt) {...};
</pre>
</aside>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBRequest@I : `EventTarget$I {
  readonly attribute `any$ `result$m;
  readonly attribute `DOMException$I? `error$m;
  readonly attribute (`IDBObjectStore$I or `IDBIndex$I or `IDBCursor$I)? `source$m;
  readonly attribute `IDBTransaction$I? `transaction$m;
  readonly attribute `IDBRequestReadyState$I `readyState$m;

  // <span class="comment" title="Event handlers">~event~handler：</span>
  attribute `EventHandler$I `onsuccess$m;
  attribute `EventHandler$I `onerror$m;
};

enum `IDBRequestReadyState@I {
  `pending$l,
  `done$l
};
</pre>

<!-- `IDBRequest!I -->
<div class="note domintro">
<dl>
	<dt>%request . `result$m</dt>
	<dd>
%request が完了している場合、
それが［
成功したならば その`結果$ ／
失敗したならば `undefined^jv
］を返す。
完了していない場合、
`InvalidStateError$E を投出する。
◎
When a request is completed, returns the result, or undefined if the request failed. Throws a "InvalidStateError" DOMException if the request is still pending.
</dd>

	<dt>%request . `error$m</dt>
	<dd>
%request が完了している場合、
それが［
成功したならば ~NULL ／
失敗したならば `~error$ （ `DOMException$I ）
］を返す。
完了していない場合、
`InvalidStateError$E を投出する。
◎
When a request is completed, returns the error (a DOMException), or null if the request succeeded. Throws a "InvalidStateError" DOMException if the request is still pending.
</dd>

	<dt>%request . `source$m</dt>
	<dd>
%request は`~open要請$である場合、
~NULL を返す。
他の場合、
%request の`~source$
（ `IDBObjectStore$I ／ `IDBIndex$I ／ `IDBCursor$I ）
を返す。
◎
Returns the IDBObjectStore, IDBIndex, or IDBCursor the request was made against, or null if it was an open request.
</dd>

	<dt>%request . `transaction$m</dt>
	<dd>
%request の`設置-先~tx$
（ `IDBTransaction$I ）
を返す。
ただし， %request は`~open要請$である場合は、
それにより~openされた`~db$の`昇格~tx$dbが`稼働して$［
いるならば それ ／
いなければ ~NULL
］を返す。
◎
Returns the IDBTransaction the request was made within. If this as an open request, then it returns an upgrade transaction while it is running, or null otherwise.
</dd>

	<dt>%request . `readyState$m</dt>
	<dd>
%request が完了して［
いなければ `pending$l ／
いれば `done$l
］を返す。
◎
Returns "pending" until a request is complete, then returns "done".
</dd>
</dl>
</div>

<div class="algo">
<p>
`result@m
取得子~手続きは：
◎
The result getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`済んだか$ ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this's done flag is false, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~RET ［
コレの`結果$ ~NEQ ε ならば それ ／
~ELSE_（すなわちコレの`~error$ ~NEQ ε ） `undefined^jv
］
◎
Otherwise, return this's result, or undefined if the request resulted in an error.
</li>
</ol>

<p class="trans-note">【
結果 ~NEQ ε の場合でも，結果~自身は `undefined^jv にもなり得る
（ `IDBObjectStore.get()$m の注記を見よ）。
】</p>
</div>

<div class="algo">
<p>
`error@m
取得子~手続きは：
◎
The error getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`済んだか$ ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this's done flag is false, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~RET［
コレの`~error$ ~NEQ ε ならば それ ／
~ELSE_（すなわちコレの`結果$ ~NEQ ε ならば） ~NULL
］
◎
Otherwise, return this's error, or null if no error occurred.
</li>
</ol>
</div>

<div class="algo">
`source@m
取得子~手続きは
⇒
~RET ［
コレの`~source$ ~NEQ ε ならば それ ／
~ELSE_ ~NULL
］
◎
The source getter steps are to return this's source, or null if no source is set.
</div>

<div class="algo">
<p>
`transaction@m
取得子~手続きは
⇒
~RET ［
コレの`設置-先~tx$ ~NEQ ε ならば それ ／
~ELSE_ ~NULL
］
◎
The transaction getter steps are to return this's transaction.
</p>

<p class="note">注記：
この取得子は、
ある種の要請
— `IDBFactory.open()$m から返される`要請$など —
においては ~NULL を返すこともある。
◎
The transaction getter can return null for certain requests, such as for requests returned from open().
</p>
</div>

<div class="algo">
`readyState@m
取得子~手続きは
⇒
~RET コレの`済んだか$に応じて［
~F ならば
`pending@l
／
~T ならば
`done@l
］
◎
The readyState getter steps are to return "pending" if this's done flag is false, and "done" otherwise.
</div>

<p>
`onsuccess@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `success$et である。
◎
The onsuccess attribute is an event handler IDL attribute whose event handler event type is success.
</p>

<p>
`onerror@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `error$et である。
◎
The onerror attribute is an event handler IDL attribute whose event handler event type is error event.
</p>

<p>
`IDBDatabase$I 上の `~open要請$を返す各種~methodは、［
`blocked$et, `upgradeneeded$et
］~eventを~listenできるように拡張された~interfaceを利用する。
◎
Methods on IDBDatabase that return a open request use an extended interface to allow listening to the blocked and upgradeneeded events.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBOpenDBRequest@I : `IDBRequest$I {
  // <span class="comment" title="Event handlers">~event~handler：</span>
  attribute `EventHandler$I `onblocked$m;
  attribute `EventHandler$I `onupgradeneeded$m;
};
</pre>

<p>
`onblocked@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `blocked$et である。
◎
The onblocked attribute is an event handler IDL attribute whose event handler event type is blocked.
</p>

<p>
`onupgradeneeded@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `upgradeneeded$et である。
◎
The onupgradeneeded attribute is an event handler IDL attribute whose event handler event type is upgradeneeded.
</p>

		</section>
		<section id="events">
<h3 title="Event interfaces">4.2. ~event~interface</h3>

<p>
この仕様は、
次の~custom~interfaceによる~eventを発火する：
◎
This specification fires events with the following custom interfaces:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBVersionChangeEvent@I : `Event$I {
  `constructor@(`DOMString$ %type, optional `IDBVersionChangeEventInit$I %eventInitDict = {});
  readonly attribute `unsigned long long$ `oldVersion$m;
  readonly attribute `unsigned long long$? `newVersion$m;
};

dictionary `IDBVersionChangeEventInit@I : `EventInit$I {
  `unsigned long long$ `oldVersion@m = 0;
  `unsigned long long$? `newVersion@m = null;
};
</pre>

<!-- `IDBVersionChangeEvent!I -->

<div class="algo">
`oldVersion@m
取得子~手続きは、
初期化-時の値を返す。
それは、
当の~dbの以前の`~version$dbを表現する。
◎
The oldVersion getter steps are to return the value it was initialized to. It represents the previous version of the database.
</div>

<div class="algo">
`newVersion@m
取得子~手続きは、
初期化-時の値を返す。
それは、
当の~dbの新たな`~version$dbを表現するが，~dbが削除されつつあるときは ~NULL になる。
`昇格~txを稼働する$手続きを見よ。
◎
The newVersion getter steps are to return the value it was initialized to. It represents the new version of the database, or null if the database is being deleted. See the steps to run an upgrade transaction.
</div>

<p>
~eventは、
`DOM^cite <a href="~DOM4#constructing-events">§ ~eventの構築-法</a>
に定義されるとおり構築される。
◎
Events are constructed as defined in DOM § 2.5 Constructing events.
</p>

<div class="algo">
<p>
`~version変更~eventを発火する@
ときは、
所与の
( %標的, %~event名, %旧~version, %新~version )
に対し，次を走らす：
◎
To fire a version change event named e at target given oldVersion and newVersion, run these steps:
</p>

<ol>
	<li>
%~event ~LET `~eventを作成する$( `IDBVersionChangeEvent$I )
◎
Let event be the result of creating an event using IDBVersionChangeEvent.
</li>
	<li>
%~event の各種~属性を次のように初期化する
⇒＃
`type$m ~SET %~event名,
`bubbles$m ~SET ~F,
`cancelable$m ~SET ~F,
`oldVersion$m ~SET %旧~version,
`newVersion$m ~SET %新~version
◎
• Set event’s type attribute to e.
• Set event’s bubbles and cancelable attributes to false.
• Set event’s oldVersion attribute to oldVersion.
• Set event’s newVersion attribute to newVersion.
</li>
	<li>
~RET `Dispatch$( %標的, %~event )
◎
Let legacyOutputDidListenersThrowFlag be false.
◎
Dispatch event at target with legacyOutputDidListenersThrowFlag.
◎
Return legacyOutputDidListenersThrowFlag.
</li>
</ol>

<p class="note">注記：
この~algoの結果は利用されないこともある。
◎
The return value of this algorithm is not always used.
</p>
</div>

		</section>
		<section id="_event-types">
<h3>【 各種~event型の一覧 】</h3>

<p>
便宜のため、
この訳では，この仕様が利用する各種~event型を以下に要約する。
</p>

<p>
これらの~eventは、［
`要請$, `~tx$, `接続$
］のいずれかに向けて発火される。
~eventは、
`親~標的を取得する$~algoを通して，複数の~objに伝播する場合もある。
親~標的は、［
`~open要請$に対しては ~NULL ／
他の`要請$に対しては その`設置-先~tx$ ／
`~tx$に対しては それが`専属する$`接続$ ／
`接続$に対しては ~NULL
］になる。
</p>

<table><thead><tr><th>~event
<th>発火-時機と標的
</thead><tbody>

<tr><td>`versionchange$et
<td>`~db$を昇格-（または削除-）しようとしたとき，
同じ~dbを~openしている他の`接続$に向けて発火される。

<tr><td>`close$et
<td>`接続$が例外的な状況下で~closeされたとき，その接続に向けて発火される。

<tr><td>`upgradeneeded$et
<td>`~db$を~openした際に`昇格~tx$が生じたとき，その`~open要請$に向けて発火される。

<tr><td>`blocked$et
<td>他の`接続$がまだ `~close済み$i でないために，［
`~dbを~openする$ ／ `~dbを削除する$
］`要請$が阻まれたとき、
その`~open要請$に向けて発火される。

<tr><td>`success$et
<td>`要請$が成功したとき，その要請に向けて発火される。

<tr><td>`error$et
<td>何らかの~errorにより`要請$が失敗したとき，その要請に向けて発火される。

<tr><td>`complete$et
<td>`~tx$が`~commit$されたとき，その~txに向けて発火される。

<tr><td>`abort$et
<td>
`~tx$が~errorまたは `abort()^m により`中止-$されたとき，その~txに向けて発火される。

</tbody></table>

		</section>
		<section id="factory-interface">
<h3 title="The IDBFactory interface">4.3. `IDBFactory^I ~interface</h3>

<p>
`~db$~objは、
`IDBFactory$I ~interface上の各種~methodを通して~accessされる。
この~interfaceを実装する単独の~objは、
Indexed DB 演算を~supportする環境の大域~scopeに在る。
◎
Database objects are accessed through methods on the IDBFactory interface. A single object implementing this interface is present in the global scope of environments that support Indexed DB operations.
</p>

<pre class="idl" id="global-scope">
partial interface mixin `WindowOrWorkerGlobalScope!I {
  [`SameObject$] readonly attribute `IDBFactory$I `indexedDB$m;
};
</pre>

<p>
`indexedDB@m
属性は、
索引付き~dbの能力に~accessするための仕組みを，~appに供する。
◎
The indexedDB attribute provides applications a mechanism for accessing capabilities of indexed databases.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBFactory@I {
  [`NewObject$] `IDBOpenDBRequest$I `open$m(
      `DOMString$ %name,
      optional [`EnforceRange$] `unsigned long long$ %version
  );
  [`NewObject$] `IDBOpenDBRequest$I `deleteDatabase$m(
      `DOMString$ %name
  );
  `Promise$&lt;`sequence$&lt;`IDBDatabaseInfo$I&gt;&gt; `databases$m();

  short `cmp$m(
      `any$ %first,
      `any$ %second
  );
};

dictionary `IDBDatabaseInfo@I {
  `DOMString$ `name@m;
  `unsigned long long$ `version@m;
};
</pre>

<!-- `IDBFactory!I -->
<div class="note domintro">
<dl>
	<dt>%request = `indexedDB$m . `open(name)$m</dt>
	<dd>
`名前$db %name の`~db$への`接続$を，該当する`~db$が［
存在するならば その現在の`~version$db ／
存在しないならば`~version$db 1
］で~openするよう要請する。
成功した場合の %request （ `IDBOpenDBRequest$I ）の `result$m は、
その~dbへの`接続$になる。
◎
Attempts to open a connection to the named database with the current version, or 1 if it does not already exist. If the request is successful request’s result will be the connection.
</dd>

	<dt>%request = `indexedDB$m . `open(name, version)$m</dt>
	<dd>
<p>
`名前$db %name の`~db$への`接続$を，指定した~version %version で~openするよう要請する。
該当する~db %db が存在する場合，その`~version$dbが：
</p>
		<ul>
			<li>
%version より低い場合、［
%db を~openしている, かつ
`versionchange$et ~eventに呼応して %db を~closeしていない
］`接続$が他にあるならば、
要請は`阻まれ$，それらすべてが~closeされてから昇格が生じることになる。
</li>
			<li>
%version より高い場合、
要請は失敗することになる。
</li>
		</ul>
<p>
成功した場合の %request （ `IDBOpenDBRequest$I ）の `result$m は、
当の`接続$になる。
</p>
◎
Attempts to open a connection to the named database with the specified version. If the database already exists with a lower version and there are open connections that don’t close in response to a versionchange event, the request will be blocked until they all close, then an upgrade will occur. If the database already exists with a higher version the request will fail. If the request is successful request’s result will be the connection.
</dd>

	<dt>%request = `indexedDB$m . `deleteDatabase(name)$m</dt>
	<dd>
名前 %name の`~db$を削除するよう要請する。
該当する~db %db が存在する場合、［
%db を~openしている, かつ
`versionchange$et ~eventに呼応して %db を~closeしていない
］`接続$があるならば，要請は`阻まれ$ることになる。
成功した場合の %request の `result$m は、
~NULL になる。
◎
Attempts to delete the named database. If the database already exists and there are open connections that don’t close in response to a versionchange event, the request will be blocked until they all close. If the request is successful request’s result will be null.
</dd>

	<dt>%result = await `indexedDB$m . `databases$m()</dt>
	<dd>
一連の［
生成元に属する各~dbの名前と~versionからなる~obj
］からなる［
~snapshotを与える~list
］に解決される~promiseを返す。
◎
Returns a promise which resolves to a list of objects giving a snapshot of the names and versions of databases within the origin.
</dd>
	<dd>
この~APIは、
~dbの利用を~~見直す~web~app用に意図される
— 例えば、
~siteの~codeの早期~versionを片付けるなど。
結果は~snapshotであることに注意
— この文脈や他の文脈により~dbを［
作成する／昇格する／削除する
］要請との間で［
~dataの収集-順, 対する応答の送達-順
］についての保証は無い。
◎
This API is intended for web applications to introspect the use of databases, for example to clean up from earlier versions of a site’s code. Note that the result is a snapshot; there are no guarantees about the sequencing of the collection of the data or the delivery of the response with respect to requests to create, upgrade, or delete databases by this context or others.
</dd>
</dl>
</div>

<div class="algo">
<p>
`open(name, version)@m
~method手続きは：
◎
The open(name, version) method steps are:
</p>
<ol>
	<li>
~IF［
%version ~EQ 0
］
⇒
~THROW `TypeError$jT
◎
If version is 0 (zero), throw a TypeError.
</li>
	<li>
%生成元 ~LET コレに`関連な設定群~obj$の`生成元$enV
◎
Let environment be this's relevant settings object.
◎
Let origin be environment’s origin.
</li>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~THROW `SecurityError$E
◎
If origin is an opaque origin, throw a "SecurityError" DOMException and abort these steps.
</li>
	<li>
%要請 ~LET 新たな`~open要請$
◎
Let request be a new open request.
</li>
	<li>
<p>
この段は、
`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
<p>
%結果 ~LET `~dbを~openする$( %生成元, %name, %version, %要請 )
◎
Let result be the result of opening a database, with origin, name, version if given and undefined otherwise, and request.
</p>

<p class="note">注記：
名前 %name の`~db$が存在しなければ、
新たな`~db$が作成される。
%version が与えられていない場合、
接続は，［
既存の~dbに対しては その`~version$dbを変更することなく ／
新たな~dbに対しては その`~version$dbを 1 にして
］~openすることになる。
【！ details 】
◎
What happens if version is not given?
◎
If version is not given and a database with that name already exists, a connection will be opened without changing the version. If version is not given and no database with that name exists, a new database will be created with version equal to 1.
</p>
			</li>
			<li>
<p>
次を走らす`~taskを~queueする$：
◎
Queue a task to run these steps:
</p>
				<ol>
					<li>
%要請 の
⇒＃
`済んだか$ ~SET ~T,
`結果$ ~SET ε,
`~error$ ~SET ε
◎
↓</li>
					<li>
<p>
~IF［
%結果 は~errorである
］：
</p>
						<ol>
							<li>
%要請 の`~error$ ~SET %結果
</li>
							<li>
`~eventを発火する$( %要請, `error$et )
— 次のように初期化して
⇒＃
`bubbles$m 属性 ~SET ~T,
`cancelable$m 属性 ~SET ~T
</li>
						</ol>
◎
If result is an error, then:
• Set request’s result to undefined.
• Set request’s error to result.
• Set request’s done flag to true.
• Fire an event named error at request with its bubbles and cancelable attributes initialized to true.
</li>
					<li>
<div class="p">
<p>
~ELSE：
</p>
						<ol>
							<li>
%要請 の`結果$ ~SET %結果
</li>
							<li>
`~eventを発火する$( %要請, `success$et )
</li>
						</ol>
◎
Otherwise:
• Set request’s result to result.
• Set request’s done flag to true.
• Fire an event named success at request.
</div>

<p class="note">注記：
上の`~dbを~openする$手続きが`昇格~txを稼働-$させた場合、
この段は その昇格~txが`完遂-$した後に走ることになる。
これは、
別の~versionへの昇格が起こりつつある場合に，最初に`接続$上に `success$et ~eventを発火して、
~scriptが［
`versionchange$et ~event用の~listenerを登録する機会
］を得られることを確保する【？】。
◎
If the steps above resulted in an upgrade transaction being run, these steps will run after that transaction finishes. This ensures that in the case where another version upgrade is about to happen, the success event is fired on the connection first so that the script gets a chance to register a listener for the versionchange event.
</p>

<p class="note">注記：
ここで，通常の［
`~success~eventを発火する$ ／
`~error~eventを発火する$
］手続きを適用しないのは、
要請の`設置-先~tx$がないためである
（その手続きは，`設置-先~tx$を配送-前に作動化して配送-後に作動中でなくする）。
【！ details 】
◎
Why aren’t the steps to fire a success event or fire an error event used?
◎
There is no transaction associated with the request (at this point), so those steps — which activate an associated transaction before dispatch and deactivate the transaction after dispatch — do not apply.
</p>

					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %要請 を表現する，新たな `IDBOpenDBRequest$I ~obj
◎
Return a new IDBOpenDBRequest object for request.
</li>
</ol>
</div>

<div class="algo">
<p>
`deleteDatabase(name)@m
~method手続きは：
◎
The deleteDatabase(name) method steps are:
</p>
<ol>
	<li>
%生成元 ~LET コレに`関連な設定群~obj$の`生成元$enV
◎
Let environment be this's relevant settings object.
◎
Let origin be environment’s origin.
</li>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~THROW `SecurityError$E
◎
If origin is an opaque origin, throw a "SecurityError" DOMException and abort these steps.
</li>
	<li>
%要請 ~LET 新たな`~open要請$
◎
Let request be a new open request.
</li>
	<li>
<p>
この段は、
`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
%結果 ~LET `~dbを削除する$( %生成元, %name, %要請 )
◎
Let result be the result of deleting a database, with origin, name, and request.
</li>
			<li>
%要請 の`処理-済みか$ ~SET ~T
◎
Set request’s processed flag to true.
</li>
			<li>
<p>
次を走らす`~taskを~queueする$：
◎
Queue a task to run these steps:
</p>
				<ol>
					<li>
%要請 の
⇒＃
`済んだか$ ~SET ~T,
`結果$ ~SET ε,
`~error$ ~SET ε
◎
↓</li>
					<li>
<p>
~IF［
%結果 は~errorである
］：
</p>
						<ol>
							<li>
%要請 の`~error$ ~SET %結果
</li>
							<li>
`~eventを発火する$( %要請, `error$et )
— 次のように初期化して
⇒＃
`bubbles$m 属性 ~SET ~T,
`cancelable$m 属性 ~SET ~T
</li>
						</ol>
◎
If result is an error, set request’s error to result, set request’s done flag to true, and fire an event named error at request with its bubbles and cancelable attributes initialized to true.
</li>
					<li>
<p>
~ELSE：
</p>
						<ol>
							<li>%要請 の`結果$ ~SET ε
</li>
							<li>
`~version変更~eventを発火する$( %要請, `success$et, %結果, ~NULL )
</li>
						</ol>
◎
Otherwise, set request’s result to undefined, set request’s done flag to true, and fire a version change event named success at request with result and null.
</li>
				</ol>
<p class="note">注記：
この時点では、
要請の`設置-先~tx$はないので、
通常の［
`~success~eventを発火する$ ／
`~error~eventを発火する$
］手続きは
（それは，`設置-先~tx$を配送-前に作動化して配送-後に作動中でなくする），
適用できない。
また、
ここでの
`success$et ~eventは `IDBVersionChangeEvent$I であり，
`oldVersion^m, `newVersion^m も含んでいる。
【！ details 】
◎
Why aren’t the steps to fire a success event or fire an error event used?
◎
There is no transaction associated with the request, so those steps — which activate an associated transaction before dispatch and deactivate the transaction after dispatch — do not apply.
◎
Also, the success event here is a IDBVersionChangeEvent which includes the oldVersion and newVersion details.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %要請 を表現する，新たな `IDBOpenDBRequest$I ~obj
◎
Return a new IDBOpenDBRequest object for request.
</li>
</ol>
</div>

<div class="algo">
<p>
`databases()@m
~method手続きは：
◎
The databases() method steps are:
</p>
<ol>
	<li>
%生成元 ~LET コレに`関連な設定群~obj$の`生成元$enV
◎
Let environment be this's relevant settings object.
◎
Let origin be environment’s origin.
</li>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET `SecurityError$E 例外で`却下される~promise$
◎
If origin is an opaque origin, then return a promise rejected with a "SecurityError" DOMException.
</li>
	<li>
%p ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li>
<p>
この段は、
`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
%~db群 ~LET %生成元 に`専属する$`~db$たちからなる`集合$
⇒
~IF［
何らかの理由でこれを決定できない
］
⇒＃
適切な~error（例： `UnknownError$E 例外）で %p を`却下する$；
~RET
◎
Let databases be the set of databases in origin. If this cannot be determined for any reason, then reject p with an appropriate error (e.g. an "UnknownError" DOMException) and terminate these steps.
</li>
			<li>
%~db~list ~LET 新たな`~list$
◎
Let result be a new list.
</li>
			<li>
<p>
%~db群 を成す
~EACH( `~db$ %~db )
に対し：
◎
For each db of databases:
</p>
				<ol>
					<li>
%info ~LET 新たな `IDBDatabaseInfo$I 辞書
◎
Let info be a new IDBDatabaseInfo dictionary.
</li>
					<li>
%info[ "`name^m" ] ~SET %~db の`名前$db,
◎
Set info’s name dictionary member to db’s name.
</li>
					<li>
%info[ "`version^m" ] ~SET %~db の `~version$db
◎
Set info’s version dictionary member to db’s version.
</li>
					<li>
%~db~list に %info を`付加する$
◎
Append info to result.
</li>
				</ol>

<p class="trans-note">【
%~db群 の順序は定義されていないので、
結果の順序も定義されないことになる。
】</p>

			</li>
			<li>
%~db~list で %p を`解決する$
◎
Resolve p with result.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>

<p class="advisement">🚧
これは、
この版による新たな~methodである。
Chrome 71, Edge 79, Safari 14
から~supportされている。
🚧
◎
🚧 The databases() method is new in this edition. It is supported in Chrome 71, Edge 79, and Safari 14. 🚧
</p>
</div>

<div class="note domintro">
<dl>
	<dt>%result = `indexedDB$m . `cmp(key1, key2)$m</dt>
	<dd>
2 個の値を`~key$として比較した結果を，次で与える数として返す
⇒＃
%key1 と %key2 は`等しい$ならば 0,
%key1 は %key2 `より小さい$ならば −1,
%key1 は %key2 `より大きい$ならば 1
◎
Compares two values as keys. Returns -1 if key1 precedes key2, 1 if key2 precedes key1, and 0 if the keys are equal.
</dd>
	<dd>
%key1, %key2 のいずれかが`~key$として妥当でない場合、
`DataError$E が投出される。
◎
Throws a "DataError" DOMException if either input is not a valid key.
</dd>
</dl>
</div>

<div class="algo">
<p>
`cmp(first, second)@m
~method手続きは：
◎
The cmp(first, second) method steps are:
</p>
<ol>
	<li>
%a ~LET `Key$( %first ) ？
◎
Let a be the result of converting a value to a key with first. Rethrow any exceptions.
◎
If a is invalid, throw a "DataError" DOMException.
</li>
	<li>
%b ~LET `Key$( %second ) ？
◎
Let b be the result of converting a value to a key with second. Rethrow any exceptions.
◎
If b is invalid, throw a "DataError" DOMException.
</li>
	<li>
~RET `Compare$( %a, %b )
◎
Return the results of comparing two keys with a and b.
</li>
</ol>
</div>

		</section>
		<section id="database-interface">
<h3 title="The IDBDatabase interface">4.4. `IDBDatabase^I ~interface</h3>
【！ TODO Add example. Should examples be in a separate section?】

<p>
`IDBDatabase$I ~interfaceは、
`~db$への`接続$を表現する。
◎
The IDBDatabase interface represents a connection to a database.
</p>

<div class="p">
<p>
［
次の両条件を満たしている`接続$
］を表現する `IDBDatabase$I ~objは、
~garbage収集されないモノトスル：
</p>

<ul>
	<li>
`状態$Cn ~EQ `~open中$i
</li>
	<li>
［
`abort$et, `error$et, `versionchange$et
］いずれかの型の~event~listenerが登録されている
</li>
</ul>

<p>
`IDBDatabase$I ~objを~garbage収集するときは、
その前に，それが表現する`接続$を`~close$するモノトスル。
</p>

◎
An IDBDatabase object must not be garbage collected if its associated connection's close pending flag is false and it has one or more event listeners registers whose type is one of abort, error, or versionchange. If an IDBDatabase object is garbage collected, the associated connection must be closed.
</div>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBDatabase@I : `EventTarget$I {
  readonly attribute `DOMString$ `name$m;
  readonly attribute `unsigned long long$ `version$m;
  readonly attribute `DOMStringList$I `objectStoreNames$m;

  [`NewObject$] `IDBTransaction$I `transaction$m(
      (`DOMString$ or `sequence$&lt;`DOMString$&gt;) %storeNames,
      optional `IDBTransactionMode$I %mode = `readonly$l
      optional `IDBTransactionOptions$I %options = {}
  );
  `undefined$ `close$m();

  [`NewObject$] `IDBObjectStore$I `createObjectStore$m(
      `DOMString$ %name,
      optional `IDBObjectStoreParameters$I %options = {}
  );
  `undefined$ `deleteObjectStore$m(
      `DOMString$ %name
  );

  // <span class="comment" title="Event handlers">~event~handler：</span>
  attribute `EventHandler$I `onabort$m;
  attribute `EventHandler$I `onclose$m;
  attribute `EventHandler$I `onerror$m;
  attribute `EventHandler$I `onversionchange$m;
};


enum `IDBTransactionDurability@I { `default@l, `strict@l, `relaxed@l };

dictionary `IDBTransactionOptions@I {
  `IDBTransactionDurability$I `durability@mb = `default$l;
};

dictionary `IDBObjectStoreParameters@I {
  (`DOMString$ or `sequence$&lt;`DOMString$&gt;)? `keyPath@mb = null;
  `boolean$ `autoIncrement@mb = false;
};
</pre>

<!-- `IDBDatabase!I -->
<div class="note domintro">
<dl>
	<dt>%connection . `name$m</dt>
	<dd>
接続先~dbの`名前$dbを返す。
◎
Returns the name of the database.
</dd>

	<dt>%connection . `version$m</dt>
	<dd>
接続先~dbの`~version$dbを返す。
◎
Returns the version of the database.
</dd>
</dl>
</div>

<div class="algo">
<p>
`name@m
取得子~手続きは
⇒
~RET コレ↗の`名前$db
◎
The name getter steps are to return this's associated database's name.
</p>

<p class="note">注記：
この属性は、
`値を保持し続ける$。
◎
The name attribute returns this name even if this's close pending flag is true. In other words, the value of this attribute stays constant for the lifetime of the IDBDatabase instance.
</p>
</div>

<div class="algo">
<p>
`version@m
取得子~手続きは
⇒
~RET コレの`~version$Cn
◎
The version getter steps are to return this's version.
</p>

<p class="note">注記：
この属性は、
コレの`状態$Cn ~EQ `~open中$i の間は，コレ↗の`~version$dbと同じ値を返し、
それ以降も同じ`値を保持し続ける$。
【！ details 】
◎
Is this the same as the database's version?
◎
As long as the connection is open, this is the same as the connected database's version. But once the connection has closed, this attribute will not reflect changes made with a later upgrade transaction.
</p>
</div>

<div class="note domintro">
<dl>
	<dt>%connection . `objectStoreNames$m</dt>
	<dd>
接続先`~db$に`専属する$`保管庫$たちの`名前$Osからなる~listを返す。
◎
Returns a list of the names of object stores in the database.
</dd>

	<dt>%store = %connection . `createObjectStore(name [, options])$m</dt>
	<dd>
接続先`~db$に`専属する$, かつ，`名前$Os %name の, %options を伴う新たな`保管庫$を作成した上で、
それを`~access先$とする 新たな `IDBObjectStore$I を返す。
◎
Creates a new object store with the given name and options and returns a new IDBObjectStore.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E を投出する。
◎
Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>

	<dt>%connection . `deleteObjectStore(name)$m</dt>
	<dd>
接続先`~db$に`専属する$，`名前$Os %name の`保管庫$を削除する。
◎
Deletes the object store with the given name.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E を投出する。
◎
Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>
</dl>
</div>

<div class="algo">
<p>
`objectStoreNames@m
取得子~手続きは：
◎
The objectStoreNames getter steps are:
</p>
<ol>
	<li>
%名前~群 ~LET ［
コレの`保管庫~集合$Cnを成す すべての`保管庫$の`名前$Os
］からなる`~list$
◎
Let names be a list of the names of the object stores in this's object store set.
</li>
	<li>
~RET `~sort済み名前~listを作成する$( %名前~群 )
◎
Return the result (a DOMStringList) of creating a sorted name list with names.
</li>
</ol>

<p class="note">注記：
この属性は、［
コレの`状態$Cn ~EQ `~open中$i
］の間は，コレ↗に専属する`保管庫$たちの`名前$Osからなる~listと同じ値を返し、
それ以降も同じ`値を保持し続ける$。
◎
Is this the same as the database's object store names?
◎
As long as the connection is open, this is the same as the connected database's object store names. But once the connection has closed, this attribute will not reflect changes made with a later upgrade transaction.
</p>
</div>

<div class="algo">
<p>
`createObjectStore(name, options)@m
~method手続きは：
◎
The createObjectStore(name, options) method steps are:
</p>
<ol>
	<li>
%~tx ~LET コレ↗の`昇格~tx$db
◎
Let database be this's associated database.
◎
Let transaction be database’s upgrade transaction if it is not null,＼
</li>
	<li>
<p>
~IF［
%~tx ~EQ ε
］
⇒
~THROW `InvalidStateError$E
</p>

<p class="trans-note">【
%~tx がコレ↗に`専属しない$場合も例外を投出するべきでは？
】</p>

◎
or throw an "InvalidStateError" DOMException otherwise.
</li>
	<li>
~IF［
%~tx の`状態$tx ~NEQ `作動中$i
］
⇒
~THROW `TransactionInactiveError$E
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%keyPath ~LET %options[ "`keyPath$mb" ]
◎
Let keyPath be options’s keyPath member if it is not undefined or null, or null otherwise.
</li>
	<li>
~IF［
%keyPath ~NEQ ~NULL
］~AND［
%keyPath は`妥当な~key~path$でない
］
⇒
~THROW `SyntaxError$E
◎
If keyPath is not null and is not a valid key path, throw a "SyntaxError" DOMException.
</li>
	<li>
~IF［
コレの`保管庫~集合$Cn内に［
`名前$Os ~EQ %name
］なる`保管庫$がある
］
⇒
~THROW `ConstraintError$E
◎
If an object store named name already exists in database throw a "ConstraintError" DOMException.
</li>
	<li>
%自動生成か ~LET %options[ "`autoIncrement$mb" ]
◎
Let autoIncrement be options’s autoIncrement member.
</li>
	<li>
~IF［
%自動生成か ~EQ ~T
］
⇒
~IF［
%keyPath ~EQ 空な `DOMString$I 値である
］~OR［
%keyPath は `~SeqDS$ 型である
］
⇒
~THROW `InvalidAccessError$E
◎
If autoIncrement is true and keyPath is an empty string or any sequence (empty or otherwise), throw an "InvalidAccessError" DOMException.
</li>
	<li>
%保管庫 ~LET 次のようにされた，新たな`保管庫$
⇒＃
コレ↗に`専属する$,
`~record~list$Os ~SET 空~list,
`名前$Os ~SET %name,
`~key生成器$を［ %自動生成か ~EQ ~T ならば持つ ／ ~ELSE_ 持たない ］,
`~key~path$Os ~SET ［ %keyPath ~NEQ ~NULL ならば %keyPath ／ ~ELSE_ ε ］
◎
Let store be a new object store in database. Set the created object store's name to name. If autoIncrement is true, then the created object store uses a key generator. If keyPath is not null, set the created object store's key path to keyPath.
</li>
	<li>
コレの`保管庫~集合$Cnに %保管庫 を追加する
【この段は、この訳による補完】
</li>
	<li>
~RET 次のようにされた，新たな`保管庫~handle$ %H
⇒＃
%H↗ ~EQ %保管庫,
%H は %~tx に`専属する$
◎
Return a new object store handle associated with store and transaction.
</li>
</ol>

<p>
この~methodは、
新たな`保管庫$を作成した上で，それを`~access先$とする新たな`保管庫~handle$を返す。
この~methodを~callできるのは、
`昇格~txの中$からに限られることに注意。
◎
This method creates and returns a new object store with the given name in the connected database. Note that this method must only be called from within an upgrade transaction.
</p>

<p>
この~methodは，コレ上の `objectStoreNames$m 属性を同期的に改変する。
◎
This method synchronously modifies the objectStoreNames property on the IDBDatabase instance on which it was called.
</p>

<div class="p">
<p>
実装によっては、［
この~methodが何かを返して，~db内に`保管庫$を作成する演算を~queueした後
］に，問題になる可能性がある。
例えば、［
新たに作成された`保管庫$についての~metadataを，~dbに非同期に挿入する所
］，あるいは［
~quota事由から，利用者に許可を請う必要があり得る所
］で。
そうなり得る場合でも、
実装は：
</p>
<ul>
	<li>
`IDBObjectStore$I ~objを作成して返すモノトスル。
</li>
	<li>
<p>
加えて，`保管庫$の作成ngに失敗したときは、［
失敗の事由に適切な~error名†
］を入力に
`~txを中止-$する手続きを行って，
%~tx を`中止-$するモノトスル。
</p>

<p>†
例えば
~quota事由に因り`保管庫$の作成ngに失敗した場合は、
`QuotaExceededError$E を利用するモノトスル。
</p>
	</li>
</ul>

◎
In some implementations it is possible for the implementation to run into problems after queuing a task to create the object store after the createObjectStore() method has returned. For example in implementations where metadata about the newly created object store is inserted into the database asynchronously, or where the implementation might need to ask the user for permission for quota reasons. Such implementations must still create and return an IDBObjectStore object, and once the implementation determines that creating the object store has failed, it must abort the transaction using the steps to abort a transaction using the appropriate error. For example if creating the object store failed due to quota reasons, a "QuotaExceededError" DOMException must be used as error.
</div>
</div>

<div class="algo">
<p>
`deleteObjectStore(name)@m
~method手続きは：
◎
The deleteObjectStore(name) method steps are:
</p>
<ol>
	<li>
%~tx ~LET コレ↗の`昇格~tx$db
◎
Let database be this's associated database.
◎
Let transaction be database’s upgrade transaction if it is not null,＼
</li>
	<li>
<p>
~IF［
%~tx ~EQ ε
］
⇒
~THROW `InvalidStateError$E
</p>

<p class="trans-note">【
%~tx がコレ↗に`専属しない$場合も例外を投出するべきでは？
】</p>

◎
or throw an "InvalidStateError" DOMException otherwise.
</li>
	<li>
~IF［
%~tx の`状態$tx ~NEQ `作動中$i
］
⇒
~THROW `TransactionInactiveError$E
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%保管庫 ~LET コレの`保管庫~集合$Cn内の［
`名前$Os ~EQ %name
］なる`保管庫$
◎
Let store be the object store named name in database,＼
</li>
	<li>
~IF［
%保管庫 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
or throw a "NotFoundError" DOMException if none.
</li>
	<li>
コレの`保管庫~集合$Cnから %保管庫 を除去する
◎
Remove store from this's object store set.
</li>
	<li>
~IF［
%~tx に`専属する$, かつ
%保管庫 を`~access先$とする`保管庫~handle$ %H がある
］
⇒
%H の`索引~集合$OsHを空にする
◎
If there is an object store handle associated with store and transaction, remove all entries from its index set.
</li>
	<li>
コレ↗内の %保管庫 を（ %保管庫 に`専属する$`索引$たちも込みで）破壊する
◎
Destroy store.
</li>
</ol>

<p>
この~methodは、
この`接続$↗に専属している，名前 %name の`保管庫$を破壊する。
この~methodを~callできるのは、
`昇格~txの中$からに限られることに注意。
◎
This method destroys the object store with the given name in the connected database. Note that this method must only be called from within an upgrade transaction.
</p>

<p>
この~methodは，コレ上の `objectStoreNames$m 属性を同期的に改変する。
◎
This method synchronously modifies the objectStoreNames property on the IDBDatabase instance on which it was called.
</p>
</div>

<div class="note domintro">
<dl>
	<dt>%transaction = %connection . `transaction(scope [, mode [, options ] ])$m</dt>
	<dd>
%connection に`専属する$新たな`~tx$を返す
⇒＃
%scope が，その`視野$を与える（ 1 個の`名前$Os, または 1 個以上の`名前$Osからなる配列）。
%mode が，その`~mode$を与える（ `readonly$l ／ `readwrite$l ）。
%options の `durability$mb が，その`耐久能~hint$を与える（ `strict$l ／ `relaxed$l ／ `default$l ）。
◎
Returns a new transaction with the given scope (which can be a single object store name or an array of names), mode ("readonly" or "readwrite"), and additional options including durability ("default", "strict" or "relaxed").
</dd>
	<dd>
既定の %mode は `readonly$l であり、
既定の `durability$mb は `default$l である。
◎
The default mode is "readonly" and the default durability is "default".
</dd>

	<dt>%connection . `close$m()</dt>
	<dd>
%connection を~closeする
— ~closeし終えるのは、
%connection に`専属する$すべての`~tx$が，稼働し終えた時点になる。
◎
Closes the connection once all running transactions have finished.
</dd>
</dl>
</div>

<div class="algo">
<p>
`transaction(storeNames, mode, options)@m
~method手続きは：
◎
The transaction(storeNames, mode, options) method steps are:
</p>
<ol>
	<li>
~IF［
コレ↗の`昇格~tx$dbは`稼働して$いる
］
⇒
~THROW `InvalidStateError$E
◎
If a running upgrade transaction is associated with the connection, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`状態$Cn ~NEQ `~open中$i
］
⇒
~THROW `InvalidStateError$E
◎
If this's close pending flag is true, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%視野 ~LET %storeNames の型に応じて
⇒＃
`~SeqDS$ ならば，その中の一意な文字列からなる集合（集合なので，重複するものは一つにする）／
`DOMString$I ならば，その文字列のみからなる集合
◎
Let scope be the set of unique strings in storeNames if it is a sequence, or a set containing one string equal to storeNames otherwise.
</li>
	<li>
~IF［
%視野 内に，コレの`保管庫~集合$Cn内のどの`保管庫$の`名前$Osにも一致しないものがある
］
⇒
~THROW `NotFoundError$E
◎
If any string in scope is not the name of an object store in the connected database, throw a "NotFoundError" DOMException.
</li>
	<li>
~IF［
%視野 は 空である
］
⇒
~THROW `InvalidAccessError$E
◎
If scope is empty, throw an "InvalidAccessError" DOMException.
</li>
	<li>
~IF［
%mode ~NIN { `readonly$l, `readwrite$l }
］
⇒
~THROW `TypeError$jT
◎
If mode is not "readonly" or "readwrite", throw a TypeError.
</li>
	<li>
%~tx ~LET 新たに`作成-$された`~tx$
— その
⇒＃
`視野$ ~SET ［ コレの`保管庫~集合$Cn内の， %視野 により指示される`保管庫$たち ］からなる集合,
`~mode$ ~SET %mode,
`専属する$`接続$ ~SET コレ,
`耐久能~hint$ ~SET %options[ "`durability$mb" ]
◎
Let transaction be a newly created transaction with this connection, mode, options’ durability member, and the set of object stores named in scope.
</li>
	<li>
%~tx の`片付ける~event~loop$ ~SET 現在の`~event~loop$
◎
Set transaction’s cleanup event loop to the current event loop.
</li>
	<li>
~RET %~tx を表現する `IDBTransaction$I ~obj
◎
Return an IDBTransaction object representing transaction.
</li>
</ol>

<p class="advisement">🚧
`durability$m は、
この版による新たな~optionである。
Chrome 82, Edge 82
から~supportされている。
🚧
◎
🚧 The durability option is new in this edition. It is supported in Chrome 82 and Edge 82. 🚧
</p>

<p class="note">注記：
作成された~txは、
その`存続期間$の規則に従う。
◎
The created transaction will follow the lifetime rules.
</p>
</div>

<div class="algo">
<p>
`close()@m
~method手続きは
⇒
`~db接続を~closeする$( コレ )
◎
The close() method steps are:
• Run close a database connection with this connection.
</p>

<p class="note">注記：
未決な`~tx$すべてが完了するまでは、
`接続$は実際には`~close$されない。
`close()$m に対する後続の~callには、
効果はない。
◎
The connection will not actually close until all outstanding transactions have completed. Subsequent calls to close() will have no effect.
</p>
</div>

<p>
`onabort@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `abort$et である。
◎
The onabort attribute is an event handler IDL attribute whose event handler event type is abort.
</p>

<p>
`onclose@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `close$et である。
◎
The onclose attribute is an event handler IDL attribute whose event handler event type is close.
</p>

<p>
`onerror@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `error$et である。
◎
The onerror attribute is an event handler IDL attribute whose event handler event type is error.
</p>

<p>
`onversionchange@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `versionchange$et である。
◎
The onversionchange attribute is an event handler IDL attribute whose event handler event type is versionchange.
</p>


		</section>
		<section id="object-store-interface">
<h3 title="The IDBObjectStore interface">4.5. `IDBObjectStore^I ~interface</h3>

<p>
`IDBObjectStore$I ~interfaceは、
`保管庫~handle$を表現する。
◎
The IDBObjectStore interface represents an object store handle.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBObjectStore@I {
  attribute `DOMString$ `name$m;
  readonly attribute `any$ `keyPath$m;
  readonly attribute `DOMStringList$I `indexNames$m;
  [`SameObject$] readonly attribute `IDBTransaction$I `transaction$m;
  readonly attribute `boolean$ `autoIncrement$m;

  [`NewObject$] `IDBRequest$I `put$m(
      `any$ %value,
      optional `any$ %key
  );
  [`NewObject$] `IDBRequest$I `add$m(
      `any$ %value,
      optional `any$ %key
  );
  [`NewObject$] `IDBRequest$I `delete$m(
      `any$ %query
  );
  [`NewObject$] `IDBRequest$I `clear$m();
  [`NewObject$] `IDBRequest$I `get$m(
      `any$ %query
  );
  [`NewObject$] `IDBRequest$I `getKey$m(
      `any$ %query
  );
  [`NewObject$] `IDBRequest$I `getAll$m(
      optional `any$ %query,
      optional [`EnforceRange$] `unsigned long$ %count
  );
  [`NewObject$] `IDBRequest$I `getAllKeys$m(
      optional `any$ %query,
      optional [`EnforceRange$] `unsigned long$ %count
  );
  [`NewObject$] `IDBRequest$I `count$m(
      optional `any$ %query
  );

  [`NewObject$] `IDBRequest$I `openCursor$m(
      optional `any$ %query,
      optional `IDBCursorDirection$I %direction = "next"
  );
  [`NewObject$] `IDBRequest$I `openKeyCursor$m(
      optional `any$ %query,
      optional `IDBCursorDirection$I %direction = "next"
  );

  `IDBIndex$I `index$m(
      `DOMString$ %name
  );

  [`NewObject$] `IDBIndex$I `createIndex$m(
      `DOMString$ %name,
      (`DOMString$ or `sequence$&lt;`DOMString$&gt;) %keyPath,
      optional `IDBIndexParameters$I %options = {}
  );
  `undefined$ `deleteIndex$m(
      `DOMString$ %name
  );
};

dictionary `IDBIndexParameters@I {
  `boolean$ `unique@mb = false;
  `boolean$ `multiEntry@mb = false;
};
</pre>

<!-- `IDBObjectStore!I -->
<div class="note domintro">
<dl>
	<dt>%store . `name$m</dt>
	<dd>
%store↗ の`名前$Osを返す。
◎
Returns the name of the store.
</dd>

	<dt>%store . `name$m = %newName</dt>
	<dd>
%store↗ の`名前$Osを %newName に更新する。
◎
Updates the name of the store to newName.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E が投出される。
◎
Throws "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>

	<dt>%store . `keyPath$m</dt>
	<dd>
%store↗ の`~key~path$Os ~NEQ ε ならば それ ／
~ELSE_ ~NULL
を返す。
◎
Returns the key path of the store, or null if none.
</dd>

	<dt>%store . `indexNames$m</dt>
	<dd>
%store↗ に`専属する$`索引$たちの`名前$Ixからなる~listを返す。
◎
Returns a list of the names of indexes in the store.
</dd>

	<dt>%store . `transaction$m</dt>
	<dd>
%store が`専属する$`~tx$を返す。
◎
Returns the associated transaction.
</dd>

	<dt>%store . `autoIncrement$m</dt>
	<dd>
%store↗ が`~key生成器$を［
持つならば ~T ／
持たないならば ~F
］を返す。
◎
Returns true if the store has a key generator, and false otherwise.
</dd>
</dl>
</div>

<div class="algo">
<p>
`name@m
取得子~手続きは
⇒
~RET コレの`名前$OsH
◎
The name getter steps are to return this's name.
</p>

<p class="note">注記：
この属性は、
コレが`専属する$~txが`完遂-$するまでは，コレ↗の`名前$Osと同じ値を返し、
それ以降も同じ`値を保持し続ける$。
【！ details 】
◎
Is this the same as the object store's name?
◎
As long as the transaction has not finished, this is the same as the associated object store's name. But once the transaction has finished, this attribute will not reflect changes made with a later upgrade transaction.
</p>
</div>

<div class="algo">
<p>
`name$m 設定子~手続きは：
◎
The name setter steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `versionchange^l ) ？
◎
Let name be the given value.
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
変則＊
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction is not an upgrade transaction, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%name ~LET `所与の値$
◎
↑</li>
	<li>
~IF［
コレの`名前$OsH ~EQ %name
］
⇒
~RET
◎
If store’s name is equal to name, terminate these steps.
</li>
	<li>
~IF［
コレが`専属する$`接続$の`保管庫~集合$Cnに［
`名前$Os ~EQ %name
］なる`保管庫$がある
］
⇒
~THROW `ConstraintError$E
◎
If an object store named name already exists in store’s database, throw a "ConstraintError" DOMException.
</li>
	<li>
コレ↗の`名前$Os ~SET %name
◎
Set store’s name to name.
</li>
	<li>
コレの`名前$OsH ~SET %name
◎
Set this's name to name.
</li>
</ol>
</div>

<div class="algo">
<p>
`keyPath@m
取得子~手続きは
⇒
~RET コレ↗の`~key~path$Os %P に応じて，［
%P ~EQ ε ならば ~NULL ／
~ELSE_ %P を `WEBIDL$r に従って，次の型として変換した結果
］
⇒＃
%P は文字列であるならば `DOMString$I ／
%P は文字列の~listであるならば `~SeqDS$
◎
The keyPath getter steps are to return this's object store's key path, or null if none. The key path is converted as a DOMString (if a string) or a sequence&lt;DOMString&gt; (if a list of strings), per [WEBIDL].
</p>

<p>
【この属性は、`値を保持し続ける$。】
</p>

<p class="note">注記：
返される値は、
コレの作成-時に利用した~instanceと同じではない。
しかしながら，この属性が~obj（特定的には `Array$jT ）を返す場合、
毎回~同じ~instanceを返す。
返された~objの~prop値を変更しても，コレに効果を及ぼすことはない。
◎
The returned value is not the same instance that was used when the object store was created. However, if this attribute returns an object (specifically an Array), it returns the same object instance every time it is inspected. Changing the properties of the object has no effect on the object store.
</p>
</div>

<div class="algo">
<p>
`indexNames@m
取得子~手続きは：
◎
The indexNames getter steps are:
</p>
<ol>
	<li>
%名前~群 ~LET ［
コレの`索引~集合$OsHを成す すべての`索引$の`名前$Ix
］からなる`~list$
◎
Let names be a list of the names of the indexes in this's index set.
</li>
	<li>
~RET `~sort済み名前~listを作成する$( %名前~群 )
◎
Return the result (a DOMStringList) of creating a sorted name list with names.
</li>
</ol>

<p class="note">注記：
この属性は、
コレが`専属する$~txが`完遂-$するまでは，コレ↗に専属する`索引$たちの名前からなる~listと同じ値を返し、
それ以降も同じ`値を保持し続ける$。
【！ deitails 】
◎
Is this the same as object store's list of index names?
◎
As long as the transaction has not finished, this is the same as the associated object store's list of index names. But once the transaction has finished, this attribute will not reflect changes made with a later upgrade transaction.
</p>
</div>

<div class="algo">
<p>
`transaction@m
取得子~手続きは
⇒
~RET コレが`専属する$~tx
◎
The transaction getter steps are to return this's transaction.
</div>

<div class="algo">
<p>
`autoIncrement@m
取得子~手続きは
⇒
~RET ［
コレ↗の`~key生成器$ ~EQ ε ならば ~F ／
~ELSE_ ~T
］
◎
The autoIncrement getter steps are to return true if this's object store has a key generator, and false otherwise.
</p>

<p>
【この属性は、`値を保持し続ける$。】
</p>
</div>


<div class="note domintro">
<p>
以下に挙げる~methodは、［
`~readonly~tx$の中で~callされた場合は `ReadOnlyError$E ／
`~tx$が `作動中$i でないときに~callされた場合は `TransactionInactiveError$E
］を投出する。
◎
The following methods throw a "ReadOnlyError" DOMException if called within a read-only transaction, and a "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl>
	<dt>%request = %store . `put(value [, key])$m</dt>
	<dt>%request = %store . `add(value [, key])$m</dt>
	<dd>
%store↗ 内に新たな`~record$ { %key : %value } を追加する／更新するよう要請する。
◎
Adds or updates a record in store with the given value and key.
</dd>
	<dd>
%store↗ の`~key~path$Os ~NEQ ε の場合、
%key は省略する必要がある
— さもなければ `DataError$E が投出される。
【この場合の~keyは， %value から`~key~path$Osを用いて抽出される】
◎
If the store uses in-line keys and key is specified a "DataError" DOMException will be thrown.
</dd>
	<dd>
<p>
%store↗ 内に`~key$ %key を持つ`~record$がすでに存在する場合：
</p>
		<ul>
			<li>
`put()$m に対しては、
新たな~recordで置換されることになる
（すなわち，~recordの値が更新される）。
</li>
			<li>
`add()$m に対しては、
要請は失敗し，
%request の 【！ ＊ 】`IDBRequest.error$m は `ConstraintError$E 例外に設定されることになる。
</li>
		</ul>
◎
If put() is used, any existing record with the key will be replaced. If add() is used, and if a record with the key already exists the request will fail, with request’s error set to a "ConstraintError" DOMException.
</dd>
	<dd>
成功した場合の %request の `result$m は、
追加した（置換した）`~record$の`~key$になる。
◎
If successful, request’s result will be the record's key.
</dd>

	<dt>%request = %store . `delete(query)$m</dt>
	<dd>
%store↗ の`~record~list$Osから［
%query が`表現する~key範囲$に入る~recordたち
］を削除するよう要請する。
◎
Deletes records in store with the given key or in the given key range in query.
</dd>
	<dd>
成功した場合の %request の `result$m は、
`undefined^jv になる。
◎
If successful, request’s result will be undefined.
</dd>

	<dt>%request = %store . `clear$m()</dt>
	<dd>
%store↗ の`~record~list$Osを空にするよう要請する。
◎
Deletes all records in store.
</dd>
	<dd>
成功した場合の %request の `result$m は、
`undefined^jv になる。
◎
If successful, request’s result will be undefined.
</dd>
</dl>
</div>

<div class="algo">
`put(value, key)@m
~method手続きは
⇒
`addするかputする$( コレ, %value, %key, ε )
◎
The put(value, key) method steps are to return the result of running add or put with this, value, key and the no-overwrite flag false.
</div>

<div class="algo">
`add(value, key)@m
~method手続きは
⇒
`addするかputする$( コレ, %value, %key, `上書不可^i )
◎
The add(value, key) method steps are to return the result of running add or put with this, value, key and the no-overwrite flag true.
</div>

<div class="algo">
<p>
`addするかputする@
ときは、
所与の
( %~handle, %value, %key, %上書不可か )
に対し，次を走らす：
◎
To add or put with handle, value, key, and no-overwrite flag, run these steps:
</p>
<ol>
	<li>
`状態を検査する$( %~handle, `readwrite^l ) ？
◎
Let transaction be handle’s transaction.
◎
Let store be handle’s object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
</li>
	<li>
%keyPath ~LET %~handle の`~key~path$Os
◎
↓</li>
	<li>
%生成器 ~LET %~handle の`~key生成器$
◎
↓</li>
	<li>
~IF［
%keyPath ~NEQ ε
］~AND［
%key ~NEQ ε
］
⇒
~THROW `DataError$E
◎
If store uses in-line keys and key was given, throw a "DataError" DOMException.
</li>
	<li>
~IF［
%keyPath ~EQ ε
］~AND［
%key ~EQ ε
］~AND［
%生成器 ~EQ ε
］
⇒
~THROW `DataError$E
◎
If store uses out-of-line keys and has no key generator and key was not given, throw a "DataError" DOMException.
</li>
	<li>
~IF［
%key ~NEQ ε
］
⇒
%key ~LET `Key$( %key ) ？
◎
If key was given, then:
• Let r be the result of converting a value to a key with key. Rethrow any exceptions.
• If r is invalid, throw a "DataError" DOMException.
• Let key be r.
</li>
	<li>
%clone ~LET `~txの間に値を~cloneする$( %value, %~handle が`専属する$`~tx$ ) ？
◎
Let targetRealm be a user-agent defined Realm.
◎
Let clone be a clone of value in targetRealm during transaction. Rethrow any exceptions.
◎
Why create a copy of the value?
◎
The value is serialized when stored. Treating it as a copy here allows other algorithms in this specification to treat it as an ECMAScript value, but implementations can optimize this if the difference in behavior is not observable.
</li>
	<li>
<p>
~IF［
%keyPath ~NEQ ε
］：
</p>
		<ol>
			<li>
%抽出d~key ~LET `Extract$( %clone, %keyPath, %生成器 ) ？
</li>
			<li>
~IF［
%抽出d~key ~NEQ ε
］
⇒
%key ~SET %抽出d~key
</li>
			<li>
~ELIF［
`~keyを値の中へ注入できるか検査する$( %clone, %keyPath ) の結果 ~EQ ~F
］
⇒
~THROW `DataError$E
</li>
		</ol>
◎
If store uses in-line keys, then:
• Let kpk be the result of extracting a key from a value using a key path with clone and store’s key path. Rethrow any exceptions.
• If kpk is invalid, throw a "DataError" DOMException.
• If kpk is not failure, let key be kpk.
• Otherwise (kpk is failure):
•• If store does not have a key generator, throw a "DataError" DOMException.
•• Otherwise, if check that a key could be injected into a value with clone and store’s key path return false, throw a "DataError" DOMException.
</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( %~handle )
⇒
`保管庫に~recordを格納する$( %~handle↗, %clone, %key, %上書不可か )
◎
Let operation be an algorithm to run store a record into an object store with store, clone, key, and no-overwrite flag.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with handle and operation.
</li>
</ol>
</div>

<div class="algo">
<p>
`delete(query)@m
~method手続きは：
◎
The delete(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `readwrite^l ) ？
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query, `~NULL不可^i ) ？
◎
Let range be the result of converting a value to a key range with query and true. Rethrow any exceptions.
</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`保管庫から~recordを削除する$( コレ↗, %範囲 )
◎
Let operation be an algorithm to run delete records from an object store with store and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
削除する`~record$たちの~keyを識別する［
`~key$／`~key範囲$
］をとり得る。
◎
The query parameter can be a key or key range (an IDBKeyRange) identifying the records keys to be deleted.
</p>

<p class="note">注記：
他の~methodと違って、
この~methodの %query 引数は，
<strong>省略可能でなく, また~NULL 値も許容されない</strong>
（すなわち，`全範囲$は指定できない）。
これは、
小さな~bugにより，保管庫の中を全~clearする~riskを抑制するためである。
◎
Unlike other methods which take keys or key ranges, this method does not allow null to be given as key. This is to reduce the risk that a small bug would clear a whole object store.
</p>
</div>

<div class="algo">
<p>
`clear()@m
~method手続きは：
◎
The clear() method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `readwrite^l ) ？
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`保管庫を~clearする$( コレ↗ )
◎
Let operation be an algorithm to run clear an object store with store.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>
</div>

<div class="note domintro">
<p>
以下に挙げる~methodは、
`~tx$が `作動中$i でないときに~callされた場合は
`TransactionInactiveError$E を投出する。
◎
The following methods throw a "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl>
	<dt>%request = %store . `get(query)$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$に入る~recordたち
］のうち，最初の~recordの`値$を検索取得するよう要請する。
◎
Retrieves the value of the first record matching the given key or key range in query.
</dd>
	<dd>
成功した場合の %request の `result$m は、
該当する~recordが［
在るならば その`値$／
無いならば `undefined^jv
］になる。
◎
If successful, request’s result will be the value, or undefined if there was no matching record.
</dd>

	<dt>%request = %store . `getKey(query)$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$に入る~recordたち
］のうち，最初の~recordの`~key$を検索取得するよう要請する。
◎
Retrieves the key of the first record matching the given key or key range in query.
</dd>
	<dd>
成功した場合の %request の `result$m は、
該当する~recordが［
在るならば その`~key$／
無いならば `undefined^jv
］になる。
◎
If successful, request’s result will be the key, or undefined if there was no matching record.
</dd>

	<dt>%request = %store . `getAll(query [, count])$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$に入る~recordたち
］のうち，最初から %count 個までの~recordの`値$たちを検索取得するよう要請する。
◎
Retrieves the values of the records matching the given key or key range in query (up to count if given).
</dd>
	<dd>
成功した場合の %request の `result$m は、
一連の`値$からなる `Array$jT になる。
◎
If successful, request’s result will be an Array of the values.
</dd>

	<dt>%request = %store . `getAllKeys(query [, count])$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$に入る~recordたち
］のうち，最初から %count 個までの~recordの`~key$たちを検索取得するよう要請する。
◎
Retrieves the keys of records matching the given key or key range in query (up to count if given).
</dd>
	<dd>
成功した場合の %request の `result$m は、
一連の`~key$からなる `Array$jT になる。
◎
If successful, request’s result will be an Array of the keys.
</dd>

	<dt>%request = %store . `count(query)$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$に入る~recordたち
］の総数を得るよう要請する。
◎
Retrieves the number of records matching the given key or key range in query.
</dd>
	<dd>
成功した場合の %request の `result$m は、
得られた総数になる。
◎
If successful, request’s result will be the count.
</dd>
</dl>
</div>

<div class="algo">
<p>
`get(query)@m
~method手続きは：
◎
The get(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
<p>
%範囲 ~LET `Range$( %query, `~NULL不可^i ) ？
◎
Let range be the result of converting a value to a key range with query and true. Rethrow any exceptions.
</li>
	<li>
%取得演算 ~LET 所与の %~record から次を取得する演算
⇒
~NOABRUPT `StructuredDeserialize$jA( %~record の`値$, `現在の~Realm$ )
◎
↓</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`範囲に入る最初の~entryを検索取得する$( コレ↗, %範囲, %取得演算 )
◎
Let operation be an algorithm to run retrieve a value from an object store with the current Realm, store, and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
検索取得する`~record$を識別する［
`~key$／`~key範囲$
］をとり得る。
範囲が指定された場合、
~methodは，その範囲に入る最初の既存の値を検索取得する。
◎
The query parameter can be a key or key range (an IDBKeyRange) identifying the record to be retrieved. If a range is specified, the method retrieves the first existing value in that range.
</p>

<p class="note">注記：
この~methodによる要請の`結果$は、
所与の~keyを伴う~recordが存在しない場合も,
`値$が `undefined^jv の~recordが存在する場合も，
`undefined^jv 値になる。
両者を区別する必要があるときは、
同じ~keyで `openCursor()$m を利用できる
— その`結果$は、
~recordが存在しなければ ~NULL になる一方で，存在するときは［
`値$Cs ~SET `undefined^jv†
］にされた`~cursor$になる。
【† この訳では、内部処理~modelにおいては，値 ε により，そのような~recordが存在する場合とを区別している。】
◎
This method produces the same result if a record with the given key doesn’t exist as when a record exists, but has undefined as value. If you need to tell the two situations apart, you can use openCursor() with the same key. This will return a cursor with undefined as value if a record exists, or no cursor if no such record exists.
</p>
</div>

<div class="algo">
<p>
`getKey(query)@m
~method手続きは：
◎
The getKey(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query, `~NULL不可^i ) ？
◎
Let range be the result of converting a value to a key range with query and true. Rethrow any exceptions.
</li>
	<li>
%取得演算 ~LET 所与の %~record から次を取得する演算
⇒
`~keyを値に変換する$( %~record の`~key$ )
◎
↓</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`範囲に入る最初の~entryを検索取得する$( コレ↗, %範囲, %取得演算 )
◎
Let operation be an algorithm to run retrieve a key from an object store with store and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
検索取得する`~record$の~keyを識別する［
`~key$／`~key範囲$
］をとり得る。
範囲が指定された場合、
~methodは，その範囲に入る最初の既存の~keyを検索取得する。
◎
The query parameter can be a key or key range (an IDBKeyRange) identifying the record key to be retrieved. If a range is specified, the method retrieves the first existing key in that range.
</p>
</div>

<div class="algo">
<p>
`getAll(query, count)@m
~method手続きは：
◎
The getAll(query, count) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
<p>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
%取得演算 ~LET 所与の %~record から次を取得する演算
⇒
~NOABRUPT `StructuredDeserialize$jA( %~record の`値$, `現在の~Realm$ )
◎
↓</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`範囲に入る~entryたちを検索取得する$( コレ↗, %範囲, %count, %取得演算 )
◎
Let operation be an algorithm to run retrieve multiple values from an object store with the current Realm, store, range, and count if given.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
検索取得する`~record$たちを識別する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
%count が指定されていて，範囲に入る~record数がそれを超える場合，最初から %count 個までが検索取得される。
◎
The query parameter can be a key or key range (an IDBKeyRange) identifying the records to be retrieved. If null or not given, an unbounded key range is used. If count is specified and there are more than count records in range, only the first count will be retrieved.
</p>
</div>

<div class="algo">
<p>
`getAllKeys(query, count)@m
~method手続きは：
◎
The getAllKeys(query, count) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
<p>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
%取得演算 ~LET 所与の %~record から次を取得する演算
⇒
`~keyを値に変換する$( %~record の`~key$ )
◎
↓</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`範囲に入る~entryたちを検索取得する$( コレ↗, %範囲, %count, %取得演算 )
◎
Let operation be an algorithm to run retrieve multiple keys from an object store with store, range, and count if given.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
検索取得する`~record$たちの~keyを識別する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
%count が指定されていて，範囲に入る~key数がそれを超える場合，最初から %count 個までが検索取得される。
◎
The query parameter can be a key or key range (an IDBKeyRange) identifying the records keys to be retrieved. If null or not given, an unbounded key range is used. If count is specified and there are more than count keys in range, only the first count will be retrieved.
</p>
</div>

<div class="algo">
<p>
`count(query)@m
~method手続きは：
◎
The count(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`範囲に入る~recordを数える$( コレ↗, %範囲 )
◎
Let operation be an algorithm to run count the records in a range with store and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
検索取得する`~record$たちの~keyを識別する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter can be a key or key range (an IDBKeyRange) identifying the records keys to be counted. If null or not given, an unbounded key range is used.
</p>
</div>

<div class="note domintro">
<p>
以下に挙げる~methodは、
`~tx$が `作動中$i でないときに~callされた場合は
`TransactionInactiveError$E を投出する。
◎
The following methods throw a "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl>
	<dt>%request = %store . `openCursor([query [, direction = "next"]])$m</dt>
	<dd>
［
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$（ %query が~NULL ならば`全範囲$）に入る~recordたち
］を，`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
◎
Opens a cursor over the records matching query, ordered by direction. If query is null, all records in store are matched.
</dd>
	<dd>
成功した場合の %request の `result$m は、
範囲に入る~recordが［
在るならば 反復-順で最初の~recordを指している `IDBCursorWithValue$I ／
無いならば ~NULL
］になる。
◎
If successful, request’s result will be an IDBCursorWithValue pointing at the first matching record, or null if there were no matching records.
</dd>

	<dt>%request = %store . `openKeyCursor([query [, direction = "next"]])$m</dt>
	<dd>
［
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$（ %query が~NULL ならば`全範囲$）に入る~recordたち
］を，`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
作成される`~cursor$の`~keyのみか$Csは ~T に設定される
（~cursorは、
~recordの~keyのみを取得する）。
◎
Opens a cursor with key only flag set to true over the records matching query, ordered by direction. If query is null, all records in store are matched.
</dd>
	<dd>
成功した場合の %request の `result$m は、
範囲に入る~recordが［
在るならば 反復-順で最初の~recordを指している `IDBCursor$I ／
無いならば ~NULL
］になる。
◎
If successful, request’s result will be an IDBCursor pointing at the first matching record, or null if there were no matching records.
</dd>
</dl>
</div>

<div class="algo">
<p>
`openCursor(query, direction)@m
~method手続きは：
◎
The openCursor(query, direction) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
%要請 ~LET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`~cursorを作成する$( コレ, `現在の~Realm$, %direction, %範囲 )
◎
Let cursor be a new cursor with its transaction set to transaction, undefined position, direction set to direction, got value flag set to false, undefined key and value, source set to store, range set to range, and key only flag set to false.
◎
Let operation be an algorithm to run iterate a cursor with the current Realm cursor.
◎
Let request be the result of running asynchronously execute a request with this and operation.
</li>
	<li>
コレの`要請$Cs ~SET %要請
◎
Set cursor’s request to request.
</li>
	<li>
~RET %要請
◎
Return request.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
`~cursor$の`範囲$Csとして利用する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter can be a key or key range (an IDBKeyRange) to use as the cursor's range. If null or not given, an unbounded key range is used.
</p>
</div>

<div class="algo">
<p>
`openKeyCursor(query, direction)@m
~method手続きは：
◎
The openKeyCursor(query, direction) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
%要請 ~LET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`~cursorを作成する$( コレ, `現在の~Realm$, %direction, %範囲, `~keyのみ^i )
◎
Let cursor be a new cursor with its transaction set to transaction, undefined position, direction set to direction, got value flag set to false, undefined key and value, source set to store, range set to range, and key only flag set to true.
◎
Let operation be an algorithm to run iterate a cursor with the current Realm and cursor.
◎
Let request be the result of running asynchronously execute a request with this and operation.
</li>
	<li>
コレの`要請$Cs ~SET %要請
◎
Set cursor’s request to request.
</li>
	<li>
~RET %要請
◎
Return request.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
`~cursor$の`範囲$Csとして利用する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter can be a key or key range (an IDBKeyRange) to use as the cursor's range. If null or not given, an unbounded key range is used.
</p>
</div>

<div class="note domintro">
<dl>
	<dt>%index = %store . `index(name)$m</dt>
	<dd>
［
%store↗ に`専属する$，`名前$Ix %name の`索引$
］を`~access先$とする，`索引~handle$（ `IDBIndex$I ）を返す。
◎
Returns an IDBIndex for the index named name in store.
</dd>

	<dt>%index = %store . `createIndex(name, keyPath [, options])$m</dt>
	<dd>
%store↗ に`専属する$新たな`索引$を，所与の［
%name, %keyPath, %options
］を伴うように作成した上で、
それを`~access先$とする新たな `IDBIndex$I を返す。
［
%keyPath, %options
］が %store 内にすでにある~dataから
<a href="#_populating-an-index">索引を拡充-</a>
できない拘束を定義する場合、
当の`昇格~tx$は `ConstraintError$E で`中止-$されることになる。
◎
Creates a new index in store with the given name, keyPath and options and returns a new IDBIndex. If the keyPath and options define constraints that cannot be satisfied with the data already in store the upgrade transaction will abort with a "ConstraintError" DOMException.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E が投出される。
◎
Throws an "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>

	<dt>%store . `deleteIndex(name)$m</dt>
	<dd>
%store↗ に`専属する$，`名前$Ix %name の`索引$を削除する。
◎
Deletes the index in store with the given name.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E が投出される。
◎
Throws an "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>
</dl>
</div>

<div class="algo">
<p>
`createIndex(name, keyPath, options)@m
~method手続きは：
◎
The createIndex(name, keyPath, options) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `versionchange^l ) ？
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If transaction is not an upgrade transaction, throw an "InvalidStateError" DOMException.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
~IF［
コレの`索引~集合$OsHに［
`名前$Ix ~EQ %name
］なる`索引$がある
］
⇒
~THROW `ConstraintError$E
◎
If an index named name already exists in store, throw a "ConstraintError" DOMException.
</li>
	<li>
~IF［
%keyPath は`妥当な~key~path$でない
］
⇒
~THROW `SyntaxError$E
◎
If keyPath is not a valid key path, throw a "SyntaxError" DOMException.
</li>
	<li>
%一意か ~LET %options[ "`unique$mb" ]
◎
Let unique be options’s unique member.
</li>
	<li>
%複-~entryか ~LET %options[ "`multiEntry$mb" ]
◎
Let multiEntry be options’s multiEntry member.
</li>
	<li>
~IF［
%keyPath は`~SeqDS$ 型である
］~AND［
%複-~entryか ~EQ ~T
］
⇒
~THROW `InvalidAccessError$E
◎
If keyPath is a sequence and multiEntry is true, throw an "InvalidAccessError" DOMException.
</li>
	<li>
%索引 ~LET 新たな`索引$†
— その
⇒＃
コレ↗に`専属する$,
`名前$Ix ~SET %name,
`~key~path$Ix ~SET %keyPath,
`一意か$Ix ~SET %一意か,
`複-~entryか$Ix ~SET %複-~entryか
◎
Let index be a new index in store. Set index’s name to name, key path to keyPath, unique flag to unique, and multiEntry flag to multiEntry.
</li>
	<li>
%索引 をコレの`索引~集合$OsHに追加する
◎
Add index to this's index set.
</li>
	<li>
~RET 次のようにされた，新たな`索引~handle$ %H
⇒＃
%H↗ ~EQ %索引,
%H はコレに`専属する$,
`名前$IxH ~SET %name
◎
Return a new index handle associated with index and this.
</li>
</ol>

<p class="trans-note">【†
索引の`~record~list$Ixは、
自動的にコレの`~record~list$Osにより拡充されることになる。
】</p>

<p>
この~methodは、
コレに`専属する$, 名前 %name の新たな`索引$を作成した上で、
それを`~access先$とする 新たな`索引~handle$を返す。
この~methodを~callできるのは、
`昇格~txの中$からに限られることに注意。
◎
This method creates and returns a new index with the given name in the object store. Note that this method must only be called from within an upgrade transaction.
</p>

<p>
作成するよう要請された索引は、［
自身が`専属する$`保管庫$に許容される~data
］についての拘束を伴うこともある
— 索引の［
`一意か$Ix ~EQ ~T
］により，索引の`~key~path$Ixが指す部位の値（`参照先~record$の値）の一意性が要求されるなど。
その保管庫が，この拘束に違反する~dataをすでに包含している場合でも、
実装は，［
この~methodにて例外を投出したり，それが返すものに影響させる
］ことなく， `IDBIndex^I ~objを作成して返すモノトスル。
代わりに実装は、［
この~methodの~callに利用された，`昇格~tx$
］を中止する`~taskを~queueする$モノトスル。
◎
The index that is requested to be created can contain constraints on the data allowed in the index’s referenced object store, such as requiring uniqueness of the values referenced by the index’s key path. If the referenced object store already contains data which violates these constraints, this must not cause the implementation of createIndex() to throw an exception or affect what it returns. The implementation must still create and return an IDBIndex object, and the implementation must queue a task to abort the upgrade transaction which was used for the createIndex() call.
</p>

<p>
この~methodは、
コレ上の `indexNames$m ~propを同期的に改変する。
この~methodは `IDBRequest$I ~objを返さないが、
索引の作成~自体は，`昇格~tx$の中の非同期的な要請として，処理される。
◎
This method synchronously modifies the indexNames property on the IDBObjectStore instance on which it was called. Although this method does not return an IDBRequest object, the index creation itself is processed as an asynchronous request within the upgrade transaction.
</p>

<p>
実装によっては、
この~methodが`索引~handle$（ `IDBIndex^I ~obj）を返した後，`索引$を非同期に作成するときに，問題になる可能性がある。
例えば、［
新たに作成された索引の~metadataを~dbに挿入する~taskを~queueする所
］，あるいは［
~quota事由から，利用者に許可を請う必要があり得る所
］で。
そのような場合でも，実装は：
◎
In some implementations it is possible for the implementation to asynchronously run into problems creating the index after the createIndex method has returned. For example in implementations where metadata about the newly created index is queued up to be inserted into the database asynchronously, or where the implementation might need to ask the user for permission for quota reasons. Such implementations＼
</p>
		<ul>
			<li>
`索引~handle$を作成して返すモノトスル。
◎
must still create and return an IDBIndex object,＼
</li>
			<li>
<p>
加えて，`索引$の作成ngに失敗したときは、
次を走らすモノトスル
⇒
`~txを中止する$( コレ, 失敗の事由に適切な~error名† )
◎
and once the implementation determines that creating the index has failed, it must run the steps to abort a transaction using an appropriate error.＼
</p>

<p>†
例えば、［
~quota事由に因り`索引$の作成ngに失敗した場合は `QuotaExceededError$E ／
［
`一意か$Ix ~EQ ~T
］の拘束に因り索引を作成できない場合は `ConstraintError$E
］を利用するモノトスル。
◎
For example if creating the index failed due to quota reasons, a "QuotaExceededError" DOMException must be used as error and if the index can’t be created due to unique flag constraints, a "ConstraintError" DOMException must be used as error.
</p>
			</li>
		</ul>

<aside class="example" id="example-async-index-creation">
<p>
索引の非同期的な作成は、
次の例のように観測できる：
◎
The asynchronous creation of indexes is observable in the following example:
</p>

<pre class="lang-js">
const %request1 = objectStore.put({name: `betty^l}, `1^lt);
const %request2 = objectStore.put({name: `betty^l}, `2^lt);
const %index = objectStore.createIndex(`by_name^l, `name^l, {unique: true});
</pre>

<p>
`createIndex()^m が~callされた時点では，いずれの`要請$もまだ実行されていない。
2 番目の要請が実行されるとき，同じ `name^js ~propを`値$に持つ`~record$が重複して作成される。
索引の作成は非同期的な`要請$と見なされ、
索引の［
`一意か$Ix ~EQ ~T
］による拘束は， 2 番目の`要請$を失敗させないので。
代わりに，`~tx$は、
索引の作成-時に，拘束を満たせないため`中止-$されることになる。
◎
At the point where createIndex() called, neither of the requests have executed. When the second request executes, a duplicate name is created. Since the index creation is considered an asynchronous request, the index’s uniqueness constraint does not cause the second request to fail. Instead, the transaction will be aborted when the index is created and the constraint fails.
</p>
</aside>
</div>

<div class="algo">
<p>
`index(name)@m
~method手続きは：
◎
The index(name) method steps are:
</p>
<ol>
	<li>
~IF［
コレ↗は削除されている
］
⇒
~THROW `InvalidStateError$E
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF
コレが`専属する$`~tx$の`状態$tx ~EQ `完遂d$i
⇒
~THROW `InvalidStateError$E
◎
If transaction’s state is finished, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%索引 ~LET コレの`索引~集合$OsH 内の`索引$のうち，次を満たすもの
⇒
`名前$Ix ~EQ %name
◎
Let index be the index named name in this's index set if one exists,＼
</li>
	<li>
~IF［
%索引 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
or throw a "NotFoundError" DOMException otherwise.
</li>
	<li>
~RET 次を満たすような`索引~handle$ %H
⇒＃
%H↗ ~EQ %索引,
%H はコレに`専属する$,
`一意性$の要件を満たす
（`可換性$の要件は、
`索引~集合$OsHの構成から自動的に満たされる）
◎
Return an index handle associated with index and this.
</li>
</ol>

<p class="note">注記：
`一意性$の要件から，返される~instanceは一意に定まる
【~instanceがその前のどの時点で作成されるかは，実装の詳細~になる】
。
よって、
`昇格~tx$の間を除き、
同じ `IDBObjectStore$I ~instance上で，同じ %name をこの~methodに渡して返される `IDBIndex$I ~instanceは、
常に同じになる。
◎
Each call to this method on the same IDBObjectStore instance with the same name returns the same IDBIndex instance.
</p>

<p class="note">注記：
%H はコレに`専属する$ので、
他の `IDBObjectStore$I ~instanceに対し同じ %name で この~methodを呼出しても， %H と異なる `IDBIndex$I ~instanceが返される。
◎
The returned IDBIndex instance is specific to this IDBObjectStore instance. If this method is called on a different IDBObjectStore instance with the same name, a different IDBIndex instance is returned.
</p>
</div>

<div class="algo">
<p>
`deleteIndex(name)@m
~method手続きは：
◎
The deleteIndex(name) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `versionchange^l ) ？
◎
Let transaction be this's transaction.
◎
Let store be this's object store.
◎
If transaction is not an upgrade transaction, throw an "InvalidStateError" DOMException.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%索引 ~LET コレ↗に`専属する$`索引$のうち，次を満たすもの
⇒
`名前$Ix ~EQ %name
◎
Let index be the index named name in store if one exists,＼
</li>
	<li>
~IF［
%索引 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
or throw a "NotFoundError" DOMException otherwise.
</li>
	<li>
コレの`索引~集合$OsHから %索引 を除去する
◎
Remove index from this's index set.
</li>
	<li>
%索引 を破壊する
◎
Destroy index.
</li>
</ol>

<p>
この~methodは、
コレ↗に専属する，名前 %name の`索引$を破壊する。
この~methodを~callできるのは、
`昇格~txの中$からに限られることに注意。
◎
This method destroys the index with the given name in the object store. Note that this method must only be called from within an upgrade transaction.
</p>

<p>
この~methodは、
コレ上の
`indexNames$m
属性を同期的に改変する。
この~methodは `IDBRequest$I ~objを返さないが、
索引の破壊~自体は，`昇格~tx$の中で非同期的な要請として処理される。
◎
This method synchronously modifies the indexNames property on the IDBObjectStore instance on which it was called. Although this method does not return an IDBRequest object, the index destruction itself is processed as an asynchronous request within the upgrade transaction.
</p>
</div>

		</section>
		<section id="index-interface">
<h3 title="The IDBIndex interface">4.6. `IDBIndex^I ~interface</h3>
【！ TODO Add example. Should examples be in a separate section?】

<p>
`IDBIndex$I ~interfaceは、
`索引~handle$を表現する。
◎
The IDBIndex interface represents an index handle.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBIndex@I {
  attribute `DOMString$ `name$m;
  [`SameObject$] readonly attribute `IDBObjectStore$I `objectStore$m;
  readonly attribute `any$ `keyPath$m;
  readonly attribute `boolean$ `multiEntry$m;
  readonly attribute `boolean$ `unique$m;

  [`NewObject$] `IDBRequest$I `get$m(
      `any$ %query
  );
  [`NewObject$] `IDBRequest$I `getKey$m(
      `any$ %query
  );
  [`NewObject$] `IDBRequest$I `getAll$m(
      optional `any$ %query,
      optional [`EnforceRange$] `unsigned long$ %count
  );
  [`NewObject$] `IDBRequest$I `getAllKeys$m(
      optional `any$ %query,
      optional [`EnforceRange$] `unsigned long$ %count
  );
  [`NewObject$] `IDBRequest$I `count$m(
      optional `any$ %query
  );

  [`NewObject$] `IDBRequest$I `openCursor$m(
      optional `any$ %query,
      optional `IDBCursorDirection$I %direction = "next"
  );
  [`NewObject$] `IDBRequest$I `openKeyCursor$m(
      optional `any$ %query,
      optional `IDBCursorDirection$I %direction = "next"
  );
};
</pre>

【！  】
<div class="note domintro">
<dl>
	<dt>%index . `name$m</dt>
	<dd>
%index↗ の`名前$Ixを返す。
◎
Returns the name of the index.
</dd>

	<dt>%index . `name$m = %newName</dt>
	<dd>
%index↗ の`名前$Ixを %newName に更新する。
◎
Updates the name of the store to newName.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E が投出される。
◎
Throws an "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>

	<dt>%index . `objectStore$m</dt>
	<dd>
%index が`専属する$`保管庫~handle$（ `IDBObjectStore$I ）を返す。
◎
Returns the IDBObjectStore the index belongs to.
</dd>

	<dt>%index . `keyPath$m</dt>
	<dd>
%index↗ の`~key~path$Ixを返す。
◎
Returns the key path of the index.
</dd>

	<dt>%index . `multiEntry$m</dt>
	<dd>
%index↗ の`複-~entryか$Ixを返す。
◎
Returns true if the index’s multiEntry flag is true.
</dd>

	<dt>%index . `unique$m</dt>
	<dd>
%index↗ の`一意か$Ixを返す。
◎
Returns true if the index’s unique flag is true.
</dd>
</dl>
</div>

<div class="algo">
<p>
`name@m
取得子~手続きは
⇒
~RET コレの`名前$IxH
◎
The name getter steps are to return this's name.
</p>

<p class="note">注記：
コレが`専属する$~txが`完遂-$していない限り、
返される値はコレ↗の`名前$Ixと同じになり、
それ以降も同じ`値を保持し続ける$。
【！ deitails 】
◎
Is this the same as the index's name?
◎
As long as the transaction has not finished, this is the same as the associated index's name. But once the transaction has finished, this attribute will not reflect changes made with a later upgrade transaction.
</p>
</div>

<div class="algo">
<p>
`name$m 設定子~手続きは：
◎
The name setter steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `versionchange^l ) ？
◎
Let name be the given value.
◎
Let transaction be this's transaction.
◎
Let index be this's index.
◎
If transaction is not an upgrade transaction, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
変則＊
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
%name ~LET `所与の値$
◎
↑</li>
	<li>
~IF［
コレの`名前$IxH ~EQ %name
］
⇒
~RET
◎
If index’s name is equal to name, terminate these steps.
</li>
	<li>
~IF［［
コレが`専属する$`保管庫~handle$
］の`索引~集合$OsHに［
`名前$IxH ~EQ %name
］なる`索引$がある
］
⇒
~THROW `ConstraintError$E
◎
If an index named name already exists in index’s object store, throw a "ConstraintError" DOMException.
</li>
	<li>
コレ↗の`名前$Ix ~SET %name
◎
Set index’s name to name.
</li>
	<li>
コレの`名前$IxH ~SET %name
◎
Set this's name to name.
</li>
</ol>
</div>

<div class="algo">
`objectStore@m
取得子~手続きは
⇒
~RET コレが`専属する$`保管庫~handle$
◎
The objectStore getter steps are to return this's object store handle.
</div>

<div class="algo">
<p>
`keyPath@m
取得子~手続きは
⇒
~RET コレ↗の`~key~path$Ix %P を `WEBIDL$r に従って，次の型として変換した結果
⇒＃
%P は文字列であるならば `DOMString$I ／
%P は文字列の~listであるならば `~SeqDS$
◎
The keyPath getter steps are to return this's index's key path. The key path is converted as a DOMString (if a string) or a sequence&lt;DOMString&gt; (if a list of strings), per [WEBIDL].
</p>

<p>
【この属性は、`値を保持し続ける$。】
</p>

<p class="note">注記：
返される値は、
コレの作成-時に利用した~instanceと同じではない。
しかしながら，この属性が~obj（特定的には `Array$jT ）を返す場合、
毎回~同じ~instanceを返す。
返された~objの~prop値を変更しても，コレに効果を及ぼすことはない。
◎
The returned value is not the same instance that was used when the index was created. However, if this attribute returns an object (specifically an Array), it returns the same object instance every time it is inspected. Changing the properties of the object has no effect on the index.
</div>

<div class="algo">
<p>
`multiEntry@m
取得子~手続きは
⇒
~RET コレ↗の`複-~entryか$Ix
◎
The multiEntry getter steps are to return this's index's multiEntry flag.
</p>

<p>
【この属性は、`値を保持し続ける$。】
</p>
</div>

<div class="algo">
<p>
`unique@m
取得子~手続きは
⇒
~RET コレ↗の`一意か$Ix
◎
The unique getter steps are to return this's index's unique flag.
</p>

<p>
【この属性は、`値を保持し続ける$。】
</p>
</div>

<div class="note domintro">
<p>
以下に挙げる~methodは、
`~tx$が `作動中$i でないときに~callされた場合は
`TransactionInactiveError$E を投出する。
◎
The following methods throw an "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl>
	<dt>%request = %index . `get(query)$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$に入る~recordたち
］のうち，最初の~recordの`参照先~record$の`値$を検索取得するよう要請する。
◎
Retrieves the value of the first record matching the given key or key range in query.
</dd>
	<dd>
成功した場合の %request の `result$m は、
該当する~recordが［
在るならば 得られた値／
無いならば `undefined^jv
］になる。
◎
If successful, request’s result will be the value, or undefined if there was no matching record.
</dd>

	<dt>%request = %index . `getKey(query)$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$に入る~recordたち
］のうち，最初の~recordの値
— すなわち，`参照先~record$の`~key$ —
を検索取得するよう要請する。
◎
Retrieves the key of the first record matching the given key or key range in query.
</dd>
	<dd>
成功した場合の %request の `result$m は、
該当する~recordが［
在るならば 得られた`~key$ ／
無いならば `undefined^jv
］になる。
◎
If successful, request’s result will be the key, or undefined if there was no matching record.
</dd>

	<dt>%request = %index . `getAll(query [, count])$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$に入る~recordたち
］のうち，最初から %count 個までの~recordの`参照先~record$の値たちを検索取得するよう要請する。
◎
Retrieves the values of the records matching the given key or key range in query (up to count if given).
</dd>
	<dd>
成功した場合の %request の `result$m は、
一連の`値$からなる `Array$jT になる。
◎
If successful, request’s result will be an Array of the values.
</dd>

	<dt>%request = %index . `getAllKeys(query [, count])$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$に入る~recordたち
］のうち，最初から %count 個までの~recordの値
— すなわち，`参照先~record$の`~key$ —
たちを検索取得するよう要請する。
◎
Retrieves the keys of records matching the given key or key range in query (up to count if given).
</dd>
	<dd>
成功した場合の %request の `result$m は、
一連の`~key$からなる `Array$jT になる。
◎
If successful, request’s result will be an Array of the keys.
</dd>

	<dt>%request = %index . `count(query)$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$に入る~recordたち
］の総数を得るよう要請する。
◎
Retrieves the number of records matching the given key or key range in query.
</dd>
	<dd>
成功した場合の %request の `result$m は、
得られた総数になる。
◎
If successful, request’s result will be the count.
</dd>
</dl>
</div>

<div class="algo">
<p>
`get(query)@m
~method手続きは：
◎
The get(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let index be this's index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query, `~NULL不可^i ) ？
◎
Let range be the result of converting a value to a key range with query and true. Rethrow any exceptions.
</li>
	<li>
%取得演算 ~LET 所与の %~record から次を取得する演算
⇒
~NOABRUPT `StructuredDeserialize$jA( %~record の`参照先~record$の値, `現在の~Realm$ )
◎
↓</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`範囲に入る最初の~entryを検索取得する$( コレ↗, %範囲, %取得演算 )
◎
Let operation be an algorithm to run retrieve a referenced value from an index with the current Realm, index, and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
検索取得する`~record$を識別する［
`~key$／`~key範囲$
］をとり得る。
範囲が指定された場合、
~methodは，その範囲に入る最初の既存の~recordの値を検索取得する。
◎
The query parameter can be a key or key range (an IDBKeyRange) identifying the record to be retrieved. If a range is specified, the method retrieves the first existing record in that range.
</p>

<p class="note">注記：
`IDBObjectStore.get()$m の注記にて述べたことが，この~methodにも該当する。
◎
This method produces the same result if a record with the given key doesn’t exist as when a record exists, but has undefined as value. If you need to tell the two situations apart, you can use openCursor() with the same key. This will return a cursor with undefined as value if a record exists, or no cursor if no such record exists.
</p>
</div>

<div class="algo">
<p>
`getKey(query)@m
~method手続きは：
◎
The getKey(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let index be this's index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query, `~NULL不可^i ) ？
◎
Let range be the result of converting a value to a key range with query and true. Rethrow any exceptions.
</li>
	<li>
%取得演算 ~LET 所与の %~record から次を取得する演算
⇒
`~keyを値に変換する$( %~record の`値$ )
◎
↓</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`範囲に入る最初の~entryを検索取得する$( コレ↗, %範囲, %取得演算 )
◎
Let operation be an algorithm to run retrieve a value from an index with index and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
検索取得する`~record$の~keyを識別する［
`~key$／`~key範囲$
］をとり得る。
範囲が指定された場合、
~methodは，その範囲に入る最初の既存の~keyを検索取得する。
◎
The query parameter can be a key or key range (an IDBKeyRange) identifying the record key to be retrieved. If a range is specified, the method retrieves the first existing key in that range.
</p>
</div>

<div class="algo">
<p>
`getAll(query, count)@m
~method手続きは：
◎
The getAll(query, count) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let index be this's index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
%取得演算 ~LET 所与の %~record から次を取得する演算
⇒
~NOABRUPT `StructuredDeserialize$jA( %~record の`参照先~record$の値, `現在の~Realm$ )
◎
↓</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`範囲に入る~entryたちを検索取得する$( コレ↗, %範囲, %count, %取得演算 )
◎
Let operation be an algorithm to run retrieve multiple referenced values from an index with the current Realm, index, range, and count if given.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
検索取得する`~record$たちを識別する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
%count が指定されていて，範囲に入る~record数がそれを超える場合，最初から %count 個までが検索取得される。
◎
The query parameter can be a key or key range (an IDBKeyRange) identifying the records to be retrieved. If null or not given, an unbounded key range is used. If count is specified and there are more than count records in range, only the first count will be retrieved.
</p>
</div>

<div class="algo">
<p>
`getAllKeys(query, count)@m
~method手続きは：
◎
The getAllKeys(query, count) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let index be this's index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
%取得演算 ~LET 所与の %~record から次を取得する演算
⇒
`~keyを値に変換する$( %~record の`値$ )
◎
↓</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`範囲に入る~entryたちを検索取得する$( コレ↗, %範囲, %count, %取得演算 )
◎
Let operation be an algorithm to run retrieve multiple values from an index with index, range, and count if given.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
検索取得する`~record$たちの~keyを識別する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
%count が指定されていて，範囲に入る~key数がそれを超える場合，最初から %count 個までが検索取得される。
◎
The query parameter can be a key or key range (an IDBKeyRange) identifying the records keys to be retrieved. If null or not given, an unbounded key range is used. If count is specified and there are more than count keys in range, only the first count will be retrieved.
</p>
</div>

<div class="algo">
<p>
`count(query)@m
~method手続きは：
◎
The count(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let index be this's index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`範囲に入る~recordを数える$( コレ↗, %範囲 )
◎
Let operation be an algorithm to run count the records in a range with index and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
数えられる`~record$たちの~keyを識別する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter can be a key or key range (an IDBKeyRange) identifying the records keys to be counted. If null or not given, an unbounded key range is used.
</p>
</div>

<div class="note domintro">
<p>
以下に挙げる~methodは、
`~tx$が `作動中$i でないときに~callされた場合は
`TransactionInactiveError$E を投出する。
◎
The following methods throw an "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl>
	<dt>%request = %index . `openCursor([query [, direction = "next"]])$m</dt>
	<dd>
［
%index↗ の`~record~list$Os内の［
%query が`表現する~key範囲$（ %query が~NULL ならば`全範囲$）に入る~recordたち
］を，`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
◎
Opens a cursor over the records matching query, ordered by direction. If query is null, all records in index are matched.
</dd>
	<dd>
成功した場合の %request の `result$m は、
範囲に入る~recordが［
在るならば 反復-順で最初の~recordを指している `IDBCursorWithValue$I ／
無いならば ~NULL
］になる。
◎
If successful, request’s result will be an IDBCursorWithValue, or null if there were no matching records.
</dd>

	<dt>%request = %index . `openKeyCursor([query [, direction = "next"]])$m</dt>
	<dd>
［
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$（ %query が~NULL ならば`全範囲$）に入る~recordたち
］を，`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
作成される`~cursor$の`~keyのみか$Csは ~T になる
（~cursorは、
~recordの~keyのみを取得する）。
◎
Opens a cursor with key only flag set to true over the records matching query, ordered by direction. If query is null, all records in index are matched.
</dd>
	<dd>
成功した場合の %request の `result$m は、
範囲に入る~recordが［
在るならば 反復-順で最初の~recordを指している `IDBCursor$I ／
無いならば ~NULL
］になる。
◎
If successful, request’s result will be an IDBCursor, or null if there were no matching records.
</dd>
</dl>
</div>

<div class="algo">
<p>
`openCursor(query, direction)@m
~method手続きは：
◎
The openCursor(query, direction) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let index be this's index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
%要請 ~LET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`~cursorを作成する$( コレ, `現在の~Realm$, %direction, %範囲 )
◎
Let cursor be a new cursor with its transaction set to transaction, undefined position, direction set to direction, got value flag set to false, undefined key and value, source set to index, range set to range, and key only flag set to false.
◎
Let operation be an algorithm to run iterate a cursor with the current Realm and cursor.
◎
Let request be the result of running asynchronously execute a request with this and operation.
</li>
	<li>
コレの`要請$Cs ~SET %要請
◎
Set cursor’s request to request.
</li>
	<li>
~RET %要請
◎
Return request.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
`~cursor$の`範囲$Csとして利用する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter can be a key or key range (an IDBKeyRange) to use as the cursor's range. If null or not given, an unbounded key range is used.
</p>
</div>

<div class="algo">
<p>
`openKeyCursor(query, direction)@m
~method手続きは：
◎
The openKeyCursor(query, direction) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
Let index be this's index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
%要請 ~LET 次の`演算$を走らす`要請を非同期に実行する$( コレ )
⇒
`~cursorを作成する$( コレ, `現在の~Realm$, %direction, %範囲, `~keyのみ^i )
◎
Let cursor be a new cursor with its transaction set to transaction, undefined position, direction set to direction, got value flag set to false, undefined key and value, source set to index, range set to range, and key only flag set to true.
◎
Let operation be an algorithm to run iterate a cursor with the current Realm and cursor.
◎
Let request be the result of running asynchronously execute a request with this and operation.
</li>
	<li>
コレの`要請$Cs ~SET %要請
◎
Set cursor’s request to request.
</li>
	<li>
~RET %要請
◎
Return request.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
`~cursor$の`範囲$Csとして利用する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter can be a key or key range (an IDBKeyRange) to use as the cursor's range. If null or not given, an unbounded key range is used.
</p>
</div>

		</section>
		<section id="keyrange">
<h3 title="The IDBKeyRange interface">4.7. `IDBKeyRange^I ~interface</h3>

<p>
`IDBKeyRange$I ~interfaceは、
`~key範囲$を表現する。
◎
The IDBKeyRange interface represents a key range.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBKeyRange@I {
  readonly attribute `any$ `lower$m;
  readonly attribute `any$ `upper$m;
  readonly attribute `boolean$ `lowerOpen$m;
  readonly attribute `boolean$ `upperOpen$m;

  // <span class="comment" title="Static construction methods">静的~構築~method：</span>
  [`NewObject$] static `IDBKeyRange$I `only$m(
      `any$ %value
  );
  [`NewObject$] static `IDBKeyRange$I `lowerBound$m(
      `any$ %lower,
      optional `boolean$ %open = false
  );
  [`NewObject$] static `IDBKeyRange$I `upperBound$m(
      `any$ %upper,
      optional `boolean$ %open = false
  );
  [`NewObject$] static `IDBKeyRange$I `bound$m(
      `any$ %lower,
      `any$ %upper,
      optional `boolean$ %lowerOpen = false,
      optional `boolean$ %upperOpen = false
  );

  `boolean$ `includes$m(`any$ %key);
};
</pre>

<div class="note domintro">
<dl>
	<dt>%range . `lower$m</dt>
	<dd>
この範囲の`下界$が［
あれば それ ／
なければ `undefined^jv
］を返す。
◎
Returns the range’s lower bound, or undefined if none.
</dd>

	<dt>%range . `upper$m</dt>
	<dd>
この範囲の`上界$が［
あれば それ ／
なければ `undefined^jv
］を返す。
◎
Returns the range’s upper bound, or undefined if none.
</dd>

	<dt>%range . `lowerOpen$m</dt>
	<dd>
この範囲の`下界openか$を返す。
◎
Returns the range’s lower open flag.
</dd>

	<dt>%range . `upperOpen$m</dt>
	<dd>
この範囲の`上界openか$を返す。
◎
Returns the range’s upper open flag.
</dd>
</dl>
</div>

<div class="algo">
`lower@m
取得子~手続きは
⇒
~RET `Value$( コレの`下界$ )
◎
The lower getter steps are to return the result of converting a key to a value with this's lower bound if it is not null, or undefined otherwise.
</div>

<div class="algo">
`upper@m
取得子~手続きは
⇒
~RET `Value$( コレの`上界$ )
◎
The upper getter steps are to return the result of converting a key to a value with this's upper bound if it is not null, or undefined otherwise.
</div>

<div class="algo">
`lowerOpen@m
取得子~手続きは
⇒
~RET コレの`下界openか$
◎
The lowerOpen getter steps are to return this's lower open flag.
</div>

<div class="algo">
`upperOpen@m
取得子~手続きは
⇒
~RET コレの`上界openか$
◎
The upperOpen getter steps are to return this's upper open flag.
</div>

<div class="note domintro">
<dl>
	<dt>%range = `IDBKeyRange$I . `only(key)$m</dt>
	<dd>
%value のみを含む，新たな `IDBKeyRange$I （ `~key範囲$ ）を返す。
◎
Returns a new IDBKeyRange spanning only key.
</dd>

	<dt>%range = `IDBKeyRange$I . `lowerBound(lower [, open = false])$m</dt>
	<dd>
`下界$ %lower から開始され, `上界$のない，新たな `IDBKeyRange$I を返す。
%open が ~T の場合、
%lower はこの範囲に含まれない。
◎
Returns a new IDBKeyRange starting at key with no upper bound. If open is true, key is not included in the range.
</dd>

	<dt>%range = `IDBKeyRange$I . `upperBound(upper [, open = false])$m</dt>
	<dd>
`下界$のない, `上界$ %upper で終端する，新たな `IDBKeyRange$I を返す。
%open が ~T の場合、
%upper はこの範囲に含まれない。
◎
Returns a new IDBKeyRange with no lower bound and ending at key. If open is true, key is not included in the range.
</dd>

	<dt>%range = `IDBKeyRange$I . `bound(lower, upper [, lowerOpen = false [, upperOpen = false]])$m</dt>
	<dd>
`下界$ %lower から `上界$ %upper までにわたる，新たな `IDBKeyRange$I を返す。
%lowerOpen が ~T の場合、
%lower はこの範囲に含まれない。
%upperOpen が ~T の場合、
%upper はこの範囲に含まれない。
◎
Returns a new IDBKeyRange spanning from lower to upper. If lowerOpen is true, lower is not included in the range. If upperOpen is true, upper is not included in the range.
</dd>
	<dd class="trans-note">【
［
%lower ／ %upper
］に対する `undefined^jv は、
許容されない
（省略可能でないので）。
したがって，［
`下界$ ／`上界$
］のない`~key範囲$を作成するためには、
他の~methodを利用する必要がある。
`全範囲$を表現する `IDBKeyRange^I ~objは 作成できないが、
<code>`lowerBound$m(`-Infinity^jv)</code>
により，実質的に等価なものは作成できる。
また、
他の各種~API~methodの引数のうち，`~key範囲$を期待するもの
（この仕様の~IDLで %query と記される引数）は、
（省略可能ならば）省略した場合には`全範囲$に解釈される。
】</dd>
</dl>
</div>

<div class="algo">
`only(value)@m
~method手続きは
⇒
~RET `Only$( `Key$( %value ) ) ？
◎
The only(value) method steps are:
• Let key be the result of converting a value to a key with value. Rethrow any exceptions.
• If key is invalid, throw a "DataError" DOMException.
• Create and return a new key range containing only key.
</div>

<div class="algo">
<p>
`lowerBound(lower, open)@m
~method手続きは：
◎
The lowerBound(lower, lowerOpen) method steps are:
</p>
<ol>
	<li>
%lowerKey ~LET `Key$( %lower ) ？
◎
Let lowerKey be the result of converting a value to a key with lower. Rethrow any exceptions.
◎
If lowerKey is invalid, throw a "DataError" DOMException.
</li>
	<li>
~RET 新たな`~key範囲$
— その
⇒＃
`下界$ ~SET %lowerKey,
`下界openか$ ~SET %open,
`上界$ ~SET ε,
`上界openか$ ~SET ~T
◎
Create and return a new key range with lower bound set to lowerKey, lower open flag set to open, upper bound set to null, and upper open flag set to true.
</li>
</ol>
</div>

<div class="algo">
<p>
`upperBound(upper, open)@m
~method手続きは：
◎
The upperBound(upper, open) method steps are:
</p>
<ol>
	<li>
%upperKey ~LET `Key$( %upper ) ？
◎
Let upperKey be the result of converting a value to a key with upper. Rethrow any exceptions.
◎
If upperKey is invalid, throw a "DataError" DOMException.
</li>
	<li>
~RET 新たな`~key範囲$
— その
⇒＃
`下界$ ~SET ε,
`下界openか$ ~SET ~T,
`上界$ ~SET %upperKey,
`上界openか$ ~SET %open
◎
Create and return a new key range with lower bound set to null, lower open flag set to true, upper bound set to upperKey, and upper open flag set to open.
</li>
</ol>
</div>

<div class="algo">
<p>
`bound(lower, upper, lowerOpen, upperOpen)@m
~method手続きは：
◎
The bound(lower, upper, lowerOpen, upperOpen) method steps are:
</p>
<ol>
	<li>
%lowerKey ~LET `Key$( %lower ) ？
◎
Let lowerKey be the result of converting a value to a key with lower. Rethrow any exceptions.
◎
If lowerKey is invalid, throw a "DataError" DOMException.
</li>
	<li>
%upperKey ~LET `Key$( %upper ) ？
◎
Let upperKey be the result of converting a value to a key with upper. Rethrow any exceptions.
◎
If upperKey is invalid, throw a "DataError" DOMException.
</li>
	<li>
~IF［
%lower ~GT~cmpkey %upper
］
⇒
~THROW `DataError$E
◎
If lowerKey is greater than upperKey, throw a "DataError" DOMException.
</li>
	<li>
~RET 新たな`~key範囲$
— その
⇒＃
`下界$ ~SET %lowerKey,
`下界openか$ ~SET %lowerOpen,
`上界$ ~SET %upperKey,
`上界openか$ ~SET %upperOpen
◎
Create and return a new key range with lower bound set to lowerKey, lower open flag set to lowerOpen, upper bound set to upperKey and upper open flag set to upperOpen.
</li>
</ol>
</div>

<div class="note domintro">
<dl>
	<dt>%range . `includes(key)$m</dt>
	<dd>
［
%key が %range に`入る$ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if key is included in the range, and false otherwise.
</dd>
</dl>
</div>

<div class="algo">
<p>
`includes(key)@m
~method手続きは：
◎
The includes(key) method steps are:
</p>
<ol>
	<li>
%key ~LET `Key$( %key ) ？
◎
Let k be the result of converting a value to a key with key. Rethrow any exceptions.
◎
If k is invalid, throw a "DataError" DOMException.
</li>
	<li>
~IF ［
%key ~IN~cmpkey コレ
］
⇒
~RET ~T
◎
Return true if k is in this range, and＼
</li>
	<li>
~RET  ~F
◎
false otherwise.
</li>
</ol>
</div>

		</section>
		<section id="cursor-interface">
<h3 title="The IDBCursor interface">4.8. `IDBCursor^I ~interface</h3>
【！ TODO Add example. Should examples be in a separate section?】

<p>
`~cursor$~objは、
`IDBCursor$I ~interfaceを実装する。
所与の`~cursor$を表現するような `IDBCursor$I ~instanceは，唯一つに限られるが、
同時に利用できる~cursorの~~総数に上限はない。
◎
Cursor objects implement the IDBCursor interface. There is only ever one IDBCursor instance representing a given cursor. There is no limit on how many cursors can be used at the same time.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBCursor@I {
  readonly attribute (`IDBObjectStore$I or `IDBIndex$I) `source$m;
  readonly attribute `IDBCursorDirection$I `direction$m;
  readonly attribute `any$ `key$m;
  readonly attribute `any$ `primaryKey$m;
  [`SameObject$] readonly attribute `IDBRequest$I `request$m;

  `undefined$ `advance$m(
      [`EnforceRange$] `unsigned long$ %count
  );
  `undefined$ `continue$m(
      optional `any$ %key
  );
  `undefined$ `continuePrimaryKey$m(
      `any$ %key,
      `any$ %primaryKey
  );

  [`NewObject$] `IDBRequest$I `update$m(
      `any$ %value
  );
  [`NewObject$] `IDBRequest$I `delete$m();
};

enum `IDBCursorDirection@I {
  `next$l,
  `nextunique$l,
  `prev$l,
  `prevunique$l
};
</pre>

<!-- `IDBCursor!I -->
<div class="note domintro">
<dl>
	<dt>%cursor . `source$m</dt>
	<dd>
%cursor の`~source$Cs
（ `IDBObjectStore$I ／ `IDBIndex$I ）
を返す。
◎
Returns the IDBObjectStore or IDBIndex the cursor was opened from.
</dd>

	<dt>%cursor . `direction$m</dt>
	<dd>
%cursor の`方向$Cs
（ `next$l ／ `nextunique$l ／ `prev$l ／ `prevunique$l ）
を返す。
◎
Returns the direction ("next", "nextunique", "prev" or "prevunique") of the cursor.
</dd>

	<dt>%cursor . `key$m</dt>
	<dd>
%cursor の`~key$Csを返す。
◎
Returns the key of the cursor.＼
</dd>
	<dd>
%cursor を進めている間 ／ 反復し終えていた場合、
`InvalidStateError$E が投出される†。
◎
Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished.
</dd>

	<dt>%cursor . `primaryKey$m</dt>
	<dd>
%cursor の`実効~key$Csを返す。
◎
Returns the effective key of the cursor.＼
</dd>
	<dd>
%cursor を進めている間 ／ 反復し終えていた場合、
`InvalidStateError$E が投出される†。
◎
Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished.
</dd>
	<dd class="trans-note">【†
これらの要件は、
下の規範的な~textには述べられていない
（何かの間違い？）。
】</dd>

	<dt>%cursor . `request$m</dt>
	<dd>
%cursor を得するために利用された`要請$Csを返す。
◎
Returns the request that was used to obtain this cursor.
</dd>
</dl>
</div>

<div class="algo">
<p>
`source@m
取得子~手続きは
⇒
~RET コレの`~source$Cs
◎
The source getter steps are to return this's source.
</p>

<p class="note">注記：
コレの`~source$Cs %S は、
<a href="#_X-new-cursor">コレを作成する</a>よう要請した［
`保管庫~handle$／`索引~handle$
］に初期化され，
それ以降は変化しない
— %S が`専属する$~txが `作動中$i でなくなっても， %S↗ が破壊されても。
◎
The source attribute never returns null or throws an exception, even if the cursor is currently being iterated, has iterated past its end, or its transaction is not active.
</p>
</div>

<div class="algo">
`direction@m
取得子~手続きは
⇒
~RET コレの`方向$Cs
◎
The direction getter steps are to return this's direction.
</div>

<div class="algo">
<p>
`key@m
取得子~手続きは
⇒
~RET `Value$( コレの`~key$Cs )
◎
The key getter steps are to return the result of converting a key to a value with the cursor’s current key.
</p>

<p class="note" id="_key-getter-return-value">注記：
~obj（ `Date$jT や `Array$jT など）を返す場合、
コレの`~key$Cs が変更されるまで，毎回~同じ~instanceを返すことになる。
すなわち、
~objに加えられる改変は，どこからも見えることになる
— しかしながら、
その改変が~dbの内容を改変することはない。
◎
If key returns an object (e.g. a Date or Array), it returns the same object instance every time it is inspected, until the cursor’s key is changed. This means that if the object is modified, those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object does not modify the contents of the database.
</p>
</div>

<div class="algo">
<p>
`primaryKey@m
取得子~手続きは
⇒
~RET `Value$( コレの`実効~key$Cs )
◎
The primaryKey getter steps are to return the result of converting a key to a value with the cursor’s current effective key.
</p>

<p class="note">注記：
<a href="#_key-getter-return-value">`key^m 取得子の注記</a>は、
この取得子にも該当する。
◎
If primaryKey returns an object (e.g. a Date or Array), it returns the same object instance every time it is inspected, until the cursor’s effective key is changed. This means that if the object is modified, those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object does not modify the contents of the database.
</p>
</div>

<div class="algo">
<p>
`request@m
取得子~手続きは
⇒
~RET コレの`要請$Cs
◎
The request getter steps are to return this's request.
</p>

<p class="advisement">🚧
これは、
この版による新たな属性である。
Chrome 76, Edge 79, Firefox 77
から~supportされている。
🚧
◎
🚧 The request attribute is new in this edition. It is supported in Chrome 76, Edge 79, and Firefox 77. 🚧
</p>
</div>

<div class="note domintro">
<p>
以下に挙げる~methodは、
`~cursor$を その`範囲$Csに入る次の`~record$以降へ進めるよう要請する：
◎
The following methods advance a cursor.
</p>
<ul>
	<li>
進め終えた時点で、
~cursorの`要請$Csに向けて `success$et ~eventが発火されることになる。
`result$m は、
`範囲$Csに入る`~record$が［
在るならば ~cursor自身 ／
無いならば `undefined^jv
］になる。
◎
Once the cursor has advanced, a success event will be fired at the same IDBRequest returned when the cursor was opened. The result will be the same cursor if a record was in range, or undefined otherwise.
</li>
	<li>
~cursorを進める前回の要請が在って，それが完了する前に~callされた場合、
`InvalidStateError$E を投出する。
◎
If called while the cursor is already advancing, an "InvalidStateError" DOMException will be thrown.
</li>
	<li>
`~tx$が `作動中$i でないときに~callされた場合、
`TransactionInactiveError$E を投出する。
◎
The following methods throw a "TransactionInactiveError" DOMException if called when the transaction is not active.
</li>
</ul>

<dl>
	<dt>%cursor . `advance(count)$m</dt>
	<dd>
%cursor を %count 個だけ先の~recordへ進める。
◎
Advances the cursor through the next count records in range.
</dd>

	<dt>%cursor . `continue$m()</dt>
	<dd>
%cursor を次の~recordへ進める。
◎
Advances the cursor to the next record in range.
</dd>

	<dt>%cursor . `continue(key)$m</dt>
	<dd>
%cursor を，次を満たす最初の~recordへ進める
⇒
［
次の~record以降に在る
］~AND［
`~key$ ~GTE~cmpkey %key
］
◎
Advances the cursor to the next record in range matching or after key.
</dd>

	<dt>%cursor . `continuePrimaryKey(key, primaryKey)$m</dt>
	<dd>
%cursor を，次を満たす最初の~recordへ進める
⇒
［
次の~record以降に在る
］~AND［
( `~key$, `値$ ) ~GTE~cmpkey ( %key, %primaryKey )
］
◎
Advances the cursor to the next record in range matching or after key and primaryKey.＼
</dd>
	<dd>
%cursor の`~source$Cs↗が`索引$でない場合、
`InvalidAccessError$E が投出される。
◎
Throws an "InvalidAccessError" DOMException if the source is not an index.
</dd>
</dl>
</div>

<div class="algo">
<p>
`advance(count)@m
~method手続きは：
◎
The advance(count) method steps are:
</p>
<ol>
	<li>
~IF［
%count ~EQ 0
］
⇒
~THROW `TypeError$jT
◎
If count is 0 (zero), throw a TypeError.
</li>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If this's source or effective object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`値は取得-済みか$Cs ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this's got value flag is false, indicating that the cursor is being iterated or has iterated past its end, throw an "InvalidStateError" DOMException.
</li>
	<li>
コレの`値は取得-済みか$Cs ~SET ~F
◎
Set this's got value flag to false.
</li>
	<li>
%要請 ~SET コレの`要請$Cs
◎
Let request be this's request.
</li>
	<li>
%要請 の
⇒＃
`処理-済みか$ ~SET ~F,
`済んだか$ ~SET ~F
◎
Set request’s processed flag to false.
◎
Set request’s done flag to false.
</li>
	<li>
次の`演算$を走らす`要請を非同期に実行する$( コレの`~source$Cs, %要請 )
⇒
`~cursorを反復する$( コレ, `現在の~Realm$, ε, ε, %count )
◎
Let operation be an algorithm to run iterate a cursor with the current Realm, this, and count.
◎
Run asynchronously execute a request with this's source, operation, and request.
</li>
</ol>

<p class="note">注記：
新たな~cursor~dataが読込まれる前に，この~methodを重ねて~callした場合
— 例えば，同じ `onsuccess^m ~handlerの~callの中で重ねて~callした場合 —
2 回目の~call時には、
~cursorの`値は取得-済みか$Cs ~EQ ~F なので， `InvalidStateError$E 例外が投出されることになる。
◎
Calling this method more than once before new cursor data has been loaded - for example, calling advance() twice from the same onsuccess handler - results in an "InvalidStateError" DOMException being thrown on the second call because the cursor’s got value flag has been set to false.
</p>
</div>

<div class="algo">
<p>
`continue(key)@m
~method手続きは：
◎
The continue(key) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If this's source or effective object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`値は取得-済みか$Cs ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this's got value flag is false, indicating that the cursor is being iterated or has iterated past its end, throw an "InvalidStateError" DOMException.
</li>
	<li>
<p>
~IF［
%key ~NEQ ε
］：
◎
If key is given, then:
</p>
		<ol>
			<li>
%key ~LET `Key$( %key ) ？
◎
Let r be the result of converting a value to a key with key. Rethrow any exceptions.
◎
If r is invalid, throw a "DataError" DOMException.
◎
Let key be r.
</li>
			<li>
~IF［
%key ~LTE~cmpkey コレの`位置$Cs
］~AND［
コレの`方向$Cs ~IN { `next^l, `nextunique^l }
］
⇒
~THROW `DataError$E
◎
If key is less than or equal to this's position and this's direction is "next" or "nextunique", then throw a "DataError" DOMException.
</li>
			<li>
~IF［
%key ~GTE~cmpkey コレの`位置$Cs
］~AND［
コレの`方向$Cs ~IN { `prev^l, `prevunique^l }
］
⇒
~THROW `DataError$E
◎
If key is greater than or equal to this's position and this's direction is "prev" or "prevunique", then throw a "DataError" DOMException.
</li>
		</ol>
	</li>
	<li>
コレの`値は取得-済みか$Cs ~SET ~F
◎
Set this's got value flag to false.
</li>
	<li>
%要請 ~SET コレの`要請$Cs
◎
Let request be this's request.
</li>
	<li>
%要請 の
⇒＃
`処理-済みか$ ~SET ~F,
`済んだか$ ~SET ~F
◎
Set request’s processed flag to false.
◎
Set request’s done flag to false.
</li>
	<li>
次の`演算$を走らす`要請を非同期に実行する$( コレの`~source$Cs, %要請 )
⇒
`~cursorを反復する$( コレ, `現在の~Realm$, %key )
◎
Let operation be an algorithm to run iterate a cursor with the current Realm, this, and key (if given).
◎
Run asynchronously execute a request with this's source, operation, and request.
</li>
</ol>

<p class="note">注記：
`advance$m の注記と同じ文言がこの~methodにも該当する。
◎
Calling this method more than once before new cursor data has been loaded - for example, calling continue() twice from the same onsuccess handler - results in an "InvalidStateError" DOMException being thrown on the second call because the cursor’s got value flag has been set to false.
</p>
</div>

<div class="algo">
<p>
`continuePrimaryKey(key, primaryKey)@m
~method手続きは：
◎
The continuePrimaryKey(key, primaryKey) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this's transaction.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If this's source or effective object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~source$Csは`索引~handle$でない
］
⇒
~THROW `InvalidAccessError$E
◎
If this's source is not an index throw an "InvalidAccessError" DOMException.
</li>
	<li>
~IF［
コレの`方向$Cs ~NIN { `next^l, `prev^l }
］
⇒
~THROW `InvalidAccessError$E
◎
If this's direction is not "next" or "prev", throw an "InvalidAccessError" DOMException.
</li>
	<li>
~IF［
コレの`値は取得-済みか$Cs ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this's got value flag is false, indicating that the cursor is being iterated or has iterated past its end, throw an "InvalidStateError" DOMException.
</li>
	<li>
%key ~LET `Key$( %key ) ？
◎
Let r be the result of converting a value to a key with key. Rethrow any exceptions.
◎
If r is invalid, throw a "DataError" DOMException.
◎
Let key be r.
</li>
	<li>
%首key ~LET `Key$( %primaryKey ) ？
◎
Let r be the result of converting a value to a key with primaryKey. Rethrow any exceptions.
◎
If r is invalid, throw a "DataError" DOMException.
◎
Let primaryKey be r.
</li>
	<li>
~IF［
コレの`方向$Cs ~EQ `next^l
］~AND［
( %key, %首key ) ~LTE~cmpkey コレの ( `位置$Cs, `保管庫~位置$Cs )
］
⇒
~THROW `DataError$E
◎
↓</li>
	<li>
~IF［
コレの`方向$Cs ~EQ `prev^l
］~AND［
( %key, %首key ) ~GTE~cmpkey コレの ( `位置$Cs, `保管庫~位置$Cs )
］
⇒
~THROW `DataError$E
◎
If key is less than this's position and this's direction is "next", throw a "DataError" DOMException.
◎
If key is greater than this's position and this's direction is "prev", throw a "DataError" DOMException.
◎
If key is equal to this's position and primaryKey is less than or equal to this's object store position and this's direction is "next", throw a "DataError" DOMException.
◎
If key is equal to this's position and primaryKey is greater than or equal to this's object store position and this's direction is "prev", throw a "DataError" DOMException.
</li>
	<li>
コレの`値は取得-済みか$Cs ~SET ~F
◎
Set this's got value flag to false.
</li>
	<li>
%要請 ~SET コレの`要請$Cs
◎
Let request be this's request.
</li>
	<li>
%要請 の
⇒＃
`処理-済みか$ ~SET ~F,
`済んだか$ ~SET ~F
◎
Set request’s processed flag to false.
◎
Set request’s done flag to false.
</li>
	<li>
次の`演算$を走らす`要請を非同期に実行する$( コレの`~source$Cs, %要請 )
⇒
`~cursorを反復する$( コレ, `現在の~Realm$, %key, %首key )
◎
Let operation be an algorithm to run iterate a cursor with the current Realm, this, key, and primaryKey.
◎
Run asynchronously execute a request with this's source, operation, and request.
</li>
</ol>

<p class="note">注記：
`advance$m の注記と同じ文言がこの~methodにも該当する。
◎
Calling this method more than once before new cursor data has been loaded - for example, calling continuePrimaryKey() twice from the same onsuccess handler - results in an "InvalidStateError" DOMException being thrown on the second call because the cursor’s got value flag has been set to false.
</p>
</div>

<div class="note domintro">
<p>
以下に挙げる~methodは、［
`~readonly~tx$の中で~callされた場合は `ReadOnlyError$E ／
`~tx$が `作動中$i でないときに~callされた場合は `TransactionInactiveError$E
］を投出する。
◎
The following methods throw a "ReadOnlyError" DOMException if called within a read-only transaction, and a "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl>
	<dt>%request = %cursor . `update(value)$m</dt>
	<dd>
%cursor が指している`~record$†の値を %value に更新するよう要請する。
◎
Updated the record pointed at by the cursor with a new value.
</dd>
	<dd class="trans-note">【†
`~source$Csが`索引$の場合は、
その`参照先~record$。
】</dd>
	<dd>
［
%cursor の`実効~保管庫$Csの`~key~path$Os ~NEQ ε
］の下で，
`~key$を変更しようとした場合†、
`DataError$E が投出される。
◎
Throws a "DataError" DOMException if the effective object store uses in-line keys and the key would have changed.
</dd>
	<dd class="trans-note">【†
すなわち，当の~recordの~keyが %value 内の`~key~path$Osが指す部位と等しくない場合。
】</dd>
	<dd>
成功した場合の %request の `result$m は、
更新した`~record$の`~key$になる。
◎
If successful, request’s result will be the record's key.
</dd>

	<dt>%request = %cursor . `delete$m()</dt>
	<dd>
%cursor が指している~recordを削除するよう要請する。
【！ ＊原文誤 with a new value. 】
◎
Delete the record pointed at by the cursor with a new value.
</dd>
	<dd>
成功した場合の %request の `result$m は、
`undefined^jv になる。
◎
If successful, request’s result will be undefined.
</dd>
</dl>
</div>

<div class="algo">
<p>
`update(value)@m
~method手続きは：
◎
The update(value) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `readwrite^l ) ？
◎
Let transaction be this's transaction.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
◎
If this's source or effective object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`値は取得-済みか$Cs ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this's got value flag is false, indicating that the cursor is being iterated or has iterated past its end, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~keyのみか$Cs ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If this's key only flag is true, throw an "InvalidStateError" DOMException.
</li>
	<li>
%clone ~LET `~txの間に値を~cloneする$( %value, コレの`~source$Csが`専属する$`~tx$ ) ？
◎
Let targetRealm be a user-agent defined Realm.
◎
Let clone be a clone of value in targetRealm during transaction. Rethrow any exceptions.
◎
Why create a copy of the value?
◎
The value is serialized when stored. Treating it as a copy here allows other algorithms in this specification to treat it as an ECMAScript value, but implementations can optimize this if the difference in behavior is not observable.
</li>
	<li>
%keyPath ~LET コレの`実効~保管庫$Csの`~key~path$Os
◎
↓</li>
	<li>
<p>
~IF［
%keyPath ~NEQ ε
］：
</p>
		<ol>
			<li>
%抽出d~key ~LET `Extract$( %clone, %keyPath ) ？
</li>
			<li>
~IF［
%抽出d~key ~NEQ~cmpkey ~cursorの`実効~key$Cs
］
⇒
~THROW `DataError$E
◎
↑</li>
		</ol>

◎
If this's effective object store uses in-line keys, then:
• Let kpk be the result of extracting a key from a value using a key path with clone and the key path of this's effective object store. Rethrow any exceptions.
• If kpk is failure, invalid, or not equal to this's effective key, throw a "DataError" DOMException.
</li>
	<li>
<p>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレの`~source$Cs )
⇒
`保管庫に~recordを格納する$( コレの`実効~保管庫$Cs, %clone, コレの`実効~key$Cs )
◎
Let operation be an algorithm to run store a record into an object store with this's effective object store, clone, this's effective key, and false.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</p>

<p class="note">注記：
`保管庫に~recordを格納する$演算は、［
~cursorを ある~recordを指す位置に移動した後，その~recordが削除されていた場合
］には，新たな~recordを作成することになる。
◎
A result of storing a record into an object store is that if the record has been deleted since the cursor moved to it, a new record will be created.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`delete()@m
~method手続きは：
◎
The delete() method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `readwrite^l ) ？
◎
Let transaction be this's transaction.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
◎
If this's source or effective object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`値は取得-済みか$Cs ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this's got value flag is false, indicating that the cursor is being iterated or has iterated past its end, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~keyのみか$Cs ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If this's key only flag is true, throw an "InvalidStateError" DOMException.
</li>
	<li>
~RET 次の`演算$を走らす`要請を非同期に実行する$( コレの`~source$Cs )
⇒
`保管庫から~recordを削除する$( コレの`実効~保管庫$Cs, `Only$( コレの`実効~key$Cs ) )
◎
Let operation be an algorithm to run delete records from an object store with this's effective object store and this's effective key.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>
</div>

<p>
`~keyのみか$Cs ~EQ ~F
にされた`~cursor$は、
`IDBCursorWithValue$I ~interfaceも実装する。
◎
A cursor that has its key only flag set to false implements the IDBCursorWithValue interface as well.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBCursorWithValue@I : `IDBCursor$I {
  readonly attribute `any$ `value$m;
};
</pre>

<div class="note domintro">
<dl>
	<dt>%cursor . `value$m</dt>
	<dd>
%cursor の現在の`値$Csを返す。
◎
Returns the cursor's current value.
</dd>
</dl>
</div>

<div class="algo">
<p>
`value@m
取得子~手続きは
⇒
~RET ［
コレの`値$Cs ~NEQ ε ならば それ ／
~ELSE_ `undefined^jv
］
◎
The value getter steps are to return this's current value.
</p>

<p class="note">注記：
<a href="#_key-getter-return-value">`key^m 取得子の注記</a>は、
この取得子にも該当する。
◎
If value returns an object, it returns the same object instance every time it is inspected, until the cursor’s value is changed. This means that if the object is modified, those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object does not modify the contents of the database.
</p>
</div>

		</section>
		<section id="transaction">
<h3 title="The IDBTransaction interface">4.9. `IDBTransaction^I ~interface</h3>
【！ TODO Add example. Should examples be in a separate section?】

<p>
`~tx$は、
次の~interfaceを実装する~objで表現される：
◎
Transaction objects implement the following interface:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBTransaction@I : `EventTarget$I {
  readonly attribute `DOMStringList$I `objectStoreNames$m;
  readonly attribute `IDBTransactionMode$I `mode$m;
  readonly attribute `IDBTransactionDurability$I `durability$m;
  [`SameObject$] readonly attribute `IDBDatabase$I `db$m;
  readonly attribute `DOMException$I? `error$m;

  `IDBObjectStore$I `objectStore$m(`DOMString$ %name);
  `undefined$ `commit$m();
  `undefined$ `abort$m();

  // <span class="comment" title="Event handlers">~event~handler：</span>
  attribute `EventHandler$I `onabort$m;
  attribute `EventHandler$I `oncomplete$m;
  attribute `EventHandler$I `onerror$m;
};

enum `IDBTransactionMode@I {
  `readonly$l,
  `readwrite$l,
  `versionchange$l
};
</pre>

<!-- `IDBTransaction!I -->
<div class="note domintro">
<dl>
	<dt>%transaction . `objectStoreNames$m</dt>
	<dd>
%transaction の`視野$に入る`保管庫$たちの名前からなる~listを返す。
`昇格~tx$に対しては、
視野は，当の`~db$の`保管庫$すべてからなる。
◎
Returns a list of the names of object stores in the transaction’s scope. For an upgrade transaction this is all object stores in the database.
</dd>

	<dt>%transaction . `mode$m</dt>
	<dd>
%transaction の`~mode$を返す。
`昇格~tx$に対しては， `versionchange$l ／
他の~txに対しては，その作成-時に与えたもの（ `readonly$l ／ `readwrite$l ）になる。
◎
Returns the mode the transaction was created with ("readonly" or "readwrite"), or "versionchange" for an upgrade transaction.
</dd>

	<dt>%transaction . `durability$m</dt>
	<dd>
%transaction の作成-時に与えた`耐久能~hint$
（ `strict$l ／ `relaxed$l ／ `default$l ）
を返す。
◎
Returns the durability hint the transaction was created with ("strict", "relaxed"), or "default").
</dd>

	<dt>%transaction . `db$m</dt>
	<dd>
%transaction が`専属する$`接続$を返す。
◎
Returns the transaction’s connection.
</dd>

	<dt>%transaction . `error$m</dt>
	<dd>
%transaction が すでに`中止-$されている場合、
その事由を供する~error（ `DOMException$I ）を返す。
◎
If the transaction was aborted, returns the error (a DOMException) providing the reason.
</dd>
</dl>
</div>

<div class="algo">
<p>
`objectStoreNames@m
取得子~手続きは：
◎
The objectStoreNames getter steps are:
</p>
<ol>
	<li>
%名前~群 ~LET ［
コレが`視野$に入れている すべての`保管庫$たちの`名前$Os
］からなる`~list$
◎
Let names be a list of the names of the object stores in this's scope.
</li>
	<li>
~RET `~sort済み名前~listを作成する$( %名前~群 )
◎
Return the result (a DOMStringList) of creating a sorted name list with names.
</li>
</ol>

<p class="note">注記：
この属性は、
いつも同じ内容の~listを返す
— ただし，`昇格~tx$の間は、
保管庫が［
作成される／削除される
］に伴い，異なる内容の~listを返し得る。
◎
The contents of each list returned by this attribute does not change, but subsequent calls to this attribute during an upgrade transaction can return lists with different contents as object stores are created and deleted.
</p>
</div>

<div class="algo">
`mode@m
取得子~手続きは
⇒
~RET コレの`~mode$
◎
The mode getter steps are to return this's mode.
</div>

<div class="algo">
<p>
`durability@m
取得子~手続きは
⇒
~RET コレの`耐久能~hint$
◎
The durability getter steps are to return this's durability hint.
</p>

<p class="advisement">🚧
これは、
この版による新たな属性である。
Chrome 82, Edge 82
から~supportされている。
🚧
◎
🚧 The durability attribute is new in this edition. It is supported in Chrome 82 and Edge 82. 🚧
</p>
</div>

<div class="algo">
`db@m
取得子~手続きは
⇒
~RET コレが`専属する$`接続$
◎
The db getter steps are to return this's connection's associated database.
</div>

<div class="algo">
<p>
`error@m
取得子~手続きは
⇒
~RET ［
コレの`~error$tx ~NEQ ε ならば それ ／
~ELSE_ ~NULL
］
◎
The error getter steps are to return this's error, or null if none.
</p>

<div class="note">
<p>
注記：
~txが中止されたときは、
その事由に応じて，次を返す：
</p>
		<ul>
			<li>
失敗した`要請$に因り`中止-$された場合、
`要請$の`~error$と同じ名前の~error。
</li>
			<li>
~event~handlerから投出された例外に因り`中止-$された場合、
`AbortError$E
</li>
			<li>
`~commit$時の~errorに因り`中止-$された場合、
失敗の事由を反映する~error
— 例えば
`QuotaExceededError$E ／ `ConstraintError$E ／ `UnknownError$E
</li>
		</ul>

<p class="trans-note">【
`abort()$m ~methodに因り`中止-$された場合は、
~NULL が返される。
】</p>

◎
If this transaction was aborted due to a failed request, this will be the same as the request's error. If this transaction was aborted due to an uncaught exception in an event handler, the error will be a "AbortError" DOMException. If the transaction was aborted due to an error while committing, it will reflect the reason for the failure (e.g. "QuotaExceededError", "ConstraintError", or "UnknownError" DOMException).
</div>
</div>

<div class="note domintro">
<dl>
	<dt>%transaction . `objectStore(name)$m</dt>
	<dd>
%transaction の`視野$に入る`名前$Os %name の`保管庫$を`~access先$とする `IDBObjectStore$I を返す。
◎
Returns an IDBObjectStore in the transaction's scope.
</dd>

	<dt>%transaction . `abort()$m</dt>
	<dd>
%transaction を中止する。
処理待ちにあるすべての`要請$は `AbortError$E で失敗し、
接続先~dbに加えられた すべての変更は復帰されることになる。
◎
Aborts the transaction. All pending requests will fail with a "AbortError" DOMException and all changes made to the database will be reverted.
</dd>

	<dt>%transaction . `commit()$m</dt>
	<dd>
~txを~commitしようと試みる。
処理待ちにあるすべての`要請$は完了できるようになるが、
新たな要請は受容されなくなる。
これを利用すれば，~txを素早く完遂するよう強制できる
— ［
~commitしようと試みる前に，処理待ち要請に対し `success$et ~eventが発火されるまで待機する
］通常のふるまいに代えて。
◎
Attempts to commit the transaction. All pending requests will be allowed to complete, but no new requests will be accepted. This can be used to force a transaction to quickly finish, without waiting for pending requests to fire success events before attempting to commit normally.
</dd>
	<dd>
処理待ち要請が
— 例えば拘束~errorに因り —
失敗した場合、
~txは中止される。
成功した要請に対しては，依然として `success$et ~eventは発火されるが、
~event~handler内で例外を投出しても，~txは中止されなくなる。
同様に，失敗した要請に対しても，依然として `error$et ~eventは発火されるが、
`preventDefault()^m を~callしても，~txは中止できない。
◎
The transaction will abort if a pending request fails, for example due to a constraint error. The success events for successful requests will still fire, but throwing an exception in an event handler will not abort the transaction. Similarly, error events for failed requests will still fire, but calling preventDefault() will not prevent the transaction from aborting.
</dd>
</dl>
</div>

<div class="algo">
<p>
`objectStore(name)@m
~method手続きは：
◎
The objectStore(name) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$tx ~EQ `完遂d$i
］
⇒
~THROW `InvalidStateError$E
◎
If this's state is finished, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%保管庫 ~LET 次を満たす`保管庫$
⇒
［
コレの`視野$に入る
］~AND［
`名前$Os ~EQ %name
］
◎
Let store be the object store named name in this's scope,＼
</li>
	<li>
~IF［
%保管庫 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
or throw a "NotFoundError" DOMException if none.
</li>
	<li>
~RET 次を満たすような`保管庫~handle$ %H
⇒＃
%H↗ ~EQ %保管庫,
%H はコレに`専属する$,
`一意性$の要件を満たす
（`可換性$の要件は、
`視野$の構成から自動的に満たされる）
◎
Return an object store handle associated with store and this.
</li>
</ol>

<p class="note">注記：
`一意性$の要件から，返される~instanceは一意に定まる
【~instanceがその前のどの時点で作成されるかは，実装の詳細~になる】
。
よって、
`昇格~tx$の間を除き、
同じ `IDBTransaction$I ~instance上で，同じ %name をこの~methodに渡して返される `IDBObjectStore$I ~instanceは、
常に同じになる。
◎
Each call to this method on the same IDBTransaction instance with the same name returns the same IDBObjectStore instance.
</p>

<p class="note">注記：
%H はコレに`専属する$ので、
他の `IDBTransaction$I ~instanceに対し同じ引数で この~methodを呼出しても， %H と異なる `IDBObjectStore$I ~instanceが返される。
◎
The returned IDBObjectStore instance is specific to this IDBTransaction. If this method is called on a different IDBTransaction, a different IDBObjectStore instance is returned.
</p>

</div>

<div class="algo">
<p>
`abort()@m
~method手続きは：
◎
The abort() method steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$tx ~IN { `~commit中$i, `完遂d$i }
］
⇒
~THROW `InvalidStateError$E
◎
If this's state is committing or finished, then throw an "InvalidStateError" DOMException.
</li>
	<li>
コレの`状態$tx ~SET `非作動中$i
◎
Set this's state to inactive and＼
</li>
	<li>
`~txを中止する$( コレ, ~NULL )
◎
run abort a transaction with this and null.
</li>
</ol>
</div>

<div class="algo">
<p>
`commit()@m
~method手続きは：
◎
The commit() method steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$tx ~NEQ `作動中$i
］
⇒
~THROW `InvalidStateError$E
◎
If this's state is not active, then throw an "InvalidStateError" DOMException.
</li>
	<li>
`~txを~commitする$( コレ )
◎
Run commit a transaction with this.
</li>
</ol>

<p class="advisement">🚧
これは、
この版による新たな~methodである。
Chrome 76, Edge 79, Firefox 74
から~supportされている。
🚧
◎
🚧 The commit() method is new in this edition. It is supported in Chrome 76, Edge 79, and Firefox 74. 🚧
</p>

<p class="note">注記：
`~tx$上でこの~methodを~callすることは、
通常は必要とされない。
~txは、
未決な要請がすべて満たされ，新たな要請は為されていなければ，自動的に~commitされる。
この~callを利用すれば、
未決な`要請$から配送される~eventを待機することなく，`~commit$処理-を開始できる。
◎
It is not normally necessary to call commit() on a transaction. A transaction will automatically commit when all outstanding requests have been satisfied and no new requests have been made. This call can be used to start the commit process without waiting for events from outstanding requests to be dispatched.
</p>
</div>

<p>
`onabort@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `abort$et である。
◎
The onabort attribute is an event handler IDL attribute whose event handler event type is abort.
</p>

<p>
`oncomplete@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `complete$et である。
◎
The oncomplete attribute is an event handler IDL attribute whose event handler event type is complete.
</p>

<p>
`onerror@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `error$et である。
◎
The onerror attribute is an event handler IDL attribute whose event handler event type is error.
</p>

<p class="note">注記：
`~tx$が成功裡に完了したかどうかは、
要請に配送される `success$et ~eventではなく，`~tx$に配送される `complete$et ~eventを~listenして決定すること
— `~tx$は、
`success$et ~eventを発火した後でも失敗し得るので。
◎
To determine if a transaction has completed successfully, listen to the transaction's complete event rather than the success event of a particular request, because the transaction can still fail after the success event fires.
</p>

		</section>
	</section>
	<section id="_algorithms0">
<h2 class="trans-note">X. この訳に特有な各種~algo</h2>

<p class="trans-note">【
この節では、
原文~仕様の各種~API定義に繰り~~返し現れる記述を集約して定義する。
集約~以外にも、
~APIの演算において即時に行われる演算
（失敗した場合は例外が投出される, この節にて述べるもの）と,
`要請$にて非同期に行われる演算（失敗は~eventを通して通知される）
とを区別して，挙動を明快にする目的もある。
【！ 両者が同じ下位~algoを重複して呼出すこともある。】
】</p>

		<section id="_X-Error">
<h3 class="trans-note">X.1. Error( %~error名 )</h3>

<p>
名前 %~error名 の新たな `DOMException$I ~objを<a href="~WEBIDL#dfn-create-exception">作成して</a>返す。
</p>
		</section>
		<section id="_X-CheckState">
<h3 class="trans-note">X.2. 状態を検査する( %O, %要求mode )</h3>

<div class="algo">
<p>
%O を通して［
`保管庫$／`索引$
］に［
~accessし得るかどうか, および演算し得るかどうか
］を検査する：
</p>

<ol>
	<li>
~Assert：
%O は［
`保管庫~handle$／`索引~handle$／`~cursor$
］である
</li>
	<li>
<p>
~IF［
%O は`~cursor$である
］：
</p>
		<ol>
			<li>
%O ~SET %O の`~source$Cs
</li>
			<li>
下の手続きを
`段 A^i, `段 C^i, `段 B^i の順に実行する
</li>
			<li>
~RET
</li>
		</ol>
	</li>
	<li>
`段 A^i：
		<ol>
			<li>
%~tx ~LET %O が`専属する$~tx
</li>
			<li>
~IF［
%要求mode ~EQ `versionchange^l
］~AND［
%~tx は`昇格~tx$でない
］
⇒
~THROW `InvalidStateError$E
◎
If transaction is not an upgrade transaction, throw an "InvalidStateError" DOMException.
</li>
		</ol>
	</li>
	<li>
`段 B^i：
		<ol>
			<li>
~IF［
%O↗ はすでに削除されている
］
⇒
~THROW `InvalidStateError$E
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
</li>
		</ol>
	</li>
	<li>
`段 C^i：
		<ol>
			<li>
~IF［
%~tx の`状態$tx ~NEQ `作動中$i
］
⇒
~THROW `TransactionInactiveError$E
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
			<li>
~IF［
%要求mode ~EQ `readwrite^l
］~AND［
%~tx は`~readonly~tx$である
］
⇒
~THROW `ReadOnlyError$E
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
</li>
		</ol>
	</li>
</ol>
</div>

<p class="trans-note">【
原文では、
`IDBIndex.name$m,
`IDBObjectStore.name$m
の設定子については、
上の手続きを他と異なる順序で検査するように記述されている
（この２つについても互いに異なる
— 単なる誤記かも？）。
詳細は原文を参照されたし。
<a href="~IDBISSUES/11">現実の実装も，上のものと一致するとは限らない</a>
（各~実装, 各~methodごとにまちまちな部分もあるかもしれない）。
】</p>

		</section>
		<section id="_X-Value">
<h3 class="trans-note">X.3. Value( %key )</h3>

<div class="algo">
<p>
所与の［
`~key$／ ε
］を値に変換した結果を返す：
</p>

<ol>
	<li>
~IF［
%key ~EQ ε
］
⇒
~RET `undefined^jv
</li>
	<li>
~RET `~keyを値に変換する$( %key )
</li>
</ol>
</div>

		</section>
		<section id="_X-Key">
<h3 class="trans-note">X.4. Key( %入力 )</h3>

<div class="algo">
<p>
所与の値を`~key$に変換した結果を返すか例外を`投出-$する：
</p>
<ol>
	<li>
%~key ~LET `値を~keyに変換する$( %入力 ) ？
</li>
	<li>
~IF［
%~key ~EQ `妥当でない^i
］
⇒
~THROW `DataError$E
</li>
	<li>
~RET %~key
</li>
</ol>
</div>

		</section>
		<section id="_X-Extract">
<h3 class="trans-note">X.5. Extract( %値, %~key~path, %生成器 )</h3>

<div class="algo">
<p>
所与の
( `値$, `~key~path$, `~key生成器$ )
に対し，［
`~key$ ／ ε
］を返すか例外を`投出-$する：
</p>

<ol>
	<li>
%抽出d~key ~LET `値から~keyを抽出する$ ( %値, %~key~path ) ？
</li>
	<li>
<p>
%抽出d~key に応じて：
</p>
		<dl class="switch">
			<dt>`~key$である</dt>
			<dd>
~RET %抽出d~key
</dd>
			<dt>`妥当でない^i</dt>
			<dd>
~THROW `DataError$E
</dd>
			<dt>`失敗^i</dt>
			<dd>
				<ol>
					<li>
~IF［
%生成器 ~EQ ε
］
⇒
~THROW `DataError$E
</li>
					<li>
~RET ε
</li>
				</ol>
</dd>
		</dl>
◎
Let kpk be the result of extracting a key from a value using a key path with clone and store’s key path. Rethrow any exceptions.
◎
If kpk is invalid, throw a "DataError" DOMException.
◎
If kpk is not failure, let key be kpk.
◎
Otherwise, if the object store does not have a key generator, throw a "DataError" DOMException.
	</li>
</ol>
</div>

		</section>
		<section id="_X-Dispatch">
<h3 class="trans-note">X.6. Dispatch( %標的, %~event )</h3>

<div class="algo">
<p>
%標的 に向けて %~event を配送した上で，真偽値を返す
— この~algoの目的においては、
%~event には真偽値をとる
`（旧来の）~listenerは投出したか@
が結付けられ，初期~時は ~F をとるとする：
</p>
<ol>
	<li>
`~eventを配送する$( %標的, %~event )
</li>
	<li>
~RET %~event の`（旧来の）~listenerは投出したか$
</li>
</ol>
</div>

		</section>
	</section>
	<section id="algorithms">
<h2 title="Algorithms">5. 各種~algo</h2>

		<section id="opening">
<h3 title="Opening a database">5.1. ~dbの~open法</h3>

<div class="algo">
<p>
`~dbを~openする@
ときは、
所与の
( `生成元$ %生成元, `名前$db %名前 `~version$db %~version `~open要請$ %要請 )
に対し，次を走らす：
◎
To open a database with origin which requested the database to be opened, a database name, a database version, and a request, run these steps:
</p>

<ol>
	<li>
%~queue ~LET ( %生成元, %名前 ) に対する`接続~queue$
◎
Let queue be the connection queue for origin and name.
</li>
	<li>
%要請 を %~queue に追加する
◎
Add request to queue.
</li>
	<li>
%~queue 内の %要請 以前の要請すべてが処理されるまで待機する
◎
Wait until all previous requests in queue have been processed.
</li>
	<li>
%~db ~LET %生成元 に`専属する$`~db$のうち，次を満たすもの
⇒
`名前$db ~EQ %名前
◎
Let db be the database named name in origin, or null otherwise.
</li>
	<li>
~IF ［
%~version ~EQ ε
］
⇒
%~version ~SET ［
%~db ~EQ ε ならば 1 ／
~ELSE_ %~db の`~version$db
］
◎
If version is undefined, let version be 1 if db is null, or db’s version otherwise.
</li>
	<li>
<p>~IF ［
%~db ~EQ ε
］：
</p>
		<ol>
			<li>
%~db ~LET 次のようにされた，新たな`~db$
⇒＃
%生成元 に`専属する$,
`名前$db ~SET %名前,
`~version$db ~SET `0^c,
`専属する$`保管庫$はない
</li>
			<li>
~IF［
何らかの事由で前~段は失敗した
］
⇒
~RET `Error$( 適切な~error名 )
— 例えば `QuotaExceededError$E ／ `UnknownError$E
</li>
		</ol>
◎
If db is null, let db be a new database with name name, version 0 (zero), and with no object stores. If this fails for any reason, return an appropriate error (e.g. a "QuotaExceededError" or "UnknownError" DOMException).
</li>
	<li>
~IF［
%~version ~LT %~db の`~version$db
］
⇒
~RET `Error$( `VersionError$E )
◎
If db’s version is greater than version, return a newly created "VersionError" DOMException and abort these steps.
</li>
	<li>
%新~接続 ~LET
%~db を`~access先$とする新たな`接続$
◎
Let connection be a new connection to db.
</li>
	<li>
%新~接続 の`~version$Cn ~SET %~version
◎
Set connection’s version to version.
</li>
	<li>
<p>
~IF ［
%~version ~GT %~db の`~version$db
］：
◎
If db’s version is less than version, then:
</p>
		<ol>
			<li>
%接続~群 ~LET ［
%~db を`~access先$とする`接続$のうち %新~接続 でないもの
］からなる`集合$
◎
Let openConnections be the set of all connections, except connection, associated with db.
</li>
			<li>
<p>
%接続~群 を成す
~EACH( %接続 )
に対し
⇒
~IF［
%接続 の`状態$Cn ~EQ `~open中$i
］
⇒
次を走らす`~taskを~queueする$
⇒
`~version変更~eventを発火する$( %接続, `versionchange$et, %~db の`~version$db, %~version )
◎
For each entry of openConnections that does not have its close pending flag set to true, queue a task to fire a version change event named versionchange at entry with db’s version and version.
</p>

<p class="note" id="_note-open-steps">注記：
この~eventの発火は、
上の反復の途中で，いくつかの接続を`~close$させ得る。
それらの接続に向けては、
まだ終えてなくとも
`versionchange$et ~eventは発火されない。
◎
Firing this event might cause one or more of the other objects in openConnections to be closed, in which case the versionchange event is not fired at those objects, even if that hasn’t yet been done.
</p>
			</li>
			<li>
すべての~eventが発火されるまで待機する
◎
Wait for all of the events to be fired.
</li>
			<li>
~IF［
%接続~群 内に，［
`状態$Cn ~NEQ `~close済み$i
］なる`接続$が依然としてある
］
⇒
次を走らす`~taskを~queueする$
⇒
`~version変更~eventを発火する$( %新~接続, `blocked$et, %~db の`~version$db, %~version )
◎
If any of the connections in openConnections are still not closed, queue a task to fire a version change event named blocked at request with db’s version and version.
</li>
			<li id="version-change-close-block">
%接続~群 を成す すべての`接続$について，［
その`状態$Cn ~EQ `~close済み$i
］になるまで，待機する
◎
Wait until all connections in openConnections are closed.
</li>
			<li>
<p>
`昇格~txを稼働する$( %新~接続, %~version, %要請 )
◎
Run run an upgrade transaction using connection, version and request.
</p>

<p class="trans-note">【
`昇格~tx$が`完遂-$するまで待機した上で
】</p>
				<ul>
					<li>
［
%新~接続 の`状態$Cn ~EQ `~close済み$i
］になったときは
⇒
~RET `Error$( `AbortError$E )
◎
If connection was closed, return a newly created "AbortError" DOMException and abort these steps.
</li>
					<li>
<p>
`昇格~tx$が中止されたときは：
</p>
						<ol>
							<li>
`~db接続を~closeする$( %新~接続 )
</li>
							<li>
~RET `Error$( `AbortError$E )
</li>
						</ol>
◎
If the upgrade transaction was aborted, run the steps to close a database connection with connection, return a newly created "AbortError" DOMException and abort these steps.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
~RET %新~接続
◎
Return connection.
</li>
</ol>
</div>

		</section>
		<section id="closing-connection">
<h3 title="Closing a database">5.2. ~dbの~close法</h3>

<div class="algo">
<p>
`~db接続を~closeする@
ときは、
所与の
( `接続$ %接続, %強制するか ~IN { `強制する^i, ε } )
に対し，次を走らす：
◎
To close a database connection with a connection object, and an optional forced flag, run these steps:
</p>

<!-- 
この手続きは、
IDBDatabase.close()$m
から同期的に呼出されているが，同期的に待機する段がある。
 -->

<ol>
	<li>
%接続 の`状態$Cn ~SET `~close待ち$i
◎
Set connection’s close pending flag to true.
</li>
	<li>
%~tx群 ~LET ［
%接続 に`専属する$`~tx$であって, `完遂-$していないもの
］からなる集合
◎
↓</li>
	<li>
~IF［
%強制するか ~EQ `強制する^i
］
⇒
%~tx群 を成す
~EACH( `~tx$ %~tx )
に対し
⇒
`~txを中止する$( %~tx, `AbortError$E )
◎
If the forced flag is true, then for each transaction created using connection run abort a transaction with transaction and newly created "AbortError" DOMException.
</li>
	<li>
%~tx群 を成す すべての~txが`完遂-$するまで待機する
◎
Wait for all transactions created using connection to complete.＼
</li>
	<li>
%接続 の`状態$Cn ~SET `~close済み$i
◎
Once they are complete, connection is closed.
</li>
	<li>
<p>
~IF
%強制するか ~EQ `強制する^i
⇒
`~eventを発火する$( %接続, `close$et )
◎
If the forced flag is true, then fire an event named close at connection.
</p>

<p class="note">注記：
`close$et ~eventが発火されるのは、
接続が異常に~closeされた場合に限られる
— 例えば：
生成元に対する~storageが~clearされた場合 ／
破損または入出力~errorがあるとき。
明示的に `close()$m を~callした場合には、
この~eventは`発火されない^em。
◎
The close event only fires if the connection closes abnormally, e.g. if the origin’s storage is cleared, or there is corruption or an I/O error. If close() is called explicitly the event does not fire.
</p>
	</li>
</ol>
</div>

<p class="note">注記：
%接続 の`状態$Cnが `~close待ち$i にされて以降は、［
%接続 を利用して，新たな`~tx$を`作成-$する
］ことはできなくなる。
~txを`作成-$する すべての~methodは、
最初に %接続 の`状態$Cnを検査した上で， `~open中$i でないならば例外を投出する。
◎
Once a connection's close pending flag has been set to true, no new transactions can be created using the connection. All methods that create transactions first check the connection's close pending flag first and throw an exception if it is true.
</p>

<p class="note">注記：
`接続$が~closeされたとき、
所与の`~db$への`接続$がすべて~closeされるまで，
<a href="#version-change-close-block">阻まれ</a>,
<a href="#delete-close-block">待機~中</a>にあった［
`昇格~txを稼働する$演算／ `~dbを削除する$演算
］の待機-は、
解かれ得る。
◎
Once the connection is closed, this can unblock the steps to run an upgrade transaction, and the steps to delete a database, which both wait for connections to a given database to be closed before continuing.
</p>
		</section>
		<section id="deleting-a-database">
<h3 title="Deleting a database">5.3. ~dbの削除-法</h3>

<div class="algo">
<p>
`~dbを削除する@
ときは、
所与の
( `生成元$ %生成元, `名前$db %名前, `~open要請$ %要請 )
に対し，次を走らす：
◎
To delete a database with the origin that requested the database to be deleted, a database name, and a request, run these steps:
</p>

<ol>
	<li>
%~queue ~LET ( %生成元, %名前 ) に対する`接続~queue$
◎
Let queue be the connection queue for origin and name.
</li>
	<li>
%要請 を %~queue に追加する
◎
Add request to queue.
</li>
	<li>
%~queue 内の %要請 以前の要請すべてが処理されるまで待機する
◎
Wait until all previous requests in queue have been processed.
</li>
	<li>
%~db ~LET %生成元 に`専属する$`~db$であって, ［
`名前$db ~EQ %名前
］なるもの
◎
Let db be the database named name in origin, if one exists.＼
</li>
	<li>
~IF［
%~db ~EQ ε
］
⇒
~RET 0
◎
Otherwise, return 0 (zero).
</li>
	<li>
%接続~群 ~LET ［
%~db を`~access先$とする`接続$
］のうち［
`状態$Cn ~NEQ `~close済み$i
］を満たすものからなる`集合$
◎
Let openConnections be the set of all connections associated with db.
</li>
	<li>
<p>
%接続~群 を成す
~EACH( %接続 )
に対し
⇒
~IF［
%接続 の`状態$Cn ~EQ `~open中$i
］
⇒
次を走らす`~taskを~queueする$
⇒
~version変更~eventを発火する$( %接続, `versionchange$et, %~db の`~version$db, ~NULL )
◎
For each entry of openConnections that does not have its close pending flag set to true, queue a task to fire a version change event named versionchange at entry with db’s version and null.
</p>

<p class="note">注記：
ここでも，<a href="#_note-open-steps">~dbの~open法と同様の注記</a>
が該当する。
◎
Firing this event might cause one or more of the other objects in openConnections to be closed, in which case the versionchange event is not fired at those objects, even if that hasn’t yet been done.
</p>
	</li>
			<li>
すべての~eventが発火されるまで待機する
◎
Wait for all of the events to be fired.
</li>
			<li>
~IF［
%接続~群 内に［
`状態$Cn ~NEQ `~close済み$i
］なる`接続$は依然としてある
］
⇒
次を走らす`~taskを~queueする$
⇒
`~version変更~eventを発火する$( %要請, `blocked$et, %~db の`~version$db, ~NULL )
◎
If any of the connections in openConnections are still not closed, queue a task to fire a version change event named blocked at request with db’s version and null.
</li>
	<li id="delete-close-block">
%接続~群 を成すすべての`接続$について，［
その`状態$Cn ~EQ `~close済み$i
］になるまで，待機する
◎
Wait until all connections in openConnections are closed.
</li>
	<li>
%~version ~LET %~db の`~version$db
◎
Let version be db’s version.
</li>
	<li>
%~db を削除する
◎
Delete db.＼
</li>
	<li>
~IF［
何らかの事由で前~段は失敗した
］
⇒
~RET `Error$( 適切な~error名 )
— 例えば `QuotaExceededError$E ／ `UnknownError$E
◎
If this fails for any reason, return an appropriate error (e.g. "QuotaExceededError" or "UnknownError" DOMException).
</li>
	<li>
~RET %~version
◎
Return version.
</li>
</ol>
</div>

		</section>
		<section id="commit-transaction">
<h3 title="Committing a transaction">5.4. ~txの~commit法</h3>

<div class="algo">
<p>
`~txを~commitする@
ときは、
所与の
( `~tx$ %~tx )
に対し，次を走らす：
◎
To commit a transaction with the transaction to commit, run these steps:
</p>

<ol>
	<li>
%~tx の`状態$tx ~SET `~commit中$i
◎
Set transaction’s state to committing.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~tx の`要請~list$を成す すべての~itemが`処理-済み$になるまで待機する
◎
Wait until every item in transaction’s request list is processed.
</li>
			<li>
~IF［
%~tx の`状態$tx ~NEQ `~commit中$i
］
⇒
~RET
◎
If transaction’s state is no longer committing, then terminate these steps.
</li>
			<li>
%~db ~LET ( %~tx が`専属する$`接続$ )↗
◎
↓</li>
			<li>
%~tx により為された未決な変更のすべてを
— %~tx の`耐久能~hint$も考慮する下で —
%~db に書込もうと試みる
◎
Attempt to write any outstanding changes made by transaction to the database, considering transaction’s durability hint.
</li>
			<li>
<p>
~IF［
前~段により書込む間に~errorが生じた
］：
◎
If an error occurs while writing the changes to the database, then＼
</p>
				<ol>
					<li>
`~txを中止する$( %~tx, その~errorに適切な~error名
（例： `QuotaExceededError$E ／ `UnknownError$E ） )
◎
run abort a transaction with transaction and an appropriate type for the error, for example "QuotaExceededError" or "UnknownError" DOMException,＼
</li>
					<li>
~RET
◎
and terminate these steps.
</li>
				</ol>
			</li>
			<li>
<p>
次を走らす`~taskを~queueする$：
◎
Queue a task to run these steps:
</p>
				<ol>
					<li>
~IF［
%~tx は`昇格~tx$である
］
⇒
%~db の`昇格~tx$db ~SET ε
◎
If transaction is an upgrade transaction, then set transaction’s connection's associated database's upgrade transaction to null.
</li>
					<li>
%~tx の`状態$tx ~SET `完遂d$i
◎
Set transaction’s state to finished.
</li>
					<li>
<p>
`~eventを発火する$( %~tx, `complete$et )
◎
Fire an event named complete at transaction.
</p>

<p class="note">注記：
この~event用の~event~handlerから例外が投出されようが、
~db変更の書込みは~eventを配送する前に終わるので，~txは~commitされる。
`complete$et ~eventが発火されるのは、
~txが成功裡に書込まれた後に限られる。
◎
Even if an exception is thrown from one of the event handlers of this event, the transaction is still committed since writing the database changes happens before the event takes places. Only after the transaction has been successfully written is the complete event fired.
</p>
					</li>
					<li>
~IF［
%~tx は`昇格~tx$である
］
⇒
［
%~tx を`設置-先~tx$とする`要請$
（すなわち、
`昇格~txを稼働する$手続きに渡された %要請 ）
］の`設置-先~tx$ ~SET ε
◎
If transaction is an upgrade transaction, then let request be the request associated with transaction and set request’s transaction to null.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<p class="trans-note">【
`~readonly~tx$に対しては、
この手続きは
（特に呼出さないようにする要件は見当たらないが）
実質的に何もしない。
】</p>

</div>

		</section>
		<section id="abort-transaction">
<h3 title="Aborting a transaction">5.5. ~txの中止-法</h3>

<div class="algo">
<p>
`~txを中止する@
ときは、
所与の
( `~tx$ %~tx, ~error名 %error )
に対し，次を走らす：
◎
To abort a transaction with the transaction to abort, and error, run these steps:
</p>

<ol>
	<li>
%~db ~LET ( %~tx が`専属する$`接続$ )↗
◎
↓</li>
	<li>
<p>
%~tx により %~db に為された，すべての変更を、
復帰させる
— `昇格~tx$に対しては：
</p>

		<ul>
			<li>
%~db に`専属する$［
`保管庫$／`索引$
］たちの集合, および`~version$dbの変更も，復帰させる。
</li>
			<li>
%~tx の間に作成された［
`保管庫$／`索引$
］は、
他の~algoの目的においては，削除されたものと見なされる。
</li>
		</ul>
◎
All the changes made to the database by the transaction are reverted. For upgrade transactions this includes changes to the set of object stores and indexes, as well as the change to the version. Any object stores and indexes which were created during the transaction are now considered deleted for the purposes of other algorithms.
</li>
	<li>
<p>
~IF［
%~tx は`昇格~tx$である
］
⇒
`昇格~txを中止する$( %~tx )
◎
If transaction is an upgrade transaction, run the steps to abort an upgrade transaction with transaction.
</p>

<p class="note">注記：
この結果、［
%~tx が`専属する$`接続$ ／ %~tx に`専属する$［
`保管庫~handle$ ／ `索引~handle$
］］すべての~instanceに対する変更は復帰されることになる。
◎
This reverts changes to all connection, object store handle, and index handle instances associated with transaction.
</p>

	</li>
	<li>
%~tx の`状態$tx ~SET `完遂d$i
◎
Set transaction’s state to finished.
</li>
	<li>
~IF［
%error ~NEQ ~NULL
］
⇒
%~tx の`~error$tx ~SET `Error$( %error )
◎
If error is not null, set transaction’s error to error.
</li>
	<li>
<p>
%~tx の`要請~list$を成す
~EACH( `要請$ %要請 )
に対し：
◎
For each request of transaction’s request list,＼
</p>
		<ol>
			<li>
%要請 を`非同期に実行する$手続きを中止する
◎
abort the steps to asynchronously execute a request for request,＼
</li>
			<li>
%要請 の`処理-済みか$ ~SET ~T
◎
set request’s processed flag to true,＼
</li>
			<li>
<p>
次を走らす`~taskを~queueする$：
◎
and queue a task to run these steps:
</p>
				<ol>
					<li>
%要請 の
⇒＃
`済んだか$ ~SET ~T,
`結果$ ~SET ε,
`~error$ ~SET `Error$( `AbortError$E )
◎
Set request’s done flag to true.
◎
Set request’s result to undefined.
◎
Set request’s error to a newly created "AbortError" DOMException.
</li>
					<li>
`~eventを発火する$( %要請, `error$et )
— 次のように初期化して
⇒＃
`bubbles$m 属性 ~SET ~T,
`cancelable$m 属性 ~SET ~T
◎
Fire an event named error at request with its bubbles and cancelable attributes initialized to true.
</li>
				</ol>

<p class="note">注記：
これは常に `error$et ~eventを発火させるとは限らない。
例えば~txが `~commit中$i の間に~errorに因り中止された場合や，それは失敗した最後の残りの要請であった場合 【？】。
◎
This does not always result in any error events being fired. For example if a transaction is aborted due to an error while committing the transaction, or if it was the last remaining request that failed.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
次を走らす`~taskを~queueする$：
◎
Queue a task to run these steps:
</p>
		<ol>
			<li>
~IF［
%~tx は`昇格~tx$である
］
⇒
%~db の`昇格~tx$db ~SET ε
◎
If transaction is an upgrade transaction, then set transaction’s connection's associated database's upgrade transaction to null.
</li>
			<li>
`~eventを発火する$( %~tx, `abort$et )
— 次のように初期化して
⇒
`bubbles$m 属性 ~SET ~T
◎
Fire an event named abort at transaction with its bubbles attribute initialized to true.
</li>
			<li>
<p>
~IF［
%~tx は`昇格~tx$である
］：
◎
If transaction is an upgrade transaction, then:
</p>
				<ol>
					<li>
%要請 ~LET %~tx を`設置-先~tx$とする`~open要請$
（すなわち、
`昇格~txを稼働する$手続きに渡された %要請 ）
◎
Let request be the open request associated with transaction.
</li>
					<li>
%要請 の
⇒＃
`設置-先~tx$ ~SET ε,
`結果$ ~SET ε,
`処理-済みか$ ~SET ~F,
`済んだか$ ~SET ~F
◎
Set request’s transaction to null.
◎
Set request’s result to undefined.
◎
Set request’s processed flag to false.
◎
Set request’s done flag to false.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="async-execute-request">
<h3 title="Asynchronously executing a request">5.6. 要請の非同期的な実行-法</h3>

<div class="algo">
<div>
<p>
所与の
( ~db上で遂行される`演算$ %演算 )
を走らす
`要請を非同期に実行する@
ときは、
所与の
( ［ `保管庫~handle$／`索引~handle$ ］ %~source, `要請$ %要請 （省略時は ε ） )
に対し，次の手続きを走らす
— この手続きは：
</p>
<ul>
	<li>
%要請 が省略された場合、
新たな`要請$を作成して返す。
</li>
	<li>
当の`要請$の`設置-先~tx$が`~txを中止-$する手続きを利用して`中止-$された場合、
いつでも中止され得る
</li>
</ul>
◎
To asynchronously execute a request with the source object and an operation to perform on a database, and an optional request, run these steps:
◎
These steps can be aborted at any point if the transaction the created request belongs to is aborted using the steps to abort a transaction.
</div>
<ol>
	<li>
%~tx ~LET %~source が`専属する$`~tx$
◎
Let transaction be the transaction associated with source.
</li>
	<li>
~Assert：
%~tx の`状態$tx ~EQ `作動中$i
◎
Assert: transaction’s state is active.
</li>
	<li>
~IF［
%要請 ~EQ ε
］
⇒
%要請 ~SET `要請$を表現する，新たな `IDBRequest$I ~obj
— その
⇒＃
`~source$ ~SET %~source,
`設置-先~tx$ ~SET %~tx
◎
If request was not given, let request be a new request with source as source.
</li>
	<li>
%~tx の`要請~list$に %要請 を追加する
◎
Add request to the end of transaction’s request list.
</li>
	<li>
~RET %要請
— ただし，以降も`並列的$に走らす
◎
Run these steps in parallel:
</li>
	<li>
次が満たされるまで待機する
⇒
%要請 は［
%~tx の`要請~list$を成す`処理-済み$である~item
］のうち最初のものである
◎
Wait until request is the first item in transaction’s request list that is not processed.
</li>
	<li>
%結果 ~LET %演算 を遂行した結果
◎
Let result be the result of performing operation.
</li>
	<li>
~IF［
%結果 は~errorである
］~AND［
%~tx の`状態$tx ~EQ `~commit中$i
］
⇒＃
`~txを中止する$( %~tx, %結果 )；
~RET
◎
If result is an error and transaction’s state is committing, then run abort a transaction with transaction and result, and terminate these steps.
</li>
	<li>
<p>
~IF［
%結果 は~errorである
］
⇒
%演算 により生じたすべての変更を復帰する
◎
If result is an error, then revert all changes made by operation.
</p>

<p class="note">注記：
これは、
この要請により行われた変更のみを復帰させる。
~txにより為された他の変更は復帰されない。
◎
This only reverts the changes done by this request, not any other changes made by the transaction.
</p>
	</li>
	<li>
%要請 の`処理-済みか$ ~SET ~T
◎
Set request’s processed flag to true.
</li>
	<li>
<p>
次を走らす`~taskを~queueする$：
◎
Queue a task to run these steps:
</p>
		<ol>
			<li>
%~tx の`要請~list$から %要請 を除去する
◎
Remove request from transaction’s request list.
</li>
			<li>
<p>
%要請 の
⇒＃
`済んだか$ ~SET ~T,
`結果$ ~SET ε,
`~error$ ~SET ε
◎
Set request’s done flag to true.
◎
↓</li>
			<li>
<p>
~IF［
%結果 は~errorである
］：
◎
If result is an error, then:
</p>
				<ol>
					<li>
%要請 の`~error$ ~SET %結果
◎
Set request’s result to undefined.
◎
Set request’s error to result.
</li>
					<li>
`~error~eventを発火する$( %要請 )
◎
Fire an error event at request.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%要請 の`結果$ ~SET %結果
◎
Set request’s result to result.
◎
Set request’s error to undefined.
</li>
					<li>
`~success~eventを発火する$( %要請 )
◎
Fire a success event at request.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

<p>
◎
↑↑Return request.
</p>

		</section>
		<section id="upgrade-transaction-steps">
<h3 title="Running an upgrade transaction">5.7. 昇格~txの稼働-法</h3>

<div class="algo">
<p>
`昇格~txを稼働する@
ときは、
所与の
( `接続$ %接続, %~version `要請$ %要請 )
に対し，次に従う
（ %接続 は`~db$を更新するために利用され，
%~version は~dbに設定する新たな~versionを与える）：
◎
To run an upgrade transaction with connection (a connection) which is used to update the database, a new version to be set for the database, and a request, run these steps:
</p>
<ol>
	<li>
%~db ~LET %接続↗
◎
Let db be connection’s database.
</li>
	<li>
%~tx ~LET 新たな`昇格~tx$
— その
⇒＃
`専属する$`接続$ ~SET %接続,
`視野$ ~SET %接続 の`保管庫~集合$Cn
◎
Let transaction be a new upgrade transaction with connection used as connection.
◎
Set transaction’s scope to connection’s object store set.
</li>
	<li>
%~db の`昇格~tx$db ~SET %~tx
◎
Set db’s upgrade transaction to transaction.
</li>
	<li>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</li>
	<li>
<p>
%~tx を開始する
◎
Start transaction.
</p>

<p class="note">注記：
この`~tx$が`完遂-$するまで，他の`接続$は %~db を~openできないことに注意。
◎
Note that until this transaction is finished, no other connections can be opened to the same database.
</p>
	</li>
	<li>
%旧~version ~LET %~db の`~version$db
◎
Let old version be db’s version.
</li>
	<li>
%~db の`~version$db ~SET %~version
—
この変更は，`~tx$の一部と見なされ、
~txが`中止-$された場合には復帰される。
◎
Set db’s version to version. This change is considered part of the transaction, and so if the transaction is aborted, this change is reverted.
</li>
	<li>
%要請 の`処理-済みか$ ~SET ~T
◎
Set request’s processed flag to true.
</li>
	<li>
<p>
次を走らす`~taskを~queueする$：
◎
Queue a task to run these steps:
</p>
		<ol>
			<li>
%要請 の`結果$ ~SET %接続
◎
Set request’s result to connection.
</li>
			<li>
%要請 の`設置-先~tx$ ~SET %~tx
◎
Set request’s transaction to transaction.
</li>
			<li>
%要請 の`済んだか$ ~SET ~T
◎
Set request’s done flag to true.
</li>
			<li>
%~tx の`状態$tx ~SET `作動中$i
◎
Set transaction’s state to active.
</li>
			<li>
%~listenerは投出したか ~LET
`~version変更~eventを発火する$( %要請, `upgradeneeded$et, %旧~version, %~version )
◎
Let didThrow be the result of firing a version change event named upgradeneeded at request with old version and version.
</li>
			<li>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</li>
			<li>
~IF［
%~listenerは投出したか ~EQ ~T
］
⇒
`~txを中止する$( %~tx, `AbortError$E )
◎
If didThrow is true, run abort a transaction with transaction and a newly created "AbortError" DOMException.
</li>
		</ol>
	</li>
	<li>
<p>
%~tx が`完遂-$するまで待機する
◎
Wait for transaction to finish.
</p>

<p class="note">注記：
［
`~txを~commitする$／
`~txを中止する$
］手続きなど，~txの存続期間に呼出される一部の~algoは、
`昇格~tx$に特有な手続きを含む。
◎
Some of the algorithms invoked during the transaction's lifetime, such as the steps to commit a transaction and the steps to abort a transaction, include steps specific to upgrade transactions.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="abort-upgrade-transaction">
<h3 title="Aborting an upgrade transaction">5.8. 昇格~txの中止-法</h3>

<div class="algo">
<p>
`昇格~txを中止する@
ときは、
所与の
( `昇格~tx$ %~tx  )
に対し，次を走らす：
◎
To abort an upgrade transaction with transaction, run these steps:
</p>

<p class="note">注記：
この手続きは，`~txを中止-$する手続き内で必要に応じて走らされ、
`~db$に`専属する$［
`保管庫$／`索引$
］たちの集合, および
`~version$db変更を復帰させる。
【~APIに公開される部分を復帰させる。】
◎
These steps are run as needed by the steps to abort a transaction, which revert changes to the database including the set of associated object stores and indexes, as well as the change to the version.
</p>

<ol>
	<li>
%接続 ~LET %~tx が`専属する$`接続$
◎
Let connection be transaction’s connection.
</li>
	<li>
%~db ~LET %接続↗
◎
Let database be connection’s database.
</li>
	<li>
<p>
%接続 の`~version$Cn ~SET %~db の`~version$db
（ %~tx が %~db を新たに作成したのであれば 0 ）
◎
Set connection’s version to database’s version if database previously existed, or 0 (zero) if database was newly created.
</p>

<p class="note">注記：
これは、
`IDBDatabase!I ~objから返される `version$m 値を復帰させる。
◎
This reverts the value of version returned by the IDBDatabase object.
</p>

	</li>
	<li>
<p>
%接続 の`保管庫~集合$Cn ~SET %~db に`専属する$`保管庫$の集合
（ %~tx が %~db を新たに作成したのであれば 空~集合 ）
◎
Set connection’s object store set to the set of object stores in database if database previously existed, or the empty set if database was newly created.
</p>

<p class="note">注記：
これは、
`IDBDatabase!I ~objから返される `objectStoreNames$m 値を復帰させる。
◎
This reverts the value of objectStoreNames returned by the IDBDatabase object.
</p>
	</li>
	<li>
<p>
この段において反復される~handleたちには、
その`~access先$が %~tx により削除-または作成されたものも含まれることに注意。
◎
↓</p>

<p>
%~tx に`専属する$
~EACH( `保管庫~handle$ %H )
に対し：
◎
For each object store handle handle associated with transaction, including those for object stores that were created or deleted during transaction:
</p>
		<ol>
			<li>
~IF［
%H↗ は %~tx により作成されたものではない
］
⇒
%H の`名前$OsH ~SET %H↗ の`名前$Os
◎
If handle’s object store was not newly created during transaction, set handle’s name to its object store's name.
</li>
			<li>
<p>
%H の`索引~集合$OsH ~SET %H↗ に`専属する$`索引$たちの集合
◎
Set handle’s index set to the set of indexes that reference its object store.
</p>

<div class="note">
<p>注記：
これは、
%H （を表現する `IDBObjectStore!I ~obj）が返す［
`name$m, `indexNames$m
］値を復帰させる。
◎
This reverts the values of name and indexNames returned by related IDBObjectStore objects.
</p>

<p>
~scriptは、
%~tx が中止されて以降も，依然として自身が持つ %H の［
`name$m ／ `indexNames$m
］属性は~queryできる
— %~tx の
<!-- `IDBTransaction!I -->`objectStore()$m ~methodを利用しても， %H↗ には~accessできなくなるが。
◎
How is this observable?
◎
Although script cannot access an object store by using the objectStore() method on an IDBTransaction instance after the transaction is aborted, it can still have references to IDBObjectStore instances where the name and indexNames properties can be queried.
</p>
</div>
			</li>
			<li>
<p>
%H に`専属する$
~EACH( `索引~handle$ %I )
に対し：
◎
For each index handle handle associated with transaction, including those for indexes that were created or deleted during transaction:
</p>
		<ol>
			<li>
~IF［
%I↗ は %~tx により作成されたものではない
］
⇒
%I の`名前$IxH ~SET %I↗ の`名前$Ix
◎
If handle’s index was not newly created during transaction, set handle’s name to its index's name.
</li>
		</ol>

<div class="note">

<p>注記：
これは、
%I （を表現する `IDBIndex!I ~obj）が返す `name$m 値を復帰させる。
◎
This reverts the value of name returned by related IDBIndex objects.
</p>

<p>
~scriptは、
%~tx が中止されて以降も，自身が持つ %I の `name$m 属性は~queryできる
— %H の
<!-- `IDBObjectStore!I -->`index()$m ~methodを利用しても， %I↗ には~accessできなくなるが。
◎
How is this observable?
◎
Although script cannot access an index by using the index() method on an IDBObjectStore instance after the transaction is aborted, it can still have references to IDBIndex instances where the name property can be queried.
</p>
</div>
			</li>
		</ol>
	</li>
</ol>
</div>

<p class="note">注記：
［
%接続 を表現する `IDBDatabase!I ~instance
］の `name$m は、
中止された`昇格~tx$が新たな`~db$を作成していたとしても，`値を保持し続ける$。
◎
The name property of the IDBDatabase instance is not modified, even if the aborted upgrade transaction was creating a new database.
</p>

		</section>
		<section id="fire-success-event">
<h3 title="Firing a success event">5.9. `success^et ~eventの発火-法</h3>

<div class="algo">
<p>
`~success~eventを発火する@
ときは、
所与の
( `要請$ %要請 )
に対し，次を走らす：
◎
To fire a success event at a request, run these steps:
</p>

<ol>
	<li>
%~event ~LET `~eventを作成する$( `Event$I )
◎
Let event be the result of creating an event using Event.
</li>
	<li>
%~event の各種~属性を次のように初期化する
⇒＃
`type$m ~SET `success^l,
`bubbles$m ~SET ~F,
`cancelable$m ~SET ~F
◎
• Set event’s type attribute to "success".
• Set event’s bubbles and cancelable attributes to false.
</li>
	<li>
%~tx ~LET %要請 の`設置-先~tx$
◎
Let transaction be request’s transaction.
◎
↓Let legacyOutputDidListenersThrowFlag be initially false.
</li>
	<li>
~IF［
%~tx の`状態$tx ~EQ `非作動中$i
］
⇒
%~tx の`状態$tx ~SET `作動中$i
◎
If transaction’s state is inactive, then set transaction’s state to active.
</li>
	<li>
%~listenerは投出したか ~LET `Dispatch$( %要請, %~event )
◎
Dispatch event at request with legacyOutputDidListenersThrowFlag.
</li>
	<li>
~IF［
%~tx の`状態$tx ~NEQ `作動中$i
］
⇒
~RET
◎
If transaction’s state is active, then:
</li>
	<li>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</li>
	<li>
~IF［
%~listenerは投出したか ~EQ ~T
］
⇒
`~txを中止する$( %~tx, `AbortError$E )
◎
If legacyOutputDidListenersThrowFlag is true, then run abort a transaction with transaction and a newly created "AbortError" DOMException.
</li>
	<li>
~IF［
%~tx の`要請~list$は空である
］
⇒
`~txを~commitする$( %~tx )
◎
If transaction’s request list is empty, then run commit a transaction with transaction.
</li>
</ol>
</div>

		</section>
		<section id="fire-error-event">
<h3 title="Firing an error event">5.10. `error^et ~eventの発火-法</h3>

<div class="algo">
<p>
`~error~eventを発火する@
ときは、
所与の
( `要請$ %要請 )
に対し，次を走らす：
◎
To fire an error event at a request, run these steps:
</p>

<ol>
	<li>
%~event ~LET `~eventを作成する$( `Event$I )
◎
Let event be the result of creating an event using Event.
</li>
	<li>
%~event の各種~属性を次のように初期化する
⇒＃
`type$m ~SET `error^l,
`bubbles$m ~SET ~T,
`cancelable$m ~SET ~T
◎
• Set event’s type attribute to "error".
• Set event’s bubbles and cancelable attributes to true.
</li>
	<li>
%~tx ~LET %要請 の`設置-先~tx$
◎
Let transaction be request’s transaction.
◎
↓Let legacyOutputDidListenersThrowFlag be initially false.
</li>
	<li>
~IF［
%~tx の`状態$tx ~EQ `非作動中$i
］
⇒
%~tx の`状態$tx ~SET `作動中$i
◎
If transaction’s state is inactive, then set transaction’s state to active.
</li>
	<li>
%~listenerは投出したか ~LET `Dispatch$( %要請, %~event )
◎
Dispatch event at request with legacyOutputDidListenersThrowFlag.
</li>
	<li>
~IF［
%~tx の`状態$tx ~NEQ `作動中$i
］
⇒
~RET
◎
If transaction’s state is active, then:
</li>
	<li>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</li>
	<li>
<p>
~IF［
%~listenerは投出したか ~EQ ~T
］：
◎
If legacyOutputDidListenersThrowFlag is true, then＼
</p>
		<ol>
			<li>
`~txを中止する$( %~tx, `AbortError$E )
◎
run abort a transaction with transaction and a newly created "AbortError" DOMException and＼
</li>
			<li>
~RET
◎
terminate these steps.＼
</li>
		</ol>
<p>
この段は、［
%~event の`取消されたか$ev ~EQ ~F
］の下でも行われる。
◎
This is done even if event’s canceled flag is false.
</p>

<div class="note">
<p>注記：
すなわち、
`error$et ~eventの配送-時に，いずれかの~event~handlerから例外が投出されたときは：
</p>
		<ul>
			<li>
~eventが `preventDefault()$m の~callにより取消されようが されまいが，~txは中止される。
</li>
			<li>
~tx上の `error^m 属性には、
要請の`~error$に代わって， `AbortError$E が利用される。
</li>
		</ul>
◎
This means that if an error event is fired and any of the event handlers throw an exception, transaction’s error property is set to an AbortError rather than request’s error, even if preventDefault() is never called.
</div>
	</li>
	<li>
~IF［
%~event の`取消されたか$ev ~EQ ~F
］
⇒＃
`~txを中止する$( %~tx, %要請 の`~error$ )；
~RET
◎
If event’s canceled flag is false, then run abort a transaction using transaction and request's error, and terminate these steps.
</li>
	<li>
~IF［
%~tx の`要請~list$は空である
］
⇒
`~txを~commitする$( %~tx )
◎
If transaction’s request list is empty, then run commit a transaction with transaction.
</li>
</ol>
</div>

		</section>
		<section id="clone-value">
<h3 title="Clone a value">5.11. 値の~clone法</h3>

<div class="algo">
<p>
`~txの間に値を~cloneする@
ときは、
所与の
( %値, `~tx$ %~tx )
に対し，次を走らす：
◎
To make a clone of value in targetRealm during transaction, run these steps:
</p>

<p class="note">注記：
値を複製するわけは：
値は格納-時に【 `StructuredSerializeForStorage$jA により】直列化されるが，この手続きを用いて複製として扱うことにより、
この仕様~内の他の~algoは，それを~ES値として扱えるようになる。
実装は、
異なる挙動が観測され得ないならば，これを最適化できる。
【！ https://github.com/w3c/IndexedDB/commit/4ccf4371e3e1a32a6f3ab1606605e71a8f4f8334】
<!-- 
Let targetRealm be a user-agent defined Realm.
Let clone be a clone of value in targetRealm during transaction. Rethrow any exceptions.
Why create a copy of the value?
• The value is serialized when stored. Treating it as a copy here allows other algorithms in this specification to treat it as an ECMAScript value, but implementations can optimize this if the difference in behavior is not observable.
 -->
</p>

<ol>
	<li>
%宛先~Realm ~LET ~UAにより定義される`~Realm$
【この訳では、この手続きを利用している各所の記述を集約するため，この段と上の注記をここに追加している。】
</li>
	<li>
~Assert：
%~tx の`状態$tx ~EQ `作動中$i
◎
Assert: transaction’s state is active.
</li>
	<li>
<p>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</p>

<p class="note">注記：
%~tx を `非作動中$i にするのは、
~cloneする演算により誘発される取得子その他の副作用が，
%~tx に対し追加の要請を為せないようにするためである。
◎
The transaction is made inactive so that getters or other side effects triggered by the cloning operation are unable to make additional requests against the transaction.
</p>
	</li>
	<li>
%直列形 ~LET ~ABRUPT `StructuredSerializeForStorage$jA( %値 )
◎
Let serialized be ? StructuredSerializeForStorage(value).
</li>
	<li>
%~clone ~LET ~ABRUPT `StructuredDeserialize$jA( %直列形, %宛先~Realm )
◎
Let clone be ? StructuredDeserialize(serialized, targetRealm).
</li>
	<li>
%~tx の`状態$tx ~SET `作動中$i
◎
Set transaction’s state to active.
</li>
	<li>
~RET %~clone
◎
Return clone.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="database-operations">
<h2 title="Database operations">6. 各種~db演算</h2>

<p>
この節では、［
`保管庫$内の~data／`~db$内の`索引$
］にて行われる各種 演算について述べる。
これらの演算は、
`要請を非同期に実行する$ことにより走ることになる。
◎
This section describes various operations done on the data in object stores and indexes in a database. These operations are run by the steps to asynchronously execute a request.
</p>

<p class="note">注記：
以下の各種 演算の手続きにおける `StructuredDeserialize$jA() からは、
（ `~NOABRUPT$ 接頭辞で指示されるように）例外は投出されない
— 演算する~dataは、
`StructuredSerializeForStorage$jA() から出力されたものに限られるので。
◎
Invocations of StructuredDeserialize() in the operation steps below can be asserted not to throw (as indicated by the ! prefix) because they operate only on previous output of StructuredSerializeForStorage().
</p>

		<section id="object-store-storage-operation">
<h3 title="Object store storage operation">6.1. 保管庫における~storage演算</h3>

<div class="algo">
<p>
`保管庫に~recordを格納する@
ときは、
所与の
( `保管庫$ %保管庫, `値$ %値, `~key$ %~key（省略時は ε ）, %上書不可か ~IN { `上書不可^i, ε } )
に対し，次を走らす：
◎
To store a record into an object store with store, value, an optional key, and a no-overwrite flag, run these steps:
</p>

<ol>
	<li>
%生成器 ~LET %保管庫 の`~key生成器$
◎
↓</li>
	<li>
%~key~path ~LET %保管庫 の`~key~path$Os
◎
↓</li>
	<li>
<p>
~IF［
%生成器 ~NEQ ε
］：
◎
If store uses a key generator, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~key ~EQ ε
］：
◎
If key is undefined, then:
</p>
				<ol>
					<li>
%~key ~LET `保管庫~用の~keyを生成する$( %保管庫 )
◎
Let key be the result of generating a key for store.
</li>
					<li>
~IF［
%~key ~EQ `失敗^i
］
⇒
~RET `Error$( `ConstraintError$E )
◎
If key is failure, then this operation failed with a "ConstraintError" DOMException. Abort this algorithm without taking any further steps.
</li>
					<li>
~IF［
%~key~path ~NEQ ε
］
⇒
`~keyを値の中へ注入する$( %値, %~key, %保管庫 の`~key~path$Os )
◎
If store also uses in-line keys, then run inject a key into a value using a key path with value, key and store’s key path.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
`保管庫~用の~key生成器を可能なら更新する$( %保管庫, %~key )
◎
Otherwise, run possibly update the key generator for store with key.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%保管庫 の`~record~list$Os内に［
`~key$ ~EQ~cmpkey %~key
］を満たす`~record$は在る
］
◎
↓</p>
		<ol>
			<li>
~IF［
%上書不可か ~EQ `上書不可^i
］
⇒
~RET `Error$( `ConstraintError$E )
◎
If the no-overwrite flag was given to these steps and is true, and a record already exists in store with its key equal to key, then this operation failed with a "ConstraintError" DOMException. Abort this algorithm without taking any further steps.
</li>
			<li>
`保管庫から~recordを削除する$( %保管庫, `Only$( %~key ) )
◎
If a record already exists in store with its key equal to key, then remove the record from store using delete records from an object store.
</li>
		</ol>
	</li>
	<li>
%保管庫 の`~record~list$Osに
~record｛ %~key ： ~NOABRUPT `StructuredSerializeForStorage$jA( %値 ) ｝
を格納する
— それに伴い，~listの~recordたちを~keyの`昇順$で~sortし直すことになる。
◎
Store a record in store containing key as its key and ! StructuredSerializeForStorage(value) as its value. The record is stored in the object store’s list of records such that the list is sorted according to the key of the records in ascending order.
</li>
	<li>
<p>
%保管庫 に`専属する$
~EACH( `索引$ %索引 )
に対し：
◎
For each index which references store:
</p>
		<ol>
			<li>
%~key集合 ~LET
`値から~key集合を抽出する$( %値,  %索引 の`~key~path$Ix, %索引 の`複-~entryか$Ix )
◎
Let index key be the result of extracting a key from a value using a key path with value, index’s key path, and index’s multiEntry flag.
</li>
			<li>
~IF［
%~key集合 ~EQ `失敗^i
］
⇒
~CONTINUE
◎
If index key is an exception, or invalid, or failure, take no further actions for index, and continue these steps for the next index.
◎
An exception thrown in this step is not rethrown.
</li>
			<li>
<p>
~IF［
%索引 の`一意か$Ix ~EQ ~T
］~AND［
%索引 の`~record~list$Ix内に［
`~key$ ~IN~cmpkey %~key集合
］を満たす`~record$は在る
］
⇒
~RET `Error$( `ConstraintError$E )
◎
If index’s multiEntry flag is false, or if index key is not an array key, and if index already contains a record with key equal to index key, and index’s unique flag is true, then this operation failed with a "ConstraintError" DOMException. Abort this algorithm without taking any further steps.
◎
If index’s multiEntry flag is true and index key is an array key, and if index already contains a record with key equal to any of the subkeys of index key, and index’s unique flag is true, then this operation failed with a "ConstraintError" DOMException. Abort this algorithm without taking any further steps.
</p>

<p class="trans-note">【
この手続きを呼び出した要請は失敗とされ、
`要請を非同期に実行する$手続きに従って，ここまでの改変は復帰されることになる。
したがって、
索引たちを反復する順序も，結果には影響しない。
】</p>

			</li>
			<li>
<p>
%~key集合 を成す
~EACH( %索引~key )
に対し
⇒
%索引 の`~record~list$Ix内に
新たな~record｛ %索引~key ： %~key ｝
を格納する
— それに伴い、
~record~listは 先ず~keyの`昇順$に~sortした上で，~keyが等しい~recordたちを値の`昇順$に~sortすることになる。
◎
If index’s multiEntry flag is false, or if index key is not an array key then store a record in index containing index key as its key and key as its value. The record is stored in index’s list of records such that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending order.
◎
If index’s multiEntry flag is true and index key is an array key, then for each subkey of the subkeys of index key store a record in index containing subkey as its key and key as its value. The records are stored in index’s list of records such that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending order.
</p>

<p class="note">注記：
%~key集合 が空でも妥当である
— その場合、
索引に追加される~recordはない。
◎
It is valid for there to be no subkeys. In this case no records are added to the index.
◎
Even if any member of subkeys is itself an array key, the member is used directly as the key for the index record. Nested array keys are not flattened or "unpacked" to produce multiple rows; only the outer-most array key is.
</p>

			</li>
		</ol>
【この段の訳は、再構成により，原文より簡素化している（`値から~key集合を抽出する$を見よ）。】

	</li>
	<li>
~RET %~key
◎
Return key.
</li>
</ol>
</div>

		</section>
		<section id="_retrieval-operations">
<h3 title="(Object store|index) retrieval operations">6.2.／6.3. 保管庫／索引から検索取得する演算</h3>

【！ Object Store Retrieval Operations 】
【！ Index Retrieval Operations 】
<a id="object-store-retrieval-operations"></a>
<a id="index-retrieval-operation"></a>

<p class="trans-note">【
この訳では、
原文の § 6.2, § 6.3 に定義される各種~演算を，（下の %取得演算 の）~parameter化により まとめて定義する。
】【
入力として下に与えられる %取得演算 には `StructuredDeserialize$jA() を孕むものもあるが、
上位節の冒頭に記されたように，その演算から例外が投出されることはない。
】</p>

<div class="algo">
<p>
<a id="retrieve-a-value-from-an-object-store"></a>
<a id="retrieve-a-key-from-an-object-store"></a>
<a id="retrieve-a-referenced-value-from-an-index"></a>
<a id="retrieve-a-value-from-an-index"></a>
`範囲に入る最初の~entryを検索取得する@
ときは、
所与の
⇒＃
%対象： `保管庫$／`索引$
%範囲： `~key範囲$
%取得演算： `~record$から対応する何かを取得する演算
◎終
に対し，次を走らす：
◎
To retrieve a value from an object store with targetRealm, store and range, run these steps:
To retrieve a key from an object store with store and range, run these steps:
To retrieve a referenced value from an index with targetRealm, index and range, run these steps:
To retrieve a value from an index with index and range, run these steps:
</p>

<ol>
	<li>
%~record ~LET %対象 の~record~list内の［
`~key$ ~IN~cmpkey %範囲
］を満たす`~record$のうち，最初のもの
◎
Let record be the first record in (store|index)’s list of records whose key is in range, if any.
</li>
	<li>
~RET［
%~record ~EQ ε ならば ε ／
~ELSE_ %取得演算( %~record )
］
◎
If record was not found, return undefined.
◎
(
Let (serialized|value) be of record’s (referenced value|value).
Return ! StructuredDeserialize(value, targetRealm).
)|(
Return the result of converting a key to a value with record’s (key|value).
)
</li>
</ol>
</div>

<div class="algo">
<p>
<a id="retrieve-multiple-values-from-an-object-store"></a>
<a id="retrieve-multiple-keys-from-an-object-store"></a>
<a id="retrieve-multiple-referenced-values-from-an-index"></a>
<a id="retrieve-multiple-values-from-an-index"></a>
`範囲に入る~entryたちを検索取得する@
ときは、
所与の
⇒＃
%対象： `保管庫$ ／ `索引$,
%範囲： `~key範囲$,
%count： 取り出す最大個数（省略時は ε ）,
%取得演算： `~record$から対応する何かを取得する演算
◎終
に対し，次を走らす：
◎
To retrieve multiple values from an object store with targetRealm, store, range and optional count, run these steps:
To retrieve multiple keys from an object store with store, range and optional count, run these steps:
To retrieve multiple referenced values from an index with targetRealm, index, range and optional count, run these steps:
To retrieve multiple values from an index with index, range and optional count, run these steps:
</p>

<ol>
	<li>
%~record~list ~LET %対象 の~record~list内の［
`~key$ ~IN %範囲
］を満たす`~record$のうち，［
%count ~IN { ε, 0 } ならば すべての~record ／
~ELSE_ 最初から %count 個までの~record
］からなる`~list$
◎
If count is not given or is 0 (zero), let count be infinity.
◎
Let records be a list containing the first count records in (store|index)’s list of records whose key is in range.
</li>
	<li>
%~list ~LET 新たな空`~list$
◎
Let list be an empty list.
</li>
	<li>
%~record~list を成す
~EACH( %~record )
に対し
⇒
%~list に %取得演算( %~record ) を付加する
◎
For each record of records: (
• Let serialized be record’s (referenced value|value).
• Let entry be ! StructuredDeserialize(serialized, targetRealm).
)|(
• Let entry be the result of converting a key to a value with record’s (key|value)).
)
• Append entry to list.
</li>
	<li>
~RET %~list を `~SeqAny$ 型~値に変換した結果
◎
Return list converted to a sequence&lt;any&gt;.
</li>
</ol>
</div>

<div lang="en" class="_en" style="white-space: pre-line;">
<h3>6.2 Object store retrieval perations</h3>
<p>
To retrieve a value from an object store with targetRealm, store and range, run these steps:

• Let record be the first record in store’s list of records whose key is in range, if any.
• If record was not found, return undefined.
• Let serialized be of record’s value.
• Return ! StructuredDeserialize(serialized, targetRealm).
</p><p>
To retrieve multiple values from an object store with targetRealm, store, range and optional count, run these steps:

• If count is not given or is 0 (zero), let count be infinity.
• Let records be a list containing the first count records in store’s list of records whose key is in range.
• Let list be an empty list.
• For each record of records:
•• Let serialized be record’s value.
•• Let entry be ! StructuredDeserialize(serialized, targetRealm).
•• Append entry to list.
• Return list converted to a sequence&lt;any&gt;.
</p><p>
To retrieve a key from an object store with store and range, run these steps:

• Let record be the first record in store’s list of records whose key is in range, if any.
• If record was not found, return undefined.
• Return the result of converting a key to a value with record’s key.
</p><p>
To retrieve multiple keys from an object store with store, range and optional count, run these steps:

• If count is not given or is 0 (zero), let count be infinity.
• Let records be a list containing the first count records in store’s list of records whose key is in range.
• Let list be an empty list.
• For each record of records:
•• Let entry be the result of converting a key to a value with record’s key.
•• Append entry to list.
• Return list converted to a sequence&lt;any&gt;.
</p>

<h3>6.3. Index retrieval operations</h3>
<p>
To retrieve a referenced value from an index with targetRealm, index and range, run these steps:

• Let record be the first record in index’s list of records whose key is in range, if any.
• If record was not found, return undefined.
• Let serialized be record’s referenced value.
• Return ! StructuredDeserialize(serialized, targetRealm).
</p><p>
To retrieve multiple referenced values from an index with targetRealm, index, range and optional count, run these steps:

• If count is not given or is 0 (zero), let count be infinity.
• Let records be a list containing the first count records in index’s list of records whose key is in range.
• Let list be an empty list.
• For each record of records:
•• Let serialized be record’s referenced value.
•• Let entry be ! StructuredDeserialize(serialized, targetRealm).
•• Append entry to list.
• Return list converted to a sequence&lt;any&gt;.
</p><p class="note">
The values of an record in an index are the keys of records in the referenced object store.
</p><p>
To retrieve a value from an index with index and range, run these steps:

• Let record be the first record in index’s list of records whose key is in range, if any.
• If record was not found, return undefined.
• Return the result of converting a key to a value with record’s value.
</p><p>
To retrieve multiple values from an index with index, range and optional count, run these steps:

• If count is not given or is 0 (zero), let count be infinity.
• Let records be a list containing the first count records in index’s list of records whose key is in range.
• Let list be an empty list.
• For each record of records:
•• Let entry be the result of converting a key to a value with record’s value.
•• Append entry to list.
• Return list converted to a sequence&lt;any&gt;.
</p>
</div>

		</section>
		<section id="object-store-deletion-operation">
<h3 title="Object store deletion operation">6.4. 保管庫から~recordを削除する演算</h3>

<div class="algo">
<p>
`保管庫から~recordを削除する@
ときは、
所与の
( `保管庫$ %保管庫, `~key範囲$ %範囲 )
に対し，次を走らす：
◎
To delete records from an object store with store and range, run these steps:
</p>

<ol>
	<li>
%保管庫 の`~record~list$Osから，次を満たす`~record$をすべて除去する
⇒
`~key$ ~IN~cmpkey %範囲
◎
Remove all records, if any, from store’s list of records with key in range.
</li>
	<li>
%保管庫 に`専属する$
~EACH( `索引$ )
に対し
⇒
`索引$の`~record~list$Ixから，次を満たす`~record$をすべて除去する
⇒
`値$ ~IN~cmpkey %範囲
◎
For each index which references store, remove every record from index’s list of records whose value is in range, if any such records exist.
</li>
	<li>
~RET ε
◎
Return undefined.
</li>
</ol>
</div>

		</section>
		<section id="record-counting-operation">
<h3 title="Record counting operation">6.5. 範囲に入る~recordを数える演算</h3>

<div class="algo">
<p>
`範囲に入る~recordを数える@
手続きは、
所与の
( `保管庫$または`索引$ %~source, `~key範囲$ %範囲 )
に対し，次を走らす：
◎
To count the records in a range with source and range, run these steps:
</p>

<ol>
	<li>
~RET %~source の~record~list内の，次を満たす`~record$の総数
⇒
`~key$ ~IN~cmpkey %範囲
◎
Let count be the number of records, if any, in source’s list of records with key in range.
◎
Return count.
</li>
</ol>
</div>

		</section>
		<section id="object-store-clear-operation">
<h3 title="Object store clear operation">6.6. 保管庫を~clearする演算</h3>

<div class="algo">
<p>
`保管庫を~clearする@
ときは、
所与の
( `保管庫$ %保管庫 )
に対し，次を走らす：
◎
To clear an object store with store, run these steps:
</p>

<ol>
	<li>
%保管庫 からすべての`~record$を除去する
◎
Remove all records from store.
</li>
	<li>
%保管庫 に`専属する$
~EACH( `索引$ )
に対し
⇒
`索引$からすべての`~record$を除去する
◎
In all indexes which reference store, remove all records.
</li>
	<li>
~RET ε
◎
Return undefined.
</li>
</ol>
</div>

		</section>
		<section id="_cursor-creation-operation">
<h3 title="Cursor iteration operation">6.X. ~cursorを作成する演算</h3>

<p class="trans-note">【
この訳では、
原文にて繰り~~返し現れる記述をこの節に集約して定義する。
】</p>

<div class="algo">
<p>
`~cursorを作成する@
ときは、
所与の
⇒＃
%~source ： `保管庫~handle$／`索引~handle$,
%宛先~Realm ：`~Realm$,
%方向 ： `方向$Cs,
%範囲： `~key範囲$,
%~keyのみ~flag ~IN { `~keyのみ^i, ε }（省略時は ε ）
◎終
に対し，次を走らす：
</p>
<ol>
	<li>
%~keyのみか ~LET %~keyのみ~flag に応じて
⇒＃
`~keyのみ^i ならば ~T ／
~ELSE_ ~F
</li>
	<li>
%~interface ~LET %~keyのみか に応じて
⇒＃
~T ならば `IDBCursor!I ／
~F ならば `IDBCursorWithValue!I
</li>
	<li>
%~cursor ~LET %宛先~Realm 内で %~interface を実装する新たな`~cursor$
</li>
	<li>
%~cursor の
⇒＃
`~source$Cs ~SET %~source,
`範囲$Cs ~SET %範囲,
`方向$Cs ~SET %方向,
`位置$Cs ~SET ε,
`保管庫~位置$Cs ~SET ε,
`~key$Cs ~SET ε,
`値$Cs ~SET ε,
`値は取得-済みか$Cs ~SET ~F,
`~keyのみか$Cs ~SET %~keyのみか
</li>
	<li>
~RET `~cursorを反復する$( %~cursor, %宛先~Realm )
</li>
</ol>
</div>

		</section>
		<section id="cursor-iteration-operation">
<h3 title="Cursor iteration operation">6.7. ~cursorを反復する演算</h3>

<div class="algo">
<p>
`~cursorを反復する@
ときは、
所与の
⇒＃
%~cursor： `~cursor$,
%宛先~Realm：`~Realm$,
%~key ： 移動先の`~key$（省略時は ε ）,
%首key ： 保管庫における移動先の`~key$（省略時は ε ）,
%count ： 反復する回数（省略時は ε ）
◎終
に対し，次を走らす：
◎
To iterate a cursor with targetRealm, cursor, an optional key and primaryKey to iterate to, and an optional count, run these steps:
</p>

<ol>
	<li>
%~source ~LET %~cursor の`~source$Cs↗
◎
Let source be cursor’s source.
</li>
	<li>
%方向 ~LET %~cursor の`方向$Cs
◎
Let direction be cursor’s direction.
</li>
	<li>
~Assert：
［
%首key ~EQ ε
］~OR［［
%~source は`索引$である
］~AND［
%方向 ~IN { `next^l, `prev^l }
］］
◎
Assert: if primaryKey is given, source is an index and direction is "next" or "prev".
</li>
	<li>
<p>
%~record~list ~LET %~source 内の すべての~recordからなる~list
◎
Let records be the list of records in source.
</p>

<p class="note">注記：
%~record~list は常に`~key$の昇順で~sortされる。
%~source が`索引$である場合、
それに加えて，同じ`~key$を持つ~recordたちは，それらの`値$
（すなわち， ~recordの`参照先~record$の`~key$）
の`昇順$でも~sortされる。
◎
records is always sorted in ascending key order. In the case of source being an index, records is secondarily sorted in ascending value order (where the value in an index is the key of the record in the referenced object store).
</p>
	</li>
	<li>
%範囲 ~LET %~cursor の`範囲$Cs
◎
Let range be cursor’s range.
</li>
	<li>
%位置 ~LET %~cursor の`位置$Cs
◎
Let position be cursor’s position.
</li>
	<li>
%保管庫~位置 ~LET %~cursor の`保管庫~位置$Cs
◎
Let object store position be cursor’s object store position.
</li>
	<li>
~IF［
%count ~EQ ε
］
⇒
%count ~SET 1
◎
If count is not given, let count be 1.
</li>
	<li>
<p>
%~record ~LET 次の下位手続きを走らせた結果
（ %~record~list から一つの~recordに絞り込む）：
</p>
		<ol>
			<li>
%~record~list から［
`~key$ ~NIN~cmpkey %範囲
］を満たす~recordすべてを除去する
</li>
			<li>
~IF［
%位置 ~NEQ ε
］：
				<ol>
					<li>
<p>
~IF［
%~source は`保管庫$である
］~OR［
%方向 ~IN { `nextunique$l, `prevunique$l }
］
⇒
%~record~list から［
%方向 に応じて，次に与える条件
］を満たす~recordすべてを除去する：
</p>

<dl class="switch">
	<dt>`next$l</dt>
	<dt>`nextunique$l</dt>
	<dd>
`~key$ ~LTE~cmpkey %位置
</dd>
	<dt>`prev$l</dt>
	<dt>`prevunique$l</dt>
	<dd>
`~key$ ~GTE~cmpkey %位置
</dd>
</dl>
					</li>
					<li>
<p>
~ELSE
⇒
%~record~list から［
%方向 に応じて，次に与える条件
］を満たす~recordすべてを除去する：
</p>
<dl class="switch">
	<dt>`next$l</dt>
	<dd>
( `~key$, `値$ ) ~LTE~cmpkey ( %位置, %保管庫~位置 )
</dd>

	<dt>`prev$l</dt>
	<dd>
( `~key$, `値$ ) ~GTE~cmpkey ( %位置, %保管庫~位置 )
</dd>
</dl>
					</li>
					<li>
<p>
~IF［
%~key ~NEQ ε
］
</p>
						<ol>
							<li>
<p>
~IF［
%首key ~EQ ε
］
⇒
%~record~list から［
%方向 に応じて，次に与える条件
］を満たす~recordすべてを除去する：
</p>
<dl class="switch">
	<dt>`next$l</dt>
	<dt>`nextunique$l</dt>
	<dd>
`~key$ ~LT~cmpkey %~key
</dd>
	<dt>`prev$l</dt>
	<dt>`prevunique$l</dt>
	<dd>
`~key$ ~GT~cmpkey %~key
</dd>
</dl>
							</li>
							<li>
<p>
~ELSE
⇒
%~record~list から［
%方向 に応じて，次に与える条件
］を満たす~recordすべてを除去する：
</p>
<dl class="switch">
	<dt>`next$l</dt>
	<dd>
( `~key$, `値$ ) ~LT~cmpkey ( %~key, %首key )
</dd>
	<dt>`prev$l</dt>
	<dd>
( `~key$, `値$ ) ~GT~cmpkey ( %~key, %首key )
</dd>
</dl>
							</li>
						</ol>
					</li>
				</ol>
			<li>
~IF［
%方向 ~IN { `nextunique$l, `prevunique$l }
］
⇒
%~record~list を成す
~EACH( ~keyが互いに`等しい$一群の~record )
に対し
⇒
それらのうち，最初のもの以外の~recordすべてを %~record~list から除去する
【！Iterating with "prevunique" visits the same records that "nextunique" visits, but in reverse order.】
</li>
			<li>
~IF［
%~record~list を成す~recordの個数 ~GTE %count
］
⇒
~RET ε
</li>
			<li>
<p>
~RET %方向 に応じて，次に与える~record：
</p>

<dl class="switch">
	<dt>`next$l</dt>
	<dt>`nextunique$l</dt>
	<dd>
%~record~list 内の最初から %count 個目の~record
</dd>
	<dt>`prev$l</dt>
	<dt>`prevunique$l</dt>
	<dd>
%~record~list 内の最後から %count 個目の~record
</dd>
				</dl>
			</li>
		</ol>

<div lang="en" class="_en">
<p>
While count is greater than 0:
</p>
		<ol>
			<li>
<p>
Switch on direction:
</p>
				<dl class="switch">
					<dt>"next"</dt>
					<dd>
Let found record be the first record in records which satisfy all of the following requirements:
						<ul>
							<li>
If key is defined, the record’s key is greater than or equal to key.
</li>
							<li>
If primaryKey is defined, the record’s key is equal to key and the record’s value is greater than or equal to primaryKey, or the record’s key is greater than key.
</li>
							<li>
If position is defined, and source is an object store, the record’s key is greater than position.
</li>
							<li>
If position is defined, and source is an index, the record’s key is equal to position and the record’s value is greater than object store position or the record’s key is greater than position.
							</li>
							<li>
The record’s key is in range.
</li>
						</ul>
					</dd>

					<dt>"nextunique"</dt>
					<dd>
◎
Let found record be the first record in records which satisfy all of the following requirements:
						<ul>
							<li>
If key is defined, the record’s key is greater than or equal to key.
</li>
							<li>
If position is defined, the record’s key is greater than position.
</li>
							<li>
The record’s key is in range.
</li>
						</ul>
					</dd>

					<dt>"prev"</dt>
					<dd>
Let found record be the last record in records which satisfy all of the following requirements:
						<ul>
							<li>
If key is defined, the record’s key is less than or equal to key.
</li>
							<li>
If primaryKey is defined, the record’s key is equal to key and the record’s value is less than or equal to primaryKey, or the record’s key is less than key.
</li>
							<li>
If position is defined, and source is an object store, the record’s key is less than position.
</li>
							<li>
If position is defined, and source is an index, the record’s key is equal to position and the record’s value is less than object store position or the record’s key is less than position.
</li>
							<li>
The record’s key is in range.
</li>
						</ul>
					</dd>

					<dt>"prevunique"</dt>
					<dd>
Let temp record be the last record in records which satisfy all of the following requirements:
						<ul>
							<li>
If key is defined, the record’s key is less than or equal to key.
</li>
							<li>
If position is defined, the record’s key is less than position.
</li>
							<li>
The record’s key is in range.
</li>
						</ul>
<p>
If temp record is defined, let found record be the first record in records whose key is equal to temp record’s key.
</p>
<p>
Iterating with "prevunique" visits the same records that "nextunique" visits, but in reverse order.
</p>
					</dd>
				</dl>
			</li>
			<li>
<p>
↓↓
If found record is not defined, then:
</p>
				<ol>
					<li>
Set cursor’s key to undefined.
</li>
					<li>
If source is an index, set cursor’s object store position to undefined.
</li>
					<li>
If cursor’s key only flag is false, set cursor’s value to undefined.
</li>
					<li>
Return null.
</li>
				</ol>
			</li>
			<li>
Let position be found record’s key.
</li>
			<li>
If source is an index, let object store position be found record’s value.
</li>
			<li>
Decrease count by 1.
</li>
		</ol>
</div>

	</li>
	<li>
<p>
~IF［
%~record ~EQ ε
］：
</p>
		<ol>
			<li>
%~cursor の`~key$Cs ~SET ε
</li>
			<li>
~IF［
%~source は`索引$である
］
⇒
%~cursor の`保管庫~位置$Cs ~SET ε
</li>
			<li>
~IF［
%~cursor の`~keyのみか$Cs ~EQ ~F
］
⇒
%~cursor の`値$Cs ~SET ε
</li>
			<li>
~RET ~NULL
</li>
		</ol>
◎
↑</li>
	<li>
%~cursor の`位置$Cs ~SET %~record の`~key$
◎
Set cursor’s position to position.
</li>
	<li>
~IF［
%~source は`索引$である
］
⇒
%~cursor の`保管庫~位置$Cs ~SET %~record の`値$
◎
If source is an index, set cursor’s object store position to object store position.
</li>
	<li>
%~cursor の`~key$Cs ~SET %~record の`~key$
◎
Set cursor’s key to found record’s key.
</li>
	<li>
<p>
~IF［
%~cursor の`~keyのみか$Cs ~EQ ~F
］：
◎
If cursor’s key only flag is false, then:
</p>
		<ol>
			<li>
~IF［
%~source は`索引$である
］
⇒
%直列形 ~LET %~record の`参照先~record$の`値$
◎
Let serialized be found record’s referenced value.
</li>
			<li>
%~cursor の`値$Cs ~SET ~NOABRUPT `StructuredDeserialize$jA( %直列形, %宛先~Realm )
◎
Set cursor’s value to ! StructuredDeserialize(serialized, targetRealm)
</li>
		</ol>
	</li>
	<li>
%~cursor の`値は取得-済みか$Cs ~SET ~T
◎
Set cursor’s got value flag to true.
</li>
	<li>
~RET %~cursor
◎
Return cursor.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="binding">
<h2 title="ECMAScript binding">7. ~ES言語束縛</h2>

<p>
この節では、
この仕様にて定義された`~key$値を［
~ES値に変換する／その逆向きに変換する
］方法, および
`~key~path$を利用して`~key$を~ES値の［
中から抽出する／中へ注入する
］方法を定義する。
この節では、
~ES言語~仕様 `ECMA-262$r の各種
型／~algo
を参照し，いくつかの
<a href="~TC39#sec-algorithm-conventions">~algo表記規約</a>†
を利用する。
ここで述べない変換の詳細は `WEBIDL$r にて定義される。
◎
This section defines how key values defined in this specification are converted to and from ECMAScript values, and how they may be extracted from and injected into ECMAScript values using key paths. This section references types and algorithms and uses some algorithm conventions from the ECMAScript Language Specification. [ECMA-262] Conversions not detailed here are defined in [WEBIDL].
</p>

<p class="trans-note">【†
概ね、
~algo内の抽象-演算（ `Get^jA() など）の前に現れる記号 ~NOABRUPT, ~ABRUPT を指す。
大雑把に言えば、
~NOABRUPT は 例外が生じ得ることを表し，
~ABRUPT は 例外は決して生じないことを表す。
~NOABRUPT, ~ABRUPT とも付与されていない場合、
一般に，明示的な例外の取扱い，または表明（ ~Assert ）を要する。
】</p>

		<section id="extract-key-from-value">
<h3 title="Extract a key from a value">7.1. 値から~keyを抽出する</h3>

<div>
<div class="algo">
<p>
`値から~keyを抽出する@
ときは、
所与の
( `値$ %値, `~key~path$ %~key~path )
に対し，［
`~key$／`失敗^i／`妥当でない^i
］を返すか例外を投出する：
</p>
<ol>
	<li>
%r ~LET ~ABRUPT `~key~pathを評価する$( %値, %~key~path )
</li>
	<li>
~IF［
%r ~EQ `失敗^i
］
⇒
~RET %r
</li>
	<li>
~RET ~ABRUPT `値を~keyに変換する$( %r )
</li>
</ol>
</div>

<div class="algo">
<p>
`値から~key集合を抽出する@
ときは、
所与の
( `値$ %値, `~key~path$ %~key~path, 真偽値 %複-~entryか )
に対し，［
`~key$の集合 ／ `失敗^i
］を返す
— 以下の中で例外が投出される所では、
`失敗^i を返すとする：
</p>

<ol>
	<li>
%r ~LET ~ABRUPT `~key~pathを評価する$( %値, %~key~path )
</li>
	<li>
~IF［
%r ~EQ `失敗^i
］
⇒
~RET `失敗^i
</li>
	<li>
~IF［
%複-~entryか ~EQ ~T
］~AND［
%r は`~Array~exotic~obj$である
］
⇒
~RET ~ABRUPT `配列を~key集合に変換する$( %r )
</li>
	<li>
%~key ~LET ~ABRUPT `値を~keyに変換する$( %r )
</li>
	<li>
~IF［
%~key は`~key$でない
］
⇒
~RET `失敗^i
</li>
	<li>
~RET %~key のみからなる集合
</li>
</ol>

</div>

◎
To extract a key from a value using a key path with value, keyPath and an optional multiEntry flag, run the following steps. The result of these steps is a key, invalid, or failure, or the steps may throw an exception.
◎
Let r be the result of evaluating a key path on a value with value and keyPath. Rethrow any exceptions.
◎
If r is failure, return failure.
◎
Let key be the result of converting a value to a key with r if the multiEntry flag is false, and the result of converting a value to a multiEntry key with r otherwise. Rethrow any exceptions.
◎
If key is invalid, return invalid.
◎
Return key.
</div>

<p class="trans-note">【
［
`値から~keyを抽出する$,
`値から~key集合を抽出する$
］は、
原文では一つの~algoとして定義されているが，この訳では 2 つに分離している。
そうした方が、
依存関係の見通しが良くなるので
（同時に、
原文による`配列を~key集合に変換する$手続きの一部もこの手続きに移動している）。
原文における `値から~key集合を抽出する$ に該当する部分は，`配列~key$を返しているが、
ここでは，単に~keyの集合を返すように改めている。
その配列~keyは一時的にしか利用されておらず
（また，実際に重複もなく順序も有意でない）、
そうした方が，この手続きを利用している箇所
（`保管庫に~recordを格納する$手続きの中で，索引を拡充するとき）
の記述も簡明になるので。
】</p>

<div class="algo">
<p>
`~key~pathを評価する@
ときは、
所与の
( `値$ %値, `~key~path$ %~key~path )
に対し，［
~ES値／`失敗^i
］を返すか例外を投出する：
◎
To evaluate a key path on a value with value and keyPath, run the following steps. The result of these steps is an ECMAScript value or failure, or the steps may throw an exception.
</p>

<p class="trans-note">【
返り値 `失敗^i は、
%値 の中に %~key~path が指す部位が無いことを表す。
】</p>

<ol>
	<li>
<p>
~IF［
%~key~path は文字列の`~list$である
］：
◎
If keyPath is a list of strings, then:
</p>
		<ol>
			<li>
%結果 ~LET 
式 `[]^jv で作成されるものと同じ，新たな `Array$jT ~obj
◎
Let result be a new Array object created as if by the expression [].
</li>
			<li>
%i ~LET 0
◎
Let i be 0.
</li>
			<li>
<p>
%~key~path を成す
~EACH( %item )
に対し：
◎
For each item of keyPath:
</p>
				<ol>
					<li>
%~key ~LET
~NOABRUPT `~key~pathを評価する$( %値, %item ) †
【！原文は引数順序が逆】
◎
Let key be the result of recursively evaluating a key path on a value with item and value.
◎
Assert: key is not an abrupt completion.
</li>
					<li>
~IF［
%~key ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If key is failure, abort the overall algorithm and return failure.
</li>
					<li>
%p ~LET ~NOABRUPT `ToString$jA( %i )
◎
Let p be ! ToString(i).
</li>
					<li>
%状態s ~LET `CreateDataProperty$jA( %result, %p, %~key )
◎
Let status be CreateDataProperty(result, p, key).
</li>
					<li>
~Assert： %状態s ~EQ ~T
◎
Assert: status is true.
</li>
					<li>
%i ~INCBY 1
◎
Increase i by 1.
</li>
				</ol>
			</li>
			<li>
~RET %結果
◎
Return result.
</li>
		</ol>

<p class="note">注記（†）：
これは、
一階層のみ “再帰する”
— `~key~path$ 連列は入子にできないので。
◎
This will only ever "recurse" one level since key path sequences can’t ever be nested.
</p>
	</li>
	<li>
~IF［
%~key~path ~EQ 空~文字列
］
⇒
~RET %値
【！ この段は不要 】
◎
If keyPath is the empty string, return value and skip the remaining steps.
</li>
	<li>
%識別子~list ~LET
`区切子で厳密に分割する$( %~key~path, `002E^U (`.^l) )
◎
Let identifiers be the result of strictly splitting keyPath on U+002E FULL STOP characters (.).
</li>
	<li>
<p>
%識別子~list を成す
~EACH( %識別子 )
に対し
◎
For each identifier of identifiers, jump to the appropriate step below:
</p>
		<ol>
			<li>
<p>
~IF［
下の表内に
( %値 が満たす条件, %識別子 )
に該当する行は在る
］
⇒
%値 ~LET 同じ行の “結果” の列に与える値
◎
↓</p>

<table class="_row">

<thead><tr><th>%値 が満たす条件
<th>%識別子
<th>結果
</thead>

<tbody><tr><td>`Type$jA( %値 ) ~EQ `String$jT
<td>`length^l
<td>%値 の`長さ$str【！the number of elements in】に等しい `Number$jT 値

<tr lang="en" class="_en"><td colspan="3">
If Type(value) is String, and identifier is "length"
• Let value be a Number equal to the number of elements in value.
</tbody>

<tbody><tr><td>`Array$jT である
<td>`length^l
<td>~NOABRUPT `ToLength$jA( ~NOABRUPT `Get$jA( %値, `length^l ) )

<tr lang="en" class="_en"><td colspan="3">
If value is an Array and identifier is "length"
• Let value be ! ToLength(! Get(value, "length")).
</tbody>

<tbody><tr><td>`Blob$I である
<td>`size^l
<td>%値 の `size$mF に等しい `Number$jT 値

<tr lang="en" class="_en"><td colspan="3">
If value is a Blob and identifier is "size"
• Let value be a Number equal to value’s size.
</tbody>

<tbody><tr><td>`Blob$I である
<td>`type^l
<td>%値 の `type$mF に等しい `String$jT 値

<tr lang="en" class="_en"><td colspan="3">
If value is a Blob and identifier is "type"
• Let value be a String equal to value’s type.
</tbody>

<tbody><tr><td>`File$I である
<td>`name^l
<td>%値 の `name$mF に等しい `String$jT 値

<tr lang="en" class="_en"><td colspan="3">
If value is a File and identifier is "name"
• Let value be a String equal to value’s name.
</tbody>

<tbody><tr><td>`File$I である
<td>`lastModified^l
<td>%値 の `lastModified$mF に等しい `Number$jT 値

<tr lang="en" class="_en"><td colspan="3">
If value is a File and identifier is "lastModified"
• Let value be a Number equal to value’s lastModified.

</tbody></table>

<p class="trans-note">【
`File^I であるならば `Blob^I でもあることに注意。
】</p>

			</li>
			<li>
<p>
~ELSE：
◎
Otherwise
</p>
				<ol>
					<li>
~IF［
`Type$jA( %値 ) ~NEQ `Object$jT
］
⇒
~RET `失敗^i
◎
If Type(value) is not Object, return failure.
</li>
					<li>
%hop ~LET ~NOABRUPT `HasOwnProperty$jA( %値, %識別子 )
◎
Let hop be ! HasOwnProperty(value, identifier).
</li>
					<li>
~IF［
%hop ~EQ `false^jv
］
⇒
~RET `失敗^i
◎
If hop is false, return failure.
</li>
					<li>
%値 ~LET ~NOABRUPT `Get$jA( %値, %識別子 )
◎
Let value be ! Get(value, identifier).
</li>
					<li>
~IF［
%値 ~EQ `undefined^jv
］
⇒
~RET `失敗^i
◎
If value is undefined, return failure.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~Assert：
%値 は`中途完了$でない
◎
Assert: value is not an abrupt completion.
</li>
	<li>
~RET %値
◎
Return value.
</li>
</ol>

<p class="note">注記：
この~algoが適用される値は，
`StructuredDeserialize$jA からの出力であり,
“自前の” ~propのみに~accessするので、
上の手続きにおける ~Assert は満たされる。
◎
Assertions can be made in the above steps because this algorithm is only applied to values that are the output of StructuredDeserialize and only access "own" properties.
</p>
</div>

		</section>
		<section id="inject-key-into-value">
<h3 title="Inject a key into a value">7.2. ~keyを値の中へ注入する</h3>

<p class="note">注記：
この節で利用される`~key~path$は、
常に文字列であり，決して連列（ `~SeqDS$ ）にはならなない
— `~key生成器$を持つ, かつ`~key~path$Osは連列にされた`保管庫$は作成し得ないので。
◎
The key paths used in this section are always strings and never sequences, since it is not possible to create a object store which has a key generator and also has a key path that is a sequence.
</p>

<div class="algo">
<p>
`~keyを値の中へ注入できるか検査する@
ときは、
所与の
( %値, %~key~path )
に対し［
~T ／ ~F
］を返す：
◎
To check that a key could be injected into a value with value and a keyPath, run the following steps. The result of these steps is either true or false.
</p>

<ol>
	<li>
%識別子~list ~LET
`区切子で厳密に分割する$( %~key~path, `002E^U (`.^l) )
◎
Let identifiers be the result of strictly splitting keyPath on U+002E FULL STOP characters (.).
</li>
	<li>
~Assert：
%識別子~list は空でない
◎
Assert: identifiers is not empty.
</li>
	<li>
%識別子~list から最後の`~item$を`除去する$
◎
Remove the last item of identifiers.
</li>
	<li>
<p>
%識別子~list を成す
~EACH( %識別子 )
に対し：
◎
For each remaining identifier of identifiers, if any:
</p>
		<ol>
			<li>
~IF［
%値 は［
`Object$jT, `Array$jT
］のいずれでもない
］
⇒
~RET ~F
◎
If value is not an Object or an Array, return false.
</li>
			<li>
%hop ~LET ~NOABRUPT `HasOwnProperty$jA( %値, %識別子 )
◎
Let hop be ! HasOwnProperty(value, identifier).
</li>
			<li>
~IF［
%hop ~EQ `false^jv
］
⇒
~RET ~T
◎
If hop is false, return true.
</li>
			<li>
%値 ~LET ~NOABRUPT `Get$jA( %値, %識別子 )
◎
Let value be ! Get(value, identifier).
</li>
		</ol>
	</li>
	<li>
~RET［
%値 は［
`Object$jT, `Array$jT
］のいずれかならば ~T ／
~ELSE_ ~F
］
◎
Return true if value is an Object or an Array, or false otherwise.
</li>
</ol>

<p class="note">注記：
この~algoが適用される値は，
`StructuredDeserialize$jA からの出力なので、
上の手続きにおける ~Assert は満たされる。
◎
Assertions can be made in the above steps because this algorithm is only applied to values that are the output of StructuredDeserialize.
</p>
</div>

<div class="algo">
<p>
`~keyを値の中へ注入する@
ときは、
所与の
( `値$ %値, `~key$ %~key, `~key~path$Os %~key~path )
に対し，次を走らす：
◎
To inject a key into a value using a key path with value, a key and a keyPath, run these steps:
</p>

<ol>
	<li>
%識別子~list ~LET
`区切子で厳密に分割する$( %~key~path, `002E^U (`.^l) )
◎
Let identifiers be the result of strictly splitting keyPath on U+002E FULL STOP characters (.).
</li>
	<li>
~Assert：
%識別子~list は空でない
◎
Assert: identifiers is not empty.
</li>
	<li>
%最後の識別子 ~LET %識別子~list の最後の`~item$
◎
Let last be the last item of identifiers＼
</li>
	<li>
%識別子~list から最後の`~item$を`除去する$
◎
and remove it from the list.
</li>
	<li>
<p>
%識別子~list を成す
~EACH( %識別子 )
に対し：
◎
For each remaining identifier of identifiers:
</p>
		<ol>
			<li>
~Assert
%値 は［
`Object$jT, `Array$jT
］のいずれかである
◎
Assert: value is an Object or an Array.
</li>
			<li>
%hop ~LET ~NOABRUPT `HasOwnProperty$jA( %値, %識別子 )
◎
Let hop be ! HasOwnProperty(value, identifier).
</li>
			<li>
<p>
~IF［
%hop ~EQ `false^jv
］：
◎
If hop is false, then:
</p>
				<ol>
					<li>
%o ~LET 
式 `({})^jv で作成されるものと同じ，新たな `Object$jT
◎
Let o be a new Object created as if by the expression ({}).
</li>
					<li>
%状態s ~LET `CreateDataProperty$jA( %値, %識別子, %o )
◎
Let status be CreateDataProperty(value, identifier, o).
</li>
					<li>
~Assert：
%状態s ~EQ `true^jv
◎
Assert: status is true.
</li>
				</ol>
			</li>
			<li>
%値 ~LET ~NOABRUPT `Get$jA( %値, %識別子 )
◎
Let value be ! Get(value, identifier).
</li>
		</ol>
	</li>
	<li>
~Assert：
%値 は `Object$jT または `Array$jT である
◎
Assert: value is an Object or an Array.
</li>
	<li>
%~key値 ~LET `~keyを値に変換する$( %~key )
◎
Let keyValue be the result of converting a key to a value with key.
</li>
	<li>
%状態s ~LET
`CreateDataProperty$jA( %値, %最後の識別子, %~key値 )
◎
Let status be CreateDataProperty(value, last, keyValue).
</li>
	<li>
~Assert：
%状態s ~EQ `true^jv
◎
Assert: status is true.
</li>
</ol>

<p class="note">注記：
この~algoが適用される値は、
`StructuredDeserialize$jA からの出力であり，`~keyを値の中へ注入できるか検査-$した後なので、
上の手続きにおける ~Assert は満たされる。
◎
Assertions can be made in the above steps because this algorithm is only applied to values that are the output of StructuredDeserialize, and the steps to check that a key could be injected into a value have been run.
</p>
</div>

		</section>
		<section id="convert-key-to-value">
<h3 title="Convert a key to a value">7.3. ~keyを値に変換する</h3>

<div class="algo">
<p>
`~keyを値に変換する@
ときは、
所与の
( `~key$ %~key )
に対し，~ES値を返す：
◎
To convert a key to a value with key, run the following steps. The steps return an ECMAScript value.
</p>

<ol>
	<li>
%値 ~LET %~key の`値$key
◎
Let type be key’s type.
◎
Let value be key’s value.
</li>
	<li>
<p>
%~key の`種別$keyに応じて：
◎
Switch on type:
</p>
		<dl class="switch">
			<dt>`number$i</dt>
			<dd>
~RET %値 に等しい~ES `Number$jT 値
◎
Return an ECMAScript Number value equal to value
</dd>
			<dt>`string$i</dt>
			<dd>
~RET %値 に等しい~ES `String$jT 値
◎
Return an ECMAScript String value equal to value
</dd>
			<dt>`date$i</dt>
			<dd>
				<ol>
					<li>
%日付 ~LET
~ES `Date$jT 構築子を ( %値 ) を引数に実行した結果
◎
Let date be the result of executing the ECMAScript Date constructor with the single argument value.
</li>
					<li>
~Assert：
%日付 は`中途完了$でない
◎
Assert: date is not an abrupt completion.
</li>
					<li>
~RET %日付
◎
Return date.
</li>
				</ol>
			</dd>

			<dt>`binary$i</dt>
			<dd>
				<ol>
					<li>
%~buffer ~LET
~ES `ArrayBuffer$jT 構築子を ( %値 の`長さ$byte ) を引数に実行した結果
◎
Let len be value’s length.
◎
Let buffer be the result of executing the ECMAScript ArrayBuffer constructor with len.
</li>
					<li>
~Assert：
%~buffer は`中途完了$でない
◎
Assert: buffer is not an abrupt completion.
</li>
					<li>
%~buffer の `ArrayBufferData^sl 内部~slotの~entryたち ~SET
%値 の~entryたち
◎
Set the entries in buffer’s [[ArrayBufferData]] internal slot to the entries in value.
</li>
					<li>
~RET %~buffer
◎
Return buffer.
</li>
				</ol>
			</dd>

			<dt>`array$i</dt>
			<dd>
				<ol>
					<li>
%配列 ~LET
~ES `Array$jT 構築子を引数なしで実行した結果
◎
Let array be the result of executing the ECMAScript Array constructor with no arguments.
</li>
					<li>
~Assert：
%配列 は`中途完了$でない
◎
Assert: array is not an abrupt completion.
</li>
					<li>
<p>
~EACH( 整数 %~index ~IN { 0 〜 %値 の`~size$ ~MINUS 1 } )
に対し，昇順に：
◎
Let len be value’s size.
◎
Let index be 0.
◎
While index is less than len:
</p>
						<ol>
							<li>
%~entry ~LET `~keyを値に変換する$( %値[ %~index ] )
◎
Let entry be the result of converting a key to a value with value[index].
</li>
							<li>
%状態s ~LET
`CreateDataProperty$jA( %配列, %~index, %~entry )
◎
Let status be CreateDataProperty(array, index, entry).
</li>
							<li>
~Assert：
%状態s ~EQ ~T
◎
Assert: status is true.
◎
Increase index by 1.
</li>
						</ol>
					</li>
					<li>
~RET %配列
◎
Return array.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>
</div>

		</section>
		<section id="convert-value-to-key">
<h3 title="Convert a value to a key">7.4. 値を~keyに変換する</h3>

<div class="algo">
<p>
`値を~keyに変換する@
ときは、
所与の
( ~ES値 %入力, `集合$ %seen )
に対し，［
`~key$／`妥当でない^i
］を返すか例外を投出する：
◎
To convert a value to a key with an ECMAScript value input, and an optional set seen, run the following steps. The result of these steps is a key or invalid, or the steps may throw an exception.
</p>

<p class="trans-note">【
%seen は［
%入力 が配列であるときに，自身を入子にしているかどうか検査する
］ために利用される。
】</p>

<ol>
	<li>
~IF［
%seen ~EQ ε
］
⇒
%seen ~SET 新たな`集合$
◎
If seen was not given, then let seen be a new empty set.
</li>
	<li>
~IF［
%入力 ~IN %seen
］
⇒
~RET `妥当でない^i
◎
If seen contains input, then return invalid.
</li>
	<li>
<p>
~IF［
`Type$jA( %入力 ) ~EQ `Number$jT
］：
◎
Jump to the appropriate step below:
◎
If Type(input) is Number
</p>
		<ol>
			<li>
~IF［
%入力 ~EQ `NaN^jv
］
⇒
~RET `妥当でない^i
◎
If input is NaN then return invalid.
</li>
			<li>
~RET 新たな`~key$
— その
⇒＃
`種別$key ~SET `number$i,
`値$key ~SET %入力
◎
Otherwise, return a new key with type number and value input.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%入力 は `Date$jT ~objである
（ `DateValue^sl 内部~slotを持つ）
］：
◎
If input is a Date (has a [[DateValue]] internal slot)
</p>
		<ol>
			<li>
%ms ~LET %入力 の `DateValue^sl 内部~slotの値
◎
Let ms be the value of input’s [[DateValue]] internal slot.
</li>
			<li>
~IF［
%ms ~EQ `NaN^jv
］
⇒
~RET `妥当でない^i
◎
If ms is NaN then return invalid.
</li>
			<li>
~RET 新たな`~key$
— その
⇒＃
`種別$key ~SET `date$i,
`値$key ~SET %ms
◎
Otherwise, return a new key with type date and value ms.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
`Type$jA( %入力 ) ~EQ `String$jT
］
⇒
~RET 新たな`~key$
— その
⇒＃
`種別$key ~SET `string$i,
`値$key ~SET %入力
◎
If Type(input) is String
• Return a new key with type string and value input.
</li>
	<li>
<p>
~ELIF［
%入力 は`~buffer~source型$である
］
◎
If input is a buffer source type
</p>
		<ol>
			<li>
%~byte列 ~LET
%入力 から`~buffer~sourceに保持されている~byte列の複製を取得-$した結果
— これは、
例外を投出し得る
◎
Let bytes be the result of getting a copy of the bytes held by the buffer source input. Rethrow any exceptions.
</li>
			<li>
~RET 新たな`~key$
— その
⇒＃
`種別$key ~SET `binary$i,
`値$key ~SET %~byte列
◎
Return a new key with type binary and value bytes.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%入力 は`~Array~exotic~obj$である
］：
◎
If input is an Array exotic object
</p>
		<ol>
			<li>
%長さ ~LET ~ABRUPT `ToLength$jA( ~ABRUPT `Get$jA( %入力, `length^l))
◎
Let len be ? ToLength( ? Get(input, "length")).
</li>
			<li>
%seen に %入力 を`付加する$
◎
Append input to seen.
</li>
			<li>
%~key群 ~LET 新たな空~list
◎
Let keys be a new empty list.
</li>
			<li>
<p>
~EACH( 整数 %~index ~IN { 0 〜 %長さ ~MINUS 1 } )
に対し，昇順に：
◎
Let index be 0.
◎
While index is less than len:
</p>
				<ol>
					<li>
%hop ~LET ~ABRUPT `HasOwnProperty$jA( %入力, %~index )
◎
Let hop be ? HasOwnProperty(input, index).
</li>
					<li>
~IF［
%hop ~EQ `false^jv
］
⇒
~RET `妥当でない^i
◎
If hop is false, return invalid.
</li>
					<li>
%~entry ~LET ~ABRUPT `Get$jA( %入力, %~index )
◎
Let entry be ? Get(input, index).
</li>
					<li>
%~key ~LET ~ABRUPT `値を~keyに変換する$( %~entry, %seen )
◎
Let key be the result of converting a value to a key with arguments entry and seen.
◎
ReturnIfAbrupt(key).
</li>
					<li>
~IF［
%~key ~EQ `妥当でない^i
］
⇒
~RET %~key
◎
If key is invalid abort these steps and return invalid.
</li>
					<li>
%~key群 に %~key を`付加する$
◎
Append key to keys.
◎
Increase index by 1.
</li>
				</ol>
			</li>
			<li>
~RET 新たな`~key$
— その
⇒＃
`種別$key ~SET `array$i,
`値$key ~SET %~key群
◎
Return a new array key with value keys.
</li>
		</ol>
	</li>
	<li>
~RET `妥当でない^i
◎
Otherwise
• Return invalid.
</li>
</ol>
</div>

<div class="algo">
<p>
`配列を~key集合に変換する@
ときは、
所与の
( ~ES `Array$jT 値 %配列 )
に対し，`~key$の集合を返すか例外を投出する：
◎
To convert a value to a multiEntry key with an ECMAScript value input, run the following steps. The result of these steps is a key or invalid, or the steps may throw an exception.
◎
If input is an Array exotic object, then:
</p>

<ol>
	<!-- Array -->
	<li>
%長さ ~LET ~ABRUPT `ToLength$jA( ~ABRUPT `Get$jA( %配列, `length^l))
◎
Let len be ? ToLength( ? Get(input, "length")).
</li>
	<li>
%seen ~LET %配列 のみからなる新たな`集合$
◎
Let seen be a new set containing only input.
</li>
	<li>
%~key群 ~LET 新たな`集合$
◎
Let keys be a new empty list.
</li>
	<li>
%~index ~LET 0
◎
Let index be 0.
</li>
	<li>
<p>
~WHILE ( %~index ~LT %長さ )
：
◎
While index is less than len:
</p>
		<ol>
			<li>
%~entry ~LET `Get$jA( %配列, %~index )
◎
Let entry be Get(input, index).
</li>
			<li>
<p>
~IF［
%~entry は`中途完了$でない
］：
◎
If entry is not an abrupt completion, then:
</p>
				<ol>
					<li>
%~key ~LET `値を~keyに変換する$( %~entry, %seen )
◎
Let key be the result of converting a value to a key with arguments entry and seen.
</li>
					<li>
~IF［
%~key は`中途完了$でない
］~AND［
%~key ~NEQ `妥当でない^i
］~AND［
%~key ~NIN~cmpkey %~key群
］
⇒
%~key を %~key群 に`付加する$set
◎
If key is not invalid or an abrupt completion, and there is no item in keys equal to key, then append key to keys.
</li>
				</ol>
			</li>
			<li>
%~index ~INCBY 1
◎
Increase index by 1.
</li>
		</ol>
	</li>
	<li>
~RET %~key群
◎
Return a new array key with value set to keys.
</li>
</ol>
</div>

<div class="note">
<p>
この手続きは、
`~key$へ変換できない~memberは無視した上で, 重複するものを除去する。
◎
Otherwise, return the result of converting a value to a key with argument input. Rethrow any exceptions.
◎
These steps are similar to those to convert a value to a key but if the top-level value is an Array then members which can not be converted to keys are ignored, and duplicates are removed.
</p>

<p>
例えば配列
`[10, 20, null, 30, 20]^jv
は、
`~key$の集合 { 10, 20, 30 } に変換される。
◎
For example, the value [10, 20, null, 30, 20] is converted to an array key with subkeys 10, 20, 30.
</p>
</div>

		</section>
	</section>
	<section id="privacy">
<h2 title="Privacy considerations">8. ~privacy上の考慮点</h2>

~INFORMATIVE

		<section id="user-tracking">
<h3 title="User tracking">8.1. 利用者の追跡</h3>

<p>
第三者-主体~host
（あるいは、
複数の~siteに配布される内容を取得する~~能力を持つ任意の~obj）
は、
その~client側~db内に格納された一意な識別子を利用して，複数~sessionにわたって利用者を追跡した上で，利用者の活動について~profileを築くこともできる。
利用者の本当の~~識別情報を知る~site
（例えば、
認証-済み資格証を要求する電子商取引~site）
と組み合わされれば、
どこかの圧政的団体が，純粋に匿名な~webの用法より ずっと正確aに各個人を標的にすることも可能になる。
◎
A third-party host (or any object capable of getting content distributed to multiple sites) could use a unique identifier stored in its client-side database to track a user across multiple sessions, building a profile of the user’s activities. In conjunction with a site that is aware of the user’s real id object (for example an e-commerce site that requires authenticated credentials), this could allow oppressive groups to target individuals with greater accuracy than in a world with purely anonymous Web usage.
</p>

<p>
利用者~追跡の~riskを軽減するために利用できる，いくつもの技法がある：
◎
There are a number of techniques that can be used to mitigate the risk of user tracking:
</p>

<dl>
	<dt>
第三者-主体による~storageを阻止する。
◎
Blocking third-party storage
</dt>
	<dd>
~UAは、
~db~objへの~accessを［
<span>閲覧文脈</span>の~top-level文書の~domainを出自にする~script
］に制約してもヨイ
—
一例として， `iframe^e 内で稼働している他の~domainからの~pageに対しては~APIへの~accessを否認するなど。
◎
User agents may restrict access to the database objects to scripts originating at the domain of the top-level document of the browsing context, for instance denying access to the API for pages from other domains running in iframes.
</dd>

	<dt>
格納された~dataを失効させる
◎
Expiring stored data
</dt>
	<dd>
<p>
~UAは、
格納されている~dataを、
一定期間~後に自動的に削除してもヨイ。
◎
User agents may automatically delete stored data after a period of time.
</p>

<p>
これは、
~siteが利用者を追跡する能を制約し得る
— ~siteは、
~site自身が利用者を認証する
（例：購入や~serviceへのログイン時など）
以外にも，利用者を複数~sessionにわたって追跡できなくする。
◎
This can restrict the ability of a site to track a user, as the site would then only be able to track the user across multiple sessions when she authenticates with the site itself (e.g. by making a purchase or logging in to a service).
</p>

<p>
しかしながら一方で、
利用者の~dataも~riskに晒す。
◎
However, this also puts the user’s data at risk.
</p>
	</dd>

	<dt>
持続的な~storageを~cookieと同様に扱う
◎
Treating persistent storage as cookies
</dt>
	<dd>
<p>
~UAは、
~db特能を
~HTTP~session~cookie `COOKIES$r
に強く結付けるような仕方で利用者に呈示するべきである。
◎
User agents should present the database feature to the user in a way that associates them strongly with HTTP session cookies. [COOKIES]
</p>

<p>
これは、
利用者が そのような~storageを~~健全な疑いで見ることを促すであろう。
◎
This might encourage users to view such storage with healthy suspicion.
</p>
	</dd>

	<dt>
~dbへ~accessできる~siteを個別に安全listに入れる
◎
Site-specific safe-listing of access to databases
</dt>
	<dd>
~UAは、
~siteがこの仕様の特能を利用できるようになる前に、
~dbに~accessする権限付与-を利用者に要求してもヨイ。
◎
User agents may require the user to authorize access to databases before a site can use the feature.
</dd>

	<dt>
格納された~dataの生成元~追跡
◎
Origin-tracking of stored data
</dt>
	<dd>

<p>
~UAは、
第三者-主体 `生成元$による内容を包含している~siteが，~dataを格納させたときは、
その~siteの`生成元$を記録してもヨイ。
◎
User agents may record the origins of sites that contained content from third-party origins that caused data to be stored.
</p>

<p>
その上で、
この情報を［
持続的な~storage内にある現在の~dataを呈示する
］ために利用するならば、
利用者は，その情報を吟味した上で 持続的な~storageからどの部分を取り除くか裁定を下せるようになる。
~阻止list
（ “この~dataを削除して，この~domainにこれ以上~dataを格納させない” ）
と組合わすことで、
利用者は，持続的な~storageの利用を自身が信用する~siteのみに制約できるようになる。
◎
If this information is then used to present the view of data currently in persistent storage, it would allow the user to make informed decisions about which parts of the persistent storage to prune. Combined with a blocklist ("delete this data and prevent this domain from ever storing data again"), the user can restrict the use of persistent storage to sites that she trusts.
</p>
	</dd>

	<dt>
共有d阻止list
◎
Shared blocklists
</dt>

	<dd>
<p>
~UAは、
利用者たちが，持続的な~storage~domainの~阻止listを共有できるようにしてもヨイ。
◎
User agents may allow users to share their persistent storage domain blocklists.
</p>

<p>
これは、
~communityが~~協同して自らの~privacyを保護できるようにする。
◎
This would allow communities to act together to protect their privacy.
</p>
	</dd>
</dl>

<p>
これらの提言は、
この~APIによる，利用者を追跡するための自明な利用については防止するが、
すべてを阻止できるわけではない。
単独の~domainの中では、
~siteは，~sessionの間 利用者を追跡し続けて、
その情報すべてを［
~siteが得した識別情報
（名前, クレジットカード番号, 住所など）
］と一緒に第三者-主体に渡すこともできる。
それでも、
第三者-主体が複数の~siteと協力して，そのような情報を得した場合、
~profileを作成し得る。
◎
While these suggestions prevent trivial use of this API for user tracking, they do not block it altogether. Within a single domain, a site can continue to track the user during a session, and can then pass all this information to the third party along with any identifying information (names, credit card numbers, addresses) obtained by the site. If a third party cooperates with multiple sites to obtain such information, a profile can still be created.
</p>

<p>
しかしながら，利用者~追跡は、
~UAからの協力が一切なくても，ある~~範囲までアリになる
— 一例として，~URL内に~session識別子を利用するなど。
この技法は、
差し障りない目的で すでに共通的に利用されているが、
利用者~追跡にも容易に（遡及的にすら）転用できる。
しかる後，この情報は、
他~siteと共有され得る
— 訪問者の IP ~addressその他の，利用者に特有な~data
（例： user-agent ~headerや環境設定）
を利用して、
別々な~sessionを首尾一貫した利用者~profileを成すように組合せることにより。
◎
However, user tracking is to some extent possible even with no cooperation from the user agent whatsoever, for instance by using session identifiers in URLs, a technique already commonly used for innocuous purposes but easily repurposed for user tracking (even retroactively). This information can then be shared with other sites, using visitors' IP addresses and other user-specific data (e.g. user-agent headers and configuration settings) to combine separate sessions into coherent user profiles.
</p>
		</section>
		<section id="cookie-resurrection">
<h3 title="Cookie resurrection">8.2. ~cookieの復活</h3>

<p>
持続的な~storage用の~UIが、
この仕様に述べた特能による持続的な~storageの~dataを~HTTP~session~cookieの~dataと別々に呈示する場合、
利用者は，一方の~dataしか削除しない可能性が高い。
そうすると~siteは、
2 つの特能を互いの冗長~backupに利用して，利用者による~privacyを保護する試みを打破できるようにもなる。
◎
If the user interface for persistent storage presents data in the persistent storage features described in this specification separately from data in HTTP session cookies, then users are likely to delete data in one and not the other. This would allow sites to use the two features as redundant backup for each other, defeating a user’s attempts to protect his privacy.
</p>
		</section>
		<section id="sensitivity-of-data">
<h3 title="Sensitivity of data">8.3. ~dataの敏感~性</h3>

<p>
~UAは、
持続的に格納された~dataを，敏感になり得るものと扱うべきである
— この仕組み内に［
メール ／ 予定表 ／ 健康診断記録
］その他の機密的~文書が格納されることは、
ごく普通にあり得る。
◎
User agents should treat persistently stored data as potentially sensitive; it is quite possible for e-mails, calendar appointments, health records, or other confidential documents to be stored in this mechanism.
</p>

<p>
ゆえに、
~UAは、
~dataを削除するときには，下層の~storageからも即座に削除されることを確保するべきである。
◎
To this end, user agents should ensure that when deleting data, it is promptly deleted from the underlying storage.
</p>
		</section>
	</section>
	<section id="security">
<h2 title="Security considerations">9. ~securityの考慮点</h2>

		<section id="dns-spoofing-attacks">
<h3 title="DNS spoofing attacks">9.1. DNS 偽装~攻撃</h3>

<p>
DNS 偽装~攻撃の~~可能性があるので、
ある~domainに属すると主張している~hostが本当にその~domainなのかは，保証できない。
これを軽減するため、
~pageは TLS を利用できる。
TLS を利用している~pageは、
その~domainの~dbに~accessできる~pageは［
TLS を利用していて, 同じ~domainを識別する証明書を持つもの
］に限られることを確保できる。
◎
Because of the potential for DNS spoofing attacks, one cannot guarantee that a host claiming to be in a certain domain really is from that domain. To mitigate this, pages can use TLS. Pages using TLS can be sure that only pages using TLS that have certificates identifying them as being from the same domain can access their databases.
</p>
		</section>
		<section id="cross-directory-attacks">
<h3 title="Cross-directory attacks">9.2. ~cross-directory攻撃</h3>

<p>
同じ~host名
— 例えば `geocities.com^c —
を共有している作者たちは、
同じ~dbの集合を共有する。
◎
Different authors sharing one host name, for example users hosting content on geocities.com, all share one set of databases.
</p>

<p>
~accessを~URL~pathに基いて制約する特能は無い。
したがって、
共有d~host上の作者には、
これらの特能を利用しないことが推奨される
— 他の作者が，その~dataを読取ったり上書できるのは自明なので。
◎
There is no feature to restrict the access by pathname. Authors on shared hosts are therefore recommended to avoid using these features, as it would be trivial for other authors to read the data and overwrite it.
</p>

<p class="note">注記：
~pathによる制約の特能が可用にされたとしても、
通例の~DOM ~scriptにおける~security~modelの下では，この保護を迂回して任意の~pathから~dataへ~accessすることは自明になる。
◎
Even if a path-restriction feature was made available, the usual DOM scripting security model would make it trivial to bypass this protection and access the data from any path.
</p>
		</section>
		<section id="implementation-risks">
<h3 title="Implementation risks">9.3. 実装にあたっての~risk</h3>

<p>
これらの持続的な~storage用の特能を実装するにあたっては、
2 つの首な~risk
— 敵対的~siteが［
他の~domainから情報を読取る ／
情報を書込んで他の~domainに読取らせる
］こと —
がある：
◎
The two primary risks when implementing these persistent storage features are letting hostile sites read information from other domains, and letting hostile sites write information that is then read from other domains.
</p>

<ul>
	<li>
第三者-主体~siteが，その~domainから読取られるものと~~想定されていないような~dataを読取れるようになれば、
`情報~漏洩e^emになる。
例えば，ある購買~site~domainの，利用者の “欲しい物リスト” が、
別の~domainにより~targeted広告に利用されたり，あるいは、
文書作成~siteに格納された，利用者が作業中の機密的~文書を，競合企業~siteが覗き見ることも可能になる。
◎
Letting third-party sites read data that is not supposed to be read from their domain causes information leakage, For example, a user’s shopping wish list on one domain could be used by another domain for targeted advertising; or a user’s work-in-progress confidential documents stored by a word-processing site could be examined by the site of a competing company.
</li>
	<li>
第三者-主体~siteが，他の~domainの持続的な~storageに~dataを書込めるようになれば、
`情報~偽装^em（なりすまし）になり，同等に危険である。
例えば，敵対的~siteは、
利用者の “欲しい物リスト” に~recordを追加したり、
利用者の~session識別子を既知な ID に設定して，利用者の被害者~siteにおける行動を追跡するためにそれを利用することも可能になる。
◎
Letting third-party sites write data to the persistent storage of other domains can result in information spoofing, which is equally dangerous. For example, a hostile site could add records to a user’s wish list; or a hostile site could set a user’s session identifier to a known ID that the hostile site can then use to track the user’s actions on the victim site.
</li>
</ul>

<p>
したがって、
この仕様に述べられる生成元~modelに厳密に従うことは、
利用者の~securityにとって重要である。
◎
Thus, strictly following the origin model described in this specification is important for user security.
</p>

<p>
~file~systemにおける持続性のために［
生成元や~dbの名前
］を利用して~pathを構築する場合、
敵対者が［
`../^l などの相対~pathを利用している他の生成元
］から情報に~accessするのを防止するため、
適切に~escapeするモノトスル。
◎
If origins or database names are used to construct paths for persistence to a file system they must be appropriately escaped to prevent an adversary from accessing information from other origins using relative paths such as "../".
</p>

		</section>
		<section id="persistence-risks">
<h3 title="Persistence risks">9.4. 持続性の~risk</h3>

<p>
実用的な実装は、
不揮発~storage媒体に~dataを持続化することになる。
~dataは、
格納-時に直列化され，検索取得-時に逆直列化されることになる
— 直列化~形式の詳細は、
~UAに特有になるが。
~UAの直列化~形式は、
時を経れば変更される可能性が高い。
例えば、［
新たな~data型を取扱う／処理能を改善する
］ため，形式は更新されることもある。
したがって、
この仕様の運用上の要件を満たすためには、
実装は，何らかの仕方で旧~直列化~形式を取扱えるモノトスル。
旧~dataの不適正な取扱いは、
基本的な直列化の懸念に加えて，~security上の課題にもなり得る。
直列化された旧~dataは、［
~versionが新しくされた~UAの下では妥当でない，形式
］を符号化しかねない。
◎
Practical implementations will persist data to a non-volatile storage medium. Data will be serialized when stored and deserialized when retrieved, although the details of the serialization format will be user-agent specific. User agents are likely to change their serialization format over time. For example, the format may be updated to handle new data types, or to improve performance. To satisfy the operational requirements of this specification, implementations must therefore handle older serialization formats in some way. Improper handling of older data can result in security issues. In addition to basic serialization concerns, serialized data could encode assumptions which are not valid in newer versions of the user agent.
</p>

<p>
実用的な例として、
`RegExp$jT 型が挙げられる
— その型の~objも `StructuredSerializeForStorage$jA 演算で直列化できる。
代表的な~UAは、
入力~dataが渡され, 結果が返される方法を前提に，正規表現を~machineに~nativeな~~命令に~compileすることになる。
この内部~状態が~dbに格納された~dataの一部として直列化されていた場合、
内部~表現が後で逆直列化されるときに様々な問題が生じることもある。
例えば、
~dataが~codeの中へ渡される手段は変更されるかもしれない。
~compiler出力における~security~bugは，~UAの更新~時に識別され修正できようが、
直列化された内部~状態は残り続ける。
◎
A practical example of this is the RegExp type. The StructuredSerializeForStorage operation allows serializing RegExp objects. A typical user agent will compile a regular expression into native machine instructions, with assumptions about how the input data is passed and results returned. If this internal state was serialized as part of the data stored to the database, various problems could arise when the internal representation was later deserialized. For example, the means by which data was passed into the code could have changed. Security bugs in the compiler output could have been identified and fixed in updates to the user agent, but remain in the serialized internal state.
</p>

<p>
~UAは、
旧~dataを適切に識別して取扱えるモノトスル。
~approachの一例としては、
直列化~形式~内に~version識別子を含ませておき，旧~dataに遭遇したときは，~scriptから可視な状態から内部~状態を構築し直すことが挙げられる。
◎
User agents must identify and handle older data appropriately. One approach is to include version identifiers in the serialization format, and to reconstruct any internal state from script-visible state when older data is encountered.
</p>
		</section>
	</section>
	<section id="accessibility">
<h2 title="Accessibility considerations">10. ~accessibilityの考慮点</h2>

~INFORMATIVE

<p>
この仕様が述べる~APIに対する~accessibilityの考慮点は、
以下のように制限される：
◎
The API described by this specification has limited accesibility considerations:
</p>

<ul>
	<li>
内容の視覚的な具現化／色に対する制御は、
供さない。
◎
It does not provide for visual rendering of content, or control over color.
</li>
	<li>
利用者~入力を受容する特能は、
供さない。
◎
It does not provide features to accept user input.
</li>
	<li>
利用者とヤリトリする特能は、
供さない。
◎
It does not provide user interaction features.
</li>
	<li>
文書の意味論は定義しない。
◎
It does not define document semantics.
</li>
	<li>
時間に基づく視覚-~mediaは、
供さない。
◎
It does not provide time-based visual media.
</li>
	<li>
時間~制限sは許容しない。
◎
It does not allow time limits.
</li>
	<li>
末端利用者~向け内容は、
直に供さない
— ~textな形でも，~graphicな形など他の形でも。
◎
It does not directly provide content for end-users, either in textual, graphical or other or non-textual form.
</li>
	<li>
伝送~protocolは定義しない。
◎
It does not define a transmission protocol.
</li>
</ul>

<p>
この~APIは、
有構造~内容の~storageを許容する。
~textな内容は文字列として格納できる。
この~APIには、
画像や音声などの他の代替な内容を［
`Blob$I ／ `File$I ／ `ImageData$I 
］~objとして格納する開発者~向け~supportは存在する。
この~APIを利用して動的な内容~appを制作している開発者は、
当の内容は様々な技術や必要性により利用者から~access可能になることを確保するベキである。
◎
The API does allow storage of structured content. Textual content can be stored as strings. Support exists in the API for developers to store alternative non-textual content such as images or audio as Blob, File, or ImageData objects. Developers producing dynamic content applications using the API should ensure that the content is accessible to users with a variety of technologies and needs.
</p>

<p>
この~API自身は，国際-化に特有な仕組みは定義しないが、
有構造~内容の~storageは，［
異なる~recordや構造を利用して，~recordの中に各 言語~代替を保持することで、
国際-化された内容を格納する
］ことも開発者に許容する。
◎
While the API itself does not define a specific mechanism for it, storage of structured content also allows developers to store internationalized content, using different records or structure within records to hold language alternatives.
</p>

<p>
この~APIは、
この~APIとのヤリトリを可能化する~UIを どう生成するかは定義しないし，それを~UAに要求することもない。
~UAは、
任意選択で，この~APIを~supportする~UI要素を供してもヨイ。
例：［
追加的な~storage~quotaが要求されるとき，利用者に~promptする ／
特定0の~web~siteが利用している~storageを観測する機能性 ／
~recordを［
検分する／改変する／削除する
］など，~APIの~storageに特有な~tool
］。
そのような~UI要素は、
~accessibility~toolを念頭に設計するモノトスル。
例えば，利用される~storage~quotaの~~一部分を~graphicな形で呈示している~UIは、
~screen-readerなどの~toolにも同じ~dataを供するモノトスル。
◎
The API does not define or require any a user agent to generate a user interface to enable interaction with the API. User agents may optionally provide user interface elements to support the API. Examples include prompts to users when additional storage quota is required, functionality to observe storage used by particular web sites, or tools specific to the API’s storage such as inspecting, modifying, or deleting records. Any such user interface elements must be designed with accessibility tools in mind. For example, a user interface presenting the fraction of storage quota used in graphical form must also provide the same data to tools such as screen readers.
</p>

	</section>
	<section id="revision-history">
<h2 title="Revision history">11. 改訂~履歴</h2>

~INFORMATIVE

<p>
以下は、
この仕様の最後の公表版からの変更点の要約である。
<a href="https://github.com/w3c/IndexedDB/">完全な改訂~履歴</a> ／
<a href="~TR/IndexedDB/#revision-history">第 1 版の改訂~履歴</a> ／
<a href="~TR/IndexedDB-2/#revision-history">第 2 版の改訂~履歴</a>
◎
The following is an informative summary of the changes since the last publication of this specification. A complete revision history can be found here. For the revision history of the first edition, see that document’s Revision History. For the revision history of the second edition, see that document’s Revision History.
</p>

<ul>
	<li>
他の仕様との統合~用に、
`索引付き~db~txを片付ける$~algoは値を返すようにした。
（<a href="https://github.com/w3c/IndexedDB/pull/232">pull#232</a>）
◎
The cleanup Indexed Database transactions algorithm now returns a value for integration with other specs. (PR #232)
</li>
	<li>
`WindowOrWorkerGlobalScope$I は今や~mixinになったので、
部分的~interface定義を更新した。
（<a href="https://github.com/w3c/IndexedDB/pull/238">pull#238</a>）
◎
Updated partial interface definition since WindowOrWorkerGlobalScope is now a mixin (PR #238).
</li>
	<li>
`IDBFactory!I に `databases()$m ~methodを追加した。
（ `31$issue ）

◎
Added databases() method. (Issue #31)
</li>
	<li>
`IDBTransaction!I に `commit()$m ~methodを追加した。
（ `234$issue ）
◎
Added commit() method. (Issue #234)
</li>
	<li>
`IDBCursor!I に `request$m 属性を追加した。
（ `255$issue ）
◎
Added request attribute. (Issue #255)
</li>
	<li>
`File$I ~objから標準でない `lastModifiedDate^m ~propの取扱いを除去した。
（ `215$issue ）
◎
Removed handling for nonstandard lastModifiedDate property of File objects. (Issue #215)
</li>
	<li>
`includes()^m ~methodの識別子に対する~escapeを除去した。
（ `294$issue ）
◎
Remove escaping includes() method. (Issue #294)
</li>
	<li>
`配列~key$を`~Array~exotic~obj$に制約した
（すなわち、
`Proxy^jT ~objを許容しないようにした）。
（ `309$issue ）
◎
Restrict array keys to Array exotic objects (i.e. disallow proxies). (Issue #309)
</li>
	<li>
~clone演算の間は、
~txは一時的に `非作動中$i になるようにした。
◎
Transactions are now temporarily made inactive during clone operations.
</li>
	<li>
`durability$mb ~optionと `durability^m 属性を追加した。
（ `50$issue ）
◎
Added durability option and durability attribute. (Issue #50)
</li>
	<li>
<a href="#transaction-scheduling">§ ~txの~schedule法</a>をもっと精確に指定した。
`視野が重合して$いる`~readonly~tx$が稼働している間は、
`~readwrite~tx$は開始できないようにした。
（ `253$issue ）
◎
Specified § 2.7.2 Transaction scheduling more precisely and disallow starting read/write transactions while read-only transactions with overlapping scope are running. (Issue #253)
</li>
	<li>
<a href="#accessibility">§ ~accessibilityの考慮点</a>
を追加した。
（ `327$issue ）
◎
Added Accessibility considerations section. (Issue #327)
</li>
	<li>
`infra$r の~list~sort法の定義を利用するようにした。
（ `346$issue ）
◎
Used [infra]'s list sorting definition. (Issue #346)
</li>
</ul>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">12. 謝辞</h2>

~INFORMATIVE

<p>
この仕様の第１版の元々の作者である `Nikunj Mehta^en 氏に特に感謝する。
次の方々，並びに第１版の他の編集者たちにも。
</p>

<p lang="en">
Special thanks to Nikunj Mehta, the original author of the first edition, and Jonas Sicking, Eliot Graff, Andrei Popescu, and Jeremy Orlow, additional editors of the first edition.
</p>

<p>
この仕様の設計に極めて影響力があった `Garret Swart^en 氏に。
◎
Garret Swart was extremely influential in the design of this specification.
</p>

<p>
この文書の作成-時に利用した 仕様~著作~tool `Bikeshed^en を作成-／保守され，一般的な著作~法を~~助言された `Tab Atkins, Jr.^en 氏に。
◎
Thanks to Tab Atkins, Jr. for creating and maintaining Bikeshed, the specification authoring tool used to create this document, and for his general authoring advice.
</p>

<p>
~feedbackと提言を寄せられ，この仕様を向上させた，次の方々に特別な謝意を：
</p>

<p lang="en">
Special thanks to

Chris Anderson,
Jake Archibald,
Yannic Bonenberger,
Andreas Butler,
Pablo Castro,
Victor Costan,
Kristof Degrave,
Domenic Denicola,
Jake Drew,
Ben Dilts,
João Eiras,
Alec Flett,
Dana Florescu,
David Grogan,
Israel Hilerio,
Jerome Hode,
Kyle Huey,
Philip Jägenstedt,
Laxminarayan G Kamath A,
Anne van Kesteren,
Adam Klein,
Marijn Kruisselbrink,
Tobie Langel,
Kang-Hao Lu,
Andrea Marchesini,
Josh Matthews,
Glenn Maynard,
Isiah Meadows,
Ms2ger,
Odin Omdal,
Danillo Paiva,
Olli Pettay,
Addison Phillips,
Simon Pieters,
Anthony Ramine,
Yonathan Randolph,
Arun Ranganathan,
Kagami Sascha Rosylight,
Margo Seltzer,
Maciej Stachowiak,
Andrew Sutherland,
Yaron Tausky,
Bevis Tseng,
Ben Turner,
Kyaw Tun,
Adrienne Walker,
Hans Wennborg,
Shawn Wilsher,
Brett Zamir,
Boris Zbarsky,
Zhiqiang Zhang, and
Kris Zyp,

all of whose feedback and suggestions have led to improvements to this specification.
</p>

	</section>
</main></div>

