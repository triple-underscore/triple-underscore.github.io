<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Indexed Database API 3.0 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">

<style>

table._row > thead > tr {
	border-bottom: solid medium var(--N-color);
}
table._row > tbody > tr {
	border-bottom: solid thin var(--N-color);
}

#_hierarchy td {
	text-align: center;
	border: none;
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let idl_ifc = '';

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let quote;
let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'I':
	if((indicator === '@') || (indicator === '!')){
		idl_ifc = key;
	}
	href = `#dom-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/(\w+)(\s=\s["\w]+)?/g, '<var>$1</var>$2');
}
	href = key.indexOf('.');
	if(href >=0 ){
		href = `${key.slice(0, href)}-${key.slice(href + 1)}`;
//		console.log(href);
	} else {
		href = (key === idl_ifc) ? idl_ifc : `${idl_ifc}-${key}`;
	}
	href = `#dom-${href.toLowerCase()}`;
	break;
case 'E':
	href = `#_${key}`;
	break;
case 'sl':
	text = `[[${text}]]`;
	break;
case 'l':
	quote = '"'
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`
	break;
case 'issue':
	href = `~IDBISSUES/${key}`;
	text = `課題 #${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}


if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return (quote ? quote + text + quote : text);

	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Indexed Database API 3.0
spec_date:2025-08-12
trans_update:2025-08-13
source_checked:250731
original_url:https://w3c.github.io/IndexedDB/
	abbr_url:INDEXEDDB
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:storage
conformance:w3c
copyright:2025,permissive
trans_1st_pub:2015-08-06


●●class_map
e:element
a:attr
et:event-type
E:error
l:literal
sl:js-slot
jT:js-type
jv:js-value
js:js-other
jA:abstract
U:code-point

●●tag_map
I:code
m:code
mF:code
mb:code
et:code
E:code
l:code
e:code
i:i
p:code
c:code
sl:span
jT:code
jv:code
js:code
jA:span
U:span
em:em
sub:sub
cite:cite

●●original_id_map

	index-list-of-records:index-records
	index-list-of-records:index-keys
	index-list-of-records:index-values
	object-store-record:object-store-list-of-records


●●mdn_urls
idbcursor:API/IDBCursor
idbcursorwithvalue:API/IDBCursorWithValue
idbdatabase:API/IDBDatabase
idbfactory:API/IDBFactory
idbindex:API/IDBIndex
idbkeyrange:API/IDBKeyRange
idbobjectstore:API/IDBObjectStore
idbopendbrequest:API/IDBOpenDBRequest
idbrequest:API/IDBRequest
idbtransaction:API/IDBTransaction
idbversionchangeevent:API/IDBVersionChangeEvent
	dictdef-idbdatabaseinfo:API/IDBDatabaseInfo
	dictdef-idbindexparameters:API/IDBIndexParameters
	dictdef-idbobjectstoreparameters:API/IDBObjectStoreParameters
	dictdef-idbtransactionoptions:API/IDBTransactionOptions
	dictdef-idbversionchangeeventinit:API/IDBVersionChangeEventInit
	enumdef-idbcursordirection:API/IDBCursorDirection
	enumdef-idbrequestreadystate:API/IDBRequestReadyState
	enumdef-idbtransactionmode:API/IDBTransactionMode

eventdef-idbdatabase-versionchange:API/IDBDatabase/versionchange_event
eventdef-idbdatabase-close:API/IDBDatabase/close_event
eventdef-idbopendbrequest-upgradeneeded:API/IDBOpenDBRequest/upgradeneeded_event
eventdef-idbopendbrequest-blocked:API/IDBOpenDBRequest/blocked_event
eventdef-idbrequest-success:API/IDBRequest/success_event
eventdef-idbrequest-error:API/IDBRequest/error_event
eventdef-idbtransaction-complete:API/IDBTransaction/complete_event
eventdef-idbtransaction-abort:API/IDBTransaction/abort_event

●●link_map


専属する:#_belong
専属しない:#_belong
値を保ち続ける:#_remain
可換性:#_commutative-requirement
一意性:#_uniqueness-requirement
~access先:#_to-access

	●IDL
Exposed:~WEBIDLjs#Exposed
EnforceRange:~WEBIDLjs#EnforceRange
SameObject:~WEBIDLjs#SameObject
NewObject:~WEBIDLjs#NewObject

E.TypeError:~WEBIDL#exceptiondef-typeerror
E.SecurityError:~WEBIDL#securityerror
	E.AbortError
	E.ConstraintError
	E.DataCloneError
	E.DataError
	E.InvalidAccessError
	E.InvalidStateError
	E.NotFoundError
	E.NotReadableError
	E.QuotaExceededError
	E.SyntaxError
	E.ReadOnlyError
	E.TransactionInactiveError
	E.UnknownError
	E.VersionError

~SeqDS:~WEBIDL#idl-sequence
~SeqAny:~WEBIDL#idl-sequence

undefined:~WEBIDL#idl-undefined
any:~WEBIDL#idl-any
DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean
unsigned long long:~WEBIDL#idl-unsigned-long-long
unsigned long:~WEBIDL#idl-unsigned-long
Promise:~WEBIDL#idl-promise
sequence:~WEBIDL#idl-sequence
I.DOMString:~WEBIDL#idl-DOMString
I.unrestricted double:~WEBIDL#idl-unrestricted-double
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array

I.IDBCursor:#idbcursor
I.IDBCursorDirection:#enumdef-idbcursordirection
I.IDBCursorWithValue:#idbcursorwithvalue
I.IDBDatabase:#idbdatabase
I.IDBFactory:#idbfactory
I.IDBDatabaseInfo:#dictdef-idbdatabaseinfo
I.IDBGetAllOptions:#dictdef-idbgetalloptions
I.IDBIndex:#idbindex
I.IDBIndexParameters:#dictdef-idbindexparameters
I.IDBKeyRange:#idbkeyrange
I.IDBObjectStore:#idbobjectstore
I.IDBObjectStoreParameters:#dictdef-idbobjectstoreparameters
I.IDBOpenDBRequest:#idbopendbrequest
I.IDBRecord:#idbrecord
I.IDBRequest:#idbrequest
I.IDBRequestReadyState:#enumdef-idbrequestreadystate
I.IDBTransaction:#idbtransaction
I.IDBTransactionMode:#enumdef-idbtransactionmode
I.IDBTransactionOptions:#dictdef-idbtransactionoptions
I.IDBVersionChangeEvent:#idbversionchangeevent
I.IDBVersionChangeEventInit:#dictdef-idbversionchangeeventinit

I.DOMStringList:~HTMLcdom#domstringlist

I.Blob:~FILEAPI#blob
I.File:~FILEAPI#file
I.QuotaExceededError:~WEBIDL#quotaexceedederror
I.DOMException:~WEBIDL#idl-DOMException
	I.Document:~HTMLdom#document
I.Document:~DOM4#document
I.Event:~DOM4#event
I.Event:~DOM4#concept-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.EventHandler:~WAPI#eventhandler
I.ImageData:~HTMLGAPI#imagedata
I.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope

constructor:#dom-idbversionchangeevent-idbversionchangeevent

m.close:#dom-idbdatabase-close
m.indexedDB:#dom-windoworworkerglobalscope-indexeddb
m.result:#dom-idbrequest-result
	m.error:#dom-idbrequest-error

m.domain:~ORIGIN#dom-document-domain
m.preventDefault:~DOM4#dom-event-preventdefault
m.bubbles:~DOM4#dom-event-bubbles
m.type:~DOM4#dom-event-type
m.cancelable:~DOM4#dom-event-cancelable

mF.size:~FILEAPI#dfn-size
mF.lastModified:~FILEAPI#dfn-lastModified
mF.name:~FILEAPI#dfn-name
mF.type:~FILEAPI#dfn-type

	●dict
mb.durability:#dom-idbtransactionoptions-durability
mb.keyPath:#dom-idbobjectstoreparameters-keypath
mb.autoIncrement:#dom-idbobjectstoreparameters-autoincrement
mb.unique:#dom-idbindexparameters-unique
mb.multiEntry:#dom-idbindexparameters-multientry
mb.query:#dom-idbgetalloptions-query
mb.count:#dom-idbgetalloptions-count
mb.direction:#dom-idbgetalloptions-direction

	●enum
l.done:#dom-idbrequestreadystate-done
l.pending:#dom-idbrequestreadystate-pending

l.next:#dom-idbcursordirection-next
l.nextunique:#dom-idbcursordirection-nextunique
l.prev:#dom-idbcursordirection-prev
l.prevunique:#dom-idbcursordirection-prevunique

l.readonly:#dom-idbtransactionmode-readonly
l.readwrite:#dom-idbtransactionmode-readwrite
l.versionchange:#dom-idbtransactionmode-versionchange

l.strict:#dom-idbtransactiondurability-strict
l.relaxed:#dom-idbtransactiondurability-relaxed
l.default:#dom-idbtransactiondurability-default

et.versionchange:#eventdef-idbdatabase-versionchange
et.close:#eventdef-idbdatabase-close
et.complete:#eventdef-idbtransaction-complete
et.abort:#eventdef-idbtransaction-abort
et.upgradeneeded:#eventdef-idbopendbrequest-upgradeneeded
et.blocked:#eventdef-idbopendbrequest-blocked
阻まれ:#eventdef-idbopendbrequest-blocked
et.success:#eventdef-idbrequest-success
et.error:#eventdef-idbrequest-error

	●js
~Record:~TC39#sec-list-and-record-specification-type
	誤）~WEBIDL#idl-record
中途完了:~TC39M/ecmascript-data-types-and-values.html#sec-completion-record-
~NOABRUPT:~TC39#sec-algorithm-conventions
~Array~exotic~obj:~TC39M/ordinary-and-exotic-objects-behaviours.html#array-exotic-object

jT.Array:~TC39M/indexed-collections.html#sec-array-objects
jT.Date:~TC39M/numbers-and-dates.html#sec-date-objects
jT.Number:~TC39M/numbers-and-dates.html#sec-number-objects
jT.Object:~TC39M/fundamental-objects.html#sec-object-objects
jT.String:~TC39M/text-processing.html#sec-string-objects
jT.RegExp:~TC39M/text-processing.html#sec-regexp-regular-expression-objects

jA.CreateDataProperty:~TC39M/abstract-operations.html#sec-createdataproperty
jA.Type:~TC39#sec-ecmascript-data-types-and-values
jA.ReturnIfAbrupt:~TC39#sec-returnifabrupt
jA.ToString:~TC39M/abstract-operations.html#sec-tostring
jA.ToLength:~TC39M/abstract-operations.html#sec-tolength
jA.Get:~TC39M/abstract-operations.html#sec-get-o-p
jA.HasOwnProperty:~TC39M/abstract-operations.html#sec-hasownproperty

	＠~TC39#prod-IdentifierName


	●es 言語束縛
jA.StructuredSerializeForStorage:~HTMLcloning#structuredserializeforstorage
jA.StructuredSerialize:~HTMLcloning#structuredserialize
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
直列化-可能:~HTMLcloning#serializable-objects
~realm:~TC39M/executable-code-and-execution-contexts.html#realm
現在の~realm:~TC39M/executable-code-and-execution-contexts.html#current-realm

~txの間に値を~cloneする:#clone
~keyを値の中へ注入できるか検査する:#check-that-a-key-could-be-injected-into-a-value
~keyを値の中へ注入する:#inject-a-key-into-a-value-using-a-key-path

値から~keyを抽出する:#extract-a-key-from-a-value-using-a-key-path
抽出される~key:#_ExtractedKeys
値から~key集合を抽出する:#_extract-keys-from-a-value
~keyを値に変換する:#convert-a-key-to-a-value
値を~keyに変換する:#convert-a-value-to-a-key
~key~pathを評価する:#evaluate-a-key-path-on-a-value
配列を~key集合に変換する:#convert-a-value-to-a-multientry-key

Key:#_X-Key
Value:#_X-Value
Extract:#_X-Extract
状態を検査する:#_X-CheckState
Dispatch:#_X-Dispatch

名前:#name
~sort済み名前~listを作成する:#create-a-sorted-name-list

	●database, 接続
~db:#database
db.名前:#database-name
db.~version:#database-version
db.昇格~tx:#database-upgrade-transaction

~db~access~task~source:#database-access-task-source
~db~taskを~queueする:#queue-a-database-task

接続:#connection
	接続先~db:#connection
Cn.~version:#connection-version
Cn.保管庫~集合:#connection-object-store-set
Cn.状態:#connection-close-pending-flag
	~close待ちか:#connection-close-pending-flag
i.~open中:#connection-opened
i.~close済み:#connection-closed
i.~close待ち:#connection-close
~close:#connection-closed

接続~queue:#connection-queue

	●transaction
~tx:#transaction-concept
tx.接続:#transaction-connection
	専属する接続:#transaction-connection
視野:#transaction-scope
視野が重合して:#transaction-overlap
~mode:#transaction-mode

tx.状態:#transaction-state
i.~commit中:#transaction-committing
i.非作動中:#transaction-inactive
i.作動中:#transaction-active
i.完遂d:#transaction-finished
完遂-:#transaction-finished
生きて:#transaction-live

耐久能~hint:#transaction-durability-hint
片付ける~event~loop:#transaction-cleanup-event-loop
索引付き~db~txを片付ける:#cleanup-indexed-database-transactions
要請~list:#transaction-request-list
tx.~error:#transaction-error
存続期間:#transaction-lifetime
作成-:#transaction-created
開始-:#transaction-start
中止-:#transaction-abort
~commit:#transaction-commit
昇格~tx:#upgrade-transaction
昇格~txの中:#_within-an-upgrade-transaction
昇格~txの外:#_within-an-upgrade-transaction

~readwrite~tx:#transaction-read-write-transaction
~readonly~tx:#transaction-read-only-transaction


	●要請
要請:#request
済んだか:#request-done-flag
~source:#request-source
結果:#request-result
~error:#request-error
~open要請:#request-open-request
演算:#_operation
設置-先~tx:#request-transaction
設置-:#request-placed
処理-済み:#request-processed
処理-済みか:#request-processed-flag


	●保管庫, 索引
保管庫:#object-store
Os.~record~list:#object-store-list-of-records
	Os.~record:#object-store-record
Os.名前:#object-store-name
Os.~key~path:#object-store-key-path
	#object-store-in-line-keys
	#object-store-out-of-line-keys

保管庫~handle:#object-store-handle
OsH.保管庫:#object-store-handle-object-store
OsH.索引~集合:#object-store-handle-index-set
OsH.名前:#object-store-handle-name
OsH.専属する~tx:#object-store-handle-transaction
OsH.~tx:#object-store-handle-transaction

索引:#index-concept
参照-:#index-referenced
参照先の保管庫:#index-referenced
参照先の値:#index-referenced-value
参照先~record:#_index-referenced-record
Ix.~record~list:#index-list-of-records
	Ix.~record:#index-records
	Ix.~key:#index-keys
	Ix.値:#index-values
Ix.~key~path:#index-key-path
Ix.名前:#index-name
Ix.一意か:#index-unique-flag
Ix.複-~entryか:#index-multientry-flag

	＊未利用

索引~handle:#index-handle
IxH.索引:#index-handle-index
IxH.名前:#index-handle-name
IxH.保管庫~handle:#index-handle-object-store-handle
IxH.~tx:#index-handle-transaction

	●crusor
~cursor:#cursor
Cs.範囲:#cursor-range
Cs.~source~handle:#cursor-source-handle
Cs.~source:#cursor-source
Cs.方向:#cursor-direction
Cs.~tx:#cursor-transaction
Cs.位置:#cursor-position
Cs.保管庫~位置:#cursor-object-store-position
Cs.~key:#cursor-key
Cs.値:#cursor-value
Cs.値は取得-済みか:#cursor-got-value-flag
Cs.実効~保管庫:#cursor-effective-object-store
Cs.実効~key:#cursor-effective-key
Cs.要請:#cursor-request
Cs.~keyのみか:#cursor-key-only-flag


	●record, value, key, key範囲, key path
~record:#_record
値:#value
~key:#key

~record~snapshot:#record-snapshot
rS.~key:#record-snapshot-key
rS.値:#record-snapshot-value
rS.首key:#record-snapshot-primary-key

i.number:#_keytype-number
i.date:#_keytype-date
i.string:#_keytype-string
i.binary:#_keytype-binary
i.array:#_keytype-array


~key範囲:#key-range
下界:#key-range-lower-bound
上界:#key-range-upper-bound
下界openか:#key-range-lower-open-flag
上界openか:#key-range-upper-open-flag
入る:#in
全範囲:#unbounded-key-range
~keyのみを包含する範囲:#containing-only
~key範囲へ変換する:#convert-a-value-to-a-key-range
表現する~key範囲:#convert-a-value-to-a-key-range
妥当な~key範囲になり得る:#potentially-valid-key-range
妥当な~key範囲になり得るか否か:#is-a-potentially-valid-key-range

~key生成器:#key-generator
現在の番号:#key-generator-current-number
最大な番号:#_max-number
		NUMBER.MAX_SAFE_INTEGER
		9007199254740992

key.型:#key-type
key.値:#key-value
配列~key:#array-key
下位key:#subkeys
~keyどうしを比較する:#compare-two-keys
昇順:#greater-than
より大きい:#greater-than
より小さい:#less-than
等しい:#equal-to
等しく:#equal-to
~key~path:#key-path
妥当な~key~path:#valid-key-path
識別子:#identifier


	●手続き

addするかputする:#add-or-put

保管庫~用の~keyを生成する:#generate-a-key
保管庫~用の~key生成器を可能なら更新する:#possibly-update-the-key-generator

	event
~success~eventを発火する:#fire-a-success-event
~error~eventを発火する:#fire-an-error-event
~version変更~eventを発火する:#fire-a-version-change-event

~db接続を~openする:#open-a-database-connection
~db接続を~closeする:#close-a-database-connection
~dbを削除する:#delete-a-database

~txを~commitする:#commit-a-transaction
~txを~commit:#commit-a-transaction
~txを中止する:#abort-a-transaction
~txを中止-:#abort-a-transaction

要請を非同期に実行する:#asynchronously-execute-a-request
非同期に実行する:#asynchronously-execute-a-request

~dbを昇格する:#upgrade-a-database
昇格~txを中止する:#abort-an-upgrade-transaction
昇格~txが中止-:#abort-an-upgrade-transaction

保管庫に~recordを格納する:#store-a-record-into-an-object-store

範囲に入る最初の~entryを検索取得する:#_retrieve-a-x-from-y
複数個の~itemを検索取得する要請を作成する:#create-a-request-to-retrieve-multiple-items
保管庫から複数個の~itemを検索取得する:#retrieve-multiple-items-from-an-object-store
索引から複数個の~itemを検索取得する:#retrieve-multiple-items-from-an-index



保管庫から~recordを削除する:#delete-records-from-an-object-store
範囲に入る~recordを数える:#count-the-records-in-a-range
保管庫を~clearする:#clear-an-object-store

~cursorを反復する:#iterate-a-cursor
~cursorを作成する:#_crtate-a-cursor

	LI:#version-change-close-block
	LI:#delete-close-block
（旧来の）~listenerは投出したか:#_legacyOutputDidListenersThrowFlag

この版:#revision-history

	●外部
新たな~obj:~WEBIDLjs#new
新たな~promise:~WEBIDLjs#a-new-promise
~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve
却下される~promise:~WEBIDLjs#a-promise-rejected-with
所与の値:~WEBIDL#the-given-value
切離されて:~WEBIDLjs#buffersource-detached
投出-:~WEBIDL#dfn-throw
新たな例外:~WEBIDL#dfn-create-exception
~buffer~source型:~WEBIDL#idl-buffer-source-types
	~buffer~source型:~WEBIDL#dfn-buffer-source-type
保持された~byte列の複製を取得する:~WEBIDLjs#dfn-get-buffer-source-copy

区切子で厳密に分割する:~INFRA#strictly-split
~byte:~INFRA#byte
~byte列:~INFRA#byte-sequence
byte.長さ:~INFRA#byte-sequence-length
未満の符号単位~列:~INFRA#code-unit-less-than
未満の~byte列:~INFRA#byte-less-than
str.長さ:~INFRA#string-length

~list:~INFRA#list
~size:~INFRA#list-size
~item:~INFRA#list-item
集合:~INFRA#ordered-set
付加する:~INFRA#list-append
前付加する:~INFRA#list-prepend
除去する:~INFRA#list-remove
set.付加する:~INFRA#set-append
~listを昇順に~sortする:~INFRA#list-sort-in-ascending-order
sub.符号単位:~INFRA#code-unit-less-than

ev.取消されたか:~DOM4#canceled-flag
~eventを発火する:~DOM4#concept-event-fire
~eventを作成する:~DOM4#concept-event-create
~eventを配送する:~DOM4#concept-event-dispatch
配送-:~DOM4#concept-event-dispatch
文書:~DOM4#concept-document
親~targetを取得する:~DOM4#get-the-parent

並列的:~HTMLINFRA#in-parallel


~taskを~queueする:~WAPI#queue-a-task
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
aG.~event~loop:~WAPI#concept-agent-event-loop
~event~loop:~WAPI#event-loop
~task:~WAPI#concept-task
~task~source:~WAPI#task-source
~task~queue:~WAPI#task-queue
関連な設定群~obj:~WAPI#relevant-settings-object
enV.生成元:~WAPI#concept-settings-object-origin

~worker:~WORKERS#worker
閲覧~文脈:~HTMLds#browsing-context
生成元:~ORIGIN#concept-origin

~storage~key:~STORAGE#storage-key
~storage~keyを得する:~STORAGE#obtain-a-storage-key
~storage~bucket:~STORAGE#storage-bucket

●●words_table1
TC39M:https://tc39.es/ecma262/multipage

SeqDS:<code>sequence&lt;DOMString&gt;</code>
SeqAny:<code>sequence&lt;any&gt;</code>
IDBISSUES:https://github.com/w3c/IndexedDB/issues
cmpkey:<a href="#_key_comparison"><sub>key</sub></a>
cmpRec:<a href="#_index_record_comparison"><sub>rec</sub></a>

varV:<var>V</var>

●●words_table

	●IDL／データ／構造
Record:
Array:
exotic:
作成ng:creating:作成
切離され:detachされ::切り離され
	queue-up
	queuing
	cloning
	copying
	構築し直す:reconstruct
	構築-法:constructing

	didThrow
	（旧来の）~listenerは投出したか:legacyOutputDidListenersThrowFlag
	空でない:non-empty

	~~一定の順序で:in-order:
	-:exclude
	-:child

	●文字データ
alphabet::::アルファベット
16-bit:
正規化形:normalization form:~
制御文字:control:~
字句的:lexicographical:~
代用対:surrogate pair::~::サロゲートペア
末尾:end:~
逆直列化-:deserialize::~::逆シリアル化
直列形:serialized::~::シリアル形
escaping::::エスケープ処理

	●一般処理
区間:interval:~
時機:timing:~
稼働-:run::~
	成功した:successful
不可分:atomic::~
例外的:exceptional:~
非作動中:inactive::~::非アクティブ
	作動中でなくなる:deactivate
上書-:overwrite::上書き
上書不可:no-overwrite::上書き不可
	完了していない:pending

呼出時:invoke 時:呼び出し時
投出あり:did throw::~
schedule::::スケジュール
	~schedule法:scheduling
要求mode:required mode:要求 mode::要求モード

異常:abnormal:~
排他的:exclusive:~
crash::::クラッシュ
	crashing
	収集-順:sequencing of the collection
中途完了:abrupt completion::~

片付ける:clean upする:~
片付けら:clean upさ:~
	片付ける:cleanup
再帰-:recurse:~
続行-:proceed:~
競合:conflict:~
	~tx間で互いに競合:merge conflicts:
処理待ち:pending:~
未決な:outstanding:~
素早く:quickに:~
一時的:temporary:~
優先-:prioritize:~

為した:makeした:~
為され:makeされ:~
為せる:makeできる:~
為せな:makeできな:~
一過:transient::~

	一定期間:period of time
	-:recursive
	渡す:pass する
	飛ばす:skip する
	終え:done
	~RET:terminate these steps
	〜になる:enter
	blocking
	unblock
	failed
	executing
	target
	発火-法:firing
	生きて:live
	生かし続けれる:cause 〜 stay alive

	●一般処理（storage
bucket::::バケット
巻戻され:roll backされ::~
巻戻し:rollback::~
復帰-:revert::~
復帰させ:revertす::~
喪失:loss:~
	starting
耐久能:durability::~
lifecycle:
成長-:grow:~
一掃-:flush::~
存続期間:lifetime:~
短命:ephemeral:~
	~~短命:short lived


	●db／接続／tx／event
db:database:::データベース

接続先:connected::~
切断-:disconnect::~
	out-of-line
	in-line
open:
	opening
close:
	~close待ち:close pending
	error:
success:
readonly:
readwrite:read/write
済んだ:done:~
commit::::コミット
	~commit中:committing
handle::::ハンドル
	新~version
	旧~version
tx: transaction:::トランザクション
	transactionに基づくtransactional:
保管庫:object store::~::オブジェクトストア
設置-:place::~
	設置-先:place 先
索引:index::~::インデックス
索引付き:indexed::~::インデックス付き
併合-:merge::~

	●演算

昇格:upgrade::~
昇格-:upgrade::~
保存-:save::~

書込n:write::書き込み
書込む:writeする::書き込む
書込まれ:writeされ::書き込まれ
書込め:writeでき::書き込め
書込まな:writeしな::書き込まな
書込んで:writeして::書き込んで
書込も:writeしよ::書き込も
書込み:writing::書き込み

読取らせ:readさせ::読み取らせ
参照先:referenced::~
参照先の:referenced::~

結果:result:~

	●変数
種類:kind:~

	%A
	%B
	%C
	%H
	%H1
	%H2
	%I
	%K
	%L
	%L1
	%O
	%P
	%R
	%R1
	%S
	%a
	%a1
	%a2
	%b
	%b1
	%b2
	%c
	%count:count
	%error:error
	%hop:hop
	%i:i
	%info:hop
	%k
	%key:key
	%key1:key1
	%key2:key2
	%keyPath:keyPath
	%lower:lower
	%lowerKey:lowerKey
	%ms:ms
	%name:name
	%o
	%p
	%q
	%query:query
	%queryOrOptions:queryOrOptions
	%r:r
	%seen:seen
	%store
	%store1
	%store2
	%storeNames
	%store_t1
	%store_t2
	%trans1
	%trans2
	%transaction
	%transaction.onerror
	%type
	%upper
	%upperKey
	%upperOpen
	%va:va
	%value
	%vb:vb
	%version
	%~NULL不可:null disallowed flag
	%~algo:-
	%~buffer:buffer
	%~byte列:bytes
	%~clone:clone
	%~cursor:cursor
	%~db:db
	%~db~list:-
	%~db群:databases
	%~entry:entry
	%~event:event
	%~event名:e
	%~handle:handle
	%~index:index
	%~interface:-
	%~item:item
	%~item:-
	%~key:key
	-:kpk
	%~key~path:keyPath
	%~keyのみ~flag:-
	%~keyのみか:-
	%~key値:keyValue
	%~key群:keys
	%~key集合:-
	%~list:list
	%~listenerは投出したか:didThrow
	%~queue:queue
	%~record:record
	%~record群:records
	%~sort済み:sorted
	%~source:source
	%~source~handle:sourceHandle
	%~storage~key:storageKey
	%~target:target
	%~tx:transaction
	%~tx群:-
	%~version:version
	%一意か:unique
	%上書不可か:no-overwrite flag
	%位置:position
	%保管庫:store
	%保管庫~位置:object store position
	%値:value
	%入力:input
	%参照先:-
	%参照先~record:-
	%名前:name
	%名前~群:names
	%宛先~realm:targetRealm
	%強制するか:forced flag
	%手続き:-
	%抽出d~key:-
	%接続
	%接続~群:openConnections
	%接続:connection
	%新~version:newVersion
	%新~接続:connection
	%方向:direction
	%日付:date
	%旧~version:oldVersion
	%最後の識別子:last
	%演算:operation
	%状態s:status
	%現在の~key:-
	%生成key:-
	%生成器:generator
	%直列形:serialized
	%種類:kind
	%範囲:range
	%範囲~record群:rangeRecords
	%索引:index
	%索引~key:index key
	%結果:result
	%自動生成か:autoIncrement
	%複-~entryか:multiEntry
	%要求mode:-
	%要請:request
	%視野:scope
	%識別子:identifier
	%識別子~list:identifiers
	%配列:array
	%長さ:len
	%関係記号
	%首key:primaryKey
	-:rangeRecordsLength

	●key 生成／cursor／走査
反復対象に:iterate over::~::イテレート対象に
	~sort済み:sorted
生成key:generated key::生成 key
下位key:subkey::下位 key
首key:primaryKey::首 key
	首key:primary key
only:
path:
全範囲:unbounded key range:~
下界:lower bound::~
上界:upper bound::~
下界open:lower open::下界は open
上界open:lower open::上界は open
増加-:increase:~
増分-:increment:~
減少-:decrease:~
	retrieval
検索-:look up::~
検索:look-up::~
単調:monotonic::~
番号:number::~
抽出d:extracted::抽出
昇順:ascending order:~
降順:descending order:~
	{key:value}:key-value
	複-~entry:multiEntry
	値は取得-済み:got value
	辿るとき:traversal

	●環境
off-line::::オフライン
disk::::ディスク
言語束縛:binding::~
machine::::マシン
compile::::コンパイル
compiler::::コンパイラ
quota::::クォータ
環境設定:configuration settings:~
宛先:target::~
電力:power:~
携帯:portable:~
battery-life:battery life:::バッテリー寿命

	●保安
	~URL~path:pathname
TLS:
DNS:
IP:
証明書:certificate:~
cross-directory::::クロスディレクトリ
健康診断記録:health record:~
	site-specific:
log-in:log in:::ログイン
購入:purchase:~
行動:action:~
	client-side
活動:activities:~
認証-:authenticate::~
	認証-済み:authenticated
電子商取引:e-commerce:~
失効-:expire:~
	expiring:
権限付与-:authorize::権限を付与
credit-card:credit card:::クレジットカード
住所:address:~
識別情報:identifying information:~
	~~識別情報:id object
阻止list:blocklist::阻止 list:阻止リスト:ブロックリスト
安全list:safe-listing::安全 list:安全リスト
	~~提案:suggestion
自明:trivial:~
協力-:cooperate:~
協力:cooperation:~
転用-:repurpose:~
遡及的:retroactive:~
訪問者:visitor:~
復活:resurrection:~

冗長:redundant:~
backup::::バックアップ
打破-:defeat:~
首尾一貫した:coherentな:~
	敏感~性:sensitivity
メール:e-mail:~
機密的:confidential:~
迂回-:bypass:~
敵対者:adversary:~
購買:shopping:~
広告:advertising:~
文書作成:word-processing:~
作業中:work-in-progress:~
競合企業:competing company:~
危険:dangerous:~
被害者:victim:~
配布-:distribute:~
本当:real:~
本当の:realな:~
圧政的団体:oppressive group:~
共有d:shared:共有
予定表:calendar appointments:~
不揮発:non-volatile:~
	媒体:medium
持続性:persistence:~
持続化-:persist:~
持続的:persistent:~
運用上の:operationalな:~
	旧:older
正規表現:regular expression:~
	~~命令:instruction
遭遇-:encounter:~
各個人:individual:~
帰属:attribution:~

	残り続ける:remain
	生じる／:arise
	scripting
	覗き見る:examine
	同等に:equal に
	letting
	組み合わされ:in conjunction with
	即座に:promptly
	capable:
	知る:aware
	差し障りない:innocuous
	純粋:purely
	晒す:put
	quite:
	責を負う:responsible
	world
	greater
	ずっと正確aに:with greater accuracy
	stored
	he
	~~健全な疑い:healthy suspicion
	取り除く:prune
	情報を吟味した上で〜裁定を下せる:informed decisions

	●accessibility
末端利用者:end-user:~
必要性:needs:~
念頭:mind:~
制作-:produce:~
screen-reader:screen reader:::スクリーンリーダ
	代替を成す〜:〜alternatives
	時間に基づく:time-based
	他の:non-textual
	~~一部分:fraction

	●仕様
targeted:
	common:
参考:informative:~
優位性:advantage:~
決定的:deterministic:~
先進的:advanced:~
心臓部:heart:~
優先順位:precedence:~
版:edition:~
確度:confidence:~
組織化-:organize:~
洗練-:sophisticate:~
提言:suggestion:~
上限:limit:~
辞退-:decline:~
重視-:weigh:~
	勝る:outweigh:~
人為的:artificial:~
課-:impose:~
述部:predicate:~

	~~課す
	際どい:edge
	易く:easy
	該当:cover
	最終的に:ultimately
	妨げ:too disruptive
	ゆえに:To this end
	~~厳密にrigorous
	強い影響力を及ぼした:extremely influential in:
	それに加え:additionally
	ごく普通に:quite
	あり得る:possible
	可能性:possible
	~~可能性:potential
	見込みが高い:likely
	なり得る:potentially
	practical
	prepare:
	primarily:
	respective:
	publish:
	publishing:
	-:similar
	suffice:
	sure:
	thank:
	一切なくても:whatsoever
	work-in-progres:
	year:
	user-specific:
	variation:
	welcome:
	先ず初めに:before proceding with rest of
	~~要約すると、:practical result of this is
	~~協同して:act together
	speaking:
	-:scenario
	secondarily:
	proposed:
	~~説明:illustrate
	employ:
	~fashion:
	follow:
	appreciation:
	capable
	との間で:with respect to
	高める:provides greater
	nonsupported
	できなくなる:prevent
	自覚できるようにしておく:make sure 〜 is aware
	authoring:
	aware:
	保-:keep
	required:
	realize:
	regarding:
	wrote:
	称され:said
	勧められ:advise
	~~見直す:introspect
	満たす:satisfy
	において新たに導入された:is new in 〜

	●未分類
出自に:originate:~
合致:match::~::マッチ
	-:evaluate
固定-:fix:~
	保ち続け:keep track
読込直す:reloadする::読み込み直す::リロードする
読込直-:reload::読み込み直::リロード
捜出す:locateする:捜し出す
隠す:hideする:~
閉じて:closeして:~
衝突-:clash:~
移行-:migrate:~
重合する:overlapする:重なり合う
重合して:overlapして:重なり合って
一意性:uniqueness:~
	一意性の
破損:corruption:~
入出力:I/O:~

	-:assign
	duplicate:
	進める:advance
	存在-:exist
	高効率:highly efficient
	類する:or something similar
	成る:comprise
	欠-:lack
	保たれ:kept
	bound
	chain
	continue:
	continuing:
	数えるcount:
	end:
	equal:
	exceeding:
	満たすfulfill:
	inspect:
	leading:
	left:
	letting:
	marked
	~~合致:meet
	met:
	指す:point
	pointed
	processed:
	put:
	~refer:
	〜し続けremain:
	stay
	taken
	tell
	結び付け:tie
	他へ~navigate:navigating away

	●未分類
	~JS:ECMAScript
実効:effective:~
B-tree::::B-ツリー
関係db:relational database:::関係データベース:リレーショナルデータベース
	time:
	non-modal
無符号:unsigned:~
有符号:signed:~
式:expression:~
総数:total number:~
連続的:continuous:~
最大:最大
最小:最小
派生した:deriveされた:~

	刊行頻度:frequency
	access可能:accessible
	返信:communicates back
	-:numeric
	-:non-numeric
	小さな差異:minor variation
	result
	extreme
	-:concrete
	across
	存続する限り固定され続ける:remains fixed for the life
	~~時間を要する:durable
	although
	also
	anyone
	apart
	away
	back
	~~悪化-:lead to a poor
	become
	本:book
	~class
	due
	early
	ever
	false
	片:fragment
	go
	he
	in-order
	in
	infinite
	infinity
	night:
	option:
	options:
	parameter:
	そのような:pattern
	片:piece
	product:
	row:
	series:
	~~容量space:

	thread:
	true:
	unchanged:
	~undo:
	unpacked:
	yield:
	区別され:sensitive／

	●指示語
元の:

	同時に:at the same time
	すべて:altogether
	長い:long
	旧:older
	次:next
	総数:how many
	大多数の:most
	後続-:follow
	より大きな:larger
	より小さな:smaller
	最も小さな:smallest
	重ねて:twice／:more than once
	最も低い:lowest
	最も高い:highest
	より高い:higher
	大きい:high／larger
	他の〜:others
	結果の:resulted／resulting
	始-:begin
	種々の:various
	様々な:variety
	inner
	間に:in the middle
	moreover:
	部分:everything
	ちょうど:exact
	ある~~範囲:some extent
	最後に:finally
	ずっと:greater
	neither
	once
	逆:opposite
	outer-most:
	part:
	past:
	slight:
	preceding
	previous:
	前回:previous
	いくつかの:several:
	小さな~small:
	大きな~large
	something:
	sometime:
	such:
	unlike:
	until:
	very:
	one and only one
	一階層:one level
	日夜:day and night
	large:
	later:
	今後の:later
	早期:earlier
	に対し:against

●●ref_normative

[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMA-262]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[FileAPI]
    Marijn Kruisselbrink. ＜File API＞. URL: https://w3c.github.io/FileAPI/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[STORAGE]
    Anne van Kesteren. ＜Storage Standard＞. Living Standard. URL: https://storage.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[Charmod-Norm]
    Addison Phillips; et al. ＜Character Model for the World Wide Web: String Matching＞. URL: https://w3c.github.io/charmod-norm/
[COOKIES]
    A. Barth. ＜HTTP State Management Mechanism＞. April 2011. Proposed Standard. URL: https://httpwg.org/specs/rfc6265.html
[WEBSTORAGE]
    Ian Hickson. ＜Web Storage (Second Edition)＞. URL: https://w3c.github.io/webstorage/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Indexed Database API 3.0</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/IndexedDB/
公表履歴
	https://www.w3.org/standards/history/IndexedDB-3/
編集者草案
	https://w3c.github.io/IndexedDB/
テスト一式
	https://github.com/web-platform-tests/wpt/tree/master/IndexedDB
課題追跡
	<a href="https://github.com/w3c/IndexedDB/issues/">GitHub</a>
編集
	<a href="mailto:jsbell@google.com">Joshua Bell</a> (Google Inc.)
	<a href="mailto:stevebe@microsoft.com">Steve Becker</a> (Microsoft)
前任編集者
	Ali Alabbas (Formerly of Microsoft)
commit 履歴
	https://github.com/w3c/IndexedDB/commits/main
実装報告
	http://wpt.fyi/IndexedDB
フィードバック
	https://github.com/w3c/IndexedDB/issues/
過去 ML アーカイブ
	https://lists.w3.org/Archives/Public/public-webapps/
公表者
	<a href="https://www.w3.org/groups/wg/webapps">Web Applications WG</a>

</script>

</head>

<body>

<header>
	<hgroup>
<h1>索引付きデータベース API — Indexed Database API 3.0</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この文書は、
~recordたちが成す~db用の~APIを定義する。
ここでの各~recordは、［
~keyと, 対応する［
単純な値, または階層的な~objを保持する
］ような何らかの値
］の組みからなる†。
加えて、
~dbは，［
格納される~recordたちにわたる，いくつかの索引
］も保守する。
~app開発者は、
~APIを直に利用して，［
~keyにより，または索引を利用して
］，格納されている~recordを捜出す。
また、
この~API上に~query言語の層を~~重ねられる。
索引付き~dbは、
持続的な~B-tree~data構造を利用して実装し得る。
◎
This document defines APIs for a database of records holding simple values and hierarchical objects. Each record consists of a key and some value. Moreover, the database maintains indexes over records it stores. An application developer directly uses an API to locate records either by their key or by using an index. A query language can be layered on this API. An indexed database can be implemented using a persistent B-tree data structure.
</p>

<p class="trans-note">【†
この仕様が対象にする~recordは、
CSV や
`関係db＠https://ja.wikipedia.org/wiki/%E9%96%A2%E4%BF%82%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9$
の様な平坦な~fieldの並びではない。
~recordの値である~objが首な~data~sourceであり
（数値や文字列のような “単純な” 値は “一階層のみの~obj” と捉えられる）、
~recordの~keyは，もっぱら それらの値を~~検索したり, ~recordたちを~sortするために働くものとして~~意図されている。
】</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下，この節の他の内容は、~SOTD-W3Cに移譲。】
</p>

<p>
これは、
Indexed Database API の第 3 版です。
`初版＠~TR/2015/REC-IndexedDB-20150108/$
（ `Indexed Database API^cite ）は
2015年 1月 8日に W3C 勧告になっています。
`第 2 版＠~TR/2018/REC-IndexedDB-2-20180130/$
（ `Indexed Database API 2.0^cite ）は
2018年 1月 30日に W3C 勧告になっています。
◎
This is the Third Edition of Indexed Database API. The First Edition, simply titled "Indexed Database API", became a W3C Recommendation on 8 January 2015. The Second Edition, titled "Indexed Database API 2.0", became a W3C Recommendation on 30 January 2018.
</p>

<p>
この第 3 版は、
第 2 版に取って代わることが意図されています。
◎
Indexed Database API 3.0 is intended to supersede Indexed Database API 2.0.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~UAは、
~web~appの~off-line~data要件を満たすため，多数の~objを局所に格納する必要がある。
`WEBSTORAGE$r は、［
~key, それに対応する値
］が成す~pairたちを格納するために有用ではあるが、［
~keyたちを順序どおりに検索取得する／
多数の値にわたり効率的に探索する／
同じ~keyに値を重複して格納する
］方法は供さない。
◎
User agents need to store large numbers of objects locally in order to satisfy off-line data requirements of Web applications. [WEBSTORAGE] is useful for storing pairs of keys and their corresponding values. However, it does not provide in-order retrieval of keys, efficient searching over values, or storage of duplicate values for a key.
</p>

<p>
この仕様は、［
大多数の洗練された~query処理器の心臓部である，先進的な { ~key: 値 } ~data管理
］を遂行する~APIを供する
— ~txに基づく~dbを利用して，一連の［
~key, それに対応する（~keyごとに一つ以上の）値
］を格納し，各~keyを決定的~順序で辿る手段を供することにより。
これは、
持続的な~B-tree~data構造を利用して実装されることが多い
— それは、
挿入と削除に加えて，大量の~data~recordを順序どおりに辿るときにも効率的であると考えられているので。
◎
This specification provides a concrete API to perform advanced key-value data management that is at the heart of most sophisticated query processors. It does so by using transactional databases to store keys and their corresponding values (one or more per key), and providing a means of traversing keys in a deterministic order. This is often implemented through the use of persistent B-tree data structures that are considered efficient for insertion and deletion as well as in-order traversal of very large numbers of data records.
</p>

<div class="example" id="example-open-connection">
<p>
次の例は、
~APIを利用して，`書庫^l ~dbに~accessする。
この~dbは、
名前 `書棚^l の`保管庫$を有する。
この書棚には、
`isbn^l ~propを首keyに用いて，一群の`~record$ （すなわち， “本” ）が格納される。
◎
The following example uses the API to access a "library" database. It has a "books" object store that holds books records stored by their "isbn" property as the primary key.
</p>

<p>
各 本には、
`書名^l ~propもある。
この例では、
書名が【書棚~内で】一意になることを，人為的に要求する。
この~codeは、［
`unique＠#dom-idbindexparameters-unique$m
~optionが ~T に設定された，名前 `書名索引^l の`索引$を作成する
］ことにより，これを施行する。
この索引は、
各 本を書名で検索するために利用され，書名が一意でない本を追加するのも防止することになる。
◎
Book records have a "title" property. This example artificially requires that book titles are unique. The code enforces this by creating an index named "by_title" with the unique option set. This index is used to look up books by title, and will prevent adding books with non-unique titles.
</p>

<p>
各 本には、
`著者名^l ~propもあり，一意になることは要求されない。
この~codeは、
名前 `著者名索引^l の`索引$も作成して，この~propによる検索を許容する。
◎
Book records also have an "author" property, which is not required to be unique. The code creates another index named "by_author" to allow look-ups by this property.
</p>

<p>
この~codeは、
まず，~dbへの接続を~openする。
`upgradeneeded$et ~event~handlerの~codeが，必要なら保管庫と（それに`専属する$）索引たちを作成する。
`success$et ~event~handlerの~codeは、
~openした接続を後の利用-用に保存する。
◎
The code first opens a connection to the database. The upgradeneeded event handler code creates the object store and indexes, if needed. The success event handler code saves the opened connection for use in later examples.
</p>

<pre class="lang-js">
const %request = `indexedDB$m.open(`書庫^l);
let %書庫;

%request.onupgradeneeded = function() {
  /* <span class="comment">
書庫~dbはまだ存在しないので，保管庫と索引を作成する。
◎
The database did not previously exist, so create object stores and indexes.
</span> */
  const %書庫 = %request.result;
  const %書棚 = %書庫.createObjectStore(`書棚^l, {keyPath: `isbn^l});
  const %書名索引 = %書棚.createIndex(`書名索引^l, `書名^l, {unique: true});
  const %著者名索引 = %書棚.createIndex(`著者名索引^l, `著者名^l);

  /* <span class="comment">
初期~dataで保管庫を拡充する
（索引は自動的に拡充される）。
◎
Populate with initial data.
</span> */
  %書棚.put({書名: `Quarry Memories^l, 著者名: `Fred^l, isbn: `123456^lt});
  %書棚.put({書名: `Water Buffaloes^l, 著者名: `Fred^l, isbn: `234567^lt});
  %書棚.put({書名: `Bedrock Nights^l, 著者名: `Barney^l, isbn: `345678^lt});
};

%request.onsuccess = function() {
  %書庫 = %request.result;
};</pre>

<p>
次の例は、
~txを利用して~dbを拡充する。
◎
The following example populates the database using a transaction.
</p>

<pre class="lang-js">
const %tx = %書庫.transaction(`書棚^l, `readwrite$l);
const %書棚 = %tx.objectStore(`書棚^l);

%書棚.put({書名: `Quarry Memories^l, 著者名: `Fred^l, isbn: `123456^lt});
%書棚.put({書名: `Water Buffaloes^l, 著者名: `Fred^l, isbn: `234567^lt});
%書棚.put({書名: `Bedrock Nights^l, 著者名: `Barney^l, isbn: `345678^lt});

%tx.oncomplete = function() {
  /* <span class="comment">
すべての要請は成功し，~txは~commitされた。
◎
All requests have succeeded and the transaction has committed.
</span> */
};</pre>

<p>
次の例は、
索引を利用して，~db内の単独の本を書名で検索する：
◎
The following example looks up a single book in the database by title using an index.
</p>

<pre class="lang-js">
const %tx = %書庫.transaction(`書棚^l, `readonly$l);
const %書棚 = %tx.objectStore(`書棚^l);
const %書名索引 = %書棚.index(`書名索引^l);

const %request = %書名索引.get(`Bedrock Nights^l);
%request.onsuccess = function() {
  const %matching = %request.result;
  if (%matching !== undefined) {
    /* <span class="comment">
合致するものが見出された。
◎
A match was found.
</span> */
    report(%matching.isbn, %matching.書名, %matching.著者名);
  } else {
    /* <span class="comment">
合致するものは見出されなかった。
◎
No match was found.
</span> */
    report(null);
  }
};</pre>

<p>
次の例は、
索引と~cursorを利用して，~db内のすべての本から，著者名が合致するものを検索する：
◎
The following example looks up all books in the database by author using an index and a cursor.
</p>

<pre class="lang-js">
const %tx = %書庫.transaction(`書棚^l, `readonly$l);
const %書棚 = %tx.objectStore(`書棚^l);
const %著者名索引 = %書棚.index(`著者名索引^l);

const %request = %著者名索引.openCursor(<span class="typ">IDBKeyRange</span>.only(`Fred^l));
%request.onsuccess = function() {
  const %cursor = %request.result;
  if (%cursor) {
    /* <span class="comment">
合致する各~recordごとに~callされる。
◎
Called for each matching record.
</span> */
    report(%cursor.value.isbn, %cursor.value.書名, %cursor.value.著者名);
    %cursor.continue();
  } else {
    /* <span class="comment">
合致する~recordはもうない。
◎
No more matching records.
</span> */
    report(null);
  }
};</pre>

<p>
要請が失敗したとき~errorを取扱う仕方の一つを、
次の例に示す：
◎
The following example shows one way to handle errors when a request fails.
</p>

<pre class="lang-js">
const %tx = %書庫.transaction(`書棚^l, `readwrite$l);
const %書棚 = %tx.objectStore(`書棚^l);
const %request = %書棚.put({書名: `Water Buffaloes^l, 著者名: `Slate^l, isbn: `987654^lt});
%request.onerror = function(%event) {
  /* <span class="comment">
索引 `書名索引^l に対する一意性の拘束は失敗した。
◎
The uniqueness constraint of the "by_title" index failed.
</span> */
  report(%request.error);
  /* <span class="comment">
~txを中止させたくなければ，
%event の `preventDefault()$m を~callすることもできる。
◎
Could call event.preventDefault() to prevent the transaction from aborting.
</span> */
};
%tx.onabort = function() {
  /* <span class="comment">
他の場合、
失敗した要請に因り，~txは自動的に中止されることになる。
◎
Otherwise the transaction will automatically abort due the failed request.
</span> */
  report(%tx.error);
};</pre>

<p>
必要なくなったなら、
~db接続は~closeできる。
◎
The database connection can be closed when it is no longer needed.
</p>

<pre class="lang-js">
%書庫.close();
</pre>

<p>
~dbは，未来に他の保管庫／索引を包含するように成長させれる。
より古い~versionから移行するときに取扱う仕方の一例を次に示す。
◎
In the future, the database might have grown to contain other object stores and indexes. The following example shows one way to handle migrating from an older version.
</p>

<pre class="lang-js">
const %request = `indexedDB$m.open(`書庫^l, `3^lt); /* <span class="comment">
~version 3 を要請する。
◎
Request version 3.
</span> */
let %書庫;

%request.onupgradeneeded = function(%event) {
  const %書庫 = %request.result;
  if (%event.oldVersion &lt; `1^lt) {
    /* <span class="comment">
~version 1 が~dbの最初の~version。
◎
Version 1 is the first version of the database.
</span> */
    const %書棚 = %書庫.createObjectStore(`書棚^l, {keyPath: `isbn^l});
    const %書名索引 = %書棚.createIndex(`書名索引^l, `書名^l, {unique: true});
    const %著者名索引 = %書棚.createIndex(`著者名索引^l, `著者名^l);
  }
  if (%event.oldVersion &lt; `2^lt) {
    /* <span class="comment">
~version 2 は、
`出版年^l で本を検索できるようにする，新たな索引を導入する。
◎
Version 2 introduces a new index of books by year.
</span> */
    const %書棚 = %request.transaction.objectStore(`書棚^l);
    const %出版年索引 = %書棚.createIndex(`出版年索引^l, `出版年^l);
  }
  if (%event.oldVersion &lt; `3^lt) {
    /* <span class="comment">
~version 3 は、
`定期刊行物^l ）用に 2 つの索引を伴う新たな保管庫を導入する。
◎
Version 3 introduces a new object store for magazines with two indexes.
</span> */
    const %定期刊行物 = %書庫.createObjectStore(`定期刊行物^l);
    const %出版元索引 = %定期刊行物.createIndex(`出版元索引^l, `出版元^l);
    const %刊行頻度索引 = %定期刊行物.createIndex(`刊行頻度索引^l, `刊行頻度^l);
  }
};

%request.onsuccess = function() {
  %書庫 = %request.result; /* <span class="comment">
%書庫.`version^m は 3 になる。
◎
db.version will be 3.
</span> */
};</pre>

</div>

<div class="example" id="handling-versionchange">

<p>
複数の~client（~pageと~worker）が、
同じ~dbを同時に利用できる
— 互いの読取り／書込みが衝突しないことは、
~txにより確保される。
新たな~clientが（ `upgradeneeded$et ~eventを介して）当の~dbを昇格したいと求めた場合、
他のすべての~clientが その~dbの現在の~versionへの接続を~closeするまでは，それを行えない。
◎
A single database can be used by multiple clients (pages and workers) simultaneously — transactions ensure they don’t clash while reading and writing. If a new client wants to upgrade the database (via the upgradeneeded event), it cannot do so until all other clients close their connection to the current version of the database.
</p>

<p>
`versionchange$et ~eventを~listenすれば、
~clientは，新たな~clientが昇格-時に阻まれるのを避けれる。
これは、
別の~clientが当の~dbを昇格したいと求めているときに発火される。
その昇格を継続することを許容するためには、
`versionchange$et ~eventに対し，この~clientによる~dbへの`接続$が最終的に~closeされるような何かを行って反応する。
◎
To avoid blocking a new client from upgrading, clients can listen for the versionchange event. This fires when another client is wanting to upgrade the database. To allow this to continue, react to the versionchange event by doing something that ultimately closes this client’s connection to the database.
</p>

<p>
これを行う仕方の一つは、
~pageを読込直すことである：
◎
One way of doing this is to reload the page:
</p>

<pre class="lang-js">
%db.onversionchange = function() {
  /* <span class="comment">
先ず、
保存-済みでない~dataを保存する：
◎
First, save any unsaved data:
</span> */
  saveUnsavedData().then(function() {
    /* <span class="comment">
~pageが利用者からヤリトリされてない場合、
読込直す方が適切になろう。
◎
If the document isn't being actively used, it could be appropriate to reload the page without the user's interaction.
</span> */
    if (!document.hasFocus()) {
      location.reload();
      /* <span class="comment">
読込直すことで、
~dbは~closeされ，新たな~JSと~db定義が読込直されることになる。
◎
Reloading will close the database, and also reload with the new JavaScript and database definitions.
</span> */
    } else {
      /* <span class="comment">
文書が~focusを得ている場合、
~pageを読込直すと利用者の妨げになり得るので，手動でそうしてもらうよう利用者に依頼する：
◎
If the document has focus, it can be too disruptive to reload the page. Maybe ask the user to do it manually:
</span> */
      displayMessage("最新~versionに昇格するため、
この~pageを読込直してください。");
    }
  });
};

function saveUnsavedData() {
  /* <span class="comment">
これをどう行うかは、
~appに依存する。
◎
How you do this depends on your app.
</span> */
}

function displayMessage() {
  /* <span class="comment">
利用者に非~modal~messageを示す。
◎
Show a non-modal message to the user.
</span> */
}</pre>

<p>
もう一つの仕方は、
`接続$の `close()$m ~methodを~callすることである。
しかしながら，当の~dbに~accessしようとする後続な試みは失敗することになるので、
~appがそれを自覚できるようにしておく必要がある。
◎
Another way is to call the connection’s close() method. However, you need to make sure your app is aware of this, as subsequent attempts to access the database will fail.
</p>

<pre class="lang-js">
%db.onversionchange = function() {
  saveUnsavedData().then(function() {
    %db.close();
    stopUsingTheDatabase();
  });
};

function stopUsingTheDatabase() {
  /* <span class="comment">
~appをそれ以上~dbを利用しない状態に置く。
◎
Put the app into a state where it no longer uses the database.
</span> */
}</pre>

<p>
（昇格を試みている）新たな~clientは、
`blocked$et ~eventを利用して，他の~clientが昇格を防止しているかどうか検出できる。
この~eventは、
`versionchange$et ~eventが発火された後も，他の~clientが 依然として~dbへの接続を保持しているときに発火される。
◎
The new client (the one attempting the upgrade) can use the blocked event to detect if other clients are preventing the upgrade from happening. The blocked event fires if other clients still hold a connection to the database after their versionchange events have fired.
</p>

<pre class="lang-js">
const %request = indexedDB.open("library", 4); /* <span class="comment">
~version 4 を要請する。
◎
Request version 4.
</span> */
let %blockedTimeout;

%request.onblocked = function() {
  /* <span class="comment">
他の~clientに，~dataを非同期に保存する時間を与える。
◎
Give the other clients time to save data asynchronously.
</span> */
  %blockedTimeout = setTimeout(function() {
    displayMessage("昇格が阻まれています。この~siteを表示している他の~UItabを閉じてください。");
  }, 1000);
};

%request.onupgradeneeded = function(%event) {
  clearTimeout(%blockedTimeout);
  hideMessage();
  // ...
};

function hideMessage() {
  /* <span class="comment">
以前に表示した~messageを隠す。
◎
Hide a previously displayed message.
</span> */
}</pre>

<p>
利用者は、
別の~clientが~dbを切断するのに失敗した場合に限り，上の~messageを見ることになる。
利用者がこれを見ることは決してないのが理想的だが。
◎
The user will only see the above message if another client fails to disconnect from the database. Ideally the user will never see this.
</p>
</div>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p><small>（
この節の表記規約は、
この仕様が~UAに~~課す要件（〜するモノトスル）を集約するものでもある。
）</small></p>

◎表記記号

<p>
`ECMA-262$r は，原文では “ECMAScript” と称されるが、
他のほとんどの仕様では “JavaScript” と表記されるので，
この訳でも そう表記することにする。
</p>

<p>
この仕様の~APIが定義する各種~interfaceの各~instanceは、
それが表現する抽象-~objと常に一対一に対応するので，同一視される
（例： `IDBDatabase$I ~objと，それが表現する`接続$ ）。
</p>

<p>
加えて、
次の記法も利用する：
</p>

<dl class="def-list">
	<dt>
%手続き( %引数 ) ？
</dt>
	<dd>
~algoの中で手続きを呼出す箇所において末尾に記号 ？ を伴う場合、
当の手続きから例外が投出され得ることを表す。
</dd>

	<dt>
%O↗
（ %O の
`~access先@
）
</dt>
	<dd>
~APIに公開される一部の型の~objは、
ある型の抽象-~objへの~accessを間接的に供するものとして定義される
（具体的には、
次項 “`専属する$” の図式に示される）。
%O がそのような型の~instanceであるとき、
%O を通して~accessされる抽象-~objは， %O↗ とも記される。
%O から %O↗ への対応関係は、
一般に多対一になることに注意。
また、
%O に対する %O↗ が別の~instanceに変わることは，決してない。
</dd>
	<dd>
%O は、
ある時点を過ぎて以降， %O↗ に~accessできなくなることもある
— %O↗ が %O よりも先に破壊された ／ %O↗ への~accessが “~closeされた” ときなど。
そうなったとしても、
%O↗ が有する~propを反映するような，
%O が有する~IDL属性には、
その
`値を保ち続ける@
とされるものもある。
そのような属性は、［
%O↗ を~access先とする別の~objを通して %O↗ に変更が加えられた
］としても，元の属性~値を保つ。
</dd>

	<dt>
`専属する@
</dt>
	<dd>
<p>
一部の型の~obj間には、
“専属する”
という語で，その結び付けの関係が表記される。
ある型 %A の~instance %a が，別の型 %B の~instance %b に`専属する$という関係には、
一般に，次が含意される：
</p>

<ul>
	<li>
%a は、
自身が存在し続ける限り， %b 以外の型 %B の~instanceには`専属しない$。
</li>
	<li>
%a が存在し続ける限り， %b も存在し続ける
（ %b が破壊される時点で， %a も破壊される）。
【！ （ %a は %b への強い参照を有する） 】
</li>
</ul>

<p>
ある~instanceに`専属する$ような~instanceは，一般に複数 存在し得る。
</p>

</dd>
	<dd>
この専属するという関係は，同じ型の~instance間で定義されたり, 循環することは決してないので、
推移的に拡張して利用される。
例えば %b が また別の型 %C の~instance %c に`専属する$とき、
“%a が`専属する$ %C ~obj”
という記述は、
%c を指すことになる。
</dd>
	<dd>
<p>
次の図式に、
この関係がある, および
上述の~accessを供する関係があるような，各種~objを要約する：
</p>

<table id="_hierarchy">
<caption style="font-style:italic;">
<ul>
<li>上向き矢印 “↑” を挟んだ下の~objが，上の~objに`専属する$。
<li>斜め矢印 “↗” を挟んだ右の~objが，左の~objを通して~accessされる。
</ul>
</caption>
<tbody>

<tr><td>【！ JS Realm？ 】
<td>【！ ↗ 】
<td>`~storage~key$

<tr><td>【！ ↑ 】
<td>
<td>↑

<tr><td>`接続$（ `IDBDatabase$I ）
<td>↗
<td>`~db$

<tr><td>↑
<td>
<td>

<tr><td>`~tx$（ `IDBTransaction$I ）
<td>
<td>↑

<tr><td>↑
<td>
<td>

<tr><td>`保管庫~handle$（ `IDBObjectStore$I ）
<td>↗
<td>`保管庫$

<tr><td>↑
<td>
<td>↑

<tr><td>`索引~handle$（ `IDBIndex$I ）
<td>↗
<td>`索引$
</table>

	</dd>
	<dd>

<p>
これらの型の~obj~instanceたちは、
常に，次の可換性と一意性の要件を満たすモノトスル：
</p>

		<dl>
			<dt>
`可換性@
</dt>
			<dd>
<p>
上の図式は`可換＠https://ja.wikipedia.org/wiki/%E5%8F%AF%E6%8F%9B%E5%9B%B3%E5%BC%8F$になる。
すなわち：
</p>
				<ul>
					<li>
どの`保管庫~handle$ %H に対しても
⇒
( %H が`専属する$`接続$ ) ↗ ~EQ
( %H↗ が`専属する$`~db$ )
</li>
					<li>
どの`索引~handle$ %H に対しても
⇒
( %H が`専属する$`保管庫~handle$ ) ↗ ~EQ ( %H↗ が`専属する$`保管庫$ )
</li>
				</ul>
			</dd>

			<dt>
`一意性@
</dt>
			<dd>
2 つの`保管庫~handle$（または 2 つの`索引~handle$）
%H1, %H2 が与えられたとき
⇒
［
%H1↗, %H2↗ は，同じ~instanceに`専属する$
］~AND［
%H1↗ ~EQ %H2↗
］ならば，
%H1 ~EQ %H2
になる。
</dd>
		</dl>

<p>
この要件の目的においては、
%H↗, %H1↗, %H2↗ は、
破壊されて以降も，他と区別できる個としては（何ら~accessできる実体は無いが）存在し続けるとする。
</p>

	</dd>
	<dd>
所与の型の~obj~instanceが［
作成される／取得される
］ときに［
どの~instanceに`専属する$, あるいは
どの~instanceを`~access先$にする
］ようにされるか，については、
上述の要件を満たすように，当の~objを［
作成する／取得する
］~APIの記述にて定義される。
</dd>
</dl>

	</section>
	<section id="constructs">
<h2 title="Constructs">2. 各種~構成子</h2>

<p>
`名前@
は、
`DOMString$I に等価な `String$jT【！string】 である。
すなわち、
空~文字列も含め，任意の長さの任意の~16-bit符号単位~列になり得る。
`名前$は常に不透明な~16-bit符号単位~列として比較される。
◎
A name is a string equivalent to a DOMString; that is, an arbitrary sequence of 16-bit code units of any length, including the empty string. Names are always compared as opaque sequences of 16-bit code units.
</p>

<div class="note">
<p>注記：
その~~結果，`名前$の比較では、
文字大小のみならず，~Unicode~textにおける他の小さな差異
— 正規化形, 制御文字の有無, その他 —
も区別される。
`Charmod-Norm$r
◎
NOTE: As a result, name comparison is sensitive to variations in case as well as other minor variations such as normalization form, the inclusion or omission of controls, and other variations in Unicode text. [Charmod-Norm]
</p>

<p>
利用する~storageの仕組みの下では~supportされない名前に対しては、
実装は，~escapingに類する仕組みを利用して 格納できる名前に対応付けれる。
◎
If an implementation uses a storage mechanism which does not support arbitrary strings, the implementation can use an escaping mechanism or something similar to map the provided name to a string that it can store.
</p>
</div>

<div class="algo">
<p>
`~sort済み名前~listを作成する@
~algoは、
所与の
( `~list$ %名前~群 )
に対し：
◎
To create a sorted name list from a list names, run these steps:
</p>
<ol>
	<li>
%~sort済み ~LET `~listを昇順に~sortする$( %名前~群, ~LT`符号単位$sub )
◎
Let sorted be names sorted in ascending order with the code unit less than algorithm.
</li>
	<li>
~RET `新たな~obj$( `DOMStringList$I )
— その
⇒＃
`文字列~list＠~HTMLcdom#_string-list$ ~SET %~sort済み
◎
Return a new DOMStringList associated with sorted.
</li>
</ol>

<p class="note">注記：
【！ details 】
これは、
`String$jT たちが成す `Array$jT ~objの `sort()＠~TC39M/indexed-collections.html#sec-array.prototype.sort$c ~methodに合致する。
この順序付けは、
各~文字列~内の~16-bit符号単位どうしを比較するための［
高効率で, 一貫した, 決定的な，~sort順序
］を与える。
この~sortは、
~alphabet順その他 どの字句的~順序にも
— 特に，代用対で表現される符号位置に対しては —
合致しない。
◎
Details
◎
This matches the sort() method on an Array of String. This ordering compares the 16-bit code units in each string, producing a highly efficient, consistent, and deterministic sort order. The resulting list will not match any particular alphabet or lexicographical order, particularly for code points represented by a surrogate pair.
</p>
</div>

		<section id="database-construct">
<h3 title="Database">2.1. ~db</h3>

<div class="p">
<p>
各 `~storage~key$には、
0 個~以上の`~db$が結付けられる
— `~db$は，その`~storage~key$に`専属する$。
</p>

<p class="trans-note">【
過去にどの~dbを作成したか調べたいときは、
`IDBFactory$I の `databases()^m ~methodを利用できる。
】</p>

<p>
各
`~db@
は，自身に格納される~dataを保持する， 0 個~以上の`保管庫$からなる。
各`~db$ %~db は、
次に挙げるものを有する：
</p>
◎
Each storage key has an associated set of databases. A database has zero or more object stores which hold the data stored in the database.
</div>

<dl class="def-list">
	<dt>
`名前@db
◎
A database has a name＼
</dt>
	<dd>
特定の`~storage~key$の中で， %~db を一意に識別する`名前$であり、
%~db が存続する間 変化しない。
◎
which identifies it within a specific storage key. The name is a name, and stays constant for the lifetime of the database.
</dd>

	<dt>
`~version@db
◎
A database has a version.＼
</dt>
	<dd>
%~db の~versionを表現する負でない整数。
%~db 作成-時の`~version$dbは， 0 である。
◎
When a database is first created, its version is 0 (zero).
</dd>
	<dd class="trans-note">【
%~db の作成-時には，自動的に`昇格~tx$が生じるので、
実質的には 1 （以上）として公開される（そのときに~errorが生じない限り）。
】</dd>
	<dd class="note">注記：
`~db$が同時に有し得る~versionは一つだけである
— 同時に複数の~versionを有する~dbは存在し得ない。
~versionを変更する仕方は、
`昇格~tx$を利用する他にない。
◎
NOTE: Each database has one version at a time; a database can’t exist in multiple versions at once. The only way to change the version is using an upgrade transaction.
</dd>

	<dt>
`昇格~tx@db
◎
A database has at most one associated upgrade transaction,＼
</dt>
	<dd>
`昇格~tx$または ε （存在しない）
— 初期~時は ε とする。
◎
 which is either null or an upgrade transaction, and is initially null.
</dd>
	<dd class="trans-note">【
所与の時点で`~db$に生じている`昇格~tx$を指す。
そのような~txは，在っても一つに限られ、
この`~db$を`~access先$とする，ある`接続$に`専属する$。
】</dd>
</dl>

			<section id="database-connection">
<h5 title="Database connection">2.1.1. ~db接続</h5>

<p>
~scriptが`~db$と直にヤリトリすることはない。
代わりに
`接続@
（ `connection^en ）を介して間接的に~accessする。
`接続$を利用すれば，`~db$を成す~objたちを操作できる。
それはまた、
`~db$用の`~tx$を得する唯一の仕方である。
◎
Script does not interact with databases directly. Instead, script has indirect access via a connection. A connection object can be used to manipulate the objects of that database. It is also the only way to obtain a transaction for that database.
</p>

<p class="trans-note">【
この訳では、
`接続$ %接続 の`~access先$の`~db$を %接続↗ とも記す。
】</p>

<p>
`接続$は，`~db$を~openすることにより作成される。
所与の`~db$を`~access先$とする，複数の`接続$が同時にあってもヨイ。
◎
The act of opening a database creates a connection. There may be multiple connections to a given database at any given time.
</p>

<p>
`接続$が~accessできる`~db$は、
その接続を~openした大域~scopeの`~storage~key$に`専属する$ものに限られる。
◎
A connection can only access databases associated with the storage key of the global scope from which the connection is opened.
</p>

<p class="note">注記：
これは、
`Document$I の `domain$m が変更されても影響されない。
◎
NOTE: This is not affected by changes to the Document’s domain.
</p>

<p>
各 `接続$ %接続 には、
次に挙げるものが結付けられる
（括弧内は、
`接続$を表現する `IDBDatabase!I ~interfaceの，対応する~member）：
◎
↓</p>

<dl class="def-list">
<!-- 
	<dt>
名前
（ name$m ）
</dt>
	<dd>
~openした~dbの名前$と同じであるが、
接続$は，~dbが削除されようが その名前を保持し続ける。
</dd>
 -->

	<dt>
`~version@Cn
（ `version$m ）
◎
A connection has a version,＼
</dt>
	<dd>
作成-時に設定され、
それ以降，変化しない。
ただし，`昇格~txが中止-$された場合、
%接続↗ である`~db$は，その元の~versionに戻される。
%接続 が`~close$されて以降は変化しない。
◎
which is set when the connection is created. It remains constant for the lifetime of the connection unless an upgrade is aborted, in which case it is set to the previous version of the database. Once the connection is closed the version does not change.
</dd>
	<dd class="trans-note">【
より詳細には、
%接続↗ の`昇格~tx$dbが`完遂-$して以降は変化しない。
】</dd>

	<dt>
`状態@Cn
◎
Each connection has a close pending flag＼
</dt>
	<dd>
%接続 の`状態$Cnは［
`~open中@i
→
`~close待ち@i
→
`~close済み@i
］の順に推移する。
後戻りすることはない。
◎
which is initially false.
</dd>
	<dd class="trans-note">【
この “状態” は，原文では
“`close pending flag^en（~close待ちか）”
という（上の `~open中$i と `~close待ち$i を区別する）真偽値で表現されているが、
原文の語
“`open^en”, “`close pending^en”, “`closed^en”
と状態遷移との対応関係を明瞭にするため，この訳では上のような定義に代えている
（ “後戻りしない” もこの訳による補完）。
】</dd>
	<dd>
<p>
状態が `~close済み$i になった %接続 は
<dfn>~closeされた</dfn>
ともいう
（そのようにする試みを<dfn>~closeする</dfn>という）。
%接続 は、
次のときに，`~close$され得る／させれる：
◎
When a connection is initially created it is in an opened state. The connection can be closed through several means.＼
</p>
		<ul>
			<li>
%接続 は、
それを作成した実行~文脈が破壊された場合には
（例えば、
利用者が当の~pageから他へ~navigateしたことに因り），
`~close$される。
◎
If the execution context where the connection was created is destroyed (for example due to the user navigating away from that page), the connection is closed.＼
</li>
			<li>
`~db接続を~closeする$手続きを利用すれば、
%接続 を明示的に`~close$させれる。
◎
The connection can also be closed explicitly using the steps to close a database connection. When the connection is closed its close pending flag is always set to true if it hasn’t already been.
</li>
			<li>
%接続 は、
例外的な状況下でも，~UAにより~closeされ得る
— 例えば、［
~file~systemへの~accessを失ったか, ~access許可が変更された
］とき，あるいは［
当の`~storage~key$に対する~storageが~clearされた
］ことに因り。
これが生じた場合、
~UAは次を走らすモノトスル
⇒
`~db接続を~closeする$( %接続, `強制する^i )
◎
A connection may be closed by a user agent in exceptional circumstances, for example due to loss of access to the file system, a permission change, or clearing of the storage key’s storage. If this occurs the user agent must run close a database connection with the connection and with the forced flag set to true.
</li>
		</ul>
	</dd>

	<dt>
`保管庫~集合@Cn
（ `objectStoreNames$m ）
◎
A connection has an object store set,＼
</dt>
	<dd>
%接続 の作成-時に， %接続↗ に`専属する$`保管庫$たちが成す集合に初期化される。
この集合の内容は、
%接続↗ の`昇格~tx$dbが`生きて$いる間を除いて，一定であり続ける。
◎
which is initialized to the set of object stores in the associated database when the connection is created. The contents of the set will remain constant except when an upgrade transaction is live.
</dd>
</dl>

<p>
`接続$の`親~targetを取得する$~algoは、
~NULL を返す。
◎
A connection’s get the parent algorithm returns null.
</p>

<p>
`versionchange@et
~eventは、
ある`接続$が`~db$を［
昇格する／削除する
］よう試みたとき，当の~dbを~openしている他の各`接続$に向けて発火される。
これは、
それら各`接続$に
— この試みを続行することを許容するよう —
各自の`接続$を~closeする機会を与える。
◎
An event with type versionchange will be fired at an open connection if an attempt is made to upgrade or delete the database. This gives the connection the opportunity to close to allow the upgrade or delete to proceed.
</p>

<p>
`close@et
~eventは、
`接続$が異常に~closeされたとき，当の接続に向けて発火される。
◎
An event with type close will be fired at a connection if the connection is closed abnormally.
</p>

			</section>
		</section>
		<section id="object-store-construct">
<h3 title="Object store">2.2. 保管庫</h3>

<p>
`保管庫@
（ `object store^en ）が、
`~db$に~dataを格納するための，首な~storageの仕組みである。
◎
An object store is the primary storage mechanism for storing data in a database.
</p>

<p>
どの`保管庫$も，ある`~db$に`専属する$。
`~db$に専属する`保管庫$たちが成す集合は、
`昇格~tx$を利用することを通して
— すなわち，`upgradeneeded$et ~eventに呼応して —
のみ変更できる。
新たな~dbが作成された時点では，それに`専属する$`保管庫$は無い。
◎
Each database has a set of object stores. The set of object stores can be changed, but only using an upgrade transaction, i.e. in response to an upgradeneeded event. When a new database is created it doesn’t contain any object stores.
</p>

<p>
各 `保管庫$ %保管庫 は、
次に挙げるものを有する
（括弧内は、
保管庫を`~access先$とする `IDBObjectStore!I ~objの対応する~member）：
◎
↓</p>

<dl class="def-list">
	<dt>
`~record~list@Os
◎
An object store has a list of records＼
</dt>
	<dd>
%保管庫 内に格納される`~record$たちが成す~listを保持する。
~list内の`~record$どうしは、
それらの`~key$の`昇順$に~sortされる。
同じ保管庫~内で，複数の~recordの`~key$が`等しく$なることは、
決してない。
◎
which hold the data stored in the object store. Each record consists of a key and a value. The list is sorted according to key in ascending order. There can never be multiple records in a given object store with the same key.
</dd>

	<dt>
`名前@Os
（ `name$m ）
◎
An object store has a name,＼
</dt>
	<dd>
`名前$。
この名前は、
どの時点においても， %保管庫 が`専属する$`~db$に`専属する$`保管庫$たちにわたって一意になる。
◎
which is a name. At any one time, the name is unique within the database to which it belongs.
</dd>

	<dt>
`~key~path@Os
（ `keyPath$m ）
◎
An object store optionally has a key path.＼
</dt>
	<dd>
`妥当な~key~path$, または ε 。
%保管庫 の作成-時に設定され、
それ以降（ ε かどうかも含め），変化しない。
◎
↓</dd>
	<dd>
`~key~path$Osが［
非 ε ／ ε
］であることは、
`~record$の`~key$として，`~record$の`値$の［
内にある／外から与えられた
］それを利用すること
（
`use in-line keys＠#object-store-in-line-keys@en† ／
`use out-of-line keys＠#object-store-out-of-line-keys@en †
）
を意味する。
◎
If the object store has a key path it is said to use in-line keys. Otherwise it is said to use out-of-line keys.
</dd>
	<dd class="trans-note">【†
この訳では、
これらの用語は利用せず，単に［
非 ε ／ ε
］で区別する。
】</dd>
	<dd class="trans-note">【
索引の`~key~path$Ixと違って、
`保管庫$の~key~pathは，空~文字列をとり得ない。
また、
`~key生成器$を有する場合は，文字列たちが成す~listもとり得ない。
】</dd>
	<dd class="trans-note">【
`~key~path$Os %P ~NEQ ε の場合、
%保管庫 の`~record~list$Osは，それを成すどの`~record$ %R も［
%R の`~key$ ~EQ~cmpkey `値から~keyを抽出する$( %R の`値$, %P )
］を満たすように拘束される。
】</dd>

	<dt>
`~key生成器$
◎
An object store optionally has a key generator.
</dt>
	<dd>
%保管庫 が~key生成器を有するかどうか（ `autoIncrement$m ）は、
%保管庫 の作成-時に設定され，それ以降は変化しない。
◎
↓</dd>
</dl>

<p>
`保管庫$を成す~recordの`~key$は、
次に挙げるいずれかの~sourceから導出され得る。
◎
An object store can derive a key for a record from one of three sources:
</p>

<p class="trans-note">【
すなわち，`~record~list$Osは、
外部から与えられる一連の値から，一連の［
~record｛ 導出された~key ： 値 ｝
］で拡充される。
】</p>

<ul>
	<li>
~keyが必要になる度に，単調に増加する番号による~keyを`~key生成器$から自動的に生成する。
◎
A key generator. A key generator generates a monotonically increasing numbers every time a key is needed.
</li>
	<li>
`~key~path$Osを介して，所与の`値から~keyを抽出する$。
◎
Keys can be derived via a key path.
</li>
	<li>
保管庫に値を格納するときに，明示的に
【すなわち，格納-用の~API~methodの引数にて】
~keyを指定する。
◎
Keys can also be explicitly specified when a value is stored in the object store.
</li>
</ul>

			<section id="object-store-handle-construct">
<h5 title="Object store handle">2.2.1. 保管庫~handle</h5>

<p>
~scriptが`保管庫$と直にヤリトリすることはない。
代わりに，ある`~tx$の中で
`保管庫~handle@
を介して間接的に~accessする。
◎
Script does not interact with object stores directly. Instead, within a transaction, script has indirect access via an object store handle.
</p>

<p>
各 `保管庫~handle$ %H には、
次に挙げるものが結付けられる
（括弧内は、
対応する `IDBObjectStore!I ~interface~member）：
◎
↓</p>

<dl class="def-list">
	<dt>
`保管庫@OsH
◎
An object store handle has an associated object store＼
</dt>
	<dd>
%H の`~access先$とされる`保管庫$。
【この訳では、もっぱら %H↗ と記す。】
◎
↑↑</dd>

	<dt>
`~tx@OsH
（ `transaction$m ）
◎
and an associated transaction.＼
</dt>
	<dd>
%H が`専属する$`~tx$。
【この訳では、この用語は利用せず，単にこのように記す。】
◎
↑↑</dd>
	<dd>
%H の［
取得-時／作成-時
］に，`可換性$と`一意性$の要件が満たされるように設定される。
◎
Multiple handles may be associated with the same object store in different transactions, but there must be only one object store handle associated with a particular object store within a transaction.
</dd>
	<dt>
`索引~集合@OsH
（ `indexNames$m ）
◎
An object store handle has an index set,＼
</dt>
	<dd>
%H の作成-時に，［
%H↗ に`専属する$`索引$たちが成す集合
］に初期化される。
◎
which is initialized to the set of indexes that reference the associated object store when the object store handle is created.＼
</dd>
	<dd>
この集合の内容は、
%H が`専属する$~txが［
`昇格~tx$であって, `生きて$いる間
］を除いて，一定であり続ける。
◎
The contents of the set will remain constant except when an upgrade transaction is live.
</dd>
	<dt>
`名前@OsH
（ `name$m ）
◎
An object store handle has a name,＼
</dt>
	<dd>
%H の作成-時に %H↗ の`名前$Osに初期化される。
◎
which is initialized to the name of the associated object store when the object store handle is created.＼
</dd>
	<dd>
この名前は、
%H が`専属する$~txが［
`昇格~tx$であって, `生きて$いる間
］を除いて，一定であり続ける。
◎
The name will remain constant except when an upgrade transaction is live.
</dd>
</dl>

			</section>
		</section>
		<section id="_record-construct">
<h3 class="trans-note">2.X. ~record</h3>

<p>
［
`保管庫$の`~record~list$Os ／
`索引$の`~record~list$Ix
］内に格納される
各
`~record@
は、
以下の節に述べる［
`~key$, `値$
］からなる。
</p>

<p>
所与の
( %~key, %値 )
を
( `~key$, `値$ )
とする`~record$は、
｛ %~key ： %値 ｝
とも表記される。
</p>

<p class="trans-note">【
この用語は，原文では保管庫のそれと索引のそれとで区別して定義されているが、
それらの総称を表す箇所も多いため，
この訳では総称として定義する
（どちらか一方を指す箇所において，どちらを指すかは、
文脈から容易に判別できる
— あるいは，そうなるよう記述を補完している）。
】</p>

		</section>
		<section id="value-construct">
<h3 title="Values">2.3. 値</h3>

<p>
各`~record$には
`値@
が結付けられる。
~UAは、
`直列化-可能$な どの~objも~supportするモノトスル†。
これには、
少なくとも次に挙げるものが含まれる
⇒＃
`String$jT などの単純~型の~primitive値,
`Date$jT,
`Object$jT,
`Array$jT,
`File$I,
`Blob$I,
`ImageData$I,
等々
◎
Each record is associated with a value. User agents must support any serializable object. This includes simple types such as String primitive values and Date objects as well as Object and Array instances, File objects, Blob objects, ImageData objects, and so on.＼
</p>

<p class="trans-note">【†
この要件は、
`保管庫$内の`~record$に限られる。
`索引$内の`~record$の`値$は、
常に その`参照先~record$の`~key$として与えられるので。
】</p>

<p>
~recordの`値$は、
参照~渡しではなく，値~渡しにより［
格納される／検索取得される
］。
［
格納-時に渡した／検索取得して得られた
］値が後で変更されても、
~db内に格納されている~recordには影響しない。
◎
Record values are stored and retrieved by value rather than by reference; later changes to a value have no effect on the record stored in the database.
</p>

<p>
~recordの`値$は、
`StructuredSerializeForStorage$jA 演算から出力される`~Record$である。
◎
Record values are Records output by the StructuredSerializeForStorage operation.
</p>

		</section>
		<section id="key-construct">
<h3 title="Keys">2.4. ~key</h3>

<p>
索引付き~db内に格納されている`~record$たちを効率的に検索取得するため、
`~record$たちは，各自の
`~key@
に則って組織化される。
◎
In order to efficiently retrieve records stored in an indexed database, each record is organized according to its key.
</p>

<p>
各 `~key$には、
次に挙げるものが結付けられる
◎
↓</p>
<dl class="def-list">
	<dt>
`型@key
◎
A key has an associated type＼
</dt>
	<dd>
`number@i
／
`date@i
／
`string@i
／
`binary@i
／
`array@i
◎
which is one of: number, date, string, binary, or array.
</dd>

	<dt>
`値@key
◎
A key also has an associated value,＼
</dt>
	<dd>
<p>
~keyの`型$keyに応じて，次に挙げる型の値をとる：
</p>
		<ul class="switch">
			<li>
`number$i ／ `date$i
⇒
`unrestricted double$I
</li>
			<li>
`string$i
⇒
`DOMString$I
</li>
			<li>
`binary$i
⇒
`~byte列$
</li>
			<li>
`array$i
⇒
0 個以上の他の`~key$（ `array$i 型も含む）たちが成す`~list$
</li>
		</ul>
◎
which will be either: an unrestricted double if type is number or date, a DOMString if type is string, a byte sequence if type is binary, or a list of other keys if type is array.
</dd>
</dl>

<p>
~JS `ECMA-262$r 値は、
`値を~keyに変換する$手続きに従って`~key$に変換される。
◎
An ECMAScript [ECMA-262] value can be converted to a key by following the steps to convert a value to a key.
</p>

<div class="note">
<p>
次に挙げる~JS型が，~keyとして妥当になる：
◎
NOTE: The following ECMAScript types are valid keys:
</p>

<ul>
	<li>
`NaN^jv 以外の `Number$jT ~primitive値。
`Infinity^jv, `-Infinity^jv も含まれる。
◎
Number primitive values, except NaN. This includes Infinity and -Infinity.
</li>
	<li>
`Date$jT ~objであって，その
`DateValue^sl 内部~slotは `NaN^jv でないもの。
◎
Date objects, except where the [[DateValue]] internal slot is NaN.
</li>
	<li>
`String$jT ~primitive値。
◎
String primitive values.
</li>
	<li>
各種`~buffer~source型$の~obj
（ `ArrayBuffer$I, あるいは `Uint8Array$I などの~buffer~view）。
◎
ArrayBuffer objects (or views on buffers such as Uint8Array).
</li>
	<li>
`Array$jT ~objであって、［
配列~内の どの~itemも定義されていて，~keyとして妥当である
］, かつ［
（直接的にも間接的にも）自身を包含していない
］もの。
特に，空な配列は妥当である。
配列は，他の配列を包含し得る。
◎
Array objects, where every item is defined, is itself a valid key, and does not directly or indirectly contain itself. This includes empty arrays. Arrays can contain other arrays.
</li>
</ul>

<p>
他の~JS値を`~key$に変換するよう試みても失敗することになる。
◎
Attempting to convert other ECMAScript values to a key will fail.
</p>

</div>

<p>
`array$i `型$keyの`~key$を特に
`配列~key@
という。
`配列~key$の`値$keyを成す各`~item$を
`下位key@
という。
◎
An array key is a key with type array. The subkeys of an array key are the items of the array key’s value.
</p>

<div class="algo">
<p>
`~keyどうしを比較する@
~algoは、
所与の
( `~key$ %a, `~key$ %b )
に対し：
◎
To compare two keys a and b, run these steps:
</p>
<ol>
	<li>
<p>
`~key$の`型$keyどうしの大小関係を［
`number$i ~LT `date$i ~LT `string$i ~LT `binary$i ~LT `array$i
］と定義する下で：
</p>
		<ol>
			<li>
~IF ［
%a の`型$key ~GT %b の`型$key
］
⇒
~RET 1
</li>
			<li>
~IF ［
%a の`型$key ~LT %b の`型$key
］
⇒
~RET −1
</li>
		</ol>
◎
Let ta be the type of a.
◎
Let tb be the type of b.
◎
If ta does not equal tb, then run these steps:
• If ta is array, then return 1.
• If tb is array, then return -1.
• If ta is binary, then return 1.
• If tb is binary, then return -1.
• If ta is string, then return 1.
• If tb is string, then return -1.
• If ta is date, then return 1.
• Assert: tb is date.
• Return -1.
</li>
	<li>
%va ~LET %a の`値$key
◎
Let va be the value of a.
</li>
	<li>
%vb ~LET %b の`値$key
◎
Let vb be the value of b.
</li>
	<li>
<p>
%a の`型$keyに応じて：
◎
Switch on ta:
</p>
		<dl class="switch">
			<dt>`number$i</dt>
			<dt>`date$i</dt>
			<dd>
				<ol>
					<li>
~IF［
%va ~GT %vb
］
⇒
~RET 1
◎
If va is greater than vb, then return 1.
</li>
					<li>
~IF［
%va ~LT %vb
］
⇒
~RET −1
◎
If va is less than vb, then return -1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>

			<dt>`string$i</dt>
			<dd>
				<ol>
					<li>
~IF［
%va は %vb `未満の符号単位~列$である
］
⇒
~RET −1
◎
If va is code unit less than vb, then return -1.
</li>
					<li>
~IF［
%vb は %va `未満の符号単位~列$である
］
⇒
~RET 1
◎
If vb is code unit less than va, then return 1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>

			<dt>`binary$i</dt>
			<dd>
				<ol>
					<li>
~IF［
%va は %vb `未満の~byte列$である
］
⇒
~RET −1
◎
If va is byte less than vb, then return -1.
</li>
					<li>
~IF［
%vb は %va `未満の~byte列$である
］
⇒
~RET 1
◎
If vb is byte less than va, then return 1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>

			<dt>`array$i</dt>
			<dd>
				<ol>
					<li>
<p>
~EACH( 整数 %i ~IN { 0 〜 min( %va の`~size$, %vb の`~size$ ) ~MINUS 1 } )
に対し，昇順に
◎
Let length be the lesser of va’s size and vb’s size.
◎
Let i be 0.
◎
While i is less than length, then:
</p>
						<ol>
							<li>
%c ~LET `~keyどうしを比較する$( %va[ %i ], %vb[ %i ] )
◎
Let c be the result of recursively comparing two keys with va[i] and vb[i].
</li>
							<li>
~IF［
%c ~NEQ 0
］
⇒
~RET %c
◎
If c is not 0, return c.
◎
Increase i by 1.
</li>
						</ol>
					</li>
					<li>
~IF［
%va の`~size$ ~GT %vb の`~size$
］
⇒
~RET 1
◎
If va’s size is greater than vb’s size, then return 1.
</li>
					<li>
~IF［
%va の`~size$ ~LT %vb の`~size$
］
⇒
~RET −1
◎
If va’s size is less than vb’s size, then return -1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>
</div>

<div class="algo">
<p>
2 つの`~key$ %a, %b の大小関係は、
`~keyどうしを比較する$( %a, %b ) の結果に応じて：
◎
↓</p>

<ul class="switch">
	<li>
1 ならば
⇒
%a は %b
`より大きい@
とされる。
◎
The key a is greater than the key b if the result of comparing two keys with a and b is 1.
</li>
	<li>
−1 ならば
⇒
%a は %b
`より小さい@
とされる。
◎
The key a is less than the key b if the result of comparing two keys with a and b is -1.
</li>
	<li>
0 ならば
⇒
%a は %b に
`等しい@
とされる。
◎
The key a is equal to the key b if the result of comparing two keys with a and b is 0.
</li>
</ul>
</div>

<p class="note">注記：
上の規則の結果として、
`-Infinity^jv が， `~key$がとり得る最小な値になる。
【！ Number keys are less than ... ↑】
`~key$がとり得る最大な値は無い
— いかなる`配列~key$に対しても、
その末尾に新たな`~key$を付加した結果の配列は，より大きくなるので。
◎
NOTE: As a result of the above rules, negative infinity is the lowest possible value for a key. Number keys are less than date keys. Date keys are less than string keys. String keys are less than binary keys. Binary keys are less than array keys. There is no highest possible key value. This is because an array of any candidate highest key followed by another key is even higher.
</p>

<p class="note">注記：
`binary$i 型の`~key$を成す各`~byte$は、
無符号~値（範囲 { 0 〜 255 } ）として比較される
— 有符号~値（範囲 { −128 〜 127 }）ではなく。
◎
NOTE: Members of binary keys are compared as unsigned byte values (in the range 0 to 255 inclusive) rather than signed byte values (in the range -128 to 127 inclusive).
</p>

<p>
この訳では、
表記
“<dfn id="_key_comparison">%関係記号<sub>key</sub></dfn>”
を利用して，次を表すことにする：
</p>
<ul>
	<li>
2 つの`~key$ %a, %b の比較
</li>
	<li>
2 つの`~key$~pair %p ~EQ ( %a1, %a2 ), %q ~EQ ( %b1, %b2 ) の比較†
</li>
	<li>
`~key$ %k が`~key範囲$ %R に`入る$か否か
</li>
	<li>
`~key$ %k が`~key$たちが成す集合 %K に含まれるか否か
</li>
</ul>

<table class="_row"><thead>
<tr><th>表記
<th>定義
<tbody>

<tr><th style="min-width: 7em;">%a ~GT~cmpkey %b
<td>%a は %b `より大きい$

<tr><th>%a ~LT~cmpkey %b
<td>%a は %b `より小さい$

<tr><th>%a ~EQ~cmpkey %b
<td>%a は %b に`等しい$

<tr><th>%a ~GTE~cmpkey %b
<td>
［
%a ~GT~cmpkey %b
］~OR［
%a ~EQ~cmpkey %b
］

<tr><th>%a ~LTE~cmpkey %b
<td>
［
%a ~LT~cmpkey %b
］~OR［
%a ~EQ~cmpkey %b
］

<tr><th>%p ~GT~cmpkey %q
<td>
［
%a1 ~GT~cmpkey %b1
］~OR［［
%a1 ~EQ~cmpkey %b1
］~AND［
%a2 ~GT~cmpkey %b2
］］

<tr><th>%p ~LT~cmpkey %q
<td>
［
%a1 ~LT~cmpkey %b1
］~OR［［
%a1 ~EQ~cmpkey %b1
］~AND［
%a2 ~LT~cmpkey %b2
］］

<tr><th>%p ~EQ~cmpkey %q
<td>
［
%a1 ~EQ~cmpkey %b1
］~AND［
%a2 ~EQ~cmpkey %b2
］

<tr><th>%p ~GTE~cmpkey %q
<td>
［
%p ~GT~cmpkey %q
］~OR［
%p ~EQ~cmpkey %q
］

<tr><th>%p ~LTE~cmpkey %q
<td>
［
%p ~LT~cmpkey %q
］~OR［
%p ~EQ~cmpkey %q
］

<tr><th>%k ~IN~cmpkey %R
<td>%k は %R に`入る$

<tr><th>%k ~NIN~cmpkey %R
<td>%k ~IN~cmpkey %R の否定

<tr><th>%k ~IN~cmpkey %K
<td>ある %key ~IN %K に対し， %k ~EQ~cmpkey %key

<tr><th>%k ~NIN~cmpkey %K
<td>%k ~IN~cmpkey %K の否定
</table>

<p>†
`~key$~pairの比較は、
簡潔に記すための，この訳による追加的な定義であり、
もっぱら，`索引$の~record
（または，［
それを意図して, あるいは それとの比較を意図して
］与えられる ( ~key, 値 ) ~pair）
どうしを比較するときに利用される。
</p>

		</section>
		<section id="key-path-construct">
<h3 title="Key path">2.5. ~key~path</h3>

<p>
`~key~path@
は、［
文字列／文字列たちが成す~list
］であり，`値$から`~key$を抽出する方法を定義する。
次に挙げるものが
`妥当な~key~path@
とされる：
◎
A key path is a string or list of strings that defines how to extract a key from a value. A valid key path is one of:
</p>

<ul>
	<li>
<p>
次に挙げる文字列：
</p>
		<ul>
			<li>
空~文字列
</li>
			<li>
`識別子@
— すなわち，~JSの `IdentifierName＠~TC39#prod-IdentifierName$js 生成規則に合致するもの
</li>
			<li>
複数個の`識別子$を `002E^U (`.^l) で分離して~~連結することにより得られるもの
</li>
		</ul>
◎
An empty string.
◎
An identifier, which is a string matching the IdentifierName production from the ECMAScript Language Specification [ECMA-262].
◎
A string consisting of two or more identifiers separated by periods (U+002E FULL STOP).
</li>
	<li>
前項に適合する文字列のみを包含している，空でない~list
◎
A non-empty list containing only strings conforming to the above requirements.
</li>
</ul>

<p class="note">注記：
~key~pathの中では space は許容されない。
◎
NOTE: Spaces are not allowed within a key path.
</p>

<p>
`~key~path$で~accessできる部位は、
`StructuredSerializeForStorage$jA により明示的に複製される~propに限られる
— 次に挙げる各種~型に特有な~propも含まれる：
◎
Key path values can only be accessed from properties explicitly copied by StructuredSerializeForStorage, as well as the following type-specific properties:
</p>

<table class="_row"><thead>
<tr><th>
型
◎
Type
<th>
~prop
◎
Properties
<tbody>

<tr><td>`Blob$I
<td>`size^m, `type^m

<tr><td>`File$I
<td>`name^m, `lastModified^m

<tr><td>`Array$jT
<td>`length^js

<tr><td>`String$jT
<td>`length^js
</table>

<p class="trans-note">【
`File^I に対しては、
`Blob^I を継承するので，上に挙げた `Blob^I の~propも含まれることになる。
】</p>

<div class="trans-note">
<p>【補記：】</p>

<p>
`~key~path$は、
~~任意に与えられる値（ ~obj ）の中のある一定の部位を表現する。
その目的は、
外から与える一連の値で，`保管庫$を`拡充する^emとき
— すなわち，値を`保管庫$の`~record~list$Osの中に`~record$の`値$として格納するとき —
に、
それらの値の中の［
~key~pathが指す部位に与えられた~data
］から，自動的に`~key$を導出することである。
あるいは、
`索引$を，それが`専属する$`保管庫$の`~record~list$Osに基づいて拡充するときにも、
同様に利用される。
例えば：
</p>

<ul>
	<li>
<p>
例えば，文字列による~key~path `a.b^l は、
任意の値 ~varV に対し，
`~varV.a.b^jv で~accessされる部位を指す：
</p>
		<ul>
			<li>
~varV ~EQ `{ a: { b: "c" }}^jv であったなら、
この~key~pathは，`~key$として `c^l を抽出する
（文字列の中の各 `002E^U (`.^l) が階層を辿る~pathの分離子を表す）。
</li>
			<li>
`~varV.a.b^jv に~accessし得ない場合
（例： `~varV.a^jv は `Object^jT でない）、
~varV からは~keyは抽出されないことになる
— この事例は、
この仕様では `失敗^i（ `failure^en ）という定数で表現される。
</li>
			<li>
`~varV.a.b^jv の値が~keyとして妥当でない場合
（例： `undefined^jv ）、
~varV からは~keyは抽出されないことになる
— この事例は、
この仕様では［
`無効な値^i （ `"invalid value"^en ）／
`無効な型^i （ `"invalid type"^en ）
］という定数で表現される。
</li>
		</ul>
	</li>
	<li>
空~文字列も~key~pathとして妥当であり、
それが指す部位は，値が何であろうと値~全体になる
（この~key~pathは`保管庫$には許容されないが）。
すなわち、
抽出される~keyは，常に値そのものになる。
</li>
	<li>
文字列たちが成す~listによる~key~pathが指す部位は、
その中の［
~key~pathとしての各 文字列が指す部位
］からなる配列になる。
例えば~key~path
« `a.b^l, `x.y.z^l »
は、
値 ~varV から，`配列~key$
`[ ~varV.a.b, ~varV.x.y.z ]^jv
を~keyとして抽出する。
</li>
</ul>

</div>

		</section>
		<section id="index-construct">
<h3 title="Index">2.6. 索引</h3>

<p>
`~key$以外の手段を通して，`保管庫$内の`~record$たちを検索取得できると有用になることもときどきある。
`索引@
（ `index^en ）は、［
`保管庫$内の`~record$たちを，それらの`値$の~propを通して検索する
］ことを許容する。
◎
It is sometimes useful to retrieve records in an object store through other means than their key. An index allows looking up records in an object store using properties of the values in the object stores records.
</p>

<p>
`索引$は、
ある~~目的に特化された`~record$たちからなる持続的な~storageであり、
その~dataは，以下に述べるとおり［
当の索引が`専属する$`保管庫$の~data
］に基いて拡充される。
各`索引$は、
次に挙げるものを有する
（括弧内は、
当の索引を`~access先$とする `IDBIndex!I ~objの対応する~member ）：
◎
An index is a specialized persistent key-value storage and has a referenced object store. The index has a list of records which hold the data stored in the index. The records in an index are automatically populated whenever records in the referenced object store are inserted, updated or deleted. There can be several indexes referencing the same object store, in which changes to the object store cause all such indexes to get updated.
</p>

<dl class="def-list">
	<dt>
`参照先の保管庫@
◎
↑</dt>
	<dd>
当の索引が`専属する$`保管庫$。
【この訳では、この用語は利用せず，単にこのように記す。】
索引の作成-時に設定される。
以下の各項では、
単に %保管庫 と記す。
◎
↑↑</dd>

	<dt>
`~record~list@Ix
◎
↓</dt>
	<dd>
<p>
当の索引に格納される~dataを保持する`~record$たちが成す~list。
この~listは、
%保管庫 の`~record~list$Os %L から自動的に拡充される：
</p>
		<ul>
			<li>
索引の作成-時に， %L に基づいて自動的に拡充される。
</li>
			<li>
%L ［
に~recordが挿入される ／
から~recordが削除される ／
の~recordの`値$が更新される
］度に，自動的に拡充される。
</li>
		</ul>

<p>
%L に変更が加えられる度に， %保管庫 に`専属する$すべての索引は更新されることになる。
</p>

<p class="trans-note">【
どのような規則に基づいて更新されるかの詳細は、
`§ 索引の拡充-法＠#_populating-an-index$に述べる。
】</p>
◎
↑↓</dd>

	<dt>
`~key~path@Ix （ `keyPath$m ）
◎
↓</dt>
	<dd>
<p>
`~key~path$。
</p>

<p>
索引~内のどの~record %R1 についても：
</p>
		<ul>
			<li>
<p>
%R1 の`値$は %保管庫 の`~record~list$Os %L 内のある`~record$の`~key$で与えられる。
</p>

<p>
`保管庫$における`~key$の一意性から、
そのような~record
— すなわち， %L 内の~recordのうち［
その`~key$ ~EQ~cmpkey %R1 の`値$
］を満たすもの %R —
は，一つだけ在ることになる。
この %R を指して， %R1 の
`参照先~record@
という。
</p>

<p class="trans-note">【
用語 `参照先~record$（および関連な記述）は、
他所を容易に述べるための，
この訳による追加。
</p>
			</li>
			<li>
%R1 の`~key$は［
%R の`値$の中の，この`~key~path$Ixが指す部位
］から`抽出される~key$（たちのいずれか）で与えられる。
</li>
		</ul>
<p>
索引の`~record~list$Ixは，そのように %R から導出される %R1 たちで拡充される。
</p>

◎
The values in the index’s records are always values of keys in the index’s referenced object store. The keys are derived from the referenced object store’s values using a key path. If a given record with key X in the object store referenced by the index has the value A, and evaluating the index’s key path on A yields the result Y, then the index will contain a record with key Y and value X.
</dd>
	<dd>
<div class="example" id="example-index-entries">
<p>
例えば，
%R ~EQ ｛ `123^c ： `{ name: "Alice", title: "CEO" }^c ｝
で，索引の`~key~path$Ixが `name^l ならば、
~key `Alice^l が抽出され，索引は
%R1 ~EQ｛ `Alice^l ： `123^c ｝
を包含することになる。
◎
For example, if an index’s referenced object store contains a record with the key 123 and the value { name: "Alice", title: "CEO" }, and the index’s key path is "name" then the index would contain a record with the key "Alice" and the value 123.
</p>
</div>

<p>
上述の %R （すなわち， %R1 の`参照先~record$）の`値$は、
%R1 の
`参照先の値@
と呼ばれる。
◎
Records in an index are said to have a referenced value. This is the value of the record in the index’s referenced object store which has a key equal to the index’s record’s value. So in the example above, the record in the index whose key is Y and value is X has a referenced value of A.
</p>

<p class="trans-note">【
が，この訳では、
この用語を利用せず，
一律に`参照先~record$の値と記すことにする。
】</p>

<div class="example" id="example-index-referenced-values">
<p>
先の例の
%R1 ~EQ｛ `Alice^l ： `123^c ｝
の`参照先~record$の値は，
`{ name: "Alice", title: "CEO" }^c
になる。
◎
In the preceding example, the record in the index with key "Alice" and value 123 would have a referenced value of { name: "Alice", title: "CEO" }.
</p>
</div>

<p class="note">注記：
【この段落の内容は、`§ 索引の拡充-法＠#_populating-an-index$に移譲。】
◎
NOTE: Each record in an index references one and only one record in the index’s referenced object store. However there can be multiple records in an index which reference the same record in the object store. And there can also be no records in an index which reference a given record in an object store.
</p>

<p>
索引~内の`~record$たちは、
常にその~keyに則って~sortされる。
保管庫と違い、
索引は，同じ~keyを伴う複数の~recordを包含し得るので、
それらの~recordは更に，それらの`値$（すなわち，`参照先~record$の~key）に則って~sortされる。
◎
The records in an index are always sorted according to the record’s key. However unlike object stores, a given index can contain multiple records with the same key. Such records are additionally sorted according to the index’s record’s value (meaning the key of the record in the referenced object store).
</p>
	</dd>

	<dt>
`名前@Ix
（ `name$m ）
◎
An index has a name,＼
</dt>
	<dd>
`名前$。
この名前は、
どの時点においても，同じ`保管庫$に`専属する$索引たちにわたって一意になる。
◎
which is a name. At any one time, the name is unique within index’s referenced object store.
</dd>

	<dt>
`一意か@Ix
（ `unique$m ）
◎
An index has a unique flag.＼
</dt>
	<dd>
真偽値。
~T にされた下では、
索引の~record~listは［
索引~内のどの 2 つの`~record$も同じ~keyを有さない
］条件の下で拡充される。
索引が`専属する$`保管庫$にて［
`~record$を［
挿入する／改変する
］試み
］は、［
索引の`~key~path$Ixを用いて その`~record$の値から`抽出される~key$（たちのいずれか）
］が［
索引~内のある`~record$の~key
］と同じになる（`等しい$）ならば，失敗する。
◎
When true, the index enforces that no two records in the index has the same key. If a record in the index’s referenced object store is attempted to be inserted or modified such that evaluating the index’s key path on the records new value yields a result which already exists in the index, then the attempted modification to the object store fails.
</dd>
	<dd class="trans-note">【
新たな`索引$を作成する試みも，この条件を満たせないときは同様に失敗する。
この場合の取扱いは
`IDBObjectStore.createIndex()$m
にて述べられる。
】</dd>

	<dt>
`複-~entryか@Ix
（ `multiEntry$m ）
◎
An index has a multiEntry flag.＼
</dt>
	<dd>
<p>
真偽値。
これは、
索引の`~key~path$Ixが指す（ %保管庫 に追加された`~record$の）部位が配列であるとき，索引がどう挙動するかに影響する：
◎
This flag affects how the index behaves when the result of evaluating the index’s key path yields an array key.＼
</p>
		<ul>
			<li>
~F の場合
⇒
索引には，その配列をそのまま`配列~key$とするような，単独の`~record$が追加される。
◎
If its multiEntry flag is false, then a single record whose key is an array key is added to the index.＼
</li>
			<li>
~T の場合
⇒
索引には，その配列~内の重複を除いた各`~key$ %key ごとに，［
%key を`~key$にするような，`~record$
］が追加される。
この場合、
`~key~path$Ixは文字列たちが成す~listをとり得ない。
◎
If its multiEntry flag is true, then one record is added to the index for each of the subkeys.
</li>
		</ul>
	</dd>
	<dd class="trans-note">【
この機能により、
各~recordに複数の “タグ” が付与されているような`~record~list$Osに対し，タグで検索するための索引を作成したり、
ある部位においてのみ異なる多数の`~record$を，一つに集約した上で取扱うことが可能になる。
】</dd>
</dl>

			<section id="_populating-an-index">
<h5>【索引の拡充-法】</h5>

<p class="trans-note">【
この節は、
原文の記述から導出した，この訳による補完である。
】</p>

<p>
所与の`索引$ %索引 に対し，［
%索引 の`~record~list$Ix %L1
］が［
%索引 が`専属する$`保管庫$の`~record~list$Os %L
］から精確にどう拡充されるかの詳細を、
以下に定式化する
（具体的な~algoは、
`§ 各種~db演算＠#database-operations$にて定義される）。
</p>

<p>
まず、
所与の`~record$ %R ~IN %L に対し，
`抽出される~key@
たちが成す集合 K( %R ) は，次で定義される：
</p>

<blockquote>
K( %R ) ~EQ `値から~key集合を抽出する$(
%R の`値$ ,
%索引 の`~key~path$Ix,
%索引 の`複-~entryか$Ix
)
</blockquote>

<p>
%L1 は，常に次の拘束が満たされるように拡充される：
</p>

<ul>
	<li>
<p>
どの %R ~IN %L に対しても、
各`~key$ %key ~IN K( %R ) に対し，
~AND↓ を満たす~record %R1 が %L1 内に唯一つ~~存在する：
</p>

		<ul>
			<li>
%R1 の`~key$ ~EQ~cmpkey %key
</li>
			<li>
%R1 の`値$ ~EQ~cmpkey %R の`~key$
</li>
		</ul>
	</li>
	<li>
%L1 は、
前項により導出されるもの以外の`~record$は含まない。
</li>
</ul>

<p>
%R が %R1 の`参照先~record$を与える。
［
%索引 の`複-~entryか$Ix ~EQ ~F
］ならば、
集合 K( %R ) は，常に 0 〜 1 個の~keyからなるので、
%L1 から %L への対応関係［
%R1 → %R1 の`参照先~record$
］は 単射になる。
また、
K( %R ) が常に空でないならば、
この対応関係は全射になる。
</p>

<p>
したがって、
索引の`~record~list$Ixは，索引が専属する保管庫の`~record~list$Osから一意に定まることになる。
例えば、
保管庫に~recordを追加してから新たな索引を作成した結果と，これを逆順に行った結果は
（~errorが生じなければ）
同じになる。
よって、
索引の~record~listを実際に構築しない実装も，原理的には可能になる
（処理能
— 例えば~recordの~sortなど —
との引き換えになるが）
（また，そのように~model化すれば、
この仕様の記述は，もっと簡略化できるであろう）。
</p>

			</section>
			<section id="index-handle-construct">
<h5 title="Index handle">2.6.1. 索引~handle</h5>

<p>
~scriptが`索引$と直にヤリトリすることはない。
代わりに`~tx$の中で
`索引~handle@
を介して間接的に~accessする。
◎
Script does not interact with indexes directly. Instead, within a transaction, script has indirect access via an index handle.
</p>

<p>
各`索引~handle$ %I には、
次に挙げるものが結付けられる
（括弧内は、
対応する `IDBIndex!I ~interface~member ）：
◎
↓</p>

<dl class="def-list">
	<dt>
`索引@IxH
◎
An index handle has an associated index＼
</dt>
	<dd>
%I の`~access先$とされる`索引$。
【この訳では、もっぱら %I↗ と記す。】
◎
↑↑</dd>

	<dt>
`保管庫~handle@IxH
（ `objectStore$m ）
◎
and an associated object store handle.＼
</dt>
	<dd>
%I が`専属する$`保管庫~handle$。
【この訳では、この用語は利用せず，単にこのように記す。】
◎
↑↑
</dd>

	<dt>
`~tx@IxH
◎
The transaction of an index handle＼
</dt>
	<dd>
%I （が`専属する$`保管庫~handle$）が`専属する$`~tx$。
【この訳では、この用語は利用せず，単にこのように記す。】
◎
is the transaction of its associated object store handle.＼
</dd>
	<dd>
上に挙げた %I の［
索引, 保管庫~handle, ~tx
］は、
%I の［
取得-時／作成-時
］に，`可換性$と`一意性$の要件が満たされるように設定される。
◎
Multiple handles may be associated with the same index in different transactions, but there must be only one index handle associated with a particular index within a transaction.
</dd>

	<dt>
`名前@IxH
（ `name$m ）
◎
An index handle has a name,＼
</dt>
	<dd>
%I の作成-時に %I↗ の`名前$Ixに初期化される。
この名前は、
%I が`専属する$`~tx$が［
`昇格~tx$であって, `生きて$いる間
］を除いて，一定であり続ける。
◎
which is initialized to the name of the associated index when the index handle is created. The name will remain constant except when an upgrade transaction is live.
</dd>
</dl>

			</section>
		</section>
		<section id="transaction-construct">
<h3 title="Transactions">2.7. ~tx</h3>

<p>
`~db$内の~dataとヤリトリするとき
— すなわち，~dataを読取る／書込むとき —
は、
常に
`~tx@
（ `transaction^en, “トランス動作” ）が利用される。
◎
A transaction is used to interact with the data in a database. Whenever data is read or written to the database it is done by using a transaction.
</p>

<div class="p">
<p>
`~tx$は、［
~app／~system
］の失敗に対する一定の保護を提供する：
</p>

<ul>
	<li>
一度に複数の~data~recordを格納したり，~data~recordを条件付きで改変するために利用できる。
</li>
	<li>
~~時間を要する［
~data~access／~data変異
］演算からなる，不可分な集合を表現する。
</li>
</ul>

<p class="trans-note">【
すなわち，失敗-時には、
中途半端な状態にならないよう，これらによる変異~すべてが元の状態に復帰される。
】</p>
◎
Transactions offer some protection from application and system failures. A transaction may be used to store multiple data records or to conditionally modify certain data records. A transaction represents an atomic and durable set of data access and data mutation operations.
</div>

<p>
各 `~tx$には、
次に挙げるものが結付けられる
（括弧内は、
対応する `IDBTransaction!I ~interface~member ）：
◎
↓</p>

<dl class="def-list">
	<dt>
`接続@tx
（ `db$m ）
◎
↓</dt>
	<dd>
すべての`~tx$は、
ある`接続$を通して`作成-$される
（後述の`存続期間$を見よ）。
~txは、
その`接続$に`専属する$。
◎
All transactions are created through a connection, which is the transaction’s connection.
</dd>
	<dd class="trans-note">【
この訳では、
この接続を指すときは，もっぱら
“（~txが）専属する接続”
と記す。
】</dd>

	<dt>
`視野@
（ `objectStoreNames$m ）
◎
A transaction has a scope＼
</dt>
	<dd>
`~tx$がヤリトリし得る`保管庫$たちが成す集合。
◎
which is a set of object stores that the transaction may interact with.
</dd>
	<dd class="note">注記：
視野は、
`昇格~tx$でない限り，固定され続ける。
◎
NOTE: A transaction’s scope remains fixed unless the transaction is an upgrade transaction.
</dd>
	<dd class="trans-note">【
視野は、
`~tx$の作成-時に決定され，内容は変化しない。
`昇格~tx$の視野は、
`常に^em，それが`専属する$`接続$の`保管庫~集合$Cnになる。
】</dd>
	<dd>
2 つの`~tx$は、
ある`保管庫$が両`~tx$の`視野$に入るならば，
`視野が重合して@
いるとされる
◎
Two transactions have overlapping scope if any object store is in both transactions' scope.
</dd>

	<dd class="trans-note">【
各~txは、
同じ`保管庫$を，
<strong>別々な`保管庫~handle$を通して</strong>
各自の
“視野に入れる”
ことに注意。
】</dd>

	<dt>
`~mode@
（ `mode$m ）
◎
A transaction has a mode＼
</dt>
	<dd>
<p>
`~tx$が，どの型のヤリトリを遂行できるかを決定する。
`~mode$は，~txの作成-時に設定され、
~txが存続する間，変化しない。
次のいずれか：
◎
that determines which types of interactions can be performed upon that transaction. The mode is set when the transaction is created and remains fixed for the life of the transaction. A transaction’s mode is one of the following:
</p>

		<dl>
			<dt>`readonly@l</dt>
			<dd>
この型の`~tx$には、
~dataを読取ることのみが許容され，改変は行えない。
`readonly^l ~txには、
複数のそれらを同時に`開始-$できる優位性がある
— 互いの`視野が重合して$いようが
（すなわち，同じ保管庫を利用していても）。
この型の~txは、
~dbが~openされたなら，いつでも作成できる。
【！ 手短に言えば、［ 同じ保管庫を視野に入れている，この型の~txたち ］は，その保管庫を排他的に占有する。】
◎
The transaction is only allowed to read data. No modifications can be done by this type of transaction. This has the advantage that several read-only transactions can be started at the same time even if their scopes are overlapping, i.e. if they are using the same object stores. This type of transaction can be created any time once a database has been opened.
</dd>

			<dt>`readwrite@l</dt>
			<dd>
この型の`~tx$には、
既存の保管庫から~dataを読取ることに加えて，~dataを［
改変する／削除する
］ことも許容される。
しかしながら、
保管庫や索引を［
追加する, 除去する
］ことはできない。
また、［
互いの`視野が重合して$いる複数の `readwrite^l `~tx$
］を同時に`開始-$させることはできない
— そうすると，~txの間に互いの~dataを改変し得ることになるので。
この型の~txは、
~dbが~openされたなら，いつでも作成できる。
◎
The transaction is allowed to read, modify and delete data from existing object stores. However object stores and indexes can’t be added or removed. Multiple "readwrite" transactions can’t be started at the same time if their scopes are overlapping since that would mean that they can modify each other’s data in the middle of the transaction. This type of transaction can be created any time once a database has been opened.
</dd>
			<dd class="trans-note">【
言い換えれば、
視野に入れている保管庫たちを排他的に占有する。
】</dd>

			<dt>`versionchange@l</dt>
			<dd>
この型の`~tx$には、
既存の保管庫から~dataを［
読取る, 改変する, 削除する
］ことに加えて，保管庫や索引を［
作成する, 除去する
］こともできる。
それは、
この型の~txのみが行い得る。
この型の~txは、
手動では作成できない
— 代わりに `upgradeneeded$et ~eventが発火されるときに自動的に作成される。
◎
The transaction is allowed to read, modify and delete data from existing object stores, and can also create and remove object stores and indexes. It is the only type of transaction that can do so. This type of transaction can’t be manually created, but instead is created automatically when an upgradeneeded event is fired.
</dd>
			<dd class="trans-note">【
言い換えれば、
接続先~db全体を排他的に占有する。
`昇格~tx$とも呼ばれる。
】</dd>

		</dl>
	</dd>

	<dt>
`耐久能~hint@
（ `durability$m ）
◎
A transaction has a durability hint.＼
</dt>
	<dd>
<p>
これは、
当の~txを~commitするときに，［
処理能, 耐久能
］のどちらを優先するかを~UAに~hintする。
次に挙げるいずれかをとる：
◎
This is a hint to the user agent of whether to prioritize performance or durability when committing the transaction. The durability hint is one of the following:
</p>
		<dl>
			<dt>`strict$l</dt>
			<dd>
~UAは、［
未決な変更~すべてが持続的な~storage媒体に成功裡に書込まれたことを検証yした後
］に限り，`~tx$は成功裡に`~commit$されたものと見なしてヨイ。
◎
The user agent may consider that the transaction has successfully committed only after verifying that all outstanding changes have been successfully written to a persistent storage medium.
</dd>

			<dt>`relaxed$l</dt>
			<dd>
~UAは、
未決な変更~すべてが~OSに書込まれ次第
— 後続な検証yは伴わずに —
`~tx$は成功裡に`~commit$されたものと見なしてヨイ。
◎
The user agent may consider that the transaction has successfully committed as soon as all outstanding changes have been written to the operating system, without subsequent verification.
</dd>

			<dt>`default$l</dt>
			<dd>
~UAは、
自身による既定の［
`~storage~bucket$用の耐久能の挙動
］を利用するベキである。
これは、
`~tx$用に他が指定されない場合の既定になる。
◎
The user agent should use its default durability behavior for the storage bucket. This is the default for transactions if not otherwise specified.
</dd>
		</dl>
	</dd>
	<dd class="note">
<p>注記：
代表的な実装においては、
`strict$l は，［
`complete$et ~eventが発火される前に~OSの入出力~bufferを一掃する
］よう~UAに~hintする。
これは、［
後続な［
~OS~crash／電力~喪失
］事例においても，変更は持続化する
］ことになる確度を高めるが、
~bufferを一掃するのに有意な時間がかかり得るため，携帯~機器の~battery-lifeを消費し得る。
◎
NOTE: In a typical implementation, "strict" is a hint to the user agent to flush any operating system I/O buffers before a complete event is fired. While this provides greater confidence that the changes will be persisted in case of subsequent operating system crash or power loss, flushing buffers can take significant time and consume battery life on portable devices.
</p>

<p>
~web~appには、［
~cacheや~recordが素早く変化するなどの短命な~data用には `relaxed$l ／
~data喪失の~riskを抑制することが処理能や電力への影響iに勝る事例においては `strict$l
］を利用することが奨励される。
実装には、
~appからの耐久能~hintを利用者や機器に対する影響iより重視することが奨励される。
◎
Web applications are encouraged to use "relaxed" for ephemeral data such as caches or quickly changing records, and "strict" in cases where reducing the risk of data loss outweighs the impact to performance and power. Implementations are encouraged to weigh the durability hint from applications against the impact to users and devices.
</p>
	</dd>

	<dt>
`片付ける~event~loop@
◎
A transaction optionally has a cleanup event loop＼
</dt>
	<dd>
`~event~loop$, または ε （初期-時）
◎
which is an event loop.
</dd>

	<dt>
`要請~list@
◎
A transaction has a request list of pending requests＼
</dt>
	<dd>
~txに`設置-$された処理待ち`要請$たちが成す【設置された順による】~list。
◎
which have been made against the transaction.
</dd>

	<dt>
`~error@tx
（ `error$m ）
◎
A transaction has a error＼
</dt>
	<dd>
初期時は ε 。
`~tx$が~errorにより`中止-$されたときに設定される。
◎
which is set if the transaction is aborted.
</dd>
	<dd class="note">注記：
実装者は、［
値 ~NULL をとる場合も~errorとして見なされる
］ことを念頭に置く必要がある
— それは、
`abort()$m ~methodから設定されるので。
◎
NOTE: Implementors need to keep in mind that the value "null" is considered an error, as it is set from abort()
</dd>
</dl>

<p>
`~tx$の`親~targetを取得する$~algoは、
~txが`専属する$`接続$を返す。
◎
A transaction’s get the parent algorithm returns the transaction’s connection.
</p>

<p>
`~mode$が `readonly$l にされた`~tx$を
`~readonly~tx@
という。
◎
A read-only transaction is a transaction with mode "readonly".
</p>

<p>
`~mode$が `readwrite$l にされた`~tx$を
`~readwrite~tx@
という。
◎
A read/write transaction is a transaction with mode "readwrite".
</p>

			<section id="transaction-lifecycle">
<h4 title="Transaction lifecycle">2.7.1. ~txの~lifecycle</h4>

<p>
`~tx$の
`状態@tx
は、
次に挙げるいずれかをとる：
◎
A transaction has a state, which is one of the following:
</p>

<dl>
	<dt>
`作動中@i
◎
active
</dt>
	<dd>
~txは、
新たに`作成-$されてから，それに`設置-$された`要請$からの~eventが配送される間は、
この状態にある。
◎
A transaction is in this state when it is first created, and during dispatch of an event from a request associated with the transaction.
</dd>
	<dd>
この状態にある~txに対しては、
新たな`要請$を為せる。
◎
New requests can be made against the transaction when it is in this state.
</dd>

	<dt>
`非作動中@i
◎
inactive
</dt>
	<dd>
~txは、
その作成~後［
~event~loopに制御が返され，~eventが配送されていない間
］は、
この状態にある。
◎
A transaction is in this state after control returns to the event loop after its creation, and when events are not being dispatched.
</dd>
	<dd>
この状態にある~txに対しては、
`要請$は為せない。
◎
No requests can be made against the transaction when it is in this state.
</dd>

	<dt>
`~commit中@i
◎
committing
</dt>
	<dd>
~txは、
それに設置されたすべての`要請$が完了したとき
— `~commit$するよう試みるに伴い —
この状態になる。
◎
Once all requests associated with a transaction have completed, the transaction will enter this state as it attempts to commit.
</dd>
	<dd>
この状態にある~txに対しては、
`要請$は為せない。
◎
No requests can be made against the transaction when it is in this state.
</dd>

	<dt>
`完遂d@i
◎
finished
</dt>
	<dd>
［
~commitされた／中止された
］~txは、
それ以降，この状態になる。
◎
Once a transaction has committed or aborted, it enters this state.
</dd>
	<dd>
この状態にある~txに対しては、
`要請$は為せない。
◎
No requests can be made against the transaction when it is in this state.
</dd>
</dl>

<p>
`~tx$は~~短命であるものと期待されている。
これは、
下に述べる自動`~commit$の機能性により促される。
◎
Transactions are expected to be short lived. This is encouraged by the automatic committing functionality described below.
</p>

<p class="note">注記：
それでも、
作者は，~txを長い間`生かし続け＠#transaction-live$れるが、
そのような用法は，利用者~体験を~~悪化させ得るので勧められない。
◎
NOTE: Authors can still cause transactions to stay alive for a long time; however, this usage pattern is not advised as it can lead to a poor user experience.
</p>

<p>
各`~tx$ %~tx は、
その
`存続期間@
にわたり，以下の順に変遷する：
◎
The lifetime of a transaction is as follows:
</p>
<ol>
	<li>
%~tx は、
`~mode$と`視野$を伴って
`作成-@
される。
その`状態$txは、
初期~時には `作動中$i になる。
◎
A transaction is created with a scope and a mode. When a transaction is created its state is initially active.
</li>
	<li>
実装は、
`§ ~txの~schedule法＠#transaction-scheduling$にて定義される［
`~tx$の［
`~mode$と`視野$
］に定義される拘束
］を施行-可能になったときは，
%~tx を非同期に
`開始-@
する`~db~taskを~queueする$モノトスル。
◎
When an implementation is able to enforce the constraints for the transaction’s scope and mode, defined below, the implementation must queue a database task to start the transaction asynchronously.
</li>
	<li>
<p>
%~tx が`開始-$されたなら、
%~tx に設置された各`要請$を実行し始めれるようになる。
それらの要請は、
`設置-$された順序で実行するモノトスル。
同様に、
それらの結果も，同じ順序で返す†モノトスル
— 異なる`~tx$に`設置-$された要請たちの間では、
返される順序は保証されないが。
◎
Once the transaction has been started the implementation can begin executing the requests placed against the transaction. Requests must be executed in the order in which they were made against the transaction. Likewise, their results must be returned in the order the requests were placed against a specific transaction. There is no guarantee about the order that results from requests in different transactions are returned.
</p>

<p class="trans-note">【†
返すとは、
要請に向けてその完了を報告する~eventを発火することを意味する。
】</p>

<p class="note">注記：
`~tx$の`~mode$は、［
互いに異なる~txに対し， 2 つの要請の どちらが先に設置された
］としても，［
~db内に格納される結果の~dataには影響しない
］ことを確保する。
◎
NOTE: Transaction modes ensure that two requests placed against different transactions can execute in any order without affecting what resulting data is stored in the database.
</p>

	</li>
	<li>
%~tx に設置された各`要請$は、
`処理-済み$になったとき，［
`success$et ／ `error$et
］~eventが発火されることになる。
この~eventが`配送-$される間、
%~tx の`状態$txは `作動中$i になり，
%~tx に対し追加的な要請を為せるようになる。
~event配送-が完了したなら、
%~tx の`状態$txは，再び `非作動中$i になる。
◎
When each request associated with a transaction is processed, a success or error event will be fired. While the event is being dispatched, the transaction state is set to active, allowing additional requests to be made against the transaction. Once the event dispatch is complete, the transaction’s state is set to inactive again.
</li>
	<li>
<p>
%~tx は、
`完遂-$する前に，いつでも
`中止-@
され得る／できる
— %~tx が `作動中$i であろうと，まだ`開始-$されていなくても。
◎
A transaction can be aborted at any time before it is finished, even if the transaction isn’t currently active or hasn’t yet started.
</p>

<p>
明示的に `abort()$m を~callすれば、
`中止-$を起動することになる。
中止-は、
失敗した要請が~scriptにより取扱われなかった場合も，それに後続して起動される。
◎
An explicit call to abort() will initiate an abort. An abort will also be initiated following a failed request that is not handled by script.
</p>

<p>
%~tx が中止されたときは、
実装は，［
%~tx の間に`~db$に為されたすべての変更
］を元へ復帰させるモノトスル
【“巻戻し（ `roll back^en ）” とも称される】。
これには、［
`保管庫$の内容に対する変更 ／
`保管庫$や`索引$の［
追加／除去
］］も含まれる。
◎
When a transaction is aborted the implementation must undo (roll back) any changes that were made to the database during that transaction. This includes both changes to the contents of object stores as well as additions and removals of object stores and indexes.
</p>
	</li>
	<li>
<p>
実装は、
%~tx が ~AND↓ を満たすならば
`~commit@
するよう試みるモノトスル：
◎
The implementation must attempt to commit＼
</p>
		<ul>
			<li>
その`状態$tx ~EQ `非作動中$i
◎
an inactive transaction when＼
</li>
			<li>
設置されたすべての`要請$は完了した
◎
all requests placed against the transaction have completed＼
</li>
			<li>
前項の各~要請が返した結果は取扱われた
◎
and their returned results handled,＼
</li>
			<li>
新たな要請は設置されていない
◎
no new requests have been placed against the transaction,＼
</li>
			<li>
`中止-$されていない
◎
and the transaction has not been aborted
</li>
		</ul>

<p>
明示的に `commit()$m を~callすれば、
要請の結果が~scriptにより取扱われるのを待機することなく`~commit$を起動することになる。
◎
An explicit call to commit() will initiate a commit without waiting for request results to be handled by script.
</p>

<p>
%~tx を~commitするとき、
その`状態$txは `~commit中$i になる。
実装は，［
%~tx に設置された要請により`~db$に為されたすべての変更
］を不可分に書込むモノトスル
— すなわち、［
すべての変更を書込む
］か［
~disk書込n~errorなどが生じた場合には、
いかなる変更も~dbに書込まない
］かになるモノトスル。
それに伴い，`~txを中止-$する手続きが後続することになる。
◎
When committing, the transaction state is set to committing. The implementation must atomically write any changes to the database made by requests placed against the transaction. That is, either all of the changes must be written, or if an error occurs, such as a disk write error, the implementation must not write any of the changes to the database, and the steps to abort a transaction will be followed.
</p>
	</li>
	<li>
%~tx が［
`~commit$された／`中止-$された
］ときは、
その`状態$txは `完遂d$i になる。
◎
When a transaction is committed or aborted, its state is set to finished.
</li>
</ol>

<p>
実装は、
`作動中$i にある`~tx$に対しては
— まだ`開始-$されていなくても —
`要請$が`設置-$されることを許容するモノトスル。
`開始-$される前に設置された`要請$たちは、
開始されるまでは実行せずに，その順序も込みで保ち続けるモノトスル。
◎
The implementation must allow requests to be placed against the transaction whenever it is active. This is the case even if the transaction has not yet been started. Until the transaction is started the implementation must not execute these requests; however, the implementation must keep track of the requests and their order.
</p>

<p>
`~tx$は、［
それが`作成-$されたときから，その`状態$txが `完遂d$i に設定されるまで
］の間，
`生きて@
いるとされる。
◎
A transaction is said to be live from when it is created until its state is set to finished.
</p>

<div class="algo">
<p>
`索引付き~db~txを片付ける@
~algoは、
片付けられた~txが［
在れば ~T ／
無ければ ~F
］を返す：
◎
To cleanup Indexed Database transactions, run the following steps. They will return true if any transactions were cleaned up, or false otherwise.
</p>

<ol>
	<li>
%結果 ~LET ~F
◎
↓If there are no transactions with cleanup event loop matching the current event loop, return false.
</li>
	<li>
<p>
`~tx$のうち［
その`片付ける~event~loop$ ~EQ 現在の`~event~loop$
］を満たす
~EACH( %~tx )
に対し：
◎
For each transaction transaction with cleanup event loop matching the current event loop:
</p>
		<ol>
			<li>
%結果 ~SET ~T
◎
↑↓</li>
			<li>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</li>
			<li>
%~tx の`片付ける~event~loop$ ~SET ε
◎
Clear transaction’s cleanup event loop.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return true.
</li>
</ol>

<p class="note">注記：
この手続きは、
`HTML$r から呼出される。
それは、
~scriptから~callされた
`transaction()＠#dom-idbdatabase-transaction$c により作成された`~tx$は，~scriptが呼出した~taskが完了した時点で作動中でなくなることを確保する。
この手続きが走るのは、
`~tx$ごとに高々 1 回限りになる。
◎
NOTE: These steps are invoked by [HTML]. They ensure that transactions created by a script call to transaction() are deactivated once the task that invoked the script has completed. The steps are run at most once for each transaction.
</p>
</div>

<p>
`complete@et
~eventは、
成功裡に`~commit$された`~tx$に向けて発火される。
◎
An event with type complete is fired at a transaction that has successfully committed.
</p>

<p>
`abort@et
~eventは、
`中止-$された`~tx$に向けて発火される。
◎
An event with type abort is fired at a transaction that has aborted.
</p>

			</section>
			<section id="transaction-scheduling">
<h4 title="Transaction scheduling">2.7.2. ~txの~schedule法</h4>

<p>
`~tx$がいつ`開始-$できるかは、
次の拘束により定義される：
◎
The following constraints define when a transaction can be started:
</p>

<ul>
	<li>
<p>
`~readonly~tx$ %~tx は、［
~AND↓ を満たす`~readwrite~tx$は無い
］ならば`開始-$できる：
◎
A read-only transactions tx can start when there are no read/write transactions which:
</p>
		<ul>
			<li>
%~tx より前に`作成-$された
◎
Were created before tx; and
</li>
			<li>
%~tx と`視野が重合して$いる
◎
have overlapping scopes with tx; and
</li>
			<li>
`完遂-$していない
◎
are not finished.
</li>
		</ul>
	</li>
	<li>
<p>
`~readwrite~tx$ %~tx は［
~AND↓ を満たす`~tx$は無い
］ならば`開始-$できる：
◎
A read/write transaction tx can start when there are no transactions which:
</p>
		<ul>
			<li>
%~tx より前に`作成-$された
◎
Were created before tx; and
</li>
			<li>
%~tx と`視野が重合して$いる
◎
have overlapping scopes with tx; and
</li>
			<li>
`完遂-$していない
◎
are not finished.
</li>
		</ul>
	</li>
</ul>

<p>
実装は追加的な拘束を課してもヨイ。
例えば，実装は
⇒＃
`視野が重合して$いない`~readwrite~tx$を並列的に`開始-$することは要求されない／
同時に`開始-$される~txの個数に制限sを課してもヨイ
◎
Implementations may impose additional constraints. For example, implementations are not required to start non-overlapping read/write transactions in parallel, or may impose limits on the number of started transactions.
</p>

<div class="note">
<p>注記：
これらの拘束は、
次を含意する：
◎
NOTE: These constraints imply the following:
</p>

<ul>
	<li>
`~readonly~tx$は、
同時並行にいくつでも
— 互いの`視野が重合して$いようが —
`開始-$することが許容される。
◎
Any number of read-only transactions are allowed to be started concurrently, even if they have overlapping scopes.
</li>
	<li>
`~readonly~tx$が`生きて$いる間は，［
実装が その~txにより作成された`要請$を通して返す~data
］は一定であり続ける。
すなわち，同じ~data片を読取る 2 つの要請からは、
~dataが見出されるかどうかも含め，同じ結果を得られる。
◎
As long as a read-only transaction is live, the data that the implementation returns through requests created with that transaction remains constant. That is, two requests to read the same piece of data yield the same result both for the case when data is found and the result is that data, and for the case when data is not found and a lack of data is indicated.
</li>
	<li>
<p>
`~readwrite~tx$は、
他の`~tx$を利用して為された`保管庫$への変更からは影響されない。
実装は、
次を確保することになる：
</p>
		<ul>
			<li>
別の~txが，`~readwrite~tx$の`視野$に入る`保管庫$の内容を改変しない。
</li>
			<li>
`~readwrite~tx$が成功裡に完了したなら，その~txを利用して`保管庫$に書込まれた変更を
— 併合する際に競合することなく —
`~db$に~commitできる。
</li>
		</ul>
◎
A read/write transaction is only affected by changes to object stores that are made using the transaction itself. The implementation ensures that another transaction does not modify the contents of object stores in the read/write transaction’s scope. The implementation also ensures that if the read/write transaction completes successfully, the changes written to object stores using the transaction can be committed to the database without merge conflicts.
</li>
	<li>
複数の`~readwrite~tx$が同じ保管庫に~accessするよう試みた場合
（すなわち，それらの`視野が重合して$いる）、
先に`作成-$された~txが保管庫への~accessを先に取得する
— 当の~txが`完遂-$するまで、
保管庫に~accessできるのは，当の~txに限られる。
◎
If multiple read/write transactions are attempting to access the same object store (i.e. if they have overlapping scopes), the transaction that was created first is the transaction which gets access to the object store first, and it is the only transaction which has access to the object store until the transaction is finished.
</li>
	<li>
`~readwrite~tx$ %A の後に`作成-$された，~tx %B は、
%A と`視野が重合して$いる`保管庫$ %O が在るならば，
%A により書込まれた %O への変更を見ることになる。
これはまた，［
%A が`完遂-$するまでは、
%B は， %A の`視野$に入る どの`保管庫$にも~accessできない
］ことを意味する。
◎
Any transaction created after a read/write transaction sees the changes written by the read/write transaction. For example, if a read/write transaction A, is created, and later another transaction B, is created, and the two transactions have overlapping scopes, then transaction B sees any changes made to any object stores that are part of that overlapping scope. This also means that transaction B does not have access to any object stores in that overlapping scope until transaction A is finished.
</li>
</ul>
</div>

			</section>
			<section id="upgrade-transaction-construct">
<h4 title="Upgrade transactions">2.7.3. 昇格~tx</h4>

<p>
`~mode$が `versionchange$l にされた`~tx$を
`昇格~tx@
（ `upgrade transaction^en ）という。
◎
An upgrade transaction is a transaction with mode "versionchange".
</p>

<p>
`昇格~tx$は、
`~db$への`接続$が~openされた後，
`~dbを昇格する$手続きの間に、
指定された`~version$dbが現在の`~version$dbより大きい場合に，自動的に作成される†。
この`~tx$は、
`upgradeneeded$et ~event~handlerの内側で `作動中$i になる。
◎
An upgrade transaction is automatically created when running the steps to upgrade a database after a connection is opened to a database, if a version greater than the current version is specified. This transaction will be active inside the upgradeneeded event handler.
</p>

<p class="trans-note">【†
このとき以外に，`接続$に`専属する$`昇格~tx$が作成される機会cは無い。
したがってそれは、
同じ接続に`専属する$他のどの`~tx$よりも先に`開始-$されることになる。
】</p>

<div class="note">
<p>注記：
`昇格~tx$は、
`~db$内の［
`保管庫$ ／ `索引$
］の［
作成, 名前の変更, 削除
］を可能化する。
◎
NOTE: An upgrade transaction enables the creation, renaming, and deletion of object stores and indexes in a database.
</p>

<p>
`昇格~tx$は、
排他的である。
`~db接続を~openする$手続きは、［
`昇格~tx$が`生きて$いる間，~dbを~openしている`接続$
］は，唯一に限られることを確保する。
同じ`~db$への他のすべての`接続$が~closeされるまでは、
`upgradeneeded$et ~eventは発火されず，
したがって`昇格~tx$も開始されない。
これは、
以前のすべての~txが`完遂-$されることを確保する。
◎
An upgrade transaction is exclusive. The steps to open a database connection ensure that only one connection to the database is open when an upgrade transaction is live. The upgradeneeded event isn’t fired, and thus the upgrade transaction isn’t started, until all other connections to the same database are closed. This ensures that all previous transactions are finished.
</p>

<p>
`昇格~tx$が`生きて$いる間は、
同じ`~db$に対し他の`接続$を~openしようとする試みは遅延され、
同じ`接続$を利用するために `transaction()＠#dom-idbdatabase-transaction$c を~callして追加的な~txを開始しようとする試みに対しては，
例外が投出されることになる。
このことは、
次を確保する：
◎
As long as an upgrade transaction is live, attempts to open more connections to the same database are delayed, and any attempts to use the same connection to start additional transactions by calling transaction() will throw an exception.＼
</p>
<ul>
	<li>
`昇格~tx$が`生きて$いる間は、
同じ`~db$に対し，
同時並行に`生きて$いる他の~txは無く,
新たな~txが~queueされることも無い。
◎
This ensures that no other transactions are live concurrently, and also ensures that no new transactions are queued against the same database as long as the upgrade transaction is live.
</li>
	<li>
`昇格~tx$が完了したなら，`~db$内の［
`保管庫$, `索引$
］たちが成す集合は、
後続なすべての［
`接続$, `~tx$
］の存続期間において，一定であり続ける。
◎
This further ensures that once an upgrade transaction is complete, the set of object stores and indexes in a database remain constant for the lifetime of all subsequent connections and transactions.
</li>
</ul>

</div>

<p class="trans-note">【
この仕様に現れる，
`昇格~txの中@
という句は、［
`upgradeneeded$et ~eventにより呼出される~event~handlerの中
］を意味する。
“昇格~txの外”
という句は、
その否定を意味する。
】</p>

			</section>
		</section>
		<section id="request-construct">
<h3 title="Requests">2.8. 要請</h3>

<p>
`~db$に対する各 非同期の`演算$は、
`要請@
（ `request^en ）を利用して行われる。
どの %要請 も，ある一つの`演算$（以下， %演算 と記す）を表現し、
次に挙げるものが結付けられる
（括弧内は、
対応する `IDBRequest!I ~interface~member ）：
◎
Each asynchronous operation on a database is done using a request. Every request represents one operation.
</p>

<dl class="def-list">
	<dt>
`処理-済みか@
◎
A request has a processed flag＼
</dt>
	<dd>
真偽値。
初期~時は ~F とする。
これは、
%演算 が実行されたとき ~T に設定される。
◎
which is initially false. This flag is set to true when the operation associated with the request has been executed.
</dd>
	<dd>
`要請$は、
その`処理-済みか$ ~EQ ~T のとき，
`処理-済み@
という。
◎
A request is said to be processed when its processed flag is true.
</dd>

	<dt>
`済んだか@
（ `readyState$m ）
◎
A request has a done flag＼
</dt>
	<dd>
真偽値。
初期~時は ~F とする。
%演算 の結果が可用になったとき ~T に設定される。
◎
which is initially false. This flag is set to true when the result of the operation associated with the request is available.
</dd>

	<dt>
`~source@
（ `source$m ）
◎
A request has a source object.
</dt>
	<dd class="trans-note">【
%演算 の対象
— 次のいずれか：［
`保管庫~handle$／`索引~handle$／`~cursor$／ε
］。
%要請 の作成-時に設定され
（設定されない場合は ε ）、
それ以降は変化しない。
】</dd>

	<dt>
`結果@
（ `result$m ）
◎
A request has a result＼
</dt>
	<dt>
`~error@
（ `error$m ）
◎
and an error,＼
</dt>
	<dd>
`済んだか$ ~EQ ~T になるまでは~accessできない。
~T の時点で，どうなるかについては、
下記に。
◎
neither of which are accessible until its done flag is true.
</dd>

	<dt>
`設置-先~tx@
（ `transaction$m ）
◎
A request has a transaction＼
</dt>
	<dd>
初期~時は ε 。
%要請 は、
%演算 を走らす`要請を非同期に実行する$手続きを利用して，`~tx$に
`設置-@
される。
同時に， %要請 は設置-先~txの`要請~list$に追加される。
◎
which is initially null. This will be set when a request is placed against a transaction using the steps to asynchronously execute a request.
</dd>
</dl>

<div class="p">
<p>
`要請$が為されるときは、
新たな`要請$が その［
`済んだか$ ~SET ~F
］にされた上で返される。
`要請$が表現する
`演算@
は、
要請が非同期に実行する手続きの~instance
— すなわち，
( 手続き, それに対する入力, その結果 )
が成す組 —
である。
</p>

<p>
`要請$ %要請 がその`演算$の手続きを終えたときは、
先ず［
%要請 の`済んだか$ ~SET ~T
］にされた上で、
演算から返された %結果 に応じて：
</p>

<ul class="switch">
	<li>
<p>
~errorでない場合
（演算は成功した）：
</p>
		<ol>
			<li>
%要請 の`結果$は %結果 に設定され、
%要請 の`~error$は ε に設定される。
</li>
			<li>
%要請 に向けて
`success@et
~eventが発火される。
</li>
		</ol>
	</li>

	<li>
<p>
~errorである場合
（演算は失敗した）：
</p>
		<ol>
			<li>
%要請 の`結果$は ε に設定され、
%要請 の`~error$は %結果 に設定される。
</li>
			<li>
%要請 に向けて
`error@et
~eventが発火される。
</li>
		</ol>
	</li>
</ul>

◎
When a request is made, a new request is returned with its done flag set to false. If a request completes successfully, its done flag is set to true, its result is set to the result of the request, and an event with type success is fired at the request.
◎
If an error occurs while performing the operation, the request’s done flag is set to true, the request’s error is set to the error, and an event with type error is fired at the request.
</div>

<p>
`要請$の`親~targetを取得する$~algoは、
要請の`設置-先~tx$を返す。
◎
A request’s get the parent algorithm returns the request’s transaction.
</p>

<p class="note">注記：
要請は概して，再利用されないが、
例外もある。
`~cursor$が反復されるときは、
その~cursorを~openするときに利用した同じ`要請$に向けて，反復の成功が報告される。
また，`昇格~tx$が必要yな場合も、
同じ`~open要請$が［
`upgradeneeded$et ~event, ~open演算~自身の最終~結果
］の両者に利用される。
事例によっては、
要請の`済んだか$は ~F に設定されてから再び ~T に設定され，
`結果$は変化する, あるいは`~error$が設定されることもある。
◎
NOTE: Requests are not typically re-used, but there are exceptions. When a cursor is iterated, the success of the iteration is reported on the same request object used to open the cursor. And when an upgrade transaction is necessary, the same open request is used for both the upgradeneeded event and final result of the open operation itself. In some cases, the request’s done flag will be set to false, then set to true again, and the result can change or error could be set instead.
</p>

			<section id="open-requests">
<h4 title="Open requests">2.8.1. ~open要請</h4>

<p>
`~open要請@
は、［
`接続$を~openするとき,
`~db$を削除するとき
］に利用される，特別な型の`要請$である。
`~open要請$に対しては：
◎
An open request is a special type of request used when opening a connection or deleting a database.＼
</p>
<ul>
	<li>
［
`success$et, `error$et
］~eventに加え，進捗を指示する［
`blocked@et,
`upgradeneeded@et
］~eventも発火され得る。
◎
In addition to success and error events, blocked and upgradeneeded events may be fired at an open request to indicate progress.
</li>
	<li>
その`~source$は常に ε である。
◎
The source of an open request is always null.
</li>
	<li>
その`設置-先~tx$は、
`upgradeneeded$et ~eventが発火されない限り， ε にされる。
【！ その~txが完遂したときも ε に戻される】
◎
The transaction of an open request is null unless an upgradeneeded event has been fired.
</li>
	<li>
その`親~targetを取得する$~algoは、
~NULL を返す。
◎
An open request’s get the parent algorithm returns null.
</li>
</ul>

			</section>
			<section id="connection-queues">
<h4 title="Connection queues">2.8.2. 接続~queue</h4>

<p>
`~open要請$は
`接続~queue@
にて処理される。
この~queueは、
( `~storage~key$, `名前$db )
が成す組に結付けられる，すべての`~open要請$を包含する†。
`接続~queue$に追加された各 要請は、
順序どおりに処理され，次の要請が処理される前に完了するモノトスル。
~open要請は、
【それが~openしようとしている~dbを~openしている】
他の`接続$により阻まれ得る
— それらの接続が`~close$されるまで、
その要請は完了せず，更なる要請は処理できないことになる。
◎
Open requests are processed in a connection queue. The queue contains all open requests associated with an storage key and a name. Requests added to the connection queue processed in order and each request must run to completion before the next request is processed. An open request may be blocked on other connections, requiring those connections to close before the request can complete and allow further requests to be processed.
</p>

<p class="trans-note">【†
言い換えれば，接続~queueは、
同じ`~db$
（その`~storage~key$に`専属する$, かつ その名前を有するものとして一意に定まる）
に対し，
それを`~access先$とする`接続$を~openしようとする`要請$すべてからなる。
】</p>

<p class="note">注記：
`接続~queue$は、
`~event~loop$に結付けられる`~task~queue$ではない
— 要請は、
すべての`閲覧~文脈$の外側で処理されるので。
それでも、
完了した`~open要請$向けの~eventは，［
要請を為した文脈~下の`~event~loop$に結付けられた`~task~queue$
］を通して送達される。
◎
NOTE: A connection queue is not a task queue associated with an event loop, as the requests are processed outside any specific browsing context. The delivery of events to completed open request still goes through a task queue associated with the event loop of the context where the request was made.
</p>

			</section>
		</section>
		<section id="range-construct">
<h3 title="Key range">2.9. ~key範囲</h3>

<p>
`保管庫$や`索引$から一連の`~record$を検索取得するためには、［
単独の`~key$, または`~key範囲$
］を利用する。
`~key範囲@
とは、
~keyに利用される ある~data型にわたる連続的な区間である。
◎
Records can be retrieved from object stores and indexes using either keys or key ranges. A key range is a continuous interval over some data type used for keys.
</p>

<p>
各 `~key範囲$には、
次に挙げるものが結付けられる
（括弧内は、
対応する `IDBKeyRange!I ~interface~member）
【これらは、作成-時に設定され，それ以降は変化しない】
：
◎
↓</p>

<dl class="def-list">
	<dt>
`下界@
（ `lower$m ）
◎
A key range has an associated lower bound＼
</dt>
	<dd>
`~key$, または ε 。
◎
(null or a key).
</dd>
	<dt>
`上界@
（ `upper$m ）
◎
A key range has an associated upper bound＼
</dt>
	<dd>
`~key$, または ε 。
◎
(null or a key).
</dd>

	<dt>
`下界openか@
（ `lowerOpen$m ）
◎
A key range has an associated lower open flag.＼
</dt>
	<dd>
真偽値。
他が指定されない限り ~F とする。
◎
Unless otherwise stated it is false.
</dd>
	<dd class="trans-note">【
`下界$ ~EQ ε の場合は、
必ず ~T にされる。
】</dd>

	<dt>
`上界openか@
（ `upperOpen$m ）
◎
A key range has an associated upper open flag.＼
</dt>
	<dd>
真偽値。
他が指定されない限り ~F とする。
◎
Unless otherwise stated it is false.
</dd>
	<dd class="trans-note">【
`上界$ ~EQ ε の場合は、
必ず ~T にされる。
】</dd>
</dl>

<p>
［
`下界$ ~GT~cmpkey `上界$
］にはならないモノトスル。
◎
A key range may have a lower bound equal to its upper bound. A key range must not have a lower bound greater than its upper bound.
</p>

<div class="algo">
`~keyのみを包含する範囲@
は、
所与の
( `~key$ %key )
に対し
⇒
~RET 新たな`~key範囲$を返す
— その
⇒＃
`下界$ ~SET %key,
`上界$ ~SET %key,
`上界openか$ ~SET ~F,
`下界openか$ ~SET ~F
◎
A key range containing only key has both lower bound and upper bound equal to key.
</div>

<p>
所与の`~key$ %key が`~key範囲$ %範囲 に
`入る@
とは、
~AND↓ が満たされることをいう：
◎
A key is in a key range range if both of the following conditions are fulfilled:
</p>
<ul>
	<li>
<p>
~OR↓：
</p>
		<ul>
			<li>
%範囲 の`下界$ ~EQ ε
</li>
			<li>
%範囲 の`下界$ ~LT~cmpkey %key
</li>
			<li>
［
%範囲 の`下界$ ~EQ~cmpkey %key
］~AND［
%範囲 の`下界openか$ ~EQ ~F
］
</li>
		</ul>
◎
The range’s lower bound is null, or it is less than key, or it is both equal to key and the range’s lower open flag is false.
</li>
	<li>
<p>
~OR↓：
</p>
		<ul>
			<li>
%範囲 の`上界$ ~EQ ε
</li>
			<li>
%範囲 の`上界$ ~GT~cmpkey %key
</li>
			<li>
［
%範囲 の`上界$ ~EQ~cmpkey %key
］~AND［
%範囲 の`上界openか$ ~EQ ~F
］
</li>
		</ul>
◎
The range’s upper bound is null, or it is greater than key, or it is both equal to key and the range’s upper open flag is false.
</li>
</ul>

<div class="note">
<p>注記：
［
`下界$ ／ `上界$
］は、
`~key範囲$に`入る$とされる`~key$の［
“~~下限” ／ “~~上限”
］を与える。
［
`下界$ ／ `上界$
］に対する ε は［
~~下限／~~上限
］が無いことを表す。
</p>

<p>
`下界$は、［
`下界openか$ ~EQ ~F
］のとき, そのときに限り，`~key範囲$に`入る$。
`上界openか$についても同様になる。
</p>

◎
NOTE:
• If a key range’s lower open flag is false, the lower bound key of the key range is included in the range itself.
• If a key range’s lower open flag is true, the lower bound key of the key range is excluded from the range itself.
• If a key range’s upper open flag is false, the upper bound key of the key range is included in the range itself.
• If a key range’s upper open flag is true, the upper bound key of the key range is excluded from the range itself.
</div>

<p>
`全範囲@
とは、［
`下界$ ~EQ `上界$ ~EQ ε
］を満たす`~key範囲$である。
どの`~key$に対しても，［
`~key$ ~IN~cmpkey `全範囲$
］は満たされる。
◎
An unbounded key range is a key range that has both lower bound and upper bound equal to null. All keys are in an unbounded key range.
</p>

<p class="trans-note">【
`全範囲$は `IDBKeyRange$I ~objとしては~instance化され得ない
— ~modelにのみ存在する~objである。
】</p>

<div class="algo">
<p>
`~key範囲へ変換する@
~algoは、
所与の
( %値, %~NULL不可 ~DF ε )
に対し：
◎
To convert a value to a key range with value and optional null disallowed flag, run these steps:
</p>

<ol>
	<li>
~IF［
%値 は`~key範囲$である
］
⇒
~RET %値
◎
If value is a key range, return value.
</li>
	<li>
<p>
~IF［
%値 ~IN { ε, ~NULL† }
］：
</p>
		<ol>
			<li>
~IF ［
%~NULL不可 ~NEQ ε
］
⇒
~THROW `DataError$E
</li>
			<li>
~RET `全範囲$
</li>
		</ol>
◎
If value is undefined or is null, then throw a "DataError" DOMException if null disallowed flag is true, or return an unbounded key range otherwise.
</li>
	<li>
%~key ~LET `Key$( %値 ) ？
◎
Let key be the result of converting a value to a key with value. Rethrow any exceptions.
◎
If key is "invalid value" or "invalid type", throw a "DataError" DOMException.
</li>
	<li>
~RET `~keyのみを包含する範囲$( %~key )
◎
Return a key range containing only key.
</li>
</ol>

<p class="trans-note">【†
この手続きは、
~key範囲を期待する引数
（この仕様において，［
%query ／ %queryOrOptions
］と命名されたもの）
をとる~API~methodから呼び出される。
その引数が省略可能であって, ~NULL が渡された場合、
特別に，引数が省略されたとき（ ε ）と同じに扱われることになる。
】</p>
</div>

<p>
所与の~JS値 %値 が
`妥当な~key範囲になり得る@
とは、［
%値 の型を成す ある値として`~key範囲$へ変換-可能なものがある
］ことをいう。
%値 が`~key範囲$へ成功裡に変換されるかどうか
— すなわち `~key範囲へ変換する$( %値 ) が例外を投出するかどうか —
とは関連しない。
◎
A potentially valid key range is an ECMAScript value that has a type that is convertible to a key range. Whether the specific value will successfully convert to a key range, i.e. converting a value to a key range with it throws an exception, is not relevant.
</p>

<p class="note">注記：
例えば、
`~buffer~source型$の~obj %O は，`妥当な~key範囲になり得る$が、
%O が`切離されて$いた場合， `~key範囲へ変換する$( %O ) は例外を投出することになる。
◎
NOTE: For example, a detached BufferSource is a potentially valid key range that will throw an exception when used with convert a value to a key range.
</p>

<div class="algo">
<p>
`妥当な~key範囲になり得るか否か@
を決定する~algoは、
所与の
( ~JS値 %値 )
に対し：
◎
To determine when a value is a potentially valid key range with ECMAScript value, run these steps:
</p>
<ol>
	<li>
~IF［
%値 は`~key範囲$である
］
⇒
~RET ~T
◎
If value is a key range, return true.
</li>
	<li>
%~key ~LET `値を~keyに変換する$( %値 ) ？
◎
Let key be the result of converting a value to a key with value.
</li>
	<li>
~RET ~IS［
%~key ~NEQ `無効な型^i
］
◎
If key is "invalid type" return false.
◎
Else return true.
</li>
</ol>

<div class="note"> 
<p>注記：
`IDBObjectStore!I の［
`getAll()$m, `getAllKeys()$m
］~method,
および
`IDBIndex!I の［
`getAll()$m, `getAllKeys()$m
］~methodは、
その最初の引数 %引数 に対し：
◎
NOTE: The getAll() and getAllKeys() methods＼
</p>
<ul>
	<li>
%引数 が`妥当な~key範囲になり得るか否か$を検査する【！use 〜 to handle】。
結果が ~T ならば、
これらの~methodは， `~key範囲へ変換する$( %引数 ) を走らす。
他の場合、
%引数 は `IDBGetAllOptions$I として解釈される【！is used for】
【その場合も， `~key範囲へ変換する$( %引数[ "`query$mb" ] ) を走らすことになる】。
◎
use is a potentially valid key range to handle their first argument. If the argument is a potentially valid key range, getAll() and getAllKeys() run convert a value to a key range with the argument. Otherwise, IDBGetAllOptions is used for the first argument.
</li>
	<li>
%引数 が［
`Date$jT ／ `Array$jT ／ `ArrayBuffer$I
］であって，
【 `~key範囲へ変換する$() の中で呼出される】`値を~keyに変換する$( %引数 ) の結果が `無効な値^i になる場合には、
例外を投出する。
例えば， %引数 が `NaN^jv `Date$jT である
【すなわち， `valueOf()^js が `NaN^jv を返す `Date^jT である】
場合、
例外を投出する
— 既定の値を伴う `IDBGetAllOptions$I 辞書として解釈されることなく
【！successfully using】。
◎
getAll() and getAllKeys() throw exceptions for Date, Array, and ArrayBuffer first arguments that return "invalid value" when used with convert a value to a key. For example, running getAll() with a NaN Date first argument throws an exception instead of successfully using an IDBGetAllOptions dictionary with default values.
</li>
</ul>
</div>
</div>

		</section>
		<section id="cursor-construct">
<h3 title="Cursor">2.10. ~cursor</h3>

<p>
`~cursor@
は、
ある~dbに`専属する$［
`索引$／`保管庫$
］の中の ある範囲に入る`~record$たちを特定の方向へ反復するために利用される。
◎
A cursor is used to iterate over a range of records in an index or an object store in a specific direction.
</p>

<p>
各`~cursor$ %~cursor は、
次に挙げるものを有する
（括弧内は、
対応する `IDBCursor!I ~interface~member）
— これらは、
`~cursorを作成する$ときに設定される：
◎
↓</p>

<dl class="def-list">
	<dt>
`~source~handle@Cs
（ `source$m ）
◎
A cursor has a source handle,＼
</dt>
	<dd>
%~cursor を~openした［
`保管庫~handle$／`索引~handle$
］。
◎
which is the index handle or the object store handle that opened the cursor.
</dd>

	<dt>
`~tx@Cs
◎
A cursor has a transaction,＼
</dt>
	<dd>
%~cursor の`~source~handle$Csが`専属する$`~tx$。
◎
which is the transaction from the cursor’s source handle.
</dd>
	<dd class="trans-note">【
この訳では、
この用語を利用せず，単にこのように記す。
】</dd>

	<dt>
`範囲@Cs
◎
A cursor has a range＼
</dt>
	<dd>
`~key範囲$。
%~cursor は、［
`~source~handle$Cs↗内の`~record$のうち，`~key$がこの範囲に`入る$もの
］を反復対象にする。
◎
of records in either an index or an object store.
</dd>
	<dd class="trans-note">【
%~cursor の作成-時に指定されなかった場合、
`全範囲$が指定されたものと見なされる。
】</dd>

	<dt>
`~source@Cs
◎
A cursor has a source＼
</dt>
	<dd>
%~cursor の`~source~handle$Csの`~access先$である［
`保管庫$／`索引$
］
— %~cursor は、
その~record~listを反復する。
◎
which is an index or an object store from the cursor’s source handle. The cursor’s source indicates which index or object store is associated with the records over which the cursor is iterating. If the cursor’s source handle is an index handle, then the cursor’s source is the index handle’s associated index. Otherwise, cursor’s source is the object store handle’s associated object store.
</dd>
	<dd class="trans-note">【
この訳では、
この用語を利用せず，もっぱら “`~source~handle$Cs↗” と記す。
】</dd>

	<dt>
`方向@Cs
（ `direction$m ）
◎
A cursor has a direction＼
</dt>
	<dd>
<p>
次の 2 つを指示する：
</p>
		<ul>
			<li>
反復-時に %~cursor の`位置$Csを移動させる方向
— すなわち，`~record$たちを その`~key$の
昇順, 降順
いずれの順序で反復するか。
初期~位置は［
前者／後者
］に応じて，
%~cursor の`~source~handle$Cs↗の［
始端／終端
］側に位置することになる。
</li>
			<li>
~keyが重複する~recordがあるとき，最初のもの以外を飛ばすかどうか。
</li>
		</ul>
◎
that determines whether it moves in monotonically increasing or decreasing order of the record keys when iterated, and if it skips duplicated values when iterating indexes. The direction of a cursor also determines if the cursor initial position is at the start of its source or at its end. A cursor’s direction is one of the following:
</dd>

	<dd>
<p>
%~cursor の`方向$Csは、
次に挙げる値をとり得る：
</p>
		<dl>
			<dt>`next@l</dt>
			<dd>
%~cursor を`~source~handle$Cs↗の始端~側から，`~key$の昇順に反復する。
</dd>
			<dt>`prev@l</dt>
			<dd>
%~cursor を`~source~handle$Cs↗の終端~側から，~keyの降順に反復する。
</dd>
			<dd>
`next$l, `prev$l のいずれも、
反復-時には、
`~key$が`等しい$もの†も含め，`範囲$Csに`入る$すべての~recordを得るべきである††。
</dd>
			<dd class="trans-note">【†
重複する~keyを伴う~record間の反復-順序については、
`保管庫~位置$Csを見よ。
】【††
“べき”
— `位置$Csの記述を見よ。
】</dd>

			<dt>`nextunique@l</dt>
			<dd>
`~key$が互いに`等しい$~recordたちについては，それらのうち最初の~record以外は飛ばすことを除いて、
`next$l と同じ。
</dd>

			<dt>`prevunique@l</dt>
			<dd>
`~key$が互いに`等しい$~recordたちについては，それらのうち
<strong >最初の</strong>
~record以外は飛ばすことを除いて、
`prev$l と同じ。
</dd>
			<dd>
［
`nextunique$l ／ `prevunique$l
］に対しては、
`~source~handle$Cs↗が`保管庫$であるか［
`索引$であって，その`一意か$Ix ~EQ ~T
］である場合の挙動は，［
`next$l ／ `prev$l
］と正確に同じになる。
</dd>
		</dl>

◎
"next"
• This direction causes the cursor to be opened at the start of the source. When iterated, the cursor should yield all records, including duplicates, in monotonically increasing order of keys.
◎
"nextunique"
• This direction causes the cursor to be opened at the start of the source. When iterated, the cursor should not yield records with the same key, but otherwise yield all records, in monotonically increasing order of keys. For every key with duplicate values, only the first record is yielded. When the source is an object store or an index with its unique flag set to true, this direction has exactly the same behavior as "next".
◎
"prev"
• This direction causes the cursor to be opened at the end of the source. When iterated, the cursor should yield all records, including duplicates, in monotonically decreasing order of keys.
◎
"prevunique"
• This direction causes the cursor to be opened at the end of the source. When iterated, the cursor should not yield records with the same key, but otherwise yield all records, in monotonically decreasing order of keys. For every key with duplicate values, only the first record is yielded. When the source is an object store or an index with its unique flag set to true, this direction has exactly the same behavior as "prev".
</dd>

	<dt>
`位置@Cs
◎
A cursor has a position＼
</dt>
	<dd>
`範囲$Csに`入る$どこかを指す†。
%~cursor が反復対象にしている~record~listは、
%~cursor の`範囲$Csが全部的に反復される前に変更されることもある。
これを取扱うため、
%~cursor は自身の`位置$Csを，~indexとしてではなく，前回に返した†~recordの`~key$として保守する。
%~cursor が次の~recordへ反復するよう依頼されたとき、
`方向$Csが~keyの昇順なら、
前回に反復した~recordの~key`より大きい$~keyを有する~recordのうち，最小な`~key$を有するものを返すことになる††。
`方向$Csが~keyの降順なら、
それとは逆に，前回に反復した~recordの~key`より小さい$~keyを有する~recordのうち，最大な`~key$を有するものを返すことになる。
◎
within its range. It is possible for the list of records which the cursor is iterating over to change before the full range of the cursor has been iterated. In order to handle this, cursors maintain their position not as an index, but rather as a key of the previously returned record. For a forward iterating cursor, the next time the cursor is asked to iterate to the next record it returns the record with the lowest key greater than the one previously returned. For a backwards iterating cursor, the situation is opposite and it returns the record with the highest key less than the one previously returned.
</dd>
	<dd class="trans-note">【†
位置は、
初期~時には，反復~順序における仮想の先頭（ ε ）をとるが、
`~cursorを作成する$要請の結果として，この位置のまま~APIに公開されることはない
— `範囲$Csに入る~recordが無い場合、
要請の`結果$は ~NULL になる。
】【
%~cursor がすべてを反復し終えて，次の~recordへの反復が試みられた場合、
ε に設定され，それ以上~反復できなくなる。
】【††
索引における~keyの重複を無視するならば。
次項を見よ。
】</dd>

	<dt>
`保管庫~位置@Cs
◎
For cursors iterating indexes＼
</dt>
	<dd>
`索引$においては、
複数の~recordが同じ~keyを有することもあり，`値$によっても~sortされることから、
`索引$を反復する~cursorについては，少しばかり複雑になる。
この場合、
%~cursor は，
`保管庫~位置^emも有する†
— それは、
前回の反復にて索引~内に見出された`~record$の`値$を指示する。
次の~recordを見出すときには、
`位置$Csに加え，`保管庫~位置$Csも利用される。
◎
the situation is a little bit more complicated since multiple records can have the same key and are therefore also sorted by value. When iterating indexes the cursor also has an object store position, which indicates the value of the previously found record in the index. Both position and the object store position are used when finding the next appropriate record.
</dd>
	<dd class="trans-note">【†
すなわち，`参照先~record$の`~key$
— ゆえに “保管庫~位置” と称されている。
】</dd>

	<dt>
`~key@Cs
（ `key$m ）
◎
↓</dt>
	<dd>
%~cursor が最後に反復した`~record$の`~key$を表現する。
◎
↓</dd>
	<dd class="trans-note">【
これは，実質的に`位置$Csの別名。
】</dd>

	<dt>
`値@Cs
（ `IDBCursorWithValue.value$m ）
◎
↓</dt>
	<dd>
%~cursor が最後に反復した`~record$の`値$†を表現する。
◎
A cursor has a key and a value which represent the key and the value of the last iterated record.
</dd>
	<dd class="trans-note">【†
`~source~handle$Cs↗が`索引$である場合は`参照先~record$の値。
】</dd>

	<dt>
`値は取得-済みか@Cs
◎
A cursor has a got value flag.＼
</dt>
	<dd>
真偽値。
~T は、［［
%~cursor を利用する`要請$
］が`非同期に実行する$`演算$
］が完了し，新たな
( `~key$Cs, `値$Cs )
を得た
（新たな ( `位置$Cs, `保管庫~位置$Cs ) に移動した）
ことを指示する。
◎
↓</dd>
	<dd class="trans-note">【
新たな`~cursor$を取得した時点では、
その前に，`範囲$Csに入る最初の~recordが検索取得されるので、
これも ~T になる。
】</dd>
	<dd>
<p>
したがって， ~F の場合、
次に挙げるいずれかを指示する：
</p>
		<ul>
			<li>
%~cursor を利用する`要請$が`非同期に実行する$`演算$は、
完了していない。
</li>
			<li>
%~cursor は，その`範囲$Csに入るすべての~recordを反復し終えて，次の~recordへの反復が一回でも試みられた。
</li>
		</ul>

<p class="trans-note">【
後者の場合に限り，［
`~key$Cs, `値$Cs
］は ε になるので、
`key$m を調べれば前者と区別できる。
後者の場合、
それ以上 %~cursor を利用できなくなる
— 例えば `範囲$Csに入る新たな~recordが追加されても，
`値は取得-済みか$Csが ~T に戻ることはない
（そうしてから もう一回~反復を試みても，例外が投出されることになる）。
】</p>

◎
When this flag is false, the cursor is either in the process of loading the next value or it has reached the end of its range. When it is true, it indicates that the cursor is currently holding a value and that it is ready to iterate to the next one.
</dd>

	<dt>
`実効~保管庫@Cs
◎
↓</dt>
	<dd>
%~cursor の`~source~handle$Cs↗に応じて
⇒＃
`保管庫$ならば それ／
`索引$ならば それが`専属する$`保管庫$
◎
↓</dd>
	<dt>
`実効~key@Cs
（ `primaryKey$m ）
◎
↓</dt>
	<dd>
%~cursor の`~source~handle$Cs↗に応じて
⇒＃
`保管庫$ならば %~cursor の`位置$Cs ／
`索引$ならば %~cursor の`保管庫~位置$Cs
◎
If the source of a cursor is an object store, the effective object store of the cursor is that object store and the effective key of the cursor is the cursor’s position. If the source of a cursor is an index, the effective object store of the cursor is that index’s referenced object store and the effective key is the cursor’s object store position.
</dd>

	<dt>
`要請@Cs
◎
A cursor has a request,＼
</dt>
	<dd>
%~cursor を~openするときに利用された`要請$。
◎
which is the request used to open the cursor.
</dd>

	<dt>
`~keyのみか@Cs
◎
A cursor also has a key only flag,＼
</dt>
	<dd>
%~cursor の`値$Csも~APIに公開されるかどうかを指示する真偽値。
◎
that indicates whether the cursor’s value is exposed via the API.
</dd>
	<dd class="trans-note">【
~F ならば、
値も~APIに公開する
— すなわち、
%~cursor は `IDBCursorWithValue$I ~interfaceを実装することになる。
】</dd>
</dl>

		</section>
		<section id="key-generator-construct">
<h3 title="Key generators">2.11. ~key生成器</h3>

<p>
`保管庫$の作成-時には、
`~key生成器@
を利用するようにも指定できる。
~key生成器は、
保管庫の中へ挿入される~record用の~keyが指定されていない場合に，それを生成するために利用される。
◎
When a object store is created it can be specified to use a key generator. A key generator is used to generate keys for records inserted into an object store if not otherwise specified.
</p>

<p>
`~key生成器$は
`現在の番号@
を有する。
`現在の番号$は、
`保管庫$の作成-時には 1 に設定され，常に［［
`最大な番号@
~EQ ( 2 の 53 乗（  9007199254740992 ） + 1 )
］以下の整数になる
【実際に利用される~keyは最大な番号~以下になる】
。
`現在の番号$は、
~keyが生成される度に増分される。
また，明示的な~keyを利用して特定の値に更新できる。
◎
A key generator has a current number. The current number is always a positive integer less than or equal to 253 (9007199254740992) + 1. The initial value of a key generator’s current number is 1, set when the associated object store is created. The current number is incremented as keys are generated, and may be updated to a specific value by using explicit keys.
</p>

<p class="note">注記：
どの保管庫も，~~自前の`~key生成器$を利用する。
ある保管庫とのヤリトリが，他の保管庫の`~key生成器$に影響することは、
決してない。
◎
NOTE: Every object store that uses key generators uses a separate generator. That is, interacting with one object store never affects the key generator of any other object store.
</p>

<div >
<p>
`現在の番号$に対する改変は、
~db演算の一部と見なされる：
</p>
<ul>
	<li>
演算が何であれ、
それが失敗して，それによる変更が復帰された場合、
`現在の番号$も元の値に復帰される。
</li>
	<li>
`~tx$が中止された場合、
~txの`視野$に入る各`保管庫$の`~key生成器$の`現在の番号$は，その~txの開始-前の値に復帰される。
</li>
</ul>
◎
Modifying a key generator’s current number is considered part of a database operation. This means that if the operation fails and the operation is reverted, the current number is reverted to the value it had before the operation started. This applies both to modifications that happen due to the current number getting increased by 1 when the key generator is used, and to modifications that happen due to a record being stored with a key value specified in the call to store the record.
◎
Likewise, if a transaction is aborted, the current number of the key generator for each object store in the transaction’s scope is reverted to the value it had before the transaction was started.
</div>

<p>
`現在の番号$は、
~db演算の結果が復帰される場合を除き，決して減少しない。
`保管庫$から`~record$を削除しようが， `IDBObjectStore.clear()$m ~methodを利用して全~recordを~clearしようが、
保管庫の`~key生成器$には決して影響しない。
◎
The current number for a key generator never decreases, other than as a result of database operations being reverted. Deleting a record from an object store never affects the object store’s key generator. Even clearing all records from an object store, for example using the clear() method, does not affect the current number of the object store’s key generator.
</p>

<p>
`~record$を格納する~callにて明示的に`~key$が指定されていない場合、
~keyは生成される。
◎
When a record is stored and a key is not specified in the call to store the record, a key is generated.
</p>

<div class="algo">
<p>
`保管庫~用の~keyを生成する@
~algoは、
所与の
( `保管庫$ %保管庫 )
に対し：
◎
To generate a key for an object store store, run these steps:
</p>

<ol>
	<li>
%生成器 ~LET %保管庫 の`~key生成器$
◎
Let generator be store’s key generator.
</li>
	<li>
%~key ~LET %生成器 の`現在の番号$
◎
Let key be generator’s current number.
</li>
	<li>
~IF［
%~key ~GT `最大な番号$
］
⇒
~RET `失敗^i
◎
If key is greater than 253 (9007199254740992), then return failure.
</li>
	<li>
%生成器 の`現在の番号$ ~INCBY 1
◎
Increase generator’s current number by 1.
</li>
	<li>
~RET %~key
◎
Return key.
</li>
</ol>
</div>

<p>
`~record$を格納する~callにて`~key$が明示的に指定された場合、
`~key生成器$は更新され得る。
◎
When a record is stored and a key is specified in the call to store the record, the associated key generator may be updated.
</p>

<div class="algo">
<p>
`保管庫~用の~key生成器を可能なら更新する@
~algoは、
所与の
( `保管庫$ %保管庫, `~key$ %~key )
に対し：
◎
To possibly update the key generator for an object store store with key, run these steps:
</p>

<ol>
	<li>
~IF［
%~key の`型$key ~NEQ `number$i
］
⇒
~RET
◎
If the type of key is not number, abort these steps.
</li>
	<li>
%値 ~LET 次を満たす最大な整数
⇒
［
%値 ~LTE %~key の`値$key
］~AND［
%値 ~LTE `最大な番号$
］
◎
Let value be the value of key.
◎
Set value to the minimum of value and 253 (9007199254740992).
◎
Set value to the largest integer not greater than value.
</li>
	<li>
%生成器 ~LET %保管庫 の`~key生成器$
◎
Let generator be store’s key generator.
</li>
	<li>
~IF［
%値 ~GTE %生成器 の`現在の番号$
］
⇒
%生成器 の`現在の番号$ ~SET %値 + 1
◎
If value is greater than or equal to generator’s current number, then set generator’s current number to value + 1.
</li>
</ol>
</div>

<div class="note">
<div class="p">
<p>注記：
~keyは、
次のいずれかにより指定できる：
</p>
<ul>
	<li>
`保管庫$の`~key~path$Os ~NEQ ε の場合
⇒
［
保管庫に格納する`~record$の`値$
］の［
~key~pathが指す部位にある~prop
］に~keyを設定する。
</li>
	<li>
他の場合
⇒
~recordを格納する~callの引数として，~keyを渡す。
</li>
</ul>
◎
NOTE: A key can be specified both for object stores which use in-line keys, by setting the property on the stored value which the object store’s key path points to, and for object stores which use out-of-line keys, by passing a key argument to the call to store the record.
</div>

<p>
指定された~keyが`現在の番号$に影響するのは、
`number$i `型$keyの場合に限られ，
他の`型$keyの~keyは影響しない
（ `string$i 値を `number$i 値に構文解析するなどの暗黙的な変換は行われない）。
1 より小さい `number$i ~keyも，`現在の番号$より常に低いので影響しない。
◎
Only specified keys of type number can affect the current number of the key generator. Keys of type date, array (regardless of the other keys they contain), binary, or string (regardless of whether they could be parsed as numbers) have no effect on the current number of the key generator. Keys of type number with value less than 1 do not affect the current number since they are always lower than the current number.
</p>
</div>

<p>
`現在の番号$が`最大な番号$を超えた下では、
後続な［
`~key生成器$を利用して新たな`~key$を生成しようとする試み
］に対しては，
`ConstraintError$E 例外が投出される。
それでも、
明示的な~keyを指定すれば，`~record$を保管庫に挿入できるが、
`~key生成器$を再び利用するためには，保管庫を削除して新たに作成し直す他にない。
◎
When the current number of a key generator reaches above the value 253 (9007199254740992) any subsequent attempts to use the key generator to generate a new key will result in a "ConstraintError" DOMException. It is still possible to insert records into the object store by specifying an explicit key, however the only way to use a key generator again for such records is to delete the object store and create a new one.
</p>

<div class="note">

<p>注記：
この上限は、
`最大な番号$を超える整数は~JS `Number$jT では一意に表現できないことによる。
例えば~JSにおいては、［
`9007199254740992 + 1 === 9007199254740992^c
］になる。
◎
NOTE: This limit arises because integers greater than 9007199254740992 cannot be uniquely represented as ECMAScript Numbers. As an example, 9007199254740992 + 1 === 9007199254740992 in ECMAScript.
</p>

<p>
`~key生成器$を普通に利用している限り、
この上限が問題になることはない。
新たな~keyを毎秒 1000 回~生成し続けても，この上限に至るのは 285000 年後である。
◎
As long as key generators are used in a normal fashion this limit will not be a problem. If you generate a new key 1000 times per second day and night, you won’t run into this limit for over 285000 years.
</p>
</div>

<div class="p">
<p>
~~要約すると、
保管庫が`~key生成器$を有する場合：
</p>
<ul>
	<li>
最初に生成される~keyは
（他の `number$i ~keyが明示的に挿入されない限り）
常に 1 になる。
</li>
	<li>
生成される~keyは、
常に，保管庫~内の最大な `number$i ~keyより大きい，正な整数になる。
</li>
	<li>
同じ保管庫に対し，同じ~keyが重ねて生成されることは、
~txが巻戻されない限り，決してない。
</li>
</ul>

◎
A practical result of this is that the first key generated for an object store is always 1 (unless a higher numeric key is inserted first) and the key generated for an object store is always a positive integer higher than the highest numeric key in the store. The same key is never generated twice for the same object store unless a transaction is rolled back.
</div>

<div class="example" id="example-key-generator">

<p>
各~保管庫は、
自前の`~key生成器$を取得する：
◎
Each object store gets its own key generator:
</p>

<pre class="lang-js">
%store1 = db.createObjectStore(`store1^l, { autoIncrement: true });
%store1.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store2 = db.createObjectStore(`store2^l, { autoIncrement: true });
%store2.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store1.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span>
%store2.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span></pre>

<p>
挿入が，拘束~違反や IO ~errorに因り失敗した場合、
`~key生成器$は更新されない。
◎
If an insertion fails due to constraint violations or IO error, the key generator is not updated.
</p>

<pre class="lang-js">
%transaction.onerror = function(%e) { %e.preventDefault() };
%store = %db.createObjectStore(`store1^l, { autoIncrement: true });
%index = %store.createIndex(`index1^l, `ix^l, { unique: true });
%store.put({ ix: `a^l}); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store.put({ ix: `a^l}); // <span class="comment"
	title="Will fail">失敗することになる</span>
%store.put({ ix: `b^l}); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span></pre>

<p>
保管庫から~itemを除去しようが，`~key生成器$には影響しない
— `clear()^m が~callされたときも含め。
◎
Removing items from an objectStore never affects the key generator. Including when clear() is called.
</p>

<pre class="lang-js">
%store = %db.createObjectStore(`store1^l, { autoIncrement: true });
%store.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store.delete(`1^lt);
%store.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span>
%store.clear();
%store.put(`c^l); // <span class="comment"
	title="Will get key 3">~key `3^jv があてがわれる</span>
%store.delete(IDBKeyRange.lowerBound(`0^lt));
%store.put(`d^l); // <span class="comment"
	title="Will get key 4">~key `4^jv があてがわれる</span></pre>

<p>
明示的な~keyを伴わせて~itemを挿入した場合、［
その~keyは `number$i である，かつ 最後に生成された~keyより大きい
］とき，そのときに限り，`~key生成器$に影響する。
◎
Inserting an item with an explicit key affects the key generator if, and only if, the key is numeric and higher than the last generated key.
</p>

<pre class="lang-js">
%store = %db.createObjectStore(`store1^l, { autoIncrement: true });
%store.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store.put(`b^l, `3^lt); // <span class="comment"
	title="Will use key 3">~key `3^jv を利用する</span>
%store.put(`c^l); // <span class="comment"
	title="Will get key 4">~key `4^jv があてがわれる</span>
%store.put(`d^l, -`10^lt); // <span class="comment"
	title="Will use key -10">~key `-10^jv を利用する</span>
%store.put(`e^l); // <span class="comment"
	title="Will get key 5">~key `5^jv があてがわれる</span>
%store.put(`f^l, `6.00001^lt); // <span class="comment"
	title="Will use key 6.0001">~key `6.0001^jv を利用する</span>
%store.put(`g^l); // <span class="comment"
	title="Will get key 7">~key `7^jv があてがわれる</span>
%store.put(`f^l, `8.9999^lt); // <span class="comment"
	title="Will use key 8.9999">~key `8.9999^jv を利用する</span>
%store.put(`g^l); // <span class="comment"
	title="Will get key 9">~key `9^jv があてがわれる</span>
%store.put(`h^l, `foo^l); // <span class="comment"
	title="Will use key &quot;foo&quot;">~key `foo^l を利用する</span>
%store.put(`i^l); // <span class="comment"
	title="Will get key 10">~key `10^jv があてがわれる</span>
%store.put(`j^l, [`1000^lt]); // <span class="comment"
	title="Will use key [1000]">~key `[1000]^jv を利用する</span>
%store.put(`k^l); // <span class="comment"
	title="Will get key 11">~key `11^jv があてがわれる</span>
/* <span class="comment">
これらはどれも、
保管庫が~key~pathを利用している下で，~objの中に明示的に~keyを埋め込んで渡したときと，同じに挙動することになる。
◎
All of these would behave the same if the objectStore used a keyPath and the explicit key was passed inline in the object
</span> */
</pre>

<p>
~txが中止された場合、
その間に起きた`~key生成器$に対する増加-は巻戻される。
これにより、
すべての巻戻しは一貫するようになる
— ~crashに因る巻戻しは、
増加された~key生成器の`現在の番号$を`~commit$する機会cを得ることは決してないので。
◎
Aborting a transaction rolls back any increases to the key generator which happened during the transaction. This is to make all rollbacks consistent since rollbacks that happen due to crash never has a chance to commit the increased key generator value.
</p>

<pre class="lang-js">
%db.createObjectStore(`store^l, { autoIncrement: true });
%trans1 = %db.transaction([`store^l], `readwrite$l);
%store_t1 = %trans1.objectStore(`store^l);
%store_t1.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store_t1.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span>
%trans1.abort();
%trans2 = %db.transaction([`store^l], `readwrite$l);
%store_t2 = trans2.objectStore(`store^l);
%store_t2.put(`c^l); // <span class="comment"
	title="Will get key 1">~key `1^jv があてがわれる</span>
%store_t2.put(`d^l); // <span class="comment"
	title="Will get key 2">~key `2^jv があてがわれる</span>
</pre>
</div>

<div class="example" id="example-inline-keygen">
<p>
ある~objを保管庫に保存するときに
（例えば `IDBObjectStore.put()$m を用いて），［
`~key~path$Osを利用するとき,
`~key生成器$を利用するとき
］における挙動の相違を以下の例にて~~説明する。
◎
The following examples illustrate the different behaviors when trying to use in-line keys and key generators to save an object to an object store.
</p>

<div>
<p>
以下では：
</p>

<ul>
	<li>
保管庫に保存する ~objを %O と記す。
</li>
	<li>
%O を保管庫に保存した結果の`~record$を %R と記す。
%O は
（ `StructuredSerializeForStorage$jA された上で）
%R の`値$として保存される。
</li>
	<li>
保管庫は`~key生成器$を有するとする。
この生成器が次回に供する値を、
%生成key と記す。
</li>
</ul>

<p>
保管庫の`~key~path$Os ~EQ ε ならば、
%R の`~key$には %生成key があてがわれることになる。
以降、
保管庫の`~key~path$ %keyPath ~NEQ ε とする。
</p>

<p>
次の様に %O が %keyPath が指す部位に~propを有さないならば：
</p>

<pre class="lang-js">
%keyPath = `foo.bar^l
%O = { foo: {} }
</pre>

<p>
%O が保管庫に保存されるときには， %生成key がその~prop
（ここでは %O`.foo.bar^c ）
の値にあてがわれる：
</p>

<pre class="lang-js">
%R の`値$ = { foo: { <mark>bar: %生成key</mark> } }
</pre>

<p>
逆に、
%O が %keyPath が指す部位に~propを有する場合：
</p>

<pre class="lang-js">
%O = { foo: { bar: <mark>10</mark> } }
</pre>

<p>
%生成key は利用されず、
%R の~keyには %keyPath が指す部位の値が
（この例では <mark>10</mark> ），利用される。
</p>

<p>
~systemは、
~prop階層を満たすに必要な分の~propを作成する責を負う。
例えば：
</p>

<pre class="lang-js">
%keyPath = `foo.bar.baz^l
%O = {}
</pre>

<p>
であれば、
%O が`保管庫$に保存されるときには，［
`foo^c, `bar^c, `baz^c
］~propが順に入れ~~子にされた上で，
%keyPath が指す部位に %生成key があてがわれる：
</p>

<pre class="lang-js">
%R の`値$ = { foo: { bar: { baz: %生成key } } }
</pre>

<p>
~primitive値~上に~propを格納するよう試みられた場合、
失敗して~errorが投出されることになる。
例えば：
</p>

<pre class="lang-js">
%keyPath = `foo^l
%O = 4
</pre>

<p>
であれば、
%O は~primitive値なので~propを定義できず，失敗する。
</p>

<p class="trans-note">【
原文の記述構成は（少なくとも，そのまま訳すと）解りにくいので、
この例の訳は等価な記述に全面的に構成し直している。
】</p>

<div lang="en" class="_en">

<p>If the following conditions are true:</p>
<ul>
<li>The object store has a key generator.</li>
<li>There is no in-line value for the key path property.</li>
</ul>
<p>
Then the value provided by the key generator is used to populate the key value.
In the example below the key path for the object store is "foo.bar".
The actual object has no value for the bar property, { foo: {} }.
When the object is saved in the object store the bar property is assigned a value of 1
because that is the next key generated by the key generator.
</p>
<pre class="lang-js">
const store = db.createObjectStore("store", { keyPath: "foo.bar", autoIncrement: true });
store.put({ foo: {} }).onsuccess = function(e) {
  const key = e.target.result;
  console.assert(key === 1);
};
</pre>
<p>If the following conditions are true:</p>
<ul>
<li>The object store has a key generator.</li>
<li>There is a value for the key path property.</li>
</ul>
<p>
Then the value associated with the key path property is used.
The auto-generated key is not used.
In the example below the key path for the object store is "foo.bar".
The actual object has a value of 10 for the bar property, { foo: { bar: 10} }.
When the object is saved in the object store the bar property keeps its value of 10, because that is the key value.
</p>

<pre class="lang-js">
const store = db.createObjectStore("store", { keyPath: "foo.bar", autoIncrement: true });
store.put({ foo: { bar: 10 } }).onsuccess = function(e) {
  const key = e.target.result;
  console.assert(key === 10);
};
</pre>
<p>
The following example illustrates the scenario when the specified in-line key is defined through a key path but there is no property matching it.
The value provided by the key generator is then used to populate the key value and the system is responsible
for creating as many properties as it requires to suffice the property dependencies on the hierarchy chain.
In the example below the key path for the object store is "foo.bar.baz".
The actual object has no value for the foo property, { zip: {} }.
When the object is saved in the object store the foo, bar, and baz properties
are created each as a child of the other until a value for foo.bar.baz can be assigned.
The value for foo.bar.baz is the next key generated by the object store.
</p>
<pre class="lang-js">
const store = db.createObjectStore("store", { keyPath: "foo.bar.baz", autoIncrement: true });
store.put({ zip: {} }).onsuccess = function(e) {
  const key = e.target.result;
  console.assert(key === 1);
  store.get(key).onsuccess = function(e) {
    const value = e.target.result;
    // value will be: { zip: {}, foo: { bar: { baz: 1 } } }
    console.assert(value.foo.bar.baz === 1);
  };
};
</pre>
<p>
Attempting to store a property on a primitive value will fail and throw an error. In the first example below the key path for the object store is "foo". The actual object is a primitive with the value, 4. Trying to define a property on that primitive value fails.
</p>
<pre class="lang-js">
const store = db.createObjectStore("store", { keyPath: "foo", autoIncrement: true });

// The key generation will attempt to create and store the key path
// property on this primitive.
store.put(4); // will throw DataError
</pre>
</div>
</div>
</div>

		</section>
		<section id="record-snapshot-construct">
<h3 title="Record snapshot">2.12. ~record~snapshot</h3>

<p>
`~record~snapshot@
は、［
`保管庫$／`索引$
］内の`~record$から複製された［
~key, 値
］を包含する
— それは、
次に挙げるものからなる：
◎
A record snapshot contains keys and values copied from an object store record or an index record.
</p>
<div>
<ul>
	<li>
`~key@rS
⇒
ある`~key$
◎
A record snapshot has a key which is a key.
</li>
	<li>
<p>
`値@rS
⇒
ある`値$
◎
A record snapshot has a value which is a value.
</p>

<p class="note">注記：
これは、［
`索引$内の`~record$用には，その`参照先~record$の`値$の複製／
`保管庫$内の`~record$用には，その`値$
］になる。
◎
NOTE: For an index record, the snapshot’s value is a copy of the record’s referenced value. For an object store record, the snapshot’s value is the record’s value.
</p>
	</li>
	<li>
<p>
`首key@rS
⇒
ある`~key$
◎
A record snapshot also has a primary key which is a key.
</p>

<p class="note">注記：
これは、［
`索引$内の`~record$用には，その`参照先~record$の`~key$／
`保管庫$内の`~record$用には，その`~key$
（当の~snapshotの`~key$rSと同じ）
］になる。
◎
NOTE: For an index record, the snapshot’s primary key is the record’s value, which is the key of the record in the index’s referenced object store. For an object store record, the snapshot’s primary key and key are the same key, which is the record’s key.
</p>
	</li>
</ul>
</div>

		</section>
	</section>
	<section id="exceptions">
<h3 title="Exceptions">3. 例外</h3>

<p>
この文書が利用する各種 例外は、
`WEBIDL$r にて定義されるとおり
【参照：`DOMException^I 用の`名前~表t＠~WEBIDL#dfn-error-names-table$ 他】，
`DOMException$I か `DOMException^I から派生した~interfaceである。
◎
Each of the exceptions used in this document is a DOMException or DOMException-derived interface, as defined in [WEBIDL].
</p>

<p>
以下の表tに、
この文書が利用する 例外~名, および その用法を述べる：
◎
The table below lists the DOMException names used in this document along with a description of the exception’s usage.
</p>

<table class="_row"><thead>
<tr><th>例外~名
<th>意味
<tbody>

<tr><td>`AbortError@E
<td>
`要請$は中止された。
◎
A request was aborted.

<tr><td>`ConstraintError@E
<td>
~txにおける変異~演算は、
拘束が満たされないため，失敗した。
◎
A mutation operation in the transaction failed because a constraint was not satisfied.

<tr><td>`DataCloneError@E
<td>
格納するよう試みた~dataは、
内部~有構造~clone~algoにより~cloneできなかった。
◎
The data being stored could not be cloned by the internal structured cloning algorithm.

<tr><td>`DataError@E
<td>
演算に供された~dataは、
要件を満たしていない。
◎
Data provided to an operation does not meet requirements.

<tr><td>`InvalidAccessError@E
<td>
~objに対し妥当でない演算が遂行された。
◎
An invalid operation was performed on an object.

<tr><td>`InvalidStateError@E
<td>
~objに対する所与の演算は、
許容されない, あるいは許容されない時機に~callされた。
または、
すでに［
削除された／除去された
］~source~objに対し要請が為された。
◎
An operation was called on an object on which it is not allowed or at a time when it is not allowed, or if a request is made on a source object that has been deleted or removed.

<tr><td>`NotFoundError@E
<td>
要請された~db~objを見出せなかったため、
演算は失敗した。
◎
The operation failed because the requested database object could not be found.

<tr><td>`NotReadableError@E
<td>
要請された~dataを包含している下層~storageを読取れなかったため、
演算は失敗した。
◎
The operation failed because the underlying storage containing the requested data could not be read. 

<tr><td>`SyntaxError@E
<td>
渡された %keyPath 引数は，`妥当な~key~path$でない。
◎
The keyPath argument contains an invalid key path.

<tr><td>`ReadOnlyError@E
<td>
`~readonly~tx$において，変異~演算が試みられた。
◎
The mutating operation was attempted in a read-only transaction.

<tr><td>`TransactionInactiveError@E
<td>
［
現在は`作動中$i でない／すでに`完遂-$した
］~txに対し，要請が設置された。
◎
A request was placed against a transaction which is currently not active, or which is finished.

<tr><td>`UnknownError@E
<td>
演算は、［
~db自身に無関係な一過な事由／
他の~errorに該当しない事由
］で失敗した。
◎
The operation failed for transient reasons unrelated to the database itself or not covered by any other error.

<tr><td>`VersionError@E
<td>
既存の~versionより低い~versionで~dbを~openするよう試みられた。
◎
An attempt was made to open a database using a lower version than the existing version.
</table>

<p>
上に挙げた `DOMException^I 例外~名とは別に，
`QuotaExceededError$I 例外~型も次の場合に利用される
⇒
残りの~storage~~容量が十分でないため、
あるいは，~storage~quotaに達したが，利用者が~dbへの容量追加を辞退しため、
演算は失敗した。
◎
Apart from the above DOMException names, the QuotaExceededError exception type is to be used if the operation failed because there was not enough remaining storage space, or the storage quota was reached and the user declined to give more space to the database.
</p>

<p class="note">注記：
複数の Indexed DB 演算が，同じ型の~errorを投出したり、
単独の演算であっても，複数の事由に対し同じ型の~errorを投出し得るので、
実装には、
より~~詳細な~messageを供して，~errorを~debugし易くすることが奨励される。
◎
NOTE: Given that multiple Indexed DB operations can throw the same type of error, and that even a single operation can throw the same type of error for multiple reasons, implementations are encouraged to provide more specific messages to enable developers to identify the cause of errors.
</p>

	</section>
	<section id="async-api">
<h2 title="API">4. ~API</h2>

<p>
各種~API~methodは、
それを~callした~threadを阻むことなく返す。
すべての非同期的な演算は、
即時に `IDBRequest$I ~instanceを返す。
この~objは、
初期~時には，演算の結果について，いかなる情報も包含しない。
情報が可用になったなら、
要請に向けて~eventが発火され，情報は当の `IDBRequest$I の属性たちを通して可用になる。
◎
The API methods return without blocking the calling thread. All asynchronous operations immediately return an IDBRequest instance. This object does not initially contain any information about the result of the operation. Once information becomes available, an event is fired on the request and the information becomes available through the properties of the IDBRequest instance.
</p>

<p>
`~db~access~task~source@
が、
これらの~taskの`~task~source$である。
◎
The task source for these tasks is the database access task source.
</p>

<div class="algo">
`~db~taskを~queueする@
~algoは、
所与の
( 何かを遂行する一連の段 %手続き )
に対し
⇒
`~taskを~queueする$( `~db~access~task~source$, %手続き )
◎
To queue a database task, perform queue a task on the database access task source.
</div>

		<section id="request-api">
<h3 title="The IDBRequest interface">4.1. `IDBRequest^I ~interface</h3>

<p>
`IDBRequest$I ~interfaceが、
`~db$や, それに専属する各種~objに対する非同期的な`要請$の結果に~accessする手段を，`~event~handler~IDL属性$ `HTML$r を利用して供する。
◎
The IDBRequest interface provides the means to access results of asynchronous requests to databases and database objects using event handler IDL attributes [HTML].
</p>

<p>
~dbに対し`演算$を要請するような どの~methodも，［
~eventを通して，要請している~appに`結果$を~~返信する
］ような， `IDBRequest$I ~objを返す。
すなわち，`演算$は非同期に実行される。
この設計は、
どの`~db$に対しても，いくつもの要請が同時に作動中になり得ることを意味する。
◎
Every method for making asynchronous requests returns an IDBRequest object that communicates back to the requesting application through events. This design means that any number of requests can be active on any database at a time.
</p>

<div class="example" id="example-async-requests">

<p>
次の例では、
`~db$を非同期に~openする。
種々の状況に応答するために、
種々の~event~handlerが登録される。
◎
In the following example, we open a database asynchronously. Various event handlers are registered for responding to various situations.
</p>

<pre class="lang-js">
const %request = `indexedDB$m.open('AddressBook', `15^lt);
%request.onsuccess = function(%evt) {...};
%request.onerror = function(%evt) {...};
</pre>
</div>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBRequest@I : `EventTarget$I {
  readonly attribute `any$ `result$m;
  readonly attribute `DOMException$I? `error$m;
  readonly attribute (`IDBObjectStore$I or `IDBIndex$I or `IDBCursor$I)? `source$m;
  readonly attribute `IDBTransaction$I? `transaction$m;
  readonly attribute `IDBRequestReadyState$I `readyState$m;

  // <span class="comment" title="Event handlers">~event~handler：</span>
  attribute `EventHandler$I `onsuccess$m;
  attribute `EventHandler$I `onerror$m;
};

enum `IDBRequestReadyState@I {
  `pending$l,
  `done$l
};
</pre>

<!-- `IDBRequest!I -->
<dl class="domintro">
	<dt>%request . `result$m</dt>
	<dd>
%request が完了している場合、
それが［
成功したならば その`結果$ ／
失敗したならば `undefined^jv
］を返す。
完了していない場合、
`InvalidStateError$E を投出する。
◎
When a request is completed, returns the result, or undefined if the request failed. Throws a "InvalidStateError" DOMException if the request is still pending.
</dd>

	<dt>%request . `error$m</dt>
	<dd>
%request が完了している場合、
それが［
成功したならば ~NULL ／
失敗したならば `~error$（ある `DOMException$I ）
］を返す。
完了していない場合、
`InvalidStateError$E を投出する。
◎
When a request is completed, returns the error (a DOMException), or null if the request succeeded. Throws a "InvalidStateError" DOMException if the request is still pending.
</dd>

	<dt>%request . `source$m</dt>
	<dd>
%request は`~open要請$である場合、
~NULL を返す。
他の場合、
%request の`~source$
（ `IDBObjectStore$I ／ `IDBIndex$I ／ `IDBCursor$I ）
を返す。
◎
Returns the IDBObjectStore, IDBIndex, or IDBCursor the request was made against, or null if it was an open request.
</dd>

	<dt>%request . `transaction$m</dt>
	<dd>
%request の`設置-先~tx$
（ `IDBTransaction$I ）
を返す。
ただし， %request は`~open要請$である場合、
%request により~openされた`~db$の`昇格~tx$dbが［
ε でない, かつ`生きて$いるならば それ ／
~ELSE_ ~NULL
］を返す。
◎
Returns the IDBTransaction the request was made within. If this as an open request, then it returns an upgrade transaction while it is live, or null otherwise.
</dd>

	<dt>%request . `readyState$m</dt>
	<dd>
%request が完了して［
いなければ `pending$l ／
いれば `done$l
］を返す。
◎
Returns "pending" until a request is complete, then returns "done".
</dd>
</dl>

<div class="algo">
<p>
`result@m
取得子~手続きは：
◎
The result getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`済んだか$ ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this’s done flag is false, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~RET ［
コレの`結果$ ~NEQ ε ならば それ ／
~ELSE_（すなわち，コレの`~error$ ~NEQ ε ） `undefined^jv
］
◎
Return this’s result, or undefined if the request resulted in an error.
</li>
</ol>

<p class="trans-note">【
結果 ~NEQ ε の場合でも，結果~自身は `undefined^jv にもなり得る
（ `IDBObjectStore.get()$m の注記を見よ）。
】</p>
</div>

<div class="algo">
<p>
`error@m
取得子~手続きは：
◎
The error getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`済んだか$ ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this’s done flag is false, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~RET［
コレの`~error$ ~NEQ ε ならば それ ／
~ELSE_（すなわちコレの`結果$ ~NEQ ε ならば） ~NULL
］
◎
Return this’s error, or null if no error occurred.
</li>
</ol>
</div>

<div class="algo">
`source@m
取得子~手続きは
⇒
~RET ［
コレの`~source$ ~NEQ ε ならば それ ／
~ELSE_ ~NULL
］
◎
The source getter steps are to return this’s source, or null if no source is set.
</div>

<div class="algo">
<p>
`transaction@m
取得子~手続きは
⇒
~RET ［
コレの`設置-先~tx$ ~NEQ ε ならば それ ／
~ELSE_ ~NULL
］
◎
The transaction getter steps are to return this’s transaction.
</p>

<p class="note">注記：
この取得子は、
ある種の要請
— `IDBFactory.open()$m から返される`要請$など —
においては ~NULL を返すこともある。
◎
NOTE: The transaction getter can return null for certain requests, such as for requests returned from open().
</p>
</div>

<div class="algo">
`readyState@m
取得子~手続きは
⇒
~RET コレの`済んだか$に応じて［
~F ならば
`pending@l
／
~T ならば
`done@l
］
◎
The readyState getter steps are to return "pending" if this’s done flag is false, and "done" otherwise.
</div>

<p>
`onsuccess@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `success$et である。
◎
The onsuccess attribute is an event handler IDL attribute whose event handler event type is success.
</p>

<p>
`onerror@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `error$et である。
◎
The onerror attribute is an event handler IDL attribute whose event handler event type is error event.
</p>

<p>
`IDBDatabase$I 上の `~open要請$を返す各種~methodは、［
`blocked$et, `upgradeneeded$et
］~eventを~listenすることを許容するために拡張された~interfaceを利用する。
◎
Methods on IDBDatabase that return a open request use an extended interface to allow listening to the blocked and upgradeneeded events.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBOpenDBRequest@I : `IDBRequest$I {
  // <span class="comment" title="Event handlers">~event~handler：</span>
  attribute `EventHandler$I `onblocked$m;
  attribute `EventHandler$I `onupgradeneeded$m;
};
</pre>

<p>
`onblocked@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `blocked$et である。
◎
The onblocked attribute is an event handler IDL attribute whose event handler event type is blocked.
</p>

<p>
`onupgradeneeded@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `upgradeneeded$et である。
◎
The onupgradeneeded attribute is an event handler IDL attribute whose event handler event type is upgradeneeded.
</p>

		</section>
		<section id="events">
<h3 title="Event interfaces">4.2. ~event~interface</h3>

<p>
この仕様は、
次の~custom~interfaceによる~eventを発火する：
◎
This specification fires events with the following custom interfaces:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBVersionChangeEvent@I : `Event$I {
  `constructor@(`DOMString$ %type, optional `IDBVersionChangeEventInit$I %eventInitDict = {});
  readonly attribute `unsigned long long$ `oldVersion$m;
  readonly attribute `unsigned long long$? `newVersion$m;
};

dictionary `IDBVersionChangeEventInit@I : `EventInit$I {
  `unsigned long long$ `oldVersion@m = 0;
  `unsigned long long$? `newVersion@m = null;
};
</pre>

<!-- `IDBVersionChangeEvent!I -->

<div class="algo">
`oldVersion@m
取得子~手続きは、
初期化-時の値を返す。
それは、
当の~dbの以前の`~version$dbを表現する。
◎
The oldVersion getter steps are to return the value it was initialized to. It represents the previous version of the database.
</div>

<div class="algo">
`newVersion@m
取得子~手続きは、
初期化-時の値を返す。
それは、
当の~dbの新たな`~version$dbを表現するが，~dbが削除されつつあるときは ~NULL になる。
`~dbを昇格する$手続きを見よ。
◎
The newVersion getter steps are to return the value it was initialized to. It represents the new version of the database, or null if the database is being deleted. See the steps to upgrade a database.
</div>

<p>
~eventは、
`DOM^cite `§ ~eventの構築-法＠~DOM4#constructing-events$
に定義されるとおり構築される。
◎
Events are constructed as defined in DOM § 2.5 Constructing events.
</p>

<div class="algo">
<p>
`~version変更~eventを発火する@
~algoは、
所与の
( %~target, %~event名, %旧~version, %新~version )
に対し：
◎
To fire a version change event named e at target given oldVersion and newVersion, run these steps:
</p>

<ol>
	<li>
%~event ~LET `~eventを作成する$( `IDBVersionChangeEvent$I )
◎
Let event be the result of creating an event using IDBVersionChangeEvent.
</li>
	<li>
%~event の各種~属性を次のように初期化する
⇒＃
`type$m ~SET %~event名,
`bubbles$m ~SET ~F,
`cancelable$m ~SET ~F,
`oldVersion$m ~SET %旧~version,
`newVersion$m ~SET %新~version
◎
• Set event’s type attribute to e.
• Set event’s bubbles and cancelable attributes to false.
• Set event’s oldVersion attribute to oldVersion.
• Set event’s newVersion attribute to newVersion.
</li>
	<li>
~RET `Dispatch$( %~target, %~event )
◎
Let legacyOutputDidListenersThrowFlag be false.
◎
Dispatch event at target with legacyOutputDidListenersThrowFlag.
◎
Return legacyOutputDidListenersThrowFlag.
</li>
</ol>

<p class="note">注記：
この~algoの結果は利用されないこともある。
◎
NOTE: The return value of this algorithm is not always used.
</p>
</div>

		</section>
		<section id="_event-types">
<h3>【 各種~event型の一覧 】</h3>

<p>
便宜のため、
この訳では，この仕様が利用する各種~event型を以下に要約する。
</p>

<p>
これらの~eventは、［
`要請$／`~tx$／`接続$
］ %~target に向けて発火される。
~eventは、
`親~targetを取得する$~algoを通して，複数の~objに伝播する場合もある。
親~targetは %~target に応じて次になる
⇒＃
`~open要請$ならば ~NULL ／
他の`要請$ならば %~target の`設置-先~tx$ ／
`~tx$ならば %~target が`専属する$`接続$ ／
`接続$ならば ~NULL
</p>

<table><thead>
<tr><th>~event
<th>発火-時機と~target
<tbody>

<tr><td>`versionchange$et
<td>
`~db$を昇格-（または削除-）しようとしたとき、
同じ~dbを~openしている他の各`接続$に向けて発火される。

<tr><td>`close$et
<td>
`接続$が例外的な状況下で~closeされたとき、
当の接続に向けて発火される。

<tr><td>`upgradeneeded$et
<td>
`~db$を~openした際に`昇格~tx$が生じたとき、
当の`~open要請$に向けて発火される。

<tr><td>`blocked$et
<td>
［
他の`接続$がまだ `~close済み$i でない
］ために［
`~db接続を~openする$ ／ `~dbを削除する$
］`要請$が阻まれたとき、
当の`~open要請$に向けて発火される。

<tr><td>`success$et
<td>
`要請$が成功したとき、
当の要請に向けて発火される。

<tr><td>`error$et
<td>
何らかの~errorにより`要請$が失敗したとき、
当の要請に向けて発火される。

<tr><td>`complete$et
<td>
`~tx$が`~commit$されたとき、
当の~txに向けて発火される。

<tr><td>`abort$et
<td>
`~tx$が~errorまたは `abort()^m により`中止-$されたとき、
当の~txに向けて発火される。
</table>

		</section>
		<section id="factory-interface">
<h3 title="The IDBFactory interface">4.3. `IDBFactory^I ~interface</h3>

<p>
`~db$~objは、
`IDBFactory$I ~interface上の各種~methodを通して~accessされる。
この~interfaceを実装する単独の~objは、
Indexed DB 演算を~supportする環境の大域~scopeに在る。
◎
Database objects are accessed through methods on the IDBFactory interface. A single object implementing this interface is present in the global scope of environments that support Indexed DB operations.
</p>

<pre class="idl" id="global-scope">
partial interface mixin `WindowOrWorkerGlobalScope!I {
  [`SameObject$] readonly attribute `IDBFactory$I `indexedDB$m;
};
</pre>

<p>
`indexedDB@m
属性は、
索引付き~dbの能力に~accessするための仕組みを，~appに供する。
◎
The indexedDB attribute provides applications a mechanism for accessing capabilities of indexed databases.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBFactory@I {
  [`NewObject$] `IDBOpenDBRequest$I `open$m(
      `DOMString$ %name,
      optional [`EnforceRange$] `unsigned long long$ %version
  );
  [`NewObject$] `IDBOpenDBRequest$I `deleteDatabase$m(
      `DOMString$ %name
  );
  `Promise$&lt;`sequence$&lt;`IDBDatabaseInfo$I&gt;&gt; `databases$m();

  short `cmp$m(
      `any$ %first,
      `any$ %second
  );
};

dictionary `IDBDatabaseInfo@I {
  `DOMString$ `name@m;
  `unsigned long long$ `version@m;
};
</pre>

<!-- `IDBFactory!I -->
<dl class="domintro">
	<dt>%request = `indexedDB$m . `open(name)$m</dt>
	<dd>
`名前$db %name の`~db$への`接続$を，該当する`~db$が［
存在するならば その現在の`~version$db ／
存在しないならば`~version$db 1
］で~openするよう要請する。
成功した場合の %request （ `IDBOpenDBRequest$I ）の `result$m は、
その~dbへの`接続$になる。
◎
Attempts to open a connection to the named database with the current version, or 1 if it does not already exist. If the request is successful request’s result will be the connection.
</dd>

	<dt>%request = `indexedDB$m . `open(name, version)$m</dt>
	<dd>
<p>
`名前$db %name の`~db$への`接続$を，指定した~version %version で~openするよう要請する。
該当する~db %db が存在する場合，その`~version$dbが：
</p>
		<ul>
			<li>
%version より低い場合、［
%db を~openしている, かつ
`versionchange$et ~eventに呼応して %db を~closeしていない
］`接続$が他に在るならば、
要請は`阻まれ$，それらすべてが~closeされてから昇格が生じることになる。
</li>
			<li>
%version より高い場合、
要請は失敗することになる。
</li>
		</ul>
<p>
成功した場合の %request （ `IDBOpenDBRequest$I ）の `result$m は、
当の`接続$になる。
</p>
◎
Attempts to open a connection to the named database with the specified version. If the database already exists with a lower version and there are open connections that don’t close in response to a versionchange event, the request will be blocked until they all close, then an upgrade will occur. If the database already exists with a higher version the request will fail. If the request is successful request’s result will be the connection.
</dd>

	<dt>%request = `indexedDB$m . `deleteDatabase(name)$m</dt>
	<dd>
名前 %name の`~db$を削除するよう要請する。
該当する~db %db が存在する場合、［
%db を~openしている, かつ
`versionchange$et ~eventに呼応して %db を~closeしていない
］`接続$が在るならば，要請は`阻まれ$ることになる。
成功した場合の %request の `result$m は、
~NULL になる。
◎
Attempts to delete the named database. If the database already exists and there are open connections that don’t close in response to a versionchange event, the request will be blocked until they all close. If the request is successful request’s result will be null.
</dd>

	<dt>%result = await `indexedDB$m . `databases$m()</dt>
	<dd>
［
`~storage~key$に専属する各~dbの名前と~versionからなる~obj
］たちが成す［
~snapshotを与える~list
］に解決される~promiseを返す。
◎
Returns a promise which resolves to a list of objects giving a snapshot of the names and versions of databases within the storage key.
</dd>
	<dd>
この~APIは、
~dbの利用を~~見直す~web~app用に意図される
— 例えば、
~siteの~codeの早期~versionを片付けるなど。
結果は~snapshotであることに注意
— この文脈や他の文脈により~dbを［
作成する／昇格する／削除する
］要請との間で［
~dataの収集-順, 対する応答の送達-順
］についての保証は無い。
◎
This API is intended for web applications to introspect the use of databases, for example to clean up from earlier versions of a site’s code. Note that the result is a snapshot; there are no guarantees about the sequencing of the collection of the data or the delivery of the response with respect to requests to create, upgrade, or delete databases by this context or others.
</dd>
</dl>

<div class="algo">
<p>
`open(name, version)@m
~method手続きは：
◎
The open(name, version) method steps are:
</p>
<ol>
	<li>
~IF［
%version ~EQ 0
］
⇒
~THROW `TypeError$E
◎
If version is 0 (zero), throw a TypeError.
</li>
	<li>
%~storage~key ~LET `~storage~keyを得する$( コレに`関連な設定群~obj$ )
◎
Let environment be this’s relevant settings object.
◎
Let storageKey be the result of running obtain a storage key given environment.＼
</li>
	<li>
~IF［
%~storage~key ~EQ `失敗^i
］
⇒
~THROW `SecurityError$E
◎
If failure is returned, then throw a "SecurityError" DOMException and abort these steps.
</li>
	<li>
%要請 ~LET 新たな`~open要請$
◎
Let request be a new open request.
</li>
	<li>
<p>
この段は、
`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
<p>
%結果 ~LET `~db接続を~openする$( %~storage~key, %name, %version, %要請 )
◎
Let result be the result of opening a database connection, with storageKey, name, version if given and undefined otherwise, and request.
</p>

<p class="note">注記：
名前 %name の`~db$が存在しなければ、
新たな`~db$が作成される。
%version が与えられていない場合、
接続は，［
既存の~dbに対しては その`~version$dbを変更することなく ／
新たな~dbに対しては その`~version$dbを 1 にして
］~openすることになる。
【！ details 】
◎
What happens if version is not given?
◎
If version is not given and a database with that name already exists, a connection will be opened without changing the version. If version is not given and no database with that name exists, a new database will be created with version equal to 1.
</p>
			</li>
			<li>
%要請 の`処理-済みか$ ~SET ~T
◎
Set request’s processed flag to true.
</li>
			<li>
<p>
`~db~taskを~queueする$( 次の手続き )
◎
Queue a database task to＼
</p>

<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
%要請 の
⇒＃
`済んだか$ ~SET ~T,
`結果$ ~SET ε,
`~error$ ~SET ε
◎
↓</li>
					<li>
<p>
~IF［
%結果 は~errorである
］：
</p>
						<ol>
							<li>
%要請 の`~error$ ~SET %結果
</li>
							<li>
`~eventを発火する$( %要請, `error$et )
— 次のように初期化して
⇒＃
`bubbles$m 属性 ~SET ~T,
`cancelable$m 属性 ~SET ~T
</li>
						</ol>
◎
If result is an error, then:
• Set request’s result to undefined.
• Set request’s error to result.
• Set request’s done flag to true.
• Fire an event named error at request with its bubbles and cancelable attributes initialized to true.
</li>
					<li>
<div class="p">
<p>
~ELSE：
</p>
						<ol>
							<li>
%要請 の`結果$ ~SET %結果
</li>
							<li>
`~eventを発火する$( %要請, `success$et )
</li>
						</ol>
◎
Otherwise:
• Set request’s result to result.
• Set request’s done flag to true.
• Fire an event named success at request.
</div>

<p class="note">注記：
上の【`~db接続を~openする$】手続きが`昇格~tx$を稼働させた場合、
この段は，それが`完遂-$した後に走ることになる。
これは、
別の~versionへの昇格が起こりつつある場合に，最初に`接続$上に `success$et ~eventを発火して、
~scriptが［
`versionchange$et ~event用の~listenerを登録する機会c
］を得られることを確保する【？】。
◎
NOTE: If the steps above resulted in an upgrade transaction being run, these steps will run after that transaction finishes. This ensures that in the case where another version upgrade is about to happen, the success event is fired on the connection first so that the script gets a chance to register a listener for the versionchange event.
</p>

<p class="note">注記：
ここで，通常の［
`~success~eventを発火する$ ／
`~error~eventを発火する$
］手続きを適用しないのは、
要請の`設置-先~tx$がないためである
（その手続きは，`設置-先~tx$を配送-前に作動化して配送-後に作動中でなくする）。
【！ details 】
◎
Why aren’t the steps to fire a success event or fire an error event used?
◎
There is no transaction associated with the request (at this point), so those steps — which activate an associated transaction before dispatch and deactivate the transaction after dispatch — do not apply.
</p>

					</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %要請 を表現する，`新たな~obj$( `IDBOpenDBRequest$I )
◎
Return a new IDBOpenDBRequest object for request.
</li>
</ol>
</div>

<div class="algo">
<p>
`deleteDatabase(name)@m
~method手続きは：
◎
The deleteDatabase(name) method steps are:
</p>
<ol>
	<li>
%~storage~key ~LET `~storage~keyを得する$( コレに`関連な設定群~obj$ )
◎
Let environment be this’s relevant settings object.
◎
Let storageKey be the result of running obtain a storage key given environment.＼
</li>
	<li>
~IF［
%~storage~key ~EQ `失敗^i
］
⇒
~THROW `SecurityError$E
◎
If failure is returned, then throw a "SecurityError" DOMException and abort these steps.
</li>
	<li>
%要請 ~LET 新たな`~open要請$
◎
Let request be a new open request.
</li>
	<li>
<p>
この段は、
`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
%結果 ~LET `~dbを削除する$( %~storage~key, %name, %要請 )
◎
Let result be the result of deleting a database, with storageKey, name, and request.
</li>
			<li>
%要請 の`処理-済みか$ ~SET ~T
◎
Set request’s processed flag to true.
</li>
			<li>
<p>
`~db~taskを~queueする$( 次の手続き )
◎
Queue a database task to＼
</p>

<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
%要請 の
⇒＃
`済んだか$ ~SET ~T,
`結果$ ~SET ε,
`~error$ ~SET ε
◎
↓</li>
					<li>
<p>
~IF［
%結果 は~errorである
］：
</p>
						<ol>
							<li>
%要請 の`~error$ ~SET %結果
</li>
							<li>
`~eventを発火する$( %要請, `error$et )
— 次のように初期化して
⇒＃
`bubbles$m 属性 ~SET ~T,
`cancelable$m 属性 ~SET ~T
</li>
						</ol>
◎
If result is an error, set request’s error to result, set request’s done flag to true, and fire an event named error at request with its bubbles and cancelable attributes initialized to true.
</li>
					<li>
<p>
~ELSE：
</p>
						<ol>
							<li>%要請 の`結果$ ~SET ε
</li>
							<li>
`~version変更~eventを発火する$( %要請, `success$et, %結果, ~NULL )
</li>
						</ol>
◎
Otherwise, set request’s result to undefined, set request’s done flag to true, and fire a version change event named success at request with result and null.
</li>
				</ol>
<p class="note">注記：
この時点では、
要請の`設置-先~tx$は無いので、
通常の［
`~success~eventを発火する$ ／
`~error~eventを発火する$
］手続きは
（それは，`設置-先~tx$を配送-前に作動化して配送-後に作動中でなくする），
適用できない。
また、
ここでの
`success$et ~eventは `IDBVersionChangeEvent$I であり，
`oldVersion^m, `newVersion^m も含んでいる。
【！ details 】
◎
Why aren’t the steps to fire a success event or fire an error event used?
◎
There is no transaction associated with the request, so those steps — which activate an associated transaction before dispatch and deactivate the transaction after dispatch — do not apply.
◎
Also, the success event here is a IDBVersionChangeEvent which includes the oldVersion and newVersion details.
</p>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %要請 を表現する，`新たな~obj$( `IDBOpenDBRequest$I )
◎
Return a new IDBOpenDBRequest object for request.
</li>
</ol>
</div>

<div class="algo">
<p>
`databases()@m
~method手続きは：
◎
The databases() method steps are:
</p>
<ol>
	<li>
%~storage~key ~LET `~storage~keyを得する$( コレに`関連な設定群~obj$ )
◎
Let environment be this’s relevant settings object.
◎
Let storageKey be the result of running obtain a storage key given environment.＼
</li>
	<li>
~IF［
%~storage~key ~EQ `失敗^i
］
⇒
~RET `却下される~promise$( `SecurityError$E 例外 )
◎
If failure is returned, then return a promise rejected with a "SecurityError" DOMException
</li>
	<li>
%p ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li>
<p>
この段は、
`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
<p>
%~db群 ~LET %~storage~key に`専属する$`~db$たちが成す`集合$
— 何らかの理由でこれを決定できない場合：
◎
Let databases be the set of databases in storageKey.＼
If this cannot be determined for any reason, then＼
</p>
				<ol>
					<li>
<p>
`~db~taskを~queueする$( 次の手続き )
◎
queue a database task to＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %p, 適切な~error（例： `UnknownError$E 例外）)
◎
reject p with an appropriate error (e.g. an "UnknownError" DOMException)＼
</div>
					</li>
					<li>
~RET
◎
and terminate these steps.
</li>
				</ol>
			</li>
			<li>
%~db~list ~LET 新たな`~list$
◎
Let result be a new list.
</li>
			<li>
<p>
%~db群 を成す
~EACH( `~db$ %~db )
に対し：
◎
For each db of databases:
</p>
				<ol>
					<li>
~IF［
%~db の`~version$db ~EQ 0
］
⇒
~CONTINUE
◎
If db’s version is 0, then continue.
</li>
					<li>
%info ~LET 新たな `IDBDatabaseInfo$I 辞書
◎
Let info be a new IDBDatabaseInfo dictionary.
</li>
					<li>
%info[ "`name^m" ] ~SET %~db の`名前$db,
◎
Set info’s name dictionary member to db’s name.
</li>
					<li>
%info[ "`version^m" ] ~SET %~db の `~version$db
◎
Set info’s version dictionary member to db’s version.
</li>
					<li>
%~db~list に %info を`付加する$
◎
Append info to result.
</li>
				</ol>

<p class="trans-note">【
%~db群 の順序は定義されていないので、
結果の順序も定義されないことになる。
】</p>

			</li>
			<li>
<p>
`~db~taskを~queueする$( 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %p, %~db~list )
</div>
◎
Queue a database task to resolve p with result.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>

<p class="advisement">🚧
この~methodは、
この版において新たに導入された。
［
Chrome 71, Edge 79, Firefox 126, Safari 14
］から~supportされている。
🚧
◎
🚧 The databases() method is new in this edition. It is supported in Chrome 71, Edge 79, Firefox 126, and Safari 14. 🚧
</p>
</div>

<dl class="domintro">
	<dt>%result = `indexedDB$m . `cmp(key1, key2)$m</dt>
	<dd>
2 個の値を`~key$として比較した結果を，次で与える数として返す
⇒＃
%key1 と %key2 は`等しい$ならば 0,
%key1 は %key2 `より小さい$ならば −1,
%key1 は %key2 `より大きい$ならば 1
◎
Compares two values as keys. Returns -1 if key1 precedes key2, 1 if key2 precedes key1, and 0 if the keys are equal.
</dd>
	<dd>
%key1, %key2 のいずれかが`~key$として妥当でない場合、
`DataError$E が投出される。
◎
Throws a "DataError" DOMException if either input is not a valid key.
</dd>
</dl>

<div class="algo">
<p>
`cmp(first, second)@m
~method手続きは：
◎
The cmp(first, second) method steps are:
</p>
<ol>
	<li>
%a ~LET `Key$( %first ) ？
◎
Let a be the result of converting a value to a key with first. Rethrow any exceptions.
◎
If a is "invalid value" or "invalid type", throw a "DataError" DOMException.
</li>
	<li>
%b ~LET `Key$( %second ) ？
◎
Let b be the result of converting a value to a key with second. Rethrow any exceptions.
◎
If b is "invalid value" or "invalid type", throw a "DataError" DOMException.
</li>
	<li>
~RET `~keyどうしを比較する$( %a, %b )
◎
Return the results of comparing two keys with a and b.
</li>
</ol>
</div>

		</section>
		<section id="database-interface">
<h3 title="The IDBDatabase interface">4.4. `IDBDatabase^I ~interface</h3>

<p>
`IDBDatabase$I ~interfaceは、
`~db$への`接続$を表現する。
◎
The IDBDatabase interface represents a connection to a database.
</p>

<div class="p">
<p>
［
~AND↓ を満たしている`接続$
］を表現する `IDBDatabase$I ~objは、
~garbage収集しないモノトスル：
</p>
<ul>
	<li>
`状態$Cn ~EQ `~open中$i
</li>
	<li>
［
`abort$et, `error$et, `versionchange$et
］いずれかの型の~event~listenerが登録されている
</li>
</ul>

<p>
`IDBDatabase$I ~objを~garbage収集するときは、
その前に，それが表現する`接続$を`~close$するモノトスル。
</p>

◎
An IDBDatabase object must not be garbage collected if its associated connection’s close pending flag is false and it has one or more event listeners registers whose type is one of abort, error, or versionchange. If an IDBDatabase object is garbage collected, the associated connection must be closed.
</div>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBDatabase@I : `EventTarget$I {
  readonly attribute `DOMString$ `name$m;
  readonly attribute `unsigned long long$ `version$m;
  readonly attribute `DOMStringList$I `objectStoreNames$m;

  [`NewObject$] `IDBTransaction$I `transaction$m(
      (`DOMString$ or `sequence$&lt;`DOMString$&gt;) %storeNames,
      optional `IDBTransactionMode$I %mode = `readonly$l
      optional `IDBTransactionOptions$I %options = {}
  );
  `undefined$ `close$m();

  [`NewObject$] `IDBObjectStore$I `createObjectStore$m(
      `DOMString$ %name,
      optional `IDBObjectStoreParameters$I %options = {}
  );
  `undefined$ `deleteObjectStore$m(
      `DOMString$ %name
  );

  // <span class="comment" title="Event handlers">~event~handler：</span>
  attribute `EventHandler$I `onabort$m;
  attribute `EventHandler$I `onclose$m;
  attribute `EventHandler$I `onerror$m;
  attribute `EventHandler$I `onversionchange$m;
};


enum `IDBTransactionDurability@I { `default@l, `strict@l, `relaxed@l };

dictionary `IDBTransactionOptions@I {
  `IDBTransactionDurability$I `durability@mb = `default$l;
};

dictionary `IDBObjectStoreParameters@I {
  (`DOMString$ or `sequence$&lt;`DOMString$&gt;)? `keyPath@mb = null;
  `boolean$ `autoIncrement@mb = false;
};
</pre>

<!-- `IDBDatabase!I -->
<dl class="domintro">
	<dt>%connection . `name$m</dt>
	<dd>
接続先~dbの`名前$dbを返す。
◎
Returns the name of the database.
</dd>

	<dt>%connection . `version$m</dt>
	<dd>
接続先~dbの`~version$dbを返す。
◎
Returns the version of the database.
</dd>
</dl>

<div class="algo">
<p>
`name@m
取得子~手続きは
⇒
~RET コレ↗の`名前$db
◎
The name getter steps are to return this’s associated database’s name.
</p>

<p class="note">注記：
この属性は、
`値を保ち続ける$。
◎
NOTE: The name attribute returns this name even if this’s close pending flag is true. In other words, the value of this attribute stays constant for the lifetime of the IDBDatabase instance.
</p>
</div>

<div class="algo">
<p>
`version@m
取得子~手続きは
⇒
~RET コレの`~version$Cn
◎
The version getter steps are to return this’s version.
</p>

<p class="note">注記：
この属性は、
コレの`状態$Cn ~EQ `~open中$i の間は，コレ↗の`~version$dbと同じ値を返し、
それ以降も同じ`値を保ち続ける$。
【！ details 】
◎
Is this the same as the database’s version?
◎
As long as the connection is open, this is the same as the connected database’s version. But once the connection has closed, this attribute will not reflect changes made with a later upgrade transaction.
</p>
</div>

<dl class="domintro">
	<dt>%connection . `objectStoreNames$m</dt>
	<dd>
接続先`~db$に`専属する$各`保管庫$の`名前$Osたちが成す~listを返す。
◎
Returns a list of the names of object stores in the database.
</dd>

	<dt>%store = %connection . `createObjectStore(name [, options])$m</dt>
	<dd>
接続先`~db$に`専属する$, かつ，`名前$Os %name の, %options を伴う新たな`保管庫$を作成した上で、
それを`~access先$とする新たな `IDBObjectStore$I を返す。
◎
Creates a new object store with the given name and options and returns a new IDBObjectStore.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E を投出する。
◎
Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>

	<dt>%connection . `deleteObjectStore(name)$m</dt>
	<dd>
接続先`~db$に`専属する$，`名前$Os %name の`保管庫$を削除する。
◎
Deletes the object store with the given name.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E を投出する。
◎
Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>
</dl>

<div class="algo">
<p>
`objectStoreNames@m
取得子~手続きは：
◎
The objectStoreNames getter steps are:
</p>
<ol>
	<li>
%名前~群 ~LET ［
コレの`保管庫~集合$Cnを成す各`保管庫$の`名前$Os
］たちが成す`~list$
◎
Let names be a list of the names of the object stores in this’s object store set.
</li>
	<li>
~RET `~sort済み名前~listを作成する$( %名前~群 )
◎
Return the result (a DOMStringList) of creating a sorted name list with names.
</li>
</ol>

<p class="note">注記：
この属性は、［
コレの`状態$Cn ~EQ `~open中$i
］の間は，コレ↗に専属する各`保管庫$の`名前$Osたちが成す~listと同じ値を返し、
それ以降も同じ`値を保ち続ける$。
◎
Is this the same as the database’s object store names?
◎
As long as the connection is open, this is the same as the connected database’s object store names. But once the connection has closed, this attribute will not reflect changes made with a later upgrade transaction.
</p>
</div>

<div class="algo">
<p>
`createObjectStore(name, options)@m
~method手続きは：
◎
The createObjectStore(name, options) method steps are:
</p>
<ol>
	<li>
%~tx ~LET コレ↗の`昇格~tx$db
◎
Let database be this’s associated database.
◎
Let transaction be database’s upgrade transaction if it is not null,＼
</li>
	<li>
<p>
~IF［
%~tx ~EQ ε
］
⇒
~THROW `InvalidStateError$E
</p>

<p class="trans-note">【
%~tx がコレ↗に`専属しない$場合も例外を投出するべきでは？
】</p>

◎
or throw an "InvalidStateError" DOMException otherwise.
</li>
	<li>
~IF［
%~tx の`状態$tx ~NEQ `作動中$i
］
⇒
~THROW `TransactionInactiveError$E
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%keyPath ~LET %options[ "`keyPath$mb" ]
◎
Let keyPath be options’s keyPath member if it is not undefined or null, or null otherwise.
</li>
	<li>
~IF［
%keyPath ~NEQ ~NULL
］~AND［
%keyPath は`妥当な~key~path$でない
］
⇒
~THROW `SyntaxError$E
◎
If keyPath is not null and is not a valid key path, throw a "SyntaxError" DOMException.
</li>
	<li>
コレの`保管庫~集合$Cnを成す
~EACH( %保管庫 )
に対し
⇒
~IF［
%保管庫 の`名前$Os ~EQ %name
］
⇒
~THROW `ConstraintError$E
◎
If an object store named name already exists in database throw a "ConstraintError" DOMException.
</li>
	<li>
%自動生成か ~LET %options[ "`autoIncrement$mb" ]
◎
Let autoIncrement be options’s autoIncrement member.
</li>
	<li>
~IF［
%自動生成か ~EQ ~T
］
⇒
~IF［
%keyPath ~EQ 空な `DOMString$I 値である
］~OR［
%keyPath は `~SeqDS$ 型である
］
⇒
~THROW `InvalidAccessError$E
◎
If autoIncrement is true and keyPath is an empty string or any sequence (empty or otherwise), throw an "InvalidAccessError" DOMException.
</li>
	<li>
%保管庫 ~LET 次のようにされた，新たな`保管庫$
— その
⇒＃
コレ↗に`専属する$,
`~record~list$Os ~SET 空~list,
`名前$Os ~SET %name,
`~key生成器$を［ %自動生成か ~EQ ~T ならば有する ／ ~ELSE_ 有さない ］,
`~key~path$Os ~SET ［ %keyPath ~NEQ ~NULL ならば %keyPath ／ ~ELSE_ ε ］
◎
Let store be a new object store in database. Set the created object store’s name to name. If autoIncrement is true, then the created object store uses a key generator. If keyPath is not null, set the created object store’s key path to keyPath.
</li>
	<li>
コレの`保管庫~集合$Cnに %保管庫 を追加する
【この段は、この訳による補完】
</li>
	<li>
~RET 次のようにされた，新たな`保管庫~handle$ %H
⇒＃
%H↗ ~EQ %保管庫,
%H は %~tx に`専属する$
◎
Return a new object store handle associated with store and transaction.
</li>
</ol>

<p>
この~methodは、
新たな`保管庫$を作成した上で，それを`~access先$とする新たな`保管庫~handle$を返す。
この~methodを~callできるのは、
`昇格~txの中$からに限られることに注意。
◎
This method creates and returns a new object store with the given name in the connected database. Note that this method must only be called from within an upgrade transaction.
</p>

<p>
この~methodは，コレ上の `objectStoreNames$m 属性を同期的に改変する。
◎
This method synchronously modifies the objectStoreNames property on the IDBDatabase instance on which it was called.
</p>

<div class="p">
<p>
実装によっては、［
この~methodが何かを返して，~db内に`保管庫$を作成する演算を~queueした後
］に，問題になる可能性がある。
例えば、［
新たに作成された`保管庫$についての~metadataを，~dbに非同期に挿入する所
］，あるいは［
~quota事由から，利用者に許可を依頼する必要があり得る所
］で。
そうなり得る場合でも、
実装は：
</p>
<ul>
	<li>
`IDBObjectStore$I ~objを作成して返すモノトスル。
</li>
	<li>
<p>
加えて，`保管庫$の作成ngに失敗したときは、［
失敗の事由に適切な~error名†
］を入力に
`~txを中止-$する手続きを行って，
%~tx を`中止-$するモノトスル。
</p>

<p>†
例えば
~quota事由に因り`保管庫$の作成ngに失敗した場合は、
`QuotaExceededError$I を利用するモノトスル。
</p>
	</li>
</ul>

◎
In some implementations it is possible for the implementation to run into problems after queuing a task to create the object store after the createObjectStore() method has returned. For example in implementations where metadata about the newly created object store is inserted into the database asynchronously, or where the implementation might need to ask the user for permission for quota reasons. Such implementations must still create and return an IDBObjectStore object, and once the implementation determines that creating the object store has failed, it must abort the transaction using the steps to abort a transaction using the appropriate error. For example if creating the object store failed due to quota reasons, a QuotaExceededError must be used as error.
</div>
</div>

<div class="algo">
<p>
`deleteObjectStore(name)@m
~method手続きは：
◎
The deleteObjectStore(name) method steps are:
</p>
<ol>
	<li>
%~tx ~LET コレ↗の`昇格~tx$db
◎
Let database be this’s associated database.
◎
Let transaction be database’s upgrade transaction if it is not null,＼
</li>
	<li>
<p>
~IF［
%~tx ~EQ ε
］
⇒
~THROW `InvalidStateError$E
</p>

<p class="trans-note">【
%~tx がコレ↗に`専属しない$場合も例外を投出するべきでは？
】</p>

◎
or throw an "InvalidStateError" DOMException otherwise.
</li>
	<li>
~IF［
%~tx の`状態$tx ~NEQ `作動中$i
］
⇒
~THROW `TransactionInactiveError$E
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%保管庫 ~LET コレの`保管庫~集合$Cn内の［
`名前$Os ~EQ %name
］なる`保管庫$
◎
Let store be the object store named name in database,＼
</li>
	<li>
~IF［
%保管庫 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
or throw a "NotFoundError" DOMException if none.
</li>
	<li>
コレの`保管庫~集合$Cnから %保管庫 を除去する
◎
Remove store from this’s object store set.
</li>
	<li>
~IF［
%~tx に`専属する$, かつ
%保管庫 を`~access先$とする`保管庫~handle$ %H がある
］
⇒
%H の`索引~集合$OsHを空にする
◎
If there is an object store handle associated with store and transaction, remove all entries from its index set.
</li>
	<li>
コレ↗内の %保管庫 を（ %保管庫 に`専属する$`索引$たちも込みで）破壊する
◎
Destroy store.
</li>
</ol>

<p>
この~methodは、
この`接続$↗に専属している，名前 %name の`保管庫$を破壊する。
この~methodを~callできるのは、
`昇格~txの中$からに限られることに注意。
◎
This method destroys the object store with the given name in the connected database. Note that this method must only be called from within an upgrade transaction.
</p>

<p>
この~methodは，コレ上の `objectStoreNames$m 属性を同期的に改変する。
◎
This method synchronously modifies the objectStoreNames property on the IDBDatabase instance on which it was called.
</p>
</div>

<dl class="domintro">
	<dt>%transaction = %connection . `transaction(scope [, mode [, options ] ])$m</dt>
	<dd>
%connection に`専属する$新たな`~tx$を返す
⇒＃
%scope が，その`視野$を与える（ 1 個の`名前$Os, または 1 個以上の`名前$Osからなる配列）。
%mode が，その`~mode$を与える（ `readonly$l ／ `readwrite$l ）。
%options の `durability$mb が，その`耐久能~hint$を与える（ `strict$l ／ `relaxed$l ／ `default$l ）。
◎
Returns a new transaction with the given scope (which can be a single object store name or an array of names), mode ("readonly" or "readwrite"), and additional options including durability ("default", "strict" or "relaxed").
</dd>
	<dd>
既定の %mode は `readonly$l であり、
既定の `durability$mb は `default$l である。
◎
The default mode is "readonly" and the default durability is "default".
</dd>

	<dt>%connection . `close$m()</dt>
	<dd>
%connection を~closeする
— ~closeし終えるのは、
%connection に`専属する$すべての`~tx$が完遂された時点になる。
◎
Closes the connection once all running transactions have finished.
</dd>
</dl>

<div class="algo">
<p>
`transaction(storeNames, mode, options)@m
~method手続きは：
◎
The transaction(storeNames, mode, options) method steps are:
</p>
<ol>
	<li>
~IF［
コレ↗の`昇格~tx$db ~NEQ ε
］~AND［
コレ↗の`昇格~tx$dbは`生きて$いる
］
⇒
~THROW `InvalidStateError$E
◎
If a live upgrade transaction is associated with the connection, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`状態$Cn ~NEQ `~open中$i
］
⇒
~THROW `InvalidStateError$E
◎
If this’s close pending flag is true, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%視野 ~LET %storeNames の型に応じて
⇒＃
`~SeqDS$ ならば，その中の一意な文字列たちが成す集合（集合なので，重複するものは一つにする）／
`DOMString$I ならば，その文字列のみからなる集合
◎
Let scope be the set of unique strings in storeNames if it is a sequence, or a set containing one string equal to storeNames otherwise.
</li>
	<li>
~IF［
%視野 内に，コレの`保管庫~集合$Cn内のどの`保管庫$の`名前$Osにも一致しないものがある
］
⇒
~THROW `NotFoundError$E
◎
If any string in scope is not the name of an object store in the connected database, throw a "NotFoundError" DOMException.
</li>
	<li>
~IF［
%視野 は 空である
］
⇒
~THROW `InvalidAccessError$E
◎
If scope is empty, throw an "InvalidAccessError" DOMException.
</li>
	<li>
~IF［
%mode ~NIN { `readonly$l, `readwrite$l }
］
⇒
~THROW `TypeError$E
◎
If mode is not "readonly" or "readwrite", throw a TypeError.
</li>
	<li>
%~tx ~LET 新たに`作成-$された`~tx$
— その
⇒＃
`視野$ ~SET ［ コレの`保管庫~集合$Cn内の， %視野 により指示される`保管庫$ ］たちが成す集合,
`~mode$ ~SET %mode,
`専属する$`接続$ ~SET コレ,
`耐久能~hint$ ~SET %options[ "`durability$mb" ]
◎
Let transaction be a newly created transaction with this connection, mode, options’ durability member, and the set of object stores named in scope.
</li>
	<li>
%~tx の`片付ける~event~loop$ ~SET 現在の`~event~loop$
◎
Set transaction’s cleanup event loop to the current event loop.
</li>
	<li>
~RET %~tx を表現する `IDBTransaction$I ~obj
◎
Return an IDBTransaction object representing transaction.
</li>
</ol>

<p class="advisement">🚧
`durability$m ~optionは、
この版において新たに導入された。
［
Chrome 82, Edge 82, Firefox 126, Safari 15
］から~supportされている。
🚧
◎
🚧 The durability option is new in this edition. It is supported in Chrome 82, Edge 82, Firefox 126, and Safari 15. 🚧
</p>

<p class="note">注記：
作成された~txは、
その`存続期間$の規則に従う。
◎
NOTE: The created transaction will follow the lifetime rules.
</p>
</div>

<div class="algo">
<p>
`close()@m
~method手続きは
⇒
`~db接続を~closeする$( コレ )
◎
The close() method steps are:
• Run close a database connection with this connection.
</p>

<p class="note">注記：
未決な`~tx$すべてが完了するまでは、
`接続$は実際には`~close$されない。
`close()$m に対する後続な~callには、
効果は無い。
◎
NOTE: The connection will not actually close until all outstanding transactions have completed. Subsequent calls to close() will have no effect.
</p>
</div>

<p>
`onabort@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `abort$et である。
◎
The onabort attribute is an event handler IDL attribute whose event handler event type is abort.
</p>

<p>
`onclose@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `close$et である。
◎
The onclose attribute is an event handler IDL attribute whose event handler event type is close.
</p>

<p>
`onerror@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `error$et である。
◎
The onerror attribute is an event handler IDL attribute whose event handler event type is error.
</p>

<p>
`onversionchange@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `versionchange$et である。
◎
The onversionchange attribute is an event handler IDL attribute whose event handler event type is versionchange.
</p>


		</section>
		<section id="object-store-interface">
<h3 title="The IDBObjectStore interface">4.5. `IDBObjectStore^I ~interface</h3>

<p>
`IDBObjectStore$I ~interfaceは、
`保管庫~handle$を表現する。
◎
The IDBObjectStore interface represents an object store handle.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBObjectStore@I {
  attribute `DOMString$ `name$m;
  readonly attribute `any$ `keyPath$m;
  readonly attribute `DOMStringList$I `indexNames$m;
  [`SameObject$] readonly attribute `IDBTransaction$I `transaction$m;
  readonly attribute `boolean$ `autoIncrement$m;

  [`NewObject$] `IDBRequest$I `put$m(
      `any$ %value,
      optional `any$ %key
  );
  [`NewObject$] `IDBRequest$I `add$m(
      `any$ %value,
      optional `any$ %key
  );
  [`NewObject$] `IDBRequest$I `delete$m(
      `any$ %query
  );
  [`NewObject$] `IDBRequest$I `clear$m();
  [`NewObject$] `IDBRequest$I `get$m(
      `any$ %query
  );
  [`NewObject$] `IDBRequest$I `getKey$m(
      `any$ %query
  );
  [`NewObject$] `IDBRequest$I `getAll$m(
      optional `any$ %queryOrOptions,
      optional [`EnforceRange$] `unsigned long$ %count
  );
  [`NewObject$] `IDBRequest$I `getAllKeys$m(
      optional `any$ %queryOrOptions,
      optional [`EnforceRange$] `unsigned long$ %count
  );
  [`NewObject$] `IDBRequest$I `getAllRecords$m(optional `IDBGetAllOptions$I %options = {});

  [`NewObject$] `IDBRequest$I `count$m(
      optional `any$ %query
  );

  [`NewObject$] `IDBRequest$I `openCursor$m(
      optional `any$ %query,
      optional `IDBCursorDirection$I %direction = "next"
  );
  [`NewObject$] `IDBRequest$I `openKeyCursor$m(
      optional `any$ %query,
      optional `IDBCursorDirection$I %direction = "next"
  );

  `IDBIndex$I `index$m(
      `DOMString$ %name
  );

  [`NewObject$] `IDBIndex$I `createIndex$m(
      `DOMString$ %name,
      (`DOMString$ or `sequence$&lt;`DOMString$&gt;) %keyPath,
      optional `IDBIndexParameters$I %options = {}
  );
  `undefined$ `deleteIndex$m(
      `DOMString$ %name
  );
};

dictionary `IDBIndexParameters@I {
  `boolean$ `unique@mb = false;
  `boolean$ `multiEntry@mb = false;
};

dictionary `IDBGetAllOptions@I {
  `any$ `query@mb = null;
  [`EnforceRange$] `unsigned long$ `count@mb;
  `IDBCursorDirection$I `direction@mb = "next";
};
</pre>

<!-- `IDBObjectStore!I -->
<dl class="domintro">
	<dt>%store . `name$m</dt>
	<dd>
%store↗ の`名前$Osを返す。
◎
Returns the name of the store.
</dd>

	<dt>%store . `name$m = %newName</dt>
	<dd>
%store↗ の`名前$Osを %newName に更新する。
◎
Updates the name of the store to newName.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E が投出される。
◎
Throws "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>

	<dt>%store . `keyPath$m</dt>
	<dd>
%store↗ の`~key~path$Os ~NEQ ε ならば それ ／
~ELSE_ ~NULL
を返す。
◎
Returns the key path of the store, or null if none.
</dd>

	<dt>%store . `indexNames$m</dt>
	<dd>
%store↗ に`専属する$各`索引$の`名前$Ixたちが成す~listを返す。
◎
Returns a list of the names of indexes in the store.
</dd>

	<dt>%store . `transaction$m</dt>
	<dd>
%store が`専属する$`~tx$を返す。
◎
Returns the associated transaction.
</dd>

	<dt>%store . `autoIncrement$m</dt>
	<dd>
%store↗ が`~key生成器$を［
有するならば ~T ／
有さないならば ~F
］を返す。
◎
Returns true if the store has a key generator, and false otherwise.
</dd>
</dl>

<div class="algo">
<p>
`name@m
取得子~手続きは
⇒
~RET コレの`名前$OsH
◎
The name getter steps are to return this’s name.
</p>

<p class="note">注記：
この属性は、
コレが`専属する$~txが`完遂-$するまでは，コレ↗の`名前$Osと同じ値を返し、
それ以降も同じ`値を保ち続ける$。
【！ details 】
◎
Is this the same as the object store’s name?
◎
As long as the transaction has not finished, this is the same as the associated object store’s name. But once the transaction has finished, this attribute will not reflect changes made with a later upgrade transaction.
</p>
</div>

<div class="algo">
<p>
`name$m 設定子~手続きは：
◎
The name setter steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `versionchange^l ) ？
◎
Let name be the given value.
◎
Let transaction be this’s transaction.
◎
Let store be this’s object store.
◎
変則＊
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction is not an upgrade transaction, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%name ~LET `所与の値$
◎
↑</li>
	<li>
~IF［
コレの`名前$OsH ~EQ %name
］
⇒
~RET
◎
If store’s name is equal to name, terminate these steps.
</li>
	<li>
コレが`専属する$`接続$の`保管庫~集合$Cnを成す
~EACH( %保管庫 )
に対し
⇒
~IF［
%保管庫 の`名前$Os ~EQ %name
］
⇒
~THROW `ConstraintError$E
◎
If an object store named name already exists in store’s database, throw a "ConstraintError" DOMException.
</li>
	<li>
コレ↗の`名前$Os ~SET %name
◎
Set store’s name to name.
</li>
	<li>
コレの`名前$OsH ~SET %name
◎
Set this’s name to name.
</li>
</ol>
</div>

<div class="algo">
<p>
`keyPath@m
取得子~手続きは
⇒
~RET コレ↗の`~key~path$Os %P に応じて，［
%P ~EQ ε ならば ~NULL ／
~ELSE_ %P を `WEBIDL$r に従って，次の型として変換した結果
］
⇒＃
%P は文字列であるならば `DOMString$I ／
%P は文字列たちが成す~listであるならば `~SeqDS$
◎
The keyPath getter steps are to return this’s object store’s key path, or null if none. The key path is converted as a DOMString (if a string) or a sequence&lt;DOMString&gt; (if a list of strings), per [WEBIDL].
</p>

<p>
【この属性は、`値を保ち続ける$。】
</p>

<p class="note">注記：
返される値は、
コレの作成-時に利用した~instanceと同じではない。
しかしながら，この属性が~obj（特定的には `Array$jT ）を返す場合、
毎回~同じ~instanceを返す。
返された~objの~prop値を変更しても，コレに効果を及ぼすことはない。
◎
NOTE: The returned value is not the same instance that was used when the object store was created. However, if this attribute returns an object (specifically an Array), it returns the same object instance every time it is inspected. Changing the properties of the object has no effect on the object store.
</p>
</div>

<div class="algo">
<p>
`indexNames@m
取得子~手続きは：
◎
The indexNames getter steps are:
</p>
<ol>
	<li>
%名前~群 ~LET ［
コレの`索引~集合$OsHを成す各`索引$の`名前$Ix
］たちが成す`~list$
◎
Let names be a list of the names of the indexes in this’s index set.
</li>
	<li>
~RET `~sort済み名前~listを作成する$( %名前~群 )
◎
Return the result (a DOMStringList) of creating a sorted name list with names.
</li>
</ol>

<p class="note">注記：
この属性は、
コレが`専属する$~txが`完遂-$するまでは，コレ↗に専属する各`索引$の名前たちが成す~listと同じ値を返し、
それ以降も同じ`値を保ち続ける$。
【！ deitails 】
◎
Is this the same as object store’s list of index names?
◎
As long as the transaction has not finished, this is the same as the associated object store’s list of index names. But once the transaction has finished, this attribute will not reflect changes made with a later upgrade transaction.
</p>
</div>

<div class="algo">
<p>
`transaction@m
取得子~手続きは
⇒
~RET コレが`専属する$~tx
◎
The transaction getter steps are to return this’s transaction.
</div>

<div class="algo">
<p>
`autoIncrement@m
取得子~手続きは
⇒
~RET ~IS［
コレ↗の`~key生成器$ ~NEQ ε
］
◎
The autoIncrement getter steps are to return true if this’s object store has a key generator, and false otherwise.
</p>

<p>
【この属性は、`値を保ち続ける$。】
</p>
</div>

<p class="note">注記：
以下に挙げる~methodは、［
`~readonly~tx$の中で~callされた場合は `ReadOnlyError$E ／
`~tx$が `作動中$i でないときに~callされた場合は `TransactionInactiveError$E
］を投出する。
◎
The following methods throw a "ReadOnlyError" DOMException if called within a read-only transaction, and a "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl class="domintro">
	<dt>%request = %store . `put(value [, key])$m</dt>
	<dt>%request = %store . `add(value [, key])$m</dt>
	<dd>
%store↗ 内に新たな`~record$ { %key : %value } を追加する／更新するよう要請する。
◎
Adds or updates a record in store with the given value and key.
</dd>
	<dd>
%store↗ の`~key~path$Os ~NEQ ε の場合、
%key は省略する必要がある
— さもなければ `DataError$E が投出される。
【この場合の~keyは，`~key~path$Osを介して %value から抽出される】
◎
If the store uses in-line keys and key is specified a "DataError" DOMException will be thrown.
</dd>
	<dd>
<p>
%store↗ 内に`~key$ %key を有する`~record$がすでに存在する場合：
</p>
		<ul>
			<li>
`put()$m に対しては、
新たな~recordで置換されることになる
（すなわち，~recordの値が更新される）。
</li>
			<li>
`add()$m に対しては、
要請は失敗し，
%request の 【！ ＊ 】`IDBRequest.error$m は `ConstraintError$E 例外に設定されることになる。
</li>
		</ul>
◎
If put() is used, any existing record with the key will be replaced. If add() is used, and if a record with the key already exists the request will fail, with request’s error set to a "ConstraintError" DOMException.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
追加した（置換した）`~record$の`~key$になる。
◎
If successful, request’s result will be the record’s key.
</dd>

	<dt>%request = %store . `delete(query)$m</dt>
	<dd>
%store↗ の`~record~list$Osから［
%query が`表現する~key範囲$に入る`~record$たち
］を削除するよう要請する。
◎
Deletes records in store with the given key or in the given key range in query.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
`undefined^jv になる。
◎
If successful, request’s result will be undefined.
</dd>

	<dt>%request = %store . `clear$m()</dt>
	<dd>
%store↗ の`~record~list$Osを空にするよう要請する。
◎
Deletes all records in store.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
`undefined^jv になる。
◎
If successful, request’s result will be undefined.
</dd>
</dl>

<div class="algo">
`put(value, key)@m
~method手続きは
⇒
`addするかputする$( コレ, %value, %key, ε )
◎
The put(value, key) method steps are to return the result of running add or put with this, value, key and the no-overwrite flag false.
</div>

<div class="algo">
`add(value, key)@m
~method手続きは
⇒
`addするかputする$( コレ, %value, %key, `上書不可^i )
◎
The add(value, key) method steps are to return the result of running add or put with this, value, key and the no-overwrite flag true.
</div>

<div class="algo">
<p>
`addするかputする@
~algoは、
所与の
( %~handle, %value, %key, %上書不可か )
に対し：
◎
To add or put with handle, value, key, and no-overwrite flag, run these steps:
</p>
<ol>
	<li>
`状態を検査する$( %~handle, `readwrite^l ) ？
◎
Let transaction be handle’s transaction.
◎
Let store be handle’s object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
</li>
	<li>
%keyPath ~LET %~handle の`~key~path$Os
◎
↓</li>
	<li>
%生成器 ~LET %~handle の`~key生成器$
◎
↓</li>
	<li>
~IF［
%keyPath ~NEQ ε
］~AND［
%key ~NEQ ε
］
⇒
~THROW `DataError$E
◎
If store uses in-line keys and key was given, throw a "DataError" DOMException.
</li>
	<li>
~IF［
%keyPath ~EQ ε
］~AND［
%key ~EQ ε
］~AND［
%生成器 ~EQ ε
］
⇒
~THROW `DataError$E
◎
If store uses out-of-line keys and has no key generator and key was not given, throw a "DataError" DOMException.
</li>
	<li>
~IF［
%key ~NEQ ε
］
⇒
%key ~LET `Key$( %key ) ？
◎
If key was given, then:
• Let r be the result of converting a value to a key with key. Rethrow any exceptions.
• If r is "invalid value" or "invalid type", throw a "DataError" DOMException.
• Let key be r.
</li>
	<li>
%~clone ~LET `~txの間に値を~cloneする$( %value, %~handle が`専属する$`~tx$ ) ？
◎
Let targetRealm be a user-agent defined Realm.
◎
Let clone be a clone of value in targetRealm during transaction. Rethrow any exceptions.
◎
Why create a copy of the value?
◎
The value is serialized when stored. Treating it as a copy here allows other algorithms in this specification to treat it as an ECMAScript value, but implementations can optimize this if the difference in behavior is not observable.
</li>
	<li>
<p>
~IF［
%keyPath ~NEQ ε
］：
</p>
		<ol>
			<li>
%抽出d~key ~LET `Extract$( %~clone, %keyPath, %生成器 ) ？
</li>
			<li>
~IF［
%抽出d~key ~NEQ ε
］
⇒
%key ~SET %抽出d~key
</li>
			<li>
~ELIF［
`~keyを値の中へ注入できるか検査する$( %~clone, %keyPath ) の結果 ~EQ ~F
］
⇒
~THROW `DataError$E
</li>
		</ol>
◎
If store uses in-line keys, then:
• Let kpk be the result of extracting a key from a value using a key path with clone and store’s key path. Rethrow any exceptions.
• If kpk is invalid, throw a "DataError" DOMException.
• If kpk is not failure, let key be kpk.
• Otherwise (kpk is failure):
•• If store does not have a key generator, throw a "DataError" DOMException.
•• If check that a key could be injected into a value with clone and store’s key path return false, throw a "DataError" DOMException.
</li>
	<li>
<p>
~RET `要請を非同期に実行する$( %~handle, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`保管庫に~recordを格納する$( %~handle↗, %~clone, %key, %上書不可か )
</div>
◎
Let operation be an algorithm to run store a record into an object store with store, clone, key, and no-overwrite flag.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with handle and operation.
</li>
</ol>
</div>

<div class="algo">
<p>
`delete(query)@m
~method手続きは：
◎
The delete(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `readwrite^l ) ？
◎
Let transaction be this’s transaction.
◎
Let store be this’s object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
</li>
	<li>
%範囲 ~LET `~key範囲へ変換する$( %query, `~NULL不可^i ) ？
◎
Let range be the result of converting a value to a key range with query and true. Rethrow any exceptions.
</li>
	<li>
<p>
~RET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`保管庫から~recordを削除する$( コレ↗, %範囲 )
</div>
◎
Let operation be an algorithm to run delete records from an object store with store and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、［
`~key$／`~key範囲$
］をとり得る
— それにより識別される`~record$たちが削除される。
◎
NOTE: The query parameter can be a key or key range (an IDBKeyRange) identifying the records to be deleted.
</p>

<p class="note">注記：
他の~methodと違って、
この~methodの %query 引数は，
<strong>省略可能でなく, ~NULL 値も許容されない</strong>
（すなわち，`全範囲$は指定できない）。
これは、
小さな~bugにより，保管庫の中を全~clearする~riskを抑制するためである。
◎
NOTE: Unlike other methods which take keys or key ranges, this method does not allow null to be given as key. This is to reduce the risk that a small bug would clear a whole object store.
</p>
</div>

<div class="algo">
<p>
`clear()@m
~method手続きは：
◎
The clear() method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `readwrite^l ) ？
◎
Let transaction be this’s transaction.
◎
Let store be this’s object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
</li>
	<li>
<p>
~RET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`保管庫を~clearする$( コレ↗ )
</div>
◎
Let operation be an algorithm to run clear an object store with store.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>
</div>

<p class="note">注記：
以下に挙げる~methodは、
`~tx$が `作動中$i でないときに~callされた場合は
`TransactionInactiveError$E を投出する。
◎
The following methods throw a "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl class="domintro">
	<dt>%request = %store . `get(query)$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$に入る`~record$たち
］のうち，最初の~recordの`値$を検索取得するよう要請する。
◎
Retrieves the value of the first record matching the given key or key range in query.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
該当する~recordが［
在るならば その`値$／
無いならば `undefined^jv
］になる。
◎
If successful, request’s result will be the value, or undefined if there was no matching record.
</dd>

	<dt>%request = %store . `getKey(query)$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$に入る`~record$たち
］のうち，最初の~recordの`~key$を検索取得するよう要請する。
◎
Retrieves the key of the first record matching the given key or key range in query.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
該当する~recordが［
在るならば その`~key$／
無いならば `undefined^jv
］になる。
◎
If successful, request’s result will be the key, or undefined if there was no matching record.
</dd>

	<dt>%request = %store . `getAll(query [, count])$m</dt>
	<dt>%request = %store . `getAll({query, count, direction})$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$に入る`~record$たち
］のうち，
最初から %count 個までの~recordの`値$を検索取得するよう要請する
— %direction が［
`next$l ／ `prev$l
］に設定された場合は［
最初／最後
］から検索取得するようになる。
◎
Retrieves the values of the records matching the given key or key range in query (up to count if given).＼
Set the direction option to "next" to retrieve the first count values, or "prev" to return the last count values.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
`値$たちが成す `Array$jT になる。
◎
If successful, request’s result will be an Array of the values.
</dd>

	<dt>%request = %store . `getAllKeys(query [, count])$m</dt>
	<dt>%request = %store . `getAllKeys({query, count, direction})$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$に入る`~record$たち
］のうち，
最初から %count 個までの~recordの`~key$を検索取得するよう要請する
— %direction が［
`next$l ／ `prev$l
］に設定された場合は［
最初／最後
］から検索取得するようになる。
◎
Retrieves the keys of records matching the given key or key range in query (up to count if given).＼
Set the direction option to "next" to retrieve the first count keys, or "prev" to return the last count keys.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
`~key$たちが成す `Array$jT になる。
◎
If successful, request’s result will be an Array of the keys.
</dd>

	<dt>%request = %store . `getAllRecords({query, count, direction})$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$に入る`~record$たち
］のうち，
最初から %count 個までの~recordの［
`~key$, `値$ 
］を検索取得するよう要請する
— %direction が［
`next$l ／ `prev$l
］に設定された場合は［
最初／最後
］から検索取得するようになる。
◎
Retrieves the keys and values of records.
◎
The query option specifies a key or key range to match. The count option limits the number of records matched.＼
Set the direction option to "next" to retrieve the first count records, or "prev" to return the last count records.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
`IDBRecord$I たちが成す `Array$jT になる。
◎
If successful, request’s result will be an Array, with each member being an IDBRecord.
</dd>

	<dt>%request = %store . `count(query)$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$に入る`~record$たち
］の総数を得るよう要請する。
◎
Retrieves the number of records matching the given key or key range in query.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
得られた総数になる。
◎
If successful, request’s result will be the count.
</dd>
</dl>

<div class="algo">
<p>
`get(query)@m
~method手続きは：
◎
The get(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
Let store be this’s object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
<p>
%範囲 ~LET `~key範囲へ変換する$( %query, `~NULL不可^i ) ？
◎
Let range be the result of converting a value to a key range with query and true. Rethrow any exceptions.
</li>
	<li>
<p>
~RET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`範囲に入る最初の~entryを検索取得する$( `現在の~realm$, コレ↗, %範囲, `値^i )
</div>
◎
Let operation be an algorithm to run retrieve a value from an object store with the current Realm record, store, and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、［
`~key$／`~key範囲$
］をとり得る
— それにより識別される`~record$
（範囲が指定された場合、
範囲に入る最初の既存の~record）
の`値$が検索取得される。
◎
NOTE: The query parameter can be a key or key range (an IDBKeyRange) identifying the record value to be retrieved. If a range is specified, the method retrieves the first existing value in that range.
</p>

<p class="note">注記：
この~methodによる要請の`結果$は、
所与の~keyを伴う~recordが存在しない場合も,
`値$が `undefined^jv の~recordが存在する場合も，
`undefined^jv 値になる。
両者を区別する必要があるときは、
同じ~keyで `openCursor()$m を利用できる
— その`結果$は、
~recordが存在しなければ ~NULL になる一方で，存在するときは［
`値$Cs ~SET `undefined^jv†
］にされた`~cursor$になる。
【† この訳では、内部処理~modelにおいては，値 ε により，そのような~recordが存在する場合とを区別している。】
◎
NOTE: This method produces the same result if a record with the given key doesn’t exist as when a record exists, but has undefined as value. If you need to tell the two situations apart, you can use openCursor() with the same key. This will return a cursor with undefined as value if a record exists, or no cursor if no such record exists.
</p>
</div>

<div class="algo">
<p>
`getKey(query)@m
~method手続きは：
◎
The getKey(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
Let store be this’s object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `~key範囲へ変換する$( %query, `~NULL不可^i ) ？
◎
Let range be the result of converting a value to a key range with query and true. Rethrow any exceptions.
</li>
	<li>
<p>
~RET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`範囲に入る最初の~entryを検索取得する$( `現在の~realm$, コレ↗, %範囲, `~key^i )
</div>
◎
Let operation be an algorithm to run retrieve a key from an object store with store and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、［
`~key$／`~key範囲$
］をとり得る
— それにより識別される`~record$
（範囲が指定された場合、
範囲に入る最初の既存の~record）
の`~key$が検索取得される。
◎
NOTE: The query parameter can be a key or key range (an IDBKeyRange) identifying the record key to be retrieved. If a range is specified, the method retrieves the first existing key in that range.
</p>
</div>

<div class="algo">
<p>
`getAll(queryOrOptions, count)@m
~method手続きは：
◎
The getAll(queryOrOptions, count) method steps are:
</p>
<ol>
	<li>
~RET `複数個の~itemを検索取得する要請を作成する$( ↓ ) ？
⇒＃
`現在の~realm$,
コレ, 
`値^i,
%queryOrOptions,
%count
◎
Return the result of creating a request to retrieve multiple items with the current Realm record, this, "value", queryOrOptions, and count if given. Rethrow any exceptions.
</li>
</ol>

<p class="advisement">🚧
%queryOrOptions 引数~用の `IDBGetAllOptions$I は、
`この版$において新たに導入された。
［
Chrome 141, Edge 141
］から~supportされている。
🚧
◎
🚧 The IDBGetAllOptions argument for getAll() is new in this edition. It is supported in Chrome 141, and Edge 141. 🚧
</p>
</div>

<div class="algo">
<p>
`getAllKeys(queryOrOptions, count)@m
~method手続きは：
◎
The getAllKeys(queryOrOptions, count) method steps are:
</p>
<ol>
	<li>
~RET `複数個の~itemを検索取得する要請を作成する$( ↓ ) ？
⇒＃
`現在の~realm$,
コレ,
`~key^i,
%queryOrOptions,
%count
◎
Return the result of creating a request to retrieve multiple items with the current Realm record, this, "key", queryOrOptions, and count if given. Rethrow any exceptions.
</li>
</ol>

<p class="advisement">🚧
%queryOrOptions 引数~用の `IDBGetAllOptions$I は、
`この版$において新たに導入された。
［
Chrome 141, Edge 141
］から~supportされている。
🚧
◎
🚧 The IDBGetAllOptions argument for getAllKeys() is new in this edition. It is supported in Chrome 141, and Edge 141. 🚧
</p>
</div>

<div class="algo">
<p>
`getAllRecords(options)@m
~method手続きは：
◎
The getAllRecords(options) method steps are:
</p>
<ol>
	<li>
~RET `複数個の~itemを検索取得する要請を作成する$( ↓ ) ？
⇒＃
`現在の~realm$,
コレ,
`~record^i,
%options
◎
Return the result of creating a request to retrieve multiple items with the current Realm record, this, "record", and options. Rethrow any exceptions.
</li>
</ol>

<p class="advisement">🚧
この~methodは、
`この版$において新たに導入された。
［
Chrome 141, Edge 141
］から~supportされている。
🚧
◎
🚧 The getAllRecords() method is new in this edition. It is supported in Chrome 141, and Edge 141. 🚧
</p>
</div>

<div class="algo">
<p>
`count(query)@m
~method手続きは：
◎
The count(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
Let store be this’s object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `~key範囲へ変換する$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
<p>
~RET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`範囲に入る~recordを数える$( コレ↗, %範囲 )
</div>
◎
Let operation be an algorithm to run count the records in a range with store and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、［
`~key$／`~key範囲$
］をとり得る
— それにより識別される`~record$たちが数えられる。
~NULL または省略時には，`全範囲$が利用される。
◎
NOTE: The query parameter can be a key or key range (an IDBKeyRange) identifying the records to be counted. If null or not given, an unbounded key range is used.
</p>
</div>

<p class="note">注記：
以下に挙げる~methodは、
`~tx$が `作動中$i でないときに~callされた場合は
`TransactionInactiveError$E を投出する。
◎
The following methods throw a "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl class="domintro">
	<dt>%request = %store . `openCursor([query [, direction = "next"]])$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$（ %query が~NULL ならば`全範囲$）に入る`~record$たち
］を［
`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
◎
Opens a cursor over the records matching query, ordered by direction. If query is null, all records in store are matched.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
範囲に入る~recordが［
在るならば 反復-順で最初の~recordを指している `IDBCursorWithValue$I ／
無いならば ~NULL
］になる。
◎
If successful, request’s result will be an IDBCursorWithValue pointing at the first matching record, or null if there were no matching records.
</dd>

	<dt>%request = %store . `openKeyCursor([query [, direction = "next"]])$m</dt>
	<dd>
%store↗ の`~record~list$Os内の［
%query が`表現する~key範囲$（ %query が~NULL ならば`全範囲$）に入る`~record$たち
］を［
`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
作成される`~cursor$の`~keyのみか$Csは ~T に設定される
（~cursorは、
~recordの~keyのみを取得する）。
◎
Opens a cursor with key only flag set to true over the records matching query, ordered by direction. If query is null, all records in store are matched.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
範囲に入る~recordが［
在るならば 反復-順で最初の~recordを指している `IDBCursor$I ／
無いならば ~NULL
］になる。
◎
If successful, request’s result will be an IDBCursor pointing at the first matching record, or null if there were no matching records.
</dd>
</dl>

<div class="algo">
<p>
`openCursor(query, direction)@m
~method手続きは：
◎
The openCursor(query, direction) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
Let store be this’s object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `~key範囲へ変換する$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
<p>
%要請 ~LET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~cursorを作成する$( `現在の~realm$, コレ, %direction, %範囲 )
</div>
◎
Let cursor be a new cursor with its source handle set to this, undefined position, direction set to direction, got value flag set to false, undefined key and value, range set to range, and key only flag set to false.
◎
Let operation be an algorithm to run iterate a cursor with the current Realm record and cursor.
◎
Let request be the result of running asynchronously execute a request with this and operation.
</li>
	<li>
コレの`要請$Cs ~SET %要請
◎
Set cursor’s request to request.
</li>
	<li>
~RET %要請
◎
Return request.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
`~cursor$の`範囲$Csとして利用する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
NOTE: The query parameter can be a key or key range (an IDBKeyRange) to use as the cursor’s range. If null or not given, an unbounded key range is used.
</p>
</div>

<div class="algo">
<p>
`openKeyCursor(query, direction)@m
~method手続きは：
◎
The openKeyCursor(query, direction) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
Let store be this’s object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `~key範囲へ変換する$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
<p>
%要請 ~LET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~cursorを作成する$( `現在の~realm$, コレ, %direction, %範囲, `~keyのみ^i )
</div>
◎
Let cursor be a new cursor with its source handle set to this, undefined position, direction set to direction, got value flag set to false, undefined key and value, range set to range, and key only flag set to true.
◎
Let operation be an algorithm to run iterate a cursor with the current Realm record and cursor.
◎
Let request be the result of running asynchronously execute a request with this and operation.
</li>
	<li>
コレの`要請$Cs ~SET %要請
◎
Set cursor’s request to request.
</li>
	<li>
~RET %要請
◎
Return request.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
`~cursor$の`範囲$Csとして利用する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
NOTE: The query parameter can be a key or key range (an IDBKeyRange) to use as the cursor’s range. If null or not given, an unbounded key range is used.
</p>
</div>

<dl class="domintro">
	<dt>%index = %store . `index(name)$m</dt>
	<dd>
［
%store↗ に`専属する$，`名前$Ix %name の`索引$
］を`~access先$とする，`索引~handle$（ `IDBIndex$I ）を返す。
◎
Returns an IDBIndex for the index named name in store.
</dd>

	<dt>%index = %store . `createIndex(name, keyPath [, options])$m</dt>
	<dd>
%store↗ に`専属する$新たな`索引$を，所与の［
%name, %keyPath, %options
］を伴うように作成した上で、
それを`~access先$とする新たな `IDBIndex$I を返す。
［
%keyPath, %options
］が %store 内にすでにある~dataから
`索引を拡充-＠#_populating-an-index$できない拘束を定義する場合、
当の`昇格~tx$は `ConstraintError$E で`中止-$されることになる。
◎
Creates a new index in store with the given name, keyPath and options and returns a new IDBIndex. If the keyPath and options define constraints that cannot be satisfied with the data already in store the upgrade transaction will abort with a "ConstraintError" DOMException.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E が投出される。
◎
Throws an "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>

	<dt>%store . `deleteIndex(name)$m</dt>
	<dd>
%store↗ に`専属する$，`名前$Ix %name の`索引$を削除する。
◎
Deletes the index in store with the given name.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E が投出される。
◎
Throws an "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>
</dl>

<div class="algo">
<p>
`createIndex(name, keyPath, options)@m
~method手続きは：
◎
The createIndex(name, keyPath, options) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `versionchange^l ) ？
◎
Let transaction be this’s transaction.
◎
Let store be this’s object store.
◎
If transaction is not an upgrade transaction, throw an "InvalidStateError" DOMException.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
コレの`索引~集合$OsHを成す
~EACH( %索引 )
に対し
⇒
~IF［
%索引 の`名前$Ix ~EQ %name
］
⇒
~THROW `ConstraintError$E
◎
If an index named name already exists in store, throw a "ConstraintError" DOMException.
</li>
	<li>
~IF［
%keyPath は`妥当な~key~path$でない
］
⇒
~THROW `SyntaxError$E
◎
If keyPath is not a valid key path, throw a "SyntaxError" DOMException.
</li>
	<li>
%一意か ~LET %options[ "`unique$mb" ]
◎
Let unique be options’s unique member.
</li>
	<li>
%複-~entryか ~LET %options[ "`multiEntry$mb" ]
◎
Let multiEntry be options’s multiEntry member.
</li>
	<li>
~IF［
%keyPath は`~SeqDS$ 型である
］~AND［
%複-~entryか ~EQ ~T
］
⇒
~THROW `InvalidAccessError$E
◎
If keyPath is a sequence and multiEntry is true, throw an "InvalidAccessError" DOMException.
</li>
	<li>
%索引 ~LET 新たな`索引$†
— その
⇒＃
コレ↗に`専属する$,
`名前$Ix ~SET %name,
`~key~path$Ix ~SET %keyPath,
`一意か$Ix ~SET %一意か,
`複-~entryか$Ix ~SET %複-~entryか
◎
Let index be a new index in store. Set index’s name to name, key path to keyPath, unique flag to unique, and multiEntry flag to multiEntry.
</li>
	<li>
%索引 をコレの`索引~集合$OsHに追加する
◎
Add index to this’s index set.
</li>
	<li>
~RET 次のようにされた，新たな`索引~handle$ %H
⇒＃
%H↗ ~EQ %索引,
%H はコレに`専属する$,
`名前$IxH ~SET %name
◎
Return a new index handle associated with index and this.
</li>
</ol>

<p class="trans-note">【†
索引の`~record~list$Ixは、
自動的にコレの`~record~list$Osにより拡充されることになる。
】</p>

<p>
この~methodは、
コレに`専属する$, 名前 %name の新たな`索引$を作成した上で、
それを`~access先$とする 新たな`索引~handle$を返す。
この~methodを~callできるのは、
`昇格~txの中$からに限られることに注意。
◎
This method creates and returns a new index with the given name in the object store. Note that this method must only be called from within an upgrade transaction.
</p>

<p>
作成するよう要請された索引は、［
自身が`専属する$`保管庫$に許容される~data
］についての拘束を伴うこともある
— 索引の［
`一意か$Ix ~EQ ~T
］により，索引の`~key~path$Ixが指す部位の値（`参照先~record$の値）の一意性が要求されるなど。
その保管庫が，この拘束に違反する~dataをすでに包含している場合でも、
実装は，［
この~methodにて例外を投出したり，それが返すものに影響させる
］ことなく， `IDBIndex^I ~objを作成して返すモノトスル。
代わりに実装は、［
この~methodの~callに利用された，`昇格~tx$
］を中止する`~db~taskを~queueする$モノトスル。
◎
The index that is requested to be created can contain constraints on the data allowed in the index’s referenced object store, such as requiring uniqueness of the values referenced by the index’s key path. If the referenced object store already contains data which violates these constraints, this must not cause the implementation of createIndex() to throw an exception or affect what it returns. The implementation must still create and return an IDBIndex object, and the implementation must queue a database task to abort the upgrade transaction which was used for the createIndex() call.
</p>

<p>
この~methodは、
コレ上の `indexNames$m ~propを同期的に改変する。
この~methodは `IDBRequest$I ~objを返さないが、
索引の作成~自体は，`昇格~tx$の中の非同期的な要請として，処理される。
◎
This method synchronously modifies the indexNames property on the IDBObjectStore instance on which it was called. Although this method does not return an IDBRequest object, the index creation itself is processed as an asynchronous request within the upgrade transaction.
</p>

<p>
実装によっては、
この~methodが`索引~handle$（ `IDBIndex^I ~obj）を返した後，`索引$を非同期に作成するときに，問題になる可能性がある。
例えば、［
新たに作成された索引の~metadataを~dbに挿入する~taskを~queueする所
］，あるいは［
~quota事由から，利用者に許可を依頼する必要があり得る所
］で。
そのような場合でも，実装は：
◎
In some implementations it is possible for the implementation to asynchronously run into problems creating the index after the createIndex method has returned. For example in implementations where metadata about the newly created index is queued up to be inserted into the database asynchronously, or where the implementation might need to ask the user for permission for quota reasons. Such implementations＼
</p>
		<ul>
			<li>
`索引~handle$を作成して返すモノトスル。
◎
must still create and return an IDBIndex object,＼
</li>
			<li>
<p>
加えて，`索引$の作成ngに失敗したときは、
次を走らすモノトスル
⇒
`~txを中止する$( コレ, 失敗の事由に適切な~error~obj† )
◎
and once the implementation determines that creating the index has failed, it must run the steps to abort a transaction using an appropriate error.＼
</p>

<div>
<p>†
例えば、
次を利用するモノトスル：
</p>
<ul>
	<li>
~quota事由に因り，`索引$の作成ngに失敗した場合
⇒
`QuotaExceededError$I
</li>
	<li>
［
`一意か$Ix ~EQ ~T
］の拘束に因り，索引を作成できない場合
⇒
`ConstraintError$E 例外
</li>
</ul>
◎
For example if creating the index failed due to quota reasons, a QuotaExceededError must be used as error and if the index can’t be created due to unique flag constraints, a "ConstraintError" DOMException must be used as error.
</div>
			</li>
		</ul>

<div class="example" id="example-async-index-creation">
<p>
索引の非同期的な作成は、
次の例のように観測できる：
◎
The asynchronous creation of indexes is observable in the following example:
</p>

<pre class="lang-js">
const %request1 = objectStore.put({name: `betty^l}, `1^lt);
const %request2 = objectStore.put({name: `betty^l}, `2^lt);
const %index = objectStore.createIndex(`by_name^l, `name^l, {unique: true});
</pre>

<p>
`createIndex()^m が~callされた時点では，いずれの`要請$もまだ実行されていない。
2 番目の要請が実行されるとき，同じ `name^js ~propを`値$に有する`~record$が重複して作成される。
索引の作成は非同期的な`要請$と見なされ、
索引の［
`一意か$Ix ~EQ ~T
］による拘束は， 2 番目の`要請$を失敗させないので。
代わりに，`~tx$は、
索引の作成-時に，拘束を満たせないため`中止-$されることになる。
◎
At the point where createIndex() called, neither of the requests have executed. When the second request executes, a duplicate name is created. Since the index creation is considered an asynchronous request, the index’s uniqueness constraint does not cause the second request to fail. Instead, the transaction will be aborted when the index is created and the constraint fails.
</p>
</div>
</div>

<div class="algo">
<p>
`index(name)@m
~method手続きは：
◎
The index(name) method steps are:
</p>
<ol>
	<li>
~IF［
コレ↗は削除されている
］
⇒
~THROW `InvalidStateError$E
◎
Let transaction be this’s transaction.
◎
Let store be this’s object store.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF
コレが`専属する$`~tx$の`状態$tx ~EQ `完遂d$i
⇒
~THROW `InvalidStateError$E
◎
If transaction’s state is finished, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%索引 ~LET コレの`索引~集合$OsH 内の`索引$のうち，次を満たすもの
⇒
`名前$Ix ~EQ %name
◎
Let index be the index named name in this’s index set if one exists,＼
</li>
	<li>
~IF［
%索引 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
or throw a "NotFoundError" DOMException otherwise.
</li>
	<li>
~RET 次を満たすような`索引~handle$ %H
⇒＃
%H↗ ~EQ %索引,
%H はコレに`専属する$,
`一意性$の要件を満たす
◎終
（`可換性$の要件は、`索引~集合$OsHの構成から自動的に満たされる）
◎
Return an index handle associated with index and this.
</li>
</ol>

<p class="note">注記：
`一意性$の要件から，返される~instanceは一意に定まる
【~instanceがその前のどの時点で作成されるかは，実装の詳細~になる】
。
よって、
`昇格~tx$の間を除き、
同じ `IDBObjectStore$I ~instance上で，同じ %name をこの~methodに渡して返される `IDBIndex$I ~instanceは、
常に同じになる。
◎
NOTE: Each call to this method on the same IDBObjectStore instance with the same name returns the same IDBIndex instance.
</p>

<p class="note">注記：
%H はコレに`専属する$ので、
他の `IDBObjectStore$I ~instanceに対し同じ %name で この~methodを呼出しても， %H と異なる `IDBIndex$I ~instanceが返される。
◎
NOTE: The returned IDBIndex instance is specific to this IDBObjectStore instance. If this method is called on a different IDBObjectStore instance with the same name, a different IDBIndex instance is returned.
</p>
</div>

<div class="algo">
<p>
`deleteIndex(name)@m
~method手続きは：
◎
The deleteIndex(name) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `versionchange^l ) ？
◎
Let transaction be this’s transaction.
◎
Let store be this’s object store.
◎
If transaction is not an upgrade transaction, throw an "InvalidStateError" DOMException.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%索引 ~LET コレ↗に`専属する$`索引$のうち，次を満たすもの
⇒
`名前$Ix ~EQ %name
◎
Let index be the index named name in store if one exists,＼
</li>
	<li>
~IF［
%索引 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
or throw a "NotFoundError" DOMException otherwise.
</li>
	<li>
コレの`索引~集合$OsHから %索引 を除去する
◎
Remove index from this’s index set.
</li>
	<li>
%索引 を破壊する
◎
Destroy index.
</li>
</ol>

<p>
この~methodは、
コレ↗に専属する，名前 %name の`索引$を破壊する。
この~methodを~callできるのは、
`昇格~txの中$からに限られることに注意。
◎
This method destroys the index with the given name in the object store. Note that this method must only be called from within an upgrade transaction.
</p>

<p>
この~methodは、
コレ上の
`indexNames$m
属性を同期的に改変する。
この~methodは `IDBRequest$I ~objを返さないが、
索引の破壊~自体は，`昇格~tx$の中で非同期的な要請として処理される。
◎
This method synchronously modifies the indexNames property on the IDBObjectStore instance on which it was called. Although this method does not return an IDBRequest object, the index destruction itself is processed as an asynchronous request within the upgrade transaction.
</p>
</div>

		</section>
		<section id="index-interface">
<h3 title="The IDBIndex interface">4.6. `IDBIndex^I ~interface</h3>

<p>
`IDBIndex$I ~interfaceは、
`索引~handle$を表現する。
◎
The IDBIndex interface represents an index handle.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBIndex@I {
  attribute `DOMString$ `name$m;
  [`SameObject$] readonly attribute `IDBObjectStore$I `objectStore$m;
  readonly attribute `any$ `keyPath$m;
  readonly attribute `boolean$ `multiEntry$m;
  readonly attribute `boolean$ `unique$m;

  [`NewObject$] `IDBRequest$I `get$m(
      `any$ %query
  );
  [`NewObject$] `IDBRequest$I `getKey$m(
      `any$ %query
  );
  [`NewObject$] `IDBRequest$I `getAll$m(
      optional `any$ %queryOrOptions,
      optional [`EnforceRange$] `unsigned long$ %count
  );
  [`NewObject$] `IDBRequest$I `getAllKeys$m(
      optional `any$ %queryOrOptions,
      optional [`EnforceRange$] `unsigned long$ %count
  );
  [`NewObject$] `IDBRequest$I `getAllRecords$m(
      optional `IDBGetAllOptions$I %options = {}
  );
  [`NewObject$] `IDBRequest$I `count$m(
      optional `any$ %query
  );

  [`NewObject$] `IDBRequest$I `openCursor$m(
      optional `any$ %query,
      optional `IDBCursorDirection$I %direction = "next"
  );
  [`NewObject$] `IDBRequest$I `openKeyCursor$m(
      optional `any$ %query,
      optional `IDBCursorDirection$I %direction = "next"
  );
};
</pre>

<dl class="domintro">
	<dt>%index . `name$m</dt>
	<dd>
%index↗ の`名前$Ixを返す。
◎
Returns the name of the index.
</dd>

	<dt>%index . `name$m = %newName</dt>
	<dd>
%index↗ の`名前$Ixを %newName に更新する。
◎
Updates the name of the store to newName.
</dd>
	<dd>
`昇格~txの外$で~callされた場合、
`InvalidStateError$E 例外が投出される。
◎
Throws an "InvalidStateError" DOMException if not called within an upgrade transaction.
</dd>

	<dt>%index . `objectStore$m</dt>
	<dd>
%index が`専属する$`保管庫~handle$（ `IDBObjectStore$I ）を返す。
◎
Returns the IDBObjectStore the index belongs to.
</dd>

	<dt>%index . `keyPath$m</dt>
	<dd>
%index↗ の`~key~path$Ixを返す。
◎
Returns the key path of the index.
</dd>

	<dt>%index . `multiEntry$m</dt>
	<dd>
%index↗ の`複-~entryか$Ixを返す。
◎
Returns true if the index’s multiEntry flag is true.
</dd>

	<dt>%index . `unique$m</dt>
	<dd>
%index↗ の`一意か$Ixを返す。
◎
Returns true if the index’s unique flag is true.
</dd>
</dl>

<div class="algo">
<p>
`name@m
取得子~手続きは
⇒
~RET コレの`名前$IxH
◎
The name getter steps are to return this’s name.
</p>

<p class="note">注記：
コレが`専属する$~txが`完遂-$していない限り、
返される値はコレ↗の`名前$Ixと同じになり、
それ以降も同じ`値を保ち続ける$。
【！ deitails 】
◎
Is this the same as the index’s name?
◎
As long as the transaction has not finished, this is the same as the associated index’s name. But once the transaction has finished, this attribute will not reflect changes made with a later upgrade transaction.
</p>
</div>

<div class="algo">
<p>
`name$m 設定子~手続きは：
◎
The name setter steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `versionchange^l ) ？
◎
Let name be the given value.
◎
Let transaction be this’s transaction.
◎
Let index be this’s index.
◎
If transaction is not an upgrade transaction, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
変則＊
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
%name ~LET `所与の値$
◎
↑</li>
	<li>
~IF［
コレの`名前$IxH ~EQ %name
］
⇒
~RET
◎
If index’s name is equal to name, terminate these steps.
</li>
	<li>
コレが`専属する$`保管庫~handle$の`索引~集合$OsHを成す
~EACH( %索引 )
に対し
⇒
~IF［
%索引 の`名前$Ix ~EQ %name
］
⇒
~THROW `ConstraintError$E
◎
If an index named name already exists in index’s object store, throw a "ConstraintError" DOMException.
</li>
	<li>
コレ↗の`名前$Ix ~SET %name
◎
Set index’s name to name.
</li>
	<li>
コレの`名前$IxH ~SET %name
◎
Set this’s name to name.
</li>
</ol>
</div>

<div class="algo">
`objectStore@m
取得子~手続きは
⇒
~RET コレが`専属する$`保管庫~handle$
◎
The objectStore getter steps are to return this’s object store handle.
</div>

<div class="algo">
<p>
`keyPath@m
取得子~手続きは
⇒
~RET コレ↗の`~key~path$Ix %P を `WEBIDL$r に従って，次の型として変換した結果
⇒＃
%P は文字列であるならば `DOMString$I ／
%P は文字列たちが成す~listであるならば `~SeqDS$
◎
The keyPath getter steps are to return this’s index’s key path. The key path is converted as a DOMString (if a string) or a sequence&lt;DOMString&gt; (if a list of strings), per [WEBIDL].
</p>

<p>
【この属性は、`値を保ち続ける$。】
</p>

<p class="note">注記：
返される値は、
コレの作成-時に利用した~instanceと同じではない。
しかしながら，この属性が~obj（特定的には `Array$jT ）を返す場合、
毎回~同じ~instanceを返す。
返された~objの~prop値を変更しても，コレに効果を及ぼすことはない。
◎
NOTE: The returned value is not the same instance that was used when the index was created. However, if this attribute returns an object (specifically an Array), it returns the same object instance every time it is inspected. Changing the properties of the object has no effect on the index.
</div>

<div class="algo">
<p>
`multiEntry@m
取得子~手続きは
⇒
~RET コレ↗の`複-~entryか$Ix
◎
The multiEntry getter steps are to return this’s index’s multiEntry flag.
</p>

<p>
【この属性は、`値を保ち続ける$。】
</p>
</div>

<div class="algo">
<p>
`unique@m
取得子~手続きは
⇒
~RET コレ↗の`一意か$Ix
◎
The unique getter steps are to return this’s index’s unique flag.
</p>

<p>
【この属性は、`値を保ち続ける$。】
</p>
</div>

<p class="note">注記：
以下に挙げる~methodは、
`~tx$が `作動中$i でないときに~callされた場合は
`TransactionInactiveError$E を投出する。
◎
The following methods throw an "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl class="domintro">
	<dt>%request = %index . `get(query)$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$に入る`~record$たち
］のうち，最初の~recordの`参照先~record$の`値$を検索取得するよう要請する。
◎
Retrieves the value of the first record matching the given key or key range in query.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
該当する~recordが［
在るならば 得られた値／
無いならば `undefined^jv
］になる。
◎
If successful, request’s result will be the value, or undefined if there was no matching record.
</dd>

	<dt>%request = %index . `getKey(query)$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$に入る`~record$たち
］のうち，最初の~recordの値
— すなわち，`参照先~record$の`~key$ —
を検索取得するよう要請する。
◎
Retrieves the key of the first record matching the given key or key range in query.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
該当する~recordが［
在るならば 得られた`~key$ ／
無いならば `undefined^jv
］になる。
◎
If successful, request’s result will be the key, or undefined if there was no matching record.
</dd>

	<dt>%request = %index . `getAll(query [, count])$m</dt>
	<dt>%request = %index . `getAll({query, count, direction})$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$に入る`~record$たち
］のうち，
最初から %count 個までの~recordの`参照先~record$の`値$を検索取得するよう要請する
— %direction が［
`next$l ／ `prev$l ／ `nextunique$l ／ `prevunique$l
］に設定された場合は［
最初／最後／最初／最後
］から検索取得するようになり，［
`nextunique$l ／ `prevunique$l
］に設定された場合は［
~keyが重複する~recordのうち［
`~record~list$Ix内で最初のもの
］以外を除外する
］ようになる。
◎
Retrieves the values of the records matching the given key or key range in query (up to count if given).＼
Set the direction option to "next" to retrieve the first count values, "prev" to return the last count values.＼
Set the direction option to "nextunique" or "prevunique" to exclude records with duplicate index keys after retrieving the first record with the duplicate index key.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
`値$たちが成す `Array$jT になる。
◎
If successful, request’s result will be an Array of the values.
</dd>

	<dt>%request = %index . `getAllKeys(query [, count])$m</dt>
	<dt>%request = %index . `getAllKeys({query, count, direction})$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$に入る`~record$たち
］のうち，
最初から %count 個までの~recordの`値$（すなわち，`参照先~record$の`~key$）を検索取得するよう要請する
— %direction が［
`next$l ／ `prev$l ／ `nextunique$l ／ `prevunique$l
］に設定された場合は［
最初／最後／最初／最後
］から検索取得するようになり，［
`nextunique$l ／ `prevunique$l
］に設定された場合は［
~keyが重複する~recordのうち［
`~record~list$Ix内で最初のもの
］以外を除外する
］ようになる。
◎
Retrieves the keys of records matching the given key or key range in query (up to count if given).＼
Set the direction option to "next" to retrieve the first count keys, "prev" to return the last count keys. Set the direction option to "nextunique" or "prevunique" to exclude records with duplicate index keys after retrieving the first record with the duplicate index key.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
`~key$たちが成す `Array$jT になる。
◎
If successful, request’s result will be an Array of the keys.
</dd>

	<dt>%request = %index . `getAllRecords({query, count, direction})$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$に入る`~record$たち
］のうち，
最初から %count 個までの~recordの［
`~key$, `参照先~record$の`~key$, `参照先~record$の`値$
］を検索取得するよう要請する
— %direction が［
`next$l ／ `prev$l ／ `nextunique$l ／ `prevunique$l
］に設定された場合は［
最初／最後／最初／最後
］から検索取得するようになり，［
`nextunique$l ／ `prevunique$l
］に設定された場合は［
~keyが重複する~recordのうち［
`~record~list$Ix内で最初のもの
］以外を除外する
］ようになる。
◎
Retrieves the keys, values, and index keys of records.
◎
The query option specifies a key or key range to match. The count option limits the number of records matched. Set the direction option to "next" to retrieve the first count records, "prev" to return the last count records. Set the direction option to "nextunique" or "prevunique" to exclude records with duplicate index keys after retrieving the first record with the duplicate index key.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
`IDBRecord!I たちが成す `Array$jT になる。
それらの［
`key$m ／ `primaryKey$m
］が，~recordの［
`~key$／`参照先~record$の`~key$
］を与える。
<!-- `IDBIndex!I -->
◎
If successful, request’s result will be an Array, with each member being an IDBRecord. Use the IDBRecord’s key to get the record’s index key. Use the IDBRecord’s primaryKey to get the record’s key.
</dd>

	<dt>%request = %index . `count(query)$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$に入る`~record$たち
］の総数を得るよう要請する。
◎
Retrieves the number of records matching the given key or key range in query.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
得られた総数になる。
◎
If successful, request’s result will be the count.
</dd>
</dl>

<div class="algo">
<p>
`get(query)@m
~method手続きは：
◎
The get(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
Let index be this’s index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `~key範囲へ変換する$( %query, `~NULL不可^i ) ？
◎
Let range be the result of converting a value to a key range with query and true. Rethrow any exceptions.
</li>
	<li>
<p>
~RET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`範囲に入る最初の~entryを検索取得する$( `現在の~realm$, コレ↗, %範囲, `値^i )
</div>
◎
Let operation be an algorithm to run retrieve a referenced value from an index with the current Realm record, index, and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、［
`~key$／`~key範囲$
］をとり得る
— それにより識別される`~record$
（範囲が指定された場合、
範囲に入る最初の既存の~record）
の`値$が検索取得される。
◎
NOTE: The query parameter can be a key or key range (an IDBKeyRange) identifying the referenced value to be retrieved. If a range is specified, the method retrieves the first existing record in that range.
</p>

<p class="note">注記：
`IDBObjectStore.get()$m の注記にて述べたことが，この~methodにも該当する。
◎
NOTE: This method produces the same result if a record with the given key doesn’t exist as when a record exists, but has undefined as value. If you need to tell the two situations apart, you can use openCursor() with the same key. This will return a cursor with undefined as value if a record exists, or no cursor if no such record exists.
</p>
</div>

<div class="algo">
<p>
`getKey(query)@m
~method手続きは：
◎
The getKey(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
Let index be this’s index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `~key範囲へ変換する$( %query, `~NULL不可^i ) ？
◎
Let range be the result of converting a value to a key range with query and true. Rethrow any exceptions.
</li>
	<li>
<p>
~RET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`範囲に入る最初の~entryを検索取得する$( `現在の~realm$, コレ↗, %範囲, `~key^i )
</div>
◎
Let operation be an algorithm to run retrieve a value from an index with index and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、［
`~key$／`~key範囲$
］をとり得る
— それにより識別される`~record$
（範囲が指定された場合、
範囲に入る最初の既存の~record）
の`~key$が検索取得される。
◎
NOTE: The query parameter can be a key or key range (an IDBKeyRange) identifying the record key to be retrieved. If a range is specified, the method retrieves the first existing key in that range.
</p>
</div>

<div class="algo">
<p>
`getAll(queryOrOptions, count)@m
~method手続きは：
◎
The getAll(queryOrOptions, count) method steps are:
</p>
<ol>
	<li>
~RET `複数個の~itemを検索取得する要請を作成する$( ↓ ) ？
⇒＃
`現在の~realm$,
コレ,
`値^i,
%queryOrOptions,
%count
◎
Return the result of creating a request to retrieve multiple items with the current Realm record, this, "value", queryOrOptions, and count if given. Rethrow any exceptions.
</li>
</ol>

<p class="advisement">🚧
%queryOrOptions 引数~用の `IDBGetAllOptions$I は、
`この版$において新たに導入された。
［
Chrome 141, Edge 141
］から~supportされている。
🚧
◎
🚧 The IDBGetAllOptions argument for getAll() is new in this edition. It is supported in Chrome 141, and Edge 141. 🚧
</p>
</div>

<div class="algo">
<p>
`getAllKeys(queryOrOptions, count)@m
~method手続きは：
◎
The getAllKeys(queryOrOptions, count) method steps are:
</p>
<ol>
	<li>
~RET `複数個の~itemを検索取得する要請を作成する$( ↓ ) ？
⇒＃
`現在の~realm$,
コレ,
`~key^i,
%queryOrOptions,
%count
◎
Return the result of creating a request to retrieve multiple items with the current Realm record, this, "key", queryOrOptions, and count if given. Rethrow any exceptions.
</li>
</ol>

<p class="advisement">🚧
%queryOrOptions 引数~用の `IDBGetAllOptions$I は、
`この版$において新たに導入された。
［
Chrome 141, Edge 141
］から~supportされている。
🚧
◎
🚧 The IDBGetAllOptions argument for getAllKeys() is new in this edition. It is supported in Chrome 141, and Edge 141. 🚧
</p>
</div>

<div class="algo">
<p>
`getAllRecords(options)@m
~method手続きは：
◎
The getAllRecords(options) method steps are:
</p>
<ol>
	<li>
~RET 
`複数個の~itemを検索取得する要請を作成する$( ↓ ) ？
⇒＃
`現在の~realm$,
コレ,
`~record^i,
%options
◎
Return the result of creating a request to retrieve multiple items with the current Realm record, this, "record", and options. Rethrow any exceptions.
</li>
</ol>

<p class="advisement">🚧
この~methodは、
`この版$において新たに導入された。
［
Chrome 141, Edge 141
］から~supportされている。
🚧
◎
🚧 The getAllRecords() method is new in this edition. It is supported in Chrome 141, and Edge 141. 🚧
</p>
</div>

<div class="algo">
<p>
`count(query)@m
~method手続きは：
◎
The count(query) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
Let index be this’s index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `~key範囲へ変換する$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
<p>
~RET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`範囲に入る~recordを数える$( コレ↗, %範囲 )
</div>
◎
Let operation be an algorithm to run count the records in a range with index and range.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、［
`~key$／`~key範囲$
］をとり得る
— それにより識別される`~record$たちが数えられる。
~NULL または省略時には，`全範囲$が利用される。
◎
NOTE: The query parameter can be a key or key range (an IDBKeyRange) identifying the records to be counted. If null or not given, an unbounded key range is used.
</p>
</div>

<p class="note">注記：
以下に挙げる~methodは、
`~tx$が `作動中$i でないときに~callされた場合は
`TransactionInactiveError$E を投出する。
◎
The following methods throw an "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl class="domintro">
	<dt>%request = %index . `openCursor([query [, direction = "next"]])$m</dt>
	<dd>
%index↗ の`~record~list$Os内の［
%query が`表現する~key範囲$（ %query が~NULL ならば`全範囲$）に入る`~record$たち
］を［
`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
◎
Opens a cursor over the records matching query, ordered by direction. If query is null, all records in index are matched.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
範囲に入る~recordが［
在るならば 反復-順で最初の~recordを指している `IDBCursorWithValue$I ／
無いならば ~NULL
］になる。
◎
If successful, request’s result will be an IDBCursorWithValue, or null if there were no matching records.
</dd>

	<dt>%request = %index . `openKeyCursor([query [, direction = "next"]])$m</dt>
	<dd>
%index↗ の`~record~list$Ix内の［
%query が`表現する~key範囲$（ %query が~NULL ならば`全範囲$）に入る`~record$たち
］を［
`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
作成される`~cursor$の`~keyのみか$Csは ~T になる
（~cursorは、
~recordの~keyのみを取得する）。
◎
Opens a cursor with key only flag set to true over the records matching query, ordered by direction. If query is null, all records in index are matched.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
範囲に入る~recordが［
在るならば 反復-順で最初の~recordを指している `IDBCursor$I ／
無いならば ~NULL
］になる。
◎
If successful, request’s result will be an IDBCursor, or null if there were no matching records.
</dd>
</dl>

<div class="algo">
<p>
`openCursor(query, direction)@m
~method手続きは：
◎
The openCursor(query, direction) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
Let index be this’s index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `~key範囲へ変換する$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
<p>
%要請 ~LET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~cursorを作成する$( `現在の~realm$, コレ, %direction, %範囲 )
</div>
◎
Let cursor be a new cursor with its source handle set to this, undefined position, direction set to direction, got value flag set to false, undefined key and value, range set to range, and key only flag set to false.
◎
Let operation be an algorithm to run iterate a cursor with the current Realm record and cursor.
◎
Let request be the result of running asynchronously execute a request with this and operation.
</li>
	<li>
コレの`要請$Cs ~SET %要請
◎
Set cursor’s request to request.
</li>
	<li>
~RET %要請
◎
Return request.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
`~cursor$の`範囲$Csとして利用する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
NOTE: The query parameter can be a key or key range (an IDBKeyRange) to use as the cursor’s range. If null or not given, an unbounded key range is used.
</p>
</div>

<div class="algo">
<p>
`openKeyCursor(query, direction)@m
~method手続きは：
◎
The openKeyCursor(query, direction) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
Let index be this’s index.
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%範囲 ~LET `~key範囲へ変換する$( %query ) ？
◎
Let range be the result of converting a value to a key range with query. Rethrow any exceptions.
</li>
	<li>
<p>
%要請 ~LET `要請を非同期に実行する$( コレ, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~cursorを作成する$( `現在の~realm$, コレ, %direction, %範囲, `~keyのみ^i )
</div>
◎
Let cursor be a new cursor with its source handle set to this, undefined position, direction set to direction, got value flag set to false, undefined key and value, range set to range, and key only flag set to true.
◎
Let operation be an algorithm to run iterate a cursor with the current Realm record and cursor.
◎
Let request be the result of running asynchronously execute a request with this and operation.
</li>
	<li>
コレの`要請$Cs ~SET %要請
◎
Set cursor’s request to request.
</li>
	<li>
~RET %要請
◎
Return request.
</li>
</ol>

<p class="note">注記：
%query ~parameterは、
`~cursor$の`範囲$Csとして利用する［
`~key$／`~key範囲$
］をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
NOTE: The query parameter can be a key or key range (an IDBKeyRange) to use as the cursor’s range. If null or not given, an unbounded key range is used.
</p>
</div>

		</section>
		<section id="keyrange">
<h3 title="The IDBKeyRange interface">4.7. `IDBKeyRange^I ~interface</h3>

<p>
`IDBKeyRange$I ~interfaceは、
`~key範囲$を表現する。
◎
The IDBKeyRange interface represents a key range.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBKeyRange@I {
  readonly attribute `any$ `lower$m;
  readonly attribute `any$ `upper$m;
  readonly attribute `boolean$ `lowerOpen$m;
  readonly attribute `boolean$ `upperOpen$m;

  // <span class="comment" title="Static construction methods">静的~構築~method：</span>
  [`NewObject$] static `IDBKeyRange$I `only$m(
      `any$ %value
  );
  [`NewObject$] static `IDBKeyRange$I `lowerBound$m(
      `any$ %lower,
      optional `boolean$ %open = false
  );
  [`NewObject$] static `IDBKeyRange$I `upperBound$m(
      `any$ %upper,
      optional `boolean$ %open = false
  );
  [`NewObject$] static `IDBKeyRange$I `bound$m(
      `any$ %lower,
      `any$ %upper,
      optional `boolean$ %lowerOpen = false,
      optional `boolean$ %upperOpen = false
  );

  `boolean$ `includes$m(`any$ %key);
};
</pre>

<dl class="domintro">
	<dt>%range . `lower$m</dt>
	<dd>
この範囲の`下界$が［
あれば それ ／
なければ `undefined^jv
］を返す。
◎
Returns the range’s lower bound, or undefined if none.
</dd>

	<dt>%range . `upper$m</dt>
	<dd>
この範囲の`上界$が［
あれば それ ／
なければ `undefined^jv
］を返す。
◎
Returns the range’s upper bound, or undefined if none.
</dd>

	<dt>%range . `lowerOpen$m</dt>
	<dd>
この範囲の`下界openか$を返す。
◎
Returns the range’s lower open flag.
</dd>

	<dt>%range . `upperOpen$m</dt>
	<dd>
この範囲の`上界openか$を返す。
◎
Returns the range’s upper open flag.
</dd>
</dl>

<div class="algo">
`lower@m
取得子~手続きは
⇒
~RET `Value$( コレの`下界$ )
◎
The lower getter steps are to return the result of converting a key to a value with this’s lower bound if it is not null, or undefined otherwise.
</div>

<div class="algo">
`upper@m
取得子~手続きは
⇒
~RET `Value$( コレの`上界$ )
◎
The upper getter steps are to return the result of converting a key to a value with this’s upper bound if it is not null, or undefined otherwise.
</div>

<div class="algo">
`lowerOpen@m
取得子~手続きは
⇒
~RET コレの`下界openか$
◎
The lowerOpen getter steps are to return this’s lower open flag.
</div>

<div class="algo">
`upperOpen@m
取得子~手続きは
⇒
~RET コレの`上界openか$
◎
The upperOpen getter steps are to return this’s upper open flag.
</div>

<dl class="domintro">
	<dt>%range = `IDBKeyRange$I . `only(key)$m</dt>
	<dd>
%value のみを含む，新たな `IDBKeyRange$I （ `~key範囲$ ）を返す。
◎
Returns a new IDBKeyRange spanning only key.
</dd>

	<dt>%range = `IDBKeyRange$I . `lowerBound(lower [, open = false])$m</dt>
	<dd>
`下界$ %lower から開始され, `上界$のない，新たな `IDBKeyRange$I を返す。
%open が ~T の場合、
%lower はこの範囲に含まれない。
◎
Returns a new IDBKeyRange starting at key with no upper bound. If open is true, key is not included in the range.
</dd>

	<dt>%range = `IDBKeyRange$I . `upperBound(upper [, open = false])$m</dt>
	<dd>
`下界$のない, `上界$ %upper で終端する，新たな `IDBKeyRange$I を返す。
%open が ~T の場合、
%upper はこの範囲に含まれない。
◎
Returns a new IDBKeyRange with no lower bound and ending at key. If open is true, key is not included in the range.
</dd>

	<dt>%range = `IDBKeyRange$I . `bound(lower, upper [, lowerOpen = false [, upperOpen = false]])$m</dt>
	<dd>
`下界$ %lower から `上界$ %upper までにわたる，新たな `IDBKeyRange$I を返す。
%lowerOpen が ~T の場合、
%lower はこの範囲に含まれない。
%upperOpen が ~T の場合、
%upper はこの範囲に含まれない。
◎
Returns a new IDBKeyRange spanning from lower to upper. If lowerOpen is true, lower is not included in the range. If upperOpen is true, upper is not included in the range.
</dd>
	<dd class="trans-note">【
［
%lower ／ %upper
］に対する `undefined^jv は、
許容されない
（省略可能でないので）。
したがって，［
`下界$ ／`上界$
］のない`~key範囲$を作成するためには、
他の~methodを利用する必要がある。
`全範囲$を表現する `IDBKeyRange^I ~objは 作成できないが、
<code>`lowerBound$m(`-Infinity^jv)</code>
により，実質的に等価なものは作成できる。
また、
他の各種~API~methodの引数のうち，`~key範囲$を期待するもの
（この仕様の~IDLで %query と記される引数）は、
（省略可能ならば）省略した場合には`全範囲$に解釈される。
】</dd>
</dl>

<div class="algo">
<p>
`only(value)@m
~method手続きは：
◎
The only(value) method steps are:
</p>
<ol>
	<li>
%~key ~LET `Key$( %value ) ？
◎
Let key be the result of converting a value to a key with value. Rethrow any exceptions.
If key is "invalid value" or "invalid type", throw a "DataError" DOMException.
</li>
	<li>
~RET `~keyのみを包含する範囲$( %~key )
◎
Create and return a new key range containing only key.
</li>
</ol>
</div>

<div class="algo">
<p>
`lowerBound(lower, open)@m
~method手続きは：
◎
The lowerBound(lower, lowerOpen) method steps are:
</p>
<ol>
	<li>
%lowerKey ~LET `Key$( %lower ) ？
【！ invalid → "invalid value" or "invalid type" 】
◎
Let lowerKey be the result of converting a value to a key with lower. Rethrow any exceptions.
◎
If lowerKey is invalid, throw a "DataError" DOMException.
</li>
	<li>
~RET 新たな`~key範囲$
— その
⇒＃
`下界$ ~SET %lowerKey,
`下界openか$ ~SET %open,
`上界$ ~SET ε,
`上界openか$ ~SET ~T
◎
Create and return a new key range with lower bound set to lowerKey, lower open flag set to open, upper bound set to null, and upper open flag set to true.
</li>
</ol>
</div>

<div class="algo">
<p>
`upperBound(upper, open)@m
~method手続きは：
◎
The upperBound(upper, open) method steps are:
</p>
<ol>
	<li>
%upperKey ~LET `Key$( %upper ) ？
◎
Let upperKey be the result of converting a value to a key with upper. Rethrow any exceptions.
◎
If upperKey is "invalid value" or "invalid type", throw a "DataError" DOMException.
</li>
	<li>
~RET 新たな`~key範囲$
— その
⇒＃
`下界$ ~SET ε,
`下界openか$ ~SET ~T,
`上界$ ~SET %upperKey,
`上界openか$ ~SET %open
◎
Create and return a new key range with lower bound set to null, lower open flag set to true, upper bound set to upperKey, and upper open flag set to open.
</li>
</ol>
</div>

<div class="algo">
<p>
`bound(lower, upper, lowerOpen, upperOpen)@m
~method手続きは：
◎
The bound(lower, upper, lowerOpen, upperOpen) method steps are:
</p>
<ol>
	<li>
%lowerKey ~LET `Key$( %lower ) ？
◎
Let lowerKey be the result of converting a value to a key with lower. Rethrow any exceptions.
◎
If lowerKey is "invalid value" or "invalid type", throw a "DataError" DOMException.
</li>
	<li>
%upperKey ~LET `Key$( %upper ) ？
◎
Let upperKey be the result of converting a value to a key with upper. Rethrow any exceptions.
◎
If upperKey is "invalid value" or "invalid type", throw a "DataError" DOMException.
</li>
	<li>
~IF［
%lower ~GT~cmpkey %upper
］
⇒
~THROW `DataError$E
◎
If lowerKey is greater than upperKey, throw a "DataError" DOMException.
</li>
	<li>
~RET 新たな`~key範囲$
— その
⇒＃
`下界$ ~SET %lowerKey,
`下界openか$ ~SET %lowerOpen,
`上界$ ~SET %upperKey,
`上界openか$ ~SET %upperOpen
◎
Create and return a new key range with lower bound set to lowerKey, lower open flag set to lowerOpen, upper bound set to upperKey and upper open flag set to upperOpen.
</li>
</ol>
</div>

<dl class="domintro">
	<dt>%range . `includes(key)$m</dt>
	<dd>
［
%key が %range に`入る$ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if key is included in the range, and false otherwise.
</dd>
</dl>

<div class="algo">
<p>
`includes(key)@m
~method手続きは：
◎
The includes(key) method steps are:
</p>
<ol>
	<li>
%key ~LET `Key$( %key ) ？
◎
Let k be the result of converting a value to a key with key. Rethrow any exceptions.
◎
If k is "invalid value" or "invalid type", throw a "DataError" DOMException.
</li>
	<li>
~RET ~IS［
%key ~IN~cmpkey コレ
］
◎
Return true if k is in this range, and false otherwise.
</li>
</ol>
</div>

		</section>
		<section id="record-interface">
<h3 title="The IDBRecord interface">4.8. `IDBRecord$I ~interface</h3>

<p>
`IDBRecord$I ~interfaceは、
ある`~record~snapshot$を表現する。
◎
The IDBRecord interface represents a record snapshot.
</p>

<pre class="idl">[`Exposed$=(Window,Worker)]
interface `IDBRecord@I {
  readonly attribute `any$ `key$m;
  readonly attribute `any$ `primaryKey$m;
  readonly attribute `any$ `value$m;
};
</pre>

<dl class="domintro">
	<dt>%record . `key$m</dt>
	<dd>
%record の`~key$を返す。
◎
Returns the record’s key.
</dd>

	<dt>%record . `primaryKey$m</dt>
	<dd>
%record は`索引$から検索取得されたものであったならば、
その`参照先~record$の`~key$を返す。
◎
If the record was retrieved from an index, returns the key of the record in the index’s referenced object store.
</dd>
	<dd>
%record は`保管庫$から検索取得されたものであったならば
%record の`~key$を返す
— それは、
%record .`key$m と同じになる。
◎
If the record was retrieved from an object store, returns the record’s key, which is the same key as record.key.
</dd>

	<dt>%record . `value$m</dt>
	<dd>
%record の`値$を返す。
◎
Returns the record’s value.
</dd>
</dl>

<div class="algo">
`key@m
取得子~手続きは
⇒
~RET `~keyを値に変換する$( コレの`~key$rS )
◎
The key getter steps are to return the result of converting a key to a value with this’s key.
</div>

<div class="algo">
`primaryKey@m
取得子~手続きは
⇒
~RET `~keyを値に変換する$( コレの`首key$rS )
◎
The primaryKey getter steps are to return the result of converting a key to a value with this’s primary key.
</div>

<div class="algo">
`value@m
取得子~手続きは
⇒
~RET コレの`値$rS
◎
The value getter steps are to return this’s value.
</div>

		</section>
		<section id="cursor-interface">
<h3 title="The IDBCursor interface">4.9. `IDBCursor^I ~interface</h3>

<p>
`~cursor$~objは、
`IDBCursor$I ~interfaceを実装する。
所与の`~cursor$を表現するような `IDBCursor$I ~instanceは，唯一つに限られるが、
同時に利用できる~cursorの~~総数に上限は無い。
◎
Cursor objects implement the IDBCursor interface. There is only ever one IDBCursor instance representing a given cursor. There is no limit on how many cursors can be used at the same time.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBCursor@I {
  readonly attribute (`IDBObjectStore$I or `IDBIndex$I) `source$m;
  readonly attribute `IDBCursorDirection$I `direction$m;
  readonly attribute `any$ `key$m;
  readonly attribute `any$ `primaryKey$m;
  [`SameObject$] readonly attribute `IDBRequest$I `request$m;

  `undefined$ `advance$m(
      [`EnforceRange$] `unsigned long$ %count
  );
  `undefined$ `continue$m(
      optional `any$ %key
  );
  `undefined$ `continuePrimaryKey$m(
      `any$ %key,
      `any$ %primaryKey
  );

  [`NewObject$] `IDBRequest$I `update$m(
      `any$ %value
  );
  [`NewObject$] `IDBRequest$I `delete$m();
};

enum `IDBCursorDirection@I {
  `next$l,
  `nextunique$l,
  `prev$l,
  `prevunique$l
};
</pre>

<!-- `IDBCursor!I -->
<dl class="domintro">
	<dt>%cursor . `source$m</dt>
	<dd>
%cursor の`~source~handle$Cs
（ `IDBObjectStore$I ／ `IDBIndex$I ）
を返す。
◎
Returns the IDBObjectStore or IDBIndex the cursor was opened from.
</dd>

	<dt>%cursor . `direction$m</dt>
	<dd>
%cursor の`方向$Cs
（ `next$l ／ `nextunique$l ／ `prev$l ／ `prevunique$l ）
を返す。
◎
Returns the direction ("next", "nextunique", "prev" or "prevunique") of the cursor.
</dd>

	<dt>%cursor . `key$m</dt>
	<dd>
%cursor の`~key$Csを返す。
◎
Returns the key of the cursor.＼
</dd>
	<dd>
%cursor を進めている間 ／ 反復し終えていた場合、
`InvalidStateError$E が投出される†。
◎
Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished.
</dd>

	<dt>%cursor . `primaryKey$m</dt>
	<dd>
%cursor の`実効~key$Csを返す。
◎
Returns the effective key of the cursor.＼
</dd>
	<dd>
%cursor を進めている間 ／ 反復し終えていた場合、
`InvalidStateError$E が投出される†。
◎
Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished.
</dd>
	<dd class="trans-note">【†
これらの要件は、
下の規範的な~textには述べられていない
（何かの間違い？）。
】</dd>

	<dt>%cursor . `request$m</dt>
	<dd>
%cursor を得するために利用された`要請$Csを返す。
◎
Returns the request that was used to obtain this cursor.
</dd>
</dl>

<div class="algo">
<p>
`source@m
取得子~手続きは
⇒
~RET コレの`~source~handle$Cs
◎
The source getter steps are to return this’s source handle.
</p>

<p class="note">注記：
コレの`~source~handle$Cs %S は、
`コレを作成する＠#_X-new-cursor$よう要請した［
`保管庫~handle$／`索引~handle$
］に初期化され，
それ以降は変化しない
— %S が`専属する$~txが `作動中$i でなくなっても， %S↗ が破壊されても。
◎
NOTE: The source attribute never returns null or throws an exception, even if the cursor is currently being iterated, has iterated past its end, or its transaction is not active.
</p>
</div>

<div class="algo">
`direction@m
取得子~手続きは
⇒
~RET コレの`方向$Cs
◎
The direction getter steps are to return this’s direction.
</div>

<div class="algo">
<p>
`key@m
取得子~手続きは
⇒
~RET `Value$( コレの`~key$Cs )
◎
The key getter steps are to return the result of converting a key to a value with the cursor’s current key.
</p>

<p class="note" id="_key-getter-return-value">注記：
~obj（ `Date$jT や `Array$jT など）を返す場合、
コレの`~key$Cs が変更されるまで，毎回~同じ~instanceを返すことになる。
すなわち、
~objに加えられる改変は，どこからも見えることになる
— しかしながら、
その改変が~dbの内容を改変することはない。
◎
NOTE: If key returns an object (e.g. a Date or Array), it returns the same object instance every time it is inspected, until the cursor’s key is changed. This means that if the object is modified, those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object does not modify the contents of the database.
</p>
</div>

<div class="algo">
<p>
`primaryKey@m
取得子~手続きは
⇒
~RET `Value$( コレの`実効~key$Cs )
◎
The primaryKey getter steps are to return the result of converting a key to a value with the cursor’s current effective key.
</p>

<p class="note">注記：
`key^m 取得子の`注記＠#_key-getter-return-value$は、
この取得子にも該当する。
◎
NOTE: If primaryKey returns an object (e.g. a Date or Array), it returns the same object instance every time it is inspected, until the cursor’s effective key is changed. This means that if the object is modified, those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object does not modify the contents of the database.
</p>
</div>

<div class="algo">
<p>
`request@m
取得子~手続きは
⇒
~RET コレの`要請$Cs
◎
The request getter steps are to return this’s request.
</p>

<p class="advisement">🚧
この属性は、
この版において新たに導入された。
［
Chrome 76, Edge 79, Firefox 77, Safari 15
］から~supportされている。
🚧
◎
🚧 The request attribute is new in this edition. It is supported in Chrome 76, Edge 79, Firefox 77, and Safari 15. 🚧
</p>
</div>

<div class="note">
<p>注記：
以下に挙げる~methodは、
`~cursor$を その`範囲$Csに入る次の`~record$以降へ進めるよう要請する：
◎
The following methods advance a cursor.
</p>
<ul>
	<li>
進め終えた時点で、
~cursorの`要請$Csに向けて `success$et ~eventが発火されることになる。
`result$m は、
`範囲$Csに入る`~record$が［
在るならば ~cursor自身 ／
無いならば `undefined^jv
］になる。
◎
Once the cursor has advanced, a success event will be fired at the same IDBRequest returned when the cursor was opened. The result will be the same cursor if a record was in range, or undefined otherwise.
</li>
	<li>
~cursorを進める前回の要請が在って，それが完了する前に~callされた場合、
`InvalidStateError$E を投出する。
◎
If called while the cursor is already advancing, an "InvalidStateError" DOMException will be thrown.
</li>
	<li>
`~tx$が `作動中$i でないときに~callされた場合、
`TransactionInactiveError$E を投出する。
◎
The following methods throw a "TransactionInactiveError" DOMException if called when the transaction is not active.
</li>
</ul>
</div>

<dl class="domintro">
	<dt>%cursor . `advance(count)$m</dt>
	<dd>
%cursor を %count 個だけ先の~recordへ進める。
◎
Advances the cursor through the next count records in range.
</dd>

	<dt>%cursor . `continue$m()</dt>
	<dd>
%cursor を次の~recordへ進める。
◎
Advances the cursor to the next record in range.
</dd>

	<dt>%cursor . `continue(key)$m</dt>
	<dd>
%cursor を，次を満たす最初の~recordへ進める
⇒
［
次の~record以降に在る
］~AND［
`~key$ ~GTE~cmpkey %key
］
◎
Advances the cursor to the next record in range matching or after key.
</dd>

	<dt>%cursor . `continuePrimaryKey(key, primaryKey)$m</dt>
	<dd>
%cursor を，次を満たす最初の~recordへ進める
⇒
［
次の~record以降に在る
］~AND［
( `~key$, `値$ ) ~GTE~cmpkey ( %key, %primaryKey )
］
◎
Advances the cursor to the next record in range matching or after key and primaryKey.＼
</dd>
	<dd>
%cursor の`~source~handle$Csが`索引~handle$でない場合、
`InvalidAccessError$E が投出される。
◎
Throws an "InvalidAccessError" DOMException if the source is not an index.
</dd>
</dl>

<div class="algo">
<p>
`advance(count)@m
~method手続きは：
◎
The advance(count) method steps are:
</p>
<ol>
	<li>
~IF［
%count ~EQ 0
］
⇒
~THROW `TypeError$E
◎
If count is 0 (zero), throw a TypeError.
</li>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If this’s source or effective object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`値は取得-済みか$Cs ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this’s got value flag is false, indicating that the cursor is being iterated or has iterated past its end, throw an "InvalidStateError" DOMException.
</li>
	<li>
コレの`値は取得-済みか$Cs ~SET ~F
◎
Set this’s got value flag to false.
</li>
	<li>
%要請 ~SET コレの`要請$Cs
◎
Let request be this’s request.
</li>
	<li>
%要請 の
⇒＃
`処理-済みか$ ~SET ~F,
`済んだか$ ~SET ~F
◎
Set request’s processed flag to false.
◎
Set request’s done flag to false.
</li>
	<li>
<p>
`要請を非同期に実行する$( コレの`~source~handle$Cs, 次の手続き, %要請 )
</p>

<div class="algo">
手続きは
⇒
`~cursorを反復する$( `現在の~realm$, コレ, ε, ε, %count )
</div>
◎
Let operation be an algorithm to run iterate a cursor with the current Realm record, this, and count.
◎
Run asynchronously execute a request with this’s source handle, operation, and request.
</li>
</ol>

<p class="note">注記：
新たな~cursor~dataが読込まれる前に，この~methodを重ねて~callした場合
— 例えば，同じ `onsuccess^m ~handlerの~callの中で重ねて~callした場合 —
2 回目の~call時には、
~cursorの`値は取得-済みか$Cs ~EQ ~F なので， `InvalidStateError$E 例外が投出されることになる。
◎
NOTE: Calling this method more than once before new cursor data has been loaded - for example, calling advance() twice from the same onsuccess handler - results in an "InvalidStateError" DOMException being thrown on the second call because the cursor’s got value flag has been set to false.
</p>
</div>

<div class="algo">
<p>
`continue(key)@m
~method手続きは：
◎
The continue(key) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If this’s source or effective object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`値は取得-済みか$Cs ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this’s got value flag is false, indicating that the cursor is being iterated or has iterated past its end, throw an "InvalidStateError" DOMException.
</li>
	<li>
<p>
~IF［
%key ~NEQ ε
］：
◎
If key is given, then:
</p>
		<ol>
			<li>
%key ~LET `Key$( %key ) ？
◎
Let r be the result of converting a value to a key with key. Rethrow any exceptions.
◎
If r is "invalid value" or "invalid type", throw a "DataError" DOMException.
◎
Let key be r.
</li>
			<li>
~IF［
%key ~LTE~cmpkey コレの`位置$Cs
］~AND［
コレの`方向$Cs ~IN { `next^l, `nextunique^l }
］
⇒
~THROW `DataError$E
◎
If key is less than or equal to this’s position and this’s direction is "next" or "nextunique", then throw a "DataError" DOMException.
</li>
			<li>
~IF［
%key ~GTE~cmpkey コレの`位置$Cs
］~AND［
コレの`方向$Cs ~IN { `prev^l, `prevunique^l }
］
⇒
~THROW `DataError$E
◎
If key is greater than or equal to this’s position and this’s direction is "prev" or "prevunique", then throw a "DataError" DOMException.
</li>
		</ol>
	</li>
	<li>
コレの`値は取得-済みか$Cs ~SET ~F
◎
Set this’s got value flag to false.
</li>
	<li>
%要請 ~SET コレの`要請$Cs
◎
Let request be this’s request.
</li>
	<li>
%要請 の
⇒＃
`処理-済みか$ ~SET ~F,
`済んだか$ ~SET ~F
◎
Set request’s processed flag to false.
◎
Set request’s done flag to false.
</li>
	<li>
<p>
`要請を非同期に実行する$$( コレの`~source~handle$Cs, 次の手続き, %要請 )
</p>

<div class="algo">
手続きは
⇒
`~cursorを反復する$( `現在の~realm$, コレ, %key )
</div>
◎
Let operation be an algorithm to run iterate a cursor with the current Realm record, this, and key (if given).
◎
Run asynchronously execute a request with this’s source handle, operation, and request.
</li>
</ol>

<p class="note">注記：
`advance$m の注記と同じ文言がこの~methodにも該当する。
◎
NOTE: Calling this method more than once before new cursor data has been loaded - for example, calling continue() twice from the same onsuccess handler - results in an "InvalidStateError" DOMException being thrown on the second call because the cursor’s got value flag has been set to false.
</p>
</div>

<div class="algo">
<p>
`continuePrimaryKey(key, primaryKey)@m
~method手続きは：
◎
The continuePrimaryKey(key, primaryKey) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ ) ？
◎
Let transaction be this’s transaction.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If this’s source or effective object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~source~handle$Csは`索引~handle$でない
］
⇒
~THROW `InvalidAccessError$E
◎
If this’s source is not an index throw an "InvalidAccessError" DOMException.
</li>
	<li>
~IF［
コレの`方向$Cs ~NIN { `next^l, `prev^l }
］
⇒
~THROW `InvalidAccessError$E
◎
If this’s direction is not "next" or "prev", throw an "InvalidAccessError" DOMException.
</li>
	<li>
~IF［
コレの`値は取得-済みか$Cs ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this’s got value flag is false, indicating that the cursor is being iterated or has iterated past its end, throw an "InvalidStateError" DOMException.
</li>
	<li>
%key ~LET `Key$( %key ) ？
◎
Let r be the result of converting a value to a key with key. Rethrow any exceptions.
◎
If r is "invalid value" or "invalid type", throw a "DataError" DOMException.
◎
Let key be r.
</li>
	<li>
%首key ~LET `Key$( %primaryKey ) ？
◎
Let r be the result of converting a value to a key with primaryKey. Rethrow any exceptions.
◎
If r is "invalid value" or "invalid type", throw a "DataError" DOMException.
◎
Let primaryKey be r.
</li>
	<li>
~IF［
コレの`方向$Cs ~EQ `next^l
］~AND［
( %key, %首key ) ~LTE~cmpkey コレの ( `位置$Cs, `保管庫~位置$Cs )
］
⇒
~THROW `DataError$E
◎
↓</li>
	<li>
~IF［
コレの`方向$Cs ~EQ `prev^l
］~AND［
( %key, %首key ) ~GTE~cmpkey コレの ( `位置$Cs, `保管庫~位置$Cs )
］
⇒
~THROW `DataError$E
◎
If key is less than this’s position and this’s direction is "next", throw a "DataError" DOMException.
◎
If key is greater than this’s position and this’s direction is "prev", throw a "DataError" DOMException.
◎
If key is equal to this’s position and primaryKey is less than or equal to this’s object store position and this’s direction is "next", throw a "DataError" DOMException.
◎
If key is equal to this’s position and primaryKey is greater than or equal to this’s object store position and this’s direction is "prev", throw a "DataError" DOMException.
</li>
	<li>
コレの`値は取得-済みか$Cs ~SET ~F
◎
Set this’s got value flag to false.
</li>
	<li>
%要請 ~SET コレの`要請$Cs
◎
Let request be this’s request.
</li>
	<li>
%要請 の
⇒＃
`処理-済みか$ ~SET ~F,
`済んだか$ ~SET ~F
◎
Set request’s processed flag to false.
◎
Set request’s done flag to false.
</li>
	<li>
<p>
`要請を非同期に実行する$$( コレの`~source~handle$Cs, 次の手続き, %要請 )
</p>

<div class="algo">
手続きは
⇒
`~cursorを反復する$( `現在の~realm$, コレ, %key, %首key )
</div>
◎
Let operation be an algorithm to run iterate a cursor with the current Realm record, this, key, and primaryKey.
◎
Run asynchronously execute a request with this’s source handle, operation, and request.
</li>
</ol>

<p class="note">注記：
`advance$m の注記と同じ文言がこの~methodにも該当する。
◎
NOTE: Calling this method more than once before new cursor data has been loaded - for example, calling continuePrimaryKey() twice from the same onsuccess handler - results in an "InvalidStateError" DOMException being thrown on the second call because the cursor’s got value flag has been set to false.
</p>
</div>

<p class="note">注記：
以下に挙げる~methodは、［
`~readonly~tx$の中で~callされた場合は `ReadOnlyError$E ／
`~tx$が `作動中$i でないときに~callされた場合は `TransactionInactiveError$E
］を投出する。
◎
The following methods throw a "ReadOnlyError" DOMException if called within a read-only transaction, and a "TransactionInactiveError" DOMException if called when the transaction is not active.
</p>

<dl class="domintro">
	<dt>%request = %cursor . `update(value)$m</dt>
	<dd>
%cursor が指している`~record$†の値を %value に更新するよう要請する。
◎
Updated the record pointed at by the cursor with a new value.
</dd>
	<dd class="trans-note">【†
`~source~handle$Cs↗が`索引$である場合は、
その`参照先~record$。
】</dd>
	<dd>
［
%cursor の`実効~保管庫$Csの`~key~path$Os ~NEQ ε
］の下で，
`~key$を変更しようとした場合†、
`DataError$E が投出される。
◎
Throws a "DataError" DOMException if the effective object store uses in-line keys and the key would have changed.
</dd>
	<dd class="trans-note">【†
すなわち，当の~recordの~keyが %value 内の`~key~path$Osが指す部位と等しくない場合。
】</dd>
	<dd>
成功した場合、
%request の `result$m は，
更新した`~record$の`~key$になる。
◎
If successful, request’s result will be the record’s key.
</dd>

	<dt>%request = %cursor . `delete$m()</dt>
	<dd>
%cursor が指している~recordを削除するよう要請する。
【！ ＊原文誤 with a new value. 】
◎
Delete the record pointed at by the cursor with a new value.
</dd>
	<dd>
成功した場合、
%request の `result$m は，
`undefined^jv になる。
◎
If successful, request’s result will be undefined.
</dd>
</dl>

<div class="algo">
<p>
`update(value)@m
~method手続きは：
◎
The update(value) method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `readwrite^l ) ？
◎
Let transaction be this’s transaction.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
◎
If this’s source or effective object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`値は取得-済みか$Cs ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this’s got value flag is false, indicating that the cursor is being iterated or has iterated past its end, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~keyのみか$Cs ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If this’s key only flag is true, throw an "InvalidStateError" DOMException.
</li>
	<li>
%~clone ~LET `~txの間に値を~cloneする$( %value, コレの`~source~handle$Csが`専属する$`~tx$ ) ？
◎
Let targetRealm be a user-agent defined Realm.
◎
Let clone be a clone of value in targetRealm during transaction. Rethrow any exceptions.
◎
Why create a copy of the value?
◎
The value is serialized when stored. Treating it as a copy here allows other algorithms in this specification to treat it as an ECMAScript value, but implementations can optimize this if the difference in behavior is not observable.
</li>
	<li>
%keyPath ~LET コレの`実効~保管庫$Csの`~key~path$Os
◎
↓</li>
	<li>
<p>
~IF［
%keyPath ~NEQ ε
］：
</p>
		<ol>
			<li>
%抽出d~key ~LET `Extract$( %~clone, %keyPath ) ？
</li>
			<li>
~IF［
%抽出d~key ~NEQ~cmpkey ~cursorの`実効~key$Cs
］
⇒
~THROW `DataError$E
◎
↑</li>
		</ol>

◎
If this’s effective object store uses in-line keys, then:
• Let kpk be the result of extracting a key from a value using a key path with clone and the key path of this’s effective object store. Rethrow any exceptions.
• If kpk is failure, invalid, or not equal to this’s effective key, throw a "DataError" DOMException.
</li>
	<li>
<div>
<p>
~RET `要請を非同期に実行する$( コレの`~source~handle$Cs, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`保管庫に~recordを格納する$( コレの`実効~保管庫$Cs, %~clone, コレの`実効~key$Cs )
</div>
◎
Let operation be an algorithm to run store a record into an object store with this’s effective object store, clone, this’s effective key, and false.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</div>

<p class="note">注記：
`保管庫に~recordを格納する$演算は、［
~cursorを ある~recordを指す位置に移動した後，当の~recordが削除されていた場合
］には，新たな~recordを作成することになる。
◎
NOTE: A result of storing a record into an object store is that if the record has been deleted since the cursor moved to it, a new record will be created.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`delete()@m
~method手続きは：
◎
The delete() method steps are:
</p>
<ol>
	<li>
`状態を検査する$( コレ, `readwrite^l ) ？
◎
Let transaction be this’s transaction.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
◎
If this’s source or effective object store has been deleted, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`値は取得-済みか$Cs ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this’s got value flag is false, indicating that the cursor is being iterated or has iterated past its end, throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~keyのみか$Cs ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If this’s key only flag is true, throw an "InvalidStateError" DOMException.
</li>
	<li>
<p>
~RET `要請を非同期に実行する$( コレの`~source~handle$Cs, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`保管庫から~recordを削除する$( コレの`実効~保管庫$Cs, `~keyのみを包含する範囲$( コレの`実効~key$Cs ) )
</div>
◎
Let operation be an algorithm to run delete records from an object store with this’s effective object store and this’s effective key.
◎
Return the result (an IDBRequest) of running asynchronously execute a request with this and operation.
</li>
</ol>
</div>

<p>
`~keyのみか$Cs ~EQ ~F
にされた`~cursor$は、
`IDBCursorWithValue$I ~interfaceも実装する。
◎
A cursor that has its key only flag set to false implements the IDBCursorWithValue interface as well.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBCursorWithValue@I : `IDBCursor$I {
  readonly attribute `any$ `value$m;
};
</pre>

<dl class="domintro">
	<dt>%cursor . `value$m</dt>
	<dd>
%cursor の現在の`値$Csを返す。
◎
Returns the cursor’s current value.
</dd>
</dl>

<div class="algo">
<p>
`value@m
取得子~手続きは
⇒
~RET ［
コレの`値$Cs ~NEQ ε ならば それ ／
~ELSE_ `undefined^jv
］
◎
The value getter steps are to return this’s current value.
</p>

<p class="note">注記：
`key^m 取得子の`注記＠#_key-getter-return-value$は、
この取得子にも該当する。
◎
NOTE: If value returns an object, it returns the same object instance every time it is inspected, until the cursor’s value is changed. This means that if the object is modified, those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object does not modify the contents of the database.
</p>
</div>

		</section>
		<section id="transaction">
<h3 title="The IDBTransaction interface">4.10. `IDBTransaction^I ~interface</h3>

<p>
`~tx$は、
次の~interfaceを実装する~objで表現される：
◎
Transaction objects implement the following interface:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `IDBTransaction@I : `EventTarget$I {
  readonly attribute `DOMStringList$I `objectStoreNames$m;
  readonly attribute `IDBTransactionMode$I `mode$m;
  readonly attribute `IDBTransactionDurability$I `durability$m;
  [`SameObject$] readonly attribute `IDBDatabase$I `db$m;
  readonly attribute `DOMException$I? `error$m;

  `IDBObjectStore$I `objectStore$m(`DOMString$ %name);
  `undefined$ `commit$m();
  `undefined$ `abort$m();

  // <span class="comment" title="Event handlers">~event~handler：</span>
  attribute `EventHandler$I `onabort$m;
  attribute `EventHandler$I `oncomplete$m;
  attribute `EventHandler$I `onerror$m;
};

enum `IDBTransactionMode@I {
  `readonly$l,
  `readwrite$l,
  `versionchange$l
};
</pre>

<!-- `IDBTransaction!I -->
<dl class="domintro">
	<dt>%transaction . `objectStoreNames$m</dt>
	<dd>
%transaction の`視野$に入る各`保管庫$の名前たちが成す~listを返す。
`昇格~tx$に対しては、
視野は，当の`~db$の`保管庫$すべてからなる。
◎
Returns a list of the names of object stores in the transaction’s scope. For an upgrade transaction this is all object stores in the database.
</dd>

	<dt>%transaction . `mode$m</dt>
	<dd>
%transaction の`~mode$を返す。
`昇格~tx$に対しては， `versionchange$l ／
他の~txに対しては，その作成-時に与えたもの（ `readonly$l ／ `readwrite$l ）になる。
◎
Returns the mode the transaction was created with ("readonly" or "readwrite"), or "versionchange" for an upgrade transaction.
</dd>

	<dt>%transaction . `durability$m</dt>
	<dd>
%transaction の作成-時に与えた`耐久能~hint$
（ `strict$l ／ `relaxed$l ／ `default$l ）
を返す。
◎
Returns the durability hint the transaction was created with ("strict", "relaxed"), or "default").
</dd>

	<dt>%transaction . `db$m</dt>
	<dd>
%transaction が`専属する$`接続$を返す。
◎
Returns the transaction’s connection.
</dd>

	<dt>%transaction . `error$m</dt>
	<dd>
%transaction が すでに`中止-$されている場合、
その事由を供する~error（ `DOMException$I ）を返す。
◎
If the transaction was aborted, returns the error (a DOMException) providing the reason.
</dd>
</dl>

<div class="algo">
<p>
`objectStoreNames@m
取得子~手続きは：
◎
The objectStoreNames getter steps are:
</p>
<ol>
	<li>
%名前~群 ~LET ［
コレが`視野$に入れている各`保管庫$の`名前$Os
］たちが成す`~list$
◎
Let names be a list of the names of the object stores in this’s scope.
</li>
	<li>
~RET `~sort済み名前~listを作成する$( %名前~群 )
◎
Return the result (a DOMStringList) of creating a sorted name list with names.
</li>
</ol>

<p class="note">注記：
この属性が返す~listの内容は、
変化しない
— ただし，`昇格~tx$の間は、
保管庫が［
作成される／削除される
］に伴い変化し得る。
◎
NOTE: The contents of each list returned by this attribute does not change, but subsequent calls to this attribute during an upgrade transaction can return lists with different contents as object stores are created and deleted.
</p>
</div>

<div class="algo">
`mode@m
取得子~手続きは
⇒
~RET コレの`~mode$
◎
The mode getter steps are to return this’s mode.
</div>

<div class="algo">
<p>
`durability@m
取得子~手続きは
⇒
~RET コレの`耐久能~hint$
◎
The durability getter steps are to return this’s durability hint.
</p>

<p class="advisement">🚧
この属性は、
この版において新たに導入された。
［
Chrome 82, Edge 82, Firefox 126, Safari 15
］から~supportされている。
🚧
◎
🚧 The durability attribute is new in this edition. It is supported in Chrome 82, Edge 82, Firefox 126, and Safari 15. 🚧
</p>
</div>

<div class="algo">
`db@m
取得子~手続きは
⇒
~RET コレが`専属する$`接続$
◎
The db getter steps are to return this’s connection’s associated database.
</div>

<div class="algo">
<p>
`error@m
取得子~手続きは
⇒
~RET ［
コレの`~error$tx ~NEQ ε ならば それ ／
~ELSE_ ~NULL
］
◎
The error getter steps are to return this’s error, or null if none.
</p>

<div class="note">
<p>
注記：
~txが中止されたときは、
その事由に応じて，次を返す：
</p>
		<ul>
			<li>
失敗した`要請$に因り`中止-$された場合、
`要請$の`~error$と同じ名前の~error。
</li>
			<li>
~event~handlerから投出された例外に因り`中止-$された場合、
`AbortError$E 例外
</li>
			<li>
`~commit$時の~errorに因り`中止-$された場合、
失敗の事由を反映する~error
— 例えば
⇒＃
`QuotaExceededError$I ／
`ConstraintError$E 例外／
`UnknownError$E 例外
</li>
		</ul>

<p class="trans-note">【
`abort()$m ~methodに因り`中止-$された場合は、
~NULL が返される。
】</p>

◎
NOTE: If this transaction was aborted due to a failed request, this will be the same as the request’s error. If this transaction was aborted due to an uncaught exception in an event handler, the error will be a "AbortError" DOMException. If the transaction was aborted due to an error while committing, it will reflect the reason for the failure (e.g. a QuotaExceededError, or a "ConstraintError" or "UnknownError" DOMException).
</div>
</div>

<dl class="domintro">
	<dt>%transaction . `objectStore(name)$m</dt>
	<dd>
%transaction の`視野$に入る`名前$Os %name の`保管庫$を`~access先$とする `IDBObjectStore$I を返す。
◎
Returns an IDBObjectStore in the transaction’s scope.
</dd>

	<dt>%transaction . `abort()$m</dt>
	<dd>
%transaction を中止する。
処理待ちなすべての`要請$は， `AbortError$E 例外で失敗し、
接続先~dbに加えられた すべての変更は，復帰されることになる。
◎
Aborts the transaction. All pending requests will fail with a "AbortError" DOMException and all changes made to the database will be reverted.
</dd>

	<dt>%transaction . `commit()$m</dt>
	<dd>
~txを~commitするよう試みる。
処理待ちなすべての`要請$は，完了することが許容されるが、
新たな要請は，受容されなくなる。
これを利用すれば，~txを素早く完遂するよう強制できる
— ［
~commitするよう試みる前に，処理待ち要請に対し `success$et ~eventが発火されるまで待機する
］通常のふるまいに代えて。
◎
Attempts to commit the transaction. All pending requests will be allowed to complete, but no new requests will be accepted. This can be used to force a transaction to quickly finish, without waiting for pending requests to fire success events before attempting to commit normally.
</dd>
	<dd>
処理待ち要請が
— 例えば拘束~errorに因り —
失敗した場合、
~txは中止される。
成功した要請に対しては，依然として `success$et ~eventは発火されるが、
~event~handler内で例外を投出しても，~txは中止されなくなる。
同様に，失敗した要請に対しても，依然として `error$et ~eventは発火されるが、
`preventDefault()^m を~callしても，~txは中止できない。
◎
The transaction will abort if a pending request fails, for example due to a constraint error. The success events for successful requests will still fire, but throwing an exception in an event handler will not abort the transaction. Similarly, error events for failed requests will still fire, but calling preventDefault() will not prevent the transaction from aborting.
</dd>
</dl>

<div class="algo">
<p>
`objectStore(name)@m
~method手続きは：
◎
The objectStore(name) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$tx ~EQ `完遂d$i
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is finished, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%保管庫 ~LET 次を満たす`保管庫$
⇒
［
コレの`視野$に入る
］~AND［
`名前$Os ~EQ %name
］
◎
Let store be the object store named name in this’s scope,＼
</li>
	<li>
~IF［
%保管庫 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
or throw a "NotFoundError" DOMException if none.
</li>
	<li>
~RET 次を満たすような`保管庫~handle$ %H
⇒＃
%H↗ ~EQ %保管庫,
%H はコレに`専属する$,
`一意性$の要件を満たす
◎終
（`可換性$の要件は、`視野$の構成から自動的に満たされる）
◎
Return an object store handle associated with store and this.
</li>
</ol>

<p class="note">注記：
`一意性$の要件から，返される~instanceは一意に定まる
【~instanceがその前のどの時点で作成されるかは，実装の詳細~になる】
。
よって、
`昇格~tx$の間を除き、
同じ `IDBTransaction$I ~instance上で，同じ %name をこの~methodに渡して返される `IDBObjectStore$I ~instanceは、
常に同じになる。
◎
NOTE: Each call to this method on the same IDBTransaction instance with the same name returns the same IDBObjectStore instance.
</p>

<p class="note">注記：
%H はコレに`専属する$ので、
他の `IDBTransaction$I ~instanceに対し同じ引数で この~methodを呼出しても， %H と異なる `IDBObjectStore$I ~instanceが返される。
◎
NOTE: The returned IDBObjectStore instance is specific to this IDBTransaction. If this method is called on a different IDBTransaction, a different IDBObjectStore instance is returned.
</p>

</div>

<div class="algo">
<p>
`abort()@m
~method手続きは：
◎
The abort() method steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$tx ~IN { `~commit中$i, `完遂d$i }
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is committing or finished, then throw an "InvalidStateError" DOMException.
</li>
	<li>
`~txを中止する$( コレ, ~NULL )
◎
Run abort a transaction with this and null.
</li>
</ol>
</div>

<div class="algo">
<p>
`commit()@m
~method手続きは：
◎
The commit() method steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$tx ~NEQ `作動中$i
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is not active, then throw an "InvalidStateError" DOMException.
</li>
	<li>
`~txを~commitする$( コレ )
◎
Run commit a transaction with this.
</li>
</ol>

<p class="advisement">🚧
この~methodは、
この版において新たに導入された。
［
Chrome 76, Edge 79, Firefox 74, Safari 15
］から~supportされている。
🚧
◎
🚧 The commit() method is new in this edition. It is supported in Chrome 76, Edge 79, Firefox 74, and Safari 15. 🚧
</p>

<p class="note">注記：
`~tx$上でこの~methodを~callすることは、
通常は必要yでない。
~txは、
未決な要請がすべて満たされ，新たな要請は為されていなければ，自動的に~commitされる。
この~callを利用すれば、
未決な`要請$から配送される~eventを待機することなく，`~commit$処理-を開始できる。
◎
NOTE: It is not normally necessary to call commit() on a transaction. A transaction will automatically commit when all outstanding requests have been satisfied and no new requests have been made. This call can be used to start the commit process without waiting for events from outstanding requests to be dispatched.
</p>
</div>

<p>
`onabort@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `abort$et である。
◎
The onabort attribute is an event handler IDL attribute whose event handler event type is abort.
</p>

<p>
`oncomplete@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `complete$et である。
◎
The oncomplete attribute is an event handler IDL attribute whose event handler event type is complete.
</p>

<p>
`onerror@m
属性は、
`~event~handler~IDL属性$であり，その`~event~handler~event型$は `error$et である。
◎
The onerror attribute is an event handler IDL attribute whose event handler event type is error.
</p>

<p class="note">注記：
`~tx$が成功裡に完了したかどうかは、
要請に配送される `success$et ~eventではなく，`~tx$に配送される `complete$et ~eventを~listenして決定すること
— `~tx$は、
`success$et ~eventを発火した後でも失敗し得るので。
◎
NOTE: To determine if a transaction has completed successfully, listen to the transaction’s complete event rather than the success event of a particular request, because the transaction can still fail after the success event fires.
</p>

		</section>
	</section>
	<section id="_algorithms0">
<h2 class="trans-note">X. この訳に特有な各種~algo</h2>

<p class="trans-note">【
この節では、
原文~仕様の各種~API定義に繰り~~返し現れる記述を集約して定義する。
集約~以外にも、
~APIの演算において即時に行われる演算
（失敗した場合は例外が投出される, この節にて述べるもの）と,
`要請$にて非同期に行われる演算（失敗は~eventを通して通知される）
とを区別して，挙動を明快にする目的もある。
【！ 両者が同じ下位~algoを重複して呼出すこともある。】
】</p>

		<section id="_X-CheckState">
<h3 class="trans-note">X.2. 状態を検査する( %O, %要求mode )</h3>

<div class="algo">
<p>
%O を通して［
`保管庫$／`索引$
］に［
~accessし得るかどうか, および演算し得るかどうか
］を検査する：
</p>

<ol>
	<li>
~Assert：
%O は［
`保管庫~handle$／`索引~handle$／`~cursor$
］である
</li>
	<li>
<p>
~IF［
%O は`~cursor$である
］：
</p>
		<ol>
			<li>
%O ~SET %O の`~source~handle$Cs
</li>
			<li>
下の手続きを
`段 A^i, `段 C^i, `段 B^i の順に実行する
</li>
			<li>
~RET
</li>
		</ol>
	</li>
	<li>
`段 A^i：
		<ol>
			<li>
%~tx ~LET %O が`専属する$~tx
</li>
			<li>
~IF［
%要求mode ~EQ `versionchange^l
］~AND［
%~tx は`昇格~tx$でない
］
⇒
~THROW `InvalidStateError$E
◎
If transaction is not an upgrade transaction, throw an "InvalidStateError" DOMException.
</li>
		</ol>
	</li>
	<li>
`段 B^i：
		<ol>
			<li>
~IF［
%O↗ はすでに削除されている
］
⇒
~THROW `InvalidStateError$E
◎
If index or index’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
If store has been deleted, throw an "InvalidStateError" DOMException.
</li>
		</ol>
	</li>
	<li>
`段 C^i：
		<ol>
			<li>
~IF［
%~tx の`状態$tx ~NEQ `作動中$i
］
⇒
~THROW `TransactionInactiveError$E
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
			<li>
~IF［
%要求mode ~EQ `readwrite^l
］~AND［
%~tx は`~readonly~tx$である
］
⇒
~THROW `ReadOnlyError$E
◎
If transaction is a read-only transaction, throw a "ReadOnlyError" DOMException.
</li>
		</ol>
	</li>
</ol>
</div>

<p class="trans-note">【
原文では、
`IDBIndex.name$m,
`IDBObjectStore.name$m
の設定子については、
上の手続きを他と異なる順序で検査するように記述されている
（この２つについても互いに異なる
— 単なる誤記かも？）。
詳細は原文を参照されたし。
`現実の実装も，上のものと一致するとは限らない＠~IDBISSUES/11$
（各~実装, 各~methodごとにまちまちな部分もあるかもしれない）。
】</p>

		</section>
		<section id="_X-Value">
<h3 class="trans-note">X.3. Value( %key )</h3>

<div class="algo">
<p>
所与の［
`~key$／ ε
］を値に変換した結果を返す：
</p>

<ol>
	<li>
~IF［
%key ~EQ ε
］
⇒
~RET `undefined^jv
</li>
	<li>
~RET `~keyを値に変換する$( %key )
</li>
</ol>
</div>

		</section>
		<section id="_X-Key">
<h3 class="trans-note">X.4. Key( %入力 )</h3>

<div class="algo">
<p>
所与の値を`~key$に変換した結果を返すか例外を`投出-$する：
</p>
<ol>
	<li>
%~key ~LET `値を~keyに変換する$( %入力 ) ？
</li>
	<li>
~IF［
%~key ~IN { `無効な値^i,  `無効な型^i }
］
⇒
~THROW `DataError$E
</li>
	<li>
~RET %~key
</li>
</ol>
</div>

		</section>
		<section id="_X-Extract">
<h3 class="trans-note">X.5. Extract( %値, %~key~path, %生成器 )</h3>

<div class="algo">
<p>
所与の
( `値$, `~key~path$, `~key生成器$ )
に対し，［
`~key$ ／ ε
］を返すか例外を`投出-$する：
</p>

<ol>
	<li>
%抽出d~key ~LET `値から~keyを抽出する$( %値, %~key~path ) ？
</li>
	<li>
<p>
%抽出d~key に応じて：
</p>
		<ul class="switch">
			<li>
`~key$である
⇒
~RET %抽出d~key
</li>
			<li>
`無効な値^i
⇒
~THROW `DataError$E
</li>
			<li>
<p>
`失敗^i：
</p>
				<ol>
					<li>
~IF［
%生成器 ~EQ ε
］
⇒
~THROW `DataError$E
</li>
					<li>
~RET ε
</li>
				</ol>
			</li>
		</ul>
◎
Let kpk be the result of extracting a key from a value using a key path with clone and store’s key path. Rethrow any exceptions.
◎
If kpk is invalid, throw a "DataError" DOMException.
◎
If kpk is not failure, let key be kpk.
◎
Otherwise, if the object store does not have a key generator, throw a "DataError" DOMException.
</li>
</ol>
</div>

		</section>
		<section id="_X-Dispatch">
<h3 class="trans-note">X.6. Dispatch( %~target, %~event )</h3>

<div class="algo">
<p>
%~target に向けて %~event を配送した上で，真偽値を返す
— この~algoの目的においては、
%~event には真偽値をとる
`（旧来の）~listenerは投出したか@
が結付けられ，初期~時は ~F をとるとする：
</p>
<ol>
	<li>
`~eventを配送する$( %~target, %~event )
</li>
	<li>
~RET %~event の`（旧来の）~listenerは投出したか$
</li>
</ol>
</div>

		</section>
	</section>
	<section id="algorithms">
<h2 title="Algorithms">5. 各種~algo</h2>

		<section id="opening">
<h3 title="Opening a database connection">5.1. ~db接続の~open法</h3>

<div class="algo">
<p>
`~db接続を~openする@
~algoは、
所与の
( `~storage~key$ %~storage~key, `名前$db %名前 `~version$db %~version `~open要請$ %要請 )
に対し：
◎
To open a database connection with storageKey which requested the database to be opened, a database name, a database version, and a request, run these steps:
</p>

<ol>
	<li>
%~queue ~LET ( %~storage~key, %名前 ) に対する`接続~queue$
◎
Let queue be the connection queue for storageKey and name.
</li>
	<li>
%要請 を %~queue に追加する
◎
Add request to queue.
</li>
	<li>
%~queue 内の %要請 以前の要請すべてが処理されるまで待機する
◎
Wait until all previous requests in queue have been processed.
</li>
	<li>
%~db ~LET %~storage~key に`専属する$`~db$のうち，次を満たすもの
⇒
`名前$db ~EQ %名前
◎
Let db be the database named name in storageKey, or null otherwise.
</li>
	<li>
~IF ［
%~version ~EQ ε
］
⇒
%~version ~SET ［
%~db ~EQ ε ならば 1 ／
~ELSE_ %~db の`~version$db
］
◎
If version is undefined, let version be 1 if db is null, or db’s version otherwise.
</li>
	<li>
<p>~IF ［
%~db ~EQ ε
］：
</p>
		<ol>
			<li>
%~db ~LET 次のようにされた，新たな`~db$
⇒＃
%~storage~key に`専属する$,
`名前$db ~SET %名前,
`~version$db ~SET `0^c,
`専属する$`保管庫$は無い
</li>
			<li>
~IF［
何らかの事由で前~段は失敗した
］
⇒
~RET 適切な~error
— 例えば：
`QuotaExceededError$I ／
`UnknownError$E 例外
</li>
		</ol>
◎
If db is null, let db be a new database with name name, version 0 (zero), and with no object stores. If this fails for any reason, return an appropriate error (e.g. a QuotaExceededError, or an "UnknownError" DOMException).
</li>
	<li>
~IF［
%~version ~LT %~db の`~version$db
］
⇒
~RET `新たな例外$( `VersionError$E )
◎
If db’s version is greater than version, return a newly created "VersionError" DOMException and abort these steps.
</li>
	<li>
%新~接続 ~LET
%~db を`~access先$とする新たな`接続$
◎
Let connection be a new connection to db.
</li>
	<li>
%新~接続 の`~version$Cn ~SET %~version
◎
Set connection’s version to version.
</li>
	<li>
<p>
~IF ［
%~version ~GT %~db の`~version$db
］：
◎
If db’s version is less than version, then:
</p>
		<ol>
			<li>
%接続~群 ~LET ［
%~db を`~access先$とする`接続$のうち %新~接続 でないもの
］たちが成す`集合$
◎
Let openConnections be the set of all connections, except connection, associated with db.
</li>
			<li>
<p>
%接続~群 を成す
~EACH( %接続 )
に対し
⇒
~IF［
%接続 の`状態$Cn ~EQ `~open中$i
］
⇒
`~db~taskを~queueする$( 次の手続き )
◎
For each entry of openConnections that does not have its close pending flag set to true, queue a database task to＼
</p>

<div class="algo">
手続きは
⇒
`~version変更~eventを発火する$( %接続, `versionchange$et, %~db の`~version$db, %~version )
◎
fire a version change event named versionchange at entry with db’s version and version.
</div>

<p class="note" id="_note-open-steps">注記：
この~eventの発火は、
上の反復の途中で，いくつかの接続を`~close$させ得る。
それらの接続に向けては、
まだ終えてなくとも
`versionchange$et ~eventは発火されない。
◎
NOTE: Firing this event might cause one or more of the other objects in openConnections to be closed, in which case the versionchange event is not fired at those objects, even if that hasn’t yet been done.
</p>
			</li>
			<li>
すべての~eventが発火されるまで待機する
◎
Wait for all of the events to be fired.
</li>
			<li>
<p>
~IF［
%接続~群 内に，［
`状態$Cn ~NEQ `~close済み$i
］なる`接続$が依然として在る
］
⇒
`~db~taskを~queueする$( 次の手続き )
◎
If any of the connections in openConnections are still not closed, queue a database task to＼
</p>

<div class="algo">
手続きは
⇒
`~version変更~eventを発火する$( %新~接続, `blocked$et, %~db の`~version$db, %~version )
◎
fire a version change event named blocked at request with db’s version and version.
</div>
			</li>
			<li id="version-change-close-block">
%接続~群 を成す すべての`接続$について，［
その`状態$Cn ~EQ `~close済み$i
］になるまで，待機する
◎
Wait until all connections in openConnections are closed.
</li>
			<li>
<p>
`~dbを昇格する$( %新~接続, %~version, %要請 )
◎
Run upgrade a database using connection, version and request.
</p>

<p class="trans-note">【
`昇格~tx$が`完遂-$するまで待機した上で
】</p>
				<ul>
					<li>
［
%新~接続 の`状態$Cn ~EQ `~close済み$i
］になったときは
⇒
~RET `新たな例外$( `AbortError$E )
◎
If connection was closed, return a newly created "AbortError" DOMException and abort these steps.
</li>
					<li>
<p>
~IF［
%要請 の`~error$ ~NEQ ε【！ is set】
］：
</p>
						<ol>
							<li>
`~db接続を~closeする$( %新~接続 )
</li>
							<li>
~RET `新たな例外$( `AbortError$E )
</li>
						</ol>
◎
If request’s error is set, run the steps to close a database connection with connection, return a newly created "AbortError" DOMException and abort these steps.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
~RET %新~接続
◎
Return connection.
</li>
</ol>
</div>

		</section>
		<section id="closing-connection">
<h3 title="Closing a database connection">5.2. ~db接続の~close法</h3>

<div class="algo">
<p>
`~db接続を~closeする@
~algoは、
所与の
( `接続$ %接続, %強制するか ~IN { `強制する^i, ε } )
に対し：
◎
To close a database connection with a connection object, and an optional forced flag, run these steps:
</p>

<!-- 
この手続きは、
IDBDatabase.close()$m
から同期的に呼出されているが，同期的に待機する段がある。
 -->

<ol>
	<li>
%接続 の`状態$Cn ~SET `~close待ち$i
◎
Set connection’s close pending flag to true.
</li>
	<li>
%~tx群 ~LET ［
%接続 に`専属する$`~tx$であって, `完遂-$していないもの
］たちが成す集合
◎
↓</li>
	<li>
~IF［
%強制するか ~EQ `強制する^i
］
⇒
%~tx群 を成す
~EACH( `~tx$ %~tx )
に対し
⇒
`~txを中止する$( %~tx, `AbortError$E )
◎
If the forced flag is true, then for each transaction created using connection run abort a transaction with transaction and newly created "AbortError" DOMException.
</li>
	<li>
%~tx群 を成す すべての~txが`完遂-$するまで待機する
◎
Wait for all transactions created using connection to complete.＼
</li>
	<li>
%接続 の`状態$Cn ~SET `~close済み$i
◎
Once they are complete, connection is closed.
</li>
	<li>
<p>
~IF
%強制するか ~EQ `強制する^i
⇒
`~eventを発火する$( %接続, `close$et )
◎
If the forced flag is true, then fire an event named close at connection.
</p>

<p class="note">注記：
`close$et ~eventが発火されるのは、
接続が異常に~closeされた場合に限られる
— 例えば：
`~storage~key$に対する~storageが~clearされた場合 ／
破損または入出力~errorがあるとき。
明示的に `close()$m を~callした場合には、
この~eventは`発火されない^em。
◎
NOTE: The close event only fires if the connection closes abnormally, e.g. if the storage key’s storage is cleared, or there is corruption or an I/O error. If close() is called explicitly the event does not fire.
</p>
	</li>
</ol>

<p class="note">注記：
%接続 の`状態$Cnが `~close待ち$i になって以降は、
%接続 を利用して新たな`~tx$を`作成-$することはできなくなる。
~txを`作成-$する すべての~methodは、
最初に %接続 の`状態$Cnを検査した上で， `~open中$i でないならば例外を投出する。
◎
NOTE: Once a connection’s close pending flag has been set to true, no new transactions can be created using the connection. All methods that create transactions first check the connection’s close pending flag first and throw an exception if it is true.
</p>

<p class="note">注記：
%接続 が `~close済み$i になったなら、［
所与の`~db$（ %接続 ↗ ）への`接続$たち すべてが~closeされる
］まで`待機して＠#delete-close-block$いた［
`~dbを昇格する$／`~dbを削除する$
］演算は，`阻まれ＠#version-change-close-block$ないようになり得る。
◎
NOTE: Once the connection is closed, this can unblock the steps to upgrade a database, and the steps to delete a database, which both wait for connections to a given database to be closed before continuing.
</p>
</div>

		</section>
		<section id="deleting-a-database">
<h3 title="Deleting a database">5.3. ~dbの削除-法</h3>

<div class="algo">
<p>
`~dbを削除する@
~algoは、
所与の
( `~storage~key$ %~storage~key, `名前$db %名前, `~open要請$ %要請 )
に対し：
◎
To delete a database with the storageKey that requested the database to be deleted, a database name, and a request, run these steps:
</p>

<ol>
	<li>
%~queue ~LET ( %~storage~key, %名前 ) に対する`接続~queue$
◎
Let queue be the connection queue for storageKey and name.
</li>
	<li>
%要請 を %~queue に追加する
◎
Add request to queue.
</li>
	<li>
%~queue 内の %要請 以前の要請すべてが処理されるまで待機する
◎
Wait until all previous requests in queue have been processed.
</li>
	<li>
%~db ~LET %~storage~key に`専属する$`~db$であって, ［
`名前$db ~EQ %名前
］なるもの
◎
Let db be the database named name in storageKey, if one exists.＼
</li>
	<li>
~IF［
%~db ~EQ ε
］
⇒
~RET 0
◎
Otherwise, return 0 (zero).
</li>
	<li>
%接続~群 ~LET ［
%~db を`~access先$とする`接続$
］のうち［
`状態$Cn ~NEQ `~close済み$i
］を満たすものたちが成す`集合$
◎
Let openConnections be the set of all connections associated with db.
</li>
	<li>
<p>
%接続~群 を成す
~EACH( %接続 )
に対し
⇒
~IF［
%接続 の`状態$Cn ~EQ `~open中$i
］
⇒
`~db~taskを~queueする$( 次の手続き )
◎
For each entry of openConnections that does not have its close pending flag set to true, queue a database task to＼
</p>

<div class="algo">
手続きは
⇒
~version変更~eventを発火する$( %接続, `versionchange$et, %~db の`~version$db, ~NULL )
◎
fire a version change event named versionchange at entry with db’s version and null.
</div>

<p class="note">注記：
ここでも，`~dbの~open法と同様の注記＠#_note-open-steps$が該当する。
◎
NOTE: Firing this event might cause one or more of the other objects in openConnections to be closed, in which case the versionchange event is not fired at those objects, even if that hasn’t yet been done.
</p>
	</li>
			<li>
すべての~eventが発火されるまで待機する
◎
Wait for all of the events to be fired.
</li>
			<li>
<p>
~IF［
%接続~群 内に［
`状態$Cn ~NEQ `~close済み$i
］なる`接続$は依然として在る
］
⇒
`~db~taskを~queueする$( 次の手続き )
◎
If any of the connections in openConnections are still not closed, queue a database task to＼
</p>

<div class="algo">
手続きは
⇒
`~version変更~eventを発火する$( %要請, `blocked$et, %~db の`~version$db, ~NULL )
◎
fire a version change event named blocked at request with db’s version and null.
</div>
	</li>
	<li id="delete-close-block">
%接続~群 を成すすべての`接続$について，［
その`状態$Cn ~EQ `~close済み$i
］になるまで，待機する
◎
Wait until all connections in openConnections are closed.
</li>
	<li>
%~version ~LET %~db の`~version$db
◎
Let version be db’s version.
</li>
	<li>
%~db を削除する
◎
Delete db.＼
</li>
	<li>
~IF［
何らかの事由で前~段は失敗した
］
⇒
~RET 適切な~error
— 例えば
⇒＃
`QuotaExceededError$I ／
`UnknownError$E 例外
◎
If this fails for any reason, return an appropriate error (e.g. a QuotaExceededError, or an "UnknownError" DOMException).
</li>
	<li>
~RET %~version
◎
Return version.
</li>
</ol>
</div>

		</section>
		<section id="commit-transaction">
<h3 title="Committing a transaction">5.4. ~txの~commit法</h3>

<div class="algo">
<p>
`~txを~commitする@
~algoは、
所与の
( `~tx$ %~tx )
に対し：
◎
To commit a transaction with the transaction to commit, run these steps:
</p>

<ol>
	<li>
%~tx の`状態$tx ~SET `~commit中$i
◎
Set transaction’s state to committing.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~tx の`要請~list$を成す すべての~itemが`処理-済み$になるまで待機する
◎
Wait until every item in transaction’s request list is processed.
</li>
			<li>
~IF［
%~tx の`状態$tx ~NEQ `~commit中$i
］
⇒
~RET
◎
If transaction’s state is no longer committing, then terminate these steps.
</li>
			<li>
%~db ~LET ( %~tx が`専属する$`接続$ )↗
◎
↓</li>
			<li>
%~tx により為された未決な変更のすべてを
— %~tx の`耐久能~hint$も考慮する下で —
%~db に書込もうと試みる
◎
Attempt to write any outstanding changes made by transaction to the database, considering transaction’s durability hint.
</li>
			<li>
<p>
~IF［
前~段により書込む間に~errorが生じた
］：
◎
If an error occurs while writing the changes to the database, then＼
</p>
				<ol>
					<li>
<p>
`~txを中止する$( %~tx, 当の~errorに適切な型の~error† )
◎
run abort a transaction with transaction and an appropriate type for the error,＼
</p>

<p>†
例えば
⇒＃
`QuotaExceededError$I ／
`UnknownError$E 例外
◎
for example a QuotaExceededError or an "UnknownError" DOMException,\
</p>
					</li>
					<li>
~RET
◎
and terminate these steps.
</li>
				</ol>
			</li>
			<li>
<p>
`~db~taskを~queueする$( 次の手続き )
◎
Queue a database task to＼
</p>

<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
~IF［
%~tx は`昇格~tx$である
］
⇒
%~db の`昇格~tx$db ~SET ε
◎
If transaction is an upgrade transaction, then set transaction’s connection’s associated database’s upgrade transaction to null.
</li>
					<li>
%~tx の`状態$tx ~SET `完遂d$i
◎
Set transaction’s state to finished.
</li>
					<li>
<p>
`~eventを発火する$( %~tx, `complete$et )
◎
Fire an event named complete at transaction.
</p>

<p class="note">注記：
この~event用の~event~handlerから例外が投出されようが、
~db変更の書込みは~eventを配送する前に終わるので，~txは~commitされる。
`complete$et ~eventが発火されるのは、
~txが成功裡に書込まれた後に限られる。
◎
NOTE: Even if an exception is thrown from one of the event handlers of this event, the transaction is still committed since writing the database changes happens before the event takes place. Only after the transaction has been successfully written is the complete event fired.
</p>
					</li>
					<li>
~IF［
%~tx は`昇格~tx$である
］
⇒
［
%~tx を`設置-先~tx$とする`要請$
【すなわち、`~dbを昇格する$ときに渡された %要請 】
］の`設置-先~tx$ ~SET ε
◎
If transaction is an upgrade transaction, then let request be the request associated with transaction and set request’s transaction to null.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
</ol>

<p class="trans-note">【
`~readonly~tx$に対しては、
この手続きは
（特に呼出さないようにする要件は見当たらないが）
実質的に何もしない。
】</p>

</div>

		</section>
		<section id="abort-transaction">
<h3 title="Aborting a transaction">5.5. ~txの中止-法</h3>

<div class="algo">
<p>
`~txを中止する@
~algoは、
所与の
( `~tx$ %~tx, %error )
に対し：
◎
To abort a transaction with the transaction to abort, and error, run these steps:
</p>

<ol>
	<li>
~IF［
%~tx の`状態$tx ~EQ `完遂d$i
］
⇒
~RET
◎
If transaction’s state is finished, abort these steps.
</li>

	<li>
%~db ~LET ( %~tx が`専属する$`接続$ )↗
◎
↓</li>
	<li>
<p>
%~tx により %~db に為された，すべての変更を復帰させる
— `昇格~tx$に対しては：
</p>
		<ul>
			<li>
%~db に`専属する$［
`保管庫$／`索引$
］たちが成す集合, および`~version$dbに対する変更も復帰させる。
</li>
			<li>
%~tx の間に作成された［
`保管庫$／`索引$
］は、
他の~algoの目的においては，削除されたものと見なされる。
</li>
		</ul>
◎
All the changes made to the database by the transaction are reverted. For upgrade transactions this includes changes to the set of object stores and indexes, as well as the change to the version. Any object stores and indexes which were created during the transaction are now considered deleted for the purposes of other algorithms.
</li>
	<li>
<p>
~IF［
%~tx は`昇格~tx$である
］
⇒
`昇格~txを中止する$( %~tx )
◎
If transaction is an upgrade transaction, run the steps to abort an upgrade transaction with transaction.
</p>

<p class="note">注記：
この結果、［
%~tx が`専属する$`接続$ ／ %~tx に`専属する$［
`保管庫~handle$ ／ `索引~handle$
］］すべての~instanceに対する変更は復帰されることになる。
◎
NOTE: This reverts changes to all connection, object store handle, and index handle instances associated with transaction.
</p>

	</li>
	<li>
%~tx の`状態$tx ~SET `完遂d$i
◎
Set transaction’s state to finished.
</li>
	<li>
%~tx の`~error$tx ~SET %error
◎
Set transaction’s error to error.
</li>
	<li>
<p>
%~tx の`要請~list$を成す
~EACH( `要請$ %要請 )
に対し：
◎
For each request of transaction’s request list,＼
</p>
		<ol>
			<li>
%要請 を`非同期に実行する$手続きを中止する
◎
abort the steps to asynchronously execute a request for request,＼
</li>
			<li>
%要請 の`処理-済みか$ ~SET ~T
◎
set request’s processed flag to true,＼
</li>
			<li>
<p>
`~db~taskを~queueする$( 次の手続き )
◎
and queue a database task to＼
</p>

<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
%要請 の
⇒＃
`済んだか$ ~SET ~T,
`結果$ ~SET ε,
`~error$ ~SET `新たな例外$( `AbortError$E )
◎
Set request’s done flag to true.
◎
Set request’s result to undefined.
◎
Set request’s error to a newly created "AbortError" DOMException.
</li>
					<li>
`~eventを発火する$( %要請, `error$et )
— 次のように初期化して
⇒＃
`bubbles$m 属性 ~SET ~T,
`cancelable$m 属性 ~SET ~T
◎
Fire an event named error at request with its bubbles and cancelable attributes initialized to true.
</li>
				</ol>

<p class="note">注記：
これは、
常に `error$et ~eventを発火するとは限らない。
例えば、
~txが `~commit中$i の間に~errorに因り中止された場合や，
それは失敗した最後の残りの要請であった場合【？】。
◎
NOTE: This does not always result in any error events being fired. For example if a transaction is aborted due to an error while committing the transaction, or if it was the last remaining request that failed.
</p>
</div>
			</li>
		</ol>
	</li>
	<li>
<p>
`~db~taskを~queueする$( 次の手続き )
◎
Queue a database task to＼
</p>

<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
		<ol>
			<li>
~IF［
%~tx は`昇格~tx$である
］
⇒
%~db の`昇格~tx$db ~SET ε
◎
If transaction is an upgrade transaction, then set transaction’s connection’s associated database’s upgrade transaction to null.
</li>
			<li>
`~eventを発火する$( %~tx, `abort$et )
— 次のように初期化して
⇒
`bubbles$m 属性 ~SET ~T
◎
Fire an event named abort at transaction with its bubbles attribute initialized to true.
</li>
			<li>
<p>
~IF［
%~tx は`昇格~tx$である
］：
◎
If transaction is an upgrade transaction, then:
</p>
				<ol>
					<li>
%要請 ~LET %~tx を`設置-先~tx$とする`~open要請$
【すなわち、`~dbを昇格する$ときに渡された %要請 】
◎
Let request be the open request associated with transaction.
</li>
					<li>
%要請 の
⇒＃
`設置-先~tx$ ~SET ε,
`結果$ ~SET ε,
`処理-済みか$ ~SET ~F,
`済んだか$ ~SET ~F
◎
Set request’s transaction to null.
◎
Set request’s result to undefined.
◎
Set request’s processed flag to false.
◎
Set request’s done flag to false.
</li>
				</ol>
			</li>
		</ol>
</div>
	</li>
</ol>
</div>

		</section>
		<section id="async-execute-request">
<h3 title="Asynchronously executing a request">5.6. 要請の非同期的な実行-法</h3>

<div class="algo">
<div>
<p>
`要請を非同期に実行する@
~algoは、
所与の
⇒＃
［ `保管庫~handle$／`索引~handle$ ］ %~source~handle,
~db上で遂行される`演算$を成す手続き %演算,
`要請$ %要請 ~DF ε
◎終
に対し
— この手続きは：
</p>
<ul>
	<li>
%要請 が省略された場合、
新たな`要請$を作成して返す。
</li>
	<li>
当の`要請$の`設置-先~tx$が`~txを中止-$する手続きを利用して`中止-$された場合、
いつでも中止され得る
</li>
</ul>
◎
To asynchronously execute a request with the source object and an operation to perform on a database, and an optional request, run these steps:
◎
These steps can be aborted at any point if the transaction the created request belongs to is aborted using the steps to abort a transaction.
</div>
<ol>
	<li>
%~tx ~LET %~source~handle が`専属する$`~tx$
◎
Let transaction be the transaction associated with source.
</li>
	<li>
~Assert：
%~tx の`状態$tx ~EQ `作動中$i
◎
Assert: transaction’s state is active.
</li>
	<li>
~IF［
%要請 ~EQ ε
］
⇒
%要請 ~SET `新たな~obj$( `IDBRequest$I )
— その
⇒＃
`~source$ ~SET %~source~handle,
`設置-先~tx$ ~SET %~tx
◎
If request was not given, let request be a new request with source as source.
</li>
	<li>
%~tx の`要請~list$に %要請 を追加する
◎
Add request to the end of transaction’s request list.
</li>
	<li>
~RET %要請
— ただし，以降も`並列的$に走らす
◎
Run these steps in parallel:
</li>
	<li>
次が満たされるまで待機する
⇒
%要請 は［
%~tx の`要請~list$を成す`処理-済み$でない~item
］のうち最初のものである
◎
Wait until request is the first item in transaction’s request list that is not processed.
</li>
	<li>
%結果 ~LET %演算 を遂行した結果
◎
Let result be the result of performing operation.
</li>
	<li>
~IF［
%結果 は~errorである
］~AND［
%~tx の`状態$tx ~EQ `~commit中$i
］
⇒＃
`~txを中止する$( %~tx, %結果 )；
~RET
◎
If result is an error and transaction’s state is committing, then run abort a transaction with transaction and result, and terminate these steps.
</li>
	<li>
<p>
~IF［
%結果 は~errorである
］
⇒
%演算 により生じたすべての変更を復帰する
◎
If result is an error, then revert all changes made by operation.
</p>

<p class="note">注記：
これは、
この要請により行われた変更のみを復帰させる。
~txにより為された他の変更は復帰されない。
◎
NOTE: This only reverts the changes done by this request, not any other changes made by the transaction.
</p>
	</li>
	<li>
%要請 の`処理-済みか$ ~SET ~T
◎
Set request’s processed flag to true.
</li>
	<li>
<p>
`~db~taskを~queueする$( 次の手続き )
◎
Queue a database task to＼
</p>

<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
		<ol>
			<li>
%~tx の`要請~list$から %要請 を除去する
◎
Remove request from transaction’s request list.
</li>
			<li>
<p>
%要請 の
⇒＃
`済んだか$ ~SET ~T,
`結果$ ~SET ε,
`~error$ ~SET ε
◎
Set request’s done flag to true.
◎
↓</li>
			<li>
<p>
~IF［
%結果 は~errorである
］：
◎
If result is an error, then:
</p>
				<ol>
					<li>
%要請 の`~error$ ~SET %結果
◎
Set request’s result to undefined.
◎
Set request’s error to result.
</li>
					<li>
`~error~eventを発火する$( %要請 )
◎
Fire an error event at request.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%要請 の`結果$ ~SET %結果
◎
Set request’s result to result.
◎
Set request’s error to undefined.
</li>
					<li>
`~success~eventを発火する$( %要請 )
◎
Fire a success event at request.
</li>
				</ol>
			</li>
		</ol>
</div>
	</li>
</ol>
</div>

<p>
◎
↑↑Return request.
</p>

		</section>
		<section id="upgrade-transaction-steps">
<h3 title="Upgrading a database">5.7. ~dbの昇格-法</h3>

<div class="algo">
<p>
`~dbを昇格する@
~algoは、
所与の
( `接続$ %接続, %~version `要請$ %要請 )
に対し：
◎
To upgrade a database with connection (a connection), a new version, and a request, run these steps:
</p>
<ol>
	<li>
%~db ~LET %接続↗
◎
Let db be connection’s database.
</li>
	<li>
%~tx ~LET 新たな`昇格~tx$
— その
⇒＃
`専属する$`接続$ ~SET %接続,
`視野$ ~SET %接続 の`保管庫~集合$Cn
◎
Let transaction be a new upgrade transaction with connection used as connection.
◎
Set transaction’s scope to connection’s object store set.
</li>
	<li>
%~db の`昇格~tx$db ~SET %~tx
◎
Set db’s upgrade transaction to transaction.
</li>
	<li>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</li>
	<li>
<p>
%~tx を開始する
◎
Start transaction.
</p>

<p class="note">注記：
この`~tx$が`完遂-$するまで，他の`接続$は %~db を~openできないことに注意。
◎
NOTE: Note that until this transaction is finished, no other connections can be opened to the same database.
</p>
	</li>
	<li>
%旧~version ~LET %~db の`~version$db
◎
Let old version be db’s version.
</li>
	<li>
%~db の`~version$db ~SET %~version
—
この変更は，`~tx$の一部と見なされ、
~txが`中止-$された場合には復帰される。
◎
Set db’s version to version. This change is considered part of the transaction, and so if the transaction is aborted, this change is reverted.
</li>
	<li>
%要請 の`処理-済みか$ ~SET ~T
◎
Set request’s processed flag to true.
</li>
	<li>
<p>
`~db~taskを~queueする$( 次の手続き )
◎
Queue a database task to＼
</p>

<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
		<ol>
			<li>
%要請 の`結果$ ~SET %接続
◎
Set request’s result to connection.
</li>
			<li>
%要請 の`設置-先~tx$ ~SET %~tx
◎
Set request’s transaction to transaction.
</li>
			<li>
%要請 の`済んだか$ ~SET ~T
◎
Set request’s done flag to true.
</li>
			<li>
%~tx の`状態$tx ~SET `作動中$i
◎
Set transaction’s state to active.
</li>
			<li>
%~listenerは投出したか ~LET
`~version変更~eventを発火する$( %要請, `upgradeneeded$et, %旧~version, %~version )
◎
Let didThrow be the result of firing a version change event named upgradeneeded at request with old version and version.
</li>
			<li>
<p>
~IF［
%~tx の`状態$tx ~EQ `作動中$i
］：
◎
If transaction’s state is active, then:
</p>
				<ol>
					<li>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</li>
					<li>
~IF［
%~listenerは投出したか ~EQ ~T
］
⇒
`~txを中止する$( %~tx, `新たな例外$( `AbortError$E ) )
◎
If didThrow is true, run abort a transaction with transaction and a newly created "AbortError" DOMException.
</li>
				</ol>
			</li>
		</ol>
</div>
	</li>
	<li>
<p>
%~tx が`完遂-$するまで待機する
◎
Wait for transaction to finish.
</p>

<p class="note">注記：
［
`~txを~commitする$／
`~txを中止する$
］手続きなど，~txの存続期間に呼出される一部の~algoは、
`昇格~tx$に特有な手続きを含む。
◎
NOTE: Some of the algorithms invoked during the transaction’s lifetime, such as the steps to commit a transaction and the steps to abort a transaction, include steps specific to upgrade transactions.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="abort-upgrade-transaction">
<h3 title="Aborting an upgrade transaction">5.8. 昇格~txの中止-法</h3>

<div class="algo">
<p>
`昇格~txを中止する@
~algoは、
所与の
( `昇格~tx$ %~tx  )
に対し：
◎
To abort an upgrade transaction with transaction, run these steps:
</p>

<p class="note">注記：
この手続きは，`~txを中止-$する手続き内で必要に応じて走らされ、
`~db$に`専属する$［
`保管庫$／`索引$
］たちが成す集合, および
`~version$db変更を復帰させる。
【~APIに公開される部分を復帰させる。】
◎
NOTE: These steps are run as needed by the steps to abort a transaction, which revert changes to the database including the set of associated object stores and indexes, as well as the change to the version.
</p>

<ol>
	<li>
%接続 ~LET %~tx が`専属する$`接続$
◎
Let connection be transaction’s connection.
</li>
	<li>
%~db ~LET %接続↗
◎
Let database be connection’s database.
</li>
	<li>
<p>
%接続 の`~version$Cn ~SET %~db の`~version$db
（ %~tx が %~db を新たに作成したのであれば 0 ）
◎
Set connection’s version to database’s version if database previously existed, or 0 (zero) if database was newly created.
</p>

<p class="note">注記：
これは、
`IDBDatabase!I ~objから返される `version$m 値を復帰させる。
◎
NOTE: This reverts the value of version returned by the IDBDatabase object.
</p>

	</li>
	<li>
<p>
%接続 の`保管庫~集合$Cn ~SET %~db に`専属する$`保管庫$たちが成す集合
（ %~tx が %~db を新たに作成したのであれば 空~集合 ）
◎
Set connection’s object store set to the set of object stores in database if database previously existed, or the empty set if database was newly created.
</p>

<p class="note">注記：
これは、
`IDBDatabase!I ~objから返される `objectStoreNames$m 値を復帰させる。
◎
NOTE: This reverts the value of objectStoreNames returned by the IDBDatabase object.
</p>
	</li>
	<li>
<p>
この段において反復される~handleたちには、
その`~access先$が %~tx により削除-または作成されたものも含まれることに注意。
◎
↓</p>

<p>
%~tx に`専属する$
~EACH( `保管庫~handle$ %H )
に対し：
◎
For each object store handle handle associated with transaction, including those for object stores that were created or deleted during transaction:
</p>
		<ol>
			<li>
~IF［
%H↗ は %~tx により作成されたものではない
］
⇒
%H の`名前$OsH ~SET %H↗ の`名前$Os
◎
If handle’s object store was not newly created during transaction, set handle’s name to its object store’s name.
</li>
			<li>
<p>
%H の`索引~集合$OsH ~SET %H↗ に`専属する$`索引$たちが成す集合
◎
Set handle’s index set to the set of indexes that reference its object store.
</p>

<div class="note">
<p>注記：
これは、
%H （を表現する `IDBObjectStore!I ~obj）が返す［
`name$m, `indexNames$m
］値を復帰させる。
◎
NOTE: This reverts the values of name and indexNames returned by related IDBObjectStore objects.
</p>

<p>
~scriptは、
%~tx が中止されて以降も，依然として自身が有する %H の［
`name$m ／ `indexNames$m
］属性は~queryできる
— %~tx の
<!-- `IDBTransaction!I -->`objectStore()$m ~methodを利用しても， %H↗ には~accessできなくなるが。
◎
How is this observable?
◎
Although script cannot access an object store by using the objectStore() method on an IDBTransaction instance after the transaction is aborted, it can still have references to IDBObjectStore instances where the name and indexNames properties can be queried.
</p>
</div>
			</li>
			<li>
<p>
%H に`専属する$
~EACH( `索引~handle$ %I )
に対し：
◎
For each index handle handle associated with transaction, including those for indexes that were created or deleted during transaction:
</p>
		<ol>
			<li>
~IF［
%I↗ は %~tx により作成されたものではない
］
⇒
%I の`名前$IxH ~SET %I↗ の`名前$Ix
◎
If handle’s index was not newly created during transaction, set handle’s name to its index’s name.
</li>
		</ol>

<div class="note">

<p>注記：
これは、
%I （を表現する `IDBIndex!I ~obj）が返す `name$m 値を復帰させる。
◎
NOTE: This reverts the value of name returned by related IDBIndex objects.
</p>

<p>
~scriptは、
%~tx が中止されて以降も，自身が有する %I の `name$m 属性は~queryできる
— %H の
<!-- `IDBObjectStore!I -->`index()$m ~methodを利用しても， %I↗ には~accessできなくなるが。
◎
How is this observable?
◎
Although script cannot access an index by using the index() method on an IDBObjectStore instance after the transaction is aborted, it can still have references to IDBIndex instances where the name property can be queried.
</p>
</div>
			</li>
		</ol>
	</li>
</ol>
</div>

<p class="note">注記：
［
%接続 を表現する `IDBDatabase!I ~instance
］の `name$m は、
中止された`昇格~tx$が新たな`~db$を作成していたとしても，`値を保ち続ける$。
◎
NOTE: The name property of the IDBDatabase instance is not modified, even if the aborted upgrade transaction was creating a new database.
</p>

		</section>
		<section id="fire-success-event">
<h3 title="Firing a success event">5.9. `success^et ~eventの発火-法</h3>

<div class="algo">
<p>
`~success~eventを発火する@
~algoは、
所与の
( `要請$ %要請 )
に対し：
◎
To fire a success event at a request, run these steps:
</p>

<ol>
	<li>
%~event ~LET `~eventを作成する$( `Event$I )
◎
Let event be the result of creating an event using Event.
</li>
	<li>
%~event の各種~属性を次のように初期化する
⇒＃
`type$m ~SET `success^l,
`bubbles$m ~SET ~F,
`cancelable$m ~SET ~F
◎
• Set event’s type attribute to "success".
• Set event’s bubbles and cancelable attributes to false.
</li>
	<li>
%~tx ~LET %要請 の`設置-先~tx$
◎
Let transaction be request’s transaction.
◎
↓Let legacyOutputDidListenersThrowFlag be initially false.
</li>
	<li>
~IF［
%~tx の`状態$tx ~EQ `非作動中$i
］
⇒
%~tx の`状態$tx ~SET `作動中$i
◎
If transaction’s state is inactive, then set transaction’s state to active.
</li>
	<li>
%~listenerは投出したか ~LET `Dispatch$( %要請, %~event )
◎
Dispatch event at request with legacyOutputDidListenersThrowFlag.
</li>
	<li>
~IF［
%~tx の`状態$tx ~NEQ `作動中$i
］
⇒
~RET
◎
If transaction’s state is active, then:
</li>
	<li>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</li>
	<li>
~IF［
%~listenerは投出したか ~EQ ~T
］
⇒
`~txを中止する$( %~tx, `新たな例外$( `AbortError$E ) )
◎
If legacyOutputDidListenersThrowFlag is true, then run abort a transaction with transaction and a newly created "AbortError" DOMException.
</li>
	<li>
~IF［
%~tx の`要請~list$は空である
］
⇒
`~txを~commitする$( %~tx )
◎
If transaction’s request list is empty, then run commit a transaction with transaction.
</li>
</ol>
</div>

		</section>
		<section id="fire-error-event">
<h3 title="Firing an error event">5.10. `error^et ~eventの発火-法</h3>

<div class="algo">
<p>
`~error~eventを発火する@
~algoは、
所与の
( `要請$ %要請 )
に対し：
◎
To fire an error event at a request, run these steps:
</p>

<ol>
	<li>
%~event ~LET `~eventを作成する$( `Event$I )
◎
Let event be the result of creating an event using Event.
</li>
	<li>
%~event の各種~属性を次のように初期化する
⇒＃
`type$m ~SET `error^l,
`bubbles$m ~SET ~T,
`cancelable$m ~SET ~T
◎
• Set event’s type attribute to "error".
• Set event’s bubbles and cancelable attributes to true.
</li>
	<li>
%~tx ~LET %要請 の`設置-先~tx$
◎
Let transaction be request’s transaction.
◎
↓Let legacyOutputDidListenersThrowFlag be initially false.
</li>
	<li>
~IF［
%~tx の`状態$tx ~EQ `非作動中$i
］
⇒
%~tx の`状態$tx ~SET `作動中$i
◎
If transaction’s state is inactive, then set transaction’s state to active.
</li>
	<li>
%~listenerは投出したか ~LET `Dispatch$( %要請, %~event )
◎
Dispatch event at request with legacyOutputDidListenersThrowFlag.
</li>
	<li>
~IF［
%~tx の`状態$tx ~NEQ `作動中$i
］
⇒
~RET
◎
If transaction’s state is active, then:
</li>
	<li>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</li>
	<li>
<p>
~IF［
%~listenerは投出したか ~EQ ~T
］：
◎
If legacyOutputDidListenersThrowFlag is true, then＼
</p>
		<ol>
			<li>
`~txを中止する$( %~tx, `新たな例外$( `AbortError$E ) )
◎
run abort a transaction with transaction and a newly created "AbortError" DOMException and＼
</li>
			<li>
~RET
◎
terminate these steps.＼
</li>
		</ol>
<p>
この段は、［
%~event の`取消されたか$ev ~EQ ~F
］の下でも行われる。
◎
This is done even if event’s canceled flag is false.
</p>

<div class="note">
<p>注記：
すなわち、
`error$et ~eventの配送-時に，いずれかの~event~handlerから例外が投出されたときは：
</p>
		<ul>
			<li>
~eventが `preventDefault()$m の~callにより取消されようが されまいが，~txは中止される。
</li>
			<li>
~tx上の `error^m 属性には、
要請の`~error$に代わって， `AbortError$E 例外が利用される。
</li>
		</ul>
◎
NOTE: This means that if an error event is fired and any of the event handlers throw an exception, transaction’s error property is set to an AbortError rather than request’s error, even if preventDefault() is never called.
</div>
	</li>
	<li>
~IF［
%~event の`取消されたか$ev ~EQ ~F
］
⇒＃
`~txを中止する$( %~tx, %要請 の`~error$ )；
~RET
◎
If event’s canceled flag is false, then run abort a transaction using transaction and request’s error, and terminate these steps.
</li>
	<li>
~IF［
%~tx の`要請~list$は空である
］
⇒
`~txを~commitする$( %~tx )
◎
If transaction’s request list is empty, then run commit a transaction with transaction.
</li>
</ol>
</div>

		</section>
		<section id="clone-value">
<h3 title="Clone a value">5.11. 値の~clone法</h3>

<div class="algo">
<p>
`~txの間に値を~cloneする@
~algoは、
所与の
( %値, `~tx$ %~tx )
に対し：
◎
To make a clone of value in targetRealm during transaction, run these steps:
</p>

<p class="note">注記：
値を複製するわけは：
値は格納-時に【 `StructuredSerializeForStorage$jA により】直列化されるが，この手続きを用いて複製として扱うことにより、
この仕様~内の他の~algoは，それを~JS値として扱えるようになる。
実装は、
異なる挙動が観測され得ないならば，これを最適化できる。
【！ https://github.com/w3c/IndexedDB/commit/4ccf4371e3e1a32a6f3ab1606605e71a8f4f8334】
<!-- 
Let targetRealm be a user-agent defined Realm.
Let clone be a clone of value in targetRealm during transaction. Rethrow any exceptions.
Why create a copy of the value?
• The value is serialized when stored. Treating it as a copy here allows other algorithms in this specification to treat it as an ECMAScript value, but implementations can optimize this if the difference in behavior is not observable.
 -->
</p>

<ol>
	<li>
%宛先~realm ~LET ~UAにより定義される`~realm$
【この訳では、この手続きを利用している各所の記述を集約するため，この段と上の注記をここに追加している。】
</li>
	<li>
~Assert：
%~tx の`状態$tx ~EQ `作動中$i
◎
Assert: transaction’s state is active.
</li>
	<li>
<p>
%~tx の`状態$tx ~SET `非作動中$i
◎
Set transaction’s state to inactive.
</p>

<p class="note">注記：
%~tx を `非作動中$i にするのは、
~cloneする演算により誘発される取得子その他の副作用が，
%~tx に対し追加の要請を為せないようにするためである。
◎
NOTE: The transaction is made inactive so that getters or other side effects triggered by the cloning operation are unable to make additional requests against the transaction.
</p>
	</li>
	<li>
%直列形 ~LET ~ABRUPT `StructuredSerializeForStorage$jA( %値 )
◎
Let serialized be ? StructuredSerializeForStorage(value).
</li>
	<li>
%~clone ~LET ~ABRUPT `StructuredDeserialize$jA( %直列形, %宛先~realm )
◎
Let clone be ? StructuredDeserialize(serialized, targetRealm).
</li>
	<li>
%~tx の`状態$tx ~SET `作動中$i
◎
Set transaction’s state to active.
</li>
	<li>
~RET %~clone
◎
Return clone.
</li>
</ol>
</div>

		</section>
		<section id="create-request-to-retrieve-multiple-items">
<h3 title="Creating a request to retrieve multiple items">5.12. 複数個の~itemを検索取得する要請の作成-法</h3>

<div class="algo">
<p>
`複数個の~itemを検索取得する要請を作成する@
~algoは、
所与の
⇒＃
`~realm$ %宛先~realm,
［ `保管庫~handle$／`索引~handle$ ］ %~source~handle,
%種類,
%queryOrOptions,
負でない整数 %count ~DF ε
◎終
に対し：
◎
To create a request to retrieve multiple items from an object store or index with targetRealm, sourceHandle, kind, queryOrOptions, and optional count, run these steps:
</p>
<ol>
	<li>
`状態を検査する$( %~source~handle ) ？
◎
Let source be an index or an object store from sourceHandle. If sourceHandle is an index handle, then source is the index handle’s associated index. Otherwise, source is the object store handle’s associated object store.
◎
If source has been deleted, throw an "InvalidStateError" DOMException.
◎
If source is an index and source’s object store has been deleted, throw an "InvalidStateError" DOMException.
◎
Let transaction be sourceHandle’s transaction.
◎
If transaction’s state is not active, then throw a "TransactionInactiveError" DOMException.
</li>
	<li>
%query ~LET %queryOrOptions
◎
↓</li>
	<li>
%方向 ~LET `next$l
◎
↓</li>
	<li>
<p>
~IF［
`妥当な~key範囲になり得るか否か$( %queryOrOptions ) ~EQ ~F
］：
</p>
		<ol>
			<li>
%query ~SET %queryOrOptions[ "`query$mb" ]
</li>
			<li>
%count ~SET %queryOrOptions[ "`count$mb" ]
</li>
			<li>
%方向 ~SET %queryOrOptions[ "`direction$mb" ]
</li>
		</ol>
◎
Let range be a key range.
◎
Let direction be a cursor direction.
◎
If running is a potentially valid key range with queryOrOptions is true, then:
• Set range to the result of converting a value to a key range with queryOrOptions. Rethrow any exceptions.
• Set direction to "next".
◎
Else:
• Set range to the result of converting a value to a key range with queryOrOptions["query"]. Rethrow any exceptions.
• Set count to queryOrOptions["count"].
• Set direction to queryOrOptions["direction"].
</li>
	<li>
%範囲 ~SET `~key範囲へ変換する$( %query ) ？
◎
↑</li>
	<li>
%~algo ~LET %~source~handle↗ に応じて
⇒＃
`索引$であるならば`索引から複数個の~itemを検索取得する$／
`保管庫$であるならば`保管庫から複数個の~itemを検索取得する$
◎
Let operation be an algorithm to run.
◎
If source is an index, set operation to retrieve multiple items from an index with targetRealm, source, range, kind, direction, and count if given.
◎
Else set operation to retrieve multiple items from an object store with targetRealm, source, range, kind, direction, and count if given.
</li>
	<li>
<p>
~RET `要請を非同期に実行する$( %~source~handle, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
%~algo( ↓ )
⇒＃
%宛先~realm,
%~source~handle↗,
%範囲,
%種類,
%方向,
%count
</div>
◎
Return the result (an IDBRequest) of running asynchronously execute a request with sourceHandle and operation.
</li>
		</ol>
<p class="note">注記：
%範囲 に入る`~record$たちが検索取得されることになる
— %query が［
~NULL ／ ε
］になる場合は，`全範囲$が利用される。
%count ~NEQ ε になる場合、
%方向 に依存して［
最初／最後
］から %count 個までの~recordに限り検索取得されることになる。
◎
NOTE: The range can be a key or key range (an IDBKeyRange) identifying the record items to be retrieved. If null or not given, an unbounded key range is used. If count is specified and there are more than count records in range, only the first count will be retrieved.
</p>
</div>

		</section>
	</section>
	<section id="database-operations">
<h2 title="Database operations">6. 各種~db演算</h2>

<p>
この節では、［
`保管庫$内の~data／`~db$内の`索引$
］にて行われる各種 演算について述べる。
これらの演算は、
`要請を非同期に実行する$ことにより走ることになる。
◎
This section describes various operations done on the data in object stores and indexes in a database. These operations are run by the steps to asynchronously execute a request.
</p>

<p class="note">注記：
以下の各種 演算の手続きにおける `StructuredDeserialize$jA() からは、
（ `~NOABRUPT$ 接頭辞で指示されるとおり）
例外は投出されない
— 演算する~dataは、
`StructuredSerializeForStorage$jA() から出力されたものに限られるので。
◎
NOTE: Invocations of StructuredDeserialize() in the operation steps below can be asserted not to throw (as indicated by the ! prefix) because they operate only on previous output of StructuredSerializeForStorage().
</p>

		<section id="object-store-storage-operation">
<h3 title="Object store storage operation">6.1. 保管庫における~storage演算</h3>

<div class="algo">
<p>
`保管庫に~recordを格納する@
~algoは、
所与の
( `保管庫$ %保管庫, `値$ %値, `~key$ %~key ~DF ε, %上書不可か ~IN { `上書不可^i, ε } ~DF ε )
に対し：
◎
To store a record into an object store with store, value, an optional key, and a no-overwrite flag, run these steps:
</p>

<ol>
	<li>
%生成器 ~LET %保管庫 の`~key生成器$
◎
↓</li>
	<li>
%~key~path ~LET %保管庫 の`~key~path$Os
◎
↓</li>
	<li>
<p>
~IF［
%生成器 ~NEQ ε
］：
◎
If store uses a key generator, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~key ~EQ ε
］：
◎
If key is undefined, then:
</p>
				<ol>
					<li>
%~key ~LET `保管庫~用の~keyを生成する$( %保管庫 )
◎
Let key be the result of generating a key for store.
</li>
					<li>
~IF［
%~key ~EQ `失敗^i
］
⇒
~RET `新たな例外$( `ConstraintError$E )
◎
If key is failure, then this operation failed with a "ConstraintError" DOMException. Abort this algorithm without taking any further steps.
</li>
					<li>
~IF［
%~key~path ~NEQ ε
］
⇒
`~keyを値の中へ注入する$( %値, %~key, %保管庫 の`~key~path$Os )
◎
If store also uses in-line keys, then run inject a key into a value using a key path with value, key and store’s key path.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
`保管庫~用の~key生成器を可能なら更新する$( %保管庫, %~key )
◎
Otherwise, run possibly update the key generator for store with key.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%保管庫 の`~record~list$Os内に［
`~key$ ~EQ~cmpkey %~key
］を満たす`~record$は在る
］
◎
↓</p>
		<ol>
			<li>
~IF［
%上書不可か ~EQ `上書不可^i
］
⇒
~RET `新たな例外$( `ConstraintError$E )
◎
If the no-overwrite flag was given to these steps and is true, and a record already exists in store with its key equal to key, then this operation failed with a "ConstraintError" DOMException. Abort this algorithm without taking any further steps.
</li>
			<li>
`保管庫から~recordを削除する$( %保管庫, `~keyのみを包含する範囲$( %~key ) )
◎
If a record already exists in store with its key equal to key, then remove the record from store using delete records from an object store.
</li>
		</ol>
	</li>
	<li>
%保管庫 の`~record~list$Osに
~record｛ %~key ： ~NOABRUPT `StructuredSerializeForStorage$jA( %値 ) ｝
を格納する
— それに伴い，~listの~recordたちを~keyの`昇順$で~sortし直すことになる。
◎
Store a record in store containing key as its key and ! StructuredSerializeForStorage(value) as its value. The record is stored in the object store’s list of records such that the list is sorted according to the key of the records in ascending order.
</li>
	<li>
<p>
%保管庫 に`専属する$
~EACH( `索引$ %索引 )
に対し：
◎
For each index which references store:
</p>
		<ol>
			<li>
%~key集合 ~LET
`値から~key集合を抽出する$( %値,  %索引 の`~key~path$Ix, %索引 の`複-~entryか$Ix )
◎
Let index key be the result of extracting a key from a value using a key path with value, index’s key path, and index’s multiEntry flag.
</li>
			<li>
~IF［
%~key集合 ~EQ `失敗^i
］
⇒
~CONTINUE
◎
If index key is an exception, or invalid, or failure, take no further actions for index, and continue these steps for the next index.
◎
NOTE: An exception thrown in this step is not rethrown.
</li>
			<li>
<p>
~IF［
%索引 の`一意か$Ix ~EQ ~T
］~AND［
%索引 の`~record~list$Ix内に［
`~key$ ~IN~cmpkey %~key集合
］を満たす`~record$は在る
］
⇒
~RET `新たな例外$( `ConstraintError$E )
◎
If index’s multiEntry flag is false, or if index key is not an array key, and if index already contains a record with key equal to index key, and index’s unique flag is true, then this operation failed with a "ConstraintError" DOMException. Abort this algorithm without taking any further steps.
◎
If index’s multiEntry flag is true and index key is an array key, and if index already contains a record with key equal to any of the subkeys of index key, and index’s unique flag is true, then this operation failed with a "ConstraintError" DOMException. Abort this algorithm without taking any further steps.
</p>

<p class="trans-note">【
この手続きを呼び出した要請は失敗とされ、
`要請を非同期に実行する$手続きに従って，ここまでの改変は復帰されることになる。
したがって、
索引たちを反復する順序も，結果には影響しない。
】</p>

			</li>
			<li>
<p>
%~key集合 を成す
~EACH( %索引~key )
に対し
⇒
%索引 の`~record~list$Ix内に
新たな~record｛ %索引~key ： %~key ｝
を格納する
— それに伴い、
~record~listは 先ず~keyの`昇順$に~sortした上で，~keyが等しい~recordたちを値の`昇順$に~sortすることになる。
◎
If index’s multiEntry flag is false, or if index key is not an array key then store a record in index containing index key as its key and key as its value. The record is stored in index’s list of records such that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending order.
◎
If index’s multiEntry flag is true and index key is an array key, then for each subkey of the subkeys of index key store a record in index containing subkey as its key and key as its value. The records are stored in index’s list of records such that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending order.
</p>

<p class="note">注記：
%~key集合 が空でも妥当である
— その場合、
索引に追加される~recordは無い。
◎
NOTE: It is valid for there to be no subkeys. In this case no records are added to the index.
◎
NOTE: Even if any member of subkeys is itself an array key, the member is used directly as the key for the index record. Nested array keys are not flattened or "unpacked" to produce multiple rows; only the outer-most array key is.
</p>

			</li>
		</ol>
【この段の訳は、再構成により，原文より簡素化している（`値から~key集合を抽出する$を見よ）。】

	</li>
	<li>
~RET %~key
◎
Return key.
</li>
</ol>
</div>

		</section>
		<section id="_retrieval-operations">
<h3>6.A. 保管庫／索引から検索取得する演算</h3>

<p class="trans-note">【
この訳では、
原文の［
§ 6.2, § 6.3
］にて定義される一部の~algoを［
入力を成す［
%~source, %種類
］に関する場合分け
］により，一括して定義する。
】</p>

<div class="algo">
<p>
`範囲に入る最初の~entryを検索取得する@
~algoは、
所与の
⇒＃
`~realm$ %宛先~realm,
［`保管庫$／`索引$］ %~source,
`~key範囲$ %範囲,
%種類 ~IN { `~key^i, `値^i }
◎終
に対し：
</p>

<ol>
	<li>
%~record ~LET %~source の~record~list内に［
`~key$ ~IN~cmpkey %範囲
］を満たす`~record$は［
在るならば それらのうち最初のもの／
無いならば ε
］
</li>
	<li>
~IF［
%~record ~EQ ε
］
⇒
~RET ε
</li>
	<li>
~IF［
%~source は`索引$である
］
⇒
%~record ~SET %~record の`参照先~record$
</li>
	<li>
<p>
%種類 に応じて：
</p>
		<ul class="switch">
			<li>
`~key^i
⇒
~RET `~keyを値に変換する$( %~record の`~key$ )
</li>
			<li>
<p>
`値^i：
</p>
				<ol>
					<li>
<p>
%値 ~LET %~record の`値$
</p>

<p>
下層~storageから値を読取る間に~errorが生じたときは
⇒
~RET `新たな例外$( `NotReadableError$E )
</p>

<p class="trans-note">【
原文は、
%~source が`索引$である場合に，この取扱いを指定していない（なぜ？）。
】</p>
					</li>
					<li>
~RET
~NOABRUPT `StructuredDeserialize$jA( %値, %宛先~realm )
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
◎
↓</div>

		</section>
		<section id="object-store-retrieval-operation">
<h3 title="Object store retrieval operations">6.2. 保管庫から検索取得する演算</h3>

<div>
<p class="trans-note">【
この節に定義される［
`保管庫から値を検索取得する＠retrieve-a-value-from-an-object-store@,
`保管庫から~keyを検索取得する＠retrieve-a-key-from-an-object-store@
］~algoは、
`範囲に入る最初の~entryを検索取得する$
~algoに集約した。
】</p>
◎
To retrieve a value from an object store with targetRealm, store and range, run these steps. They return undefined, an ECMAScript value, or an error (a DOMException):
• Let record be the first record in store’s list of records whose key is in range, if any.
• If record was not found, return undefined.
• Let serialized be record’s value. If an error occurs while reading the value from the underlying storage, return a newly created "NotReadableError" DOMException.
• Return ! StructuredDeserialize(serialized, targetRealm).
◎
To retrieve a key from an object store with store and range, run these steps:
• Let record be the first record in store’s list of records whose key is in range, if any.
• If record was not found, return undefined.
• Return the result of converting a key to a value with record’s key.
</div>

<div class="algo">
<p>
`保管庫から複数個の~itemを検索取得する@
~algoは、
所与の
⇒＃
`~realm$ %宛先~realm,
`保管庫$ %保管庫,
`~key範囲$ %範囲,
%種類,
文字列 %方向,
負でない整数 %count ~DF ε
◎終
に対し：
◎
To retrieve multiple items from an object store with targetRealm, store, range, kind, direction, and optional count, run these steps:
</p>
<ol>
	<li>
~IF［
%count ~IN { ε, 0 }
］
⇒
%count ~LET 無限大
◎
If count is not given or is 0 (zero), let count be infinity.
</li>
	<li>
%範囲~record群 ~LET %保管庫 の`~record~list$Os内の［
`~key$ ~IN~cmpkey %範囲
］を満たす`~record$たちが成す同順な`~list$
◎
↓</li>
	<li>
<p>
%~record群 ~LET %方向 に応じて：
</p>
		<ul class="switch">
			<li>
`next$l ／ `nextunique$l
⇒
%範囲~record群 を成す最初から %count 個までの~recordたちが成す同順な`~list$
</li>
			<li>
`prev$l ／ `prevunique$l
⇒
%範囲~record群 を成す最後から %count 個までの~recordたちが成す同順な`~list$
</li>
		</ul>
◎
Let records be an empty list of records.
◎
If direction is "next" or "nextunique", set records to the first count of store’s list of records whose key is in range.
◎
If direction is "prev" or "prevunique", set records to the last count of store’s list of records whose key is in range.
</li>
	<li>
%~list ~LET « »
◎
Let list be an empty list.
</li>
	<li>
<p>
%~record群 を成す
~EACH( %~record )
に対し：
◎
For each record of records, switching on kind:
</p>
		<ol>
			<li>
<p>
%~item ~LET %種類 に応じて：
</p>
				<ul class="switch">
					<li>
`~key^i
⇒
`~keyを値に変換する$( %~record の`~key$ )
◎
"key"
• Let key be the result of converting a key to a value with record’s key.
• Append key to list.
</li>
					<li>
`値^i
⇒
~NOABRUPT `StructuredDeserialize$jA( %~record の`値$, %宛先~realm )
◎
"value"
• Let serialized be record’s value.
• Let value be ! StructuredDeserialize(serialized, targetRealm).
• Append value to list.
</li>
					<li>
`~record^i
⇒
新たな`~record~snapshot$
— その
⇒＃
`~key$rS ~SET %~record の`~key$
`値$rS ~SET ~NOABRUPT `StructuredDeserialize$jA( %~record の`値$, %宛先~realm ),
`首key$rS ~SET %~record の`~key$
◎
"record"
• Let key be the record’s key.
• Let serialized be record’s value.
• Let value be ! StructuredDeserialize(serialized, targetRealm).
• Let recordSnapshot be a new record snapshot with its key set to key, value set to value, and primary key set to key.
• Append recordSnapshot to list.
</li>
				</ul>
			</li>
			<li>
%~list に %~item を`付加する$
◎
↑</li>
		</ol>
	</li>
	<li>
~RET %~list
◎
Return list.
</li>
</ol>
</div>

		</section>
		<section id="index-retrieval-operation">
<h3 title="Index retrieval operations">6.3. 索引から検索取得する演算</h3>

<div>
<p class="trans-note">【
この節に定義される［
`索引から参照先~recordの~keyを検索取得する＠retrieve-a-referenced-value-from-an-index@,
`索引から参照先~recordの値を検索取得する＠retrieve-a-value-from-an-index@
］~algoは、
`範囲に入る最初の~entryを検索取得する$
~algoに集約した。
】</p>
◎
To retrieve a referenced value from an index with targetRealm, index and range, run these steps:
• Let record be the first record in index’s list of records whose key is in range, if any.
• If record was not found, return undefined.
• Let serialized be record’s referenced value.
• Return ! StructuredDeserialize(serialized, targetRealm).
◎
To retrieve a value from an index with index and range, run these steps:
• Let record be the first record in index’s list of records whose key is in range, if any.
• If record was not found, return undefined.
• Return the result of converting a key to a value with record’s value.
</div>

<div class="algo">
<p>
`索引から複数個の~itemを検索取得する@
~algoは、
所与の
⇒＃
`~realm$ %宛先~realm,
`索引$ %索引,
`~key範囲$ %範囲,
%種類,
文字列 %方向,
負でない整数 %count ~DF ε
◎終
に対し：
◎
To retrieve multiple items from an index with targetRealm, index, range, kind, direction and optional count, run these steps:
</p>
<ol>
	<li>
~IF［
%count ~IN { ε, 0 }
］
⇒
%count ~LET 無限大
◎
If count is not given or is 0 (zero), let count be infinity.
</li>
	<li>
%範囲~record群 ~LET %索引 の`~record~list$Ix内の［
`~key$ ~IN~cmpkey %範囲
］を満たす`~record$たちが成す同順な`~list$
◎
↓</li>
	<li>
<p>
~IF［
%方向 ~IN { `nextunique$l, `prevunique$l }
］：
</p>
		<ol>
			<li>
%現在の~key ~LET ε
</li>
			<li>
<p>
%範囲~record群 を成す
~EACH( %~record )
に対し：
</p>
				<ol>
					<li>
~IF［
%現在の~key ~NEQ ε
］~AND［
%~record の`~key$ ~EQ~cmpkey %現在の~key
］
⇒
%範囲~record群 から %~record を除去する
</li>
					<li>
%現在の~key ~SET %~record の`~key$
</li>
				</ol>
			</li>
		</ol>

<p class="trans-note">【
以下を単純~化するため、
この訳では，前~段とこの段を追加する。
加えて、
原文では `prevunique$l の場合に最後からでなく最初から（ %count 個までを）収集しているが，
明らかに誤りであろう。
】</p>
◎
↓</li>
	<li>
<p>
%~record群 ~LET %方向 に応じて：
◎
Let records be an empty list of records.
◎
Switching on direction:
</p>
		<ul class="switch">
			<li>
`next$l ／ `nextunique$l
⇒
%範囲~record群 を成す最初から %count 個までの~recordたちが成す同順な`~list$
◎
"next"
• Set records to the first count of index’s list of records whose key is in range.
◎
"nextunique"
• Let rangeRecords be a list containing the index’s list of records whose key is in range.
• Let rangeRecordsLength be rangeRecords’s size.
• Let i be 0.
• While i is less than rangeRecordsLength, then:
•• Increase i by 1.
•• if record’s size is equal to count, then break.
•• If the result of comparing two keys using the keys from |rangeRecords[i]| and |rangeRecords[i-1]| is equal, then continue.
•• Else append |rangeRecords[i]| to records.
</li>
			<li>
`prev$l ／ `prevunique$l
⇒
%範囲~record群 を成す最後から %count 個までの~recordたちが成す同順な`~list$
◎
"prev"
• Set records to the last count of index’s list of records whose key is in range.
◎
"prevunique"
• Let rangeRecords be a list containing the index’s list of records whose key is in range.
• Let rangeRecordsLength be rangeRecords’s size.
• Let i be 0.
• While i is less than rangeRecordsLength, then:
•• Increase i by 1.
•• if record’s size is equal to count, then break.
•• If the result of comparing two keys using the keys from |rangeRecords[i]| and |rangeRecords[i-1]| is equal, then continue.
•• Else prepend |rangeRecords[i]| to records.
</li>
		</ul>
	</li>
	<li>
%~list ~LET « »
◎
Let list be an empty list.
</li>
	<li>
<p>
%~record群 を成す
~EACH( %~record )
に対し：
◎
For each record of records, switching on kind:
</p>
		<ol>
			<li>
%参照先 ~LET %~record の`参照先~record$
</li>
			<li>
<p>
%~item ~LET %種類 に応じて：
</p>
				<ul>
					<li>
`~key^i
⇒
`~keyを値に変換する$( %参照先 の`~key$ )
◎
"key"
• Let key be the result of converting a key to a value with record’s value.
• Append key to list.
</li>
					<li>
`値^i
⇒
~NOABRUPT `StructuredDeserialize$jA( %参照先 の`値$, %宛先~realm )
◎
• Let serialized be record’s referenced value.
• Let value be ! StructuredDeserialize(serialized, targetRealm).
• Append value to list.
</li>
					<li>
`~record^i
⇒
新たな`~record~snapshot$
— その
⇒＃
`~key$rS ~SET %~record の`~key$
`値$rS ~SET ~NOABRUPT `StructuredDeserialize$jA( %参照先 の`値$, %宛先~realm )
`首key$rS ~SET %参照先 の`~key$
◎
"record"
• Let index key be the record’s key.
• Let key be the record’s value.
• Let serialized be record’s referenced value.
• Let value be ! StructuredDeserialize(serialized, targetRealm).
• Let recordSnapshot be a new record snapshot with its key set to index key, value set to value, and primary key set to key.
• Append recordSnapshot to list.
</li>
				</ul>
			</li>
			<li>
%~list に %~item を`付加する$
◎
↑</li>
		</ol>
	</li>
	<li>
~RET %~list
◎
Return list.
</li>
</ol>
</div>

<p class="note">注記：
索引~内の`~record$の`値$は、
`参照先~record$の`~key$になる。
◎
The values of a record in an index are the keys of records in the referenced object store.
</p>

		</section>
		<section id="object-store-deletion-operation">
<h3 title="Object store deletion operation">6.4. 保管庫から~recordを削除する演算</h3>

<div class="algo">
<p>
`保管庫から~recordを削除する@
~algoは、
所与の
( `保管庫$ %保管庫, `~key範囲$ %範囲 )
に対し：
◎
To delete records from an object store with store and range, run these steps:
</p>

<ol>
	<li>
%保管庫 の`~record~list$Osから，次を満たす`~record$をすべて除去する
⇒
`~key$ ~IN~cmpkey %範囲
◎
Remove all records, if any, from store’s list of records with key in range.
</li>
	<li>
%保管庫 に`専属する$
~EACH( `索引$ )
に対し
⇒
`索引$の`~record~list$Ixから，次を満たす`~record$をすべて除去する
⇒
`値$ ~IN~cmpkey %範囲
◎
For each index which references store, remove every record from index’s list of records whose value is in range, if any such records exist.
</li>
	<li>
~RET ε
◎
Return undefined.
</li>
</ol>
</div>

		</section>
		<section id="record-counting-operation">
<h3 title="Record counting operation">6.5. 範囲に入る~recordを数える演算</h3>

<div class="algo">
<p>
`範囲に入る~recordを数える@
~algoは、
所与の
( `保管庫$または`索引$ %~source, `~key範囲$ %範囲 )
に対し：
◎
To count the records in a range with source and range, run these steps:
</p>
<ol>
	<li>
~RET %~source の~record~list内の，次を満たす`~record$の総数
⇒
`~key$ ~IN~cmpkey %範囲
◎
Let count be the number of records, if any, in source’s list of records with key in range.
◎
Return count.
</li>
</ol>
</div>

		</section>
		<section id="object-store-clear-operation">
<h3 title="Object store clear operation">6.6. 保管庫を~clearする演算</h3>

<div class="algo">
<p>
`保管庫を~clearする@
~algoは、
所与の
( `保管庫$ %保管庫 )
に対し：
◎
To clear an object store with store, run these steps:
</p>

<ol>
	<li>
%保管庫 の`~record~list$Osからすべての`~record$を除去する
◎
Remove all records from store.
</li>
	<li>
%保管庫 に`専属する$
~EACH( `索引$ %索引 )
に対し
⇒
%索引 の`~record~list$Ixからすべての`~record$を除去する
◎
In all indexes which reference store, remove all records.
</li>
	<li>
~RET ε
◎
Return undefined.
</li>
</ol>
</div>

		</section>
		<section id="_cursor-creation-operation">
<h3 title="Cursor iteration operation">6.B. ~cursorを作成する演算</h3>

<p class="trans-note">【
この訳では、
原文にて繰り~~返し現れる記述をこの節に集約して定義する。
】</p>

<div class="algo">
<p>
`~cursorを作成する@
~algoは、
所与の
⇒＃
`~realm$ %宛先~realm,
［ `保管庫~handle$／`索引~handle$ ］ %~source~handle,
`方向$Cs %方向,
`~key範囲$ %範囲,
%~keyのみ~flag ~IN { `~keyのみ^i, ε } ~DF ε
◎終
に対し，［
~NULL ／`~cursor$
］を返す：
</p>
<ol>
	<li>
%~keyのみか ~LET ~IS［
%~keyのみ~flag ~EQ `~keyのみ^i
］
</li>
	<li>
%~interface ~LET %~keyのみか に応じて
⇒＃
~T ならば `IDBCursor!I ／
~F ならば `IDBCursorWithValue!I
</li>
	<li>
%~cursor ~LET `新たな~obj$( %~interface, %宛先~realm )
</li>
	<li>
%~cursor の
⇒＃
`~source~handle$Cs ~SET %~source~handle,
`範囲$Cs ~SET %範囲,
`方向$Cs ~SET %方向,
`位置$Cs ~SET ε,
`保管庫~位置$Cs ~SET ε,
`~key$Cs ~SET ε,
`値$Cs ~SET ε,
`値は取得-済みか$Cs ~SET ~F,
`~keyのみか$Cs ~SET %~keyのみか
</li>
	<li>
~RET `~cursorを反復する$( %宛先~realm, %~cursor )
</li>
</ol>
</div>

		</section>
		<section id="cursor-iteration-operation">
<h3 title="Cursor iteration operation">6.7. ~cursorを反復する演算</h3>

<div class="algo">
<p>
`~cursorを反復する@
~algoは、
所与の
⇒＃
`~realm$ %宛先~realm,
`~cursor$ %~cursor,
移動先の`~key$ %~key ~DF ε,
保管庫における移動先の`~key$ %首key ~DF ε,
反復する回数 %count ~DF ε
◎終
に対し：
◎
To iterate a cursor with targetRealm, cursor, an optional key and primaryKey to iterate to, and an optional count, run these steps:
</p>

<ol>
	<li>
%~source ~LET %~cursor の`~source~handle$Cs↗
◎
Let source be cursor’s source.
</li>
	<li>
%方向 ~LET %~cursor の`方向$Cs
◎
Let direction be cursor’s direction.
</li>
	<li>
~Assert：
［
%首key ~EQ ε
］~OR［［
%~source は`索引$である
］~AND［
%方向 ~IN { `next^l, `prev^l }
］］
◎
Assert: if primaryKey is given, source is an index and direction is "next" or "prev".
</li>
	<li>
<p>
%~record群 ~LET %~source 内の すべての~recordたちが成す~list
◎
Let records be the list of records in source.
</p>

<p class="note">注記：
%~record群 は常に`~key$の昇順で~sortされる。
%~source が`索引$である場合、
それに加えて，同じ`~key$を有する~recordたちは，それらの`値$
（すなわち， ~recordの`参照先~record$の`~key$）
の`昇順$でも~sortされる。
◎
NOTE: records is always sorted in ascending key order. In the case of source being an index, records is secondarily sorted in ascending value order (where the value in an index is the key of the record in the referenced object store).
</p>
	</li>
	<li>
%範囲 ~LET %~cursor の`範囲$Cs
◎
Let range be cursor’s range.
</li>
	<li>
%位置 ~LET %~cursor の`位置$Cs
◎
Let position be cursor’s position.
</li>
	<li>
%保管庫~位置 ~LET %~cursor の`保管庫~位置$Cs
◎
Let object store position be cursor’s object store position.
</li>
	<li>
~IF［
%count ~EQ ε
］
⇒
%count ~SET 1
◎
If count is not given, let count be 1.
</li>
	<li>
%~record ~LET ε
◎
↓</li>
	<li>
<p>
（この段は、
%~record群 から一つの~recordに絞り込む）：
</p>
		<ol>
			<li>
%~record群 から［
`~key$ ~NIN~cmpkey %範囲
］を満たす~recordすべてを除去する
</li>
			<li>
~IF［
%位置 ~NEQ ε
］：
				<ol>
					<li>
<p>
~IF［
%~source は`保管庫$である
］~OR［
%方向 ~IN { `nextunique$l, `prevunique$l }
］
⇒
%~record群 から［
%方向 に応じて，次に与える条件
］を満たす~recordすべてを除去する：
</p>

<dl class="switch">
	<dt>`next$l</dt>
	<dt>`nextunique$l</dt>
	<dd>
`~key$ ~LTE~cmpkey %位置
</dd>
	<dt>`prev$l</dt>
	<dt>`prevunique$l</dt>
	<dd>
`~key$ ~GTE~cmpkey %位置
</dd>
</dl>
					</li>
					<li>
<p>
~ELSE
⇒
%~record群 から［
%方向 に応じて，次に与える条件
］を満たす~recordすべてを除去する：
</p>
<dl class="switch">
	<dt>`next$l</dt>
	<dd>
( `~key$, `値$ ) ~LTE~cmpkey ( %位置, %保管庫~位置 )
</dd>

	<dt>`prev$l</dt>
	<dd>
( `~key$, `値$ ) ~GTE~cmpkey ( %位置, %保管庫~位置 )
</dd>
</dl>
					</li>
					<li>
<p>
~IF［
%~key ~NEQ ε
］
</p>
						<ol>
							<li>
<p>
~IF［
%首key ~EQ ε
］
⇒
%~record群 から［
%方向 に応じて，次に与える条件
］を満たす~recordすべてを除去する：
</p>
<dl class="switch">
	<dt>`next$l</dt>
	<dt>`nextunique$l</dt>
	<dd>
`~key$ ~LT~cmpkey %~key
</dd>
	<dt>`prev$l</dt>
	<dt>`prevunique$l</dt>
	<dd>
`~key$ ~GT~cmpkey %~key
</dd>
</dl>
							</li>
							<li>
<p>
~ELSE
⇒
%~record群 から［
%方向 に応じて，次に与える条件
］を満たす~recordすべてを除去する：
</p>
<dl class="switch">
	<dt>`next$l</dt>
	<dd>
( `~key$, `値$ ) ~LT~cmpkey ( %~key, %首key )
</dd>
	<dt>`prev$l</dt>
	<dd>
( `~key$, `値$ ) ~GT~cmpkey ( %~key, %首key )
</dd>
</dl>
							</li>
						</ol>
					</li>
				</ol>
			<li>
~IF［
%方向 ~IN { `nextunique$l, `prevunique$l }
］
⇒
%~record群 を成す
~EACH( ~keyが互いに`等しい$一群の~record )
に対し
⇒
それらのうち，最初のもの以外の~recordすべてを %~record群 から除去する
【！Iterating with "prevunique" visits the same records that "nextunique" visits, but in reverse order.】
</li>
			<li>
<p>
~IF［
%~record群 を成す~recordの個数 ~LT %count
］：
</p>
				<ol>
					<li>
~IF［
%方向 ~IN { `next$l, `nextunique$l }
］
⇒
%~record ~SET %~record群 内の最初から %count 個目の~record
</li>
					<li>
~ELSE（ %方向 ~IN { `prev$l, `prevunique$l } ）
⇒
%~record ~SET %~record群 内の最後から %count 個目の~record
</li>
				</ol>
			</li>
		</ol>

<div lang="en" class="_en">
<p>
While count is greater than 0:
</p>
		<ol>
			<li>
<p>
Switch on direction:
</p>
				<dl class="switch">
					<dt>"next"</dt>
					<dd>
◎
Let found record be the first record in records which satisfy all of the following requirements:
• If key is defined:
•• The record’s key is greater than or equal to key.
• If primaryKey is defined:
•• The record’s key is equal to key and the record’s value is greater than or equal to primaryKey
•• The record’s key is greater than key.
• If position is defined and source is an object store:
•• The record’s key is greater than position.
• If position is defined and source is an index:
•• The record’s key is equal to position and the record’s value is greater than object store position
•• The record’s key is greater than position.
• The record’s key is in range.
</dd>

					<dt>"nextunique"</dt>
					<dd>
◎
Let found record be the first record in records which satisfy all of the following requirements:
• If key is defined:
•• The record’s key is greater than or equal to key.
• If position is defined:
•• The record’s key is greater than position.
• The record’s key is in range.
</dd>

					<dt>"prev"</dt>
					<dd>
◎
Let found record be the last record in records which satisfy all of the following requirements:
• If key is defined:
•• The record’s key is less than or equal to key.
• If primaryKey is defined:
•• The record’s key is equal to key and the record’s value is less than or equal to primaryKey
•• The record’s key is less than key.
• If position is defined and source is an object store:
•• The record’s key is less than position.
• If position is defined and source is an index:
•• The record’s key is equal to position and the record’s value is less than object store position
• The record’s key is less than position.
• The record’s key is in range.
</dd>

					<dt>"prevunique"</dt>
					<dd>
◎
Let temp record be the last record in records which satisfy all of the following requirements:
• If key is defined:
•• The record’s key is less than or equal to key.
• If position is defined:
•• The record’s key is less than position.
• The record’s key is in range.
◎
If temp record is defined, let found record be the first record in records whose key is equal to temp record’s key.
◎
NOTE: Iterating with "prevunique" visits the same records that "nextunique" visits, but in reverse order.
</dd>
				</dl>
			</li>
			<li>
◎
↓↓ If found record is not defined, then:
• Set cursor’s key to undefined.
• If source is an index, set cursor’s object store position to undefined.
• If cursor’s key only flag is false, set cursor’s value to undefined.
• Return null.
</li>
			<li>
Let position be found record’s key.
</li>
			<li>
If source is an index, let object store position be found record’s value.
</li>
			<li>
Decrease count by 1.
</li>
		</ol>
</div>

	</li>
	<li>
<p>
~IF［
%~record ~EQ ε
］：
</p>
		<ol>
			<li>
%~cursor の`~key$Cs ~SET ε
</li>
			<li>
~IF［
%~source は`索引$である
］
⇒
%~cursor の`保管庫~位置$Cs ~SET ε
</li>
			<li>
~IF［
%~cursor の`~keyのみか$Cs ~EQ ~F
］
⇒
%~cursor の`値$Cs ~SET ε
</li>
			<li>
~RET ~NULL
</li>
		</ol>
◎
↑</li>
	<li>
%~cursor の`位置$Cs ~SET %~record の`~key$
◎
Set cursor’s position to position.
</li>
	<li>
~IF［
%~source は`索引$である
］
⇒
%~cursor の`保管庫~位置$Cs ~SET %~record の`値$
◎
If source is an index, set cursor’s object store position to object store position.
</li>
	<li>
%~cursor の`~key$Cs ~SET %~record の`~key$
◎
Set cursor’s key to found record’s key.
</li>
	<li>
<p>
~IF［
%~cursor の`~keyのみか$Cs ~EQ ~F
］：
◎
If cursor’s key only flag is false, then:
</p>
		<ol>
			<li>
%直列形 ~LET %~source に応じて
⇒＃
`保管庫$であるならば %~record の`値$ ／
`索引$であるならば %~record の`参照先~record$の`値$
◎
Let serialized be found record’s value if source is an object store, or found record’s referenced value otherwise.
</li>
			<li>
%~cursor の`値$Cs ~SET ~NOABRUPT `StructuredDeserialize$jA( %直列形, %宛先~realm )
◎
Set cursor’s value to ! StructuredDeserialize(serialized, targetRealm)
</li>
		</ol>
	</li>
	<li>
%~cursor の`値は取得-済みか$Cs ~SET ~T
◎
Set cursor’s got value flag to true.
</li>
	<li>
~RET %~cursor
◎
Return cursor.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="binding">
<h2 title="ECMAScript binding">7. ~JS言語束縛</h2>

<p>
この節では、
この仕様にて定義された`~key$値を［
~JS値に変換する／その逆向きに変換する
］方法, および
`~key~path$を利用して`~key$を~JS値の［
中から抽出する／中へ注入する
］方法を定義する。
この節では、
~JS言語~仕様 `ECMA-262$r の各種
型／~algo
を参照し，いくつかの`~algo表記規約＠~TC39#sec-algorithm-conventions$†を利用する。
ここで述べない変換の詳細は `WEBIDL$r にて定義される。
◎
This section defines how key values defined in this specification are converted to and from ECMAScript values, and how they may be extracted from and injected into ECMAScript values using key paths. This section references types and algorithms and uses some algorithm conventions from the ECMAScript Language Specification. [ECMA-262] Conversions not detailed here are defined in [WEBIDL].
</p>

<p class="trans-note">【†
概ね、
~algo内の抽象-演算（ `Get^jA() など）の前に現れる記号 ~NOABRUPT, ~ABRUPT を指す。
大雑把に言えば、
~NOABRUPT は 例外が生じ得ることを表し，
~ABRUPT は 例外は決して生じないことを表す。
~NOABRUPT, ~ABRUPT とも付与されていない場合、
一般に，明示的な例外の取扱い，または表明（ ~Assert ）を要する。
】</p>

		<section id="extract-key-from-value">
<h3 title="Extract a key from a value">7.1. 値から~keyを抽出する</h3>

<div>
<div class="algo">
<p>
`値から~keyを抽出する@
~algoは、
所与の
( `値$ %値, `~key~path$ %~key~path )
に対し，［
`~key$／`失敗^i／`無効な値^i
］を返すか例外を投出する：
</p>
<ol>
	<li>
%r ~LET `~key~pathを評価する$( %値, %~key~path ) ？
</li>
	<li>
~IF［
%r ~EQ `失敗^i
］
⇒
~RET %r
</li>
	<li>
%~key ~LET `値を~keyに変換する$( %r ) ？
</li>
	<li>
~IF［
%~key ~EQ `無効な型^i
］
⇒
~RET `無効な値^i
</li>
	<li>
~RET %~key
</li>
</ol>
</div>

<div class="algo">
<p>
`値から~key集合を抽出する@
~algoは、
所与の
( `値$ %値, `~key~path$ %~key~path, 真偽値 %複-~entryか )
に対し，［
`~key$たちが成す集合 ／ `失敗^i
］を返す
— 以下の中で例外が投出される所では、
`失敗^i を返すとする：
</p>
<ol>
	<li>
%r ~LET `~key~pathを評価する$( %値, %~key~path ) ？
</li>
	<li>
~IF［
%r ~EQ `失敗^i
］
⇒
~RET `失敗^i
</li>
	<li>
~IF［
%複-~entryか ~EQ ~T
］~AND［
%r は`~Array~exotic~obj$である
］
⇒
~RET `配列を~key集合に変換する$( %r ) ？
</li>
	<li>
%~key ~LET `値を~keyに変換する$( %r ) ？
</li>
	<li>
~IF［
%~key ~IN { `無効な値^i, `無効な型^i }
］
⇒
~RET `失敗^i
</li>
	<li>
~RET %~key のみからなる集合
</li>
</ol>
</div>

◎
To extract a key from a value using a key path with value, keyPath and an optional multiEntry flag, run the following steps. The result of these steps is a key, invalid, or failure, or the steps may throw an exception.
◎
Let r be the result of evaluating a key path on a value with value and keyPath. Rethrow any exceptions.
◎
If r is failure, return failure.
◎
Let key be the result of converting a value to a key with r if the multiEntry flag is false, and the result of converting a value to a multiEntry key with r otherwise. Rethrow any exceptions.
◎
If key is "invalid value" or "invalid type", return invalid.
◎
Return key.
</div>

<p class="trans-note">【
［
`値から~keyを抽出する$,
`値から~key集合を抽出する$
］は、
原文では一つの~algoとして定義されているが，この訳では 2 つに分離している。
そうした方が、
依存関係の見通しが良くなるので
（それに伴い、
原文による `配列を~key集合に変換する$ ~algoを成す一部もこの手続きの中へ移動している）。
原文における `値から~key集合を抽出する$ ~algoに該当する部分は，`配列~key$を返しているが、
この訳では，単に~keyたちが成す集合を返すよう改める。
その配列~keyは一時的にしか利用されておらず
（また，実際に重複もなく順序も有意でない）、
そうした方が，この手続きを利用している箇所
（`保管庫に~recordを格納する$手続きの中で，索引を拡充するとき）
の記述も簡明になるので。
】</p>

<div class="algo">
<p>
`~key~pathを評価する@
~algoは、
所与の
( `値$ %値, `~key~path$ %~key~path )
に対し，［
~JS値／`失敗^i
］を返すか例外を投出する：
◎
To evaluate a key path on a value with value and keyPath, run the following steps. The result of these steps is an ECMAScript value or failure, or the steps may throw an exception.
</p>

<p class="trans-note">【
返り値 `失敗^i は、
%値 の中に %~key~path が指す部位が無いことを表す。
】</p>

<ol>
	<li>
<p>
~IF［
%~key~path は文字列たちが成す`~list$である
］：
◎
If keyPath is a list of strings, then:
</p>
		<ol>
			<li>
%結果 ~LET 
式 `[]^jv で作成されるものと同じ，新たな `Array$jT ~obj
◎
Let result be a new Array object created as if by the expression [].
</li>
			<li>
%i ~LET 0
◎
Let i be 0.
</li>
			<li>
<p>
%~key~path を成す
~EACH( %~item )
に対し：
◎
For each item of keyPath:
</p>
				<ol>
					<li>
%~key ~LET `~key~pathを評価する$( %値, %~item ) †
【！原文は引数順序が逆】
◎
Let key be the result of recursively evaluating a key path on a value with item and value.
◎
Assert: key is not an abrupt completion.
</li>
					<li>
~IF［
%~key ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If key is failure, abort the overall algorithm and return failure.
</li>
					<li>
%p ~LET ~NOABRUPT `ToString$jA( %i )
◎
Let p be ! ToString(i).
</li>
					<li>
%状態s ~LET `CreateDataProperty$jA( %結果, %p, %~key )
◎
Let status be CreateDataProperty(result, p, key).
</li>
					<li>
~Assert： %状態s ~EQ ~T
◎
Assert: status is true.
</li>
					<li>
%i ~INCBY 1
◎
Increase i by 1.
</li>
				</ol>
			</li>
			<li>
~RET %結果
◎
Return result.
</li>
		</ol>

<p class="note">注記（†）：
これは、
一階層のみ “再帰する”
— `~key~path$ 連列は入子にできないので。
◎
NOTE: This will only ever "recurse" one level since key path sequences can’t ever be nested.
</p>
	</li>
	<li>
~IF［
%~key~path ~EQ 空~文字列
］
⇒
~RET %値
【！ この段は不要 】
◎
If keyPath is the empty string, return value and skip the remaining steps.
</li>
	<li>
%識別子~list ~LET
`区切子で厳密に分割する$( %~key~path, `002E^U (`.^l) )
◎
Let identifiers be the result of strictly splitting keyPath on U+002E FULL STOP characters (.).
</li>
	<li>
<p>
%識別子~list を成す
~EACH( %識別子 )
に対し
◎
For each identifier of identifiers, jump to the appropriate step below:
</p>
		<ol>
			<li>
<p>
~IF［
下の表t内に
( %値 が満たす条件, %識別子 )
に該当する行は在る
］
⇒
%値 ~LET 同じ行の “結果” の列に与える値
</p>

<table class="_row"><thead>
<tr><th>%値 が満たす条件
<th>%識別子
<th>結果
<tbody>

<tr><td>`Type$jA( %値 ) ~EQ `String$jT
<td>`length^l
<td>%値 の`長さ$str【！the number of elements in】に等しい `Number$jT 値

<tr><td>`Array$jT である
<td>`length^l
<td>~NOABRUPT `ToLength$jA( ~NOABRUPT `Get$jA( %値, `length^l ) )

<tr><td>`Blob$I である
<td>`size^l
<td>%値 の `size$mF に等しい `Number$jT 値

<tr><td>`Blob$I である
<td>`type^l
<td>%値 の `type$mF に等しい `String$jT 値

<tr><td>`File$I である
<td>`name^l
<td>%値 の `name$mF に等しい `String$jT 値

<tr><td>`File$I である
<td>`lastModified^l
<td>%値 の `lastModified$mF に等しい `Number$jT 値
</table>

<p class="trans-note">【
`File^I であるならば `Blob^I でもあることに注意。
】</p>

◎
If Type(value) is String, and identifier is "length"
• Let value be a Number equal to the number of elements in value.
◎
If value is an Array and identifier is "length"
• Let value be ! ToLength(! Get(value, "length")).
◎
If value is a Blob and identifier is "size"
• Let value be a Number equal to value’s size.
◎
If value is a Blob and identifier is "type"
• Let value be a String equal to value’s type.
◎
If value is a File and identifier is "name"
• Let value be a String equal to value’s name.
◎
If value is a File and identifier is "lastModified"
• Let value be a Number equal to value’s lastModified.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise
</p>
				<ol>
					<li>
~IF［
`Type$jA( %値 ) ~NEQ `Object$jT
］
⇒
~RET `失敗^i
◎
If Type(value) is not Object, return failure.
</li>
					<li>
%hop ~LET ~NOABRUPT `HasOwnProperty$jA( %値, %識別子 )
◎
Let hop be ! HasOwnProperty(value, identifier).
</li>
					<li>
~IF［
%hop ~EQ `false^jv
］
⇒
~RET `失敗^i
◎
If hop is false, return failure.
</li>
					<li>
%値 ~LET ~NOABRUPT `Get$jA( %値, %識別子 )
◎
Let value be ! Get(value, identifier).
</li>
					<li>
~IF［
%値 ~EQ `undefined^jv
］
⇒
~RET `失敗^i
◎
If value is undefined, return failure.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~Assert：
%値 は`中途完了$でない
◎
Assert: value is not an abrupt completion.
</li>
	<li>
~RET %値
◎
Return value.
</li>
</ol>

<p class="note">注記：
この~algoが適用される値は，
`StructuredDeserialize$jA からの出力であり,
“自前の” ~propのみに~accessするので、
上の手続きにおける ~Assert は満たされる。
◎
NOTE: Assertions can be made in the above steps because this algorithm is only applied to values that are the output of StructuredDeserialize and only access "own" properties.
</p>
</div>

		</section>
		<section id="inject-key-into-value">
<h3 title="Inject a key into a value">7.2. ~keyを値の中へ注入する</h3>

<p class="note">注記：
この節で利用される`~key~path$は、
常に文字列であり，決して連列（ `~SeqDS$ ）にはならなない
— `~key生成器$を有する, かつ`~key~path$Osは連列にされた`保管庫$は作成し得ないので。
◎
NOTE: The key paths used in this section are always strings and never sequences, since it is not possible to create a object store which has a key generator and also has a key path that is a sequence.
</p>

<div class="algo">
<p>
`~keyを値の中へ注入できるか検査する@
~algoは、
所与の
( %値, %~key~path )
に対し，真偽値を返す：
◎
To check that a key could be injected into a value with value and a keyPath, run the following steps. The result of these steps is either true or false.
</p>

<ol>
	<li>
%識別子~list ~LET
`区切子で厳密に分割する$( %~key~path, `002E^U (`.^l) )
◎
Let identifiers be the result of strictly splitting keyPath on U+002E FULL STOP characters (.).
</li>
	<li>
~Assert：
%識別子~list は空でない
◎
Assert: identifiers is not empty.
</li>
	<li>
%識別子~list から最後の`~item$を`除去する$
◎
Remove the last item of identifiers.
</li>
	<li>
<p>
%識別子~list を成す
~EACH( %識別子 )
に対し：
◎
For each remaining identifier of identifiers, if any:
</p>
		<ol>
			<li>
~IF［
%値 は［
`Object$jT, `Array$jT
］のいずれでもない
］
⇒
~RET ~F
◎
If value is not an Object or an Array, return false.
</li>
			<li>
%hop ~LET ~NOABRUPT `HasOwnProperty$jA( %値, %識別子 )
◎
Let hop be ! HasOwnProperty(value, identifier).
</li>
			<li>
~IF［
%hop ~EQ `false^jv
］
⇒
~RET ~T
◎
If hop is false, return true.
</li>
			<li>
%値 ~LET ~NOABRUPT `Get$jA( %値, %識別子 )
◎
Let value be ! Get(value, identifier).
</li>
		</ol>
	</li>
	<li>
~RET ~IS［
%値 は［
`Object$jT ／ `Array$jT
］である
］
◎
Return true if value is an Object or an Array, or false otherwise.
</li>
</ol>

<p class="note">注記：
この~algoが適用される値は，
`StructuredDeserialize$jA からの出力なので、
上の手続きにおける ~Assert は満たされる。
◎
NOTE: Assertions can be made in the above steps because this algorithm is only applied to values that are the output of StructuredDeserialize.
</p>
</div>

<div class="algo">
<p>
`~keyを値の中へ注入する@
~algoは、
所与の
( `値$ %値, `~key$ %~key, `~key~path$Os %~key~path )
に対し：
◎
To inject a key into a value using a key path with value, a key and a keyPath, run these steps:
</p>

<ol>
	<li>
%識別子~list ~LET
`区切子で厳密に分割する$( %~key~path, `002E^U (`.^l) )
◎
Let identifiers be the result of strictly splitting keyPath on U+002E FULL STOP characters (.).
</li>
	<li>
~Assert：
%識別子~list は空でない
◎
Assert: identifiers is not empty.
</li>
	<li>
%最後の識別子 ~LET %識別子~list の最後の`~item$
◎
Let last be the last item of identifiers＼
</li>
	<li>
%識別子~list から最後の`~item$を`除去する$
◎
and remove it from the list.
</li>
	<li>
<p>
%識別子~list を成す
~EACH( %識別子 )
に対し：
◎
For each remaining identifier of identifiers:
</p>
		<ol>
			<li>
~Assert
%値 は［
`Object$jT, `Array$jT
］のいずれかである
◎
Assert: value is an Object or an Array.
</li>
			<li>
%hop ~LET ~NOABRUPT `HasOwnProperty$jA( %値, %識別子 )
◎
Let hop be ! HasOwnProperty(value, identifier).
</li>
			<li>
<p>
~IF［
%hop ~EQ `false^jv
］：
◎
If hop is false, then:
</p>
				<ol>
					<li>
%o ~LET 
式 `({})^jv で作成されるものと同じ，新たな `Object$jT
◎
Let o be a new Object created as if by the expression ({}).
</li>
					<li>
%状態s ~LET `CreateDataProperty$jA( %値, %識別子, %o )
◎
Let status be CreateDataProperty(value, identifier, o).
</li>
					<li>
~Assert：
%状態s ~EQ `true^jv
◎
Assert: status is true.
</li>
				</ol>
			</li>
			<li>
%値 ~LET ~NOABRUPT `Get$jA( %値, %識別子 )
◎
Let value be ! Get(value, identifier).
</li>
		</ol>
	</li>
	<li>
~Assert：
%値 は `Object$jT または `Array$jT である
◎
Assert: value is an Object or an Array.
</li>
	<li>
%~key値 ~LET `~keyを値に変換する$( %~key )
◎
Let keyValue be the result of converting a key to a value with key.
</li>
	<li>
%状態s ~LET
`CreateDataProperty$jA( %値, %最後の識別子, %~key値 )
◎
Let status be CreateDataProperty(value, last, keyValue).
</li>
	<li>
~Assert：
%状態s ~EQ `true^jv
◎
Assert: status is true.
</li>
</ol>

<p class="note">注記：
この~algoが適用される値は、
`StructuredDeserialize$jA からの出力であり，`~keyを値の中へ注入できるか検査-＠#check-that-a-key-could-be-injected-into-a-value$した後なので、
上の手続きにおける ~Assert は満たされる。
◎
NOTE: Assertions can be made in the above steps because this algorithm is only applied to values that are the output of StructuredDeserialize, and the steps to check that a key could be injected into a value have been run.
</p>
</div>

		</section>
		<section id="convert-key-to-value">
<h3 title="Convert a key to a value">7.3. ~keyを値に変換する</h3>

<div class="algo">
<p>
`~keyを値に変換する@
~algoは、
所与の
( `~key$ %~key )
に対し，~JS値を返す：
◎
To convert a key to a value with key, run the following steps. The steps return an ECMAScript value.
</p>

<ol>
	<li>
%値 ~LET %~key の`値$key
◎
Let type be key’s type.
◎
Let value be key’s value.
</li>
	<li>
<p>
%~key の`型$keyに応じて：
◎
Switch on type:
</p>
		<dl class="switch">
			<dt>`number$i</dt>
			<dd>
~RET %値 に等しい~JS `Number$jT 値
◎
Return an ECMAScript Number value equal to value
</dd>
			<dt>`string$i</dt>
			<dd>
~RET %値 に等しい~JS `String$jT 値
◎
Return an ECMAScript String value equal to value
</dd>
			<dt>`date$i</dt>
			<dd>
				<ol>
					<li>
%日付 ~LET
~JS `Date$jT 構築子を ( %値 ) を引数に実行した結果
◎
Let date be the result of executing the ECMAScript Date constructor with the single argument value.
</li>
					<li>
~Assert：
%日付 は`中途完了$でない
◎
Assert: date is not an abrupt completion.
</li>
					<li>
~RET %日付
◎
Return date.
</li>
				</ol>
			</dd>

			<dt>`binary$i</dt>
			<dd>
				<ol>
					<li>
%~buffer ~LET
~JS `ArrayBuffer$I 構築子を ( %値 の`長さ$byte ) を引数に実行した結果
◎
Let len be value’s length.
◎
Let buffer be the result of executing the ECMAScript ArrayBuffer constructor with len.
</li>
					<li>
~Assert：
%~buffer は`中途完了$でない
◎
Assert: buffer is not an abrupt completion.
</li>
					<li>
%~buffer の `ArrayBufferData^sl 内部~slot内の~entryたち ~SET %値 の~entryたち
◎
Set the entries in buffer’s [[ArrayBufferData]] internal slot to the entries in value.
</li>
					<li>
~RET %~buffer
◎
Return buffer.
</li>
				</ol>
			</dd>

			<dt>`array$i</dt>
			<dd>
				<ol>
					<li>
%配列 ~LET
~JS `Array$jT 構築子を引数なしで実行した結果
◎
Let array be the result of executing the ECMAScript Array constructor with no arguments.
</li>
					<li>
~Assert：
%配列 は`中途完了$でない
◎
Assert: array is not an abrupt completion.
</li>
					<li>
<p>
~EACH( 整数 %~index ~IN { 0 〜 %値 の`~size$ ~MINUS 1 } )
に対し，昇順に：
◎
Let len be value’s size.
◎
Let index be 0.
◎
While index is less than len:
</p>
						<ol>
							<li>
%~entry ~LET `~keyを値に変換する$( %値[ %~index ] )
◎
Let entry be the result of converting a key to a value with value[index].
</li>
							<li>
%状態s ~LET
`CreateDataProperty$jA( %配列, %~index, %~entry )
◎
Let status be CreateDataProperty(array, index, entry).
</li>
							<li>
~Assert：
%状態s ~EQ ~T
◎
Assert: status is true.
◎
Increase index by 1.
</li>
						</ol>
					</li>
					<li>
~RET %配列
◎
Return array.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>
</div>

		</section>
		<section id="convert-value-to-key">
<h3 title="Convert a value to a key">7.4. 値を~keyに変換する</h3>

<div class="algo">
<p>
`値を~keyに変換する@
~algoは、
所与の
( ~JS値 %入力, `集合$ %seen )
に対し，［
`~key$／`無効な値^i／`無効な型^i
］を返すか例外を投出する：
◎
To convert a value to a key with an ECMAScript value input, and an optional set seen, run the following steps. The result of these steps is a key, or "invalid value", or "invalid type", or the steps may throw an exception.
</p>

<p class="trans-note">【
%seen は［
%入力 が配列であるときに，自身を入子にしているかどうか検査する
］ために利用される。
】</p>

<ol>
	<li>
~IF［
%seen ~EQ ε
］
⇒
%seen ~SET 新たな`集合$
◎
If seen was not given, then let seen be a new empty set.
</li>
	<li>
~IF［
%入力 ~IN %seen
］
⇒
~RET `無効な値^i
◎
If seen contains input, then return "invalid value".
</li>
	<li>
<p>
~IF［
`Type$jA( %入力 ) ~EQ `Number$jT
］：
◎
Jump to the appropriate step below:
◎
If Type(input) is Number
</p>
		<ol>
			<li>
~IF［
%入力 ~EQ `NaN^jv
］
⇒
~RET `無効な値^i
◎
If input is NaN then return "invalid value".
</li>
			<li>
~RET 新たな`~key$
— その
⇒＃
`型$key ~SET `number$i,
`値$key ~SET %入力
◎
Otherwise, return a new key with type number and value input.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%入力 は `Date$jT ~objである
（ `DateValue^sl 内部~slotを有する）
］：
◎
If input is a Date (has a [[DateValue]] internal slot)
</p>
		<ol>
			<li>
%ms ~LET %入力 の `DateValue^sl 内部~slotの値
◎
Let ms be the value of input’s [[DateValue]] internal slot.
</li>
			<li>
~IF［
%ms ~EQ `NaN^jv
］
⇒
~RET `無効な値^i
◎
If ms is NaN then return "invalid value".
</li>
			<li>
~RET 新たな`~key$
— その
⇒＃
`型$key ~SET `date$i,
`値$key ~SET %ms
◎
Otherwise, return a new key with type date and value ms.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
`Type$jA( %入力 ) ~EQ `String$jT
］
⇒
~RET 新たな`~key$
— その
⇒＃
`型$key ~SET `string$i,
`値$key ~SET %入力
◎
If Type(input) is String
• Return a new key with type string and value input.
</li>
	<li>
<p>
~ELIF［
%入力 は`~buffer~source型$である
］
◎
If input is a buffer source type
</p>
		<ol>
			<li>
~IF［
%入力 は`切離されて$いる
］
⇒
~RET `無効な値^i
◎
If input is detached then return "invalid value".
</li>
			<li>
%~byte列 ~LET %入力 に`保持された~byte列の複製を取得する$
◎
Let bytes be the result of getting a copy of the bytes held by the buffer source input.
</li>
			<li>
~RET 新たな`~key$
— その
⇒＃
`型$key ~SET `binary$i,
`値$key ~SET %~byte列
◎
Return a new key with type binary and value bytes.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%入力 は`~Array~exotic~obj$である
］：
◎
If input is an Array exotic object
</p>
		<ol>
			<li>
%長さ ~LET ~ABRUPT `ToLength$jA( ~ABRUPT `Get$jA( %入力, `length^l))
◎
Let len be ? ToLength( ? Get(input, "length")).
</li>
			<li>
%seen に %入力 を`付加する$
◎
Append input to seen.
</li>
			<li>
%~key群 ~LET 新たな`~list$
◎
Let keys be a new empty list.
</li>
			<li>
<p>
~EACH( 整数 %~index ~IN { 0 〜 %長さ ~MINUS 1 } )
に対し，昇順に：
◎
Let index be 0.
◎
While index is less than len:
</p>
				<ol>
					<li>
%hop ~LET ~ABRUPT `HasOwnProperty$jA( %入力, %~index )
◎
Let hop be ? HasOwnProperty(input, index).
</li>
					<li>
~IF［
%hop ~EQ `false^jv
］
⇒
~RET `無効な値^i
◎
If hop is false, return "invalid value".
</li>
					<li>
%~entry ~LET ~ABRUPT `Get$jA( %入力, %~index )
◎
Let entry be ? Get(input, index).
</li>
					<li>
%~key ~LET `値を~keyに変換する$( %~entry, %seen ) ？
◎
Let key be the result of converting a value to a key with arguments entry and seen.
◎
ReturnIfAbrupt(key).
</li>
					<li>
~IF［
%~key ~IN { `無効な値^i, `無効な型^i }
］
⇒
~RET `無効な値^i
◎
If key is "invalid value" or "invalid type" abort these steps and return "invalid value".
</li>
					<li>
%~key群 に %~key を`付加する$
◎
Append key to keys.
◎
Increase index by 1.
</li>
				</ol>
			</li>
			<li>
~RET 新たな`~key$
— その
⇒＃
`型$key ~SET `array$i,
`値$key ~SET %~key群
◎
Return a new array key with value keys.
</li>
		</ol>
	</li>
	<li>
~RET `無効な型^i
◎
Otherwise
• Return "invalid type".
</li>
</ol>
</div>

<div class="algo">
<p>
`配列を~key集合に変換する@
~algoは、
所与の
( ~JS `Array$jT 値 %配列 )
に対し，`~key$たちが成す集合を返すか例外を投出する：
◎
To convert a value to a multiEntry key with an ECMAScript value input, run the following steps.＼
↑↑ The result of these steps is a key, or "invalid value", or "invalid type", or the steps may throw an exception.
• ↑↑ If input is an Array exotic object, then:
</p>
<ol>
	<!-- Array -->
	<li>
%長さ ~LET ~ABRUPT `ToLength$jA( ~ABRUPT `Get$jA( %配列, `length^l))
◎
Let len be ? ToLength( ? Get(input, "length")).
</li>
	<li>
%seen ~LET %配列 のみからなる新たな`集合$
◎
Let seen be a new set containing only input.
</li>
	<li>
%~key群 ~LET 新たな`集合$
◎
Let keys be a new empty list.
</li>
	<li>
%~index ~LET 0
◎
Let index be 0.
</li>
	<li>
<p>
~WHILE ( %~index ~LT %長さ )
：
◎
While index is less than len:
</p>
		<ol>
			<li>
%~entry ~LET `Get$jA( %配列, %~index )
◎
Let entry be Get(input, index).
</li>
			<li>
<p>
~IF［
%~entry は`中途完了$でない
］：
◎
If entry is not an abrupt completion, then:
</p>
				<ol>
					<li>
%~key ~LET `値を~keyに変換する$( %~entry, %seen ) ？
◎
Let key be the result of converting a value to a key with arguments entry and seen.
</li>
					<li>
~IF［
%~key は`中途完了$でない
］~AND［
%~key ~NIN { `無効な値^i, `無効な型^i }
］~AND［
%~key ~NIN~cmpkey %~key群
］
⇒
%~key を %~key群 に`付加する$set
◎
If key is not "invalid value" or "invalid type" or an abrupt completion, and there is no item in keys equal to key, then append key to keys.
</li>
				</ol>
			</li>
			<li>
%~index ~INCBY 1
◎
Increase index by 1.
</li>
		</ol>
	</li>
	<li>
~RET %~key群
◎
Return a new array key with value set to keys.
</li>
</ol>
</div>

<div class="note">
<p>
この手続きは、
`~key$へ変換できない~memberは無視した上で, 重複するものを除去する。
◎
Otherwise, return the result of converting a value to a key with argument input. Rethrow any exceptions.
◎
NOTE: These steps are similar to those to convert a value to a key but if the top-level value is an Array then members which can not be converted to keys are ignored, and duplicates are removed.
</p>

<p>
例えば配列
`[10, 20, null, 30, 20]^jv
は、
`~key$たちが成す集合 { 10, 20, 30 } に変換される。
◎
For example, the value [10, 20, null, 30, 20] is converted to an array key with subkeys 10, 20, 30.
</p>
</div>

		</section>
	</section>
	<section id="privacy">
<h2 title="Privacy considerations">8. ~privacyの考慮点</h2>

◎非規範的

		<section id="user-tracking">
<h3 title="User tracking">8.1. 利用者の追跡</h3>

<p>
第三者-主体~host
（あるいは、
複数の~siteに配布される内容を取得する能力がある任意の~obj）
は、
その~client側~db内に格納された一意な識別子を利用して，複数~sessionにわたって利用者を追跡した上で，利用者の活動について~profileを築くこともできる。
利用者の本当の~~識別情報を知る~site
（例えば、
認証-済み資格証を要求する電子商取引~site）
と組み合わされれば、
どこかの圧政的団体が，純粋に匿名な~webの用法より ずっと正確aに各個人を~targetにすることも可能になる。
◎
A third-party host (or any object capable of getting content distributed to multiple sites) could use a unique identifier stored in its client-side database to track a user across multiple sessions, building a profile of the user’s activities. In conjunction with a site that is aware of the user’s real id object (for example an e-commerce site that requires authenticated credentials), this could allow oppressive groups to target individuals with greater accuracy than in a world with purely anonymous Web usage.
</p>

<p>
利用者~追跡の~riskを軽減するために利用できる，いくつもの技法がある：
◎
There are a number of techniques that can be used to mitigate the risk of user tracking:
</p>

<dl>
	<dt>
第三者-主体による~storageを阻止する
◎
Blocking third-party storage
</dt>
	<dd>
~UAは、
~db~objへの~accessを［
<span>閲覧~文脈</span>の~top-level文書の~domainを出自にする~script
］に制約してもヨイ
—
一例として， `iframe^e 内で稼働している他の~domainからの~pageに対しては~APIへの~accessを否認するなど。
◎
User agents may restrict access to the database objects to scripts originating at the domain of the top-level document of the browsing context, for instance denying access to the API for pages from other domains running in iframes.
</dd>

	<dt>
格納された~dataを失効させる
◎
Expiring stored data
</dt>
	<dd>
<p>
~UAは、
格納された~dataを一定期間~後に自動的に削除してもヨイ。
◎
User agents may automatically delete stored data after a period of time.
</p>

<p>
これは、
~siteが利用者を追跡する能を制約し得る
— ~siteは、
~site自身が利用者を認証する
（例：購入や~serviceへの~log-in時など）
以外にも，利用者を複数~sessionにわたって追跡できなくする。
◎
This can restrict the ability of a site to track a user, as the site would then only be able to track the user across multiple sessions when she authenticates with the site itself (e.g. by making a purchase or logging in to a service).
</p>

<p>
しかしながら一方で、
利用者の~dataも~riskに晒す。
◎
However, this also puts the user’s data at risk.
</p>
	</dd>

	<dt>
持続的な~storageを~cookieと同様に扱う
◎
Treating persistent storage as cookies
</dt>
	<dd>
~UAは、
~db特能を~HTTP~session~cookie `COOKIES$r に強く結付ける仕方で利用者に呈示するべきである。
◎
User agents should present the database feature to the user in a way that associates them strongly with HTTP session cookies. [COOKIES]
</dd>
	<dd>
これは、
利用者が そのような~storageを~~健全な疑いで見ることを促すであろう。
◎
This might encourage users to view such storage with healthy suspicion.
</dd>

	<dt>
~dbへ~accessできる~siteを個別に安全listに入れる
◎
Site-specific safe-listing of access to databases
</dt>
	<dd>
~UAは、
~siteが この仕様の特能を利用できるようになる前に，
~dbへの~accessに対し権限付与することを利用者に要求してもヨイ。
◎
User agents may require the user to authorize access to databases before a site can use the feature.
</dd>

	<dt>
第三者-主体~storageの帰属
◎
Attribution of third-party storage
</dt>
	<dd>
~UAは、
第三者-主体 `生成元$に属する内容を包含している~siteが~dataを格納したときは，
当の`生成元$を記録してもヨイ。
◎
User agents may record the origins of sites that contained content from third-party origins that caused data to be stored.
</dd>
	<dd>
この情報を［
持続的な~storage内にある現在の~data
］を呈示する際に利用すれば、
利用者は，その情報を吟味した上で 持続的な~storageからどの部分を取り除くか裁定を下せるようになる。
これを阻止list
（ “この~dataを削除して，この~domainにこれ以上~dataを格納させない” ）
と組合せれば、
利用者は，持続的な~storageの利用を自身が信用する~siteのみに制約できるようになる。
◎
If this information is then used to present the view of data currently in persistent storage, it would allow the user to make informed decisions about which parts of the persistent storage to prune. Combined with a blocklist ("delete this data and prevent this domain from ever storing data again"), the user can restrict the use of persistent storage to sites that she trusts.
</dd>

	<dt>
共有d阻止list
◎
Shared blocklists
</dt>

	<dd>
~UAは、［
持続的な~storage~domainの阻止listを共有する
］ことを利用者たちに許容してもヨイ。
◎
User agents may allow users to share their persistent storage domain blocklists.
</dd>
	<dd>
これは、
~communityに［
自らの~privacyを~~協同して保護する
］ことを許容する。
◎
This would allow communities to act together to protect their privacy.
</dd>
</dl>

<p>
これらの提言は、
この~APIによる，利用者を追跡するための自明な利用については防止するが、
すべてを阻止できるわけではない。
単独の~domainの中では、
~siteは，［
~sessionの間 利用者を追跡し続けて、
その情報すべてを［
~siteが得した識別情報
（名前, ~credit-card番号, 住所など）
］と一緒に第三者-主体に渡す
］こともできる。
第三者-主体が複数の~siteと協力して，そのような情報を得した場合、
利用者~profileは，依然として作成され得る。
◎
While these suggestions prevent trivial use of this API for user tracking, they do not block it altogether. Within a single domain, a site can continue to track the user during a session, and can then pass all this information to the third party along with any identifying information (names, credit card numbers, addresses) obtained by the site. If a third party cooperates with multiple sites to obtain such information, a profile can still be created.
</p>

<p>
しかしながら，利用者~追跡は、
~UAからの協力が一切なくても，ある~~範囲までアリになる
— 一例として，~URL内に~session識別子を利用するなど。
この技法は、
差し障りない目的で すでに共通的に利用されているが，
利用者~追跡にも容易に（遡及的にすら）転用できる。
しかる後，この情報は、
他~siteと共有され得る
— 訪問者の~IP~addressその他の，利用者に特有な~data
（例： `User-Agent＠~HTTPsem#field.user-agent$h ~headerや環境設定）
を利用して、
別々な~sessionを首尾一貫した利用者~profileを成すように組合せることにより。
◎
However, user tracking is to some extent possible even with no cooperation from the user agent whatsoever, for instance by using session identifiers in URLs, a technique already commonly used for innocuous purposes but easily repurposed for user tracking (even retroactively). This information can then be shared with other sites, using visitors' IP addresses and other user-specific data (e.g. user-agent headers and configuration settings) to combine separate sessions into coherent user profiles.
</p>
		</section>
		<section id="cookie-resurrection">
<h3 title="Cookie resurrection">8.2. ~cookieの復活</h3>

<p>
持続的な~storage用の~UIが、
この仕様に述べた特能による持続的な~storageの~dataを~HTTP~session~cookieの~dataと別々に呈示する場合、
利用者は，一方の~dataしか削除しない見込みが高い。
そうすると、［
2 つの特能を互いの冗長~backupに利用して，
利用者による~privacyを保護する試みを打破する
］ことを~siteに許容することにもなる。
◎
If the user interface for persistent storage presents data in the persistent storage features described in this specification separately from data in HTTP session cookies, then users are likely to delete data in one and not the other. This would allow sites to use the two features as redundant backup for each other, defeating a user’s attempts to protect his privacy.
</p>
		</section>
		<section id="sensitivity-of-data">
<h3 title="Sensitivity of data">8.3. ~dataの敏感~性</h3>

<p>
~UAは、
持続的に格納された~dataを敏感になり得るものとして扱うべきである
— この仕組み内に［
メール／予定表／健康診断記録
］その他の機密的~文書が格納されることは、
ごく普通にあり得る。
◎
User agents should treat persistently stored data as potentially sensitive; it is quite possible for e-mails, calendar appointments, health records, or other confidential documents to be stored in this mechanism.
</p>

<p>
ゆえに、
~UAは，［
~dataを削除するときには，下層の~storageからも即座に削除される
］ことを確保するべきである。
◎
To this end, user agents should ensure that when deleting data, it is promptly deleted from the underlying storage.
</p>
		</section>
	</section>
	<section id="security">
<h2 title="Security considerations">9. ~securityの考慮点</h2>

		<section id="dns-spoofing-attacks">
<h3 title="DNS spoofing attacks">9.1. ~DNS偽装~攻撃</h3>

<p>
~DNS偽装~攻撃の~~可能性があるので、
ある~domainに属すると主張している~hostが本当にその~domainなのかは，保証できない。
これを軽減するため、
~pageは~TLSを利用できる。
~TLSを利用している~pageは、
その~domainの~dbに~accessできる~pageは［
~TLSを利用していて, 同じ~domainを識別する証明書を有するもの
］に限られることを確保できる。
◎
Because of the potential for DNS spoofing attacks, one cannot guarantee that a host claiming to be in a certain domain really is from that domain. To mitigate this, pages can use TLS. Pages using TLS can be sure that only pages using TLS that have certificates identifying them as being from the same domain can access their databases.
</p>
		</section>
		<section id="cross-directory-attacks">
<h3 title="Cross-directory attacks">9.2. ~cross-directory攻撃</h3>

<p>
同じ~host名
— 例えば， `geocities.com^c 【`今や存在しない＠https://en.wikipedia.org/wiki/GeoCities$】 —
を共有している作者たちは、
同じ［
~dbたちが成す集合
］を共有する。
◎
Different authors sharing one host name, for example users hosting content on geocities.com, all share one set of databases.
</p>

<p>
~accessを~URL~pathに基いて制約する特能は無い。
したがって、
共有d~host上の作者には、
これらの特能を利用しないことが推奨される
— 他の作者が，その~dataを読取ったり上書できるのは自明なので。
◎
There is no feature to restrict the access by pathname. Authors on shared hosts are therefore recommended to avoid using these features, as it would be trivial for other authors to read the data and overwrite it.
</p>

<p class="note">注記：
~pathによる制約の特能が可用にされたとしても、
通例の~DOM ~scriptにおける~security~modelの下では，この保護を迂回して任意の~pathから~dataへ~accessすることは自明になる。
◎
NOTE: Even if a path-restriction feature was made available, the usual DOM scripting security model would make it trivial to bypass this protection and access the data from any path.
</p>
		</section>
		<section id="implementation-risks">
<h3 title="Implementation risks">9.3. 実装にあたっての~risk</h3>

<p>
これらの持続的な~storage用の特能を実装するにあたっては、
2 つの首な~risk
— 敵対的~siteが［
他の~domainから情報を読取る ／
情報を書込んで他の~domainに読取らせる
］こと —
がある：
◎
The two primary risks when implementing these persistent storage features are letting hostile sites read information from other domains, and letting hostile sites write information that is then read from other domains.
</p>
<ul>
	<li>
第三者-主体~siteが［
その~domainから読取られるものと~~想定されていない~data
］を読取れるようになると、
`情報~漏洩e^emになる。
例えば、［
ある購買~site~domainにおける利用者の “欲しい物リスト” が，
別の~domainにより~targeted広告に利用される
］あるいは［
文書作成~siteに格納された利用者が作業中な機密的~文書を競合企業~siteが覗き見る
］ことも可能になる。
◎
Letting third-party sites read data that is not supposed to be read from their domain causes information leakage, For example, a user’s shopping wish list on one domain could be used by another domain for targeted advertising; or a user’s work-in-progress confidential documents stored by a word-processing site could be examined by the site of a competing company.
</li>
	<li>
第三者-主体~siteが，他の~domainの持続的な~storageに~dataを書込めるようになると、
`情報~偽装^em（なりすまし）になり，同等に危険である。
例えば、
敵対的~siteは，［
利用者の “欲しい物リスト” に~recordを追加する
］あるいは［
利用者の~session識別子を既知な~IDに設定して，
それを利用して利用者の被害者~siteにおける行動を追跡する
］ことも可能になる。
◎
Letting third-party sites write data to the persistent storage of other domains can result in information spoofing, which is equally dangerous. For example, a hostile site could add records to a user’s wish list; or a hostile site could set a user’s session identifier to a known ID that the hostile site can then use to track the user’s actions on the victim site.
</li>
</ul>

<p>
したがって、
この仕様に述べられる~storage~key~modelに厳密に従うことは、
利用者の~securityにとって重要である。
◎
Thus, strictly following the storage key model described in this specification is important for user security.
</p>

<p>
~file~systemにおける持続性のために，
~host名や~db名を利用して~pathを構築する場合、［
敵対者が［
`../^l などの相対~pathを利用している他の`~storage~key$
］から情報に~accessする
］ことを防止するよう，適切に~escapeするモノトスル。
◎
If host names or database names are used to construct paths for persistence to a file system they must be appropriately escaped to prevent an adversary from accessing information from other storage keys using relative paths such as "../".
</p>

		</section>
		<section id="persistence-risks">
<h3 title="Persistence risks">9.4. 持続性の~risk</h3>

<p>
実用的な実装は、
不揮発~storage媒体に~dataを持続化することになる。
~dataは、
格納-時に直列化され，検索取得-時に逆直列化されることになる
— 直列化~形式の詳細は、
~UAに特有になるが。
~UAの直列化~形式は、
時間~越しに変更される見込みが高い。
例えば、［
新たな~data型を取扱う／処理能を改善する
］ため，形式は更新されることもある。
したがって、
この仕様の運用上の要件を満たすためには、
実装は，何らかの仕方で旧~直列化~形式を取扱えるモノトスル。
旧~dataの不適正な取扱いは、
基本的な直列化の懸念に加えて，~securityの課題にもなり得る。
直列化された旧~dataは、［
~versionが新しくされた~UAの下では妥当でない，形式
］を符号化しかねない。
◎
Practical implementations will persist data to a non-volatile storage medium. Data will be serialized when stored and deserialized when retrieved, although the details of the serialization format will be user-agent specific. User agents are likely to change their serialization format over time. For example, the format may be updated to handle new data types, or to improve performance. To satisfy the operational requirements of this specification, implementations must therefore handle older serialization formats in some way. Improper handling of older data can result in security issues. In addition to basic serialization concerns, serialized data could encode assumptions which are not valid in newer versions of the user agent.
</p>

<p>
実用的な例として、
`RegExp$jT 型が挙げられる
— その型の~objも `StructuredSerializeForStorage$jA 演算で直列化できる。
代表的な~UAは、
入力~dataが渡され, 結果が返される方法を前提に，正規表現を~machineに~nativeな~~命令に~compileすることになる。
この内部~状態が~dbに格納された~dataの一部として直列化されていた場合、
内部~表現が後で逆直列化されるときに様々な問題が生じることもある。
例えば、
~dataが~codeの中へ渡される手段は変更されるかもしれない。
~compiler出力における~security~bugは，~UAの更新~時に識別され修正できようが、
直列化された内部~状態は残り続ける。
◎
A practical example of this is the RegExp type. The StructuredSerializeForStorage operation allows serializing RegExp objects. A typical user agent will compile a regular expression into native machine instructions, with assumptions about how the input data is passed and results returned. If this internal state was serialized as part of the data stored to the database, various problems could arise when the internal representation was later deserialized. For example, the means by which data was passed into the code could have changed. Security bugs in the compiler output could have been identified and fixed in updates to the user agent, but remain in the serialized internal state.
</p>

<p>
~UAは、
旧~dataを適切に識別して取扱えるモノトスル。
~approachの一例として、［
直列化~形式~内に~version識別子も含ませた上で、
旧~dataに遭遇したときは，
~scriptから可視な状態から内部~状態を構築し直す
］ことが挙げられる。
◎
User agents must identify and handle older data appropriately. One approach is to include version identifiers in the serialization format, and to reconstruct any internal state from script-visible state when older data is encountered.
</p>

		</section>
	</section>
	<section id="accessibility">
<h2 title="Accessibility considerations">10. ~accessibilityの考慮点</h2>

◎非規範的

<p>
この仕様が述べる~APIに対する~accessibilityの考慮点は、
以下のように制限される：
◎
The API described by this specification has limited accesibility considerations:
</p>

<ul>
	<li>
内容の視覚的な具現化／色に対する制御は、
供さない。
◎
It does not provide for visual rendering of content, or control over color.
</li>
	<li>
利用者~入力を受容する特能は、
供さない。
◎
It does not provide features to accept user input.
</li>
	<li>
利用者とヤリトリする特能は、
供さない。
◎
It does not provide user interaction features.
</li>
	<li>
文書の意味論は定義しない。
◎
It does not define document semantics.
</li>
	<li>
時間に基づく視覚-~mediaは、
供さない。
◎
It does not provide time-based visual media.
</li>
	<li>
時間~制限sは許容しない。
◎
It does not allow time limits.
</li>
	<li>
末端利用者~向け内容は、
直に供さない
— ~textな形でも，~graphicな形など他の形でも。
◎
It does not directly provide content for end-users, either in textual, graphical or other or non-textual form.
</li>
	<li>
伝送~protocolは定義しない。
◎
It does not define a transmission protocol.
</li>
</ul>

<p>
この~APIは、
有構造~内容の~storageを許容する。
~textな内容は文字列として格納できる。
この~APIには、
他の代替な内容
— 画像や音声など —
を［
`Blob$I ／ `File$I ／ `ImageData$I
］~objとして格納する開発者~向け~supportが存在する。
この~APIを利用して動的な内容~appを制作している開発者は、
当の内容が
— 様々な技術で, 様々な必要性を満たすよう —
利用者から~access可能になることを確保するベキである。
◎
The API does allow storage of structured content. Textual content can be stored as strings. Support exists in the API for developers to store alternative non-textual content such as images or audio as Blob, File, or ImageData objects. Developers producing dynamic content applications using the API should ensure that the content is accessible to users with a variety of technologies and needs.
</p>

<p>
この~API自体は，国際-化に特有な仕組みを定義しないが、
有構造~内容の~storageは，［
異なる~recordや構造を利用して，~recordの中に各 言語~代替を保持する
］ことにより［
国際-化された内容を格納する
］ことも開発者に許容する。
◎
While the API itself does not define a specific mechanism for it, storage of structured content also allows developers to store internationalized content, using different records or structure within records to hold language alternatives.
</p>

<p>
この~APIは、
この~APIとのヤリトリを可能化する~UIを どう生成するかは定義しないし，
それを~UAに要求することもない。
~UAは、
任意選択で，この~APIを~supportする~UI要素を供してもヨイ。
例：［
追加的な~storage~quotaが要求されるとき，利用者に~promptする／
特定0の~web~siteが利用している~storageを観測する機能性／
~recordを［
検分する／改変する／削除する
］など，~APIの~storageに特有な~tool
］。
そのような~UI要素は、
~accessibility~toolを念頭に設計するモノトスル。
例えば，利用される~storage~quotaの~~一部分を~graphicな形で呈示している~UIは、
~screen-readerなどの~toolにも同じ~dataを供するモノトスル。
◎
The API does not define or require any a user agent to generate a user interface to enable interaction with the API. User agents may optionally provide user interface elements to support the API. Examples include prompts to users when additional storage quota is required, functionality to observe storage used by particular web sites, or tools specific to the API’s storage such as inspecting, modifying, or deleting records. Any such user interface elements must be designed with accessibility tools in mind. For example, a user interface presenting the fraction of storage quota used in graphical form must also provide the same data to tools such as screen readers.
</p>

	</section>
	<section id="revision-history">
<h2 title="Revision history">11. 改訂~履歴</h2>

◎非規範的

<p>
以下は、
この仕様の最後の公表版からの変更点の要約である。
`完全な改訂~履歴＠https://github.com/w3c/IndexedDB/$ ／
`第 1 版の改訂~履歴＠~TR/IndexedDB/#revision-history$ ／
`第 2 版の改訂~履歴＠~TR/IndexedDB-2/#revision-history$
◎
The following is an informative summary of the changes since the last publication of this specification. A complete revision history can be found here. For the revision history of the first edition, see that document’s Revision History. For the revision history of the second edition, see that document’s Revision History.
</p>

<ul>
	<li>
他の仕様との統合~用に、
`索引付き~db~txを片付ける$~algoは値を返すようにした。
（`pull#232＠https://github.com/w3c/IndexedDB/pull/232$）
◎
The cleanup Indexed Database transactions algorithm now returns a value for integration with other specs. (PR #232)
</li>
	<li>
`WindowOrWorkerGlobalScope$I は今や~mixinになったので、
部分的~interface定義を更新した。
（`pull#238＠https://github.com/w3c/IndexedDB/pull/238$）
◎
Updated partial interface definition since WindowOrWorkerGlobalScope is now a mixin. (PR #238)
</li>
	<li>
`IDBFactory!I に `databases()$m ~methodを追加した。
（ `31$issue ）
◎
Added databases() method. (issue #31)
</li>
	<li>
`IDBTransaction!I に `commit()$m ~methodを追加した。
（ `234$issue ）
◎
Added commit() method. (issue #234)
</li>
	<li>
`IDBCursor!I に `request$m 属性を追加した。
（ `255$issue ）
◎
Added request attribute. (issue #255)
</li>
	<li>
`File$I ~objから標準でない `lastModifiedDate^m ~propの取扱いを除去した。
（ `215$issue ）
◎
Removed handling for nonstandard lastModifiedDate property of File objects. (issue #215)
</li>
	<li>
`IDBKeyRange!I の `includes()$m ~methodの識別子に対する~escapeを除去した。
（ `294$issue ）
◎
Remove escaping includes() method. (issue #294)
</li>
	<li>
`配列~key$を`~Array~exotic~obj$に制約した
（すなわち、
`Proxy^jT ~objを許容しないようにした）。
（ `309$issue ）
◎
Restrict array keys to Array exotic objects (i.e. disallow proxies). (issue #309)
</li>
	<li>
~clone演算の間は、
~txは一時的に `非作動中$i になるようにした。
（`pull#310＠https://github.com/w3c/IndexedDB/pull/310$）
◎
Transactions are now temporarily made inactive during clone operations. (PR #310)
</li>
	<li>
`IDBTransactionOptions$I に `durability$mb ~optionを追加すると伴に，
`IDBTransaction!I に `durability$m 属性を追加した。
（ `50$issue ）
◎
Added durability option and durability attribute. (issue #50)
</li>
	<li>
`§ ~txの~schedule法＠#transaction-scheduling$をもっと精確に指定した。
`視野が重合して$いる`~readonly~tx$が生きている【！running】間は、
`~readwrite~tx$を開始できないようにした。
（ `253$issue ）
◎
Specified § 2.7.2 Transaction scheduling more precisely and disallow starting read/write transactions while read-only transactions with overlapping scope are running. (issue #253)
</li>
	<li>
`§ ~accessibilityの考慮点＠#accessibility$を追加した。
（ `327$issue ）
◎
Added Accessibility considerations section. (issue #327)
</li>
	<li>
`infra$r の~list~sort法の定義を利用するようにした。
（ `346$issue ）
◎
Used [infra]’s list sorting definition. (issue #346)
</li>
	<li>
“`running^en” を一義化するため、
【 “`running^en ~tx” に代えて】
`生きて$いる~tx用の定義を追加して，
“昇格~txを `run^en する” を “`~dbを昇格する$” に改称した。
（ `408$issue ）
◎
Added a definition for live transactions, and renamed "run an upgrade transaction" to upgrade a database, to disambiguate "running". (issue #408)
</li>
	<li>
`保管庫から検索取得する演算＠#_retrieval-operations$において，
下層~storageから値を読取るときの失敗~用の例外~型を指定した。
（ `423$issue ）
◎
Specified the DOMException type for failures when reading a value from the underlying storage in § 6.2 Object store retrieval operations. (issue #423)
</li>
	<li>
`値を~keyに変換する$~algoを［
切離されている配列~buffer用には `無効な値^i を返す
］よう更新した。
（ `417$issue ）
◎
Updated convert a value to a key to return invalid for detached array buffers. (issue #417)
</li>
	<li>
`IDBFactory!I の `open()$m を更新した
— %要請 の`処理-済みか$を ~T に設定するよう。
（ `434$issue ）
◎
Updated open() to set its request’s processed flag to true. (issue #434)
</li>
	<li>
`IDBFactory!I の `databases()$m において、
作成が済んでない~dbを含めないようにした。
（ `442$issue ）
◎
Don’t include databases that aren’t done being created in databases(). (issue #442)
</li>
	<li>
`~tx$を自動で`~commit$するよう試みるのは、
`非作動中$i なときに限るべきであることを明確化した。
（ `436$issue ）
◎
Clarify that only inactive transactions should attempt to auto-commit. (issue #436)
</li>
	<li>
`~dbを昇格する$手続きを正した
— 中止された~txを取扱うよう。
（ `436$issue ）
◎
Correct upgrade a database steps to handle aborted transactions. (issue #436)
</li>
	<li>
`~cursorを反復する$ときの値の直列化【 %直列形 】には、
`保管庫$用には，~recordの`値$を
— `参照先~record$の`値$の代わりに —
利用するよう更新した。
（ `452$issue ）
◎
Update iterate a cursor value serialization to use value for object stores instead of referenced values. (issue #452)
</li>
	<li>
`~cursor$に`~source~handle$Csを追加した。
— 内部的な［
`索引$／`保管庫$
］を~scriptへ公開するのを避けるため。
（ `445$issue ）
◎
Add source handle to cursor to avoid exposing internal indexes and object stores to script. (issue #445)
</li>
	<li>
`~db~taskを~queueする$を定義して，
`~taskを~queueする$をそれで置換した。
（ `421$issue ）
◎
Define Queue a database task and replace Queue a task with it (issue #421)
</li>
	<li>
`IDBFactory!I の `databases()$m ~methodに欠落った並列的な【`~db~taskを~queueする$】段を追加した。
（ `421$issue ）
◎
Add missing parallel step to databases() (issue #421)
</li>
	<li>
~cursor反復の述部を明確化した。
（ `450$issue ）
◎
Clarify cursor iteration predicates (issue #450)
</li>
	<li>
`IDBObjectStore!I に `getAllRecords()$m ~methodを追加した。
`IDBIndex!I に `getAllRecords()$m ~methodを追加した。
（ `206$issue ）
◎
Add getAllRecords(options) method to IDBObjectStore and IDBIndex. (issue #206)
</li>
	<li>
`IDBObjectStore!I の［
`getAll()$m, `getAllKeys()$m
］~methodおよび `IDBIndex!I の［
`getAll()$m, `getAllKeys()$m
］~method用に方向~optionを追加した。
（ `130$issue ）
◎
Add direction option to getAll() and getAllKeys() for IDBObjectStore and IDBIndex (issue #130)
</li>
	<li>
`QuotaExceededError$I の利用を更新した
— それが，今や 例外~名ではなく `DOMException$I から派生した~interfaceであることを反映するよう。
（ `463$issue ）
◎
Use of QuotaExceededError has been updated to reflect that it is now a DOMException-derived interface instead of an exception name. (issue #463)
</li>
	<li>
~NULL は、
`~error$tx用の妥当な値であるものと指定して，
`~txを中止する$~algoにおいて設定されることを許容した。
（ `433$issue ）
◎
Specify that null is valid for error, and allow it to be set in abort a transaction (issue #433)
</li>
	<li>
`~db接続を~openする$~algoにおいて`昇格~tx$の代わりに`要請$の`~error$を検査するようにした。
（ `433$issue ）
◎
Check the request’s error instead of the upgrade transaction in open a database connection. (issue #433)
</li>
	<li>
`IDBTransaction!I の `abort()$m ~method手続き内の冗長な~tx状態~変更を除去した。
◎
Remove redundant transaction state change in abort().
</li>
</ul>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">12. 謝辞</h2>

◎非規範的

<p>
この仕様の第１版の元々の作者である `Nikunj Mehta^en 氏に特別な謝意を。
第１版の編集者である次に挙げる方々, 並びに他の編集者たちにも
⇒
`Jonas Sicking, Eliot Graff, Andrei Popescu, Jeremy Orlow^en
◎
Special thanks to Nikunj Mehta, the original author of the first edition,＼
and Jonas Sicking, Eliot Graff, Andrei Popescu, and Jeremy Orlow, additional editors of the first edition.
</p>

<p>
この仕様の設計に極めて影響力があった `Garret Swart^en 氏に。
◎
Garret Swart was extremely influential in the design of this specification.
</p>

<p>
この文書の作成-時に利用した 仕様~著作~tool `Bikeshed^en を［
作成-／保守-
］され，一般的な著作~法を~~助言された `Tab Atkins, Jr.^en 氏に。
◎
Thanks to Tab Atkins, Jr. for creating and maintaining Bikeshed, the specification authoring tool used to create this document, and for his general authoring advice.
</p>

<p>
~feedbackや提言を寄せられ, この仕様の改善へ導いた，
次に挙げる方々に特別な謝意を：
</p>

<p lang="en">
Special thanks to

Abhishek Shanthkumar,
Adam Klein,
Addison Phillips,
Adrienne Walker,
Alec Flett,
Andrea Marchesini,
Andreas Butler,
Andrew Sutherland,
Anne van Kesteren,
Anthony Ramine,
Ari Chivukula,
Arun Ranganathan,
Ben Dilts,
Ben Turner,
Bevis Tseng,
Boris Zbarsky,
Brett Zamir,
Chris Anderson,
Dana Florescu,
Danillo Paiva,
David Grogan,
Domenic Denicola,
Dominique Hazael-Massieux,
Evan Stade,
Glenn Maynard,
Hans Wennborg,
Isiah Meadows,
Israel Hilerio,
Jake Archibald,
Jake Drew,
Jerome Hode,
Josh Matthews,
João Eiras,
Kagami Sascha Rosylight,
Kang-Hao Lu,
Kris Zyp,
Kristof Degrave,
Kyaw Tun,
Kyle Huey,
Laxminarayan G Kamath A,
Maciej Stachowiak,
Marcos Cáceres,
Margo Seltzer,
Marijn Kruisselbrink,
Ms2ger,
Odin Omdal,
Olli Pettay,
Pablo Castro,
Philip Jägenstedt,
Shawn Wilsher,
Simon Pieters,
Steffen Larssen,
Steve Becker,
Tobie Langel,
Victor Costan,
Xiaoqian Wu,
Yannic Bonenberger,
Yaron Tausky,
Yonathan Randolph,
and
Zhiqiang Zhang,

all of whose feedback and suggestions have led to improvements to this specification.
</p>

	</section>
</main></div>

