<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Supporting concepts（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">
<style>

@supports (grid-template-columns: subgrid) and (display: contents) {

._compare-origin {
	grid-template-columns: 1fr 1fr;
	max-width: 28em;
	tr {
		grid-template-areas:
			"A A"
			"B B"
			"同一 同じ"
		;
		> *:nth-child(1) {
			grid-area: A;
			white-space: nowrap;
		}
		> *:nth-child(2) {
			grid-area: B;
			white-space: nowrap;
		}
		> *:nth-child(3) {
			grid-area: 同一;
		}
		> *:nth-child(4) {
			grid-area: 同じ;
		}
	}
}

}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>
<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'browsers',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'coop':
case 'coep':
case 'l':
case 'coI':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sbox': // sandboxing flags
	text = `閲覧~文脈~sandbox化( ${key} )~flag`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2025-09-08
trans_update:2025-09-10
source_checked:241212
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/browsers.html
site_nav:browsers,security,html
nav_prev:HTMLpopover
nav_next:WINDOW
trans_1st_pub:2016-07-12


●●class_map
e:element
a:attr
et:event-type
E:error
U:code-point
sl:js-slot
v:value
h:header
sc:scheme
dir:directive

●●tag_map
I:code
m:code
c:code
e:code
a:code
et:code
E:code
sl:span
U:span
v:code
h:code
sc:code
dir:code
i:i
em:em
cite:cite
sub:sub

●●words_table

database::::データベース
iframe:
	unfortunate

	●仕様
採用-:adopt:~
基礎的な:fundamental:~
自明:trivial:~
不作為:inadvertent:~
固守:adherence:~
任意選択する:opt-inする:任意で選ぶ
活用-:leverage:~
処する:dealする:~
決着-:settle:~

	-:substeps
	~~協調する:if they do the same thing
	なり得る:potentially
	にもかかわらず:nonetheless
	加えて:Furthermore
	様々な程度:varying degrees
	広く:widely
	方が好ましい:in favor of
	何もかも:everything
	舞台裏:behind the scenes
	〜としては:In terms of
	一方で 〜 ~~力点が置かれる:since 〜 more about
	結果に至る:can cause 〜 end up
	により:by means of
	それに加え:with the addition that
	より多くの自由度:in the order of 〜 more freedom
	になるかどうか:outcome of
	これを書いた時点:At the time of writing
	その引き換えに:in exchange
	~~確保する:make sure
	放置-:letting

	●network／保安
IP:
COOP:
	coop:COOP
COEP:
	coep:COEP
HTTP_S:HTTP(S) 
下位domain:subdomain:::下位ドメイン
navigator::::ナビゲータ
権限:authority:~
強制d:forced:強制
公共:public::~
逃れる:escapeする:~
報告先:reporting endpoint::~
報告用:reporting::~
陥穽:pitfall:落とし穴
蝕む:undermineする:~
処置:disposition::~
施行n:enforcement:施行
無毒化-:sanitize::~
username::::ユーザ名
password::::パスワード
私的:private:~
公で:publicで:~
端点:endpoint::~::エンドポイント
堅牢:robust:~

	信用できない:untrusted
	CORS-cross-origin
	CORS-same-origin
	ひどいことに:acute
	緩い／緩め方／緩めよ:relax
	敷かれ:create

	●環境 ／ 閲覧
agent:
surrounding:
補助:auxiliary::~
成分組:tuple:~
閉じる:closeする::~
	閉じるとき:closing
開く:openする::~
開いた:openした::~
	-:back
	戻るよう:back
埋込元:embedder::埋め込み元
opener:::open 元
openee:::open 先
accessed:::access 先:アクセス先
accessor:::access 元:アクセス元
open:
closed:
切替n:switch:切り替え
scope::::スコープ
process::::プロセス
履歴上の:historicalな:~
virtual:
BF:
	~BF:back/forward
入替える:swapする:入れ替える
入替n:swap:入れ替え

	生成元を~keyに:origin-keyed

	●UI
popup:
再生-:play:~
一過:transient::~
autofill:
	around
	Control key
	~scroll用:scrolling
	~tab付き:tabbed

	●構文
dot::::ドット
	過ぎない:past
	-:頭部の
	尾部:end
	末尾の:trailing

	●一般処理
動作者:actor:~
書込む:writeする:書き込む
同等:equal:~
同等性:equality:~
和集合:union::~
割振る:allocateする::割り振る
割振り:allocation::割り振り
作成元の:creator::~
作成時の:creation::~
実効:effective:~
params::::パラメタ群
手渡す:hand offする:取り扱わせる
処置先:disposition::~
installation:
最終-:final:~

	しようとしている:going to
	この時点で:at this point
	しつつ:about to

	●変数
top::::トップ
	%A
	%B
	%閲覧~文脈:browsingContext
	%閲覧~文脈:browsing context
	%~URL:url
	%hostA
	%hostB
	%report-to:-
	%~COOP応答は~navi~sourceか:isCOOPResponseNavigationSource
	%~accessed
	%~accessorと~accessedの関係性:accessorAccessedRelationship
	%~accessedの~COOP:accessedCOOP
	%~accessedの~URL:accessedURL
	%~accessedの~referrer:accessedReferrer
	%~accessedの作成元の生成元:accessedCreatorOrigin
	%~accessedの初期~URL:accessedInitialURL
	%~accessedの生成元:accessedOrigin
	-:accessedInclusiveAncestorOrigins
	%~accessed~top:-
	%~accessed~top にて`作動中な文書$bc:accessedTopDocument
	%~accessorの~COOP:accessorCOOP
	%~accessorの~URL:accessorURL
	%~accessorの~referrer:accessorReferrer
	%~accessorの作成元の生成元:accessorCreatorOrigin
	%~accessorの初期~URL:accessorInitialURL
	%~accessorの生成元:accessorOrigin
	-:accessorInclusiveAncestorOrigins
	%~accessor~top:-
	%~accessor~top にて`作動中な文書$bc:accessorTopDocument
	%~COEP:coep
	%~COOP~URL:coopURL
	%~COOP値:coopValue
	%~COOP施行n結果:coopEnforcementResult
	%~COOP生成元:coopOrigin
	%~domain
	%~host:host
	%~host接尾辞~文字列:hostSuffixString
	%~host接尾辞:hostSuffix
	%~item:value[0]
	%~navi~COOP:navigationCOOP
	%~openerの~URL:openerURL
	%~openerの初期~生成元:openerInitialOrigin
	%~openerの生成元:openerOrigin
	%~openした~windowの~URL:openedWindowURL
	%~openした~windowの生成元:openedWindowOrigin
	%~prop名:propertyName
	%~sandbox~flag群:sandboxFlags
	%~source~file:sourceFile
	%~target
	%~token群:tokens
	%~worker大域~scope:workerGlobalScope
	%予約-済み環境:reservedEnvironment
	%他の~URL:otherURL
	%他の生成元:otherOrigin
	%作動中な文書の~COOP値:activeDocumentCOOPValue
	%作動中な文書の~navi生成元:activeDocumentNavigationOrigin
	%作動中な文書の報告のみの~COOP:activeDocumentCOOP（原文誤記）
	%作動中な文書の報告のみの~COOP:activeDocumentCOOPReportOnly
	%値:-
	%元の~host:originalHost
	%入力:input
	%処置:disposition
	%出力:output
	%列番号:columnNumber
	%初期~about_blankか:isInitialAboutBlank
	%初期~about_blankである:isInitialAboutBlank
	%初期~window~URL:initialWindowURL,
	%以前の応答の~URL:previousResponseURL
	%以前の応答の生成元:previousResponseOrigin
	%埋込元:embedder
	%報告先:-
	%報告先:endpoint
	%実効~domain:effectiveDomain
	%文書の~COOP:documentCOOP
	%文書の生成元:documentOrigin
	%応答:response
	%応答~URL:responseURL
	%応答~施策:responsePolicy
	%応答の生成元:responseOrigin
	%応答の~COOP:responseCOOP
	%応答の~COOP値:responseCOOPValue
	%所有者:owner
	%所有者~施策:ownerPolicy
	%新たな~COOP施行n結果:newCOOPEnforcementResult
	%新たな閲覧~文脈:newBrowsingContext
	%施策:policy
	%本体:body
	%構文解析した~item:parsedItem
	%以後の応答の~URL:nextResponseURL
	%以後の応答の生成元:nextResponseOrigin
	%無毒化した~URL:sanitizedURL
	%現在の~COOP施行n結果:currentCOOPEnforcementResult
	%環境:environment
	%生成元:origin
	%直列化した~URL:serialized
	%直列化した~referrer:serializedReferrer
	%種別:type
	%結果:result
	%行番号:lineNumber
	%親~施策:parentPolicy
	-:coep
	-:securityState
	%施策~容器:policyContainer
	%履歴~施策~容器:historyPolicyContainer
	%起動元~施策~容器:initiatorPolicyContainer
	%親~施策~容器:parentPolicyContainer
	%応答~施策~容器:~responsePolicyContainer
	%~CSP~list:cspList
	%指令~群:directives
	%指令:directive
	%~navi~params:navigationParams
	%~groupを入替えるか:~swapGroup
	%~source生成元:sourceOrigin
	%行先~生成元:destinationOrigin

	●未分類
blob:
出自の:originating:~
通貨:currency:~
行番号:line number::~
列番号:column number::~
列挙値:enum::~
無符号:unsigned:~
側:side:~

	getting
	-:common
	種類:
	~frame化:framing
	報告のみの:report-only
	空になった:which no longer contains any browsing contexts
	~~投出:raise
	変異しない:immutable
	対応付け:map
	~~述べ
	-:prefixed
	選ばれ
	選ぶ:choose する
	meant
	said
	~instance化-:instantiate
	:exactly
	連結-
	hosting
	非:non
	:per
	point
	それまでの文書:predecessor
	占める:occupy
	現れる:appearする
	後続-:follow
	伴い得る:attached
	最終的な:final
	以前に読込まれ:previously-load
	~web~site:website
	入れ替え:swap
	^en:the back/forward cache
	-:next
	以前の:previous
	以後の:next
	断たれ:sever


●●original_id_map

	csp-derived-sandboxing-flags:forced-sandboxing-flag-set

●●words_table1

document-domain:<code>document.domain</code> 
about_blank:about:blank
about_srcdoc:about:srcdoc
sf:<sub>sf-</sub>

●●mdn_urls

cross-origin-opener-policy-2:HTTP/Headers/Cross-Origin-Opener-Policy
	cross-origin-opener-policy-report-only:HTTP/Headers/Cross-Origin-Opener-Policy-Report-Only
cross-origin-embedder-policy:HTTP/Headers/Cross-Origin-Embedder-Policy
	cross-origin-embedder-policy-report-only:HTTP/Headers/Cross-Origin-Embedder-Policy-Report-Only
	origin-agent-cluster:HTTP/Headers/Origin-Agent-Cluster


●●link_map



	●IDL
I.Document:~HTMLdom#document
	→ 文書
	I.Window:~WINDOW#window
	→ ~window
~window:~WINDOW#the-window-object
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.WorkletGlobalScope:~WORKLETS#workletglobalscope
I.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
I.MessageChannel:~HTMLcomms#messagechannel
I.BroadcastChannel:~HTMLcomms#broadcastchannel
I.Cache:~SW1#cache

E.SecurityError:~WEBIDL#securityerror

m.domain:#dom-document-domain
c.document.domain:#dom-document-domain
m.originAgentCluster:#dom-originagentcluster
m.localStorage:~WEBSTORAGE#dom-localstorage

	●event
et.beforeunload:~HTMLindex#event-beforeunload

	●要素
e.iframe:~HEembed#the-iframe-element

	●内容属性
a.sandbox:~HEembed#attr-iframe-sandbox
a.target:~HTMLlinks#attr-hyperlink-target

	●code 他

coI.none:~HTMLds#cross-origin-isolation-none
coI.logical:~HTMLds#cross-origin-isolation-logical
coI.concrete:~HTMLds#cross-origin-isolation-concrete

dir.sandbox:~CSP3#sandbox
dir.frame-ancestors:~CSP3#frame-ancestors

h.X-Frame-Options:~HTMLsl#x-frame-options

	●生成元／sandbox（origin.html
	§:#origin
	§:#sandboxing
	§:#relaxing-the-same-origin-restriction
	:#origin-2
	:#unicode-serialisation-of-an-origin

生成元:#concept-origin
不透明な生成元:#concept-origin-opaque
成分組~生成元:#concept-origin-tuple
o.~scheme:#concept-origin-scheme
o.~host:#concept-origin-host
o.~port:#concept-origin-port
o.~domain:#concept-origin-domain
実効~domain:#concept-origin-effective-domain
生成元を直列化する:#ascii-serialisation-of-an-origin
o.直列化:#ascii-serialisation-of-an-origin
同一-生成元:#same-origin
sub.生成元:#same-origin
同じ生成元~domain:#same-origin-domain
同一-~site:#same-site
site.同一-~site:#concept-site-same-site
~scheme無しで同一-~site:#schemelessly-same-site

~scheme＆~host:#scheme-and-host
sh.~scheme:#concept-scheme-and-host-scheme
sh.~host:#concept-scheme-and-host-host

~site:#site
~siteを得する:#obtain-a-site
~siteを直列化する:#serialization-of-a-site

登録-可能な~domain接尾辞または同等:#is-a-registrable-domain-suffix-of-or-is-equal-to

v.allow-popups:#attr-iframe-sandbox-allow-popups
v.allow-top-navigation:#attr-iframe-sandbox-allow-top-navigation
v.allow-top-navigation-by-user-activation:#attr-iframe-sandbox-allow-top-navigation-by-user-activation
v.allow-top-navigation-to-custom-protocols:#attr-iframe-sandbox-allow-top-navigation-to-custom-protocols
v.allow-same-origin:#attr-iframe-sandbox-allow-same-origin
v.allow-forms:#attr-iframe-sandbox-allow-forms
v.allow-pointer-lock:#attr-iframe-sandbox-allow-pointer-lock
v.allow-scripts:#attr-iframe-sandbox-allow-scripts
v.allow-popups-to-escape-sandbox:#attr-iframe-sandbox-allow-popups-to-escape-sandbox
v.allow-modals:#attr-iframe-sandbox-allow-modals
v.allow-orientation-lock:#attr-iframe-sandbox-allow-orientation-lock
v.allow-presentation:#attr-iframe-sandbox-allow-presentation
v.allow-downloads:#attr-iframe-sandbox-allow-downloads

~sandbox法~flag集合:#sandboxing-flag-set
作動中な~sandbox法~flag集合:#active-sandboxing-flag-set
~popup~sandbox法~flag集合:#popup-sandboxing-flag-set
~iframe~sandbox法~flag集合:#iframe-sandboxing-flag-set

sbox.~document-domain:#sandboxed-document.domain-browsing-context-flag
sbox.~form:#sandboxed-forms-browsing-context-flag
sbox.~navi:#sandboxed-navigation-browsing-context-flag
許可-済み~navigator:#one-permitted-sandboxed-navigator
sbox.~pointer~lock:#sandboxed-pointer-lock-browsing-context-flag
sbox.~script:#sandboxed-scripts-browsing-context-flag
sbox.利用者-作動化を伴わない~top-level~navi:#sandboxed-top-level-navigation-without-user-activation-browsing-context-flag
sbox.利用者-作動化を伴う~top-level~navi:#sandboxed-top-level-navigation-with-user-activation-browsing-context-flag
sbox.生成元:#sandboxed-origin-browsing-context-flag
sbox.自動的な特能:#sandboxed-automatic-features-browsing-context-flag
sbox.補助~navi:#sandboxed-auxiliary-navigation-browsing-context-flag
sbox.方位~lock:#sandboxed-orientation-lock-browsing-context-flag
sbox.呈示:#sandboxed-presentation-browsing-context-flag
sbox.~download:#sandboxed-downloads-browsing-context-flag
sbox.~custom~protocol~navi:#sandboxed-custom-protocols-navigation-browsing-context-flag

~sandboxは補助~閲覧~文脈に伝播する~flag:#sandbox-propagates-to-auxiliary-browsing-contexts-flag
~sandbox化( ~modal )~flag:#sandboxed-modals-flag
作成時の~sandbox法~flag群を決定する:#determining-the-creation-sandboxing-flags
~sandbox法~指令を構文解析する:#parse-a-sandboxing-directive


	●COOP／COEP

coop.report-to:#coop-report-to
coop.same-origin-allow-popups:#coop-same-origin-allow-popups
coop.same-origin:#coop-same-origin
coop.same-origin-plus-COEP:#coop-same-origin-plus-coep
coop.unsafe-none:#coop-unsafe-none
coop.noopener-allow-popups:#coop-noopener-allow-popups

coep.report-to:#coep-report-to
coep.require-corp:#coep-require-corp
coep.unsafe-none:#coep-unsafe-none
coep.credentialless:#coep-credentialless

h.Cross-Origin-Opener-Policy:#cross-origin-opener-policy-2
h.Cross-Origin-Opener-Policy-Report-Only:#cross-origin-opener-policy-report-only
h.Cross-Origin-Embedder-Policy:#cross-origin-embedder-policy
h.Cross-Origin-Embedder-Policy-Report-Only:#cross-origin-embedder-policy-report-only
h.Cross-Origin-Resource-Policy:~FETCH#http-cross-origin-resource-policy
h.Origin-Agent-Cluster:#origin-agent-cluster

~navi応答~用に利用する閲覧~文脈を得する:#obtain-browsing-context-navigation
~opener施策:#cross-origin-opener-policy
~opener施策を得する:#obtain-coop
~opener施策の施行n結果:#coop-enforcement-result
~opener施策~値:#cross-origin-opener-policy-value
~opener施策~値として合致して:#matching-coop
応答の~opener施策を施行する:#coop-enforce

cooP.閲覧~文脈~groupの切替nは必要か:#coop-enforcement-bcg-switch
cooP.報告のみに因る閲覧~文脈~groupの切替nは必要か:#coop-enforcement-bcg-switch-report-only
cooP.~opener施策:#coop-enforcement-coop
cooP.生成元:#coop-enforcement-origin
cooP.~URL:#coop-enforcement-url
cooP.現在の文脈は~navi~sourceか:#coop-enforcement-source

文書:~HTMLdom#the-document-object
doc.施策~容器:~HTMLdom#concept-document-policy-container
doc.~opener施策:~HTMLdom#concept-document-coop
doc.~referrer:~HTMLdom#the-document's-referrer
	doc.~referrer:~HTMLdom#dom-document-referrer
doc.~URL:~DOM4#concept-document-url
doc.生成元:~DOM4#concept-document-origin
doc.初期~about_blank か:~HTMLdom#is-initial-about:blank

有構造~field値を取得する:~FETCH#concept-header-list-get-structured-header
局所的な~URL:~FETCH#is-local
応答~URLを報告-用に直列化する:~FETCH#serialize-a-response-url-for-reporting
応答:~FETCH#concept-response
rs.~URL:~FETCH#concept-response-url
rs.~header~list:~FETCH#concept-response-header-list
~CORS~protocol:~FETCH#http-cors-protocol
	~CORS~protocol:~FETCH#http-cors-protocol
rq.~referrer:~FETCH#concept-request-referrer
~fetch~scheme:~FETCH#fetch-scheme
~HTTP_S~scheme:~FETCH#http-scheme

埋込元~施策:#embedder-policy
埋込元~施策を得する:#obtain-an-embedder-policy
埋込元~施策~値:#embedder-policy-value
embP.値:#embedder-policy-value-2
embP.報告先:#embedder-policy-reporting-endpoint
embP.報告のみの値:#embedder-policy-report-only-value
embP.報告のみの報告先:#embedder-policy-report-only-reporting-endpoint

i.~COEP報告~種別:#coep-report-type

大域~objの埋込元~施策を検査する:#check-a-global-object's-embedder-policy
~navi応答の埋込元~施策に対する固守を検査する:#check-a-navigation-response's-adherence-to-its-embedder-policy
非同一-生成元~埋込元~施策の継承~違反を~queueする:#queue-a-cross-origin-embedder-policy-inheritance-violation

非同一-生成元~隔離と互換:#compatible-with-cross-origin-isolation

	●報告

coOP.報告先:#coop-struct-report-endpoint
coOP.報告のみの報告先:#coop-struct-report-only-endpoint
coOP.報告のみの値:#coop-struct-report-only-value
coOP.値:#coop-struct-value

~accessedと~accessorの関係性:#accessor-accessed-relationship
i.~~無関係:#accessor-accessed-none
i.~accessorは~openee:#accessor-accessed-openee
i.~accessorは~opener:#accessor-accessed-opener

報告のみの~COOPの施行-法は閲覧~文脈~groupの切替nを要求するかどうか検査する:#check-bcg-switch-navigation-report-only
~COOP値は閲覧~文脈~groupの切替nを要求するかどうか検査する:#check-browsing-context-group-switch-coop-value
~popupの~COOP値は閲覧~文脈~groupの切替nを要求するかどうか検査する:#check-browsing-context-group-switch-coop-value-popup
~popup~COOP値は閲覧~文脈~groupの切替nを要求するか検査する:#check-browsing-context-group-switch-coop-value-popup
閲覧~文脈どうしの~accessは報告されるべきかどうか検査する:#coop-check-access-report
~openした~windowからの~access用に違反~報告を~queueする:#coop-violation-access-from-opened
~openerからの~access用に違反~報告を~queueする:#coop-violation-access-from-opener
~openerへの~access用に違反~報告を~queueする:#coop-violation-access-to-opener
別の~windowからの~access用に違反~報告を~queueする:#coop-violation-access-from-other
別の~windowへの~access用に違反~報告を~queueする:#coop-violation-access-to-other
~openした~windowへの~access用に違反~報告を~queueする:#coop-violation-access-to-opened
各種~access用に違反~報告を~queueする:#coop-violation-access
~COOP応答から~navigateして去るときの閲覧~文脈~groupの切替n用に違反~報告を~queueする:#coop-violation-navigation-from
~COOP応答へ~navigateするときの閲覧~文脈~groupの切替n用に違反~報告を~queueする:#coop-violation-navigation-to
報告~内に送信する~URLを無毒化する:#sanitize-url-report

有構造~header:~STRUCTURED-FIELDS#structured-header
	有構造~header:~STRUCTURED-FIELDS
~sf真偽値:~STRUCTURED-FIELDS#sf-boolean
~sf~token:~STRUCTURED-FIELDS#sf-token
~sf文字列:~STRUCTURED-FIELDS#sf-string
~sf~parameter群:~STRUCTURED-FIELDS#sf-parameters
~sf~item:~STRUCTURED-FIELDS#sf-item
sfI.値:~STRUCTURED-FIELDS#sf-item
sfI.~parameter群:~STRUCTURED-FIELDS#sf-item

	●施策~容器
施策~容器:#policy-container
pC.~CSP~list:#policy-container-csp-list
pC.埋込元~施策:#policy-container-embedder-policy
pC.~referrer施策:#policy-container-referrer-policy
pC.完全性~施策:#policy-container-integrity-policy
pC.報告のみの完全性~施策:#policy-container-report-only-integrity-policy
施策~容器を~cloneする:#clone-a-policy-container
~URLは履歴~内に施策~容器を格納するよう要求するか？:#requires-storing-the-policy-container-in-history
~fetch応答から施策~容器を作成する:#creating-a-policy-container-from-a-fetch-response
~navi~paramsの施策~容器を決定する:#determining-navigation-params-policy-container
~worker大域~scopeの施策~容器を初期化する:#initialize-worker-policy-container


	●用語 HTML
sc.~about_srcdoc:~HTMLurl#about:srcdoc

一過な作動化を有して:~HTMLinteraction#transient-activation
~hyperlinkを~downloadする:~HTMLlinks#downloading-hyperlinks

~navigable:~HTMLds#navigable
子~navigable:~HTMLds#child-navigable
nav.容器~文書:~HTMLds#nav-container-document
広義-先祖~navigable群:~HTMLds#inclusive-ancestor-navigables
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context
閲覧~文脈:~HTMLds#browsing-context
nav.作動中な閲覧~文脈:~HTMLds#nav-bc
先祖~閲覧~文脈:~HTMLds#ancestor-browsing-context
bc.開いた閲覧~文脈:~HTMLds#opener-browsing-context
全部的に作動中:~HTMLds#fully-active
bc.作動中な文書:~HTMLds#active-document
nav.作動中な文書:~HTMLds#nav-document
属する閲覧~文脈:~HTMLds#concept-document-bc
bc.~top-level閲覧~文脈:~HTMLds#bc-tlbc
bc.初期~URL:~HTMLds#browsing-context-initial-url
bc.~virtual閲覧~文脈~group~ID:~HTMLds#virtual-browsing-context-group-id
bc.作成時の~opener生成元:~HTMLds#opener-origin-at-creation
bc.作動中な~window:~HTMLds#active-window
補助~閲覧~文脈:~HTMLds#auxiliary-browsing-context
~navigableを選ぶ規則:~HTMLds#the-rules-for-choosing-a-navigable
新たな~top-level閲覧~文脈と文書を作成する:~HTMLds#creating-a-new-top-level-browsing-context
tbcG.~group:~HTMLds#tlbc-group
閲覧~文脈~group:~HTMLds#browsing-context-group
bcG.閲覧~文脈~集合:~HTMLds#browsing-context-set
bcG.非同一-生成元~隔離~mode:~HTMLds#bcg-cross-origin-isolation
bcG.履歴上の~agent~cluster~key~map:~HTMLds#historical-agent-cluster-key-map
非同一-生成元~隔離~mode:~HTMLds#cross-origin-isolation-mode

文書を作成して初期化する:~HTMLlifecycle#initialise-the-document-object
~BF~cache:~HTMLnav#_bf-cache
外部~softwareに手渡す:~HTMLnav#hand-off-to-external-software
~navi~params:~HTMLnav#navigation-params
nvP.利用者-関与i:~HTMLnav#navigation-params-user-involvement
nvP.~navigable:~HTMLnav#navigation-params-navigable
nvP.~COOP施行n結果:~HTMLnav#navigation-params-coop-enforcement-result
nvP.生成元:~HTMLnav#navigation-params-origin
nvP.~opener施策:~HTMLnav#navigation-params-coop
nvP.最終-~sandbox~flag集合:~HTMLnav#navigation-params-sandboxing
i.~browser~UI:~HTMLnav#uni-browser-ui

非同一-生成元から~access可能な~window~prop名:~HTMLWPROXY#cross-origin-accessible-window-property-name

環境:~WAPI#environment
enV.施策~容器:~WAPI#concept-settings-object-policy-container
enV.~secureな文脈:~WAPI#secure-context
	非~secureな文脈:~WAPI#non-secure-context
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability
enV.大域~obj:~WAPI#concept-settings-object-global

環境~設定群~obj:~WAPI#environment-settings-object
関連な設定群~obj:~WAPI#relevant-settings-object
agC.非同一-生成元~隔離~mode:~WAPI#agent-cluster-cross-origin-isolation
生成元を~keyにするか:~WAPI#is-origin-keyed
~agent~cluster~key:~WAPI#agent-cluster-key
~keyに:~WAPI#agent-cluster-key

wG.施策~容器:~WORKERS#concept-workerglobalscope-policy-container
wG.埋込元~施策:~WORKERS#concept-workerglobalscope-embedder-policy
wG.~URL:~WORKERS#concept-workerglobalscope-url
wG.所有者~集合:~WORKERS#concept-WorkerGlobalScope-owner-set

	●用語（外部
実装定義:~INFRA#implementation-defined

16 ~bitな無符号~整数:~INFRA#16-bit-unsigned-integer

~scalar値~文字列:~INFRA#scalar-value-string
~ASCII文字列:~INFRA#ascii-string
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
~tuple:~INFRA#tuple
空:~INFRA#list-is-empty
~size:~INFRA#list-size
付加する:~INFRA#list-append
~cloneする:~INFRA#list-clone
包含する:~INFRA#list-contain
和集合:~INFRA#set-union
集合:~INFRA#ordered-set
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item

~URL:~URL1#concept-url
妥当な~URL文字列:~URL1#valid-url-string
同等な~host:~URL1#concept-host-equals
~URLを直列化する:~URL1#concept-url-serializer
i.素片は除外する:~URL1#url-serializer-exclude-fragment
~hostを直列化する:~URL1#concept-host-serializer
~host構文解析器:~URL1#concept-host-parser
~URLの~usernameを設定する:~URL1#set-the-username
~URLの~passwordを設定する:~URL1#set-the-password
~host:~URL1#concept-host
~IP~address:~URL1#ip-address
url.~domain:~URL1#concept-domain
url.~host:~URL1#concept-url-host
url.~port:~URL1#concept-url-port
url.~scheme:~URL1#concept-url-scheme
url.~blob~URL~entry:~URL1#concept-url-blob-entry
整数を直列化する:~URL1#serialize-an-integer
公共~接尾辞:~URL1#host-public-suffix
登録-可能な~domain:~URL1#host-registrable-domain

~agent~cluster:~TC39#sec-agent-clusters
~surrounding~agent:~TC39#surrounding-agent

~node文書:~DOM4#concept-node-document

報告を生成して~queueする:~REPORTING#generate-and-queue-a-report
報告を生成する:~REPORTING#generate-a-report
報告を~queueする:#_reporting-queue
	廃）報告を~queueする:~REPORTING#reporting-queue
	廃）報告を~queueする:~REPORTING#queue-report
報告~種別:~REPORTING#report-type
報告用~観測器から可視:~REPORTING#visible-to-reportingobservers
報告先:~REPORTING#endpoint

~CSP~list:~CSP3#csp-list
応答の~CSPを構文解析する:~CSP3#parse-response-csp
処置先:~CSP3#policy-disposition
指令~集合:~CSP3#policy-directive-set
指令:~CSP3#directives
~CSPから導出される~sandbox法~flag群:#csp-derived-sandboxing-flags

~referrer施策:~REFERRER-POLICY#referrer-policy
既定の~referrer施策:~REFERRER-POLICY#default-referrer-policy
~referrer施策を構文解析する:~REFERRER-POLICY#parse-referrer-policy-from-header

完全性~施策:~SRI#integrity-policy
完全性~施策~headerを構文解析する:~SRI#parse-integrity-policy-headers

bU.環境:~FILEAPI#blob-url-entry-environment

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ Supporting concepts</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>HTML — web ページの読み込み：サポート用の概念</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="browsers">
<h2 title="Loading web pages">7. ~web~pageの読込ng</h2>

<p>
この節は、
~web~browserに最も直に適用される特能を述べる。
とは言え，~web~browserかどうかにかかわらず、
この節に定義される要件は，`すべての~UA^emに適用される
— 他が指定されない限り。
◎
This section describes features that apply most directly to web browsers. Having said that, except where specified otherwise, the requirements defined in this section do apply to all user agents, whether they are web browsers or not.
</p>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

<p>
この仕様が参照する
`報告を~queueする@
~algoは，
`REPORTING$r にて定義されていたが、
“`報告を生成する$” に改称され，
その処理nの中の “報告を~queueする” 部分は “`報告を生成して~queueする$” に移動された。
この仕様~内の該当する箇所は、
それに順応するよう改める必要があろう。
</p>

		</section>
		<section id="loading-web-pages-supporting-concepts">
<h3 title="Supporting concepts">7.1. ~support用の概念</h3>

			<section id="origin">
<h4 title="Origins">7.1.1. 生成元</h4>

<p>
<ruby>生成元<rt>せいせいもと</rt></ruby>（ `origin^en ）は、
~webの~security~modelにおける基礎的な通貨である。
~web~platformにおける，ある生成元を共有する動作者たちは、
互いを信用し，同じ権限を有するものと見做される。
互いの生成元が相違する動作者たちは、
敵対的になり得るものと見なされ，様々な程度で互いに隔離される。
◎
Origins are the fundamental currency of the web's security model. Two actors in the web platform that share an origin are assumed to trust each other and to have the same authority. Actors with differing origins are considered potentially hostile versus each other, and are isolated from each other to varying degrees.
</p>

<p class="example">
例えば
`bank.example.com^c
にて~hostされている X 銀行の~web~siteが
`charity.example.org^c
にて~hostされている Y 事業体の~web~siteの~DOMを精査しようと試行した場合、
`SecurityError$E 例外が~~投出されることになる。
◎
For example, if Example Bank's web site, hosted at bank.example.com, tries to examine the DOM of Example Charity's web site, hosted at charity.example.org, a "SecurityError" DOMException will be raised.
</p>

<p class="trans-note">【
“~~生成元” という訳語は、
おそらく，~HTTP用語
`~~生成する＠~HTTPinfra#generate$
（ `generate^en ）に由来する
— より詳細には、
~HTTP要請に対し
`応答を生成した~server＠~HTTPinfra#origin-server$
（ `origin server^en ）（を識別する情報）を指す。
したがって， “~~生成元” の “~~元” の読みは、
`original^en（ “~~元の” ）を意味する “もと” であり， “げん” ではない。
】</p>

<hr>

<p id="origin-2">
`生成元@
（ `origin^en ）は、
次のいずれかとして与えられる：
◎
An origin is one of the following:
</p>

<dl class="def-list">
	<dt>
`不透明な生成元@
◎
An opaque origin
</dt>
	<dd>
直列化して再度~作成し直せない内部的な値であって
（`生成元を直列化する$ときは `null^l に直列化される）、
有意義な演算は，同等性を~testすることに限られる。
◎
An internal value, with no serialization it can be recreated from (it is serialized as "null" per serialization of an origin), for which the only meaningful operation is testing for equality.
</dd>

	<dt>
`成分組~生成元@
◎
A tuple origin
</dt>
	<dd>
<p>
順に，次に挙げるものからなる`~tuple$：
◎
A tuple consisting of:
</p>
		<ol>
			<li>
`~scheme@o
⇒
`~ASCII文字列$
◎
A scheme (an ASCII string).
</li>
			<li>
`~host@o

⇒
`~host$url
◎
A host (a host).
</li>
			<li>
`~port@o
⇒
~NULL ／ `16 ~bitな無符号~整数$
◎
A port (null or a 16-bit unsigned integer).
</li>
			<li>
`~domain@o
⇒
~NULL ／ `~domain$url
— 他が言明されない限り， ~NULL とする。
◎
A domain (null or a domain). Null unless stated otherwise.
</li>
		</ol>

<p class="note">注記：
`生成元$は共有され得る
— 例えば、
複数の`文書$間で。
加えて、
`生成元$は，一般に変異しない。
`成分組~生成元$の`~domain$oに限り，それも
`document.domain$c ~APIを通してのみ，変更され得る。
◎
Origins can be shared, e.g., among multiple Document objects. Furthermore, origins are generally immutable. Only the domain of a tuple origin can be changed, and only through the document.domain API.
</p>
	</dd>
</dl>

<div class="algo">
<p>
`生成元$ %生成元 の
`実効~domain@
は、
次に従って算出される：
◎
The effective domain of an origin origin is computed as follows:
</p>
<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET ~NULL
◎
If origin is an opaque origin, then return null.
</li>
	<li>
~IF［
%生成元 の`~domain$o ~NEQ ~NULL
］
⇒
~RET %生成元 の`~domain$o
◎
If origin's domain is non-null, then return origin's domain.
</li>
	<li>
~RET %生成元 の`~host$o
◎
Return origin's host.
</li>
</ol>
</div>

<div class="algo">
<p>
`生成元を直列化する@
~algoは、
所与の
( `生成元$ %生成元 )
に対し，文字列を返す：
◎
The serialization of an origin is the string obtained by applying the following algorithm to the given origin origin:
</p>
<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET `null^l
◎
If origin is an opaque origin, then return "null".
</li>
	<li>
%結果 ~LET 次を順に連結した結果
⇒＃
%生成元 の`~scheme$o,
`://^l,
`~hostを直列化する$( %生成元 の`~host$o )
◎
Otherwise, let result be origin's scheme.
◎
Append "://" to result.
◎
Append origin's host, serialized, to result.
</li>
	<li>
~IF［
%生成元 の`~port$o ~EQ ~NULL
］
⇒
~RET %結果
◎
↓</li>
	<li>
~RET 次を順に連結した結果
⇒＃
%結果,
`003A^U `:^smb,
`整数を直列化する$( %生成元 の`~port$o )
◎
If origin's port is non-null, append a U+003A COLON character (:), and origin's port, serialized, to result.
◎
Return result.
</li>
</ol>
</div>

<p class="example">
`成分組~生成元$
( `https^l, `xn--maraa-rta.example^l, ~NULL, ~NULL ) 
の`直列化$oは、
`https://xn--maraa-rta.example^l
になる。
◎
The serialization of ("https", "xn--maraa-rta.example", null, null) is "https://xn--maraa-rta.example".
</p>

<p id="unicode-serialisation-of-an-origin" class="note">注記：
`生成元の~Unicode直列化^i も利用されていたが、
それが広く採用されたことは，決してない。
◎
There used to also be a Unicode serialization of an origin. However, it was never widely adopted.
</p>

<hr>

<div class="algo">
<p>
2 つの`生成元$ ( %A, %B ) が
`同一-生成元@
であるとは、
~OR↓ を満たすことをいう：
◎
Two origins, A and B, are said to be same origin if the following algorithm returns true:
</p>
<ul>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
%A は`不透明な生成元$である
</li>
			<li>
%B は`不透明な生成元$である
</li>
			<li>
%A ~EQ %B
</li>
		</ul>
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
%A は`成分組~生成元$である
</li>
			<li>
%B は`成分組~生成元$である
</li>
			<li>
%A の`~scheme$o ~EQ %B の`~scheme$o
</li>
			<li>
%A の`~host$o ~EQ %B の`~host$o
</li>
			<li>
%A の`~port$o ~EQ %B の`~port$o
</li>
		</ul>
◎
If A and B are both tuple origins and their schemes, hosts, and port are identical, then return true.
◎
Return false.
</li>
</ul>

<p>
これは、
次のように表記されることもある【この表記法は、この訳に特有】
⇒＃
%A ~EQ`生成元$sub %B
（ ~NEQ`生成元$sub は、その否定を表す）
</p>
</div>

<div class="algo">
<p>
2 つの`生成元$ ( %A, %B ) が
`同じ生成元~domain@
であるとは、
~OR↓ を満たすことをいう：
◎
Two origins, A and B, are said to be same origin-domain if the following algorithm returns true:
</p>
<ul>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
%A は`不透明な生成元$である
</li>
			<li>
%B は`不透明な生成元$である
</li>
			<li>
%A ~EQ %B
</li>
		</ul>
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
%A は`成分組~生成元$である
</li>
			<li>
%B は`成分組~生成元$である
</li>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
<p>
~AND↓：
</p>
						<ul>
							<li>
%A の`~domain$o ~NEQ ~NULL
</li>
							<li>
%A の`~domain$o ~EQ %B の`~domain$o
</li>
							<li>
%A の`~scheme$o ~EQ %B の`~scheme$o
</li>
						</ul>
					</li>
					<li>
<p>
~AND↓：
</p>
						<ul>
							<li>
%A の`~domain$o ~EQ ~NULL
</li>
							<li>
%B の`~domain$o ~EQ ~NULL
</li>
							<li>
%A ~EQ`生成元$sub %B
</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
◎
If A and B are both tuple origins:
• If A and B's schemes are identical, and their domains are identical and non-null, then return true.
• Otherwise, if A and B are same origin and their domains are both null, return true.
◎
Return false.
</li>
</ul>
</div>

<div class="example">

<table class="grid-table _compare-origin"><thead>
<tr><th>%A ( ~scheme, ~host, ~port, ~domain )
<th>%B
<th>`同一-生成元$？
<th>`同じ生成元~domain$？
<tbody>

<tr><td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>✅
<td>✅

<tr><td>(`https^l, `example.org^l, 314, ~NULL)
<td>(`https^l, `example.org^l, 420, ~NULL)
<td>❌
<td>❌

<tr><td>(`https^l, `example.org^l, 314, `example.org^l)
<td>(`https^l, `example.org^l, 420, `example.org^l)
<td>❌
<td>✅

<tr><td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>(`https^l, `example.org^l, ~NULL, `example.org^l)
<td>✅
<td>❌

<tr><td>(`https^l, `example.org^l, ~NULL, `example.org^l)
<td>(`http^l, `example.org^l, ~NULL, `example.org^l)
<td>❌
<td>❌
</table>

</div>

				<section id="sites">
<h4 title="Sites">7.1.1.1. ~site</h4>

<p>
`~scheme＆~host@
は、
( ある`~ASCII文字列$
`~scheme@sh, 
ある`~host$
`~host@sh
)
が成す`~tuple$である。
◎
A scheme-and-host is a tuple of a scheme (an ASCII string) and a host (a host).
</p>

<p>
`~site@
は、［
`不透明な生成元$／`~scheme＆~host$
］である
◎
A site is an opaque origin or a scheme-and-host.
</p>

<div class="algo">
<p>
`~siteを得する@
~algoは、
所与の
( `生成元$ %生成元 )
に対し：
◎
To obtain a site, given an origin origin, run these steps:
</p>
<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET %生成元
◎
If origin is an opaque origin, then return origin.
</li>
	<li>
%~domain ~LET %生成元 の`~host$oの`登録-可能な~domain$
◎
↓</li>
	<li>
~IF［
%~domain ~EQ ~NULL
］
⇒
%~domain ~SET %生成元 の`~host$o
◎
↓</li>
	<li>
~RET ( %生成元 の`~scheme$o, %~domain )
◎
If origin's host's registrable domain is null, then return (origin's scheme, origin's host).
◎
Return (origin's scheme, origin's host's registrable domain).
</li>
</ol>
</div>

<div class="algo">
<p>
2 つの`~site$
( %A, %B ) が
`同一-~site@site
であるとは、
~OR↓ を満たすことをいう：
◎
Two sites, A and B, are said to be same site if the following algorithm returns true:
</p>
<ul>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
%A は`不透明な生成元$である
</li>
			<li>
%B は`不透明な生成元$である
</li>
			<li>
%A ~EQ %B
</li>
		</ul>
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
%A は`~scheme＆~host$である
</li>
			<li>
%B は`~scheme＆~host$である
</li>
			<li>
%A の`~scheme$sh ~EQ %B の`~scheme$sh
</li>
			<li>
( %A の`~host$sh, %B の`~host$sh )
は`同等な~host$である
</li>
		</ul>
◎
If A or B is an opaque origin, then return false.
◎
If A's and B's scheme values are different, then return false.
◎
If A's and B's host values are not equal, then return false.
◎
Return true.
</li>
</ul>
</div>

<div class="algo">
<p>
`~siteを直列化する@
~algoは、
所与の
( `~site$ %~site )
に対し，文字列を返す：
◎
The serialization of a site is the string obtained by applying the following algorithm to the given site site:
</p>
<ol>
	<li>
~IF［
%~site は`不透明な生成元$である
］
⇒
~RET `null^l
◎
If site is an opaque origin, then return "null".
</li>
	<li>
%結果 ~LET %~site[ 0 ]
◎
Let result be site[0].
</li>
	<li>
%結果 に
`://^l を付加する
◎
Append "://" to result.
</li>
	<li>
%結果 に次の結果を付加する
⇒
`~hostを直列化する$( %~site[1] )
◎
Append site[1], serialized, to result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="warning">
直列化された値は、
生成元ではなく~siteであることが文脈から明瞭に判る必要がある
— この 2 つには、
構文上の相違があるとは限らないので。
例えば，
生成元 ( `https^l, `shop.example^l, ~NULL, ~NULL )
の直列化と
~site ( `https^l, `shop.example^l )
の直列化は、
同じ `https://shop.example^l になる。
◎
It needs to be clear from context that the serialized value is a site, not an origin, as there is not necessarily a syntactic difference between the two. For example, the origin ("https", "shop.example", null, null) and the site ("https", "shop.example") have the same serialization: "https://shop.example".
</p>
</div>

<div class="algo">
<p>
2 つの`生成元$ ( %A, %B ) が
`~scheme無しで同一-~site@
であるとは、
~OR↓ を満たすことをいう：
◎
Two origins, A and B, are said to be schemelessly same site if the following algorithm returns true:
</p>
<ul>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
%A は`不透明な生成元$である
</li>
			<li>
%B は`不透明な生成元$である
</li>
			<li>
%A ~EQ %B
</li>
		</ul>
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
%A は`成分組~生成元$である
</li>
			<li>
%B は`成分組~生成元$である
</li>
			<li>
<p>
(
%A の`~host$o %hostA,
%hostA の`登録-可能な~domain$ %domainA,
%B の`~host$o %hostB,
%hostB の`登録-可能な~domain$ %domainB
)
は ~OR↓ を満たす：
</p>
				<ul>
					<li>
<p>
~AND↓：
</p>
						<ul>
							<li>
( %hostA, %hostB )
は`同等な~host$である
</li>
							<li>
%domainA ~EQ ~NULL
【したがって， %domainB ~EQ ~NULL 】
</li>
						</ul>
					</li>
					<li>
<p>
~AND↓：
</p>
						<ul>
							<li>
%domainA ~NEQ ~NULL
</li>
							<li>
%domainB ~NEQ ~NULL
</li>
							<li>
( %domainA, %domainB )
は`同等な~host$である
</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
◎
If A and B are both tuple origins, then:
• Let hostA be A's host, and let hostB be B's host.
• If hostA equals hostB and hostA's registrable domain is null, then return true.
• If hostA's registrable domain equals hostB's registrable domain and is non-null, then return true.
◎
Return false.
</li>
</ul>
</div>

<div class="algo">
<p>
2 つの`生成元$ ( %A, %B ) が
`同一-~site@
であるとは、
次の 2 つの結果が`同一-~site$siteであることをいう
⇒＃
`~siteを得する$( %A ),
`~siteを得する$( %B )
◎
Two origins, A and B, are said to be same site if the following algorithm returns true:
• Let siteA be the result of obtaining a site given A.
• Let siteB be the result of obtaining a site given B.
• If siteA is same site with siteB, then return true.
• Return false.
</p>

<p class="trans-note">【
( %A, %B ) が`同一-生成元$であるならば、
`同一-~site$でもある。
】</p>
</div>

<p class="note">注記：
［
`同一-生成元$, `同じ生成元~domain$
］の概念と違って、［
`~scheme無しで同一-~site$, `同一-~site$
］においては，［
`~port$o, `~domain$o
］成分は無視される。
◎
Unlike the same origin and same origin-domain concepts, for schemelessly same site and same site, the port and domain components are ignored.
</p>

<p class="warning">
`URL^cite にて
`説明される理由＠~URL1#warning-avoid-psl$から，［
`同一-~site$,
`~scheme無しで同一-~site$
］の概念は、
アリなときは避けるベキである
— `同一-生成元$を検査する方が好ましい。
◎
For the reasons explained in URL, the same site and schemelessly same site concepts should be avoided when possible, in favor of same origin checks.
</p>

<div id="example-same-site" class="example">
<p>
所与の`公共~接尾辞$［
`wildlife.museum^l, `museum^l, `com^l
］および，そうでない `example.com^l に対し：
◎
Given that wildlife.museum, museum, and com are public suffixes and that example.com is not:
</p>

<table class="grid-table _compare-origin"><thead>
<tr><th>%A ( ~scheme, ~host )
<th>%B
<th>`~scheme無しで同一-~site$？
<th>`同一-~site$？
<tbody>

<tr><td>(`https^l, `example.com^l)
<td>(`https^l, `sub.example.com^l)
<td>✅
<td>✅
<tr><td>(`https^l, `example.com^l)
<td>(`https^l, `sub.other.example.com^l)
<td>✅
<td>✅
<tr><td>(`https^l, `example.com^l)
<td>(`http^l, `non-secure.example.com^l)
<td>✅
<td>❌
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `sub.r.wildlife.museum^l)
<td>✅
<td>✅
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `sub.other.r.wildlife.museum^l)
<td>✅
<td>✅
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `other.wildlife.museum^l)
<td>❌
<td>❌
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `wildlife.museum^l)
<td>❌
<td>❌
<tr><td>(`https^l, `wildlife.museum^l)
<td>(`https^l, `wildlife.museum^l)
<td>✅
<td>✅
<tr><td>(`https^l, `example.com^l)
<td>(`https^l, `example.com.^l)
<td>❌
<td>❌
</table>

<p>
（ここでは、［
`~port$o, `~domain$o
］成分は考慮されないので省略している。）
◎
(Here we have omitted the port and domain components since they are not considered.)
</p>
</div>

				</section>
				<section id="relaxing-the-same-origin-restriction">
<h5 title="Relaxing the same-origin restriction">7.1.1.2. 同一-生成元による制約の緩め方</h5>

<dl class="domintro">
	<dt>%document.`domain$m [ = %domain ]</dt>
	<dd>
~security検査~用に利用される現在の~domainを返す。
◎
Returns the current domain used for security checks.
</dd>
	<dd>
下位domainを除去するような値に設定して，`生成元$の`~domain$oを変更できる
— そうすることにより，
同じ~domainに属する他の下位domain上の~pageと互いに~accessできるようになる
（それらも，同じことをしたならば）。
これは、
同じ~domainに属する異なる~host上の~pageが，
互いの~DOMへ同期的に~accessすることを可能化する。
◎
Can be set to a value that removes subdomains, to change the origin's domain to allow pages on other subdomains of the same domain (if they do the same thing) to access each other. This enables pages on different hosts of a domain to synchronously access each other's DOMs.
</dd>
	<dd>
［
次において／次のとき
］は、
設定子は `SecurityError$E 例外を投出することになる
⇒＃
~sandbox化された `iframe$e 内／
`不透明な生成元$を伴う`文書$内／
`属する閲覧~文脈$が無い`文書$内／
◎
In sandboxed iframes, Documents with opaque origins, and Documents without a browsing context, the setter will throw a "SecurityError" exception.＼
</dd>
	<dd>
［
`crossOriginIsolated＠~HTMLGAPI#dom-crossoriginisolated$m, `originAgentCluster$m
］どちらかが ~T を返す事例では、
設定子は何もしない。
◎
In cases where crossOriginIsolated or originAgentCluster return true, the setter will do nothing.
</dd>
</dl>

<div class="critical">

<p>
`document.domain$c 設定子を利用するのは、
避けること。
それは、
同一-生成元~施策が供する~security保護を蝕む。
とりわけ、
他者と~hostを共有しているとき，ひどいことになる：
例えば，信用できない第三者-主体が［
同じ~IP~address上の~portだけ異なる~HTTP~server
］を~hostできる場合、［
通常は同じ~host上の異なる~siteどうしを保護する，同一-生成元による保護
］は，失敗することになる
— `document.domain$c 設定子が利用されて以降は、
生成元の比較-時に，その~portは無視されるので。
◎
Avoid using the document.domain setter. It undermines the security protections provided by the same-origin policy. This is especially acute when using shared hosting; for example, if an untrusted third party is able to host an HTTP server at the same IP address but on a different port, then the same-origin protection that normally protects two different sites on the same host will fail, as the ports are ignored when comparing origins after the document.domain setter has been used.
</p>

<p>
これらの~securityの陥穽があるので、
この特能は~web~platformから除去されつつある過程にある
（何年もかかるであろう）。
◎
Because of these security pitfalls, this feature is in the process of being removed from the web platform. (This is a long process that takes many years.)
</p>

<p>
他の生成元と安全な方式で通信するためには、
代わりに［
`postMessage()＠~HTMLcomms#dom-window-postmessage$m ／ `MessageChannel$I ~obj
］を利用すること。
◎
Instead, use postMessage() or MessageChannel objects to communicate across origins in a safe manner.
</p>
</div>

<p>
`Document$I の
`domain@m
属性の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The domain getter steps are:
</p>
		<ol>
			<li>
%実効~domain ~LET コレの`生成元$docの`実効~domain$
◎
Let effectiveDomain be this's origin's effective domain.
</li>
			<li>
~IF［
%実効~domain ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If effectiveDomain is null, then return the empty string.
</li>
			<li>
~RET `~hostを直列化する$( %実効~domain )
◎
Return effectiveDomain, serialized.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The domain setter steps are:
</p>
		<ol>
			<li>
~IF［
コレが`属する閲覧~文脈$ ~EQ ~NULL
］
⇒
~THROW `SecurityError$E
◎
If this's browsing context is null, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
`~document-domain$sbox ~IN
コレにて`作動中な~sandbox法~flag集合$
］
⇒
~THROW `SecurityError$E
◎
If this's active sandboxing flag set has its sandboxed document.domain browsing context flag set, then throw a "SecurityError" DOMException.
</li>
			<li>
%実効~domain ~LET コレの`生成元$docの`実効~domain$
◎
Let effectiveDomain be this's origin's effective domain.
</li>
			<li>
~IF［
%実効~domain ~EQ ~NULL
］
⇒
~THROW `SecurityError$E
◎
If effectiveDomain is null, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
所与の値は %実効~domain に対し`登録-可能な~domain接尾辞または同等$でない
］
⇒
~THROW `SecurityError$E
◎
If the given value is not a registrable domain suffix of and is not equal to effectiveDomain, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
`~surrounding~agent$の`~agent~cluster$の`生成元を~keyにするか$ ~EQ ~T
］
⇒
~RET
◎
If the surrounding agent's agent cluster's is origin-keyed is true, then return.
</li>
			<li>
コレの`生成元$docの`~domain$o ~SET `~host構文解析器$( 所与の値 )
◎
Set this's origin's domain to the result of parsing the given value.
</li>
		</ol>
	</li>
</ul>

<div class="algo">
<p>
所与の`~scalar値~文字列$ %~host接尾辞~文字列 は`~host$ %元の~host に対し
`登録-可能な~domain接尾辞または同等@
であるかどうか決定するときは：
◎
To determine if a scalar value string hostSuffixString is a registrable domain suffix of or is equal to a host originalHost:
</p>
<ol>
	<li>
~IF［
%~host接尾辞~文字列 ~EQ 空~文字列
］
⇒
~RET ~F
◎
If hostSuffixString is the empty string, then return false.
</li>
	<li>
%~host接尾辞 ~LET `~host構文解析器$( %~host接尾辞~文字列 )
◎
Let hostSuffix be the result of parsing hostSuffixString.
</li>
	<li>
~IF［
%~host接尾辞 ~EQ `失敗^i
］
⇒
~RET ~F
◎
If hostSuffix is failure, then return false.
</li>
	<li>
<p>
~IF［
( %~host接尾辞, %元の~host )
は`同等な~host$でない
］：
◎
If hostSuffix does not equal originalHost, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~host接尾辞 は`~domain$urlでない
］~OR［
%元の~host は`~domain$urlでない
］
⇒
~RET ~F
◎
If hostSuffix or originalHost is not a domain, then return false.
</p>

<p class="note">注記：
どちらかの`~host$が`~IP~address$である場合、
この段で除外される。
◎
This excludes hosts that are IP addresses.
</p>
			</li>
			<li>
~IF［
%~host接尾辞 に `002E^U `.^smb を接頭した結果は、
%元の~host の尾部に合致しない
］
⇒
~RET ~F
◎
If hostSuffix, prefixed by U+002E (.), does not match the end of originalHost, then return false.
</li>
			<li>
<p>
~IF［
~OR↓
`URL$r
］…
◎
If any of the following are true:
</p>
				<ul class="brief">
					<li>
( %~host接尾辞, %~host接尾辞 の`公共~接尾辞$ )
は、
`同等な~host$である
◎
hostSuffix equals hostSuffix's public suffix; or
</li>
					<li>
%~host接尾辞 に `002E^U `.^smb を接頭した結果は、
%元の~host の`公共~接尾辞$の尾部に合致する
◎
hostSuffix, prefixed by U+002E (.), matches the end of originalHost's public suffix,
</li>
				</ul>
<p>
…ならば
⇒
~RET ~F
◎
then return false. [URL]
</p>
			</li>
			<li>
~Assert：
%元の~host の`公共~接尾辞$に `002E^U `.^smb を接頭した結果は、
%~host接尾辞 の尾部に合致する
◎
Assert: originalHost's public suffix, prefixed by U+002E (.), matches the end of hostSuffix.
</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="example" style="overflow-x:auto;" id="example-registrable-domain-suffix">
<table>
<caption>※
3 列目は、
`登録-可能な~domain接尾辞または同等$になるかどうかを表す。
</caption>
<tbody><tr><th>%~host接尾辞~文字列
<th>%元の~host
<th>※
<th>注記

<tr><td>`0.0.0.0^l
<td>`0.0.0.0^c
<td>✅
<td>

<tr><td>`0x10203^l
<td>`0.1.2.3^c
<td>✅
<td>

<tr><td>`[0::1]^l
<td>`::1^c
<td>✅
<td>

<tr><td>`example.com^l
<td>`example.com^c
<td>✅
<td>

<tr><td>`example.com^l
<td>`example.com.^c
<td>❌
<td rowspan="2">
末尾の~dotは有意になる。

<tr><td>`example.com.^l
<td>`example.com^c
<td>❌

<tr><td>`example.com^l
<td>`www.example.com^c
<td>✅
<td>

<tr><td>`com^l
<td>`example.com^c
<td>❌
<td>
これを書いた時点では、
`com^c は公共~接尾辞である。

<tr><td>`example^l
<td>`example^c
<td>✅
<td>

<tr><td>`compute.amazonaws.com^l
<td>`example.compute.amazonaws.com^c
<td>❌
<td rowspan="3">
これを書いた時点では、
`*.compute.amazonaws.com^c は公共~接尾辞である。

<tr><td>`example.compute.amazonaws.com^l
<td>`www.example.compute.amazonaws.com^c
<td>❌

<tr><td>`amazonaws.com^l
<td>`www.example.compute.amazonaws.com^c
<td>❌

<tr><td>`amazonaws.com^l
<td>`test.amazonaws.com^c
<td>✅
<td>
これを書いた時点では、
`amazonaws.com^c は登録-可能な~domainである。
</table>

◎
hostSuffixString｜originalHost｜Outcome of is a registrable domain suffix of or is equal to｜Notes
"0.0.0.0"｜0.0.0.0｜✅｜
"0x10203"｜0.1.2.3｜✅｜
"[0::1]"｜::1｜✅｜
"example.com"｜example.com｜✅｜
"example.com"｜example.com.｜❌｜Trailing dot is significant.
"example.com."｜example.com｜❌
"example.com"｜www.example.com｜✅｜
"com"｜example.com｜❌｜At the time of writing, com is a public suffix.
"example"｜example｜✅｜
"compute.amazonaws.com"｜example.compute.amazonaws.com｜❌｜At the time of writing, *.compute.amazonaws.com is a public suffix.
"example.compute.amazonaws.com"｜www.example.compute.amazonaws.com｜❌
"amazonaws.com"｜www.example.compute.amazonaws.com｜❌
"amazonaws.com"｜test.amazonaws.com｜✅｜At the time of writing, amazonaws.com is a registrable domain.
</div>

				</section>
			</section>
			<section id="origin-keyed-agent-clusters">
<h4 title="Origin-keyed agent clusters">7.1.2. 生成元を~keyにする~agent~cluster</h4>

<dl class="domintro">
	<dt>%window.`originAgentCluster$m</dt>
	<dd>
この`~window$が属する`~agent~cluster$は，
この節に述べる方式で`生成元$を`~keyに$するならば、
~T を返す。
◎
Returns true if this Window belongs to an agent cluster which is origin-keyed, in the manner described in this section.
</dd>
</dl>

<p>
`~secureな文脈$enV越しに送達される`文書$は、
`Origin-Agent-Cluster@h
~HTTP応答~headerを利用することにより，自身を`生成元$を`~keyに$するような`~agent~cluster$内に配置するよう要請できる。
この~headerは、
`有構造~header$であり，その値は`~sf真偽値$でなければナラナイ。
`STRUCTURED-FIELDS$r
◎
A Document delivered over a secure context can request that it be placed in an origin-keyed agent cluster, by using the `Origin-Agent-Cluster` HTTP response header. This header is a structured header whose value must be a boolean. [STRUCTURED-FIELDS]
</p>

<p>
`文書を作成して初期化する$処理~modelにより、
`~sf真偽値$ ~T （すなわち, `?1^bl ）でない値は無視されることになる。
◎
Per the processing model in the create and initialize a new Document object, values that are not the structured header boolean true value (i.e., `?1`) will be ignored.
</p>

<p>
この~headerを利用することによる帰結は：
◎
The consequences of using this header are that＼
</p>
<ul>
	<li>
結果の`文書$の`~agent~cluster~key$は、
`対応する~site＠#obtain-a-site$にはならず，文書の`生成元$docになる。
◎
the resulting Document's agent cluster key is its origin, instead of the corresponding site.＼
</li>
	<li>
観測-可能な効果としては、
`document.domain$c を利用して`同一-生成元~制約を緩めよう＠#relaxing-the-same-origin-restriction$と試みても，
何もしないことになり、
非同一-生成元に属する`文書$へ
`WebAssembly.Module＠https://webassembly.github.io/spec/js-api/#module$c
~objを送信することも，
アリでなくなる
（それらが`同一-~site$に属していようが）。
◎
In terms of observable effects, this means that attempting to relax the same-origin restriction using document.domain will instead do nothing, and it will not be possible to send WebAssembly.Module objects to cross-origin Documents (even if they are same site).＼
</li>
	<li>
この隔離は，舞台裏では、［
~processや~threadなど、
実装に特有な`~agent~cluster$に対応する資源
］をより効率的に割振ることを~UAに許容し得る。
◎
Behind the scenes, this isolation can allow user agents to allocate implementation-specific resources corresponding to agent clusters, such as processes or threads, more efficiently.
</li>
</ul>

<p>
`閲覧~文脈~group$の中では、［
`Origin-Agent-Cluster$h ~headerにより，同一-生成元に属する`文書$どうしが異なる`~agent~cluster$に属する結果に至る
］ことは，決してないことに注意
— それらのうち、
あるものは この~headerを送信し，
他のものは送信しない場合でも。
これは、
`履歴上の~agent~cluster~key~map$bcGにより防止される。
◎
Note that within a browsing context group, the `Origin-Agent-Cluster` header can never cause same-origin Document objects to end up in different agent clusters, even if one sends the header and the other doesn't. This is prevented by means of the historical agent cluster key map.
</p>

<p class="note">注記：
このことは、
同じ`閲覧~文脈~group$内に 以前に読込まれた同一-生成元~pageに対し，
この~headerが省略されていた場合、
`originAgentCluster$m 取得子は
— この~headerが ~T に設定されたとしても —
~F を返し得ることを意味する。
類似に、
~headerが ~T に設定されていないときでも， ~T を返し得る。
◎
This means that the originAgentCluster getter can return false, even if the header is set, if the header was omitted on a previously-loaded same-origin page in the same browsing context group. Similarly, it can return true even when the header is not set.
</p>

<div class="algo">
`originAgentCluster@m
取得子~手続きは
⇒
~RET `~surrounding~agent$の`~agent~cluster$の`生成元を~keyにするか$
◎
The originAgentCluster getter steps are to return the surrounding agent's agent cluster's is origin-keyed.
</div>

<p class="note">注記：
`文書$のうち，`不透明な生成元$に属するものは、
無条件に生成元を~keyにすると見なせる
— それらに対しては、
この~headerによる効果はなく，
`originAgentCluster$m 取得子は常に ~T を返すことになる。
◎
Documents with an opaque origin can be considered unconditionally origin-keyed; for them the header has no effect, and the originAgentCluster getter will always return true.
</p>

<p class="note">注記：
類似に，`~agent~cluster$のうち［
`非同一-生成元~隔離~mode$agC ~EQ `none$coI
］を満たすものに属する`文書$は、
自動的に生成元を~keyにする。
`Origin-Agent-Cluster$h ~headerは、［
資源の割振りについての実装に対する追加的な~hint
］としても有用になり得る
— が，それを追加しても、
作者~codeから観測-可能になる追加的な効果はない。
一方で，非同一-生成元~隔離を達成するために利用される［
`Cross-Origin-Opener-Policy$h ／
`Cross-Origin-Embedder-Policy$h 
］~headerは、［
同じ~address空間~内にある何もかもが，そこにあること
］を任意選択することを確保することに，より~~力点が置かれる。
◎
Similarly, Documents whose agent cluster's cross-origin isolation mode is not "none" are automatically origin-keyed. The `Origin-Agent-Cluster` header might be useful as an additional hint to implementations about resource allocation, since the `Cross-Origin-Opener-Policy` and `Cross-Origin-Embedder-Policy` headers used to achieve cross-origin isolation are more about ensuring that everything in the same address space opts in to being there. But adding it would have no additional observable effects on author code.
</p>

			</section>
			<section id="cross-origin-opener-policies">
<h4 title="Cross-origin opener policies">7.1.3. 非同一-生成元~opener施策</h4>

<p>
`~opener施策~値@
は、
`~top-level閲覧~文脈$内に~navigateされる【ことにより作成される】文書に対し，［
新たな`~top-level閲覧~文脈$, および
対応する`~group$tbcG
］の作成を強制することを許容する。
アリな値は：
◎
An opener policy value allows a document which is navigated to in a top-level browsing context to force the creation of a new top-level browsing context, and a corresponding group. The possible values are:
</p>
<dl>
	<dt>`unsafe-none@coop</dt>
	<dd>
これが（現在の）既定であり、
次を意味する
⇒
当の文書は、
それまでの文書
【~navigateされる前に作動中であった文書】
と同じ`~top-level閲覧~文脈$を占めることになる
— ただし、
当の文書と それまでの文書に異なる`~opener施策$が指定されている場合は除く。
◎
This is the (current) default and means that the document will occupy the same top-level browsing context as its predecessor, unless that document specified a different opener policy.
</dd>

	<dt>`same-origin-allow-popups@coop</dt>
	<dd>
これは、
次が満たされる場合を除き，当の文書~用に新たな`~top-level閲覧~文脈$の作成を強制する
⇒
当の文書と それまでの文書は、
`同一-生成元$である, かつ同じ`~opener施策$が指定されている
◎
This forces the creation of a new top-level browsing context for the document, unless its predecessor specified the same opener policy and they are same origin.
</dd>

	<dt>`same-origin@coop</dt>
	<dd>
これは， `same-origin-allow-popups$coop と同じに挙動するが、
それに加え
— そこに述べた条件が満たされない限り —
作成される`補助~閲覧~文脈$が包含している文書【当の文書】は~opener【それまでの文書】に対し~closedに現れることになる
【言い換えれば、それまでの文書から当の文書へは~accessし得なくなる】
。
◎
This behaves the same as "same-origin-allow-popups", with the addition that any auxiliary browsing context created needs to contain same origin documents that also have the same opener policy or it will appear closed to the opener.
</dd>

	<dt>`same-origin-plus-COEP@coop</dt>
	<dd>
これは， `same-origin$coop と同じに挙動するが、
それに加え，
（新たな）`~top-level閲覧~文脈$の`~group$tbcGの`非同一-生成元~隔離~mode$bcGを［
`logical$coI ／ `concrete$coI
］いずれかに設定する。
◎
This behaves the same as "same-origin", with the addition that it sets the (new) top-level browsing context's group's cross-origin isolation mode to one of "logical" or "concrete".
</dd>
	<dd class="note">注記：
`same-origin-plus-COEP$coop は、
`Cross-Origin-Opener-Policy$h ~headerを介して直に設定することはできないが，
次の組合nを一緒に設定した結果として得られる
⇒＃
`same-origin$coop を値にとる `Cross-Origin-Opener-Policy$h ~header,
`非同一-生成元~隔離と互換$な値をとる `Cross-Origin-Embedder-Policy$h ~header
◎
"same-origin-plus-COEP" cannot be directly set via the `Cross-Origin-Opener-Policy` header, but results from a combination of setting both `Cross-Origin-Opener-Policy: same-origin` and a `Cross-Origin-Embedder-Policy` header whose value is compatible with cross-origin isolation together.
</dd>

	<dt>`noopener-allow-popups@coop</dt>
	<dd>
これは、
当の文書~用に新たな`~top-level閲覧~文脈$の作成を強制する
— それまでの文書に関わらず。
◎
This forces the creation of a new top-level browsing context for the document, regardless of its predecessor.
</dd>
	<dd class="note">
<p>注記：
`noopener-allow-popups$coop 値を含めることで，［
それが適用された文書, その~opener
］との “~opener” 関係性は断たれるが、
それら同一-生成元な文書の間には，堅牢な~security境界は敷かれない。
◎
While including a noopener-allow-popups value severs the opener relationship between the document on which it is applied and its opener, it does not create a robust security boundary between those same-origin documents.
</p>

<p>
同一-生成元な~appによる他の~riskには，次が挙げられる：
◎
Other risks from same-origin applications include:
</p>
		<ul>
			<li>
当の文書の内容を~fetchしている同一-生成元な要請
— これは、
`FETCH-METADATA$r による~filter法を通して軽減することもできる。
◎
Same-origin requests fetching the document's content — could be mitigated through Fetch Metadata filtering. [FETCHMETADATA]
</li>
			<li>
同一-生成元な~frame化
— これは、［
`X-Frame-Options$h ／
~CSP `frame-ancestors$dir
］を通して軽減することもできる。
◎
Same-origin framing - could be mitigated through X-Frame-Options or CSP frame-ancestors.
</li>
			<li>
~JSから~access可能な~cookie
— これは、
すべての~cookieに `httponly＠~HTTPcookie#sane-httponly$c を伴わせることを確保することにより軽減できる。
◎
JavaScript accessible cookies - can be mitigated by ensuring all cookies are httponly.
</li>
			<li>
`localStorage$m による敏感な~dataへの~access。
◎
localStorage access to sensitive data.
</li>
			<li>
~swの~installation
◎
Service worker installation.
</li>
			<li>
`SW$r の `Cache$I ~APIによる敏感~dataへの操作や~access。
◎
Cache API manipulation or access to sensitive data. [SW]
</li>
			<li>
`postMessage()^m や `BroadcastChannel$I による敏感な情報を公開する~message法。
◎
postMessage or BroadcastChannel messaging that exposes sensitive information.
</li>
			<li>
`~autofill＠~HTMLautofill$は、
同一-生成元な文書~用には利用者-ヤリトリを要求しないであろう。
◎
Autofill which may not require user interaction for same-origin documents.
</li>
		</ul>
<p>
`noopener-allow-popups$coop を利用している開発者は、
次を~~確保する必要がある：
◎
Developers using noopener-allow-popups＼
</p>
		<ul>
			<li>
自身の敏感な~appが，［
他の同一-生成元な文書へ~access可能な~client側の特能
］に依拠しないようにする
— 例：
`localStorage$m その他の~client側~storage~API,
`BroadcastChannel$I やそれに関係する同一-生成元な通信の仕組み。
◎
need to make sure that their sensitive applications don't rely on client-side features accessible to other same-origin documents, e.g., localStorage and other client-side storage APIs, BroadcastChannel and related same-origin communication mechanisms.＼
</li>
			<li>
自身の~server側の端点は、
~naviでない要請に対する応答の内容が同一-生成元な文書から~access可能になる場合には，敏感な~dataを返さないようにする。
◎
They also need to make sure that their server-side endpoints don't return sensitive data to non-navigation requests, whose response content is accessible to same-origin documents.
</li>
		</ul>
	</dd>
</dl>

<p>
`~opener施策@
（ `opener policy^en ）は、
次に挙げるものからなる：
◎
An opener policy consists of:
</p>

<p class="trans-note">【
この仕様に現れる “COOP” は、
この用語の過去の名前
“非同一-生成元~opener施策 （ `cross-origin opener policy^en ）”
または `Cross-Origin-Opener-Policy^h
の略称。
しかしながら，非同一-生成元に限定されなくなったので
（新たに追加された `noopener-allow-popups$coop を見よ）、
このように改称された
（関連な課題： `#10373＠~HTMLissue/10373$, `#10374＠~HTMLissue/10374$ ）。
】</p>

<ul>
	<li>
`値@coOP
⇒
`~opener施策~値$
— 初期~時は `unsafe-none$coop とする。
◎
A value, which is an opener policy value, initially "unsafe-none".
</li>
	<li>
`報告先@coOP
⇒
文字列／ ~NULL
— 初期~時は ~NULL とする。
◎
A reporting endpoint, which is string or null, initially null.
</li>
	<li>
`報告のみの値@coOP
⇒
`~opener施策~値$
— 初期~時は `unsafe-none$coop とする。
◎
A report-only value, which is an opener policy value, initially "unsafe-none".
</li>
	<li>
`報告のみの報告先@coOP
⇒
文字列／ ~NULL
— 初期~時は ~NULL とする。
◎
A report-only reporting endpoint, which is a string or null, initially null.
</li>
</ul>

<div class="algo">
<p>
所与の
⇒＃
`~opener施策~値$ %文書の~COOP,
`生成元$ %文書の生成元,
`~opener施策~値$ %応答の~COOP,
`生成元$ %応答の生成元
◎終
が，
`~opener施策~値として合致して@
いるとは、
~AND↓ が満たされることをいう：
</p>
<ul>
	<li>
%文書の~COOP ~EQ %応答の~COOP
</li>
	<li>
［
%文書の~COOP ~EQ `unsafe-none$coop
］~OR［
%文書の生成元 ~EQ`生成元$sub %応答の生成元
］
</li>
</ul>

◎
To match opener policy values, given an opener policy value documentCOOP, an origin documentOrigin, an opener policy value responseCOOP, and an origin responseOrigin:
• If documentCOOP is "unsafe-none" and responseCOOP is "unsafe-none", then return true.
• If documentCOOP is "unsafe-none" or responseCOOP is "unsafe-none", then return false.
• If documentCOOP is responseCOOP and documentOrigin is same origin with responseOrigin, then return true.
• Return false.
</div>

				<section id="the-coop-headers">
<h5 title="The headers">7.1.3.1. 各種~header</h5>

<p>
`文書$の【！cross-origin】`~opener施策$docは、［
`Cross-Origin-Opener-Policy@h
／
`Cross-Origin-Opener-Policy-Report-Only@h
］~HTTP応答~headerから導出される。
これらは，`有構造~header$であり、
その値は`~sf~token$でなければナラナイ。
`STRUCTURED-FIELDS$r
◎
A Document's cross-origin opener policy is derived from the `Cross-Origin-Opener-Policy` and `Cross-Origin-Opener-Policy-Report-Only` HTTP response headers. These headers are structured headers whose value must be a token. [STRUCTURED-FIELDS]
</p>

<p>
`~opener施策~値$が，`~sf~token$として妥当になる。
各~tokenは`~sf~parameter群$も伴い得る
— それを成す
`report-to@coop
~parameterは、
適切な`報告先$を識別する`妥当な~URL文字列$をとり得る。
`REPORTING$r
◎
The valid token values are the opener policy values. The token may also have attached parameters; of these, the "report-to" parameter can have a valid URL string identifying an appropriate reporting endpoint. [REPORTING]
</p>

<p class="note">注記：
下に述べる処理~modelにより、
~UAは，次の場合にはこの~headerを無視することになる
⇒
値を`~sf~token$として構文解析できない／
妥当でない値を包含する
◎
Per the processing model described below, user agents will ignore this header if it contains an invalid value. Likewise, user agents will ignore this header if the value cannot be parsed as a token.
</p>

<hr>

<div class="algo">
<p>
`~opener施策を得する@
~algoは、
所与の
( `応答$ %応答, `環境$ %予約-済み環境 )
に対し：
◎
To obtain an opener policy given a response response and an environment reservedEnvironment:
</p>
<ol>
	<li>
%施策 ~LET 新たな`~opener施策$
◎
Let policy be a new opener policy.
</li>
	<li>
~IF［
%予約-済み環境 は`~secureな文脈$enVでない
］
⇒
~RET %施策
◎
If reservedEnvironment is a non-secure context, then return policy.
</li>
	<li>
%構文解析した~item ~LET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Cross-Origin-Opener-Policy$h, `~item^i )
◎
Let parsedItem be the result of getting a structured field value given `Cross-Origin-Opener-Policy` and "item" from response's header list.
</li>
	<li>
<p>
~IF［
%構文解析した~item ~NEQ ~NULL
］：
◎
If parsedItem is not null, then:
</p>
		<ol>
			<li>
%値 ~LET %構文解析した~item の`値$sfI【！%構文解析した~item[ 0 ]】
◎
↓</li>
			<li>
<p>
~IF［
%値 は`~sf~token$である【この条件は、この訳による補完】
］：
◎
↓</p>
				<ol>
					<li>
<p>
~IF［
%値 ~EQ `same-origin$coop
］：
◎
If parsedItem[0] is "same-origin", then:
</p>
						<ol>
							<li>
%~COEP ~LET `埋込元~施策を得する$( %応答, %予約-済み環境 )
◎
Let coep be the result of obtaining a cross-origin embedder policy from response and reservedEnvironment.
</li>
							<li>
%施策 の`値$coOP ~SET ［
次が満たされるならば `same-origin-plus-COEP$coop ／
~ELSE_ `same-origin$coop
］
⇒
%~COEP の`値$embPは`非同一-生成元~隔離と互換$である
◎
If coep's value is compatible with cross-origin isolation, then set policy's value to "same-origin-plus-COEP".
◎
Otherwise, set policy's value to "same-origin".
</li>
						</ol>
					</li>
					<li>
~IF［
%値 ~EQ `same-origin-allow-popups$coop
］
⇒
%施策 の`値$coOP ~SET `same-origin-allow-popups$coop
◎
If parsedItem[0] is "same-origin-allow-popups", then set policy's value to "same-origin-allow-popups".
</li>
					<li>
~IF［
%値 ~EQ `noopener-allow-popups$coop
］
⇒
%施策 の`値$coOP ~SET `noopener-allow-popups$coop
◎
If parsedItem[0] is "noopener-allow-popups", then set policy's value to "noopener-allow-popups".
</li>
					<li>
%report-to ~LET %構文解析した~item の`~parameter群$sfI[ `report-to$coop ]
◎
↓</li>
					<li>
~IF［
%report-to は`~sf文字列$である
］
⇒
%施策 の`報告先$coOP ~SET %report-to
◎
If parsedItem[1]["report-to"] exists and it is a string, then set policy's reporting endpoint to parsedItem[1]["report-to"].
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%構文解析した~item ~SET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Cross-Origin-Opener-Policy-Report-Only$h, `~item^i )
◎
Set parsedItem to the result of getting a structured field value given `Cross-Origin-Opener-Policy-Report-Only` and "item" from response's header list.
</li>
	<li>
<p>
~IF［
%構文解析した~item ~NEQ ~NULL
］：
◎
If parsedItem is not null, then:
</p>
		<ol>
			<li>
%値 ~LET %構文解析した~item の`値$sfI【！%構文解析した~item[ 0 ]】
◎
↓</li>
			<li>
<p>
~IF［
%値 は`~sf~token$である【この条件は、この訳による補完】
］：
◎
↓</p>
				<ol>
					<li>
<p>
~IF［
%値 ~EQ `same-origin$coop
］：
◎
If parsedItem[0] is "same-origin", then:
</p>
						<ol>
							<li>
%~COEP ~LET `埋込元~施策を得する$( %応答, %予約-済み環境 )
◎
Let coep be the result of obtaining a cross-origin embedder policy from response and reservedEnvironment.
</li>
							<li>
<p>
%施策 の`報告のみの値$coOP ~SET ［
次が満たされるならば `same-origin-plus-COEP$coop ／
~ELSE_ `same-origin$coop
］
⇒
［
%~COEP の`値$embPは`非同一-生成元~隔離と互換$である
］~OR［
%~COEP の`報告のみの値$embPは`非同一-生成元~隔離と互換$である
］
</p>

<p class="note">注記：
報告のみの~COOPは、
報告のみの~COEPも考慮した上で，特別な値 `same-origin-plus-COEP$coop をアテガう。
これは、［
~COOP, ~COEP
］の配備にあたって，より多くの自由度を開発者に許容する。
</p>
◎
If coep's value is compatible with cross-origin isolation or coep's report-only value is compatible with cross-origin isolation, then set policy's report-only value to "same-origin-plus-COEP".
◎
Report only COOP also considers report-only COEP to assign the special "same-origin-plus-COEP" value. This allows developers more freedom in the order of deployment of COOP and COEP.
◎
Otherwise, set policy's report-only value to "same-origin".
</li>
						</ol>
					</li>
					<li>
~IF［
%値 ~EQ `same-origin-allow-popups$coop
］
⇒
%施策 の`報告のみの値$coOP ~SET `same-origin-allow-popups$coop
◎
If parsedItem[0] is "same-origin-allow-popups", then set policy's report-only value to "same-origin-allow-popups".
</li>
					<li>
%report-to ~LET %構文解析した~item の`~parameter群$sfI[ `report-to$coop ]
◎
↓</li>
					<li>
~IF［
%report-to は`~sf文字列$である
］
⇒
%施策 の`報告のみの報告先$coOP ~SET %report-to
◎
If parsedItem[1]["report-to"] exists and it is a string, then set policy's report-only reporting endpoint to parsedItem[1]["report-to"].
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %施策
◎
Return policy.
</li>
</ol>
</div>

				</section>
				<section id="browsing-context-group-switches-due-to-cross-origin-opener-policy">
<h5 title="Browsing context group switches due to opener policy">7.1.3.2. ~opener施策に因る閲覧~文脈~groupの切替n</h5>

<div class="algo">
<p>
`~popupの~COOP値は閲覧~文脈~groupの切替nを要求するかどうか検査する@
~algoは、
所与の
⇒＃
`生成元$ %応答の生成元,
`生成元$ %作動中な文書の~navi生成元,
`値$coOP %応答の~COOP値,
`値$coOP %作動中な文書の~COOP値
◎終
に対し：
◎
To check if popup COOP values require a browsing context group switch, given two origins responseOrigin and activeDocumentNavigationOrigin, and two opener policy values responseCOOPValue and activeDocumentCOOPValue:
</p>
<ol>
	<li>
~IF［
%応答の~COOP値 ~EQ `noopener-allow-popups$coop
］
⇒
~RET ~T
◎
If responseCOOPValue is "noopener-allow-popups", then return true.
</li>
	<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
		<ul>
			<li>
%作動中な文書の~COOP値 の`値$coOP ~IN
{ `same-origin-allow-popups$coop, `noopener-allow-popups$coop }
◎
activeDocumentCOOPValue's value is "same-origin-allow-popups" or "noopener-allow-popups"; and
</li>
			<li>
%応答の~COOP値 ~EQ `unsafe-none$coop
◎
responseCOOPValue is "unsafe-none",
</li>
		</ul>
<p>
…ならば
⇒
~RET ~F
◎
then return false.
</p>
	</li>
	<li>
~IF［
( %作動中な文書の~COOP値,
%作動中な文書の~navi生成元,
%応答の~COOP値,
%応答の生成元 )
は、
`~opener施策~値として合致して$いる
］
⇒
~RET ~F
◎
If the result of matching activeDocumentCOOPValue, activeDocumentNavigationOrigin, responseCOOPValue, and responseOrigin is true, then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~COOP値は閲覧~文脈~groupの切替nを要求するかどうか検査する@
~algoは、
所与の
⇒＃
真偽値 %初期~about_blankか,
`生成元$ %応答の生成元,
`生成元$ %作動中な文書の~navi生成元,
`値$coOP %応答の~COOP値,
`値$coOP %作動中な文書の~COOP値
◎終
に対し：
◎
To check if COOP values require a browsing context group switch, given a boolean isInitialAboutBlank, two origins responseOrigin and activeDocumentNavigationOrigin, and two opener policy values responseCOOPValue and activeDocumentCOOPValue:
</p>
<ol>
	<li>
~IF［
%初期~about_blankか ~EQ ~T
］
⇒
~RET `~popupの~COOP値は閲覧~文脈~groupの切替nを要求するかどうか検査する$( ↓ )
⇒＃
%応答の生成元,
%作動中な文書の~navi生成元,
%応答の~COOP値,
%作動中な文書の~COOP値
◎
If isInitialAboutBlank is true, then return the result of checking if popup COOP values requires a browsing context group switch with responseOrigin, activeDocumentNavigationOrigin, responseCOOPValue, and activeDocumentCOOPValue.
</li>
	<li>
<p class="note">注記：
この段は、
非~popup~naviを処する。
◎
Here we are dealing with a non-popup navigation.
</p>

<p>
~RET ~IS［
( %作動中な文書の~COOP値,
%作動中な文書の~navi生成元,
%応答の~COOP値,
%応答の生成元 )
は、
`~opener施策~値として合致して$いない
］
◎
If the result of matching activeDocumentCOOPValue, activeDocumentNavigationOrigin, responseCOOPValue, and responseOrigin is true, then return false.
◎
Return true.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`報告のみの~COOPの施行-法は閲覧~文脈~groupの切替nを要求するかどうか検査する@
~algoは、
所与の
⇒＃
真偽値 %初期~about_blankか,
`生成元$ %応答の生成元,
`生成元$ %作動中な文書の~navi生成元,
`~opener施策$ %応答の~COOP,
`~opener施策$ %作動中な文書の報告のみの~COOP【！作動中な文書の~COOP】
◎終
に対し：
◎
To check if enforcing report-only COOP would require a browsing context group switch, given a boolean isInitialAboutBlank, two origins responseOrigin, activeDocumentNavigationOrigin, and two opener policies responseCOOP and activeDocumentCOOP:
</p>
<ol>
	<li>
<p>
~IF［
次の結果 ~EQ ~F
］…
⇒
`~COOP値は閲覧~文脈~groupの切替nを要求するかどうか検査する$( ↓ )
⇒＃
%初期~about_blankか,
%応答の生成元,
%作動中な文書の~navi生成元,
%応答の~COOP の`報告のみの値$coOP,
%作動中な文書の報告のみの~COOP の`報告のみの値$coOP
◎終
…ならば
⇒
~RET ~F
◎
If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank, responseOrigin, activeDocumentNavigationOrigin, responseCOOP's report-only value, and activeDocumentCOOPReportOnly's report-only value is false, then return false.
</p>

<p class="note">注記：
報告のみの施策の照合は、
~web~siteに次を許容する
⇒
~web~siteに属する すべての~pageに対し、
同じ［
報告のみの~opener施策
］を指定して，それらの~page間の~naviに対しては違反~報告を受信しない。
◎
Matching report-only policies allows a website to specify the same report-only opener policy on all its pages and not receive violation reports for navigations between these pages.
</p>
	</li>
	<li>
~IF［
次の結果 ~EQ ~T
］…
⇒
`~COOP値は閲覧~文脈~groupの切替nを要求するかどうか検査する$( ↓ )
⇒＃
%初期~about_blankか,
%応答の生成元,
%作動中な文書の~navi生成元,
%応答の~COOP の`値$coOP,
%作動中な文書の報告のみの~COOP の`報告のみの値$coOP
◎終
…ならば
⇒
~RET ~T
◎
If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank, responseOrigin, activeDocumentNavigationOrigin, responseCOOP's value, and activeDocumentCOOPReportOnly's report-only value is true, then return true.
</li>
	<li>
~IF［
次の結果 ~EQ ~T
］…
⇒
`~COOP値は閲覧~文脈~groupの切替nを要求するかどうか検査する$( ↓ )
⇒＃
%初期~about_blankか,
%応答の生成元,
%作動中な文書の~navi生成元,
%応答の~COOP の`報告のみの値$coOP,
%作動中な文書の報告のみの~COOP の`値$coOP
◎終
…ならば
⇒
~RET ~T
◎
If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank, responseOrigin, activeDocumentNavigationOrigin, responseCOOP's report-only value, and activeDocumentCOOPReportOnly's value is true, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<p>
`~opener施策の施行n結果@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
An opener policy enforcement result is a struct with the following items:
</p>
<ul>
	<li>
`閲覧~文脈~groupの切替nは必要か@cooP
⇒
真偽値
— 初期~時は ~F とする。
◎
A boolean needs a browsing context group switch, initially false.
</li>
	<li>
`報告のみに因る閲覧~文脈~groupの切替nは必要か@cooP
⇒
真偽値
— 初期~時は ~F とする。
◎
A boolean would need a browsing context group switch due to report-only, initially false.
</li>
	<li>
`~URL@cooP
⇒
`~URL$
◎
A URL url.
</li>
	<li>
`生成元@cooP
⇒
`生成元$
◎
An origin origin.
</li>
	<li>
`~opener施策@cooP
⇒
`~opener施策$
◎
An opener policy opener policy.
</li>
	<li>
`現在の文脈は~navi~sourceか@cooP
⇒
真偽値
— 初期~時は ~F とする。
◎
A boolean current context is navigation source, initially false.
</li>
</ul>

<div class="algo">
<p>
`応答の~opener施策を施行する@
~algoは、
所与の
⇒＃
`閲覧~文脈$ %閲覧~文脈,
`~URL$ %応答~URL,
`生成元$ %応答の生成元,
`~opener施策$ %応答の~COOP,
`~opener施策の施行n結果$ %現在の~COOP施行n結果,
`~referrer$rq %~referrer
◎終
に対し：
◎
To enforce a response's opener policy, given a browsing context browsingContext, a URL responseURL, an origin responseOrigin, an opener policy responseCOOP, an opener policy enforcement result currentCOOPEnforcementResult, and a referrer referrer:
</p>
<ol>
	<li>
%新たな~COOP施行n結果 ~LET 新たな`~opener施策の施行n結果$
— その
⇒＃
`閲覧~文脈~groupの切替nは必要か$cooP ~SET %現在の~COOP施行n結果 の`閲覧~文脈~groupの切替nは必要か$cooP,
`報告のみに因る閲覧~文脈~groupの切替nは必要か$cooP ~SET %現在の~COOP施行n結果 の`報告のみに因る閲覧~文脈~groupの切替nは必要か$cooP,
`~URL$cooP ~SET %応答~URL,
`生成元$cooP ~SET %応答の生成元,
`~opener施策$cooP ~SET %応答の~COOP,
`現在の文脈は~navi~sourceか$cooP ~SET ~T
◎
Let newCOOPEnforcementResult be a new opener policy enforcement result with
◎
needs a browsing context group switch
• currentCOOPEnforcementResult's needs a browsing context group switch
would need a browsing context group switch due to report-only
• currentCOOPEnforcementResult's would need a browsing context group switch due to report-only
url
• responseURL
origin
• responseOrigin
opener policy
• responseCOOP
current context is navigation source
• true
</li>
	<li>
%初期~about_blankか ~LET %閲覧~文脈 にて`作動中な文書$bcの`初期~about_blank か$doc
◎
Let isInitialAboutBlank be browsingContext's active document's is initial about:blank.
</li>
	<li>
~IF［
%初期~about_blankか ~EQ ~T
］~AND［
%閲覧~文脈 の`初期~URL$bc ~EQ ~NULL
］
⇒
%閲覧~文脈 の`初期~URL$bc ~SET %応答~URL
◎
If isInitialAboutBlank is true and browsingContext's initial URL is null, set browsingContext's initial URL to responseURL.
</li>
	<li>
<p>
~IF［
次の結果 ~EQ ~T
］…
⇒
`~COOP値は閲覧~文脈~groupの切替nを要求するかどうか検査する$( ↓ )
⇒＃
%初期~about_blankか,
%現在の~COOP施行n結果 の`~opener施策$cooP の`値$coOP,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の~COOP の`値$coOP,
%応答の生成元
◎終
…ならば：
◎
If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank, currentCOOPEnforcementResult's opener policy's value, currentCOOPEnforcementResult's origin, responseCOOP's value, and responseOrigin is true, then:
</p>
		<ol>
			<li>
%新たな~COOP施行n結果 の`閲覧~文脈~groupの切替nは必要か$cooP ~SET ~T
◎
Set newCOOPEnforcementResult's needs a browsing context group switch to true.
</li>
			<li>
<p>
~IF［
%閲覧~文脈 の`~group$tbcG の`閲覧~文脈~集合$bcGの`~size$ ~GT 1
］：
◎
If browsingContext's group's browsing context set's size is greater than 1, then:
</p>
				<ol>
					<li>
`~COOP応答へ~navigateするときの閲覧~文脈~groupの切替n用に違反~報告を~queueする$( ↓ )
⇒＃
%応答の~COOP,
`enforce^l,
%応答~URL,
%現在の~COOP施行n結果 の`~URL$cooP,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の生成元,
%~referrer
◎
Queue a violation report for browsing context group switch when navigating to a COOP response with responseCOOP, "enforce", responseURL, currentCOOPEnforcementResult's url, currentCOOPEnforcementResult's origin, responseOrigin, and referrer.
</li>
					<li>
`~COOP応答から~navigateして去るときの閲覧~文脈~groupの切替n用に違反~報告を~queueする$( ↓ )
⇒＃
%現在の~COOP施行n結果 の`~opener施策$cooP,
`enforce^l,
%現在の~COOP施行n結果 の`~URL$cooP,
%応答~URL,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の生成元,
%現在の~COOP施行n結果 の`現在の文脈は~navi~sourceか$cooP
◎
Queue a violation report for browsing context group switch when navigating away from a COOP response with currentCOOPEnforcementResult's opener policy, "enforce", currentCOOPEnforcementResult's url, responseURL, currentCOOPEnforcementResult's origin, responseOrigin, and currentCOOPEnforcementResult's current context is navigation source.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
次の結果 ~EQ ~T
］…
⇒
`報告のみの~COOPの施行-法は閲覧~文脈~groupの切替nを要求するかどうか検査する$( ↓ )
⇒＃
%初期~about_blankか,
%応答の生成元,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の~COOP,
%現在の~COOP施行n結果 の`~opener施策$cooP
◎終
…ならば：
◎
If the result of checking if enforcing report-only COOP would require a browsing context group switch given isInitialAboutBlank, responseOrigin, currentCOOPEnforcementResult's origin, responseCOOP, and currentCOOPEnforcementResult's opener policy, is true, then:
</p>
		<ol>
			<li>
%新たな~COOP施行n結果 の`報告のみに因る閲覧~文脈~groupの切替nは必要か$cooP ~SET ~T
◎
Set newCOOPEnforcementResult's would need a browsing context group switch due to report-only to true.
</li>
			<li>
<p>
~IF［
%閲覧~文脈 の`~group$tbcG の`閲覧~文脈~集合$bcGの`~size$ ~GT 1
］：
◎
If browsingContext's group's browsing context set's size is greater than 1, then:
</p>
				<ol>
					<li>
`~COOP応答へ~navigateするときの閲覧~文脈~groupの切替n用に違反~報告を~queueする$( ↓ )
⇒＃
%応答の~COOP,
`reporting^l,
%応答~URL,
%現在の~COOP施行n結果 の`~URL$cooP,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の生成元,
%~referrer
◎
Queue a violation report for browsing context group switch when navigating to a COOP response with responseCOOP, "reporting", responseURL, currentCOOPEnforcementResult's url, currentCOOPEnforcementResult's origin, responseOrigin, and referrer.
</li>
					<li>
`~COOP応答から~navigateして去るときの閲覧~文脈~groupの切替n用に違反~報告を~queueする$( ↓ )
⇒＃
%現在の~COOP施行n結果 の`~opener施策$cooP,
`reporting^l,
%現在の~COOP施行n結果 の`~URL$cooP,
%応答~URL,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の生成元,
%現在の~COOP施行n結果 の`現在の文脈は~navi~sourceか$cooP
◎
Queue a violation report for browsing context group switch when navigating away from a COOP response with currentCOOPEnforcementResult's opener policy, "reporting", currentCOOPEnforcementResult's url, responseURL, currentCOOPEnforcementResult's origin, responseOrigin, and currentCOOPEnforcementResult's current context is navigation source.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %新たな~COOP施行n結果
◎
Return newCOOPEnforcementResult.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navi応答~用に利用する閲覧~文脈を得する@
~algoは、
所与の
( `~navi~params$ %~navi~params )
に対し：
◎
To obtain a browsing context to use for a navigation response, given navigation params navigationParams:
</p>
<ol>
	<li>
%閲覧~文脈 ~LET %~navi~params の`~navigable$nvPにて`作動中な閲覧~文脈$nav
◎
Let browsingContext be navigationParams's navigable's active browsing context.
</li>
	<li>
~IF［
%閲覧~文脈 は`~top-level閲覧~文脈$でない
］
⇒
~RET %閲覧~文脈
◎
If browsingContext is not a top-level browsing context, then return browsingContext.
</li>
	<li>
%~COOP施行n結果 ~LET %~navi~params の`~COOP施行n結果$nvP
◎
Let coopEnforcementResult be navigationParams's COOP enforcement result.
</li>
	<li>
%~groupを入替えるか ~LET %~COOP施行n結果 の`閲覧~文脈~groupの切替nは必要か$cooP
◎
Let swapGroup be coopEnforcementResult's needs a browsing context group switch.
</li>
	<li>
%~source生成元 ~LET %閲覧~文脈 にて`作動中な文書$bcの`生成元$doc
◎
Let sourceOrigin be browsingContext's active document's origin.
</li>
	<li>
%行先~生成元 ~LET %~navi~params の`生成元$nvP
◎
Let destinationOrigin be navigationParams's origin.
</li>
	<li>
<p>
~IF［
( %~source生成元, %行先~生成元 )
は`同一-~site$でない
］：
◎
If sourceOrigin is not same site with destinationOrigin:
</p>
		<ol>
			<li>
<p>
~IF［
~AND↓
］…
◎
If＼
</p>
				<ul>
					<li>
［
%~source生成元, %行先~生成元
］どちらかの`~scheme$oは`~HTTP_S~scheme$でない
◎
either of sourceOrigin or destinationOrigin have a scheme that is not an HTTP(S) scheme and＼
</li>
					<li>
~UAは、［
%~source生成元 と %行先~生成元 を互いに隔離すること
］が（`実装定義$な理由で）必要yであるものと見なす
◎
the user agent considers it necessary for sourceOrigin and destinationOrigin to be isolated from each other (for implementation-defined reasons),＼
</li>
				</ul>
<p>
…ならば
⇒
任意選択で
⇒
%~groupを入替えるか ~SET ~T
◎
optionally set swapGroup to true.
</p>

<p class="note">注記：
例えば，利用者が `about:settings^c から `https://example.com^c へ~navigateした場合、
~UAは，入替nを強制することもできる。
◎
For example, if a user navigates from about:settings to https://example.com, the user agent could force a swap.
</p>

<p class="XXX">
この段を任意選択なまま放置せずに相互運用可能な挙動に決着することは、
`課題 #10842＠~HTMLissue/10842$ が追跡する。
◎
Issue #10842 tracks settling on an interoperable behavior here, instead of letting this be optional.
</p>
			</li>
			<li>
<p>
~IF［
%~navi~params の`利用者-関与i$nvP ~EQ `~browser~UI$i
］
⇒
任意選択で
⇒
%~groupを入替えるか ~SET ~T
◎
If navigationParams's user involvement is "browser UI", optionally set swapGroup to true.
</p>

<p class="XXX">
この段を任意選択なまま放置せずに相互運用可能な挙動に決着することは、
`課題 #6356＠~HTMLissue/6356$が追跡する。
◎
Issue #6356 tracks settling on an interoperable behavior here, instead of letting this be optional.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%閲覧~文脈 の`~group$tbcGの`閲覧~文脈~集合$bcGの`~size$ ~EQ 1
］
⇒
任意選択で
⇒
%~groupを入替えるか ~SET ~T
◎
If browsingContext's group's browsing context set's size is 1, optionally set swapGroup to true.
</p>

<p class="note">注記：
一部の実装は、
処理能の理由から，
ここで閲覧~文脈~groupたちを入替える。
◎
Some implementations swap browsing context groups here for performance reasons.
</p>

<p class="note">注記：
［
この文脈【 %閲覧~文脈 ？】を~scriptし得る他の文脈
］用の検査は、［
~web~pageにも影響し得る，挙動における相違
］を防止するためには足らない。
現在は他の文脈は無い場合でも，行先~pageは~windowを開くこともでき、
利用者がそれから~navigateして戻った場合、
以前の~pageは，開いた~windowが~script可能になることを期待することもある。
ここで入替nを行うと、
そのような利用事例を非互換化することになろう。
◎
The check for other contexts that could script this one is not sufficient to prevent differences in behavior that could affect a web page. Even if there are currently no other contexts, the destination page could open a window, then if the user navigates back, the previous page could expect to be able to script the opened window. Doing a swap here would break that use case.
</p>
	</li>
	<li>
<p>
~IF［
%~groupを入替えるか ~EQ ~F
］：
◎
If swapGroup is false, then:
</p>
		<ol>
			<li>
~IF［
%~COOP施行n結果 の`報告のみに因る閲覧~文脈~groupの切替nは必要か$cooP ~EQ ~T
］
⇒
%閲覧~文脈 の`~virtual閲覧~文脈~group~ID$bc ~SET 新たな一意な識別子
◎
If coopEnforcementResult's would need a browsing context group switch due to report-only is true, set browsingContext's virtual browsing context group ID to a new unique identifier.
</li>
			<li>
~RET %閲覧~文脈
◎
Return browsingContext.
</li>
		</ol>
	</li>
	<li>
<p>
%新たな閲覧~文脈 ~LET 次の結果を成す閲覧~文脈
⇒
`新たな~top-level閲覧~文脈と文書を作成する$()
◎
Let newBrowsingContext be the first return value of creating a new top-level browsing context and document.
</p>

<p class="note">注記：
この事例では、
閲覧~文脈~groupの入れ替えを遂行しようとしている。
%閲覧~文脈 は、
`作成されつつ＠~HTMLlifecycle#initialise-the-document-object$ある新たな`文書$には利用されないことになる。
いずれにせよ，それが他の`文書$（`~BF~cache$内にあるものなど）により利用されない場合、
~UAは，この時点で`それを破壊する＠~HTMLds#a-browsing-context-is-discarded$かもしれない。
◎
In this case we are going to perform a browsing context group swap. browsingContext will not be used by the new Document that we are about to create. If it is not used by other Documents either (such as ones in the back/forward cache), then the user agent might destroy it at this point.
</p>
	</li>
	<li>
%~navi~COOP ~LET %~navi~params の`~opener施策$nvP
◎
Let navigationCOOP be navigationParams's cross-origin opener policy.
</li>
	<li>
<p>
~IF［
%~navi~COOP の`値$coOP ~EQ `same-origin-plus-COEP$coop
］
⇒
%新たな閲覧~文脈 の`~group$tbcGの`非同一-生成元~隔離~mode$bcG ~SET ［
`logical$coI ／ `concrete$coI
］
— どちらが選ばれるかは、
`実装定義$とする
◎
If navigationCOOP's value is "same-origin-plus-COEP", then set newBrowsingContext's group's cross-origin isolation mode to either "logical" or "concrete". The choice of which is implementation-defined.
</p>

<p class="note">注記：
【（この段落より詳細な）`非同一-生成元~隔離~mode$に付随する注記を見よ。】
◎
It is difficult on some platforms to provide the security properties required by the cross-origin isolated capability. "concrete" grants access to it and "logical" does not.
</p>
	</li>
	<li>
%~sandbox~flag群 ~LET %~navi~params の`最終-~sandbox~flag集合$nvPを`~cloneする$
◎
Let sandboxFlags be a clone of navigationParams's final sandboxing flag set.
</li>
	<li>
<p>
~IF［
%~sandbox~flag群 は空でない
］：
◎
If sandboxFlags is not empty, then:
</p>
		<ol>
			<li>
~Assert：
%~navi~COOP の`値$coOP ~EQ `unsafe-none$coop
◎
Assert: navigationCOOP's value is "unsafe-none".
</li>
			<li>
~Assert：
%新たな閲覧~文脈 の`~popup~sandbox法~flag集合$は`空$である。
◎
Assert: newBrowsingContext's popup sandboxing flag set is empty.
</li>
			<li>
%新たな閲覧~文脈 の`~popup~sandbox法~flag集合$ ~SET %~sandbox~flag群
◎
Set newBrowsingContext's popup sandboxing flag set to sandboxFlags.
</li>
		</ol>
	</li>
	<li>
~RET %新たな閲覧~文脈
◎
Return newBrowsingContext.
</li>
</ol>
</div>

				</section>
				<section id="coep-reporting">
<h5 title="Reporting">7.1.3.3. 報告-法</h5>

<p>
`~accessedと~accessorの関係性@
は、
`閲覧~文脈$どうしで~accessが起きたときの関係性を述べる列挙値であり，
次に挙げる値をとり得る：
◎
An accessor-accessed relationship is an enum that describes the relationship between two browsing contexts between which an access happened. It can take the following values:
</p>
<dl class="def-list">
	<dt>
`~accessorは~opener@i
◎
accessor is opener
</dt>
	<dd>
［
~accessorである`閲覧~文脈$または その`先祖~閲覧~文脈$
］のいずれかが，［
~accessedである`閲覧~文脈$の`~top-level閲覧~文脈$bc
］を`開いた閲覧~文脈$bcである。
◎
The accessor browsing context or one of its ancestors is the opener browsing context of the accessed browsing context's top-level browsing context.
</dd>

	<dt>
`~accessorは~openee@i
◎
accessor is openee
</dt>
	<dd>
［
~accessedである`閲覧~文脈$または その`先祖~閲覧~文脈$
］のいずれかが，［
~accessorである`閲覧~文脈$の`~top-level閲覧~文脈$bc
］を`開いた閲覧~文脈$bcである。
◎
The accessed browsing context or one of its ancestors is the opener browsing context of the accessor browsing context's top-level browsing context.
</dd>
	<dt>
`~~無関係@i
◎
none
</dt>
	<dd>
上述した どちらにも該当しない。
◎
There is no opener relationship between the accessor browsing context, the accessor browsing context, or any of their ancestors.
</dd>
</dl>

<div class="algo">
<p>
`閲覧~文脈どうしの~accessは報告されるべきかどうか検査する@
~algoは、
所与の
⇒＃
`閲覧~文脈$ %~accessor,
`閲覧~文脈$ %~accessed,
~JS~prop名 %P,
`環境~設定群~obj$ %環境
◎終
に対し：
◎
To check if an access between two browsing contexts should be reported, given two browsing contexts accessor and accessed, a JavaScript property name P, and an environment settings object environment:
</p>
<ol>
	<li>
~IF［
%P は`非同一-生成元から~access可能な~window~prop名$でない
］
⇒
~RET
◎
If P is not a cross-origin accessible window property name, then return.
</li>
	<li>
~Assert：［
%~accessor にて`作動中な文書$bc,
%~accessed にて`作動中な文書$bc
］は、
どちらも`全部的に作動中$である。
◎
Assert: accessor's active document and accessed's active document are both fully active.
</li>
	<li>
%~accessor~top ~LET %~accessor の`~top-level閲覧~文脈$bc
◎
Let accessorTopDocument be accessor's top-level browsing context's active document.
◎
Let accessorInclusiveAncestorOrigins be the list obtained by taking the origin of the active document of each of accessor's active document's inclusive ancestor navigables.
</li>
	<li>
%~accessed~top ~LET %~accessed の`~top-level閲覧~文脈$bc
◎
Let accessedTopDocument be accessed's top-level browsing context's active document.
◎
Let accessedInclusiveAncestorOrigins be the list obtained by taking the origin of the active document of each of accessed's active document's inclusive ancestor navigables.
</li>
	<li>
%~accessor にて`作動中な文書$bcの`広義-先祖~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
~IF［
%~navigable にて`作動中な文書$navの`生成元$doc
~NEQ`生成元$sub
%~accessor~top にて`作動中な文書$bcの`生成元$doc
］
⇒
~RET
◎
If any of accessorInclusiveAncestorOrigins are not same origin with accessorTopDocument's origin,＼
◎
↓</li>
	<li>
<p>
%~accessed にて`作動中な文書$bcの`広義-先祖~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
~IF［
%~navigable にて`作動中な文書$navの`生成元$doc
~NEQ`生成元$sub
%~accessed~top にて`作動中な文書$bcの`生成元$doc
］
⇒
~RET
◎
or if any of accessedInclusiveAncestorOrigins are not same origin with accessedTopDocument's origin, then return.
</p>

<p class="note">注記：
この段と前~段は、［
非同一-生成元に属する~iframeについての情報
］が［
~opener施策を報告している~top-levelの~frameへ漏洩する
］のを避ける。
◎
This avoids leaking information about cross-origin iframes to a top level frame with opener policy reporting.
</p>
   </li>
	<li>
~IF［
%~accessor~top の`~virtual閲覧~文脈~group~ID$bc
~EQ
%~accessed~top の`~virtual閲覧~文脈~group~ID$bc
］
⇒
~RET
◎
If accessor's top-level browsing context's virtual browsing context group ID is accessed's top-level browsing context's virtual browsing context group ID, then return.
</li>
	<li>
%~accessorと~accessedの関係性 ~LET 【！新たな`~accessedと~accessorの関係性$】`~~無関係$i
◎
Let accessorAccessedRelationship be a new accessor-accessed relationship with value none.
</li>
	<li>
~IF［
%~accessed~top を`開いた閲覧~文脈$bc ~IN 
{ %~accessor, %~accessor の`先祖~閲覧~文脈$たち }
］
⇒
%~accessorと~accessedの関係性 ~SET `~accessorは~opener$i
◎
If accessed's top-level browsing context's opener browsing context is accessor or is an ancestor of accessor, then set accessorAccessedRelationship to accessor is opener.
</li>
	<li>
~IF［
%~accessor~top を`開いた閲覧~文脈$bc ~IN 
{ %~accessed, %~accessed の`先祖~閲覧~文脈$たち }
］
⇒
%~accessorと~accessedの関係性 ~SET `~accessorは~openee$i
◎
If accessor's top-level browsing context's opener browsing context is accessed or is an ancestor of accessed, then set accessorAccessedRelationship to accessor is openee.
</li>
	<li>
`各種~access用に違反~報告を~queueする$( ↓ )
⇒＃
%~accessorと~accessedの関係性,
%~accessor~top にて`作動中な文書$bcの`~opener施策$doc,
%~accessed~top にて`作動中な文書$bcの`~opener施策$doc,
%~accessor にて`作動中な文書$bcの`~URL$doc,
%~accessed にて`作動中な文書$bcの`~URL$doc,
%~accessor~top の`初期~URL$bc,
%~accessed~top の`初期~URL$bc,
%~accessor にて`作動中な文書$bcの`生成元$doc,
%~accessed にて`作動中な文書$bcの`生成元$doc,
%~accessor~top の`作成時の~opener生成元$bc,
%~accessed~top の`作成時の~opener生成元$bc,
%~accessor~top にて`作動中な文書$bcの`~referrer$doc,
%~accessed~top にて`作動中な文書$bcの`~referrer$doc,
%P,
%環境
◎
Queue violation reports for accesses, given accessorAccessedRelationship, accessorTopDocument's opener policy, accessedTopDocument's opener policy, accessor's active document's URL, accessed's active document's URL, accessor's top-level browsing context's initial URL, accessed's top-level browsing context's initial URL, accessor's active document's origin, accessed's active document's origin, accessor's top-level browsing context's opener origin at creation, accessed's top-level browsing context's opener origin at creation, accessorTopDocument's referrer, accessedTopDocument's referrer, P, and environment.
</li>
</ol>
</div>

<div class="algo">
<p>
`報告~内に送信する~URLを無毒化する@
~algoは、
所与の
( `~URL$ %~URL )
に対し：
◎
To sanitize a URL to send in a report given a URL url:
</p>
<ol>
	<li>
%無毒化した~URL ~LET %~URL の複製
◎
Let sanitizedURL be a copy of url.
</li>
	<li>
`~URLの~usernameを設定する$( %無毒化した~URL, 空~文字列 )
◎
Set the username given sanitizedURL and the empty string.
</li>
	<li>
`~URLの~passwordを設定する$( %無毒化した~URL, 空~文字列 )
◎
Set the password given sanitizedURL and the empty string.
</li>
	<li>
~RET `~URLを直列化する$( %無毒化した~URL, `素片は除外する$i )
◎
Return the serialization of sanitizedURL with exclude fragment set to true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~COOP応答へ~navigateするときの閲覧~文脈~groupの切替n用に違反~報告を~queueする@
~algoは、
所与の
⇒＃
`~opener施策$ %~COOP,
文字列 %処置,
`~URL$ %~COOP~URL,
`~URL$ %以前の応答の~URL,
`生成元$ %~COOP生成元
`生成元$ %以前の応答の生成元,
`~referrer$rq %~referrer
◎終
に対し：
◎
To queue a violation report for browsing context group switch when navigating to a COOP response given an opener policy coop, a string disposition, a URL coopURL, a URL previousResponseURL, two origins coopOrigin and previousResponseOrigin, and a referrer referrer:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
%~COOP値 ~LET %処置 に応じて
⇒＃
`reporting^l ならば %~COOP の`報告のみの値$coOP ／
~ELSE_ %~COOP の`値$coOP
◎
Let coopValue be coop's value.
◎
If disposition is "reporting", then set coopValue to coop's report-only value.
</li>
	<li>
%直列化した~referrer ~LET %~referrer に応じて
⇒＃
`~URL$であるならば `~URLを直列化する$( %~referrer ) ／
~ELSE_ %~referrer
◎
Let serializedReferrer be an empty string.
◎
If referrer is a URL, set serializedReferrer to the serialization of referrer.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
<tbody>

<tr><td>`disposition^c
<td>%処置

<tr><td>`effectivePolicy^c
<td>%~COOP値

<tr><td>`previousResponseURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %以前の応答の生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %以前の応答~URL )

<tr><td>`referrer^c
<td>%直列化した~referrer

<tr><td>`type^c
<td>`navigation-to-response^l
</table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜disposition
• effectivePolicy｜coopValue
• previousResponseURL｜If coopOrigin and previousResponseOrigin are same origin this is the sanitization of previousResponseURL, null otherwise.
• referrer｜serializedReferrer
• type｜"navigation-to-response"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, ε, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`~COOP応答から~navigateして去るときの閲覧~文脈~groupの切替n用に違反~報告を~queueする@
~algoは、
所与の
⇒＃
`~opener施策$ %~COOP,
文字列 %処置,
`~URL$ %~COOP~URL,
`~URL$ %以後の応答の~URL,
`生成元$ %~COOP生成元
`生成元$ %以後の応答の生成元,
真偽値 %~COOP応答は~navi~sourceか
◎終
に対し：
◎
To queue a violation report for browsing context group switch when navigating away from a COOP response given an opener policy coop, a string disposition, a URL coopURL, a URL nextResponseURL, two origins coopOrigin and nextResponseOrigin, and a boolean isCOOPResponseNavigationSource:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
%~COOP値 ~LET %処置 に応じて
⇒＃
`reporting^l ならば %~COOP の`報告のみの値$coOP ／
~ELSE_ %~COOP の`値$coOP
◎
Let coopValue be coop's value.
◎
If disposition is "reporting", then set coopValue to coop's report-only value.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
<tbody>

<tr><td>`disposition^c
<td>%処置

<tr><td>`effectivePolicy^c
<td>%~COOP値

<tr><td>`nextResponseURL^c
<td>
［
%~COOP生成元 ~EQ`生成元$sub %以後の応答の生成元
］~AND［
%~COOP応答は~navi~sourceか ~EQ ~T
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %以後の応答の~URL )

<tr><td>`type^c
<td>`navigation-from-response^l
</table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜disposition
• effectivePolicy｜coopValue
• nextResponseURL｜If coopOrigin and nextResponseOrigin are same origin or isCOOPResponseNavigationSource is true, this is the sanitization of nextResponseURL, null otherwise.
• type｜"navigation-from-response"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, ε, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`各種~access用に違反~報告を~queueする@
~algoは、
所与の
⇒＃
`~accessedと~accessorの関係性$ %~accessorと~accessedの関係性,
`~opener施策$ %~accessorの~COOP,
`~opener施策$ %~accessedの~COOP,
`~URL$ %~accessorの~URL,
`~URL$ %~accessedの~URL,
`~URL$ %~accessorの初期~URL,
`~URL$ %~accessedの初期~URL,
`生成元$ %~accessorの生成元,
`生成元$ %~accessedの生成元,
`生成元$ %~accessorの作成元の生成元
`生成元$ %~accessedの作成元の生成元,
`~referrer$doc %~accessorの~referrer,
`~referrer$doc %~accessedの~referrer,
文字列 %~prop名,
`環境~設定群~obj$ %環境
◎終
に対し：
◎
To queue violation reports for accesses, given an accessor-accessed relationship accessorAccessedRelationship, two opener policies accessorCOOP and accessedCOOP, four URLs accessorURL, accessedURL, accessorInitialURL, accessedInitialURL, four origins accessorOrigin, accessedOrigin, accessorCreatorOrigin and accessedCreatorOrigin, two referrers accessorReferrer and accessedReferrer, a string propertyName, and an environment settings object environment:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
%~COOP値 ~LET %処置 に応じて
⇒＃
`reporting^l ならば %~COOP の`報告のみの値$coOP ／
~ELSE_ %~COOP の`値$coOP
◎
Let coopValue be coop's value.
◎
If disposition is "reporting", then set coopValue to coop's report-only value.
</li>
	<li>
<p>
~IF［
%~accessorと~accessedの関係性 ~EQ `~accessorは~opener$i
］：
◎
If accessorAccessedRelationship is accessor is opener:
</p>
		<ol>
			<li>
`~openした~windowへの~access用に違反~報告を~queueする$( ↓ )
⇒＃
%~accessorの~COOP,
%~accessorの~URL,
%~accessedの~URL,
%~accessedの初期~URL,
%~accessorの生成元,
%~accessedの生成元,
%~accessedの作成元の生成元,
%~prop名,
%環境
◎
Queue a violation report for access to an opened window, given accessorCOOP, accessorURL, accessedURL, accessedInitialURL, accessorOrigin, accessedOrigin, accessedCreatorOrigin, propertyName, and environment.
</li>
			<li>
`~openerからの~access用に違反~報告を~queueする$( ↓ )
⇒＃
%~accessedの~COOP,
%~accessedの~URL,
%~accessorの~URL,
%~accessedの生成元,
%~accessorの生成元,
%~prop名,
%~accessedの~referrer
◎
Queue a violation report for access from the opener, given accessedCOOP, accessedURL, accessorURL, accessedOrigin, accessorOrigin, propertyName, and accessedReferrer.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%~accessorと~accessedの関係性 ~EQ `~accessorは~openee$i
］：
◎
Otherwise, if accessorAccessedRelationship is accessor is openee:
</p>
		<ol>
			<li>
`~openerへの~access用に違反~報告を~queueする$( ↓ )
⇒＃
%~accessorの~COOP,
%~accessorの~URL,
%~accessedの~URL,
%~accessorの生成元,
%~accessedの生成元,
%~prop名,
%~accessorの~referrer,
%環境
◎
Queue a violation report for access to the opener, given accessorCOOP, accessorURL, accessedURL, accessorOrigin, accessedOrigin, propertyName, accessorReferrer, and environment.
</li>
			<li>
`~openした~windowからの~access用に違反~報告を~queueする$( ↓ )
⇒＃
%~accessedの~COOP,
%~accessedの~URL,
%~accessorの~URL,
%~accessorの初期~URL,
%~accessedの生成元,
%~accessorの生成元,
%~accessorの作成元の生成元,
%~prop名
◎
Queue a violation report for access from an opened window, given accessedCOOP, accessedURL, accessorURL, accessorInitialURL, accessedOrigin, accessorOrigin, accessorCreatorOrigin, and propertyName.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
`~openした~windowへの~access用に違反~報告を~queueする$( ↓ )
⇒＃
%~accessorの~COOP,
%~accessorの~URL,
%~accessedの~URL,
%~accessorの生成元,
%~accessedの生成元,
%~prop名,
%環境
◎
Queue a violation report for access to another window, given accessorCOOP, accessorURL, accessedURL, accessorOrigin, accessedOrigin, propertyName, and environment.
</li>
			<li>
`別の~windowからの~access用に違反~報告を~queueする$( ↓ )
⇒＃
%~accessedの~COOP,
%~accessedの~URL,
%~accessorの~URL,
%~accessedの生成元,
%~accessorの生成元,
%~prop名
◎
Queue a violation report for access from another window, given accessedCOOP, accessedURL, accessorURL, accessedOrigin, accessorOrigin, and propertyName.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~openerへの~access用に違反~報告を~queueする@
~algoは、
所与の
⇒＃
`~opener施策$ %~COOP,
`~URL$ %~COOP~URL,
`~URL$ %~openerの~URL,
`生成元$ %~COOP生成元,
`生成元$ %~openerの生成元,
文字列 %~prop名,
`~referrer$rq %~referrer,
`環境~設定群~obj$ %環境
◎終
に対し：
◎
To queue a violation report for access to the opener, given an opener policy coop, two URLs coopURL and openerURL, two origins coopOrigin and openerOrigin, a string propertyName, a referrer referrer, and an environment settings object environment:
</p>
<ol>
	<li>
( %~source~file, ( %行番号, %列番号 ) )
~LET この報告を誘発した関連な~scriptの ( ~URL, 問題になり得る位置 )
◎
Let sourceFile, lineNumber, and columnNumber be the relevant script URL and problematic position which triggered this report.
</li>
	<li>
%直列化した~referrer ~LET %~referrer に応じて
⇒＃
`~URL$であるならば `~URLを直列化する$( %~referrer ) ／
~ELSE_ %~referrer
◎
Let serializedReferrer be an empty string.
◎
If referrer is a URL, set serializedReferrer to the serialization of referrer.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
<tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`property^c
<td>%~prop名

<tr><td>`openerURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openerの生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %~openerの~URL )

<tr><td>`referrer^c
<td>%直列化した~referrer

<tr><td>`sourceFile^c
<td>%~source~file

<tr><td>`lineNumber^c
<td>%行番号

<tr><td>`columnNumber^c
<td>%列番号

<tr><td>`type^c
<td>`access-to-opener^l
</table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coop's report-only value
• property｜propertyName
• openerURL｜If coopOrigin and openerOrigin are same origin, this is the sanitization of openerURL, null otherwise.
• referrer｜serializedReferrer
• sourceFile｜sourceFile
• lineNumber｜lineNumber
• columnNumber｜columnNumber
• type｜"access-to-opener"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, %環境, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL and environment.
</li>
</ol>
</div>

<div class="algo">
<p>
`~openした~windowへの~access用に違反~報告を~queueする@
~algoは、
所与の
⇒＃
`~opener施策$ %~COOP,
`~URL$ %~COOP~URL,
`~URL$ %~openした~windowの~URL,
`~URL$ %初期~window~URL,
`生成元$ %~COOP生成元,
`生成元$ %~openした~windowの生成元,
`生成元$ %~openerの初期~生成元,
文字列 %~prop名,
`環境~設定群~obj$ %環境
◎終
に対し：
◎
To queue a violation report for access to an opened window, given an opener policy coop, three URLs coopURL, openedWindowURL and initialWindowURL, three origins coopOrigin, openedWindowOrigin, and openerInitialOrigin, a string propertyName, and an environment settings object environment:
</p>
<ol>
	<li>
( %~source~file, ( %行番号, %列番号 ) )
~LET この報告を誘発した関連な~scriptの ( ~URL, 問題になり得る位置 )
◎
Let sourceFile, lineNumber, and columnNumber be the relevant script URL and problematic position which triggered this report.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
<tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`property^c
<td>%~prop名

<tr><td>`openedWindowURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openした~windowの生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %~openした~windowの~URL )

<tr><td>`openedWindowInitialURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openerの初期~生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %初期~window~URL ).

<tr><td>`sourceFile^c
<td>%~source~file

<tr><td>`lineNumber^c
<td>%行番号

<tr><td>`columnNumber^c
<td>%列番号

<tr><td>`type^c
<td>`access-to-opener^l
</table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coop's report-only value
• property｜propertyName
• openedWindowURL｜If coopOrigin and openedWindowOrigin are same origin, this is the sanitization of openedWindowURL, null otherwise.
• openedWindowInitialURL｜If coopOrigin and openerInitialOrigin are same origin, this is the sanitization of initialWindowURL, null otherwise.
• sourceFile｜sourceFile
• lineNumber｜lineNumber
• columnNumber｜columnNumber
• type｜"access-to-opener"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, %環境, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL and environment.
</li>
</ol>
</div>

<div class="algo">
<p>
`別の~windowへの~access用に違反~報告を~queueする@
~algoは、
所与の
⇒＃
`~opener施策$ %~COOP,
`~URL$ %~COOP~URL,
`~URL$ %他の~URL,
`生成元$ %~COOP生成元
`生成元$ %他の生成元,
文字列 %~prop名,
`環境~設定群~obj$ %環境
◎終
に対し：
◎
To queue a violation report for access to another window, given an opener policy coop, two URLs coopURL and otherURL, two origins coopOrigin and otherOrigin, a string propertyName, and an environment settings object environment:
</p>
<ol>
	<li>
( %~source~file, ( %行番号, %列番号 ) )
~LET この報告を誘発した関連な~scriptの ( ~URL, 問題になり得る位置 )
◎
Let sourceFile, lineNumber, and columnNumber be the relevant script URL and problematic position which triggered this report.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
<tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`property^c
<td>%~prop名

<tr><td>`otherURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %他の生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %他の~URL )

<tr><td>`sourceFile^c
<td>%~source~file

<tr><td>`lineNumber^c
<td>%行番号

<tr><td>`columnNumber^c
<td>%列番号

<tr><td>`type^c
<td>`access-to-opener^l
</table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coop's report-only value
• property｜propertyName
• otherURL｜If coopOrigin and otherOrigin are same origin, this is the sanitization of otherURL, null otherwise.
• sourceFile｜sourceFile
• lineNumber｜lineNumber
• columnNumber｜columnNumber
• type｜"access-to-opener"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, %環境, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL and environment.
</li>
</ol>
</div>

<div class="algo">
<p>
`~openerからの~access用に違反~報告を~queueする@
~algoは、
所与の
⇒＃
`~opener施策$ %~COOP,
`~URL$ %~COOP~URL,
`~URL$ %~openerの~URL,
`生成元$ %~COOP生成元,
`生成元$ %~openerの生成元,
文字列 %~prop名,
`~referrer$rq %~referrer
◎終
に対し：
◎
To queue a violation report for access from the opener, given an opener policy coop, two URLs coopURL and openerURL, two origins coopOrigin and openerOrigin, a string propertyName, and a referrer referrer:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
%直列化した~referrer ~LET %~referrer に応じて
⇒＃
`~URL$であるならば `~URLを直列化する$( %~referrer ) ／
~ELSE_ %~referrer
◎
Let serializedReferrer be an empty string.
◎
If referrer is a URL, set serializedReferrer to the serialization of referrer.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
<tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`property^c
<td>%~prop名

<tr><td>`openerURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openerの生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %~openerの~URL )

<tr><td>`referrer^c
<td>%直列化した~referrer

<tr><td>`type^c
<td>`access-to-opener^l
</table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coop's report-only value
• property｜propertyName
• openerURL｜If coopOrigin and openerOrigin are same origin, this is the sanitization of openerURL, null otherwise.
• referrer｜serializedReferrer
• type｜"access-to-opener"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, ε, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`~openした~windowからの~access用に違反~報告を~queueする@
~algoは、
所与の
⇒＃
`~opener施策$%~COOP,
`~URL$ %~COOP~URL,
`~URL$ %~openした~windowの~URL,
`~URL$ %初期~window~URL,
`生成元$ %~COOP生成元,
`生成元$ %~openした~windowの生成元,
`生成元$ %~openerの初期~生成元,
文字列 %~prop名
◎終
に対し：
◎
To queue a violation report for access from an opened window, given an opener policy coop, three URLs coopURL, openedWindowURL and initialWindowURL, three origins coopOrigin, openedWindowOrigin, and openerInitialOrigin, and a string propertyName:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
<tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP値

<tr><td>`property^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`openedWindowURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openした~windowの生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %~openした~windowの~URL )

<tr><td>`openedWindowInitialURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openerの初期~生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %初期~window~URL )

<tr><td>`type^c
<td>`access-to-opener^l
</table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coopValue
• property｜coop's report-only value
• openedWindowURL｜If coopOrigin and openedWindowOrigin are same origin, this is the sanitization of openedWindowURL, null otherwise.
• openedWindowInitialURL｜If coopOrigin and openerInitialOrigin are same origin, this is the sanitization of initialWindowURL, null otherwise.
• type｜"access-to-opener"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, ε, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`別の~windowからの~access用に違反~報告を~queueする@
~algoは、
所与の
⇒＃
`~opener施策$ %~COOP,
`~URL$ %~COOP~URL,
`~URL$ %他の~URL,
`生成元$ %~COOP生成元,
`生成元$ %他の生成元,
文字列 %~prop名
◎終
に対し：
◎
To queue a violation report for access from another window, given an opener policy coop, two URLs coopURL and otherURL, two origins coopOrigin and otherOrigin, and a string propertyName:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
<tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`property^c
<td>%~prop名

<tr><td>`otherURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %他の生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %他の~URL )

<tr><td>`type^c
<td>`access-to-opener^c
</table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coop's report-only value
• property｜propertyName
• otherURL｜If coopOrigin and otherOrigin are same origin, this is the sanitization of otherURL, null otherwise.
• type｜access-to-opener
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, ε, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="coep">
<h4 title="Cross-origin embedder policies">7.1.4. 非同一-生成元~埋込元~施策</h4>

<p>
`埋込元~施策~値@
は、
資源~所有者からの明示的な許可を伴わずに，
非同一-生成元~資源の~fetchingを制御する
— それは、
次に挙げるいずれかの文字列をとる：
◎
An embedder policy value is one of three strings that controls the fetching of cross-origin resources without explicit permission from resource owners.
</p>

<dl class="def-list">
	<dt>`unsafe-none@coep</dt>
	<dd>
<p>
これが既定の値。
この値が利用されたときは、
非同一-生成元~資源を~fetchするときに，
“明示的な許可” は要求されない。
</p>

<p>
この項, および以下の各項における “明示的な許可” とは、［
`~CORS~protocol$ ／
`Cross-Origin-Resource-Policy$h ~header
］を通した［
~serverによる明示的な許可
］を意味する。
</p>
◎
This is the default value. When this value is used, cross-origin resources can be fetched without giving explicit permission through the CORS protocol or the `Cross-Origin-Resource-Policy` header.
</dd>

	<dt>`require-corp@coep</dt>
	<dd>
この値が利用されたときは、
非同一-生成元~資源を~fetchするときに，
“明示的な許可” が要求される。
◎
When this value is used, fetching cross-origin resources requires the server's explicit permission through the CORS protocol or the `Cross-Origin-Resource-Policy` header.
</dd>

	<dt>`credentialless@coep</dt>
	<dd>
この値が利用されたときは、
~CORSなしで非同一-生成元~資源を~fetchするときに，
資格証を省略する。
その引き換えに、
明示的な `Cross-Origin-Resource-Policy$h ~headerは要求されなくなる。
［
資格証を伴って送信される，他の要請
］には、
“明示的な許可” が要求される。
◎
When this value is used, fetching cross-origin no-CORS resources omits credentials. In exchange, an explicit `Cross-Origin-Resource-Policy` header is not required. Other requests sent with credentials require the server's explicit permission through the CORS protocol or the `Cross-Origin-Resource-Policy` header.
</dd>
</dl>

<div class="warning">
<p>
実装者には、［
`credentialless$coep を~supportする前に，次の両者を~supportする
］ことが強く奨励される
⇒＃
`私的な~network~access＠https://wicg.github.io/private-network-access/$,
`不透明な応答の阻止-法＠https://github.com/annevk/orb$
◎
Before supporting "credentialless", implementers are strongly encouraged to support both:
• Private Network Access
• Opaque Response Blocking
</p>

<p>
さもなければ、
次を攻撃者に許容することになろう
⇒
~clientの~network位置を活用して，公でない資源を
— `非同一-生成元~能力は隔離されるか？$enVを利用して —
読取る
◎
Otherwise, it would allow attackers to leverage the client's network position to read non public resources, using the cross-origin isolated capability.
</p>
</div>

<p>
次を満たす`埋込元~施策~値$ %値 は、
`非同一-生成元~隔離と互換@
であるとされる
⇒
%値 ~IN { `credentialless$coep, `require-corp$coep }
◎
An embedder policy value is compatible with cross-origin isolation if it is "credentialless" or "require-corp".
</p>

<p>
`埋込元~施策@
【略称 “COEP” 】は、
次に挙げるものからなる：
◎
An embedder policy consists of:
</p>
<ul>
	<li>
`値@embP
⇒
`埋込元~施策~値$
— 初期~時は `unsafe-none$coep とする。
◎
A value, which is an embedder policy value, initially "unsafe-none".
</li>
	<li>
`報告先@embP
⇒
文字列
— 初期~時は空~文字列とする。
◎
A reporting endpoint string, initially the empty string.
</li>
	<li>
`報告のみの値@embP
⇒
`埋込元~施策~値$
— 初期~時は `unsafe-none$coep とする。
◎
A report only value, which is an embedder policy value, initially "unsafe-none".
</li>
	<li>
`報告のみの報告先@embP
⇒
文字列
— 初期~時は空~文字列とする。
◎
A report only reporting endpoint string, initially the empty string.
</li>
</ul>

<p>
`~COEP報告~種別@i
は、
`coep^l を値にとる`報告~種別$であり，`報告用~観測器から可視$であるとする。
◎
The "coep" report type is a report type whose value is "coep". It is visible to ReportingObservers.
</p>

				<section id="the-coep-headers">
<h5 title="The headers">7.1.4.1. 各種~header</h5>

<p>
［
`Cross-Origin-Embedder-Policy@h ／
`Cross-Origin-Embedder-Policy-Report-Only@h
］~HTTP応答~headerは、［
`環境~設定群~obj$用に`埋込元~施策$を宣言すること
］を~serverに許容する。
両~headerとも`有構造~header$であり、
その値は`~sf~token$でなければナラナイ。
`STRUCTURED-FIELDS$r
◎
The `Cross-Origin-Embedder-Policy` and `Cross-Origin-Embedder-Policy-Report-Only` HTTP response headers allow a server to declare an embedder policy for an environment settings object. These headers are structured headers whose values must be token. [STRUCTURED-FIELDS]
</p>

<p>
`埋込元~施策~値$が，`~sf~token$として妥当になる。
各~tokenは`~sf~parameter群$も伴い得る
— それを成す
`report-to@coep
~parameterは、
適切な`報告先$を識別する`妥当な~URL文字列$をとり得る。
`REPORTING$r
◎
The valid token values are the embedder policy values. The token may also have attached parameters; of these, the "report-to" parameter can have a valid URL string identifying an appropriate reporting endpoint. [REPORTING]
</p>

<div class="note">
<p>注記：
値を`~sf~token$として構文解析し得ない~headerが在る下では、
処理~model（`埋込元~施策を得する$）は，
（既定の `unsafe-none$coep になることにより）
~openに失敗する【何の？】。
所与の応答~内に複数の `Cross-Origin-Embedder-Policy$h ~headerが在って、
不作為に結合され，~listが作成された場合も同様になる：
◎
The processing model fails open (by defaulting to "unsafe-none") in the presence of a header that cannot be parsed as a token. This includes inadvertent lists created by combining multiple instances of the `Cross-Origin-Embedder-Policy` header present in a given response:
</p>

<div>
<table><thead>
<tr><th>`Cross-Origin-Embedder-Policy$h`
<th>最終的な`埋込元~施策~値$
<tbody>

<tr><td>`送達された~headerなし^em
<td>`unsafe-none$coep

<tr><td>`require-corp^bl
<td>`require-corp$coep

<tr><td>`unknown-value^bl
<td>`unsafe-none$coep

<tr><td>`require-corp, unknown-value^bl
<td>`unsafe-none$coep

<tr><td>`unknown-value, unknown-value^bl
<td>`unsafe-none$coep

<tr><td>`unknown-value, require-corp^bl
<td>`unsafe-none$coep

<tr><td>`require-corp, require-corp^bl
<td>`unsafe-none$coep
</table>

◎
• `Cross-Origin-Embedder-Policy`｜Final embedder policy value
• No header delivered｜"unsafe-none"
• `require-corp`｜"require-corp"
• `unknown-value`｜"unsafe-none"
• `require-corp, unknown-value`｜"unsafe-none"
• `unknown-value, unknown-value`｜"unsafe-none"
• `unknown-value, require-corp`｜"unsafe-none"
• `require-corp, require-corp`｜"unsafe-none"
</div>

<p>
（同じことは，
`Cross-Origin-Embedder-Policy-Report-Only$h にも適用される。）
◎
(The same applies to `Cross-Origin-Embedder-Policy-Report-Only`.)
</p>
</div>

<hr>

<div class="algo">
<p>
`埋込元~施策を得する@
~algoは、
所与の
( `応答$ %応答, `環境$ %環境 )
に対し：
◎
To obtain an embedder policy from a response response and an environment environment:
</p>
<ol>
	<li>
%施策 ~LET 新たな`埋込元~施策$
◎
Let policy be a new embedder policy.
</li>
	<li>
~IF［
%環境 は`~secureな文脈$enVでない
］
⇒
~RET %施策
◎
If environment is a non-secure context, then return policy.
</li>
	<li>
%構文解析した~item ~LET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Cross-Origin-Embedder-Policy$h, `~item^i )
◎
Let parsedItem be the result of getting a structured field value with `Cross-Origin-Embedder-Policy` and "item" from response's header list.
</li>
	<li>
<p>
~IF［
%構文解析した~item ~NEQ ~NULL
］：
</p>
		<ol>
			<li>
%値 ~LET %構文解析した~item の`値$sfI【！%構文解析した~item[ 0 ]】
</li>
			<li>
<p>
~IF［
%値 は`~sf~token$である【この条件は、この訳による補完】
］~AND［
%値 は`非同一-生成元~隔離と互換$である
］：
</p>
				<ol>
					<li>
%施策 の`値$embP ~SET %値
</li>
					<li>
%報告先 ~LET %構文解析した~item の`~parameter群$sfI[ `report-to$coep ]
</li>
					<li>
~IF［
%報告先 ~NEQ ε
］
⇒
%施策 の`報告先$embP ~SET %報告先
</li>
				</ol>
			</li>
		</ol>
◎
If parsedItem is non-null and parsedItem[0] is compatible with cross-origin isolation:
• Set policy's value to parsedItem[0].
• If parsedItem[1]["report-to"] exists, then set policy's endpoint to parsedItem[1]["report-to"].
</li>
	<li>
%構文解析した~item ~SET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Cross-Origin-Embedder-Policy-Report-Only$h, `~item^i )
◎
Set parsedItem to the result of getting a structured field value with `Cross-Origin-Embedder-Policy-Report-Only` and "item" from response's header list.
</li>
	<li>
<p>
~IF［
%構文解析した~item ~NEQ ~NULL
］：
</p>
		<ol>
			<li>
%値 ~LET %構文解析した~item の`値$sfI【！%構文解析した~item[ 0 ]】
</li>
			<li>
<p>
~IF［
%値 は`~sf~token$である【この条件は、この訳による補完】
］~AND［
%値 は`非同一-生成元~隔離と互換$である
］：
</p>
				<ol>
					<li>
%施策 の`報告のみの値$embP ~SET %値
</li>
					<li>
%報告先 ~LET %構文解析した~item の`~parameter群$sfI[ `report-to$coep ]
</li>
					<li>
~IF［
%報告先 ~NEQ ε
］
⇒
%施策 の`報告のみの報告先$embP ~SET %報告先
</li>
				</ol>
			</li>
		</ol>
◎
If parsedItem is non-null and parsedItem[0] is compatible with cross-origin isolation:
• Set policy's report only value to parsedItem[0].
• If parsedItem[1]["report-to"] exists, then set policy's endpoint to parsedItem[1]["report-to"].
</li>
	<li>
~RET %施策
◎
Return policy.
</li>
</ol>
</div>

				</section>
				<section id="embedder-policy-checks">
<h5 title="Embedder policy checks">7.1.4.2. 埋込元~施策の検査</h5>

<div class="algo">
<p>
`~navi応答の埋込元~施策に対する固守を検査する@
~algoは、
所与の
( `応答$ %応答, `~navigable$ %~navigable, `埋込元~施策$ %応答~施策 )
に対し：
◎
To check a navigation response's adherence to its embedder policy given a response response, a navigable navigable, and an embedder policy responsePolicy:
</p>
<ol>
	<li>
~IF［
%~navigable は`子~navigable$でない
］
⇒
~RET ~T
◎
If navigable is not a child navigable, then return true.
</li>
	<li>
%親~施策 ~LET %~navigable の`容器~文書$navの`施策~容器$docの`埋込元~施策$pC
◎
Let parentPolicy be navigable's container document's policy container's embedder policy.
</li>
	<li>
~IF［
%親~施策 の`報告のみの値$embPは`非同一-生成元~隔離と互換$である
］~AND［
%応答~施策 の`値$embPは`非同一-生成元~隔離と互換$でない
］
⇒
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `navigation^l, %親~施策 の`報告のみの報告先$embP, `reporting^l, %~navigable の`容器~文書$navに`関連な設定群~obj$ )
◎
If parentPolicy's report-only value is compatible with cross-origin isolation and responsePolicy's value is not, then queue a cross-origin embedder policy inheritance violation with response, "navigation", parentPolicy's report only reporting endpoint, "reporting", and navigable's container document's relevant settings object.
</li>
	<li>
~IF［
%親~施策 の`値$embPは`非同一-生成元~隔離と互換$でない
］~OR［
%応答~施策 の`値$embPは`非同一-生成元~隔離と互換$である
］
⇒
~RET ~T
◎
If parentPolicy's value is not compatible with cross-origin isolation or responsePolicy's value is compatible with cross-origin isolation, then return true.
</li>
	<li>
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `navigation^l, %親~施策 の`報告先$embP, `enforce^l, %~navigable の`容器~文書$navに`関連な設定群~obj$ )
◎
Queue a cross-origin embedder policy inheritance violation with response, "navigation", parentPolicy's reporting endpoint, "enforce", and navigable's container document's relevant settings object.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`大域~objの埋込元~施策を検査する@
~algoは、
所与の
( `WorkerGlobalScope$I %~worker大域~scope, `環境~設定群~obj$ %所有者, `応答$ %応答 )
に対し：
◎
To check a global object's embedder policy given a WorkerGlobalScope workerGlobalScope, an environment settings object owner, and a response response:
</p>
<ol>
	<li>
~IF［
%~worker大域~scope は `DedicatedWorkerGlobalScope$I ~objでない
］
⇒
~RET ~T
◎
If workerGlobalScope is not a DedicatedWorkerGlobalScope object, then return true.
</li>
	<li>
%施策 ~LET %~worker大域~scope の`埋込元~施策$wG
◎
Let policy be workerGlobalScope's embedder policy.
</li>
	<li>
%所有者~施策 ~LET %所有者 の`施策~容器$enVの`埋込元~施策$pC
◎
Let ownerPolicy be owner's policy container's embedder policy.
</li>
	<li>
~IF［
%所有者~施策 の`報告のみの値$embPは`非同一-生成元~隔離と互換$である
］~AND［
%施策 の`値$embPは`非同一-生成元~隔離と互換$でない
］
⇒
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `worker initialization^l, %所有者の施策 の`報告のみの報告先$embP, `reporting^l, %所有者 )
◎
If ownerPolicy's report-only value is compatible with cross-origin isolation and policy's value is not, then queue a cross-origin embedder policy inheritance violation with response, "worker initialization", ownerPolicy's report only reporting endpoint, "reporting", and owner.
</li>
	<li>
~IF［
%所有者~施策 の`値$embPは`非同一-生成元~隔離と互換$でない
］~OR［
%施策 の`値$embPは`非同一-生成元~隔離と互換$である
］
⇒
~RET ~T
◎
If ownerPolicy's value is not compatible with cross-origin isolation or policy's value is compatible with cross-origin isolation, then return true.
</li>
	<li>
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `worker initialization^l, %所有者の施策 の`報告先$embP, `enforce^l, %所有者 )
◎
Queue a cross-origin embedder policy inheritance violation with response, "worker initialization", ownerPolicy's reporting endpoint, "enforce", and owner.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`非同一-生成元~埋込元~施策の継承~違反を~queueする@
~algoは、
所与の
( `応答$ %応答, 文字列 %種別, 文字列 %報告先, 文字列 %処置, `環境~設定群~obj$ %設定群 )
に対し：
◎
To queue a cross-origin embedder policy inheritance violation given a response response, a string type, a string endpoint, a string disposition, and an environment settings object settings:
</p>
<ol>
	<li>
%直列化した~URL ~LET `応答~URLを報告-用に直列化する$( %応答 )
◎
Let serialized be the result of serializing a response URL for reporting with response.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含する新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
<tbody>

<tr><td>`type^c
<td>%種別

<tr><td>`blockedURL^c
<td>%直列化した~URL

<tr><td>`disposition^c
<td>%処置
</table>

◎
Let body be a new object containing the following properties:
◎
key	value
type	type
blockedURL	serialized
disposition	disposition
</li>
	<li>
`報告を~queueする$( %本体, `~COEP報告~種別$i, %報告先, %設定群 )
◎
Queue body as the "coep" report type for endpoint on settings.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="sandboxing">
<h4 title="Sandboxing">7.1.5. ~sandbox法</h4>

<p>
`~sandbox法~flag集合@
は、
以下に挙げる各種~flagのうち，いくつかからなる集合である。
この集合は、
それが含む各種~flagを通して，
信用できない資源が持ち得る能を制約するために利用される：
◎
A sandboxing flag set is a set of zero or more of the following flags, which are used to restrict the abilities that potentially untrusted resources have:
</p>

【！ flag ~IN ~sandbox法~flag集合 ↔ flag ~EQ ~T】

<p class="trans-note">【
“`~sandbox＠https://en.wikipedia.org/wiki/Sandbox_(computer_security)$”
—  “（こどもの）砂場” （ “監獄” を和らげた語（一般に，より制約も緩い））。
】【
以下に現れる各種
“`X^sbox”
は、
“X について，閲覧~文脈を~sandbox化する
（当の閲覧~文脈において X の機能を抑止する）
ことを指示するもの”
を意味する
— そのように解釈し易いよう、
この訳では，関数的に記している。
】【
以下に現れる “内容” とは、［
これらの~flagが適用される閲覧~文脈
］内の内容を指す。
】</p>

<dl>
	<dt>
`~navi@sbox
◎
The sandboxed navigation browsing context flag
</dt>
	<dd>
<p>
この~flagは、
~sandbox化された当の閲覧~文脈を %B とするとき，
次に挙げるもの以外の`閲覧~文脈$ %C に対しては，
%B の内容が %C を`~navigateするのを防止する＠~HTMLnav#sandboxLinks$：
</p>
		<ul>
			<li>
%B 自身
</li>
			<li>
%B が内側に更に入子にしている閲覧~文脈
</li>
			<li>
%B が開いた`補助~閲覧~文脈$
（これは、`補助~navi$sboxにより保護される）†
</li>
			<li>
%B の`~top-level閲覧~文脈$
（これは、
`利用者-作動化を伴う~top-level~navi$sbox,
`利用者-作動化を伴わない~top-level~navi$sbox
により保護される）
</li>
		</ul>
◎
This flag prevents content from navigating browsing contexts other than the sandboxed browsing context itself (or browsing contexts further nested inside it), auxiliary browsing contexts (which are protected by the sandboxed auxiliary navigation browsing context flag defined next), and the top-level browsing context (which is protected by the sandboxed top-level navigation without user activation browsing context flag and sandboxed top-level navigation with user activation browsing context flag defined below).
</dd>
	<dd>†
この制約にもかかわらず，［
`補助~navi$sbox ~NIN `~sandbox法~flag集合$
］の下では、
ある種の事例では，新たな`~top-level閲覧~文脈$として
%~popup 【すなわち、`補助~閲覧~文脈$】を開くことが許容される。
そのような %~popup の作成-時には、
それを作成した`閲覧~文脈$が，
%~popup の
`許可-済み~navigator@††
として設定される
— それは、
（ ~naviに関して~sandbox化されていても）実際には %~popup を~navigateすることが許可される。
（他の場合、
%~popup に対する~naviは，`~navi$sboxにより防止される。）
◎
If the sandboxed auxiliary navigation browsing context flag is not set, then in certain cases the restrictions nonetheless allow popups (new top-level browsing contexts) to be opened. These browsing contexts always have one permitted sandboxed navigator, set when the browsing context is created, which allows the browsing context that created them to actually navigate them. (Otherwise, the sandboxed navigation browsing context flag would prevent them from being navigated even if they were opened.)
</dd>
	<dd class="trans-note">【††
“`one permitted sandboxed navigator^en”
— この “`one^en” は、［
%~popup に対し`許可-済み~navigator$とされるものは、
1 個だけあること
］を表していると見受けられる。
】</dd>

	<dt>
`補助~navi@sbox
◎
The sandboxed auxiliary navigation browsing context flag
</dt>
	<dd>
この~flagは、
内容が`新たな補助~閲覧~文脈を作成することを防止する＠~HTMLds#sandboxWindowOpen$
— 例えば［
`target$a 属性 ／
`window.open()＠~WINDOW#dom-window-open$c ~method
］を利用して。
◎
This flag prevents content from creating new auxiliary browsing contexts, e.g. using the target attribute or the window.open() method.
</dd>

	<dt>`利用者-作動化を伴わない~top-level~navi@sbox</dt>
	<dt>`利用者-作動化を伴う~top-level~navi@sbox</dt>
	<dd>
両~flagとも、
内容が その`~top-level閲覧~文脈$を［
`~navigateするのを防止する＠~HTMLnav#sandboxLinks$ ／
`閉じるのを防止する＠~WINDOW#sandboxClose$
］。
これらは順に、
~sandbox化された閲覧~文脈にて`作動中な~window$bcは`一過な作動化を有して$［
いないとき, いるとき
］に限り，諮られる。
◎
The sandboxed top-level navigation without user activation browsing context flag
◎
This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level browsing context. It is consulted only when the sandboxed browsing context's active window does not have transient activation.
</dd>
	<dd>
両~flagとも、
影響するのは`~top-level閲覧~文脈$に限られる
— ［
この~flag（`一過な作動化を有して$いるか否かに応じて適切な方） ~NIN `~sandbox法~flag集合$
］の下では、
内容は，その`~top-level閲覧~文脈$を~navigateできる。
が、
他の`閲覧~文脈$は，依然として他の~flag
— `~navi$sboxや, （場合によっては）`補助~navi$sbox —
により保護される。
◎
When the sandboxed top-level navigation without user activation browsing context flag is not set, content can navigate its top-level browsing context, but other browsing contexts are still protected by the sandboxed navigation browsing context flag and possibly the sandboxed auxiliary navigation browsing context flag.
◎
The sandboxed top-level navigation with user activation browsing context flag
◎
This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level browsing context. It is consulted only when the sandboxed browsing context's active window has transient activation.
◎
As with the sandboxed top-level navigation without user activation browsing context flag, this flag only affects the top-level browsing context; if it is not set, other browsing contexts might still be protected by other flags.
</dd>

	<dt>
`生成元@sbox
◎
The sandboxed origin browsing context flag
</dt>
	<dd>
この~flagは、
`内容を不透明な生成元に属するよう強制する＠~HTMLds#sandboxOrigin$
— したがって，内容が［
同じ`生成元$からの他の内容
］に~accessすることを防止する。
◎
This flag forces content into an opaque origin, thus preventing it from accessing other content from the same origin.
</dd>
	<dd>
この~flagはまた、
~scriptが `document.cookie^m ~IDL属性を`読取る／書込むことを防止する＠~HTMLdom#sandboxCookies$ことに加え，
`localStorage＠~WEBSTORAGE#dom-localstorage$m への~accessも阻止する。
◎
This flag also prevents script from reading from or writing to the document.cookie IDL attribute, and blocks access to localStorage.
</dd>

	<dt>
`~form@sbox
◎
The sandboxed forms browsing context flag
</dt>
	<dd>
この~flagは、
`~form提出を阻止する＠~HTMLforms#sandboxSubmitBlocked$。
◎
This flag blocks form submission.
</dd>

	<dt>
`~pointer~lock@sbox
◎
The sandboxed pointer lock browsing context flag
</dt>
	<dd>
この~flagは、
Pointer Lock ~APIを不能化する。
`POINTERLOCK$r
◎
This flag disables the Pointer Lock API. [POINTERLOCK]
</dd>

	<dt>
`~script@sbox
◎
The sandboxed scripts browsing context flag
</dt>
	<dd>
この~flagは、
`~script実行を阻止する＠~WAPI#sandboxScriptBlocked$。
◎
This flag blocks script execution.
</dd>

	<dt>
`自動的な特能@sbox
◎
The sandboxed automatic features browsing context flag
</dt>
	<dd>
この~flagは、
次に挙げるような自動的に誘発される特能を阻止する
⇒＃
`動画を自動的に再生する＠~HEmedia#attr-media-autoplay$／
`~form~controlを自動的に~focusする＠~HTMLinteraction#attr-fe-autofocus$
◎
This flag blocks features that trigger automatically, such as automatically playing a video or automatically focusing a form control.
</dd>

	<dt>
`~document-domain@sbox
◎
The sandboxed document.domain browsing context flag
</dt>
	<dd>
この~flagは、
`document.domain$c 設定子の利用を防止する。
◎
This flag prevents content from using the document.domain setter.
</dd>

	<dt>
`~sandboxは補助~閲覧~文脈に伝播する~flag@
◎
The sandbox propagates to auxiliary browsing contexts flag
</dt>
	<dd>
この~flagは、［
内容にて`作動中な~sandbox法~flag集合$
］を［
内容が作成する`補助~閲覧~文脈$
］に継承させることにより，内容が ~sandboxから逃れるのを防止する。
◎
This flag prevents content from escaping the sandbox by ensuring that any auxiliary browsing context it creates inherits the content's active sandboxing flag set.
</dd>

	<dt>
`~sandbox化( ~modal )~flag@
◎
The sandboxed modals flag
</dt>
	<dd>
この~flagは、［
内容が，次のいずれかの特能を利用して~modal~dialogを生産する
］のを防止する
⇒＃
`window.alert()＠~HTMLGAPI#dom-window-alert$c ／
`window.confirm()＠~HTMLGAPI#dom-window-confirm$c ／
`window.print()＠~HTMLGAPI#dom-window-print$c ／
`window.prompt()＠~HTMLGAPI#dom-window-prompt$c ／
`beforeunload$et ~event
◎
This flag prevents content from using any of the following features to produce modal dialogs:
• window.alert()
• window.confirm()
• window.print()
• window.prompt()
• the beforeunload event
</dd>

	<dt>
`方位~lock@sbox
◎
The sandboxed orientation lock browsing context flag
</dt>
	<dd>
この~flagは、
~screen方位を~lockする能を不能化する。
`SCREENORIENTATION$r
◎
This flag disables the ability to lock the screen orientation. [SCREENORIENTATION]
</dd>
	<dt>
`呈示@sbox
◎
The sandboxed presentation browsing context flag
</dt>
	<dd>
この~flagは、
`Presentation API^cite を不能化する。
`PRESENTATION$r
◎
This flag disables the Presentation API. [PRESENTATION]
</dd>

	<dt>
`~download@sbox
◎
The sandboxed downloads browsing context flag
</dt>
	<dd>
この~flagは、［
内容が，次のいずれかを通して~downloadを起動したり~instance化する
］ことを防止する
⇒＃
`~hyperlinkを~downloadする$／
`~navi＠~HTMLnav#navigation-as-a-download$を通して`~downloadとして取扱われる＠~HTMLlinks#handle-as-a-download$もの
◎
This flag prevents content from initiating or instantiating downloads, whether through downloading hyperlinks or through navigation that gets handled as a download.
</dd>

	<dt>
`~custom~protocol~navi@sbox
◎
The sandboxed custom protocols navigation browsing context flag
</dt>
	<dd>
この~flagは、
非`~fetch~scheme$へ向かう~naviを`外部~softwareに手渡す$ことを防止する。
◎
This flag prevents navigations toward non fetch schemes from being handed off to external software.
</dd>
</dl>

<div class="algo">
<p>
`~sandbox法~指令を構文解析する@
~algoは、
所与の
( 文字列 %入力, `~sandbox法~flag集合$ %出力 )
に対し：
◎
When the user agent is to parse a sandboxing directive, given a string input and a sandboxing flag set output, it must run the following steps:
</p>
<ol>
	<li>
%~token群 ~LET `~ASCII空白で分割する$( %入力 )
◎
Split input on ASCII whitespace, to obtain tokens.
</li>
	<li>
%出力 を空にする
◎
Let output be empty.
</li>
	<li>

<p>
以下に挙げる各種~flagを，対応する記述の条件が満たされるならば
%出力 に追加する：
◎
Add the following flags to output:
</p>
		<ul>
			<li>
`~navi$sbox
⇒
~~無条件
◎
The sandboxed navigation browsing context flag.
</li>
			<li>
`補助~navi$sbox
⇒
`allow-popups@v ~NIN %~token群
◎
The sandboxed auxiliary navigation browsing context flag, unless tokens contains the allow-popups keyword.
</li>
			<li>
`利用者-作動化を伴わない~top-level~navi$sbox
⇒
`allow-top-navigation@v
~NIN %~token群
◎
The sandboxed top-level navigation without user activation browsing context flag, unless tokens contains the allow-top-navigation keyword.
</li>
			<li>
<p>
`利用者-作動化を伴う~top-level~navi$sbox
⇒
［
`allow-top-navigation-by-user-activation@v
~NIN %~token群
］~AND［
`allow-top-navigation$v ~NIN %~token群
］
◎
The sandboxed top-level navigation with user activation browsing context flag, unless tokens contains either the allow-top-navigation-by-user-activation keyword or the allow-top-navigation keyword.
</p>

<p class="note">注記：
したがって，［
`allow-top-navigation$v ~IN %~token群
］の場合、
`allow-top-navigation-by-user-activation$v の効果はなくなる。
この理由から、
両~keywordとも指定するのは，文書~適合性の~errorになる。
◎
This means that if the allow-top-navigation is present, the allow-top-navigation-by-user-activation keyword will have no effect. For this reason, specifying both is a document conformance error.
</p>
			</li>
			<li>
<p>
`生成元$sbox
⇒
`allow-same-origin@v ~NIN %~token群
◎
The sandboxed origin browsing context flag, unless the tokens contains the allow-same-origin keyword.
</p>

<div class="note">
<p>注記：
`allow-same-origin$v ~keywordは、
次の 2 つの事例に意図されている：
◎
The allow-same-origin keyword is intended for two cases.
</p>

<ul>
	<li>
一つは、
同一-~siteな内容を，次のように~sandbox化するための利用
⇒＃
内容による~scriptingは不能化する／
内容が成す~DOMへの~accessは許容する
◎
First, it can be used to allow content from the same site to be sandboxed to disable scripting, while still allowing access to the DOM of the sandboxed content.
</li>
	<li>
もう一つは、
第三者-主体~siteからの内容を埋込むときに，その内容を次のように~sandbox化するための利用
⇒
その~siteが ~popupを開く, 等々は防止するが、
埋込まれた~pageが［
~dataを格納するための~database~API, 等を利用して，その出自の~siteと通信すること
］は防止しない。
◎
Second, it can be used to embed content from a third-party site, sandboxed to prevent that site from opening popups, etc, without preventing the embedded page from communicating back to its originating site, using the database APIs to store data, etc.
</li>
</ul>
</div>

			</li>
			<li>
`~form$sbox
⇒
`allow-forms@v ~NIN %~token群
◎
The sandboxed forms browsing context flag, unless tokens contains the allow-forms keyword.
</li>
			<li>
`~pointer~lock$sbox
⇒
`allow-pointer-lock@v ~NIN %~token群
◎
The sandboxed pointer lock browsing context flag, unless tokens contains the allow-pointer-lock keyword.
</li>
			<li>
`~script$sbox
⇒
`allow-scripts@v ~NIN %~token群
◎
The sandboxed scripts browsing context flag, unless tokens contains the allow-scripts keyword.
</li>
			<li>
<p>
`自動的な特能$sbox
⇒
`allow-scripts$v ~NIN %~token群
◎
The sandboxed automatic features browsing context flag, unless tokens contains the allow-scripts keyword (defined above).
</p>

<p class="note">注記：
この~flagは、
`~script$sboxと同じ~keywordで緩められる
— この~flagにより許容されなくなる宣言的な特能は、
~scriptが可能化されている下では自明にアリになるので。
◎
This flag is relaxed by the same keyword as scripts, because when scripts are enabled these features are trivially possible anyway, and it would be unfortunate to force authors to use script to do them when sandboxed rather than allowing them to use the declarative features.
</p>
			</li>
			<li>
`~document-domain$sbox
⇒
~~無条件
◎
The sandboxed document.domain browsing context flag.
</li>
			<li>
`~sandboxは補助~閲覧~文脈に伝播する~flag$
⇒
`allow-popups-to-escape-sandbox@v ~NIN %~token群
◎
The sandbox propagates to auxiliary browsing contexts flag, unless tokens contains the allow-popups-to-escape-sandbox keyword.
</li>
			<li>
`~sandbox化( ~modal )~flag$
⇒
`allow-modals@v ~NIN %~token群
◎
The sandboxed modals flag, unless tokens contains the allow-modals keyword.
</li>
			<li>
`方位~lock$sbox
⇒
`allow-orientation-lock@v ~NIN %~token群
◎
The sandboxed orientation lock browsing context flag, unless tokens contains the allow-orientation-lock keyword.
</li>
			<li>
`呈示$sbox
⇒
`allow-presentation@v ~NIN %~token群
◎
The sandboxed presentation browsing context flag, unless tokens contains the allow-presentation keyword.
</li>
			<li>
`~download$sbox
⇒
`allow-downloads@v ~NIN %~token群
◎
The sandboxed downloads browsing context flag, unless tokens contains the allow-downloads keyword.
</li>
			<li>
`~custom~protocol~navi$sbox
⇒
［
`allow-top-navigation-to-custom-protocols@v
~NIN %~token群
］~AND［
`allow-popups$v ~NIN %~token群
］~AND［
`allow-top-navigation$v ~NIN %~token群
］
◎
The sandboxed custom protocols navigation browsing context flag, unless tokens contains either the allow-top-navigation-to-custom-protocols keyword, the allow-popups keyword, or the allow-top-navigation keyword.
</li>
		</ul>
	</li>
</ol>
</div>

<hr>

<p>
`~sandbox法~flag集合$には、
次に挙げる種類のものがある：
</p>

<ul>
	<li>
各`~top-level閲覧~文脈$は、
`~popup~sandbox法~flag集合@
を有する
— `閲覧~文脈$の作成-時には、
空~集合になるモノトスル。
それは、
次により拡充される
⇒＃
`~navigableを選ぶ規則$／
`~navi応答~用に利用する閲覧~文脈を得する$とき
◎
Every top-level browsing context has a popup sandboxing flag set, which is a sandboxing flag set. When a browsing context is created, its popup sandboxing flag set must be empty. It is populated by the rules for choosing a navigable and the obtain a browsing context to use for a navigation response algorithm.
</li>
	<li>
各 `iframe$e 要素は、
`~iframe~sandbox法~flag集合@
を有する。
所与の特定0の時点に，どの~flagがこの集合に含められるかは、
`iframe$e 要素の`sandbox$a 属性により決定される。
◎
Every iframe element has an iframe sandboxing flag set, which is a sandboxing flag set. Which flags in an iframe sandboxing flag set are set at any particular time is determined by the iframe element's sandbox attribute.
</li>
	<li>
各`文書$は、
`作動中な~sandbox法~flag集合@
を有する
— `文書$の作成-時には、
空~集合になるモノトスル。
それは、
`~navi~algo＠~HTMLnav#navigate$により拡充される。
◎
Every Document has an active sandboxing flag set, which is a sandboxing flag set. When the Document is created, its active sandboxing flag set must be empty. It is populated by the navigation algorithm.
</li>
</ul>

<div class="algo">
<p>
`~CSPから導出される~sandbox法~flag群@
は、
所与の
( `~CSP~list$ %~CSP~list )
に対し，次の~algoが返す`~sandbox法~flag集合$である：
◎
Every CSP list cspList has CSP-derived sandboxing flags, which is a sandboxing flag set. It is the return value of the following algorithm:
</p>
<ol>
	<li>
%指令~群 ~LET 空な`集合$
◎
Let directives be an empty ordered set.
</li>
	<li>
<p>
%~CSP~list を成す
~EACH( %施策 )
に対し：
◎
For each policy in cspList:
</p>
		<ol>
			<li>
~IF［
%施策 の`処置先$ ~NEQ `enforce^l
］
⇒
~CONTINUE
◎
If policy's disposition is not "enforce", then continue.
</li>
			<li>
~IF［
%施策 の`指令~集合$は、
名前 `sandbox$dir を伴う`指令$を`包含する$
］
⇒
%指令~群 に その指令を`付加する$
◎
If policy's directive set contains a directive whose name is "sandbox", then append that directive to directives.
</li>
		</ol>
	</li>
	<li>
~IF［
%指令~群 は空である
］
⇒
~RET 空な`~sandbox法~flag集合$
◎
If directives is empty, then return an empty sandboxing flag set.
</li>
	<li>
%指令 ~LET %指令~群[ %指令~群 の`~size$ − 1 ]
◎
Let directive be directives[directives's size − 1].
</li>
	<li>
~RET `~sandbox法~指令を構文解析する$( %指令 )
◎
Return the result of parsing the sandboxing directive directive.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`作成時の~sandbox法~flag群を決定する@
~algoは、
所与の
( `閲覧~文脈$ %閲覧~文脈, ~NULL または要素 %埋込元 )
に対し：
◎
To determine the creation sandboxing flags for a browsing context browsing context, given null or an element embedder, return the union of the flags that are present in the following sandboxing flag sets:
</p>
<ol>
	<li>
~IF［
%埋込元 ~EQ ~NULL
］
⇒
~RET %閲覧~文脈 の`~popup~sandbox法~flag集合$を`~cloneする$
◎
If embedder is null, then: the flags set on browsing context's popup sandboxing flag set.
</li>
	<li>
~ELSE（ %埋込元 は要素である）
⇒
~RET 次の`和集合$
⇒＃
%埋込元 の`~iframe~sandbox法~flag集合$,
%埋込元 の`~node文書$にて`作動中な~sandbox法~flag集合$
◎
If embedder is an element, then: the flags set on embedder's iframe sandboxing flag set.
◎
If embedder is an element, then: the flags set on embedder's node document's active sandboxing flag set.
</li>
</ol>
</div>

			</section>
			<section id="policy-containers">
<h4 title="Policy containers">7.1.6. 施策~容器</h4>

<p>
`施策~容器@
は、［
`Document$I ／ `WorkerGlobalScope$I ／ `WorkletGlobalScope$I
］に適用する施策を包含している`構造体$であり，次に挙げる`~item$sctからなる：
◎
A policy container is a struct containing policies that apply to a Document, a WorkerGlobalScope, or a WorkletGlobalScope. It has the following items:
</p>
<ul>
	<li>
`~CSP~list@pC
⇒
ある`~CSP~list$
— 初期~時は空とする。
◎
A CSP list, which is a CSP list. It is initially empty.
</li>
	<li>
`埋込元~施策@pC
⇒
ある`埋込元~施策$
— 初期~時は新たな`埋込元~施策$とする。
◎
An embedder policy, which is an embedder policy. It is initially a new embedder policy.
</li>
	<li>
`~referrer施策@pC
⇒
ある`~referrer施策$
— 初期~時は`既定の~referrer施策$とする。
◎
A referrer policy, which is a referrer policy. It is initially the default referrer policy.
</li>
	<li>
`完全性~施策@pC
⇒
ある`完全性~施策$
— 初期~時は新たな`完全性~施策$とする。
◎
An integrity policy, which is an integrity policy, initially a new integrity policy.
</li>
	<li>
`報告のみの完全性~施策@pC
⇒
ある`完全性~施策$
— 初期~時は新たな`完全性~施策$とする。
◎
A report only integrity policy, which is an integrity policy, initially a new integrity policy.
</li>
</ul>

<p class="XXX">
他の施策も施策~容器の中へ移動する。
◎
Move other policies into the policy container.
</p>

<div class="algo">
<p>
`施策~容器を~cloneする@
~algoは、
所与の
( `施策~容器$ %施策~容器 )
に対し：
◎
To clone a policy container given a policy container policyContainer:
</p>
<ol>
	<li>
<p>
%~clone ~LET 新たな`施策~容器$
— その
⇒＃
`埋込元~施策$pC ~SET %施策~容器 の`埋込元~施策$pCの複製
`~referrer施策$pC ~SET %施策~容器 の`~referrer施策$pC
`完全性~施策$pC ~SET %施策~容器 の`完全性~施策$pCの複製
</p>

<p class="trans-note">【
ここで`報告のみの完全性~施策$pCだけ複製しない理由は よくわからない。
】</p>
◎
Let clone be a new policy container.
◎
↓ For each policy in policyContainer's CSP list, append a copy of policy into clone's CSP list.
◎
Set clone's embedder policy to a copy of policyContainer's embedder policy.
◎
Set clone's referrer policy to policyContainer's referrer policy.
◎
Set clone's integrity policy to a copy of policyContainer's integrity policy.
</li>
	<li>
%施策~容器 の`~CSP~list$pCを成す
~EACH( %施策 )
に対し
⇒
%~clone の`~CSP~list$pC に %施策 の複製を`付加する$
◎
↑</li>
	<li>
~RET %~clone
◎
Return clone.
</li>
</ol>
</div>

<div class="algo">
<p>
`~URLは履歴~内に施策~容器を格納するよう要求するか？@
かどうか決定するときは、
所与の
( `~URL$ %~URL )
に対し：
◎
To determine whether a URL url requires storing the policy container in history:
</p>
<ol>
	<li>
~IF［
%~URL の`~scheme$url ~EQ `blob^l
］
⇒
~RET ~F
◎
If url's scheme is "blob", then return false.
</li>
	<li>
~IF［
%~URL は`局所的な~URL$である
］
⇒
~RET ~T
◎
If url is local, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`~fetch応答から施策~容器を作成する@
~algoは、
所与の
( `応答$ %応答, `環境$または~NULL %環境 )
に対し：
◎
To create a policy container from a fetch response given a response response and an environment-or-null environment:
</p>
<ol>
	<li>
~IF［
%応答 の`~URL$rsの`~scheme$url ~EQ `blob^l
］
⇒
~RET `施策~容器を~cloneする$( %応答 の`~URL$rsの`~blob~URL~entry$urlの`環境$bUの`施策~容器$ )
◎
If response's URL's scheme is "blob", then return a clone of response's URL's blob URL entry's environment's policy container.
</li>
	<li>
%結果 ~LET 新たな`施策~容器$
◎
Let result be a new policy container.
</li>
	<li>
%結果 の`~CSP~list$pC ~SET `応答の~CSPを構文解析する$( %応答 )
◎
Set result's CSP list to the result of parsing a response's Content Security Policies given response.
</li>
	<li>
%結果 の`埋込元~施策$pC ~SET %環境 に応じて
⇒＃
~NULL ならば `unsafe-none$coep ／
~ELSE_ `埋込元~施策を得する$( %応答, %環境 )
◎
If environment is non-null, then set result's embedder policy to the result of obtaining an embedder policy given response and environment. Otherwise, set it to "unsafe-none".
</li>
	<li>
%結果 の`~referrer施策$pC ~SET 
`~referrer施策を構文解析する$( %応答 )
`REFERRERPOLICY$r
◎
Set result's referrer policy to the result of parsing the `Referrer-Policy` header given response. [REFERRERPOLICY]
</li>
	<li>
`完全性~施策~headerを構文解析する$( %応答, %結果 )
`SRI$r
◎
Parse Integrity-Policy headers with response and result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navi~paramsの施策~容器を決定する@
~algoは、
所与の
⇒＃
`~URL$ %応答~URL,
`施策~容器$または~NULL %履歴~施策~容器,
`施策~容器$または~NULL %起動元~施策~容器,
`施策~容器$または~NULL %親~施策~容器,
`施策~容器$または~NULL %応答~施策~容器
◎終
に対し：
◎
To determine navigation params policy container given a URL responseURL and four policy container-or-nulls historyPolicyContainer, initiatorPolicyContainer, parentPolicyContainer, and responsePolicyContainer:
</p>
<ol>
	<li>
<p>
~IF［
%履歴~施策~容器 ~NEQ ~NULL
］：
◎
If historyPolicyContainer is not null, then:
</p>
		<ol>
			<li>
~Assert：
`~URLは履歴~内に施策~容器を格納するよう要求するか？$( %応答~URL ) ~EQ ~T
◎
Assert: responseURL requires storing the policy container in history.
</li>
			<li>
~RET `施策~容器を~cloneする$( %履歴~施策~容器 )
◎
Return a clone of historyPolicyContainer.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%応答~URL ~EQ `~about_srcdoc$sc
］：
◎
If responseURL is about:srcdoc, then:
</p>
		<ol>
			<li>
~Assert：
%親~施策~容器 ~NEQ ~NULL
◎
Assert: parentPolicyContainer is not null.
</li>
			<li>
~RET `施策~容器を~cloneする$( %親~施策~容器 )
◎
Return a clone of parentPolicyContainer.
</li>
		</ol>
	</li>
	<li>
~IF［
%応答~URL は`局所的な~URL$である
］~AND［
%起動元~施策~容器 ~NEQ ~NULL
］
⇒
~RET `施策~容器を~cloneする$( %起動元~施策~容器 )
◎
If responseURL is local and initiatorPolicyContainer is not null, then return a clone of initiatorPolicyContainer.
</li>
	<li>
~IF［
%応答~施策~容器 ~NEQ ~NULL
］
⇒
~RET %応答~施策~容器
◎
If responsePolicyContainer is not null, then return responsePolicyContainer.
</li>
	<li>
~RET 新たな`施策~容器$
◎
Return a new policy container.
</li>
</ol>
</div>

<div class="algo">
<p>
`~worker大域~scopeの施策~容器を初期化する@
~algoは、
所与の
( `WorkerGlobalScope$I %~worker大域~scope, `応答$ %応答, `環境$ %環境 )
に対し：
◎
To initialize a worker global scope's policy container given a WorkerGlobalScope workerGlobalScope, a response response, and an environment environment:
</p>
<ol>
	<li>
%~URL ~LET %~worker大域~scope の`~URL$wG
◎
↓</li>
	<li>
<p>
~IF［
%~URL は`局所的な~URL$である
］~AND［
%~URL の`~scheme$url ~NEQ `blob^l
］：
◎
If workerGlobalScope's url is local but its scheme is not "blob":
</p>
		<ol>
			<li>
~Assert：
%~worker大域~scope の`所有者~集合$wGの`~size$ ~EQ 1
◎
Assert: workerGlobalScope's owner set's size is 1.
</li>
			<li>
%~worker大域~scope の`施策~容器$wG ~SET `施策~容器を~cloneする$( %~worker大域~scope の`所有者~集合$wG[ 0 ] に`関連な設定群~obj$の`施策~容器$enV )
◎
Set workerGlobalScope's policy container to a clone of workerGlobalScope's owner set[0]'s relevant settings object's policy container.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%~worker大域~scope の`施策~容器$wG ~SET `~fetch応答から施策~容器を作成する$( %応答, %環境 )
◎
Otherwise, set workerGlobalScope's policy container to the result of creating a policy container from a fetch response given response and environment.
</li>
</ol>
</div>

			</section>
		</section>
	</section>
</main>
