<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Origin, Sandboxing（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<style>

@supports (display: grid) and (display: contents) {

._compare-origin {
	max-width: 28em;
}

._compare-origin tr {
	grid-template-areas:
		"A A"
		"B B"
		"同一 同じ"
	;
	grid-template-columns: 1fr 1fr;
}

._compare-origin tr > *:nth-child(1) {
	grid-area: A;
	white-space: nowrap;
}

._compare-origin tr > *:nth-child(2) {
	grid-area: B;
	white-space: nowrap;
}

._compare-origin tr > *:nth-child(3) {
	grid-area: 同一;
}

._compare-origin tr > *:nth-child(4) {
	grid-area: 同じ;
}

}

</style>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'coop':
case 'coep':
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sbox': // sandboxing flags
	text = `閲覧文脈~sandbox化( ${key} )~flag`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'sf': // structured fields
	text = `<sub>sf-</sub>${text}`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2020-07-10
trans_update:2020-07-12
source_checked:200626
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/origin.html
site_nav:browsers,security,html
nav_prev:WINDOW
nav_next:HISTORY
trans_1st_pub:2016-07-12


●●class_map
e:element
a:attr
et:event-type
E:error
U:code-point
sl:js-slot
v:value
h:header
sc:scheme

●●tag_map
I:code
m:code
c:code
e:code
a:code
et:code
E:code
sl:span
U:span
v:code
h:code
sc:code
i:i
em:em
cite:cite

●●words_table

database::::データベース
iframe:
	unfortunate

	●仕様
アタられ:consultされ:あたられ
採用-:adopt:~
基礎的な:fundamental:~
自明:trivial:~
不作為:inadvertent:~
固守:adherence:~
	-:substeps
	~~協調する:if they do the same thing
	なり得る:potentially
	にもかかわらず:nonetheless
	加えて:Furthermore
	様々な程度:varying degrees
	広く:widely
	方が好ましい:in favor of

	●network／保安
IPv4:
IPv6:
IP:
COOP:
coep:
下位domain:subdomain:::下位ドメイン
navigator::::ナビゲータ
隔離-:isolate:~
権限:authority:~
強制d:forced:強制
公共:public::~
逃れる:escapeする:~
flags:::flag 群:フラグ群
報告先:reporting endpoint::~
報告用:reporting::~
陥穽:pitfall:落とし穴
蝕む:undermineする:~

	信用できない:untrusted
	CORS-cross-origin
	CORS-same-origin
	~secure化-:secured
	ひどいことに:acute

	●環境 ／ 閲覧
agent:
surrounding:
補助:auxiliary::~
成分組:tuple:~
閉じる:closeする::~
	閉じるとき:closing
開く:openする::~
開いた:openした::~
	-:back
埋込元:embedder::埋め込み元
opener:::open 元
open:
closed:
切替n:switch:切り替え
scope::::スコープ

	●UI
modal::::モーダル
popup:
再生-:play:~
一過:transient::~

	around
	Control key
	~scroll用:scrolling
	~tab付き:tabbed

	●構文
分割-:split:~
接頭-:prefix:~
結合-:combine::~
直列形:serialized::~::シリアル形

	過ぎない:past
	-:頭部の

	●未分類
出自の:originating:~
動作者:actor:~
	getting
読取る:readする:読み取る
書込む:writeする:書き込む
	-:common
同等:equal:~
同等性:equality:~
和集合:union:~
実効:effective:~
	種類:
自動:automatic:~
通貨:currency:~
新-:new:~
観測器:observer::~
parameters:::parameter 群:パラメタ群

	空になった:which no longer contains any browsing contexts
	~~投出:raise
	変異しない:immutable
	対応付け:map
	~~述べ
	-:prefixed
	選ばれ
	選ぶ:choose する
	meant
	said
	~instance化-:instantiate
	:exactly
	連結-
	hosting
	非:non
	:per
	point
	それまでの文書:predecessor
	占める:occupy
	現れる:appearする
	後続-:follow
	伴い得る:attached
	最終的な:final

	●変数
	%生成元:origin
	%結果:result
	%A
	%B
	%hostA
	%hostB
	%~domain
	%~host接尾辞~文字列:hostSuffixString
	%~host:host
	%入力:input
	%出力:output
	%~tokenたち:tokens
	%元の~host:originalHost
	%埋込元:embedder
	%実効~domain:effectiveDomain
	%初期~about_blankである:isInitialAboutBlank
	%応答:response
	%応答~生成元:responseOrigin
	%応答~COOP:responseCOOP
	%B:browsingContext
	%~item:value[0]
	%値:value[0]
	%新-閲覧文脈:newBrowsingContext
	%作動中の文書の~COOP:activeDocumentCOOP
	%作動中の文書の~navi生成元:activeDocumentNavigationOrigin
	-:securityState
	-:coep
	%~sandbox~flags:sandboxFlags
	%oA:originA
	%oB:originB
	%~navi~COOP:navigationCOOP
	%報告先:endpoint
	%種別:type
	%予約-済み環境~reservedEnvironment
	%親~施策:parentPolicy
	%応答~施策:responsePolicy
	%~worker大域~scope:workerGlobalScope
	%構文解析した~item:~parsedItem
	%所有者~施策:ownerPolicy
	%施策:policy
	%報告先:-
	%~target
	%所有者:owner

	●指示語
	尾部:end
	:these
	:such as
	-:next


●●original_id_map


●●words_table1

document-domain:<code>document.domain</code> 
about_blank:about:blank

●●link_map



	●IDL
I.Document:~HTMLdom#document
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
I.MessageChannel:~HTMLcomms#messagechannel

E.SecurityError:~WEBIDL#securityerror

m.document.domain:#dom-document-domain
m.domain:#dom-document-domain
m.localStorage:~WEBSTORAGE#dom-localstorage
m.crossOriginIsolated:~HTMLGAPI#dom-crossoriginisolated
m.window.alert:~HTMLGAPI#dom-window-alert
m.window.confirm:~HTMLGAPI#dom-window-confirm
m.window.print:~HTMLGAPI#dom-window-print
m.window.prompt:~HTMLGAPI#dom-window-prompt
m.window.open:~WINDOW#dom-window-open
m.postMessage:~HTMLcomms#dom-window-postmessage

	●event
et.beforeunload:~HTMLindex#event-beforeunload

	●要素
e.img:~HEimages#the-img-element
e.iframe:~HEembed#the-iframe-element
e.audio:~HEmedia#the-audio-element
e.video:~HEmedia#the-video-element


	●内容属性
a.sandbox:~HEembed#attr-iframe-sandbox
a.target:~HTMLlinks#attr-hyperlink-target

	●code
	m.onclick
sc.~about_blank:~HTMLdep#about:blank



	●閲覧文脈
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
閲覧文脈:~BROWSERS#browsing-context
閲覧文脈を選ぶ規則:~BROWSERS#the-rules-for-choosing-a-browsing-context-given-a-browsing-context-name
作動中の文書:~BROWSERS#active-document
属する閲覧文脈:~BROWSERS#concept-document-bc
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
子~閲覧文脈:~BROWSERS#child-browsing-context
bc.容器:~BROWSERS#bc-container
容器~文書:~BROWSERS#bc-container-document
補助~閲覧文脈:~BROWSERS#auxiliary-browsing-context
新たな閲覧文脈を作成する:~BROWSERS#creating-a-new-browsing-context
作動中の~window:~BROWSERS#active-window
tbcG.~group:~BROWSERS#tlbc-group
新たな~top-level閲覧文脈を作成する:~BROWSERS#creating-a-new-top-level-browsing-context
閲覧文脈~group:~BROWSERS#browsing-context-group
bcG.非同一-生成元~隔離-済み:~BROWSERS#bcg-cross-origin-isolated

閲覧文脈を破棄する:~WINDOW#a-browsing-context-is-discarded
~session履歴:~HISTORY#session-history


	●生成元／sandbox（origin.html
	§:#origin
	§:#sandboxing
	§:#relaxing-the-same-origin-restriction
	:#origin-2
	:#unicode-serialisation-of-an-origin
	:~HTMLforms#sandboxSubmitBlocked
	:~HEmedia#attr-media-autoplay
	:~HTMLinteraction#attr-fe-autofocus
	:~NAVI#sandboxPluginNavigate
	:~WAPI#sandboxScriptBlocked
	:~HEembed#sandboxPluginEmbed
	:~HEembed#sandboxPluginObject

生成元:#concept-origin
不透明な生成元:#concept-origin-opaque
成分組~生成元:#concept-origin-tuple
o.~scheme:#concept-origin-scheme
o.~host:#concept-origin-host
o.~port:#concept-origin-port
o.~domain:#concept-origin-domain
実効~domain:#concept-origin-effective-domain
生成元を直列化する:#ascii-serialisation-of-an-origin
o.直列化:#ascii-serialisation-of-an-origin
同一-生成元:#same-origin
同じ生成元~domain:#same-origin-domain
同じ~site:#same-site
~scheme無しで同じ~site:#schemelessly-same-site

~scheme＆登録-可能な~domain:#scheme-and-registrable-domain
~site:#site
~siteを得する:#obtain-a-site

登録-可能な~domain接尾辞または同等:#is-a-registrable-domain-suffix-of-or-is-equal-to


v.allow-popups:#attr-iframe-sandbox-allow-popups
v.allow-top-navigation:#attr-iframe-sandbox-allow-top-navigation
v.allow-top-navigation-by-user-activation:#attr-iframe-sandbox-allow-top-navigation-by-user-activation
v.allow-same-origin:#attr-iframe-sandbox-allow-same-origin
v.allow-forms:#attr-iframe-sandbox-allow-forms
v.allow-pointer-lock:#attr-iframe-sandbox-allow-pointer-lock
v.allow-scripts:#attr-iframe-sandbox-allow-scripts
v.allow-popups-to-escape-sandbox:#attr-iframe-sandbox-allow-popups-to-escape-sandbox
v.allow-modals:#attr-iframe-sandbox-allow-modals
v.allow-orientation-lock:#attr-iframe-sandbox-allow-orientation-lock
v.allow-presentation:#attr-iframe-sandbox-allow-presentation
v.allow-downloads:#attr-iframe-sandbox-allow-downloads

~sandbox法~flag集合:#sandboxing-flag-set
bc.~sandbox法~flags:#concept-bc-sandboxing-flags
作動中の~sandbox法~flag集合:#active-sandboxing-flag-set
強制d~sandbox法~flag集合:#forced-sandboxing-flag-set
~popup~sandbox法~flag集合:#popup-sandboxing-flag-set
~iframe~sandbox法~flag集合:#iframe-sandboxing-flag-set

sbox.~document-domain:#sandboxed-document.domain-browsing-context-flag
sbox.~form:#sandboxed-forms-browsing-context-flag
sbox.~navi:#sandboxed-navigation-browsing-context-flag
許可-済み~navigator:#one-permitted-sandboxed-navigator
sbox.~plugin:#sandboxed-plugins-browsing-context-flag
sbox.~pointer~lock:#sandboxed-pointer-lock-browsing-context-flag
sbox.~script:#sandboxed-scripts-browsing-context-flag
sbox.非~利用者~作動化~top-level~navi:#sandboxed-top-level-navigation-without-user-activation-browsing-context-flag
sbox.利用者~作動化~top-level~navi:#sandboxed-top-level-navigation-with-user-activation-browsing-context-flag
sbox.生成元:#sandboxed-origin-browsing-context-flag
sbox.自動~特能:#sandboxed-automatic-features-browsing-context-flag
sbox.補助~navi:#sandboxed-auxiliary-navigation-browsing-context-flag
sbox.方位~lock:#sandboxed-orientation-lock-browsing-context-flag
sbox.呈示:#sandboxed-presentation-browsing-context-flag
sbox.~download:#sandboxed-downloads-browsing-context-flag

~sandboxは補助~閲覧文脈に伝播する~flag:#sandbox-propagates-to-auxiliary-browsing-contexts-flag
~sandbox化( ~modal )~flag:#sandboxed-modals-flag
作成時の~sandbox法~flagsを決定する:#determining-the-creation-sandboxing-flags
~sandbox法~指令を構文解析する:#parse-a-sandboxing-directive


	●COOP／COEP

coop.same-origin-allow-popups:#coop-same-origin-allow-popups
coop.same-origin:#coop-same-origin
coop.same-origin-plus-COEP:#coop-same-origin-plus-coep
coop.unsafe-none:#coop-unsafe-none
coep.report-to:#coep-report-to
coep.require-corp:#coep-require-corp
coep.unsafe-none:#coep-unsafe-none

h.Cross-Origin-Opener-Policy:~HTMLiana#cross-origin-opener-policy-2
h.Cross-Origin-Embedder-Policy:~HTMLiana#cross-origin-embedder-policy
h.Cross-Origin-Embedder-Policy-Report-Only:~HTMLiana#cross-origin-embedder-policy-report-only
h.Cross-Origin-Resource-Policy:~FETCH#http-cross-origin-resource-policy

~navi応答~用に利用する閲覧文脈を得する:#obtain-browsing-context-navigation
非同一-生成元~opener施策を得する:#obtain-coop
埋込元~施策を得する:#obtain-an-embedder-policy
応答は閲覧文脈~groupの切替nを要求するか検査する:#check-browsing-context-group-switch-response
非同一-生成元~opener施策:#cross-origin-opener-policy

文書:~HTMLdom#the-document-object
doc.非同一-生成元~opener施策:~HTMLdom#concept-document-coop
doc.埋込元~施策:~HTMLdom#concept-document-embedder-policy
非同一-生成元~opener施策として合致する:#matching-coop

有構造~field値を取得する:~FETCH#concept-header-list-get-structured-header
応答~URLを報告-用に直列化する:~FETCH#serialize-a-response-url-for-reporting
応答:~FETCH#concept-response
rs.~URL:~FETCH#concept-response-url
rs.~header~list:~FETCH#concept-response-header-list
rs.~HTTPS状態:~FETCH#concept-response-https-state
~CORS~protocol:~FETCH#http-cors-protocol

埋込元~施策:#embedder-policy
embP.値:#embedder-policy-value-2
embP.報告先:#embedder-policy-reporting-endpoint
embP.報告のみの値:#embedder-policy-report-only-value
embP.報告のみの報告先:#embedder-policy-report-only-reporting-endpoint

埋込元~施策~値:#embedder-policy-value
enV.埋込元~施策:~WAPI#concept-settings-object-embedder-policy
wG.埋込元~施策:~WORKERS#concept-workerglobalscope-embedder-policy
i.~coep報告~種別:#coep-report-type

大域~objの埋込元~施策を検査する:#check-a-global-object's-embedder-policy
~navi応答の埋込元~施策に対する固守を検査する:#check-a-navigation-response's-adherence-to-its-embedder-policy
非同一-生成元~埋込元~施策の継承~違反を~queueする:#queue-a-cross-origin-embedder-policy-inheritance-violation

有構造~header:~HEADER-STRUCTURE#structured-header
	有構造~header:~HEADER-STRUCTURE
sf.~token:~HEADER-STRUCTURE#sf-token
	sf.~token:~HEADER-STRUCTURE#token
sf.~parameters:~HEADER-STRUCTURE#sf-parameters
	sf.~parameters:~HEADER-STRUCTURE#param
sf.~item:~HEADER-STRUCTURE#sf-item
	sf.~item:~HEADER-STRUCTURE#item
sfI.値:~HEADER-STRUCTURE#sf-item
sfI.~parameters:~HEADER-STRUCTURE#sf-item

	●用語 HTML
l.document-domain:~HTMLINFRA#document-domain-feature
~plugin:~HTMLINFRA#plugin
~secure化でき:~HTMLINFRA#concept-plugin-secure

~CORS非同一-生成元:~HTMLurl#cors-cross-origin
~CORS同一-生成元:~HTMLurl#cors-same-origin

~navi:~NAVI#navigate
~navigate応答を処理する:~NAVI#process-a-navigate-response

環境:~WAPI#environment
enV.~secureな文脈:~WAPI#secure-context
	非~secureな文脈:~WAPI#non-secure-context
環境~設定群~obj:~WAPI#environment-settings-object
関連な設定群~obj:~WAPI#relevant-settings-object
非同一-生成元~隔離-済み:~WAPI#cross-origin-isolated

画像~data:~HEimages#img-req-data
利用は許容されて:~HEembed#allowed-to-use
~media~data:~HEmedia#media-data
~media要素:~HEmedia#media-element

一過な作動化:~HTMLinteraction#transient-activation

~hyperlinkを~downloadする:~HTMLlinks#downloading-hyperlinks
~downloadとして:~HTMLlinks#as-a-download

	●用語（外部
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
~tuple:~INFRA#tuple
空:~INFRA#list-is-empty
~cloneする:~INFRA#list-clone

	●URL1
妥当な~URL文字列:~URL1#valid-url-string
同等な~host:~URL1#concept-host-equals
~hostを直列化する:~URL1#concept-host-serializer
~host構文解析器:~URL1#concept-host-parser

x.~host:~URL1#concept-host
url.~domain:~URL1#concept-domain
url.~host:~URL1#concept-url-host
url.~port:~URL1#concept-url-port
url.~scheme:~URL1#concept-url-scheme
~IPv4~address:~URL1#concept-ipv4
~IPv6~address:~URL1#concept-ipv6
整数を直列化する:~URL1#serialize-an-integer
公共~接尾辞:~URL1#host-public-suffix
登録-可能な~domain:~URL1#host-registrable-domain

~agent~cluster:~TC39#sec-agent-clusters
~surrounding~agent:~TC39#surrounding-agent

~network~scheme:~FETCH#network-scheme

~node文書:~DOM4#concept-node-document

報告を~queueする:~REPORTING#reporting-queue
	~REPORTING#queue-report
報告~種別:~REPORTING#report-type
報告用~観測器から可視:~REPORTING#visible-to-reportingobservers
報告先:~REPORTING#endpoint


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ Origin, § Sandboxing</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>生成元, サンドボックス法 — Origin, Sandboxing</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

		<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ε, コレ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="origin">
<h2 title="Origin">7.5. 生成元</h2>

<p>
<ruby>生成元<rt>せいせいもと</rt></ruby>（ `origin^en ）は、~webの~security~modelにおける基礎的な通貨である。
~web~platformにおける，ある生成元を共有する動作者たちは、互いを信用し，同じ権限を有するものと見做される。
互いの生成元が相違する動作者たちは、敵対的になり得るものと見なされ，様々な程度で互いに隔離される。
◎
Origins are the fundamental currency of the web's security model. Two actors in the web platform that share an origin are assumed to trust each other and to have the same authority. Actors with differing origins are considered potentially hostile versus each other, and are isolated from each other to varying degrees.
</p>

<p class="example">
例えば
`bank.example.com^c
にて~hostされている X 銀行の~web~siteが
`charity.example.org^c
にて~hostされている Y 事業体の~web~siteの~DOMを精査しようと試行した場合、
`SecurityError$E 例外が~~投出されることになる。
◎
For example, if Example Bank's web site, hosted at bank.example.com, tries to examine the DOM of Example Charity's web site, hosted at charity.example.org, a "SecurityError" DOMException will be raised.
</p>

<p class="trans-note">【
“~~生成元” という訳語は、おそらく，~HTTP用語
<a href="~HTTPsem#generate">~~生成する</a>
（ `generate^en ）に由来する
— より詳細~には、~HTTP要請に対し
<a href="~HTTPsem#origin-server">応答を生成した~server</a>
（ `origin server^en ）（を識別する情報）を指す。
したがって， “~~生成元” の “~~元” の読みは、
`original^en（ “~~元の” ）を意味する “もと” であり， “げん” ではない。
】</p>

<hr>

<p id="origin-2">
`生成元@
（ `origin^en ）は、次のいずれかとして与えられる：
◎
An origin is one of the following:
</p>

<dl class="def-list">
	<dt>
`不透明な生成元@
◎
An opaque origin
</dt>
	<dd>
直列化して再度~作成し直せないような，内部的な値であって（`生成元を直列化する$ときは `null^l に直列化される）、有意義な演算は，同等性を~testすることに限られる。
◎
An internal value, with no serialization it can be recreated from (it is serialized as "null" per serialization of an origin), for which the only meaningful operation is testing for equality.
</dd>

	<dt>
`成分組~生成元@
◎
A tuple origin
</dt>
	<dd>
<p>
次のものからなる（括弧内はとり得る値）：
◎
A tuple consists of:
</p>
		<ul>
			<li>
`~scheme@o
（ `~scheme$url ）
◎
A scheme (a scheme).
</li>
			<li>
`~host@o
（ `~host$url ）
◎
A host (a host).
</li>
			<li>
`~port@o
（ `~port$url ）
◎
A port (a port).
</li>
			<li>
`~domain@o
（ ~NULL または `~domain$url ）。
他が言明されない限り， ~NULL とする。
◎
A domain (null or a domain). Null unless stated otherwise.
</li>
		</ul>

<p class="note">注記：
`生成元$は共有され得る
— 例えば、複数の`文書$間で。
加えて、`生成元$は，一般に変異しない。
`成分組~生成元$の`~domain$oに限り，それも
`document.domain$m ~APIを通してのみ，変更され得る。
◎
Origins can be shared, e.g., among multiple Document objects. Furthermore, origins are generally immutable. Only the domain of a tuple origin can be changed, and only through the document.domain API.
</p>
	</dd>
</dl>

<div class="algo">
<p>
`生成元$ %生成元 の
`実効~domain@
は、次に従って算出される：
◎
The effective domain of an origin origin is computed as follows:
</p>

<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET ~NULL
◎
If origin is an opaque origin, then return null.
</li>
	<li>
~IF［
%生成元 の`~domain$o ~NEQ ~NULL
］
⇒
~RET %生成元 の`~domain$o
◎
If origin's domain is non-null, then return origin's domain.
</li>
	<li>
~RET %生成元 の`~host$o
◎
Return origin's host.
</li>
</ol>
</div>

<p>
仕様が定義する様々な~objは，`生成元$を有するように定義される。
これらの`生成元$は、次のうち，最初に該当する項目に従って決定される：
◎
Various specification objects are defined to have an origin. These origins are determined as follows:
</p>

<ol class="switch">
	<li>
`文書$に対しては
⇒
［
`新たな閲覧文脈を作成する$, および`~navi$
］~algoが、構築~時に`生成元$をアテガう。
他の場合【アテガわなかった場合？】、
`DOM$r に定義される既定の挙動が適用される。
◎
For Document objects
• The create a new browsing context and navigation algorithms assign the origin at construction time. Otherwise, the default default behavior as defined in DOM applies. [DOM]
</li>
	<li>
<p>
`img$e 要素による画像に対しては、その`画像~data$に応じて：
◎
For images of img elements
</p>
		<ul class="switch">
			<li>
`~CORS非同一-生成元$である場合
⇒
一意かつ`不透明な生成元$
— これは、画像の作成-時にアテガわれる。
◎
If the image data is CORS-cross-origin
• A unique opaque origin assigned when the image is created.
</li>
			<li>
`~CORS同一-生成元$である場合
⇒
要素の`~node文書$の`生成元$
◎
If the image data is CORS-same-origin
• The img element's node document's origin.
</li>
		</ul>
	</li>
	<li>
<p>
`~media要素$（ `audio$e ／ `video$e ）に対しては、その`~media~data$に応じて：
◎
For audio and video elements
</p>
		<ul class="switch">
			<li>
`~CORS非同一-生成元$である場合
⇒
一意かつ`不透明な生成元$
— これは、~media~dataの~fetch時にアテガわれる。
◎
If the media data is CORS-cross-origin
• A unique opaque origin assigned when the media data is fetched.
</li>
			<li>
`~CORS同一-生成元$である場合
⇒
要素の`~node文書$の`生成元$
◎
If the media data is CORS-same-origin
• The media element's node document's origin.
</li>
		</ul>
	</li>
</ol>

<p>
他の仕様は、特定0の［
`文書$ ／ 画像 ／ `~media要素$
］の`生成元$を指定して，上の定義を上書きし得る。
◎
Other specifications can override the above definitions by themselves specifying the origin of a particular Document object, image, or media element.
</p>

<hr>

<div class="algo">
<p>
`生成元を直列化する@
ときは、所与の
( `生成元$ %生成元 )
に対し，次を適用して得される文字列を返す：
◎
The serialization of an origin is the string obtained by applying the following algorithm to the given origin origin:
</p>

<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET `null^l
◎
If origin is an opaque origin, then return "null".
</li>
	<li>
%結果 ~LET 次を順に連結した結果
⇒＃
%生成元 の`~scheme$o,
`://^l,
`~hostを直列化する$( %生成元 の`~host$o )
◎
Otherwise, let result be origin's scheme.
◎
Append "://" to result.
◎
Append origin's host, serialized, to result.
</li>
	<li>
~IF［
%生成元 の`~port$o ~EQ ~NULL
］
⇒
~RET %結果
◎
↓</li>
	<li>
~RET 次を順に連結した結果
⇒＃
%結果,
`003A^U `:^smb,
`整数を直列化する$( %生成元 の`~port$o )
◎
If origin's port is non-null, append a U+003A COLON character (:), and origin's port, serialized, to result.
◎
Return result.
</li>
</ol>
</div>

<p class="example">
`成分組~生成元$
( `https^l, `xn--maraa-rta.example^l, ~NULL, ~NULL ) 
の`直列化$oは、
`https://xn--maraa-rta.example^l
になる。
◎
The serialization of ("https", "xn--maraa-rta.example", null, null) is "https://xn--maraa-rta.example".
</p>

<p id="unicode-serialisation-of-an-origin" class="note">注記：
`生成元の~Unicode直列化^i も利用されていたが、それが広く採用されたことは，決してない。
◎
There used to also be a Unicode serialization of an origin. However, it was never widely adopted.
</p>

<hr>

<p>
2 つの`生成元$ %A, %B が
`同一-生成元@
であるとは、次のいずれかを満たすことをいう：
◎
Two origins, A and B, are said to be same origin if the following algorithm returns true:
</p>

<ul>
	<li>
［
%A, %B とも`不透明な生成元$である
］~AND［
%A ~EQ %B
］
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
［
%A, %B とも`成分組~生成元$である
］~AND［
%A, %B の ( `~scheme$o, `~host$o, `~port$o ) は各~成分ごとに一致する
］
◎
If A and B are both tuple origins and their schemes, hosts, and port are identical, then return true.
◎
Return false.
</li>
</ul>

<p>
2 つの`生成元$ %A, %B が
`同じ生成元~domain@
であるとは、次のいずれかを満たすことをいう：
◎
Two origins, A and B, are said to be same origin-domain if the following algorithm returns true:
</p>

<ul>
	<li>
［
%A, %B とも`不透明な生成元$である
］~AND［
%A ~EQ %B
］
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
<p>
［
%A, %B とも`成分組~生成元$である
］~AND［
%A, %B は次のいずれかを満たす
］：
</p>
		<ul>
			<li>
［
%A の`~domain$o ~EQ %B の`~domain$o ~NEQ ~NULL
］~AND［
%A の`~scheme$o ~EQ %B の`~scheme$o
］
</li>
			<li>
［
%A の`~domain$o ~EQ %B の`~domain$o ~EQ ~NULL
］~AND［
( %A, %B )
は`同一-生成元$である
］
</li>
		</ul>
◎
If A and B are both tuple origins, run these substeps:
• If A and B's schemes are identical, and their domains are identical and non-null, then return true.
• Otherwise, if A and B are same origin and their domains are identical and null, then return true.
◎
Return false.
	</li>
</ul>

<div class="example">

<table class="grid-table _compare-origin">
<thead><tr><th>%A ( ~scheme, ~host, ~port, ~domain )
<th>%B
<th>`同一-生成元$？
<th>`同じ生成元~domain$？
</thead><tbody>

<tr><td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>✅
<td>✅

<tr><td>(`https^l, `example.org^l, 314, ~NULL)
<td>(`https^l, `example.org^l, 420, ~NULL)
<td>❌
<td>❌

<tr><td>(`https^l, `example.org^l, 314, `example.org^l)
<td>(`https^l, `example.org^l, 420, `example.org^l)
<td>❌
<td>✅

<tr><td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>(`https^l, `example.org^l, ~NULL, `example.org^l)
<td>✅
<td>❌

<tr><td>(`https^l, `example.org^l, ~NULL, `example.org^l)
<td>(`http^l, `example.org^l, ~NULL, `example.org^l)
<td>❌
<td>❌
</tbody></table>

</div>

			<section id="sites">
<h4 title="Sites">7.5.1. ~site</h4>

<p>
`~scheme＆登録-可能な~domain@
は、
( `~scheme$url, `~domain$url )
が成す`~tuple$である。
◎
A scheme-and-registrable-domain is a tuple of a scheme and a domain.
</p>

<p>
`~site@
は、次に挙げるいずれかである
⇒＃
`不透明な生成元$ ／
`成分組~生成元$であって, その`~host$oの`登録-可能な~domain$ ~EQ ~NULL であるもの ／
`~scheme＆登録-可能な~domain$
◎
A site is an opaque origin, a tuple origin whose host's registrable domain is null, or a scheme-and-registrable-domain.
</p>

<div class="algo">
<p>
`~siteを得する@
ときは、所与の
( 生成元 %生成元 )
に対し，次を走らす：
◎
To obtain a site, given an origin origin, run these steps:
</p>
<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET %生成元
◎
If origin is an opaque origin, then return origin.
</li>
	<li>
%~domain ~LET %生成元 の`~host$oの`登録-可能な~domain$
◎
↓</li>
	<li>
~IF［
%~domain ~EQ ~NULL
］
⇒
~RET %生成元
◎
If origin's host's registrable domain is null, then return origin.
</li>
	<li>
~RET ( %生成元 の`~scheme$o, %~domain )
◎
Return (origin's scheme, origin's host's registrable domain).
</li>
</ol>
</div>

<p>
2 つの`生成元$ %A, %B が
`~scheme無しで同じ~site@
であるとは、次のいずれかを満たすことをいう：
◎
Two origins, A and B, are said to be schemelessly same site if the following algorithm returns true:
</p>

<ul>
	<li>
［
%A, %B とも`不透明な生成元$である
］~AND［
%A ~EQ %B
］
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
<p>
［
%A, %B とも`成分組~生成元$である
］~AND［
( %A の`~host$o %hostA, %B の`~host$o %hostB )
は次のいずれかを満たす
］：
</p>
		<ul>
			<li>
［
( %hostA, %hostB )
は`同等な~host$である
］~AND［
%hostA の`登録-可能な~domain$ ~EQ ~NULL
］
</li>
			<li>
( %hostA の`登録-可能な~domain$, %hostB の`登録-可能な~domain$ )
は、どちらも ~NULL でない, かつ`同等な~host$である
</li>
		</ul>
◎
If A and B are both tuple origins, then:
• Let hostA be A's host, and let hostB be B's host.
• If hostA equals hostB and hostA's registrable domain is null, then return true.
• If hostA's registrable domain equals hostB's registrable domain and is non-null, then return true.
◎
Return false.
</li>
</ul>

<p>
2 つの`生成元$ %A, %B が
`同じ~site@
であるとは、次のいずれも満たすことをいう：
◎
Two origins, A and B, are said to be same site if both of the following statements are true:
</p>

<ul>
	<li>
( %A, %B )
は、`~scheme無しで同じ~site$である
◎
A and B are schemelessly same site
</li>
	<li>
<p>
次のいずれかを満たす：
</p>
		<ul>
			<li>
%A, %B とも`不透明な生成元$である
</li>
			<li>
［
%A, %B とも`成分組~生成元$である
］~AND［
%A の`~scheme$o ~EQ %B の`~scheme$o
］
</li>
		</ul>
◎
A and B are either both opaque origins, or both tuple origins with the same scheme
</li>
</ul>

<p class="note">注記：
［
`同一-生成元$, `同じ生成元~domain$
］の概念と違って、［
`~scheme無しで同じ~site$, `同じ~site$
］においては，［
`~port$o, `~domain$o
］成分は無視される。
◎
Unlike the same origin and same origin-domain concepts, for schemelessly same site and same site, the port and domain components are ignored.
</p>

<p class="warning">
`URL^cite にて
<a href="~URL1#warning-avoid-psl">説明される理由</a>から，［
`同じ~site$,
`~scheme無しで同じ~site$
］の概念は、アリなときは避けるベキである
— `同一-生成元$を検査する方が好ましい。
◎
For the reasons explained in URL, the same site and schemelessly same site concepts should be avoided when possible, in favor of same origin checks.
</p>

<div id="example-same-site" class="example">
<p>
所与の`公共~接尾辞$［
`wildlife.museum^l, `museum^l, `com^l
］および，そうでない `example.com^l に対し：
◎
Given that wildlife.museum, museum, and com are public suffixes and that example.com is not:
</p>

<table class="grid-table _compare-origin">
<thead><tr><th>%A ( ~scheme, ~host )
<th>%B
<th>`~scheme無しで同じ~site$？
<th>`同じ~site$？
</thead><tbody>

<tr><td>(`https^l, `example.com^l)
<td>(`https^l, `sub.example.com^l)
<td>✅
<td>✅
<tr><td>(`https^l, `example.com^l)
<td>(`https^l, `sub.other.example.com^l)
<td>✅
<td>✅
<tr><td>(`https^l, `example.com^l)
<td>(`http^l, `non-secure.example.com^l)
<td>✅
<td>❌
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `sub.r.wildlife.museum^l)
<td>✅
<td>✅
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `sub.other.r.wildlife.museum^l)
<td>✅
<td>✅
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `other.wildlife.museum^l)
<td>❌
<td>❌
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `wildlife.museum^l)
<td>❌
<td>❌
<tr><td>(`https^l, `wildlife.museum^l)
<td>(`https^l, `wildlife.museum^l)
<td>✅
<td>✅
</tbody></table>

<p>
（ここでは、［
`~port$o, `~domain$o
］成分は考慮されないので省略している。）
◎
(Here we have omitted the port and domain components since they are not considered.)
</p>
</div>

			</section>
			<section id="relaxing-the-same-origin-restriction">
<h3 title="Relaxing the same-origin restriction">7.5.2. 同一-生成元による制約の緩め方</h3>

<dl class="domintro">
	<dt>%document . `domain$m [ = %domain ]</dt>
	<dd>
~security検査~用に利用される現在の~domainを返す。
◎
Returns the current domain used for security checks.
</dd>
	<dd>
下位domainを除去するような値に設定して，`生成元$の`~domain$oを変更できる
— そうすることにより，
同じ~domainに属する他の下位domain上の~pageと互いに~accessできるようになる（それらも，同じことをしたならば）。
これは、同じ~domainに属する異なる~host上の~pageが，互いの~DOMへ同期的に~accessすることを可能化する。
◎
Can be set to a value that removes subdomains, to change the origin's domain to allow pages on other subdomains of the same domain (if they do the same thing) to access each other. This enables pages on different hosts of a domain to synchronously access each other's DOMs.
</dd>
	<dd>
次においては／次のときは、設定子は `SecurityError$E 例外を投出することになる
⇒＃
~sandbox化された `iframe$e 内／
`不透明な生成元$を伴う`文書$内／
`属する閲覧文脈$が無い`文書$内／
`document-domain$l 特能は不能化されているとき
◎
In sandboxed iframes, Documents with opaque origins, Documents without a browsing context, and when the "document-domain" feature is disabled, the setter will throw a "SecurityError" exception.＼
</dd>
	<dd>
`crossOriginIsolated$m が ~T を返す事例では、設定子は何もしない。
◎
In cases where crossOriginIsolated returns true, the setter will do nothing.
</dd>
</dl>

<div class="critical">

<p>
`document.domain$m 設定子を利用するのは、避けること。
それは、同一-生成元~施策が供する~security保護を蝕む。
とりわけ、他者と~hostを共有しているとき，ひどいことになる：
例えば，信用できない第三者主体が［
同じ~IP~address上の~portだけ異なる~HTTP~server
］を~hostできる場合、［
通常は同じ~host上の異なる~siteどうしを保護する，同一-生成元による保護
］は，失敗することになる
— `document.domain$m 設定子が利用されて以降は、生成元の比較-時に，その~portは無視されるので。
◎
Avoid using the document.domain setter. It undermines the security protections provided by the same-origin policy. This is especially acute when using shared hosting; for example, if an untrusted third party is able to host an HTTP server at the same IP address but on a different port, then the same-origin protection that normally protects two different sites on the same host will fail, as the ports are ignored when comparing origins after the document.domain setter has been used.
</p>

<p>
これらの~security上の陥穽があるので、この特能は~web~platformから除去されつつある過程にある（何年もかかるであろう）。
◎
Because of these security pitfalls, this feature is in the process of being removed from the web platform. (This is a long process that takes many years.)
</p>

<p>
他の生成元と安全な方式で通信するためには、代わりに［
`postMessage()$m ／ `MessageChannel$I ~obj
］を利用すること。
◎
Instead, use postMessage() or MessageChannel objects to communicate across origins in a safe manner.
</p>
</div>

<p>
`Document$I の
`domain@m
属性の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The domain getter steps are:
</p>
		<ol>
			<li>
%実効~domain ~LET コレの`生成元$の`実効~domain$
◎
Let effectiveDomain be this's origin's effective domain.
</li>
			<li>
~IF［
%実効~domain ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If effectiveDomain is null, then return the empty string.
</li>
			<li>
~RET `~hostを直列化する$( %実効~domain )
◎
Return effectiveDomain, serialized.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The domain setter steps are:
</p>
		<ol>
			<li>
~IF［
コレが`属する閲覧文脈$ ~EQ ~NULL
］
⇒
~THROW `SecurityError$E
◎
If this's browsing context is null, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
`~document-domain$sbox ~IN
コレにて`作動中の~sandbox法~flag集合$
］
⇒
~THROW `SecurityError$E
◎
If this's active sandboxing flag set has its sandboxed document.domain browsing context flag set, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
コレには `document-domain$l 特能の`利用は許容されて$いない
］
⇒
~THROW `SecurityError$E
◎
If this is not allowed to use the "document-domain" feature, then throw a "SecurityError" DOMException.
</li>
			<li>
%実効~domain ~LET コレの`生成元$の`実効~domain$
◎
Let effectiveDomain be this's origin's effective domain.
</li>
			<li>
~IF［
%実効~domain ~EQ ~NULL
］
⇒
~THROW `SecurityError$E
◎
If effectiveDomain is null, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
所与の値は %実効~domain に対し`登録-可能な~domain接尾辞または同等$でない
］
⇒
~THROW `SecurityError$E
◎
If the given value is not a registrable domain suffix of and is not equal to effectiveDomain, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
`~surrounding~agent$の`~agent~cluster$の`非同一-生成元~隔離-済み$ ~EQ ~T
］
⇒
~RET
◎
If the surrounding agent's agent cluster's cross-origin isolated is true, then return.
</li>
			<li>
コレの`生成元$の`~domain$o ~SET `~host構文解析器$( 所与の値 )
◎
Set this's origin's domain to the result of parsing the given value.
</li>
		</ol>
	</li>
</ul>

<div class="algo">
<p>
所与の文字列 %~host接尾辞~文字列 は`~host$x %元の~host に対し
`登録-可能な~domain接尾辞または同等@
であるかどうか決定するときは、次を走らす：
◎
To determine if a string hostSuffixString is a registrable domain suffix of or is equal to a host originalHost, run these steps:
</p>

<ol>
	<li>
~IF［
%~host接尾辞~文字列 ~EQ 空~文字列
］
⇒
~RET ~F
◎
If hostSuffixString is the empty string, then return false.
</li>
	<li>
%~host ~LET `~host構文解析器$( %~host接尾辞~文字列 )
◎
Let host be the result of parsing hostSuffixString.
</li>
	<li>
~IF［
%~host ~EQ `失敗^i
］
⇒
~RET ~F
◎
If host is failure, then return false.
</li>
	<li>
<p>
~IF［
( %~host, %元の~host )
は`同等な~host$でない
］：
◎
If host does not equal originalHost, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~host , %元の~host のいずれかは`~domain$urlでない 
］
⇒
~RET ~F
◎
If host or originalHost is not a domain, then return false.
</p>

<p class="note">注記：
すなわち、
`~IPv4~address$ ／ `~IPv6~address$
による`~host$xは除外する。
◎
This excludes hosts that are an IPv4 address or an IPv6 address.
</p>
			</li>
			<li>
~IF［［
%~host に `002E^U `.^smb を接頭した結果
］は %元の~host の尾部に【！正確に】合致しない
］
⇒
~RET ~F
◎
If host, prefixed by a U+002E FULL STOP (.), does not exactly match the end of originalHost, then return false.
</li>
			<li>
~IF［
( %~host, %~host の`公共~接尾辞$ )
は`同等な~host$である `URL$r
］
⇒
~RET ~F
◎
If host equals host's public suffix, then return false. [URL]
</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="sandboxing">
<h2 title="Sandboxing">7.6. ~sandbox法</h2>

<p>
`~sandbox法~flag集合@
は、以下に挙げる各種~flagのうち，いくつかからなる集合である。
この集合は、それが含む各種~flagを通して，信用できない資源が持ち得る能を制約するために利用される：
◎
A sandboxing flag set is a set of zero or more of the following flags, which are used to restrict the abilities that potentially untrusted resources have:
</p>

【！ flag ~IN ~sandbox法~flag集合 ↔ flag ~EQ ~T】

<p class="trans-note">【
“<a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security)">~sandbox</a>”
—  “（こどもの）砂場” （ “監獄” を和らげた語（一般に，より制約も緩い））。
】【
以下に現れる各種
“`X^sbox”
は、
“［
X について，閲覧文脈を~sandbox化する（ X の機能を抑止する）
］ことを指示する~flag”
と解釈する
— そのように解釈し易いよう、この訳では，関数的に記している。
】【
以下に現れる “内容” とは、［
これらの~flagが適用される閲覧文脈
］内の内容を指す。
】</p>

<dl>
	<dt>
`~navi@sbox
◎
The sandboxed navigation browsing context flag
</dt>
	<dd>
<p>
この~flagは、~sandbox化されている当の閲覧文脈を %B とするとき，
次に挙げるもの以外の`閲覧文脈$ %C に対しては，
%B の内容が %C を
<a href="~NAVI#sandboxLinks">~navigateするのを防止する</a>
：
</p>
		<ul>
			<li>
%B 自身
</li>
			<li>
%B が内側に更に入子にしている閲覧文脈
</li>
			<li>
%B が開いた`補助~閲覧文脈$（これは、`補助~navi$sboxにより保護される）†
</li>
			<li>
%B の`~top-level閲覧文脈$（これは、
`利用者~作動化~top-level~navi$sbox,
`非~利用者~作動化~top-level~navi$sbox
により保護される）
</li>
		</ul>
◎
This flag prevents content from navigating browsing contexts other than the sandboxed browsing context itself (or browsing contexts further nested inside it), auxiliary browsing contexts (which are protected by the sandboxed auxiliary navigation browsing context flag defined next), and the top-level browsing context (which is protected by the sandboxed top-level navigation without user activation browsing context flag and sandboxed top-level navigation with user activation browsing context flag defined below).
</dd>
	<dd>†
この制約にもかかわらず，［
`補助~navi$sbox ~NIN `~sandbox法~flag集合$
］の下では、ある種の事例では，新たな`~top-level閲覧文脈$として
%~popup 【すなわち、`補助~閲覧文脈$】を開くことが許容される。
そのような %~popup の作成-時には、それを作成した`閲覧文脈$が，
%~popup の
`許可-済み~navigator@††
として設定される
— それは、（ ~naviに関して~sandbox化されていても）実際には %~popup を~navigateすることが許可される。
（他の場合、 %~popup に対する~naviは，`~navi$sboxにより防止される。）
◎
If the sandboxed auxiliary navigation browsing context flag is not set, then in certain cases the restrictions nonetheless allow popups (new top-level browsing contexts) to be opened. These browsing contexts always have one permitted sandboxed navigator, set when the browsing context is created, which allows the browsing context that created them to actually navigate them. (Otherwise, the sandboxed navigation browsing context flag would prevent them from being navigated even if they were opened.)
</dd>
	<dd class="trans-note">【††
“`one permitted sandboxed navigator^en”
— この “`one^en” は、［
%~popup に対し`許可-済み~navigator$とされるものは、 1 個だけあること
］を表していると見受けられる。
】</dd>

	<dt>
`補助~navi@sbox
◎
The sandboxed auxiliary navigation browsing context flag
</dt>
	<dd>
この~flagは、内容が
<a href="~BROWSERS#sandboxWindowOpen">新たな補助~閲覧文脈を作成するのを防止する</a>
—
例えば［
`target$a 属性 ／
`window.open()$m ~method
］を利用して。
◎
This flag prevents content from creating new auxiliary browsing contexts, e.g. using the target attribute or the window.open() method.
</dd>

	<dt>`非~利用者~作動化~top-level~navi@sbox</dt>
	<dt>`利用者~作動化~top-level~navi@sbox</dt>
	<dd>
両~flagとも、内容が その`~top-level閲覧文脈$を［
<a href="~NAVI#sandboxLinks">~navigateするのを防止する</a> ／
<a href="~WINDOW#sandboxClose">閉じるのを防止する</a>
］。
これらは順に、~sandbox化されている閲覧文脈にて`作動中の~window$の`一過な作動化$が［
~F のとき, ~T のとき
］に限り，アタられる。
◎
The sandboxed top-level navigation without user activation browsing context flag
◎
This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level browsing context. It is consulted only when the sandboxed browsing context's active window does not have transient activation.
</dd>
	<dd>
両~flagとも、影響するのは`~top-level閲覧文脈$に限られる
— ［
この~flag（`一過な作動化$に応じて適切な方） ~NIN `~sandbox法~flag集合$
］の下では、内容は，その`~top-level閲覧文脈$を~navigateできる。
が、他の`閲覧文脈$は，依然として他の~flag
— `~navi$sboxや, （場合によっては）`補助~navi$sbox —
により保護される。
◎
When the sandboxed top-level navigation without user activation browsing context flag is not set, content can navigate its top-level browsing context, but other browsing contexts are still protected by the sandboxed navigation browsing context flag and possibly the sandboxed auxiliary navigation browsing context flag.
◎
The sandboxed top-level navigation with user activation browsing context flag
◎
This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level browsing context. It is consulted only when the sandboxed browsing context's active window has transient activation.
◎
As with the sandboxed top-level navigation without user activation browsing context flag, this flag only affects the top-level browsing context; if it is not set, other browsing contexts might still be protected by other flags.
</dd>

	<dt>
`~plugin@sbox
◎
The sandboxed plugins browsing context flag
</dt>
	<dd>
この~flagは、内容が［
<a href="~HEembed#sandboxPluginEmbed">`embed^e 要素を利用して</a> ／
<a href="~HEembed#sandboxPluginObject">`object^e 要素を利用して</a>
］, あるいは［
それらが`入子にしている閲覧文脈$に対する
<a href="~NAVI#sandboxPluginNavigate">~naviを通して</a>
］~pluginを~instance化するのを防止する
— それらの`~plugin$を`~secure化でき$ない限り。
◎
This flag prevents content from instantiating plugins, whether using the embed element, the object element, or through navigation of their nested browsing context, unless those plugins can be secured.
</dd>

	<dt>
`生成元@sbox
◎
The sandboxed origin browsing context flag
</dt>
	<dd>
この~flagは、
<a href="~BROWSERS#sandboxOrigin">内容を一意な生成元~内に強制する</a>
— したがって，内容が［
同じ`生成元$からの他の内容
］に~accessするのを防止する。
◎
This flag forces content into a unique origin, thus preventing it from accessing other content from the same origin.
</dd>
	<dd>
この~flagはまた、~scriptが `document.cookie^m ~IDL属性を
<a href="~HTMLdom#sandboxCookies">読取る／書込むのを防止する</a>
ことに加え， `localStorage$m への~accessも阻止する。
◎
This flag also prevents script from reading from or writing to the document.cookie IDL attribute, and blocks access to localStorage.
</dd>

	<dt>
`~form@sbox
◎
The sandboxed forms browsing context flag
</dt>
	<dd>
この~flagは、
<a href="~HTMLforms#sandboxSubmitBlocked">~form提出を阻止する</a>
。
◎
This flag blocks form submission.
</dd>

	<dt>
`~pointer~lock@sbox
◎
The sandboxed pointer lock browsing context flag
</dt>
	<dd>
この~flagは、 Pointer Lock ~APIを不能化する。
`POINTERLOCK$r
◎
This flag disables the Pointer Lock API. [POINTERLOCK]
</dd>

	<dt>
`~script@sbox
◎
The sandboxed scripts browsing context flag
</dt>
	<dd>
この~flagは、
<a href="~WAPI#sandboxScriptBlocked">~script実行を阻止する</a>。
◎
This flag blocks script execution.
</dd>

	<dt>
`自動~特能@sbox
◎
The sandboxed automatic features browsing context flag
</dt>
	<dd>
<p >
この~flagは、次に挙げるような自動的に誘発される特能を阻止する：
</p>

<ul ><li><a href="~HEmedia#attr-media-autoplay">動画を自動的に再生する</a>
</li><li><a href="~HTMLinteraction#attr-fe-autofocus">~form~controlを自動的に~focusする</a>
</li></ul>

◎
This flag blocks features that trigger automatically, such as automatically playing a video or automatically focusing a form control.
</dd>

	<dt>
`~document-domain@sbox
◎
The sandboxed document.domain browsing context flag
</dt>
	<dd>
この~flagは、 `document.domain$m 設定子の利用を防止する。
◎
This flag prevents content from using the document.domain setter.
</dd>

	<dt>
`~sandboxは補助~閲覧文脈に伝播する~flag@
◎
The sandbox propagates to auxiliary browsing contexts flag
</dt>
	<dd>
この~flagは、［
内容にて`作動中の~sandbox法~flag集合$
］を［
内容が作成する`補助~閲覧文脈$
］に継承させることにより，内容が ~sandboxから逃れるのを防止する。
◎
This flag prevents content from escaping the sandbox by ensuring that any auxiliary browsing context it creates inherits the content's active sandboxing flag set.
</dd>

	<dt>
`~sandbox化( ~modal )~flag@
◎
The sandboxed modals flag
</dt>
	<dd>
<p>
この~flagは、［
内容が，次のいずれかの特能を利用して~modal~dialogを生産する
］のを防止する：
◎
This flag prevents content from using any of the following features to produce modal dialogs:
</p>

<ul><li>`window.alert()$m
</li><li>`window.confirm()$m
</li><li>`window.print()$m
</li><li>`window.prompt()$m
</li><li>`beforeunload$et ~event
</li></ul>

	</dd>

	<dt>
`方位~lock@sbox
◎
The sandboxed orientation lock browsing context flag
</dt>
	<dd>
この~flagは、~screen方位を~lockする能を不能化する。
`SCREENORIENTATION$r
◎
This flag disables the ability to lock the screen orientation. [SCREENORIENTATION]
</dd>
	<dt>
`呈示@sbox
◎
The sandboxed presentation browsing context flag
</dt>
	<dd>
この~flagは、 Presentation API を不能化する。
`PRESENTATION$r
◎
This flag disables the Presentation API. [PRESENTATION]
</dd>

	<dt>
`~download@sbox
◎
The sandboxed downloads browsing context flag
</dt>
	<dd>
この~flagは、内容が次のいずれかを通して~downloadを起動したり~instance化することを防止する
⇒＃
`~hyperlinkを~downloadする$／
`~navigate応答を処理する$ときに`~downloadとして$取扱われるもの
◎
This flag prevents content from initiating or instantiating downloads, whether through downloading hyperlinks or through navigation that gets handled as a download.
</dd>
</dl>

<div class="algo">
<p>
`~sandbox法~指令を構文解析する@
手続きは、所与の (
文字列 %入力,
`~sandbox法~flag集合$ %出力
)
に対し，次を走らすモノトスル：
◎
When the user agent is to parse a sandboxing directive, given a string input, a sandboxing flag set output, it must run the following steps:
</p>

<ol>
	<li>
%~tokenたち ~LET `~ASCII空白で分割する$( %入力 )
◎
Split input on ASCII whitespace, to obtain tokens.
</li>
	<li>
%出力 を空にする
◎
Let output be empty.
</li>
	<li>

<p>
以下に挙げる各種~flagを，対応する記述の条件が満たされるならば
%出力 に追加する：
◎
Add the following flags to output:
</p>
		<ul>
			<li>
`~navi$sbox
⇒
無条件
◎
The sandboxed navigation browsing context flag.
</li>
			<li>
`補助~navi$sbox
⇒
`allow-popups@v ~NIN %~tokenたち
◎
The sandboxed auxiliary navigation browsing context flag, unless tokens contains the allow-popups keyword.
</li>
			<li>
`非~利用者~作動化~top-level~navi$sbox
⇒
`allow-top-navigation@v
~NIN %~tokenたち
◎
The sandboxed top-level navigation without user activation browsing context flag, unless tokens contains the allow-top-navigation keyword.
</li>
			<li>
<p>
`利用者~作動化~top-level~navi$sbox
⇒
［
`allow-top-navigation-by-user-activation@v
~NIN %~tokenたち
］~AND［
`allow-top-navigation$v ~NIN %~tokenたち
］
◎
The sandboxed top-level navigation with user activation browsing context flag, unless tokens contains either the allow-top-navigation-by-user-activation keyword or the allow-top-navigation keyword.
</p>

<p class="note">注記：
したがって、［
`allow-top-navigation$v ~IN %~tokenたち
］の場合、
`allow-top-navigation-by-user-activation$v
の効果はなくなる。
この理由から、両~keywordとも指定するのは，文書~適合性の~errorになる。
◎
This means that if the allow-top-navigation is present, the allow-top-navigation-by-user-activation keyword will have no effect. For this reason, specifying both is a document conformance error.
</p>
			</li>
			<li>
`~plugin$sbox
⇒
無条件
◎
The sandboxed plugins browsing context flag.
</li>
			<li>
<p>
`生成元$sbox
⇒
`allow-same-origin@v ~NIN %~tokenたち
◎
The sandboxed origin browsing context flag, unless the tokens contains the allow-same-origin keyword.
</p>

<div class="note">

<p>注記：
`allow-same-origin$v ~keywordは、次の 2 つの事例に意図されている：
◎
The allow-same-origin keyword is intended for two cases.
</p>

<ul>
	<li>
<p>
一つは、同じ~siteからの内容を，次のように~sandbox化するための利用：
</p>

<ul ><li>内容による~scriptingは不能化する。
</li><li>内容が成す~DOMへの~accessは許容する。
</li></ul>
◎
First, it can be used to allow content from the same site to be sandboxed to disable scripting, while still allowing access to the DOM of the sandboxed content.
</li>
	<li>
<p>
もう一つは、第三者主体~siteからの内容を埋込むときに，その内容を次のように~sandbox化するための利用：
</p>

<ul ><li>その~siteが ~popupを開く, 等々は防止する。
</li><li>［
埋込まれた~pageが、~dataを格納するための~database~API, 等を利用して，その出自の~siteと通信する
］ことは防止しない。
</li></ul>

◎
Second, it can be used to embed content from a third-party site, sandboxed to prevent that site from opening popups, etc, without preventing the embedded page from communicating back to its originating site, using the database APIs to store data, etc.
</li>
</ul>
</div>

			</li>
			<li>
`~form$sbox
⇒
`allow-forms@v ~NIN %~tokenたち
◎
The sandboxed forms browsing context flag, unless tokens contains the allow-forms keyword.
</li>
			<li>
`~pointer~lock$sbox
⇒
`allow-pointer-lock@v ~NIN %~tokenたち
◎
The sandboxed pointer lock browsing context flag, unless tokens contains the allow-pointer-lock keyword.
</li>
			<li>
`~script$sbox
⇒
`allow-scripts@v ~NIN %~tokenたち
◎
The sandboxed scripts browsing context flag, unless tokens contains the allow-scripts keyword.
</li>
			<li>
<p>
`自動~特能$sbox
⇒
`allow-scripts$v ~NIN %~tokenたち
◎
The sandboxed automatic features browsing context flag, unless tokens contains the allow-scripts keyword (defined above).
</p>

<p class="note">注記：
この~flagは、`~script$sboxと同じ~keywordで緩められる
— この~flagにより許容されなくなる宣言的な特能は、~scriptが可能化されている下では自明にアリになるので。
◎
This flag is relaxed by the same keyword as scripts, because when scripts are enabled these features are trivially possible anyway, and it would be unfortunate to force authors to use script to do them when sandboxed rather than allowing them to use the declarative features.
</p>
			</li>
			<li>
`~document-domain$sbox
⇒
無条件
◎
The sandboxed document.domain browsing context flag.
</li>
			<li>
`~sandboxは補助~閲覧文脈に伝播する~flag$
⇒
`allow-popups-to-escape-sandbox@v ~NIN %~tokenたち
◎
The sandbox propagates to auxiliary browsing contexts flag, unless tokens contains the allow-popups-to-escape-sandbox keyword.
</li>
			<li>
`~sandbox化( ~modal )~flag$
⇒
`allow-modals@v ~NIN %~tokenたち
◎
The sandboxed modals flag, unless tokens contains the allow-modals keyword.
</li>
			<li>
`方位~lock$sbox
⇒
`allow-orientation-lock@v ~NIN %~tokenたち
◎
The sandboxed orientation lock browsing context flag, unless tokens contains the allow-orientation-lock keyword.
</li>
			<li>
`呈示$sbox
⇒
`allow-presentation@v ~NIN %~tokenたち
◎
The sandboxed presentation browsing context flag, unless tokens contains the allow-presentation keyword.
</li>
			<li>
`~download$sbox
⇒
`allow-downloads@v ~NIN %~tokenたち
◎
The sandboxed downloads browsing context flag, unless tokens contains the allow-downloads keyword.
</li>
		</ul>
	</li>
</ol>
</div>

<hr>

<p>
`~sandbox法~flag集合$には、次に挙げる種類のものがある：
</p>

<ul>
	<li>
各`~top-level閲覧文脈$は、
`~popup~sandbox法~flag集合@
を有する
— `閲覧文脈$の作成-時には、空~集合になるモノトスル。
それは、次により拡充される
⇒＃
`閲覧文脈を選ぶ規則$／
`~navi応答~用に利用する閲覧文脈を得する$とき
◎
Every top-level browsing context has a popup sandboxing flag set, which is a sandboxing flag set. When a browsing context is created, its popup sandboxing flag set must be empty. It is populated by the rules for choosing a browsing context and the obtain a browsing context to use for a navigation response algorithm.
</li>
	<li>
各 `iframe$e 要素は、
`~iframe~sandbox法~flag集合@
を有する。
所与の特定0の時点に，どの~flagがこの集合に含められるかは、
`iframe$e 要素の`sandbox$a 属性により決定される。
◎
Every iframe element has an iframe sandboxing flag set, which is a sandboxing flag set. Which flags in an iframe sandboxing flag set are set at any particular time is determined by the iframe element's sandbox attribute.
</li>
	<li>
各`文書$は、
`作動中の~sandbox法~flag集合@
を有する
— `文書$の作成-時には、空~集合になるモノトスル。
それは、`~navi$~algoにより拡充される。
◎
Every Document has an active sandboxing flag set, which is a sandboxing flag set. When the Document is created, its active sandboxing flag set must be empty. It is populated by the navigation algorithm.
</li>
	<li>
<p>
`~navi$~algoにより得される各~資源は、
`強制d~sandbox法~flag集合@
を有する
— 既定では空~集合とする。
他の仕様は、ある種の~flagをこの集合に含めるよう定義し得る。
◎
Every resource that is obtained by the navigation algorithm has a forced sandboxing flag set, which is a sandboxing flag set. A resource by default has no flags set in its forced sandboxing flag set, but other specifications can define that certain flags are set.
</p>

<p class="note">注記：
`強制d~sandbox法~flag集合$は、特に，
Content Security Policy `CSP$r により利用される。
◎
In particular, the forced sandboxing flag set is used by Content Security Policy. [CSP]
</p>
	</li>
</ul>

<hr>

<div class="algo">
<p>
`作成時の~sandbox法~flagsを決定する@
ときは、所与の
( `閲覧文脈$ %B, ~NULL または要素 %埋込元 )
に対し、次を走らす：
◎
To determine the creation sandboxing flags for a browsing context browsing context, given null or an element embedder, return the union of the flags that are present in the following sandboxing flag sets:
</p>
<ol>
	<li>
~IF［
%埋込元 ~EQ ~NULL
］
⇒
~RET ［
%B の`~popup~sandbox法~flag集合$
］を成すすべての~flagからなる集合
◎
If embedder is null, then: the flags set on browsing context's popup sandboxing flag set.
</li>
	<li>
~ELSE（ %埋込元 は要素である）
⇒
~RET 次の和集合を成すすべての~flagからなる集合
⇒＃
%埋込元 の`~iframe~sandbox法~flag集合$,
%埋込元 の`~node文書$にて`作動中の~sandbox法~flag集合$
◎
If embedder is an element, then: the flags set on embedder's iframe sandboxing flag set.
◎
If embedder is an element, then: the flags set on embedder's node document's active sandboxing flag set.
</li>
</ol>
</div>

<p>
`閲覧文脈$【！`属する閲覧文脈$】 %B 用の
`~sandbox法~flags@bc
は、 %B の作成~後には次の結果になる
⇒
`作成時の~sandbox法~flagsを決定する$( %B, %B の`容器$bc )
◎
After creation, the sandboxing flags for a browsing context browsing context are the result of determining the creation sandboxing flags given browsing context and browsing context's container.
</p>

		</section>
		<section id="cross-origin-opener-policies">
<h2 title="Cross-origin opener policies">7.7. 非同一-生成元~opener施策</h2>

<p>
`非同一-生成元~opener施策@
は、`~top-level閲覧文脈$内に~navigateされる文書に［
新たな`~top-level閲覧文脈$, および
対応する`~group$tbcG
］の作成を強制することを許容する。
それは、次に挙げる いずれかを値にとる：
◎
A cross-origin opener policy allows a document which is navigated to in a top-level browsing context to force the creation of a new top-level browsing context, and a corresponding group.＼
It has one of the following values:
</p>
<dl>
	<dt>`unsafe-none@coop</dt>
	<dd>
これが（現在の）既定であり、次を意味する
⇒
文書は，それまでの文書
【~navigateされる前に作動中であった文書】
と同じ`~top-level閲覧文脈$を占めることになる
— ただし、それまでの文書に異なる`非同一-生成元~opener施策$が指定されている場合は除く。
◎
This is the (current) default and means that the document will occupy the same top-level browsing context as its predecessor, unless that document specified a different cross-origin opener policy.
</dd>

	<dt>`same-origin-allow-popups@coop</dt>
	<dd>
これは、文書~用に新たな`~top-level閲覧文脈$の作成を強制する
— ただし、それまでの文書に同じ`非同一-生成元~opener施策$を指定されていて，それらは`同一-生成元$である場合は除く。
◎
This forces the creation of a new top-level browsing context for the document, unless its predecessor specified the same cross-origin opener policy and they are same origin.
</dd>

	<dt>`same-origin@coop</dt>
	<dd>
これは、 `same-origin-allow-popups$coop と同じに挙動することに加え，作成される どの`補助~閲覧文脈$も［
同じ`非同一-生成元~opener施策$を有する, かつ`同一-生成元$な文書
］を包含する必要があるようにする
— そうでない場合、それは，~openerに対し~closedに【~accessし得ないように】現れることになる。
◎
This behaves the same as "same-origin-allow-popups", with the addition that any auxiliary browsing context created needs to contain same origin documents that also have the same cross-origin opener policy or it will appear closed to the opener.
</dd>

	<dt>`same-origin-plus-COEP@coop</dt>
	<dd>
これは `same-origin$coop と同じに挙動することに加え，（新たな）`~top-level閲覧文脈$の`~group$tbcGの`非同一-生成元~隔離-済み$bcGを ~T に設定する。
◎
This behaves the same as "same-origin", with the addition that it sets the (new) top-level browsing context's group's cross-origin isolated to true.
</dd>
	<dd class="note">注記：
`same-origin-plus-COEP$coop は、
`Cross-Origin-Opener-Policy$h ~headerを介して直に設定することはできないが、次の組合nを一緒に設定した結果として得られる
⇒＃
`Cross-Origin-Opener-Policy$h には `same-origin$coop,
`Cross-Origin-Embedder-Policy$h には `require-corp^l
◎
"same-origin-plus-COEP" cannot be directly set via the `Cross-Origin-Opener-Policy` header, but results from a combination of setting both `Cross-Origin-Opener-Policy: same-origin` and `Cross-Origin-Embedder-Policy: require-corp` together.
</dd>
</dl>

<div class="algo">
<p>
所与の
( `非同一-生成元~opener施策$ %A, `生成元$ %oA,
`非同一-生成元~opener施策$ %B, `生成元$ %oB )
は、次のいずれかが満たされるとき, その時に限り
`非同一-生成元~opener施策として合致する@
とされる：
</p>
<ul>
	<li>
%A ~EQ %B ~EQ `unsafe-none$coop
</li>
	<li>
［
%A ~EQ %B ~NEQ `unsafe-none$coop
］~AND［
( %oA, %oB )
は`同一-生成元$である
］
</li>
</ul>

◎
To match cross-origin opener policies, given a cross-origin opener policy A, an origin originA, a cross-origin opener policy B, and an origin originB:
• If A is "unsafe-none" and B is "unsafe-none", then return true.
• If A is "unsafe-none" or B is "unsafe-none", then return false.
• If A is B and originA is same origin with originB, then return true.
• Return false.
</div>

			<section id="the-cross-origin-opener-policy-header">
<h3 title="The Cross-Origin-Opener-Policy header">7.7.1. `Cross-Origin-Opener-Policy^h ~header</h3>

<p>
`文書$の`非同一-生成元~opener施策$docは、
`Cross-Origin-Opener-Policy$h
~HTTP応答~headerから導出される。
この~headerは`有構造~header$であり、その値は`~token$sf でなければナラナイ。
`STRUCTURED-HEADERS$r
◎
A Document's cross-origin opener policy is derived from the `Cross-Origin-Opener-Policy` HTTP response header. This header is a structured header whose value must be a token. [STRUCTURED-HEADERS]
</p>

<p>
次に挙げる値が，`~token$sfとして妥当になる
⇒＃
`unsafe-none$coop,
`same-origin-allow-popups$coop,
`same-origin$coop
◎
The valid token values are "unsafe-none", "same-origin-allow-popups", and "same-origin".
</p>

<p class="note">注記：
下に述べる処理~modelにより、~UAは，次の場合にはこの~headerを無視することになる
⇒
値を`~token$sfとして構文解析できない／
妥当でない値を包含する
◎
Per the processing model described below, user agents will ignore this header if it contains an invalid value. Likewise, user agents will ignore this header if the value cannot be parsed as a token.
</p>

<hr>

<div class="algo">
<p>
`非同一-生成元~opener施策を得する@
ときは、所与の
( `応答$ %応答, `環境$ %予約-済み環境 )
に対し：
◎
To obtain a cross-origin opener policy given a response response and an environment reservedEnvironment:
</p>
<ol>
	<li>
~IF［
%予約-済み環境 は`~secureな文脈$enVでない
］
⇒
~RET `unsafe-none$coop
◎
If reservedEnvironment is a non-secure context, then return "unsafe-none".
</li>
	<li>
~IF［
%応答 の`~HTTPS状態$rs ~EQ `deprecated^l
］
⇒
~RET `unsafe-none$coop
◎
If response's HTTPS state is "deprecated", then return "unsafe-none".
</li>
	<li>
%~item ~LET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Cross-Origin-Opener-Policy$h, `~item^i )
◎
Let value be the result of getting a structured header given `Cross-Origin-Opener-Policy` and "item" from response's header list.
</li>
	<li>
~IF［
%~item ~EQ ~NULL【！failure or null】
］
⇒
~RET `unsafe-none$coop
◎
If value is failure or null, then return "unsafe-none".
</li>
	<li>
%値 ~LET %~item の`値$sfI【！ %~item[0] 】
◎
↓</li>
	<li>
~IF［
%値 の型は`~token$sfでない【この条件は、この訳による補完】
］~OR［
%値 ~NIN { `same-origin$coop, `same-origin-allow-popups$coop }
］
⇒
~RET `unsafe-none$coop
◎
If value[0] is not "same-origin" or "same-origin-allow-popups", then return "unsafe-none".
</li>
	<li>
~IF［
%値 ~EQ `same-origin$coop
］~AND［
`埋込元~施策を得する$( %応答 ) の`値$embP ~EQ `require-corp^l
］
⇒
~RET `same-origin-plus-COEP$coop
◎
If value[0] is "same-origin", then:
• Let coep be the result of obtaining an embedder policy from response.
• If coep's value is "require-corp", then return "same-origin-plus-COEP".
</li>
	<li>
~RET %値
◎
Return value[0].
</li>
</ol>
</div>

			</section>
			<section id="browsing-context-group-switches-due-to-cross-origin-opener-policy">
<h3 title="Browsing context group switches due to cross-origin opener policy">7.7.2. 非同一-生成元~opener施策に因る閲覧文脈~groupの切替n</h3>

<div class="algo">
<p>
`応答は閲覧文脈~groupの切替nを要求するか検査する@
ときは、所与の
( `閲覧文脈$ %B, `生成元$ %応答~生成元, `非同一-生成元~opener施策$ %応答~COOP )
に対し：
◎
To check if a response requires a browsing context group switch, given a browsing context browsingContext, an origin responseOrigin and a cross-origin opener policy responseCOOP:
</p>
<ol>
	<li>
%作動中の文書の~navi生成元 ~LET %B にて`作動中の文書$の`生成元$
◎
Let activeDocumentNavigationOrigin be browsingContext's active document's origin.
</li>
	<li>
%作動中の文書の~COOP ~LET %B にて`作動中の文書$の`非同一-生成元~opener施策$doc
◎
Let activeDocumentCOOP be browsingContext's active document's cross-origin opener policy.
</li>
	<li>
%初期~about_blankである ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%B の`~session履歴$は、次の~entryのみからなる
⇒
`新たな閲覧文脈を作成する$ときに追加された，
`~about_blank$sc `文書$
◎
Let isInitialAboutBlank be false.
◎
If browsingContext's only entry in its session history is the about:blank Document that was added when browsingContext was created, then set isInitialAboutBlank to true.
</li>
	<li>
~IF［
( %作動中の文書の~COOP, %作動中の文書の~navi生成元, %応答~COOP, %応答~生成元 )
は、`非同一-生成元~opener施策として合致する$
］
⇒
~RET ~F
◎
If the result of matching activeDocumentCOOP, activeDocumentNavigationOrigin, responseCOOP and responseOrigin is true, then return false.
</li>
	<li>
<p>
~RET ［
次がすべて満たされるならば ~F ／
~ELSE_ ~T
］：
</p>
		<ul>
			<li>
%初期~about_blankである ~EQ ~T
</li>
			<li>
%作動中の文書の~COOP ~EQ `same-origin-allow-popups$coop
</li>
			<li>
%応答~COOP ~EQ `unsafe-none$coop
</li>
		</ul>
◎
If all of the following are true:
• isInitialAboutBlank
• activeDocumentCOOP is "same-origin-allow-popups".
• responseCOOP is "unsafe-none".
then return false.
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navi応答~用に利用する閲覧文脈を得する@
ときは、所与の
( `閲覧文脈$ %B, `~sandbox法~flag集合$ %~sandbox~flags, `非同一-生成元~opener施策$ %~navi~COOP )
に対し：
◎
To obtain a browsing context to use for a navigation response, given a browsing context browsingContext, a sandboxing flag set sandboxFlags, and a cross-origin opener policy navigationCOOP:
</p>
<ol>
	<li>
~Assert：
%B は`~top-level閲覧文脈$である。
◎
Assert: browsingContext is a top-level browsing context.
</li>
	<li>
%新-閲覧文脈 ~LET `新たな~top-level閲覧文脈を作成する$()
◎
Let newBrowsingContext be the result of creating a new top-level browsing context.
</li>
	<li>
~IF［
%~navi~COOP ~EQ `same-origin-plus-COEP$coop
］
⇒
%新-閲覧文脈 の`~group$tbcGの`非同一-生成元~隔離-済み$bcG ~SET ~T
◎
If navigationCOOP is "same-origin-plus-COEP", then set newBrowsingContext's group's cross-origin isolated to true.
</li>
	<li>
<p>
~IF［
%~sandbox~flags は空でない
］：
◎
If sandboxFlags is not empty, then:
</p>
		<ol>
			<li>
~Assert：
%~navi~COOP ~EQ `unsafe-none$coop
◎
Assert: navigationCOOP is "unsafe-none".
</li>
			<li>
~Assert：
%新-閲覧文脈 の`~popup~sandbox法~flag集合$は`空$である。
◎
Assert: newBrowsingContext's popup sandboxing flag set is empty.
</li>
			<li>
%新-閲覧文脈 の`~popup~sandbox法~flag集合$ ~SET 
`~sandbox法~flag集合$ ~SET %~sandbox~flags を`~cloneする$
◎
Set newBrowsingContext's popup sandboxing flag set to a clone of sandboxFlags.
</li>
		</ol>
	</li>
	<li>
<p>
`閲覧文脈を破棄する$( %B )
◎
Discard browsingContext.
</p>

<p class="note">注記：
これによる %B の`~group$tbcGに対する効果は無いが、当の`閲覧文脈~group$を成す`~top-level閲覧文脈$が %B しかない事例では、~UAは，空になった当の~groupを削除するであろう。
◎
This has no effect on browsingContext's group, unless browsingContext was its sole top-level browsing context. In that case, the user agent might delete the browsing context group which no longer contains any browsing contexts.
</p>
	</li>
	<li>
~RET %新-閲覧文脈
◎
Return newBrowsingContext.
</li>
</ol>

<p class="XXX">
~naviに後続して，閲覧文脈~groupどうしを入れ替えることによる影響iは、全部的に定義されていない。
それは、現時点では
<a href="~HTMLissue/5350">課題 #5350</a>
にて論の最中にある。
◎
The impact of swapping browsing context groups following a navigation is not fully defined. It is currently under discussion in issue #5350.
</p>
</div>

			</section>
		</section>
		<section id="coep">
<h3 title="Cross-origin embedder policies">7.8 非同一-生成元~埋込元~施策</h3>

<p>
`埋込元~施策~値@
は、資源~所有者からの明示的な許可を伴わずに，非同一-生成元~資源の~fetchingを制御する。
そのような値には、次の 2 つがある：
◎
An embedder policy value controls the fetching of cross-origin resources without explicit permission from resource owners. There are two such values:
</p>

<dl class="def-list">
	<dt>`unsafe-none@coep</dt>
	<dd>
これが既定の値。
この値が利用されたときは、非同一-生成元~資源は［
`~CORS~protocol$ ／
`Cross-Origin-Resource-Policy$h ~header
］通して明示的な許可を与えることなく~fetchできるようになる。
◎
This is the default value. When this value is used, cross-origin resources can be fetched without giving explicit permission through the CORS protocol or the `Cross-Origin-Resource-Policy` header.
</dd>

	<dt>`require-corp@coep</dt>
	<dd>
この値が利用されたときは、非同一-生成元~資源を~fetchするときに，~serverによる［
`~CORS~protocol$ ／
`Cross-Origin-Resource-Policy$h ~header
］を通した明示的な許可が要求される。
◎
When this value is used, fetching cross-origin resources requires the server's explicit permission through the CORS protocol or the `Cross-Origin-Resource-Policy` header.
</dd>
</dl>

<p>
`埋込元~施策@
は、次に挙げるものからなる：
◎
An embedder policy consists of:
</p>
<ul>
	<li>
`値@embP
⇒
`埋込元~施策~値$であり，初期~時は `unsafe-none$coep とする。
◎
A value, which is an embedder policy value, initially "unsafe-none".
</li>
	<li>
`報告先@embP
⇒
文字列であり，初期~時は空~文字列とする。
◎
A reporting endpoint string, initially the empty string.
</li>
	<li>
`報告のみの値@embP
⇒
`埋込元~施策~値$であり，
初期~時は `unsafe-none$coep とする。
◎
A report only value, which is an embedder policy value, initially "unsafe-none".
</li>
	<li>
`報告のみの報告先@embP
⇒
文字列であり，初期~時は空~文字列とする。
◎
A report only reporting endpoint string, initially the empty string.
</li>
</ul>

<p>
`~coep報告~種別@i
は、
`coep^l を値とする`報告~種別$であり，`報告用~観測器から可視$であるとする。
◎
The "coep" report type is a report type whose value is "coep". It is visible to ReportingObservers.
</p>

			<section id="the-headers">
<h4 title="The headers">7.8.1 各種~header</h4>

<p>
［
`Cross-Origin-Embedder-Policy$h ／
`Cross-Origin-Embedder-Policy-Report-Only$h
］~HTTP応答~headerは、［
`環境~設定群~obj$用に`埋込元~施策$を宣言すること
］を~serverに許容する。
両~headerとも`有構造~header$であり、その値は `~token$sf でなければナラナイ。
`STRUCTURED-HEADERS$r
◎
The `Cross-Origin-Embedder-Policy` and `Cross-Origin-Embedder-Policy-Report-Only` HTTP response header fields allow a server to declare an embedder policy for an environment settings object. These headers are structured headers whose values must be token. [STRUCTURED-HEADERS]
</p>

<p>
`埋込元~施策~値$が，`~token$sfとして妥当になる。
~tokenは、`~parameters$sfも伴い得る
— それを成す
`report-to@coep
~parameterは、適切な`報告先$を識別する`妥当な~URL文字列$をとり得る。
`REPORTING$r
◎
The valid token values are the embedder policy values. The token may also have attached parameters; of these, the "report-to" parameter can have a valid URL string identifying an appropriate reporting endpoint. [REPORTING]
</p>

<div class="note">
<p>注記：
値を`~token$sfとして構文解析し得ない~headerが在る下では、処理~model（`埋込元~施策を得する$）は，（既定の `unsafe-none$coep になることにより）~openに失敗する【何の？】。
所与の応答~内に複数の `Cross-Origin-Embedder-Policy$h ~headerが在って、不作為に結合され，~listが作成された場合も同様になる：
◎
The processing model fails open (by defaulting to "unsafe-none") in the presence of a header that cannot be parsed as a token. This includes inadvertent lists created by combining multiple instances of the `Cross-Origin-Embedder-Policy` header present in a given response:
</p>

<div>
<table><thead>
<tr><th>`Cross-Origin-Embedder-Policy$h`
<th>最終的な`埋込元~施策~値$
</thead><tbody>

<tr><td>`送達された~headerなし^em
<td>`unsafe-none$coep

<tr><td>`require-corp^bl
<td>`require-corp$coep

<tr><td>`unknown-value^bl
<td>`unsafe-none$coep

<tr><td>`require-corp, unknown-value^bl
<td>`unsafe-none$coep

<tr><td>`unknown-value, unknown-value^bl
<td>`unsafe-none$coep

<tr><td>`unknown-value, require-corp^bl
<td>`unsafe-none$coep

<tr><td>`require-corp, require-corp^bl
<td>`unsafe-none$coep
</tbody></table>

◎
`Cross-Origin-Embedder-Policy`｜Final embedder policy value
No header delivered｜"unsafe-none"
`require-corp`｜"require-corp"
`unknown-value`｜"unsafe-none"
`require-corp, unknown-value`｜"unsafe-none"
`unknown-value, unknown-value`｜"unsafe-none"
`unknown-value, require-corp`｜"unsafe-none"
`require-corp, require-corp`｜"unsafe-none"
</div>

<p>
（同じことは，
`Cross-Origin-Embedder-Policy-Report-Only$h にも適用される。）
◎
(The same applies to `Cross-Origin-Embedder-Policy-Report-Only`.)
</p>
</div>

<hr>

<div class="algo">
<p>
`埋込元~施策を得する@
ときは、所与の
( `応答$ %応答 )
に対し：
◎
To obtain an embedder policy from a response response:
</p>
<ol>
	<li>
%施策 ~LET 新たな`埋込元~施策$
◎
Let policy be a new embedder policy.
</li>
	<li>
%構文解析した~item ~LET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Cross-Origin-Embedder-Policy$h, `~item^i )
◎
Let parsedItem be the result of getting a structured header with `Cross-Origin-Embedder-Policy` and "item".
</li>
	<li>
<p>
~IF［
%構文解析した~item ~NEQ ~NULL【！failure nor null】
］：
</p>
		<ol>
			<li>
%値 ~LET %構文解析した~item の`値$sfI
</li>
			<li>
<p>
~IF［
%値 の型は`~token$sfである【この条件は、この訳による補完】
］~AND［
%値 ~EQ `require-corp^l
］：
</p>
				<ol>
					<li>
%施策 の`値$embP ~SET `require-corp$coep
</li>
					<li>
%報告先 ~LET %構文解析した~item の`~parameters$sfI[ `report-to$coep ]
</li>
					<li>
~IF［
%報告先 ~NEQ ε
］
⇒
%施策 の`報告先$embP ~SET %報告先
</li>
				</ol>
			</li>
		</ol>
◎
If parsedItem is neither failure nor null and parsedItem[0] is "require-corp":
• Set policy's value to "require-corp".
• If parsedItem[1]["report-to"] exists, then set policy's endpoint to parsedItem[1]["report-to"].
</li>
	<li>
%構文解析した~item ~SET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Cross-Origin-Embedder-Policy-Report-Only$h, `~item^i )
◎
Set parsedItem to the result of getting a structured header with `Cross-Origin-Embedder-Policy-Report-Only` and "item".
</li>
	<li>
<p>
~IF［
%構文解析した~item ~NEQ ~NULL【！failure nor null】
］：
</p>
		<ol>
			<li>
%値 ~LET %構文解析した~item の`値$sfI
</li>
			<li>
<p>
~IF［
%値 の型は`~token$sfである【この条件は、この訳による補完】
］~AND［
%値 ~EQ `require-corp^l
］：
</p>
				<ol>
					<li>
%施策 の`報告のみの値$embP ~SET `require-corp$coep
</li>
					<li>
%報告先 ~LET %構文解析した~item の`~parameters$sfI[ `report-to$coep ]
</li>
					<li>
~IF［
%報告先 ~NEQ ε
］
⇒
%施策 の`報告のみの報告先$embP ~SET %報告先
</li>
				</ol>
			</li>
		</ol>
◎
If parsedItem is neither failure nor null and parsedItem[0] is "require-corp":
• Set policy's report only value to "require-corp".
• If parsedItem[1]["report-to"] exists, then set policy's report only reporting endpoint to parsedItem[1]["report-to"].
</li>
	<li>
~RET %施策
◎
Return policy.
</li>
</ol>
</div>

			</section>
			<section id="embedder-policy-checks">
<h4 title="Embedder policy checks">7.8.2 埋込元~施策の検査</h4>

<div class="algo">
<p>
`~navi応答の埋込元~施策に対する固守を検査する@
ときは、所与の
( `応答$ %応答, `閲覧文脈$ %~target )
に対し：
◎
To check a navigation response's adherence to its embedder policy given a response response and a browsing context target:
</p>
<ol>
	<li>
~IF［
%~target は`子~閲覧文脈$でない
］
⇒
~RET ~T
◎
If target is not a child browsing context, then return true.
</li>
	<li>
%応答~施策 ~LET `埋込元~施策を得する$( %応答 )
◎
Let responsePolicy be the result of obtaining an embedder policy from response.
</li>
	<li>
%親~施策 ~LET %~target の`容器~文書$の`埋込元~施策$doc
◎
Let parentPolicy be target's container document's embedder policy.
</li>
	<li>
~IF［
%親~施策 の`報告のみの値$embP ~EQ `require-corp$coep
］~AND［
%応答~施策 の`値$embP ~EQ `unsafe-none$coep
］
⇒
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `navigation^l, %親~施策 の`報告のみの報告先$embP, %~target の`容器~文書$に`関連な設定群~obj$ )
◎
If parentPolicy's report only value is "require-corp" and responsePolicy's value is "unsafe-none", then queue a cross-origin embedder policy inheritance violation with response, "navigation", parentPolicy's report only reporting endpoint, and target's container document's relevant settings object.
</li>
	<li>
~IF［
%親~施策 の`値$embP ~EQ `unsafe-none$coep
］~OR［
%応答~施策 の`値$embP ~EQ `require-corp$coep
］
⇒
~RET ~T
◎
If parentPolicy's value is "unsafe-none" or responsePolicy's value is "require-corp", then return true.
</li>
	<li>
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `navigation^l, %親~施策 の`報告先$embP, %~target の`容器~文書$に`関連な設定群~obj$ )
◎
Queue a cross-origin embedder policy inheritance violation with response, "navigation", parentPolicy's reporting endpoint, and target's container document's relevant settings object.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`大域~objの埋込元~施策を検査する@
ときは、所与の
( `WorkerGlobalScope$I %~worker大域~scope, `環境~設定群~obj$ %所有者, `応答$ %応答 )
に対し：
◎
To check a global object's embedder policy given a WorkerGlobalScope workerGlobalScope, an environment settings object owner, and a response response:
</p>
<ol>
	<li>
~IF［
%~worker大域~scope は `DedicatedWorkerGlobalScope$I ~objでない
］
⇒
~RET ~T
◎
If workerGlobalScope is not a DedicatedWorkerGlobalScope object, then return true.
</li>
	<li>
%施策 ~LET %~worker大域~scope の`埋込元~施策$wG
◎
Let policy be workerGlobalScope's embedder policy.
</li>
	<li>
%所有者~施策 ~LET %所有者 の`埋込元~施策$enV
◎
Let ownerPolicy be owner's embedder policy.
</li>
	<li>
~IF［
%所有者~施策 の`報告のみの値$embP ~EQ `require-corp$coep
］~AND［
%施策 の`値$embP ~EQ `unsafe-none$coep
］
⇒
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `worker initialization^l, %所有者の施策 の`報告のみの報告先$embP, %所有者 )
◎
If ownerPolicy's report only value is "require-corp" and policy's value is "unsafe-none", then queue a cross-origin embedder policy inheritance violation with response, "worker initialization", owner's policy's report only reporting endpoint, and owner.
</li>
	<li>
~IF［
%所有者~施策 の`値$embP ~EQ `unsafe-none$coep
］~OR［
%施策 の`値$embP ~EQ `require-corp$coep
］
⇒
~RET ~T
◎
If ownerPolicy's value is "unsafe-none" or policy's value is "require-corp", then return true.
</li>
	<li>
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `worker initialization^l, %所有者の施策 の`報告先$embP, %所有者 )
◎
Queue a cross-origin embedder policy inheritance violation with response, "worker initialization", owner's policy's reporting endpoint, and owner.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`非同一-生成元~埋込元~施策の継承~違反を~queueする@
ときは、所与の
( `応答$ %応答, 文字列 %種別, 文字列 %報告先, `環境~設定群~obj$ %設定群 )
に対し：
◎
To queue a cross-origin embedder policy inheritance violation given a response response, a string type, a string endpoint, and an environment settings object settings:
</p>
<ol>
	<li>
%直列形 ~LET `応答~URLを報告-用に直列化する$( %応答 )
◎
Let serialized be the result of serializing a response URL for reporting with response.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含する新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
</thead><tbody>

<tr><td>`type^c
<td>%種別
<tr><td>`blocked-url^c
<td>%直列形
</tbody></table>

◎
Let body be a new object containing the following properties:
key	value
type	type
blocked-url	serialized
</li>
	<li>
`報告を~queueする$( %本体, `~coep報告~種別$i, %報告先, %設定群 )
◎
Queue body as the "coep" report type for endpoint on settings.
</li>
</ol>
</div>

			</section>
		</section>
</main>
