<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Origin, Sandboxing（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<style>

@supports (display: grid) and (display: contents) {

._compare-origin {
	max-width: 28em;
}

._compare-origin tr {
	grid-template-areas:
		"A A"
		"B B"
		"同一 同じ"
	;
	grid-template-columns: 1fr 1fr;
}

._compare-origin tr > *:nth-child(1) {
	grid-area: A;
	white-space: nowrap;
}

._compare-origin tr > *:nth-child(2) {
	grid-area: B;
	white-space: nowrap;
}

._compare-origin tr > *:nth-child(3) {
	grid-area: 同一;
}

._compare-origin tr > *:nth-child(4) {
	grid-area: 同じ;
}

}

</style>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'coop':
case 'coep':
case 'l':
case 'coI':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sbox': // sandboxing flags
	text = `閲覧文脈~sandbox化( ${key} )~flag`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'sf': // structured fields
	text = `<sub>sf-</sub>${text}`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2021-05-06
trans_update:2021-05-07
source_checked:201119
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/origin.html
site_nav:browsers,security,html
nav_prev:WINDOW
nav_next:HISTORY
trans_1st_pub:2016-07-12


●●class_map
e:element
a:attr
et:event-type
E:error
U:code-point
sl:js-slot
v:value
h:header
sc:scheme

●●tag_map
I:code
m:code
c:code
e:code
a:code
et:code
E:code
sl:span
U:span
v:code
h:code
sc:code
i:i
em:em
cite:cite
sub:sub

●●words_table

database::::データベース
iframe:
	unfortunate

	●仕様
アタられ:consultされ:あたられ
採用-:adopt:~
基礎的な:fundamental:~
自明:trivial:~
不作為:inadvertent:~
固守:adherence:~
任意選択する:opt-inする:任意で選ぶ
無条件:unconditional:~

	-:substeps
	~~協調する:if they do the same thing
	なり得る:potentially
	にもかかわらず:nonetheless
	加えて:Furthermore
	様々な程度:varying degrees
	広く:widely
	方が好ましい:in favor of
	何もかも:everything
	舞台裏:behind the scenes
	〜としては:In terms of
	一方で 〜 ~~力点が置かれる:since 〜 more about
	結果に至る:can cause 〜 end up
	により:by means of
	それに加え:with the addition that
	より多くの自由度:in the order of 〜 more freedom

	●network／保安
IPv4:
IPv6:
IP:
COOP:
	coop:COOP
COEP:
	coep:COEP
下位domain:subdomain:::下位ドメイン
navigator::::ナビゲータ
権限:authority:~
強制d:forced:強制
公共:public::~
逃れる:escapeする:~
flags:::flag 群:フラグ群
報告先:reporting endpoint::~
報告用:reporting::~
陥穽:pitfall:落とし穴
蝕む:undermineする:~
処置:disposition::~
施行n:enforcement:施行
無毒化-:sanitize::~
username::::ユーザ名
password::::パスワード

	信用できない:untrusted
	CORS-cross-origin
	CORS-same-origin
	~secure化-:secured
	ひどいことに:acute
	緩い／緩め方／緩めよ:relax

	●環境 ／ 閲覧
agent:
surrounding:
補助:auxiliary::~
成分組:tuple:~
閉じる:closeする::~
	閉じるとき:closing
開く:openする::~
開いた:openした::~
	-:back
埋込元:embedder::埋め込み元
opener:::open 元
openee:::open 先
accessed:::access 先
accessor:::access 元
open:
closed:
切替n:switch:切り替え
scope::::スコープ
process::::プロセス
履歴上の:historicalな:~
virtual:

	生成元を~keyに:origin-keyed


	●UI
modal::::モーダル
popup:
再生-:play:~
一過:transient::~

	around
	Control key
	~scroll用:scrolling
	~tab付き:tabbed

	●構文
分割-:split:~
接頭-:prefix:~

	過ぎない:past
	-:頭部の

	●一般処理
動作者:actor:~
書込む:writeする:書き込む
同等:equal:~
同等性:equality:~
和集合:union::~
割振る:allocateする::割り振る
割振り:allocation::割り振り
作成元の:creator::~
作成時の:creation::~
実効:effective:~
params::::パラメタ群

	●未分類
blob:
出自の:originating:~
通貨:currency:~
行番号:line number::~
列番号:column number::~
列挙値:enum::~
	getting
	-:common
	種類:

	報告のみの:report-only
	空になった:which no longer contains any browsing contexts
	~~投出:raise
	変異しない:immutable
	対応付け:map
	~~述べ
	-:prefixed
	選ばれ
	選ぶ:choose する
	meant
	said
	~instance化-:instantiate
	:exactly
	連結-
	hosting
	非:non
	:per
	point
	それまでの文書:predecessor
	占める:occupy
	現れる:appearする
	後続-:follow
	伴い得る:attached
	最終的な:final
	以前に読込まれ:previously-load
	~web~site:website

	●変数
	%A
	%B
	%B:browsingContext
	%~URL:url
	%hostA
	%hostB
	%oA:originA
	%oB:originB
	%report-to:-
	%~COOP応答は~navi~sourceか:isCOOPResponseNavigationSource
	%~accessedと~accessorの関係性:%~accessedと~accessorの関係性
	%~accessedの~COOP:accessedCOOP
	%~accessedの~URL:accessedURL
	%~accessedの~referrer:accessedReferrer
	%~accessedの~top-level閲覧文脈:-
	%~accessedの作成元の生成元:accessedCreatorOrigin
	%~accessedと先祖たち:-
	%~accessedの初期~URL:accessedInitialURL
	%~accessedの生成元:accessedOrigin
	%~accessorの~COOP:accessorCOOP
	%~accessorの~URL:accessorURL
	%~accessorの~referrer:accessorReferrer
	%~accessorの~top-level閲覧文脈:-
	%~accessorの作成元の生成元:accessorCreatorOrigin
	%~accessorと先祖たち:-
	%~accessorの初期~URL:accessorInitialURL
	%~accessorの生成元:accessorOrigin
	%~COEP:coep
	%~COOP~URL:coopURL
	%~COOP値:coopValue
	%~COOP施行n結果:coopEnforcementResult
	%~COOP生成元:coopOrigin
	%~domain
	%~host:host
	%~host接尾辞~文字列:hostSuffixString
	%~item:value[0]
	%~navi~COOP:navigationCOOP
	%~openerの~URL:openerURL
	%~openerの初期~生成元:openerInitialOrigin
	%~openerの生成元:openerOrigin
	%~openした~windowの~URL:openedWindowURL
	%~openした~windowの生成元:openedWindowOrigin
	%~prop名:propertyName
	%~sandbox~flags:sandboxFlags
	%~source~file:sourceFile
	%~target
	%~tokenたち:tokens
	%~worker大域~scope:workerGlobalScope
	%予約-済み環境:reservedEnvironment
	%他の~URL:otherURL
	%他の生成元:otherOrigin
	%作動中の文書の~COOP:activeDocumentCOOP
	%作動中の文書の~COOP値:activeDocumentCOOPValue
	%作動中の文書の~navi生成元:activeDocumentNavigationOrigin
	%作動中の文書の報告のみの~COOP:activeDocumentCOOPReportOnly
	%値:-
	%元の~host:originalHost
	%入力:input
	%処置:disposition
	%出力:output
	%列番号:columnNumber
	%初期~about_blankか:isInitialAboutBlank
	%初期~about_blankである:isInitialAboutBlank
	%初期~window~URL:initialWindowURL,
	%以前の応答の~URL:previousResponseURL
	%以前の応答の生成元:previousResponseOrigin
	%埋込元:embedder
	%報告先:-
	%報告先:endpoint
	%実効~domain:effectiveDomain
	%応答:response
	%応答~COOP:responseCOOP
	%応答~URL:responseURL
	%応答~施策:responsePolicy
	%応答~生成元:responseOrigin
	%応答の~COOP:responseCOOP
	%応答の~COOP値:responseCOOPValue
	%所有者:owner
	%所有者~施策:ownerPolicy
	%新たな~COOP施行n結果:newCOOPEnforcementResult
	%新たな閲覧文脈:newBrowsingContext
	%施策:policy
	%本体:body
	%構文解析した~item:parsedItem
	%以後の応答の~URL:nextResponseURL
	%以後の応答の生成元:nextResponseOrigin
	%無毒化した~URL:sanitizedURL
	%現在の~COOP施行n結果:currentCOOPEnforcementResult
	%環境:environment
	%生成元:origin
	%直列化した~URL:serialized
	%直列化した~referrer:serializedReferrer
	%種別:type
	%結果:result
	%行番号:lineNumber
	%親~施策:parentPolicy
	-:coep
	-:securityState
	%施策~容器:policyContainer
	%履歴~施策~容器:historyPolicyContainer
	%起動元~施策~容器:initiatorPolicyContainer
	%親~施策~容器:parentPolicyContainer
	%応答~施策~容器:~responsePolicyContainer

	●指示語
	尾部:end
	:these
	:such as
	-:next
	以前の:previous
	以後の:next


●●original_id_map


●●words_table1

HTMLWPROXY:HTML-windowproxy-ja.html
document-domain:<code>document.domain</code> 
about_blank:about:blank
about_srcdoc:about:srcdoc

●●link_map



	●IDL
I.Document:~HTMLdom#document
	I.Window:~WINDOW#window → ~window
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.WorkletGlobalScope:~WORKLETS#workletglobalscope
I.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
I.MessageChannel:~HTMLcomms#messagechannel

E.SecurityError:~WEBIDL#securityerror

m.document.domain:#dom-document-domain
m.domain:#dom-document-domain
m.localStorage:~WEBSTORAGE#dom-localstorage
m.originAgentCluster:#dom-originagentcluster
m.crossOriginIsolated:~HTMLGAPI#dom-crossoriginisolated

m.window.alert:~HTMLGAPI#dom-window-alert
m.window.confirm:~HTMLGAPI#dom-window-confirm
m.window.print:~HTMLGAPI#dom-window-print
m.window.prompt:~HTMLGAPI#dom-window-prompt
m.window.open:~WINDOW#dom-window-open
m.postMessage:~HTMLcomms#dom-window-postmessage

	●event
et.beforeunload:~HTMLindex#event-beforeunload

	●要素
e.iframe:~HEembed#the-iframe-element

	●内容属性
a.sandbox:~HEembed#attr-iframe-sandbox
a.target:~HTMLlinks#attr-hyperlink-target

	●code
	m.onclick

c.WebAssembly.Module:https://webassembly.github.io/spec/js-api/#module

l.document-domain:~HTMLINFRA#document-domain-feature

coI.none:~BROWSERS#cross-origin-isolation-none
coI.logical:~BROWSERS#cross-origin-isolation-logical
coI.concrete:~BROWSERS#cross-origin-isolation-concrete

	●閲覧文脈
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
閲覧文脈:~BROWSERS#browsing-context
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
開いた閲覧文脈:~BROWSERS#opener-browsing-context
子~閲覧文脈:~BROWSERS#child-browsing-context
閲覧文脈を選ぶ規則:~BROWSERS#the-rules-for-choosing-a-browsing-context-given-a-browsing-context-name
作動中の文書:~BROWSERS#active-document
属する閲覧文脈:~BROWSERS#concept-document-bc
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
bc.初期~URL:~BROWSERS#browsing-context-initial-url
bc.~virtual閲覧文脈~group~ID:~BROWSERS#virtual-browsing-context-group-id
bc.容器:~BROWSERS#bc-container
bc.作成時の~opener生成元:~BROWSERS#opener-origin-at-creation
容器~文書:~BROWSERS#bc-container-document
補助~閲覧文脈:~BROWSERS#auxiliary-browsing-context
作動中の~window:~BROWSERS#active-window
新たな~top-level閲覧文脈を作成する:~BROWSERS#creating-a-new-top-level-browsing-context
tbcG.~group:~BROWSERS#tlbc-group
閲覧文脈~group:~BROWSERS#browsing-context-group
bcG.閲覧文脈~集合:~BROWSERS#browsing-context-set
bcG.非同一-生成元~隔離~mode:~BROWSERS#bcg-cross-origin-isolation
bcG.履歴上の~agent~cluster~key~map:~BROWSERS#historical-agent-cluster-key-map

非同一-生成元~隔離~mode:~BROWSERS#cross-origin-isolation-mode

非同一-生成元から~access可能な~window~prop名:~HTMLWPROXY#cross-origin-accessible-window-property-name

閲覧文脈を破棄する:~WINDOW#a-browsing-context-is-discarded

	●生成元／sandbox（origin.html
	§:#origin
	§:#sandboxing
	§:#relaxing-the-same-origin-restriction
	:#origin-2
	:#unicode-serialisation-of-an-origin
	:~HTMLforms#sandboxSubmitBlocked
	:~HEmedia#attr-media-autoplay
	:~HTMLinteraction#attr-fe-autofocus
	:~NAVI#sandboxPluginNavigate
	:~WAPI#sandboxScriptBlocked
	:~HEembed#sandboxPluginEmbed
	:~HEembed#sandboxPluginObject

生成元:#concept-origin
不透明な生成元:#concept-origin-opaque
成分組~生成元:#concept-origin-tuple
o.~scheme:#concept-origin-scheme
o.~host:#concept-origin-host
o.~port:#concept-origin-port
o.~domain:#concept-origin-domain
実効~domain:#concept-origin-effective-domain
生成元を直列化する:#ascii-serialisation-of-an-origin
o.直列化:#ascii-serialisation-of-an-origin
同一-生成元:#same-origin
sub.生成元:#same-origin
同じ生成元~domain:#same-origin-domain
同じ~site:#same-site
~scheme無しで同じ~site:#schemelessly-same-site

~scheme＆~host:#scheme-and-host
~site:#site
~siteを得する:#obtain-a-site

登録-可能な~domain接尾辞または同等:#is-a-registrable-domain-suffix-of-or-is-equal-to


v.allow-popups:#attr-iframe-sandbox-allow-popups
v.allow-top-navigation:#attr-iframe-sandbox-allow-top-navigation
v.allow-top-navigation-by-user-activation:#attr-iframe-sandbox-allow-top-navigation-by-user-activation
v.allow-same-origin:#attr-iframe-sandbox-allow-same-origin
v.allow-forms:#attr-iframe-sandbox-allow-forms
v.allow-pointer-lock:#attr-iframe-sandbox-allow-pointer-lock
v.allow-scripts:#attr-iframe-sandbox-allow-scripts
v.allow-popups-to-escape-sandbox:#attr-iframe-sandbox-allow-popups-to-escape-sandbox
v.allow-modals:#attr-iframe-sandbox-allow-modals
v.allow-orientation-lock:#attr-iframe-sandbox-allow-orientation-lock
v.allow-presentation:#attr-iframe-sandbox-allow-presentation
v.allow-downloads:#attr-iframe-sandbox-allow-downloads

~sandbox法~flag集合:#sandboxing-flag-set
bc.~sandbox法~flags:#concept-bc-sandboxing-flags
作動中の~sandbox法~flag集合:#active-sandboxing-flag-set
強制d~sandbox法~flag集合:#forced-sandboxing-flag-set
~popup~sandbox法~flag集合:#popup-sandboxing-flag-set
~iframe~sandbox法~flag集合:#iframe-sandboxing-flag-set

sbox.~document-domain:#sandboxed-document.domain-browsing-context-flag
sbox.~form:#sandboxed-forms-browsing-context-flag
sbox.~navi:#sandboxed-navigation-browsing-context-flag
許可-済み~navigator:#one-permitted-sandboxed-navigator
sbox.~plugin:#sandboxed-plugins-browsing-context-flag
sbox.~pointer~lock:#sandboxed-pointer-lock-browsing-context-flag
sbox.~script:#sandboxed-scripts-browsing-context-flag
sbox.非~利用者~作動化~top-level~navi:#sandboxed-top-level-navigation-without-user-activation-browsing-context-flag
sbox.利用者~作動化~top-level~navi:#sandboxed-top-level-navigation-with-user-activation-browsing-context-flag
sbox.生成元:#sandboxed-origin-browsing-context-flag
sbox.自動的な特能:#sandboxed-automatic-features-browsing-context-flag
sbox.補助~navi:#sandboxed-auxiliary-navigation-browsing-context-flag
sbox.方位~lock:#sandboxed-orientation-lock-browsing-context-flag
sbox.呈示:#sandboxed-presentation-browsing-context-flag
sbox.~download:#sandboxed-downloads-browsing-context-flag

~sandboxは補助~閲覧文脈に伝播する~flag:#sandbox-propagates-to-auxiliary-browsing-contexts-flag
~sandbox化( ~modal )~flag:#sandboxed-modals-flag
作成時の~sandbox法~flagsを決定する:#determining-the-creation-sandboxing-flags
~sandbox法~指令を構文解析する:#parse-a-sandboxing-directive


	●COOP／COEP

coop.report-to:#coop-report-to
coop.same-origin-allow-popups:#coop-same-origin-allow-popups
coop.same-origin:#coop-same-origin
coop.same-origin-plus-COEP:#coop-same-origin-plus-coep
coop.unsafe-none:#coop-unsafe-none

coep.report-to:#coep-report-to
coep.require-corp:#coep-require-corp
coep.unsafe-none:#coep-unsafe-none

h.Cross-Origin-Opener-Policy:~HTMLiana#cross-origin-opener-policy-2
h.Cross-Origin-Opener-Policy-Report-Only:~HTMLiana#cross-origin-opener-policy-report-only
h.Cross-Origin-Embedder-Policy:~HTMLiana#cross-origin-embedder-policy
h.Cross-Origin-Embedder-Policy-Report-Only:~HTMLiana#cross-origin-embedder-policy-report-only
h.Cross-Origin-Resource-Policy:~FETCH#http-cross-origin-resource-policy
h.Origin-Agent-Cluster:~HTMLiana#origin-agent-cluster

~navi応答~用に利用する閲覧文脈を得する:#obtain-browsing-context-navigation
非同一-生成元~opener施策:#cross-origin-opener-policy
非同一-生成元~opener施策を得する:#obtain-coop
非同一-生成元~opener施策の施行n結果:#coop-enforcement-result
非同一-生成元~opener施策~値:#cross-origin-opener-policy-value
非同一-生成元~opener施策~値として合致する:#matching-coop
応答の非同一-生成元~opener施策を施行する:#coop-enforce

cooP.閲覧文脈~groupの切替nは必要か:#coop-enforcement-bcg-switch
cooP.報告のみに因る閲覧文脈~groupの切替nは必要か:#coop-enforcement-bcg-switch-report-only
cooP.非同一-生成元~opener施策:#coop-enforcement-coop
cooP.生成元:#coop-enforcement-origin
cooP.~url:#coop-enforcement-url
cooP.現在の文脈は~navi~sourceか:#coop-enforcement-source

文書:~HTMLdom#the-document-object
doc.非同一-生成元~opener施策:~HTMLdom#concept-document-coop
doc.埋込元~施策:~HTMLdom#concept-document-embedder-policy
doc.~referrer:~HTMLdom#the-document's-referrer
	doc.~referrer:~HTMLdom#dom-document-referrer
doc.~URL:~DOM4#concept-document-url
doc.生成元:~DOM4#concept-document-origin
まだ初期~about_blank 文書である:~HTMLdom#still-on-its-initial-about:blank-document

有構造~field値を取得する:~FETCH#concept-header-list-get-structured-header
局所的な~URL:~FETCH#is-local
応答~URLを報告-用に直列化する:~FETCH#serialize-a-response-url-for-reporting
応答:~FETCH#concept-response
rs.~URL:~FETCH#concept-response-url
rs.~header~list:~FETCH#concept-response-header-list
~CORS~protocol:~FETCH#http-cors-protocol
rq.~referrer:~FETCH#concept-request-referrer


埋込元~施策:#embedder-policy
埋込元~施策を得する:#obtain-an-embedder-policy
埋込元~施策~値:#embedder-policy-value
embP.値:#embedder-policy-value-2
embP.報告先:#embedder-policy-reporting-endpoint
embP.報告のみの値:#embedder-policy-report-only-value
embP.報告のみの報告先:#embedder-policy-report-only-reporting-endpoint

i.~COEP報告~種別:#coep-report-type

大域~objの埋込元~施策を検査する:#check-a-global-object's-embedder-policy
~navi応答の埋込元~施策に対する固守を検査する:#check-a-navigation-response's-adherence-to-its-embedder-policy
非同一-生成元~埋込元~施策の継承~違反を~queueする:#queue-a-cross-origin-embedder-policy-inheritance-violation


	■報告

coOP.報告先:#coop-struct-report-endpoint
coOP.報告のみの報告先:#coop-struct-report-only-endpoint
coOP.報告のみの値:#coop-struct-report-only-value
coOP.値:#coop-struct-value

~accessedと~accessorの関係性:#accessor-accessed-relationship
i.~~無関係:#accessor-accessed-none
i.~accessorは~openee:#accessor-accessed-openee
i.~accessorは~opener:#accessor-accessed-opener

報告のみの~COOPの施行-法は閲覧文脈~groupの切替nを要求するかどうか検査する:#check-bcg-switch-navigation-report-only
~COOP値は閲覧文脈~groupの切替nを要求するかどうか検査する:#check-browsing-context-group-switch-coop-value
閲覧文脈どうしの~accessは報告されるべきかどうか検査する:#coop-check-access-report
~openした~windowからの~access用に違反~報告を~queueする:#coop-violation-access-from-opened
~openerからの~access用に違反~報告を~queueする:#coop-violation-access-from-opener
~openerへの~access用に違反~報告を~queueする:#coop-violation-access-to-opener
別の~windowからの~access用に違反~報告を~queueする:#coop-violation-access-from-other
別の~windowへの~access用に違反~報告を~queueする:#coop-violation-access-to-other
~openした~windowへの~access用に違反~報告を~queueする:#coop-violation-access-to-opened
各種~access用に違反~報告を~queueする:#coop-violation-access
~COOP応答から~navigateして去るときの閲覧文脈~groupの切替n用に違反~報告を~queueする:#coop-violation-navigation-from
~COOP応答へ~navigateするときの閲覧文脈~groupの切替n用に違反~報告を~queueする:#coop-violation-navigation-to
報告~内に送信する~URLを無毒化する:#sanitize-url-report

有構造~header:~HEADER-STRUCTURE#structured-header
	有構造~header:~HEADER-STRUCTURE
sf.真偽値:~HEADER-STRUCTURE#sf-boolean
sf.~token:~HEADER-STRUCTURE#sf-token
sf.文字列:~HEADER-STRUCTURE#sf-string
sf.~parameters:~HEADER-STRUCTURE#sf-parameters
sf.~item:~HEADER-STRUCTURE#sf-item
sfI.値:~HEADER-STRUCTURE#sf-item
sfI.~parameters:~HEADER-STRUCTURE#sf-item

	●施策~容器
施策~容器:#policy-container
pC.~CSP~list:#policy-container-csp-list
施策~容器を~cloneする:#clone-a-policy-container
~URLは履歴~内に施策~容器を格納するよう要求するか？:#requires-storing-the-policy-container-in-history
~fetch応答から施策~容器を作成する:#creating-a-policy-container-from-a-fetch-response
~navi~paramsの施策~容器を決定する:#determining-navigation-params-policy-container
~worker大域~scopeの施策~容器を初期化する:#initialize-worker-policy-container

	●用語 HTML
~plugin:~HTMLINFRA#plugin
~secure化でき:~HTMLINFRA#concept-plugin-secure

sc.~about_srcdoc:~HTMLurl#about:srcdoc

~navi:~NAVI#navigate
~navigate応答を処理する:~NAVI#process-a-navigate-response
文書を作成して初期化する:~NAVI#initialise-the-document-object

~window:~WINDOW#the-window-object

環境:~WAPI#environment
enV.施策~容器:~WAPI#concept-settings-object-policy-container
enV.埋込元~施策:~WAPI#concept-settings-object-embedder-policy
enV.~secureな文脈:~WAPI#secure-context
	非~secureな文脈:~WAPI#non-secure-context
環境~設定群~obj:~WAPI#environment-settings-object
関連な設定群~obj:~WAPI#relevant-settings-object
agC.非同一-生成元~隔離~mode:~WAPI#agent-cluster-cross-origin-isolation
生成元を~keyにするか:~WAPI#is-origin-keyed
~agent~cluster~key:~WAPI#agent-cluster-key
~keyに:~WAPI#agent-cluster-key

利用は許容されて:~HEembed#allowed-to-use

一過な作動化？:~HTMLinteraction#transient-activation

~hyperlinkを~downloadする:~HTMLlinks#downloading-hyperlinks
~downloadとして:~HTMLlinks#as-a-download

wG.施策~容器:~WORKERS#concept-workerglobalscope-policy-container
wG.埋込元~施策:~WORKERS#concept-workerglobalscope-embedder-policy
wG.~url:~WORKERS#concept-workerglobalscope-url
wG.所有者~集合:~WORKERS#concept-WorkerGlobalScope-owner-set

	●用語（外部
実装定義:~INFRA#implementation-defined

~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
~tuple:~INFRA#tuple
空:~INFRA#list-is-empty
~size:~INFRA#list-size
~cloneする:~INFRA#list-clone
和集合:~INFRA#set-union
集合:~INFRA#ordered-set
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item

	●URL1
~URL:~URL1#concept-url
妥当な~URL文字列:~URL1#valid-url-string
同等な~host:~URL1#concept-host-equals
~URLを直列化する:~URL1#concept-url-serializer
i.素片は除外する:~URL1#url-serializer-exclude-fragment
~hostを直列化する:~URL1#concept-host-serializer
~host構文解析器:~URL1#concept-host-parser
~URLの~usernameを設定する:~URL1#set-the-username
~URLの~passwordを設定する:~URL1#set-the-password

~host:~URL1#concept-host
url.~domain:~URL1#concept-domain
url.~host:~URL1#concept-url-host
url.~port:~URL1#concept-url-port
url.~scheme:~URL1#concept-url-scheme
url.~blob~URL~entry:~URL1#concept-url-blob-entry
~IPv4~address:~URL1#concept-ipv4
~IPv6~address:~URL1#concept-ipv6
整数を直列化する:~URL1#serialize-an-integer
公共~接尾辞:~URL1#host-public-suffix
登録-可能な~domain:~URL1#host-registrable-domain

~agent~cluster:~TC39#sec-agent-clusters
~surrounding~agent:~TC39#surrounding-agent

~node文書:~DOM4#concept-node-document

報告を~queueする:~REPORTING#reporting-queue
	~REPORTING#queue-report
報告~種別:~REPORTING#report-type
報告用~観測器から可視:~REPORTING#visible-to-reportingobservers
報告先:~REPORTING#endpoint

~CSP~list:~CSP3#csp-list
応答の~CSPを構文解析する:~CSP3#parse-response-csp

bU.環境:~FILEAPI#blob-url-entry-environment


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ Origin, § Sandboxing</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>生成元, サンドボックス法 — Origin, Sandboxing</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ε, コレ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="origin">
<h3 title="Origin">7.5. 生成元</h3>

<p>
<ruby>生成元<rt>せいせいもと</rt></ruby>（ `origin^en ）は、~webの~security~modelにおける基礎的な通貨である。
~web~platformにおける，ある生成元を共有する動作者たちは、互いを信用し，同じ権限を有するものと見做される。
互いの生成元が相違する動作者たちは、敵対的になり得るものと見なされ，様々な程度で互いに隔離される。
◎
Origins are the fundamental currency of the web's security model. Two actors in the web platform that share an origin are assumed to trust each other and to have the same authority. Actors with differing origins are considered potentially hostile versus each other, and are isolated from each other to varying degrees.
</p>

<p class="example">
例えば
`bank.example.com^c
にて~hostされている X 銀行の~web~siteが
`charity.example.org^c
にて~hostされている Y 事業体の~web~siteの~DOMを精査しようと試行した場合、
`SecurityError$E 例外が~~投出されることになる。
◎
For example, if Example Bank's web site, hosted at bank.example.com, tries to examine the DOM of Example Charity's web site, hosted at charity.example.org, a "SecurityError" DOMException will be raised.
</p>

<p class="trans-note">【
“~~生成元” という訳語は、おそらく，~HTTP用語
<a href="~HTTPinfra#generate">~~生成する</a>
（ `generate^en ）に由来する
— より詳細には、~HTTP要請に対し
<a href="~HTTPinfra#origin-server">応答を生成した~server</a>
（ `origin server^en ）（を識別する情報）を指す。
したがって， “~~生成元” の “~~元” の読みは、
`original^en（ “~~元の” ）を意味する “もと” であり， “げん” ではない。
】</p>

<hr>

<p id="origin-2">
`生成元@
（ `origin^en ）は、次のいずれかとして与えられる：
◎
An origin is one of the following:
</p>

<dl class="def-list">
	<dt>
`不透明な生成元@
◎
An opaque origin
</dt>
	<dd>
直列化して再度~作成し直せないような，内部的な値であって（`生成元を直列化する$ときは `null^l に直列化される）、有意義な演算は，同等性を~testすることに限られる。
◎
An internal value, with no serialization it can be recreated from (it is serialized as "null" per serialization of an origin), for which the only meaningful operation is testing for equality.
</dd>

	<dt>
`成分組~生成元@
◎
A tuple origin
</dt>
	<dd>
<p>
次のものからなる（括弧内はとり得る値）：
◎
A tuple consists of:
</p>
		<ul>
			<li>
`~scheme@o
（ `~scheme$url ）
◎
A scheme (a scheme).
</li>
			<li>
`~host@o
（ `~host$url ）
◎
A host (a host).
</li>
			<li>
`~port@o
（ `~port$url ）
◎
A port (a port).
</li>
			<li>
`~domain@o
（ ~NULL または `~domain$url ）。
他が言明されない限り， ~NULL とする。
◎
A domain (null or a domain). Null unless stated otherwise.
</li>
		</ul>

<p class="note">注記：
`生成元$は共有され得る
— 例えば、複数の`文書$間で。
加えて、`生成元$は，一般に変異しない。
`成分組~生成元$の`~domain$oに限り，それも
`document.domain$m ~APIを通してのみ，変更され得る。
◎
Origins can be shared, e.g., among multiple Document objects. Furthermore, origins are generally immutable. Only the domain of a tuple origin can be changed, and only through the document.domain API.
</p>
	</dd>
</dl>

<div class="algo">
<p>
`生成元$ %生成元 の
`実効~domain@
は、次に従って算出される：
◎
The effective domain of an origin origin is computed as follows:
</p>

<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET ~NULL
◎
If origin is an opaque origin, then return null.
</li>
	<li>
~IF［
%生成元 の`~domain$o ~NEQ ~NULL
］
⇒
~RET %生成元 の`~domain$o
◎
If origin's domain is non-null, then return origin's domain.
</li>
	<li>
~RET %生成元 の`~host$o
◎
Return origin's host.
</li>
</ol>
</div>

<div class="algo">
<p>
`生成元を直列化する@
ときは、所与の
( `生成元$ %生成元 )
に対し，次を適用して得される文字列を返す：
◎
The serialization of an origin is the string obtained by applying the following algorithm to the given origin origin:
</p>
<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET `null^l
◎
If origin is an opaque origin, then return "null".
</li>
	<li>
%結果 ~LET 次を順に連結した結果
⇒＃
%生成元 の`~scheme$o,
`://^l,
`~hostを直列化する$( %生成元 の`~host$o )
◎
Otherwise, let result be origin's scheme.
◎
Append "://" to result.
◎
Append origin's host, serialized, to result.
</li>
	<li>
~IF［
%生成元 の`~port$o ~EQ ~NULL
］
⇒
~RET %結果
◎
↓</li>
	<li>
~RET 次を順に連結した結果
⇒＃
%結果,
`003A^U `:^smb,
`整数を直列化する$( %生成元 の`~port$o )
◎
If origin's port is non-null, append a U+003A COLON character (:), and origin's port, serialized, to result.
◎
Return result.
</li>
</ol>
</div>

<p class="example">
`成分組~生成元$
( `https^l, `xn--maraa-rta.example^l, ~NULL, ~NULL ) 
の`直列化$oは、
`https://xn--maraa-rta.example^l
になる。
◎
The serialization of ("https", "xn--maraa-rta.example", null, null) is "https://xn--maraa-rta.example".
</p>

<p id="unicode-serialisation-of-an-origin" class="note">注記：
`生成元の~Unicode直列化^i も利用されていたが、それが広く採用されたことは，決してない。
◎
There used to also be a Unicode serialization of an origin. However, it was never widely adopted.
</p>

<hr>

<p>
2 つの`生成元$ %A, %B が
`同一-生成元@
であるとは、次のいずれかを満たすことをいう：
◎
Two origins, A and B, are said to be same origin if the following algorithm returns true:
</p>
<ul>
	<li>
［
%A, %B とも`不透明な生成元$である
］~AND［
%A ~EQ %B
］
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
［
%A, %B とも`成分組~生成元$である
］~AND［
%A, %B の ( `~scheme$o, `~host$o, `~port$o ) は各~成分ごとに一致する
］
◎
If A and B are both tuple origins and their schemes, hosts, and port are identical, then return true.
◎
Return false.
</li>
</ul>

<p>
これは、次のように表記されることもある【この表記法は、この訳に特有】
⇒＃
%A ~EQ`生成元$sub %B
（ ~NEQ`生成元$sub は、その否定を表す）
</p>

<p>
2 つの`生成元$ %A, %B が
`同じ生成元~domain@
であるとは、次のいずれかを満たすことをいう：
◎
Two origins, A and B, are said to be same origin-domain if the following algorithm returns true:
</p>

<ul>
	<li>
［
%A, %B とも`不透明な生成元$である
］~AND［
%A ~EQ %B
］
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
<p>
［
%A, %B とも`成分組~生成元$である
］~AND［
%A, %B は次のいずれかを満たす
］：
</p>
		<ul>
			<li>
［
%A の`~domain$o ~EQ %B の`~domain$o ~NEQ ~NULL
］~AND［
%A の`~scheme$o ~EQ %B の`~scheme$o
］
</li>
			<li>
［
%A の`~domain$o ~EQ %B の`~domain$o ~EQ ~NULL
］~AND［
%A ~EQ`生成元$sub %B
］
</li>
		</ul>
◎
If A and B are both tuple origins, run these substeps:
• If A and B's schemes are identical, and their domains are identical and non-null, then return true.
• Otherwise, if A and B are same origin and their domains are identical and null, then return true.
◎
Return false.
	</li>
</ul>

<div class="example">

<table class="grid-table _compare-origin">
<thead><tr><th>%A ( ~scheme, ~host, ~port, ~domain )
<th>%B
<th>`同一-生成元$？
<th>`同じ生成元~domain$？
</thead><tbody>

<tr><td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>✅
<td>✅

<tr><td>(`https^l, `example.org^l, 314, ~NULL)
<td>(`https^l, `example.org^l, 420, ~NULL)
<td>❌
<td>❌

<tr><td>(`https^l, `example.org^l, 314, `example.org^l)
<td>(`https^l, `example.org^l, 420, `example.org^l)
<td>❌
<td>✅

<tr><td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>(`https^l, `example.org^l, ~NULL, `example.org^l)
<td>✅
<td>❌

<tr><td>(`https^l, `example.org^l, ~NULL, `example.org^l)
<td>(`http^l, `example.org^l, ~NULL, `example.org^l)
<td>❌
<td>❌
</tbody></table>

</div>

			<section id="sites">
<h4 title="Sites">7.5.1. ~site</h4>

<p>
`~scheme＆~host@
は、
( `~scheme$url, `~host$ )
が成す`~tuple$である。
◎
A scheme-and-host is a tuple of a scheme and a host.
</p>

<p>
`~site@
は、［
`不透明な生成元$／`~scheme＆~host$
］である
◎
A site is an opaque origin or a scheme-and-host.
</p>

<div class="algo">
<p>
`~siteを得する@
ときは、所与の
( `生成元$ %生成元 )
に対し，次を走らす：
◎
To obtain a site, given an origin origin, run these steps:
</p>
<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET %生成元
◎
If origin is an opaque origin, then return origin.
</li>
	<li>
%~domain ~LET %生成元 の`~host$oの`登録-可能な~domain$
◎
↓</li>
	<li>
~IF［
%~domain ~EQ ~NULL
］
⇒
%~domain ~SET %生成元 の`~host$o
◎
↓</li>
	<li>
~RET ( %生成元 の`~scheme$o, %~domain )
◎
If origin's host's registrable domain is null, then return (origin's scheme, origin's host).
◎
Return (origin's scheme, origin's host's registrable domain).
</li>
</ol>
</div>

<p>
2 つの`生成元$ %A, %B が
`~scheme無しで同じ~site@
であるとは、次のいずれかを満たすことをいう：
◎
Two origins, A and B, are said to be schemelessly same site if the following algorithm returns true:
</p>

<ul>
	<li>
［
%A, %B とも`不透明な生成元$である
］~AND［
%A ~EQ %B
］
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
<p>
［
%A, %B とも`成分組~生成元$である
］~AND［
( %A の`~host$o %hostA, %B の`~host$o %hostB )
は次のいずれかを満たす
］：
</p>
		<ul>
			<li>
［
( %hostA, %hostB )
は`同等な~host$である
］~AND［
%hostA の`登録-可能な~domain$ ~EQ ~NULL
］
</li>
			<li>
( %hostA の`登録-可能な~domain$, %hostB の`登録-可能な~domain$ )
は、どちらも ~NULL でない, かつ`同等な~host$である
</li>
		</ul>
◎
If A and B are both tuple origins, then:
• Let hostA be A's host, and let hostB be B's host.
• If hostA equals hostB and hostA's registrable domain is null, then return true.
• If hostA's registrable domain equals hostB's registrable domain and is non-null, then return true.
◎
Return false.
</li>
</ul>

<p>
2 つの`生成元$ %A, %B が
`同じ~site@
であるとは、次のいずれも満たすことをいう：
◎
Two origins, A and B, are said to be same site if both of the following statements are true:
</p>

<ul>
	<li>
( %A, %B )
は、`~scheme無しで同じ~site$である
◎
A and B are schemelessly same site
</li>
	<li>
<p>
次のいずれかを満たす：
</p>
		<ul>
			<li>
%A, %B とも`不透明な生成元$である
</li>
			<li>
［
%A, %B とも`成分組~生成元$である
］~AND［
%A の`~scheme$o ~EQ %B の`~scheme$o
］
</li>
		</ul>
◎
A and B are either both opaque origins, or both tuple origins with the same scheme
</li>
</ul>

<p class="note">注記：
［
`同一-生成元$, `同じ生成元~domain$
］の概念と違って、［
`~scheme無しで同じ~site$, `同じ~site$
］においては，［
`~port$o, `~domain$o
］成分は無視される。
◎
Unlike the same origin and same origin-domain concepts, for schemelessly same site and same site, the port and domain components are ignored.
</p>

<p class="warning">
`URL^cite にて
<a href="~URL1#warning-avoid-psl">説明される理由</a>から，［
`同じ~site$,
`~scheme無しで同じ~site$
］の概念は、アリなときは避けるベキである
— `同一-生成元$を検査する方が好ましい。
◎
For the reasons explained in URL, the same site and schemelessly same site concepts should be avoided when possible, in favor of same origin checks.
</p>

<div id="example-same-site" class="example">
<p>
所与の`公共~接尾辞$［
`wildlife.museum^l, `museum^l, `com^l
］および，そうでない `example.com^l に対し：
◎
Given that wildlife.museum, museum, and com are public suffixes and that example.com is not:
</p>

<table class="grid-table _compare-origin">
<thead><tr><th>%A ( ~scheme, ~host )
<th>%B
<th>`~scheme無しで同じ~site$？
<th>`同じ~site$？
</thead><tbody>

<tr><td>(`https^l, `example.com^l)
<td>(`https^l, `sub.example.com^l)
<td>✅
<td>✅
<tr><td>(`https^l, `example.com^l)
<td>(`https^l, `sub.other.example.com^l)
<td>✅
<td>✅
<tr><td>(`https^l, `example.com^l)
<td>(`http^l, `non-secure.example.com^l)
<td>✅
<td>❌
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `sub.r.wildlife.museum^l)
<td>✅
<td>✅
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `sub.other.r.wildlife.museum^l)
<td>✅
<td>✅
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `other.wildlife.museum^l)
<td>❌
<td>❌
<tr><td>(`https^l, `r.wildlife.museum^l)
<td>(`https^l, `wildlife.museum^l)
<td>❌
<td>❌
<tr><td>(`https^l, `wildlife.museum^l)
<td>(`https^l, `wildlife.museum^l)
<td>✅
<td>✅
</tbody></table>

<p>
（ここでは、［
`~port$o, `~domain$o
］成分は考慮されないので省略している。）
◎
(Here we have omitted the port and domain components since they are not considered.)
</p>
</div>

			</section>
			<section id="relaxing-the-same-origin-restriction">
<h4 title="Relaxing the same-origin restriction">7.5.2. 同一-生成元による制約の緩め方</h4>

<dl class="domintro">
	<dt>%document . `domain$m [ = %domain ]</dt>
	<dd>
~security検査~用に利用される現在の~domainを返す。
◎
Returns the current domain used for security checks.
</dd>
	<dd>
下位domainを除去するような値に設定して，`生成元$の`~domain$oを変更できる
— そうすることにより，
同じ~domainに属する他の下位domain上の~pageと互いに~accessできるようになる（それらも，同じことをしたならば）。
これは、同じ~domainに属する異なる~host上の~pageが，互いの~DOMへ同期的に~accessすることを可能化する。
◎
Can be set to a value that removes subdomains, to change the origin's domain to allow pages on other subdomains of the same domain (if they do the same thing) to access each other. This enables pages on different hosts of a domain to synchronously access each other's DOMs.
</dd>
	<dd>
［
次において／次のとき
］は、設定子は `SecurityError$E 例外を投出することになる
⇒＃
~sandbox化された `iframe$e 内／
`不透明な生成元$を伴う`文書$内／
`属する閲覧文脈$が無い`文書$内／
`document-domain$l 特能は不能化されているとき
◎
In sandboxed iframes, Documents with opaque origins, Documents without a browsing context, and when the "document-domain" feature is disabled, the setter will throw a "SecurityError" exception.＼
</dd>
	<dd>
［
`crossOriginIsolated$m, `originAgentCluster$m
］どちらかが ~T を返す事例では、設定子は何もしない。
◎
In cases where crossOriginIsolated or originAgentCluster return true, the setter will do nothing.
</dd>
</dl>

<div class="critical">

<p>
`document.domain$m 設定子を利用するのは、避けること。
それは、同一-生成元~施策が供する~security保護を蝕む。
とりわけ、他者と~hostを共有しているとき，ひどいことになる：
例えば，信用できない第三者主体が［
同じ~IP~address上の~portだけ異なる~HTTP~server
］を~hostできる場合、［
通常は同じ~host上の異なる~siteどうしを保護する，同一-生成元による保護
］は，失敗することになる
— `document.domain$m 設定子が利用されて以降は、生成元の比較-時に，その~portは無視されるので。
◎
Avoid using the document.domain setter. It undermines the security protections provided by the same-origin policy. This is especially acute when using shared hosting; for example, if an untrusted third party is able to host an HTTP server at the same IP address but on a different port, then the same-origin protection that normally protects two different sites on the same host will fail, as the ports are ignored when comparing origins after the document.domain setter has been used.
</p>

<p>
これらの~securityの陥穽があるので、この特能は~web~platformから除去されつつある過程にある（何年もかかるであろう）。
◎
Because of these security pitfalls, this feature is in the process of being removed from the web platform. (This is a long process that takes many years.)
</p>

<p>
他の生成元と安全な方式で通信するためには、代わりに［
`postMessage()$m ／ `MessageChannel$I ~obj
］を利用すること。
◎
Instead, use postMessage() or MessageChannel objects to communicate across origins in a safe manner.
</p>
</div>

<p>
`Document$I の
`domain@m
属性の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The domain getter steps are:
</p>
		<ol>
			<li>
%実効~domain ~LET コレの`生成元$docの`実効~domain$
◎
Let effectiveDomain be this's origin's effective domain.
</li>
			<li>
~IF［
%実効~domain ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If effectiveDomain is null, then return the empty string.
</li>
			<li>
~RET `~hostを直列化する$( %実効~domain )
◎
Return effectiveDomain, serialized.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The domain setter steps are:
</p>
		<ol>
			<li>
~IF［
コレが`属する閲覧文脈$ ~EQ ~NULL
］
⇒
~THROW `SecurityError$E
◎
If this's browsing context is null, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
`~document-domain$sbox ~IN
コレにて`作動中の~sandbox法~flag集合$
］
⇒
~THROW `SecurityError$E
◎
If this's active sandboxing flag set has its sandboxed document.domain browsing context flag set, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
コレには `document-domain$l 特能の`利用は許容されて$いない
］
⇒
~THROW `SecurityError$E
◎
If this is not allowed to use the "document-domain" feature, then throw a "SecurityError" DOMException.
</li>
			<li>
%実効~domain ~LET コレの`生成元$docの`実効~domain$
◎
Let effectiveDomain be this's origin's effective domain.
</li>
			<li>
~IF［
%実効~domain ~EQ ~NULL
］
⇒
~THROW `SecurityError$E
◎
If effectiveDomain is null, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
所与の値は %実効~domain に対し`登録-可能な~domain接尾辞または同等$でない
］
⇒
~THROW `SecurityError$E
◎
If the given value is not a registrable domain suffix of and is not equal to effectiveDomain, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
`~surrounding~agent$の`~agent~cluster$の`生成元を~keyにするか$ ~EQ ~T
］
⇒
~RET
◎
If the surrounding agent's agent cluster's is origin-keyed is true, then return.
</li>
			<li>
コレの`生成元$docの`~domain$o ~SET `~host構文解析器$( 所与の値 )
◎
Set this's origin's domain to the result of parsing the given value.
</li>
		</ol>
	</li>
</ul>

<div class="algo">
<p>
所与の文字列 %~host接尾辞~文字列 は`~host$ %元の~host に対し
`登録-可能な~domain接尾辞または同等@
であるかどうか決定するときは、次を走らす：
◎
To determine if a string hostSuffixString is a registrable domain suffix of or is equal to a host originalHost, run these steps:
</p>

<ol>
	<li>
~IF［
%~host接尾辞~文字列 ~EQ 空~文字列
］
⇒
~RET ~F
◎
If hostSuffixString is the empty string, then return false.
</li>
	<li>
%~host ~LET `~host構文解析器$( %~host接尾辞~文字列 )
◎
Let host be the result of parsing hostSuffixString.
</li>
	<li>
~IF［
%~host ~EQ `失敗^i
］
⇒
~RET ~F
◎
If host is failure, then return false.
</li>
	<li>
<p>
~IF［
( %~host, %元の~host )
は`同等な~host$でない
］：
◎
If host does not equal originalHost, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~host , %元の~host のいずれかは`~domain$urlでない 
］
⇒
~RET ~F
◎
If host or originalHost is not a domain, then return false.
</p>

<p class="note">注記：
すなわち、
`~IPv4~address$ ／ `~IPv6~address$
による`~host$は除外する。
◎
This excludes hosts that are an IPv4 address or an IPv6 address.
</p>
			</li>
			<li>
~IF［［
%~host に `002E^U `.^smb を接頭した結果
］は %元の~host の尾部に【！正確に】合致しない
］
⇒
~RET ~F
◎
If host, prefixed by a U+002E FULL STOP (.), does not exactly match the end of originalHost, then return false.
</li>
			<li>
~IF［
( %~host, %~host の`公共~接尾辞$ )
は`同等な~host$である `URL$r
］
⇒
~RET ~F
◎
If host equals host's public suffix, then return false. [URL]
</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

			</section>
			<section id="origin-keyed-agent-clusters">
<h4 title="Origin-keyed agent clusters">7.5.3 生成元を~keyにする~agent~cluster</h4>

<dl class="domintro">
	<dt>%window . `originAgentCluster$m</dt>
	<dd>
この`~window$が属する`~agent~cluster$は，この節に述べる方式で`生成元$を`~keyに$するならば、
~T を返す。
◎
Returns true if this Window belongs to an agent cluster which is origin-keyed, in the manner described in this section.
</dd>
</dl>

<p>
`~secureな文脈$enV越しに送達される`文書$は、
`Origin-Agent-Cluster$h ~HTTP応答~headerを利用することにより，自身を`生成元$を`~keyに$するような`~agent~cluster$内に配置するよう要請できる。
この~headerは、`有構造~header$であり，その値は`真偽値$sfでなければナラナイ。
`STRUCTURED-FIELDS$r
◎
A Document delivered over a secure context can request that it be placed in an origin-keyed agent cluster, by using the `Origin-Agent-Cluster` HTTP response header. This header is a structured header whose value must be a boolean. [STRUCTURED-FIELDS]
</p>

<p>
`文書を作成して初期化する$処理~modelにより、
`真偽値$sf ~T （すなわち, `?1^bl ）でない値は無視されることになる。
◎
Per the processing model in the create and initialize a new Document object, values that are not the structured header boolean true value (i.e., `?1`) will be ignored.
</p>

<p>
この~headerを利用することによる帰結は：
◎
The consequences of using this header are that＼
</p>
<ul>
	<li>
結果の`文書$の`~agent~cluster~key$は、
<a href="#obtain-a-site">対応する~site</a>にはならず，文書の`生成元$docになる。
◎
the resulting Document's agent cluster key is its origin, instead of the corresponding site.
</li>
	<li>
観測-可能な効果としては、
`document.domain$m を利用して
<a href="#relaxing-the-same-origin-restriction">同一-生成元~制約を緩めよう</a>と試みても，何もしないことになり、非同一-生成元に属する`文書$へ `WebAssembly.Module$c ~objを送信することも，アリでなくなる（それらが`同じ~site$に属していようが）。
◎
In terms of observable effects, this means that attempting to relax the same-origin restriction using document.domain will instead do nothing, and it will not be possible to send WebAssembly.Module objects to cross-origin Documents (even if they are same site).
</li>
	<li>
この隔離は，舞台裏では、［
~processや~threadなど、実装に特有な，`~agent~cluster$に対応する資源
］をより効率的に割振ることを~UAに許容し得る。
◎
Behind the scenes, this isolation can allow user agents to allocate implementation-specific resources corresponding to agent clusters, such as processes or threads, more efficiently.
</li>
</ul>

<p>
`閲覧文脈~group$の中では、［
`Origin-Agent-Cluster$h ~headerにより，同一-生成元に属する`文書$どうしが異なる`~agent~cluster$に属する結果に至る
］ことは，決してないことに注意
— それらのうち，あるものは この~headerを送信し、他は送信しない場合でも。
これは、`履歴上の~agent~cluster~key~map$bcGにより防止される。
◎
Note that within a browsing context group, the `Origin-Agent-Cluster` header can never cause same-origin Document objects to end up in different agent clusters, even if one sends the header and the other doesn't. This is prevented by means of the historical agent cluster key map.
</p>

<p class="note">注記：
このことは、同じ`閲覧文脈~group$内に 以前に読込まれた同一-生成元~pageに対し，この~headerが省略されていた場合、
`originAgentCluster$m 取得子は
— この~headerが ~T に設定されたとしても —
~F を返し得ることを意味する。
類似に、~headerが ~T に設定されていないときでも，
~T を返し得る。
◎
This means that the originAgentCluster getter can return false, even if the header is set, if the header was omitted on a previously-loaded same-origin page in the same browsing context group. Similarly, it can return true even when the header is not set.
</p>

<div class="algo">
`originAgentCluster@m
取得子~手続きは
⇒
~RET `~surrounding~agent$の`~agent~cluster$の`生成元を~keyにするか$
◎
The originAgentCluster getter steps are to return the surrounding agent's agent cluster's is origin-keyed.
</div>

<p class="note">注記：
`文書$のうち，`不透明な生成元$に属するものは、無条件に生成元を~keyにすると見なせる
— それらに対しては、この~headerによる効果はなく，
`originAgentCluster$m 取得子は常に ~T を返すことになる。
◎
Documents with an opaque origin can be considered unconditionally origin-keyed; for them the header has no effect, and the originAgentCluster getter will always return true.
</p>

<p class="note">注記：
類似に，`~agent~cluster$のうち［
`非同一-生成元~隔離~mode$agC ~EQ `none$coI
］を満たすものに属する`文書$は、自動的に生成元を~keyにする。
`Origin-Agent-Cluster$h ~headerは、［
資源の割振りについての実装に対する追加的な~hint
］としても有用になり得る
— が，それを追加しても、作者~codeから観測-可能になる追加的な効果はない。
一方で，非同一-生成元~隔離を達成するために利用される［
`Cross-Origin-Opener-Policy$h ／
`Cross-Origin-Embedder-Policy$h 
］~headerは、［
同じ~address空間~内にある何もかもが，そこにあること
］を任意選択することを確保することに，より~~力点が置かれる。
◎
Similarly, Documents whose agent cluster's cross-origin isolation mode is not "none" are automatically origin-keyed. The `Origin-Agent-Cluster` header might be useful as an additional hint to implementations about resource allocation, since the `Cross-Origin-Opener-Policy` and `Cross-Origin-Embedder-Policy` headers used to achieve cross-origin isolation are more about ensuring that everything in the same address space opts in to being there. But adding it would have no additional observable effects on author code.
</p>

			</section>
		</section>
		<section id="sandboxing">
<h3 title="Sandboxing">7.6. ~sandbox法</h3>

<p>
`~sandbox法~flag集合@
は、以下に挙げる各種~flagのうち，いくつかからなる集合である。
この集合は、それが含む各種~flagを通して，信用できない資源が持ち得る能を制約するために利用される：
◎
A sandboxing flag set is a set of zero or more of the following flags, which are used to restrict the abilities that potentially untrusted resources have:
</p>

【！ flag ~IN ~sandbox法~flag集合 ↔ flag ~EQ ~T】

<p class="trans-note">【
“<a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security)">~sandbox</a>”
—  “（こどもの）砂場” （ “監獄” を和らげた語（一般に，より制約も緩い））。
】【
以下に現れる各種
“`X^sbox”
は、
“［
X について，閲覧文脈を~sandbox化する（ X の機能を抑止する）
］ことを指示する~flag”
と解釈する
— そのように解釈し易いよう、この訳では，関数的に記している。
】【
以下に現れる “内容” とは、［
これらの~flagが適用される閲覧文脈
］内の内容を指す。
】</p>

<dl>
	<dt>
`~navi@sbox
◎
The sandboxed navigation browsing context flag
</dt>
	<dd>
<p>
この~flagは、~sandbox化されている当の閲覧文脈を %B とするとき，
次に挙げるもの以外の`閲覧文脈$ %C に対しては，
%B の内容が %C を
<a href="~NAVI#sandboxLinks">~navigateするのを防止する</a>
：
</p>
		<ul>
			<li>
%B 自身
</li>
			<li>
%B が内側に更に入子にしている閲覧文脈
</li>
			<li>
%B が開いた`補助~閲覧文脈$（これは、`補助~navi$sboxにより保護される）†
</li>
			<li>
%B の`~top-level閲覧文脈$（これは、
`利用者~作動化~top-level~navi$sbox,
`非~利用者~作動化~top-level~navi$sbox
により保護される）
</li>
		</ul>
◎
This flag prevents content from navigating browsing contexts other than the sandboxed browsing context itself (or browsing contexts further nested inside it), auxiliary browsing contexts (which are protected by the sandboxed auxiliary navigation browsing context flag defined next), and the top-level browsing context (which is protected by the sandboxed top-level navigation without user activation browsing context flag and sandboxed top-level navigation with user activation browsing context flag defined below).
</dd>
	<dd>†
この制約にもかかわらず，［
`補助~navi$sbox ~NIN `~sandbox法~flag集合$
］の下では、ある種の事例では，新たな`~top-level閲覧文脈$として
%~popup 【すなわち、`補助~閲覧文脈$】を開くことが許容される。
そのような %~popup の作成-時には、それを作成した`閲覧文脈$が，
%~popup の
`許可-済み~navigator@††
として設定される
— それは、（ ~naviに関して~sandbox化されていても）実際には %~popup を~navigateすることが許可される。
（他の場合、 %~popup に対する~naviは，`~navi$sboxにより防止される。）
◎
If the sandboxed auxiliary navigation browsing context flag is not set, then in certain cases the restrictions nonetheless allow popups (new top-level browsing contexts) to be opened. These browsing contexts always have one permitted sandboxed navigator, set when the browsing context is created, which allows the browsing context that created them to actually navigate them. (Otherwise, the sandboxed navigation browsing context flag would prevent them from being navigated even if they were opened.)
</dd>
	<dd class="trans-note">【††
“`one permitted sandboxed navigator^en”
— この “`one^en” は、［
%~popup に対し`許可-済み~navigator$とされるものは、 1 個だけあること
］を表していると見受けられる。
】</dd>

	<dt>
`補助~navi@sbox
◎
The sandboxed auxiliary navigation browsing context flag
</dt>
	<dd>
この~flagは、内容が
<a href="~BROWSERS#sandboxWindowOpen">新たな補助~閲覧文脈を作成するのを防止する</a>
—
例えば［
`target$a 属性 ／
`window.open()$m ~method
］を利用して。
◎
This flag prevents content from creating new auxiliary browsing contexts, e.g. using the target attribute or the window.open() method.
</dd>

	<dt>`非~利用者~作動化~top-level~navi@sbox</dt>
	<dt>`利用者~作動化~top-level~navi@sbox</dt>
	<dd>
両~flagとも、内容が その`~top-level閲覧文脈$を［
<a href="~NAVI#sandboxLinks">~navigateするのを防止する</a> ／
<a href="~WINDOW#sandboxClose">閉じるのを防止する</a>
］。
これらは順に、~sandbox化されている閲覧文脈にて`作動中の~window$の`一過な作動化？$が［
~F のとき, ~T のとき
］に限り，アタられる。
◎
The sandboxed top-level navigation without user activation browsing context flag
◎
This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level browsing context. It is consulted only when the sandboxed browsing context's active window does not have transient activation.
</dd>
	<dd>
両~flagとも、影響するのは`~top-level閲覧文脈$に限られる
— ［
この~flag（`一過な作動化？$に応じて適切な方） ~NIN `~sandbox法~flag集合$
］の下では、内容は，その`~top-level閲覧文脈$を~navigateできる。
が、他の`閲覧文脈$は，依然として他の~flag
— `~navi$sboxや, （場合によっては）`補助~navi$sbox —
により保護される。
◎
When the sandboxed top-level navigation without user activation browsing context flag is not set, content can navigate its top-level browsing context, but other browsing contexts are still protected by the sandboxed navigation browsing context flag and possibly the sandboxed auxiliary navigation browsing context flag.
◎
The sandboxed top-level navigation with user activation browsing context flag
◎
This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level browsing context. It is consulted only when the sandboxed browsing context's active window has transient activation.
◎
As with the sandboxed top-level navigation without user activation browsing context flag, this flag only affects the top-level browsing context; if it is not set, other browsing contexts might still be protected by other flags.
</dd>

	<dt>
`~plugin@sbox
◎
The sandboxed plugins browsing context flag
</dt>
	<dd>
この~flagは、内容が［
<a href="~HEembed#sandboxPluginEmbed">`embed^e 要素を利用して</a> ／
<a href="~HEembed#sandboxPluginObject">`object^e 要素を利用して</a>
］, あるいは［
それらが`入子にしている閲覧文脈$に対する
<a href="~NAVI#sandboxPluginNavigate">~naviを通して</a>
］~pluginを~instance化するのを防止する
— それらの`~plugin$を`~secure化でき$ない限り。
◎
This flag prevents content from instantiating plugins, whether using the embed element, the object element, or through navigation of their nested browsing context, unless those plugins can be secured.
</dd>

	<dt>
`生成元@sbox
◎
The sandboxed origin browsing context flag
</dt>
	<dd>
この~flagは、
<a href="~BROWSERS#sandboxOrigin">内容を一意な生成元~内に強制する</a>
— したがって，内容が［
同じ`生成元$からの他の内容
］に~accessするのを防止する。
◎
This flag forces content into a unique origin, thus preventing it from accessing other content from the same origin.
</dd>
	<dd>
この~flagはまた、~scriptが `document.cookie^m ~IDL属性を
<a href="~HTMLdom#sandboxCookies">読取る／書込むのを防止する</a>
ことに加え， `localStorage$m への~accessも阻止する。
◎
This flag also prevents script from reading from or writing to the document.cookie IDL attribute, and blocks access to localStorage.
</dd>

	<dt>
`~form@sbox
◎
The sandboxed forms browsing context flag
</dt>
	<dd>
この~flagは、
<a href="~HTMLforms#sandboxSubmitBlocked">~form提出を阻止する</a>
。
◎
This flag blocks form submission.
</dd>

	<dt>
`~pointer~lock@sbox
◎
The sandboxed pointer lock browsing context flag
</dt>
	<dd>
この~flagは、 Pointer Lock ~APIを不能化する。
`POINTERLOCK$r
◎
This flag disables the Pointer Lock API. [POINTERLOCK]
</dd>

	<dt>
`~script@sbox
◎
The sandboxed scripts browsing context flag
</dt>
	<dd>
この~flagは、
<a href="~WAPI#sandboxScriptBlocked">~script実行を阻止する</a>。
◎
This flag blocks script execution.
</dd>

	<dt>
`自動的な特能@sbox
◎
The sandboxed automatic features browsing context flag
</dt>
	<dd>
<p >
この~flagは、次に挙げるような自動的に誘発される特能を阻止する：
</p>

<ul ><li><a href="~HEmedia#attr-media-autoplay">動画を自動的に再生する</a>
</li><li><a href="~HTMLinteraction#attr-fe-autofocus">~form~controlを自動的に~focusする</a>
</li></ul>

◎
This flag blocks features that trigger automatically, such as automatically playing a video or automatically focusing a form control.
</dd>

	<dt>
`~document-domain@sbox
◎
The sandboxed document.domain browsing context flag
</dt>
	<dd>
この~flagは、 `document.domain$m 設定子の利用を防止する。
◎
This flag prevents content from using the document.domain setter.
</dd>

	<dt>
`~sandboxは補助~閲覧文脈に伝播する~flag@
◎
The sandbox propagates to auxiliary browsing contexts flag
</dt>
	<dd>
この~flagは、［
内容にて`作動中の~sandbox法~flag集合$
］を［
内容が作成する`補助~閲覧文脈$
］に継承させることにより，内容が ~sandboxから逃れるのを防止する。
◎
This flag prevents content from escaping the sandbox by ensuring that any auxiliary browsing context it creates inherits the content's active sandboxing flag set.
</dd>

	<dt>
`~sandbox化( ~modal )~flag@
◎
The sandboxed modals flag
</dt>
	<dd>
<p>
この~flagは、［
内容が，次のいずれかの特能を利用して~modal~dialogを生産する
］のを防止する：
◎
This flag prevents content from using any of the following features to produce modal dialogs:
</p>

<ul><li>`window.alert()$m
</li><li>`window.confirm()$m
</li><li>`window.print()$m
</li><li>`window.prompt()$m
</li><li>`beforeunload$et ~event
</li></ul>

	</dd>

	<dt>
`方位~lock@sbox
◎
The sandboxed orientation lock browsing context flag
</dt>
	<dd>
この~flagは、~screen方位を~lockする能を不能化する。
`SCREENORIENTATION$r
◎
This flag disables the ability to lock the screen orientation. [SCREENORIENTATION]
</dd>
	<dt>
`呈示@sbox
◎
The sandboxed presentation browsing context flag
</dt>
	<dd>
この~flagは、 Presentation API を不能化する。
`PRESENTATION$r
◎
This flag disables the Presentation API. [PRESENTATION]
</dd>

	<dt>
`~download@sbox
◎
The sandboxed downloads browsing context flag
</dt>
	<dd>
この~flagは、内容が次のいずれかを通して~downloadを起動したり~instance化することを防止する
⇒＃
`~hyperlinkを~downloadする$／
`~navigate応答を処理する$ときに`~downloadとして$取扱われるもの
◎
This flag prevents content from initiating or instantiating downloads, whether through downloading hyperlinks or through navigation that gets handled as a download.
</dd>
</dl>

<div class="algo">
<p>
`~sandbox法~指令を構文解析する@
手続きは、所与の (
文字列 %入力,
`~sandbox法~flag集合$ %出力
)
に対し，次を走らすモノトスル：
◎
When the user agent is to parse a sandboxing directive, given a string input, a sandboxing flag set output, it must run the following steps:
</p>

<ol>
	<li>
%~tokenたち ~LET `~ASCII空白で分割する$( %入力 )
◎
Split input on ASCII whitespace, to obtain tokens.
</li>
	<li>
%出力 を空にする
◎
Let output be empty.
</li>
	<li>

<p>
以下に挙げる各種~flagを，対応する記述の条件が満たされるならば
%出力 に追加する：
◎
Add the following flags to output:
</p>
		<ul>
			<li>
`~navi$sbox
⇒
~~無条件
◎
The sandboxed navigation browsing context flag.
</li>
			<li>
`補助~navi$sbox
⇒
`allow-popups@v ~NIN %~tokenたち
◎
The sandboxed auxiliary navigation browsing context flag, unless tokens contains the allow-popups keyword.
</li>
			<li>
`非~利用者~作動化~top-level~navi$sbox
⇒
`allow-top-navigation@v
~NIN %~tokenたち
◎
The sandboxed top-level navigation without user activation browsing context flag, unless tokens contains the allow-top-navigation keyword.
</li>
			<li>
<p>
`利用者~作動化~top-level~navi$sbox
⇒
［
`allow-top-navigation-by-user-activation@v
~NIN %~tokenたち
］~AND［
`allow-top-navigation$v ~NIN %~tokenたち
］
◎
The sandboxed top-level navigation with user activation browsing context flag, unless tokens contains either the allow-top-navigation-by-user-activation keyword or the allow-top-navigation keyword.
</p>

<p class="note">注記：
したがって、［
`allow-top-navigation$v ~IN %~tokenたち
］の場合、
`allow-top-navigation-by-user-activation$v
の効果はなくなる。
この理由から、両~keywordとも指定するのは，文書~適合性の~errorになる。
◎
This means that if the allow-top-navigation is present, the allow-top-navigation-by-user-activation keyword will have no effect. For this reason, specifying both is a document conformance error.
</p>
			</li>
			<li>
`~plugin$sbox
⇒
~~無条件
◎
The sandboxed plugins browsing context flag.
</li>
			<li>
<p>
`生成元$sbox
⇒
`allow-same-origin@v ~NIN %~tokenたち
◎
The sandboxed origin browsing context flag, unless the tokens contains the allow-same-origin keyword.
</p>

<div class="note">

<p>注記：
`allow-same-origin$v ~keywordは、次の 2 つの事例に意図されている：
◎
The allow-same-origin keyword is intended for two cases.
</p>

<ul>
	<li>
<p>
一つは、同じ~siteからの内容を，次のように~sandbox化するための利用：
</p>

<ul ><li>内容による~scriptingは不能化する。
</li><li>内容が成す~DOMへの~accessは許容する。
</li></ul>
◎
First, it can be used to allow content from the same site to be sandboxed to disable scripting, while still allowing access to the DOM of the sandboxed content.
</li>
	<li>
<p>
もう一つは、第三者主体~siteからの内容を埋込むときに，その内容を次のように~sandbox化するための利用：
</p>

<ul ><li>その~siteが ~popupを開く, 等々は防止する。
</li><li>［
埋込まれた~pageが、~dataを格納するための~database~API, 等を利用して，その出自の~siteと通信する
］ことは防止しない。
</li></ul>

◎
Second, it can be used to embed content from a third-party site, sandboxed to prevent that site from opening popups, etc, without preventing the embedded page from communicating back to its originating site, using the database APIs to store data, etc.
</li>
</ul>
</div>

			</li>
			<li>
`~form$sbox
⇒
`allow-forms@v ~NIN %~tokenたち
◎
The sandboxed forms browsing context flag, unless tokens contains the allow-forms keyword.
</li>
			<li>
`~pointer~lock$sbox
⇒
`allow-pointer-lock@v ~NIN %~tokenたち
◎
The sandboxed pointer lock browsing context flag, unless tokens contains the allow-pointer-lock keyword.
</li>
			<li>
`~script$sbox
⇒
`allow-scripts@v ~NIN %~tokenたち
◎
The sandboxed scripts browsing context flag, unless tokens contains the allow-scripts keyword.
</li>
			<li>
<p>
`自動的な特能$sbox
⇒
`allow-scripts$v ~NIN %~tokenたち
◎
The sandboxed automatic features browsing context flag, unless tokens contains the allow-scripts keyword (defined above).
</p>

<p class="note">注記：
この~flagは、`~script$sboxと同じ~keywordで緩められる
— この~flagにより許容されなくなる宣言的な特能は、~scriptが可能化されている下では自明にアリになるので。
◎
This flag is relaxed by the same keyword as scripts, because when scripts are enabled these features are trivially possible anyway, and it would be unfortunate to force authors to use script to do them when sandboxed rather than allowing them to use the declarative features.
</p>
			</li>
			<li>
`~document-domain$sbox
⇒
~~無条件
◎
The sandboxed document.domain browsing context flag.
</li>
			<li>
`~sandboxは補助~閲覧文脈に伝播する~flag$
⇒
`allow-popups-to-escape-sandbox@v ~NIN %~tokenたち
◎
The sandbox propagates to auxiliary browsing contexts flag, unless tokens contains the allow-popups-to-escape-sandbox keyword.
</li>
			<li>
`~sandbox化( ~modal )~flag$
⇒
`allow-modals@v ~NIN %~tokenたち
◎
The sandboxed modals flag, unless tokens contains the allow-modals keyword.
</li>
			<li>
`方位~lock$sbox
⇒
`allow-orientation-lock@v ~NIN %~tokenたち
◎
The sandboxed orientation lock browsing context flag, unless tokens contains the allow-orientation-lock keyword.
</li>
			<li>
`呈示$sbox
⇒
`allow-presentation@v ~NIN %~tokenたち
◎
The sandboxed presentation browsing context flag, unless tokens contains the allow-presentation keyword.
</li>
			<li>
`~download$sbox
⇒
`allow-downloads@v ~NIN %~tokenたち
◎
The sandboxed downloads browsing context flag, unless tokens contains the allow-downloads keyword.
</li>
		</ul>
	</li>
</ol>
</div>

<hr>

<p>
`~sandbox法~flag集合$には、次に挙げる種類のものがある：
</p>

<ul>
	<li>
各`~top-level閲覧文脈$は、
`~popup~sandbox法~flag集合@
を有する
— `閲覧文脈$の作成-時には、空~集合になるモノトスル。
それは、次により拡充される
⇒＃
`閲覧文脈を選ぶ規則$／
`~navi応答~用に利用する閲覧文脈を得する$とき
◎
Every top-level browsing context has a popup sandboxing flag set, which is a sandboxing flag set. When a browsing context is created, its popup sandboxing flag set must be empty. It is populated by the rules for choosing a browsing context and the obtain a browsing context to use for a navigation response algorithm.
</li>
	<li>
各 `iframe$e 要素は、
`~iframe~sandbox法~flag集合@
を有する。
所与の特定0の時点に，どの~flagがこの集合に含められるかは、
`iframe$e 要素の`sandbox$a 属性により決定される。
◎
Every iframe element has an iframe sandboxing flag set, which is a sandboxing flag set. Which flags in an iframe sandboxing flag set are set at any particular time is determined by the iframe element's sandbox attribute.
</li>
	<li>
各`文書$は、
`作動中の~sandbox法~flag集合@
を有する
— `文書$の作成-時には、空~集合になるモノトスル。
それは、`~navi$~algoにより拡充される。
◎
Every Document has an active sandboxing flag set, which is a sandboxing flag set. When the Document is created, its active sandboxing flag set must be empty. It is populated by the navigation algorithm.
</li>
	<li>
<p>
`~navi$~algoにより得される各~資源は、
`強制d~sandbox法~flag集合@
を有する
— 既定では空~集合とする。
他の仕様は、ある種の~flagをこの集合に含めるよう定義し得る。
◎
Every resource that is obtained by the navigation algorithm has a forced sandboxing flag set, which is a sandboxing flag set. A resource by default has no flags set in its forced sandboxing flag set, but other specifications can define that certain flags are set.
</p>

<p class="note">注記：
`強制d~sandbox法~flag集合$は、特に，
Content Security Policy `CSP$r により利用される。
◎
In particular, the forced sandboxing flag set is used by Content Security Policy. [CSP]
</p>
	</li>
</ul>

<hr>

<div class="algo">
<p>
`作成時の~sandbox法~flagsを決定する@
ときは、所与の
( `閲覧文脈$ %B, ~NULL または要素 %埋込元 )
に対し、次を走らす：
◎
To determine the creation sandboxing flags for a browsing context browsing context, given null or an element embedder, return the union of the flags that are present in the following sandboxing flag sets:
</p>
<ol>
	<li>
~IF［
%埋込元 ~EQ ~NULL
］
⇒
~RET %B の`~popup~sandbox法~flag集合$を`~cloneする$
◎
If embedder is null, then: the flags set on browsing context's popup sandboxing flag set.
</li>
	<li>
~ELSE（ %埋込元 は要素である）
⇒
~RET 次の`和集合$
⇒＃
%埋込元 の`~iframe~sandbox法~flag集合$,
%埋込元 の`~node文書$にて`作動中の~sandbox法~flag集合$
◎
If embedder is an element, then: the flags set on embedder's iframe sandboxing flag set.
◎
If embedder is an element, then: the flags set on embedder's node document's active sandboxing flag set.
</li>
</ol>
</div>

<p>
`閲覧文脈$【！`属する閲覧文脈$】 %B 用の
`~sandbox法~flags@bc
は、 %B の作成~後には次の結果になる
⇒
`作成時の~sandbox法~flagsを決定する$( %B, %B の`容器$bc )
◎
After creation, the sandboxing flags for a browsing context browsing context are the result of determining the creation sandboxing flags given browsing context and browsing context's container.
</p>

		</section>
		<section id="cross-origin-opener-policies">
<h3 title="Cross-origin opener policies">7.7. 非同一-生成元~opener施策</h3>

<p>
`非同一-生成元~opener施策~値@
は、`~top-level閲覧文脈$内に~navigateされる【ことにより作成される】文書に対し，［
新たな`~top-level閲覧文脈$, および
対応する`~group$tbcG
］の作成を強制することを許容する。
アリな値は：
◎
A cross-origin opener policy value allows a document which is navigated to in a top-level browsing context to force the creation of a new top-level browsing context, and a corresponding group. The possible values are:
</p>
<dl>
	<dt>`unsafe-none@coop</dt>
	<dd>
これが（現在の）既定であり、次を意味する
⇒
当の文書は、それまでの文書
【~navigateされる前に作動中であった文書】
と同じ`~top-level閲覧文脈$を占めることになる
— ただし、当の文書と それまでの文書に異なる`非同一-生成元~opener施策$が指定されている場合は除く。
◎
This is the (current) default and means that the document will occupy the same top-level browsing context as its predecessor, unless that document specified a different cross-origin opener policy.
</dd>

	<dt>`same-origin-allow-popups@coop</dt>
	<dd>
これは、次が満たされる場合を除き，当の文書~用に新たな`~top-level閲覧文脈$の作成を強制する
⇒
当の文書と それまでの文書は、`同一-生成元$である, かつ同じ`非同一-生成元~opener施策$が指定されている
◎
This forces the creation of a new top-level browsing context for the document, unless its predecessor specified the same cross-origin opener policy and they are same origin.
</dd>

	<dt>`same-origin@coop</dt>
	<dd>
これは， `same-origin-allow-popups$coop と同じに挙動するが、それに加え
— そこに述べた条件が満たされない限り —
作成される`補助~閲覧文脈$が包含している文書【当の文書】は~opener【それまでの文書】に対し~closedに現れることになる
【言い換えれば、それまでの文書から当の文書へは~accessし得なくなる】
。
◎
This behaves the same as "same-origin-allow-popups", with the addition that any auxiliary browsing context created needs to contain same origin documents that also have the same cross-origin opener policy or it will appear closed to the opener.
</dd>

	<dt>`same-origin-plus-COEP@coop</dt>
	<dd>
これは， `same-origin$coop と同じに挙動するが、それに加え，
（新たな）`~top-level閲覧文脈$の`~group$tbcGの`非同一-生成元~隔離~mode$bcGを［
`logical$coI ／ `concrete$coI
］いずれかに設定する。
◎
This behaves the same as "same-origin", with the addition that it sets the (new) top-level browsing context's group's cross-origin isolation mode to one of "logical" or "concrete".
</dd>
	<dd class="note">注記：
`same-origin-plus-COEP$coop は、
`Cross-Origin-Opener-Policy$h ~headerを介して直に設定することはできないが、次の組合nを一緒に設定した結果として得られる
⇒＃
`Cross-Origin-Opener-Policy$h には `same-origin$coop,
`Cross-Origin-Embedder-Policy$h には `require-corp^l
◎
"same-origin-plus-COEP" cannot be directly set via the `Cross-Origin-Opener-Policy` header, but results from a combination of setting both `Cross-Origin-Opener-Policy: same-origin` and `Cross-Origin-Embedder-Policy: require-corp` together.
</dd>
</dl>

<p>
`非同一-生成元~opener施策@
【略称 “COOP” 】は、次に挙げるものからなる：
◎
A cross-origin opener policy consists of:
</p>
<ul>
	<li>
`値@coOP
⇒
`非同一-生成元~opener施策~値$
— 初期~時は `unsafe-none$coop とする。
◎
A value, which is a cross-origin opener policy value, initially "unsafe-none".
</li>
	<li>
`報告先@coOP
⇒
文字列／ ~NULL
— 初期~時は ~NULL とする。
◎
A reporting endpoint, which is string or null, initially null.
</li>
	<li>
`報告のみの値@coOP
⇒
`非同一-生成元~opener施策~値$
— 初期~時は `unsafe-none$coop とする。
◎
A report-only value, which is a cross-origin opener policy value, initially "unsafe-none".
</li>
	<li>
`報告のみの報告先@coOP
⇒
文字列／ ~NULL
— 初期~時は ~NULL とする。
◎
A report-only reporting endpoint, which is a string or null, initially null.
</li>
</ul>

<div class="algo">
<p>
所与の
( `非同一-生成元~opener施策~値$ %A, `生成元$ %oA,
`非同一-生成元~opener施策~値$ %B, `生成元$ %oB )
は、次のいずれかを満たすとき, そのときに限り
`非同一-生成元~opener施策~値として合致する@
とされる：
</p>
<ul>
	<li>
%A ~EQ %B ~EQ `unsafe-none$coop
</li>
	<li>
［
%A ~EQ %B ~NEQ `unsafe-none$coop
］~AND［
%oA ~EQ`生成元$sub %oB
］
</li>
</ul>

◎
To match cross-origin opener policy values, given a cross-origin opener policy value A, an origin originA, a cross-origin opener policy value B, and an origin originB:
• If A is "unsafe-none" and B is "unsafe-none", then return true.
• If A is "unsafe-none" or B is "unsafe-none", then return false.
• If A is B and originA is same origin with originB, then return true.
• Return false.
</div>

			<section id="the-headers">
<h4 title="The headers">7.7.1. 各種~header</h4>

<p>
`文書$の`非同一-生成元~opener施策$docは、［
`Cross-Origin-Opener-Policy$h ／
`Cross-Origin-Opener-Policy-Report-Only$h
］~HTTP応答~headerから導出される。
これらは，`有構造~header$であり、その値は`~token$sfでなければナラナイ。
`STRUCTURED-FIELDS$r
◎
A Document's cross-origin opener policy is derived from the `Cross-Origin-Opener-Policy` and the `Cross-Origin-Opener-Policy-Report-Only` HTTP response headers. These headers are structured headers whose value must be a token. [STRUCTURED-FIELDS]
</p>

<p>
`非同一-生成元~opener施策~値$が，`~token$sfとして妥当になる。
各~tokenは`~parameters$sfも伴い得る
— それを成す
`report-to@coop
~parameterは、適切な`報告先$を識別する`妥当な~URL文字列$をとり得る。
`REPORTING$r
◎
The valid token values are the opener policy values. The token may also have attached parameters; of these, the "report-to" parameter can have a valid URL string identifying an appropriate reporting endpoint. [REPORTING]
</p>

<p class="note">注記：
下に述べる処理~modelにより、~UAは，次の場合にはこの~headerを無視することになる
⇒
値を`~token$sfとして構文解析できない／
妥当でない値を包含する
◎
Per the processing model described below, user agents will ignore this header if it contains an invalid value. Likewise, user agents will ignore this header if the value cannot be parsed as a token.
</p>

<hr>

<div class="algo">
<p>
`非同一-生成元~opener施策を得する@
ときは、所与の
( `応答$ %応答, `環境$ %予約-済み環境 )
に対し：
◎
To obtain a cross-origin opener policy given a response response and an environment reservedEnvironment:
</p>
<ol>
	<li>
%施策 ~LET 新たな`非同一-生成元~opener施策$
◎
Let policy be a new cross-origin opener policy.
</li>
	<li>
~IF［
%予約-済み環境 は`~secureな文脈$enVでない
］
⇒
~RET %施策
◎
If reservedEnvironment is a non-secure context, then return policy.
</li>
	<li>
%構文解析した~item【！%値】 ~LET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Cross-Origin-Opener-Policy$h, `~item^i )
◎
Let value be the result of getting a structured field value given `Cross-Origin-Opener-Policy` and "item" from response's header list.
</li>
	<li>
<p>
~IF［
%構文解析した~item ~NEQ ~NULL
］：
◎
If parsedItem is not null, then:
</p>
		<ol>
			<li>
%値 ~LET %構文解析した~item の`値$sfI【！%構文解析した~item[ 0 ]】
◎
↓</li>
			<li>
<p>
~IF［
%値 は`~token$sfである【この条件は、この訳による補完】
］：
◎
↓</p>
				<ol>
					<li>
<p>
~IF［
%値 ~EQ `same-origin$coop
］：
◎
If parsedItem[0] is "same-origin", then:
</p>
						<ol>
							<li>
%~COEP ~LET `埋込元~施策を得する$( %応答, %予約-済み環境 )
◎
Let coep be the result of obtaining a cross-origin embedder policy from response and reservedEnvironment.
</li>
							<li>
%施策 の`値$coOP ~SET ［
次が満たされるならば `same-origin-plus-COEP$coop ／
~ELSE_ `same-origin$coop
］
⇒
%~COEP の`値$embP ~EQ `require-corp$coep
◎
If coep's value is "require-corp", then set policy's value to "same-origin-plus-COEP".
◎
Otherwise, set policy's value to "same-origin".
</li>
						</ol>
					</li>
					<li>
~IF［
%値 ~EQ `same-origin-allow-popups$coop
］
⇒
%施策 の`値$coOP ~SET `same-origin-allow-popups$coop
◎
If parsedItem[0] is "same-origin-allow-popups", then set policy's value to "same-origin-allow-popups".
</li>
					<li>
%report-to ~LET %構文解析した~item の`~parameters$sfI[ `report-to$coop ]
◎
↓</li>
					<li>
~IF［
%report-to は`文字列$sfである
］
⇒
%施策 の`報告先$coOP ~SET %report-to
◎
If parsedItem[1]["report-to"] exists and it is a string, then set policy's reporting endpoint to parsedItem[1]["report-to"].
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%構文解析した~item ~SET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Cross-Origin-Opener-Policy-Report-Only$h, `~item^i )
◎
Set parsedItem to the result of getting a structured field value given `Cross-Origin-Opener-Policy-Report-Only` and "item" from response's header list.
</li>
	<li>
<p>
~IF［
%構文解析した~item ~NEQ ~NULL
］：
◎
If parsedItem is not null, then:
</p>
		<ol>
			<li>
%値 ~LET %構文解析した~item の`値$sfI【！%構文解析した~item[ 0 ]】
◎
↓</li>
			<li>
<p>
~IF［
%値 は`~token$sfである【この条件は、この訳による補完】
］：
◎
↓</p>
				<ol>
					<li>
<p>
~IF［
%値 ~EQ `same-origin$coop
］：
◎
If parsedItem[0] is "same-origin", then:
</p>
						<ol>
							<li>
%~COEP ~LET `埋込元~施策を得する$( %応答, %予約-済み環境 )
◎
Let coep be the result of obtaining a cross-origin embedder policy from response and reservedEnvironment.
</li>
							<li>
<p>
%施策 の`報告のみの値$coOP ~SET ［
次が満たされるならば `same-origin-plus-COEP$coop ／
~ELSE_ `same-origin$coop
］
⇒
［
%~COEP の`値$embP ~EQ `require-corp$coep
］~OR［
%~COEP の`報告のみの値$embP ~EQ `require-corp$coep
］
</p>

<p class="note">注記：
報告のみの~COOPは、報告のみの~COEPも考慮した上で，特別な値 `same-origin-plus-COEP$coop をアテガう。
これは、［
~COOP, ~COEP
］の配備にあたって，より多くの自由度を開発者に許容する。
</p>
◎
If coep's value is "require-corp" or coep's report-only value is "require-corp", then set policy's report-only value to "same-origin-plus-COEP".
◎
Report only COOP also considers report-only COEP to assign the special "same-origin-plus-COEP" value. This allows developers more freedom in the order of deployment of COOP and COEP.
◎
Otherwise, set policy's report-only value to "same-origin".
</li>
						</ol>
					</li>
					<li>
~IF［
%値 ~EQ `same-origin-allow-popups$coop
］
⇒
%施策 の`報告のみの値$coOP ~SET `same-origin-allow-popups$coop
◎
If parsedItem[0] is "same-origin-allow-popups", then set policy's report-only value to "same-origin-allow-popups".
</li>
					<li>
%report-to ~LET %構文解析した~item の`~parameters$sfI[ `report-to$coop ]
◎
↓</li>
					<li>
~IF［
%report-to は`文字列$sfである
］
⇒
%施策 の`報告のみの報告先$coOP ~SET %report-to
◎
If parsedItem[1]["report-to"] exists and it is a string, then set policy's report-only reporting endpoint to parsedItem[1]["report-to"].
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %施策
◎
Return policy.
</li>
</ol>
</div>

			</section>
			<section id="browsing-context-group-switches-due-to-cross-origin-opener-policy">
<h4 title="Browsing context group switches due to cross-origin opener policy">7.7.2. 非同一-生成元~opener施策に因る閲覧文脈~groupの切替n</h4>

<div class="algo">
<p>
`~COOP値は閲覧文脈~groupの切替nを要求するかどうか検査する@
ときは、所与の
⇒＃
真偽値 %初期~about_blankか,
`生成元$ %応答の生成元,
`生成元$ %作動中の文書の~navi生成元,
`値$coOP %応答の~COOP値,
`値$coOP %作動中の文書の~COOP値
◎終
に対し：
◎
To check if COOP values require a browsing context group switch, given a boolean isInitialAboutBlank, two origins responseOrigin, activeDocumentNavigationOrigin, and two cross-origin opener policy values responseCOOPValue and activeDocumentCOOPValue:
</p>
<ol>
	<li>
~IF［
(
%作動中の文書の~COOP値,
%作動中の文書の~navi生成元,
%応答の~COOP値,
%応答の生成元 )
は、`非同一-生成元~opener施策~値として合致する$
］
⇒
~RET ~F
◎
If the result of matching activeDocumentCOOPValue, activeDocumentNavigationOrigin, responseCOOPValue, and responseOrigin is true, return false.
</li>
	<li>
<p>
~RET ［
次がすべて満たされるならば ~F ／
~ELSE_ ~T
］：
</p>
		<ul>
			<li>
%初期~about_blankか ~EQ ~T
</li>
			<li>
%作動中の文書の~COOP値 【！の`値$coOP】 ~EQ `same-origin-allow-popups$coop
</li>
			<li>
%応答の~COOP値 ~EQ `unsafe-none$coop
</li>
		</ul>
◎
If all of the following are true:
• isInitialAboutBlank,
• activeDocumentCOOPValue's value is "same-origin-allow-popups".
• responseCOOPValue is "unsafe-none",
then return false.
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`報告のみの~COOPの施行-法は閲覧文脈~groupの切替nを要求するかどうか検査する@
ときは、所与の
⇒＃
真偽値 %初期~about_blankか,
`生成元$ %応答の生成元,
`生成元$ %作動中の文書の~navi生成元,
`非同一-生成元~opener施策$ %応答の~COOP,
`非同一-生成元~opener施策$ %作動中の文書の~COOP
◎終
に対し：
◎
To check if enforcing report-only COOP would require a browsing context group switch, given a boolean isInitialAboutBlank, two origins responseOrigin, activeDocumentNavigationOrigin, and two cross-origin opener policies responseCOOP and activeDocumentCOOP:
</p>
<ol>
	<li>
<p>
~IF［
次の結果 ~EQ ~F
］…
⇒
`~COOP値は閲覧文脈~groupの切替nを要求するかどうか検査する$( 次に挙げる引数 )
⇒＃
%初期~about_blankか,
%応答の生成元,
%作動中の文書の~navi生成元,
%応答の~COOP の`報告のみの値$coOP,
%作動中の文書の報告のみの~COOP の`報告のみの値$coOP
◎終
…ならば
⇒
~RET ~F
◎
If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank, responseOrigin, activeDocumentNavigationOrigin, responseCOOP's report-only value and activeDocumentCOOPReportOnly's report-only value is false, then return false.
</p>

<p class="note">注記：
報告のみの施策の照合は、~web~siteに次を許容する
⇒
~web~siteに属する すべての~pageに対し、同じ［
報告のみの非同一-生成元~opener施策
］を指定して，それらの~page間の~naviに対しては違反~報告を受信しない。
◎
Matching report-only policies allows a website to specify the same report-only cross-origin opener policy on all its pages and not receive violation reports for navigations between these pages.
</p>
	</li>
	<li>
~IF［
次の結果 ~EQ ~T
］…
⇒
`~COOP値は閲覧文脈~groupの切替nを要求するかどうか検査する$( 次に挙げる引数 )
⇒＃
%初期~about_blankか,
%応答の生成元,
%作動中の文書の~navi生成元,
%応答の~COOP の`値$coOP,
%作動中の文書の報告のみの~COOP の`報告のみの値$coOP
◎終
…ならば
⇒
~RET ~T
◎
If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank, responseOrigin, activeDocumentNavigationOrigin, responseCOOP's value and activeDocumentCOOPReportOnly's report-only value is true, then return true.
</li>
	<li>
~IF［
次の結果 ~EQ ~T
］…
⇒
`~COOP値は閲覧文脈~groupの切替nを要求するかどうか検査する$( 次に挙げる引数 )
⇒＃
%初期~about_blankか,
%応答の生成元,
%作動中の文書の~navi生成元,
%応答の~COOP の`報告のみの値$coOP,
%作動中の文書の報告のみの~COOP の`値$coOP
◎終
…ならば
⇒
~RET ~T
◎
If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank, responseOrigin, activeDocumentNavigationOrigin, responseCOOP's report-only value and activeDocumentCOOPReportOnly's value is true, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<p>
`非同一-生成元~opener施策の施行n結果@
は、次に挙げる`~item$sctを伴う`構造体$である：
◎
A cross-origin opener policy enforcement result is a struct with the following items:
</p>
<ul>
	<li>
`閲覧文脈~groupの切替nは必要か@cooP
⇒
真偽値
— 初期~時は ~F とする。
◎
A boolean needs a browsing context group switch, initially false.
</li>
	<li>
`報告のみに因る閲覧文脈~groupの切替nは必要か@cooP
⇒
真偽値
— 初期~時は ~F とする。
◎
A boolean would need a browsing context group switch due to report-only, initially false.
</li>
	<li>
`~url@cooP
⇒
`~URL$
◎
A URL url.
</li>
	<li>
`生成元@cooP
⇒
`生成元$
◎
An origin current origin.
</li>
	<li>
`非同一-生成元~opener施策@cooP
⇒
`非同一-生成元~opener施策$。
◎
A cross-origin opener policy cross-origin opener policy.
</li>
	<li>
`現在の文脈は~navi~sourceか@cooP
⇒
真偽値。
◎
A boolean current context is navigation source.
</li>
</ul>

<div class="algo">
<p>
`応答の非同一-生成元~opener施策を施行する@
ときは、所与の
⇒＃
`閲覧文脈$ %B,
`~URL$ %応答~URL,
`生成元$ %応答の生成元,
`非同一-生成元~opener施策$ %応答の~COOP,
`非同一-生成元~opener施策の施行n結果$ %現在の~COOP施行n結果,
`~referrer$rq %~referrer
◎終
に対し：
◎
To enforce a response's cross-origin opener policy, given a browsing context browsingContext, a URL responseURL, an origin responseOrigin, a cross-origin opener policy responseCOOP, a cross-origin opener policy enforcement result currentCOOPEnforcementResult, and a referrer referrer:
</p>
<ol>
	<li>
%新たな~COOP施行n結果 ~LET 次のように設定された，新たな`非同一-生成元~opener施策の施行n結果$
⇒＃
`閲覧文脈~groupの切替nは必要か$cooP ~SET %現在の~COOP施行n結果 の`閲覧文脈~groupの切替nは必要か$cooP,
`報告のみに因る閲覧文脈~groupの切替nは必要か$cooP ~SET %現在の~COOP施行n結果 の`報告のみに因る閲覧文脈~groupの切替nは必要か$cooP,
`~url$cooP ~SET %応答~URL,
`生成元$cooP ~SET %応答の生成元,
`非同一-生成元~opener施策$cooP ~SET %応答の~COOP,
`現在の文脈は~navi~sourceか$cooP ~SET ~T
◎
Let newCOOPEnforcementResult be a new cross-origin opener policy enforcement result whose needs a browsing context group switch is currentCOOPEnforcementResult's needs a browsing context group switch, would need a browsing context group switch due to report-only is currentCOOPEnforcementResult's would need a browsing context group switch due to report-only, url is responseURL, origin is responseOrigin, coop is responseCOOP, and current context is navigation source is true.
</li>
	<li>
%初期~about_blankか ~LET ［
%B は`まだ初期~about_blank 文書である$ならば ~T ／
~ELSE_ ~F
］
◎
Let isInitialAboutBlank be true if browsingContext is still on its initial about:blank Document; otherwise, false.
</li>
	<li>
~IF［
%初期~about_blankか ~EQ ~T
］~AND［
%B の`初期~URL$bc ~EQ ~NULL
］
⇒
%B の`初期~URL$bc ~SET %応答~URL
◎
If isInitialAboutBlank is true and browsingContext's initial URL is null, set browsingContext's initial URL to responseURL.
</li>
	<li>
<p>
~IF［
次の結果 ~EQ ~T
］…
⇒
`~COOP値は閲覧文脈~groupの切替nを要求するかどうか検査する$( 次に挙げる引数 )
⇒＃
%初期~about_blankか,
%現在の~COOP施行n結果 の`非同一-生成元~opener施策$cooP の`値$coOP,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の~COOP の`値$coOP,
%応答の生成元
◎終
…ならば：
◎
If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank, currentCOOPEnforcementResult's cross-origin opener policy's value, currentCOOPEnforcementResult's origin, responseCOOP's value, and responseOrigin is true, then:
</p>
		<ol>
			<li>
%新たな~COOP施行n結果 の`閲覧文脈~groupの切替nは必要か$cooP ~SET ~T
◎
Set newCOOPEnforcementResult's needs a browsing context group switch to true.
</li>
			<li>
<p>
~IF［
%B の`~group$tbcG の`閲覧文脈~集合$bcGの`~size$ ~GT 1
］：
◎
If browsingContext's group's browsing context set's size is greater than 1, then:
</p>
				<ol>
					<li>
`~COOP応答へ~navigateするときの閲覧文脈~groupの切替n用に違反~報告を~queueする$( 次に挙げる引数 )
⇒＃
%応答の~COOP,
`enforce^l,
%応答~URL,
%現在の~COOP施行n結果 の`~url$cooP,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の生成元,
%~referrer
◎
Queue a violation report for browsing context group switch when navigating to a COOP response with responseCOOP, "enforce", responseURL, currentCOOPEnforcementResult's url, currentCOOPEnforcementResult's origin, responseOrigin, and referrer.
</li>
					<li>
`~COOP応答から~navigateして去るときの閲覧文脈~groupの切替n用に違反~報告を~queueする$( 次に挙げる引数 )
⇒＃
%作動中の文書の~COOP,
`enforce^l,
%現在の~COOP施行n結果 の`~url$cooP,
%応答~URL,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の生成元,
%現在の~COOP施行n結果 の`現在の文脈は~navi~sourceか$cooP
◎
Queue a violation report for browsing context group switch when navigating away from a COOP response with activeDocumentCOOP, "enforce", currentCOOPEnforcementResult's url, responseURL, currentCOOPEnforcementResult's origin, responseOrigin, and currentCOOPEnforcementResult's current context is navigation source.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
次の結果 ~EQ ~T
］…
⇒
`報告のみの~COOPの施行-法は閲覧文脈~groupの切替nを要求するかどうか検査する$( 次に挙げる引数 )
⇒＃
%初期~about_blankか,
%応答の生成元,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の~COOP,
%現在の~COOP施行n結果 の`非同一-生成元~opener施策$cooP
◎終
…ならば：
◎
If the result of checking if enforcing report-only COOP would require a browsing context group switch given isInitialAboutBlank, responseOrigin, currentCOOPEnforcementResult's origin, responseCOOP, and currentCOOPEnforcementResult's cross-origin opener policy, is true, then:
</p>
		<ol>
			<li>
%結果 の`報告のみに因る閲覧文脈~groupの切替nは必要か$cooP ~SET ~T
◎
Set result's would need a browsing context group switch due to report-only to true.
</li>
			<li>
<p>
~IF［
%B の`~group$tbcG の`閲覧文脈~集合$bcGの`~size$ ~GT 1
］：
◎
If browsingContext's group's browsing context set's size is greater than 1, then:
</p>
				<ol>
					<li>
`~COOP応答へ~navigateするときの閲覧文脈~groupの切替n用に違反~報告を~queueする$( 次に挙げる引数 )
⇒＃
%応答の~COOP,
`reporting^l,
%応答~URL,
%現在の~COOP施行n結果 の`~url$cooP,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の生成元,
%~referrer
◎
Queue a violation report for browsing context group switch when navigating to a COOP response with responseCOOP, "reporting", responseURL, currentCOOPEnforcementResult's url, currentCOOPEnforcementResult's origin, responseOrigin, and referrer.
</li>
					<li>
`~COOP応答から~navigateして去るときの閲覧文脈~groupの切替n用に違反~報告を~queueする$( 次に挙げる引数 )
⇒＃
%作動中の文書の~COOP,
`reporting^l,
%現在の~COOP施行n結果 の`~url$cooP,
%応答~URL,
%現在の~COOP施行n結果 の`生成元$cooP,
%応答の生成元,
%現在の~COOP施行n結果 の`現在の文脈は~navi~sourceか$cooP
◎
Queue a violation report for browsing context group switch when navigating away from a COOP response with activeDocumentCOOP, "reporting", currentCOOPEnforcementResult's url, responseURL, currentCOOPEnforcementResult's origin, responseOrigin, and currentCOOPEnforcementResult's current context is navigation source.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %新たな~COOP施行n結果
◎
Return newCOOPEnforcementResult.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navi応答~用に利用する閲覧文脈を得する@
ときは、所与の
⇒＃
`閲覧文脈$ %B,
`~sandbox法~flag集合$ %~sandbox~flags,
`非同一-生成元~opener施策$ %~navi~COOP,
`非同一-生成元~opener施策の施行n結果$ %~COOP施行n結果
◎終
に対し：
◎
To obtain a browsing context to use for a navigation response, given a browsing contexts browsingContext, a sandboxing flag set sandboxFlags, a cross-origin opener policy navigationCOOP, and a cross-origin opener policy enforcement result coopEnforcementResult:
</p>
<ol>
	<li>
~Assert：
%B は`~top-level閲覧文脈$である。
◎
Assert: browsingContext is a top-level browsing context.
</li>
	<li>
<p>
~IF［
%~COOP施行n結果 の`閲覧文脈~groupの切替nは必要か$cooP ~EQ ~F
］：
◎
If coopEnforcementResult's needs a browsing context group switch is false, then:
</p>
		<ol>
			<li>
~IF［
%~COOP施行n結果 の`報告のみに因る閲覧文脈~groupの切替nは必要か$cooP ~EQ ~T
］
⇒
%閲覧文脈 の`~virtual閲覧文脈~group~ID$bc ~SET 新たな一意な識別子
◎
If coopEnforcementResult's would need a browsing context group switch due to report-only is true, set browsing context's virtual browsing context group ID to a new unique identifier.
</li>
			<li>
~RET %B
◎
Return browsingContext.
</li>
		</ol>
	</li>
	<li>
%新たな閲覧文脈 ~LET `新たな~top-level閲覧文脈を作成する$()
◎
Let newBrowsingContext be the result of creating a new top-level browsing context.
</li>
	<li>
<p>
~IF［
%~navi~COOP の`値$coOP ~EQ `same-origin-plus-COEP$coop
］
⇒
%新たな閲覧文脈 の`~group$tbcGの`非同一-生成元~隔離~mode$bcG ~SET ［
`logical$coI ／ `concrete$coI
］
— どちらが選ばれるかは、`実装定義$とする
◎
If navigationCOOP's value is "same-origin-plus-COEP", then set newBrowsingContext's group's cross-origin isolation mode to either "logical" or "concrete". The choice of which is implementation-defined.
</p>

<p class="note">注記：
【（この段落より詳細な）`非同一-生成元~隔離~mode$に付随する注記を見よ。】
◎
It is difficult on some platforms to provide the security properties required by the cross-origin isolated capability. "concrete" grants access to it and "logical" does not.
</p>
	</li>
	<li>
<p>
~IF［
%~sandbox~flags は空でない
］：
◎
If sandboxFlags is not empty, then:
</p>
		<ol>
			<li>
~Assert：
%~navi~COOP の`値$coOP ~EQ `unsafe-none$coop
◎
Assert navigationCOOP's value is "unsafe-none".
</li>
			<li>
~Assert：
%新たな閲覧文脈 の`~popup~sandbox法~flag集合$は`空$である。
◎
Assert: newBrowsingContext's popup sandboxing flag set is empty.
</li>
			<li>
%新たな閲覧文脈 の`~popup~sandbox法~flag集合$ ~SET %~sandbox~flags を`~cloneする$
◎
Set newBrowsingContext's popup sandboxing flag set to a clone of sandboxFlags.
</li>
		</ol>
	</li>
	<li>
<p>
`閲覧文脈を破棄する$( %B )
◎
Discard browsingContext.
</p>

<p class="note">注記：
これによる %B の`~group$tbcGに対する効果は無いが、その`閲覧文脈~集合$bcGが【！当の`閲覧文脈~group$を成す`~top-level閲覧文脈$が】
%B のみからなる事例では、~UAは，空になったそれを削除するであろう。
◎
This has no effect on browsingContext's group, unless browsingContext was its sole top-level browsing context. In that case, the user agent might delete the browsing context group which no longer contains any browsing contexts.
</p>
	</li>
	<li>
~RET %新たな閲覧文脈
◎
Return newBrowsingContext.
</li>
</ol>

<p class="XXX">
~naviに後続して，閲覧文脈~groupどうしを入れ替えることによる影響iは、全部的には定義されていない。
現時点では、
<a href="~HTMLissue/5350">課題 #5350</a>
にて論の最中にある。
◎
The impact of swapping browsing context groups following a navigation is not fully defined. It is currently under discussion in issue #5350.
</p>
</div>

			</section>
			<section id="reporting">
<h4 title="Reporting">7.7.3 報告-法</h4>

<p>
`~accessedと~accessorの関係性@
は、`閲覧文脈$どうしで~accessが起きたときの関係性を述べる列挙値であり，次に挙げる値をとり得る：
◎
An accessor-accessed relationship is an enum that describes the relationship between two browsing contexts between which an access happened. It can take the following values:
</p>
<dl class="def-list">
	<dt>
`~accessorは~opener@i
◎
accessor is opener
</dt>
	<dd>
［
~accessorである`閲覧文脈$または その`先祖~閲覧文脈$
］のいずれかが，［
~accessedである`閲覧文脈$の`~top-level閲覧文脈$
］を`開いた閲覧文脈$である。
◎
The accessor browsing context or one of its ancestors is the opener browsing context of the accessed browsing context's top-level browsing context.
</dd>

	<dt>
`~accessorは~openee@i
◎
accessor is openee
</dt>
	<dd>
［
~accessedである`閲覧文脈$または その`先祖~閲覧文脈$
］のいずれかが，［
~accessorである`閲覧文脈$の`~top-level閲覧文脈$
］を`開いた閲覧文脈$である。
◎
The accessed browsing context or one of its ancestors is the opener browsing context of the accessor browsing context's top-level browsing context.
</dd>
	<dt>
`~~無関係@i
◎
none
</dt>
	<dd>
上述した どちらにも該当しない。
◎
There is no opener relationship between the accessor browsing context, the accessor browsing context, or any of their ancestors.
</dd>
</dl>

<div class="algo">
<p>
`閲覧文脈どうしの~accessは報告されるべきかどうか検査する@
ときは、所与の
⇒＃
`閲覧文脈$ %~accessor
`閲覧文脈$ %~accessed,
~JS~prop名 %P,
`環境~設定群~obj$ %環境
◎終
に対し：
◎
To check if an access between two browsing contexts should be reported, given two browsing contexts accessor and accessed, a JavaScript property name P, and an environment settings object environment:
</p>
<ol>
	<li>
~IF［
%P は`非同一-生成元から~access可能な~window~prop名$でない
］
⇒
~RET
◎
If P is not a cross-origin accessible window property name, then return.
</li>
	<li>
%~accessorの~top-level閲覧文脈 ~LET %~accessor の`~top-level閲覧文脈$
◎
↓</li>
	<li>
%~accessedの~top-level閲覧文脈 ~LET %~accessed の`~top-level閲覧文脈$
◎
↓</li>
	<li>
%~accessorと先祖たち ~LET ［
%~accessor, その`先祖~閲覧文脈$たち
］が成す集合
◎
↓</li>
	<li>
%~accessedと先祖たち ~LET ［
%~accessed, その`先祖~閲覧文脈$たち
］が成す集合
◎
↓</li>
	<li>
<div class="p">
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
次を満たす %閲覧文脈 ~IN %~accessorと先祖たち が在る
⇒
%閲覧文脈 にて`作動中の文書$の`生成元$doc
~NEQ`生成元$sub
%~accessorの~top-level閲覧文脈 にて`作動中の文書$の`生成元$doc
</li>
			<li>
次を満たす %閲覧文脈 ~IN %~accessedと先祖たち が在る
⇒
%閲覧文脈 にて`作動中の文書$の`生成元$doc
~NEQ`生成元$sub
%~accessedの~top-level閲覧文脈 にて`作動中の文書$の`生成元$doc
</li>
		</ul>
<p>
…ならば
⇒
~RET
</p>
◎
If accessor's active document's origin or any of its ancestors' active document's origins are not same origin with accessor's top-level browsing context's active document's origin,＼
or if accessed's active document's origin or any of its ancestors' active document's origins are not same origin with accessed's top-level browsing context's active document's origin, then return.
</div>

<p class="note">注記：
これは、非同一-生成元に属する~iframeについての情報が，非同一-生成元~opener施策を報告している~top-levelの~frameへ漏洩するのを避ける。
◎
This avoids leaking information about cross-origin iframes to a top level frame with cross-origin opener policy reporting
</p>
	</li>
	<li>
~IF［
%~accessorの~top-level閲覧文脈 の`~virtual閲覧文脈~group~ID$bc
~EQ
%~accessedの~top-level閲覧文脈 の`~virtual閲覧文脈~group~ID$bc
］
⇒
~RET
◎
If accessor's top-level browsing context's virtual browsing context group ID is accessed's top-level browsing context's virtual browsing context group ID, then return.
</li>
	<li>
%~accessedと~accessorの関係性 ~LET 【！新たな`~accessedと~accessorの関係性$】`~~無関係$i
◎
Let accessorAccessedRelationship be a new accessor-accessed relationship with value none.
</li>
	<li>
~IF［
%~accessedの~top-level閲覧文脈 を`開いた閲覧文脈$ ~IN %~accessorと先祖たち
］
⇒
%~accessedと~accessorの関係性 ~SET `~accessorは~opener$i
◎
If accessed's top-level browsing context's opener browsing context is accessor or an ancestor of accessor, then set accessorAccessedRelationship to accessor is opener.
</li>
	<li>
~IF［
%~accessorの~top-level閲覧文脈 を`開いた閲覧文脈$ ~IN %~accessedと先祖たち
］
⇒
%~accessedと~accessorの関係性 ~SET `~accessorは~openee$i
◎
If accessor's top-level browsing context's opener browsing context is accessed or an ancestor of accessed, then set accessorAccessedRelationship to accessor is openee.
</li>
	<li>
`各種~access用に違反~報告を~queueする$( 次に挙げる引数 )
⇒＃
%~accessedと~accessorの関係性,
%~accessorの~top-level閲覧文脈 にて`作動中の文書$の`非同一-生成元~opener施策$doc,
%~accessedの~top-level閲覧文脈 にて`作動中の文書$の`非同一-生成元~opener施策$doc,
%~accessor にて`作動中の文書$の`~URL$doc,
%~accessed にて`作動中の文書$の`~URL$doc,
%~accessorの~top-level閲覧文脈 の`初期~URL$bc,
%~accessedの~top-level閲覧文脈 の`初期~URL$bc,
%~accessor にて`作動中の文書$の`生成元$doc,
%~accessed にて`作動中の文書$の`生成元$doc,
%~accessorの~top-level閲覧文脈 の`作成時の~opener生成元$bc,
%~accessedの~top-level閲覧文脈 の`作成時の~opener生成元$bc,
%~accessorの~top-level閲覧文脈 にて`作動中の文書$の`~referrer$doc,
%~accessedの~top-level閲覧文脈 にて`作動中の文書$の`~referrer$doc,
%P,
%環境
◎
Queue violation reports for accesses, given accessorAccessedRelationship, accessor's top-level browsing context's active document's cross-origin opener policy, accessed's top-level browsing context's active document's cross-origin opener policy, accessor's active document's URL, accessed's active document's URL, accessor's top-level browsing context's initial URL, accessed's top-level browsing context's initial URL, accessor's active document's origin, accessed's active document's origin, accessor's top-level browsing context's opener origin at creation, accessed's top-level browsing context's opener origin at creation, accessor's top-level browsing context's active document's referrer, accessed's top-level browsing context's active document's referrer, P, and environment.
</li>
</ol>
</div>

<div class="algo">
<p>
`報告~内に送信する~URLを無毒化する@
ときは、所与の
( `~URL$ %~URL )
に対し：
◎
To sanitize a URL to send in a report given a URL url:
</p>
<ol>
	<li>
%無毒化した~URL ~LET %~URL の複製
◎
Let sanitizedURL be a copy of url.
</li>
	<li>
`~URLの~usernameを設定する$( %無毒化した~URL, 空~文字列 )
◎
Set the username given sanitizedURL and the empty string.
</li>
	<li>
`~URLの~passwordを設定する$( %無毒化した~URL, 空~文字列 )
◎
Set the password given sanitizedURL and the empty string.
</li>
	<li>
~RET `~URLを直列化する$( %無毒化した~URL, `素片は除外する$i )
◎
Return the serialization of sanitizedURL with exclude fragment set to true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~COOP応答へ~navigateするときの閲覧文脈~groupの切替n用に違反~報告を~queueする@
ときは、所与の
⇒＃
`非同一-生成元~opener施策$ %~COOP,
文字列 %処置,
`~URL$ %~COOP~URL,
`~URL$ %以前の応答の~URL,
`生成元$ %~COOP生成元
`生成元$ %以前の応答の生成元,
`~referrer$rq %~referrer
◎終
に対し：
◎
To queue a violation report for browsing context group switch when navigating to a COOP response given a cross-origin opener policy coop, a string disposition, a URL coopURL, a URL previousResponseURL, two origins coopOrigin and previousResponseOrigin, and a referrer referrer:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
%~COOP値 ~LET %処置 に応じて
⇒＃
`reporting^l ならば %~COOP の`報告のみの値$coOP ／
~ELSE_ %~COOP の`値$coOP
◎
Let coopValue be coop's value.
◎
If disposition is "reporting", then set coopValue to coop's report-only value.
</li>
	<li>
%直列化した~referrer ~LET %~referrer に応じて
⇒＃
`~URL$であるならば `~URLを直列化する$( %~referrer ) ／
~ELSE_ %~referrer
◎
Let serializedReferrer be an empty string
◎
If referrer is a URL, set serializedReferrer to the serialization of referrer.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
</thead><tbody>

<tr><td>`disposition^c
<td>%処置

<tr><td>`effectivePolicy^c
<td>%~COOP値

<tr><td>`previousResponseURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %以前の応答の生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %以前の応答~URL )

<tr><td>`referrer^c
<td>%直列化した~referrer

<tr><td>`type^c
<td>`navigation-to-response^l
</tbody></table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜disposition
• effectivePolicy｜coopValue
• previousResponseURL｜If coopOrigin and previousResponseOrigin are same origin this is the sanitization of previousResponseURL, null otherwise.
• referrer｜serializedReferrer
• type｜"navigation-to-response"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, ε, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`~COOP応答から~navigateして去るときの閲覧文脈~groupの切替n用に違反~報告を~queueする@
ときは、所与の
⇒＃
`非同一-生成元~opener施策$ %~COOP,
文字列 %処置,
`~URL$ %~COOP~URL,
`~URL$ %以後の応答の~URL,
`生成元$ %~COOP生成元
`生成元$ %以後の応答の生成元,
真偽値 %~COOP応答は~navi~sourceか
◎終
に対し：
◎
To queue a violation report for browsing context group switch when navigating away from a COOP response given a cross-origin opener policy coop, a string disposition, a URL coopURL, a URL nextResponseURL, two origins coopOrigin and nextResponseOrigin, and a boolean isCOOPResponseNavigationSource:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
%~COOP値 ~LET %処置 に応じて
⇒＃
`reporting^l ならば %~COOP の`報告のみの値$coOP ／
~ELSE_ %~COOP の`値$coOP
◎
Let coopValue be coop's value.
◎
If disposition is "reporting", then set coopValue to coop's report-only value.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
</thead><tbody>

<tr><td>`disposition^c
<td>%処置

<tr><td>`effectivePolicy^c
<td>%~COOP値

<tr><td>`nextResponseURL^c
<td>
［
%~COOP生成元 ~EQ`生成元$sub %以後の応答の生成元
］~AND［
%~COOP応答は~navi~sourceか ~EQ ~T
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %以前の応答~URL )

<tr><td>`type^c
<td>`navigation-to-response^l
</tbody></table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜disposition
• effectivePolicy｜coopValue
• nextResponseURL｜If coopOrigin and nextResponseOrigin are same origin or isCOOPResponseNavigationSource is true, this is the sanitization of previousResponseURL, null otherwise.
• type｜"navigation-to-response"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, ε, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`各種~access用に違反~報告を~queueする@
ときは、所与の
⇒＃
`~accessedと~accessorの関係性$ %~accessedと~accessorの関係性,
`非同一-生成元~opener施策$ %~accessorの~COOP,
`非同一-生成元~opener施策$ %~accessedの~COOP,
`~URL$ %~accessorの~URL,
`~URL$ %~accessedの~URL,
`~URL$ %~accessorの初期~URL,
`~URL$ %~accessedの初期~URL,
`生成元$ %~accessorの生成元,
`生成元$ %~accessedの生成元,
`生成元$ %~accessorの作成元の生成元
`生成元$ %~accessedの作成元の生成元,
`~referrer$doc %~accessorの~referrer,
`~referrer$doc %~accessedの~referrer,
文字列 %~prop名,
`環境~設定群~obj$ %環境
◎終
に対し：
◎
To queue violation reports for accesses, given an accessor-accessed relationship accessorAccessedRelationship, two cross-origin opener policies accessorCOOP and accessedCOOP, four URLs accessorURL, accessedURL, accessorInitialURL, accessedInitialURL, four origins accessorOrigin, accessedOrigin, accessorCreatorOrigin and accessedCreatorOrigin, two referrers accessorReferrer and accessedReferrer, a string propertyName, and an environment settings object environment:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
%~COOP値 ~LET %処置 に応じて
⇒＃
`reporting^l ならば %~COOP の`報告のみの値$coOP ／
~ELSE_ %~COOP の`値$coOP
◎
Let coopValue be coop's value.
◎
If disposition is "reporting", then set coopValue to coop's report-only value.
</li>
	<li>
<p>
~IF［
%~accessedと~accessorの関係性 ~EQ `~accessorは~opener$i
］：
◎
If accessorAccessedRelationship is accessor is opener:
</p>
		<ol>
			<li>
`~openした~windowへの~access用に違反~報告を~queueする$( 次に挙げる引数 )
⇒＃
%~accessorの~COOP,
%~accessorの~URL,
%~accessedの~URL,
%~accessedの初期~URL,
%~accessorの生成元,
%~accessedの生成元,
%~accessedの作成元の生成元,
%~prop名,
%環境
◎
Queue a violation report for access to an opened window, given accessorCOOP, accessorURL, accessedURL, accessedInitialURL, accessorOrigin, accessedOrigin, accessedCreatorOrigin, propertyName, and environment.
</li>
			<li>
`~openerからの~access用に違反~報告を~queueする$( 次に挙げる引数 )
⇒＃
%~accessedの~COOP,
%~accessedの~URL,
%~accessorの~URL,
%~accessedの生成元,
%~accessorの生成元,
%~prop名,
%~accessedの~referrer
◎
Queue a violation report for access from the opener, given accessedCOOP, accessedURL, accessorURL, accessedOrigin, accessorOrigin, propertyName, and accessedReferrer.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%~accessedと~accessorの関係性 ~EQ `~accessorは~openee$i
］：
◎
Otherwise, if accessorAccessedRelationship is accessor is openee:
</p>
		<ol>
			<li>
`~openerへの~access用に違反~報告を~queueする$( 次に挙げる引数 )
⇒＃
%~accessorの~COOP,
%~accessorの~URL,
%~accessedの~URL,
%~accessorの生成元,
%~accessedの生成元,
%~prop名,
%~accessorの~referrer,
%環境
◎
Queue a violation report for access to the opener, given accessorCOOP, accessorURL, accessedURL, accessorOrigin, accessedOrigin, propertyName, accessorReferrer, and environment.
</li>
			<li>
`~openした~windowからの~access用に違反~報告を~queueする$( 次に挙げる引数 )
⇒＃
%~accessedの~COOP,
%~accessedの~URL,
%~accessorの~URL,
%~accessorの初期~URL,
%~accessedの生成元,
%~accessorの生成元,
%~accessorの作成元の生成元,
%~prop名
◎
Queue a violation report for access from an opened window, given accessedCOOP, accessedURL, accessorURL, accessorInitialURL, accessedOrigin, accessorOrigin, accessorCreatorOrigin, and propertyName.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
`~openした~windowへの~access用に違反~報告を~queueする$( 次に挙げる引数 )
⇒＃
%~accessorの~COOP,
%~accessorの~URL,
%~accessedの~URL,
%~accessorの生成元,
%~accessedの生成元,
%~prop名,
%環境
◎
Queue a violation report for access to another window, given accessorCOOP, accessorURL, accessedURL, accessorOrigin, accessedOrigin, propertyName, and environment
</li>
			<li>
`別の~windowからの~access用に違反~報告を~queueする$( 次に挙げる引数 )
⇒＃
%~accessedの~COOP,
%~accessedの~URL,
%~accessorの~URL,
%~accessedの生成元,
%~accessorの生成元,
%~prop名
◎
Queue a violation report for access from another window, given accessedCOOP, accessedURL, accessorURL, accessedOrigin, accessorOrigin, and propertyName.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~openerへの~access用に違反~報告を~queueする@
ときは、所与の
⇒＃
`非同一-生成元~opener施策$ %~COOP,
`~URL$ %~COOP~URL,
`~URL$ %~openerの~URL,
`生成元$ %~COOP生成元,
`生成元$ %~openerの生成元,
文字列 %~prop名,
`~referrer$rq %~referrer,
`環境~設定群~obj$ %環境
◎終
に対し：
◎
To queue a violation report for access to the opener, given a cross-origin opener policy coop, two URLs coopURL and openerURL, two origins coopOrigin and openerOrigin, a string propertyName, a referrer referrer, and an environment settings object environment:
</p>
<ol>
	<li>
( %~source~file, ( %行番号, %列番号 ) )
~LET この報告を誘発した関連な~scriptの ( ~URL, 問題になり得る位置 )
◎
Let sourceFile, lineNumber and columnNumber be the relevant script URL and problematic position which triggered this report.
</li>
	<li>
%直列化した~referrer ~LET %~referrer に応じて
⇒＃
`~URL$であるならば `~URLを直列化する$( %~referrer ) ／
~ELSE_ %~referrer
◎
Let serializedReferrer be an empty string
◎
If referrer is a URL, set serializedReferrer to the serialization of referrer.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
</thead><tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`property^c
<td>%~prop名

<tr><td>`openerURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openerの生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %~openerの~URL )

<tr><td>`referrer^c
<td>%直列化した~referrer

<tr><td>`sourceFile^c
<td>%~source~file

<tr><td>`lineNumber^c
<td>%行番号

<tr><td>`columnNumber^c
<td>%列番号

<tr><td>`type^c
<td>`access-to-opener^l
</tbody></table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coop's report-only value
• property｜propertyName
• openerURL｜If coopOrigin and openerOrigin are same origin, this is the sanitization of openerURL, null otherwise.
• referrer｜serializedReferrer
• sourceFile｜sourceFile
• lineNumber｜lineNumber
• columnNumber｜columnNumber
• type｜"access-to-opener"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, %環境, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL and environment.
</li>
</ol>
</div>

<div class="algo">
<p>
`~openした~windowへの~access用に違反~報告を~queueする@
ときは、所与の
⇒＃
`非同一-生成元~opener施策$ %~COOP,
`~URL$ %~COOP~URL,
`~URL$ %~openした~windowの~URL,
`~URL$ %初期~window~URL,
`生成元$ %~COOP生成元,
`生成元$ %~openした~windowの生成元,
`生成元$ %~openerの初期~生成元,
文字列 %~prop名,
`環境~設定群~obj$ %環境
◎終
に対し：
◎
To queue a violation report for access to an opened window, given a cross-origin opener policy coop, three URLs coopURL, openedWindowURL and initialWindowURL, three origins coopOrigin, openedWindowOrigin, and openerInitialOrigin, a string propertyName, and an environment settings object environment:
</p>
<ol>
	<li>
( %~source~file, ( %行番号, %列番号 ) )
~LET この報告を誘発した関連な~scriptの ( ~URL, 問題になり得る位置 )
◎
Let sourceFile, lineNumber and columnNumber be the relevant script URL and problematic position which triggered this report.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
</thead><tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`property^c
<td>%~prop名

<tr><td>`openedWindowURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openした~windowの生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %~openした~windowの~URL )

<tr><td>`openedWindowInitialURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openerの初期~生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %初期~window~URL ).

<tr><td>`sourceFile^c
<td>%~source~file

<tr><td>`lineNumber^c
<td>%行番号

<tr><td>`columnNumber^c
<td>%列番号

<tr><td>`type^c
<td>`access-to-opener^l
</tbody></table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coop's report-only value
• property｜propertyName
• openedWindowURL｜If coopOrigin and openedWindowOrigin are same origin, this is the sanitization of openedWindowURL, null otherwise.
• openedWindowInitialURL｜If coopOrigin and openerInitialOrigin are same origin, this is the sanitization of initialWindowURL, null otherwise.
• sourceFile｜sourceFile
• lineNumber｜lineNumber
• columnNumber｜columnNumber
• type｜"access-to-opener"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, %環境, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL and environment.
</li>
</ol>
</div>

<div class="algo">
<p>
`別の~windowへの~access用に違反~報告を~queueする@
ときは、所与の
⇒＃
`非同一-生成元~opener施策$ %~COOP,
`~URL$ %~COOP~URL,
`~URL$ %他の~URL,
`生成元$ %~COOP生成元
`生成元$ %他の生成元,
文字列 %~prop名,
`環境~設定群~obj$ %環境
◎終
に対し：
◎
To queue a violation report for access to another window, given a cross-origin opener policy coop, two URLs coopURL and otherURL, two origins coopOrigin and otherOrigin, a string propertyName, and an environment settings object environment:
</p>
<ol>
	<li>
( %~source~file, ( %行番号, %列番号 ) )
~LET この報告を誘発した関連な~scriptの ( ~URL, 問題になり得る位置 )
◎
Let sourceFile, lineNumber and columnNumber be the relevant script URL and problematic position which triggered this report.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
</thead><tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`property^c
<td>%~prop名

<tr><td>`otherURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %他の生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %他の~URL )

<tr><td>`sourceFile^c
<td>%~source~file

<tr><td>`lineNumber^c
<td>%行番号

<tr><td>`columnNumber^c
<td>%列番号

<tr><td>`type^c
<td>`access-to-opener^l
</tbody></table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coop's report-only value
• property｜propertyName
• otherURL｜If coopOrigin and otherOrigin are same origin, this is the sanitization of otherURL, null otherwise.
• sourceFile｜sourceFile
• lineNumber｜lineNumber
• columnNumber｜columnNumber
• type｜"access-to-opener"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, %環境, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL and environment.
</li>
</ol>
</div>

<div class="algo">
<p>
`~openerからの~access用に違反~報告を~queueする@
ときは、所与の
⇒＃
`非同一-生成元~opener施策$ %~COOP,
`~URL$ %~COOP~URL,
`~URL$ %~openerの~URL,
`生成元$ %~COOP生成元,
`生成元$ %~openerの生成元,
文字列 %~prop名,
`~referrer$rq %~referrer
◎終
に対し：
◎
To queue a violation report for access from the opener, given a cross-origin opener policy coop, two URLs coopURL and openerURL, two origins coopOrigin and openerOrigin, a string propertyName, and a referrer referrer:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
%直列化した~referrer ~LET %~referrer に応じて
⇒＃
`~URL$であるならば `~URLを直列化する$( %~referrer ) ／
~ELSE_ %~referrer
◎
Let serializedReferrer be an empty string
◎
If referrer is a URL, set serializedReferrer to the serialization of referrer.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
</thead><tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`property^c
<td>%~prop名

<tr><td>`openerURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openerの生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %~openerの~URL )

<tr><td>`referrer^c
<td>%直列化した~referrer

<tr><td>`type^c
<td>`access-to-opener^l
</tbody></table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coop's report-only value
• property｜propertyName
• openerURL｜If coopOrigin and openerOrigin are same origin, this is the sanitization of openerURL, null otherwise.
• referrer｜serializedReferrer
• type｜"access-to-opener"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, ε, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`~openした~windowからの~access用に違反~報告を~queueする@
ときは、所与の
⇒＃
`非同一-生成元~opener施策$%~COOP,
`~URL$ %~COOP~URL,
`~URL$ %~openした~windowの~URL,
`~URL$ %初期~window~URL,
`生成元$ %~COOP生成元,
`生成元$ %~openした~windowの生成元,
`生成元$ %~openerの初期~生成元,
文字列 %~prop名
◎終
に対し：
◎
To queue a violation report for access from an opened window, given a cross-origin opener policy coop, three URLs coopURL, openedWindowURL and initialWindowURL, three origins coopOrigin, openedWindowOrigin, and openerInitialOrigin, and a string propertyName:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
</thead><tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP値

<tr><td>`property^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`openedWindowURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openした~windowの生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %~openした~windowの~URL )

<tr><td>`openedWindowInitialURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %~openerの初期~生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %初期~window~URL )

<tr><td>`type^c
<td>`access-to-opener^l
</tbody></table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coopValue
• property｜coop's report-only value
• openedWindowURL｜If coopOrigin and openedWindowOrigin are same origin, this is the sanitization of openedWindowURL, null otherwise.
• openedWindowInitialURL｜If coopOrigin and openerInitialOrigin are same origin, this is the sanitization of initialWindowURL, null otherwise.
• type｜"access-to-opener"
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, ε, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`別の~windowからの~access用に違反~報告を~queueする@
ときは、所与の
⇒＃
`非同一-生成元~opener施策$ %~COOP,
`~URL$ %~COOP~URL,
`~URL$ %他の~URL,
`生成元$ %~COOP生成元,
`生成元$ %他の生成元,
文字列 %~prop名
◎終
に対し：
◎
To queue a violation report for access from another window, given a cross-origin opener policy coop, two URLs coopURL and otherURL, two origins coopOrigin and otherOrigin, and a string propertyName:
</p>
<ol>
	<li>
~IF［
%~COOP の`報告先$coOP ~EQ ~NULL
］
⇒
~RET
◎
If coop's reporting endpoint is null, return.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
</thead><tbody>

<tr><td>`disposition^c
<td>`reporting^l

<tr><td>`effectivePolicy^c
<td>%~COOP の`報告のみの値$coOP

<tr><td>`property^c
<td>%~prop名

<tr><td>`otherURL^c
<td>［
%~COOP生成元 ~EQ`生成元$sub %他の生成元
］ならば次の結果／
~ELSE_ ~NULL
⇒
`報告~内に送信する~URLを無毒化する$( %他の~URL )
<tr><td>`type^c
<td>`access-to-opener^c
</tbody></table>

◎
Let body be a new object containing the following properties:
• key｜value
• disposition｜"reporting"
• effectivePolicy｜coop's report-only value
• property｜propertyName
• otherURL｜If coopOrigin and otherOrigin are same origin, this is the sanitization of otherURL, null otherwise.
• type｜access-to-opener
</li>
	<li>
`報告を~queueする$( %本体, `coop^l, %~COOP の`報告先$coOP, ε, %~COOP~URL )
◎
Queue body as "coop" for coop's reporting endpoint with coopURL.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="coep">
<h3 title="Cross-origin embedder policies">7.8 非同一-生成元~埋込元~施策</h3>

<p>
`埋込元~施策~値@
は、資源~所有者からの明示的な許可を伴わずに，非同一-生成元~資源の~fetchingを制御する。
そのような値には、次の 2 つがある：
◎
An embedder policy value controls the fetching of cross-origin resources without explicit permission from resource owners. There are two such values:
</p>

<dl class="def-list">
	<dt>`unsafe-none@coep</dt>
	<dd>
これが既定の値。
この値が利用されたときは、非同一-生成元~資源は［
`~CORS~protocol$ ／
`Cross-Origin-Resource-Policy$h ~header
］通して明示的な許可を与えることなく~fetchできるようになる。
◎
This is the default value. When this value is used, cross-origin resources can be fetched without giving explicit permission through the CORS protocol or the `Cross-Origin-Resource-Policy` header.
</dd>

	<dt>`require-corp@coep</dt>
	<dd>
この値が利用されたときは、非同一-生成元~資源を~fetchするときに，~serverによる［
`~CORS~protocol$ ／
`Cross-Origin-Resource-Policy$h ~header
］を通した明示的な許可が要求される。
◎
When this value is used, fetching cross-origin resources requires the server's explicit permission through the CORS protocol or the `Cross-Origin-Resource-Policy` header.
</dd>
</dl>

<p>
`埋込元~施策@
【略称 “COEP” 】は、次に挙げるものからなる：
◎
An embedder policy consists of:
</p>
<ul>
	<li>
`値@embP
⇒
`埋込元~施策~値$
— 初期~時は `unsafe-none$coep とする。
◎
A value, which is an embedder policy value, initially "unsafe-none".
</li>
	<li>
`報告先@embP
⇒
文字列
— 初期~時は空~文字列とする。
◎
A reporting endpoint string, initially the empty string.
</li>
	<li>
`報告のみの値@embP
⇒
`埋込元~施策~値$
— 初期~時は `unsafe-none$coep とする。
◎
A report only value, which is an embedder policy value, initially "unsafe-none".
</li>
	<li>
`報告のみの報告先@embP
⇒
文字列
— 初期~時は空~文字列とする。
◎
A report only reporting endpoint string, initially the empty string.
</li>
</ul>

<p>
`~COEP報告~種別@i
は、
`coep^l を値にとる`報告~種別$であり，`報告用~観測器から可視$であるとする。
◎
The "coep" report type is a report type whose value is "coep". It is visible to ReportingObservers.
</p>

			<section id="the-headers-2">
<h4 title="The headers">7.8.1 各種~header</h4>

<p>
［
`Cross-Origin-Embedder-Policy$h ／
`Cross-Origin-Embedder-Policy-Report-Only$h
］~HTTP応答~headerは、［
`環境~設定群~obj$用に`埋込元~施策$を宣言すること
］を~serverに許容する。
両~headerとも`有構造~header$であり、その値は`~token$sfでなければナラナイ。
`STRUCTURED-FIELDS$r
◎
The `Cross-Origin-Embedder-Policy` and `Cross-Origin-Embedder-Policy-Report-Only` HTTP response header fields allow a server to declare an embedder policy for an environment settings object. These headers are structured headers whose values must be token. [STRUCTURED-FIELDS]
</p>

<p>
`埋込元~施策~値$が，`~token$sfとして妥当になる。
各~tokenは`~parameters$sfも伴い得る
— それを成す
`report-to@coep
~parameterは、適切な`報告先$を識別する`妥当な~URL文字列$をとり得る。
`REPORTING$r
◎
The valid token values are the embedder policy values. The token may also have attached parameters; of these, the "report-to" parameter can have a valid URL string identifying an appropriate reporting endpoint. [REPORTING]
</p>

<div class="note">
<p>注記：
値を`~token$sfとして構文解析し得ない~headerが在る下では、処理~model（`埋込元~施策を得する$）は，（既定の `unsafe-none$coep になることにより）~openに失敗する【何の？】。
所与の応答~内に複数の `Cross-Origin-Embedder-Policy$h ~headerが在って、不作為に結合され，~listが作成された場合も同様になる：
◎
The processing model fails open (by defaulting to "unsafe-none") in the presence of a header that cannot be parsed as a token. This includes inadvertent lists created by combining multiple instances of the `Cross-Origin-Embedder-Policy` header present in a given response:
</p>

<div>
<table><thead>
<tr><th>`Cross-Origin-Embedder-Policy$h`
<th>最終的な`埋込元~施策~値$
</thead><tbody>

<tr><td>`送達された~headerなし^em
<td>`unsafe-none$coep

<tr><td>`require-corp^bl
<td>`require-corp$coep

<tr><td>`unknown-value^bl
<td>`unsafe-none$coep

<tr><td>`require-corp, unknown-value^bl
<td>`unsafe-none$coep

<tr><td>`unknown-value, unknown-value^bl
<td>`unsafe-none$coep

<tr><td>`unknown-value, require-corp^bl
<td>`unsafe-none$coep

<tr><td>`require-corp, require-corp^bl
<td>`unsafe-none$coep
</tbody></table>

◎
• `Cross-Origin-Embedder-Policy`｜Final embedder policy value
• No header delivered｜"unsafe-none"
• `require-corp`｜"require-corp"
• `unknown-value`｜"unsafe-none"
• `require-corp, unknown-value`｜"unsafe-none"
• `unknown-value, unknown-value`｜"unsafe-none"
• `unknown-value, require-corp`｜"unsafe-none"
• `require-corp, require-corp`｜"unsafe-none"
</div>

<p>
（同じことは，
`Cross-Origin-Embedder-Policy-Report-Only$h にも適用される。）
◎
(The same applies to `Cross-Origin-Embedder-Policy-Report-Only`.)
</p>
</div>

<hr>

<div class="algo">
<p>
`埋込元~施策を得する@
ときは、所与の
( `応答$ %応答, `環境$ %環境 )
に対し：
◎
To obtain an embedder policy from a response response and an environment environment:
</p>
<ol>
	<li>
%施策 ~LET 新たな`埋込元~施策$
◎
Let policy be a new embedder policy.
</li>
	<li>
~IF［
%環境 は`~secureな文脈$enVでない
］
⇒
~RET %施策
◎
If environment is a non-secure context, then return policy.
</li>
	<li>
%構文解析した~item ~LET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Cross-Origin-Embedder-Policy$h, `~item^i )
◎
Let parsedItem be the result of getting a structured field value with `Cross-Origin-Embedder-Policy` and "item" from response's header list.
</li>
	<li>
<p>
~IF［
%構文解析した~item ~NEQ ~NULL
］：
</p>
		<ol>
			<li>
%値 ~LET %構文解析した~item の`値$sfI
</li>
			<li>
<p>
~IF［
%値 は`~token$sfである【この条件は、この訳による補完】
］~AND［
%値 ~EQ `require-corp^l
］：
</p>
				<ol>
					<li>
%施策 の`値$embP ~SET `require-corp$coep
</li>
					<li>
%報告先 ~LET %構文解析した~item の`~parameters$sfI[ `report-to$coep ]
</li>
					<li>
~IF［
%報告先 ~NEQ ε
］
⇒
%施策 の`報告先$embP ~SET %報告先
</li>
				</ol>
			</li>
		</ol>
◎
If parsedItem is non-null and parsedItem[0] is "require-corp":
• Set policy's value to "require-corp".
• If parsedItem[1]["report-to"] exists, then set policy's endpoint to parsedItem[1]["report-to"].
</li>
	<li>
%構文解析した~item ~SET %応答 の`~header~list$rsから`有構造~field値を取得する$( `Cross-Origin-Embedder-Policy-Report-Only$h, `~item^i )
◎
Set parsedItem to the result of getting a structured field value with `Cross-Origin-Embedder-Policy-Report-Only` and "item" from response's header list.
</li>
	<li>
<p>
~IF［
%構文解析した~item ~NEQ ~NULL
］：
</p>
		<ol>
			<li>
%値 ~LET %構文解析した~item の`値$sfI
</li>
			<li>
<p>
~IF［
%値 は`~token$sfである【この条件は、この訳による補完】
］~AND［
%値 ~EQ `require-corp^l
］：
</p>
				<ol>
					<li>
%施策 の`報告のみの値$embP ~SET `require-corp$coep
</li>
					<li>
%報告先 ~LET %構文解析した~item の`~parameters$sfI[ `report-to$coep ]
</li>
					<li>
~IF［
%報告先 ~NEQ ε
］
⇒
%施策 の`報告のみの報告先$embP ~SET %報告先
</li>
				</ol>
			</li>
		</ol>
◎
If parsedItem is non-null and parsedItem[0] is "require-corp":
• Set policy's report-only value to "require-corp".
• If parsedItem[1]["report-to"] exists, then set policy's report-only reporting endpoint to parsedItem[1]["report-to"].
</li>
	<li>
~RET %施策
◎
Return policy.
</li>
</ol>
</div>

			</section>
			<section id="embedder-policy-checks">
<h4 title="Embedder policy checks">7.8.2 埋込元~施策の検査</h4>

<div class="algo">
<p>
`~navi応答の埋込元~施策に対する固守を検査する@
ときは、所与の
( `応答$ %応答, `閲覧文脈$ %~target, `環境$ %環境 )
に対し：
◎
To check a navigation response's adherence to its embedder policy given a response response, a browsing context target, and an environment environment:
</p>
<ol>
	<li>
~IF［
%~target は`子~閲覧文脈$でない
］
⇒
~RET ~T
◎
If target is not a child browsing context, then return true.
</li>
	<li>
%応答~施策 ~LET `埋込元~施策を得する$( %応答, %環境 )
◎
Let responsePolicy be the result of obtaining an embedder policy from response.
</li>
	<li>
%親~施策 ~LET %~target の`容器~文書$の`埋込元~施策$doc
◎
Let parentPolicy be target's container document's embedder policy.
</li>
	<li>
~IF［
%親~施策 の`報告のみの値$embP ~EQ `require-corp$coep
］~AND［
%応答~施策 の`値$embP ~EQ `unsafe-none$coep
］
⇒
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `navigation^l, %親~施策 の`報告のみの報告先$embP, `reporting^l, %~target の`容器~文書$に`関連な設定群~obj$ )
◎
If parentPolicy's report-only value is "require-corp" and responsePolicy's value is "unsafe-none", then queue a cross-origin embedder policy inheritance violation with response, "navigation", parentPolicy's report only reporting endpoint, "reporting", and target's container document's relevant settings object.
</li>
	<li>
~IF［
%親~施策 の`値$embP ~EQ `unsafe-none$coep
］~OR［
%応答~施策 の`値$embP ~EQ `require-corp$coep
］
⇒
~RET ~T
◎
If parentPolicy's value is "unsafe-none" or responsePolicy's value is "require-corp", then return true.
</li>
	<li>
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `navigation^l, %親~施策 の`報告先$embP, `enforce^l, %~target の`容器~文書$に`関連な設定群~obj$ )
◎
Queue a cross-origin embedder policy inheritance violation with response, "navigation", parentPolicy's reporting endpoint, "enforce", and target's container document's relevant settings object.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`大域~objの埋込元~施策を検査する@
ときは、所与の
( `WorkerGlobalScope$I %~worker大域~scope, `環境~設定群~obj$ %所有者, `応答$ %応答 )
に対し：
◎
To check a global object's embedder policy given a WorkerGlobalScope workerGlobalScope, an environment settings object owner, and a response response:
</p>
<ol>
	<li>
~IF［
%~worker大域~scope は `DedicatedWorkerGlobalScope$I ~objでない
］
⇒
~RET ~T
◎
If workerGlobalScope is not a DedicatedWorkerGlobalScope object, then return true.
</li>
	<li>
%施策 ~LET %~worker大域~scope の`埋込元~施策$wG
◎
Let policy be workerGlobalScope's embedder policy.
</li>
	<li>
%所有者~施策 ~LET %所有者 の`埋込元~施策$enV
◎
Let ownerPolicy be owner's embedder policy.
</li>
	<li>
~IF［
%所有者~施策 の`報告のみの値$embP ~EQ `require-corp$coep
］~AND［
%施策 の`値$embP ~EQ `unsafe-none$coep
］
⇒
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `worker initialization^l, %所有者の施策 の`報告のみの報告先$embP, `reporting^l, %所有者 )
◎
If ownerPolicy's report-only value is "require-corp" and policy's value is "unsafe-none", then queue a cross-origin embedder policy inheritance violation with response, "worker initialization", owner's policy's report only reporting endpoint, "reporting", and owner.
</li>
	<li>
~IF［
%所有者~施策 の`値$embP ~EQ `unsafe-none$coep
］~OR［
%施策 の`値$embP ~EQ `require-corp$coep
］
⇒
~RET ~T
◎
If ownerPolicy's value is "unsafe-none" or policy's value is "require-corp", then return true.
</li>
	<li>
`非同一-生成元~埋込元~施策の継承~違反を~queueする$( %応答, `worker initialization^l, %所有者の施策 の`報告先$embP, `enforce^l, %所有者 )
◎
Queue a cross-origin embedder policy inheritance violation with response, "worker initialization", owner's policy's reporting endpoint, "enforce", and owner.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`非同一-生成元~埋込元~施策の継承~違反を~queueする@
ときは、所与の
( `応答$ %応答, 文字列 %種別, 文字列 %報告先, 文字列 %処置, `環境~設定群~obj$ %設定群 )
に対し：
◎
To queue a cross-origin embedder policy inheritance violation given a response response, a string type, a string endpoint, a string disposition, and an environment settings object settings:
</p>
<ol>
	<li>
%直列化した~URL ~LET `応答~URLを報告-用に直列化する$( %応答 )
◎
Let serialized be the result of serializing a response URL for reporting with response.
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含する新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
</thead><tbody>

<tr><td>`type^c
<td>%種別
<tr><td>`blockedURL^c
<td>%直列化した~URL
<tr><td>`disposition^c
<td>%処置
</tbody></table>

◎
Let body be a new object containing the following properties:
◎
key	value
type	type
blockedURL	serialized
disposition	disposition
</li>
	<li>
`報告を~queueする$( %本体, `~COEP報告~種別$i, %報告先, %設定群 )
◎
Queue body as the "coep" report type for endpoint on settings.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="policy-containers">
<h3 title="Policy containers">7.9. 施策~容器</h3>

<p>
`施策~容器@
は、［
`Document$I ／ `WorkerGlobalScope$I ／ `WorkletGlobalScope$I
］に適用する施策を包含している`構造体$であり，次に挙げる`~item$sctからなる：
◎
A policy container is a struct containing policies that apply to a Document, a WorkerGlobalScope, or a WorkletGlobalScope. It has the following items:
</p>
<ul>
	<li>
`~CSP~list@pC
⇒
`~CSP~list$
— 初期~時は空とする。
◎
A CSP list, which is a CSP list. It is initially empty.
</li>
</ul>

<p class="XXX">
他の施策も施策~容器の中へ移動する。
◎
Move other policies into the policy container.
</p>

<div class="algo">
<p>
`施策~容器を~cloneする@
ときは、所与の
( `施策~容器$ %施策~容器 )
に対し：
◎
To clone a policy container given a policy container policyContainer:
</p>
<ol>
	<li>
%~clone ~LET 新たな`施策~容器$
◎
Let clone be a new policy container.
</li>
	<li>
%~clone の`~CSP~list$pC ~SET %施策~容器 の`~CSP~list$pCを`~cloneする$
◎
Set clone's CSP list to a clone of policyContainer's CSP list.
</li>
	<li>
~RET %~clone
◎
Return clone.
</li>
</ol>
</div>

<div class="algo">
<p>
`~URLは履歴~内に施策~容器を格納するよう要求するか？@
かどうか決定するときは、所与の
( `~URL$ %~URL )
に対し：
◎
To determine whether a URL url requires storing the policy container in history:
</p>
<ol>
	<li>
~IF［
%~URL の`~scheme$url ~EQ `blob^l
］
⇒
~RET ~F
◎
If url's scheme is "blob", then return false.
</li>
	<li>
~IF［
%~URL ~EQ `~about_srcdoc$sc
］
⇒
~RET ~F
◎
If url is about:srcdoc, then return false.
</li>
	<li>
~IF［
%~URL は`局所的な~URL$である
］
⇒
~RET ~T
◎
If url is local, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`~fetch応答から施策~容器を作成する@
ときは、所与の
( `応答$ %応答 )
に対し：
◎
To create a policy container from a fetch response given a response response:
</p>
<ol>
	<li>
~IF［
%応答 の`~URL$rsの`~scheme$url ~EQ `blob^l
］
⇒
~RET `施策~容器を~cloneする$( %応答 の`~URL$rsの`~blob~URL~entry$urlの`環境$bUの`施策~容器$ )
◎
If response's URL's scheme is "blob", then return a clone of response's URL's blob URL entry's environment's policy container.
</li>
	<li>
%結果 ~LET 新たな`施策~容器$
◎
Let result be a new policy container.
</li>
	<li>
%結果 の`~CSP~list$pC ~SET `応答の~CSPを構文解析する$( %応答 )
◎
Set result's CSP list to the result of parsing a response's Content Security Policies given response.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navi~paramsの施策~容器を決定する@
ときは、所与の
⇒＃
`~URL$ %応答~URL,
`施策~容器$または~NULL %履歴~施策~容器,
`施策~容器$または~NULL %起動元~施策~容器,
`施策~容器$または~NULL %親~施策~容器,
`施策~容器$または~NULL %応答~施策~容器
◎終
に対し：
◎
To determine navigation params policy container given a URL responseURL and four policy container-or-nulls historyPolicyContainer, initiatorPolicyContainer, parentPolicyContainer, and responsePolicyContainer:
</p>
<ol>
	<li>
<p>
~IF［
%履歴~施策~容器 ~NEQ ~NULL
］：
◎
If historyPolicyContainer is not null, then:
</p>
		<ol>
			<li>
~Assert：
`~URLは履歴~内に施策~容器を格納するよう要求するか？$( %応答~URL ) ~EQ ~T
◎
Assert: responseURL requires storing the policy container in history.
</li>
			<li>
~RET `施策~容器を~cloneする$( %履歴~施策~容器 )
◎
Return a clone of historyPolicyContainer.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%応答~URL ~EQ `~about_srcdoc$sc
］：
◎
If responseURL is about:srcdoc, then:
</p>
		<ol>
			<li>
~Assert：
%親~施策~容器 ~NEQ ~NULL
◎
Assert: parentPolicyContainer is not null.
</li>
			<li>
~RET `施策~容器を~cloneする$( %親~施策~容器 )
◎
Return a clone of parentPolicyContainer.
</li>
		</ol>
	</li>
	<li>
~IF［
%応答~URL は`局所的な~URL$である
］~AND［
%起動元~施策~容器 ~NEQ ~NULL
］
⇒
~RET `施策~容器を~cloneする$( %起動元~施策~容器 )
◎
If responseURL is local and initiatorPolicyContainer is not null, then return a clone of initiatorPolicyContainer.
</li>
	<li>
~IF［
%応答~施策~容器 ~NEQ ~NULL
］
⇒
~RET %応答~施策~容器
◎
If responsePolicyContainer is not null, then return responsePolicyContainer.
</li>
	<li>
~RET 新たな`施策~容器$
◎
Return a new policy container.
</li>
</ol>
</div>

<div class="algo">
<p>
`~worker大域~scopeの施策~容器を初期化する@
ときは、所与の
( `WorkerGlobalScope$I %~worker大域~scope, `応答$ %応答 )
に対し：
◎
To initialize a worker global scope's policy container given a WorkerGlobalScope workerGlobalScope and a response response:
</p>
<ol>
	<li>
%~URL ~LET %~worker大域~scope の`~url$wG
◎
↓</li>
	<li>
<p>
~IF［
%~URL は`局所的な~URL$である
］~AND［
%~URL の`~scheme$url ~NEQ `blob^l
］：
◎
If workerGlobalScope's url is local but its scheme is not "blob":
</p>
		<ol>
			<li>
~Assert：
%~worker大域~scope の`所有者~集合$wGの`~size$ ~EQ 1
◎
Assert: workerGlobalScope's owner set's size is 1.
</li>
			<li>
%~worker大域~scope の`施策~容器$wG ~SET `施策~容器を~cloneする$( %~worker大域~scope の`所有者~集合$wG[ 0 ] に`関連な設定群~obj$の`施策~容器$enV )
◎
Set workerGlobalScope's policy container to a clone of workerGlobalScope's owner set[0]'s relevant settings object's policy container.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%~worker大域~scope の`施策~容器$wG ~SET `~fetch応答から施策~容器を作成する$( %応答 )
◎
Otherwise, set workerGlobalScope's policy container to the result of creating a policy container from a fetch response given response.
</li>
</ol>
</div>

		</section>
</main>

