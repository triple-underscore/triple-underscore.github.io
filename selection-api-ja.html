<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Selection API （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style type="text/css">
.user-agent {
	font-family: sans-serif0, sans-serif;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`
	break;
}


let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:Selection API
spec_date:2019-08-19
trans_update:2019-06-11
source_checked:181108
original_url:https://w3c.github.io/selection-api/
	abbr_url:SELECTIONAPI
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
site_nav:uievents
conformance:w3c
copyright:2018,permissive
trans_1st_pub:2019-03-20

●●class_map
E:error
et:event-type
ua:user-agent
css:css

●●tag_map
E:code
et:code
I:code
m:code
c:code
css:code
i:i
ua:span

●●original_id_map
selection:dom-selection
dom-selection-stringifier:

●●link_map

	●IDL
Exposed:~WEBIDL#Exposed

DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean
unsigned long:~WEBIDL#idl-unsigned-long
CEReactions:~HEcustom#cereactions

E.IndexSizeError:~WEBIDL#indexsizeerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotFoundError:~WEBIDL#notfounderror

I.Node:~DOM4#node
I.Document:~DOM4#document
文書:~HTMLdom#the-document-object
	~DOM4#document
I.EventHandler:~WAPI#eventhandler
I.Range:~DOM4#range
I.AbstractRange:~DOM4#abstractrange
I.Window:~WINDOW#window
I.Selection:#selection
I.GlobalEventHandlers:~WAPI#globaleventhandlers

m.selection:#dom-selection
選択:#dom-selection
文書の選択:#_document-selection

m.addRange:#dom-selection-addrange
m.anchorNode:#dom-selection-anchornode
m.anchorOffset:#dom-selection-anchoroffset
m.collapse:#dom-selection-collapse
m.collapseToEnd:#dom-selection-collapsetoend
m.collapseToStart:#dom-selection-collapsetostart
m.containsNode:#dom-selection-containsnode
m.deleteFromDocument:#dom-selection-deletefromdocument
m.empty:#dom-selection-empty
m.focusNode:#dom-selection-focusnode
m.focusOffset:#dom-selection-focusoffset
m.getRangeAt:#dom-selection-getrangeat
m.isCollapsed:#dom-selection-iscollapsed
m.extend:#dom-selection-extend
m.rangeCount:#dom-selection-rangecount
m.removeAllRanges:#dom-selection-removeallranges
m.removeRange:#dom-selection-removerange
m.selectAllChildren:#dom-selection-selectallchildren
m.selection:#dom-selection
m.setBaseAndExtent:#dom-selection-setbaseandextent
m.setPosition:#dom-selection-setposition
m.type:#dom-selection-type
m.stringifier:#dom-selection-stringifier

m.getSelection:#dom-document-getselection
m.~getSelectionW:#dom-window-getselection
m.deleteContents:~DOM4#dom-range-deletecontents
m.onselectionchange:#dom-globaleventhandlers-onselectionchange
m.onselectstart:#dom-globaleventhandlers-onselectstart
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable

m.Document.open:~HTMLdynamic#dom-document-open


et.selectionchange:#dfn-selectionchange
et.selectstart:#dfn-selectstart

	●constructor

	■attrs/method

	■variable

	■event

	●用語
sL.範囲o:#_range
空である:#dfn-empty
起点:#dfn-anchor
~focus:#dfn-focus
方向:#dfn-direction
i.無方向:#dfn-directionless
i.後方:#dfn-backwards
i.前方:#dfn-forwards

境界点を検査する:#_check-bp
新たな範囲oを作成する:#_create-a-range
以下略:#_omitted

	●用語（外部
~eventを発火する:~DOM4#concept-event-fire
~eventを発火-:~DOM4#concept-event-fire

長さ:~DOM4#concept-node-length
~node:~DOM4#concept-node
根:~DOM4#concept-tree-root

範囲o:~DOM4#concept-range
~live範囲o:~DOM4#concept-live-range
境界点:~DOM4#concept-range-bp
bp.~offset:~DOM4#concept-range-bp-offset
bp.~node:~DOM4#boundary-point-node
境界点を設定する:~DOM4#concept-range-bp-set
始端:~DOM4#concept-range-start
終端:~DOM4#concept-range-end
始端~node:~DOM4#concept-range-start-node
終端~node:~DOM4#concept-range-end-node
始端~offset:~DOM4#concept-range-start-offset
終端~offset:~DOM4#concept-range-end-offset
i.より前:~DOM4#concept-range-bp-before
i.より後:~DOM4#concept-range-bp-after
i.に等しい:~DOM4#concept-range-bp-equal
畳まれて:~DOM4#range-collapsed
	collapsed:~DOM4#dom-range-collapsed
部分的に包含されて:~DOM4#partially-contained

HTML Editing API:https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html

編集中の~host:#dfn-editing-hosts

~HTML要素:~HTMLINFRA#html-elements
属する閲覧文脈:~BROWSERS#concept-document-bc
閲覧文脈に属する:~BROWSERS#concept-document-bc
閲覧文脈:~BROWSERS#browsing-context
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~taskを~queueする:~WAPI#queue-a-task
作動中の文書:~BROWSERS#active-document
文字列~化の挙動:~WEBIDL#dfn-stringification-behavior

結付けられている文書:~WINDOW#concept-document-window
	m.document:~WINDOW#dom-window-document
	document:#dom-document

	●他
	HTML specification:https://www.w3.org/TR/html5/
	Mozilla bug:https://bugzilla.mozilla.org/show_bug.cgi?id=717339
	W3C bug 10583:https://www.w3.org/Bugs/Public/show_bug.cgi?id=10583
	WebKit bug:https://bugs.webkit.org/show_bug.cgi?id=76114
	bug 13909:https://www.w3.org/Bugs/Public/show_bug.cgi?id=13909
	bug 15470:https://www.w3.org/Bugs/Public/show_bug.cgi?id=15470
	discussion:https://lists.w3.org/Archives/Public/public-webapps/2012JanMar/0159.html
	discussion:https://lists.w3.org/Archives/Public/public-whatwg-archive/2011Jun/0193.html
	nsISelection.idl:https://mxr.mozilla.org/mozilla/source/content/base/public/nsISelection.idl
	DOM Range specification:https://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113/ranges.html

●●words_table1
EXEC-COMMAND:https://w3c.github.io/editing/execCommand.html
getSelectionW:getSelection


●●words_table


	●処理一般
渡した:passした:~

	文字列~化:stringification
	投出-:raise／:raising
	投出されるもの:called out
	変更は加えず:leaving〜unchanged

	●型／構造／操作

	子孫:descend
	子:children
	~NULLにする:remove
	~SET ~NULL:disassociating／
	~NULLにされ:dissociated

	●選択／範囲／UI
caret::::キャレット
drag::::ドラッグ
起点:anchor::~
copy::::コピー
paste::::ペースト
編集中の:editing::~
編集-:edit::~
	編集-時の:editing
	編集-不能な:non-editable
畳まれ:collapseされ::~
範囲o:range::範囲°
境界点:boundary point::~
選択-:select::~
選択:selection::~
前方:forwards::~
後方:backwards::~
無方向:directionless::~

	●仕様
	-:suitable
際どい:corner:~
柔軟性:flexibility:~
積極的:aggressive:~
妥協:compromise:~
背景:background:~
流儀:fashion:~
奇妙さ:oddities:~
不快:unpleasant:~

	ではなく:as opposed to
	欠落している:missing
	することにより:after the fact by
	編集者:I
	ここでは:I／we
	先行:preliminary
	-:perhaps
	わずかしか:rarely
	-:thanks to
	-:nevertheless
	以前に:predate
	ようだ:apparently
	いずれにせよ:anyway
	関心がある箇所:point of interest
	ない限り，〜し続ける:in the meantime
	~~不利に~~扱う:short-change
	~~無意味で:don't make any real sense
	参加:participation
	助力:helpful
	すなわち:namely that
	など／:say

	●仕様（動詞

共存:coexistence:~
立証-:prove:~

	それがため:explain
	~~述べていた:said
	持ち込まれ:carried on
	言えない:impossible to tell
	~~対処する:deal with
	に見える:viewed as
	奪う:take 〜 away
	書き手:writer
	成す:made-up
	の他にも:in addition to
	入口:entry point

	●未分類
table::::テーブル
column:::列
doctype:
領域:region::~
切詰めて:clampして::切り詰めて
	新-範囲o:newRange
	旧-起点:oldAnchor
	旧-~focus:oldFocus
	新-~focus:newFocus
	-:nodeLength
	~Mac
	-:strong
	Comment^I:comment
	居させ:letting them lie
	ごとに一つだけ:singleton


	●機能語
新-:new:~
旧-:old:~

	何も:nothing
	同じに:identically
	ほぼ:mostly
	もの:anything
	以前に／それまで:previously
	他所:somewhere else
	地点:point
	され続ける:continue
	導く:lead
	もの:thing
	戻-:back
	-:current
	何箇所か:some places
	最後に，:finally
	どれも:everything
	以外の:non-
	いくぶん:some
	一方で:but
	さほど:doesn't much
	高々:at most
	少数の:couple of
	古い:old
	別として:though not
	であり続ける:try to stop
	それに類するもの:things like that
	部位:portion


●●ref_normative

[dom]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[webidl]
    Web IDL. Boris Zbarsky. W3C. 15 December 2016. W3C Editor's Draft. URL: https://heycam.github.io/webidl/

●●
ref_informative


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Selection API</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/selection-api/ 
編集者草案
	https://w3c.github.io/selection-api/
テスト一式
	https://github.com/web-platform-tests/wpt/tree/master/selection
編集
	<a href="mailto:rniwa@apple.com">Ryosuke Niwa</a> (Apple Inc.)
Participate
	<a href="https://github.com/w3c/selection-api/">GitHub w3c/selection-api</a>
	<a href="https://github.com/w3c/selection-api/issues/">File a bug</a>
	<a href="https://github.com/w3c/selection-api/commits/gh-pages">Commit history</a>
	<a href="https://github.com/w3c/selection-api/pulls/">Pull requests</a>
メーリングリスト
	<a href="mailto:public-webapps@w3.org">public-webapps mailing list</a>
	<a href="https://lists.w3.org/Archives/Public/public-webapps/">archive</a>
発行者
	<a href="https://www.w3.org/2019/webapps/">Web Applications Working Group</a>
</script>

</head>

<body>

<header>
	<hgroup>
<h1>Selection API</h1>
	</hgroup>

</header>

<hr>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この文書は、［
Selection ~API, および選択に関係する機能性の仕様
］の，先行~草案である。
これは、
<a href="https://www.w3.org/TR/html5/">~HTML仕様</a>
の少数の古い節,
<a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113/ranges.html">DOM Range 仕様</a>
の選択に関する部分を置換する。
◎
This document is a preliminary draft of a specification for the Selection API and selection related functionality. It replaces a couple of old sections of the HTML specification, the selection part of the old DOM Range specification.
</p>

<p>
この文書は、選択~用の~APIを定義する
— それは、［
文書のある部位を選択する／ ［
~copy, ~paste その他の編集-時の演算
］用の関心がある箇所を指定する
］ことを，利用者や作者に許容する。
◎
This document defines APIs for selection, which allows users and authors to select a portion of a document or specify a point of interest for copy, paste, and other editing operations.
</p>
	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは編集者草案の公の複製です…
【以下，この節の他の内容は<a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="background" class="informative">
<h2 title="Background">1. 背景</h2>

<p>
［
`IE9^ua ／
`Firefox 6.0a2^ua
］は、選択~内の任意な範囲oを許容し，この仕様が元々~~述べていたものに従う。
しかしながら，これは、~~無意味で不快な際どい事例を導くことに加え，［
作者, 実装者, 仕様の書き手
］三者とも それに~~対処する必要がある。
［
`Chrome 14 dev^ua ／
`Opera 11.11^ua
］は、選択を積極的に正規化し，それを［
空~要素やそれに類するもの
］の内側には居させなくするが、これも作者から柔軟性を奪うので，不良な案に見える。
◎
IE9 and Firefox 6.0a2 allow arbitrary ranges in the selection, which follows what this spec originally said. However, this leads to unpleasant corner cases that authors, implementers, and spec writers all have to deal with, and they don't make any real sense. Chrome 14 dev and Opera 11.11 aggressively normalize selections, like not letting them lie inside empty elements and things like that, but this is also viewed as a bad idea, because it takes flexibility away from authors.
</p>

<p>
よって、編集者は、いくぶんの単純~化を許容しつつ作者をさほど拘束しない妥協を成すよう，仕様を変更した。
<a href="https://lists.w3.org/Archives/Public/public-whatwg-archive/2011Jun/0193.html">論点</a>
を見よ。
基本的には、［
`選択$の`範囲o$sLの`境界点$の`~node$bpが、
`Document^I の子孫であって， `Element^I または `Text^I であり続ける
］よう，そうならなくなる何箇所かで例外を投出する。
【言い換えれば、`~live範囲o$ `DOM$r に課される拘束に従う。】
◎
So I changed the spec to a made-up compromise that allows some simplification but doesn't constrain authors much. See discussion. Basically it would throw exceptions in some places to try to stop the selection from containing a range that had a boundary point other than an Element or Text node, or a boundary point that didn't descend from a Document.
</p>

<p>
（`以下略$）
◎
But this meant getRangeAt() had to start returning a copy, not a reference. Also, it would be prone to things failing weirdly in corner cases. Perhaps most significantly, all sorts of problems might arise when DOM mutations transpire, like if a boundary point's node is removed from its parent and the mutation rules would place the new boundary point inside a non-Text/Element node. And finally, the previously-specified behavior had the advantage of matching two major implementations, while the new behavior matched no one. So I changed it back.
◎
See bug 15470. IE9, Firefox 12.0a1, Chrome 17 dev, and Opera Next 12.00 alpha all make the range initially null.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW, 此れ, 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p id="_omitted">
原文に多数見られる過去~UA実装の互換性に関する情報は、現況と乖離していると見受けられるので、この訳では大部分を省略する（
“（以下略）”
と記された箇所）。
<small>
訳者が確認した限り，現在の
`Firefox^ua （ `Gecko^ua ）,
`Chrome^ua
に関しては、ほぼ仕様に従っていると見受けられる。
</small>
</p>

	</section>
	<section id="definition">
<h2 title="Definition">2. 定義</h2>

<p>
どの`文書$にも，それが`属する閲覧文脈$ ~NEQ ~NULL ならば
`選択@
と呼ばれる，一意な `Selection$I ~objが結付けられる。
`DOM$r `HTML$r
◎
Every document with a browsing context has a unique selection associated with it.
</p>

<p class="note">注記：
これは、~HTML仕様による要件である。
（`以下略$）
◎
This is a requirement of the HTML spec. IE9 and Opera Next 12.00 alpha seem to follow it, while Firefox 12.0a1 and Chrome 17 dev seem not to. See Mozilla bug, WebKit bug.
</p>

<p>
この`選択$は、`文書$を成す すべての内容から共有されるモノトスル（入子にされた`文書$は別として）
— 文書~内に`編集中の~host$があれば それも含めて。
`文書$の内側には無い
`編集中の~host@
【<a href="~EXEC-COMMAND#editing-host">参考</a>】
は、`選択$を持ち得ない。
◎
This one selection must be shared by all the content of the document (though not by nested documents), including any editing hosts in the document. Editing hosts that are not inside a document cannot have a selection
</p>

<p>
各 `選択$には、
`範囲o@sL
が結付けられる
— それは，`範囲o$†または ~NULL であり、初期~時には ~NULL になるモノトスル。
◎
Each selection can be associated with a single range. When there is no range associated with the selection, the selection is empty. The selection must be initially empty.
</p>

<p class="trans-note">【†
この`範囲o$（ `AbstractRange$I ）は、実際には`~live範囲o$（ `Range$I ）になる（この仕様の~APIは、`範囲o$sLとして `Range^I ~objを返している）。
】【
原文では、`範囲o$sLは `DOM$r 用語の`範囲o$を直に指していて，
“範囲oが結付けられ得る”
と記されているが、
“結付けられていない場合”
を表現し易くするため、ここでは， ~NULL もとり得る新たな用語として定義し直す。
それに伴い，原文における
“結付けられていない場合”
を表す句
“`選択$は
`空である@
（ `empty^en ）”
も，直に
“`選択$の`範囲o$sL ~EQ ~NULL”
と記す（ “空である” は、範囲oが`畳まれて$いるかのように誤解し易くもある）。
】</p>

<p class="note">注記：
`文書$の`選択$は、`文書$ごとに一つだけ結付けられる~objなので、
`Document.open()$m が~callされるときには新たな~objに置換される。
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=15470">bug 15470</a>
を見よ。
（`以下略$）
◎
A document's selection is a singleton object associated with that document, so it gets replaced with a new object when Document.open() is called. See bug 15470. IE9 and Opera Next 12.00 alpha allow the user to reset the range to null after the fact by clicking somewhere; Firefox 12.0a1 and Chrome 17 dev do not. We follow Gecko/WebKit, because it lessens the chance of getRangeAt(0) throwing.
</p>

<p>
`選択$の`範囲o$sLは、非 ~NULL になったなら
— この仕様が他を要求するまで —
同じ~objであり続けるモノトスル。
◎
Once a selection is associated with a given range, it must continue to be associated with that same range until this specification requires otherwise.
</p>

<p class="note">注記：
一例として，~DOMが範囲oの境界点を変化させるような仕方で変更されても，~scriptが`範囲o$sLの境界点を改変しても、選択の`範囲o$sLは同じ~objであり続ける。
しかしながら，［
利用者が選択を変更したか，~scriptが `addRange()$m を~callした
］場合、この仕様の他所にて要求されるように，選択の`範囲o$sLは新たな`範囲o$になる。
◎
For instance, if the DOM changes in a way that changes the range's boundary points, or a script modifies the boundary points of the range, the same range object must continue to be associated with the selection. However, if the user changes the selection or a script calls addRange(), the selection must be associated with a new range object, as required elsewhere in this specification.
</p>

<p>
`選択$の`範囲o$sLは［
~NULL でない, かつ`畳まれて$いる
］場合、~caret位置は，`範囲o$sLの`始端$にあるモノトスル。
他の場合における~caret位置は、この仕様では定義しない。
~UAは、~caretを［
`範囲o$sLの始端, 終端, あるいは他所
］のどこにするか裁定するときには，~platform規約に従うベキである。
◎
If the selection's range is not null and is collapsed, then the caret position must be at that range's boundary point. When the selection is not empty, this specification does not define the caret position; user agents should follow platform conventions in deciding whether the caret is at the start of the selection, the end of the selection, or somewhere else.
</p>
<p class="note">注記：
これは、 Mac 利用者を~~不利に~~扱う。
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=13909">bug 13909</a>
を見よ。
◎
This short-changes Mac users. See bug 13909.
</p>

<p>
各 `選択$には
`方向@
があり、［
`前方@i,
`後方@i,
`無方向@i
］いずれかをとる。
利用者が 1 個目の`境界点$ %A を指示してから， 2 個目のそれ %B を指示することにより（ある地点を~clickして別の地点へ~dragするなどにより），`選択$の`範囲o$sLを作成した場合、初期~時の`方向$は，［
%A は %B `より後$i ならば `後方$i ／
%A は %B `より前$i ならば `前方$i ／
~ELSE_ `無方向$i 
］になるモノトスル。
`DOM$r
◎
Each selection has a direction, forwards, backwards, or directionless. If the user creates a selection by indicating first one boundary point of the range and then the other (such as by clicking on one point and dragging to another), and the first indicated boundary point is after the second, then the corresponding selection must initially be backwards. If the first indicated boundary point is before the second, then the corresponding selection must initially be forwards. Otherwise, it must be directionless.
</p>

<p>
各 `選択$には
`起点@
（ `anchor^en ）,
`~focus@
（ `focus^en ）もある：
◎
Each selections also have an anchor and a focus.＼
</p>

<ul>
	<li>
`選択$の`範囲o$sL ~EQ ~NULL の場合、［
`起点$, `~focus$
］とも ~NULL を返すとする。
◎
If the selection's range is null, its anchor and focus are both null.＼
</li>
	<li>
<p>
`選択$の`範囲o$sL ~NEQ ~NULL の場合、`選択$の`方向$に応じて
</p>
		<ul>
			<li>
`前方$i ならば ［
`起点$は`範囲o$sLの`始端$，`~focus$は`範囲o$sLの`終端$
］を返すとする。
</li>
			<li>
他の場合は［
`起点$は`範囲o$sLの`終端$, `~focus$は`範囲o$sLの`始端$
］を返すとする。
</li>
		</ul>
◎
If the selection's range is not null and its direction is forwards, its anchor is the range's start, and its focus is the end. Otherwise, its focus is the start and its anchor is the end.
</li>
</ul>

	</section>
	<section id="selection-interface">
<h2 title="Selection interface">3. `Selection^I ~interface</h2>

<p>
`Selection$I ~interfaceは
各~文書に結付けられている`選択$とヤリトリする仕方を供する。
◎
Selection interface provides a way to interact with the selection associated with each document.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `Selection@I {
  readonly attribute `Node$I? `anchorNode$m;
  readonly attribute unsigned long `anchorOffset$m;
  readonly attribute `Node$I? `focusNode$m;
  readonly attribute unsigned long `focusOffset$m;
  readonly attribute boolean `isCollapsed$m;
  readonly attribute unsigned long `rangeCount$m;
  readonly attribute DOMString `type$m;
  `Range$I `getRangeAt$m(unsigned long %index);
  void `addRange$m(`Range$I %range);
  void `removeRange$m(`Range$I %range);
  void `removeAllRanges$m();
  void `empty$m();
  void `collapse$m(`Node$I? %node, optional unsigned long %offset = 0);
  void `setPosition$m(`Node$I? %node, optional unsigned long %offset = 0);
  void `collapseToStart$m();
  void `collapseToEnd$m();
  void `extend$m(`Node$I %node, optional unsigned long %offset = 0);
  void `setBaseAndExtent$m(`Node$I %anchorNode, unsigned long %anchorOffset, `Node$I %focusNode, unsigned long %focusOffset);
  void `selectAllChildren$m(`Node$I %node);
  [`CEReactions$] void `deleteFromDocument$m();
  boolean `containsNode$m(`Node$I %node, optional boolean %allowPartialContainment = false);
  `stringifier$m DOMString ();
};
</pre>

<div class="algorithm">
<p>
`新たな範囲oを作成する@
ときは、所与の
( `境界点$ %A, `境界点$ %B )
に対し，次を走らす：
</p>

<ol>
	<li>
( %始端, %終端 ) ~LET ［
%A は %B `より前$i ならば ( %A, %B ) ／
~ELSE_ ( %B, %A )
］
</li>
	<li>
%範囲o ~LET 新たな`~live範囲o$ `DOM$r
</li>
	<li>
%範囲o の`境界点を設定する$( `始端^i, %始端 の`~node$bp, %始端 の`~offset$bp )
</li>
	<li>
%範囲o の`境界点を設定する$( `終端^i, %終端 の`~node$bp, %終端 の`~offset$bp )
</li>
	<li>
~RET %範囲o
</li>
</ol>

<p class="trans-note">【
この~algoは、原文の共通な記述を集約したものである。
これは、所与の 2 つの境界点を，必要に応じて入れ替える。
】</p>

◎
↓</div>

<dl class="idl-def">
	<dt>`anchorNode@m</dt>
	<dd>
取得子は、此れの`起点$に応じて，次を返すモノトスル
⇒＃
~NULL ならば ~NULL ／
~ELSE_ 此れの`起点$の`~node$bp
◎
The attribute must return the anchor node of the context object, or null if the anchor is null.
</dd>

	<dt>`anchorOffset@m</dt>
	<dd>
取得子は、此れの`起点$に応じて，次を返すモノトスル
⇒＃
~NULLならば 0 ／
~ELSE_ 此れの`起点$の`~offset$bp
◎
The attribute must return the anchor offset of the context object, or 0 if the anchor is null.
</dd>

	<dt>`focusNode@m</dt>
	<dd>
取得子は、此れの`起点$に応じて，次を返すモノトスル
⇒＃
~NULL ならば ~NULL ／
~ELSE_ 此れの`~focus$の`~node$bp
◎
The attribute must return the focus node of the context object, or null if the anchor is null.
</dd>

	<dt>`focusOffset@m</dt>
	<dd>
取得子は、此れの`~focus$に応じて，次を返すモノトスル
⇒＃
~NULL ならば 0 ／
~ELSE_ 此れの`~focus$の`~offset$bp
◎
The attribute must return the focus offset of the context object, or 0 if the focus is null.
</dd>

	<dt>`isCollapsed@m</dt>
	<dd>
取得子は、［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返すモノトスル
⇒
此れの`起点$ ~EQ 此れの`~focus$（両者とも ~NULL も含む）
◎
The attribute must return true if and only if the anchor and focus are the same (including if both are null). Otherwise it must return false.
</dd>

	<dt>`rangeCount@m</dt>
	<dd>
取得子は、此れの`範囲o$sLに応じて，次を返すモノトスル
⇒＃
~NULL ならば 0 ／
~ELSE_ 1
◎
The attribute must return 0 if the context object is empty, and must return 1 otherwise.
</dd>

	<dt>`type@m</dt>
	<dd>
取得子は、此れの`範囲o$sLに応じて，次を返すモノトスル
⇒＃
~NULL ならば `None^l ／
~ELSE_ `畳まれて$いるならば `Caret^l ／
~ELSE_ `Range^l
◎
The attribute must return "None" if the context object is empty, "Caret" if the context object's range is collapsed, and "Range" otherwise.
</dd>

	<dt>`getRangeAt(index)@m</dt>
	<dd>
<p>
次を走らすモノトスル：
</p>
		<ol>
			<li>
~IF［
%index ~NEQ 0
］~OR［
此れの`範囲o$sL ~EQ ~NULL
］
⇒
~THROW `IndexSizeError$E
</li>
			<li>
~RET 此れの`範囲o$sL
</li>
		</ol>
◎
The method must throw an IndexSizeError exception if index is not 0, or if the context object is empty. Otherwise, it must return a reference to (not a copy of) the context object's range.
</dd>
	<dd class="note">注記：
この~methodは、此れの`範囲o$sLが ~NULL にされない限り，後続の~callに対し同じ~objを返し続ける。
特に，`範囲o$sL ~NEQ ~NULL ならば、次の~codeは ~T に評価される
⇒
`getSelection().getRangeAt(0) === getSelection().getRangeAt(0)^c
◎
Thus subsequent calls of this method returns the same range object if nothing has removed the context object's range in the meantime. In particular, getSelection().getRangeAt(0) === getSelection().getRangeAt(0) evaluates to true if the selection is not empty.
</dd>
	<dd class="note">注記：
（`以下略$）
◎
IE9 and Firefox 4.0 return the same object every time, as the spec says. Chrome 12 dev and Opera 11.10 return a different object every time.
</dd>

	<dt>`addRange(range)@m</dt>
	<dd>
<p>
次を走らすモノトスル：
◎
The method must follow these steps:
</p>
		<ol>
			<li>
~IF［
此れの`範囲o$sL ~EQ ~NULL
<!-- rangeCount is not 0 -->
］~AND［
%range の`始端~node$の`根$ ~EQ 此れを結付けている`文書$
］
⇒
此れの`範囲o$sL ~SET %range
◎
If the root of the range's boundary points are not the document associated with context object, abort these steps.
◎
If rangeCount is not 0, abort these steps.
◎
Set the context object's range to range by a strong reference (not by making a copy).
</li>
		</ol>
	</dd>
	<dd>
<p class="note">注記：
`範囲o$sLは参照として追加されるので、この~methodに対する後続の~callは，同じ~objを返す。
他の何かが`選択$の`範囲o$sLを ~NULL にするか置換するまで、`選択$が追加された後における，~scriptによる`範囲o$sLに対する変更を反映することになる。
特に，次の~codeを走らせた後には、`選択$は，
%a ではなく %b を包含することになる：
◎
Since range is added by reference, subsequent calls to getRangeAt(0) returns the same object, and any changes that a script makes to range after it is added must be reflected in the selection, until something else removes or replaces the context object's range. In particular, the selection will contain b as opposed to a after running the following code:
</p>

<pre class="js-code">
var %r = document.createRange();
%r.selectNode(%a);
getSelection().addRange(%r);
%r.selectNode(%b);
</pre>

	</dd>
	<dd class="note">注記：
（`以下略$）
◎
At Step 2, Chrome 58 and Edge 25 do nothing. Firefox 51 gives you a multi-range selection. At least they keep the exisiting range.
◎
At Step 3, Chrome 58 and Firefox 51 store a reference, as described here. Edge 25 stores a copy. Firefox 51 changes its selection if the range is modified.
</dd>

	<dt>`removeRange(range)@m</dt>
	<dd>
<p>
次を走らすモノトスル：
</p>
		<ol>
			<li>
~IF［
此れの`範囲o$sL ~NEQ %range
］
⇒
~THROW `NotFoundError$E
</li>
			<li>
此れの`範囲o$sL ~SET ~NULL
</li>
		</ol>
◎
The method must make the context object empty by disassociating its range if the context object's range is range. Otherwise, it must throw a NotFoundError.
</dd>

	<dt>`removeAllRanges()@m</dt>
	<dd>
次を走らすモノトスル
⇒
此れの`範囲o$sL ~SET ~NULL
◎
The method must make the context object empty by disassociating its range if the context object has an associated range.
</dd>

	<dt>`empty()@m</dt>
	<dd>
この~methodは、 `removeAllRanges()$m の別名であり，それと同じに挙動するモノトスル。
◎
The method must be an alias, and behave identically, to removeAllRanges().
</dd>

	<dt>`collapse(node, offset)@m</dt>
	<dd>
<p>
次を走らすモノトスル：
◎
The method must follow these steps:
</p>
		<ol>
			<li>
~IF［
%node ~EQ ~NULL
］
⇒＃
`removeAllRanges()$m と同じに挙動する；
~RET
◎
If node is null, this method must behave identically as removeAllRanges() and abort these steps.
</li>
			<li>
~IF［
%offset ~GT %node の`長さ$
］
⇒
~THROW `IndexSizeError$E
◎
The method must throw an IndexSizeError exception if offset is longer than node's length and abort these steps.
</li>
			<li>
~IF［
%node の`根$ ~NEQ 此れを結付けている`文書$
］
⇒
~RET
◎
If node's root is not the document associated with the context object, abort these steps.
</li>
			<li>
%境界点 ~LET `境界点$( %node, %offset )
◎
↓</li>
			<li>
此れの`範囲o$sL ~SET `新たな範囲oを作成する$( %境界点, %境界点 )
◎
Otherwise, let newRange be a new range.
◎
Set the start and the end of newRange to (node, offset).
◎
Set the context object's range to newRange.
</li>
		</ol>
	</dd>

	<dt>`setPosition(node, offset)@m</dt>
	<dd>
この~methodは、 `collapse()$m の別名であり，それと同じに挙動するモノトスル。
◎
The method must be an alias, and behave identically, to collapse().
</dd>

	<dt>`collapseToStart()@m</dt>
	<dd>
<p>
次を走らすモノトスル：
</p>
		<ol>
			<li>
~IF［
此れの`範囲o$sL ~EQ ~NULL
］
⇒
~THROW `InvalidStateError$E
</li>
			<li>
%境界点 ~LET 此れの`範囲o$sLの`始端$
</li>
			<li>
此れの`範囲o$sL ~SET `新たな範囲oを作成する$( %境界点, %境界点 )
</li>
		</ol>
◎
The method must throw InvalidStateError exception if the context object is empty. Otherwise, it must create a new range, set both its start and end to the start of the context object's range, and then set the context object's range to the newly-created range.
</dd>
	<dd class="note">注記：
（`以下略$）
◎
For collapseToStart/End, IE9 mutates the existing range, while Firefox 9.0a2 and Chrome 15 dev replace it with a new one. The spec follows the majority and replaces it with a new one, leaving the old Range object unchanged.
</dd>

	<dt>`collapseToEnd()@m</dt>
	<dd>
<p>
次を走らすモノトスル：
</p>
		<ol>
			<li>
~IF［
此れの`範囲o$sL ~EQ ~NULL
］
⇒
~THROW `InvalidStateError$E
</li>
			<li>
%境界点 ~LET 此れの`範囲o$sLの`終端$
</li>
			<li>
此れの`範囲o$sL ~SET `新たな範囲oを作成する$( %境界点, %境界点 )
</li>
		</ol>
◎
The method must throw InvalidStateError exception if the context object is empty. Otherwise, it must create a new range, set both its start and end to the end of the context object's range, and then set the context object's range to the newly-created range.
</dd>

	<dt>`extend(node, offset)@m</dt>
	<dd>
<p>
次を走らすモノトスル：
◎
The method must follow these steps:
</p>
		<ol>
			<li>
~IF［
%node の`根$ ~NEQ 此れを結付けている`文書$
］
⇒
~RET
◎
If node's root is not the document associated with the context object, abort these steps.
</li>
			<li>
~IF［
此れの`範囲o$sL ~EQ ~NULL
］
⇒
~THROW `InvalidStateError$E
◎
If the context object is empty, throw an InvalidStateError exception and abort these steps.
</li>
			<li>
%旧-起点 ~LET 此れの`起点$
<!-- 
oldFocus 未利用
 -->
◎
Let oldAnchor and oldFocus be the context object's anchor and focus, and＼
</li>
			<li>
%新-~focus ~LET `境界点$( %node, %offset )
◎
let newFocus be the boundary point (node, offset).
◎
↓Let newRange be a new range.
</li>
			<li>
~IF［
%node の`根$ ~NEQ 此れの`範囲o$sLの`始端~node$の`根$
］
⇒
%旧-起点 ~SET %新-~focus
◎
If node's root is not the same as the context object's range's root, set newRange's start and end to newFocus.
</li>
			<li>
此れの`範囲o$sL ~SET `新たな範囲oを作成する$( %旧-起点, %新-~focus )
◎
Otherwise, if oldAnchor is before or equal to newFocus, set newRange's start to oldAnchor, then set its end to newFocus.
◎
Otherwise, set newRange's start to newFocus, then set its end to oldAnchor.
◎
Set the context object's range to newRange.
</li>
			<li>
此れの`方向$ ~SET ［
%新-~focus は %旧-起点 `より前$i ならば `後方$i ／
~ELSE_ `前方$i
］
◎
If newFocus is before oldAnchor, set the context object's direction to backwards. Otherwise, set it to forwards.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
（`以下略$）
◎
Reverse-engineered circa January 2011. IE doesn't support it, so I'm relying on Firefox (implemented extend() sometime before 2000) and WebKit (implemented extend() in 2007). I'm mostly ignoring Opera, because gsnedders tells me its implementation isn't compatible. Firefox 12.0a1 seems to mutate the existing range. IE9 doesn't support extend(), and it's impossible to tell whether Chrome 17 dev or Opera Next 12.00 alpha mutate or replace, because getRangeAt() returns a copy anyway. Nevertheless, I go against Gecko here, to be consistent with collapse().
</dd>

	<dt>`setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset)@m</dt>
	<dd>
<p>
次を走らすモノトスル：
◎
The method must follow these steps:
</p>
		<ol>
			<li>
~IF［
%anchorOffset ~GT %anchorNode の`長さ$
］~OR［
%focusOffset ~GT %focusNode の`長さ$
］
⇒
~THROW `IndexSizeError$E
◎
If anchorOffset is longer than anchorNode's length or if focusOffset is longer than focusNode's length, throw an IndexSizeError exception and abort these steps.
</li>
			<li>
~IF［
%anchorNode の`根$ ~NEQ 此れを結付けている`文書$
］~OR［
%focusNode の`根$ ~NEQ 此れを結付けている`文書$
］
⇒
~RET
◎
If the roots of anchorNode or focusNode are not the document associated with context object, abort these steps.
</li>
			<li>
%起点 ~LET `境界点$( %anchorNode, %anchorOffset )
◎
Let anchor be the boundary point (anchorNode, anchorOffset) and＼
</li>
			<li>
%~focus ~LET `境界点$( %focusNode, %focusOffset )
◎
let focus be the boundary point (focusNode, focusOffset).
</li>
			<li>
此れの`範囲o$sL ~SET `新たな範囲oを作成する$( %起点, %~focus )
◎
Let newRange be a new range.
◎
If anchor is before focus, set the newRange's start to anchor and its end to focus. Otherwise, set them to focus and anchor respectively.
◎
Set the context object's range to newRange.
</li>
			<li>
此れの`方向$ ~SET ［
次が満たされるならば `後方$i ／
~ELSE_ `前方$i
］
⇒
%~focus は %起点 `より前$i
◎
If focus is before anchor, set context object's direction to backwards. Otherwise, set it to forwards
</li>
		</ol>
	</dd>

	<dt>`selectAllChildren(node)@m</dt>
	<dd>
<p>
次を走らすモノトスル：
◎
The method must follow these steps:
</p>
		<ol>
			<li>
~IF［
%node の`根$ ~NEQ 此れを結付けている`文書$
］
⇒
~RET
◎
If node's root is not the document associated with the context object, abort these steps.
</li>
			<li>
此れの`範囲o$sL ~SET `新たな範囲oを作成する$(
`境界点$( %node, 0 ),
`境界点$( %node, %~node の`長さ$ )
)
◎
Let newRange be a new range and nodeLength be the length of node.
◎
Set newRange's start to (node, 0).
◎
Set newRange's end to (node, nodeLength).
◎
Set the context object's range to newRange.
</li>
			<li>
此れの`方向$ ~SET %前方
◎
Set the context object's direction to forwards.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
（`以下略$）
◎
Based mostly on Firefox 9.0a2. It has a bug that I didn't reproduce, namely that if you pass a Document as the argument, the end offset becomes 1 instead of the number of children it has. It also throws a RangeException instead of DOMException, because its implementation predated their merging.
◎
IE9 behaves similarly but with glitches. It throws "Unspecified error." if the node is detached or display:none, and apparently in some random other cases too. It throws "Invalid argument." for detached comments (only!). Finally, if you pass it a comment, it seems to select the whole comment, unlike with text nodes.
◎
Chrome 16 dev behaves as you'd expect given its Selection implementation. It refuses to select anything that's not visible, so it's almost always wrong. Opera 11.50 just does nothing in all my tests, as usual.
	</dd>
	<dd class="note">注記：
新たな範囲oは、既存の範囲oを変異することなく置換する。
（`以下略$）
◎
The new range replaces any existing one, doesn't mutate it. This matches IE9 and Firefox 12.0a1. (Chrome 17 dev and Opera Next 12.00 alpha can't be tested, because getRangeAt() returns a copy anyway.)
</dd>

	<dt>`deleteFromDocument()@m</dt>
	<dd>
次を走らすモノトスル
⇒
~IF［
此れの`範囲o$sL ~NEQ ~NULL
］
⇒
此れの`範囲o$sL上で `deleteContents()$m の手続きを呼出す `DOM$r
◎
The method must invoke deleteContents() on the context object's range if the context object is not empty. Otherwise the method must do nothing.
</dd>
	<dd class="note">注記：
これは、範囲oを置換することなく，実際に変異させる~methodの一つである。
（`以下略$）
◎
This is the one method that actually mutates the range instead of replacing it. This matches IE9 and Firefox 12.0a1. (Chrome 17 dev and Opera Next 12.00 alpha can't be tested, because getRangeAt() returns a copy anyway.)
</dd>

	<dt>`containsNode(node, allowPartialContainment)@m</dt>
	<dd>
<p>
次を走らすモノトスル：
</p>
		<ol>
			<li>
~IF［
此れの`範囲o$sL ~EQ ~NULL
］~OR［
%node の`根$ ~NEQ 此れを結付けている`文書$
］
⇒
~RET ~F
</li>
			<li>
%より前 ~LET 次に与える条件
⇒
此れの`範囲o$sLの`始端$は `境界点$( %node, 0 ) `より前$i か視覚的に等価†
</li>
			<li>
%より後 ~LET 次に与える条件
⇒
此れの`範囲o$sLの`終端$は `境界点$( %node, %node の`長さ$ ) `より後$i か視覚的に等価†
</li>
			<li>
<p>
~RET ［
次のいずれかが満たされるならば ~T ／
~ELSE_ ~F
］
</p>
				<ul>
					<li>
［
%allowPartialContainment ~EQ ~F
］~AND［
%より前
］~AND［
%より後
］
</li>
					<li>
［
%より前
］~OR［
%より後
］††
</li>
				</ul>
			</li>
		</ol>
<p class="trans-note">【†
“視覚的に等価”
が具体的にどう決定されるかは、定義されていない。
“2 つの境界点の合間に描画される内容は無いならば視覚的に等価とされる”
のような定義は考えられるが。
】【††
明らかに条件が不足している。
［
%~node は此れの`範囲o$sLに`部分的に包含されて$いる
］のような条件も必要であろう。
】</p>

◎
The method must return false if the context object is empty or if node's root is not the document associated with the context object.
◎
Otherwise, if allowPartialContainment is false, the method must return true if and only if start of its range is before or visually equivalent to the first boundary point in the node and end of its range is after or visually equivalent to the last boundary point in the node.
◎
If allowPartialContainment is true, the method must return true if and only if start of its range is before or visually equivalent to the first boundary point in the node or end of its range is after or visually equivalent to the last boundary point in the node.
</dd>

	<dt>`stringifier@m</dt>
	<dd>
`文字列~化の挙動$は
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10583">W3C bug 10583</a>
を見よ。
◎
See W3C bug 10583.
</dd>
</dl>

<p class="note">注記：
`Gecko^ua
による
<a href="https://mxr.mozilla.org/mozilla/source/content/base/public/nsISelection.idl">nsISelection.idl</a>
も見よ。
この仕様は、そのどれもまだ備えていない
— 特に、 `selectionLanguageChange()^m, `containsNode()^m は欠落している。
それらが欠落しているのは、編集者が，それらを `Range^I の用語でどう定義するか作業できなかったためである。
◎
See also nsISelection.idl from Gecko. This spec doesn't have everything from there yet, in particular selectionLanguageChange() and containsNode() are missing. They are missing because I couldn't work out how to define them in terms of Ranges.
</p>

<div class="note">注記：
<p>
`Selection$I ~interfaceは、元々は
`Netscape^ua
の特能であった。
元の実装は
`Gecko^ua（ `Firefox^ua ）
に持ち込まれ、後に，他の~browser~engineも独立にこの特能を実装した。
`Netscape^ua
実装は、単独の選択における複数の範囲oを常に許容していた
— 一例として，利用者が~tableの ある~columnも選択できるよう。
しかしながら，複数個の範囲oからなる選択は、~web開発者が知る由もない
不快な際どい事例があるものと立証され、
`Gecko^ua 開発者ですら，わずかしか正しく取扱っていなかった。
他の~browser~engineは、この特能を実装したことは決してなく，様々な互換でない流儀で選択を単独の範囲oに切詰めていた。
◎
Originally, the Selection interface was a Netscape feature. The original implementation was carried on into Gecko (Firefox), and the feature was later implemented independently by other browser engines. The Netscape implementation always allowed multiple ranges in a single selection, for instance so the user could select a column of a table However, multi-range selections proved to be an unpleasant corner case that web developers didn't know about and even Gecko developers rarely handled correctly. Other browser engines never implemented the feature, and clamped selections to a single range in various incompatible fashions.
</p>

<p>
この仕様は，選択を高々 1 個の範囲oに制約する~~点で
`Gecko^ua
以外の~engineに従うが、この~APIは，元々は任意な個数の範囲oを伴う選択~用に設計されていた。
`removeRange()$m と `removeAllRanges()$m の共存や,
`getRangeAt()$m ~methodの整数~引数は常に 0 でなければならない奇妙さがあるのは、それがためである。
◎
This specification follows non-Gecko engines in restricting selections to at most one range, but the API was still originally designed for selections with arbitrary numbers of ranges. This explains oddities like the coexistence of removeRange() and removeAllRanges(), and a getRangeAt() method that takes an integer argument that must always be zero.
</p>
</div>

<p>
`Selection^I ~interfaceを成すすべての~memberは、その~objが表現する`範囲o$用の演算の用語で定義される。
これらの演算は， `Range$I ~interfaceに定義されるように例外を投出し得る
【すなわち、`新たな範囲oを作成する$とき】。
したがって `Selection$I ~interfaceの各~memberも
— そこで明示的に投出される例外の他に —
例外を投出することになる。
◎
All of the members of the Selection interface are defined in terms of operations on the range object (if any) represented by the object. These operations can raise exceptions, as defined for the Range interface; this can therefore result in the members of the Selection interface raising exceptions as well, in addition to any explicitly called out below.
</p>

	</section>
	<section id="extensions-to-other-interfaces">
<h2 title="Extensions to Other Interfaces">4. 他の~interfaceに対する拡張</h2>

<p>
この仕様は、いくつかの~interfaceを拡張して、この仕様にて定義される~interfaceへの入口を供する。
◎
This specification extends several interfaces to provide entry points to the interfaces defined in this specification.
</p>

		<section id="extensions-to-document-interface">
<h3 title="Extensions to Document interface">4.1. `Document^I ~interfaceに対する拡張</h3>

<p>
`Document$I ~interfaceは、`HTML$r にて定義される。
◎
The Document interface is defined in [HTML].
</p>

<pre class="idl">
partial interface `Document$I {
  `Selection$I? getSelection();
};
</pre>

<div class="algorithm">
<p>
`文書の選択@
は、所与の
( `文書$ %文書 )
に対し，次を返す
⇒＃
%文書 が`属する閲覧文脈$ ~NEQ ~NULL ならば %文書 の`選択$ ／
~ELSE_ ~NULL
◎
The method must return the selection associated with context object if the context object has an associated browsing context, and it must return null otherwise.
</p>
</div>

<dl class="idl-def">
	<dt>`getSelection()@m</dt>
	<dd>
`文書の選択$( 此れ )
を返すモノトスル。
◎
↑</dd>
	<dd class="note">注記：
閲覧文脈に属さない`文書$（ `document.implementation.createHTMLDocument("")^c
で作成したものなど）上で，この~methodを~callした場合、~NULL が返される。
（`以下略$）
◎
If we create a Document object with no browsing context (say via document.implementation.createHTMLDocument("") and call getSelection on it), IE9 seems to return a different Selection object. Firefox 12.0a1 and Opera Next 12.00 alpha return the same object as for the current window. Chrome 17 dev returns null. See discussion. There's no meaningful selection associated with such a document, so we follow WebKit and require returning null.
</dd>
</dl>

		</section>
		<section id="extensions-to-window-interface">
<h3 title="Extensions to Window interface">4.2. `Window^I ~interfaceに対する拡張</h3>

<p>
`Window$I ~interfaceは `HTML$r にて定義される。
◎
The Window interface is defined in [HTML].
</p>

<pre class="idl">
partial interface `Window$I {
  `Selection$I? `getSelection()$m;
};
</pre>

<dl>
	<dt>`~getSelectionW()@m</dt>
	<dd>
`文書の選択$( 此れに`結付けられている文書$ )
を返すモノトスル。
<!-- document property -->
◎
The method must invoke and return the result of getSelection on the context object's document property.
</dd>
</dl>

		</section>
		<section id="extensions-to-globaleventhandlers">
<h3 title="Extensions to GlobalEventHandlers">4.3. `GlobalEventHandlers^I に対する拡張</h3>

<p>
`GlobalEventHandlers$I ~interfaceは、 `HTML$r にて定義される。
◎
The GlobalEventHandlers interface is defined in [HTML].
</p>

<pre class="idl">
partial interface mixin `GlobalEventHandlers$I {
  attribute `EventHandler$I `onselectstart$m;
  attribute `EventHandler$I `onselectionchange$m;
};
</pre>

<dl>
	<dt>`onselectstart@m</dt>
	<dt>`onselectionchange@m</dt>
	<dd>
順に［
`selectstart$et,
`selectionchange$et
］~event用の`~event~handler~IDL属性$。
すべての［
`~HTML要素$, `文書$, `Window$I ~obj
］は、これらを~supportするモノトスル。
◎
The attribute must be an event handler IDL attribute for the selectstart event supported by all HTML elements, Document objects, and Window objects.
◎
The attribute must be an event handler IDL attribute for the selectionchange event supported by all HTML elements, Document objects, and Window objects.
</dd>
</dl>

		</section>
	</section>
	<section id="user-interactions">
<h2 title="User Interactions">5. 利用者~対話</h2>

<p>
~UAは、`作動中の文書$に結付けられた`選択$を変更することを利用者に許容するベキである。
利用者が選択を改変したときは、~UAは，次を走らすモノトスル：
◎
The user agent should allow the user to change the selection associated with the active document. If the user makes any modification to a selection, the user agent must＼
</p>

<ol>
	<li>
( %始端, %終端 ) ~LET 利用者による選択の ( 始端, 終端 ) を指す`境界点$
（ %始端 は %終端 `より後$i でない）
◎
↓</li>
	<li>
`選択$の`範囲o$sL ~SET `新たな範囲oを作成する$( %始端, %終端 )
（既存の`範囲o$sLは改変されない）
◎
create a new range with suitable start and end of the range and associate the selection with this new range (not modify the existing range), and＼
</li>
	<li>
<p>
`選択$の`方向$ ~SET 利用者は［
%始端, %終端
］どちらから選択し始めたかに応じて
⇒＃
%始端 と %終端 は一致するならば `前方$i／
%始端 から選択し始めたならば `前方$i ／
%終端 から選択し始めたならば `後方$i ／
~platform規約に因り どちらから選択し始めたか決定できないならば `無方向$i†
◎
set update selection's direction to forwards if the start is before or equal to the end, backwards if if the end is before the start, or directionless if the start and the end cannot be ordered due to the platform convention.
</p>

<p class="trans-note">【†
例えばダブルクリック等で単語を選択したときなど。
】【
原文の記述は、［
始端／終端
］と［
選択し始めた地点／選択し終えた地点
］とが混同されていて，はっきりしない所がある。
%始端 と %終端 が一致する場合と他の場合は両立し得るが、`方向$の定義の記述に従うなら，一致する場合が優先されることになる。
しかしながら，常識的には、 “決定できない場合” がそれより優先されるべきであろう。
】</p>

	</li>
</ol>

<p>
~UAは、利用者~動作（例：編集-不能な領域を~clickするなど）に呼応して`選択$の`範囲o$sLを ~NULL に設定しないモノトスル。
◎
The user agent must not make a selection empty if it was not already empty in response to any user actions (e.g. clicking on a non-editable region).
</p>

<p class="note">注記：
（`以下略$）
◎
See bug 15470. IE9 and Opera Next 12.00 alpha allow the user to reset the range to null after the fact by clicking somewhere; Firefox 12.0a1 and Chrome 17 dev do not. I follow Gecko/WebKit, because it lessens the chance of getRangeAt(0) throwing.
</p>

		<section id="selectstart-event">
<h3 title="selectstart event">5.1. `selectstart@et ~event</h3>

<p>
~UAは、利用者が起動した動作に呼応して，`選択$の`範囲o$sLに新たな`範囲o$ %新-範囲o を設定しようとするときは
— `選択$の`範囲o$sLは それまで［
 ~NULL であった／`畳まれて$いた
］場合には、選択を変更するに先立って —
%新-範囲o の`始端~node$に向けて，名前 `selectstart^et の`~eventを発火する$モノトスル
— 次のように初期化して
⇒＃
`bubbles$m ~SET ~T,
`cancelable$m ~SET ~T
◎
When the user agent is about to associate a new range newRange to the selection in response to a user initiated action, the user agent must fire an event with the name selectstart, which bubbles and is cancelable, at the node associated with the boundary point of newRange's start prior to changing the selection if the selection was previously empty or the previously associated range was collapsed.
</p>

<p>
当の~eventが取消された場合、~UAは，`選択$を変更しないモノトスル。
◎
If the event is canceled, the user agent must not change the selection.
</p>

<p>
~UAは、`選択$の`範囲o$sLを ~NULL に設定したときには，`~eventを発火-$しないモノトスル。
◎
The user agent must not fire the event when the user agent sets the selection empty.
</p>

		</section>
		<section id="selectionchange-event">
<h3 title="selectionchange event">5.2. `selectionchange@et ~event</h3>

<p>
`選択$の`範囲o$sLが［
~NULL または新たな`範囲o$にされた／
そのいずれかの`境界点$が利用者または内容~scriptにより変異された
］ときは、~UAは，次を走らす`~taskを~queueする$モノトスル
⇒
`選択$を結付けている`文書$に向けて，名前 `selectionchange^et の`~eventを発火する$
— 次のように初期化して
⇒＃
`bubbles$m ~SET ~F,
`cancelable$m ~SET ~F
◎
When the selection is dissociated with its range, associated with a new range or the associated range's boundary point is mutated either by the user or the content script, the user agent must queue a task to fire an event with the name selectionchange, which does not bubble and is not cancelable, at the document associated with the selection.
</p>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕様, および
`HTML Editing API$ 仕様の元の作者である `Aryeh Gregor^en 氏に。
◎
Many thanks to
◎
Aryeh Gregor, who is the original author of this specification as well as HTML Editing API specification.
</p>

<p>
`HTML Editing API$ 仕様に対し，~feedback, 参加, その他の助力を貢献された方々に：
</p>

<div lang="en-x-a0">
Contributors to the HTML Editing API specification - Ehsan Akhgari, Tab Atkins, Mathias Bynens, Tim Down, Markus Ernst, Daniel Glazman, Tali Gregor (née Fuss), Stig Halvorsen, Jeff Harris, Ian Hickson, Cameron Heavon-Jones, Anne van Kesteren, Alfonso Martínez de Lizarrondo, Glenn Maynard, Ms2ger, Robert O'Callahan, Julie Parent, Simon Pieters, Michael A. Puls II, Rich Schwerdtfeger, Jonas Sicking, Henri Sivonen, Smylers, Hallvord R. M. Steen, Roland Steiner, Annie Sullivan, timeless, Ojan Vafai, Brett Zamir, and Boris Zbarsky for their feedback, participation, or other helpful contributions
</div>

	</section>
</main></div>

