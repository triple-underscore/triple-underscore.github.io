<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Form control（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>
.html-code.bad {
	color: gray;
}
</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'MAIN',
		persisted_parts: Util.collectHtmlCodeList(),
		collectParts: Util.collectParts,
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		E: 'error',
		h: 'header',
		st: 'attr-state',
		v: 'value',
		M: 'method',
		U: 'code-point',
	};

	var tag_map = {
		I: 'code', // IDL
		m: 'code', // IDL
		E: 'code', // err
		c: 'code', 
		e: 'code', // elem
		a: 'code', // attr
		M: 'code',
		h: 'code',
		et: 'code',
		st: 'span', // for IM
		v: 'code', // attr value
		mt: 'code', // mime type
		U: 'span',
		V: 'var',
		i: 'i',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U' :
	text = 'U+' + key;
	break;
case 'smb': //
	text = '(<span class="char-symbol">' + text + '</span>)'
	break;
case 'xCode':
	return '<a id="_ex-' + key + '">＊</a>'
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>



<script type="text/plain" id="_source_data">


●●options

spec_date:2018-05-16
trans_update:2018-05-08
	source_checked:170608
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/form-control-infrastructure.html
nav_prev:HEinput
nav_next:HEinteractive
trans_1st_pub:2016-09-29


●●original_id_map


	concept-fe-dirty:concept-input-value-dirty-flag
	concept-fe-dirty:concept-textarea-dirty


●●link_map


	●IDL
E.IndexSizeError:~WEBIDL#indexsizeerror
E.InvalidStateError:~WEBIDL#invalidstateerror
	DOMException:~WEBIDL#idl-DOMException
I.Document:~HTMLdom#document
文書:~HTMLdom#the-document-object
I.SelectionMode:#selectionmode
I.ValidityState:#validitystate
I.HTMLInputElement:~HEinput#htmlinputelement

m.action:#dom-fs-action
m.autofocus:#dom-fe-autofocus
m.badInput:#dom-validitystate-badinput
m.checkValidity:#dom-cva-checkvalidity
m.customError:#dom-validitystate-customerror
m.disabled:#dom-fe-disabled
m.elements:~HEforms#dom-form-elements
m.encoding:#dom-fs-encoding
m.enctype:#dom-fs-enctype
m.form:#dom-fae-form
m.formAction:#dom-fs-formaction
m.formEnctype:#dom-fs-formenctype
m.formMethod:#dom-fs-formmethod
m.formNoValidate:#dom-fs-formnovalidate
m.formTarget:#dom-fs-formtarget
m.method:#dom-fs-method
m.name:#dom-fe-name
m.noValidate:#dom-fs-novalidate
m.patternMismatch:#dom-validitystate-patternmismatch
m.rangeOverflow:#dom-validitystate-rangeoverflow
m.rangeUnderflow:#dom-validitystate-rangeunderflow
m.reportValidity:#dom-cva-reportvalidity
m.select:#dom-textarea/input-select
m.selectionDirection:#dom-textarea/input-selectiondirection
m.selectionEnd:#dom-textarea/input-selectionend
m.selectionStart:#dom-textarea/input-selectionstart
m.setCustomValidity:#dom-cva-setcustomvalidity
m.setRangeText:#dom-textarea/input-setrangetext
m.setSelectionRange:#dom-textarea/input-setselectionrange
m.show:~HEinteractive#dom-dialog-show
m.showModal:~HEinteractive#dom-dialog-showmodal
m.stepMismatch:#dom-validitystate-stepmismatch
m.submit:~HEforms#dom-form-submit
m.target:#dom-fs-target
m.tooLong:#dom-validitystate-toolong
m.tooShort:#dom-validitystate-tooshort
m.typeMismatch:#dom-validitystate-typemismatch
m.valid:#dom-validitystate-valid
m.validationMessage:#dom-cva-validationmessage
m.validity:#dom-cva-validity
m.value:~HEforms#dom-textarea-value
m.valueMissing:#dom-validitystate-valuemissing
m.willValidate:#dom-cva-willvalidate

m.cancelable:~DOM4#dom-event-cancelable
m.bubbles:~DOM4#dom-event-bubbles

m.innerHTML:~DOM-Parsing#dom-element-innerhtml

l.end:#dom-selectionmode-end
l.preserve:#dom-selectionmode-preserve
l.select:#dom-selectionmode-select
l.start:#dom-selectionmode-start


	●要素／属性／値／状態
e.button:~HEforms#the-button-element
e.datalist:~HEforms#the-datalist-element
e.dialog:~HEinteractive#the-dialog-element
e.fieldset:~HEforms#the-fieldset-element
e.form:~HEforms#the-form-element
e.input:~HEinput#the-input-element
e.legend:~HEforms#the-legend-element
e.object:~HEembed#the-object-element
e.option:~HEforms#the-option-element
e.optgroup:~HEforms#the-optgroup-element
e.select:~HEforms#the-select-element
e.textarea:~HEforms#the-textarea-element

et.click:~UIEVENTS#event-type-click
et.input:~HTMLindex#event-input
et.invalid:~HTMLindex#event-invalid
et.reset:~HTMLindex#event-reset
et.select:~HTMLindex#event-select
et.submit:~HTMLindex#event-submit

a.accept-charset:~HEforms#attr-form-accept-charset
a.action:#attr-fs-action
a.autofocus:#attr-fe-autofocus
a.dirname:#attr-fe-dirname
a.disabled:#attr-fe-disabled
a.~disabled0:~HEforms#attr-fieldset-disabled
a.enctype:#attr-fs-enctype
a.form:#attr-fae-form
a.formaction:#attr-fs-formaction
a.formenctype:#attr-fs-formenctype
a.formmethod:#attr-fs-formmethod
a.formnovalidate:#attr-fs-formnovalidate
a.formtarget:#attr-fs-formtarget
a.hidden:~HTMLinteraction#the-hidden-attribute
a.max:~HEinput#attr-input-max
a.maxlength:#attr-fe-maxlength
a.~maxlengthI:~HEinput#attr-input-maxlength
a.~maxlengthT:~HEforms#attr-textarea-maxlength
a.method:#attr-fs-method
a.min:~HEinput#attr-input-min
a.minlength:#attr-fe-minlength
a.~nameF:~HEforms#attr-form-name
a.~minlengthI:~HEinput#attr-input-minlength
a.~minlengthT:~HEforms#attr-textarea-minlength
a.~multipleI:~HEinput#attr-input-multiple
a.multiple:~HEforms#attr-select-multiple
a.name:#attr-fe-name
a.novalidate:#attr-fs-novalidate
a.open:#attr-dialog-open
a.pattern:~HEinput#attr-input-pattern
a.~requiredI:~HEinput#attr-input-required
a.~requiredT:~HEforms#attr-textarea-required
a.step:~HEinput#attr-input-step
a.target:#attr-fs-target
a.type:~HEinput#attr-input-type
a.value:~HEinput#attr-input-value


v.dialog:#attr-fs-method-dialog-keyword
v.get:#attr-fs-method-get-keyword
v.post:#attr-fs-method-post-keyword
v._charset_:#attr-fe-name-charset

sT.~text_plain:#attr-fs-enctype-text
sT.~form_urlencoded:#attr-fs-enctype-urlencoded
sT.~mp_form_data:#attr-fs-enctype-formdata

mt.~form_urlencoded:~URL1#concept-urlencoded
mt.~mp_form_data:~HTMLindex#multipart/form-data
mt.~text_plain:~IETF/rfc2046#section-4.1.3
mt.application/octet-stream:~IETF/rfc2046#section-4.5.1


st.Checkbox:~HEinput#checkbox-state-(type=checkbox)
st.Date:~HEinput#date-state-(type=date)
st.Email:~HEinput#e-mail-state-(type=email)
st.File:~HEinput#file-upload-state-(type=file)
st.Hidden:~HEinput#hidden-state-(type=hidden)
st.Image:~HEinput#image-button-state-(type=image)
st.Datetime-local:~HEinput#local-date-and-time-state-(type=datetime-local)
st.Month:~HEinput#month-state-(type=month)
st.Number:~HEinput#number-state-(type=number)
st.Password:~HEinput#password-state-(type=password)
st.Radio:~HEinput#radio-button-state-(type=radio)
st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Submit:~HEinput#submit-button-state-(type=submit)
st.Tel:~HEinput#telephone-state-(type=tel)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Time:~HEinput#time-state-(type=time)
st.Url:~HEinput#url-state-(type=url)
st.Week:~HEinput#week-state-(type=week)


st.GET:#attr-fs-method-get
st.POST:#attr-fs-method-post
st.dialog:#attr-fs-method-dialog

	●
~offset:#_insertion-offset
~legend:~HEforms#_fieldset-legend
~dirty値~flag:#concept-fe-dirty
適用される:~HEinput#concept-input-apply
適用されない:~HEinput#do-not-apply
選択された座標:~HEinput#concept-input-type-image-coordinate
選択された~file~list:~HEinput#concept-input-type-file-selected
~radio~button群:~HEinput#radio-button-group

~formに所有され得る要素:~HEforms#form-associated-element
~listされ:~HEforms#category-listed
再設定-可能:~HEforms#category-reset
提出-可能:~HEforms#category-submit

opt.選択有無:~HEforms#concept-option-selectedness
提出-~button:~HEforms#concept-submit-button
選択肢~list:~HEforms#concept-select-option-list
改行を正規化-:~HEforms#textarea-line-break-normalisation-transformation
行折返し:~HEforms#textarea-wrapping-transformation
opt.値:~HEforms#concept-option-value
opt.不能化され:~HEforms#concept-option-disabled
tA.生の値:~HEforms#concept-textarea-raw-value

~dialogを閉じる:~HEinteractive#close-the-dialog


	●form
所有させる:#concept-form-association
~form所有者:#form-owner
所有され:#form-owner
所有-:#form-owner
構文解析器挿入~flag:#parser-inserted-flag

値:#concept-fe-value
値たち:#concept-fe-values
~API値:#concept-fe-api-value
~checkedness:#concept-fe-checked
変異-可能:#concept-fe-mutable
不能化され:#concept-fe-disabled
~form~control~maxlength属性:#attr-fe-maxlength
~form~control~minlength属性:#attr-fe-minlength

既定の~button:#default-button
~button:#concept-button

再設定~algo:#concept-form-reset-control
~formを再設定-:#concept-form-reset
~form所有者を再設定-:#reset-the-form-owner

関連する値:#concept-textarea/input-relevant-value
~text手入力~cursor位置:#concept-textarea/input-cursor
選択:#concept-textarea/input-selection
選択~方向:#selection-direction
選択~範囲を設定する:#set-the-selection-range
選択~方向を設定する:#set-the-selection-direction
	~text選択:#concept-textarea/input-selection
	~text手入力~cursor:#concept-textarea/input-cursor


自動focus根:#nearest-ancestor-autofocus-scoping-root-element
最も近い先祖の自動focus視野根~要素:#nearest-ancestor-autofocus-scoping-root-element

	●提出 fs
提出する:#concept-form-submit
~form提出:#form-submission-2
動作:#concept-fs-action
~enctype:#concept-fs-enctype
~method:#concept-fs-method
検証なし状態:#concept-fs-novalidate

~Get動作~URL:#submit-get-action
本体として~Mailする:#submit-mailto-body
~header列を伴う~Mail:#submit-mailto-headers
変異-動作~URL:#submit-mutate-action
~entity本体として提出する:#submit-body
~dialogを提出する:#submit-dialog

~navigateを計画する:#plan-to-navigate
計画された~navi:#planned-navigation
~form~data集合を構築する:#constructing-the-form-data-set
~entryを付加する:#append-an-entry

~form提出用の属性:#attributes-for-form-submission
form.符号化方式:#picking-an-encoding-for-the-form

~mp_form_data境界~文字列:#multipart/form-data-boundary-string
~mp_form_dataとして符号化する:#multipart/form-data-encoding-algorithm
~text_plainとして符号化する:#text/plain-encoding-algorithm


	●妥当性
拘束を対話的に検証-:#interactively-validate-the-constraints
拘束を静的に検証-:#statically-validate-the-constraints
拘束検証の対象外:#barred-from-constraint-validation
拘束検証の候補:#candidate-for-constraint-validation

~custom妥当性~error~message:#custom-validity-error-message
自身の拘束を満たす:#concept-fv-valid
妥当性~状態:#validity-states

~pattern不一致の難あり:#suffering-from-a-pattern-mismatch
~step不一致の難あり:#suffering-from-a-step-mismatch
型~不一致の難あり:#suffering-from-a-type-mismatch
~overflowの難あり:#suffering-from-an-overflow
~underflowの難あり:#suffering-from-an-underflow
不良~入力の難あり:#suffering-from-bad-input
欠落の難あり:#suffering-from-being-missing
長過ぎる難あり:#suffering-from-being-too-long
短か過ぎる難あり:#suffering-from-being-too-short
~custom~errorの難あり:#suffering-from-a-custom-error

値に許容される最大~長さ:#maximum-allowed-value-length
値に許容される最小~長さ:#minimum-allowed-value-length


	●INFRA
~ASCII数字:~INFRA#ascii-digit
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
~JS文字列~長さ:~INFRA#javascript-string-length

node.挿入された:~HTMLINFRA#nodes-are-inserted
node.除去された:~HTMLINFRA#nodes-are-removed
中へ挿入された:~HTMLINFRA#insert-an-element-into-a-document
から除去された:~HTMLINFRA#remove-an-element-from-a-document
~live:~HTMLINFRA#live
~plugin:~HTMLINFRA#plugin
反映-:~HTMLcdom#reflect
既知の値のみに制限され:~HTMLcdom#limited-to-only-known-values

h.Content-Type:~HTMLurl#content-type
前後~空白~可の妥当かつ空でない~URL:~HTMLurl#valid-non-empty-url-potentially-surrounded-by-spaces
相対的に構文解析-:~HTMLurl#parse-a-url
結果の~URL~record:~HTMLurl#resulting-url-record

真偽~属性:~HTMLcms#boolean-attribute
列挙ed属性:~HTMLcms#enumerated-attribute
値なし用の既定:~HTMLcms#missing-value-default
妥当でない値~用の既定:~HTMLcms#invalid-value-default
妥当な非負~整数:~HTMLcms#valid-non-negative-integer
非負~整数として構文解析-:~HTMLcms#rules-for-parsing-non-negative-integers


	●WAPI
~DOM操作~task源:~WAPI#dom-manipulation-task-source
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task

~errorを報告する:~WAPI#report-the-error
走っている~script:~WAPI#running-script
~task~queue:~WAPI#task-queue
~task源:~WAPI#task-source
~task:~WAPI#concept-task
利用者~対話~task源:~WAPI#user-interaction-task-source
~click~eventを発火-:~WAPI#fire-a-click-event

	●DOM4
~ID:~DOM4#concept-id
doc.~URL:~DOM4#concept-document-url
接続されて:~DOM4#connected
文書の符号化方式:~DOM4#concept-document-encoding
広義~先祖:~DOM4#concept-tree-inclusive-ancestor
~node文書:~DOM4#concept-node-document
木~順序:~DOM4#concept-tree-order
木:~DOM4#concept-tree
~eventを発火する:~DOM4#concept-event-fire
作動化の挙動:~DOM4#eventtarget-activation-behavior

	●URL
~UTF-8~percent-符号化する:~URL1#utf-8-percent-encode
~form_urlencoded直列化器:~URL1#concept-urlencoded-serializer
~path~percent-符号化-集合:~URL1#path-percent-encode-set
	＊既定の符号化-集合:~URL1#default-encode-set
url.~query:~URL1#concept-url-query
url.~scheme:~URL1#concept-url-scheme

	●ENC
~UTF-8:~ENCODING#utf-8
符号化方式:~ENCODING#encoding
符号化方式を用いて符号化する:~ENCODING#encode
~UTF-8符号化する:~ENCODING#utf-8-encode
~labelから符号化方式を取得する:~ENCODING#concept-encoding-get
符号化方式から出力~符号化方式を取得する:~ENCODING#get-an-output-encoding

enc.名前:~ENCODING#name

	●borowser

作動中の文書:~BROWSERS#active-document
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
入子の閲覧文脈:~BROWSERS#nested-browsing-context
親~閲覧文脈:~BROWSERS#parent-browsing-context
妥当な閲覧文脈~名または~keyword:~BROWSERS#valid-browsing-context-name-or-keyword
閲覧文脈を選ぶ規則:~BROWSERS#the-rules-for-choosing-a-browsing-context-given-a-browsing-context-name

生成元:~ORIGIN#concept-origin
同一生成元:~ORIGIN#same-origin
作動中の~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
閲覧文脈~sandbox化( 自動~特色機能 )~flag:~ORIGIN#sandboxed-automatic-features-browsing-context-flag
閲覧文脈~sandbox化( ~form )~flag:~ORIGIN#sandboxed-forms-browsing-context-flag

~navigate:~NAVI#navigate
置換~可能化~flag:~NAVI#replacement-enabled
履歴を走査する:~NAVI#traverse-the-history
値たちは再設定され:~NAVI#history-autocomplete


	●fetch
要請:~FETCH#concept-request
rq.本体:~FETCH#concept-request-body
rq.~header~list:~FETCH#concept-request-header-list
rq.~method:~FETCH#concept-request-method
rq.~url:~FETCH#concept-request-url

	●syntax
~HTML構文解析器:~HTMLparsing#html-parser
完全に読込まれ:~HTMLparsing#completely-loaded
構文解析-~error:~HTMLparsing#parse-errors
構文解析を停止-:~HTMLparsing#stop-parsing

	●dom
左横書き:~HTMLdom#concept-ltr
右横書き:~HTMLdom#concept-rtl
方向性:~HTMLdom#the-directionality

要素の~targetを取得する:~HEmetadata#get-an-element's-target
	'
	●interaction
~focusされて:~HTMLinteraction#focused
~objを~focusする:~HTMLinteraction#focusing-steps

	●
具現化されて:~HTMLrendering#being-rendered
~navigateできない:~HTMLlinks#cannot-navigate

~Unicode~scalar値~列に変換する:~WEBIDL#dfn-obtain-unicode


●●words_table1



disabled0:disabled
maxlengthI:maxlength
maxlengthT:maxlength
minlengthI:minlength
minlengthT:minlength
multipleI:multiple
requiredI:required
requiredT:required
targetB:target
nameF:name
form_urlencoded:<code>application/x-www-form-urlencoded</code> 
mp_form_data:<code>multipart/form-data</code> 
text_plain:<code>text/plain</code> 

awesomeAt:awesome@example.com
rtlWord1:%D9%85%D8%B1%D8%AD%D8%A8%D8%A7


●●words_table



	●network／url／保安
header::::ヘッダ
method::::メソッド
payload::::ペイロード
scheme::::スキーム
path::::パス
query::::クエリ
HTTP:
URL:
client::::クライアント
navigate::::ナビゲート
navi:navigation:::ナビ
server::::サーバ
percent-::: %-
sandbox::::サンドボックス
保安:security::~:セキュリティ
url:
record::::レコード
POST:
GET:
entity:
Get:
Mail:
multipart:
計画-:plan::~

要請:request::~::リクエスト
本体:body::~::ボディ
提出元:submitter::~
	multipart:
提出用の:submission::~
提出:submission::~
提出-:submit::~
	-:submitted from

読込まれ:load され::読み込まれ::ロードされ
読込む:load する::読み込む::ロードする
読込んで:load して::読み込んで::ロードして
送信-:send:~
資源:resource::~:リソース
行先:destination::~
敵対的:hostile:~
生成元:origin::~::オリジン
同一生成元:same-origin::~::同一オリジン

	●仕様
Web:
UA:user agent:UA
algo:algorithm:::アルゴリズム
API:
browser::::ブラウザ
model::::モデル
platform::::プラットフォーム
support::::サポート
	それらの:those
下位手続き:substeps:~
事例:case:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
任意選択で:optional に:~
作者:author:~
依存-:depend:~
共通の:common な:~
共通的な:common な:よくある
利用者:user:~
効果:effect:~
単純:simple:~
含意-:imply:~
	わけではない:imply
奨励-:encourage:~
定義-:define:~
定義:definition:~
実装-:implement:~
実際:actual:~
意図-:intend:~
	意図せず:unintentional
手続き:steps:~
段:step:~
指定-:specify:~
指示-:indicate:~
挙動:behavior:ふるまい
供-:provide:~
供さな:provide しな:~
旧来の:legacy:~
	旧式:older
	旧:old
明示的:explicit:~
期待-:expect:~
条件:condition:~
正確:exact:~
歴史的:historical:~
決定-:determine:~
特定0の:particular:ある特定の
特色機能:feature:~
理由:reason:~
目的:purpose:~
矢印:arrow:~
	directional arrow
結付け:association:結び付け
結付けら:associate さ:結び付けら

要件:requirement:~
要求-:require:~
述べる:describe する:~
述べら:describe さ:~
記述-:describe:~
記述:description:~
許容-:allow:~
適切:appropriate:~
適用-:apply:~
関係性:relationship:~
関係-:relate:~
制御-:control:~
基盤:infrastructure:~
多義的:ambiguous:~
	実質的:effective:~
影響-:affect:~
意味-:mean:~
意味:meaning:~
意図的:intentional:~
改善-:improve:~
暗黙的:implicit:~
有用:useful:~
概して:typical に:~
概念:concept:~
標準:standard:~
特有の:specific な:~
	を通して:in terms of
相似的:analogous:~
相応しく:suitable に:~
規範的:normative:~
解釈-:interpret:~
	再~解釈される問題 problematic reinterpretation
適合:conforming:~
不適合:non-conforming:~
取扱う:handle する:取り扱う
要件:requirements:~
見做され:assume され:~
精確:precise:~
受容-:accept:~
方式:manner:~
	具体例として:for instance,
上書き:override:~
試みる:attempt する:~
強く:strong に:~

特別:special:~
詳細:details:~
通常の:normal な:~
避ける:avoid する:~
事実:fact:~
望む:wish する:~
組込みの:built-in:~
課題:issue:~

	可能:possible
	対処:work around
	取りやめた:drop
	欠いて:lack of
	ではなく:as opposed to
	足りる:suffice
	~~判断:think
	依然として:still:~
	基づく:based
	代わりに:instead
	おそらく:probably#1
	しかしながら，:however
	したがって:thus
	べき:should
	ほとんどの:most
	他の:other:~
	他の場合:otherwise:~
	伝える:inform:~
	利用-:use:~
	可視でない:invisible:~
	呼ばれ／称され:called::~
	場合によっては:possibly:~
	序論:introduction:~
	必要:need:~
	必要とされ:necessary:~
	様々な:various:~
	決して:never:~
	満たす:satisfy:~
	節:section:~
	望み:wishes
	読まれる用途:readable
	次の様:might be something like
	され次第:as soon as
	反し:go against
	他所:other parts
	ものと:ought
	申し分ない:fine
	考える:consider
	似た様な:something like
	ない限り，in the absence of
	全く:quite
	かかわらず:regardless
	まるごと:altogether
	複雑になって／複雑な:complicated
	担当する:has claimed responsibility
	以前は:previously
	最早:no longer
	他方:On the other hand
	呼応して:in response to
	魔法の:magic
	usable
	conclude
	overall
	stood
	follow
	-:causing
	-:loop
	nothing
	overall
	~~有効になる:kick in
	in the face of
	後者:latter:~
	扱う:treat:~
	見よ:see
	類似する:similar:~
	を以って:by means of
	例:example
	別々に:separately
	優先される:takes precedence over

	●構文／直列化
ASCII:
CR:
CRLF:CR+LF
LF:
UTF-8:
Unicode:
scalar::::スカラー
charset:
error::::エラー
keyword::::キーワード
tag::::タグ
token::::トークン
field::::フィールド
byte-stream:byte stream:::バイトストリーム
数字:digit:~
境界:boundary:~
引用符:quote:~
改行文字:newline:~
整数:integer:~
文字:character:~
文字列:string:~
	-:substring:~
構文:syntax:~
構文解析-:parse::~::パース
構文解析器:parser::~::パーサ
構文解析器挿入:parser-inserted::~::パーサ挿入
正しい:correct な:~
正規化-:normalize:~
正規化:normalization:~
省略-:omit:~
空:empty:~
空の:empty:~
空白:whitespace:~
測定-:measure:~
符号位置:code point:~
符号単位:code unit:~
符号化-:encode:~
符号化方式:encoding:~
解析済み:parsed::~::パース済み
	16 進:hexadecimal
	3 桁ごと:thousand
	部位:part:~
	開始:start:~
	16 進:hexadecimal
	基数 10:base-ten
直列化器:serializer::~::シリアライザ
近似-:approximate:~
分割-:split:~

出力:output:~
取得-:get:~

	●状態／妥当性
checkedness::::チェック有無
overflow::::オーバーフロー
underflow::::アンダーフロー
pattern::::パタン
step:
enctype:
custom::::カスタム
	難あり:suffer from／suffering from
	対象外:barred from
不一致:mismatch::~
不良:bad::~
欠落:missing::~
真偽:boolean::~
妥当性:validity:~
妥当:valid:~
	妥当でない:invalid:~
未取扱:unhandled:未取り扱いの
	~unhandled-invalid:#5
非妥当:invalid:~
不能化-:disable::~
値:value:~
選択有無:selectedness:~
候補:candidate:~
再設定-:reset::~::リセット
再設定:reset::~::リセット
制限-:limit:~
	上限／下限:limit:~
可能化-:enable:~
可能化:enabled:~
型:type:~
変換-:convert:~
変化-:change:~
	そのまま変化しない:remain unchanged
変更-:change:~
変更:changes:~
必須の:required::~
必須:required::~
拘束検証:constraint validation:~
拘束:constraints:~
拘束-:constrain:~
静的:static::~
既定:default:~:::デフォルト
既定の:default:~:::デフォルト
最大:maximum:~
最小:minimum:~
検証-:validate::~
検証:validation::~
検証なし:no-validate::~
状態:state::~
検査-:check::~::チェック
dirty::::
flag::::フラグ
違反:violation:~
問題:problem:~
行折返し:line wrapping:行の折り返し
	~~結合:coalesce
肯定的:positive:~
否定的:negative:~
変異-:mutate::~
	変異-可能:mutable
	変異-可能~性:mutability
	合う／合わない:fit


	●UI
window::::ウィンドウ
legend:
alert:
box::::ボックス
form::::フォーム
UI:
caret::::キャレット
button::::ボタン
click:
control::::コントロール
dialog::::ダイアログ
event::::イベント
欄:field::~::フィールド
field::::フィールド
file::::ファイル
focus::::フォーカス
picker:
color-well:
key::::キー
label::::ラベル
radio::::ラジオ
scrolling::::スクロール
選択肢:option::~::オプション
対話的:interactive:~
対話-:interact:やりとり
対話:interaction:~
	連関:interaction
作動化の:activation::~::アクティブ化の
報告-:report:~
報告:report:~
指名-:designate::~
改行:line break:~
方向:direction:~
	方向:dir
方向性:directionality:~
書字:writing:~
編集:edit:~
自動充填:autofill::~
自動focus:autofocus::自動 focus:自動フォーカス
自動化:automated:~
自動:automatic:~
自動的:automatic:~
進捗:progress:~
地域化-:localize:~
探索:search::検索

側:side:~

動作-:act:~
動作:action:~
座標:coordinate:~
体験:experience:~
	に注目させる:brings 〜 attention

	●UI 入力
右横書き:right-to-left:~
左横書き:left-to-right:~
	ltr／rtl
入力:input:~

	切り替えてswitch::~
	叩く:hit する:~
	-:letter
	Shift ＋:Shift modifier
e-mail::::メール
	~e-mail:email

address::::アドレス

選択-:select:~
選択:selection:~
	選択-可能:selectable
始端:start:~
	~~始端:beginning
終端:end:~
	始端~offset 〜 終端~offset: sequence of characters starting with the character at the 始端th position (in logical order) and ending with the character at the (終端-1)th position

offset::::オフセット
cursor::::カーソル
範囲:range:~
	範囲:size
	途中:in the middle
	留める:snap

埋めら:fill さ:~
埋める:fill する:~
	予め〜埋められ:prefill
打込んで:type して::~::タイプして
打込み:typing::~::タイピング
手入力-:enter:~
手入力:entry:~
手動:manual:~
	直後:just before
	直前:just after

	3 桁ごと:thousand:~
	Shift ＋:Shift modifier
	低い:low
	高い:high
	16 進:hexadecimal

	●呈示
graphical-cue:graphical cue:::グラフィック的な指示記号
具現化-:render:~
可視:visible:~

	●内容
MIME:
HTML:
plugin::::プラグイン
	入子に:nest:入れ子に
入子の:nested:入れ子の
内容:content:~
内縁:inner:~
単語:word:~
外縁:outer:~
先祖:ancestor:~
子孫:descendants:~
属性:attribute:~
形式:format:~
木:tree::~::ツリー
所有者:owner:~
所有-:own:~
文書:document:~
文脈:context:~
根:root::~::ルート
	nearest ancestor autofocus scoping root element
要素:element:~
親:parent:~
連鎖:chain:~
data::::データ
群:group::~::グループ
text::::テキスト
	~textによる:textual
列挙ed:enumerated:列挙


	●DOM／IDL／event／task
被呼出時:被 invoke 時:~
取得子:getter:~
設定子:setter:~
引数:argument:~
反映-:reflect:~
発火-:fire::~
配送-:dispatch::~
DOM:
ID:
IDL:
JS:JavaScript
call:
member::::メンバ
live:
method::::メソッド
node::::ノード
obj:object:::オブジェクト
task::::タスク
源:source::~::ソース
target::::ターゲット
queue::::キュー
取得子:getter:~
取消-:cancel::取り消::キャンセル
取消す:cancel する::取り消す::キャンセルする
作動中の:active な::~::アクティブな
接続-:connect::~




	●未分類（動詞
付加-:append:~
作成-:create:~
包含-:contain:~
合致-:match:~
挿入-:insert:~
構築-:construct:~
相違-:differ:~
置換-:replace:~
置換:replacement:~
表現-:represent:~
設定-:set:~
迂回-:bypass:~
追加-:add:~
遂行-:perform:~
	〜ないよう:prevent
除去-:remove:~
依拠-:rely:~
	依拠-可能:reliable
保全-:preserve:~
保存-:save:~
処理-:process:~
列挙:enumeration:~
初期化-:initialize:~
初期:initial:~
判別-:distinguish:~
到達-:reach:~
削除-:delete:~
呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
呼出す:invoke する:呼び出す
命名:naming:~
失敗-:fail:~
失敗:failure:~
宣言-:declare:~
挿入:insertion:~
操作-:manipulate:~
操作:manipulation:~
改変-:modify:~
演算-:operate:~
生成-:generate:~
破棄-:discard:~
移動-:move:~
翻訳-:translate:~
調整-:adjust:~
通知-:notify:~
配置-:place:~
走って:run して:~
走らす:run する:~
走らせ:run し:~
阻む:block する:~
閉じる:close する:~
対応付けら:map さ:~
	失った:lost
保守-:maintain:~
	有さない:missing
	表せ:expressible
共有-:share:~
追跡-:track:~
見出され:find され:~
参照:reference:~
切詰める:clamp する:切り詰める
	映し出:mirror
	数え:count
	空に戻す:clear
	得-:obtain
	数:number
	含-:include
	含めて:including
	新たに:newly
	減る:decrease
	示す:show
	表す:express
	起こる:happen
	返す:return
	指す:point to
	消える:away
	過ぎて:now past

	●未分類
clobbering:
	-:paragraph:~
code::::コード
entry::::エントリ
list::::リスト
literal::::リテラル
maxlength:
message::::メッセージ
minlength:
prop:property:::プロパティ
script::::スクリプト
	対象:subject
tool::::ツール
top-level::::トップレベル
位置:position:~
全部的:full:~
内部:internal:~
名:name:~
名前:name:~
在する:present する:在る
	-:variable
不完全:incomplete:~
完全:complete:~
差分:delta:~
成分:component:~
新たな:new:~
構造:structure:~
無視-:ignore:~
相対的:relative:~
色:color:~
規則:rule:~
論理:logical:~
長さ:length:~
閲覧文脈:browsing context:~
集合:set:~
頁:page:::ページ
順序:order:~
素の:plain:~
無限大:infinity:~
関連する:relevant な:~

	省略時は／optionally
	種類:kind
	結果:result
	表:table
	-:long
	~~結合:coalesce
	組:tuple:~
	( 名, 値):name-value
	非 file:non-file
	下限:lower bound
	cover
	occurrence
	now:
	+:pair
	-:long
	-:mark
	1 個の:one
	code片:snippet
	cue:
	directional
	first-in-form
	focusing
	made
	occurrence
	pointing
	previous
	using

	●指示語
既知の:known:~
現在の:current:~
	現在:currently
自前の:own:~
	頭部:leading
	一時的:temporary
	後に:subsequently
	finally
	~~最後の:final
	すべて:everything
	一部:part of
	対応する:respective
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	それら:they
	上:above
	下:below
	所与の:given
	与-:give
	両者:both
	高い:high
	低い:low
	前:before
	各:each
	同じ:same
	対応-:correspond
	対応する:corresponding
	後:after
	following
	複数の:multiple
	負の:negative
	非負:non-negative
	除-:except
	時点:instant
	最も近い:nearest
	最初の:first
	最後の:last
	自身:itself
	異なる:different
	当の:main
	任意の:arbitrary
	別の:another
	別個の:distinct

●●html_code_list

■association-of-controls-and-forms-1 bad
...
 <form id="a">
  <div id="b"></div>
 </form>
 <％script>
  document.getElementById('b').innerHTML =
     '<table><tr><td></form><form id="c"><input id="d"></table>' +
     '<input id="e">';
 </％script>
...

■directionality-1
<form action="addcomment.cgi" method=post>
 <p><label>コメント： <input type=text name="comment" ＜dirname="comment.dir"＞ required></label></p>
 <p><button name="mode" type=submit value="add">コメントを投稿する</button></p>
</form>

<form action="addcomment.cgi" method=post>
 <p><label>Comment: <input type=text name="comment" dirname="comment.dir" required></label></p>
 <p><button name="mode" type=submit value="add">Post Comment</button></p>
</form>


■minimum-input-length-1
<form action="/events/menu.cgi" method="post">
 <p><label>競技種目： <input required minlength=5 maxlength=50 name=event></label></p>
 <p><label>朝食を希望される場合は記入してください：
    <textarea name="breakfast" minlength="10"></textarea></label></p>
 <p><label>昼食を希望される場合は記入してください：
    <textarea name="lunch" minlength="10"></textarea></label></p>
 <p><label>夕食を希望される場合は記入してください：
    <textarea name="dinner" minlength="10"></textarea></label></p>
 <p><input type=submit value="request を submit する"></p>
</form>

Name of Event:
Describe what you would like for XXX, if anything:
Submit Request


■method-get-1
<form method="get" action="/search.cgi">
 <p><label>検索語句： <input type=search name=q></label></p>
 <p><input type=submit></p>
</form>

Search terms:

■method-post-1
<form method="post" action="/post-message.cgi">
 <p><label>メッセージ： <input type=text name=m></label></p>
 <p><input type=submit value="提出する"></p>
</form>

Message:
Submit message

■method-dialog-1
<dialog id="ship">
 <form method=dialog>
  <p>船はすでに入港しています。</p>
  <button type=submit value="board">乗船する</button>
  <button type=submit value="call">船長を呼ぶ</button>
 </form>
</dialog>


<p>A ship has arrived in the harbour.</p>
<button type=submit value="board">Board the ship</button>
<button type=submit value="call">Call to the captain</button>


■method-post-2
<form action="editor.cgi" method="post">
 <p><label>名前： <input required name=fn></label></p>
 <p><label>感想： <textarea required name=essay></textarea></label></p>
 <p><input type=submit name=submit value="提出する"></p>
 <p><input type=submit formnovalidate name=save value="＜保存する＞"></p>
 <p><input type=submit formnovalidate name=cancel value="取り消す"></p>
</form>

Name:
Essay:
value="Submit essay"
value="Save essay"
value="Cancel"


■autofocus-1
<input maxlength="256" name="q" value="" ＜autofocus＞>
<input type="submit" value="Search">

■form-submission-1
<form action="/find.cgi" method=get>
 <input type=text name=t>
 <input type=search name=q>
 <input type=submit>
</form>


■form-submission-2
<form action="/find.cgi" method=post enctype="multipart/form-data">
 <input type=text name=t>
 <input type=search name=q>
 <input type=submit>
</form>



●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
Forms 章の
<a href="~SPEC_URL">Form control infrastructure その他の関連する</a>
節を日本語に翻訳したものです。
~PUB
</p>

</script>



<!--%style -->
<style type="text/css">

</style>


</head>

<body>

<header id="head">
	<hgroup>
<h1>フォーム（共通） — Forms （ Form control infrastructure 他 ）</h1>
	</hgroup>

</header>


<main id="MAIN" style="display:none;">

			<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoの記述に利用されている各種記号（ ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

			</section>
			<section id="form-control-infrastructure">
<h3 title="Form control infrastructure">4.10.17. ~form~control基盤</h3>

				<section id="a-form-control's-value">
<h4 title="A form control's value">4.10.17.1. ~form ~controlの値</h4>

<p>
ほとんどの~form~controlは、
`値@
と
`~checkedness@
を持つ（後者は `input$e 要素のみから利用される）。
これらは、利用者が~controlと対話する方法を記述するために利用される。
◎
Most form controls have a value and a checkedness. (The latter is only used by input elements.) These are used to describe how the user interacts with the control.
</p>

<p>
~controlの`値$は、その内部~状態である
— なので、利用者の現在の入力に合致しないこともある。
◎
A control's value is its internal state. As such, it might not match the user's current input.
</p>

<p class="example">
具体例として、利用者が 数字を期待する `Number$st 欄の中に単語
"<kbd>three</kbd>"
を手入力した場合、利用者の入力は
文字列 "three" になるが，~controlの`値$は そのまま変化しない。
あるいは、利用者が `Email$st 欄の中へ~e-mail~address
"<kbd>&nbsp;~awesomeAt</kbd>"
（頭部に空白あり）を手入力した場合、利用者の入力は文字列 `&nbsp;~awesomeAt^l になるが，~browserの~UIは それを`値$ `~awesomeAt^l （頭部に空白なし）に翻訳するであろう。
◎
For instance, if a user enters the word "three" into a numeric field that expects digits, the user's input would be the string "three" but the control's value would remain unchanged. Or, if a user enters the email address " awesome@example.com" (with leading whitespace) into an email field, the user's input would be the string " awesome@example.com" but the browser's UI for email fields might translate that into a value of "awesome@example.com" (without the leading whitespace).
</p>

<p>
各［
`input$e ／ `textarea$e
］要素は、
`~dirty値~flag@
を持つ。
これは、要素の［
`値$と既定の値
］との連関を追跡するために利用される
— ~F の下では，`値$は 既定の値を映し出し、 ~T の下では，既定の値は無視される。
◎
input and textarea elements have a dirty value flag. This is used to track the interaction between the value and default value. If it is false, value mirrors the default value. If it is true, the default value is ignored.
</p>

<p>
各 `input$e 要素は，別々に定義される
`値たち@
も持つ。
それは、要素の `~multipleI$a 属性に対する 拘束検証の挙動を定義するためにある。
◎
To define the behavior of constraint validation in the face of the input element's multiple attribute, input elements can also have separately defined values.
</p>

<p>
`値$を伴うすべての~form~controlは、
`~API値@
を得るための~algoも備える。
それは、［
`maxlength$a ／ `minlength$a
］属性の挙動, および `textarea$e 要素に特有の他の~APIを定義するためにある。
既定では、この~algoは，単純に~controlの`値$を返す。
◎
To define the behavior of the maxlength and minlength attributes, as well as other APIs specific to the textarea element, all form control with a value also have an algorithm for obtaining an API value. By default this algorithm is to simply return the control's value.
</p>

<p>
`select$e 要素は、`値$を持たない
— 代わりに，その `option$e 要素の`選択有無$optが利用される。
◎
The select element does not have a value; the selectedness of its option elements is what is used instead.
</p>


				</section>
				<section id="mutability">
<h4 title="Mutability">4.10.17.2. 変異-可能~性</h4>

<p>
~form~controlは
`変異-可能@
として指名され得る。
◎
A form control can be designated as mutable.
</p>


<p class="note">注記：
これは，（要素がそう指名されているかどうかに依拠する，この仕様における定義と要件を以って）、利用者が~form~controlの`値$や`~checkedness$を改変できるかどうか，および ~controlは予め自動的に埋められるかどうかを決定する。
◎
This determines (by means of definitions and requirements in this specification that rely on whether an element is so designated) whether or not the user can modify the value or checkedness of a form control, or whether or not a control can be automatically prefilled.
</p>

				</section>
				<section id="association-of-controls-and-forms">
<h4 title="Association of controls and forms">4.10.17.3. ~controlと~formとの結付け</h4>


<p>
各 `~formに所有され得る要素$には、［
要素の
`~form所有者@
と呼ばれる，ある `form$e 要素
］との関係性が与えられ得る。
どの `form$e 要素にも所有されない要素の`~form所有者$は ~NULL とする。
◎
A form-associated element can have a relationship with a form element, which is called the element's form owner. If a form-associated element is not associated with a form element, its form owner is said to be null.
</p>

<p class="trans-note">【
“所有される”
— 原文では、単に “結付けられる（ associated ）” であるが、この訳では
“所有-” ／ “所有され得る”
という語で，その結付けを表すことにする。
例えば， “~form %F が所有する要素” とは、`~formに所有され得る要素$であって［
その`~form所有者$ ~EQ %F
］なるもの（または、それらが成す集合）を意味する。
】【
同じ要素が同時に複数の `form$e 要素から所有されることはない。
】</p>

<p>
各 `~formに所有され得る要素$には、
`構文解析器挿入~flag@
が結付けられる。
【指定されない限り ~OFF 。】
◎
A form-associated element has an associated parser inserted flag.
</p>

<p>
`~formに所有され得る要素$は、既定では，それに最も近い先祖 `form$e 要素に所有される（下に述べる）が、それらのうち`~listされ$る要素には，これを上書きする
`form@a
属性が指定されても~MAY。
◎
A form-associated element is, by default, associated with its nearest ancestor form element (as described below), but, if it is listed, may have a form attribute specified to override this.
</p>

<p class="note">注記：
この特色機能により、入子の `form$e 要素~用の~supportを欠いている下でも，作者は対処できるようになる。
◎
This feature allows authors to work around the lack of support for nested form elements.
</p>

<p>
`~listされ$る要素に指定する `form$a 属性の値は、要素の`木$内にある `form$e 要素の`~ID$で~MUST。
◎
If a listed form-associated element has a form attribute specified, then that attribute's value must be the ID of a form element in the element's tree.
</p>

<p class="note">注記：
この節における規則は、複雑になっている
— ［
文書／`木$
］が適合ならば，入子の `form$e 要素を包含することは決してないが、そのような入子の要素を有する`木$を生成することは，事実として全く可能なので（例： ~DOM操作を遂行する~scriptを用いて）。
それまた、~HTML構文解析器における規則によっても複雑になっている
— 歴史的~理由から、`~formに所有され得る要素$が，その先祖でない `form$e 要素に所有されることもあるので。
◎
The rules in this section are complicated by the fact that although conforming documents or trees will never contain nested form elements, it is quite possible (e.g., using a script that performs DOM manipulation) to generate trees that have such nested elements. They are also complicated by rules in the HTML parser that, for historical reasons, can result in a form-associated element being associated with a form element that is not its ancestor.
</p>

<p>
`~formに所有され得る要素$の作成-時には、その`~form所有者$は，~NULLに（所有者なし）に初期化され~MUST。
◎
When a form-associated element is created, its form owner must be initialized to null (no owner).
</p>

<p class="algo-head">
所与の~form %~form に，`~formに所有され得る要素$ %要素 を
`所有させる@
ときは、［
%要素 の`~form所有者$ ~SET %~form
］に設定し~MUST。
◎
When a form-associated element is to be associated with a form, its form owner must be set to that form.
</p>

<p class="trans-note">【
この訳では、この用語は利用せず，直接的に
“%要素 の`~form所有者$ ~SET %~form”
と記すことにする。
】</p>

<p>
`~formに所有され得る要素$ %要素 に対し，次が生じたときは、~UAは %要素 の`~form所有者を再設定-$し~MUST：
◎
↓</p>

<ul>
	<li>
［
%要素 の`構文解析器挿入~flag$ ~EQ ~ON
］の下で，
%要素 または そのいずれかの先祖が`挿入された$nodeとき。
◎
When a form-associated element or one of its ancestors is inserted, then:
• If the form-associated element's parser inserted flag is set, then return.
• Reset the form owner of the form-associated element.
</li>
	<li>
［
%要素 の`~form所有者$ %所有者 ~NEQ ~NULL 
］の下で，
%要素 または そのいずれかの先祖が`除去された$node結果、
%要素, %所有者 は同じ`木$内でなくなったとき。
◎
When a form-associated element or one of its ancestors is removed, then:
• If the form-associated element has a form owner and the form-associated element and its form owner are no longer in the same tree, then reset the form owner of the form-associated element.
</li>
	<li>
%要素 が`~listされ$る要素であって，その `form$a 属性が［
設定- ／ 変更- ／除去-
］されたとき。
◎
When a listed form-associated element's form attribute is set, changed, or removed, then the user agent must reset the form owner of that element.
</li>
	<li>
<p>
%要素 が`~listされ$る要素であって， `form$a 属性を有している下で：
</p>
<ul><li>`木$内のある要素の`~ID$が変更されたとき。
</li><li>`~ID$を伴うある要素が，当の`文書$［
の`中へ挿入された$ ／ `から除去された$
］とき。
</li></ul>

◎
When a listed form-associated element has a form attribute and the ID of any of the elements in the tree changes, then the user agent must reset the form owner of that form-associated element.
◎
When a listed form-associated element has a form attribute and an element with an ID is inserted into or removed from the Document, then the user agent must reset the form owner of that form-associated element.
</li>
</ul>

<div >
<p class="algo-head">
~UAは、`~formに所有され得る要素$ %要素 の
`~form所有者を再設定-@
するときは、［
%要素 の`~form所有者$ ~SET
~DOMの改変-後の時点で 次の手続きを走らせた結果
］にし~MUST：
</p>

<ol>
	<li>
%要素 の`構文解析器挿入~flag$ ~SET ~OFF
</li>
	<li>
~IF［
%要素 は`接続されて$いる
］~AND［
%要素 は`~listされ$る要素である
］~AND［
%要素 は `form$a 内容~属性を有する
］~AND［
%要素 の`木$内に［
`~ID$ ~EQ ［
%要素 の `form$a 内容~属性の値
］］なる要素があって，それらのうち`木~順序$で最初のものは `form$e 要素である
］
⇒
~RET その `form$e 要素
</li>
	<li>
~IF ［
%要素 の先祖に `form$e 要素は在る
］
⇒
~RET それらのうち %要素 に最も近いもの
</li>
	<li>
~RET ~NULL
</li>
</ol>

<p class="trans-note">【
この訳では、原文の記述を整理して，等価な結果が得られるよう単純化している。
】</p>

◎
When the user agent is to reset the form owner of a form-associated element element, it must run the following steps:

• Unset element's parser inserted flag.
• If all of the following conditions are true
•• element's form owner is not null
•• element is not listed or its form content attribute is not present
•• element's form owner is its nearest form element ancestor after the change to the ancestor chain
then do nothing, and return.

• Set element's form owner to null.

• If element is listed, has a form content attribute, and is connected, then:
•• If the first element in element's tree, in tree order, to have an ID that is case-sensitively equal to element's form content attribute's value, is a form element, then associate the element with that form element.

• Otherwise, if element has an ancestor form element, then associate element with the nearest such ancestor form element.
</div>

<div class="example">

<p>
次の不適合~code片：
◎
In the following non-conforming snippet:
</p>

`association-of-controls-and-forms-1^xCode

<p>
"d" の`~form所有者$は，内縁の入子の~form "c" になる一方で、
"e" の`~form所有者$は，外縁の~form "a" になる。
◎
The form owner of "d" would be the inner nested form "c", while the form owner of "e" would be the outer form "a".
</p>

<p>
これは次のようにして起こる：
先ず，~node "e" は、`~HTML構文解析器$において "c" に結付けられる。
次に，`innerHTML$m ~algoは、~nodeたちを一時的な文書から要素 "b" へ移動する。
各~nodeは、この時点で，各自の先祖の連鎖が変更されたことを見る。
したがって、構文解析器による “魔法の” 結付けすべては、通常の，先祖への結付けに再設定される。
◎
This happens as follows: First, the "e" node gets associated with "c" in the HTML parser. Then, the innerHTML algorithm moves the nodes from the temporary document to the "b" element. At this point, the nodes see their ancestor chain change, and thus all the "magic" associations done by the parser are reset to normal ancestor associations.
</p>

<p>
もっとも、この例は不適合な文書である
— そこには、入子の `form$e 要素による内容~modelの違反があり，また
`&lt;/form&gt;^c ~tagにも`構文解析-~error$がある。
◎
This example is a non-conforming document, though, as it is a violation of the content models to nest form elements, and there is a parse error for the &lt;/form&gt; tag.
</p>

</div>


<dl class="domintro">
	<dt>%element . `form$m</dt>
	<dd>
要素の`~form所有者$が［
在るならば それ ／
無いならば ~NULL
］を返す。
◎
Returns the element's form owner.
◎
Returns null if there isn't one.
</dd>
</dl>


<dl class="idl-def">
	<dt>`form@m</dt>
	<dd>
`~formに所有され得る要素$のうち，`~listされ$るものは、この~IDL属性を有する。
◎
↓</dd>
	<dd>
取得子は、［
此れの`~form所有者$ ~NEQ ~NULL ならば それ ／
~ELSE_ ~NULL 
］を返さ~MUST。
◎
Listed form-associated elements have a form IDL attribute, which, on getting, must return the element's form owner, or null if there isn't one.
</dd>

</dl>



				</section>
			</section>
			<section id="attributes-common-to-form-controls">
<h3 title="Attributes common to form controls">4.10.18. 各種~form~controlに共通の属性</h3>

				<section id="naming-form-controls:-the-name-attribute">
<h4 title="Naming form controls: the name attribute">4.10.18.1. ~form~controlの命名： `name^a 属性</h4>

<p>
`name@a
内容~属性は、~form~controlの名前を与える。
それは、`~form提出$, および
`form$e 要素の `elements$m ~objにて利用される。
この属性の値に［
空~文字列 ／ `isindex^v
］を指定しては~MUST_NOT。
◎
The name content attribute gives the name of the form control, as used in form submission and in the form element's elements object. If the attribute is specified, its value must not be the empty string or isindex.
</p>

<p class="note">注記：
いくつかの~UAは、歴史的に，［
名前 `isindex^v を伴う “first-in-form” ~text~control
］用に特別な~supportを実装していた。
また，この仕様は、以前は，そのための関係する~UA要件を定義していた。
しかしながら，一部の~UAは、後にその特別な~supportを取りやめたため、関係する要件は この仕様から除去された。
なので、旧来の~UAから再~解釈される問題を避けるため、名前 `isindex^v は最早~許容されない。
◎
A number of user agents historically implemented special support for first-in-form text controls with the name isindex, and this specification previously defined related user agent requirements for it. However, some user agents subsequently dropped that special support, and the related requirements were removed from this specification. So, to avoid problematic reinterpretations in legacy user agents, the name isindex is no longer allowed.
</p>

<p>
`~nameF$a に対しては［
`isindex^v, 空~文字列
］以外の どの値も許容される。
◎
Other than isindex, any non-empty value for name is allowed.＼
</p>

<p>
［
`value$a 属性を有さない `Hidden$st ~control
］の `name$a 属性~用の~keyword
`_charset_@v
は特別であり，指定された場合、
`value$a 属性に代わって［
~controlを`所有-$している~formの`符号化方式$form
］が，提出-時における~controlの値を自動的に与えるようになる。
◎
The name _charset_ is special: if used as the name of a Hidden control with no value attribute, then during submission the value attribute is automatically given a value consisting of the submission character encoding.
</p>

<dl class="idl-def">
	<dt>`name@m</dt>
	<dd>
`name$a 内容~属性を`反映-$し~MUST。
◎
The name IDL attribute must reflect the name content attribute.
</dd>

</dl>

<div class="note">

<p>注記：
~DOM~clobbering【 “痛める” 】は、共通的な保安~上の課題をもたらす。
`name$a 内容~属性に組込みの~form~propの名前を利用するのは、避けること。
◎
DOM clobbering is a common cause of security issues. Avoid using the names of built-in form properties with the name content attribute.
</p>

<p>
次の例では、 `input$e 要素は組込みの `method$a ~propを上書きする：
◎
In this example, the input element overrides the built-in method property:
</p>

<pre>
let %form = document.createElement("form");
let %input = document.createElement("input");
%form.appendChild(%input);

%form.method;           // =&gt; "get"
%input.name = "method"; /* <span class="comment">
~DOM~clobberingはここで生じる
◎
DOM clobbering occurs here
</span> */
%form.method === %input; // =&gt; true
</pre>

<p>
`input^e の名前は，組込みの~form~propより優先されるので、
`form.method^c による~JS参照は、組込みの `method$a ~propの代わりに，名前 `method^l の `input$e 要素を指すことになる。
◎
Since the input name takes precedence over built-in form properties, the JavaScript reference form.method will point to the input element named "method" instead of the built-in method property.
</p>

</div>

				</section>
				<section id="submitting-element-directionality:-the-dirname-attribute">
<h4 title="Submitting element directionality: the dirname attribute">4.10.18.2. 要素~方向性の提出-法： `dirname^a 属性</h4>

<p>
~form~control要素の
`dirname@a
属性は、要素の`方向性$の提出を可能化し，`~form提出$の際に この値を包含させる名前を与える。
この属性には、空~文字列を指定しては~MUST_NOT。
◎
The dirname attribute on a form control element enables the submission of the directionality of the element, and gives the name of the control that contains this value during form submission. If such an attribute is specified, its value must not be the empty string.
</p>

<div class="example">
<p>
~text~controlと提出-~buttonを包含する~formの例：
◎
In this example, a form contains a text control and a submission button:
</p>

`directionality-1^xCode

<p>
利用者がこの~formを提出したとき、~UAは，順に［
"comment", "comment.dir", "mode"
］と称される 3 個の欄を含める。
利用者が "Hello" と手入力していたなら、その提出~本体は，次の様になるであろう：
◎
When the user submits the form, the user agent includes three fields, one called "comment", one called "comment.dir", and one called "mode"; so if the user types "Hello", the submission body might be something like:
</p>

<pre>
comment=Hello&amp;<mark>comment.dir=ltr</mark>&amp;mode=add
</pre>


<p>
利用者が手動で書字~方向を右横書きに切り替えて，
"<span dir="rtl" lang="ar">مرحبا</span>"
と手入力していたなら、その提出~本体は，次の様になるであろう：
◎
If the user manually switches to a right-to-left writing direction and enters "مرحبا", the submission body might be something like:
</p>

<pre>
comment=~rtlWord1&amp;<mark>comment.dir=rtl</mark>&amp;mode=add
</pre>

</div>


				</section>
				<section id="limiting-user-input-length:-the-maxlength-attribute">
<h4 title="Limiting user input length: the maxlength attribute">4.10.18.3. 利用者~入力の長さ上限の設定-法： `maxlength^a 属性</h4>

<p>
`~form~control~maxlength属性@
は、`~dirty値~flag$により制御され、利用者が入力できる文字~数の上限を宣言する。
この “文字~数” は，`~JS文字列~長さ$で測定され、
`textarea$e 要素の事例においては，すべての改行文字は 1 個の文字に正規化される
（ ~CRLF ではなく）。
◎
A form control maxlength attribute, controlled by the dirty value flag, declares a limit on the number of characters a user can input. The "number of characters" is measured using JavaScript string length and, in the case of textarea elements, with all newlines normalized to a single character (as opposed to CRLF pairs).
</p>

<p>
要素の `~form~control~maxlength属性$に指定する値は
`妥当な非負~整数$で~MUST。
要素の
`値に許容される最大~長さ@
は、［［
要素がこの属性を有する
］~AND［
その値を`非負~整数として構文解析-$した結果 ~NEQ ~error
］ならば 結果の数 ／
~ELSE_ ε
］とする。
◎
If an element has its form control maxlength attribute specified, the attribute's value must be a valid non-negative integer. If the attribute is specified and applying the rules for parsing non-negative integers to its value results in a number, then that number is the element's maximum allowed value length. If the attribute is omitted or parsing its value results in an error, then there is no maximum allowed value length.
</p>

<div class="p">
<p><strong>拘束検証</strong>
⇒
要素が次をすべて満たしている間は、`長過ぎる難あり$になる：
</p>

<ul ><li>その`~dirty値~flag$ ~EQ ~T
</li><li>その`値$が最後に変更されたのは，利用者の編集による（~scriptによるものではなく）
</li><li>その`~API値$の`~JS文字列~長さ$ ~GT その`値に許容される最大~長さ$ ~NEQ ε
</li></ul>

◎
Constraint validation: If an element has a maximum allowed value length, its dirty value flag is true, its value was last changed by a user edit (as opposed to a change made by a script), and the JavaScript string length of the element's API value is greater than the element's maximum allowed value length, then the element is suffering from being too long.
</div>

<p>
~UAは、利用者が，要素の`~API値$を［
その`~JS文字列~長さ$ ~GT 要素の`値に許容される最大~長さ$
］なる値に設定させないようにして~MAY。
◎
User agents may prevent the user from causing the element's API value to be set to a value whose JavaScript string length is greater than the element's maximum allowed value length.
</p>

<p class="note">注記：
`textarea$e 要素の事例では、`~API値$と`値$は相違する。
特に、`値に許容される最大~長さ$が検査される前に，それ用に`改行を正規化-$する（一方で `行折返し$は適用されない)。
◎
In the case of textarea elements, the API value and value differ. In particular, the textarea line break normalization transformation is applied before the maximum allowed value length is checked (whereas the textarea wrapping transformation is not applied).
</p>


				</section>
				<section id="setting-minimum-input-length-requirements:-the-minlength-attribute">
<h4 title="Setting minimum input length requirements: the minlength attribute">4.10.18.4. 利用者~入力の長さ下限の設定-法： `minlength^a 属性</h4>

<p>
`~form~control~minlength属性@
は、`~dirty値~flag$により制御され、利用者が入力できる文字~数の下限を宣言する。
この “文字~数” は，`~JS文字列~長さ$で測定され、
`textarea$e 要素の事例においては、すべての改行文字は 1 個の文字に正規化される（~CRLFでなく）。
◎
A form control minlength attribute, controlled by the dirty value flag, declares a lower bound on the number of characters a user can input. The "number of characters" is measured using JavaScript string length and, in the case of textarea elements, with all newlines normalized to a single character (as opposed to CRLF pairs).
</p>

<p class="note">注記：
`minlength$a 
属性は `required^a 属性を含意しない。
当の~form~controlが `required^a 属性を有さない場合、値は依然として省略し得る
— `minlength$a 属性が~~有効になるのは、利用者が何らかの値を手入力したときに限られる。
作者は、空~文字列を許容しない場合には， `required^a 属性も設定する必要がある。
◎
The minlength attribute does not imply the required attribute. If the form control has no required attribute, then the value can still be omitted; the minlength attribute only kicks in once the user has entered a value at all. If the empty string is not allowed, then the required attribute also needs to be set.
</p>

<p>
要素の`~form~control~minlength属性$に指定する値は、`妥当な非負~整数$で~MUST。
要素の
`値に許容される最小~長さ@
は、［［
要素が この属性を有する
］~AND［
その値を`非負~整数として構文解析-$した結果 ~NEQ ~error
］ならば 結果の数 ／
~ELSE_ ε
］とする。
◎
If an element has its form control minlength attribute specified, the attribute's value must be a valid non-negative integer. If the attribute is specified and applying the rules for parsing non-negative integers to its value results in a number, then that number is the element's minimum allowed value length. If the attribute is omitted or parsing its value results in an error, then there is no minimum allowed value length.
</p>

<p>
要素の［
`値に許容される最大~長さ$,
`値に許容される最小~長さ$
］の両者とも ε でない場合、［
`値に許容される最小~長さ$ ~LTE `値に許容される最大~長さ$
］で~MUST。
◎
If an element has both a maximum allowed value length and a minimum allowed value length, the minimum allowed value length must be smaller than or equal to the maximum allowed value length.
</p>

<div class="p">
<p><strong>拘束検証</strong>
⇒
要素が次をすべて満たしている間は、`短か過ぎる難あり$になる
</p>

<ul ><li>その`~dirty値~flag$ ~EQ ~T
</li><li>その`値$が最後に変更されたのは，利用者の編集による（~scriptによるものではなく）
</li><li>その`値$ ~NEQ 空~文字列
</li><li>その`~API値$の`~JS文字列~長さ$ ~LT その`値に許容される最小~長さ$ ~NEQ ε
</li></ul>

◎
Constraint validation: If an element has a minimum allowed value length, its dirty value flag is true, its value was last changed by a user edit (as opposed to a change made by a script), its value is not the empty string, and the JavaScript string length of the element's API value is less than the element's minimum allowed value length, then the element is suffering from being too short.
</div>


<div class="example">

<p>
次の例には 4 個の~text~controlがある。
最初のそれは必須であり、 5 文字 以上にする必要がある。
他の 3 個は任意選択であるが、利用者が埋める場合には， 10 文字~以上を手入力する必要がある。
◎
In this example, there are four text controls. The first is required, and has to be at least 5 characters long. The other three are optional, but if the user fills one in, the user has to enter at least 10 characters.
</p>

`minimum-input-length-1^xCode

</div>

				</section>
				<section id="enabling-and-disabling-form-controls:-the-disabled-attribute">
<h4 title="Enabling and disabling form controls: the disabled attribute">4.10.18.5. ~form~controlの可能化-法と不能化-法： `disabled^a 属性</h4>

<p>
`disabled@a
内容~属性は`真偽~属性$である。
◎
The disabled content attribute is a boolean attribute.
</p>

<p class="note">注記：
`option$e 要素~用の
<a href="~HEforms#attr-option-disabled">`disabled^a</a>
属性,
`optgroup$e 要素~用の
<a href="~HEforms#attr-optgroup-disabled">`disabled^a</a>
属性は、別々に定義される。
◎
The disabled attribute for option elements and the disabled attribute for optgroup elements are defined separately.
</p>

<p>
~form~control %C は、次のいずれかを満たすならば
`不能化され@
ているとされる：
◎
A form control is disabled if any of the following conditions are met:
</p>

<ol>
	<li>
<p>
%C は次をすべて満たす
</p>
<ul ><li>［
`button$e ／ `input$e ／ `select$e ／ `textarea$e
］要素である
</li><li>`disabled$a 属性を有する（その値にかかわらず）
</li></ul>

◎
The element is a button, input, select, or textarea element, and the disabled attribute is specified on this element (regardless of its value).
</li>
	<li>
<p>
次をすべて満たす要素 %F がある
</p>

<ul ><li>%F は `fieldset$e 要素である
</li><li>%F は `~disabled0$a 属性を有する
</li><li>%C ~IN { %F の子孫 }
</li><li>［
%F の`~legend$ ~EQ ε
］~OR［
%C ~NIN { %F の`~legend$の子孫 }
］
</li></ul>


◎
The element is a descendant of a fieldset element whose disabled attribute is specified, and is not a descendant of that fieldset element's first legend element child, if any.
</li>
</ol>

<p>
~form~controlが`不能化され$ている間は、`利用者~対話~task源$から`~queueされ$る どの `click$et ~eventも，その要素に配送されないようにし~MUST。
◎
A form control that is disabled must prevent any click events that are queued on the user interaction task source from being dispatched on the element.
</p>

<p><strong>拘束検証</strong>
⇒
要素は、`不能化され$ている間は，`拘束検証の対象外$になる
◎
Constraint validation: If an element is disabled, it is barred from constraint validation.
</p>

<dl class="idl-def">
	<dt>`disabled@m</dt>
	<dd>
`disabled$a 内容~属性を`反映-$し~MUST。
◎
The disabled IDL attribute must reflect the disabled content attribute.
</dd>

</dl>


				</section>
				<section id="form-submission">
<h4 title="Form submission">4.10.18.6. ~form提出</h4>

<p>
`~form提出用の属性@
は、 `form$e 要素にも，`提出-~button$†にも指定できる。
（† ~formを提出する~buttonを表現する要素
— 例えば `input$e 要素のうち `type$a 属性が `Submit$st 状態にあるもの。）
◎
Attributes for form submission can be specified both on form elements and on submit buttons (elements that represent buttons that submit forms, e.g. an input element whose type attribute is in the Submit Button state).
</p>

<p>
`form$e 要素には、次に挙げる`~form提出用の属性$が指定されて~MAY
⇒
`action$a, `enctype$a, `method$a, `novalidate$a, `target$a
◎
The attributes for form submission that may be specified on form elements are action, enctype, method, novalidate, and target.
</p>

<p>
`提出-~button$には、次に挙げる，対応する`~form提出用の属性$が指定されて~MAY
⇒
`formaction$a, `formenctype$a, `formmethod$a, `formnovalidate$a, `formtarget$a
— これらの属性の省略-時の既定は、 `form$e 要素に与えられた対応する属性の値になる。
◎
The corresponding attributes for form submission that may be specified on submit buttons are formaction, formenctype, formmethod, formnovalidate, and formtarget. When omitted, they default to the values given on the corresponding attributes on the form element.
</p>

<hr>

<p>
`action@a
／
`formaction@a
内容~属性に指定する値は、`前後~空白~可の妥当かつ空でない~URL$で~MUST。
◎
The action and formaction content attributes, if specified, must have a value that is a valid non-empty URL potentially surrounded by spaces.
</p>

<div >
<p class="algo-head">
要素の
`動作@
は、次に従って決定される値である：
</p>

<ol>
	<li>
［
要素は`提出-~button$である
］~AND［
要素は `formaction$a 属性を有する
］ならば その値
</li>
	<li>
~ELSE_ ［
要素の`~form所有者$ %O ~NEQ ~NULL
］~AND［
%O は `action$a 属性を有する
］ならば その値
</li>
	<li>
~ELSE_ 空~文字列
</li>
</ol>

◎
The action of an element is the value of the element's formaction attribute, if the element is a submit button and has such an attribute, or the value of its form owner's action attribute, if it has one, or else the empty string.
</div>

<hr>

<p>
`method@a
／
`formmethod@a
内容~属性は、`列挙ed属性$であり，次の~keywordと状態をとり得る：
◎
The method and formmethod content attributes are enumerated attributes with the following keywords and states:
</p>

<ul>
	<li>
~keyword
`get@v
は、
`GET@st
状態に対応付けられる
— それは、~HTTP~GET~methodを指示する。
◎
The keyword get, mapping to the state GET, indicating the HTTP GET method.
</li>
	<li>
~keyword
`post@v
は、
`POST@st
状態に対応付けられる
— それは、~HTTP~POST~methodを指示する。
◎
The keyword post, mapping to the state POST, indicating the HTTP POST method.
</li>
	<li>
~keyword
`dialog@v
は、
`dialog@st
状態に対応付けられる
— それは、次が意図されることを指示する
⇒
`form$e の提出-時に，その~formが見出される `dialog$e ~boxが［
在るならば それを閉じる ／
無いならば 提出しない
］
◎
The keyword dialog, mapping to the state dialog, indicating that submitting the form is intended to close the dialog box in which the form finds itself, if any, and otherwise not submit.
</li>
</ul>

<p>
これらの属性に対する`妥当でない値~用の既定$は、
`GET$st 状態とする。
`method$a 属性に対する`値なし用の既定$も
`GET$st 状態とする。
（ `formmethod$a 属性には，［
`値なし用の既定$ ／ `妥当でない値~用の既定$
］は無い。）
◎
The invalid value default for these attributes is the GET state. The missing value default for the method attribute is also the GET state. (There is no missing value default or invalid value default for the formmethod attribute.)
</p>


<p>
要素の
`~method@
は、上に与えた いずれかの状態をとる
— それは、［
要素は`提出-~button$である
］~AND［
要素は `formmethod$a 属性を有する
］ならば その属性の状態 ／
~ELSE_ 要素の`~form所有者$の `method$a 属性の状態
］とする。
◎
The method of an element is one of those states. If the element is a submit button and has a formmethod attribute, then the element's method is that attribute's state; otherwise, it is the form owner's method attribute's state.
</p>

<div class="example">

<p>
`method$a 属性を利用して 既定の値 `get$v を明示的に指定する例
— 探索~queryは、~URL内に提出されるようになる：
◎
Here the method attribute is used to explicitly specify the default value, "get", so that the search query is submitted in the URL:
</p>

`method-get-1^xCode

</div>

<div class="example">

<p>
他方， `method$a 属性に値 `post$v に指定した場合、利用者の~messageは，~HTTP要請の本体~内に提出される：
◎
On the other hand, here the method attribute is used to specify the value "post", so that the user's message is submitted in the HTTP request's body:
</p>

`method-post-1^xCode

</div>

<div class="example">

<p>
次の例では、 `form$e は `dialog$e に利用される。
~formが提出されたとき~dialogを自動的に閉じるため、
`method$a 属性には `dialog$v ~keywordが利用されている。
◎
In this example, a form is used with a dialog. The method attribute's "dialog" keyword is used to have the dialog automatically close when the form is submitted.
</p>

`method-dialog-1^xCode
<pre class="html-code">
&lt;script&gt;
 var %ship = document.getElementById('ship');
 %ship.showModal();
 %ship.onclose = function (%event) {
   if (%ship.returnValue == 'board') {
     // ...
   } else {
     // ...
   }
 };
&lt;/script&gt;
</pre>

</div>

<hr>

<p>
`enctype@a
／
`formenctype@a
内容~属性は、`列挙ed属性$であり，次の~keywordと状態をとり得る：
◎
The enctype and formenctype content attributes are enumerated attributes with the following keywords and states:
</p>

<ul>
	<li>
"`~form_urlencoded@sT"
~keywordと, 対応する状態。
◎
The "application/x-www-form-urlencoded" keyword and corresponding state.
</li>
	<li>
"`~mp_form_data@sT"
~keywordと, 対応する状態。
◎
The "multipart/form-data" keyword and corresponding state.
</li>
	<li>
"`~text_plain@sT"
~keywordと, 対応する状態。
◎
The "text/plain" keyword and corresponding state.
</li>
</ul>

<p>
［
これらの属性に対する `妥当でない値~用の既定$ ／
`enctype$a 属性に対する`値なし用の既定$
］は、 `~form_urlencoded$sT 状態とする。
（ `formenctype$a 属性には，［
`値なし用の既定$ ／ `妥当でない値~用の既定$
］は無い。）
◎
The invalid value default for these attributes is the application/x-www-form-urlencoded state. The missing value default for the enctype attribute is also the application/x-www-form-urlencoded state. (There is no missing value default or invalid value default for the formenctype attribute.)
</p>

<p>
要素の
`~enctype@
は、これら 3 状態のいずれかをとり，［
要素は［
`提出-~button$である
］~AND［
`formenctype$a 属性を有する
］ならばその属性の状態 ／
~ELSE_ 要素の`~form所有者$の`enctype$a 属性の状態
］になるとする。
◎
The enctype of an element is one of those three states. If the element is a submit button and has a formenctype attribute, then the element's enctype is that attribute's state; otherwise, it is the form owner's enctype attribute's state.
</p>

<hr>

<p>
`target@a
／
`formtarget@a
内容~属性に指定する値は、`妥当な閲覧文脈~名または~keyword$で~MUST。
◎
The target and formtarget content attributes, if specified, must have values that are valid browsing context names or keywords.
</p>

<hr>

<p>
`novalidate@a
／
`formnovalidate@a
内容~属性は`真偽~属性$である。
在する場合、
~form／要素
は，提出の間に検証されないことを指示する。
◎
The novalidate and formnovalidate content attributes are boolean attributes. If present, they indicate that the form is not to be validated during submission.
</p>

<p>
要素の
`検証なし状態@
は、［
要素が次を満たすならば ~T ／
~ELSE_ ~F
］とする
⇒
［［
`提出-~button$である
］~AND［
`formnovalidate$a 属性を有する
］］~OR［
`~form所有者$は［
~NULL でない, かつ `novalidate$a 属性を有する
］］
◎
The no-validate state of an element is true if the element is a submit button and the element's formnovalidate attribute is present, or if the element's form owner's novalidate attribute is present, and false otherwise.
</p>

<div class="example">
<p>
この属性は、検証~拘束を備える~formに “保存-” ~buttonを含ませて，［
利用者が，~form内の~dataを全部的に手入力していない場合でも、それらの進捗を保存できる
］ようにするときに有用になる。
次の単純な~form例には、 2 個の必須の欄に加えて， 3 個の~button
— ~form提出-用の~button（両~欄とも埋めることが要求される）,
<mark>保存-用の~button</mark>（利用者が後で戻って来て埋められるようにする）,
~formを まるごと取消す~button —
がある：
◎
This attribute is useful to include "save" buttons on forms that have validation constraints, to allow users to save their progress even though they haven't fully entered the data in the form. The following example shows a simple form that has two required fields. There are three buttons: one to submit the form, which requires both fields to be filled in; one to save the form so that the user can come back and fill it in later; and one to cancel the form altogether.
</p>

`method-post-2^xCode

</div>

<hr>

<div class="p">
<dl class="idl-def">
	<dt>`action@m</dt>
	<dd>
同じ名前の内容~属性を`反映-$し~MUST。
ただし、取得子は，［
此れは その内容~属性を有さない
］~OR［
此れは その内容~属性を有していて，その値 ~EQ 空~文字列
］ならば、此れの`~node文書$の`~URL$docを返さ~MUST。
</dd>

	<dt>`target@m</dt>
	<dd>
同じ名前の内容~属性を`反映-$し~MUST。
</dd>

	<dt>`method@m</dt>
	<dt>`enctype@m</dt>
	<dd>
`既知の値のみに制限され$る下で，同じ名前の対応する内容~属性を`反映-$し~MUST。
</dd>

	<dt>`encoding@m</dt>
	<dd>
`既知の値のみに制限され$る下で，
`enctype$a 内容~属性を`反映-$し~MUST。
</dd>

	<dt>`noValidate@m</dt>
	<dd>
`novalidate$a 内容~属性を`反映-$し~MUST。
</dd>

	<dt>`formAction@m</dt>
	<dd>
`formaction$a 内容~属性を`反映-$し~MUST。
ただし、取得子は，［
此れは その内容~属性を有さない
］~OR［
此れは その内容~属性を有していて，その値 ~EQ 空~文字列
］ならば、此れの`~node文書$の`~URL$docを返さ~MUST。
</dd>

	<dt>`formEnctype@m</dt>
	<dd>
`既知の値のみに制限され$る下で，
`formenctype$a 内容~属性を`反映-$し~MUST。
</dd>

	<dt>`formMethod@m</dt>
	<dd>
`既知の値のみに制限され$る下で，
`formmethod$a 内容~属性を`反映-$し~MUST。
</dd>

	<dt>`formNoValidate@m</dt>
	<dd>
`formnovalidate$a 内容~属性
を`反映-$し~MUST。
</dd>

	<dt>`formTarget@m</dt>
	<dd>
`formtarget$a 内容~属性を`反映-$し~MUST。
</dd>

</dl>

◎
The action IDL attribute must reflect the content attribute of the same name, except that on getting, when the content attribute is missing or its value is the empty string, the element's node document's URL must be returned instead. The target IDL attribute must reflect the content attribute of the same name. The method and enctype IDL attributes must reflect the respective content attributes of the same name, limited to only known values. The encoding IDL attribute must reflect the enctype content attribute, limited to only known values. The noValidate IDL attribute must reflect the novalidate content attribute. The formAction IDL attribute must reflect the formaction content attribute, except that on getting, when the content attribute is missing or its value is the empty string, the element's node document's URL must be returned instead. The formEnctype IDL attribute must reflect the formenctype content attribute, limited to only known values. The formMethod IDL attribute must reflect the formmethod content attribute, limited to only known values. The formNoValidate IDL attribute must reflect the formnovalidate content attribute. The formTarget IDL attribute must reflect the formtarget content attribute.
</div>



					<section id="autofocusing-a-form-control:-the-autofocus-attribute">
<h5 title="Autofocusing a form control: the autofocus attribute">4.10.18.6.1. ~form~controlの自動focus法： `autofocus^a 属性</h5>

<p>
`autofocus@a
内容~属性により、作者は，［
頁が読込まれ次第 ／
当の~formが見出される `dialog$e が示され次第
］，~controlを~focusさせるよう指示できるようになる
— 利用者は、当の~controlに 手動で~focusせずに，打込みを開始できるようになる。
◎
The autofocus content attribute allows the author to indicate that a control is to be focused as soon as the page is loaded or as soon as the dialog within which it finds itself is shown, allowing the user to just start typing without having to manually focus the main control.
</p>

<p>
`autofocus$a
属性は`真偽~属性$である。
◎
The autofocus attribute is a boolean attribute.
</p>

<p>
要素 %要素 が属する
`自動focus根@†
は、
%要素 の`広義~先祖$に `dialog$e 要素が［
在るならば それらのうち %要素 に最も近いもの ／
無いならば %要素 の last `広義~先祖$である要素††
］とする。
◎
An element's nearest ancestor autofocus scoping root element is the element itself if the element is a dialog element, or else is the element's nearest ancestor dialog element, if any, or else is the element's last inclusive ancestor element.
</p>

<p class="trans-note">【†
原文では，
“nearest ancestor autofocus scoping root element”
といういかにも長い呼称なので、この訳では略記する。
】【††
“last” が意図不明。
“`木~順序$で最後”
を意味するならば、定義により，最後の`広義~先祖$は %要素 自身になる。
】</p>

<p>
同じ`自動focus根$に属する複数の要素が， `autofocus$a 属性を有していては~MUST_NOT。
◎
There must not be two elements with the same nearest ancestor autofocus scoping root element that both have the autofocus attribute specified.
</p>

<p>
`autofocus$a 属性を有する要素 %要素 が，文書の`中へ挿入された$ときは、`利用者~対話~task源$から，次を走らす`~taskを~queueする$：
◎
When an element with the autofocus attribute specified is inserted into a document, queue a task on the user interaction task source to run the following steps:
</p>

<ol>
	<li>
~IF［
利用者は~focusを変更しないよう望むことを指示した（例えば，~form~control内で打込みを開始することにより）
］
⇒
~UAの任意選択で
⇒
~RET
◎
If the user has indicated (for example, by starting to type in a form control) that they do not wish focus to be changed, then optionally return.
</li>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let target be the element's node document.
</li>
	<li>
%B ~LET %文書 が`属する閲覧文脈$
◎
↓</li>
	<li>
~IF［
%B ~EQ ε
］
⇒
~RET
◎
If target has no browsing context, then return.
</li>
	<li>
%T ~LET %B の`~top-level閲覧文脈$
◎
↓</li>
	<li>
~IF［
%T ~EQ ε （例： %B は`入子の閲覧文脈$であって， %B の`親~閲覧文脈$ ~EQ ε のとき）
］
⇒
~RET
◎
If target's browsing context has no top-level browsing context (e.g., it is a nested browsing context with no parent browsing context), then return.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET：
</p>
		<ul>
			<li>
`閲覧文脈~sandbox化( 自動~特色機能 )~flag$ ~IN %文書 の`作動中の~sandbox法~flag集合$
◎
If target's active sandboxing flag set has the sandboxed automatic features browsing context flag, then return.
</li>
			<li>
( %文書 の`生成元$, %T 内の現在~focusされている要素の`~node文書$の`生成元$ )
は`同一生成元$でない
◎
If target's origin is not the same as the origin of the node document of the currently focused element in target's top-level browsing context, then return.
</li>
			<li>
( %文書 の`生成元$, %T にて`作動中の文書$の`生成元$ )
は`同一生成元$でない
◎
If target's origin is not the same as the origin of the active document of target's top-level browsing context, then return.
</li>
			<li>
<p>
ある`文書$ %D があって，次がいずれも満たされる：
</p>
				<ul>
					<li>
~UAは、ある要素が %D の`中へ挿入された$ことに呼応して，この手続きの最後の段にすでに到達した【？】
</li>
					<li>
%D の`~top-level閲覧文脈$にて`作動中の文書$ ~EQ %T にて`作動中の文書$
</li>
				</ul>
◎
If the user agent has already reached the last step of this list of steps in response to an element being inserted into a Document whose top-level browsing context's active document is the same as target's top-level browsing context's active document, then return.
</li>
		</ul>
	</li>
	<li>
`~objを~focusする$( %要素 )
— 加えて，~UAは、次をしても~MAY
⇒
文書の~scrolling位置も変更するか，あるいは
要素を利用者に注目させるような何らかの他の動作を遂行する
◎
Run the focusing steps for the element. User agents may also change the scrolling position of the document, or perform some other action that brings the element to the user's attention.
</li>
</ol>

<p class="note">注記：
これは、文書を読込んでいる間の自動的~focusを取扱う。
`dialog$e 要素の［
`show()$m ／ `showModal()$m
］~methodも， `autofocus$a 属性を処理する。
◎
This handles the automatic focusing during document load. The show() and showModal() methods of dialog elements also processes the autofocus attribute.
</p>

<p class="note">注記：
~controlを~focusするとき、~UAは，~focusを失った~browser~windowを~focusする必要はない。
◎
Focusing the control does not imply that the user agent has to focus the browser window if it has lost focus.
</p>

<dl class="idl-def">
	<dt>`autofocus@m</dt>
	<dd>
同じ名前の内容~属性を`反映-$し~MUST。
◎
The autofocus IDL attribute must reflect the content attribute of the same name.
</dd>
</dl>



<div class="example">
<p>
次の~code片の~text~controlは、文書が読込まれたときに~focusされることになる。
◎
In the following snippet, the text control would be focused when the document was loaded.
</p>

`autofocus-1^xCode

</div>


					</section>
				</section>
				<section id="autofill">
<h4 title="Autofill">4.10.18.7. 自動充填（ autofill ）</h4>

<p class="trans-note">【
この節の内容は、
<a href="~HTMLautofill#autofill">別ページにて</a>
。
】</p>


				</section>
			</section>
			<section id="textFieldSelection">
<h3 title="APIs for the text control selections">4.10.19. ~text~control選択~用の~API</h3>


<p>
［
`input$e ／ `textarea$e
］要素は、それらの選択を取扱うためとして，いくつかの~memberを定義している。
それらは、ここに定義される~algoを共有する。
◎
The input and textarea elements define several attributes and methods for handling their selection. Their shared algorithms are defined here.
</p>

<p>
この節における
`~offset@
とは、~text内の，論理~順序による［
始端, 終端, 隣接する ある 2 文字の間
］のいずれかを指す，負でない整数であり、`~offset$ 0 は始端を指し，`~offset$［
~text内の文字~数
］は終端を指すとする。
</p>

<p class="trans-note">【
この`~offset$の定義は、簡潔に記すために，この訳に導入している（原文の “offset” は、文字列~内の “文字の~offset” を表していて，記述がまわりくどいので）。
】【
文字の個数が［
符号単位／符号位置
］のどちらに基づくのか述べられていないが、少なくとも一部の~UAの実装は
— `~form~control~maxlength属性$などと同様に —
符号単位（`~JS文字列~長さ$）に基づいている。
】</p>


<dl class="domintro">

	<dt>%element . `select()$m</dt>
	<dd>
~text~control内のすべてを選択する。
◎
Selects everything in the text control.
</dd>

	<dt>%element . `selectionStart$m [ = %value ]</dt>
	<dd>
選択の始端を指す`~offset$を返す。
◎
Returns the offset to the start of the selection.
</dd>
	<dd>
設定して，選択の始端を変更できる。
◎
Can be set, to change the start of the selection.
</dd>

	<dt>%element . `selectionEnd$m [ = %value ]</dt>
	<dd>
選択の終端を指す`~offset$を返す。
◎
Returns the offset to the end of the selection.
</dd>
	<dd>
設定して，選択の終端を変更できる。
◎
Can be set, to change the end of the selection.
</dd>

	<dt>%element . `selectionDirection$m [ = %value ]</dt>
	<dd>
現在の`選択~方向$を返す。
◎
Returns the current direction of the selection.
</dd>
	<dd>
設定して，現在の`選択~方向$を変更できる。
◎
Can be set, to change the direction of the selection.
</dd>
	<dd>
可能な値は［
`forward^l, `backward^l, `none^l
］のいずれかである。
◎
The possible values are "forward", "backward", and "none".
</dd>

	<dt>%element . `setSelectionRange(start, end [, direction] )$m</dt>
	<dd>
選択の［
始端, 終端, 方向
］を［
%start, %end, %direction
］に変更する。
%direction が省略された場合、方向は~platformの既定のそれ（ `forward^l または `none^l ）に再設定される。
◎
Changes the selection to cover the given substring in the given direction. If the direction is omitted, it will be reset to be the platform default (none or forward).
</dd>

	<dt>%element . `setRangeText(replacement [, start, end [, selectionMode ] ] )$m</dt>
	<dd>
~textのある範囲を，新たな~textに置換する。
%start, %end 引数が供されない場合の範囲は、選択~全体と見做される。
◎
Replaces a range of text with the new text. If the start and end arguments are not provided, the range is assumed to be the selection.
</dd>
	<dd>
<p>
~~最後の引数は、~textが置換された後に，選択が どう設定されることになるかを決定する。
可能な値は：
◎
The final argument determines how the selection will be set after the text has been replaced. The possible values are:
</p>

		<dl>
			<dt>`select$l</dt>
			<dd>
新たに挿入された~textを選択する。
◎
Selects the newly inserted text.
</dd>

			<dt>`start$l</dt>
			<dd>
選択の始端, 終端ともに 挿入された~textの直前に移動する。
◎
Moves the selection to just before the inserted text.
</dd>

			<dt>`end$l</dt>
			<dd>
選択の始端, 終端ともに 挿入された~textの直後に移動する。
◎
Moves the selection to just after the selected text.
</dd>

			<dt>`preserve$l</dt>
			<dd>
選択をなるべく保全しようと試みる。
これが既定。
◎
Attempts to preserve the selection. This is the default.
</dd>
		</dl>
	</dd>
</dl>

<p>
［
これらの~APIが`適用される$すべての `input$e 要素, および `textarea$e 要素
］は、どの時点でも（要素が`具現化されて$いなくとも），［
`選択@,
`~text手入力~cursor位置@
］のどちらかは有するとする。
初期~状態では、~controlの始端を指す~text手入力~cursor位置を有するものとされ~MUST。
◎
All input elements to which these APIs apply, and all textarea elements, have either a selection or a text entry cursor position at all times (even for elements that are not being rendered). The initial state must consist of a text entry cursor at the beginning of the control.
</p>

<p class="trans-note">【
~text手入力~cursor位置は，実質的には “始端と終端が一致する空の選択” と同じに見受けられる（ “空の選択” と “選択なし” を区別するための用語かもしれないが、そのような区別が有意になる箇所は見当たらない）。
】</p>

<p>
これらの~APIは、［
`input$e 要素に対しては その`値$ ／
`textarea$e 要素に対しては その`~API値$
］に対し演算し~MUST。
この，演算される値~文字列は、以下に与える~algoにおいては，当の要素に
`関連する値@
と総称される。
◎
For input elements, these APIs must operate on the element's value. For textarea elements, these APIs must operate on the element's API value. In the below algorithms, we call the value string being operated on the relevant value.
</p>

<div class="example">
<p>
`textarea$e 要素~用に`生の値$tAに代えて`~API値$を利用することは、文字 `000D^U `CR^smb が正規化されて消えることを意味する。
例えば：
◎
The use of API value instead of raw value for textarea elements means that U+000D (CR) characters are normalized away. For example,
</p>

<pre class="html-code">
&lt;textarea id="demo"&gt;&lt;/textarea&gt;
&lt;script&gt;
 %demo.value = "A\r\nB";
 %demo.setRangeText("replaced", 0, 2);
 assert(%demo.value === "replacedB");
&lt;/script&gt;
</pre>

<p>
`生の値$tA `A\r\nB^l に演算した場合、文字~並び `A\r^l が置換される結果 `replaced\nB^l になるが、`~API値$ `A\nB^l を利用するので，文字~並び `A\n^l が置換される結果 `replacedB^l になる。
◎
If we had operated on the raw value of "A\r\nB", then we would have replaced the characters "A\r", ending up with a result of "replaced\nB". But since we used the API value of "A\nB", we replaced the characters "A\n", giving "replacedB".
</p>

</div>

<p>
これらの~APIが適用される要素に対し，`関連する値$が変化したときは、次を走らすとする：
◎
Whenever the relevant value changes for an element to which these APIs apply, run these steps:
</p>

<ol>
	<li>
<p>
~IF［
要素は`選択$を有する
］：
◎
If the element has a selection:
</p>
		<ol>
			<li>
~IF［
選択の始端は `関連する値$の終端を過ぎている<!-- 始端？ -->
］
⇒
選択の始端 ~SET `関連する値$の終端
◎
If the start of the selection is now past the end of the relevant value, set it to the end of the relevant value.
</li>
			<li>
~IF［
選択の終端は `関連する値$の終端を過ぎている
］
⇒
選択の終端 ~SET `関連する値$の終端
◎
If the end of the selection is now past the end of the relevant value, set it to the end of the relevant value.
</li>
			<li>
~IF［
~UAは空の選択を~supportしない
］~AND［
選択の始端, 終端とも`関連する値$の終端を指している
］
⇒
選択を除去した上で，要素の`~text手入力~cursor位置$ ~SET `関連する値$の終端
◎
If the user agent does not support empty selection, and both the start and end of the selection are now pointing to the end of the relevant value, then instead set the element's text entry cursor position to the end of the relevant value, removing any selection.
</li>
		</ol>
	</li>
	<li>
~ELSE（ 要素は`~text手入力~cursor位置$を有する）
⇒
~IF［
`~text手入力~cursor位置$は `関連する値$の終端を過ぎている
］
⇒
`~text手入力~cursor位置$ ~SET `関連する値$の終端
◎
Otherwise, the element must have a text entry cursor position position. If it is now past the end of the relevant value, set it to the end of the relevant value.
</li>
</ol>

<p class="note">注記：
上で切詰める手続きのみならず，この仕様の他所にも、`関連する値$が変化するときに，`~text手入力~cursor位置$を改変する事例がある。
例えば `textarea$e 用の `value$m 設定子など。
◎
In some cases where the relevant value changes, other parts of the specification will also modify the text entry cursor position, beyond just the clamping steps above. For example, see the value setter for textarea.
</p>

<p>
文字 `200D^U ZERO WIDTH JOINER
などの可視でない文字であっても，文字として数えられる。
したがって，具体例として、選択は 可視でない文字のみを含むこともあり，~text挿入~cursorは そのような文字の前後いずれかの側に配置され得る。
◎
Characters with no visible rendering, such as U+200D ZERO WIDTH JOINER, still count as characters. Thus, for instance, the selection can include just an invisible character, and the text insertion cursor can be placed to one side or another of such a character.
</p>

<p>
［
`input$e ／ `textarea$e
］要素において~text`選択$を変更するような~UI特色機能は、可能な所では，`選択~範囲を設定する$~algoを利用して実装され~MUST
— 例えば すべてに同じ~eventが発火されるように。
◎
Where possible, user interface features for changing the text selection in input and textarea elements must be implemented using the set the selection range algorithm so that, e.g., all the same events fire.
</p>

<p>
各［
`input$e ／ `textarea$e
］要素の`選択$は、次のいずれかを値にとる
`選択~方向@
を持つ
⇒＃
`forward^l,
`backward^l,
`none^l
◎
The selections of input and textarea elements have a selection direction, which is either "forward", "backward", or "none".＼
</p>

<p>
この方向は、利用者が選択を操作するときに設定される。
選択~方向の正確な意味は~platformに依存する。
◎
This direction is set when the user manipulates the selection. The exact meaning of the selection direction depends on the platform.＼
</p>

<p class="algo-head">
要素の
`選択~方向を設定する@
ときは、所与の
( %方向 )
に対し，次を走らす
⇒
要素の`選択~方向$ ~SET ［
次が満たされるならば `forward^l ／
~ELSE_ %方向
］
⇒
［
%方向 ~EQ `none^l
］~AND［
~platformは %方向 を~supportしない
］
◎
To set the selection direction of an element to a given direction, update the element's selection direction to the given direction, unless the direction is "none" and the platform does not support that direction; in that case, update the element's selection direction to "forward".
</p>


<div class="note">
<p>注記：
Windows 上では、この選択~方向は、選択に相対的な~caret位置を指示する：
~caretは、方向に応じて［
`forward^l ならば選択の終端 ／
`backward^l ならば選択の始端
］にある。
Windows に `none^l 方向はない。
◎
On Windows, the direction indicates the position of the caret relative to the selection: a "forward" selection has the caret at the end of the selection and a "backward" selection has the caret at the start of the selection. Windows has no "none" direction.
</p>

<p>
Mac では、方向は，利用者が
Shift ＋ 矢印~keyを用いて，選択~範囲を調整するときに 選択のどちらの端が影響されるかを指示する：
改変される端は、方向に応じて［
`forward^l ならば選択の終端 ／
`backward^l ならば選択の始端
］になる。
Mac では、 `none^l 方向が既定であり，特定0の方向はまだ選択されてないことを指示する。
方向は、利用者が選択を最初に調整するときに，どっちの矢印~keyが利用されたかに基づいて暗黙的に設定される。
◎
On Mac, the direction indicates which end of the selection is affected when the user adjusts the size of the selection using the arrow keys with the Shift modifier: the "forward" direction means the end of the selection is modified, and the "backward" direction means the start of the selection is modified. The "none" direction is the default on Mac, it indicates that no particular direction has yet been selected. The user sets the direction implicitly when first adjusting the selection, based on which directional arrow key was used.
</p>
</div>

<dl class="idl-def">
	<dt>`select()@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The select() method, when invoked, must run the following steps:
</p>

		<ol>
			<li>
<p>
~IF［
此れは `input$e 要素である
］~AND［［
この~methodは此れに`適用されない$
］~OR［
此れに対応する~controlには選択-可能な~textはない
］］
⇒
~RET
◎
If this element is an input element, and either select() does not apply to this element or the corresponding control has no selectable text, return.
</p>

<p class="example">
具体例として、
<a href="~HEinput#color-state-(type=color)">`&lt;input type=color&gt;^e</a>
を，［
16 進~色~codeを受容する~text~control
］ではなく［
色~pickerを擁する~color-well
］として具現化する~UAにおいては、選択-可能な~textは無いので，この~methodの~callは無視される。
◎
For instance, in a user agent where &lt;input type=color&gt; is rendered as a color well with a picker, as opposed to a text control accepting a hexadecimal color code, there would be no selectable text, and thus calls to the method are ignored.
</p>
			</li>
			<li>
`選択~範囲を設定する$( 0, `無限大^i )
◎
Set the selection range with 0 and infinity.
</li>
		</ol>
	</dd>

	<dt>`selectionStart@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The selectionStart attribute's getter must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れは `input$e 要素である
］~AND［
この~methodは此れに`適用されない$
］
⇒
~RET ~NULL
◎
If this element is an input element, and selectionStart does not apply to this element, return null.
</li>
			<li>
~IF［
此れは`選択$を有さない
］
⇒
~RET 此れに`関連する値$の中で`~text手入力~cursor位置$を指す`~offset$
◎
If there is no selection, return the offset (in logical order) within the relevant value to the character that immediately follows the text entry cursor.
</li>
			<li>
~RET 此れに`関連する値$の中で`選択$の始端を指す`~offset$
◎
Return the offset (in logical order) within the relevant value to the character that immediately follows the start of the selection.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次の手続きを走らせ~MUST：
◎
The selectionStart attribute's setter must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れは `input$e 要素である
］~AND［
この~methodは此れに`適用されない$
］
⇒
~THROW `InvalidStateError$E
◎
If this element is an input element, and selectionStart does not apply to this element, throw an "InvalidStateError" DOMException.
</li>
			<li>
%終端 ~LET { 此れの `selectionEnd$m 属性の値, 所与の値 } の最大
◎
Let end be the value of this element's selectionEnd attribute.
◎
If end is less than the given value, set end to the given value.
</li>
			<li>
`選択~範囲を設定する$( 所与の値, %終端, 此れの `selectionDirection$m 属性の値 )
◎
Set the selection range with the given value, end, and the value of this element's selectionDirection attribute.
</li>
		</ol>
	</dd>

	<dt>`selectionEnd@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The selectionEnd attribute's getter must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れは `input$e 要素である
］~AND［
この~methodは此れに`適用されない$
］
⇒
~RET ~NULL
◎
If this element is an input element, and selectionEnd does not apply to this element, return null.
</li>
			<li>
~IF［
此れは`選択$を有さない
］
⇒
~RET 此れに`関連する値$の中で`~text手入力~cursor位置$を指す`~offset$
◎
If there is no selection, return the offset (in logical order) within the relevant value to the character that immediately follows the text entry cursor.
</li>
			<li>
~RET 此れに`関連する値$の中で`選択$の終端を指す`~offset$
◎
Return the offset (in logical order) within the relevant value to the character that immediately follows the end of the selection.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次の手続きを走らせ~MUST：
◎
The selectionEnd attribute's setter must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れは `input$e 要素である
］~AND［
この~methodは此れに`適用されない$
］
⇒
~THROW `InvalidStateError$E
◎
If this element is an input element, and selectionEnd does not apply to this element, throw an "InvalidStateError" DOMException.
</li>
			<li>
`選択~範囲を設定する$( 此れの `selectionStart$m 属性の値, 所与の値, 此れの `selectionDirection$m 属性の値 )
◎
Set the selection range with the value of this element's selectionStart attribute, the given value, and the value of this element's selectionDirection attribute.
</li>
		</ol>
	</dd>

	<dt>`selectionDirection@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The selectionDirection attribute's getter must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れは `input$e 要素である
］~AND［
この~methodは此れに`適用されない$
］
⇒
~RET ~NULL
◎
If this element is an input element, and selectionDirection does not apply to this element, return null.
</li>
			<li>
~RET 此れの`選択~方向$
◎
Return this element's selection direction.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次の手続きを走らせ~MUST：
◎
The selectionDirection attribute's setter must run the following steps:
</p>
		<ol>
			<li>
~IF［
此れは `input$e 要素である
］~AND［
この~methodは此れに`適用されない$
］
⇒
~THROW `InvalidStateError$E
◎
If this element is an input element, and selectionDirection does not apply to this element, throw an "InvalidStateError" DOMException.
</li>
			<li>
`選択~範囲を設定する$( 此れの `selectionStart$m 属性の値, 此れの `selectionEnd$m 属性の値, 所与の値 )
◎
Set the selection range with the value of this element's selectionStart attribute, the value of this element's selectionEnd attribute, and the given value.
</li>
		</ol>
	</dd>

	<dt>`setSelectionRange(start, end, direction)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The setSelectionRange(start, end, direction) method, when invoked, must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れは `input$e 要素である
］~AND［
この~methodは此れに`適用されない$
］
⇒
~THROW `InvalidStateError$E
◎
If this element is an input element, and setSelectionRange() does not apply to this element, throw an "InvalidStateError" DOMException.
</li>
			<li>
`選択~範囲を設定する$( %start, %end, %direction )
◎
Set the selection range with start, end, and direction.
</li>
		</ol>
	</dd>
</dl>


<p class="algo-head">
~text~control【を表現する要素】 %要素 の
`選択~範囲を設定する@
ときは、所与の
⇒＃
%始端 （非負~整数, ~NULL のいずれか）,
%終端 （非負~整数, ~NULL, `無限大^i のいずれか）,
%方向 （文字列, 省略時は ε）
◎終
に対し，次の手続き走らす
— 以下においては、値 `無限大^i は他のどの値よりも大きいとする：
◎
To set the selection range with an integer or null start, an integer or null or the special value infinity end, and optionally a string direction, run the following steps:
</p>

<ol>
	<li>
~IF［
%始端 ~EQ ~NULL
］
⇒
%始端 ~SET 0
◎
If start is null, let start be zero.
</li>
	<li>
~IF［
%終端 ~EQ ~NULL
］
⇒
%終端 ~LET 0
◎
If end is null, let end be zero.
</li>
	<li>
%L ~LET %要素 に`関連する値$の長さ
◎
↓</li>
	<li>
%終端 ~LET { %終端, %L } の最小
◎
↓</li>
	<li>
%始端 ~LET { %始端, %L, %終端 } の最小
◎
↓</li>
	<li>
%要素 に`関連する値$の中で，`選択$の範囲を［
%始端 `~offset$ 〜 %終端 `~offset$
］に設定する
— 範囲が空になる場合、空~選択の概念がない~UAにおいては，~cursorを %終端 `~offset$に設定する
◎
Set the selection of the text control to the sequence of characters within the relevant value starting with the character at the startth position (in logical order) and ending with the character at the (end-1)th position. Arguments greater than the length of the relevant value of the text control (including the special value infinity) must be treated as pointing at the end of the text control. If end is less than or equal to start then the start of the selection and the end of the selection must both be placed immediately before the character with offset end. In UAs where there is no concept of an empty selection, this must set the cursor to be just before the character with offset end.
</li>
	<li>
~IF［
%方向 ~NIN { ε, `backward^l, `forward^l }
］
⇒
%方向 ~SET `none^l
◎
If direction is not a case-sensitive match for either the string "backward" or "forward", or if the direction argument was omitted, set direction to "none".
</li>
	<li>
%要素 の`選択~方向を設定する$( %方向 )
◎
Set the selection direction of the text control to direction.
</li>
	<li>
~IF［
前~段までにより，~text~controlの`選択$は改変された（その範囲, `選択~方向$いずれにせよ）
］
⇒
~task源に`利用者~対話~task源$を用いる下で，次を走らす`~taskを~queueする$
⇒
%要素 に向けて，名前 `select$et の`~eventを発火する$
— 次のように初期化して
⇒
`bubbles$m 属性 ~SET ~T
◎
If the previous steps caused the selection of the text control to be modified (in either extent or direction), then queue a task, using the user interaction task source, to fire an event named select at the element, with the bubbles attribute initialized to true.
</li>
</ol>


<p class="idl-def">
`setRangeText(replacement, start, end, selectionMode)@m
の被呼出時には、次の手続きを走らせ~MUST：
◎
The setRangeText(replacement, start, end, selectMode) method, when invoked, must run the following steps:
</p>

<ol>
	<li>
~IF［
此れは `input$e 要素である
］~AND［
この~methodは此れに`適用されない$
］
⇒
~THROW `InvalidStateError$E
◎
If this element is an input element, and setRangeText() does not apply to this element, throw an "InvalidStateError" DOMException.
</li>
	<li>
此れの`~dirty値~flag$ ~SET ~T
◎
Set this element's dirty value flag to true.
</li>
	<li>
( %選択~始端, %選択~終端 ) ~LET
此れの
( `selectionStart$m, `selectionEnd$m )
属性の現在の値
◎
↓↓</li>
	<li>
~IF［
%start 以降の引数は与えられていない
］
⇒＃
( %start, %end ) ~SET ( %選択~始端, %選択~終端 )；
%selectionMode ~SET `preserve$l
◎
If the method has only one argument, then let start and end have the values of the selectionStart attribute and the selectionEnd attribute respectively.
◎
Otherwise, let start, end have the values of the second and third arguments respectively.
◎
↓↓
</li>
	<li>
~IF［
%start ~GT %end
］
⇒
~THROW `IndexSizeError$E
◎
If start is greater than end, then throw an "IndexSizeError" DOMException.
</li>
	<li>
%L ~LET 此れに`関連する値$の長さ
◎
↓</li>
	<li>
%始端 ~SET { %start, %L } の最小
◎
If start is greater than the length of the relevant value of the text control, then set it to the length of the relevant value of the text control.
</li>
	<li>
%終端 ~SET { %end, %L } の最小
◎
If end is greater than the length of the relevant value of the text control, then set it to the length of the relevant value of the text control.
◎
↑↑Let selection start be the current value of the selectionStart attribute.
◎
↑↑Let selection end be the current value of the selectionEnd attribute.
</li>
	<li>
~IF［
%始端 ~LT %終端
］
⇒
此れに`関連する値$から範囲［
%始端 `~offset$ 〜 %終端 `~offset$
］にある文字を削除する
◎
If start is less than end, delete the sequence of characters within the element's relevant value starting with the character at the startth position (in logical order) and ending with the character at the (end-1)th position.
</li>
	<li>
此れに`関連する値$の %始端 `~offset$に %replacement の値を挿入する
◎
Insert the value of the first argument into the text of the relevant value of the text control, immediately before the startth character.
</li>
	<li>
%新~終端 ~LET %始端 + ( %replacement の長さ )
◎
Let new length be the length of the value of the first argument.
◎
Let new end be the sum of start and new length.
</li>
	<li>
<p>
%selectionMode に応じて：
◎
Run the appropriate set of substeps from the following list:
</p>

		<dl class="switch">
			<dt>`select@l
◎
If the fourth argument's value is "select"
</dt>
			<dd>
( %選択~始端, %選択~終端 ) ~SET ( %始端, %新~終端 )
◎
Let selection start be start.
◎
Let selection end be new end.
</dd>

			<dt>`start@l
◎
If the fourth argument's value is "start"
</dt>
			<dd>
( %選択~始端, %選択~終端 ) ~SET ( %始端, %始端 )
◎
Let selection start and selection end be start.
</dd>

			<dt>`end@l
◎
If the fourth argument's value is "end"
</dt>
			<dd>
( %選択~始端, %選択~終端 ) ~SET ( %新~終端, %新~終端 )
◎
Let selection start and selection end be new end.
</dd>

			<dt>`preserve@l （既定）
◎
If the fourth argument's value is "preserve" (the default)
◎
↑↑If the method has only one argument
</dt>

			<dd>
				<ol>
					<li>
%差分 ~LET ( %replacement の長さ ) − ( %終端 − %始端 )
◎
Let old length be end minus start.
◎
Let delta be new length minus old length.
</li>
					<li>
~IF［
%選択~始端 ~GT %終端
］
⇒
%選択~始端 ~INCBY %差分
（ %差分 が負の場合，すなわち 新たな~textが置換された~textより短い場合、 %選択~始端 の値は<em>減る</em>ことになる）
◎
If selection start is greater than end, then increment it by delta. (If delta is negative, i.e. the new text is shorter than the old text, then this will decrease the value of selection start.)
</li>
					<li>
~ELIF［
%選択~始端 ~GT %始端
］
⇒
%選択~始端 ~SET %始端
（ %選択~始端 が置換された~textの途中にあった場合，選択の始端は新たな~textの始端に留められる）
◎
Otherwise: if selection start is greater than start, then set it to start. (This snaps the start of the selection to the start of the new text if it was in the middle of the text that it replaced.)
</li>
					<li>
~IF［
%選択~終端 ~GT %終端
］
⇒
%選択~終端 ~INCBY %差分
◎
If selection end is greater than end, then increment it by delta in the same way.
</li>
					<li>
~ELIF［
%選択~終端 ~GT %始端
］
⇒
%選択~終端 ~SET %新~終端
（ %選択~終端 が置換された~textの途中にあった場合，選択の始端は新たな~textの終端に留められる）
◎
Otherwise: if selection end is greater than start, then set it to new end. (This snaps the end of the selection to the end of the new text if it was in the middle of the text that it replaced.)
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
`選択~範囲を設定する$( %選択~始端, %選択~終端 )
◎
Set the selection range with selection start and selection end.
</li>
</ol>

<p>
`setRangeText()$m
~methodは、次の列挙を利用する：
◎
The setRangeText() method uses the following enumeration:
</p>

<pre class="idl">
enum `SelectionMode@I {
  `select$l,
  `start$l,
  `end$l,
  `preserve$l // <span class="comment">既定</span>
};
</pre>


<hr>

<div class="example">

<p>
現在~選択されている~textを得るには、次の~JSで足りる：
◎
To obtain the currently selected text, the following JavaScript suffices:
</p>

<pre>
var %selectionText = %control.value.substring(%control.selectionStart, %control.selectionEnd);
</pre>

<p>
（ %control は［
`input$e ／ `textarea$e
］要素とする。）
◎
...where control is the input or textarea element.
</p>

</div>

<div class="example">

<p>
3 つの属性を保全して，~text選択は保守しながら、~text~controlの始端に~textを追加する例：
◎
To add some text at the start of a text control, while maintaining the text selection, the three attributes must be preserved:
</p>

<pre>
var %oldStart = %control.selectionStart;
var %oldEnd = %control.selectionEnd;
var %oldDirection = %control.selectionDirection;
var %prefix = "http://";
%control.value = %prefix + %control.value;
%control.setSelectionRange(%oldStart + %prefix.length, %oldEnd + %prefix.length, %oldDirection);
</pre>

<p>
（ %control は［
`input$e ／ `textarea$e
］要素とする。）
◎
...where control is the input or textarea element.
</p>

</div>



			</section>
			<section id="constraints">
<h3 title="Constraints">4.10.20. 拘束</h3>

				<section id="definitions">
<h4 title="Definitions">4.10.20.1. 各種 定義</h4>

<p>
`提出-可能$な要素は、
`拘束検証の対象外@
にある間を除いて，
`拘束検証の候補@
になる（例えば、 `object$e 要素は`拘束検証の対象外$になる。）
◎
A submittable element is a candidate for constraint validation except when a condition has barred the element from constraint validation. (For example, an element is barred from constraint validation if it is an object element.)
</p>

<p>
要素には、
`~custom妥当性~error~message@
も定義され得る
— 初期~時には，空~文字列とする。
その値が空~文字列でないときは、要素は，`~custom~errorの難あり$になる。
`setCustomValidity()$m ~methodを用いて，それを設定できる。
~UAは、当の~controlにおける問題を利用者に~alertするときには、`~custom妥当性~error~message$を利用するべきである。
◎
An element can have a custom validity error message defined. Initially, an element must have its custom validity error message set to the empty string. When its value is not the empty string, the element is suffering from a custom error. It can be set using the setCustomValidity() method. The user agent should use the custom validity error message when alerting the user to the problem with the control.
</p>

<p>
要素は、様々な仕方で拘束できる／され得る。
以下に，拘束検証の目的において~controlを妥当でなくするような，~form~controlがとり得る
`妥当性~状態@
を挙げる。
（下の定義は規範的でない
— 各~状態が適用されるかどうかは、この仕様の他所にて より精確に定義される。）
◎
An element can be constrained in various ways. The following is the list of validity states that a form control can be in, making the control invalid for the purposes of constraint validation. (The definitions below are non-normative; other parts of this specification define more precisely when each state applies or does not.)
</p>


<dl>
	<dt>
`欠落の難あり@
◎
Suffering from being missing
</dt>
	<dd>
~controlは、 `required^a 属性（
`input$e の `~requiredI$a ／ `textarea$e の `~requiredT$a
）を有するが、その`値$がないとき。
ただし、［
`select$e 要素 ／ `~radio~button群$に属する~control
］においては、それらの各 節に指定されるように，より複雑な規則になる。
◎
When a control has no value but has a required attribute (input required, textarea required); or, more complicated rules for select elements and controls in radio button groups, as specified in their sections.
</dd>

	<dt>
`型~不一致の難あり@
◎
Suffering from a type mismatch
</dt>
	<dd> 
任意の利用者~入力を許容する~controlの`値$が正しい構文でないとき（
`Email$st, `Url$st
）。
◎
When a control that allows arbitrary user input has a value that is not in the correct syntax (E-mail, URL).
</dd>

	<dt>
`~pattern不一致の難あり@
◎
Suffering from a pattern mismatch
</dt>
	<dd>
~controlの`値$が `pattern$a 属性を満たさないとき。
◎
When a control has a value that doesn't satisfy the pattern attribute.
</dd>

	<dt>
`長過ぎる難あり@
◎
Suffering from being too long
</dt>
	<dd> 
~controlの`値$が`~form~control~maxlength属性$（
`input$e の `~maxlengthI$a ／ `textarea$e の `~maxlengthT$a
）に比して長過ぎるとき。
◎
When a control has a value that is too long for the form control maxlength attribute (input maxlength, textarea maxlength).
</dd>

	<dt>
`短か過ぎる難あり@
◎
Suffering from being too short
</dt>
	<dd>
~controlの`値$が`~form~control~minlength属性$（
`input$e の `~minlengthI$a ／ `textarea$e の `~minlengthT$a
）に比して短か過ぎるとき。
◎
When a control has a value that is too short for the form control minlength attribute (input minlength, textarea minlength).
</dd>

	<dt>
`~underflowの難あり@
◎
Suffering from an underflow
</dt>
	<dd>
~controlの`値$は 空~文字列でない, かつ
`min$a 属性に比して低~過ぎるとき。
◎
When a control has a value that is not the empty string and is too low for the min attribute.
</dd>

	<dt>
`~overflowの難あり@
◎
Suffering from an overflow
</dt>
	<dd>
~controlの`値$は 空~文字列でない, かつ
`max$a 属性に比して高~過ぎるとき。
◎
When a control has a value that is not the empty string and is too high for the max attribute.
</dd>

	<dt>
`~step不一致の難あり@
◎
Suffering from a step mismatch
</dt>
	<dd>
~controlの`値$が `step$a 属性が与える規則に合わないとき。
◎
When a control has a value that doesn't fit the rules given by the step attribute.
</dd>

	<dt>
`不良~入力の難あり@
◎
Suffering from bad input
</dt>
	<dd>
~controlの入力は不完全であり、~UAは，［
その現在の状態において，利用者が~formを提出できる
］と~~判断していないとき。
◎
When a control has incomplete input and the user agent does not think the user ought to be able to submit the form in its current state.
</dd>
	<dd class="trans-note">【
すなわち、上に挙げられた他のどの “難あり” にも該当しないが， “難あり” にされるべきとき。
】</dd>

	<dt>
`~custom~errorの難あり@
◎
Suffering from a custom error
</dt>
	<dd>
~controlの`~custom妥当性~error~message$が空~文字列でないとき。
（これは、要素の `setCustomValidity()$m ~methodにより設定される。）
◎
When a control's custom validity error message (as set by the element's setCustomValidity() method) is not the empty string.
</dd>
</dl>

<p class="note">注記：
要素は，`不能化され$ていても，依然として これらいずれかの状態に難ありになり得る。
したがって，これらの状態は、提出の間に~formを検証するときに，利用者に問題を指示しない場合でも，~DOMにおいて表現され得る。
【<a href="#the-constraint-validation-api">拘束検証~API</a>を通して？】
◎
An element can still suffer from these states even when the element is disabled; thus these states can be represented in the DOM even if validating the form during submission wouldn't indicate a problem to the user.
</p>

<p>
要素は、上述した どの`妥当性~状態$の難ありでもないとき，
`自身の拘束を満たす@
とされる。
◎
An element satisfies its constraints if it is not suffering from any of the above validity states.
</p>


				</section>
				<section id="constraint-validation">
<h4 title="Constraint validation">4.10.20.2. 拘束検証</h4>

<div >
<p class="algo-head">
~UAは、 `form$e 要素 %~form の
`拘束を静的に検証-@
することが要求されたときは，次の手続きを走らせ~MUST
— それは、［
`肯定的^i, `否定的^i
］のいずれかを返す：
</p>

<ul ><li>`肯定的^i は %~form 内のすべての~controlは妥当であることを表し、
`否定的^i はその否定を表す。
</li><li>`否定的^i を返す場合の結果には，［
妥当でないかつ, それを担当する~scriptもない要素
］の~listも伴われる（場合によっては空になる）
</li></ul>

◎
When the user agent is required to statically validate the constraints of form element form, it must run the following steps, which return either a positive result (all the controls in the form are valid) or a negative result (there are invalid controls) along with a (possibly empty) list of elements that are invalid and for which no script has claimed responsibility:
</div>

<ol>
	<li>
%~control~list ~LET
%~form が`所有-$している要素のうち，`提出-可能$であるものからなる，`木~順序$による~list
◎
Let controls be a list of all the submittable elements whose form owner is form, in tree order.
</li>
	<li>
%非~妥当~control~list ~LET 空~list
◎
Let invalid controls be an initially empty list of elements.
</li>
	<li>
<p>
%~control~list 内の ~EACH ( %欄 ) に対し：
◎
For each element field in controls, in tree order:
</p>

		<ol>
			<li>
~IF［
%欄 は`拘束検証の候補$でない
］
⇒
~CONTINUE
◎
If field is not a candidate for constraint validation, then move on to the next element.
</li>
			<li>
~IF［
%欄 は`自身の拘束を満たす$
］
⇒
~CONTINUE
◎
Otherwise, if field satisfies its constraints, then move on to the next element.
</li>
			<li>
%非~妥当~control~list に %欄 を追加する
◎
Otherwise, add field to invalid controls.
</li>
		</ol>
	</li>
	<li>
~IF［
%非~妥当~control~list は空である
］
⇒
~RET `肯定的^i
◎
If invalid controls is empty, then return a positive result.
</li>
	<li>
%未取扱~非妥当~control~list ~LET 空~list
◎
Let unhandled invalid controls be an initially empty list of elements.
</li>
	<li>
<p>
%非~妥当~control~list 内の ~EACH ( %欄 ) に対し：
◎
For each element field in invalid controls, if any, in tree order:
</p>
		<ol>
			<li>
%notCanceled ~LET %欄 に向けて，名前 `invalid$et の`~eventを発火する$
— 次のように初期化して
⇒
`cancelable$m 属性 ~SET ~T
◎
Let notCanceled be the result of firing an event named invalid at field, with the cancelable attribute initialized to true.
</li>
			<li>
~IF［
%notCanceled ~EQ ~T
］
⇒
%未取扱~非妥当~control~list に %欄 を追加する
◎
If notCanceled is true, then add field to unhandled invalid controls.
</li>
</ol>

	</li>
	<li>
~RET `否定的^i ＋ %未取扱~非妥当~control~list
◎
Return a negative result with the list of elements in the unhandled invalid controls list.
</li>
</ol>

<p class="algo-head">
~UAは、
`form$e 要素 %~form を
`拘束を対話的に検証-@
するときは、次の手続きを走らせ~MUST
◎
If a user agent is to interactively validate the constraints of form element form, then the user agent must run the following steps:
</p>

<ol>
	<li>
~IF［
%~form の`拘束を静的に検証-$した結果 ~EQ `肯定的^i
］
⇒
~RET `肯定的^i
◎
Statically validate the constraints of form, and let unhandled invalid controls be the list of elements returned if the result was negative.
◎
If the result was positive, then return that result.
</li>
	<li>
<p>
前段の検証-結果に伴われる %未取扱~非妥当~control~list 内の 1 個~以上の要素の拘束についての問題を，利用者に報告する
— ~UAは次をしても~MAY：
◎
Report the problems with the constraints of at least one of the elements given in unhandled invalid controls to the user. User agents＼
</p>

		<ul>
			<li>
`~objを~focusする$( ~list内のいずれかの要素 )
◎
may focus one of those elements in the process, by running the focusing steps for that element, and＼
</li>
			<li>
文書の~scrolling位置も変更する ／
要素を利用者に注目させるような何らかの他の動作を遂行する。
◎
may change the scrolling position of the document, or perform some other action that brings the element to the user's attention.＼
</li>
			<li>
複数の拘束~違反を報告する。
◎
User agents may report more than one constraint violation.＼
</li>
			<li>
適切になるなら，関係する拘束~違反~報告を~~結合する
（例：
`~radio~button群$内の複数の~radio~buttonが必須とされている場合、報告する必要がある~errorは一つだけになる）。
◎
User agents may coalesce related constraint violation reports if appropriate (e.g. if multiple radio buttons in a group are marked as required, only one error need be reported).＼
</li>
			<li>
いずれかの~controlが`具現化されて$いない場合（例： `hidden$a 属性を有するなど）、~script~errorを報告する。
◎
If one of the controls is not being rendered (e.g. it has the hidden attribute set) then user agents may report a script error.
</li>
		</ul>
	</li>
	<li>
~RET `否定的^i
◎
Return a negative result.
</li>
</ol>

				</section>
				<section id="the-constraint-validation-api">
<h4 title="The constraint validation API">4.10.20.3. 拘束検証~API</h4>

<dl class="domintro">

	<dt>%element . `willValidate$m</dt>
	<dd>
［
%element は~formの提出-時に検証されるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element will be validated when the form is submitted; false otherwise.
</dd>

	<dt>%element . `setCustomValidity(message)$m</dt>
	<dd>
~custom~errorを設定して %element が検証-時に失敗するようにする。
%message は 利用者に問題を報告するときに示される~messageを与える。
◎
Sets a custom error, so that the element would fail to validate. The given message is the message to be shown to the user when reporting the problem to the user.
</dd>
	<dd>
%message が空~文字列の場合、~custom~errorを~~空に戻す。
◎
If the argument is the empty string, clears the custom error.
</dd>

	<dt>%element . `validity$m . `valueMissing$m</dt>
	<dd>
［
%element は必須の欄であって 値がない ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element has no value but is a required field; false otherwise.
</dd>

	<dt>%element . `validity$m . `typeMismatch$m</dt>
	<dd>
［
%element の値は正しい構文でないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is not in the correct syntax; false otherwise.
</dd>

	<dt>%element . `validity$m . `patternMismatch$m</dt>
	<dd>
［
%element の値は供された~patternに合致しないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value doesn't match the provided pattern; false otherwise.
</dd>

	<dt>%element . `validity$m . `tooLong$m</dt>
	<dd>
［
%element の値は 供された最大~長さより長いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is longer than the provided maximum length; false otherwise.
</dd>

	<dt>%element . `validity$m . `tooShort$m</dt>
	<dd>
［
%element の値は 空~文字列でない, かつ 供された最小~長さより短いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value, if it is not the empty string, is shorter than the provided minimum length; false otherwise.
</dd>

	<dt>%element . `validity$m . `rangeUnderflow$m</dt>
	<dd>
［
%element の値は 供された最小より低いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is lower than the provided minimum; false otherwise.
</dd>

	<dt>%element . `validity$m . `rangeOverflow$m</dt>
	<dd>
［
%element の値は 供された最大より高いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is higher than the provided maximum; false otherwise.
</dd>

	<dt>%element . `validity$m . `stepMismatch$m</dt>
	<dd>
［
%element の値は `step$a 属性が与える規則に合わないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value doesn't fit the rules given by the step attribute; false otherwise.
</dd>

	<dt>%element . `validity$m . `badInput$m</dt>
	<dd>
［
利用者が~UI内に供した入力を ~UAが値に変換できないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the user has provided input in the user interface that the user agent is unable to convert to a value; false otherwise.
</dd>

	<dt>%element . `validity$m . `customError$m</dt>
	<dd>
［
%element に~custom~errorがあるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element has a custom error; false otherwise.
</dd>

	<dt>%element . `validity$m . `valid$m</dt>
	<dd>
［
%element の値に妥当性の問題がないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value has no validity problems; false otherwise.
</dd>

	<dt>%valid = %element . `checkValidity()$m</dt>
	<dd>
［
%element の値に妥当性の問題がないならば ~T ／
~ELSE_ ~F
］を返す。
加えて， ~F を返すときは、
%element に向けて `invalid$et ~eventを発火する。
◎
Returns true if the element's value has no validity problems; false otherwise. Fires an invalid event at the element in the latter case.
</dd>

	<dt>%valid = %element . `reportValidity()$m</dt>
	<dd>
［
%element の値に妥当性の問題がないならば ~T ／
~ELSE_ ~F
］を返す。
加えて， ~F を返すときは、
 %element に向けて `invalid$et ~eventを発火した上で，（~eventが取消されなかったなら）問題を利用者に報告する。
◎
Returns true if the element's value has no validity problems; otherwise, returns false, fires an invalid event at the element, and (if the event isn't canceled) reports the problem to the user.
</dd>

	<dt>%element . `validationMessage$m</dt>
	<dd>
%element の妥当性が検査され，問題があった場合に 利用者に示されることになる~error~messageを返す。
◎
Returns the error message that would be shown to the user if the element was to be checked for validity.
</dd>
</dl>



<dl class="idl-def">
	<dt>`willValidate@m</dt>
	<dd>
取得子は、［
此れは`拘束検証の候補$であるならば ~T ／
~ELSE_（すなわち`拘束検証の対象外$ならば） ~F 
］を返さ~MUST。
◎
The willValidate attribute's getter must return true, if this element is a candidate for constraint validation, and false otherwise (i.e., false if any conditions are barring it from constraint validation).
</dd>

	<dt>`setCustomValidity(message)@m</dt>
	<dd>
被呼出時には、［
此れの`~custom妥当性~error~message$ ~SET %message
］に設定し~MUST。
◎
The setCustomValidity(message) method, when invoked, must set the custom validity error message to message.
</dd>
	<dd class="example">

<p>
次の例では、~scriptは，~form~controlの値を編集される度に検査し、妥当な値でないならば，
`setCustomValidity()$m ~methodを利用して適切な~messageを設定する。
◎
In the following example, a script checks the value of a form control each time it is edited, and whenever it is not a valid value, uses the setCustomValidity() method to set an appropriate message.
</p>

<pre class="html-code">
&lt;label&gt;Feeling: &lt;input name=f type="text" oninput="check(this)"&gt;&lt;/label&gt;
&lt;script&gt;
 function check(%input) {
   if (%input.value == "good" ||
       %input.value == "fine" ||
       %input.value == "tired") {
     %input.setCustomValidity('"' + %input.value + '" is not a feeling.');
   } else {
     /* <span class="comment">
%input は申し分ない — ~error~messageを再設定する
◎
input is fine -- reset the error message
</span> */
     %input.setCustomValidity('');
   }
 }
&lt;/script&gt;
</pre>

	</dd>

	<dt>`validity@m</dt>
	<dd>
取得子は、［
此れの`妥当性~状態$を表現する `ValidityState$I ~obj
］を返さ~MUST。
この~objは`~live$とする。
◎
The validity attribute's getter must return a ValidityState object that represents the validity states of this element. This object is live.
</dd>

</dl>


<pre class="idl">
[Exposed=Window]
interface `ValidityState@I {
  readonly attribute boolean `valueMissing$m;
  readonly attribute boolean `typeMismatch$m;
  readonly attribute boolean `patternMismatch$m;
  readonly attribute boolean `tooLong$m;
  readonly attribute boolean `tooShort$m;
  readonly attribute boolean `rangeUnderflow$m;
  readonly attribute boolean `rangeOverflow$m;
  readonly attribute boolean `stepMismatch$m;
  readonly attribute boolean `badInput$m;
  readonly attribute boolean `customError$m;
  readonly attribute boolean `valid$m;
};
</pre>

<p>
`ValidityState$I ~objは、次に挙げる属性を持つ。
それらの取得子は、［
対応する条件が満たされるならば ~T ／
~ELSE_ ~F
］を返さ~MUST：
◎
A ValidityState object has the following attributes. On getting, they must return true if the corresponding condition given in the following list is true, and false otherwise.
</p>

<dl class="idl-def">
	<dt>`valueMissing@m</dt>
	<dd>
~controlには`欠落の難あり$
◎
The control is suffering from being missing.
</dd>

	<dt>`typeMismatch@m</dt>
	<dd>
~controlには`型~不一致の難あり$
◎
The control is suffering from a type mismatch.
</dd>

	<dt>`patternMismatch@m</dt>
	<dd>
~controlには`~pattern不一致の難あり$
◎
The control is suffering from a pattern mismatch.
</dd>

	<dt>`tooLong@m</dt>
	<dd>
~controlには`長過ぎる難あり$
◎
The control is suffering from being too long.
</dd>

	<dt>`tooShort@m</dt>
	<dd>
~controlには`短か過ぎる難あり$
◎
The control is suffering from being too short.
</dd>

	<dt>`rangeUnderflow@m</dt>
	<dd>
~controlには`~underflowの難あり$
◎
The control is suffering from an underflow.
</dd>

	<dt>`rangeOverflow@m</dt>
	<dd>
~controlには`~overflowの難あり$
◎
The control is suffering from an overflow.
</dd>

	<dt>`stepMismatch@m</dt>
	<dd>
~controlには`~step不一致の難あり$
◎
The control is suffering from a step mismatch.
</dd>

	<dt>`badInput@m</dt>
	<dd>
~controlには`不良~入力の難あり$
◎
The control is suffering from bad input.
</dd>

	<dt>`customError@m</dt>
	<dd>
~controlには`~custom~errorの難あり$
◎
The control is suffering from a custom error.
</dd>

	<dt>`valid@m</dt>
	<dd>
上に挙げた どの条件も満たされない
◎
None of the other conditions are true.
</dd>
</dl>

<hr>

<dl class="idl-def">
	<dt>`checkValidity()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The checkValidity() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
<p >
~IF［
此れは`拘束検証の候補$である
］~AND［
此れは`自身の拘束を満たす$
］：
◎
If this element is a candidate for constraint validation and does not satisfy its constraints, then:
</p>

				<ol>
					<li>
此れに向けて，名前 `invalid$et の`~eventを発火する$
— 次のように初期化して
⇒
`cancelable$m 属性 ~SET ~T（取消しても効果はないが）
◎
Fire an event named invalid at this element, with the cancelable attribute initialized to true (though canceling has no effect).
</li>
					<li>
~RET ~F
◎
Return false.
</li>
				</ol>
			</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</dd>

	<dt>`reportValidity()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The reportValidity() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
<p>
~IF［
此れは`拘束検証の候補$である
］~AND［
此れは`自身の拘束を満たす$
］：
◎
If this element is a candidate for constraint validation and does not satisfy its constraints, then:
</p>

				<ol>
					<li>
%report ~LET 此れに向けて，名前 `invalid$et の`~eventを発火する$
— 次のように初期化して
⇒
`cancelable$m 属性 ~SET ~T
◎
Let report be the result of firing an event named invalid at this element, with the cancelable attribute initialized to true.
</li>
					<li>
<p>
~IF［
%report ~EQ ~T
］
⇒
此れの拘束についての問題を 利用者に報告する
— その際には、~UAは 次をしても~MAY：
◎
If report is true, then report the problems with the constraints of this element to the user. When reporting the problem with the constraints to the user, the user agent＼
</p>

						<ul >
							<li>
`~objを~focusする$( 此れ )
◎
may run the focusing steps for this element, and＼
</li>
							<li>
文書の~scrolling位置を変更する, あるいは
要素を利用者に注目させるような何らかの他の動作を遂行する
◎
may change the scrolling position of the document, or perform some other action that brings this element to the user's attention.＼
</li>
							<li>
此れが複数の問題に難ありならば，それら複数の拘束~違反を報告する
◎
User agents may report more than one constraint violation, if this element suffers from multiple problems at once.＼
</li>
							<li>
此れが`具現化されて$いない場合、利用者に通知する代わりに，`走っている~script$に対し`~errorを報告する$
◎
If this element is not being rendered, then the user agent may, instead of notifying the user, report the error for the running script.
</li>
						</ul>
					</li>
					<li>
~RET ~F
◎
Return false.
</li>
				</ol>
			</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</dd>

	<dt>`validationMessage@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The validationMessage attribute's getter must run these steps:
</p>

		<ol>
			<li>
~IF［
此れは`拘束検証の候補$でない
］~OR［
此れは`自身の拘束を満たす$
］
⇒
~RET 空~文字列
◎
If this element is not a candidate for constraint validation or if this element satisfies its constraints, then return the empty string.
</li>
			<li>
<p>
~RET 次の要件を満たすような~message：
◎
Return a suitably localized message that＼
</p>
				<ul>
					<li>
此れは、妥当性の拘束に問題がある，唯一の~form~controlである場合、利用者に示すに相応しく地域化された~message。
◎
the user agent would show the user if this were the only form control with a validity constraint problem.＼
</li>
					<li>
~UAが~textによる~messageを実際に示さない場合（例えば，代わりに~graphical-cueを示す場合）、~controlが満たさない（ 1 個~以上の）妥当性~拘束を表し, 相応しく地域化された~message。
◎
If the user agent would not actually show a textual message in such a situation (e.g., it would show a graphical cue instead), then return a suitably localized message that expresses (one or more of) the validity constraint(s) that the control does not satisfy.＼
</li>
					<li>
［
此れは`拘束検証の候補$である
］~AND［
`~custom~errorの難あり$
］の場合、結果の~message内には`~custom妥当性~error~message$が在するべきである。
【この場合の結果に，他の情報も含まれ得るのかどうかは、原文の記述からは，はっきりしない。】
◎
If the element is a candidate for constraint validation and is suffering from a custom error, then the custom validity error message should be present in the return value.
</li>
				</ul>
			</li>
		</ol>
	</dd>
</dl>


				</section>
				<section id="security-forms">
<h4 title="Security">4.10.20.4. 保安</h4>


<p id="security-0">
~serverは、~client側の検証に依拠するべきでない。
敵対的な利用者は，~client側の検証を意図的に迂回でき、また
意図せずとも，これらの特色機能を実装しない［
旧式の~UA ／ 自動化~tool
］の利用者により迂回され得るので。
拘束検証の特色機能が意図するのは，利用者~体験を改善することに限られており、保安については，いかなる種類の仕組みも供さない。
◎
Servers should not rely on client-side validation. Client-side validation can be intentionally bypassed by hostile users, and unintentionally bypassed by users of older user agents or automated tools that do not implement these features. The constraint validation features are only intended to improve the user experience, not to provide any kind of security mechanism.
</p>


				</section>
			</section>
			<section id="form-submission-2">
<h3 title="Form submission">4.10.21. ~form提出</h3>

				<section id="introduction-5">
<h4 title="Introduction">4.10.21.1. 序論</h4>


~INFORMATIVE

<p>
~formが提出されるとき、~form内の~dataは，`~enctype$が指定する構造に変換された上で、所与の`~method$を用いて，`動作$に指定される行先へ送信される。
◎
When a form is submitted, the data in the form is converted into the structure specified by the enctype, and then sent to the destination specified by the action using the given method.
</p>

<p>
例えば、次の~formでは：
◎
For example, take the following form:
</p>

`form-submission-1^xCode

<p>
利用者が
1 番目の欄に "cats",
2 番目の欄に "fur"
と打込んで，提出-~buttonを叩いた場合、~UAは
`/find.cgi?t=cats&amp;q=fur^c
を読込むことになる。
◎
If the user types in "cats" in the first field and "fur" in the second, and then hits the submit button, then the user agent will load /find.cgi?t=cats&amp;q=fur.
</p>

<p>
他方、次の~formを考える：
◎
On the other hand, consider this form:
</p>

`form-submission-2^xCode

<p>
利用者により同じ入力が与えられた下での提出の結果は，全く異なり、代わりに~UAは，所与の~URLへ向けて 次の~textに似た様な~entity本体を伴わせた~HTTP~POSTを行う：
◎
Given the same user input, the result on submission is quite different: the user agent instead does an HTTP POST to the given URL, with as the entity body something like the following text:
</p>

<pre class="http-code">
------kYFrd4jNJEgCervE
Content-Disposition: form-data; name="t"

cats
------kYFrd4jNJEgCervE
Content-Disposition: form-data; name="q"

fur
------kYFrd4jNJEgCervE--
</pre>


				</section>
				<section id="implicit-submission">
<h4 title="Implicit submission">4.10.21.2. 暗黙的な提出</h4>

<p>
`form$e 要素の
`既定の~button@
は、それが`所有-$している`提出-~button$のうち，`木~順序$で最初のものとする。
◎
A form element's default button is the first submit button in tree order whose form owner is that form element.
</p>

<p>
~UAが，利用者による ~formの暗黙的な提出を~supportする場合（例えば，一部の~platformでは、~text~controlが`~focusされて$いる間に <kbd>enter</kbd> ~keyを叩くと，~formは暗黙的に提出される）、~formの`既定の~button$に`作動化の挙動$があって, `不能化され$ていない場合に そうするときは、~UAは，その`既定の~button$に向けて`~click~eventを発火-$し~MUST。
◎
If the user agent supports letting the user submit a form implicitly (for example, on some platforms hitting the "enter" key while a text control is focused implicitly submits the form), then doing so for a form, whose default button has activation behavior and is not disabled, must cause the user agent to fire a click event at that default button.
</p>


<p class="note">注記：
~Webには，~formを暗黙的に提出する仕方がある場合に限り利用できる頁もある。
したがって、~UAには，これの~supportが強く奨励される。
◎
There are pages on the Web that are only usable if there is a way to implicitly submit forms, so user agents are strongly encouraged to support this.
</p>

<div>
<p>
~formに`提出-~button$がない場合、暗黙的な提出の仕組みは：
</p>

<ul>
	<li>
<p>
~form内に，` 暗黙的な提出を阻む欄^i がある場合には、何もしては~MUST_NOT
⇒
` 暗黙的な提出を阻む欄^i とは、`form$e 要素が`所有-$している `input$e 要素のうち，`type$a 属性の状態が次のいずれかにあるものとする
⇒
`Text$st, `Text$st, `Url$st, `Tel$st, `Email$st, `Password$st, `Date$st, `Month$st, `Week$st, `Time$st, `Datetime-local$st, `Number$st
</p>

</li>
	<li>
他の場合、次をし~MUST
⇒
 `form$e 要素を それ自身から`提出する$
</li>
</ul>

◎
If the form has no submit button, then the implicit submission mechanism must do nothing if the form has more than one field that blocks implicit submission, and must submit the form element from the form element itself otherwise.
◎
For the purpose of the previous paragraph, an element is a field that blocks implicit submission of a form element if it is an input element whose form owner is that form element and whose type attribute is in one of the following states: Text, Search, URL, Telephone, E-mail, Password, Date, Month, Week, Time, Local Date and Time, Number
</div>

				</section>
				<section id="form-submission-algorithm">
<h4 title="Form submission algorithm">4.10.21.3. ~form提出~algo</h4>

<p class="algo-head">
`form$e 要素 %~form を要素 %提出元 （概して~button）から
`提出する@
ときは、~UAは，次の手続きを走らせ~MUST：
◎
When a form element form is submitted from an element submitter (typically a button),＼
◎
↓↓optionally with a submitted from submit() method flag set, the user agent must run the following steps:
</p>

<ol>
	<li>
~IF［
%~form は`~navigateできない$
］
⇒
~RET
◎
If form cannot navigate, then return.
</li>
	<li>
%~form文書 ~LET %~form の`~node文書$
◎
Let form document be the form's node document.
</li>
	<li id="sandboxSubmitBlocked">
~IF［
`閲覧文脈~sandbox化( ~form )~flag$ ~IN %~form文書 の`作動中の~sandbox法~flag集合$
］
⇒
~RET
◎
If form document's active sandboxing flag set has its sandboxed forms browsing context flag set, then return.
</li>
	<li>
%~form閲覧文脈 ~LET %~form文書 が`属する閲覧文脈$
◎
Let form browsing context be the browsing context of form document.
</li>
	<li>
`submit() から呼出された^V ~LET ［
この手続きは `submit()$m ~methodから呼出されたならば ~T ／
~ELSE_ ~F
］
◎
↑↑</li>
	<li>
<p>
~IF［
`submit() から呼出された^V ~EQ ~F
］：
</p>
		<ol>
			<li>
<p>
~IF［
%提出元 の`検証なし状態$ ~EQ ~F
］：
</p>
				<ol>
					<li>
%結果 ~LET %~form の`拘束を対話的に検証-$した結果
</li>
					<li>
<p>
~IF［
%結果 ~EQ `否定的^i
］：
</p>

<ol><li>%~form に向けて，名前 `invalid$et の`~eventを発火する$
</li><li>~RET
</li></ol>
					</li>
				</ol>
◎
If the submitted from submit() method flag is not set, and the submitter element's no-validate state is false, then interactively validate the constraints of form and examine the result: if the result is negative (the constraint validation concluded that there were invalid fields and probably informed the user of this) then fire an event named invalid at the form element and then return.
◎
If the submitted from submit() method flag is not set, then:
</li>
			<li>
%continue ~LET %~form に向けて，名前 `submit$et の`~eventを発火する$
— 次のように初期化して
⇒＃
`bubbles$m 属性 ~SET ~T, 
`cancelable$m 属性 ~SET ~T
◎
Let continue be the result of firing an event named submit at form, with the bubbles attribute initialized to true and the cancelable attribute initialized to true.
</li>
			<li>
~IF［
%continue ~EQ ~F
］
⇒
~RET
◎
If continue is false, then return.
</li>
			<li>
<p>
~IF［
%~form は`~navigateできない$
］
⇒
~RET
◎
If form cannot navigate, then return.
</p>

<p class="note">注記：
`~navigateできない$かどうか再び調べる
— `submit$et ~eventを配送した結果，変化することもあるので。
◎
Cannot navigate is run again as dispatching the submit event could have changed the outcome.
</p>
			</li>
		</ol>
	</li>
	<li>
%符号化方式 ~LET %~form の現在の`符号化方式$form
◎
Let encoding be the result of picking an encoding for the form.
</li>
	<li>
%~form~data集合 ~LET `~form~data集合を構築する$( %~form, %提出元, %符号化方式 )
◎
Let form data set be the result of constructing the form data set with form, submitter, and encoding.
</li>
	<li>
%動作~URL ~LET %提出元 の`動作$
◎
Let action be the submitter element's action.
</li>
	<li>
~IF［
%動作~URL ~EQ 空~文字列
］
⇒
%動作~URL ~LET %~form文書 の`~URL$doc
◎
If action is the empty string, let action be the URL of the form document.
</li>
	<li>
%解析済み動作 ~LET %動作~URL を %提出元 の`~node文書$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse the URL action, relative to the submitter element's node document.＼
</li>
	<li>
~IF［
%解析済み動作 ~EQ ~error
］
⇒
~RET
◎
If this fails, return.
◎
Let parsed action be the resulting URL record.
</li>
	<li>
%~scheme ~LET %解析済み動作 の`~scheme$url
◎
Let scheme be the scheme of parsed action.
</li>
	<li>
%~enctype ~LET %提出元 の`~enctype$
◎
Let enctype be the submitter element's enctype.
</li>
	<li>
%~method ~LET %提出元 の`~method$
◎
Let method be the submitter element's method.
</li>
	<li>
%~target ~LET ［［
%提出元 は`提出-~button$である
］~AND［
%提出元 は `formtarget$a 属性~値を有する
］ならば その属性~値 ／
~ELSE_ `要素の~targetを取得する$( %~form )
<!-- ＊
原文 “提出元 の~form所有者／submitter's form owner” はおかしい：
提出元 が form 要素の場合、~form所有者 は定義されない
-->
］
◎
Let target be the submitter element's formtarget attribute value, if the element is a submit button and has such an attribute. Otherwise, let it be the result of getting an element's target given submitter's form owner.
</li>
	<li>
( %~target閲覧文脈, %置換- ) ~LET
( %~target, %~form閲覧文脈 )
を与える下で，`閲覧文脈を選ぶ規則$を適用した結果
◎
Let target browsing context and replace be the result of applying the rules for choosing a browsing context using target and form browsing context.
</li>
	<li>
~IF［
%~target閲覧文脈 ~EQ ~NULL
］
⇒
~RET
◎
If target browsing context is null, then return.
</li>
	<li>
［
%~form文書 はまだ`完全に読込まれ$ていない
］~AND［
`submit() から呼出された^V ~EQ ~T
］
⇒
%置換- ~SET ~T
◎
If form document has not yet completely loaded and the submitted from submit() method flag is set, then set replace to true.
</li>
	<li>
~IF［
%~method ~EQ `dialog$st
］
⇒
`~dialogを提出する$
◎
If the value of method is dialog then jump to the submit dialog steps.
</li>
	<li>
<p>
( %~scheme, %~method ) に応じて，下の表の一列目の %~scheme に該当する行の %~method に該当する列に示される下位手続きを遂行する
◎
Otherwise, select the appropriate row in the table below based on the value of scheme as given by the first cell of each row. Then, select the appropriate cell on that row based on the value of method as given in the first cell of each column. Then, jump to the steps named in that cell and defined below the table.
</p>

<table><thead><tr><td>%~scheme
<th>%~method ~EQ `GET$st
<th>%~method ~EQ `POST$st
</thead><tbody><tr><th> `http^c
<td>`変異-動作~URL$
◎
Mutate action URL
<td>`~entity本体として提出する$
◎
Submit as entity body

<tr><th> `https^c
<td>`変異-動作~URL$
◎
Mutate action URL
<td>`~entity本体として提出する$
◎
Submit as entity body

<tr><th> `ftp^c
<td>`~Get動作~URL$
◎
Get action URL
<td>`~Get動作~URL$
◎
Get action URL

<tr><th> `javascript^c
<td>`~Get動作~URL$
◎
Get action URL
<td>`~Get動作~URL$
◎
Get action URL

<tr><th> `data^c
<td>`変異-動作~URL$
◎
Mutate action URL
<td>`~Get動作~URL$
◎
Get action URL

<tr><th> `mailto^c
<td>`~header列を伴う~Mail$
◎
Mail with headers
<td>`本体として~Mailする$
◎
Mail as body

<tr><th> その他
<td colspan="2">
この仕様では定義されない
—
~UAは、これを定義する別の仕様がない限り，この仕様にて 類似する~schemeに対し定義される方式と相似的に動作するべきである。
◎
If scheme is not one of those listed in this table, then the behavior is not defined by this specification. User agents should, in the absence of another specification defining this, act in a manner analogous to that defined in this specification for similar schemes.

</tbody></table>

</ol>

<p>
各 `form$e 要素 %~form には、
`計画された~navi@
がある。
それは，~NULL または ある`~task$として定義され、要素の作成-時には~NULLに設定され~MUST。
以下に述べる挙動において，特定0の資源 %行先 への
`~navigateを計画する@
よう要求されたときは、次の手続きを走らせ~MUST
◎
Each form element has a planned navigation, which is either null or a task; when the form is first created, its planned navigation must be set to null. In the behaviors described below, when the user agent is required to plan to navigate to a particular resource destination, it must run the following steps:
</p>

<ol>
	<li>
~IF［
%~form に`計画された~navi$ ~NEQ ~NULL
］
⇒
それを`~task~queue$から除去する
◎
If the form has a non-null planned navigation, remove it from its task queue.
</li>
	<li>
( %~target閲覧文脈, %置換- ) ~LET 
この手続きを呼出した ~formを`提出する$~algoにより設定されたそれら
◎
↓</li>
	<li>
<p>
%~form に`計画された~navi$ ~LET 次の手続きを走らす新たな`~task$：
◎
Let the form's planned navigation be a new task that consists of running the following steps:
</p>

		<ol>
			<li>
%~form に`計画された~navi$ ~SET ~NULL
◎
Let the form's planned navigation be null.
</li>
			<li>
［
`置換~可能化~flag$ ~SET %置換-
］の下で，
%~target閲覧文脈 を %行先 へ`~navigate$する
◎
Navigate target browsing context to destination. If replace is true, then target browsing context must be navigated with replacement enabled.
◎
For the purposes of this task, target browsing context and replace are the variables that were set up when the overall form submission algorithm was run, with their values as they stood when this planned navigation was queued.
</li>
		</ol>
	</li>
	<li>
~task源に`~DOM操作~task源$を用いる下で，次を走らす`~taskを~queueする$
⇒
%~form に`計画された~navi$
◎
Queue the task that is the form's new planned navigation.
◎
The task source for this task is the DOM manipulation task source.
</li>
</ol>

<p>
%~form を`提出する$~algoの文脈における各種~挙動は、次に従うとする：
◎
The behaviors are as follows:
</p>

<dl>
	<dt>`変異-動作~URL@
◎
Mutate action URL
</dt>
	<dd>
		<ol>
			<li>
%解析済み動作 の`~query$url ~SET
`~form_urlencoded直列化器$( %~form~data集合, %符号化方式 )
◎
Let query be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.
◎
Set parsed action's query component to query.
</li>
			<li>
%解析済み動作 への`~navigateを計画する$
◎
Plan to navigate to parsed action.
</li>
		</ol>
	</dd>

	<dt>`~entity本体として提出する@
◎
Submit as entity body
</dt>
	<dd>
		<ol>
			<li>
<p>
%~enctype に応じて：
◎
Switch on enctype:
</p>

				<dl class="switch">
					<dt>`~form_urlencoded$sT</dt>
					<dd>
<p>
%本体 ~LET
`~form_urlencoded直列化器$( %~form~data集合, %符号化方式 )
◎
Let body be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.
</p>


<p>
%本体 ~SET `~UTF-8符号化する$( %本体 )
◎
Set body to the result of encoding body.
</p>

<p>
%~MIME型 ~LET `~form_urlencoded$mt
◎
Let MIME type be "application/x-www-form-urlencoded".
</p>
					</dd>


					<dt>`~mp_form_data$sT</dt>
					<dd>
%本体 ~LET `~mp_form_dataとして符号化する$( %~form~data集合, %符号化方式 )
◎
Let body be the result of running the multipart/form-data encoding algorithm with form data set and encoding.
</dd>
					<dd>
%~MIME型 ~LET 次の文字列を順に連結した結果
⇒＃
`multipart/form-data;^l,
1 個の文字 `0020^U SPACE,
`boundary=^l,
`~mp_form_dataとして符号化する$ときに生成された`~mp_form_data境界~文字列$
◎
Let MIME type be the concatenation of the string "multipart/form-data;", a U+0020 SPACE character, the string "boundary=", and the multipart/form-data boundary string generated by the multipart/form-data encoding algorithm.
</dd>

					<dt>`~text_plain$sT</dt>
					<dd>
<p>
%本体 ~LET `~text_plainとして符号化する$( %~form~data集合 )
◎
Let body be the result of running the text/plain encoding algorithm with form data set.
</p>

<p>
%本体 ~SET `符号化方式を用いて符号化する$( %符号化方式, %本体 )
◎
Set body to the result of encoding body using encoding.
</p>

<p>
%~MIME型 ~LET `~text_plain^mt
◎
Let MIME type be "text/plain".
</p>
</dd>
				</dl>
			<li>
<p>
次のようにされた新たな`要請$への`~navigateを計画する$
</p>

<ul><li>`~url$rq ~SET %解析済み動作
</li><li>`~method$rq ~SET %~method
</li><li>`~header~list$rq ~SET 
( `Content-Type^h / %~MIME型 )
のみからなる
</li><li>`本体$rq ~SET %本体
</li></ul>

◎
Plan to navigate to a new request whose url is parsed action, method is method, header list consists of `Content-Type`/MIME type, and body is body.
</li>
		</ol>
	</dd>

	<dt>`~Get動作~URL@
◎
Get action URL
</dt>
	<dd>
<p>
%解析済み動作 への`~navigateを計画する$
◎
Plan to navigate to parsed action.
</p>

<p class="note">注記：
%~form~data集合 は破棄される。
◎
The form data set is discarded.
</p>
	</dd>

	<dt>`~header列を伴う~Mail@
◎
Mail with headers
</dt>
	<dd>
		<ol>
			<li>
%~header列 ~LET
`~form_urlencoded直列化器$( %~form~data集合, %符号化方式 )
◎
Let headers be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.
</li>
			<li>
%~header列 内の各 文字 `002B^U `+^smb を 文字列 `%20^l に置換する
◎
Replace occurrences of U+002B PLUS SIGN characters (+) in headers with the string "%20".
</li>
			<li>
%解析済み動作 の`~query$url ~SET %~header列
◎
Set parsed action's query to headers.
</li>
			<li>
%解析済み動作 への`~navigateを計画する$
◎
Plan to navigate to parsed action.
</li>
		</ol>
	</dd>

	<dt>
`本体として~Mailする@
◎
Mail as body
</dt>
	<dd>
		<ol>
			<li>
<p>
%~enctype に応じて：
◎
Switch on enctype:
</p>

<dl class="switch">
<dt>`~text_plain$sT</dt>
<dd>
<ol>
	<li>
%本体 ~LET `~text_plainとして符号化する$( %~form~data集合 )
◎
Let body be the result of running the text/plain encoding algorithm with form data set.
</li>
	<li>
%本体 内の ~EACH ( %符号位置 ) を次の結果に置換する
⇒
`~UTF-8~percent-符号化する$( `~path~percent-符号化-集合$, %符号位置 )
］
`URL$r
◎
Set body to the result of concatenating the result of UTF-8 percent encoding each code point in body, using the default encode set. [URL]
</li>
</ol>

</dd>
<dt>
その他
◎
Otherwise
</dt>
<dd>
%本体 ~LET
`~form_urlencoded直列化器$( %~form~data集合, %符号化方式 )
◎
Let body be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.
</dd>
</dl>
			</li>
			<li>
%~query ~LET %解析済み動作 の`~query$url
</li>
			<li>
~IF［
%~query ~EQ ~NULL
］
⇒
%~query ~SET 空~文字列
◎
If parsed action's query is null, then set it to the empty string.
</li>
			<li>
~IF［
%~query ~NEQ 空~文字列
］
⇒
%~query に 1 個の文字 `0026^U `&amp;^smb を付加する
◎
If parsed action's query is not the empty string, then append a single U+0026 AMPERSAND character (&amp;) to it.
</li>
			<li>
%~query に `body=^l を付加する
◎
Append "body=" to parsed action's query.
</li>
			<li>
%~query に %本体 を付加する
◎
Append body to parsed action's query.
</li>
			<li>
%解析済み動作 の`~query$url ~SET %~query
</li>
			<li>
%解析済み動作 への`~navigateを計画する$
◎
Plan to navigate to parsed action.
</li>
		</ol>
	</dd>
	<dt>`~dialogを提出する@
◎
Submit dialog
</dt>
	<dd>
		<ol>
			<li>
%対象 ~LET %~form に最も近い先祖 `dialog$e 要素
◎
Let subject be the nearest ancestor dialog element of form, if any.
</li>
			<li>
~IF［
%対象 ~EQ ε（無い）
］~OR［
%対象 は `open$a 属性を有さない
］
⇒
~RET
— 何もしない。
◎
If there isn't one, or if it does not have an open attribute, do nothing. Otherwise, proceed as follows:
</li>
			<li>
%結果 ~LET %提出元 の`値$（ ε もとり得る）
◎
↓</li>
			<li>
<p>
~IF［
%提出元 は `input$e 要素である
］~AND［
その `type$a 属性は `Image$st 状態にある
］：
</p>
				<ol>
					<li>
( %x, %y ) ~LET `選択された座標$の ( x, y ) 成分を基数 10 の数として `~ASCII数字$列で表した結果
</li>
					<li>
%結果 ~SET 次を順に連結した結果
⇒＃
%x,
文字 `002C^U `,^smb,
%y
</li>
				</ol>

◎
If submitter is an input element whose type attribute is in the Image Button state, then let result be the string formed by concatenating the selected coordinate's x-component, expressed as a base-ten number using ASCII digits, a U+002C COMMA character (,), and the selected coordinate's y-component, expressed in the same way as the x-component.
◎
Otherwise, if submitter has a value, then let result be that value.
◎
Otherwise, there is no result.
</li>
			<li>
%対象 の`~dialogを閉じる$
</li>
			<li>
~RET %結果
◎
Then, close the dialog subject. If there is a result, let that be the return value.
</li>
		</ol>
	</dd>
</dl>

				</section>
				<section id="constructing-form-data-set">
<h4 title="Constructing the form data set">4.10.21.4. ~form~data集合の構築-法</h4>

<p class="algo-head">
`~form~data集合を構築する@
ときは、所与の
( %~form, %提出元 （省略時は ~NULL ）, %符号化方式 （省略時は ~NULL ）
に対し，次を走らす：
◎
The algorithm to construct the form data set given a form, an optional submitter, and an optional encoding, is as follows. If not specified otherwise, submitter is null.
</p>

<ol>
	<li>
%~control~list ~LET ［
%~form が`所有-$している`提出-可能$な要素
］すべてからなる，`木~順序$による~list
◎
Let controls be a list of all the submittable elements whose form owner is form, in tree order.
</li>
	<li>
%~form~data集合 ~LET 空~list（ 0 個~以上の［
( 名, 値 ) が成す組
］からなる）
◎
Let the form data set be a list of name-value tuples, initially empty.
</li>
	<li>
<p>
%~control~list 内の ~EACH ( %欄 ) に対し：
◎
For each element field in controls, in tree order:
</p>
		<ol>
			<li>
%状態 ~LET ［
%欄 は `input$e 要素であるならば その `type$a 属性の状態 ／
~ELSE_ `他の要素^i
］
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If any of the following is true:
</p>

				<ul>
					<li>
%欄 の先祖に `datalist$e 要素がある
◎
The field element has a datalist element ancestor.
</li>
					<li>
%欄 は`不能化され$ている
◎
The field element is disabled.
</li>
					<li>
［
%欄 は`~button$である
］~AND［
%欄 ~NEQ %提出元
］
◎
The field element is a button but it is not submitter.
</li>
					<li>
［
%状態 ~IN { `Checkbox$st, `Radio$st }
］~AND［
%欄 の`~checkedness$ ~EQ ~F
］
◎
The field element is an input element whose type attribute is in the Checkbox state and whose checkedness is false.
◎
The field element is an input element whose type attribute is in the Radio Button state and whose checkedness is false.
</li>
					<li>
［
%状態 ~NEQ `Image$st
］~AND［［
%欄 は `name$a 属性を有さない
］~OR［
%欄 は `name$a 属性を有していて，その値 ~EQ 空~文字列
］］
◎
The field element is not an input element whose type attribute is in the Image Button state, and either the field element does not have a name attribute specified, or its name attribute's value is the empty string.
</li>
					<li>
%欄 は［
`~plugin$を利用していない `object$e 要素
］である
◎
The field element is an object element that is not using a plugin.
</li>
				</ul>

<p>
…ならば
⇒
~CONTINUE
◎
Then continue.
</p>

			</li>
			<li>
%名 ~LET ［
%欄 は `name$a 属性を有するならば その値 ／
~ELSE_ 空~文字列
］
◎
↓</li>
			<li>
<p>
%状態 に応じて, または［
%状態 ~EQ `他の要素^i
］の場合は %欄 に応じて：
◎
↓</p>

				<ul class="switch">
					<li>
<p>
`Image$st：
◎
If the field element is an input element whose type attribute is in the Image Button state, then:
</p>
						<ol>
							<li>
~IF［
%名 ~NEQ 空~文字列
］
⇒
%名 の末尾に 1 個の文字 `002E^U `.^smb を付加する
◎
If the field element has a name attribute specified and its value is not the empty string, let name be that value followed by a single U+002E FULL STOP character (.). Otherwise, let name be the empty string.
</li>
							<li>
%x名 ~LET %名 の末尾に 1 個の文字 `0078^U `x^smb を付加した結果
◎
Let namex be the string consisting of the concatenation of name and a single U+0078 LATIN SMALL LETTER X character (x).
</li>
							<li>
%y名 ~LET %名 の末尾に 1 個の文字 `0079^U `y^smb を付加した結果
◎
Let namey be the string consisting of the concatenation of name and a single U+0079 LATIN SMALL LETTER Y character (y).
</li>
							<li>
~Assert：
［
%欄 ~EQ %提出元
］~AND［
この~algoが呼出される前に，利用者は座標を指示した
］
◎
The field element is submitter, and before this algorithm was invoked the user indicated a coordinate.＼
</li>
							<li>
( %x, %y ) ~LET に利用者により`選択された座標$の ( %x, %y ) 成分
◎
Let x be the x-component of the coordinate selected by the user, and let y be the y-component of the coordinate selected by the user.
</li>
							<li>
%~form~data集合 に`~entryを付加する$( %x名, %x )
◎
Append an entry to the form data set with namex and x.
</li>
							<li>
%~form~data集合 に`~entryを付加する$( %y名, %y )
◎
Append an entry to the form data set with namey and y.
</li>
							<li>
~CONTINUE
◎
Continue.
◎
Let name be the value of the field element's name attribute.
</li>
						</ol>
					</li>
					<li>
`select$e 要素である
⇒
%欄 の`選択肢~list$内の ~EACH( `option$e 要素 %O ) に対し
⇒
~IF［
%O の`選択有無$opt ~EQ ~T
］~AND［
%O は`不能化され$optていない
］
⇒
%~form~data集合 に`~entryを付加する$( %名, %O の`値$opt )
◎
If the field element is a select element, then for each option element in the select element's list of options whose selectedness is true and that is not disabled,append an entry to the form data set with name and the value of the option element.
</li>
					<li>
<p>
`Checkbox$st ／ `Radio$st ：
◎
Otherwise, if the field element is an input element whose type attribute is in the Checkbox state or the Radio Button state, then:
</p>
						<ol>
							<li>
%値 ~LET ［
%欄 は `value$a 属性を有するならば その値 ／
~ELSE_ 文字列 `on^l
］
◎
If the field element has a value attribute specified, then let value be the value of that attribute; otherwise, let value be the string "on".
</li>
							<li>
%~form~data集合 に`~entryを付加する$( %名, %値 )
◎
Append an entry to the form data set with name and value.
</li>
						</ol>
					</li>
					<li>
<p>
`File$st ：
◎
Otherwise, if the field element is an input element whose type attribute is in the File Upload state, then＼
</p>
						<ol>
							<li>
%~file~list ~LET %欄 の`選択された~file~list$
◎
↓</li>
							<li>
~IF［
%~file~list は空でない
］
⇒
%~file~list 内の ~EACH( %~file ) に対し
⇒
%~form~data集合 に`~entryを付加する$( %名, %~file )
（ %~file は、 ( 名前, 型, 本体 ) からなる）
◎
for each file selected in the input element, append an entry to the form data set with name and the file (consisting of the file's name, type, and body).＼
</li>
							<li>
~ELSE
⇒
%~form~data集合 に`~entryを付加する$( %名, 次を伴う~file )
⇒＃
名前 ~SET 空~文字列,
型 ~SET `application/octet-stream$mt
本体 ~SET 空
◎
If there are no selected files, then append an entry to the form data set with name and a file with an empty name, application/octet-stream as type, and an empty body.
</li>
						</ol>
					</li>
					<li>
`object$e 要素である
⇒
~IF［
`~plugin$から~form提出~値を得れる
］
⇒
%~form~data集合 に`~entryを付加する$( %名, ~form提出~値 )
◎
Otherwise, if the field element is an object element: try to obtain a form submission value from the plugin, and if that is successful, append an entry to the form data set with name and the returned form submission value.
</li>
					<li>
<p>
`Hidden$st：
◎
Otherwise, if the field element is an input element whose type attribute is in the Hidden state＼
</p>
						<ol>
							<li>
~IF［
%名 ~NEQ "`_charset_$v"
］
⇒
~GOTO `その他^i
◎
and name is "_charset_":
</li>
							<li>
%charset ~LET %符号化方式 に応じて
⇒＃
~NULL ならば `UTF-8^l ／
~ELSE_ %符号化方式 の`名前$enc
◎
Let charset be the name of encoding if encoding is given, and "UTF-8" otherwise.
</li>
							<li>
%~form~data集合 に`~entryを付加する$( %名, %charset )
◎
Append an entry to the form data set with name and charset.
</li>
						</ol>
					</li>
					<li>
<p>
`textarea$e 要素である
⇒
%~form~data集合 に`~entryを付加する$( %名, %欄 の`値$, `改行は正規化しない^i )
◎
Otherwise, if the field element is a textarea element, append an entry to the form data set with name and the value of the field element, and the prevent line break normalization flag set.
</p>

<p class="note">注記：
`textarea$e 要素の`値$の事例では、改行の正規化は，~controlの`生の値$tAを~controlの`値$に変換する間にすでに遂行されている（それは、必要とされる行折返しも遂行する）。
◎
In the case of the value of textarea elements, the line break normalization is already performed during the conversion of the control's raw value into the control's value (which also performs any necessary line wrapping).
</p>
					</li>
					<li>
`その他^i
⇒
%~form~data集合 に`~entryを付加する$( %名, %欄 の`値$ )
◎
Otherwise, append an entry to the form data set with name and the value of the field element.
</li>

				</ul>
			</li>
			<li>
<p>
~IF［
%欄 は `dirname$a 属性を有する
］~AND［
その値 ~NEQ 空~文字列
］：
◎
If the element has a dirname attribute, and that attribute's value is not the empty string, then:
</p>
				<ol>
					<li>
%方向~名 ~LET %欄 の `dirname$a 属性の値
◎
Let dirname be the value of the element's dirname attribute.
</li>
					<li>
%方向 ~LET %欄 の`方向性$に応じて［
`左横書き$ならば `ltr^l ／
`右横書き$ならば `rtl^l
］
◎
Let dir be the string "ltr" if the directionality of the element is 'ltr', and "rtl" otherwise (i.e., when the directionality of the element is 'rtl').
</li>
					<li>
%~form~data集合 に`~entryを付加する$( %方向~名, %方向 )
◎
Append an entry to the form data set with dirname and dir.
</li>
			</ol>

<p class="note">注記：
要素が `dirname$a 属性を有するのは、
`textarea$e 要素であるか, または［
`input$e 要素であって その `type$a 属性の状態 ~IN { `Text$st, `Search$st }
］の場合に限られる。
◎
An element can only have a dirname attribute if it is a textarea element or an input element whose type attribute is in either the Text state or the Search state.
</p>

			</li>
		</ol>
	</li>
	<li>
~RET %~form~data集合
◎
Return the form data set.
</li>
</ol>

<p class="algo-head">
%~form~data集合 に
`~entryを付加する@
ときは、所与の
( %名, %値, %改行は正規化しない~flag ~IN { `改行は正規化しない^i, ε } （省略時は ε ） )
に対し，次を走らす：
◎
To append an entry to form data set, given name, value, and optional prevent line break normalization flag, run these steps:
</p>

<ol>
	<li>
以下において，所与の %文字列 の改行文字を正規化する所では
⇒
%文字列 内の各［
~LF ／ ~CR
］を、それが~CRLFの一部を成さないならば，~CRLFに置換する
⇒
ここで、
~LF は文字 `000A^U LINE FEED ／
~CR は文字 `000D^U CARRIAGE RETURN ／
~CRLFは 2 文字からなる並び［
~CR ~LF
］を表すとする。
◎
↓</li>
	<li>
%名 の改行文字を正規化する
◎
For name, replace every occurrence of U+000D (CR) not followed by U+000A (LF), and every occurrence of U+000A (LF) not preceded by U+000D (CR), by a string consisting of a U+000D (CR) and U+000A (LF).
</li>
	<li>
%名 を`~Unicode~scalar値~列に変換する$
◎
Replace name with the result of converting to a sequence of Unicode scalar values.
</li>
	<li>
<p>
~IF［
%値 は~fileでない
］：
◎
If value is not a file, then:
</p>
		<ol>
			<li>
~IF［
%改行は正規化しない~flag ~EQ ε
］
⇒
%値 の改行文字を正規化する
◎
If the prevent line break normalization flag is unset, then replace every occurrence of U+000D (CR) not followed by U+000A (LF), and every occurrence of U+000A (LF) not preceded by U+000D (CR) in value, by a string consisting of a U+000D (CR) and U+000A (LF).
</li>
			<li>
%値 を`~Unicode~scalar値~列に変換する$
◎
Replace value with the result of converting to a sequence of Unicode scalar values.
</li>
		</ol>
	</li>
	<li>
%~form~data集合 に新たな組( %名, %値 ) を付加する
◎
Create a tuple with name and value, and append it to form data set.
</li>
</ol>

				</section>
				<section id="selecting-a-form-submission-encoding">
<h4 title="Selecting a form submission encoding">4.10.21.5. ~form提出 符号化方式</h4>


<p class="algo-head">
所与の時点における， `form$e 要素 %~form の
`符号化方式@form
は、
`符号化方式から出力~符号化方式を取得する$( 次の手続きを走らせた結果 ) の結果で与えられる：
◎
If the user agent is to pick an encoding for a form, it must run the following steps:
</p>

<div>

<ol>
	<li>
~IF［
%~form は `accept-charset$a 属性を有さない
］
⇒
~RET `文書の符号化方式$
</li>
	<li>
`~ASCII空白で分割する$( %~form の `accept-charset$a 属性の値 )
— その結果を成す~EACH ( ~token ) に対し
⇒
~IF［
`~labelから符号化方式を取得する$( ~token ) の結果 ~NEQ 失敗
］
⇒
~RET その結果
</li>
	<li>
~RET `~UTF-8$
</li>
</ol>

◎
• Let encoding be the document's character encoding.
• If the form element has an accept-charset attribute, set encoding to the return value of running these substeps:
•• Let input be the value of the form element's accept-charset attribute.
•• Let candidate encoding labels be the result of splitting input on ASCII whitespace.
•• Let candidate encodings be an empty list of character encodings.
•• For each token in candidate encoding labels in turn (in the order in which they were found in input), get an encoding for the token and, if this does not result in failure, append the encoding to candidate encodings.
•• If candidate encodings is empty, return UTF-8.
•• Return the first encoding in candidate encodings.
• Return the result of getting an output encoding from encoding.
</div>



				</section>
				<section id="url-encoded-form-data">
<h4 title="URL-encoded form data">4.10.21.6. ~URLに符号化された~form~data</h4>


<p id="application-x-www-form-urlencoded-encoding-algorithm">
<span id="application/x-www-form-urlencoded-encoding-algorithm"></span>

`~form_urlencoded$mt の詳細は
WHATWG URL 標準 `URL$r を見よ。
◎
See the WHATWG URL standard for details on application/x-www-form-urlencoded. [URL]
</p>

				</section>
				<section id="multipart-form-data">
<h4 title="Multipart form data">4.10.21.7. ~multipart~form~data</h4>

<p class="algo-head">
`~mp_form_dataとして符号化する@
ときは、所与の 
( %~form~data集合, %符号化方式 )
に対し，次を走らす：
◎
The multipart/form-data encoding algorithm, given a form data set and encoding, is as follows:
</p>

<ol>
	<li>
<p>
%~form~data集合 内の~EACH( %組 ) に対し：
◎
Let result be the empty string.
◎
For each entry in the form data set:
</p>
		<ol>
			<li>
%組 の［
名, 値
］のそれぞれに対し
⇒
その中の［
%符号化方式 を用いて表せない ~EACH ( %文字 )
］を，次を順に連結した結果の文字列に置換する
⇒＃
文字 `0026^U `&amp;^smb,
文字 `0023^U `#^smb,
%文字 の符号位置を基数 10 で表現する 1 個以上の`~ASCII数字$並び,
文字 `003B^U `;^smb
◎
For each character in the entry's name and value that cannot be expressed using the selected character encoding, replace the character by a string consisting of a U+0026 AMPERSAND character (&amp;), a U+0023 NUMBER SIGN character (#), one or more ASCII digits representing the code point of the character in base ten, and finally a U+003B (;).
</li>
		</ol>
	</li>
	<li>
<p>
~RET ［
`RFC7578$r
<cite>Returning Values from Forms: `~mp_form_data^mt</cite>
に述べられる規則
］を用いて，
<!-- (now mutated) -->
%~form~data集合 を符号化した結果の~byte-stream
— その際には、以下に与える要件に従わ~MUST：
◎
Encode the (now mutated) form data set using the rules described by RFC 7578, Returning Values from Forms: multipart/form-data, and return the resulting byte stream. [RFC7578]
</p>
		<ul>
			<li>
%~form~data集合 内の各 %組 が `field^i を与える。
%組 の ( 名, 値 ) が ( `field name^i, `field value^i ) を与える。
◎
Each entry in the form data set is a field, the name of the entry is the field name and the value of the entry is the field value.
</li>
			<li>
各~部位の順序は、 %~form~data集合 内の %組 の順序と同じにする。
名が同じ 複数の %組 は，別個の~fieldとして扱う。
◎
The order of parts must be the same as the order of fields in the form data set. Multiple entries with the same name must be treated as distinct fields.
</li>
			<li>
<p>
生成する `~mp_form_data$mt 資源を成す各~部位のうち：
</p>
				<ul>
					<li>
~file~field以外の~fieldに対応する部位には、 `Content-Type$h ~headerは指定しない。
それらの名と値は， %符号化方式 を用いて符号化する。
◎
The parts of the generated multipart/form-data resource that correspond to non-file fields must not have a `Content-Type` header specified. Their names and values must be encoded using the character encoding selected above.
</li>
					<li>
~file~fieldに対応する部位に含まれる~file名は、 %符号化方式 を用いて符号化する
— その精確な名前は、必要とされるなら近似してよい（例えば，名~内の［
改行文字は除去する ／
引用符は `%22^l に変更する ／
%符号化方式 では表せない文字は他の文字に置換する
］など）。
◎
File names included in the generated multipart/form-data resource (as part of file fields) must use the character encoding selected above, though the precise name may be approximated if necessary (e.g. newlines could be removed from file names, quotes could be changed to "%22", and characters not expressible in the selected character encoding could be replaced by other characters).
</li>
				</ul>
			</li>
		</ul>
<p>
`~mp_form_data境界~文字列@
とは、~UAが，この~algoが返す値を生成するときに利用する境界~文字列である。
（この値は、この~algoが生成する ~form提出~payloadの~MIME型を生成するときに利用される。）
◎
The boundary used by the user agent in generating the return value of this algorithm is the multipart/form-data boundary string. (This value is used to generate the MIME type of the form submission payload generated by this algorithm.)
</p>

	</li>
</ol>

<p>
`~mp_form_data$mt ~payloadを解釈する方法の詳細は、
`RFC7578$r を見よ。
◎
For details on how to interpret multipart/form-data payloads, see RFC 7578. [RFC7578]
</p>


				</section>
				<section id="plain-text-form-data">
<h4 title="Plain text form data">4.10.21.8. 素の~text~form~data</h4>


<p class="algo-head">
`~text_plainとして符号化する@
ときは、所与の
( %~form~data集合 )
に対し， 次を走らす：
◎
The text/plain encoding algorithm, given a form data set, is as follows:
</p>

<ol>
	<li>
%結果 ~LET 空~文字列
◎
Let result be the empty string.
</li>
	<li>
<p>
%~form~data集合 内の~EACH( %組 ) に対し：
◎
For each entry in the form data set:
</p>
		<ol>
			<li>
~IF［
%組 の値は~fileである
］
⇒
%組 の値 ~SET その~fileの名前
◎
If the entry's value is a file, then set its value to the file's name.
</li>
			<li>
%結果 に次を順に付加する
⇒＃
%組 の名,
文字 `003D^U `=^smb,
%組 の値,
~CRLF
◎
Append the entry's name to result.
◎
Append a single U+003D EQUALS SIGN character (=) to result.
◎
Append the entry's value to result.
◎
Append a U+000D CARRIAGE RETURN (CR) U+000A LINE FEED (LF) character pair to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p>
`~text_plain$mt 形式を利用する~payloadは、人から読まれる用途に意図される。
その形式は多義的なので、~computerからは 依拠-可能に解釈できない（例えば、値~内の~literal改行文字と 値の終端にある改行文字を判別する仕方はない）。
◎
Payloads using the text/plain format are intended to be human readable. They are not reliably interpretable by computer, as the format is ambiguous (for example, there is no way to distinguish a literal newline in a value from the newline at the end of the value).
</p>


				</section>
			</section>
			<section id="resetting-a-form">
<h3 title="Resetting a form">4.10.22. ~formの再設定-法</h3>

<p class="algo-head">
`~formを再設定-@
するときは、所与の `form$e 要素 %~form に対し，次を走らせ~MUST：
◎
When a form element form is reset, run these steps:
</p>

<ol>
	<li>
%reset ~LET %~form に向けて，名前 `reset$et の`~eventを発火する$
— 次のように初期化して
⇒＃
`bubbles$m 属性 ~SET ~T, 
`cancelable$m 属性 ~SET ~T
◎
Let reset be the result of firing an event named reset at form, with the bubbles and cancelable attributes initialized to true.
</li>
	<li>
~IF［
%reset ~EQ ~T
］
⇒
%~form が`所有-$している ~EACH ( `再設定-可能$な %要素 ) に対し
⇒
%要素 の`再設定~algo$を呼出す
◎
If reset is true, then invoke the reset algorithm of each resettable element whose form owner is form.
</li>
</ol>

<p>
各 `再設定-可能$な要素は、自前の
`再設定~algo@
を定義する。
それらの~algoの一部として，~form~controlに加えられた変更は、利用者による変更には数えられない（したがって、例えば `input$et ~eventを発火させることはない）。
◎
Each resettable element defines its own reset algorithm. Changes made to form controls as part of these algorithms do not count as changes caused by the user (and thus, e.g., do not cause input events to fire).
</p>


			</section>

</main>
