<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Form control（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-んア-ン]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
case 'hH':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl': // literal bytes
	text = `\`<code class="literal">${text}</code>\``;
	break;
case 'm':
case 'eI':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U' :
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'X':
	text = `0x${text}`;
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}


if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>



<script type="text/plain" id="_source_data">


●●options

spec_date:2025-07-30
trans_update:2025-07-25
source_checked:250314
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/form-control-infrastructure.html
	abbr_url:HTMLforms
nav_prev:HEinput
nav_next:HEinteractive
trans_1st_pub:2016-09-29


●●class_map
e:element
a:attr
et:event-type
E:error
h:header
st:attr-state
v:value
M:method
U:code-point
cn:cp-name
X:hex-value

●●tag_map
I:code
m:code
eI:code
E:code
c:code
e:code
a:code
M:code
h:code
et:code
st:i
v:code
mt:code
U:span
cn:span
X:span
V:var
i:i
cite:cite

●●original_id_map


	concept-fe-dirty:concept-input-value-dirty-flag
	concept-fe-dirty:concept-textarea-dirty
	form-submission:form-submission-2
	create-an-entry:append-an-entry
	concept-form-submit:submit-user-involvement
	concept-form-submit:submit-subbmitted-from-method

●●mdn_urls
	selectionmode:API/SelectionMode
validitystate:API/ValidityState
formdataevent:API/FormDataEvent
	formdataeventinit:API/FormDataEventInit
	submitevent:API/SubmitEvent
	submiteventinit:API/SubmitEventInit

●●link_map

	●IDL
E.IndexSizeError:~WEBIDL#indexsizeerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotSupportedError:~WEBIDL#notsupportederror
	DOMException:~WEBIDL#idl-DOMException
I.Document:~HTMLdom#document
文書:~HTMLdom#the-document-object
I.SelectionMode:#selectionmode
I.ValidityState:#validitystate
I.HTMLElement:~HTMLdom#htmlelement
I.HTMLInputElement:~HEinput#htmlinputelement
I.File:~FILEAPI#file
	I.File:~FILEAPI#dfn-file
I.Blob:~FILEAPI#blob
	I.Blob:~FILEAPI#dfn-Blob

I.FormData:~XHR#formdata
I.FormDataEvent:#formdataevent
I.FormDataEventInit:#formdataeventinit
I.SubmitEvent:#submitevent
I.SubmitEventInit:#submiteventinit
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.ElementInternals:~HEcustom#elementinternals

m.action:#dom-fs-action
m.badInput:#dom-validitystate-badinput
m.checkValidity:#dom-cva-checkvalidity
m.customError:#dom-validitystate-customerror
m.disabled:#dom-fe-disabled
m.elements:~HEforms#dom-form-elements
m.encoding:#dom-fs-encoding
m.enctype:#dom-fs-enctype
m.form:#dom-fae-form
m.formAction:#dom-fs-formaction
m.formData:#dom-formdataevent-formdata
m.formEnctype:#dom-fs-formenctype
m.formMethod:#dom-fs-formmethod
m.formNoValidate:#dom-fs-formnovalidate
m.formTarget:#dom-fs-formtarget
m.method:#dom-fs-method
m.~nameF:~FILEAPI#dfn-name
m.name:#dom-fe-name
m.noValidate:#dom-fs-novalidate
m.patternMismatch:#dom-validitystate-patternmismatch
m.rangeOverflow:#dom-validitystate-rangeoverflow
m.rangeUnderflow:#dom-validitystate-rangeunderflow
m.reportValidity:#dom-cva-reportvalidity
m.select:#dom-textarea/input-select
m.selectionDirection:#dom-textarea/input-selectiondirection
m.selectionEnd:#dom-textarea/input-selectionend
m.selectionStart:#dom-textarea/input-selectionstart
m.setCustomValidity:#dom-cva-setcustomvalidity
m.setRangeText:#dom-textarea/input-setrangetext
m.setSelectionRange:#dom-textarea/input-setselectionrange
m.stepMismatch:#dom-validitystate-stepmismatch
m.submit:~HEforms#dom-form-submit
m.target:#dom-fs-target
m.tooLong:#dom-validitystate-toolong
m.tooShort:#dom-validitystate-tooshort
m.typeMismatch:#dom-validitystate-typemismatch
m.valid:#dom-validitystate-valid
m.validationMessage:#dom-cva-validationmessage
m.validity:#dom-cva-validity
m.value:~HEforms#dom-textarea-value
m.valueMissing:#dom-validitystate-valuemissing
m.willValidate:#dom-cva-willvalidate

m.submitter:#dom-submitevent-submitter
m.cancelable:~DOM4#dom-event-cancelable
m.bubbles:~DOM4#dom-event-bubbles

m.innerHTML:~HTMLdynamic#dom-element-innerhtml

eI.setValidity:~HEcustom#dom-elementinternals-setvalidity
eI.checkValidity:#dom-elementinternals-checkvalidity
eI.form:#dom-elementinternals-form
eI.reportValidity:#dom-elementinternals-reportvalidity
eI.validity:#dom-elementinternals-validity
eI.willValidate:#dom-elementinternals-willvalidate

l.end:#dom-selectionmode-end
l.preserve:#dom-selectionmode-preserve
l.select:#dom-selectionmode-select
l.start:#dom-selectionmode-start


	●要素／属性／値／状態
e.button:~HEforms#the-button-element
e.datalist:~HEforms#the-datalist-element
e.dialog:~HEinteractive#the-dialog-element
e.fieldset:~HEforms#the-fieldset-element
e.form:~HEforms#the-form-element
e.input:~HEinput#the-input-element
e.legend:~HEforms#the-legend-element
e.option:~HEforms#the-option-element
e.optgroup:~HEforms#the-optgroup-element
e.select:~HEforms#the-select-element
e.textarea:~HEforms#the-textarea-element

et.click:~UIEVENTS#event-type-click
et.formdata:~HTMLindex#event-formdata
et.input:~UIEVENTS#event-type-input
et.invalid:~HTMLindex#event-invalid
et.reset:~HTMLindex#event-reset
et.select:~HTMLindex#event-select
et.submit:~HTMLindex#event-submit

a.accept-charset:~HEforms#attr-form-accept-charset
a.action:#attr-fs-action
a.dirname:#attr-fe-dirname
a.disabled:#attr-fe-disabled
a.~disabled0:~HEforms#attr-fieldset-disabled
a.enctype:#attr-fs-enctype
a.form:#attr-fae-form
a.formaction:#attr-fs-formaction
a.formenctype:#attr-fs-formenctype
a.formmethod:#attr-fs-formmethod
a.formnovalidate:#attr-fs-formnovalidate
a.formtarget:#attr-fs-formtarget
a.hidden:~HTMLinteraction#attr-hidden
a.max:~HEinput#attr-input-max
a.maxlength:#attr-fe-maxlength
a.~maxlengthI:~HEinput#attr-input-maxlength
a.~maxlengthT:~HEforms#attr-textarea-maxlength
a.method:#attr-fs-method
a.min:~HEinput#attr-input-min
a.minlength:#attr-fe-minlength
a.~nameF:~HEforms#attr-form-name
a.~minlengthI:~HEinput#attr-input-minlength
a.~minlengthT:~HEforms#attr-textarea-minlength
a.~multipleI:~HEinput#attr-input-multiple
a.multiple:~HEforms#attr-select-multiple
a.name:#attr-fe-name
a.novalidate:#attr-fs-novalidate
a.pattern:~HEinput#attr-input-pattern
a.~requiredI:~HEinput#attr-input-required
a.~requiredT:~HEforms#attr-textarea-required
a.step:~HEinput#attr-input-step
a.target:#attr-fs-target
a.type:~HEinput#attr-input-type
a.value:~HEinput#attr-input-value


v.dialog:#attr-fs-method-dialog-keyword
v.get:#attr-fs-method-get-keyword
v.post:#attr-fs-method-post-keyword
v._charset_:#attr-fe-name-charset
v.noreferrer:#link-type-noreferrer


v.text/plain:#attr-fs-enctype-text
v.application/x-www-form-urlencoded:#attr-fs-enctype-urlencoded
v.multipart/form-data:#attr-fs-enctype-formdata

mt.application/x-www-form-urlencoded:~URL1#concept-urlencoded
mt.multipart/form-data:~HTMLindex#multipart/form-data
mt.text/plain:~RFCx/rfc2046#section-4.1.3
mt.application/octet-stream:~RFCx/rfc2046#section-4.5.1


st.Checkbox:~HEinput#checkbox-state-(type=checkbox)
st.Date:~HEinput#date-state-(type=date)
st.Email:~HEinput#email-state-(type=email)
st.File:~HEinput#file-upload-state-(type=file)
st.Hidden:~HEinput#hidden-state-(type=hidden)
st.Image:~HEinput#image-button-state-(type=image)
st.Datetime-local:~HEinput#local-date-and-time-state-(type=datetime-local)
st.Month:~HEinput#month-state-(type=month)
st.Number:~HEinput#number-state-(type=number)
st.Password:~HEinput#password-state-(type=password)
st.Radio:~HEinput#radio-button-state-(type=radio)
st.Submit:~HEinput#submit-button-state-(type=submit)
st.Tel:~HEinput#telephone-state-(type=tel)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Time:~HEinput#time-state-(type=time)
st.Url:~HEinput#url-state-(type=url)
st.Week:~HEinput#week-state-(type=week)


st.GET:#attr-fs-method-get
st.POST:#attr-fs-method-post
st.dialog:#attr-fs-method-dialog

M.GET:~HTTPsem#GET
M.POST:~HTTPsem#POST

	●
~offset:#_insertion-offset
~legend:~HEforms#_fieldset-legend
利用者~妥当性:#user-validity
適用される:~HEinput#concept-input-apply
適用されない:~HEinput#do-not-apply
選定された座標:~HEinput#concept-input-type-image-coordinate
選択された~file~list:~HEinput#concept-input-type-file-selected
~radio~button~group:~HEinput#radio-button-group

~formに所有され得る要素:~HEforms#form-associated-element
~listされ:~HEforms#category-listed
再設定-可能:~HEforms#category-reset
提出-可能:~HEforms#category-submit

opt.選択状態:~HEforms#concept-option-selectedness
提出-~button:~HEforms#concept-submit-button
~option_e~list:~HEforms#concept-select-option-list
行l折返ng:~HEforms#textarea-wrapping-transformation
opt.値:~HEforms#concept-option-value
opt.不能化されて:~HEforms#concept-option-disabled
tA.生の値:~HEforms#concept-textarea-raw-value

~dialogを閉じる:~HEinteractive#close-the-dialog


	●form
所有させる:#concept-form-association
~form所有者:#form-owner
所有して:#form-owner
構文解析器が挿入したか:#parser-inserted-flag
fe.値:#concept-fe-value
fe.値~群:#concept-fe-values
fe.省略可能な値:#concept-fe-optional-value
fe.値は~dirtyか:#concept-fe-dirty
fe.~API値:#concept-fe-api-value
fe.~check有りか:#concept-fe-checked
fe.変異-可能:#concept-fe-mutable
fe.不能化されて:#concept-fe-disabled
~form~control~maxlength属性:#attr-fe-maxlength
~form~control~minlength属性:#attr-fe-minlength

既定の~button:#default-button
再設定~algo:#concept-form-reset-control
~formを再設定する:#concept-form-reset
~form所有者を設定し直す:#reset-the-form-owner

関連な値:#concept-textarea/input-relevant-value
~text手入力~cursor位置:#concept-textarea/input-cursor
選択:#concept-textarea/input-selection
選択~方向:#selection-direction
選択~範囲を設定する:#set-the-selection-range
選択~方向を設定する:#set-the-selection-direction
	~text選択:#concept-textarea/input-selection
	~text手入力~cursor:#concept-textarea/input-cursor



	●提出 fs
~formを提出する:#concept-form-submit
	%利用者-関与i:#submit-user-involvement
	submit() ~method:submit-subbmitted-from-method
~form提出:#form-submission
動作:#concept-fs-action
~enctype:#concept-fs-enctype
~method:#concept-fs-method
検証なし状態:#concept-fs-novalidate

~Get動作~URL:#submit-get-action
本体として~Mailする:#submit-mailto-body
~header列を伴う~Mail:#submit-mailto-headers
変異-動作~URL:#submit-mutate-action
~entity本体として提出する:#submit-body

~navigateを計画する:#plan-to-navigate
計画された~navi:#planned-navigation
~entry~listを構築する:#constructing-the-form-data-set
~entry~list構築-中か:#constructing-entry-list
提出~event発火-中か:#firing-submission-events

~entryを作成する:#create-an-entry
~entry~list:#entry-list
fD.~entry~list:~XHR#concept-formdata-entry-list
fD.~entry:#form-entry
fD.名:#form-entry-name
fD.値:#form-entry-value

~form提出用の属性:#attributes-for-form-submission
form.符号化法:#picking-an-encoding-for-the-form

~mp_form_data境界~文字列:#multipart/form-data-boundary-string
~mp_form_dataとして符号化する:#multipart/form-data-encoding-algorithm
~text_plainとして符号化する:#text/plain-encoding-algorithm
名値~pair~listに変換する:#convert-to-a-list-of-name-value-pairs
改行文字を~form~data用に正規化する:#_normalize-newlines-for-form-data

	暗黙的な提出を阻む欄:#field-that-blocks-implicit-submission

	●妥当性
拘束をヤリトリありに検証する:#interactively-validate-the-constraints
拘束を静的に検証する:#statically-validate-the-constraints
拘束~検証の対象外:#barred-from-constraint-validation
拘束~検証の候補:#candidate-for-constraint-validation

~custom妥当性~error~message:#custom-validity-error-message
自身の拘束を満たして:#concept-fv-valid
妥当性~状態:#validity-states
妥当性を検査する:#check-validity-steps
妥当性を報告する:#report-validity-steps

~pattern不一致の難あり:#suffering-from-a-pattern-mismatch
~step不一致の難あり:#suffering-from-a-step-mismatch
型~不一致の難あり:#suffering-from-a-type-mismatch
~overflowの難あり:#suffering-from-an-overflow
~underflowの難あり:#suffering-from-an-underflow
不良~入力の難あり:#suffering-from-bad-input
欠落である難あり:#suffering-from-being-missing
長過ぎる難あり:#suffering-from-being-too-long
短か過ぎる難あり:#suffering-from-being-too-short
~custom~errorの難あり:#suffering-from-a-custom-error

値に許容される最大~長さ:#maximum-allowed-value-length
値に許容される最小~長さ:#minimum-allowed-value-length


	●用語 HTML

~button:~HEforms#concept-button

~DOM操作~task~source:~WAPI#dom-manipulation-task-source
~taskを~queueする:~WAPI#queue-a-task
要素~taskを~queueする:~WAPI#queue-an-element-task

~task~queue:~WAPI#task-queue
~task~source:~WAPI#task-source
~task:~WAPI#concept-task
利用者ヤリトリ~task~source:~WAPI#user-interaction-task-source
~click~eventを発火する:~WAPI#fire-a-click-event

~node~navigable:~HTMLds#node-navigable
nav.作動中な文書:~HTMLds#nav-document
妥当な~navigable~target名または~keyword:~HTMLds#valid-navigable-target-name-or-keyword
~navigableを選ぶ規則:~HTMLds#the-rules-for-choosing-a-navigable
作動中な~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
閲覧~文脈~sandbox化( ~form )~flag:~ORIGIN#sandboxed-forms-browsing-context-flag

~navigableを~URLへ~navigateする:~HTMLnav#navigate
~navigate:~HTMLnav#navigate
hH.auto:~HTMLnav#navigationhistorybehavior-auto
hH.replace:~HTMLnav#navigationhistorybehavior-replace
i.作動化:~HTMLnav#uni-activation

	i.履歴~取扱い:~HTMLnav#navigation-hh
	i.~referrer施策:~HTMLnav#navigation-referrer-policy
	i.文書~資源:~HTMLnav#navigation-resource
	i.~form~data~entry~list:~HTMLnav#navigation-form-data-entry-list
	i.利用者-関与i:~HTMLnav#navigation-user-involvement
~POST資源:~HTMLnav#post-resource
pR.要請~本体:~HTMLnav#post-resource-request-body
pR.要請~内容~型:~HTMLnav#post-resource-request-content-type
~naviに対する利用者-関与i:~HTMLnav#user-navigation-involvement
i.なし:~HTMLnav#uni-none

完全に読込まれ:~HTMLlifecycle#completely-loaded

~formに所有され得る~custom要素:~HEcustom#form-associated-custom-element
iN.~target要素:~HEcustom#internals-target
cF.~entry構築~algo:~HEcustom#face-entry-construction
cF.妥当性~flag群:~HEcustom#_validity-flags
cF.検証~anchor:~HEcustom#face-validation-anchor

~HTML構文解析器:~HTMLparsing#html-parser
構文解析-~error:~HTMLparsing#parse-errors

~navigateできない:~HTMLlinks#cannot-navigate
要素の~noopenerを取得する:~HTMLlinks#get-an-element's-noopener
~link型:~HTMLlinks#linkTypes

i.~ltr:~HTMLdom#concept-ltr
i.~rtl:~HTMLdom#concept-rtl
方向性:~HTMLdom#the-directionality
自動~方向性を伴う~formに所有され得る要素:~HTMLdom#auto-directionality-form-associated-elements

要素の~targetを取得する:~HEmetadata#get-an-element's-target

~focusされて:~HTMLinteraction#focused
~objを~focusする:~HTMLinteraction#focusing-steps

具現化されて:~HTMLrendering#being-rendered

~HTML要素~挿入-時の手続き:~HTMLINFRA#html-element-insertion-steps
	~DOM4#concept-node-insert-ext
~HTML要素~除去-時の手続き:~HTMLINFRA#html-element-removing-steps
	~DOM4#concept-node-remove-ext
~HTML要素~移動-時の手続き:~HTMLINFRA#html-element-moving-steps
	＠~HTMLINFRA#insert-an-element-into-a-document
	＠~HTMLINFRA#remove-an-element-from-a-document
~live:~HTMLINFRA#live
反映する:~HTMLcdom#reflect
既知な値のみに制限され:~HTMLcdom#limited-to-only-known-values

h.Content-Type:~HTMLurl#content-type
妥当かつ空でない~URL（前後~空白~可）:~HTMLurl#valid-non-empty-url-potentially-surrounded-by-spaces
~URLを符号化法の下で相対的に構文解析する:~HTMLurl#encoding-parsing-a-url

真偽-属性:~HTMLcms#boolean-attribute
列挙d属性:~HTMLcms#enumerated-attribute
欠落~値~用の既定の状態:~HTMLcms#missing-value-default
妥当でない値~用の既定の状態:~HTMLcms#invalid-value-default
妥当な負でない整数:~HTMLcms#valid-non-negative-integer
負でない整数として構文解析-:~HTMLcms#rules-for-parsing-non-negative-integers


	●用語（他

符号単位:~INFRA#code-unit
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
改行文字を正規化する:~INFRA#normalize-newlines
長さ:~INFRA#string-length
連結する:~INFRA#string-concatenate
~list:~INFRA#list
付加する:~INFRA#list-append
~listを~cloneする:~INFRA#list-clone
~scalar値~文字列:~INFRA#scalar-value-string
~scalar値~文字列に変換する:~INFRA#javascript-string-convert
同型に符号化する:~INFRA#isomorphic-encode

~ID:~DOM4#concept-id
doc.~URL:~DOM4#concept-document-url
doc.符号化法:~DOM4#concept-document-encoding
接続されて:~DOM4#connected
~node文書:~DOM4#concept-node-document
~tree順序:~DOM4#concept-tree-order
~tree:~DOM4#concept-tree
~eventを発火する:~DOM4#concept-event-fire
作動化の挙動:~DOM4#eventtarget-activation-behavior

文字列を~UTF-8~percent-符号化する:~URL1#string-utf-8-percent-encode
~form_urlencoded直列化器:~URL1#concept-urlencoded-serializer
~path~percent-符号化-集合:~URL1#path-percent-encode-set
	既定の符号化-集合:~URL1#default-encode-set = ~path~percent-符号化-集合
~URL:~URL1#concept-url
url.~query:~URL1#concept-url-query
url.~scheme:~URL1#concept-url-scheme

~UTF-8:~ENCODING#utf-8
符号化法:~ENCODING#encoding
符号化法を利用して符号化する:~ENCODING#encode
~UTF-8符号化する:~ENCODING#utf-8-encode
~labelから符号化法を取得する:~ENCODING#concept-encoding-get
符号化法から出力~符号化法を取得する:~ENCODING#get-an-output-encoding
enc.名前:~ENCODING#name


●●words_table1

disabled0:disabled
maxlengthI:maxlength
maxlengthT:maxlength
minlengthI:minlength
minlengthT:minlength
multipleI:multiple
requiredI:required
requiredT:required
targetB:target
nameF:name
form_urlencoded:<code>application/x-www-form-urlencoded</code> 
mp_form_data:<code>multipart/form-data</code> 
text_plain:<code>text/plain</code> 
option_e:<code class="element">option</code> 

awesomeAt:awesome@example.com
rtlWord1:%D9%85%D8%B1%D8%AD%D8%A8%D8%A7


●●words_table



	●network／url／保安
payload::::ペイロード
percent-::: %-
noopener:
entity:
Get:
Mail:
multipart:
計画-:plan::~
提出元:submitter::~
	multipart:
提出用の:submission::~
	-:submitted from

迂回-:bypass:~
POST:
	%~POST資源:postResource

	●構文／直列化
charset:
連結-:concatenate:~
	連結-:concatenation
	16 進:hexadecimal
	3 桁ごと:thousand


	16 進:hexadecimal

	●状態／妥当性
check::::チェック
	~check有りか:checkedness
overflow::::オーバーフロー
underflow::::アンダーフロー
step:
enctype:
	難あり:suffer from／suffering from
	対象外:barred from
不一致:mismatch::~
未取扱い:unhandled:未取り扱い
	~unhandled-invalid:#5
選択状態:selectedness:~
候補:candidate:~

	そのまま変化しない:remain unchanged
検証なし:no-validate::~
dirty::::
折返ng:wrapping::折り返し
肯定的:positive:~
否定的:negative:~
	合う／合わない:fit
	各~部位:parts
	部位:part


	●UI
legend:
alert:
caret::::キャレット
欄:field::~::フィールド
picker:::選択 UI
color-well:
radio::::ラジオ
scrolling::::スクロール
	連関:interaction
指名-:designate::~
改行:line break:~
書字:writing::~
編集-:edit:~
autofill:
地域化-:localize::~::ローカル化
側:side:~
注目:attention:~
	注目を引かせる:brings 〜 attention
	方向:dir
cue:
保存-:save:~

	●UI 入力
ltr:::左横書き
rtl:::右横書き
右横書き:right-to-left::~
左横書き:left-to-right::~
	ltr／rtl

	-:letter
	Shift ＋:Shift modifier
email::::メール

選択-:select:~
選択:selection:~
	~~始端:beginning
	始端~offset 〜 終端~offset: sequence of characters starting with the character at the 始端th position (in logical order) and ending with the character at the (終端-1)th position

	範囲:size
	途中:in the middle
	留める:snap

埋めら:fillさ:~
埋める:fillする:~
	予め〜埋められ:prefill
	直後:just before
	直前:just after


	Shift ＋:Shift modifier
	低い:low
	高い:high
	16 進:hexadecimal

	●処理
名値:name-value:名-値
切詰める:clampする:切り詰める
識別情報:identity:~
翻訳-:translate:~
合体-:coalesce:~

	変異-能:mutability
	渡-:pass
	保たれ:keepされ
	〜ないよう:prevent

	%C
	%F:-
	%L:-
	%charset:charset
	%form
	%option:option element
	%x:x
	%x名:namex
	%y:y
	%y名:namey
	%~MIME型:mimeType
	%~POST資源:postResource
	%~URL:url
	%~control群:controls
	%~enctype:enctype
	%~entry:entry
	%~entry~list:entry list
	%~file:file
	%~filename:filename
	%~file~list:selected files
	%~form:-
	%~form:form
	%~form~data:form data
	%~form~target:formTarget
	%~form文書:form document
	%~header列:headers
	%~list:list
	%~method:method
	%~noopener:noopener
	%~pair:pair
	%~pair群:pairs
	%~query:-
	%~referrer施策:referrerPolicy
	%~scheme:scheme
	%~subject:subject
	%~target:target
	%~target~navigable:targetNavigable
	%~token
	%値:value
	%再設定するか:reset
	%利用者-関与i:userInvolvement
	%動作~URL:action
	%取消されなかったか:notCanceled
	%名:name
	%報告するか:report
	%境界~文字列:boundary string
	%妥当でない~control群:invalid controls
	%始端:-
	%始端:start
	%履歴~取扱い:historyHandling
	%差分:delta
	%提出元:submitter
	%提出元~button:submitterButton
	%文字列:-
	%新~終端:new end
	%方向:
	%方向:-
	%方向:direction
	%方向~名:dirname
	%未取扱いな妥当でない~control群:unhandled invalid controls
	%本体:body
	%構文解析した動作:parsed action
	%欄:field
	%欄:field
	%状態:-
	%符号化法:encoding
	%終端:-
	%終端:end
	%結果:-
	%結果:result
	%継続するか:shouldContinue
	%要素:-
	%要素:element
	%選択~始端:-
	%選択~始端:selection start
	%選択~終端:-
	%選択~終端:selection end

	●仕様
事実:fact:~
複雑:complicated:~
概略的:brief:~
	旧式:older
	旧:old
	を通して:in terms of

	わけではない:imply
	解釈し直される問題:problematic reinterpretation
	表出できない:not expressible
	対処:work around
	欠いて:lack of
	ではなく:as opposed to
	足りる:suffice
	~~判断:think
	およそ:probably
	伝わって:inform
	可視でない:invisible
	称され:called
	満たす:satisfy
	望み:wishes
	読まれる用途:readable
	次の様:might be something like
	反し:go against
	他所:other parts
	ものと:ought
	申し分ない:fine
	考える:consider
	似た様な:something like
	ない限り，in the absence of
	全く:quite
	担当する:has claimed responsibility
	以前は:previously
	魔法の:magic
	conclude
	examine
	overall
	stood
	follow
	-:causing
	-:loop
	nothing
	overall
	~~有効になる:kick in
	in the face of
	を以って:by means of
	優先される:takes precedence over
	控え目に:sparingly


	●未分類
閉じる:closeする:~
maxlength:
minlength:
	-:variable
差分:delta:~
矢印:arrow:~

	有さない:missing
	映し出:mirror
	数え:count
	~~空に戻す:clear
	数:number
	減る:decrease
	指す:point to
	消える:away
	過ぎて:now past
	^en:clobbering
	directional arrow
	種類:kind
	-:long

	( 名, 値):name-value
	非 file:non-file
	下限:lower bound
	cover
	occurrence
	now:
	+:pair
	-:long
	-:mark
	1 個の:one
	code片:snippet
	directional
	first-in-form
	focusing
	made
	occurrence
	pointing
	previous
	using

	先頭:leading
	一時的:temporary
	後に:subsequently
	finally
	~~最後の:final
	すべて:everything
	対応する:respective
	高い:high
	低い:low
	following
	時点:instant
	最も近い:nearest
	当の:main
	まるごと:altogether
	ほとんどにおいて〜と同じになる:largely mirror

●●html_code_list

■association-of-controls-and-forms-1 bad
...
 <form id="a">
  <div id="b"></div>
 </form>
 <％script>
  document.getElementById('b').innerHTML =
     '<table><tr><td></form><form id="c"><input id="d"></table>' +
     '<input id="e">';
 </％script>
...

■directionality-1
<form action="addcomment.cgi" method=post>
 <p><label>コメント： <input type=text name="comment" ＜dirname="comment.dir"＞ required></label></p>
 <p><button name="mode" type=submit value="add">コメントを投稿する</button></p>
</form>

<form action="addcomment.cgi" method=post>
 <p><label>Comment: <input type=text name="comment" dirname="comment.dir" required></label></p>
 <p><button name="mode" type=submit value="add">Post Comment</button></p>
</form>


■minimum-input-length-1
<form action="/events/menu.cgi" method="post">
 <p><label>競技種目： <input required minlength=5 maxlength=50 name=event></label></p>
 <p><label>朝食を希望される場合は記入してください：
    <textarea name="breakfast" minlength="10"></textarea></label></p>
 <p><label>昼食を希望される場合は記入してください：
    <textarea name="lunch" minlength="10"></textarea></label></p>
 <p><label>夕食を希望される場合は記入してください：
    <textarea name="dinner" minlength="10"></textarea></label></p>
 <p><input type=submit value="request を submit する"></p>
</form>

Name of Event:
Describe what you would like for XXX, if anything:
Submit Request


■method-get-1
<form method="get" action="/search.cgi">
 <p><label>検索語句： <input type=search name=q></label></p>
 <p><input type=submit></p>
</form>

Search terms:

■method-post-1
<form method="post" action="/post-message.cgi">
 <p><label>メッセージ： <input type=text name=m></label></p>
 <p><input type=submit value="提出する"></p>
</form>

Message:
Submit message

■method-dialog-1
<dialog id="ship">
 <form method=dialog>
  <p>船はすでに入港しています。</p>
  <button type=submit value="board">乗船する</button>
  <button type=submit value="call">船長を呼ぶ</button>
 </form>
</dialog>
<％script>
 var %ship = document.getElementById('ship');
 %ship.showModal();
 %ship.onclose = function (%event) {
   if (%ship.returnValue == 'board') {
     // ...
   } else {
     // ...
   }
 };
<％/script>


<p>A ship has arrived in the harbour.</p>
<button type=submit value="board">Board the ship</button>
<button type=submit value="call">Call to the captain</button>


■method-post-2
<form action="editor.cgi" method="post">
 <p><label>名前： <input required name=fn></label></p>
 <p><label>感想： <textarea required name=essay></textarea></label></p>
 <p><input type=submit name=submit value="提出する"></p>
 <p><input type=submit formnovalidate name=save value="＜保存する＞"></p>
 <p><input type=submit formnovalidate name=cancel value="取り消す"></p>
</form>

Name:
Essay:
value="Submit essay"
value="Save essay"
value="Cancel"

■textFieldSelection-1
<textarea id="demo"></textarea>
<％script>
 %demo.value = "A\r\nB";
 %demo.setRangeText("replaced", 0, 2);
 assert(%demo.value === "replacedB");
<％/script>

■form-submission-1
<form action="/find.cgi" method=get>
 <input type=text name=t>
 <input type=search name=q>
 <input type=submit>
</form>


■form-submission-2
<form action="/find.cgi" method=post enctype="multipart/form-data">
 <input type=text name=t>
 <input type=search name=q>
 <input type=submit>
</form>



●●trans_metadata
<p>
~THIS_PAGEは、
~WHATWGによる HTML 仕様の
§ Forms 内の
<a href="~SPEC_URL">§ Form control infrastructure その他の関連する節</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>
</head>
<body>

<header>
	<hgroup>
<h1>HTML — フォームコントロール基盤, 他</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

			<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

◎表記記号

			</section>
			<section id="form-control-infrastructure">
<h4 title="Form control infrastructure">4.10.18. ~form~control基盤</h4>

				<section id="a-form-control's-value">
<h5 title="A form control's value">4.10.18.1. ~form~controlの値</h5>

<p>
ほとんどの~form~controlは、
【文字列をとる】
`値@fe
と【真偽値をとる】
`~check有りか@fe
を有する
（後者を利用するものは `input$e 要素に限られる）。
これらは、
利用者が~controlとヤリトリする方法を述べるために利用される。
◎
Most form controls have a value and a checkedness. (The latter is only used by input elements.) These are used to describe how the user interacts with the control.
</p>

<p>
~controlの`値$feは、
その内部~状態である
— なので、
利用者の現在の入力に合致しないこともある。
◎
A control's value is its internal state. As such, it might not match the user's current input.
</p>

<p class="example">
一例として，
利用者が数字を期待する `Number$st 欄の中に単語 "<kbd>three</kbd>" を手入力した場合、
利用者の入力は文字列 `three^l になるが，
~controlの`値$feは そのまま変化しない。
あるいは，
利用者が `Email$st 欄の中へ~email~address "<kbd>&nbsp;~awesomeAt</kbd>" （先頭に空白が在る）を手入力した場合、
利用者の入力は文字列 `&nbsp;~awesomeAt^l になるが，
~browserの~UIは それを`値$fe `~awesomeAt^l （先頭に空白は無い）に翻訳するであろう。
◎
For instance, if a user enters the word "three" into a numeric field that expects digits, the user's input would be the string "three" but the control's value would remain unchanged. Or, if a user enters the email address " awesome@example.com" (with leading whitespace) into an email field, the user's input would be the string " awesome@example.com" but the browser's UI for email fields might translate that into a value of "awesome@example.com" (without the leading whitespace).
</p>

<p>
各［
`input$e ／ `textarea$e
］要素は、
真偽値をとる
`値は~dirtyか@fe
を有する。
これは、
要素の［
`値$feと既定の値
］との連関を追跡するために利用される
— ~F の下では，要素の`値$feは 既定の値を映し出し、
~T の下では，既定の値は無視される。
◎
input and textarea elements have a dirty value flag. This is used to track the interaction between the value and default value. If it is false, value mirrors the default value. If it is true, the default value is ignored.
</p>

<p>
一部の~form~controlは、
`省略可能な値@fe
も有する。
これは、
ほとんどにおいて`値$feと同じになるが，空~文字列には正規化されない。
◎
Some form controls also have an optional value. This largely mirrors the value but doesn't normalize to an empty string.＼
</p>

<p class="note">注記：
これは、
控え目に利用されるべきである
— 一般には，`値$feの方が求まれる。
◎
This ought to be used sparingly, you generally want value.
</p>

<p>
各［
`input$e ／ `textarea$e ／ `select$e
］要素は、
真偽値をとる
`利用者~妥当性@
を有する
— 初期~時は ~F に設定されるとする。
◎
input, textarea, and select elements have a user validity boolean. It is initially set to false.
</p>

<p>
各 `input$e 要素は，別々に定義される
`値~群@fe
も有する。
それは、
要素の `~multipleI$a 属性に対する 拘束~検証の挙動を定義するためにある。
◎
To define the behavior of constraint validation in the face of the input element's multiple attribute, input elements can also have separately defined values.
</p>

<p>
`値$feを伴うすべての~form~controlは、
`~API値@fe
を得するための~algoも備える。
それは、［
`maxlength$a ／ `minlength$a
］属性の挙動, および `textarea$e 要素に特有な他の~APIを定義するためにある。
既定では、
この~algoは，単純に~controlの`値$feを返す。
◎
To define the behavior of the maxlength and minlength attributes, as well as other APIs specific to the textarea element, all form control with a value also have an algorithm for obtaining an API value. By default this algorithm is to simply return the control's value.
</p>

<p>
`select$e 要素は、
`値$feを有さない
— 代わりに，その `option$e 要素たちの`選択状態$optが利用される。
◎
The select element does not have a value; the selectedness of its option elements is what is used instead.
</p>

				</section>
				<section id="mutability">
<h5 title="Mutability">4.10.18.2. 変異-能</h5>

<p>
~form~controlは
`変異-可能@fe
として指名され得る。
◎
A form control can be designated as mutable.
</p>

<p class="note">注記：
これは，
（要素がそう指名されているかどうかに依拠する，この仕様における定義と要件を以って）、［
利用者が~form~controlの`値$feや`~check有りか$feを改変できるかどうか
］および［
~controlは予め自動的に埋められるかどうか
］を決定する。
◎
This determines (by means of definitions and requirements in this specification that rely on whether an element is so designated) whether or not the user can modify the value or checkedness of a form control, or whether or not a control can be automatically prefilled.
</p>

				</section>
				<section id="association-of-controls-and-forms">
<h5 title="Association of controls and forms">4.10.18.3. ~controlと~formとの結付け</h5>

<p>
各 `~formに所有され得る要素$には、［
要素の
`~form所有者@
と呼ばれる，ある `form$e 要素
］との関係性が与えられ得る。
どの `form$e 要素にも所有されない要素の`~form所有者$は、
~NULL になる。
◎
A form-associated element can have a relationship with a form element, which is called the element's form owner. If a form-associated element is not associated with a form element, its form owner is said to be null.
</p>

<p class="trans-note">【
用語 “~form所有者” は、
要素が `form^e 要素である場合にも利用されている箇所がある
— この場合の`~form所有者$は、
要素~自身を指すと見受けられる。
】【
“所有される”
— 原文では、
単に “結付けられる（ `associated^en ）” であるが、
この訳では
“所有-” ／ “所有され得る”
という語で，その結付けを表すことにする。
例えば， “~form %F が所有する要素” とは、
`~formに所有され得る要素$であって［
その`~form所有者$ ~EQ %F
］なるもの
（または、
それらが成す集合）
を意味する。
】【
同じ要素が同時に複数の `form$e 要素から所有されることはない。
】</p>

<p>
各 `~formに所有され得る要素$には、
真偽値をとる
`構文解析器が挿入したか@
が結付けられる。
【指定されない限り ~F 。】
◎
A form-associated element has an associated parser inserted flag.
</p>

<p>
`~formに所有され得る要素$は、
既定では，それに最も近い先祖 `form$e 要素に所有されるが
（以下で述べられる）、
それらのうち`~listされ$る要素には，これを上書きする
`form@a
属性を指定してもヨイ。
◎
A form-associated element is, by default, associated with its nearest ancestor form element (as described below), but, if it is listed, may have a form attribute specified to override this.
</p>

<p class="note">注記：
この特能により、
入子な `form$e 要素~用の~supportを欠いている下でも，作者は対処できるようになる。
◎
This feature allows authors to work around the lack of support for nested form elements.
</p>

<p>
`~listされ$る要素に指定する `form$a 属性の値は、
要素の`~tree$内にある `form$e 要素の`~ID$でなければナラナイ。
◎
If a listed form-associated element has a form attribute specified, then that attribute's value must be the ID of a form element in the element's tree.
</p>

<p class="note">注記：
この節における規則は、
複雑になっている
— ［
文書／`~tree$
］が適合ならば，入子な `form$e 要素を包含することは決してないが、
そのような入子な要素を有する`~tree$を生成することは，事実として全くアリなので
（例： ~DOM操作を遂行する~scriptを利用して）。
それまた、
`~HTML構文解析器$における規則によっても複雑になっている
— 歴史的な理由から、
`~formに所有され得る要素$が，その先祖でない `form$e 要素に所有されることもあるので。
◎
The rules in this section are complicated by the fact that although conforming documents or trees will never contain nested form elements, it is quite possible (e.g., using a script that performs DOM manipulation) to generate trees that have such nested elements. They are also complicated by rules in the HTML parser that, for historical reasons, can result in a form-associated element being associated with a form element that is not its ancestor.
</p>

<p>
`~formに所有され得る要素$の`~form所有者$は、
要素の作成-時に ~NULL （所有者なし）に初期化するモノトスル。
◎
When a form-associated element is created, its form owner must be initialized to null (no owner).
</p>

<div class="algo">
<p>
所与の~form %~form に，`~formに所有され得る要素$ %要素 を
`所有させる@
~algoは
⇒
%要素 の`~form所有者$ ~SET %~form
◎
When a form-associated element is to be associated with a form, its form owner must be set to that form.
</p>

<p class="trans-note">【
この訳では、
この用語は利用せず，直に
“%要素 の`~form所有者$ ~SET %~form”
と記すことにする。
】</p>
</div>

<p>
`~formに所有され得る要素$ %要素 に対し，次が生じたときは、
~UAは %要素 の`~form所有者を設定し直す$モノトスル：
◎
↓</p>

<ul>
	<li>
%要素 が`~listされ$る要素であって，その `form$a 属性が［
設定- ／ 変更- ／除去-
］されたとき。
◎
When a listed form-associated element's form attribute is set, changed, or removed, then the user agent must reset the form owner of that element.
</li>
	<li>
<p>
%要素 が`~listされ$る要素であって， `form$a 属性を有している下で：
</p>
		<ul>
			<li>
%要素 が属する`~tree$内のある要素の`~ID$が変更されたとき。
</li>
			<li>
<p>
%要素 が［
その`~ID$ ~NEQ ε
］を満たしている下で，次に挙げるいずれかが生じたとき：
</p>
				<ul>
					<li>
%要素 が当の`文書$の`中へ挿入された＠~HTMLINFRA#insert-an-element-into-a-document$
</li>
					<li>
%要素 が当の`文書$`から除去された＠~HTMLINFRA#remove-an-element-from-a-document$
</li>
					<li>
%要素 用の`~HTML要素~移動-時の手続き$が走った
</li>
				</ul>
			</li>
		</ul>
◎
When a listed form-associated element has a form attribute and the ID of any of the elements in the tree changes, then the user agent must reset the form owner of that form-associated element.
◎
When a listed form-associated element has a form attribute and an element with an ID is inserted into or removed from the Document, or its HTML element moving steps are run, then the user agent must reset the form owner of that form-associated element.
</li>
</ul>

<p class="note">注記：
`~form所有者$は、
他にも次により設定し直される
⇒＃
`~HTML要素~挿入-時の手続き$,
`~HTML要素~除去-時の手続き$,
`~HTML要素~移動-時の手続き$
◎
The form owner is also reset by the HTML element insertion steps, HTML element removing steps, and HTML element moving steps.
</p>

<div class="algo">
<p>
`~formに所有され得る要素$ %要素 の
`~form所有者を設定し直す@
~algoは：
◎
To reset the form owner of a form-associated element element:
</p>
<ol>
	<li>
%要素 の`構文解析器が挿入したか$ ~SET ~F
◎
Unset element's parser inserted flag.
</li>
	<li>
<p>
（この段は、
この手続きが~DOMの改変に伴って呼出された場合には，改変した後の時点で適用する。）
</p>
<div class="algo">
<p>
%要素 の`~form所有者$ ~SET 次の手続きを走らせた結果：
</p>
		<ol>
			<li>
<p>
~IF［
~AND↓
］…
</p>
				<ul>
					<li>
%要素 は`接続されて$いる
</li>
					<li>
%要素 は`~listされ$る要素である
</li>
					<li>
%要素 は `form$a 内容~属性を有する
</li>
					<li>
%要素 が属する`~tree$内に次を満たす要素がある
⇒
その`~ID$ ~EQ【！identical】 %要素 の `form$a 内容~属性の値
</li>
					<li>
前項を満たす要素のうち，`~tree順序$で最初のもの %form は `form$e 要素である
</li>
				</ul>
<p>
…ならば
⇒
~RET %form
</p>
			</li>
			<li>
~IF ［
%要素 の先祖に `form$e 要素は在る
］
⇒
~RET それらのうち %要素 に最も近いもの
</li>
			<li>
~RET ~NULL
</li>
		</ol>
</div>
◎
If all of the following are true:
• element's form owner is not null;
• element is not listed or its form content attribute is not present; and
• element's form owner is its nearest form element ancestor after the change to the ancestor chain,
◎
then return.
◎
Set element's form owner to null.
◎
If element is listed, has a form content attribute, and is connected, then:
• If the first element in element's tree, in tree order, to have an ID that is identical to element's form content attribute's value, is a form element, then associate the element with that form element.
◎
Otherwise, if element has an ancestor form element, then associate element with the nearest such ancestor form element.
</li>
</ol>
</div>

<div class="example">
<p>
次の不適合~code片：
◎
In the following non-conforming snippet
</p>

`association-of-controls-and-forms-1^xCode

<p>
"d" の`~form所有者$は，内縁の入子な~form "c" になる一方で、
"e" の`~form所有者$は，外縁の~form "a" になる。
◎
the form owner of "d" would be the inner nested form "c", while the form owner of "e" would be the outer form "a".
</p>

<p>
これは次のようにして起こる：
先ず，~node "e" は、
`~HTML構文解析器$において "c" に結付けられる。
次に，`innerHTML$m ~algoは、
~nodeたちを一時的な文書から要素 "b" へ移動する。
各~nodeは、
この時点で，各自の先祖の連鎖が変更されたことを見る。
したがって、
構文解析器による “魔法の” 結付けすべては、
通常の，先祖への結付けに再設定される。
◎
This happens as follows: First, the "e" node gets associated with "c" in the HTML parser. Then, the innerHTML algorithm moves the nodes from the temporary document to the "b" element. At this point, the nodes see their ancestor chain change, and thus all the "magic" associations done by the parser are reset to normal ancestor associations.
</p>

<p>
もっとも、
この例は不適合な文書である
— そこには、
入子な `form$e 要素による内容~modelの違反があり，また
`&lt;/form&gt;^c ~tagにも`構文解析-~error$がある。
◎
This example is a non-conforming document, though, as it is a violation of the content models to nest form elements, and there is a parse error for the &lt;/form&gt; tag.
</p>
</div>

<dl class="domintro">
	<dt>%element.`form$m</dt>
	<dd>
要素の`~form所有者$（無いならば ~NULL になる）を返す。
◎
Returns the element's form owner.
◎
Returns null if there isn't one.
</dd>
</dl>

<p>
［
`~formに所有され得る要素$のうち，`~listされ$るもの
］の`~form所有者$は、［
要素が`~formに所有され得る~custom要素$である場合は `ElementInternals$I の `form$eI ／
~ELSE_ 要素が実装する各種~interfaceの `form$m
］~IDL属性に公開される：
◎
Listed form-associated elements except for form-associated custom elements have a form IDL attribute,＼
</p>
<ul>
	<li class="algo">
`form@m
取得子~手続きは
⇒
~RET コレの`~form所有者$
◎
which, on getting, must return the element's form owner, or null if there isn't one.
</li>
	<li class="algo">
<p>
`ElementInternals$I の
`form@eI
取得子~手続きは：
◎
Form-associated custom elements don't have form IDL attribute. Instead, their ElementInternals object has a form IDL attribute.＼
On getting, it must＼
</p>
		<ol>
			<li>
%要素 ~LET コレの`~target要素$iN
◎
↓</li>
			<li>
~IF［
%要素 は`~formに所有され得る~custom要素$でない
］
⇒
~THROW `NotSupportedError$E
◎
throw a "NotSupportedError" DOMException if the target element is not a form-associated custom element.＼
</li>
			<li>
~RET %要素 の`~form所有者$
◎
Otherwise, it must return the element's form owner, or null if there isn't one.
</li>
		</ol>
	</li>
</ul>

				</section>
			</section>
			<section id="attributes-common-to-form-controls">
<h4 title="Attributes common to form controls">4.10.19. 各種~form~controlに共通な属性</h4>

				<section id="naming-form-controls:-the-name-attribute">
<h5 title="Naming form controls: the name attribute">4.10.19.1. ~form~controlの命名： `name^a 属性</h5>

<p>
`name@a
内容~属性は、
~form~controlの名前を与える。
それは、
`~form提出$, および
`form$e 要素の `elements$m ~objにて利用される。
この属性の値に［
空~文字列 ／ `isindex^v
］を指定してはナラナイ。
◎
The name content attribute gives the name of the form control, as used in form submission and in the form element's elements object. If the attribute is specified, its value must not be the empty string or isindex.
</p>

<p class="note">注記：
いくつかの~UAは、
歴史的に，［
名前 `isindex^v を伴う “first-in-form” ~text~control
］用に特別な~supportを実装していた。
また，この仕様は、
以前は，そのための関係する~UA要件を定義していた。
しかしながら，一部の~UAは、
後にその特別な~supportを落としたため、
関係する要件は この仕様から除去された。
なので、
旧来の~UAから解釈し直される問題を避けるため、
名前 `isindex^v は，もはや許容されない。
◎
A number of user agents historically implemented special support for first-in-form text controls with the name isindex, and this specification previously defined related user agent requirements for it. However, some user agents subsequently dropped that special support, and the related requirements were removed from this specification. So, to avoid problematic reinterpretations in legacy user agents, the name isindex is no longer allowed.
</p>

<p>
`~nameF$a に対しては［
`isindex^v, 空~文字列
］以外の どの値も許容される。
◎
Other than isindex, any non-empty value for name is allowed.＼
</p>

<p>
［
`value$a 属性を有さない `Hidden$st ~control
］の `name$a 属性~用の~keyword
`_charset_@v
に`~ASCII大小無視$で合致する名前は特別であり，指定された場合、
`value$a 属性に代わって［
~controlを`所有して$いる~formの`符号化法$form
］が，提出-時における~controlの値を自動的に与えるようになる。
◎
An ASCII case-insensitive match for the name _charset_ is special: if used as the name of a Hidden control with no value attribute, then during submission the value attribute is automatically given a value consisting of the submission character encoding.
</p>

<p>
`name@m
~IDL属性は、
`name$a 内容~属性を`反映する$モノトスル。
◎
The name IDL attribute must reflect the name content attribute.
</p>

<div class="note">

<p>注記：
~DOM `clobbering^en 【 “痛める” 】は、
共通的な~security上の課題をもたらす。
`name$a 内容~属性に組込みの~form~propの名前を利用するのは、
避けること。
◎
DOM clobbering is a common cause of security issues. Avoid using the names of built-in form properties with the name content attribute.
</p>

<p>
次の例では、
`input$e 要素は組込みの `method$a ~propを上書きする：
◎
In this example, the input element overrides the built-in method property:
</p>

<pre class="lang-js">
let %form = document.createElement("form");
let %input = document.createElement("input");
%form.appendChild(%input);

%form.method;           // =&gt; "get"
%input.name = "method"; /* <span class="comment">
~DOM `clobbering^en はここで生じる
◎
DOM clobbering occurs here
</span> */
%form.method === %input; // =&gt; true
</pre>

<p>
`input^e の名前は，組込みの~form~propより優先されるので、
`form.method^c による~JS参照は、
組込みの `method$a ~propの代わりに，
`method^l と命名された `input$e 要素を指すことになる。
◎
Since the input name takes precedence over built-in form properties, the JavaScript reference form.method will point to the input element named "method" instead of the built-in method property.
</p>
</div>

				</section>
				<section id="submitting-element-directionality:-the-dirname-attribute">
<h5 title="Submitting element directionality: the dirname attribute">4.10.19.2. 要素~方向性の提出-法： `dirname^a 属性</h5>

<p>
~form~control要素の
`dirname@a
属性は、
要素の`方向性$の提出を可能化し，`~form提出$の際に この値を包含させる名前を与える。
この属性には、
空~文字列を指定してはナラナイ。
◎
The dirname attribute on a form control element enables the submission of the directionality of the element, and gives the name of the control that contains this value during form submission. If such an attribute is specified, its value must not be the empty string.
</p>

<div class="example">
<p>
~text~controlと提出-~buttonを包含する~formの例：
◎
In this example, a form contains a text control and a submission button:
</p>

`directionality-1^xCode

<p>
利用者がこの~formを提出したとき、
~UAは，順に［
"comment", "comment.dir", "mode"
］と称される 3 個の欄を含める。
利用者が "Hello" と手入力していたなら、
その提出~本体は，次の様になるであろう：
◎
When the user submits the form, the user agent includes three fields, one called "comment", one called "comment.dir", and one called "mode"; so if the user types "Hello", the submission body might be something like:
</p>

<pre class="lang-http">
comment=Hello&amp;<mark>comment.dir=ltr</mark>&amp;mode=add
</pre>

<p>
利用者が手動で書字~方向を右横書きに切り替えて，
"<span dir="rtl" lang="ar">مرحبا</span>"
と手入力していたなら、
その提出~本体は，次の様になるであろう：
◎
If the user manually switches to a right-to-left writing direction and enters "مرحبا", the submission body might be something like:
</p>

<pre class="lang-http">
comment=~rtlWord1&amp;<mark>comment.dir=rtl</mark>&amp;mode=add
</pre>
</div>

				</section>
				<section id="limiting-user-input-length:-the-maxlength-attribute">
<h5 title="Limiting user input length: the maxlength attribute">4.10.19.3. 利用者~入力の長さ上限の設定-法： `maxlength^a 属性</h5>

<p>
`~form~control~maxlength属性@
は、
`値は~dirtyか$feにより制御され、
利用者が入力できる文字~数の上限を宣言する。
この文字~数は，`長さ$で測定され、
`textarea$e 要素の事例においては，すべての改行文字は 1 個の文字に正規化される
（ `CRLF^i ~pairではなく）。
◎
A form control maxlength attribute, controlled by the dirty value flag, declares a limit on the number of characters a user can input. The number of characters is measured using length and, in the case of textarea elements, with all newlines normalized to a single character (as opposed to CRLF pairs).
</p>

<p>
要素の`~form~control~maxlength属性$に指定する値は、
`妥当な負でない整数$でなければナラナイ。
要素の
`値に許容される最大~長さ@
は、［［
要素がこの属性を有する
］~AND［
その値を`負でない整数として構文解析-$した結果 ~NEQ `失敗^i
］ならば 結果の数 ／
~ELSE_ ε
］とする。
◎
If an element has its form control maxlength attribute specified, the attribute's value must be a valid non-negative integer. If the attribute is specified and applying the rules for parsing non-negative integers to its value results in a number, then that number is the element's maximum allowed value length. If the attribute is omitted or parsing its value results in an error, then there is no maximum allowed value length.
</p>

<div class="p">
<p><strong>拘束~検証</strong>
⇒
要素が ~AND↓ を満たしている間は、
`長過ぎる難あり$になる：
</p>
<ul>
	<li>
その`値は~dirtyか$fe ~EQ ~T
</li>
	<li>
その`値$feが最後に変更されたのは，利用者の編集-による（~scriptによるものではなく）
</li>
	<li>
その`~API値$feの`長さ$ ~GT その`値に許容される最大~長さ$ ~NEQ ε
</li>
</ul>
◎
Constraint validation: If an element has a maximum allowed value length, its dirty value flag is true, its value was last changed by a user edit (as opposed to a change made by a script), and the length of the element's API value is greater than the element's maximum allowed value length, then the element is suffering from being too long.
</div>

<p>
~UAは、
利用者が，要素の`~API値$feを［
その`長さ$ ~GT 要素の`値に許容される最大~長さ$
］なる値に設定させないようにしてもヨイ。
◎
User agents may prevent the user from causing the element's API value to be set to a value whose length is greater than the element's maximum allowed value length.
</p>

<p class="note">注記：
`textarea$e 要素の事例では、
`~API値$feと`値$feは相違する。
特に、
`値に許容される最大~長さ$が検査される前に，それ用に`改行文字を正規化する$（一方で `行l折返ng$は適用されない）。
◎
In the case of textarea elements, the API value and value differ. In particular, newline normalization is applied before the maximum allowed value length is checked (whereas the textarea wrapping transformation is not applied).
</p>

				</section>
				<section id="setting-minimum-input-length-requirements:-the-minlength-attribute">
<h5 title="Setting minimum input length requirements: the minlength attribute">4.10.19.4. 利用者~入力の長さ下限の設定-法： `minlength^a 属性</h5>

<p>
`~form~control~minlength属性@
は、
`値は~dirtyか$feにより制御され、
利用者が入力できる文字~数の下限を宣言する。
この “文字~数” は，`長さ$で測定され、
`textarea$e 要素の事例においては、
すべての改行文字は 1 個の文字に正規化される
（ `CRLF^i ~pairではなく）。
◎
A form control minlength attribute, controlled by the dirty value flag, declares a lower bound on the number of characters a user can input. The "number of characters" is measured using length and, in the case of textarea elements, with all newlines normalized to a single character (as opposed to CRLF pairs).
</p>

<p class="note">注記：
`minlength$a 属性は `required^a 属性を含意しない。
当の~form~controlが `required^a 属性を有さない場合、
値は依然として省略し得る
— `minlength$a 属性が~~有効になるのは、
利用者が何らかの値を手入力したときに限られる。
作者は、
空~文字列を許容しない場合には， `required^a 属性も設定する必要がある。
◎
The minlength attribute does not imply the required attribute. If the form control has no required attribute, then the value can still be omitted; the minlength attribute only kicks in once the user has entered a value at all. If the empty string is not allowed, then the required attribute also needs to be set.
</p>

<p>
要素の`~form~control~minlength属性$に指定する値は、
`妥当な負でない整数$でなければナラナイ。
要素の
`値に許容される最小~長さ@
は、［［
要素が この属性を有する
］~AND［
その値を`負でない整数として構文解析-$した結果 ~NEQ `失敗^i
］ならば 結果の数 ／
~ELSE_ ε
］とする。
◎
If an element has its form control minlength attribute specified, the attribute's value must be a valid non-negative integer. If the attribute is specified and applying the rules for parsing non-negative integers to its value results in a number, then that number is the element's minimum allowed value length. If the attribute is omitted or parsing its value results in an error, then there is no minimum allowed value length.
</p>

<p>
要素の［
`値に許容される最大~長さ$,
`値に許容される最小~長さ$
］の両者とも ε でない場合、［
`値に許容される最小~長さ$ ~LTE `値に許容される最大~長さ$
］でなければナラナイ。
◎
If an element has both a maximum allowed value length and a minimum allowed value length, the minimum allowed value length must be smaller than or equal to the maximum allowed value length.
</p>

<div class="p">
<p><strong>拘束~検証</strong>
⇒
要素が ~AND↓ を満たしている間は、
`短か過ぎる難あり$になる
</p>
<ul>
	<li>
その`値は~dirtyか$fe ~EQ ~T
</li>
	<li>
その`値$feが最後に変更されたのは，利用者の編集-による（~scriptによるものではなく）
</li>
	<li>
その`値$fe ~NEQ 空~文字列
</li>
	<li>
その`~API値$feの`長さ$ ~LT その`値に許容される最小~長さ$ ~NEQ ε
</li>
</ul>
◎
Constraint validation: If an element has a minimum allowed value length, its dirty value flag is true, its value was last changed by a user edit (as opposed to a change made by a script), its value is not the empty string, and the length of the element's API value is less than the element's minimum allowed value length, then the element is suffering from being too short.
</div>

<div class="example">
<p>
次の例には 4 個の~text~controlがある。
最初のそれは要求される欄であり、
5 文字 以上にする必要がある。
他の 3 個は省略可能であるが、
利用者が埋める場合には， 10 文字~以上を手入力する必要がある。
◎
In this example, there are four text controls. The first is required, and has to be at least 5 characters long. The other three are optional, but if the user fills one in, the user has to enter at least 10 characters.
</p>

`minimum-input-length-1^xCode
</div>

				</section>
				<section id="enabling-and-disabling-form-controls:-the-disabled-attribute">
<h5 title="Enabling and disabling form controls: the disabled attribute">4.10.19.5. ~form~controlの可能化-法と不能化-法： `disabled^a 属性</h5>

<p>
`disabled@a
内容~属性は`真偽-属性$である。
◎
The disabled content attribute is a boolean attribute.
</p>

<p class="note">注記：
`option$e 要素~用の `disabled＠~HEforms#attr-option-disabled$a 属性,
`optgroup$e 要素~用の `disabled＠~HEforms#attr-optgroup-disabled$a 属性は、
別々に定義される。
◎
The disabled attribute for option elements and the disabled attribute for optgroup elements are defined separately.
</p>

<p>
~form~control【を表現する要素】 %要素 が
`不能化されて@fe
いるとは、
~OR↓ を満たすことをいう：
◎
A form control is disabled if any of the following are true:
</p>
<ol>
	<li>
<p>
~AND↓ ：
</p>
		<ul>
			<li>
次に挙げるいずれかの要素である
⇒＃
`button$e ／
`input$e ／
`select$e ／
`textarea$e ／
`~formに所有され得る~custom要素$
</li>
			<li>
`disabled$a 属性を有する
【！(regardless of its value) 真偽-属性なので不要な記述】
</li>
		</ul>
◎
the element is a button, input, select, textarea, or form-associated custom element, and the disabled attribute is specified on this element (regardless of its value); or
</li>
	<li>
<p>
その先祖として，
~AND↓ を満たす `fieldset$e 要素が在る：
</p>
		<ul>
			<li>
`~disabled0$a 属性を有する
</li>
			<li>
その`~legend$は %要素 の先祖でない
</li>
		</ul>
◎
the element is a descendant of a fieldset element whose disabled attribute is specified, and is not a descendant of that fieldset element's first legend element child, if any.
</li>
</ol>

<p>
~form~controlが`不能化されて$feいる間は、
`利用者ヤリトリ~task~source$から`~queueされ＠~WAPI#queue-a-task$た `click$et ~eventは，当の要素へ配送しないモノトスル。
◎
A form control that is disabled must prevent any click events that are queued on the user interaction task source from being dispatched on the element.
</p>

<p class="note">注記：
~form~controlは、
`不能化されて$feいても，
それに対する改変~すべてが防止されるとは限らない。
例えば，その［
`値$fe／`~check有りか$fe
］は、
~JSから~program的に改変されることも，
利用者-動作により間接的に改変されることも
（例：当の~controlは~radio~buttonであって、
それが属する`~radio~button~group$内の他の［
`不能化されて$feいない要素
］が改変された場合）
ある。
◎
Being disabled does not prevent all modifications to the form control. For example, the control's value or checkedness could be modified programmatically from JavaScript. Or, they could be indirectly modified by user action, e.g., if other non-disabled elements in the control's radio button group were modified.
</p>

<p><strong>拘束~検証</strong>
⇒
要素は、
`不能化されて$feいる間は，`拘束~検証の対象外$になる。
◎
Constraint validation: If an element is disabled, it is barred from constraint validation.
</p>

<p>
`disabled@m
~IDL属性は、
`disabled$a 内容~属性を`反映する$モノトスル。
◎
The disabled IDL attribute must reflect the disabled content attribute.
</p>

				</section>
				<section id="form-submission-attributes">
<h5 title="Form submission attributes">4.10.19.6. ~form提出用の属性</h5>

<p>
`~form提出用の属性@
は、
`form$e 要素にも，`提出-~button$†にも指定できる。
（† ~formを提出する~buttonを表現する要素
— 例： `input$e 要素のうち `type$a 属性が `Submit$st 状態にあるもの。）
◎
Attributes for form submission can be specified both on form elements and on submit buttons (elements that represent buttons that submit forms, e.g. an input element whose type attribute is in the Submit Button state).
</p>

<p>
`form$e 要素には、
次に挙げる`~form提出用の属性$が指定されてもヨイ
⇒
`action$a, `enctype$a, `method$a, `novalidate$a, `target$a
◎
The attributes for form submission that may be specified on form elements are action, enctype, method, novalidate, and target.
</p>

<p>
`提出-~button$には、
次に挙げる，対応する`~form提出用の属性$が指定されてもヨイ
⇒
`formaction$a, `formenctype$a, `formmethod$a, `formnovalidate$a, `formtarget$a
— これらの属性の省略-時の既定は、
`form$e 要素に与えられた対応する属性の値になる。
◎
The corresponding attributes for form submission that may be specified on submit buttons are formaction, formenctype, formmethod, formnovalidate, and formtarget. When omitted, they default to the values given on the corresponding attributes on the form element.
</p>

<hr>

<p>
［
`action@a
／
`formaction@a
］内容~属性に指定する値は、
`妥当かつ空でない~URL（前後~空白~可）$でなければナラナイ。
◎
The action and formaction content attributes, if specified, must have a value that is a valid non-empty URL potentially surrounded by spaces.
</p>

<div class="algo">
<p>
%要素 の
`動作@
は、
次に従って決定される：
</p>
<ol>
	<li>
~IF［
%要素 は`提出-~button$である
］~AND［
%要素 は `formaction$a 属性を有する
］
⇒
~RET その属性の値
</li>
	<li>
%要素 ~SET %要素 の`~form所有者$
</li>
	<li>
~IF［
%要素 ~NEQ ~NULL
］~AND［
%要素 は `action$a 属性を有する
］
⇒
~RET その属性の値
</li>
	<li>
~RET 空~文字列
</li>
</ol>

◎
The action of an element is the value of the element's formaction attribute, if the element is a submit button and has such an attribute, or the value of its form owner's action attribute, if it has one, or else the empty string.
</div>

<hr>

<p>
［
`method@a
／
`formmethod@a
］内容~属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The method and formmethod content attributes are enumerated attributes with the following keywords and states:
</p>
<div>
<table><thead>
<tr><th>~keyword
<th>状態
<th>概略的な記述
<tbody>

<tr><td>`get@v
<td>`GET@st
<td>
次を指示する
⇒
当の~formは、
~HTTP `GET$M ~methodを利用することになる。

<tr><td>`post@v
<td>`POST@st
<td>
次を指示する
⇒
当の~formは、
~HTTP `POST$M ~methodを利用することになる。

<tr><td>`dialog@v
<td>`dialog@st
<td>
次を指示する
⇒
当の~formは、
それが見出される `dialog$e ~boxが［
在るならば それを閉じる／
無いならば 提出しない
］ことが意図される。
</table>
◎
Keyword｜State｜Brief description
get｜GET｜Indicates the form will use the HTTP GET method.
post｜POST｜Indicates the form will use the HTTP POST method.
dialog｜Dialog｜Indicates the form is intended to close the dialog box in which the form finds itself, if any, and otherwise not submit.
</div>

<p>
`method$a 属性の［
`欠落~値~用の既定の状態$, `妥当でない値~用の既定の状態$
］は、
いずれも `GET$st とする。
◎
The method attribute's missing value default and invalid value default are both the GET state.
</p>

<p>
`formmethod$a 属性の
⇒＃
`欠落~値~用の既定の状態$は ε とする【この状態は、利用されない（次の段落）】。
`妥当でない値~用の既定の状態$は `GET$st とする。
◎
The formmethod attribute has no missing value default, and its invalid value default is the GET state.
</p>

<p>
要素の
`~method@
は、
上に挙げた いずれかの状態をとる
— それは、［［
要素は`提出-~button$である
］~AND［
要素は `formmethod$a 属性を有する
］ならば その属性の状態 ／
~ELSE_ 要素の`~form所有者$の `method$a 属性の状態
］とする。
◎
The method of an element is one of those states. If the element is a submit button and has a formmethod attribute, then the element's method is that attribute's state; otherwise, it is the form owner's method attribute's state.
</p>

<div class="example">
<p>
`method$a 属性を利用して 既定の値 `get$v を明示的に指定する例
— 探索~queryは、
~URL内に提出されるようになる：
◎
Here the method attribute is used to explicitly specify the default value, "get", so that the search query is submitted in the URL:
</p>

`method-get-1^xCode
</div>

<div class="example">
<p>
他方， `method$a 属性に値 `post$v に指定した場合、
利用者の~messageは，~HTTP要請の本体~内に提出される：
◎
On the other hand, here the method attribute is used to specify the value "post", so that the user's message is submitted in the HTTP request's body:
</p>

`method-post-1^xCode
</div>

<div class="example">
<p>
次の例では、
`form$e は `dialog$e に利用される。
~formが提出されたとき~dialogを自動的に閉じるため、
`method$a 属性には `dialog$v ~keywordが利用されている。
◎
In this example, a form is used with a dialog. The method attribute's "dialog" keyword is used to have the dialog automatically close when the form is submitted.
</p>

`method-dialog-1^xCode
</div>

<hr>

<p>
［
`enctype@a
／
`formenctype@a
］内容~属性は，`列挙d属性$であり、
次に挙げる~keywordが定義される
— それぞれ、
同じ名前の状態に対応付けられる：
◎
The enctype and formenctype content attributes are enumerated attributes with the following keywords and states:
</p>
<ul>
	<li>
`application/x-www-form-urlencoded@v
◎
The "application/x-www-form-urlencoded" keyword and corresponding state.
</li>
	<li>
`multipart/form-data@v
◎
The "multipart/form-data" keyword and corresponding state.
</li>
	<li>
`text/plain@v
◎
The "text/plain" keyword and corresponding state.
</li>
</ul>

<p>
`enctype$a 属性の
⇒＃
`欠落~値~用の既定の状態$は `application/x-www-form-urlencoded$v とする。
`妥当でない値~用の既定の状態$は `application/x-www-form-urlencoded$v とする。
◎
The attribute's missing value default and invalid value default are both the application/x-www-form-urlencoded state.
</p>

<p>
`formenctype$a 属性の
⇒＃
`欠落~値~用の既定の状態$は ε とする【この状態は、利用されない（次の段落）】。／
`妥当でない値~用の既定の状態$は `application/x-www-form-urlencoded$v とする。
◎
The formenctype attribute has no missing value default, and its invalid value default is the application/x-www-form-urlencoded state.
</p>

<p>
要素の
`~enctype@
は、
上に挙げた 3 種の状態いずれかをとり，［
要素は［
`提出-~button$である
］~AND［
`formenctype$a 属性を有する
］ならばその属性の状態 ／
~ELSE_ 要素の`~form所有者$の `enctype$a 属性の状態
］になるとする。
◎
The enctype of an element is one of those three states. If the element is a submit button and has a formenctype attribute, then the element's enctype is that attribute's state; otherwise, it is the form owner's enctype attribute's state.
</p>

<hr>

<p>
［
`target@a
／
`formtarget@a
］内容~属性に指定する値は、
`妥当な~navigable~target名または~keyword$でなければナラナイ。
◎
The target and formtarget content attributes, if specified, must have values that are valid navigable target names or keywords.
</p>

<hr>

<p>
［
`novalidate@a
／
`formnovalidate@a
］内容~属性は`真偽-属性$である。
在る場合、［
~form／要素
］は，提出の間に検証されないことを指示する。
◎
The novalidate and formnovalidate content attributes are boolean attributes. If present, they indicate that the form is not to be validated during submission.
</p>

<div class="p">
<p>
要素の
`検証なし状態@
は、
~IS ~OR↓ になるとする：
</p>
<ul>
	<li>
［
要素は`提出-~button$である
］~AND［
要素は `formnovalidate$a 属性を有する
］
</li>
	<li>
要素の`~form所有者$は［
~NULL でない, かつ `novalidate$a 属性を有する
］
</li>
</ul>

◎
The no-validate state of an element is true if the element is a submit button and the element's formnovalidate attribute is present, or if the element's form owner's novalidate attribute is present, and false otherwise.
</div>

<div class="example">
<p>
この属性は、
検証~拘束を備える~formに “保存-” ~buttonを含ませて，［
利用者が，~form内の~dataを全部的に手入力していない場合でも、
それらの進捗を保存できる
］ようにするときに有用になる。
次の単純な~form例には、
2 個の要求される欄に加えて， 3 個の~button
— ~form提出-用の~button（両~欄とも埋めることが要求される）,
<mark>保存-用の~button</mark>（利用者が後で戻って来て埋められるようにする）,
~formを まるごと取消す~button —
がある：
◎
This attribute is useful to include "save" buttons on forms that have validation constraints, to allow users to save their progress even though they haven't fully entered the data in the form. The following example shows a simple form that has two required fields. There are three buttons: one to submit the form, which requires both fields to be filled in; one to save the form so that the user can come back and fill it in later; and one to cancel the form altogether.
</p>

`method-post-2^xCode
</div>

<hr>

<p>
`action@m
~IDL属性は、
`action$a 内容~属性を`反映する$モノトスル。
ただし，取得子は、
コレが次を満たさないならば，コレの`~node文書$の`~URL$docを返すモノトスル
⇒
`action$a 内容~属性を有していて，その値 ~NEQ 空~文字列
◎
The action IDL attribute must reflect the content attribute of the same name, except that on getting, when the content attribute is missing or its value is the empty string, the element's node document's URL must be returned instead.＼
</p>

<p>
`target@m
~IDL属性は、
`target$a 内容~属性を`反映する$モノトスル。
◎
The target IDL attribute must reflect the content attribute of the same name.＼
</p>

<div>
<p>
`method@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`method$a 内容~属性を`反映する$モノトスル。
</p>

<p>
［
`enctype@m,
`encoding@m
］両~IDL属性とも、
`既知な値のみに制限され$る下で，
`enctype$a 内容~属性を`反映する$モノトスル。
</p>
◎
The method and enctype IDL attributes must reflect the respective content attributes of the same name, limited to only known values.＼
◎
The encoding IDL attribute must reflect the enctype content attribute, limited to only known values.＼
</div>

<p>
`noValidate@m
~IDL属性は、
`novalidate$a 内容~属性を`反映する$モノトスル。
◎
The noValidate IDL attribute must reflect the novalidate content attribute.＼
</p>

<p>
`formAction@m
~IDL属性は、
`formaction$a 内容~属性を`反映する$モノトスル。
ただし，取得子は、
コレが次を満たさないならば，コレの`~node文書$の`~URL$docを返すモノトスル
⇒
`formaction$a 内容~属性を有していて，その値 ~NEQ 空~文字列
◎
The formAction IDL attribute must reflect the formaction content attribute, except that on getting, when the content attribute is missing or its value is the empty string, the element's node document's URL must be returned instead.＼
</p>

<p>
`formEnctype@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`formenctype$a 内容~属性を`反映する$モノトスル。
◎
The formEnctype IDL attribute must reflect the formenctype content attribute, limited to only known values.＼
</p>

<p>
`formMethod@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`formmethod$a 内容~属性を`反映する$モノトスル。
◎
The formMethod IDL attribute must reflect the formmethod content attribute, limited to only known values.＼
</p>

<p>
`formNoValidate@m
~IDL属性は、
`formnovalidate$a 内容~属性を`反映する$モノトスル。
◎
The formNoValidate IDL attribute must reflect the formnovalidate content attribute.＼
</p>

<p>
`formTarget@m
~IDL属性は、
`formtarget$a 内容~属性を`反映する$モノトスル。
◎
The formTarget IDL attribute must reflect the formtarget content attribute.
</p>

				</section>
				<section id="autofill">
<h5 title="Autofill">4.10.19.7. ~autofill</h5>

<p class="trans-note">【
この節の内容は、
`別~page＠~HTMLautofill#autofill$にて。
】</p>

				</section>
			</section>
			<section id="textFieldSelection">
<h4 title="APIs for the text control selections">4.10.20. ~text~control選択~用の~API</h4>

<p>
［
`input$e ／ `textarea$e
］要素は、
それらの選択を取扱うためとして，いくつかの~memberを定義している。
それらは、
ここに定義される~algoを共有する。
◎
The input and textarea elements define several attributes and methods for handling their selection. Their shared algorithms are defined here.
</p>

<p>
この節における
`~offset@
とは、
~text内の，論理-順序による［
始端／終端／隣接する ある 2 個の`符号単位$の狭間
］を指す，負でない整数であり、
`~offset$ 0 は~textの始端を指すとする（したがって，`~offset$［
~textの`長さ$
］は終端を指すことになる）。
</p>

<p class="trans-note">【
この`~offset$の定義は、
簡潔に記すために，この訳に導入している
（原文の “`offset^en” は、
文字列~内の “`符号単位$の~offset” を表していて，記述がまわりくどいので）。
】</p>

<dl class="domintro">

	<dt>%element.`select()$m</dt>
	<dd>
~text~control内のすべてを選択する。
◎
Selects everything in the text control.
</dd>

	<dt>%element.`selectionStart$m [ = %value ]</dt>
	<dd>
選択の始端を指す`~offset$を返す。
◎
Returns the offset to the start of the selection.
</dd>
	<dd>
設定して，選択の始端を変更できる。
◎
Can be set, to change the start of the selection.
</dd>

	<dt>%element.`selectionEnd$m [ = %value ]</dt>
	<dd>
選択の終端を指す`~offset$を返す。
◎
Returns the offset to the end of the selection.
</dd>
	<dd>
設定して，選択の終端を変更できる。
◎
Can be set, to change the end of the selection.
</dd>

	<dt>%element.`selectionDirection$m [ = %value ]</dt>
	<dd>
現在の`選択~方向$を返す。
◎
Returns the current direction of the selection.
</dd>
	<dd>
設定して，現在の`選択~方向$を変更できる。
◎
Can be set, to change the direction of the selection.
</dd>
	<dd>
アリな値は［
`forward^l, `backward^l, `none^l
］のいずれかである。
◎
The possible values are "forward", "backward", and "none".
</dd>

	<dt>%element.`setSelectionRange(start, end [, direction])$m</dt>
	<dd>
選択の［
始端, 終端, 方向
］を［
%start, %end, %direction
］に変更する。
%direction が省略された場合、
方向は~platformの既定のそれ（ `forward^l または `none^l ）に再設定される。
◎
Changes the selection to cover the given substring in the given direction. If the direction is omitted, it will be reset to be the platform default (none or forward).
</dd>

	<dt>%element.`setRangeText(replacement [, start, end [, selectionMode ] ])$m</dt>
	<dd>
~textのある範囲を，新たな~textに置換する。
%start, %end 引数が供されない場合の範囲は、
選択~全体と見做される。
◎
Replaces a range of text with the new text. If the start and end arguments are not provided, the range is assumed to be the selection.
</dd>
	<dd>
<p>
~~最後の引数は、
~textが置換された後に，選択が どう設定されることになるかを決定する。
アリな値は：
◎
The final argument determines how the selection will be set after the text has been replaced. The possible values are:
</p>

		<dl>
			<dt>`select$l</dt>
			<dd>
新たに挿入された~textを選択する。
◎
Selects the newly inserted text.
</dd>

			<dt>`start$l</dt>
			<dd>
選択の始端, 終端ともに 挿入された~textの直前に移動する。
◎
Moves the selection to just before the inserted text.
</dd>

			<dt>`end$l</dt>
			<dd>
選択の始端, 終端ともに 挿入された~textの直後に移動する。
◎
Moves the selection to just after the selected text.
</dd>

			<dt>`preserve$l</dt>
			<dd>
選択をなるべく保全しようと試みる。
これが既定。
◎
Attempts to preserve the selection. This is the default.
</dd>
		</dl>
	</dd>
</dl>

<p>
［
これらの~APIが`適用される$すべての `input$e 要素, および `textarea$e 要素
］は、
どの時点でも（要素が`具現化されて$いなくとも），［
`選択@,
`~text手入力~cursor位置@
］のどちらかは有するとする
— これらは、
~controlに`関連な値$における`~offset$で測定される。
初期~状態では、
~controlの始端を指す~text手入力~cursor位置を有するモノトスル。
◎
All input elements to which these APIs apply, and all textarea elements, have either a selection or a text entry cursor position at all times (even for elements that are not being rendered), measured in offsets into the code units of the control's relevant value. The initial state must consist of a text entry cursor at the beginning of the control.
</p>

<p class="trans-note">【
~text手入力~cursor位置は，実質的には “始端と終端が一致する空な選択” と同じに見受けられる（ “空な選択” と “選択なし” を区別するための用語かもしれないが、
そのような区別が有意になる箇所は見当たらない）。
】</p>

<p>
これらの~APIは、［
`input$e 要素に対しては その`値$fe ／
`textarea$e 要素に対しては その`~API値$fe
］に対し演算するモノトスル。
この，演算される値~文字列は、
以下に与える~algoにおいては，当の要素に
`関連な値@
と総称される。
◎
For input elements, these APIs must operate on the element's value. For textarea elements, these APIs must operate on the element's API value. In the below algorithms, we call the value string being operated on the relevant value.
</p>

<div class="example">
<p>
`textarea$e 要素~用に`生の値$tAに代えて`~API値$feを利用することは、
文字 `000D^U `CR^cn が正規化されて消えることを意味する。
例えば：
◎
The use of API value instead of raw value for textarea elements means that U+000D (CR) characters are normalized away. For example,
</p>

`textFieldSelection-1^xCode

<p>
`生の値$tA `A\r\nB^l に演算した場合、
文字~並び `A\r^l が置換される結果 `replaced\nB^l になるが、
`~API値$fe `A\nB^l を利用するので，文字~並び `A\n^l が置換される結果 `replacedB^l になる。
◎
If we had operated on the raw value of "A\r\nB", then we would have replaced the characters "A\r", ending up with a result of "replaced\nB". But since we used the API value of "A\nB", we replaced the characters "A\n", giving "replacedB".
</p>
</div>

<p>
文字 `200D^U ZERO WIDTH JOINER
などの可視でない文字であっても，文字として数えられる。
したがって，一例として、
選択は 可視でない文字のみを含むこともあり，~text挿入~cursorは そのような文字の前後いずれかの側に配置され得る。
◎
Characters with no visible rendering, such as U+200D ZERO WIDTH JOINER, still count as characters. Thus, for instance, the selection can include just an invisible character, and the text insertion cursor can be placed to one side or another of such a character.
</p>

<div class="algo">
<p>
これらの~APIが適用される要素に対し，`関連な値$が変化したときは、
次を走らすとする：
◎
Whenever the relevant value changes for an element to which these APIs apply, run these steps:
</p>
<ol>
	<li>
<p>
~IF［
要素は`選択$を有する
］：
◎
If the element has a selection:
</p>
		<ol>
			<li>
~IF［
選択の始端は `関連な値$の終端を過ぎている<!-- 始端？ -->
］
⇒
選択の始端 ~SET `関連な値$の終端
◎
If the start of the selection is now past the end of the relevant value, set it to the end of the relevant value.
</li>
			<li>
~IF［
選択の終端は `関連な値$の終端を過ぎている
］
⇒
選択の終端 ~SET `関連な値$の終端
◎
If the end of the selection is now past the end of the relevant value, set it to the end of the relevant value.
</li>
			<li>
~IF［
~UAは空な選択を~supportしない
］~AND［
選択の始端, 終端とも`関連な値$の終端を指している
］
⇒
選択を除去した上で，要素の`~text手入力~cursor位置$ ~SET `関連な値$の終端
◎
If the user agent does not support empty selection, and both the start and end of the selection are now pointing to the end of the relevant value, then instead set the element's text entry cursor position to the end of the relevant value, removing any selection.
</li>
		</ol>
	</li>
	<li>
~ELSE（ 要素は`~text手入力~cursor位置$を有する）
⇒
~IF［
`~text手入力~cursor位置$は `関連な値$の終端を過ぎている
］
⇒
`~text手入力~cursor位置$ ~SET `関連な値$の終端
◎
Otherwise, the element must have a text entry cursor position position. If it is now past the end of the relevant value, set it to the end of the relevant value.
</li>
</ol>

<p class="note">注記：
上で切詰める手続きのみならず，この仕様の他所にも、
`関連な値$が変化するときに，`~text手入力~cursor位置$を改変する事例がある。
例えば `textarea$e 用の `value$m 設定子など。
◎
In some cases where the relevant value changes, other parts of the specification will also modify the text entry cursor position, beyond just the clamping steps above. For example, see the value setter for textarea.
</p>
</div>

<p>
［
`input$e ／ `textarea$e
］要素において~text`選択$を変更するような~UI特能は、
アリな所では，`選択~範囲を設定する$~algoを利用して実装するモノトスル
— 例：すべてに同じ~eventが発火されるよう。
◎
Where possible, user interface features for changing the text selection in input and textarea elements must be implemented using the set the selection range algorithm so that, e.g., all the same events fire.
</p>

<p>
各［
`input$e ／ `textarea$e
］要素の`選択$は、
次のいずれかを値にとる
`選択~方向@
を有する
⇒＃
`forward^l,
`backward^l,
`none^l
◎
The selections of input and textarea elements have a selection direction, which is either "forward", "backward", or "none".＼
</p>

<p>
選択~方向の正確な意味は~platformに依存する。
この方向は、
利用者が選択を操作するときに設定される。
`選択~方向$は、
初期~時は［
当の~platformが~supportするならば `none^l ／
~ELSE_ `forward^l
］にするモノトスル。
◎
The exact meaning of the selection direction depends on the platform. This direction is set when the user manipulates the selection. The initial selection direction must be "none" if the platform supports that direction, or "forward" otherwise.
</p>

<div class="algo">
<p>
`選択~方向を設定する@
~algoは、
所与の
( %要素, %方向 )
に対し
⇒
要素の`選択~方向$ ~SET ［
次が満たされるならば `forward^l ／
~ELSE_ %方向
］
⇒
［
%方向 ~EQ `none^l
］~AND［
~platformは %方向 を~supportしない
］
◎
To set the selection direction of an element to a given direction, update the element's selection direction to the given direction, unless the direction is "none" and the platform does not support that direction; in that case, update the element's selection direction to "forward".
</p>
</div>

<div class="note">
<p>注記：
Windows 上では、
この選択~方向は、
選択に相対的な~caret位置を指示する：
~caretは、
方向に応じて［
`forward^l ならば選択の終端 ／
`backward^l ならば選択の始端
］にある。
Windows に `none^l 方向はない。
◎
On Windows, the direction indicates the position of the caret relative to the selection: a "forward" selection has the caret at the end of the selection and a "backward" selection has the caret at the start of the selection. Windows has no "none" direction.
</p>

<p>
Mac では、
方向は，利用者が
Shift ＋ 矢印~UIkeyを利用して，選択~範囲を調整するときに 選択のどちらの端が影響されるかを指示する：
改変される端は、
方向に応じて［
`forward^l ならば選択の終端 ／
`backward^l ならば選択の始端
］になる。
Mac では、
`none^l 方向が既定であり，特定0の方向はまだ選択されてないことを指示する。
方向は、
利用者が選択を最初に調整するときに，どっちの矢印~UIkeyが利用されたかに基づいて暗黙的に設定される。
◎
On Mac, the direction indicates which end of the selection is affected when the user adjusts the size of the selection using the arrow keys with the Shift modifier: the "forward" direction means the end of the selection is modified, and the "backward" direction means the start of the selection is modified. The "none" direction is the default on Mac, it indicates that no particular direction has yet been selected. The user sets the direction implicitly when first adjusting the selection, based on which directional arrow key was used.
</p>
</div>

<div class="algo">
<p>
`select()@m
~method~手続きは：
◎
The select() method, when invoked, must run the following steps:
</p>
<ol>
	<li>
<p>
~IF［
コレは `input$e 要素である
］~AND［［
この~methodはコレに`適用されない$
］~OR［
コレに対応する~controlには選択-可能な~textはない
］］
⇒
~RET
◎
If this element is an input element, and either select() does not apply to this element or the corresponding control has no selectable text, return.
</p>

<p class="example">
一例として、
`&lt;input type=color&gt;＠~HEinput#color-state-(type=color)$e
を［
16 進~色~codeを受容する~text~control
］ではなく［
色~pickerを擁する~color-well
］として具現化する~UAにおいては、
選択-可能な~textは無いので，この~methodの~callは無視される。
◎
For instance, in a user agent where &lt;input type=color&gt; is rendered as a color well with a picker, as opposed to a text control accepting a hexadecimal color code, there would be no selectable text, and thus calls to the method are ignored.
</p>
	</li>
	<li>
`選択~範囲を設定する$( コレ, 0, `無限大^i )
◎
Set the selection range with 0 and infinity.
</li>
</ol>
</div>

<div class="algo">
<p>
`selectionStart@m
取得子~手続きは：
◎
The selectionStart attribute's getter must run the following steps:
</p>
<ol>
	<li>
~IF［
コレは `input$e 要素である
］~AND［
この~methodはコレに`適用されない$
］
⇒
~RET ~NULL
◎
If this element is an input element, and selectionStart does not apply to this element, return null.
</li>
	<li>
~IF［
コレは`選択$を有さない
］
⇒
~RET コレに`関連な値$の中で`~text手入力~cursor位置$を指す`~offset$
◎
If there is no selection, return the code unit offset within the relevant value to the character that immediately follows the text entry cursor.
</li>
	<li>
~RET コレに`関連な値$の中で`選択$の始端を指す`~offset$
◎
Return the code unit offset within the relevant value to the character that immediately follows the start of the selection.
</li>
</ol>
</div>

<div class="algo">
<p>
`selectionStart$m
設定子~手続きは：
◎
The selectionStart attribute's setter must run the following steps:
</p>
<ol>
	<li>
~IF［
コレは `input$e 要素である
］~AND［
この~methodはコレに`適用されない$
］
⇒
~THROW `InvalidStateError$E
◎
If this element is an input element, and selectionStart does not apply to this element, throw an "InvalidStateError" DOMException.
</li>
	<li>
%終端 ~LET コレ上の `selectionEnd$m 取得子~手続き()
◎
Let end be the value of this element's selectionEnd attribute.
</li>
	<li>
~IF［
%終端 ~LT 所与の値
］
⇒
%終端 ~SET 所与の値
◎
If end is less than the given value, set end to the given value.
</li>
	<li>
%方向 ~LET コレ上の `selectionDirection$m 取得子~手続き()
◎
↓</li>
	<li>
`選択~範囲を設定する$( コレ, 所与の値, %終端, %方向 )
◎
Set the selection range with the given value, end, and the value of this element's selectionDirection attribute.
</li>
</ol>
</div>

<div class="algo">
<p>
`selectionEnd@m
取得子~手続きは：
◎
The selectionEnd attribute's getter must run the following steps:
</p>
<ol>
	<li>
~IF［
コレは `input$e 要素である
］~AND［
この~methodはコレに`適用されない$
］
⇒
~RET ~NULL
◎
If this element is an input element, and selectionEnd does not apply to this element, return null.
</li>
	<li>
~IF［
コレは`選択$を有さない
］
⇒
~RET コレに`関連な値$の中で`~text手入力~cursor位置$を指す`~offset$
◎
If there is no selection, return the code unit offset within the relevant value to the character that immediately follows the text entry cursor.
</li>
	<li>
~RET コレに`関連な値$の中で`選択$の終端を指す`~offset$
◎
Return the code unit offset within the relevant value to the character that immediately follows the end of the selection.
</li>
</ol>
</div>

<div class="algo">
<p>
`selectionEnd$m
設定子~手続きは：
◎
The selectionEnd attribute's setter must run the following steps:
</p>
<ol>
	<li>
~IF［
コレは `input$e 要素である
］~AND［
この~methodはコレに`適用されない$
］
⇒
~THROW `InvalidStateError$E
◎
If this element is an input element, and selectionEnd does not apply to this element, throw an "InvalidStateError" DOMException.
</li>
	<li>
%始端 ~LET コレ上の `selectionStart$m 取得子~手続き()
◎
↓</li>
	<li>
%方向 ~LET コレ上の `selectionDirection$m 取得子~手続き()
◎
↓</li>
	<li>
`選択~範囲を設定する$( コレ, %始端, 所与の値, %方向 )
◎
Set the selection range with the value of this element's selectionStart attribute, the given value, and the value of this element's selectionDirection attribute.
</li>
</ol>
</div>

<div class="algo">
<p>
`selectionDirection@m
取得子~手続きは：
◎
The selectionDirection attribute's getter must run the following steps:
</p>
<ol>
	<li>
~IF［
コレは `input$e 要素である
］~AND［
この~methodはコレに`適用されない$
］
⇒
~RET ~NULL
◎
If this element is an input element, and selectionDirection does not apply to this element, return null.
</li>
	<li>
~RET コレの`選択~方向$
◎
Return this element's selection direction.
</li>
</ol>
</div>

<div class="algo">
<p>
`selectionDirection$m
設定子~手続きは：
◎
The selectionDirection attribute's setter must run the following steps:
</p>
<ol>
	<li>
~IF［
コレは `input$e 要素である
］~AND［
この~methodはコレに`適用されない$
］
⇒
~THROW `InvalidStateError$E
◎
If this element is an input element, and selectionDirection does not apply to this element, throw an "InvalidStateError" DOMException.
</li>
	<li>
%始端 ~LET コレ上の `selectionStart$m 取得子~手続き()
◎
↓</li>
	<li>
%終端 ~LET コレ上の `selectionEnd$m 取得子~手続き()
◎
↓</li>
	<li>
`選択~範囲を設定する$( コレ, %始端, %終端, 所与の値 )
◎
Set the selection range with the value of this element's selectionStart attribute, the value of this element's selectionEnd attribute, and the given value.
</li>
</ol>
</div>

<div class="algo">
<p>
`setSelectionRange(start, end, direction)@m
~method~手続きは：
◎
The setSelectionRange(start, end, direction) method, when invoked, must run the following steps:
</p>
<ol>
	<li>
~IF［
コレは `input$e 要素である
］~AND［
この~methodはコレに`適用されない$
］
⇒
~THROW `InvalidStateError$E
◎
If this element is an input element, and setSelectionRange() does not apply to this element, throw an "InvalidStateError" DOMException.
</li>
	<li>
`選択~範囲を設定する$( コレ, %start, %end, %direction )
◎
Set the selection range with start, end, and direction.
</li>
</ol>
</div>

<div class="algo">
<p>
`選択~範囲を設定する@
~algoは、
所与の
⇒＃
~text~control【を表現する要素】 %要素,
［ 負でない整数／ ~NULL ］ %始端,
［ 負でない整数／ ~NULL ／ `無限大^i ］ %終端,
文字列 %方向 ~DF ε
◎終
に対し
— 以下においては、
値 `無限大^i は他のどの値よりも大きいとする：
◎
To set the selection range with an integer or null start, an integer or null or the special value infinity end, and optionally a string direction, run the following steps:
</p>
<ol>
	<li>
~IF［
%始端 ~EQ ~NULL
］
⇒
%始端 ~SET 0
◎
If start is null, let start be 0.
</li>
	<li>
~IF［
%終端 ~EQ ~NULL
］
⇒
%終端 ~LET 0
◎
If end is null, let end be 0.
</li>
	<li>
%L ~LET %要素 に`関連な値$の`長さ$
◎
↓</li>
	<li>
%終端 ~LET { %終端, %L } の最小
◎
↓</li>
	<li>
%始端 ~LET { %始端, %L, %終端 } の最小
◎
↓</li>
	<li>
%要素 に`関連な値$の中で，`選択$の範囲を［
%始端 `~offset$ 〜 %終端 `~offset$
］に設定する
— 範囲が空になる場合、
空~選択の概念がない~UAにおいては，~cursorを %終端 `~offset$に設定する
◎
Set the selection of the text control to the sequence of code units within the relevant value starting with the code unit at the startth position (in logical order) and ending with the code unit at the (end-1)th position. Arguments greater than the length of the relevant value of the text control (including the special value infinity) must be treated as pointing at the end of the text control. If end is less than or equal to start, then the start of the selection and the end of the selection must both be placed immediately before the character with offset end. In UAs where there is no concept of an empty selection, this must set the cursor to be just before the character with offset end.
</li>
	<li>
~IF［
%方向 ~NIN【！identical】 { `backward^l, `forward^l }
］~OR［
%方向 ~EQ ε
］
⇒
%方向 ~SET `none^l
◎
If direction is not identical to either "backward" or "forward", or if the direction argument was not given, set direction to "none".
</li>
	<li>
`選択~方向を設定する$( %要素, %方向 )
◎
Set the selection direction of the text control to direction.
</li>
	<li>
<p>
~IF［
前~段までにより，~text~controlの`選択$は改変された（その範囲, `選択~方向$いずれにせよ）
］
⇒
`要素~taskを~queueする$( `利用者ヤリトリ~task~source$, %要素, 次の手続き )
◎
If the previous steps caused the selection of the text control to be modified (in either extent or direction), then queue an element task on the user interaction task source given the element to＼
</p>

<div class="algo">
手続きは
⇒
`~eventを発火する$( %要素, `select$et )
— 次のように初期化して
⇒
`bubbles$m 属性 ~SET ~T
◎
fire an event named select at the element, with the bubbles attribute initialized to true.
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
`setRangeText(replacement, start, end, selectionMode)@m
~method~手続きは：
◎
The setRangeText(replacement, start, end, selectMode) method, when invoked, must run the following steps:
</p>
<ol>
	<li>
~IF［
コレは `input$e 要素である
］~AND［
この~methodはコレに`適用されない$
］
⇒
~THROW `InvalidStateError$E
◎
If this element is an input element, and setRangeText() does not apply to this element, throw an "InvalidStateError" DOMException.
</li>
	<li>
コレの`値は~dirtyか$fe ~SET ~T
◎
Set this element's dirty value flag to true.
</li>
	<li>
%選択~始端 ~LET コレ上の `selectionStart$m 取得子~手続き()
◎
↓</li>
	<li>
%選択~終端 ~LET コレ上の `selectionEnd$m 取得子~手続き()
◎
↓</li>
	<li>
~IF［
%start 以降の引数は与えられていない
］
⇒＃
( %start, %end ) ~SET ( %選択~始端, %選択~終端 )；
%selectionMode ~SET `preserve$l
◎
If the method has only one argument, then let start and end have the values of the selectionStart attribute and the selectionEnd attribute respectively.
◎
Otherwise, let start, end have the values of the second and third arguments respectively.
◎
↓↓
</li>
	<li>
~IF［
%start ~GT %end
］
⇒
~THROW `IndexSizeError$E
◎
If start is greater than end, then throw an "IndexSizeError" DOMException.
</li>
	<li>
%L ~LET コレに`関連な値$の長さ
◎
↓</li>
	<li>
%始端 ~SET { %start, %L } の最小
◎
If start is greater than the length of the relevant value of the text control, then set it to the length of the relevant value of the text control.
</li>
	<li>
%終端 ~SET { %end, %L } の最小
◎
If end is greater than the length of the relevant value of the text control, then set it to the length of the relevant value of the text control.
◎
↑↑Let selection start be the current value of the selectionStart attribute.
◎
↑↑Let selection end be the current value of the selectionEnd attribute.
</li>
	<li>
~IF［
%始端 ~LT %終端
］
⇒
コレに`関連な値$から範囲［
%始端 `~offset$ 〜 %終端 `~offset$
］にある`符号単位$を削除する
◎
If start is less than end, delete the sequence of code units within the element's relevant value starting with the code unit at the startth position and ending with the code unit at the (end-1)th position.
</li>
	<li>
コレに`関連な値$の %始端 `~offset$に %replacement の値を挿入する
◎
Insert the value of the first argument into the text of the relevant value of the text control, immediately before the startth code unit.
</li>
	<li>
%新~終端 ~LET %始端 + ( %replacement の`長さ$ )
◎
Let new length be the length of the value of the first argument.
◎
Let new end be the sum of start and new length.
</li>
	<li>
<p>
%selectionMode に応じて：
◎
Run the appropriate set of substeps from the following list:
</p>
		<dl class="switch">
			<dt>`select@l
◎
If the fourth argument's value is "select"
</dt>
			<dd>
( %選択~始端, %選択~終端 ) ~SET ( %始端, %新~終端 )
◎
Let selection start be start.
◎
Let selection end be new end.
</dd>

			<dt>`start@l
◎
If the fourth argument's value is "start"
</dt>
			<dd>
( %選択~始端, %選択~終端 ) ~SET ( %始端, %始端 )
◎
Let selection start and selection end be start.
</dd>

			<dt>`end@l
◎
If the fourth argument's value is "end"
</dt>
			<dd>
( %選択~始端, %選択~終端 ) ~SET ( %新~終端, %新~終端 )
◎
Let selection start and selection end be new end.
</dd>

			<dt>`preserve@l
◎
If the fourth argument's value is "preserve"
◎
↑↑If the method has only one argument
</dt>

			<dd>
				<ol>
					<li>
%差分 ~LET ( %replacement の長さ ) − ( %終端 − %始端 )
◎
Let old length be end minus start.
◎
Let delta be new length minus old length.
</li>
					<li>
~IF［
%選択~始端 ~GT %終端
］
⇒
%選択~始端 ~INCBY %差分
（ %差分 が負である場合，すなわち 新たな~textが置換された~textより短い場合、
%選択~始端 の値は<em>減る</em>ことになる）
◎
If selection start is greater than end, then increment it by delta. (If delta is negative, i.e. the new text is shorter than the old text, then this will decrease the value of selection start.)
</li>
					<li>
~ELIF［
%選択~始端 ~GT %始端
］
⇒
%選択~始端 ~SET %始端
（ %選択~始端 が置換された~textの途中にあった場合，選択の始端は新たな~textの始端に留められる）
◎
Otherwise: if selection start is greater than start, then set it to start. (This snaps the start of the selection to the start of the new text if it was in the middle of the text that it replaced.)
</li>
					<li>
~IF［
%選択~終端 ~GT %終端
］
⇒
%選択~終端 ~INCBY %差分
◎
If selection end is greater than end, then increment it by delta in the same way.
</li>
					<li>
~ELIF［
%選択~終端 ~GT %始端
］
⇒
%選択~終端 ~SET %新~終端
（ %選択~終端 が置換された~textの途中にあった場合，選択の始端は新たな~textの終端に留められる）
◎
Otherwise: if selection end is greater than start, then set it to new end. (This snaps the end of the selection to the end of the new text if it was in the middle of the text that it replaced.)
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
`選択~範囲を設定する$( コレ, %選択~始端, %選択~終端 )
◎
Set the selection range with selection start and selection end.
</li>
</ol>
</div>

<p>
`setRangeText()$m
~methodは、
次の列挙を利用する：
◎
The setRangeText() method uses the following enumeration:
</p>

<pre class="idl">
enum `SelectionMode@I {
  `select$l,
  `start$l,
  `end$l,
  `preserve$l // <span class="comment">既定</span>
};
</pre>

<hr>

<div class="example">
<p>
現在~選択されている~textを得するには、
次の~JSで足りる：
◎
To obtain the currently selected text, the following JavaScript suffices:
</p>

<pre class="lang-js">
var %selectionText = %control.value.substring(%control.selectionStart, %control.selectionEnd);
</pre>

<p>
（ %control は［
`input$e ／ `textarea$e
］要素とする。）
◎
...where control is the input or textarea element.
</p>
</div>

<div class="example">
<p>
3 つの属性を保全して，~text選択は保守しながら、
~text~controlの始端に~textを追加する例：
◎
To add some text at the start of a text control, while maintaining the text selection, the three attributes must be preserved:
</p>

<pre class="lang-js">
var %oldStart = %control.selectionStart;
var %oldEnd = %control.selectionEnd;
var %oldDirection = %control.selectionDirection;
var %prefix = "http://";
%control.value = %prefix + %control.value;
%control.setSelectionRange(%oldStart + %prefix.length, %oldEnd + %prefix.length, %oldDirection);
</pre>

<p>
（ %control は［
`input$e ／ `textarea$e
］要素とする。）
◎
...where control is the input or textarea element.
</p>
</div>


			</section>
			<section id="constraints">
<h4 title="Constraints">4.10.21. 拘束</h4>

				<section id="definitions">
<h5 title="Definitions">4.10.21.1. 各種 定義</h5>

<p>
`提出-可能$な要素は、
`拘束~検証の対象外@
にある間を除いて，
`拘束~検証の候補@
になる（例えば、
先祖に `datalist$e 要素がある要素は，`拘束~検証の対象外$になる）。
◎
A submittable element is a candidate for constraint validation except when a condition has barred the element from constraint validation. (For example, an element is barred from constraint validation if it has a datalist element ancestor.)
</p>

<p>
要素には、
`~custom妥当性~error~message@
も定義され得る：
◎
An element can have a custom validity error message defined.＼
</p>

<ul>
	<li>
初期~時は、
空~文字列とする。
◎
Initially, an element must have its custom validity error message set to the empty string.＼
</li>
	<li>
空~文字列でないときは、
当の要素は，`~custom~errorの難あり$になる。
◎
When its value is not the empty string, the element is suffering from a custom error.＼
</li>
	<li>
当の要素が`~formに所有され得る~custom要素$である場合、
`ElementInternals$I ~objの `setValidity()$eI ~methodを介して設定できる。
他の場合、
`setCustomValidity()$m を~method利用して設定できる。
◎
It can be set using the setCustomValidity() method, except for form-associated custom elements. Form-associated custom elements can have a custom validity error message set via their ElementInternals object's setValidity() method.＼
</li>
	<li>
~UAは、
当の~controlにおける問題を利用者に~alertするときには，
`~custom妥当性~error~message$を利用するべきである。
◎
The user agent should use the custom validity error message when alerting the user to the problem with the control.
</li>
</ul>

<p>
要素は、
様々な仕方で拘束できる／され得る。
以下に、［
拘束~検証の目的において~controlを妥当でなくする
］ような，~form~controlがとり得る
`妥当性~状態@
を挙げる
（以下の記述【！定義】は、
規範的でない
— 各~状態が いつ適用される／されないかは、
この仕様の他所にて，より精確に定義される）。
◎
An element can be constrained in various ways. The following is the list of validity states that a form control can be in, making the control invalid for the purposes of constraint validation. (The definitions below are non-normative; other parts of this specification define more precisely when each state applies or does not.)
</p>
<dl>
	<dt>
`欠落である難あり@
◎
Suffering from being missing
</dt>
	<dd>
~controlは、
`required^a 属性
（ `input$e の `~requiredI$a ／ `textarea$e の `~requiredT$a ）
を有するが，
その`値$feが無いとき。
ただし，［
`select$e 要素 ／
`~radio~button~group$に属する~control
］においては、
それらの各~節に指定されるとおり，もっと複雑な規則になる。
◎
When a control has no value but has a required attribute (input required, textarea required); or, more complicated rules for select elements and controls in radio button groups, as specified in their sections.
</dd>
	<dd>
`~formに所有され得る~custom要素$においては、
その`妥当性~flag群$cF[ `valueMissing^l ] ~EQ ~T のとき。
◎
When the setValidity() method sets valueMissing flag to true for a form-associated custom element.
</dd>

	<dt>
`型~不一致の難あり@
◎
Suffering from a type mismatch
</dt>
	<dd> 
当の~controlは、
任意な利用者~入力を許容するが，その`値$feが正しい構文でないとき
（ `Email$st, `Url$st ）。
◎
When a control that allows arbitrary user input has a value that is not in the correct syntax (Email, URL).
</dd>
	<dd>
`~formに所有され得る~custom要素$においては、
その`妥当性~flag群$cF[ `typeMismatch^l ] ~EQ ~T のとき。
◎
When the setValidity() method sets typeMismatch flag to true for a form-associated custom element.
</dd>

	<dt>
`~pattern不一致の難あり@
◎
Suffering from a pattern mismatch
</dt>
	<dd>
~controlの`値$feが
`pattern$a 属性を満たさないとき。
◎
When a control has a value that doesn't satisfy the pattern attribute.
</dd>
	<dd>
`~formに所有され得る~custom要素$においては、
その`妥当性~flag群$cF[ `patternMismatch^l ] ~EQ ~T のとき。
◎
When the setValidity() method sets patternMismatch flag to true for a form-associated custom element.
</dd>

	<dt>
`長過ぎる難あり@
◎
Suffering from being too long
</dt>
	<dd> 
~controlの`値$feが`~form~control~maxlength属性$
（ `input$e の `~maxlengthI$a ／ `textarea$e の `~maxlengthT$a ）
に比して長過ぎるとき。
◎
When a control has a value that is too long for the form control maxlength attribute (input maxlength, textarea maxlength).
</dd>
	<dd>
`~formに所有され得る~custom要素$においては、
その`妥当性~flag群$cF[ `tooLong^l ] ~EQ ~T のとき。
◎
When the setValidity() method sets tooLong flag to true for a form-associated custom element.
</dd>

	<dt>
`短か過ぎる難あり@
◎
Suffering from being too short
</dt>
	<dd>
~controlの`値$feが`~form~control~minlength属性$
（ `input$e の `~minlengthI$a ／ `textarea$e の `~minlengthT$a ）
に比して短か過ぎるとき。
◎
When a control has a value that is too short for the form control minlength attribute (input minlength, textarea minlength).
</dd>
	<dd>
`~formに所有され得る~custom要素$においては、
その`妥当性~flag群$cF[ `tooShort^l ] ~EQ ~T のとき。
◎
When the setValidity() method sets tooShort flag to true for a form-associated custom element.
</dd>

	<dt>
`~underflowの難あり@
◎
Suffering from an underflow
</dt>
	<dd>
~controlの`値$feが［
空~文字列でない
］かつ［
`min$a 属性に比して低~過ぎる
］とき。
◎
When a control has a value that is not the empty string and is too low for the min attribute.
</dd>
	<dd>
`~formに所有され得る~custom要素$においては、
その`妥当性~flag群$cF[ `rangeUnderflow^l ] ~EQ ~T のとき。
◎
When the setValidity() method sets rangeUnderflow flag to true for a form-associated custom element.
</dd>

	<dt>
`~overflowの難あり@
◎
Suffering from an overflow
</dt>
	<dd>
~controlの`値$feが［
空~文字列でない
］かつ［
`max$a 属性に比して高~過ぎる
］とき。
◎
When a control has a value that is not the empty string and is too high for the max attribute.
</dd>
	<dd>
`~formに所有され得る~custom要素$においては、
その`妥当性~flag群$cF[ `rangeOverflow^l ] ~EQ ~T のとき。
◎
When the setValidity() method sets rangeOverflow flag to true for a form-associated custom element.
</dd>

	<dt>
`~step不一致の難あり@
◎
Suffering from a step mismatch
</dt>
	<dd>
~controlの`値$feが `step$a 属性が与える規則に合わないとき。
◎
When a control has a value that doesn't fit the rules given by the step attribute.
</dd>
	<dd>
`~formに所有され得る~custom要素$においては、
その`妥当性~flag群$cF[ `stepMismatch^l ] ~EQ ~T のとき。
◎
When the setValidity() method sets stepMismatch flag to true for a form-associated custom element.
</dd>

	<dt>
`不良~入力の難あり@
◎
Suffering from bad input
</dt>
	<dd>
~controlの入力は不完全であり、
~UAは，［
現在の状態において，利用者が~formを提出できる
］と~~判断していないとき。
◎
When a control has incomplete input and the user agent does not think the user ought to be able to submit the form in its current state.
</dd>
	<dd>
`~formに所有され得る~custom要素$においては、
その`妥当性~flag群$cF[ `badInput^l ] ~EQ ~T のとき。
◎
When the setValidity() method sets badInput flag to true for a form-associated custom element.
</dd>
	<dd class="trans-note">【
すなわち、
上に挙げられた他のどの “難あり” にも該当しないが，
“難あり” にされるべきとき。
】</dd>

	<dt>
`~custom~errorの難あり@
◎
Suffering from a custom error
</dt>
	<dd>
~controlの`~custom妥当性~error~message$が空~文字列でないとき。
（これは、［
要素の `setCustomValidity()$m ~method／
`ElementInternals$I の `setValidity()$eI ~method
］により設定される。）
◎
When a control's custom validity error message (as set by the element's setCustomValidity() method or ElementInternals's setValidity() method) is not the empty string.
</dd>
</dl>

<p class="trans-note">【
`妥当性~flag群$cFを成す各~entryは、
`ElementInternals$I の `setValidity()$eI ~methodにより設定される。
】</p>

<p class="note">注記：
要素は、
`不能化されて$feいる間でも，これらいずれかの状態に難ありになり得る。
したがって，これらの状態は、［
提出の間に~formを検証するときに，利用者に問題を指示しない場合
］でも，
【`拘束~検証~API＠#the-constraint-validation-api$を通して】
~DOM内で表現され得る。
◎
An element can still suffer from these states even when the element is disabled; thus these states can be represented in the DOM even if validating the form during submission wouldn't indicate a problem to the user.
</p>

<p>
要素が
`自身の拘束を満たして@
いるとは、
上に挙げた どの`妥当性~状態$の難ありでもないことをいう。
◎
An element satisfies its constraints if it is not suffering from any of the above validity states.
</p>

				</section>
				<section id="constraint-validation">
<h5 title="Constraint validation">4.10.21.2. 拘束~検証</h5>

<div class="algo">
<div class="p">
<p>
`拘束を静的に検証する@
~algoは、
所与の
( `form$e 要素 %~form )
に対し，［
`肯定的^i ／ `否定的^i
］を返す：
</p>
<ul>
	<li>
`肯定的^i は、
%~form 内のすべての~controlは妥当であることを表す
— `否定的^i は、
その否定を表す。
</li>
	<li>
`否定的^i を返す場合、
結果には，［
妥当でないかつ, それを担当する~scriptもない要素
］たちが成す~list（場合によっては空）も伴われる。
</li>
</ul>

◎
When the user agent is required to statically validate the constraints of form element form, it must run the following steps, which return either a positive result (all the controls in the form are valid) or a negative result (there are invalid controls) along with a (possibly empty) list of elements that are invalid and for which no script has claimed responsibility:
</div>
<ol>
	<li>
%~control群 ~LET ［
%~form が`所有して$いる要素のうち`提出-可能$なもの
］たちが成す，`~tree順序$による~list
◎
Let controls be a list of all the submittable elements whose form owner is form, in tree order.
</li>
	<li>
%妥当でない~control群 ~LET 空な~list
◎
Let invalid controls be an initially empty list of elements.
</li>
	<li>
<p>
%~control群 を成す
~EACH( %欄 )
に対し
⇒
~IF［
%欄 は`拘束~検証の候補$である
］~AND［
%欄 は`自身の拘束を満たして$いない
］
⇒
%妥当でない~control群 に %欄 を追加する
◎
For each element field in controls, in tree order:
• If field is not a candidate for constraint validation, then move on to the next element.
• Otherwise, if field satisfies its constraints, then move on to the next element.
• Otherwise, add field to invalid controls.
</li>
	<li>
~IF［
%妥当でない~control群 は空である
］
⇒
~RET `肯定的^i
◎
If invalid controls is empty, then return a positive result.
</li>
	<li>
%未取扱いな妥当でない~control群 ~LET 空な~list
◎
Let unhandled invalid controls be an initially empty list of elements.
</li>
	<li>
<p>
%妥当でない~control群 を成す
~EACH( %欄 )
に対し：
◎
For each element field in invalid controls, if any, in tree order:
</p>
		<ol>
			<li>
%取消されなかったか ~LET
`~eventを発火する$( %欄, `invalid$et )
— 次のように初期化して
⇒
`cancelable$m 属性 ~SET ~T
◎
Let notCanceled be the result of firing an event named invalid at field, with the cancelable attribute initialized to true.
</li>
			<li>
~IF［
%取消されなかったか ~EQ ~T
］
⇒
%未取扱いな妥当でない~control群 に %欄 を追加する
◎
If notCanceled is true, then add field to unhandled invalid controls.
</li>
</ol>

	</li>
	<li>
~RET `否定的^i ＋ %未取扱いな妥当でない~control群
◎
Return a negative result with the list of elements in the unhandled invalid controls list.
</li>
</ol>
</div>

<div class="algo">
<p>
`拘束をヤリトリありに検証する@
~algoは、
所与の
( `form$e 要素 %~form )
に対し：
◎
If a user agent is to interactively validate the constraints of form element form, then the user agent must run the following steps:
</p>
<ol>
	<li>
~IF［
`拘束を静的に検証する$( %~form ) ~EQ `肯定的^i
］
⇒
~RET `肯定的^i
◎
Statically validate the constraints of form, and let unhandled invalid controls be the list of elements returned if the result was negative.
◎
If the result was positive, then return that result.
</li>
	<li>
<p>
［
前~段の検証-結果に伴われる %未取扱いな妥当でない~control群
］を成す 1 個~以上の要素に対する拘束に関する問題を利用者に報告する
— ~UAは、
次をしてもヨイ：
◎
Report the problems with the constraints of at least one of the elements given in unhandled invalid controls to the user.
</p>
		<ul>
			<li>
<p>
`~objを~focusする$( ~list内のいずれかの要素 )
— 加えて、
文書の~scrolling位置を変更するか，要素に利用者の注目を引かせる他の何らかの動作を遂行する。
◎
User agents may focus one of those elements in the process, by running the focusing steps for that element, and may change the scrolling position of the document, or perform some other action that brings the element to the user's attention.＼
</p>

<p>
`~formに所有され得る~custom要素$に対しては、
これらの動作の目的においては，`検証~anchor$cFを利用するベキである。
◎
For elements that are form-associated custom elements, user agents should use their validation anchor instead, for the purposes of these actions.
</p>
			</li>
			<li>
複数の拘束~違反を報告する。
◎
User agents may report more than one constraint violation.
</li>
			<li>
適切になるなら，関係する拘束~違反~報告たちを合体する
（例：
ある`~radio~button~group$を成す複数の~radio~buttonが要求される欄として~markされた場合、
報告する必要がある~errorは 1 個だけになる）。
◎
User agents may coalesce related constraint violation reports if appropriate (e.g. if multiple radio buttons in a group are marked as required, only one error need be reported).
</li>
			<li>
いずれかの~controlが`具現化されて$いない場合
（例： `hidden$a 属性を有するなど）、
~script~errorを報告する。
◎
If one of the controls is not being rendered (e.g. it has the hidden attribute set), then user agents may report a script error.
</li>
		</ul>
	</li>
	<li>
~RET `否定的^i
◎
Return a negative result.
</li>
</ol>
</div>

				</section>
				<section id="the-constraint-validation-api">
<h5 title="The constraint validation API">4.10.21.3. 拘束~検証~API</h5>

<dl class="domintro">

	<dt>%element.`willValidate$m</dt>
	<dd>
［
%element は~formの提出-時に検証されるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element will be validated when the form is submitted; false otherwise.
</dd>

	<dt>%element.`setCustomValidity(error【！message】)$m</dt>
	<dd>
~custom~errorを設定して %element が検証-時に失敗するようにする。
%error は 利用者に問題を報告するときに示される~messageを与える。
◎
Sets a custom error, so that the element would fail to validate. The given message is the message to be shown to the user when reporting the problem to the user.
</dd>
	<dd>
%message が空~文字列の場合、
~custom~errorを~~空に戻す。
◎
If the argument is the empty string, clears the custom error.
</dd>

	<dt>%element.`validity$m.`valueMissing$m</dt>
	<dd>
［
%element は要求される欄であるが値を有さない ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element has no value but is a required field; false otherwise.
</dd>

	<dt>%element.`validity$m.`typeMismatch$m</dt>
	<dd>
［
%element の値は正しい構文でないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is not in the correct syntax; false otherwise.
</dd>

	<dt>%element.`validity$m.`patternMismatch$m</dt>
	<dd>
［
%element の値は供された~patternに合致しないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value doesn't match the provided pattern; false otherwise.
</dd>

	<dt>%element.`validity$m.`tooLong$m</dt>
	<dd>
［
%element の値は 供された最大~長さより長いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is longer than the provided maximum length; false otherwise.
</dd>

	<dt>%element.`validity$m.`tooShort$m</dt>
	<dd>
［
%element の値は 空~文字列でない, かつ 供された最小~長さより短いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value, if it is not the empty string, is shorter than the provided minimum length; false otherwise.
</dd>

	<dt>%element.`validity$m.`rangeUnderflow$m</dt>
	<dd>
［
%element の値は 供された最小より低いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is lower than the provided minimum; false otherwise.
</dd>

	<dt>%element.`validity$m.`rangeOverflow$m</dt>
	<dd>
［
%element の値は 供された最大より高いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is higher than the provided maximum; false otherwise.
</dd>

	<dt>%element.`validity$m.`stepMismatch$m</dt>
	<dd>
［
%element の値は `step$a 属性が与える規則に合わないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value doesn't fit the rules given by the step attribute; false otherwise.
</dd>

	<dt>%element.`validity$m.`badInput$m</dt>
	<dd>
［
利用者が~UI内に供した入力を ~UAが値に変換できないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the user has provided input in the user interface that the user agent is unable to convert to a value; false otherwise.
</dd>

	<dt>%element.`validity$m.`customError$m</dt>
	<dd>
［
%element に~custom~errorがあるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element has a custom error; false otherwise.
</dd>

	<dt>%element.`validity$m.`valid$m</dt>
	<dd>
［
%element の値に妥当性の問題がないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value has no validity problems; false otherwise.
</dd>

	<dt>%valid = %element.`checkValidity()$m</dt>
	<dd>
［
%element の値に妥当性の問題がないならば ~T ／
~ELSE_ ~F
］を返す。
加えて， ~F を返すときは、
%element に向けて `invalid$et ~eventを発火する。
◎
Returns true if the element's value has no validity problems; false otherwise. Fires an invalid event at the element in the latter case.
</dd>

	<dt>%valid = %element.`reportValidity()$m</dt>
	<dd>
［
%element の値に妥当性の問題がないならば ~T ／
~ELSE_ ~F
］を返す。
加えて， ~F を返すときは、
%element に向けて `invalid$et ~eventを発火した上で，（~eventが取消されなかったなら）問題を利用者に報告する。
◎
Returns true if the element's value has no validity problems; otherwise, returns false, fires an invalid event at the element, and (if the event isn't canceled) reports the problem to the user.
</dd>

	<dt>%element.`validationMessage$m</dt>
	<dd>
%element の妥当性が検査され，問題があった場合に 利用者に示されることになる~error~messageを返す。
◎
Returns the error message that would be shown to the user if the element was to be checked for validity.
</dd>
</dl>

<div class="algo">
`willValidate@m
取得子~手続きは
⇒
~RET ~IS［
コレは`拘束~検証の候補$である
］
◎
The willValidate attribute's getter must return true, if this element is a candidate for constraint validation, and false otherwise (i.e., false if any conditions are barring it from constraint validation).
</div>

<div class="algo">
<p>
`ElementInternals$I の
`willValidate@eI
取得子~手続きは：
</p>
<ol>
	<li>
%要素 ~LET コレの`~target要素$iN
</li>
	<li>
~IF［
%要素 は`~formに所有され得る~custom要素$でない
］
⇒
~THROW `NotSupportedError$E
</li>
	<li>
~RET ~IS［
%要素 は`拘束~検証の候補$である
］
</li>
</ol>
◎
The willValidate attribute of ElementInternals interface, on getting, must throw a "NotSupportedError" DOMException if the target element is not a form-associated custom element. Otherwise, it must return true if the target element is a candidate for constraint validation, and false otherwise.
</div>

<div class="algo">
`setCustomValidity(error)@m
~method~手続きは
⇒
コレの`~custom妥当性~error~message$ ~SET `改行文字を正規化する$( %error )
◎
The setCustomValidity(error) method steps are:
• Set error to the result of normalizing newlines given error.
• Set the custom validity error message to error.
</div>

<div class="example">
<p>
次の例では、
~scriptは，~form~controlの値を編集される度に検査し、
妥当な値でないならば，
`setCustomValidity()$m ~methodを利用して適切な~messageを設定する。
◎
In the following example, a script checks the value of a form control each time it is edited, and whenever it is not a valid value, uses the setCustomValidity() method to set an appropriate message.
</p>

<pre class="lang-html">
&lt;label&gt;Feeling: &lt;input name=f type="text" oninput="check(this)"&gt;&lt;/label&gt;
&lt;script&gt;
 function check(%input) {
   if (%input.value == "good" ||
       %input.value == "fine" ||
       %input.value == "tired") {
     %input.setCustomValidity('"' + %input.value + '" is not a feeling.');
   } else {
     /* <span class="comment">
%input は申し分ない — ~error~messageを再設定する
◎
input is fine -- reset the error message
</span> */
     %input.setCustomValidity('');
   }
 }
&lt;/script&gt;
</pre>
</div>

<div class="algo">
`validity@m
取得子~手続きは
⇒
~RET コレの`妥当性~状態$を表現する，`~live$な `ValidityState$I ~obj
◎
The validity attribute's getter must return a ValidityState object that represents the validity states of this element. This object is live.
</div>

<div class="algo">
<p>
`ElementInternals$I の
`validity@eI
取得子~手続きは：
</p>
<ol>
	<li>
%要素 ~LET コレの`~target要素$iN
</li>
	<li>
~IF［
%要素 は`~formに所有され得る~custom要素$でない
］
⇒
~THROW `NotSupportedError$E
</li>
	<li>
~RET %要素 の`妥当性~状態$を表現する，`~live$な `ValidityState$I ~obj
</li>
</ol>
◎
The validity attribute of ElementInternals interface, on getting, must throw a "NotSupportedError" DOMException if the target element is not a form-associated custom element. Otherwise, it must return a ValidityState object that represents the validity states of the target element. This object is live.
</div>

<pre class="idl">
[Exposed=Window]
interface `ValidityState@I {
  readonly attribute boolean `valueMissing$m;
  readonly attribute boolean `typeMismatch$m;
  readonly attribute boolean `patternMismatch$m;
  readonly attribute boolean `tooLong$m;
  readonly attribute boolean `tooShort$m;
  readonly attribute boolean `rangeUnderflow$m;
  readonly attribute boolean `rangeOverflow$m;
  readonly attribute boolean `stepMismatch$m;
  readonly attribute boolean `badInput$m;
  readonly attribute boolean `customError$m;
  readonly attribute boolean `valid$m;
};
</pre>

<div class="algo">
<p>
`ValidityState$I の次に挙げる属性の取得子~手続きは、
~IS［
対応する条件が満たされる
］を返す：
◎
A ValidityState object has the following attributes. On getting, they must return true if the corresponding condition given in the following list is true, and false otherwise.
</p>

<dl class="def-list">
	<dt>`valueMissing@m</dt>
	<dd>
~controlには`欠落である難あり$
◎
The control is suffering from being missing.
</dd>

	<dt>`typeMismatch@m</dt>
	<dd>
~controlには`型~不一致の難あり$
◎
The control is suffering from a type mismatch.
</dd>

	<dt>`patternMismatch@m</dt>
	<dd>
~controlには`~pattern不一致の難あり$
◎
The control is suffering from a pattern mismatch.
</dd>

	<dt>`tooLong@m</dt>
	<dd>
~controlには`長過ぎる難あり$
◎
The control is suffering from being too long.
</dd>

	<dt>`tooShort@m</dt>
	<dd>
~controlには`短か過ぎる難あり$
◎
The control is suffering from being too short.
</dd>

	<dt>`rangeUnderflow@m</dt>
	<dd>
~controlには`~underflowの難あり$
◎
The control is suffering from an underflow.
</dd>

	<dt>`rangeOverflow@m</dt>
	<dd>
~controlには`~overflowの難あり$
◎
The control is suffering from an overflow.
</dd>

	<dt>`stepMismatch@m</dt>
	<dd>
~controlには`~step不一致の難あり$
◎
The control is suffering from a step mismatch.
</dd>

	<dt>`badInput@m</dt>
	<dd>
~controlには`不良~入力の難あり$
◎
The control is suffering from bad input.
</dd>

	<dt>`customError@m</dt>
	<dd>
~controlには`~custom~errorの難あり$
◎
The control is suffering from a custom error.
</dd>

	<dt>`valid@m</dt>
	<dd>
上に挙げた どの条件も満たされない
◎
None of the other conditions are true.
</dd>
</dl>
</div>

<hr>

<div class="algo">
<p>
`妥当性を検査する@
手続きは、
所与の
( 要素 %要素 )
に対し：
◎
The check validity steps for an element element are:
</p>
<ol>
	<li>
<p>
~IF［
%要素 は`拘束~検証の候補$である
］~AND［
%要素 は`自身の拘束を満たして$いない
］：
◎
If element is a candidate for constraint validation and does not satisfy its constraints, then:
</p>
		<ol>
			<li>
`~eventを発火する$( %要素, `invalid$et )
— 次のように初期化して
⇒
`cancelable$m 属性 ~SET ~T（取消しても効果はないが）
◎
Fire an event named invalid at element, with the cancelable attribute initialized to true (though canceling has no effect).
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
`checkValidity()@m
~method~手続きは
⇒
~RET `妥当性を検査する$( コレ )
◎
The checkValidity() method, when invoked, must run the check validity steps on this element.
</div>

<div class="algo">
<p>
`ElementInternals$I の
`checkValidity()@eI
~method~手続きは：
◎
The checkValidity() method of the ElementInternals interface must run these steps:
</p>
<ol>
	<li>
%要素 ~LET コレの`~target要素$iN
◎
Let element be this ElementInternals's target element.
</li>
	<li>
~IF［
%要素 は`~formに所有され得る~custom要素$でない
］
⇒
~THROW `NotSupportedError$E
◎
If element is not a form-associated custom element, then throw a "NotSupportedError" DOMException.
</li>
	<li>
~RET `妥当性を検査する$( %要素 )
◎
Run the check validity steps on element.
</li>
</ol>
</div>

<div class="algo">
<p>
`妥当性を報告する@
手続きは、
所与の
( 要素 %要素 )
に対し：
◎
The report validity steps for an element element are:
</p>
<ol>
	<li>
<p>
~IF［
%要素 は`拘束~検証の候補$である
］~AND［
%要素 は`自身の拘束を満たして$いない
］：
◎
If element is a candidate for constraint validation and does not satisfy its constraints, then:
</p>
		<ol>
			<li>
%報告するか ~LET
`~eventを発火する$( %要素, `invalid$et )
— 次のように初期化して
⇒
`cancelable$m 属性 ~SET ~T
◎
Let report be the result of firing an event named invalid at element, with the cancelable attribute initialized to true.
</li>
			<li>
<p>
~IF［
%報告するか ~EQ ~T
］
⇒
%要素 の拘束についての問題を 利用者に報告する
— その際には、
~UAは 次をしてもヨイ：
◎
If report is true, then report the problems with the constraints of this element to the user. When reporting the problem with the constraints to the user, the user agent＼
</p>
				<ul>
					<li>
`~objを~focusする$( %要素 )
— 加えて、
文書の~scrolling位置を変更するか，要素に利用者の注目を引かせる他の何らかの動作を遂行する
◎
may run the focusing steps for element, and may change the scrolling position of the document, or perform some other action that brings element to the user's attention.＼
</li>
					<li>
%要素 が複数の問題に難ありならば，それら複数の拘束~違反を報告する
◎
User agents may report more than one constraint violation, if element suffers from multiple problems at once.
</li>
				</ul>
			</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
`reportValidity()@m
~method~手続きは
⇒
~RET `妥当性を検査する$( コレ )
◎
The reportValidity() method, when invoked, must run the report validity steps on this element.
</div>

<div class="algo">
<p>
`ElementInternals$I の
`reportValidity()@eI
~method~手続きは：
◎
The reportValidity() method of the ElementInternals interface must run these steps:
</p>
<ol>
	<li>
%要素 ~LET コレの`~target要素$iN
◎
Let element be this ElementInternals's target element.
</li>
	<li>
~IF［
%要素 は`~formに所有され得る~custom要素$でない
］
⇒
~THROW `NotSupportedError$E
◎
If element is not a form-associated custom element, then throw a "NotSupportedError" DOMException.
</li>
	<li>
`妥当性を報告する$( %要素 )
◎
Run the report validity steps on element.
</li>
</ol>
</div>

<div class="algo">
<p>
`validationMessage@m
取得子~手続きは：
◎
The validationMessage attribute's getter must run these steps:
</p>
<ol>
	<li>
~IF［
コレは`拘束~検証の候補$でない
］~OR［
コレは`自身の拘束を満たして$いる
］
⇒
~RET 空~文字列
◎
If this element is not a candidate for constraint validation or if this element satisfies its constraints, then return the empty string.
</li>
	<li>
<p>
~RET ［
コレが妥当性の拘束に問題がある，唯一の~form~controlであった場合
］に利用者に示すことになる，相応しく地域化された~message
— ただし：
◎
Return a suitably localized message that the user agent would show the user if this were the only form control with a validity constraint problem.＼
</p>
		<ul>
			<li>
~UAが実際には~textな~messageを示さない場合
（例：代わりに~graphicな~cueを示す場合）
には、［
当の~controlが満たさない（ 1 個~以上の）妥当性~拘束たち
］を表出する, 相応しく地域化された~message
◎
If the user agent would not actually show a textual message in such a situation (e.g., it would show a graphical cue instead), then return a suitably localized message that expresses (one or more of) the validity constraint(s) that the control does not satisfy.＼
</li>
			<li>
【！不要：コレは`拘束~検証の候補$である ~AND】
コレは`~custom~errorの難あり$な場合、
結果の~message内には`~custom妥当性~error~message$が【も？】在るべきである。
◎
If the element is a candidate for constraint validation and is suffering from a custom error, then the custom validity error message should be present in the return value.
</li>
		</ul>
	</li>
</ol>
</div>

				</section>
				<section id="security-forms">
<h5 title="Security">4.10.21.4. ~security</h5>

<p id="security-0">
~serverは、
~client側の検証に依拠するべきでない。
敵対的な利用者は，~client側の検証を意図的に迂回でき、
また意図的でなくとも，これらの特能を実装しない［
旧式な~UA ／ 自動化された~tool
］の利用者により迂回され得るので。
拘束~検証の特能が意図するのは，利用者~体験を改善することに限られており、
~securityについては，いかなる種類の仕組みも供さない。
◎
Servers should not rely on client-side validation. Client-side validation can be intentionally bypassed by hostile users, and unintentionally bypassed by users of older user agents or automated tools that do not implement these features. The constraint validation features are only intended to improve the user experience, not to provide any kind of security mechanism.
</p>

				</section>
			</section>
			<section id="form-submission">
<h4 title="Form submission">4.10.22. ~form提出</h4>

				<section id="introduction-5">
<h5 title="Introduction">4.10.22.1. 序論</h5>

◎非規範的

<p>
~formが提出されるとき、
~form内の~dataは，`~enctype$が指定する構造に変換された上で、
所与の`~method$を利用して，`動作$に指定される行先へ送信される。
◎
When a form is submitted, the data in the form is converted into the structure specified by the enctype, and then sent to the destination specified by the action using the given method.
</p>

<p>
例えば、
次の~formでは：
◎
For example, take the following form:
</p>

`form-submission-1^xCode

<p>
利用者が，［
1 個目の欄に "cats",
2 個目の欄に "fur"
］と打込んで提出-~buttonを叩いた場合、
~UAは
`/find.cgi?t=cats&amp;q=fur^c
を読込むことになる。
◎
If the user types in "cats" in the first field and "fur" in the second, and then hits the submit button, then the user agent will load /find.cgi?t=cats&amp;q=fur.
</p>

<p>
他方、
次の~formを考える：
◎
On the other hand, consider this form:
</p>

`form-submission-2^xCode

<p>
利用者により同じ入力が与えられた下での提出の結果は，全く異なり、
代わりに~UAは，所与の~URLへ向けて~HTTP `POST$M を行う
— 次の~textの様な~entity本体を伴わせて：
◎
Given the same user input, the result on submission is quite different: the user agent instead does an HTTP POST to the given URL, with as the entity body something like the following text:
</p>

<pre class="lang-http">
------kYFrd4jNJEgCervE
Content-Disposition: form-data; name="t"

cats
------kYFrd4jNJEgCervE
Content-Disposition: form-data; name="q"

fur
------kYFrd4jNJEgCervE--
</pre>

				</section>
				<section id="implicit-submission">
<h5 title="Implicit submission">4.10.22.2. 暗黙的な提出</h5>

<p>
`form$e 要素の
`既定の~button@
は、
それが`所有して$いる`提出-~button$のうち，`~tree順序$で最初のものとする。
◎
A form element's default button is the first submit button in tree order whose form owner is that form element.
</p>

<p>
~UAが，利用者による ~formの暗黙的な提出を~supportする場合（例えば，一部の~platformでは、
~text~controlが`~focusされて$いる間に <kbd>enter</kbd> ~UIkeyを叩くと，~formは暗黙的に提出される）、
~formの`既定の~button$に`作動化の挙動$があって, `不能化されて$feいない場合に そうするときは、
~UAは，その`既定の~button$に向けて`~click~eventを発火する$モノトスル。
◎
If the user agent supports letting the user submit a form implicitly (for example, on some platforms hitting the "enter" key while a text control is focused implicitly submits the form), then doing so for a form, whose default button has activation behavior and is not disabled, must cause the user agent to fire a click event at that default button.
</p>

<p class="note">注記：
~webには、
暗黙的に提出する仕方がある場合に限り，~formを利用-可能な~pageもある。
したがって~UAには、
これの~supportが強く奨励される。
◎
There are pages on the web that are only usable if there is a way to implicitly submit forms, so user agents are strongly encouraged to support this.
</p>

<div class="algo">
<p>
`form$e 要素 %~form に`提出-~button$が無い場合、
暗黙的な提出の仕組みは，次の手続きを遂行するモノトスル：
</p>
<ol>
	<li>
<p id="field-that-blocks-implicit-submission">
~IF［
~AND↓ を満たす要素（ “暗黙的な提出を阻む欄” ）は無い
］…
</p>
		<ul>
			<li>
要素の`~form所有者$ ~EQ %~form
</li>
			<li>
［
要素は `input$e 要素である
］~AND［
要素の `type$a 属性の状態 ~IN {
`Text$st, `Text$st, `Tel$st, `Url$st, `Email$st, `Password$st, `Date$st, `Month$st, `Week$st, `Time$st, `Datetime-local$st, `Number$st
}
］
</li>
		</ul>
<p>
…ならば
⇒
`~formを提出する$( %~form, %~form, `作動化$i )
</p>
	</li>
</ol>
◎
If the form has no submit button, then the implicit submission mechanism must perform the following steps:
• If the form has more than one field that blocks implicit submission, then return.
• Submit the form element from the form element itself with userInvolvement set to "activation".
• For the purpose of the previous paragraph, an element is a field that blocks implicit submission of a form element if it is an input element whose form owner is that form element and whose type attribute is in one of the following states: Text, Search, Telephone, URL, Email, Password, Date, Month, Week, Time, Local Date and Time, Number
</div>

				</section>
				<section id="form-submission-algorithm">
<h5 title="Form submission algorithm">4.10.22.3. ~form提出~algo</h5>

<p>
各 `form$e 要素は、
次に挙げるものを有する：
◎
↓</p>
<ul>
	<li>
`~entry~list構築-中か@
⇒
真偽-値
— 初期~時は ~F とする。
◎
Each form element has a constructing entry list boolean, initially false.
</li>
	<li>
`提出~event発火-中か@
⇒
真偽-値
— 初期~時は ~F とする。
◎
Each form element has a firing submission events boolean, initially false.
</li>
</ul>

<div class="algo">
<p>
`~formを提出する@
~algoは、
所与の
( `form$e 要素 %~form, %提出元, `~naviに対する利用者-関与i$ %利用者-関与i ~DF `なし$i" )
に対し：
◎
To submit a form element form from an element submitter (typically a button), given an optional boolean submitted from submit() method (default false) and an optional user navigation involvement userInvolvement (default "none"):
</p>

<p class="trans-note">【
原文の~algoは［
“`submitted from submit() method^en” と称される真偽値~引数
］もとるが、
この訳では %提出元 に統合する。
】</p>
<ol>
	<li>
~Assert：
%提出元 は次に挙げるいずれかである
⇒
ε ／
要素（概して~button）／
`submit() ~method^i
◎
↑</li>
	<li>
`submit() から呼出されたか^V ~LET ~IS［
%提出元 ~EQ `submit() ~method^i
］
◎
↑</li>
	<li>
~IF［
%提出元 ~IN { ε, `submit() ~method^i }
］
⇒
%提出元 ~SET %~form
◎
↑</li>
	<li>
~IF［
%~form は`~navigateできない$
］
⇒
~RET
◎
If form cannot navigate, then return.
</li>
	<li>
~IF［
%~form の`~entry~list構築-中か$ ~EQ ~T
］
⇒
~RET
◎
If form's constructing entry list is true, then return.
</li>
	<li>
%~form文書 ~LET %~form の`~node文書$
◎
Let form document be form's node document.
</li>
	<li id="sandboxSubmitBlocked">
~IF［
`閲覧~文脈~sandbox化( ~form )~flag$ ~IN %~form文書 の`作動中な~sandbox法~flag集合$
］
⇒
~RET
◎
If form document's active sandboxing flag set has its sandboxed forms browsing context flag set, then return.
</li>
	<li>
<p>
~IF［
`submit() から呼出されたか^V ~EQ ~F
］：
◎
If submitted from submit() method is false, then:
</p>
		<ol>
			<li>
~IF［
%~form の`提出~event発火-中か$ ~EQ ~T
］
⇒
~RET
◎
If form's firing submission events is true, then return.
</li>
			<li>
%~form の`提出~event発火-中か$ ~SET ~T
◎
Set form's firing submission events to true.
</li>
			<li>
%~form が`所有して$いる
~EACH( `提出-可能$な要素 %欄 )
に対し
⇒
%欄 の`利用者~妥当性$ ~SET ~T
◎
For each element field in the list of submittable elements whose form owner is form, set field's user validity to true.
</li>
			<li>
<p>
~IF［
%提出元 の`検証なし状態$ ~EQ ~F
］：
◎
If the submitter element's no-validate state is false, then＼
</p>
				<ol>
					<li>
%結果 ~LET `拘束をヤリトリありに検証する$( %~form )
◎
interactively validate the constraints of form and examine the result.＼
</li>
					<li>
<p>
~IF［
%結果 ~EQ `否定的^i
（すなわち，妥当でない欄があり、
そのことは，およそ利用者に伝わっている）
］：
◎
If the result is negative (i.e., the constraint validation concluded that there were invalid fields and probably informed the user of this), then:
</p>
						<ol>
							<li>
%~form の`提出~event発火-中か$ ~SET ~F
◎
Set form's firing submission events to false.
</li>
							<li>
~RET
◎
Return.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%提出元~button ~LET ［
%提出元 ~EQ %~form ならば ~NULL ／
~ELSE_ %提出元
］
◎
Let submitterButton be null if submitter is form. Otherwise, let submitterButton be submitter.
</li>
			<li>
%継続するか ~LET
`~eventを発火する$( %~form, `submit$et, `SubmitEvent$I )
— 次のように初期化して
⇒＃
`submitter$m 属性 ~SET %提出元~button,
`bubbles$m 属性 ~SET ~T, 
`cancelable$m 属性 ~SET ~T
◎
Let shouldContinue be the result of firing an event named submit at form using SubmitEvent, with the submitter attribute initialized to submitterButton, the bubbles attribute initialized to true, and the cancelable attribute initialized to true.
</li>
			<li>
%~form の`提出~event発火-中か$ ~SET ~F
◎
Set form's firing submission events to false.
</li>
			<li>
~IF［
%継続するか ~EQ ~F
］
⇒
~RET
◎
If shouldContinue is false, then return.
</li>
			<li>
<p>
~IF［
%~form は`~navigateできない$
］
⇒
~RET
◎
If form cannot navigate, then return.
</p>

<p class="note">注記：
`~navigateできない$かどうか再び調べる
— `submit$et ~eventを配送した結果，変化することもあるので。
◎
Cannot navigate is run again as dispatching the submit event could have changed the outcome.
</p>
			</li>
		</ol>
	</li>
	<li>
%符号化法 ~LET %~form の現在の`符号化法$form
◎
Let encoding be the result of picking an encoding for the form.
</li>
	<li>
%~entry~list ~LET `~entry~listを構築する$( %~form, %提出元, %符号化法 )
◎
Let entry list be the result of constructing the entry list with form, submitter, and encoding.
</li>
	<li>
~Assert：
%~entry~list ~NEQ ~NULL
◎
Assert: entry list is not null.
</li>
	<li>
<p>
~IF［
%~form は`~navigateできない$
］
⇒
~RET
◎
If form cannot navigate, then return.
</p>

<p class="note">注記：
`~navigateできない$かどうか再び調べる
— `~entry~listを構築する$ときに `formdata$et ~eventを配送した結果，変化することもあるので。
◎
Cannot navigate is run again as dispatching the formdata event in constructing the entry list could have changed the outcome.
</p>
	</li>
	<li>
%~method ~LET %提出元 の`~method$
◎
Let method be the submitter element's method.
</li>
	<li>
<p>
~IF［
%~method ~EQ `dialog$st
］：
◎
If method is dialog, then:
</p>
		<ol>
			<li>
~IF［
%~form の先祖に `dialog$e 要素は無い
］
⇒
~RET
◎
If form does not have an ancestor dialog element, then return.
</li>
			<li>
%~subject ~LET %~form に最も近い先祖 `dialog$e 要素
◎
Let subject be form's nearest ancestor dialog element.
</li>
			<li>
%結果 ~LET ~NULL
◎
Let result be null.
</li>
			<li>
<p>
~IF［
%提出元 は `input$e 要素である
］~AND［
その `type$a 属性は `Image$st 状態にある
］：
◎
If submitter is an input element whose type attribute is in the Image Button state, then:
</p>
		<ol>
			<li>
( %x, %y ) ~LET `選定された座標$
◎
Let (x, y) be the selected coordinate.
</li>
			<li>
%結果 ~SET 次を順に`連結する$
⇒＃
%x, 
`,^l,
%y
◎
Set result to the concatenation of x, ",", and y.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%提出元 は`提出-~button$である
］
⇒
%結果 ~SET %提出元 の`省略可能な値$fe
◎
Otherwise, if submitter is a submit button, then set result to submitter's optional value.
</li>
			<li>
`~dialogを閉じる$( %~subject, %結果, ~NULL )
◎
Close the dialog subject with result and null.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%動作~URL ~LET %提出元 の`動作$
◎
Let action be the submitter element's action.
</li>
	<li>
~IF［
%動作~URL ~EQ 空~文字列
］
⇒
%動作~URL ~LET %~form文書 の`~URL$doc
【！この場合も~URLを符号化法の下で相対的に構文解析するのか？】
◎
If action is the empty string, let action be the URL of the form document.
</li>
	<li>
%構文解析した動作 ~LET `~URLを符号化法の下で相対的に構文解析する$( %動作~URL, %提出元 の`~node文書$ )
◎
Let parsed action be the result of encoding-parsing a URL given action, relative to submitter's node document.
</li>
	<li>
~IF［
%構文解析した動作 ~EQ `失敗^i
］
⇒
~RET
◎
If parsed action is failure, then return.
</li>
	<li>
%~scheme ~LET %構文解析した動作 の`~scheme$url
◎
Let scheme be the scheme of parsed action.
</li>
	<li>
%~enctype ~LET %提出元 の`~enctype$
◎
Let enctype be the submitter element's enctype.
</li>
	<li>
%~form~target ~LET ~NULL
◎
Let formTarget be null.
</li>
	<li>
~IF［
%提出元 は`提出-~button$である
］~AND［
%提出元 は `formtarget$a 属性を有する
］
⇒
%~form~target ~SET %提出元 の `formtarget$a 属性の値
◎
If the submitter element is a submit button and it has a formtarget attribute, then set formTarget to the formtarget attribute value.
</li>
	<li>
%~target ~LET `要素の~targetを取得する$( %~form, %~form~target )
<!-- ＊
原文 “提出元 の~form所有者／submitter's form owner” はおかしい：
提出元 が form 要素の場合、
~form所有者 は定義されない
-->
◎
Let target be the result of getting an element's target given submitter's form owner and formTarget.
</li>
	<li>
%~noopener ~LET `要素の~noopenerを取得する$( %~form, %構文解析した動作, %~target )
◎
Let noopener be the result of getting an element's noopener with form, parsed action, and target.
</li>
	<li>
( %~target~navigable, — ) ~LET `~navigableを選ぶ規則$を適用する( %~target, %~form の`~node~navigable$, %~noopener )
◎
Let targetNavigable be the first return value of applying the rules for choosing a navigable given target, form's node navigable, and noopener.
</li>
	<li>
~IF［
%~target~navigable ~EQ ~NULL
］
⇒
~RET
◎
If targetNavigable is null, then return.
</li>
	<li>
<p>
%履歴~取扱い ~LET ［
~AND↓ が満たされるならば `replace$hH ／
~ELSE_ `auto$hH
］：
</p>
		<ul>
			<li>
%~form文書 ~EQ %~target~navigable にて`作動中な文書$nav
</li>
			<li>
%~form文書 はまだ`完全に読込まれ$ていない
</li>
		</ul>
◎
Let historyHandling be "auto".
◎
If form document equals targetNavigable's active document, and form document has not yet completely loaded, then set historyHandling to "replace".
</li>
	<li>
<p>
( %~scheme, %~method ) に応じて，下の表tの 1 列目の %~scheme に該当する行の %~method に該当する列に示される手続きを遂行する
◎
Select the appropriate row in the table below based on scheme as given by the first cell of each row. Then, select the appropriate cell on that row based on method as given in the first cell of each column. Then, jump to the steps named in that cell and defined below the table.
</p>

<table><thead>
<tr><td>%~scheme
<th>%~method ~EQ `GET$st
<th>%~method ~EQ `POST$st
<tbody>

<tr><th> `http^l
<td>`変異-動作~URL$
◎
Mutate action URL
<td>`~entity本体として提出する$
◎
Submit as entity body

<tr><th>`https^l
<td>`変異-動作~URL$
◎
Mutate action URL
<td>`~entity本体として提出する$
◎
Submit as entity body

<tr><th>`ftp^l
【`課題 #5375＠~HTMLissue/5375$】
<td>`~Get動作~URL$
◎
Get action URL
<td>`~Get動作~URL$
◎
Get action URL

<tr><th>`javascript^l
<td>`~Get動作~URL$
◎
Get action URL
<td>`~Get動作~URL$
◎
Get action URL

<tr><th>`data^l
<td>`変異-動作~URL$
◎
Mutate action URL
<td>`~Get動作~URL$
◎
Get action URL

<tr><th>`mailto^l
<td>`~header列を伴う~Mail$
◎
Mail with headers
<td>`本体として~Mailする$
◎
Mail as body

<tr><th>その他
<td colspan="2">
この仕様では定義されない
—
~UAは、
これを定義する別の仕様がない限り，
この仕様にて 類似な~schemeに対し定義される方式と相似的に動作するべきである。
◎
If scheme is not one of those listed in this table, then the behavior is not defined by this specification. User agents should, in the absence of another specification defining this, act in a manner analogous to that defined in this specification for similar schemes.
</table>
	</li>
</ol>
</div>

<p>
各 `form$e 要素 %~form には、
`計画された~navi@
がある。
それは、［
~NULL ／`~task$
］であり，
初期~時は ~NULL になるモノトスル。
◎
Each form element has a planned navigation, which is either null or a task; when the form is first created, its planned navigation must be set to null.＼
</p>

<div class="algo">
<p>
`~navigateを計画する@
~algoは、
所与の
( `~URL$ %~URL, `~POST資源$ %~POST資源 ~DF ~NULL )
に対し：
◎
In the behaviors described below, when the user agent is required to plan to navigate to a URL url given an optional POST resource-or-null postResource (default null), it must run the following steps:
</p>
<ol>
	<li>
%~referrer施策 ~LET 空~文字列
◎
Let referrerPolicy be the empty string.
</li>
	<li>
~IF［
%~form の`~link型$に `noreferrer$v ~keywordが含まれている
］
⇒
%~referrer施策 ~SET `no-referrer^l
◎
If the form element's link types include the noreferrer keyword, then set referrerPolicy to "no-referrer".
</li>
	<li>
~IF［
%~form に`計画された~navi$ ~NEQ ~NULL
］
⇒
それを`~task~queue$から除去する
◎
If the form has a non-null planned navigation, remove it from its task queue.
</li>
	<li>
<p>
%~form に`計画された~navi$ ~SET `要素~taskを~queueする$( `~DOM操作~task~source$, %~form, 次の手続き )
◎
Queue an element task on the DOM manipulation task source given the form element and the following steps:
</p>

<div class="algo">
<p>
手続きは：
</p>
		<ol>
			<li>
%~form に`計画された~navi$ ~SET ~NULL
</li>
			<li>
`~navigableを~URLへ~navigateする$( %~target~navigable, %~URL, %~form の`~node文書$ )
— 次も与える下で
⇒＃
`履歴~取扱い^i ~SET %履歴~取扱い,
`利用者-関与i^i ~SET %利用者-関与i,
`~source要素^i ~SET %提出元,
`~referrer施策^i ~SET %~referrer施策,
`文書~資源^i ~SET %~POST資源,
`~form~data~entry~list^i ~SET %~entry~list
</li>
		</ol>
◎
Set the form's planned navigation to null.
◎
Navigate targetNavigable to url using the form element's node document, with historyHandling set to historyHandling, userInvolvement set to userInvolvement, sourceElement set to submitter, referrerPolicy set to referrerPolicy, documentResource set to postResource, and formDataEntryList set to entry list.
◎
↑ Set the form's planned navigation to the just-queued task.
</div>

<p class="trans-note">【
%~target~navigable, %履歴~取扱い, %利用者-関与i, %提出元, %~entry~list
は、
この手続きを（間接的に）呼出した`~formを提出する$~algo［
の中で設定された／に渡された
］それらを指す。
】</p>
</li>
</ol>
</div>

<div class="algo">
<p>
`~formを提出する$~algoの文脈における各種~挙動は、
次に従うとする：
◎
The behaviors are as follows:
</p>

<dl>
	<dt>
`変異-動作~URL@
◎
Mutate action URL
</dt>
	<dd>
		<ol>
			<li>
%~pair群 ~LET `名値~pair~listに変換する$( %~entry~list )
◎
Let pairs be the result of converting to a list of name-value pairs with entry list.
</li>
			<li>
%構文解析した動作 の`~query$url ~SET `~form_urlencoded直列化器$( %~pair群, %符号化法 )
◎
Let query be the result of running the application/x-www-form-urlencoded serializer with pairs and encoding.
◎
Set parsed action's query component to query.
</li>
			<li>
`~navigateを計画する$( %構文解析した動作 )
◎
Plan to navigate to parsed action.
</li>
		</ol>
	</dd>

	<dt>
`~entity本体として提出する@
◎
Submit as entity body
</dt>
	<dd>
		<ol>
			<li>
~Assert：
%~method ~EQ `POST$st
【この手続きを（間接的に）呼出した`~formを提出する$~algoの中で設定された %~method 】
◎
Assert: method is POST.
</li>
			<li>
( %本体, %~MIME型 ) ~LET ( ε, ε )
</li>
			<li>
<p>
%~enctype に応じて：
◎
Switch on enctype:
</p>
				<dl class="switch">
					<dt>`application/x-www-form-urlencoded$v</dt>
					<dd>
						<ol>
							<li>
%~pair群 ~LET `名値~pair~listに変換する$( %~entry~list )
◎
Let pairs be the result of converting to a list of name-value pairs with entry list.
</li>
							<li>
%本体 ~SET `~form_urlencoded直列化器$( %~pair群, %符号化法 )
◎
Let body be the result of running the application/x-www-form-urlencoded serializer with pairs and encoding.
</li>
							<li>
%本体 ~SET `~UTF-8符号化する$( %本体 )
◎
Set body to the result of encoding body.
</li>
							<li>
%~MIME型 ~SET ``^`application/x-www-form-urlencoded$mt``^
◎
Let mimeType be `application/x-www-form-urlencoded`.
</li>
						</ol>
					</dd>

					<dt>`multipart/form-data$v</dt>
					<dd>
						<ol>
							<li>
%本体 ~SET `~mp_form_dataとして符号化する$( %~pair群, %符号化法 )
◎
Let body be the result of running the multipart/form-data encoding algorithm with entry list and encoding.
</li>
							<li>
%境界~文字列 ~LET 前~段を走らすときに生成した`~mp_form_data境界~文字列$
◎
↓</li>
							<li>
%~MIME型 ~SET 次を順に連結した結果
⇒＃
`multipart/form-data; boundary=^bl,
`同型に符号化する$( %境界~文字列 )
◎
Let mimeType be the isomorphic encoding of the concatenation of "multipart/form-data; boundary=" and the multipart/form-data boundary string generated by the multipart/form-data encoding algorithm.
</li>
						</ol>
					</dd>

					<dt>`text/plain$v</dt>
					<dd>
						<ol>
							<li>
%~pair群 ~LET `名値~pair~listに変換する$( %~entry~list )
◎
Let pairs be the result of converting to a list of name-value pairs with entry list.
</li>
							<li>
%本体 ~SET `~text_plainとして符号化する$( %~pair群 )
◎
Let body be the result of running the text/plain encoding algorithm with pairs.
</li>
							<li>
%本体 ~SET `符号化法を利用して符号化する$( %本体, %符号化法 )
◎
Set body to the result of encoding body using encoding.
</li>
							<li>
%~MIME型 ~SET `text/plain^bl
◎
Let mimeType be `text/plain`.
</li>
						</ol>
					</dd>
				</dl>
			</li>
			<li>
%~POST資源 ~LET 新たな`~POST資源$
— その
⇒＃
`要請~本体$pR ~SET %本体,
`要請~内容~型$pR ~SET %~MIME型
◎
Plan to navigate to parsed action given a POST resource whose request body is body and request content-type is mimeType.
</li>
			<li>
`~navigateを計画する$( %構文解析した動作, %~POST資源 )
◎
↑</li>
		</ol>
	</dd>

	<dt>
`~Get動作~URL@
◎
Get action URL
</dt>
	<dd>
<p>
`~navigateを計画する$( %構文解析した動作 )
◎
Plan to navigate to parsed action.
</p>

<p class="note">注記：
%~entry~list は破棄される。
◎
entry list is discarded.
</p>
	</dd>

	<dt>
`~header列を伴う~Mail@
◎
Mail with headers
</dt>
	<dd>
		<ol>
			<li>
%~pair群 ~LET `名値~pair~listに変換する$( %~entry~list )
◎
Let pairs be the result of converting to a list of name-value pairs with entry list.
</li>
			<li>
%~header列 ~LET
`~form_urlencoded直列化器$( %~pair群, %符号化法 )
◎
Let headers be the result of running the application/x-www-form-urlencoded serializer with pairs and encoding.
</li>
			<li>
%~header列 内の各 文字 `002B^U `+^smb を 文字列 `%20^l に置換する
◎
Replace occurrences of U+002B PLUS SIGN characters (+) in headers with the string "%20".
</li>
			<li>
%構文解析した動作 の`~query$url ~SET %~header列
◎
Set parsed action's query to headers.
</li>
			<li>
`~navigateを計画する$( %構文解析した動作 )
◎
Plan to navigate to parsed action.
</li>
		</ol>
	</dd>

	<dt>
`本体として~Mailする@
◎
Mail as body
</dt>
	<dd>
		<ol>
			<li>
%本体 ~LET ε
◎
↓</li>
			<li>
%~pair群 ~LET `名値~pair~listに変換する$( %~entry~list )
◎
Let pairs be the result of converting to a list of name-value pairs with entry list.
</li>
			<li>
<p>
~IF［
%~enctype ~EQ `text/plain$v
］：
◎
Switch on enctype:
• text/plain
</p>
				<ol>
					<li>
%本体 ~SET `~text_plainとして符号化する$( %~pair群 )
◎
Let body be the result of running the text/plain encoding algorithm with pairs.
</li>
					<li>
%本体 ~SET `文字列を~UTF-8~percent-符号化する$( %本体, `~path~percent-符号化-集合$【！既定の符号化-集合】 )
`URL$r
◎
Set body to the result of running UTF-8 percent-encode on body using the default encode set. [URL]
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%本体 ~SET `~form_urlencoded直列化器$( %~pair群, %符号化法 )
◎
Otherwise
• Let body be the result of running the application/x-www-form-urlencoded serializer with pairs and encoding.
</li>
			<li>
%~query ~LET %構文解析した動作 の`~query$url
◎
↓</li>
			<li>
~IF［
%~query ~EQ ~NULL
］
⇒
%~query ~SET 空~文字列
◎
If parsed action's query is null, then set it to the empty string.
</li>
			<li>
~IF［
%~query ~NEQ 空~文字列
］
⇒
%~query に 1 個の文字 `0026^U `&amp;^smb を付加する
◎
If parsed action's query is not the empty string, then append a single U+0026 AMPERSAND character (&amp;) to it.
</li>
			<li>
%~query に `body=^l を付加する
◎
Append "body=" to parsed action's query.
</li>
			<li>
%~query に %本体 を付加する
◎
Append body to parsed action's query.
</li>
			<li>
%構文解析した動作 の`~query$url ~SET %~query
◎
↑</li>
			<li>
`~navigateを計画する$( %構文解析した動作 )
◎
Plan to navigate to parsed action.
</li>
		</ol>
	</dd>
</dl>
</div>

				</section>
				<section id="constructing-form-data-set">
<h5 title="Constructing the entry list">4.10.22.4. ~entry~listの構築-法</h5>

<p>
`~entry~list@
は、
一群の`~entry$fDからなる`~list$であり，
概して~formの内容を表現する。
`~entry@fD
は、
次に挙げるものからなる~tupleである：
◎
An entry list is a list of entries, typically representing the contents of a form.＼
An entry is a tuple consisting of＼
</p>
<ul>
	<li>
`名@fD
⇒
`~scalar値~文字列$
◎
a name (a scalar value string)＼
</li>
	<li>
`値@fD
⇒
`~scalar値~文字列$／ `File$I ~obj
◎
and a value (either a scalar value string or a File object).
</li>
</ul>

<div class="algo">
<p>
`~entryを作成する@
~algoは
所与の
( 文字列 %名, 文字列または `Blob$I ~obj %値, `~scalar値~文字列$ %~filename ~DF ε )
に対し：
◎
To create an entry given a string name, a string or Blob object value, and optionally a scalar value string filename:
</p>
<ol>
	<li>
%名 ~SET %名 を`~scalar値~文字列に変換する$
◎
Set name to the result of converting name into a scalar value string.
</li>
	<li>
~IF［
%値 は文字列である
］
⇒
%値 ~SET %値 を`~scalar値~文字列に変換する$
◎
If value is a string, then set value to the result of converting value into a scalar value string.
</li>
	<li>
<div>
<p>
~ELIF［
%値 は `File$I ~objでない
］~OR［
%~filename ~NEQ ε
］：
</p>
		<ol>
			<li>
%値 ~SET  %値 と同じ~byte列を表現する新たな `File$I ~obj
</li>
			<li>
%値 の `~nameF$m 属性~値 ~SET ［
%~filename ~NEQ ε ならば %~filename ／
~ELSE_ `blob^l
］
</li>
		</ol>
◎
Otherwise:
• If value is not a File object, then set value to a new File object, representing the same bytes, whose name attribute value is "blob".
• If filename is given, then set value to a new File object, representing the same bytes, whose name attribute is filename.
</div>

<p class="note">注記：
この演算は、［
%~filename ~NEQ ε の場合 ／
渡された `Blob$I は `File$I ~objでない場合
］でも，新たな `File$I ~objを作成することになる。
それらの事例では、
渡された `Blob$I ~objの識別情報は保たれない。
◎
These operations will create a new File object if either filename is given or the passed Blob is not a File object. In those cases, the identity of the passed Blob object is not kept.
</p>
	</li>
	<li>
~RET 次を伴う新たな`~entry$fD
⇒＃
`名$fD ~SET %名,
`値$fD ~SET %値
◎
Return an entry whose name is name and whose value is value.
</li>
</ol>
</div>

<div class="algo">
<p>
`~entry~listを構築する@
~algoは、
所与の
⇒＃
%~form,
%提出元 ~DF ~NULL,
%符号化法 ~DF `~UTF-8$
◎終
に対し：
◎
To construct the entry list given a form, an optional submitter (default null), and an optional encoding (default UTF-8):
</p>
<ol>
	<li>
~IF［
%~form の`~entry~list構築-中か$ ~EQ ~T
］
⇒
~RET ~NULL
◎
If form's constructing entry list is true, then return null.
</li>
	<li>
%~form の`~entry~list構築-中か$ ~SET ~T
◎
Set form's constructing entry list to true.
</li>
	<li>
%~control群 ~LET ［
%~form が`所有して$いる`提出-可能$な要素
］すべてからなる，`~tree順序$による~list
◎
Let controls be a list of all the submittable elements whose form owner is form, in tree order.
</li>
	<li>
%~entry~list ~LET 新たな空な`~entry~list$
◎
Let entry list be a new empty entry list.
</li>
	<li>
<p>
%~control群 を成す
~EACH( %欄 )
に対し：
◎
For each element field in controls, in tree order:
</p>
		<ol>
			<li>
%状態 ~LET ［
%欄 は `input$e 要素であるならば その `type$a 属性の状態 ／
~ELSE_ `他の要素^i
］
◎
↓</li>
			<li>
<p>
~IF［
~OR↓
］…
◎
If any of the following are true:
</p>

				<ul>
					<li>
%欄 の先祖に `datalist$e 要素がある
◎
field has a datalist element ancestor;
</li>
					<li>
%欄 は`不能化されて$feいる
◎
field is disabled;
</li>
					<li>
［
%欄 は`~button$である
］~AND［
%欄 ~NEQ %提出元
］
◎
field is a button but it is not submitter;
</li>
					<li>
［
%状態 ~IN { `Checkbox$st, `Radio$st }
］~AND［
%欄 の`~check有りか$fe ~EQ ~F
］
◎
field is an input element whose type attribute is in the Checkbox state and whose checkedness is false; or
◎
field is an input element whose type attribute is in the Radio Button state and whose checkedness is false,
</li>
				</ul>
<p>
…ならば
⇒
~CONTINUE
◎
then continue.
</p>
			</li>
			<li>
%名 ~LET ［
%欄 は `name$a 属性を有するならば その値 ／
~ELSE_ 空~文字列
］
◎
↓</li>
			<li>
<p>
~IF［
%状態 ~EQ `Image$st
］：
◎
If the field element is an input element whose type attribute is in the Image Button state, then:
</p>
				<ol>
					<li>
~IF［
%欄 ~NEQ %提出元
］
⇒
~CONTINUE
◎
If the field element is not submitter, then continue.
</li>
					<li>
~IF［
%名 ~NEQ 空~文字列
］
⇒
%名 の末尾に `002E^U `.^smb を付加する
◎
If the field element has a name attribute specified and its value is not the empty string, let name be that value followed by U+002E (.). Otherwise, let name be the empty string.
</li>
					<li>
%x名 ~LET 次を順に`連結する$
⇒＃
%名,
`0078^U `x^smb
◎
Let namex be the concatenation of name and U+0078 (x).
</li>
					<li>
%y名 ~LET 次を順に`連結する$
⇒＃
%名,
`0079^U `y^smb
◎
Let namey be the concatenation of name and U+0079 (y).
</li>
					<li>
( %x, %y ) ~LET %欄 の`選定された座標$
◎
Let (x, y) be the selected coordinate.
</li>
					<li>
%~entry~list に次の結果を`付加する$
⇒
`~entryを作成する$( %x名, %x )
◎
Create an entry with namex and x, and append it to entry list.
</li>
					<li>
%~entry~list に次の結果を`付加する$
⇒
`~entryを作成する$( %y名, %y )
◎
Create an entry with namey and y, and append it to entry list.
</li>
					<li>
~CONTINUE
◎
Continue.
</li>
				</ol>
			</li>
			<li>
~IF［
%欄 は`~formに所有され得る~custom要素$である
］
⇒＃
`~entry構築~algo$cF( %欄, %~entry~list ) を遂行する；
~CONTINUE
◎
If the field is a form-associated custom element, then perform the entry construction algorithm given field and entry list, then continue.
</li>
			<li>
~IF［
%名 ~EQ 空~文字列
］
⇒
~CONTINUE
◎
If either the field element does not have a name attribute specified, or its name attribute's value is the empty string, then continue.
◎
Let name be the value of the field element's name attribute.
</li>
			<li>
<p>
%状態 に応じて, または［
%状態 ~EQ `他の要素^i
］の場合は %欄 に応じて：
◎
↓</p>

				<ul class="switch">
					<li>
`select$e 要素である
⇒
%欄 の`~option_e~list$を成す
~EACH( `option$e 要素 %option )
に対し
⇒
~IF［
%option の`選択状態$opt ~EQ ~T
］~AND［
%option は`不能化されて$optいない
］
⇒
%~entry~list に次の結果を`付加する$
⇒
`~entryを作成する$( %名, %option の`値$opt )
◎
If the field element is a select element, then for each option element in the select element's list of options whose selectedness is true and that is not disabled, create an entry with name and the value of the option element, and append it to entry list.
</li>
					<li>
<p>
`Checkbox$st ／ `Radio$st ：
◎
Otherwise, if the field element is an input element whose type attribute is in the Checkbox state or the Radio Button state, then:
</p>
						<ol>
							<li>
%値 ~LET ［
%欄 は `value$a 属性を有するならば その値 ／
~ELSE_ 文字列 `on^l
］
◎
If the field element has a value attribute specified, then let value be the value of that attribute; otherwise, let value be the string "on".
</li>
							<li>
%~entry~list に次の結果を`付加する$
⇒
`~entryを作成する$( %名, %値 )
◎
Create an entry with name and value, and append it to entry list.
</li>
						</ol>
					</li>
					<li>
<p>
`File$st ：
◎
Otherwise, if the field element is an input element whose type attribute is in the File Upload state, then:
</p>
						<ol>

							<li>
%~file~list ~LET %欄 の`選択された~file~list$
◎
↓</li>
							<li>
~IF［
%~file~list は空である
］
⇒
%~entry~list に次の結果を`付加する$
⇒
`~entryを作成する$( %名, 次のようにされた新たな `File$I ~obj )
⇒＃
名前 ~SET 空~文字列,
型 ~SET `application/octet-stream$mt
本体 ~SET 空
◎
If there are no selected files, then create an entry with name and a new File object with an empty name, application/octet-stream as type, and an empty body, and append it to entry list.
</li>
							<li>
~ELSE
⇒
%~file~list を成す
~EACH( %~file )
に対し
⇒
%~entry~list に次の結果を`付加する$
⇒
`~entryを作成する$( %名, %~file を表現する新たな `File$I ~obj )
◎
Otherwise, for each file in selected files, create an entry with name and a File object representing the file, and append it to entry list.
</li>
						</ol>
					</li>
					<li>
<p>
`Hidden$st：
◎
Otherwise, if the field element is an input element whose type attribute is in the Hidden state＼
</p>
						<ol>
							<li>
~IF［
%名 は "`_charset_$v" に`~ASCII大小無視$で合致する
］
⇒
~GOTO `その他^i
◎
and name is an ASCII case-insensitive match for "_charset_":
</li>
							<li>
%charset ~LET %符号化法 の`名前$enc
◎
Let charset be the name of encoding.
</li>
							<li>
%~entry~list に次の結果を`付加する$
⇒
`~entryを作成する$( %名, %charset )
◎
Create an entry with name and charset, and append it to entry list.
</li>
						</ol>
					</li>
					<li>
その他
⇒
%~entry~list に次の結果を`付加する$
⇒
`~entryを作成する$( %名, %欄 の`値$fe )
◎
Otherwise, create an entry with name and the value of the field element, and append it to entry list.
</li>

				</ul>
			</li>
			<li>
<p>
~IF［
%欄 は `dirname$a 属性を有していて，その値 ~NEQ 空~文字列
］~AND［
%欄 は`自動~方向性を伴う~formに所有され得る要素$である
］：
◎
If the element has a dirname attribute, that attribute's value is not the empty string, and the element is an auto-directionality form-associated element: 
</p>
				<ol>
					<li>
%方向~名 ~LET %欄 の `dirname$a 属性の値
◎
Let dirname be the value of the element's dirname attribute.
</li>
					<li>
%方向 ~LET %欄 の`方向性$に応じて［
`~ltr$i ならば `ltr^l ／
`~rtl$i ならば `rtl^l
］
◎
Let dir be the string "ltr" if the directionality of the element is 'ltr', and "rtl" otherwise (i.e., when the directionality of the element is 'rtl').
</li>
					<li>
%~entry~list に次の結果を`付加する$
⇒
`~entryを作成する$( %方向~名, %方向 )
◎
Create an entry with dirname and dir, and append it to entry list.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%~form~data ~LET 新たな `FormData$I ~obj
— その
⇒
`~entry~list$fD ~SET %~entry~list
◎
Let form data be a new FormData object associated with entry list.
</li>
	<li>
`~eventを発火する$( %~form, `formdata$et, `FormDataEvent$I )
— 次のように初期化して
⇒＃
`formData$m 属性 ~SET %~form~data,
`bubbles$m 属性 ~SET ~T
◎
Fire an event named formdata at form using FormDataEvent, with the formData attribute initialized to form data and the bubbles attribute initialized to true.
</li>
	<li>
%~form の`~entry~list構築-中か$ ~SET ~F
◎
Set form's constructing entry list to false.
</li>
	<li>
~RET `~listを~cloneする$( %~entry~list )
◎
Return a clone of entry list.
</li>
</ol>
</div>

				</section>
				<section id="selecting-a-form-submission-encoding">
<h5 title="Selecting a form submission encoding">4.10.22.5. ~form提出~用の符号化法の選定-法</h5>

<div class="algo">
<p>
所与の時点における，
`form$e 要素 %~form の
`符号化法@form
は、［
`符号化法から出力~符号化法を取得する$( 次の手続きを走らせた結果 )
］の結果を返す：
</p>
<ol>
	<li>
~IF［
%~form は `accept-charset$a 属性を有さない
］
⇒
~RET 文書【 %~form の`~node文書$】の`符号化法$doc
</li>
	<li>
［
`~ASCII空白で分割する$( %~form の `accept-charset$a 属性の値 )
］の結果を成す
~EACH( %~token )
に対し
⇒
~IF［
`~labelから符号化法を取得する$( %~token ) の結果 ~NEQ `失敗^i
］
⇒
~RET その結果
</li>
	<li>
~RET `~UTF-8$
</li>
</ol>

◎
If the user agent is to pick an encoding for a form, it must run the following steps:
• Let encoding be the document's character encoding.
• If the form element has an accept-charset attribute, set encoding to the return value of running these substeps:
•• Let input be the value of the form element's accept-charset attribute.
•• Let candidate encoding labels be the result of splitting input on ASCII whitespace.
•• Let candidate encodings be an empty list of character encodings.
•• For each token in candidate encoding labels in turn (in the order in which they were found in input), get an encoding for the token and, if this does not result in failure, append the encoding to candidate encodings.
•• If candidate encodings is empty, return UTF-8.
•• Return the first encoding in candidate encodings.
• Return the result of getting an output encoding from encoding.
</div>

				</section>
				<section id="converting-an-entry-list-to-a-list-of-name-value-pairs">
<h5 title="Converting an entry list to a list of name-value pairs">4.10.22.6. ~entry~listから名値~pair~listへの変換-法</h5>

<p>
［
`application/x-www-form-urlencoded$mt として符号化する／
`~text_plainとして符号化する$
］~algoは、
0 個以上の名値~pairからなる~listをとる
— そこでの各~pairの値は文字列でなければナラナイ
（対して，`~entry~list$を成す~itemの値は `File$I にもなり得る）。
次の~algoは、
この変換を遂行する。
◎
The application/x-www-form-urlencoded and text/plain encoding algorithms take a list of name-value pairs, where the values must be strings, rather than an entry list where the value can be a File. The following algorithm performs the conversion.
</p>

<div class="algo">
<p>
`名値~pair~listに変換する@
~algoは、
所与の
( `~entry~list$ %~entry~list )
に対し：
◎
To convert to a list of name-value pairs an entry list entry list, run these steps:
</p>
<ol>
	<li>
%~list ~LET 新たな`~list$
◎
Let list be an empty list of name-value pairs.
</li>
	<li>
<p>
%~entry~list を成す
~EACH( %~entry )
に対し：
◎
For each entry of entry list:
</p>
		<ol>
			<li>
%名 ~LET `改行文字を~form~data用に正規化する$( %~entry の`名$fD )
◎
Let name be entry's name, with every occurrence of U+000D (CR) not followed by U+000A (LF), and every occurrence of U+000A (LF) not preceded by U+000D (CR), replaced by a string consisting of U+000D (CR) and U+000A (LF).
</li>
			<li>
%値 ~LET %~entry の`値$fD
◎
↓</li>
			<li>
~IF［
%値 は `File$I ~objである
］
⇒
%値 ~SET  %値 の `~nameF$m
◎
If entry's value is a File object, then let value be entry's value's name. Otherwise, let value be entry's value.
</li>
			<li>
%値 ~SET `改行文字を~form~data用に正規化する$( %値 )
◎
Replace every occurrence of U+000D (CR) not followed by U+000A (LF), and every occurrence of U+000A (LF) not preceded by U+000D (CR), in value, by a string consisting of U+000D (CR) and U+000A (LF).
</li>
			<li>
%~list に新たな名値~pair ( %名 / %値 ) を`付加する$
◎
Append to list a new name-value pair whose name is name and whose value is value.
</li>
		</ol>
	</li>
	<li>
~RET %~list
◎
Return list.
</li>
</ol>
</div>

<div class="algo">
<p>
`改行文字を~form~data用に正規化する@
~algoは、
所与の
( 文字列 %文字列 )
に対し：
</p>
<ol>
	<li>
以下においては
⇒＃
`LF^i は 文字 `000A^U `LINE FEED^cn ／
`CR^i は 文字 `000D^U `CARRIAGE RETURN^cn ／
`CRLF^i は［ 1 個の `CR^i, 1 個の `LF^i ］並びが成す文字列
◎終
を表すとする。
</li>
	<li>
%文字列 ~SET ［
%文字列 を成す各 `LF^i のうち直前の文字は［
無い／ `CR^i でない
］もの
］を `CRLF^i に置換した結果
</li>
	<li>
%文字列 ~SET ［
%文字列 を成す各 `CR^i のうち直後の文字は［
無い／ `LF^i でない
］もの
］を `CRLF^i に置換した結果
</li>
	<li>
~RET %文字列
</li>
</ol>

<p class="trans-note">【
この~algoは、
他所を簡潔に記すために，この訳に導入している。
これは、
`改行文字を正規化する$~algoの “逆” に似たことを行う。
】</p>
</div>

				</section>
				<section id="url-encoded-form-data">
<h5 title="URL-encoded form data">4.10.22.7. ~URLに符号化された~form~data</h5>

<p id="application-x-www-form-urlencoded-encoding-algorithm">
<span id="application/x-www-form-urlencoded-encoding-algorithm"></span>
`application/x-www-form-urlencoded$mt の詳細は
`URL^cite `URL$r
を見よ。
◎
See URL for details on application/x-www-form-urlencoded. [URL]
</p>

				</section>
				<section id="multipart-form-data">
<h5 title="Multipart form data">4.10.22.8. ~multipart~form~data</h5>

<div class="algo">
<p>
`~mp_form_dataとして符号化する@
~algoは、
所与の 
( `~entry~list$ %~entry~list, `符号化法$ %符号化法 )
に対し：
◎
The multipart/form-data encoding algorithm, given an entry list entry list and an encoding encoding, is as follows:
</p>
<ol>
	<li>
<p>
%~entry~list を成す
~EACH( %~entry )
に対し：
◎
For each entry of entry list:
</p>
		<ol>
			<li>
%~entry の`名$fD ~SET `改行文字を~form~data用に正規化する$( %~entry の名 )
◎
Replace every occurrence of U+000D (CR) not followed by U+000A (LF), and every occurrence of U+000A (LF) not preceded by U+000D (CR), in entry's name, by a string consisting of a U+000D (CR) and U+000A (LF).
</li>
			<li>
~IF［
%~entry の`値$fDは `File$I ~objでない
］
⇒
%~entry の`値$fD ~SET `改行文字を~form~data用に正規化する$( %~entry の値 )
◎
If entry's value is not a File object, then replace every occurrence of U+000D (CR) not followed by U+000A (LF), and every occurrence of U+000A (LF) not preceded by U+000D (CR), in entry's value, by a string consisting of a U+000D (CR) and U+000A (LF).
</li>
		</ol>
	</li>
	<li>
<p>
~RET ［
`RFC7578$r
`Returning Values from Forms: multipart/form-data^cite
に述べられる規則
］を利用して，
%~entry~list を符号化した結果の~byte列
— その際には、
以下に与える条件に従うモノトスル：
◎
Return the byte sequence resulting from encoding the entry list using the rules described by RFC 7578, Returning Values from Forms: multipart/form-data, given the following conditions: [RFC7578]
</p>
		<ul>
			<li>
%~entry~list を成す各`~entry$fDは、
ある `~field^i を与える
— ~entryの ( `名$fD, `値$fD ) が ( `~field名^i, `~field値^i ) を与える。
◎
Each entry in entry list is a field, the name of the entry is the field name and the value of the entry is the field value.
</li>
			<li>
各`~field^i は、
生成される `multipart/form-data$mt 資源を成す各~部位に対応する。
各~部位の順序は、
%~entry~list 成す~entryたちの順序と同じにする。
`名$fDが同じ複数の`~entry$fDは，別個な~fieldとして扱う。
◎
The order of parts must be the same as the order of fields in entry list. Multiple entries with the same name must be treated as distinct fields.
</li>
			<li>
<p>
各~部位における `~field^i に対しては、
~file~fieldの `~field値^i を除き：
◎
↓</p>
				<ul>
					<li>
それらの［
`~field名^i／`~field値^i
］, および［
~file~field用の~filename
］を，次の結果の~byte列に変換した結果に設定する
⇒
`符号化法を利用して符号化する$( 当の `~field^i を与える~entryの［名／値］, %符号化法 )
◎
Field names, field values for non-file fields, and filenames for file fields, in the generated multipart/form-data resource must be set to the result of encoding the corresponding entry's name or value with encoding, converted to a byte sequence.
</li>
					<li>
ただし，~file~field用の［
`~field名^i, ~filename
］に対しては、
前項の結果に対し，次に挙げる各~byteをその直後に与える~byte列に置換して~escapeするモノトスル
— 他の~escapeは遂行しないモノトスル
⇒＃
`0A^X (`LF^cn) → `%0A^bl ／
`0D^X (`CR^cn) → `%0D^bl ／
`22^X `"^smb → `%22^bl
◎
For field names and filenames for file fields, the result of the encoding in the previous bullet point must be escaped by replacing any 0x0A (LF) bytes with the byte sequence `%0A`, 0x0D (CR) with `%0D` and 0x22 (") with `%22`. The user agent must not perform any other escapes.
</li>
				</ul>
<p class="trans-note">【
~file~fieldとは、
それを与える~entryの値が `File$I ~objである~fieldを指す。
】</p>
			</li>
			<li>
~file~field以外の~fieldに対応する部位には、
`Content-Type$h ~headerは指定しない。
◎
The parts of the generated multipart/form-data resource that correspond to non-file fields must not have a `Content-Type` header specified.
</li>
		</ul>
<p>
`~mp_form_data境界~文字列@
とは、
~UAが，この~algoが返す値を生成するときに利用する境界~文字列である。
（この値は、［
この~algoが生成する~form提出~payload
］の~MIME型を生成するときに利用される。）
◎
The boundary used by the user agent in generating the return value of this algorithm is the multipart/form-data boundary string. (This value is used to generate the MIME type of the form submission payload generated by this algorithm.)
</p>
	</li>
</ol>
</div>

<p>
`multipart/form-data$mt ~payloadを解釈する方法の詳細は、
`RFC7578$r を見よ。
◎
For details on how to interpret multipart/form-data payloads, see RFC 7578. [RFC7578]
</p>

				</section>
				<section id="plain-text-form-data">
<h5 title="Plain text form data">4.10.22.9. 素な~text~form~data</h5>

<div class="algo">
<p>
`~text_plainとして符号化する@
~algoは、
所与の
( 名値~pairたちが成す~list %~pair群 )
に対し：
◎
The text/plain encoding algorithm, given a list of name-value pairs pairs, is as follows:
</p>
<ol>
	<li>
%結果 ~LET 空~文字列
◎
Let result be the empty string.
</li>
	<li>
<p>
%~pair群 を成す
~EACH( %~pair )
に対し：
◎
For each pair in pairs:
</p>
		<ol>
			<li>
%結果 に次を順に付加する
⇒＃
%~pair の名,
文字 `003D^U `=^smb,
%~pair の値,
文字 `000D^U `CR^cn,
文字 `000A^U `LF^cn
◎
Append pair's name to result.
◎
Append a single U+003D EQUALS SIGN character (=) to result.
◎
Append pair's value to result.
◎
Append a U+000D CARRIAGE RETURN (CR) U+000A LINE FEED (LF) character pair to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<p>
`text/plain$mt 形式を利用する~payloadは、
人から読まれる用途に意図される。
その形式は多義的なので、
~computerからは依拠-可能に解釈できない
（例えば、
値~内の~literal改行文字と 値の終端にある改行文字を判別する仕方はない）。
◎
Payloads using the text/plain format are intended to be human readable. They are not reliably interpretable by computer, as the format is ambiguous (for example, there is no way to distinguish a literal newline in a value from the newline at the end of the value).
</p>

				</section>
				<section id="the-submitevent-interface">
<h5 title="The SubmitEvent interface">4.10.22.10. `SubmitEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `SubmitEvent@I : `Event$I {
  constructor(DOMString %type, optional `SubmitEventInit$I %eventInitDict = {});

  readonly attribute `HTMLElement$I? `submitter$m;
};

dictionary `SubmitEventInit@I : `EventInit$I {
  `HTMLElement$I? submitter = null;
};
</pre>

<dl class="domintro">
	<dt>%event.`submitter$m</dt>
	<dd>
`~form提出$を誘発した`提出-~button$を表現している要素を返す
— 提出が~buttonから誘発されたものでない場合、
~NULL を返す。
◎
Returns the element representing the submit button that triggered the form submission, or null if the submission was not triggered by a button.
</dd>
</dl>

<div class="algo">
`submitter@m
取得子~手続きは、
初期化-時の値を返す。
◎
The submitter attribute must return the value it was initialized to.
</div>

				</section>
				<section id="the-formdataevent-interface">
<h5 title="The FormDataEvent interface">4.10.22.11. `FormDataEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `FormDataEvent@I : `Event$I {
  constructor(DOMString %type, `FormDataEventInit$I %eventInitDict);

  readonly attribute `FormData$I `formData$m;
};

dictionary `FormDataEventInit@I : `EventInit$I {
  required `FormData$I formData;
};
</pre>

<dl class="domintro">
	<dt>%event.`formData$m</dt>
	<dd>
~target `form$e が所有している要素の名前と値を表現している `FormData$I ~objを返す。
返される~obj上の演算は、
提出される~form~dataに影響することになる。
◎
Returns a FormData object representing names and values of elements associated to the target form. Operations on the FormData object will affect form data to be submitted.
</dd>
</dl>

<div class="algo">
<p>
`formData@m
取得子~手続きは、
初期化-時の値を返す。
◎
The formData attribute must return the value it was initialized to.＼
</p>

<p>
これは、［
`form$e が提出されるとき`構築-＠#constructing-the-form-data-set$された
`~entry~list$
］を結付けている `FormData$I ~objを表現する。
◎
It represents a FormData object associated to the entry list that is constructed when the form is submitted.
</p>
</div>

				</section>
			</section>
			<section id="resetting-a-form">
<h4 title="Resetting a form">4.10.23. ~formの再設定-法</h4>

<div class="algo">
<p>
`~formを再設定する@
~algoは、
所与の
( `form$e 要素 %~form )
に対し：
◎
When a form element form is reset, run these steps:
</p>
<ol>
	<li>
%再設定するか ~LET
`~eventを発火する$( %~form, `reset$et )
— 次のように初期化して
⇒＃
`bubbles$m 属性 ~SET ~T,
`cancelable$m 属性 ~SET ~T
◎
Let reset be the result of firing an event named reset at form, with the bubbles and cancelable attributes initialized to true.
</li>
	<li>
~IF［
%再設定するか ~EQ ~T
］
⇒
%~form が`所有して$いる
~EACH( `再設定-可能$な %要素 )
に対し
⇒
%要素 の`再設定~algo$を呼出す
◎
If reset is true, then invoke the reset algorithm of each resettable element whose form owner is form.
</li>
</ol>
</div>

<p>
各 `再設定-可能$な要素は、
自前の
`再設定~algo@
を定義する。
それらの~algoの一部として，~form~controlに加えられた変更は、
利用者による変更には数えられない
（したがって、
例えば `input$et ~eventを発火させることはない）。
◎
Each resettable element defines its own reset algorithm. Changes made to form controls as part of these algorithms do not count as changes caused by the user (and thus, e.g., do not cause input events to fire).
</p>

			</section>
</main>

