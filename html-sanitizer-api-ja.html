<!DOCTYPE html><html><head><meta charset="utf-8">
<title>HTML Sanitizer API（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">

<style>
.wpt-block {
	background-color: var(--bg-color-2);
}
</style>


<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		persisted_parts: Object.create(null),
		generate: expand,
	};
	{
		const test_list = [
"sanitizer-sanitize",
"sanitizer-sanitizeFor",
"element-set-sanitized-html",
"sanitizer-config",
"sanitizer-query-config"
		];
		const parts = source_data.persisted_parts;
		test_list.forEach( (id) => {
			const suffix = 
				( id === 'sanitizer-query-config' ) ?
					'.https.tenative.html'
					: '.https.tentative.html';
			const href = id + suffix;
			const div = C('div');
			div.className = 'wpt-block';
			div.innerHTML = `
テスト：
<a href="https://wpt.fyi/results/sanitizer-api/${href}">${href}</a>
<a href="https://wpt.live/sanitizer-api/${href}">(live test)</a>
<a href="https://github.com/web-platform-tests/wpt/blob/master/sanitizer-api/${href}">(source)</a>
`;
			parts[`_test-${id}`] = div;
		});
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'tg':
	klass = 'e';
	text = `&lt;${key}&gt;`;
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'mc':
	text = 'constructor';
//	key = `new ${key}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U':
	text = `U+${text}`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2021-11-10
trans_update:2021-12-07
source_checked:211018
	page_state_key:＊
original_url:https://wicg.github.io/sanitizer-api/
abbr_url:HTMLsanitizer
spec_status:EDCG
ref_id_prefix:biblio-
ref_id_lowercase:true
	conformance:
	copyright:
trans_1st_pub:2021-11-16


●●class_map
E:error
e:element
tg:element
a:attr
et:event-type
U:code-point
cn:cp-name

●●tag_map
p:var
e:code
tg:code
a:code
E:code
I:code
m:code
U:span
cn:span
c:code
i:i
V:var

●●words_table1

●●words_table

	●略語
MathML:
XSS:
	~XSS:cross-site scripting
	~XSS:Cross-Site Scripting
	~XSS:XSS-style
mXSS:
	~mXSS:mXSS-
	~mXSS:mXSS-style
	~mXSS:Mutated Cross-Site Scripting
	~mXSS:Mutated XSS
環境設定0:config:環境設定

	●sanitizer
sanitize:
sanitizer:
Sanitizer:
	~Sanitizer:the Sanitizer
sanitization:
	~sanitizeした結果:after sanitization
走査-:traverse::~::トラバース
正則:regular:~
保つ:keepする:~

baseline:
funky:

	i.保つ:c.keep
	i.落とす:c.drop
	i.阻止する:c.block
	i.正則:c.regular
	i.未知:c.unknown
	i.~custom:c.custom

	●処理
繰返に:repeatedly:繰り返し
	文字列を文字列へ~~変換する:string-to-string
	手渡せる:can in turn hand over
	通過-:passed through
	〜を~~連結して:joining 〜 together
	同時に:simultaneously
	直列化-:un-parsing
	直列化-:unparsing
	直列化-:unparse
	構文解析し直す:re-parsing
	構文解析器:Parser
	接続されて$いない:unconnectedな
	構文解析器:Parser
	文字ごとに:character-for-character
	小文字~化:lowercased
	%属性:attr

	●構文
body:
	誤って入子にされた:misnested
	文字大小が混在した:mixed-case
	文字大小無視:case insensitive
	~ASCII:ascii
	文字大小無視:case insensitive
	構文解析器:Parser
	文字大小が混在した:mixed-case

	●保安
能動的:active::~::アクティブ
潔白:innocent:~
	見かけは潔白な:innocent-looking
不活:inert:~
	不活そうに見える:seemingly inert
策:strategy::~
脅威:threat::~
危険:dangerous:~
時限爆弾:time-bomb:~
悪用-:exploite:~
gadget:
clobbering:

	抗する:against
	信用-済みでない:untrusted
	~secureでない:insecure
	~script的:script-ish
	~script的な:script-y
	~script注入:script-injection
	許容-~list:allow-list

	●仕様

素朴:naive:~
目指す:aimする:~
機能上の:functionalな:~
種類:kind:~
網羅的:exhaustive:~
稀:rare:~
公表-:publish:~
立証-:prove:~
本物の:realな:~
	それを行うようになる:will 〜 do so in a fashion
維持-:retain:~
責務:responsibility:~
計画-:plan:~
微妙:subtle:~
審査-:vet:~
framework::::フレームワーク
遂げる:carry outする:~
外来の:foreignな:~
完結-:finalize:~
寄与-:contribute:~
有益:beneficial:~
適理:reasonable:~
現実:real-world:~
有効果:effective:有効
理解:understanding:~
給-:supply:~
移植-:graft:~
trouble::::トラブル
補助用の:helper:~
協力:cooperation:~
扱い:treatement:~
正当性:justification:~
無条件で:unconditionalに:~
惑わす:confuseする:~
発想:inspiration:~
教える:teachする:~
学習-:learn:~
由来:derivation:~
排-:eliminate:~
解決策:solution:~


	およそ見込まれない:unlikely
	それほどでもない:not so much
	ある程度の:some degree of
	多くの, ほとんどの:Most, many
	他のどの 〜 にも，およそ:pretty much every
	-:proudly
	4 種に~~分類される: fall into one of four classes
	自体:by themselves
	それ自体は:_per~se_
	それ自体:in its own right
	とり挙げ:pick
	へ進む:go with
	〜こそが:very
	得られ:yield
	見込みがずっと高い:much more likely to be
	~~強調したい:like to stress
	読み易さのため:ease of reading
	関心事:we are interested in
	しないこと。:you shall pretty
	はらんで:fraught with
	結局の所:ultimately
	表す:stands for
	表す:denote
	まさに:just
	感じられ:feel
	残り:the rest
	どうするか？:what if
	とは言え、:That being said
	つきまとう:come with
	ついてくる:comes with
	少ない:little
	挙動は 〜 一致する:behave identically
	どちらも，他方を:respective other
	次に従って決定される:Let 〜:
	該当する:applies to
	広く:widely
	普及している:popularな
	~~説明用:for illustration purposes
	~~説明用:for illustrative purposes
	~~説明用の:for illustration 
	~scriptを伴わない:non-scripting
	委ねられ:up to
	処する:deal with
	旧式な:outdated
	紛れもなく:arguably
	当の:your
	かまわない:free to
	~sanitizeした結果を その文脈から切り離しても:take the sanitization result and remove it from its context
	誤って適用すること:mis-applying
	起因する:stem from
	伝えな:inform
	潜む:creep
	よく知る立場にある:has a fairly good idea
	脆い:fragileな
	影響されない:unaffected
	見かけ:look
	覚えた:remember
	残す:leave
	転化-:turn into
	より厳密:stricter
	事実:in fact
	そこまでに:only
	数少ない:small-ish number of
	と同じく:just like
	助手:side-kick
	同類:companion
	併用されるもの:companion
	片棒を担ぐ:accomplice
	まだまだ:super-duper
	最終的:eventual
	結局の所:ultimately
	概念~化できる:One way to conceptualize this is to view
	許容しない:disallow
	および:plus
	ある程度の:some amount of
	委ねる:leave
	一箇所:in one place
	助け:help
	求まれる:we want
	§:subchapter
	制限-付きで:limited
	追加される:gains an additional
	〜だけ用い続ける:stick with
	もっぱら:sole
	能力がある:〜-capable
	^en:opt-out
	^en:W3C Standard
	^en:W3C Standards Track
	異なる何かに:differently
	この仕様の:our own
	追い易くする:easy to follow
	〜の仕様:specified
	依存する:dependent
	追い易くする:easy to follow
	忘れることはない:disappear
	あろう:maybe
	その場限りの:hacky
	手早く:quick
	草案:draft
	~~述べる:laid out
	可能性:possibility
	~~絶対的な:hard
	下位節:subsection

	●未分類
内包-:include::~
広義:inclusive:~
封入-:enclose:~
同等性:equality:~
template:
	~template化:templating
	template::::テンプレート
走査-:traverse::~::トラバース
隠蔽-:overshadow:~
cell::::セル

	属する:belong
	遅くなる:slower
	~code片:snippet
	含め:including
	伴われる:attached
	詰め込む:stuff
	利用元~空間:user-space
	包装する:wrapper a container that contains
	片:piece of
	置く:put
	書く:write
	-:unset
	-:branch
	改変せずに:unmodified
	側:side
	文書片:fragment
	渡-:pass
	ある時点:point in time
	返す:pick
	合致しないこと:mismatch
	^e:iframe
	^en:cure53
	^en:Internet Explorer
	:PLAINTEXT state
	:RCDATA state

	●指示語

	(2):middle
	ほぼ:mostly
	どこでも:everywhere
	一群の:set of
	今:now
	後で:later
	~~上層:top-of
	当の:in question

●●original_id_map

●●mdn_urls

●●link_map


	●I
	■IDL
Exposed:~WEBIDL#Exposed
SecureContext:~WEBIDL#SecureContext

boolean:~WEBIDL#idl-boolean
undefined:~WEBIDL#idl-undefined
DOMString:~WEBIDL#idl-DOMString
record:~WEBIDL#idl-record
sequence:~WEBIDL#idl-sequence

E.TypeError:~WEBIDL#exceptiondef-typeerror

I.AttributeMatchList:#typedefdef-attributematchlist
I.Comment:~DOM4#comment
I.Document:~DOM4#document
I.DocumentFragment:~DOM4#documentfragment
I.Element:~DOM4#element
I.HTMLBaseElement:~HEmetadata#htmlbaseelement
I.HTMLButtonElement:~HEforms#htmlbuttonelement
I.HTMLDataElement:~HEtextlevel#htmldataelement
I.HTMLEmbedElement:~HEembed#htmlembedelement
I.HTMLFormElement:~HEforms#htmlformelement
I.HTMLHyperlinkElementUtils:~HTMLlinks#htmlhyperlinkelementutils
I.HTMLIFrameElement:~HEembed#htmliframeelement
I.HTMLInputElement:~HEinput#htmlinputelement
I.HTMLObjectElement:~HEembed#htmlobjectelement
I.HTMLParamElement:~HEembed#htmlparamelement
I.HTMLScriptElement:~HEscripting#htmlscriptelement
I.HTMLSlotElement:~HEscripting#htmlslotelement
I.HTMLTemplateElement:~HEscripting#htmltemplateelement
I.HTMLUnknownElement:~HTMLdom#htmlunknownelement
I.HTMLPortalElement:https://wicg.github.io/portals/

I.Sanitizer:#sanitizer
I.SanitizerConfig:#dictdef-sanitizerconfig
I.SetHTMLOptions:#dictdef-sethtmloptions
I.Text:~DOM4#text

m.new Sanitizer:#dom-sanitizer-sanitizer
mc.Sanitizer:#dom-sanitizer-sanitizer
	%config:#dom-sanitizer-sanitizer-config-config
m.sanitizer:#dom-sethtmloptions-sanitizer
m.sanitize:#dom-sanitizer-sanitize
	%input:#dom-sanitizer-sanitize-input-input
m.sanitizeFor:#dom-sanitizer-sanitizefor
	%element:#dom-sanitizer-sanitizefor-element-input-element
	%input:#dom-sanitizer-sanitizefor-element-input-input
m.getConfiguration:#dom-sanitizer-getconfiguration
m.getDefaultConfiguration:#dom-sanitizer-getdefaultconfiguration
m.setHTML:#dom-element-sethtml
	:#dom-element-sethtml-input-sanitizer
	%input:#dom-element-sethtml-input-options-input
	%options:#dom-element-sethtml-input-options-options
m.allowElements:#dom-sanitizerconfig-allowelements
m.blockElements:#dom-sanitizerconfig-blockelements
m.dropElements:#dom-sanitizerconfig-dropelements
m.allowAttributes:#dom-sanitizerconfig-allowattributes
m.dropAttributes:#dom-sanitizerconfig-dropattributes
m.allowCustomElements:#dom-sanitizerconfig-allowcustomelements
m.allowComments:#dom-sanitizerconfig-allowcomments

m.createDocumentFragment:~DOM4#dom-document-createdocumentfragment
m.innerHTML:~DOM4#widl-Element-innerHTML
~template内容:~HEscripting#template-contents
	m.content:~HEscripting#dom-template-content
m.protocol:~HTMLlinks#dom-hyperlink-protocol

	●tg
e.xmp:~HTMLobs#xmp
e.plaintext:~HTMLobs#plaintext
e.title:~HEmetadata#the-title-element
e.textarea:~HEforms#the-textarea-element
e.applet:~HTMLobs#applet
e.basefont:~HTMLobs#basefont
e.div:~HEgrouping#the-div-element
e.frame:~HTMLobs#frame
e.frameset:~HTMLobs#frameset
e.img:~HEimages#the-img-element
e.noembed:~HTMLobs#noembed
e.noframes:~HTMLobs#noframes
	e.nolayer:~HTMLobs#nolayer
e.noscript:~HEscripting#the-noscript-element
e.object:~HEembed#the-object-element
e.slot:~HEscripting#the-slot-element
e.table:~HEtables#the-table-element
e.td:~HEtables#the-td-element
e.template:~HEscripting#the-template-element

a.action:~HTMLforms#attr-fs-action
a.formaction:~HTMLforms#attr-fs-formaction
a.slot:~HTMLdom#attr-slot
a.data-:~HTMLdom#custom-data-attribute
a.allowpaymentrequest:https://www.w3.org/TR/payment-request/


	●用語

V.to_node:#_to_node

許容する要素~群:#element-allow-list
阻止する要素~群:#element-block-list
落とす要素~群:#element-drop-list
許容する属性~群:#attribute-allow-list
落とす属性~群:#attribute-drop-list
	~custom要素を許容するか:#allow-custom-elements-option
	~commentを許容するか:#allow-comments-option
~custom要素を許容する~option:#allow-custom-elements-option
~commentを許容する~option:#allow-comments-option
属性~照合-~map:#attribute-match-list
	属性~照合-~list:#attribute-match-list
合致して:#_matches-to-attribute-match-list

~sanitizeする:#sanitize
要素~用に~sanitizeする:#sanitizefor
	~sanitizeFor:#sanitizefor
要素~用に~sanitizeして設定する:#sanitizeandset
	~sanitizeAndSet:#sanitizeandset

要素~名を正規化する:#normalize-element-name
~Sanitizerを初期化する:#create-a-sanitizer
	~Sanitizerを作成する:#create-a-sanitizer
環境設定0を~queryする:#query-the-sanitizer-config
文書片を作成する:#create-a-document-fragment
文書片を~sanitizeする:#sanitize-a-document-fragment
~nodeを~sanitizeする:#sanitize-a-node
~funkyな要素を取扱う:#handle-funky-elements
~sanitizeする動作:#sanitize-action
より厳密な動作:#stricter-action
有効果な要素~環境設定:#effective-element-configuration
有効果な属性~環境設定:#effective-attribute-configuration
elm.種類:#element-kind
attr.種類:#attribute-kind
属性~用の有効果な環境設定を決定する:#determine-the-effective-configuration-for-an-attribute
要素~用の有効果な環境設定を決定する:#determine-the-effective-configuration-for-an-element
属性~用の~baseline環境設定を決定する:#determine-the-baseline-configuration-for-an-attribute
要素~用の~baseline環境設定を決定する:#determine-the-baseline-configuration-for-an-element
~baseline環境設定:#_baseline-configuration
要素~用の~baseline許容-~list:#baseline-element-allow-list
属性~用の~baseline許容-~list:#baseline-attribute-allow-list
既定の環境設定:#default-configuration
環境設定~obj:#configuration-object

	●用語（外部／補完
~ASCII小文字~化する:~INFRA#ascii-lowercase
	~EACH:~INFRA#list-iterate
~map:~INFRA#ordered-map
~list:~INFRA#list
文字列:~INFRA#string
~HTML名前空間:~INFRA#html-namespace

構築子~手続き:~WEBIDL#constructor-steps
内包する:~WEBIDL#include

~HTML構文解析器:~HTMLparsing#html-parser
	~HTML構文解析~algo:~HTMLparsing#parsing

素片を構文解析する:~DOM-Parsing#dfn-fragment-parsing-algorithm
https://w3c.github.io/DOM-Parsing/#dfn-fragment-parsing-algorithm

~custom要素:~HEcustom#custom-element

文書:~DOM4#concept-document
文書片:~DOM4#_concept-documentfragment
文書~要素:~DOM4#document-element
	m.documentElement:~DOM4#dom-document-documentelement
要素:~DOM4#concept-element
全~内容を~nodeで置換する:~DOM4#concept-node-replace-all
属性~list:~DOM4#concept-element-attribute
~nodeを~cloneする:~DOM4#concept-node-clone
要素を作成する:~DOM4#concept-create-element
要素~interface:~DOM4#concept-element-interface
広義~子孫:~DOM4#concept-tree-inclusive-descendant
~node:~DOM4#boundary-point-node
親:~DOM4#concept-tree-parent
~tree順序:~DOM4#concept-tree-order
妥当な~custom要素~名:~HEcustom#valid-custom-element-name
~nodeを付加する:~DOM4#concept-node-append
局所-名:~DOM4#concept-element-local-name
attr.局所-名:~DOM4#concept-attribute-local-name
~node文書:~DOM4#concept-node-document
接続されて:~DOM4#connected

~URL:~URL1#concept-url
	url.~scheme:~URL1#concept-url-scheme
妥当な~URL文字列:~URL1#valid-url-string

~event~handler内容~属性:~WAPI#event-handler-content-attributes
	~event~handler属性:~WAPI#event-handler-attributes


	●他
	:~HTMLparsing#plaintext-state
	:~HTMLparsing#rcdata-state
	:~HTMLparsing#parsing-main-inbody
	https://www.w3.org/community/about/agreements/cla/
	http://www.w3.org/community/
	https://www.w3.org/community/wicg/
	https://html.spec.whatwg.org/#non-conforming-features
	https://github.com/google/security-research-pocs/tree/master/script-gadgets
	#constants
	https://github.com/WICG/sanitizer-api/issues/72
	https://msdn.microsoft.com/en-us/library/cc848922(v=vs.85).aspx

●●ref_data


●●ref_normative

[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[DEFAULTS]
    ＜Sanitizer API Defaults＞. URL: https://github.com/WICG/sanitizer-api/blob/main/resources/defaults-derivation.html
[DOMPURIFY]
    ＜DOMPurify＞. URL: https://github.com/cure53/DOMPurify
[MXSS]
    ＜mXSS Attacks: Attacking well-secured Web-Applications by using innerHTML Mutations＞. URL: https://cure53.de/fp170.pdf
[MXSS1]
    ＜Mutation XSS via namespace confusion＞. URL: https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass/
[MXSS2]
    ＜CVE-2020-6802 Write-up＞. URL: https://www.checkmarx.com/blog/technical-blog/vulnerabilities-discovered-in-mozilla-bleach/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/


●●trans_metadata
<p>
~THIS_PAGEは、
~W3Cにより編集者草案（ Draft Community Group Report ）として公開された
<a href="~SPEC_URL">HTML Sanitizer API</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

このバージョン
	https://wicg.github.io/sanitizer-api/
課題追跡
	<a href="https://github.com/WICG/sanitizer-api/issues/">GitHub</a>

Editors:
	<a href="https://frederik-braun.com">Frederik Braun</a> (Mozilla) <a class="u-email email" href="mailto:fbraun@mozilla.com">fbraun@mozilla.com</a>
	<a href="https://cure53.de">Mario Heiderich</a> (Cure53) <a href="mailto:mario@cure53.de">mario@cure53.de</a>
	<a href="https://www.google.com">Daniel Vogelheim</a> (Google LLC) <a href="mailto:vogelheim@google.com">vogelheim@google.com</a>

commit 履歴
	https://github.com/WICG/sanitizer-api/commits/main

</script>
<body>

<!--%parts -->
<template id="_persisted_parts">

<pre
	id="_dgm-baseline-elements"
	class="include-code"
>
[
  "a",
  "abbr",
  "acronym",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "basefont",
  "bdi",
  "bdo",
  "bgsound",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "cite",
  "code",
  "col",
  "colgroup",
  "command",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "font",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "image",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "layer",
  "legend",
  "li",
  "link",
  "listing",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "meta",
  "meter",
  "nav",
  "nobr",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "picture",
  "plaintext",
  "popup",
  "portal",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "section",
  "select",
  "selectmenu",
  "slot",
  "small",
  "source",
  "span",
  "strike",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "tt",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "xmp"
]
</pre>

<pre
	id="_dgm-baseline-attributes"
	class="include-code"
>
[
  "abbr",
  "accept",
  "accept-charset",
  "accesskey",
  "action",
  "align",
  "alink",
  "allow",
  "allowfullscreen",
  "allowpaymentrequest",
  "alt",
  "anchor",
  "archive",
  "as",
  "async",
  "autocapitalize",
  "autocomplete",
  "autocorrect",
  "autofocus",
  "autopictureinpicture",
  "autoplay",
  "axis",
  "background",
  "behavior",
  "bgcolor",
  "border",
  "bordercolor",
  "capture",
  "cellpadding",
  "cellspacing",
  "challenge",
  "char",
  "charoff",
  "charset",
  "checked",
  "cite",
  "class",
  "classid",
  "clear",
  "code",
  "codebase",
  "codetype",
  "color",
  "cols",
  "colspan",
  "compact",
  "content",
  "contenteditable",
  "controls",
  "controlslist",
  "conversiondestination",
  "coords",
  "crossorigin",
  "csp",
  "data",
  "datetime",
  "declare",
  "decoding",
  "default",
  "defer",
  "dir",
  "direction",
  "dirname",
  "disabled",
  "disablepictureinpicture",
  "disableremoteplayback",
  "disallowdocumentaccess",
  "download",
  "draggable",
  "elementtiming",
  "enctype",
  "end",
  "enterkeyhint",
  "event",
  "exportparts",
  "face",
  "for",
  "form",
  "formaction",
  "formenctype",
  "formmethod",
  "formnovalidate",
  "formtarget",
  "frame",
  "frameborder",
  "headers",
  "height",
  "hidden",
  "high",
  "href",
  "hreflang",
  "hreftranslate",
  "hspace",
  "http-equiv",
  "id",
  "imagesizes",
  "imagesrcset",
  "importance",
  "impressiondata",
  "impressionexpiry",
  "incremental",
  "inert",
  "inputmode",
  "integrity",
  "invisible",
  "is",
  "ismap",
  "keytype",
  "kind",
  "label",
  "lang",
  "language",
  "latencyhint",
  "leftmargin",
  "link",
  "list",
  "loading",
  "longdesc",
  "loop",
  "low",
  "lowsrc",
  "manifest",
  "marginheight",
  "marginwidth",
  "max",
  "maxlength",
  "mayscript",
  "media",
  "method",
  "min",
  "minlength",
  "multiple",
  "muted",
  "name",
  "nohref",
  "nomodule",
  "nonce",
  "noresize",
  "noshade",
  "novalidate",
  "nowrap",
  "object",
  "open",
  "optimum",
  "part",
  "pattern",
  "ping",
  "placeholder",
  "playsinline",
  "policy",
  "poster",
  "preload",
  "pseudo",
  "readonly",
  "referrerpolicy",
  "rel",
  "reportingorigin",
  "required",
  "resources",
  "rev",
  "reversed",
  "role",
  "rows",
  "rowspan",
  "rules",
  "sandbox",
  "scheme",
  "scope",
  "scopes",
  "scrollamount",
  "scrolldelay",
  "scrolling",
  "select",
  "selected",
  "shadowroot",
  "shadowrootdelegatesfocus",
  "shape",
  "size",
  "sizes",
  "slot",
  "span",
  "spellcheck",
  "src",
  "srcdoc",
  "srclang",
  "srcset",
  "standby",
  "start",
  "step",
  "style",
  "summary",
  "tabindex",
  "target",
  "text",
  "title",
  "topmargin",
  "translate",
  "truespeed",
  "trusttoken",
  "type",
  "usemap",
  "valign",
  "value",
  "valuetype",
  "version",
  "virtualkeyboardpolicy",
  "vlink",
  "vspace",
  "webkitdirectory",
  "width",
  "wrap"
]
</pre>

<pre
	id="_dgm-default-configuration-object"
	class="include-code"
>
{
  "allowCustomElements": false,
  "allowElements": [
    "a",
    "abbr",
    "acronym",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "bdi",
    "bdo",
    "bgsound",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "layer",
    "legend",
    "li",
    "link",
    "listing",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "meta",
    "meter",
    "nav",
    "nobr",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "picture",
    "popup",
    "pre",
    "progress",
    "q",
    "rb",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "section",
    "select",
    "selectmenu",
    "small",
    "source",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr"
  ],
  "allowAttributes": {
    "abbr": [
      "*"
    ],
    "accept": [
      "*"
    ],
    "accept-charset": [
      "*"
    ],
    "accesskey": [
      "*"
    ],
    "action": [
      "*"
    ],
    "align": [
      "*"
    ],
    "alink": [
      "*"
    ],
    "allow": [
      "*"
    ],
    "allowfullscreen": [
      "*"
    ],
    "alt": [
      "*"
    ],
    "anchor": [
      "*"
    ],
    "archive": [
      "*"
    ],
    "as": [
      "*"
    ],
    "async": [
      "*"
    ],
    "autocapitalize": [
      "*"
    ],
    "autocomplete": [
      "*"
    ],
    "autocorrect": [
      "*"
    ],
    "autofocus": [
      "*"
    ],
    "autopictureinpicture": [
      "*"
    ],
    "autoplay": [
      "*"
    ],
    "axis": [
      "*"
    ],
    "background": [
      "*"
    ],
    "behavior": [
      "*"
    ],
    "bgcolor": [
      "*"
    ],
    "border": [
      "*"
    ],
    "bordercolor": [
      "*"
    ],
    "capture": [
      "*"
    ],
    "cellpadding": [
      "*"
    ],
    "cellspacing": [
      "*"
    ],
    "challenge": [
      "*"
    ],
    "char": [
      "*"
    ],
    "charoff": [
      "*"
    ],
    "charset": [
      "*"
    ],
    "checked": [
      "*"
    ],
    "cite": [
      "*"
    ],
    "class": [
      "*"
    ],
    "classid": [
      "*"
    ],
    "clear": [
      "*"
    ],
    "code": [
      "*"
    ],
    "codebase": [
      "*"
    ],
    "codetype": [
      "*"
    ],
    "color": [
      "*"
    ],
    "cols": [
      "*"
    ],
    "colspan": [
      "*"
    ],
    "compact": [
      "*"
    ],
    "content": [
      "*"
    ],
    "contenteditable": [
      "*"
    ],
    "controls": [
      "*"
    ],
    "controlslist": [
      "*"
    ],
    "conversiondestination": [
      "*"
    ],
    "coords": [
      "*"
    ],
    "crossorigin": [
      "*"
    ],
    "csp": [
      "*"
    ],
    "data": [
      "*"
    ],
    "datetime": [
      "*"
    ],
    "declare": [
      "*"
    ],
    "decoding": [
      "*"
    ],
    "default": [
      "*"
    ],
    "defer": [
      "*"
    ],
    "dir": [
      "*"
    ],
    "direction": [
      "*"
    ],
    "dirname": [
      "*"
    ],
    "disabled": [
      "*"
    ],
    "disablepictureinpicture": [
      "*"
    ],
    "disableremoteplayback": [
      "*"
    ],
    "disallowdocumentaccess": [
      "*"
    ],
    "download": [
      "*"
    ],
    "draggable": [
      "*"
    ],
    "elementtiming": [
      "*"
    ],
    "enctype": [
      "*"
    ],
    "end": [
      "*"
    ],
    "enterkeyhint": [
      "*"
    ],
    "event": [
      "*"
    ],
    "exportparts": [
      "*"
    ],
    "face": [
      "*"
    ],
    "for": [
      "*"
    ],
    "form": [
      "*"
    ],
    "formaction": [
      "*"
    ],
    "formenctype": [
      "*"
    ],
    "formmethod": [
      "*"
    ],
    "formnovalidate": [
      "*"
    ],
    "formtarget": [
      "*"
    ],
    "frame": [
      "*"
    ],
    "frameborder": [
      "*"
    ],
    "headers": [
      "*"
    ],
    "height": [
      "*"
    ],
    "hidden": [
      "*"
    ],
    "high": [
      "*"
    ],
    "href": [
      "*"
    ],
    "hreflang": [
      "*"
    ],
    "hreftranslate": [
      "*"
    ],
    "hspace": [
      "*"
    ],
    "http-equiv": [
      "*"
    ],
    "id": [
      "*"
    ],
    "imagesizes": [
      "*"
    ],
    "imagesrcset": [
      "*"
    ],
    "importance": [
      "*"
    ],
    "impressiondata": [
      "*"
    ],
    "impressionexpiry": [
      "*"
    ],
    "incremental": [
      "*"
    ],
    "inert": [
      "*"
    ],
    "inputmode": [
      "*"
    ],
    "integrity": [
      "*"
    ],
    "invisible": [
      "*"
    ],
    "is": [
      "*"
    ],
    "ismap": [
      "*"
    ],
    "keytype": [
      "*"
    ],
    "kind": [
      "*"
    ],
    "label": [
      "*"
    ],
    "lang": [
      "*"
    ],
    "language": [
      "*"
    ],
    "latencyhint": [
      "*"
    ],
    "leftmargin": [
      "*"
    ],
    "link": [
      "*"
    ],
    "list": [
      "*"
    ],
    "loading": [
      "*"
    ],
    "longdesc": [
      "*"
    ],
    "loop": [
      "*"
    ],
    "low": [
      "*"
    ],
    "lowsrc": [
      "*"
    ],
    "manifest": [
      "*"
    ],
    "marginheight": [
      "*"
    ],
    "marginwidth": [
      "*"
    ],
    "max": [
      "*"
    ],
    "maxlength": [
      "*"
    ],
    "mayscript": [
      "*"
    ],
    "media": [
      "*"
    ],
    "method": [
      "*"
    ],
    "min": [
      "*"
    ],
    "minlength": [
      "*"
    ],
    "multiple": [
      "*"
    ],
    "muted": [
      "*"
    ],
    "name": [
      "*"
    ],
    "nohref": [
      "*"
    ],
    "nomodule": [
      "*"
    ],
    "nonce": [
      "*"
    ],
    "noresize": [
      "*"
    ],
    "noshade": [
      "*"
    ],
    "novalidate": [
      "*"
    ],
    "nowrap": [
      "*"
    ],
    "object": [
      "*"
    ],
    "open": [
      "*"
    ],
    "optimum": [
      "*"
    ],
    "part": [
      "*"
    ],
    "pattern": [
      "*"
    ],
    "ping": [
      "*"
    ],
    "placeholder": [
      "*"
    ],
    "playsinline": [
      "*"
    ],
    "policy": [
      "*"
    ],
    "poster": [
      "*"
    ],
    "preload": [
      "*"
    ],
    "pseudo": [
      "*"
    ],
    "readonly": [
      "*"
    ],
    "referrerpolicy": [
      "*"
    ],
    "rel": [
      "*"
    ],
    "reportingorigin": [
      "*"
    ],
    "required": [
      "*"
    ],
    "resources": [
      "*"
    ],
    "rev": [
      "*"
    ],
    "reversed": [
      "*"
    ],
    "role": [
      "*"
    ],
    "rows": [
      "*"
    ],
    "rowspan": [
      "*"
    ],
    "rules": [
      "*"
    ],
    "sandbox": [
      "*"
    ],
    "scheme": [
      "*"
    ],
    "scope": [
      "*"
    ],
    "scopes": [
      "*"
    ],
    "scrollamount": [
      "*"
    ],
    "scrolldelay": [
      "*"
    ],
    "scrolling": [
      "*"
    ],
    "select": [
      "*"
    ],
    "selected": [
      "*"
    ],
    "shadowroot": [
      "*"
    ],
    "shadowrootdelegatesfocus": [
      "*"
    ],
    "shape": [
      "*"
    ],
    "size": [
      "*"
    ],
    "sizes": [
      "*"
    ],
    "slot": [
      "*"
    ],
    "span": [
      "*"
    ],
    "spellcheck": [
      "*"
    ],
    "src": [
      "*"
    ],
    "srcdoc": [
      "*"
    ],
    "srclang": [
      "*"
    ],
    "srcset": [
      "*"
    ],
    "standby": [
      "*"
    ],
    "start": [
      "*"
    ],
    "step": [
      "*"
    ],
    "style": [
      "*"
    ],
    "summary": [
      "*"
    ],
    "tabindex": [
      "*"
    ],
    "target": [
      "*"
    ],
    "text": [
      "*"
    ],
    "title": [
      "*"
    ],
    "topmargin": [
      "*"
    ],
    "translate": [
      "*"
    ],
    "truespeed": [
      "*"
    ],
    "trusttoken": [
      "*"
    ],
    "type": [
      "*"
    ],
    "usemap": [
      "*"
    ],
    "valign": [
      "*"
    ],
    "value": [
      "*"
    ],
    "valuetype": [
      "*"
    ],
    "version": [
      "*"
    ],
    "virtualkeyboardpolicy": [
      "*"
    ],
    "vlink": [
      "*"
    ],
    "vspace": [
      "*"
    ],
    "webkitdirectory": [
      "*"
    ],
    "width": [
      "*"
    ],
    "wrap": [
      "*"
    ]
  }
}
</pre>

</template>

<header>
	<hgroup>
<h1>HTML Sanitizer API</h1>
<!--
<h2>Draft Community Group Report</h2>
 -->
	</hgroup>
<details><summary>©</summary>
<small class="copyright" lang="en">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2021 the Contributors to the HTML Sanitizer API Specification, published by the <a href="https://www.w3.org/community/wicg/">Web Platform Incubator Community Group</a> under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>.
A human-readable <a href="http://www.w3.org/community/about/agreements/cla-deed/">summary</a> is available.
</small>
</details>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この文書は、
一群の~APIを指定する
— それは、信用-済みでない~HTML入力を［
文書の~DOMの中への安全な挿入~用に~sanitizeする（無毒化する）
］ことを開発者に許容する。
◎
This document specifies a set of APIs which allow developers to take untrusted HTML input and sanitize it for safe insertion into a document’s DOM.
</p>

	</section>
	<section id="status">
~STATUSofTHIS

<p>
この仕様は、
<a lang="en" href="https://www.w3.org/community/wicg/">Web Platform Incubator Community Group</a>
により公表されました。
それは、
`W3C Standard^en でも `W3C Standards Track^en でもありません。
<a lang="en" href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>
の下では、
ある制限-付き `opt-out^en があり，他の条件が適用されることに注意されたし。
詳しくは
<a lang="en" href="http://www.w3.org/community/">W3C Community and Business Groups</a>
について学習されたし。
◎
This specification was published by the Web Platform Incubator Community Group. It is not a W3C Standard nor is it on the W3C Standards Track. Please note that under the W3C Community Contributor License Agreement (CLA) there is a limited opt-out and other conditions apply. Learn more about W3C Community and Business Groups.
</p>

	</section>

<main>

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~web~appは、
~client側で，~HTMLを成す文字列で作業する必要があることが多い
— たぶん［
~client側における~template化による解決策,
あるいは利用者が生成した内容の具現化
］の一部として, 等々。
それを安全な仕方で行うのは困難である
— ［
文字列を~~連結して，`要素$の `innerHTML$m の中へ詰め込む
］ような素朴な~approachは、［
いくつかの期待されない仕方で~JSを実行させ得る
］ので，~riskをはらんでいる。
◎
Web applications often need to work with strings of HTML on the client side, perhaps as part of a client-side templating solution, perhaps as part of rendering user generated content, etc. It is difficult to do so in a safe way. The naive approach of joining strings together and stuffing them into an Element's innerHTML is fraught with risk, as it can cause JavaScript execution in a number of unexpected ways.
</p>

<p>
`DOMPURIFY$r の様な~libraryは、
文字列を挿入する前に，［
それを注意深く構文解析して~DOMを構築してから、
許容-~listを通して，その~memberたちを~filterして~sanitizeする
］ことにより，この問題を管理しようと試みる。
これは、脆い~approachであることが立証された
— ~webに公開された【~libraryの】構文解析~APIは、
文字列を “本物の” ~DOM内に~HTMLとして実際に具現化するとき，常に［
~browserの挙動に適理な仕方で対応付ける
］とは限らないので。
さらには，~libraryは、［
時間~越しに変化していく~browserの挙動
］の~~上層にあることを保つ必要がある
— それまで安全だったものは、
~platform~levelの新たな特能に基づいて時限爆弾に転化し得るので。
◎
Libraries like [DOMPURIFY] attempt to manage this problem by carefully parsing and sanitizing strings before insertion, by constructing a DOM and filtering its members through an allow-list. This has proven to be a fragile approach, as the parsing APIs exposed to the web don’t always map in reasonable ways to the browser’s behavior when actually rendering a string as HTML in the "real" DOM. Moreover, the libraries need to keep on top of browsers' changing behavior over time; things that once were safe may turn into time-bombs based on new platform-level features.
</p>

<p>
~browserは、
~codeをいつ実行しようとするかについて，よく知る立場にある。
利用元~空間の~libraryは，次により改善でき、
この文書は，まさにそれを目指す~APIを要旨する
⇒
任意な文字列から安全な方式で~HTMLを具現化するにあたって，次を可能にする
⇒
それを行う方法を~browserに教えること、
および［
~browserによる自前の［
構文解析器の実装
］が変化するに伴い［
保守される／更新される
］見込みがずっと高い仕方で，それを行うこと
◎
The browser has a fairly good idea of when it is going to execute code. We can improve upon the user-space libraries by teaching the browser how to render HTML from an arbitrary string in a safe manner, and do so in a way that is much more likely to be maintained and updated along with the browser’s own changing parser implementation. This document outlines an API which aims to do just that.
</p>

		<section id="goals">
<h3 title="Goals">1.1. 目標</h3>

<ul>
	<li>
次により，~DOMに基づく~XSS攻撃の~riskを軽減する
⇒
~HTMLを取扱うための［
利用元により制御される仕組み
］を開発者に供して、
注入の際に直な~script実行を防止する
◎
Mitigate the risk of DOM-based cross-site scripting attacks by providing developers with mechanisms for handling user-controlled HTML which prevent direct script execution upon injection.
</li>
	<li>
~HTML出力を現在の~UAの中で安全に利用できるようにする
— ~UAの［
~HTMLに対する現在の理解
］を織り込む下で。
◎
Make HTML output safe for use within the current user agent, taking into account its current understanding of HTML.
</li>
	<li>
対象になる［
要素や属性
］の既定の集合を上書きすることを，開発者に許容する。
ある種の［
要素／属性
］を追加することは、
<a href="https://github.com/google/security-research-pocs/tree/master/script-gadgets">~script~gadget攻撃</a>を防止し得る。
◎
Allow developers to override the defaults set of elements and attributes. Adding certain elements and attributes can prevent script gadget attacks.
</li>
</ul>

		</section>
		<section id="api-summary">
<h3 title="API Summary">1.2. ~APIの要約</h3>

<div class="example">

<pre class="lang-js">
let %s = new Sanitizer();

/* <span class="comment">
入力~dataは、
~treeを成す~DOM~node群として すでに可用な事例：
◎
Case: The input data is available as a tree of DOM nodes.
</span> */
let %userControlledTree = ...;
%element.replaceChildren(%s.sanitize(%userControlledTree));

/* <span class="comment">
入力は文字列として可用であり，
どの要素に挿入するかも知っている事例：
◎
Case: The input is available as a string, and we know the element to insert it into:
</span> */
let %userControlledInput = "&amp;lt;img src=x onerror=alert(1)//&amp;gt;";
%element.setHTML(%userControlledInput, %s);

/* <span class="comment">
入力は文字列として可用であり，
どの型の要素に挿入するかも知っていて，
最終的に挿入することになるが、
今は挿入できないか，そうしたくない事例：
◎
Case: The input is available as a string, and we know which type of element we will eventually insert it to, but can’t or don’t want to perform the insertion now:
</span> */
let %forDiv = %s.sanitizeFor("div", %userControlledInput);
/* <span class="comment">
後で：
◎
Later:
</span> */
document.querySelector(``^${%forDiv.localName}#target``^).replaceChildren(%forDiv.children);
</pre>
</div>

		</section>
		<section id="strings">
<h3 title="The Trouble With Strings">1.3. 文字列に伴われる~trouble</h3>

<p>
多くの~HTML~sanitizer~libraryは，文字列を文字列へ~~変換する~APIに基づくが、
この~APIは，そのような~methodを提供することはない。
この下位節では、その理由と，それによる含意を~Sanitizer~API用に説明する。
◎
Many HTML sanitizer libraries are based on string-to-string APIs, while this API does not offer such a method. This sub-section explains the reasons and implications for the Sanitizer API.
</p>

<p>
文字列を~node群が成す~tree（または ある`文書片$）へ変換するためには、
それを構文解析する必要がある。
<a href="~HTMLparsing#parsing">~HTML構文解析~algo</a>は、
~HTMLの構文解析がどう働くかを注意深く指定する。
この~algoのふるまいは、その構文解析-用の文脈を与える現在の~nodeに依存する。
すなわち、
同じ文字列であっても，得られる構文解析-~treeは、
構文解析される文脈を成す~HTML~nodeに応じて異なり得る。
◎
To convert a string into a tree of nodes (or a fragment), it needs to be parsed. The HTML parsing algorithm carefully specifies how parsing HTML works. This parsing algorithm is dependent on the current node as its parsing context. That is, the same string parsed in the context of different HTML nodes will yield different parse trees.
</p>

<div class="example">

<p>
異なる文脈~内の文字列 `&lt;em&gt;bla^l ：
</p>

<table><thead><tr><th>文脈<th>入力<th>結果
</thead><tbody>

<tr><td>`div$e
<td>`&lt;div&gt;&lt;em&gt;bla&lt;/div&gt;^l
<td>`&lt;div&gt;&lt;em&gt;bla&lt;/em&gt;&lt;/div&gt;^c

<tr><td>`textarea$e
<td>`&lt;textarea&gt;&lt;em&gt;bla&lt;/textarea&gt;^l
<td>`&lt;textarea&gt;&amp;lt;em&amp;gt;bla&lt;/textarea&gt;^c

</tbody></table>
◎
The string &lt;em&gt;bla in &lt;div&gt; and &lt;textarea&gt; context.
• &lt;div&gt;&lt;em&gt;bla&lt;/div&gt; ⇨ &lt;div&gt;&lt;em&gt;bla&lt;/em&gt;&lt;/div&gt;
• &lt;textarea&gt;&lt;em&gt;bla&lt;/textarea&gt; ⇨ &lt;textarea&gt;&amp;lt;em&amp;gt;bla&lt;/textarea&gt;
</div>

<div class="example">
<p>
異なる文脈~内の~table~cell
</p>

<table><thead><tr><th>文脈<th>入力<th>結果
</thead><tbody>

<tr><td>`table$e
<td>`&lt;table&gt;&lt;td&gt;text&lt;/table&gt;^l
<td>`&lt;table&gt;&lt;td&gt;text&lt;/table&gt;^c

<tr><td>`div$e
<td>`&lt;div&gt;&lt;td&gt;text&lt;/div&gt;^l
<td>`&lt;div&gt;text&lt;/div&gt;^c

</tbody></table>

◎
A table cell in &lt;table&gt; and non-table (&lt;div&gt;) context.
• &lt;table&gt;&lt;td&gt;text&lt;/table&gt; ⇨ &lt;table&gt;&lt;td&gt;text&lt;/table&gt;
• &lt;div&gt;&lt;td&gt;text&lt;/div&gt; ⇨ &lt;div&gt;text&lt;/div&gt;
</div>

<p>
これらの相違は、
~siteの~sanitization策の中に~bugが潜むのを許容し得る
— それは、<a href="#mutated-xss">~mXSS</a>と呼ばれる，ある~classの~XSS攻撃により悪用され得る（されてきた）。
これらの攻撃は、結局の所，構文解析~文脈の混同に依存する。
例えば，開発者が［
文字列を ある（構文解析）文脈~内で~sanitizeした結果の文字列
］を異なる文脈
— 異なる何かに解釈される文脈 —
内で適用するとき。
◎
These differences can allow bugs to creep into a site’s sanitization strategy, which can (and have been) exploited by a class of XSS-style attacks called mXSS. These attacks ultimately depend on confusions of the parsing context, for example when a developer will sanitize a string in one (parsing) context, while then applying the resulting string in a different context, where it will be interpreted differently.
</p>

【！class="example"】
<p class="note">注記：
現実にある~libraryにおける~mXSSの例は
`MXSS1$r, `MXSS2$r
にて見出せる。
これらの報告をとり挙げたのは、
容易に読めるために過ぎない
— 類似な報告は、
~HTML構文解析を処する他のどの~toolにも，およそあることを~~強調したい。
◎
Two mXSS-style examples in real-world libraries can be found in [MXSS1]] and [MXSS2]. We’d like to stress that we picked these reports for their ease of reading. There are similar reports for pretty much every other tools that deals with HTML parsing.
</p>

<p>
この攻撃~classは，［
~sanitizationが`生じた後^emにおける，結果の文字列の特定0の用法
］に依存するので、
この~APIが利用者を保護する能力は，【そのような用法が生じない所までに】制限される。
その結果、
~Sanitizer~APIは，次の原則に従う
⇒
~Sanitizer~APIが文字列から~DOM（下位-）~tree［
へ構文解析する／から直列化する【！unparse】
］ときは、［
当の演算は、
暗黙の正しい構文解析-文脈がある所で，それを行う
］ようになるか，または［
開発者が構文解析-文脈を給して，所与の文脈を結果の引数にて維持することを要求する
］ことになる。
◎
Since this attack class depends on a particular usage of the string after the sanitization has occurred, the API itself has only limited capability to protect its users. As a result, the Sanitizer API follows the following principle:
◎
Whenever the Sanitzer API parses or unparses a DOM (sub-)tree to or from a string, it will either do so in a fashion where the correct parse context is implied by the operation; or it will require a parse context to be supplied by the developer and will retain the given context in the resulting argument.＼
</p>

<p>
言い換えれば，~Sanitizer~APIは、以前に構文解析~文脈が［
給されたなら，それを忘れることはない／
給されなかったなら，いかなる構文解析~文脈も前提にしない
］。
◎
In other words, the Sanitzer API will never assume a parsing context, or disappear a parsing context that has been supplied earlier.
</p>

			<section id="string-context-case-1">
<h4 title="Case 1: Sanitizing With Nodes, Only.">1.3.1. 事例 1： ~node群の~sanitize法</h4>

<p>
当の利用者~dataは，すでに~DOM~node群
— 例えば，ある~frame内の`文書$ —
として可用である場合、
~Sanitizerは容易に利用できる：
◎
If the user data in question is already available as DOM nodes - for example a Document instance in a frame - then the Sanitizer can be easily used:
</p>

<div class="example">

<pre class="lang-js">
const %sanitizer = new Sanitizer( ... );  /* <span class="comment">
新たな `Sanitizer^I
◎
Our Sanitizer;
</span> */

/* <span class="comment">
`id^a に `userFrame^l を伴う `iframe^e がある
— 関心事は、その内容である。
◎
There is an iframe with id "userFrame" whose content we are interested in.
</span> */
const %user_tree = document.getElementById("userFrame").contentWindow.document;
const %sanitized = %sanitizer.sanitize(user_tree);
</pre>
</div>

<p class="note">注記：
~HTML文字列の構文解析は、
様々な副作用
— ~network要請や~scriptを実行する様なそれ —
を伴い得る。
素朴に構文解析した場合
— 例：`接続されて$いない要素の `innerHTML$m に文字列をアテガうなど —
これらを依拠-可能に防止しないことになる。
したがって，~sanitizeされる利用者~dataが元々は文字列を形成する場合、
以下に挙げるいずれかの事例へ進むことを推奨する。
◎
Note: Parsing an HTML string can have various side-effects, like network requests or executing scripts. Naively parsing these, e.g. by assigning a string to .innerHTML of an unconnected element, will not reliably prevent these. Therefore, if the user data to be sanitized is originally in string form, we recommend to go with one of the following cases.
</p>

			</section>
			<section id="string-context-case-2">
<h4 title="Case 2: Sanitizing a String with Implied Context.">1.3.2. 事例 2：暗黙の文脈を伴う文字列の~sanitize法</h4>

<p>
当の利用者~dataは文字列の形で可用で，
~sanitizeされた下位treeを~DOMの中へ直に挿入したいと望む場合、
次のようにして行える：
◎
If the user data is available in string form and we wish to directly insert the sanitized subtree into the DOM, we can do so as follows:
</p>

<div class="example">

<pre class="lang-js">
const %user_string = "...";  /* <span class="comment">
利用者からの文字列
◎
The user string.
</span> */
const %sanitizer = new Sanitizer( ... );  /* <span class="comment">
新たな `Sanitizer^I
◎
Our Sanitizer;
</span> */

/* <span class="comment">
%user_string 内の~HTMLを［
`id^a に `target^l を伴う~target要素
］の中へ挿入する
— すなわち、~XSS~riskを伴わないことを除けば，
<code>%target.innerHTML = %value</code>
に等価になる —
ことが求まれるなら：
◎
We want to insert the HTML in user_string into a target element with id target. That is, we want the equivalent of target.innerHTML = value, except without the XSS risks.
</span> */
document.getElementById("target").setHTML(%user_string, %sanitizer);
</pre>
</div>

			</section>
			<section id="string-context-case-3">
<h4 title="Case 3: Sanitizing a String with a Given Context.">1.3.3. 事例 3： 所与の文脈を伴う文字列の~sanitize法</h4>

<p>
利用者~dataは文字列の形で可用で、
開発者は それを今すぐ~sanitizeしたいが，その結果は後で~DOMに適用したいと望む場合、
利用される文脈について~Sanitizerに伝える必要がある。
文脈の混同を防止するため、
結果は［
結果【の~DOM~tree】, 構文解析-文脈
］の両者を包装する容器になる。
この容器は、
簡便に，~node自身としてすでに存在する
【~Sanitizerに伝えた要素~型の新たな~nodeとして，~Sanitizerが作成することになる】。
◎
If the user data is available in string form and the developer wishes to sanitize it now, but apply the result to the DOM later, then the Sanitizer must be informed about the context that it will be used. To prevent context confusion the result is wrapper a container that contains both the result and also the parse context. Conveniently, this container already exists, and it is the node itself!
</p>

<div class="example">

<pre class="lang-js">
/* <span class="comment">
利用者~入力を成す ある種の片は、
当の~pageの複数の要素~内に挿入するよう，繰返に利用されることが意味される。
これらの要素は，すべて `div$tg 要素になる。
◎
A certain piece of user input is meant to be used repeatedly, to insert it in multiple elements on the page. All these elements will be &lt;div&gt; elements.
</span> */
const %user_string = "...";  /* <span class="comment">
利用者からの文字列
◎
The user string.
</span> */
const %sanitizer = new Sanitizer( ... );  /* <span class="comment">
新たな `Sanitizer^I
◎
Our Sanitizer.
</span> */

const %sanitized = %sanitizer.sanitizeFor("div", %user_string);
sanitized instanceof HTMLDivElement  /* <span class="comment">
~T になる。
~nodeは、~Sanitizerから与えられる。
◎
true. The Sanitizer has given us a node.
</span> */

/* <span class="comment">
...後で，同じ~program内で：
◎
... later, in the same program ...
</span> */
for (let %elem = ... of ...) {
  /* <span class="comment">
%elem ~instanceはどれも、
上の `sanitizeFor()$m ~callにて利用したものと同じ型になるべきである。
これは、次のような見かけの表明でも行える：
◎
All of our "elem" instances should be of the same type used in the .sanitizeFor call above. With an assertion library, this could look as follows:
</span> */
  assert_true(%elem instanceof %sanitized.constructor);  /* <span class="comment">
`assert_true^c は、
`WPT^en ~test【`Web Platfotm Test^en】のそれと似たものとする。
◎
Assuming assert_true, like in WPT tests.
</span> */
  %elem.replaceChildren(...%sanitized.childNodes);
}

/* <span class="comment">
次の代わりに：
◎
Instead of:
</span> */
%elem.replaceChildren(...%sanitized.childNodes);
/* <span class="comment">
次のように書くこともできる：
◎
one could write:
</span> */
%elem.innerHTML = %sanitized.innerHTML;
/* <span class="comment">
これの効果は、
遅くなることを除けば同じになるはずである
— これは，すでに可用であった~node~treeを直列化して【！un-parsing】から構文解析し直すので、
前者の方だけ用い続けることが推奨される。
◎
This should have the same effect, except be slower, since this will trigger un-parsing and then re-parsing the node tree which we already have available as a node tree. So we recommend to stick with the former version.
</span> */
</pre>
</div>

			</section>
			<section id="string-context-case-other">
<h4 title="The Other Case">1.3.4. その他の事例</h4>

<p>
所与の~app構造において，これらの事例がどれも働かないため，文字列を文字列へ~~変換する演算が要求される場合どうするか？
この事例では、
開発者は［
~sanitizeした結果を その文脈から切り離してもかまわない
］が，［
結果の文字列を不適切な文脈~内に誤って適用することに起因する~mXSS~classの攻撃
］を防止する責務は開発者にあり続ける。
◎
What if neither of these cases works with a given application structure, and a string-to-string operation is required? In this case, the developer is free to take the sanitization result and remove it from its context. In this case, the responsibility to prevent mXSS-class attacks that stem from mis-applying those strings in an inappropriate context remains with the developer.
</p>

<div class="example">

<pre class="lang-js">
const %user_string = "...";  /* <span class="comment">
利用者からの文字列
◎
The user string.
</span> */
const %sanitizer = new Sanitizer( ... );  /* <span class="comment">
新たな `Sanitizer^I
◎
Our Sanitizer.
</span> */

/* <span class="comment">
開発者は、
この文字列を `div$e 要素の中に挿入するものと計画するが，
これを（要素の代わりに）文字列として保つ必要があるとする。
~mXSS攻撃を防止するためには、
開発者は［
構文解析~文脈を覚えておいて，これを異なる構文解析~文脈には利用しない
］ことが重要になる。
◎
The developer plans to insert this string into a &lt;div&gt; element, but has to keep this around as a string (instead of an element). It’s important that the developer remembers the parsing context and MUST NOT use this in a different parsing context in order to prevent mXSS attacks.
</span> */
const %sanitized_for_div = %sanitizer.sanitizeFor("div", %user_string).innerHTML;
</pre>
</div>

			</section>
		</section>
	</section>
	<section id="framework">
<h2 title="Framework">2. ~framework</h2>

		<section id="sanitizer-api">
<h3 title="Sanitizer API">2.1. ~Sanitizer~API</h3>

<p>
中核~APIは `Sanitizer$I ~objと `sanitize()$m ~methodである。
~Sanitizerは、
各種~option用の省略可能な `SanitizerConfig$I 辞書を利用して，~instance化できる。
最も共通的な利用事例
— ~XSSを防止すること —
は，既定で取扱われ、
追加的な［
~appに特有な利用事例
］を取扱うときに限り，~customな環境設定0を伴う~Sanitizerを作成することが必要とされる。
◎
The core API is the Sanitizer object and the sanitize method. Sanitizers can be instantiated using an optional SanitizerConfig dictionary for options. The most common use-case - preventing XSS - is handled by default, so that creating a Sanitizer with a custom config is necessary only to handle additional, application-specific use cases.
</p>

<pre class="idl">
[`Exposed$=(Window), `SecureContext$]
interface `Sanitizer@I {
  `Sanitizer$mc(optional `SanitizerConfig$I %config = {});

  `DocumentFragment$I `sanitize$m((`Document$I or `DocumentFragment$I) %input);
  `Element$I? `sanitizeFor$m(`DOMString$ %element, `DOMString$ %input);

  `SanitizerConfig$I `getConfiguration$m();
  static `SanitizerConfig$I `getDefaultConfiguration$m();
};
</pre>

<div class="algo">
<p>
`new Sanitizer(config)@m
構築子~手続きは：
</p>
<ol>
	<li>
~IF［
%config は空である
］†
⇒
`~Sanitizerを初期化する$( コレ )
</li>
	<li>
~ELSE†
⇒
`~Sanitizerを初期化する$( コレ, %config )
</li>
</ol>

<p class="trans-note">【†
この場合分けは、この訳による補完。
この構築子が %config を省略して~callされた場合、
`~Sanitizerを初期化する$手続きを 2 個目の引数を省略して呼出す
（すなわち，`既定の環境設定$を利用する）ことが原文の意図であるが、
~IDLの定義により， %config には空な辞書が既定~値として渡されるので
（明示的に空な辞書が渡された場合とで挙動を違えることはできない）。
】</p>
◎
The new Sanitizer(config) constructor steps are to run the create a sanitizer algorithm steps with config as parameter.
</div>

<div class="algo">
`sanitize(input)@m
~method手続きは
⇒
~RET コレで`~sanitizeする$( %input )
◎
The sanitize(input) method steps are to return the result of running the sanitize algorithm on input,
</div>

<div class="algo">
`sanitizeFor(element, input)@m
~method手続きは
⇒
~RET コレで`要素~用に~sanitizeする$( %element, %input )
◎
The sanitizeFor(element, input) method steps are to return the result of running sanitizeFor algorithm on element and input.
</div>

<div class="algo">
<p>
`getConfiguration()@m
~method手続きは
⇒
~RET コレの`環境設定0を~queryする$()
◎
The getConfiguration() method steps are to return the result of running the query the sanitizer config algorithm.＼
</p>
<p>
これは、
本質的には ~Sanitizerの`環境設定~obj$の複製を返すが，
ある程度の正規化を伴う。
◎
It essentially returns a copy of the Sanitizer’s configuration object, with some degree of normalization.
</p>
</div>

<div class="algo">
`getDefaultConfiguration()@m
静的~method手続きは
⇒
~RET `既定の環境設定$
◎
The value of the static getDefaultConfiguration() method steps are to return the value of the default configuration object.
</div>

<p>
`Element$I ~interfaceには、
`setHTML()$m ~methodが追加される
— それは、~Sanitizerを利用して，文字列を既存の要素~nodeに直に適用する。
◎
The Element interface gains an additional method, setHTML which applies a string using a Sanitizer directly to an existing element node.
</p>
	
<pre class="idl">
dictionary `SetHTMLOptions$I {
  `Sanitizer$I `sanitizer$m;
};
partial interface `Element$I {
  `undefined$ `setHTML$m(`DOMString$ %input, `SetHTMLOptions$I %options = {});
};
</pre>

<div class="algo">
`setHTML(input, sanitizer)@m
~method手続きは
⇒
`要素~用に~sanitizeして設定する$( コレ, %input, %sanitizer )
◎
The setHTML(input, sanitizer) method steps are to run the sanitizeAndSet algorithm on input and sanitizer.
◎
Is this how we specify a method on existing class "owned" by a different spe?
</div>

【！<p class="issue">これは、異なる仕様に “所有される” 既存の~class用に~methodを指定する方法として~~適切なのか？</p>】

<div class="example">
<p>
この仕様の例を追い易くするためには、
手早く容易に~DOM~nodeを作成する仕方が必要になる
— この仕様の~Sanitizer~APIでも作成できるが、
それは，自身をデモるためには利用できないので。
以下に与える `to_node$V は、
これを成遂げるための その場限りの仕方であり，~~説明用に限られる
— 実施には利用しないこと。
この構文解析~methodは、
構文解析される文字列に基づいて，~secureでない副作用を伴い得る。
事実，この~APIこそが、
もっぱら，この~approachに伴う問題を防止する目的で存在する。
◎
// To make our examples easy to follow, we’ll need a way create DOM nodes.
// The following is hacky way to accomplish this, for illustration only,
// that you shall pretty please not use in practice. This parsing method can
// cause side-effects based on the string being parsed, which is insecure.
// In fact, this very API exists for the sole purpose of preventing the
// problems that this approach has.
//
// But... for our examples we’ll need something that is quick and easy, since
// we cannot use our own Sanitizer API to explain our own Sanitizer API.
</p>

<pre class="lang-js">
const `to_node@V = %str =&gt; document.createRange().createContextualFragment(%str);
</pre>
</div>

<div class="example">
<pre class="lang-js">
/* <span class="comment">
~Sanitizerの中核~APIは、
`sanitize()$m ~methodである：
◎
The core API of the Sanitizer is the .sanitize method:
</span> */
let %untrusted_input = `to_node$V("Hello!");
const %sanitizer = new Sanitizer();
%sanitizer.sanitize(%untrusted_input);  /* <span class="comment">
~text~node "Hello!" を伴う`文書片$
◎
DocumentFragment w/ a text node, "Hello!"
</span> */

/* <span class="comment">
これが、おそらく，~DOM内のどこかに置くことが求まれるもの：
◎
Probably we want to put this somewhere in our DOM:
</span> */
%element.replaceChildren(%sanitizer.sanitize(%untrusted_input));

/* <span class="comment">
入力が~markupを包含する場合、
~script的な~markupを除いて，ほぼ保全されることになる：
◎
If our input contains markup it’ll be mostly preserved, except for script-y markup:
</span> */
%untrusted_input = `to_node$V("&lt;em onclick='alert(1);'&gt;Hello!&lt;/em&gt;");
%sanitizer.sanitize(%untrusted_input);  /* &lt;em&gt;Hello!&lt;/em&gt; */
%element.replaceChildren(%sanitizer.sanitize(%untrusted_input));  /* <span class="comment">
`alert(1)^c は生じ得ない。
◎
No alert!
</span> */

/* <span class="comment">
`sanitize()$m ~methodが首な~APIであり、
`文書片$を返す。
`sanitizeFor()$m ~methodは、
文字列を受容して, それを構文解析して, ~HTML要素~nodeを返す。
◎
The .sanitize method is the primary API, and returns a DocumentFragment. The .sanitizeFor method accepts and parses a string and returns an HTML element node.
</span> */
const %hello = `to_node$V("hello");
(%sanitizer.sanitize(hello)) instanceof DocumentFragment;  /* true */
(%sanitizer.sanitizeFor("template", "hello")) instanceof HTMLTemplateElement;  /* true */
</pre>
</div>

		</section>
		<section id="api-string-handling">
<h3 title="String Handling">2.2. 文字列の取扱い</h3>

<p>
文字列を~HTMLへ構文解析する（あるいは~HTMLから直列化する【！unparse】）ためには、
文脈~要素が要求される。
したがって、
`sanitizeFor()$m ~methodには，［
実装が~HTML構文解析器へ手渡せる文脈
］を渡すことが要求される。
◎
Parsing (and unparsing) strings to (or from) HTML requires a context element. Thus, the sanitizeFor method requires us to pass in a context, which the implementation can then hand over to the HTML Parser.
</p>

<p>
加えて、
`Element$I ~interfaceには `setHTML()$m ~methodが追加される
— それは、当の`要素$に適用されるので，常に正しい文脈を知る。
この`要素$が、自前の内容を［
構文解析するとき, 直列化するとき
］の正しい文脈を与える。
◎
Additionally, the Element interface gains a setHTML method, which always knows the correct context, because it is applied to a given Element instance. This Element is the correct context for both parsing and unparsing its own content.
</p>

<div>
<p>
文字列の~sanitizationは、
次に挙げる 3 段からなる演算として概念~化できる
⇒＃
(1)： 文字列を構文解析する。
(2)： (1) の結果の~node~treeを~sanitizeする。
(3)： (2) の結果の下位treeを~liveな~DOMへ移植する。
</p>

<p>
`Sanitizer$I の `sanitize()$m は、
段 (2) を遂行する。
`Sanitizer$I の `sanitizeFor()$m は、
段 (1), (2) を遂行するが (3) を開発者に委ねる。
`Element$I の `setHTML$m は、
段 (1), (2), (3) すべてを遂行する。
どれを利用するかは、
当の~appの構造に依存する
— 3 つの段をすべてを同時に行えることもあれば、
（~code構造により，または ある時点で）~DOMの最終的な改変から~sanitizationが除去される【ので，その後に適用する必要がある？】こともあろう。
</p>
◎
One way to conceptualize this is to view string sanitization as a three step operation: 1, parsing the string; 2, sanitizing the resulting node tree; and 3, grafting the resulting subtree onto our live DOM. Sanitizer.sanitize is the middle step. Sanitizer.sanitizeFor performs the first and second steps, but leaves the third to the developer. Element.setHTML does all three. Which to use depends on the structure of your application, whether you can do all three steps simultaneously, or whether maybe the sanitization is removed (in either code structure or point in time) from the eventual modification of the DOM.
</div>

<div class="example">

<pre class="lang-js">
  /* <span class="comment">
~sanitizeされる~markupは，~treeとして すでに可用な場合
（例：埋込まれた~frameから）、 
`sanitize()$m を利用できる：
◎
If the markup to be sanitized is already available as a tree, for example from an embedded frame, one can use sanitize:
</span> */
  document.getElementById("target").replaceChildren(
    %sanitizer.sanitize(
      document.querySelector("iframe#myframe").contentWindow.document));

  /* <span class="comment">
~sanitizeされる~markupは，文字列の形で在るが、
挿入-先として求まれる要素はすでに可用である場合：
◎
If the markup to be sanitized is present in string form, but we already have the element we want to insert in available:
</span> */
  const %untrusted_input = "....";
  document.getElementById("someelement").setHTML(
    %untrusted_input, {sanitizer: %sanitizer});

  /* <span class="comment">
上と同じだが、
既定の~Sanitizer環境設定を利用するときは：
◎
Same as above, but using the default Sanitizer configuration:
</span> */
  document.getElementById("somelement").setHTML(%untrusted_input);

  /* <span class="comment">
~sanitizeされることになる~markupは，文字列の形で在るが、
今は~DOMへの挿入は求まれない場合：
◎
If the markup to be sanitized is present in string form, but we don’t want to do the DOM insertion now:
</span> */
  let %no_xss = %sanitizer.sanitizeFor("div", %untrusted_input);
  /* <span class="comment">
... ずっと後で ...
◎
... much later ...
</span> */
  document.querySelector("div#targetdiv").replaceChildren(...%no_xss.childNodes);

  /* <span class="comment">
~HTMLの構文解析は、
多くの仕方で現在の文脈に依存することに注意
— うち一部は微妙で, 他はそれほどでもない。
結果を最終的に利用する所とは異なる文脈を給することには、
~securityの~risk, 機能上の~riskどちらもある。
これを安全に取扱うことは開発者に委ねられる。
◎
Note that parsing HTML depends on the current context in many ways, some subtle, some not so much. Supplying a different context than what the result will eventually be used in has both security and functional risks. It’s up to the developer to handle this safely.
</span> */
  /* <span class="comment">
例：多くの, ほとんどの構文解析~文脈は、
`table$tg に封入されていない~table~data （ `td$tg ）を許容しない。
◎
Example: Most, many parsing contexts disallow table data (&lt;td&gt;) without an enclosing table.
</span> */
  %sanitizer.sanitizeFor("div", "&lt;td&gt;data&lt;/td&gt;").innerHTML  /* "data" */
  %sanitizer.sanitizeFor("table", "&lt;td&gt;data&lt;/td&gt;").innerHTML  /* "&lt;td&gt;data&lt;/td&gt;" */
</pre>
</div>

<div class="note">

<p>注記：
文字列を~sanitizeするときは、
`~HTML構文解析器$を利用して入力を構文解析するので，ある程度の正規化を遂行することになる。
なので、
特定0の入力に対し施される~sanitization手続きは何も無い場合でも，
`sanitizeFor()$m の出力【を直列化した結果】が文字ごとに入力と一致することは保証できない。
◎
Note: Sanitizing a string will use the HTML Parser to parse the input, which will perform some degree of normalization. So even if no sanitization steps are taken on a particular input, it cannot be guaranteed that the output of .sanitizeFor will be character-for-character identical to the input.
</p>

<div class="example">
<pre class="lang-js">
%sanitizer.sanitizeFor("div", "Stra&amp;szlig;e")  /* 
Straße */
%sanitizer.sanitizeFor("div", "&lt;image&gt;")  /* `img$tg */
</pre>
</div>

</div>

<div class="note">

<p>注記：
［
`Sanitizer$I の `sanitizeFor()$m,
`Element$I の `setHTML()$m
］~methodは、
互いに他方を置換できる。
この両者が供されているのは、
それらが~supportする利用事例が異なるからである。
◎
Note: Sanitizer.sanitizeFor and Element.setHTML can replace the respective other. Both are provided, since they support different use cases.
</p>

<div class="example">
<pre class="lang-js">
/* <span class="comment">
この `sanitizeFor^c 関数は、
`setHTML()$m 【！SetInnerHTML】に基づく：
◎
sanitizeFor, based on SetInnerHTML.
</span> */
function sanitizeFor(%element, %input) {
  const %elem = document.createElement(%element);
  %elem.setHTML(%input, {sanitizer: this});
  return %elem;
}

/* <span class="comment">
この `setHTML^c 関数は、
`sanitizeFor()$m に基づく：
◎
setHTML, based on sanitizeFor.
</span> */
function setHTML(%input, %options) {
  const %sanitizer = %options?.sanitizer ?? new Sanitizer();
  this.replaceChildren(...%sanitizer.sanitizeFor(this.localName, %input).childNodes);
}
</pre>
</div>
</div>

		</section>
		<section id="config">
<h3 title="The Configuration Dictionary">2.3. 環境設定~辞書</h3>

<p>
~Sanitizerの
`環境設定~obj@
は、辞書であり，~sanitize演算に対する改変を述べる。
~Sanitizerが明示的な環境設定を受取らなかった場合
— 例えば，~parameterを何も伴わずに構築されたとき —
`既定の環境設定$が環境設定~objとして利用される。
◎
The Sanitizer’s configuration object is a dictionary which describes modifications to the sanitize operation. If a Sanitizer has not received an explicit configuration, for example when being constructed without any parameters, then the default configuration value is used as the configuration object.
</p>

<p class="trans-note">【
原文には、［
~Sanitizerが`環境設定~obj$を持たない場合もある
］と見做す記述
（持たない場合、`既定の環境設定$を利用するよう明示的に指定している）
と［
~Sanitizerは常に`環境設定~obj$を持つ
］と見做す記述
（環境設定が供されなかった場合、`既定の環境設定$に設定されたものと見做す）
があって，一貫でない。
この訳では、後者に統一することにする。
】</p>

<pre class="idl">
dictionary `SanitizerConfig@I {
  `sequence$&lt;`DOMString$&gt; `allowElements$m;
  `sequence$&lt;`DOMString$&gt; `blockElements$m;
  `sequence$&lt;`DOMString$&gt; `dropElements$m;
  `AttributeMatchList$I `allowAttributes$m;
  `AttributeMatchList$I `dropAttributes$m;
  `boolean$ `allowCustomElements$m;
  `boolean$ `allowComments$m;
};
</pre>

<dl>
	<dt>`allowElements@m</dt>
	<dd>
`許容する要素~群@†
を与える
— それは、［
次に該当する要素の名前を与える文字列
］からなる連列である
⇒
~sanitizerは、入力~内に維持するべきである
◎
The element allow list is a sequence of strings with elements that the sanitizer should retain in the input.
</dd>
	<dd class="trans-note">【†
この訳では、
この用語は利用せず，直に
%環境設定~obj[ "`allowElements$m" ]
のような形で参照することにする
（以下で他の~member用に定義される~~同類の用語についても同様）。
原文には，［
この~memberが供されなかった場合、この用語は，どう定義されるのか
］が直に述べられていないため、
~memberの有無による場合分けを述べる所では，結局~直に参照することになる
（この用語を通して述べる利点がない）ので。
】</dd>

	<dt>`blockElements@m</dt>
	<dd>
`阻止する要素~群@
を与える
— それは、［
次に該当する要素の名前を与える文字列
］からなる連列である
⇒
~sanitizerは、
入力から除去するべきであるが，その子孫【！children】は維持するべきである
◎
The element block list is a sequence of strings with elements where the sanitizer should remove the elements from the input, but retain their children.
</dd>

	<dt>`dropElements@m</dt>
	<dd>
`落とす要素~群@
を与える
— それは、［
次に該当する要素の名前を与える文字列
］からなる連列である
⇒
~sanitizerは、
入力から
— その子孫【！children】も含めて —
除去するべきである
◎
The element drop list is a sequence of strings with elements that the sanitizer should remove from the input, including its children.
</dd>

	<dt>`allowAttributes@m</dt>
	<dd>
`許容する属性~群@
を与える
— それは、次を決定するための`属性~照合-~map$である
⇒
属性は、
（所与の要素にて）許容されるべきかどうか
◎
The attribute allow list is an attribute match list, which determines whether an attribute (on a given element) should be allowed.
</dd>

	<dt>`dropAttributes@m</dt>
	<dd>
`落とす属性~群@
を与える
— それは、次を決定するための`属性~照合-~map$である
⇒
属性は、（所与の要素から）落とされるべきかどうか
◎
The attribute drop list is an attribute match list, which determines whether an attribute (on a given element) should be dropped.
</dd>

	<dt>`allowCustomElements@m</dt>
	<dd>
`~custom要素を許容する~option@
— `~custom要素$は考慮されるかどうかを決定する。
それらは、既定では落とされる。
この~optionが ~T の場合、
~custom要素であっても，他のすべての［
組込みの検査／環境設定された検査
］に対し検査されることになる。
◎
The allow custom elements option determines whether custom elements are to be considered. The default is to drop them. If this option is true, custom elements will still be checked against all other built-in or configured checks.
</dd>

	<dt>`allowComments@m</dt>
	<dd>
`~commentを許容する~option@
— ~HTML~commentは許容されるかどうかを決定する。
◎
The allow comments option determines whether HTML comments are allowed.
</dd>
</dl>

<p class="note">注記：
`allowElements$m は，既定では要素を落とす~sanitizerを作成する一方で、［
`blockElements$m ／ `dropElements$m
］は，既定では未知な要素を保つ。
両方とも利用することもアリであるが、
おそらく実用的な利用は少ない。
同じことは、［
`allowAttributes$m, `dropAttributes$m
］にも該当する。
◎
Note: allowElements creates a sanitizer that defaults to dropping elements, while blockElements and dropElements defaults to keeping unknown elements. Using both types is possible, but is probably of little practical use. The same applies to allowAttributes and dropAttributes.
</p>

<p class="note">注記：
要素~名は~HTML構文解析器の規則に従って正規化される。
このことは、
要素~名は通例的に
— すなわち，数少ない［
~HTML以外の名前空間（~SVG, ~MathML）に属する文字大小が混在した要素~名
］を除いて —
小文字になることを意味する。
◎
Note: Element names are normalized, following the rules of the HTML Parser. This means elements are usually lowercase, except for a small-ish number of mixed case element names in non-HTML namespaces (SVG, MathML).
</p>

<div class="example">

<pre class="lang-js">
  const %sample = `to_node$V("Some text &lt;b&gt;&lt;i&gt;with&lt;/i&gt;&lt;/b&gt; &lt;blink&gt;tags&lt;/blink&gt;.");
  const %script_sample = `to_node$V("abc &lt;script&gt;alert(1)&lt;/script&gt; def");

  /* Some text &lt;b&gt;with&lt;/b&gt; text tags. */
  new Sanitizer({allowElements: [ "b" ]}).sanitize(%sample);

  /* Some text &lt;i&gt;with&lt;/i&gt; &lt;blink&gt;tags&lt;/blink&gt;. */
  new Sanitizer({blockElements: [ "b" ]}).sanitize(%sample);

  /* Some text &lt;blink&gt;tags&lt;/blink&gt;. */
  new Sanitizer({dropElements: [ "b" ]}).sanitize(%sample);

  /* <span class="comment">
注記：
既定の環境設定は、
~XSSに関連な入力を取扱う：
◎
Note: The default configuration handles XSS-relevant input:
</span> */

  /* <span class="comment">
~scriptを伴わない入力は、
通過することになる：
◎
Non-scripting input will be passed through:
</span> */
  new Sanitizer().sanitize(%sample);  /* <span class="comment">
%sample を改変せずに出力することになる。
◎
Will output sample unmodified.
</span> */

  /* <span class="comment">
`script^e は阻止され、
`abc alert(1) def^l になる：
◎
Scripts will be blocked: "abc alert(1) def"
</span> */
  new Sanitizer().sanitize(%script_sample);
</pre>
</div>

<p>
［
要素／属性
］を［
許容する~list, 阻止する~list
］に加えて，一部の［
~node／要素
］型を環境設定する~optionもある。
◎
In addition to allow and block lists for elements and attributes, there are also options to configure some node or element types.
</p>

<div class="example">
<pre class="lang-js">
  /* <span class="comment">
~commentは、
既定では落とされることになる。
◎
Examples:
◎
Comments will be dropped by default.
</span> */
  const %comment = `to_node$V("Hello  World!");
  new Sanitizer().sanitize(%comment);  /* `Hello World!^l */
  new Sanitizer({allowComments: true}).sanitize(%comment);  /* <span class="comment">
結果は %comment と同じになる。
◎
Same as comment.
</span> */
</pre>
</div>

<p>
~sanitizerの環境設定は、
`getConfiguration()$m【！sanitizer config】 ~methodを利用して~queryできる。
◎
A sanitizer’s configuration can be queried using the query the sanitizer config method.
</p>

<div class="example">

<pre class="lang-js">
  /* <span class="comment">
既定の環境設定0は、
`script^e 要素を許容するか？
◎
Does the default config allow script elements?
</span> */
  Sanitizer.getDefaultConfiguration().allowElements.includes("script") /* false */

  /* <span class="comment">
~Sanitizer~instance %a_sanitizer を見出したとする。
その `allowElements$m （許容する要素~群）は環境設定されたか？
◎
We found a Sanitizer instance. Does it have an allow-list configured?
</span> */
  const %a_sanitizer = ...;
  !!%a_sanitizer.getConfiguration().allowElements /* <span class="comment">
結果は［
`allowElements$m は環境設定された
］ならば ~T になる。
◎
true, if an allowElements list is configured
</span> */

  /* <span class="comment">
`allowElements$m が %a_sanitizer に在る場合、
それは `div$tg 要素を含むか？
◎
If it does have an allow elements list, does it include the &lt;div&gt; element?
</span> */
  %a_sanitizer.getConfiguration().allowElements.includes("div")  /* <span class="comment">
結果は［
`allowElements$m 内に `div^l は在る
］ならば ~T になる。
◎
true, if "div" is in allowElements.
</span> */

  /* <span class="comment">
`getConfiguration()$m ~methodは、
何らかの正規化を行うかもしれないことに注意
【例：`要素~名を正規化する$など（実際には、構築-時に正規化される）】
。
例：~IDL【 `SanitizerConfig$I 】内に宣言されていない ( ~key, 値 ) ~pairは、
包含しないことになる
【これは、~Web~IDLにより自動的に施行されるので，この~APIに特有な挙動ではない（例として挙げるには不適切に思われる）】。
◎
Note that the getConfiguration method might do some normalization. E.g., it won’t contain key/value pairs that are not declare in the IDL.
</span> */
  Object.keys(new Sanitizer({madeUpDictionaryKey: "Hello"}).getConfiguration())  /* [] */

  /* <span class="comment">
~sanitizer【！~Sanitizer】の演算は，当の~sanitizerの環境設定0で述べられるので、
新たな~sanitizerの挙動は，別のそれと同じ環境設定を伴うならば一致するべきである。
【！(For illustration purposes only...】
◎
As a Sanitizer’s config describes its operation, a new sanitizer with another instance’s configuration should behave identically. (For illustration purposes only. It would make more sense to just use a directly.)
</span> */
  const %a = /* <span class="comment">
どこかで見出された，ある `Sanitizer^I
◎
... a Sanitizer we found somewhere ...
</span> */;
  const %b = new Sanitizer(%a.getConfiguration());  /* <span class="comment">
%b の挙動は %a と同じになるはずである。
◎
b should behave the same as a.
</span> */

  /* <span class="comment">
`new Sanitizer().getConfiguration()^c の結果は
`getDefaultConfiguration()^m 同じになるはずである
（~~説明用に限る
— ~JSには、~objの同等性を実装する，もっと良い仕方がある）。
◎
getDefaultConfiguration() and new Sanitizer().getConfiguration should be the same. (For illustration purposes only. There are better ways of implementing object equality in JavaScript.)
</span> */
  JSON.stringify(Sanitizer.getDefaultConfiguration()) == JSON.stringify(new Sanitizer().getConfiguration());  /* true */

  /* <span class="comment">
要素の名前は正規化される。
◎
Element names are normalized.
</span> */
  new Sanitizer({allowElements: ["EM", "sPAn"]}).config().allowElements  /* ["em", "span"] */

</pre>
</div>

			<section id="attr-match-list">
<h4 title="Attribute Match Lists">2.3.1. 属性~照合-~map</h4>

<p>
`属性~照合-~map@
は、属性~名から［
一連の要素~名からなる~list
］への`~map$である。
この~map内の特別な要素~名【！名前】 `*^l は、
すべての要素を表す。
◎
An attribute match list is a map of attribute names to element names, where the special name "*" stands for all elements.＼
</p>

<p class="trans-note">【
原文では， “属性~照合-~list” と称されているが、
無用な混同を避けるため，この訳では “属性~照合-~map” に改称する。
】</p>

<div class="algo">
<p>
%要素 に属する %属性 は`属性~照合-~map$ %~map に
`合致して@
いるかどうかは，次に従う：
</p>
<ol>
	<li>
%値 ~LET %~map[ %属性 の`局所-名$attr ]
</li>
	<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%値 ~NEQ ε
］~AND［［
`*^l ~IN %値
］~OR［
%要素 の`局所-名$ ~IN %値
］］
</li>
</ol>

◎
A given attribute belonging to an element matches an attribute match list, if the attribute’s local name is a key in the match list, and element’s local name or "*" are found in the attribute’s value list.
</div>

<pre class="idl">
typedef `record$&lt;`DOMString$, `sequence$&lt;`DOMString$&gt;&gt; `AttributeMatchList@I;
</pre>

<div class="example">

<p>
属性と`属性~照合-~map$用の例：
◎
Examples for attributes and attribute match lists:
</p>
<pre class="lang-js">
  const %sample = `to_node$V("&lt;span id='span1' class='theclass' style='font-weight: bold'&gt;hello&lt;/span&gt;");

  /* <span class="comment">
`span^e 要素に限り `style^a 属性を許容する：
`&lt;span style='font-weight: bold'&gt;...&lt;/span&gt;^c
◎
Allow only &lt;span style&gt;: &lt;span style='font-weight: bold'&gt;...&lt;/span&gt;
</span> */
  new Sanitizer({allowAttributes: {"style": ["span"]}}).sanitize(%sample);

  /* <span class="comment">
`style^a 属性を許容するのは `span^e ではない：
`&lt;span&gt;...&lt;/span&gt;^c
◎
Allow style, but not on span: &lt;span&gt;...&lt;/span&gt;
</span> */
  new Sanitizer({allowAttributes: {"style": ["div"]}}).sanitize(%sample);

  /* <span class="comment">
どの要素にも `style^a 属性を許容する：
`&lt;span style='font-weight: bold'&gt;...&lt;/span&gt;^c
◎
Allow style on any elements: &lt;span style='font-weight: bold'&gt;...&lt;/span&gt;
</span> */
  new Sanitizer({allowAttributes: {"style": ["*"]}}).sanitize(%sample);

  /* <span class="comment">
`span^e 要素に限り `id^a 属性を落とす：
`&lt;span class='theclass' style='font-weight: bold'&gt;...&lt;/span&gt;^c
◎
Drop &lt;span id&gt;: &lt;span class='theclass' style='font-weight: bold'&gt;...&lt;/span&gt;
</span> */
  new Sanitizer({dropAttributes: {"id": ["span"]}}).sanitize(%sample);

  /* <span class="comment">
どの要素からも `id^a 属性を落とす：
`&lt;span class='theclass' style='font-weight: bold'&gt;...&lt;/span&gt;^c
◎
Drop id, everywhere: &lt;span class='theclass' style='font-weight: bold'&gt;...&lt;/span&gt;
</span> */
  new Sanitizer({dropAttributes: {"id": ["*"]}}).sanitize(%sample);
</pre>
</div>

			</section>
		</section>
	</section>
	<section id="algorithms">
<h2 title="Algorithms">3. 各種~algo</h2>

		<section id="api-algorithms">
<h3 title="API Implementation">3.1. ~API実装</h3>

<div class="algo">
<p>
`~Sanitizerを初期化する@
ときは、所与の
( `Sanitizer$I %~sanitizer, `SanitizerConfig$I %環境設定0 （省略時は ε ） )
に対し，次の手続きを走らす：
</p>

<ol>
	<li>
~IF［
%環境設定0 ~EQ ε
］
⇒
%環境設定0 ~SET `既定の環境設定$
</li>
	<li>
%環境設定0 ~SET %環境設定0 の複製
</li>
	<li>
<p>
%環境設定0 内のすべての`要素~名を正規化する$
</p>

<p class="note">注記：
環境設定~objは、
%環境設定0 の［
`allowElements$m,
`blockElements$m,
`dropElements$m
］~member内, ［［
`allowAttributes$m,
`dropAttributes$m
］~memberが与える`属性~照合-~map$内の各~entryの値
］内に要素~名を包含する。
</p>

<p class="trans-note">【
この段では、
要素~名が妥当でない場合の挙動も指定されるべきであろう。
】</p>
	</li>
	<li>
%~sanitizer の`環境設定~obj$ ~SET %環境設定0
</li>
</ol>

<p class="trans-note">【
この手続きは、
原文では， “~Sanitizerを作成する” 手続きとして述べられているが、
この訳では，単に初期化のみを遂行するように改めている
— そのままだと `WEBIDL$r における`構築子~手続き$の規約と整合でないので。
】</p>

◎
To create a Sanitizer with an optional config parameter, run these steps:
• Let sanitizer be a newly created Sanitizer instance.
• Create a copy of config.
• Normalize all element names in config’s copy by running the normalize element name algorithm on each of them.
• Return sanitizer, with config’s copy as its configuration object.
◎
Note: The configuration object contains element names in the element allow list, element block list, and element drop list, and in the mapped values in the attribute allow list and attribute drop list.
</div>

<div class="algo">
<p>
`要素~名を正規化する@
ときは、所与の
( %名前 )
に対し，次の手続きを走らす：
◎
To normalize element name name, run these steps:
</p>
<ol>
	<li>
~RET `~ASCII小文字~化する$( %名前 )
◎
Convert name to ASCII lowercase.
◎
Return name.
</li>
</ol>

<div class="issue">
<p>
この~methodは、
現時点では~supportされていない［
~SVG要素／~MathML要素
］用には働かない。
そうなったときは、
上の手続きは次に置換されることになる：
◎
This method will not work for SVG and/or MathML elements, which are not currently supported. When they are, replace the steps above with:
</p>
<ol>
	<li>
%名前 ~SET `~ASCII小文字~化する$( %名前 )
◎
Convert name to ASCII lowercase.
</li>
	<li>
%接頭辞 ~LET 空~文字列
◎
Let prefix be the empty string.
</li>
	<li>
~IF［
%名前 は `:^l （ `003E^U ）を包含する
］
⇒＃
%接頭辞 ~SET %名前 の【最初の】 `:^l より前を成す部分,
%名前 ~SET %名前 の `:^l より後を成す部分
◎
If name contains a ":" (U+003E), then split the string on it and set prefix to the part before, and update name with the part after.
</li>
	<li>
~IF［
%接頭辞 ~IN { `svg^l, `math^l }
］
⇒
~HTML構文解析~仕様の
<a href="~HTMLparsing#parsing-main-inforeign">§ 外来の内容~内の~tokenを構文解析する規則</a>
の “その他の開始~tag” に従って，
%名前 を調整する
◎
If prefix is either "svg" or "math", then adjust the name as described in the "any other start tag" branch of the The rules for parsing tokens in foreign content subchapter in the HTML parsing spec.
</li>
	<li>
~RET %名前
◎
Return name.
</li>
</ol>
</div>
</div>

<div class="algo">
<p>
`Sanitizer$I %~sanitizer で
`~sanitizeする@
ときは、所与の
( `文書$または`文書片$ %入力 )
に対し，次の手続きを走らす：
◎
To sanitize a given input of type Document or DocumentFragment run these steps:
</p>
<ol>
	<li>
%文書片 ~LET `文書片を作成する$( %入力 )
◎
Let fragment be the result of running the create a document fragment algorithm on input.
</li>
	<li>
%~sanitizer で`文書片を~sanitizeする$( %文書片 )
◎
Run the sanitize a document fragment algorithm on fragment.
</li>
	<li>
~RET %文書片
◎
Return fragment.
</li>
</ol>

<div id="_test-sanitizer-sanitize"></div>
</div>

<div class="algo">
<p>
`Sanitizer$I %~sanitizer で
`要素~用に~sanitizeする@
ときは、所与の
( `文字列$ %要素~名, `文字列$ %入力 )
に対し，次の手続きを走らす：
◎
To sanitize for an element name of type DOMString and a given input of type DOMString run these steps:
</p>
<ol>
	<li>
%要素 ~LET `要素を作成する$( 現在の文書【？】, %要素~名, `~HTML名前空間$ )
◎
Let node be an HTML element created by running the steps of the creating an element algorithm with the current document, element, the [[HTML namespace]], and no optional parameters.
</li>
	<li>
~IF［
`要素~用の~baseline環境設定を決定する$( %要素 ) ~NEQ `保つ^i
］
⇒
~RET ~NULL
◎
If the result of running the steps of the determine the baseline configuration for an element algorithm for the element node is anything other than keep, then return null.
</li>
	<li>
%文書片 ~LET `素片を構文解析する$( %入力, %要素 )
◎
Let fragment be the result of invoking the html fragment parsing algorithm, with node as the context element and input as markup.
</li>
	<li>
%~sanitizer で`文書片を~sanitizeする$( %文書片 )
◎
Run the steps of the sanitize a document fragment algorithm on fragment.
</li>
	<li>
%要素 の`全~内容を~nodeで置換する$( %文書片 )
◎
Replace all with fragment as the node and node as the parent.
</li>
	<li>
~RET %要素
◎
Return node.
</li>
</ol>

<div id="_test-sanitizer-sanitizeFor"></div>
</div>

<div class="algo">
<p>
`要素~用に~sanitizeして設定する@
ときは、所与の
( `要素$ %要素, `文字列$ %値, `SetHTMLOptions$I %~option群 )
に対し，次の手続きを走らす：
◎
To sanitize and set a value using an SetHTMLOptions options dictionary on an Element node this, run these steps:
</p>
<ol>
	<li>
~IF［
%要素 の`種類$elm ~EQ `正則^i
］~AND［
%要素 【の`局所-名$】 ~NIN `要素~用の~baseline許容-~list$
］
⇒
~THROW`TypeError$E
◎
If the element kind of this is regular and this does not match any name in the baseline element allow list, then throw a TypeError and return.
</li>
	<li>
%~sanitizer ~LET %~option群[ "`sanitizer$m" ]
◎
↓</li>
	<li>
<p>
~IF［
%~sanitizer ~EQ ε
］：
</p>
		<ol>
			<li>
%~sanitizer ~SET 新たな `Sanitizer$I ~obj
</li>
			<li>
`~Sanitizerを初期化する$( %~sanitizer )
</li>
		</ol>
◎
If the sanitizer member exists in the options SetHTMLOptions dictionary,
• then let sanitizer be the value of the sanitizer member of the options SetHTMLOptions dictionary,
• otherwise let sanitizer be the result of the create a Sanitizer algorithm without a config parameter.
</li>
	<li>
%文書片 ~LET `素片を構文解析する$( %値, %要素 )
◎
Let fragment be the result of invoking the html fragment parsing algorithm with this as the context node and value as markup.
</li>
	<li>
【！Run the steos if the】
%~sanitizer で`文書片を~sanitizeする$( %文書片 )
◎
Run the steos if the sanitize a document fragment algorithm on fragment, using sanitizer as the current Sanitizer instance.
</li>
	<li>
%要素 の`全~内容を~nodeで置換する$( %文書片 )
◎
Replace all with fragment as the node and this as the parent.
</li>
</ol>

<div id="_test-element-set-sanitized-html"></div>
</div>

<div class="algo">
<p>
`Sanitizer$I %~sanitizer の
`環境設定0を~queryする@
ときは、次の手続きを走らす：
◎
To query the sanitizer config of a given sanitizer instance, run these steps:
• Let sanitizer be the current Sanitizer.
</p>
<ol>
	<li>
%環境設定0 ~LET %~sanitizer の`環境設定~obj$
【！は在るならば それ／無いならば`既定の環境設定$】
◎
Let config be sanitizer’s configuration object, or the default configuration if no configuration object was given.
</li>
	<li>
%結果 ~LET 新たな`~map$
【！新たに構築された SanitizerOptions 辞書】
◎
Let result be a newly constructed SanitizerOptions dictionary.
</li>
	<li>
【！%環境設定0 を成す ~EACH( %~key → %値 ) に対し／~IF［%~key は SanitizerOptions 内に宣言されている］／%結果[ %~key ] ~SET %値】

`SanitizerConfig$I 内に宣言された
~EACH( ~member名 %名前 )
に対し
⇒
~IF［
%環境設定0[ %名前 ] ~NEQ ε
］
⇒
%結果[ %~key ] ~SET %環境設定0[ %名前 ]
◎
For any non-empty member of config whose key is declared in SanitizerOptions, copy the value to result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<div id="_test-sanitizer-config"></div>
<div id="_test-sanitizer-query-config"></div>
</div>

		</section>
		<section id="helper-algorithms">
<h3 title="Helper Definitions">3.2. 補助用の定義</h3>

<div class="algo">
<p>
`文書片を作成する@
ときは、所与の
( `文書$または`文書片$ %入力 )
に対し，次の手続きを走らす：
◎
To create a document fragment named fragment from an input of type Document or DocumentFragment, run these steps:
</p>
<ol>
	<li>
%~node ~LET %入力 の型に応じて
⇒＃
`文書片$であるならば %入力 ／
`文書$であるならば %入力 の`文書~要素$【！documentElement】
◎
Switch based on input’s type:
• If input is of type DocumentFragment, then:
•• Let node refer to input.
• If input is of type Document, then:
•• Let node refer to input’s documentElement.
</li>
	<li>
%文書 ~LET 【原文には指定されていない： %入力 の`~node文書$？】
◎
↓</li>
	<li>
%~clone ~LET `~nodeを~cloneする$( %~node, %文書, `子も~cloneする^i )
◎
Let clone be the result of running clone a node on node with the clone children flag set to true.
</li>
	<li>
【！result of createDocumentFragment】
%文書片 ~LET 次のように設定された新たな`文書片$
⇒
その`~node文書$ ~SET %文書
◎
Let fragment be the result of createDocumentFragment.
</li>
	<li>
%文書片 に`~nodeを付加する$( %~clone )
◎
Append the node clone to the parent fragment.
</li>
	<li>
~RET %文書片
◎
Return fragment.
</li>
</ol>
</div>

		</section>
		<section id="sanitizer-algorithms">
<h3 title="Sanitization Algorithms">3.3. 各種~sanitization~algo</h3>

<div class="algo">
<p>
`Sanitizer$I %~sanitizer で
`文書片を~sanitizeする@
ときは、所与の
( `文書片$ %文書片 )
に対し，次の手続きを走らす：
◎
To sanitize a document fragment named fragment run these steps:
</p>
<ol>
	<li>
%m ~LET 新たな`~map$
◎
Let m be a map that maps nodes to a sanitize action
</li>
	<li>
%~node群 ~LET %文書片 のすべての`広義~子孫$からなる`~tree順序$による`~list$
◎
Let nodes be a list containing the inclusive descendants of fragment, in tree order.
</li>
	<li>
<p>
%~node群 を成す
~EACH( %~node )
に対し：
◎
For each node in nodes:
</p>
		<ol>
			<li>
%動作 ~LET %~sanitizer で`~nodeを~sanitizeする$( %~node )
◎
Let action be the result of running the sanitize a node algorithm on node.
</li>
			<li>
%m[ %~node ] ~SET %動作
◎
Insert node and action into m
</li>
		</ol>
	</li>
	<li>
<p>
%~node群 を成す
~EACH( %~node )
に対し，
%m[ %~node ] に応じて：
◎
For each node in nodes:
</p>
		<ul class="switch">
			<li>
`落とす^i
⇒
%文書片 から［
%~node , %~node のすべての子孫【！children】
］を除去する
◎
If m[node] is drop, remove the node and all children from fragment.
</li>
			<li>
`阻止する^i
⇒
%文書片 から %~node を除去して，
%~node のすべての子［
要素／~text
］~nodeで置換する
◎
If m[node] is block, replace the node with all of its element and text node children from fragment.
</li>
			<li>
`保つ^i
⇒
何もしない
◎
If m[node] is keep, do nothing.
</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`Sanitizer$I %~sanitizer で
`~nodeを~sanitizeする@
ときは、所与の
( `~node$ %~node )
に対し，
%~node が何を実装するかに応じて，次の手続きを走らす：
◎
To sanitize a node named node run these steps:
• Let sanitizer be the current Sanitizer.
</p>
<ul class="switch">
	<li>
<p>
`Element$I ：
◎
If node is an element node:
</p>
		<ol>
			<li>
%要素 ~LET %~node
◎
Let element be node’s element.
</li>
			<li>
<p>
%要素 の`属性~list$を成す
~EACH( %属性 )
に対し：
◎
For each attr in element’s attribute list:
</p>
				<ol>
					<li>
%属性~動作 ~LET `有効果な属性~環境設定$( %~sanitizer, %属性, %要素 )
◎
Let attr action be the resulf of running the effective attribute configuration algorithm on sanitizer, attr, and element.
</li>
					<li>
~IF［
%属性~動作 ~NEQ `保つ^i
］
⇒
%要素 から %属性 を除去する
◎
If attr action is different from keep, remove attr from element.
</li>
				</ol>
			</li>
			<li>
`~funkyな要素を取扱う$( %要素 )
◎
Run the steps to handle funky elements on element.
</li>
			<li>
%動作 ~LET `有効果な要素~環境設定$( %~sanitizer, %要素 )
◎
Let action be the resulf of running the effective element configuration algorithm on sanitizer and element.
</li>
			<li>
~RET %動作
◎
Return action.
</li>
		</ol>
	</li>
	<li>
<p>
`Document$I ／
`DocumentFragment$I
：
</p>
		<ol>
			<li>
~IF［
%~node の`親$ ~EQ ~NULL
］
⇒
~RET `保つ^i
</li>
			<li>
<p>
~GOTO その他
</p>
<p class="trans-note">【
<a href="~DOM4#node-trees">~node~treeに課される拘束</a>により，常に［
%~node の`親$ ~EQ ~NULL
］になるので、この段に達することは無いはず。
】</p>
			</li>
		</ol>
◎
If node is a Document or DocumentFragment node and if node’s parent is null: Return keep.
</li>
	<li>
<p>
`Comment$I ：
◎
If node is a Comment node:
</p>
		<ol>
			<li>
%環境設定0 ~LET %~sanitizer の`環境設定~obj$
【！は在るならば それ／無いならば `既定の環境設定$】
◎
Let config be sanitizer’s configuration object, or the default configuration if no configuration object was given.
</li>
			<li>
~IF［
%環境設定0[ "`allowComments$m" ]【！の`~commentを許容する~option$】 ~EQ ~T
］
⇒
~RET `保つ^i
◎
If config’s allow comments option is present and is set to to true: Return keep.
</li>
			<li>
~RET `落とす^i
◎
Return drop.
</li>
		</ol>
	</li>
	<li>
`Text$I
⇒
~RET `保つ^i
◎
If node is a Text node: Return keep.
</li>
	<li>
その他
⇒
~RET `落とす^i
◎
Return drop
</li>
</ul>
</div>

<p>
一部の~HTML要素には、［
環境設定~option群や他の~algoの用語では容易に表出できない，特別な扱い
］を要求するものもある。
次の~algoは、これらを一箇所に収集する。
◎
Some HTML elements require special treatment in a way that can’t be easily expressed in terms of configuration options or other algorithms. The following algorithm collects these in one place.
</p>

<div class="algo">
<p>
`~funkyな要素を取扱う@
ときは、所与の
( %要素 )
に対し，次の手続きを走らす：
◎
To handle funky elements on a given element, run these steps:
</p>
<ol>
	<li>
<p>
~IF［
%要素 の`要素~interface$ ~EQ `HTMLTemplateElement$I
］：
◎
If element’s element interface is HTMLTemplateElement:
</p>
		<ol>
			<li>
%~sanitizer で`文書片を~sanitizeする$( %要素 の`~template内容$ )
◎
Run the steps of the sanitize a document fragment algorithm on element’s content attribute, and replace element’s content attribute with the result.
</li>
			<li>
%要素 のすべての子~nodeを落とす
【 %要素 から すべての子~nodeを除去する】
◎
Drop all child nodes of element.
</li>
		</ol>
	</li>
	<li>
~IF［
%要素 の`要素~interface$は
`HTMLHyperlinkElementUtils$I ~mixinを`内包する$
］~AND［
%要素 の `protocol$m ~prop ~EQ `javascript:^l
］
⇒
%要素 から `href^a 属性を除去する
◎
If element’s element interface has a HTMLHyperlinkElementUtils mixin, and if element’s protocol property is "javascript:":
• Remove the href attribute from element.
</li>
	<li>
<p>
~IF［
%要素 の`要素~interface$ ~EQ `HTMLFormElement$I
］~AND［
%要素 の `action$a 属性は
`javascript:^c ~protocolを伴う`~URL$である†
］
⇒
%要素 から `action$a 属性を除去する
◎
if element’s element interface is HTMLFormElement, and if element’s action attribute is a [URL] with javascript: protocol:
• Remove the action attribute from element.
</li>
	<li>
~IF［
%要素 の`要素~interface$ ~IN { `HTMLInputElement$I, `HTMLButtonElement$I }
］~AND［
%要素 の `formaction$a 属性は
`javascript:^c ~protocolを伴う`~URL$である†
］
⇒
%要素 から `formaction$a 属性を除去する
◎
if element’s element interface is HTMLInputElement or HTMLButtonElement, and if element’s formaction attribute is a [URL] with javascript: protocol
• Remove the formaction attribute from element.
</li>
</ol>

<p class="trans-note">【†
もっと厳密には、
%要素 は当の属性を有していて，その値は`妥当な~URL文字列$であることも要求されよう。
】</p>

</div>

			<section id="configuration-algorithms">
<h4 title="The Effective Configuration">3.3.1. 有効果な環境設定</h4>

<p>
`Sanitizer$I は，複階的にもなり得るので、
補助用の構成子として，`有効果な環境設定^emを定義する。
これは，ほぼ仕様の便利~用にあり、
`Sanitizer$I の演算を次の 2 つの段で説明することを策定者に許容する
⇒＃
(1) ：有効果な環境設定を導出する方法,
(2) ：当の `Sanitizer$I の演算を (1) の結果に基づいて定義する
◎
A Sanitizer is potentially complex, so we will define a helper construct, the effective configuration. This is mostly a specification convenience and allows us to explain a Sanitizer’s operation in two steps: One, how to derive the effective configuration, and two, define the Sanitzer’s operation based on it.
</p>

<p>
有効果な環境設定は［
所与の %要素 ／
所与の ( %要素, %属性 ) が成す~pair
］を`~sanitizeする動作$へ対応付ける。
◎
An effective configuration maps a given element or a given pair of element and attribute to a sanitize action.
</p>

<p>
`~sanitizeする動作@
は［
`保つ^i ／ `落とす^i ／ `阻止する^i
］いずれかをとり得る。
◎
A sanitize action can have the values keep, drop, or block.＼
</p>

<div class="algo">
<p>
2 つの`~sanitizeする動作$に対し
`より厳密な動作@
を決定するときは
⇒
［
`落とす^i, `阻止する^i, `保つ^i
］の順に “大きい” と見做す下で，
2 つのうち “大きい方” を返す。
◎
To determine the stricter action of two sanitize actions, pick the 'larger' of the two actions assuming a transitively defined order with drop &gt; block, and block &gt; keep.
</p>
</div>

<div class="algo">
<p>
`有効果な要素~環境設定@
を決定するときは、所与の
( `Sanitizer$I %~sanitizer, 要素 %要素 )
に対し，次の手続きを走らす：
◎
To determine a Sanitizer sanitizer’s effective element configuration for an element element, run these steps:
</p>
<ol>
	<li>
%環境設定0 ~LET %~sanitizer の`環境設定~obj$
◎
Let config be sanitizer’s configuration object.
</li>
	<li>
%~baseline動作 ~LET `要素~用の~baseline環境設定を決定する$( %要素 )
◎
Let baseline action be the result of running the steps of the determine the baseline configuration for an element algorithm for the element element.
</li>
	<li>
%環境設定0動作 ~LET `要素~用の有効果な環境設定を決定する$( %要素, %環境設定0 )
◎
Let config action be the result of running the steps of the determine the effective configuration for an element algorithm for the element element and the config config.
</li>
	<li>
~RET `より厳密な動作$( %~baseline動作, %環境設定0動作 )
◎
Return the stricter action of baseline action and config action.
</li></ol>

<p class="note">注記：
より厳密な動作の定義は、
組込みの`~baseline環境設定$は上書きし得ないことを確保する
— したがって，すべての `Sanitizer$I ~instance用の~~絶対的な保証を形成する。
属性~用のそれ【`有効果な属性~環境設定$におけるそれ】と同様に。
◎
Note: The definition of stricter actions ensures that the built-in baseline configuration cannot be overriden, and therefor forms a hard guarantee for all Sanitizer instances. Likewise for attributes.
</p>
</div>

<div class="algo">
<p>
`有効果な属性~環境設定@
を決定するときは、所与の
( `Sanitizer$I %~sanitizer, 属性 %属性, 要素 %要素 )
に対し，次の手続きを走らす：
◎
To determine a Sanitizer sanitizer’s effective attribute configuration for an attribute attr attached to an element element, run these steps:
</p>
<ol>
	<li>
%環境設定0 ~LET %~sanitizer の`環境設定~obj$
◎
Let config be sanitizer’s configuration object.
</li>
	<li>
%~baseline動作 ~LET `属性~用の~baseline環境設定を決定する$( %属性 )
◎
Let baseline action be the result of running the steps of the determine the baseline configuration for an attribute algorithm on the attribute attr.
</li>
	<li>
%環境設定0動作 ~LET `属性~用の有効果な環境設定を決定する$( %属性, %要素, %環境設定0 )
◎
Let config action be the result of running the steps of the determine the effective configuration for an attribute algorithm on the attribute attr, with the element element and the config config.
</li>
	<li>
~RET `より厳密な動作$( %~baseline動作, %環境設定0動作 )
◎
Return the stricter action of baseline action and config action.
</li>
</ol>
</div>

<p>
有効果な環境設定がどう導出されるか述べる前に，ある補助用の定義が必要になる：
◎
Before describing how an effective configuration is derived, we need a helper definition:
</p>

<div class="algo">
<p>
%要素 の
`種類@elm
は、［
`正則^i,
`未知^i,
`~custom^i
］いずれかであり，次に従って決定される：
◎
The element kind of an element is one of regular, unknown, or custom. Let element kind be:
</p>
<ol>
	<li>
~IF［
%要素 の`局所-名$は`妥当な~custom要素~名$である
］
⇒
~RET `~custom^i
◎
custom, if element’s local name is a valid custom element name,
</li>
	<li>
~IF［
%要素 は~HTML名前空間 `HTML$r に属さない
］
⇒
~RET `未知^i
◎
unknown, if element is not in the [HTML] namespace＼
</li>
	<li>
~IF［
%要素 の`局所-名$は未知な要素を表す
— すなわち， `HTML$r 仕様が %要素 にアテガう`要素~interface$は `HTMLUnknownElement$I である
］
⇒
~RET `未知^i
◎
or if element’s local name denotes an unknown element — that is, if the element interface the [HTML] specification assigns to it would be HTMLUnknownElement,
</li>
	<li>
~RET `正則^i
◎
regular, otherwise.
</li>
</ol>
</div>

<div class="algo">
<p>
類似に，
%属性 の
`種類@attr
は、［
`正則^i, `未知^i
］いずれかであり，次に従って決定される：
◎
Similarly, the attribute kind of an attribute is one of regular or unknown. Let attribute kind be:
</p>
<ol>
	<li>
~RET 
`HTML$r 仕様は %属性 の名前に何らかの意味を
⇒＃
アテガうならば `正則^i ／
アテガわないならば `未知^i
◎
unknown, if the [HTML] specification does not assign any meaning to attribute’s name.
◎
regular, otherwise.
</li>
</ol>

<p class="trans-note">【
“何らかの意味をアテガう” の精確な定義は、
述べられていない。
（例：<a href="~HTMLobs">廃用にされた旧来の属性</a>の`種類$attrは、どちらになる？）
】</p>
</div>

<p class="issue">
この仕様は、
現時点では［
~MathML／~SVG
］を `未知^i な内容として扱う
— したがって既定では阻止される。
これは、修正される必要がある。
<a href="https://github.com/WICG/sanitizer-api/issues/72">課題 #72</a>
◎
The spec currently treats MathML and SVG as unknown content and therefore blocked by default. This needs to be fixed. [Issue #WICG/sanitizer-api#72]
</p>

<div class="algo">
<p>
`要素~用の有効果な環境設定を決定する@
ときは、所与の
( %要素, `環境設定~obj$ %環境設定0 )
に対し，次の手続きを走らす：
◎
To determine the effective configuration for an element element, given a configuration object config, run these steps:
</p>
<ol>
	<li>
~IF［
%要素 の`種類$elm ~EQ `~custom^i
］~AND［
%環境設定0[ "`allowCustomElements$m" ] ~NEQ ~T
］
⇒
~RET `落とす^i
◎
If element’s element kind is custom and if config’s allow custom elements option is unset or set to anything other than true: Return drop.
</li>
	<li>
%名前 ~LET %要素 の`局所-名$
◎
Let name be the element’s local name.
</li>
	<li>
%落とす要素~群 ~LET %環境設定0[ "`dropElements$m" ]
◎
↓</li>
	<li>
~IF［
%落とす要素~群 ~NEQ ε
］~AND［
%名前 ~IN %落とす要素~群
］
⇒
~RET `落とす^i
◎
If name is in config’s element drop list: Return drop.
</li>
	<li>
%阻止する要素~群 ~LET %環境設定0[ "`blockElements$m" ]
◎
↓</li>
	<li>
~IF［
%阻止する要素~群 ~NEQ ε
］~AND［
%名前 ~IN %阻止する要素~群
］
⇒
~RET `阻止する^i
◎
If name is in config’s element block list: Return block.
</li>
	<li>
%許容する要素~群 ~LET %環境設定0[ "`allowElements$m" ]
◎
↓</li>
	<li>
~IF［
%許容する要素~群 ~EQ ε
］~OR［
%許容する要素~群 は空である
］
⇒
%許容する要素~群 ~SET `既定の環境設定$[ "`allowElements$m" ]
◎
↓</li>
	<li>
~IF［
%名前 ~NIN【！not it】 %許容する要素~群
］
⇒
~RET `阻止する^i
◎
If config has a non-empty element allow list and name is not in config’s element allow list: Return block.
◎
If config does not have a non-empty element allow list and name is not it the default configuration's element allow list: Return block.
</li>
	<li>
~RET `保つ^i
◎
Return keep.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性~用の有効果な環境設定を決定する@
ときは、所与の
(  %属性, %要素, `環境設定~obj$ %環境設定0 )
に対し，次の手続きを走らす：
◎
To determine the effective configuration for an attribute attr, attached to an element element, and given a configuration object config, run these steps:
</p>
<ol>
	<li>
%落とす属性~群 ~LET %環境設定0[ "`dropAttributes$m" ]
◎
↓</li>
	<li>
~IF［
%落とす属性~群 ~NEQ ε
］~AND［
( %要素, %属性 ) は %落とす属性~群 に`合致して$いる
］
⇒
~RET `落とす^i
◎
if config’s attribute drop list contains attr’s local name as key, and the associated value contains either element’s ]=Element/local name=] or the string "*": Return drop.
</li>
	<li>
%許容する属性~群 ~LET %環境設定0[ "`allowAttributes$m" ]
◎
↓</li>
	<li>
~IF［
%許容する属性~群 ~EQ ε
］~OR［
%許容する属性~群 は空である
］
⇒
%許容する属性~群 ~SET `既定の環境設定$[ "`allowAttributes$m" ]
◎
↓</li>
	<li>
~IF［
( %要素, %属性 ) は %許容する属性~群 に`合致して$いない
］
⇒
~RET `落とす^i
◎
If config has a non-empty attribute allow list and it does not contain attr’s local name, or attr’s associated value contains neither element’s local name nor the string "*": Return drop.
◎
if config does not have a non-empty attribute allow list and default configuration's attribute allow list does not contain attr’s local name, or attr’s associated value contains neither element’s local name nor the string "*": Return drop.
</li>
	<li>
~RET `保つ^i
◎
Return keep.
</li>
</ol>

<p class="note">注記：
~Sanitizer環境設定~内の要素~名は、
要素の`局所-名$と同じく，~HTML構文解析器における正規化~段に則って正規化される。
したがって、比較は，実質的に文字大小無視になる。
◎
Note: The element names in the Sanitizer configuration are normalized according to normalization step in the HTML Parser, just like elements' local names are. Thus, the comparison is effectively case insensitive.
</p>
</div>

			</section>
		</section>
		<section id="defaults">
<h3 title="Baseline and Defaults">3.4. ~baseline環境設定と既定の環境設定</h3>

<p class="issue">
~sanitizerの［
`~baseline環境設定$, `既定の環境設定$【！baseline and defaults】
］は、
注意深く審査する必要があり，依然として論の最中にある。
以下に与える値は、~~説明用に限られる。
◎
The sanitizer baseline and defaults need to be carefully vetted, and are still under discussion. The values below are for illustrative purposes only.
</p>

<div class="algo">
<p>
`要素~用の~baseline環境設定を決定する@
ときは、所与の
( %要素 )
に対し，［
次が満たされるならば `落とす^i ／
~ELSE_ `保つ^i
］を返す
⇒
［
%要素 の`種類$elm ~EQ `正則^i
］~AND［
%要素 の`局所-名$ ~NIN `要素~用の~baseline許容-~list$
］
◎
To determine the baseline configuration for an element element, run these steps:
• if element’s element kind is regular and if element’s local name is not in the baseline element allow list: Return drop.
• Return keep.
</p>
</div>

<div class="algo">
<p>
`属性~用の~baseline環境設定を決定する@
ときは、所与の
( %属性 )
に対し，［
次が満たされるならば `落とす^i ／
~ELSE_ `保つ^i
］を返す
⇒
［
%属性 の`種類$attr ~EQ `正則^i
］~AND［
%属性 の名前 ~NIN `属性~用の~baseline許容-~list$
］
◎
To determine the baseline configuration for an attribute attr, run these steps:
• If attr’s attribute kind is regular and if attr’s name is not in the baseline attribute allow list: Return drop
• Return keep.
</p>
</div>

<p>
~sanitizerには、
組込みの`既定の環境設定$がある
— それは、`~baseline環境設定$【！the baseline】より厳密であり，
~script注入の可能性, および［
旧来の／通例的でない
］構成子は，どれも排することを目指す。
◎
The sanitizer has a built-in default configuration, which is stricter than the baseline and aims to eliminate any script-injection possibility, as well as legacy or unusual constructs.
</p>

<p>
`~baseline環境設定@
は、
<a href="#constants">付録 A</a>
にて与える~JSON定数［
`要素~用の~baseline許容-~list$, `属性~用の~baseline許容-~list$
］により定義される。
既定の環境設定【！baseline and defaults】は、
<a href="#constants">付録 A</a>
にて与える~JSON定数 `既定の環境設定$により定義される。
◎
The defaults and baseline are defined by three JSON constants, baseline element allow list, baseline attribute allow list, default configuration. For better readability, these have been moved to an appendix A.
</p>

		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">4. ~securityの考慮点</h2>

<p>
~Sanitizer~APIに意図されるのは、
~DOMに基づく~XSS（ `DOM-based Cross-Site Scripting^en ）を防止することである
— 給された~HTML内容を走査して，環境設定に則って［
要素／属性
］を除去することにより。
この~APIの仕様は、［
~script能力がある~markupを残すような `Sanitizer$I ~objの構築
］を~supportしてはナラナイ
— そうすることは、
脅威~modelにおける~bugになろう。
◎
The Sanitizer API is intended to prevent DOM-based Cross-Site Scripting by traversing a supplied HTML content and removing elements and attributes according to a configuration. The specified API must not support the construction of a Sanitizer object that leaves script-capable markup in and doing so would be a bug in the threat model.
</p>

<p>
とは言え、
~Sanitizer~APIの正しい用法では保護-可能でない，~securityの課題はある
— 以下の下位節では、
そのような局面について~~述べる。
◎
That being said, there are security issues which the correct usage of the Sanitizer API will not be able to protect against and the scenarios will be laid out in the following sections.
</p>

		<section id="server-side-xss">
<h3 title="Server-Side Reflected and Stored XSS">4.1. ~server側に反映され, 格納される~XSS</h3>

~INFORMATIVE

<p>
~Sanitizer~APIは、
もっぱら~DOM内で演算する
— それは、
既存の`文書片$を走査して~filterするための能力を追加する。
~Sanitizerは、［
~server側に反映され, 格納される~XSS
］には取組まない。
◎
The Sanitizer API operates solely in the DOM and adds a capability to traverse and filter an existing DocumentFragment. The Sanitizer does not address server-side reflected or stored XSS.
</p>

		</section>
		<section id="dom-clobbering">
<h3 title="DOM clobbering">4.2. ~DOM~clobbering</h3>

~INFORMATIVE

<p>
~DOM~clobbering【 “痛めつけ” 】は、
悪意的な~HTMLで~appを惑わす攻撃である
— そこでは、［
要素の［
`id^a や `name^a
］属性を命名することにより，［
~DOM内の~HTML要素の `children^m の様な~prop
］が悪意的な内容により隠蔽される。
◎
DOM clobbering describes an attack in which malicious HTML confuses an application by naming elements through id or name attributes such that properties like children of an HTML element in the DOM are overshadowed by the malicious content.
</p>

<p>
~Sanitizer~APIは、
既定の状態では，~DOM~clobbering攻撃を保護しないが、
`id^a 属性や `name^a 属性を除去するよう環境設定することはできる。
◎
The Sanitizer API does not protect DOM clobbering attacks in its default state, but can be configured to remove id and name attributes.
</p>

		</section>
		<section id="script-gadgets">
<h3 title="XSS with Script gadgets">4.3. ~script~gadgetを伴う~XSS</h3>

~INFORMATIVE

<p>
~script~gadgetは、
既存の［
普及している~JS~libraryからの~app~code
］を利用して，攻撃者が自前の~codeを実行させる技法である。
これは、［
ある~frameworkに限り，構文解析され解釈される
］ような［
見かけは潔白な~code／不活そうに見える~DOM~node
］を注入することにより行われることが多く、
その入力に基づいて~JSの実行を遂行する。
◎
Script gadgets are a technique in which an attacker uses existing application code from popular JavaScript libraries to cause their own code to execute. This is often done by injecting innocent-looking code or seemingly inert DOM nodes that is only parsed and interpreted by a framework which then performs the execution of JavaScript based on that input.
</p>

<p>
~Sanitizer~APIは、
これらの攻撃は防止できないが，［
次に挙げるものは、明示的に許容すること
］を~page作者に要求する：
◎
The Sanitizer API can not prevent these attacks, but requires page authors to explicitly allow＼
</p>
<ul>
	<li>
~HTMLに未知な［
属性／要素
］
◎
attributes and elements that are unknown to HTML＼
</li>
	<li>
［
~template化, ~framework
］に特有な~code用に広く利用されていることが既知な~markup
— ［
`data-$a, `slot$a
］属性や［
`slot$tg, `template$tg
］要素など。
◎
and markup that is known to be widely used for templating and framework-specific code, like data- and slot attributes and elements like &lt;slot&gt; and &lt;template&gt;.＼
</li>
</ul>

<p>
これらの制約は、
網羅的でないと予見される。
~page作者には、［
自身が利用している第三者主体~libraryを，この挙動に関して精査すること
］が奨励される。
◎
We believe that these restrictions are not exhaustive and encourage page authors to examine their third party libraries for this behavior.
</p>

		</section>
		<section id="mutated-xss">
<h3 title="Mutated XSS">4.4. ~mXSS</h3>

~INFORMATIVE

<p>
~mXSS
（ `Mutated Cross-Site Scripting^en ／ `Mutated XSS^en の略称）は、［
~HTML~code片を不正な文脈の下で構文解析するとき，構文解析器~文脈が合致しないこと
］に基づく攻撃である。
特に，【ある親~要素の中で】~HTML素片を構文解析してから文字列に直列化した結果は、
異なる親~要素の中に挿入されるとき，~~元と正確に同じに［
構文解析され, 解釈される
］ことは保証されない。
そのような攻撃を遂げる例には、［
外来の内容や誤って入子にされた~tagに対し，構文解析の挙動が変化すること
］に依拠するものがある。
◎
Mutated XSS or mXSS describes an attack based on parser context mismatches when parsing an HTML snippet without the correct context. In particular, when a parsed HTML fragment has been serialized to a string, the string is not guaranteed to be parsed and interpreted exactly the same when inserted into a different parent element. An example for carrying out such an attack is by relying on the change of parsing behavior for foreign content or misnested tags.
</p>

<p>
~Sanitizer~APIは、
~mXSSに抗する助けを提供するが，開発者による ある程度の協力にも依拠する。
`sanitize()$m ~method【！function】は、
文字列を取扱わないので影響されない。
`setHTML()$m ~method【！function】は、
~sanitizationと~DOM改変を組合せて，正しい文脈を暗黙的に適用できる。
`sanitizeFor()$m ~method【！function】は、
構文解析と~sanitizationを組合せるが，
その結果の最終的な適用は開発者が正しい文脈を給することに依拠する。
◎
The Sanitizer API offers help against Mutated XSS, but relies on some amount of cooperation by the developers.＼
The sanitize() function does not handle strings and is therefore unaffected.＼
The setHTML function combines sanitization with DOM modification and can implicitly apply the correct context.＼
The sanitizeFor() function combines parsing and sanitization, and relies on the developer to supply the correct context for the eventual application of its result.
</p>

<p>
~sanitizeされる~dataが~node~treeとして可用な場合、
作者には， `sanitize()$m ~method【！function】を利用することが奨励される
— それは、`文書片$を返すことに加え，
直列化と追加的な構文解析につきまとう~riskを避ける。
~sanitizeした結果の文書片に対し直に演算すれば、
直列化と構文解析による追加的な~costも避けられるので，処理能の便益もついてくる。
◎
If the data to be sanitized is available as a node tree, we encourage authors to use the sanitize() function of the API which returns a DocumentFragment and avoids risks that come with serialization and additional parsing. Directly operating on a fragment after sanitization also comes with a performance benefit, as the cost of additional serialization and parsing is avoided.
</p>

<p>
~mXSSに対する，より完全な扱いは、
`MXSS$r にて見出せる。
◎
A more complete treatement of mXSS can be found in [MXSS].
</p>

		</section>
	</section>
	<section id="ack">
<h2 title="Acknowledgements">5. 謝辞</h2>

<p>
［
`Cure53^en の `DOMPURIFY$r
］による［
この文書が述べる~API
］用の明瞭な発想に。
`Internet Explorer^en の
<a href="https://msdn.microsoft.com/en-us/library/cc848922(v=vs.85).aspx">`window.toStaticHTML()^c</a>
にも。
◎
Cure53’s [DOMPURIFY] is a clear inspiration for the API this document describes, as is Internet Explorer’s window.toStaticHTML().
</p>

	</section>
	<section id="constants">
<h2 title="Appendix A: Built-in Constants">付録 A. 組込みの定数</h2>

<p>
`この付録は、他が明示的に注記された所を除き，規範的である。^em
◎
This appendix is normative, except where explicitly noted otherwise.
</p>

<p>
これらの定数は、
~Sanitizer~algoの中核を成す挙動を定義する。
◎
These constants define core behaviour of the Sanitizer algorithm.
</p>

		<section id="builtins-justification">
<h3 title="Built-ins Justification">組込みの【環境設定の】正当性</h3>

<p>
`この下位節は、まだまだ規範的でない。^em
◎
This subsection is super duper non-normative.
</p>

<p class="note">注記：
これらの定数を成す規範的な値は、
以下に見出される。
これらの由来は、［
`DEFAULTS$r による~script
］による実装と伴に，ここに説明される。
これらの値は、
この仕様が完結する前に変更されるものと予期される。
これらはまた、
追加的な~HTML要素が~UAに導入されるに伴い，
それを含むよう更新されるものと期待される。
◎
Note: The normative values of these constants are found below. The derivation of these are explained here, with an implementation in the [DEFAULTS] script. It is expected that these values will change before this specification is finalized. Also, we expect these to be updated to include additional HTML elements as they are introduced in user agents.
</p>

<p>
~Sanitizer~APIの目的においては、
`HTML$r の構成子は，次に挙げる 4 種に~~分類される。
1 種目は`~baseline環境設定$【！the baseline】を定義する／
2 種目, 3 種目は`既定の環境設定$【！the default】を定義する：
◎
For the purpose of this Sanitizer API, [HTML] constructs fall into one of four classes, where the first defines the baseline, and the first, second, plus the third define the default:
</p>
<ol>
	<li>
［
要素／属性
］のうち，~scriptを（直に）実行するもの。
言い換えれば、
無条件で~script的な［
要素／属性
］。
◎
Elements and attributes that (directly) execute script. In other words, elements and attributes that are unconditionally script-ish.
</li>
	<li>
旧来の “困難な” ［
要素／属性
］
— 例：`plaintext$tg, `xmp$tg, 特別な構文解析~規則が伴われる要素。
これらは、それ自体は危険でないが，既存の脆弱性に寄与していた。
◎
Legacy and "difficult" elements and attributes. Examples are the &lt;plaintext&gt; &lt;xmp&gt; and elements, which have special parsing rules attached to them. These are not dangerous _per se_, but they have contributed to existing vulnerability.
</li>
	<li>
［
要素／属性
］のうち，［
利用者が給する内容においてイミを成すのは、稀である
］と感じられるもの。
◎
Elements and attributes that we feel rarely make sense in user-supplied content.
</li>
	<li>
残りすべて。
◎
All the rest.
</li>
</ol>

<p>
特定的には：
◎
Specifically:
</p>
<ol>
	<li>
<p>
~script的な構成子は：
◎
Script-ish constructs:
</p>
		<ul>
			<li>
`HTMLScriptElement$I
【を実装する要素（以下同様）】
— これは、もっぱら，~scriptを実行することを目的とする。
◎
The HTMLScriptElement, which proudly executes script as its sole purpose.
</li>
			<li>
すべての`~event~handler内容~属性$
— これらも、~scriptを実行するので。
◎
All event handler attributes, since these also execute script.
</li>
			<li>
`HTMLIFrameElement$I
— これもまた、任意な~HTML内容を読込むので，~scriptである。
◎
HTMLIFrameElement, which loads arbitrary HTML content and therefor also script.
</li>
			<li>
旧来の［
`HTMLObjectElement$I ／ `HTMLEmbedElement$I
］
— これらは、~HTMLでない能動的な内容を読込む。
および，前者（ `object$tg ）の “助手” `HTMLParamElement$I も。
◎
The legacy HTMLObjectElement and HTMLEmbedElement, which load non-HTML active content. Also, &lt;object&gt;'s side-kick HTMLParamElement.
</li>
			<li>
<a href="~HTMLobs#non-conforming-features">もはや適合でない</a>［
`frame$tg,
`frameset$tg,
`applet$tg
］
— これらは、上に挙げた要素と同類な，旧式な~versionである。
◎
The no-longer conforming &lt;frame&gt;, &lt;frameset&gt;, and &lt;applet&gt; tags, which are outdated versions companions of several elements listed above.
</li>
			<li>
<p>
［
`noscript$tg,
`noframes$tg,
`noembed$tg,
`nolayer^tg†
］要素。
これらは，それ自体は紛れもなく~script的なものではないが、
上に挙げた要素と併用されるものであり，それ自体ではイミを成さない。
</p>

<p class="trans-note">【†
`nolayer^tg は、過去に標準~化されたこともない。
】</p>
◎
The &lt;noscript&gt;, &lt;noframes&gt;, &lt;noembed&gt;, and &lt;nolayer&gt; elements. These, by themselves, are arguably not script-ish, but they are companions to elements listed above, and make no sense on their own.
</li>
			<li>
`HTMLBaseElement$I
— これは、他の~URLの解釈を実質的に改変するので。
◎
Also, the HTMLBaseElement, as this effectively modifies interpretation of other URLs.
</li>
		</ul>
	</li>
	<li>
<p>
旧来の “困難な” 要素は：
◎
Legacy and "difficult" elements.
</p>
		<ul>
			<li>
<p>
次に挙げる，特別な構文解析の挙動を伴うもの。
これらは、
それ自体は危険でないが，~mXSS攻撃に寄与していた：
◎
Special parsing behaviour. This is not dangerous in its own right, but has contributed to mXSS-style attacks. This includes:
</p>
				<ul>
					<li>
`plaintext$tg
（これは、
<a href="~HTMLparsing#plaintext-state">PLAINTEXT state</a>
内で構文解析される。）
◎
&lt;plaintext&gt; (Which parses in PLAINTEXT state.)
</li>
					<li>
`title$tg, `textarea$tg
（これは、
<a href="~HTMLparsing#rcdata-state">RCDATA  state</a>
内で構文解析される。）
◎
&lt;title&gt; and &lt;textarea&gt; (Which parse in RCDATA state.)
</li>
					<li>
不適合な `xmp$tg 要素。
◎
The non-conforming [&lt;xmp&gt;](https://html.spec.whatwg.org/#xmp) element.
</li>
				</ul>
			</li>
			<li>
<p>
旧来の要素：
◎
Legacy elements:
</p>
				<ul>
					<li>
`image^tg
（これは、
<a href="~HTMLparsing#parsing-main-inbody">~body~mode</a>
内で `img$tg として構文解析される）。
◎
&lt;image&gt; ([which is parsed as &lt;img&gt;](https://html.spec.whatwg.org/#parsing-main-inbody)).
</li>
					<li>
`basefont$tg
◎
&lt;basefont&gt;
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
<p>
利用者が給する内容において有益になるとは，およそ見込まれない構成子は：
◎
Constructs unlikely to be beneficial in user-supplied content:
</p>
		<ul>
			<li>
`HTMLTemplateElement$I, `HTMLSlotElement$I
— 前者は、もっぱら~JSから利用される新たな~templateを導入する／
後者は、前者の片棒を担ぐ。
◎
The HTMLTemplateElement, which introduces a new template to be used by JavaScript, and its HTMLSlotElement accomplice.
</li>
			<li>
~frame の様な `HTMLPortalElement$I
◎
The frame-like HTMLPortalElement.
</li>
			<li>
`HTMLDataElement$I
◎
HTMLDataElement,
</li>
			<li>
（非推奨にされた） `allowpaymentrequest$a 属性。
◎
The (deprecated) allowpaymentrequest attribute.
</li>
		</ul>
	</li>
</ol>

		</section>
		<section id="baseline-elements">
<h3 title="The Baseline Element Allow List">要素~用の~baseline許容-~list</h3>

<p>
組込みの
`要素~用の~baseline許容-~list@
は、次で与えられる：
◎
The built-in baseline element allow list has the following value:
</p>

`baseline-elements^dgm

		</section>
		<section id="baseline-attributes">
<h3 title="The Baseline Attribute Allow List">属性~用の~baseline許容-~list</h3>

<p>
`属性~用の~baseline許容-~list@
は、次で与えられる：
◎
The baseline attribute allow list has the following value:
</p>

`baseline-attributes^dgm

		</section>
		<section id="default-configuration-object">
<h3 title="The Default Configuration Object">既定の環境設定~obj</h3>

<p>
組込みの
`既定の環境設定@
は、次で与えられる：
◎
The built-in default configuration has the following value:
</p>

`default-configuration-object^dgm

		</section>
	</section>
</main></div>