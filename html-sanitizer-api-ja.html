<!DOCTYPE html><html><head><meta charset="utf-8">
<title>HTML Sanitizer API（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">

<style>
.wpt-block {
	background-color: var(--note-bg-color);
}
</style>


<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		persisted_parts: Object.create(null),
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'm':
case 'mE':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2025-05-14
trans_update:2025-05-23
source_checked:240321
	page_state_key:＊
original_url:https://wicg.github.io/sanitizer-api/
abbr_url:HTMLsanitizer
spec_status:EDCG
ref_id_prefix:biblio-
ref_id_lowercase:true
	conformance:
	copyright:
site_nav:html,security
trans_1st_pub:2021-11-16


●●class_map
E:error
e:element
a:attr
et:event-type
sl:js-slot

●●tag_map
p:var
e:code
a:code
E:code
I:code
m:code
mE:code
mb:code
mbE:code
mbU:code
mbA:code
sl:span
c:code
sub:sub
i:i

●●words_table1
URLPATTERN:urlpattern-ja.html
MATHML3:https://www.w3.org/TR/MathML3/mathml.html
js_:<code class="scheme">javascript:</code> 

●●words_table

	●略語
MathML:
XLink:
XSS:
	~XSS:cross-site scripting
	~XSS:Cross-Site Scripting
mXSS:
	~mXSS:mutated Cross-Site Scripting
	~mXSS:mutated XSS

	●sanitizer
無毒化:sanitization::~
無毒化-:sanitize::~
無毒化器:sanitizer::~
	無毒化した結果:after sanitization
	`無毒化器~API^i:the Sanitizer API
	`無毒化器~API^i:the Sanitizer
	環境設定:config
	組込みの環境設定:builtins

	●処理
併合-:merge:~
再帰-:recurse:~

	〜を~~連結して:joining 〜 together
	築いておいて:built-up
	予め:pre-

	●変数
	%~target:target
	コレ:this
	%文書:document
	%html:html
	%~option群:options
	%環境設定:configuration
	%~source環境設定:configuration
	%最小限の環境設定:-
	%環境設定:-
	%~JS~navi~URLを取扱うか:handleJavascriptNavigationUrls
	%無毒化器:sanitizer
	%無毒化器~指定:sanitizerSpec
	%妥当か:valid
	%妥当か:setConfigurationResult
	%文脈~要素:contextElement
	%options:options
	%安全か:safe
	%新たな子~群:newChildren
	%素片:fragment
	%~node:node
	%現在の~node:current
	%子:child
	%子~群:-
	%要素~名:elementName
	%属性:attribute
	%属性:attr
	%属性~名:attrName
	%属性~値:-
	%局所-名:-
	%名前空間:-
	%要素:element
	%名前:name
	%~list:list
	%結果:result
	%環境設定:result
	%既定の名前空間:defaultNamespace
	%A:-
	%B:-
	%準拠~HTML:compliantHTML
	%bool
	%~commentや~data属性を許容するか:allowCommentsAndDataAttributes

	●構文

	誤って入子にされた:mis-nested

	●保安
潔白:innocent:~
	見かけは潔白な:innocent-looking
不活:inert:~
	不活そうに見える:seemingly inert
脅威:threat::~
時限爆弾:time-bomb:~
悪用-:exploite:~
gadget:
clobbering:
隠蔽-:overshadow:~

	信用-済みでない:untrusted
	許容-~list:allow-list

	●仕様
素朴:naive:~
目指す:aimする:~
網羅的:exhaustive:~
立証-:prove:~
本物の:realな:~
	それを行うようになる:will 〜 do so in a fashion
遂げる:carry outする:~
外来:foreign::~
理解:understanding:~
給-:supply:~
扱い:treatment:~
惑わす:confuseする:~
発想:inspiration:~
	情報と発想に基づく:informed and inspired
教える:teachする:~
学習-:learn:~
解決策:solution:~
想定-:suppose:~
味付け:flavour:~
機能:function:~
準拠な:compliantな:準拠する
準拠:compliant:~
精巧:elaborate:~
複雑:complicated:~
最小限の:baseline:~
警告:warning:~
形式化:formalism:~
貴重:valuable:~
責務:responsibility:~

	見込みがずっと高い:much more likely to be
	はらんで:fraught with
	まさに:just
	とは言え、:That being said
	広く:widely
	普及している:popularな
	よく知る立場にある:has a fairly good idea
	脆い:fragileな
	影響されない:unaffected
	残す:leave
	転化-:turn into
	制限-付き:limited
	追加される:gains an additional
	もっぱら:solely
	能力がある:〜-capable
	~~述べる:laid out
	下位節:subsection
	注意:note
	問わず:without regard
	現時点では:currently
	満たす:hold
	~~概ね:largely
	仕組み:mechanics
	にも定義される:mirrored
	定義される:gain
	に類する:family of 〜 -like
	今の所:right now
	それでも:should 〜 after all
	表す:denote
	分類される:falls into a handful of categories
	^en:opt-out
	^en:W3C Standard
	^en:W3C Standards Track
	^en:cure53
	^en:Internet Explorer

	●未分類
保つ:keepする:~
同等性:equality:~
template:
	~template化:templating
	~template::::テンプレート
多重定義-:overload::~
存続期間:lifetime:~
早期:early:~
最終-:final:~

	~navi用:navigating
	~call元:caller
	~code片:snippet
	詰め込む:stuff
	利用元~空間:user-space
	側:side
	文書片:fragment
	渡-:pass
	合致しないこと:mismatch
	一群の:set of
	~~上層:top-of
	し直す:re-
	時点:point
	~HTML:HTML5
	~memberであるか否か:membership
	~item:member
	~navigate用の:navigating
	~support用の:supporting
	“阻止-~list” として:helper
	-:shortcut
	-:(or set subtraction)
	少数の:one (or a few)
	少し:a little
	〜など，何らかの方法:or elsehow
	要素ごと:per-element
	~script内容:script-content
	を根とする:beginning with


●●original_id_map
	dom-sanitizer-get:sanitizer-get
	dom-sanitizer-allowelement:sanitizer-allowelement
	dom-sanitizer-removeelement:sanitizer-removeelement
	dom-sanitizer-replaceelementwithchildren:sanitizer-replaceelementwithchildren
	dom-sanitizer-allowattribute:sanitizer-allowattribute
	dom-sanitizer-removeattribute:sanitizer-removeattribute
	dom-sanitizer-setcomments:sanitizer-setcomments
	dom-sanitizer-setdataattributes:sanitizer-setdataattributes
	dom-sanitizer-removeunsafe:sanitizer-removeunsafe
	dom-element-sethtml:element-sethtml
	dom-element-sethtmlunsafe:element-sethtmlunsafe
	dom-shadowroot-sethtml:shadowroot-sethtml
	dom-shadowroot-sethtmlunsafe:shadowroot-sethtmlunsafe
	dom-document-parsehtml:document-parsehtml
	dom-document-parsehtmlunsafe:document-parsehtmlunsafe
	dom-sanitizer-sanitizer:sanitizer-constructor


●●mdn_urls

●●link_map

	●IDL

Exposed:~WEBIDLjs#Exposed
CEReactions:~HEcustom#cereactions

DOMString:~WEBIDL#idl-DOMString
	DOMString → `文字列$
TrustedHTML:~TRUSTED-TYPES#trustedhtml
I.TrustedHTML:~TRUSTED-TYPES#trustedhtml
boolean:~WEBIDL#idl-boolean
sequence:~WEBIDL#idl-sequence
undefined:~WEBIDL#idl-undefined

E.TypeError:~WEBIDL#exceptiondef-typeerror

I.HTMLTemplateElement:~HEscripting#htmltemplateelement
I.Comment:~DOM4#comment
I.Document:~DOM4#document
I.DocumentFragment:~DOM4#documentfragment
文書片:~DOM4#_concept-documentfragment
I.DocumentType:~DOM4#documenttype
I.Element:~DOM4#element
I.Node:~DOM4#node
I.ParentNode:~DOM4#parentnode
I.ShadowRoot:~DOM4#shadowroot
I.Text:~DOM4#text
I.DOMParser:~HTMLdynamic#domparser

I.SanitizerElementNamespace:#dictdef-sanitizerelementnamespace
I.SanitizerElementNamespaceWithAttributes:#dictdef-sanitizerelementnamespacewithattributes
I.SanitizerElement:#typedefdef-sanitizerelement
I.SanitizerElementWithAttributes:#typedefdef-sanitizerelementwithattributes
I.SanitizerAttributeNamespace:#dictdef-sanitizerattributenamespace
I.SanitizerAttribute:#typedefdef-sanitizerattribute
I.SanitizerConfig:#dictdef-sanitizerconfig
SetHTMLOptions
I.SanitizerPresets:#enumdef-sanitizerpresets
I.SetHTMLOptions:#dictdef-sethtmloptions
I.SetHTMLUnsafeOptions:#dictdef-sethtmlunsafeoptions
I.Sanitizer:#sanitizer

mb.attributes:#dom-sanitizerconfig-attributes
mb.comments:#dom-sanitizerconfig-comments
mb.dataAttributes:#dom-sanitizerconfig-dataattributes
mb.elements:#dom-sanitizerconfig-elements
mb.removeAttributes:#dom-sanitizerconfig-removeattributes
mb.removeElements:#dom-sanitizerconfig-removeelements
mb.replaceWithChildrenElements:#dom-sanitizerconfig-replacewithchildrenelements

mbE.name:#dom-sanitizerelementnamespace-name
mbE.namespace:#dom-sanitizerelementnamespace-namespace
mbE.attributes:#dom-sanitizerelementnamespacewithattributes-attributes
mbE.removeAttributes:#dom-sanitizerelementnamespacewithattributes-removeattributes

mbA.name:#dom-sanitizerattributenamespace-name
mbA.namespace:#dom-sanitizerattributenamespace-namespace

mE.innerHTML:~HTMLdynamic#dom-element-innerhtml
mE.setHTML:#dom-element-sethtml
mE.setHTMLUnsafe:#dom-element-sethtmlunsafe
m.setHTML:#dom-shadowroot-sethtml
m.setHTMLUnsafe:#dom-shadowroot-sethtmlunsafe
m.parseFromString:~HTMLdynamic#dom-domparser-parsefromstring
m.parseHTML:#dom-document-parsehtml
m.parseHTMLUnsafe:#dom-document-parsehtmlunsafe

m.new Sanitizer:#dom-sanitizer-sanitizer
m.get:#dom-sanitizer-get
m.allowElement:#dom-sanitizer-allowelement
m.removeElement:#dom-sanitizer-removeelement
m.replaceElementWithChildren:#dom-sanitizer-replaceelementwithchildren
m.allowAttribute:#dom-sanitizer-allowattribute
m.removeAttribute:#dom-sanitizer-removeattribute
m.setComments:#dom-sanitizer-setcomments
m.setDataAttributes:#dom-sanitizer-setdataattributes
m.removeUnsafe:#dom-sanitizer-removeunsafe

mb.sanitizer:#dom-sethtmloptions-sanitizer
mbU.sanitizer:#dom-sethtmlunsafeoptions-sanitizer

l.default:#dom-sanitizerpresets-default

	●arg
	#dom-element-sethtmlunsafe-html-options-html
	#dom-element-sethtmlunsafe-html-options-options
	#dom-element-sethtml-html-options-html
	#dom-element-sethtml-html-options-options
	#dom-shadowroot-sethtmlunsafe-html-options-html
	#dom-shadowroot-sethtmlunsafe-html-options-options
	#dom-shadowroot-sethtml-html-options-html
	#dom-shadowroot-sethtml-html-options-options
	#dom-document-parsehtmlunsafe-html-options-html
	#dom-document-parsehtmlunsafe-html-options-options
	#dom-document-parsehtml-html-options-html
	#dom-document-parsehtml-html-options-options
	#dom-sanitizer-sanitizer-configuration-configuration
	#dom-sanitizer-allowelement-element-element
	#dom-sanitizer-removeelement-element-element
	#dom-sanitizer-replaceelementwithchildren-element-element
	#dom-sanitizer-allowattribute-attribute-attribute
	#dom-sanitizer-removeattribute-attribute-attribute
	#dom-sanitizer-setcomments-allow-allow
	#dom-sanitizer-setdataattributes-allow-allow


	●code 他
a.data-:~HTMLdom#custom-data-attribute
a.slot:~HTMLdom#attr-slot
e.slot:~HEscripting#the-slot-element
e.template:~HEscripting#the-template-element


	●用語
安全:#safe-and-unsafe

環境設定:#sanitizer-configuration
~option群から無毒化器を取得する:#sanitizerconfig-get-a-sanitizer-instance-from-options
無毒化する中核~演算:#sanitize-core
要素を許容するようにする:#sanitizerconfig-allow-an-element
要素を除去するようにする:#sanitizer-remove-an-element
要素をその子~群で置換するようにする:#sanitizer-replace-an-element-with-its-children
属性を許容するようにする:#sanitizer-allow-an-attribute
属性を除去するようにする:#sanitizer-remove-an-attribute
~commentを許容するか否か設定する:#sanitizer-set-comments
~data属性を許容するか否か設定する:#sanitizer-set-data-attributes
~data属性たちを設定する:#sanitizer-set-data-attributes
安全でないものを除去するようにする:#sanitizerconfig-remove-unsafe
環境設定の欠落~memberを初期化する:#_fully-initilaize-a-configuration
環境設定を設定する:#sanitizer-set-a-configuration
属性~群を伴う無毒化器~要素を正準-化する:#canonicalize-a-sanitizer-element-with-attributes
無毒化器~要素を正準-化する:#canonicalize-a-sanitizer-element
無毒化器~属性を正準-化する:#canonicalize-a-sanitizer-attribute
環境設定から除去する:#sanitizerconfig-remove
環境設定に追加する:#sanitizerconfig-add
組込みの安全な既定の環境設定:#built-in-safe-default-configuration
組込みの安全な最小限の環境設定:#built-in-safe-baseline-configuration
組込みの~navigateされる~URLをとる属性~list:#built-in-navigating-url-attributes-list
組込みの~animateされる~URLをとる属性~list:#built-in-animating-url-attributes-list

~HTMLを設定して~filterする:#set-and-filter-html
~nodeを無毒化する:#sanitize
同等な名前:#sanitizerconfig-contains
	cG.包含-:#sanitizerconfig-contains → 同等な名前
sub.名前:#sanitizerconfig-contains
無毒化器~用の名前を正準-化する:#canonicalize-a-sanitizer-name
正準-化された名前:#_canonicalize-name
~js_~URLを包含して:#contains-a-javascript-url

	＠#set-equal
	＠#boolean-not

	●用語（外部
実装-:~WEBIDLjs#implements
新たな~obj:~WEBIDLjs#new
辞書:~WEBIDL#dfn-dictionary
文字列:~INFRA#string
	コレ:~WEBIDL#this
	~THROW:~WEBIDL#dfn-throw

	~Assert:~INFRA#assert
	~EACH:~INFRA#list-iterate
	~IN:~INFRA#list-contain
	~CONTINUE:~INFRA#iteration-continue
	~EQ:~INFRA#string-is
	~NEQ ε:~INFRA#map-exists

~list:~INFRA#list
~size:~INFRA#list-size
除去する:~INFRA#list-remove
付加する:~INFRA#list-append
真偽値:~INFRA#boolean
から開始して:~INFRA#string-starts-with
	符号単位~接頭辞:~INFRA#code-unit-prefix → から開始して
空:~INFRA#list-is-empty
	空にする:~INFRA#list-empty

有順序~集合:~INFRA#ordered-set
有順序~map:~INFRA#ordered-map
~HTML名前空間:~INFRA#html-namespace
~SVG名前空間:~INFRA#svg-namespace
~MathML名前空間:~INFRA#mathml-namespace
~XLink名前空間:~INFRA#xlink-namespace

全~内容を~nodeで置換する:~DOM4#concept-node-replace-all
~nodeを付加する:~DOM4#concept-node-append
属性~list:~DOM4#concept-element-attribute
子~群:~DOM4#concept-tree-child
局所-名:~DOM4#concept-element-local-name
名前空間:~DOM4#concept-element-namespace
doc.宣言的な~shadow根を許容するか:~DOM4#document-allow-declarative-shadow-roots
doc.内容~型:~DOM4#concept-document-content-type
attr.局所-名:~DOM4#concept-attribute-local-name
attr.名前空間:~DOM4#concept-attribute-namespace
~node文書:~DOM4#concept-node-document
~nodeを除去する:~DOM4#concept-node-remove
~shadow~host:~DOM4#element-shadow-host
el.~shadow根:~DOM4#concept-element-shadow-root
属性を除去する:~DOM4#concept-element-attributes-remove
属性~値を取得する:~DOM4#concept-element-attributes-get-value

基本~URL構文解析器:~URL1#concept-basic-url-parser
url.~scheme:~URL1#concept-url-scheme

~template内容:~HEscripting#template-contents

属する閲覧~文脈:~HTMLds#concept-document-bc
文字列から~HTMLを構文解析する:~HTMLdynamic#parse-html-from-a-string
~HTML素片の構文解析~algo:~HTMLparsing#html-fragment-parsing-algorithm

関連な大域~obj:~WAPI#concept-relevant-global
~event~handler内容~属性:~WAPI#event-handler-content-attributes

信用-済みな型に準拠な文字列を取得する:~TRUSTED-TYPES#abstract-opdef-get-trusted-type-compliant-string

	文字列:https://wicg.github.io/speech-api/#dom-speechgrammarlist-addfromstring-string-weight-string



●●ref_data


●●ref_normative

[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[TRUSTED-TYPES]
    Krzysztof Kotowicz. ＜Trusted Types＞. URL: https://w3c.github.io/trusted-types/dist/spec/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[DOMPURIFY]
    ＜DOMPurify＞. URL: https://github.com/cure53/DOMPurify
[HTMLSanitizer]
    ＜HTML Sanitizer＞. URL: https://www.bucksch.org/1/projects/mozilla/108153/
[MathML]
    Patrick D F Ion; Robert R Miner. ＜Mathematical Markup Language (MathML™) 1.01 Specification＞. 7 March 2023. REC. URL: https://www.w3.org/TR/REC-MathML/
[MXSS]
    ＜mXSS Attacks: Attacking well-secured Web-Applications by using innerHTML Mutations＞. URL: https://cure53.de/fp170.pdf
[SafeMathML]
    ＜MathML Safe List＞. URL: https://w3c.github.io/mathml-docs/mathml-safe-list
[SVG11]
    Erik Dahlström; et al. ＜Scalable Vector Graphics (SVG) 1.1 (Second Edition)＞. 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/


●●trans_metadata
<p>
~THIS_PAGEは、
~W3Cにより編集者草案（ Draft Community Group Report ）として公開された
<a href="~SPEC_URL">HTML Sanitizer API</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

課題追跡
	<a href="https://github.com/WICG/sanitizer-api/issues/">GitHub</a>

編集
	<a href="https://frederik-braun.com">Frederik Braun</a> (Mozilla) <a href="mailto:fbraun@mozilla.com">fbraun@mozilla.com</a>
	<a href="https://cure53.de">Mario Heiderich</a> (Cure53) <a href="mailto:mario@cure53.de">mario@cure53.de</a>
	<a href="https://www.google.com">Daniel Vogelheim</a> (Google LLC) <a href="mailto:vogelheim@google.com">vogelheim@google.com</a>

commit 履歴
	https://github.com/WICG/sanitizer-api/commits/main

</script>
<body>

<header>
	<hgroup>
<h1>HTML Sanitizer API</h1>
<!--
<h2>Draft Community Group Report</h2>
 -->
	</hgroup>
<details><summary>©</summary>
<small class="copyright" lang="en">
<a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2025 the Contributors to the HTML Sanitizer API Specification, published by the <a href="https://www.w3.org/community/wicg/">Web Platform Incubator Community Group</a> under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>.
A human-readable <a href="https://www.w3.org/community/about/agreements/cla-deed/">summary</a> is available.
</small>
</details>

</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は、
一群の~APIを指定する
— それは、
信用-済みでない~HTML入力を［
文書の~DOMの中への安全な挿入~用に無毒化-（ `sanitize^en ）する
］ことを開発者に許容する。
◎
This document specifies a set of APIs which allow developers to take untrusted HTML input and sanitize it for safe insertion into a document’s DOM.
</p>

	</section>
	<section id="status">
◎位置付け

<p>
この仕様は、
<a lang="en" href="https://www.w3.org/community/wicg/">Web Platform Incubator Community Group</a>
により公表されました。
それは、
`W3C Standard^en でも `W3C Standards Track^en でもありません。
<a lang="en" href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>
の下では、
ある制限-付き `opt-out^en があり，他の条件が適用されることに注意されたし。
詳しくは
<a lang="en" href="https://www.w3.org/community/">W3C Community and Business Groups</a>
について学習されたし。
◎
This specification was published by the Web Platform Incubator Community Group. It is not a W3C Standard nor is it on the W3C Standards Track. Please note that under the W3C Community Contributor License Agreement (CLA) there is a limited opt-out and other conditions apply. Learn more about W3C Community and Business Groups.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
<main>

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
~web~appは、
~client側で，~HTMLを成す文字列で作業する必要があることが多い
— たぶん［
~client側における~template化による解決策
］や［
利用者が生成した内容の具現化
］, 等々を成す一部として。
それを安全な仕方で行うのは困難である
— ［
文字列を~~連結して， `Element$I の `innerHTML$mE の中へ詰め込む
］ような素朴な~approachは、
いくつかの期待されない仕方で~JSを実行させ得るので，
~riskをはらんでいる。
◎
Web applications often need to work with strings of HTML on the client side, perhaps as part of a client-side templating solution, perhaps as part of rendering user generated content, etc. It is difficult to do so in a safe way. The naive approach of joining strings together and stuffing them into an Element’s innerHTML is fraught with risk, as it can cause JavaScript execution in a number of unexpected ways.
</p>

<p>
`DOMPURIFY$r の様な~libraryは、
文字列を挿入する前に［
それを注意深く構文解析して，~DOMを構築してから、
許容-~listを通して，その~memberたちを~filterして無毒化する
］ことにより，この問題を管理するよう試みる。
これは、
脆い~approachであることが立証された
— ~webに公開された【~libraryの】構文解析~APIは、
文字列を “本物の” ~DOM内に~HTMLとして実際に具現化するとき，常に［
適理な仕方で，~browserの挙動に対応付ける
］とは限らないので。
さらには、
~libraryが［
時間~越しに変化していく~browserの挙動
］の~~上層にあることを保つ必要もある
— それまで安全だったものは、
~platform~levelの新たな特能に基づいて時限爆弾に転化し得るので。
◎
Libraries like [DOMPURIFY] attempt to manage this problem by carefully parsing and sanitizing strings before insertion, by constructing a DOM and filtering its members through an allow-list. This has proven to be a fragile approach, as the parsing APIs exposed to the web don’t always map in reasonable ways to the browser’s behavior when actually rendering a string as HTML in the "real" DOM. Moreover, the libraries need to keep on top of browsers' changing behavior over time; things that once were safe may turn into time-bombs based on new platform-level features.
</p>

<p>
~browserは、
~codeをいつ実行しようとするかについて，よく知る立場にある。
利用元~空間の~libraryは，次により改善でき、
この文書は，まさにそれを目指す~APIを要旨する
⇒
任意な文字列から安全な方式で~HTMLを具現化するにあたって，次を可能にする
⇒
それを行う方法を~browserに教えること、
および［
~browserによる自前の［
構文解析器の実装
］が変化するに伴い［
保守される／更新される
］見込みがずっと高い仕方で，それを行うこと
◎
The browser has a fairly good idea of when it is going to execute code. We can improve upon the user-space libraries by teaching the browser how to render HTML from an arbitrary string in a safe manner, and do so in a way that is much more likely to be maintained and updated along with the browser’s own changing parser implementation. This document outlines an API which aims to do just that.
</p>

		<section id="goals">
<h3 title="Goals">1.1. 目標</h3>

<ul>
	<li>
次により，~DOMに基づく~XSS攻撃の~riskを軽減する
⇒
~HTMLを取扱うための［
利用元により制御される仕組み
］を開発者に供して、
注入の際に直な~script実行を防止する
◎
Mitigate the risk of DOM-based cross-site scripting attacks by providing developers with mechanisms for handling user-controlled HTML which prevent direct script execution upon injection.
</li>
	<li>
~HTML出力を現在の~UAの中で安全に利用できるようにする
— ~UAの［
~HTMLに対する現在の理解
］を織り込む下で。
◎
Make HTML output safe for use within the current user agent, taking into account its current understanding of HTML.
</li>
	<li>
対象になる［
要素／属性
］たちが成す既定の集合を上書きすることを，開発者に許容する。
ある種の［
要素／属性
］をそこに追加することは、
`~script~gadget攻撃＠https://github.com/google/security-research-pocs/tree/master/script-gadgets$を防止し得る。
◎
Allow developers to override the default set of elements and attributes. Adding certain elements and attributes can prevent script gadget attacks.
</li>
</ul>

		</section>
		<section id="api-summary">
<h3 title="API Summary">1.2. ~APIの要約</h3>

<p>
`無毒化器~API^i（ `Sanitizer API^en ）は、［
~HTMLを包含している文字列を~DOM~treeへ構文解析して，
結果の~treeを利用者が給した環境設定に則って~filterする
］ための機能性を提供する。
~APIは、
次に挙げる 2 × 2 種の味付けを伴う~methodとして供される：
◎
The Sanitizer API offers functionality to parse a string containing HTML into a DOM tree, and to filter the resulting tree according to a user-supplied configuration. The methods come in two by two flavours:
</p>
<ul>
	<li>
`安全@
か否か：
`安全$な~methodは、
~scriptを実行する~markupを生成しないことになる。
すなわち、
それらは，~XSSから安全になるはずである。
`安全$でない~methodは、
何であれ，想定されるものを［
構文解析する, ~filterする
］ことになる。
`§ ~securityの考慮点＠#security-considerations$
も見よ。
◎
Safe and unsafe: The "safe" methods will not generate any markup that executes script. That is, they should be safe from XSS. The "unsafe" methods will parse and filter whatever they’re supposed to. See also: § 4 Security Considerations.
</li>
	<li>
文脈：
~methodは、［
`Element$I, `ShadowRoot$I
］上に定義され，
これらの `Node$I の子~群を置換することになる
— それは、
`innerHTML$mE に~~概ね相似的である。
`Document$I 上にも静的な~methodがあり、
文書~全体に対し構文解析する
— それは、
`DOMParser$I の `parseFromString()$m に~~概ね相似的である。
◎
Context: Methods are defined on Element and ShadowRoot and will replace these Node’s children, and are largely analogous to innerHTML. There are also static methods on the Document, which parse an entire document are largely analogous to DOMParser.parseFromString().
</li>
</ul>

		</section>
	</section>
	<section id="framework">
<h2 title="Framework">2. ~framework</h2>

		<section id="sanitizer-api">
<h3 title="Sanitizer API">2.1. 無毒化器~API</h3>

<p>
`Element$I ~interfaceは、
2 つの~method
— `setHTML()$mE, `setHTMLUnsafe()$mE —
を定義する。
これらは、
どちらも［
~HTML~markupを伴う`文字列$,
省略可能な環境設定
］をとる。
◎
The Element interface defines two methods, setHTML() and setHTMLUnsafe(). Both of these take a DOMString with HTML markup, and an optional configuration.
</p>

<pre class="idl">
partial interface `Element$I {
  [`CEReactions$] `undefined$ `setHTMLUnsafe$mE((`TrustedHTML$ or `DOMString$) %html, optional `SetHTMLUnsafeOptions$I %options = {});
  [`CEReactions$] `undefined$ `setHTML$mE(`DOMString$ %html, optional `SetHTMLOptions$I %options = {});
};
</pre>

<div class="algo">
<p>
`Element$I の
`setHTMLUnsafe(html, options)@mE
~method手続きは：
◎
Element’s setHTMLUnsafe(html, options) method steps are:
</p>
<ol>
	<li>
%準拠~HTML ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
%html,
`Element setHTMLUnsafe^l,
`script^l
◎
Let compliantHTML be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this’s relevant global object, html, "Element setHTMLUnsafe", and "script".
</li>
	<li>
%~target ~LET コレ
◎
↓</li>
	<li>
~IF［
コレは `HTMLTemplateElement$I 要素である
］
⇒
%~target ~SET コレの`~template内容$
◎
Let target be this’s template contents if this is a template element; otherwise this.
</li>
	<li>
`~HTMLを設定して~filterする$( ↓ )
⇒＃
%~target,
コレ,
%準拠~HTML,
%options,
~F
◎
Set and filter HTML given target, this, compliantHTML, options, and false.
</li>
</ol>
</div>

<div class="algo">
<p>
`Element$I の
`setHTML(html, options)@mE
~method手続きは：
◎
Element’s setHTML(html, options) method steps are:
</p>
<ol>
	<li>
%~target ~LET コレ
◎
↓</li>
	<li>
~IF［
コレは `HTMLTemplateElement$I 要素である
］
⇒
%~target ~SET コレの`~template内容$
◎
Let target be this’s template contents if this is a template; otherwise this.
</li>
	<li>
`~HTMLを設定して~filterする$( ↓ )
⇒＃
%~target,
コレ,
%html,
%options,
~T
◎
Set and filter HTML given target, this, html, options, and true.
</li>
</ol>
</div>

<pre class="idl">
partial interface `ShadowRoot$I {
  [`CEReactions$] `undefined$ `setHTMLUnsafe$m((`TrustedHTML$ or `DOMString$) %html, optional `SetHTMLUnsafeOptions$I %options = {});
  [`CEReactions$] `undefined$ `setHTML$m(`DOMString$ %html, optional `SetHTMLOptions$I %options = {});
};
</pre>

<p>
`Element$I 上に定義された~methodは、
`ShadowRoot$I 上にも定義される：
◎
These methods are mirrored on the ShadowRoot:
</p>

<div class="algo">
<p>
`ShadowRoot$I の
`setHTMLUnsafe(html, options)@m
~method手続きは：
◎
ShadowRoot’s setHTMLUnsafe(html, options) method steps are:
</p>
<ol>
	<li>
%準拠~HTML ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
%html,
`ShadowRoot setHTMLUnsafe^l,
`script^l
◎
Let compliantHTML be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this’s relevant global object, html, "ShadowRoot setHTMLUnsafe", and "script".
</li>
	<li>
`~HTMLを設定して~filterする$( ↓ )
⇒＃
コレ,
コレの`~shadow~host$,
%準拠~HTML,
%options,
~F
◎
Set and filter HTML using this, this’s shadow host (as context element), compliantHTML, options, and false.
</li>
</ol>
</div>

<div class="algo">
<p>
`ShadowRoot$I の
`setHTML(html, options)@m
~method手続きは：
◎
ShadowRoot’s setHTML(html, options) method steps are:
</p>
<ol>
	<li>
`~HTMLを設定して~filterする$( ↓ )
⇒＃
コレ,
コレ,
%html,
%options,
~T
◎
Set and filter HTML using this (as target), this (as context element), html, options, and true.
</li>
</ol>
</div>

<p>
`Document$I ~interfaceには、
2 つの新たな静的~methodが定義される
— それは、
所与の文字列を `Document$I 全体を成すものとして構文解析する：
◎
The Document interface gains two new methods which parse an entire Document:
</p>

<pre class="idl">
partial interface `Document$I {
  static `Document$I `parseHTMLUnsafe$m((`TrustedHTML$ or `DOMString$) %html, optional `SetHTMLUnsafeOptions$I %options = {});
  static `Document$I `parseHTML$m(`DOMString$ %html, optional `SetHTMLOptions$I %options = {});
};
</pre>

<div class="algo">
<p>
`parseHTMLUnsafe(html, options)@m
~method手続きは：
◎
The parseHTMLUnsafe(html, options) method steps are:
</p>
<ol>
	<li>
%準拠~HTML ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
%html,
`Document parseHTMLUnsafe^l,
`script^l
◎
Let compliantHTML be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this’s relevant global object, html, "Document parseHTMLUnsafe", and "script".
</li>
	<li>
<p>
%文書 ~LET 新たな `Document$I
— その
⇒＃
`内容~型$doc ~SET `text/html^l
◎
Let document be a new Document, whose content type is "text/html".
</p>

<p class="note">注記：
%文書 が`属する閲覧~文脈$は ~NULL なので、
~scriptingは不能化される。
◎
Note: Since document does not have a browsing context, scripting is disabled.
</p>
	</li>
	<li>
%文書 の`宣言的な~shadow根を許容するか$doc ~SET ~T
◎
Set document’s allow declarative shadow roots to true.
</li>
	<li>
`文字列から~HTMLを構文解析する$( %文書, %準拠~HTML )
◎
Parse HTML from a string given document and compliantHTML.
</li>
	<li>
%無毒化器 ~LET `~option群から無毒化器を取得する$( %options, ~F )
◎
Let sanitizer be the result of calling get a sanitizer instance from options with options and false.
</li>
	<li>
`~nodeを無毒化する$( %文書, %無毒化器, ~F )
◎
Call sanitize on document with sanitizer and false.
</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<div class="algo">
<p>
`parseHTML(html, options)@m
~method手続きは：
◎
The parseHTML(html, options) method steps are:
</p>
<ol>
	<li>
<p>
%文書 ~LET 新たな `Document$I
— その
⇒＃
`内容~型$doc ~SET `text/html^l
◎
Let document be a new Document, whose content type is "text/html".
</p>

<p class="note">注記：
%文書 が`属する閲覧~文脈$は ~NULL なので、
~scriptingは不能化される。
◎
Note: Since document does not have a browsing context, scripting is disabled.
</p>
	</li>
	<li>
%文書 の`宣言的な~shadow根を許容するか$doc ~SET ~T
◎
Set document’s allow declarative shadow roots to true.
</li>
	<li>
`文字列から~HTMLを構文解析する$( %文書, %html )
◎
Parse HTML from a string given document and html.
</li>
	<li>
%無毒化器 ~LET `~option群から無毒化器を取得する$( %options, ~T )
◎
Let sanitizer be the result of calling get a sanitizer instance from options with options and true.
</li>
	<li>
`~nodeを無毒化する$( %文書, %無毒化器, ~T )
◎
Call sanitize on document with sanitizer and true.
</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

		</section>
		<section id="configobject">
<h3 title="SetHTML options and the configuration object.">2.2. `SetHTML^I ~option群と環境設定~obj</h3>

<p>
`setHTML()$mE に類する~methodは、
いずれも，ある~option群を与える辞書を受容する。
今の所は、
これらの辞書に定義される~memberは 1 つしかない：
◎
The family of setHTML()-like methods all accept an options dictionary. Right now, only one member of this dictionary is defined:
</p>

<pre class="idl">
enum `SanitizerPresets@I{
   `default@l
};
dictionary `SetHTMLOptions@I {
  (`Sanitizer$I or `SanitizerConfig$I or `SanitizerPresets$I) `sanitizer@mb = "default";
};
dictionary `SetHTMLUnsafeOptions@I {
  (`Sanitizer$I or `SanitizerConfig$I or `SanitizerPresets$I) `sanitizer@mbU = {};
};
</pre>

<p>
`Sanitizer$I 環境設定~obj
【この文脈においては、`各種~method＠#sanitizer-api$がとる %options 引数】
は、
~filter環境設定を~capsule化する。
同じ環境設定を［
`安全$な~method／
`安全$でない~method【名前に `Unsafe^en を伴う~method】
］どちらにも利用できる。
`安全$な~methodは、
渡された環境設定
— 渡されなかったときは，既定の環境設定 —
に対し，暗黙的に`安全でないものを除去するようにする$
【！ `removeUnsafe()$m 演算を遂行する】。
環境設定~objの意図は、
~pageの存続期間における早期に少数の環境設定を築いておいて，
必要に応じて利用できるようにすることである。
これは、
それらの環境設定を予め処理することを実装に許容する。
◎
The Sanitizer configuration object encapsulates a filter configuration. The same configuration can be used with both "safe" or "unsafe" methods, where the "safe" methods perform an implicit removeUnsafe operation on the passed in configuration and have a default configuration when none is passed. The intent is that one (or a few) configurations will be built-up early on in a page’s lifetime, and can then be used whenever needed. This allows implementations to pre-process configurations.
</p>

<p>
環境設定~obj
【この文脈においては、 `Sanitizer$I ~objの`環境設定$】は、
それを与える辞書を返すよう~queryできる。
それはまた、
直に改変できる。
◎
The configuration object can be queried to return a configuration dictionary. It can also be modified directly.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `Sanitizer@I {
  `constructor＠#dom-sanitizer-sanitizer$(optional (`SanitizerConfig$I or `SanitizerPresets$I) %configuration = "default");

  /* <span class="comment">
環境設定を~queryする
◎
Query configuration:
</span> */
  `SanitizerConfig$I `get$m();

  /* <span class="comment">
この無毒化器の`環境設定$を成す各種［
~list／~field
］（たち）を改変する：
◎
Modify a Sanitizer’s lists and fields:
</span> */
  `undefined$ `allowElement$m(`SanitizerElementWithAttributes$I %element);
  `undefined$ `removeElement$m(`SanitizerElement$I %element);
  `undefined$ `replaceElementWithChildren$m(`SanitizerElement$I %element);
  `undefined$ `allowAttribute$m(`SanitizerAttribute$I %attribute);
  `undefined$ `removeAttribute$m(`SanitizerAttribute$I %attribute);
  `undefined$ `setComments$m(`boolean$ %allow);
  `undefined$ `setDataAttributes$m(`boolean$ %allow);

  /* <span class="comment">
~scriptを実行する~markupを除去するようにする
— これは、
この無毒化器の`環境設定$を成す複数の~listを改変し得る：
◎
Remove markup that executes script. May modify multiple lists:
</span> */
  `undefined$ `removeUnsafe$m();
};
</pre>

<p>
各 `Sanitizer$I ~objには、
その
`環境設定@
と称される，ある `SanitizerConfig$I が結付けられる。
◎
A Sanitizer has an associated configuration, a SanitizerConfig.
</p>

<div class="algo">
<p>
`new Sanitizer(configuration)@m
構築子~手続きは：
◎
The constructor(configuration) method steps are:
</p>
<ol>
	<li>
<p>
~IF［
%configuration は`文字列$である
］：
◎
If configuration is a SanitizerPresets string, then:
</p>
		<ol>
			<li>
~Assert：
%configuration ~EQ `default$l
◎
Assert: configuration is default.
</li>
			<li>
%configuration ~SET `組込みの安全な既定の環境設定$
◎
Set configuration to the built-in safe default configuration.
</li>
		</ol>
	</li>
	<li>
コレの`環境設定$ ~SET 空な `SanitizerConfig$I
【この段は、この訳による補完。】
</li>
	<li>
%妥当か ~LET `環境設定を設定する$( コレ, %configuration, ~T )
◎
Let valid be the return value of set a configuration with configuration and true on this.
</li>
	<li>
~IF［
%妥当か ~EQ ~F
］
⇒
~THROW `TypeError$E
◎
If valid is false, then throw a TypeError.
</li>
</ol>
</div>

<div class="algo">
<p>
`get()@m
~method手続きは
⇒
~RET コレの`環境設定$
◎
The get() method steps are to return the value of this’s configuration.
</p>
</div>

<div class="algo">
`allowElement(element)@m
~method手続きは
⇒
`要素を許容するようにする$( コレの`環境設定$, %element )
◎
The allowElement(element) method steps are to allow an element with element and this’s configuration.
</div>

<div class="algo">
`removeElement(element)@m
~method手続きは
⇒
`要素を除去するようにする$( コレの`環境設定$, %element )
◎
The removeElement(element) method steps are to remove an element with element and this’s configuration.
</div>

<div class="algo">
`replaceElementWithChildren(element)@m
~method手続きは
⇒
`要素をその子~群で置換するようにする$( コレの`環境設定$, %element )
◎
The replaceElementWithChildren(element) method steps are to replace an element with its children with element and this’s configuration.
</div>

<div class="algo">
`allowAttribute(attribute)@m
~method手続きは
⇒
`属性を許容するようにする$( コレの`環境設定$, %attribute )
◎
The allowAttribute(attribute) method steps are to allow an attribute with attribute and this’s configuration.
</div>

<div class="algo">
`removeAttribute(attribute)@m
~method手続きは
⇒
`属性を除去するようにする$( コレの`環境設定$, %attribute )
◎
The removeAttribute(attribute) method steps are to remove an attribute with attribute and this’s configuration.
</div>

<div class="algo">
`setComments(allow)@m
~method手続きは
⇒
`~commentを許容するか否か設定する$( コレの`環境設定$, %allow )
◎
The setComments(allow) method steps to set comments with allow and this’s configuration.
</div>

<div class="algo">
`setDataAttributes(allow)@m
~method手続きは
⇒
`~data属性を許容するか否か設定する$( コレの`環境設定$, %allow )
◎
The setDataAttributes(allow) method steps are to set data attributes with allow and this’s configuration.
</div>

<div class="algo">
`removeUnsafe()@m
~method手続きは
⇒
`安全でないものを除去するようにする$( コレの`環境設定$ )
◎
The removeUnsafe() method steps are to update this’s configuration with the result of calling remove unsafe on this’s configuration.
</div>

		</section>
		<section id="config">
<h3 title="The Configuration Dictionary">2.3. 環境設定~辞書</h3>

<pre class="idl">
dictionary `SanitizerElementNamespace@I {
  required `DOMString$ `name@mbE;
  `DOMString$? _`namespace@mbE = "http://www.w3.org/1999/xhtml";
};

/* <span class="comment">
"`elements$mb" により利用される
◎
Used by "elements"
</span> */
dictionary `SanitizerElementNamespaceWithAttributes@I : `SanitizerElementNamespace$I {
  `sequence$&lt;`SanitizerAttribute$I&gt; `attributes@mbE;
  `sequence$&lt;`SanitizerAttribute$I&gt; `removeAttributes@mbE;
};

typedef (`DOMString$ or `SanitizerElementNamespace$I) `SanitizerElement@I;
typedef (`DOMString$ or `SanitizerElementNamespaceWithAttributes$I) `SanitizerElementWithAttributes@I;

dictionary `SanitizerAttributeNamespace@I {
  required `DOMString$ `name@mbA;
  `DOMString$? _`namespace@mbA = null;
};
typedef (`DOMString$ or `SanitizerAttributeNamespace$I) `SanitizerAttribute@I;

dictionary `SanitizerConfig@I {
  `sequence$&lt;`SanitizerElementWithAttributes$I&gt; `elements@mb;
  `sequence$&lt;`SanitizerElement$I&gt; `removeElements@mb;
  `sequence$&lt;`SanitizerElement$I&gt; `replaceWithChildrenElements@mb;

  `sequence$&lt;`SanitizerAttribute$I&gt; `attributes@mb;
  `sequence$&lt;`SanitizerAttribute$I&gt; `removeAttributes@mb;

  `boolean$ `comments@mb;
  `boolean$ `dataAttributes@mb;
};
</pre>

		</section>
	</section>
	<section id="algorithms">
<h2 title="Algorithms">3. ~algo</h2>

<div class="algo">
<p>
`~HTMLを設定して~filterする@
~algoは、
所与の
⇒＃
［ `Element$I ／ `DocumentFragment$I ］ %~target,
`Element$I %文脈~要素,
`文字列$ %html,
`辞書$ %~option群,
`真偽値$ %安全か
◎終
に対し：
◎
To set and filter HTML, given an Element or DocumentFragment target, an Element contextElement, a string html, and a dictionary options, and a boolean safe:
</p>
<ol>
	<li>
~IF［
%安全か ~EQ ~T
］~AND［
%文脈~要素 の`局所-名$ ~EQ `script^l
］~AND［
%文脈~要素 の`名前空間$ ~IN { `~HTML名前空間$, `~SVG名前空間$ }
］
⇒
~RET
◎
If safe and contextElement’s local name is "script" and contextElement’s namespace is the HTML namespace or the SVG namespace, then return.
</li>
	<li>
%無毒化器 ~LET `~option群から無毒化器を取得する$( %~option群, %安全か )
◎
Let sanitizer be the result of calling get a sanitizer instance from options with options and safe.
</li>
	<li>
%新たな子~群 ~LET `~HTML素片の構文解析~algo$( %文脈~要素, %html, ~T )
◎
Let newChildren be the result of the HTML fragment parsing algorithm given contextElement, html, and true.
</li>
	<li>
%素片 ~LET 新たな `DocumentFragment$I
— その
⇒＃
`~node文書$ ~SET %文脈~要素 の`~node文書$
◎
Let fragment be a new DocumentFragment whose node document is contextElement’s node document.
</li>
	<li>
%新たな子~群 を成す
~EACH( %~node )
に対し
⇒
%素片 【の`子~群$】に %~node を`付加する$
◎
For each node in newChildren, append node to fragment.
</li>
	<li>
`~nodeを無毒化する$( %素片, %無毒化器, %安全か )
◎
Run sanitize on fragment using sanitizer and safe.
</li>
	<li>
%~target の`全~内容を~nodeで置換する$( %素片 )
◎
Replace all with fragment within target.
</li>
</ol>
</div>

<div class="algo">
<p>
`~option群から無毒化器を取得する@
~algoは、
所与の
( %~option群, `真偽値$ %安全か )
に対し：
◎
To get a sanitizer instance from options from a dictionary options with a boolean safe, do:
</p>
<ol>
	<li>
<p>
~Assert：
%~option群 は次に挙げるいずれかである
⇒＃
`SetHTMLOptions$I ／
`SetHTMLUnsafeOptions$I
</p>

<p class="note">注記：
これらは、
既定【各自の `sanitizer^mb ~memberの既定~値】においてのみ相違する。
</p>
◎
Note: This algorithm works for both SetHTMLOptions and SetHTMLUnsafeOptions. They only differ in the defaults.
</li>
	<li>
%無毒化器~指定 ~LET %~option群[ "`sanitizer^mb" ]
◎
Let sanitizerSpec be "default".（不要）
◎
If options["sanitizer"] exists, then:（不要）
• Set sanitizerSpec to options["sanitizer"]
</li>
	<li>
~IF［
%無毒化器~指定 は `Sanitizer$I を`実装-$する
］
⇒
~RET %無毒化器~指定
◎
↓</li>
	<li>
~IF［
%無毒化器~指定 ~EQ `default$l
］
⇒
%無毒化器~指定 ~SET `組込みの安全な既定の環境設定$
◎
Assert: sanitizerSpec is either a Sanitizer instance, a string which is a SanitizerPresets member, or a dictionary.
◎
If sanitizerSpec is a string:
• Assert: sanitizerSpec is "default"
• Set sanitizerSpec to the built-in safe default configuration.
</li>
	<li>
~Assert：
%無毒化器~指定 は`辞書$である。
◎
Assert: sanitizerSpec is either a Sanitizer instance, or a dictionary.
◎
If sanitizerSpec is a dictionary:
</li>
	<li>
%無毒化器 ~LET `新たな~obj$( `Sanitizer$I )
◎
• Let sanitizer be a new Sanitizer instance.
</li>
	<li>
%妥当か ~LET `環境設定を設定する$( %無毒化器, %無毒化器~指定, ~IS［ %安全か ~EQ ~F ］ )
◎
• Let setConfigurationResult be the result of set a configuration with sanitizerSpec and not safe on sanitizer.
</li>
	<li>
~IF［
%妥当か ~EQ ~F
］
⇒
~THROW `TypeError$E
◎
• If setConfigurationResult is false, throw a TypeError.
</li>
	<li>
~RET %無毒化器
◎
• Set sanitizerSpec to sanitizer.
◎
Assert: sanitizerSpec is a Sanitizer instance.
◎
Return sanitizerSpec.
</li>
</ol>
</div>

		<section id="sanitization">
<h3 title="Sanitization Algorithms">3.1. 無毒化~algo</h3>

<div class="algo">
<p>
`~nodeを無毒化する@
~algoは、
所与の
( `ParentNode$I %~node, `Sanitizer$I %無毒化器, `真偽値$ %安全か )
に対し：
</p>
<ol>
	<li>
%環境設定 ~LET %無毒化器 の`環境設定$の複製
</li>
	<li>
`環境設定の欠落~memberを初期化する$( %環境設定, ~F )†
</li>
	<li>
~IF［
%安全か ~EQ ~T
］
⇒
`安全でないものを除去するようにする$( %環境設定 )
</li>
	<li>
`無毒化する中核~演算$( %~node, %環境設定, %安全か )
</li>
</ol>

<p class="trans-note">【†
欠落~memberを初期化する段は、
この訳による追加。
最後の段で呼出される`無毒化する中核~演算$は、
%環境設定 に欠落~memberがある場合をきちんと取扱っていないので。
それに伴い，常に複製するよう改めてもいる
— %無毒化器 の`環境設定$を公開する `get()$m の挙動を改めないよう。
（ 2 個目の引数 ~F は、
~~形式上のものであり，結果には影響しない
— %環境設定 の真偽値~member（ `comments$mb, `dataAttributes$mb ）は、
%無毒化器 の作成-時に初期化されるので）。
】</p>
◎
For the main sanitize operation, using a ParentNode node, a Sanitizer sanitizer, and a boolean safe, run these steps:
• Let configuration be the value of sanitizer’s configuration.
• If safe is true, then set configuration to the result of calling remove unsafe on configuration.
• Call sanitize core on node, configuration, and with handleJavascriptNavigationUrls set to safe.
</div>

<div class="algo">
<div>
<p>
`無毒化する中核~演算@
は、
所与の
( `ParentNode$I %~node, `SanitizerConfig$I %環境設定, `真偽値$ %~JS~navi~URLを取扱うか )
に対し：
</p>

<p class="note">注記：
これは、
%~node を根とする~DOM~tree内を %~node から反復して，
一部の特別な事例（例：`~template内容$）を取扱うために再帰し得る。
</p>
◎
The sanitize core operation, using a ParentNode node, a SanitizerConfig configuration, and a boolean handleJavascriptNavigationUrls, iterates over the DOM tree beginning with node, and may recurse to handle some special cases (e.g. template contents). It consistes of these steps:
</div>
<ol>
	<li>
<p>
%~node の`子~群$を成す
~EACH( %子 )
に対し：
◎
For each child of node’s children:
</p>
		<ol>
			<li>
<p>
~Assert：
%子 は次に挙げるいずれかを`実装-$する
⇒
`Text$I ／ `Comment$I ／ `Element$I ／ `DocumentType$I
◎
Assert: child implements Text, Comment, Element, or DocumentType.
</p>

<p class="note">注記：
この~algoに渡される %~node は、
現時点では，~HTML構文解析器の出力に限られ、
この表明は，それに対しては満たされるべきである。
`DocumentType$I は、［
`parseHTML()$m, `parseHTMLUnsafe()$m
］用に限り，生じるべきである。
この~algoが将来に異なる文脈にて利用されるようになった場合、
この前提は，精査し直す必要がある。
◎
Note: Currently, this algorithm is only called on output of the HTML parser for which this assertion should hold. DocumentType should only occur for parseHTML and parseHTMLUnsafe. If in the future this algorithm will be used in different contexts, this assumption needs to be re-examined.
</p>
			</li>
			<li>
~IF［
%子 は `DocumentType$I を`実装-$する
］
⇒
~CONTINUE
◎
If child implements DocumentType, then continue.
</li>
			<li>
~IF［
%子 は `Text$I を`実装-$する
］
⇒
~CONTINUE
◎
If child implements Text, then continue.
</li>
			<li>
<p>
~IF［
%子 は `Comment$I を`実装-$する
］：
</p>
				<ol>
					<li>
~IF［
%環境設定[ "`comments$mb" ] ~NEQ ~T
］
⇒
`~nodeを除去する$( %子 )
</li>
					<li>
~CONTINUE
</li>
				</ol>
◎
If child implements Comment:
• If configuration["comments"] is not true, then remove child.
◎
Otherwise:
</li>
			<li>
%要素~名 ~LET «[ "`name$mbE" → %子 の`局所-名$, "`namespace$mbE" → %子 の`名前空間$ ]»
【！新たな `SanitizerElementNamespace$I】
◎
Let elementName be a SanitizerElementNamespace with child’s local name and namespace.
</li>
			<li>
<p>
~IF［
%要素~名 ~IN`名前$sub %環境設定[ "`replaceWithChildrenElements$mb" ]
］：
◎
If configuration["replaceWithChildrenElements"] contains elementName:
</p>
				<ol>
					<li>
`無毒化する中核~演算$( %子, %環境設定, %~JS~navi~URLを取扱うか )
◎
Call sanitize core on child with configuration and handleJavascriptNavigationUrls.
</li>
					<li>
<p>
%子 の`全~内容を~nodeで置換する$( %子 の`子~群$ )
</p>

<p class="trans-note">【
引数の型が合致していない。
厳密には、
%子 の子~群を ある文書片で包装してから渡す必要があろう。
】</p>
◎
Call replace all with child’s children within child.
</li>
					<li>
~CONTINUE
◎
Continue.
</li>
				</ol>
			</li>
			<li>
<div>
<p>
~IF［
~OR↓
］…
</p>
				<ul>
					<li>
%要素~名 ~IN`名前$sub %環境設定[ "`removeElements$mb" ]
</li>
					<li>
［
%環境設定[ "`elements$mb" ] は`空$でない
］~AND［
%要素~名 ~NIN`名前$sub %環境設定[ "`elements$mb" ]
］
</li>
				</ul>
<p>
…ならば：
</p>
◎
If configuration["removeElements"] contains elementName, or if configuration["elements"] is not empty and does not contain elementName:
</div>
				<ol>
					<li>
`~nodeを除去する$( %子 )
◎
Remove child.
</li>
					<li>
~CONTINUE
◎
Continue.
</li>
				</ol>
			</li>
			<li>
~IF［
%要素~名 ~EQ`名前$sub «[ `name^l → `template^l, `namespace^l → `~HTML名前空間$ ]»
］
⇒
`無毒化する中核~演算$( %子 の`~template内容$, %環境設定, %~JS~navi~URLを取扱うか )
◎
If elementName equals «[ "name" → "template", "namespace" → HTML namespace ]»
• Then call sanitize core on child’s template contents with configuration and handleJavascriptNavigationUrls.
</li>
			<li>
~IF［
%子 は`~shadow~host$である
］
⇒
`無毒化する中核~演算$( %子 の`~shadow根$el, %環境設定, %~JS~navi~URLを取扱うか )
◎
If child is a shadow host, then call sanitize core on child’s shadow root with configuration and handleJavascriptNavigationUrls.
</li>
			<li>
<p>
%子 の`属性~list$を成す
~EACH( %属性 )
に対し：
◎
For each attribute in child’s attribute list:
</p>
				<ol>
					<li>
%局所-名 ~LET %属性 の`局所-名$attr
◎
↓</li>
					<li>
%名前空間 ~LET %属性 の`名前空間$attr
◎
↓</li>
					<li>
%属性~値 ~LET %子 の`属性~値を取得する$( %局所-名, %名前空間 )
◎
↓</li>
					<li>
%属性~名 ~LET «[ "`name$mbA" → %局所-名, "`namespace$mbA" → %名前空間 ]»
【！新たな `SanitizerAttributeNamespace$I】
◎
Let attrName be a SanitizerAttributeNamespace with attribute’s local name and namespace.
</li>
					<li>
<p>
~IF［
~OR↓
］…
</p>
						<ul>
							<li>
%属性~名 ~IN`名前$sub %環境設定[ "`removeAttributes$mb" ]
◎
If configuration["removeAttributes"] contains attrName, then Remove attribute from child.
</li>
							<li>
%属性~名 ~IN`名前$sub %環境設定[ "`elements$mb" ][ "`removeAttributes$mbE" ]
◎
If configuration["elements"]["removeAttributes"] contains attrName, then remove attribute from child.
</li>
							<li>
<p>
~NOT ~OR↓
◎
If all of the following are false, then remove attribute from child.
</p>
								<ul>
									<li>
%属性~名 ~IN`名前$sub %環境設定[ "`attributes$mb" ]
【！exists and】
◎
configuration["attributes"] exists and contains attrName
</li>
									<li>
%属性~名 ~IN`名前$sub %環境設定[ "`elements$mb" ][ "`attributes$mbE" ]
◎
configuration["elements"]["attributes"] contains attrName
</li>
									<li>
<p>
~AND↓：
</p>
										<ul>
											<li>
%局所-名 は `data-^l `から開始して$いる
</li>
											<li>
%名前空間 ~EQ ~NULL
											<li>
%環境設定[ "`dataAttributes$mb" ] ~EQ ~T
</li>
										</ul>
◎
"data-" is a code unit prefix of local name and namespace is null and configuration["dataAttributes"] is true
</li>
								</ul>
							</li>
							<li>
<p>
［
%~JS~navi~URLを取扱うか ~EQ ~T
］~AND［
~OR↓
］：
◎
If handleJavascriptNavigationUrls:
</p>
								<ul>
									<li>
<p>
~AND↓：
</p>
										<ul>
											<li>
<p>
`組込みの~navigateされる~URLをとる属性~list$を成す ある %~item は ~AND↓ を満たす：
</p>
												<ul>
													<li>
%~item[ 0 ] ~EQ`名前$sub %要素~名
</li>
													<li>
%~item[ 1 ] ~EQ`名前$sub %属性~名
</li>
												</ul>
											</li>
											<li>
%属性~値 は`~js_~URLを包含して$いる
</li>
										</ul>
◎
If «[elementName, attrName]» matches an entry in the built-in navigating URL attributes list, and if attribute contains a javascript: URL, then remove attribute from child.
</li>
									<li>
<p>
~AND↓：
</p>
										<ul>
											<li>
%子 の`名前空間$ ~EQ `~MathML名前空間$
</li>
											<li>
%局所-名 ~EQ `href^l
</li>
											<li>
%名前空間 ~IN { ~NULL, `~XLink名前空間$ }
</li>
											<li>
%属性~値 は`~js_~URLを包含して$いる
</li>
										</ul>
◎
If child’s namespace is the MathML Namespace and attr’s local name is "href" and attr’s namespace is null or the XLink namespace and attr contains a javascript: URL, then remove attr.
</li>
									<li>
<p>
~AND↓：
</p>
										<ul>
											<li>
<p>
`組込みの~animateされる~URLをとる属性~list$を成す ある %~item は ~AND↓ を満たす：
</p>
												<ul>
													<li>
%~item[ 0 ] ~EQ`名前$sub %要素~名
</li>
													<li>
%~item[ 1 ] ~EQ`名前$sub %属性~名
</li>
												</ul>
											</li>
											<li>
%属性~値 ~IN { `href^l, `xlink:href^l }
</li>
										</ul>
◎
If the built-in animating URL attributes list contains «[elementName, attrName]» and attr’s value is "href" or "xlink:href", then remove attr.
</li>
								</ul>
							</li>
						</ul>
<p>
…ならば
⇒
`属性を除去する$( %属性 )
</p>
					</li>
				</ol>
			</li>
			<li>
`無毒化する中核~演算$( %子, %環境設定, %~JS~navi~URLを取扱うか )
◎
Call sanitize core on child with configuration and handleJavascriptNavigationUrls.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="note">
<p>
注記：
現在の~browserは、
~js_~URLを~navigateするときに限り~supportする。
~js_~URLへの~naviは，
~navi自体は~XSSの脅威ではないので取扱われるが、
【~js_~URLは？】一般には~naviではない。
◎
Note: Current browsers support javascript: URLs only when navigating. Since navigation itself is not an XSS threat we handle navigation to javascript: URLs, but not navigations in general.
</p>

<p>
宣言的な~naviは、
次に挙げるものに分類される：
◎
Declarative navigation falls into a handful of categories:
</p>
<ul>
	<li>
~anchor要素
（`~HTML名前空間$／`~SVG名前空間$に属する `a^e 要素）。
◎
Anchor elements. (&lt;a&gt; in HTML and SVG namespaces)
</li>
	<li>
~form用の要素のうち，~form動作を成す一部として~naviを誘発するもの。
◎
Form elements that trigger navigation as part of the form action.
</li>
	<li>
~MathML名前空間に属する要素
— これらすべては、
`~anchorとして動作する＠~MATHML3#chapter2_fund.globatt$ことが許容される。
`MathML$r
◎
[MathML] allows any element to act as an anchor.
</li>
	<li>
各種~SVG~animation要素。
`SVG11$r
◎
[SVG11] animation.
</li>
</ul>

<p>
これらのうち：
◎
↓</p>
<ul>
	<li>
最初に挙げた 2 つは、
`組込みの~navigateされる~URLをとる属性~list$が受持つ。
◎
The first two are covered by the built-in navigating URL attributes list.
</li>
	<li>
~MathMLの事例は、
別々な規則が受持つ
— この仕様には、
“名前空間ごとに大域的” な規則を受持つ形式化は無いので。
◎
The MathML case is covered by a seperate rule, because there is no formalism in this spec to cover a "per-namespace global" rule.
</li>
	<li>
~SVG~animationの事例は、
`組込みの~animateされる~URLをとる属性~list$が受持つ。
が、
~SVG~animation要素の解釈は~animation~targetに依存し，
無毒化の間は何が最終-~targetになるか知り得ないので、
`~nodeを無毒化する$~algoは，
`href^a 属性の~animationを阻止する。
◎
The SVG animation case is covered by the built-in animating URL attributes list. But since the interpretation of SVG animation elements depends on the animation target, and since during sanitization we cannot know what the final target will be, the sanitize algorithm blocks any animation of href attributes.
</li>
</ul>
</div>

<div class="algo">
<p>
所与の %属性~値【！%属性】 が
`~js_~URLを包含して@
いるか否か決定する~algoは：
◎
To determine whether an attribute contains a javascript: URL:
</p>
<ol>
	<li>
%~URL ~LET `基本~URL構文解析器$( %属性~値 )
◎
Let url be the result of running the basic URL parser on attribute’s value.
</li>
	<li>
~RET ~IS［
%~URL ~NEQ `失敗^i
］~AND［
%~URL の`~scheme$url ~EQ `javascript^l
］
◎
If url is failure, then return false.
◎
Return whether url’s scheme is "javascript".
</li>
</ol>
</div>

		</section>
		<section id="configuration-processing">
<h3 title="Configuration Processing">3.2. 環境設定の処理-法</h3>

<div class="algo">
<p>
`要素を許容するようにする@
~algoは、
所与の
( `SanitizerConfig$I %環境設定, %要素 )
に対し：
◎
To allow an element element with a SanitizerConfig configuration, do:
</p>
<ol>
	<li>
%要素 ~SET `属性~群を伴う無毒化器~要素を正準-化する$( %要素 )
◎
Set element to the result of canonicalize a sanitizer element with attributes with element.
</li>
	<li>
`環境設定から除去する$( %環境設定, "`elements$mb", %要素 )
◎
Remove element from configuration["elements"].
</li>
	<li>
`環境設定に追加する$( %環境設定, "`elements$mb", %要素 )
【！%環境設定[ "`elements$mb" ] に %要素 を`付加する$】
◎
Append element to configuration["elements"].
</li>
	<li>
`環境設定から除去する$( %環境設定, "`removeElements$mb", %要素 )
◎
Remove element from configuration["removeElements"].
</li>
	<li>
`環境設定から除去する$( %環境設定, "`replaceWithChildrenElements$mb", %要素 )
◎
Remove element from configuration["replaceWithChildrenElements"].
</li>
</ol>

<p class="note">注記：
`allowElement()$m 【などが呼出すこの~algo】の取扱いは、
他の~methodより少し複雑である
— 許容される要素たちが成す~list【 `elements$mb 】 %~list は、
それを成す要素ごとに［
許容される／除去される
］属性たちが成す~list
【 `attributes$mbE ／ `removeAttributes$mbE 】
— 要素ごとの~list —
を伴い得るので。
ここでは、
%~list から［
`同等な名前$に基づいて %要素 に合致するもの
］を除去してから %要素 を追加し直す
— それは、
要素ごとの~listが何であれ，それを設定し直す効果がある
（併合するなど，何らかの方法で改変することなく）。
言い換えれば、
要素ごとの~listは，それ全体としてしか設定し得ない。
加えて、［
`removeElements$mb, `replaceWithChildrenElements$mb
］~listからも， %要素 に合致する要素を除去する。
◎
NOTE: Handling of allowElement is a little more complicated than the other methods, because the element allow list can have per-element allow- and remove-attribute lists. We first remove the given element from the list before then adding it, which has the effect of re-setting (rather than merging or elsehow modifying) the per-element list to whatever is passed in. In other words, the per-element allow- and remove-lists can only be set as a whole.
◎
NOTE: Remove matches on name and namespace, so adding an element with attributes would still remove the matching element from the removeElements and replaceWithChildrenElements lists.
</p>
</div>

<div class="algo">
<p>
`要素を除去するようにする@
~algoは、
所与の
( `SanitizerConfig$I %環境設定, %要素 )
に対し：
◎
To remove an element element from a SanitizerConfig configuration, do:
</p>
<ol>
	<li>
%要素 ~SET `無毒化器~要素を正準-化する$( %要素 )
◎
Set element to the result of canonicalize a sanitizer element with element.
</li>
	<li>
`環境設定に追加する$( %環境設定, "`removeElements$mb", %要素 )
◎
Add element to configuration["removeElements"].
</li>
	<li>
`環境設定から除去する$( %環境設定, "`elements$mb", %要素 )
◎
Remove element from configuration["elements"] list.
</li>
	<li>
`環境設定から除去する$( %環境設定, "`replaceWithChildrenElements$mb", %要素 )
◎
Remove element from configuration["replaceWithChildrenElements"].
</li>
</ol>
</div>

<div class="algo">
<p>
`要素をその子~群で置換するようにする@
~algoは、
所与の
( `SanitizerConfig$I %環境設定, %要素 )
に対し：
◎
To replace an element with its children element from a SanitizerConfig configuration, do:
</p>
<ol>
	<li>
%要素 ~SET `無毒化器~要素を正準-化する$( %要素 )
◎
Set element to the result of canonicalize a sanitizer element with element.
</li>
	<li>
`環境設定に追加する$( %環境設定, "`replaceWithChildrenElements$mb", %要素 )
◎
Add element to configuration["replaceWithChildrenElements"].
</li>
	<li>
`環境設定から除去する$( %環境設定, "`removeElements$mb", %要素 )
◎
Remove element from configuration["removeElements"].
</li>
	<li>
`環境設定から除去する$( %環境設定, "`elements$mb", %要素 )
◎
Remove element from configuration["elements"] list.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性を許容するようにする@
~algoは、
所与の
( `SanitizerConfig$I %環境設定, %属性 )
に対し：
◎
To allow an attribute attribute on a SanitizerConfig configuration, do:
</p>
<ol>
	<li>
%属性 ~SET `無毒化器~属性を正準-化する$( %属性 )
◎
Set attribute to the result of canonicalize a sanitizer attribute with attribute.
</li>
	<li>
`環境設定に追加する$( %環境設定, "`attributes$mb", %属性 )
◎
Add attribute to configuration["attributes"].
</li>
	<li>
`環境設定から除去する$( %環境設定, "`removeAttributes$mb", %属性 )
◎
Remove attribute from configuration["removeAttributes"].
</li>
</ol>
</div>

<div class="algo">
<p>
`属性を除去するようにする@
~algoは、
所与の
( `SanitizerConfig$I %環境設定, %属性 )
に対し：
◎
To remove an attribute attribute from a SanitizerConfig configuration, do:
</p>
<ol>
	<li>
%属性 ~SET `無毒化器~属性を正準-化する$( %属性 )
◎
Set attribute to the result of canonicalize a sanitizer attribute with attribute.
</li>
	<li>
`環境設定に追加する$( %環境設定, "`removeAttributes$mb", %属性 )
◎
Add attribute to configuration["removeAttributes"].
</li>
	<li>
`環境設定から除去する$( %環境設定, "`attributes$mb", %属性 )
◎
Remove attribute from configuration["attributes"].
</li>
</ol>
</div>

<div class="algo">
`~commentを許容するか否か設定する@
~algoは、
所与の
( `SanitizerConfig$I %環境設定, `真偽値$ %許容するか )
に対し
⇒
%環境設定[ "`comments$mb" ] ~SET %許容するか
◎
To set comments with allow on a SanitizerConfig configuration, do:
• Set configuration["comments"] to allow.
</div>

<div class="algo">
`~data属性を許容するか否か設定する@
~algoは、
所与の
( `SanitizerConfig$I %環境設定, `真偽値$ %許容するか )
に対し
⇒
%環境設定[ "`dataAttributes$mb" ] ~SET %許容するか
◎
To set data attributes with allow on a SanitizerConfig configuration, do:
• Set configuration["dataAttributes"] to allow.
</div>

<div class="algo">
<p class="note">注記：
次の~algoは，
“安全でない（ `unsafe^en ）…” と称されるが、
用語 “`安全$でない” は，
厳密に`この仕様におけるイミ＠#security-considerations$として
— ［
文書の中へ挿入されたとき~JSを実行することになる内容
］を表すものとして —
利用される。
言い換えれば、
この【~algoを利用する `removeUnsafe()$m 】~methodは，
~XSS用の機会を除去する。
◎
Note: While this algorithm is called remove unsafe, we use the term "unsafe" strictly in the sense of this spec, to denote content that will execute JavaScript when inserted into the document. In other words, this method will remove oportunities for XSS.
</p>

<p>
`安全でないものを除去するようにする@
~algoは、
所与の
( `SanitizerConfig$I %環境設定 )
に対し：
◎
To remove unsafe from a configuration, do this:
</p>
<ol>
	<li>
%最小限の環境設定 ~LET `組込みの安全な最小限の環境設定$
◎
↓</li>
	<li>
~Assert：
~AND↓
⇒＃
%最小限の環境設定[ `removeElements$mb ] ~NEQ ε,
%最小限の環境設定[ `removeAttributes$mb ] ~NEQ ε,
【…以下，不要なので省略する。】
◎
Assert: The built-in safe baseline configuration has removeElements and removeAttributes keys set, but not elements, replaceWithChildrenElements, or attributes.
◎
↑↑ Let result be a copy of configuration.
</li>
	<li>
%最小限の環境設定[ "`removeElements$mb" ] を成す
~EACH( %要素 )
に対し
⇒
`要素を除去するようにする$( %環境設定, %要素 )
◎
For each element in built-in safe baseline configuration[removeElements]:
• Call remove an element with element and result.
</li>
	<li>
%最小限の環境設定[ "`removeAttributes$mb" ] を成す
~EACH( %属性 )
に対し
⇒
`属性を除去するようにする$( %環境設定, %属性 )
◎
For each attribute in built-in safe baseline configuration[removeAttributes]:
• Call remove an attribute with attribute and result.
</li>
	<li>
`HTML$r にて定義される
~EACH( `~event~handler内容~属性$の名前 %属性~名 )
に対し
⇒
`属性を除去するようにする$( %環境設定, %属性~名 )
◎
For each attribute listed in event handler content attributes:
• Call remove an attribute with attribute and result.
◎
↑↑ Return result.
</li>
</ol>

<p class="trans-note">【
原文は %環境設定 を複製してから改変した結果を返しているが、
複製は，`~nodeを無毒化する$ときに限り必要yあるので、
そこへ移動することにする。
】</p>
</div>

<div class="algo">
<p>
`環境設定を設定する@
~algoは、
所与の
( `Sanitizer$I %無毒化器, `辞書$ %~source環境設定, `真偽値$ %~commentや~data属性を許容するか )
に対し：
◎
To set a configuration, given a dictionary configuration, a boolean allowCommentsAndDataAttributes, and a Sanitizer sanitizer:
</p>
<ol>
	<li>
%全部的な環境設定 ~LET %~source環境設定 の複製
</li>
	<li>
<p>
`環境設定の欠落~memberを初期化する$( %全部的な環境設定, %~commentや~data属性を許容するか )
</p>

<p class="trans-note">【
この段と前~段は、
この訳による補完。
原文は、
%~source環境設定 に欠落な~list~memberがある場合を`きちんと取扱っていない＠https://github.com/WICG/sanitizer-api/issues/268$ので。
加えて，
原文では以下で遂行される欠落な真偽値~memberの処理もここで行うことにする。
】</p>
	</li>
	<li>
%環境設定 ~LET %無毒化器 の`環境設定$
◎
↓</li>
	<li>
%全部的な環境設定[ "`elements$mb" ] を成す
~EACH( %要素 )
に対し
⇒
`要素を許容するようにする$( %環境設定, %要素 )
◎
For each element of configuration["elements"] do:
• Call allow an element with element and sanitizer’s configuration.
</li>
	<li>
%全部的な環境設定[ "`removeElements$mb" ] を成す
~EACH( %要素 )
に対し
⇒
`要素を除去するようにする$( %環境設定, %要素 )
◎
For each element of configuration["removeElements"] do:
• Call remove an element with element and sanitizer’s configuration.
</li>
	<li>
%全部的な環境設定[ "`replaceWithChildrenElements$mb" ] を成す
~EACH( %要素 )
に対し
⇒
`要素をその子~群で置換するようにする$( %環境設定, %要素 )
◎
For each element of configuration["replaceWithChildrenElements"] do:
• Call replace an element with its children with element and sanitizer’s configuration.
</li>
	<li>
%全部的な環境設定[ "`attributes$mb" ] を成す
~EACH( %属性 )
に対し
⇒
`属性を許容するようにする$( %環境設定, %属性 )
◎
For each attribute of configuration["attributes"] do:
• Call allow an attribute with attribute and sanitizer’s configuration.
</li>
	<li>
%全部的な環境設定[ "`removeAttributes$mb" ] を成す
~EACH( %属性 )
に対し
⇒
`属性を除去するようにする$( %環境設定, %属性 )
◎
For each attribute of configuration["removeAttributes"] do:
• Call remove an attribute with attribute and sanitizer’s configuration.
</li>
	<li>
`~commentを許容するか否か設定する$( %環境設定, %全部的な環境設定[ "`comments$mb" ] )
◎
If configuration["comments"] exists:
• Then call set comments with configuration["comments"] and sanitizer’s configuration.
• Otherwise call set comments with allowCommentsAndDataAttributes and sanitizer’s configuration.
</li>
	<li>
`~data属性を許容するか否か設定する$( %環境設定, %全部的な環境設定[ "`dataAttributes$mb" ] )
◎
If configuration["dataAttributes"] exists:
• Then call set data attributes with configuration["dataAttributes"] and sanitizer’s configuration.
• Otherwise call set data attributes with allowCommentsAndDataAttributes and sanitizer’s configuration.
</li>
	<li>
<p>
« "`elements$mb", "`removeElements$mb", "`replaceWithChildrenElements$mb", "`attributes$mb", "`removeAttributes$mb" »
を成す
~EACH( %~key )
に対し：
</p>
		<ol>
			<li>
%~size ~LET %全部的な環境設定[ %~key ] の`~size$
</li>
			<li>
~IF［
%~size ~GT 0
］~AND［
%環境設定[ %~key ] ~EQ ε
］
⇒
~RET ~F
</li>
			<li>
~IF［
%~size ~NEQ %環境設定[ %~key ] の`~size$
］
⇒
~RET ~F
</li>
		</ol>
◎
Return whether all of the following are true:
• size of configuration["elements"] equals size of sanitizer’s configuration["elements"].
• size of configuration["removeElements"] equals size of sanitizer’s configuration["removeElements"].
• size of configuration["replaceWithChildrenElements"] equals size of sanitizer’s configuration["replaceWithChildrenElements"].
• size of configuration["attributes"] equals size of sanitizer’s configuration["attributes"].
• size of configuration["removeAttributes"] equals size of sanitizer’s configuration["removeAttributes"].
</li>
	<li>
<p>
~RET ~IS［
~AND↓
］：
</p>
		<ul>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
［
%~source環境設定[ "`elements$mb" ] ~NEQ ε
］~AND［
%~source環境設定[ "`removeElements$mb" ] ~EQ ε
］
</li>
					<li>
［
%~source環境設定[ "`elements$mb" ] ~EQ ε
］~AND［
%~source環境設定[ "`removeElements$mb" ] ~NEQ ε
］
</li>
				</ul>
			</li>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
［
%~source環境設定[ "`attributes$mb" ] ~NEQ ε
］~AND［
%~source環境設定[ "`removeAttributes$mb" ] ~EQ ε
］
</li>
					<li>
［
%~source環境設定[ "`attributes$mb" ] ~EQ ε
］~AND［
%~source環境設定[ "`removeAttributes$mb" ] ~NEQ ε
］
				</ul>
			</li>
		</ul>
◎
• Either configuration["elements"] or configuration["removeElements"] exist, or neither, but not both.
• Either configuration["attributes"] or configuration["removeAttributes"] exist, or neither, but not both.
</li>
</ol>

<p class="note">注記：
この仕様の以前の~versionでは、
環境設定を正準-化する方法を精巧に定義していた。
今や，それは、
実質的に~method定義の中へ移動された。
◎
Note: Previous versions of this spec had elaborate definitions of how to canonicalize a config. This has now effectively been moved into the method definitions.
</p>

<p class="note">注記：
この演算は、
`Sanitizer$I の各種~操作~methodの用語
【各種 “〜するようにする” ／ “するか否か設定する” ~algo】
で定義される。
それらの~methodは、
他の~listから合致している~entryたちを除去する。
~size同等性は、
その後に検査される。
例えば，環境設定 `{ allow: ["div", "div"] }^c は、
その許容される要素たちが成す~list【 `elements$mb 】内に 1 個の要素を伴う `Sanitizer^I を作成してから，
~F を返して~call元に例外を投出させる†。
◎
Note: This operation is defined in terms of the manipulation methods on the Sanitizer. Those methods remove matching entries from other lists. The size equality steps in the last step would then catch this. For example: { allow: ["div", "div"] } would create a Sanitizer with one element in the allow list. The final test would then return false, which would cause the caller to throw an exception.
</p>

<p class="trans-note">【†
作成しないで ~F を返すだけでも足るように見えるが、
将来には例外を投出しない用法も見越されているのかもしれない。
】</p>

<p class="issue">
この~algoは、［
要素ごとの属性~list, 構文~error
］用の~error検査が依然として欠落である。
◎
This is still missing error checks for the per-element attribute lists and syntax errors.
</p>
</div>

<div class="algo">
<p>
`環境設定の欠落~memberを初期化する@
~algoは、
所与の
( `SanitizerConfig$I %環境設定, `真偽値$ %~commentや~data属性を許容するか )
に対し：
</p>
<ol>
	<li>
« "`elements$mb", "`removeElements$mb", "`replaceWithChildrenElements$mb", "`attributes$mb", "`removeAttributes$mb" »
を成す
~EACH( %~key )
に対し
⇒
~IF［
%環境設定[ %~key ] ~EQ ε
］
⇒
%環境設定[ %~key ] ~SET 新たな`~list$
</li>
	<li>
%環境設定[ "`elements$mb" ] を成す
~EACH( %要素 )
に対し
⇒
« "`attributes$mbE", "`removeAttributes$mbE" »
を成す
~EACH( %~key )
に対し
⇒
~IF［
%要素[ %~key ] ~EQ ε
］
⇒
%要素[ %~key ] ~SET 新たな`~list$
</li>
	<li>
« "`comments$mb", "`dataAttributes$mb" »
を成す
~EACH( %~key )
に対し
⇒
~IF［
%環境設定[ %~key ] ~EQ ε
］
⇒
%環境設定[ %~key ] ~SET %~commentや~data属性を許容するか
</li>
</ol>

<p class="trans-note">【
この~algoは、
%環境設定 に欠落~memberがある場合を取扱うための，
この訳による追加。
】</p>
</div>

<div class="algo">
<p>
`属性~群を伴う無毒化器~要素を正準-化する@
~algoは、
所与の
( `SanitizerElementWithAttributes$I %要素 )
に対し：
◎
In order to canonicalize a sanitizer element with attributes a SanitizerElementWithAttributes element, do this:
</p>
<ol>
	<li>
%結果 ~LET `無毒化器~要素を正準-化する$( %要素 )
◎
Let result be the result of canonicalize a sanitizer element with element.
</li>
	<li>
<p>
« "`attributes$mbE", "`removeAttributes$mbE" »
を成す
~EACH( %~key )
に対し：
</p>
		<ol>
			<li>
%属性~群 ~LET %要素[ %~key ]
</li>
			<li>
~IF［
%属性~群 ~EQ ε
］
⇒
~CONTINUE
</li>
			<li>
<p>
%属性~群 を成す
~EACH( %属性 )
に対し：
</p>
				<ol>
					<li>
%属性 ~SET `無毒化器~属性を正準-化する$( %属性 )
</li>
					<li>
`環境設定に追加する$( %結果, %~key, %属性 )
</li>
				</ol>
			</li>
		</ol>
◎
If element is a dictionary:（この条件は不要）
• For each attribute in element["attributes"]:
•• Add the result of canonicalize a sanitizer attribute with attribute to result["attributes"].
◎
• For each attribute in element["removeAttributes"]:
•• Add the result of canonicalize a sanitizer attribute with attribute to result["removeAttributes"].
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
`無毒化器~要素を正準-化する@
~algoは、
所与の
( `SanitizerElement$I %要素 )
に対し
⇒
~RET `無毒化器~用の名前を正準-化する$( %要素, `~HTML名前空間$ )
◎
In order to canonicalize a sanitizer element a SanitizerElement element, return the result of canonicalize a sanitizer name with element and the HTML namespace as the default namespace.
</div>

<div class="algo">
`無毒化器~属性を正準-化する@
~algoは、
所与の
( `SanitizerAttribute$I %属性 )
に対し
⇒
~RET `無毒化器~用の名前を正準-化する$( %属性, ~NULL )
◎
In order to canonicalize a sanitizer attribute a SanitizerAttribute attribute, return the result of canonicalize a sanitizer name with attribute and null as the default namespace.
</div>

<div class="algo">
<p>
`無毒化器~用の名前を正準-化する@
~algoは、
所与の
( %名前, %既定の名前空間 )
に対し，
%名前 に応じて：
◎
In order to canonicalize a sanitizer name name, with a default namespace defaultNamespace, run the following steps:
</p>
<ul class="switch">
	<li>
`文字列$である
⇒
~RET «[ `name^l → %名前, `namespace^l → %既定の名前空間 ]»
◎
Assert: name is either a DOMString or a dictionary.
◎
If name is a DOMString, then return «[ "name" → name, "namespace" → defaultNamespace]».
</li>
	<li>
<p>
`辞書$である：
</p>
		<ol>
			<li>
%局所~名 ~LET %名前[ `name^l ]
</li>
			<li>
~Assert：
%局所~名 ~NEQ ε
</li>
			<li>
%名前空間 ~LET %名前[ `namespace^l ]
</li>
			<li>
~IF［
%名前空間 ~EQ ε
］
⇒
%名前空間 ~SET %既定の名前空間
</li>
			<li>
~IF［
%名前空間 ~EQ 空~文字列
］
⇒
%名前空間 ~SET ~NULL
</li>
			<li>
~RET «[ `name^l → %局所~名, `namespace^l → %名前空間 ]»
</li>
		</ol>
◎
Assert: name is a dictionary and name["name"] exists.
◎
Let namespace be name["namespace"] if it exists, otherwise defaultNamespace.
◎
If namespace is the empty string, then set it to null.
◎
Return «[
"name" → name["name"],
"namespace" → namespace
]».
</li>
</ul>
</div>

		</section>
		<section id="alg-support">
<h3 title="Supporting Algorithms">3.3. ~support用の~algo</h3>

<p>
この仕様において利用される`正準-化された＠#canonicalize-a-sanitizer-name$［
要素~名（ `SanitizerElementNamespace$I ） ／
属性~名（ `SanitizerAttributeNamespace$I ）
］たちが成す~list用には、
~listを成す~memberであるか否かは［
`name^l, `namespace^l
］両~entryを照合すること（`同等な名前$か否か）に基づく。
◎
For the canonicalized element and attribute name lists used in this spec, list membership is based on matching both "name" and "namespace" entries:
</p>

<div>
<p>
`正準-化された名前@
とは、
次を満たす`有順序~map$ %~map である
⇒
［
%~map[ `name^l ] は文字列である
］~AND［
%~map[ `namespace^l ] は文字列である
］
</p>

<p class="trans-note">【
この用語は、
明確化するための，この訳による追加。
】</p>

<p>
所与の
( `正準-化された名前$ %A, `正準-化された名前$ %B )
が
`同等な名前@
であるとは、
~AND↓ が満たされることをいう：
</p>
<ul>
	<li>
%A[ `name^l ] ~EQ %B[ `name^l ]【！`同等な集合$】
</li>
	<li>
%A[ `namespace^l ] ~EQ %B[ `namespace^l ]【！`同等な集合$】
</li>
</ul>

<p>
この条件は、
“ %A ~EQ`名前$sub %B ”
とも表記される。
~EQ に代えて ~NEQ や ~IN と伴に利用された場合も、
それらの定義は，この同等性に基づくことになる。
</p>

<p class="trans-note">【
この［
用語／定義
］は，原文では別の形で表現されているが、
この訳では，このように改める
— そうした方が簡便に利用できるので。
】</p>
◎
A Sanitizer name list contains an item if there exists an entry of list that is an ordered map, and where item["name"] equals entry["name"] and item["namespace"] equals entry["namespace"].
</div>

<div class="algo">
<p>
`環境設定から除去する@
~algoは、
所与の
( `有順序~map$ %~map, `文字列$ %~key, `正準-化された名前$ %名前 )
に対し：
</p>
<ol>
	<li>
%~list ~LET %~map[ %~key ]
</li>
	<li>
~IF［
%~list ~EQ ε
］
⇒
~RET
</li>
	<li>
~Assert：
%~list を成す各~itemは`正準-化された名前$である。
</li>
	<li>
%~list から次を満たす~itemを`除去する$
⇒
当の~item ~EQ`名前$sub %名前
</li>
	<li class="trans-note">
【
一貫性を得るためには、
この段で，次を遂行する必要もあるかもしれない
】
⇒
~IF［
%~list は空である
］
⇒
%~map[ %~key ] ~SET ε
</li>
</ol>
◎
To remove an item from a list that is an ordered map, remove all entry from list where item["name"] equals entry["name"] and item["namespace"] equals entry["namespace"].
</div>

<div class="algo">
<p>
`環境設定に追加する@
~algoは、
所与の
( `有順序~map$ %~map, `文字列$ %~key, `正準-化された名前$ %名前 )
に対し：
</p>
<ol>
	<li>
~IF［
%~map[ %~key ] ~EQ ε
］
⇒
%~map[ %~key ] ~SET 新たな`~list$
</li>
	<li>
%~list ~LET %~map[ %~key ]
</li>
	<li>
~Assert：
%~list を成す各~itemは`正準-化された名前$である。
</li>
	<li>
~IF［
%名前 ~IN`名前$sub %~list
］
⇒
~RET
</li>
	<li>
%~list に %名前 を`付加する$
</li>
</ol>
◎
To add a name to a list, where name is canonicalized and list is an ordered map:
• If list contains name, then return.
• Append name to list.
</div>

<p>
`有順序~集合$どうしの
`同等性＠#set-equal@
は…
◎
Equality for ordered sets is equality of its members, but without regard to order: Ordered sets A and B are equal if both A is a superset of B and B is a superset of A.
</p>

<p class="trans-note">【
この定義は利用されないので、
和訳は省略する。
原文にて，この用語を参照している箇所は、
実際には文字列どうしを比較しており，誤りであろう。
】</p>

<div class="algo">
<p>
`真偽値$ %bool の
`not＠#boolean-not@
を決定する~algoは
⇒
~RET ~IS［
%bool ~EQ ~F
］
◎
To determine not of a boolean bool, return false if bool is true, and return true otherwise.
</p>

<p class="trans-note">【
この訳では、
この~algoを利用しない。
この~siteの和訳全般に利用される ~IS 演算で足るので。
】</p>
</div>

		</section>
		<section id="sanitization-defaults">
<h3 title="Builtins">3.4. 組込みのもの</h3>

<p>
組込みの環境設定として、
次に挙げる 4 種がある
⇒＃
`組込みの安全な既定の環境設定$,
`組込みの安全な最小限の環境設定$,
`組込みの~navigateされる~URLをとる属性~list$,
`組込みの~animateされる~URLをとる属性~list$
◎
There are four builtins:
• The built-in safe default configuration,
• the built-in safe baseline configuration,
• the built-in navigating URL attributes list, and
• the built-in animating URL attributes list.
</p>

<p>
以下に現れる［
%HTMLNS は`~HTML名前空間$／
%SVGNS は`~SVG名前空間$／
%MathMLNS は`~MathML名前空間$
］を表すとする。
◎
↓</p>

<p>
`組込みの安全な既定の環境設定@
は、
次で与えられる：
◎
The built-in safe default configuration is as follows:
</p>

<pre>
{
  "elements": [
    {
      "name": "html",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "head",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "title",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "body",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "article",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "section",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "nav",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "aside",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "h1",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "h2",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "h3",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "h4",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "h5",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "h6",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "hgroup",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "header",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "footer",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "address",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "p",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "hr",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "pre",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "blockquote",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "cite",
          "namespace": null
        }
      ]
    },
    {
      "name": "ol",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "reversed",
          "namespace": null
        },
        {
          "name": "start",
          "namespace": null
        },
        {
          "name": "type",
          "namespace": null
        }
      ]
    },
    {
      "name": "ul",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "menu",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "li",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "value",
          "namespace": null
        }
      ]
    },
    {
      "name": "dl",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "dt",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "dd",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "figure",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "figcaption",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "main",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "search",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "div",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "a",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "href",
          "namespace": null
        },
        {
          "name": "rel",
          "namespace": null
        },
        {
          "name": "hreflang",
          "namespace": null
        },
        {
          "name": "type",
          "namespace": null
        }
      ]
    },
    {
      "name": "em",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "strong",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "small",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "s",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "cite",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "q",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "dfn",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "abbr",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "ruby",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "rt",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "rp",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "data",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "value",
          "namespace": null
        }
      ]
    },
    {
      "name": "time",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "datetime",
          "namespace": null
        }
      ]
    },
    {
      "name": "code",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "var",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "samp",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "kbd",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "sub",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "sup",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "i",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "b",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "u",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "mark",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "bdi",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "bdo",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "span",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "br",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "wbr",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "ins",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "cite",
          "namespace": null
        },
        {
          "name": "datetime",
          "namespace": null
        }
      ]
    },
    {
      "name": "del",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "cite",
          "namespace": null
        },
        {
          "name": "datetime",
          "namespace": null
        }
      ]
    },
    {
      "name": "table",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "caption",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "colgroup",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "span",
          "namespace": null
        }
      ]
    },
    {
      "name": "col",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "span",
          "namespace": null
        }
      ]
    },
    {
      "name": "tbody",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "thead",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "tfoot",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "tr",
      "namespace": %HTMLNS,
      "attributes": []
    },
    {
      "name": "td",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "colspan",
          "namespace": null
        },
        {
          "name": "rowspan",
          "namespace": null
        },
        {
          "name": "headers",
          "namespace": null
        }
      ]
    },
    {
      "name": "th",
      "namespace": %HTMLNS,
      "attributes": [
        {
          "name": "colspan",
          "namespace": null
        },
        {
          "name": "rowspan",
          "namespace": null
        },
        {
          "name": "headers",
          "namespace": null
        },
        {
          "name": "scope",
          "namespace": null
        },
        {
          "name": "abbr",
          "namespace": null
        }
      ]
    },
    {
      "name": "math",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "merror",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mfrac",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mi",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mmultiscripts",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mn",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mo",
      "namespace": %MathMLNS,
      "attributes": [
        {
          "name": "form",
          "namespace": null
        },
        {
          "name": "fence",
          "namespace": null
        },
        {
          "name": "separator",
          "namespace": null
        },
        {
          "name": "lspace",
          "namespace": null
        },
        {
          "name": "rspace",
          "namespace": null
        },
        {
          "name": "stretchy",
          "namespace": null
        },
        {
          "name": "symmetric",
          "namespace": null
        },
        {
          "name": "maxsize",
          "namespace": null
        },
        {
          "name": "minsize",
          "namespace": null
        },
        {
          "name": "largeop",
          "namespace": null
        },
        {
          "name": "movablelimits",
          "namespace": null
        }
      ]
    },
    {
      "name": "mover",
      "namespace": %MathMLNS,
      "attributes": [
        {
          "name": "accent",
          "namespace": null
        }
      ]
    },
    {
      "name": "mpadded",
      "namespace": %MathMLNS,
      "attributes": [
        {
          "name": "width",
          "namespace": null
        },
        {
          "name": "height",
          "namespace": null
        },
        {
          "name": "depth",
          "namespace": null
        },
        {
          "name": "lspace",
          "namespace": null
        },
        {
          "name": "voffset",
          "namespace": null
        }
      ]
    },
    {
      "name": "mphantom",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mprescripts",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mroot",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mrow",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "ms",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mspace",
      "namespace": %MathMLNS,
      "attributes": [
        {
          "name": "width",
          "namespace": null
        },
        {
          "name": "height",
          "namespace": null
        },
        {
          "name": "depth",
          "namespace": null
        }
      ]
    },
    {
      "name": "msqrt",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mstyle",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "msub",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "msubsup",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "msup",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mtable",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mtd",
      "namespace": %MathMLNS,
      "attributes": [
        {
          "name": "columnspan",
          "namespace": null
        },
        {
          "name": "rowspan",
          "namespace": null
        }
      ]
    },
    {
      "name": "mtext",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "mtr",
      "namespace": %MathMLNS,
      "attributes": []
    },
    {
      "name": "munder",
      "namespace": %MathMLNS,
      "attributes": [
        {
          "name": "accentunder",
          "namespace": null
        }
      ]
    },
    {
      "name": "munderover",
      "namespace": %MathMLNS,
      "attributes": [
        {
          "name": "accent",
          "namespace": null
        },
        {
          "name": "accentunder",
          "namespace": null
        }
      ]
    },
    {
      "name": "semantics",
      "namespace": %MathMLNS,
      "attributes": []
    }
  ],
  "attributes": [
    {
      "name": "dir",
      "namespace": null
    },
    {
      "name": "lang",
      "namespace": null
    },
    {
      "name": "title",
      "namespace": null
    },
    {
      "name": "displaystyle",
      "namespace": null
    },
    {
      "name": "mathbackground",
      "namespace": null
    },
    {
      "name": "mathcolor",
      "namespace": null
    },
    {
      "name": "mathsize",
      "namespace": null
    },
    {
      "name": "scriptlevel",
      "namespace": null
    }
  ]
  "comments": false,
  "dataAttributes": false
}
</pre>

<p class="note">注記：
上に含められた `MathML$r ~markupは、
`SafeMathML$r に基づく。
◎
Note: Included [MathML] markup is based on [SafeMathML].
</p>

<p>
`組込みの安全な最小限の環境設定@
は、
~script内容のみを阻止することが意味され，次で与えられる：
◎
The built-in safe baseline configuration is meant to block only script-content. It is as follows:
</p>

<pre>
{
  "removeElements": [
    {
      "namespace": %HTMLNS,
      "name": "script"
    },
    {
      "namespace": %HTMLNS,
      "name": "frame"
    },
    {
      "namespace": %HTMLNS,
      "name": "iframe"
    },
    {
      "namespace": %HTMLNS,
      "name": "object"
    },
    {
      "namespace": %HTMLNS,
      "name": "embed"
    },
    {
      "namespace": %SVGNS,
      "name": "script"
    },
    {
      "namespace": %SVGNS,
      "name": "use"
    }
  ],
  "removeAttributes": []
}
</pre>

<div class="advisement">
<p>警告：
`安全でないものを除去するようにする$~algoは、［
`HTML$r にて定義される`~event~handler内容~属性$を除去する
］よう追加的に指定する。
~UAは、
`HTML$r 仕様に対する拡張として追加的な`~event~handler内容~属性$を定義する場合には，
それを取扱う方法を裁定する責務がある。
現在の`~event~handler内容~属性$たちを利用する下では、
安全な最小限の環境設定は，実質的に次の様になる：
◎
Warning: The remove unsafe algorithm specifies to additionally remove any event handler content attributes, as defined in [HTML]. If a user agent defines extensions to the [HTML] spec with additional event handler content attributes, it is its responsibility to decide how to handle them. Using the current event handler content attributes list, the safe baseline configuration looks effectively like so:
</p>

<pre>
{
  "removeElements": [
    {
      "namespace": %HTMLNS,
      "name": "script"
    },
    {
      "namespace": %HTMLNS,
      "name": "frame"
    },
    {
      "namespace": %HTMLNS,
      "name": "iframe"
    },
    {
      "namespace": %HTMLNS,
      "name": "object"
    },
    {
      "namespace": %HTMLNS,
      "name": "embed"
    },
    {
      "namespace": %SVGNS,
      "name": "script"
    },
    {
      "namespace": %SVGNS,
      "name": "use"
    }
  ],
  "removeAttributes": [
    "onafterprint",
    "onauxclick",
    "onbeforeinput",
    "onbeforematch",
    "onbeforeprint",
    "onbeforeunload",
    "onbeforetoggle",
    "onblur",
    "oncancel",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncontextlost",
    "oncontextmenu",
    "oncontextrestored",
    "oncopy",
    "oncuechange",
    "oncut",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "onformdata",
    "onhashchange",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onlanguagechange",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onmessage",
    "onmessageerror",
    "onmousedown",
    "onmouseenter",
    "onmouseleave",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onoffline",
    "ononline",
    "onpagehide",
    "onpagereveal",
    "onpageshow",
    "onpageswap",
    "onpaste",
    "onpause",
    "onplay",
    "onplaying",
    "onpopstate",
    "onprogress",
    "onratechange",
    "onreset",
    "onresize",
    "onrejectionhandled",
    "onscroll",
    "onscrollend",
    "onsecuritypolicyviolation",
    "onseeked",
    "onseeking",
    "onselect",
    "onslotchange",
    "onstalled",
    "onstorage",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "ontoggle",
    "onunhandledrejection",
    "onunload",
    "onvolumechange",
    "onwaiting",
    "onwheel"
  ]
}
</pre>
</div>

<p>
`組込みの~navigateされる~URLをとる属性~list@
は、
`javascript:＠~HTMLnav#the-javascript:-url-special-case$l ~naviが安全でないとされるものであり，次で与えられる
◎
The built-in navigating URL attributes list, for which "javascript:" navigations are "unsafe", are as follows:
</p>

<pre>
«[
[ { "name" → "a", "namespace" → %HTMLNS }, { "name" → "href", "namespace" → null } ],
[ { "name" → "area", "namespace" → %HTMLNS }, { "name" → "href", "namespace" → null } ],
[ { "name" → "base", "namespace" → %HTMLNS }, { "name" → "href", "namespace" → null } ],
[ { "name" → "button", "namespace" → %HTMLNS }, { "name" → "formaction", "namespace" → null } ],
[ { "name" → "form", "namespace" → %HTMLNS }, { "name" → "action", "namespace" → null } ],
[ { "name" → "iframe", "namespace" → %HTMLNS }, { "name" → "src", "namespace" → null } ],
[ { "name" → "input", "namespace" → %HTMLNS }, { "name" → "formaction", "namespace" → null } ],
[ { "name" → "a", "namespace" → %SVGNS }, { "name" → "href", "namespace" → null } ],
[ { "name" → "a", "namespace" → %SVGNS }, { "name" → "href", "namespace" → XLink namespace } ],
]»
</pre>

<p>
`組込みの~animateされる~URLをとる属性~list@
は、
次で与えられ，
`SVG11$r において~navi要素を ~js_~URLを利用するよう宣言的に改変するために利用され得る：
◎
The built-in animating URL attributes list, which can be used in [SVG11] to declaratively modify navigation elements to use "javascript:" URLs, is as follows:
</p>

<pre>
«[
[ { "name" → "animate", "namespace" → %SVGNS }, { "name" → "attributeName", "namespace" → null] } ],
[ { "name" → "animateMotion", "namespace" → %SVGNS }, { "name" → "attributeName", "namespace" → null } ],
[ { "name" → "animateTransform", "namespace" → %SVGNS }, { "name" → "attributeName", "namespace" → null } ],
[ { "name" → "set", "namespace" → %SVGNS }, { "name" → "attributeName", "namespace" → null } ],
]»
</pre>


		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">4. ~securityの考慮点</h2>

<p>
`無毒化器~API^i に意図されるのは、
~DOMに基づく~XSS（ `DOM-based Cross-Site Scripting^en ）を防止することである
— 給された~HTML内容を辿って，環境設定に則って［
要素／属性
］を除去することにより。
この~APIの仕様は、［
~script能力がある~markupを残すような `Sanitizer^I ~objの構築
【！この `Sanitizer^I は、現在の `Sanitizer$I とは別物かも？】
］を~supportしてはナラナイ
— そうすることは、
脅威~modelにおける~bugになろう。
◎
The Sanitizer API is intended to prevent DOM-based Cross-Site Scripting by traversing a supplied HTML content and removing elements and attributes according to a configuration. The specified API must not support the construction of a Sanitizer object that leaves script-capable markup in and doing so would be a bug in the threat model.
</p>

<p>
とは言え、
`無毒化器~API^i の正しい用法では保護-可能でない，~securityの課題はある
— 以下の下位節では、
そのような局面について~~述べる。
◎
That being said, there are security issues which the correct usage of the Sanitizer API will not be able to protect against and the scenarios will be laid out in the following sections.
</p>

		<section id="server-side-xss">
<h3 title="Server-Side Reflected and Stored XSS">4.1. ~server側に反映され, 格納される~XSS</h3>

◎非規範的

<p>
`無毒化器~API^i は、
もっぱら~DOM内で演算する
— それは、
既存の `DocumentFragment$I を辿って~filterするための能力を追加する。
`無毒化器~API^i は、［
~server側に反映され, 格納される~XSS
］には取組まない。
◎
The Sanitizer API operates solely in the DOM and adds a capability to traverse and filter an existing DocumentFragment. The Sanitizer does not address server-side reflected or stored XSS.
</p>

		</section>
		<section id="dom-clobbering">
<h3 title="DOM clobbering">4.2. ~DOM~clobbering</h3>

◎非規範的

<p>
~DOM~clobbering【 “痛めつけ” 】は、
悪意的な~HTMLで~appを惑わす攻撃である
— そこでは、［
要素の［
`id^a や `name^a
］属性を命名することにより，［
~DOM内の~HTML要素の `children^m の様な~prop
］が悪意的な内容により隠蔽される。
◎
DOM clobbering describes an attack in which malicious HTML confuses an application by naming elements through id or name attributes such that properties like children of an HTML element in the DOM are overshadowed by the malicious content.
</p>

<p>
`無毒化器~API^i は、
既定の状態では，~DOM~clobbering攻撃を保護しないが、
`id^a 属性や `name^a 属性を除去するよう環境設定することはできる。
◎
The Sanitizer API does not protect DOM clobbering attacks in its default state, but can be configured to remove id and name attributes.
</p>

		</section>
		<section id="script-gadgets">
<h3 title="XSS with Script gadgets">4.3. ~script~gadgetを伴う~XSS</h3>

◎非規範的

<p>
~script~gadgetは、
既存の［
普及している~JS~libraryからの~app~code
］を利用して，攻撃者が自前の~codeを実行させる技法である。
これは、［
ある~frameworkに限り，構文解析され解釈される
］ような［
見かけは潔白な~code／不活そうに見える~DOM~node
］を注入することにより行われることが多く、
その入力に基づいて~JSの実行を遂行する。
◎
Script gadgets are a technique in which an attacker uses existing application code from popular JavaScript libraries to cause their own code to execute. This is often done by injecting innocent-looking code or seemingly inert DOM nodes that is only parsed and interpreted by a framework which then performs the execution of JavaScript based on that input.
</p>

<p>
`無毒化器~API^i は、
これらの攻撃を防止できないが，［
次に挙げるものを許容するためには、
明示的に環境設定しなければナラナイ
］ことを~page作者に要求する：
◎
The Sanitizer API can not prevent these attacks, but requires page authors to explicitly allow unknown elements in general, and authors must additionally explicitly configure＼
</p>
<ul>
	<li>
未知な［
属性／要素
］
◎
unknown attributes and elements＼
</li>
	<li>
［
~template化, ~framework
］に特有な~code用に広く利用されていることが既知な~markup
— 次に挙げるものなど
⇒＃
`data-$a 属性,
`slot$a 属性,
`slot$e 要素,
`template$e 要素
◎
and markup that is known to be widely used for templating and framework-specific code, like data- and slot attributes and elements like &lt;slot&gt; and &lt;template&gt;.＼
</li>
</ul>

<p>
これらの制約は、
網羅的でないと予見される。
~page作者には、［
自身が利用している第三者-主体~libraryを，この挙動に関して精査すること
］が奨励される。
◎
We believe that these restrictions are not exhaustive and encourage page authors to examine their third party libraries for this behavior.
</p>

		</section>
		<section id="mutated-xss">
<h3 title="Mutated XSS">4.4. ~mXSS</h3>

◎非規範的

<p>
~mXSS
（ `mutated Cross-Site Scripting^en ／ `mutated XSS^en の略称）は、［
~HTML~code片を不正な文脈の下で構文解析するとき，構文解析器【を遂行している】文脈が合致しないこと
］に基づく攻撃である。
特に，【ある親~要素の中で】~HTML素片を構文解析してから文字列に直列化した結果は、
異なる親~要素の中に挿入されるとき，~~元と正確に同じに［
構文解析され, 解釈される
］ことは保証されない。
そのような攻撃を遂げる例には、［
外来な内容や誤って入子にされた~tagに対し，構文解析の挙動が変化すること
］に依拠するものがある。
◎
Mutated XSS or mXSS describes an attack based on parser context mismatches when parsing an HTML snippet without the correct context. In particular, when a parsed HTML fragment has been serialized to a string, the string is not guaranteed to be parsed and interpreted exactly the same when inserted into a different parent element. An example for carrying out such an attack is by relying on the change of parsing behavior for foreign content or mis-nested tags.
</p>

<p>
`無毒化器~API^i は、
文字列を~node~treeへ転化する機能しか提供しない。
すべての無毒化器~関数は、
文脈を暗黙的に給する：
`Element$I の `setHTML()$mE は現在の要素を利用し，
`Document$I の `parseHTML()$m は新たな文書を作成する。
したがって、
`無毒化器~API^i は，~mXSSにより直に影響されることは無い。
◎
The Sanitizer API offers only functions that turn a string into a node tree. The context is supplied implicitly by all sanitizer functions: Element.setHTML() uses the current element; Document.parseHTML() creates a new document. Therefore Sanitizer API is not directly affected by mutated XSS.
</p>

<p>
開発者が無毒化された~node~treeを
— 例えば `innerHTML$mE を介して —
文字列として検索取得してから，その結果を再び構文解析した場合、
~mXSSが生じ得る
— なので，この実施は忌避される。
それでも，~HTMLを文字列として［
処理する／渡す
］ことが必要yな場合、
文字列を~DOMの中へ挿入するときには，
信用-済みでないのと見なすベキであり，（再び）無毒化するベキである。
言い換えれば、
無毒化されてから直列化された~HTML~treeは，
もはや無毒化-済みとは見なせない。
◎
If a developer were to retrieve a sanitized node tree as a string, e.g. via .innerHTML, and to then parse it again then mutated XSS may occur. We discourage this practice. If processing or passing of HTML as a string should be necessary after all, then any string should be considered untrusted and should be sanitized (again) when inserting it into the DOM. In other words, a sanitized and then serialized HTML tree can no longer be considered as sanitized.
</p>

<p>
~mXSSに対する，より完全な扱いは、
`MXSS$r にて見出せる。
◎
A more complete treatment of mXSS can be found in [MXSS].
</p>

		</section>
	</section>
	<section id="ack">
<h2 title="Acknowledgements">5. 謝辞</h2>

<p>
この作業は、［
`cure53^en 氏による `DOMPURIFY$r 
`Internet Explorer^en の `window.toStaticHTML()＠https://msdn.microsoft.com/en-us/library/cc848922(v=vs.85).aspx$c,
`Ben Bucksch^en 氏による元の `HTMLSanitizer$r
］による情報と発想に基づく。
次に挙げる方々も貴重な~feedbackを寄せられた
⇒
`Anne van Kesteren, Krzysztof Kotowicz, Tom Schuster, Luke Warlow, Guillaume Weghsteen, and Mike West^en
◎
This work is informed and inspired by [DOMPURIFY] from cure53, Internet Explorer’s window.toStaticHTML() as well as the original [HTMLSanitizer] from Ben Bucksch. Anne van Kesteren, Krzysztof Kotowicz, Tom Schuster, Luke Warlow, Guillaume Weghsteen, and Mike West for their valuable feedback.
</p>

	</section>
</main></div>

