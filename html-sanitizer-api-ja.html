<!DOCTYPE html><html><head><meta charset="utf-8">
<title>HTML Sanitizer API（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">

<style>
.wpt-block {
	background-color: var(--note-bg-color);
}
</style>


<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		persisted_parts: Object.create(null),
		generate: expand,
	};
	{
		const test_list = [
"sanitizer-sanitize",
"sanitizer-sanitizeFor",
"element-set-sanitized-html",
"sanitizer-config",
"sanitizer-query-config"
		];
		const parts = source_data.persisted_parts;
		test_list.forEach( (id) => {
			const suffix = 
				( id === 'sanitizer-query-config' ) ?
					'.https.tenative.html'
					: '.https.tentative.html';
			const href = id + suffix;
			const div = C('div');
			div.className = 'wpt-block';
			div.innerHTML = `
テスト：
<a href="https://wpt.fyi/results/sanitizer-api/${href}">${href}</a>
<a href="https://wpt.live/sanitizer-api/${href}">(live test)</a>
<a href="https://github.com/web-platform-tests/wpt/blob/master/sanitizer-api/${href}">(source)</a>
`;
			parts[`_test-${id}`] = div;
		});
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'tg':
	klass = 'e';
	text = `&lt;${key}&gt;`;
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'mc':
	text = 'constructor';
//	key = `new ${key}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	href = `~ISSUE/${key}`;
	text = `課題 #${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2023-11-24
trans_update:2022-12-25
source_checked:211130
	page_state_key:＊
original_url:https://wicg.github.io/sanitizer-api/
abbr_url:HTMLsanitizer
spec_status:EDCG
ref_id_prefix:biblio-
ref_id_lowercase:true
	conformance:
	copyright:
site_nav:html,security
trans_1st_pub:2021-11-16


●●class_map
E:error
e:element
tg:element
a:attr
et:event-type

●●tag_map
p:var
e:code
tg:code
a:code
E:code
I:code
m:code
c:code
i:i
V:var
sub:sub

●●words_table1
ISSUE:https://github.com/WICG/sanitizer-api/issues

●●words_table

	●略語
MathML:
XSS:
	~XSS:cross-site scripting
	~XSS:Cross-Site Scripting
	~XSS:XSS-style
mXSS:
	~mXSS:mXSS-
	~mXSS:mXSS-style
	~mXSS:Mutated Cross-Site Scripting
	~mXSS:Mutated XSS
環境設定0:config:環境設定

	●sanitizer
sanitize:
sanitizer:
Sanitizer:
	~Sanitizer:the Sanitizer
sanitization:
	~sanitizeした結果:after sanitization
正則:regular:~
保つ:keepする:~

baseline:
funky:

	i.保つ:c.keep
	i.落とす:c.drop
	i.阻止する:c.block
	i.正則:c.regular
	i.未知:c.unknown
	i.~custom:c.custom

	●処理
繰返に:repeatedly:繰り返し
	文字列を文字列へ~~変換する:string-to-string
	手渡せる:can in turn hand over
	通過-:passed through
	〜を~~連結して:joining 〜 together
	同時に:simultaneously
	直列化-:un-parsing
	直列化-:unparsing
	直列化-:unparse
	構文解析し直す:re-parsing
	構文解析器:Parser
	接続されて$いない:unconnectedな
	構文解析器:Parser
	文字ごとに:character-for-character
	小文字~化:lowercased
	%属性:attr

	●構文
body:
連結-:concatenate:~
	どの名前空間にも属さない:non-namespaced

	誤って入子にされた:misnested
	文字大小無視:case insensitive
	構文解析器:Parser

	●保安
能動的:active::~::アクティブ
潔白:innocent:~
	見かけは潔白な:innocent-looking
不活:inert:~
	不活そうに見える:seemingly inert
策:strategy::~
脅威:threat::~
危険:dangerous:~
時限爆弾:time-bomb:~
悪用-:exploite:~
gadget:
clobbering:

	抗する:against
	信用-済みでない:untrusted
	~secureでない:insecure
	~script的:script-ish
	~script的な:script-y
	~script注入:script-injection
	許容-~list:allow-list

	●仕様

素朴:naive:~
目指す:aimする:~
機能上の:functionalな:~
種類:kind:~
網羅的:exhaustive:~
稀:rare:~
立証-:prove:~
本物の:realな:~
	それを行うようになる:will 〜 do so in a fashion
維持-:retain:~
責務:responsibility:~
計画-:plan:~
微妙:subtle:~
審査-:vet:~
遂げる:carry outする:~
外来:foreign::~
完結-:finalize:~
寄与-:contribute:~
有益:beneficial:~
現実:real-world:~
理解:understanding:~
給-:supply:~
移植-:graft:~
trouble::::トラブル
補助用の:helper:~
協力:cooperation:~
扱い:treatement:~
正当性:justification:~
惑わす:confuseする:~
発想:inspiration:~
教える:teachする:~
学習-:learn:~
由来:derivation:~
排-:eliminate:~
解決策:solution:~
翻訳-:translate:~
export:
参照r:refer:参照
有効:effective:~

	およそ見込まれない:unlikely
	それほどでもない:not so much
	ある程度の:some degree of
	多くの, ほとんどの:Most, many
	他のどの 〜 にも，およそ:pretty much every
	-:proudly
	4 種に~~分類される: fall into one of four classes
	自体:by themselves
	それ自体は:_per~se_
	それ自体:in its own right
	とり挙げ:pick
	へ進む:go with
	〜こそが:very
	得られ:yield
	見込みがずっと高い:much more likely to be
	~~強調したい:like to stress
	読み易さのため:ease of reading
	関心事:we are interested in
	しないこと。:you shall pretty
	はらんで:fraught with
	結局の所:ultimately
	表す:stands for
	表す:denote
	まさに:just
	感じられ:feel
	残り:the rest
	どうするか？:what if
	とは言え、:That being said
	つきまとう:come with
	ついてくる:comes with
	少ない:little
	挙動は 〜 一致する:behave identically
	どちらも，他方を:respective other
	次に従って決定される:Let 〜:
	該当する:applies to
	広く:widely
	普及している:popularな
	~~説明用:for illustration purposes
	~~説明用:for illustrative purposes
	~~説明用の:for illustration 
	~scriptを伴わない:non-scripting
	委ねられ:up to
	処する:deal with
	旧式な:outdated
	紛れもなく:arguably
	当の:your
	かまわない:free to
	~sanitizeした結果を その文脈から切り離しても:take the sanitization result and remove it from its context
	誤って適用すること:mis-applying
	起因する:stem from
	伝えな:inform
	潜む:creep
	よく知る立場にある:has a fairly good idea
	脆い:fragileな
	影響されない:unaffected
	見かけ:look
	覚えた:remember
	残す:leave
	転化-:turn into
	より厳密:stricter
	事実:in fact
	そこまでに:only
	と同じく:just like
	助手:side-kick
	同類:companion
	併用されるもの:companion
	片棒を担ぐ:accomplice
	まだまだ:super-duper
	最終的:eventual
	結局の所:ultimately
	概念~化できる:One way to conceptualize this is to view
	許容しない:disallow
	および:plus
	ある程度の:some amount of
	委ねる:leave
	一箇所:in one place
	助け:help
	求まれる:we want
	§:subchapter
	制限-付きで:limited
	追加される:gains an additional
	〜だけ用い続ける:stick with
	もっぱら:sole
	能力がある:〜-capable
	^en:opt-out
	^en:W3C Standard
	^en:W3C Standards Track
	異なる何かに:differently
	この仕様の:our own
	追い易くする:easy to follow
	〜の仕様:specified
	依存する:dependent
	追い易くする:easy to follow
	忘れることはない:disappear
	あろう:maybe
	その場限りの:hacky
	手早く:quick
	草案:draft
	~~述べる:laid out
	可能性:possibility
	下位節:subsection
	-:subchapter
	-:branch
	明らか:apparent
	注意:note
	と捉えられる:may think of
	整理-:clean up
	その場で:in place
	少し精確さに欠く:a bit too imprecise
	~~避けたい:We do not want to
	本当の問い:question is really

	●未分類
広義:inclusive:~
封入-:enclose:~
同等性:equality:~
template:
	~template化:templating
	template::::テンプレート
隠蔽-:overshadow:~
cell::::セル

	属する:belong
	遅くなる:slower
	~code片:snippet
	含め:including
	伴われる:attached
	詰め込む:stuff
	利用元~空間:user-space
	包装する:wrapper a container that contains
	片:piece of
	置く:put
	書く:write
	-:unset
	-:branch
	改変せずに:unmodified
	側:side
	文書片:fragment
	渡-:pass
	ある時点:point in time
	返す:pick
	合致しないこと:mismatch
	^e:iframe
	^en:cure53
	^en:Internet Explorer
	:PLAINTEXT state
	:RCDATA state
	-:commonly known as the XML namespace

	●指示語

	(2):middle
	ほぼ:mostly
	どこでも:everywhere
	一群の:set of
	今:now
	後で:later
	~~上層:top-of
	当の:in question
	同じだけ:as much

●●original_id_map

●●mdn_urls

●●link_map


	●I
	■IDL
Exposed:~WEBIDL#Exposed
SecureContext:~WEBIDL#SecureContext

boolean:~WEBIDL#idl-boolean
undefined:~WEBIDL#idl-undefined
DOMString:~WEBIDL#idl-DOMString
record:~WEBIDL#idl-record
sequence:~WEBIDL#idl-sequence

E.TypeError:~WEBIDL#exceptiondef-typeerror

I.AttributeMatchList:#typedefdef-attributematchlist
I.Comment:~DOM4#comment
I.Document:~DOM4#document
I.DocumentFragment:~DOM4#documentfragment
I.Element:~DOM4#element
I.Attr:~DOM4#attr
I.DocumentType:~DOM4#documenttype
I.ProcessingInstruction:~DOM4#processinginstruction
I.HTMLBaseElement:~HEmetadata#htmlbaseelement
I.HTMLDataElement:~HEtextlevel#htmldataelement
I.HTMLEmbedElement:~HEembed#htmlembedelement
I.HTMLIFrameElement:~HEembed#htmliframeelement
I.HTMLObjectElement:~HEembed#htmlobjectelement
I.HTMLParamElement:~HTMLLS/obsolete.html#htmlparamelement
I.HTMLScriptElement:~HEscripting#htmlscriptelement
I.HTMLSlotElement:~HEscripting#htmlslotelement
I.HTMLTemplateElement:~HEscripting#htmltemplateelement
I.HTMLUnknownElement:~HTMLdom#htmlunknownelement
I.HTMLPortalElement:https://wicg.github.io/portals/
I.MutationObserver:~DOM4#mutationobserver

I.Sanitizer:#sanitizer
I.SanitizerConfig:#dictdef-sanitizerconfig
I.SetHTMLOptions:#dictdef-sethtmloptions
I.Text:~DOM4#text

m.new Sanitizer:#dom-sanitizer-sanitizer
mc.Sanitizer:#dom-sanitizer-sanitizer
	%config:#dom-sanitizer-sanitizer-config-config
m.sanitizer:#dom-sethtmloptions-sanitizer
m.sanitize:#dom-sanitizer-sanitize
	%input:#dom-sanitizer-sanitize-input-input
m.sanitizeFor:#dom-sanitizer-sanitizefor
	%element:#dom-sanitizer-sanitizefor-element-input-element
	%input:#dom-sanitizer-sanitizefor-element-input-input
m.getConfiguration:#dom-sanitizer-getconfiguration
m.getDefaultConfiguration:#dom-sanitizer-getdefaultconfiguration
m.setHTML:#dom-element-sethtml
	:#dom-element-sethtml-input-sanitizer
	%input:#dom-element-sethtml-input-options-input
	%options:#dom-element-sethtml-input-options-options
m.allowElements:#dom-sanitizerconfig-allowelements
m.blockElements:#dom-sanitizerconfig-blockelements
m.dropElements:#dom-sanitizerconfig-dropelements
m.allowAttributes:#dom-sanitizerconfig-allowattributes
m.dropAttributes:#dom-sanitizerconfig-dropattributes
m.allowCustomElements:#dom-sanitizerconfig-allowcustomelements
m.allowUnknownMarkup:#dom-sanitizerconfig-allowunknownmarkup
m.allowComments:#dom-sanitizerconfig-allowcomments

m.createDocumentFragment:~DOM4#dom-document-createdocumentfragment
m.innerHTML:~DOM-Parsing#dom-element-innerhtml
~template内容:~HEscripting#template-contents
	m.content:~HEscripting#dom-template-content
m.protocol:~HTMLlinks#dom-hyperlink-protocol

属する要素:~DOM4#concept-attribute-element
	m.ownerElement:~DOM4#dom-attr-ownerelement

	●tg
e.xmp:~HTMLobs#xmp
e.plaintext:~HTMLobs#plaintext
e.title:~HEmetadata#the-title-element
e.textarea:~HEforms#the-textarea-element
e.applet:~HTMLobs#applet
e.basefont:~HTMLobs#basefont
e.div:~HEgrouping#the-div-element
e.frame:~HTMLobs#frame
e.frameset:~HTMLobs#frameset
e.img:~HEimages#the-img-element
e.noembed:~HTMLobs#noembed
e.noframes:~HTMLobs#noframes
	e.nolayer:~HTMLobs#nolayer
e.noscript:~HEscripting#the-noscript-element
e.object:~HEembed#the-object-element
e.slot:~HEscripting#the-slot-element
e.table:~HEtables#the-table-element
e.td:~HEtables#the-td-element
e.template:~HEscripting#the-template-element

a.action:~HTMLforms#attr-fs-action
a.formaction:~HTMLforms#attr-fs-formaction
a.slot:~HTMLdom#attr-slot
a.data-:~HTMLdom#custom-data-attribute
a.allowpaymentrequest:https://www.w3.org/TR/payment-request/


	●用語

V.to_node:#_to_node

許容する要素~群:#element-allow-list
阻止する要素~群:#element-block-list
落とす要素~群:#element-drop-list
許容する属性~群:#attribute-allow-list
落とす属性~群:#attribute-drop-list
	~commentを許容する~option:#allow-comments-option
	~commentを許容するか:#allow-comments-option
	~custom要素を許容するか:#allow-custom-elements-option
	~custom要素を許容する~option:#dom-sanitizerconfig-allowcustomelements
	未知な~markupを許容する~option:#dom-sanitizerconfig-allowunknownmarkup
属性~照合-~map:#attribute-match-list
	属性~照合-~list:#attribute-match-list
要素は名前~群に合致しているか？:#element-matches-an-element-name
属性は照合-~mapに合致しているか？:#attribute-matches-an-attribute-match-list
	elm.合致して:#element-matches-an-element-name
	attr.合致して:#attribute-matches-an-attribute-match-list

~sanitizeする:#sanitize
要素~用に~sanitizeする:#sanitizefor
	~sanitizeFor:#sanitizefor
要素~用に~sanitizeして設定する:#sanitizeandset
	~sanitizeAndSet:#sanitizeandset
~Sanitizerを初期化する:#create-a-sanitizer
	~Sanitizerを作成する:#create-a-sanitizer
環境設定0を~queryする:#query-the-sanitizer-config
文書片を作成する:#create-a-document-fragment
文書片を~sanitizeする:#sanitize-a-document-fragment
~nodeを~sanitizeする:#sanitize-a-node
~funkyな要素を取扱う:#handle-funky-elements
~sanitizeする動作:#sanitize-action
環境設定~用の要素~名:#_element-name-for-config
要素~種類:#element-kind
属性~種類:#attribute-kind
要素~用の~sanitize動作:#sanitize-action-for-an-element
属性~用の~sanitize動作:#sanitize-action-for-an-attribute

~baseline環境設定:#_baseline-configuration
要素~用の~baseline許容-~list:#baseline-element-allow-list
属性~用の~baseline許容-~list:#baseline-attribute-allow-list
既定の環境設定:#default-configuration
環境設定~辞書:#configuration-dictionary

	●用語（外部／補完
	~EACH:~INFRA#list-iterate
sub.大小無視:~INFRA#ascii-case-insensitive
~ASCII大小無視:~INFRA#ascii-case-insensitive
文字列:~INFRA#string
~map:~INFRA#ordered-map
~list:~INFRA#list
~size:~INFRA#list-size
~HTML名前空間:~INFRA#html-namespace

構築子~手続き:~WEBIDL#constructor-steps

~HTML構文解析器:~HTMLparsing#html-parser
	~HTML構文解析~algo:~HTMLparsing#parsing
外来な要素:~HTMLwriting#foreign-elements

素片を構文解析する:~DOM-Parsing#dfn-fragment-parsing-algorithm
https://w3c.github.io/DOM-Parsing/#dfn-fragment-parsing-algorithm

~custom要素:~HEcustom#custom-element

文書:~DOM4#concept-document
文書片:~DOM4#_concept-documentfragment
文書~要素:~DOM4#document-element
	m.documentElement:~DOM4#dom-document-documentelement
要素:~DOM4#concept-element
名前空間:~DOM4#concept-element-namespace
~nodeを除去する:~DOM4#concept-node-remove
子~群:~DOM4#concept-tree-child
親:~DOM4#concept-node-insert
全~内容を~nodeで置換する:~DOM4#concept-node-replace-all
子を~nodeに置換する:~DOM4#concept-node-replace
属性~list:~DOM4#concept-element-attribute
属性を除去する:~DOM4#concept-element-attributes-remove
~nodeを~cloneする:~DOM4#concept-node-clone
要素を作成する:~DOM4#concept-create-element
要素~interface:~DOM4#concept-element-interface
広義~子孫:~DOM4#concept-tree-inclusive-descendant
子孫:~DOM4#concept-tree-descendant
~node:~DOM4#boundary-point-node
親:~DOM4#concept-tree-parent
~tree順序:~DOM4#concept-tree-order
妥当な~custom要素~名:~HEcustom#valid-custom-element-name
~nodeを付加する:~DOM4#concept-node-append
局所-名:~DOM4#concept-element-local-name
attr.局所-名:~DOM4#concept-attribute-local-name
attr.名前空間:~DOM4#concept-attribute-namespace
~node文書:~DOM4#concept-node-document
接続されて:~DOM4#connected

~URL:~URL1#concept-url
	url.~scheme:~URL1#concept-url-scheme
妥当な~URL文字列:~URL1#valid-url-string

~event~handler内容~属性:~WAPI#event-handler-content-attributes
	~event~handler属性:~WAPI#event-handler-attributes


	●他
	:~HTMLparsing#plaintext-state
	:~HTMLparsing#rcdata-state
	:~HTMLparsing#parsing-main-inbody
	https://www.w3.org/community/about/agreements/cla/
	https://www.w3.org/community/
	https://www.w3.org/community/wicg/
	https://html.spec.whatwg.org/#non-conforming-features
	https://github.com/google/security-research-pocs/tree/master/script-gadgets
	#constants
	https://msdn.microsoft.com/en-us/library/cc848922(v=vs.85).aspx

●●ref_data


●●ref_normative

[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[DEFAULTS]
    ＜Sanitizer API Defaults＞. URL: https://github.com/WICG/sanitizer-api/blob/main/resources/defaults-derivation.html
[DOMPURIFY]
    ＜DOMPurify＞. URL: https://github.com/cure53/DOMPurify
[MXSS]
    ＜mXSS Attacks: Attacking well-secured Web-Applications by using innerHTML Mutations＞. URL: https://cure53.de/fp170.pdf
[MXSS1]
    ＜Mutation XSS via namespace confusion＞. URL: https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass/
[MXSS2]
    ＜CVE-2020-6802 Write-up＞. URL: https://www.checkmarx.com/blog/technical-blog/vulnerabilities-discovered-in-mozilla-bleach/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/


●●trans_metadata
<p>
~THIS_PAGEは、
~W3Cにより編集者草案（ Draft Community Group Report ）として公開された
<a href="~SPEC_URL">HTML Sanitizer API</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

このバージョン
	https://wicg.github.io/sanitizer-api/
課題追跡
	<a href="https://github.com/WICG/sanitizer-api/issues/">GitHub</a>

編集
	<a href="https://frederik-braun.com">Frederik Braun</a> (Mozilla) <a class="u-email email" href="mailto:fbraun@mozilla.com">fbraun@mozilla.com</a>
	<a href="https://cure53.de">Mario Heiderich</a> (Cure53) <a href="mailto:mario@cure53.de">mario@cure53.de</a>
	<a href="https://www.google.com">Daniel Vogelheim</a> (Google LLC) <a href="mailto:vogelheim@google.com">vogelheim@google.com</a>

テスト一式
	https://wpt.fyi/results/sanitizer-api/
commit 履歴
	https://github.com/WICG/sanitizer-api/commits/main

</script>
<body>

<!--%parts -->
<template id="_persisted_parts">

<pre
	id="_dgm-baseline-elements"
	class="include-code"
>
[
  "a",
  "abbr",
  "acronym",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "basefont",
  "bdi",
  "bdo",
  "bgsound",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "cite",
  "code",
  "col",
  "colgroup",
  "command",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "font",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "image",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "layer",
  "legend",
  "li",
  "link",
  "listing",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "meta",
  "meter",
  "nav",
  "nobr",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "picture",
  "plaintext",
  "popup",
  "portal",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "section",
  "select",
  "selectmenu",
  "slot",
  "small",
  "source",
  "span",
  "strike",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "tt",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "xmp"
]
</pre>

<pre
	id="_dgm-baseline-attributes"
	class="include-code"
>
[
  "abbr",
  "accept",
  "accept-charset",
  "accesskey",
  "action",
  "align",
  "alink",
  "allow",
  "allowfullscreen",
  "allowpaymentrequest",
  "alt",
  "anchor",
  "archive",
  "as",
  "async",
  "autocapitalize",
  "autocomplete",
  "autocorrect",
  "autofocus",
  "autopictureinpicture",
  "autoplay",
  "axis",
  "background",
  "behavior",
  "bgcolor",
  "border",
  "bordercolor",
  "capture",
  "cellpadding",
  "cellspacing",
  "challenge",
  "char",
  "charoff",
  "charset",
  "checked",
  "cite",
  "class",
  "classid",
  "clear",
  "code",
  "codebase",
  "codetype",
  "color",
  "cols",
  "colspan",
  "compact",
  "content",
  "contenteditable",
  "controls",
  "controlslist",
  "conversiondestination",
  "coords",
  "crossorigin",
  "csp",
  "data",
  "datetime",
  "declare",
  "decoding",
  "default",
  "defer",
  "dir",
  "direction",
  "dirname",
  "disabled",
  "disablepictureinpicture",
  "disableremoteplayback",
  "disallowdocumentaccess",
  "download",
  "draggable",
  "elementtiming",
  "enctype",
  "end",
  "enterkeyhint",
  "event",
  "exportparts",
  "face",
  "for",
  "form",
  "formaction",
  "formenctype",
  "formmethod",
  "formnovalidate",
  "formtarget",
  "frame",
  "frameborder",
  "headers",
  "height",
  "hidden",
  "high",
  "href",
  "hreflang",
  "hreftranslate",
  "hspace",
  "http-equiv",
  "id",
  "imagesizes",
  "imagesrcset",
  "importance",
  "impressiondata",
  "impressionexpiry",
  "incremental",
  "inert",
  "inputmode",
  "integrity",
  "invisible",
  "is",
  "ismap",
  "keytype",
  "kind",
  "label",
  "lang",
  "language",
  "latencyhint",
  "leftmargin",
  "link",
  "list",
  "loading",
  "longdesc",
  "loop",
  "low",
  "lowsrc",
  "manifest",
  "marginheight",
  "marginwidth",
  "max",
  "maxlength",
  "mayscript",
  "media",
  "method",
  "min",
  "minlength",
  "multiple",
  "muted",
  "name",
  "nohref",
  "nomodule",
  "nonce",
  "noresize",
  "noshade",
  "novalidate",
  "nowrap",
  "object",
  "open",
  "optimum",
  "part",
  "pattern",
  "ping",
  "placeholder",
  "playsinline",
  "policy",
  "poster",
  "preload",
  "pseudo",
  "readonly",
  "referrerpolicy",
  "rel",
  "reportingorigin",
  "required",
  "resources",
  "rev",
  "reversed",
  "role",
  "rows",
  "rowspan",
  "rules",
  "sandbox",
  "scheme",
  "scope",
  "scopes",
  "scrollamount",
  "scrolldelay",
  "scrolling",
  "select",
  "selected",
  "shadowroot",
  "shadowrootdelegatesfocus",
  "shape",
  "size",
  "sizes",
  "slot",
  "span",
  "spellcheck",
  "src",
  "srcdoc",
  "srclang",
  "srcset",
  "standby",
  "start",
  "step",
  "style",
  "summary",
  "tabindex",
  "target",
  "text",
  "title",
  "topmargin",
  "translate",
  "truespeed",
  "trusttoken",
  "type",
  "usemap",
  "valign",
  "value",
  "valuetype",
  "version",
  "virtualkeyboardpolicy",
  "vlink",
  "vspace",
  "webkitdirectory",
  "width",
  "wrap"
]
</pre>

<pre
	id="_dgm-default-configuration-dictionary"
	class="include-code"
>
{
  "allowCustomElements": false,
  "allowUnknownMarkup": false,
  "allowElements": [
    "a",
    "abbr",
    "acronym",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "bdi",
    "bdo",
    "bgsound",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "layer",
    "legend",
    "li",
    "link",
    "listing",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "meta",
    "meter",
    "nav",
    "nobr",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "picture",
    "popup",
    "pre",
    "progress",
    "q",
    "rb",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "section",
    "select",
    "selectmenu",
    "small",
    "source",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr"
  ],
  "allowAttributes": {
    "abbr": [
      "*"
    ],
    "accept": [
      "*"
    ],
    "accept-charset": [
      "*"
    ],
    "accesskey": [
      "*"
    ],
    "action": [
      "*"
    ],
    "align": [
      "*"
    ],
    "alink": [
      "*"
    ],
    "allow": [
      "*"
    ],
    "allowfullscreen": [
      "*"
    ],
    "alt": [
      "*"
    ],
    "anchor": [
      "*"
    ],
    "archive": [
      "*"
    ],
    "as": [
      "*"
    ],
    "async": [
      "*"
    ],
    "autocapitalize": [
      "*"
    ],
    "autocomplete": [
      "*"
    ],
    "autocorrect": [
      "*"
    ],
    "autofocus": [
      "*"
    ],
    "autopictureinpicture": [
      "*"
    ],
    "autoplay": [
      "*"
    ],
    "axis": [
      "*"
    ],
    "background": [
      "*"
    ],
    "behavior": [
      "*"
    ],
    "bgcolor": [
      "*"
    ],
    "border": [
      "*"
    ],
    "bordercolor": [
      "*"
    ],
    "capture": [
      "*"
    ],
    "cellpadding": [
      "*"
    ],
    "cellspacing": [
      "*"
    ],
    "challenge": [
      "*"
    ],
    "char": [
      "*"
    ],
    "charoff": [
      "*"
    ],
    "charset": [
      "*"
    ],
    "checked": [
      "*"
    ],
    "cite": [
      "*"
    ],
    "class": [
      "*"
    ],
    "classid": [
      "*"
    ],
    "clear": [
      "*"
    ],
    "code": [
      "*"
    ],
    "codebase": [
      "*"
    ],
    "codetype": [
      "*"
    ],
    "color": [
      "*"
    ],
    "cols": [
      "*"
    ],
    "colspan": [
      "*"
    ],
    "compact": [
      "*"
    ],
    "content": [
      "*"
    ],
    "contenteditable": [
      "*"
    ],
    "controls": [
      "*"
    ],
    "controlslist": [
      "*"
    ],
    "conversiondestination": [
      "*"
    ],
    "coords": [
      "*"
    ],
    "crossorigin": [
      "*"
    ],
    "csp": [
      "*"
    ],
    "data": [
      "*"
    ],
    "datetime": [
      "*"
    ],
    "declare": [
      "*"
    ],
    "decoding": [
      "*"
    ],
    "default": [
      "*"
    ],
    "defer": [
      "*"
    ],
    "dir": [
      "*"
    ],
    "direction": [
      "*"
    ],
    "dirname": [
      "*"
    ],
    "disabled": [
      "*"
    ],
    "disablepictureinpicture": [
      "*"
    ],
    "disableremoteplayback": [
      "*"
    ],
    "disallowdocumentaccess": [
      "*"
    ],
    "download": [
      "*"
    ],
    "draggable": [
      "*"
    ],
    "elementtiming": [
      "*"
    ],
    "enctype": [
      "*"
    ],
    "end": [
      "*"
    ],
    "enterkeyhint": [
      "*"
    ],
    "event": [
      "*"
    ],
    "exportparts": [
      "*"
    ],
    "face": [
      "*"
    ],
    "for": [
      "*"
    ],
    "form": [
      "*"
    ],
    "formaction": [
      "*"
    ],
    "formenctype": [
      "*"
    ],
    "formmethod": [
      "*"
    ],
    "formnovalidate": [
      "*"
    ],
    "formtarget": [
      "*"
    ],
    "frame": [
      "*"
    ],
    "frameborder": [
      "*"
    ],
    "headers": [
      "*"
    ],
    "height": [
      "*"
    ],
    "hidden": [
      "*"
    ],
    "high": [
      "*"
    ],
    "href": [
      "*"
    ],
    "hreflang": [
      "*"
    ],
    "hreftranslate": [
      "*"
    ],
    "hspace": [
      "*"
    ],
    "http-equiv": [
      "*"
    ],
    "id": [
      "*"
    ],
    "imagesizes": [
      "*"
    ],
    "imagesrcset": [
      "*"
    ],
    "importance": [
      "*"
    ],
    "impressiondata": [
      "*"
    ],
    "impressionexpiry": [
      "*"
    ],
    "incremental": [
      "*"
    ],
    "inert": [
      "*"
    ],
    "inputmode": [
      "*"
    ],
    "integrity": [
      "*"
    ],
    "invisible": [
      "*"
    ],
    "is": [
      "*"
    ],
    "ismap": [
      "*"
    ],
    "keytype": [
      "*"
    ],
    "kind": [
      "*"
    ],
    "label": [
      "*"
    ],
    "lang": [
      "*"
    ],
    "language": [
      "*"
    ],
    "latencyhint": [
      "*"
    ],
    "leftmargin": [
      "*"
    ],
    "link": [
      "*"
    ],
    "list": [
      "*"
    ],
    "loading": [
      "*"
    ],
    "longdesc": [
      "*"
    ],
    "loop": [
      "*"
    ],
    "low": [
      "*"
    ],
    "lowsrc": [
      "*"
    ],
    "manifest": [
      "*"
    ],
    "marginheight": [
      "*"
    ],
    "marginwidth": [
      "*"
    ],
    "max": [
      "*"
    ],
    "maxlength": [
      "*"
    ],
    "mayscript": [
      "*"
    ],
    "media": [
      "*"
    ],
    "method": [
      "*"
    ],
    "min": [
      "*"
    ],
    "minlength": [
      "*"
    ],
    "multiple": [
      "*"
    ],
    "muted": [
      "*"
    ],
    "name": [
      "*"
    ],
    "nohref": [
      "*"
    ],
    "nomodule": [
      "*"
    ],
    "nonce": [
      "*"
    ],
    "noresize": [
      "*"
    ],
    "noshade": [
      "*"
    ],
    "novalidate": [
      "*"
    ],
    "nowrap": [
      "*"
    ],
    "object": [
      "*"
    ],
    "open": [
      "*"
    ],
    "optimum": [
      "*"
    ],
    "part": [
      "*"
    ],
    "pattern": [
      "*"
    ],
    "ping": [
      "*"
    ],
    "placeholder": [
      "*"
    ],
    "playsinline": [
      "*"
    ],
    "policy": [
      "*"
    ],
    "poster": [
      "*"
    ],
    "preload": [
      "*"
    ],
    "pseudo": [
      "*"
    ],
    "readonly": [
      "*"
    ],
    "referrerpolicy": [
      "*"
    ],
    "rel": [
      "*"
    ],
    "reportingorigin": [
      "*"
    ],
    "required": [
      "*"
    ],
    "resources": [
      "*"
    ],
    "rev": [
      "*"
    ],
    "reversed": [
      "*"
    ],
    "role": [
      "*"
    ],
    "rows": [
      "*"
    ],
    "rowspan": [
      "*"
    ],
    "rules": [
      "*"
    ],
    "sandbox": [
      "*"
    ],
    "scheme": [
      "*"
    ],
    "scope": [
      "*"
    ],
    "scopes": [
      "*"
    ],
    "scrollamount": [
      "*"
    ],
    "scrolldelay": [
      "*"
    ],
    "scrolling": [
      "*"
    ],
    "select": [
      "*"
    ],
    "selected": [
      "*"
    ],
    "shadowroot": [
      "*"
    ],
    "shadowrootdelegatesfocus": [
      "*"
    ],
    "shape": [
      "*"
    ],
    "size": [
      "*"
    ],
    "sizes": [
      "*"
    ],
    "slot": [
      "*"
    ],
    "span": [
      "*"
    ],
    "spellcheck": [
      "*"
    ],
    "src": [
      "*"
    ],
    "srcdoc": [
      "*"
    ],
    "srclang": [
      "*"
    ],
    "srcset": [
      "*"
    ],
    "standby": [
      "*"
    ],
    "start": [
      "*"
    ],
    "step": [
      "*"
    ],
    "style": [
      "*"
    ],
    "summary": [
      "*"
    ],
    "tabindex": [
      "*"
    ],
    "target": [
      "*"
    ],
    "text": [
      "*"
    ],
    "title": [
      "*"
    ],
    "topmargin": [
      "*"
    ],
    "translate": [
      "*"
    ],
    "truespeed": [
      "*"
    ],
    "trusttoken": [
      "*"
    ],
    "type": [
      "*"
    ],
    "usemap": [
      "*"
    ],
    "valign": [
      "*"
    ],
    "value": [
      "*"
    ],
    "valuetype": [
      "*"
    ],
    "version": [
      "*"
    ],
    "virtualkeyboardpolicy": [
      "*"
    ],
    "vlink": [
      "*"
    ],
    "vspace": [
      "*"
    ],
    "webkitdirectory": [
      "*"
    ],
    "width": [
      "*"
    ],
    "wrap": [
      "*"
    ]
  }
}
</pre>

</template>

<header>
	<hgroup>
<h1>HTML Sanitizer API</h1>
<!--
<h2>Draft Community Group Report</h2>
 -->
	</hgroup>
<details><summary>©</summary>
<small class="copyright" lang="en">
<a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2022 the Contributors to the HTML Sanitizer API Specification, published by the <a href="https://www.w3.org/community/wicg/">Web Platform Incubator Community Group</a> under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>.
A human-readable <a href="https://www.w3.org/community/about/agreements/cla-deed/">summary</a> is available.
</small>
</details>

</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は、
一群の~APIを指定する
— それは、
信用-済みでない~HTML入力を［
文書の~DOMの中への安全な挿入~用に~sanitizeする（無毒化する）
］ことを開発者に許容する。
◎
This document specifies a set of APIs which allow developers to take untrusted HTML input and sanitize it for safe insertion into a document’s DOM.
</p>

	</section>
	<section id="status">
◎位置付け

<p>
この仕様は、
<a lang="en" href="https://www.w3.org/community/wicg/">Web Platform Incubator Community Group</a>
により公表されました。
それは、
`W3C Standard^en でも `W3C Standards Track^en でもありません。
<a lang="en" href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>
の下では、
ある制限-付き `opt-out^en があり，他の条件が適用されることに注意されたし。
詳しくは
<a lang="en" href="https://www.w3.org/community/">W3C Community and Business Groups</a>
について学習されたし。
◎
This specification was published by the Web Platform Incubator Community Group. It is not a W3C Standard nor is it on the W3C Standards Track. Please note that under the W3C Community Contributor License Agreement (CLA) there is a limited opt-out and other conditions apply. Learn more about W3C Community and Business Groups.
</p>

	</section>

<main>

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
~web~appは、
~client側で，~HTMLを成す文字列で作業する必要があることが多い
— たぶん［
~client側における~template化による解決策,
あるいは利用者が生成した内容の具現化
］の一部として, 等々。
それを安全な仕方で行うのは困難である
— ［
文字列を~~連結して，`要素$の `innerHTML$m の中へ詰め込む
］ような素朴な~approachは、［
いくつかの期待されない仕方で~JSを実行させ得る
］ので，~riskをはらんでいる。
◎
Web applications often need to work with strings of HTML on the client side, perhaps as part of a client-side templating solution, perhaps as part of rendering user generated content, etc. It is difficult to do so in a safe way. The naive approach of joining strings together and stuffing them into an Element's innerHTML is fraught with risk, as it can cause JavaScript execution in a number of unexpected ways.
</p>

<p>
`DOMPURIFY$r の様な~libraryは、
文字列を挿入する前に，［
それを注意深く構文解析して~DOMを構築してから、
許容-~listを通して，その~memberたちを~filterして~sanitizeする
］ことにより，この問題を管理しようと試みる。
これは、
脆い~approachであることが立証された
— ~webに公開された【~libraryの】構文解析~APIは、
文字列を “本物の” ~DOM内に~HTMLとして実際に具現化するとき，常に［
~browserの挙動に適理な仕方で対応付ける
］とは限らないので。
さらには，~libraryは、［
時間~越しに変化していく~browserの挙動
］の~~上層にあることを保つ必要がある
— それまで安全だったものは、
~platform~levelの新たな特能に基づいて時限爆弾に転化し得るので。
◎
Libraries like [DOMPURIFY] attempt to manage this problem by carefully parsing and sanitizing strings before insertion, by constructing a DOM and filtering its members through an allow-list. This has proven to be a fragile approach, as the parsing APIs exposed to the web don’t always map in reasonable ways to the browser’s behavior when actually rendering a string as HTML in the "real" DOM. Moreover, the libraries need to keep on top of browsers' changing behavior over time; things that once were safe may turn into time-bombs based on new platform-level features.
</p>

<p>
~browserは、
~codeをいつ実行しようとするかについて，よく知る立場にある。
利用元~空間の~libraryは，次により改善でき、
この文書は，まさにそれを目指す~APIを要旨する
⇒
任意な文字列から安全な方式で~HTMLを具現化するにあたって，次を可能にする
⇒
それを行う方法を~browserに教えること、
および［
~browserによる自前の［
構文解析器の実装
］が変化するに伴い［
保守される／更新される
］見込みがずっと高い仕方で，それを行うこと
◎
The browser has a fairly good idea of when it is going to execute code. We can improve upon the user-space libraries by teaching the browser how to render HTML from an arbitrary string in a safe manner, and do so in a way that is much more likely to be maintained and updated along with the browser’s own changing parser implementation. This document outlines an API which aims to do just that.
</p>

		<section id="goals">
<h3 title="Goals">1.1. 目標</h3>

<ul>
	<li>
次により，~DOMに基づく~XSS攻撃の~riskを軽減する
⇒
~HTMLを取扱うための［
利用元により制御される仕組み
］を開発者に供して、
注入の際に直な~script実行を防止する
◎
Mitigate the risk of DOM-based cross-site scripting attacks by providing developers with mechanisms for handling user-controlled HTML which prevent direct script execution upon injection.
</li>
	<li>
~HTML出力を現在の~UAの中で安全に利用できるようにする
— ~UAの［
~HTMLに対する現在の理解
］を織り込む下で。
◎
Make HTML output safe for use within the current user agent, taking into account its current understanding of HTML.
</li>
	<li>
対象になる［
要素や属性
］の既定の集合を上書きすることを，開発者に許容する。
ある種の［
要素／属性
］を追加することは、
`~script~gadget攻撃＠https://github.com/google/security-research-pocs/tree/master/script-gadgets$を防止し得る。
◎
Allow developers to override the defaults set of elements and attributes. Adding certain elements and attributes can prevent script gadget attacks.
</li>
</ul>

		</section>
		<section id="api-summary">
<h3 title="API Summary">1.2. ~APIの要約</h3>

<div class="example">

<pre class="lang-js">
let %s = new Sanitizer();

/* <span class="comment">
入力~dataは、
~treeを成す~DOM~node群として すでに可用な事例：
◎
Case: The input data is available as a tree of DOM nodes.
</span> */
let %userControlledTree = ...;
%element.replaceChildren(%s.sanitize(%userControlledTree));

/* <span class="comment">
入力は文字列として可用であり，
どの要素に挿入するかも知っている事例：
◎
Case: The input is available as a string, and we know the element to insert it into:
</span> */
let %userControlledInput = "&amp;lt;img src=x onerror=alert(1)//&amp;gt;";
%element.setHTML(%userControlledInput, %s);

/* <span class="comment">
入力は文字列として可用であり，
どの型の要素に挿入するかも知っていて，
最終的に挿入することになるが、
今は挿入できないか，そうしたくない事例：
◎
Case: The input is available as a string, and we know which type of element we will eventually insert it to, but can’t or don’t want to perform the insertion now:
</span> */
let %forDiv = %s.sanitizeFor("div", %userControlledInput, {sanitizer: %s});
/* <span class="comment">
後で：
◎
Later:
</span> */
document.querySelector(``^${%forDiv.localName}#target``^).replaceChildren(...%forDiv.childNodes);
</pre>
</div>

		</section>
		<section id="strings">
<h3 title="The Trouble With Strings">1.3. 文字列に伴われる~trouble</h3>

<p>
多くの~HTML~sanitizer~libraryは，文字列を文字列へ~~変換する~APIに基づくが、
この~APIは，そのような~methodを提供することはない。
この下位節では、
その理由と，それによる含意を~Sanitizer~API用に説明する。
◎
Many HTML sanitizer libraries are based on string-to-string APIs, while this API does not offer such a method. This sub-section explains the reasons and implications for the Sanitizer API.
</p>

<p>
文字列を~node群が成す~tree（または ある`文書片$）へ変換するためには、
それを構文解析する必要がある。
`~HTML構文解析~algo＠~HTMLparsing#parsing$は、
~HTMLの構文解析がどう働くかを注意深く指定する。
この~algoのふるまいは、
その構文解析-用の文脈を与える現在の~nodeに依存する。
すなわち、
同じ文字列であっても，得られる構文解析-~treeは、
構文解析される文脈を成す~HTML~nodeに応じて異なり得る。
◎
To convert a string into a tree of nodes (or a fragment), it needs to be parsed. The HTML parsing algorithm carefully specifies how parsing HTML works. This parsing algorithm is dependent on the current node as its parsing context. That is, the same string parsed in the context of different HTML nodes will yield different parse trees.
</p>

<div class="example">

<p>
異なる文脈~内の文字列 `&lt;em&gt;bla^l ：
</p>

<table><thead>
<tr><th>文脈
<th>入力
<th>結果
<tbody>

<tr><td>`div$e
<td>`&lt;div&gt;&lt;em&gt;bla&lt;/div&gt;^l
<td>`&lt;div&gt;&lt;em&gt;bla&lt;/em&gt;&lt;/div&gt;^c

<tr><td>`textarea$e
<td>`&lt;textarea&gt;&lt;em&gt;bla&lt;/textarea&gt;^l
<td>`&lt;textarea&gt;&amp;lt;em&amp;gt;bla&lt;/textarea&gt;^c
</table>
◎
The string &lt;em&gt;bla in &lt;div&gt; and &lt;textarea&gt; context.
• &lt;div&gt;&lt;em&gt;bla&lt;/div&gt; ⇨ &lt;div&gt;&lt;em&gt;bla&lt;/em&gt;&lt;/div&gt;
• &lt;textarea&gt;&lt;em&gt;bla&lt;/textarea&gt; ⇨ &lt;textarea&gt;&amp;lt;em&amp;gt;bla&lt;/textarea&gt;
</div>

<div class="example">
<p>
異なる文脈~内の~table~cell
</p>

<table><thead>
<tr><th>文脈
<th>入力
<th>結果
<tbody>

<tr><td>`table$e
<td>`&lt;table&gt;&lt;td&gt;text&lt;/table&gt;^l
<td>`&lt;table&gt;&lt;td&gt;text&lt;/table&gt;^c

<tr><td>`div$e
<td>`&lt;div&gt;&lt;td&gt;text&lt;/div&gt;^l
<td>`&lt;div&gt;text&lt;/div&gt;^c
</table>

◎
A table cell in &lt;table&gt; and non-table (&lt;div&gt;) context.
• &lt;table&gt;&lt;td&gt;text&lt;/table&gt; ⇨ &lt;table&gt;&lt;td&gt;text&lt;/table&gt;
• &lt;div&gt;&lt;td&gt;text&lt;/div&gt; ⇨ &lt;div&gt;text&lt;/div&gt;
</div>

<p>
これらの相違は、
~siteの~sanitization策の中に~bugが潜むのを許容し得る
— それは、
`~mXSS＠#mutated-xss$と呼ばれる，ある~classの~XSS攻撃により悪用され得る（されてきた）。
これらの攻撃は、
結局の所，構文解析~文脈の混同に依存する。
例えば，開発者が［
文字列を ある（構文解析）文脈~内で~sanitizeした結果の文字列
］を異なる文脈
— 異なる何かに解釈される文脈 —
内で適用するとき。
◎
These differences can allow bugs to creep into a site’s sanitization strategy, which can (and have been) exploited by a class of XSS-style attacks called mXSS. These attacks ultimately depend on confusions of the parsing context, for example when a developer will sanitize a string in one (parsing) context, while then applying the resulting string in a different context, where it will be interpreted differently.
</p>

【！class="example"】
<p class="note">注記：
現実にある~libraryにおける~mXSSの例は
`MXSS1$r, `MXSS2$r
にて見出せる。
これらの報告をとり挙げたのは、
容易に読めるために過ぎない
— 類似な報告は、
~HTML構文解析を処する他のどの~toolにも，およそあることを~~強調したい。
◎
Two mXSS-style examples in real-world libraries can be found in [MXSS1]] and [MXSS2]. We’d like to stress that we picked these reports for their ease of reading. There are similar reports for pretty much every other tools that deals with HTML parsing.
</p>

<p>
この攻撃~classは，［
~sanitizationが`生じた後^emにおける，結果の文字列の特定0の用法
］に依存するので、
この~APIが利用者を保護する能力は，【そのような用法が生じない所までに】制限される。
その結果、
~Sanitizer~APIは，次の原則に従う
⇒
~Sanitizer~APIが文字列から~DOM（下位-）~tree［
へ構文解析する／から直列化する【！unparse】
］ときは、［
当の演算は、
暗黙な正しい構文解析-文脈がある所で，それを行う
］ようになるか，または［
開発者が構文解析-文脈を給して，所与の文脈を結果の引数にて維持することを要求する
］ことになる。
◎
Since this attack class depends on a particular usage of the string after the sanitization has occurred, the API itself has only limited capability to protect its users. As a result, the Sanitizer API follows the following principle:
◎
Whenever the Sanitzer API parses or unparses a DOM (sub-)tree to or from a string, it will either do so in a fashion where the correct parse context is implied by the operation; or it will require a parse context to be supplied by the developer and will retain the given context in the resulting argument.＼
</p>

<p>
言い換えれば，~Sanitizer~APIは、
以前に構文解析~文脈が［
給されたなら，それを忘れることはない／
給されなかったなら，いかなる構文解析~文脈も前提にしない
］。
◎
In other words, the Sanitzer API will never assume a parsing context, or disappear a parsing context that has been supplied earlier.
</p>

			<section id="string-context-case-1">
<h4 title="Case 1: Sanitizing With Nodes, Only.">1.3.1. 事例 1： ~node群の~sanitize法</h4>

<p>
当の利用者~dataは，すでに~DOM~node群
— 例えば，ある~frame内の`文書$ —
として可用である場合、
~Sanitizerは容易に利用できる：
◎
If the user data in question is already available as DOM nodes - for example a Document instance in a frame - then the Sanitizer can be easily used:
</p>

<div class="example">

<pre class="lang-js">
const %sanitizer = new Sanitizer( ... );  /* <span class="comment">
新たな `Sanitizer^I
◎
Our Sanitizer;
</span> */

/* <span class="comment">
`id^a に `userFrame^l を伴う `iframe^e がある
— 関心事は、
その内容である。
◎
There is an iframe with id "userFrame" whose content we are interested in.
</span> */
const %user_tree = document.getElementById("userFrame").contentWindow.document;
const %sanitized = %sanitizer.sanitize(user_tree);
</pre>
</div>

<p class="note">注記：
~HTML文字列の構文解析は、
様々な副作用
— ~network要請や~scriptを実行する様なそれ —
を伴い得る。
素朴に構文解析した場合
— 例：`接続されて$いない要素の `innerHTML$m に文字列をアテガうなど —
これらを依拠-可能に防止しないことになる。
したがって，~sanitizeされる利用者~dataが元々は文字列を形成する場合、
以下に挙げるいずれかの事例へ進むことを推奨する。
◎
Note: Parsing an HTML string can have various side-effects, like network requests or executing scripts. Naively parsing these, e.g. by assigning a string to .innerHTML of an unconnected element, will not reliably prevent these. Therefore, if the user data to be sanitized is originally in string form, we recommend to go with one of the following cases.
</p>

			</section>
			<section id="string-context-case-2">
<h4 title="Case 2: Sanitizing a String with Implied Context.">1.3.2. 事例 2：暗黙な文脈を伴う文字列の~sanitize法</h4>

<p>
当の利用者~dataは文字列の形で可用で，
~sanitizeされた下位treeを~DOMの中へ直に挿入したいと望む場合、
次のようにして行える：
◎
If the user data is available in string form and we wish to directly insert the sanitized subtree into the DOM, we can do so as follows:
</p>

<div class="example">

<pre class="lang-js">
const %user_string = "...";  /* <span class="comment">
利用者からの文字列
◎
The user string.
</span> */
const %sanitizer = new Sanitizer( ... );  /* <span class="comment">
新たな `Sanitizer^I
◎
Our Sanitizer;
</span> */

/* <span class="comment">
%user_string 内の~HTMLを［
`id^a に `target^l を伴う~target要素
］の中へ挿入する
— すなわち、
~XSS~riskを伴わないことを除けば，
<code>%target.innerHTML = %value</code>
に等価になる —
ことが求まれるなら：
◎
We want to insert the HTML in user_string into a target element with id target. That is, we want the equivalent of target.innerHTML = value, except without the XSS risks.
</span> */
document.getElementById("target").setHTML(%user_string, {sanitizer: %sanitizer});
</pre>
</div>

			</section>
			<section id="string-context-case-3">
<h4 title="Case 3: Sanitizing a String with a Given Context.">1.3.3. 事例 3： 所与の文脈を伴う文字列の~sanitize法</h4>

<p>
利用者~dataは文字列の形で可用で、
開発者は それを今すぐ~sanitizeしたいが，その結果は後で~DOMに適用したいと望む場合、
利用される文脈について~Sanitizerに伝える必要がある。
文脈の混同を防止するため、
結果は［
結果【の~DOM~tree】, 構文解析-文脈
］の両者を包装する容器になる。
この容器は、
簡便に，~node自身としてすでに存在する
【~Sanitizerに伝えた要素~型の新たな~nodeとして，~Sanitizerが作成することになる】。
◎
If the user data is available in string form and the developer wishes to sanitize it now, but apply the result to the DOM later, then the Sanitizer must be informed about the context that it will be used. To prevent context confusion the result is wrapper a container that contains both the result and also the parse context. Conveniently, this container already exists, and it is the node itself!
</p>

<div class="example">

<pre class="lang-js">
/* <span class="comment">
利用者~入力を成す ある種の片は、
当の~pageの複数の要素~内に挿入するよう，繰返に利用されることが意味される。
これらの要素は，すべて `div$tg 要素になる。
◎
A certain piece of user input is meant to be used repeatedly, to insert it in multiple elements on the page. All these elements will be &lt;div&gt; elements.
</span> */
const %user_string = "...";  /* <span class="comment">
利用者からの文字列
◎
The user string.
</span> */
const %sanitizer = new Sanitizer( ... );  /* <span class="comment">
新たな `Sanitizer^I
◎
Our Sanitizer.
</span> */

const %sanitized = %sanitizer.sanitizeFor("div", %user_string);
sanitized instanceof HTMLDivElement  /* <span class="comment">
~T になる。
~nodeは、
~Sanitizerから与えられる。
◎
true. The Sanitizer has given us a node.
</span> */

/* <span class="comment">
...後で，同じ~program内で：
◎
... later, in the same program ...
</span> */
for (let %elem = ... of ...) {
  /* <span class="comment">
%elem ~instanceはどれも、
上の `sanitizeFor()$m ~callにて利用したものと同じ型になるべきである。
これは、
次のような見かけの表明でも行える：
◎
All of our "elem" instances should be of the same type used in the .sanitizeFor call above. With an assertion library, this could look as follows:
</span> */
  assert_true(%elem instanceof %sanitized.constructor);  /* <span class="comment">
`assert_true^c は、
`WPT^en ~test【`Web Platfotm Test^en】のそれと似たものとする。
◎
Assuming assert_true, like in WPT tests.
</span> */
  %elem.replaceChildren(...%sanitized.childNodes);
}

/* <span class="comment">
次の代わりに：
◎
Instead of:
</span> */
%elem.replaceChildren(...%sanitized.childNodes);
/* <span class="comment">
次のように書くこともできる：
◎
one could write:
</span> */
%elem.innerHTML = %sanitized.innerHTML;
/* <span class="comment">
これの効果は、
遅くなることを除けば同じになるはずである
— これは，すでに可用であった~node~treeを直列化して【！un-parsing】から構文解析し直すので、
前者の方だけ用い続けることが推奨される。
◎
This should have the same effect, except be slower, since this will trigger un-parsing and then re-parsing the node tree which we already have available as a node tree. So we recommend to stick with the former version.
</span> */
</pre>
</div>

			</section>
			<section id="string-context-case-other">
<h4 title="The Other Case">1.3.4. その他の事例</h4>

<p>
所与の~app構造において，これらの事例がどれも働かないため，文字列を文字列へ~~変換する演算が要求される場合どうするか？
この事例では、
開発者は［
~sanitizeした結果を その文脈から切り離してもかまわない
］が，［
結果の文字列を不適切な文脈~内に誤って適用することに起因する~mXSS~classの攻撃
］を防止する責務は開発者にあり続ける。
◎
What if neither of these cases works with a given application structure, and a string-to-string operation is required? In this case, the developer is free to take the sanitization result and remove it from its context. In this case, the responsibility to prevent mXSS-class attacks that stem from mis-applying those strings in an inappropriate context remains with the developer.
</p>

<div class="example">

<pre class="lang-js">
const %user_string = "...";  /* <span class="comment">
利用者からの文字列
◎
The user string.
</span> */
const %sanitizer = new Sanitizer( ... );  /* <span class="comment">
新たな `Sanitizer^I
◎
Our Sanitizer.
</span> */

/* <span class="comment">
開発者は、
この文字列を `div$e 要素の中に挿入するものと計画するが，
これを（要素の代わりに）文字列として保つ必要があるとする。
~mXSS攻撃を防止するためには、
開発者は［
構文解析~文脈を覚えておいて，これを異なる構文解析~文脈には利用しない
］ことが重要になる。
◎
The developer plans to insert this string into a &lt;div&gt; element, but has to keep this around as a string (instead of an element). It’s important that the developer remembers the parsing context and MUST NOT use this in a different parsing context in order to prevent mXSS attacks.
</span> */
const %sanitized_for_div = %sanitizer.sanitizeFor("div", %user_string).innerHTML;
</pre>
</div>

			</section>
		</section>
	</section>
	<section id="framework">
<h2 title="Framework">2. ~framework</h2>

		<section id="sanitizer-api">
<h3 title="Sanitizer API">2.1. ~Sanitizer~API</h3>

<p>
中核~APIは `Sanitizer$I ~objと `sanitize()$m ~methodである。
~Sanitizerは、
各種~option用の省略可能な `SanitizerConfig$I 辞書を利用して，~instance化できる。
最も共通的な利用事例
— ~XSSを防止すること —
は，既定で取扱われ、
追加的な［
~appに特有な利用事例
］を取扱うときに限り，~customな環境設定0を伴う~Sanitizerを作成することが必要yである。
◎
The core API is the Sanitizer object and the sanitize method. Sanitizers can be instantiated using an optional SanitizerConfig dictionary for options. The most common use-case - preventing XSS - is handled by default, so that creating a Sanitizer with a custom config is necessary only to handle additional, application-specific use cases.
</p>

<pre class="idl">
[`Exposed$=(Window), `SecureContext$]
interface `Sanitizer@I {
  `Sanitizer$mc(optional `SanitizerConfig$I %config = {});

  `DocumentFragment$I `sanitize$m((`Document$I or `DocumentFragment$I) %input);
  `Element$I? `sanitizeFor$m(`DOMString$ %element, `DOMString$ %input);

  `SanitizerConfig$I `getConfiguration$m();
  static `SanitizerConfig$I `getDefaultConfiguration$m();
};
</pre>

<div class="algo">
<p>
`new Sanitizer(config)@m
構築子~手続きは：
</p>
<ol>
	<li>
~IF［
%config は空である
］†
⇒
`~Sanitizerを初期化する$( コレ )
</li>
	<li>
~ELSE†
⇒
`~Sanitizerを初期化する$( コレ, %config )
</li>
</ol>

<p class="trans-note">【†
この場合分けは、
この訳による補完。
この構築子が %config を省略して~callされた場合、
`~Sanitizerを初期化する$手続きを 2 個目の引数を省略して呼出す
（すなわち，`既定の環境設定$を利用する）ことが原文の意図であるが、
~IDLの定義により， %config には空な辞書が既定~値として渡されるので
（明示的に空な辞書が渡された場合とで挙動を違えることはできない）。
】</p>
◎
The new Sanitizer(config) constructor steps are to run the create a sanitizer algorithm steps on this with config as parameter.
</div>

<div class="algo">
`sanitize(input)@m
~method手続きは
⇒
~RET コレで`~sanitizeする$( %input )
◎
The sanitize(input) method steps are to return the result of running the sanitize algorithm on input,
</div>

<div class="algo">
`sanitizeFor(element, input)@m
~method手続きは
⇒
~RET コレで`要素~用に~sanitizeする$( %element, %input )
◎
The sanitizeFor(element, input) method steps are to return the result of running sanitizeFor algorithm on element and input.
</div>

<div class="algo">
<p>
`getConfiguration()@m
~method手続きは
⇒
~RET コレの`環境設定0を~queryする$()
◎
The getConfiguration() method steps are to return the result of running the query the sanitizer config algorithm.＼
</p>
<p>
これは、
本質的には ~Sanitizerの`環境設定~辞書$の複製を返すが，
ある程度の正規化を伴う。
【この正規化に該当する処理nは、この仕様の更新により除去された。】
◎
It essentially returns a copy of the Sanitizer’s configuration dictionary, with some degree of normalization.
</p>
</div>

<div class="algo">
`getDefaultConfiguration()@m
静的~method手続きは
⇒
~RET `既定の環境設定$
◎
The value of the static getDefaultConfiguration() method steps are to return the value of the default configuration dictionary.
</div>

<p>
`Element$I ~interfaceには、
`setHTML()$m ~methodが追加される
— それは、
~Sanitizerを利用して，文字列を既存の要素~nodeに直に適用する。
◎
The Element interface gains an additional method, setHTML which applies a string using a Sanitizer directly to an existing element node.
</p>

<pre class="idl">
dictionary `SetHTMLOptions$I {
  `Sanitizer$I `sanitizer$m;
};
partial interface `Element$I {
  `undefined$ `setHTML$m(`DOMString$ %input, optional `SetHTMLOptions$I %options = {});
};
</pre>

<div class="algo">
`setHTML(input, options)@m
~method手続きは
⇒
`要素~用に~sanitizeして設定する$( コレ, %input, %options )
◎
The setHTML(input, options) method steps are to run the sanitizeAndSet algorithm on this, input, and options.
◎
Is this how we specify a method on existing class "owned" by a different spe?
</div>

【！<p class="issue">これは、異なる仕様に “所有される” 既存の~class用に~methodを指定する方法として~~適切なのか？</p>】

<div class="example">
<p>
この仕様の例を追い易くするためには、
手早く容易に~DOM~nodeを作成する仕方が必要になる
— この仕様の~Sanitizer~APIでも作成できるが、
それは，自身をデモるためには利用できないので。
以下に与える `to_node$V は、
これを成遂げるための その場限りの仕方であり，~~説明用に限られる
— 実施には利用しないこと。
この構文解析~methodは、
構文解析される文字列に基づいて，~secureでない副作用を伴い得る。
事実，この~APIこそが、
もっぱら，この~approachに伴う問題を防止する目的で存在する。
◎
// To make our examples easy to follow, we’ll need a way create DOM nodes.
// The following is hacky way to accomplish this, for illustration only,
// that you shall pretty please not use in practice. This parsing method can
// cause side-effects based on the string being parsed, which is insecure.
// In fact, this very API exists for the sole purpose of preventing the
// problems that this approach has.
//
// But... for our examples we’ll need something that is quick and easy, since
// we cannot use our own Sanitizer API to explain our own Sanitizer API.
</p>

<pre class="lang-js">
const `to_node@V = %str =&gt; document.createRange().createContextualFragment(%str);
</pre>
</div>

<div class="example">
<pre class="lang-js">
/* <span class="comment">
~Sanitizerの中核~APIは、
`sanitize()$m ~methodである：
◎
The core API of the Sanitizer is the .sanitize method:
</span> */
let %untrusted_input = `to_node$V("Hello!");
const %sanitizer = new Sanitizer();
%sanitizer.sanitize(%untrusted_input);  /* <span class="comment">
~text~node "Hello!" を伴う`文書片$
◎
DocumentFragment w/ a text node, "Hello!"
</span> */

/* <span class="comment">
これが、
おそらく，~DOM内のどこかに置くことが求まれるもの：
◎
Probably we want to put this somewhere in our DOM:
</span> */
%element.replaceChildren(%sanitizer.sanitize(%untrusted_input));

/* <span class="comment">
入力が~markupを包含する場合、
~script的な~markupを除いて，ほぼ保全されることになる：
◎
If our input contains markup it’ll be mostly preserved, except for script-y markup:
</span> */
%untrusted_input = `to_node$V("&lt;em onclick='alert(1);'&gt;Hello!&lt;/em&gt;");
%sanitizer.sanitize(%untrusted_input);  /* &lt;em&gt;Hello!&lt;/em&gt; */
%element.replaceChildren(%sanitizer.sanitize(%untrusted_input));  /* <span class="comment">
`alert(1)^c は生じ得ない。
◎
No alert!
</span> */

/* <span class="comment">
`sanitize()$m ~methodが首な~APIであり、
`文書片$を返す。
`sanitizeFor()$m ~methodは、
文字列を受容して, それを構文解析して, ~HTML要素~nodeを返す。
◎
The .sanitize method is the primary API, and returns a DocumentFragment. The .sanitizeFor method accepts and parses a string and returns an HTML element node.
</span> */
const %hello = `to_node$V("hello");
(%sanitizer.sanitize(hello)) instanceof DocumentFragment;  /* true */
(%sanitizer.sanitizeFor("template", "hello")) instanceof HTMLTemplateElement;  /* true */
</pre>
</div>

		</section>
		<section id="api-string-handling">
<h3 title="String Handling">2.2. 文字列の取扱い</h3>

<p>
文字列を~HTMLへ構文解析する（あるいは~HTMLから直列化する【！unparse】）ためには、
文脈~要素が要求される。
したがって、
`sanitizeFor()$m ~methodには，［
実装が~HTML構文解析器へ手渡せる文脈
］を渡すことが要求される。
◎
Parsing (and unparsing) strings to (or from) HTML requires a context element. Thus, the sanitizeFor method requires us to pass in a context, which the implementation can then hand over to the HTML Parser.
</p>

<p>
加えて、
`Element$I ~interfaceには `setHTML()$m ~methodが追加される
— それは、
当の`要素$に適用されるので，常に正しい文脈を知る。
この`要素$が、
自前の内容を［
構文解析するとき, 直列化するとき
］の正しい文脈を与える。
◎
Additionally, the Element interface gains a setHTML method, which always knows the correct context, because it is applied to a given Element instance. This Element is the correct context for both parsing and unparsing its own content.
</p>

<div>
<p>
文字列の~sanitizationは、
次に挙げる 3 段からなる演算として概念~化できる
⇒＃
(1)： 文字列を構文解析する。
(2)： (1) の結果の~node~treeを~sanitizeする。
(3)： (2) の結果の下位treeを~liveな~DOMへ移植する。
</p>

<p>
`Sanitizer$I の `sanitize()$m は、
段 (2) を遂行する。
`Sanitizer$I の `sanitizeFor()$m は、
段 (1), (2) を遂行するが (3) を開発者に委ねる。
`Element$I の `setHTML$m は、
段 (1), (2), (3) すべてを遂行する。
どれを利用するかは、
当の~appの構造に依存する
— 3 つの段をすべてを同時に行えることもあれば、
（~code構造により，または ある時点で）~DOMの最終的な改変から~sanitizationが除去される【ので，その後に適用する必要がある？】こともあろう。
</p>
◎
One way to conceptualize this is to view string sanitization as a three step operation: 1, parsing the string; 2, sanitizing the resulting node tree; and 3, grafting the resulting subtree onto our live DOM. Sanitizer.sanitize is the middle step. Sanitizer.sanitizeFor performs the first and second steps, but leaves the third to the developer. Element.setHTML does all three. Which to use depends on the structure of your application, whether you can do all three steps simultaneously, or whether maybe the sanitization is removed (in either code structure or point in time) from the eventual modification of the DOM.
</div>

<div class="example">

<pre class="lang-js">
/* <span class="comment">
~sanitizeされる~markupは，~treeとして すでに可用な場合
（例：埋込まれた~frameから）、
`sanitize()$m を利用できる：
◎
If the markup to be sanitized is already available as a tree, for example from an embedded frame, one can use sanitize:
</span> */
document.getElementById("target").replaceChildren(
  %sanitizer.sanitize(
    document.querySelector("iframe#myframe").contentWindow.document));

/* <span class="comment">
~sanitizeされる~markupは，文字列の形で在るが、
挿入-先として求まれる要素はすでに可用である場合：
◎
If the markup to be sanitized is present in string form, but we already have the element we want to insert in available:
</span> */
const %untrusted_input = "....";
document.getElementById("someelement").setHTML(
  %untrusted_input, {sanitizer: %sanitizer});

/* <span class="comment">
上と同じだが、
既定の~Sanitizer環境設定を利用するときは：
◎
Same as above, but using the default Sanitizer configuration:
</span> */
document.getElementById("somelement").setHTML(%untrusted_input);

/* <span class="comment">
~sanitizeされることになる~markupは，文字列の形で在るが、
今は~DOMへの挿入は求まれない場合：
◎
If the markup to be sanitized is present in string form, but we don’t want to do the DOM insertion now:
</span> */
let %no_xss = %sanitizer.sanitizeFor("div", %untrusted_input);
/* <span class="comment">
... ずっと後で ...
◎
... much later ...
</span> */
document.querySelector("div#targetdiv").replaceChildren(...%no_xss.childNodes);

/* <span class="comment">
~HTMLの構文解析は、
多くの仕方で現在の文脈に依存することに注意
— うち一部は微妙で, 他はそれほどでもない。
結果を最終的に利用する所とは異なる文脈を給することには、
~securityの~risk, 機能上の~riskどちらもある。
これを安全に取扱うことは開発者に委ねられる。
◎
Note that parsing HTML depends on the current context in many ways, some subtle, some not so much. Supplying a different context than what the result will eventually be used in has both security and functional risks. It’s up to the developer to handle this safely.
</span> */
/* <span class="comment">
例：多くの, ほとんどの構文解析~文脈は、
`table$tg に封入されていない~table~data （ `td$tg ）を許容しない。
◎
Example: Most, many parsing contexts disallow table data (&lt;td&gt;) without an enclosing table.
</span> */
%sanitizer.sanitizeFor("div", "&lt;td&gt;data&lt;/td&gt;").innerHTML  /* "data" */
%sanitizer.sanitizeFor("table", "&lt;td&gt;data&lt;/td&gt;").innerHTML  /* "&lt;td&gt;data&lt;/td&gt;" */
</pre>
</div>

<div class="note">

<p>注記：
文字列を~sanitizeするときは、
`~HTML構文解析器$を利用して入力を構文解析するので，ある程度の正規化を遂行することになる。
なので、
特定0の入力に対し施される~sanitization手続きは何も無い場合でも，
`sanitizeFor()$m の出力【を直列化した結果】が文字ごとに入力と一致することは保証できない。
◎
Note: Sanitizing a string will use the HTML Parser to parse the input, which will perform some degree of normalization. So even if no sanitization steps are taken on a particular input, it cannot be guaranteed that the output of .sanitizeFor will be character-for-character identical to the input.
</p>

<div class="example">
<pre class="lang-js">
%sanitizer.sanitizeFor("div", "Stra&amp;szlig;e")  /* 
Straße */
%sanitizer.sanitizeFor("div", "&lt;image&gt;")  /* `img$tg */
</pre>
</div>

</div>

<div class="note">

<p>注記：
［
`Sanitizer$I の `sanitizeFor()$m,
`Element$I の `setHTML()$m
］~methodは、
互いに他方を置換できる。
この両者が供されているのは、
それらが~supportする利用事例が異なるからである。
◎
Note: Sanitizer.sanitizeFor and Element.setHTML can replace the respective other. Both are provided, since they support different use cases.
</p>

<div class="example">
<pre class="lang-js">
/* <span class="comment">
この `sanitizeFor^c 関数は、
`setHTML()$m 【！SetInnerHTML】に基づく：
◎
sanitizeFor, based on SetInnerHTML.
</span> */
function sanitizeFor(%element, %input) {
  const %elem = document.createElement(%element);
  %elem.setHTML(%input, {sanitizer: this});
  return %elem;
}

/* <span class="comment">
この `setHTML^c 関数は、
`sanitizeFor()$m に基づく：
◎
setHTML, based on sanitizeFor.
</span> */
function setHTML(%input, %options) {
  const %sanitizer = %options?.sanitizer ?? new Sanitizer();
  this.replaceChildren(...%sanitizer.sanitizeFor(this.localName, %input).childNodes);
}
</pre>
</div>
</div>

		</section>
		<section id="config">
<h3 title="The Configuration Dictionary">2.3. 環境設定~辞書</h3>

<p>
~Sanitizerの
`環境設定~辞書@
は、
辞書であり，~sanitize演算に対する改変を述べる。
~Sanitizerが明示的な環境設定を受取らなかった場合
— 例えば，~parameterを何も伴わずに構築されたとき —
`既定の環境設定$が環境設定~辞書として利用される。
◎
The Sanitizer’s configuration dictionary is a dictionary which describes modifications to the sanitize operation. If a Sanitizer has not received an explicit configuration, for example when being constructed without any parameters, then the default configuration value is used as the configuration dictionary.
</p>

<p class="trans-note">【
原文には、［
~Sanitizerが`環境設定~辞書$を持たない場合もある
］と見做す記述
（持たない場合、
`既定の環境設定$を利用するよう明示的に指定している）
と［
~Sanitizerは常に`環境設定~辞書$を持つ
］と見做す記述
（環境設定が供されなかった場合、
`既定の環境設定$に設定されたものと見做す）
があって，一貫でない。
この訳では、
後者に統一することにする。
】</p>

<pre class="idl">
dictionary `SanitizerConfig@I {
  `sequence$&lt;`DOMString$&gt; `allowElements$m;
  `sequence$&lt;`DOMString$&gt; `blockElements$m;
  `sequence$&lt;`DOMString$&gt; `dropElements$m;
  `AttributeMatchList$I `allowAttributes$m;
  `AttributeMatchList$I `dropAttributes$m;
  `boolean$ `allowCustomElements$m;
  `boolean$ `allowUnknownMarkup$m;
  `boolean$ `allowComments$m;
};
</pre>

<dl>
	<dt>`allowElements@m</dt>
	<dd>
`許容する要素~群@†
を与える
— それは、［
次に該当する要素の名前を与える文字列
］からなる連列である
⇒
~sanitizerは、
入力~内に維持するべきである
◎
The element allow list is a sequence of strings with elements that the sanitizer should retain in the input.
</dd>
	<dd class="trans-note">【†
この訳では、
この用語は利用せず，直に
%環境設定~辞書[ "`allowElements$m" ]
のような形で参照することにする
（以下で他の~member用に定義される~~同類の用語についても同様）。
原文には，［
この~memberが供されなかった場合、
この用語は，どう定義されるのか
］が直に述べられていないため、
~memberの有無による場合分けを述べる所では，結局~直に参照することになる
（この用語を通して述べる利点がない）ので。
】</dd>

	<dt>`blockElements@m</dt>
	<dd>
`阻止する要素~群@
を与える
— それは、［
次に該当する要素の名前を与える文字列
］からなる連列である
⇒
~sanitizerは、
入力から除去するべきであるが，その子孫【！children】は維持するべきである
◎
The element block list is a sequence of strings with elements where the sanitizer should remove the elements from the input, but retain their children.
</dd>

	<dt>`dropElements@m</dt>
	<dd>
`落とす要素~群@
を与える
— それは、［
次に該当する要素の名前を与える文字列
］からなる連列である
⇒
~sanitizerは、
入力から
— その子孫【！children】も含めて —
除去するべきである
◎
The element drop list is a sequence of strings with elements that the sanitizer should remove from the input, including its children.
</dd>

	<dt>`allowAttributes@m</dt>
	<dd>
`許容する属性~群@
を与える
— それは、
次を決定するための`属性~照合-~map$である
⇒
属性は、
（所与の要素にて）許容されるべきかどうか
◎
The attribute allow list is an attribute match list, which determines whether an attribute (on a given element) should be allowed.
</dd>

	<dt>`dropAttributes@m</dt>
	<dd>
`落とす属性~群@
を与える
— それは、
次を決定するための`属性~照合-~map$である
⇒
属性は、
（所与の要素から）落とされるべきかどうか
◎
The attribute drop list is an attribute match list, which determines whether an attribute (on a given element) should be dropped.
</dd>

	<dt>`allowCustomElements@m</dt>
	<dd>
`~custom要素$は考慮されるかどうかを決定する。
それらは、
既定では落とされる。
この~optionが ~T の場合、
~custom要素であっても，他のすべての［
組込みの検査／環境設定された検査
］に対し検査されることになる。
◎
The allow custom elements option determines whether custom elements are to be considered. The default is to drop them. If this option is true, custom elements will still be checked against all other built-in or configured checks.
</dd>

	<dt>`allowUnknownMarkup@m</dt>
	<dd>
未知な~HTML要素を考慮するかどうかを決定する。
既定では，それらを落とす。
この~optionが ~T の場合、
未知な~HTML要素も，他のすべての［
組込みの検査／環境設定された検査
］に対し検査されることになる。
◎
The allow unknown markup option determines whether unknown HTML elements are to be considered. The default is to drop them. If this option is true, unkown HTML elements will still be checked against all other built-in or configured checks.
</dd>

	<dt>`allowComments@m</dt>
	<dd id="allow-comments-option">
~HTML~commentは許容されるかどうかを決定する。
◎
The allow comments option determines whether HTML comments are allowed.
</dd>
</dl>

<div class="note">
<p>注記：
`allowElements$m は，既定では要素を落とす~sanitizerを作成する一方で、［
`blockElements$m ／ `dropElements$m
］は，既定では未知な要素を保つ。
両方とも利用することもアリであるが、
おそらく実用的な利用は少ない。
同じことは、［
`allowAttributes$m, `dropAttributes$m
］にも該当する。
◎
Note: allowElements creates a sanitizer that defaults to dropping elements, while blockElements and dropElements defaults to keeping unknown elements. Using both types is possible, but is probably of little practical use. The same applies to allowAttributes and dropAttributes.
</p>

<p class="trans-note">【
`dropElements^m, `blockElements^m, `allowElements^m 
の順に優先され，
`dropAttributes^m, `allowAttributes^m
の順に優先される。
】</p>

</div>

<div class="example">
<pre class="lang-js">
const %sample = `to_node$V("Some text &lt;b&gt;&lt;i&gt;with&lt;/i&gt;&lt;/b&gt; &lt;blink&gt;tags&lt;/blink&gt;.");
const %script_sample = `to_node$V("abc &lt;script&gt;alert(1)&lt;/script&gt; def");

/* Some text &lt;b&gt;with&lt;/b&gt; text tags. */
new Sanitizer({allowElements: [ "b" ]}).sanitize(%sample);

/* Some text &lt;i&gt;with&lt;/i&gt; &lt;blink&gt;tags&lt;/blink&gt;. */
new Sanitizer({blockElements: [ "b" ]}).sanitize(%sample);

/* Some text &lt;blink&gt;tags&lt;/blink&gt;. */
new Sanitizer({dropElements: [ "b" ]}).sanitize(%sample);

/* <span class="comment">
注記：
既定の環境設定は、
~XSSに関連な入力を取扱う：
◎
Note: The default configuration handles XSS-relevant input:
</span> */

/* <span class="comment">
~scriptを伴わない入力は、
通過することになる：
◎
Non-scripting input will be passed through:
</span> */
new Sanitizer().sanitize(%sample);  /* <span class="comment">
%sample を改変せずに出力することになる。
◎
Will output sample unmodified.
</span> */

/* <span class="comment">
`script^e は阻止され、
`abc alert(1) def^l になる：
◎
Scripts will be blocked: "abc alert(1) def"
</span> */
new Sanitizer().sanitize(%script_sample);
</pre>
</div>

<p>
［
要素／属性
］を［
許容する~list, 阻止する~list
］に加えて，一部の［
~node／要素
］型を環境設定する~optionもある。
◎
In addition to allow and block lists for elements and attributes, there are also options to configure some node or element types.
</p>

<div class="example">
<pre class="lang-js">
/* <span class="comment">
~commentは、
既定では落とされることになる。
◎
Examples:
◎
Comments will be dropped by default.
</span> */
const %comment = `to_node$V("Hello  World!");
new Sanitizer().sanitize(%comment);  /* `Hello World!^l */
new Sanitizer({allowComments: true}).sanitize(%comment);  /* <span class="comment">
結果は %comment と同じになる。
◎
Same as comment.
</span> */
</pre>
</div>

<p>
~sanitizerの環境設定は、
`getConfiguration()$m【！sanitizer config】 ~methodを利用して~queryできる。
◎
A sanitizer’s configuration can be queried using the query the sanitizer config method.
</p>

<div class="example">

<pre class="lang-js">
/* <span class="comment">
既定の環境設定0は、
`script^e 要素を許容するか？
◎
Does the default config allow script elements?
</span> */
Sanitizer.getDefaultConfiguration().allowElements.includes("script") /* false */

/* <span class="comment">
~Sanitizer~instance %a_sanitizer を見出したとする。
その `allowElements$m （許容する要素~群）は環境設定されたか？
◎
We found a Sanitizer instance. Does it have an allow-list configured?
</span> */
const %a_sanitizer = ...;
!!%a_sanitizer.getConfiguration().allowElements /* <span class="comment">
結果は［
`allowElements$m は環境設定された
］ならば ~T になる。
◎
true, if an allowElements list is configured
</span> */

/* <span class="comment">
`allowElements$m が %a_sanitizer に在る場合、
それは `div$tg 要素を含むか？
◎
If it does have an allow elements list, does it include the &lt;div&gt; element?
</span> */
%a_sanitizer.getConfiguration().allowElements.includes("div")  /* <span class="comment">
結果は［
`allowElements$m 内に `div^l は在る
］ならば ~T になる。
◎
true, if "div" is in allowElements.
</span> */

/* <span class="comment">
`getConfiguration()$m ~methodは、
何らかの正規化を行うかもしれないことに注意。
例：~IDL【 `SanitizerConfig$I 】内に宣言されていない ( ~key, 値 ) ~pairは、
包含しないことになる
【これは、~Web~IDLにより自動的に施行されるので，この~APIに特有な挙動ではない（例として挙げるには不適切に思われる）】。
◎
Note that the getConfiguration method might do some normalization. E.g., it won’t contain key/value pairs that are not declare in the IDL.
</span> */
Object.keys(new Sanitizer({madeUpDictionaryKey: "Hello"}).getConfiguration())  /* [] */

/* <span class="comment">
~sanitizer【！~Sanitizer】の演算は，当の~sanitizerの環境設定0で述べられるので、
新たな~sanitizerの挙動は，別のそれと同じ環境設定を伴うならば一致するべきである。
【！(For illustration purposes only...】
◎
As a Sanitizer’s config describes its operation, a new sanitizer with another instance’s configuration should behave identically. (For illustration purposes only. It would make more sense to just use a directly.)
</span> */
const %a = /* <span class="comment">
どこかで見出された，ある `Sanitizer^I
◎
... a Sanitizer we found somewhere ...
</span> */;
const %b = new Sanitizer(%a.getConfiguration());  /* <span class="comment">
%b の挙動は %a と同じになるはずである。
◎
b should behave the same as a.
</span> */

/* <span class="comment">
`new Sanitizer().getConfiguration()^c の結果は
`getDefaultConfiguration()^m 同じになるはずである
（~~説明用に限る
— ~JSには、
~objの同等性を実装する，もっと良い仕方がある）。
◎
getDefaultConfiguration() and new Sanitizer().getConfiguration should be the same. (For illustration purposes only. There are better ways of implementing object equality in JavaScript.)
</span> */
JSON.stringify(Sanitizer.getDefaultConfiguration()) == JSON.stringify(new Sanitizer().getConfiguration());  /* true */
</pre>
</div>

			<section id="attr-match-list">
<h4 title="Attribute Match Lists">2.3.1. 属性~照合-~map</h4>

<p>
`属性~照合-~map@
は、
属性から要素たちへの`~map$である。
この~map内の
特別な名前 `*^l は、［
すべての属性／すべての要素
］を表す。
◎
An attribute match list is a map of attributes to elements, where the special name "*" stands for all attributes or elements.＼
</p>

<p class="trans-note">【
すなわち、
~mapを成す各~entryの：
~keyは［
`*^l または属性の名前
］を与える ／
値は［
1 個の `*^l または一群の要素~名
］からなる`~list$を与える。
~entryの値は、
理論上は（ 1 個以上の） `*^l と要素~名の混在もあり得るが，
その場合の挙動は曖昧にしか述べられていていない。
この訳では、
暫定的に［
1 個の `*^l からなる場合に限り，すべての要素を表す
］ものと見做しているが。
】【
この用語は，原文では “属性~照合-~list” と称されているが、
無用な混同を避けるため，
この訳では “属性~照合-~map” に改称する。
（原文における，この語の用法は、［
~mapそれ自体, ~mapを成すある~entryの値
］を両義的に表していて，紛らわしい。）
】</p>

<p>
ある要素に属している属性は、
次が満たされるならば`属性~照合-~map$に合致する…
【これは、規範的な定義ではなく無用に冗長なので，和訳は省略する。`属性は照合-~mapに合致しているか？$を見よ。】
◎
A given attribute belonging to an element matches an attribute match list, if the attribute is a key in the match list, and element or "*" are found in the attribute’s value list.
</p>

<p>
要素~名は，`~HTML名前空間$に属する名前として解釈され、
属性は，どの名前空間にも属さないものと解釈される
— すなわち、
`HTML$r の通常の［
要素／属性
］として捉えられる。
［
要素は その`局所-名$／
属性は その`局所-名$attr
］で命名される。
◎
Element names are interpreted as names in the [[HTML namespace]] and non-namespaced attributes - i.e., what one may think of as normal [HTML] elements and attributes. Elements are named by their local name, and attributes, too.
</p>

<pre class="idl">
typedef `record$&lt;`DOMString$, `sequence$&lt;`DOMString$&gt;&gt; `AttributeMatchList@I;
</pre>

<div class="example">

<p>
属性と`属性~照合-~map$用の例：
◎
Examples for attributes and attribute match lists:
</p>
<pre class="lang-js">
const %sample = `to_node$V("&lt;span id='span1' class='theclass' style='font-weight: bold'&gt;hello&lt;/span&gt;");

/* <span class="comment">
`span^e 要素に限り `style^a 属性を許容する：
`&lt;span style='font-weight: bold'&gt;...&lt;/span&gt;^c
◎
Allow only &lt;span style&gt;: &lt;span style='font-weight: bold'&gt;...&lt;/span&gt;
</span> */
new Sanitizer({allowAttributes: {"style": ["span"]}}).sanitize(%sample);

/* <span class="comment">
`style^a 属性を許容するのは `span^e ではない：
`&lt;span&gt;...&lt;/span&gt;^c
◎
Allow style, but not on span: &lt;span&gt;...&lt;/span&gt;
</span> */
new Sanitizer({allowAttributes: {"style": ["div"]}}).sanitize(%sample);

/* <span class="comment">
どの要素にも `style^a 属性を許容する：
`&lt;span style='font-weight: bold'&gt;...&lt;/span&gt;^c
◎
Allow style on any elements: &lt;span style='font-weight: bold'&gt;...&lt;/span&gt;
</span> */
new Sanitizer({allowAttributes: {"style": ["*"]}}).sanitize(%sample);

/* <span class="comment">
`span^e 要素に限り `id^a 属性を落とす：
`&lt;span class='theclass' style='font-weight: bold'&gt;...&lt;/span&gt;^c
◎
Drop &lt;span id&gt;: &lt;span class='theclass' style='font-weight: bold'&gt;...&lt;/span&gt;
</span> */
new Sanitizer({dropAttributes: {"id": ["span"]}}).sanitize(%sample);

/* <span class="comment">
どの要素からも `id^a 属性を落とす：
`&lt;span class='theclass' style='font-weight: bold'&gt;...&lt;/span&gt;^c
◎
Drop id, everywhere: &lt;span class='theclass' style='font-weight: bold'&gt;...&lt;/span&gt;
</span> */
new Sanitizer({dropAttributes: {"id": ["*"]}}).sanitize(%sample);
</pre>
</div>

			</section>
		</section>
	</section>
	<section id="algorithms">
<h2 title="Algorithms">3. 各種~algo</h2>

		<section id="api-algorithms">
<h3 title="API Implementation">3.1. ~API実装</h3>

<div class="algo">
<p>
`~Sanitizerを初期化する@
【！create a …】
ときは、
所与の
( `Sanitizer$I %~sanitizer, `SanitizerConfig$I %環境設定0 （省略時は ε ） )
に対し，次の手続きを走らす：
◎
To create a Sanitizer with an optional config parameter, run these steps:
</p>
<ol>
	<li>
~IF［
%環境設定0 ~EQ ε
］
⇒
%環境設定0 ~SET `既定の環境設定$
◎
Create a copy of config.
</li>
	<li>
%~sanitizer の`環境設定~辞書$ ~SET %環境設定0
◎
Set config as this's configuration dictionary.
</li>
</ol>

<p class="issue">
ここでは、
当の環境設定0の どの~propに要素~名が見出されるか明示的に言明して，
~map演算で改変するベキである
[`148$issue]
◎
This should explicitly state the config’s properties in which element names are found and modify the config wih map operations. [Issue #148]
</p>
</div>

<p class="note">注記：
環境設定~辞書は、
%環境設定0 の［
`allowElements$m,
`blockElements$m,
`dropElements$m
］~member内, ［［
`allowAttributes$m,
`dropAttributes$m
］~memberが与える`属性~照合-~map$内の各~entryの値
］内に要素~名を包含する。
◎
Note: The configuration object contains element names in the element allow list, element block list, and element drop list, and in the mapped values in the attribute allow list and attribute drop list.
</p>

<div class="algo">
<p>
`Sanitizer$I %~sanitizer で
`~sanitizeする@
ときは、
所与の
( `文書$または`文書片$ %入力 )
に対し，次の手続きを走らす：
◎
To sanitize a given input of type Document or DocumentFragment run these steps:
</p>
<ol>
	<li>
%文書片 ~LET `文書片を作成する$( %入力 )
◎
Let fragment be the result of running the create a document fragment algorithm on input.
</li>
	<li>
%~sanitizer で`文書片を~sanitizeする$( %文書片 )
◎
Run the sanitize a document fragment algorithm on fragment.
</li>
	<li>
~RET %文書片
◎
Return fragment.
</li>
</ol>

<div id="_test-sanitizer-sanitize"></div>

<p class="issue">
~sanitizeする~algoは、
“文書片を作成する” を走らす必要は無い。
[`149$issue]
◎
The sanitize algorithm does not need to run "create a document fragment". [Issue #149]
</p>
</div>

<div class="algo">
<p>
`Sanitizer$I %~sanitizer で
`要素~用に~sanitizeする@
ときは、
所与の
( `文字列$ %要素~名, `文字列$ %入力 )
に対し，次の手続きを走らす：
◎
To sanitize for an element name of type DOMString and a given input of type DOMString run these steps:
</p>
<ol>
	<li>
%要素 ~LET `要素を作成する$( 現在の文書【？】, %要素~名, `~HTML名前空間$ )
◎
Let element be an HTML element created by running the steps of the creating an element algorithm with the current document, element name, the HTML namespace, and no optional parameters.
</li>
	<li>
~IF［
%要素 の`要素~種類$ ~EQ `正則^i
］~AND［
%要素~名 ~NIN `要素~用の~baseline許容-~list$
］
⇒
~RET ~NULL
◎
If the element kind of element is regular and if the baseline element allow list does not contain element name, then return null.
</li>
	<li>
%文書片 ~LET `素片を構文解析する$( %入力, %要素 )
◎
Let fragment be the result of invoking the html fragment parsing algorithm, with element as the context element and input as markup.
</li>
	<li>
%~sanitizer で`文書片を~sanitizeする$( %文書片 )
◎
Run the steps of the sanitize a document fragment algorithm on fragment.
</li>
	<li>
%要素 の`全~内容を~nodeで置換する$( %文書片 )
◎
Replace all with fragment as the node and element as the parent.
</li>
	<li>
~RET %要素
◎
Return element.
</li>
</ol>

<div id="_test-sanitizer-sanitizeFor"></div>

<p class="issue">
`sanitizeFor()$m から渡される要素~名には、
名前空間に関係する処理が要求されるのでは？
[`140$issue]
【この仕様は，~HTML名前空間に限るよう更新されたので、この課題は，もはや不要になっている。】
◎
Does the .sanitizeFor element name require namespace-related processing? [Issue #140]
</p>
</div>

<div class="algo">
<p>
`要素~用に~sanitizeして設定する@
ときは、
所与の
( `要素$ %要素, `文字列$ %値, `SetHTMLOptions$I %~option群 )
に対し，次の手続きを走らす：
◎
To sanitize and set a value using an SetHTMLOptions options dictionary on an Element node this, run these steps:
</p>
<ol>
	<li>
~IF［
%要素 の`要素~種類$ ~EQ `正則^i
］~AND［
%要素 の`局所-名$ ~NIN `要素~用の~baseline許容-~list$
］
⇒
~THROW `TypeError$E
◎
If the element kind of this is regular and this' local name does not match any name in the baseline element allow list, then throw a TypeError and return.
</li>
	<li>
%~sanitizer ~LET %~option群[ "`sanitizer$m" ]
◎
↓</li>
	<li>
<p>
~IF［
%~sanitizer ~EQ ε
］：
</p>
		<ol>
			<li>
%~sanitizer ~SET 新たな `Sanitizer$I ~obj
</li>
			<li>
`~Sanitizerを初期化する$( %~sanitizer )
</li>
		</ol>
◎
If the sanitizer member exists in the options SetHTMLOptions dictionary,
• then let sanitizer be the value of the sanitizer member of the options SetHTMLOptions dictionary,
• otherwise let sanitizer be the result of the create a Sanitizer algorithm without a config parameter.
</li>
	<li>
%文書片 ~LET `素片を構文解析する$( %値, %要素 )
◎
Let fragment be the result of invoking the html fragment parsing algorithm with this as the context node and value as markup.
</li>
	<li>
【！the steps if】
%~sanitizer で`文書片を~sanitizeする$( %文書片 )
◎
Run the steps if the sanitize a document fragment algorithm on fragment, using sanitizer as the current Sanitizer instance.
</li>
	<li>
%要素 の`全~内容を~nodeで置換する$( %文書片 )
◎
Replace all with fragment as the node and this as the parent.
</li>
</ol>

<div id="_test-element-set-sanitized-html"></div>
</div>

<div class="algo">
<p>
`Sanitizer$I %~sanitizer の
`環境設定0を~queryする@
ときは、
次の手続きを走らす：
◎
To query the sanitizer config of a given sanitizer instance, run these steps:
• Let sanitizer be the current Sanitizer.
</p>
<ol>
	<li>
%環境設定0 ~LET %~sanitizer の`環境設定~辞書$
【！は在るならば それ／無いならば`既定の環境設定$】
◎
Let config be sanitizer’s configuration dictionary, or the default configuration if no configuration dictionary was given.
</li>
	<li>
%結果 ~LET 新たな`~map$
【！新たに構築された SanitizerConfig 辞書】
◎
Let result be a newly constructed SanitizerConfig dictionary.
</li>
	<li>
【！%環境設定0 を成す ~EACH( %~key → %値 ) に対し／~IF［%~key は SanitizerConfig 内に宣言されている］／%結果[ %~key ] ~SET %値】

`SanitizerConfig$I 内に宣言された
~EACH( ~member名 %名前 )
に対し
⇒
~IF［
%環境設定0[ %名前 ] ~NEQ ε
］
⇒
%結果[ %~key ] ~SET %環境設定0[ %名前 ]
◎
For any non-empty member of config whose key is declared in SanitizerConfig, copy the value to result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<div id="_test-sanitizer-config"></div>
<div id="_test-sanitizer-query-config"></div>

<p class="issue">
~IDLは、
この~algoを成す ほとんどの段を~careする
— もっと整理する。
[`150$issue]
◎
IDL is taking care of most steps in "query the sanitizer config". Clean up. [Issue #150]
</p>
</div>

		</section>
		<section id="helper-algorithms">
<h3 title="Helper Definitions">3.2. 補助用の定義</h3>

<div class="algo">
<p>
`文書片を作成する@
ときは、
所与の
( `文書$または`文書片$ %入力 )
に対し，次の手続きを走らす：
◎
To create a document fragment named fragment from an input of type Document or DocumentFragment, run these steps:
</p>
<ol>
	<li>
%~node ~LET %入力 の型に応じて
⇒＃
`文書片$であるならば %入力 ／
`文書$であるならば %入力 の`文書~要素$【！documentElement】
◎
Let node be null.
◎
Switch based on input’s type:
• If input is of type DocumentFragment, then:
•• Set node to input.
• If input is of type Document, then:
•• Set node to input’s documentElement.
</li>
	<li>
%文書 ~LET %~node の`~node文書$
◎
↓</li>
	<li>
%~clone ~LET `~nodeを~cloneする$( %~node, %文書, `子も~cloneする^i )
◎
Let clone be the result of running clone a node on node with the clone children flag set.
</li>
	<li>
【！result of createDocumentFragment】
%文書片 ~LET 次のように設定された新たな`文書片$
⇒
その`~node文書$ ~SET %文書
◎
Let fragment be a new DocumentFragment whose node document is node’s node document.
</li>
	<li>
%文書片 に`~nodeを付加する$( %~clone )
◎
Append the node clone to fragment.
</li>
	<li>
~RET %文書片
◎
Return fragment.
</li>
</ol>
</div>

		</section>
		<section id="sanitizer-algorithms">
<h3 title="Sanitization Algorithms">3.3. 各種~sanitization~algo</h3>

<div class="algo">
<p>
`Sanitizer$I %~sanitizer で
`文書片を~sanitizeする@
ときは、
所与の
( `文書片$ %文書片 )
に対し，次の手続きを走らす：
◎
To sanitize a document fragment named fragment with a Sanitizer sanitizer run these steps:
</p>
<ol>
	<li>
%m ~LET 新たな`~map$
◎
Let m be a map that maps nodes to a sanitize action.
</li>
	<li>
<p>
%~node群 ~LET %文書片 のすべての`子孫$†からなる`~tree順序$による`~list$
◎
Let nodes be a list containing the inclusive descendants of fragment, in tree order.
</p>

<p class="trans-note">【†
原文には，`広義~子孫$と記されているが（すなわち， %文書片 も %~node群 に含める）、
以下に現れる演算は， %文書片 には適用し得ないので改めている。
】</p>
	</li>
	<li>
<p>
%~node群 を成す
~EACH( %~node )
に対し：
◎
For each node in nodes:
</p>
		<ol>
			<li>
%動作 ~LET %~sanitizer で`~nodeを~sanitizeする$( %~node )
◎
Let action be the result of running the sanitize a node algorithm on node with sanitizer.
</li>
			<li>
%m[ %~node ] ~SET %動作
◎
Set m[node] to action.
</li>
		</ol>
	</li>
	<li>
<p>
%~node群 を成す
~EACH( %~node )
に対し：
◎
For each node in nodes:
</p>
		<ol>
			<li>
<p>
~IF［
%~node は %文書片 の`子孫$でない
］
⇒
~CONTINUE
</p>

<p class="trans-note">【
この段は、
この訳による補完。
%~node は，この~loopの間に %文書片 から除去され得るので
— そのような~nodeであっても，上の段により~sanitizeされるが。
】</p>
			</li>
			<li>
<p>
%m[ %~node ] に応じて：
◎
↓</p>
				<ul class="switch">
					<li>
`落とす^i
⇒
`~nodeを除去する$( %~node )
◎
If m[node] is drop, remove node.
</li>
					<li>
<p>
`阻止する^i：
</p>
						<ol>
							<li>
%素片 ~LET 新たな`文書片$
</li>
							<li>
<p>
%~node の`子~群$を成す
~EACH( %子 )
に対し
⇒
%素片 に`~nodeを付加する$( %子 )
</p>

<p class="trans-note">【
ここでは、［
`Element$I ／ `Text$I
］でない %子 は飛ばされるべきであろう。
】</p>

							</li>
							<li>
%~node の`親$の中で`子を~nodeに置換する$( %~node, %素片 )
</li>
						</ol>
◎
If m[node] is block, create a DocumentFragment fragment, append all of node’s children to fragment, and replace node within node’s parent with fragment.
</li>
					<li>
`保つ^i
⇒
何もしない
◎
If m[node] is keep, do nothing.
</li>
				</ul>
			</li>
		</ol>
	</li>
</ol>

<p class="issue">
上の段【 “`阻止する^i” 】は、
少し精確さに欠く
— 子~群を明示的に反復して，親の中へ挿入する必要がある。
それらを変数~内に収集するか，その場で行うこともできよう。
[`156$issue]
【この課題は、今や解決-済み（削除漏れ？）。】
◎
The step above needs to explicitly iterate over the children and insert into parent. It could collect them in a variable or do things in place, but this is a bit too imprecise. [Issue #156]
</p>
</div>

<div class="algo">
<p>
`Sanitizer$I %~sanitizer で
`~nodeを~sanitizeする@
ときは、
所与の
( `~node$ %~node )
に対し：
◎
To sanitize a node named node with sanitizer run these steps:
</p>
<ol>
	<li>
~Assert：
%~node は次に挙げるいずれでもない
⇒＃
`Document$I ／
`DocumentFragment$I ／
`Attr$I ／
`DocumentType$I
◎
Assert: node is not a Document or DocumentFragment or Attr or DocumentType node.
</li>
	<li>
%環境設定0 ~LET %~sanitizer の`環境設定~辞書$
◎
↓</li>
	<li>
<p>
%~node が何を実装するかに応じて：
◎
↓</p>
		<ul class="switch">
			<li>
<p>
`Element$I ：
◎
If node is an element node:
</p>
				<ol>
					<li>
%要素 ~LET %~node
◎
Let element be node.
</li>
					<li>
<p>
%要素 の`属性~list$を成す
~EACH( %属性 )
に対し：
◎
For each attr in element’s attribute list:
</p>
						<ol>
							<li>
%属性~動作 ~LET `属性~用の~sanitize動作$( %属性, 【！%要素】【 %環境設定0 】 )
◎
Let attr action be the result of running the sanitize action for an attribute algorithm on attr and element.
</li>
							<li>
~IF［
%属性~動作 ~NEQ `保つ^i
］
⇒
`属性を除去する$( %属性 )
◎
If attr action is different from keep, remove an attribute supplying attr.
</li>
						</ol>
					</li>
					<li>
`~funkyな要素を取扱う$( %要素 )
◎
Run the steps to handle funky elements on element.
</li>
					<li>
%動作 ~LET `要素~用の~sanitize動作$( %要素【, %環境設定0 】 )
◎
Let action be the result of running the sanitize action for an element on element.
</li>
					<li>
~RET %動作
◎
Return action.
</li>
				</ol>
			</li>
			<li>
<p>
`Comment$I ：
◎
If node is a Comment node:
</p>
				<ol>
					<li>
~IF［
%環境設定0[ "`allowComments$m" ]【！の`~commentを許容する~option$】 ~EQ ~T
］
⇒
~RET `保つ^i
◎
↑↑Let config be sanitizer’s configuration dictionary, or the default configuration if no configuration dictionary was given.
◎
If config’s allow comments option exists and |config|[allowComments] is true: Return keep.
</li>
					<li>
~RET `落とす^i
◎
Return drop.
</li>
				</ol>
			</li>
			<li>
`Text$I
⇒
~RET `保つ^i
◎
If node is a Text node: Return keep.
</li>
			<li>
`ProcessingInstruction$I
⇒
~RET `落とす^i
◎
Assert: node is a ProcessingInstruction
◎
Return drop
</li>
		</ul>
	</li>
</ol>

<p class="issue">
`属性~用の~sanitize動作$に与える~parameterが合致していない。
有効な~sanitizer環境設定0を作成することを考慮する。
また、
環境設定0が`常に在る^emことは，~IDLにより保証される。
本当の問いは~memberが存在するかどうかである。
`151$issue
◎
The sanitize action for an attribute algorithm parameters do not match. Issue(153): consider creating an effective sanitizer config. Also, IDL guarantees that a config is ALWAYS given. The question is really whether the members exists. [Issue #151]
</div>

<p>
一部の~HTML要素には、［
環境設定~option群や他の~algoの用語では容易に表出できない，特別な扱い
］を要求するものもある。
次の~algoは、
これらを一箇所に収集する。
◎
Some HTML elements require special treatment in a way that can’t be easily expressed in terms of configuration options or other algorithms. The following algorithm collects these in one place.
</p>

<div class="algo">
<p>
`~funkyな要素を取扱う@
ときは、
所与の
( %要素 )
に対し，次の手続きを走らす：
◎
To handle funky elements on a given element, run these steps:
</p>
<ol>
	<li>
~IF［
%要素 の`名前空間$ ~NEQ `~HTML名前空間$
］
⇒
~RET
◎
↓</li>
	<li>
<p>
%要素 の`局所-名$に応じて：
◎
↓</p>
		<ul class="switch">
			<li>
<p>
`template^l ：
◎
If element’s namespace is HTML and the local name is "template":
</p>
				<ol>
					<li>
%~sanitizer で`文書片を~sanitizeする$( %要素 の`~template内容$ )
◎
Run the steps of the sanitize a document fragment algorithm on element’s template contents attribute.
</li>
					<li>
%要素 のすべての子~nodeを落とす
【 %要素 から すべての子~nodeを除去する】
◎
Drop all child nodes of element.
</li>
				</ol>
			</li>
			<li>
`a^l ／ `area^l
⇒
~IF［
%要素 の `protocol$m ~prop ~EQ `javascript:^l
］
⇒
%要素 から `href^a 属性を除去する
◎
If element’s namespace is HTML and the local name is one of "a" or "area", and if element’s protocol property is "javascript:":
• Remove the href attribute from element.
</li>
			<li>
`form^l
⇒
~IF［
%要素 の `action$a 属性は
`javascript:^c ~protocolを伴う`~URL$である†
］
⇒
%要素 から `action$a 属性を除去する
◎
If element’s namespace is HTML and the local name is "form" and if element’s action attribute is a [URL] with javascript: protocol:
• Remove the action attribute from element.
</li>
			<li>
`input^l ／ `button^l
⇒
~IF［
%要素 の `formaction$a 属性は
`javascript:^c ~protocolを伴う`~URL$である†
］
⇒
%要素 から `formaction$a 属性を除去する
◎
If element’s namespace is HTML and the local name is "input" or "button", and if element’s formaction attribute is a [URL] with javascript: protocol
• Remove the formaction attribute from element.
</li>
		</ul>
	</li>
</ol>

<p class="trans-note">【†
もっと厳密には、
%要素 は当の属性を有していて，その値は`妥当な~URL文字列$であることも要求されよう。
】</p>

<p class="issue">
~funkyな要素の~propを もっと精確に~exportして参照rする。
[`154$issue]
◎
Export and refer funky element properties more precisely. [Issue #154]
</p>
</div>

		</section>
		<section id="configuration">
<h3 title="Matching Against The Configuration">3.4. 環境設定との照合-法</h3>

<p>
`~sanitizeする動作@
は、
次のいずれかをとる
⇒
`保つ^i ／ `落とす^i ／ `阻止する^i
◎
A sanitize action is keep, drop, or block.
</p>

<div class="algo">
<p>
`要素~用の~sanitize動作@
を決定するときは、
所与の
( %要素, `SanitizerConfig$I %環境設定0 )
に対し，次の手続きを走らす：
◎
To determine the sanitize action for an element, given a SanitizerConfig config, run these steps:
</p>
<ol>
	<li>
%種類 ~LET %要素 の`要素~種類$
◎
Let kind be element’s element kind.
</li>
	<li>
~IF［
%種類 ~EQ `正則^i
］~AND［
`要素は名前~群に合致しているか？$( %要素, `要素~用の~baseline許容-~list$ ) ~EQ ~F
］
⇒
~RET `落とす^i
◎
If kind is regular and element does not match any name in the baseline element allow list: Return drop.
</li>
	<li>
~IF［
%種類 ~EQ `~custom^i
］~AND［
%環境設定0[ "`allowCustomElements$m" ] ~NEQ ~T
］
⇒
~RET `落とす^i
◎
If kind is custom and if config["allowCustomElements"] does not exist or if config["allowCustomElements"] is false: Return drop.
</li>
	<li>
~IF［
%種類 ~EQ `未知^i
］~AND［
%環境設定0[ "`allowUnknownMarkup$m" ] ~NEQ ~T
］
⇒
~RET `落とす^i
◎
If kind is unknown and if config["allowUnknownMarkup"] does not exist or it config["allowUnknownMarkup"] is false: Return drop.
</li>
	<li>
~IF［
`要素は名前~群に合致しているか？$( %要素, %環境設定0[ "`dropElements$m" ] ) ~EQ ~T
］
⇒
~RET `落とす^i
◎
If element matches any name in config["dropElements"]: Return drop.
</li>
	<li>
~IF［
`要素は名前~群に合致しているか？$( %要素, %環境設定0[ "`blockElements$m" ] ) ~EQ ~T
］
⇒
~RET `阻止する^i
◎
If element matches any name in config["blockElements"]: Return block.
</li>
	<li>
%許容する要素~群 ~LET %環境設定0[ "`allowElements$m" ]
◎
Let allow list be null.
◎
If "allowElements" exists in config:
• Then : Set allow list to config["allowElements"].
</li>
	<li>
~IF［
%許容する要素~群 ~EQ ε
］
⇒
%許容する要素~群 ~SET `既定の環境設定$[ "`allowElements$m" ]
◎
• Otherwise: Set allow list to the default configuration's element allow list.
</li>
	<li>
~IF［
`要素は名前~群に合致しているか？$( %要素, %許容する要素~群 ) ~EQ ~F
］
⇒
~RET `阻止する^i
◎
If element does not match any name in allow list: Return block.
</li>
	<li>
~RET `保つ^i
◎
Return keep.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素は名前~群に合致しているか？@
は、
所与の
( %要素,［
`~list$／ ε
］ %名前~list )
に対し
⇒
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%名前~list ~NEQ ε
］~AND［
%要素 は`~HTML名前空間$に属する
］~AND［
%要素 の`局所-名$ ~IN %名前~list
］
◎
To determine whether an element matches an element name, run these steps:
• If element is in the HTML namespace and if element’s local name is identical to name: Return true.
• Return false.
</p>

<p class="trans-note">【
この~algoは、
原文では（ %名前~list を成す）個々の名前に対し適用するよう定義されているが、
この~algoを呼出している箇所では，常に~listを成す各~名前に対し（ `any^en という句を通して）演算しているので、
この訳では，その~logicを この~algoの中に集約する。
】</p>

<p class="issue">
名前空間との分離子は、
~colonでなく空白にすべきか？
[`146$issue]
【この仕様は，~HTML名前空間に限るよう更新されたので、この課題は，もはや不要になっている。】
◎
Whitespaces or colons? [Issue #146]
</p>
</div>

<div class="algo">
<p>
`属性は照合-~mapに合致しているか？@
は、
所与の
( %属性, ［
`属性~照合-~map$／ ε
］ %~map )
に対し，次の手続きを走らす：
</p>
<ol>
	<li>
~IF［
%~map ~EQ ε
］
⇒
~RET ~F
</li>
	<li>
~IF［
%属性 の`名前空間$attr ~NEQ ~NULL
］
⇒
~RET ~F
</li>
	<li>
<p>
~EACH( %名前 ~IN « %属性 の`局所-名$attr, `*^l » )
に対し：
</p>
		<ol>
			<li>
%要素~名~群 ~LET %~map[ %名前 ]
</li>
			<li>
~IF［
%要素~名~群 ~EQ ε
］
⇒
~CONTINUE
</li>
			<li>
~IF［
%要素~名~群 の`~size$ ~EQ 1
］~AND［
%要素~名~群[ 0 ] ~EQ `*^l
］
⇒
~RET ~T
</li>
			<li>
<p>
~IF［
%属性 が`属する要素$の`局所-名$ ~IN %要素~名~群
］
⇒
~RET ~T
</p>

<p class="trans-note">【
%属性 が`属する要素$が ~NULL になることはない
— 少なくとも，この仕様においては。
】</p>
			</li>
		</ol>
	</li>
	<li>
~RET ~F
</li>
</ol>

<p class="trans-note">【
この~algoは、
原文では %~map を成す個別の~entryの値（要素~名の~list）に対し演算するよう述べられているが、
この~algoを呼出している箇所では，
常に %~map 成す各~keyに対し（ `any^en という句を通して）演算しているので、
この訳では，その~logicをこの~algoの冒頭に集約する。
】</p>

◎
To determine whether an attribute matches an attribute match list list, run these steps:
• If attribute’s namespace is not null: Return false.
• If attribute’s local name does not match the attribute match list list’s key and if the key is not "*": Return false.
• Let element be the attribute’s Element.
• Let element name be element’s local name.
• If list’s value does not contain element name and value is not ["*"]: Return false.
• Return true.
</div>

<div class="algo">
<p>
`属性~用の~sanitize動作@
を決定するときは、
所与の
( %属性, `SanitizerConfig$I【！~Sanitizer環境設定~辞書】 %環境設定0 )
に対し，次の手続きを走らす：
◎
To determine the sanitize action for an attribute given a Sanitizer configuration dictionary config, run these steps:
</p>
<ol>
	<li>
%種類 ~LET %属性 の`属性~種類$
◎
Let kind be attribute’s attribute kind.
</li>
	<li>
~IF［
%種類 ~EQ `未知^i
］~AND［
%環境設定0[ "`allowUnknownMarkup$m" ] ~NEQ ~T
］
⇒
~RET `落とす^i
◎
If kind is unknown and if config["allowUnknownMarkup"] does not exist or it config["allowUnknownMarkup"] is false: Return drop.
</li>
	<li>
~IF［
%種類 ~EQ `正則^i
］~AND［
%属性 の`局所-名$attr ~NIN `属性~用の~baseline許容-~list$
］
⇒
~RET `落とす^i
◎
If kind is regular and attribute’s local name does not match any name in the baseline attribute allow list: Return drop.
</li>
	<li>
~IF［
`属性は照合-~mapに合致しているか？$( %属性, %環境設定0[ "`dropAttributes$m" ] ) ~EQ ~T
］
⇒
~RET `落とす^i
◎
If attribute matches any attribute match list in config’s attribute drop list: Return drop.
</li>
	<li>
%許容する属性~群 ~LET %環境設定0[ "`allowAttributes$m" ]
◎
If attribute allow list exists in config:
• Then let allow list be |config|["allowAttributes"].
</li>
	<li>
~IF［
%許容する属性~群 ~EQ ε
］
⇒
%許容する属性~群 ~SET `既定の環境設定$[ "`allowAttributes$m" ]
◎
• Otherwise: Let allow list be the default configuration's attribute allow list.
</li>
	<li>
~IF［
`属性は照合-~mapに合致しているか？$( %属性, %許容する属性~群 ) ~EQ ~F
］
⇒
~RET `落とす^i
◎
If attribute does not match any attribute match list in allow list: Return drop.
</li>
	<li>
~RET `保つ^i
◎
Return keep.
</li>
</ol>
</div>

<div class="algo">
<p>
%要素 の
`要素~種類@
は、［
`正則^i,
`未知^i,
`~custom^i
］いずれかであり，次に従って決定される：
◎
The element kind of an element is one of regular, unknown, or custom. Let element kind be:
</p>
<ol>
	<li>
~IF［
%要素 の`局所-名$は`妥当な~custom要素~名$である
］
⇒
~RET `~custom^i
◎
custom, if element’s local name is a valid custom element name,
</li>
	<li>
~IF［
%要素 は~HTML名前空間 `HTML$r に属さない
］
⇒
~RET `未知^i
◎
unknown, if element is not in the [HTML] namespace＼
</li>
	<li>
<p>
~IF［
%要素 の`局所-名$は未知な要素を表す
— すなわち， `HTML$r 仕様が %要素 にアテガう`要素~interface$は `HTMLUnknownElement$I である
］
⇒
~RET `未知^i
◎
or if element’s local name denotes an unknown element — that is, if the element interface the [HTML] specification assigns to it would be HTMLUnknownElement,
</p>

<p class="issue">
~interfaceの利用は~~避けたい
（例： `applet^e や `blink^e は `HTMLUnknownElement^I である）。
[`147$issue]
◎
We do not want to use the interface (e.g., "applet" and "blink" are HTMLUnknownElement) [Issue #147]
</p>

</li>
	<li>
~RET `正則^i
◎
regular, otherwise.
</li>
</ol>
</div>

<div class="algo">
<p>
%属性 の
`属性~種類@
は、［
`正則^i, `未知^i
］いずれかであり，次に従って決定される：
</p>
<ul>
	<li>
~RET `HTML$r 仕様は %属性 の名前に何らかの意味を
⇒＃
アテガうならば `正則^i ／
アテガわないならば `未知^i
</li>
</ul>

<p class="issue">
これもまた、
もっと特定にする必要がある
— `歴史的^i, `廃用^i, `適合^i, `不適合^i （例： `bgcolor^a ）。
~sanitizerに特有な対応付けを与える~listが望ましい。
[`147$issue]
</p>

<p class="trans-note">【
上の課題にも指摘されたように、
“何らかの意味をアテガう” の精確な定義は，述べられていない。
（例：`廃用にされた旧来の属性＠~HTMLobs#_non-conforming-attributes$の`属性~種類$は、
どちらになる？）
】</p>
◎
Similarly, the attribute kind of an attribute is one of regular or unknown. Let attribute kind be:
• unknown, if the [HTML] specification does not assign any meaning to attribute’s name.
• Again, this needs to be more specific. Historical, obsolete, conforming, non-conforming (e.g. bgcolor). It is desirable we make a sanitizer-specific list. [Issue #147]
• regular, otherwise.
</div>

		</section>
		<section id="defaults">
<h3 title="Baseline and Defaults">3.5. ~baseline環境設定と既定の環境設定</h3>

<p class="issue">
~sanitizerの［
`~baseline環境設定$, `既定の環境設定$【！baseline and defaults】
］は、
注意深く審査する必要があり，依然として論の最中にある。
以下に与える値は、
~~説明用に限られる。
◎
The sanitizer baseline and defaults need to be carefully vetted, and are still under discussion. The values below are for illustrative purposes only.
</p>

<p>
~sanitizerには、
組込みの`既定の環境設定$がある
— それは、
`~baseline環境設定$【！the baseline】より厳密であり，
~script注入の可能性, および［
旧来の／通例的でない
］構成子は，どれも排することを目指す。
◎
The sanitizer has a built-in default configuration, which is stricter than the baseline and aims to eliminate any script-injection possibility, as well as legacy or unusual constructs.
</p>

<p>
`~baseline環境設定@
は、
`付録 A＠#constants$ にて与える~JSON定数［
`要素~用の~baseline許容-~list$, `属性~用の~baseline許容-~list$
］により定義される。
既定の環境設定【！baseline and defaults】は、
`付録 A＠#constants$ にて与える~JSON定数 `既定の環境設定$により定義される。
◎
The defaults and baseline are defined by three JSON constants, baseline element allow list, baseline attribute allow list, default configuration. For better readability, these have been moved to an appendix A.
</p>

		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">4. ~securityの考慮点</h2>

<p>
~Sanitizer~APIに意図されるのは、
~DOMに基づく~XSS（ `DOM-based Cross-Site Scripting^en ）を防止することである
— 給された~HTML内容を辿って，環境設定に則って［
要素／属性
］を除去することにより。
この~APIの仕様は、［
~script能力がある~markupを残すような `Sanitizer$I ~objの構築
］を~supportしてはナラナイ
— そうすることは、
脅威~modelにおける~bugになろう。
◎
The Sanitizer API is intended to prevent DOM-based Cross-Site Scripting by traversing a supplied HTML content and removing elements and attributes according to a configuration. The specified API must not support the construction of a Sanitizer object that leaves script-capable markup in and doing so would be a bug in the threat model.
</p>

<p>
とは言え、
~Sanitizer~APIの正しい用法では保護-可能でない，~securityの課題はある
— 以下の下位節では、
そのような局面について~~述べる。
◎
That being said, there are security issues which the correct usage of the Sanitizer API will not be able to protect against and the scenarios will be laid out in the following sections.
</p>

		<section id="server-side-xss">
<h3 title="Server-Side Reflected and Stored XSS">4.1. ~server側に反映され, 格納される~XSS</h3>

◎非規範的

<p>
~Sanitizer~APIは、
もっぱら~DOM内で演算する
— それは、
既存の`文書片$を辿って~filterするための能力を追加する。
~Sanitizerは、［
~server側に反映され, 格納される~XSS
］には取組まない。
◎
The Sanitizer API operates solely in the DOM and adds a capability to traverse and filter an existing DocumentFragment. The Sanitizer does not address server-side reflected or stored XSS.
</p>

		</section>
		<section id="dom-clobbering">
<h3 title="DOM clobbering">4.2. ~DOM~clobbering</h3>

◎非規範的

<p>
~DOM~clobbering【 “痛めつけ” 】は、
悪意的な~HTMLで~appを惑わす攻撃である
— そこでは、［
要素の［
`id^a や `name^a
］属性を命名することにより，［
~DOM内の~HTML要素の `children^m の様な~prop
］が悪意的な内容により隠蔽される。
◎
DOM clobbering describes an attack in which malicious HTML confuses an application by naming elements through id or name attributes such that properties like children of an HTML element in the DOM are overshadowed by the malicious content.
</p>

<p>
~Sanitizer~APIは、
既定の状態では，~DOM~clobbering攻撃を保護しないが、
`id^a 属性や `name^a 属性を除去するよう環境設定することはできる。
◎
The Sanitizer API does not protect DOM clobbering attacks in its default state, but can be configured to remove id and name attributes.
</p>

		</section>
		<section id="script-gadgets">
<h3 title="XSS with Script gadgets">4.3. ~script~gadgetを伴う~XSS</h3>

◎非規範的

<p>
~script~gadgetは、
既存の［
普及している~JS~libraryからの~app~code
］を利用して，攻撃者が自前の~codeを実行させる技法である。
これは、［
ある~frameworkに限り，構文解析され解釈される
］ような［
見かけは潔白な~code／不活そうに見える~DOM~node
］を注入することにより行われることが多く、
その入力に基づいて~JSの実行を遂行する。
◎
Script gadgets are a technique in which an attacker uses existing application code from popular JavaScript libraries to cause their own code to execute. This is often done by injecting innocent-looking code or seemingly inert DOM nodes that is only parsed and interpreted by a framework which then performs the execution of JavaScript based on that input.
</p>

<p>
~Sanitizer~APIは、
これらの攻撃は防止できないが，［
次に挙げるものは、
明示的に許容すること
］を~page作者に要求する：
◎
The Sanitizer API can not prevent these attacks, but requires page authors to explicitly allow＼
</p>
<ul>
	<li>
未知な［
属性／要素
］
— これらを許容するためには、
明示的に環境設定しなければナラナイ
◎
unknown elements in general, and authors must additionally explicitly configure unknown attributes and elements＼
</li>
	<li>
［
~template化, ~framework
］に特有な~code用に広く利用されていることが既知な~markup
— ［
`data-$a, `slot$a
］属性や［
`slot$tg, `template$tg
］要素など。
◎
and markup that is known to be widely used for templating and framework-specific code, like data- and slot attributes and elements like &lt;slot&gt; and &lt;template&gt;.＼
</li>
</ul>

<p>
これらの制約は、
網羅的でないと予見される。
~page作者には、［
自身が利用している第三者-主体~libraryを，この挙動に関して精査すること
］が奨励される。
◎
We believe that these restrictions are not exhaustive and encourage page authors to examine their third party libraries for this behavior.
</p>

		</section>
		<section id="mutated-xss">
<h3 title="Mutated XSS">4.4. ~mXSS</h3>

◎非規範的

<p>
~mXSS
（ `Mutated Cross-Site Scripting^en ／ `Mutated XSS^en の略称）は、［
~HTML~code片を不正な文脈の下で構文解析するとき，構文解析器~文脈が合致しないこと
］に基づく攻撃である。
特に，【ある親~要素の中で】~HTML素片を構文解析してから文字列に直列化した結果は、
異なる親~要素の中に挿入されるとき，~~元と正確に同じに［
構文解析され, 解釈される
］ことは保証されない。
そのような攻撃を遂げる例には、［
外来な内容や誤って入子にされた~tagに対し，構文解析の挙動が変化すること
］に依拠するものがある。
◎
Mutated XSS or mXSS describes an attack based on parser context mismatches when parsing an HTML snippet without the correct context. In particular, when a parsed HTML fragment has been serialized to a string, the string is not guaranteed to be parsed and interpreted exactly the same when inserted into a different parent element. An example for carrying out such an attack is by relying on the change of parsing behavior for foreign content or misnested tags.
</p>

<p>
~Sanitizer~APIは、
~mXSSに抗する助けを提供するが，開発者による ある程度の協力にも依拠する。
`sanitize()$m ~method【！function】は、
文字列を取扱わないので影響されない。
`setHTML()$m ~method【！function】は、
~sanitizationと~DOM改変を組合せて，正しい文脈を暗黙的に適用できる。
`sanitizeFor()$m ~method【！function】は、
構文解析と~sanitizationを組合せるが，
その結果の最終的な適用は開発者が正しい文脈を給することに依拠する。
◎
The Sanitizer API offers help against Mutated XSS, but relies on some amount of cooperation by the developers.＼
The sanitize() function does not handle strings and is therefore unaffected.＼
The setHTML function combines sanitization with DOM modification and can implicitly apply the correct context.＼
The sanitizeFor() function combines parsing and sanitization, and relies on the developer to supply the correct context for the eventual application of its result.
</p>

<p>
~sanitizeされる~dataが~node~treeとして可用な場合、
作者には， `sanitize()$m ~method【！function】を利用することが奨励される
— それは、
`文書片$を返すことに加え，
直列化と追加的な構文解析につきまとう~riskを避ける。
~sanitizeした結果の文書片に対し直に演算すれば、
直列化と構文解析による追加的な~costも避けられるので，処理能の便益もついてくる。
◎
If the data to be sanitized is available as a node tree, we encourage authors to use the sanitize() function of the API which returns a DocumentFragment and avoids risks that come with serialization and additional parsing. Directly operating on a fragment after sanitization also comes with a performance benefit, as the cost of additional serialization and parsing is avoided.
</p>

<p>
~mXSSに対する，より完全な扱いは、
`MXSS$r にて見出せる。
◎
A more complete treatement of mXSS can be found in [MXSS].
</p>

		</section>
	</section>
	<section id="ack">
<h2 title="Acknowledgements">5. 謝辞</h2>

<p>
［
`Cure53^en の `DOMPURIFY$r
］による［
この文書が述べる~API
］用の明瞭な発想に。
`Internet Explorer^en の
`window.toStaticHTML()＠https://msdn.microsoft.com/en-us/library/cc848922(v=vs.85).aspx$c
にも。
◎
Cure53’s [DOMPURIFY] is a clear inspiration for the API this document describes, as is Internet Explorer’s window.toStaticHTML().
</p>

	</section>
	<section id="constants">
<h2 title="Appendix A: Built-in Constants">付録 A. 組込みの定数</h2>

<p>
`この付録は、
他が明示的に注記された所を除き，規範的である。^em
◎
This appendix is normative, except where explicitly noted otherwise.
</p>

<p>
これらの定数は、
~Sanitizer~algoの中核を成す挙動を定義する。
◎
These constants define core behaviour of the Sanitizer algorithm.
</p>

		<section id="builtins-justification">
<h3 title="Built-ins Justification">組込みの【環境設定の】正当性</h3>

<p>
`この下位節は、
まだまだ規範的でない。^em
◎
This subsection is super duper non-normative.
</p>

<p class="note">注記：
これらの定数を成す規範的な値は、
以下に見出される。
これらの由来は、［
`DEFAULTS$r による~script
］による実装と伴に，ここに説明される。
これらの値は、
この仕様が完結する前に変更されるものと予期される。
これらはまた、
追加的な~HTML要素が~UAに導入されるに伴い，
それを含むよう更新されるものと期待される。
◎
Note: The normative values of these constants are found below. The derivation of these are explained here, with an implementation in the [DEFAULTS] script. It is expected that these values will change before this specification is finalized. Also, we expect these to be updated to include additional HTML elements as they are introduced in user agents.
</p>

<p>
~Sanitizer~APIの目的においては、
`HTML$r の構成子は，次に挙げる 4 種に~~分類される。
1 種目は`~baseline環境設定$【！the baseline】を定義する／
2 種目, 3 種目は`既定の環境設定$【！the default】を定義する：
◎
For the purpose of this Sanitizer API, [HTML] constructs fall into one of four classes, where the first defines the baseline, and the first, second, plus the third define the default:
</p>
<ol>
	<li>
［
要素／属性
］のうち，~scriptを（直に）実行するもの。
言い換えれば、
無条件に~script的な［
要素／属性
］。
◎
Elements and attributes that (directly) execute script. In other words, elements and attributes that are unconditionally script-ish.
</li>
	<li>
旧来の “困難な” ［
要素／属性
］
— 例：`plaintext$tg, `xmp$tg, 特別な構文解析~規則が伴われる要素。
これらは、
それ自体は危険でないが，既存の脆弱性に寄与していた。
◎
Legacy and "difficult" elements and attributes. Examples are the &lt;plaintext&gt; &lt;xmp&gt; and elements, which have special parsing rules attached to them. These are not dangerous _per se_, but they have contributed to existing vulnerability.
</li>
	<li>
［
要素／属性
］のうち，［
利用者が給する内容においてイミを成すのは、
稀である
］と感じられるもの。
◎
Elements and attributes that we feel rarely make sense in user-supplied content.
</li>
	<li>
残りすべて。
◎
All the rest.
</li>
</ol>

<p>
特定的には：
◎
Specifically:
</p>
<ol>
	<li>
<p>
~script的な構成子は：
◎
Script-ish constructs:
</p>
		<ul>
			<li>
`HTMLScriptElement$I
【を実装する要素（以下同様）】
— これは、
もっぱら，~scriptを実行することを目的とする。
◎
The HTMLScriptElement, which proudly executes script as its sole purpose.
</li>
			<li>
すべての`~event~handler内容~属性$
— これらも、
~scriptを実行するので。
◎
All event handler attributes, since these also execute script.
</li>
			<li>
`HTMLIFrameElement$I
— これもまた、
任意な~HTML内容を読込むので，~scriptである。
◎
HTMLIFrameElement, which loads arbitrary HTML content and therefor also script.
</li>
			<li>
旧来の［
`HTMLObjectElement$I ／ `HTMLEmbedElement$I
］
— これらは、
~HTMLでない能動的な内容を読込む。
および，前者（ `object$tg ）の “助手” `HTMLParamElement$I も。
◎
The legacy HTMLObjectElement and HTMLEmbedElement, which load non-HTML active content. Also, &lt;object&gt;’s side-kick HTMLParamElement.
</li>
			<li>
`もはや適合でない＠~HTMLobs#non-conforming-features$［
`frame$tg,
`frameset$tg,
`applet$tg
］
— これらは、
上に挙げた要素と同類な，旧式な~versionである。
◎
The no-longer conforming &lt;frame&gt;, &lt;frameset&gt;, and &lt;applet&gt; tags, which are outdated versions companions of several elements listed above.
</li>
			<li>
<p>
［
`noscript$tg,
`noframes$tg,
`noembed$tg,
`nolayer^tg†
］要素。
これらは，それ自体は紛れもなく~script的なものではないが、
上に挙げた要素と併用されるものであり，それ自体ではイミを成さない。
</p>

<p class="trans-note">【†
`nolayer^tg は、
過去に標準~化されたこともない。
】</p>
◎
The &lt;noscript&gt;, &lt;noframes&gt;, &lt;noembed&gt;, and &lt;nolayer&gt; elements. These, by themselves, are arguably not script-ish, but they are companions to elements listed above, and make no sense on their own.
</li>
			<li>
`HTMLBaseElement$I
— これは、
他の~URLの解釈を実質的に改変するので。
◎
Also, the HTMLBaseElement, as this effectively modifies interpretation of other URLs.
</li>
		</ul>
	</li>
	<li>
<p>
旧来の “困難な” 要素は：
◎
Legacy and "difficult" elements.
</p>
		<ul>
			<li>
<p>
次に挙げる，特別な構文解析の挙動を伴うもの。
これらは、
それ自体は危険でないが，~mXSS攻撃に寄与していた：
◎
Special parsing behaviour. This is not dangerous in its own right, but has contributed to mXSS-style attacks. This includes:
</p>
				<ul>
					<li>
`plaintext$tg
（これは、
`PLAINTEXT state＠~HTMLparsing#plaintext-state$
内で構文解析される。）
◎
&lt;plaintext&gt; (Which parses in PLAINTEXT state.)
</li>
					<li>
`title$tg, `textarea$tg
（これは、
`RCDATA state＠~HTMLparsing#rcdata-state$
内で構文解析される。）
◎
&lt;title&gt; and &lt;textarea&gt; (Which parse in RCDATA state.)
</li>
					<li>
不適合な `xmp$tg 要素。
◎
The non-conforming [&lt;xmp&gt;](https://html.spec.whatwg.org/#xmp) element.
</li>
				</ul>
			</li>
			<li>
<p>
旧来の要素：
◎
Legacy elements:
</p>
				<ul>
					<li>
`image^tg
（これは、
`~body~mode＠~HTMLparsing#parsing-main-inbody$内で `img$tg として構文解析される）。
◎
&lt;image&gt; ([which is parsed as &lt;img&gt;](https://html.spec.whatwg.org/#parsing-main-inbody)).
</li>
					<li>
`basefont$tg
◎
&lt;basefont&gt;
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
<p>
利用者が給する内容において有益になるとは，およそ見込まれない構成子は：
◎
Constructs unlikely to be beneficial in user-supplied content:
</p>
		<ul>
			<li>
`HTMLTemplateElement$I, `HTMLSlotElement$I
— 前者は、
もっぱら~JSから利用される新たな~templateを導入する／
後者は、
前者の片棒を担ぐ。
◎
The HTMLTemplateElement, which introduces a new template to be used by JavaScript, and its HTMLSlotElement accomplice.
</li>
			<li>
~frame の様な `HTMLPortalElement$I
◎
The frame-like HTMLPortalElement.
</li>
			<li>
`HTMLDataElement$I
◎
HTMLDataElement,
</li>
			<li>
（非推奨にされた） `allowpaymentrequest$a 属性。
◎
The (deprecated) allowpaymentrequest attribute.
</li>
		</ul>
	</li>
</ol>

		</section>
		<section id="baseline-elements">
<h3 title="The Baseline Element Allow List">要素~用の~baseline許容-~list</h3>

<p>
組込みの
`要素~用の~baseline許容-~list@
は、
次で与えられる：
◎
The built-in baseline element allow list has the following value:
</p>

`baseline-elements^dgm

		</section>
		<section id="baseline-attributes">
<h3 title="The Baseline Attribute Allow List">属性~用の~baseline許容-~list</h3>

<p>
`属性~用の~baseline許容-~list@
は、
次で与えられる：
◎
The baseline attribute allow list has the following value:
</p>

`baseline-attributes^dgm

		</section>
		<section id="default-configuration-dictionary">
<h3 title="The Default Configuration Dictionary">既定の環境設定~辞書</h3>

<p>
組込みの
`既定の環境設定@
は、
次で与えられる：
◎
The built-in default configuration has the following value:
</p>

`default-configuration-dictionary^dgm

		</section>
	</section>
</main></div>

