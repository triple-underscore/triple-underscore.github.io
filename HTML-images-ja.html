<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML — Images 他 ( Embedded content )（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		persisted_parts: Util.collectHtmlCodeList(),
		collectParts: Util.collectParts,
		toc_main: 'MAIN',
		generate: expand
	};

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'mS':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 't':
	text = `&lt;${text}&gt;`;
	break;
case 'tag':
	text = `&lt;${text}&gt;`;
	break;
case 'U': 
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'xCode':
	return `<a id="_ex-${key}">＊</a>`;
	break;
case 'AA':
	return `<a href="~HTMLARIA#el-${key}">作者~向け</a>／<a href="~HTMLAAM#el-${key}">実装者~向け</a>`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2020-05-19
trans_update:2020-05-21
source_checked:191126
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/embedded-content.html
nav_prev:HEedits
nav_next:HEembed
trans_1st_pub:2017-02-20

●●class_map
e:element
E:error
a:attr
aS:attr
aL:attr
et:event-type
p:property
t:type
st:attr-state
css:css
v:value
h:header
U:code-point

●●tag_map
I:code
m:code
mS:code
mA:code
mD:code
E:code
c:code
tag:code
e:code
a:code
aS:code
aL:code
et:code
mt:code
st:span
h:code
p:code
t:var
css:code
U:span
v:code
i:i
em:em

●●original_urls
images:https://html.spec.whatwg.org/multipage/images.html
the-map-element:https://html.spec.whatwg.org/multipage/image-maps.html
the-area-element:https://html.spec.whatwg.org/multipage/image-maps.html
image-maps:https://html.spec.whatwg.org/multipage/image-maps.html


●●original_id_map

●●mdn_urls
the-area-element:HTML/Element/area
the-img-element:HTML/Element/img
the-map-element:HTML/Element/map
the-source-element:HTML/Element/source
the-picture-element:HTML/Element/picture

htmlimageelement:API/HTMLImageElement
htmlpictureelement:API/HTMLPictureElement
htmlsourceelement:API/HTMLSourceElement
htmlmapelement:API/HTMLMapElement
htmlareaelement:API/HTMLAreaElement

●●link_map

CEReactions:~HEcustom#cereactions
HTMLConstructor:~HTMLdom#htmlconstructor
LegacyFactoryFunction:~WEBIDLjs#LegacyFactoryFunction

E.EncodingError:~WEBIDL#encodingerror

I.Document:~HTMLdom#document
文書:~HTMLdom#the-document-object
I.HTMLElement:~HTMLdom#htmlelement
I.HTMLImageElement:#htmlimageelement
I.HTMLPictureElement:#htmlpictureelement
I.HTMLSourceElement:#htmlsourceelement
I.HTMLCollection:~DOM4#interface-htmlcollection
I.HTMLMapElement:#htmlmapelement

I.DOMTokenList:~DOM4#interface-domtokenlist
I.HTMLAreaElement:#htmlareaelement
I.HTMLHyperlinkElementUtils:~HTMLlinks#htmlhyperlinkelementutils

m.Image:#dom-image
m.alt:#dom-img-alt
m.areas:#dom-map-areas
m.complete:#dom-img-complete
m.createElement:~DOM4#dom-document-createelement
m.crossOrigin:#dom-img-crossorigin
m.currentSrc:#dom-img-currentsrc
m.decoding:#dom-img-decoding
m.height:#dom-img-height
m.isMap:#dom-img-ismap
m.loading:#dom-img-loading
m.name:#dom-map-name
m.naturalHeight:#dom-img-naturalheight
m.naturalWidth:#dom-img-naturalwidth
m.referrerPolicy:#dom-img-referrerpolicy
m.requestAnimationFrame:~HTMLGAPI#dom-animationframeprovider-requestanimationframe
m.decode:#dom-img-decode
m.sizes:#dom-img-sizes
m.src:#dom-img-src
m.srcset:#dom-img-srcset
m.useMap:#dom-img-usemap
m.value:~DOM4#dom-domtokenlist-value
m.width:#dom-img-width


mS.media:#dom-source-media
mS.sizes:#dom-source-sizes
mS.src:~HEmedia#dom-source-src
mS.srcset:#dom-source-srcset
mS.type:#dom-source-type

mA.alt:#dom-area-alt
mA.coords:#dom-area-coords
mA.download:#dom-area-download
mA.ping:#dom-area-ping
mA.referrerPolicy:#dom-area-referrerpolicy
mA.rel:#dom-area-rel
mA.relList:#dom-area-rellist
mA.shape:#dom-area-shape
mA.target:#dom-area-target

mD.width:#dom-dim-width
mD.height:#dom-dim-height


et.error:~HTMLindex#event-error
et.load:~HTMLindex#event-load

e.img:#the-img-element
e.picture:#the-picture-element
e.source:#the-source-element
e.area:#the-area-element
e.map:#the-map-element

e.audio:~HEmedia#the-audio-element
e.video:~HEmedia#the-video-element
e.track:~HEtrack#the-track-element

e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.object:~HEembed#the-object-element

e.input:~HEinput#the-input-element
e.a:~HEtextlevel#the-a-element
e.button:~HEforms#the-button-element
e.canvas:~HEcanvas#the-canvas-element
e.figure:~HEgrouping#the-figure-element
e.figcaption:~HEgrouping#the-figcaption-element
e.link:~HEmetadata#the-link-element

aS.media:#attr-source-media
aS.sizes:#attr-source-sizes
aS.src:~HEmedia#attr-source-src
aS.srcset:#attr-source-srcset
aS.type:#attr-source-type

aL.imagesrcset:~HEmetadata#attr-link-imagesrcset
aL.imagesizes:~HEmetadata#attr-link-imagesizes
aL.href:~HEmetadata#attr-link-href

a.alt:#attr-img-alt
a.crossorigin:#attr-img-crossorigin
a.decoding:#attr-img-decoding
a.loading:#attr-img-loading
a.href:~HTMLlinks#attr-hyperlink-href
a.id:~HTMLdom#the-id-attribute
a.ismap:#attr-img-ismap
a.name:#attr-map-name
a.referrerpolicy:#attr-img-referrerpolicy
a.sizes:#attr-img-sizes
a.src:#attr-img-src
a.srcset:#attr-img-srcset
a.title:~HTMLdom#attr-title
a.usemap:#attr-hyperlink-usemap
a.height:~HEembed#attr-dim-height
a.width:~HEembed#attr-dim-width

a.~alt0:#attr-area-alt
a.coords:#attr-area-coords
a.shape:#attr-area-shape

a.download:~HTMLlinks#attr-hyperlink-download
a.itemprop:~HTMLLS/microdata.html#names:-the-itemprop-attribute
a.ping:~HTMLlinks#ping
a.~referrerpolicy0:~HTMLlinks#attr-hyperlink-referrerpolicy
a.rel:~HTMLlinks#attr-hyperlink-rel
a.target:~HTMLlinks#attr-hyperlink-target

v.sync:#attr-img-decoding-sync
v.async:#attr-img-decoding-async
v.auto:#attr-img-decoding-auto

v.circle:#attr-area-shape-keyword-circle
v.circ:#attr-area-shape-keyword-circ
v.default:#attr-area-shape-keyword-default
v.poly:#attr-area-shape-keyword-poly
v.polygon:#attr-area-shape-keyword-polygon
v.rect:#attr-area-shape-keyword-rect
v.rectangle:#attr-area-shape-keyword-rectangle
v.generator-unable-to-provide-required-alt:#attr-img-generator-unable-to-provide-required-alt

st.Sync:#attr-img-decoding-sync-state
st.Async:#attr-img-decoding-async-state
st.Auto:#attr-img-decoding-auto-state

st.~NoCORS:~HTMLurl#attr-crossorigin-none

st.真円:#attr-area-shape-circle
st.既定:#attr-area-shape-default
st.多角形:#attr-area-shape-poly
st.矩形:#attr-area-shape-rect

st.Lazy:~HTMLurl#attr-loading-lazy-state
st.Eager:~HTMLurl#attr-loading-eager-state


t.length:~CSSVAL#lengths
t.media-condition:~MQ4#typedef-media-condition
t.source-size-value:#source-size-value
t.source-size:#source-size

h.Cache-Control:~RFC7234#section-5.2
mt.multipart/x-mixed-replace:~HTMLiana#multipart/x-mixed-replace
v.must-revalidate:~RFC7234#section-5.2.2.1

p.height:~CSS2VISUDET#the-height-property
p.width:~CSS2VISUDET#the-width-property
p.aspect-ratio:~CSSWG/css-sizing-4/#propdef-aspect-ratio
p.image-orientation:~CSSIMAGE#the-image-orientation

css.px:#px
css.vw:~CSSVAL#vw
css.in:~CSSVAL#in
~CSS~inch:~CSSVAL#in
~CSS~pixel:~CSSVAL#px


t.length:~CSSVAL#lengths
t.media-condition:~MQ4#typedef-media-condition
t.whitespace-token:~CSSSYN#typedef-whitespace-token
t.source-size-list:#source-size-list
t.source-size-value:#source-size-value


	●用語
画像~fetch~task:#_img-fetch-task

全部的に復号-可能:#img-good
可用:#img-available
画像は可用:#img-available
状態:#img-req-state
st.壊en:#img-error
st.完全に可用:#img-all
st.部分的に可用:#img-inc
st.不可用:#img-none
現在の~URL:#img-req-url
	#img-load
画像~data:#img-req-data

復号-:#img-decoding-process
画像~復号~hint:#image-decoding-hint

画像~要請:#image-request
現在の要請:#current-request
処理待ち要請:#pending-request
画像~要請を中止する:#abort-the-image-request
処理待ち要請を現在の要請に昇格する:#upgrade-the-pending-request-to-the-current-request

§ 画像~用の代替として動作する~textを供するときの要件:~HEimageAlt#alt

表示域に基づく選定:#viewport-based-selection
画像~形式に基づく選定:#image-format-based-selection
~art-direction:#art-direction

画像~dataを更新する:#update-the-image-data
画像~sourceを選定する:#select-an-image-source
~source集合を更新する:#update-the-source-set
~srcset属性を構文解析する:#parse-a-srcset-attribute
~sizes属性を構文解析する:#parse-a-sizes-attribute
~source密度を正規化する:#normalise-the-source-densities

現在の画素~密度:#current-pixel-density
密度補正済み内在的~size:#density-corrected-intrinsic-width-and-height

	#img-determine-type

画像~source:#image-source
iS.~URL文字列:#_image-source-url
iS.記述子:#_image-source-descriptor


	~described上:#unknown-images
機器画素比:#device-pixel-ratio


画像~候補~文字列:#image-candidate-string
画素~密度~記述子:#pixel-density-descriptor
横幅~記述子:#width-descriptor
密度~値:#pixel-density-descriptor-value
	画素~密度~記述子~値／値
横幅~値:#width-descriptor-value
	横幅~記述子~値:#width-descriptor-value
妥当な~source~size~list:#valid-source-size-list
構文解析-~error:#concept-microsyntax-parse-error


最後に選定された~source:#last-selected-source
可用な画像~list:#list-of-available-images
上層~cachingは無視する~flag:#ignore-higher-layer-caching

関連な変異:#relevant-mutations

~sizes属性:#sizes-attribute
~source集合:#source-set
~srcset属性:#srcset-attribute
~source~size:#source-size-2
~srcsetまたは~pictureを利用して:#use-srcset-or-picture

寸法~属性:~HEembed#dimension-attributes
画像~map:#image-map
~media要素:~HEmedia#media-element
~media資源:~HEmedia#media-resource

	●用語（HTML
~hardware制限:~HTMLINFRA#hardwareLimitations
並列的:~HTMLINFRA#in-parallel
~live:~HTMLINFRA#live
文書の中へ挿入された:~HTMLINFRA#insert-an-element-into-a-document
node.挿入された:~HTMLINFRA#nodes-are-inserted
node.除去された:~HTMLINFRA#nodes-are-removed

反映して:~HTMLcdom#reflect
反映する:~HTMLcdom#reflect
既知な値のみに制限され:~HTMLcdom#limited-to-only-known-values

~lazy読込ng属性:~HTMLurl#lazy-loading-attribute
~lazyに読込むことになる:~HTMLurl#will-lazy-load-element-steps
~lazyに読込まれるに準備済み~flag:~HTMLurl#ready-to-be-lazy-loaded
~lazyに読込んでいる要素の交差~観測ngを開始する:~HTMLurl#start-intersection-observing-a-lazy-loading-element
~lazyに読込んでいる要素の交差~観測ngを停止する:~HTMLurl#stop-intersection-observing-a-lazy-loading-element

~referrer施策~属性:~HTMLurl#referrer-policy-attribute
~CORS設定群~属性:~HTMLurl#cors-settings-attribute
~CORS非同一-生成元:~HTMLurl#cors-cross-origin
~CORS同一-生成元:~HTMLurl#cors-same-origin
~CORSになり得る要請を作成する:~HTMLurl#create-a-potential-cors-request
結付けられている~Content-Type~header:~HTMLurl#content-type
非安全~応答:~HTMLurl#unsafe-response
相対的に構文解析-:~HTMLurl#parse-a-url
結果の~URL文字列:~HTMLurl#resulting-url-string
結果の~URL~record:~HTMLurl#resulting-url-record
妥当かつ空でない~URL:~HTMLurl#valid-non-empty-url
前後~空白~可の妥当かつ空でない~URL:~HTMLurl#valid-non-empty-url-potentially-surrounded-by-spaces

環境に合致して:~HTMLcms#matches-the-environment
真偽~属性:~HTMLcms#boolean-attribute
列挙d属性:~HTMLcms#enumerated-attribute
値なし用の既定:~HTMLcms#missing-value-default
妥当でない値~用の既定:~HTMLcms#invalid-value-default
妥当な浮動小数点数:~HTMLcms#valid-floating-point-number
妥当な媒体~query~list:~HTMLcms#valid-media-query-list
妥当な負でない整数:~HTMLcms#valid-non-negative-integer
妥当な浮動小数点数~list:~HTMLcms#valid-list-of-floating-point-numbers
寸法~値として構文解析する:~HTMLcms#rules-for-parsing-dimension-values
妥当な~hash名~参照:~HTMLcms#valid-hash-name-reference

浮動小数点数として構文解析する:~HTMLcms#rules-for-parsing-floating-point-number-values
負でない整数として構文解析する:~HTMLcms#rules-for-parsing-non-negative-integers
浮動小数点数~listとして構文解析する:~HTMLcms#rules-for-parsing-a-list-of-floating-point-numbers
~hash名~参照として構文解析する:~HTMLcms#rules-for-parsing-a-hash-name-reference


分類:~HTMLdom#concept-element-categories
内容~属性:~HTMLdom#concept-element-attributes
内容~model:~HTMLdom#concept-element-content-model
この要素を利用できる文脈:~HTMLdom#concept-element-contexts
~accessibilityの考慮点:~HTMLdom#concept-element-accessibility-considerations
~DOM~interface:~HTMLdom#concept-element-dom
大域~属性:~HTMLdom#global-attributes
対話的~内容:~HTMLdom#interactive-content-2
なし:~HTMLdom#concept-content-nothing
可触~内容:~HTMLdom#palpable-content-2
句ng内容:~HTMLdom#phrasing-content-2
text/html における~tag省略:~HTMLdom#concept-element-tag-omission
埋込d内容:~HTMLdom#embedded-content-category
~fallback内容:~HTMLdom#fallback-content
~flow内容:~HTMLdom#flow-content-2
要素間~空白:~HTMLdom#inter-element-whitespace
表現-:~HTMLdom#represents
参照-:~HTMLdom#referenced
~scriptを~supportする要素:~HTMLdom#script-supporting-elements-2
透過的:~HTMLdom#transparent


~event~loop:~WAPI#event-loop
同期区間:~WAPI#synchronous-section
安定~状態を待受ける:~WAPI#await-a-stable-state
~task源:~WAPI#task-source
~task:~WAPI#concept-task
~DOM操作~task源:~WAPI#dom-manipulation-task-source
~network用~task源:~WAPI#networking-task-source
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
要素~taskを~queueする:~WAPI#queue-an-element-task
小taskを~queueする:~WAPI#queue-a-microtask
現在の大域~obj:~WAPI#current-global-object
関連な設定群~obj:~WAPI#relevant-settings-object
~script:~WAPI#concept-script
用の~scriptingは不能化されて:~WAPI#concept-n-noscript
描画を更新する:~WAPI#update-the-rendering

~animation~frame~callback~map:~HTMLGAPI#list-of-animation-frame-callbacks

doc.作動中:~BROWSERS#active-document
閲覧文脈:~BROWSERS#browsing-context

結付けられている文書:~WINDOW#concept-document-window
生成元:~ORIGIN#concept-origin

~navi:~NAVI#navigate

~hyperlink:~HTMLlinks#hyperlink
~hyperlinkを~downloadする:~HTMLlinks#downloading-hyperlinks
~hyperlinkを追う:~HTMLlinks#following-hyperlinks-2

~focus可能な区画:~HTMLinteraction#focusable-area
~formに所有され得る要素:~HEforms#form-associated-element

具現化されて:~HTMLrendering#being-rendered
~animationを開始し直す:~HTMLrendering#restart-the-animation

終了tag:~HTMLwriting#syntax-end-tag
~load~eventを遅延-:~HTMLparsing#delay-the-load-event


	●用語（外部
実装定義:~INFRA#implementation-defined
位置~変数:~INFRA#string-position-variable
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII大小無視:~INFRA#ascii-case-insensitive
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
~ASCII空白を読飛ばす:~INFRA#skip-ascii-whitespace
~ASCII空白:~INFRA#ascii-whitespace
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
~HTML名前空間:~INFRA#html-namespace

~URL:~URL1#concept-url
絶対~URL:~URL1#absolute-url-string

受入-時の手続き:~DOM4#concept-node-adopt-ext
接続されて:~DOM4#connected
要素を作成する:~DOM4#concept-create-element
文書~要素:~DOM4#document-element
~eventを発火する:~DOM4#concept-event-fire
~node文書:~DOM4#concept-node-document
属性~値を設定する:~DOM4#concept-element-attributes-set-value
~tree:~DOM4#concept-tree
~tree順序:~DOM4#concept-tree-order
作動化の挙動:~DOM4#eventtarget-activation-behavior

~fetch:~FETCH#concept-fetch
	~fetching:~FETCH#concept-fetch
~network~error:~FETCH#concept-network-error
~ok状態s:~FETCH#ok-status
	応答~状態s:~FETCH#concept-response-status
rq.~client:~FETCH#concept-request-client
rq.起動元:~FETCH#concept-request-initiator
rq.~referrer施策:~FETCH#concept-request-referrer-policy
rq.同期~flag:~FETCH#synchronous-flag

~MIME型:~MIMESNIFF#mime-type
画像を特定的に~sniffするための規則:~MIMESNIFF#rules-for-sniffing-images-specifically
妥当な~MIME型~文字列:~MIMESNIFF#valid-mime-type

~referrer施策:~REFERRER-POLICY#referrer-policy

~math関数:~CSSVAL#math-function
成分~値:~CSSSYN#component-value
内在的~寸法:~CSSIMAGE#intrinsic-dimensions
	内在的~縦横比:~CSSIMAGE#intrinsic-aspect-ratio
内在的~横幅:~CSSIMAGE#intrinsic-width
内在的~縦幅:~CSSIMAGE#intrinsic-height

塗り~source:~CSSIMAGE4#paint-source
~comma区切りの成分~値~listとして構文解析する:~CSSSYN#parse-a-comma-separated-list-of-component-values
表示域:~CSS2VISUREN#viewport


●●words_table1

HEimageAlt:HTML-image-alt-ja.html

alt0:alt
referrerpolicy0:referrerpolicy
undefined:<span class="js-value">undefined</span>


●●words_table

	●仕様
選択肢:option::~::オプション
先取的に:aggressiveに:先取りして
補足的:supplemental:~
補足:supplementary:~
流儀:fashion:~
	- ／ようにして:fashion
自由:free:~
原始的:rudimentary:~

	必要:necessarily
	すなわち，:i.e。
	できない:unable to
	他方、:on the other hand,
	ヨイ:may
	特殊:special
	理想:ideally
	悪化:worse
	加えて:furthermore,
	抗して:against
	ごく:very
	早くに as soon as
	目につくほど:notable
	なりかねない:potentially
	人達:people
	の好み:like
	見込まれ:likely
	したいであろう:would like to
	次の様に:look like

	●仕様（動詞
強いら:forceさ:~
	要がある:require
適応-:adapt:~
適応的:adaptive:~
	適用-可能な／与えられていれば:applicable
排他的:exclusive:~

付帯-:accompany:~
	代替として:alternatively
代用:replacement:~
伝達-:convey:~
	著作-法:authoring
冗長:redundant:~
漸増的に:incremental mannerで:~
条項:clause:~
念頭:mind:~
概略的:brief:~
本当の:real:~
機会:chance:~
出荷-:ship:~
経た:experienceした:~
助け:help:~
	易くする:help
契約:contract:~
違約-:break:~
尊重-:respect:~

	影響されない:unaffected
	遂げる:carry out
	~list:array
	用-法:how to use
	からなる:consisting／consists of
	同順の:retaining relative order
	との併用:in conjunction with
	併用-:used together
	併用-:together with
	に応じて:depending on
	いてよい／省略時:optionally
	似た見かけの:similar-looking
	同様の:similar な
	予め除外:preclude
	問いへ導く:leads to a question
	困惑させる:confusing
	how
	呼ばれている:referred to as
	-:When asked to 
	同一視される referred to as
	し易くなるよう:to ease
	-:responsible
	~~説明:Description
	という:said to be
	すなわち、:This means
	〜に注意。:Notice that
	~~供する:create

	●fetch／network／navi
NoCORS:No CORS
Content-Type:
caching::::キャッシュ処理
sniff:
ok:
hash::::ハッシュ
port-scan:port scan:::ポートスキャン
	~server側:server-side
ping:
load:
	再~download:re-download
lazy:
eager:
	後回し:lazy
	早急:eager
上層:higher-layer:~
二重:double:~
本体部位:body part::~::ボディパート
	crossorigin
非安全:unsafe::~
速度:speed:~
可変速:variable-speed:~
高速:fast:~
低速:slow:~
	短い:low-
	長い:high-
定額制:constant-cost:~
従量制:variable-cost:~
	従量課金:pay by the byte
帯域幅:bandwidth:~
progressive::::プログレッシブ
packet::::パケット
	仕事場:at work
	家:at home
追う:followする:~

	●処理（一般
小task:microtask::小 task:小タスク
	scriptあり:scripted
main::::メイン
必要時:on demand:~
	あり得る:possible
同期区間:synchronous section::~
待受ける:awaitする::待ち受ける
形:form:~
	復号-可能:decodable
復号:decoding::~::デコード処理
	復号:decoding process
候補:candidate:~
処理待ち:pending:~
壊en:broken:壊れている
	壊れている:corrupted
不可用:unavailable:~
致命的:fatal:~
安定:stable::~
昇格-:upgrade::~
不可分:atomic::~
費やさ:elapseさ:~
修復-:repair:~
抹消-:evict:~
割振れる:allocateできる:割り振れる
受入-:adopt:~
観測ng:observing::観測
交差:intersection::~
	交差~観測ng:intersection-observing

	以降:rest
	再度~走らせ:rerun
	開始し直す:restart
	先立って:ahead of
	かかった時間:amount of time it takes
	同時:at the same time
	GOTO:jump to the step labeled／ return to the step labeled
	CORS属性~状態:corsAttributeState
	URL文字列:urlString
	先送り可否:deferral

	●IDL／型／構造
真:true::~
偽:false::~
浮動小数点数:floating-point number:~

	on setting
	instance化:instantiate
	子である:contained
	子たち:children

	●構文
comma::::カンマ
区切りの:-separated:~
終了tag:end tag::終了 tag:終了タグ
	token化:tokenizer
未解析:unparsed::~::未パースの
丸括弧:parentheses:~
読飛ばす:skipする:読み飛ばす
省略不可:omissibleでない:~
省略:omission:~
	有していない:omitted
不一致:mismatch:~
剥ぐ:stripする:~

	丸括弧:parens
	LEFT PARENTHESIS
	EOF
	RIGHT PARENTHESIS
	COMMA
	LATIN SMALL LETTER

	●媒体／呈示／画像／UI
PNG:
GIF:
JPEG:
PDF:
APNG:
SMIL:
MNG:
WebP:
JPEG-XR:JPEG XR
picture:
srcset:
sizes:
zoom::::ズーム
	~animate化:animated
art-direction:art direction::art 演出:アート演出
display::::ディスプレイ
column::::カラム
再flow:reflow:::再フロー:リフロー
	~graphicな:graphical
monitor::::モニタ
laptop::::ノートパソコン
	media:medium
単page:single-page::単 page:単ページ
複page:multipage::複 page:複ページ
多page:paged:::複ページ
	最~大:biggest
	最~小:smallest

装飾的:decorative:~
	環境~上の:environmental
携帯:mobile::~::モバイル
	携帯~機:mobile
電話:phone::~
視覚障碍:visual disability:~
盲目の:blind:~
刊行:publication:~
縦横比:aspect ratio:~

	OCR
比べ:compareして:~
	に比して:relative to
pointing::::ポインタ指示
選択-:select:~
被選定:selected:選定された
変形-:transform:~
	見られ:view
塗り:paint:~
塗られ:paintされ:~

	周りにずれる:shifting around

	●幾何
inch::::インチ
resize::::リサイズ
pixel::::ピクセル
画素:pixel::~::ピクセル
	画像でない:non-image
解像度:resolution:~
描画size:rendered size:描画 size::描画サイズ
機器画素比:device-pixel-ratio::~
比:ratio::~
回転:rotation::~
	縦幅:future-compat-h
縦:vertical::~
横:horizontal::~
密度:density::~
密度補正済み:density corrected::~
半分:half:~
	直立:upright
	真横に倒され:90 degrees rotate
	対角線:diagonal
	切り抜いた:crop
真円:circle:~
矩形:rectangle:~
多角形:polygon:~
無反応:dead::~
図形:shape::~
座標s:coords::座標 list:座標リスト
中心:center:~
半径:radius:~
幾何的:geometric:~
内域:interior:~
even-odd:
多層化-:layer::~
覆う:coverする:~
伸張-:stretch:~
	左上隅:top-left corner
	右下隅:bottom right corner
	地点:point

	●内容
banner::::バナー
vector::::ベクター
bitmap::::ビットマップ
素の:plain:~
句ng:phrasing::句::フレージング
要素間:inter-element:~
分類:categories:~
可触:palpable::~
透過的:transparent::~
	なし:none
重要部分:critical part:~

	~formに所有され得る:Form-associated
	物語:story
	絵図:picture

	●未分類（動詞
圧縮:compression:~
供与-:contribute:~
固定-:fix:~
縮小-:scale down:~
節約-:save:~
	notification
保つ:keepする:~
欠如:lack:~

	指定する:present
	書き直:rewrite
	でなくなった:stops being
	埋め尽くす:fill up
	選ぶ／選ばれ／選んだ／選ばせ:choose
	選ぶ:pick
	対応:respective
	switching
	占める:take up
	順に見ていく:walk through
	戻って来る:return
	戻され:return
	わたる:span
	欠落している／~~完全に得られ:missing
	-:presence
	showing
	having
	using
	called
	giving
	running
	allowing
	remaining
	come
	であり続ける／-:stay
	-:mentioned
	referred
	取り出された:taken from
	-:swap around

	-:reverse
	-:remaining

	~~現れない:missing

	●未分類
端末:terminal::~::ターミナル
filter::::フィルタ
	jump::::
	-:mark
math:
memory::::メモリ
	~memoryが少ない:low-memory
	pointing
	未~support:unsupported
tablet::::タブレット
	〜な／〜の~text:textual
	~textのみの:text-only
	time::::
	~zoom前の the previous point
	〜したもの／種:version
factory::::ファクトリ
coding-style:coding style:::コーディングスタイル
framework::::フレームワーク
batch::::バッチ
実効:effective:~
文脈上の:contextual:~
	終端-:end
	対応する:relevant
	さほど関連しない:some less relevant

	スイス:Switzerland
	ジュネーヴ州:canton Geneva
	カルージュ:Carouge
	自治体:municipality
	町:the town
	紋章:coat of arms
	point
	continuing
	now
	のみを:bare
	-:amongst
	~formに所有され得る:form-associated
	最初に現れ次第:if the preceding entries in the list weren't used '
	-:we
	-:inner
	次の画像は、:here it is
	-:cell
	による:form
	すぐ 〜 ~~状態にある:readily 〜

	●指示語
	自身のみでは:on its own
	まるごと／全体:entirely
	だけで:merely
	旧:older
	行:row
	境目:breakpoint／
	周囲:surrounding
	最終的:the final
	あたりの:per
	他の:the rest of
	前の／先行する:previous
	先行の:preceding
	境目:between
	後続する:follow する
	異なる／種々の:different
	早く:sooner
	互いに:mutually
	のどれでも:any of
	-:something
	何らかの方法:somehow
	その他:anything else
	残りの:the remainder of
	〜でも:yet
	まったく〜ない:at all
	およそ:about
	常時:ever
	連続する:consecutive
	その次の／次回の:next
	その間に:in the meantime
	以前に:previously
	続けて:in succession
	末尾から連続する:trailing
	末尾の:final trailing
	-:final
	他所:anywhere else
	そうするとき:when doing so
	何も:nothing
	前後には，任意個数の:optionally intermixed
	neither
	nor
	まれ:rarely
	rest
	part
	together
	earlier
	一括して:together
	主な:main
	次の／次に:the following

	●数量
	1 個だけ／1 回だけ／同じ:single
	数:number
	単位:unit
	最も幅広:widest
	より幅広:wider
	幅広／幅~wide
	広い:wide
	狭い:narrow
	中程度:middle
	小:small
	中:medium
	大:big
	大きさ:how big
	大きい方の:bigger
	小さい方の:smaller
	小さい／狭い:small
	greater
	大きい／広い:large
	大き過ぎる:too large
	ごく狭い:very low-
	より低く:lower
	高:high-／high
	の 3 倍:three times as many
	以内には:at least

●●html_code_list

■img-0
<img src="1.jpeg" alt="1">
<img src="2.jpeg" loading=eager alt="2">
<img src="3.jpeg" loading=lazy alt="3">
<div id=very-large></div> <!-- この div より後にあるものすべては表示域より下にある -->
<img src="4.jpeg" alt="4">
<img src="5.jpeg" loading=lazy alt="5">

Everything after this div is below the viewport

■img-1
<p>私は<img src="carouge.svg" alt="">カルージュに住んでます。</p>

<p>I lived in <img src="carouge.svg" alt=""> Carouge.</p>


■img-2
<p>私の故郷： <img src="carouge.svg" alt="Carouge"></p>

<p>Home town: <img src="carouge.svg" alt="Carouge"></p>


■img-3
<p>カルージュには紋章があります。</p>
<p><img src="carouge.svg" alt="木の前に横たわるライオンを図案化している紋章"></p>
<p>それは町の至る所で装飾に用いられています。</p>


<p>Carouge has a coat of arms.</p>
<p><img src="carouge.svg" alt="The coat of arms depicts a lion, sitting in front of a tree."></p>
<p>It is used as decoration all over the town.</p>


■img-4
<p>カルージュには紋章があります。</p>
<p><img src="carouge.svg" alt=""></p>
<p>この紋章は、木の前に横たわるライオンを図案化しています。
それは町の至る所で装飾に用いられています。</p>

<p>Carouge has a coat of arms.</p>
<p><img src="carouge.svg" alt=""></p>
<p>The coat of arms depicts a lion, sitting in front of a tree.
It is used as decoration all over the town.</p>


■img-5
<p>彼女がフォルダを取りあげたとき、紙片が抜け落ちた。</p>
<p><img src="carouge.svg" alt="シール状のものに、赤い背景に緑の木、舌を出して尻尾が S 字状の黄色いライオンが描かれている"></p>
<p>フォルダを前に、彼女はその紙片を見つめた。 S だ！待ち望んでいた答えは単純に文字 S だった！なぜ今まで気付かなかった？今やすべてに合点がいった。マリアが舌を突き出したとき、ヘクターが電話でライオンの尻尾と呼んでいたものは…</p>

<p>She picked up the folder and a piece of paper fell out.</p>
<p><img src="carouge.svg" alt="Shaped like a shield, the paper had a
red background, a green tree, and a yellow lion with its tongue
hanging out and whose tail was shaped like an S."></p>
<p>She stared at the folder. S! The answer she had been looking for all
this time was simply the letter S! How had she not seen that before? It all
came together now. The phone call where Hector had referred to a lion's tail,
the time Maria had stuck her tongue out...</p>

'

■img-6
<p>最後の利用者がアップロードした紋章は、これです：</p>
<p><img src="last-uploaded-coat-of-arms.cgi" title="利用者がアップロードした紋章"></p>

<p>The last user to have uploaded a coat of arms uploaded this one:</p>
<p><img src="last-uploaded-coat-of-arms.cgi" title="User-uploaded coat of arms."></p>


■img-7
<article>
 <h1>うちの猫</h1>
 <h2>フワッフィ</h2>
 <p>お気に入りはフワッフィ。</p>
 <img src="fluffy.jpg" alt="編み玉でじゃれるのが好き。">
 <p>この子はとってもかわいいの。</p>
 <h2>マイルズ</h2>
 <p>もう一人の子、マイルズは食べては寝てばかり。</p>
</article>

<article>
 <h1>My cats</h1>
 <h2>Fluffy</h2>
 <p>Fluffy is my favorite.</p>
 <img src="fluffy.jpg" alt="She likes playing with a ball of yarn.">
 <p>She's just too cute.</p>
 <h2>Miles</h2>
 <p>My other cat, Miles just eats and sleeps.</p>
</article>

	'

■img-8
<article>
 <h1>撮影法</h1>
 <h2>動く標的を屋内で撮る</h2>
 <p>秘訣は、標的の速さ、標的までの距離から、どう予測するか知ることです。</p>
 <img src="fluffy.jpg" alt="編み玉に飛びつくように追っかけるネコも、このワザできれいに撮影できます。">
 <h2>夜間撮影</h2>
 <p>これを達成するには、高感度なフィルムを使うか、強いフラッシュをたく必要があります。</p>
</article>


<article>
 <h1>Photography</h1>
 <h2>Shooting moving targets indoors</h2>
 <p>The trick here is to know how to anticipate; to know at what speed and
 what distance the subject will pass by.</p>
 <img src="fluffy.jpg" alt="A cat flying by, chasing a ball of yarn, can be
 photographed quite nicely using this technique.">
 <h2>Nature by night</h2>
 <p>To achieve this, you'll need either an extremely sensitive film, or
 immense flash lights.</p>
</article>

	'

■img-9
<article>
 <h1>私について</h1>
 <h2>うちのペット</h2>
 <p>猫のフワッフィと犬のマイルズ。</p>
 <img src="fluffy.jpg" alt="猫のフワッフィは、せわしなく動きたがる。">
 <p>犬のマイルズは、私との長い散歩が好きです。</p>
 <h2>音楽</h2>
 <p>散歩を終えた後は、バッハを聴いて頭を空っぽにするのが好きです。</p>
</article>

<article>
 <h1>About me</h1>
 <h2>My pets</h2>
 <p>I've got a cat named Fluffy and a dog named Miles.</p>
 <img src="fluffy.jpg" alt="Fluffy, my cat, tends to keep itself busy.">
 <p>My dog Miles and I like go on long walks together.</p>
 <h2>music</h2>
 <p>After our walks, having emptied my mind, I like listening to Bach.</p>
</article>

	'

■img-10
<article>
 <h1>フワッフィと編み玉</h1>
 <p>猫のフワッフィは編み玉でじゃれたり飛び跳ねるのが好きでした。</p>
 <aside><img src="fluffy.jpg" alt="" title="フワッフィ"></aside>
 <p>朝でも夜でもよく遊んでいたものです。</p>
</article>

<article>
 <h1>Fluffy and the Yarn</h1>
 <p>Fluffy was a cat who liked to play with yarn. She also liked to jump.</p>
 <aside><img src="fluffy.jpg" alt="" title="Fluffy"></aside>
 <p>She would play in the morning, she would play in the evening.</p>
</article>



■intro-1
％<h2>今日の特集から</h2>
＜<img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150">＞
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
は、英国の<a href="/wiki/Music_hall">舞台</a>歌手で、...

％<h2>From today's featured article</h2>
＜<img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150">＞
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
was an English <a href="/wiki/Music_hall">music hall</a> singer, ...

	'

■intro-2
％<h2>今日の特集から</h2>
<img ＜src="/uploads/100-marie-lloyd.jpg"＞
     ＜srcset="/uploads/150-marie-lloyd.jpg 1.5x, /uploads/200-marie-lloyd.jpg 2x"＞
     alt="" width="100" height="150">
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
は、英国の<a href="/wiki/Music_hall">舞台</a>歌手で、...


％<h2>From today's featured article</h2>
<img ＜src="/uploads/100-marie-lloyd.jpg"＞
     ＜srcset="/uploads/150-marie-lloyd.jpg 1.5x, /uploads/200-marie-lloyd.jpg 2x"＞
     alt="" width="100" height="150">
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
was an English <a href="/wiki/Music_hall">music hall</a> singer, ...

	'

■intro-3
％<h1><img ＜sizes="100vw" srcset="wolf-400.jpg 400w, wolf-800.jpg 800w, wolf-1600.jpg 1600w"＞
     src="wolf-400.jpg" alt="The rad wolf"></h1>


■intro-4
<img ＜sizes="(max-width: 30em) 100vw, (max-width: 50em) 50vw, calc(33vw - 100px)"＞
     ＜srcset="swing-200.jpg 200w, swing-400.jpg 400w, swing-800.jpg 800w, swing-1600.jpg 1600w"＞
     src="swing-400.jpg" alt="Kettlebell Swing">


■intro-5
<picture>
  <source ＜media="(min-width: 45em)"＞ srcset="large.jpg">
  <source ＜media="(min-width: 32em)"＞ srcset="med.jpg">
  <img src="small.jpg" alt="The wolf runs through the snow.">
</picture>



■intro-6
％<h1>
 <picture>
  <source media="(max-width: 500px)" srcset="banner-phone.jpeg, banner-phone-HD.jpeg 2x">
  <img src="banner.jpeg" srcset="banner-HD.jpeg 2x" alt="The Breakfast Combo">
 </picture>
</h1>


■intro-7
％<h2>今日の特集から</h2>
<picture>
 <source srcset="/uploads/100-marie-lloyd.webp" ＜type="image/webp"＞>
 <source srcset="/uploads/100-marie-lloyd.jxr" ＜type="image/vnd.ms-photo"＞>
 <img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150">
</picture>
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
は、英国の<a href="/wiki/Music_hall">舞台</a>歌手で、...

％<h2>From today's featured article</h2>
<picture>
 <source srcset="/uploads/100-marie-lloyd.webp" ＜type="image/webp"＞>
 <source srcset="/uploads/100-marie-lloyd.jxr" ＜type="image/vnd.ms-photo"＞>
 <img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150">
</picture>
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
was an English <a href="/wiki/Music_hall">music hall</a> singer, ...

	'

■intro-8
<figure>
 <picture>
  <source srcset="a-square.png" media="(max-width: 600px)">
  <img src="a-rectangle.png" alt="スーツとメガネを着こなす Barney Frank 氏">
 </picture>
 <figcaption>Barney Frank, 2011</figcaption>
</figure>


 alt="Barney Frank wears a suit and glasses."


■intro-9
<style>
 #a { width: 300px; height: 150px; }
 @media (max-width: 600px) { #a { width: 100px; height: 100px; } }
</style>
<figure>
 <picture>
  <source srcset="a-square.png" media="(max-width: 600px)">
  <img src="a-rectangle.png" alt="スーツとメガネを着こなす Barney Frank 氏" id="a">
 </picture>
 <figcaption>Barney Frank, 2011</figcaption>
</figure>


■intro-10
<style media="(max-width: 600px)">
 #a { width: 100px; height: 100px; }
</style>
<figure>
 <picture>
  <source srcset="a-square.png" media="(max-width: 600px)">
  <img src="a-rectangle.png" width="300" height="150"
  alt="スーツとメガネを着こなす Barney Frank 氏" id="a">
 </picture>
 <figcaption>Barney Frank, 2011</figcaption>
</figure>


■intro-11
<picture>
 <source srcset="pear-mobile.jpeg" media="(max-width: 720px)">
 <source srcset="pear-tablet.jpeg" media="(max-width: 1280px)">
 <img src="pear-desktop.jpeg" alt="The pear is juicy.">
</picture>



■intro-12
<picture>
 <source srcset="pear-mobile.jpeg" media="(max-width: 720px)">
 <source srcset="pear-tablet.jpeg" media="(max-width: 1280px)">
 <source srcset="pear-desktop.jpeg">
 <img src="pear-mobile.jpeg" alt="The pear is juicy.">
</picture>



■intro-13
<picture>
 <source srcset="pear-mobile.jpeg" media="(max-width: 720px)">
 <source srcset="pear-tablet.jpeg" media="(max-width: 1280px)">
 <source srcset="pear-desktop.jpeg">
 <img src="pear-tablet.jpeg" alt="The pear is juicy.">
</picture>


■intro-14
<picture>
 <source srcset="pear-desktop.jpeg" media="(min-width: 1281px)">
 <source srcset="pear-tablet.jpeg" media="(min-width: 721px)">
 <img src="pear-mobile.jpeg" alt="The pear is juicy.">
</picture>

■map-1
<!DOCTYPE HTML>
<HTML LANG="EN">
<TITLE>Babies™: Toys</TITLE>
<HEADER>
 <H1>Toys</H1>
 <IMG SRC="/images/menu.gif"
      ALT="Babies™ navigation menu. Select a department to go to its page."
      USEMAP="#NAV">
</HEADER>
 ...
<FOOTER>
 <MAP NAME="NAV">
  <P>
   <A HREF="/clothes/">Clothes</A>
   <AREA ALT="Clothes" COORDS="0,0,100,50" HREF="/clothes/"> |
   <A HREF="/toys/">Toys</A>
   <AREA ALT="Toys" COORDS="100,0,200,50" HREF="/toys/"> |
   <A HREF="/food/">Food</A>
   <AREA ALT="Food" COORDS="200,0,300,50" HREF="/food/"> |
   <A HREF="/books/">Books</A>
   <AREA ALT="Books" COORDS="300,0,400,50" HREF="/books/">
  </P>
 </MAP>
</FOOTER>

■usemap-1
<p>
図形を選択してください：
 <img src="shapes.png" usemap="#shapes"
      alt="4 種の図形が可用です：栗色の穴あき四角形, 緑色の円, 紺色の三角形, 黄色の十文字星形">
 <map name="shapes">
  <area shape=rect coords="50,50,100,100"> <!-- 四角形の穴 -->
  <area shape=rect coords="25,25,125,125" href="red.html" alt="栗色の四角形">
  <area shape=circle coords="200,75,50" href="green.html" alt="緑色の円">
  <area shape=poly coords="325,25,262,125,388,125" href="blue.html" alt="紺色の三角形">
  <area shape=poly coords="450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60"
        href="yellow.html" alt="黄色の十文字星形">
 </map>
</p>

<p>
 Please select a shape:
 <img src="shapes.png" usemap="#shapes"
      alt="Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.">
 <map name="shapes">
  <area shape=rect coords="50,50,100,100"> <!-- the hole in the red box -->
  <area shape=rect coords="25,25,125,125" href="red.html" alt="Red box.">
  <area shape=circle coords="200,75,50" href="green.html" alt="Green circle.">
  <area shape=poly coords="325,25,262,125,388,125" href="blue.html" alt="Blue triangle.">
  <area shape=poly coords="450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60"
        href="yellow.html" alt="Yellow star.">
 </map>
</p>


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の画像に関係するいくつかの節（
<a href="~SPEC_URL">§ Embedded content</a>,
<a href="~HTMLLS/images.html">§ Images</a>,
<a href="~HTMLLS/image-maps.html">§ Image maps</a>,
他）を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<div id="_persisted_parts" hidden>

<svg id="_ex-intro-svg-1"
	xml:lang="en-x-a0"
	font-size="2.5" role="img" viewBox="0 0 80 32" font-family="sans-serif" height="200" aria-label="The phone's screen is much smaller compared to the laptop's screen.">
 
 <rect width="6" fill="white" stroke="black" x="6" height="12" y="18" rx="1"></rect>
 <text transform="translate(9 24)
 rotate(-60)" text-anchor="middle" dominant-baseline="middle">4″</text>
 
 <rect width="40" stroke-width="2" fill="white" stroke="black" x="30" height="26" y="2" rx="2"></rect>
 <line y2="30" stroke-linecap="round" stroke-width="2" stroke="black" x1="26" y1="30" x2="74"></line>
 <text transform="translate(50 15)
 rotate(-30)" text-anchor="middle" dominant-baseline="middle">14″</text>
</svg>

<svg id="_ex-intro-svg-2"
	xml:lang="en-x-a0"
	font-size="2.5" role="img" viewBox="0 0 56 27" font-family="sans-serif" height="170" aria-label="One phone has big pixels, the other has small pixels.">
 <defs>
  
<pattern id="img-intro-pixel" width="3" patternUnits="userSpaceOnUse" stroke-linecap="round" x="0" y="0" height="3">
   <rect fill="black" width="3" x="0" height="3" y="0"></rect>
   <line y2="2.5" stroke="red" x1="0.5" x2="0.5" y1="0.5"></line>
   <line y2="2.5" stroke="lime" x1="1.5" x2="1.5" y1="0.5"></line>
   <line y2="2.5" stroke="blue" x1="2.5" x2="2.5" y1="0.5"></line>
  </pattern>
 </defs>
 
 <rect width="6" fill="white" stroke="black" x="6" height="12" y="8" rx="1"></rect>
 <rect width="6" fill="white" stroke="black" x="36" height="12" y="8" rx="1"></rect>
 
 <line y2="24" stroke-width="3" stroke="brown" x1="15" y1="16" x2="22"></line>
 <circle cx="10" cy="10" fill="url(#img-intro-pixel)" stroke="black" r="8"></circle>
 <line y2="24" stroke-width="3" stroke="brown" x1="45" y1="16" x2="52"></line>
 <circle cx="120" transform="scale(0.333333)" cy="30" r="24" stroke-width="3" fill="url(#img-intro-pixel)" stroke="black"></circle>
 
 <text x="20" y="10" dominant-baseline="middle">1x</text>
 <text x="50" y="10" dominant-baseline="middle">3x</text>
</svg>

<svg id="_ex-intro-svg-3"
	xml:lang="en-x-a0"
	font-size="2.5" role="img" viewBox="0 0 60 32" font-family="sans-serif" height="200" aria-label="The tablet has two orientations.">
 
 <rect width="14" fill="white" stroke="black" x="6" height="20" y="5" rx="1"></rect>
 <line y2="24" stroke-width="1.1" stroke="black" x1="6" y1="24" x2="20"></line>
 <text text-anchor="middle" x="13" y="14.5" dominant-baseline="middle">縦置き</text>
 <rect width="20" fill="white" stroke="black" x="30" height="14" y="11" rx="1"></rect>
 <line y2="11" stroke-width="1.1" stroke="black" x1="31" y1="25" x2="31"></line>
 <text text-anchor="middle" x="40.5" y="18" dominant-baseline="middle">横置き</text>
</svg>

<svg id="_ex-intro-svg-4"
	viewBox="0 0 52 25.6" height="160" aria-label="The upright-held phone shows a small wolf at the top, and the tablet shows the same image but it is bigger." role="img">

 <rect width="6" fill="white" stroke="black" x="6" height="12" y="8" rx="1"></rect>
 <rect fill="#716966" x="7" width="4" height="2" y="9"></rect>
 <image xlink:href="HTML-resources/wolf.jpg" width="4" x="7" y="9" height="2"></image>

 <rect width="20" fill="white" stroke="black" x="25" height="14" y="6" rx="1"></rect>
 <line y2="6" stroke-width="1.1" stroke="black" x1="26" y1="20" x2="26"></line>
 <rect fill="#716966" x="27" width="17" height="8.5" y="7"></rect>
 <image xlink:href="HTML-resources/wolf.jpg" width="17" x="27" y="7" height="8.5"></image>

</svg>


<svg id="_ex-intro-svg-5"
	xml:lang="en-x-a0"
	font-size="2.5" role="img" viewBox="0 0 115 32" font-family="sans-serif" height="200" aria-label="The rotated phone shows a top part of an image of a kettlebell swing; the
upright-held tablet shows a bit smaller images in two columns; the laptop shows images in three
columns.">

 <rect width="12" fill="white" stroke="black" x="6" height="6" y="24" rx="1"></rect>
 <rect fill="#987b5a" width="10" x="7" height="4.5" y="25"></rect>
 <image xlink:href="HTML-resources/kettlebell.jpg" preserveAspectRatio="xMinYMin slice" width="10" x="7" y="25" height="4.5"></image>
 <text text-anchor="middle" x="12" y="21">小のときは 1 列</text>

 <rect width="14" fill="white" stroke="black" x="32" height="20" y="10" rx="1"></rect>
 <line y2="29" stroke-width="1.1" stroke="black" x1="32" y1="29" x2="46"></line>
 <rect fill="#987b5a" width="5.5" x="33" height="5.5" y="11"></rect>
 <image xlink:href="HTML-resources/kettlebell.jpg" width="5.5" x="33" y="11" height="5.5"></image>
 <rect fill="burlywood" width="5.5" x="39.5" height="5.5" y="11"></rect>
 <rect fill="silver" width="5.5" x="33" height="5.5" y="17.5"></rect>
 <text text-anchor="middle" x="39" y="7">中のときは 2 列</text>

 <rect width="40" stroke-width="2" fill="white" stroke="black" x="65" height="26" y="2" rx="2"></rect>
 <line y2="30" stroke-linecap="round" stroke-width="2" stroke="black" x1="61" y1="30" x2="109"></line>
 <rect fill="#987b5a" width="10" x="67" height="10" y="4"></rect>
 <image xlink:href="HTML-resources/kettlebell.jpg" width="10" x="67" y="4" height="10"></image>
 <rect fill="burlywood" width="10" x="80" height="10" y="4"></rect>
 <rect fill="silver" width="10" x="93" height="10" y="4"></rect>
 <text text-anchor="middle" x="85" y="25">大のときは 3 列</text>
</svg>


<svg id="_ex-intro-svg-6"
	viewBox="0 0 52 25.6"
	height="160"
	aria-label="The upright-held phone shows a cropped image of a wolf; the rotated tablet shows the uncropped image."
	role="img"
>

 <rect width="6" fill="white" stroke="black" x="6" height="12" y="8" rx="1"></rect>
 <rect fill="#716966" x="7" width="4" height="6" y="9"></rect>
 <image xlink:href="HTML-resources/wolf.jpg" preserveAspectRatio="xMidYMid slice" width="4" x="7" y="9" height="6"></image>

 <rect width="20" fill="white" stroke="black" x="25" height="14" y="6" rx="1"></rect>
 <line y2="6" stroke-width="1.1" stroke="black" x1="26" y1="20" x2="26"></line>
 <rect fill="#716966" x="27" width="17" height="8.5" y="7"></rect>
 <image xlink:href="HTML-resources/wolf.jpg" width="17" x="27" y="7" height="8.5"></image>

</svg>

<svg id="_ex-sample-usemap"
	xmlns="http://www.w3.org/2000/svg"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	viewBox="0 0 600 150"
	width="600" height="150"
>
	<g stroke-width="3" stroke="black">
<path
	fill="maroon"
	fill-rule="evenodd"
	d="M25,25 h100 v100 h-100 z m25,25 v50 h50 v-50 z"
/>
<circle
	fill="green"
	cx="200" cy="75" r="50"
/>
<path
	fill="navy"
	d="M325,25,262,125,388,125"
/>
<path
	fill="yellow"
	d="M450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60z"
/>
<!-- 
	d="m325,25 l-63,100 h126 z"
	d="m450,25 15,35 35,15 -35,15 -15,35 -15,-35 -35,-15 35,-15 z"
 -->
	</g>
</svg>


</div>

<header id="head">
	<hgroup>
<h1>画像（埋め込み内容） — Images ( Embedded content )</h1>

	</hgroup>
</header>

<main id="MAIN" hidden>

			<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoの記述に利用されている各種記号（ ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
`px@css
は、`~CSS~pixel$単位の略記である。
</p>

			</section>
			<section id="the-picture-element">
<h3 title="The picture element">4.8.1. `picture^e 要素</h3>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$ ／ `句ng内容$ ／ `埋込d内容$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
<p>
次の要素からなる挙げられる順による並び：
</p>

<ol ><li>0 個~以上の `source$e 要素
</li><li>1 個の `img$e 要素
</li></ol>

<p>
加えて、これらの要素の前後には，任意個数の`~scriptを~supportする要素$があってよい。
</p>
◎
Zero or more source elements, followed by one img element, optionally intermixed with script-supporting elements.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`picture$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLPictureElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();
};
</pre>
	</dd>
</dl>

<p>
`picture$e 要素は、その子である `img$e 要素に複数の~sourceを供する容器である。
それは、作者が，［［
~screen画素~密度, `表示域$の~size, 画像~形式, その他の要因
］に基づいて どの画像~資源を利用するか
］について，宣言的に［
~UAを制御する／~UAに~hintを与える
］ことを可能にする。
それは、その子たちを`表現-$する。
◎
The picture element is a container which provides multiple sources to its contained img element to allow authors to declaratively control or give hints to the user agent about which image resource to use, based on the screen pixel density, viewport size, image format, and other factors. It represents its children.
</p>

  
<p class="note">注記：
`picture$e 要素は、似た見かけの［
`video$e ／ `audio$e
］要素とは いくぶん異なる。
それらも `source$e 要素を包含するが、
`source$e 要素の `src$aS 属性は、要素が `picture$e 要素の中に入子にされたときは 意味はなく，資源~選定~algoも異なる。
また、 `picture$e 要素~自身は何も表示しない
— それは、その子である `img$e 要素に，複数の `~URL$ から選ぶことを可能化するような文脈を供するだけである。
◎
The picture element is somewhat different from the similar-looking video and audio elements. While all of them contain source elements, the source element's src attribute has no meaning when the element is nested within a picture element, and the resource selection algorithm is different. Also, the picture element itself does not display anything; it merely provides a context for its contained img element that enables it to choose from multiple URLs.
</p>

			</section>
			<section id="the-source-element">
<h3 title="The source element">4.8.2. `source^e 要素</h3>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
なし。
◎
None.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`picture$e 要素の子としては、
`img$e 要素の前。
◎
As a child of a picture element, before the img element.
</dd>
	<dd>
`~media要素$の子としては、どの［
`~flow内容$ ／ `track$e 要素
］よりも前。
◎
As a child of a media element, before any flow content or track elements.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>`src$aS
— 資源の~address
◎
src — Address of the resource
</dd>
	<dd>`type$aS
— 埋込d資源の型
◎
type — Type of embedded resource
</dd>
	<dd>`srcset$aS
— 種々の状況（例：高~解像度~display, 狭い~monitor, 等々）に応じて利用する一連の画像
◎
srcset — Images to use in different situations (e.g. high-resolution displays, small monitors, etc)
</dd>
	<dd>`sizes$aS
— 種々の~page~layout用の画像~size
◎
sizes — Image sizes for different page layouts
</dd>
	<dd>`media$aS
— 適用-可能な~media
◎
media — Applicable media
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`source$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLSourceElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute USVString `src$mS;
  [`CEReactions$] attribute DOMString `type$mS;
  [`CEReactions$] attribute USVString `srcset$mS;
  [`CEReactions$] attribute DOMString `sizes$mS;
  [`CEReactions$] attribute DOMString `media$mS;
};
</pre>
	</dd>
</dl>

<p>
`source$e 要素は、作者が，［
`img$e 要素／ `~media要素$用の複数の代替 `~media資源$
］用に 複数の代替`~source集合$を指定できるようにする。
この要素は、自身のみでは何も`表現-$しない。
◎
The source element allows authors to specify multiple alternative source sets for img elements or multiple alternative media resources for media elements. It does not represent anything on its own.
</p>

<p>
`source$e 要素には
`type@aS
属性を指定してもヨイ。
指定する値は、`妥当な~MIME型~文字列$でなければナラナイ。
◎
The type attribute may be present. If present, the value must be a valid MIME type string.
</p>

<p>
`source$e 要素 %source の親が `picture$e 要素である場合、以下の要件も課される：
◎
The remainder of the requirements depend on whether the parent is a picture element or a media element:
◎
source element's parent is a picture element
</p>

<p class="trans-note">【
親が`~media要素$である場合の要件, および
`~media要素$に関係する他の内容は、<a href="~HEmedia#the-source-element" >別ページ</a>にて。
】</p>

<ul>
	<li>
<p>
%source は
`srcset@aS
属性を有していなければナラナイ
— それは`~srcset属性$になる。
この属性は、`~source集合$†として %source が選定された場合に，それ用の一連の`画像~source$を供与する††。
◎
The srcset attribute must be present, and is a srcset attribute.
◎
The srcset attribute contributes the image sources to the source set, if the source element is selected.
</p>

<p class="trans-note">【†
%source の親 `picture$e 要素の子である `img^e 要素の`~source集合$を指す（以下同様）。
】【††
ある時点で所与の `img^e 要素に画像~sourceを供与する `source^e 要素は 1 つまでに限られる（詳細は
<a href="#updating-the-source-set">§ ~source集合の更新-法</a>
に）。
】</p>

	</li>
	<li>
［
%source が `srcset$aS 属性を有する
］~AND［
その値が与える`画像~候補~文字列$に`横幅~記述子$も伴われる
］場合、 %source は
`sizes@aS
属性も有してなければナラナイ
— それは`~sizes属性$になる。
この属性は、`~source集合$として %source が選定された場合に，その`~source~size$を供与する。
◎
If the srcset attribute has any image candidate strings using a width descriptor, the sizes attribute must also be present, and is a sizes attribute. The sizes attribute contributes the source size to the source set, if the source element is selected.
</li>
	<li>
%source は
`media@aS
属性を指定してもヨイ。
その場合の値は、`妥当な媒体~query~list$を包含していなければナラナイ。
~UAは、値が`環境に合致して$いない場合には，
%source を飛ばして 次~以降の `source$e 要素を選定することになる。
◎
The media attributes may also be present. If present, the value must contain a valid media query list. The user agent will skip to the next source element if the value does not match the environment.
</li>
	<li>
<p>
%source の `type$aS 属性は、`~source集合$内の各 画像の型を与える
— これにより，~UAは、所与の型を~supportしない場合には，
%source を飛ばして 次~以降の `source$e 要素を選定できるようになる。
◎
The type attribute gives the type of the images in the source set, to allow the user agent to skip to the next source element if it does not support the given type.
</p>

<p class="note">注記：
`type$aS 属性が`指定されていない^em場合、~UAは、画像~資源を~fetchした後にその画像~形式を~supportしないことを見出した場合，他の `source$e 要素を選定しないことになる。
◎
If the type attribute is not specified, the user agent will not select a different source element if it finds that it does not support the image format after fetching it.
</p>
	</li>
	<li>
<p>
%source に後続する同胞に［
別の `source$e 要素 ／
`srcset$a 属性を有する `img$e 要素
］がある場合、
%source は 次のいずれかは満たしていなければナラナイ：
◎
When a source element has a following sibling source element or img element with a srcset attribute specified, it must have at least one of the following:
</p>

		<ul>
			<li>
`media$aS 属性が指定されていて、その値は次を満たす
⇒
`~ASCII小文字~化する$( `前後の~ASCII空白~列を剥ぐ$( 値 ) ) ~NIN { 空~文字列, `all^l }
◎
A media attribute specified with a value that, after stripping leading and trailing ASCII whitespace, is not the empty string and is not an ASCII case-insensitive match for the string "all".
</li>
			<li>
`type$aS 属性が指定されている
◎
A type attribute specified.
</li>
		</ul>
	</li>
	<li>
<p>
%source は `src$aS 属性を有してはナラナイ。
◎
The src attribute must not be present.
</li>
</ul>

<dl class="idl-def">
	<dt>`type@mS</dt>
	<dt>`srcset@mS</dt>
	<dt>`sizes@mS</dt>
	<dt>`media@mS</dt>
	<dd>
順に，（どれも同じ名前の）
`type$aS,
`srcset$aS,
`sizes$aS,
`media$aS
内容~属性を`反映する$モノトスル。
◎
The IDL attributes src, type, srcset, sizes and media must reflect the respective content attributes of the same name.
</dd>
</dl>

			</section>
			<section id="the-img-element">
<h3 title="The img element">4.8.3. `img^e 要素</h3>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$ ／ `句ng内容$ ／ `埋込d内容$ ／ `~formに所有され得る要素$ ／ `可触~内容$ ／ （要素は `usemap$a 属性を有する場合に限り）`対話的~内容$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
Form-associated element.
◎
If the element has a usemap attribute: Interactive content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了tag$はない
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`alt$a
— 画像が可用でないときに利用するための代用~text
◎
alt — Replacement text for use when images are not available
</dd>
	<dd>`src$a
— 画像~資源の~address
◎
src — Address of the resource
</dd>
	<dd>`srcset$a
— 種々の状況（例：高~解像度~display, 狭い~monitor, 等々）に応じて利用する一連の画像
◎
srcset — Images to use in different situations (e.g. high-resolution displays, small monitors, etc)
</dd>
	<dd>`sizes$a
— 種々の~page~layout用の画像~size
◎
sizes — Image sizes for different page layouts
</dd>
	<dd>`crossorigin$a
— 要素が非同一-生成元~要請をどう取扱うか
◎
crossorigin — How the element handles crossorigin requests
</dd>
	<dd>`usemap$a
— 利用する`画像~map$の名前
◎
usemap — Name of image map to use
</dd>
	<dd>`ismap$a
— この画像は~server側~画像~mapかどうか
◎
ismap — Whether the image is a server-side image map
</dd>
	<dd>`width$a
—
横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>`height$a
—
縦~寸法
◎
height — Vertical dimension
</dd>
	<dd>`referrerpolicy$a
— この要素により起動される`~fetch$用の`~referrer施策$
◎
referrerpolicy — Referrer policy for fetches initiated by the element
</dd>
	<dd>`decoding$a
— この画像を呈示~用に処理するときに利用する，復号~用の~hint
◎
decoding — Decoding hint to use when processing this image for presentation
</dd>
	<dd>`loading$a
— 読込ngの先送り可否を決定するときに利用される。
◎
loading — Used when determining loading deferral
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
要素は空でない `alt$a 属性を有する場合
⇒
`img$AA
◎
If the element has a non-empty alt attribute: for authors; for implementers.
</dd>
	<dd>
他の場合
⇒
`img-empty-alt$AA
◎
Otherwise: for authors; for implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window,
 `LegacyFactoryFunction$=`Image$m(optional unsigned long width, optional unsigned long height)]
interface `HTMLImageElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute DOMString `alt$m;
  [`CEReactions$] attribute USVString `src$m;
  [`CEReactions$] attribute USVString `srcset$m;
  [`CEReactions$] attribute DOMString `sizes$m;
  [`CEReactions$] attribute DOMString? `crossOrigin$m;
  [`CEReactions$] attribute DOMString `useMap$m;
  [`CEReactions$] attribute boolean `isMap$m;
  [`CEReactions$] attribute unsigned long `width$m;
  [`CEReactions$] attribute unsigned long `height$m;
  readonly attribute unsigned long `naturalWidth$m;
  readonly attribute unsigned long `naturalHeight$m;
  readonly attribute boolean `complete$m;
  readonly attribute USVString `currentSrc$m;
  [`CEReactions$] attribute DOMString `referrerPolicy$m;
  [`CEReactions$] attribute DOMString `decoding$m;
  [`CEReactions$] attribute DOMString `loading$m;

  Promise&lt;void&gt; `decode$m();
};
</pre>
	</dd>
</dl>

<p>
`img$e 要素は、画像を表現する。
◎
An img element represents an image.
</p>

<p>
この画像は、要素の
`src@a,
`srcset@a
属性, および［
要素の親が `picture$e 要素である場合における
要素に先行する同胞である各 `source$e 要素の `srcset$aS 属性
］により与えられる，埋込d内容になる。
加えて、要素の
`alt@a
属性の値は，［
当の画像を処理できない, または
画像の読込ngが不能化されている
］ときのための等価な内容を供する（すなわち， `img$e 要素の`~fallback内容$になる）。
◎
The image given by the src and srcset attributes, and any previous sibling source elements' srcset attributes if the parent is a picture element, is the embedded content; the value of the alt attribute provides equivalent content for those who cannot process images or who have image loading disabled (i.e. it is the img element's fallback content).
</p>

<p>
`alt$a 属性の値に課される要件は、`§ 画像~用の代替として動作する~textを供するときの要件$にて述べる。
◎
The requirements on the alt attribute's value are described in a separate section.
</p>

<p>
要素は、次を満たしていなければナラナイ
⇒
［
`src$a 属性を有する
］~AND［
その値は`前後~空白~可の妥当かつ空でない~URL$を包含する
］~AND［
その~URLは［
対話的でも, 多pageでも, ~scriptありでもない画像~資源
］を参照している
］
◎終
— 画像は、~animate化されていてもよい。
◎
The src attribute must be present, and must contain a valid non-empty URL potentially surrounded by spaces referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted.
</p>

<div class="note">

<div class="p">
<p>注記：
上の要件は、次に挙げるもの等は，画像として与えれることを含意する：
</p>

<ul ><li>静的な~bitmap（例：~PNG, ~GIF, ~JPEG）
</li><li>単pageの~vector文書（単pageの~PDF, ~XML~fileのうち~SVG`文書~要素$を伴うもの）
</li><li>~animate化された~bitmap（ ~APNG, ~animate化~GIF)
</li><li>~animate化された~vector~graphic（ ~XML~fileのうち，~SVG`文書~要素$を伴い, 宣言的な~SMIL~animationを利用するもの）
</li></ul>
◎
The requirements above imply that images can be static bitmaps (e.g. PNGs, GIFs, JPEGs), single-page vector documents (single-page PDFs, XML files with an SVG document element), animated bitmaps (APNGs, animated GIFs), animated vector graphics (XML files with an SVG document element that use declarative SMIL animation), and so forth.＼
</div>

<div class="p">
<p>
一方で、次に挙げるもの等は，予め除外される：
</p>

<ul ><li>~scriptありの~SVG~file†
</li><li>複page~PDF~file
</li><li>対話的~MNG~file
</li><li>~HTML文書
</li><li>素の~text文書
</li></ul>

◎
However, these definitions preclude SVG files with script, multipage PDF files, interactive MNG files, HTML documents, plain text documents, and so forth.＼
</div>

<p>
`PNG$r
`GIF$r
`JPEG$r
`PDF$r
`XML$r
`APNG$r
`SVG$r
`MNG$r
</p>

<p class="trans-note">【†
~scriptありでも、実際には，それを不能化した上で呈示する~UAが多いと思われるが（そのような処理ができない~UAも視野に入れた要件？）。
】</p>

</div>

<p>
要素は `srcset$a 属性を指定してもヨイ
— それは、`~srcset属性$になる。
◎
The srcset attribute may also be present, and is a srcset attribute.
</p>

<p>
`srcset$a 属性と（その値に`横幅~記述子$は利用されていない場合の） `src$a 属性は、`~source集合$に`画像~source$を供与する（どの `source$e 要素も選定されなかった場合に限り）。
◎
The srcset attribute and the src attribute (if width descriptors are not used) contribute the image sources to the source set (if no source element was selected).
</p>

<p>
［
要素が `srcset$a 属性を有する
］~AND［
その値のいずれかの`画像~候補~文字列$に`横幅~記述子$が利用されている
］場合、要素は
`sizes@a
属性も有していなければナラナイ
— それは`~sizes属性$になる。
`sizes$a 属性は、`~source集合$に`~source~size$を供与する（どの `source$e 要素も選定されなかった場合に限り）。
◎
If the srcset attribute is present and has any image candidate strings using a width descriptor, the sizes attribute must also be present, and is a sizes attribute. The sizes attribute contributes the source size to the source set (if no source element was selected).
</p>

<p>
`crossorigin@a
属性は`~CORS設定群~属性$である。
その目的は、第三者主体~siteからの画像に対し，
`canvas$e から利用される非同一-生成元~accessを許容することである。
◎
The crossorigin attribute is a CORS settings attribute. Its purpose is to allow images from third-party sites that allow cross-origin access to be used with canvas.
</p>

<p>
`referrerpolicy@a
属性は、`~referrer施策~属性$である。
その目的は、画像の`~fetch$時に利用される`~referrer施策$を設定することである。
`REFERRERPOLICY$r
◎
The referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when fetching the image. [REFERRERPOLICY]
</p>

<p>
`decoding@a
属性は、この画像を`復号-$するときに選好される~methodを指示する。
この属性に指定する値は、`画像~復号~hint$でなければナラナイ。
この属性の［
`値なし用の既定$ ／ `妥当でない値~用の既定$
］は、 `Auto$st 状態とする。
◎
The decoding attribute indicates the preferred method to decode this image. The attribute, if present, must be an image decoding hint. This attribute's missing value default and invalid value default are both the auto state.
</p>

<p>
`loading@a
属性は、`~lazy読込ng属性$である。
その目的は、表示域の外側にある画像を読込むときの施策を指示することにある。
◎
The loading attribute is a lazy loading attribute. Its purpose is to indicate the policy for loading images that are outside the viewport.
</p>

<div class="example">

`img-0^xCode

<p>
上の例において、各~画像は，次に従って読込まれる：
◎
In the example above, the images load as follows:
</p>

<dl class="switch">
	<dt>`1.jpeg^c</dt>
	<dt>`2.jpeg^c</dt>
	<dt>`4.jpeg^c</dt>
	<dd>
画像は~eager（早急）に読込まれ，~windowの~load~eventを遅延する。
◎
The images load eagerly and delay the window's load event.
</dd>

	<dt>`3.jpeg^c</dt>
	<dd>
画像は、表示域に入ったことに因り~layoutが既知になったとき，読込まれる。
しかしながら，~windowの~load~eventは遅延しない。
◎
The image loads when layout is known, due to being in the viewport, however it does not delay the window's load event.
</dd>

	<dt>`5.jpeg^c</dt>
	<dd>
画像は表示域の中に~scrollされたときに限り読込まれ、~windowの~load~eventは遅延しない。
◎
The image loads only once scrolled into the viewport, and does not delay the window's load event.
</dd>
</dl>

<p class="note">注記：
画像を読込んだ後に~page~layoutが周りにずれるのを防止するため、開発者には~lazy（後回し）に読込まれる画像に対しては［
`width$a, `height$a
］属性を介して，内在的~縦横比を指定する†ことが奨励される
— ~CSSにより画像の［
`width^p ／ `height^p
］~propが【例えば `100%^v ／ `auto^v などに】設定されていても。
◎
Developers are encouraged to specify an intrinsic aspect ratio via width and height attributes on lazy loaded images, even if CSS sets the image's width and height properties, to prevent the page layout from shifting around after the image loads.
</p>

<p class="trans-note">【†
これは、~UA~stylesheetを介して `aspect-ratio$p ~propを設定することになると見込まれる（
<a href="~HTMLissue/5290">参照</a>
）
】</p>

</div>

<hr>

<p>
`img$e 要素は、~layout用の~toolとして利用してはナラナイ。
特に， 透明な画像を表示するために利用されるべきではない
— そのような画像が［
意味を伝達する／ 文書に有用なものを追加する
］のはまれなので。
◎
The img element must not be used as a layout tool. In particular, img elements should not be used to display transparent images, as such images rarely convey meaning and rarely add anything useful to the document.
</p>

<hr>

<div class="p">
<p>
`img$e 要素 %img が表現するものは、その
`src$a, `alt$a
属性に依存する
— 以下 %alt は， %img が `alt$a 属性を［
有するならばその値 ／
有さないならば ε
］とする：
</p>

◎
What an img element represents depends on the src attribute and the alt attribute.
</div>

<dl class="switch">
	<dt>%img は `src$a 属性を有する場合：</dt>
	<dd>
<div class="p">
<p>
%img の`画像は可用$である, かつ
~UAはその画像を表示するよう環境設定されているならば、
%img は，その画像~dataを`表現-$する。
</p>

<p>
加えて、 %alt に応じて：
</p>

◎
↓</div>
		<dl class="switch">
			<dt>空~文字列
◎
If the src attribute is set and the alt attribute is set to the empty string
</dt>
			<dd>
画像は、文書~内の他の内容に対する 装飾的または補足的であり，冗長な情報である。
◎
The image is either decorative or supplemental to the rest of the content, redundant with some other information in the document.
</dd>
			<dd>
%img が画像~dataを表現しない場合、それは何も`表現-$しないので，具現化から完全に省略されてもヨイ。
~UAは、画像は在るが具現化からは省略された旨を利用者に通知してもヨイ。
◎
If the image is available and the user agent is configured to display that image, then the element represents the element's image data.
◎
Otherwise, the element represents nothing, and may be omitted completely from the rendering. User agents may provide the user with a notification that an image is present but has been omitted from the rendering.
</dd>

			<dt>
空でない文字列
◎
If the src attribute is set and the alt attribute is set to a value that isn't empty
</dt>
			<dd>
画像は内容に欠かせない。
%alt は、画像~用の等価な または代用~textを与える。
◎
The image is a key part of the content; the alt attribute gives a textual equivalent or replacement for the image.
◎
If the image is available and the user agent is configured to display that image, then the element represents the element's image data.
</dd>
			<dd>
%img が画像~dataを表現しない場合、
%img は %alt で与えられる~textを`表現-$する。
~UAは、画像は在るが具現化からは省略された旨を利用者に通知してもヨイ。
◎
Otherwise, the element represents the text given by the alt attribute. User agents may provide the user with a notification that an image is present but has been omitted from the rendering.
</dd>

			<dt>ε
◎
If the src attribute is set and the alt attribute is not
</dt>
			<dd>
画像は内容に欠かせないかもしれない。
画像に等価な~textは、可用でない。
◎
The image might be a key part of the content, and there is no textual equivalent of the image available.
</dd>
			<dd class="note">注記：
適合~文書において `alt$a 属性が無いことは、画像は内容に欠かせないが，その生成-時には画像~用の代用~textは可用でなかったことを指示する。
◎
In a conforming document, the absence of the alt attribute indicates that the image is a key part of the content but that a textual replacement for the image was not available when the image was generated.
</dd>
			<dd>
<p>
%img が画像~dataを表現しない場合：
◎
If the image is available and the user agent is configured to display that image, then the element represents the element's image data.
</p>
				<ul>
					<li>
`src$a 属性の値が空~文字列ならば、 %img は何も`表現-$しない。
◎
If the image has a src attribute whose value is the empty string, then the element represents nothing.
</li>
					<li>
<p>
他の場合、~UAは，画像はあるが具現化されていないことを何らかの類の指示子で表示するべきである。
加えて，［
利用者から要請された, または そのように環境設定されている
］, あるいは［
~naviに呼応して文脈上の情報を供することが要求される
］場合、次に従って導出される結果が ε でないならば，それを画像~用の~caption情報として供してもヨイ：
◎
Otherwise, the user agent should display some sort of indicator that there is an image that is not being rendered, and may, if requested by the user, or if so configured, or when required to provide contextual information in response to navigation, provide caption information for the image, derived as follows:
</p>
						<ol>
							<li>
~IF［
%img は `title$a 属性を有する
］~AND［
その値 ~NEQ 空~文字列
］
⇒
~RET その属性の値
◎
If the image has a title attribute whose value is not the empty string, then return the value of that attribute.
</li>
							<li>
<p>
~IF［
次の関係をすべて満たす要素 %F, %C が在る
］…：
</p>

<ul ><li>%F は `figure$e 要素である
</li><li>%img は %F の子孫である
</li><li>%C は %F の子である `figcaption$e 要素のうち最初のものである
</li><li>%F の子孫は［
%C とその子孫, `要素間~空白$, %img, 非`~flow内容$
］のみからなる
</li><li>%img は %C の子孫ではない†
</li></ul>

<p>
…ならば
⇒
~RET %C の内容
</p>

<p class="trans-note">【†
この条件は訳者による補完。
原文の言い回しが微妙なので はっきりしないが、さもなければ，該当する `figure^e 要素（`~flow内容$でもある）が複数あり得ることになり，多義的になることに加え、
%img 自身が自身の~caption情報の一部を成す循環が生じ得るので。
】</p>
◎
If the image is a descendant of a figure element that has a child figcaption element, and, ignoring the figcaption element and its descendants, the figure element has no flow content descendants other than inter-element whitespace and the img element, then return the contents of the first such figcaption element.
</li>
							<li>
~RET ε
（~caption情報は無い。）
◎
Return nothing. (There is no caption information.)
</li>
						</ol>
					</li>
				</ul>
			</dd>
		</dl>
	</dd>

	<dt>%img は `src$a 属性を有さない場合：</dt>
	<dd>
%alt が空でない文字列ならば、
%img は その文字列による~textを`表現-$する。
他の場合、
%img は何も`表現-$しない。
◎
If the src attribute is not set and either the alt attribute is set to the empty string or the alt attribute is not set at all
◎
The element represents nothing.
◎
Otherwise
◎
The element represents the text given by the alt attribute.
</dd>
</dl>

<p>
`alt$a 属性は、助言的~情報を表現するものではない。
~UAは、 `alt$a 属性の内容を `title$a 属性の内容と同じ仕方では呈示しないモノトスル。
◎
The alt attribute does not represent advisory information. User agents must not present the contents of the alt attribute in the same way as content of the title attribute.
</p>

<p>
~UAは，常に、画像を［
表示させる／させない
］の選択肢を利用者に供してもヨイ。
~UAは、利用者が画像を見れないときには
— 視覚障碍 ／ ~graphic能力のない~text端末を利用しているなど —
利用者が用立て易くするような経験則を適用してもヨイ。
そのような経験則には、一例として，画像の中に見出された~textの光学文字認識（ OCR ）も含まれ得る。
◎
User agents may always provide the user with the option to display any image, or to prevent any image from being displayed. User agents may also apply heuristics to help the user make use of the image when the user is unable to see it, e.g. due to a visual disability or because they are using a text terminal with no graphics capabilities. Such heuristics could include, for instance, optical character recognition (OCR) of text found within the image.
</p>

<p class="warning">
~UAには， `alt$a 属性が欠落している事例を修復することが奨励されるが、作者は，そのような挙動に依拠してはナラナイ。
詳細は、`§ 画像~用の代替として動作する~textを供するときの要件$に述べる。
◎
While user agents are encouraged to repair cases of missing alt attributes, authors must not rely on such behavior. Requirements for providing text to act as an alternative for images are described in detail below.
</p>

<p>
`img$e 要素の`内容^emは、あっても，具現化の目的においては無視される。
◎
The contents of img elements, if any, are ignored for the purposes of rendering.
</p>

<hr>

<p>
`img$e 要素が `usemap$a 属性を有する場合、画像には`画像~map$が結付けられることを指示し得る。
◎
The usemap attribute, if present, can indicate that the image has an associated image map.
</p>

<p>
`img$e 要素が［
`ismap@a
属性を有する
］~AND［
先祖に `href$a 属性を有する `a$e 要素がある
］場合、~server側~画像~mapへの~accessを供することを指示する。
これは、その `a$e 要素~上の~eventがどう取扱われるかにも影響する。
◎
The ismap attribute, when used on an element that is a descendant of an a element with an href attribute, indicates by its presence that the element provides access to a server-side image map. This affects how events are handled on the corresponding a element.
</p>

<p>
`ismap$a 属性は`真偽~属性$である。
この属性は、要素の先祖に［
`href$a 属性を有する `a$e 要素
］が無い場合には，指定してはナラナイ。
◎
The ismap attribute is a boolean attribute. The attribute must not be specified on an element that does not have an ancestor a element with an href attribute.
</p>

<p class="note">注記：
同じ `picture$e 要素~内に［［
`usemap$a ／ `ismap$a
］属性を有する `img$e 要素
］と［
`media$aS 属性を有する `source$e 要素
］が併用された場合、結果の挙動は，困惑させるものになる。
◎
The usemap and ismap attributes can result in confusing behavior when used together with source elements with the media attribute specified in a picture element.
</p>

  
<p>
`img$e 要素は、`寸法~属性$を~supportする。
◎
The img element supports dimension attributes.
</p>

<dl class="idl-def">
	<dt>`alt@m</dt>
	<dt>`src@m</dt>
	<dt>`srcset@m</dt>
	<dt>`sizes@m</dt>
	<dd>
順に，（どれも同じ名前の）
`alt$a,
`src$a,
`srcset$a,
`sizes$a
内容~属性を`反映する$モノトスル。
◎
The alt, src, srcset and sizes IDL attributes must reflect the respective content attributes of the same name.
</dd>

	<dt>`crossOrigin@m</dt>
	<dd>
`既知な値のみに制限され$る下で，
`crossorigin$a 内容~属性を`反映する$モノトスル。
◎
The crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.
</dd>

	<dt>`useMap@m</dt>
	<dd>
`usemap$a 内容~属性を`反映する$モノトスル。
◎
The useMap IDL attribute must reflect the usemap content attribute.
</dd>

	<dt>`isMap@m</dt>
	<dd>
`ismap$a 内容~属性を`反映する$モノトスル。
◎
The isMap IDL attribute must reflect the ismap content attribute.
</dd>

	<dt>`referrerPolicy@m</dt>
	<dd>
`既知な値のみに制限され$る下で，
`referrerpolicy$a 内容~属性を`反映する$モノトスル。
◎
The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.
</dd>

	<dt>`decoding@m</dt>
	<dd>
`既知な値のみに制限され$る下で，
`decoding$a 内容~属性を`反映する$モノトスル。
◎
The decoding IDL attribute must reflect the decoding content attribute, limited to only known values.
</dd>

	<dt>`loading@m</dt>
	<dd>
`既知な値のみに制限され$る下で，
`loading$a 内容~属性を`反映する$モノトスル。
◎
The loading IDL attribute must reflect the loading content attribute, limited to only known values.
</dd>
</dl>

<dl class="domintro">

	<dt>%image . `width$m [ = %value ]</dt>
	<dt>%image . `height$m [ = %value ]</dt>
	<dd>
これらの属性は、［
この画像の実際に描画される寸法が既知ならば それ ／
~ELSE_ 0
］を返す。
◎
These attributes return the actual rendered dimensions of the image, or zero if the dimensions are not known.
</dd>
	<dd>
設定して，対応する内容~属性を変更できる。
◎
They can be set, to change the corresponding content attributes.
</dd>

	<dt>%image . `naturalWidth$m</dt>
	<dt>%image . `naturalHeight$m</dt>
	<dd>
これらの属性は、［
この画像の`内在的~寸法$が既知ならば それ ／
~ELSE_ 0
］を返す
◎
These attributes return the intrinsic dimensions of the image, or zero if the dimensions are not known.
</dd>

	<dt>%image . `complete$m</dt>
	<dd>
この画像は［
完全に~downloadされた, または 指定されていないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the image has been completely downloaded or if no image is specified; otherwise, returns false.
</dd>

	<dt>%image . `currentSrc$m</dt>
	<dd>
この画像の`絶対~URL$を返す。
◎
Returns the image's absolute URL.
</dd>

	<dt>%image . `decode()$m</dt>
	<dd>
この~methodは、~UAに画像を`並列的$に`復号-$させ，［
復号が完了した時点で充足されることになる~promise
］を返す。
◎
This method causes the user agent to decode the image in parallel, returning a promise that fulfills when decoding is complete.
</dd>
	<dd>
画像を復号できなかった場合、~promiseは `EncodingError$E 例外で却下されることになる。
◎
The promise will be rejected with an "EncodingError" DOMException if the image cannot be decoded.
</dd>

	<dt>%image = new `Image( [ width [, height ] ] )$m</dt>
	<dd>
新たな `img$e 要素を返す
— ［
%width ／ %height
］が与えられていれば、それを要素の［
`width$a ／ `height$a
］属性に設定した上で。
◎
Returns a new img element, with the width and height attributes set to the values passed in the relevant arguments, if applicable.
</dd>

</dl>

<dl class="idl-def">
	<dt>`width@m</dt>
	<dt>`height@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル
— この手続きにおける “~size” は、
`width^m に対しては横幅, 
`height^m に対しては縦幅を指すとする：
</p>
		<ol>
			<li>
~IF［
此れの`画像は可用$でない
］
⇒
~RET 0
</li>
			<li>
~IF［
画像は`具現化されて$いる
］~AND［
画像が具現化されている~mediaは視覚的である
］
⇒
~RET
`px$css 単位で測った，描画された画像の~size
</li>
			<li>
~IF［
画像の`内在的~寸法$はある
］
⇒
~RET 画像の`密度補正済み内在的~size$
</li>
			<li>
~RET 0
</li>
		</ol>

`CSS$r
◎
The IDL attributes width and height must return the rendered width and height of the image, in CSS pixels, if the image is being rendered, and is being rendered to a visual medium; or else the density-corrected intrinsic width and height of the image, in CSS pixels, if the image has intrinsic dimensions and is available but not being rendered to a visual medium; or else 0, if the image is not available or does not have intrinsic dimensions. [CSS]
</dd>
	<dd>
設定子は、順に（同じ名前の）
`width$a,
`height$a
内容~属性を`反映して$いるかのように動作するモノトスル。
◎
On setting, they must act as if they reflected the respective content attributes of the same name.
</dd>

	<dt>`naturalWidth@m</dt>
	<dt>`naturalHeight@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル
— この手続きにおける “~size” は、
`naturalWidth^m に対しては横幅, 
`naturalHeight^m に対しては縦幅を指すとする：
</p>
		<ol>
			<li>
~IF［
此れの`画像は可用$でない
］
⇒
~RET 0
</li>
			<li>
~IF［
画像の`内在的~寸法$はある
］
⇒
~RET 画像の`密度補正済み内在的~size$
］
</li>
			<li>
~RET 0
</li>
		</ol>

`CSS$r
◎
The IDL attributes naturalWidth and naturalHeight must return the density-corrected intrinsic width and height of the image, in CSS pixels, if the image has intrinsic dimensions and is available, or else 0. [CSS]
</dd>
	<dd class="note">注記：
画像の`内在的~寸法$は，その~metadata内に指定された方位を織り込むので、
`naturalWidth$m, `naturalHeight$m
は，画像を正しく方位するために必要な回転を適用した後の寸法を反映する
— `image-orientation$p ~propの値に関わらず。
◎
Since the intrinsic dimensions of an image take into account any orientation specified in its metadata, naturalWidth and naturalHeight reflect the dimensions after applying any rotation needed to correctly orient the image, regardless of the value of the 'image-orientation' property.
</dd>

	<dt>`complete@m</dt>
	<dd>
<p>
取得子は、［
次の条件いずれかが満たされるならば ~T ／
~ELSE_ ~F
］を返すモノトスル：
◎
The IDL attribute complete must return true if any of the following conditions is true:
</p>
		<ul>
			<li>
［
此れは `srcset$a 属性を有していない
］~AND［
此れは `src$a 属性を［
有していないか，有していて その値 ~EQ 空~文字列
］］
◎
Both the src attribute and the srcset attribute are omitted.
◎
The srcset attribute is omitted and the src attribute's value is the empty string.
</li>
			<li>
［
此れの`現在の要請$の`状態$ ~IN { `完全に可用$st, `壊en$st }
］~AND［
此れの`処理待ち要請$ ~EQ ~NULL
］
◎
The img element's current request's state is completely available and its pending request is null.
◎
The img element's current request's state is broken and its pending request is null.
◎
Otherwise, the attribute must return false.
</li>
		</ul>
	</dd>

	<dt>`currentSrc@m</dt>
	<dd>
取得子は、此れの`現在の要請$の`現在の~URL$を返すモノトスル。
◎
The currentSrc IDL attribute must return the img element's current request's current URL.
</dd>

	<dt>`decode()@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを遂行するモノトスル：
◎
The decode() method, when invoked, must perform the following steps:
</p>
		<ol>
			<li>
%~promise ~LET 新たな~promise
◎
Let promise be a new promise.
</li>
			<li>
<p>
次を遂行する`小taskを~queueする$：
◎
Queue a microtask to perform the following steps:
</p>

<div class="note">
<p>注記：
これが行われるのは、`画像~dataを更新する$手続きが小task内も占めるからである。
したがって、次のような~codeに対し：
◎
This is done because updating the image data takes place in a microtask as well. Thus, to make code such as
</p>

<pre class="lang-js">
img.src = "stars.jpg";
img.decode();
</pre>

<p>
`stars.jpg^c を適正に復号するためには、処理を小task 1 個分だけ遅延する必要がある。
◎
properly decode stars.jpg, we need to delay any processing by one microtask.
</p>
</div>
				<ol>
					<li>
<p>
~IF［
此れは次のいずれかを満たす
］…：
◎
If any of the following conditions are true about this img element:
</p>
						<ul>
							<li>
`~node文書$は`作動中$docでない
◎
its node document is not an active document;
</li>
							<li>
`現在の要請$の`状態$ ~EQ `壊en$st
◎
its current request's state is broken,
</li>
						</ul>
<p>
…ならば
⇒
`EncodingError$E 例外で %~promise を却下する
◎
then reject promise with an "EncodingError" DOMException.
</p>
					</li>
					<li>
<p>
~ELSE
⇒
`並列的$に、次のいずれかが生じるまで待機した上で，対応する動作を遂行する：
◎
Otherwise, in parallel, wait for one of the following cases to occur, and perform the corresponding actions:
</p>
						<dl class="switch">
							<dt>
此れの`~node文書$は`作動中$docでなくなった
◎
This img element's node document stops being an active document
</dt>
							<dt>
此れの`現在の要請$は 変化したか変異された
◎
This img element's current request changes or is mutated
</dt>
							<dt>
此れの`現在の要請$の`状態$ ~EQ `壊en$stになった
◎
This img element's current request's state becomes broken
</dt>
							<dd>
`EncodingError$E 例外で %~promise を却下する
◎
Reject promise with an "EncodingError" DOMException.
</dd>

							<dt>
此れの`現在の要請$の`状態$は`完全に可用$stになった
◎
This img element's current request's state becomes completely available
</dt>
							<dd>
<p>
画像を`復号-$する
— その結果に応じて：
◎
Decode the image.
</p>
<div >
								<dl class="switch">
									<dt>
この画像に対する復号を遂行する必要はない（例えば，画像は~vector~graphicである）：
</dt>
									<dt>
復号は成功裡に完了した：
</dt>
									<dd>
~undefined で %~promise を解決する
</dd>

									<dt>
復号に失敗した（例えば，画像~dataは妥当でないことに因り）：
</dt>
									<dd>
`EncodingError$E 例外で %~promise を却下する
</dd>

									<dd>
</dd>
								</dl>

◎
If decoding does not need to be performed for this image (for example because it is a vector graphic), resolve promise with undefined.
◎
If decoding fails (for example due to invalid image data), reject promise with an "EncodingError" DOMException.
◎
If the decoding process completes successfully, resolve promise with undefined.
</div>

<p>
~UAは、［
復号された~media~dataが，すぐ可用な~~状態であり続ける
］ことを確保するべきである
— 少なくとも，`~event~loop$における次回の`描画を更新する$ 段が成功裡に終端するまでは。
これは、~API契約の重要な部分を成し，アリな限り違約されるべきでない。
（これに違反するのは，概して、~memoryが少なく復号された画像~dataを抹消する要がある状況か，復号された形で~~一時に保つには画像が大き過ぎるときに限られるであろう。）
◎
User agents should ensure that the decoded media data stays readily available until at least the end of the next successful update the rendering step in the event loop. This is an important part of the API contract, and should not be broken if at all possible. (Typically, this would only be violated in low-memory situations that require evicting decoded image data, or when the image is too large to keep in decoded form for this period of time.)
</p>
							</dd>
						</dl>

<p class="note">注記：
~animate化~画像が`完全に可用$stになるのは、そのすべての~frameが読込まれた後に限られる。
したがって，実装が その時点より前に最初の~frameを復号できるとしても、上の手続きではそうすることなく，すべての~frameが可用になるまで待機する。
◎
Animated images will become completely available only after all their frames are loaded. Thus, even though an implementation could decode the first frame before that point, the above steps will not do so, instead waiting until all frames are available.
</p>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return promise.
</li>
		</ol>
	</dd>
	<dd class="example">
<p>
`decode$m ~methodを使わずに， `img$e 要素を読込んでから表示する処理-は、次の様になるであろう：
◎
Without the decode() method, the process of loading an img element and then displaying it might look like the following:
</p>

<pre class="lang-js">
const %img = new Image();
%img.src = "nebula.jpg";
%img.onload = () =&gt; {
    document.body.appendChild(%img);
};
%img.onerror = () =&gt; {
    document.body.appendChild(new Text("nebula を読込めませんでした：("));
};
</pre>

<!-- 
Could not load the nebula :
-->

<p>
しかしながら，これでは、何~frameか目につくほどに落とされ得る
— 画像を~DOMの中に挿入した後に生じる塗りには，~main~threadにおける同期的な復号を要するので。
◎
However, this can cause notable dropped frames, as the paint that occurs after inserting the image into the DOM causes a synchronous decode on the main thread.
</p>

<p>
`decode$m ~methodを利用すれば、これを次の様に書き直せる：
◎
This can instead be rewritten using the decode() method:
</p>

<pre class="lang-js">
const %img = new Image();
%img.src = "nebula.jpg";
%img.decode().then(() =&gt; {
    document.body.appendChild(%img);
}).catch(() =&gt; {
    document.body.appendChild(new Text("nebula を読込めませんでした： ("));
});
</pre>

<p>
この形であれば、画像が~DOMに挿入される（したがって塗られる）のは，それを`並列的$に復号して復号が完了した後に限られるので、~frameが落とされるのを避けれる。
◎
This latter form avoids the dropped frames of the original, by allowing the user agent to decode the image in parallel, and only inserting it into the DOM (and thus causing it to be painted) once the decoding process is complete.
</p>
	</dd>
	<dd class="example">
<p>
`decode()$m ~methodは，復号された画像~dataが 1 ~frame以内に可用になるのを確保しようと試みるので、 `requestAnimationFrame()$m ~APIと組合せることもできる。
このことは、［
すべての~DOM改変が，`~animation~frame~callback~map$に一括して~batchされる
］ことを確保するような［
~coding-style／~framework
］と併用できることを意味する：
◎
Because the decode() method attempts to ensure that the decoded image data is available for at least one frame, it can be combined with the requestAnimationFrame() API. This means it can be used with coding styles or frameworks that ensure that all DOM modifications are batched together as animation frame callbacks:
</p>

<pre class="lang-js">
const %container = document.querySelector("#container");

const { %containerWidth, %containerHeight } = computeDesiredSize();
requestAnimationFrame(() =&gt; {
 %container.style.width = %containerWidth;
 %container.style.height = %containerHeight;
});

// ...

const %img = new Image();
%img.src = "supernova.jpg";
%img.decode().then(() =&gt; {
    requestAnimationFrame(() =&gt; %container.appendChild(%img));
});
</pre>

	</dd>

	<dt>`Image(width, height)@m</dt>
	<dd>
この旧来の~factory関数は、 `HTMLImageElement$I ~objを作成する（ `createElement()$m などの~DOMによる~factory~methodに加えて供されている）。
◎
A legacy factory function is provided for creating HTMLImageElement objects (in addition to the factory methods from DOM such as createElement()): Image(width, height).＼
</dd>
	<dd>
<p>
被呼出時には、次の手続きを遂行するモノトスル：
◎
When invoked, the legacy factory function must perform the following steps:
</p>
		<ol>
			<li>
%文書 ~LET `現在の大域~obj$に`結付けられている文書$
◎
Let document be the current global object's associated Document.
</li>
			<li>
%img ~LET `要素を作成する$( %文書, `img^l, `~HTML名前空間$ )
◎
Let img be the result of creating an element given document, img, and the HTML namespace.
</li>
			<li>
~IF［
%width は与えられている
］
⇒
%img の`属性~値を設定する$( `width^l,  %width )
◎
If width is given, then set an attribute value for img using "width" and width.
</li>
			<li>
~IF［
%height は与えられている
］
⇒
%img の`属性~値を設定する$( `height^l, %height )
◎
If height is given, then set an attribute value for img using "height" and height.
</li>
			<li>
~RET %img
◎
Return img.
</li>
		</ol>
	</dd>
</dl>

<div class="example">

<p>
同じ画像であっても、それに適切な代替~textは，文脈に依存して異なり得る。
◎
A single image can have different appropriate alternative text depending on the context.
</p>

<p>
以下の各~事例には，どれも同じ画像が利用されているが、それでも `alt$a ~textは，事例ごとに異なる。
画像は、スイス ジュネーヴ州
<a href="https://upload.wikimedia.org/wikipedia/commons/f/fc/Carouge-coat_of_arms.svg">カルージュ自治体の紋章</a>
である。
◎
In each of the following cases, the same image is used, yet the alt text is different each time. The image is the coat of arms of the Carouge municipality in the canton Geneva in Switzerland.
</p>

<p>
次の画像は、補足~iconとして利用されている：
◎
Here it is used as a supplementary icon:
</p>

`img-1^xCode

<p>
次の画像は、町を表現している~iconとして利用されている：
◎
Here it is used as an icon representing the town:
</p>

`img-2^xCode

<p>
次の画像は、町についての~textの一部として利用されている：
◎
Here it is used as part of a text on the town:
</p>

`img-3^xCode

<p>
次の画像は，同様の~textを~supportする仕方として利用されており、画像の代替は，代わりに記述として与えられている：
◎
Here it is used as a way to support a similar text where the description is given as well as, instead of as an alternative to, the image:
</p>

`img-4^xCode

<p>
次の画像は、物語の一部として利用されている：
◎
Here it is used as part of a story:
</p>

`img-5^xCode

<p>
次の画像は、刊行~時点では，何らかの種類の紋章になることのみしか既知でないため，代用~textは供せない
— `title$a 属性~内には 画像~用の概略的~captionしか供せていない：
◎
Here it is not known at the time of publication what the image will be, only that it will be a coat of arms of some kind, and thus no replacement text can be provided, and instead only a brief caption for the image is provided, in the title attribute:
</p>

`img-6^xCode

<p>
この事例でも、作者は，本当の代用~textを供する仕方を見出すのが理想だが。
例えば、当の利用者にそれも供するよう依頼するなど。
代用~textが供されていないと、画像を見れない人達にとって，文書の利用が困難になる
— 例：
盲目の利用者 ／
接続の帯域幅がごく狭い／
従量課金 ／
~textのみの~Web~browserを利用するよう強いられているなど。
◎
Ideally, the author would find a way to provide real replacement text even in this case, e.g. by asking the previous user. Not providing replacement text makes the document more difficult to use for people who are unable to view images, e.g. blind users, or users or very low-bandwidth connections or who pay by the byte, or users who are forced to use a text-only Web browser.
</p>

</div>

<div class="example">
<p>
絵図は同じでも、適切に代替する~textは，文脈に応じて異なる例：
◎
Here are some more examples showing the same picture used in different contexts, with different appropriate alternate texts each time.
</p>

`img-7^xCode

`img-8^xCode

`img-9^xCode

`img-10^xCode

</div>

			</section>
			<section id="images">
<h3 title="Images">4.8.4. 画像</h3>

				<section id="introduction-3">
<h4 title="Introduction">4.8.4.1. 序論</h4>

~INFORMATIVE

<p>
~HTML内に画像~資源を 1 個だけ画像を埋込むときは、
`img$e 要素と その `src$a 属性を利用する。
◎
To embed an image in HTML, when there is only a single image resource, use the img element and its src attribute.
</p>

<div class="example">

`intro-1^xCode

</div>

<p>
しかしながら、作者が複数の画像~資源を利用して，~UAにそれらから選ばせたいと望むかもしれない状況も，いくつかある：
◎
However, there are a number of situations for which the author might wish to use multiple image resources that the user agent can choose from:
</p>

<ul>
	<li>
<p>
環境~上の特徴は、利用者ごとに異なるかもしれない：
◎
Different users might have different environmental characteristics:
</p>

		<ul>
			<li>
<p>
~screenの物理的~sizeは、利用者ごとに異なるかもしれない。
◎
The users' physical screen size might be different from one another.
</p>

<div class="example">
<p>
~screenの対角線は、携帯~電話では 4 ~inchである一方，
~laptopでは 14 ~inchかもしれない。
◎
A mobile phone's screen might be 4 inches diagonally, while a laptop's screen might be 14 inches diagonally.
</p>

`intro-svg-1^xCode

</div>

      
<p class="note">注記：
これが関連するのは、画像の描画sizeが`表示域$~sizeに依存する場合に限られる。
◎
This is only relevant when an image's rendered size depends on the viewport size.
</p>

			</li>
			<li>

<p>
~screen画素~密度は、利用者ごとに異なるかもしれない。
◎
The users' screen pixel density might be different from one another.
</p>

<div class="example">

<p>
携帯~電話の~screenの~inchあたりの物理的~画素~数は、他に比べ 3 倍になるかもしれない
— ~screenの物理的~sizeに関わらず。
◎
A mobile phone's screen might have three times as many physical pixels per inch compared to another mobile phone's screen, regardless of their physical screen size.
</p>

`intro-svg-2^xCode

</div>

			</li>
			<li>
<p>
~zoom~levelは、利用者ごとに異なったり,
同じ利用者でも時間とともに変化するかもしれない。
◎
The users' zoom level might be different from one another, or might change for a single user over time.
</p>

<p class="example">
利用者は、より詳細な見かけを取得できるようにするため，特定0の画像を~zoomして大きくするかもしれない。
◎
A user might zoom in to a particular image to be able to get a more detailed look.
</p>

<p>
~zoom~levelと（前項の）~screen画素~密度の両者とも、
1 `px$css あたりの~screenの物理的~画素~数に影響し得る。
この比は、通例的に
`機器画素比@
と呼ばれている。
◎
The zoom level and the screen pixel density (the previous point) can both affect the number of physical screen pixels per CSS pixel. This ratio is usually referred to as device-pixel-ratio.
</p>

			</li>
			<li>
<p>
~screen方位は、利用者ごとに異なったり,
同じ利用者でも時間とともに変化するかもしれない。
◎
The users' screen orientation might be different from one another, or might change for a single user over time.
</p>

<div class="example">
<p>
~tabletは、~screenが
縦置き（ `portrait^en ）または横置き（ `landscape^en ）
になるよう，直立に保持されたり，真横に倒されることもある。
◎
A tablet can be held upright or rotated 90 degrees, so that the screen is either "portrait" or "landscape".
</p>

`intro-svg-3^xCode

</div>

			</li>
			<li>
<p>
~networkの［
速度 ／ 待時間 ／ 帯域幅~cost
］は、利用者ごとに異なったり, 同じ利用者でも時間とともに変化するかもしれない。
◎
The users' network speed, network latency and bandwidth cost might be different from one another, or might change for a single user over time.
</p>

<p class="example">
利用者の接続は、
仕事場では 高速, 短い待時間, 定額制 ／
家では 低速, 短い待時間, 定額制 ／
他所では 可変速, 長い待時間, 従量制
かもしれない。
◎
A user might be on a fast, low-latency and constant-cost connection while at work, on a slow, low-latency and constant-cost connection while at home, and on a variable-speed, high-latency and variable-cost connection anywhere else.
</p>

			</li>
		</ul>
	</li>
	<li>
<p>
作者は、同じ画像~内容を
— 通例的には `表示域$の横幅に依存して —
異なる描画sizeで示したいと求めるかもしれない。
これは、通例的に
`表示域に基づく選定@
と呼ばれている。
◎
Authors might want to show the same image content but with different rendered size depending on, usually, the width of the viewport. This is usually referred to as viewport-based selection.
</p>

<div class="example">

<p>
~Web~pageには、`表示域$の上端に その横幅の全体にわたる~bannerが常にあるかもしれない。
この事例では、画像の描画sizeは，~screenの物理的~sizeに依存する（~browser~windowは最大~化されているとする）。
◎
A Web page might have a banner at the top that always spans the entire viewport width. In this case, the rendered size of the image depends on the physical size of the screen (assuming a maximised browser window).
</p>

`intro-svg-4^xCode

</div>

<div class="example">

<p>
別の~Web~pageは、画像を何本かの~columnに並べていて，その本数は、~screenの物理的~sizeが［
小なら 1 本, 中なら 2 本, 大ならば 3 本
］あり、画像の描画sizeは，各~事例ごとに `表示域$を埋め尽くすため変わるかもしれない。
この事例では、画像の描画sizeは，~layoutは~column 1 本のときの方が ~screenは小さくとも， 2 本のときに比べ `大きくなる^emこともある。
◎
Another Web page might have images in columns, with a single column for screens with a small physical size, two columns for screens with medium physical size, and three columns for screens with big physical size, with the images varying in rendered size in each case to fill up the viewport. In this case, the rendered size of an image might be bigger in the one-column layout compared to the two-column layout, despite the screen being smaller.
</p>

`intro-svg-5^xCode

</div>

	</li>
	<li>

<p>
作者は、画像の描画sizeに依存して異なる画像~内容を
示したいと求めるかもしれない。
これは、通例的に
`~art-direction@
（ `art direction^en ）と呼ばれている。
◎
Authors might want to show different image content depending on the rendered size of the image. This is usually referred to as art direction.
</p>

<div class="example">
<p>
~Web~pageが，物理的~sizeが広い~screenで見られているときは（~browser~windowは最大~化されているとする）、作者は，画像の重要部分の周囲に さほど関連しない部分を含ませたいと望む一方で、同じ~Web~pageが狭い~screenで見られているときは画像の重要部分だけ示したいと望むかもしれない。
◎
When a Web page is viewed on a screen with a large physical size (assuming a maximised browser window), the author might wish to include some less relevant parts surrounding the critical part of the image. When the same Web page is viewed on a screen with a small physical size, the author might wish to show only the critical part of the image.
</p>

`intro-svg-6^xCode

</div>

	</li>
	<li>

<p>
作者は、同じ画像~内容を，~UAが~supportする画像~形式に依存して，異なる画像~形式で示したいと求めるかもしれない。
これは、通例的に
`画像~形式に基づく選定@
と呼ばれている。
◎
Authors might want to show the same image content but using different image formats, depending on which image formats the user agent supports. This is usually referred to as image format-based selection.
</p>

<p class="example">
~Web~pageには、［
~JPEG, ~WebP, ~JPEG-XR
］などの各種 画像~形式による画像があるかもしれない
— 後の 2 つの方が、~JPEGに比べ圧縮~能が良い。
~supportされる画像~形式は~UAごと異なり，形式によってはより良い圧縮~比を提供するので、作者は，~UAがより良い形式を~supportするときはそれ, しないときは~fallbackとして~JPEGを供するよう~serveしたいであろう。
◎
A Web page might have some images in the JPEG, WebP and JPEG XR image formats, with the latter two having better compression abilities compared to JPEG. Since different user agents can support different image formats, with some formats offering better compression ratios, the author would like to serve the better formats to user agents that support them, while providing JPEG fallback for user agents that don't.
</p>

	</li>
</ul>

<p>
上に挙げた各 状況は、互いに排他的ではない。
例えば、 `機器画素比$ごとに異なる資源を，`~art-direction$用に異なる資源も伴うように組合せることは、理にかなう。
◎
The above situations are not mutually exclusive. For example, it is reasonable to combine different resources for different device-pixel-ratio with different resources for art direction.
</p>

<p>
これらの問題を~scriptingを利用して解くこともアリだが、そうすると他の問題も導入される：
◎
While it is possible to solve these problems using scripting, doing so introduces some other problems:
</p>

<ul>
	<li>
~UAには、~Web~pageの読込ngが早く完了するよう，~scriptが走る機会を得る前に，~HTML~markup内に指定された画像を先取的に~downloadするものもある。
 ~scriptが~downloadする画像を変更した場合、~UAは 2 回の~downloadを別々に開始することになり，~pageの読込ng処理能が悪化しかねない。
◎
Some user agents aggressively download images specified in the HTML markup, before scripts have had a chance to run, so that Web pages complete loading sooner. If a script changes which image to download, the user agent will potentially start two separate downloads, which can instead cause worse page loading performance.
</li>
	<li>
作者が~HTML~markup内に画像を指定するのを避けて，~scriptから 1 回だけ~downloadすることにした場合、上述の二重~download問題は避けれるが，~scriptingを不能化した利用者に対しては画像は まったく~downloadされず，画像を先取的に~downloadする最適化も不能化されることになる。
◎
If the author avoids specifying any image in the HTML markup and instead instantiates a single download from script, that avoids the double download problem above but then no image will be downloaded at all for users with scripting disabled and the aggressive image downloading optimization will also be disabled.
</li>
</ul>

<p>
このことを念頭に，この仕様は、上の問題に宣言的な方式で取組む，いくつかの特能を導入する。
◎
With this in mind, this specification introduces a number of features to address the above problems in a declarative manner.
</p>

<dl>
	<dt>
画像の描画sizeは固定されているときの`機器画素比$に基づく選定：
◎
Device-pixel-ratio-based selection when the rendered size of the image is fixed
</dt>
	<dd>
<p>
`img$e 要素~上の
`src$a, `srcset$a
属性に `x^v 記述子を利用すれば、~sizeだけ異なる複数の画像を供せる（小さい方の画像は 大きい方の画像を縮小したもの）。
◎
The src and srcset attributes on the img element can be used, using the x descriptor, to provide multiple images that only vary in their size (the smaller image is a scaled-down version of the bigger image).
</p>

<p class="note">注記：
`x^v 記述子は、画像の描画sizeが`表示域$の横幅に依存するとき（`表示域に基づく選定$）は 適切でないが、`~art-direction$と併用できる。
◎
The x descriptor is not appropriate when the rendered size of the image depends on the viewport width (viewport-based selection), but can be used together with art direction.
</p>

<div class="example">

`intro-2^xCode

<p>
~UAは、所与の資源のどれかを，利用者の［
~screenの画素~密度,
~zoom~level,
場合によっては利用者の~network条件などの他の要因
］に依存して選べる。
◎
The user agent can choose any of the given resources depending on the user's screen's pixel density, zoom level, and possibly other factors such as the user's network conditions.
</p>

<p>
`srcset$a 属性を解さない旧~UAとの後方-互換性のため、
`img$e 要素の `src$a 属性~内にも 1 個の~URLが指定されている。
これにより、旧~UAにて表示されるときでも有用になる（その解像度は、たぶん利用者の好みより低くなるであろうが）。
`src$a 属性は、新しい~UAに対しても，資源~選定に関与する
— その値に記述子 `1x^v を伴わせたものが `srcset$a にも指定されていたかのように。
◎
For backwards compatibility with older user agents that don't yet understand the srcset attribute, one of the URLs is specified in the img element's src attribute. This will result in something useful (though perhaps lower-resolution than the user would like) being displayed even in older user agents. For new user agents, the src attribute participates in the resource selection, as if it was specified in srcset with a 1x descriptor.
</p>

<p>
`width$a, `height$a
属性~内には、画像の描画sizeが与えられている
— それにより，~UAは、画像を~downloadする前に それ用の空間を割振れるようになる。
◎
The image's rendered size is given in the width and height attributes, which allows the user agent to allocate space for the image before it is downloaded.
</p>

</div>
	</dd>

	<dt>`表示域に基づく選定$
◎
Viewport-based selection
</dt>
	<dd>
<p>
`srcset$a, `sizes$a
属性と `w^v 記述子を利用すれば、~sizeだけ異なる複数の画像を供せる（小さい方の画像は 大きい方の画像を縮小したもの）。
◎
The srcset and sizes attributes can be used, using the w descriptor, to provide multiple images that only vary in their size (the smaller image is a scaled-down version of the bigger image).
</p>

<div class="example">

<p>
この例では、~banner画像は，`表示域$の横幅 全体を占める（適切な~CSSを利用して）。
◎
In this example, a banner image takes up the entire viewport width (using appropriate CSS).
</p>

`intro-3^xCode

<p>
~UAは、指定された `w^v 記述子と `sizes$a 属性~内に指定された描画sizeから，各~画像の実効画素~密度を計算することになる。
次に~UAは、所与の資源のどれかを，利用者の［
~screenの画素~密度,
~zoom~level,
場合によっては利用者の~network条件などの他の要因
］に依存して選べる。
◎
The user agent will calculate the effective pixel density of each image from the specified w descriptors and the specified rendered size in the sizes attribute. It can then choose any of the given resources depending on the user's screen's pixel density, zoom level, and possibly other factors such as the user's network conditions.
</p>

<p>
利用者の~screen幅が 320 `px$css の場合、これは
`wolf-400.jpg 1.25x, wolf-800.jpg 2.5x, wolf-1600.jpg 5x^v
を指定することに等価になる。
他方，~screen幅が 1200 `px$css の場合、これは
`wolf-400.jpg 0.33x, wolf-800.jpg 0.67x, wolf-1600.jpg 1.33x^v
を指定することに等価になる。
`w^v 記述子と `sizes$a 属性を利用することにより、利用者の機器の大きさに関わらず，~UAは~downloadする正しい画像~sourceを選べる。
◎
If the user's screen is 320 CSS pixels wide, this is equivalent to specifying wolf-400.jpg 1.25x, wolf-800.jpg 2.5x, wolf-1600.jpg 5x. On the other hand, if the user's screen is 1200 CSS pixels wide, this is equivalent to specifying wolf-400.jpg 0.33x, wolf-800.jpg 0.67x, wolf-1600.jpg 1.33x. By using the w descriptors and the sizes attribute, the user agent can choose the correct image source to download regardless of how large the user's device is.
</p>

<p>
後方-互換性のため， ~URLのうち 1 つが `img$e 要素の`src$a 属性~内に指定される。
新しい~UAにおいては、 `srcset$a 属性が `w^v 記述子を利用しているときは，
`src$a 属性は無視される。
◎
For backwards compatibility, one of the URLs is specified in the img element's src attribute. In new user agents, the src attribute is ignored when the srcset attribute uses w descriptors.
</p>

</div>

<div class="example">

<p>
この例の~Web~pageの~layoutは、`表示域$の横幅に依存して 3 種に分かれる。
一連の画像は、~layout幅が［
狭いときは 1 本,
中程度のときは 2 本,
広いときは 3 本
］の~columnに並べられ（各~画像の横幅は、順に，およそ 100%, 50%, 33% ）、それに加え~page~marginがある。
これらの~layoutは、`表示域$の幅 `30em^v, `50em^v を境目に分かたれる。
◎
In this example, the Web page has three layouts depending on the width of the viewport. The narrow layout has one column of images (the width of each image is about 100%), the middle layout has two columns of images (the width of each image is about 50%), and the widest layout has three columns of images, and some page margin (the width of each image is about 33%). It breaks between these layouts when the viewport is 30em wide and 50em wide, respectively.
</p>

`intro-4^xCode

<p>
`sizes$a 属性は、~layoutの境目を［
`30em^v, `50em^v
］の所に設定しておき、これらの境目で区切られる順に，画像~sizeは［
`100vw^v, `50vw^v, `calc(33vw - 100px)^v
］になるよう宣言する。
これらの~sizeを［
~CSSで指定する実際の画像~横幅
］に正確に合致させることは、必要とされない。
◎
The sizes attribute sets up the layout breakpoints at 30em and 50em, and declares the image sizes between these breakpoints to be 100vw, 50vw, or calc(33vw - 100px). These sizes do not necessarily have to match up exactly with the actual image width as specified in the CSS.
</p>

<p>
~UAは、
`media-condition$t （丸括弧の中）が 真に評価されるような
最初の~itemを利用して，あるいは すべてが偽に評価された場合は 最後の~item（
`calc(33vw - 100px)^v
）を利用して， `sizes$a 属性から横幅を選ぶことになる。
◎
The user agent will pick a width from the sizes attribute, using the first item with a &lt;media-condition&gt; (the part in parentheses) that evaluates to true, or using the last item (calc(33vw - 100px)) if they all evaluate to false.
</p>

<p>
例えば，`表示域$の横幅 %横幅 が `29em^v の場合、
`(max-width: 30em)^v
は 真に評価され，
`100vw^v が利用されるので、画像~sizeは，資源~選定の目的においては `29em^v になる。
%横幅 が `32em^v であった場合、
`(max-width: 30em)^v
は偽に評価されるが,
`(max-width: 50em)^v
は真に評価され，
`50vw^v が利用されるので、画像~sizeは，資源~選定の目的においては `16em^v になる（ %横幅 の半分）。
~layoutが異なることにより、`表示域$が少しだけ幅広になったときの画像が，より小さくなることに注意。
◎
For example, if the viewport width is 29em, then (max-width: 30em) evaluates to true and 100vw is used, so the image size, for the purpose of resource selection, is 29em. If the viewport width is instead 32em, then (max-width: 30em) evaluates to false, but (max-width: 50em) evaluates to true and 50vw is used, so the image size, for the purpose of resource selection, is 16em (half the viewport width). Notice that the slightly wider viewport results in a smaller image because of the different layout.
</p>

<p>
それから，~UAは、実効~画素~密度を計算して，前の例と同様に適切な資源を選べれるようになる。
◎
The user agent can then calculate the effective pixel density and choose an appropriate resource similarly to the previous example.
</p>

</div>

	</dd>

	<dt>`~art-direction$に基づく選定
◎
Art direction-based selection
</dt>
	<dd>
<p>
`picture$e 要素, `source$e 要素を `media$aS 属性と併用すれば、画像~内容が変わるような複数の画像を供せる（一例として，小さい方の画像は 大きい方の画像を切り抜いたもの）。
◎
The picture element and the source element, together with the media attribute, can be used, to provide multiple images that vary the image content (for instance the smaller image might be a cropped version of the bigger image).
</p>

<div class="example">

`intro-5^xCode

<p>
~UAは、 `picture$e 要素~内の `source$e 要素のうち，［
その `media$aS 属性~内の媒体~queryが環境に合致する
］ような最初のものを選んだ上で、その `srcset$aS 属性から適切な~URLを選ぶことになる。
◎
The user agent will choose the first source element for which the media query in the media attribute matches, and then choose an appropriate URL from its srcset attribute.
</p>

<p>
画像の描画sizeは、どの資源が選ばれたかに依存して変わる。
~CSSを利用すれば、~UAが画像を~downloadする前に利用できる寸法を指定できる。
◎
The rendered size of the image varies depending on which resource is chosen. To specify dimensions that the user agent can use before having downloaded the image, CSS can be used.
</p>

<pre class="lang-css">
img { width: 300px; height: 300px }
@media (min-width: 32em) { img { width: 500px; height:300px } }
@media (min-width: 45em) { img { width: 700px; height:400px } }
</pre>

</div>

<div class="example">
<p>
次の例では、`~art-direction$と`機器画素比$に基づく選定を組合せる。
`表示域$の半分を占める~bannerは、
~screen幅が広いとき, 狭いときの 2 種で供される。
◎
This example combines art direction- and device-pixel-ratio-based selection. A banner that takes half the viewport is provided in two versions, one for wide screens and one for narrow screens.
</p>

`intro-6^xCode

</div>

   </dd>

	<dt>`画像~形式に基づく選定$
◎
Image format-based selection
</dt>
	<dd>
<p>
`source$e 要素に `type$aS 属性を利用すれば、異なる形式による複数の画像を供せる。
◎
The type attribute on the source element can be used, to provide multiple images in different formats.
</p>

<div class="example">

`intro-7^xCode

<p>
この例では、~UAは，［
自身が~supportする~MIME型を伴う `type$aS 属性を有する
］ような，最初の~sourceを選ぶことになる。
~UAが ~WebP画像を~supportするなら最初の `source$e 要素が選ばれ，そうでないが ~JPEG-XR画像を~supportするなら 2 個目の `source$e 要素が選ばれ，両~形式とも~supportしなければ `img$e 要素が選ばれることになる。
◎
In this example, the user agent will choose the first source that has a type attribute with a supported MIME type. If the user agent supports WebP images, the first source element will be chosen. If not, but the user agent does support JPEG XR images, the second source element will be chosen. If neither of those formats are supported, the img element will be chosen.
</p>

</div>

	</dd>
</dl>

					<section id="adaptive-images">
<h5 title="Adaptive images">4.8.4.1.1. 適応的な画像</h5>

~INFORMATIVE

<p>
~CSSと媒体~queryを利用すれば、利用者の環境に動的に適応するような~graphicな~page~layoutを構築できる
— 特に，異なる`表示域$寸法と画素~密度に応じて。
しかしながら，内容に対しては~CSSは助けにならない
— その代わりとして、
`img$e 要素の `srcset$a 属性, および `picture$e 要素がある。
この節では、これらの特能の用-法を示す見本~事例を順に見ていく。
◎
CSS and media queries can be used to construct graphical page layouts that adapt dynamically to the user's environment, in particular to different viewport dimensions and pixel densities. For content, however, CSS does not help; instead, we have the img element's srcset attribute and the picture element. This section walks through a sample case showing how to use these features.
</p>

<p>
次の状況を考える：
~screenが幅広のときは（ 600 `px$css より幅広），名前 `a-rectangle.png^v の 300×150 画像が利用され、
より狭い~screenのときは（ 600 `px$css 以下）
より小さい 100×100 の画像 `a-square.png^v が利用されることになるような。
このための~markupは、次の様な見かけになるであろう：
◎
Consider a situation where on wide screens (wider than 600 CSS pixels) a 300×150 image named a-rectangle.png is to be used, but on smaller screens (600 CSS pixels and less), a smaller 100×100 image called a-square.png is to be used. The markup for this would look like this:
</p>

`intro-8^xCode

<p class="note">注記：
`alt$a 属性~内に何を置くかについての詳細は、
`§ 画像~用の代替として動作する~textを供するときの要件$を見よ。
◎
For details on what to put in the alt attribute, see the Requirements for providing text to act as an alternative for images section.
</p>

<p>
ここでの問題は、~UAにとっては，当の画像を読込んでいる間 画像に利用する寸法を知れるとは限らないことである。
~CSSと~CSS媒体~queryを利用して寸法を供すれば、~pageを読込んでいる間に ~layoutが何回も再flowされるのを避けれる：
◎
The problem with this is that the user agent does not necessarily know what dimensions to use for the image when the image is loading. To avoid the layout having to be reflowed multiple times as the page is loading, CSS and CSS media queries can be used to provide the dimensions:
</p>

`intro-9^xCode

<p>
代替として，
`width$a, `height$a
属性を利用すれば、旧来の~UA用にも横幅と縦幅を供せる
— ~CSSは `picture$e を~supportする~UAにだけ利用することにして：
◎
Alternatively, the width and height attributes can be used to provide the width and height for legacy user agents, using CSS just for the user agents that support picture:
</p>

`intro-10^xCode

<hr>

<p>
`img$e 要素に利用されている `src$a 属性は、
`picture$e 要素を~supportしない旧来の~UAに対しては，利用する画像の~URLを与える。
ここで、どの画像を `src$a 属性に供するかの 問いへ導く。
◎
The img element is used with the src attribute, which gives the URL of the image to use for legacy user agents that do not support the picture element. This leads to a question of which image to provide in the src attribute.
</p>

<p>
作者が 旧来の~UAでは最~大の画像を求める場合、~markupは，次のようにも記せる：
◎
If the author wants the biggest image in legacy user agents, the markup could be as follows:
</p>

`intro-11^xCode

<p>
しかしながら，旧来の携帯~機~UAの方が重要な場合、
3 個の画像すべてを `source$e 要素~内に挙げれば
`src$a 属性を まるごと上書きできる：
◎
However, if legacy mobile user agents are more important, one can list all three images in the source elements, overriding the src attribute entirely.
</p>

`intro-12^xCode

<p>
この場合の `src$a 属性は，実際に `picture$e を~supportする~UAからは まるごと無視されるので、どの画像であれ，その大きさに関わらず既定として与えれる：
◎
Since at this point the src attribute is actually being ignored entirely by picture-supporting user agents, the src attribute can default to any image, including one that is neither the smallest nor biggest:
</p>

`intro-13^xCode

<hr>

<p>
上では，最大~寸法（`表示域$のそれ）を与えるため、画像に意図される `max-width^css ~media特能が利用されている。
代わりに `min-width^css を利用することもアリである。
◎
Above the max-width media feature is used, giving the maximum (viewport) dimensions that an image is intended for. It is also possible to use min-width instead.
</p>

`intro-14^xCode

					</section>
				</section>
				<section id="attributes-common-to-source-and-img-elements">
<h4 title="Attributes common to source, img, and link elements">4.8.4.2. `source^e, `img^e, `link^e 要素に共通の属性</h4>

					<section id="srcset-attributes">
<h5 title="Srcset attributes">4.8.4.2.1. ~srcset属性</h5>

<p>
`~srcset属性@
には、この節に定義される要件が課される。
◎
A srcset attribute is an attribute with requirements defined in this section.
</p>

<p class="trans-note">【
この “~srcset属性” は、［
`source^e 要素の `srcset$aS 属性,
`img^e 要素の `srcset$a 属性,
`link^e 要素の `imagesrcset$aL 属性
］の総称を表す。
】</p>

<div class="p">
<p>
この属性に指定する値は、次を満たさなければナラナイ：
</p>

<ul>
	<li>
互いに `002C^U `,^smb で区切られた
1 個~以上の`画像~候補~文字列$からなる。
</li>
	<li>
値を成す ある`画像~候補~文字列$が［
その~URLの後に記述子も`~ASCII空白$も包含しない
］ならば、その次の`画像~候補~文字列$の最初の文字は`~ASCII空白$である。
</li>
</ul>

◎
If present, its value must consist of one or more image candidate strings, each separated from the next by a U+002C COMMA character (,). If an image candidate string contains no descriptors and no ASCII whitespace after the URL, the following image candidate string, if there is one, must begin with one or more ASCII whitespace.
</div>

<p>
各
`画像~候補~文字列@
は、挙げられる順に，次の成分からなる
— この~listの他にも，その下に述べる制約がある：
◎
An image candidate string consists of the following components, in order, with the further restrictions described below this list:
</p>

<ol>
	<li>
0 個~以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
	<li>
1 個の`妥当かつ空でない~URL$であって，
先頭, 末尾の両~文字とも `002C^U `,^smb
でないものであって、対話的でも, 多pageでも, ~scriptありでもない画像~資源（~animate化されていてもよい）を参照しているもの。
◎
A valid non-empty URL that does not start or end with a U+002C COMMA character (,), referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted.
</li>
	<li>
0 個~以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
	<li>
<p>
次のうち，いずれか 1 つ：
◎
Zero or one of the following:
</p>

		<ul>
			<li>
空~文字列
</li>
			<li>
<p>
`横幅~記述子@
を与える，次の並び：
</p>

<ol ><li>1 個の`~ASCII空白$
</li><li>1 個の`妥当な負でない整数$であって、 0 より大きい数を与えるもの
— これは
`横幅~値@
を表現する
</li><li>1 個の文字 `0077^U `w^smb
</li></ol>

◎
A width descriptor, consisting of: ASCII whitespace, a valid non-negative integer giving a number greater than zero representing the width descriptor value, and a U+0077 LATIN SMALL LETTER W character.
</li>
	<li>
<p>
`画素~密度~記述子@
を与える，次の並び：
</p>

<ol><li >1 個の`~ASCII空白$
</li><li>1 個の`妥当な浮動小数点数$であって、 0 より大きい数を与えるもの
— これは
`密度~値@
を表現する
</li><li>1 個の文字 `0078^U `x^smb
</li></ol>

◎
A pixel density descriptor, consisting of: ASCII whitespace, a valid floating-point number giving a number greater than zero representing the pixel density descriptor value, and a U+0078 LATIN SMALL LETTER X character.
</li>
		</ul>
<p class="trans-note">【
これらの記述子は、文脈に応じて，そのような文字列を指すこともあれば, 抽象的な値~型を意味することもある。
】</p>

	</li>
	<li>
0 個~以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
</ol>

<div class="p">
<p>
同じ要素の 複数の`画像~候補~文字列$においては：
</p>

<ul ><li>互いの`横幅~値$が同じになってはナラナイ。
</li><li>互いの`密度~値$が同じになってはナラナイ。
</li><li>この要件の目的においては、記述子を伴わない`画像~候補~文字列$は，記述子 `1x^v を伴う`画像~候補~文字列$と等価とする。
</li></ul>

◎
There must not be an image candidate string for an element that has the same width descriptor value as another image candidate string's width descriptor value for the same element.
◎
There must not be an image candidate string for an element that has the same pixel density descriptor value as another image candidate string's pixel density descriptor value for the same element. For the purpose of this requirement, an image candidate string with no descriptors is equivalent to an image candidate string with a 1x descriptor.
</div>

<p>
要素~用の ある`画像~候補~文字列$に`横幅~記述子$を指定している場合、他のすべての`画像~候補~文字列$にも`横幅~記述子$を指定しなければナラナイ。
◎
If an image candidate string for an element has the width descriptor specified, all other image candidate strings for that element must also have the width descriptor specified.
</p>

<p>
`画像~候補~文字列$の`横幅~記述子$にて指定される`横幅~値$は、`画像~候補~文字列$の~URLで与えられる資源に`内在的~横幅$がある場合には，それに合致させるモノトスル。
◎
The specified width in an image candidate string's width descriptor must match the intrinsic width in the resource given by the image candidate string's URL, if it has an intrinsic width.
</p>

<p>
要素が`~sizes属性$を有する場合、その要素~用の どの`画像~候補~文字列$にも`横幅~記述子$を指定しなければナラナイ。
◎
If an element has a sizes attribute present, all image candidate strings for that element must have the width descriptor specified.
</p>

					</section>
					<section id="sizes-attributes">
<h5 title="Sizes attributes">4.8.4.2.2. ~sizes属性</h5>

<p>
`~sizes属性@
には、この節に定義される要件が課される。
◎
A sizes attribute is an attribute with requirements defined in this section.
</p>

<p class="trans-note">【
この “~sizes属性” は、［
`source^e 要素の `sizes$aS 属性,
`img^e 要素の `sizes$a 属性,
`link^e 要素の `imagesizes$aL 属性
］の総称を表す。
】</p>

<p>
指定する値は、`妥当な~source~size~list$でなければナラナイ。
◎
If present, the value must be a valid source size list.
</p>

<p>
`妥当な~source~size~list@
は、次の文法に合致する文字列とする：
`CSSVALUES$r
`MQ$r
◎
A valid source size list is a string that matches the following grammar: [CSSVALUES] [MQ]
</p>

<pre class="prod">
`source-size-list@t = [ `source-size$t# , ]? `source-size-value$t
`source-size@t = `media-condition$t `source-size-value$t
`source-size-value@t = `length$t
</pre>

<p>
`source-size-value$t は、負になってはナラナイことに加え，`~math関数$以外の~CSS関数は利用してはナラナイ。
◎
A &lt;source-size-value&gt; must not be negative, and must not use CSS functions other than the math functions.
</p>

<p>
`source-size-value$t は、画像に意図される~layout横幅を与える。
作者は、 `media-condition$t で環境ごとに異なる横幅を指定できる。
◎
The &lt;source-size-value&gt; gives the intended layout width of the image. The author can specify different widths for different environments with &lt;media-condition&gt;s.
</p>

  
<p class="note">注記：
`source-size-value$t においては、百分率は許容されない
— 何に相対的になるかについての混同を避けるため。
`表示域$の横幅に相対的な~sizeには、 `vw$css 単位を利用できる。
◎
Percentages are not allowed in a &lt;source-size-value&gt;, to avoid confusion about what it would be relative to. The 'vw' unit can be used for sizes relative to the viewport width.
</p>

					</section>
				</section>
				<section id="images-processing-model">
<h4 title="Processing model">4.8.4.3. 処理~model</h4>

<div class="p">

<p>
各 `img$e 要素は、次のものを持つ：
</p>

<dl class="def-list">
	<dt>`現在の要請@</dt>
	<dd>
初期~時には新たな`画像~要請$に設定される。
</dd>

	<dt>`処理待ち要請@</dt>
	<dd>
`画像~要請$, または ε 。
初期~時は ε とする。
</dd>
</dl>

◎
An img element has a current request and a pending request. The current request is initially set to a new image request. The pending request is initially set to null.
</div>

<p>
各
`画像~要請@
は、次のものを持つ：
◎
An image request has a state, current URL, and image data.
</p>

<dl class="def-list">
	<dt>`状態@</dt>
	<dd>
<p>
次のいずれか
— 初期~時は `不可用$st とする：
◎
An image request's state is one of the following:
</p>

		<dl>
			<dt>`不可用@st
◎
Unavailable
</dt>
			<dd>
~UAは 画像~dataをある程度は得しているかもしれないが，画像の寸法を取得するまで十分に復号されていない。
◎
The user agent hasn't obtained any image data, or has obtained some or all of the image data but hasn't yet decoded enough of the image to get the image dimensions.
</dd>

			<dt>`部分的に可用@st
◎
Partially available
</dt>
			<dd>
~UAは 画像~dataの一部を得していて，少なくとも画像の寸法は可用である。
◎
The user agent has obtained some of the image data and at least the image dimensions are available.
</dd>

			<dt>`完全に可用@st
◎
Completely available
</dt>
			<dd>
~UAは すべての画像~dataを得していて，少なくとも画像の寸法は可用である。
◎
The user agent has obtained all of the image data and at least the image dimensions are available.
</dd>

			<dt>`壊en@st
◎
Broken
</dt>
			<dd>
~UAは できる限りすべての画像~dataを得したが、画像の寸法を取得するに十分に画像を復号できなかった（例：
画像は壊れている ／
形式は~supportされてない ／
まったく~dataを得せなかった）。
◎
The user agent has obtained all of the image data that it can, but it cannot even decode the image enough to get the image dimensions (e.g. the image is corrupted, or the format is not supported, or no data could be obtained).
</dd>
		</dl>
	</dd>

	<dt>`現在の~URL@</dt>
	<dd>
初期~時は空~文字列とする。
◎
An image request's current URL is initially the empty string.
</dd>

	<dt>`画像~data@</dt>
	<dd>
復号された画像~data。
初期~時は ε （なし）とする。
◎
An image request's image data is the decoded image data.
</dd>
</dl>

<p>
`img$e 要素は、次を満たすならば
`画像は可用@
であるとされる
⇒
その`現在の要請$の`状態$ ~IN  { `部分的に可用$st, `完全に可用$st }
◎
When an image request's state is either partially available or completely available, the image request is said to be available.
</p>

<p>
`img$e 要素は、次を満たすならば
`全部的に復号-可能@
であるとされる
⇒
［
その`現在の要請$の`状態$ ~EQ `完全に可用$st
］~AND［
~UAは その~media~dataを~errorなしに復号できる
］
◎
When an img element's current request's state is completely available and the user agent can decode the media data without errors, then the img element is said to be fully decodable.
◎
↑An image request's state is initially unavailable.
</p>

<div class="p">
<p>
`img$e 要素は、その`画像は可用$であるならば，次のような`塗り~source$を供する：
</p>
<ul ><li>横幅, 縦幅は、画像の`密度補正済み内在的~size$（横幅, 縦幅 それぞれに対し，もしあれば）
</li><li>外観は、画像の内在的~外観
</li></ul>

◎
When an img element's current request is available, the img element provides a paint source whose width is the image's density-corrected intrinsic width (if any), whose height is the image's density-corrected intrinsic height (if any), and whose appearance is the intrinsic appearance of the image.
</div>

<hr>

<p>
次を満たす `img$e 要素は、
`~srcsetまたは~pictureを利用して@
いるとされる
⇒
［
`srcset$a 属性を有する
］~OR［
親は `picture$e 要素である
］
◎
An img element is said to use srcset or picture if it has a srcset attribute specified or if it has a parent that is a picture element.
</p>

<hr>

<p>
各 `img$e 要素は、次のものも持つ：
◎
↓</p>

<dl class="def-list">
	<dt>`最後に選定された~source@</dt>
	<dd>
初期~時は ε （なし）になるモノトスル。
◎
Each img element has a last selected source, which must initially be null.
</dd>

	<dt>`現在の画素~密度@</dt>
	<dd>
初期~時は ε （未定義）になるモノトスル。
◎
Each image request has a current pixel density, which must initially be undefined.
</dd>
	<dd class="trans-note">【
これは，原文では各 `画像~要請$が持つものとして定義されているが、実際には `img^e 要素の`現在の要請$のそれしか参照されていないので、この訳では `img^e 要素が直に持つように単純~化している。
】</dd>
</dl>

<p>
`img$e 要素の`現在の画素~密度$ ~NEQ 1.0 のときは、
要素の画像~dataは、その解像度が［
1 `px$css あたりの機器~画素~数† ~EQ `現在の画素~密度$
］であったかのように扱うモノトスル。
画像の
`密度補正済み内在的~size@
とは、`現在の画素~密度$を織り込んだ後における， `px$css 単位で測った［
`内在的~横幅$ ／ `内在的~縦幅$
］である（ “~size” は、横幅／縦幅の総称）。
◎
When an img element has a current pixel density that is not 1.0, the element's image data must be treated as if its resolution, in device pixels per CSS pixels, was the current pixel density. The image's density-corrected intrinsic width and height are the intrinsic width and height after taking into account the current pixel density.
</p>

<p class="trans-note">【†
ここでの機器~画素の単位が何に基づくか述べられていないが（例えば機器の物理的な 1 画素は正方形でないかもしれない）、［
画像の 1 画素が “ある基準表示” において~screenを占める長さ
］として定義されると考えればよいであろう。
実際には、画像の画素~単位が何に基づくかは，画像~形式に依存するであろうし（例えば~vector画像）、何をもって “基準表示” とされるかは，環境に依存するかもしれないが。
そのような詳細は、ここには言及されていない（不要なので追求されていないと思われる）。
】</p>

<p class="example">
例えば、［
`現在の画素~密度$ ~EQ 3.125
］の場合、
1 `in$css （ ~EQ 96 `px$css ）あたりの機器~画素~数は 300 （~EQ 96 × 3.125 ）になることを意味する。
したがって、画像~dataの ( 横幅, 縦幅 ) が ( 300, 600 ) ならば，その
( `内在的~横幅$, `内在的~縦幅$ )
は
( 96 `px$css, 192 `px$css )
になる。
◎
For example, if the current pixel density is 3.125, that means that there are 300 device pixels per CSS inch, and thus if the image data is 300x600, it has intrinsic dimensions of 96 CSS pixels by 192 CSS pixels.
</p>

<p>
各［
`img$e ／ `link$e
］要素には、`~source集合$が結付けられる。
◎
All img and link elements are associated with a source set.
</p>

<p>
`~source集合@
は、［
0 個~以上の`画像~source$からなる有順序~集合
］, および
`~source~size$からなる：
◎
A source set is an ordered set of zero or more image sources and a source size.
</p>

<ul>
	<li>
<p>
各
`画像~source@
は、次のものからなる：
</p>

		<dl class="def-list">
			<dt>`~URL文字列@iS</dt>
			<dd>
画像~資源の`~URL$を与える文字列。
</dd>
			<dd class="trans-note">【
原文では単に`~URL$と記されているが（それは構造体である）、実際には文字列なので，この訳では このように言い換えることにする。
】</dd>

			<dt>`記述子@iS</dt>
			<dd>
［
ε（なし）, `横幅~記述子$, `画素~密度~記述子$
］のいずれか。
初期~時は ε 。
</dd>
			<dd class="trans-note">【
この “記述子” という語は、簡便に総称するために，この訳に導入した用語である。
】</dd>
		</dl>
◎
An image source is a URL, and optionally either a pixel density descriptor, or a width descriptor.
</li>
	<li>
`~source~size@
は， `source-size-value$t で与えられる。
その単位が`表示域$に相対的であるときは，［
`img$e 要素の`~node文書$の`表示域$
］に相対的に解釈するモノトスル。
他の単位は、 Media Queries `MQ$r に従って解釈するモノトスル。
◎
A source size is a &lt;source-size-value&gt;. When a source size has a unit relative to the viewport, it must be interpreted relative to the img element's node document's viewport. Other units must be interpreted the same as in Media Queries. [MQ]
</li>
</ul>

<hr>

<p>
この節における各~algoにおける
`構文解析-~error@
は、入力と要件との間の 致命的でない不一致を指示する。
~UAには、何らかの方法で`構文解析-~error$を公開することが奨励される。
◎
A parse error for algorithms in this section indicates a non-fatal mismatch between input and requirements. User agents are encouraged to expose parse errors somehow.
</p>

<hr>

<p>
画像が成功裡に~fetchされたかどうか（例：その応答~状態sは`~ok状態s$であったかどうか）は、［
画像の型 ／ 画像は妥当であるかどうか
］を決定するときには，無視するモノトスル。
◎
Whether the image is fetched successfully or not (e.g. whether the response status was an ok status) must be ignored when determining the image's type and whether it is a valid image.
</p>

<p class="note">注記：
これにより，~serverは、画像を~error応答で返して，それらを表示させれるようになる。
◎
This allows servers to return images with error responses, and have them displayed.
</p>

<p id="img-determine-type">
~UAは、画像の型を決定するときは，`画像を特定的に~sniffするための規則$を適用するべきである
— その
`公式的な型^i
【 `the official type^en — “名目上” のような意？】
には，画像に`結付けられている~Content-Type~header$ で与えられる型 %型 を与える下で。
これらの規則を適用しない場合、画像の型は %型 になるモノトスル。
◎
The user agent should apply the image sniffing rules to determine the type of the image, with the image's associated Content-Type headers giving the official type. If these rules are not applied, then the type of the image must be the type given by the image's associated Content-Type headers.
</p>

<p>
~UAは、 `img$e 要素においては：
◎
↓</p>

<ul>
	<li>
画像でない資源は~supportしないモノトスル（例：~XML~fileのうち，`文書~要素$は~HTML要素になるもの）。
◎
User agents must not support non-image resources with the img element (e.g. XML files whose document element is an HTML element).＼
</li>
	<li>
画像~資源~内に埋込まれた実行-可能~codeは走らせないモノトスル（例： ~script）。
◎
User agents must not run executable code (e.g. scripts) embedded in the image resource.＼
</li>
	<li>
資源が複pageである場合は、その最初の~pageのみ表示するモノトスル（例：~PDF~file）。
◎
User agents must only display the first page of a multipage resource (e.g. a PDF file).＼
</li>
	<li>
資源が対話的に動作するのを許容しないモノトスル。
◎
User agents must not allow the resource to act in an interactive fashion, but＼
</li>
	<li>
資源における~animationは、尊守するべきである。
◎
should honour any animation in the resource.
</li>
</ul>

<p>
この仕様は、どの画像~型が~supportされるかは指定しない。
◎
This specification does not specify which image types are to be supported.
</p>

					<section id="when-to-obtain-images">
<h5 title="When to obtain images">4.8.4.3.1. 画像をいつ得するか</h5>

<p>
既定では、画像は即時に得される。
~UAは、代わりに必要時に画像を得する~optionを利用者に供してもヨイ（例えば、帯域幅が拘束された利用者は，それを利用するかもしれない）。
~UAは、所与の `img$e 要素 %img の画像を：
◎
By default, images are obtained immediately. User agents may provide users with the option to instead obtain them on-demand. (The on-demand option might be used by bandwidth-constrained users, for example.)
◎
↓</p>

<ul>
	<li>
即時に得するときは、次に従うモノトスル
⇒
%img が作成されたとき, および
%img が`関連な変異$を経た各回ごと
に，同期的に %img の`画像~dataを更新する$
— 特に言明されていれば、 `~animationを開始し直す^i も与える下で。
◎
When obtaining images immediately, the user agent must synchronously update the image data of the img element, with the restart animation flag set if so stated, whenever that element is created or has experienced relevant mutations.
</li>
	<li>
<p>
必要時に得するときは、次に従うモノトスル：
◎
When obtaining images on demand, the user agent must ＼
</p>
		<ul>
			<li>
［
%img の`現在の要請$の`状態$ ~EQ `不可用$st
］場合に限り、 %img の画像~dataが必要になり次第（すなわち，必要時に），`画像~dataを更新する$。
◎
update the image data of an img element whenever it needs the image data (i.e., on demand), but only if the img element's current request's state is unavailable.＼
</li>
			<li>
%img が`関連な変異$を経た時点で，［
%img の`現在の要請$の`状態$ ~SET `不可用$st
］に戻す。
◎
When an img element has experienced relevant mutations, if the user agent only obtains images on demand, the img element's current request's state must return to unavailable.
</li>
		</ul>
	</li>
</ul>

					</section>
					<section id="reacting-to-dom-mutations">
<h5 title="Reacting to DOM mutations">4.8.4.3.2. ~DOM変異に対する反応-法</h5>

<p>
`img$e 要素 %img に
`関連な変異@
とは、次のいずれかが生じたことを表す：
◎
The relevant mutations for an img element are as follows:
</p>

<ul>
	<li>
%img の［
`src$a, `srcset$a, `width$a, `sizes$a
］属性のうちいずれかが［
設定- ／ 変更- ／ 除去-
］された。
◎
The element's src, srcset, width, or sizes attributes are set, changed, or removed.
</li>
	<li>
%img が `src$a 属性を有している下で，その値が前と同じ値に設定された
— この場合
⇒
`画像~dataを更新する$ときには、 `~animationを開始し直す^i を~~渡すモノトスル
◎
The element's src attribute is set to the same value as the previous value. This must set the restart animation flag for the update the image data algorithm.
</li>
	<li>
%img の `crossorigin$a 属性の状態が変化した。
◎
The element's crossorigin attribute's state is changed.
</li>
	<li>
%img の `referrerpolicy$a 属性の状態が変化した。
◎
The element's referrerpolicy attribute's state is changed.
</li>
	<li>
%img は `picture$e 要素の子として`挿入された$node。
◎
↓</li>
	<li>
<p>
%img の親は `picture$e 要素である下で，次のいずれかが生じた：
◎
↓</p>
		<ul>
			<li>
%img は親から`除去された$node。
◎
The element is inserted into or removed from a picture parent element.
</li>
			<li>
%img に先行する同胞として `source$e 要素が`挿入された$node。
◎
The element's parent is a picture element and a source element is inserted as a previous sibling.
</li>
		</ul>
	</li>
	<li>
<p>
%img の親は `picture$e 要素である, かつ
%img に先行する同胞に `source$e 要素 %source がある下で，次のいずれかが生じた：
</p>

<ul ><li>%source は`除去された$node。
</li><li>%source の［
`srcset$aS, `sizes$aS, `media$aS, `type$aS
］属性のうちいずれかが［
設定- ／変更- ／ 除去-
］された。
</li></ul>

◎
The element's parent is a picture element and a source element that was a previous sibling is removed.
◎
The element's parent is a picture element and a source element that is a previous sibling has its srcset, sizes, media, or type attributes set, changed, or removed.
</li>
	<li>
%img に対する`受入-時の手続き$が走った。
◎
The element's adopting steps are run.
</li>
</ul>

					</section>
					<section id="the-list-of-available-images">
<h5 title="The list of available images">4.8.4.3.3. 可用な画像の~list</h5>

<p>
各 `文書$は
`可用な画像~list@
を持つモノトスル。
この~list内の~entryにされる各 画像は：
◎
Each Document object must have a list of available images. Each image in this list is＼
</p>

<ul>
	<li>
<p>
( `絶対~URL$, ~mode, `生成元$または ε )
からなる組による~keyで識別される
— ここで：
</p>

<ul><li>~modeは `~CORS設定群~属性$がとり得る状態と同じ~~範囲の値をとる。
</li><li>3 個目の成分は、［
~mode ~EQ `~NoCORS$st
］の場合は，常に ε （なし）にされる。
</li></ul>

◎
identified by a tuple consisting of an absolute URL, a CORS settings attribute mode, and, if the mode is not No CORS, an origin.＼
</li>
	<li>
加えて，
`上層~cachingは無視する~flag@
も伴われる。
◎
Each image furthermore has an ignore higher-layer caching flag.＼
</li>
</ul>

<p>
~UAは，いつでも、異なる`文書$~間で，一方の`可用な画像~list$内の~entryを他方へ複製してヨイ（例：
~UAは， ある`文書$の作成-時に，他の`文書$~内に読込まれたすべての画像を~listに追加できる）。ただし、この仕方で複製された~entryに対しては：
◎
User agents may copy entries from one Document object's list of available images to another at any time (e.g. when the Document is created, user agents can add to it all the images that are loaded in other Documents),＼
</p>

<ul>
	<li>
その~keyを変更しないモノトスル。
◎
but must not change the keys of entries copied in this way when doing so, and＼
</li>
	<li>
その`上層~cachingは無視する~flag$は ~F にするモノトスル。
◎
must unset the ignore higher-layer caching flag for the copied entry.＼
</li>
</ul>

<p>
~UAは，いつでも、`可用な画像~list$内から画像を除去してヨイ（例：~memoryを節約する）。ただし，除去する~entryの［
`上層~cachingは無視する~flag$ ~EQ ~F
］の場合は、当の資源~用の上層~cachingの意味論に適切になるよう除去するモノトスル（例： ~HTTP `Cache-Control$h 応答~header）。
◎
User agents may also remove images from such lists at any time (e.g. to save memory). User agents must remove entries in the list of available images as appropriate given higher-layer caching semantics for the resource (e.g. the HTTP `Cache-Control` response header) when the ignore higher-layer caching flag is unset.
</p>

<p class="note">注記：
`可用な画像~list$は、~HTTPによる~cachingが許容されないときでも，［
 `src$a 属性が 以前に読込んだ~URLに変更された際に、同じ文書~内の画像を再~downloadするのを避けて， 同期的な切替えを可能化する
］ために意図されている。
それは、［
前の画像をまだ読込んでいる間に，同じ画像を再~downloadするのを避ける
］ために利用されるものではない。
◎
The list of available images is intended to enable synchronous switching when changing the src attribute to a URL that has previously been loaded, and to avoid re-downloading images in the same document even when they don't allow caching per HTTP. It is not used to avoid re-downloading the same image while the previous image is still loading.
</p>

<p class="note">注記：
~UAは、画像~dataを`可用な画像~list$とは別々に格納することもできる。
◎
The user agent can also store the image data separately from the list of available images.
</p>

<p class="example">
例えば、資源に［
`must-revalidate$v を値にとる ~HTTP `Cache-Control$h 応答~header
］が伴われていて，［
資源の`上層~cachingは無視する~flag$ ~EQ ~F
］の場合、~UAは，それを`可用な画像~list$から除去することになるが、画像~dataは別々に保っておいて，~serverが 状態s~code `304^st （ Not Modified ）で応答してきたときには，それを利用することもできる。
◎
For example, if a resource has the HTTP response header `Cache-Control: must-revalidate`, and its ignore higher-layer caching flag is unset, the user agent would remove it from the list of available images but could keep the image data separately, and use that if the server responds with a 304 Not Modified status.
</p>

					</section>
					<section id="decoding-images">
<h5 title="Decoding images">4.8.4.3.4 画像の復号-法</h5>

<p>
画像~dataは、~file~sizeを抑制するため，通例的に符号化される。
すなわち、~UAが画像を~screenに呈示する前に，~dataは復号される必要がある。
`復号-@
は、画像の媒体~dataを~screenに呈示するに相応しい~bitmap形に変換する処理-である。
この処理-は、内容を呈示するときに孕まれる他の処理-に比して，低速にもなり得ることに注意。
したがって~UAは、最良な利用者~体験を~~供するため，復号をいつ遂行するか選べる。
◎
Image data is usually encoded in order to reduce file size. This means that in order for the user agent to present the image to the screen, the data needs to be decoded. Decoding is the process which converts an image's media data into a bitmap form, suitable for presentation to the screen. Note that this process can be slow relative to other processes involved in presenting content. Thus, the user agent can choose when to perform decoding, in order to create the best user experience.
</p>

<p>
画像の復号は、それが完遂するまで 他の内容の呈示を防止するならば，同期的という。
これには概して、画像と他の内容を，同時かつ不可分に呈示する効果がある。
しかしながら、この呈示は，復号にかかった時間だけ遅延される。
◎
Image decoding is said to be synchronous if it prevents presentation of other content until it is finished. Typically, this has an effect of atomically presenting the image and any other content at the same time. However, this presentation is delayed by the amount of time it takes to perform the decode.
</p>

<p>
画像の復号は、他の内容の呈示を防止しないならば，非同期的という。
これには、画像でない内容を より高速に呈示する効果がある。
しかしながら，復号-が完遂するまで、画像~内容は~screenに~~現れない。
復号-が完遂したなら，~screenは画像で更新される。
◎
Image decoding is said to be asynchronous if it does not prevent presentation of other content. This has an effect of presenting non-image content faster. However, the image content is missing on screen until the decode finishes. Once the decode is finished, the screen is updated with the image.
</p>

<p>
同期的, 非同期的
どちらの復号~modeであれ，最終的な内容が~screenに呈示されるまでに費やされる時間は同じになる。
主な相違は、~UAが最終的な内容を呈示するに先立って，画像でない内容を呈示するかどうかになる。
◎
In both synchronous and asynchronous decoding modes, the final content is presented to screen after the same amount of time has elapsed. The main difference is whether the user agent presents non-image content ahead of presenting the final content.
</p>

<p>
~UAが［
同期的, 非同期的
］どちらで復号するか裁定するのを援助するため、
`img$e 要素には `decoding$a 属性を設定できる。
この属性にアリな値は、
`画像~復号~hint@
~keywordである：
◎
In order to aid the user agent in deciding whether to perform synchronous or asynchronous decode, the decoding attribute can be set on img elements. The possible values of of the decoding attribute are the following image decoding hint keywords:
</p>

<table><thead><tr><th>~keyword
<th>状態
<th>~~説明
</thead><tbody>

<tr><td>`sync@v
<td>`Sync@st
<td>
この画像を，他の内容との不可分な呈示~用に同期的に`復号-$する選好を指示する。
◎
Indicates a preference to decode this image synchronously for atomic presentation with other content.

<tr><td>`async@v
<td>`Async@st
<td>
他の内容の呈示が遅延されるのを避けるため、この画像を，他の内容との不可分な呈示~用に非同期的に`復号-$する選好を指示する。
◎
Indicates a preference to decode this image asynchronously to avoid delaying presentation of other content.

<tr><td>`auto@v
<td>`Auto@st
<td>
復号~modeの選好は無いことを指示する（既定）。
◎
Indicates no preference in decoding mode (the default).

</tr></tbody></table>

<p>
~UAは，画像を`復号-$するときは、
`decoding$a 属性の状態にて指示された選好を尊重するべきである。
指示された状態が `Auto$st の場合、~UAは，復号の挙動を自由に選べる。
◎
When decoding an image, the user agent should respect the preference indicated by the decoding attribute's state. If the state indicated is auto, then the user agent is free to choose any decoding behavior.
</p>

<p class="note">
`decode$m ~methodを利用して，復号の挙動を制御することもアリである。
この~methodは、［
内容を~screenに呈示する処理-からは独立に，`復号-$を遂行する
］ので， `decoding$a 属性からは影響されない。
◎
It is also possible to control the decoding behavior using the decode() method. Since the decode() method performs decoding independently from the process responsible for presenting content to screen, it is unaffected by the decoding attribute.
</p>
					</section>
					<section id="updating-the-image-data">
<h5 title="Updating the image data">4.8.4.3.5. 画像~dataの更新-法</h5>

<p class="note">注記：
この~algoは、`並列的$に走っている手続きからは~callできない。
~UAは、［
`並列的$に走っている手続きから，この~algoを~callする必要がある場合
］には，それを行う`~taskを~queueする$必要がある。
【！https://github.com/whatwg/html/pull/3752】
◎
This algorithm cannot be called from steps running in parallel. If a user agent needs to call this algorithm from steps running in parallel, it needs to queue a task to do so.
</p>

<div class="algorithm">
<p>
~UAは，
`img$e 要素 %img の
`画像~dataを更新する@
ときは、所与の
( %~animationを開始し直す~flag ~IN { `~animationを開始し直す^i, ε }（ 省略時は ε ）)
に対し，次の手続きを走らすモノトスル：
◎
When the user agent is to update the image data of an img element, optionally with the restart animations flag set, it must run the following steps:
</p>

<ol>
	<li>
<p>
~IF［
%img の`~node文書$は`作動中$docでない
］：
◎
If the element's node document is not the active document, then:
</p>
		<ol>
			<li>
この~algoを`並列的$に走らすよう継続する
◎
Continue running this algorithm in parallel.
</li>
			<li>
%img の`~node文書$が`作動中$docになるまで待機する
◎
Wait until the element's node document is the active document.
</li>
			<li>
~IF［
%img に対し この~algoの別の~instanceが，この~instanceより後に開始されていた（それが早々に ~RET して，最早~走ってない場合でも）
］
⇒
~RET
◎
If another instance of this algorithm for this img element was started after this instance (even if it aborted and is no longer running), then return.
</li>
			<li>
この~algoの以降を継続する`小taskを~queueする$
【並列的に走るのは、ここまで】
◎
Queue a microtask to continue this algorithm.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
~UAは画像を~supportできない
］~OR［
画像の~supportは不能化されている
］：
◎
If the user agent cannot support images, or its support for images has been disabled, then＼
</p>
		<ol>
			<li>
%img の`現在の要請$による`画像~要請を中止する$
◎
abort the image request for the current request and＼
</li>
			<li>
%img の`処理待ち要請$による`画像~要請を中止する$
◎
the pending request,＼
</li>
			<li>
%img の`現在の要請$の`状態$ ~SET `不可用$st
◎
set current request's state to unavailable,＼
</li>
			<li>
%img の`処理待ち要請$ ~SET ε
◎
set pending request to null, and＼
</li>
			<li>
~RET
◎
return.
</li>
		</ol>
	</li>
	<li>
( %被選定~source, %被選定~画素~密度 ) ~LET ( ε, ε )
◎
Let selected source be null and selected pixel density be undefined.
</li>
	<li>
~IF［
%img は`~srcsetまたは~pictureを利用して$いない
］~AND［
%img は `src$a 属性 %src を有する
］~AND［
%src の値 ~NEQ 空~文字列
］
⇒
( %被選定~source, %被選定~画素~密度 ) ~SET ( %src の値, 1.0 )
◎
If the element does not use srcset or picture and it has a src attribute specified whose value is not the empty string, then set selected source to the value of the element's src attribute and set selected pixel density to 1.0.
</li>
	<li>
%img の`最後に選定された~source$ ~SET %被選定~source
◎
Set the element's last selected source to selected source.
</li>
	<li>
<p>
`(A)^i：<br>
~IF［
%被選定~source ~NEQ ε
］：
◎
If selected source is not null, then:
</p>
		<ol>
			<li>
%文書 ~LET %img の`~node文書$
◎
↓</li>
			<li>
%~URL文字列 ~LET
%被選定~source を %文書 に`相対的に構文解析-$した`結果の~URL文字列$
◎
Parse selected source, relative to the element's node document.＼
</li>
			<li>
~IF［
%~URL文字列 ~EQ `失敗^i
］
⇒
~BREAK `(A)^i
◎
If that is not successful, then abort this inner set of steps. Otherwise, let urlString be the resulting URL string.
</li>
			<li>
<p>
%~key ~LET 次の成分からなる~key：
</p>
<ol ><li>%~URL文字列
</li><li>%img の `crossorigin$a 内容~属性の状態
</li><li>%~CORS属性~状態 ~NEQ `~NoCORS$st ならば %文書 の`生成元$ ／
~ELSE_ ε
</li></ol>
◎
Let key be a tuple consisting of urlString, the img element's crossorigin attribute's mode, and, if that mode is not No CORS, the node document's origin.
</li>
			<li>
<p>
~IF［
%文書 の`可用な画像~list$内に， %~key に対応する~entry %~entry はある
］：
◎
If the list of available images contains an entry for key, then:
</p>
				<ol>
					<li>
%~entry の`上層~cachingは無視する~flag$ ~SET ~T
◎
Set the ignore higher-layer caching flag for that entry.
</li>
					<li>
%img の`現在の要請$による`画像~要請を中止する$
◎
Abort the image request for the current request and＼
</li>
					<li>
%img の`処理待ち要請$による`画像~要請を中止する$
◎
the pending request.
</li>
					<li>
%img の`処理待ち要請$ ~SET ε
◎
Set pending request to null.
</li>
					<li>
%img の`現在の要請$ ~LET 次のようにされた新たな`画像~要請$
⇒＃
`画像~data$ ~SET %~entry の`画像~data$；
`状態$ ~SET `完全に可用$st
◎
Let current request be a new image request whose image data is that of the entry and whose state is completely available.
</li>
					<li>
画像の呈示を適切に更新する
◎
Update the presentation of the image appropriately.
</li>
					<li>
%img の`現在の画素~密度$ ~SET %被選定~画素~密度
<!-- 現在の要請の -->
◎
Set current request's current pixel density to selected pixel density.
</li>
					<li>
<p>
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %img )：
◎
Queue an element task on the DOM manipulation task source given the img element and following steps:
</p>
						<ol>
							<li>
~IF［
%~animationを開始し直す~flag ~NEQ ε
］
⇒
`~animationを開始し直す$( %img )
◎
If restart animation is set, then restart the animation.
</li>
							<li>
%img の`現在の要請$の`現在の~URL$ ~SET %~URL文字列
◎
Set current request's current URL to urlString.
</li>
							<li>
%img に向けて，名前 `load$et の`~eventを発火する$
◎
Fire an event named load at the img element.
</li>
						</ol>
					</li>
					<li>
~RET
◎
Abort the update the image data algorithm.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
この~algoの以降を遂行する`小taskを~queueする$（この~algoを呼出した`~task$を継続できるようにする）
◎
Queue a microtask to perform the rest of this algorithm, allowing the task that invoked this algorithm to continue.
</li>
	<li>
<p>
~IF［
%img に対するこの~algoの別の~instanceが，この~instanceより後に開始されていた（それが早々に ~RET して，最早~走ってない場合でも）
］
⇒
~RET
◎
If another instance of this algorithm for this img element was started after this instance (even if it aborted and is no longer running), then return.
</p>

<p class="note">注記：
複数の要請を避けるため、効果があるのは，最後の~instanceに限られる
— 例えば［
`src$a, `srcset$a, `crossorigin$a
］属性が続けて設定されたときでも。
◎
Only the last instance takes effect, to avoid multiple requests when, for example, the src, srcset, and crossorigin attributes are all set in succession.
</p>
	</li>
	<li>
%現~要請 ~LET %img の`現在の要請$
◎
↓</li>
	<li>
( %被選定~source, %被選定~画素~密度 )
~LET `画像~sourceを選定する$( %img )
◎
Let selected source and selected pixel density be the URL and pixel density that results from selecting an image source, respectively.
</li>
	<li>
<p>
~IF［
%被選定~source ~EQ ε
］：
◎
If selected source is null, then:
</p>
		<ol>
			<li>
%現~要請 の`状態$ ~SET `壊en$st
◎
Set the current request's state to broken,＼
</li>
			<li>
%現~要請 による`画像~要請を中止する$
◎
abort the image request for the current request and＼
</li>
			<li>
%img の`処理待ち要請$による`画像~要請を中止する$
◎
the pending request, and＼
</li>
			<li>
%img の`処理待ち要請$ ~SET ε
◎
set pending request to null.
</li>
			<li>
<p>
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %img )：
◎
Queue an element task on the DOM manipulation task source given the img element and the following steps:
</p>
				<ol>
					<li>
%現~要請 の`現在の~URL$ ~SET 空~文字列
◎
Change the current request's current URL to the empty string.
◎
</li>
					<li>
~IF［
%img は `src$a 属性を有する
］~OR［
%img は`~srcsetまたは~pictureを利用して$いる
］
⇒
%img に向けて，名前 `error$et の`~eventを発火する$
◎
if the element has a src attribute or it uses srcset or picture, fire an event named error at the img element.
</li>
				</ol>
			</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%文書 ~LET %img の`~node文書$
◎
Parse selected source, relative to the element's node document, and＼
</li>
	<li>
( %~URL~record, %~URL文字列 )
~LET
%被選定~source を %文書 に`相対的に構文解析-$した
( `結果の~URL~record$, `結果の~URL文字列$ )
◎
let urlString be the resulting URL string.＼
</li>
	<li>
<p>
~IF［
%~URL文字列 ~EQ `失敗^i
］：
◎
If that is not successful, then:
</p>
		<ol>
			<li>
%現~要請 による`画像~要請を中止する$
◎
Abort the image request for the current request and＼
</li>
			<li>
%img の`処理待ち要請$による`画像~要請を中止する$
◎
the pending request.
</li>
			<li>
%現~要請 の`状態$ ~SET `壊en$st
◎
Set the current request's state to broken.
</li>
			<li>
%img の`処理待ち要請$ ~SET ε
◎
Set pending request to null.
</li>
			<li>
<p>
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %img )：
◎
Queue an element task on the DOM manipulation task source given the img element and the following steps:
</p>
				<ol>
					<li>
%現~要請 の`現在の~URL$ ~SET %被選定~source
◎
Change the current request's current URL to selected source.
</li>
					<li>
%img に向けて，名前 `error$et の`~eventを発火する$
◎
Fire an event named error at the img element.
</li>
				</ol>
			</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%処理待ち要請 ~LET %img の`処理待ち要請$
◎
↓</li>
	<li>
~IF［
%処理待ち要請 ~NEQ ε
］~AND［
%~URL文字列 ~EQ %処理待ち要請 の`現在の~URL$
］
⇒
~RET
◎
If the pending request is not null and urlString is the same as the pending request's current URL, then return.
</li>
	<li>
<p>
~IF［
%~URL文字列 ~EQ %現~要請 の`現在の~URL$
］~AND［
%現~要請 の`状態$ ~EQ `部分的に可用$st
］：
◎
If urlString is the same as the current request's current URL and current request's state is partially available, then＼
</p>
		<ol>
			<li>
%処理待ち要請 による`画像~要請を中止する$
◎
abort the image request for the pending request,＼
</li>
			<li>
~IF［
%~animationを開始し直す~flag ~NEQ ε
］
⇒
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %img )
⇒
`~animationを開始し直す$( %img )
◎
queue an element task on the DOM manipulation task source given the img element to restart the animation if restart animation is set, and＼
</li>
			<li>
~RET
◎
return.
</li>
		</ol>
	</li>
	<li>
~IF［
%処理待ち要請 ~NEQ ε
］
⇒
%処理待ち要請 による`画像~要請を中止する$
◎
If the pending request is not null, then abort the image request for the pending request.
</li>
	<li>
%画像~要請 ~LET 新たな`画像~要請$
◎
Set image request to a new image request＼
</li>
	<li>
%画像~要請 の`現在の~URL$ ~SET %~URL文字列
◎
whose current URL is urlString.
</li>
	<li>
~IF［
%現~要請 の`状態$ ~IN { `不可用$st, `壊en$st }
］
⇒
%img の`現在の要請$ ~SET %画像~要請
◎
If current request's state is unavailable or broken, then set the current request to image request.＼
</li>
	<li>
~ELSE
⇒
%img の`処理待ち要請$ ~SET %画像~要請
◎
Otherwise, set the pending request to image request.
</li>
	<li>
%要請 ~LET
`~CORSになり得る要請を作成する$( %~URL~record, `image^l, %img の`crossorigin$a 内容~属性の現在の状態 )
◎
Let request be the result of creating a potential-CORS request given urlString, "image", and the current state of the element's crossorigin content attribute.
</li>
	<li>
%要請 の`~client$rq ~SET %文書 に`関連な設定群~obj$
◎
Set request's client to the element's node document's relevant settings object.
</li>
	<li>
~IF［
%img は`~srcsetまたは~pictureを利用して$いる
］
⇒
%要請 の`起動元$rq ~SET `imageset^l 
◎
If the element uses srcset or picture, set request's initiator to "imageset".
</li>
	<li>
%要請 の`~referrer施策$rq ~SET
%img の `referrerpolicy$a 属性の現在の状態
◎
Set request's referrer policy to the current state of the element's referrerpolicy attribute.
</li>
	<li>
%~load~eventを遅延する ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%img の`~lazy読込ng属性$は `Eager$st 状態にある
］~OR［
%img `用の~scriptingは不能化されて$いる
］
◎
Let delay load event be true if the img's lazy loading attribute is in the Eager state, or if scripting is disabled for the img, and false otherwise.
</li>
	<li>
<p>
~IF［
`~lazyに読込むことになる$( %img ) ~EQ ~T
］：
◎
If the will lazy load element steps given the img return true, then:
</p>
		<ol>
			<li>
`~lazyに読込んでいる要素の交差~観測ngを開始する$( %img )
◎
Start intersection-observing a lazy loading element for the img element.
</li>
			<li>
この~algoを`並列的$に走らすよう継続する
【上で~queueした小taskは、ここで終わることになる】
◎
Continue running this algorithm in parallel.
</li>
			<li>
次が満たされるようになるまで待機する【これは、永遠に待機するかもしれない】
⇒
［
%img の`~lazyに読込まれるに準備済み~flag$ ~EQ ~T
］~OR［
`~lazyに読込むことになる$( %img ) ~NEQ ~T
］
◎
Wait until the img's ready to be lazy loaded flag is true, or until the will lazy load element steps no longer return true, given the img.
</li>
			<li>
`~lazyに読込んでいる要素の交差~観測ngを停止する$( %img )
◎
Stop intersection-observing a lazy loading element for the img element.
</li>
			<li>
この~algoの以降を走らすよう継続する`要素~taskを~queueする$( `~DOM操作~task源$, %img )
◎
Queue an element task on the DOM manipulation task source given the img element to continue running the rest of this algorithm.
</li>
		</ol>
	</li>

	<li>
<p>
%要請 を用いて`~fetch$すると同時に~fetch~algoの~instanceを %画像~要請 に結付ける
— 加えて：
◎
Fetch request. Let this instance of the fetching algorithm be associated with image request.
</p>
		<ul>
			<li>
このようにして得した資源があれば、それが %画像~要請 の`画像~data$になる。
それは、［
`~CORS同一-生成元$,
`~CORS非同一-生成元$
］のいずれかになる
— これは、画像~自身の`生成元$に影響する（例： `canvas$e 上で利用されるとき）。
◎
The resource obtained in this fashion, if any, is image request's image data. It can be either CORS-same-origin or CORS-cross-origin; this affects the origin of the image itself (e.g. when used on a canvas).
</li>
			<li>
<p>
［
%~load~eventを遅延する ~EQ ~T
］のときは
⇒
画像の~fetchingは、資源が~fetchされ，`~network用~task源$から`~queueされ$た`~task$が走るまで（
<a href="#img-load">下に定義される</a>
），
%文書 の`~load~eventを遅延-$するモノトスル
◎
When delay load event is true, fetching the image must delay the load event of the element's node document until the task that is queued by the networking task source once the resource has been fetched (defined below) has been run.
</p>

<p class="warning">
あいにくこれは、利用者の局所~networkに対する原始的な~port-scanを遂行するためにも利用され得る（とりわけ，~scriptingとの併用で
— 実際には，~scriptingは、そのような攻撃を遂げるために必要とはされないが）。
~UAは、この攻撃を軽減するため，上に述べたものより厳密な`生成元$~access制御~施策を実装してもヨイが、あいにく そのような施策は，概して既存の~Web内容と互換にならない。
◎
This, unfortunately, can be used to perform a rudimentary port scan of the user's local network (especially in conjunction with scripting, though scripting isn't actually necessary to carry out such an attack). User agents may implement cross-origin access control policies that are stricter than those described above to mitigate this attack, but unfortunately such policies are typically not compatible with existing Web content.
</p>

			</li>
		</ul>
	</li>
	<li>
<div class="p">

<p>
この~algoを`並列的$に走らすよう継続する
【上で~queueした小task／~taskは、ここで終わることになる】
— ~fetchingによる~dataが~~完全に得られ次第，アリな限り早く、以下に挙げる項目のうち，最初に適用-可能なものに対応する段を走らす：
</p>

<p>
この段における
`画像~fetch~task@
とは、画像が~fetchされている間に`~network用~task源$から`~queueされ$ることになる，個々の`~task$を指すとする。
</p>
◎
Continue the remaining steps in parallel, but without missing any data from fetching.
◎
As soon as possible, jump to the first applicable entry from the following list:
</div>

<!-- ＊
可能な限り早く
— 画像の形式~supoortするかどうか, 
~supoortする場合は 画像~要請 の画像の寸法を決定できるかどうか判明した時点まで待機する
 -->
		<dl class="switch">
			<dt>
資源の~MIME型 ~EQ `multipart/x-mixed-replace$mt
：
◎
If the resource type is multipart/x-mixed-replace
</dt>
			<dd>
<p>
次回の`画像~fetch~task$は、次の下位手続きを走らすモノトスル：
◎
The next task that is queued by the networking task source while the image is being fetched must run the following steps:
</p>
				<ol>
					<li>
%状態 ~LET ~UAは %画像~要請 の画像の寸法を［
決定できたならば `部分的に可用$st ／
何らかの致命的な仕方で得れないまでに壊れていると決定できたならば `壊en$st
］
◎
↓</li>
					<li>
<p>
~IF［
%画像~要請 ~EQ %img の`処理待ち要請$
］：
</p>
						<ol>
								<li>
~Assert†：
［
完全に復号された本体部位が少なくとも 1 個以上ある
］~OR［
%状態 ~EQ `壊en$st
］
</li>
								<li>
%img の`現在の要請$による`画像~要請を中止する$
</li>
								<li>
%img の`処理待ち要請を現在の要請に昇格する$
</li>
								<li>
~IF［
完全に復号された本体部位はまだない
］~AND［
%状態 ~EQ `壊en$st
］
⇒
%画像~要請 の`状態$ ~SET `壊en$st
</li>
						</ol>

<p class="trans-note">【†
この ~Assert は訳者による補完。
原文では，この ~Assert が満たされない場合の挙動が記されておらず、満たされない場合，処理待ち要請が現在の要請に昇格する機会が来なくなってしまうので。
】</p>
◎
If image request is the pending request and at least one body part has been completely decoded, abort the image request for the current request, upgrade the pending request to the current request.
◎
Otherwise, if image request is the pending request and the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, abort the image request for the current request, upgrade the pending request to the current request, and set the current request's state to broken.
</li>
					<li>
~ELIF［
%画像~要請 ~EQ %img の`現在の要請$ 
］~AND［
%画像~要請 の`状態$ ~EQ `不可用$st
］
⇒
%画像~要請 の`状態$ ~SET %状態
◎
Otherwise, if image request is the current request, its state is unavailable, and the user agent is able to determine image request's image's width and height, set the current request's state to partially available.
◎
Otherwise, if image request is the current request, its state is unavailable, and the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, set the current request's state to broken.
</li>
				</ol>

<div class="p">
<p>
各`画像~fetch~task$は、画像の呈示を更新するモノトスルが、新たな本体部位が来る度に，前の画像を置換するモノトスル
— ある本体部位が完全に復号された時点で，~UAは次を走らすモノトスル：
</p>

				<ol>
					<li>
%img の`現在の要請$の`状態$ ~SET `完全に可用$st
</li>
					<li>
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %img )
⇒
%img に向けて，名前 `load$et の`~eventを発火する$
</li>
				</ol>
◎
Each task that is queued by the networking task source while the image is being fetched must update the presentation of the image, but as each new body part comes in, it must replace the previous image. Once one body part has been completely decoded, the user agent must set the img element's current request's state to completely available and queue an element task on the DOM manipulation task source given the img element to fire an event named load at the img element.
</div>
			</dd>
			<dt>
資源の~MIME型と~dataは
<a href="#img-determine-type">下に述べるように</a>
~supportする画像~形式に対応する：
◎
If the resource type and data corresponds to a supported image format, as described below
</dt>
			<dd>
<p>
次回の`画像~fetch~task$は、次の下位手続きを走らすモノトスル：
◎
The next task that is queued by the networking task source while the image is being fetched must run the following steps:
</p>
				<ol>
					<li>
<p>
~IF［
~UAは %画像~要請 の画像の寸法を決定できた
］：
</p>
						<ol>
							<li>
~IF［
%画像~要請 ~EQ %img の`現在の要請$
］
⇒
%img の呈示を適切に更新する
</li>
							<li>
%画像~要請 の`状態$ ~SET `部分的に可用$st
</li>
						</ol>
◎
If the user agent is able to determine image request's image's width and height, and image request is pending request, set image request's state to partially available.
◎
Otherwise, if the user agent is able to determine image request's image's width and height, and image request is current request, update the img element's presentation appropriately and set image request's state to partially available.
</li>
					<li>
<p>
~ELSE（画像は 何らかの致命的な仕方で壊れていると決定できた） ：
</p>
						<ol>
							<li>
%img の`現在の要請$による`画像~要請を中止する$
</li>
							<li>
<p>
~IF［
%画像~要請 ~EQ %img の`処理待ち要請$
］：
</p>

<ol><li>%img の`処理待ち要請$による`画像~要請を中止する$
</li><li>%img の`処理待ち要請を現在の要請に昇格する$
</li><li>%img の`現在の要請$の`状態$ ~SET `壊en$st
</li></ol>
							</li>
							<li>
%img に向けて，名前 `error$et の`~eventを発火する$
</li>
						</ol>
◎
Otherwise, if the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, and image request is pending request, abort the image request for the current request and the pending request, upgrade the pending request to the current request, set current request's state to broken, and fire an event named error at the img element.
◎
Otherwise, if the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, and image request is current request, abort the image request for image request and fire an event named error at the img element.
</li>
				</ol>

<div class="p">
<p id="img-load">
上の`~task$, および 後続の各`画像~fetch~task$は、次を走らすモノトスル：
</p>

<ol><li>~IF［
%画像~要請 ~EQ %img の`現在の要請$
］
⇒
画像の呈示を更新する（例えば，画像が~progressive~JPEGの場合、各~packetは その画像の解像度を向上させ得る）
</li></ol>

◎
That task, and each subsequent task, that is queued by the networking task source while the image is being fetched, if image request is the current request, must update the presentation of the image appropriately (e.g., if the image is a progressive JPEG, each packet can improve the resolution of the image).
</div>

<p>
加えて、資源を~fetchし終えたときの最後の`画像~fetch~task$は、次の下位手続きを走らすモノトスル：
◎
Furthermore, the last task that is queued by the networking task source once the resource has been fetched must additionally run these steps:
</p>
				<ol>
					<li>
<p>
~IF［
%画像~要請 ~EQ %img の`処理待ち要請$
］：
◎
If image request is the pending request,＼
</p>
						<ol>
							<li>
%img の`現在の要請$による`画像~要請を中止する$
◎
abort the image request for the current request,＼
</li>
							<li>
%img の`処理待ち要請を現在の要請に昇格する$
◎
upgrade the pending request to the current request and＼
</li>
							<li>
%img の呈示を適切に更新する
◎
update the img element's presentation appropriately.
</li>
						</ol>
					</li>
					<li>
%画像~要請 の`状態$ ~SET `完全に可用$st
◎
Set image request to the completely available state.
</li>
					<li>
%文書 の`可用な画像~list$に，画像を追加する
— この画像は
⇒
~key %~key で識別され,
`上層~cachingは無視する~flag$は ~T にするとする
◎
Add the image to the list of available images using the key key, with the ignore higher-layer caching flag set.
</li>
					<li>
%img に向けて，名前 `load$et の`~eventを発火する$
◎
Fire an event named load at the img element.
</li>
				</ol>
			</dd>

			<dt>
その他（ 画像~dataは~supportされる~file形式でない ）：
◎
Otherwise
◎
The image data is not in a supported file format; the user agent must＼
</dt>
			<dd>
				<ol>
					<li>
%画像~要請 の`状態$ ~SET `壊en$st
◎
set image request's state to broken,＼
</li>
					<li>
%img の`現在の要請$による`画像~要請を中止する$
◎
abort the image request for the current request＼
</li>
					<li>
%img の`処理待ち要請$による`画像~要請を中止する$
◎
and the pending request,＼
</li>
					<li>
~IF［
%画像~要請 ~EQ %img の`処理待ち要請$
］
⇒
%img の`処理待ち要請を現在の要請に昇格する$
◎
upgrade the pending request to the current request if image request is the pending request, and then＼
</li>
					<li>
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %img )
⇒
%img に向けて，名前 `error$et の`~eventを発火する$
◎
queue an element task on the DOM manipulation task source given the img element to fire an event named error at the img element.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>
</div>

<p>
~UAが，ある要素 %img に対し上の~algoを走らせている間は、
%img は`接続されて$いなくとも，
%img の`~node文書$から %img への強い参照-があるモノトスル。
◎
While a user agent is running the above algorithm for an element x, there must be a strong reference from the element's node document to the element x, even if that element is not connected.
</p>

<div class="algorithm">
<p>
`画像~要請$ %画像~要請 による
`画像~要請を中止する@
ときは、次の手続きを走らす：
◎
To abort the image request for an image request image request means to run the following steps:
</p>

<ol>
	<li>
%画像~要請 の`画像~data$ ~SET ε
◎
Forget image request's image data, if any.
</li>
	<li>
%画像~要請 による`~fetch$~algoの~instanceがあれば、それを中止した上で，その~algoにより生成された処理待ち~taskすべてを破棄する
◎
Abort any instance of the fetching algorithm for image request, discarding any pending tasks generated by that algorithm.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`img$e 要素の
`処理待ち要請を現在の要請に昇格する@
ときは、次の手続きを走らす：
◎
To upgrade the pending request to the current request for an img element means to run the following steps:
</p>

<ol>
	<li>
%img の`現在の要請$ ~SET %img の`処理待ち要請$
◎
Let the img element's current request be the pending request.
</li>
	<li>
%img の`処理待ち要請$ ~SET ε
◎
Let the img element's pending request be null.
</li>
</ol>
</div>

					</section>
					<section id="selecting-an-image-source">
<h5 title="Selecting an image source">4.8.4.3.6. 画像~sourceの選定-法</h5>

<div class="algorithm">
<p>
`画像~sourceを選定する@
ときは、所与の
( %要素 )
に対し，次を走らすモノトスル
— これは
( `~URL$を与える文字列, `密度~値$ )
の組を返す：
◎
When asked to select an image source for a given img or link element el, user agents must do the following:
</p>

<ol>
	<li>
~Assert：
%要素 は［
`img$e ／ `link$e
］要素である
◎
↑</li>
	<li>
<p>
`~source集合を更新する$( %要素 )
</p>

<p class="trans-note">【
その結果、 %要素 の`~source集合$内のすべての~entryの`記述子$iSは，`画素~密度~記述子$に正規化されることに注意。
】</p>
◎
Update the source set for el.
</li>
	<li>
~IF［
%要素 の`~source集合$は空である
］
⇒
~RET ( ε, ε )
◎
If el's source set is empty, return null as the URL and undefined as the pixel density.
</li>
	<li>
%~source集合 ~LET 空~集合
◎
Otherwise, take el's source set and let it be source set.
</li>
	<li>
%要素 の`~source集合$ 内の
~EACH( ~entry %b )
に対し，順に
⇒
~IF［
%b の`記述子$iSの`密度~値$は %~source集合 内のどの~entryのそれとも異なる
］
⇒
%b を %~source集合 に追加する
◎
If an entry b in source set has the same associated pixel density descriptor as an earlier entry a in source set, then remove entry b. Repeat this step until none of the entries in source set have the same associated pixel density descriptor as an earlier entry.
</li>
	<li>
%被選定~source ~LET
~UAに特有な方式で， %~source集合 から 1 個の `画像~source$を選んだ結果
◎
In a user agent-specific manner, choose one image source from source set. Let this be selected source.
</li>
	<li>
~RET
( %被選定~source の`~URL文字列$iS, %被選定~source の`記述子$iSの`密度~値$ )
◎
Return selected source and its associated pixel density.
</li>
</ol>
</div>

					</section>
					<section id="updating-the-source-set">
<h5 title="Updating the source set">4.8.4.3.7. ~source集合の更新-法</h5>

<div class="algorithm">
<p>
`~source集合を更新する@
ときは、所与の
( %要素 )
に対し，次を走らすモノトスル：
◎
When asked to update the source set for a given img or link element el, user agents must do the following:
</p>

<ol>
	<li>
~Assert：
%要素 は［
`img$e ／ `link$e
］要素である
◎
↑</li>
	<li>
%要素~list ~LET « »
◎
↓↓Set el's source set to an empty source set.
◎
Let elements be « el ».
↓↓
</li>
	<li>
%~fallback横幅 ~LET ε
◎
↓</li>
	<li>
<p>
~IF［
%要素 は `img$e 要素である
］：
◎
↓</p>
		<ol>
			<li>
<p>
~IF［
%要素 の親~node は `picture$e 要素である
］
⇒
%要素~list ~SET %要素 に先行する同胞の `source$e 要素からなる同順の~list
</p>

<p class="trans-note">【
この訳では、ここで %要素~list をこれらの `source^e 要素に絞り込んでおくにより，原文の~algoを少し簡潔に組み替えている。
】</p>

◎
If el is an img element whose parent node is a picture element, then replace the contents of elements with el's parent node's child elements, retaining relative order.
↓↓
◎
Let width be null.
</li>
			<li>
<p>
~IF［
%要素 は `width$a 属性を有する
］：
</p>
				<ol>
					<li>
%横幅 ~LET `寸法~値として構文解析する$( %要素 の `width$a 属性の値 )†
</li>
					<li>
~IF［
%横幅 ~NEQ `失敗^i
］~AND［
%横幅 の種別 ~NEQ 百分率
］
⇒
%~fallback横幅 ~SET %横幅
</li>
				</ol>

【†原文には %横幅 は “（構文解析して）返された整数” と記されているが、意図がはっきりしない（結果は一般に実数になるが、整数に丸める要件も課される？）】

◎
If el is an img element with a width attribute, and parsing that attribute's value using the rules for parsing dimension values doesn't generate an error or a percentage value, then set width to the returned integer value.
</li>
		</ol>
	</li>
	<li>
%要素~list に %要素 を付加する
◎
↑↑</li>
	<li>
<p>
%要素~list 内の
~EACH( %子 )
に対し：
◎
For each child in elements:
</p>
		<ol>
			<li>
%~source集合 ~LET ［
%子 は`~srcset属性$を有するならば次の結果 ／
~ELSE_ 空の`~source集合$
］
⇒
`~srcset属性を構文解析する$( %子 )
◎
↓</li>
			<li>
<p>
~IF［
%子 ~EQ %要素
］：
◎
If child is el:
</p>
				<ol>
					<li>
<p>
~IF［
次がすべて満たされる
］…：
</p>

<ul ><li>%子 は［
`img^e 要素であって `src$a 属性を有する ／
`link^e 要素であって `href$aL 属性を有する
］
</li><li>前項の属性の値 %値 ~NEQ 空~文字列
</li><li>%~source集合 内のどの`画像~source$の`記述子$iSも，［
ε , または［
`画素~密度~記述子$であって，その`密度~値$ ~NEQ 1
］］：
</li></ul>

<p>
…ならば
⇒
%~source集合 に
次のようにされた新たな`画像~source$を付加する
⇒＃
`~URL文字列$iS ~SET %値,
`記述子$iS ~SET ε
</p>

◎
• Let source set be an empty source set.
• If child has a srcset or imagesrcset attribute, parse child's srcset attribute and set source set to the returned source set.
• Parse child's sizes attribute with the fallback width width, and let source set's source size be the returned value.
• If child has a src or href attribute whose value is not the empty string and source set does not contain an image source with a pixel density descriptor value of 1, and no image source with a width descriptor, append child's src or href attribute value to source set.
</li>
					<li>
~GOTO `最後^i
◎
↓↓
• Normalize the source densities of source set.
• Let el's source set be source set.
• Return.
</li>
				</ol>

<p class="note">注記：
%要素 が `link^e 要素であるならば、即時に この段に達して~~反復を終えることになる。
◎
If el is a link element, then elements contains only el, so this step will be reached immediately and the rest of the algorithm will not run.
</p>

			</li>
			<li>
~Assert：
%子 は `source^e 要素である
◎
Assert: child is not a link element.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

<ul><li>%~source集合 は空である
</li><li>
［
%子 は `media$aS 属性を有する
］~AND［
その値は`環境に合致して$いない
］
</li><li>
［
%子 は `type$aS 属性を有する
］~AND［
その値は 未知な／未~supportの`~MIME型$である
］
</li></ul>

<p>
…ならば
⇒
~CONTINUE
</p>

◎
• If child is not a source element, continue to the next child. Otherwise, child is a source element.
• If child does not have a srcset attribute, continue to the next child.
• Parse child's srcset attribute and let the returned source set be source set.
• If source set has zero image sources, continue to the next child.
• If child has a media attribute, and its value does not match the environment, continue to the next child.
• Parse child's sizes attribute with the fallback width width, and let source set's source size be the returned value.
• If child has a type attribute, and its value is an unknown or unsupported MIME type, continue to the next child.
↓↓
• Normalize the source densities of source set.
• Let el's source set be source set.
• Return.
</li>
			<li>
<p>
`最後^i：
</p>
				<ol>
					<li>
%~source集合 の`~source~size$ ~LET
%子 の`~sizes属性を構文解析する$( %~fallback横幅 )
</li>
					<li>
`~source密度を正規化する$( %~source集合 )
</li>
					<li>
%要素 の`~source集合$ ~SET %~source集合
</li>
					<li>
~RET
</li>
				</ol>
◎
↑↑</li>
		</ol>
	</li>
</ol>
</div>

<p class="note">注記：
各 `img$e 要素は、`画像~source$を選定するときに［
自身, および
自身に先行する同胞 `source$e 要素たち
］を独立と見なし、他の（妥当でない）要素 — ［
同じ `picture$e 要素~内の他の `img$e 要素 ／
自身に後続する同胞の `source$e 要素
］は無視する。
◎
Each img element independently considers its previous sibling source elements plus the img element itself for selecting an image source, ignoring any other (invalid) elements, including other img elements in the same picture element, or source elements that are following siblings of the relevant img element.
</p>

					</section>
					<section id="parsing-a-srcset-attribute">
<h5 title="Parsing a srcset attribute">4.8.4.3.8. ~srcset属性の構文解析-法</h5>

<div class="algorithm">
<p>
`~srcset属性を構文解析する@
ときは、所与の
( %要素 )
に対し，次を走らす：
◎
When asked to parse a srcset attribute from an element, parse the value of the element's srcset attribute as follows:
</p>

<ol>
	<li>
%入力 ~LET %要素 の`~srcset属性$の値
◎
Let input be the value passed to this algorithm.
</li>
	<li>
%位置 ~LET %入力 の中の最初の文字を指している`位置~変数$
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%候補~list ~LET 空の`~source集合$
◎
Let candidates be an initially empty source set.
</li>
	<li>
<p>
~WHILE 無条件：
◎
Splitting loop:＼
</p>
		<ol>
			<li>
%入力 内の %位置 から
{ `~ASCII空白$, `002C^U `,^smb }
からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII whitespace or U+002C COMMA characters from input given position.＼
</li>
			<li>
~IF［
前~段にて 1 個~以上の文字 `002C^U `,^smb が収集された
］
⇒
`構文解析-~error$
◎
If any U+002C COMMA characters were collected, that is a parse error.
</li>
			<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET %候補~list
◎
If position is past the end of input, return candidates.
</li>
			<li>
%記述子 ~LET ε
◎
↓</li>
			<li>
%~url ~LET
%入力 内の %位置 から
`~ASCII空白$以外の`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not ASCII whitespace from input given position, and let that be url.
◎
↓↓Let descriptors be a new empty list.
</li>
			<li>
<p>
~IF［
%~url の最後の文字 ~EQ `002C^U `,^smb
］：
◎
If url ends with U+002C (,), then:
</p>

				<ol>
					<li>
%~url の末尾から連続する文字 `002C^U `,^smb をすべて除去する
◎
Remove all trailing U+002C COMMA characters from url.＼
</li>
					<li>
~IF［
前~段で 2 個~以上の文字が除去された
］
⇒
`構文解析-~error$
◎
If this removed more than one character, that is a parse error.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
%記述子 ~LET ［
下に与える “記述子を~token化する” 下位手続きを走らせた結果
］を，その下に与える “記述子 構文解析器” にかけた結果
【この訳では、原文の~algoを，これらの手続きに分割して記述している。】
</li>
					<li>
~IF［
%記述子 ~EQ `~error^i
］
⇒
~CONTINUE
</li>
				</ol>
◎
Otherwise:
◎
↓↓</li>
			<li>
<p>
%候補~list に
次のようにされた新たな`画像~source$を付加する
⇒＃
`~URL文字列$iS ~SET %~url,
`記述子$iS ~SET %記述子
◎
↓↓</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">
<p>
上の`~srcset属性を構文解析する$手続きに利用される，記述子を~token化する下位手続きは、次を走らす：
◎
Descriptor tokenizer:＼
</p>

<div>
<ol>
	<li>
%記述子~list ~LET 新たな空~list
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
</li>
			<li>
%記述子~token ~LET 空~文字列
</li>
			<li>
%記述子~token に次の結果を付加する
⇒
%入力 内の %位置 から，次に挙げるもの以外の`符号位置~並びを収集する$
⇒＃
`~ASCII空白$, `002C^U `,^smb, `0028^U `(^smb
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ `0028^U `(^smb
］：
</p>
				<ol>
					<li>
%記述子~token に次の結果を付加する
⇒
%入力 内の %位置 から， `0029^U `)^smb 以外の`符号位置~並びを収集する$
</li>
					<li>
~IF［
%位置↗ ~EQ `0029^U `)^smb
］
⇒＃
%記述子~token に %位置↗ を付加する；
%位置 ~INCBY 1
</li>
				</ol>
			</li>
			<li>
~IF［
%記述子~token ~NEQ 空~文字列
］
⇒
%記述子~list に %記述子~token を付加する
</li>
			<li>
~IF［
%位置↗ は`~ASCII空白$でない
］
⇒
~BREAK
</li>
		</ol>
	</li>
	<li>
~RET %記述子~list
</li>
</ol>

◎
Skip ASCII whitespace within input given position.
◎
↑↓
◎
Let current descriptor be the empty string.
◎
Let state be in descriptor.
◎
Let c be the character at position. Do the following depending on the value of state. For the purpose of this step, "EOF" is a special character representing that position is past the end of input.
◎
In descriptor
• Do the following, depending on the value of c:

•• ASCII whitespace
••• If current descriptor is not empty, append current descriptor to descriptors and let current descriptor be the empty string. Set state to after descriptor.

•• U+002C COMMA (,)
••• Advance position to the next character in input. If current descriptor is not empty, append current descriptor to descriptors. Jump to the step labeled descriptor parser.

•• U+0028 LEFT PARENTHESIS (()
••• Append c to current descriptor. Set state to in parens.

•• EOF
••• If current descriptor is not empty, append current descriptor to descriptors. Jump to the step labeled descriptor parser.

•• Anything else
••• Append c to current descriptor.
◎
In parens

• Do the following, depending on the value of c:

•• U+0029 RIGHT PARENTHESIS ())
••• Append c to current descriptor. Set state to in descriptor.

•• EOF
••• Append current descriptor to descriptors. Jump to the step labeled descriptor parser.

•• Anything else
••• Append c to current descriptor.

◎
After descriptor

• Do the following, depending on the value of c:

•• ASCII whitespace
••• Stay in this state.

•• EOF
••• Jump to the step labeled descriptor parser.

•• Anything else
••• Set state to in descriptor. Set position to the previous character in input.
◎
Advance position to the next character in input. Repeat this step.
</div>

<p class="note">注記：
将来の追加と互換にするため、この~algoは，複数の記述子と丸括弧を伴う記述子を~supportする。
◎
In order to be compatible with future additions, this algorithm supports multiple descriptors and descriptors with parens.
</p>

<p class="trans-note">【
原文による上の~algoは，（おそらく拡張を視野に）文字~単位で細かく処理しているが、この訳では，流れを追いやすくなるよう等価な形に再構成している。
】</p>
</div>

<div class="algorithm">
<p>
上の`~srcset属性を構文解析する$手続きに利用される，記述子 構文解析器は、所与の %記述子~list に対し，次を走らす：
◎
Descriptor parser:＼
</p>

<ol>
	<li>
%~error ~LET  `no^i
◎
Let error be no.
</li>
	<li>
<p>
( %横幅, %縦幅, %密度 ) ~LET ( ε, ε, ε )
</p>

<p class="trans-note">【
%縦幅 （原文における名前は “`future-compat-h^en” ）は，現時点では用を為さないが、将来における追加と互換にするため，予め処理に組み込まれている。
】</p>
◎
Let width be absent.
◎
Let density be absent.
◎
Let future-compat-h be absent.
</li>
	<li>
<p>
%記述子~list 内の
~EACH( %記述子~token )
に対し：
◎
For each descriptor in descriptors, run the appropriate set of steps from the following list:
</p>
		<ol>
			<li>
%種別 ~LET %記述子~token の最後の文字
◎
↓</li>
			<li>
%数 ~LET %記述子~token から最後の文字を除去した結果
◎
↓</li>
			<li>
<p>
~IF［
%種別 ~EQ `0077^U `w^smb
］~AND［
%数 は`妥当な負でない整数$である
］：
◎
If the descriptor consists of a valid non-negative integer followed by a U+0077 LATIN SMALL LETTER W character
</p>
				<ol>
					<li>
<p>
~IF［
~UAは `sizes$a 属性を~supportしない
］
⇒
%~error ~SET `yes^i
◎
If the user agent does not support the sizes attribute, let error be yes.
</p>

<p class="note">注記：
適合~UAは `sizes$a 属性を~supportすることになる。
しかしながら，実施においては、~UAは概して，特能を漸増的に実装して出荷する。
◎
A conforming user agent will support the sizes attribute. However, user agents typically implement and ship features in an incremental manner in practice.
</p>
					</li>
					<li>
~IF［
%横幅 ~NEQ ε
］~OR［
%密度 ~NEQ ε
］
⇒
%~error ~SET `yes^i
◎
If width and density are not both absent, then let error be yes.
</li>
					<li>
%数 ~SET `負でない整数として構文解析する$( %数 )
◎
Apply the rules for parsing non-negative integers to the descriptor.＼
</li>
					<li>
~IF［
%数 ~EQ 0
］
⇒
%~error ~SET `yes^i
◎
If the result is zero, let error be yes.＼
</li>
					<li>
~ELSE
⇒
%横幅 ~SET %数
◎
Otherwise, let width be the result.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%種別 ~EQ `0078^U `x^smb
］~AND［
%数 は`妥当な浮動小数点数$である
］：
◎
If the descriptor consists of a valid floating-point number followed by a U+0078 LATIN SMALL LETTER X character
</p>
				<ol>
					<li>
~IF［
%横幅 ~NEQ ε
］~OR［
%密度 ~NEQ ε
］~OR［
%縦幅 ~NEQ ε
］
⇒
%~error ~SET `yes^i
◎
If width, density and future-compat-h are not all absent, then let error be yes.
</li>
					<li>
%数 ~SET `浮動小数点数として構文解析する$( %数 )
◎
Apply the rules for parsing floating-point number values to the descriptor.＼
</li>
					<li>
~IF［
%数 ~LT 0
］
⇒
%~error ~SET  `yes^i
◎
If the result is less than zero, let error be yes.＼
</li>
					<li>
<p>
~ELSE
⇒
%密度 ~SET %数
◎
Otherwise, let density be the result.
</p>

<p class="note">注記：
%密度 ~EQ 0
の場合、［
`内在的~横幅$ ／ `内在的~縦幅$
］は無限になる。
~UAには、画像を描画できる大きさを制限することが期待される
— そうすることは、`~hardware制限$の条項により許容される。
◎
If density is zero, the intrinsic dimensions will be infinite. User agents are expected to have limits in how big images can be rendered, which is allowed by the hardware limitations clause.
</p>

					</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%種別 ~EQ `0068^U `h^smb
］~AND［
%数 は`妥当な負でない整数$である
］：
◎
If the descriptor consists of a valid non-negative integer followed by a U+0068 LATIN SMALL LETTER H character
</p>

				<ol>
					<li>
`構文解析-~error$
◎
This is a parse error.
</li>
					<li>
~IF［
%縦幅 ~NEQ ε
］~OR［
%密度 ~NEQ ε
］
⇒
%~error ~SET `yes^i
◎
If future-compat-h and density are not both absent, then let error be yes.
</li>
					<li>
%数 ~SET `負でない整数として構文解析する$( %数 )
◎
Apply the rules for parsing non-negative integers to the descriptor.＼
</li>
					<li>
~IF［
%数 ~EQ 0
］
⇒
%~error ~SET `yes^i
◎
If the result is zero, let error be yes.＼
</li>
					<li>
~ELSE
⇒
%縦幅 ~SET %数
◎
Otherwise, let future-compat-h be the result.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%~error ~SET `yes^i
◎
Anything else
◎
Let error be yes.
</li>
		</ol>
	</li>
	<li>
~IF［
%縦幅 ~NEQ ε
］~AND［
%横幅 ~EQ ε
］
⇒
%~error ~SET `yes^i
◎
If future-compat-h is not absent and width is absent, let error be yes.
</li>
	<li>
<p>
~IF［
%~error ~EQ `no^i
］：
</p>
		<ol>
			<li>
~IF［
%横幅 ~NEQ ε
］
⇒
~RET `横幅~値$に %横幅 を伴う`横幅~記述子$
</li>
			<li>
~IF［
%密度 ~NEQ ε
］
⇒
~RET `密度~値$に %密度 を伴う`画素~密度~記述子$
</li>
			<li>
~RET ε
</li>
		</ol>
◎
If error is still no, then append a new image source to candidates whose URL is url, associated with a width width if not absent and a pixel density density if not absent.＼
</li>
	<li>
`構文解析-~error$
◎
Otherwise, there is a parse error.
</li>
	<li>
~RET `~error^i
◎
Return to the step labeled splitting loop.
</li>
</ol>
</div>

					</section>
					<section id="parsing-a-sizes-attribute">
<h5 title="Parsing a sizes attribute">4.8.4.3.9. ~sizes属性の構文解析-法</h5>

<div class="algorithm">
<p>
%要素 の
`~sizes属性を構文解析する@
ときは、所与の
( %~fallback横幅 )
に対し，次を走らす：
◎
When asked to parse a sizes attribute from an element, with a fallback width width,＼
</p>

<ol>
	<li>
%未解析~sizes~list ~LET `~comma区切りの成分~値~listとして構文解析する$( ［
%要素 は`~sizes属性$を有するならば その値 ／
~ELSE_ 空~文字列
］ )
`CSSSYNTAX$r
◎
parse a comma-separated list of component values from the value of the element's sizes attribute (or the empty string, if the attribute is absent), and let unparsed sizes list be the result. [CSSSYNTAX]
</li>
	<li>
<p>
%未解析~sizes~list 内の
~EACH( %未解析~size )
に対し：
◎
For each unparsed size in unparsed sizes list:
</p>
		<ol>
			<li>
%未解析~size の~~終端から連続する `whitespace-token$t すべてを除去する
◎
Remove all consecutive &lt;whitespace-token&gt;s from the end of unparsed size.＼
</li>
			<li>
~IF［
%未解析~size は空である
］
⇒＃
`構文解析-~error$；
~CONTINUE
◎
If unparsed size is now empty, that is a parse error; continue to the next iteration of this algorithm.
</li>
			<li>
%~size ~LET %未解析~size 内の最後の`成分~値$
◎
If the last component value in unparsed size is a valid non-negative &lt;source-size-value&gt;, let size be its value and＼
</li>
			<li>
%未解析~size から最後の`成分~値$を除去する
◎
remove the component value from unparsed size.＼
</li>
			<li>
~IF［
%~size は `source-size-value$t に合致しない
］~OR［
%~size は `~math関数$以外の~CSS関数を含んでいる
］~OR［
%~size は負な数を表す
］
⇒＃
`構文解析-~error$；
~CONTINUE
◎
Any CSS function other than the math functions is invalid. Otherwise, there is a parse error; continue to the next iteration of this algorithm.
</li>
			<li>
%未解析~size の終端から連続する `whitespace-token$t すべてを除去する
◎
Remove all consecutive &lt;whitespace-token&gt;s from the end of unparsed size.＼
</li>
			<li>
~IF［
%未解析~size は空である
］
⇒
~IF［
%未解析~size は %未解析~sizes~list 内の最後の~itemでない
］
⇒
`構文解析-~error$
◎
If unparsed size is now empty, return size and exit this algorithm. If this was not the last item in unparsed sizes list, that is a parse error.
</li>
			<li>
<p>
~ELIF［
%未解析~size は、全体として，次のいずれかを満たす `MQ$r
］
⇒
~CONTINUE：
</p>

<ul><li>`media-condition$t に合致しない
</li><li>`media-condition$t として<a href="~MQ4#evaluating">評価した結果</a>は偽になる
</li></ul>

◎
Parse the remaining component values in unparsed size as a &lt;media-condition&gt;. If it does not parse correctly, or it does parse correctly but the &lt;media-condition&gt; evaluates to false, continue to the next iteration of this algorithm. [MQ]
</li>
			<li>
~RET %~size
◎
Return size and exit this algorithm.
</li>
		</ol>
	</li>
	<li>
~IF［
%~fallback横幅 ~NEQ ε
］
⇒
~RET ［
単位 `px$css による %~fallback横幅
］として与えられる `length$t 値
◎
If the above algorithm exhausts unparsed sizes list without returning a size value, follow these steps:
◎
If width is not null, return a &lt;length&gt; with the value width and the unit 'px'.
</li>
	<li>
~RET `100vw^v 
【すなわち，表示域の横幅】
◎
Return 100vw.
</li>
</ol>
</div>

<p class="note">注記：
`妥当な~source~size~list$は、
`source-size-list$t 内の最後の~entryとして `source-size-value$t のみを包含する（ `media-condition$t は付帯しない）が、この構文解析-~algoは，形上では そのようなものを~list内のどこでも許容し、最初に現れ次第，即時に~sizeとして受容することになる。
これは、将来の拡張を可能化するため, および
末尾の~commaなどの単純な作者~errorに抗して保護するためである。
◎
While a valid source size list only contains a bare &lt;source-size-value&gt; (without an accompanying &lt;media-condition&gt;) as the last entry in the &lt;source-size-list&gt;, the parsing algorithm technically allows such at any point in the list, and will accept it immediately as the size if the preceding entries in the list weren't used. This is to enable future extensions, and protect against simple author errors such as a final trailing comma.
</p>

					</section>
					<section id="normalizing-the-source-densities">
<h5 title="Normalizing the source densities">4.8.4.3.10. ~source密度の正規化-法</h5>

<p>
`~source集合$を正規化することで、それに含まれる どの`画像~source$の`記述子$iSも，`画素~密度~記述子$にされる。
◎
An image source can have a pixel density descriptor, a width descriptor, or no descriptor at all accompanying its URL. Normalizing a source set gives every image source a pixel density descriptor.
</p>

<div class="algorithm">
<p>
`~source密度を正規化する@
ときは、所与の
( `~source集合$ %~source集合 )
に対し，次を走らす：
◎
When asked to normalize the source densities of a source set source set, the user agent must do the following:
</p>

<ol>
	<li>
%~source~size ~LET  %~source集合 の`~source~size$
◎
Let source size be source set's source size.
</li>
	<li>
<p>
%~source集合 内の
~EACH( `画像~source$ %S )
に対し：
</p>
		<ol>
			<li>
%密度 ~LET 1
</li>
			<li>
<p>
%S の`記述子$iS に応じて：
</p>
				<dl class="switch">
					<dt>`画素~密度~記述子$</dt>
					<dd>
~CONTINUE
</dd>

					<dt>`横幅~記述子$</dt>
					<dd>
%密度 ~SET ( %S の`記述子$iSの`横幅~値$ ÷ `~source~size$ )
</dd>
					<dd class="note">注記：
`~source~size$ ~EQ 0
の場合の密度は無限大になり、
( `内在的~横幅$, `内在的~縦幅$ ) は ( 0, 0 ) になる。
</dd>
				</dl>
			</li>
			<li>
%S の`記述子$iS ~SET `密度~値$に %密度 を伴う`画素~密度~記述子$
</li>
		</ol>

◎
For each image source in source set:

• If the image source has a pixel density descriptor, continue to the next image source.
• Otherwise, if the image source has a width descriptor, replace the width descriptor with a pixel density descriptor with a value of the width descriptor value divided by the source size and a unit of x.
• If the source size is zero, the density would be infinity, which results in the intrinsic dimensions being zero by zero.
• Otherwise, give the image source a pixel density descriptor of 1x.
</li>
</ol>
</div>

					</section>
					<section id="reacting-to-environment-changes">
<h5 title="Reacting to environment changes">4.8.4.3.11. 環境~変化に対する反応-法</h5>

<div class="algorithm">
<p id="img-environment-changes">
~UAはいつでも、環境における変化に反応するため，次の~algoを走らせて`img$e 要素 %img の画像を更新してヨイ。
（~UAには、この~algoを常時~走らすことは`要求されない^em
— 例えば、利用者が当の~pageを見ていなくて，その間に環境が何度か変化する事例においては、~UAは，利用者が~pageに戻って来るまで どの画像を利用するか決定するのを待機したいと求めるかもしれない。）
◎
The user agent may at any time run the following algorithm to update an img element's image in order to react to changes in the environment. (User agents are not required to ever run this algorithm; for example, if the user is not looking at the page any more, the user agent might want to wait until the user has returned to the page before determining which image to use, in case the environment changes again in the meantime.)
</p>

<p class="note">注記：
~UAには、特に，［
利用者が`表示域$の~sizeを変更したとき（例：~windowを~resizeしたときや，~page~zoomを変更したとき） ／
`img$e 要素が`文書の中へ挿入された$とき
］には、この~algoを走らせて，［
`密度補正済み内在的~size$が新たな`表示域$に合致する, かつ
`~art-direction$が孕まれるときは正しい画像が選ばれる
］ようにすることが奨励される。
◎
User agents are encouraged to run this algorithm in particular when the user changes the viewport's size (e.g. by resizing the window or changing the page zoom), and when an img element is inserted into a document, so that the density-corrected intrinsic width and height match the new viewport, and so that the correct image is chosen when art direction is involved.
</p>

<ol>
	<li>
<p>
次の手続きを`同期区間$として，この~algoの`安定~状態を待受ける$：
◎
Await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)
</p>
		<ol>
			<li>
%文書 ~LET %img の`~node文書$
◎
↓</li>
			<li>
~IF［
%img は`~srcsetまたは~pictureを利用して$いない
］~OR［
%文書 は`作動中$docでない
］~OR［
%img の画像~dataの資源~型 ~EQ `multipart/x-mixed-replace$mt
］~OR［
%img の`処理待ち要請$ ~NEQ ε
］
⇒
~RET
◎
⌛ If the img element does not use srcset or picture, its node document is not the active document, has image data whose resource type is multipart/x-mixed-replace, or the pending request is not null, then return.
</li>
			<li>
( %被選定~source, %被選定~画素~密度 )
~LET `画像~sourceを選定する$( %img )
◎
⌛ Let selected source and selected pixel density be the URL and pixel density that results from selecting an image source, respectively.
</li>
			<li>
~IF［
%被選定~source ~EQ ε
］
⇒
~RET
◎
⌛ If selected source is null, then return.
</li>
			<li>
~IF［
%被選定~source ~EQ %img の`最後に選定された~source$
］~AND［
%被選定~画素~密度 ~EQ %img の`現在の画素~密度$
］
⇒
~RET
◎
⌛ If selected source and selected pixel density are the same as the element's last selected source and current pixel density, then return.
</li>
			<li>
( %~URL~record, %~URL文字列 )
~LET
%被選定~source を %文書 に`相対的に構文解析-$した
( `結果の~URL~record$, `結果の~URL文字列$ )
◎
⌛ Parse selected source, relative to the element's node document, and let urlString be the resulting URL string.＼
</li>
			<li>
~IF［
%~URL文字列 ~EQ `失敗^i
］
⇒
~RET
◎
If that is not successful, then return.
</li>
			<li>
%~CORS属性~状態 ~LET %img の `crossorigin$a 内容~属性の状態
◎
⌛ Let corsAttributeState be the state of the element's crossorigin content attribute.
</li>
			<li>
%生成元 ~LET ［
%~CORS属性~状態 ~EQ `~NoCORS$st ならば ε ／
~ELSE_ %文書 の`生成元$
］
◎
⌛ Let origin be the origin of the img element's node document.
</li>
			<li>
%~client ~LET %文書 に`関連な設定群~obj$
◎
⌛ Let client be the img element's node document's relevant settings object.
</li>
			<li>
%~key ~LET
組 ( %~URL文字列, %~CORS属性~状態, %生成元 )
◎
⌛ Let key be a tuple consisting of urlString, corsAttributeState, and, if corsAttributeState is not No CORS, origin.
</li>
			<li>
%画像~要請 ~LET 新たな`画像~要請$
◎
⌛ Let image request be a new image request＼
</li>
			<li>
%画像~要請 の`現在の~URL$ ~SET %~URL文字列
◎
whose current URL is urlString
</li>
			<li>
%img の`処理待ち要請$ ~LET %画像~要請
◎
⌛ Let the element's pending request be image request.
</li>
		</ol>
<p>
`同期区間$はここで終端する
— 以降の手続きは、同期区間を走らせ終えてから，`並列的$に走らすことになる。
◎
End the synchronous section, continuing the remaining steps in parallel.
</p>
	</li>
	<li>
~IF［
`可用な画像~list$内に %~key に対応する~entryはある
］
⇒
%画像~要請 の`画像~data$ ~SET その~entryの`画像~data$
◎
If the list of available images contains an entry for key, then set image request's image data to that of the entry. Continue to the next step.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%要請 ~LET
`~CORSになり得る要請を作成する$( %~URL~record, `image^l , %~CORS属性~状態 )
◎
Let request be the result of creating a potential-CORS request given urlString, "image", and corsAttributeState.
</li>
			<li>
%要請 の
⇒＃
`~client$rq ~SET %~client,
`起動元$rq ~SET `imageset^l,
`同期~flag$rq  ~SET ~T,
`~referrer施策$rq ~SET %img の `referrerpolicy$a 属性の現在の状態
◎
Set request's client to client, initiator to "imageset", and set request's synchronous flag.
◎
Set request's referrer policy to the current state of the element's referrerpolicy attribute.
</li>
			<li>
%応答 ~LET %要請 を用いて`~fetch$した結果
◎
Let response be the result of fetching request.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
↓</p>

				<ul>
					<li>
%応答 の`非安全~応答$は`~network~error$である
◎
If response's unsafe response is a network error or＼
</li>
					<li>
`画像を特定的に~sniffするための規則$を<a href="#img-determine-type">適用して決定される</a>画像の形式は未~supportである
◎
if the image format is unsupported (as determined by applying the image sniffing rules, again as mentioned earlier), or＼
</li>
					<li>
~UAは %画像~要請 の画像は，何らかの致命的な仕方で画像の寸法を得せないまでに壊れていると決定できる
◎
if the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, or＼
</li>
					<li>
画像~資源の型 ~EQ `multipart/x-mixed-replace$mt
◎
if the resource type is multipart/x-mixed-replace,＼
</li>
				</ul>

<div >
<p>
…ならば：
</p>

<ol ><li>%img の`処理待ち要請$ ~SET ε
</li><li>~RET
</li></ol>

◎
then let pending request be null and abort these steps.
</div>

			</li>
			<li>
~ELSE（ %応答 の`非安全~応答$は %画像~要請 の`画像~data$を表現する）
⇒
%応答 は［
`~CORS同一-生成元$, `~CORS非同一-生成元$
］のいずれかになり、それに応じて，画像の`生成元$に影響する（例： `canvas$e にて利用されるとき）。
◎
Otherwise, response's unsafe response is image request's image data. It can be either CORS-same-origin or CORS-cross-origin; this affects the origin of the image itself (e.g., when used on a canvas).
</li>
		</ol>
	</li>
	<li>
<p>
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %img )：
◎
Queue an element task on the DOM manipulation task source given the img element and the following steps:
</p>
		<ol>
			<li>
<p>
~IF［
%img はこの~algoを開始した時点から`関連な変異$を経た
］：
</p>

<ol ><li>%img の`処理待ち要請$ ~LET ε
</li><li>~RET
</li></ol>

◎
If the img element has experienced relevant mutations since this algorithm started, then let pending request be null and abort these steps.
</li>
			<li>
%img の
( `最後に選定された~source$, `現在の画素~密度$ ) ~SET
( %被選定~source, %被選定~画素~密度 )
◎
Let the img element's last selected source be selected source and the img element's current pixel density be selected pixel density.
</li>
			<li>
%画像~要請 の`状態$ ~SET `完全に可用$st
◎
Set the image request's state to completely available.
</li>
			<li>
%文書 の`可用な画像~list$に，画像を追加する
— この画像は
⇒
~key %~key で識別され,
`上層~cachingは無視する~flag$は ~T にするとする
◎
Add the image to the list of available images using the key key, with the ignore higher-layer caching flag set.
</li>
			<li>
%img の`処理待ち要請を現在の要請に昇格する$
◎
Upgrade the pending request to the current request.
</li>
			<li>
%img の呈示を適切に更新する
◎
Update the img element's presentation appropriately.
</li>
			<li>
%img に向けて，名前 `load$et の`~eventを発火する$
◎
Fire an event named load at the img element.
</li>
		</ol>
	</li>
</ol>
</div>

					</section>
				</section>
				<section id="alt">
<h4 title="Requirements for providing text to act as an alternative for images">4.8.4.4. 画像~用の代替として動作する~textを供するときの要件</h4>

<p class="trans-note">【
この節の内容は、<a href="~HEimageAlt">別~page</a>にて。
】</p>

				</section>
			</section>
			<section id="the-map-element">
<h3 title="The map element">4.8.13 `map^e 要素</h3>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$／`句ng内容$／`可触~内容$
◎
Flow content.
◎
Phrasing content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`句ng内容$が期待される所。
◎
Where phrasing content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`透過的$
◎
Transparent.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`name$a
— `usemap$a 属性から`参照-$するための， `画像~map$の名前
◎
name — Name of image map to reference from the usemap attribute
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`map$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLMapElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute DOMString `name$m;
  [SameObject] readonly attribute `HTMLCollection$I `areas$m;
};
</pre>
</dd>
	</dl>

<p>
`map$e 要素は、 `img$e 要素, および
子孫の `area$e 要素との併用で，`画像~map$を定義する。
この要素は、その子たちを`表現-$する。
◎
The map element, in conjunction with an img element and any area element descendants, defines an image map. The element represents its children.
</p>

<p>
`name@a
属性は、この~mapに名前を与えて，他から`参照-$できるようにする。
`map$e 要素は、この属性を有していなければナラナイ。
この属性には、［
`~ASCII空白$を含む文字列／空~文字列
］を指定してはナラナイ。
また、［
同じ`~tree$内の別の `map$e 要素の `name$a 属性の値
］と等しくなってはナラナイ。
`id$a 属性も指定された場合、両~属性とも同じ値にしなければナラナイ。
◎
The name attribute gives the map a name so that it can be referenced. The attribute must be present and must have a non-empty value with no ASCII whitespace. The value of the name attribute must not be equal to the value of the name attribute of another map element in the same tree. If the id attribute is also specified, both attributes must have the same value.
</p>

  <dl class="domintro">

	<dt>%map . `areas$m</dt>
	<dd>
この `map$e 内の `area$e 要素たちからなる `HTMLCollection$I を返す。
◎
Returns an HTMLCollection of the area elements in the map.
</dd>
</dl>

<dl class="idl-def">
	<dt>`areas@m</dt>
	<dd>
次のようにされた `HTMLCollection$I を返すモノトスル
⇒＃
根は 此れ,
~filterは `area$e 要素のみに合致する
◎
The areas attribute must return an HTMLCollection rooted at the map element, whose filter matches only area elements.
</dd>

	<dt>`name@m</dt>
	<dd>
`name$a 内容~属性を`反映する$モノトスル。
◎
The IDL attribute name must reflect the content attribute of the same name.
</dd>
</dl>

<div class="example">

<p>
画像~mapは、保守し易くなるよう，~page上の他の内容との併用により定義できる。
次の~page例には、先頭に画像~mapがあり，末尾に対応する一連の~text~linkがある。
◎
Image maps can be defined in conjunction with other content on the page, to ease maintenance. This example is of a page with an image map at the top of the page and a corresponding set of text links at the bottom.
</p>

`map-1^xCode

</div>

			</section>
			<section id="the-area-element">
<h3 title="The area element">4.8.14 `area^e 要素</h3>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$ ／ `句ng内容$
◎
Flow content.
◎
Phrasing content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`句ng内容$が期待される所
— ただし、先祖に `map$e 要素がある場合に限る。
◎
Where phrasing content is expected, but only if there is a map element ancestor.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$。
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`~alt0$a
— 画像が可用でないときに利用される代用~text
◎
alt — Replacement text for use when images are not available
</dd>
	<dd>
`coords$a
— `画像~map$内に作成される図形の座標を与える
◎
coords — Coordinates for the shape to be created in an image map
</dd>
	<dd>
`shape$a
— `画像~map$内に作成される図形の種類を与える
◎
shape — The kind of shape to be created in an image map
</dd>
	<dd>
`href$a
— `~hyperlink$の~addressを与える
◎
href — Address of the hyperlink
</dd>
	<dd>
`target$a
— `~hyperlink$による`~navi$対象の`閲覧文脈$を与える
◎
target — Browsing context for hyperlink navigation
</dd>
	<dd>
`download$a
— 資源へ~navigateする代わりに，それを~downloadするかどうか, および
そうする場合の~file名を与える
◎
download — Whether to download the resource instead of navigating to it, and its file name if so
</dd>
	<dd>
`ping$a
— ~pingする`~URL$を与える
◎
ping — URLs to ping
</dd>
	<dd>
`rel$a
— 当の`~hyperlink$を包含している文書における所在と行先~資源との関係性を与える
◎
rel — Relationship between the location in the document containing the hyperlink and the destination resource
</dd>
	<dd>
`~referrerpolicy0$a
— この要素により起動される`~fetch$用の`~referrer施策$
◎
referrerpolicy — Referrer policy for fetches initiated by the element
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
要素は `href$a 属性を有する場合
⇒
`area$AA
◎
If the element has an href attribute: for authors; for implementers.
</dd>
	<dd>
他の場合
⇒
`area-no-href$AA
◎
Otherwise: for authors; for implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLAreaElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute DOMString `alt$mA;
  [`CEReactions$] attribute DOMString `coords$mA;
  [`CEReactions$] attribute DOMString `shape$mA;
  [`CEReactions$] attribute DOMString `target$mA;
  [`CEReactions$] attribute DOMString `download$mA;
  [`CEReactions$] attribute USVString `ping$mA;
  [`CEReactions$] attribute DOMString `rel$mA;
  [SameObject, PutForwards=`value$m] readonly attribute `DOMTokenList$I `relList$mA;
  [`CEReactions$] attribute DOMString `referrerPolicy$mA;
};
`HTMLAreaElement$I includes `HTMLHyperlinkElementUtils$I;
</pre>
	</dd>
</dl>

<p>
`area$e 要素は、次のいずれかを`表現-$する
⇒＃
何らかの~textを伴う~hyperlinkと それに対応する`画像~map$上の区画 ／
無反応~区画
◎
The area element represents either a hyperlink with some text and a corresponding area on an image map, or a dead area on an image map.
</p>

<p>
`area$e 要素に親~nodeがある場合、その いずれかの先祖は `map$e 要素でなければナラナイ。
◎
An area element with a parent node must have a map element ancestor.
</p>

<p>
`area$e 要素が `href$a 属性を有する場合、要素は`~hyperlink$を表現する。
この事例では、要素は
`~alt0@a
属性も有していなければナラナイ。
それは、~hyperlinkの~textを与える。
この属性に指定する~textは、［
その~hyperlinkが、その~text~なしに，その図形が画像に適用された上で利用されたとき
］と同じ種類の~~選択肢を［［
`画像~map$の他の~hyperlink用に指定された~text, および画像の代替~text
］は伴いつつ, 画像~自身は伴わずに呈示されるとき
］に，利用者に供するものでなければナラナイ
— ただし、同じ `画像~map$内に［
同じ資源を指す別の `area$e 要素があって，~~空でない `~alt0$a 属性を有している
］場合は，~~空にされてもヨイ。
◎
If the area element has an href attribute, then the area element represents a hyperlink. In this case, the alt attribute must be present. It specifies the text of the hyperlink. Its value must be text that, when presented with the texts specified for the other hyperlinks of the image map, and with the alternative text of the image, but without the image itself, provides the user with the same kind of choice as the hyperlink would when used without its text but with its shape applied to the image. The alt attribute may be left blank if there is another area element in the same image map that points to the same resource and has a non-blank alt attribute.
</p>

<div class="p">
<p>
`area$e 要素が `href$a 属性を有さない場合：
</p>

<ul ><li>要素が表現する区画は、選択できなくするモノトスル。
</li><li>`~alt0$a 属性は省略されなければナラナイ。
</li></ul>

◎
If the area element has no href attribute, then the area represented by the element cannot be selected, and the alt attribute must be omitted.
</div>

<p>
両~事例とも、［
`shape$a ／ `coords$a
］属性は，当の区画を指定する。
◎
In both cases, the shape and coords attributes specify the area.
</p>

<p>
`shape@a
属性は、`列挙d属性$である。
次の表の 2 列目, 3 列目に、この属性~用に定義される各種~keywordを挙げる。
それぞれ、表の同じ行の 1 列目に与える状態に対応付けられる。
3 列目に挙げる~keywordは、不適合である。
◎
The shape attribute is an enumerated attribute. The following table lists the keywords defined for this attribute. The states given in the first cell of the rows with keywords give the states to which those keywords map. Some of the keywords are non-conforming, as noted in the last column.
</p>

<table><thead><tr><th>状態
<th>~keyword
<th>~keyword（不適合）
</thead>

<tbody><tr><td>`真円$st
<td>`circle@v
<td>`circ@v

<tr><td>`既定$st
<td>`default@v
<td>

<tr><td>`多角形$st
<td>`poly@v
<td>`polygon@v

<tr><td>`矩形$st
<td>`rect@v
<td>`rectangle@v

</tbody></table>
<!-- 

State 	Keywords 	Notes
Circle state 	circle 	
circ 	Non-conforming
Default state 	default 	
Polygon state 	poly 	
polygon 	Non-conforming
Rectangle state 	rect 	
rectangle 	Non-conforming 

-->
<p>
この属性は省略されてもヨイ。
［
`値なし用の既定$ ／ `妥当でない値~用の既定$
］は、`矩形$st状態とする。
◎
The attribute may be omitted. The missing value default and invalid value default are the rectangle state.
</p>

<p>
`coords@a
属性に指定する値は、`妥当な浮動小数点数~list$を包含しなければナラナイ。
この属性は、 `shape$a 属性で記述される図形の座標を与える。
この属性の処理については、`画像~map$処理~modelの一部として述べる。
加えて，この属性は、 `area$e 要素の `shape$a 属性の状態に応じて，以下の要件を満たしていなければナラナイ
— 以下に述べる どの座標も、画像の左上隅から相対的に, 1 個目の成分は右方, 2 個目の成分は下方への距離を表すとし、どの数も `px$css 単位とする：
◎
The coords attribute must, if specified, contain a valid list of floating-point numbers. This attribute gives the coordinates for the shape described by the shape attribute. The processing for this attribute is described as part of the image map processing model.
</p>

<dl>
	<dt>`真円@st</dt>
	<dd>
この状態の下では、要素は `coords$a 属性を有していて，その値は
3 個の整数からなり, 3 個目は 0 以上でなければナラナイ。
◎
In the circle state, area elements must have a coords attribute present, with three integers, the last of which must be non-negative.＼
</dd>
	<dd>
( 1，2 ) 個目の整数が成す座標は 真円の中心,
3 個目の整数は 真円の半径を表現するモノトスル。
◎
The first integer must be the distance in CSS pixels from the left edge of the image to the center of the circle, the second integer must be the distance in CSS pixels from the top edge of the image to the center of the circle, and the third integer must be the radius of the circle, again in CSS pixels.
</dd>

	<dt>`既定@st</dt>
	<dd>
この状態の下では、要素は `coords$a 属性を有してはナラナイ（区画は画像~全体になる）。
◎
In the default state state, area elements must not have a coords attribute. (The area is the whole image.)
</dd>

	<dt>`多角形@st</dt>
	<dd>
この状態の下では、要素は `coords$a 属性を有していて，その値は
6 個~以上かつ偶数~個の整数からなっていなければナラナイ。
◎
In the polygon state, area elements must have a coords attribute with at least six integers, and the number of integers must be even.＼
</dd>
	<dd>
各 正~整数 %i に対し
( %i × 2 − 1, %i × 2 ) 
個目の整数が成す座標は，多角形の %i 個目の頂点を表現するモノトスル。
◎
Each pair of integers must represent a coordinate given as the distances from the left and the top of the image in CSS pixels respectively, and all the coordinates together must represent the points of the polygon, in order.
</dd>

	<dt>`矩形@st</dt>
	<dd>
この状態の下では、要素は `coords$a 属性を有していて，その値は次を満たさなければナラナイ
⇒＃
4 個の整数 %x1, %y1, %x2, %y2 からなる,
%x1 ~LT %x2,
%y1 ~LT %y2
◎
In the rectangle state, area elements must have a coords attribute with exactly four integers, the first of which must be less than the third, and the second of which must be less than the fourth.＼
</dd>
	<dd>
座標 ( %x1, %y1 ) は矩形の左上隅を, ( %x2, %y2 ) は矩形の右下隅を表現するモノトスル。
◎
The four points must represent, respectively, the distance from the left edge of the image to the left side of the rectangle, the distance from the top edge to the top side, the distance from the left edge to the right side, and the distance from the top edge to the bottom side, all in CSS pixels.
</dd>
</dl>

<p>
~UAは、
`area$e 要素を利用して作成された［
`~hyperlinkを追う$／
`~hyperlinkを~downloadする$
］ことを利用者に許容するときに，~linkをどう追うかは、次~節に述べるように［
`href$a, `target$a, `download$a, `ping$a
］属性により裁定される。
~UAは、利用者が~linkを追う前に，
`rel$a 属性を利用して，~target資源に見込まれる資質を 利用者に指示してもヨイ。
◎
When user agents allow users to follow hyperlinks or download hyperlinks created using the area element, as described in the next section, the href, target, download, and ping attributes decide how the link is followed. The rel attribute may be used to indicate to the user the likely nature of the target resource before the user follows the link.
</p>

<p>
`area$e 要素が
`href$a 属性を有さない場合、［
`target$a ／ `download$a ／ `ping$a ／ `rel$a ／ `~referrerpolicy0$a
］属性も有してはナラナイ。
◎
The target, download, ping, rel, and referrerpolicy attributes must be omitted if the href attribute is not present.
</p>

<p>
`area$e 要素が
`itemprop$a 属性を有する場合、
`href$a 属性も有していなければナラナイ。
◎
If the itemprop attribute is specified on an area element, then the href attribute must also be specified.
</p>

<p>
`area$e 要素 %要素 の`作動化の挙動$は
⇒
%要素 の `download$a 属性, および利用者から表出された選好が あれば，それに従って、
%要素 により作成された［
`~hyperlinkを追う$／
`~hyperlinkを~downloadする$
］（もしあれば）
◎
The activation behavior of area elements is to follow the hyperlink or download the hyperlink created by the area element, if any, and as determined by the download attribute and any expressed user preference.
</p>

<dl class="idl-def">
	<dt>`alt@mA</dt>
	<dt>`coords@mA</dt>
	<dt>`target@mA</dt>
	<dt>`download@mA</dt>
	<dt>`ping@mA</dt>
	<dt>`rel@mA</dt>
	<dt>`shape@mA</dt>
	<dd>
順に，（どれも同じ名前の）
`~alt0$a,
`coords$a,
`target$a,
`download$a,
`ping$a,
`rel$a
内容~属性を`反映する$モノトスル。
◎
The IDL attributes alt, coords, target, download, ping, and rel, each must reflect the respective content attributes of the same name.
</dd>

	<dd>
`shape$a 内容~属性を`反映する$モノトスル。
◎
The IDL attribute shape must reflect the shape content attribute.
</dd>

	<dt>`relList@mA</dt>
	<dd>
`rel$a 内容~属性を`反映する$モノトスル。
◎
The IDL attribute relList must reflect the rel content attribute.
</dd>

	<dt>`referrerPolicy@mA</dt>
	<dd>
`既知な値のみに制限され$る下で，
`~referrerpolicy0$a 内容~属性を`反映する$モノトスル。
◎
The IDL attribute referrerPolicy must reflect the referrerpolicy content attribute, limited to only known values.
</dd>
</dl>

			</section>
			<section id="image-maps">
<h3 title="Image maps">4.8.15 画像~map</h3>

				<section id="authoring">
<h4 title="Authoring">4.8.15.1 著作-法</h4>

<p>
`画像~map@
は、画像~上の幾何的な区画に`~hyperlink$を結付けることを可能にする。
◎
An image map allows geometric areas on an image to be associated with hyperlinks.
</p>

<p>
［
`img$e 要素による画像, または
画像を表現している `object$e 要素
］には、当の要素~上に
`usemap@a
属性を指定することにより，（ `map$e 要素による）画像~mapが結付けられてもヨイ。
`usemap$a 属性に指定する値は、ある `map$e 要素を指す`妥当な~hash名~参照$でなければナラナイ。
◎
An image, in the form of an img element or an object element representing an image, may be associated with an image map (in the form of a map element) by specifying a usemap attribute on the img or object element. The usemap attribute, if specified, must be a valid hash-name reference to a map element.
</p>

<div class="example">

<p>
次のような見かけの画像を考える：
◎
Consider an image that looks as follows:
</p>

<figure>`sample-usemap^xCode
<figcaption>
等間隔に並んだ， 4 個の縁取りのある図形：
栗色の穴あき四角形, 緑色の円, 紺色の三角形, 黄色の十文字星形
◎
A line with four shapes in it, equally spaced: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.
</figcaption></figure>

<p>
色付けられた区画だけ~click可能にさせたい場合、次にようにして行える：
◎
If we wanted just the colored areas to be clickable, we could do it as follows:
</p>

`usemap-1^xCode

</div>

				</section>
				<section id="image-map-processing-model">
<h4 title="Processing model">4.8.15.2 処理~model</h4>

<span id="processing-model"></span>

<p>
［
`img$e ／ `object$e
］要素 %要素 が画像を表現していてる, かつ
`usemap$a 属性 %属性 を有する場合、~UAは，以下に従ってを処理するモノトスル：
◎
If an img element or an object element representing an image has a usemap attribute specified, user agents must process it as follows:
</p>

<ol>
	<li>
%~map ~LET `map$e 要素を指す`~hash名~参照として構文解析する$( %属性 の値, %要素 )
◎
Parse the attribute's value using the rules for parsing a hash-name reference to a map element, with the element as the context node. This will return either an element (the map) or null.
</li>
	<li>
~IF［
%~map ~EQ ~NULL
］
⇒
~RET
（以降，画像は画像~mapには結付けられない。）
◎
If that returned null, then return. The image is not associated with an image map after all.
</li>
	<li>
%areas ~LET %~map の子孫であるすべての `area$e 要素たち
◎
Otherwise, the user agent must collect all the area elements that are descendants of the map. Let those be the areas.
</li>
</ol>

<p>
対話的~UAは、 %areas を，次の 2 種類の仕方いずれかに従って処理するモノトスル：
◎
Having obtained the list of area elements that form the image map (the areas), interactive user agents must process the list in one of two ways.
</p>

<dl>
	<dt>
~UAは、 `img$e 要素が表現する~textを示すことを意図する場合：
◎
If the user agent intends to show the text that the img element represents, then it must use the following steps.
</dt>
	<dd class="note">注記：
画像を［
~supportしない／不能化されている
］~UAにおいては、 `object$e 要素は画像を表現し得ないので、この仕方は決して適用されない（代わりに`~fallback内容$が示される）。
したがって、次の手続きが適用されるのは `img$e 要素に限られる。
◎
In user agents that do not support images, or that have images disabled, object elements cannot represent images, and thus this section never applies (the fallback content is shown instead). The following steps therefore only apply to img elements.
</dd>
	<dd>
		<ol>
			<li>
<p>
%areas 内の次に該当する `area$e 要素は、すべてを除去する
</p>

<ul><li>`href$a 属性を有さないもの
</li><li>`~alt0$a 属性を有さないもの
</li><li>`~alt0$a 属性の値は空~文字列である, かつ
%areas 内に別の `area$e 要素 %A があって，両~要素とも
同じ値をとる `href$a 属性を有していて， %A は 空でない `~alt0$a 属性を有する。
</li></ul>
◎
Remove all the area elements in areas that have no href attribute.
◎
Remove all the area elements in areas that have no alt attribute, or whose alt attribute's value is the empty string, if there is another area element in areas with the same value in the href attribute and with a non-empty alt attribute.
</li>
			<li>
結果の %areas 内の各 `area$e 要素は、`~hyperlink$を表現する
— それらの~hyperlinkはすべて、
`img$e の~textに結付けられる方式で利用者に可用にされるべきである。
◎
Each remaining area element in areas represents a hyperlink. Those hyperlinks should all be made available to the user in a manner associated with the text of the img.
</li>
		</ol>
	</dd>
	<dd>
この文脈においては，~UAは、［
`area$e ／ `img$e
］要素のうち `alt^a 属性を［
有さないか、有していて，何らかの可視でない~text（空~文字列も含む）が指定されているもの
］を，`実装定義$な流儀で［
作者が供した相応しい~textの欠如を指示することが意図される
］よう表現してもヨイ。
◎
In this context, user agents may represent area and img elements with no specified alt attributes, or whose alt attributes are the empty string or some other non-visible text, in an implementation-defined fashion intended to indicate the lack of suitable author-provided text.
</dd>

	<dt>
~UAは、画像を示す, かつ［
利用者が画像とヤリトリして~hyperlinkを選択することを許容する
］ことを意図する場合：</dt>
	<dd>
画像は、 %areas 内の各 `area$e 要素から取り出された図形たちの集合に結付けられるモノトスル
— %~map 内の図形たちは、`~tree順序$で最初に近いものほど利用者から見て手前になるよう，多層化するものとする。
◎
If the user agent intends to show the image and allow interaction with the image to select hyperlinks, then the image must be associated with a set of layered shapes, taken from the area elements in areas, in reverse tree order (so the last specified area element in the map is the bottom-most shape, and the first element in the map, in tree order, is the top-most shape).
</dd>
</dl>

<div class="algorithm">
<p>
%areas 内の各 `area$e 要素 %要素 に対しては、当の画像に重ねる［
%要素 が表現する図形の層
］を次に従って得するモノトスル：
◎
Each area element in areas must be processed as follows to obtain a shape to layer onto the image:
</p>

<ol>
	<li>
%状態 ~LET %要素 の `shape$a 属性の状態
◎
Find the state that the element's shape attribute represents.
</li>
	<li>
%座標s ~LET %要素 は `coords$a 属性を
⇒＃
有するならば `浮動小数点数~listとして構文解析する$( 属性の値 ) ／
有さないならば 空~list
◎
Use the rules for parsing a list of floating-point numbers to parse the element's coords attribute, if it is present, and let the result be the coords list. If the attribute is absent, let the coords list be the empty list.
</li>
	<li>
%必要個数 ~LET %状態 に応じて
⇒＃
`真円$st ならば 3 ／
`既定$st ならば 0 ／
`多角形$st ならば 6 ／
`矩形$st ならば 4
◎
If the number of items in the coords list is less than the minimum number given for the area element's current state, as per the following table, then the shape is empty; return.
◎
State 	Minimum number of items
Circle state 	3
Default state 	0
Polygon state 	6
Rectangle state 	4 
</li>
	<li>
~IF［
%座標s 内の~itemの個数 ~LT %必要個数
］
⇒
~RET ε（図形は空）
◎
Check for excess items in the coords list as per the entry in the following list corresponding to the shape attribute's state:
• Circle state
•• Drop any items in the list beyond the third.
• Default state
•• Drop all items in the list.
• Polygon state
•• Drop the last item if there's an odd number of items.
• Rectangle state
•• Drop any items in the list beyond the fourth.
◎
If the shape attribute represents the rectangle state, and the first number in the list is numerically greater than the third number in the list, then swap those two numbers around.
◎
If the shape attribute represents the rectangle state, and the second number in the list is numerically greater than the fourth number in the list, then swap those two numbers around.
</li>
	<li>
~IF［
%状態 ~EQ `真円$st
］~AND［
%座標s 内の 3 個目の数 ~EQ 0
］
⇒
~RET ε（図形は空）
◎
If the shape attribute represents the circle state, and the third number in the list is less than or equal to zero, then the shape is empty; return.
</li>
	<li>
<p>
~RET %状態 に応じて，次で与えられる図形
— 以下におけるどの座標も画像の左上隅を~~原点とし，座標や距離は `px$css 単位とする：
◎
Now, the shape represented by the element is the one described for the entry in the list below corresponding to the state of the shape attribute:
</p>

		<dl class="switch">

			<dt>`真円$st</dt>
			<dd>
中心は %座標s の ( 1, 2 ) 個目の数が成す座標,
半径は %座標s の 3 個目の数
で与えられる真円
◎
Let x be the first number in coords, y be the second number, and r be the third number.
◎
The shape is a circle whose center is x CSS pixels from the left edge of the image and y CSS pixels from the top edge of the image, and whose radius is r CSS pixels.
</dd>

			<dt>`既定$st</dt>
			<dd>
画像の全体を正確に覆う矩形
◎
The shape is a rectangle that exactly covers the entire image.
</dd>

			<dt>`多角形$st</dt>
			<dd>
各 整数［
%i ~IN { 1 ~LTE %i ~LTE  ( %座標s 内の~item数 ÷ 2 ) }
］に対し， %i 個目の頂点は［
%座標s の ( %i × 2 − 1, %i × 2 ) 個目の数が成す座標
］で与えられる，多角形
— この図形の内域は、~even-odd規則
【<a href="~SVGpainting#WindingRule">巻き数~規則</a>】
を利用して確立されるとする `GRAPHICS$r
◎
Let xi be the (2i)th entry in coords, and yi be the (2i+1)th entry in coords (the first entry in coords being the one with index 0).
◎
Let the coordinates be (xi, yi), interpreted in CSS pixels measured from the top left of the image, for all integer values of i from 0 to (N/2)-1, where N is the number of items in coords.
◎
The shape is a polygon whose vertices are given by the coordinates, and whose interior is established using the even-odd rule. [GRAPHICS]
</dd>

			<dt>`矩形$st</dt>
			<dd>
［
%座標s の ( 1, 2 ) 個目の数が成す座標,
%座標s の ( 3, 4 ) 個目の数が成す座標
］の両者を覆う最~小な矩形
◎
Let x1 be the first number in coords, y1 be the second number, x2 be the third number, and y2 be the fourth number.
◎
The shape is a rectangle whose top-left corner is given by the coordinate (x1, y1) and whose bottom right corner is given by the coordinate (x2, y2), those coordinates being interpreted as CSS pixels from the top left corner of the image.
</dd>
		</dl>

<p class="trans-note">【
この段の目的においては、
%座標s が不適合であっても（例：
~itemが余分にある，あるいは `矩形$st のときに［
1 個目の数 ~GT 3 個目の数
］など），図形を成す。
】</p>

<p>
歴史的な理由から，各 座標は、~CSS［
`width$p ／ `height$p
］~prop†により伸張された後の，表示されている画像に相対的に解釈するモノトスル（†または，非~CSS~browserにおいては、画像~要素の［
`width^a ／ `height^a
］属性 —
~CSS~browserは，それらの属性を前述の~CSS~propに対応付ける）。
◎
For historical reasons, the coordinates must be interpreted relative to the displayed image after any stretching caused by the CSS 'width' and 'height' properties (or, for non-CSS browsers, the image element's width and height attributes — CSS browsers map those attributes to the aforementioned CSS properties).
</p>

<p class="note">注記：
~browserによる~zoom特能や，~CSSや~SVGを利用して適用された変形-（座標系変換）は、これらの座標には影響しない。
◎
Browser zoom features and transforms applied using CSS or SVG do not affect the coordinates.
</p>
	</li>
</ol>
</div>

<p>
［
上の~algoにより多層化された図形たちの集合に結付けられている画像
］との［
~pointing装置によるヤリトリ
］による，関連な利用者~対話~eventは、~pointing装置が指示した地点を覆う図形が［
在るならば それらのうち最も手前側の層にあるもの ／
無いならば 画像~要素~自身
］に向けて，最初に発火するモノトスル。
~UAは、`~hyperlink$を表現している個々の `area$e 要素が［
選択される／作動化される
］ことを許容してもヨイ（例：~keyboardを利用して）。
◎
Pointing device interaction with an image associated with a set of layered shapes per the above algorithm must result in the relevant user interaction events being first fired to the top-most shape covering the point that the pointing device indicated, if any, or to the image element itself, if there is no shape covering that point. User agents may also allow individual area elements representing hyperlinks to be selected and activated (e.g. using a keyboard).
</p>

<p class="note">注記：
同じ `map$e 要素（およびその `area$e 要素たち）には，複数の［
`img$e ／`object$e
］要素が結付けられ得るので、同じ `area$e 要素が文書の複数の`~focus可能な区画$に対応することもあり得る。
◎
Because a map element (and its area elements) can be associated with multiple img and object elements, it is possible for an area element to correspond to multiple focusable areas of the document.
</p>

<p>
画像~mapは`~live$である
— ~DOMが変異された場合、~UAは，上の画像~map用の~algoを再度~走らせたかのように動作するモノトスル。
◎
Image maps are live; if the DOM is mutated, then the user agent must act as if it had rerun the algorithms for image maps.
</p>

				</section>
			</section>
</main>
