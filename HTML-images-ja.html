<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML — Images 他 ( Embedded content )（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'mS':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 't':
	text = `&lt;${text}&gt;`;
	break;
case 'tag':
	text = `&lt;${text}&gt;`;
	break;
case 'U': 
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
case 'AA':
	return `<a href="~HTMLARIA#el-${key}">作者~向け</a>／<a href="~HTMLAAM#el-${key}">実装者~向け</a>`;
	break;
case 'obsMb':
	text = '廃用にされた~memberもある';
	href= `~HTMLLS/obsolete.html#${key}-partial`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2025-01-27
trans_update:2024-11-09
source_checked:230602
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/embedded-content.html
nav_prev:HEedits
nav_next:HEimageAlt
trans_1st_pub:2017-02-20

●●class_map
e:element
E:error
a:attr
aS:attr
aL:attr
et:event-type
p:property
t:type
st:attr-state
css:css
v:value
jv:js-value
h:header
U:code-point
obsMb:comment

●●tag_map
I:code
m:code
mS:code
mA:code
mD:code
E:code
c:code
tag:code
e:code
a:code
aS:code
aL:code
et:code
mt:code
st:i
h:code
p:code
t:var
css:code
U:span
v:code
jv:code
i:i
em:em
obsMb:span

●●original_urls
images:https://html.spec.whatwg.org/multipage/images.html
the-map-element:https://html.spec.whatwg.org/multipage/image-maps.html
the-area-element:https://html.spec.whatwg.org/multipage/image-maps.html
image-maps:https://html.spec.whatwg.org/multipage/image-maps.html


●●original_id_map

●●mdn_urls
the-area-element:HTML/Element/area
the-img-element:HTML/Element/img
the-map-element:HTML/Element/map
the-source-element:HTML/Element/source
the-picture-element:HTML/Element/picture

htmlimageelement:API/HTMLImageElement
htmlpictureelement:API/HTMLPictureElement
htmlsourceelement:API/HTMLSourceElement
htmlmapelement:API/HTMLMapElement
htmlareaelement:API/HTMLAreaElement

●●link_map

CEReactions:~HEcustom#cereactions
HTMLConstructor:~HTMLdom#htmlconstructor
LegacyFactoryFunction:~WEBIDLjs#LegacyFactoryFunction

E.EncodingError:~WEBIDL#encodingerror

Promise:~WEBIDL#idl-promise

I.Document:~HTMLdom#document
文書:~HTMLdom#the-document-object
I.HTMLElement:~HTMLdom#htmlelement
I.HTMLImageElement:#htmlimageelement
I.HTMLPictureElement:#htmlpictureelement
I.HTMLSourceElement:#htmlsourceelement
I.HTMLCollection:~DOM4#interface-htmlcollection
I.HTMLMapElement:#htmlmapelement

I.DOMTokenList:~DOM4#interface-domtokenlist
I.HTMLAreaElement:#htmlareaelement
I.HTMLHyperlinkElementUtils:~HTMLlinks#htmlhyperlinkelementutils

m.Image:#dom-image
m.alt:#dom-img-alt
m.areas:#dom-map-areas
m.complete:#dom-img-complete
m.createElement:~DOM4#dom-document-createelement
m.crossOrigin:#dom-img-crossorigin
m.currentSrc:#dom-img-currentsrc
m.decoding:#dom-img-decoding
m.fetchPriority:#dom-img-fetchpriority
m.height:#dom-img-height
m.isMap:#dom-img-ismap
m.loading:#dom-img-loading
m.name:#dom-map-name
m.naturalHeight:#dom-img-naturalheight
m.naturalWidth:#dom-img-naturalwidth
m.referrerPolicy:#dom-img-referrerpolicy
m.requestAnimationFrame:~HTMLGAPI#dom-animationframeprovider-requestanimationframe
m.decode:#dom-img-decode
m.sizes:#dom-img-sizes
m.src:#dom-img-src
m.srcset:#dom-img-srcset
m.useMap:#dom-img-usemap
m.value:~DOM4#dom-domtokenlist-value
m.width:#dom-img-width


mS.media:#dom-source-media
mS.sizes:#dom-source-sizes
mS.src:~HEmedia#dom-source-src
mS.type:#dom-source-type
mS.srcset:#dom-source-srcset

mA.alt:#dom-area-alt
mA.coords:#dom-area-coords
mA.download:#dom-area-download
mA.ping:#dom-area-ping
mA.referrerPolicy:#dom-area-referrerpolicy
mA.rel:#dom-area-rel
mA.relList:#dom-area-rellist
mA.shape:#dom-area-shape
mA.target:#dom-area-target

mD.width:#dom-dim-width
mD.height:#dom-dim-height

et.error:~HTMLindex#event-error
et.load:~HTMLindex#event-load

e.img:#the-img-element
e.picture:#the-picture-element
e.source:#the-source-element
e.area:#the-area-element
e.map:#the-map-element

e.audio:~HEmedia#the-audio-element
e.video:~HEmedia#the-video-element
e.track:~HEtrack#the-track-element

e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element

e.input:~HEinput#the-input-element
e.a:~HEtextlevel#the-a-element
e.button:~HEforms#the-button-element
e.canvas:~HEcanvas#the-canvas-element
e.figure:~HEgrouping#the-figure-element
e.figcaption:~HEgrouping#the-figcaption-element
e.link:~HEmetadata#the-link-element

aS.media:#attr-source-media
aS.sizes:#attr-source-sizes
aS.src:~HEmedia#attr-source-src
aS.srcset:#attr-source-srcset
aS.type:#attr-source-type
aS.width:#attr-source-width
aS.height:#attr-source-height

aL.imagesrcset:~HEmetadata#attr-link-imagesrcset
aL.imagesizes:~HEmetadata#attr-link-imagesizes
aL.href:~HEmetadata#attr-link-href

a.alt:#attr-img-alt
a.crossorigin:#attr-img-crossorigin
a.decoding:#attr-img-decoding
a.fetchpriority:#attr-img-fetchpriority
a.loading:#attr-img-loading
a.href:~HTMLlinks#attr-hyperlink-href
a.id:~HTMLdom#the-id-attribute
a.ismap:#attr-img-ismap
a.name:#attr-map-name
a.referrerpolicy:#attr-img-referrerpolicy
a.sizes:#attr-img-sizes
a.src:#attr-img-src
a.srcset:#attr-img-srcset
a.title:~HTMLdom#attr-title
a.usemap:#attr-hyperlink-usemap
a.height:~HEembed#attr-dim-height
a.width:~HEembed#attr-dim-width

a.~alt0:#attr-area-alt
a.coords:#attr-area-coords
a.shape:#attr-area-shape

a.download:~HTMLlinks#attr-hyperlink-download
a.itemprop:~HTMLLS/microdata.html#names:-the-itemprop-attribute
a.ping:~HTMLlinks#ping
a.~referrerpolicy0:~HTMLlinks#attr-hyperlink-referrerpolicy
a.rel:~HTMLlinks#attr-hyperlink-rel
a.target:~HTMLlinks#attr-hyperlink-target

v.sync:#attr-img-decoding-sync
v.async:#attr-img-decoding-async
v.auto:#attr-img-decoding-auto

v.~auto0:#valdef-sizes-auto

v.circle:#attr-area-shape-keyword-circle
v.circ:#attr-area-shape-keyword-circ
v.default:#attr-area-shape-keyword-default
v.poly:#attr-area-shape-keyword-poly
v.polygon:#attr-area-shape-keyword-polygon
v.rect:#attr-area-shape-keyword-rect
v.rectangle:#attr-area-shape-keyword-rectangle


st.同期c:#attr-img-decoding-sync-state
st.非同期c:#attr-img-decoding-async-state
st.自動:#attr-img-decoding-auto-state

st.~CORSなし:~HTMLurl#attr-crossorigin-none

st.真円:#attr-area-shape-circle
st.既定:#attr-area-shape-default
st.多角形:#attr-area-shape-poly
st.矩形:#attr-area-shape-rect

st.Lazy:~HTMLurl#attr-loading-lazy-state
st.Eager:~HTMLurl#attr-loading-eager-state


t.length:~CSSVAL#lengths
t.media-condition:~MQ5#typedef-media-condition
t.source-size:#source-size
t.source-size-list:#source-size-list
t.source-size-value:#source-size-value
t.whitespace-token:~CSSSYN#typedef-whitespace-token

p.width:~CSS2J#propdef-width
p.height:~CSS2J#propdef-height
p.aspect-ratio:~SIZING#propdef-aspect-ratio
p.image-orientation:~CSSIMAGE#propdef-image-orientation
p.contain-intrinsic-size:~CSSWG/css-sizing-4/#propdef-contain-intrinsic-size

css.px:#px
	~CSSVAL#px
css.pt:~CSSVAL#pt
css.vw:~CSSVAL#vw
css.in:~CSSVAL#in
	~CSS~inch:~CSSVAL#in

h.Cache-Control:~HTTPcache#field.cache-control
mt.multipart/x-mixed-replace:~HTMLiana#multipart/x-mixed-replace
v.must-revalidate:~HTTPcache#cache-response-directive.must-revalidate


	●用語
画像~fetch~task:#_img-fetch-task

全部的に復号-可能:#img-good
可用:#img-available
画像は可用:#img-available
状態:#img-req-state
st.壊en:#img-error
st.完全に可用:#img-all
st.部分的に可用:#img-inc
st.不可用:#img-none
現在の~URL:#img-req-url
	#img-load
画像~data:#img-req-data

復号-:#img-decoding-process
画像~復号~hint:#image-decoding-hint

画像~要請:#image-request
現在の要請:#current-request
処理待ち要請:#pending-request
画像~要請を中止する:#abort-the-image-request
処理待ち要請を現在の要請に昇格する:#upgrade-the-pending-request-to-the-current-request
画像を呈示~用に準備する:#prepare-an-image-for-presentation

§ 画像~用の代替として動作する~textを供するときの要件:~HEimageAlt#alt

表示域に基づく選定:#viewport-based-selection
画像~形式に基づく選定:#image-format-based-selection
~art-direction:#art-direction

画像~dataを更新する:#update-the-image-data
画像~sourceを選定する:#select-an-image-source
~source集合から画像~sourceを選定する:#select-an-image-source-from-a-source-set
~source集合を作成する:#create-a-source-set
~source集合を更新する:#update-the-source-set
~srcset属性を構文解析する:#parse-a-srcset-attribute
~sizes属性を構文解析する:#parse-a-sizes-attribute
~source密度を正規化する:#normalise-the-source-densities

現在の画素~密度:#current-pixel-density
密度~補正-済み生来な~size:#density-corrected-intrinsic-width-and-height
選好される密度~補正-済み寸法:#preferred-density-corrected-dimensions

	#img-determine-type

画像~source:#image-source
iS.~URL文字列:#_image-source-url
iS.記述子:#_image-source-descriptor

	~described上:#unknown-images
機器画素比:#device-pixel-ratio

画像~候補~文字列:#image-candidate-string
画素~密度~記述子:#pixel-density-descriptor
横幅~記述子:#width-descriptor
密度~値:#pixel-density-descriptor-value
	画素~密度~記述子~値／値
横幅~値:#width-descriptor-value
	横幅~記述子~値:#width-descriptor-value
妥当な~source~size~list:#valid-source-size-list
構文解析-~error:#concept-microsyntax-parse-error

最後に選定された~source:#last-selected-source
可用な画像~list:#list-of-available-images
上層~cachingは無視するか:#ignore-higher-layer-caching

関連な変異:#relevant-mutations

~sizes属性:#sizes-attribute
~source集合:#source-set
~srcset属性:#srcset-attribute
~source~size:#source-size-2
自動-~sizeを許容して:#allows-auto-sizes
~srcsetまたは~pictureを利用して:#use-srcset-or-picture

環境における変化に反応する:#img-environment-changes

寸法~属性~source:#concept-img-dimension-attribute-source
画像~map:#image-map

	●用語（HTML
並列的:~HTMLINFRA#in-parallel
~live:~HTMLINFRA#live
文書の中へ挿入された:~HTMLINFRA#insert-an-element-into-a-document
~HTML要素~挿入-時の手続き:~HTMLINFRA#html-element-insertion-steps
~HTML要素~除去-時の手続き:~HTMLINFRA#html-element-removing-steps

反映して:~HTMLcdom#reflect
反映する:~HTMLcdom#reflect
既知な値のみに制限され:~HTMLcdom#limited-to-only-known-values

寸法~属性:~HEembed#dimension-attributes
~media要素:~HEmedia#media-element
~media資源:~HEmedia#media-resource
資源~選定~algo:~HEmedia#concept-media-load-algorithm

~lazy読込ng属性:~HTMLurl#lazy-loading-attribute
~lazyに読込むことになる:~HTMLurl#will-lazy-load-element-steps
~lazy読込n再開~手続き:~HTMLurl#lazy-load-resumption-steps
~lazyに読込んでいる要素の交差~観測を開始する:~HTMLurl#start-intersection-observing-a-lazy-loading-element

~referrer施策~属性:~HTMLurl#referrer-policy-attribute
~fetch優先度~属性:~HTMLurl#fetch-priority-attribute
~CORS設定群~属性:~HTMLurl#cors-settings-attribute
~CORS非同一-生成元:~HTMLurl#cors-cross-origin
~CORS同一-生成元:~HTMLurl#cors-same-origin
~CORSになり得る要請を作成する:~HTMLurl#create-a-potential-cors-request
結付けられた~Content-Type~header:~HTMLurl#content-type
安全でない応答:~HTMLurl#unsafe-response
~URLを符号化法の下で相対的に構文解析する:~HTMLurl#encoding-parsing-a-url
	~HTMLurl#encoding-parsing-and-serializing-a-url → ~HTMLurl#encoding-parsing-a-url, ~URL1#concept-url-serializer
妥当かつ空でない~URL:~HTMLurl#valid-non-empty-url
前後~空白~可の妥当かつ空でない~URL:~HTMLurl#valid-non-empty-url-potentially-surrounded-by-spaces

環境に合致して:~HTMLcms#matches-the-environment
真偽-属性:~HTMLcms#boolean-attribute
列挙d属性:~HTMLcms#enumerated-attribute
欠落~値~用の既定の状態:~HTMLcms#missing-value-default
妥当でない値~用の既定の状態:~HTMLcms#invalid-value-default
妥当な浮動小数点数:~HTMLcms#valid-floating-point-number
妥当な媒体~query~list:~HTMLcms#valid-media-query-list
妥当な負でない整数:~HTMLcms#valid-non-negative-integer
妥当な浮動小数点数~list:~HTMLcms#valid-list-of-floating-point-numbers
寸法~値として構文解析する:~HTMLcms#rules-for-parsing-dimension-values
妥当な~hash名~参照:~HTMLcms#valid-hash-name-reference

浮動小数点数として構文解析する:~HTMLcms#rules-for-parsing-floating-point-number-values
負でない整数として構文解析する:~HTMLcms#rules-for-parsing-non-negative-integers
浮動小数点数~listとして構文解析する:~HTMLcms#rules-for-parsing-a-list-of-floating-point-numbers
~hash名~参照として構文解析する:~HTMLcms#rules-for-parsing-a-hash-name-reference


分類:~HTMLdom#concept-element-categories
内容~属性:~HTMLdom#concept-element-attributes
内容~model:~HTMLdom#concept-element-content-model
この要素を利用できる文脈:~HTMLdom#concept-element-contexts
~accessibilityの考慮点:~HTMLdom#concept-element-accessibility-considerations
~DOM~interface:~HTMLdom#concept-element-dom
大域~属性:~HTMLdom#global-attributes
対話的~内容:~HTMLdom#interactive-content-2
なし:~HTMLdom#concept-content-nothing
可触~内容:~HTMLdom#palpable-content-2
句ng内容:~HTMLdom#phrasing-content-2
text/html における~tag省略:~HTMLdom#concept-element-tag-omission
埋込d内容:~HTMLdom#embedded-content-category
~fallback内容:~HTMLdom#fallback-content
~flow内容:~HTMLdom#flow-content-2
要素間~空白:~HTMLdom#inter-element-whitespace
表現-:~HTMLdom#represents
参照-:~HTMLdom#referenced
~scriptを~supportする要素:~HTMLdom#script-supporting-elements-2
透過的:~HTMLdom#transparent


~event~loop:~WAPI#event-loop
同期区間:~WAPI#synchronous-section
安定~状態を待受ける:~WAPI#await-a-stable-state
~task~source:~WAPI#task-source
~task:~WAPI#concept-task
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
~network用~task~source:~WAPI#networking-task-source
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
大域~taskを~queueする:~WAPI#queue-a-global-task
要素~taskを~queueする:~WAPI#queue-an-element-task
小taskを~queueする:~WAPI#queue-a-microtask
現在の大域~obj:~WAPI#current-global-object
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
~script:~WAPI#concept-script
~scriptingは不能化されて:~WAPI#concept-n-noscript
描画を更新する:~WAPI#update-the-rendering

~animation~frame~callback~map:~HTMLGAPI#list-of-animation-frame-callbacks

全部的に作動中:~HTMLds#fully-active
~navigable:~HTMLds#navigable

結付けられた文書:~WINDOW#concept-document-window
生成元:~ORIGIN#concept-origin

~navi:~HTMLnav#navigate

~hyperlink:~HTMLlinks#hyperlink
~hyperlinkを~downloadする:~HTMLlinks#downloading-hyperlinks
~hyperlinkを追う:~HTMLlinks#following-hyperlinks-2

~focus可能な区画:~HTMLinteraction#focusable-area
~formに所有され得る要素:~HEforms#form-associated-element

具現化されて:~HTMLrendering#being-rendered
~animationを開始し直す:~HTMLrendering#restart-the-animation

終了~tag:~HTMLwriting#syntax-end-tag
~load~eventを遅延する:~HTMLparsing#delay-the-load-event


	●用語（外部
実装定義:~INFRA#implementation-defined
位置~変数:~INFRA#string-position-variable
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII大小無視:~INFRA#ascii-case-insensitive
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
~ASCII空白を読飛ばす:~INFRA#skip-ascii-whitespace
~ASCII空白:~INFRA#ascii-whitespace
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
~HTML名前空間:~INFRA#html-namespace

~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve

~URL:~URL1#concept-url
絶対~URL:~URL1#absolute-url-string
~URLを直列化する:~URL1#concept-url-serializer

~size:~INFRA#list-size


受入-時の手続き:~DOM4#concept-node-adopt-ext
接続されて:~DOM4#connected
要素を作成する:~DOM4#concept-create-element
文書~要素:~DOM4#document-element
~eventを発火する:~DOM4#concept-event-fire
~node文書:~DOM4#concept-node-document
属性~値を設定する:~DOM4#concept-element-attributes-set-value
~tree:~DOM4#concept-tree
~tree順序:~DOM4#concept-tree-order
doc.生成元:~DOM4#concept-document-origin

~fetch:~FETCH#concept-fetch
	~fetching:~FETCH#concept-fetch
i.応答の処理n:~FETCH#process-response
~network~error:~FETCH#concept-network-error
~ok状態s:~FETCH#ok-status
	応答~状態s:~FETCH#concept-response-status
応答:~FETCH#concept-response
rq.~client:~FETCH#concept-request-client
rq.起動元:~FETCH#concept-request-initiator
rq.~referrer施策:~FETCH#concept-request-referrer-policy
rq.優先度:~FETCH#request-priority
rq.同期~flag:~HTMLdep#synchronous-flag
	廃）rq.同期~flag:~FETCH#synchronous-flag

~MIME型:~MIMESNIFF#mime-type
画像を特定的に~sniffするための規則:~MIMESNIFF#rules-for-sniffing-images-specifically
妥当な~MIME型~文字列:~MIMESNIFF#valid-mime-type

~referrer施策:~REFERRER-POLICY#referrer-policy

~math関数:~CSSVAL#math-function
成分~値:~CSSSYN#component-value
~CSS関数:~CSSSYN#function
具象-~obj~size:~CSSIMAGE#concrete-object-size
	生来な寸法:~CSSIMAGE#natural-dimensions → 生来な横幅／生来な縦幅
生来な横幅:~CSSIMAGE#natural-width
生来な縦幅:~CSSIMAGE#natural-height

選好d縦横比:~SIZING#preferred-aspect-ratio

塗り~source:~CSSIMAGE4#paint-source
~commaで分離された成分~値~listとして構文解析する:~CSSSYN#parse-a-comma-separated-list-of-component-values
表示域:~CSS2J#viewport


●●words_table1

alt0:alt
auto0:auto
referrerpolicy0:referrerpolicy


●●words_table

	●仕様
選択肢:option::~::オプション
	choice:~~選択肢
先取的に:aggressiveに:先取りして
補足的:supplemental:~
補足:supplementary:~
流儀:fashion:~
	- ／ようにして:fashion
原始的:rudimentary:~
強いら:forceさ:~
順応-:adapt:~
順応的:adaptive:~
排他的:exclusive:~
付随-:accompany:~
代用:replacement:~
	著作-法:authoring
冗長:redundant:~
漸増的に:incremental mannerで:~
念頭:mind:~
概略的:brief:~
本当の:real:~
出荷-:ship:~
経た:experienceした:~
助け:help:~
	易くする:help
契約:contract:~
破られ:breakされ:~
尊重-:respect:~
稀:rare:~
design::::デザイン
	~design化:designate

	代替として:alternatively
	必要:necessarily
	他方、:on the other hand
	特殊:special
	理想:ideally
	悪化:worse
	加えて:furthermore
	抗して:against
	ごく:very
	早くに as soon as
	目につくほど:notable
	なりかねない:potentially
	人達:people
	の好み:like
	見込まれ:likely
	見込みが高い:will likely
	したいであろう:would like to
	次の様に:look like
	どうなるか:what would be

	影響されない:unaffected
	遂げる:carry out
	~list:array
	からなる:consisting／consists of
	同順の:retaining relative order
	との併用:in conjunction with
	併用-:used together
	併用-:together with
	に応じて:depending on
	いてよい／省略時:optionally
	似た見かけの:similar-looking
	同様の:similar な
	予め除外:preclude
	問いに至る:leads to a question
	困惑させる:confusing
	how
	呼ばれている:referred to as
	-:When asked to 
	同一視される referred to as
	し易くなるよう:to ease
	-:responsible
	という:said to be
	すなわち、:This means
	〜に注意。:Notice that
	~~供する:create
	与えられていれば:applicable
	要がある:require
	否:No

	●fetch／network／navi
Content-Type:
caching::::キャッシュ処理
sniff:
ok:
hash::::ハッシュ
port-scan:port scan:::ポートスキャン
	~server側:server-side
ping:
load:
	~downloadし直:re-download
lazy:
eager:
	後回し:lazy
	早急:eager
上層:higher-layer:~
二重:double:~
本体部位:body part::~::ボディパート
	crossorigin
速度:speed:~
可変速:variable-speed:~
高速:fast:~
低速:slow:~
	短い:low-
	長い:high-
定額制:constant-cost:~
従量制:variable-cost:~
	従量課金:pay by the byte
帯域幅:bandwidth:~
progressive::::プログレッシブ
packet::::パケット
	仕事場:at work
	家:at home
追う:followする:~

	●処理（一般
小task:microtask::小 task:小タスク
	scriptあり:scripted
main::::メイン
必要時:on demand:~
	あり得る:possible
同期区間:synchronous section::~
待受ける:awaitする::待ち受ける
候補:candidate:~
処理待ち:pending:~
壊en:broken:壊れている
破損-:corrupt:~
不可用:unavailable:~
致命的:fatal:~
安定:stable::~
昇格-:upgrade::~
不可分:atomic::~
費やさ:elapseさ:~
修復-:repair:~
抹消-:evict:~
割振る:allocateする:割り振る
受入-:adopt:~
再開:resumption::~
到着-:arrive:~
優先度:priority::~

	以降:rest
	再度~走らせ:rerun
	開始し直す:restart
	先立って:ahead of
	かかった時間:amount of time it takes
	同時:at the same time
	先送り可否:deferral
	この~algoの 〜 段~以降を走らす手続き:the rest of this algorithm starting with the step labeled 〜
	〜か否かが変化した:starts or stops being
	~EQ ε:is not set
	GOTO:jump to the step labeled／ return to the step labeled
	無かったとする下で決定される:but acting as if there are no

	%~CORS属性~状態:corsAttributeState
	%~URL~record:urlString
	%再開~手続き:resumptionSteps
	%物理-横幅:physicalWidth
	%物理-縦幅:physicalHeight
	%要請:req
	%~EXIF~tag~map:exifTagMap
	%寸法:dim
	%寸法~X:dimX:#6
	%寸法~Y:dimY:#6
	%解像度~X:resX:#4
	%解像度~Y:resY:#4
	解像度~単位:resUnit
	-:widthFromDensity
	-:heightFromDensity
	%~event名:eventName
	%挿入される~node:insertedNode
	%除去される~node:removedNode
	%旧-親:oldParent
	%要素:el
	%~source集合:sourceSet
	%~source集合:source set
	%選定された~source:selectedSource
	%要素~群:elements
	%~srcset:srcset
	%~sizes:sizes
	%~href:href
	%未解析~sizes~list:unparsed sizes list
	%未解析~size:unparsed size
	%~size:size
	%場合によっては~eventを省略し得るか:maybe omit events flag
	場合によっては~eventを省略し得る^i:maybe omit events flag set
	%以前の~URL:previousURL
座標s:coords::座標 list:座標リスト
	%座標s:coords
	%大域~obj:global

	●IDL／型／構造
真:true::~
偽:false::~
浮動小数点数:floating-point number:~

	on setting
	instance化:instantiate
	子である:contained
	子たち:children

	●構文
	token化:tokenizer
未解析:unparsed::~::未パースの
丸括弧:parentheses:~
読飛ばす:skipする:読み飛ばす
省略不可:omissibleでない:~
省略:omission:~
	有していない:omitted
不一致:mismatch:~
剥ぐ:stripする:~

	丸括弧:parens
	LEFT PARENTHESIS
	EOF
	RIGHT PARENTHESIS
	COMMA
	LATIN SMALL LETTER

	●媒体／呈示／画像／UI
PNG:
GIF:
JPEG:
PDF:
APNG:
SMIL:
MNG:
WebP:
EXIF:
JPEG-XR:JPEG XR
picture:
srcset:
sizes:
href:
X:
Y:
zoom::::ズーム
art-direction:art direction::art 演出:アート演出
display::::ディスプレイ
column::::カラム
codec::::コーデック
monitor::::モニタ
laptop::::ノートパソコン
多page:paged:::複ページ
装飾的:decorative:~
	環境~上の:environmental
携帯:mobile::~::モバイル
	携帯~機:mobile
電話:phone::~
視覚障碍:visual disability:~
盲目:blind:~
縦横比:aspect ratio:~
比して:compareして:比べて
	〜よりも:relative to
pointing::::ポインタ指示
選択-:select:~
	選定された:selected
変形-:transform:~
視られ:viewされ:~
視れな:viewできな:~
	視れない:unable to view
	見れない:unable to see
塗り:paint:~
塗られ:paintされ:~
生来:natural::~

	OCR
	~animate化:animated
	~flowし直:reflow
	~graphicな:graphical
	単-~page:single-page
	複-~page:multipage
	最~大:biggest
	最~小:smallest
	周りにずれる:shifting around

	●幾何
inch::::インチ
解像度:resolution:~
描画d:rendered:描画
機器画素比:device-pixel-ratio::~
比:ratio::~
回転:rotation::~
	縦幅:future-compat-h
縦:vertical::~
横:horizontal::~
密度:density::~
補正-:correct::~
	密度~補正-済み:density-corrected
半分:half:~
	直立:upright
	真横に倒され:90 degrees rotate
	対角線:diagonal
	切り抜いた:crop
真円:circle:~
矩形:rectangle:~
多角形:polygon:~
無反応:dead::~
図形:shape::~
中心:center:~
半径:radius:~
幾何的:geometric:~
内域:interior:~
even-odd:
多層化-:layer::~
覆う:coverする:~
伸張-:stretch:~
	左上隅:top-left corner
	右下隅:bottom right corner
	地点:point

	●内容
banner::::バナー
bitmap::::ビットマップ
句ng:phrasing::句::フレージング
要素間:inter-element:~
分類:categories:~
可触:palpable::~
透過的:transparent::~
	なし:none
重要部分:critical part:~

	~formに所有され得る:Form-associated
	物語:story
	絵図:picture

	●未分類
圧縮:compression:~
供与-:contribute:~
固定-:fix:~
縮小-:scale down:~
節約-:save:~
	notification
保つ:keepする:~
欠如:lack:~
端末:terminal::~::ターミナル
	jump::::
	-:mark
math:
	~memoryが少ない:low-memory
	pointing
	未~support:unsupported
tablet::::タブレット
	〜な／〜の~text:textual
	~textのみの:text-only
	time::::
	~zoom前の the previous point
	〜したもの／種:version
factory::::ファクトリ
coding-style:coding style:::コーディングスタイル
batch::::バッチ
実効:effective:~
文脈上の:contextual:~
meta::::メタ

	終端-:end
	対応する:relevant
	さほど関連しない:some less relevant
	指定する:present
	書き直:rewrite
	でなくなった:stops being
	埋め尽くす:fill up
	選ぶ／選ばれ／選んだ／選ばせ:choose
	選ぶ:pick
	対応:respective
	switching
	占める:take up
	順に見ていく:walk through
	戻って来る:return
	戻され:return
	わたる:span
	-:presence
	showing
	having
	using
	called
	giving
	running
	allowing
	remaining
	come
	であり続ける／-:stay
	-:mentioned
	referred
	取り出された:taken from
	-:swap around
	-:bare

	-:reverse
	-:remaining
	~~現れない:missing on

	スイス:Switzerland
	ジュネーヴ州:canton Geneva
	カルージュ:Carouge
	自治体:municipality
	町:the town
	紋章:coat of arms
	point
	continuing
	now
	のみを:bare
	-:amongst
	~formに所有され得る:form-associated
	最初に現れ次第:if the preceding entries in the list weren't used '
	-:we
	-:inner
	次の画像は、:here it is
	-:cell
	による:form
	すぐ 〜 ~~状態にある:readily 〜
	自身のみでは:on its own
	まるごと／全体:entirely
	だけで:merely
	旧:older
	行:row
	境目:breakpoint／
	周囲:surrounding
	最終的:the final
	あたりの:per
	他の:the rest of
	前の／先行する:previous
	先行の:preceding
	境目:between
	後続する:follow する
	異なる／種々の:different
	早く:sooner
	互いに:mutually
	のどれでも:any of
	-:something
	何らかの方法:somehow
	その他:anything else
	残りの:the remainder of
	〜でも:yet
	まったく〜ない:at all
	およそ:about
	常時:ever
	連続する:consecutive
	その次の／次回の:next
	その間に:in the meantime
	以前に:previously
	続けて:in succession
	末尾から連続する:trailing
	末尾の:final trailing
	-:final
	他所:anywhere else
	そうするとき:when doing so
	何も:nothing
	前後には，任意個数の:optionally intermixed
	neither
	nor
	まれ:rarely
	rest
	part
	together
	earlier
	一括して:together
	主な:main
	次の／次に:the following
	全体:whole

	●数量
	1 個だけ／1 回だけ／同じ:single
	数:number
	最も幅広:widest
	より幅広:wider
	幅広／幅~wide
	広い:wide
	狭い:narrow
	中程度:middle
	小:small
	中:medium
	大:big
	大きさ:how big
	大きい方の:bigger
	小さい方の:smaller
	小さい／狭い:small
	greater
	大きい／広い:large
	大き過ぎる:too large
	ごく狭い:very low-
	より低く:lower
	高:high-／high
	の 3 倍:three times as many
	以内には:at least

●●html_code_list

■img-0
<img src="1.jpeg" alt="1">
<img src="2.jpeg" loading=eager alt="2">
<img src="3.jpeg" loading=lazy alt="3">
<div id=very-large></div> <!-- この div より後にあるものすべては表示域より下にある -->
<img src="4.jpeg" alt="4">
<img src="5.jpeg" loading=lazy alt="5">

Everything after this div is below the viewport

■img-1
<p>私は<img src="carouge.svg" alt="">カルージュに住んでます。</p>

<p>I lived in <img src="carouge.svg" alt=""> Carouge.</p>


■img-2
<p>私の故郷： <img src="carouge.svg" alt="Carouge"></p>

<p>Home town: <img src="carouge.svg" alt="Carouge"></p>


■img-3
<p>カルージュには紋章があります。</p>
<p><img src="carouge.svg" alt="木の前に横たわるライオンを図案化している紋章"></p>
<p>それは町の至る所で装飾に用いられています。</p>


<p>Carouge has a coat of arms.</p>
<p><img src="carouge.svg" alt="The coat of arms depicts a lion, sitting in front of a tree."></p>
<p>It is used as decoration all over the town.</p>


■img-4
<p>カルージュには紋章があります。</p>
<p><img src="carouge.svg" alt=""></p>
<p>この紋章は、木の前に横たわるライオンを図案化しています。
それは町の至る所で装飾に用いられています。</p>

<p>Carouge has a coat of arms.</p>
<p><img src="carouge.svg" alt=""></p>
<p>The coat of arms depicts a lion, sitting in front of a tree.
It is used as decoration all over the town.</p>


■img-5
<p>彼女がフォルダを取りあげたとき、紙片が抜け落ちた。</p>
<p><img src="carouge.svg" alt="シール状のものに、赤い背景に緑の木、舌を出して尻尾が S 字状の黄色いライオンが描かれている"></p>
<p>フォルダを前に、彼女はその紙片を見つめた。 S だ！待ち望んでいた答えは単純に文字 S だった！なぜ今まで気付かなかった？今やすべてに合点がいった。マリアが舌を突き出したとき、ヘクターが電話でライオンの尻尾と呼んでいたものは…</p>

<p>She picked up the folder and a piece of paper fell out.</p>
<p><img src="carouge.svg" alt="Shaped like a shield, the paper had a
red background, a green tree, and a yellow lion with its tongue
hanging out and whose tail was shaped like an S."></p>
<p>She stared at the folder. S! The answer she had been looking for all
this time was simply the letter S! How had she not seen that before? It all
came together now. The phone call where Hector had referred to a lion's tail,
the time Maria had stuck her tongue out...</p>

'

■img-6
<p>最後の利用者がアップロードした紋章は、これです：</p>
<p><img src="last-uploaded-coat-of-arms.cgi" title="利用者がアップロードした紋章"></p>

<p>The last user to have uploaded a coat of arms uploaded this one:</p>
<p><img src="last-uploaded-coat-of-arms.cgi" title="User-uploaded coat of arms."></p>


■img-7
<article>
 <h1>うちの猫</h1>
 <h2>フワッフィ</h2>
 <p>お気に入りはフワッフィ。</p>
 <img src="fluffy.jpg" alt="編み玉でじゃれるのが好き。">
 <p>この子はとってもかわいいの。</p>
 <h2>マイルズ</h2>
 <p>もう一人の子、マイルズは食べては寝てばかり。</p>
</article>

<article>
 <h1>My cats</h1>
 <h2>Fluffy</h2>
 <p>Fluffy is my favorite.</p>
 <img src="fluffy.jpg" alt="She likes playing with a ball of yarn.">
 <p>She's just too cute.</p>
 <h2>Miles</h2>
 <p>My other cat, Miles just eats and sleeps.</p>
</article>

	'

■img-8
<article>
 <h1>撮影法</h1>
 <h2>動く標的を屋内で撮る</h2>
 <p>秘訣は、標的の速さ、標的までの距離から、どう予測するか知ることです。</p>
 <img src="fluffy.jpg" alt="編み玉に飛びつくように追っかけるネコも、このワザできれいに撮影できます。">
 <h2>夜間撮影</h2>
 <p>これを達成するには、高感度なフィルムを使うか、強いフラッシュをたく必要があります。</p>
</article>


<article>
 <h1>Photography</h1>
 <h2>Shooting moving targets indoors</h2>
 <p>The trick here is to know how to anticipate; to know at what speed and
 what distance the subject will pass by.</p>
 <img src="fluffy.jpg" alt="A cat flying by, chasing a ball of yarn, can be
 photographed quite nicely using this technique.">
 <h2>Nature by night</h2>
 <p>To achieve this, you'll need either an extremely sensitive film, or
 immense flash lights.</p>
</article>

	'

■img-9
<article>
 <h1>私について</h1>
 <h2>うちのペット</h2>
 <p>猫のフワッフィと犬のマイルズ。</p>
 <img src="fluffy.jpg" alt="猫のフワッフィは、せわしなく動きたがる。">
 <p>犬のマイルズは、私との長い散歩が好きです。</p>
 <h2>音楽</h2>
 <p>散歩を終えた後は、バッハを聴いて頭を空っぽにするのが好きです。</p>
</article>

<article>
 <h1>About me</h1>
 <h2>My pets</h2>
 <p>I've got a cat named Fluffy and a dog named Miles.</p>
 <img src="fluffy.jpg" alt="Fluffy, my cat, tends to keep itself busy.">
 <p>My dog Miles and I like go on long walks together.</p>
 <h2>music</h2>
 <p>After our walks, having emptied my mind, I like listening to Bach.</p>
</article>

	'

■img-10
<article>
 <h1>フワッフィと編み玉</h1>
 <p>猫のフワッフィは編み玉でじゃれたり飛び跳ねるのが好きでした。</p>
 <aside><img src="fluffy.jpg" alt="" title="フワッフィ"></aside>
 <p>朝でも夜でもよく遊んでいたものです。</p>
</article>

<article>
 <h1>Fluffy and the Yarn</h1>
 <p>Fluffy was a cat who liked to play with yarn. She also liked to jump.</p>
 <aside><img src="fluffy.jpg" alt="" title="Fluffy"></aside>
 <p>She would play in the morning, she would play in the evening.</p>
</article>



■intro-1
％<h2>今日の特集から</h2>
＜<img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150">＞
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
は、英国の<a href="/wiki/Music_hall">舞台</a>歌手で、...

％<h2>From today's featured article</h2>
＜<img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150">＞
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
was an English <a href="/wiki/Music_hall">music hall</a> singer, ...

	'

■intro-2
％<h2>今日の特集から</h2>
<img ＜src="/uploads/100-marie-lloyd.jpg"＞
     ＜srcset="/uploads/150-marie-lloyd.jpg 1.5x, /uploads/200-marie-lloyd.jpg 2x"＞
     alt="" width="100" height="150">
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
は、英国の<a href="/wiki/Music_hall">舞台</a>歌手で、...


％<h2>From today's featured article</h2>
<img ＜src="/uploads/100-marie-lloyd.jpg"＞
     ＜srcset="/uploads/150-marie-lloyd.jpg 1.5x, /uploads/200-marie-lloyd.jpg 2x"＞
     alt="" width="100" height="150">
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
was an English <a href="/wiki/Music_hall">music hall</a> singer, ...

	'

■intro-3
％<h1><img ＜sizes="100vw" srcset="wolf-400.jpg 400w, wolf-800.jpg 800w, wolf-1600.jpg 1600w"＞
     src="wolf-400.jpg" alt="The rad wolf"></h1>


■intro-4
<img ＜sizes="(max-width: 30em) 100vw, (max-width: 50em) 50vw, calc(33vw - 100px)"＞
     ＜srcset="swing-200.jpg 200w, swing-400.jpg 400w, swing-800.jpg 800w, swing-1600.jpg 1600w"＞
     src="swing-400.jpg" alt="Kettlebell Swing">

■intro-5
<img ＜loading="lazy" width="200" height="200" sizes="auto"＞
     srcset="swing-200.jpg 200w, swing-400.jpg 400w, swing-800.jpg 800w, swing-1600.jpg 1600w"
     src="swing-400.jpg" alt="Kettlebell Swing">

■intro-6
<img loading="lazy" width="200" height="200"
     ＜sizes="auto, (max-width: 30em) 100vw, (max-width: 50em) 50vw, calc(33vw - 100px)"＞
     srcset="swing-200.jpg 200w, swing-400.jpg 400w, swing-800.jpg 800w, swing-1600.jpg 1600w"
     src="swing-400.jpg" alt="Kettlebell Swing">

■intro-7
<picture>
  <source ＜media="(min-width: 45em)"＞ srcset="large.jpg">
  <source ＜media="(min-width: 32em)"＞ srcset="med.jpg">
  <img src="small.jpg" alt="The wolf runs through the snow.">
</picture>



■intro-8
％<h1>
 <picture>
  <source media="(max-width: 500px)" srcset="banner-phone.jpeg, banner-phone-HD.jpeg 2x">
  <img src="banner.jpeg" srcset="banner-HD.jpeg 2x" alt="The Breakfast Combo">
 </picture>
</h1>


■intro-9
％<h2>今日の特集から</h2>
<picture>
 <source srcset="/uploads/100-marie-lloyd.webp" ＜type="image/webp"＞>
 <source srcset="/uploads/100-marie-lloyd.jxr" ＜type="image/vnd.ms-photo"＞>
 <img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150">
</picture>
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
は、英国の<a href="/wiki/Music_hall">舞台</a>歌手で、...

％<h2>From today's featured article</h2>
<picture>
 <source srcset="/uploads/100-marie-lloyd.webp" ＜type="image/webp"＞>
 <source srcset="/uploads/100-marie-lloyd.jxr" ＜type="image/vnd.ms-photo"＞>
 <img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150">
</picture>
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
was an English <a href="/wiki/Music_hall">music hall</a> singer, ...

	'

■intro-10
<figure>
 <picture>
  <source srcset="a-square.png" media="(max-width: 600px)">
  <img src="a-rectangle.png" alt="スーツとメガネを着こなす Barney Frank 氏">
 </picture>
 <figcaption>Barney Frank, 2011</figcaption>
</figure>


 alt="Barney Frank wears a suit and glasses."


■intro-11
<style>
 #a { width: 300px; height: 150px; }
 @media (max-width: 600px) { #a { width: 100px; height: 100px; } }
</style>
<figure>
 <picture>
  <source srcset="a-square.png" media="(max-width: 600px)">
  <img src="a-rectangle.png" alt="スーツとメガネを着こなす Barney Frank 氏" id="a">
 </picture>
 <figcaption>Barney Frank, 2011</figcaption>
</figure>


■intro-12
<style media="(max-width: 600px)">
 #a { width: 100px; height: 100px; }
</style>
<figure>
 <picture>
  <source srcset="a-square.png" media="(max-width: 600px)">
  <img src="a-rectangle.png" width="300" height="150"
  alt="スーツとメガネを着こなす Barney Frank 氏" id="a">
 </picture>
 <figcaption>Barney Frank, 2011</figcaption>
</figure>


■intro-13
<picture>
 <source srcset="pear-mobile.jpeg" media="(max-width: 720px)">
 <source srcset="pear-tablet.jpeg" media="(max-width: 1280px)">
 <img src="pear-desktop.jpeg" alt="The pear is juicy.">
</picture>



■intro-14
<picture>
 <source srcset="pear-mobile.jpeg" media="(max-width: 720px)">
 <source srcset="pear-tablet.jpeg" media="(max-width: 1280px)">
 <source srcset="pear-desktop.jpeg">
 <img src="pear-mobile.jpeg" alt="The pear is juicy.">
</picture>



■intro-15
<picture>
 <source srcset="pear-mobile.jpeg" media="(max-width: 720px)">
 <source srcset="pear-tablet.jpeg" media="(max-width: 1280px)">
 <source srcset="pear-desktop.jpeg">
 <img src="pear-tablet.jpeg" alt="The pear is juicy.">
</picture>


■intro-16
<picture>
 <source srcset="pear-desktop.jpeg" media="(min-width: 1281px)">
 <source srcset="pear-tablet.jpeg" media="(min-width: 721px)">
 <img src="pear-mobile.jpeg" alt="The pear is juicy.">
</picture>

■map-1
<!DOCTYPE HTML>
<HTML LANG="EN">
<TITLE>Babies™: Toys</TITLE>
<HEADER>
 <H1>Toys</H1>
 <IMG SRC="/images/menu.gif"
      ALT="Babies™ navigation menu. Select a department to go to its page."
      USEMAP="#NAV">
</HEADER>
 ...
<FOOTER>
 <MAP NAME="NAV">
  <P>
   <A HREF="/clothes/">Clothes</A>
   <AREA ALT="Clothes" COORDS="0,0,100,50" HREF="/clothes/"> |
   <A HREF="/toys/">Toys</A>
   <AREA ALT="Toys" COORDS="100,0,200,50" HREF="/toys/"> |
   <A HREF="/food/">Food</A>
   <AREA ALT="Food" COORDS="200,0,300,50" HREF="/food/"> |
   <A HREF="/books/">Books</A>
   <AREA ALT="Books" COORDS="300,0,400,50" HREF="/books/">
  </P>
 </MAP>
</FOOTER>

■usemap-1
<p>
図形を選択してください：
 <img src="shapes.png" usemap="#shapes"
      alt="4 種の図形が可用です：栗色の穴あき四角形, 緑色の円, 紺色の三角形, 黄色の十文字星形">
 <map name="shapes">
  <area shape=rect coords="50,50,100,100"> <!-- 四角形の穴 -->
  <area shape=rect coords="25,25,125,125" href="red.html" alt="栗色の四角形">
  <area shape=circle coords="200,75,50" href="green.html" alt="緑色の円">
  <area shape=poly coords="325,25,262,125,388,125" href="blue.html" alt="紺色の三角形">
  <area shape=poly coords="450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60"
        href="yellow.html" alt="黄色の十文字星形">
 </map>
</p>

<p>
 Please select a shape:
 <img src="shapes.png" usemap="#shapes"
      alt="Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.">
 <map name="shapes">
  <area shape=rect coords="50,50,100,100"> <!-- the hole in the red box -->
  <area shape=rect coords="25,25,125,125" href="red.html" alt="Red box.">
  <area shape=circle coords="200,75,50" href="green.html" alt="Green circle.">
  <area shape=poly coords="325,25,262,125,388,125" href="blue.html" alt="Blue triangle.">
  <area shape=poly coords="450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60"
        href="yellow.html" alt="Yellow star.">
 </map>
</p>


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の画像に関係するいくつかの節（
<a href="~SPEC_URL">§ Embedded content</a>,
<a href="~HTMLLS/images.html">§ Images</a>,
<a href="~HTMLLS/image-maps.html">§ Image maps</a>,
他）を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<template id="_persisted_parts">

<svg id="_dgm-intro-svg-1"
	xml:lang="en"
	font-size="2.5" role="img" viewBox="0 0 80 32" font-family="sans-serif" height="200" aria-label="The phone's screen is much smaller compared to the laptop's screen.">
 
 <rect width="6" fill="white" stroke="black" x="6" height="12" y="18" rx="1"></rect>
 <text transform="translate(9 24)
 rotate(-60)" text-anchor="middle" dominant-baseline="central">4″</text>
 
 <rect width="40" stroke-width="2" fill="white" stroke="black" x="30" height="26" y="2" rx="2"></rect>
 <line y2="30" stroke-linecap="round" stroke-width="2" stroke="black" x1="26" y1="30" x2="74"></line>
 <text transform="translate(50 15)
 rotate(-30)" text-anchor="middle" dominant-baseline="central">14″</text>
</svg>

<svg id="_dgm-intro-svg-2"
	xml:lang="en"
	font-size="2.5" role="img" viewBox="0 0 56 27" font-family="sans-serif" height="170" aria-label="One phone has big pixels, the other has small pixels.">
 <defs>
  
<pattern id="img-intro-pixel" width="3" patternUnits="userSpaceOnUse" stroke-linecap="round" x="0" y="0" height="3">
   <rect fill="black" width="3" x="0" height="3" y="0"></rect>
   <line y2="2.5" stroke="red" x1="0.5" x2="0.5" y1="0.5"></line>
   <line y2="2.5" stroke="lime" x1="1.5" x2="1.5" y1="0.5"></line>
   <line y2="2.5" stroke="blue" x1="2.5" x2="2.5" y1="0.5"></line>
  </pattern>
 </defs>
 
 <rect width="6" fill="white" stroke="black" x="6" height="12" y="8" rx="1"></rect>
 <rect width="6" fill="white" stroke="black" x="36" height="12" y="8" rx="1"></rect>
 
 <line y2="24" stroke-width="3" stroke="brown" x1="15" y1="16" x2="22"></line>
 <circle cx="10" cy="10" fill="url(#img-intro-pixel)" stroke="black" r="8"></circle>
 <line y2="24" stroke-width="3" stroke="brown" x1="45" y1="16" x2="52"></line>
 <circle cx="120" transform="scale(0.333333)" cy="30" r="24" stroke-width="3" fill="url(#img-intro-pixel)" stroke="black"></circle>
 
 <text x="20" y="10" dominant-baseline="central">1x</text>
 <text x="50" y="10" dominant-baseline="central">3x</text>
</svg>

<svg id="_dgm-intro-svg-3"
	xml:lang="en"
	font-size="2.5" role="img" viewBox="0 0 60 32" font-family="sans-serif" height="200" aria-label="The tablet has two orientations.">
 
 <rect width="14" fill="white" stroke="black" x="6" height="20" y="5" rx="1"></rect>
 <line y2="24" stroke-width="1.1" stroke="black" x1="6" y1="24" x2="20"></line>
 <text text-anchor="middle" x="13" y="14.5" dominant-baseline="central">縦置き</text>
 <rect width="20" fill="white" stroke="black" x="30" height="14" y="11" rx="1"></rect>
 <line y2="11" stroke-width="1.1" stroke="black" x1="31" y1="25" x2="31"></line>
 <text text-anchor="middle" x="40.5" y="18" dominant-baseline="central">横置き</text>
</svg>

<svg id="_dgm-intro-svg-4"
	viewBox="0 0 52 25.6" height="160" aria-label="The upright-held phone shows a small wolf at the top, and the tablet shows the same image but it is bigger." role="img">

 <rect width="6" fill="white" stroke="black" x="6" height="12" y="8" rx="1"></rect>
 <rect fill="#716966" x="7" width="4" height="2" y="9"></rect>
 <image xlink:href="HTML-resources/wolf.jpg" width="4" x="7" y="9" height="2"></image>

 <rect width="20" fill="white" stroke="black" x="25" height="14" y="6" rx="1"></rect>
 <line y2="6" stroke-width="1.1" stroke="black" x1="26" y1="20" x2="26"></line>
 <rect fill="#716966" x="27" width="17" height="8.5" y="7"></rect>
 <image xlink:href="HTML-resources/wolf.jpg" width="17" x="27" y="7" height="8.5"></image>

</svg>


<svg id="_dgm-intro-svg-5"
	xml:lang="en"
	font-size="2.5" role="img" viewBox="0 0 115 32" font-family="sans-serif" height="200" aria-label="The rotated phone shows a top part of an image of a kettlebell swing; the
upright-held tablet shows a bit smaller images in two columns; the laptop shows images in three
columns.">

 <rect width="12" fill="white" stroke="black" x="6" height="6" y="24" rx="1"></rect>
 <rect fill="#987b5a" width="10" x="7" height="4.5" y="25"></rect>
 <image xlink:href="HTML-resources/kettlebell.jpg" preserveAspectRatio="xMinYMin slice" width="10" x="7" y="25" height="4.5"></image>
 <text text-anchor="middle" x="12" y="21">小のときは 1 列</text>

 <rect width="14" fill="white" stroke="black" x="32" height="20" y="10" rx="1"></rect>
 <line y2="29" stroke-width="1.1" stroke="black" x1="32" y1="29" x2="46"></line>
 <rect fill="#987b5a" width="5.5" x="33" height="5.5" y="11"></rect>
 <image xlink:href="HTML-resources/kettlebell.jpg" width="5.5" x="33" y="11" height="5.5"></image>
 <rect fill="burlywood" width="5.5" x="39.5" height="5.5" y="11"></rect>
 <rect fill="silver" width="5.5" x="33" height="5.5" y="17.5"></rect>
 <text text-anchor="middle" x="39" y="7">中のときは 2 列</text>

 <rect width="40" stroke-width="2" fill="white" stroke="black" x="65" height="26" y="2" rx="2"></rect>
 <line y2="30" stroke-linecap="round" stroke-width="2" stroke="black" x1="61" y1="30" x2="109"></line>
 <rect fill="#987b5a" width="10" x="67" height="10" y="4"></rect>
 <image xlink:href="HTML-resources/kettlebell.jpg" width="10" x="67" y="4" height="10"></image>
 <rect fill="burlywood" width="10" x="80" height="10" y="4"></rect>
 <rect fill="silver" width="10" x="93" height="10" y="4"></rect>
 <text text-anchor="middle" x="85" y="25">大のときは 3 列</text>
</svg>


<svg id="_dgm-intro-svg-6"
	viewBox="0 0 52 25.6"
	height="160"
	aria-label="The upright-held phone shows a cropped image of a wolf; the rotated tablet shows the uncropped image."
	role="img"
>

 <rect width="6" fill="white" stroke="black" x="6" height="12" y="8" rx="1"></rect>
 <rect fill="#716966" x="7" width="4" height="6" y="9"></rect>
 <image xlink:href="HTML-resources/wolf.jpg" preserveAspectRatio="xMidYMid slice" width="4" x="7" y="9" height="6"></image>

 <rect width="20" fill="white" stroke="black" x="25" height="14" y="6" rx="1"></rect>
 <line y2="6" stroke-width="1.1" stroke="black" x1="26" y1="20" x2="26"></line>
 <rect fill="#716966" x="27" width="17" height="8.5" y="7"></rect>
 <image xlink:href="HTML-resources/wolf.jpg" width="17" x="27" y="7" height="8.5"></image>

</svg>

<svg id="_dgm-sample-usemap"
	xmlns="http://www.w3.org/2000/svg"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	viewBox="0 0 600 150"
	width="600" height="150"
>
	<g stroke-width="3" stroke="black">
<path
	fill="maroon"
	fill-rule="evenodd"
	d="M25,25 h100 v100 h-100 z m25,25 v50 h50 v-50 z"
/>
<circle
	fill="green"
	cx="200" cy="75" r="50"
/>
<path
	fill="navy"
	d="M325,25,262,125,388,125"
/>
<path
	fill="yellow"
	d="M450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60z"
/>
<!-- 
	d="m325,25 l-63,100 h126 z"
	d="m450,25 15,35 35,15 -35,15 -15,35 -15,-35 -35,-15 35,-15 z"
 -->
	</g>
</svg>

</template>

<header>
	<hgroup>
<h1>HTML — 画像, 他</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

			<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

◎表記記号

<p>
`px@css
は、
`~CSS~pixel単位＠~CSSVAL#px$の略記である。
</p>

			</section>
			<section id="the-picture-element">
<h4 title="The picture element">4.8.1. `picture^e 要素</h4>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$ ／ `句ng内容$ ／ `埋込d内容$ ／ `可触~内容$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
<p>
順に，次に挙げる要素からなる：
</p>
		<ol>
			<li>
0 個~以上の `source$e 要素
</li>
			<li>
1 個の `img$e 要素
</li>
		</ol>
<p>
加えて、
これらの要素の前後には，
任意個数の`~scriptを~supportする要素$があってよい。
</p>
◎
Zero or more source elements, followed by one img element, optionally intermixed with script-supporting elements.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`picture$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLPictureElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();
};
</pre>
	</dd>
</dl>

<p>
`picture$e 要素は、
その子である `img$e 要素に複数の~sourceを供する容器である。
それは、
作者が［［
~screen画素~密度, `表示域$の~size, 画像~形式, その他の要因
］に基づいて どの画像~資源を利用するか
］について宣言的に［
~UAを制御する／~UAに~hintを与える
］ことを可能にする。
それは、
その子たちを`表現-$する。
◎
The picture element is a container which provides multiple sources to its contained img element to allow authors to declaratively control or give hints to the user agent about which image resource to use, based on the screen pixel density, viewport size, image format, and other factors. It represents its children.
</p>

<p class="note">注記：
`picture$e 要素は、
似た見かけの［
`video$e ／ `audio$e
］要素とは いくぶん異なる。
それらも `source$e 要素を包含するが、
`source$e 要素の `src$aS 属性は、
要素が `picture$e 要素の中に入子にされたときは意味はなく，
資源~選定~algoも異なる。
また、
`picture$e 要素~自身は何も表示しない
— それは、
その子である `img$e 要素に［
複数の`~URL$から選ぶことを可能化する文脈
］を供するだけである。
◎
The picture element is somewhat different from the similar-looking video and audio elements. While all of them contain source elements, the source element's src attribute has no meaning when the element is nested within a picture element, and the resource selection algorithm is different. Also, the picture element itself does not display anything; it merely provides a context for its contained img element that enables it to choose from multiple URLs.
</p>

			</section>
			<section id="the-source-element">
<h4 title="The source element">4.8.2. `source^e 要素</h4>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
なし。
◎
None.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`picture$e 要素の子としては、
`img$e 要素よりも前。
◎
As a child of a picture element, before the img element.
</dd>
	<dd>
`~media要素$の子としては、
どの［
`~flow内容$ ／ `track$e 要素
］よりも前。
◎
As a child of a media element, before any flow content or track elements.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了~tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`type$aS
— 埋込d資源の型
◎
type — Type of embedded resource
</dd>
	<dd>
`media$aS
</dd>
	<dd>
`media$aS
— 適用-可能な~media
◎
media — Applicable media
</dd>
	<dd>
`src$aS
（ `audio$e ／ `video$e 内）
— 資源の~address
◎
src (in audio or video) — Address of the resource
</dd>
	<dd>
`srcset$aS
（ `picture$e 内）
— 種々の状況
（例：高~解像度~display, 狭い~monitor, 等々）
に応じて利用する一連の画像
◎
srcset (in picture) — Images to use in different situations, e.g., high-resolution displays, small monitors, etc.
</dd>
	<dd>
`sizes$aS
（ `picture$e 内）
— 種々の~page~layout用の画像~size
◎
sizes (in picture) — Image sizes for different page layouts
</dd>
	<dd>
`width$a
（ `picture$e 内）
— 横~寸法
◎
width (in picture) — Horizontal dimension
</dd>
	<dd>
`height$a
（ `picture$e 内）
— 縦~寸法
◎
height (in picture) — Vertical dimension
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`source$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLSourceElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute USVString `src$mS;
  [`CEReactions$] attribute DOMString `type$mS;
  [`CEReactions$] attribute USVString `srcset$mS;
  [`CEReactions$] attribute DOMString `sizes$mS;
  [`CEReactions$] attribute DOMString `media$mS;
  [`CEReactions$] attribute unsigned long `width$m;
  [`CEReactions$] attribute unsigned long `height$m;
};
</pre>
	</dd>
</dl>

<p>
`source$e 要素は、
作者が，［
`img$e 要素／
`~media要素$用の複数の代替な`~media資源$
］用に［
複数の代替からなる`~source集合$
］を指定できるようにする。
この要素は、
自身のみでは何も`表現-$しない。
◎
The source element allows authors to specify multiple alternative source sets for img elements or multiple alternative media resources for media elements. It does not represent anything on its own.
</p>

<p>
`source$e 要素には
`type@aS
属性を指定してもヨイ。
指定する値は、
`妥当な~MIME型~文字列$でなければナラナイ。
◎
The type attribute may be present. If present, the value must be a valid MIME type string.
</p>

<p>
`source$e 要素には
`media@aS
属性を指定してもヨイ。
その場合の値は、
`妥当な媒体~query~list$を包含していなければナラナイ。
~UAは、
値が`環境に合致して$いない場合には，［
当の `source$e を飛ばして，次~以降の `source$e 要素を選定する
］ことになる。
◎
The media attribute may also be present. If present, the value must contain a valid media query list. The user agent will skip to the next source element if the value does not match the environment.
</p>

<p class="note">注記：
`media$aS 属性は、
`~media要素$用には，`資源~選定~algo$の間に一回だけ評価される。
対照的に，`picture$e 要素を利用しているときは、
~UAは，各`環境における変化に反応する$ことになる。
◎
The media attribute is only evaluated once during the resource selection algorithm for media elements. In contrast, when using the picture element, the user agent will react to changes in the environment.
</p>

<p>
`source$e 要素 %source の親が `picture$e 要素である場合、
以下に挙げる要件も課される
— 以下における “当の `img$e 要素” は、
`picture$e 要素の最後の子として要求されるそれを指す：
◎
The remainder of the requirements depend on whether the parent is a picture element or a media element:
◎
The source element's parent is a picture element
</p>

<p class="trans-note">【
親が`~media要素$である場合の要件, および
`~media要素$に関係する他の内容は、
`別~page＠~HEmedia#the-source-element$にて。
】</p>

<ul>
	<li>
<p>
%source は
`srcset@aS
属性を有していなければナラナイ
— それは`~srcset属性$になる。
この属性は、
`~source集合$†として %source が選定された場合に，
それ用の`画像~source$たちを供与する††。
◎
The srcset attribute must be present, and is a srcset attribute.
◎
The srcset attribute contributes the image sources to the source set, if the source element is selected.
</p>

<p class="trans-note">【†
当の `img$e 要素の`~source集合$（以下同様）。
】【††
ある時点で所与の `img^e 要素に画像~sourceを供与する `source^e 要素は 1 つまでに限られる（詳細は、 `§ ~source集合の更新-法＠#updating-the-source-set$に）。
】</p>
	</li>
	<li>
<p>
%source の `srcset$aS 属性の値を成す`画像~候補~文字列$は`横幅~記述子$を伴う場合：
◎
If the srcset attribute has any image candidate strings using a width descriptor,＼
</p>
		<ul>
			<li>
%source は `sizes$aS 属性を有していてもヨイ。
◎
the sizes attribute may also be present.＼
</li>
			<li>
当の `img$e 要素は`自動-~sizeを許容して$いない場合、
%source は `sizes$aS 属性を有していなければナラナイ。
◎
If, additionally, the following sibling img element does not allow auto-sizes, the sizes attribute must be present.＼
</li>
		</ul>
<p>
`sizes@aS
属性は、
`~sizes属性$である
— それは、
`~source集合$として %source が選定された場合に，
当の `img$e 要素の`~source~size$を供与する。
◎
The sizes attribute is a sizes attribute, which contributes the source size to the source set, if the source element is selected.
</p>

<p class="note">注記：
当の `img$e 要素が`自動-~sizeを許容して$いる場合、
%source 【！previous sibling source elements】の `sizes$aS 属性を省略できる。
そのような事例では、
値 `~auto0$v を伴う `sizes$aS 属性を指定することと等価になる。
◎
If the img element allows auto-sizes, then the sizes attribute can be omitted on previous sibling source elements. In such cases, it is equivalent to specifying auto.
</p>
	</li>
	<li>
%source は、
`寸法~属性$を~supportする。
当の `img$e 要素は、［
`§ 具現化にて定義される＠~HTMLrendering#dimRendering$とおり，
自身が描画される寸法と縦横比を決定する
］ためとして，
%source の［
`height$a, `width$a
］属性を利用できる
— `img^e 要素~自身のそれらに代えて。
◎
The source element supports dimension attributes. The img element can use the width and height attributes of a source element, instead of those on the img element itself, to determine its rendered dimensions and aspect-ratio, as defined in the Rendering section.
</li>
	<li>
<p>
%source の `type$aS 属性は、
`~source集合$を成す各~画像の型を与える
— これは、
次を許容する
⇒
~UAが所与の型を~supportしない場合に，
%source を飛ばして 次~以降の `source$e 要素を選定する。
◎
The type attribute gives the type of the images in the source set, to allow the user agent to skip to the next source element if it does not support the given type.
</p>

<p class="note">注記：
`type$aS 属性が`指定されていない^em場合、
~UAは，［
画像~資源を~fetchした後に，その画像~形式を~supportしないことを見出した場合
］には，
他の `source$e 要素を選定しないことになる。
◎
If the type attribute is not specified, the user agent will not select a different source element if it finds that it does not support the image format after fetching it.
</p>
	</li>
	<li>
<div>
<p>
~OR↓ が満たされる場合：
</p>
		<ul>
			<li>
%source に後続する同胞として別の `source$e 要素が在る
</li>
			<li>
当の `img$e 要素は `srcset$a 属性を有する
</li>
		</ul>
<p>
%source は ~OR↓ を満たさなければナラナイ：
</p>
◎
When a source element has a following sibling source element or img element with a srcset attribute specified, it must have at least one of the following:
</div>
		<ul>
			<li>
`media$aS 属性が指定されていて、
その値は次を満たす
⇒
`~ASCII小文字~化する$( `前後の~ASCII空白~列を剥ぐ$( 値 ) ) ~NIN { 空~文字列, `all^l }
◎
A media attribute specified with a value that, after stripping leading and trailing ASCII whitespace, is not the empty string and is not an ASCII case-insensitive match for the string "all".
</li>
			<li>
`type$aS 属性が指定されている
◎
A type attribute specified.
</li>
		</ul>
	</li>
	<li>
<p>
%source は `src$aS 属性を有してはナラナイ。
◎
The src attribute must not be present.
</li>
</ul>

<div class="algo">
<p>
`source$e 用の`~HTML要素~挿入-時の手続き$は、
所与の
( %挿入される~node )
に対し：
◎
The source HTML element insertion steps, given insertedNode, are:
</p>
<ol>
	<li>
%親 ~LET %挿入される~node の親
</li>
	<li>
~IF［
%親 は`~media要素$である
］
⇒
【この段の内容は、`別~page＠~HEmedia#the-source-element$にて】
◎
If insertedNode's parent is a media element that has no src attribute and whose networkState has the value NETWORK_EMPTY, then invoke that media element's resource selection algorithm.
</li>
	<li>
~IF［
%親 は `picture$e 要素である
］
⇒
~IF［
%挿入される~node に後続する同胞【！next sibling】として `img$e 要素が在る
］
⇒
該当する最初の `img$e 要素には`関連な変異$が生じたものとみなす
【該当する `img^e が複数個ある場合、不適合になる。】
◎
If insertedNode's next sibling is an img element and its parent is a picture element, then, count this as a relevant mutation for the img element.
</li>
</ol>
</div>

<div class="algo">
<p>
`source$e 用の`~HTML要素~除去-時の手続き$は、
所与の
( %除去される~node, %旧-親 )
に対し：
◎
The source HTML element removing steps, given removedNode and oldParent, are:
</p>
<ol>
	<li>
~IF［
%旧-親 は `picture$e 要素である
］
⇒
~IF［
%除去される~node に後続する同胞【！next sibling】として `img$e 要素が在った
］
⇒
該当する最初の `img$e 要素には`関連な変異$が生じたものとみなす
【該当する `img^e が複数個ある場合、不適合になる。】
◎
If removedNode's next sibling was an img element and oldParent is a picture element, then, count this as a relevant mutation for the img element.
</li>
</ol>
</div>

<div class="p">
<p>
`type@mS
~IDL属性は、
`type$aS 内容~属性を`反映する$モノトスル。
</p>

<p>
`srcset@mS
~IDL属性は、
`srcset$aS 内容~属性を`反映する$モノトスル。
</p>

<p>
`sizes@mS
~IDL属性は、
`sizes$aS 内容~属性を`反映する$モノトスル。
</p>

<p>
`media@mS
~IDL属性は、
`media$aS 内容~属性を`反映する$モノトスル。
</p>
◎
The IDL attributes src, type, srcset, sizes, and media must reflect the respective content attributes of the same name.
</div>

			</section>
			<section id="the-img-element">
<h4 title="The img element">4.8.3. `img^e 要素</h4>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$／
`句ng内容$／
`埋込d内容$／
`~formに所有され得る要素$／
`可触~内容$／
（要素は `usemap$a 属性を有する場合に限り）`対話的~内容$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
Form-associated element.
◎
If the element has a usemap attribute: Interactive content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所
◎
Where embedded content is expected.
</dd>
	<dd>
`picture$e 要素の子としては、
すべての `source$e 要素よりも後。
◎
As a child of a picture element, after all source elements.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了~tag$はない
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`alt$a
— 画像が可用でないときに利用するための代用~text
◎
alt — Replacement text for use when images are not available
</dd>
	<dd>
`src$a
— 画像~資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`srcset$a
— 種々の状況
（例：高~解像度~display, 狭い~monitor, 等々）
に応じて利用する一連の画像
◎
srcset — Images to use in different situations, e.g., high-resolution displays, small monitors, etc.
</dd>
	<dd>
`sizes$a
— 種々の~page~layout用の画像~size
◎
sizes — Image sizes for different page layouts
</dd>
	<dd>
`crossorigin$a
— 要素が非同一-生成元~要請をどう取扱うか
◎
crossorigin — How the element handles crossorigin requests
</dd>
	<dd>
`usemap$a
— 利用する`画像~map$の名前
◎
usemap — Name of image map to use
</dd>
	<dd>
`ismap$a
— この画像は~server側~画像~mapかどうか
◎
ismap — Whether the image is a server-side image map
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>
	<dd>
`referrerpolicy$a
— この要素により起動される`~fetch$用の`~referrer施策$
◎
referrerpolicy — Referrer policy for fetches initiated by the element
</dd>
	<dd>
`decoding$a
— この画像を呈示~用に処理するときに利用する，復号~用の~hint
◎
decoding — Decoding hint to use when processing this image for presentation
</dd>
	<dd>
`loading$a
— 読込ngの先送り可否を決定するときに利用される。
◎
loading — Used when determining loading deferral
</dd>
	<dd>
`fetchpriority$a
— 要素により起動される`~fetch$用の`優先度$rqを設定する。
◎
fetchpriority — Sets the priority for fetches initiated by the element
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
要素は空でない `alt$a 属性を有する場合
⇒
`img$AA
◎
If the element has a non-empty alt attribute: for authors; for implementers.
</dd>
	<dd>
他の場合
⇒
`img-empty-alt$AA
◎
Otherwise: for authors; for implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window,
 `LegacyFactoryFunction$=`Image$m(optional unsigned long width, optional unsigned long height)]
interface `HTMLImageElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute DOMString `alt$m;
  [`CEReactions$] attribute USVString `src$m;
  [`CEReactions$] attribute USVString `srcset$m;
  [`CEReactions$] attribute DOMString `sizes$m;
  [`CEReactions$] attribute DOMString? `crossOrigin$m;
  [`CEReactions$] attribute DOMString `useMap$m;
  [`CEReactions$] attribute boolean `isMap$m;
  [`CEReactions$] attribute unsigned long `width$m;
  [`CEReactions$] attribute unsigned long `height$m;
  readonly attribute unsigned long `naturalWidth$m;
  readonly attribute unsigned long `naturalHeight$m;
  readonly attribute boolean `complete$m;
  readonly attribute USVString `currentSrc$m;
  [`CEReactions$] attribute DOMString `referrerPolicy$m;
  [`CEReactions$] attribute DOMString `decoding$m;
  [`CEReactions$] attribute DOMString `loading$m;
  [`CEReactions$] attribute DOMString `fetchPriority$m;

  `Promise$&lt;undefined&gt; `decode$m();

  // `HTMLImageElement$obsMb
};
</pre>
	</dd>
</dl>

<p>
`img$e 要素は、
画像を表現する。
◎
An img element represents an image.
</p>

<p>
`img$e 要素は、
`寸法~属性~source@
を有する
— それは、
初期~時には要素~自身に設定される。
【次の段落にて述べられる，ある `source^e 要素に設定され得る。】
◎
An img element has a dimension attribute source, initially set to the element itself.
</p>

<p>
この画像は、
要素の
`src@a,
`srcset@a
属性, および［
要素の親が `picture$e 要素である場合における
要素に先行する同胞である各 `source$e 要素の `srcset$aS 属性
］により与えられる，埋込d内容になる。
加えて、
要素の
`alt@a
属性の値は，［
当の画像を処理できない, または
画像の読込ngが不能化されている
］ときのための等価な内容を供する
（すなわち， `img$e 要素の`~fallback内容$になる）。
◎
The image given by the src and srcset attributes, and any previous sibling source elements' srcset attributes if the parent is a picture element, is the embedded content; the value of the alt attribute provides equivalent content for those who cannot process images or who have image loading disabled (i.e. it is the img element's fallback content).
</p>

<p>
`alt$a 属性の値に課される要件は、
`§ 画像~用の代替として動作する~textを供するときの要件$にて述べる。
◎
The requirements on the alt attribute's value are described in a separate section.
</p>

<p>
要素は、
次を満たしていなければナラナイ
⇒
［
`src$a 属性を有する
］~AND［
その値は`前後~空白~可の妥当かつ空でない~URL$を包含する
］~AND［
その~URLは［
対話的でも多pageでもなく, ~scriptも伴わない画像~資源
］を参照している
］
◎終
— 画像は、
~animate化されていてもよい。
◎
The src attribute must be present, and must contain a valid non-empty URL potentially surrounded by spaces referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted.
</p>

<div class="note">

<div class="p">
<p>注記：
上の要件は、
次に挙げるもの等は，画像として与えれることを含意する：
</p>
<ul>
	<li>
静的な~bitmap
（例：~PNG, ~GIF, ~JPEG）
</li>
	<li>
単-~pageな~vector文書
（例：単-~pageな~PDF, ~XML~fileのうち~SVG`文書~要素$を伴うもの）
</li>
	<li>
~animate化された~bitmap
（例：~APNG, ~animate化~GIF)
</li>
	<li>
~animate化された~vector~graphic
（例：~XML~fileのうち，
~SVG`文書~要素$を伴い, 宣言的な~SMIL~animationを利用するもの）
</li>
</ul>
◎
The requirements above imply that images can be static bitmaps (e.g. PNGs, GIFs, JPEGs), single-page vector documents (single-page PDFs, XML files with an SVG document element), animated bitmaps (APNGs, animated GIFs), animated vector graphics (XML files with an SVG document element that use declarative SMIL animation), and so forth.＼
</div>

<div class="p">
<p>
一方で、
次に挙げるもの等は，予め除外される：
</p>

<ul>
	<li>
~scriptを伴う~SVG~file†
</li>
	<li>
複-~page~PDF~file
</li>
	<li>
対話的~MNG~file
</li>
	<li>
~HTML文書
</li>
	<li>
素な~text文書
</li>
</ul>

◎
However, these definitions preclude SVG files with script, multipage PDF files, interactive MNG files, HTML documents, plain text documents, and the like.＼
</div>

<p>
`PNG$r
`GIF$r
`JPEG$r
`PDF$r
`XML$r
`APNG$r
`SVG$r
`MNG$r
</p>

<p class="trans-note">【†
~scriptを伴う場合でも、
実際には，それを不能化した上で呈示する~UAが多いと思われるが
（そのような処理ができない~UAも視野に入れた要件？）。
】</p>
</div>

<p>
要素は `srcset$a 属性を指定してもヨイ
— それは、
`~srcset属性$になる。
◎
The srcset attribute may also be present, and is a srcset attribute.
</p>

<p>
`srcset$a 属性と（その値に`横幅~記述子$は利用されていない場合の） `src$a 属性は、
`~source集合$に`画像~source$を供与する
（どの `source$e 要素も選定されなかった場合に限り）。
◎
The srcset attribute and the src attribute (if width descriptors are not used) contribute the image sources to the source set (if no source element was selected).
</p>

<p>
要素は `srcset$a 属性を有していて，
その値を成すいずれかの`画像~候補~文字列$に`横幅~記述子$が利用された場合、
要素は `sizes$a 属性も有していなければナラナイ。
◎
If the srcset attribute is present and has any image candidate strings using a width descriptor, the sizes attribute must also be present.＼
</p>

<p>
要素には `srcset$a 属性は`指定されてない^em場合、
要素の `loading$a 属性の状態 ~EQ `Lazy$st ならば，
値 `auto^l （`~ASCII大小無視$）を伴う `sizes$a 属性を指定してもヨイ。
◎
If the srcset attribute is not specified, and the loading attribute is in the Lazy state, the sizes attribute may be specified with the value "auto" (ASCII case-insensitive).＼
</p>

<p>
`sizes@a
属性は`~sizes属性$である
— それは、
`~source集合$に`~source~size$を供与する
（どの `source$e 要素も選定されなかった場合に限り）。
◎
The sizes attribute is a sizes attribute, which contributes the source size to the source set (if no source element was selected).
</p>

<p>
`img$e 要素が
`自動-~sizeを許容して@
いるとは、
~AND↓ を満たすことをいう：
◎
An img element allows auto-sizes if:
</p>
<ul>
	<li>
その `loading$a 属性の状態 ~EQ `Lazy$st
◎
its loading attribute is in the Lazy state, and
</li>
	<li>
`~ASCII小文字~化する$( その `sizes$a 属性の値 )
の結果は次を満たす
⇒
［
`auto^l に等しい
］~OR［
`auto,^l で開始している
］
◎
its sizes attribute's value is "auto" (ASCII case-insensitive), or starts with "auto," (ASCII case-insensitive).
</li>
</ul>

<p>
`crossorigin@a
属性は`~CORS設定群~属性$である。
その目的は、
第三者-主体~siteからの画像に対し，
`canvas$e から利用される非同一-生成元~accessを許容することである。
◎
The crossorigin attribute is a CORS settings attribute. Its purpose is to allow images from third-party sites that allow cross-origin access to be used with canvas.
</p>

<p>
`referrerpolicy@a
属性は、
`~referrer施策~属性$である。
その目的は、
画像の`~fetch$時に利用される`~referrer施策$を設定することである。
`REFERRERPOLICY$r
◎
The referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when fetching the image. [REFERRERPOLICY]
</p>

<p>
`decoding@a
属性は、
この画像を`復号-$するときに選好される~methodを指示する。
この属性に指定する値は、
`画像~復号~hint$でなければナラナイ。
◎
The decoding attribute indicates the preferred method to decode this image. The attribute, if present, must be an image decoding hint.＼
</p>

<p>
`decoding$a 属性【は、`列挙d属性$であり，】その［
`欠落~値~用の既定の状態$, `妥当でない値~用の既定の状態$
］は、
いずれも `自動$st とする。
◎
This attribute's missing value default and invalid value default are both the auto state.
</p>

<p>
`fetchpriority@a
属性は、
`~fetch優先度~属性$である。
その目的は、
画像の`~fetch$時に利用される`優先度$rqを設定することである。
◎
The fetchpriority attribute is a fetch priority attribute. Its purpose is to set the priority used when fetching the image.
</p>

<p>
`loading@a
属性は、
`~lazy読込ng属性$である。
その目的は、
表示域の外側にある画像を読込むときの施策を指示することにある。
◎
The loading attribute is a lazy loading attribute. Its purpose is to indicate the policy for loading images that are outside the viewport.
</p>

<div class="algo">
<p>
`img$e 要素の %img の `loading$a 属性の状態が `Eager$st に変化したときは、
次の手続きを走らすモノトスル：
◎
When the loading attribute's state is changed to the Eager state, the user agent must run these steps:
</p>
<ol>
	<li>
%再開~手続き ~LET %img の`~lazy読込n再開~手続き$
◎
Let resumptionSteps be the img element's lazy load resumption steps.
</li>
	<li>
~IF［
%再開~手続き ~EQ ~NULL
］
⇒
~RET
◎
If resumptionSteps is null, then return.
</li>
	<li>
%img の`~lazy読込n再開~手続き$ ~SET ~NULL
◎
Set the img's lazy load resumption steps to null.
</li>
	<li>
%再開~手続き()
◎
Invoke resumptionSteps.
</li>
</ol>
</div>

<div class="example">

`img-0^xCode

<p>
上の例において、
各~画像は，次に従って読込まれる：
◎
In the example above, the images load as follows:
</p>

<dl class="switch">
	<dt>`1.jpeg^c</dt>
	<dt>`2.jpeg^c</dt>
	<dt>`4.jpeg^c</dt>
	<dd>
画像は~eager（早急）に読込まれ，~windowの~load~eventを遅延する。
◎
The images load eagerly and delay the window's load event.
</dd>

	<dt>`3.jpeg^c</dt>
	<dd>
画像は、
表示域に入ったことに因り~layoutが既知になったとき，読込まれる。
しかしながら，~windowの~load~eventは遅延しない。
◎
The image loads when layout is known, due to being in the viewport, however it does not delay the window's load event.
</dd>

	<dt>`5.jpeg^c</dt>
	<dd>
画像は表示域の中に~scrollされたときに限り読込まれ、
~windowの~load~eventは遅延しない。
◎
The image loads only once scrolled into the viewport, and does not delay the window's load event.
</dd>
</dl>

<p class="note">注記：
画像を読込んだ後に~page~layoutが周りにずれるのを防止するため、
開発者には~lazy（後回し）に読込まれる画像に対しては［
`width$a, `height$a
］属性を介して，
`選好d縦横比$を指定する†ことが奨励される
— ~CSSにより画像の［
`width^p ／ `height^p
］~propが【例えば `100%^v ／ `auto^v などに】設定されていても。
◎
Developers are encouraged to specify a preferred aspect ratio via width and height attributes on lazy loaded images, even if CSS sets the image's width and height properties, to prevent the page layout from shifting around after the image loads.
</p>

<p class="trans-note">【†
これは、
~UA~stylesheetを介して `aspect-ratio$p ~propを設定することになると見込まれる
（`参照＠~HTMLissue/5290$）
】</p>
</div>

<div class="algo">
<p>
`img$e 用の`~HTML要素~挿入-時の手続き$は、
所与の
( %挿入される~node )
に対し：
◎
The img HTML element insertion steps, given insertedNode, are:
</p>
<ol>
	<li>
~IF［
%挿入される~node の親は `picture$e 要素である
］
⇒
%挿入される~node には`関連な変異$が生じたものとみなす
◎
If insertedNode's parent is a picture element, then, count this as a relevant mutation for insertedNode.
</li>
</ol>
</div>

<div class="algo">
<p>
`img$e 用の`~HTML要素~除去-時の手続き$は、
所与の
( %除去される~node, %旧-親 )
に対し：
◎
The img HTML element removing steps, given removedNode and oldParent, are:
</p>
<ol>
	<li>
~IF［
%旧-親 は`picture$e 要素である
］
⇒
%除去される~node には`関連な変異$が生じたものとみなす
◎
If oldParent is a picture element, then, count this as a relevant mutation for removedNode.
</li>
</ol>
</div>

<hr>

<p>
`img$e 要素は、
~layout用の~toolとして利用してはナラナイ。
特に， 透明な画像を表示するために利用するべきではない
— そのような画像が［
意味を伝達する／ 文書に有用なものを追加する
］ことは稀にしかないので。
◎
The img element must not be used as a layout tool. In particular, img elements should not be used to display transparent images, as such images rarely convey meaning and rarely add anything useful to the document.
</p>

<hr>

<div class="p">
<p>
`img$e 要素 %img が表現するものは、
その［
`src$a, `alt$a
］属性に依存する
— 以下 %alt は， %img が `alt$a 属性を［
有するならばその値 ／
有さないならば ε
］とする：
</p>

◎
What an img element represents depends on the src attribute and the alt attribute.
</div>

<dl class="switch">
	<dt>%img は `src$a 属性を有する場合：</dt>
	<dd>
<div class="p">
<p>
［
%img の`画像は可用$である
］かつ［
~UAは、
その画像を表示するよう環境設定されている
］ならば、
%img は，その画像~dataを`表現-$する。
</p>

<p>
加えて、
%alt に応じて：
</p>

◎
↓</div>
		<dl class="switch">
			<dt>空~文字列
◎
If the src attribute is set and the alt attribute is set to the empty string
</dt>
			<dd>
画像は、［
文書~内の他の内容に対する装飾的または補足的な何か
］であり，冗長な情報である。
◎
The image is either decorative or supplemental to the rest of the content, redundant with some other information in the document.
</dd>
			<dd>
%img が画像~dataを表現しない場合、
それは何も`表現-$しないので，具現化から完全に省略されてもヨイ。
~UAは、［
画像は在るが，具現化からは省略された旨
］を利用者に通知してもヨイ。
◎
If the image is available and the user agent is configured to display that image, then the element represents the element's image data.
◎
Otherwise, the element represents nothing, and may be omitted completely from the rendering. User agents may provide the user with a notification that an image is present but has been omitted from the rendering.
</dd>

			<dt>
空でない文字列
◎
If the src attribute is set and the alt attribute is set to a value that isn't empty
</dt>
			<dd>
画像は内容に欠かせない。
%alt は、
画像~用の［
等価な, または代用
］~textを与える。
◎
The image is a key part of the content; the alt attribute gives a textual equivalent or replacement for the image.
◎
If the image is available and the user agent is configured to display that image, then the element represents the element's image data.
</dd>
			<dd>
%img が画像~dataを表現しない場合、
%img は %alt で与えられる~textを`表現-$する。
~UAは、［
画像は在るが，具現化からは省略された旨
］を利用者に通知してもヨイ。
◎
Otherwise, the element represents the text given by the alt attribute. User agents may provide the user with a notification that an image is present but has been omitted from the rendering.
</dd>

			<dt>ε
◎
If the src attribute is set and the alt attribute is not
</dt>
			<dd>
画像は内容に欠かせないかもしれない。
画像に等価な~textは、
可用でない。
◎
The image might be a key part of the content, and there is no textual equivalent of the image available.
</dd>
			<dd class="note">注記：
適合~文書において `alt$a 属性が無いことは、［
画像は内容に欠かせないが，その生成-時には画像~用の代用~textは可用でなかった
］ことを指示する。
◎
In a conforming document, the absence of the alt attribute indicates that the image is a key part of the content but that a textual replacement for the image was not available when the image was generated.
</dd>
			<dd>
<p>
%img が画像~dataを表現しない場合：
◎
If the image is available and the user agent is configured to display that image, then the element represents the element's image data.
</p>
				<ul>
					<li>
`src$a 属性の値が空~文字列ならば、
%img は何も`表現-$しない。
◎
If the image has a src attribute whose value is the empty string, then the element represents nothing.
</li>
					<li>
<p>
他の場合、
~UAは，［
画像はあるが，具現化されていない
］ことを［
何らかの類の指示子
］で表示するべきである。
加えて，［
利用者から要請された, または そのように環境設定されている
］, あるいは［
~naviに呼応して文脈上の情報を供することが要求される
］場合、
次に従って導出される結果が ε でないならば，
それを画像~用の~caption情報として供してもヨイ：
◎
Otherwise, the user agent should display some sort of indicator that there is an image that is not being rendered, and may, if requested by the user, or if so configured, or when required to provide contextual information in response to navigation, provide caption information for the image, derived as follows:
</p>
						<ol>
							<li>
~IF［
%img は `title$a 属性を有する
］~AND［
その値 ~NEQ 空~文字列
］
⇒
~RET その属性の値
◎
If the image has a title attribute whose value is not the empty string, then return the value of that attribute.
</li>
							<li>
<p>
~IF［
~AND↓ を満たす要素 %F, %C が在る
］…
</p>
								<ul>
									<li>
%F は `figure$e 要素である
</li>
									<li>
%img は %F の子孫である
</li>
									<li>
%C は %F の子である `figcaption$e 要素のうち最初のものである
</li>
									<li>
%F の子孫は［
%C とその子孫, `要素間~空白$, %img, 非`~flow内容$
］のみからなる
</li>
									<li>
%img は %C の子孫ではない†
</li>
								</ul>
<p>
…ならば
⇒
~RET %C の内容
</p>

<p class="trans-note">【†
この条件は訳者による補完。
原文の言い回しが微妙なので はっきりしないが、
さもなければ，
該当する `figure^e 要素（`~flow内容$でもある）が複数あり得ることになり，
多義的になることに加え、
%img 自身が自身の~caption情報の一部を成す循環が生じ得るので。
】</p>
◎
If the image is a descendant of a figure element that has a child figcaption element, and, ignoring the figcaption element and its descendants, the figure element has no flow content descendants other than inter-element whitespace and the img element, then return the contents of the first such figcaption element.
</li>
							<li>
~RET ε
（~caption情報は無い。）
◎
Return nothing. (There is no caption information.)
</li>
						</ol>
					</li>
				</ul>
			</dd>
		</dl>
	</dd>

	<dt>%img は `src$a 属性を有さない場合：</dt>
	<dd>
%alt が空でない文字列ならば、
%img は その文字列による~textを`表現-$する。
他の場合、
%img は何も`表現-$しない。
◎
If the src attribute is not set and either the alt attribute is set to the empty string or the alt attribute is not set at all
◎
The element represents nothing.
◎
Otherwise
◎
The element represents the text given by the alt attribute.
</dd>
</dl>

<p>
`alt$a 属性は、
助言的~情報を表現するものではない。
~UAは、
`alt$a 属性の内容を `title$a 属性の内容と同じ仕方では呈示しないモノトスル。
◎
The alt attribute does not represent advisory information. User agents must not present the contents of the alt attribute in the same way as content of the title attribute.
</p>

<p>
~UAは，常に、
画像を［
表示させる／させない
］の選択肢を利用者に供してもヨイ。
~UAは、
利用者が画像を見れないときには
— 視覚障碍 ／ ~graphic能力のない~text端末を利用しているなど —
利用者が用立て易くするような経験則を適用してもヨイ。
そのような経験則には、
一例として，画像の中に見出された~textの光学文字認識（ OCR ）も含まれ得る。
◎
User agents may always provide the user with the option to display any image, or to prevent any image from being displayed. User agents may also apply heuristics to help the user make use of the image when the user is unable to see it, e.g. due to a visual disability or because they are using a text terminal with no graphics capabilities. Such heuristics could include, for instance, optical character recognition (OCR) of text found within the image.
</p>

<p class="warning">
~UAには，［
`alt$a 属性が欠落な事例を修復する
］ことが奨励されるが、
作者は，そのような挙動に依拠してはナラナイ。
詳細は、
`§ 画像~用の代替として動作する~textを供するときの要件$に述べる。
◎
While user agents are encouraged to repair cases of missing alt attributes, authors must not rely on such behavior. Requirements for providing text to act as an alternative for images are described in detail below.
</p>

<p>
`img$e 要素の`内容^emは、
あっても，具現化の目的においては無視される。
◎
The contents of img elements, if any, are ignored for the purposes of rendering.
</p>

<hr>

<p>
`img$e 要素が `usemap$a 属性を有する場合、
画像には`画像~map$が結付けられることを指示し得る。
◎
The usemap attribute, if present, can indicate that the image has an associated image map.
</p>

<p>
`img$e 要素が［
`ismap@a
属性を有する
］~AND［
先祖に `href$a 属性を有する `a$e 要素がある
］場合、
~server側~画像~mapへの~accessを供することを指示する。
これは、
その `a$e 要素~上の~eventがどう取扱われるかにも影響する。
◎
The ismap attribute, when used on an element that is a descendant of an a element with an href attribute, indicates by its presence that the element provides access to a server-side image map. This affects how events are handled on the corresponding a element.
</p>

<p>
`ismap$a 属性は`真偽-属性$である。
この属性は、
要素の先祖に［
`href$a 属性を有する `a$e 要素
］が無い場合には，指定してはナラナイ。
◎
The ismap attribute is a boolean attribute. The attribute must not be specified on an element that does not have an ancestor a element with an href attribute.
</p>

<p class="note">注記：
同じ `picture$e 要素~内に［［
`usemap$a ／ `ismap$a
］属性を有する `img$e 要素
］と［
`media$aS 属性を有する `source$e 要素
］が併用された場合、
結果の挙動は，困惑させるものになる。
◎
The usemap and ismap attributes can result in confusing behavior when used together with source elements with the media attribute specified in a picture element.
</p>

<p>
`img$e 要素は、
`寸法~属性$を~supportする。
◎
The img element supports dimension attributes.
</p>

<div class="p">
<p>
`alt@m
~IDL属性は、
`alt$a 内容~属性を`反映する$モノトスル。
</p>

<p>
`src@m
~IDL属性は、
`src$a 内容~属性を`反映する$モノトスル。
</p>

<p>
`srcset@m
~IDL属性は、
`srcset$a 内容~属性を`反映する$モノトスル。
</p>

<p>
`sizes@m
~IDL属性は、
`sizes$a 内容~属性を`反映する$モノトスル。
</p>

◎
The alt, src, srcset, and sizes IDL attributes must reflect the respective content attributes of the same name.
</div>

<p>
`crossOrigin@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`crossorigin$a 内容~属性を`反映する$モノトスル。
◎
The crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.
</p>

<p>
`useMap@m
~IDL属性は、
`usemap$a 内容~属性を`反映する$モノトスル。
◎
The useMap IDL attribute must reflect the usemap content attribute.
</p>

<p>
`isMap@m
~IDL属性は、
`ismap$a 内容~属性を`反映する$モノトスル。
◎
The isMap IDL attribute must reflect the ismap content attribute.
</p>

<p>
`referrerPolicy@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`referrerpolicy$a 内容~属性を`反映する$モノトスル。
◎
The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.
</p>

<p>
`decoding@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`decoding$a 内容~属性を`反映する$モノトスル。
◎
The decoding IDL attribute must reflect the decoding content attribute, limited to only known values.
</p>

<p>
`loading@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`loading$a 内容~属性を`反映する$モノトスル。
◎
The loading IDL attribute must reflect the loading content attribute, limited to only known values.
</p>

<p>
`fetchPriority@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`fetchpriority$a 内容~属性を`反映する$モノトスル。
◎
The fetchPriority IDL attribute must reflect the fetchpriority content attribute, limited to only known values.
</p>

<dl class="domintro">

	<dt>%image.`width$m [ = %value ]</dt>
	<dt>%image.`height$m [ = %value ]</dt>
	<dd>
これらの属性は、［
この画像の実際に描画される寸法が既知ならば それ ／
~ELSE_ 0
］を返す。
◎
These attributes return the actual rendered dimensions of the image, or 0 if the dimensions are not known.
</dd>
	<dd>
設定して，対応する内容~属性を変更できる。
◎
They can be set, to change the corresponding content attributes.
</dd>

	<dt>%image.`naturalWidth$m</dt>
	<dt>%image.`naturalHeight$m</dt>
	<dd>
これらの属性は、この画像の［
`生来な横幅$／`生来な縦幅$
］は既知ならば それ ／
~ELSE_ 0
］を返す
◎
These attributes return the natural dimensions of the image, or 0 if the dimensions are not known.
</dd>

	<dt>%image.`complete$m</dt>
	<dd>
この画像は［
完全に~downloadされた, または 指定されていないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the image has been completely downloaded or if no image is specified; otherwise, returns false.
</dd>

	<dt>%image.`currentSrc$m</dt>
	<dd>
この画像の`絶対~URL$を返す。
◎
Returns the image's absolute URL.
</dd>

	<dt>%image.`decode()$m</dt>
	<dd>
この~methodは、
~UAに画像を`並列的$に`復号-$させ，［
復号が完了した時点で充足されることになる~promise
］を返す。
◎
This method causes the user agent to decode the image in parallel, returning a promise that fulfills when decoding is complete.
</dd>
	<dd>
画像を復号できなかった場合、
~promiseは `EncodingError$E 例外で却下されることになる。
◎
The promise will be rejected with an "EncodingError" DOMException if the image cannot be decoded.
</dd>

	<dt>%image = new `Image( [ width [, height ] ] )$m</dt>
	<dd>
新たな `img$e 要素を返す
— ［
%width ／ %height
］が与えられていれば、
それを要素の［
`width$a ／ `height$a
］属性に設定した上で。
◎
Returns a new img element, with the width and height attributes set to the values passed in the relevant arguments, if applicable.
</dd>

</dl>

<div class="algo">
<p>
［
`width@m
／
`height@m
］取得子~手続きは：
</p>
<ol>
	<li>
%~size ~LET ［
画像は`具現化されて$いるならば描画された画像の~size ／
~ELSE_ `画像は可用$であるならば画像の`密度~補正-済み生来な~size$／
~ELSE_ ( 0, 0 )
］
</li>
	<li>
~RET %~size を成す［
`width^m 用には横幅 ／
`height^m 用には縦幅
］を成す `px$css 数
`CSS$r
</li>
</ol>
◎
The IDL attributes width and height must return＼
the rendered width and height of the image, in CSS pixels, if the image is being rendered;＼
or else the density-corrected natural width and height of the image, in CSS pixels, if the image has density-corrected natural width and height and is available but is not being rendered;＼
or else 0, if the image is not available or does not have density-corrected natural width and height. [CSS]
</div>

<p>
［
`width$m ／ `height$m
］設定子は、［
`width$a ／ `height$a
］内容~属性を`反映して$いるかのように動作するモノトスル。
◎
On setting, they must act as if they reflected the respective content attributes of the same name.
</p>

<div class="algo">
<div>
<p>
［
`naturalWidth@m
／
`naturalHeight@m
］取得子~手続きは：
</p>
<ol>
	<li>
%~size ~LET ［
`画像は可用$であるならば画像の`密度~補正-済み生来な~size$／
~ELSE_ ( 0, 0 )
］
</li>
	<li>
~RET %~size を成す［
`naturalWidth^m 用には横幅／
`naturalHeight^m 用には縦幅
］を成す `px$css 数
</li>
</ol>
◎
The IDL attributes naturalWidth and naturalHeight must return the density-corrected natural width and height of the image, in CSS pixels, if the image has density-corrected natural width and height and is available, or else 0. [CSS]
</div>

<p class="note">注記：
画像の`密度~補正-済み生来な~size$は［
画像の~metadata内に指定された方位を織り込む
］ので、［
`naturalWidth$m, `naturalHeight$m
］は［
画像を正しく方位するために必要な回転
］を適用した後の寸法を反映する
— `image-orientation$p ~propの値に関わらず。
◎
Since the density-corrected natural width and height of an image take into account any orientation specified in its metadata, naturalWidth and naturalHeight reflect the dimensions after applying any rotation needed to correctly orient the image, regardless of the value of the 'image-orientation' property.
</p>
</div>

<div class="algo">
<p>
`complete@m
取得子~手続きは
⇒
~RET ~IS ~OR↓：
</p>
<ul>
	<li>
［
コレは `srcset$a 属性を有していない
］~AND［
コレは `src$a 属性を［
有していないか，有していて その値 ~EQ 空~文字列
］］
</li>
	<li>
［
コレの`現在の要請$の`状態$ ~IN { `完全に可用$st, `壊en$st }
］~AND［
コレの`処理待ち要請$ ~EQ ~NULL
］
</li>
</ul>
◎
The complete getter steps are:
• If any of the following are true:
•• both the src attribute and the srcset attribute are omitted;
•• the srcset attribute is omitted and the src attribute's value is the empty string;
•• the img element's current request's state is completely available and its pending request is null; or
•• the img element's current request's state is broken and its pending request is null,
• then return true.
• Return false.
</div>

<div class="algo">
`currentSrc@m
取得子~手続きは
⇒
~RET コレの`現在の要請$の`現在の~URL$
◎
The currentSrc IDL attribute must return the img element's current request's current URL.
</div>

<div class="algo">
<p>
`decode()@m
~method~手続きは：
◎
The decode() method, when invoked, must perform the following steps:
</p>
<ol>
	<li>
%~promise ~LET 新たな~promise
◎
Let promise be a new promise.
</li>
	<li>
<p>
`小taskを~queueする$( 次の手続き )
◎
Queue a microtask to perform the following steps:
</p>

<div class="note">
<p>注記：
これが行われるのは、
`画像~dataを更新する$手続きが小task内も占めるからである。
したがって、
次のような~codeに対し：
◎
This is done because updating the image data takes place in a microtask as well. Thus, to make code such as
</p>

<pre class="lang-js">
img.src = "stars.jpg";
img.decode();
</pre>

<p>
`stars.jpg^c を適正に復号するためには、
処理を小task 1 個分だけ遅延する必要がある。
◎
properly decode stars.jpg, we need to delay any processing by one microtask.
</p>
</div>

<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
%大域~obj ~LET コレに`関連な大域~obj$
◎
Let global be this's relevant global object.
</li>
			<li>
~IF［
コレの`~node文書$は`全部的に作動中$でない
］~OR［
コレの`現在の要請$の`状態$ ~EQ `壊en$st
］
⇒＃
`~promiseを却下する$( %~promise, `EncodingError$E 例外 )；
~RET
◎
If any of the following are true:
• this's node document is not fully active; or
• this's current request's state is broken,
then reject promise with an "EncodingError" DOMException.
◎
Otherwise,＼
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす
— 次に挙げるいずれかが生じるまで待機してから，対応する動作を遂行する：
◎
in parallel, wait for one of the following cases to occur, and perform the corresponding actions:
</p>
				<dl class="switch">
					<dt>
コレの`~node文書$は`全部的に作動中$でなくなった
◎
This img element's node document stops being fully active
</dt>
					<dt>
コレの`現在の要請$は変化したか変異した
◎
This img element's current request changes or is mutated
</dt>
					<dt>
コレの`現在の要請$の`状態$ ~EQ `壊en$stになった
◎
This img element's current request's state becomes broken
</dt>
					<dd>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %大域~obj, 次の手続き )
◎
Queue a global task on the DOM manipulation task source with global＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `EncodingError$E 例外 )
◎
to reject promise with an "EncodingError" DOMException.
</div>
					</dd>

					<dt>
コレの`現在の要請$の`状態$は`完全に可用$stになった
◎
This img element's current request's state becomes completely available
</dt>
					<dd>
<p>
画像を`復号-$する
— その結果に応じて：
◎
Decode the image.
</p>
<div >
						<dl class="switch">
							<dt>
この画像~用には復号を遂行する必要はなかった
（例：画像は~vector~graphicである）
◎
If decoding does not need to be performed for this image (for example because it is a vector graphic) or＼
</dt>
							<dt>
復号~処理nは成功裡に完了した
◎
the decoding process completes successfully,＼
</dt>
							<dd>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %大域~obj, 次の手続き )
◎
then queue a global task on the DOM manipulation task source with global＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise, `undefined^jv )
◎
to resolve promise with undefined.
</div>
							</dd>

							<dt>
復号に失敗した
（例：画像~dataは妥当でないことに因り）
◎
If decoding fails (for example due to invalid image data),＼
</dt>
							<dd>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %大域~obj, 次の手続き )
◎
then queue a global task on the DOM manipulation task source with global＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `EncodingError$E 例外 )
◎
to reject promise with an "EncodingError" DOMException.
</div>
							</dd>
						</dl>
</div>

<p>
~UAは、［
復号された~media~dataが，すぐ可用な~~状態であり続ける
］ことを確保するべきである
— 少なくとも［
`~event~loop$における次回の`描画を更新する$ 段が成功裡に終端する
］までは。
これは、
~API契約の重要な部分を成し，アリな限り破られるべきでない。
（これに違反するのは、
概して，［
~memoryが少なく復号された画像~dataを抹消する要がある状況
］か［
復号された形で~~一時に保つには画像が大き過ぎるとき
］に限られるであろう。）
◎
User agents should ensure that the decoded media data stays readily available until at least the end of the next successful update the rendering step in the event loop. This is an important part of the API contract, and should not be broken if at all possible. (Typically, this would only be violated in low-memory situations that require evicting decoded image data, or when the image is too large to keep in decoded form for this period of time.)
</p>
					</dd>
				</dl>

<p class="note">注記：
~animate化~画像が`完全に可用$stになるのは、
そのすべての~frameが読込まれた後に限られる。
したがって，
実装が その時点より前に最初の~frameを復号できるとしても、
上の手続きではそうすることなく，
すべての~frameが可用になるまで待機する。
◎
Animated images will become completely available only after all their frames are loaded. Thus, even though an implementation could decode the first frame before that point, the above steps will not do so, instead waiting until all frames are available.
</p>
			</li>
		</ol>
</div>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="example">
<p>
`decode$m ~methodを使わずに，
`img$e 要素を読込んでから表示する処理nは、
次の様になるであろう：
◎
Without the decode() method, the process of loading an img element and then displaying it might look like the following:
</p>

<pre class="lang-js">
const %img = new Image();
%img.src = "nebula.jpg";
%img.onload = () =&gt; {
    document.body.appendChild(%img);
};
%img.onerror = () =&gt; {
    document.body.appendChild(new Text("nebula を読込めませんでした：("));
};
</pre>

<!-- 
Could not load the nebula :
-->

<p>
しかしながら，これでは、
何~frameか目につくほどに落とされ得る
— 画像を~DOMの中に挿入した後に生じる塗りには，
~main~threadにおける同期的な復号を要するので。
◎
However, this can cause notable dropped frames, as the paint that occurs after inserting the image into the DOM causes a synchronous decode on the main thread.
</p>

<p>
`decode$m ~methodを利用すれば、
これを次の様に書き直せる：
◎
This can instead be rewritten using the decode() method:
</p>

<pre class="lang-js">
const %img = new Image();
%img.src = "nebula.jpg";
%img.decode().then(() =&gt; {
    document.body.appendChild(%img);
}).catch(() =&gt; {
    document.body.appendChild(new Text("nebula を読込めませんでした： ("));
});
</pre>

<p>
この形であれば、［
画像が~DOMに挿入される（したがって塗られる）のは、
それを`並列的$に復号して復号~処理nが完了した後に限られる
］ので，~frameが落とされるのを避けれる。
◎
This latter form avoids the dropped frames of the original, by allowing the user agent to decode the image in parallel, and only inserting it into the DOM (and thus causing it to be painted) once the decoding process is complete.
</p>
</div>

<div class="example">
<p>
`decode()$m ~methodは、［
復号された画像~dataが 1 ~frame以内に可用になる
］ことを確保しようと試みるので，
`requestAnimationFrame()$m ~APIと組合せることもできる。
このことは、［
すべての~DOM改変が，`~animation~frame~callback~map$に一括して~batchされる
］ことを確保するような［
~coding-style／~framework
］と併用できることを意味する：
◎
Because the decode() method attempts to ensure that the decoded image data is available for at least one frame, it can be combined with the requestAnimationFrame() API. This means it can be used with coding styles or frameworks that ensure that all DOM modifications are batched together as animation frame callbacks:
</p>

<pre class="lang-js">
const %container = document.querySelector("#container");

const { %containerWidth, %containerHeight } = computeDesiredSize();
requestAnimationFrame(() =&gt; {
 %container.style.width = %containerWidth;
 %container.style.height = %containerHeight;
});

// ...

const %img = new Image();
%img.src = "supernova.jpg";
%img.decode().then(() =&gt; {
    requestAnimationFrame(() =&gt; %container.appendChild(%img));
});
</pre>
</div>

<div class="algo">
<p>
`Image(width, height)@m
は、
`HTMLImageElement$I ~objを作成する旧来の~factory関数である
（ `createElement()$m などの~DOMによる~factory~methodに加えて供されている）。
その~method~手続きは：
◎
A legacy factory function is provided for creating HTMLImageElement objects (in addition to the factory methods from DOM such as createElement()): Image(width, height).＼
When invoked, the legacy factory function must perform the following steps:
</p>
<ol>
	<li>
%文書 ~LET `現在の大域~obj$に`結付けられた文書$
◎
Let document be the current global object's associated Document.
</li>
	<li>
%img ~LET `要素を作成する$( %文書, `img^l, `~HTML名前空間$ )
◎
Let img be the result of creating an element given document, "img", and the HTML namespace.
</li>
	<li>
~IF［
%width ~NEQ ε
］
⇒
%img の`属性~値を設定する$( `width^l,  %width )
◎
If width is given, then set an attribute value for img using "width" and width.
</li>
	<li>
~IF［
%height ~NEQ ε
］
⇒
%img の`属性~値を設定する$( `height^l, %height )
◎
If height is given, then set an attribute value for img using "height" and height.
</li>
	<li>
~RET %img
◎
Return img.
</li>
</ol>
</div>

<div class="example">

<p>
同じ画像であっても、
それに適切な代替~textは，文脈に依存して異なり得る。
◎
A single image can have different appropriate alternative text depending on the context.
</p>

<p>
以下の各~事例には，どれも同じ画像が利用されているが、
それでも `alt$a ~textは，事例ごとに異なる。
画像は、
スイス ジュネーヴ州
`カルージュ自治体の紋章＠https://upload.wikimedia.org/wikipedia/commons/f/fc/Carouge-coat_of_arms.svg$である。
◎
In each of the following cases, the same image is used, yet the alt text is different each time. The image is the coat of arms of the Carouge municipality in the canton Geneva in Switzerland.
</p>

<p>
次の画像は、
補足~iconとして利用されている：
◎
Here it is used as a supplementary icon:
</p>

`img-1^xCode

<p>
次の画像は、
町を表現している~iconとして利用されている：
◎
Here it is used as an icon representing the town:
</p>

`img-2^xCode

<p>
次の画像は、
町についての~textの一部として利用されている：
◎
Here it is used as part of a text on the town:
</p>

`img-3^xCode

<p>
次の画像は、
同様の~textを~supportする仕方として利用されている
— 画像の代替は、
代わりに記述として与えられている：
◎
Here it is used as a way to support a similar text where the description is given as well as, instead of as an alternative to, the image:
</p>

`img-4^xCode

<p>
次の画像は、
物語の一部として利用されている：
◎
Here it is used as part of a story:
</p>

`img-5^xCode

<p>
次の画像は、［
公表~時点では、
何らかの種類の紋章であることしか既知でない
］ため，代用~textは供せない
— `title$a 属性~内には 画像~用の概略的~captionしか供せていない：
◎
Here it is not known at the time of publication what the image will be, only that it will be a coat of arms of some kind, and thus no replacement text can be provided, and instead only a brief caption for the image is provided, in the title attribute:
</p>

`img-6^xCode

<p>
この事例でも、
作者は，本当の代用~textを供する仕方を見出すのが理想だが。
例えば、
当の利用者にそれも供するよう依頼するなど。
代用~textが供されていないと、
画像を視れない人達にとって，文書の利用が困難になる
— 例：
盲目な利用者 ／
接続の帯域幅がごく狭い／
従量課金 ／
~textのみの~web~browserを利用するよう強いられている，
など。
◎
Ideally, the author would find a way to provide real replacement text even in this case, e.g. by asking the previous user. Not providing replacement text makes the document more difficult to use for people who are unable to view images, e.g. blind users, or users or very low-bandwidth connections or who pay by the byte, or users who are forced to use a text-only web browser.
</p>
</div>

<div class="example">
<p>
絵図は同じでも、
適切に代替する~textは，文脈に応じて異なる例：
◎
Here are some more examples showing the same picture used in different contexts, with different appropriate alternate texts each time.
</p>

`img-7^xCode

`img-8^xCode

`img-9^xCode

`img-10^xCode
</div>

			</section>
			<section id="images">
<h4 title="Images">4.8.4. 画像</h4>

				<section id="introduction-3">
<h5 title="Introduction">4.8.4.1. 序論</h5>

◎非規範的

<p>
~HTML内に画像~資源を 1 個だけ画像を埋込むときは、
`img$e 要素と その `src$a 属性を利用する。
◎
To embed an image in HTML, when there is only a single image resource, use the img element and its src attribute.
</p>

<div class="example">
`intro-1^xCode
</div>

<p>
しかしながら、
作者が［
複数の画像~資源を利用して，~UAが それらから選ぶ
］ようにしたいと望む状況もあるかもしれない：
◎
However, there are a number of situations for which the author might wish to use multiple image resources that the user agent can choose from:
</p>

<ul>
	<li>
<p>
環境~特性は、
利用者ごとに異なるかもしれない：
◎
Different users might have different environmental characteristics:
</p>

		<ul>
			<li>
<p>
~screenの物理的~sizeは、
利用者ごとに異なるかもしれない。
◎
The users' physical screen size might be different from one another.
</p>

<div class="example">
<p>
~screenの対角線は、
携帯~電話では 4 ~inchである一方，
~laptopでは 14 ~inchかもしれない。
◎
A mobile phone's screen might be 4 inches diagonally, while a laptop's screen might be 14 inches diagonally.
</p>

`intro-svg-1^dgm
</div>

      
<p class="note">注記：
これが関連するのは、
画像の描画d~sizeが`表示域$の~sizeに依存する場合に限られる。
◎
This is only relevant when an image's rendered size depends on the viewport size.
</p>

			</li>
			<li>

<p>
~screen画素~密度は、
利用者ごとに異なるかもしれない。
◎
The users' screen pixel density might be different from one another.
</p>

<div class="example">

<p>
携帯~電話の~screenの~inchあたりの物理的~画素~数は、
他に比して 3 倍になるかもしれない
— ~screenの物理的~sizeに関わらず。
◎
A mobile phone's screen might have three times as many physical pixels per inch compared to another mobile phone's screen, regardless of their physical screen size.
</p>

`intro-svg-2^dgm
</div>

			</li>
			<li>
<p>
~zoom~levelは、
利用者ごとに異なったり,
同じ利用者でも時間~越しに変化するかもしれない。
◎
The users' zoom level might be different from one another, or might change for a single user over time.
</p>

<p class="example">
利用者は、
より詳細な見かけを取得できるようにするため，
特定0の画像を~zoomして大きくするかもしれない。
◎
A user might zoom in to a particular image to be able to get a more detailed look.
</p>

<p>
~zoom~levelと（前項の）~screen画素~密度の両者とも、
1 `px$css あたりの~screenの物理的~画素~数に影響し得る。
この比は、
通例的に
`機器画素比@
と呼ばれている。
◎
The zoom level and the screen pixel density (the previous point) can both affect the number of physical screen pixels per CSS pixel. This ratio is usually referred to as device-pixel-ratio.
</p>

			</li>
			<li>
<p>
~screen方位は、
利用者ごとに異なったり,
同じ利用者でも時間~越しに変化するかもしれない。
◎
The users' screen orientation might be different from one another, or might change for a single user over time.
</p>

<div class="example">
<p>
~tabletは、
~screenが
縦置き（ `portrait^en ）または横置き（ `landscape^en ）
になるよう，直立に保持されたり，真横に倒されることもある。
◎
A tablet can be held upright or rotated 90 degrees, so that the screen is either "portrait" or "landscape".
</p>

`intro-svg-3^dgm
</div>

			</li>
			<li>
<p>
~networkの［
速度 ／ 待時間 ／ 帯域幅~cost
］は、
利用者ごとに異なったり,
同じ利用者でも時間~越しに変化するかもしれない。
◎
The users' network speed, network latency and bandwidth cost might be different from one another, or might change for a single user over time.
</p>

<p class="example">
利用者の接続は、
仕事場では［
高速, 短い待時間, 定額制
］,
家では［
低速, 短い待時間, 定額制
］,
他所では［
可変速, 長い待時間, 従量制
］かもしれない。
◎
A user might be on a fast, low-latency and constant-cost connection while at work, on a slow, low-latency and constant-cost connection while at home, and on a variable-speed, high-latency and variable-cost connection anywhere else.
</p>

			</li>
		</ul>
	</li>
	<li>
<p>
作者は、
同じ画像~内容を
— 通例的には `表示域$の横幅に依存して —
異なる描画d~sizeで示したいと求めるかもしれない。
これは、
通例的に
`表示域に基づく選定@
と呼ばれている。
◎
Authors might want to show the same image content but with different rendered size depending on, usually, the width of the viewport. This is usually referred to as viewport-based selection.
</p>

<div class="example">

<p>
~web~pageには、
`表示域$の上端に［
その横幅の全体にわたる~banner
］が常にあるかもしれない。
この事例では、
画像の描画d~sizeは，
~screenの物理的~sizeに依存する
（~browser~windowは最大~化されているとする）。
◎
A web page might have a banner at the top that always spans the entire viewport width. In this case, the rendered size of the image depends on the physical size of the screen (assuming a maximised browser window).
</p>

`intro-svg-4^dgm
</div>

<div class="example">

<p>
別の~web~pageは、
画像を何本かの~columnに並べていて，
その本数は、~screenの物理的~sizeが［
小なら 1 本, 中なら 2 本, 大ならば 3 本
］あり、
画像の描画d~sizeは，
各~事例ごとに`表示域$を埋め尽くすため変わるかもしれない。
この事例では、
画像の描画d~sizeは
— ~screenが小さかろうが —
~layoutは~column 1 本のときの方が，
2 本のときに比して`大きくなる^emこともある。
◎
Another web page might have images in columns, with a single column for screens with a small physical size, two columns for screens with medium physical size, and three columns for screens with big physical size, with the images varying in rendered size in each case to fill up the viewport. In this case, the rendered size of an image might be bigger in the one-column layout compared to the two-column layout, despite the screen being smaller.
</p>

`intro-svg-5^dgm
</div>

	</li>
	<li>

<p>
作者は、
画像の描画d~sizeに依存して，異なる画像~内容を示したいと求めるかもしれない。
これは、
通例的に
`~art-direction@
（ `art direction^en ）と呼ばれている。
◎
Authors might want to show different image content depending on the rendered size of the image. This is usually referred to as art direction.
</p>

<div class="example">
<p>
作者は、［
~web~pageが物理的~sizeが広い~screenで視られているとき
（~browser~windowは最大~化されているとする）
］は［
画像の重要部分の周囲に さほど関連しない部分を含めたい
］と望む一方で，［
同じ~web~pageが狭い~screenで視られているとき
］は［
画像の重要部分だけ示したい
］と望むかもしれない。
◎
When a web page is viewed on a screen with a large physical size (assuming a maximised browser window), the author might wish to include some less relevant parts surrounding the critical part of the image. When the same web page is viewed on a screen with a small physical size, the author might wish to show only the critical part of the image.
</p>

`intro-svg-6^dgm
</div>

	</li>
	<li>

<p>
作者は、
同じ画像~内容を［
~UAが~supportする画像~形式に依存して，異なる画像~形式で示したい
］と求めるかもしれない。
これは、
通例的に
`画像~形式に基づく選定@
と呼ばれている。
◎
Authors might want to show the same image content but using different image formats, depending on which image formats the user agent supports. This is usually referred to as image format-based selection.
</p>

<p class="example">
~web~pageには、［
~JPEG, ~WebP, ~JPEG-XR
］などの各種 画像~形式による画像があるかもしれない
— 後の 2 つの方が、
~JPEGに比して圧縮~能が良い。
~supportされる画像~形式は、
~UAごとに異なり，
形式によってはより良い圧縮~比を提供するので、
作者は，~UAが より良い形式を［
~supportするときは それ ／
~supportしないときは ~fallbackとして~JPEG
］を供するよう~serveしたいであろう。
◎
A web page might have some images in the JPEG, WebP and JPEG XR image formats, with the latter two having better compression abilities compared to JPEG. Since different user agents can support different image formats, with some formats offering better compression ratios, the author would like to serve the better formats to user agents that support them, while providing JPEG fallback for user agents that don't.
</p>

	</li>
</ul>

<p>
上に挙げた各 状況は、
互いに排他的ではない。
例えば、［
`機器画素比$ごとに異なる資源を`~art-direction$用に異なる資源も伴うよう組合せる
］ことは，理にかなう。
◎
The above situations are not mutually exclusive. For example, it is reasonable to combine different resources for different device-pixel-ratio with different resources for art direction.
</p>

<p>
これらの問題を~scriptingを利用して解くこともアリだが、
そうすると他の問題も導入される：
◎
While it is possible to solve these problems using scripting, doing so introduces some other problems:
</p>

<ul>
	<li>
~UAには、
~web~pageの読込ngが早く完了するよう，［
~scriptが走る機会cを得る前に，
~HTML~markup内に指定された画像を先取的に~downloadする
］ものもある。
~scriptが~downloadする画像を変更した場合、
~UAは 2 回の~downloadを別々に開始することになり，
~pageの読込ng処理能が悪化しかねない。
◎
Some user agents aggressively download images specified in the HTML markup, before scripts have had a chance to run, so that web pages complete loading sooner. If a script changes which image to download, the user agent will potentially start two separate downloads, which can instead cause worse page loading performance.
</li>
	<li>
作者が［
~HTML~markup内に画像を指定するのを避けて，
~scriptから 1 回だけ~downloadする
］ことにした場合、
上述の二重~download問題は避けれるが，
~scriptingを不能化した利用者に対しては［
画像は まったく~downloadされず，
画像を先取的に~downloadする最適化も不能化される
］ことになる。
◎
If the author avoids specifying any image in the HTML markup and instead instantiates a single download from script, that avoids the double download problem above but then no image will be downloaded at all for users with scripting disabled and the aggressive image downloading optimization will also be disabled.
</li>
</ul>

<p>
このことを念頭に，この仕様は、［
上の問題に宣言的な方式で取組む特能
］をいくつか導入する。
◎
With this in mind, this specification introduces a number of features to address the above problems in a declarative manner.
</p>
<dl>
	<dt>
画像の描画d~sizeは固定されているときの`機器画素比$に基づく選定：
◎
Device-pixel-ratio-based selection when the rendered size of the image is fixed
</dt>
	<dd>
<p>
`img$e 要素~上の
`src$a, `srcset$a
属性に `x^v 記述子を利用すれば、
~sizeだけ異なる複数の画像を供せる
（小さい方の画像は 大きい方の画像を縮小したもの）。
◎
The src and srcset attributes on the img element can be used, using the x descriptor, to provide multiple images that only vary in their size (the smaller image is a scaled-down version of the bigger image).
</p>

<p class="note">注記：
`x^v 記述子は、
画像の描画d~sizeが`表示域$の横幅に依存するとき（`表示域に基づく選定$）は適切でないが，
`~art-direction$と併用できる。
◎
The x descriptor is not appropriate when the rendered size of the image depends on the viewport width (viewport-based selection), but can be used together with art direction.
</p>
	</dd>
	<dd class="example">
`intro-2^xCode

<p>
~UAは、
所与の資源のどれかを，利用者の［
~screenの画素~密度,
~zoom~level,
場合によっては利用者の~network条件などの他の要因
］に依存して選べる。
◎
The user agent can choose any of the given resources depending on the user's screen's pixel density, zoom level, and possibly other factors such as the user's network conditions.
</p>

<p>
`srcset$a 属性を解さない旧~UAとの後方-互換性のため、
`img$e 要素の `src$a 属性~内にも 1 個の~URLが指定されている。
これにより、
旧~UAにて表示されるときでも有用になる
（その解像度は、たぶん利用者の好みより低くなるであろうが）。
`src$a 属性は、
新しい~UAに対しても，資源~選定に関与する
— その値に記述子 `1x^v を伴わせたものが `srcset$a にも指定されていたかのように。
◎
For backwards compatibility with older user agents that don't yet understand the srcset attribute, one of the URLs is specified in the img element's src attribute. This will result in something useful (though perhaps lower-resolution than the user would like) being displayed even in older user agents. For new user agents, the src attribute participates in the resource selection, as if it was specified in srcset with a 1x descriptor.
</p>

<p>
［
`width$a,
`height$a
］属性~内には、
画像の描画d~sizeが与えられている
— それは、［
画像を~downloadする前に，それ用の空間を割振る
］ことを~UAに許容する。
◎
The image's rendered size is given in the width and height attributes, which allows the user agent to allocate space for the image before it is downloaded.
</p>
	</dd>

	<dt>
`表示域に基づく選定$
◎
Viewport-based selection
</dt>
	<dd>
`srcset$a, `sizes$a
属性と `w^v 記述子を利用すれば、
~sizeだけ異なる複数の画像を供せる
（小さい方の画像は 大きい方の画像を縮小したもの）。
◎
The srcset and sizes attributes can be used, using the w descriptor, to provide multiple images that only vary in their size (the smaller image is a scaled-down version of the bigger image).
</dd>
	<dd class="example">
<p>
この例では、
~banner画像は，`表示域$の横幅~全体を占める
（適切な~CSSを利用して）。
◎
In this example, a banner image takes up the entire viewport width (using appropriate CSS).
</p>

`intro-3^xCode

<p>
~UAは、
指定された `w^v 記述子と `sizes$a 属性~内に指定された描画d~sizeから，
各~画像の実効画素~密度を計算することになる。
次に~UAは、
所与の資源のどれかを，利用者の［
~screenの画素~密度,
~zoom~level,
場合によっては利用者の~network条件などの他の要因
］に依存して選べる。
◎
The user agent will calculate the effective pixel density of each image from the specified w descriptors and the specified rendered size in the sizes attribute. It can then choose any of the given resources depending on the user's screen's pixel density, zoom level, and possibly other factors such as the user's network conditions.
</p>

<p>
利用者の~screen幅が 320 `px$css の場合、
これは
`wolf-400.jpg 1.25x, wolf-800.jpg 2.5x, wolf-1600.jpg 5x^v
を指定することに等価になる。
他方，~screen幅が 1200 `px$css の場合、
これは
`wolf-400.jpg 0.33x, wolf-800.jpg 0.67x, wolf-1600.jpg 1.33x^v
を指定することに等価になる。
`w^v 記述子と `sizes$a 属性を利用することにより、
利用者の機器の大きさに関わらず，
~UAは~downloadする正しい画像~sourceを選べる。
◎
If the user's screen is 320 CSS pixels wide, this is equivalent to specifying wolf-400.jpg 1.25x, wolf-800.jpg 2.5x, wolf-1600.jpg 5x. On the other hand, if the user's screen is 1200 CSS pixels wide, this is equivalent to specifying wolf-400.jpg 0.33x, wolf-800.jpg 0.67x, wolf-1600.jpg 1.33x. By using the w descriptors and the sizes attribute, the user agent can choose the correct image source to download regardless of how large the user's device is.
</p>

<p>
後方-互換性を得るため、
~URLのうち 1 つが `img$e 要素の`src$a 属性~内に指定される。
新しい~UAにおいては、
`srcset$a 属性が `w^v 記述子を利用しているときは，
`src$a 属性は無視される。
◎
For backwards compatibility, one of the URLs is specified in the img element's src attribute. In new user agents, the src attribute is ignored when the srcset attribute uses w descriptors.
</p>
	</dd>
	<dd class="example">
<p>
この例の~web~pageの~layoutは、
`表示域$の横幅に依存して 3 種に分かれる。
一連の画像は、
~layout幅が［
狭いときは 1 本,
中程度のときは 2 本,
広いときは 3 本
］の~columnに並べられ
（各~画像の横幅は、順に，およそ 100%, 50%, 33% ）、
それに加え~page~marginがある。
これらの~layoutは、
`表示域$の幅 `30em^v, `50em^v を境目に分かたれる。
◎
In this example, the web page has three layouts depending on the width of the viewport. The narrow layout has one column of images (the width of each image is about 100%), the middle layout has two columns of images (the width of each image is about 50%), and the widest layout has three columns of images, and some page margin (the width of each image is about 33%). It breaks between these layouts when the viewport is 30em wide and 50em wide, respectively.
</p>

`intro-4^xCode

<p>
`sizes$a 属性は、
~layoutの境目を［
`30em^v, `50em^v
］の所に設定しておき、
これらの境目で分けられる順に，画像~sizeは［
`100vw^v, `50vw^v, `calc(33vw - 100px)^v
］になるよう宣言する。
これらの~sizeを［
~CSSで指定する実際の画像~横幅
］に正確に合致させることは、
必要yでない。
◎
The sizes attribute sets up the layout breakpoints at 30em and 50em, and declares the image sizes between these breakpoints to be 100vw, 50vw, or calc(33vw - 100px). These sizes do not necessarily have to match up exactly with the actual image width as specified in the CSS.
</p>

<p>
~UAは、［
`media-condition$t （丸括弧の中）が真に評価される最初の~item
］を利用して，あるいは［
すべてが偽に評価された場合は，最後の~item
（ `calc(33vw - 100px)^v ）
］を利用して，
`sizes$a 属性から横幅を選ぶことになる。
◎
The user agent will pick a width from the sizes attribute, using the first item with a &lt;media-condition&gt; (the part in parentheses) that evaluates to true, or using the last item (calc(33vw - 100px)) if they all evaluate to false.
</p>

<p>
例えば，`表示域$の横幅 %横幅 が `29em^v の場合、
`(max-width: 30em)^v
は 真に評価され，
`100vw^v が利用されるので、
画像~sizeは，資源~選定の目的においては `29em^v になる。
%横幅 が `32em^v であった場合、
`(max-width: 30em)^v
は偽に評価されるが,
`(max-width: 50em)^v
は真に評価され，
`50vw^v が利用されるので、
画像~sizeは，
資源~選定の目的においては `16em^v になる（ %横幅 の半分）。
~layoutが異なることにより、
`表示域$が少しだけ幅広になったときの方が，小さな画像になることに注意。
◎
For example, if the viewport width is 29em, then (max-width: 30em) evaluates to true and 100vw is used, so the image size, for the purpose of resource selection, is 29em. If the viewport width is instead 32em, then (max-width: 30em) evaluates to false, but (max-width: 50em) evaluates to true and 50vw is used, so the image size, for the purpose of resource selection, is 16em (half the viewport width). Notice that the slightly wider viewport results in a smaller image because of the different layout.
</p>

<p>
それから，~UAは、
実効~画素~密度を計算して，前の例と同様に適切な資源を選べれるようになる。
◎
The user agent can then calculate the effective pixel density and choose an appropriate resource similarly to the previous example.
</p>
	</dd>
	<dd class="example">
<p>
この例は、
前の例と同じだが，当の画像は後回し（ `Lazy$st ）に読込まれる。
この事例では、
`sizes$a 属性に~keyword `~auto0$v を利用できる
— ~UAは、
`~source~size$用に `width$a 属性（または~CSSにて指定された横幅）を利用することになる。
◎
This example is the same as the previous example, but the image is lazy-loaded. In this case, the sizes attribute can use the auto keyword, and the user agent will use the width attribute (or the width specified in CSS) for the source size.
</p>

`intro-5^xCode

<p>
~keyword `~auto0$v を~supportしない旧来の~UAとの後方-互換性を良くしたいと欲する場合、
~fallback~sizeを指定できる。
◎
For better backwards-compatibility with legacy user agents that don't support the auto keyword, fallback sizes can be specified if desired.
</p>

`intro-6^xCode

	</dd>

	<dt>`~art-direction$に基づく選定
◎
Art direction-based selection
</dt>
	<dd>
［
`picture$e 要素, `source$e 要素
］を `media$aS 属性と併用すれば、
画像~内容が変わるような複数の画像を供せる
（一例として，小さい方の画像は 大きい方の画像を切り抜いたもの）。
◎
The picture element and the source element, together with the media attribute, can be used to provide multiple images that vary the image content (for instance the smaller image might be a cropped version of the bigger image).
</dd>
	<dd class="example">
`intro-7^xCode

<p>
~UAは、［
`picture$e 要素~内の `source$e 要素
］のうち［
その `media$aS 属性~内の媒体~queryが環境に合致するもの
］のうち最初のものを選んだ上で，［
その `srcset$aS 属性から適切な~URLを選ぶ
］ことになる。
◎
The user agent will choose the first source element for which the media query in the media attribute matches, and then choose an appropriate URL from its srcset attribute.
</p>

<p>
画像の描画d~sizeは、
どの資源が選ばれたかに依存して変わる。
~CSSを利用すれば、
~UAが画像を~downloadする前に利用できる寸法を指定できる。
◎
The rendered size of the image varies depending on which resource is chosen. To specify dimensions that the user agent can use before having downloaded the image, CSS can be used.
</p>

<pre class="lang-css">
img { width: 300px; height: 300px }
@media (min-width: 32em) { img { width: 500px; height:300px } }
@media (min-width: 45em) { img { width: 700px; height:400px } }
</pre>
	</dd>
	<dd class="example">
<p>
次の例では、
`~art-direction$と`機器画素比$に基づく選定を組合せる。
`表示域$の半分を占める~bannerは、
~screen幅が［
広いとき, 狭いとき
］の 2 種で供される。
◎
This example combines art direction- and device-pixel-ratio-based selection. A banner that takes half the viewport is provided in two versions, one for wide screens and one for narrow screens.
</p>

`intro-8^xCode
	</dd>

	<dt>`画像~形式に基づく選定$
◎
Image format-based selection
</dt>
	<dd>
`source$e 要素に `type$aS 属性を利用すれば、
異なる形式による複数の画像を供せる。
◎
The type attribute on the source element can be used to provide multiple images in different formats.
</dd>
	<dd class="example">
`intro-9^xCode
<p>
この例では、
~UAは，［
自身が~supportする~MIME型を伴う `type$aS 属性を有する
］ような最初の~sourceを選ぶことになる。
~UAが~WebP画像を~supportするなら 1 個目の `source$e 要素が選ばれ，
そうでないが ~JPEG-XR画像を~supportするなら 2 個目の `source$e 要素が選ばれ，
両~形式とも~supportしなければ `img$e 要素が選ばれることになる。
◎
In this example, the user agent will choose the first source that has a type attribute with a supported MIME type. If the user agent supports WebP images, the first source element will be chosen. If not, but the user agent does support JPEG XR images, the second source element will be chosen. If neither of those formats are supported, the img element will be chosen.
</p>
	</dd>
</dl>

					<section id="adaptive-images">
<h5 title="Adaptive images">4.8.4.1.1. 順応的な画像</h5>

◎非規範的

<p>
~CSSと媒体~queryを利用すれば、［
利用者の環境に動的に順応する
］ような［
~graphicな~page~layout
］を構築できる
— 特に，異なる`表示域$寸法と画素~密度に応じて。
しかしながら、
~CSSは，内容に対しては助けにならない
— その代わりとして、
`img$e 要素の `srcset$a 属性, および `picture$e 要素がある。
この節では、
これらの特能を利用する方法を示す見本~事例を順に見ていく。
◎
CSS and media queries can be used to construct graphical page layouts that adapt dynamically to the user's environment, in particular to different viewport dimensions and pixel densities. For content, however, CSS does not help; instead, we have the img element's srcset attribute and the picture element. This section walks through a sample case showing how to use these features.
</p>

<p>
~screenが幅広なときは（ 600 `px$css より幅広）［
300×150 の画像 `a-rectangle.png^v
］が利用され，
~screenがより狭いときは（ 600 `px$css 以下）［
より小さい 100×100 の画像 `a-square.png^v
］が利用される状況を考える。
このための~markupは、
次の様な見かけになるであろう：
◎
Consider a situation where on wide screens (wider than 600 CSS pixels) a 300×150 image named a-rectangle.png is to be used, but on smaller screens (600 CSS pixels and less), a smaller 100×100 image called a-square.png is to be used. The markup for this would look like this:
</p>

`intro-10^xCode

<p class="note">注記：
`alt$a 属性~内に何を置くかについての詳細は、
`§ 画像~用の代替として動作する~textを供するときの要件$を見よ。
◎
For details on what to put in the alt attribute, see the Requirements for providing text to act as an alternative for images section.
</p>

<p>
ここでの問題は、
~UAにとっては［
当の画像を読込んでいる間，画像に利用する寸法を知れるとは限らない
］ことである。
~CSSと~CSS媒体~queryを利用して寸法を供すれば、
~pageを読込んでいる間に~layoutが何回も~flowし直されるのを避けれる：
◎
The problem with this is that the user agent does not necessarily know what dimensions to use for the image when the image is loading. To avoid the layout having to be reflowed multiple times as the page is loading, CSS and CSS media queries can be used to provide the dimensions:
</p>

`intro-11^xCode

<p>
代替として，
`width$a, `height$a
属性を利用すれば、
旧来の~UA用にも横幅と縦幅を供せる
— ~CSSは `picture$e を~supportする~UAにだけ利用することにして：
◎
Alternatively, the width and height attributes can be used to provide the width and height for legacy user agents, using CSS just for the user agents that support picture:
</p>

`intro-12^xCode

<hr>

<p>
`img$e 要素に利用されている `src$a 属性は、［
`picture$e 要素を~supportしない旧来の~UA
］に対しては，利用する画像の~URLを与える。
これは、
どの画像を `src$a 属性に供するかの問いに至る。
◎
The img element is used with the src attribute, which gives the URL of the image to use for legacy user agents that do not support the picture element. This leads to a question of which image to provide in the src attribute.
</p>

<p>
作者が 旧来の~UAでは最~大の画像を求める場合、
~markupは，次のようにも記せる：
◎
If the author wants the biggest image in legacy user agents, the markup could be as follows:
</p>

`intro-13^xCode

<p>
しかしながら，旧来の携帯~機~UAの方が重要な場合、
3 個の画像すべてを `source$e 要素~内に挙げれば
`src$a 属性を まるごと上書きできる：
◎
However, if legacy mobile user agents are more important, one can list all three images in the source elements, overriding the src attribute entirely.
</p>

`intro-14^xCode

<p>
この場合の `src$a 属性は，［
実際に `picture$e を~supportする~UAからは まるごと無視される
］ので、
どの画像であれ，その大きさに関わらず既定として与えれる：
◎
Since at this point the src attribute is actually being ignored entirely by picture-supporting user agents, the src attribute can default to any image, including one that is neither the smallest nor biggest:
</p>

`intro-15^xCode

<hr>

<p>
上では，最大~寸法（`表示域$のそれ）を与えるため、
画像に意図される `max-width^css ~media特能が利用されている。
代わりに `min-width^css を利用することもアリである。
◎
Above the max-width media feature is used, giving the maximum (viewport) dimensions that an image is intended for. It is also possible to use min-width instead.
</p>

`intro-16^xCode

					</section>
				</section>
				<section id="attributes-common-to-source-and-img-elements">
<h5 title="Attributes common to source, img, and link elements">4.8.4.2. `source^e, `img^e, `link^e 要素に共通な属性</h5>

					<section id="srcset-attributes">
<h5 title="Srcset attributes">4.8.4.2.1. ~srcset属性</h5>

<p>
`~srcset属性@
には、
この節に定義される要件が課される。
◎
A srcset attribute is an attribute with requirements defined in this section.
</p>

<p class="trans-note">【
この “~srcset属性” は、［
`source^e 要素の `srcset$aS 属性,
`img^e 要素の `srcset$a 属性,
`link^e 要素の `imagesrcset$aL 属性
］の総称を表す。
】</p>

<div class="p">
<p>
この属性に指定する値は、
次を満たさなければナラナイ：
</p>

<ul>
	<li>
`002C^U `,^smb で分離された
1 個~以上の`画像~候補~文字列$からなる。
</li>
	<li>
値を成す ある`画像~候補~文字列$が［
その~URLの後に記述子も`~ASCII空白$も包含しない
］ならば、
その次の`画像~候補~文字列$の最初の文字は`~ASCII空白$である。
</li>
</ul>

◎
If present, its value must consist of one or more image candidate strings, each separated from the next by a U+002C COMMA character (,). If an image candidate string contains no descriptors and no ASCII whitespace after the URL, the following image candidate string, if there is one, must begin with one or more ASCII whitespace.
</div>

<p>
各
`画像~候補~文字列@
は、
挙げられる順に，次に挙げる成分からなる
— この~listの他にも，その下に述べる制約がある：
◎
An image candidate string consists of the following components, in order, with the further restrictions described below this list:
</p>

<ol>
	<li>
0 個~以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
	<li>
1 個の`妥当かつ空でない~URL$であって，
先頭, 末尾の両~文字とも `002C^U `,^smb
でないものであって、［
対話的でも多pageでもなく, ~scriptも伴わない画像~資源
］（~animate化されていてもよい）
を参照しているもの。
◎
A valid non-empty URL that does not start or end with a U+002C COMMA character (,), referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted.
</li>
	<li>
0 個~以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
	<li>
<p>
次のうち，いずれか 1 つ：
◎
Zero or one of the following:
</p>

		<ul>
			<li>
空~文字列
</li>
			<li>
<p>
`横幅~記述子@
を与える，次の並び：
</p>
				<ol>
					<li>
1 個の`~ASCII空白$
</li>
					<li>
1 個の`妥当な負でない整数$であって、
0 より大きい数を与えるもの
— これは
`横幅~値@
を表現する
</li>
					<li>
1 個の文字 `0077^U `w^smb
</li>
				</ol>
◎
A width descriptor, consisting of: ASCII whitespace, a valid non-negative integer giving a number greater than zero representing the width descriptor value, and a U+0077 LATIN SMALL LETTER W character.
</li>
			<li>
<p>
`画素~密度~記述子@
を与える，次の並び：
</p>
				<ol>
					<li>
1 個の`~ASCII空白$
</li>
					<li>
1 個の`妥当な浮動小数点数$であって、
0 より大きい数を与えるもの
— これは
`密度~値@
を表現する
</li>
					<li>
1 個の文字 `0078^U `x^smb
</li>
				</ol>
◎
A pixel density descriptor, consisting of: ASCII whitespace, a valid floating-point number giving a number greater than zero representing the pixel density descriptor value, and a U+0078 LATIN SMALL LETTER X character.
</li>
		</ul>
<p class="trans-note">【
これらの記述子は、
文脈に応じて，そのような文字列を指すこともあれば, 抽象的な値~型を意味することもある。
】</p>

	</li>
	<li>
0 個~以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
</ol>

<div class="p">
<p>
同じ要素の 複数の`画像~候補~文字列$においては：
</p>
<ul>
	<li>
互いの`横幅~値$が同じになってはナラナイ。
</li>
	<li>
互いの`密度~値$が同じになってはナラナイ。
</li>
	<li>
この要件の目的においては、
記述子を伴わない`画像~候補~文字列$は，記述子 `1x^v を伴う`画像~候補~文字列$と等価とする。
</li>
</ul>
◎
There must not be an image candidate string for an element that has the same width descriptor value as another image candidate string's width descriptor value for the same element.
◎
There must not be an image candidate string for an element that has the same pixel density descriptor value as another image candidate string's pixel density descriptor value for the same element. For the purpose of this requirement, an image candidate string with no descriptors is equivalent to an image candidate string with a 1x descriptor.
</div>

<p>
要素~用の ある`画像~候補~文字列$に`横幅~記述子$を指定している場合、
他のすべての`画像~候補~文字列$にも`横幅~記述子$を指定しなければナラナイ。
◎
If an image candidate string for an element has the width descriptor specified, all other image candidate strings for that element must also have the width descriptor specified.
</p>

<p>
`画像~候補~文字列$の`横幅~記述子$にて指定される`横幅~値$は、
`画像~候補~文字列$の~URLで与えられる資源に`生来な横幅$がある場合には，
それに合致させるモノトスル。
◎
The specified width in an image candidate string's width descriptor must match the natural width in the resource given by the image candidate string's URL, if it has a natural width.
</p>

<p>
要素が`~sizes属性$を有する場合、
その要素~用の どの`画像~候補~文字列$にも`横幅~記述子$を指定しなければナラナイ。
◎
If an element has a sizes attribute present, all image candidate strings for that element must have the width descriptor specified.
</p>

					</section>
					<section id="sizes-attributes">
<h5 title="Sizes attributes">4.8.4.2.2. ~sizes属性</h5>

<p>
`~sizes属性@
には、
この節に定義される要件が課される。
◎
A sizes attribute is an attribute with requirements defined in this section.
</p>

<p class="trans-note">【
この “~sizes属性” は、［
`source^e 要素の `sizes$aS 属性,
`img^e 要素の `sizes$a 属性,
`link^e 要素の `imagesizes$aL 属性
］の総称を表す。
】</p>

<p>
指定する値は、
`妥当な~source~size~list$でなければナラナイ。
◎
If present, the value must be a valid source size list.
</p>

<p>
`妥当な~source~size~list@
は、
次の文法に合致する文字列とする：
`CSSVALUES$r
`MQ$r
◎
A valid source size list is a string that matches the following grammar: [CSSVALUES] [MQ]
</p>

<pre class="prod">
`source-size-list@t
	= `source-size$t#? , `source-size-value$t
`source-size@t
	= `media-condition$t `source-size-value$t
	| `~auto0$v
`source-size-value@t
	= `length$t
	| `~auto0$v
</pre>

<p>
`source-size-value$t として与える `length$t は、
次を満たさなければナラナイ
⇒
［
負でない
］~AND［
`~math関数$以外の`~CSS関数$を利用していない
］
◎
A &lt;source-size-value&gt; that is a &lt;length&gt; must not be negative, and must not use CSS functions other than the math functions.
</p>

<p>
~keyword
`~auto0@v
は、
`~sizes属性を構文解析する$ことにより算出される横幅を与える。
在る場合、
~AND↓ が満たされなければナラナイ：
◎
The keyword auto is a width that is computed in parse a sizes attribute. If present,＼
</p>
<ul>
	<li>
`~auto0$v は `source-size-list$t 値 %~list を成す最初の~entryである
◎
it must be the first entry＼
</li>
	<li>
`~ASCII小文字~化する$( %~list )
の結果は次を満たす
⇒
［
`auto^l に等しい
］~OR［
`auto,^l で開始している
］
◎
and the entire &lt;source-size-list&gt; value must either be the string "auto" (ASCII case-insensitive) or start with the string "auto," (ASCII case-insensitive).
</li>
</ul>

<p class="note">注記：
`~auto0$v は、
当の画像の読込ngを
（［
`画像~dataを更新する$／ `環境における変化に反応する$
］~algoで）
起動した `img$e 要素が［
`自動-~sizeを許容して$いて，`具現化されて$いる
］ならば，要素の`具象-~obj~size$を成す横幅になる。
他の場合、
`~auto0$v 値は無視され，
その次の`~source~size$が（もし在れば）代わりに利用される。
◎
If the img element that initiated the image loading (with the update the image data or react to environment changes algorithms) allows auto-sizes and is being rendered, then auto is the concrete object size width. Otherwise, the auto value is ignored and the next source size is used instead, if any.
</p>

<div>
<p>
`img$e 要素の `sizes$a 属性には、
当の要素が`自動-~sizeを許容して$いるならば，
~keyword `~auto0$v を指定してもヨイ
— 他の場合、
指定してはナラナイ。
</p>

<p>
`source$e 要素の `sizes$aS 属性には、
当の要素に後続する同胞として［
`自動-~sizeを許容して$いる `img$e 要素が在る
］ならば，
~keyword `~auto0$v を指定してもヨイ
— 他の場合、
指定してはナラナイ。
</p>

◎
The auto keyword may be specified in the sizes attribute of source elements and sizes attribute of img elements, if the following conditions are met. Otherwise, auto must not be specified.
• The element is a source element with a following sibling img element.
• The element is an img element.
• The img element referenced in either condition above allows auto-sizes.
</div>

<p class="note">注記：
加えて、［［
`width$a, `height$a
］属性を利用して，あるいは~CSSで
］寸法を指定することが，強く奨励される。
寸法が指定されない下では、
当の画像は，寸法 300×150 で描画される見込みが高い
— `sizes="auto"^c は、
`§ 具現化＠~HTMLrendering#img-contain-size$
においては
<code class="css">`contain-intrinsic-size$p: `300px 150px^v;</code>
を含意するので。
◎
In addition, it is strongly encouraged to specify dimensions using the width and height attributes or with CSS. Without specified dimensions, the image will likely render with 300x150 dimensions because sizes="auto" implies contain-intrinsic-size: 300px 150px in the Rendering section.
</p>

<p>
`source-size-value$t は、
画像に意図される~layout横幅を与える。
作者は、
`media-condition$t で環境ごとに異なる横幅を指定できる。
◎
The &lt;source-size-value&gt; gives the intended layout width of the image. The author can specify different widths for different environments with &lt;media-condition&gt;s.
</p>

<p class="note">注記：
`source-size-value$t においては、
百分率は許容されない
— 何に相対的になるかについての混同を避けるため。
`表示域$の横幅に相対的な~sizeには、
`vw$css 単位を利用できる。
◎
Percentages are not allowed in a &lt;source-size-value&gt;, to avoid confusion about what it would be relative to. The 'vw' unit can be used for sizes relative to the viewport width.
</p>

					</section>
				</section>
				<section id="images-processing-model">
<h5 title="Processing model">4.8.4.3. 処理~model</h5>

<p>
各 `img$e 要素は、
次に挙げるものを持つ：
◎
An img element has a current request and a pending request.＼
</p>
<ul>
	<li>
`現在の要請@
⇒
初期~時には新たな`画像~要請$に設定される。
◎
The current request is initially set to a new image request.＼
</li>
	<li>
`処理待ち要請@
⇒
ある`画像~要請$／ ~NULL
— 初期~時は ~NULL とする。
◎
The pending request is initially set to null.
</li>
</ul>

<p>
各
`画像~要請@
は、
次に挙げるものを持つ：
◎
An image request has a state, current URL, and image data.
</p>
<ul>
	<li>
<p>
`状態@
⇒
次に挙げるいずれか
— 初期~時は `不可用$st とする：
◎
An image request's state is one of the following:
</p>
		<ul>
			<li>
`不可用@st
⇒
~UAは 画像~dataをある程度は得しているかもしれないが，
画像の寸法を取得するまで十分に復号されていない。
◎
Unavailable
• The user agent hasn't obtained any image data, or has obtained some or all of the image data but hasn't yet decoded enough of the image to get the image dimensions.
</li>
			<li>
`部分的に可用@st
⇒
~UAは 画像~dataの一部を得していて，少なくとも画像の寸法は可用である。
◎
Partially available
• The user agent has obtained some of the image data and at least the image dimensions are available.
</li>
			<li>
`完全に可用@st
⇒
~UAは すべての画像~dataを得していて，少なくとも画像の寸法は可用である。
◎
Completely available
• The user agent has obtained all of the image data and at least the image dimensions are available.
</li>
			<li>
`壊en@st
⇒
~UAは，できる限りすべての画像~dataを得したが、
画像の寸法を取得するに十分に画像を復号できなかった
（例：
画像は破損している ／
形式は~supportされてない ／
まったく~dataを得せなかった）。
◎
Broken
• The user agent has obtained all of the image data that it can, but it cannot even decode the image enough to get the image dimensions (e.g. the image is corrupted, or the format is not supported, or no data could be obtained).
</li>
		</ul>
	</li>
	<li>
`現在の~URL@
⇒
初期~時は空~文字列とする。
◎
An image request's current URL is initially the empty string.
</li>
	<li>
`画像~data@
⇒
復号された画像~data。
初期~時は ε （なし）とする。
◎
An image request's image data is the decoded image data.
</li>
</ul>

<p>
`img$e 要素は、
次を満たすならば
`画像は可用@
であるとされる
⇒
その`現在の要請$の`状態$ ~IN  { `部分的に可用$st, `完全に可用$st }
◎
When an image request's state is either partially available or completely available, the image request is said to be available.
</p>

<p>
`img$e 要素は、
次を満たすならば
`全部的に復号-可能@
であるとされる
⇒
［
その`現在の要請$の`状態$ ~EQ `完全に可用$st
］~AND［
~UAは その~media~dataを~errorなしに復号できる
］
◎
When an img element's current request's state is completely available and the user agent can decode the media data without errors, then the img element is said to be fully decodable.
◎
↑An image request's state is initially unavailable.
</p>

<div class="p">
<p>
`img$e 要素は、
その`画像は可用$であるならば，次のような`塗り~source$を供する：
</p>
<ul>
	<li>
横幅, 縦幅は、
画像の`密度~補正-済み生来な~size$
（横幅, 縦幅 それぞれに対し，もしあれば）
</li>
	<li>
外観は、
画像の生来な外観
【`内在的な外観＠~CSSIMAGE4#paint-sources$】
</li>
</ul>
◎
When an img element's current request is available, the img element provides a paint source whose width is the image's density-corrected natural width (if any), whose height is the image's density-corrected natural height (if any), and whose appearance is the natural appearance of the image.
</div>

<hr>

<p>
次を満たす `img$e 要素は、
`~srcsetまたは~pictureを利用して@
いるとされる
⇒
［
`srcset$a 属性を有する
］~OR［
親は `picture$e 要素である
］
◎
An img element is said to use srcset or picture if it has a srcset attribute specified or if it has a parent that is a picture element.
</p>

<hr>

<p>
各 `img$e 要素は、
次に挙げるものも持つ：
◎
↓</p>
<ul>
	<li>
`最後に選定された~source@
⇒
初期~時は ε （なし）とする。
◎
Each img element has a last selected source, which must initially be null.
</li>
	<li>
`現在の画素~密度@
⇒
初期~時は 1 とする。
◎
Each image request has a current pixel density, which must initially be 1.
</li>
	<li>
`選好される密度~補正-済み寸法@
⇒
~NULL または
( 横幅, 縦幅 ) からなる構造体。
初期~時は ~NULL とする。
◎
Each image request has preferred density-corrected dimensions, which is either a struct consisting of a width and a height or is null. It must initially be null.
</li>
</ul>

<p class="trans-note">【
［
`現在の画素~密度$／`選好される密度~補正-済み寸法$
］は、
原文では各 `画像~要請$が持つものとして定義されているが，
実際には `img^e 要素の`現在の要請$のそれしか参照されていないので、
この訳では `img^e 要素が直に持つように単純~化している。
】</p>

<div class="algo">
<p>
`img$e 要素 %img の
`密度~補正-済み生来な~size@
を決定する
~algoは：
◎
To determine the density-corrected natural width and height of an img element img:
</p>
<ol>
	<li>
<p>
%寸法 ~LET %img の`選好される密度~補正-済み寸法$
◎
Let dim be img's current request's preferred density-corrected dimensions.
</p>

<p class="note">注記：
`選好される密度~補正-済み寸法$は、
`画像を呈示~用に準備する$~algo内で
当の画像~内の~meta情報に基づいて設定される。
◎
The preferred density-corrected dimensions are set in the prepare an image for presentation algorithm based on meta information in the image.
</p>
	</li>
	<li>
<p>
~IF［
%寸法 ~EQ ~NULL
］：
</p>
		<ol>
			<li>
%寸法 の横幅 ~SET %img の`生来な横幅$は［
在るならば それ／
無いならば 0†
］
</li>
			<li>
%寸法 の縦幅 ~SET %img の`生来な縦幅$は［
在るならば それ／
無いならば 0†
］
</li>
		</ol>
<p class="trans-note">【†
原文は、［
生来な横幅／生来な縦幅
］が無い場合の取扱いを述べていない。
一方で，`密度~補正-済み生来な~size$を参照している他所においては、
それが無い場合の取扱いを述べており，その場合は 0 と見なすものと指定されているので、
その取扱いをここに集約する。
】</p>
◎
If dim is null, set dim to img's natural dimensions.
</li>
	<li>
%寸法 の横幅 ~SET %寸法 の横幅 ~DIV %img の`現在の画素~密度$
◎
Set dim's width to dim's width divided by img's current request's current pixel density.
</li>
	<li>
%寸法 の縦幅 ~SET %寸法 の縦幅 ~DIV %img の`現在の画素~密度$
◎
Set dim's height to dim's height divided by img's current request's current pixel density.
</li>
	<li>
~RET %寸法
◎
Return dim.
</li>
</ol>
</div>

<p class="example">
例えば、［
`現在の画素~密度$ ~EQ 3.125
］の場合、
1 `in$css （ ~EQ 96 `px$css ）あたりの機器~画素~数は 300 （~EQ 96 ~MUL 3.125 ）になることを意味する。
したがって、
画像~dataの ( 横幅, 縦幅 ) が ( 300, 600 ) ならば，
その`密度~補正-済み生来な~size$は
( 96 `px$css, 192 `px$css )
になる。
◎
For example, if the current pixel density is 3.125, that means that there are 300 device pixels per CSS inch, and thus if the image data is 300x600, it has density-corrected natural width and height of 96 CSS pixels by 192 CSS pixels.
</p>

<p>
各［
`img$e ／ `link$e
］要素には、
`~source集合$が結付けられる。
◎
All img and link elements are associated with a source set.
</p>

<p>
`~source集合@
は、［
0 個~以上の`画像~source$たちが成す有順序~集合
］, および
`~source~size$からなる：
◎
A source set is an ordered set of zero or more image sources and a source size.
</p>

<ul>
	<li>
<p>
各
`画像~source@
は、
次に挙げるものからなる：
</p>
			<ul>
				<li>
<p>
`~URL文字列@iS
⇒
画像~資源の`~URL$を与える文字列。
</p>

<p class="trans-note">【
原文では単に`~URL$と記されているが（それは構造体である）、
実際には文字列なので，この訳では このように言い換える。
】</p>
				</li>
				<li>
<p>
`記述子@iS
⇒
次に挙げるいずれか
— 初期~時は ε とする
⇒＃
ε（なし）／
`横幅~記述子$／
`画素~密度~記述子$
</p>

<p class="trans-note">【
語 “記述子” は、
簡便に総称するために，この訳に導入した用語である。
】</p>
				</li>
			</ul>
◎
An image source is a URL, and optionally either a pixel density descriptor, or a width descriptor.
</li>
	<li>
`~source~size@
は， `source-size-value$t で与えられる。
その単位が`表示域$に相対的であるときは，［
`img$e 要素の`~node文書$の`表示域$
］に相対的に解釈するモノトスル。
他の単位は、
`Media Queries^cite `MQ$r に従って解釈するモノトスル。
◎
A source size is a &lt;source-size-value&gt;. When a source size has a unit relative to the viewport, it must be interpreted relative to the img element's node document's viewport. Other units must be interpreted the same as in Media Queries. [MQ]
</li>
</ul>

<hr>

<p>
この節における各~algoにおける
`構文解析-~error@
は、
入力と要件との間の 致命的でない不一致を指示する。
~UAには、
何らかの方法で`構文解析-~error$を公開することが奨励される。
◎
A parse error for algorithms in this section indicates a non-fatal mismatch between input and requirements. User agents are encouraged to expose parse errors somehow.
</p>

<hr>

<p>
画像が成功裡に~fetchされたかどうか
（例：その応答~状態sは`~ok状態s$であったかどうか）
は、［
画像の型 ／ 画像は妥当であるかどうか
］を決定するときには，無視するモノトスル。
◎
Whether the image is fetched successfully or not (e.g. whether the response status was an ok status) must be ignored when determining the image's type and whether it is a valid image.
</p>

<p class="note">注記：
これにより，~serverは、
画像を~error応答で返して，それらを表示させれるようになる。
◎
This allows servers to return images with error responses, and have them displayed.
</p>

<p id="img-determine-type">
~UAは、
画像の型を決定するときは，
`画像を特定的に~sniffするための規則$を適用するべきである
— その
`公式的な型^i
【 `the official type^en — “名目上” のような意？】
には［
画像に`結付けられた~Content-Type~header$ で与えられる型 %型
］を与える下で。
これらの規則を適用しない場合、
画像の型は %型 になるモノトスル。
◎
The user agent should apply the image sniffing rules to determine the type of the image, with the image's associated Content-Type headers giving the official type. If these rules are not applied, then the type of the image must be the type given by the image's associated Content-Type headers.
</p>

<p>
~UAは、
`img$e 要素においては：
◎
↓</p>

<ul>
	<li>
画像でない資源は~supportしないモノトスル
（例：~XML~fileのうち，`文書~要素$は~HTML要素になるもの）。
◎
User agents must not support non-image resources with the img element (e.g. XML files whose document element is an HTML element).＼
</li>
	<li>
画像~資源~内に埋込まれた実行-可能~codeは走らせないモノトスル
（例： ~script）。
◎
User agents must not run executable code (e.g. scripts) embedded in the image resource.＼
</li>
	<li>
資源が複-~pageである場合は、
その最初の~pageのみ表示するモノトスル
（例：~PDF~file）。
◎
User agents must only display the first page of a multipage resource (e.g. a PDF file).＼
</li>
	<li>
資源が対話的に動作するのを許容しないモノトスル。
◎
User agents must not allow the resource to act in an interactive fashion, but＼
</li>
	<li>
資源における~animationは、
尊守するべきである。
◎
should honour any animation in the resource.
</li>
</ul>

<p>
この仕様は、どの画像~型が~supportされるかは指定しない。
◎
This specification does not specify which image types are to be supported.
</p>

					<section id="when-to-obtain-images">
<h5 title="When to obtain images">4.8.4.3.1. 画像をいつ得するか</h5>

<p>
既定では、
画像は即時に得される。
~UAは、
代わりに必要時に画像を得する~optionを利用者に供してもヨイ
（例えば、帯域幅が拘束された利用者は，それを利用するかもしれない）。
~UAは、
所与の `img$e 要素 %img の画像を：
◎
By default, images are obtained immediately. User agents may provide users with the option to instead obtain them on-demand. (The on-demand option might be used by bandwidth-constrained users, for example.)
◎
↓</p>

<ul>
	<li>
即時に得するときは、
次に従うモノトスル
⇒
%img が作成されたとき, および
%img が`関連な変異$を経た各回ごと
に，同期的に %img の`画像~dataを更新する$
— 特に言明されていれば、
`~animationを開始し直す^i も与える下で。
◎
When obtaining images immediately, the user agent must synchronously update the image data of the img element, with the restart animation flag set if so stated, whenever that element is created or has experienced relevant mutations.
</li>
	<li>
<p>
必要時に得するときは、
次に従うモノトスル：
◎
When obtaining images on demand, the user agent must ＼
</p>
		<ul>
			<li>
［
%img の`現在の要請$の`状態$ ~EQ `不可用$st
］場合に限り、
%img の画像~dataが必要になり次第（すなわち，必要時に），`画像~dataを更新する$。
◎
update the image data of an img element whenever it needs the image data (i.e., on demand), but only if the img element's current request's state is unavailable.＼
</li>
			<li>
%img が`関連な変異$を経た時点で，［
%img の`現在の要請$の`状態$ ~SET `不可用$st
］に戻す。
◎
When an img element has experienced relevant mutations, if the user agent only obtains images on demand, the img element's current request's state must return to unavailable.
</li>
		</ul>
	</li>
</ul>

					</section>
					<section id="reacting-to-dom-mutations">
<h5 title="Reacting to DOM mutations">4.8.4.3.2. ~DOM変異に対する反応-法</h5>

<p>
`img$e 要素 %img に
`関連な変異@
とは、
次に挙げるいずれかが生じることを表す：
◎
The relevant mutations for an img element are as follows:
</p>
<ul>
	<li>
%img の［
次に挙げる属性のうち，いずれか
］が［
設定-／変更-／除去-
］された
⇒＃
`src$a,
`srcset$a,
`width$a,
`sizes$a
◎
The element's src, srcset, width, or sizes attributes are set, changed, or removed.
</li>
	<li>
%img が `src$a 属性を有している下で，その値が前と同じ値に設定された
— この場合
⇒
`画像~dataを更新する$ときには、
`~animationを開始し直す^i を~~渡すモノトスル
◎
The element's src attribute is set to the same value as the previous value. This must set the restart animation flag for the update the image data algorithm.
</li>
	<li>
%img の `crossorigin$a 属性の状態が変化した。
◎
The element's crossorigin attribute's state is changed.
</li>
	<li>
%img の `referrerpolicy$a 属性の状態が変化した。
◎
The element's referrerpolicy attribute's state is changed.
</li>
	<li>
［
`img$e ／ `source$e
］用の［
`~HTML要素~挿入-時の手続き$／`~HTML要素~除去-時の手続き$
］（順不同）により，`関連な変異$が生じたものとされた。
◎
The img or source HTML element insertion steps or HTML element removing steps count the mutation as a relevant mutation.
</li>
	<li>
<p>
~AND↓ が満たされている下で…：
</p>
		<ul>
			<li>
%img の親は `picture$e 要素である
</li>
			<li>
%img に先行する同胞に `source$e 要素 %source が在る
</li>
		</ul>
<p>
%source の［
次に挙げる属性のうち，いずれか
］が［
設定-／変更-／除去-
］された
⇒＃
`srcset$aS,
`sizes$aS,
`media$aS,
`type$aS,
`width$a,
`height$a
</p>
◎
The element's parent is a picture element and a source element that is a previous sibling has its srcset, sizes, media, type, width or height attributes set, changed, or removed.
</li>
	<li>
%img 用の`受入-時の手続き$が走った。
◎
The element's adopting steps are run.
</li>
	<li>
<p>
%img は`自動-~sizeを許容して$いる下で、
次に挙げるいずれかが生じた：
◎
If the element allows auto-sizes:＼
</p>
		<ul>
			<li>
%img が`具現化されて$いるか否かが変化した
◎
the element starts or stops being rendered,＼
</li>
			<li>
%img の`具象-~obj~size$を成す横幅が変化した
◎
or its concrete object size width changes.＼
</li>
		</ul>
<p>
この場合、
`画像~dataを更新する$ときには，
`場合によっては~eventを省略し得る^i を渡すモノトスル。
◎
This must set the maybe omit events flag for the update the image data algorithm.
</p>
	</li>
</ul>

					</section>
					<section id="the-list-of-available-images">
<h5 title="The list of available images">4.8.4.3.3. 可用な画像の~list</h5>

<p>
各 `文書$は
`可用な画像~list@
を持つモノトスル。
この~list内の~entryになる各 画像は：
◎
Each Document object must have a list of available images. Each image in this list is＼
</p>

<ul>
	<li>
<p>
( `絶対~URL$, ~mode, `生成元$または ε )
からなる~tupleによる~keyで識別される
— ここで：
</p>
		<ul>
			<li>
~modeは `~CORS設定群~属性$がとり得る状態と同じ~~範囲の値をとる。
</li>
			<li>
3 個目の成分は、［
~mode ~EQ `~CORSなし$st
］の場合は，常に ε （なし）にされる。
</li>
		</ul>
◎
identified by a tuple consisting of an absolute URL, a CORS settings attribute mode, and, if the mode is not No CORS, an origin.＼
</li>
	<li>
加えて，真偽値をとる
`上層~cachingは無視するか@
も伴われる。
◎
Each image furthermore has an ignore higher-layer caching flag.＼
</li>
</ul>

<p>
~UAは，いつでも、
異なる`文書$~間で，一方の`可用な画像~list$内の~entryを他方へ複製してヨイ
（例：~UAは， ある`文書$の作成-時に，他の`文書$~内に読込まれたすべての画像を~listに追加できる）。
ただし、
この仕方で複製された~entryに対しては：
◎
User agents may copy entries from one Document object's list of available images to another at any time (e.g. when the Document is created, user agents can add to it all the images that are loaded in other Documents),＼
</p>

<ul>
	<li>
その~keyを変更しないモノトスル。
◎
but must not change the keys of entries copied in this way when doing so,＼
</li>
	<li>
その`上層~cachingは無視するか$は ~F にするモノトスル。
◎
and must unset the ignore higher-layer caching flag for the copied entry.＼
</li>
</ul>

<p>
~UAは，いつでも、
`可用な画像~list$内から画像を除去してヨイ（例：~memoryを節約する）。
ただし，除去する~entryの［
`上層~cachingは無視するか$ ~EQ ~F
］の場合は、
当の資源~用の上層~cachingの意味論に適切になるよう除去するモノトスル
（例： ~HTTP `Cache-Control$h 応答~header）。
◎
User agents may also remove images from such lists at any time (e.g. to save memory). User agents must remove entries in the list of available images as appropriate given higher-layer caching semantics for the resource (e.g. the HTTP `Cache-Control` response header) when the ignore higher-layer caching flag is unset.
</p>

<p class="note">注記：
`可用な画像~list$は、［
~HTTPによる~cachingが許容されないとき
］でも，［
`src$a 属性が 以前に読込んだ~URLに変更されたときに
— 同じ文書~内の画像を~downloadし直すのを避けるよう —
同期的な切替えを可能化する
］ために意図されている。
それは、［
以前の画像をまだ読込んでいる間に，
同じ画像を~downloadし直すのを避ける
］ために利用されるものではない。
◎
The list of available images is intended to enable synchronous switching when changing the src attribute to a URL that has previously been loaded, and to avoid re-downloading images in the same document even when they don't allow caching per HTTP. It is not used to avoid re-downloading the same image while the previous image is still loading.
</p>

<p class="note">注記：
~UAは、
画像~dataを`可用な画像~list$とは別々に格納することもできる。
◎
The user agent can also store the image data separately from the list of available images.
</p>

<p class="example">
例えば、
資源に［
`must-revalidate$v を値にとる ~HTTP `Cache-Control$h 応答~header
］が伴われていて，［
資源の`上層~cachingは無視するか$ ~EQ ~F
］の場合、
~UAは，それを`可用な画像~list$から除去することになるが、
画像~dataは別々に保っておいて，［
~serverが 状態s~code `304^st （ Not Modified ）で応答してきたときには、
それを利用する
］こともできる。
◎
For example, if a resource has the HTTP response header `Cache-Control: must-revalidate`, and its ignore higher-layer caching flag is unset, the user agent would remove it from the list of available images but could keep the image data separately, and use that if the server responds with a 304 Not Modified status.
</p>

					</section>
					<section id="decoding-images">
<h5 title="Decoding images">4.8.4.3.4. 画像の復号-法</h5>

<p>
画像~dataは、
~file~sizeを抑制するため，通例的に符号化される。
すなわち、
~UAが画像を~screenに呈示する前に，~dataは復号される必要がある。
`復号-@
は、
画像の媒体~dataを［
~screenに呈示するに相応しい~bitmap形
］に変換する処理nである。
この処理nは、
内容を呈示するときに孕まれる他の処理nよりも低速にもなり得ることに注意。
したがって~UAは、
最良な利用者~体験を~~供するため，復号をいつ遂行するか選べる。
◎
Image data is usually encoded in order to reduce file size. This means that in order for the user agent to present the image to the screen, the data needs to be decoded. Decoding is the process which converts an image's media data into a bitmap form, suitable for presentation to the screen. Note that this process can be slow relative to other processes involved in presenting content. Thus, the user agent can choose when to perform decoding, in order to create the best user experience.
</p>

<p>
画像の復号は、
それが完遂するまで 他の内容の呈示を防止するならば，同期的という。
これには概して、
画像と他の内容を，同時かつ不可分に呈示する効果がある。
しかしながら、
この呈示は，復号にかかった時間だけ遅延される。
◎
Image decoding is said to be synchronous if it prevents presentation of other content until it is finished. Typically, this has an effect of atomically presenting the image and any other content at the same time. However, this presentation is delayed by the amount of time it takes to perform the decode.
</p>

<p>
画像の復号は、
他の内容の呈示を防止しないならば，非同期的という。
これには、
画像でない内容を より高速に呈示する効果がある。
しかしながら、
復号-が完遂するまで，画像~内容は~screenに~~現れない。
— 完遂したなら，~screenは画像で更新される。
◎
Image decoding is said to be asynchronous if it does not prevent presentation of other content. This has an effect of presenting non-image content faster. However, the image content is missing on screen until the decode finishes. Once the decode is finished, the screen is updated with the image.
</p>

<p>
［
同期的, 非同期的
］どちらの復号~modeであれ，［
最終的な内容が~screenに呈示されるまでに費やされる時間
］は同じになる。
主な相違は、［
~UAが最終的な内容を呈示するに先立って，画像でない内容を呈示するかどうか
］になる。
◎
In both synchronous and asynchronous decoding modes, the final content is presented to screen after the same amount of time has elapsed. The main difference is whether the user agent presents non-image content ahead of presenting the final content.
</p>

<p>
~UAが［
同期的, 非同期的
］どちらで復号するか裁定するのを援助するため、
`img$e 要素には `decoding$a 属性を設定できる。
この属性~用の
`画像~復号~hint@
~keyword, とり得る状態, それらの対応付けは：
◎
In order to aid the user agent in deciding whether to perform synchronous or asynchronous decode, the decoding attribute can be set on img elements. The possible values of the decoding attribute are the following image decoding hint keywords:
</p>

<table><thead>
<tr><th>~keyword
<th>状態
<th>記述
<tbody>

<tr><td>`sync@v
<td>`同期c@st
<td>
この画像を，他の内容との不可分な呈示~用に同期的に`復号-$する選好を指示する。
◎
Indicates a preference to decode this image synchronously for atomic presentation with other content.

<tr><td>`async@v
<td>`非同期c@st
<td>
他の内容の呈示が遅延されるのを避けるため、
この画像を［
他の内容との不可分な呈示
］用に非同期的に`復号-$する選好を指示する。
◎
Indicates a preference to decode this image asynchronously to avoid delaying presentation of other content.

<tr><td>`auto@v
<td>`自動@st
<td>
復号~modeの選好は無いことを指示する（既定）。
◎
Indicates no preference in decoding mode (the default).
</table>

<p>
~UAは，画像を`復号-$するときは、［
`decoding$a 属性の状態にて指示された選好
］を尊重するべきである。
指示された状態が `自動$st の場合、
~UAは，復号の挙動を選んでもかまわない。
◎
When decoding an image, the user agent should respect the preference indicated by the decoding attribute's state. If the state indicated is auto, then the user agent is free to choose any decoding behavior.
</p>

<p class="note">
`decode$m ~methodを利用して，復号の挙動を制御することもアリである。
この~methodは、［
内容を~screenに呈示する処理nからは独立に，`復号-$を遂行する
］ので， `decoding$a 属性からは影響されない。
◎
It is also possible to control the decoding behavior using the decode() method. Since the decode() method performs decoding independently from the process responsible for presenting content to screen, it is unaffected by the decoding attribute.
</p>
					</section>
					<section id="updating-the-image-data">
<h5 title="Updating the image data">4.8.4.3.5. 画像~dataの更新-法</h5>

<p class="note">注記：
この~algoは、
`並列的$に走っている手続きからは~callできない。
~UAは、［
`並列的$に走っている手続きから，この~algoを~callする必要がある場合
］には，それを行う`~taskを~queueする$必要がある。
【！https://github.com/whatwg/html/pull/3752】
◎
This algorithm cannot be called from steps running in parallel. If a user agent needs to call this algorithm from steps running in parallel, it needs to queue a task to do so.
</p>

<div class="algo">
<p>
`img$e 要素 %img の
`画像~dataを更新する@
~algoは、
所与の
⇒＃
%~animationを開始し直すか ~IN { `~animationを開始し直す^i, ε }（ 省略時は ε ）,
%場合によっては~eventを省略し得るか ~IN { `場合によっては~eventを省略し得る^i, ε }（ 省略時は ε ）
◎終
に対し：
◎
When the user agent is to update the image data of an img element, optionally with the restart animations flag set, optionally with the maybe omit events flag set, it must run the following steps:
</p>
<ol>
	<li>
<p>
~IF［
%img の`~node文書$は`全部的に作動中$でない
］：
◎
If the element's node document is not fully active, then:
</p>
		<ol>
			<li>
この~algoを`並列的$に走らすよう継続する
◎
Continue running this algorithm in parallel.
</li>
			<li>
%img の`~node文書$が`全部的に作動中$になるまで待機する
◎
Wait until the element's node document is fully active.
</li>
			<li>
~IF［
%img に対し この~algoの別の~instanceが，この~instanceより後に開始されていた（それが早々に ~RET して，もはや走ってない場合でも）
］
⇒
~RET
◎
If another instance of this algorithm for this img element was started after this instance (even if it aborted and is no longer running), then return.
</li>
			<li>
`小taskを~queueする$( この~algoの以降を継続する手続き )
【したがって，ここで ~RET するであろう。】
◎
Queue a microtask to continue this algorithm.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
~UAは画像を~supportできない
］~OR［
画像の~supportは不能化されている
］：
◎
If the user agent cannot support images, or its support for images has been disabled, then＼
</p>
		<ol>
			<li>
`画像~要請を中止する$( %img の`現在の要請$ )
◎
abort the image request for the current request and＼
</li>
			<li>
`画像~要請を中止する$( %img の`処理待ち要請$ )
◎
the pending request,＼
</li>
			<li>
%img の`現在の要請$の`状態$ ~SET `不可用$st
◎
set current request's state to unavailable,＼
</li>
			<li>
%img の`処理待ち要請$ ~SET ~NULL
◎
set pending request to null,＼
</li>
			<li>
~RET
◎
and return.
</li>
		</ol>
	</li>
	<li>
%以前の~URL ~LET `現在の要請$の`現在の~URL$
◎
Let previousURL be the current request's current URL.
</li>
	<li>
( %選定された~source, %選定された画素~密度 ) ~LET ( ε, ε )
◎
Let selected source be null and selected pixel density be undefined.
</li>
	<li>
~IF［
%img は`~srcsetまたは~pictureを利用して$いない
］~AND［
%img は `src$a 属性 %src を有する
］~AND［
%src の値 ~NEQ 空~文字列
］
⇒
( %選定された~source, %選定された画素~密度 ) ~SET ( %src の値, 1.0 )
◎
If the element does not use srcset or picture and it has a src attribute specified whose value is not the empty string, then set selected source to the value of the element's src attribute and set selected pixel density to 1.0.
</li>
	<li>
%img の`最後に選定された~source$ ~SET %選定された~source
◎
Set the element's last selected source to selected source.
</li>
	<li>
<p>
`(A)^i：<br>
~IF［
%選定された~source ~NEQ ε
］：
◎
If selected source is not null, then:
</p>
		<ol>
			<li>
%文書 ~LET %img の`~node文書$
◎
↓</li>
			<li>
%~URL~record ~LET `~URLを符号化法の下で相対的に構文解析する$( %選定された~source, %文書 )
【！#encoding-parsing-and-serializing-a-url】
◎
Let urlString be the result of encoding-parsing-and-serializing a URL given selected source, relative to the element's node document.
</li>
			<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~BREAK `(A)^i
◎
If urlString is failure, then abort this inner set of steps.
</li>
			<li>
<p>
%~key ~LET 次に挙げる成分からなる~key：
</p>
				<ol>
					<li>
`~URLを直列化する$( %~URL~record )
</li>
					<li>
%img の `crossorigin$a 内容~属性の状態
</li>
					<li>
%~CORS属性~状態 ~NEQ `~CORSなし$st ならば %文書 の`生成元$doc ／
~ELSE_ ε
</li>
				</ol>
◎
Let key be a tuple consisting of urlString, the img element's crossorigin attribute's mode, and, if that mode is not No CORS, the node document's origin.
</li>
			<li>
<p>
~IF［
%文書 の`可用な画像~list$内に， %~key に対応する~entry %~entry は在る
］：
◎
If the list of available images contains an entry for key, then:
</p>
				<ol>
					<li>
%~entry の`上層~cachingは無視するか$ ~SET ~T
◎
Set the ignore higher-layer caching flag for that entry.
</li>
					<li>
`画像~要請を中止する$( %img の`現在の要請$ )
◎
Abort the image request for the current request and＼
</li>
					<li>
`画像~要請を中止する$( %img の`処理待ち要請$ )
◎
the pending request.
</li>
					<li>
%img の`処理待ち要請$ ~SET ~NULL
◎
Set pending request to null.
</li>
					<li>
%img の`現在の要請$ ~LET 次のようにされた新たな`画像~要請$
⇒＃
`画像~data$ ~SET %~entry の`画像~data$；
`状態$ ~SET `完全に可用$st
◎
Let current request be a new image request whose image data is that of the entry and whose state is completely available.
</li>
					<li>
`画像を呈示~用に準備する$( %img )
◎
Prepare current request for presentation given the img element.
</li>
					<li>
【！ 現在の要請の】
%img の`現在の画素~密度$ ~SET %選定された~画素~密度
◎
Set current request's current pixel density to selected pixel density.
</li>
					<li>
<p>
`要素~taskを~queueする$( `~DOM操作~task~source$, %img, 次の手続き )
◎
Queue an element task on the DOM manipulation task source given the img element and＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
						<ol>
							<li>
~IF［
%~animationを開始し直すか ~NEQ ε
］
⇒
`~animationを開始し直す$( %img )
◎
If restart animation is set, then restart the animation.
</li>
							<li>
%img の`現在の要請$の`現在の~URL$ ~SET %~URL文字列
◎
Set current request's current URL to urlString.
</li>
							<li>
~IF［
%場合によっては~eventを省略し得るか ~EQ ε
］~OR［
%以前の~URL ~NEQ %~URL文字列
］
⇒
`~eventを発火する$( %img, `load$et )
◎
If maybe omit events is not set or previousURL is not equal to urlString, then fire an event named load at the img element.
</li>
						</ol>
</div>
					</li>
					<li>
~RET
◎
Abort the update the image data algorithm.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
`小taskを~queueする$( この~algoの以降を遂行する手続き )
【したがって，ここで ~RET するであろう。】
（この~algoを呼出した`~task$を継続できるようにするため）
◎
Queue a microtask to perform the rest of this algorithm, allowing the task that invoked this algorithm to continue.
</li>
	<li>
<p>
~IF［
%img に対するこの~algoの別の~instanceが，この~instanceより後に開始されていた（それが早々に ~RET して，もはや走ってない場合でも）
］
⇒
~RET
◎
If another instance of this algorithm for this img element was started after this instance (even if it aborted and is no longer running), then return.
</p>

<p class="note">注記：
複数の要請を避けるため、
効果があるのは，最後の~instanceに限られる
— 例えば［
`src$a, `srcset$a, `crossorigin$a
］属性が続けて設定されたときでも。
◎
Only the last instance takes effect, to avoid multiple requests when, for example, the src, srcset, and crossorigin attributes are all set in succession.
</p>
	</li>
	<li>
%現~要請 ~LET %img の`現在の要請$
◎
↓</li>
	<li>
( %選定された~source, %選定された画素~密度 )
~LET `画像~sourceを選定する$( %img )
◎
Let selected source and selected pixel density be the URL and pixel density that results from selecting an image source, respectively.
</li>
	<li>
<p>
~IF［
%選定された~source ~EQ ε
］：
◎
If selected source is null, then:
</p>
		<ol>
			<li>
%現~要請 の`状態$ ~SET `壊en$st
◎
Set the current request's state to broken,＼
</li>
			<li>
`画像~要請を中止する$( %現~要請 )
◎
abort the image request for the current request and＼
</li>
			<li>
`画像~要請を中止する$( %img の`処理待ち要請$ )
◎
the pending request,＼
</li>
			<li>
%img の`処理待ち要請$ ~SET ~NULL
◎
and set pending request to null.
</li>
			<li>
<p>
`要素~taskを~queueする$( `~DOM操作~task~source$, %img, 次の手続き )
◎
Queue an element task on the DOM manipulation task source given the img element and＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
				<ol>
					<li>
%現~要請 の`現在の~URL$ ~SET 空~文字列
◎
Change the current request's current URL to the empty string.
</li>
					<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
						<ul>
							<li>
［
%img は `src$a 属性を有する
］~OR［
%img は`~srcsetまたは~pictureを利用して$いる
］
◎
the element has a src attribute or it uses srcset or picture; and
</li>
							<li>
［
%場合によっては~eventを省略し得るか ~EQ ε
］~OR［
%以前の~URL ~NEQ 空~文字列
］
◎
maybe omit events is not set or previousURL is not the empty string,
</li>
						</ul>
<p>
…ならば
⇒
`~eventを発火する$( %img, `error$et )
◎
then fire an event named error at the img element.
</p>
					</li>
				</ol>
</div>
			</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%文書 ~LET %img の`~node文書$
◎
↓</li>
	<li>
%~URL~record ~LET `~URLを符号化法の下で相対的に構文解析する$( %選定された~source, %文書 )
【！#encoding-parsing-and-serializing-a-url】
◎
Let urlString be the result of encoding-parsing-and-serializing a URL given selected source, relative to the element's node document.
</li>
	<li>
<p>
~IF［
%~URL~record ~EQ `失敗^i
］：
◎
If urlString is failure, then:
</p>
		<ol>
			<li>
`画像~要請を中止する$( %現~要請 )
◎
Abort the image request for the current request and＼
</li>
			<li>
`画像~要請を中止する$( %img の`処理待ち要請$ )
◎
the pending request.
</li>
			<li>
%現~要請 の`状態$ ~SET `壊en$st
◎
Set the current request's state to broken.
</li>
			<li>
%img の`処理待ち要請$ ~SET ~NULL
◎
Set pending request to null.
</li>
			<li>
<p>
`要素~taskを~queueする$( `~DOM操作~task~source$, %img, 次の手続き )
◎
Queue an element task on the DOM manipulation task source given the img element and＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
				<ol>
					<li>
%現~要請 の`現在の~URL$ ~SET %選定された~source
◎
Change the current request's current URL to selected source.
</li>
					<li>
~IF［
%場合によっては~eventを省略し得るか ~EQ ε
］~OR［
%以前の~URL ~NEQ %選定された~source
］
⇒
`~eventを発火する$( %img, `error$et )
◎
If maybe omit events is not set or previousURL is not equal to selected source, then fire an event named error at the img element.
</li>
				</ol>
</div>
			</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%~URL文字列 ~LET `~URLを直列化する$( %~URL~record )
◎
↑↑</li>
	<li>
%処理待ち要請 ~LET %img の`処理待ち要請$
◎
↓</li>
	<li>
~IF［
%処理待ち要請 ~NEQ ~NULL
］~AND［
%~URL文字列 ~EQ %処理待ち要請 の`現在の~URL$
］
⇒
~RET
◎
If the pending request is not null and urlString is the same as the pending request's current URL, then return.
</li>
	<li>
<p>
~IF［
%~URL文字列 ~EQ %現~要請 の`現在の~URL$
］~AND［
%現~要請 の`状態$ ~EQ `部分的に可用$st
］：
◎
If urlString is the same as the current request's current URL and current request's state is partially available, then＼
</p>
		<ol>
			<li>
`画像~要請を中止する$( %処理待ち要請 )
◎
abort the image request for the pending request,＼
</li>
			<li>
<p>
~IF［
%~animationを開始し直すか ~NEQ ε
］
⇒
`要素~taskを~queueする$( `~DOM操作~task~source$, %img, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~animationを開始し直す$( %img )
</div>
◎
queue an element task on the DOM manipulation task source given the img element to restart the animation if restart animation is set,＼
</li>
			<li>
~RET
◎
and return.
</li>
		</ol>
	</li>
	<li>
`画像~要請を中止する$( %処理待ち要請 )
◎
Abort the image request for the pending request.
</li>
	<li>
%画像~要請 ~LET 新たな`画像~要請$
◎
Set image request to a new image request＼
</li>
	<li>
%画像~要請 の`現在の~URL$ ~SET %~URL文字列
◎
whose current URL is urlString.
</li>
	<li>
~IF［
%現~要請 の`状態$ ~IN { `不可用$st, `壊en$st }
］
⇒
%img の`現在の要請$ ~SET %画像~要請
◎
If current request's state is unavailable or broken, then set the current request to image request.＼
</li>
	<li>
~ELSE
⇒
%img の`処理待ち要請$ ~SET %画像~要請
◎
Otherwise, set the pending request to image request.
</li>
	<li>
%要請 ~LET
`~CORSになり得る要請を作成する$( %~URL~record, `image^l, %img の`crossorigin$a 内容~属性の現在の状態 )
◎
Let request be the result of creating a potential-CORS request given urlString, "image", and the current state of the element's crossorigin content attribute.
</li>
	<li>
%要請 の`~client$rq ~SET %文書 に`関連な設定群~obj$
◎
Set request's client to the element's node document's relevant settings object.
</li>
	<li>
~IF［
%img は`~srcsetまたは~pictureを利用して$いる
］
⇒
%要請 の`起動元$rq ~SET `imageset^l 
◎
If the element uses srcset or picture, set request's initiator to "imageset".
</li>
	<li>
%要請 の
⇒＃
`~referrer施策$rq ~SET %img の `referrerpolicy$a 属性の現在の状態,
`優先度$rq ~SET %img の `fetchpriority$a 属性の現在の状態
◎
Set request's referrer policy to the current state of the element's referrerpolicy attribute.
◎
Set request's priority to the current state of the element's fetchpriority attribute.
</li>
	<li>
%~load~eventを遅延するか ~LET ~IS［
%img の`~lazy読込ng属性$の状態 ~EQ `Eager$st
］~OR［
%img 用の`~scriptingは不能化されて$いる
］
◎
Let delay load event be true if the img's lazy loading attribute is in the Eager state, or if scripting is disabled for the img, and false otherwise.
</li>
	<li>
<p>
~IF［
`~lazyに読込むことになる$( %img ) ~EQ ~T
］：
◎
If the will lazy load element steps given the img return true, then:
</p>
		<ol>
			<li>
%img の`~lazy読込n再開~手続き$ ~SET 
この~algoの `画像を~fetchする^i 段~以降を走らす手続き
◎
Set the img's lazy load resumption steps to the rest of this algorithm starting with the step labeled fetch the image.
</li>
			<li>
`~lazyに読込んでいる要素の交差~観測を開始する$( %img )
◎
Start intersection-observing a lazy loading element for the img element.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
`画像を~fetchする^i：
◎
Fetch the image:＼
</p>
		<ol>
			<li>
%要請 を`~fetch$する
◎
Fetch request.＼
</li>
			<li>
~RET
— ただし，以降の手続きは、［
~fetchした結果の`応答$ %応答 に対する`応答の処理n$i
］の一部として走らす
◎
Return from this algorithm, and run the remaining steps as part of the fetch's processResponse for the response response.
</li>
		</ol>
		<ul>
			<li>
このようにして得した資源があれば、
それが %画像~要請 の`画像~data$になる。
それは、
`~CORS同一-生成元$にも`~CORS非同一-生成元$にもなり得る
— どちらになるかに応じて，当の画像と他の~APIとのヤリトリに影響する
（例： `canvas$e 上で利用されるとき）。
◎
The resource obtained in this fashion, if any, is image request's image data. It can be either CORS-same-origin or CORS-cross-origin; this affects the image's interaction with other APIs (e.g., when used on a canvas).
</li>
			<li>
<p>
［
%~load~eventを遅延するか ~EQ ~T
］のときは
⇒
画像の~fetchingは、
資源が~fetchされ，`~network用~task~source$から`~queueされ$た`~task$が走るまで
（`下に定義される＠#img-load$），
%文書 の`~load~eventを遅延する$モノトスル
◎
When delay load event is true, fetching the image must delay the load event of the element's node document until the task that is queued by the networking task source once the resource has been fetched (defined below) has been run.
</p>

<p class="warning">
あいにくこれは、［
利用者の局所~networkに対する原始的な~port-scan
］を遂行するためにも利用され得る
（とりわけ，~scriptingとの併用で
— 実際には、
~scriptingは，そのような攻撃を遂げるために必要yでないが）。
~UAは、
この攻撃を軽減するため，［
上に述べたものより厳密な`生成元$~access制御~施策
］を実装してもヨイが、
あいにく そのような施策は，概して既存の~web内容と互換にならない。
◎
This, unfortunately, can be used to perform a rudimentary port scan of the user's local network (especially in conjunction with scripting, though scripting isn't actually necessary to carry out such an attack). User agents may implement cross-origin access control policies that are stricter than those described above to mitigate this attack, but unfortunately such policies are typically not compatible with existing web content.
</p>
			</li>
		</ul>
	</li>
	<li>
<p>
【~fetchingによる~dataが得られるに伴い，】
アリな限り早く、［
以下に挙げる各項のうち，最初に適用-可能なもの
］に対応する段を走らす：
◎
As soon as possible, jump to the first applicable entry from the following list:
</p>

<p>
この段における
`画像~fetch~task@
とは、
画像が~fetchされている間に`~network用~task~source$から`~queueされ$ることになる，各`~task$を指すとする。
◎
↓</p>

<!-- ＊
可能な限り早く
— 画像の形式~supoortするかどうか, 
~supoortする場合は 画像~要請 の画像の寸法を決定できるかどうか判明した時点まで待機する
 -->
		<dl class="switch">
			<dt>
資源の~MIME型 ~EQ `multipart/x-mixed-replace$mt
：
◎
If the resource type is multipart/x-mixed-replace
</dt>
			<dd>
<div class="algo">
<p>
最初の【！the next】`画像~fetch~task$は、
次の手続きを走らすモノトスル：
◎
The next task that is queued by the networking task source while the image is being fetched must run the following steps:
</p>
				<ol>
					<li>
%状態 ~LET ~UAは %画像~要請 の画像の寸法を［
決定できたならば `部分的に可用$st ／
何らかの致命的な仕方で得れないまでに破損していると決定できたならば `壊en$st
］
◎
↓</li>
					<li>
<p>
~IF［
%画像~要請 ~EQ %img の`処理待ち要請$
］：
</p>
						<ol>
							<li>
~Assert†：
［
完全に復号された本体部位が少なくとも 1 個以上ある
］~OR［
%状態 ~EQ `壊en$st
］
</li>
							<li>
`画像~要請を中止する$( %img の`現在の要請$ )
</li>
							<li>
%img の`処理待ち要請を現在の要請に昇格する$
</li>
							<li>
~IF［
完全に復号された本体部位はまだない
］~AND［
%状態 ~EQ `壊en$st
］
⇒
%画像~要請 の`状態$ ~SET `壊en$st
</li>
						</ol>

<p class="trans-note">【†
この ~Assert は訳者による補完。
原文では，この ~Assert が満たされない場合の挙動が記されておらず、
満たされない場合，処理待ち要請が現在の要請に昇格する機会cが来なくなってしまうので。
】</p>
◎
If image request is the pending request and at least one body part has been completely decoded, abort the image request for the current request, and upgrade the pending request to the current request.
◎
Otherwise, if image request is the pending request and the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, abort the image request for the current request, upgrade the pending request to the current request, and set the current request's state to broken.
</li>
					<li>
~ELIF［
%画像~要請 ~EQ %img の`現在の要請$
］~AND［
%画像~要請 の`状態$ ~EQ `不可用$st
］
⇒
%画像~要請 の`状態$ ~SET %状態
◎
Otherwise, if image request is the current request, its state is unavailable, and the user agent is able to determine image request's image's width and height, set the current request's state to partially available.
◎
Otherwise, if image request is the current request, its state is unavailable, and the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, set the current request's state to broken.
</li>
				</ol>
</div>

<p>
【 %img の`現在の要請$用の】
各`画像~fetch~task$は，画像の呈示を更新するモノトスルが、
新たな本体部位が来る度に，~UAは次に従うモノトスル：
◎
Each task that is queued by the networking task source while the image is being fetched must update the presentation of the image, but as each new body part comes in,＼
</p>
				<ul>
					<li class="algo">
<p>
~IF［
~UAは画像の寸法を決定できた
］：
</p>
						<ol>
							<li>
`画像を呈示~用に準備する$( %img )
</li>
							<li>
以前の画像を置換する
</li>
						</ol>
◎
if the user agent is able to determine the image's width and height, it must prepare the img element's current request for presentation given the img element and replace the previous image.＼
</li>
					<li class="algo">
<p>
ある本体部位が完全に復号された時点で，次の手続きを遂行する：
◎
Once one body part has been completely decoded, perform the following steps:
</p>
						<ol>
							<li>
%img の`現在の要請$の`状態$ ~SET `完全に可用$st
◎
Set the img element's current request's state to completely available.
</li>
							<li>
<p>
~IF［
%場合によっては~eventを省略し得るか ~EQ ε
］~OR［
%以前の~URL ~NEQ %~URL文字列
］
⇒
`要素~taskを~queueする$( `~DOM操作~task~source$, %img, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~eventを発火する$( %img, `load$et )
</div>
◎
If maybe omit events is not set or previousURL is not equal to urlString, then queue an element task on the DOM manipulation task source given the img element to fire an event named load at the img element.
</li>
						</ol>
					</li>
				</ul>
			</dd>
			<dt>
資源の~MIME型と~dataは、
`下に述べるとおり＠#img-determine-type$，~supportする画像~形式に対応する：
◎
If the resource type and data corresponds to a supported image format, as described below
</dt>
			<dd>
<div class="algo">
<p>
最初の【！the next】`画像~fetch~task$は、
次の手続きを走らすモノトスル：
◎
The next task that is queued by the networking task source while the image is being fetched must run the following steps:
</p>
				<ol>
					<li>
<p>
~IF［
~UAは %画像~要請 の画像の寸法を決定できた
］：
</p>
						<ol>
							<li>
~IF［
%画像~要請 ~EQ %img の`現在の要請$
］
⇒
`画像を呈示~用に準備する$( %img )
</li>
							<li>
%画像~要請 の`状態$ ~SET `部分的に可用$st
</li>
						</ol>
◎
If the user agent is able to determine image request's image's width and height, and image request is pending request, set image request's state to partially available.
◎
Otherwise, if the user agent is able to determine image request's image's width and height, and image request is current request, prepare image request for presentation given the img element and set image request's state to partially available.
</li>
					<li>
<p>
~ELSE（画像は［
何らかの致命的な仕方で破損している
］と決定できた）：
</p>
						<ol>
							<li>
`画像~要請を中止する$( %img の`現在の要請$ )
</li>
							<li>
<p>
~IF［
%画像~要請 ~EQ %img の`処理待ち要請$
］：
</p>
								<ol>
									<li>
`画像~要請を中止する$( %img の`処理待ち要請$ )
</li>
									<li>
%img の`処理待ち要請を現在の要請に昇格する$
</li>
									<li>
%img の`現在の要請$の`状態$ ~SET `壊en$st
</li>
									<li>
`~eventを発火する$( %img, `error$et )
</li>
								</ol>
							</li>
							<li>
~ELIF［
%場合によっては~eventを省略し得るか ~EQ ε
］~OR［
%以前の~URL ~NEQ %~URL文字列
］
⇒
`~eventを発火する$( %img, `error$et )
</li>
						</ol>
◎
Otherwise, if the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, and image request is pending request:
• Abort the image request for the current request and the pending request.
• Upgrade the pending request to the current request.
• Set current request's state to broken.
• Fire an event named error at the img element.
◎
Otherwise, if the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, and image request is current request:
• Abort the image request for image request.
• If maybe omit events is not set or previousURL is not equal to urlString, then fire an event named error at the img element.
</li>
				</ol>
</div>

<div class="algo">
<p id="img-load">
各`画像~fetch~task$（最初のそれも含む）は、
次の手続きを走らすモノトスル：
</p>
				<ol>
					<li>
~IF［
%画像~要請 ~EQ %img の`現在の要請$
］
⇒
画像の呈示を更新する
（例えば，画像が~progressive~JPEGの場合、
各~packetは，その画像の解像度を向上させ得る）
</li>
				</ol>
◎
That task, and each subsequent task, that is queued by the networking task source while the image is being fetched, if image request is the current request, must update the presentation of the image appropriately (e.g., if the image is a progressive JPEG, each packet can improve the resolution of the image).
</div>

<div class="algo">
<p>
加えて、
資源を~fetchし終えたときの最後の`画像~fetch~task$は，
次の手続きを走らすモノトスル：
◎
Furthermore, the last task that is queued by the networking task source once the resource has been fetched must additionally run these steps:
</p>
				<ol>
					<li>
<p>
~IF［
%画像~要請 ~EQ %img の`処理待ち要請$
］：
◎
If image request is the pending request,＼
</p>
						<ol>
							<li>
`画像~要請を中止する$( %img の`現在の要請$ )
◎
abort the image request for the current request,＼
</li>
							<li>
%img の`処理待ち要請を現在の要請に昇格する$
◎
upgrade the pending request to the current request and＼
</li>
							<li>
`画像を呈示~用に準備する$( %img )
◎
prepare image request for presentation given the img element.
</li>
						</ol>
					</li>
					<li>
%画像~要請 の`状態$ ~SET `完全に可用$st
◎
Set image request to the completely available state.
</li>
					<li>
%文書 の`可用な画像~list$に，画像を追加する
— この画像は
⇒
~key %~key で識別され,
`上層~cachingは無視するか$は ~T にするとする
◎
Add the image to the list of available images using the key key, with the ignore higher-layer caching flag set.
</li>
					<li>
~IF［
%場合によっては~eventを省略し得るか ~EQ ε
］~OR［
%以前の~URL ~NEQ %~URL文字列
］
⇒
`~eventを発火する$( %img, `load$et )
◎
If maybe omit events is not set or previousURL is not equal to urlString, then fire an event named load at the img element.
</li>
				</ol>
</div>
			</dd>

			<dt>
その他（ 画像~dataは~supportされる~file形式でない ）：
◎
Otherwise
◎
The image data is not in a supported file format; the user agent must＼
</dt>
			<dd>
				<ol>
					<li>
%画像~要請 の`状態$ ~SET `壊en$st
◎
set image request's state to broken,＼
</li>
					<li>
`画像~要請を中止する$( %img の`現在の要請$ )
◎
abort the image request for the current request＼
</li>
					<li>
`画像~要請を中止する$( %img の`処理待ち要請$ )
◎
and the pending request,＼
</li>
					<li>
~IF［
%画像~要請 ~EQ %img の`処理待ち要請$
］
⇒
%img の`処理待ち要請を現在の要請に昇格する$
◎
upgrade the pending request to the current request if image request is the pending request, and then＼
</li>
					<li>
<p>
~IF［
%場合によっては~eventを省略し得るか ~EQ ε
］~OR［
%以前の~URL ~NEQ %~URL文字列
］
⇒
`要素~taskを~queueする$( `~DOM操作~task~source$, %img, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~eventを発火する$( %img, `error$et )
</div>
◎
if maybe omit events is not set or previousURL is not equal to urlString, queue an element task on the DOM manipulation task source given the img element to fire an event named error at the img element.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>
</div>

<p>
~UAが，ある要素 %img に対し上の~algoを走らせている間は、
%img は`接続されて$いなくとも，
%img の`~node文書$から %img への強い参照があるモノトスル。
◎
While a user agent is running the above algorithm for an element x, there must be a strong reference from the element's node document to the element x, even if that element is not connected.
</p>

<div class="algo">
<p>
`画像~要請を中止する@
~algoは、
所与の
( ［
`画像~要請$／~NULL
］ %画像~要請 )
に対し：
◎
To abort the image request for an image request or null image request means to run the following steps:
</p>
<ol>
	<li>
~IF［
%画像~要請 ~EQ ~NULL
］
⇒
~RET
◎
If image request is null, then return.
</li>
	<li>
%画像~要請 の`画像~data$ ~SET ε
◎
Forget image request's image data, if any.
</li>
	<li>
%画像~要請 による`~fetch$~algoの~instanceがあれば、
それを中止した上で，
その~algoにより生成された処理待ち~taskすべてを破棄する
◎
Abort any instance of the fetching algorithm for image request, discarding any pending tasks generated by that algorithm.
</li>
</ol>
</div>

<div class="algo">
<p>
`img$e 要素の
`処理待ち要請を現在の要請に昇格する@
~algoは：
◎
To upgrade the pending request to the current request for an img element means to run the following steps:
</p>

<ol>
	<li>
~Assert：
%img の`処理待ち要請$ ~NEQ ~NULL
</li>
	<li>
%img の`現在の要請$ ~SET %img の`処理待ち要請$
◎
Let the img element's current request be the pending request.
</li>
	<li>
%img の`処理待ち要請$ ~SET ~NULL
◎
Let the img element's pending request be null.
</li>
</ol>

<p class="trans-note">【
最初の段は、
この訳による補完
（`現在の要請$は ~NULL をとり得ない）。
】</p>
</div>

					</section>
					<section id="preparing-an-image-for-presentation">
<h6 title="Preparing an image for presentation">4.8.4.3.6. 画像を呈示~用に準備する</h6>

<div class="algo">
<p>
`画像を呈示~用に準備する@
~algoは、
所与の
( 画像~要素 %img )
に対し：
◎
To prepare an image for presentation for an image request req given image element img:
</p>
<ol>
	<li>
<p>
%要請 ~LET %img の`現在の要請$
</p>

<p class="trans-note">【
この段は、
この訳による追加
— 原文の~algoは，`画像~要請$も引数にとっているが、
実際に この~algoが適用される`画像~要請$は，
%img の`現在の要請$に限られる。
】</p>
	</li>
	<li>
%~EXIF~tag~map ~LET %要請 の`画像~data$から
— 関連な~codecにより定義されるとおりに —
得される~EXIF~tag群
`EXIF$r
◎
Let exifTagMap be the EXIF tags obtained from req's image data, as defined by the relevant codec. [EXIF]
</li>
	<li>
( %物理-横幅, %物理-縦幅 ) ~LET 
%要請 の`画像~data$から
— 関連な~codecにより定義されるとおりに —
得される
( 横幅, 縦幅 )
◎
Let physicalWidth and physicalHeight be the width and height obtained from req's image data, as defined by the relevant codec.
</li>
	<li>
%寸法~X ~LET %~EXIF~tag~map の~tag `0xA002^c （ `PixelXDimension^i ）の値
◎
Let dimX be the value of exifTagMap's tag 0xA002 (PixelXDimension).
</li>
	<li>
%寸法~Y ~LET %~EXIF~tag~map の~tag `0xA003^c （ `PixelYDimension^i ）の値
◎
Let dimY be the value of exifTagMap's tag 0xA003 (PixelYDimension).
</li>
	<li>
%解像度~X ~LET %~EXIF~tag~map の~tag `0x011A^c （ `XResolution^i ）の値
◎
Let resX be the value of exifTagMap's tag 0x011A (XResolution).
</li>
	<li>
%解像度~Y ~LET %~EXIF~tag~map の~tag `0x011B^c （ `YResolution^i ）の値
◎
Let resY be the value of exifTagMap's tag 0x011B (YResolution).
</li>
	<li>
%解像度~単位 ~LET %~EXIF~tag~map の~tag `0x0128^c （ `ResolutionUnit^i ）の値
◎
Let resUnit be the value of exifTagMap's tag 0x0128 (ResolutionUnit).
</li>
	<li>
<p>
~IF［
~NOT ~AND↓
］…
</p>
		<ul>
			<li>
%寸法~X は整数である
</li>
			<li>
%寸法~Y は整数である
</li>
			<li>
%寸法~X ~GT 0
</li>
			<li>
%寸法~Y ~GT 0
</li>
			<li>
%解像度~X は浮動小数点数である
</li>
			<li>
%解像度~Y は浮動小数点数である
</li>
			<li>
%解像度~X ~GT 0
</li>
			<li>
%解像度~Y ~GT 0
</li>
			<li>
%解像度~単位 ~EQ 2 （ `Inch^i ）
</li>
			<li>
%物理-横幅 ~MUL 72 ~DIV %解像度~X ~EQ %寸法~X
【浮動小数点数の丸め誤差は、この比較に どう織り込まれる？】
</li>
			<li>
%物理-縦幅 ~MUL 72 ~DIV %解像度~Y ~EQ %寸法~Y
</li>
		</ul>
<p>
…ならば
⇒
~RET
</p>
◎
If either dimX or dimY is not a positive integer, then return.
◎
If either resX or resY is not a positive floating-point number, then return.
◎
If resUnit is not equal to 2 (Inch), then return.
◎
Let widthFromDensity be the value of physicalWidth, multiplied by 72 and divided by resX.
◎
Let heightFromDensity be the value of physicalHeight, multiplied by 72 and divided by resY.
◎
If widthFromDensity is not equal to dimX or heightFromDensity is not equal to dimY, then return.
</li>
	<li>
<p>
~IF［
%要請 の`画像~data$は`~CORS非同一-生成元$である
］：
</p>
		<ol>
			<li>
%img の ( `生来な横幅$, `生来な縦幅$ ) ~SET ( %寸法~X, %寸法~Y )
</li>
			<li>
前~段の設定に則って，
%img の画素~dataを拡縮する
</li>
			<li>
~RET
</li>
		</ol>
◎
If req's image data is CORS-cross-origin, then set img's natural dimensions to dimX and dimY, scale img's pixel data accordingly, and return.
</li>
	<li>
%要請 の`選好される密度~補正-済み寸法$ ~SET ( %寸法~X, %寸法~Y )
◎
Set req's preferred density-corrected dimensions to a struct with its width set to dimX and its height set to dimY.
</li>
	<li>
%img の呈示を適切に更新する
◎
Update req's img element's presentation appropriately.
</li>
</ol>

<p class="note">注記：
~EXIF内の解像度は，~CSS `pt$css 【！points per inch】に等価なので、
72 が解像度から~sizeを算出するための基底になる。
◎
Resolution in EXIF is equivalent to CSS points per inch, therefore 72 is the base for computing size from resolution.
</p>

<p class="XXX">
画像がすでに呈示された後に~EXIFが到着する事例でどうなるかは、
まだ指定されていない。
`~CSS課題 #4929＠~CSSissue/4929$を見よ。
◎
It is not yet specified what would be the case if EXIF arrives after the image is already presented. See issue #4929.
</p>
</div>

					</section>
					<section id="selecting-an-image-source">
<h5 title="Selecting an image source">4.8.4.3.7. 画像~sourceの選定-法</h5>

<div class="algo">
<p>
`画像~sourceを選定する@
~algoは、
所与の
( `img$e 要素 %要素 )
に対し：
◎
To select an image source given an img element el:
</p>
<ol>
	<li>
<p>
`~source集合を更新する$( %要素 )
</p>

<p class="trans-note">【
その結果、
%要素 の`~source集合$内のすべての~entryの`記述子$iSは，
`画素~密度~記述子$に正規化されることに注意。
】</p>
◎
Update the source set for el.
</li>
	<li>
~IF［
%要素 の`~source集合$は空である
］
⇒
~RET ( ε, ε )
◎
If el's source set is empty, return null as the URL and undefined as the pixel density.
</li>
	<li>
~RET `~source集合から画像~sourceを選定する$( %要素 の`~source集合$ )
◎
Return the result of selecting an image from el's source set.
</li>
</ol>
</div>

<div class="algo">
<p>
`~source集合から画像~sourceを選定する@
~algoは、
所与の
( `~source集合$ %~source集合 )
に対し，
( ~URLを与える文字列, `密度~値$ )
からなる~tupleを返す：
◎
To select an image source from a source set given a source set sourceSet:
</p>
<ol>
	<li>
%~source群 ~LET 空な集合
◎
↓</li>
	<li>
%~source集合 を成す
~EACH( ~entry %b )
に対し，順に
⇒
~IF［
%b の`記述子$iSの`密度~値$は %~source群 を成す どの~entryのそれとも異なる
］
⇒
%b を %~source群 に追加する
◎
If an entry b in sourceSet has the same associated pixel density descriptor as an earlier entry a in sourceSet, then remove entry b. Repeat this step until none of the entries in sourceSet have the same associated pixel density descriptor as an earlier entry.
</li>
	<li>
%選定された~source ~LET `実装定義$な方式で %~source群 から 1 個の `画像~source$を選んだ結果
◎
In an implementation-defined manner, choose one image source from sourceSet. Let this be selectedSource.
</li>
	<li>
~RET ( %選定された~source の`~URL文字列$iS, %選定された~source の`記述子$iSの`密度~値$ )
◎
Return selectedSource and its associated pixel density.
</li>
</ol>
</div>

					</section>
					<section id="creating-a-source-set-from-attributes">
<h6 title="Creating a source set from attributes">4.8.4.3.8. 属性~群からの~source集合の作成-法</h6>

<div class="algo">
<p>
`~source集合を作成する@
~algoは、
所与の
( 文字列 %既定の~source, 文字列 %~srcset, 文字列 %~sizes, ［
要素／~NULL
］ %img )
に対し：
◎
When asked to create a source set given a string default source, a string srcset, a string sizes, and an element or null img:
</p>
<ol>
	<li>
%~source集合 ~LET `~srcset属性を構文解析する$( %~srcset )
◎
Let source set be an empty source set.
◎
If srcset is not an empty string, then set source set to the result of parsing srcset.
</li>
	<li>
%~source集合 の【！】`~source~size$ ~LET `~sizes属性を構文解析する$( %~sizes, %img )
◎
Let source size be the result of parsing sizes with img.
</li>
	<li>
~IF［
%既定の~source ~NEQ 空~文字列
］~AND［
%~source集合 を成す どの`画像~source$も，その`記述子$iSは ε または［
`画素~密度~記述子$であって，その`密度~値$ ~NEQ 1
］を満たす
］
⇒
%~source集合 に %既定の~source を付加する
◎
If default source is not the empty string and source set does not contain an image source with a pixel density descriptor value of 1, and no image source with a width descriptor, append default source to source set.
</li>
	<li>
`~source密度を正規化する$( %~source集合 )
◎
Normalize the source densities of source set.
</li>
	<li>
~RET %~source集合
◎
Return source set.
</li>
</ol>
</div>

					</section>
					<section id="updating-the-source-set">
<h5 title="Updating the source set">4.8.4.3.9. ~source集合の更新-法</h5>

<div class="algo">
<p>
`~source集合を更新する@
~algoは、
所与の
( %要素 )
に対し：
◎
When asked to update the source set for a given img or link element el, user agents must do the following:
</p>
<ol>
	<li>
~Assert：
%要素 は［
`img$e ／ `link$e
］要素である
◎
↑</li>
	<li>
%要素~群 ~LET « »
◎
↓↓Set el's source set to an empty source set.
◎
Let elements be « el ».
↓↓
</li>
	<li>
%img ~LET ~NULL
◎
↓</li>
	<li>
<p>
~IF［
%要素 は `img$e 要素である
］：
</p>
		<ol>
			<li>
<p>
~IF［
%要素 の親は `picture$e 要素である
］
⇒
%要素~群 ~SET %要素 に先行する同胞である `source$e 要素たちが成す同順の~list
</p>

<p class="trans-note">【
この訳では、
この段で %要素~群 をこれらの `source^e 要素に絞り込んでおくことにより，
原文の~algoを少し簡潔に組み替えている。
】</p>
			</li>
			<li>
%img ~SET %要素
</li>
		</ol>
◎
If el is an img element whose parent node is a picture element, then replace the contents of elements with el's parent node's child elements, retaining relative order.
◎
Let img be el if el is an img element, otherwise null.
</li>
	<li>
%要素~群 に %要素 を付加する
◎
↑↑</li>
	<li>
<p>
%要素~群 を成す
~EACH( %子 )
に対し：
◎
For each child in elements:
</p>
		<ol>
			<li>
<p>
~IF［
%子 ~EQ %要素
］：
◎
If child is el:
</p>
				<ol>
					<li>
%既定の~source ~LET 空~文字列
◎
Let default source be the empty string.
</li>
					<li>
%~srcset ~LET 空~文字列
◎
Let srcset be the empty string.
</li>
					<li>
%~sizes ~LET 空~文字列
◎
Let sizes be the empty string.
</li>
					<li>
<p>
~IF［
%要素 は `img$e 要素である
］：
</p>
						<ol>
							<li>
~IF［
%要素 は `srcset$a 属性を有する
］
⇒
%~srcset ~SET その属性の値
</li>
							<li>
~IF［
%要素 は `sizes$a 属性を有する
］
⇒
%~sizes ~SET その属性の値
</li>
							<li>
~IF［
%要素 は `src$a 属性を有する
］
⇒
%既定の~source ~SET その属性の値
</li>
						</ol>
◎
↓</li>
					<li>
<p>
~ELSE（ %要素 は `link$e 要素である）：
</p>
						<ol>
							<li>
~IF［
%要素 は `imagesrcset$aL 属性を有する
］
⇒
%~srcset ~SET その属性の値
</li>
							<li>
~IF［
%要素 は `imagesizes$aL 属性を有する
］
⇒
%~sizes ~SET その属性の値
</li>
							<li>
~IF［
%要素 は `href$aL 属性を有する
］
⇒
%既定の~source ~SET その属性の値
</li>
						</ol>
◎
↑ If el is an img element that has a srcset attribute, then set srcset to that attribute's value.
◎
Otherwise, if el is a link element that has an imagesrcset attribute, then set srcset to that attribute's value.
◎
↑ If el is an img element that has a sizes attribute, then set sizes to that attribute's value.
◎
Otherwise, if el is a link element that has an imagesizes attribute, then set sizes to that attribute's value.
◎
↑ If el is an img element that has a src attribute, then set default source to that attribute's value.
◎
Otherwise, if el is a link element that has an href attribute, then set default source to that attribute's value.
</li>
					<li>
%要素 の`~source集合$ ~SET `~source集合を作成する$( %既定の~source, %~srcset, %~sizes, %img )
◎
Let el's source set be the result of creating a source set given default source, srcset, sizes, and img.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>

<p class="note">注記：
%要素 が `link^e 要素であるならば、
即時に この段に達して~~反復を終えることになる。
◎
If el is a link element, then elements contains only el, so this step will be reached immediately and the rest of the algorithm will not run.
</p>

			</li>
			<li>
~Assert：
%子 は `source$e 要素である
◎
If child is not a source element, then continue.
</li>
			<li>
~IF［
%子 は `srcset$aS 属性を有さない
］
⇒
~CONTINUE
◎
If child does not have a srcset attribute, continue to the next child.
</li>
			<li>
%~source集合 ~LET `~srcset属性を構文解析する$( %子 の`srcset$aS 属性の値 )
◎
Parse child's srcset attribute and let the returned source set be source set.
</li>
			<li>
<p>
~IF［
~OR↓
］…
</p>
				<ul>
					<li>
%~source集合 は空である
</li>
					<li>
［
%子 は `media$aS 属性を有する
］~AND［
その値は`環境に合致して$いない
］
</li>
					<li>
［
%子 は `type$aS 属性を有する
］~AND［
その値は［
未知／未~support
］な`~MIME型$である
］
</li>
				</ul>
<p>
…ならば
⇒
~CONTINUE
</p>
◎
If source set has zero image sources, continue to the next child.
◎
If child has a media attribute, and its value does not match the environment, continue to the next child.
◎
↓↓Parse child's sizes attribute with img, and let source set's source size be the returned value.
◎
If child has a type attribute, and its value is an unknown or unsupported MIME type, continue to the next child.
</li>
			<li>
%要素 の`寸法~属性~source$ ~SET ［
次が満たされるならば %子 ／
~ELSE_ %要素
］
⇒
%子 は［
`width$a, `height$a
］いずれかの属性を有する
◎
If child has width or height attributes, set el's dimension attribute source to child. Otherwise, set el's dimension attribute source to el.
</li>
			<li>
%~sizes ~LET ［
%子 は`~sizes属性$を有するならば その値 ／
~ELSE_ 空~文字列
］
◎
↑↑</li>
			<li>
%~source集合 の`~source~size$ ~LET
`~sizes属性を構文解析する$( %~sizes, %img )
◎
↑↑</li>
			<li>
`~source密度を正規化する$( %~source集合 )
◎
Normalize the source densities of source set.
</li>
			<li>
%要素 の`~source集合$ ~SET %~source集合
◎
Let el's source set be source set.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
</ol>
</div>

<p class="note">注記：
各 `img$e 要素は、
`画像~source$を選定するときに［
自身, および
自身に先行する同胞 `source$e 要素たち
］を独立と見なし、
他の（妥当でない）要素 — ［
同じ `picture$e 要素~内の他の `img$e 要素 ／
自身に後続する同胞の `source$e 要素
］は無視する。
◎
Each img element independently considers its previous sibling source elements plus the img element itself for selecting an image source, ignoring any other (invalid) elements, including other img elements in the same picture element, or source elements that are following siblings of the relevant img element.
</p>

					</section>
					<section id="parsing-a-srcset-attribute">
<h5 title="Parsing a srcset attribute">4.8.4.3.10. ~srcset属性の構文解析-法</h5>

<div class="algo">
<p>
`~srcset属性を構文解析する@
~algoは、
所与の
( 文字列 %入力 )
に対し：
◎
When asked to parse a srcset attribute from an element, parse the value of the element's srcset attribute as follows:
• Let input be the value passed to this algorithm.
</p>
<ol>
	<li>
%位置 ~LET %入力 の中の最初の文字を指している`位置~変数$
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%候補~list ~LET 空な`~source集合$
◎
Let candidates be an initially empty source set.
</li>
	<li>
<p>
~WHILE 無条件：
◎
Splitting loop:＼
</p>
		<ol>
			<li>
%入力 内の %位置 から
{ `~ASCII空白$, `002C^U `,^smb }
からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII whitespace or U+002C COMMA characters from input given position.＼
</li>
			<li>
~IF［
前~段にて 1 個~以上の文字 `002C^U `,^smb が収集された
］
⇒
`構文解析-~error$
◎
If any U+002C COMMA characters were collected, that is a parse error.
</li>
			<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET %候補~list
◎
If position is past the end of input, return candidates.
</li>
			<li>
%記述子 ~LET ε
◎
↓</li>
			<li>
%~URL ~LET
%入力 内の %位置 から
`~ASCII空白$以外の`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not ASCII whitespace from input given position, and let that be url.
◎
↓↓Let descriptors be a new empty list.
</li>
			<li>
<p>
~IF［
%~URL の最後の文字 ~EQ `002C^U `,^smb
］：
◎
If url ends with U+002C (,), then:
</p>

				<ol>
					<li>
%~URL の末尾から連続する文字 `002C^U `,^smb をすべて除去する
◎
Remove all trailing U+002C COMMA characters from url.＼
</li>
					<li>
~IF［
前~段で 2 個~以上の文字が除去された
］
⇒
`構文解析-~error$
◎
If this removed more than one character, that is a parse error.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
%記述子~list ~LET %入力 内の %位置 から記述子を~token化する†
</li>
					<li>
%記述子 ~SET 記述子~群を構文解析する( %記述子~list )†
</li>
					<li>
~IF［
%記述子 ~EQ `~error^i
］
⇒
~CONTINUE
</li>
				</ol>

<p class="trans-note">【†
これらの手続きは、
以下に定義される。
この訳では、
原文の~algoを，これらの手続きに分割して記述している。
】</p>
◎
Otherwise:
◎
↓↓</li>
			<li>
<p>
%画像~source ~LET 新たな`画像~source$
— その
⇒＃
`~URL文字列$iS ~SET %~URL,
`記述子$iS ~SET %記述子
◎
↓↓</li>
			<li>
%候補~list に %画像~source を付加する
◎
↓↓</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
%入力 内の %位置 から記述子を~token化するときは、
次を走らす
（これは、~call元の`位置~変数$も更新する）：
◎
Descriptor tokenizer:＼
</p>

<div>
<ol>
	<li>
%記述子~list ~LET 新たな空な~list
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
</li>
			<li>
%記述子~token ~LET 空~文字列
</li>
			<li>
%記述子~token に次の結果を付加する
⇒
%入力 内の %位置 から，次に挙げるもの以外の`符号位置~並びを収集する$
⇒＃
`~ASCII空白$, `002C^U `,^smb, `0028^U `(^smb
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ `0028^U `(^smb
］：
</p>
				<ol>
					<li>
%記述子~token に次の結果を付加する
⇒
%入力 内の %位置 から， `0029^U `)^smb 以外の`符号位置~並びを収集する$
</li>
					<li>
~IF［
%位置↗ ~EQ `0029^U `)^smb
］
⇒＃
%記述子~token に %位置↗ を付加する；
%位置 ~INCBY 1
</li>
				</ol>
			</li>
			<li>
~IF［
%記述子~token ~NEQ 空~文字列
］
⇒
%記述子~list に %記述子~token を付加する
</li>
			<li>
~IF［
%位置↗ は`~ASCII空白$でない
］
⇒
~BREAK
</li>
		</ol>
	</li>
	<li>
~RET %記述子~list
</li>
</ol>

◎
Skip ASCII whitespace within input given position.
◎
↑↓
◎
Let current descriptor be the empty string.
◎
Let state be in descriptor.
◎
Let c be the character at position. Do the following depending on the value of state. For the purpose of this step, "EOF" is a special character representing that position is past the end of input.
◎
In descriptor
• Do the following, depending on the value of c:

•• ASCII whitespace
••• If current descriptor is not empty, append current descriptor to descriptors and let current descriptor be the empty string. Set state to after descriptor.

•• U+002C COMMA (,)
••• Advance position to the next character in input. If current descriptor is not empty, append current descriptor to descriptors. Jump to the step labeled descriptor parser.

•• U+0028 LEFT PARENTHESIS (()
••• Append c to current descriptor. Set state to in parens.

•• EOF
••• If current descriptor is not empty, append current descriptor to descriptors. Jump to the step labeled descriptor parser.

•• Anything else
••• Append c to current descriptor.
◎
In parens

• Do the following, depending on the value of c:

•• U+0029 RIGHT PARENTHESIS ())
••• Append c to current descriptor. Set state to in descriptor.

•• EOF
••• Append current descriptor to descriptors. Jump to the step labeled descriptor parser.

•• Anything else
••• Append c to current descriptor.

◎
After descriptor

• Do the following, depending on the value of c:

•• ASCII whitespace
••• Stay in this state.

•• EOF
••• Jump to the step labeled descriptor parser.

•• Anything else
••• Set state to in descriptor. Set position to the previous character in input.
◎
Advance position to the next character in input. Repeat this step.
</div>

<p class="note">注記：
将来の追加と互換にするため、
この~algoは，複数の記述子と丸括弧を伴う記述子を~supportする。
◎
In order to be compatible with future additions, this algorithm supports multiple descriptors and descriptors with parens.
</p>

<p class="trans-note">【
原文による上の~algoは，（おそらく拡張を視野に）文字~単位で細かく処理しているが、
この訳では，流れを追いやすくなるよう等価な形に再構成している。
】</p>
</div>

<div class="algo">
<p>
記述子~群を構文解析するときは、
記述子 構文解析器は、
所与の
( %記述子~list )
に対し，次を走らす：
◎
Descriptor parser:＼
</p>

<ol>
	<li>
%~error ~LET  `no^i
◎
Let error be no.
</li>
	<li>
<p>
( %横幅, %縦幅, %密度 ) ~LET ( ε, ε, ε )
</p>

<p class="trans-note">【
%縦幅 （原文における名前は “`future-compat-h^en” ）は、
現時点では用を為さないが，
将来における追加と互換にするため予め処理に組み込まれている。
】</p>
◎
Let width be absent.
◎
Let density be absent.
◎
Let future-compat-h be absent.
</li>
	<li>
<p>
%記述子~list を成す
~EACH( %記述子~token )
に対し：
◎
For each descriptor in descriptors, run the appropriate set of steps from the following list:
</p>
		<ol>
			<li>
%種別 ~LET %記述子~token の最後の文字
◎
↓</li>
			<li>
%数 ~LET %記述子~token から最後の文字を除去した結果
◎
↓</li>
			<li>
<p>
~IF［
%種別 ~EQ `0077^U `w^smb
］~AND［
%数 は`妥当な負でない整数$である
］：
◎
If the descriptor consists of a valid non-negative integer followed by a U+0077 LATIN SMALL LETTER W character
</p>
				<ol>
					<li>
<p>
~IF［
~UAは `sizes$a 属性を~supportしない
］
⇒
%~error ~SET `yes^i
◎
If the user agent does not support the sizes attribute, let error be yes.
</p>

<p class="note">注記：
適合~UAは `sizes$a 属性を~supportすることになる。
しかしながら，実施においては、
~UAは概して，特能を漸増的に実装して出荷する。
◎
A conforming user agent will support the sizes attribute. However, user agents typically implement and ship features in an incremental manner in practice.
</p>
					</li>
					<li>
~IF［
%横幅 ~NEQ ε
］~OR［
%密度 ~NEQ ε
］
⇒
%~error ~SET `yes^i
◎
If width and density are not both absent, then let error be yes.
</li>
					<li>
%数 ~SET `負でない整数として構文解析する$( %数 )
◎
Apply the rules for parsing non-negative integers to the descriptor.＼
</li>
					<li>
~IF［
%数 ~EQ 0
］
⇒
%~error ~SET `yes^i
◎
If the result is 0, let error be yes.＼
</li>
					<li>
~ELSE
⇒
%横幅 ~SET %数
◎
Otherwise, let width be the result.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%種別 ~EQ `0078^U `x^smb
］~AND［
%数 は`妥当な浮動小数点数$である
］：
◎
If the descriptor consists of a valid floating-point number followed by a U+0078 LATIN SMALL LETTER X character
</p>
				<ol>
					<li>
~IF［
%横幅 ~NEQ ε
］~OR［
%密度 ~NEQ ε
］~OR［
%縦幅 ~NEQ ε
］
⇒
%~error ~SET `yes^i
◎
If width, density and future-compat-h are not all absent, then let error be yes.
</li>
					<li>
%数 ~SET `浮動小数点数として構文解析する$( %数 )
◎
Apply the rules for parsing floating-point number values to the descriptor.＼
</li>
					<li>
~IF［
%数 ~LT 0
］
⇒
%~error ~SET `yes^i
◎
If the result is less than 0, let error be yes.＼
</li>
					<li>
<p>
~ELSE
⇒
%密度 ~SET %数
◎
Otherwise, let density be the result.
</p>

<p class="note">注記：
［
%密度 ~EQ 0
］の場合、［
`生来な横幅$ ／ `生来な縦幅$
］は無限になる。
~UAには、
画像が描画され得る大きさを`制限することが期待される＠~INFRA#algorithm-limits$。
◎
If density is 0, the natural dimensions will be infinite. User agents are expected to have limits in how big images can be rendered.
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%種別 ~EQ `0068^U `h^smb
］~AND［
%数 は`妥当な負でない整数$である
］：
◎
If the descriptor consists of a valid non-negative integer followed by a U+0068 LATIN SMALL LETTER H character
</p>

				<ol>
					<li>
`構文解析-~error$
◎
This is a parse error.
</li>
					<li>
~IF［
%縦幅 ~NEQ ε
］~OR［
%密度 ~NEQ ε
］
⇒
%~error ~SET `yes^i
◎
If future-compat-h and density are not both absent, then let error be yes.
</li>
					<li>
%数 ~SET `負でない整数として構文解析する$( %数 )
◎
Apply the rules for parsing non-negative integers to the descriptor.＼
</li>
					<li>
~IF［
%数 ~EQ 0
］
⇒
%~error ~SET `yes^i
◎
If the result is 0, let error be yes.＼
</li>
					<li>
~ELSE
⇒
%縦幅 ~SET %数
◎
Otherwise, let future-compat-h be the result.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%~error ~SET `yes^i
◎
Anything else
◎
Let error be yes.
</li>
		</ol>
	</li>
	<li>
~IF［
%縦幅 ~NEQ ε
］~AND［
%横幅 ~EQ ε
］
⇒
%~error ~SET `yes^i
◎
If future-compat-h is not absent and width is absent, let error be yes.
</li>
	<li>
<p>
~IF［
%~error ~EQ `no^i
］：
</p>
		<ol>
			<li>
~IF［
%横幅 ~NEQ ε
］
⇒
~RET `横幅~値$に %横幅 を伴う`横幅~記述子$
</li>
			<li>
~IF［
%密度 ~NEQ ε
］
⇒
~RET `密度~値$に %密度 を伴う`画素~密度~記述子$
</li>
			<li>
~RET ε
</li>
		</ol>
◎
If error is still no, then append a new image source to candidates whose URL is url, associated with a width width if not absent and a pixel density density if not absent.＼
</li>
	<li>
`構文解析-~error$
◎
Otherwise, there is a parse error.
</li>
	<li>
~RET `~error^i
◎
Return to the step labeled splitting loop.
</li>
</ol>
</div>

					</section>
					<section id="parsing-a-sizes-attribute">
<h5 title="Parsing a sizes attribute">4.8.4.3.11. ~sizes属性の構文解析-法</h5>

<div class="algo">
<p>
`~sizes属性を構文解析する@
~algoは、
所与の
( 文字列 %入力, ［
`img$e 要素／~NULL
］ %img )
に対し：
◎
When asked to parse a sizes attribute from an element element, with an img element or null img:
</p>
<ol>
	<li>
%未解析~sizes~list ~LET `~commaで分離された成分~値~listとして構文解析する$( %入力 )
`CSSSYNTAX$r
◎
Let unparsed sizes list be the result of parsing a comma-separated list of component values from the value of element's sizes attribute (or the empty string, if the attribute is absent). [CSSSYNTAX]
</li>
	<li>
%~size ~LET ~NULL
◎
Let size be null.
</li>
	<li>
<p>
%未解析~sizes~list を成す
~EACH( %未解析~size )
に対し：
◎
For each unparsed size in unparsed sizes list:
</p>
		<ol>
			<li>
%未解析~size の~~終端から連続する `whitespace-token$t すべてを除去する
◎
Remove all consecutive &lt;whitespace-token&gt;s from the end of unparsed size.＼
</li>
			<li>
~IF［
%未解析~size は空である
］
⇒＃
`構文解析-~error$；
~CONTINUE
◎
If unparsed size is now empty, then that is a parse error; continue.
</li>
			<li>
%~size ~SET %未解析~size を成す最後の`成分~値$
◎
If the last component value in unparsed size＼
↓ is a valid non-negative &lt;source-size-value&gt;,＼
then set size to its value and＼
</li>
			<li>
%未解析~size から最後の`成分~値$を除去する
◎
remove the component value from unparsed size.＼
</li>
			<li>
<p>
~IF［
%~size は ~OR↓ を満たす
］…
</p>
				<ul>
					<li>
`source-size-value$t に合致しない
</li>
					<li>
`~math関数$以外の`~CSS関数$を含んでいる
</li>
					<li>
負な数を表す
</li>
				</ul>

<p>
…ならば
⇒＃
`構文解析-~error$；
~CONTINUE
</p>
◎
Any CSS function other than the math functions is invalid.＼
Otherwise, there is a parse error; continue.
</li>
			<li>
<div>
<p>
~IF［
~AND↓
］…
</p>
				<ul>
					<li>
%~size ~EQ `~auto0$v
</li>
					<li>
%img ~NEQ ~NULL
</li>
					<li>
%img は`具現化されて$いる
</li>
					<li>
%img は`自動-~sizeを許容して$いる
</li>
				</ul>
<p>
…ならば
⇒
%~size ~SET %img の`具象-~obj~size$を成す横幅を成す `px$css 数
</p>
◎
If size is auto, and img is not null, and img is being rendered, and img allows auto-sizes, then set size to the concrete object size width of img, in CSS pixels.
</div>

<p class="note">注記：
依然として %~size ~EQ `~auto0$v の場合、
%~size は無視されることになる。
◎
If size is still auto, then it will be ignored.
</p>
			</li>
			<li>
%未解析~size の終端から連続する `whitespace-token$t すべてを除去する
◎
Remove all consecutive &lt;whitespace-token&gt;s from the end of unparsed size.＼
</li>
			<li>
<p>
~IF［
%未解析~size は空である
］：
◎
If unparsed size is now empty:
</p>
				<ol>
					<li>
~IF［
%未解析~size は %未解析~sizes~list を成す最後の~itemでない
］
⇒
`構文解析-~error$
◎
If this was not the last item in unparsed sizes list, that is a parse error.
</li>
					<li>
~IF［
%~size ~NEQ `~auto0$v
］
⇒
~RET %~size
◎
If size is not auto, then return size.＼
</li>
					<li>
~CONTINUE
◎
Otherwise, continue.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%未解析~size は ~OR↓ を満たす `MQ$r
］…
</p>
				<ul>
					<li>
`media-condition$t に合致しない
</li>
					<li>
`media-condition$t として`評価した結果＠~MQ5#evaluating$は偽になる
</li>
				</ul>
<p>
…ならば
⇒
~CONTINUE
</p>
◎
Parse the remaining component values in unparsed size as a &lt;media-condition&gt;. If it does not parse correctly, or it does parse correctly but the &lt;media-condition&gt; evaluates to false, continue. [MQ]
</li>
			<li>
~IF［
%~size ~NEQ `~auto0$v
］
⇒
~RET %~size
◎
If size is not auto, then return size.＼
</li>
			<li>
~CONTINUE
◎
Otherwise, continue.
</li>
		</ol>
	</li>
	<li>
~RET `100vw^v
【すなわち，表示域の横幅】
◎
Return 100vw.
</li>
</ol>
</div>

<p class="note">注記：
`source-size-list$t 内の最後の~entry以外の~entry
— すなわち `source-size$t —
として［
`media-condition$t を伴わない `length$t のみ
］を利用することは妥当でない。
しかしながら，この構文解析-~algoは、
そのようなものを `source-size-list$t 内のどこでも許容する
— 最初に現れ次第，即時に~sizeとして受容することになる。
これは、［
将来の拡張を可能化するため
］および［
単純な作者~error（末尾の~commaなど）に抗して保護するため
］である。
`source-size$t 用の~keyword `~auto0$v は、
旧来の~UA用に［
それに後続する~entryによる~fallback
］を供するためとして，許容される。
◎
It is invalid to use a bare &lt;source-size-value&gt; that is a &lt;length&gt; (without an accompanying &lt;media-condition&gt;) as an entry in the &lt;source-size-list&gt; that is not the last entry. However, the parsing algorithm allows it at any point in the &lt;source-size-list&gt;, and will accept it immediately as the size if the preceding entries in the list weren't used. This is to enable future extensions, and protect against simple author errors such as a final trailing comma. A bare auto keyword is allowed to have other entries following it to provide a fallback for legacy user agents.
</p>

					</section>
					<section id="normalizing-the-source-densities">
<h5 title="Normalizing the source densities">4.8.4.3.12. ~source密度の正規化-法</h5>

<p>
`~source集合$を正規化することで、
それに含まれる どの`画像~source$の`記述子$iSも，`画素~密度~記述子$になる。
◎
An image source can have a pixel density descriptor, a width descriptor, or no descriptor at all accompanying its URL. Normalizing a source set gives every image source a pixel density descriptor.
</p>

<div class="algo">
<p>
`~source密度を正規化する@
~algoは、
所与の
( `~source集合$ %~source集合 )
に対し：
◎
When asked to normalize the source densities of a source set source set, the user agent must do the following:
</p>

<ol>
	<li>
%~source~size ~LET  %~source集合 の`~source~size$
◎
Let source size be source set's source size.
</li>
	<li>
<p>
%~source集合 を成す
~EACH( `画像~source$ %S )
に対し：
</p>
		<ol>
			<li>
%密度 ~LET 1
</li>
			<li>
~IF［
%S の`記述子$iSは`画素~密度~記述子$である
］
⇒
~CONTINUE
</li>
			<li>
<p>
~IF［
%S の`記述子$iSは`横幅~記述子$である
］
⇒
%密度 ~SET ( %S の`記述子$iSの`横幅~値$ ~DIV %~source~size )
</p>

<p class="note">注記：
［
%~source~size ~EQ 0
］の場合の密度は無限大になり、
( `生来な横幅$, `生来な縦幅$ ) は ( 0, 0 ) になる。
</p>
			</li>
			<li>
%S の`記述子$iS ~SET `密度~値$に %密度 を伴う`画素~密度~記述子$
</li>
		</ol>
◎
For each image source in source set:
• If the image source has a pixel density descriptor, continue to the next image source.
• Otherwise, if the image source has a width descriptor, replace the width descriptor with a pixel density descriptor with a value of the width descriptor value divided by the source size and a unit of x.
• If the source size is 0, then the density would be infinity, which results in the natural dimensions being 0 by 0.
• Otherwise, give the image source a pixel density descriptor of 1x.
</li>
</ol>
</div>

					</section>
					<section id="reacting-to-environment-changes">
<h5 title="Reacting to environment changes">4.8.4.3.13. 環境~変化に対する反応-法</h5>

<div class="algo">
<p>
~UAはいつでも、
`環境における変化に反応する@
ため，
次の~algoを走らせて`img$e 要素 %img の画像を更新してヨイ。
（~UAには、
この~algoを常時~走らすことは`要求されない^em
— 例えば［
利用者が当の~pageを見ていなくて，その間に環境が何度か変化する事例
］においては、
~UAは［
利用者が~pageに戻って来るまで，どの画像を利用するか決定するのを待機したい
］と求めるかもしれない。）
◎
The user agent may at any time run the following algorithm to update an img element's image in order to react to changes in the environment. (User agents are not required to ever run this algorithm; for example, if the user is not looking at the page any more, the user agent might want to wait until the user has returned to the page before determining which image to use, in case the environment changes again in the meantime.)
</p>

<p class="note">注記：
~UAには
— 特に［
利用者が`表示域$の~sizeを変更したとき
（例：~windowを~resizeしたときや，~page~zoomを変更したとき） ／
`img$e 要素が`文書の中へ挿入された$とき
］には —
この~algoを走らせて，［
`密度~補正-済み生来な~size$が新たな`表示域$に合致する
］かつ［
`~art-direction$が孕まれるときは、
正しい画像が選ばれる
］ようにすることが奨励される。
◎
User agents are encouraged to run this algorithm in particular when the user changes the viewport's size (e.g. by resizing the window or changing the page zoom), and when an img element is inserted into a document, so that the density-corrected natural width and height match the new viewport, and so that the correct image is chosen when art direction is involved.
</p>
<ol>
	<li>
<p>
次の手続きを`同期区間$として，この~algoの`安定~状態を待受ける$：
◎
Await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)
</p>
		<ol>
			<li>
%文書 ~LET %img の`~node文書$
◎
↓</li>
			<li>
~IF［
%img は`~srcsetまたは~pictureを利用して$いない
］~OR［
%文書 は`全部的に作動中$でない
］~OR［
%img の画像~dataの資源~型 ~EQ `multipart/x-mixed-replace$mt
］~OR［
%img の`処理待ち要請$ ~NEQ ~NULL
］
⇒
~RET
◎
⌛ If the img element does not use srcset or picture, its node document is not fully active, has image data whose resource type is multipart/x-mixed-replace, or the pending request is not null, then return.
</li>
			<li>
( %選定された~source, %選定された画素~密度 )
~LET `画像~sourceを選定する$( %img )
◎
⌛ Let selected source and selected pixel density be the URL and pixel density that results from selecting an image source, respectively.
</li>
			<li>
~IF［
%選定された~source ~EQ ε
］
⇒
~RET
◎
⌛ If selected source is null, then return.
</li>
			<li>
~IF［
%選定された~source ~EQ %img の`最後に選定された~source$
］~AND［
%選定された画素~密度 ~EQ %img の`現在の画素~密度$
］
⇒
~RET
◎
⌛ If selected source and selected pixel density are the same as the element's last selected source and current pixel density, then return.
</li>
			<li>
%~URL~record ~LET `~URLを符号化法の下で相対的に構文解析する$( %選定された~source, %文書 )
【！#encoding-parsing-and-serializing-a-url】
◎
⌛ Let urlString be the result of encoding-parsing-and-serializing a URL given selected source, relative to the element's node document.
</li>
			<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~RET
◎
⌛ If urlString is failure, then return.
</li>
			<li>
%~URL文字列 ~LET `~URLを直列化する$( %~URL~record )
◎
↑↑</li>
			<li>
%~CORS属性~状態 ~LET %img の `crossorigin$a 内容~属性の状態
◎
⌛ Let corsAttributeState be the state of the element's crossorigin content attribute.
</li>
			<li>
%生成元 ~LET ［
%~CORS属性~状態 ~EQ `~CORSなし$st ならば ε ／
~ELSE_ %文書 の`生成元$doc
］
◎
↓
◎
⌛ Let origin be the img element's node document's origin.
</li>
			<li>
%~client ~LET %文書 に`関連な設定群~obj$
◎
⌛ Let client be the img element's node document's relevant settings object.
</li>
			<li>
%~key ~LET
( %~URL文字列, %~CORS属性~状態, %生成元 )
からなる~tuple
◎
⌛ Let key be a tuple consisting of urlString, corsAttributeState, and, if corsAttributeState is not No CORS, origin.
</li>
			<li>
%画像~要請 ~LET 新たな`画像~要請$
◎
⌛ Let image request be a new image request＼
</li>
			<li>
%画像~要請 の`現在の~URL$ ~SET %~URL文字列
◎
whose current URL is urlString.
</li>
			<li>
%img の`処理待ち要請$ ~LET %画像~要請
◎
⌛ Let the element's pending request be image request.
</li>
		</ol>
<p>
`同期区間$はここで終端する
— 以降の手続きは、
同期区間を走らせ終えてから，`並列的$に走らすことになる。
◎
End the synchronous section, continuing the remaining steps in parallel.
</p>
	</li>
	<li>
~IF［
`可用な画像~list$内に %~key に対応する~entryはある
］
⇒
%画像~要請 の`画像~data$ ~SET その~entryの`画像~data$
◎
If the list of available images contains an entry for key, then set image request's image data to that of the entry. Continue to the next step.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%要請 ~LET `~CORSになり得る要請を作成する$( %~URL~record, `image^l , %~CORS属性~状態 )
◎
Let request be the result of creating a potential-CORS request given urlString, "image", and corsAttributeState.
</li>
			<li>
%要請 の
⇒＃
`~client$rq ~SET %~client,
`起動元$rq ~SET `imageset^l,
`同期~flag$rq  ~SET ~T,
`~referrer施策$rq ~SET %img の `referrerpolicy$a 属性の現在の状態,
`優先度$rq ~SET %img の `fetchpriority$a 属性の現在の状態
◎
Set request's client to client, initiator to "imageset", and set request's synchronous flag.
◎
Set request's referrer policy to the current state of the element's referrerpolicy attribute.
◎
Set request's priority to the current state of the element's fetchpriority attribute.
</li>
			<li>
%応答 ~LET %要請 を用いて`~fetch$した結果
◎
Let response be the result of fetching request.
</li>
			<li>
<p>
~IF［
~OR↓
］…
◎
↓</p>

				<ul>
					<li>
%応答 の`安全でない応答$は`~network~error$である
◎
If response's unsafe response is a network error or＼
</li>
					<li>
`画像を特定的に~sniffするための規則$を`適用して決定される＠#img-determine-type$画像の形式は未~supportである
◎
if the image format is unsupported (as determined by applying the image sniffing rules, again as mentioned earlier), or＼
</li>
					<li>
~UAは、
次を決定できる
⇒
%画像~要請 の画像は、
何らかの致命的な仕方で，画像の寸法を得せないまでに破損している
◎
if the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, or＼
</li>
					<li>
画像~資源の型 ~EQ `multipart/x-mixed-replace$mt
◎
if the resource type is multipart/x-mixed-replace,＼
</li>
				</ul>
<p>
…ならば
⇒＃
%img の`処理待ち要請$ ~SET ~NULL；
~RET
◎
then let pending request be null and abort these steps.
</p>
			</li>
			<li>
~ELSE（ %応答 の`安全でない応答$は %画像~要請 の`画像~data$を表現する）
⇒
%応答 は`~CORS同一-生成元$にも`~CORS非同一-生成元$にもなり得る
— どちらになるかに応じて，当の画像と他の~APIとのヤリトリに影響する（例： `canvas$e 上で利用されるとき）。
◎
Otherwise, response's unsafe response is image request's image data. It can be either CORS-same-origin or CORS-cross-origin; this affects the image's interaction with other APIs (e.g., when used on a canvas).
</li>
		</ol>
	</li>
	<li>
<p>
`要素~taskを~queueする$( `~DOM操作~task~source$, %img, 次の手続き )
◎
Queue an element task on the DOM manipulation task source given the img element and＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li>
~IF［
%img はこの~algoを開始した時点から`関連な変異$を経た
］
⇒＃
%img の`処理待ち要請$ ~LET ~NULL；
~RET
◎
If the img element has experienced relevant mutations since this algorithm started, then let pending request be null and abort these steps.
</li>
			<li>
%img の
( `最後に選定された~source$, `現在の画素~密度$ ) ~SET
( %選定された~source, %選定された画素~密度 )
◎
Let the img element's last selected source be selected source and the img element's current pixel density be selected pixel density.
</li>
			<li>
%画像~要請 の`状態$ ~SET `完全に可用$st
◎
Set the image request's state to completely available.
</li>
			<li>
%文書 の`可用な画像~list$に，画像を追加する
— この画像は
⇒
~key %~key で識別され,
`上層~cachingは無視するか$は ~T にするとする
◎
Add the image to the list of available images using the key key, with the ignore higher-layer caching flag set.
</li>
			<li>
%img の`処理待ち要請を現在の要請に昇格する$
◎
Upgrade the pending request to the current request.
</li>
			<li>
`画像を呈示~用に準備する$( %img )
◎
Prepare image request for presentation given the img element.
</li>
			<li>
`~eventを発火する$( %img, `load$et )
◎
Fire an event named load at the img element.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

					</section>
				</section>
				<section id="alt">
<h5 title="Requirements for providing text to act as an alternative for images">4.8.4.4. 画像~用の代替として動作する~textを供するときの要件</h5>

<p class="trans-note">【
この節の内容は、
`別~page＠~HEimageAlt$にて。
】</p>

				</section>
			</section>
			<section id="the-map-element">
<h4 title="The map element">4.8.12. `map^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$／`句ng内容$／`可触~内容$
◎
Flow content.
◎
Phrasing content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`句ng内容$が期待される所。
◎
Where phrasing content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`透過的$
◎
Transparent.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`name$a
— `usemap$a 属性から`参照-$するための， `画像~map$の名前
◎
name — Name of image map to reference from the usemap attribute
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`map$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLMapElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute DOMString `name$m;
  [SameObject] readonly attribute `HTMLCollection$I `areas$m;
};
</pre>
</dd>
	</dl>

<p>
`map$e 要素は、
`img$e 要素, および
子孫の `area$e 要素との併用で，`画像~map$を定義する。
この要素は、
その子たちを`表現-$する。
◎
The map element, in conjunction with an img element and any area element descendants, defines an image map. The element represents its children.
</p>

<p>
`name@a
属性は、
この~mapに名前を与えて，他から`参照-$できるようにする。
`map$e 要素は、
この属性を有していなければナラナイ。
この属性には、［
`~ASCII空白$を含む文字列／空~文字列
］を指定してはナラナイ。
また、［
同じ`~tree$内の別の `map$e 要素の `name$a 属性の値
］と等しくなってはナラナイ。
`id$a 属性も指定された場合、
両~属性とも同じ値にしなければナラナイ。
◎
The name attribute gives the map a name so that it can be referenced. The attribute must be present and must have a non-empty value with no ASCII whitespace. The value of the name attribute must not be equal to the value of the name attribute of another map element in the same tree. If the id attribute is also specified, both attributes must have the same value.
</p>

<dl class="domintro">

	<dt>%map.`areas$m</dt>
	<dd>
この `map$e 内の `area$e 要素たちからなる `HTMLCollection$I を返す。
◎
Returns an HTMLCollection of the area elements in the map.
</dd>
</dl>

<div class="algo">
`areas@m
取得子~手続きは
⇒
~RET 次のようにされた `HTMLCollection$I
⇒＃
根は コレ,
~filterは `area$e 要素のみに合致する
◎
The areas attribute must return an HTMLCollection rooted at the map element, whose filter matches only area elements.
</div>

<p>
`name@m
~IDL属性は、
`name$a 内容~属性を`反映する$モノトスル。
◎
The IDL attribute name must reflect the content attribute of the same name.
</p>

<div class="example">

<p>
画像~mapは、
保守し易くなるよう，
~page上の他の内容との併用により定義できる。
次の~page例には、
先頭に画像~mapがあり，末尾に対応する一連の~text~linkがある。
◎
Image maps can be defined in conjunction with other content on the page, to ease maintenance. This example is of a page with an image map at the top of the page and a corresponding set of text links at the bottom.
</p>

`map-1^xCode
</div>

			</section>
			<section id="the-area-element">
<h4 title="The area element">4.8.13. `area^e 要素</h4>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$ ／ `句ng内容$
◎
Flow content.
◎
Phrasing content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`句ng内容$が期待される所
— ただし、
先祖に `map$e 要素がある場合に限る。
◎
Where phrasing content is expected, but only if there is a map element ancestor.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$。
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了~tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`~alt0$a
— 画像が可用でないときに利用される代用~text
◎
alt — Replacement text for use when images are not available
</dd>
	<dd>
`coords$a
— `画像~map$内に作成される図形の座標を与える
◎
coords — Coordinates for the shape to be created in an image map
</dd>
	<dd>
`shape$a
— `画像~map$内に作成される図形の種類を与える
◎
shape — The kind of shape to be created in an image map
</dd>
	<dd>
`href$a
— `~hyperlink$の~addressを与える
◎
href — Address of the hyperlink
</dd>
	<dd>
`target$a
— `~hyperlink$による`~navi$用の`~navigable$を与える。
◎
target — Navigable for hyperlink navigation
</dd>
	<dd>
`download$a
— 資源へ~navigateする代わりに，それを~downloadするかどうか, および
そうする場合の~filenameを与える
◎
download — Whether to download the resource instead of navigating to it, and its filename if so
</dd>
	<dd>
`ping$a
— ~pingする`~URL$を与える
◎
ping — URLs to ping
</dd>
	<dd>
`rel$a
— 当の`~hyperlink$を包含している文書における所在と行先~資源との関係性を与える
◎
rel — Relationship between the location in the document containing the hyperlink and the destination resource
</dd>
	<dd>
`~referrerpolicy0$a
— この要素により起動される`~fetch$用の`~referrer施策$
◎
referrerpolicy — Referrer policy for fetches initiated by the element
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
要素は `href$a 属性を有する場合
⇒
`area$AA
◎
If the element has an href attribute: for authors; for implementers.
</dd>
	<dd>
他の場合
⇒
`area-no-href$AA
◎
Otherwise: for authors; for implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLAreaElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute DOMString `alt$mA;
  [`CEReactions$] attribute DOMString `coords$mA;
  [`CEReactions$] attribute DOMString `shape$mA;
  [`CEReactions$] attribute DOMString `target$mA;
  [`CEReactions$] attribute DOMString `download$mA;
  [`CEReactions$] attribute USVString `ping$mA;
  [`CEReactions$] attribute DOMString `rel$mA;
  [SameObject, PutForwards=`value$m] readonly attribute `DOMTokenList$I `relList$mA;
  [`CEReactions$] attribute DOMString `referrerPolicy$mA;

  // `HTMLAreaElement$obsMb
};
`HTMLAreaElement$I includes `HTMLHyperlinkElementUtils$I;
</pre>
	</dd>
</dl>

<p>
`area$e 要素は、
次のいずれかを`表現-$する
⇒＃
何らかの~textを伴う~hyperlinkと それに対応する`画像~map$上の区画 ／
無反応な区画
◎
The area element represents either a hyperlink with some text and a corresponding area on an image map, or a dead area on an image map.
</p>

<p>
`area$e 要素に親~nodeがある場合、
その いずれかの先祖は `map$e 要素でなければナラナイ。
◎
An area element with a parent node must have a map element ancestor.
</p>

<p>
`area$e 要素が `href$a 属性を有する場合、
要素は`~hyperlink$を表現する。
この事例では、
要素は
`~alt0@a
属性も有していなければナラナイ。
それは、
当の~hyperlinkを成す~textを指定する。
この~textは：
◎
If the area element has an href attribute, then the area element represents a hyperlink. In this case, the alt attribute must be present. It specifies the text of the hyperlink. Its value＼
</p>
<ul>
	<li>
次を利用者に供するものでなければナラナイ
⇒
［［
当の`画像~map$を成す他の~hyperlink用に指定された~text, 当の画像を成す代替~text
］を伴うが，当の画像を伴わずに呈示される
］ときに［
当の~hyperlinkが［
この~textを伴わずに，当の画像に当の図形を適用した上で利用された
］とするとき
］と同じ種類の~~選択肢
◎
must be text that, when presented with the texts specified for the other hyperlinks of the image map, and with the alternative text of the image, but without the image itself, provides the user with the same kind of choice as the hyperlink would when used without its text but with its shape applied to the image.＼
</li>
	<li>
<p>
ただし、［
当の`画像~map$を成す別の `area$e 要素として ~AND↓ を満たすもの
］が在る場合，
~~空にしてもヨイ：
</p>
		<ul>
			<li>
当の~hyperlinkと同じ資源を指す`~hyperlink$を表現している
</li>
			<li>
`~alt0$a 属性を有していて，その値は~~空でない
</li>
		</ul>
◎
The alt attribute may be left blank if there is another area element in the same image map that points to the same resource and has a non-blank alt attribute.
</li>
</ul>

<div class="p">
<p>
`area$e 要素が `href$a 属性を有さない場合：
</p>
<ul>
	<li>
要素が表現する区画を選択できなくするモノトスル。
</li>
	<li>
`~alt0$a 属性を省略しなければナラナイ。
</li>
</ul>
◎
If the area element has no href attribute, then the area represented by the element cannot be selected, and the alt attribute must be omitted.
</div>

<p>
`href$a 属性を有するかどうかを問わず，［
`shape$a, `coords$a
］属性が当の区画を指定する。
◎
In both cases, the shape and coords attributes specify the area.
</p>

<p>
`shape@a
属性は、
`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The shape attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>適合か
<th>状態
<th>概略的な記述
<tbody>

<tr><td>`circle@v
<td>
<td rowspan="2">`真円$st
<td rowspan="2">
当の区画は、［
`coords$a 属性の値を成す正確に 3 個の整数
］を利用して~design化される真円になる。
<tr><td>`circ@v
<td>否

<tr><td>`default@v
<td>
<td>`既定$st
<td>
当の区画は、
画像~全体になる
（ `coords$a 属性は利用されない）。

<tr><td>`poly@v
<td>
<td rowspan="2">`多角形$st
<td rowspan="2">
当の区画は、［
`coords$a 属性の値を成す 6 個以上の整数
］を利用して~design化される多角形になる。

<tr><td>`polygon@v
<td>否

<tr><td>`rect@v
<td>
<td rowspan="2">`矩形$st
<td rowspan="2">
当の区画は、［
`coords$a 属性の値を成す正確に 4 個の整数
］を利用して~design化される矩形になる。

<tr><td>`rectangle@v
<td>否

</table>

<p class="trans-note">【
略称 `circ^v は適合しない一方で、
略称［
`poly^v ／ `rect^v
］は適合することに注意。
】</p>

◎
Keyword｜Conforming｜State｜Brief description
circle｜｜Circle state｜Designates a circle, using exactly three integers in the coords attribute.
circ｜No｜｜
default｜｜Default state｜This area is the whole image. (The coords attribute is not used.)
poly｜｜Polygon state｜Designates a polygon, using at-least six integers in the coords attribute.
polygon｜No｜｜
rect｜｜Rectangle state｜Designates a rectangle, using exactly four integers in the coords attribute.
rectangle｜No｜｜
</div>

<p>
`shape$a 属性の［
`欠落~値~用の既定の状態$, `妥当でない値~用の既定の状態$
］は、
いずれも `矩形$st とする。
◎
The attribute's missing value default and invalid value default are both the rectangle state.
</p>

<p>
`coords@a
属性に指定する値は、
`妥当な浮動小数点数~list$を包含しなければナラナイ。
この属性は、
`shape$a 属性が述べる図形の座標を与える。
この属性の処理については、
`画像~map$処理~modelの一部として述べられる。
加えて，この属性は、
`area$e 要素の `shape$a 属性の状態に応じて，
以下に挙げる要件を満たさなければナラナイ
— 以下に述べる どの座標も，画像の左上隅から相対的に［
1 個目の成分は右方,
2 個目の成分は下方
］への距離を `px$css 数で表すとする：
◎
The coords attribute must, if specified, contain a valid list of floating-point numbers. This attribute gives the coordinates for the shape described by the shape attribute. The processing for this attribute is described as part of the image map processing model.
</p>

<dl>
	<dt>`真円@st</dt>
	<dd>
この状態の下では、
要素は `coords$a 属性を有していて，
その値は次を満たさなければナラナイ
⇒
［
3 個の整数からなる
］~AND［
3 個目の整数 ~GTE 0
］
◎
In the circle state, area elements must have a coords attribute present, with three integers, the last of which must be non-negative.＼
</dd>
	<dd>
( 1，2 ) 個目の整数が成す座標は 真円の中心,
3 個目の整数は 真円の半径を表現するモノトスル。
◎
The first integer must be the distance in CSS pixels from the left edge of the image to the center of the circle, the second integer must be the distance in CSS pixels from the top edge of the image to the center of the circle, and the third integer must be the radius of the circle, again in CSS pixels.
</dd>

	<dt>`既定@st</dt>
	<dd>
この状態の下では、
要素は `coords$a 属性を有してはナラナイ（区画は画像~全体になる）。
◎
In the default state, area elements must not have a coords attribute. (The area is the whole image.)
</dd>

	<dt>`多角形@st</dt>
	<dd>
この状態の下では、
要素は `coords$a 属性を有していて，
その値は次を満たさなければナラナイ
⇒
6 個~以上かつ偶数~個の整数からなる
◎
In the polygon state, area elements must have a coords attribute with at least six integers, and the number of integers must be even.＼
</dd>
	<dd>
各 正~整数 %i に対し、
( %i ~MUL 2 ~MINUS 1, %i ~MUL 2 )
個目の整数が成す座標は，多角形の %i 個目の頂点を表現するモノトスル。
◎
Each pair of integers must represent a coordinate given as the distances from the left and the top of the image in CSS pixels respectively, and all the coordinates together must represent the points of the polygon, in order.
</dd>

	<dt>`矩形@st</dt>
	<dd>
この状態の下では、
要素は `coords$a 属性を有していて，
その値は次を満たさなければナラナイ
⇒
［
4 個の整数 %x1, %y1, %x2, %y2 からなる
］~AND［
%x1 ~LT %x2
］~AND［
%y1 ~LT %y2
］
◎
In the rectangle state, area elements must have a coords attribute with exactly four integers, the first of which must be less than the third, and the second of which must be less than the fourth.＼
</dd>
	<dd>
座標［
( %x1, %y1 ) は矩形の左上隅,
( %x2, %y2 ) は矩形の右下隅
］を表現するモノトスル。
◎
The four points must represent, respectively, the distance from the left edge of the image to the left side of the rectangle, the distance from the top edge to the top side, the distance from the left edge to the right side, and the distance from the top edge to the bottom side, all in CSS pixels.
</dd>
</dl>

<p>
~UAは、
`area$e 要素を利用して作成された［
`~hyperlinkを追う$／
`~hyperlinkを~downloadする$
］ことを利用者に許容するときに，~linkをどう追うかは、［
`href$a, `target$a, `download$a, `ping$a
］属性により裁定される。
~UAは、
利用者が~linkを追う前に，
`rel$a 属性を利用して，
~target資源に見込まれる資質を利用者に指示してもヨイ。
◎
When user agents allow users to follow hyperlinks or download hyperlinks created using the area element, the href, target, download, and ping attributes decide how the link is followed. The rel attribute may be used to indicate to the user the likely nature of the target resource before the user follows the link.
</p>

<p>
`area$e 要素が
`href$a 属性を有さない場合、［
`target$a ／ `download$a ／ `ping$a ／ `rel$a ／ `~referrerpolicy0$a
］属性も有してはナラナイ。
◎
The target, download, ping, rel, and referrerpolicy attributes must be omitted if the href attribute is not present.
</p>

<p>
`area$e 要素が
`itemprop$a 属性を有する場合、
`href$a 属性も有していなければナラナイ。
◎
If the itemprop attribute is specified on an area element, then the href attribute must also be specified.
</p>

<div class="p">
<p>
`alt@mA
~IDL属性は、
`~alt0$a 内容~属性を`反映する$モノトスル。
</p>

<p>
`coords@mA
~IDL属性は、
`coords$a 内容~属性を`反映する$モノトスル。
</p>

<p>
`shape@mA
~IDL属性は、
`shape$a 内容~属性を`反映する$モノトスル。
</p>

<p>
`target@mA
~IDL属性は、
`target$a 内容~属性を`反映する$モノトスル。
</p>

<p>
`download@mA
~IDL属性は、
`download$a 内容~属性を`反映する$モノトスル。
</p>

<p>
`ping@mA
~IDL属性は、
`ping$a 内容~属性を`反映する$モノトスル。
</p>

<p>
`rel@mA
~IDL属性は、
`rel$a 内容~属性を`反映する$モノトスル。
</p>
◎
The IDL attributes alt, coords, shape, target, download, ping, and rel, each must reflect the respective content attributes of the same name.
</div>

<p>
`relList@mA
~IDL属性は、
`rel$a 内容~属性を`反映する$モノトスル。
◎
The IDL attribute relList must reflect the rel content attribute.
</p>

<p>
`referrerPolicy@mA
~IDL属性は、
`既知な値のみに制限され$る下で，
`~referrerpolicy0$a 内容~属性を`反映する$モノトスル。
◎
The IDL attribute referrerPolicy must reflect the referrerpolicy content attribute, limited to only known values.
</p>

			</section>
			<section id="image-maps">
<h4 title="Image maps">4.8.14. 画像~map</h4>

				<section id="authoring">
<h5 title="Authoring">4.8.14.1. 著作-法</h5>

<p>
`画像~map@
は、
画像~上の幾何的な区画に`~hyperlink$を結付けることを可能にする。
◎
An image map allows geometric areas on an image to be associated with hyperlinks.
</p>

<p>
`img$e 要素による画像には、
当の要素~上に
`usemap@a
属性を指定することにより，
（ `map$e 要素による）画像~mapが結付けられてもヨイ。
`usemap$a 属性に指定する値は、
ある `map$e 要素を指す`妥当な~hash名~参照$でなければナラナイ。
◎
An image, in the form of an img element, may be associated with an image map (in the form of a map element) by specifying a usemap attribute on the img element. The usemap attribute, if specified, must be a valid hash-name reference to a map element.
</p>

<div class="example">

<p>
次のような見かけの画像を考える：
◎
Consider an image that looks as follows:
</p>

<figure>`sample-usemap^dgm
<figcaption>
等間隔に並んだ， 4 個の縁取りのある図形：
栗色の穴あき四角形, 緑色の円, 紺色の三角形, 黄色の十文字星形
◎
A line with four shapes in it, equally spaced: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.
</figcaption></figure>

<p>
色付けられた区画だけ~click可能にさせたい場合、
次にようにして行える：
◎
If we wanted just the colored areas to be clickable, we could do it as follows:
</p>

`usemap-1^xCode
</div>

				</section>
				<section id="image-map-processing-model">
<h5 title="Processing model">4.8.14.2. 処理~model</h5>

<p>
`img$e 要素 %要素 が `usemap$a 属性 %属性 を有する場合、
~UAは，以下に従って処理するモノトスル：
◎
If an img element has a usemap attribute specified, user agents must process it as follows:
</p>
<ol>
	<li>
%~map ~LET `map$e 要素を指す`~hash名~参照として構文解析する$( %属性 の値, %要素 )
◎
Parse the attribute's value using the rules for parsing a hash-name reference to a map element, with the element as the context node. This will return either an element (the map) or null.
</li>
	<li>
~IF［
%~map ~EQ ~NULL
］
⇒
~RET
（以降，画像は画像~mapには結付けられない。）
◎
If that returned null, then return. The image is not associated with an image map after all.
</li>
	<li>
%area群 ~LET %~map の子孫である `area$e 要素たちが成す集合
◎
Otherwise, the user agent must collect all the area elements that are descendants of the map. Let those be the areas.
</li>
</ol>

<p>
対話的な~UAは、
上で得された %area群 を［
次に挙げる 2 とおりの仕方いずれか
］に従って処理するモノトスル：
◎
Having obtained the list of area elements that form the image map (the areas), interactive user agents must process the list in one of two ways.
</p>

<dl>
	<dt>
~UAは、
`img$e 要素が表現する~textを示すことを意図する場合：
◎
If the user agent intends to show the text that the img element represents, then it must use the following steps.
</dt>
	<dd>
		<ol>
			<li>
<p>
この段における %~hyperlink条件 は、
所与の `area$e 要素が次を満たすことをいう
⇒
［
`href$a 属性を有する
］~AND［
`~alt0$a 属性を有する
］
</p>

<p>
%area群 から ~OR↓ を満たす `area$e 要素たちを除去する：
</p>
				<ul>
					<li>
~NOT %~hyperlink条件
</li>
					<li>
［
%~hyperlink条件
］~AND［
`~alt0$a 属性の値 ~EQ 空~文字列
］~AND［
%area群 内に次を満たす別の `area$e 要素 %A が在る
］
⇒
［
%~hyperlink条件
］~AND［
%A の `~alt0$a 属性の値 ~NEQ 空~文字列
］~AND［
%A の `href$a 属性の値 ~EQ 当の要素の `href$a 属性の値
］
</li>
				</ul>
◎
Remove all the area elements in areas that have no href attribute.
◎
Remove all the area elements in areas that have no alt attribute,＼
or whose alt attribute's value is the empty string, if there is another area element in areas with the same value in the href attribute and with a non-empty alt attribute.
</li>
			<li>
前~段の結果の %area群 を成す各 `area$e 要素は、
`~hyperlink$を表現する
— それらの~hyperlinkはすべて、
`img$e の~textに結付けられる方式で利用者に可用にされるべきである。
◎
Each remaining area element in areas represents a hyperlink. Those hyperlinks should all be made available to the user in a manner associated with the text of the img.
</li>
		</ol>
	</dd>
	<dd>
この文脈においては、~UAは，［
`area$e ／ `img$e
］要素のうち `alt^a 属性を［
有さないか、
有していて，何らかの可視でない~text（空~文字列も含む）が指定されたもの
］を`実装定義$な流儀で［
作者が供した相応しい~textの欠如を指示することが意図される
］よう表現してもヨイ。
◎
In this context, user agents may represent area and img elements with no specified alt attributes, or whose alt attributes are the empty string or some other non-visible text, in an implementation-defined fashion intended to indicate the lack of suitable author-provided text.
</dd>

	<dt>
~UAは、［
画像を示す
］かつ［
画像とヤリトリして~hyperlinkを選択することを利用者に許容する
］ことを意図する場合：
◎
If the user agent intends to show the image and allow interaction with the image to select hyperlinks,＼
</dt>
	<dd>
画像は、［
%area群 内の各 `area$e 要素から取り出された図形たちが成す集合
］に結付けられるモノトスル
— %~map 内の図形たちは、［
`~tree順序$で最初に近いものほど利用者から見て手前
］になるよう多層化するものとする。
◎
then the image must be associated with a set of layered shapes, taken from the area elements in areas, in reverse tree order (so the last specified area element in the map is the bottom-most shape, and the first element in the map, in tree order, is the top-most shape).
</dd>
</dl>

<div class="algo">
<p>
%area群 内の各 `area$e 要素 %要素 に対しては、
当の画像に重ねる［
%要素 が表現する図形の層
］を次に従って得するモノトスル：
◎
Each area element in areas must be processed as follows to obtain a shape to layer onto the image:
</p>

<ol>
	<li>
%状態 ~LET %要素 の `shape$a 属性の状態
◎
Find the state that the element's shape attribute represents.
</li>
	<li>
%座標s ~LET %要素 は `coords$a 属性を
⇒＃
有するならば `浮動小数点数~listとして構文解析する$( 属性の値 ) ／
有さないならば空な~list
◎
Use the rules for parsing a list of floating-point numbers to parse the element's coords attribute, if it is present, and let the result be the coords list. If the attribute is absent, let the coords list be the empty list.
</li>
	<li>
%必要個数 ~LET %状態 に応じて
⇒＃
`真円$st ならば 3 ／
`既定$st ならば 0 ／
`多角形$st ならば 6 ／
`矩形$st ならば 4
◎
If the number of items in the coords list is less than the minimum number given for the area element's current state, as per the following table, then the shape is empty; return.
◎
State 	Minimum number of items
Circle state 	3
Default state 	0
Polygon state 	6
Rectangle state 	4 
</li>
	<li>
~IF［
%座標s の`~size$ ~LT %必要個数
］
⇒
~RET ε（図形は空）
◎
Check for excess items in the coords list as per the entry in the following list corresponding to the shape attribute's state:
• Circle state
•• Drop any items in the list beyond the third.
• Default state
•• Drop all items in the list.
• Polygon state
•• Drop the last item if there's an odd number of items.
• Rectangle state
•• Drop any items in the list beyond the fourth.
◎
If the shape attribute represents the rectangle state, and the first number in the list is numerically greater than the third number in the list, then swap those two numbers around.
◎
If the shape attribute represents the rectangle state, and the second number in the list is numerically greater than the fourth number in the list, then swap those two numbers around.
</li>
	<li>
~IF［
%状態 ~EQ `真円$st
］~AND［
%座標s[ 2 ] ~EQ 0
］
⇒
~RET ε（図形は空）
◎
If the shape attribute represents the circle state, and the third number in the list is less than or equal to zero, then the shape is empty; return.
</li>
	<li>
<p>
~RET %状態 に応じて，次で与えられる図形
— 以下におけるどの座標も画像の左上隅を~~原点とし，座標や距離は `px$css 数を表すとする：
◎
Now, the shape represented by the element is the one described for the entry in the list below corresponding to the state of the shape attribute:
</p>

		<dl class="switch">

			<dt>`真円$st</dt>
			<dd>
次で与えられる真円
⇒＃
中心は ( %座標s[ 0 ], %座標s[ 1 ] ) が成す座標,
半径は %座標s[ 2 ]
◎
Let x be the first number in coords, y be the second number, and r be the third number.
◎
The shape is a circle whose center is x CSS pixels from the left edge of the image and y CSS pixels from the top edge of the image, and whose radius is r CSS pixels.
</dd>

			<dt>`既定$st</dt>
			<dd>
画像の全体を正確に覆う矩形
◎
The shape is a rectangle that exactly covers the entire image.
</dd>

			<dt>`多角形$st</dt>
			<dd>
<p>
次で与えられる多角形：
</p>
				<ul>
					<li>
%n ~EQ ( %座標s の`~size$ ~DIV 2 ) 個の頂点からなる
</li>
					<li>
各 整数 %i ~IN { 0 〜 %n ~MINUS 1 } に対し，
( %座標s[ %i ~MUL 2 ], %座標s[ %i ~MUL 2 ~PLUS 1 ] )
が成す座標が ( %i ~PLUS 1 ) 個目の頂点を与える
</li>
				</ul>
<p>
この図形の内域は、
~even-odd規則
【`巻き数~規則＠~SVGpainting#WindingRule$】
を利用して確立されるとする `GRAPHICS$r
</p>
◎
Let xi be the (2i)th entry in coords, and yi be the (2i+1)th entry in coords (the first entry in coords being the one with index 0).
◎
Let the coordinates be (xi, yi), interpreted in CSS pixels measured from the top left of the image, for all integer values of i from 0 to (N/2)-1, where N is the number of items in coords.
◎
The shape is a polygon whose vertices are given by the coordinates, and whose interior is established using the even-odd rule. [GRAPHICS]
</dd>

			<dt>`矩形$st</dt>
			<dd>
次をいずれも覆う最~小な矩形
⇒＃
( %座標s[ 0 ], %座標s[ 1 ] ) が成す座標,
( %座標s[ 2 ], %座標s[ 3 ] ) が成す座標
◎
Let x1 be the first number in coords, y1 be the second number, x2 be the third number, and y2 be the fourth number.
◎
The shape is a rectangle whose top-left corner is given by the coordinate (x1, y1) and whose bottom right corner is given by the coordinate (x2, y2), those coordinates being interpreted as CSS pixels from the top left corner of the image.
</dd>
		</dl>

<p class="trans-note">【
この段の目的においては、
%座標s が不適合であっても
（例： ~itemが余分にある，あるいは `矩形$st のときに［
%座標s[ 0 ] ~GT %座標s[ 2 ]
］である場合など），
図形を成す。
】</p>

<p>
歴史的な理由から，各 座標は、
~CSS［
`width$p ／ `height$p
］~prop†により伸張された後の，表示されている画像に相対的に解釈するモノトスル
（†または，非~CSS~browserにおいては、画像~要素の［
`width^a ／ `height^a
］属性 —
~CSS~browserは，それらの属性を前述の~CSS~propに対応付ける）。
◎
For historical reasons, the coordinates must be interpreted relative to the displayed image after any stretching caused by the CSS 'width' and 'height' properties (or, for non-CSS browsers, the image element's width and height attributes — CSS browsers map those attributes to the aforementioned CSS properties).
</p>

<p class="note">注記：
［
~browserによる~zoom特能
］や［
~CSSや~SVGを利用して適用された変形-（座標系変換）
］は、
これらの座標には影響しない。
◎
Browser zoom features and transforms applied using CSS or SVG do not affect the coordinates.
</p>
	</li>
</ol>
</div>

<p>
［
上の~algoにより多層化された図形たちが成す集合に結付けられた画像
］との［
~pointing装置によるヤリトリ
］による，関連な利用者~対話~eventは、
~pointing装置が指示した地点を覆う図形が［
在るならば それらのうち最も手前側の層にあるもの ／
無いならば 画像~要素~自身
］に向けて，最初に発火するモノトスル。
~UAは、
`~hyperlink$を表現している個々の `area$e 要素が［
選択される／作動化される
］ことを許容してもヨイ
（例：~keyboardを利用して）。
◎
Pointing device interaction with an image associated with a set of layered shapes per the above algorithm must result in the relevant user interaction events being first fired to the top-most shape covering the point that the pointing device indicated, if any, or to the image element itself, if there is no shape covering that point. User agents may also allow individual area elements representing hyperlinks to be selected and activated (e.g. using a keyboard).
</p>

<p class="note">注記：
同じ `map$e 要素（およびその `area$e 要素たち）には，
複数個の `img$e 要素が結付けられ得るので、
同じ `area$e 要素が文書の複数の`~focus可能な区画$に対応することもあり得る。
◎
Because a map element (and its area elements) can be associated with multiple img elements, it is possible for an area element to correspond to multiple focusable areas of the document.
</p>

<p>
画像~mapは`~live$である
— ~DOMが変異された場合、
~UAは，上の画像~map用の~algoを再度~走らせたかのように動作するモノトスル。
◎
Image maps are live; if the DOM is mutated, then the user agent must act as if it had rerun the algorithms for image maps.
</p>

				</section>
			</section>
</main>
