<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Cookies: HTTP State Management Mechanism （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">

<style>

/* cookie 属性 */
.cookie-attr {
	font-weight: normal;
	color: var(--text-color-3);
}

.dom {
	color: var(--text-color-0);
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^§])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#${key}`;//.toLowerCase();
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${text}</code>\``;
	break;
case 'p':
	href = `#p.${key}`;
	break;
case 'X':
	text = `0x${text}`;
	break;
case 'U':
	text = `U+${text}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'rfc':
	{
		const [rfc, sec] = key.split('/');
		if(!sec) {
			return match;
		}
		return `<a href="#ref-RFC${rfc}">[RFC${rfc}]</a> <a href="~RFCx/rfc${rfc}#section-${sec}">§ ${sec}</a> `;
	}
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '§':
		text = ` <a href="${href}">§ ${text}</a> `;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

</script>

<script type="text/plain" id="_source_data">

●●options

spec_date:2025-07-21
trans_update:2025-08-12
	source_checked::250721
original_url:https://httpwg.org/http-extensions/draft-ietf-httpbis-layered-cookies.html
	abbr_url:COOKIES
spec_status:IETFID
page_state_key:HTTP
no_original_dfn:true
	ref_id_prefix:ref-
site_nav:network,http
trans_1st_pub:2025-08-12

●●class_map
ca:cookie-attr
p:production
P:token
X:hex-value
U:code-point
h:header
m:method
dom:dom
st:status
2119:rfc2119

●●tag_map
ca:code
h:code
m:code
P:code
p:code
c:code
dom:code
X:span
U:span
i:i
cite:cite
st:code
2119:em

●●original_id_map

references:
normative:
informative:

●●mdn_urls
cookie:HTTP/Headers/Cookie
sane-cookie:HTTP/Headers/Cookie
set-cookie:HTTP/Headers/Set-Cookie
sane-set-cookie:HTTP/Headers/Set-Cookie

●●link_map

h.Cookie:#cookie
		h.Cookie:#sane-cookie
h.Set-Cookie:#set-cookie

st.1xx:~HTTPsem#status.1xx
st.4xx:~HTTPsem#status.4xx
st.5xx:~HTTPsem#status.5xx

p.IMF-fixdate:~HTTPinfra#p.IMF-fixdate
p.token:~HTTPinfra#p.token
p.BWS:~HTTPinfra#p.BWS
p.OWS:~HTTPinfra#p.OWS

ca.Expires:#attribute-expires
ca.Max-Age:#attribute-max-age
ca.Domain:#attribute-domain
ca.Path:#attribute-path
ca.Secure:#attribute-secure
ca.HttpOnly:#attribute-httponly
ca.SameSite:#attribute-samesite

bl.expires:#attribute-expires
bl.max-age:#attribute-max-age
bl.domain:#attribute-domain
bl.path:#attribute-path
bl.secure:#attribute-secure
bl.httponly:#attribute-httponly
bl.samesite:#attribute-samesite

bl.__Secure-:#the-secure-prefix
bl.__Host-:#the-host-prefix
bl.__Http-:#the-http-prefix
bl.__HostHttp-:#the-hosthttp-prefix


	bl.Strict:#samesite-strict
	bl.Lax:#samesite-lax
	bl.None:#samesite-none

~UA:#dfn-user-agent
	~UA:~HTTPinfra#user-agent
	~UA:~INFRA#user-agent
~server:#dfn-server

~cookie:#dfn-cookie
cK.名前:#dfn-cookie-name
cK.値:#dfn-cookie-value
cK.~secureか:#dfn-cookie-secure
cK.~host:#dfn-cookie-host
cK.~hostに限るか:#dfn-cookie-host-only
cK.~path:#dfn-cookie-path
cK.~path属性を有するか:#dfn-cookie-has-path-attribute
cK.同一-~site:#dfn-cookie-same-site
cK.~HTTPに限るか:#dfn-cookie-http-only
cK.作成~時刻:#dfn-cookie-creation-time
cK.失効~時刻:#dfn-cookie-expiry-time
cK.最後に~accessした時刻:#dfn-cookie-last-access-time

~cookie保管庫:#dfn-cookie-store
非~HTTP~API:#dfn-non-HTTP
~cookie~byte:#dfn-cookie-byte
~byte列を二分する:#_split-into-two-byte-sequences

失効した:#dfn-expired
属性:#dfn-attributes
~Host接頭辞に互換:#dfn-host-prefix-compatible
~Http接頭辞に互換:#dfn-http-prefix-compatible
~domain合致するか否か:#dfn-domain-match
~path合致するか否か:#dfn-patrh-match
~cookieたちを~garbage収集する:#dfn-garbage-collect-cookies
~cookieの既定の~path:#dfn-default-cookie-path
~cookieを格納する:#dfn-store-a-cookie
~cookieを構文解析して格納する:#dfn-parse-and-store-a-cookie
~cookieを構文解析する:#dfn-parse-a-cookie
~cookieたちを検索取得する:#dfn-retrieve-cookies
~cookieたちを直列化する:#dfn-serialize-cookies
日付を構文解析する:#dfn-cookie-date
超過~大域~cookieたちを除去する:#dfn-remove-global-excess-cookies
~host用の超過~cookieたちを除去する:#remove-excess-cookies-for-a-host
失効した~cookieたちを除去する:#dfn-remove-expired-cookies
~hostごとの総~cookie数の上限:#dfn-total-cookies-per-host-limit
総~cookie数の上限:#dfn-total-cookies-limit
~cookie齢の上限:#dfn-cookie-age-limit
最も早い時刻:#dfn-earliest-representable-date
時間~差:#dfn-duration
時刻:#dfn-time
現-時刻:#dfn-current-time
現在の時刻:#dfn-current-time

~ambient権限:#dfn-ambient-authority
~CSRF攻撃:#dfn-csrf

~secure:#secure-channel

	●§
~server要件:#server-requirements
~UA要件:#ua-requirements
機密性の弱点:#weak-confidentiality
完全性の弱点:#weak-integrity
~cookie施策:#cookie-policy

	`Secure$ca:#attribute-secure
	＠#third-party-cookies
	＠#security-considerations
	＠#server-syntax
	＠#cookie-path
	＠#set-cookie
	＠#cookie
	＠#sane-set-cookie

	●用語（HTTP

実装定義:~INFRA#implementation-defined
安全:~HTTPsem#safe-method
冪等:~HTTPsem#idempotent-method
生成する:~HTTPinfra#generate
~target~URI:~HTTPsem#target-URI
	request-uri → ~target~URI
~headerの結合-法:~HTTPinfra#combine-headers
生成元~server:~HTTPinfra#origin-server
	~client:~HTTPinfra#client
	~server:~HTTPinfra#server
媒介者:~HTTPinfra#intermediary
~field値:~HTTPinfra#field-value
~field行l:~HTTPinfra#field-line
~field行l値:~HTTPinfra#field-line-value
状態s~code:~HTTPsem#status-code

	●用語（外部
~byte:~INFRA#byte
~byte列:~INFRA#byte-sequence
~byte小文字~化する:~INFRA#byte-lowercase
byte.値:~INFRA#byte-value
byte.長さ:~INFRA#byte-sequence-length
byte.から開始して:~INFRA#byte-sequence-starts-with
~byte大小無視:~INFRA#byte-case-insensitive
~ASCII~byte:~INFRA#ascii-byte
~ASCII復号する:~INFRA#ascii-decode
真偽値:~INFRA#boolean
文字列:~INFRA#string
~list:~INFRA#list
~size:~INFRA#list-size
空:~INFRA#list-is-empty
除去する:~INFRA#list-remove
付加する:~INFRA#list-append
拡張する:~INFRA#list-extend
~listを昇順に~sortする:~INFRA#list-sort-in-ascending-order
構造体:~INFRA#struct

~host構文解析器:~URL1#concept-host-parser
~IP~address:~URL1#ip-address
同等な~host:~URL1#concept-host-equals
~host:~URL1#concept-host
~URL~path:~URL1#url-path
~URL~pathを直列化する:~URL1#url-path-serializer
~domain:~URL1#concept-domain
~URL:#concept-url
url.~scheme:~URL1#concept-url-scheme
url.~path:~URL1#concept-url-path
url.~host:~URL1#concept-url-host
公共~接尾辞:~URL1#host-public-suffix
~URL~pathを直列化する:#url-path-serializer

生成元:~ORIGIN#concept-origin

	＠~HTMLdom#dom-document-cookie

●● §
1:#introduction
1.1:#examples
2:#conventions
2.1:#terminology
2.2:#abnf
3:#implementation-advisory
3.1:#cookie-producing-implementations
3.2:#cookie-consuming-implementations
3.3:#languages-frameworks
4:#server-requirements
4.1:#sane-set-cookie
4.1.1:#abnf-syntax
4.1.2:#sane-set-cookie-semantics
4.1.2.1:#attribute-expires
4.1.2.2:#attribute-max-age
4.1.2.3:#attribute-domain
4.1.2.4:#attribute-path
4.1.2.5:#attribute-secure
4.1.2.6:#attribute-httponly
4.1.2.7:#attribute-samesite
4.1.3:#server-name-prefixes
4.1.3.1:#the-secure-prefix
4.1.3.2:#the-host-prefix
4.1.3.3:#the-http-prefix
4.1.3.4:#the-hosthttp-prefix
4.2:#sane-cookie
4.2.1:#server-syntax
4.2.2:#semantics
5:#ua-requirements
5.1:#cookie-concepts
5.1.1:#cookie-store-and-limits
5.1.2:#cookie-struct
5.1.2.1:#cookie-struct-miscellaneous
5.2:#cookie-store-eviction
5.2.1:#remove-expired-cookies
5.2.2:#remove-excess-cookies-for-a-host
5.2.3:#remove-global-excess-cookies
5.3:#subcomponent-algorithms
5.3.1:#cookie-date
5.3.2:#domain-matching
5.3.3:#cookie-path
5.3.4:#path-matching
5.4:#main-algorithms
5.4.1:#parse-and-store-a-cookie
5.4.2:#parse-a-cookie
5.4.3:#store-a-cookie
5.4.4:#garbage-collect-cookies
5.4.5:#retrieve-cookies
5.4.6:#serialize-cookies
5.5:#requirements-specific-to-non-browser-user-agents
5.5.1:#set-cookie
5.5.2:#cookie
5.5.3:#cookie-store-eviction-for-non-browser-user-agents
5.5:#requirements-specific-to-browser-user-agents
6:#implementation-considerations
6.1:#limits
6.2:#application-programming-interfaces
7:#privacy-considerations
7.1:#third-party-cookies
7.2:#cookie-policy
7.3:#user-controls
7.4:#expiration-dates
8:#security-considerations
8.1:#overview
8.2:#ambient-authority
8.3:#clear-text
8.4:#session-identifiers
8.5:#weak-confidentiality
8.6:#weak-integrity
8.7:#reliance-on-dns
8.8:#samesite-cookies
9:#iana
9.1:#iana-cookie
9.2:#iana-set-cookie
	#changes
	#acknowledgements
	#rfc.authors


●●words_table1
CAPABILITY-URLS:capability-urls-ja.html
HTTPv2:https://httpwg.org/specs/rfc9113.html

ナラナイ:<em class="rfc2119">ならない</em>
ベキ:<em class="rfc2119">べき</em>
ヨイ:<em class="rfc2119">よい</em>

Http: `<code class="literal">Http</code>` 
Host: `<code class="literal">Host</code>` 
StrictOrLax: `<code class="literal">Strict</code>` や `<code class="literal">Lax</code>` 

●●words_table

	●network
DNS:
URI:
UTC:
HTTP2:HTTP/2
HTTP3:HTTP/3
TLS:
	TLS:Transport Layer Security (TLS)
IP:
internet::::インターネット
	~internet:the Internet
socket::::ソケット
公共:public::~
帯域幅:bandwidth::~
冪等:idempotent::~
発行-:issue::~
為す:makeする:~
下位domain:subdomain::下位 domain:下位ドメイン

	~transport層:transport-layer
	応用~層:application-layer
	~header:header field
	伝送-:transmission

	●cookie
保管庫:store::~::ストア
保管:storage::~::ストレージ
割当分:quota::割り当て分::クォータ
抹消-:evict::~
抹消:eviction::~
超過:excess::~
超過-:exceed::~
	これ:removing
維持-:retain::~
逼迫:pressure:~
有効:valid::~
書込める:writeできる::書き込める
上限:limit:~
directory::::ディレクトリ
	下位-~directory:subdirectory

	優先:has precedence
	~PLUS:sum of
	現れる:appear
	`Cookie^h ~header:cookie header
	容量:capabilities／
	総容量
	少数かつ小容量:few and as small


	●cookie（期間）
失効-:expire::~
失効:expiry::~
	失効~時刻:expiry-time
有効期間:expiration period::~
有効期限:expiration date::~
持続的:persistent::~
持続-:persist::~
存続期間:lifetime::~
齢:age:~
現-:current:~
	期日:date
	期間:duration
	期間内:time period
	期間の最大:maximum amount of time during which
	期限
	最長:maximum
	~~終了
	終了時:at the end／is over
	過去:past
	最も早い:earliest
	最も過去:earliest
	より過去:earlier
	〜週間:weeks
			対象範囲:scope
	遠い未来:distant future
	未来:future
	後の時点:later time

	●構文
文法記号:grammatical term:~
文法記法:grammatical notation:~
日時:date＆time::~
	日時:date and time
	日時:date-and-time
	日時:time and date
年t:year::年
月t:month::月
日t:day::日
時t:hour::時
分t:minute::分
秒t:second::秒
閏秒:leap seconds::うるう秒
連結-:concatenate::~
	連結した結果:concatenation of
剥がさ:stripさ:~
	部位
	~MUL 10 ~PLUS:base 10

	^X:comma, semicolon, and backslash

	下位-成分:subcomponent
	2 桁表記:
	桁:digit
	二重引用符:double quote
	日付~文字列:date string
	制御文字:controls
	10 進数字:decimal
	16 進数字:hexadecimal
	~RET:abort
	-:successful
	括られ:wrap
	頭部:leading
	尾部:suffix
	尾部:trailing
	先頭と末尾:initial and trailing
	`から開始して$byte:begins with a case-sensitive match for the string
	名前を伴わない:nameless
	~ASCII~byte:US-ASCII characters
	KiB:kibibytes
	`min^op:smaller of
	先頭の~byteを除去した結果:without its leading U+002E (.)
	接頭辞を伴う:prefix
	byte:octet

	●一般処理／構文解析
生産器:producer::~
消費器:consumer::~
分割0:divide:分割
圧縮:compression::~
同等:equal:~
昇順に:ascending orderで:~
	~listを昇順に~sortする:sort

	~GTE:greater than or equal to
	~LTE:less than or equal to
	順に:followed by
	照合-法:matching
	認識されない:unrecognized
	認識できない:unrecognized
	-:remainder
	~domain合致-:domain-match
	~path合致-:path-match

●変数

旧-:old:~
最大-:max:~
秒数差:delta-seconds:~

	%年t値:year-value
	%月t値:month-value
	%日t値:day-of-month-value
	%時t値:hour-value
	%分t値:minute-value
	%秒t値:second-value
	%~cookie:cookie
	%失効した~cookie群:expiredCookies
	%~host:host
	%~host~cookie群:insecureCookies, secureCookies
	%超過~host~cookie群:excessHostCookies
	%全~cookie群:allCookies
	%超過~大域~cookie群:excessGlobalCookies
	%入力:input
	%~domain属性~値:domainAttributeValue
	%~path:path
	%要請~path:requestPath
	%~cookie~path:cookiePath
	%直列化-済み要請~path:serializedRequestPath
	%直列化-済み~cookie~path:serializedCookiePath
	%~secureか:isSecure
	%~HTTPに限るは許容されるか:httpOnlyAllowed
	%公共~接尾辞~用には~hostに限られない~cookieを許容するか:allowNonHostOnlyCookieForPublicSuffix
	%同一-~siteに~StrictOrLaxは許容されるか:sameSiteStrictOrLaxAllowed
	%名~値~入力:nameValueInput
	%属性~群~入力:attributesInput
	%名前:name
	%値:value
	%最大-齢は在るか:maxAgeSeen
	%属性~群~入力 を成す 0 番の~byte:char
	%属性~名~値~入力:attributeNameValueInput
	%属性~名:attributeName
	%属性~値:attributeValue
	%失効~時刻:expiryTime
	%~host入力:hostInput
	-:existingCookie
	%旧-~cookie:oldCookie
	%除去された~cookie群:removedCookies
	-:cookieList
	%同一-~site:sameSite
	%~cookie群:cookies
	%出力:output
	%秒数差:deltaSeconds
	%小文字~化~名:-
	%小文字~化~値:-
	%接頭辞:-

	●保安
ambient:
XSS:cross-site scripting:XSS
CSRF:
	CSRF:cross-site request forgery
nonce::::ナンス
欠陥:infelicities:~
login::::ログイン
退行-:degrade::~
被害者:victim::~
被害:damage::~
拒否-:refuse::~
再現:replay::~
能動的:active::~::アクティブ
認証:authentication::~
認証-:authenticate::~
	認証し直すよう:reauthentication step
真正:authentic:~
権限:authority::~
権限付与:authorization::~
権限付与され:authorizeされ::権限が付与され
弱体化-:compromise::~
機密性:confidentiality::~
機密:confidential::~
暗号化-:encrypt::~
暗号化:encryption::~
暗号:cryptography::~
署名-:sign::~
傍受-:intercept::~
侵害-:disrupt::~
固定化:fixation:~
固定化-:fix:~
修正:fixing:~
秘匿情報:secrets::~
	秘匿情報:secret information
堅牢:robust::~
平文:clear::~
上品:graceful::~
原理:principles:~
	予測-不能:unpredictable
盗聴者:eavesdropper:~
上書-:overwrite::上書き
絡める:entangleする:~
検索-:look up:~
稼働-:run:~
陥穽:pitfall:落とし穴
仕掛ける:mountする:~
施行:enforcement::~
防御:defense::~
活動:activity:~
相関-:correlate:~
濫用:abuse:~
警告-:warn:~
組立てる:assembleする:組み立てる
社会:society:~
広告:advertisement:~
	広告:ad
詐欺行為:fraud:~

	互いに信用し合っていない:mutually distrusting
	抗する:against
	根本から払拭する:mitigate 〜 completely
	弱点:weak
	混乱した使節の問題:confused deputy
	最悪:the worst
	分離:separate
	読む:learns
	偽造:forgery
	~~放任:let
	互いに~~無関係に見える複数の:different, seemingly unconnected
	植え付け:transplanting

	●仕様
要件群:requirement 群:~
	要件群:set of requirements
programmer::::プログラマ
助言-:advice:~
	勧める:advised to
理解:understanding:~
養う:developする:~
間違った:wrongな:~
	~API:application programming interface (API)
応用-:apply:~
指図-:instruct:~
競合-:conflict:~
競争:race condition::~
増補-:enhance:~
指名-:designate::~
指名:designation::~
運用者:operator:~
依拠:reliance:~
給-:supply:~
承認-:endorse:~
考えて:considerして:~
行使-:exercise:~
相互運用-:interoperate:~
際立つ:salientな:~
欠点:drawbacks:~
確証:confidence:~
万能:panacea:~
採用-:adopt:~
機能:function:~
推定-:infer:~
排他的:exclusive:~
上塗り:overlay:~
成文化-:codify:~
避けな:avoidしな:~
総意:consensus:~
後継:successor:~
限定的:limited:~
実現可能:feasible:~
享受-:enjoy:~
判定-:judge:~
妨害:disruption:~
内来的:inherent:~
仕分ける:partitionする:~
促進-:promote:~
背後:behind:~
不作為:inadvertent:~
思慮深く:thoughtfulに:~
末端-:end:~
柔軟性:flexibility:~
手助け:facilitate:~
強制的:forcible:~
必須な:requisiteな:必須とされる
	必須な〜しておく:pre-requisite
下流の:downstream:~
改造-:revamp:~
土台作業:groundwork:~
諸々:miscellaneous:~

	~~寛容:lenient
	~~寛容:tolerant
	~~寛容さ:tolerance
	警告-対象になるもの:some things that 〜 warned against
	助けになる:help
	助ける:help
	要する:require
	込み入った:esoteric
	期待されない:unexpectedly
	アリでない:impossible
	ほぼ無意味と化す:largely moot
	正しく〜ない:incorrect
	普及している:popularな
	足る:sufficient
	不足:insufficient
	併用:in conjunction with
	事実，:In fact
	~~可能性:potential
	無用に:gratuitously
	~~詳細:more information
	形をとる:in the form of
	〜そうに見える:seemingly
	何十年:multiple decades
	顕著:most apparent
	表記
	表す:denoted
	notice
	至らせ:lead to
	すべてを成すには至らない:prudent to ensure that this designation is not the 
	改めることはない:unaltered
	綴って:spell out
	きちんと:well に
	満たす:meet
	あり得る:It's possible that
	と称される:known as
	抑制するものにもなり得る:may reduce the likelihood
	相互運用能:will be able to interoperate with
	~~思慮深く応用:judicious application
	呼ばれ:called
	なりすまして:impersonating
	選ぶ:chooseする
	するため:in order
	~~妨げ:preclude
	間違いなく:certainly
	切り分ける:hew
	-:vice-versa
	警告:warning
	~~段階:step
	呼称:names
	~~別名:or
	それ以外の:as a general category
	~HTTP~field名~registry:HTTP Field Name Registry
	^en:CamelCase
	望ましくない:undesirable
	と称される:referred to as
	にはなるが，それを超えるものではない:best characterised as
	かまわない:free to
	広く:wideに
	広い:wide
	それだけで:on their own
	様々な:varied
	ばかりではない:not every 〜 is necessarily
	回数や~~頻度:how often
	より幅広い:broader
	広まった:widespread
	まだ早過ぎる:it is too early
	最終的:eventual
	最終的な:final
	書いて:writing
	きちんと定義された:well-defined
	課す:impose
	少なくとも当面の間は 〜 見込まれる:for the foreseeable future
	もたらす:resulted in
	多様な:variety of
	〜する場合には:do／does
	注意を払う
	に注意:It's important to note that
	概ね:roughly
	最も適する:best fit
	築かれてきた:built up
	多い:frequently
	念頭に置く:mindful
	見込みが高い:likely
	注記:note
	したがって:meaning that
	相当に:considerable
	から外れる:out-of-
	から外れる:outside
	~~敷:laying
	後述する:that follow
	主要な:main
	ここ以外のどこか:out-of-bound
	特に感謝する:Many thanks
	以前の~version:prior version

	●未分類
内包-:include::~
付-:attach::~
再起動:restart:~
mail::::メール
	~mail:email
suite::::スイート
stateful::::ステートフル
	状態を保つ:stateful
欠如:lack:~
対称:symmetric:~
事業:business:~

	最大~化:maximize
	最小~化:minimize
	返送-:send back
	~~単独
	~web~mail:webmail
	~web~site:website
	-:yield
	なるべく近く:as closely as
	及ぶ／またがる:span
	〜側:-side
	何であれ:anything
	唯一の:the only
	~serverへの:outbound
	~serverからの:inbound
	〜番台の:-level
	一連
	~form提出:submission
	~~構成するもの:piece of
	^p:cookie-value
	要請の`~target~URI$:request-uri
	総数:in total
	総:total
	見ている:viewing
	現在:current
	後続
	後続して:subsequently
	一形態:a form of
	まるごと:in its entirety
	同時に:simultaneously
	唯一:the only
	後／後で:later
	より長い:longer
	巨大:large
	より広い:larger
	多数の:large number of
	〜したとき:in the event
	~OR:is not both
	無効~化:invalidation
	始まる:begin
	非:non-
	改められな:unaltered
	表現していた:referred
	過去:past
	class="issue":XXX
	終わった:is over
	勝つ:win
	新たに:newly-


●●ref_normative
[HTML]
    Hickson, I., Pieters, S., van Kesteren, A., Jägenstedt, P., and D. Denicola, ＜HTML＞, n.d.
    URL: https://html.spec.whatwg.org/
[INFRA]
    van Kesteren, A. and D. Denicola, ＜Infra＞, n.d.
    URL: https://infra.spec.whatwg.org
[RFC1034]
    Mockapetris, P., ＜Domain names - concepts and facilities＞, STD 13, ~RFC1034, November 1987
[RFC1123]
    Braden, R., Ed., ＜Requirements for Internet Hosts - Application and Support＞, STD 3, ~RFC1123, October 1989
[RFC2119]
    Bradner, S., ＜Key words for use in RFCs to Indicate Requirement Levels＞, BCP 14, ~RFC2119, March 1997
[RFC5234]
    Crocker, D., Ed. and P. Overell, ＜Augmented BNF for Syntax Specifications: ABNF＞, STD 68, ~RFC5234, January 2008
[URL]
    van Kesteren, A., ＜URL＞, n.d.
    URL: https://url.spec.whatwg.org

●●ref_informative

[CSRF]
    Barth, A., Jackson, C., and J. Mitchell, ＜Robust Defenses for Cross-Site Request Forgery＞, DOI 10.1145/1455770.1455782, ISBN 978-1-59593-810-7, ACM CCS '08: Proceedings of the 15th ACM conference on Computer and communications security (pages 75-88), October 2008
    URL: http://portal.acm.org/citation.cfm?id=1455770.1455782
[RFC9114]
    Bishop, M., Ed., ＜HTTP/3＞, ~RFC9114, June 2022
[HttpFieldNameRegistry]
    ＜Hypertext Transfer Protocol (HTTP) Field Name Registry＞, n.d.
    URL: https://www.iana.org/assignments/http-fields/
[RFC2109]
    Kristol, D. and L. Montulli, ＜HTTP State Management Mechanism＞, ~RFC2109, February 1997
[RFC4648]
    Josefsson, S., ＜The Base16, Base32, and Base64 Data Encodings＞, ~RFC4648, October 2006
[RFC6265]
    Barth, A., ＜HTTP State Management Mechanism＞, ~RFC6265, April 2011
[RFC7034]
    Ross, D. and T. Gondrom, ＜HTTP Header Field X-Frame-Options＞, ~RFC7034, October 2013
[RFC9110]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP Semantics＞, STD 97, ~RFC9110, June 2022
[RFC9113]
    Thomson, M., Ed. and C. Benfield, Ed., ＜HTTP/2＞, ~RFC9113, June 2022
[TLS13]
    Rescorla, E., ＜The Transport Layer Security (TLS) Protocol Version 1.3＞, ~RFC8446, August 2018

●●ref_additional
[RFC6265bis]
    ＜HTTP State Management Mechanism＞
    URL: https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html

●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公開された，
<a href="~SPEC_URL">HTTP State Management Mechanism</a>
（ RFC 6265 の改訂）を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

公表者
	HTTP Working Group
位置付け
	Internet-Draft
廃用
	6265 （認可されたならば）
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集／著作者アドレス
	<a href="mailto:annevk@annevk.nl" class="email">Anne van Kesteren</a> (Apple)
	<a href="mailto:johannhof@google.com" class="email">Johann Hofmann</a> (Google)
課題追跡
	https://github.com/httpwg/http-extensions/labels/cookies
履歴
	https://datatracker.ietf.org/doc/draft-ietf-httpbis-layered-cookies/
commit 履歴
	https://github.com/httpwg/http-extensions/commits/main/draft-ietf-httpbis-layered-cookies.md
HTTP 拡張仕様草案
	https://github.com/httpwg/http-extensions#draft-http-extension-specifications

</script>

</head>

<body>

<header>
	<hgroup>
<h1>クッキー： HTTP 状態管理の仕組み</h1>
<p>Cookies: HTTP State Management Mechanism</p>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は~HTTP `Cookie^h と `Set-Cookie^h ~headerを定義する。
これらの~headerは、
（~cookieと呼ばれる）状態~情報を~HTTP~UA側に格納させるために，
~HTTP~serverにより利用され得るものであり、
ほぼ状態~情報がない~HTTP~protocol越しに，
~serverが状態を保つ~sessionを保守できるようにする。
~cookieには，~securityと~privacyを退行させる 多くの歴史的な欠陥があるが、
`Cookie^h と `Set-Cookie^h ~headerは~internet上で広く利用されている。
この文書は、
`RFC6265$r, `RFC6265bis$r を廃用にする。
◎
This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol. Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet. This document obsoletes RFC 6265 and 6265bis.
</p>

	</section>
	<section>
<h2 title="About This Document">この文書について</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#about-this-draft$に移譲。
】</p>

	</section>
	<section id="status-of-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status-draft$に移譲。
】</p>

	</section>
	<section id="copyright">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2025 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
この文書は、
~HTTP［
`Cookie^h, `Set-Cookie^h
］~headerを定義する。
~HTTP~serverは、
`Set-Cookie^h ~headerを利用して，~cookieと呼ばれる［
( 名前, 値 ) が成す~pair, それに結付けられた~metadata
］を~UAに渡せる。
~UAは、
~serverへ後続な要請を為す際に，
その~metadataと他の情報を利用して
( 名前, 値 ) が成す~pairを `Cookie^h ~header内に返すかどうか決定する。
◎
This document defines the HTTP Cookie and Set-Cookie header fields. Using the Set-Cookie header field, an HTTP server can pass name/value pairs and associated metadata (called cookies) to a user agent. When the user agent makes subsequent requests to the server, the user agent uses the metadata and other information to determine whether to return the name/value pairs in the Cookie header field.
</p>

<p class="trans-note">【
“~header” は、
正式には “~header~field（ `header field^en ）” と称されるが，
この訳では一律に “~header” と略記する。
】【
“~cookie” は，この仕様においては［
~UAの`~cookie保管庫$に格納される~data（`~cookie$）
］として定義されるが、
その~dataの~sourceを成すもの
（~serverが `Set-Cookie^h ~header内に送信するそれ）,
その~dataから導出されるもの
（~UAが `Cookie^h ~header内に送信するそれ）
も含めた総称としても利用される
（どれを指すかは、
文脈に依存する）。
】</p>

<p>
見かけの単純さに反し、
~cookieには，いくつかの複階性がある。
例えば、
~serverは，
【自身が~UAへ送信する各~cookieごとに】
次に挙げるものの視野を絞れる
⇒＃
~UAが当の~cookieを返すべき期間の最大,
~UAが当の~cookieを どの~serverへ返すべきか,
~UAの`非~HTTP~API$が当の~cookieに~accessできるかどうか
◎
Although simple on their surface, cookies have a number of complexities. For example, the server can scope the maximum amount of time during which the user agent should return the cookie, the servers to which the user agent should return the cookie, and whether the cookie can be accessed through a non-HTTP API, such as JavaScript in a web browser.
</p>

<p>
歴史的な理由から、
~cookieには，~securityと~privacyに関わる欠陥がいくつかある。
例えば、
~serverは，~cookieの `Secure$ca 属性により［
当の~cookieは “`~secure$” な接続~用に意図されること
］を指示できるが、
それは，能動的~network攻撃者が居る下で完全性を供するものではない。
類似に、
所与の~host用の~cookieは，同じ~host上のすべての~portにわたって共有される
— 異なる~portを介して検索取得された内容どうしは、
~web~browserが通例的に利用する “同一-生成元~施策（ `same-origin policy^en ）” により隔離されるにも関わらず。
◎
For historical reasons, cookies contain a number of security and privacy infelicities. For example, a server can indicate that a given cookie is intended for "secure" connections, but the cookie's Secure attribute does not provide integrity in the presence of an active network attacker. Similarly, cookies for a given host are shared across all the ports on that host, even though the usual "same-origin policy" used by web browsers isolates content retrieved via different ports.
</p>

<p>
この文書は、
これらの~headerの構文と意味論を指定する。
一部の既存の~softwareにおいて，この仕様の要件と有意な仕方で相違する所では、
その相違についても説明する。
◎
This document specifies the syntax and semantics of these header fields. Where some existing software differs from the requirements in significant ways, the document contains a note explaining the difference.
</p>

<p>
この文書は、
`RFC6265$r, `RFC6265bis$r を廃用にする。
◎
This document obsoletes [RFC6265] and 6265bis.
</p>

		<section id="examples">
<h3 title="Examples">1.1. 例</h3>

<div class="example">

<p>
~serverは、
`~UA$への~HTTP応答に `Set-Cookie^h ~headerを利用して，
短い文字列【`~byte列$】を送信できる
— ~UAは、
その~cookieの視野に入る未来の~HTTP要請において，
その文字列を返すことになる。
例えば，~serverは、
`SID^c と命名された “~session識別子” として値 `31d4d96e407aad42^c を~UAへ送信できる。
~UAは、
後続な要請にて，その~session識別子を返すことになる：
◎
Using the Set-Cookie header field, a server can send the user agent a short string in an HTTP response that the user agent will return in future HTTP requests that are within the scope of the cookie. For example, the server can send the user agent a "session identifier" named SID with the value 31d4d96e407aad42. The user agent then returns the session identifier in subsequent requests.
</p>

<!-- 
Server -&gt; User Agent
User Agent -&gt; Server
 -->

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: SID=31d4d96e407aad42

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42
</pre>

<p>
~serverは、［
`Path$ca ／ `Domain$ca
］属性を利用して，~cookieの既定の視野を改めれる。
例えば，~serverは、
`site.example^c の［
どの~path,
どの下位domain
］に対しても，その~cookieを返すよう~UAに指図できる：
◎
The server can alter the default scope of the cookie using the Path and Domain attributes. For example, the server can instruct the user agent to return the cookie to every path and every subdomain of site.example.
</p>

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: SID=31d4d96e407aad42; Path=/; Domain=site.example

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42
</pre>

<p>
次の例に示されるとおり、
~serverは，複数個の~cookieを~UAに格納させれる。
例えば，~serverは、
2 個の `Set-Cookie^h ~headerを返すことにより，
~session識別子と同時に利用者が選好する言語も格納させれる。
~serverは、
より~securityに敏感な~session識別子~用には，
追加的な保護を供する［
`Secure$ca, `HttpOnly$ca
］`属性$（ § 4.1.2 ）を利用することに注意：
◎
As shown in the next example, the server can store multiple cookies at the user agent. For example, the server can store a session identifier as well as the user's preferred language by returning two Set-Cookie header fields. Notice that the server uses the Secure and HttpOnly attributes to provide additional security protections for the more sensitive session identifier (see Section 4.1.2).
</p>

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: SID=31d4d96e407aad42; Path=/; Secure; HttpOnly
Set-Cookie: lang=en-US; Path=/; Domain=site.example

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42; lang=en-US
</pre>

<p>
上の `Cookie^h ~headerは、
2 個の~cookie
— `SID^c と命名されたもの, `lang^c と命名されたもの —
を包含していることに注意。
◎
Notice that the Cookie header field above contains two cookies, one named SID and one named lang.
</p>

<p>
~cookie名は、
文字大小区別である。
したがって，~serverが［
名前の文字大小に限り相違する 2 個の `Set-Cookie^h ~header
］を~UAへ送信した場合、
~UAは，それら両~cookieを［
格納して，後続な要請において返す
］ことになる：
◎
Cookie names are case-sensitive, meaning that if a server sends the user agent two Set-Cookie header fields that differ only in their name's case the user agent will store and return both of those cookies in subsequent requests.
</p>

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: SID=31d4d96e407aad42
Set-Cookie: sid=31d4d96e407aad42

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42; sid=31d4d96e407aad42
</pre>

<p>
~UAの “複数~session” 越しに（例：~UAの再起動を挟んで）~cookieを持続させるよう望むなら、
~serverは， `Expires$ca 属性にその有効期限を指定できる。
~UAは、
自身の`~cookie保管庫$の総容量が割当分を超過した場合や，
利用者が手動で~serverの~cookieを削除した場合など、
有効期限が過ぎる前に~cookieを削除し得ることに注意。
◎
If the server wishes the user agent to persist the cookie over multiple "sessions" (e.g., user agent restarts), the server can specify an expiration date in the Expires attribute. Note that the user agent might delete the cookie before the expiration date if the user agent's cookie store exceeds its quota or if the user manually deletes the server's cookie.
</p>

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: lang=en-US; Expires=Wed, 09 Jun 2021 10:18:14 GMT

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42; lang=en-US
</pre>

<p>
最後に，~cookieを除去するためには、
~serverは，有効期限を過去にした `Set-Cookie^h ~headerを返す。
これが成功するのは、
`Set-Cookie^h ~header内の［
`Path$ca, `Domain$ca
］両~属性とも，~cookieの作成-時に利用した値に合致するときに限られる。
◎
Finally, to remove a cookie, the server returns a Set-Cookie header field with an expiration date in the past. The server will be successful in removing the cookie only if the Path and the Domain attribute in the Set-Cookie header field match the values used when the cookie was created.
</p>

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: lang=; Expires=Sun, 06 Nov 1994 08:49:37 GMT

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42
</pre>
</div>

		</section>
	</section>
	<section id="conventions">
<h2 title="Conventions">2. 表記規約</h2>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

		</section>
		<section id="terminology">
<h3 title="Terminology">2.1. 各種用語</h3>

<p>
この仕様は、
`INFRA$r に依存する。
◎
This specification depends on Infra. [INFRA]
</p>

<p>
この仕様~内に利用される一部の用語は、
次に挙げる［
標準／仕様
］内に定義される
⇒＃
`RFC9110$r,
`URL$r
◎
Some terms used in this specification are defined in the following standards and specifications:
• HTTP [RFC9110]
• URL [URL]
</p>

<p class="trans-note">【
原文では、
ほとんどの［
これらの用語を指すと見受けられる語
］には，［
その定義を参照する~link
］が与えられていない。
この訳では，それらのうち推定-可能なものには~linkを補完しているが、
原文の意図とは異なるものもあるかもしれない。
】</p>

<p>
`非~HTTP~API@
とは、
`~cookie$を［
設定する／検索取得する
］ために利用される~HTTP以外の仕組みである
— ~JSに~cookieを公開する~web~browser~API
（例： ~HTMLの `document.cookie＠~HTMLdom#dom-document-cookie$dom ）
など。
◎
A non-HTTP API is a non-HTTP mechanisms used to set and retrieve cookies, such as a web browser API that exposes cookies to JavaScript.
</p>

		</section>
		<section id="abnf">
<h3 title="ABNF">2.2. ~ABNF</h3>

<p>
この仕様は、
`RFC5234$r による~ABNF（ Augmented Backus-Naur Form ）記法を利用する。
◎
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234].
</p>

<p>
次に挙げる中核~規則は、
`RFC 5234, Appendix B.1＠~RFCx/rfc5234#appendix-B.1$
にて定義されるものとして，参照される
⇒＃
`ALPHA^P （ `letters^en ）,
	`CR^P （ `carriage return^en ）,
	`CRLF^P （ CR LF ）,
`CTL^P （制御文字）,
`DIGIT^P （ 10 進数字 0-9 ）,
`DQUOTE^P （二重引用符）,
	`HEXDIG^P （ 16 進数字 0-9/A-F/a-f ）,
	`LF^P （ `line feed^en ）,
`NUL^P （ ~NULL ~byte【！octet】【 `00^X 】）,
`OCTET^P （ `NUL^P 以外の~byte【！8-bit sequence of data】）,
`SP^P （ `space^en 【 `20^X 】）,
`HTAB^P （ `horizontal tab^en 【 `09^X 】）,
`CHAR^P （【 `NUL^P 以外の】`~ASCII~byte$）,
	`VCHAR^P （可視な`~ASCII~byte$ 【 `21^X 〜 `7E^X 】）,
`WSP^P （空白【 `SP^P と `HTAB^P 】）
◎
The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTLs (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), NUL (null octet), OCTET (any 8-bit sequence of data except NUL), SP (space), HTAB (horizontal tab), CHAR (any ASCII byte), VCHAR (any visible ASCII byte), and WSP (whitespace).
</p>

<p>
次に挙げる規則は、
`RFC9110$r にて定義される
⇒＃
【`IMF-fixdate$p,】
【`token$p,】
`OWS$p （省略可能な空白）,
`BWS$p （不良な空白）
◎
The OWS (optional whitespace) and BWS (bad whitespace) rules are defined in Section 5.6.3 of [RFC9110].
</p>

		</section>
	</section>
	<section id="implementation-advisory">
<h2 title="Which Requirements to Implement">3. どの要件を実装するか</h2>

<p>
下に与える［
`~server要件§, `~UA要件§
］は、
別個な種別の実装~用の要件群を論じる。
この節は、
実装者が自身の目標に どちらの要件群が最も適するか決定する際の手引きとして意味される。
間違った要件群を選ぶと，他の~cookie実装との互換性を欠如する結果にもなり得る。
◎
The upcoming two sections, Section 4 and Section 5, discuss the set of requirements for two distinct types of implementations. This section is meant to help guide implementers in determining which set of requirements best fits their goals. Choosing the wrong set of requirements could result in a lack of compatibility with other cookie implementations.
</p>

<p>
互換であることが何を意味するかは、
実装者の目標に依存して異なることに注意。
これらの相違点は、［
意図的な仕様~変更,
意図的でない仕様~変更,
仕様の解釈,
歴史的な実装~間の相違点
］に因り，時を経るに伴い築かれてきた。
◎
It's important to note that being compatible means different things depending on the implementer's goals. These differences have built up over time due to both intentional and unintentional specification changes, specification interpretations, and historical implementation differences.
</p>

<p>
この節は、
概ね，この仕様の実装者を 2 つの種別
— 生産器と消費器 —
に分割0する。
これらは、
公式的な用語ではない
— これらは、［
読者が，利用事例に対する直感的な理解を養う
］ことを助けるためにあり，この節でしか利用されない。
◎
This section roughly divides implementers of this specification into two types, producers and consumers. These are not official terms and are only used here to help readers develop an intuitive understanding of the use cases.
</p>

		<section id="cookie-producing-implementations">
<h3 title="Cookie Producing Implementations">3.1. ~cookieを生産している実装</h3>

<p>
実装者は、［
~cookieを作成して，`~UA$
— ~web~browserなど —
へ送信することになる
］ときは，`~server要件§を選ぶべきである。
これらの実装は，この仕様では
`~server@
と称されることが多いが、
~cookieを首に生産するものは，何であれ含まれる
— 例えば：
◎
An implementer should choose Section 4 whenever cookies are created and will be sent to a user agent, such as a web browser. These implementations are frequently referred to as servers by the specification but that term includes anything which primarily produces cookies. Some potential examples:
</p>
<ul>
	<li>
ある［
~web~site／~API
］を~hostしている~server応用
◎
Server applications hosting a website or API
</li>
	<li>
~cookieを~supportする［
~programming言語／~software~framework
］
◎
Programming languages or software frameworks that support cookies
</li>
	<li>
統合された【何に？】第三者-主体による~web応用
— 事業~管理~suiteなど
◎
Integrated third-party web applications, such as a business management suite
</li>
</ul>

<p>
これらはいずれも、［
アリな限り多くの`~UA$を~supportすることのみならず，他の`~server$も~supportすること
］から便益を得る。
このことは、［
ある~cookieが，ある~software~frameworkにより生産され、
後で，それを読取る必要がある~server応用へ返送する場合
］に有用になる。
`~server要件§は、
このイミを成す互換性を最大~化する助けになる最善な実施を助言する。
◎
All these benefit from not only supporting as many user agents as possible but also supporting other servers. This is useful if a cookie is produced by a software framework and is later sent back to a server application which needs to read it. Section 4 advises best practices that help maximize this sense of compatibility.
</p>

		</section>
		<section id="cookie-consuming-implementations">
<h3 title="Cookie Consuming Implementations">3.2. ~cookieを消費している実装</h3>

<p>
実装者は、
~cookieが首に別の~sourceから受信されるときは，`~UA要件§を選ぶべきである。
これらの実装は、
`~UA@
と称される
— 例えば：
◎
An implementer should choose Section 5 whenever cookies are primarily received from another source. These implementations are referred to as user agents. Some examples:
</p>
<ul>
	<li>
~web~browser
◎
Web browsers
</li>
	<li>
~statefulな~HTTPを~supportする~tool
◎
Tools that support stateful HTTP
</li>
	<li>
~cookieを~supportする［
~programming言語／~software~framework
］
◎
Programming languages or software frameworks that support cookies
</li>
</ul>

<p>
`~UA$は，［
利用者が どの`~server$へ~accessすることになるか
］および［
その~serverは最善な実施に従っているかどうか
］を知り得ないので、
より~~寛容な要件群を実装して，［
~serverが生産すると警告-対象になるもの
］も受容するよう勧める。
`~UA要件§は、
このイミの互換性を最大~化する助けになる最善な実施を助言する。
◎
Because user agents don't know which servers a user will access, and whether or not that server is following best practices, users agents are advised to implement a more lenient set of requirements and to accept some things that servers are warned against producing. Section 5 advises best practices that help maximize this sense of compatibility.
</p>

		</section>
		<section id="languages-frameworks">
<h3 title="Programming Languages &amp; Software Frameworks">3.3. ~programming言語と~software~framework</h5>

<p>
~cookie用の~supportを伴う［
~programming言語／~software~framework
］は、［
~cookie生産器や~cookie消費器, あるいはこの両者
］として動作する応用を作成するためにも適度に利用され得る。
開発者は，［
生産器／消費器
］としての互換性を最大~化するよう求めるであろうから、
これらの［
言語／~framework
］は，
互換性~mode~toggleの背後で［
`~server要件§, `~UA要件§
］どちらも~supportすることを強く考慮するべきである。
この切り替えは、
既定では，`~server要件§になるべきである。
◎
A programming language or software framework with support for cookies could reasonably be used to create an application that acts as a cookie producer, cookie consumer, or both. Because a developer may want to maximize their compatibility as either a producer or consumer, these languages or frameworks should strongly consider supporting both sets of requirements, Section 4 and Section 5, behind a compatibility mode toggle. This toggle should default to Section 4's requirements.
</p>

<p>
そうすることで、
当の開発者の応用が［
他の`~server$が読取れない~cookie
］を不作為に作成する機会cは，抑制されることになる。
◎
Doing so will reduce the chances that a developer's application can inadvertently create cookies that cannot be read by other servers.
</p>

		</section>
	</section>
	<section id="server-requirements">
<h2 title="Server Requirements">4. ~server要件</h2>

<p>
この節では、
~HTTP［
`Cookie^h, `Set-Cookie^h
］~headerを成す適合［
構文, 意味論
］を述べる。
◎
This section describes the conforming syntax and semantics of the HTTP Cookie and Set-Cookie header fields.
</p>

		<section id="sane-set-cookie">
<h3 title="Set-Cookie">4.1. `Set-Cookie^h ~header</h3>

<p>
`Set-Cookie^h ~HTTP応答~headerは、
`~server$から`~UA$へ~cookieを送信するときに利用される。
◎
The Set-Cookie HTTP response header field is used to send cookies from the server to the user agent.
</p>

<p>
`生成元~server$は、
どの応答にも `Set-Cookie^h 応答~headerを送信してヨイ。
生成元~serverは、
単独の応答に複数個の `Set-Cookie^h ~headerを内包できる。
`Cookie^h や `Set-Cookie^h ~headerが在っても，~HTTP~cacheが応答を格納したり再利用する~~妨げにはならない。
◎
Origin servers MAY send a Set-Cookie response header field with any response. An origin server can include multiple Set-Cookie header fields in a single response. The presence of a Cookie or a Set-Cookie header field does not preclude HTTP caches from storing and reusing a response.
</p>

<p>
［
`生成元~server$／`媒介者$
］は、
複数個の `Set-Cookie^h ~header値【`~field行l値$】を 1 個の~header【`~field行l$】の中へ結合してはナラナイ。
~headerを結合する通例の仕組み（ `RFC9110$r `~headerの結合-法$にて定義される）は、
`Set-Cookie^h における `2C^X `,^smb の利用と競合するので，
`Set-Cookie^h ~headerの意味論を変更し得る。
◎
Origin servers and intermediaries MUST NOT combine multiple Set-Cookie header fields into a single header field. The usual mechanism for combining HTTP headers fields (i.e., as defined in Section 5.3 of [RFC9110]) might change the semantics of the Set-Cookie header field because the %x2C (",") character is used by Set-Cookie in a way that conflicts with such combining.
</p>

<div class="example">
<p>
例えば次は：
◎
For example,
</p>

<pre class="lang-http">
Set-Cookie: a=b;path=/c,d=e
</pre>

<p>
…次のどちらが意図されたのか多義的になる
⇒＃
2 個の~cookie `a=b;…^c と `d=e^c ／
~path `/c,d=e^c を伴う 1 個の~cookie
◎
is ambiguous. It could be intended as two cookies, a=b and d=e, or a single cookie with a path of /c,d=e.
</p>
</div>

			<section id="abnf-syntax">
<h4 title="Syntax">4.1.1. 構文</h4>

<p>
非正式には、
`Set-Cookie^h 応答~headerの値は，［
次の並びで与えられる 1 個の~cookie
］を包含する：
◎
Informally, the Set-Cookie response header field contains a cookie,＼
</p>
<ol>
	<li>
( ~cookieの名前（ `cookie-name$p ）, ~cookieの値（ `cookie-value$p ） )
が成す~pair（ `cookie-pair$p ）
◎
which begins with a name-value-pair,＼
</li>
	<li>
0 個~以上の`属性$（ `cookie-av$p ）
— 各 `属性$は、
( 属性~名, 属性~値 )
が成す~pairを与える
◎
followed by zero or more attribute-value pairs.＼
</li>
</ol>

<p>
`~server$は、
次の文法に適合する `Set-Cookie^h ~headerを送信しなければナラナイ：
◎
Servers MUST send Set-Cookie header fields that conform to the following grammar:
</p>

<pre class="bnf">
`set-cookie@p
	= `set-cookie-string$p
`set-cookie-string@p
	= `BWS$p `cookie-pair$p *( `BWS$p ";" `OWS$p `cookie-av$p )
`cookie-pair@p
	= `cookie-name$p `BWS$p "=" `BWS$p `cookie-value$p
`cookie-name@p
	= `token$p
	; <span class="comment">
`RFC9110$r にて定義される
</span>
`cookie-value@p
	= *`cookie-octet$p
	/ ( DQUOTE *`cookie-octet$p DQUOTE )
`cookie-octet@p
	= `%x21^_
	/ `%x23-2B^_
	/ `%x2D-3A^_
	/ `%x3C-5B^_
	/ `%x5D-7E^_
	; <span class="comment">
［
`CTL^P,
`SP^P,
`DQUOTE^P,
`2C^X `,^smb,
`3B^X `;^smb,
`5C^X `\^smb
］以外の`~ASCII~byte$
◎
US-ASCII characters excluding CTLs, whitespace, DQUOTE, comma, semicolon, and backslash
◎
↑ token = &lt;token, defined in [HTTP], Section 5.6.2&gt;
</span>
`cookie-av@p
	= `expires-av$p
	/ `max-age-av$p
	/ `domain-av$p
	/ `path-av$p
	/ `secure-av$p
	/ `httponly-av$p
	/ `samesite-av$p
	/ `extension-av$p
`expires-av@p
	= "Expires" `BWS$p "=" `BWS$p `sane-cookie-date$p
`sane-cookie-date@p
	= `IMF-fixdate$p
	; <span class="comment">
`RFC9110$r にて定義される
【しかしながら、閏秒は許容されない（`日付を構文解析する$を見よ）】
◎
IMF-fixdate, defined in [HTTP], Section 5.6.7
</span>
`max-age-av@p
	= "Max-Age" `BWS$p "=" `BWS$p `non-zero-digit$p *DIGIT
`non-zero-digit@p
	= `%x31-39^_
	; <span class="comment">
数字 1 〜 9
◎
digits 1 through 9
</span>

`domain-av@p
	= "Domain" `BWS$p "=" `BWS$p `domain-value$p
`domain-value@p
	= &lt;`subdomain^p&gt;
	; <span class="comment">
下に与える詳細を見よ
◎
see details below
</span>
`path-av@p
	= "Path" `BWS$p "=" `BWS$p `path-value$p
`path-value@p
	= *`av-octet$p
`secure-av@p
	= "Secure"
`httponly-av@p
	= "HttpOnly"
`samesite-av@p
	= "SameSite" `BWS$p "=" `BWS$p `samesite-value$p
`samesite-value@p
	= "Strict"
	/ "Lax"
	/ "None"
`extension-av@p
	= *`av-octet$p
`av-octet@p
	= `%x20-3A^_
	/ `%x3C-7E^_
	; <span class="comment">
［
`CTL^P, `3B^X `;^smb
］以外の `CHAR^P
◎
any CHAR except CTLs or ";"
</span>
</pre>

<p>
上の中の一部の文法記号は、
この文書の文法記法（ ~ABNF `RFC5234$r ）とは異なる記法を利用する文書を参照していることに注意。
◎
Note that some of the grammatical terms above reference documents that use different grammatical notations than this document (which uses ABNF from [RFC5234]).
</p>

<p>
上の文法により、
`~server$は，名前を伴わない~cookie（すなわち， `cookie-name$p は空）を生産してはナラナイ
— そのような~cookieは、
`~UA$により
— ~serverへ返送するとき —
予測-不能に†直列化されたものである場合もあるので。
【† 例えば，`非~HTTP~API$を通して設定されたもの。】
◎
Per the grammar above, servers MUST NOT produce nameless cookies (i.e., an empty cookie-name) as such cookies may be unpredictably serialized by user agents when sent back to the server.
</p>

<p>
`cookie-value$p の意味論は、
この文書では定義されない。
◎
The semantics of the cookie-value are not defined by this document.
</p>

<p>
`cookie-value$p の中に任意な~dataを格納するよう望む`~server$は、
`~UA$との互換性を最大~化するためには，その~dataを【 `cookie-octet$p のみからなるよう】符号化するベキである
（例えば， Base64 `RFC4648$r を利用して）。
◎
To maximize compatibility with user agents, servers that wish to store arbitrary data in a cookie-value SHOULD encode that data, for example, using Base64 [RFC4648].
</p>

<p>
上の文法により、
`cookie-value$p は `DQUOTE^P で括られてもヨイ。
この事例では、
先頭と末尾の `DQUOTE^P は剥がされないことに注意
— それらは `cookie-value$p の一部を成し、
`~server$へ送信される `Cookie^h ~headerに内包されることになる。
◎
Per the grammar above, the cookie-value MAY be wrapped in DQUOTE characters. Note that in this case, the initial and trailing DQUOTE characters are not stripped. They are part of the cookie-value, and will be included in Cookie header fields sent to the server.
</p>

<p>
`domain-value$p は、［
`1034/3.5$rfc にて定義され， `1123/2.1$rfc にて増補される
］とおりの `subdomain^p （ “下位domain” ）である。
したがって、
`domain-value$p は`~ASCII~byte$たちが成す`~byte列$になる
◎
The domain-value is a subdomain as defined by [RFC1034], Section 3.5, and as enhanced by [RFC1123], Section 2.1. Thus, domain-value is a byte sequence of ASCII bytes.
</p>

<p>
`set-cookie-string$p の中で，文法記号 `cookie-av$p が生産する部位は、
`属性@
と称される。
`~UA$との互換性を最大~化するためには、
`~server$は，同じ `set-cookie-string$p の中に同じ名前を伴う複数個の属性を生産するベキではない
◎
The portions of the set-cookie-string produced by the cookie-av term are known as attributes. To maximize compatibility with user agents, servers SHOULD NOT produce two attributes with the same name in the same set-cookie-string.
</p>

<p class="note">注記：
`属性$の名前は、
ここでは `CamelCase^en で呈示されるが
（ `HttpOnly^ca や `SameSite^ca など），
文字大小無視【`~byte大小無視$】である。
なので、
文字大小がどうなっていようが
（例： `httponly^ca, `Httponly^ca, `hTTPoNLY^ca, 等々），
受容される。
◎
NOTE: The name of an attribute-value pair is not case-sensitive. So while they are presented here in CamelCase, such as HttpOnly or SameSite, any case is accepted. E.g., httponly, Httponly, hTTPoNLY, etc.
</p>

<p>
`~server$は、
同じ応答~内に同じ `cookie-name$p を伴う複数個の `Set-Cookie^h ~headerを内包してはナラナイ。
（`~UA$がこの場合をどう取扱うかについては、
`5.5.1＠#set-cookie§ を見よ。）
◎
Servers MUST NOT include more than one Set-Cookie header field in the same response with the same cookie-name. (See Section 5.5.1 for how user agents handle this case.)
</p>

<p>
`~server$が複数個の［
`Set-Cookie^h ~headerを包含している応答
］を同時に`~UA$に送信した場合
（例：複数の~socket越しに~UAと通信するとき）、
これらの応答は “競争” を生じさせ，
予測-不能な挙動へ至らせ得る。
◎
If a server sends multiple responses containing Set-Cookie header fields concurrently to the user agent (e.g., when communicating with the user agent over multiple sockets), these responses create a "race condition" that can lead to unpredictable behavior.
</p>

<p class="note">注記：
一部の既存の~UAは、
2 桁表記による年tの解釈が他と異なる。
互換性の課題を避けるため、
~serverは，
`RFC1123$r に則り，年tの表記に 4 桁を要する `rfc1123-date^p 【 `IMF-fixdate$p 】形式を利用するベキである。
◎
NOTE: Some existing user agents differ in their interpretation of two-digit years. To avoid compatibility issues, servers SHOULD use the rfc1123-date format, which requires a four-digit year.
</p>

<p class="note">注記：
一部の~UAは、
~cookie内の日付を 32 ~bitな UNIX `time_t^c 型の値として格納し, 処理する。
一部の~systemには， `time_t^c 処理を~supportする~libraryに実装~bugがあり、
その種の~UAでは， 2038 年より後の日付が正しく処理されないかもしれない。
◎
NOTE: Some user agents store and process dates in cookies as 32-bit UNIX time_t values. Implementation bugs in the libraries supporting time_t processing on some systems might cause such user agents to process dates after the year 2038 incorrectly.
</p>

			</section>
			<section id="sane-set-cookie-semantics">
<h4 title="Semantics (Non-Normative)">4.1.2. 意味論（規範的でない）</h4>

<p>
この節では、
`Set-Cookie^h ~headerの意味論を単純~化して述べる。
これらの意味論は、
~serverにおける~cookieの最も共通的な利用を理解するには十分~詳細なものである。
全部的な意味論は`~UA要件§にて述べる。
◎
This section describes simplified semantics of the Set-Cookie header field. These semantics are detailed enough to be useful for understanding the most common uses of cookies by servers. The full semantics are described in Section 5.
</p>

<p>
`Set-Cookie^h ~headerを受信した~UAは、
その~cookieを，その属性もひっくるめて格納する。
~UAは、
後続して~HTTP要請を為す際には，
適用-可能かつ まだ失効していない~cookieを `Cookie^h ~headerに内包する。
◎
When the user agent receives a Set-Cookie header field, the user agent stores the cookie together with its attributes. Subsequently, when the user agent makes an HTTP request, the user agent includes the applicable, non-expired cookies in the Cookie header field.
</p>

<p id="_-store-cookie">
~UAは、
すでに格納された~cookieと同じ［
`cookie-name$p,
`domain-value$p,
`path-value$p
］を伴う新たな~cookieを受信した場合、
既存の~cookieは抹消され，新たな~cookieに置換される。
~serverは、
新たな~cookieを
— その `Expires$ca 属性の値を過去に設定した上で —
~UAに送信することにより，~cookieを削除できることに注意。
◎
If the user agent receives a new cookie with the same cookie-name, domain-value, and path-value as a cookie that it has already stored, the existing cookie is evicted and replaced with the new cookie. Notice that servers can delete cookies by sending the user agent a new cookie with an Expires attribute with a value in the past.
</p>

<p>
~cookieは、
~cookieの属性により指示されない限り，
（例えば，下位domainではなく）`生成元~server$に対してのみ返され，
現在の~sessionの終了時に失効する
（ “~sessionの~~終了” は、
~UAにより定義される）。
~UAは、
認識できない~cookie属性を無視する（~cookieまるごと，ではなく）。
◎
Unless the cookie's attributes indicate otherwise, the cookie is returned only to the origin server (and not, for example, to any subdomains), and it expires at the end of the current session (as defined by the user agent). User agents ignore unrecognized cookie attributes (but not the entire cookie).
</p>

				<section id="attribute-expires">
<h5 title="The Expires Attribute">4.1.2.1. `Expires^ca 属性</h5>

<p>
`Expires^ca 属性は、
~cookieの最長な存続期間を指示するものであり，~cookieが失効する日時として表現される。
~UAには、
指定された期日を過ぎるまで~cookieを維持することは，要求されない。
事実，~UAは、［
~memoryの逼迫／~privacy
］の懸念に因り，~cookieを抹消することが多い。
◎
The Expires attribute indicates the maximum lifetime of the cookie, represented as the date and time at which the cookie expires. The user agent is not required to retain the cookie until the specified date has passed. In fact, user agents often evict cookies due to memory pressure or privacy concerns.
</p>

				</section>
				<section id="attribute-max-age">
<h5 title="The Max-Age Attribute">4.1.2.2. `Max-Age^ca 属性</h5>

<p>
`Max-Age^ca 属性もまた、
~cookieの最長な存続期間を指示するものであり，
~cookieが失効するまでの秒t数として表現される。
~UAには、
指定された期間を過ぎるまで~cookieを維持することは，要求されない。
事実，~UAは、［
~memoryの逼迫／~privacy
］の懸念に因り，~cookieを抹消することが多い。
◎
The Max-Age attribute indicates the maximum lifetime of the cookie, represented as the number of seconds until the cookie expires. The user agent is not required to retain the cookie for the specified duration. In fact, user agents often evict cookies due to memory pressure or privacy concerns.
</p>

<p class="note">注記：
一部の既存の~UAは、
`Max-Age^ca 属性を~supportしない。
そのような~UAは、
この属性を無視する。
◎
NOTE: Some existing user agents do not support the Max-Age attribute. User agents that do not support the Max-Age attribute ignore the attribute.
</p>

<p>
~cookieが［
`Max-Age$ca, `Expires$ca
］どちらの属性も有する場合、
`Max-Age^ca 属性が優先され，~cookieの有効期限を制御する。
~cookieが［
`Max-Age^ca, `Expires^ca
］どちらの属性も有さない場合、
~UAは、
（自身が定義する） “現在の~sessionの終了時” まで，~cookieを維持することになる。
◎
If a cookie has both the Max-Age and the Expires attribute, the Max-Age attribute has precedence and controls the expiration date of the cookie. If a cookie has neither the Max-Age nor the Expires attribute, the user agent will retain the cookie until "the current session is over" (as defined by the user agent).
</p>

				</section>
				<section id="attribute-domain">
<h5 title="The Domain Attribute">4.1.2.3. `Domain^ca 属性</h5>

<p>
`Domain^ca 属性は、
~cookieが送信されることになる~hostを指定する。
◎
The Domain attribute specifies those hosts to which the cookie will be sent.
</p>

<p>
~serverが `Domain^ca 属性を内包した場合、
その値は，指定された~domainに加えて, そのどの下位domainにも適用される。
例えば， `Domain^ca 属性の値が `site.example^bl ならば、
~UAは，［
`site.example^c ／
`www.site.example^c ／
`www.corp.site.example^c
］へ向けて~HTTP要請を送信する際に、
その~cookieを `Cookie^h ~headerに内包することになる
先頭の `2E^X `.^smb は、
在っても無視されることに注意
— その文字は許可されてないが，それでも。
◎
If the server includes the Domain attribute, the value applies to both the specified domain and any subdomains. For example, if the value of the Domain attribute is "site.example", the user agent will include the cookie in the Cookie header field when making HTTP requests to site.example, www.site.example, and www.corp.site.example. Note that a leading %x2E ("."), if present, is ignored even though that character is not permitted.
</p>

<p>
~serverが `Domain^ca 属性を省略した場合、
~UAは，当の~cookieを［
`生成元~server$へは返すが，下位domainへは返さない
］ことになる。
◎
If the server omits the Domain attribute, the user agent will return the cookie only to the origin server and not to any subdomains.
</p>

<p class="warning"><strong>警告：</strong>
一部の既存の~UAは、
`Domain^ca 属性が無い下でも，
`Domain^ca 属性が在って，現在の~host名を包含していたかのように扱う。
例えば，
`site.example^c
が `Domain^ca 属性が無い `Set-Cookie^h ~headerを返した場合、
これらの~UAは，その~cookieを
`www.site.example^c,
`www.corp.site.example^c
どちらにも誤って送信することになる。
◎
WARNING: Some existing user agents treat an absent Domain attribute as if the Domain attribute were present and contained the current host name. For example, if site.example returns a Set-Cookie header field without a Domain attribute, these user agents will erroneously send the cookie to www.site.example and www.corp.site.example as well.
</p>

<p>
~UAは、
~cookieの `Domain^ca 属性が，その~cookieの`生成元~server$を内包する視野を指定していない限り、
その~cookieを却下することになる。
例えば、
`foo.site.example^c
から受信した~cookieの `Domain^ca 属性の値が
`site.example^c
や
`foo.site.example^c
であれば，その~cookieは受容されることになるが、
`Domain^ca 属性の値が
`bar.site.example^c
や
`baz.foo.site.example^c
であれば，その~cookieは受容されないことになる。
◎
The user agent will reject cookies unless the Domain attribute specifies a scope for the cookie that would include the origin server. For example, the user agent will accept a cookie with a Domain attribute of "site.example" or of "foo.site.example" from foo.site.example, but the user agent will not accept a cookie with a Domain attribute of "bar.site.example" or of "baz.foo.site.example".
</p>

				</section>
				<section id="attribute-path">
<h5 title="The Path Attribute">4.1.2.4. `Path^ca 属性</h5>

<p>
各~cookieの視野は、［
`Path^ca 属性により制御される，~pathたちが成す集合
］に制限される。
~serverが `Path^ca 属性を省略した場合、
~UAは，要請の`~target~URI$【！request-uri】の~path成分が成す “~directory” を既定の値として利用することになる
（詳細は、
`~cookieの既定の~path＠#cookie-path§を見よ）。
◎
The scope of each cookie is limited to a set of paths, controlled by the Path attribute. If the server omits the Path attribute, the user agent will use the "directory" of the request-uri's path component as the default value. (See Section 5.3.3 for more details.)
</p>

<p>
~UAは、
要請の`~target~URI$【！request-uri】の~path部位が~cookieの `Path^ca 属性に合致する
（またはその下位-~directoryになっている）
場合に限り，その~cookieを~HTTP要請に内包することになる
— ここで， `2F^X `/^smb は、
~directory分離子として解釈される。
◎
The user agent will include the cookie in an HTTP request only if the path portion of the request-uri matches (or is a subdirectory of) the cookie's Path attribute, where the %x2F ("/") character is interpreted as a directory separator.
</p>

<p>
所与の~hostの中で，~pathが異なる~cookieを互いに隔離することは、
有用~そうに見えるが，
~securityは `Path^ca 属性に依存できない
（`~securityの考慮点＠#security-considerations§を見よ）。
◎
Although seemingly useful for isolating cookies between different paths within a given host, the Path attribute cannot be relied upon for security (see Section 8).
</p>

				</section>
				<section id="attribute-secure">
<h5 title="The Secure Attribute">4.1.2.5. `Secure^ca 属性</h5>

<p>
`Secure^ca 属性は、
~cookieの視野を “`~secure$” な~channelに制限する
— 何が “`~secure@” を成すかは、
この文書の視野から外れる。
`Secure^ca 属性を有する~cookieに対しては、
~UAは，`~secure$な~channel（概して，~TLS越しの~HTTP `TLS13$r `RFC9110$r ）越しに伝送される場合に限り，
その~cookieを要請に内包することになる。
◎
The Secure attribute limits the scope of the cookie to "secure" channels (where "secure" is outside the scope of this document). E.g., when a cookie has the Secure attribute, the user agent will include the cookie in an HTTP request only if the request is transmitted over a secure channel (typically HTTP over Transport Layer Security (TLS) [TLS13] [RFC9110]).
</p>

				</section>
				<section id="attribute-httponly">
<h5 title="The HttpOnly Attribute">4.1.2.6. `HttpOnly^ca 属性</h5>

<p>
`HttpOnly^ca 属性は、
~cookieの視野を~HTTP要請に制限する。
特に，この属性は、
`非~HTTP~API$を介して~cookieへの~accessを供するときは，
当の~cookieを省略することを~UAに指図する。
◎
The HttpOnly attribute limits the scope of the cookie to HTTP requests. In particular, the attribute instructs the user agent to omit the cookie when providing access to cookies via non-HTTP APIs.
</p>

				</section>
				<section id="attribute-samesite">
<h5 title="The SameSite Attribute">4.1.2.7. `SameSite^ca 属性</h5>

<p>
`SameSite^ca 属性は、
`~cookie$の作成および送達に際しての視野を［
当の~cookieが，より広い文脈の中で “同一-~site” であると見なされるかどうか
］に関して制限する
（何が “同一-~site” を成すかは、
この文書の視野から外れる）。
`SameSite^ca 属性は、
特に［
~web~browser, それを通して~access可能な~web応用
］に関連する。
◎
The SameSite attribute limits the scope of the cookie upon creation and delivery with respect to whether the cookie is considered to be "same-site" within a larger context (where "same-site" is outside the scope of this document). The SameSite attribute is particularly relevant for web browsers and web applications accessible through them.
</p>

<p>
`SameSite^ca 属性は、
その値として，次に挙げるものを~supportする
⇒＃
`Strict^bl,
`Lax^bl,
`None^bl
◎
The SameSite attribute supports Strict, Lax, and None as values.
</p>

				</section>
			</section>
			<section id="server-name-prefixes">
<h4 title="Cookie Name Prefixes">4.1.3. ~cookie名の接頭辞</h4>

<p>
この文書の
`機密性の弱点§,
`完全性の弱点§
では、
~cookieの歴史的な実装の欠点の一部について綴っている。
特に，~serverにとっては、［
所与の【受信した要請に伴われた】~cookieが，
【以前に，当の~serverが】特定0の［
属性たちが成す集合
］を伴わせて設定したものである
］ものと確証を得ることはアリでない。
そのような確証を後方-互換な仕方で供するため、
~cookieの名前を成す最初の数~文字から 2 つの共通的な要件を推定できる
【ようにする特能を，以下に指定する】。
◎
Section 8.5 and Section 8.6 of this document spell out some of the drawbacks of cookies' historical implementation. In particular, it is impossible for a server to have confidence that a given cookie was set with a particular set of attributes. In order to provide such confidence in a backwards-compatible way, two common sets of requirements can be inferred from the first few characters of the cookie's name.
</p>

<p>
`~UA$との互換性を最大~化するため、
`~server$は，以下に述べるとおりに接頭辞を利用するベキである。
◎
To maximize compatibility with user agents, servers SHOULD use prefixes as described below.
</p>

				<section id="the-secure-prefix">
<h5 title="The __Secure- Prefix">4.1.3.1. `__Secure-^bl 接頭辞</h5>

<p>
`~cookie$の`名前$cKが `__Secure-^bl `から開始して$byteいる場合、
当の~cookieは，次のように［
設定される／設定されていた
］ことになる
⇒＃
`Secure$ca 属性を伴う
◎
If a cookie's name begins with a case-sensitive match for the string __Secure-, then the cookie will have been set with a Secure attribute.
</p>

<p class="trans-note">【
そのような名前を伴う~cookieを~serverが~UAへ送信するときは，そのように設定する必要があり、
~serverが~UAから受信したときは，過去にそのように設定されたものと推定できる
（以下の各節に挙げられる他の接頭辞も同様）。
】</p>

<div class="example">
<p>
例えば，次の `Set-Cookie^h ~headerは、
`Secure$ca 属性を伴わないので，適合tな~UAはそれを却下することになろう：
◎
For example, the following Set-Cookie header field would be rejected by a conformant user agent, as it does not have a Secure attribute.
</p>

<pre class="lang-http">
Set-Cookie: __Secure-SID=12345; Domain=site.example
</pre>

<p>
一方で，次の `Set-Cookie^h ~headerは、［
`~secure$な生成元（例： `https://site.example/^c ）から設定された場合は，受容される／
他の場合は，却下される
］ことになろう：
◎
Whereas the following Set-Cookie header field would be accepted if set from a secure origin (e.g. https://site.example/), and rejected otherwise:
</p>

<pre class="lang-http">
Set-Cookie: __Secure-SID=12345; Domain=site.example; Secure
</pre>
</div>

				</section>
				<section id="the-host-prefix">
<h5 title="The __Host- Prefix">4.1.3.2. `__Host-^bl 接頭辞</h5>

<p>
~cookieの`名前$cKが `__Host-^bl `から開始して$byteいる場合、
当の~cookieは，次のように［
設定される／設定されていた
］ことになる
⇒＃
`Secure$ca 属性を伴う,
値 `/^bl をとる `Path$ca 属性を伴う,
`Domain$ca 属性を伴わない
◎
If a cookie's name begins with a case-sensitive match for the string __Host-, then the cookie will have been set with a Secure attribute, a Path attribute with a value of /, and no Domain attribute.
</p>

<p>
この組合nは、
`生成元$を~security境界として扱うことに なるべく近くなるよう，~cookieを切り分ける：
◎
This combination yields a cookie that hews as closely as a cookie can to treating the origin as a security boundary.＼
</p>
<ul>
	<li>
`Domain$ca 属性の欠如は、
次を確保する
⇒
当の~cookieの`~hostに限るか$cK を ~T にして，~cookieを
— 下位domainに及ぶことを許容することなく —
特定0の~hostに~lockする
◎
The lack of a Domain attribute ensures that cookie's host-only is true, locking the cookie to a particular host, rather than allowing it to span subdomains.＼
</li>
	<li>
`Path$ca を `/^bl に設定することは、
次を意味する
⇒
当の~cookieは、
`~host$全体に効果的になり，
特定の~path用の~cookieにより上書きされなくなる
◎
Setting the Path to / means that the cookie is effective for the entire host, and won't be overridden for specific paths.＼
</li>
	<li>
<p>
`Secure$ca 属性は、
次を確保する：
</p>
		<ul>
			<li>
`~secure$でない`生成元$が当の~cookieを改めることはない
</li>
			<li>
当の~cookieは複数の~protocolにまたがらない【`~secure$な~channelに限られる】
</li>
		</ul>
◎
The Secure attribute ensures that the cookie is unaltered by non-secure origins, and won't span protocols.
</li>
</ul>

<p>
同一-生成元~施策を~~構成するもののうち，~portのみが、
`__Host-^bl ~cookieが無視し続けるものになる。
◎
Ports are the only piece of the same-origin policy that __Host- cookies continue to ignore.
</p>

<div class="example">
<p>
例えば，次に挙げる~cookieは、
常に，~UAにより却下されることになる：
◎
For example, the following cookies would always be rejected:
</p>

<pre class="lang-http">
Set-Cookie: __Host-SID=12345
Set-Cookie: __Host-SID=12345; Secure
Set-Cookie: __Host-SID=12345; Domain=site.example
Set-Cookie: __Host-SID=12345; Domain=site.example; Path=/
Set-Cookie: __Host-SID=12345; Secure; Domain=site.example; Path=/
</pre>

<p>
次の~cookieは、
`~secure$な生成元
（例： `https://site.example/^c ）
により設定された場合には受容され，他の場合は却下される：
◎
While the following would be accepted if set from a secure origin (e.g. https://site.example/), and rejected otherwise:
</p>

<pre class="lang-http">
Set-Cookie: __Host-SID=12345; Secure; Path=/
</pre>
</div>

				</section>
				<section id="the-http-prefix">
<h5 title="The __Http- Prefix">4.1.3.3. `__Http-^bl 接頭辞</h5>

<p>
`~cookie$の`名前$cKが `__Http-^bl `から開始して$byteいる場合、
当の~cookieは，次のように［
設定される／設定されていた
］ことになる
⇒＃
`Secure$ca 属性を伴う,
`HttpOnly$ca 属性を伴う
◎
If a cookie's name begins with a case-sensitive match for the string __Http-, then the cookie will have been set with a Secure attribute, and an HttpOnly attribute.
</p>

<p>
これは、［
当の~cookieは `Set-Cookie^h ~headerを利用して設定されたこと
］および［
当の~cookieの視野は~HTTP要請に制限されること
］を［
開発者／~server運用者
］が知る助けになる。
◎
This helps developers and server operators to know that the cookie was set using a Set-Cookie header, and is limited in scope to HTTP requests.
</p>

				</section>
				<section id="the-hosthttp-prefix">
<h5 title="The __HostHttp- prefix">4.1.3.4. `__HostHttp-^bl 接頭辞</h5>

<p>
`~cookie$の`名前$cKが `__HostHttp-^bl `から開始して$byteいる場合、
当の~cookieは，次のように［
設定される／設定されていた
］ことになる
⇒＃
`Secure$ca 属性を伴う,
`HttpOnly$ca 属性を伴う,
値 `/^bl をとる `Path$ca 属性を伴う,
`Domain$ca 属性を伴なわない
◎
If a cookie's name begins with a case-sensitive match for the string __HostHttp-, then the cookie will have been set with a Secure attribute, an HttpOnly attribute, a Path attribute with a value of /, and no Domain attribute.
</p>

<p>
これは、［
当の~cookieは `Set-Cookie^h ~headerを利用して設定されたこと
］および［
当の~cookieの視野は~HTTP要請に制限されること
］を［
開発者／~server運用者
］が知る助けになる。
◎
This helps developers and server operators to know that the cookie was set using a Set-Cookie header, and is limited in scope to HTTP requests.
</p>

<p>
この組合nは、［
`生成元$を~security境界として扱うことに なるべく近くなるよう，~cookieを切り分ける
］と同時に，［
開発者／~server運用者
］が［
当の~cookieの視野は~HTTP要請に制限されること
］を知ることを確保する：
◎
This combination yields a cookie that hews as closely as a cookie can to treating the origin as a security boundary, while at the same time ensuring developers and server operators know that its scope is limited to HTTP requests.＼
</p>
<ul>
	<li>
`Domain$ca 属性の欠如は、
次を確保する
⇒
当の~cookieの`~hostに限るか$cK を ~T にして，~cookieを
— 下位domainに及ぶことを許容することなく —
特定0の`~host$に~lockする
◎
The lack of a Domain attribute ensures that cookie's host-only is true, locking the cookie to a particular host, rather than allowing it to span subdomains.＼
</li>
	<li>
`Path$ca を `/^bl に設定することは、
次を意味する
⇒
当の~cookieは、
`~host$全体に効果的になり，
特定の~path用の~cookieにより上書きされなくなる
◎
Setting the Path to / means that the cookie is effective for the entire host, and won't be overridden for specific paths.＼
</li>
	<li>
<p>
`Secure$ca 属性は、
次を確保する：
</p>
		<ul>
			<li>
`~secure$でない`生成元$が当の~cookieを改めることはない
</li>
			<li>
当の~cookieは複数の~protocolにまたがらない【`~secure$な~channelに限られる】
</li>
		</ul>
◎
The Secure attribute ensures that the cookie is unaltered by non-secure origins, and won't span protocols.＼
</li>
	<li>
`HttpOnly$ca 属性は、
次を確保する
⇒
`~UA$は、
当の~cookieを`非~HTTP~API$へは公開しない。
◎
The HttpOnly attribute ensures that the cookie is not exposed by the user agent to non-HTTP APIs.
</li>
</ul>

				</section>
			</section>
		</section>
		<section id="sane-cookie">
<h3 title="Cookie">4.2. `Cookie^h ~header</h3>

			<section id="server-syntax">
<h4 title="Syntax">4.2.1. 構文</h4>

<p>
`~UA$は、
`Cookie^h ~headerに自身が格納した`~cookie$たちを伴わせて，`生成元~server$へ送信する。
当の【~cookieを設定した】`~server$が `4.1＠#sane-set-cookie§の要件に適合する
（かつ`~UA$が`~UA要件§に適合する）
ならば、
`~UA$は，次の文法に適合する `Cookie^h ~headerを送信することになる：
◎
The user agent sends stored cookies to the origin server in the Cookie header field. If the server conforms to the requirements in Section 4.1 (and the user agent conforms to the requirements in Section 5), the user agent will send a Cookie header field that conforms to the following grammar:
</p>

<pre class="bnf">
`cookie@p
	= `cookie-string$p
`cookie-string@p
	= `cookie-pair$p *( ";" SP `cookie-pair$p )
</pre>

<p>
`RFC9110$r `~fieldの長さ制限s＠~HTTPinfra#fields.limits§は，
~header用には長さ制限sを定義しないが、
~web~serverの実装は，ある上限を課す見込みが高い
— 普及している多くの実装には、
既定の上限 8 KiB 【 8 ~MUL 1024 ~byte 】が有る。
`~server$は、
最終的な `cookie-string$p が自身が~headerに課す上限を超過しないよう，
多数の巨大な~cookieを設定することを避けるベキである。
さもなければ、
~serverへの要請を失敗させかねない。
◎
While Section 5.4 of [RFC9110] does not define a length limit for header fields it is likely that the web server's implementation does impose a limit; many popular implementations have default limits of 8 kibibytes. Servers SHOULD avoid setting a large number of large cookies such that the final cookie-string would exceed their header field limit. Not doing so could result in requests to the server failing.
</p>

<p>
`~server$は、
複数個の `Cookie^h ~headerに対し~~寛容でなければナラナイ。
例えば，
~HTTP2 `RFC9113$r や~HTTP3 `RFC9114$r【！`HTTP$r】 における［
~client／`媒介者$
］は、
圧縮を改善するために，
`Cookie^h ~headerを分割するかもしれない。
`~server$は、
この~~寛容さが どんな形をとるか決定してもかまわない。
例えば，~serverは、［
各 `Cookie^h ~headerを個別に処理する
］ことも［
すべての `Cookie^h ~headerを一つに連結してから，
最終的な 1 個の~headerを処理する
］こともできる。
`~server$は、
どちらの~approachをとるか裁定するときには，
自身が~headerに課す上限を念頭に置くべきである。
◎
Servers MUST be tolerant of multiple Cookie headers. For example, an HTTP/2 [RFC9113] or HTTP/3 [HTTP] client or intermediary might split a Cookie header to improve compression. Servers are free to determine what form this tolerance takes. For example, the server could process each Cookie header individually or the server could concatenate all the Cookie headers into one and then process that final, single, header. The server should be mindful of any header field limits when deciding which approach to take.
</p>

<p class="note">注記：
`媒介者$は，
`Cookie^h ~headerを改変し得るが、
~serverが送信されてきた~headerを処理できなくなるのを避けるため，
~serverが~headerに課す共通的な上限も念頭に置くべきである。
例えば、
複数個の `Cookie^h ~headerを 1 個の~headerの中へ連結すると，
~serverの~size上限を超過するかもしれない。
◎
Note: Since intermediaries can modify Cookie headers they should also be mindful of common server header field limits in order to avoid sending servers headers that they cannot process. For example, concatenating multiple cookie headers into a single header might exceed a server's size limit.
</p>

			</section>
			<section id="semantics">
<h4 title="Semantics">4.2.2. 意味論</h4>

<p>
各 `cookie-pair$p が，`~UA$に格納されている~cookieを表現する。
`cookie-pair$p は、
`~UA$が `Set-Cookie^h ~header内に受信した［
`cookie-name$p と `cookie-value$p
］を包含する。
◎
Each cookie-pair represents a cookie stored by the user agent. The cookie-pair contains the cookie-name and cookie-value the user agent received in the Set-Cookie header field.
</p>

<p>
~cookieの`属性$は、
`~UA$から`~server$へは返されないことに注意。
特に，~serverは、
`Cookie^h ~header~~単独からは，~cookieが［
いつ失効するのか？／
どの~hostに有効なのか？／
どの~pathに有効なのか？／
`Secure$ca や `HttpOnly$ca 属性を伴って設定されたものかどうか？
］を決定できない。
◎
Notice that the cookie attributes are not returned. In particular, the server cannot determine from the Cookie field alone when a cookie will expire, for which hosts the cookie is valid, for which paths the cookie is valid, or whether the cookie was set with the Secure or HttpOnly attributes.
</p>

<p>
`Cookie^h ~header内の個々の~cookieの意味論については、
この文書では定義されない。
これらの~cookieに対する応用に特有な意味論は、
`~server$ごとに指定されることが期待されている。
◎
The semantics of individual cookies in the Cookie header field are not defined by this document. Servers are expected to imbue these cookies with application-specific semantics.
</p>

<p>
~cookieは `Cookie^h ~headerにて直列化されるが、
`~server$は，その直列化の順序に依拠するベキでない。
特に， `Cookie^h ~headerが同じ名前を伴う 2 個の~cookieを包含している場合
（例：異なる［
`Path$ca ／ `Domain$ca
］属性を伴って設定されたもの）、
`~server$は，これらの~cookieが~header内に現れる順序に依拠するベキでない。
◎
Although cookies are serialized linearly in the Cookie header field, servers SHOULD NOT rely upon the serialization order. In particular, if the Cookie header field contains two cookies with the same name (e.g., that were set with different Path or Domain attributes), servers SHOULD NOT rely upon the order in which these cookies appear in the header field.
</p>

			</section>
		</section>
	</section>
	<section id="ua-requirements">
<h2 title="User Agent Requirements">5. ~UAに課される要件</h2>

<p>
この節では、［
`Cookie^h, `Set-Cookie^h
］~headerに結付けられた処理~modelを詳細に指定する
— `~UA$が既存の`~server$と
（それが`~server要件§【！the well-behaved profile described in】に適合しない場合でも）
相互運用できるに足るまでに。
◎
This section specifies the processing models associated with the Cookie and Set-Cookie header fields in sufficient detail that a user agent can interoperate with existing servers (even those that do not conform to the well-behaved profile described in Section 4).
</p>

<p>
`~UA$は、
ここで指定されるものより多くの制約（例：~UAの`~cookie施策$）を施行し得る。
しかしながら，そのような追加の制約は、
既存の`~server$との相互運用能を抑制するものにもなり得る。
◎
A user agent could enforce more restrictions than those specified herein (e.g., restrictions specified by its cookie policy, described in Section 7.2). However, such additional restrictions may reduce the likelihood that a user agent will be able to interoperate with existing servers.
</p>

		<section id="cookie-concepts">
<h3 title="Cookie Concepts">5.1. ~cookieの概念</h3>

<p>
後述する各種~algoを手助けするため、
いくつか必須な概念を導入しておく必要がある。
◎
To facilitate the algorithms that follow, a number of pre-requisite concepts need to be introduced.
</p>

			<section id="cookie-store-and-limits">
<h4 title="Cookie Store And Limits">5.1.1. ~cookie保管庫と各種~上限</h4>

<p>
各`~UA$には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
<p>
`~cookie保管庫@
⇒
`~cookie$たちが成す~list
— 初期~時は空とする。
◎
A user agent has an associated cookie store, which is a list of cookies. It is initially « ».
</p>

<p class="trans-note">【
この~listを成す~cookieたちの順序は定義されない。
しかしながら，
`~cookie保管庫$から何らかの条件を満たす（あるいはすべての）~cookieたちが成す~listを取得するときは、
一般に，何らかの規則に従って~sortされる
— そのためには、
取得された~listを有順序な`~list$として扱う必要がある。
したがって、
そのような規則の下で順序に優劣がつかない~cookieどうしの順序は，`実装定義$になる。
】</p>
	</li>
	<li>
`~hostごとの総~cookie数の上限@
⇒
ある整数
— それは、
【`実装定義$であり，】
50 以上になるベキである。
◎
A user agent has an associated total cookies-per-host limit, which is an integer. It SHOULD be 50 or more.
</li>
	<li>
`総~cookie数の上限@
⇒
ある整数
— それは、
【`実装定義$であり，】
3000 以上になるベキである。
◎
A user agent has an associated total cookies limit, which is an integer. It SHOULD be 3000 or more.
</li>
	<li>
`~cookie齢の上限@
⇒
ある日t数で表現される`時間~差$
— それは、
【`実装定義$であり，】
400日t以下になるベキである
（ `~cookie施策§を見よ）。
◎
A user agent has an associated cookie age limit, which is a number of days. It SHOULD be 400 days or less (see Section 7.2).
</li>
	<li>
<p>
`最も早い時刻@
⇒
`~UA$が表現-可能な最も過去な日時を表現する`時刻$
</p>

<p class="trans-note">【
この用語は、
他所を集約するための，この訳による追加。
“表現-可能” が本当は何を意味するのかは、
はっきりしない
— 例えば，`失効~時刻$cKは、
`最も早い時刻$より過去にもなり得る。
】</p>
	</li>
</ul>

			</section>
			<section id="cookie-struct">
<h4 title="Cookie Struct">5.1.2. ~cookie構造体</h4>

<p>
`~cookie@
は、
~client↔~server間で伝送されることになる状態を~~構成するものを表現する
— それは、
次に挙げる~itemからなる`構造体$である：
◎
A cookie is a struct that represents a piece of state to be transmitted between a client and a server.
</p>

<ul>
	<li>
`名前@cK
（ `name^en ）
⇒
ある`~byte列$
— 常に【作成-時に】設定される必要がある。
◎
A cookie's name is a byte sequence. It always needs to be set.
</li>
	<li>
`値@cK
（ `value^en ）
⇒
ある`~byte列$
— 常に【作成-時に】設定される必要がある。
◎
A cookie's value is a byte sequence. It always needs to be set.
</li>
	<li>
`~secureか@cK
（ `secure^en ）
⇒
ある`真偽値$
— 初期~時は ~F とする。
◎
A cookie's secure is a boolean. It is initially false.
</li>
	<li>
<p>
`~host@cK
（ `host^en ）
⇒
次に挙げるいずれか
— 初期~時は ~NULL とする
⇒
ある`~domain$／
ある`~IP~address$／
~NULL／
`失敗^i
◎
A cookie's host is a domain, IP address, null, or failure. It is initially null.＼
</p>

<p class="note">注記：
これは、
当の~cookieが`~UA$の`~cookie保管庫$内に格納される時点では，［
`~domain$／`~IP~address$
］になる。
◎
Note: Once a cookie is in the user agent's cookie store its host is a domain or IP address.
</p>
	</li>
	<li>
`~hostに限るか@cK
（ `host-only^en ）
⇒
ある`真偽値$
— 初期~時は ~F とする。
◎
A cookie's host-only is a boolean. It is initially false.
</li>
	<li>
`~path@cK
（ `path^en ）
⇒
ある`~URL~path$
◎
A cookie's path is a URL path.
</li>
	<li>
`~path属性を有するか@cK
（ `has-path attribute^en ）
⇒
ある`真偽値$
— 初期~時は ~F とする。
◎
A cookie's has-path attribute is a boolean. It is initially false.
</li>
	<li>
`同一-~site@cK
（ `same-site^en ）
⇒
次に挙げるいずれか
— 初期~時は `unset^l とする
⇒＃
`unset^l,
`strict^l,
`lax^l,
`none^l
◎
A cookie's same-site is "strict", "lax", "unset", or "none". It is initially "unset".
</li>
	<li>
`~HTTPに限るか@cK
（ `http-only^en ）
⇒
ある`真偽値$
— 初期~時は ~F とする。
◎
A cookie's http-only is a boolean. It is initially false.
</li>
	<li>
`作成~時刻@cK
（ `creation-time^en ）
⇒
ある`時刻$
— 初期~時は`現-時刻$とする。
◎
A cookie's creation-time is a time. It is initially the current time.
</li>
	<li>
<p>
`失効~時刻@cK
（ `expiry-time^en ）
⇒
~NULL ／ある`時刻$
— 初期~時は~NULL とする。
</p>

<p class="note">注記：
この仕様の以前の~versionは、
~NULL を別個な~field "`persistent-flag^en" の値 ~F で表現していた。
</p>
◎
A cookie's expiry-time is null or a time. It is initially null. Note: A prior version of this specification referred to null with a distinct "persistent-flag" field being false.
</li>
	<li>
`最後に~accessした時刻@cK
（ `last-access-time^en ）
⇒
ある`時刻$
— 初期~時は`現-時刻$とする。
◎
A cookie's last-access-time is a time. It is initially the current time.
</li>
</ul>

<p class="trans-note">【
明確化するため、
この訳では，以下に挙げる用語を追加する：
】</p>

<p>
`時刻@
は，日時を表現する~dataであり、［
どの 2 つの`時刻$も，
“大きさ” を比較-可能（ “小さい” ものほど より過去であることを意味する）である
］かつ［
別の`時刻$を減算することにより，`時間~差$を算出-可能である
］かつ［
`時間~差$を［
加算-／減算-
］することにより，別の`時刻$を算出-可能である
］なら，どう表現されるかは問われない
（大きさ “0” が どの日時に対応するかも含めて）。
</p>

<p>
`時間~差@
は，
2 つの`時刻$の差を表現する~dataであり、
加算や減算が可能になるなら，どう表現されるかは問われない。
</p>

<p>
しかしながら，
この仕様の処理~model（`日付を構文解析する$）により、
`時刻$や`時間~差$は，秒t単位より細かくなり得ないことに加え、
閏秒も除外されることになる。
</p>

<p>
`現-時刻@
とは、［
~cookieの処理において，この語が参照された時点
］における現在の日時を表現する`時刻$である。
</p>


				<section id="cookie-struct-miscellaneous">
<h5 title="Cookie Struct Miscellaneous">5.1.2.1. ~cookie構造体の諸々</h5>

<p>
所与の`~cookie$が【所与の時点で】
`失効した@
とは、
その`失効~時刻$cKが次を満たすことをいう
⇒
［
その`失効~時刻$cK ~NEQ ~NULL
］~AND［
その`失効~時刻$cK ~LT `現-時刻$【！in the past】
］
◎
A cookie is expired if its expiry-time is non-null and its expiry-time is in the past.
</p>

<p>
所与の`~cookie$が
`~Host接頭辞に互換@
であるとは、
~AND↓ が満たされることをいう：
◎
A cookie cookie is Host-prefix compatible if:
</p>
<ul>
	<li>
その`~secureか$cK ~EQ ~T
◎
cookie's secure is true;
</li>
	<li>
その`~hostに限るか$cK ~EQ ~T
◎
cookie's host-only is true;
</li>
	<li>
その`~path属性を有するか$cK ~EQ ~T
◎
cookie's has-path attribute is true; and
</li>
	<li>
その`~path$cKの`~size$ ~EQ 1
◎
cookie's path's size is 1＼
</li>
	<li>
その`~path$cK[ 0 ] ~EQ 空~文字列
◎
and cookie's path[0] is the empty string,
</li>
</ul>

<p>
所与の`~cookie$が
`~Http接頭辞に互換@
であるとは、
~AND↓ が満たされることをいう：
◎
A cookie cookie is Http-prefix compatible if:
</p>
<ul>
	<li>
その`~secureか$cK ~EQ ~T
◎
cookie's secure is true; and
</li>
	<li>
その`~HTTPに限るか$cK ~EQ ~F
◎
cookie's http-only is false,
</li>
</ul>

				</section>
			</section>
		</section>
		<section id="cookie-store-eviction">
<h3 title="Cookie Store Eviction">5.2. ~cookie保管庫からの抹消</h3>

			<section id="remove-expired-cookies">
<h4 title="Remove Expired Cookies">5.2.1. 失効した~cookieたちを除去する</h4>

<div class="algo">
<p>
`失効した~cookieたちを除去する@
~algoは：
◎
↓</p>
<ol>
	<li>
%失効した~cookie群 ~LET « »
◎
↓</li>
	<li>
<p>
`~UA$の`~cookie保管庫$を成す
~EACH( %~cookie )
に対し：
</p>
		<ol>
			<li>
~IF［
~NOT %~cookie は`失効した$
］
⇒
~CONTINUE
</li>
			<li>
%失効した~cookie群 に %~cookie への参照を`付加する$；
</li>
			<li>
`~UA$の`~cookie保管庫$から %~cookie を除去する
</li>
		</ol>
◎
Let expiredCookies be a list of references to all expired cookies in the user agent's cookie store.
◎
For each cookie of expiredCookies:
• Remove cookie from the user agent's cookie store.
</li>
	<li>
~RET %失効した~cookie群
◎
Return expiredCookies.
</li>
</ol>
</div>

			</section>
			<section id="remove-excess-cookies-for-a-host">
<h4 title="Remove Excess Cookies for a Host">5.2.2. ~host用の超過~cookieたちを除去する</h4>

<div class="algo">
<p>
`~host用の超過~cookieたちを除去する@
~algoは、
所与の
( `~host$ %~host )
に対し：
◎
To Remove Excess Cookies for a Host given a host host:
</p>
<ol>
	<li>
%~host~cookie群 ~LET `~UA$の`~cookie保管庫$内の次を満たす`~cookie$たちが成す`~list$
⇒
( その`~host$cK, %~host )
は`同等な~host$である
◎
↓</li>
	<li>
<p>
%~host~cookie群 ~SET `~listを昇順に~sortする$( %~host~cookie群, 次の手続き )
</p>
<div class="algo">
<p>
手続きは、
所与の
( `~cookie$ %A, `~cookie$ %B )
に対し：
</p>
		<ol>
			<li>
~IF［
%A の`~secureか$cK ~NEQ %B の`~secureか$cK
］
⇒
~RET ~IS［
%A の`~secureか$cK ~EQ ~F
］
</li>
			<li>
~RET ~IS［
%A の`最後に~accessした時刻$cK ~LT %B の`最後に~accessした時刻$cK
］
</li>
		</ol>
</div>
◎
Let insecureCookies be a list of references to all cookies in the user agent's cookie store whose host is host-equal to host and whose secure is false.
◎
Sort insecureCookies by earliest last-access-time first.
◎
Let secureCookies be a list of references to all cookies in the user agent's cookie store whose host is host-equal to host and whose secure is true.
◎
Sort secureCookies by earliest last-access-time first.
</li>
	<li>
%超過~host~cookie群 ~LET « »
◎
Let excessHostCookies be an empty list of cookies.
</li>
	<li>
<p>
~WHILE［
%~host~cookie群 の`~size$ ~GT `~UA$の`~hostごとの総~cookie数の上限$
］~AND［
%~host~cookie群 は`空$でない
］：
</p>
		<ol>
			<li>
%~cookie ~LET %~host~cookie群[ 0 ]
</li>
			<li>
%~host~cookie群 から %~cookie を`除去する$
</li>
			<li>
`~UA$の`~cookie保管庫$から %~cookie を除去する
</li>
			<li>
%超過~host~cookie群 に %~cookie を`付加する$
</li>
		</ol>
◎
While insecureCookies's size + secureCookies's size is greater than the user agent's total cookies-per-host limit:
• If insecureCookies is not empty:
•• Let cookie be the first item of insecureCookies.
•• Remove cookie from insecureCookies.
•• Remove cookie from the user agent's cookie store.
•• Append cookie to excessHostCookies.
• Otherwise:
•• Let cookie be the first item of secureCookies.
•• Remove cookie from secureCookies.
•• Remove cookie from the user agent's cookie store.
•• Append cookie to excessHostCookies.
</li>
	<li>
~RET %超過~host~cookie群
◎
Return excessHostCookies.
</li>
</ol>
</div>

			</section>
			<section id="remove-global-excess-cookies">
<h4 title="Remove Global Excess Cookies">5.2.3. 超過~大域~cookieを除去する</h4>

<div class="algo">
<p>
`超過~大域~cookieたちを除去する@
~algoは：
◎
To Remove Global Excess Cookies:
</p>
<ol>
	<li>
%全~cookie群 ~LET `~UA$の`~cookie保管庫$内の すべての~cookieたちが成す`~list$
◎
↓</li>
	<li>
<p>
%全~cookie群 ~SET `~listを昇順に~sortする$( %全~cookie群, 次の手続き )
</p>

<div class="algo">
手続きは、
所与の
( `~cookie$ %A, `~cookie$ %B )
に対し
⇒
~RET ~IS［
%A の`最後に~accessした時刻$cK ~LT %B の`最後に~accessした時刻$cK
］
</div>
◎
Let allCookies be the result of sorting the user agent's cookie store by earliest last-access-time first.
</li>
	<li>
%超過~大域~cookie群 ~LET « »
◎
Let excessGlobalCookies be an empty list of cookies.
</li>
	<li>
<p>
~WHILE［
%全~cookie群 の`~size$ ~GT `~UA$の`総~cookie数の上限$
］：
◎
While allCookies's size is greater than the user agent's total cookies limit:
</p>
		<ol>
			<li>
%~cookie ~LET %全~cookie群[ 0 ]
◎
Let cookie be the first item of allCookies.
</li>
			<li>
%全~cookie群 から %~cookie を`除去する$
◎
Remove cookie from allCookies.
</li>
			<li>
`~UA$の`~cookie保管庫$から %~cookie を除去する
◎
Remove cookie from the user agent's cookie store.
</li>
			<li>
%超過~大域~cookie群 に %~cookie を`付加する$
◎
Append cookie to excessGlobalCookies.
</li>
		</ol>
	</li>
	<li>
~RET %超過~大域~cookie群
◎
Return excessGlobalCookies.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="subcomponent-algorithms">
<h3 title="Subcomponent Algorithms">5.3. 下位-成分~algo</h3>

<p>
この節では、［
`Cookie^h ／ `Set-Cookie^h
］~headerを成す特定の下位-成分を処理するために~UAが利用する，いくつかの~algoを定義する。
◎
This section defines some algorithms used by user agents to process specific subcomponents of the Cookie and Set-Cookie header fields.
</p>

			<section id="cookie-date">
<h4 title="Parse a Date">5.3.1. 日付を構文解析する</h4>

<div class="algo">
<p>
`日付を構文解析する@
~algoは、
所与の
( `~byte列$ %入力 )
に対し，［
日時 ／`失敗^i
］を返す：
◎
To Parse a Date given a byte sequence input, run these steps. They return a date and time or failure.
</p>
<ol>
	<li>
( %年t値, %月t値, %日t値, %時t値, %分t値, %秒t値 ) ~LET ( ε, ε, ε, ε, ε, ε )
◎
Note that the various boolean flags defined as a part of the algorithm (i.e., found-time, found-day-of-month, found-month, found-year) are initially "not set".
</li>
	<li>
<p>
%~token~list ~LET ［
下の文法を利用して， `cookie-date$p を一連の `date-token$p に分割0した結果
］で与えられる，出現順による~list
◎
Using the grammar below, divide the cookie-date into date-tokens.
</p>

<p class="trans-note">【
この構文解析に失敗することはない
— `delimiter$p と `non-delimiter$p が，あらゆる~byteを消費するので
（後者は、
前者~以外の~byteを表す）。
】</p>

<pre class="bnf">
`cookie-date@p
	= *`delimiter$p `date-token-list$p *`delimiter$p
`date-token-list@p
	= `date-token$p *( 1*`delimiter$p `date-token$p )
`date-token@p
	= 1*`non-delimiter$p

`delimiter@p
	= `%x09^_
	/ `%x20-2F^_
	/ `%x3B-40^_
	/ `%x5B-60^_
	/ `%x7B-7E^_
`non-delimiter@p
	= `%x00-08^_
	/ `%x0A-1F^_
	/ DIGIT
	/ ":"
	/ ALPHA
	/ `%x7F-FF^_
`non-digit@p
	= `%x00-2F^_
	/ `%x3A-FF^_

`day-of-month@p
	= 1*2DIGIT [ `non-digit$p *OCTET ]
`month@p
	= ( "jan" / "feb" / "mar" / "apr" /
	    "may" / "jun" / "jul" / "aug" /
	    "sep" / "oct" / "nov" / "dec" ) *OCTET
`year@p
	= 2*4DIGIT [ `non-digit$p *OCTET ]
`time@p
	= `hms-time$p [ `non-digit$p *OCTET ]
`hms-time@p
	= `time-field$p ":" `time-field$p ":" `time-field$p
`time-field@p
	= 1*2DIGIT
</pre>

	</li>
	<li>
<p>
%~token~list を成す
~EACH( `date-token$p %日付~token )
に対し：
◎
Process each date-token sequentially in the order the date-tokens appear in the cookie-date:
</p>
		<ol>
			<li>
~IF［
%時t値 ~EQ ε
］~AND［
%日付~token は生成規則 `time$p に合致する
］
⇒＃
( %時t値, %分t値, %秒t値 ) ~SET 順に %日付~token の中の各~数字~列が表す数；
~CONTINUE
◎
If the found-time flag is not set and the token matches the time production, set the found-time flag and set the hour-value, minute-value, and second-value to the numbers denoted by the digits in the date-token, respectively. Skip the remaining sub-steps and continue to the next date-token.
</li>
			<li>
~IF［
%日t値 ~EQ ε
］~AND［
%日付~token は生成規則 `day-of-month$p に合致する
］
⇒＃
%日t値 ~SET %日付~token が表す数；
~CONTINUE
◎
If the found-day-of-month flag is not set and the date-token matches the day-of-month production, set the found-day-of-month flag and set the day-of-month-value to the number denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.
</li>
			<li>
~IF［
%月t値 ~EQ ε
］~AND［
%日付~token は生成規則 `month$p に合致する
］
⇒＃
%月t値 ~SET %日付~token が表す月t；
~CONTINUE
◎
If the found-month flag is not set and the date-token matches the month production, set the found-month flag and set the month-value to the month denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.
</li>
			<li>
~IF［
%年t値 ~EQ ε
］~AND［
%日付~token は生成規則 `year$p に合致する
］
⇒＃
%年t値 ~SET %日付~token が表す数；
~CONTINUE
◎
If the found-year flag is not set and the date-token matches the year production, set the found-year flag and set the year-value to the number denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.
</li>
		</ol>
	</li>
	<li>
~IF［
ε ~IN { %日t値, %月t値, %年t値, %時t値 }
］
⇒
~RET `失敗^i
◎
↓↓</li>
	<li>
~IF［
%年t値 ~GTE 70
］~AND［
%年t値 ~LTE 99
］
⇒
%年t値 ~INCBY 1900
◎
If the year-value is greater than or equal to 70 and less than or equal to 99, increment the year-value by 1900.
</li>
	<li>
<p>
~IF［
%年t値 ~GTE 0
］~AND［
%年t値 ~LTE 69
］
⇒
%年t値 ~INCBY 2000
◎
If the year-value is greater than or equal to 0 and less than or equal to 69, increment the year-value by 2000.
</p>

<p class="note">注記：
一部の既存の~UAは、
2 桁表記の年tを他と異なるように解釈する。
◎
NOTE: Some existing user agents interpret two-digit years differently.
</p>
	</li>
	<li>
<p>
~IF［
~OR↓
］…
◎
If one of the following is true:
• ↑ at least one of the found-day-of-month, found-month, found-year, or found-time flags is not set,
</p>
		<ul>
			<li>
［
%日t値 ~LT 1
］~OR［
%日t値 ~GT 31
］
◎
the day-of-month-value is less than 1 or greater than 31,
</li>
			<li>
%年t値 ~LT 1601
◎
the year-value is less than 1601,
</li>
			<li>
%時t値 ~GT 23
◎
the hour-value is greater than 23,
</li>
			<li>
%分t値 ~GT 59
◎
the minute-value is greater than 59, or
</li>
			<li>
%秒t値 ~GT 59
◎
the second-value is greater than 59,
</li>
		</ul>
<p>
…ならば
⇒
~RET `失敗^i
◎
then return failure.
</p>

<p>
（閏秒はこの構文では表現できないことに注意。）
◎
(Note that leap seconds cannot be represented in this syntax.)
</p>
	</li>
	<li>
%~cookie日付 ~SET 次で与えられる~UTC（協定世界時）による日付
⇒＃
年t: %年t値,
月t: %月t値,
日t: %日t値,
時t: %時t値,
分t: %分t値,
秒t: %秒t値
◎
Let the parsed-cookie-date be the date whose day-of-month, month, year, hour, minute, and second (in UTC) are the day-of-month-value, the month-value, the year-value, the hour-value, the minute-value, and the second-value, respectively.＼
</li>
	<li>
~IF［
%~cookie日付 が表す日付は存在しない【例： 2 月 31 日】
］
⇒
~RET `失敗^i
◎
If no such date exists, abort these steps and fail to parse the cookie-date.
</li>
	<li>
~RET %~cookie日付
◎
Return the parsed-cookie-date as the result of this algorithm.
</li>
</ol>
</div>

			</section>
			<section id="domain-matching">
<h4 title="Domain Matching">5.3.2. ~domainの照合-法</h4>

<div class="algo">
<p>
`~domain合致するか否か@
を決定する~algoは、
所与の
( `~host$ %~host, `文字列$ %~domain属性~値 )
に対し，ある`真偽値$を返す：
◎
A host host Domain-Matches a string domainAttributeValue if at least one of the following is true:
</p>
<ol>
	<li>
~IF［
%~host ~EQ %~domain属性~値
］
⇒
~RET ~T
◎
host equals domainAttributeValue, or
</li>
			<li>
<p>
~RET ~IS［
~AND↓
］：
◎
if all of the following are true:
</p>
		<ul>
			<li>
%~host は`~domain$である
◎
host is a domain, and
</li>
			<li>
%~host は次を連結した結果で終端している
⇒
`002E^U `.^smb,
%~domain属性~値
◎
host ends with the concatenation of U+002E (.) and domainAttributeValue.
</li>
		</ul>
	</li>
</ol>
</div>

			</section>
			<section id="cookie-path">
<h4 title="Cookie Default Path">5.3.3. ~cookieの既定の~path</h4>

<div class="algo">
<p>
`~cookieの既定の~path@
を決定する~algoは、
所与の
( `~URL~path$ %~path )
に対し，
ある`~URL~path$を返す：
◎
To determine the Cookie Default Path, given a URL path path, run these steps. They return a URL path.
</p>
<ol>
	<li>
~Assert：
［
%~path は`~list$である
］~AND［
%~path は`空$でない
］
◎
Assert: path is a non-empty list.
</li>
	<li>
~IF［
%~path の`~size$ ~GT 1
］
⇒
%~path から最後の~itemを`除去する$
◎
If path's size is greater than 1, then remove path's last item.
</li>
	<li>
~ELSE
⇒
%~path[0] ~SET 空~文字列
◎
Otherwise, set path[0] to the empty string.
</li>
	<li>
~RET %~path
◎
Return path.
</li>
</ol>
</div>

			</section>
			<section id="path-matching">
<h4 title="Path Matching">5.3.4. ~pathの照合-法</h4>

<div class="algo">
<p>
`~path合致するか否か@
を決定する~algoは、
所与の
( `~URL~path$ %要請~path, `~URL~path$ %~cookie~path )
に対し，
ある`真偽値$を返す：
◎
To determine if a URL path requestPath Path-Matches a URL path cookiePath, run these steps. They return a boolean.
</p>
<ol>
	<li>
%直列化-済み要請~path ~LET `~URL~pathを直列化する$( %要請~path )
◎
Let serializedRequestPath be the result of URL path serializing requestPath.
</li>
	<li>
%直列化-済み~cookie~path ~LET `~URL~pathを直列化する$( %~cookie~path )
◎
Let serializedCookiePath be the result of URL path serializing cookiePath.
</li>
	<li>
<p>
~RET ~IS［
~OR↓
］：
◎
↓</p>
		<ul>
			<li>
%直列化-済み~cookie~path ~EQ %直列化-済み要請~path
◎
If serializedCookiePath is serializedRequestPath, then return true.
</li>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
%直列化-済み要請~path は %直列化-済み~cookie~path `から開始して$byteいる
</li>
					<li>
%直列化-済み~cookie~path は `002F^U `/^smb で終端している
</li>
				</ul>
◎
If serializedRequestPath starts with serializedCookiePath and serializedCookiePath ends with a U+002F (/), then return true.
</li>
			<li>
次を順に連結した結果は %直列化-済み~cookie~path `から開始して$byteいる
⇒＃
%直列化-済み要請~path,
`002F^U `/^smb
◎
Return whether the concatenation of serializedRequestPath followed by U+002F (/) starts with serializedCookiePath.
</li>
		</ul>
	</li>
</ol>
</div>

			</section>
		</section>
		<section id="main-algorithms">
<h3 title="Main Algorithms">5.4. 主要な~algo</h3>

			<section id="parse-and-store-a-cookie">
<h4 title="Parse and Store a Cookie">5.4.1. ~cookieを構文解析して格納する</h4>

<div class="algo">
<p>
`~cookieを構文解析して格納する@
~algoは、
所与の
⇒＃
`~byte列$ %入力,
`真偽値$ %~secureか,
［`~domain$／`~IP~address$］ %~host,
`~URL~path$ %~path,
`真偽値$ %~HTTPに限るは許容されるか,
`真偽値$ %公共~接尾辞~用には~hostに限られない~cookieを許容するか,
`真偽値$ %同一-~siteに~StrictOrLaxは許容されるか
◎終
に対し：
◎
To Parse and Store a Cookie given a byte sequence input, boolean isSecure, domain or IP address host, URL path path, boolean httpOnlyAllowed, boolean allowNonHostOnlyCookieForPublicSuffix, and boolean sameSiteStrictOrLaxAllowed:
</p>
<ol>
	<li>
%~cookie ~LET `~cookieを構文解析する$( %入力, %~secureか, %~host, %~path )
◎
Let cookie be the result of running Parse a Cookie with input, isSecure, host, and path.
</li>
	<li>
~IF［
%~cookie ~EQ `失敗^i
］
⇒
~RET
◎
If cookie is failure, then return.
</li>
	<li>
~RET `~cookieを格納する$( ↓ )
⇒＃
%~cookie,
%~secureか,
%~host,
%~path,
%~HTTPに限るは許容されるか,
%公共~接尾辞~用には~hostに限られない~cookieを許容するか,
%同一-~siteに~StrictOrLaxは許容されるか
◎
Return the result of Store a Cookie given cookie, isSecure, host, path, httpOnlyAllowed, allowNonHostOnlyCookieForPublicSuffix, and sameSiteStrictOrLaxAllowed.
</li>
</ol>
</div>

			</section>
			<section id="parse-a-cookie">
<h4 title="Parse a Cookie">5.4.2. ~cookieを構文解析する</h4>

<p>
`~cookie~byte@
とは、
次に挙げる`~byte$である
⇒＃
`09^X,
{ `20^X 〜 `7E^X },
{ `80^X 〜 `FF^X }
</p>

<p class="trans-note">【
（［
`HTAB^P 以外の `CTL^P
］ではない~byte。
】【
この用語は、
他所を集約するための，この訳による追加。
】</p>

<div class="algo">
<p>
`~cookieを構文解析する@
~algoは、
所与の
( `~byte列$ %入力, `真偽値$ %~secureか, `~host$ %~host, `~URL~path$ %~path )
に対し，［
新たな`~cookie$／ `失敗^i
］を返す：
◎
To Parse a Cookie given a byte sequence input, boolean isSecure, host host, URL path path, run these steps. They return a new cookie or failure:
</p>
<ol>
	<li>
%入力 を成す
~EACH( `~byte$ %~byte )
に対し
⇒
~IF［
%~byte は`~cookie~byte$でない
］
⇒
~RET `失敗^i
◎
If input contains a byte in the range 0x00 to 0x08, inclusive, the range 0x0A to 0x1F inclusive, or 0x7F (CTL bytes excluding HTAB), then return failure.
</li>
	<li>
( %名~値~入力, %属性~群~入力 ) ~SET `~byte列を二分する$( %入力, `3B^X `;^smb )
◎
Let nameValueInput be null.
◎
Let attributesInput be the empty byte sequence.
◎
If input contains 0x3B (;), then set nameValueInput to the bytes up to, but not including, the first 0x3B (;), and attributesInput to the remainder of input (including the 0x3B (;) in question).
◎
Otherwise, set nameValueInput to input.
◎
Assert: nameValueInput is a byte sequence.
</li>
	<li>
<p>
( %名前, %値 ) ~LET
</p>
		<ul>
			<li>
%名~値~入力 は `3D^X `=^smb を包含しないならば
⇒
( 空な`~byte列$, %名~値~入力 )
</li>
			<li>
~ELSE_ 
⇒
`~byte列を二分する$( %名~値~入力, `3D^X `=^smb )
</li>
		</ul>
◎
Let name be null.
◎
Let value be null.
◎
If nameValueInput does not contain a 0x3D (=) character, then set name to the empty byte sequence, and value to nameValueInput.
◎
Otherwise, set name to the bytes up to, but not including, the first 0x3D (=), and set value to the bytes after the first 0x3D (=) (possibly being the empty byte sequence).
</li>
	<li>
%名前 から頭部と尾部を成す `WSP^P ~byte列を除去する
◎
↓</li>
	<li>
%値 から頭部と尾部を成す `WSP^P ~byte列を除去する
◎
Remove any leading or trailing WSP bytes from name and value.
</li>
	<li>
~IF［
( %名前 の`長さ$byte ~PLUS %値 の`長さ$byte ) ~NIN { 1 〜 4096 }
］
⇒
~RET `失敗^i
◎
If name's length + value's length is 0 or is greater than 4096, then return failure.
</li>
	<li>
%~cookie ~LET 新たな`~cookie$
— その
⇒＃
`名前$cK ~SET %名前,
`値$cK ~SET %値
◎
Let cookie be a new cookie whose name is name and value is value.
</li>
	<li>
<p>
%~cookie の`~path$cK ~SET `~cookieの既定の~path$( %~path )
◎
Set cookie's path to the result of running Cookie Default Path with path.
</p>

<p class="note">注記：
`Path$ca 属性は、
これを上書きし得る
◎
Note: A Path attribute can override this.
</p>
	</li>
	<li>
<p>
~WHILE［
%属性~群~入力 の`長さ$byte ~NEQ 0
］：
◎
While attributesInput is not an empty byte sequence:
</p>
		<ol>
			<li>
%最大-齢は在るか ~LET ~F
◎
Let maxAgeSeen be false.
</li>
			<li>
( %属性~名~値~入力, %属性~群~入力 ) ~SET `~byte列を二分する$( %属性~群~入力, `3B^X `;^smb )
◎
Let char be the result of consuming the first byte of attributesInput.
◎
Assert: char is 0x3B (;).
◎
Let attributeNameValueInput be null.
◎
If attributesInput contains 0x3B (;), then set attributeNameValueInput to the result of consuming the bytes of attributesInput up to, but not including, the first 0x3B (;).
◎
Otherwise, set attributeNameValueInput to the result of consuming the remainder of attributesInput.
</li>
			<li>
( %属性~名, %属性~値 ) ~LET `~byte列を二分する$( %属性~名~値~入力, `3D^X `=^smb )
◎
Let attributeName be null.
◎
Let attributeValue be the empty string.
◎
If attributeNameValueInput contains a 0x3D (=), then set attributeName to the bytes up to, but not including, the first 0x3D (=) of attributeNameValueInput, and attributeValue to the bytes after the first 0x3D (=) of attributeNameValueInput.
◎
Otherwise, set attributeName to attributeNameValueInput.
</li>
			<li>
%属性~名 から頭部と尾部を成す `WSP^P ~byte列を除去する 
◎
↓</li>
			<li>
%属性~値 から頭部と尾部を成す `WSP^P ~byte列を除去する
◎
Remove any leading or trailing WSP bytes from attributeName and attributeValue.
</li>
			<li>
~IF［
%属性~値 の`長さ$byte ~GT 1024
］
⇒
~CONTINUE
◎
If attributeValue's length is greater than 1024, then continue.
</li>
			<li>
%属性~名 ~SET `~byte小文字~化する$( %属性~名 )
◎
↓</li>
			<li>
<p>
~IF［
%属性~名 ~EQ `expires$bl
］：
◎
If attributeName is a byte-case-insensitive match for Expires:
</p>
				<ol>
					<li>
~IF［
%最大-齢は在るか ~EQ ~T
］
⇒
~CONTINUE
◎
If maxAgeSeen is true, then continue.
</li>
					<li>
%失効~時刻 ~LET `日付を構文解析する$( %属性~値 )
◎
Let expiryTime be the result of running Parse a Date given attributeValue.
</li>
					<li>
~IF［
%属性~値 ~EQ `失敗^i
］
⇒
~CONTINUE
◎
If attributeValue is failure, then continue.
</li>
					<li>
%失効~時刻 ~SET `min^op( %失効~時刻, `現-時刻$ ~PLUS `~UA$の`~cookie齢の上限$ )
◎
If expiryTime is greater than the current time and date + the user agent's cookie age limit, then set expiryTime to the user agent's cookie age limit.
</li>
					<li>
任意選択で
⇒
%失効~時刻 ~SET `max^op( %失効~時刻, `~UA$の`最も早い時刻$ )
◎
If expiryTime is earlier than the earliest date the user agent can represent, the user agent MAY replace expiryTime with the earliest representable date.
</li>
					<li>
%~cookie の`失効~時刻$cK ~SET %失効~時刻
◎
Set cookie's expiry-time to expiryTime.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%属性~名 ~EQ `max-age$bl
］：
◎
If attributeName is a byte-case-insensitive match for Max-Age:
</p>
				<ol>
					<li>
~IF［
%属性~値 の`長さ$byte ~EQ 0
］
⇒
~CONTINUE
◎
If attributeValue is empty, continue.
</li>
					<li>
%秒数差 ~LET ［
次が満たされるならば −1 ／
~ELSE_ 0
］
⇒
%属性~名 を成す 0 番の~byte ~EQ `2D^X `-^smb
◎
↓</li>
					<li>
~IF［
%秒数差 ~EQ −1
］
⇒
%属性~名 ~SET %属性~名 から 0 番の~byteを除去した結果
◎
↓</li>
					<li>
~IF［
%属性~値 の`長さ$byte ~EQ 0
］~OR［
%属性~名 を成す ある~byteは `DIGIT^P でない
］
⇒
~CONTINUE
◎
If the first byte of attributeValue is neither a DIGIT, nor 0x2D (-) followed by a DIGIT, then continue.
◎
If the remainder of attributeValue contains a non-DIGIT, then continue.
</li>
					<li>
~IF［
%秒数差 ~NEQ −1
］
⇒
%属性~名 を成す
~EACH( %~byte )
に対し
⇒
%秒数差 ~SET %秒数差 ~MUL 10 ~PLUS ( %~byte の`値$byte ~MINUS `30^X `0^smb )
◎
Let deltaSeconds be attributeValue, converted to a base 10 integer.
</li>
					<li>
<p>
%~cookie の`失効~時刻$cK ~SET %秒数差 に応じて：
</p>
						<ul class="switch">
							<li>
0 ／ −1
⇒
`~UA$の`最も早い時刻$
</li>
							<li>
他の場合
⇒
`現-時刻$ ~PLUS `min^op( %秒数差 秒tを表現する`時間~差$, `~UA$の`~cookie齢の上限$ )
</li>
						</ul>
◎
Set deltaSeconds to the smaller of deltaSeconds and the user agent's cookie age limit, in seconds.
◎
If deltaSeconds is less than or equal to 0, let expiryTime be the earliest representable date and time. Otherwise, let expiryTime be the current date and time + deltaSeconds seconds.
◎
Set cookie's expiry-time to expiryTime.
</li>
					<li>
%最大-齢は在るか ~SET ~T
◎
Set maxAgeSeen to true.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%属性~名 ~EQ `domain$bl
］：
◎
If attributeName is a byte-case-insensitive match for Domain:
</p>
				<ol>
					<li>
%~host ~LET `失敗^i
◎
Let host be failure.
</li>
					<li>
<p>
~IF［
%属性~値 を成す どの~byteも`~ASCII~byte$である
］：
◎
If attributeValue contains only ASCII bytes:
</p>
						<ol>
							<li>
%~host入力 ~LET `~ASCII復号する$( %属性~値 )
◎
Let hostInput be attributeValue, ASCII decoded.
</li>
							<li>
~IF［
%~host入力 は `002E^U `.^smb `から開始して$byteいる
］
⇒
%~host入力 ~SET %~host入力 から先頭の~byteを除去した結果
◎
If hostInput starts with U+002E (.), then set hostInput to hostInput without its leading U+002E (.).
</li>
							<li>
%~host ~SET `~host構文解析器$( %~host入力 )
◎
Set host to the result of host parsing hostInput.
</li>
						</ol>
					</li>
					<li>
%~cookie の`~host$cK ~SET %~host
◎
Set cookie's host to host.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%属性~名 ~EQ `path$bl
］：
◎
If attributeName is a byte-case-insensitive match for Path:
</p>
				<ol>
					<li>
<p>
~IF［
%属性~値 の`長さ$byte ~NEQ 0
］~AND［
%属性~値 を成す 0 番の~byte ~NEQ `2F^X `/^smb
］：
◎
If attributeValue is not empty and if the first byte of attributeValue is 0x2F (/), then:
</p>
						<ol>
							<li>
<p>
%~cookie の`~path$cK ~SET %属性~値 を 0x2F `/^smb で分割した結果
</p>

<p class="trans-note">【
`~path$cKは~ASCII文字列たちが成す~listなので，
`~ASCII復号する$ことにより文字列に変換する必要もあるが、
`~ASCII~byte$以外の~byteをどう取扱うか指定されていない。
】</p>
◎
Set cookie's path to attributeValue split on 0x2F (/).
</li>
							<li>
%~cookie の`~path属性を有するか$cK ~SET ~T
◎
Set cookie's has-path attribute to true.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~IF［
%属性~名 ~EQ `secure$bl
］
⇒
%~cookie の`~secureか$cK ~SET ~T
◎
If attributeName is a byte-case-insensitive match for Secure:
• Set cookie's secure to true.
</li>
			<li>
~IF［
%属性~名 ~EQ `httponly$bl
］
⇒
%~cookie の`~HTTPに限るか$cK ~SET ~T
◎
If attributeName is a byte-case-insensitive match for HttpOnly:
• Set cookie's http-only to true.
</li>
			<li>
<p>
~IF［
%属性~名 ~EQ `samesite$bl
］：
</p>
				<ol>
					<li>
%属性~値 ~SET `~byte小文字~化する$( %属性~値 )
</li>
					<li>
~IF［
%属性~値 ~IN { `none^bl, `strict^bl, `lax^bl }
］
⇒
%~cookie の`同一-~site$cK ~SET `~ASCII復号する$( %属性~値 )
</li>
				</ol>
◎
If attributeName is a byte-case-insensitive match for SameSite:
• If attributeValue is a byte-case-insensitive match for None, then set cookie's same-site to "none".
• If attributeValue is a byte-case-insensitive match for Strict, then set cookie's same-site to "strict".
• If attributeValue is a byte-case-insensitive match for Lax, then set cookie's same-site to "lax".
</li>
		</ol>
	</li>
	<li>
~RET %~cookie
◎
Return cookie.
</li>
</ol>

<p class="note">注記：
認識されない %属性~名 を伴う`属性$は無視される。
◎
Note: Attributes with an unrecognized attributeName are ignored.
</p>

<p class="note">注記：
これは，意図的に、
同じ名前を伴う`属性$が重ねて現れた場合，より後に現れたものが それまでのものを上書きする
— 一般に，最後に指定された`属性$が “勝つ” よう。
◎
Note: This intentionally overrides earlier cookie attributes so that generally the last specified cookie attribute "wins".
</p>
</div>

<div class="algo">
<p>
`~byte列を二分する@
~algoは、
所与の
( `~byte列$ %入力, `~byte$ %区切子 )
に対し：
</p>
<ol>
	<li>
%頭部 ~LET 空な`~byte列$
</li>
	<li>
%~index ~LET 0
</li>
	<li>
<p>
~WHILE［
%~index ~LT %入力 の`長さ$byte
］
</p>
		<ol>
			<li>
%~byte ~LET %入力 を成す %~index 番の~byte
</li>
			<li>
~IF［
%~byte ~EQ %区切子
］
⇒＃
%~index ~INCBY 1；
~BREAK
</li>
			<li>
%頭部 に %~byte を付加する
</li>
		</ol>
	</li>
	<li>
%残り ~LET %入力 を成す %~index 番から終端までの~byteたちが成す`~byte列$
</li>
	<li>
~RET ( %頭部, %残り )
（どちらも，空になり得る）
</li>
</ol>

<p class="trans-note">【
この~algoは、
記述を簡潔かつ簡明にするために，この訳に導入している。
】</p>
</div>

			</section>
			<section id="store-a-cookie">
<h4 title="Store a Cookie">5.4.3. ~cookieを格納する</h4>

<div class="algo">
<p>
`~cookieを格納する@
~algoは、
所与の
⇒＃
`~cookie$ %~cookie,
`真偽値$ %~secureか,
［`~domain$／`~IP~address$］ %~host,
`真偽値$ %~HTTPに限るは許容されるか,
`真偽値$ %公共~接尾辞~用には~hostに限られない~cookieを許容するか,
`真偽値$ %同一-~siteに~StrictOrLaxは許容されるか
◎終
に対し：
◎
To Store a Cookie given a cookie cookie, boolean isSecure, domain or IP address host, boolean httpOnlyAllowed, boolean allowNonHostOnlyCookieForPublicSuffix, and boolean sameSiteStrictOrLaxAllowed:
</p>
<ol>
	<li>
~Assert：
( %~cookie の`名前$cKの`長さ$byte ~PLUS %~cookie の`値$cKの`長さ$byte ) ~IN { 1 〜 4096 }
◎
Assert: cookie's name's length + cookie's value's length is not 0 or greater than 4096.
</li>
	<li>
~Assert：
%~cookie の`名前$cKを成す どの`~byte$も`~cookie~byte$である
◎
Assert: cookie's name does not contain a byte in the range 0x00 to 0x08, inclusive, in the range 0x0A to 0x1F, inclusive, or 0x7F (CTL characters excluding HTAB).
</li>
	<li>
~IF［
%~cookie の`~host$cK ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If cookie's host is failure, then return null.
</li>
	<li>
%~cookie の
⇒＃
`作成~時刻$cK ~SET `現-時刻$【！現在の日時】,
`最後に~accessした時刻$cK ~SET `現-時刻$【！現在の日時】
◎
Set cookie's creation-time and last-access-time to the current date and time.
</li>
	<li>
<p>
~IF［
%公共~接尾辞~用には~hostに限られない~cookieを許容するか ~EQ ~F
］~AND［
%~cookie の`~host$cK は`公共~接尾辞$である
］：
◎
If allowNonHostOnlyCookieForPublicSuffix is false and cookie's host is a public suffix:
</p>
		<ol>
			<li>
~IF［
( %~cookie の`~host$cK, %~host )
は`同等な~host$である
］
⇒
%~cookie の`~host$cK ~SET ~NULL
◎
If cookie's host is host-equal to host, then set cookie's host to null.
</li>
			<li>
~ELSE
⇒
~RET ~NULL
◎
Otherwise, return null.
</li>
		</ol>

<p class="note">注記：
この段は、
`attacker.example^c 【ある下位domainに居る攻撃者】が［
`example^c 【その`公共~接尾辞$】を値にとる `Domain$ca 属性
］を伴う~cookieを設定することにより［
`site.example^c 【別の下位domain】の完全性を侵害すること
］を防止する。
末端-利用者が `example^c へ直に~navigateしたときは、
~cookieは，依然として設定され得る
— された場合、
当の`~cookie$の`~hostに限るか$cKは，
強制的に ~T に設定されることになる。
◎
Note: This step prevents attacker.example from disrupting the integrity of site.example by setting a cookie with a Domain attribute of example. In the event the end user navigates directly to example, a cookie can still be set and will forcibly have its host-only set to true.
</p>
	</li>
	<li>
<p>
~IF［
%~cookie の`~host$cK ~EQ ~NULL
］：
◎
If cookie's host is null:
</p>
		<ol>
			<li>
%~cookie の`~hostに限るか$cK ~SET ~T
◎
Set cookie's host-only to true.
</li>
			<li>
%~cookie の`~host$cK ~SET %~host
◎
Set cookie's host to host.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
~IF［
`~domain合致するか否か$( %~host, %~cookie の`~host$cK ) ~EQ ~F
］
⇒
~RET ~NULL
◎
If host does not Domain-Match cookie's host, then return null.
</li>
			<li>
%~cookie の`~hostに限るか$cK ~SET ~F
◎
Set cookie's host-only to false.
</li>
		</ol>
	</li>
	<li>
~Assert：
%~cookie の`~host$cKは［
`~domain$／`~IP~address$
］である
◎
Assert: cookie's host is a domain or IP address.
</li>
	<li>
~IF［
%~HTTPに限るは許容されるか ~EQ ~F
］~AND［
%~cookie の`~HTTPに限るか$cK ~EQ ~T
］
⇒
~RET ~NULL
◎
If httpOnlyAllowed is false and cookie's http-only is true, then return null.
</li>
	<li>
<p>
~IF［
%~secureか ~EQ ~F
］：
◎
If isSecure is false:
</p>
		<ol>
			<li>
~IF［
%~cookie の`~secureか$cK ~EQ ~T
］
⇒
~RET ~NULL
◎
If cookie's secure is true, then return null.
</li>
			<li>
<p>
~IF［
`~UA$の`~cookie保管庫$内に ~AND↓ を満たす`~cookie$が在る
］…
◎
If the user agent's cookie store contains at least one cookie existingCookie that meets all of the following criteria:
</p>
				<ul>
					<li>
その`名前$cK ~EQ %~cookie の`名前$cK
◎
existingCookie's name is cookie's name;
</li>
					<li>
その`~secureか$cK ~EQ ~T
◎
existingCookie's secure is true;
</li>
					<li>
<p>
~OR↓：
</p>
						<ul>
							<li>
次の結果 ~EQ ~T
⇒
`~domain合致するか否か$( その`~host$cK, %~cookie の`~host$cK )
</li>
							<li>
次の結果 ~EQ ~T
⇒
`~domain合致するか否か$( %~cookie の`~host$cK, その`~host$cK )
</li>
						</ul>
◎
existingCookie's host Domain-Matches cookie's host, or vice-versa; and
</li>
					<li>
次の結果 ~EQ ~T
⇒
`~path合致するか否か$( %~cookie の`~path$cK, その`~path$cK )
◎
cookie's path Path-Matches existingCookie's path,
</li>
				</ul>
<p>
…ならば
⇒
~RET ~NULL
◎
then return null.
</p>

<p class="note">注記：
~pathの比較が対称でないのは，［
新たに作成された~cookie（ %~cookie ）が~secureでない場合
］に限り［
`~cookie保管庫$を成す既存の~secureな~cookieを上塗りしない
］ことを確保するためであり、
~cookie修正~攻撃に抗する，いくぶんの軽減を供する。
すなわち，既存の~secureな~cookieとして［
`~path$cKに `/login^l を伴うもの
］が在る場合、
同じ`名前$cKを伴う~cookieとして［
`~path$cKに `/^l や `/foo^l を伴うもの
］は設定できても，［
`~path$cKに `/login^l や `/login/en^l を伴うもの
］は設定できない。
【ここでの~secureとは、 `~secureか$cK ~EQ ~T を意味する。】
◎
Note: The path comparison is not symmetric, ensuring only that a newly-created, non-secure cookie does not overlay an existing secure cookie, providing some mitigation against cookie-fixing attacks. That is, given an existing secure cookie named 'a' with a path of '/login', a non-secure cookie named 'a' could be set for a path of '/' or '/foo', but not for a path of '/login' or '/login/en'.
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%~cookie の`同一-~site$cK ~NEQ `none^l
］~AND［
%同一-~siteに~StrictOrLaxは許容されるか ~EQ ~F
］
⇒
~RET ~NULL
◎
If cookie's same-site is not "none" and sameSiteStrictOrLaxAllowed is false, then return null.
</li>
	<li>
~IF［
%~cookie の`同一-~site$cK ~EQ `none^l
］~AND［
%~cookie の`~secureか$cK ~EQ ~F
］
⇒
~RET ~NULL
◎
If cookie's same-site is "none" and cookie's secure is false, then return null.
</li>
	<li>
<p>
%小文字~化~名 ~LET `~byte小文字~化する$( %~cookie の`名前$cK )
</p>

<p class="note">注記：
ここ以降における検査は、
~byte小文字~化された値に対し行われる
— これらの値を文字大小無視な方式で処理する~serverを保護するため。
</p>
◎
↓</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
%小文字~化~名 は `__secure-^bl `から開始して$byteいる
</li>
					<li>
%~cookie の`~secureか$cK ~EQ ~F
</li>
				</ul>
</p>
			</li>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
%小文字~化~名 は `__host-^bl `から開始して$byteいる
</li>
					<li>
%~cookie は`~Host接頭辞に互換$でない
</li>
				</ul>
			</li>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
%小文字~化~名 は `__http-^bl `から開始して$byteいる
</li>
					<li>
%~cookie は`~Http接頭辞に互換$でない
</li>
				</ul>
			</li>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
%小文字~化~名 は `__hosthttp-^bl `から開始して$byteいる
</li>
					<li>
［
%~cookie は`~Host接頭辞に互換$でない
］~OR［
%~cookie は`~Http接頭辞に互換$でない
］
</li>
				</ul>
			</li>
		</ul>
<p>
…ならば
⇒
~RET ~NULL
</p>
◎
If cookie's name, byte-lowercased, starts with __secure- and cookie's secure is false, then return null.
◎
Note: The check here and those below are with a byte-lowercased value in order to protect servers that process these values in a case-insensitive manner.
◎
If cookie's name, byte-lowercased, starts with __host- and cookie is not Host-prefix compatible, then return null.
◎
If cookie's name, byte-lowercased, starts with __http- and cookie is not Http-prefix compatible, then return null.
◎
If cookie's name, byte-lowercased, starts with __hosthttp- and cookie is not both Host-prefix compatible and Http-prefix compatible, then return null.
</li>
	<li>
<p>
~IF［
%小文字~化~名 の`長さ$byte ~EQ 0
］：
</p>
		<ol>
			<li>
%小文字~化~値 ~LET `~byte小文字~化する$( %~cookie の`値$cK )
</li>
			<li>
« `__secure-^bl, `__host-^bl, `__http-^bl, `__hosthttp-^bl  »
を成す
~EACH( %接頭辞 )
に対し
⇒
~IF［
%小文字~化~値 は %接頭辞 `から開始して$byteいる
］
⇒
~RET ~NULL
</li>
		</ol>
◎
If cookie's name is the empty byte sequence and one of the following is true:
• cookie's value, byte-lowercased, starts with __secure-,
• cookie's value, byte-lowercased, starts with __host-,
• cookie's value, byte-lowercased, starts with __http-, or
• cookie's value, byte-lowercased, starts with __hosthttp-,
◎
then return null.
</li>
	<li>
<p>
%旧-~cookie ~LET `~UA$の`~cookie保管庫$内に［
~AND↓ を満たす`~cookie$は在るならば，それ／
無いならば ~NULL
］
</p>
<p class="note">注記：
この~algoは、［
該当する~cookieは 1 個までに限られる
］という不変則を保守する。
</p>
		<ul>
			<li>
その`名前$cK ~EQ %~cookie の`名前$cK
</li>
			<li>
( その`~host$cK, %~cookie の`~host$cK )
は`同等な~host$である
</li>
			<li>
その`~hostに限るか$cK ~EQ %~cookie の`~hostに限るか$cK
</li>
			<li>
<p>
`~URL~pathを直列化する$( その`~path$cK ) ~EQ `~URL~pathを直列化する$( %~cookie の`~path$cK )
</p>

<p class="trans-note">【
原文は，これを “`is path-equal to^en” という定義が不明な句で述べているが、
過去~versionの処理~modelから，このように意図されるものと推定される。
】</p>
</li>
		</ul>
◎
If the user agent's cookie store contains a cookie oldCookie whose name is cookie's name, host is host-equal to cookie's host, host-only is cookie's host-only, and path is path-equal to cookie's path:
◎
↓</li>
	<li>
<p>
~IF［
%旧-~cookie ~NEQ ~NULL
］：
◎
↑</p>
		<ol>
			<li>
~IF［
%~HTTPに限るは許容されるか ~EQ ~F
］~AND［
%旧-~cookie の`~HTTPに限るか$cK ~EQ ~T
］
⇒
~RET ~NULL
◎
If httpOnlyAllowed is false and oldCookie's http-only is true, then return null.
</li>
			<li>
<p>
~IF［
~AND↓
］…
</p>
			<ul>
				<li>
%~cookie の`~secureか$cK ~EQ %旧-~cookie の`~secureか$cK
</li>
				<li>
%~cookie の`同一-~site$cK ~EQ %旧-~cookie の`同一-~site$cK
</li>
				<li>
%~cookie の`失効~時刻$cK ~EQ %旧-~cookie の`失効~時刻$cK
</li>
			</ul>
<p>
…ならば
⇒
~RET ~NULL
</p>
◎
If cookie's secure is equal to oldCookie's secure, cookie's same-site is equal to oldCookie's same-site, and cookie's expiry-time is equal to oldCookie's expiry-time, then return null.
</li>
			<li>
%~cookie の`作成~時刻$cK ~SET %旧-~cookie の`作成~時刻$cK
◎
Set cookie's creation-time to oldCookie's creation-time.
</li>
			<li>
`~UA$の`~cookie保管庫$から %旧-~cookie を除去する
◎
Remove oldCookie from the user agent's cookie store.
</li>
		</ol>
	</li>
	<li>
`~UA$の`~cookie保管庫$内に %~cookie を挿入する
◎
↑ Note: This algorithm maintains the invariant that there is at most one such cookie.
◎
Insert cookie into the user agent's cookie store.
</li>
	<li>
~RET %~cookie
◎
Return cookie.
</li>
</ol>
</div>

			</section>
			<section id="garbage-collect-cookies">
<h4 title="Garbage Collect Cookies">5.4.4. ~cookieたちを~garbage収集する</h4>

<div class="algo">
<p>
`~cookieたちを~garbage収集する@
~algoは、
所与の
( `~host$ %~host )
に対し：
◎
To Garbage Collect Cookies given a host host:
</p>
<ol>
	<li>
%除去された~cookie群 ~LET `失効した~cookieたちを除去する$()
◎
Let expiredCookies be the result of running Remove Expired Cookies.
</li>
	<li>
%除去された~cookie群 を次の結果で`拡張する$
⇒
`~host用の超過~cookieたちを除去する$( %~host )
◎
Let excessHostCookies be the result of running Remove Excess Cookies for Host given host.
</li>
	<li>
%除去された~cookie群 を次の結果で`拡張する$
⇒
`超過~大域~cookieたちを除去する$()
◎
Let excessGlobalCookies be the result of running Remove Global Excess Cookies.
</li>
	<li>
~RET %除去された~cookie群
◎
↑ Let removedCookies be « ».
◎
↑ For each cookieList of « expiredCookies, excessHostCookies, excessGlobalCookies », do the following:
• Extend removedCookies with cookieList.
◎
Return removedCookies
</li>
</ol>
</div>

			</section>
			<section id="retrieve-cookies">
<h4 title="Retrieve Cookies">5.4.5. ~cookieたちを検索取得する</h4>

<div class="algo">
<p>
`~cookieたちを検索取得する@
~algoは、
所与の
⇒＃
`真偽値$ %~secureか,
`~host$ %~host,
`~URL~path$ %~path,
`真偽値$ %~HTTPに限るは許容されるか,
`文字列$ %同一-~site
◎終
に対し：
◎
To Retrieve Cookies given a boolean isSecure, host host, URL path path, boolean httpOnlyAllowed, and string sameSite:
</p>
<ol>
	<li>
~Assert：
%同一-~site ~IN { `strict-or-less^l, `lax-or-less^l, `unset-or-less^l, `none^l }
◎
Assert: sameSite is "strict-or-less", "lax-or-less", "unset-or-less", or "none".
</li>
	<li>
<p>
%~cookie群 ~LET `~UA$の`~cookie保管庫$内の ~AND↓ を満たす`~cookie$たちが成す`~list$：
◎
Let cookies be all cookies from the user agent's cookie store that meet these conditions:
</p>
		<ul>
			<li>
<p>
~OR↓：
◎
One of the following is true:
</p>
				<ul>
					<li>
［
その`~hostに限るか$cK ~EQ ~T
］~AND［
( %~host, その`~host$cK )
は`同等な~host$である
］
◎
cookie's host-only is true and host is host-equal to cookie's host, or
</li>
					<li>
［
その`~hostに限るか$cK ~EQ ~F
］~AND［
`~domain合致するか否か$( %~host, その`~host$cK ) ~EQ ~T
］
◎
cookie's host-only is false and host Domain-Matches cookie's host.
</li>
				</ul>
<p>
公共~接尾辞~listは、
~cookieが作成された後に変更されることもあり得る。
その結果，ある`~cookie$の`~host$cKが`公共~接尾辞$になった場合、
当の~cookieの`~hostに限るか$cK ~EQ ~F ならば，
当の~cookieは返されるベキでない。
◎
It's possible that the public suffix list changed since a cookie was created. If this change results in a cookie's host becoming a public suffix and the cookie's host-only is false, then that cookie SHOULD NOT be returned.
</p>

<p class="issue">【！XXX】
この要件は、
おそらく，ここ以外のどこかへ移動するべきである
— この無効~化は、
`公共~接尾辞$を更新するときの一部として起こるべきなので。
◎
XXX: We should probably move this requirement out-of-bound as this invalidation should happen as part of updating the public suffixes.
</p>
			</li>
			<li>
次の結果 ~EQ ~T
⇒
`~path合致するか否か$( %~path , その`~path$cK )
◎
path Path-Matches cookie's path.
</li>
			<li>
<p>
~OR↓：
◎
One of the following is true:
</p>
				<ul>
					<li>
［
その`~secureか$cK ~EQ ~T
］~AND［
%~secureか ~EQ ~T
］
◎
cookie's secure is true and isSecure is true, or
</li>
					<li>
その`~secureか$cK ~EQ ~F
◎
cookie's secure is false.
</li>
				</ul>
			</li>
			<li>
<p>
~OR↓：
◎
One of the following is true:
</p>
				<ul>
					<li>
［
その`~HTTPに限るか$cK ~EQ ~T
］~AND［
%~HTTPに限るは許容されるか ~EQ ~T
］
◎
cookie's http-only is true and httpOnlyAllowed is true, or
</li>
					<li>
その`~HTTPに限るか$cK ~EQ ~F
◎
cookie's http-only is false.
</li>
				</ul>
			</li>
			<li>
<p>
~OR↓：
◎
One of the following is true:
</p>
				<ul>
					<li>
［
その`同一-~site$cK ~EQ `strict^l
］~AND［
%同一-~site ~EQ `strict-or-less^l
］
◎
cookie's same-site is "strict" and sameSite is "strict-or-less";
</li>
					<li>
［
その`同一-~site$cK ~EQ `lax^l
］~AND［
%同一-~site ~IN { `strict-or-less^l, `lax-or-less^l }
］
◎
cookie's same-site is "lax" and sameSite is one of "strict-or-less" or "lax-or-less";
</li>
					<li>
［
その`同一-~site$cK ~EQ `unset^l
］~AND［
%同一-~site ~IN { `strict-or-less^l, `lax-or-less^l, `unset-or-less^l }
］
◎
cookie's same-site is "unset" and sameSite is one of "strict-or-less", "lax-or-less", or "unset-or-less"; or
</li>
					<li>
その`同一-~site$cK ~EQ `none^l
◎
cookie's same-site is "none".
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
<p>
%~cookie群 ~SET `~listを昇順に~sortする$( %~cookie群, 次の手続き )
</p>

<div class="algo">
<p>
手続きは、
所与の
( `~cookie$ %A, `~cookie$ %B )
に対し：
</p>
		<ol>
			<li>
~IF［
%A の`~path$cKの`~size$ ~NEQ %B の`~path$cKの`~size$
］
⇒
~RET ~IS［
%A の`~path$cKの`~size$ ~GT %B の`~path$cKの`~size$
］
</li>
			<li>
~RET ~IS［
%A の`作成~時刻$cK ~LT %B の`作成~時刻$cK
］
</li>
		</ol>
</div>
◎
Sort cookies in the following order:
• Cookies whose path's size is greater are listed before cookies whose path's size is smaller.
• Among cookies whose path's size is equal, cookies whose creation-time is earlier are listed before cookies whose creation-time is later.
</li>
	<li>
<p>
%~cookie群 を成す
~EACH( %~cookie )
に対し
⇒
%~cookie の`最後に~accessした時刻$cK ~SET `現-時刻$【！現在の日時】
</p>

<p>
（これらの変更は、
`~UA$の`~cookie保管庫$内に反映される。）
</p>
◎
Set the last-access-time of each cookie of cookies to the current date and time and reflect these changes in the user agent's cookie store.
</li>
	<li>
~RET %~cookie群
◎
Return cookies.
</li>
</ol>
</div>

			</section>
			<section id="serialize-cookies">
<h4 title="Serialize Cookies">5.4.6. ~cookieたちを直列化する</h4>

<div class="algo">
<p>
`~cookieたちを直列化する@
~algoは、
所与の
( `~cookie$たちが成す~list %~cookie群 )
に対し：
◎
To Serialize Cookies given a list of cookies cookies:
</p>
<ol>
	<li>
%出力 ~LET 空な`~byte列$
◎
Let output be an empty byte sequence.
</li>
	<li>
<p>
%~cookie群 を成す
~EACH( %~cookie )
に対し：
◎
For each cookie of cookies:
</p>
		<ol>
			<li>
~IF［
%出力 の`長さ$byte ~NEQ 0
］
⇒
%出力 に次を順に付加する
⇒＃
`3B^X `;^smb,
`20^X (SP)
◎
If output is not the empty byte sequence, then append 0x3B (;) followed by 0x20 (SP) to output.
</li>
			<li>
( %名前, %値 ) ~LET ( %~cookie の`名前$cK, %~cookie の`値$cK )
◎
↓</li>
			<li>
~IF［
%名前 の`長さ$byte ~NEQ 0
］
⇒
%出力 に次を順に付加する
⇒＃
%名前,
`3D^X `=^smb
◎
If cookie's name is not the empty byte sequence, then append cookie's name followed by 0x3D (=) to output.
</li>
			<li>
%出力 に %値 を付加する
◎
Append cookie's value to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="requirements-specific-to-non-browser-user-agents">
<h3 title="Requirements Specific to Non-Browser User Agents">5.5. 非~browser~UAに特有な要件</h3>

			<section id="set-cookie">
<h4 title="The Set-Cookie Header Field">5.5.1. `Set-Cookie^h ~header</h4>

<p>
`~UA$は、
~HTTP応答 %応答 内に `Set-Cookie^h ~header %~header を受信したときは：
◎
When a user agent receives a Set-Cookie header field in an HTTP response, the user agent＼
</p>
<ul>
	<li>
自身の~cookie施策に則って，
%~header をまるごと無視してもヨイ
（ `~cookie施策§を見よ）。
◎
MAY ignore the Set-Cookie header field in its entirety as per its cookie policy (see Section 7.2).
</li>
	<li>
%応答 の`状態s~code$が 100 番台（ `1xx$st ）である場合、
%~header を無視してもヨイ。
◎
User agents MAY ignore Set-Cookie header fields contained in responses with 100-level status codes.
</li>
	<li>
他の場合
（ 400 番台（ `4xx$st ）や 500 番台（ `5xx$st ）も含む）、
%~header を以下に従って処理するベキである：
◎
Set-Cookie header fields contained in responses with non-100-level status codes (including those in responses with 400- and 500-level status codes) SHOULD be processed as follows:
</li>
</ul>

<div class="algo">
<p>
%~header を処理する~algoは：
◎
↑</p>
<ol>
	<li>
%~URL ~LET 要請の~URL
【 %応答 が応対した要請の`~target~URI$に等価な`~URL$】
◎
↓</li>
	<li>
%~secureか ~LET ~IS［
%~URL の`~scheme$urlは、
`実装定義$な方式で，`~secure$であるものと判断される
］
◎
Let isSecure be a boolean indicating whether request's URL's scheme is deemed secure, in an implementation-defined manner.
</li>
	<li>
%~host ~LET 要請の~host
【 %~URL の`~host$url？】
◎
Let host be request's host.
</li>
	<li>
%~path ~LET %~URL の`~path$url
◎
Let path be request's URL's path.
</li>
	<li>
%~HTTPに限るは許容されるか ~LET ~T
◎
Let httpOnlyAllowed be true.
</li>
	<li>
%公共~接尾辞~用には~hostに限られない~cookieを許容するか ~LET `実装定義$な真偽-値
◎
Let allowNonHostOnlyCookieForPublicSuffix be a boolean whose value is implementation-defined.
</li>
	<li>
%同一-~siteに~StrictOrLaxは許容されるか ~LET `実装定義$な真偽-値
◎
Let sameSiteStrictOrLaxAllowed be a boolean whose value is implementation-defined.
</li>
	<li>
%~cookie ~LET `~cookieを構文解析して格納する$( ↓ )
⇒＃
%~header の`~field値$,
%~secureか,
%~host,
%~path,
%~HTTPに限るは許容されるか,
%公共~接尾辞~用には~hostに限られない~cookieを許容するか,
%同一-~siteに~StrictOrLaxは許容されるか
◎
Let cookie be the result of running Parse and Store a Cookie given the header field value, isSecure, host, path, httpOnlyAllowed, allowNonHostOnlyCookieForPublicSuffix, and sameSiteStrictOrLaxAllowed.
</li>
	<li>
~IF［
%~cookie ~EQ ~NULL
］
⇒
~RET
◎
If cookie is null, then return.
</li>
	<li>
`~cookieたちを~garbage収集する$( %~cookie の`~host$cK )
◎
Run Garbage Collect Cookies given cookie's host.
</li>
</ol>
</div>

			</section>
			<section id="cookie">
<h4 title="The Cookie Header Field">5.5.2. `Cookie^h ~header</h4>

<p>
`~UA$は、
以前に格納した`~cookie$を `Cookie^h 要請~headerに内包することになる。
◎
The user agent includes stored cookies in the Cookie request header field.
</p>

<p>
`~UA$は、
~HTTP要請を`生成する$ときは
⇒＃
複数個の `Cookie^h ~headerを付してはナラナイ。
`Cookie^h ~headerをまるごと省略してもヨイ。
◎
When the user agent generates an HTTP request, the user agent MUST NOT attach more than one Cookie header field.
◎
A user agent MAY omit the Cookie header field in its entirety.
</p>

<div class="algo">
<p>
`~UA$は、
~HTTP要請 %要請 に `Cookie^h ~headerを付する場合には，
その値を次に従って算出しなければナラナイ：
◎
If the user agent does attach a Cookie header field to an HTTP request, the user agent MUST compute its value as follows:
</p>
<ol>
	<li>
%~URL ~LET %要請 の~URL
【 %要請 の`~target~URI$に等価な`~URL$】
◎
↓</li>
	<li>
%~secureか ~LET ~IS［
%~URL の`~scheme$urlは、
`実装定義$な方式で，`~secure$であるものと判断される
］
◎
Let isSecure be a boolean indicating whether request's URL's scheme is deemed secure, in an implementation-defined manner.
</li>
	<li>
%~host ~LET %要請 の~host
【 %~URL の`~host$url？】
◎
Let host be request's host.
</li>
	<li>
%~path ~LET %~URL の`~path$url
◎
Let path be request's URL's path.
</li>
	<li>
%~HTTPに限るは許容されるか ~LET ~T
◎
Let httpOnlyAllowed be true.
</li>
	<li>
%同一-~site ~LET `実装定義$な次に挙げるいずれかの`文字列$
⇒＃
`strict-or-less^l,
`lax-or-less^l,
`unset-or-less^l ,
`none^l
◎
Let sameSite be a string whose value is implementation-defined, but has to be one of "strict-or-less", "lax-or-less", "unset-or-less", or "none".
</li>
	<li>
%~cookie群 ~LET `~cookieたちを検索取得する$( ↓ )
⇒＃
%~secureか,
%~host,
%~path,
%~HTTPに限るは許容されるか,
%同一-~site
◎
Let cookies be the result of running Retrieve Cookies given isSecure, host, path, httpOnlyAllowed, and sameSite.
</li>
	<li>
~RET `~cookieたちを直列化する$( %~cookie群 )
◎
Return the result of running Serialize Cookies given cookies.
</li>
</ol>
</div>

<p class="note">注記：
この仕様の以前の~versionでは、
要請~内に送信する `Cookie^h ~headerを 1 個に限るものと要求していた。
これは、
もはや要件ではない。
この仕様は， 1 個の `cookie-string$p を生産するよう要求するが、
一部の`~UA$は，それを複数個の `Cookie^h ~headerにまたがるよう分割することもある。
例えば、
`RFC9113$r `8.2.3＠~HTTPv2#CompressCookie§,
`RFC9114$r【！`HTTP$r】 `~field圧縮＠~HTTPv3#field-compression§
を見よ。
◎
Note: Previous versions of this specification required that only one Cookie header field be sent in requests. This is no longer a requirement. While this specification requires that a single cookie-string be produced, some user agents may split that string across multiple Cookie header fields. For examples, see Section 8.2.3 of [RFC9113] and Section 4.2.1 of [HTTP].
</p>

			</section>
			<section id="cookie-store-eviction-for-non-browser-user-agents">
<h4 title="Cookie Store Eviction for Non-Browser User Agents">5.5.3. 非~browser~UA用の~cookie保管庫からの抹消</h4>

<p>
`~UA$は、［
どの時点であれ，自身の`~cookie保管庫$を成す 1 個以上の`~cookie$が`失効した$とき
］は，次を~callすることにより［
それらすべてを保管庫から抹消する
］ベキである
⇒
`失効した~cookieたちを除去する$()
◎
The user agent SHOULD evict all expired cookies from its cookie store if, at any time, an expired cookie exists in the cookie store, by calling Remove Expired Cookies.
</p>

<p>
`~UA$は，
（自身により定義されるとおり）
“現在の~sessionが終わった”
ときは、
`~cookie保管庫$から次を満たす`~cookie$すべてを除去しなければナラナイ
⇒
その`失効~時刻$cK ~EQ ~NULL
◎
When "the current session is over" (as defined by the user agent), the user agent MUST remove from the cookie store all cookies whose expiry-time is null.
</p>

			</section>
		</section>
		<section id="requirements-specific-to-browser-user-agents">
<h3 title="Requirements Specific to Browser User Agents">5.6. ~browser~UAに特有な要件</h3>

<p>
各~browser`~UA$には、
一般に，
非~browser`~UA$と同じ~modelに従うことが期待される。
一方で，~browser~UAには、
文書~model（および文書を入子にする能）に因り，追加的な複階性が有る
— それは、
この仕様の視野から外れるものと見なされる。
◎
While browsers are expected to generally follow the same model as non-browser user agents, they have additional complexity due to the document model (and the ability to nest documents) that is considered out-of-scope for this specification.
</p>

<p>
そのような`~UA$用の仕様を築くときは、
次に挙げる~algoに基づくことが期待される
— ［
`Cookie^h ~headerを処理する／
`Set-Cookie^h ~headerを処理する／
`非~HTTP~API$を通して`~UA$の`~cookie保管庫$を操作する
］際には，それらを適切に呼出すよう：
◎
Specifications for such a user agent are expected to build upon the following algorithms and invoke them appropriately to process Cookie and Set-Cookie header fields, as well as manipulating the user agent's cookie store through non-HTTP APIs:
</p>
<ul>
	<li>
`~cookieを構文解析して格納する$
◎
Parse and Store a Cookie
</li>
	<li>
`~cookieを格納する$
◎
Store a Cookie
</li>
	<li>
`失効した~cookieたちを除去する$
◎
Remove Expired Cookies
</li>
	<li>
`~cookieたちを~garbage収集する$
◎
Garbage Collect Cookies
</li>
	<li>
`~cookieたちを検索取得する$
◎
Retrieve Cookies
</li>
	<li>
`~cookieたちを直列化する$
◎
Serialize Cookies
</li>
</ul>

<p>
これは、
~browserに必要な自身の【！to detail？】要件における柔軟性を相当に詳細に供する。
◎
This provides the flexibility browsers need to detail their requirements in considerable detail.
</p>

		</section>
	</section>
	<section id="implementation-considerations">
<h2 title="Implementation Considerations">6. 実装-時の考慮点</h2>

		<section id="limits">
<h3 title="Limits">6.1. 制限s</h3>

<p>
`~server$は、
できるだけ［
少数の~cookie, 小容量な~cookie
］を利用するベキである
⇒＃
これらの実装~制限sに達することを避けるよう／
各 要請に `Cookie^h ~headerが内包されることに因る~network帯域幅を最小~化するよう／
自身が~headerに課す上限（`構文＠#server-syntax§を見よ）に達することを避けるよう
◎
Servers SHOULD use as few and as small cookies as possible to avoid reaching these implementation limits, minimize network bandwidth due to the Cookie header field being included in every request, and to avoid reaching server header field limits (See Section 4.2.1).
</p>

<p>
`~UA$は~cookieをいつでも抹消し得るので、
`~server$は，［
~UAが `Cookie^h ~header内に 1 個以上の~cookieを返すことに失敗したとき
］には上品に退行する（ `gracefully degrade^en ）ベキである。
◎
Servers SHOULD gracefully degrade if the user agent fails to return one or more cookies in the Cookie header field because the user agent might evict any cookie at any time.
</p>

		</section>
		<section id="application-programming-interfaces">
<h3 title="Application Programming Interfaces">6.2. ~API</h3>

<p>
［
`Cookie^h, `Set-Cookie^h
］~headerが，このような込み入った構文を利用する理由の一つは、
多くの~platformが
（~serverと~UAどちらにおいても），
~cookieに対し文字列に基づく~APIを供する結果、
応用~層の~programmerたちに［
これらの~headerに利用される構文を生成して構文解析する
］ことを要求するからである。
その結果、
多くの~programmerから正しく実装されず，相互運用能の問題が生じている。
◎
One reason the Cookie and Set-Cookie header fields use such esoteric syntax is that many platforms (both in servers and user agents) provide a string-based application programming interface (API) to cookies, requiring application-layer programmers to generate and parse the syntax used by the Cookie and Set-Cookie header fields, which many programmers have done incorrectly, resulting in interoperability problems.
</p>

<p>
~platformが，~cookieに対し［
文字列に基づく~APIの代わりに，より意味論上の~API
］を供するなら、
きちんと~serveされることになろう。
特定の~API設計を推奨することは，この文書の視野を超えるが、［
直列化された日付~文字列に代えて，抽象- “Date” ~obj
］を受容することには，明瞭な便益がある。
◎
Instead of providing string-based APIs to cookies, platforms would be well-served by providing more semantic APIs. It is beyond the scope of this document to recommend specific API designs, but there are clear benefits to accepting an abstract "Date" object instead of a serialized date string.
</p>

		</section>
	</section>
	<section id="privacy-considerations">
<h2 title="Privacy Considerations">7. ~privacyの考慮点</h2>

<p>
~cookieの首な~privacy~riskは、
利用者の活動を相関する，その能である。
これは，単独の~site上でも起こり得るが、
最も問題になり得るのは，利用者の~profileを築くために［
互いに~~無関係に見える複数の~web~siteにまたがって，活動が追跡される
］ときである。
◎
Cookies' primary privacy risk is their ability to correlate user activity. This can happen on a single site, but is most problematic when activity is tracked across different, seemingly unconnected Web sites to build a user profile.
</p>

<p>
時を経て，この能力は、
（ `RFC2109$r, および そのすべての後継にて，明示的に警告されたが）
次に挙げるものなど，様々な理由で広く利用されるようになった：
◎
Over time, this capability (warned against explicitly in [RFC2109] and all of its successors) has become widely used for varied reasons including:
</p>
<ul>
	<li>
複数~siteにまたがって，利用者を認証する
◎
authenticating users across sites,
</li>
	<li>
利用者についての情報を組立てる
◎
assembling information on users,
</li>
	<li>
詐欺行為や他の［
望ましくない流通を形成するもの
］に抗して，保護する
◎
protecting against fraud and other forms of undesirable traffic,
</li>
	<li>
［
特定の利用者／指定された属性を伴う利用者
］を~targetにする広告
◎
targeting advertisements at specific users or at users with specified attributes,
</li>
	<li>
広告が利用者に示された回数や~~頻度を測定する
◎
measuring how often ads are shown to users, and
</li>
	<li>
広告が いつ利用者の挙動における変化をもらしたかを認識する
◎
recognizing when an ad resulted in a change in user behavior.
</li>
</ul>

<p>
~cookieの利用は，~privacyの問題になり得るものばかりではないが、
その濫用の~~可能性は，［
~internet~communityや，より幅広い社会
］に広まった懸念になった。
~UAは、
これらの懸念に呼応して，
~cookieの機能性を様々な仕方で能動的に拘束した
（以前の各~仕様にて許容され, 奨励されたとおり）
— ~Webの健全さに望ましいものと~UAが判定した特能に対する妨害を避けながら。
◎
While not every use of cookies is necessarily problematic for privacy, their potential for abuse has become a widespread concern in the Internet community and broader society. In response to these concerns, user agents have actively constrained cookie functionality in various ways (as allowed and encouraged by previous specifications), while avoiding disruption to features they judge desirable for the health of the Web.
</p>

<p>
~cookieによる~privacyへの影響iを軽減するために利用されるべき特定の仕組みについて，
総意を宣言するのは、
まだ早過ぎる。
それらがどう取扱われるかについての，~UAによる進行中な変更点は、
その最終的な総意への入力を供し得る実験にはなるが，それを超えるものではない。
◎
It is too early to declare consensus on which specific mechanism(s) should be used to mitigate cookies' privacy impact; user agents' ongoing changes to how they are handled are best characterised as experiments that can provide input into that eventual consensus.
</p>

<p>
代わりに，
この文書は、［
~cookieに結付けられる~privacy~riskに抗して，~cookieの広い配備を享受する
］ための，限定的かつ一般的な
— これを書いている時点における —
軽減策を述べる。
実装には、
実験を継続して，時を経るに伴い［
~cookieに対し，より［
厳密かつ きちんと定義された
］制限を課す
］ことが期待される。
この文書の将来~versionは、
それらの仕組みを配備~経験に基づいて成文化するものにもなろう。
現在，~cookieに依拠している機能を［
それを~targetにする別々な仕組み
］により~supportできるならば、
それらを別々な仕様にて文書化することにより，~cookieに対する より厳密な制限が実現可能になるかもしれない。
◎
Instead, this document describes limited, general mitigations against the privacy risks associated with cookies that enjoy wide deployment at the time of writing. It is expected that implementations will continue to experiment and impose stricter, more well-defined limitations on cookies over time. Future versions of this document might codify those mechanisms based upon deployment experience. If functions that currently rely on cookies can be supported by separate, targeted mechanisms, they might be documented in separate specifications and stricter limitations on cookies might become feasible.
</p>

<p>
~cookieは，
複数~siteにまたがって利用者を追跡するために利用できる唯一の仕組みではないので、
これらの軽減策は
— ~Web~privacyを改善するために必要yであるとしても —
それだけで足るものにはならないことに注意。
◎
Note that cookies are not the only mechanism that can be used to track users across sites, so while these mitigations are necessary to improve Web privacy, they are not sufficient on their own.
</p>

		<section id="third-party-cookies">
<h3 title="Third-Party Cookies">7.1. 第三者-主体~cookie</h3>

<p>
“第三者-主体（ `third-party^en ）” ~cookie（ “非同一-~site（ `cross-site^en ）” ~cookieとも称される）とは、［
埋込まれた内容（~script, 画像, ~stylesheet, ~frameなど）のうち，
首な資源（通例的に，利用者が見ている~web~page）を~hostする~serverとは異なる~serverから得されたもの
］に結付けられた~cookieである。
第三者-主体~cookieは、
異なる各~siteにおける利用者の活動を相関するために利用されることが多い。
◎
A "third-party" or cross-site cookie is one that is associated with embedded content (such as scripts, images, stylesheets, frames) that is obtained from a different server than the one that hosts the primary resource (usually, the Web page that the user is viewing). Third-party cookies are often used to correlate users' activity on different sites.
</p>

<p>
第三者-主体~cookieには，内来的に~privacyの課題があるので、
今や ほとんどの~UAは，それらを多様な仕方で制限する。
ある~UAは、［
第三者-主体による `Set-Cookie^h ~headerを処理すること,
第三者-主体による `Cookie^h ~headerを送信すること
］どちらも拒否することにより，第三者-主体~cookieを完全に阻止する。
ある~UAは、
当事者-主体の文脈に基づいて
— 閲覧されている~siteに依存して異なる~cookieが送信されるよう —
~cookieを仕分ける。
ある~UAは、［
自身の~cookie施策や利用者-制御
］に基づいて，~cookieを阻止する。
◎
Because of their inherent privacy issues, most user agents now limit third-party cookies in a variety of ways. Some completely block third-party cookies by refusing to process third-party Set-Cookie header fields and refusing to send third-party Cookie header fields. Some partition cookies based upon the first-party context, so that different cookies are sent depending on the site being browsed. Some block cookies based upon user agent cookie policy and/or user controls.
</p>

<p>
この文書は，
特定の~approachを承認するものでも要求するものでもないが、
~UAには，第三者-主体~cookie用の施策として［
互換性の拘束が許可する限り，制約的なもの
］を採用することが`推奨される^2119。
その帰結として、
少なくとも当面の間は，資源は［
第三者-主体~cookieが，各~UAにより一貫して扱われること
］には依拠し得ないものと見込まれる。
◎
While this document does not endorse or require a specific approach, it is RECOMMENDED that user agents adopt a policy for third-party cookies that is as restrictive as compatibility constraints permit. Consequently, resources cannot rely upon third-party cookies being treated consistently by user agents for the foreseeable future.
</p>

		</section>
		<section id="cookie-policy">
<h3 title="Cookie Policy">7.2. ~cookie施策</h3>

<p>
`~UA$は、
~cookie施策を施行してもヨイ
— それは、
~cookieをどう［
利用し得る／無視し得る
］かについての制約からなる
（ `5.5.1＠#set-cookie§ を見よ）。
◎
User agents MAY enforce a cookie policy consisting of restrictions on how cookies may be used or ignored (see Section 5.5.1).
</p>

<p>
~cookie施策は、
どの~domain, あるいは どの主体に対し
— 後者は当事者-主体, 第三者-主体どちらなのかに応じて（`第三者-主体~cookie＠#third-party-cookies§を見よ） —
［
~UAが~cookie~accessを許容するかどうか
］を統治し得る。
施策は、
~cookieの［
~size,
失効（ `Expires$ca 属性, `Max-Age$ca 属性を見よ）
~domainごとの個数【`~hostごとの総~cookie数の上限$】／
総数【`総~cookie数の上限$】
］に対しても制限sを定義し得る。
◎
A cookie policy may govern which domains or parties, as in first and third parties (see Section 7.1), for which the user agent will allow cookie access. The policy can also define limits on cookie size, cookie expiry (see Section 4.1.2.1 and Section 4.1.2.2), and the number of cookies per domain or in total.
</p>

<p>
制約的な~cookie施策は、［
~security／~privacy
］を改善することを目標とすることが多い。
~UAは、
~cookie施策を変更することを利用者に許容することが多い
（`利用者-制御＠#user-controls§を見よ）。
◎
The goal of a restrictive cookie policy is often to improve security or privacy. User agents often allow users to change the cookie policy (see Section 7.3).
</p>

		</section>
		<section id="user-controls">
<h3 title="User Controls">7.3. 利用者-制御</h3>

<p>
`~UA$は、
`~cookie保管庫$に格納された~cookieを管理するための仕組みを，
利用者に供するベキである。
例えば、
~cookieのうち［
指定された期間内に受信されたもの ／
特定0の~domainに関係するもの
］すべてを，利用者が削除できるようにするなど。
多くの~UAは、
利用者が`~cookie保管庫$に格納された~cookieを精査できるような~UIを備えている。
◎
User agents SHOULD provide users with a mechanism for managing the cookies stored in the cookie store. For example, a user agent might let users delete all cookies received during a specified time period or all the cookies related to a particular domain. In addition, many user agents include a user interface element that lets users examine the cookies stored in their cookie store.
</p>

<p>
`~UA$は、
~cookieを不能化する仕組みを，利用者に供するベキである。
~cookieが不能化されている場合、
~UAは
⇒＃
`~server$への~HTTP要請に `Cookie^h ~headerを内包してはナラナイ／
`~server$からの~HTTP応答~内の `Set-Cookie^h ~headerを処理してはナラナイ
◎
User agents SHOULD provide users with a mechanism for disabling cookies. When cookies are disabled, the user agent MUST NOT include a Cookie header field in outbound HTTP requests and the user agent MUST NOT process Set-Cookie header fields in inbound HTTP responses.
</p>

<p>
`~UA$は、
`~cookie施策$を変更する仕方を提供してもヨイ（ `~cookie施策§を見よ）。
◎
User agents MAY offer a way to change the cookie policy (see Section 7.2).
</p>

<p>
`~UA$は、［
複数~sessionにわたる`~cookie$の持続的な保管を防止する~option
］を利用者に供してもヨイ。
そのように環境設定されている場合、
~UAは，受信したすべての`~cookie$を［
その`失効~時刻$cK ~EQ ~NULL であった
］かのように扱わなければナラナイ。
◎
User agents MAY provide users the option of preventing persistent storage of cookies across sessions. When configured thusly, user agents MUST treat all received cookies as if their expiry-time is null.
</p>

		</section>
		<section id="expiration-dates">
<h3 title="Expiration Dates">7.4. 有効期限</h3>

<p>
`~server$は，`~cookie$の有効期限【`失効~時刻$cK】を遠い未来に設定できるが、
ほとんどの`~UA$は，実際に~cookieを何十年も維持することはない。
`~server$は、
各~cookieに対し
— 無用に長い有効期間を設定せずに —
その目的に基づいた適度な有効期間を設定することにより，
利用者の~privacyを促進するベキである。
例えば、
~session識別子の代表的な期限は，
2 週間くらいが適度であろう。
◎
Although servers can set the expiration date for cookies to the distant future, most user agents do not actually retain cookies for multiple decades. Rather than choosing gratuitously long expiration periods, servers SHOULD promote user privacy by selecting reasonable cookie expiration periods based on the purpose of the cookie. For example, a typical session identifier might reasonably be set to expire in two weeks.
</p>

		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">8. ~securityの考慮点</h2>

		<section id="overview">
<h3 title="Overview">8.1. 概観</h3>

<p>
~cookieには、
~securityの陥穽がいくつかある。
この節では、
その中で少数の，特に際立つ課題を概観する。
◎
Cookies have a number of security pitfalls. This section overviews a few of the more salient issues.
</p>

<p>
~cookieは特に、
認証における`~ambient権限$に依拠するよう開発者に促す結果，
`~CSRF攻撃$ `CSRF$r
に対する脆弱性に転じることが多い。
また，~session識別子を~cookieに格納する際に、
開発者は，~session固定化の脆弱性を生み出すことが多い。
【！ http://security.c-inf.com/index.php?Session%20Fixation】
◎
In particular, cookies encourage developers to rely on ambient authority for authentication, often becoming vulnerable to attacks such as cross-site request forgery [CSRF]. Also, when storing session identifiers in cookies, developers often create session fixation vulnerabilities.
</p>

<p class="trans-note">【
`~ambient権限@
— 環境から暗黙的に（一律に）与えられる権限：
`参考＠https://en.wikipedia.org/wiki/Ambient_authority$
】【
`~CSRF攻撃@
（ `Cross-Site Request Forgery^en ／ ~siteをまたがる要請の偽造）：
`参考＠https://ja.wikipedia.org/wiki/Cross_site_request_forgery$
】【
~session固定化（ `session fixation^en ）：
`参考＠https://en.wikipedia.org/wiki/Session_fixation$
】</p>

<p>
~cookie~protocolには，それ自体に様々な脆弱性があるので
（`機密性の弱点§, `完全性の弱点§を見よ）、
~transport層の暗号化
— ~HTTPSに使役されるものなど —
は，~network攻撃者が被害者の~cookieを［
得する／改める
］ことを防止するには不足である。
加えて、
~cookieは，既定では
— ~HTTPSと併用されているときであっても —
~network攻撃者に抗する機密性や完全性を供さない。
◎
Transport-layer encryption, such as that employed in HTTPS, is insufficient to prevent a network attacker from obtaining or altering a victim's cookies because the cookie protocol itself has various vulnerabilities (see "Weak Confidentiality" and "Weak Integrity", below). In addition, by default, cookies do not provide confidentiality or integrity from network attackers, even when used in conjunction with HTTPS.
</p>

		</section>
		<section id="ambient-authority">
<h3 title="Ambient Authority">8.2. ~ambient権限</h3>

<p>
利用者の認証に~cookieを利用する`~server$は、
一部の~UAが［
~remote主体が，
~UAから~HTTP要請を発行させること
（例：~HTTP~redirectや~HTML~formを介して）
］を~~放任するので，~securityの脆弱性に悩まされることになる。
そのような~UAは、
それらの要請を発行するときに
— ~remote主体が当の~cookieの内容を知らなくとも —
~cookieを付してしまう。
その結果、
騙され易い~serverは，~remote主体から権限を行使され得ることになる。
【~remote主体 — おそらく，第三者-主体と同義。】
◎
A server that uses cookies to authenticate users can suffer security vulnerabilities because some user agents let remote parties issue HTTP requests from the user agent (e.g., via HTTP redirects or HTML forms). When issuing those requests, user agents attach cookies even if the remote party does not know the contents of the cookies, potentially letting the remote party exercise authority at an unwary server.
</p>

<p>
この~securityの懸念には，いくつか呼称があるが
（例：`~CSRF攻撃$や “`confused deputy^en” † ）、
その課題は，~cookieが`~ambient権限$の一形態である所から端を発する。
~cookieは、
（~URLの形をとる）対象の指名（ `designation^en ）と（~cookieの形をとる）対象への権限付与（ `authorization^en ）との分離を，
~serverの運用者たちに促してしまう。
その結果、
~UAは，攻撃者が指名する資源に権限を給するかもしれず、
場合によっては，~serverや~clientは攻撃者により指名された行為を
— 利用者から権限付与されたかのように —
引き受けてしまう。
◎
Although this security concern goes by a number of names (e.g., cross-site request forgery, confused deputy), the issue stems from cookies being a form of ambient authority. Cookies encourage server operators to separate designation (in the form of URLs) from authorization (in the form of cookies). Consequently, the user agent might supply the authorization for a resource designated by the attacker, possibly causing the server or its clients to undertake actions designated by the attacker as though they were authorized by the user.
</p>

<p>
~server運用者たちは、
権限付与に~cookieを利用する代わりに，
~URLを能力（ `capabilities^en ††）として扱うことにより、
対象の指名と対象への権限付与とを絡めるよう望むかもしれない。
この~approachは、
秘匿情報を~cookieに格納する代わりに~URLに格納して†††，
~remote主体【！entity】が秘匿情報~自体を給することを要求する。
この~approachは万能ではないが、
この原理を~~思慮深く応用すれば，より堅牢な~securityへ至らせ得る。
◎
Instead of using cookies for authorization, server operators might wish to consider entangling designation and authorization by treating URLs as capabilities. Instead of storing secrets in cookies, this approach stores secrets in URLs, requiring the remote entity to supply the secret itself. Although this approach is not a panacea, judicious application of these principles can lead to more robust security.
</p>

<p class="trans-note">【†
“`confused deputy^en”
（混乱した使節の~~問題）：
`参考＠https://ja.wikipedia.org/wiki/Confused_deputy_problem$
】【††
`capability^en
— 能力に基づく~security（`~ambient権限$に対立する概念）：
`参考＠https://ja.wikipedia.org/wiki/Capability-based_security$
】【†††
`参考（能力~URL）＠~CAPABILITY-URLS#dfn-capability-urls$
】</p>

		</section>
		<section id="clear-text">
<h3 title="Clear Text">8.3. 平文~text</h3>

<p>
`~secure$な~channel越しに送信されていない限り、
`Cookie^h と `Set-Cookie^h ~header内の情報は，平文のまま伝送される。
◎
Unless sent over a secure channel (such as TLS [TLS13]), the information in the Cookie and Set-Cookie header fields is transmitted in the clear.
</p>
<ol>
	<li>
これらの~headerにより運ばれる，~securityに敏感な情報すべてが、
盗聴者に公開される。
◎
All sensitive information conveyed in these header fields is exposed to an eavesdropper.
</li>
	<li>
悪意的な`媒介者$は，いずれの方向へ流れる~headerも改めれるため、
予測-不能な結果になる。
◎
A malicious intermediary could alter the header fields as they travel in either direction, with unpredictable results.
</li>
	<li>
悪意的な~clientは， `Cookie^h ~headerを その伝送-前に改めれるため、
予測-不能な結果になる。
◎
A malicious client could alter the Cookie header fields before transmission, with unpredictable results.
</li>
</ol>

<p>
`~server$は、
~UAに向けて~cookieの内容を伝送する際には
（~cookieを`~secure$な~channel越しに送信するときでも）、
（自身が欲する何らかの形式で）
暗号化して署名するベキである。
しかしながら，それだけでは、
攻撃者による，~UAから別の~UAへの~cookieの植え付け（ `transplanting^en ）や,
後の時点における~cookieの再現を防止することにはならない。
◎
Servers SHOULD encrypt and sign the contents of cookies (using whatever format the server desires) when transmitting them to the user agent (even when sending the cookies over a secure channel). However, encrypting and signing cookie contents does not prevent an attacker from transplanting a cookie from one user agent to another or from replaying the cookie at a later time.
</p>

<p>
各~cookieごとに内容を暗号化して署名することに加えて、
高~levelな~securityを要する`~server$は、
`~secure$な~channel越しに限り `Cookie^h, `Set-Cookie^h ~headerを利用した上で，
どの~cookieにも `Secure$ca 属性を設定するベキである。
~serverが `Secure$ca 属性を設定しない場合、
`~secure$な~channelにより供される保護は，ほぼ無意味と化すことになる。
◎
In addition to encrypting and signing the contents of every cookie, servers that require a higher level of security SHOULD use the Cookie and Set-Cookie header fields only over a secure channel. When using cookies over a secure channel, servers SHOULD set the Secure attribute (see Section 4.1.2.5) for every cookie. If a server does not set the Secure attribute, the protection provided by the secure channel will be largely moot.
</p>

<p>
例えば、
~cookieの中に~session識別子を格納する~web~mail~serverがあって，
概して~HTTPS越しに~accessされるとする。
~serverがその~cookieに `Secure$ca 属性を設定しなかった場合、
能動的~network攻撃者は、
~UAからの任意の outbound ~HTTP要請を傍受して，
~web~mail~serverに向けて，
その要請を~HTTP越しに~redirectさせることが可能になる。
~web~mail~serverが~HTTP接続を~listenしていなくても、
依然として，~UAは
【~redirectにおける】
要請の中に~cookieを内包することになる。
能動的~network攻撃者は、［
これらの~cookieを傍受して，~serverに向けてそれらを再現する
］ことにより，利用者の~mail内容を読むことが可能になる。
~serverが `Secure$ca 属性をその~cookieに設定していたなら、
~UAはその~cookieを平文~textの要請の中に内包させはしないであろう。
◎
For example, consider a webmail server that stores a session identifier in a cookie and is typically accessed over HTTPS. If the server does not set the Secure attribute on its cookies, an active network attacker can intercept any outbound HTTP request from the user agent and redirect that request to the webmail server over HTTP. Even if the webmail server is not listening for HTTP connections, the user agent will still include cookies in the request. The active network attacker can intercept these cookies, replay them against the server, and learn the contents of the user's email. If, instead, the server had set the Secure attribute on its cookies, the user agent would not have included the cookies in the clear-text request.
</p>

		</section>
		<section id="session-identifiers">
<h3 title="Session Identifiers">8.4. ~session識別子</h3>

<p>
~serverが、
~session情報を（攻撃者に公開されたり, 再現され得る）~cookie内に直に格納する代わりに，
~nonce
（ “`number used once^en （使い捨ての番号）”
— ~~別名 “~session識別子” ）
を~cookieに格納することが、
共通的に行われている。
~serverは，~nonceを伴う~HTTP要請を受信したとき、
その~nonceを~keyに，当の~cookieに結付けられた状態~情報を検索できる。
◎
Instead of storing session information directly in a cookie (where it might be exposed to or replayed by an attacker), servers commonly store a nonce (or "session identifier") in a cookie. When the server receives an HTTP request with a nonce, the server can look up state information associated with the cookie using the nonce as a key.
</p>

<p>
~session識別子~cookieの利用-下では、
攻撃者に~cookieの内容を読まれたときの被害が制限される
— ~nonceが有用になるのは，
（それ自身が~securityに敏感である，非~nonceの~cookieを成す内容と違って）
~serverとヤリトリするときに限られるので。
更に，使い捨て~nonceを利用すれば、［
攻撃者が、
~serverとの 2 回のヤリトリから~cookieの内容を “継ぎ接ぎ” して，
~serverの挙動を期待されないものにする
］ことも防止される。
◎
Using session identifier cookies limits the damage an attacker can cause if the attacker learns the contents of a cookie because the nonce is useful only for interacting with the server (unlike non-nonce cookie content, which might itself be sensitive). Furthermore, using a single nonce prevents an attacker from "splicing" together cookie content from two interactions with the server, which could cause the server to behave unexpectedly.
</p>

<p>
~session識別子の利用には~riskが伴う。
例えば、
~serverは， “~session固定化” の脆弱性を避けるよう注意を払うベキである。
~session固定化~攻撃は、
次の 3 ~~段階を経る：
◎
Using session identifiers is not without risk. For example, the server SHOULD take care to avoid "session fixation" vulnerabilities. A session fixation attack proceeds in three steps.＼
</p>
<ol>
	<li>
攻撃者は、
ある~session識別子 %~session識別子 を自身の~UAで~~取得してから，
被害者の~UAに植え付ける†。
◎
First, the attacker transplants a session identifier from his or her user agent to the victim's user agent.＼
</li>
	<li>
被害者は、
%~session識別子 を~serverとのヤリトリに利用する
（場合によっては、
利用者の資格証（ `credentials^en ）や機密（ `confidential^en ）に関する情報も伴わせて）。
◎
Second, the victim uses that session identifier to interact with the server, possibly imbuing the session identifier with the user's credentials or confidential information.＼
</li>
	<li>
攻撃者は、
%識別子 を利用して~serverと直にヤリトリする
（場合によっては、
利用者の権限（ `authority^en ）や機密に関する情報が奪われる）。
◎
Third, the attacker uses the session identifier to interact with server directly, possibly obtaining the user's authority or confidential information.
</li>
</ol>

<p class="trans-note">【†
植え付ける（ `transplant^en ）：
何らかの方法で
（具体的な手段は`多岐にわたる＠https://www.google.co.jp/search?q=session+fixation$）、
被害者を［
攻撃者が~session識別子により，
一定の権限を有する状態で~serverに~accessできる状況
］と同じ状況へ誘い込む
（しかる後， “体を入れ替える”
— 攻撃者が用意した “合鍵” を被害者に利用させ，
被害者が自身の情報を持ち込むよう仕向けてから、
同じ鍵で侵入する。
したがって、
“~login” 時に鍵を別の鍵に交換することが効果的な対策になると考えられる）。
】</p>

		</section>
		<section id="weak-confidentiality">
<h3 title="Weak Confidentiality">8.5. 機密性の弱点</h3>

<p>
~cookieは~portによる隔離を供さない。
~cookieが，ある~port上で稼働している~serviceで読取れるならば、
その~cookieは，同じ~serverの別~port上の~serviceでも読取れる。
~cookieが，ある~port上の~serviceで書込めるならば、
その~cookieは，同じ~serverの別~port上の~serviceでも書込める。
この理由から、
~serverは、［
同じ~hostの異なる~port上で，互いに信用し合っていない~serviceを同時に稼働しているとき
］は，~securityに敏感な情報を~cookieを利用して格納するベキでない。
◎
Cookies do not provide isolation by port. If a cookie is readable by a service running on one port, the cookie is also readable by a service running on another port of the same server. If a cookie is writable by a service on one port, the cookie is also writable by a service running on another port of the same server. For this reason, servers SHOULD NOT both run mutually distrusting services on different ports of the same host and use cookies to store security-sensitive information.
</p>

<p>
~cookieは~schemeによる隔離を供さない。
~cookieは `http^c と `https^c ~schemeで最も共通的に利用されるが、
所与の~host用の~cookieは，
`ftp^c や `gopher^c などの他の~schemeでも可用になり得る。
この，~schemeによる隔離の欠如は、
~cookieへの~accessを許可する`非~HTTP~API$において顕著に見られるが、
~schemeによる隔離の欠如はまた，
~cookieの処理~要件にも実際に在る
（例：~HTTPを介して `gopher^c ~scheme~URIから検索取得することを考えてみよ）。
【~web~platform（~browser）においては、 `gopher^c はすでに廃されている ／ `ftp^c は廃されつつある。】
◎
Cookies do not provide isolation by scheme. Although most commonly used with the http and https schemes, the cookies for a given host might also be available to other schemes, such as ftp and gopher. Although this lack of isolation by scheme is most apparent in non-HTTP APIs that permit access to cookies (e.g., HTML's document.cookie API), the lack of isolation by scheme is actually present in requirements for processing cookies themselves (e.g., consider retrieving a URI with the gopher scheme via HTTP).
</p>

<p>
~cookieは~pathによる隔離を常に供するものではない。
~network~levelの~protocolでは、
ある~pathに対応して格納された~cookieが，別の~pathに向けて送信されることはないが、
一部の~UAは，`非~HTTP~API$を介して~cookieを公開する。
これらの~UAの一部（例：~web~browser）は，
異なる~pathから受信した資源を隔離しないので、
ある~pathから検索取得された資源は，
別の~path用に格納された~cookieに~access可能になるかもしれない。
◎
Cookies do not always provide isolation by path. Although the network-level protocol does not send cookies stored for one path to another, some user agents expose cookies via non-HTTP APIs, such as HTML's document.cookie API. Because some of these user agents (e.g., web browsers) do not isolate resources received from different paths, a resource retrieved from one path might be able to access cookies stored for another path.
</p>

		</section>
		<section id="weak-integrity">
<h3 title="Weak Integrity">8.6. 完全性の弱点</h3>

<p>
~cookieは、
同胞~domain（およびそれらの下位domain）に対する完全性（ `integrity^en ）を保証しない。
例えば, `foo.site.example^c と `bar.site.example^c を考える。
`foo.site.example^c ~serverは、
`Domain$ca 属性 `site.example^bl を伴う~cookieを設定できる
（場合によっては、
既存の `site.example^bl を伴う~cookieを上書する）。
~UAは、
その~cookieを `bar.site.example^c へ向けた~HTTP要請に内包することになる。
最悪な場合、
`bar.site.example^c ~serverは，
この~cookieと自身が設定した~cookieとを判別できなくなる。
`foo.site.example^c ~serverは、
この能を利用して `bar.site.example^c への攻撃を仕掛けるかもしれない。
◎
Cookies do not provide integrity guarantees for sibling domains (and their subdomains). For example, consider foo.site.example and bar.site.example. The foo.site.example server can set a cookie with a Domain attribute of "site.example" (possibly overwriting an existing "site.example" cookie set by bar.site.example), and the user agent will include that cookie in HTTP requests to bar.site.example. In the worst case, bar.site.example will be unable to distinguish this cookie from a cookie it set itself. The foo.site.example server might be able to leverage this ability to mount an attack against bar.site.example.
</p>

<p>
`Set-Cookie^h ~headerは `Path$ca 属性を~supportするが、
~UAは `Set-Cookie^h ~header内に任意な `Path$ca 属性を受容するので，
`Path$ca 属性は いかなる完全性の保護も供さない。
例えば，
`http://site.example/foo/bar^c
に向けた要請に対する~HTTP応答は、
`Path$ca 属性 `/qux^bl を伴う~cookieを設定できる。
したがって~serverは、［
同じ~hostの異なる~path上で，互いに信用し合っていない~serviceを同時に稼働しているとき
］は，~securityに敏感な情報を~cookieを利用して格納するベキでない。
◎
Even though the Set-Cookie header field supports the Path attribute, the Path attribute does not provide any integrity protection because the user agent will accept an arbitrary Path attribute in a Set-Cookie header field. For example, an HTTP response to a request for http://site.example/foo/bar can set a cookie with a Path attribute of "/qux". Consequently, servers SHOULD NOT both run mutually distrusting services on different paths of the same host and use cookies to store security-sensitive information.
</p>

<p>
能動的~network攻撃者は、
`http://site.example/^c
からの応答になりすまして `Set-Cookie^h ~headerを注入することにより，
`https://site.example/^c
に向けて送信される `Cookie^h ~headerに~cookieを注入できる。
`site.example^c
にある~HTTPS~serverは、
~HTTPS応答の中のこれらの~cookieと 自身が設定した~cookieとを判別できない。
`site.example^c が~HTTPSを排他的に利用していたとしても、
能動的~network攻撃者は，
この能を利用して `site.example^c への攻撃を仕掛けるかもしれない。
◎
An active network attacker can also inject cookies into the Cookie header field sent to https://site.example/ by impersonating a response from http://site.example/ and injecting a Set-Cookie header field. The HTTPS server at site.example will be unable to distinguish these cookies from cookies that it set itself in an HTTPS response. An active network attacker might be able to leverage this ability to mount an attack against site.example even if site.example uses HTTPS exclusively.
</p>

<p>
~serverは、
自身の~cookieを［
その内容を暗号化して署名するか，
`__Secure-$bl 接頭辞を伴うよう命名する
］ことにより，これらの攻撃を部分的に軽減できる。
しかしながら，［
攻撃者は、
自身が真正な `site.example^c ~serverから受信した~cookieを，
利用者の~sessionの中で再現できる
］ので、
暗号の利用は この課題を根本から払拭するものではなく，予測-不能な結果になる。
◎
Servers can partially mitigate these attacks by encrypting and signing the contents of their cookies, or by naming the cookie with the __Secure- prefix. However, using cryptography does not mitigate the issue completely because an attacker can replay a cookie he or she received from the authentic site.example server in the user's session, with unpredictable results.
</p>

<p>
最後に，攻撃者は、
多数の~cookieを格納させることにより，
~cookieを削除するよう~UAに強制するかもしれない。
~UAは，自身の保管~上限に達したとき、
何らかの~cookieを抹消するよう強制されることになる。
~serverは、
~UAが~cookieを維持することに依拠するベキでない。
◎
Finally, an attacker might be able to force the user agent to delete cookies by storing a large number of cookies. Once the user agent reaches its storage limit, the user agent will be forced to evict some cookies. Servers SHOULD NOT rely upon user agents retaining cookies.
</p>

		</section>
		<section id="reliance-on-dns">
<h3 title="Reliance on DNS">8.7. ~DNSへの依拠</h3>

<p>
~cookieの~securityは、
~DNS（ `Domain Name System^en ）に依拠する。
~DNSが部分的または全部的に弱体化された場合、
~cookie~protocolは，応用が要する~securityを供するのに失敗するであろう。
◎
Cookies rely upon the Domain Name System (DNS) for security. If the DNS is partially or fully compromised, the cookie protocol might fail to provide the security properties required by applications.
</p>

		</section>
		<section id="samesite-cookies">
<h3 title="SameSite Cookies">8.8. `SameSite^ca ~cookie</h3>

<p>
~cookieを配備するにあたって，
`SameSite$ca を厳密~mode（ `strict^l ）に設定した場合、
~clientが それを~supportするならば，`~CSRF攻撃$に抗する堅牢な防御を提供する。
しかしながら，それだけでは、
`~CSRF攻撃$に抗する~siteの防御~すべてを成すには至らない
— 同一-~siteな［
~navi／~form提出
］は、
他の攻撃~行路
— ~XSSなど —
を併用すれば，間違いなく実行できるので。
◎
SameSite cookies offer a robust defense against CSRF attack when deployed in strict mode, and when supported by the client. It is, however, prudent to ensure that this designation is not the extent of a site's defense against CSRF, as same-site navigations and submissions can certainly be executed in conjunction with other attack vectors such as cross-site scripting.
</p>

<p>
~riskをもっと全部的に軽減するため、
開発者には，通例の~server側~防御
（［
`安全$な~HTTP~methodは`冪等$になることを確保するための，~CSRF~token
］, 等々）
を配備することが強く奨励される。
◎
Developers are strongly encouraged to deploy the usual server-side defenses (CSRF tokens, ensuring that "safe" HTTP methods are idempotent, etc) to mitigate the risk more fully.
</p>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">9. ~IANA考慮点</h2>

		<section id="iana-cookie">
<h3>9.1. `Cookie^h</h3>

<p>
~HTTP~field名~registry `HttpFieldNameRegistry$r は、
以下の登録により更新される必要がある。
◎
The HTTP Field Name Registry (see [HttpFieldNameRegistry]) needs to be updated with the following registration:
</p>

<div>
<table><tbody>
<tr><th>~header名
<td>`Cookie^h
<tr><th>適用-可能な~protocol
<td>http
<tr><th>位置付け
<td>standard
<tr><th>著作者
<td>IETF
<tr><th>変更~制御者
<td>IETF
<tr><th>仕様~文書
<td>この仕様の`5.5.2＠#cookie§
</table>
◎
Header field name:
• Cookie
Applicable protocol:
• http
Status:
• standard
Author/Change controller:
• IETF
Specification document:
• this specification (Section 5.5.2)
</div>

		</section>
		<section id="iana-set-cookie">
<h3>9.2. `Set-Cookie^h</h3>

<p>
~HTTP~field名~registry `HttpFieldNameRegistry$r は、
以下の登録により更新される必要がある。
◎
The HTTP Field Name Registry (see [HttpFieldNameRegistry]) needs to be updated with the following registration:
</p>

<div>
<table><tbody>
<tr><th>~header名
<td>`Set-Cookie^h
<tr><th>位置付け
<td>standard
<tr><th>著作者
<td>IETF
<tr><th>変更~制御者
<td>IETF
<tr><th>仕様~文書
<td>この仕様の`5.5.1＠#set-cookie§
</table>
◎
Header field name:
• Set-Cookie
Applicable protocol:
• http
Status:
• standard
Author/Change controller:
• IETF
Specification document:
• this specification (Section 5.5.1)
</div>

		</section>
	</section>
	<section id="changes">
<h2 title="Changes">10. 変更点</h2>

<p>
［
~browserに課される より詳細な要件
］を下流の仕様において許容するため、
以前の~versionから【！the document】改造した。
◎
Revamped the document to allow for more detailed requirements on browsers in downstream specifications.
</p>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
現代の~cookie仕様 `RFC6265$r にて土台作業を~~敷かれた `Adam Barth^en 氏には、
特に感謝する。
◎
Many thanks to Adam Barth for laying the groundwork for a modern cookie specification with RFC 6265.
</p>

<p>
前述の作業の上に，後続な草案において改善された次に挙げる方々にも感謝する
⇒
`John Wilander, Lily Chen, Mike West, Steven Bingler, Steven Englehardt^en
◎
And thanks to John Wilander, Lily Chen, Mike West, Steven Bingler, and Steven Englehardt for improving upon that work in subsequent drafts.
</p>

	</section>
</main></div>
