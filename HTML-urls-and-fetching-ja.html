<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — URL／Fetching resources （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">
<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>


Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'I':
	break;
case 'm':
case 'sL': 
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text = key.replace(/_/, ':');
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'h':
	text = `\`<code class="header">${text}</code>\``;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'jI':
	text = `%${key}%`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2025-05-15
trans_update:2025-05-16
source_checked:241217
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/urls-and-fetching.html
	abbr_url:HTMLurl
nav_prev:HTMLcms
nav_next:HTMLcdom
trans_1st_pub:2016-01-28


●●class_map
e:element
a:attr
st:attr-state
et:event-type
sc:scheme
ps:pseudo
p:production
v:value
E:error
t:type
U:code-point
sl:js-slot

●●tag_map
I:code
m:code
sL:code
E:code
c:code
e:code
a:code
st:i
sc:code
et:code
v:code
p:code
ps:code
sl:span
V:var
t:var
i:i
U:span
cite:cite

●●original_id_map

	parse-a-url:resolve-a-url

●●mdn_urls
attr-nonce:HTML/Global_attributes/nonce

●●link_map

		●idl
I.HTMLOrSVGElement:~HTMLdom#htmlorsvgelement

I.IntersectionObserver:~INTERSECTIONOBSERVER#intersectionobserver
I.IntersectionObserverInit:~INTERSECTIONOBSERVER#dictdef-intersectionobserverinit
I.IntersectionObserverCallback:~INTERSECTIONOBSERVER#callbackdef-intersectionobservercallback
I.Window:~WINDOW#window

m.new IntersectionObserver:~INTERSECTIONOBSERVER#dom-intersectionobserver-intersectionobserver

m.src:~HEimages#dom-img-src
m.nonce:#dom-noncedelement-nonce

m.observe:~INTERSECTIONOBSERVER#dom-intersectionobserver-observe
m.unobserve:~INTERSECTIONOBSERVER#dom-intersectionobserver-unobserve
m.isIntersecting:~INTERSECTIONOBSERVER#dom-intersectionobserverentry-isintersecting
m.target:~INTERSECTIONOBSERVER#dom-intersectionobserverentry-target

		●element
e.del:~HEedits#the-del-element
e.ins:~HEedits#the-ins-element

e.base:~HEmetadata#the-base-element
e.blockquote:~HEgrouping#the-blockquote-element
e.meta:~HEmetadata#the-meta-element
e.q:~HEtextlevel#the-q-element
e.img:~HEimages#the-img-element
e.iframe:~HEembed#the-iframe-element

		●attr
a.href:~HTMLlinks#attr-hyperlink-href
a.~hrefM:~HEmetadata#attr-base-href
a.~nameM:~HEmetadata#attr-meta-name
a.ping:~HTMLlinks#ping
a.nonce:#attr-nonce

	●keywords, etc.

sc.about_:~HTMLdep#about-protocol
sc.about_blank:~HTMLdep#about:blank
sc.about_legacy-compat:#about:legacy-compat
sc.about_html-kind:#about:html-kind
sc.about_srcdoc:#about:srcdoc

st.匿名:#attr-crossorigin-anonymous
st.資格証を利用する:#attr-crossorigin-use-credentials
st.~CORSなし:#attr-crossorigin-none

st.Lazy:#attr-loading-lazy-state
st.Eager:#attr-loading-eager-state

st.高い:#attr-fetchpriority-high-state
st.低い:#attr-fetchpriority-low-state
st.自動:#attr-fetchpriority-auto-state

v.anonymous:#attr-crossorigin-anonymous-keyword
v.use-credentials:#attr-crossorigin-use-credentials-keyword
v.noreferrer:~HTMLlinks#link-type-noreferrer
v.referrer:~HEmetadata#meta-referrer

v.lazy:#attr-loading-lazy
v.eager:#attr-loading-eager

v.high:#attr-fetchpriority-high
v.low:#attr-fetchpriority-low
v.auto:#attr-fetchpriority-auto


h.Referrer-Policy:~REFERRER-POLICY#referrer-policy-header-dfn

ps.link:~HTMLselectors#selector-link
ps.visited:~HTMLselectors#selector-visited

sl.CryptographicNonce:#cryptographicnonce

l.render:#blocking-token-render

	●用語
~about_blank に合致して:#matches-about:blank
~about_srcdoc に合致して:#matches-about:srcdoc

~CORS設定群~属性の資格証~mode:#cors-settings-attribute-credentials-mode

~lazy読込ng属性:#lazy-loading-attribute
~lazy読込n~scroll~margin:#lazy-load-root-margin

~lazy読込n交差~観測器:#lazy-load-intersection-observer
~lazy読込n再開~手続き:#lazy-load-resumption-steps
~lazyに読込んでいる要素の交差~観測を開始する:#start-intersection-observing-a-lazy-loading-element
~lazyに読込んでいる要素の交差~観測を停止する:#stop-intersection-observing-a-lazy-loading-element
~lazyに読込むことになる:#will-lazy-load-element-steps

他を阻む属性:#blocking-attribute
アリな他を阻む~token:#possible-blocking-token
他を阻む~token集合:#blocking-tokens-set
具現化を阻む能性:#potentially-render-blocking
暗黙的に具現化を阻む能性:#implicitly-potentially-render-blocking

~fetch優先度~属性:#fetch-priority-attribute

	●HTML
文書:~HTMLdom#document
	I.Document:~HTMLdom#document
doc.~about基底~URL:~HTMLdom#concept-document-about-base-url
具現化を阻まなくする:~HTMLdom#unblock-rendering

文字~符号化法:~HTMLINFRA#encoding
基底~URL変更-手続き:~HTMLdep#base-url-change-steps
基底~URLの変化により影響される:~HTMLdep#affected-by-a-base-url-change

反映-:~HTMLcdom#reflect

列挙d属性:~HTMLcms#enumerated-attribute
欠落~値~用の既定の状態:~HTMLcms#missing-value-default
妥当でない値~用の既定の状態:~HTMLcms#invalid-value-default
~space等で分離された~token集合:~HTMLcms#set-of-space-separated-tokens

施策~容器:~ORIGIN#policy-container
pC.~CSP~list:~ORIGIN#policy-container-csp-list

閲覧~文脈に接続された:~HTMLINFRA#becomes-browsing-context-connected
閲覧~文脈から切断された:~HTMLINFRA#becomes-browsing-context-disconnected

enV.~API用~基底~URL:~WAPI#api-base-url
環境~設定群~obj:~WAPI#environment-settings-object
~scriptingは可能化されて:~WAPI#concept-n-script
	~WAPI#concept-n-noscript → ~NOT ~scriptingは可能化されて

DOCTYPE:~HTMLwriting#syntax-doctype

凍結d基底~URL:~HEmetadata#frozen-base-url
~hyperlink:~HTMLlinks#hyperlink
~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document

関連な大域~obj:~WAPI#concept-relevant-global
結付けられた文書:~WINDOW#concept-document-window

	●Encoding
~labelから符号化法を取得する:~ENCODING#concept-encoding-get
~UTF-8:~ENCODING#utf-8


	●Fetch
~fetch:~FETCH#concept-fetch
応答:~FETCH#concept-response
rs.種別:~FETCH#concept-response-type
rs.内部~応答:~FETCH#concept-internal-response
要請:~FETCH#concept-request
rq.~URL:~FETCH#concept-request-url
rq.行先:~FETCH#concept-request-destination
rq.~mode:~FETCH#concept-request-mode
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.~URL資格証を利用するか:~FETCH#concept-request-use-url-credentials-flag
	＊rq.~referrer:~FETCH#concept-request-referrer

	●DOM
doc.~URL:~DOM4#concept-document-url
doc.符号化法:~DOM4#concept-document-encoding
~tree順序:~DOM4#concept-tree-order
~node文書:~DOM4#concept-node-document
~HTML文書:~DOM4#html-document
~shadowも含めた根:~DOM4#concept-shadow-including-root
属性~値を設定する:~DOM4#concept-element-attributes-set-value
~clone時の手続き:~DOM4#concept-node-clone-ext
属性~変更-時の手続き:~DOM4#concept-element-attributes-change-ext
~supportする~token集合:~DOM4#concept-supported-tokens

	●INFRA
実装定義:~INFRA#implementation-defined

~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII空白:~INFRA#ascii-whitespace
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII空白を読飛ばす:~INFRA#skip-ascii-whitespace
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
位置~変数:~INFRA#string-position-variable
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points

	●URL / FETCH
~URL:~URL1#concept-url
~URL~record:~URL1#concept-url
url.~scheme:~URL1#concept-url-scheme
url.~path:~URL1#concept-url-path
url.~username:~URL1#concept-url-username
url.~password:~URL1#concept-url-password
url.~host:~URL1#concept-url-host
url.~query:~URL1#concept-url-query
url.素片:~URL1#concept-url-fragment

絶対~URL:~URL1#absolute-url-string
	＊:~URL1#syntax-url-absolute
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer
妥当な~URL文字列:~URL1#valid-url-string

妥当かつ空でない~URL:#valid-non-empty-url
前後~空白~可の妥当な~URL:#valid-url-potentially-surrounded-by-spaces
前後~空白~可の妥当かつ空でない~URL:#valid-non-empty-url-potentially-surrounded-by-spaces
~fallback基底~URL:#fallback-base-url
文書~基底~URL:#document-base-url
~URLを相対的に構文解析する:#parse-a-url
	相対的に~URL構文解析して直列化する:#parsing-and-serializing-a-url
~URLを符号化法の下で相対的に構文解析する:#encoding-parsing-a-url
~URLを符号化法の下で相対的に構文解析して直列化する:#encoding-parsing-and-serializing-a-url

~CORS同一-生成元:#cors-same-origin
~CORS非同一-生成元:#cors-cross-origin
安全でない応答:#unsafe-response

Content-Type ~metadata:#content-type
~CORSになり得る要請を作成する:#create-a-potential-cors-request
meta 要素から符号化法を抽出する:#algorithm-for-extracting-a-character-encoding-from-a-meta-element
~CORS設定群~属性:#cors-settings-attribute
~referrer施策~属性:#referrer-policy-attribute

rq.優先度:~FETCH#request-priority

	●他
~MIME型:~MIMESNIFF#mime-type
算出される~MIME型:~MIMESNIFF#computed-mime-type
画像を特定的に~sniffするための規則:~MIMESNIFF#rules-for-sniffing-images-specifically
資源は~textか~binaryかを判別する規則:~MIMESNIFF#rules-for-text-or-binary
音声や動画を特定的に~sniffするための規則:~MIMESNIFF#rules-for-sniffing-audio-and-video-specifically

疑似類:~SELECTORS4#pseudo-class
~referrer施策:~REFERRER-POLICY#referrer-policy

~headerにより送達された~CSPを包含している:~CSP3#contains-a-header-delivered-content-security-policy

内包して:~WEBIDL#include

●●words_table1

about_blank:about:blank
about_srcdoc:about:srcdoc

nameM:name
hrefM:href


●●words_table

	●network／fetch／URL／保安
sniff:
	potential-CORS
	CORS-cross-origin
	CORS-same-origin
	解決-不能:unresolvable
nonce::::ナンス
side-channel::::サイドチャネル
password::::パスワード
username::::ユーザ名
暗号用:cryptographic::~
不正転送:exfiltration::~
	〜に抗する:anti-

	●構文
backslash::::バックスラッシュ
読飛ばす:skipする:読み飛ばす
剥ぐ:stripする:~
	一重引用符

	●lazy
lazy:
増やす:increaseする:~
	精確にしない:imprecise
	遅い:slow
	より速く:faster 〜 speeds
	速さ:speed
	勢い:momentum
	待時間が長い:high-latency
	~scroll:scrolling

	●処理（一般
続行-:proceed:~
復旧-:restore:~
accessor::::アクセス子:アクセサ
	属性:attr:
翻訳:translation:~
再開:resumption::~
切断-:disconnect::~
優先度:priority::~

	他を阻む:blocking

生の:raw:~
	%再開~手続き:resumptionSteps
	走らす:execute
	初期化-:initialization
	%~URL:url
	%要素:el
	%生の~token群:rawTokens
	%符号化法:encoding
	%~label:-
	%環境:environment
	%基底~URL:baseURL
	-:urlRecord
	%~node:node
	%複製:copy
	-:subtree

	●仕様
寄与-:contribute:~
絶対要件:imperative:~
転用-:repurpose:~
指図-:direct:~
計略的:strategic:~
保護策:measure:~
近似的:approximate:~
強いら:forceさ:~
現代的:modern:~
品質:quality:~
能性:potential:~

	概略的:Brief
	無条件
	示-
	全体を通して:throughout
	しそう:likely
	課題:bug
	より旧い:older
	-:of course

	●未分類
about:
内包-:include::~
iframe:
track::::トラック
iframe-srcdoc:iframe srcdoc
種類:kind:~
給-:supply:~

	〜を包装する手続き:wrapper
	予約-済み:reserved
	列目:column
	分岐-
	含め
	従う
	与え
	対応-
	指して
	指す
	挙げる
	有する
	行う
	生じ
	省略時
	具体的
	匿名
	大別
	%局所~名:localName
	%文書:doc
	%旧~値
	%値
	%名前空間
	大部分:majority
	-:wherein
	属-
	通-:
	部分:
	前後
	最初
	最後
	一つ
	列目
	上
	他
	他の
	以下
	以外
	以降
	先ず
	先頭の
	内の
	可の
	各
	各種
	場合
	対し
	当の
	必要
	応じて
	時に
	更なる
	次
	法
	特に
	直後
	自身
	行
	該当
	低い:low
	高い:high
	〜は低い:low-
	〜は高い:high-

	-:away


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ URL, § Fetching resources</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTML — URL, 資源の fetch 法</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

		<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

◎表記記号

		</section>
		<section id="urls">
<h3 title="URLs">2.4. ~URL</h3>

			<section id="terminology-2">
<h4 title="Terminology">2.4.1. 各種用語</h4>

<p>
`妥当かつ空でない~URL@
とは、
空~文字列でない，`妥当な~URL文字列$である。
◎
A string is a valid non-empty URL if it is a valid URL string but it is not the empty string.
</p>

<p>
`前後~空白~可の妥当な~URL@
とは、
次の結果が`妥当な~URL文字列$になる %文字列 である
⇒
`前後の~ASCII空白~列を剥ぐ$( %文字列 )
◎
A string is a valid URL potentially surrounded by spaces if, after stripping leading and trailing ASCII whitespace from it, it is a valid URL string.
</p>

<p>
`前後~空白~可の妥当かつ空でない~URL@
とは、
次の結果が`妥当かつ空でない~URL$になる %文字列 である
⇒
`前後の~ASCII空白~列を剥ぐ$( %文字列 )
◎
A string is a valid non-empty URL potentially surrounded by spaces if, after stripping leading and trailing ASCII whitespace from it, it is a valid non-empty URL.
</p>

<p>
この仕様は、
予約-済みかつ解決-不能な `about_$sc ~URL `ABOUT$r として，
次に挙げる~URLを定義する：
◎
↓</p>

<dl class="def-list">
	<dt>
`about_legacy-compat@sc
◎
This specification defines the URL about:legacy-compat as a reserved, though unresolvable, about: URL,＼
</dt>
	<dd>
~XML~toolとの互換性に必要なとき，`~HTML文書$内の `DOCTYPE$ にて利用される。
◎
for use in DOCTYPEs in HTML documents when needed for compatibility with XML tools. [ABOUT]
</dd>

	<dt>
`about_html-kind@sc
◎
This specification defines the URL about:html-kind as a reserved, though unresolvable, about: URL,＼
</dt>
	<dd>
~media~trackの種類~用の識別子として利用される。
◎
that is used as an identifier for kinds of media tracks. [ABOUT]
</dd>

	<dt>
`about_srcdoc@sc
◎
This specification defines the URL about:srcdoc as a reserved, though unresolvable, about: URL,＼
</dt>
	<dd>
`~iframe-srcdoc文書$の`~URL$docとして利用される。
◎
that is used as the URL of iframe srcdoc documents. [ABOUT]
</dd>
</dl>

<p class="trans-note">【
これら（および `about_blank$sc ）は，
`~URL$をとり得る何かと直に（ “~EQ” で）比較されることもあるが、
その比較が何に基づくかは，明示的に定義されていない。
これらは，
“`URL$r に定義される`~URL$である”
とすら述べられていないが、［
`~URL$をとり得る何かと比較される／
上のように`~URL$として利用される
］以上，そう見なす必要があるので、
実際には［
当の `about_…^sc を文字列として`構文解析-＠~URL1#concept-url-parser$した結果の`~URL$
］であり，［
他との比較は，`同等な~URL＠~URL1#concept-url-equals$に基づく
］と解釈すべきに思われる。
】</p>

<div class="algo">
<p>
`文書$ %文書 の
`~fallback基底~URL@
は、
次を走らせて得される`~URL~record$である：
◎
The fallback base URL of a Document object document is the URL record obtained by running these steps:
</p>
<ol>
	<li>
%~about基底~URL ~LET %文書 の`~about基底~URL$doc
◎
↓</li>
	<li>
<p>
~IF［
%文書 は`~iframe-srcdoc文書$である
］：
◎
If document is an iframe srcdoc document, then:
</p>
		<ol>
			<li>
~Assert：
%~about基底~URL ~NEQ ~NULL
◎
Assert: document's about base URL is non-null.
</li>
			<li>
~RET %~about基底~URL
◎
Return document's about base URL.
</li>
		</ol>
	</li>
	<li>
~IF［
%文書 の`~URL$doc は`~about_blank に合致して$いる
］~AND［
%~about基底~URL ~NEQ ~NULL
］
⇒
~RET %文書 の`~about基底~URL$doc
◎
If document's URL matches about:blank and document's about base URL is non-null, then return document's about base URL.
</li>
	<li>
~RET %文書 の`~URL$doc
◎
Return document's URL.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書$ %文書 の
`文書~基底~URL@
は、
次を走らせて得される`~URL~record$である：
◎
The document base URL of a Document object is the URL record obtained by running these steps:
</p>
<ol>
	<li>
~IF［
%文書 内に `~hrefM$a 属性を有する `base$e 要素は在る
］
⇒
~RET それらのうち`~tree順序$で最初のものの`凍結d基底~URL$
◎
↓</li>
	<li>
~RET %文書 の`~fallback基底~URL$
◎
If there is no base element that has an href attribute in the Document, then return the Document's fallback base URL.
◎
Otherwise, return the frozen base URL of the first base element in the Document that has an href attribute, in tree order.
</li>
</ol>
</div>

<hr>

<div class="p">
<p>
`~URL$が
`~about_blank に合致して@
いるとは、
~AND↓ が満たされることをいう：
</p>
<ul>
	<li>
その`~scheme$url ~EQ `about^l
</li>
	<li>
その`~path$urlは 1 個の文字列 `blank^l のみからなる
</li>
	<li>
その`~username$url ~EQ 空~文字列
</li>
	<li>
その`~password$url ~EQ 空~文字列
</li>
	<li>
その`~host$url ~EQ ~NULL
</li>
</ul>
◎
A URL matches about:blank if its scheme is "about", its path contains a single string "blank", its username and password are the empty string, and its host is null.
</div>

<p class="note">注記：
そのような~URLの［
`~query$url ／ `素片$url
］は ~NULL でないこともある。
例えば、［
`about:blank?foo#bar^l を`~URL構文解析する$ことにより作成された`~URL~record$
］は，`~about_blank に合致して$いる。
◎
Such a URL's query and fragment can be non-null. For example, the URL record created by parsing "about:blank?foo#bar" matches about:blank.
</p>

<div class="p">
<p>
`~URL$が
`~about_srcdoc に合致して@
いるとは、
~AND↓ が満たされることをいう：
</p>
<ul>
	<li>
その`~scheme$url ~EQ `about^l
</li>
	<li>
その`~path$urlは 1 個の文字列 `srcdoc^l のみからなる
</li>
	<li>
その`~query$url ~EQ ~NULL
</li>
	<li>
その`~username$url ~EQ 空~文字列
</li>
	<li>
その`~password$url ~EQ 空~文字列
</li>
	<li>
その`~host$url ~EQ ~NULL
</li>
</ul>
◎
A URL matches about:srcdoc if its scheme is "about", its path contains a single string "srcdoc", its query is null, its username and password are the empty string, and its host is null.
</div>

<p class="note">注記：
`~about_srcdoc に合致して$いる`~URL$の`~query$urlが ~NULL になることを確保する理由は、
`~iframe-srcdoc文書$を［
その`~URL$docの`~query$url ~NEQ ~NULL
］を満たすように作成することはアリでないからである
— `~URL$docが`~about_blank に合致して$いる`文書$と違って。
言い換えれば、
`~about_srcdoc に合致して$いる どの`~URL$も，`素片$url以外の成分は同じになる。
◎
The reason that matches about:srcdoc ensures that the URL's query is null is because it is not possible to create an iframe srcdoc document whose URL has a non-null query, unlike Documents whose URL matches about:blank. In other words, the set of all URLs that match about:srcdoc only vary in their fragment.
</p>

			</section>
			<section id="resolving-urls">
<h4 title="Parsing URLs">2.4.2. ~URLの構文解析-法</h4>

<p>
~URLの構文解析は、
文字列をとり，それが表現する`~URL~record$を得する処理nである。
この処理nは `URL$r にて定義されているが、
この~HTML標準では，基底~URLと符号化法を抽象化して包装する手続きをいくつか定義する。
◎
Parsing a URL is the process of taking a string and obtaining the URL record that it represents. While this process is defined in URL, the HTML standard defines several wrappers to abstract base URLs and encodings. [URL]
</p>

<p class="note">注記：
ほとんどの新たな~APIは、
`~URLを相対的に構文解析する$を利用する。
より旧い~APIと~HTML要素は、
`~URLを符号化法の下で相対的に構文解析する$を利用する理由があるかもしれない。
もちろん，［
~customな基底~URLが必要なとき／基底~URLが欲されないとき
］も、
`~URL構文解析する$を直に利用できる。
◎
Most new APIs are to use parse a URL. Older APIs and HTML elements might have reason to use encoding-parse a URL. When a custom base URL is needed or no base URL is desired, the URL parser can of course be used directly as well.
</p>

<div class="algo">
<p>
`~URLを相対的に構文解析する@
~algoは、
所与の
( 文字列 %~URL, `文書$または`環境~設定群~obj$ %環境 )
に対し，［
`失敗^i ／`~URL$
］を返す：
◎
To parse a URL, given a string url, relative to a Document object or environment settings object environment, run these steps. They return failure or a URL.
</p>
<ol>
	<li>
%基底~URL ~LET %環境 に応じて
⇒＃
`文書$であるならば %環境 の`文書~基底~URL$／
%環境 の`~API用~基底~URL$enV
◎
Let baseURL be environment's base URL, if environment is a Document object; otherwise environment's API base URL.
</li>
	<li>
~RET `~URL構文解析する$( %~URL, %基底~URL )
◎
Return the result of applying the URL parser to url, with baseURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`~URLを符号化法の下で相対的に構文解析する@
~algoは、
所与の
( 文字列 %~URL, `文書$または`環境~設定群~obj$ %環境 )
に対し，［
`失敗^i ／`~URL$
］を返す：
◎
To encoding-parse a URL, given a string url, relative to a Document object or environment settings object environment, run these steps. They return failure or a URL.
</p>
<ol>
	<li>
%符号化法 ~LET `~UTF-8$
◎
Let encoding be UTF-8.
</li>
	<li>
~IF［
%環境 は`文書$である
］
⇒
%符号化法 ~SET %環境 の`符号化法$doc
◎
If environment is a Document object, then set encoding to environment's character encoding.
</li>
	<li>
~ELIF［
%環境 に`関連な大域~obj$ は `Window$I ~objである
］
⇒
%符号化法 ~SET %環境 に`関連な大域~obj$に`結付けられた文書$の`符号化法$doc
◎
Otherwise, if environment's relevant global object is a Window object, set encoding to environment's relevant global object's associated Document's character encoding.
</li>
	<li>
%基底~URL ~LET %環境 に応じて
⇒＃
`文書$であるならば %環境 の`文書~基底~URL$／
%環境 の`~API用~基底~URL$enV
◎
Let baseURL be environment's base URL, if environment is a Document object; otherwise environment's API base URL.
</li>
	<li>
~RET `~URL構文解析する$( %~URL, %基底~URL, %符号化法 )
◎
Return the result of applying the URL parser to url, with baseURL and encoding.
</li>
</ol>

<div>
<p class="trans-note">【
原文には，
この~algoの結果をさらに`直列化した結果＠~URL1#concept-url-serializer$を返す
`~URLを符号化法の下で相対的に構文解析して直列化する@
~algoも定義されているが、
この訳では利用しない
— 直列化した結果のみが利用される事例は，ごく少数に限られるので。
直列化が必要になる所では、
明示的に それを呼出すことにする。
】
</p>
◎
To encoding-parse-and-serialize a URL, given a string url, relative to a Document object or environment settings object environment, run these steps. They return failure or a string.
• Let url be the result of encoding-parsing a URL given url, relative to environment.
• If url is failure, then return failure.
• Return the result of applying the URL serializer to url.
</div>
</div>

			</section>
			<section id="dynamic-changes-to-base-urls">
<h4 title="Dynamic changes to base URLs">2.4.3. 基底~URLに対する動的な変化</h4>

<p>
`文書$ %文書 の`文書~基底~URL$が変化したとき、
%文書 内のすべての要素は，
%文書 の`基底~URLの変化により影響される$ `DOM$r。
◎
When a document's document base URL changes, all elements in that document are affected by a base URL change.
</p>

<div class="algo">
<p>
要素 %要素 が`基底~URLの変化により影響される$ときに走らす`基底~URL変更-手続き$ `DOM$r は、
次で与えられる：
◎
The following are base URL change steps, which run when an element is affected by a base URL change (as defined by DOM):
</p>

<dl class="switch">
	<dt>
%要素 は`~hyperlink$を作成するものである場合、
~UAは次に従うべきである：
◎
If the element creates a hyperlink
</dt>
	<dd>
<p>
当の~hyperlinkにより識別される`~URL$から導出される~dataは、
表示に影響している場合（~URLは利用者に示されているなど）
⇒
次の結果に基づいて，該当する~UIを適切に更新する
⇒
`~URLを符号化法の下で相対的に構文解析する$( 当の~hyperlinkの `href$a 属性の値, %要素 の`~node文書$ )
◎
If the URL identified by the hyperlink is being shown to the user, or if any data derived from that URL is affecting the display, then the href attribute's value should be reparsed, relative to the element's node document and the UI updated appropriately.
</p>

<p class="example">
例えば~CSS［
`link$ps ／ `visited$ps
］`疑似類$は、
影響され得る。
◎
For example, the CSS :link/:visited pseudo-classes might have been affected.
</p>

<p>
当の~hyperlinkは `ping$a 属性を有する場合
⇒
その値を成す
~EACH( %~token )
に対し
⇒
%~token が与える`~URL$は、
利用者に示されているならば
⇒
次の結果に基づいて，該当する~UIを適切に更新する
⇒
`~URLを符号化法の下で相対的に構文解析する$( %~token, %要素 の`~node文書$ )
◎
If the hyperlink has a ping attribute and its URL(s) are being shown to the user, then the ping attribute's tokens should be reparsed, relative to the element's node document and the UI updated appropriately.
</p>
	</dd>

	<dt>
［
%要素 は［
`q$e ／ `blockquote$e ／ `ins$e ／ `del$e
］要素である
］~AND［
%要素 は `cite^a 属性を有する
］場合、
~UAは次に従うべきである：
◎
If the element is a q, blockquote, ins, or del element with a cite attribute
</dt>
	<dd>
`cite^a 属性で識別される`~URL$から導出される~dataは、
表示に影響している場合
（~URLは利用者に示されているなど）
⇒
次の結果に基づいて，該当する~UIを適切に更新する
⇒
`~URLを符号化法の下で相対的に構文解析する$( `cite^a 属性の値, %要素 の`~node文書$ )
◎
If the URL identified by the cite attribute is being shown to the user, or if any data derived from that URL is affecting the display, then the cite attribute's value should be reparsed, relative to the element's node document and the UI updated appropriately.
</dd>

	<dt>
他の場合：
◎
Otherwise
</dt>
	<dd>
%要素 は直に影響されない。
◎
The element is not directly affected.
</dd>
	<dd class="example">
具体的には、
基底~URLを変更しても，
`img$e 要素により表示されている画像には影響しない
— ~scriptからの `src$m ~IDL属性に対する後続な~accessに対しては，
新たな`絶対~URL$が返されることになるが、
示されている画像には対応しなくなるであろう。
◎
For instance, changing the base URL doesn't affect the image displayed by img elements, although subsequent accesses of the src IDL attribute from script will return a new absolute URL that might no longer correspond to the image being shown.
</dd>
</dl>
</div>

			</section>
		</section>
		<section id="fetching-resources">
<h3 title="Fetching resources">2.5. 資源の~fetch法</h3>

			<section id="terminology-3">
<h4 title="Terminology">2.5.1. 各種用語</h4>

<div>
<p>
【`~network~error＠~FETCH#concept-network-error$以外の】
`応答$は、
次に挙げる 2 つに大別される
`FETCH$r ：
</p>
<ul>
	<li>
`~CORS同一-生成元@
⇒
`種別$rs ~IN { `basic^l, `cors^l, `default^l }
を満たすもの。
</li>
	<li>
`~CORS非同一-生成元@
⇒
`種別$rs ~IN { `opaque^l, `opaqueredirect^l }
を満たすもの。
</li>
</ul>
◎
A response whose type is "basic", "cors", or "default" is CORS-same-origin. [FETCH]
◎
A response whose type is "opaque" or "opaqueredirect" is CORS-cross-origin.
</div>

<p>
`応答$の
`安全でない応答@
は、
その`内部~応答$rsが［
在るならば それ ／
無いならば`応答$自身
］とする。
◎
A response's unsafe response is its internal response if it has one, and the response itself otherwise.
</p>

<div class="algo">
<p>
`~CORSになり得る要請を作成する@
~algoは、
所与の
⇒＃
%~URL,
%行先,
%~CORS属性~状態,
%同一-生成元~fallbackありか ~IN { `同一-生成元~fallbackあり^i, ε }（省略時は ε ）
◎終
に対し：
◎
To create a potential-CORS request, given a url, destination, corsAttributeState, and an optional same-origin fallback flag, run these steps:
</p>
<ol>
	<li>
%~mode ~LET ［
%~CORS属性~状態 ~EQ `~CORSなし$st ならば `no-cors^l ／
~ELSE_ `cors^l
］
◎
Let mode be "no-cors" if corsAttributeState is No CORS, and "cors" otherwise.
</li>
	<li>
~IF［
%同一-生成元~fallbackありか ~EQ `同一-生成元~fallbackあり^i
］~AND［
%~mode ~EQ `no-cors^l
］
⇒
%~mode ~SET `same-origin^l
◎
If same-origin fallback flag is set and mode is "no-cors", set mode to "same-origin".
</li>
	<li>
%資格証~mode ~LET `include^l
◎
Let credentialsMode be "include".
</li>
	<li>
~IF［
%~CORS属性~状態 ~EQ `匿名$st
］
⇒
%資格証~mode ~SET `same-origin^l
◎
If corsAttributeState is Anonymous, set credentialsMode to "same-origin".
</li>
	<li>
~RET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET %~URL,
`行先$rq ~SET %行先,
`~mode$rq ~SET %~mode,
`資格証~mode$rq ~SET %資格証~mode,
`~URL資格証を利用するか$rq ~SET ~T
◎
Return a new request whose URL is url, destination is destination, mode is mode, credentials mode is credentialsMode, and whose use-URL-credentials flag is set.
</li>
</ol>
</div>

			</section>
			<section id="content-type-sniffing">
<h4 title="Determining the type of a resource">2.5.2. 資源の型の決定-法</h4>

<p>
資源の
`Content-Type ~metadata@
は、
`MIMESNIFF$r による要件に整合な方式†で［
得する, 解釈する
］モノトスル。
【† おそらく，`給された~MIME型を検出する~algo＠~MIMESNIFF#supplied-mime-type-detection-algorithm$を指す。】
◎
The Content-Type metadata of a resource must be obtained and interpreted in a manner consistent with the requirements of MIME Sniffing. [MIMESNIFF]
</p>

<p id="computed-mime-type">
資源から`算出される~MIME型$は、
`MIMESNIFF$r による要件に整合な方式で見出すモノトスル。
◎
The computed MIME type of a resource must be found in a manner consistent with the requirements given in MIME Sniffing. [MIMESNIFF]
</p>

<div class="p">
<p>
次に挙げる規則も `MIMESNIFF$r にて定義される
— いずれも，ある`~MIME型$を返す：
</p>
<ul>
	<li id="content-type-sniffing:-image">
`画像を特定的に~sniffするための規則$
</li>
	<li id="content-type-sniffing:-text-or-binary">
`資源は~textか~binaryかを判別する規則$
</li>
	<li id="content-type-sniffing:-video">
`音声や動画を特定的に~sniffするための規則$
</li>
</ul>
◎
The rules for sniffing images specifically, the rules for distinguishing if a resource is text or binary, and the rules for sniffing audio and video specifically are also defined in MIME Sniffing. These rules return a MIME type as their result. [MIMESNIFF]
</div>

<p class="warning">
`MIMESNIFF$r による規則には、
正確に従うことが絶対要件である。
~UAが，内容~型の検出~用に［
~serverが期待するものとは異なる経験則
］を利用すると、
~securityの問題が生じ得る。
更なる詳細は、
その仕様を見よ。
◎
It is imperative that the rules in MIME Sniffing be followed exactly. When a user agent uses different heuristics for content type detection than the server expects, security problems can occur. For more details, see MIME Sniffing. [MIMESNIFF]
</p>

			</section>
			<section id="extracting-character-encodings-from-meta-elements">
<h4 title="Extracting character encodings from meta elements">2.5.3. `meta^e 要素から文字~符号化法を抽出する</h4>

<div class="algo">
<p>
`meta 要素から符号化法を抽出する@
~algoは、
所与の
( 文字列 %入力 )
に対し，［
`文字~符号化法$／ ε（ “無い” ）
］を返す：
◎
The algorithm for extracting a character encoding from a meta element, given a string s, is as follows. It returns either a character encoding or nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let position be a pointer into s, initially pointing at the start of the string.
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
~IF［
%入力 の %位置 以降の部分に`~ASCII大小無視$で `charset^l に合致する文字列がある
］
⇒
%位置 ~SET 該当する文字列のうち，最初のものの直後を指す位置
</li>
			<li>
~ELSE
⇒
~RET ε
</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
</li>
			<li>
~IF［
%位置↗ ~EQ `003D^U `=^smb
］
⇒
~BREAK
</li>
		</ol>
◎
Loop: Find the first seven characters in s after position that are an ASCII case-insensitive match for the word "charset". If no such match is found, return nothing.
◎
Skip any ASCII whitespace that immediately follow the word "charset" (there might not be any).
◎
If the next character is not a U+003D EQUALS SIGN (=), then move position to point just before that next character, and jump back to the step labeled loop.
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip any ASCII whitespace that immediately follow the equals sign (there might not be any).
</li>
	<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET ε
◎
↓</li>
	<li>
%~label ~LET ε
◎
↓</li>
	<li>
<p>
~IF［
%位置↗ ~IN { `0022^U `"^smb, `0027^U `'^smb }
］：
</p>
		<ol>
			<li>
%引用符 ~LET %位置↗
</li>
			<li>
%位置 ~INCBY 1
</li>
			<li>
%~label ~SET
%入力 内の %位置 から
%引用符 以外の`符号位置~並びを収集する$
</li>
			<li>
~IF［
%位置↗ ~NEQ %引用符
］
⇒
~RET ε
</li>
		</ol>
◎
Process the next character as follows:
• If it is a U+0022 QUOTATION MARK character (") and there is a later U+0022 QUOTATION MARK character (") in s
• If it is a U+0027 APOSTROPHE character (') and there is a later U+0027 APOSTROPHE character (') in s
•• Return the result of getting an encoding from the substring that is between this character and the next earliest occurrence of this character.
• If it is an unmatched U+0022 QUOTATION MARK character (")
• If it is an unmatched U+0027 APOSTROPHE character (')
• If there is no next character
•• Return nothing.
</li>
	<li>
~ELSE
⇒
%~label ~SET 
%入力 内の %位置 から
{ `~ASCII空白$, `003B^U `;^smb }
以外の`符号位置~並びを収集する$
◎
• Otherwise
•• Return the result of getting an encoding from the substring that consists of this character up to but not including the first ASCII whitespace or U+003B SEMICOLON character (;), or the end of s, whichever comes first.
</li>
	<li>
%符号化法 ~LET `~labelから符号化法を取得する$( %~label )
◎
↑</li>
	<li>
~IF［
%符号化法 ~EQ `失敗^i
］
⇒
~RET ε
◎
↑</li>
	<li>
~RET %符号化法
◎
↑</li>
</ol>

<p class="note">
この~algoは、
~HTTP仕様のものとは別個な形をとる
（例えば，~HTTPでは、
一重引用符 `0027^U `'^smb の利用は許容されないことに加え、［
この~algoが~supportしない，~backslashによる~escapeの仕組み
］を~supportすることが要求されている）。
この~algoは，歴史的に~HTTPに関係する文脈で利用されていたが、
実装により~supportされる構文は，あるときから分岐した。
`HTTP$r
◎
This algorithm is distinct from those in the HTTP specifications (for example, HTTP doesn't allow the use of single quotes and requires supporting a backslash-escape mechanism that is not supported by this algorithm). While the algorithm is used in contexts that, historically, were related to HTTP, the syntax as supported by implementations diverged some time ago. [HTTP]
</p>
</div>

			</section>
			<section id="cors-settings-attributes">
<h4 title="CORS settings attributes">2.5.4. ~CORS設定群~属性</h4>

<p>
内容~属性には、
`~CORS設定群~属性@
（ `CORS settings attribute^en ）
であると定義されるものもある。
【通例的に， `crossorigin^a と命名される。】
それは，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
A CORS settings attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態
<th>概略的な記述
<tbody>

<tr><td>
`anonymous@v
<td rowspan="2">
`匿名@st
<td rowspan="2">
当の要素による`要請$の［
`~mode$rqを `cors^l ／
`資格証~mode$rqを `same-origin^l
］に設定する。

<tr><td>空~文字列

<tr><td>
`use-credentials@v
<td>
`資格証を利用する@st
<td>
当の要素による`要請$の［
`~mode$rqを `cors^l ／
`資格証~mode$rqを `include^l
］に設定する。

<tr><td>（なし）
<td>
`~CORSなし@st
<td class="trans-note">【
当の要素による`要請$の［
`~mode$rqを概して `no-cors^l （一部の事例では `same-origin^l ）／
`資格証~mode$rqを `include^l
］に設定する。
】
</table>

◎
Keyword｜State｜Brief description
◎
anonymous｜Anonymous｜Requests for the element will have their mode set to "cors" and their credentials mode set to "same-origin".
(the empty string)｜↑｜↑
use-credentials｜Use Credentials｜Requests for the element will have their mode set to "cors" and their credentials mode set to "include".
</div>

<p>
`~CORS設定群~属性$の
⇒＃
`欠落~値~用の既定の状態$は `~CORSなし$st とする。
`妥当でない値~用の既定の状態$は `匿名$st とする。
◎
The attribute's missing value default is the No CORS state, and its invalid value default is the Anonymous state.
</p>

<p>
~fetchにおいて`~CORS設定群~属性$が統治する大部分は、
`~CORSになり得る要請を作成する$~algoを介して行われることになる。
◎
The majority of fetches governed by CORS settings attributes will be done via the create a potential-CORS request algorithm.
</p>

<p>
より現代的な［
`要請$の`~mode$rqは常に `cors^l になる特能
］用には、
ある種の`~CORS設定群~属性$は，［
少し異なる意味に転用され、
`要請$の`資格証~mode$rqに限り，影響iする
］ようになる。
この翻訳を遂行するため、
所与の`~CORS設定群~属性$に対し，
`~CORS設定群~属性の資格証~mode@
が定義される
— それは、
当の属性の状態に応じて，次に与える値に決定される
⇒＃
`~CORSなし$st ならば `same-origin^l ／
`匿名$st ならば `same-origin^l ／
`資格証を利用する$st ならば `include^l
◎
For more modern features, where the request's mode is always "cors", certain CORS settings attributes have been repurposed to have a slightly different meaning, wherein they only impact the request's credentials mode. To perform this translation, we define the CORS settings attribute credentials mode for a given CORS settings attribute to be determined by switching on the attribute's state:
◎
No CORS
Anonymous
• "same-origin"
Use Credentials
• "include"
</p>

			</section>
			<section id="referrer-policy-attributes">
<h4 title="Referrer policy attributes">2.5.5. ~referrer施策~属性</h4>

<p>
内容~属性には、
`~referrer施策~属性@
（ `referrer policy attribute^en ）
であると定義されるものもある。
【通例的に， `referrerpolicy^a と命名される。】
それは、
`列挙d属性$である。
この属性~用に定義される~keywordは、
`~referrer施策$であり，空~文字列も含む。
各~keywordは、
同じ名前の状態に対応付けられる。
◎
A referrer policy attribute is an enumerated attribute. Each referrer policy, including the empty string, is a keyword for this attribute, mapping to a state of the same name.
</p>

<p>
`~referrer施策~属性$の［
`欠落~値~用の既定の状態$, `妥当でない値~用の既定の状態$
］は、
いずれも 空~文字列 とする。
◎
The attribute's missing value default and invalid value default are both the empty string state.
</p>

<p>
これらの状態による各種`~fetch$の処理~modelへの影響iについては、
この仕様を通して, および［
`FETCH$r,
`REFERRERPOLICY$r
］にて，より詳細に定義される。
◎
The impact of these states on the processing model of various fetches is defined in more detail throughout this specification, in Fetch, and in Referrer Policy. [FETCH] [REFERRERPOLICY]
</p>

<div class="note">
<p>注記：
［
所与の`~fetch$がどの処理~modelを利用するか
］に寄与し得る通達には，いくつかあり、
`~referrer施策~属性$は，その一つである。
一般に、
これらの通達は，次の順序で処理される：
◎
Several signals can contribute to which processing model is used for a given fetch; a referrer policy attribute is only one of them. In general, the order in which these signals are processed are:
</p>
<ol>
	<li>
最初に、
~link型 `noreferrer$v の有無。
◎
First, the presence of a noreferrer link type;
</li>
	<li>
`~referrer施策~属性$の値。
◎
Then, the value of a referrer policy attribute;
</li>
	<li>
`~nameM$a 属性が `referrer$v に設定された `meta$e 要素の有無。
◎
Then, the presence of any meta element with name attribute set to referrer.
</li>
	<li>
最後に、
`Referrer-Policy$h ~header。
◎
Finally, the `Referrer-Policy` HTTP header.
</li>
</ol>
</div>

			</section>
			<section id="nonce-attributes">
<h4 title="Nonce attributes">2.5.6. `nonce^a 属性</h4>

<p>
`nonce@a
内容~属性は、
暗号用~nonce （ `cryptographic nonce^en ）を表現する。
それは、
`CSP$r により利用され，［
所与の~fetchを続行することを許容する
］か否かを決定する。
値は~textである†。
◎
A nonce content attribute represents a cryptographic nonce ("number used once") which can be used by Content Security Policy to determine whether or not a given fetch will be allowed to proceed. The value is text. [CSP]
</p>

<p class="trans-note">【†
`nonce^en は `number used once^en （ “使い捨ての番号” ）の略語であるが、
値は数を表現するものではない（単なる文字列である）。
】</p>

<p>
要素 %要素 が `nonce$a 内容~属性 %属性 を有するとき、
その暗号用~nonceは，~script以外には公開されない
（`~CSS属性~選択子＠~SELECTORS4#attribute-selectors$の様な~side-channelには公開されない）
ことが確保される
— %属性 の値を %要素 の
`CryptographicNonce@sl
内部~slotへ移動して，
それを `HTMLOrSVGElement$I ~interface~mixinを介して~scriptに公開して，
%属性 を空~文字列に設定することにより。
この~slotの値は、
他が指定されない限り，空~文字列になるとする。
◎
Elements that have a nonce content attribute ensure that the cryptographic nonce is only exposed to script (and not to side-channels like CSS attribute selectors) by taking the value from the content attribute, moving it into an internal slot named [[CryptographicNonce]], exposing it to script via the HTMLOrSVGElement interface mixin, and setting the content attribute to the empty string. Unless otherwise specified, the slot's value is the empty string.
</p>

<dl class="domintro">
	<dt>%element.`nonce$m</dt>
	<dd>
要素の暗号用~nonce用に設定された値を返す。
設定子を利用しなかった場合、
これは， `nonce$a 内容~属性にて元々見出された値を返すことになる。
◎
Returns the value set for element's cryptographic nonce. If the setter was not used, this will be the value originally found in the nonce content attribute.
</dd>

	<dt>%element.`nonce$m = %value</dt>
	<dd>
要素の暗号用~nonce値を更新する。
◎
Updates element's cryptographic nonce value.
</dd>
</dl>

<div class="algo">
`nonce@m
取得子~手続きは
⇒
~RET コレ . `CryptographicNonce$sl
◎
The nonce IDL attribute must, on getting, return the value of this element's [[CryptographicNonce]];＼
</div>

<div class="algo">
<p>
`nonce$m 設定子~手続きは
⇒
コレ . `CryptographicNonce$sl ~SET 所与の値
◎
and on setting, set this element's [[CryptographicNonce]] to the given value.
</p>

<p id="nonce-does-not-update-dom" class="note">注記：
`nonce$m 設定子は、
対応する内容~属性を更新しないことに注意。
このこと, および［
要素が`閲覧~文脈に接続された$とき，
`nonce$a 内容~属性を空~文字列に設定すること
］（下に述べる）は、［
内容~属性を容易に読取れる仕組み（選択子など）による，~nonce値の不正転送
］を防止することが意味されている。
この挙動が導入された~~経緯は、
`課題 #2369＠~HTMLissue/2369$
にて学べる。
◎
Note how the setter for the nonce IDL attribute does not update the corresponding content attribute. This, as well as the below setting of the nonce content attribute to the empty string when an element becomes browsing-context connected, is meant to prevent exfiltration of the nonce value through mechanisms that can easily read content attributes, such as selectors. Learn more in issue #2369, where this behavior was introduced.
</p>
</div>

<div class="algo">
<p>
%要素 上の `nonce$a 内容~属性~用に利用される
`属性~変更-時の手続き$は、所与の
( %局所~名, %旧~値, %値, %名前空間 )
に対し：
◎
The following attribute change steps are used for the nonce content attribute:
</p>
<ol>
	<li>
~IF［
%要素 は `HTMLOrSVGElement$I を`内包して$いない
］
⇒
~RET
◎
If element does not include HTMLOrSVGElement, then return.
</li>
	<li>
~IF［
%局所~名 ~NEQ `nonce^l
］~OR［
%名前空間 ~NEQ ~NULL
］
⇒
~RET
◎
If localName is not nonce or namespace is not null, then return.
</li>
	<li>
%要素 . `CryptographicNonce$sl ~SET %値 に応じて
⇒＃
~NULL ならば 空~文字列 ／
~ELSE_ %値
◎
If value is null, then set element's [[CryptographicNonce]] to the empty string.
◎
Otherwise, set element's [[CryptographicNonce]] to value.
</li>
</ol>
</div>

<div class="algo">
<p>
`HTMLOrSVGElement$I を`内包して$いる %要素 が`閲覧~文脈に接続された$ときは、
次を走らすモノトスル：
◎
Whenever an element including HTMLOrSVGElement becomes browsing-context connected, the user agent must execute the following steps on the element:
</p>
<ol>
	<li>
%~CSP~list ~LET %要素 の`~shadowも含めた根$の`施策~容器$の`~CSP~list$pC
◎
Let CSP list be element's shadow-including root's policy container's CSP list.
</li>
	<li>
<p>
~IF［
%~CSP~list は`~headerにより送達された~CSPを包含している$
］~AND［
%要素 は `nonce$a 内容~属性を有していて，その値 ~NEQ 空~文字列
］：
◎
If CSP list contains a header-delivered Content Security Policy, and element has a nonce content attribute whose value is not the empty string, then:
</p>
		<ol>
			<li>
%nonce ~LET %要素 . `CryptographicNonce$sl
◎
Let nonce be element's [[CryptographicNonce]].
</li>
			<li>
%要素 の`属性~値を設定する$( `nonce^l, 空~文字列 )
◎
Set an attribute value for element using "nonce" and the empty string.
</li>
			<li>
%要素 . `CryptographicNonce$sl ~SET %nonce
◎
Set element's [[CryptographicNonce]] to nonce.
</li>
		</ol>

<p class="note">注記：
%要素 . `CryptographicNonce^sl は、
復旧しないと空~文字列になる。
◎
If element's [[CryptographicNonce]] were not restored it would be the empty string at this point.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`HTMLOrSVGElement$I を`内包して$いる要素~用の`~clone時の手続き$は、
所与の
( %~node, %複製, … )
に対し
⇒
%複製 . `CryptographicNonce$sl ~SET %~node . `CryptographicNonce$sl
◎
The cloning steps for elements that include HTMLOrSVGElement given node, copy, and subtree are to set copy's [[CryptographicNonce]] to node's [[CryptographicNonce]].
</p>
</div>

			</section>
			<section id="lazy-loading-attributes">
<h4 title="Lazy loading attributes">2.5.7. ~lazy読込ng属性</h4>

<p>
内容~属性には、
`~lazy読込ng属性@
（ `lazy loading attribute^en
【 “読込ngを後回しにする” 】 ）
であると定義されるものもある。
【通例的に， `loading^a と命名される。】
それは，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
A lazy loading attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態
<tbody>

<tr><td>`lazy@v
<td>`Lazy$st

<tr><td>`eager@v
<td>`Eager$st
</table>

<p>
上に挙げた各~状態は、
次を~UAに指図する：
</p>
<ul>
	<li>
`Lazy@st
（後回し）
⇒
当の要素に結付けられた何らかの条件が満たされるまで、
資源の~fetchingを先送りする。
</li>
	<li>
`Eager@st
（早急）
⇒
資源を即時に~fetchする。
</li>
</ul>

◎
Keyword｜State｜Brief description
lazy｜Lazy｜Used to defer fetching a resource until some conditions are met.
eager｜Eager｜Used to fetch a resource immediately; the default state.
◎
The attribute directs the user agent to fetch a resource immediately or to defer fetching until some conditions associated with the element are met, according to the attribute's current state.
</div>

<p>
`~lazy読込ng属性$の［
`欠落~値~用の既定の状態$, `妥当でない値~用の既定の状態$
］は、
いずれも `Eager$st とする。
◎
The attribute's missing value default and invalid value default are both the Eager state.
</p>

<hr>

<div class="algo">
<p>
`~lazyに読込むことになる@
か否かは、
所与の
( 要素 %要素 )
に対し
⇒
~RET ~IS［
~AND↓
］：
</p>
<ul>
	<li>
<p>
%要素 用の`~scriptingは可能化されて$いる
</p>

<p class="note">注記：
これは、
追跡に抗する保護策である
— ~UAの~scriptingが不能化されている下で~lazy読込ngを~supportした場合、
~pageの~markup内に画像を計略的に配置すれば，
~serverはそれらの画像がいつ, どれだけ要請されたか追跡でき、
~session全体を通して利用者の~scroll位置を近似的に追跡することが，
~siteにとって依然としてアリになるので。
</p>
	</li>
	<li>
%要素 の`~lazy読込ng属性$は `Lazy$st 状態にある
</li>
</ul>
◎
The will lazy load element steps, given an element element, are as follows:
• If scripting is disabled for element, then return false.
• This is an anti-tracking measure, because if a user agent supported lazy loading when scripting is disabled, it would still be possible for a site to track a user's approximate scroll position throughout a session, by strategically placing images in a page's markup such that a server can track how many images are requested and when.
• If element's lazy loading attribute is in the Lazy state, then return true.
• Return false.
</div>

<p>
各［
`img$e ／ `iframe$e
］要素には、
`~lazy読込n再開~手続き@
が結付けられ，初期~時は ~NULL になるとする。
◎
Each img and iframe element has associated lazy load resumption steps, initially null.
</p>

<p class="note">注記：
この手続きは、［
それらの要素のうち，`~lazyに読込むことになる$もの
］用にあり，［
`~lazy読込n交差~観測器$の~callback内から／
要素の`~lazy読込ng属性$が `Eager$st 状態に変化した【！設定された】とき
］走らすことになる。
これは、
当の要素の読込ngを継続させる。
◎
For img and iframe elements that will lazy load, these steps are run from the lazy load intersection observer's callback or when their lazy loading attribute is set to the Eager state. This causes the element to continue loading.
</p>

<p>
各`文書$は、
`~lazy読込n交差~観測器@
を有する
— それは、
初期~時は ~NULL になるとするが，
後で `IntersectionObserver$I ~instanceに設定され得る。
◎
Each Document has a lazy load intersection observer, initially set to null but can be set to an IntersectionObserver instance.
</p>

<div class="algo">
<p>
`~lazyに読込んでいる要素の交差~観測を開始する@
~algoは、
所与の
( %要素 )
に対し：
◎
To start intersection-observing a lazy loading element element, run these steps:
</p>
<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let doc be element's node document.
</li>
	<li>
<p>
~IF［
%文書 の`~lazy読込n交差~観測器$ ~EQ ~NULL
］：
◎
If doc's lazy load intersection observer is null,＼
</p>
		<ol>
			<li>
%文書 の`~lazy読込n交差~観測器$ ~SET 新たな `IntersectionObserver$I ~obj
◎
set it to a new IntersectionObserver instance, initialized as follows:
</li>
			<li>
<p>
%文書 の`~lazy読込n交差~観測器$上で
`new IntersectionObserver$m 構築子~手続き( %callback, %options )
を遂行する※【下を見よ（以下同様）】
— ここで：
◎
The intention is to use the original value of the IntersectionObserver constructor. However, we're forced to use the JavaScript-exposed constructor in this specification, until Intersection Observer exposes low-level hooks for use in specifications. See bug w3c/IntersectionObserver#464 which tracks this. [INTERSECTIONOBSERVER]
</p>
				<ul>
					<li class="algo">
<p>
`IntersectionObserverCallback$I ~callback %callback は、
引数
( %~entry~list, %観測器 )
に対し，次の手続きを走らす：
◎
The callback is these steps, with arguments entries and observer:
</p>
						<ol>
							<li>
<p>
%~entry~list 内の
~EACH( %~entry )
に対し
<span class="XXX">，開発者が改変-可能な［
配列~accessorや反復~hook
］は誘発しない反復~手法を利用して</span>：
</p>
								<ol>
									<li>
~IF［
%~entry 上の `isIntersecting$m 取得子~手続き()※ ~EQ ~F
］
⇒
~CONTINUE
</li>
									<li>
%~target ~LET %~entry 上の `target$m 取得子~手続き()※
</li>
									<li>
%再開~手続き ~LET %~target の`~lazy読込n再開~手続き$
</li>
									<li>
~IF［
%再開~手続き ~EQ ~NULL
］
⇒
~RET
</li>
									<li>
`~lazyに読込んでいる要素の交差~観測を停止する$( %~target )
</li>
									<li>
%~target の`~lazy読込n再開~手続き$ ~SET ~NULL
</li>
									<li>
%再開~手続き を呼出す
</li>
								</ol>
◎
For each entry in entries using a method of iteration which does not trigger developer-modifiable array accessors or iteration hooks:
• Let resumptionSteps be null.
• If entry.isIntersecting is true, then set resumptionSteps to entry.target's lazy load resumption steps.
• If resumptionSteps is null, then return.
• Stop intersection-observing a lazy loading element for entry.target.
• Set entry.target's lazy load resumption steps to null.
• Invoke resumptionSteps.
◎
The intention is to use the original value of the isIntersecting and target getters. See w3c/IntersectionObserver#464. [INTERSECTIONOBSERVER]
</li>
						</ol>
					</li>
					<li>
<p>
`IntersectionObserverInit$I 辞書 %options は、
次の~memberを伴う
⇒
«[ "`scrollMargin^c" → `~lazy読込n~scroll~margin$ ]»
◎
The options is an IntersectionObserverInit dictionary with the following dictionary members: «[ "scrollMargin" → lazy load scroll margin ]»
</p>

<p class="note">注記：
これは、［
画像が まだ表示域に交差していなくても，~scrollしている間に そうなりつつある
］とき，画像を~fetchすることを許容する。
◎
This allows for fetching the image during scrolling, when it does not yet — but is about to — intersect the viewport.
</p>

<p class="XXX">
`~lazy読込n~scroll~margin$用の示唆は，値に対する動的な変更を含意するが、
`IntersectionObserver$I ~APIは，~scroll~marginの変更-法を~supportしていない。
`w3c/IntersectionObserver 課題 #428＠https://github.com/w3c/IntersectionObserver/issues/428$
を見よ。
◎
The lazy load scroll margin suggestions imply dynamic changes to the value, but the IntersectionObserver API does not support changing the scroll margin. See issue w3c/IntersectionObserver#428.
</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
<p>
%文書 の`~lazy読込n交差~観測器$ の`observe$m ~method手続き( %要素 )※
◎
Call doc's lazy load intersection observer's observe method with element as the argument.
◎
The intention is to use the original value of the observe method. See w3c/IntersectionObserver#464. [INTERSECTIONOBSERVER]
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~lazyに読込んでいる要素の交差~観測を停止する@
~algoは、
所与の
( %要素 )
に対し：
◎
To stop intersection-observing a lazy loading element element, run these steps:
</p>
<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let doc be element's node document.
</li>
	<li>
~Assert：
%文書 の`~lazy読込n交差~観測器$ ~NEQ ~NULL
◎
Assert: doc's lazy load intersection observer is not null.
</li>
	<li>
%文書 の`~lazy読込n交差~観測器$の `unobserve$m ~method手続き( %要素 )※
◎
Call doc's lazy load intersection observer's unobserve method with element as the argument.
◎
The intention is to use the original value of the unobserve method. See w3c/IntersectionObserver#464. [INTERSECTIONOBSERVER]
</li>
</ol>
</div>

<p class="XXX">※
`INTERSECTIONOBSERVER$r に定義される これらの~interface~member
（ `new IntersectionObserver()$m 構築子, 等々）には、
それぞれの元の【~JSにより改変されていない】値を利用して~accessすることが意図nにある
【そのように解釈されるよう、この訳では “構築子~手続き” 等々を利用しているが】
。
しかしながら，その仕様が他の仕様における利用-用に低~levelな~hookを公開するまでは、
この仕様は，~JSに公開される それらを利用するよう強いられる。
これを追跡している
`w3c/IntersectionObserver 課題 #464＠https://github.com/w3c/IntersectionObserver/issues/464$
を見よ。
◎
↑↑</p>

<p>
◎追跡路
`~lazy読込n~scroll~margin@
は、
`実装定義$な値であるが，次に挙げる示唆を考慮するとする：
◎
(This is a tracking vector.)
The lazy load scroll margin is an implementation-defined value, but with the following suggestions to consider:
</p>
<ul>
	<li>
次を満たす最小な値に設定する
⇒
所与の機器~用の通常の用法~patternの下で、［
対象が表示域に交差するより前に，その資源は読込n済みになる
］ことが最も多くなる。
◎
Set a minimum value that most often results in the resources being loaded before they intersect the viewport under normal usage patterns for the given device.
</li>
	<li>
［
概して，他より速く~scrollする機器
］用には、
値を増やす。
◎
The typical scrolling speed: increase the value for devices with faster typical scrolling speeds.
</li>
	<li>
現在~scrollしている速さや勢い
⇒
~UAは、
~scrollが停止しそうになる所を予測しようと試みて，
それに則って値を調整できる。
◎
The current scrolling speed or momentum: the UA can attempt to predict where the scrolling will likely stop, and adjust the value accordingly.
</li>
	<li>
~network品質
⇒
接続が遅いか, その待時間が長い場合には、
値を増やす。
◎
The network quality: increase the value for slow or high-latency connections.
</li>
	<li>
利用者-選好は、
値に波及し得る。
◎
User preferences can influence the value.
</li>
</ul>

<p class="note">
`~privacy用＠~INFRA#tracking-vector$には、［
`~lazy読込n~scroll~margin$は，追加的な情報を漏洩しない
］ことが重要である。
例えば、［
現在の機器~上で~scrollする代表的な速さ
］を［
新たな指紋収集~行路を導入しないよう，精確にしない
］こともできる。
◎
It is important for privacy that the lazy load scroll margin not leak additional information. For example, the typical scrolling speed on the current device could be imprecise so as to not introduce a new fingerprinting vector.
</p>

			</section>
			<section id="blocking-attributes">
<h4 title="Blocking attributes">2.5.8. 他を阻む属性</h4>

<p>
内容~属性には、
`他を阻む属性@
（ `blocking attribute^en ）
であると定義されるものもある。
【通例的に， `blocking^a と命名される。】
それは、［
外部~資源の~fetchingに際して，ある種の演算は阻まれるべきである
］ことを明示的に指示する。
阻まれ得る演算は、
各種
`アリな他を阻む~token@
（ `possible blocking tokens^en ）で表現される
— それらは、
次の表tに挙げる文字列である：
◎
A blocking attribute explicitly indicates that certain operations should be blocked on the fetching of an external resource. The operations that can be blocked are represented by possible blocking tokens, which are strings listed by the following table:
</p>

<div>
<table><thead>
<tr><th>アリな他を阻む~token
<th>記述
<tbody>

<tr><td>`render@l
<td>要素には`具現化を阻む能性$がある。
</table>

◎
Possible blocking token｜Description
"render"｜The element is potentially render-blocking.
</div>

<p id="future-blocking-tokens" class="note">注記：
`アリな他を阻む~token$は、
将来には，もっと~~増やされ得る。
◎
In the future, there might be more possible blocking tokens.
</p>

<p>
`他を阻む属性$の値は、
`~space等で分離された~token集合$（一意）であって，
それを成す各~tokenは`アリな他を阻む~token$でなければナラナイ。
`他を阻む属性$が`~supportする~token集合$は、
すべての`アリな他を阻む~token$からなる。
どの要素も，それが有し得る`他を阻む属性$は 1 個までになる†。
◎
A blocking attribute must have a value that is an unordered set of unique space-separated tokens, each of which are possible blocking tokens. The supported tokens of a blocking attribute are the possible blocking tokens. Any element can have at most one blocking attribute.
</p>

<p class="trans-note">【†
所与の要素~型に対し，複数の`他を阻む属性$が定義されることはない。
】</p>

<div class="algo">
<p>
所与の要素 %要素 用の
`他を阻む~token集合@
（ `blocking tokens set^en ）
は、
次の手続きの結果になる：
◎
The blocking tokens set for an element el are the result of the following steps:
</p>
<ol>
	<li>
%値 ~LET %要素 は`他を阻む属性$を［
有するならば，その値／
有さないならば，空~文字列
］
◎
Let value be the value of el's blocking attribute, or the empty string if no such attribute exists.
</li>
	<li>
%値 ~SET `~ASCII小文字~化する$( %値 )
◎
Set value to value, converted to ASCII lowercase.
</li>
	<li>
%生の~token群 ~LET `~ASCII空白で分割する$( %値 )
◎
Let rawTokens be the result of splitting value on ASCII whitespace.
</li>
	<li>
~RET %生の~token群 から`アリな他を阻む~token$でないものすべてを除いた集合
◎
Return a set containing the elements of rawTokens that are possible blocking tokens.
</li>
</ol>
</div>

<p>
所与の要素 %要素 には
`具現化を阻む能性@
がある（ `potentially render-blocking^en である）とは、
次が満たされることをいう
⇒
［
`render$l ~IN %要素 用の`他を阻む~token集合$
］~OR［
%要素 には`暗黙的に具現化を阻む能性$がある
］
◎
An element is potentially render-blocking if its blocking tokens set contains "render", or if it is＼
</p>

<p>
所与の要素に
`暗黙的に具現化を阻む能性@
がある（ `implicitly potentially render-blocking^en である）かどうかは、
個々の要素ごとに定義される。
既定では、
要素には，`暗黙的に具現化を阻む能性$はないとする。
◎
implicitly potentially render-blocking, which will be defined at the individual elements. By default, an element is not implicitly potentially render-blocking.
</p>

			</section>
			<section id="fetch-priority-attributes">
<h4 title="Fetch priority attributes">2.5.9 ~fetch優先度~属性</h4>

<p>
内容~属性には、
`~fetch優先度~属性@
（ `fetch priority attribute^en ）
であると定義されるものもある。
【通例的に， `fetchpriority^a と命名される。】
それは，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
A fetch priority attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態（文字列†）
<th>概略的な記述
<tbody>

<tr><td>`high@v
<td>`高い@st
（ `high^l ）
<td>
`行先$rqが同じ他の資源に相対的な`~fetch$優先度は、
高いことを通達する。

<tr><td>`low@v
<td>`低い@st
（ `low^l ）
<td>
`行先$rqが同じ他の資源に相対的な`~fetch$優先度は、
低いことを通達する。

<tr><td>`auto@v
<td>`自動@st
（ `auto^l ）
<td>
`行先$rqが同じ他の資源に相対的な`~fetch$優先度は、
自動的に決定することを通達する。
</table>

<p class="trans-note">【†
各~状態は，抽象的な定数であるが、
この仕様の各所では，括弧内に挙げた文字列に等しいものと見なされ、
文字列として，要請の`優先度$rqに利用される。
】</p>

◎
Keyword｜State｜Brief description
high｜High｜Signals a high-priority fetch relative to other resources with the same destination.
low｜Low｜Signals a low-priority fetch relative to other resources with the same destination.
auto｜Auto｜Signals automatic determination of fetch priority relative to other resources with the same destination.
</div>

<p>
`~fetch優先度~属性$の［
`欠落~値~用の既定の状態$, `妥当でない値~用の既定の状態$
］は、
いずれも `自動$st とする。
◎
The attribute's missing value default and invalid value default are both the Auto state.
</p>

			</section>
		</section>
</main>
