<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Conditional Rules Module Level 5 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let context_desc = '';

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'p':
	{
		const i = key.indexOf(':');
		if(i > 0) {
			key = text.slice(0, i);
			text = `${key}: <code class="value">${text.slice(i + 1)}</code>`;
		}
	}
	break;
case 'tp': // property value type
	text = `&lt;'<code class="property">${key}</code>'&gt;`;
	href = link_map[`p.${key}`];
	break;
case 'd':
	context_desc = `#valdef-container-${key}-`;
	break;
case 'vd':
	href = context_desc + key;
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 'at': 
	text = `@${key}`;
	break;
case 'f': 
	text = `${key}()`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'm':
	{
		const n = text.indexOf('(');
		if(n > 0){
			key = text.slice(0, n);
			text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
		}
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Conditional Rules Module Level 5
spec_date:2025-05-23
trans_update:2025-05-24
source_checked:240617
page_state_key:CSS
original_url:https://drafts.csswg.org/css-conditional-5/
	abbr_url:CSSCOND5
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-ux,css
conformance:css
copyright:2025,permissive
trans_1st_pub:2023-11-06


●●class_map
p:property
d:descriptor
pe:pseudo
css:css
at:at-rule
e:element
t:type
tp:type
f:func
v:value
vd:value
u:unit
vC:value
et:event-type

●●tag_map
p:code
d:code
pe:code
at:code
t:var
tp:var
u:code
css:code
e:code
I:code
m:code
c:code
et:code
v:code
vd:code
f:code
vC:code
V:var
i:i
em:em
cite:cite

●●original_id_map

●●mdn_urls
propdef-contain:CSS/contain
propdef-content-visibility:CSS/content-visibility

●●link_map



	●IDL
CSSOMString:~CSSOM1#cssomstring
Exposed:~WEBIDLjs#Exposed
I.CSSConditionRule:~CSSCOND#cssconditionrule
I.CSSContainerRule:#csscontainerrule
I.MediaQueryList:~CSSOMVIEW#mediaquerylist
m.matchMedia:~CSSOMVIEW#dom-window-matchmedia
m.conditionText:~CSSCOND#dom-cssconditionrule-conditiontext
m.containerName:#dom-csscontainerrule-containername
m.containerQuery:#dom-csscontainerrule-containerquery

et.scrollsnapchanging:~CSSSCROLLSNAP2#eventdef-snapevent-scrollsnapchanging
et.scrollsnapchange:~CSSSCROLLSNAP2#eventdef-snapevent-scrollsnapchange

	●css
at.when:#at-ruledef-when
at.else:#at-ruledef-else
at.container:#at-ruledef-container
at.font-face:~CSSFONT#at-font-face-rule
	at.font-face:~CSSFONT5#at-font-face-rule
at.keyframes:~CSSANIM#at-ruledef-keyframes
at.layer:~CASCADE#at-ruledef-layer
at.supports:~CSSCOND#at-ruledef-supports
at.media:~CSSCOND#at-ruledef-media

d.aspect-ratio:#descdef-container-aspect-ratio
d.block-size:#descdef-container-block-size
d.height:#descdef-container-height
d.inline-size:#descdef-container-inline-size
d.orientation:#descdef-container-orientation
d.width:#descdef-container-width
d.stuck:#descdef-container-stuck
d.snapped:#descdef-container-snapped
d.scrollable:#descdef-container-scrollable

p.container-name:#propdef-container-name
p.container-type:#propdef-container-type
p.container:#propdef-container
p.font-size:~CSSFONT#propdef-font-size
p.line-height:~CSS2J#propdef-line-height
p.direction:~CSSWM#propdef-direction
p.writing-mode:~CSSWM#propdef-writing-mode

pe.after:~CSSPSEUDO#selectordef-after
pe.backdrop:~CSSPOS4#selectordef-backdrop
pe.before:~CSSPSEUDO#selectordef-before
pe.file-selector-button:~CSSFORMS#selectordef-file-selector-button
	pe.file-selector-button:~CSSPSEUDO#selectordef-file-selector-button
pe.first-letter:~CSSPSEUDO#selectordef-first-letter
pe.first-line:~CSSPSEUDO#selectordef-first-line
pe.marker:~CSSPSEUDO#selectordef-marker
pe.part():~CSSSHADOWPARTS#selectordef-part
pe.placeholder:~CSSFORMS#selectordef-placeholder
	pe.placeholder:~CSSPSEUDO#selectordef-placeholder
pe.slotted():~CSSSCOPING#selectordef-slotted

t.boolean-expr:~CSSVAL5#typedef-boolean-expr
t.block-contents:~CSSSYN#typedef-block-contents
t.container-condition:#typedef-container-condition
t.container-name:#typedef-container-name
t.container-query:#typedef-container-query
t.custom-ident:~CSSVAL#identifier-value
t.custom-property-name:~CSSVAR#typedef-custom-property-name
t.font-format:~CSSFONT#font-format-values
t.font-tech:~CSSFONT#font-tech-values
t.general-enclosed:~CSSVAL#typedef-general-enclosed
t.length:~CSSVAL#length-value
t.mf-boolean:~MQ5#typedef-mf-boolean
t.mf-plain:~MQ5#typedef-mf-plain
t.mf-range:~MQ5#typedef-mf-range
t.query-in-parens:#typedef-query-in-parens
t.ratio:~CSSVAL#ratio-value
t.rule-list:~CSSSYN#typedef-rule-list
t.scroll-state-query:#typedef-scroll-state-query
t.scroll-state-in-parens:#typedef-scroll-state-in-parens
t.scroll-state-feature:#typedef-scroll-state-feature
t.size-feature:#typedef-size-feature
t.string:~CSSVAL#string-value
t.style-feature:#typedef-style-feature
t.style-in-parens:#typedef-style-in-parens
t.style-query:#typedef-style-query
t.supports-decl:~CSSCOND#typedef-supports-decl
t.supports-feature:#typedef-supports-feature
t.supports-font-format-fn:#typedef-supports-font-format-fn
t.supports-font-tech-fn:#typedef-supports-font-tech-fn
t.supports-selector-fn:~CSSCOND4#typedef-supports-selector-fn

f.var:~CSSVAR#funcdef-var
f.media:#funcdef-media
f.supports:#funcdef-supports

u.em:~CSSVAL#em

v.sticky:~CSSPOS#valdef-position-sticky
v.hidden:~CSSOVERFLOW3#valdef-overflow-hidden

v.not:~MQ5#valdef-media-not
v.revert-layer:~CASCADE#valdef-all-revert-layer
v.revert:~CASCADE#valdef-all-revert

v.normal:#valdef-container-type-normal
v.size:#valdef-container-type-size
v.inline-size:#valdef-container-type-inline-size
v.scroll-state:#valdef-container-type-scroll-state

v.none:#valdef-container-name-none

	vd.portrait:#valdef-container-orientation-portrait
	vd.landscape:#valdef-container-orientation-landscape

	vd.none:#valdef-container-stuck-none
	vd.top:#valdef-container-stuck-top
	vd.right:#valdef-container-stuck-right
	vd.bottom:#valdef-container-stuck-bottom
	vd.left:#valdef-container-stuck-left
	vd.block-start:#valdef-container-stuck-block-start
	vd.inline-start:#valdef-container-stuck-inline-start
	vd.block-end:#valdef-container-stuck-block-end
	vd.inline-end:#valdef-container-stuck-inline-end

	vd.none:#valdef-container-snapped-none
	vd.x:#valdef-container-snapped-x
	vd.y:#valdef-container-snapped-y
	vd.block:#valdef-container-snapped-block
	vd.inline:#valdef-container-snapped-inline
	vd.both:#valdef-container-snapped-both


	vd.none:#valdef-container-scrollable-none
	vd.top:#valdef-container-scrollable-top
	vd.right:#valdef-container-scrollable-right
	vd.bottom:#valdef-container-scrollable-bottom
	vd.left:#valdef-container-scrollable-left
	vd.block-start:#valdef-container-scrollable-block-start
	vd.inline-start:#valdef-container-scrollable-inline-start
	vd.block-end:#valdef-container-scrollable-block-end
	vd.inline-end:#valdef-container-scrollable-inline-end
	vd.x:#valdef-container-scrollable-x
	vd.y:#valdef-container-scrollable-y
	vd.block:#valdef-container-scrollable-block
	vd.inline:#valdef-container-scrollable-inline

	●用語
条件付き規則の連鎖:#conditional-rule-chain
~font技術を~supportする:#dfn-support-font-tech
~font形式を~supportする:#dfn-support-font-format

~query容器:#query-container
~query容器~名:#query-container-name
~size特能:#size-features
~style特能:#style-features
~scroll状態~特能:#scroll-state-feature
容器~query:#container-query
容器~query長さ:#container-query-length
容器~query長さ単位:#container-query-length
容器~size~query:#container-size-query
容器~style~query:#container-style-query
css.style():#container-style-query
容器~特能:#container-feature
容器~scroll状態~query:#container-scroll-state-query


	●用語（CSS
条件付き~group規則:~CSSCOND#conditional-group-rule
~CSS特能~query:~CSSCOND#css-feature-queries
~supports~query:~CSSCOND#supports-queries

~size封込め:~CSSCONTAIN#size-containment
行内-~size封込め:~CSSCONTAIN#inline-size-containment
~style封込め:~CSSCONTAIN#style-containment
封込め:~CSSCONTAIN#containment
~layout封込め:~CSSCONTAIN#layout-containment
~layout封込め~box:~CSSCONTAIN#layout-containment-box

~CSS全域~keyword:~CSSVAL#css-wide-keywords
~CSS識別子:~CSSVAL#css-css-identifier
小さい表示域~size:~CSSVAL#small-viewport-size
相対~長さ単位:~CSSVAL#relative-length
比率:~CSSVAL#ratio

~at-規則:~CSSSYN#at-rule
~style規則:~CSSSYN#style-rule
宣言:~CSSSYN#declaration

~cascadeに依存する~keyword:~CASCADE#cascade-dependent-keyword
~prop:~CASCADE#css-property
下位prop:~CASCADE#longhand
初期~値:~CASCADE#initial-value
略式~prop:~CASCADE#shorthand-property
算出d値:~CASCADE#computed-value
算出-:~CASCADE#computed-value

真偽-文脈:~MQ5#boolean-context
範囲~文脈:~MQ5#range-context
媒体~query:~MQ5#media-query
媒体~特能:~MQ5#media-feature

	＠~WANIM#effect-value
~style変化~event:~TRANSITION#style-change-event

首要~box:~CSSDISP#principal-box
独立な整形~文脈:~CSSDISP#independent-formatting-context

内容~box:~CSSBOX#content-box

~size:~SIZING#size
縦幅:~SIZING#height
横幅:~SIZING#width
最小-内容~size:~SIZING#min-content

塊-軸:~CSSWM#block-axis
塊~size:~CSSWM#block-size
行内-軸:~CSSWM#inline-axis
行内~size:~CSSWM#inline-size
塊-始端:~CSSWM#block-start
行内-始端:~CSSWM#inline-start
塊-終端:~CSSWM#block-end
行内-終端:~CSSWM#inline-end

~supportされる~CSS~prop:~CSSOM1#supported-css-property

仮想の~tag列:~CSSPSEUDO#fictional-tag-sequence

疑似要素:~SELECTORS4#pseudo-element
出自の要素:~SELECTORS4#originating-element
最終的な出自の要素:~SELECTORS4#ultimate-originating-element

~custom~prop:~CSSVAR#custom-property

平坦~tree:~CSSSCOPING#flat-tree

~scroll容器:~CSSOVERFLOW3#scroll-container
~scrollport:~CSSOVERFLOW3#scrollport
~scroll可能な~overflow矩形:~CSSOVERFLOW3#scrollable-overflow-rectangle
~scroll可能な~overflow:~CSSOVERFLOW3#scrollable-overflow
到達-不能な~scroll可能な~overflow領域:~CSSOVERFLOW3#unreachable-scrollable-overflow-region
	#negative-scrollable-overflow-region → #unreachable-scrollable-overflow-region

張付き~view矩形:~CSSPOS#sticky-view-rectangle
張付きに位置され:~CSSPOS#sticky-position

~layout後の状態を~snapshotする手続き:~CSSOMVIEW#run-snapshot-post-layout-state-steps
留め~target:~CSSSCROLLSNAP2#snap-target
留め容器:~CSSSCROLLSNAP#scroll-snap-container
留められ:~CSSSCROLLSNAP#scroll-snap

	●用語（他
広義-先祖:~DOM4#concept-tree-inclusive-ancestor
~shadow~host:~DOM4#element-shadow-host
~shadow~tree:~DOM4#concept-shadow-tree

連結する:~INFRA#string-concatenate

~event~loop処理~model:~WAPI#event-loop-processing-model

●●words_table1
SCROLL-ANIM:https://drafts.csswg.org/scroll-animations-1/
CSSSCROLLSNAP2:https://drafts.csswg.org/css-scroll-snap-2/

inline-size0:inline-size

●●words_table

	●条件付き
条件付けら:conditionさ::~
supports:
真:true::~
偽:false::~
	`真^i:true
	`偽^i:false
	`未知^i:unknown
比較子:comparator:~
論理:logic:~
	真偽-条件:boolean
代数:algebra:~
葉:leave:~
式:expression:~
	〜:X
	論理積:“and” boolean relation
	~~結合:conjoin

	●幾何
縦横比:aspect-ratio::~
縦方向:vertical::~
横方向:horizontal::~
矩形:rectangle:~
	対~辺どうし:opposite edge
	異なる軸:opposite axes
	横方向かつ縦方向:both directions
	`塊-軸$方向:block direction
	`行内-軸$方向:inline direction

	●layout
封込め:containment::封じ込め
首要:principal::主要
押出す:pushする:押し出す

	●scroll
scrollport::::スクロール域
	~scroll容器:scroller
	~scrollを~snapshotしている:scroll-snapshotting
張付き:sticky::~
張付な:stickされ::張付いている
	stickされ:stuck
切取られ:clipされ::切り取られ
ズラされ:shiftされ:ずらされ
留ng:snapping::留め::スナッピング
留め:snap::~::スナップ
留めら:snapさ::~::スナップさ
居続ける:stayする:~
	過ぎた:past
	~scroll状態:scroll-state

	●CSS
For:for:用途
出自の:originating::~
複合:compound::~
全域:wide-:~
代入:substitution::~
代入-:substitute::~
比率:ratio::~
gradient:
単彩色:monochrome:~
異体:variation::~::バリエーション

	●処理
	同時:same time
	箇所たち:points

	●仕様
仮想の:fictionalな:~
適格:eligible:~
提起-:raise:~
集成-:aggregate:~
	集成した上で in aggregate
複雑:complicated:~
稼働-:run:~
不用意:accidental:~
種類:kind:~
発展:evolution:~
有用性:utility:~
想定-:suppose:~
	予め想定され:presuppose
早期:early:~
細工-:craft:~
作為的:silly:~
取込む:importする:取り込む
誤記:typo:~
余分:extra:~
統一-:unify:~
循環依存:cycle:~

	規範的でない:informative
	得るため:for the sake
	能力がある:capable
	応答-可能:responsive
	不要な:unneeded
	注記-:note
	~~起因する:caused by
	珍しくない:not unusual
	事足りる:fine
	難しい:hard
	難しく:harder
	に注意:notice
	事実:fact
	~~現実の:real-world
	悪化する:would get 〜 worse
	に似た:a la
	共通的に:not uncommon
	間違った:wrong
	~~大体は:pretty
	なりそうだ:I presume
	読む:read
	書く:write
	~~判明:see
	人にもよろうが:for me
	至らせ:lead

	●言い換え
連結-:concatenate:~
	連結-:join
	~~縮約-:reduce
	評価が変化したとき:starts (or stops) applying
	種別~選定~用の:type-selection
	容器~query:Container Query
	ResizeObserver:resizeObserver
	~typographic~style:typographic concerns
	上に挙げたものでない:remaining
	種別~選定:type-selection
	~shadow~DOM:shadow-DOM
	^p:font-size
	^p:container-type
	`main^e main
	`aside^e:sidebar
	`.my-component^css の行内~size:width of 〜 inline-container
	塊~size:height
	評価した結果は:evaluates to
	色~fontだけ:flat color fill
	評価される:The result is
	他が選ばれない場合:unless one of the earlier conditions succeeds.
	color-COLRv1^v:COLRv1
	color-SVG^v:SVG
	color-COLRv0^v:COLRv0
	~styleされなく:then left unstyled
	に加え:simultaneously
	から順に:The most 〜 the next best choice 〜 while the least
	この~level 5:CSS Conditional Level 5
	技術:tech
	容器~query$:Container Queries
	媒体~query$:Media Queries
	満たされないときに限り `真^i になる:as the inverse of
	...排他的でない:doesn’t exclude large widths...
	重複して:duplicating
	ある種別の:certain types of

	●未分類
併合-:merge:~
component::::コンポーネント
typography::::タイポグラフィ
typographic::::タイポグラフィック
帯域幅:bandwidth:~
浪費-:waste:~
可変:variable:~
排他的:exclusive:~
修飾-:qualify:~
短絡-:short-circuit:~
Latin::::ラテン
Greek:::ギリシア文字
後続-:follow:~
先行-:precede:~
本物の:realな:~
計数:counting:~

	し続ける:continue
	右:right
	時点:point
	過ぎる:past
	つなげる:string
	寸法に関する:dimensional
	逆に:reverse
	括弧:parentheses
	評価-時の:on evaluating
	十分:enough
	にも:back
	これまでの:previous
	一部:part
	を~~基準に:against
	を~~基準に:with respect
	小さい方:smaller
	大きい方:larger
	来て:come
	最も近い:nearest
	満たす:meet
	上回る:above
	相互に:mutually
	-:very
	とても:very
	何も:anything at all
	順に:in order
	連続する:consecutive
	同じに:identically
	一連の:a collection of
	一連の:series of
	〜全体:as a whole
	これら各:successive
	も:plus
	現れる:appear
	重複:duplication
	^c:if-else
	直後:immediately
	直前:immediately
	含む:include
	一つだけ:exactly one
	選ばれ:chosen


●●ref_normative

[CSS-ANIMATIONS-1]
    David Baron; et al. ＜CSS Animations Level 1＞. URL: https://drafts.csswg.org/css-animations/
[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 4＞. URL: https://drafts.csswg.org/css-cascade-4/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-CONDITIONAL-3]
    Chris Lilley; David Baron; Elika Etemad. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/
[CSS-CONDITIONAL-4]
    David Baron; Elika Etemad; Chris Lilley. ＜CSS Conditional Rules Module Level 4＞. URL: https://drafts.csswg.org/css-conditional-4/
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. ＜CSS Containment Module Level 2＞. URL: https://drafts.csswg.org/css-contain-2/
[CSS-CONTAIN-3]
    Tab Atkins Jr.; Florian Rivoal; Miriam Suzanne. ＜CSS Containment Module Level 3＞. URL: https://drafts.csswg.org/css-contain-3/
[CSS-DISPLAY-4]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Display Module Level 4＞. URL: https://drafts.csswg.org/css-display/
[CSS-FONTS-4]
    Chris Lilley. ＜CSS Fonts Module Level 4＞. URL: https://drafts.csswg.org/css-fonts-4/
[CSS-FONTS-5]
    Chris Lilley. ＜CSS Fonts Module Level 5＞. URL: https://drafts.csswg.org/css-fonts-5/
[CSS-OVERFLOW-3]
    Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-POSITION-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 3＞. URL: https://drafts.csswg.org/css-position-3/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. URL: https://drafts.csswg.org/css-scoping/
[CSS-SCROLL-SNAP-2]
    Elika Etemad; Tab Atkins Jr.; Adam Argyle. ＜CSS Scroll Snap Module Level 2＞. URL: https://drafts.csswg.org/css-scroll-snap-2/
[CSS-SHADOW-PARTS-1]
    Tab Atkins Jr.; Fergal Daly. ＜CSS Shadow Parts＞. URL: https://drafts.csswg.org/css-shadow-parts/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-TRANSITIONS-1]
    David Baron; et al. ＜CSS Transitions＞. URL: https://drafts.csswg.org/css-transitions/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-VALUES-5]
    Tab Atkins Jr.; Elika Etemad; Miriam Suzanne. ＜CSS Values and Units Module Level 5＞. URL: https://drafts.csswg.org/css-values-5/
[CSS-VARIABLES-2]
    ＜CSS Custom Properties for Cascading Variables Module Level 2＞. Editor's Draft. URL: https://drafts.csswg.org/css-variables-2/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. URL: https://drafts.csswg.org/css-writing-modes-4/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[CSSOM-VIEW-1]
    Simon Pieters. ＜CSSOM View Module＞. URL: https://drafts.csswg.org/cssom-view/
[MEDIAQUERIES-4]
    Florian Rivoal; Tab Atkins Jr.. ＜Media Queries Level 4＞. URL: https://drafts.csswg.org/mediaqueries-4/
[MEDIAQUERIES-5]
    Dean Jackson; et al. ＜Media Queries Level 5＞. URL: https://drafts.csswg.org/mediaqueries-5/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[WEB-ANIMATIONS-1]
    Brian Birtles; et al. ＜Web Animations＞. URL: https://drafts.csswg.org/web-animations-1/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-FORMS-1]
    Tim Nguyen. ＜CSS Form Control Styling Level 1＞. URL: https://drafts.csswg.org/css-forms-1/
[CSS-POSITION-4]
    ＜CSS Positioned Layout Module Level 4＞. Editor's Draft. URL: https://drafts.csswg.org/css-position-4/
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. ＜CSS Pseudo-Elements Module Level 4＞. URL: https://drafts.csswg.org/css-pseudo-4/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Conditional Rules Module Level 5</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-conditional-5/
公表履歴
	https://www.w3.org/standards/history/css-conditional-5/
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-conditional-5">CSSWG Issues Repository</a>
編集
	<a href="https://dbaron.org/">L. David Baron</a> (Mozilla)
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Apple)
	<a href="https://svgees.us/">Chris Lilley</a> (W3C)
	<a href="https://www.miriamsuzanne.com/who/">Miriam E. Suzanne</a> (Invited Expert)
Suggest an Edit for this Spec:
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-conditional-5/Overview.bs">GitHub Editor</a>
差分仕様
	yes
テスト一式
	https://wpt.fyi/results/css/css-conditional/
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-conditional-5
</script>

</head>
<body>


<header>
	<hgroup>
<h1>CSS 条件付き規則 — CSS Conditional Rules Module Level 5</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<div>
<p>
この~moduleは、
~CSSによる［
適用されている~stylesheetを成す各部に対する［
処理器／環境
］の能力に基づく条件付き処理
］用の特能を包含する
— それは：
</p>
<ul>
	<li>
~level 4 `css-conditional-4$r の機能性を含み，それを拡張する
</li>
	<li>
一般~化された条件付き規則 `when$at を追加する。
</li>
	<li>
連鎖された条件付き規則 `else$at を追加する。
</li>
	<li>
`supports$at 規則~内で利用される`~supports~query$の構文に対する~font処理~queryを導入する。
</li>
	<li>

`容器~query$を導入する。
</li>
</ul>
◎
This module contains the features of CSS for conditional processing of parts of style sheets, based on capabilities of the processor or the environment the style sheet is being applied in. It includes and extends the functionality of CSS Conditional 4 [css-conditional-4], adding the generalized conditional rule @when and the chained conditional rule @else, as well as introducing font processing queries to the supports query syntax used in @supports rules, and container queries.
</div>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p class="issue">
この~level 5 は、
現時点では，`新たなもの^emからなる早期~草案である。
以前の~level `css-conditional-3$r, `css-conditional-4$r にて定義される特能は、
まだ，ここには複製されていない。
◎
This is currently an early draft of the things that are new in level 5. The features in Level 3 and Level 4 are still defined in [css-conditional-3] and [css-conditional-4] and have not yet been copied here.
</p>

<p>
この~level 5 は：
◎
↓</p>
<ul>
	<li>
~supportされる~font技術を~testすることを許容するため，［
`supports$at 規則,
`~supports~query$の構文
］を拡張する。
◎
CSS Conditional Level 5 extends the @supports rule and supports query syntax to allow testing for supported font technologies.
</li>
	<li>
`when$at 規則を追加する。
それは、
条件付き規則の概念を一般~化する。
既存の条件付き規則において表出できるものは、
`when$at においても，条件の種類を宣言する適切な関数で包装することにより表出できる。
これは、
単独の真偽-式~内に異なる種別の~queryたち
— `媒体~query$, `~supports~query$など —
を容易に組合せることを作者に許容する。
これが無い下では、
作者は別々な条件付き規則を入子にすることに依拠しなければならず，
読むのも書くのも難しくなり，
各~条件は論理積で~~結合されるものと予め想定され
（他を指示する容易な仕方は無い），
提案された`条件付き規則の連鎖$における有用性も制約される。
◎
It also adds an @when rule, which generalizes the concept of a conditional rule. Anything that can be expressed in an existing conditional rule can be expressed in @when by wrapping it in an appropriate function to declare what kind of condition it is. This allow authors to easily combine multiple types of queries, such as media queries and supports queries, in a single boolean expression. Without this, authors must rely on nesting separate conditional rules, which is harder to read and write, presupposes the conditions are to be conjoined with the “and” boolean relation (with no easy way to indicate anything else), and restricts their utility in the proposed conditional rule chains.
</li>
	<li>
`else$at 規則を追加する。
それは、
他の条件付き規則の直後に後続する。
それは、
自身の条件を［
直前に先行する各~規則の条件が満たされないときに限り `真^i になる
］よう自動的に修飾する
— それにより、
`条件付き規則の連鎖$を成す規則のうち最初に合致した【条件が `真^i に評価された】ものに限り適用されるようにする。
◎
It also adds @else rules, which immediately follow other conditional rules and automatically qualify their conditions as the inverse of the immediately preceding rule’s conditions, such that only the first matching rule in a conditional rule chain is applied.
</li>
	<li>
`容器~query$を追加する。
それは，概念的には媒体~queryに類似するが、
【媒体としての】文書~全体ではなく，
文書の中の【個々の】要素の側面
（~boxの寸法や算出された~styleなど）
を~testすることを許容する。
◎
It also adds Container Queries. They are conceptually similar to Media Queries, but allow testing aspects of elements within the document (such as box dimensions or computed styles), rather than on the document as a whole.
</li>
</ul>


	</section>
	<section id="at-supports-ext">
<h2 title="Extensions to the @supports rule">2. `supports$at 規則に対する拡張</h2>

<p>
この~levelは、
`supports-feature$t 構文を次に従って拡張する：
◎
This level of the specification extends the &lt;supports-feature&gt; syntax as follows:
</p>

<pre class="prod">
`supports-feature@t
	= `supports-selector-fn$t
	| `supports-font-tech-fn$t
	| `supports-font-format-fn$t
	| `supports-decl$t
`supports-font-tech-fn@t
	= font-tech( `font-tech$t )
`supports-font-format-fn@t
	= font-format( `font-format$t )
</pre>

<dl>
	<dt>`supports-font-tech-fn$t</dt>
	<dd>
~UAが引数として供された`~font技術を~supportする$ならば `真^i に評価される†。
◎
The result is true if the UA supports the font tech provided as an argument to the function.
</dd>

	<dt>`supports-font-format-fn$t</dt>
	<dd>
~UAが引数として供された`~font形式を~supportする$ならば `真^i に評価される†。
◎
The result is true if the UA supports the font format provided as an argument to the function.
</dd>
</dl>

<p class="trans-note">【†
他の場合は `偽^i に評価される。
`supports$at 規則~用の条件は、
`未知^i に評価されることはないので。
】</p>

		<section id="support-definition-ext">
<h3 title="Extensions to the definition of support">2.1. ~supportの定義に対する拡張</h3>

<p>
~CSS処理器は、
次を満たすとき，
`~font技術を~supportする@
ものと見なされる
⇒
`font-tech$t として指定された
`CSS-FONTS-4$r `§ ~font技術＠~CSSFONT#font-tech-definitions$
を［
~layout, 描画
］において用立てる能力がある。
◎
A CSS processor is considered to support a font tech when it is capable of utilizing the specified CSS Fonts 4 § 11.1 Font tech in layout and rendering.
</p>

<p>
~CSS処理器は、
次を満たすとき，
`~font形式を~supportする@
ものと見なされる
⇒
`font-format$t として指定された
`CSS-FONTS-4$r `§ ~font形式＠~CSSFONT#font-format-definitions$
— ただし， `string$t として指定されたものは除く —
を［
~layout, 描画
］において用立てる能力がある。
◎
A CSS processor is considered to support a font format when it is capable of utilizing the specified CSS Fonts 4 § 11.2 Font formats in layout and rendering, and this format is not specified as a &lt;string&gt;.
</p>

		</section>
	</section>
	<section id="when-rule">
<h2 title="Generalized Conditional Rules: the @when rule">3. 一般~化された条件付き規則： `when^at 規則</h2>

<p>
`when@at
~at-規則は、
個々の`条件付き~group規則$
— `media$at や `supports$at など —
を一般~化する`条件付き~group規則$である。
それは、
次で定義される：
◎
The @when at-rule is a conditional group rule that generalizes the individual conditional group rules such as @media and @supports. It is defined as:
</p>

<pre class="prod">
@when `boolean-condition^t {
  `rule-list$t
}
</pre>

<p>
`boolean-condition^t は、
`MEDIAQUERIES-5$r `§ 構文＠~MQ5#mq-syntax$ に似た真偽-代数であるが，［
`media$f, `supports$f
］関数を葉として伴う。
◎
Where &lt;boolean-condition&gt; is a boolean algebra a la Media Queries 4 § 3 Syntax, but with media() and supports() functions as leaves.
</p>

<p class="issue">
“真偽-代数”,
“〜を葉として伴う”
を汎用な仕方で定義する。
すべての条件付き規則が
— 自前の真偽-代数を定義し直す必要なく —
それを直に参照できるよう。

【おそらく、 `boolean-expr$t `CSS-VALUES-5^r を参照することになろう。】
◎
Define "boolean algebra, with X as leaves" in a generic way in Conditional, so all the conditional rules can reference it directly, rather than having to redefine boolean algebra on their own.
</p>

<p>
`media$f 関数,
`supports$f 関数は、
次で定義される：
◎
The media() and supports() functions are defined as:
</p>

<pre class="prod">
`media@f
	= media( [ `mf-plain$t | `mf-boolean$t | `mf-range$t ] )
`supports@f
	= supports( `declaration^t )
</pre>

<p>
これらの関数は、
その名前を伴う~at-規則
— `media^f 用には `media$at ／
`supports^f 用には `supports$at —
に則って，その引数を評価した結果に評価される。
◎
A media() or supports() function is associated the boolean result that its contained condition is associated with.
</p>

	</section>
	<section id="else-rule">
<h2 title="Chained Conditionals: the @else rule">4. 連鎖された条件付き規則： `else^at 規則</h2>

<p>
`条件付き~group規則$は、
通例的には，互いに独立である
— 各自が有する条件は，他の規則への直な参照を伴うことなく別々に評価され、
もっぱら自身の条件に基づいて，包含している規則を適用するかどうかを裁定する。
◎
Usually, conditional group rules are independent; each one has a separate condition evaluated without direct reference to any other rule, and decides whether or not to apply its contained rules based solely on its condition.
</p>

<p>
これは、
単純な条件~用には事足りるが，［
相互に排他的になることが意味された一連の条件付き
］を書くことは困難である。
作者は、
それらの条件を注意深く細工する必要がある
— ［
他の規則が意味されるときには、作動化しない
］よう，および［
一連の条件付きが`すべて^emが不用意に除外されて，一部の状況では~styleされなくなる
］ことはないよう。
◎
This is fine for simple conditions, but makes it difficult to write a collection of conditionals that are meant to be mutually exclusive: authors have to very carefully craft their conditions to not activate when the other rules are meant to, and make sure the collection of conditionals don’t accidentally all exclude some situation which is then left unstyled.
</p>

<p>
`else@at
規則は、
`条件付き規則の連鎖$を形成するために利用される`条件付き~group規則$である
— それは、
複数の`条件付き~group規則$どうしを結付けて，［
最初に合致するものに限り，その条件が `真^i として評価されるようになる
］ことを保証する。
それは、
次で定義される：
◎
The @else rule is a conditional group rule used to form conditional rule chains, which associate multiple conditional rules and guarantee that only the first one that matches will evaluate its condition as true. It is defined as:
</p>

<pre class="prod">
@else `boolean-condition^t? {
  `rule-list$t
}
</pre>

<p>
`else$at は、
`when$at と同じに解釈される。
その `boolean-condition^t が省略された場合、［
常に `真^i に評価される条件
］が在るものとして扱われる。
◎
@else is interpreted identically to @when. If its &lt;boolean-condition&gt; is omitted, it’s treated as having a condition that’s always true.
</p>

<p>
`条件付き規則の連鎖@
とは、［
`else$at 以外の`条件付き~group規則$から開始され，
0 個以上の `else^at 規則が後続する
］ような，連続する一連の`条件付き~group規則$である。
これら各`条件付き~group規則$どうしの合間には、
空白や~comment以外の~tokenは生じ得ない
— そのような~tokenは、
当の連鎖を “分断する” 。
◎
A conditional rule chain is a series of consecutive conditional group rules, starting with a conditional group rule other than @else, followed by zero or more @else rules. There cannot be anything between the successive conditional group rules other than whitespace and/or comments; any other token “breaks” the chain.
</p>

<p class="issue">
条件を省略できるのは，連鎖を成す最後の `else$at に限られるものと要求するべきか？
~code内の `if^c … `else^c が成す連鎖に対し［
~debugするために，どれか 1 つに `true^c を設定して連鎖を短絡する
］ことは、
人にもよろうが，共通的にあろう。
~CSSにおいても，それは類似に有用になりそうだ
— 不用意に条件を省略した場合でも、
何か間違ったことは，~~大体は容易に~~判明するであろう。
◎
Should we require that only the last @else in a chain can have an omitted condition? It’s not uncommon for me, when debugging code, to short-circuit an if-else chain by setting one of them to "true"; I presume that would be similarly useful in CSS? It’s still pretty easy to see you’ve done something wrong if you omit the condition accidentally.
</p>

<p>
`条件付き規則の連鎖$の中では、
順に，各`条件付き~group規則$を成す条件が評価される。
それらのうち いずれかが `真^i に評価される場合、
`後続して^emいる どの`条件付き~group規則$に対しても，その条件は
— 何が言明されようが —
`偽^i に評価される。
◎
Within a conditional rule chain, the conditions of each conditional group rule are evaluated in order. If one of them is true, the conditions of all following conditional group rules in the chain evaluate to false, regardless of their stated condition.
</p>

<p>
`条件付き規則の連鎖$の一部を成していない `else$at 規則は、
無効であり，無視するモノトスル。
◎
An @else rule that is not part of a conditional rule chain is invalid and must be ignored.
</p>

<div class="example">
<p>
（いくぶん作為的な）
条件付き連鎖の例：
◎
For example, here’s a (somewhat silly) conditional chain:
</p>

<pre class="lang-css">
@when media(width &gt;= 400px) and media(pointer: fine) and supports(display: flex) {
  /* A */
} @else supports(caret-color: pink) and supports(background: double-rainbow()) {
  /* B */
} @else {
  /* C */
}
</pre>

<p>
これらの規則のうち選ばれるものは、
一つだけになる
— 最初の 2 つに指定された条件は まったく独立で排他的でないし，
3 個目の規則は何も指定しない【すなわち，無条件】が、
それでも。
◎
Exactly one of the preceding rules will be chosen, even though the second rule doesn’t exclude large widths, fine points, or flexbox support, and the last rule doesn’t specify anything at all.
</p>

<p>
`条件付き規則の連鎖$を用いずに同じ結果を達成するためには、
次のように書く必要があろう：
◎
To achieve the same result without conditional rule chains, you’d need to write:
</p>

<pre class="lang-css">
@media (width &gt;= 400px) and (pointer: fine) {
  @supports (display: flex) {
    /* A */
  }
  @supports not (display: flex) {
    @supports (caret-color: pink) and (background: double-rainbow()) {
      /* B */
    }
    @supports not ((caret-color: pink) and (background: double-rainbow())) {
      /* C */
    }
  }
}
@media not ((width &gt;= 400px) and (pointer: fine)) {
  @supports (caret-color: pink) and (background: double-rainbow()) {
    /* B */
  }
  @supports not ((caret-color: pink) and (background: double-rainbow())) {
    /* C */
  }
}
</pre>

<p>
これは、
読むのが難しいことに加え，条件, 内容どちらにも有意な重複が要求され、
正しく書くのが`とても困難^emである。
条件がもっと複雑な場合
（~~現実の内容においては珍しくない）、
`有意^emに悪化する。
◎
This is simultaneously hard to read, requires significant duplication of both conditions and contents, and is very difficult to write correctly. If the conditions got any more complicated (which is not unusual in real-world content), the example would get significantly worse.
</p>
</div>

<div class="example">
<p>
この例では、
3 種の異なる色~font技術が選好される順序で~testされる
— 最も能力があるものから順に：
［
`color-COLRv1^v, `variations^v
］は［
~gradient, ~font異体
］どちらも~supportする。
`color-SVG^v は~gradientを~supportする。
`color-COLRv0^v は色~fontだけを~supportする。
◎
In this example, three different color font technologies are tested, in order of preference, plus a monochrome fallback. The most capable, COLRv1, supports both gradients and font variations; the next best choice, SVG, supports gradients while the least capable, COLRv0, supports flat color fill only.
</p>

<p>
また、
最後に~fallbackとして単彩色もある
— それには~test条件は無いので、
他が選ばれない場合には，常に選ばれる。
◎
The fallback has no test condition, so will always be chosen unless one of the earlier conditions succeeds.
</p>

<pre class="lang-css">
@when font-tech(color-COLRv1) and font-tech(variations) {
  @font-face { font-family: icons; src: url(icons-gradient-var.woff2); }
}
@else font-tech(color-SVG) {
  @font-face { font-family: icons; src: url(icons-gradient.woff2); }
}
@else font-tech(color-COLRv0) {
  @font-face { font-family: icons; src: url(icons-flat.woff2); }
}
@else {
  @font-face { font-family: icons; src: url(icons-fallback.woff2); }
}
</pre>

<p>
この例では、
可変~色~font【 `icons-gradient-var.woff2^v 】は，［
`color-COLRv1^v, ~font異体
］どちらも~supportされる場合に限り~downloadされることに注意。
◎
Notice that in this example, the variable color font is only downloaded if COLRv1 is supported and font variations are also supported.
</p>

<p>
可用な~optionのうち 1 つだけが~downloadされることにも注意。
`when$at, `else$at を伴わない事例では、
次の例が示すとおり，そうならない。
◎
Notice too that only one of the available options will be downloaded; this would not be the case without @when and @else, as the next example shows.
</p>
</div>

<div class="example">
<p>
この例では、［
`color-COLRv1^v が~supportされる場合は，~fallbackは利用されなくなる
］ように現れるが、
事実においては，どちらの~fontも~downloadされ、
利用されない~fontは帯域幅を浪費することになる。
◎
In this example, although it appears that the fallback will not be used if COLRv1 is supported, in fact both fonts will be downloaded, which wastes bandwidth if it is not used.
</p>

<p>
それでも、
一部の文字~用には，~fallbackが利用されるかもしれない
— 例えば、
当の色~fontは~Latinしか~supportしないが，
~fallbackは~Latinと~Greekを~supportする場合。
◎
The fallback might still be used for some characters; for example, if the color font supports only Latin, while the fallback supports Latin and Greek.
</p>

<pre class="lang-css">
@font-face { font-family: icons; src: url(icons-fallback.woff2);
@supports font-tech(color-COLRv1) {
  @font-face { font-family: icons; src: url(icons-gradient-var.woff2); }
}
</pre>
</div>

	</section>
	<section id="container-queries">
<h2 title="Container Queries">5. 容器~query</h2>

<p>
`媒体~query$は，
当の文書を表示している~UAや機器~環境を成す ある種の側面（表示域~寸法や利用者~選好など）を~queryするための~methodを供するが、
`容器~query$は，
当の文書の中で要素を成す ある種の側面（~box寸法や算出された~styleなど）を~testすることを許容する。
◎
While media queries provide a method to query aspects of the user agent or device environment that a document is being displayed in (such as viewport dimensions or user preferences), container queries allow testing aspects of elements within the document (such as box dimensions or computed styles).
</p>

<p>
`容器~style~query$の目的においては、
すべての要素は，既定では
`~query容器@
（ `query container^en ）になる。
さらには、［
`container-type$p ~prop（または `container$p `略式~prop$）を利用して，
追加的な~query種別を指定する
］ことにより，要素は［
`容器~size~query$／
`容器~scroll状態~query$
］用の`~query容器$も確立し得る。
`~query容器$の`平坦~tree$における子孫に適用される~style規則は、［
当の容器に対し， `container$at `条件付き~group規則$を利用して~queryする
］ことにより，条件付けられ得る。
◎
By default, all elements are query containers for the purpose of container style queries, and can be established as query containers for container size queries and container scroll-state queries by specifying the additional query types using the container-type property (or the container shorthand). Style rules applying to a query container’s flat tree descendants can be conditioned by querying against it, using the @container conditional group rule.
</p>

<div class="example">
<p>
例えば、
`main^e や `aside^e 用の区画を容器として定義してから，
`.media-object^css を［
自身が属する容器の~sizeに依存して~layoutを縦方向から横方向へ変更する
］ものとして記述できる：
◎
For example, we can define the main content area and sidebar as containers, and then describe a .media-object that changes from vertical to horizontal layout depending on the size of its container:
</p>

<pre class="lang-css">
main, aside {
  container: my-layout / inline-size;
}

.media-object {
  display: grid;
  grid-template: 'img' auto 'content' auto / 100%;
}

@container my-layout (inline-size &gt; 45em) {
  .media-object {
    grid-template: 'img content' auto / auto 1fr;
  }
}
</pre>

<p>
［
`main^e ／ `aside^e
］用の区画~内の各 `.media-object^css は、
各自の自前の容器~文脈に応答することになる。
◎
Media objects in the main and sidebar areas will each respond to their own container context.
</p>
</div>

<div>
<p>
`疑似要素$選択子~用には、
`~query容器$は，次により確立され得る：
</p>
<ul>
	<li>
［
`part()$pe ／ `slotted()$pe
］用には、［
それが表現する~DOM~tree内の本物の要素
］の`平坦~tree$における先祖
</li>
	<li>
他の疑似要素~用には、
その`出自の要素$†の`平坦~tree$における`広義-先祖$
</li>
</ul>

<p class="trans-note">【†
より精確には`最終的な出自の要素$
（次の注記に現れる “出自の要素” も同様）。
】</p>

◎
For the ::part() and ::slotted() pseudo-element selectors, which represent real elements in the DOM tree, query containers can be established by flat tree ancestors of those elements. For other pseudo-elements, query containers can be established by inclusive flat tree ancestors of their originating element.
</div>

<div class="note">
<p>注記：
従って：
◎
It follows that:
</p>
<ul>
	<li>
［
`before$pe,
`after$pe,
`marker$pe,
`backdrop$pe
］は、
各自の出自の要素を~queryする。
◎
::before, ::after, ::marker, and ::backdrop query their originating elements
</li>
	<li>
［
`first-letter$pe,
`first-line$pe
］は、
各自の出自の要素を~queryする
— 継承と描画の目的において，
`仮想の~tag列$が `first-line$pe を他の要素を過ぎるよう押出す場合でも。
◎
::first-letter and ::first-line query their originating elements, even if the fictional tag sequence may push the ::first-line past other elements for the purpose of inheritance and rendering
</li>
	<li>
選択子 `slotted()$pe は、
`~shadow~tree$の内側にある容器たち（~slot自身も含む）を~queryできる。
◎
::slotted() selectors can query containers inside the shadow tree, including the slot itself
</li>
	<li>
選択子 `::slotted()::before^css は、
`~shadow~host$の~slotされる子【 `slotted()$pe に合致する要素】を~queryできる
◎
::slotted()::before selectors can query the slotted shadow host child
</li>
	<li>
選択子 `part()$pe は、
`~shadow~tree$の内側にある容器を~queryできる。
◎
::part() selectors can query containers inside the shadow tree
</li>
	<li>
［
`placeholder$pe,
`file-selector-button$pe
］は，入力~要素を~queryできるが、
当の入力~要素が`~shadow~tree$を利用して実装された場合，それは内部の容器を公開しない。
◎
::placeholder and ::file-selector-button can query the input element, but do not expose any internal containers if the input element is implemented using a shadow tree
</li>
</ul>
</div>

<div class="example">
<p>
次の `before^pe 選択子は、
出自の要素の~sizeを~queryしている：
◎
A ::before selector querying the size of the originating element:
</p>
<pre class="lang-html">
&lt;style&gt;
  #container {
    width: 100px;
    container-type: inline-size;
  }
  @container (inline-size &lt; 150px) {
    #inner::before {
      content: "BEFORE";
    }
  }
&lt;/style&gt;
&lt;div id=container&gt;
  &lt;span id=inner&gt;&lt;/span&gt;
&lt;/div&gt;
</pre>
</div>

<div class="example">
<p>
`~shadow~host$（この例では `id=host^c ）の【ある~slot（ `slot^e ）にアテガわれることになる】子（ `id=slotted^c ）を~styleするための `slotted()$pe 選択子は、
当の`~shadow~tree$内の容器（ `id=container^c ）を~queryできる：
◎
A ::slotted() selector for styling a shadow host child can query a container in the shadow tree:
</p>
<pre class="lang-html">
&lt;div id=host style="width:200px"&gt;
  &lt;template `shadowrootmode＠~HEscripting#attr-template-shadowrootmode$【！shadowroot】=open&gt;
    &lt;style&gt;
      #container {
        width: 100px;
        container-type: inline-size;
      }
      @container (inline-size &lt; 150px) {
        ::slotted(span) {
          color: green;
        }
      }
    &lt;/style&gt;
    &lt;div id=container&gt;
      &lt;slot&gt;&lt;/slot&gt;【！&lt;slot /&gt;】
    &lt;/div&gt;
  &lt;/template&gt;
  &lt;span id=slotted&gt;Green&lt;/span&gt;
&lt;/div&gt;
</pre>
</div>

		<section id="container-type">
<h3 title="Creating Query Containers: the container-type property">5.1. ~query容器の作成-法： `container-type^p ~prop</h3>

◎名 `container-type@p
◎値 `normal$v | [ [ `size$v | `inline-size$v ] || `scroll-state$v ]
◎初 `normal^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア ~animate不可
◎表終

<p>
`container-type$p ~propは、
ある種別の`容器~query$
— `容器~size~query$【！~size`容器~query$】【／`容器~scroll状態~query$】 —
用に，明示的に要素を`~query容器$として確立させる。
`容器~size~query$用には、
いくつかの種別の`封込め$も適用される【！要求する】。
他の種別の`容器~query$
— `容器~style~query$など —
用には、
どの要素も`~query容器$になれる。
◎
The container-type property establishes the element as a query container for certain types of queries. For size container queries, which require certain types of containment, elements are explicitly made query containers through this property. For other types of query containers any element can be a query container, such as for container style queries.
</p>

<p>
各種~値の意味は：
◎
Values have the following meanings:
</p>
<dl class="valdef">
	<dt>`size@v</dt>
	<dd>
<p>
当の要素は：
◎
↓</p>
		<ul>
			<li>
［
`行内-軸$, `塊-軸$
］どちらに対しても，`容器~size~query$用に`~query容器$を確立する。
◎
Establishes a query container for container size queries on both the inline and block axis.＼
</li>
			<li>
その`首要~box$に［
`~style封込め$,
`~size封込め$
］を適用する。
◎
Applies style containment and size containment to the principal box,＼
</li>
			<li>
`独立な整形~文脈$を確立する。
◎
and establishes an independent formatting context.
</li>
		</ul>
	</dd>

	<dt>`inline-size@v</dt>
	<dd>
<p>
当の要素は：
◎
↓</p>
		<ul>
			<li>
【！container’s】自前の`行内-軸$に対し，`容器~size~query$用に`~query容器$を確立する。
◎
Establishes a query container for container size queries on the container’s own inline axis.＼
</li>
			<li>
その`首要~box$に［
`~style封込め$,
`行内-~size封込め$
］を適用する。
◎
Applies style containment and inline-size containment to the principal box,＼
</li>
			<li>
`独立な整形~文脈$を確立する。
◎
and establishes an independent formatting context.
</li>
		</ul>
	</dd>

	<dt>`scroll-state@v</dt>
	<dd>
当の要素は、
`容器~scroll状態~query$【！`~scroll状態~query^】用に`~query容器$を確立する。
◎
Establishes a query container for scroll-state queries
</dd>

	<dt>`normal@v</dt>
	<dd>
当の要素は、［
`容器~size~query$／`容器~scroll状態~query$
］用の`~query容器$にはならないが，
`容器~style~query$用の`~query容器$であり続ける。
◎
The element is not a query container for any container size queries or scroll-state queries, but remains a query container for container style queries.
</dd>
</dl>

<div class="example">
<p>
例えば，作者は、
容器の~sizeに応答-可能な~typographyを作成できる
— ~sizeに基づいて，［
`font-size$p や `line-height$p その他の~typographic~style
］を調整するような：
◎
For example, authors can create container-responsive typography, adjusting font-size, line-height, and other typographic concerns based on the size of a container:
</p>
<pre class="lang-css">
aside, main {
  container-type: inline-size;
}

h2 { font-size: 1.2em; }

@container (width &gt; 40em) {
  h2 { font-size: 1.5em; }
}
</pre>

<p>
~query条件~内で利用される値 `40em^v は、
関連な`~query容器$†の `font-size$p の`算出d値$に相対的になる。
【† この例では `aside^e または `main^e が選定されるものと想定されている。】
◎
The 40em value used in the query condition is relative to the computed value of font-size on the relevant query container.
</p>
</div>

<div class="example">
<p>
容器は、
~queryされる~styleの算出d値も公開できる。
これは、
複数の~propに わたって挙動を~toggleするときに有用になり得る：
◎
Containers can also expose computed style values for querying. This can be useful for toggling behavior across multiple properties:
</p>

<pre class="lang-css">
@container style(--cards: small) {
  article {
    border: thin solid silver;
    border-radius: 0.5em;
    padding: 1em;
  }
}
</pre>
</div>

<div class="example">
<p>
容器は、
~scroll~offsetに依存する状態も公開し得る。
この例では、
`張付きに位置され$た要素【 `#sticky^css 】が上端~辺に張付なとき，その子孫【 `#sticky-child^css 】を~styleする：
◎
Containers can also expose state that depends on scroll offset. This example styles a descendant of a sticky positioned element when it is stuck to the top edge:
</p>

<pre class="lang-css">
#sticky {
  container-type: scroll-state;
  position: sticky;
}
@container scroll-state(stuck: top) {
  #sticky-child {
    background-color: lime;
  }
}
</pre>
</div>

		</section>
		<section id="container-name">
<h3 title="Naming Query Containers: the container-name property">5.2. ~query容器の命名-法： `container-name^p ~prop</h3>

◎名 `container-name@p
◎値 `none^v | `custom-ident$t+
◎初 `none^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 ~keyword `none$v ／ `~CSS識別子$たちが成す有順序~list
◎順 文法に従う
◎ア ~animate不可
◎表終

<p>
`container-name$p ~propは、
`~query容器~名@
（ `container query name^en ）たちが成す~listを指定する。
これらの名前は、
`container$at 規則により，
どの`~query容器$を~targetにするか~filterするために利用できる。
◎
The container-name property specifies a list of query container names. These names can be used by @container rules to filter which query containers are targeted.
</p>

<dl class="valdef">
	<dt>`none@v</dt>
	<dd>
当の`~query容器$には`~query容器~名$は無い。
◎
The query container has no query container name.
</dd>

	<dt id="valdef-container-name-custom-ident">`custom-ident$t</dt>
	<dd>
`~query容器~名$を`~CSS識別子$として指定する。
この `custom-ident$t からは、
~keyword［
`none$v, `and^v, `not$v, `or^v
］は除外される。
◎
Specifies a query container name as an identifier. The keywords none, and, not, and or are excluded from this &lt;custom-ident&gt;.
</dd>
</dl>

<div class="example">
<p>
一部の事例では、
特定の容器を成す側面を~queryすることが求まれる
— それが【この例では `.card^css の】最も近い先祖~容器でない場合でも。
例えば、［
`main^e 内容~区画の塊~size／
より入子にされた `.my-component^css の行内~size
］を~queryするよう求まれるかもしれない。
◎
In some cases, we want to query aspects of a specific container, even if it’s not the nearest ancestor container. For example, we might want to query the height of a main content area, and the width of a more nested inline-container.
</p>
<pre class="lang-css">
main {
  container-type: size;
  container-name: my-page-layout;
}

.my-component {
  container-type: inline-size;
  container-name: my-component-library;
}

@container my-page-layout (block-size &gt; 12em) {
  .card { margin-block: 2em; }
}

@container my-component-library (inline-size &gt; 30em) {
  .card { margin-inline: 2em; }
}
</pre>

<p>
容器を その名前のみに基づいて~queryすることもアリである。
◎
It is also possible to query for a container only based on its name.
</p>

<pre class="lang-css">
@container my-page-layout {
  .card { padding: 1em; }
}
</pre>
</div>

		</section>
		<section id="container-shorthand">
<h3 title="Creating Named Containers: the container shorthand">5.3. 有名~容器の作成-法： `container^p 略式~prop</h3>

◎名 `container@p
◎値 `container-name$tp [ / `container-type$tp ]?
◎初 個々の~propを見よ
◎適 個々の~propを見よ
◎継 個々の~propを見よ
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎ア 個々の~propを見よ
◎順 文法に従う
◎表終

<p>
`container$p `略式~prop$は、
同じ宣言で［
`container-type$p, `container-name$p
］両者を設定する。
`container-type$tp が省略された場合、
`container-type$p は，その`初期~値$に設定し直される。
◎
The container shorthand property sets both container-type and container-name in the same declaration. If &lt;'container-type'&gt; is omitted, it is reset to its initial value.
</p>

<div class="example">
<p>
略式~構文を利用して，［
`container-type$p, `container-name$p
］両者を定義できる：
◎
We can define both a container-type and container-name using the shorthand syntax:
</p>
<pre class="lang-css">
main {
  container: my-layout / size;
}

.grid-item {
  container: my-component / inline-size;
}
</pre>
</div>

		</section>
		<section id="container-rule">
<h3 title="Container Queries: the @container rule">5.4. 容器~query： `container^at 規則</h3>

<p>
`container@at
規則は，`条件付き~group規則$であり、
その条件は
`容器~query@
（ `container query^en ）を包含する。
`容器~query$は、［
個々の［
`容器~size~query$／`容器~style~query$
］【 `container-query$t 】による真偽-条件
］たちが成す組合nである。
`container$at 規則の `block-contents$t ~blockの中の~style宣言たちは、
規則の条件により，［
所与の要素~用の`~query容器$に対し`容器~query$を評価した結果が `真^i になるときに限り，
要素に適用される【！match】
］よう`~filterされる＠~CASCADE#filtering$。
◎
The @container rule is a conditional group rule whose condition contains a container query, which is a boolean combination of container size queries and/or container style queries. Style declarations within the &lt;block-contents&gt; block of an @container rule are filtered by its condition to only match when the container query is true for their element’s query container.
</p>

<p class="trans-note">【
`容器~query$は、
一般には［
当の規則を成す条件~全体
］を指すが，当の規則を成す個々の `container-query$t を指すこともある。
】</p>

<p>
`container$at 規則の構文は：
◎
The syntax of the @container rule is:
</p>

<pre class="prod">
@container `container-condition$t# {
  `block-contents$t
}
</pre>

<p>
ここで：
◎
where:
</p>

<pre class="prod">
`container-condition@t
	= [ `container-name$t? `container-query$t? ]!
`container-name@t
	= `custom-ident$t
`container-query@t
	= not `query-in-parens$t
	| `query-in-parens$t
		[ [ and `query-in-parens$t ]*
		| [ or `query-in-parens$t ]* ]
`query-in-parens@t
	= ( `container-query$t )
	| ( `size-feature$t )
	| style( `style-query$t )
	| scroll-state( `scroll-state-query$t )
	| `general-enclosed$t
`style-query@t
	= not `style-in-parens$t
	| `style-in-parens$t
		[ [ and `style-in-parens$t ]*
		| [ or `style-in-parens$t ]* ]
	| `style-feature$t
`style-in-parens@t
	= ( `style-query$t )
	| ( `style-feature$t )
	| `general-enclosed$t
`scroll-state-query@t
	= not `scroll-state-in-parens$t
	| `scroll-state-in-parens$t
		[ [ and `scroll-state-in-parens$t ]*
		| [ or `scroll-state-in-parens$t ]* ]
	| `scroll-state-feature$t
`scroll-state-in-parens@t
	= ( `scroll-state-query$t )
	| ( `scroll-state-feature$t )
	| `general-enclosed$t
</pre>

<p>
この構文を成す `custom-ident$t においては、
~keyword［
`none$v, `and^v, `not$v, `or^v
］は除外される。
◎
The keywords none, and, not, and or are excluded from the &lt;custom-ident&gt; above.
</p>

<p>
各~要素に対し、
所与の `container-condition$t %条件 用に~queryされることになる`~query容器$は，
当の要素の先祖のうち［
%条件 を成す `container-query$t を成す どの`容器~特能$用にも妥当である
］ものとして確立された`~query容器$から選定される。
`container-query$t が［
未知な／~supportされない
］`容器~特能$を包含する場合、
%条件 用に選定される`~query容器$は無い。
`container-name$t は、
`~query容器$たちが成す集合を［
合致している`~query容器~名$を伴うもの
］だけが考慮されるよう~filterする。
◎
For each element, the query container to be queried is selected from among the element’s ancestor query containers that are established as a valid query container for all the container features in the &lt;container-query&gt;. If the &lt;container-query&gt; contains unknown or unsupported container features, no query container will be selected for that &lt;container-condition&gt;. The &lt;container-name&gt; filters the set of query containers considered to just those with a matching query container name.
</p>

<p class="trans-note">【
該当する`~query容器$が複数ある場合に，
どれが選定されるのか指定する記述が無い
— 普通に考えれば、
それらのうち当の要素に最も近い先祖？
（原文の `query container^en は、
多くの箇所で単数形なので，すべてが選定されることはないであろう）。
】</p>

<p>
要素~用に適格な`~query容器$が選定されたなら、
`container-query$t 内の各`容器~特能$は，
その`~query容器$に対し評価される。
どの先祖も適格な`~query容器$でない場合、
当の要素に対しては，`容器~query$の結果は `未知^i になる。
媒体~queryと同じく、
`general-enclosed$t を評価した結果は `未知^i になる。
`container-query$t が省略された場合、
`~query容器$は， `container-name$t が合致する限り適格になる。
◎
Once an eligible query container has been selected for an element, each container feature in the &lt;container-query&gt; is evaluated against that query container. If no ancestor is an eligible query container, then the container query is unknown for that element. As with media queries, &lt;general-enclosed&gt; evaluates to unknown. If the &lt;container-query&gt; is omitted, the query container is eligible as long as the &lt;container-name&gt; matches.
</p>

<p>
`容器~query$が複数の `container-condition$t を含む場合、
各~条件ごとに自前の`~query容器$が選定され，
それらは独立に評価されることになる。
`容器~query$を評価した結果は、［
次が満たされるならば `真^i ／
~ELSE_ `偽^i
］になる
⇒
`いずれか^emの `container-condition$t 成分を評価した結果は `真^i になる
◎
If a container query includes multiple &lt;container-condition&gt;s, each condition will select it’s own query container, and evaluate independently. A container query is true if any of its component &lt;container-condition&gt;s are true, and false only if all of its component &lt;container-condition&gt;s are false.
</p>

<div class="example">
<p>
`媒体~query$と同じく、
単独の条件~内に複数の~queryを一緒につなげれる：
◎
As with media queries, we can string together multiple queries in a single condition:
</p>
<pre class="lang-css">
@container card (inline-size &gt; 30em) and style(--responsive: true) {
  /* <span class="comment">
~style群
◎
styles
</span> */
}
</pre>

<div>
<p>
上の~style群は、
~AND↓ を満たす先祖~容器が在る場合に限り，適用されることになる：
</p>
<ul>
	<li>
【`container-name$p により】 "`card^v" と命名された
</li>
	<li>
`inline-size$d 条件を満たす
</li>
	<li>
`style()$css 条件を満たす
</li>
</ul>
◎
The styles above will only be applied if there is an ancestor container named "card" that meets both the inline-size and style conditions.
</div>

<p>
複数の条件を~listを成すよう【すなわち，~commaで分離して】組合せることにより、
条件ごとに異なる容器に対し評価させることもできる：
◎
We can also combine multiple conditions into a list, with each condition evaluating against a different container:
</p>

<pre class="lang-css">
@container card (inline-size &gt; 30em), style(--large: true) {
  /* styles */
}
</pre>

<div>
<p>
上の~styleは、
~OR↓ が満たされる場合に適用されることになる：
</p>
<ul>
	<li>
次を満たす先祖~容器が在る
⇒
［
"`card^v" と命名された
］~AND［
`inline-size$d 条件を満たす
］
</li>
	<li>
最も近い~style容器は `style()$css 条件を満たす
【なぜ，ここだけが他の例と違って “最も近い” を伴うのか不明。】
</li>
</ul>
◎
The styles above will be applied if there is an ancestor container named "card" that meets the inline-size condition or the nearest style container meets the style condition.
</div>
</div>

<p>
複数に【複数の `container^at を通して】入子にされた`容器~query$の内側に在る［
ある要素に対し定義された~style規則
］は、
次が満たされるとき適用される
⇒
それを包装している どの【 `container^at の】`容器~query$に対しても，次が満たされる
⇒
それを当の要素~用に評価した結果は `真^i になる
◎
Style rules defined on an element inside multiple nested container queries apply when all of the wrapping container queries are true for that element.
</p>

<p class="note">注記：
入子な`容器~query$は，［
その親とは異なる容器
］との関係において評価されることもあるので、
複数の `container-condition$t を単独の~queryの中へ併合することは，
常にアリになるとは限らない。
◎
Note: Nested container queries can evaluate in relation to different containers, so it is not always possible to merge the individual &lt;container-condition&gt;s into a single query.
</p>

<div class="example">
<p>
単独の［
~commaで分離された`容器~query$
］を利用すれば、
複数の容器を~queryできる：
◎
Using a single comma-separated container query, we can query multiple containers:
</p>

<pre class="lang-css">
@container card (inline-size &gt; 30em), style(--responsive: true) {
    /* <span class="comment">
~style群
◎
styles
</span> */
}
</pre>

<div>
<p>
上の~style群は、
~OR↓ を満たす容器の内側にある要素に適用されることになる：
</p>
<ul>
	<li>
［
"`card^v" と命名された
］~AND［
`inline-size$d 条件を満たす
］
</li>
	<li>
`style()$css 条件を満たす
</li>
</ul>
◎
The styles above will apply for an element inside either a container named "card" that meets the inline-size condition, or a container meeting the style condition.
</div>

<p>
複数の容器を~queryしつつ，
`すべての^em 条件を満たすよう要求するためには、
複数の`容器~query$を入子にする必要がある：
◎
In order to require that all conditions are met while querying multiple containers, we would need to nest multiple queries:
</p>

<pre class="lang-css">
@container card (inline-size &gt; 30em) {
  @container style(--responsive: true) {
    /* <span class="comment">
~style群
◎
styles
</span> */
  }
}
</pre>

<div>
<p>
上の~style群は、
~AND↓ を満たす要素に限り，適用されることになる：
</p>
<ul>
	<li>
次を満たす先祖~容器が在る
⇒
［
"`card^v" と命名された
］~AND［
`inline-size$d 条件を満たす
］
</li>
	<li>
`style()$css 条件を満たす先祖~容器が在る
</li>
</ul>
◎
The styles above will only be applied if there is both an ancestor container named "card" that meets the inline-size condition, and an ancestor container meeting the style condition.
</div>
</div>

<p>
大域的な名前を定義している`~at-規則$
— `keyframes$at／ `font-face$at ／ `layer$at など —
は、
`容器~query$の内側で定義された場合でも，当の~query条件により拘束されない。
◎
Global, name-defining at-rules such as @keyframes or @font-face or @layer that are defined inside container queries are not constrained by the container query conditions.
</p>

		</section>
		<section id="animated-containers">
<h3 title="Animated Containers">5.5. ~animateされる容器</h3>

<p>
`容器~query$の評価における変化は、
`~style変化~event$の一部を成すモノトスル
— 当の変化が`~animation効果により生じた＠~WANIM#effect-value$ときでも。
◎
A change in the evaluation of a container query must be part of a style change event, even when the change occurred because of animation effects.
</p>

<div class="example">
<p>
容器
【この例では `#container^css 】
の同胞である要素
【この例では `#sibling^css 】
に対する遷移は、
当の容器の~sizeに間接的に影響し得る
— その結果，容器~queryの評価が変化すると、
【容器~内の要素（この例では `#inner^css ）に対し】
`~style変化~event$を誘発する：
◎
A transition on a sibling element can indirectly affect the size of a container, triggering style change events whenever container queries change their evaluation as a result:
</p>

<pre class="lang-html">
&lt;main&gt;
  &lt;div id=container&gt;
    &lt;div id=inner&gt;Inner&lt;/div&gt;
  &lt;/div&gt;
  &lt;div id=sibling&gt;Sibling&lt;/div&gt;
&lt;/main&gt;
</pre>

<pre class="lang-css">
main {
  display: flex;
  width: 300px;
}

#container {
  container-type: inline-size;
  flex: 1;
}

/* <span class="comment">
`width^p の解決d値は初期~時は 200px になるが、
`#sibling^css に対する遷移が進捗するに伴い変化する。
◎
Resolved width is initially 200px, but changes as the transition on #sibling progresses.
</span> */
#inner {
  transition: 1s background-color;
  background-color: tomato;
}

/* <span class="comment">
この容器~queryの評価が変化したときは、
`#inner^css の `background-color^p に対する遷移を開始させる【！must】。
◎
When this container query starts (or stops) applying, a transition must start on background-color on #inner.
</span> */
@container (width &lt;= 150px) {
  #inner {
    background-color: skyblue;
  }
}

#sibling {
  width: 100px;
  transition: width 1s;
}

#sibling:hover {
  width: 200px;
}
</pre>

<div>
◎
&lt;main&gt;
  &lt;div id=container&gt;
    &lt;div id=inner&gt;Inner&lt;/div&gt;
  &lt;/div&gt;
  &lt;div id=sibling&gt;Sibling&lt;/div&gt;
&lt;/main&gt;
</div>
</div>

<p>
`容器~query長さ単位$に~~起因する`算出d値$における変化も，
`~style変化~event$の一部を成すモノトスル。
◎
Changes in computed values caused by container query length units must also be part of a style change event.
</p>

		</section>
	</section>
	<section id="container-features">
<h2 title="Container Features">6. 容器~特能</h2>

<p>
`容器~特能@
（ `container feature^en ）は、
`~query容器$を成す特有な側面を~queryする。
◎
A container feature queries a specific aspect of a query container.
</p>

<p>
`容器~特能$は、
`真偽-文脈$において評価するときは，`媒体~特能$と同じ規則を利用する。
◎
Container features use the same rules as media features when evaluating in a boolean context.
</p>

		<section id="size-container">
<h3 title="Size Container Features">6.1. ~size容器~特能</h3>

<p>
`容器~size~query@
（ `container size query^en ）は、
`~query容器$の`首要~box$の~sizeを~queryすることを許容する。
それは、［
個々の`~size特能$による真偽-条件
］たちが成す組合nである。
個々の
`~size特能@
（ `size-feature$t ）は、
当の`~query容器$を成す単独の［
特定の［
寸法に関する特能
］］を~queryする。
`size-feature@t
の構文は、
`媒体~特能$ `mediaqueries-5$r 用のそれと同じであり，［
特能~名, 比較子, 値
］からなる。
各`~size特能$を`容器~size~query$に組合せる真偽-［
構文, 論理
］は、
`~CSS特能~query$用のそれと同じである。
（ `supports$at を見よ。 `css-conditional-3$r ）
◎
A container size query allows querying the size of the query container’s principal box. It is a boolean combination of individual size features (&lt;size-feature&gt;) that each query a single, specific dimensional feature of the query container. The syntax of a &lt;size-feature&gt; is the same as for a media feature: a feature name, a comparator, and a value. [mediaqueries-5] The boolean syntax and logic combining size features into a size query is the same as for CSS feature queries. (See @supports. [css-conditional-3])
</p>

<div>
<p>
所与の`~query容器$ %容器 用に`~size特能$ %特能 を評価した結果は、
%容器 が ~AND↓ を満たさない場合には， `未知^i になる：
</p>
<ul>
	<li>
%容器 の`首要~box$は、
`~layout封込め~box$である
</li>
	<li>
%容器 は、
%特能 【！`容器~size~query$】に関連な軸において %特能 【が~queryする寸法】を~supportする
</li>
</ul>
◎
If the query container does not have a principal box, or the principal box is not a layout containment box, or the query container does not support container size queries on the relevant axes, then the result of evaluating the size feature is unknown.
</div>

<div>
<p>
所与の`~query容器$ %容器 用の`容器~query$を成す各~条件【すなわち， `size-feature$t 】内の：
</p>
<ul>
	<li>
<p>
`相対~長さ単位$（`容器~query長さ単位$を含む）は、
%容器 における当の単位を伴う値の`算出d値$に基づいて評価される。
</p>

<p class="note">注記：
これは、
`媒体~query$内の相対~単位に対する取扱いとは異なる。
</p>
	</li>
	<li>
<p>
【 `var$f により参照される】`~custom~prop$は、
%容器 における当の~propの`算出d値$に基づいて評価される。
</p>

<p class="note">注記：
`~custom~prop$による`代入＠~CSSVAL5#substitute-arbitrary-substitution-function$の結果が当の`~size特能$用には妥当でない値になる場合、
他の妥当でない特能~値と同じに取扱われ，当の~size特能を評価した結果は `未知^i になる。
</p>
	</li>
	<li>
`~tree計数~関数＠~CSSVAL5#tree-counting$ `CSS-VALUES-5$r は、
%容器 【！容器~要素】を~~基準に評価される。
</li>
</ul>

◎
Relative length units (including container query length units) and custom properties in container query conditions are evaluated based on the computed values of the query container.
◎
Tree counting functions (CSS Values 5 § 9 Tree Counting Functions: the sibling-count() and sibling-index() notations) are evaluated against the container element.
◎
Note: This is different from the handling of relative units in media queries.
◎
Note: If custom property substitution results in an invalid value for the size feature, it is handled the same as other invalid feature values, and the result of the size feature is unknown.
</div>

<div class="example">
<p>
例えば， `font-size^p が互いに異なる`~query容器$たちは、
`em$u 単位に基づく~queryを各自の自前の `font-size^p に相対的に評価することになる：
◎
For example, query containers with different font-sizes will evaluate em-based queries relative to their own font sizes:
</p>

<pre class="lang-css">
aside, main {
  container-type: inline-size;
}

aside { font-size: 16px; }
main { font-size: 24px; }

@container (width &gt; 40em) {
  h2 { font-size: 1.5em; }
}
</pre>

<p>
この~query条件~内で利用された値 `40em^v は、
関連な`~query容器$の `font-size$p の`算出d値$に相対的になる
— この~query条件は：
◎
The 40em value used in the query condition is relative to the computed value of font-size on the relevant query container:
</p>
<ul>
	<li>
`aside^e の内側にある `h2^e 用には、
容器の `width$d が `640px^v を上回るとき `真^i になる。
◎
For any h2 inside aside, the query condition will be true above 640px.
</li>
	<li>
`main^e の内側にある `h2^e 用には、
容器の `width$d が `960px^v を上回るとき `真^i になる。
◎
For any h2 inside main, the query condition will be true above 960px.
</li>
</ul>
</div>

<div class="example">
<p>
類似に，`~query容器$は、
`var$f に基づく~queryを自前の`~custom~prop$の`算出d値$に相対的に評価することになる：
◎
Similarly, query containers will evaluate var()-based queries relative to their own computed value of the custom property:
</p>

<pre class="lang-css">
aside, main {
  container-type: inline-size;
}

aside { --query: 300px; }
main { --query: 500px; }

@container (width &gt; var(--query)) {
  h2 { font-size: 1.5em; }
}
</pre>

<p>
この~query条件に利用された `var(--query)^v には、
関連な`~query容器$の `--query^p `~custom~prop$の`算出d値$が代入される
— この~query条件は：
◎
The var(--query) value used in the query condition is substituted with the computed value of the --query custom property on the relevant query container:
</p>

<ul>
	<li>
`aside^e の内側にある `h2^e 用には、
算出d値が `300px^v を上回るとき `真^i になる。
◎
For any h2 inside aside, the query condition will be true above 300px.
</li>
	<li>
`main^e の内側にある `h2^e 用には、
算出d値が `500px^v を上回るとき `真^i になる。
◎
For any h2 inside main, the query condition will be true above 500px.
</li>
</ul>
</div>

			<section id="width">
<h4 title="Width: the width feature">6.1.1. 横幅： `width^d 特能</h4>

◎述 `width@d
◎用 `container$at
◎値 `length$t
◎型 範囲
◎表終

<p>
`容器~特能$ `width$d は、
`~query容器$の`内容~box$の`横幅$を~queryする。
◎
The width container feature queries the width of the query container’s content box.
</p>

			</section>
			<section id="height">
<h4 title="Height: the height feature">6.1.2. 縦幅： `height^d 特能</h4>

◎述 `height@d
◎用 `container$at
◎値 `length$t
◎型 範囲
◎表終

<p>
`容器~特能$ `height$d は、
`~query容器$の`内容~box$の`縦幅$を~queryする。
◎
The height container feature queries the height of the query container’s content box.
</p>

			</section>
			<section id="inline-size">
<h4 title="Inline-size: the inline-size feature">6.1.3. 行内-~size： `inline-size^d 特能</h4>

◎述 `inline-size@d
◎用 `container$at
◎値 `length$t
◎型 範囲
◎表終

<p>
`容器~特能$ `inline-size$d は、［
`~query容器$の`行内-軸$における，
`~query容器$の`内容~box$の`~size$
］を~queryする。
◎
The inline-size container feature queries the size of the query container’s content box in the query container’s inline axis.
</p>

			</section>
			<section id="block-size">
<h4 title="Block-size: the block-size feature">6.1.4. 塊~size： `block-size^d 特能</h4>

◎述 `block-size@d
◎用 `container$at
◎値 `length$t
◎型 範囲
◎表終

<p>
`容器~特能$ `block-size$d は、［
`~query容器$の`塊-軸$における，`~query容器$の`内容~box$の`~size$
］を~queryする。
◎
The block-size container feature queries the size of the query container’s content box in the query container’s block axis.
</p>

			</section>
			<section id="aspect-ratio">
<h4 title="Aspect-ratio: the aspect-ratio feature">6.1.5. 縦横比： `aspect-ratio^d 特能</h4>

◎述 `aspect-ratio@d
◎用 `container$at
◎値 `ratio$t
◎型 範囲
◎表終

<p>
`容器~特能$ `aspect-ratio$d は、［
`容器~特能$ `width$d の値
］が成す［
`容器~特能$ `height$d の値
］に対する比率†を~queryする【！is defined as】。
◎
The aspect-ratio container feature is defined as the ratio of the value of the width container feature to the value of the height container feature.
</p>

<p class="trans-note">【†
`範囲~文脈$においては、
~CSSの`比率$と同様に，前者を後者で除算した結果に基づいて比較されよう。
】</p>

			</section>
			<section id="orientation">
<h4 title="Orientation: the orientation feature">6.1.6. 方位： `orientation^d 特能</h4>

◎述 `orientation@d
◎用 `container$at
◎値 `portrait$vd | `landscape$vd
◎型 離散的
◎表終

<p>
`容器~特能$ `orientation$d は、［
次が満たされるならば
`portrait@vd
／
~ELSE_
`landscape@vd
］になる
⇒
`容器~特能$ `height$d の値 ~GTE `容器~特能$ `width$d の値
◎
portrait
• The orientation container feature is portrait when the value of the height container feature is greater than or equal to the value of the width container feature.
◎
landscape
• Otherwise orientation is landscape.
</p>

			</section>
		</section>
		<section id="style-container">
<h3 title="Style Container Features">6.2. ~style容器~特能</h3>

<p>
`容器~style~query@
（ `container style query^en ）は、
`~query容器$の`算出d値$を~queryすることを許容する。
それは、［
個々の`~style特能$による真偽-条件
］たちが成す組合nである。
各
`~style特能@
（ `style-feature$t ）は、
`~query容器$の単独の特定の~propを~queryする。
`style-feature@t
の構文は、
次に挙げるいずれかと同じになる
⇒＃
妥当な`宣言$ `CSS-SYNTAX-3$r 用のそれ／
`~supportされる~CSS~prop$／
`custom-property-name$t
◎
A container style query allows querying the computed values of the query container. It is a boolean combination of individual style features (&lt;style-feature&gt;) that each query a single, specific property of the query container. The syntax of a &lt;style-feature&gt; is either the same as for a valid declaration [CSS-SYNTAX-3], a supported CSS property, or a &lt;custom-property-name&gt;.
</p>

<p>
各`~style特能$による【！Its】~queryを評価した結果は、［
次が満たされるならば `真^i ／
~ELSE_ `偽^i
］になる
⇒
`~query容器$の［
所与の~prop
］の`算出d値$
（それも，`~query容器$を~~基準に`算出-$される）
は、
所与の値に合致する
◎
Its query evaluates to true if the computed value of the given property on the query container matches the given value (which is also computed with respect to the query container), and false otherwise.
</p>

<p>
値を伴わない`~style特能$を評価した結果は、［
次が満たされるならば `真^i 【／~ELSE_ `偽^i】
］になる
⇒
所与の`~prop$用の`算出d値$は，それ用の`初期~値$とは異なる
◎
A style feature without a value evaluates to true if the computed value is different from the initial value for the given property.
</p>

<p>
`容器~style~query$の中で組合された`~style特能$たちに対する真偽-［
構文, 論理
］は、
`~CSS特能~query$用のそれと同じである。 
（ `supports$at を見よ。 `css-conditional-3$r ）
◎
The boolean syntax and logic combining style features into a style query is the same as for CSS feature queries. (See @supports. [css-conditional-3])
</p>

<p>
`略式~prop$を~queryする`~style特能$を評価した結果は、［
次が満たされるならば `真^i ／
~ELSE_ `偽^i
］になる
⇒
各`下位prop$に対し，その`算出d値$は
【所与の値から導出される各~下位prop用の算出d値に】
合致する
◎
Style features that query a shorthand property are true if the computed values match for each of its longhand properties, and false otherwise.
</p>

<p>
`~cascadeに依存する~keyword$
— `revert$v, `revert-layer$v など —
は、
`~style特能$内の値としては妥当でなく，
`容器~style~query$は `偽^i になる。
◎
Cascade-dependent keywords, such as revert and revert-layer, are invalid as values in a style feature, and cause the container style query to be false.
</p>

<p class="note">注記：
上に挙げたものでない，`~cascadeに依存する~keyword$ではない`~CSS全域~keyword$は、
他の値と同じく，当の`~query容器$を~~基準に`算出d値$される。
◎
Note: The remaining non-cascade-dependent CSS-wide keywords are computed with respect to the query container, the same as other values.
</p>

		</section>
		<section id="scroll-state-container">
<h3 title="Scroll State Container Features">6.3. ~scroll状態~容器~特能</h3>

<p>
`容器~scroll状態~query@
は、
~scroll位置に依存する状態~用に容器を~queryすることを許容する。
それは、［
個々の`~scroll状態~特能$による真偽-条件
］たちが成す組合nである。
個々の
`~scroll状態~特能@
（ `scroll-state-feature$t ）は、
当の`~query容器$を成す単独の特能を~queryする。
`scroll-state-feature@t
の構文は、
`媒体~特能$用のそれと同じであり，［
特能~名, 比較子, 値
］からなる。
◎
A container scroll-state query allows querying a container for state that depends on scroll position. It is a boolean combination of individual scroll-state features (&lt;scroll-state-feature&gt;) that each query a single feature of the query container. The syntax of a &lt;scroll-state-feature&gt; is the same as for a media feature: a feature name, a comparator, and a value.
</p>

<p>
`~scroll状態~特能$には、
`~scroll容器$の状態に合致するもの（例： `scrollable$d 特能）も，［
要素のうち，その先祖`~scroll容器$の`~scrollport$の~scroll位置により影響されるもの
］の状態に合致すもの（例： `snapped$d ）もある。
◎
Scroll-state features can either match state of the scroller itself, or an element that is affected by the scroll position of an ancestor scroll container’s scrollport. An example of the former is the scrollable feature, snapped the latter.
</p>

			<section id="updating-scroll-state">
<h4 title="Updating Scroll State">6.3.1. ~scroll状態の更新-法</h4>

<p>
~scroll状態は、
~layoutにおける循環依存を生じさせ得る
— ~scroll状態を~queryした結果に応じて~styleが変化して，
それに伴い~layoutが変化すると~scroll状態~変化へ至らせ得るので。
◎
Scroll state may cause layout cycles since queried scroll state may cause style changes, which may lead to scroll state changes as a result of layout.
</p>

<p>
そのような循環依存を避けるため、
`~layout後の状態を~snapshotする手続き$ %手続き を次に従うように走らすとする：
◎
To avoid such layout cycles, scroll-state query containers update their current state as part of run snapshot post-layout state steps＼
</p>
<ul>
	<li>
<p>
%手続き は、
~HTMLの`~event~loop処理~model$における特定の箇所たち†に限り，走らす。
◎
which is only run at specific points in the HTML event loop processing model.
</p>

<p class="trans-note">【†
一箇所とは限らず，正確な箇所も指定されていないが、
少なくとも一箇所は［
`描画を更新する段＠~WAPI#update-the-rendering$の中の`文書の~scroll手続き＠~CSSOMVIEW#document-run-the-scroll-steps$を走らす段
］に近いどこかになろう。
】</p>
	</li>
	<li>
%手続き を成す一部として、
各 ( `容器~scroll状態~query$用の【！`scroll-state$v 】`~query容器$ %容器 )
に対し，
%容器 の現在の~scroll状態を更新する。
◎
When asked to run snapshot post-layout state steps, update the current state of every scroll-state query container.＼
</li>
	<li>
%手続き により~snapshotされた状態は、
次回に %手続き が走るまで，どの［
~style, ~layout
］更新にも利用されることになる。
◎
This snapshotted state will be used for any style and layout updates until the next time these steps are run.
</li>
</ul>

			</section>
			<section id="stuck">
<h4 title="Sticky positioning: the stuck feature">6.3.2. 張付き位置決め： `stuck^d 特能</h4>

◎述 `stuck@d
◎用 `container$at
◎値 `none$vd | `top$vd | `right$vd | `bottom$vd | `left$vd | `block-start$vd | `inline-start$vd | `block-end$vd | `inline-end$vd
◎型 離散的
◎表終

<p>
`容器~特能$ `stuck$d は、
`張付きに位置され$た【！`sticky$v な有位置な】容器が，所与の辺に関して［
`張付き~view矩形$の内側に居続けるよう視覚的にズラされたかどうか
］を~queryする。
論理-~keyword【！辺】は、
当の`~query容器$
— 以下 %容器 —
の［
`direction$p, `writing-mode$p
］に基づいて，物理-~keyword【！辺】へ対応付けられる。
%容器 は`張付きに位置され$ていない場合，合致する値は無い。
◎
The stuck container feature queries whether a sticky positioned container is visually shifted to stay inside the sticky view rectangle for the given edge. The logical edges map to physical based on the direction and writing-mode of the query container. None of the values match if the query container is not sticky positioned.
</p>

<p>
2 個の値に同時に合致することは、
それらが異なる軸に対応する場合はアリだが，
それらが同じ軸の対~辺どうしに対応する場合にはアリでない。
◎
It is possible for two values from opposite axes to match at the same time, but not for opposite edges along the same axis.
</p>

<div class="example">
<p>
次は合致し得る：
◎
May match:
</p>
<pre class="lang-css">
@container scroll-state((stuck: top) and (stuck: left)) { ... }
</pre>

<p>
次は決して合致しない：
◎
Will never match:
</p>

<pre class="lang-css">
@container scroll-state((stuck: left) and (stuck: right)) { ... }
</pre>
</div>

<dl class="valdef">
	<dt>`none@vd</dt>
	<dd>
%容器 は、
どの方向へもズラされていない。
◎
The sticky container is not shifted in any direction.
</dd>

	<dt>`top@vd</dt>
	<dd>
%容器 は、
上端~辺の内側に居続けるようズラされた。
◎
The sticky container is shifted to stay inside the top edge.
</dd>

	<dt>`right@vd</dt>
	<dd>
%容器 は、
右端~辺の内側に居続けるようズラされた。
◎
The sticky container is shifted to stay inside the right edge.
</dd>

	<dt>`bottom@vd</dt>
	<dd>
%容器 は、
下端~辺の内側に居続けるようズラされた。
◎
The sticky container is shifted to stay inside the bottom edge.
</dd>

	<dt>`left@vd</dt>
	<dd>
%容器 は、
左端~辺の内側に居続けるようズラされた。
◎
The sticky container is shifted to stay inside the left edge.
</dd>

	<dt>`block-start@vd</dt>
	<dd>
%容器 は、
`塊-始端$辺の内側に居続けるようズラされた。
◎
The sticky container is shifted to stay inside the block-start edge.
</dd>

	<dt>`inline-start@vd</dt>
	<dd>
%容器 は、
`行内-始端$辺の内側に居続けるようズラされた。
◎
The sticky container is shifted to stay inside the inline-start edge.
</dd>

	<dt>`block-end@vd</dt>
	<dd>
%容器 は、
`塊-終端$辺の内側に居続けるようズラされた。
◎
The sticky container is shifted to stay inside the block-end edge.
</dd>

	<dt>`inline-end@vd</dt>
	<dd>
%容器 は、
`行内-終端$辺の内側に居続けるようズラされた。
◎
The sticky container is shifted to stay inside the inline-end edge.
</dd>
</dl>

			</section>
			<section id="snapped">
<h4 title="Scroll snapping: the snapped feature">6.3.3. ~scroll留ng： `snapped^d 特能</h4>

◎述 `snapped@d
◎用 `container$at
◎値 `none$vd | `x$vd | `y$vd | `block$vd | `inline$vd | `both$vd
◎型 離散的
◎表終

<p>
`容器~特能$ `snapped$d は、
所与の軸において，［
`留め~target$は、
その`留め容器$に`留められ$るように
【当の`~query容器$ — 以下 %容器 — は、その`留め容器$である`~scroll容器$  — 以下 %~scroll容器 — に`留められ$る`留め~target$に】
［
なる／なり得る
］かどうか
］を~queryする。
すなわち、
`留め~target$のうち
【 `scrollsnapchange$et ではなく】
`scrollsnapchanging$et ~eventが発火されるものに合致する。
◎
The snapped container feature queries whether a snap target is, or would be, snapped to its snap container, in the given axis. That is, it matches any snap target that the scrollsnapchanging event is fired for.
</p>

<dl class="valdef">
	<dt>`none@vd</dt>
	<dd>
%容器 は、
【 %~scroll容器 用の】`留め~target$でない。
◎
The query container is not a snap target.
</dd>

	<dt>`x@vd</dt>
	<dd>
%容器 は、
%~scroll容器 用の横方向における`留め~target$である。
◎
snapped container feature matches x if the query container is a horizontal snap target for its scroll container.
</dd>

	<dt>`y@vd</dt>
	<dd>
%容器 は、
%~scroll容器 用の縦方向における`留め~target$である。
◎
snapped container feature matches y if the query container is a vertical snap target for its scroll container.
</dd>

	<dt>`block@vd</dt>
	<dd>
%容器 は、
%~scroll容器 用の［
%~scroll容器 の`塊-軸$方向
］における`留め~target$である。
◎
snapped container feature matches block if the query container is a snap target for its scroll container. in the block direction of the snap container.
</dd>

	<dt>`inline@vd</dt>
	<dd>
%容器 は、
%~scroll容器 用の［
%~scroll容器 の`行内-軸$方向
］における`留め~target$である。
◎
snapped container feature matches inline if the query container is a snap target for its scroll container in the inline direction of the snap container.
</dd>

	<dt>`both@vd</dt>
	<dd>
%容器 は、
%~scroll容器 用の［
横方向かつ縦方向
］における`留め~target$である。
◎
snapped container feature matches both if the query container is a snap target for its scroll container in both directions of the snap container.
</dd>
</dl>

			</section>
			<section id="scrollable">
<h4 title="Scrollable: the scrollable feature">6.3.4. ~scroll可能： `scrollable^d 特能</h4>

◎述 `scrollable@d
◎用 `container$at
◎値 `none$vd | `top$vd | `right$vd | `bottom$vd | `left$vd | `block-start$vd | `inline-start$vd | `block-end$vd | `inline-end$vd | `x$vd | `y$vd | `block$vd | `inline$vd
◎型 離散的
◎表終

<p>
`容器~特能$ `scrollable$d は、
`~scroll容器$を成す ある内容のうち［
`~scroll可能な~overflow矩形$の一部を成す
］かつ［
利用者が~scrollすることにより到達-可能である
］ものが，所与の方向において【~overflowして】切取られたかどうかを~queryする。
すなわち、
`scrollable$d は［
`hidden$v な容器／
`到達-不能な~scroll可能な~overflow領域$
］用には合致しない。
◎
The scrollable container feature queries whether a scroll container has clipped scrollable overflow rectangle content in the given direction which is reachable through user initiated scrolling. That is, scrollable does not match for a hidden container, nor for a negative scrollable overflow region.
</p>

<p>
論理-~keyword【！値】は、
当の`~query容器$
— 以下 %容器 —
の［
`direction$p, `writing-mode$p
］に基づいて物理-~keyword【！値】へ対応付けられる。
%容器 は`~scroll容器$でない場合，合致する値は無い。
◎
The logical values map to physical based on the direction and writing-mode of the query container. None of the values match if the container is not a scroll container.
</p>

<dl class="valdef">
	<dt>`none@vd</dt>
	<dd>
%容器 には、
どの方向にも`~scroll可能な~overflow$は無い。
◎
The scroll container does not have scrollable overflow in any direction. 
</dd>

	<dt>`top@vd</dt>
	<dd>
%容器 には、
上端~辺を過ぎた`~scroll可能な~overflow$が有る。
◎
The scroll container has scrollable overflow past the top edge.
</dd>

	<dt>`right@vd</dt>
	<dd>
%容器 には、
右端~辺を過ぎた`~scroll可能な~overflow$が有る。
◎
The scroll container has scrollable overflow past the right edge.
</dd>

	<dt>`bottom@vd</dt>
	<dd>
%容器 には、
下端~辺を過ぎた`~scroll可能な~overflow$が有る。
◎
The scroll container has scrollable overflow past the bottom edge.
</dd>

	<dt>`left@vd</dt>
	<dd>
%容器 には、
右端~辺を過ぎた`~scroll可能な~overflow$が有る。
◎
The scroll container has scrollable overflow past the left edge.
</dd>

	<dt>`block-start@vd</dt>
	<dd>
%容器 には、
`塊-始端$辺を過ぎた`~scroll可能な~overflow$が有る。
◎
The scroll container has scrollable overflow past the block-start edge.
</dd>

	<dt>`inline-start@vd</dt>
	<dd>
%容器 には、
`行内-始端$辺を過ぎた`~scroll可能な~overflow$が有る。
◎
The scroll container has scrollable overflow past the inline-start edge.
</dd>

	<dt>`block-end@vd</dt>
	<dd>
%容器 には、
`塊-終端$辺を過ぎた`~scroll可能な~overflow$が有る。
◎
The scroll container has scrollable overflow past the block-end edge.
</dd>

	<dt>`inline-end@vd</dt>
	<dd>
%容器 には、
`行内-終端$辺を過ぎた`~scroll可能な~overflow$が有る。
◎
The scroll container has scrollable overflow past the inline-end edge.
</dd>

	<dt>`x@vd</dt>
	<dd>
%容器 には、
横方向に`~scroll可能な~overflow$が有る。
◎
The scroll container has horizontally scrollable overflow.
</dd>

	<dt>`y@vd</dt>
	<dd>
%容器 には、
縦方向に`~scroll可能な~overflow$が有る。
◎
The scroll container has vertically scrollable overflow.
</dd>

	<dt>`block@vd</dt>
	<dd>
%容器 には、
`塊-軸$方向に`~scroll可能な~overflow$が有る。
◎
The scroll container has scrollable overflow in its block direction.
</dd>

	<dt>`inline@vd</dt>
	<dd>
%容器 には、
`行内-軸$方向に`~scroll可能な~overflow$が有る。
◎
The scroll container has scrollable overflow in its inline direction
</dd>
</dl>

			</section>
		</section>
	</section>
	<section id="container-lengths">
<h2 title="Container Relative Lengths: the cqw, cqh, cqi, cqb, cqmin, cqmax units">7. 容器に相対的な長さ単位： `cqw^u, `cqh^u, `cqi^u, `cqb^u, `cqmin^u, `cqmax^u</h2>

<p>
`容器~query長さ単位@
（ `container query length unit^en ）は、
`~query容器$の寸法に相対的な長さを指定する。
~stylesheetにて`容器~query長さ単位$を利用すれば、
~componentを ある`~query容器$から別のそれへ移動するのも容易になる。
◎
Container query length units specify a length relative to the dimensions of a query container. Style sheets that use container query length units can more easily move components from one query container to another.
</p>

<p>
`容器~query長さ単位$は：
◎
The container query length units are:
</p>

<div>
<table class="data">
<caption>
容器~単位たちの規範的でない要約
</caption>
<thead>
<tr><th>単位
<th>何に相対的か
</thead><tbody>

<tr><td>`cqw^u
<td>`~query容器$の`横幅$の 1%

<tr><td>`cqh^u
<td>`~query容器$の`縦幅$の 1%

<tr><td>`cqi^u
<td>`~query容器$の`行内~size$の 1%

<tr><td>`cqb^u
<td>`~query容器$の`塊~size$の 1%

<tr><td>`cqmin^u
<td>`cqi^u, `cqb^u のうち小さい方の値

<tr><td>`cqmax^u
<td>`cqi^u, `cqb^u のうち大きい方の値
</tbody></table>
◎
Informative Summary of Container Units unit 	relative to
cqw 	1% of a query container’s width
cqh 	1% of a query container’s height
cqi 	1% of a query container’s inline size
cqb 	1% of a query container’s block size
cqmin 	The smaller value of cqi or cqb
cqmax 	The larger value of cqi or cqb
</div>

<p>
各~要素に対し，
`容器~query長さ単位$は、
当の単位に関連な軸（たち）に対する`容器~size~query$として評価される。
各~軸に対し、
`~query容器$は，
当の軸において当の`容器~size~query$を受容する先祖~容器のうち最も近いものになる。
適格な`~query容器$として可用なものは無い場合、
当の軸~用には`小さい表示域~size$を利用する。
◎
For each element, container query length units are evaluated as container size queries on the relevant axis (or axes) described by the unit. The query container for each axis is the nearest ancestor container that accepts container size queries on that axis. If no eligible query container is available, then use the small viewport size for that axis.
</p>

<p class="note">注記：
事例によっては、
同じ要素~上の［
`cqi^u 単位, `cqb^u 単位
］は，異なる関係にある`~query容器$に対し評価されることになる。
類似に，［
`cqmin^u 単位／ `cqmax^u 単位
］は、［
`cqi^u, `cqb^u
］単位が異なる`~query容器$から来ているときでも，それらの寸法のうち［
小さい方／大きい方
］を表現する。
◎
Note: In some cases cqi and cqb units on the same element will evaluate in relation to different query containers. Similarly, cqmin and cqmax units represent the larger or smaller of the cqi and cqb units, even when those dimensions come from different query containers.
</p>

<p>
子~要素が継承するのは、
その親に指定されたとおりの相対的な値ではなく，`算出d値$である。
◎
Child elements do not inherit the relative values as specified for their parent; they inherit the computed values.
</p>

<div class="example">
<p>
作者は、
`容器~query長さ単位$に対し適切な`~query容器$が有ることを確保できる
— それを［
同じ `container-type$p に依拠する`容器~query$
］の内側で適用することにより。
~customな~fallback値は、
`容器~query$の外側で定義できる：
◎
Authors can ensure that container query length units have an appropriate query container by applying them inside a container query that relies on the same container-type. Custom fallback values can be defined outside the container query:
</p>
<pre class="lang-css">
/* <span class="comment">
~fallback値は、
封込めには依拠しない
◎
The fallback value does not rely on containment
</span> */
h2 { font-size: 1.2em; }

@container (inline-size &gt;= 0px) {
  /* <span class="comment">
`inline-size$d 容器が可用なときに限り適用する
◎
only applies when an inline-size container is available
</span> */
  h2 { font-size: calc(1.2em + 1cqi); }
}
</pre>
</div>

	</section>
	<section id="apis">
<h2 title="APIs">8. ~API</h2>

		<section id="the-csscontainerrule-interface">
<h3 title="The CSSContainerRule interface">8.1. `CSSContainerRule^I ~interface</h3>

<p>
`CSSContainerRule$I ~interfaceは、
ある `container$at 規則を表現する。
◎
The CSSContainerRule interface represents a @container rule.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSContainerRule@I : `CSSConditionRule$I {
    readonly attribute `CSSOMString$ `containerName$m;
    readonly attribute `CSSOMString$ `containerQuery$m;
};
</pre>

<div class="algo">
<p>
`CSSContainerRule$I に特有な［
`CSSConditionRule^I の `conditionText$m 取得子~手続き
］は、次に従うものと定義される：
</p>
<ol>
	<li>
%名前 ~LET コレの `containerName$m 属性の値
</li>
	<li>
%~query ~LET コレの `containerQuery$m 属性の値
</li>
	<li>
~IF［
%名前 ~EQ 空~文字列
］
⇒
~RET %~query
</li>
	<li>
~RET « %名前, %~query » を~spaceで`連結する$
</li>
</ol>
◎
conditionText of type CSSOMString (CSSContainerRule-specific definition for attribute on CSSConditionRule)
• The conditionText attribute (defined on the CSSConditionRule parent rule), on getting, must return a value as follows:
•• The @container rule has an associated &lt;container-name&gt;
•••  The result of getting the containerName and containerQuery attributes, joined by a single whitespace.
•• Otherwise
••• The result of getting the containerQuery attribute.
</div>

<div class="algo">
`containerName@m
取得子~手続き
⇒
~RET ［
コレが表現する `container$at 規則に `container-name$t は指定されたならば それを直列化した結果 ／
~ELSE_ 空~文字列
］
◎
containerName of type CSSOMString
• The containerName attribute, on getting, must return a value as follows:
• The @container rule has an associated &lt;container-name&gt;
•• The result of serializing that &lt;container-name&gt;.
• Otherwise
•• An empty string.
</div>

<div class="algo">
`containerQuery@m
取得子~手続きは
⇒
~RET コレが表現する `container$at 規則に指定された `container-query$t
— この結果は、［
この仕様の適合t実装
（［
この仕様~内の `general-enclosed$t 拡張能の仕組みにより許容される将来の拡張
］を実装する実装も含む）
において，指定された~queryと同じ結果に評価される
］よう，論理的な単純~化を伴わないとする
— 言い換えれば、
~token~streamの単純~化は許容されるが
（空白~列は［
省略可能であることが既知な事例では省略する／
他の場合は 1 個の~spaceに~~縮約する
］），
論理的な単純~化
（不要な括弧の除去, 評価-時の結果に基づく単純~化など）は、
許容されない。
◎
containerQuery of type CSSOMString
• The containerQuery attribute, on getting, must return the &lt;container-query&gt; that was specified, without any logical simplifications, so that the returned query will evaluate to the same result as the specified query in any conformant implementation of this specification (including implementations that implement future extensions allowed by the &lt;general-enclosed&gt; extensibility mechanism in this specification). In other words, token stream simplifications are allowed (such as reducing whitespace to a single space or omitting it in cases where it is known to be optional), but logical simplifications (such as removal of unneeded parentheses, or simplification based on evaluating results) are not allowed.
</div>

<p class="issue">
容器~queryは、
`matchContainer()^m ~methodを有するべきである。
これは、［
`matchMedia()$m, `MediaQueryList$I ~interface
］上で~model化されることになるが、
`Window^I ではなく `Element^I に適用される。
それは、
~layout~sizeを測定するときは `ResizeObserver＠~CSSWG/resize-observer-1/#resizeobserver$I と類似に挙動するが，追加的な容器~query構文と特能を供する。
`6205$issue
◎
Container Queries should have a matchContainer method. This will be modeled on matchMedia() and the MediaQueryList interface, but applied to Elements rather than the Window. When measuring layout sizes, it behaves Similar to resizeObserver, but it provides the additional Container Query syntax and features. [Issue #6205]
</p>

		</section>
	</section>
	<section id="security">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
この文書に対し提起された~securityの課題は無い。
◎
No security issues have been raised against this document
</p>

	</section>
	<section id="privacy">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
［
`font-tech^f, `font-format^f
］関数は、
利用者の~softwareについての情報を供し得る
— その~versionや［
ある種の特能を可能化するか不能化する既定でない設定の下で稼働しているかどうか
］など。
この情報は：
◎
The font-tech() and font-format() functions may provide information about the user’s software such as its version and whether it is running with non-default settings that enable or disable certain features.
</p>
<ul>
	<li>
他の~APIを通しても決定され得る。
しかしながら、
この仕様における特能は，この情報が~Web上に公開される仕方の一つを成す。
◎
This information can also be determined through other APIs. However, the features in this specification are one of the ways this information is exposed on the Web.
</li>
	<li>
集成した上で利用者の`指紋収集＠https://www.w3.org/2001/tag/doc/unsanctioned-tracking/$の正確度を改善するためにも利用され得る。
◎
This information can also, in aggregate, be used to improve the accuracy of fingerprinting of the user.
</li>
</ul>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<dl>
	<dt id="changes-20241105">
`2024 年 11月 5日 作業草案＠~TR/2024/WD-css-conditional-5-20241105/$
からの変更点
◎
Changes since the Working Draft of 5 November 2024
</dt>
	<dd>
寸法に関する~query容器には、
もはや`~layout封込め$を適用しない【代わりに，`独立な整形~文脈$を確立する】ようにした。
（ `pull #10544＠https://github.com/w3c/csswg-drafts/pull/10544$ ）
◎
Dimensional query containers no longer apply layout containment
</dd>

	<dt id="changes-20240723/">
`2024 年 7月 23日 作業草案＠~TR/2021/WD-css-conditional-5-20240723/$
からの変更点
◎
Changes since the Working Draft of 23 July 2024
</dt>
	<dd>
［
`stuck$d, `snapped$d, `scrollable$d
］特能~用の値として【！scroll-state() features】~keyword `none^v を追加した。
（ `pull #10874＠https://github.com/w3c/csswg-drafts/pull/10874$ ）
◎
Add none-keywords to scroll-state() features (#10874)
</dd>
	<dd>
`container-type$p 用の値として `scroll-state$v を追加した。
［
`stuck$d, `snapped$d, `scrollable$d
］特能~用の~queryとして `scroll-state^f を追加した。
（ `6402$issue, `10784$issue, `10796$issue ）
◎
Added container-type:scroll-state, and scroll-state() queries for stuck, snapped, and scrollable features (#6402, #10784, #10796)
</dd>
	<dd>
例を正した
（~~存在しない `container-type:style^p を利用していた）。
◎
Corrected example (there is no container-type:style)
</dd>
	<dd>
`容器~query$は`平坦~tree$を利用するものと指定した。
（ `5984＠~CSSissue/5984#issuecomment-2112977366$issue ）
◎
Specified that container queries use the flat tree (#5984)
</dd>

	<dt id="changes-20211221/">
`2021 年 12月 21日 最初の公な作業草案＠~TR/2021/WD-css-conditional-5-20211221/$
からの変更点
◎
Changes since the First Public Working Draft of 21 December 2021
</dt>
	<dd>
`容器~query$を `CSS-CONTAIN-3$r からこの仕様へ移動した。
（ `10433$issue ）
◎
Moved container queries to this specification, from CSS Contain 3 (#10433)
</dd>
	<dd>
重複していた［
`font-format$t, `font-tech$t
］の定義を除去して，
`CSS-FONTS-4$r から取込むようにした。
（ `8110$issue ）
◎
Imported the definitions of &lt;font-format&gt; and &lt;font-tech&gt; from CSS Fonts 4, rather than duplicating them in this specification (#8110)
</dd>
	<dd>
［
構文解析~algo, ~block生成規則
］に新たな名前を利用するよう更新した。
◎
Updated to use the new parsing algorithm names and block production names
</dd>
	<dd>
`font-format^t の文法~内の誤記を正した。
◎
Corrected a typo in the grammar of &lt;font-format&gt;
</dd>
	<dd>
［
`font-tech^t, `font-format^t
］生成規則~内の余分な~spaceを正した。
（ `7369$issue ）
◎
Corrected extra spaces in the font-tech and font-format productions (#7369 )
</dd>

	<dt id="changes-from-L4">
~level 4 からの追加
◎
Additions since Level 4
</dt>
	<dd>
［
`when$at, `else$at
］を追加した。
◎
Added @when and @else.
</dd>
	<dd>
`~supports~query$を［
`font-tech^f, `font-format^f
］を介する~font能力を表出するよう拡張した。
◎
Extended supports queries to express font capabilities via font-tech() and font-format().
</dd>
	<dd>
`容器~query$を `CSS-CONTAIN-3$r からこの仕様へ移動した。
（この特能の発展に関するさらなる情報は
`CSS-CONTAIN-3$r の `§ 変更点＠~CSSWG/css-contain-3/#changes$も見よ。）
◎
Moved Container Queries from [CSS-CONTAIN-3] to this specification. (See also the CSS Containment 3 § A Changes for more information on the evolution of this feature.)
</dd>
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
［
`when$at, `else$at
］規則は、
`Tab Atkins^en 氏による提案に基づく。
◎
The @when and @else rules are based on a proposal by Tab Atkins.
</p>

<p>
次に挙げる方々からの~commentや これまでの作業に，
および，この仕様に貢献された他の多くの方々に。
◎
</p>

<div lang="en">
Comments and previous work from Adam Argyle, Amelia Bellamy-Royds, Anders Hartvoll Ruud, Brian Kardell, Chris Coyier, Christopher Kirk-Nielsen, David Herron, Eric Portis, Ethan Marcotte, Florian Rivoal, Geoff Graham, Gregory Wild-Smith, Ian Kilpatrick, Jen Simmons, Kenneth Rohde Christiansen, Lea Verou, Martin Auswöger, Martine Dowden, Mike Riethmuller, Morten Stenshorne, Nicole Sullivan, Rune Lillesveen, Scott Jehl Scott Kellum, Stacy Kvernmo, Theresa O’Connor, Una Kravets, and many others have contributed to this specification.
</div>

	</section>
</main></div>
