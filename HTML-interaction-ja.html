<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — User interaction（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'editing',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ー]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'mE':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'a':
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'h':
	text = `<code class="header">${text}</code>`;
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'Key': 
	text = `<kbd><kbd>${key}</kbd></kbd>`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2025-09-30
trans_update:2025-10-01
source_checked:240603
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/interaction.html
	abbr_url:HTMLinteraction
site_nav:uievents,html
nav_prev:HTMLselectors
nav_next:HTMLdnd
trans_1st_pub:2016-11-06


●●class_map
e:element
a:attr
et:event-type
p:property
ps:pseudo
st:attr-state
stS:attr-state
stW:attr-state
aH:attr-state
css:css
v:value
vS:value
vC:value
vW:value
E:error
h:header
M:method

●●tag_map
I:code
m:code
m1:code
mE:code
mb:code
E:code
c:code
e:code
a:code
et:code
st:i
stS:i
stW:i
aH:span
h:code
M:code
p:code
ps:code
css:code
samp:samp
v:code
vS:code
vC:value
vW:code
i:i
kbd:kbd
em:em
cite:cite

●●original_id_map


dom-document-designmode:designMode
	system-focus:tlbc-system-focus
	currently-focused-area-of-a-top-level-traversable:currently-focused-area-of-a-top-level-browsing-context
	current-focus-chain-of-a-top-level-traversable:current-focus-chain-of-a-top-level-browsing-context

●●mdn_urls

closewatcher:API/CloseWatcher
commandevent:API/CommandEvent
	elementcontenteditable:API/ElementContentEditable
toggleevent:API/ToggleEvent
useractivation:API/UserActivation
	visibilitystateentry:API/VisibilityStateEntry

the-accesskey-attribute:HTML/Global_attributes/accesskey
attr-enterkeyhint:HTML/Global_attributes/enterkeyhint
attr-hidden:HTML/Global_attributes/hidden
attr-contenteditable:HTML/Global_attributes/contenteditable
attr-autocapitalize:HTML/Global_attributes/autocapitalize
attr-fe-autofocus:HTML/Global_attributes/autofocus
attr-inputmode:HTML/Global_attributes/inputmode
attr-tabindex:HTML/Global_attributes/tabindex

●●link_map

CEReactions:~HEcustom#cereactions
E.SyntaxError:~WEBIDL#syntaxerror
E.InvalidStateError:~WEBIDL#invalidstateerror

I.AbortSignal:~DOM4#abortsignal
I.CloseWatcher:#closewatcher
I.CloseWatcherOptions:#closewatcheroptions
I.CommandEvent:#commandevent
I.CommandEventInit:#commandeventinit
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.Document:~HTMLdom#document
	→ 文書
I.DocumentOrShadowRoot:~HTMLdom#documentorshadowroot
I.Element:~DOM4#element
	:~DOM4#interface-element
	→ 要素
I.ElementContentEditable:#elementcontenteditable
I.Event:~DOM4#event
	I.Event:~DOM4#interface-event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
	I.EventTarget:~DOM4#interface-eventtarget
I.FocusEvent:~UIEVENTS#focusevent
I.FocusOptions:#focusoptions
I.HTMLOrSVGElement:~HTMLdom#htmlorsvgelement
I.Navigator:~HTMLnavigator#navigator
I.Node:~DOM4#node
	I.Node:~DOM4#interface-node
I.PerformanceEntry:~TIMELINE#dom-performanceentry
I.Selection:~SELECTIONAPI#dom-selection
I.Text:~DOM4#text
	I.Text:~DOM4#interface-text
I.ToggleEvent:#toggleevent
I.ToggleEventInit:#toggleeventinit
I.UserActivation:#useractivation
I.VisibilityStateEntry:#visibilitystateentry
I.Window:~WINDOW#window
~window:~WINDOW#the-window-object

	■DOM
m.isTrusted:~DOM4#dom-event-istrusted
m.bubbles:~DOM4#dom-event-bubbles
m.type:~DOM4#dom-event-type
m.currentTarget:~DOM4#dom-event-currenttarget

m.accessKeyLabel:#dom-accesskeylabel
m.activeElement:#dom-documentorshadowroot-activeelement
m.autocapitalize:#dom-autocapitalize
m.autocorrect:#dom-autocorrect
m.blur:#dom-window-blur
mE.blur:#dom-blur
m.command:#dom-commandevent-command
m.focus:#dom-window-focus
mE.focus:#dom-focus
m.enterKeyHint:#dom-enterkeyhint
m.click:#dom-click
m.contentEditable:#dom-contenteditable
m.hasFocus:#dom-document-hasfocus
m.hidden:#dom-document-hidden
mE.hidden:#dom-hidden
m.isContentEditable:#dom-iscontenteditable
m.inputMode:#dom-inputmode
m.newState:#dom-toggleevent-newstate
m.oldState:#dom-toggleevent-oldstate
m1.source:#dom-toggleevent-source
m.source:#dom-commandevent-source
m.tabIndex:#dom-tabindex
m.visibilityState:#dom-document-visibilitystate
m.writingSuggestions:#dom-writingsuggestions

m.navigator:~HTMLnavigator#dom-window-navigator
m.userActivation:#dom-navigator-useractivation
m.hasBeenActive:#dom-useractivation-hasbeenactive
m.isActive:#dom-useractivation-isactive

m.name:#visibilitystateentry-name
m.entryType:#visibilitystateentry-entrytype
m.startTime:#visibilitystateentry-starttime
m.duration:#visibilitystateentry-duration

	m.execCommand:#execCommand
m.execCommand:~EXEC-COMMAND#execcommand%28%29
m.queryCommandEnabled:~EXEC-COMMAND#dom-document-querycommandenabled%28%29
m.queryCommandIndeterm:~EXEC-COMMAND#dom-document-querycommandindeterm%28%29
m.queryCommandState:~EXEC-COMMAND#dom-document-querycommandstate%28%29
m.queryCommandSupported:~EXEC-COMMAND#dom-document-querycommandsupported%28%29
m.queryCommandValue:~EXEC-COMMAND#dom-document-querycommandvalue%28%29

m.spellcheck:#dom-spellcheck

m.relatedTarget:~UIEVENTS#dom-focusevent-relatedtarget
m.detail:~UIEVENTS#dom-uievent-detail
m.view:~UIEVENTS#dom-uievent-view
m.show:~HEinteractive#dom-dialog-show
m.showModal:~HEinteractive#dom-dialog-showmodal
m.designMode:#dom-document-designmode

m.new CloseWatcher:#dom-closewatcher
m.requestClose:#dom-closewatcher-requestclose
m.close:#dom-closewatcher-close
m.destroy:#dom-closewatcher-destroy
m.oncancel:#handler-closewatcher-oncancel
m.onclose:#handler-closewatcher-onclose
m.preventDefault:~DOM4#dom-event-preventdefault
m.cancelable:~DOM4#dom-event-cancelable

m.pointerType:~POINTEREVENTS#dom-pointerevent-pointertype

mb.preventScroll:#dom-focusoptions-preventscroll
mb.focusVisible:#dom-focusoptions-focusvisible

mb.signal:#dom-closewatcheroptions-signal

l.focus-without-user-activation:~HTMLINFRA#focus-without-user-activation-feature

	■css
p.outline:~CSSUI#propdef-outline
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.white-space:~CSSTEXT#propdef-white-space
p.pointer-events:~CSSUI#pointer-events-control
p.user-select:~CSSUI#content-selection
p.content-visibility:~CSSCONTAIN#propdef-content-visibility
p.display:~CSSDISP#propdef-display

	■e
e.a:~HEtextlevel#the-a-element

e.area:~HEimages#the-area-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.frame:~HTMLobs#frame

e.canvas:~HEcanvas#the-canvas-element

e.input:~HEinput#the-input-element
e.button:~HEforms#the-button-element
e.form:~HEforms#the-form-element
e.label:~HEforms#the-label-element
e.output:~HEforms#the-output-element
e.select:~HEforms#the-select-element
e.textarea:~HEforms#the-textarea-element

e.details:~HEinteractive#the-details-element
e.dialog:~HEinteractive#the-dialog-element
e.summary:~HEinteractive#the-summary-element

e.div:~HEgrouping#the-div-element
e.link:~HEmetadata#the-link-element
e.object:~HEembed#the-object-element
e.video:~HEmedia#the-video-element

e.slot:~HEscripting#the-slot-element

	e.a:~SVGlinking#elementdef-a


	■#attr-

a.accesskey:#the-accesskey-attribute
a.aria-describedby:~ARIA1#aria-describedby
a.autocapitalize:#attr-autocapitalize
a.autocorrect:#attr-autocorrect
a.autofocus:#attr-fe-autofocus
a.commandfor:~HEforms#attr-button-commandfor
a.contenteditable:#attr-contenteditable
a.disabled:~HTMLforms#attr-fe-disabled
a.draggable:~HTMLdnd#attr-draggable
a.enterkeyhint:#attr-enterkeyhint
a.form:~HTMLforms#attr-fae-form
a.hidden:#attr-hidden
a.href:~HTMLlinks#attr-hyperlink-href
a.inert:#the-inert-attribute
a.inputmode:#attr-inputmode
a.open:~HEinteractive#attr-details-open
a.pattern:~HEinput#attr-input-pattern
a.popovertarget:~HTMLpopover#attr-popovertarget
a.readonly:~HEinput#attr-input-readonly
a.spellcheck:#attr-spellcheck
a.src:~HEimages#attr-img-src
a.tabindex:#attr-tabindex
a.title:~HTMLdom#attr-title
a.type:~HEinput#attr-input-type
a.~readonly0:~HEforms#attr-textarea-readonly
a.writingsuggestions:#attr-writingsuggestions

v.none:#attr-inputmode-keyword-none
v.text:#attr-inputmode-keyword-text
v.tel:#attr-inputmode-keyword-tel
v.url:#attr-inputmode-keyword-url
v.email:#attr-inputmode-keyword-email
v.numeric:#attr-inputmode-keyword-numeric
v.decimal:#attr-inputmode-keyword-decimal
v.search:#attr-inputmode-keyword-search

vC.none:#attr-autocapitalize-none
vC.off:#attr-autocapitalize-off
vC.on:#attr-autocapitalize-on
vC.sentences:#attr-autocapitalize-sentences
vC.words:#attr-autocapitalize-words
vC.characters:#attr-autocapitalize-characters

v.off:#attr-autocorrect-off
v.on:#attr-autocorrect-on

v.enter:#attr-enterkeyhint-keyword-enter
v.done:#attr-enterkeyhint-keyword-done
v.go:#attr-enterkeyhint-keyword-go
v.next:#attr-enterkeyhint-keyword-next
v.previous:#attr-enterkeyhint-keyword-previous
v.~search0:#attr-enterkeyhint-keyword-search
v.send:#attr-enterkeyhint-keyword-send

v.until-found:#attr-hidden-until-found
v.hidden:#attr-hidden-hidden

v.true:#attr-contenteditable-true
v.false:#attr-contenteditable-false
v.plaintext-only:#attr-contenteditable-plaintextonly

vS.true:#attr-spellcheck-true
vS.false:#attr-spellcheck-false

vW.true:#attr-writingsuggestions-true
vW.false:#attr-writingsuggestions-false

	■event
et.beforematch:~HTMLindex#event-beforematch
et.blur:~HTMLindex#event-blur
et.cancel:~HTMLindex#event-cancel
et.change:~HTMLindex#event-change
et.close:~HTMLindex#event-close
et.focus:~HTMLindex#event-focus
et.fullscreenchange:~FULLSCREEN#eventdef-document-fullscreenchange
et.click:~POINTEREVENTS#dfn-click
et.keydown:~UIEVENTS#event-type-keydown
et.mousedown:~POINTEREVENTS#dfn-mousedown
et.pointerup:~POINTEREVENTS#dfn-pointerup
et.pointerdown:~POINTEREVENTS#dfn-pointerdown
et.scroll:~CSSOMVIEW#eventdef-document-scroll
et.toggle:~HTMLindex#event-toggle
et.touchend:https://w3c.github.io/touch-events/#event-touchend
et.visibilitychange:~HTMLindex#event-visibilitychange

st.Email:~HEinput#email-state-(type=email)
st.Hidden:~HEinput#hidden-state-(type=hidden)
st.Number:~HEinput#number-state-(type=number)
st.Password:~HEinput#password-state-(type=password)
st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Tel:~HEinput#telephone-state-(type=tel)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Url:~HEinput#url-state-(type=url)

st.~on:#concept-autocorrection-on
st.~off:#concept-autocorrection-off

st.非可視でない:#attr-hidden-not-hidden-state
st.非可視:#attr-hidden-hidden-state
st.見出されるまでは非可視:#attr-hidden-until-found-state

stS.~T:#attr-spellcheck-true-state
stS.~F:#attr-spellcheck-false-state
stS.既定:#attr-spellcheck-default-state

stW.~T:#attr-writingsuggestions-true-state
stW.~F:#attr-writingsuggestions-false-state
stW.既定:#attr-writingsuggestions-default-state

aH.既定:#autocap-hint-default
aH.なし:#autocap-hint-none
aH.一文ごと:#autocap-hint-sentences
aH.単語ごと:#autocap-hint-words
aH.文字ごと:#autocap-hint-characters

cF.動作:~HEinteractive#command-facet-action
cF.不能化されるか:~HEinteractive#command-facet-disabledstate
cF.隠されるか:~HEinteractive#command-facet-hiddenstate

ps.focus-visible:~SELECTORS4#focus-visible-pseudo

st.~T:#attr-contenteditable-true-state
st.~F:#attr-contenteditable-false-state
st.素な~textのみ:#attr-contenteditable-plaintextonly-state
st.継承-:#attr-contenteditable-inherit-state

	●用語
要素:#_element

文書:~HTMLdom#the-document-object
~tabindex値:#tabindex-value

先祖を露呈する:#ancestor-revealing-algorithm
先祖~露呈~pair:#ancestor-reveal-pair
arP.~node:#ancestor-reveal-pair-node
arP.文字列:#ancestor-reveal-pair-string

失効-:#activation-expiry
作動化を誘発する入力~event:#activation-triggering-input-event

利用者-作動化を消費-:#consume-user-activation
履歴~動作による作動化を消費する:#consume-history-action-user-activation
履歴~動作による作動化を消費-:#consume-history-action-user-activation

最後の作動化の時刻印:#last-activation-timestamp
最後の履歴~動作による作動化の時刻印:#last-history-action-activation-timestamp

居残な作動化を有して:#sticky-activation
一過な作動化を有して:#transient-activation
履歴~動作による作動化を有して:#history-action-activation
一過な作動化の所要時間:#transient-activation-duration

作動化を通知する:#activation-notification
作動化を消費する:#activation-consuming-api
一過な作動化を消費する~API:#activation-consuming-api
履歴~動作による作動化を消費する~API:#history-action-activation-consuming-api
居残な作動化で通過制御される~API:#sticky-activation-gated-api
一過な作動化で通過制御される~API:#transient-activation-gated-api
利用者-作動化で通過制御される~API:#user-activation-gated-apis
結付けられた~UserActivation:#associated-useractivation

アテガわれた~access~UIkey:#assigned-access-key
阻んでいる~modal~dialog:#blocked-by-a-modal-dialog

doc.可視性~状態:#visibility-state
可視性~状態を更新する:#update-the-visibility-state
~page可視性~変化-時の手続き:#page-visibility-change-steps
vsE.時刻印:#visibilitystateentry-timestamp
vsE.可視性~状態:#visibilitystateentry-state

~design~modeは可能化されるか:#design-mode-enabled
編集中の~host:#editing-host

~clickは進捗-中か:#click-in-progress-flag

~toggle~task追跡子:#toggle-task-tracker
tTk.~task:#toggle-task-task
tTk.旧-状態:#toggle-task-old-state

~DOM~anchor:#dom-anchor
~focus鎖:#focus-chain
~focusを有するか？:#has-focus-steps
~focusを得る:#gains-focus
~focusされて:#focused

~focus可能な区画:#focusable-area
~focus可能な図形:#_focusable-shape

~focus可能:#focusable
連列的に~focus可能:#sequentially-focusable
~clickで~focus可能:#click-focusable
~system~focus:#system-focus
利用者の注目:#user-attention
~top-level辿可能にて全部的に作動中かつ利用者の注目を有している子孫:#fully-active-descendant-of-a-top-level-traversable-with-user-attention

tlT.現在の~focus鎖:#current-focus-chain-of-a-top-level-traversable
tlT.現在の被focus区画:#currently-focused-area-of-a-top-level-traversable

doc.指名する被focus区画:#focused-area-of-the-document

~focusを許容する手続き:#allow-focus-steps
~focusを更新する:#focus-update-steps
~objを~unfocusする:#unfocusing-steps
~objを~focusする:#focusing-steps
~focus可能な区画を取得する:#get-the-focusable-area

自動focusは処理-済みか:#autofocus-processed-flag
自動focus候補~群:#autofocus-candidates
自動focus候補~群を洗出す:#flush-autofocus-candidates
自動focus委任-先:#autofocus-delegate
~focus委任-先:#focus-delegate

	:#bc-focus-ergo-bcc-focus

相応しい連列的に~focus可能な区画:#suitable-sequentially-focusable-area

連列的~focus~navi:#sequential-focus-navigation
連列的~focus~navi順序:#sequential-focus-navigation-order
連列的~focus~naviの始点:#sequential-focus-navigation-starting-point
	適切になるなら:#concept-platform-dropeffect-override
	concept-platform-dropeffect-override-

不活:#inert
既定の挙動:#concept-spellcheck-default
i.既定では継承する:#concept-spellcheck-default-inherit
i.既定では~T:#concept-spellcheck-default-true
i.既定では~F:#concept-spellcheck-default-false

連列的~navi探索~algo:#sequential-navigation-search-algorithm
~source~node:#source-node
連列的~focus方向:#sequential-focus-direction
i.前方:#sequential-focus-forward
i.後方:#sequential-focus-backward
選定法:#selection-mechanism
i.~DOM順:#selection-mechanism-dom
i.連列的:#selection-mechanism-sequential

~focus~navi視野:#focus-navigation-scope
~tabindex順な~focus~navi視野:#tabindex-ordered-focus-navigation-scope
平坦~化された~tabindex順な~focus~navi視野:#flattened-tabindex-ordered-focus-navigation-scope
結付けられた~focus~navi所有者:#associated-focus-navigation-owner
~focus~navi視野の所有者:#focus-navigation-scope-owner

自動頭字化~hint:#autocapitalization-hint
自前の自動頭字化~hintを算出する:#own-autocapitalization-hint
利用する自動頭字化~hintを算出する:#used-autocapitalization-hint
自動頭字化-と自動訂正-を継承-:~HEforms#category-autocapitalize

利用する自動訂正~状態を算出する:#used-autocorrection-state

自動focus根:#nearest-ancestor-autofocus-scoping-root-element


~find-in-page:#find-in-page-2
~find-in-page~UI:#find-in-page-interface
fiP.~query:#fip-query
fiP.合致-~list:#fip-matches
fiP.作動中な合致-:#fip-active-match

閉-注視器:#close-watcher
cW.~window:#close-watcher-window
cW.閉-動作:#close-watcher-close-action
cW.取消-動作:#close-watcher-cancel-action
cW.取消-動作を走らせているか:#close-watcher-is-running-cancel
cW.可能化~状態を取得する:#close-watcher-get-enabled-state
cW.作動中:#close-watcher-active

閉-要請:#close-request
閉-要請~手続き:#close-request-steps
閉-注視器を確立する:#establish-a-close-watcher
閉-注視器たちを処理する:#process-close-watchers
内部~閉-注視器:#internal-close-watcher
閉-注視器に閉じるよう要請する:#close-watcher-request-close
閉-注視器を閉じる:#close-watcher-close
閉-注視器を破壊する:#close-watcher-destroy

閉-注視器~管理器:#close-watcher-manager
cwM.許容される~groupの個数:#close-watcher-manager-allowed-number-of-groups
cwM.~group群:#close-watcher-manager-groups
cwM.次回の利用者-作動化は新たな~groupを許容するか:#close-watcher-manager-next
利用者-作動化について閉-注視器~管理器に通知する:#notify-the-close-watcher-manager-about-user-activation

書法~示唆~値を算出する:#computed-writing-suggestions-value

	●用語（HTML

~HTML要素:~HTMLINFRA#html-elements
即時に:~HTMLINFRA#immediately
~live:~HTMLINFRA#live
文書の中へ挿入された:~HTMLINFRA#insert-an-element-into-a-document
q
反映する:~HTMLcdom#reflect
既知な値のみに制限される:~HTMLcdom#limited-to-only-known-values

列挙d属性:~HTMLcms#enumerated-attribute
真偽-属性:~HTMLcms#boolean-attribute
妥当でない値~用の既定の状態:~HTMLcms#invalid-value-default
欠落~値~用の既定の状態:~HTMLcms#missing-value-default
空~文字列~用の既定の状態:~HTMLcms#empty-value-default
整数として構文解析する:~HTMLcms#rules-for-parsing-integers
~space等で分離された~token集合:~HTMLcms#set-of-space-separated-tokens
妥当な整数:~HTMLcms#valid-integer

~body要素:~HTMLdom#the-body-element-2

利用は許容されて:~HEembed#allowed-to-use

~navigable:~HTMLds#navigable
nav.親:~HTMLds#nav-parent
nav.作動中な文書:~HTMLds#nav-document
nav.作動中な~window:~HTMLds#nav-window
nav.~top-level辿可能:~HTMLds#nav-top
nav.容器:~HTMLds#nav-container
子~navigable:~HTMLds#child-navigable
~top-level辿可能:~HTMLds#top-level-traversable
辿可能な~navigable:~HTMLds#traversable-navigable
nav.~system可視性~状態:~HTMLds#system-visibility-state
先祖~navigable群:~HTMLds#ancestor-navigables
子孫~navigable群:~HTMLds#descendant-navigables
広義-先祖~navigable群:~HTMLds#inclusive-ancestor-navigables
広義-子孫~navigable群:~HTMLds#inclusive-descendant-navigables
~navigable容器:~HTMLds#navigable-container
内容~navigable:~HTMLds#content-navigable
~node~navigable:~HTMLds#node-navigable
全部的に作動中:~HTMLds#fully-active

閲覧~文脈:~HTMLds#browsing-context
属する閲覧~文脈:~HTMLds#concept-document-bc
bc.作動中な~window:~HTMLds#active-window

対応する~navigable:~WINDOW#window-navigable
結付けられた文書:~WINDOW#concept-document-window
~navi~API:~HTMLnavAPI#window-navigation-api
進行中な~naviの間に~focusは変化したか:~HTMLnavAPI#focus-changed-during-ongoing-navigation

~target要素:~HTMLnav#target-element
素片へ~navigateする:~HTMLnav#navigate-fragid

作動中な~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
閲覧~文脈~sandbox化( 自動的な特能 )~flag:~ORIGIN#sandboxed-automatic-features-browsing-context-flag
同一-生成元:~ORIGIN#same-origin

~task:~WAPI#concept-task
~taskを~queueする:~WAPI#queue-a-task
~click~eventを発火する:~WAPI#fire-a-click-event
~focus~eventを発火する:#fire-a-focus-event
合成な~pointer~eventを発火する:~WAPI#fire-a-synthetic-pointer-event
関連な~realm:~WAPI#concept-relevant-realm
関連な大域~obj:~WAPI#concept-relevant-global
利用者ヤリトリ~task~source:~WAPI#user-interaction-task-source
大域~taskを~queueする:~WAPI#queue-a-global-task
~event~handler:~WAPI#event-handlers
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes

fe.不能化されて:~HTMLforms#concept-fe-disabled
fe.変異-可能:~HTMLforms#concept-fe-mutable
fe.値:~HTMLforms#concept-fe-value
~form所有者:~HTMLforms#form-owner
利用者~妥当性:~HTMLforms#user-validity

入力~eventを発火する:~HEinput#_fire-input-event
選択された~file~list:~HEinput#concept-input-type-file-selected
	~HEtextlevel#the-a-element
	~HEinput#number-state-(type=number)
	~HEinput#range-state-(type=range)
	~HEinput#text-(type=text)-state-and-search-state-(type=search)
	適用される:~HEinput#concept-input-apply

~command:~HEinteractive#concept-command
~commandを定義する:~HEinteractive#concept-command
親~details用の~summary:~HEinteractive#summary-for-its-parent-details

i.示している:~HTMLpopover#popover-showing-state
el.~popover誘発元:~HTMLpopover#popover-trigger
a.popover:~HTMLpopover#attr-popover
~popover要素:~HTMLpopover#_popover-element
	st.~popoverなし:~HTMLpopover#attr-popover-none-state
~popover可視性~状態:~HTMLpopover#popover-visibility-state

実際に不能化-:~HTMLselectors#concept-element-disabled
~UI内に公開されている~control:~HEmedia#expose-a-user-interface-to-the-user
~scriptを阻んでいる~stylesheet集合:~HEmetadata#script-blocking-style-sheet-set
具現化され:~HTMLrendering#being-rendered
具現化されて:~HTMLrendering#being-rendered
その具現化を子へ委任して:~HTMLrendering#delegating-its-rendering-to-its-children

~hyperlink:~HTMLlinks#hyperlink
画像~map:~HEimages#image-map

	●用語（外部
新たな~obj:~WEBIDLjs#new

実装定義:~INFRA#implementation-defined

~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII空白:~INFRA#ascii-whitespace
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
~tuple:~INFRA#tuple
~list:~INFRA#list
~size:~INFRA#list-size
空:~INFRA#list-is-empty
除去する:~INFRA#list-remove
付加する:~INFRA#list-append
空にする:~INFRA#list-empty
~cloneする:~INFRA#list-clone
拡張する:~INFRA#list-extend
構造体:~INFRA#struct
~item:~INFRA#list-item
sct.~item:~INFRA#struct-item

表示域:~CSS2J#viewport
~box~tree:~CSSDISP#box-tree
~CSS~box:~CSSDISP#box
~targetを~viewの中へ~scrollする:~CSSOMVIEW#scroll-a-target-into-view
平坦~tree:~CSSSHADOW#flat-tree

~focusを指示する:~SELECTORS4#indicate-focus

~node文書:~DOM4#concept-node-document
~tree順序:~DOM4#concept-tree-order
子:~DOM4#concept-tree-child
子孫:~DOM4#concept-tree-descendant
~node~tree:~DOM4#concept-node-tree
根:~DOM4#concept-tree-root
文書~内にある:~DOM4#in-a-document
文書~要素:~DOM4#document-element
親~要素:~DOM4#parent-element
広義-先祖:~DOM4#concept-tree-inclusive-ancestor
	広義-先祖 → 親~要素
接続されて:~DOM4#connected
~host:~DOM4#concept-documentfragment-host
~shadow根:~DOM4#concept-shadow-root
~shadowも含めた子孫:~DOM4#concept-shadow-including-descendant
~shadowも含めた~tree順序:~DOM4#concept-shadow-including-tree-order
~shadowも含めた広義-先祖:~DOM4#concept-shadow-including-inclusive-ancestor
~shadow~host:~DOM4#element-shadow-host
el.~shadow根:~DOM4#concept-element-shadow-root
	属性~値を設定する:~DOM4#concept-element-attributes-set-value
sR.~focusを委任するか:~DOM4#shadowroot-delegates-focus
割当-先~slot:~DOM4#slotable-assigned-slot
~eventを配送する:~DOM4#concept-event-dispatch
~eventを発火する:~DOM4#concept-event-fire
作動化の挙動:~DOM4#eventtarget-activation-behavior
ev.~composedか:~DOM4#composed-flag
ev.取消されたか:~DOM4#canceled-flag
~targetし直す:~DOM4#retarget
doc.生成元:~DOM4#concept-document-origin
aB.中止-済み:~DOM4#abortsignal-aborted
通達に~algoを追加する:~DOM4#abortsignal-add
attr.値:~DOM4#concept-attribute-value

現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time
処理能~entryを~queueする:~TIMELINE#queue-a-performanceentry

上端~層:~CSSPOS4#document-top-layer

~screen方位~変更~手続き:~SCREEN-ORIENTATION#dfn-screen-orientation-change-steps

~fullscreen要素:~FULLSCREEN#fullscreen-element
~fullscreenから全部的に抜出る:~FULLSCREEN#fully-exit-fullscreen

~URL:~URL1#concept-url

~view遷移の~page可視性~変化-時の手続き:~CSSVT#view-transition-page-visibility-change-steps

飛ばされた内容:~CSSCONTAIN#skips-its-contents
内容は飛ばされ:~CSSCONTAIN#skips-its-contents
~layout封込め:~CSSCONTAIN#layout-containment
選択:~SELECTIONAPI#dfn-selection

編集-可能:~EXEC-COMMAND#editable
属する編集中の~host:~EXEC-COMMAND#editing-host-of
作動中な範囲:~EXEC-COMMAND#active-range
選択を削除-:~EXEC-COMMAND#delete-the-selection

拡張~command:~WEBDRIVER#dfn-extension-commands
~remote端~手続き:~WEBDRIVER#dfn-remote-end-steps
現在の閲覧~文脈:~WEBDRIVER#dfn-current-browsing-context
成功:~WEBDRIVER#dfn-success


●●words_table1

WEBDRIVER:https://w3c.github.io/webdriver/
VIBRATION:vibration-ja.html

readonly0:readonly
search0:search
svg-a:a
Esc:<kbd>Esc</kbd>

●●words_table

	●focus／dialog
順な:ordered:順による
	連列的~focus~navi順序
	~focus~navi序列
blur:
	~focus可能:focusable
	~focus不能:non-focusable
	~focus時の:focusing
	~focus能:focusability
被focus:focused::被 focus:被フォーカス
自動focus:autofocus::自動 focus:自動フォーカス
unfocus::::未フォーカスに
	~unfocus時の:unfocusing

指名-:designate::~
届けら:routeさ::~
届ける:routeする::~
	経由-:channeled
	から経由され:channeled form
	委任-先:delegate
	委任-先~list:delegates
	得た:gainした
	得る:gainする

tabindex:
図形:shape::~
	到達-可能でない:unreachable

前方:forward::~
後方:backward::~
不活:inert::~
	不活 性:inertness
環:ring::~
鎖:chain::~
隠す:hideする::~
隠-:hide::~

操作o:operation:操作
操作不能:inoperable:~
代役:placeholder:~
候補:candidate:~
選定法:selection mechanism:~
始点:starting point:~
scrolling::::スクロール
誘発元:trigger:~
注目:attention:~

	進捗-中:in progress
	ただちに:as soon as
	巡る:travel

	●編集
綴り:spelling:~
誤綴な:misspelled:綴りを誤った
検査ng:checking:検査
編集:editing::~
編集-:edit::~
編集中の:editing::~
	編集-不能:non-editable
折返す:wrapする::折り返す
折返され:wrapされ::折り返され
折返ng:wrapping::折り返し
境界点:boundary point::~
選択-:select:~

選択:selection:~
字下げ:indentation:~
一文:sentence:文
自然言語:language:~
誤り:error::~::エラー
訂正:correction::~
	不向き: not well suited
約物:punctuation character:~

	●UI／呈示
	tab化された:tabbed
	^en:tabbing
	UI:interface／user interface
design:
kiosk:
panel::::パネル
popup::::
bullet::::ビュレット
drag::::ドラッグ
drop::::ドロップ
picker:::選択 UI
autofill:
開く:openする:~
開な:openな:開いた
閉な:closedな:閉じた
閉じる:closeする:~
閉じら:closeさ:~
閉-:close:閉じ
	閉じるための／閉じる際の:closing
押下げる:pressする:~
押下げら:pressさ:~
押下げた:pressした:~
押下n:press:押下げ
	押下げること:pressing
	押下げら:pressing down
放され:releaseされ:~
戻り:back:~
退-:dismiss:退け
退ける:dismissする:~
退けら:dismissさ:~
	退けられた時点:upon dismissal
注視-:watch::~
注視器:watcher::~
find-in-page::::ページ内検索
popover:
下位widget:subwidget::下位 widget:下位ウィジェット
full::::フル
pointing::::ポインタ指示
十key:numeric keypad:::テンキーの類
数量-:numeric:~
	数:numeric
修飾:modifier:~
声:voice:~
click:
外形線:outline:~
美観:aesthetics:~
欄:field::~::フィールド
	合致するものを探索-:searching for matches
振動-:vibrate::~
示され:showされ:~
示して:showして:~
示す:showする:~
抜出る:exitする::抜け出る
alphabetic-mnemonic:alphabetic mnemonic::alphabetic 符号:アルファベット符号
電話番号:telephone number:~
email::::メール
手早く:quickに:~
書式:format::~
locale::::ロケール
affordance:
virtual-keyboard:virtual keyboard:::ソフトウェアキーボード
	~keyboardのみの:keyboard-only
	小数を含む:fractional
	PIN

自動頭字化-:autocapitalize::~
自動頭字化:autocapitalization::~
自動訂正-:autocorrect::~
自動訂正:autocorrection::~
字l:letter::字°
頭字化:capitalize::~
頭字:capital letter::~
voice:::声::ボイス
打込む:typeする:打ち込む:::タイプする
打込まれ:typeされ:打ち込まれ:::タイプされ
打込みそ:typeしそ:打ち込みそ
打込み:typing:打ち込み:::タイピング
打込んで:typeして:打ち込んで:::タイプして
打込んだ:typeした:打ち込んだ:::タイプした
組成-:compose::~
	助けに:helpful
改行:new line:~
	`Enter^Key ~UIkey:enter key
cue:
IME:input method editor:IME

能動的:active::~
知覚-:perceive:~
一過:transient::~
居残な:stickyな::居残る
近過去:recent:~
経過-:elapse:~
失効:expiry:~
失効-:expire:~
強調-:highlight:~
露呈-:reveal:露わに
露呈:reveal:露わ化
展開-:expand:~
検索語:search term::~
切替器:switcher:~
最小化-:minimize:~
遮って:obscureして:~
遮られ:obscureされ:~
遮る:obscureする:~
拡大鏡:magnifier:~
接触判定:hit-testing::~
持続的:persistent::~
封込め:containment::封じ込め
非可視:hidden:~
UserActivation:
後景:backdrop::~
上層:overlay::~::オーバーレイ
	上層を成す:overlaid／:overlaid
生な:raw:~
rich:
	形式~化:formatting
shortcut::::ショートカット
洗出す:flushする:洗い出す
	履歴~上の:historical
経路:path::~
off-screen::::オフスクリーン
	開閉すること:to be opened or closed
塗り:paint:~
間引かせ:throttleさせ:~
間引き:throttling:~
活動:activity:~
	活動が無い:inactivity
fullscreen::::全スクリーン
controller::::コントローラ
gamepad::::ゲームパッド
desktop::::デスクトップ
mobile::::モバイル
非作動化-:deactivate::~::非アクティブ化
確認:confirmation:~
至急:urgent:~
書法:writing::書き方
on::::オン
off::::オフ

	示唆:suggestions
	ヤリトリ-可能:interactive
	長く:long
	長くとも:at most
	数秒:a few seconds
	導く:take 〜 to
	煩わしい:annoying
	受けた:get／:got
	使い勝手:usability
	使い勝手がすこぶる悪く:significantly less usable
	使い勝手は悪くなる:become unusable
	最後の（最も手前に~~示される）:topmost
	次へ進める:advance
	間を~~空け:separated by a gap
	ごく狭い:tiny
	~~背後に:background
	いらつかせる:get frustrated
	指示するもの:indication
	見えてない:not be able to see
	^Key:Control
	^Key:Escape
	^Key:Shift
	WYSIWYG
	長期間:long period
	になって以降:from the moment
	失う:lose
	失った:lose
	失われ:lose
	失われ:lost
	〜が~focusを得るに伴い失われる:lost to
	失って:lost
	^en:two-finger scrub “z”
	増減~button:up and down buttons in a spin-control version
	~tab~UIkeyで移動する:tab to
	編集-可能:editable

	●構文

	-:literal
縮約-:collapse:~
普通字:letter:~
	先頭の:leading

	●内容／DOM
body:
details:
summary:
	後続-:
	子たち:children
割当-:assign::あてがい
	割当-先:assigned 先
アテガイ:assign 法::あてがい方
一節:section:~
見出し:heading::~

	●処理
旧-:old:~
新-:new:~
追跡子:tracker::~::トラッカー
解体-:tear down:~
再帰-:recurse::~
消費:consumption::~
続行-:proceed:~
	直行-:proceeds directly
時間切れ:timeout:~
	集める:gather
管理器:manager::~::マネージャ
次回の:next:~

	●変数
	%取扱えるか:canHandle
	%文書:target
	%文書:d
	%~top文書:topDocument
	%文書:doc
	-:inclusiveAncestorDocuments
	%~focus誘発元:focus trigger
	%~target:focus target
	%~target:new focus target
	%~target:focusTarget
	%自動focus委任-先:autofocusDelegate
	%~focus可能な区画:focusableArea
	%~focus可能な区画:focusable area
	%~~注目先:whereToLook
	%~target:parent
	%親:-
	%子孫:descendant
	%新たな状態:newState
	%新-鎖:new chain
	%可視性~状態:visibilityState
	%現在の~node:currentNode
	%~focusを指示するか:-
	%被focus要素
	%先祖~navigable:ancestorNavigable
	%~navigable群:navigables
	%~navigable:navigable
	%~window:W
	%~window:window
	%~window群:windows
	%消費するか:consume
	%文書:document
	%~event:event
	%何か閉じられたか:closedSomething
	%閉-注視器:closeWatcher
	%閉-を防止し得るか:canPreventClose
	%取消-動作:cancelAction
	%閉-動作:closeAction
	%可能化~状態を取得する:getEnabledState
	%継続するべきか:shouldContinue
	%閉-注視器を処理したか:processedACloseWatcher
	%要素:element
	%管理器:manager
	%続行するべきか:shouldProceed
	%親:-
	%状態:-
	%内容~属性~値:-
	%履歴~動作による作動化を要求するか:requireHistoryActionActivation
	%~target:target
	%露呈~型:revealType
	%露呈する先祖~群:ancestorsToReveal
	%露呈する先祖:ancestorToReveal
	%~index:parsedValue

	●保安
通過制御-:gate::~
濫用:abuse:~
濫用者:abuser:~
濫用的:abusive:~
悪用-:exploit:~
横取n:interception::横取り
横取り:intercept::~
無制限:unlimited:~
確信犯:determined:~
貯蓄-:bank:~
	いらつかせる:frustration
	抗する:anti-

	●仕様
素早く:quickに:~
	-:non-normative
正当:legitimate:~
略式的:skeletal:~
	文脈に応じた:contextual
遺物:artifact:~
選択的:selective:~
支援-:assist:~
支援技術:assistive technologies:~
介入-:intervene:~
構成-:compose:~
網羅的:exhaustive:~
故意:deliberate:~
類別-:classify:~
複雑:complicated:~
規定-:dictate:~
満足-:satisfy:~
明白:obvious:~
連関:link:~
	同様に:similar fashion
逃れる:escapeする:~
維持-:retain:~
critical:
変種:variant:~
微妙:subtle:~
自由:free:~
過度:excessive:~
概略的:brief:~
為す:makeする:~

	なり得る:possible
	きれいに:neatly
	きわどい:corner
	それに代わる:in its stead
	ないがしろに:detriment
	に過ぎない:merely
	も:opt to
	何らかの方法:somehow
	何らかの類の:some sort of
	普及している:prevalent
	申し分ない:fine
	およそ:likely
	可能性が高い:likely
	多様な:wide variety of
	様々な:variety
	-:in fact
	それに伴い:thereby
	現時点で最良:currently-best
	対照的に:in contrast
	~~直に:immediately
	custom化:customizable
	-:abstract concept
	ある:particular
	易くする:help
	概ね:roughly speaking
	正当化される:well justify
	呼応:in response to
	できる:capable of
	満たす:meet
	-:aforementioned
	下層を〜成す:underlie
	cause:結果〜ことになる
	変わらない:stay
	~CSSも~supportする:HTML+CSS
	留意すること:worth remembering
	挙げる点:two caveats
	に注意:notice
	~~現在:presently
	~~明らか:apparent
	~~注目-:looking at
	難しくなる:harder
	とは言えない:not quite
	なるとは限らず:not necessarily have to be
	ときもある:sometimes
	数えられ:count
	紛れもなく:definitely
	に基づく:come
	支える:uphold
	道:path
	短く言えば：in short
	自身が:in fact,

	●言い換え
	防止するため:for 〜 prevention purposes
	変化しない:original 〜 remains unchanged
	〜かどうか:status
	も併用することなく:as opposed to
	遡り続け:continues up 〜 up to
	合致-~list:matches
	~text片:piece of text
	投稿-:publish
	外された:omitted
	戻せるように:allow 〜 toggle it back
	起こる時点は、いくつかあり得る:can happen at different times
	各~合致を:through
	便利用として:helper utility
	~group化されてない:ungrouped
	ならない:bail out
	後から:newly
	~F になる:lost
	継続して〜至る:continuing onward to
	-:Combined,
	戻る:reset
	-:branch
	一つだけ:single

	●未分類
trust:
	~trustされない:not trusted
composed:
commit:
game::::ゲーム
log-in:log in:::ログイン
main::::メイン
macOS:
逆順:reverse order:~
携帯:mobile::~::モバイル
スマホ:phone:::~
非対称:asymmetry:~
深い:deepな:~
	最も深い:deepest
高分解能:high resolution::~
代用:substitute:~
合成な:syntheticな:~
合成-:synthesize:~
告知-:advertise:~
保つ:keepする:~
切替える:switchする:切り替える
所在-:locate::~
増分的:incremental:~
増える:increaseする:~
族:family::~
screenshot::::スクリーンショット
現在は:currently:現在
一様:uniform:~
top::::トップ
端:end:~
template:
URI:
相関:correlation:~
隠蔽-:shadow:~
保存-:save:~
	保存されてない:unsaved
差分:delta:~
	集約-:centralize
束ねら:tieさ:~
付随-:accompany:~

	素な~textのみ:plaintext-only
	この属性の状態:kind of editable (or not editable)
	-:header
	-:time
	-:argument
	-:required
	-:relative
	~~記事:article
	数:number
	小さい／小さな:small
	定数:constant number
	未設定:unset
	したい:want
	始-:begin
	伝える:tell／:inform
	~~検索
	~~生成
	~~要請
	~~連続する:adjacent
	〜されない:opposed
	選んだ:choosing
	選ぶ:choose
	選ばれ:chosen
	~~選ぶ:pick
	-:exception
	-:setting
	-:map
	-:place
	属する:belong
	実際に不能化-:disable
	~~由来する:comes from
	語全体:whole words
	し始める:begin
	し終えた:finish
	他へ~navigate:navigating away
	に基づくか:base 〜 off
	またがる:span
	直の:immediate
	などなど:and so forth
	-:second／third
	以前の:previous
	先ず:first place
	先ず:first
	次の:next
	次回:next time
	次回:next
	前後の:next or previous
	前の:previous
	-:originally
	一緒:together
	一つに:together
	一回の:single
	一回の:per
	一回以上は:at least once
	2 回目:the second time
	2 回目:the second
	初めて:very first
	一部に限られる:subset of those
	何度も続けて:too frequently
	何度も続けて:multiple times in a row
	続けて:twice in a row
	続けて:twice
	~~後方へ:back
	^en:DualShock
	^en:square
	^en:iOS VoiceOver
	^en:Android
	最終的に:eventually
	~call元:caller
	~~統合-:consolidate
	まで戻る:get back
	主な:main
	別な:second independent
	整数:number
	〜以下までは:a number equal to at most
	まで:at most
	回数:the number of times
	~group法:grouping
	~group化:grouped
	含まれ:include

	一方
	一種
	一連
	一部
	一部分:part of
	一体としての:whole
	上述
	以上
	以下
	以前
	以外
	以降
	任意
	個
	個数
	全体
	各種
	場合
	前述
	〜単独:alone
	だけなら:alone
	〜しか:just
	右列:cells in the right column
	左列:The cells in the left column
	左右列にまたがるセル:cells that span both columns
	直前
	直前に:just
	直後
	自身
	新
	旧
	その検査／:spellchecking
	とする／:suppose
	またがる:span
	利用-中に:being used
	つつある:about to be
	いかなる類の:any sort of
	高い〜ほど:higher
	ほとんど:mostly
	所与の時点:at any particular time
	在るならば:by its presence
	Population by City
	“読込n中…”:"loading"
	~targetにされ:targeted at

	-:facet
	-:in place for
	-:in the middle
	-:lack thereof
	ARIA
	Alt
	C:
	CSS
	Emacs
	Mac
	Windows
	aforementioned
	amongst
	aware
	became
	become
	care
	caused
	cell
	column
	committing
	consist
	earlier:#1
	equipped
	express
	finally
	follow
	home
	instruction
	lack
	later
	lead
	left
	mac
	made
	marked
	matching
	moving
	opted
	in-
	middle
	point
	pre-order
	put
	redo
	reduce
	referenced
	rerouting
	right
	row
	said
	sometime
	spin-control
	sure
	thereof
	top
	toward
	unable
	unadorned
	unset
	vision
	その場で:on-demand
	その場の:on-demand
	大きな:one big
	者:people
	分断不可:non-breaking
	前順, 深さ優先:pre-order, depth-first
	だけで:simply
	参照
	参照元:
	同時:
	同等に:equally
	名称:
	対応
	必ず:make sure
	指-:refer
	方法
	昇順
	時点
	用途
	省略時
	組み合わせ:mix
	該当
	詳細
	黄色:yellow

	無条件
	無用に煩雑
	現時点

●●html_code_list
■inert-1
<section aria-labelledby=s1>
  <h3 id=s1>Population by City</h3>
  <div class=container>
    <div class=loading><p>Loading...</p></div>
    <div inert>
      <form>
        <fieldset>
          <legend>Date range</legend>
          <div>
            <label for=start>Start</label>
            <input type=date id=start>
          </div>
          <div>
            <label for=end>End</label>
            <input type=date id=end>
          </div>
          <div>
            <button>Apply</button>
          </div>
        </fieldset>
      </form>
      <table>
        <caption>From 20-- to 20--</caption>
        <thead>
          <tr>
            <th>City</th>
            <th>State</th>
            <th>20-- Population</th>
            <th>20-- Population</th>
            <th>Percentage change</th>
          </tr>
        </thead>
        <tbody>
          <!-- ... -->
        </tbody>
      </table>
    </div>
  </div>
</section>

都市人口
読み込み中…
データ範囲
開始年
終了年
適用
20XX年から 20XX年まで
都市
州
20XX年の人口
20XX年の人口
変化率（百分率）

■data-model-1
<map id=wallmap><area alt="入り口ドア" coords="10,10,100,200" href="door.html"></map>
...
<img src="images/innerwall.jpeg" alt="ドア付きの白い壁がここにある" usemap="#wallmap">
...
<img src="images/outerwall.jpeg" alt="ドア付きの赤い壁がここにある" usemap="#wallmap">

alt="Enter Door"
...
alt="There is a white wall here, with a door."
...
alt="There is a red wall here, with a door."


■autofocus-1
<input maxlength="256" name="q" value="" ＜autofocus＞>
<input type="submit" value="Search">

■autofocus-2
<div contenteditable ＜autofocus＞>Edit <strong>me!</strong><div>

■intro9-1
<input type=button value=Collect onclick="collect()"
       ＜accesskey="C 1"＞ id=c>

■accesskey-1
<nav>
 <p>
  <a
    title="Consortium Activities"
    ＜accesskey="A"＞
    href="/Consortium/activities"
  >Activities</a> |
  <a
    title="Technical Reports and Recommendations"
    ＜accesskey="T"＞
    href="/TR/"
  >Technical Reports</a> |
  <a
    title="Alphabetical Site Index"
    ＜accesskey="S"＞
    href="/Consortium/siteindex"
  >Site Index</a> |
  <a
    title="About This Site"
    ＜accesskey="B"＞
    href="/Consortium/"
  >About Consortium</a> |
  <a
    title="Contact Consortium"
    ＜accesskey="C"＞
    href="/Consortium/contact"
  >Contact</a>
 </p>
</nav>

<nav>
 <p>
  <a title="Consortium Activities" accesskey="A" href="/Consortium/activities">Activities</a> |
  <a title="Technical Reports and Recommendations" accesskey="T" href="/TR/">Technical Reports</a> |
  <a title="Alphabetical Site Index" accesskey="S" href="/Consortium/siteindex">Site Index</a> |
  <a title="About This Site" accesskey="B" href="/Consortium/">About Consortium</a> |
  <a title="Contact Consortium" accesskey="C" href="/Consortium/contact">Contact</a>
 </p>
</nav>

■accesskey-2
<form action="/search">
 <label>Search: <input type="search" name="q" ＜accesskey="s 0"＞></label>
 <input type="submit">
</form>

■contenteditable-1
<form method=POST>
 <fieldset>
  <legend>新着記事</legend>
  <textarea name=article>&lt;p>こんにちは&lt;/p></textarea>
 </fieldset>
 <p><button>投稿</button></p>
</form>

<form method=POST>
 <fieldset>
  <legend>New article</legend>
  <textarea name=article>&lt;p>Hello world.&lt;/p></textarea>
 </fieldset>
 <p><button>Publish</button></p>
</form>

■contenteditable-2
<form method=POST>
 <fieldset>
  <legend>新着記事</legend>
  <textarea id=textarea name=article>&lt;p>こんにちは&lt;/p></textarea>
＜  <div id=div style="white-space: pre-wrap" hidden><p>こんにちは</p></div>
  <％script>
   let %textarea = document.getElementById("textarea");
   let %div = document.getElementById("div");
   %textarea.hidden = true;
   %div.hidden = false;
   %div.contentEditable = "true";
   %div.oninput = (%e) => {
     %textarea.value = %div.innerHTML;
   };
  </％script>＞
 </fieldset>
 <p><button>投稿</button></p>
</form>

■contenteditable-3
<!doctype html>
<html lang=en>
<title>Live CSS editing!</title>
<style style=white-space:pre contenteditable>
html { margin:.2em; font-size:2em; color:lime; background:purple }
head, title, style { display:block }
body { display:none }
</style>

■spelling-1
<div contenteditable="true">
 <span spellcheck="false" id="a">Hell</span><em>o!</em>
</div>

■spelling-2 bad
<p spellcheck="true">
 <label>Name: <input spellcheck=" false" id="b"></label>
</p>

■autocorrect-1
<form autocorrect="off">
 <input type="search">
 <textarea autocorrect="on"></textarea>
</form>

●●images
＠HTML-resources/
inert-example-loading-section｜height:243px;｜｜.png
focus-tree｜height:450px;｜｜.png

●●trans_metadata
<p>
~THIS_PAGEは、
~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ User interaction</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>
</head>
<body>

<header>
	<hgroup>
<h1>HTML — 利用者によるやりとり</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="editing">
<h2 title="User interaction">6. 利用者-ヤリトリ</h2>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

<p>
用語
`要素@
は、
`Element$I ~objの略記として用いられる。
</p>

		</section>
		<section id="the-hidden-attribute">
<h3 title="The hidden attribute">6.1. `hidden^a 属性</h3>

<p>
`hidden@a
内容~属性は、
どの`~HTML要素$に設定してもヨイ。
この属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
All HTML elements may have the hidden content attribute set. The hidden attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態
<th>概略的な記述
<tbody>

<tr><td>`hidden@v
<td>`非可視@st
<td>
具現化されなくなる。

<tr><td>`until-found@v
<td>`見出されるまでは非可視@st
<td>
具現化されなくなるが、
内側にある内容は［
`~find-in-page$／`素片へ~navigateする$こと
］により~access可能になる。

<tr><td>
<td>`非可視でない@st
<td>【具現化される。】
</table>
◎
Keyword｜State｜Brief description
hidden｜Hidden｜Will not be rendered.
until-found｜Hidden Until Found｜Will not be rendered, but content inside will be accessible to find-in-page and fragment navigation.
</div>

<p>
`hidden$a 属性の
⇒＃
`欠落~値~用の既定の状態$は `非可視でない$st とする。
`妥当でない値~用の既定の状態$は `非可視$st とする。
`空~文字列~用の既定の状態$は `非可視$st とする。
◎
The attribute's missing value default is the Not Hidden state, and its invalid value default and empty value default are both the Hidden state.
</p>

<p>
上に挙げた各~状態は、
次を指示する：
◎
↓</p>
<dl>
	<dt>
`非可視でない$st
</dt>
	<dd>
当の要素は、
常に，利用者から直に~accessできる。
【この項は、この訳による補完。】
</dd>
	<dt>
`非可視$st
◎
When an element has the hidden attribute in the Hidden state, it indicates that＼
</dt>
	<dd>
当の要素は、
利用者からは直に~accessできない
— すなわち、
次のいずれか
⇒＃
まだ, あるいは設定して以降、~pageの現在の状態に直には関連しない／
~pageの他の部分に再利用される内容を宣言するために利用されている
◎
the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user.＼
</dd>
	<dd>
<p>
~UAは、
この状態にある要素を具現化するベキでない。
◎
User agents should not render elements that are in the Hidden state.
</p>

<p class="note">注記：
~UAは、
この要件を~style層を通して間接的に実装できる
— 例えば、
§ 具現化 において`示唆される規則＠~HTMLrendering#hiddenCSS$を利用して実装することもできる。
◎
The requirement for user agents not to render elements that are in the Hidden state can be implemented indirectly through the style layer. For example, a web browser could implement these requirements using the rules suggested in the Rendering section.
</p>
	</dd>

	<dt>
`見出されるまでは非可視$st
◎
When an element has the hidden attribute in the Hidden Until Found state, it indicates that＼
</dt>
	<dd>
当の要素は`非可視$stのときと同様に非可視になるが、
その内容は［
`~find-in-page$／`素片へ~navigateする$こと
］により~access可能になる。
◎
the element is hidden like the Hidden state but the content inside the element will be accessible to find-in-page and fragment navigation.＼
</dd>
	<dd>
これらの特能が［
当の要素の下位tree内に在る~target
］へ~scrollするよう試みたときは、
~UAは，そこへ~scrollするより前に［
当の~target~nodeに対し`先祖を露呈する$ことにより，
当の要素の `hidden$a 属性を
— 当の要素の内容が露呈されるよう —
除去する
］ことになる。
◎
When these features attempt to scroll to a target which is in the element's subtree, the user agent will remove the hidden attribute in order to reveal the content before scrolling to it by running the ancestor revealing algorithm on the target node.
</dd>
</dl>

<p class="note">注記：
~web~browserは、［
要素の `hidden$a 属性の状態 ~EQ `見出されるまでは非可視$st
］のときは
— `§ 具現化＠~HTMLrendering#hiddenCSS$にて指定されるとおり —
要素に対し，
<code class="css">`display$p: `none^v</code>
に代えて
<code class="css">`content-visibility$p: `hidden^v</code>
を利用することになる。
◎
Web browsers will use 'content-visibility: hidden' instead of 'display: none' when the hidden attribute is in the Hidden Until Found state, as specified in the Rendering section.
</p>

<div class="note">
<p>注記：
この属性は、
概して~CSSを利用して実装されるので，
~CSSを利用して上書きすることもアリである。
一例として、
すべての要素に
<code class="css">`display^p: `block^v</code>
を適用する規則は，
`非可視$st 状態の効果を取消すことになる。
したがって、
~stylesheetを書く作者は，［
この属性を有する要素が依然として期待されるとおり~styleされる
］よう~careする必要がある。
加えて、［
`見出されるまでは非可視$st 状態を~supportしない旧来の~UA
］においては，［
<code class="css">`content-visibility^p: `hidden^v</code>
にならない代わりに
<code class="css">`display^p: `none^v</code>
になる
］ので、
作者は，自身の~stylesheetにおいて［
`見出されるまでは非可視$st 状態にある要素
］の［
`display$p, `content-visibility$p
］~propが変化しないようにすることが奨励される。
◎
Because this attribute is typically implemented using CSS, it's also possible to override it using CSS. For instance, a rule that applies 'display: block' to all elements will cancel the effects of the Hidden state. Authors therefore have to take care when writing their style sheets to make sure that the attribute is still styled as expected. In addition, legacy user agents which don't support the Hidden Until Found state will have 'display: none' instead of 'content-visibility: hidden', so authors are encouraged to make sure that their style sheets don't change the 'display' or 'content-visibility' properties of Hidden Until Found elements.
</p>

<p>
［
要素の `hidden$a 属性の状態 ~EQ `見出されるまでは非可視$st
］のときは，［
<code class="css">`display^p: `none^v</code>
に代えて
<code class="css">`content-visibility^p: `hidden^v</code>
が利用される
］ので、
そのような要素は，次に挙げるもの関して `非可視$st 状態にあるものと異なる：
◎
Since elements with the hidden attribute in the Hidden Until Found state use 'content-visibility: hidden' instead of 'display: none', there are two caveats of the Hidden Until Found state that make it different from the Hidden state:
</p>
<ul>
	<li>
当の要素が`~find-in-page$により露呈されるためには、
`~layout封込め$に影響される必要がある。
したがって、
要素の `display$p 値が［
`none^v ／ `contents^v ／ `inline^v
］にされた場合，
要素は`~find-in-page$により露呈されなくなる。
◎
The element needs to be affected by layout containment in order to be revealed by find-in-page. This means that if the element in the Hidden Until Found state has a 'display' value of 'none', 'contents', or 'inline', then the element will not be revealed by find-in-page.
</li>
	<li>
当の要素は、
依然として，`~boxを生成する＠~CSSDISP#propdef-visibility$
— すなわち、
要素の周りには［
~border, ~margin, ~padding
］が描画される。
◎
The element will still have a generated box when in the Hidden Until Found state, which means that borders, margin, and padding will still be rendered around the element.
</li>
</ul>
</div>

<div class="example">
<p>
次の略式的な例では、［
利用者が~log-inするまで，~web~gameの~main~screenを隠す
］ために，この属性が利用されている：
◎
In the following skeletal example, the attribute is used to hide the web game's main screen until the user logs in:
</p>

<pre class="lang-html">
&lt;h1&gt;The Example Game&lt;/h1&gt;
&lt;section id="login"&gt;
 &lt;h2&gt;Login&lt;/h2&gt;
 &lt;form&gt;
  ...
  &lt;!-- 利用者~資格を検査したなら， login() を~callする --&gt;
 &lt;/form&gt;
 &lt;script&gt;
  function login() {
    // ~screenを切り替える
    document.getElementById('login').hidden = true;
    document.getElementById('game').hidden = false;
  }
 &lt;/script&gt;
&lt;/section&gt;
&lt;section id="game" hidden&gt;
 ...
&lt;/section&gt;
</pre>
</div>

<!-- 
The Example Game
Login

calls login() once the user's credentials have been checked

// switch screens
-->
<p>
`hidden$a 属性は、［
他の呈示では正当に示され得るような内容に対し，それを隠す用途
］には，利用してはナラナイ。
例えば、［
~UItab化された~dialog内の~panelを隠す用途
］に `hidden$a を利用することは，不正である
— ~UItab化された~interfaceは，~overflow呈示の一種に過ぎず、
単に［
~scrollbarを伴う大きな~pageに すべての~form~controlを示すこと
］に同等なので。
類似に，この属性を［
ある呈示に限って内容を隠す用途
］に利用することは、
不正である
— `hidden$a 属性を有するものは、
~screen読取器も含め，すべての呈示から隠される。
◎
The hidden attribute must not be used to hide content that could legitimately be shown in another presentation. For example, it is incorrect to use hidden to hide panels in a tabbed dialog, because the tabbed interface is merely a kind of overflow presentation — one could equally well just show all the form controls in one big page with a scrollbar. It is similarly incorrect to use this attribute to hide content just from one presentation — if something is marked hidden, it is hidden from all presentations, including, for instance, screen readers.
</p>

<p>
`hidden$a 属性を有さない要素から，
`hidden$a 属性を有する要素へ`~hyperlink$してはナラナイ。
類似に，
`hidden$a 属性を有さない［
`label$e ／ `output$e
］要素の `for^a 属性は、
`hidden$a 属性を有する要素を指してはナラナイ。
いずれの参照も，利用者を惑わすことになるので。
◎
Elements that are not themselves hidden must not hyperlink to elements that are hidden. The for attributes of label and output elements that are not themselves hidden must similarly not refer to elements that are hidden. In both cases, such references would cause user confusion.
</p>

<p>
しかしながら，他の文脈においては、
要素や~scriptが `hidden$a 属性を有する要素を指すこともある。
◎
Elements and scripts may, however, refer to elements that are hidden in other contexts.
</p>

<div class="example">
<p>
例えば、
`href$a 属性の~link先に `hidden$a 属性を有する一節をアテガうことは，
不正になる。
当の内容が［
適用-可能でない／関連しない
］ならば、
そこへ~linkする理由はない。
◎
For example, it would be incorrect to use the href attribute to link to a section marked with the hidden attribute. If the content is not applicable or relevant, then there is no reason to link to it.
</p>

<p>
しかしながら、
ARIA `aria-describedby$a 属性を利用して `hidden$a 属性を有する記述を指すことは，
申し分ない。
記述を隠すことは，それ~~単独では有用でないことを含意するが、
ある要素についての記述を
— 当の要素から参照するなど —
特定の文脈において有用になる仕方で書くこともできるので。
◎
It would be fine, however, to use the ARIA aria-describedby attribute to refer to descriptions that are themselves hidden. While hiding the descriptions implies that they are not useful alone, they could be written in such a way that they are useful in the specific context of being referenced from the elements that they describe.
</p>

<p>
類似に、
~scriptによる~graphic~engineは，
`hidden$a 属性を有する `canvas$e 要素を~off-screen~bufferとして利用することもでき、
~form~controlの `form$a 属性は，
`hidden$a 属性を有する `form$e 要素を指すこともできる。
◎
Similarly, a canvas element with the hidden attribute could be used by a scripted graphics engine as an off-screen buffer, and a form control could refer to a hidden form element using its form attribute.
</p>
</div>

<p>
`hidden$a 属性を有する一節~内の要素であっても、
依然として作動中であり続ける
— 例：そのような一節~内の［
~script／~form~control
］は、
依然として［
実行される／提出される
］。
変化するのは、
利用者~向けの呈示に限られる。
◎
Elements in a section hidden by the hidden attribute are still active, e.g. scripts and form controls in such sections still execute and submit respectively. Only their presentation to the user changes.
</p>

<p>
`hidden@mE
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The hidden getter steps are:
</p>
		<ol>
			<li>
~IF［
コレの `hidden$a 属性の状態 ~EQ `見出されるまでは非可視$st
］
⇒
~RET "`until-found$v"
◎
If the hidden attribute is in the Hidden Until Found state, then return "until-found".
</li>
			<li>
~IF［
コレは `hidden$a 属性を有する
］
⇒
~RET ~T
◎
If the hidden attribute is set, then return true.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The hidden setter steps are:
</p>
		<ol>
			<li>
~IF［
所与の値は、
`~ASCII大小無視$で "`until-found$v" に合致する
］
⇒
コレの `hidden$a 属性の値 ~SET "`until-found$v"
◎
If the given value is a string that is an ASCII case-insensitive match for "until-found", then set the hidden attribute to "until-found".
</li>
			<li>
~ELIF［
所与の値 ~IN { ~F, 空~文字列, ~NULL, 0, NaN }
］
⇒
コレの `hidden$a 属性を除去する
◎
Otherwise, if the given value is false, then remove the hidden attribute.
◎
Otherwise, if the given value is the empty string, then remove the hidden attribute.
◎
Otherwise, if the given value is null, then remove the hidden attribute.
◎
Otherwise, if the given value is 0, then remove the hidden attribute.
◎
Otherwise, if the given value is NaN, then remove the hidden attribute.
</li>
			<li>
~ELSE
⇒
コレの `hidden$a 属性 ~SET 空~文字列
◎
Otherwise, set the hidden attribute to the empty string.
</li>
		</ol>
	</li>
</ul>

<p>
`先祖~露呈~pair@
は、
(
`~node@arP,
`文字列@arP
)
からなる`~tuple$である。
◎
An ancestor reveal pair is a tuple consisting of a node and a string.
</p>

<div class="algo">
<p>
`先祖を露呈する@
~algoは、
所与の
( ~node %~target )
に対し：
◎
The ancestor revealing algorithm given a node target is:
</p>
<ol>
	<li>
%露呈する先祖~群 ~LET « »
◎
Let ancestorsToReveal be « ».
</li>
	<li>
%先祖 ~LET %~target
◎
Let ancestor be target.
</li>
	<li>
<p>
~WHILE［
`平坦~tree$において %先祖 の親~nodeは在る
］
◎
While ancestor has a parent node within the flat tree:
</p>
		<ol>
			<li>
~IF［
%先祖 の `hidden$a 属性の状態 ~EQ `見出されるまでは非可視$st
］
⇒
%露呈する先祖~群 に ( %先祖, `until-found^l ) を`付加する$
◎
If ancestor has a hidden attribute in the Hidden Until Found state, then append (ancestor, "until-found") to ancestorsToReveal.
</li>
			<li>
<p>
~IF［
~AND↓ を満たす `details$e 要素が在る
］…
</p>
				<ul>
					<li>
`open$a 属性を有さない
</li>
					<li>
%先祖 は その `2 個目の~slot＠~HTMLrendering#_details-slots$の中に~slotされている
</li>
				</ul>
<p>
…ならば
⇒
%露呈する先祖~群 に
( %先祖 の親~node, `details^l )
を`付加する$
◎
If ancestor is slotted into the second slot of a details element which does not have an open attribute, then append (ancestor's parent node, "details") to ancestorsToReveal.
</p>
			</li>
			<li>
%先祖 ~SET `平坦~tree$における %先祖 の親~node
◎
Set ancestor to the parent node of ancestor within the flat tree.
</li>
		</ol>
	</li>
	<li>
<p>
%露呈する先祖~群 を成す
~EACH(  ( %露呈する先祖, %露呈~型 ) )
に対し：
◎
For each (ancestorToReveal, revealType) of ancestorsToReveal:
</p>
		<ol>
			<li>
~IF［
%露呈する先祖 は`接続されて$いない
］
⇒
~RET
◎
If ancestorToReveal is not connected, then return.
</li>
			<li>
<p>
~IF［
%露呈~型 ~EQ `until-found^l
］：
◎
If revealType is "until-found":
</p>
				<ol>
					<li>
~IF［
%露呈する先祖 の `hidden$a 属性の状態 ~NEQ `見出されるまでは非可視$st
］
⇒
~RET
◎
If ancestorToReveal's hidden attribute is not in the Hidden Until Found state, then return.
</li>
					<li>
`~eventを発火する$( %露呈する先祖, `beforematch$et )
— 次のように初期化して
⇒
`bubbles$m 属性 ~SET ~T
◎
Fire an event named beforematch at ancestorToReveal with the bubbles attribute initialized to true.
</li>
					<li>
~IF［
%露呈する先祖 は`接続されて$いない
］
⇒
~RET
◎
If ancestorToReveal is not connected, then return.
</li>
					<li>
~IF［
%露呈する先祖 の `hidden$a 属性の状態 ~NEQ `見出されるまでは非可視$st
］
⇒
~RET
◎
If ancestorToReveal's hidden attribute is not in the Hidden Until Found state, then return.
</li>
					<li>
%露呈する先祖 から `hidden$a 属性を除去する
◎
Remove the hidden attribute from ancestorToReveal.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~Assert：
%露呈~型 ~EQ `details^l
◎
Assert: revealType is "details".
</li>
					<li>
~IF［
%露呈する先祖 は `open$a 属性を有する
］
⇒
~RET
◎
If ancestorToReveal has an open attribute, then return.
</li>
					<li>
%露呈する先祖 の `open$a 属性の値 ~SET 空~文字列
◎
Set ancestorToReveal's open attribute to the empty string.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="page-visibility">
<h3 title="Page visibility">6.2. ~page可視性</h3>

<p>
`辿可能な~navigable$の`~system可視性~状態$navは、
~UAにより決定される
— 作成~時における初期~値も含めて。
それは、
例えば，次に挙げるいずれかに該当するかどうかを表現する
⇒＃
~browser~UIwindowは最小化されている／
~browser~UItabは現在は~~背後にある／
~task切替器などの~system要素が~pageを遮っている
◎
A traversable navigable's system visibility state, including its initial value upon creation, is determined by the user agent. It represents, for example, whether the browser window is minimized, a browser tab is currently in the background, or a system element such as a task switcher obscures the page.
</p>

<div class="algo">
<p>
~UAは、［
`辿可能な~navigable$ %辿可能 用の`~system可視性~状態$navが %新たな状態 に変化した
］ものと決定したときは，
次の手続きを走らすモノトスル：
◎
When a user agent determines that the system visibility state for traversable navigable traversable has changed to newState, it must run the following steps:
</p>
<ol>
	<li>
%~navigable群 ~LET %辿可能 にて`作動中な文書$navの`広義-子孫~navigable群$
◎
Let navigables be the inclusive descendant navigables of traversable's active document.
</li>
	<li>
<p>
%~navigable群 を成す
~EACH( %~navigable )
に対し
<span class="XXX">順序は？</span>：
◎
For each navigable of navigables in what order?:
</p>
		<ol>
			<li>
%文書 ~LET %~navigable にて`作動中な文書$nav
◎
Let document be navigable's active document.
</li>
			<li>
<p>
`大域~taskを~queueする$( `利用者ヤリトリ~task~source$, %文書 に`関連な大域~obj$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`可視性~状態を更新する$( %文書, %新たな状態 )
</div>
◎
Queue a global task on the user interaction task source given document's relevant global object to update the visibility state of document with newState.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
各`文書$は、
`可視性~状態@doc
を有する
— それは、［
`hidden^l ／ `visible^l
］いずれかをとり，
初期~時は `hidden^l に設定されるとする。
◎
A Document has a visibility state, which is either "hidden" or "visible", initially set to "hidden".
</p>

<div class="algo">
<p>
`visibilityState@m
取得子~手続きは
⇒
~RET コレの`可視性~状態$doc
◎
The visibilityState getter steps are to return this's visibility state.
</p>
</div>

<div class="algo">
<p>
`hidden@m
取得子~手続きは
⇒
~RET ~IS［
コレの`可視性~状態$doc ~EQ `hidden^l
］
◎
The hidden getter steps are to return true if this's visibility state is "hidden", otherwise false.
</p>
</div>

<div class="algo">
<p>
`可視性~状態を更新する@
~algoは、
所与の
( `文書$ %文書, %可視性~状態 )
に対し：
◎
To update the visibility state of Document document to visibilityState:
</p>
<ol>
	<li>
~IF［
%文書 の`可視性~状態$doc ~EQ %可視性~状態
］
⇒
~RET
◎
If document's visibility state equals visibilityState, then return.
</li>
	<li>
%文書 の`可視性~状態$doc ~SET %可視性~状態
◎
Set document's visibility state to visibilityState.
</li>
	<li>
%処理能~entry ~LET 新たな `VisibilityStateEntry$I
— その
⇒＃
`可視性~状態$vsE ~SET %可視性~状態,
`時刻印$vsE ~SET `現在の高分解能~時刻$( %文書 に`関連な大域~obj$ )
◎
Queue a new VisibilityStateEntry whose visibility state is visibilityState and whose timestamp is the current high resolution time given document's relevant global object.
</li>
	<li>
`処理能~entryを~queueする$( %処理能~entry )
◎
↑</li>
	<li>
`~screen方位~変更~手続き$( %文書 )
`SCREENORIENTATION$r
◎
Run the screen orientation change steps with document. [SCREENORIENTATION]
</li>
	<li>
`~view遷移の~page可視性~変化-時の手続き$( %文書 )
◎
Run the view transition page visibility change steps with document.
</li>
	<li>
<p>
他の仕様に定義される
`~page可視性~変化-時の手続き@
があれば、［
`可視性~状態$doc, %文書
］を与える下で，それらを走らす
◎
Run any page visibility change steps which may be defined in other specifications, with visibility state and document.
</p>

<p class="XXX">
これを書いている時点では、［
`DEVICEPOSTURE$r
`WEBNFC$r
］が，`~page可視性~変化-時の手続き$を~hookとして利用していることが知られているが、
それらが走る順序は，指定されていない。
そのような仕様は、
この~hookを利用する代わりに，その策定者が［
ここから直に自身の仕様の中へ~callする段を追加するための `pull request^en
］を送信する方が［
各~仕様にまたがって~callされる順序
］がきちんと定義されるので良いであろう。
◎
It would be better if specification authors sent a pull request to add calls from here into their specifications directly, instead of using the page visibility change steps hook, to ensure well-defined cross-specification call order. As of the time of this writing the following specifications are known to have page visibility change steps, which will be run in an unspecified order: Device Posture API and Web NFC. [DEVICEPOSTURE] [WEBNFC]
</p>
	</li>
	<li>
`~eventを発火する$( %文書, `visibilitychange$et )
— 次のように初期化して
⇒
`bubbles$m 属性 ~SET ~T
◎
Fire an event named visibilitychange at document, with its bubbles attribute initialized to true.
</li>
</ol>
</div>

			<section id="the-visibilitystateentry-interface">
<h4 title="The VisibilityStateEntry interface">6.2.1. `VisibilityStateEntry$I ~interface</h4>

<p>
`VisibilityStateEntry$I ~interfaceは、
文書が作動中になって以降における文書の可視性の変化を公開する。
◎
The VisibilityStateEntry interface exposes visibility changes to the document, from the moment the document becomes active.
</p>

<div class="example">
<p>
これは例えば、
~page内の~JS~codeが，可視性の変化と塗り計時との相関を精査することを許容する：
◎
For example, this allows JavaScript code in the page to examine correlation between visibility changes and paint timing:
</p>

<pre class="lang-js">
function wasHiddenBeforeFirstContentfulPaint() {
    const %fcpEntry = performance.getEntriesByName("first-contentful-paint")[0];
    const %visibilityStateEntries = performance.getEntriesByType("visibility-state");
    return %visibilityStateEntries.some(e =&gt;
        e.startTime &lt; %fcpEntry.startTime &amp;&amp;
        e.name === "hidden");
}
</pre>

</div>

<p class="note">注記：
~pageを隠すことは，描画~その他の~UA演算を間引かせ得るので、
可視性の変化を［
そのような間引きが生じたことの指示
］として利用することは，共通的にある。
しかしながら、
間引かせ得るものは，~browserに応じて他にもある
— 長期間，活動【利用者-ヤリトリ等】が無いなど。
◎
Since hiding a page can cause throttling of rendering and other user-agent operations, it is common to use visibility changes as an indication that such throttling has occurred. However, other things could also cause throttling in different browsers, such as long periods of inactivity.
</p>

<pre class="idl">
[Exposed=(Window)]
interface `VisibilityStateEntry@I : `PerformanceEntry$I {
  readonly attribute DOMString `name$m;                 /* <span class="comment">
継承した `name＠~TIMELINE#dom-performanceentry-name$m を隠蔽する
◎
shadows inherited name
</span> */
  readonly attribute DOMString `entryType$m;            /* <span class="comment">
継承した `entryType＠~TIMELINE#dom-performanceentry-entrytype$m を隠蔽する
◎
shadows inherited entryType
</span> */
  readonly attribute DOMHighResTimeStamp `startTime$m;  /* <span class="comment">
継承した `startTime＠~TIMELINE#dom-performanceentry-starttime$m を隠蔽する
◎
shadows inherited startTime
</span> */
  readonly attribute unsigned long `duration$m;         /* <span class="comment">
継承した `duration＠~TIMELINE#dom-performanceentry-duration$m を隠蔽する
◎
shadows inherited duration
</span> */
};
</pre>

<p>
各 `VisibilityStateEntry$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`時刻印@vsE
⇒
`DOMHighResTimeStamp$I 値
◎
The VisibilityStateEntry has an associated DOMHighResTimeStamp timestamp.
</li>
	<li>
`可視性~状態@vsE
⇒
`visible^l ／ `hidden^l
◎
The VisibilityStateEntry has an associated "visible" or "hidden" visibility state.
</li>
</ul>

<div class="algo">
`name@m
取得子~手続きは
⇒
~RET コレの`可視性~状態$vsE
◎
The name getter steps are to return this's visibility state.
</div>

<div class="algo">
`entryType@m
取得子~手続きは
⇒
~RET `visibility-state^l
◎
The entryType getter steps are to return "visibility-state".
</div>

<div class="algo">
`startTime@m
取得子~手続きは
⇒
~RET コレの`時刻印$vsE
◎
The startTime getter steps are to return this's timestamp.
</div>

<div class="algo">
`duration@m
取得子~手続きは
⇒
~RET 0
◎
The duration getter steps are to return zero.
</div>

			</section>
		</section>
		<section id="inert-subtrees">
<h3 title="Inert subtrees">6.3. 不活な下位tree</h3>

<p class="note">注記：
同じ名前【不活, `inert^en】の属性についての説明は、
`inert$a も見よ。
◎
See also inert for an explanation of the attribute of the same name.
</p>

<p>
~node（特に，要素／~text~node）は、
`不活@
にし得る。
~nodeが`不活$にされたときは：
◎
A node (in particular elements and text nodes) can be inert. When a node is inert:
</p>
<ul>
	<li>
接触判定は、［
`pointer-events$p ~CSS~propは `none^v に設定されていた
］かのように，動作するモノトスル。
◎
Hit-testing must act as if the 'pointer-events' CSS property were set to 'none'.
</li>
	<li>
~text選択の機能性は、［
`user-select$p ~CSS~propは `none^v に設定されていた
］かのように，動作するモノトスル
◎
Text selection functionality must act as if the 'user-select' CSS property were set to 'none'.
</li>
	<li>
当の~nodeが`編集-可能$である場合、
編集-可能でなかったかのように，挙動するモノトスル。
◎
If it is editable, the node behaves as if it were non-editable.
</li>
	<li>
~UAは、
`~find-in-page$の目的においては，当の~nodeを無視するベキである。
◎
The user agent should ignore the node for the purposes of find-in-page.
</li>
</ul>

<p class="note">注記：
`不活$な~nodeは、
一般に，~focusし得ない。
~UAは、
不活な~nodeを~accessibility~APIや支援技術に公開しない。
不活な~nodeのうち`~commandを定義する$ものも、
上で述べた方式では，利用者からは操作不能になる。
◎
Inert nodes generally cannot be focused, and user agents do not expose the inert nodes to accessibility APIs or assistive technologies. Inert nodes that are commands will become inoperable to users, in the manner described above.
</p>

<p>
しかしながら，~UAは、
`~find-in-page$と~text選択については，
上の制約を上書きすることを利用者に許容してもヨイ。
◎
User agents may allow the user to override the restrictions on find-in-page and text selection, however.
</p>

<p>
既定では、
~nodeは`不活$でない。
◎
By default, a node is not inert.
</p>

			<section id="modal-dialogs-and-inert-subtrees">
<h4 title="Modal dialogs and inert subtrees">6.3.1. ~modal~dialogと不活な下位tree</h4>

<p>
`文書$ %文書 の`上端~層$を成す最後の（最も手前に~~示される）要素【！subject】が `dialog$e 要素であるとき、
当の要素を指して，
%文書 を
`阻んでいる~modal~dialog@
という。
そのような要素 %dialog が在る間は、
%文書 に`接続されて$いる~nodeのうち［
%dialog と`平坦~tree$における その子孫
］以外は，`不活$になるモノトスル。
◎
A Document document is blocked by a modal dialog subject if subject is the topmost dialog element in document's top layer.＼
While document is so blocked, every node that is connected to document, with the exception of the subject element and its flat tree descendants, must become inert.
</p>

<p>
%dialog も `inert$a 属性を介して追加的に`不活$になり得るが、
それは，この属性が %dialog 自身に指定された場合に限られる
（すなわち、
%dialog は “先祖の不活 性から逃れる”
【 %dialog は、この属性を有さないならば，先祖が不活でも不活にならない】）。
`平坦~tree$における %dialog の各~子孫も，同様に`不活$になり得る。
◎
subject can additionally become inert via the inert attribute, but only if specified on subject itself (i.e., subject escapes inertness of ancestors); subject's flat tree descendants can become inert in a similar fashion.
</p>

<p class="note">注記：
`dialog$e 要素の `showModal()$m ~methodは、
要素の`~node文書$の`上端~層$に要素を`追加する＠~CSSPOS4#add-an-element-to-the-top-layer$ことにより，
この仕組みを誘発する。
◎
The dialog element's showModal() method causes this mechanism to trigger, by adding the dialog element to its node document's top layer.
</p>

			</section>
			<section id="the-inert-attribute">
<h4 title="The inert attribute">6.3.2. `inert^a 属性</h4>

<p>
`inert$a 属性は、
`真偽-属性$であり，在るならば次を指示する
⇒
当の要素, および［
`平坦~tree$における当の要素の子孫のうち［
“先祖の不活 性から逃れる” もの（~modal~dialogなど）以外のもの
］すべて
］は、
~UAにより`不活$にされる。
◎
The inert attribute is a boolean attribute that indicates, by its presence, that the element and all its flat tree descendants which don't otherwise escape inertness (such as modal dialogs) are to be made inert by the user agent.
</p>

<p>
`不活$な下位treeは、［
当の~pageを成す，不活~状態ではない側面
］を［
理解する／利用する
］ために~criticalな［
内容／~control
］を包含するベキでない。
不活な下位tree内の内容は、
どの利用者からも［
知覚-可能／ヤリトリ-可能
］になるとは限らない。
作者は、
要素が表現する内容が何らかの仕方で視覚的に遮られていない限り，
要素を不活として指定するベキでない。
ほとんどの事例では、
作者は，個々の~form~controlに対し `inert$a【！`不活$】 属性を指定するベキでない
— それらには、
`disabled$a 属性の方が，おそらく適切になる。
◎
An inert subtree should not contain any content or controls which are critical to understanding or using aspects of the page which are not in the inert state. Content in an inert subtree will not be perceivable by all users, or interactive. Authors should not specify elements as inert unless the content they represent are also visually obscured in some way. In most cases, authors should not specify the inert attribute on individual form controls. In these instances, the disabled attribute is probably more appropriate.
</p>

<div class="example">
<p>
次の例に，［
部分的に読込まれ，
“読込n中…” ~messageにより視覚的に遮られた内容
］を［
不活として~markする方法
］を示す。
◎
The following example shows how to mark partially loaded content, visually obscured by a "loading" message, as inert.
</p>

`inert-1^xCode

<p id="_dgm-inert-example-loading-section">
“Population by City” 内容の~screenshot
— そこには、［
上層を成す~message “読込n中…（ `Loading...^en ）
］があり，［
~form~controlや~data~tableなどの内容
］を視覚的に遮る。
内容は、
まだ全部的に描画されてないので，不活~状態にある。
◎
Screenshot of Population by City content with an overlaid loading message which visually obscures the form controls and data table which have not fully rendered, and thus are in the inert state.
</p>

<p>
上層を成す “読込n中…” は、
不活な内容を遮ることで，［
不活な内容が，~~現在~access可能でない
］ことを視覚的に~~明らかにする。
見出しと “読込n中…” ~textは、
`inert$a【！`不活$】 属性を有する要素の子孫でないことに注意。
これは、
どの利用者も［
この~textには~access可能になる一方で，不活な内容とはヤリトリし得ない
］ことを確保することになる。
◎
The "loading" overlay obscures the inert content, making it visually apparent that the inert content is not presently accessible. Notice that the heading and "loading" text are not descendants of the element with the inert attribute. This will ensure this text is accessible to all users, while the inert content cannot be interacted with by anyone.
</p>
</div>

<div class="note">
<p>注記：
既定では、［
要素／要素の下位tree
］が不活であることを持続的に視覚的に指示するものは無い。
そのような内容に適切な視覚的~styleは、
文脈に依存することが多い。
一例として、
~off-screen~navi~panelは，既定の~styleを要求しない
— その~off-screen位置は、
当の内容を視覚的に遮るので
【この “~off-screen” は、何を意味する？】。
類似に，~modalな `dialog$e 要素の後景は、
~web~pageを成す不活な内容を視覚的に遮るための手段として~serveすることになる
— 不活な内容を特定的に~styleするためではなく。
◎
By default, there is no persistent visual indication of an element or its subtree being inert. Appropriate visual styles for such content is often context-dependent. For instance, an inert off-screen navigation panel would not require a default style, as its off-screen position visually obscures the content. Similarly, a modal dialog element's backdrop will serve as the means to visually obscure the inert content of the web page, rather than styling the inert content specifically.
</p>

<p>
しかしながら，他の多くの状況~用には、
利用者-混同を避けるため，作者には［
自身の文書を成す［
どの部分が作動中か，どの部分が不活か
］を明瞭に~markする
］ことが強く奨励される。
特に、［
どの利用者も，~page全体を一度に見れる
］とは限らないことに留意すること
— 例えば、［
~screen読取器／小さな機器／拡大鏡
］の利用者，あるいは特に小さい~UIwindowを利用している利用者であっても，
~pageにて作動中な部分が見えてないかもしれず、
不活な一節が明白に不活でない場合，利用者をいらつかせるかもしれない。
◎
However, for many other situations authors are strongly encouraged to clearly mark what parts of their document are active and which are inert, to avoid user confusion. In particular, it is worth remembering that not all users can see all parts of a page at once; for example, users of screen readers, users on small devices or with magnifiers, and even users using particularly small windows might not be able to see the active part of a page and might get frustrated if inert sections are not obviously inert.
</p>
</div>

			</section>
		</section>
		<section id="tracking-user-activation">
<h3 title="Tracking user activation">6.4. 利用者-作動化の追跡-法</h3>

<p>
ある種の［
利用者に煩わしくもなり得る~API
］
（例：
`~popupを開く＠~WINDOW#apis-for-creating-and-navigating-browsing-contexts-by-name$,
スマホを`振動させる＠~VIBRATION$）
の濫用を防止するため、
~UAがこれらの~APIを許容するのは，利用者が~web~pageと［
能動的にヤリトリしている／一回以上はヤリトリした
］ときに限られる。
この “能動的なヤリトリ” の状態は、
この節に定義する仕組みを通して保守される。
◎
To prevent abuse of certain APIs that could be annoying to users (e.g., opening popups or vibrating phones), user agents allow these APIs only when the user is actively interacting with the web page or has interacted with the page at least once. This "active interaction" state is maintained through the mechanisms defined in this section.
</p>

			<section id="user-activation-data-model">
<h4 title="Data model">6.4.1. ~data~model</h4>

<p>
各`~window$ %~window には、
次に挙げる［
利用者-作動化を追跡する目的に関連な値
］がある：
◎
For the purpose of tracking user activation, each Window W has two relevant values:
</p>
<ul>
	<li>
<p>
`最後の作動化の時刻印@
⇒
`DOMHighResTimeStamp$I 型の値 ／ 正な無限大 ／ 負な無限大
— 初期~時は正な無限大とする。
</p>
		<ul>
			<li>
正な無限大は、
次を指示する
⇒
%~window は、
まだ作動化されたことがない。
</li>
			<li>
負な無限大は、
次を指示する
⇒
%~window に対する最後の`利用者-作動化を消費-$した。
</li>
		</ul>
◎
A last activation timestamp, which is either a DOMHighResTimeStamp, positive infinity (indicating that W has never been activated), or negative infinity (indicating that the activation has been consumed). Initially positive infinity.
</li>
	<li>
`最後の履歴~動作による作動化の時刻印@
⇒
`DOMHighResTimeStamp$I 型の値 ／ 正な無限大
— 初期~時は正な無限大とする。
◎
A last history-action activation timestamp, which is either a DOMHighResTimeStamp or positive infinity, initially positive infinity.
</li>
</ul>

<p>
~UAはまた，
`一過な作動化の所要時間@
を定義する。
それは、［
ある種の`利用者-作動化で通過制御される~API$（例：~popupを開く）
］用に［
利用者-作動化はどれだけ長く可用にされるか
］を指示する定数である。
◎
A user agent also defines a transient activation duration, which is a constant number indicating how long a user activation is available for certain user activation-gated APIs (e.g., for opening popups).
</p>

<p class="note">注記：
`一過な作動化の所要時間$は、
長くとも数秒までにすることが期待される
— 利用者が、
場合によっては［
~pageとのヤリトリ, 作動化で通過制御される~APIを~callしている~page
］の間の連関を知覚できるように。
◎
The transient activation duration is expected be at most a few seconds, so that the user can possibly perceive the link between an interaction with the page and the page calling the activation-gated API.
</p>

<p>
%~window には、
次に挙げる［
利用者-作動化に関する状態を含意する条件【！boolean】
］がある：
◎
We then have the following boolean user activation states for W:
</p>
<dl>
	<dt>
`居残な作動化を有して@
いる（ `have sticky activation^en ）
◎
Sticky activation
</dt>
	<dd>
次が満たされることをいう
⇒
%~window の`最後の作動化の時刻印$ ~LTE `現在の高分解能~時刻$( %~window )
◎
When the current high resolution time given W is greater than or equal to the last activation timestamp in W, W is said to have sticky activation.
</dd>
	<dd>
これは、［
利用者は，これまで %~window とヤリトリしたことがあるかどうか
］を指示する。
これは， %~window の履歴~上の作動化~状態であり、
有していない状態から開始して，
%~window が初めて`作動化を通知する$とき，有している状態に変化する
（また、
有していない状態へ戻ることは決してない）。
◎
This is W's historical activation state, indicating whether the user has ever interacted in W. It starts false, then changes to true (and never changes back to false) when W gets the very first activation notification.
</dd>

	<dt>
`一過な作動化を有して@
いる（ `have transient activation^en ）
◎
Transient activation
</dt>
	<dd>
次が満たされることをいう
⇒
%~window の`最後の作動化の時刻印$ ~LTE `現在の高分解能~時刻$( %~window ) ~LT ( %~window の`最後の作動化の時刻印$ ~PLUS `一過な作動化の所要時間$ )
◎
When the current high resolution time given W is greater than or equal to the last activation timestamp in W, and less than the last activation timestamp in W plus the transient activation duration, then W is said to have transient activation.
</dd>
	<dd>
これは、［
利用者は，近過去に %~window とヤリトリしたかどうか
］を指示する。
これは， %~window の現在の作動化~状態であり、
有していない状態から開始して，
%~window が`作動化を通知する$各回ごとに制限された時間だけ
有している状態であり続ける。
◎
This is W's current activation state, indicating whether the user has interacted in W recently. This starts with a false value, and remains true for a limited time after every activation notification W gets.
</dd>
	<dd>
`一過な作動化を有して$いる状態は、［
最後の利用者-作動化から`一過な作動化の所要時間$が経過して，そうでなくなったとき
］には，
`失効-@
したものと見なされる。
これは、
`作動化を消費する$ことを通して，失効~時刻より前に有していない状態へ戻り得ることに注意。
◎
The transient activation state is considered expired if it becomes false because the transient activation duration time has elapsed since the last user activation. Note that it can become false even before the expiry time through an activation consumption.
</dd>

	<dt>
`履歴~動作による作動化を有して@
いる
（ `have history-action activation^en ）
◎
History-action activation
</dt>
	<dd>
次が満たされることをいう
⇒
%~window の`最後の履歴~動作による作動化の時刻印$ ~NEQ %~window の`最後の作動化の時刻印$
◎
When the last history-action activation timestamp of W is not equal to the last activation timestamp of W, then W is said to have history-action activation.
</dd>
	<dd>
これは，利用者-作動化の特別な変種であり、
ある種の~session履歴~APIへの~accessを許容するために利用される
— そのような~APIは、
何度も続けて利用された場合，利用者は`~browser~UI＠~HTMLsl#nav-traversal-ui$を利用して~~後方へ辿ることが難しくなる。
これは、
有していない状態から開始して，
利用者が %~window とヤリトリしたとき有している状態になるが、
`履歴~動作による作動化を消費する$ことを通して，有していない状態へ戻る。
このことは、［
そのような~APIは、
利用者-作動化が介入しない限り，何度も続けて利用され得ない
］ことを確保する。
が、
`一過な作動化を有して$いるときと違って，そのような~APIを利用する際の時間~制限-は無い。
◎
This is a special variant of user activation, used to allow access to certain session history APIs which, if used too frequently, would make it harder for the user to traverse back using browser UI. It starts with a false value, and becomes true whenever the user interacts with W, but is reset to false through history-action activation consumption. This ensures such APIs cannot be used multiple times in a row without an intervening user activation. But unlike transient activation, there is no time limit within which such APIs must be used.
</dd>
</dl>

<p class="note">注記：
［
`最後の作動化の時刻印$, `最後の履歴~動作による作動化の時刻印$
］は、
当の`文書$が`全部的に作動中$かどうかが変化した後も維持される
（例：`文書$から 他へ~navigateした後／~cacheされた`文書$へ~navigateした後）。
このことは、［
`居残な作動化を有して$いる状態は、
同じ`文書$が再利用され続ける限り，複数回の~naviにまたがる
］ことを意味する。
対して，
`一過な作動化を有して$いる状態が`失効-$する時刻は、
変化しない
（すなわち、
元の`作動化を誘発する入力~event$から`一過な作動化の所要時間$までに失効する）。
ある種のものが［
`居残な作動化を有して$いるか否か, `一過な作動化を有して$いるか否か
］どちらに基づくか裁定するときは、
このことを考慮することが重要になる。
◎
The last activation timestamp and last history-action activation timestamp are retained even after the Document changes its fully active status (e.g., after navigating away from a Document, or navigating to a cached Document). This means sticky activation state spans multiple navigations as long as the same Document gets reused. For the transient activation state, the original expiry time remains unchanged (i.e., the state still expires within the transient activation duration limit from the original activation triggering input event). It is important to consider this when deciding whether to base certain things off sticky activation or transient activation.
</p>

			</section>
			<section id="user-activation-processing-model">
<h4 title="Processing model">6.4.2. 処理~model</h4>

<div class="algo">
<p>
利用者-ヤリトリの結果，［
`文書$ %文書 に向けて，`作動化を誘発する入力~event$が発火される
］ことになる場合、
~UAは
— `~eventを配送する$より`前に^em —
次に与える
`作動化を通知する@
手続きを遂行するモノトスル：
◎
When a user interaction causes firing of an activation triggering input event in a Document document, the user agent must perform the following activation notification steps before dispatching the event:
</p>
<ol>
	<li>
~Assert：
%文書 は`全部的に作動中$である。
◎
Assert: document is fully active.
</li>
	<li>
%~window群 ~LET « %文書 に`関連な大域~obj$ »
◎
Let windows be « document's relevant global object ».
</li>
	<li>
<p>
%文書 の`先祖~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
%~window群 に %~navigable にて`作動中な~window$nav を`付加する$
◎
Extend windows with the active window of each of document's ancestor navigables.
</li>
	<li>
%文書 の`子孫~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
~IF［
( `作動中な文書$navの`生成元$doc, %文書 の`生成元$doc )
は`同一-生成元$である
］
⇒
%~window群 に %~navigable にて`作動中な~window$nav を`付加する$
◎
Extend windows with the active window of each of document's descendant navigables, filtered to include only those navigables whose active document's origin is same origin with document's origin.
</li>
	<li>
<p>
%~window群 を成す
~EACH( %~window )
に対し：
◎
For each window in windows:
</p>
		<ol>
			<li>
%~window の`最後の作動化の時刻印$ ~SET `現在の高分解能~時刻$
◎
Set window's last activation timestamp to the current high resolution time.
</li>
			<li>
`利用者-作動化について閉-注視器~管理器に通知する$( %~window )
◎
Notify the close watcher manager about user activation given window.
</li>
		</ol>
	</li>
</ol>
</div>

<div>
<p>
所与の~event %~event が
`作動化を誘発する入力~event@
であるとは、
次が満たされることをいう
⇒
［
%~event の `isTrusted$m ~EQ ~T
］~AND［
次の表tを成す ある行に関して，次が満たされる
］
⇒
［
%~event の `type$m ~EQ 行の 1 列目に挙げる値
］~AND［
行の 2 列目に挙げる条件は満たされる
］
</p>

<table><thead>
<tr><th>`type$m
<th>条件
<tbody>

<tr><td>"`keydown$et"
<td>当の~UIkeyは、
`Esc^Key ~UIkeyでも ~UAにより予約された~shortcut~UIkeyでもない

<tr><td>"`mousedown$et"
<td>無条件

<tr><td>"`pointerdown$et"
<td>%~event の `pointerType$m ~EQ `mouse^l

<tr><td>"`pointerup$et"
<td>%~event の `pointerType$m ~NEQ `mouse^l

<tr><td>"`touchend$et"
<td>無条件
</table>
◎
An activation triggering input event is any event whose isTrusted attribute is true and whose type is one of:
• "keydown", provided the key is neither the Esc key nor a shortcut key reserved by the user agent;
• "mousedown";
• "pointerdown", provided the event's pointerType is "mouse";
• "pointerup", provided the event's pointerType is not "mouse"; or
• "touchend".
</div>

<div class="algo">
<p>
［
この仕様／他の仕様
］にて定義される`一過な作動化を消費する~API$は、
`利用者-作動化を消費-@
し得る
— それは、
所与の
( `~window$ %~window )
に対し，次の手続きを遂行する：
◎
Activation consuming APIs defined in this and other specifications can consume user activation by performing the following steps, given a Window W:
</p>
<ol>
	<li>
~IF［
%~window に`対応する~navigable$ ~EQ ~NULL
］
⇒
~RET
◎
If W's navigable is null, then return.
</li>
	<li>
%~window に`対応する~navigable$の`~top-level辿可能$navにて`作動中な文書$navの`広義-子孫~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
%~navigable にて`作動中な~window$navの`最後の作動化の時刻印$ ~SET 負な無限大
◎
Let top be W's navigable's top-level traversable.
◎
Let navigables be the inclusive descendant navigables of top's active document.
◎
Let windows be the list of Window objects constructed by taking the active window of each item in navigables.
◎
For each window in windows, if window's last activation timestamp is not positive infinity, then set window's last activation timestamp to negative infinity.
</li>
</ol>
</div>

<div class="algo">
<p>
`履歴~動作による作動化を消費する~API$は、
`履歴~動作による作動化を消費-@
し得る
— それは、
所与の
( `~window$ %~window )
に対し，次の手続きを遂行する：
◎
History-action activation-consuming APIs can consume history-action user activation by performing the following steps, given a Window W:
</p>
<ol>
	<li>
~IF［
%~window に`対応する~navigable$ ~EQ ~NULL
］
⇒
~RET
◎
If W's navigable is null, then return.
</li>
	<li>
%~window に`対応する~navigable$の`~top-level辿可能$navにて`作動中な文書$navの`広義-子孫~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
%~navigable にて`作動中な~window$navの`最後の履歴~動作による作動化の時刻印$ ~SET %~window の`最後の作動化の時刻印$
◎
Let top be W's navigable's top-level traversable.
◎
Let navigables be the inclusive descendant navigables of top's active document.
◎
Let windows be the list of Window objects constructed by taking the active window of each item in navigables.
◎
For each window in windows, set window's last history-action activation timestamp to window's last activation timestamp.
</li>
</ol>
</div>

<p class="note">注記：
~page内の`閲覧~文脈$のうち［
`作動化を通知する$ことにより影響されるものたちが成す集合
］と［
`作動化を消費する$ことにより影響されるものたちが成す集合
］は、
非対称であることに注意：
作動化を消費したときは，［
~page内のすべての閲覧~文脈は，`一過な作動化を有して$いない状態
］へ変化するが、
作動化を通知したときは，［
それらのうち一部の閲覧~文脈に限り，`一過な作動化を有して$いる状態
］へ変化する。
ここでの消費が資質において網羅的であることは故意であり、
悪意的な~siteが
（場合によっては、
`iframe$e たちが成す深い階層を悪用することにより）［
一回の利用者-作動化に対し，`一過な作動化を消費する~API$を複数回~callする
］ことを防止するためである。
◎
Note the asymmetry in the sets of browsing contexts in the page that are affected by an activation notification vs an activation consumption: an activation consumption changes (to false) the transient activation states for all browsing contexts in the page, but an activation notification changes (to true) the states for a subset of those browsing contexts. The exhaustive nature of consumption here is deliberate: it prevents malicious sites from making multiple calls to an activation consuming API from a single user activation (possibly by exploiting a deep hierarchy of iframes).
</p>

			</section>
			<section id="user-activation-gated-apis">
<h4 title="APIs gated by user activation">6.4.3. 利用者-作動化で通過制御される~API</h4>

<p>
利用者-作動化に依存する~APIは、
次に挙げる~levelに類別される
◎
APIs that are dependent on user activation are classified into different levels:
</p>
<dl>
	<dt>
`居残な作動化で通過制御される~API@
◎
Sticky activation-gated APIs
</dt>
	<dd>
これらの~APIは、
`居残な作動化を有して$いることを要求する
— なので，利用者-作動化が初めて生じるまでは、
阻止される。
◎
These APIs require the sticky activation state to be true, so they are blocked until the very first user activation.
</dd>

	<dt>
`一過な作動化で通過制御される~API@
◎
Transient activation-gated APIs
</dt>
	<dd>
これらの~APIは、
`一過な作動化を有して$いることを要求するが，`利用者-作動化を消費-$しない
— なので，一過な状態が`失効-$するまでは、
一回の利用者-作動化に対し複数回の~callが許容される。
◎
These APIs require the transient activation state to be true, but they don't consume it, so multiple calls are allowed per user activation until the transient state expires.
</dd>

	<dt>
`一過な作動化を消費する~API@
◎
Transient activation-consuming APIs
</dt>
	<dd>
これらの~APIは、
`一過な作動化を有して$いることを要求することに加え、
各~callごとに`利用者-作動化を消費-$することにより，
一回の利用者-作動化に対する複数回の~callを防止する。
◎
These APIs require the transient activation state to be true, and they consume user activation in each call to prevent multiple calls per user activation.
</dd>

	<dt>
`履歴~動作による作動化を消費する~API@
◎
History-action activation-consuming APIs
</dt>
	<dd>
これらの~APIは、
`履歴~動作による作動化を有して$いることを要求することに加え、
各~callごとに`履歴~動作による作動化を消費する$ことにより，
一回の利用者-作動化に対する複数回の~callを防止する。
◎
These APIs require the history-action activation state to be true, and they consume history-action user activation in each call to prevent multiple calls per user activation.
</dd>
</dl>

			</section>
			<section id="the-useractivation-interface">
<h4 title="The UserActivation interface">6.4.4. `UserActivation^I ~interface</h4>

<p>
各`~window$ %~window には、
それに
`結付けられた~UserActivation@
がある
— それは、
ある `UserActivation$I ~objである。
%~window の作成~時には、
%~window に`結付けられた~UserActivation$を次の結果に設定するモノトスル
⇒
`新たな~obj$( `UserActivation$I, %~window に`関連な~realm$ )
◎
Each Window has an associated UserActivation, which is a UserActivation object. Upon creation of the Window object, its associated UserActivation must be set to a new UserActivation object created in the Window object's relevant realm.
</p>

<pre class="idl">
[Exposed=Window]
interface `UserActivation@I {
  readonly attribute boolean `hasBeenActive$m;
  readonly attribute boolean `isActive$m;
};

partial interface <dfn id="NavigatorUserActivation-partial">`Navigator$I</dfn> {
  [SameObject] readonly attribute `UserActivation$I `userActivation$m;
};
</pre>

<dl class="domintro">
	<dt>`navigator$m.`userActivation$m.`hasBeenActive$m</dt>
	<dd>
当の~windowが`居残な作動化を有して$いるか否かを返す。
◎
Returns whether the window has sticky activation.
</dd>

	<dt>`navigator$m.`userActivation$m.`isActive$m</dt>
	<dd>
当の~windowは`一過な作動化を有して$いるか否かを返す。
◎
Returns whether the window has transient activation.
</dd>
</dl>

<div class="algo">
`userActivation@m
取得子~手続きは
⇒
~RET コレに`関連な大域~obj$に`結付けられた~UserActivation$
◎
The userActivation getter steps are to return this's relevant global object's associated UserActivation.
</div>

<div class="algo">
`hasBeenActive@m
取得子~手続きは
⇒
~RET ~IS［
コレに`関連な大域~obj$は`居残な作動化を有して$いる
］
◎
The hasBeenActive getter steps are to return true if this's relevant global object has sticky activation, and false otherwise.
</div>

<div class="algo">
`isActive@m
取得子~手続きは
⇒
~RET ~IS［
コレに`関連な大域~obj$は`一過な作動化を有して$いる
］
◎
The isActive getter steps are to return true if this's relevant global object has transient activation, and false otherwise.
</div>

			</section>
			<section id="user-activation-user-agent-automation">
<h4 title="User agent automation">6.4.5. ~UAの自動化</h4>

<p>
この仕様は、［
~UAを自動化する／~appを~testする
］目的で，
`WEBDRIVER$r 用に次の`拡張~command$を定義する
— ~UAがこの拡張~commandを~supportするのは、
任意選択である：
◎
For the purposes of user-agent automation and application testing, this specification defines the following extension command for the Web Driver specification. It is optional for a user agent to support the following extension command. [WEBDRIVER]
</p>

<div>
<table><thead>
<tr><th>
~HTTP~method
<th>~URI~template
<tbody>

<tr><td>`POST^M
<td>`/session/{<var>session id</var>}/window/consume-user-activation^c
</table>

◎
HTTP Method｜URI Template
`POST`｜/session/{session id}/window/consume-user-activation
</div>

<div class="algo">
<p>
この拡張~command用の`~remote端~手続き$は：
◎
The remote end steps are:
</p>
<ol>
	<li>
%~window ~LET `現在の閲覧~文脈$にて`作動中な~window$bc
◎
Let window be the current browsing context's active window.
</li>
	<li>
%消費するか ~LET ~IS［
%~window は`一過な作動化を有して$いる
］
◎
Let consume be true if window has transient activation; otherwise false.
</li>
	<li>
~IF［
%消費するか ~EQ ~T
］
⇒
%~window に対する`利用者-作動化を消費-$する
◎
If consume is true, then consume user activation of window.
</li>
	<li>
~RET 新たな`成功$
— その
⇒
~data ~SET %消費するか
◎
Return success with data consume.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="activation">
<h3 title="Activation behavior of elements">6.5. 要素が有する作動化の挙動</h3>

<p>
~HTMLにおける ある種の要素は、
`作動化の挙動$を有する
— すなわち、
利用者は それを作動化できる。
これは、
常に `click$et ~eventにより生じる。
◎
Certain elements in HTML have an activation behavior, which means that the user can activate them. This is always caused by a click event.
</p>

<p>
~UAは、
`作動化の挙動$を有する要素を手動で
— 一例として、
~keyboardや声~入力を利用したり，~mouse~clickを通して —
誘発することを利用者に許容するベキである。
利用者が，
`作動化の挙動$が定義されている要素を~click以外の方式で誘発したときは、
ヤリトリ~eventの既定の動作においては，
要素に向けて`~click~eventを発火する$モノトスル。
◎
The user agent should allow the user to manually trigger elements that have an activation behavior, for instance using keyboard or voice input, or through mouse clicks. When the user triggers an element with a defined activation behavior in a manner other than clicking it, the default action of the interaction event must be to fire a click event at the element.
</p>

<dl class="domintro">
	<dt>%element.`click()$m</dt>
	<dd>
要素が~clickされたかのように動作させる。
◎
Acts as if the element was clicked.
</dd>
</dl>

<p>
各~要素には
`~clickは進捗-中か@
が結付けられ、
初期~時は ~F をとるとする。
◎
Each element has an associated click in progress flag, which is initially unset.
</p>

<div class="algo">
<p>
`click()@m
~method手続きは：
◎
The click() method must run the following steps:
</p>
<ol>
	<li>
コレは`不能化されて$feいる~form~controlである
⇒
~RET
◎
If this element is a form control that is disabled, then return.
</li>
	<li>
~IF［
コレの`~clickは進捗-中か$ ~EQ ~T
］
⇒
~RET
◎
If this element's click in progress flag is set, then return.
</li>
	<li>
コレの`~clickは進捗-中か$ ~SET ~T
◎
Set this element's click in progress flag.
</li>
	<li>
`合成な~pointer~eventを発火する$( コレ, `click^et, `~trustされない^i )
◎
Fire a synthetic pointer event named click at this element, with the not trusted flag set.
</li>
	<li>
コレの`~clickは進捗-中か$ ~SET ~F
◎
Unset this element's click in progress flag.
</li>
</ol>
</div>

			<section id="the-toggleevent-interface">
<h4 title="The ToggleEvent interface">6.5.1. `ToggleEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `ToggleEvent@I : `Event$I {
  constructor(DOMString type, optional `ToggleEventInit$I %eventInitDict = {});
  readonly attribute DOMString `oldState$m;
  readonly attribute DOMString `newState$m;
  readonly attribute `Element$I? `source$m1;
};

dictionary `ToggleEventInit@I : `EventInit$I {
  DOMString oldState = "";
  DOMString newState = "";
  `Element$I? source = null;
};
</pre>

<dl class="domintro">
	<dt>%event.`oldState$m</dt>
	<dd>
［
閉な状態から開な状態へ遷移しているときは `closed^l ／
逆へ遷移しているときは `open^l
］に設定される。
◎
Set to "closed" when transitioning from closed to open, or set to "open" when transitioning from open to closed.
</dd>

	<dt>%event.`newState$m</dt>
	<dd>
［
開な状態から閉な状態へ遷移しているときは `closed^l ／
逆へ遷移しているときは `open^l
］に設定される。
◎
Set to "open" when transitioning from closed to open, or set to "closed" when transitioning from open to closed.
</dd>

	<dt>%event.`source$m1</dt>
	<dd>
当の~toggleを起動した要素は［
在るならば それ／
無いならば ~NULL
］に設定される
— それは、［
`popovertarget$a, `commandfor$a
］属性で設定しておける。
◎
Set to the element which initiated the toggle, which can be set up with the popovertarget and commandfor attributes. If there is no source element, then it is set to null.
</dd>
</dl>

<p>
`oldState@m
／
`newState@m
属性は、
初期化~時の値を返すモノトスル。
◎
The oldState and newState attributes must return the values they are initialized to.
</p>

<div class="algo">
<p>
`source@m1
取得子~手続きは
⇒
~RET `source$m1 をコレの `currentTarget$m に向けて`~targetし直す$
◎
The source getter steps are to return the result of retargeting source against this's currentTarget.
</p>

<p class="XXX">
`~DOM標準の課題 #1328＠https://github.com/whatwg/dom/issues/1328$
は、
~eventに結付けられた~dataを `Event^I 上で もっと良くイミを成す仕方で標準~化する方法を追跡する。
現時点では、［
ある値へ初期化された~event属性は，取得子も有すること【？】ができない
］ので［
ある内部~slot（あるいは追加的な~fieldたちが成す~map）で，これを適正に指定する
］ことが要求される。
◎
DOM standard issue #1328 tracks how to better standardize associated event data in a way which makes sense on Events. Currently an event attribute initialized to a value cannot also have a getter, and so an internal slot (or map of additional fields) is required to properly specify this.
</p>
</div>

<p>
`~toggle~task追跡子@
（ `toggle task tracker^en ）は、
`構造体$であり，次に挙げる`~item$sctを伴う：
◎
A toggle task tracker is a struct which has:
</p>
<ul>
	<li>
`~task@tTk
⇒
`ToggleEvent$I を発火する`~task$
◎
task
• A task which fires a ToggleEvent.
</li>
	<li>
`旧-状態@tTk
⇒
`~task$tTkが発火する~eventの `oldState$m 属性用の値を表現する文字列
◎
old state
• A string which represents the task's event's value for the oldState attribute.
</li>
</ul>

			</section>
			<section id="the-commandevent-interface">
<h4 title="The CommandEvent interface">6.5.2 `CommandEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `CommandEvent@I : `Event$I {
  constructor(DOMString type, optional `CommandEventInit$I %eventInitDict = {});
  readonly attribute Element? `source$m;
  readonly attribute DOMString `command$m;
};

dictionary `CommandEventInit@I : `EventInit$I {
  Element? source = null;
  DOMString command = "";
};
</pre>

<dl class="domintro">
	<dt>%event . `command$m</dt>
	<dd>
当の要素がとり得る動作を返す。
◎
Returns what action the element can take.
</dd>

	<dt>%event . `source$m</dt>
	<dd>
この~eventを生じさせるためにヤリトリされた`要素$を返す。
◎
Returns the Element that was interacted with in order to cause this event.
</dd>
</dl>

<p>
`command@m
取得子~手続きは、
初期化-時の値を返す。
◎
The command attribute must return the value it was initialized to.
</p>

<div class="algo">
<p>
`source@m
取得子~手続きは
⇒
~RET `source$m をコレの `currentTarget$m に向けて`~targetし直す$
◎
The source getter steps are to return the result of retargeting source against this's currentTarget.
</p>

<p class="XXX">
`~DOM標準の課題 #1328＠https://github.com/whatwg/dom/issues/1328$
は、
~eventに結付けられた~dataを `Event^I 上で もっと良くイミを成す仕方で標準~化する方法を追跡する。
現時点では、［
ある値へ初期化された~event属性は，取得子も有すること【？】ができない
］ので［
ある内部~slot（あるいは追加的な~fieldたちが成す~map）で，これを適正に指定する
］ことが要求される。
◎
DOM standard issue #1328 tracks how to better standardize associated event data in a way which makes sense on Events. Currently an event attribute initialized to a value cannot also have a getter, and so an internal slot (or map of additional fields) is required to properly specify this.
</p>
</div>

			</section>
		</section>
		<section id="focus">
<h3 title="Focus">6.6. ~focus</h3>

			<section id="introduction-8">
<h4 title="Introduction">6.6.1. 序論</h4>

◎非規範的

<p>
~HTML~UIは、
概して複数個のヤリトリありな~widgetからなる
—
~form~control,
~scroll可能な領域,
~link,
~dialog~box,
~browser~UItab,
などなど。
これらの~widgetは、
あるもの（例： ~browser~UItab, ~dialog~box）が他のもの（例： ~link, ~form~control）を包含しているような，階層を形成する。
◎
An HTML user interface typically consists of multiple interactive widgets, such as form controls, scrollable regions, links, dialog boxes, browser tabs, and so forth. These widgets form a hierarchy, with some (e.g. browser tabs, dialog boxes) containing others (e.g. links, form controls).
</p>

<p>
~keyboard~UIによるヤリトリ-時の~UIkey入力は、
~systemからヤリトリありな~widgetの階層を経由して，`~focusされて$いる作動中な~widgetにたどり着く。
◎
When interacting with an interface using a keyboard, key input is channeled from the system, through the hierarchy of interactive widgets, to an active widget, which is said to be focused.
</p>

<div class="example">
<p>
~graphicな環境~内で走っている~browser~UItab内で走っている~HTML~appを考える。
この~appの~pageには，いくつかの~text~controlや~linkがあり、
~modal~dialogを現在は示していて，その中にも~text~controlや~buttonがあるとする。
この局面における~focus可能な~widgetの階層は、
次のようになる：
◎
Consider an HTML application running in a browser tab running in a graphical environment. Suppose this application had a page with some text controls and links, and was currently showing a modal dialog, which itself had a text control and a button.
</p>

<p>
先ず，~browser~UIwindowを含む ①
⇒
~UIwindowは、
その子として，~HTML~appを包含している~browser~UItabを有する ②
⇒
~UItabは、
その子として，前述の~dialogの他に種々の~linkや~text~controlを有する ③
⇒
~dialogは、
その子として，~text~controlや~buttonを有する ④
◎
The hierarchy of focusable widgets, in this scenario, would include the browser window, which would have, amongst its children, the browser tab containing the HTML application. The tab itself would have as its children the various links and text controls, as well as the dialog. The dialog itself would have as its children the text control and the button.
</p>

<p id="_dgm-focus-tree">
この例において`~focusされて$いる~widgetが~dialog~box内の~text~controlであった場合、
~UIkey入力は［
~graphicな~system →
① ~web~browser →
② ~UItab →
③ ~dialog →
④ ~text~control
］の順に経由することになる。
◎
If the widget with focus in this example was the text control in the dialog box, then key input would be channeled from the graphical system to ① the web browser, then to ② the tab, then to ③ the dialog, and finally to ④ the text control.
</p>
</div>

<p>
~keyboard~eventは、
常に，この`~focusされて$いる要素を~targetにする。
◎
Keyboard events are always targeted at this focused element.
</p>

			</section>
			<section id="data-model">
<h4 title="Data model">6.6.2. ~data~model</h4>

<p>
所与の`~top-level辿可能$ %辿可能 は：
◎
↓</p>
<ul>
	<li>
<p>
`~system~focus@
を有しているとは、
次を満たしていることをいう
⇒
%辿可能 は~OSから経由された~keyboard入力を受取れる
◎
A top-level traversable has system focus when it can receive keyboard input channeled from the operating system,＼
</p>

<p>
このときは、
場合によっては，［
%辿可能 にて`作動中な文書$navの`子孫~navigable群$を成す ある`~navigable$
］が そのような入力の~targetになる。
◎
possibly targeted at one of its active document's descendant navigables.
</p>
	</li>
	<li>
<p>
`利用者の注目@
を有しているとは、
~AND↓ を満たしていることをいう
</p>
		<ul>
			<li>
%辿可能 の`~system可視性~状態$nav ~EQ `visible^l
</li>
			<li>
<p>
~OR↓
</p>
				<ul>
					<li>
%辿可能 は`~system~focus$を有している
</li>
					<li>
%辿可能 に直に関係する~UA~widgetが在って，
それは~OSから経由された~keyboard入力を受取れる
</li>
				</ul>
			</li>
		</ul>
◎
A top-level traversable has user attention when its system visibility state is "visible", and it either has system focus or user agent widgets directly related to it can receive keyboard input channeled from the operating system.
</li>
</ul>

<p class="note">注記：
`利用者の注目$は、
~browser~UIwindowが~focusを失ったときには失われる。
一方で，`~system~focus$は、
~browser~UIwindow内の他の~system~widget
— ~URL~barなど —
が~focusを得るに伴い失われることもある。
◎
User attention is lost when a browser window loses focus, whereas system focus might also be lost to other system widgets in the browser window such as a location bar.
</p>

<p>
所与の`文書$が
`~top-level辿可能にて全部的に作動中かつ利用者の注目を有している子孫@
であるとは、
~AND↓ を満たしていることをいう：
◎
A Document d is a fully active descendant of a top-level traversable with user attention when＼
</p>
<ul>
	<li>
`全部的に作動中$である
◎
d is fully active and＼
</li>
	<li>
その`~node~navigable$の`~top-level辿可能$navは、
`利用者の注目$を有している
◎
d's node navigable's top-level traversable has user attention.
</li>
</ul>

<p>
用語
`~focus可能な区画@
は、
~UIを成す領域のうち，~keyboard入力などの~targetにもなり得るものを指す。
［
要素／要素の一部分／その他の~UAにより管理される領域
］は、
~focus可能な区画になり得る。
◎
The term focusable area is used to refer to regions of the interface that can further become the target of such keyboard input. Focusable areas can be elements, parts of elements, or other regions managed by the user agent.
</p>

<p>
各 `~focus可能な区画$ %区画 は、
`~DOM~anchor@
を有する
— それは、
%区画 の~DOMにおける位置を表現する `Node$I ~objである
（ %区画 自体が `Node$I であるときは、
それがそのまま`~DOM~anchor$になる）。
`~DOM~anchor$は、
%区画 を表現する~DOM~objが他に無いときに，
一部の~APIにより`~focus可能な区画$の代用として利用される。
◎
Each focusable area has a DOM anchor, which is a Node object that represents the position of the focusable area in the DOM. (When the focusable area is itself a Node, it is its own DOM anchor.) The DOM anchor is used in some APIs as a substitute for the focusable area when there is no other DOM object to represent the focusable area.
</p>

<p class="trans-note">【
以下に現れる，`~focus可能な区画$が “属する`文書$” という句は、
当の区画の`~DOM~anchor$の`~node文書$を指す。
】</p>

<p>
次の表tの 1 列目に、
どの~objが`~focus可能な区画$になり得るかを述べる。
対応する`~DOM~anchor$を表tの 2 列目に述べる。
◎
The following table describes what objects can be focusable areas. The cells in the left column describe objects that can be focusable areas; the cells in the right column describe the DOM anchors for those elements. (The cells that span both columns are non-normative examples.)
</p>

<table id="table-fa"><thead>
<tr><th>`~focus可能な区画$
<th id="th-fa-dom-rep">`~DOM~anchor$
<tr><th colspan="2">
<div class="example">
<i>左右列にまたがるセルには、
例を示す。</i></div>

<tbody><tr><th id="td-fa-1">
<p>
~AND↓ を満たす要素：
◎
Elements that meet all the following criteria:
</p>
		<ul>
			<li>
［
その`~tabindex値$ ~NEQ ~NULL
］~OR［
~UAは、
それを~focus可能であると決定した
］
◎
the element's tabindex value is non-null, or the element is determined by the user agent to be focusable;
</li>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
`~shadow~host$でない
</li>
					<li>
［
その`~shadow根$el ~NEQ ~NULL
］~AND［
その`~shadow根$elの`~focusを委任するか$sR ~EQ ~F
］
</li>
				</ul>
◎
the element is either not a shadow host, or has a shadow root whose delegates focus is false;
</li>
			<li>
`実際に不能化-$されていない
◎
the element is not actually disabled;
</li>
			<li>
`不活$でない
◎
the element is not inert;
</li>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
`具現化されて$いる
</li>
					<li>
`その具現化を子へ委任して$いる
</li>
					<li>
`関連な~canvas~fallback内容として利用-中にある＠~HEcanvas#being-used-as-relevant-canvas-fallback-content$
</li>
				</ul>
◎
the element is either being rendered, delegating its rendering to its children, or being used as relevant canvas fallback content.
</li>
		</ul>

<td>
当の要素
◎
The element itself.
<tr><td colspan="2">

<div class="example">
<ul>
	<li>
`iframe$e
</li>
	<li>
`dialog$e
</li>
	<li>
`&lt;input type=text&gt;＠~HEinput#text-(type=text)-state-and-search-state-(type=search)$e,
</li>
	<li>
場合によっては（~platform規約に依存する）
`&lt;a href="…"&gt;＠~HEtextlevel#the-a-element$e
</li>
</ul>
◎
iframe, dialog, &lt;input type=text&gt;, sometimes &lt;a href=""&gt; (depending on platform conventions).
</div>

<tbody><tr><th id="td-fa-2">
<p>
`画像~map$内の
`~focus可能な図形@
— そのような図形は、
~AND↓ を満たす
( `area$e 要素 %area , `img$e 要素 %img )
が成す各~pairごとに作成される：
</p>
<ul>
	<li>
%img は、
その `usemap^a 属性を通して %area の親である `map^e 要素を指している
</li>
	<li>
%img は、
`具現化されて$いる, かつ`不活$でない
</li>
</ul>

<p class="trans-note">【
以下では、
%area を指して
“図形を`定義している^i `area$e 要素”，
%img を指して
“図形が`属する^i `img$e 要素”
と記すことにする。
】</p>

◎
The shapes of area elements in an image map associated with an img element that is being rendered and is not inert.
<td>
当の図形が属する `img$e 要素
◎
The img element.
<tr><td colspan="2">

<div class="example">
<p>
次の例の `area$e 要素は、［
その親である `map^e 要素への参照を通して それを利用している各 `img$e 要素
］ごとに 1 個ずつ，計 2 個の図形を作成する。
各~図形の`~DOM~anchor$は、
参照元の `img^e 要素になる。
◎
In the following example, the area element creates two shapes, one on each image. The DOM anchor of the first shape is the first img element, and the DOM anchor of the second shape is the second img element.
</p>

`data-model-1^xCode
</div>

<tbody><tr><th id="td-fa-3">
~UAが［
次を満たす要素
］用に供した下位widget
⇒
［
`具現化されて$いる
］~AND［
`実際に不能化-$されてない
］~AND［
`不活$でない
］
◎
The user-agent provided subwidgets of elements that are being rendered and are not actually disabled or inert.
<td>
当の要素
◎
The element for which the focusable area is a subwidget.
<tr><td colspan="2" headers="td-fa-3">

<div class="example">
<ul>
	<li>
`video$e 要素~用に`~UI内に公開されている~control$
◎
The controls in the user interface for a video element,＼
</li>
	<li>
`&lt;input type=number&gt;＠~HEinput#number-state-(type=number)$e
用の増減~button
◎
the up and down buttons in a spin-control version of &lt;input type=number&gt;,＼
</li>
	<li>
`details$e 要素の具現化の一部を成していて，~keyboard入力で当の要素を開閉することを可能化しているもの。
◎
the part of a details element's rendering that enables the element to be opened or closed using keyboard input.
</li>
</ul>
</div>

<tbody><tr><th id="td-fa-4">
［
次を満たす要素
］により作成された~scroll可能な領域
⇒
［
`具現化されて$いる
］~AND［
`不活$でない
］
◎
The scrollable regions of elements that are being rendered and are not inert.
<td>
当の要素
◎
The element for which the box that the scrollable region scrolls was created.
<tr><td colspan="2">

<div class="example">
<p>
~CSS `overflow$p ~propに対する `scroll^v 値は、
概して，~scroll可能な領域を作成させる。
◎
The CSS 'overflow' property's 'scroll' value typically creates a scrollable region.
</p>
</div>

<tbody><tr><th id="td-fa-5">
［
次を満たす`文書$
］用の`表示域$
⇒
［
`属する閲覧~文脈$ ~NEQ ~NULL
］~AND［
`不活$でない
］
◎
The viewport of a Document that has a non-null browsing context and is not inert.
<td>
当の`文書$
◎
The Document for which the viewport was created.
<tr><td colspan="2">
<div class="example">
<p>
`iframe$e の内容。
◎
The contents of an iframe.
</p>
</div>

<tbody><tr><th id="td-fa-6">
他の任意の，~UAにより~focus可能な区画であると決定された［
要素, または要素の
— とりわけ、［
~accessibilityを援助する／~platform規約により良く合致する
］ような —
一部分
］。
◎
Any other element or part of an element determined by the user agent to be a focusable area, especially to aid with accessibility or to better match platform conventions.

<td>
当の要素
◎
The element.
<tr><td colspan="2">

<div class="example">
<p>
~UAは、
利用者が~listを容易に~navigateできるよう，
すべての~list~item~bulletを`連列的に~focus可能$にすることもできる。
◎
A user agent could make all list item bullets sequentially focusable, so that a user can more easily navigate lists.
</p>

<p>
類似に，~UAは、
`title$a 属性を有する すべての要素に対し，
それらの助言的~情報に~accessできるよう，
`連列的に~focus可能$にすることもできる。
◎
Similarly, a user agent could make all elements with title attributes sequentially focusable, so that their advisory information can be accessed.
</p>
</div>
</table>

<p id="bc-focus-ergo-bcc-focus" class="note">注記：
`~navigable容器$ %容器 （例： `iframe$e ）は `~focus可能な区画$であるが、［
%容器 の`内容~navigable$ %N ~NEQ ~NULL
］の場合，［
%容器 へ届けられる~UIkey~eventは、
%N にて`作動中な文書$nav %文書 へ~~直に届けられる
］ようになる。
類似に，`連列的~focus~navi$においては、
%容器 は，本質的には %文書 の代役として動作するに過ぎない。
◎
A navigable container (e.g. an iframe) is a focusable area, but key events routed to a navigable container get immediately routed to its content navigable's active document. Similarly, in sequential focus navigation a navigable container essentially acts merely as a placeholder for its content navigable's active document.
</p>

<hr>

<p>
各 `文書$が
`指名する被focus区画@doc
は、
文書に属する`~focus可能な区画$のうち 1 つを指す【か，何も指さずに ~NULL になる】。
どの~focus可能な区画がそう指名されるかは、
この仕様の各種~algoに基づいて，時間~越しに変化する。
◎
One focusable area in each Document is designated the focused area of the document. Which control is so designated changes over time, based on algorithms in this specification.
</p>

<p class="trans-note">【
原文は，何も指さない場合ついて述べていないが、
それもあり得るらしい
（ `課題 #5835＠~HTMLissue/5835$
— 場合によっては、
表示域に~fallbackするよう定義されるかもしれない）。
加えて、
~NULL にもなり得ることは，`現在の被focus区画$tlTの定義からも要請される。
】</p>

<p class="note">注記：
文書は、［
`全部的に作動中$でなく，利用者に示されていない場合
］でも，`指名する被focus区画$docを有し得る。
文書が`全部的に作動中$かどうかが変化しても、
文書が`指名する被focus区画$docは，同じまま変わらない。
◎
Even if a document is not fully active and not shown to the user, it can still have a focused area of the document. If a document's fully active state changes, its focused area of the document will stay the same.
</p>

<div class="algo">
<p>
`~top-level辿可能$ %辿可能 の
`現在の被focus区画@tlT
を決定する~algoは、［
ある`~focus可能な区画$／~NULL
］を返す：
</p>
<ol>
	<li>
~IF［
%辿可能 は`~system~focus$を有していない
］
⇒
~RET ~NULL
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
%文書 ~SET %辿可能 にて`作動中な文書$nav
</li>
			<li>
%区画 ~LET %文書 が`指名する被focus区画$doc
</li>
			<li>
~IF［
%区画 ~EQ ~NULL
］
⇒
~RET %文書
</li>
			<li>
~IF［
%区画 は`~navigable容器$でない
］
⇒
~RET %区画
</li>
			<li>
%辿可能 ~SET %区画 の`内容~navigable$
</li>
			<li>
~IF［
%辿可能 ~EQ ~NULL
］
⇒
~RET %区画
</li>
		</ol>
	</li>
</ol>
◎
The currently focused area of a top-level traversable traversable is the focusable area-or-null returned by this algorithm:
• If traversable does not have system focus, then return null.
• Let candidate be traversable's active document.
• While candidate's focused area is a navigable container with a non-null content navigable: set candidate to the active document of that navigable container's content navigable.
• If candidate's focused area is non-null, set candidate to candidate's focused area.
• Return candidate.
</div>

<p>
`~top-level辿可能$ %辿可能 の
`現在の~focus鎖@tlT
は、［
%辿可能 の`現在の被focus区画$tlT ~NEQ ~NULL ならば その`~focus鎖$／
~ELSE_ 空~list
］とする。
◎
The current focus chain of a top-level traversable traversable is the focus chain of the currently focused area of traversable, if traversable is non-null, or an empty list otherwise.
</p>

<p>
`現在の被focus区画$tlTの`~DOM~anchor$である要素は、
`~focusされて@
いるという。
そうでない要素がそうなることを，要素は
`~focusを得る@
という。
◎
An element that is the DOM anchor of a focusable area is said to gain focus when that focusable area becomes the currently focused area of a top-level traversable. When an element is the DOM anchor of a focusable area of the currently focused area of a top-level traversable, it is focused.
</p>

<div class="algo">
<p>
`~focus可能な区画$ %~subject の
`~focus鎖@
は、
次の~algoにより構築される有順序~listである：
◎
The focus chain of a focusable area subject is the ordered list constructed as follows:
</p>

<ol>
	<li>
%出力 ~LET 空~list
◎
Let output be an empty list.
◎
Let currentObject be subject.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%出力 に %~subject を付加する
◎
Append currentObject to output.
</li>
			<li>
%~DOM~anchor ~LET ［
%~subject は`~focus可能な区画$であるならば %~subject の`~DOM~anchor$ ／
~ELSE_ ε
］
◎
↓</li>
			<li>
~IF［
%~subject は`~focus可能な図形$である
］
⇒
%出力 に %~subject を定義している `area$e 要素を付加する
◎
If currentObject is an area element's shape, then append that area element to output.
</li>
			<li>
~ELIF［
%~DOM~anchor は要素である
］~AND［
%~DOM~anchor ~NEQ %~subject
］
⇒
%出力 に %~DOM~anchor を付加する
◎
Otherwise, if currentObject's DOM anchor is an element that is not currentObject itself, then append currentObject's DOM anchor to output.
</li>
			<li>
~IF［
%~DOM~anchor ~NEQ ε
］
⇒
%~subject ~SET %~DOM~anchor の`~node文書$
◎
If currentObject is a focusable area, then set currentObject to currentObject's DOM anchor's node document.
</li>
			<li>
<p>
~ELIF［
%~subject は`文書$である
］：
</p>
				<ol>
					<li>
%~subject ~SET %~subject の`~node~navigable$の`親$nav
</li>
					<li>
~IF［
%~subject ~EQ ~NULL
］
⇒
~BREAK
</li>
				</ol>
◎
Otherwise, if currentObject is a Document whose node navigable's parent is non-null, then set currentObject to currentObject's node navigable's parent.
</li>
			<li>
~ELSE
⇒
~BREAK
◎
Otherwise, break.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
~focus鎖は、
%~subject から開始して，
（ %~subject が［
`現在の被focus区画$tlTであるか，そうなり得るものである
］ならば）
`~top-level辿可能$に属する`文書$まで，~focus階層を遡り続ける。
◎
The chain starts with subject and (if subject is or can be the currently focused area of a top-level traversable) continues up the focus hierarchy up to the Document of the top-level traversable.
</p>
</div>

<p>
要素は、
`~focus可能な区画$であるならば，
`~focus可能@
であるという。
◎
All elements that are focusable areas are said to be focusable.
</p>

<p class="trans-note">【
この定義が［
要素が`~focus可能な区画$の`~DOM~anchor$である場合
］も含むのかどうか，はっきりしないが、
“要素が`~focusされて$いる” の意味論に従うなら，含むように思われる。
】</p>

<p>
`~focus可能な区画$には、
次に挙げる特別な~focus能を有する種別もある：
◎
There are two special types of focusability for focusable areas:
</p>

<ul>
	<li>
`連列的に~focus可能@
⇒
`~focus可能な区画$のうち［
それが属する`文書$の`連列的~focus~navi順序$に含まれているもの
］のうち，~UAが［
連列的に~focus可能である
］と決定したもの。
◎
A focusable area is said to be sequentially focusable if it is included in its Document's sequential focus navigation order and the user agent determines that it is sequentially focusable.
</li>
	<li>
`~clickで~focus可能@
⇒
`~focus可能な区画$のうち，~UAが［
~clickで~focus可能である
］と決定したもの。
~UAは、
~focus可能な区画のうち［
`~tabindex値$ ~NEQ ~NULL
］を満たすものは，~clickで~focus可能と見なすベキである。
◎
A focusable area is said to be click focusable if the user agent determines that it is click focusable. User agents should consider focusable areas with non-null tabindex values to be click focusable.
</li>
</ul>

<p class="note">注記：
`~focus可能$でない要素は、
`~focus可能な区画$にならないので，
`連列的に~focus可能$にも`~clickで~focus可能$にもならない。
◎
Elements which are not focusable are not focusable areas, and thus not sequentially focusable and not click focusable.
</p>

<div class="note">
<p>注記：
“要素が`~focus可能$である”
は、［
要素を~program的に
— 例： `focus()$mE ~methodや `autofocus$a 属性を介して —
~focusできるかどうか
］についての言明である。
対照的に，［
`連列的に~focus可能$／`~clickで~focus可能$
］は、［
`連列的~focus~navi$において／`作動化の挙動$として
］，~UAが利用者-ヤリトリに どう応答するかを統治する。
◎
Being focusable is a statement about whether an element can be focused programmatically, e.g. via the focus() method or autofocus attribute. In contrast, sequentially focusable and click focusable govern how the user agent responds to user interaction: respectively, to sequential focus navigation and as activation behavior.
</p>

<p>
~UAは、
要素は［
`~focus可能$であって，自身が属する`文書$の`連列的~focus~navi順序$に含まれて
］いても，［
利用者-選好に則って，`連列的に~focus可能$でないものと決定する
］かもしれない。
例えば，~macOS利用者は、
~form~controlでない要素を飛ばすよう，~UAを設定できたり、
`連列的~focus~navi$を `Tab^Key ~UIkeyだけで（ `Option^Key ~UIkeyも併用することなく）行うときは，~linkを飛ばせる。
◎
The user agent might determine that an element is not sequentially focusable even if it is focusable and is included in its Document's sequential focus navigation order, according to user preferences. For example, macOS users can set the user agent to skip non-form control elements, or can skip links when doing sequential focus navigation with just the Tab key (as opposed to using both the Option and Tab keys).
</p>

<p>
類似に，~UAは、
ある要素を［
`~focus可能$であっても，`~clickで~focus可能$ではないと決定する
］かもしれない。
例えば，一部の~UAにおいては、
編集-不能な~form~controlは，~clickしても~focusされない
— すなわち~UAは、
そのような~controlを［
~clickで~focus可能でないもの
］と決定したことになる。
◎
Similarly, the user agent might determine that an element is not click focusable even if it is focusable. For example, in some user agents, clicking on a non-editable form control does not focus it, i.e. the user agent has determined that such controls are not click focusable.
</p>

<p>
したがって，要素は、［
`~focus可能$でありながら，
`連列的に~focus可能$にも`~clickで~focus可能$にもならない
］こともある。
例えば，一部の~UAにおいては、［
編集-不能な~form~controlのうち，
その`~tabindex値$は負な整数であるもの
］は，［
利用者-ヤリトリを介しては，~focus可能にならず、
~program的~APIを介するとき限り，~focus可能になる
］。
◎
Thus, an element can be focusable, but neither sequentially focusable nor click focusable. For example, in some user agents, a non-editable form-control with a negative-integer tabindex value would not be focusable via user interaction, only via programmatic APIs.
</p>
</div>

<div class="algo">
<p>
利用者が［
`~focus可能な区画$のうち`~clickで~focus可能$なもの
］を`作動化した＠#activation$ときは、
~UAは次を走らすモノトスル
⇒
`~objを~focusする$( 当の`~focus可能な区画$, ε, `click^l )
◎
When a user activates a click focusable focusable area, the user agent must run the focusing steps on the focusable area with focus trigger set to "click".
</p>
</div>

<p class="note">注記：
~focusすることは、
`作動化の挙動$ではないことに注意
— すなわち、
要素に対し［
`click()$m ~methodを~callしても／
合成な `click$et ~eventを配送しても
］要素が~focusを得ることはない。
◎
Note that focusing is not an activation behavior, i.e. calling the click() method on an element or dispatching a synthetic click event on it won't cause the element to get focused.
</p>

<hr>

<div class="p">
<p>
所与の~nodeが
`~focus~navi視野の所有者@
であるとは、
次に挙げるいずれかであることをいう：
</p>
<ul>
	<li>
`文書$
</li>
	<li>
`~shadow~host$
</li>
	<li>
`slot$e 要素
</li>
	<li>
次を満たす要素の`~popover誘発元$el
⇒
`~popover可視性~状態$ ~EQ `示している$i
</li>
</ul>
◎
A node is a focus navigation scope owner if it is a Document, a shadow host, a slot, or an element which is the popover trigger of an element in the popover showing state.
</div>

<p>
各`~focus~navi視野の所有者$は、
`~focus~navi視野@
を有する
— それは，要素たちが成す~listであり、
その内容は，次に従って決定される：
◎
Each focus navigation scope owner has a focus navigation scope, which is a list of elements. Its contents are determined as follows:
</p>
<ul>
	<li class="algo">
<p>
先ず，所与の要素 %要素 に
`結付けられた~focus~navi所有者@
は、
次の~algoで決定される［
~NULL ／ `~focus~navi視野の所有者$
］になる：
◎
Every element element has an associated focus navigation owner, which is either null or a focus navigation scope owner. It is determined by the following algorithm:
</p>
		<ol>
			<li>
%親 ~LET %要素 の親
◎
↓</li>
			<li>
~IF［
%親 ~EQ  ~NULL
］
⇒
~RET ~NULL
◎
If element's parent is null, then return null.
</li>
			<li>
~IF［
%親 は`~shadow~host$である
］
⇒
~RET %要素 の`割当-先~slot$
◎
If element's parent is a shadow host, then return element's assigned slot.
</li>
			<li>
~IF［
%親 は`~shadow根$である
］
⇒
~RET %親 の`~host$
◎
If element's parent is a shadow root, then return the parent's host.
</li>
			<li>
~IF［
%親 は`文書~要素$である
］
⇒
~RET %親 の`~node文書$
◎
If element's parent is the document element, then return the parent's node document.
</li>
			<li>
~IF［
%要素 は`~HTML要素$である
］~AND［
%要素 の`~popover可視性~状態$ ~EQ `示している$i
］~AND［
%要素 の`~popover誘発元$el ~NEQ ~NULL
］
⇒
~RET %要素 の`~popover誘発元$el
◎
If element is in the popover showing state and has a popover trigger set, then return element's popover trigger.
</li>
			<li>
~RET %親 に`結付けられた~focus~navi所有者$
◎
Return element's parent's associated focus navigation owner.
</li>
		</ol>
	</li>
	<li>
所与の`~focus~navi視野の所有者$ %所有者 の`~focus~navi視野$は、
次を満たす要素からなる
⇒
それに`結付けられた~focus~navi所有者$ ~EQ %所有者
◎
Then, the contents of a given focus navigation scope owner owner's focus navigation scope are all elements whose associated focus navigation owner is owner.
</li>
</ul>

<p class="note">注記：
`~focus~navi視野$の中における要素の順序は、
この仕様~のどの~algoにも影響iしない。
順序付けが重要になるのは、
下に定義する［
`~tabindex順な~focus~navi視野$／
`平坦~化された~tabindex順な~focus~navi視野$
］の概念に限られる。
◎
The order of elements within a focus navigation scope does not impact any of the algorithms in this specification. Ordering only becomes important for the tabindex-ordered focus navigation scope and flattened tabindex-ordered focus navigation scope concepts defined below.
</p>

<p>
各`~focus~navi視野の所有者$ %所有者 は、
`~tabindex順な~focus~navi視野@
を有する。
それは，［
`~focus可能な区画$,
`~focus~navi視野の所有者$
］たちが成す`~list$であり、
その内容は，次に従って決定される：
◎
A tabindex-ordered focus navigation scope is a list of focusable areas and focus navigation scope owners. Every focus navigation scope owner owner has tabindex-ordered focus navigation scope, whose contents are determined as follows:
</p>

<ul>
	<li>
次を満たす すべての要素を包含する
⇒
［
要素 ~IN %所有者 の`~focus~navi視野$
］~AND［
`~focus~navi視野の所有者$である
］~AND［
その`~tabindex値$は負な整数でない
］
◎
It contains all elements in owner's focus navigation scope that are themselves focus navigation scope owners, except the elements whose tabindex value is a negative integer.
</li>
	<li>
次を満たす すべての`~focus可能な区画$を包含する
⇒
［
その`~DOM~anchor$ ~IN %所有者 の`~focus~navi視野$
］~AND［
その`~tabindex値$は負な整数でない
］
◎
It contains all of the focusable areas whose DOM anchor is an element in owner's focus navigation scope, except the focusable areas whose tabindex value is a negative integer.
</li>
</ul>

<p>
`~tabindex順な~focus~navi視野$の中における順序は、
以下の節にて述べるとおり，各~要素の`~tabindex値$により決定される。
◎
The order within a tabindex-ordered focus navigation scope is determined by each element's tabindex value, as described in the section below.
</p>

<p class="note">注記：
そこに与える規則は、
ほとんどが “ベキである” 言明による相対-順序付けで構成されているので，
精確な順序付けは与えない。
◎
The rules there do not give a precise ordering, as they are composed mostly of "should" statements and relative orderings.
</p>

<div class="algo">
<p>
各`~focus~navi視野の所有者$ %所有者 は、
互いに別個な
`平坦~化された~tabindex順な~focus~navi視野@
を所有する。
それは，`~focus可能な区画$たちが成す`~list$であり、
その内容は，次の~algoに従って決定される：
◎
A flattened tabindex-ordered focus navigation scope is a list of focusable areas. Every focus navigation scope owner owner owns a distinct flattened tabindex-ordered focus navigation scope, whose contents are determined by the following algorithm:
</p>

<ol>
	<li>
%結果 ~LET 新たな`~list$
◎
↓</li>
	<li>
<p>
%所有者 の`~tabindex順な~focus~navi視野$を成す
~EACH( %~item )
に対し：
</p>
		<ol>
			<li>
~IF［
%~item は`~focus~navi視野の所有者$でない
］~OR［
%~item は`~focus可能な区画$である
］
⇒
%結果 に %~item を`付加する$
</li>
			<li>
~IF［
%~item は`~focus~navi視野の所有者$である
］
⇒
%結果 を［
%~item の`平坦~化された~tabindex順な~focus~navi視野$
］で`拡張する$
</li>
		</ol>
◎
Let result be a clone of owner's tabindex-ordered focus navigation scope.
◎
For each item of result:
• If item is not a focus navigation scope owner, then continue.
• If item is not a focusable area, then replace item with all of the items in item's flattened tabindex-ordered focus navigation scope.
• Otherwise, insert the contents of item's flattened tabindex-ordered focus navigation scope after item.
</li>
</ol>

<p class="trans-note">【
この訳では、
“`拡張する$” を利用して，原文の~algoを簡素化している。
】</p>
</div>

			</section>
			<section id="the-tabindex-attribute">
<h4 title="The tabindex attribute">6.6.3. `tabindex^a 属性</h4>

<p>
`tabindex@a
内容~属性は、［
要素, および それを`~DOM~anchor$とする`~focus可能な区画$
］を`~focus可能な区画$にすること, その場合に［
`連列的に~focus可能$になるのを［
許容する／防止する
］こと
］を，作者に許容する。
加えて、
`連列的~focus~navi$における それらの相対-順序付けを決定する。
◎
The tabindex content attribute allows authors to make an element and regions that have the element as its DOM anchor be focusable areas, allow or prevent them from being sequentially focusable, and determine their relative ordering for sequential focus navigation.
</p>

<p>
“tab index” という名称は、
一連の~focus可能な要素を~navigateするときに，
`Tab^Key ~UIkeyが共通的に利用されることに~~由来する。
語 “`tabbing^en” とは、
連列的~focus~naviを利用して到達し得る［
`連列的に~focus可能$な`~focus可能な区画$
］を，前方へ辿ることを指す。
◎
The name "tab index" comes from the common use of the Tab key to navigate through the focusable elements. The term "tabbing" refers to moving forward through sequentially focusable focusable areas.
</p>

<p>
`tabindex$a 属性に指定される値は、
`妥当な整数$でなければナラナイ。
正な整数は、
要素の`~focus可能な区画$の［
`連列的~focus~navi順序$における位置
］を指定する。
負な整数は、
当の~controlは`連列的に~focus可能$にしないことを指示する。
◎
The tabindex attribute, if specified, must have a value that is a valid integer. Positive numbers specify the relative position of the element's focusable areas in the sequential focus navigation order, and negative numbers indicate that the control is not sequentially focusable.
</p>

<p>
開発者は、
`tabindex$a 属性に対する 0, −1 以外の値は注意して利用するベキである
— 正しく利用するのは複雑なので。
◎
Developers should use caution when using values other than 0 or −1 for their tabindex attributes as this is complicated to do correctly.
</p>

<div class="note">
<p>注記：
`tabindex$a 属性にアリな各~値の挙動についての規範的でない要約を次に挙げる
（より精確な規則は、
下の処理~modelに与える）。
◎
The following provides a non-normative summary of the behaviors of the possible tabindex attribute values. The below processing model gives the more precise rules.
</p>

<dl>
	<dt>
省略された／整数でない【値は妥当でない】
◎
omitted (or non-integer values)
</dt>
	<dd>
要素が`~focus可能$かどうか, および そうなる場合に［
`連列的に~focus可能$／`~clickで~focus可能$
］になるかどうかは、
~UAが裁定することになる。
◎
The user agent will decide whether the element is focusable, and if it is, whether it is sequentially focusable or click focusable (or both).
</dd>
	<dt>
負な整数
◎
−1 (or other negative integer values)
</dt>
	<dd>
要素を`~focus可能$にする。
加えて、
作者は［
要素は，`~clickで~focus可能$になるが`連列的に~focus可能$にはならない
］ことを選好することを指示する。
~UAは、
これらの選好を無視するかもしれない
— 例：
特定の要素~型~用に~platform規約に則って，
あるいは~keyboardのみの利用者~用に。
◎
Causes the element to be focusable, and indicates that the author would prefer the element to be click focusable but not sequentially focusable. The user agent might ignore this preference for click and sequential focusability, e.g., for specific element types according to platform conventions, or for keyboard-only users.
</dd>

	<dt>0</dt>
	<dd>
要素を`~focus可能$にする。
加えて、
作者は［
要素は，`~clickで~focus可能$かつ`連列的に~focus可能$になる
］ことを選好することを指示する。
~UAは、
これらの選好を無視するかもしれない。
◎
Causes the element to be focusable, and indicates that the author would prefer the element to be both click focusable and sequentially focusable. The user agent might ignore this preference for click and sequential focusability.
</dd>
	<dt>
正な整数
◎
positive integer values
</dt>
	<dd>
0 と同じに挙動するが，それに加え、
`tabindex$a 属性~値が高い要素ほど後になるよう，`~tabindex順な~focus~navi視野$の中での順序付けを与える。
◎
Behaves the same as 0, but in addition creates a relative ordering within a tabindex-ordered focus navigation scope, so that elements with higher tabindex attribute value come later.
</dd>
</dl>

<p>
`tabindex$a 属性は、
要素を~focus不能にする用途には利用できないことに注意。
~page作者がそれを行うには、
要素を［
`実際に不能化-$するか, `不活$にする
］他にない。
◎
Note that the tabindex attribute cannot be used to make an element non-focusable. The only way a page author can do that is by disabling the element, or making it inert.
</p>
</div>

<hr>

<p>
所与の要素の
`~tabindex値@
は、［
要素は `tabindex$a 属性 %A を有する
］~AND［
`整数として構文解析する$( %A の値 ) ~NEQ `失敗^i
］ならば その結果 ／
~ELSE_ ~NULL
］とする。
◎
The tabindex value of an element is the value of its tabindex attribute, parsed using the rules for parsing integers. If parsing fails or the attribute is not specified, then the tabindex value is null.
</p>

<p>
所与の`~focus可能な区画$の`~tabindex値$は、
その`~DOM~anchor$の`~tabindex値$とする。
◎
The tabindex value of a focusable area is the tabindex value of its DOM anchor.
</p>

<p>
要素の`~tabindex値$は、
次に従って解釈するモノトスル：
◎
The tabindex value of an element must be interpreted as follows:
</p>

<ul>
	<li>
<p>
`~tabindex値$ ~EQ ~NULL の場合：
◎
If the value is null
</p>
		<ul>
			<li>
~UAは、
~platform規約に従って，次を決定するベキである
⇒
要素は`~focus可能な区画$であると見なすベキかどうか
— そうであれば
⇒
［
要素, および それを`~DOM~anchor$とする`~focus可能な区画$
］は`連列的に~focus可能$になるかどうか
— そうであれば
⇒
それらは、
`~tabindex順な~focus~navi視野$において どこに位置するか？
◎
The user agent should follow platform conventions to determine if the element should be considered as a focusable area and if so, whether the element and any focusable areas that have the element as their DOM anchor are sequentially focusable, and if so, what their relative position in their tabindex-ordered focus navigation scope is to be.＼
</li>
			<li>
要素は`~focus~navi視野の所有者$である場合、
`~focus可能な区画$でない場合でも，
自身の`~tabindex順な~focus~navi視野$には含めるモノトスル。
◎
If the element is a focus navigation scope owner, it must be included in its tabindex-ordered focus navigation scope even if it is not a focusable area.
</li>
			<li>
同じ`~focus~navi視野$に属する［
要素, `~focus可能な区画$
］のうち［
`~tabindex値$ ~EQ ~NULL
］を満たすものたちの［
`~tabindex順な~focus~navi視野$の中での順序
］は、
`~shadowも含めた~tree順序$に従うベキである。
◎
The relative ordering within a tabindex-ordered focus navigation scope for elements and focusable areas that belong to the same focus navigation scope and whose tabindex value is null should be in shadow-including tree order.
</li>
			<li>
<p>
~platform規約の違いを除き、
次に挙げる要素は［
`~focus可能な区画$と見なされ，`連列的に~focus可能$である
］ベキであることが示唆される：
◎
Modulo platform conventions, it is suggested that the following elements should be considered as focusable areas and be sequentially focusable:
</p>
				<ul>
					<li>
`a$e 要素のうち， `href$a 属性を有するもの
◎
a elements that have an href attribute
</li>
					<li>
`button$e 要素
◎
button elements
</li>
					<li>
`input$e 要素のうち，［
その `type$a 属性の状態 ~NEQ `Hidden$st
］を満たすもの
◎
input elements whose type attribute are not in the Hidden state
</li>
					<li>
`select$e 要素
◎
select elements
</li>
					<li>
`textarea$e 要素
◎
textarea elements
</li>
					<li>
`details$e 要素の子である `summary$e 要素のうち，最初のもの
◎
summary elements that are the first summary element child of a details element
</li>
					<li>
`draggable$a 属性を有する要素のうち、
~UAが［
利用者が~pointing装置を利用することなく，その要素~用の~drag操作oを始める
］ことを可能化するもの。
◎
Elements with a draggable attribute set, if that would enable the user agent to allow the user to begin drag operations for those elements without the use of a pointing device
</li>
					<li>
`編集中の~host$
◎
Editing hosts
</li>
					<li>
`~navigable容器$
◎
Navigable containers
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
<p>
`~tabindex値$ ~NEQ ~NULL の場合、
要素を`~focus可能な区画$と見なすモノトスル。
加えて：

<!-- 
must consider the element as 
と
must allow the element to be considered as
の違いはどこに？
-->
◎
↓</p>
		<ul>
			<li>
<p>
`~tabindex値$ ~LT 0 の場合、
要素を`~tabindex順な~focus~navi視野$からは外すベキである。
◎
If the value is a negative integer
◎
The user agent must consider the element as a focusable area, but should omit the element from any tabindex-ordered focus navigation scope.
</p>

<p class="note">注記：
［
要素を連列的~focus~naviから外すとする，作者からの要件
］を無視する妥当な理由としては、［
利用者が~focusを移動する仕組みが，連列的~focus~naviの他にない場合
］が挙げられる。
一例として、［
~keyboardのみの利用者は、
負な `tabindex$a を伴う~text~controlを~clickできない
］ので，［
利用者が~tab~UIkeyで当の~controlへ移動する
］ことを~UAが許容することは正当化される。
◎
One valid reason to ignore the requirement that sequential focus navigation not allow the author to lead to the element would be if the user's only mechanism for moving the focus is sequential focus navigation. For instance, a keyboard-only user would be unable to click on a text control with a negative tabindex, so that user's user agent would be well justified in allowing the user to tab to the control regardless.
</p>
			</li>
			<li>
`~tabindex値$ ~GTE 0 の場合、［
要素, それを`~DOM~anchor$とする`~focus可能な区画$
］は`連列的に~focus可能$にするベキである。
◎
If the value is a zero
◎
The user agent must allow the element to be considered as a focusable area and should allow the element and any focusable areas that have the element as their DOM anchor to be sequentially focusable.
◎
↓↓The relative ordering within a tabindex-ordered focus navigation scope for elements and focusable areas that belong to the same focus navigation scope and whose tabindex value is zero should be in shadow-including tree order.
◎
If the value is greater than zero
◎
The user agent must allow the element to be considered as a focusable area and should allow the element and any focusable areas that have the element as their DOM anchor to be sequentially focusable,＼
</li>
		</ul>
	</li>
	<li>
<p>
同じ`~focus~navi視野$に属する［
要素, `~focus可能な区画$
］たちの［
`~tabindex順な~focus~navi視野$の中での順序
］は、
以下に従うベキである：
</p>

		<ul>
			<li>
［
`~tabindex値$ ~GT 0
］を満たすものは、
他のものより先にする。
</li>
			<li>
［
`~tabindex値$ ~GT 0
］を満たすものどうしの順序は、
`~tabindex値$の昇順にする（値が小さいものが先）。
</li>
			<li>
［
`~tabindex値$ ~GTE 0
］を満たすもののうち`~tabindex値$が同じものどうしの順序は、
`~DOM~anchor$の`~shadowも含めた~tree順序$に従う。
</li>
		</ul>

<p class="trans-note">【
`~tabindex値$が［
負なものどうし／
負なものと 0 のもの
］の順序は、
定義されていない
（元々、
`~tabindex順な~focus~navi視野$からは外す “ベキ” とされている）。
同じ`~DOM~anchor$を共有するものどうしの順序も、
定義されていない。
】</p>

◎
and should place the element — referenced as candidate below — and the aforementioned focusable areas in the tabindex-ordered focus navigation scope where the element is a part of so that, relative to other elements and focusable areas that belong to the same focus navigation scope, they are:
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has been omitted or whose value, when parsed, returns an error,
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value less than or equal to zero,
◎
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than zero but less than the value of the tabindex attribute on candidate,
◎
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is located earlier than candidate in shadow-including tree order,
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is located later than candidate in shadow-including tree order, and
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than the value of the tabindex attribute on candidate.
</li>
</ul>

<div class="algo">
<p>
`tabIndex@m
取得子~手続きは：
◎
The tabIndex getter steps are:
</p>
<ol>
	<li>
%属性 ~LET コレの `tabindex$a 属性~node
◎
Let attribute be this's tabindex attribute.
</li>
	<li>
<p>
~IF［
%属性 ~NEQ ~NULL
］：
◎
If attribute is not null:
</p>
		<ol>
			<li>
%~index ~LET `整数として構文解析する$( %属性 の`値$attr )
◎
Let parsedValue be the result of integer parsing attribute's value.
</li>
			<li>
~IF［
%~index ~NEQ `失敗^i
］~AND［
%~index は `long＠~WEBIDL#idl-long$c 型の範囲に入る
］
⇒
~RET %~index
◎
If parsedValue is not an error and is within the long range, then return parsedValue.
</li>
		</ol>
	</li>
	<li>
~RET ［
コレは次に挙げるいずれかの要素であるならば 0 ／
~ELSE_ 1
］
⇒＃
`a$e,
`area$e,
`button$e,
`frame$e,
`iframe$e,
`input$e,
`object$e,
`select$e,
`textarea$e,
~SVG `a＠~SVGlinking#elementdef-a$e,
`親~details用の~summary$
◎
Return 0 if this is an a, area, button, frame, iframe, input, object, select, textarea, or SVG a element, or is a summary element that is a summary for its parent details; otherwise 1.
</li>
</ol>

<p class="note">注記：
要素~型に応じて既定の値が変わるのは、
歴史的な遺物である。
◎
The varying default value based on element type is a historical artifact.
</p>
</div>

			</section>
			<section id="focus-processing-model">
<h4 title="Processing model">6.6.4. 処理~model</h4>

<div class="algo">
<p>
`~focus可能な区画を取得する@
~algoは、
所与の
( %~target, 文字列 %~focus誘発元 ~DF `other^l )
に対し：
◎
To get the focusable area for a focus target that is either an element that is not a focusable area, or is a navigable, given an optional string focus trigger (default "other"), run the first matching set of steps from the following list:
</p>
<ol>
	<li>
~Assert：
%~target は次のいずれかである
⇒
`~focus可能な区画$でない要素 ／ `~navigable$
◎
↑</li>
	<li>
~IF［
%~target は `area$e 要素である
］~AND［
%~target は`~focus可能な図形$を定義している
］
⇒
~RET それらの図形の`~DOM~anchor$のうち，`~tree順序$で最初のもの
◎
If focus target is an area element with one or more shapes that are focusable areas
• Return the shape corresponding to the first img element in tree order that uses the image map to which the area element belongs.
</li>
	<li>
~IF［
%~target は要素である
］~AND［
%~target は 1 個以上の［
`~focus可能な区画$である~scroll可能な領域
］を伴う
］
⇒
~RET それらの領域のうち，`~DOM~anchor$が［
`平坦~tree$における`~tree順序$（前順, 深さ優先の順序）で最初に来る
］もの
`CSSSCOPING$r
◎
If focus target is an element with one or more scrollable regions that are focusable areas
• Return the element's first scrollable region, according to a pre-order, depth-first traversal of the flat tree. [CSSSCOPING]
</li>
	<li>
~IF［
%~target は`文書~要素$である
］
⇒
~RET %~target の`文書$の`表示域$
◎
If focus target is the document element of its Document
• Return the Document's viewport.
</li>
	<li>
~IF［
%~target は`~navigable$である
］
⇒
~RET %~target にて`作動中な文書$nav
◎
If focus target is a navigable
• Return the navigable's active document.
</li>
	<li>
~IF［
%~target は`~navigable容器$である
］~AND［
%~target の`内容~navigable$ %N ~NEQ ~NULL
］
⇒
~RET %N にて`作動中な文書$nav
◎
If focus target is a navigable container with a non-null content navigable
• Return the navigable container's content navigable's active document.
</li>
	<li>
<p>
~IF［
%~target は`~shadow~host$である
］~AND［
%~target の`~shadow根$elの`~focusを委任するか$sR ~EQ ~T
］：
◎
If focus target is a shadow host whose shadow root's delegates focus is true
</p>
		<ol>
			<li>
%被focus要素 ~LET `現在の被focus区画$tlTの`~DOM~anchor$
◎
Let focusedElement be the currently focused area of a top-level traversable's DOM anchor.
</li>
			<li>
~IF［
%~target は %被focus要素 の`~shadowも含めた広義-先祖$である
］
⇒
~RET %被focus要素
◎
If focus target is a shadow-including inclusive ancestor of focusedElement, then return focusedElement.
</li>
			<li>
~RET `~focus委任-先$( %~target, %~focus誘発元 )
◎
Return the focus delegate for focus target given focus trigger.
</li>
		</ol>

<p class="note">注記：
`連列的に~focus可能$かどうかについては、［
`~shadow~host$,
`~focusを委任するか$sR
］の取扱いは，`連列的~focus~navi順序$を構築するとき行われる。
すなわち，そのような`~shadow~host$に対しては、
連列的~focus~naviの一部として
`~objを~focusする$() が~callされることは決してない。
◎
For sequential focusability, the handling of shadow hosts and delegates focus is done when constructing the sequential focus navigation order. That is, the focusing steps will never be called on such shadow hosts as part of sequential focus navigation.
</p>
	</li>
	<li>
~RET ~NULL
◎
Otherwise
• Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~focus委任-先@
を決定する
~algoは、
所与の
( %~target, 文字列 %~focus誘発元 ~DF `other^l )
に対し：
◎
The focus delegate for a focusTarget, given an optional string focusTrigger (default "other"), is given by the following steps:
</p>
<ol>
	<li>
~IF［
%~target は`~shadow~host$である
］~AND［
%~target の`~shadow根$elの`~focusを委任するか$sR ~EQ ~F
］
⇒
~RET ~NULL
◎
If focusTarget is a shadow host and its shadow root's delegates focus is false, then return null.
</li>
	<li>
%~~注目先 ~LET %~target
◎
Let whereToLook be focusTarget.
</li>
	<li>
~IF［
%~~注目先 は`~shadow~host$である
］
⇒
%~~注目先 ~SET %~~注目先 の`~shadow根$el
◎
If whereToLook is a shadow host, then set whereToLook to whereToLook's shadow root.
</li>
	<li>
%自動focus委任-先 ~LET `自動focus委任-先$( %~~注目先, %~focus誘発元 )
◎
Let autofocusDelegate be the autofocus delegate for whereToLook given focusTrigger.
</li>
	<li>
~IF［
%自動focus委任-先 ~NEQ ~NULL
］
⇒
~RET %自動focus委任-先
◎
If autofocusDelegate is not null, then return autofocusDelegate.
</li>
	<li>
<p>
%~~注目先 の
~EACH( `子孫$ %子孫 )
に対し，`~tree順序$で：
◎
For each descendant of whereToLook's descendants, in tree order:
</p>
		<ol>
			<li>
<p>
~IF［
~OR↓
］…
</p>
				<ul>
					<li>
［
%~target は `dialog$e 要素である
］~AND［
%子孫 は`連列的に~focus可能$である
］
</li>
					<li>
［
%~target は `dialog$e 要素でない
］~AND［
%子孫 は`~focus可能な区画$である
］
</li>
				</ul>
<p>
…ならば
⇒
~RET %子孫
</p>
◎
Let focusableArea be null.
◎
If focusTarget is a dialog element and descendant is sequentially focusable, then set focusableArea to descendant.
◎
Otherwise, if focusTarget is not a dialog and descendant is a focusable area, set focusableArea to descendant.
◎
↓</li>
			<li>
<p>
%~focus可能な区画 ~LET `~focus可能な区画を取得する$( %子孫, %~focus誘発元 )
◎
Otherwise, set focusableArea to the result of getting the focusable area for descendant given focusTrigger.
</p>

<p class="note">注記：
この段は，この~algoに再帰し得る
— すなわち、
`~focus可能な区画を取得する$手続きは，
%子孫 の`~focus委任-先$を返すかもしれない。
◎
This step can end up recursing, i.e., the get the focusable area steps might return the focus delegate of descendant.
</p>
			</li>
			<li>
~IF［
%~focus可能な区画 ~NEQ ~NULL
］
⇒
~RET %~focus可能な区画
◎
If focusableArea is not null, then return focusableArea.
</li>
		</ol>
<p class="note">注記：
ここでは、
`~shadowも含めた子孫$は`~~注目しない^emで`子孫$に限り~~注目することが，重要になる。
`~shadow~host$は、
代わりに，上で言及した再帰的な事例により取扱われる。
◎
It's important that we are not looking at the shadow-including descendants here, but instead only at the descendants. Shadow hosts are instead handled by the recursive case mentioned above.
</p>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

<p class="note">注記：
上の~algoは、
本質的に，［
相応しい`~focus可能な区画$のうち，次に該当する最初のもの
］を返す
⇒
その`~DOM~anchor$から %~target までの経路では、
どの~shadow~tree境界においても~focusを委任する
◎
The above algorithm essentially returns the first suitable focusable area where the path between its DOM anchor and focusTarget delegates focus at any shadow tree boundaries.
</p>
</div>

<div class="algo">
<p>
`自動focus委任-先@
を決定する
~algoは、
所与の
( %~target, %~focus誘発元 )
に対し：
◎
The autofocus delegate for a focus target given a focus trigger is given by the following steps:
</p>
<ol>
	<li>
<p>
%~target の
~EACH( `子孫$ %子孫 )
に対し，`~tree順序$で：
◎
For each descendant descendant of focus target, in tree order:
</p>
		<ol>
			<li>
~IF［
%子孫 は `autofocus$a 内容~属性を有さない
］
⇒
~CONTINUE
◎
If descendant does not have an autofocus content attribute, then continue.
</li>
			<li>
%~focus可能な区画 ~LET ［
%子孫 は`~focus可能な区画$であるならば %子孫 ／
~ELSE_ `~focus可能な区画を取得する$( %子孫, %~focus誘発元 )
］
◎
Let focusable area be descendant, if descendant is a focusable area; otherwise let focusable area be the result of getting the focusable area for descendant given focus trigger.
</li>
			<li>
~IF［
%~focus可能な区画 ~EQ ~NULL
］
⇒
~CONTINUE
◎
If focusable area is null, then continue.
</li>
			<li>
~IF［
%~focus可能な区画 は`~clickで~focus可能$でない
］~AND［
%~focus誘発元 ~EQ `click^l
］
⇒
~CONTINUE
◎
If focusable area is not click focusable and focus trigger is "click", then continue.
</li>
			<li>
~RET %~focus可能な区画
◎
Return focusable area.
</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~objを~focusする@
~algoは、
所与の
( %~target, %~fallback~target ~DF ε, 文字列 %~focus誘発元 ~DF ε )
に対し：
◎
The focusing steps for an object new focus target that is either a focusable area, or an element that is not a focusable area, or a navigable, are as follows. They can optionally be run with a fallback target and a string focus trigger.
</p>

<ol>
	<li>
~Assert：
%~target は次のいずれかである
⇒
`~focus可能な区画$ ／
`~focus可能な区画$でない要素 ／
`~navigable$
◎
↑</li>
	<li>
~IF［
%~target は`~focus可能な区画$でない
］
⇒
%~target ~SET `~focus可能な区画を取得する$( %~target, %~focus誘発元 )
◎
If new focus target is not a focusable area, then set new focus target to the result of getting the focusable area for new focus target, given focus trigger if it was passed.
</li>
	<li>
<p>
~IF［
%~target ~EQ ~NULL
］：
◎
If new focus target is null, then:
</p>
		<ol>
			<li>
~IF［
%~fallback~target ~EQ ε
］
⇒
~RET
◎
If no fallback target was specified, then return.
</li>
			<li>
%~target ~SET %~fallback~target
◎
Otherwise, set new focus target to the fallback target.
</li>
		</ol>
	</li>
	<li>
~IF［
%~target は`~navigable容器$である
］~AND［
%~target の`内容~navigable$ %N ~NEQ ~NULL
］
⇒＃
%~target ~SET %N にて`作動中な文書$nav
◎
If new focus target is a navigable container with non-null content navigable, then set new focus target to the content navigable's active document.
</li>
	<li>
~IF［
%~target は`~focus可能な区画$である
］~AND［
%~target の`~DOM~anchor$は`不活$である
］
⇒
~RET
◎
If new focus target is a focusable area and its DOM anchor is inert, then return.
</li>
	<li>
~IF［
%~target ~EQ `現在の被focus区画$tlT
］
⇒
~RET
◎
If new focus target is the currently focused area of a top-level traversable, then return.
</li>
	<li>
%旧-鎖 ~LET ［
%~target が見出される`~top-level辿可能$
］の`現在の~focus鎖$tlT
◎
Let old chain be the current focus chain of the top-level traversable in which new focus target finds itself.
</li>
	<li>
%新-鎖 ~LET %~target の`~focus鎖$
◎
Let new chain be the focus chain of new focus target.
</li>
	<li>
`~focusを更新する$( %旧-鎖, %新-鎖, %~target )
◎
Run the focus update steps with old chain, new chain, and new focus target respectively.
</li>
</ol>
</div>

<div class="algo">
<p>
~UAは，利用者が［
`~focus可能な区画$ ／ `~navigable$
］ %候補 に~focusを移動するよう試みたときには、
`即時に$次を走らすモノトスル
⇒
`~objを~focusする$( %候補 )
◎
User agents must immediately run the focusing steps for a focusable area or navigable candidate whenever the user attempts to move the focus to candidate.
</p>
</div>

<div class="algo">
<p>
`~objを~unfocusする@
~algoは、
所与の
( ［ `~focus可能な区画$ ／ `~focus可能な区画$でない要素 ］ %旧-~target )
に対し：
◎
The unfocusing steps for an object old focus target that is either a focusable area or an element that is not a focusable area are as follows:
</p>
<ol>
	<li>
%辿可能 ~LET %旧-~target が見出される`~top-level辿可能$
◎
↓</li>
	<li>
%現在の被focus区画 ~SET %辿可能 の`現在の被focus区画$tlT
◎
↓</li>
	<li>
<p>
~Assert：
%現在の被focus区画 ~NEQ ~NULL
</p>
<p class="trans-note">【
この段までは、
以下を［
集約する／明確化する
］ための，この訳による追加。
原文には［
%現在の被focus区画 ~EQ ~NULL
］の場合に対する取扱いが述べられていないが、
その事例は生じ得ないので省略されたと思われる。
】</p>
◎
↓</li>
	<li>
<p>
~IF［
%旧-~target は`~shadow~host$である
］~AND［
%旧-~target の`~shadow根$elは ~AND↓ を満たす
］…
</p>
		<ul>
			<li>
その`~focusを委任するか$sR ~EQ ~T
</li>
			<li>
%現在の被focus区画 の`~DOM~anchor$の`~shadowも含めた広義-先祖$である
</li>
		</ul>
<p>
…ならば
⇒
%旧-~target ~SET %現在の被focus区画
</p>
◎
If old focus target is a shadow host whose shadow root's delegates focus is true, and old focus target's shadow root is a shadow-including inclusive ancestor of the currently focused area of a top-level traversable's DOM anchor, then set old focus target to that currently focused area of a top-level traversable.
</li>
	<li>
~IF［
%旧-~target は`不活$である
］
⇒
~RET
◎
If old focus target is inert, then return.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
［
%現在の被focus区画 は`~focus可能な図形$である
］~AND［
 %旧-~target は その図形を定義している `area$e 要素である
</li>
			<li>
［
%現在の被focus区画 は~scroll可能な領域である
］~AND［
%旧-~target は その~scroll可能な領域を有する要素である
］
</li>
		</ul>
<p>
…ならば
⇒
%旧-~target ~SET %現在の被focus区画
</p>
◎
If old focus target is an area element and one of its shapes is the currently focused area of a top-level traversable, or, if old focus target is an element with one or more scrollable regions, and one of them is the currently focused area of a top-level traversable, then let old focus target be that currently focused area of a top-level traversable.
</li>
	<li>
%旧-鎖 ~LET %辿可能 の`現在の~focus鎖$tlT
◎
Let old chain be the current focus chain of the top-level traversable in which old focus target finds itself.
</li>
	<li>
~IF［
%旧-~target ~NIN %旧-鎖
］
⇒
~RET
◎
If old focus target is not one of the entries in old chain, then return.
</li>
	<li>
~IF［
%旧-~target は`~focus可能な区画$でない
］
⇒
~RET
◎
If old focus target is not a focusable area, then return.
</li>
	<li>
%~top文書 ~LET %旧-鎖 の最後の~entry
◎
Let topDocument be old chain's last entry.
</li>
	<li>
~IF［
%~top文書 の`~node~navigable$は`~system~focus$を有している
］
⇒
`~objを~focusする$( %~top文書 の`表示域$ )
◎
If topDocument's node navigable has system focus, then run the focusing steps for topDocument's viewport.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise,＼
</p>
		<ol>
			<li>
%~top文書 の`~node~navigable$から`~system~focus$を除去するための，~platformに特有な関連な規約を適用する
◎
apply any relevant platform-specific conventions for removing system focus from topDocument's node navigable,＼
</li>
			<li>
`~focusを更新する$( %旧-鎖, 空~list, ~NULL )
◎
and run the focus update steps given old chain, an empty list, and null.
</li>
		</ol>
	</li>
</ol>
</div>

<p class="note">注記：
`~objを~unfocusする$ことにより，常に~focusが変更されるとは限らない
— `現在の被focus区画$tlTに適用されるときであっても。
例えば，
`現在の被focus区画$tlTは`表示域$である場合、
通例的には，［
`~objを~focusする$ことにより，別の`~focus可能な区画$が明示的に~focusされる
］までは［
その~focusを保つ
］ことになる。
◎
The unfocusing steps do not always result in the focus changing, even when applied to the currently focused area of a top-level traversable. For example, if the currently focused area of a top-level traversable is a viewport, then it will usually keep its focus regardless until another focusable area is explicitly focused with the focusing steps.
</p>

<hr>

<div class="algo">
<p>
`~focusを更新する@
~algoは、
所与の
( %旧-鎖, %新-鎖, %新-~target )
に対し：
◎
The focus update steps, given an old chain, a new chain, and a new focus target respectively, are as follows:
</p>

<ol>
	<li>
~WHILE［
%旧-鎖 内の最後の~entry ~EQ %新-鎖 内の最後の~entry
］
⇒＃
%旧-鎖 内から最後の~entryを~popする；
%新-鎖 内から最後の~entryを~popする
◎
If the last entry in old chain and the last entry in new chain are the same, pop the last entry from old chain and the last entry from new chain and redo this step.
</li>
	<li>
<p>
%旧-鎖 を成す
~EACH( ~entry %~entry )
に対し：
◎
For each entry entry in old chain, in order, run these substeps:
</p>
		<ol>
			<li id="unfocus-causes-change-event">
<p>
~IF［
~AND↓
］…
</p>
				<ul>
					<li>
%~entry は次を満たす `input$e 要素である
⇒
［
`change$et ~eventが`適用される＠~HEinput#concept-input-apply$
］~AND［
`作動化の挙動$は定義されていない
］
</li>
					<li>
%~entry が~focusされている間に，利用者は %~entry の［
`値$fe ／ `選択された~file~list$
］を変更したが、
その（当の~controlが最初に~focusされたときとは異なる）変更は，
まだ~commitされていない
</li>
				</ul>
<p>
…ならば
⇒＃
%~entry の`利用者~妥当性$ ~SET ~T；
`入力~eventを発火する$( %~entry, `change$et )
</p>
◎
If entry is an input element, and the change event applies to the element, and the element does not have a defined activation behavior, and the user has changed the element's value or its list of selected files while the control was focused without committing that change (such that it is different to what it was when the control was first focused), then:
• Set entry's user validity to true.
• Fire an event named change at the element, with the bubbles attribute initialized to true.
</li>
			<li>
%~blur~event~target ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry は要素である
］
⇒
%~blur~event~target ~LET %~entry
◎
If entry is an element, let blur event target be entry.
</li>
			<li>
~ELIF［
%~entry は`文書$である
］
⇒
%~blur~event~target ~LET %~entry に`関連な大域~obj$
◎
If entry is a Document object, let blur event target be that Document object's relevant global object.
◎
Otherwise, let blur event target be null.
</li>
			<li>
%関係する~target ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry ~EQ %旧-鎖 内の最後の~entry
］~AND［
%~entry は`要素$である
］~AND［
%新-鎖 内の最後の~entryは`要素$である
］
⇒
%関係する~target ~LET %新-鎖 内の最後の~entry
◎
If entry is the last entry in old chain, and entry is an Element, and the last entry in new chain is also an Element, then let related blur target be the last entry in new chain. Otherwise, let related blur target be null.
</li>
			<li>
<p>
~IF［
%~blur~event~target ~NEQ ~NULL
］
⇒
`~focus~eventを発火する$( %~blur~event~target, `blur$et, %関係する~target )
◎
If blur event target is not null, fire a focus event named blur at blur event target, with related blur target as the related target.
</p>

<p class="note" id="note-sometimes-no-blur-event">注記：
~eventは発火されない事例もある
— 例：
%~entry は［
`~focus可能な図形$ ／ ~scroll可能な領域 ／ `表示域$
］であるとき。
◎
In some cases, e.g., if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%新-~target の~focus時に，~platformに特有な関連な規約がある
］
⇒
その規約を適用する
（例えば，一部の~platformは、
~text~controlに~focusされたときに，その内容を選択する）
◎
Apply any relevant platform-specific conventions for focusing new focus target. (For example, some platforms select the contents of a text control when that control is focused.)
</li>
	<li>
<p>
%新-鎖 を成す
~EACH( ~entry %~entry )
に対し，逆順に：
◎
For each entry entry in new chain, in reverse order, run these substeps:
</p>
		<ol>
			<li>
<p>
~IF［
%~entry は`~focus可能な区画$である
］~AND［
%~entry が`指名する被focus区画$doc ~NEQ %~entry
］：
◎
If entry is a focusable area, and the focused area of the document is not entry:
</p>
				<ol>
					<li>
%文書 に`関連な大域~obj$の`~navi~API$の`進行中な~naviの間に~focusは変化したか$ ~SET ~T
◎
Set document's relevant global object's navigation API's focus changed during ongoing navigation to true.
</li>
					<li>
%~entry が属する`文書$が`指名する被focus区画$doc ~SET %~entry
◎
Designate entry as the focused area of the document.
</li>
				</ol>
			</li>
			<li>
%~focus~event~target ~LET %~entry に応じて
⇒＃
要素であるならば %~entry ／
`文書$であるならば %~entry に`関連な大域~obj$ ／
~ELSE_ ~NULL
◎
If entry is an element, let focus event target be entry.
◎
If entry is a Document object, let focus event target be that Document object's relevant global object.
◎
Otherwise, let focus event target be null.
</li>
			<li>
%関係する~target ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry ~EQ %新-鎖 内の最後の~entry
］~AND［
%~entry は`要素$である
］~AND［
%旧-鎖 内の最後の~entryは`要素$である
］
⇒
%関係する~target ~SET %旧-鎖 内の最後の~entry
◎
If entry is the last entry in new chain, and entry is an Element, and the last entry in old chain is also an Element, then let related focus target be the last entry in old chain. Otherwise, let related focus target be null.
</li>
			<li>
<p>
~IF［
%~focus~event~target ~NEQ ~NULL
］
⇒
`~focus~eventを発火する$( %~focus~event~target, `focus$et, %関係する~target )
◎
If focus event target is not null, fire a focus event named focus at focus event target, with related focus target as the related target.
</p>

<p class="note">注記：
~eventは発火されない事例もある
— 例：
%~entry は［
`~focus可能な図形$ ／ ~scroll可能な領域 ／ `表示域$
］であるとき。
◎
In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.
</p>

			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~focus~eventを発火する@
~algoは、
所与の
( 要素 %~target, 名前 %e, 関係する~target %r )
に対し
⇒
`~eventを発火する$( %~target, %e, `FocusEvent$I )
— 次のように初期化して
⇒＃
`relatedTarget$m 属性 ~SET %r,
`view$m 属性 ~SET %~target の`~node文書$に`関連な大域~obj$,
`~composedか$ev ~SET ~T
◎
To fire a focus event named e at an element t with a given related target r, fire an event named e at t, using FocusEvent, with the relatedTarget attribute initialized to r, the view attribute initialized to t's node document's relevant global object, and the composed flag set.
</p>
</div>

<hr>

<div class="algo">
<p>
~UAは、
`~top-level辿可能$ %辿可能 内で~UIkey~event %~event を届けるときは，
次の手続きを走らすモノトスル：
◎
When a key event is to be routed in a top-level traversable, the user agent must run the following steps:
</p>
<ol>
	<li>
%~target区画 ~LET %辿可能 の`現在の被focus区画$tlT
◎
Let target area be the currently focused area of the top-level traversable.
</li>
	<li>
~Assert：
%~target区画 は ~NULL でない
— ~UIkey~eventが届けられる`~top-level辿可能$は、
`~system~focus$を有しているものに限られるので。
したがって、
%~target区画 は`~focus可能な区画$である。
◎
Assert: target area is not null, since key events are only routed to top-level traversables that have system focus. Therefore, target area is a focusable area.
</li>
	<li>
%~target~node ~LET %~target区画 の`~DOM~anchor$
◎
Let target node be target area's DOM anchor.
</li>
	<li>
~IF［
%~target~node は`文書$である
］
⇒
%~target~node ~SET ［
%~target~node の`~body要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %~target~node の`文書~要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %~target~node
］
◎
If target node is a Document that has a body element, then let target node be the body element of that Document.
◎
Otherwise, if target node is a Document object that has a non-null document element, then let target node be that document element.
</li>
	<li>
~IF［
%~target~node は`不活$である
］
⇒
~RET
◎
If target node is not inert, then:
</li>
	<li>
%取扱えるか ~LET `~eventを配送する$( %~target~node, %~event )
◎
Let canHandle be the result of dispatching the key event at target node.
</li>
	<li>
~IF［
%取扱えるか ~EQ ~T
］
⇒
%~target区画 に %~event を取扱わせる
— これは、
%~target~node に向けて`~click~eventを発火する$ことも含み得る。
◎
If canHandle is true, then let target area handle the key event. This might include firing a click event at target node.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`~focusを有するか？@
~algoは、
所与の
( `文書$ %~target )
に対し：
◎
The has focus steps, given a Document object target, are as follows:
</p>

<p class="trans-note">【
この用語を参照する “~focusを有して” ［
いる／いない
］という句は、
この~algoの結果が［
~T ／ ~F
］になることを意味する。
】</p>
<ol>
	<li>
%N ~LET %~target の`~node~navigable$の`~top-level辿可能$nav
◎
↓</li>
	<li>
~IF［
%N は`~system~focus$を有していない
］
⇒
~RET ~F
◎
If target's node navigable's top-level traversable does not have system focus, then return false.
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
%候補 ~LET %N にて`作動中な文書$nav
</li>
			<li>
~IF［
%候補 ~EQ %~target
］
⇒
~RET ~T
</li>
			<li>
%F ~LET %候補 が`指名する被focus区画$doc
</li>
			<li>
~IF［
%F は`~navigable容器$でない
］
⇒
~RET ~F
</li>
			<li>
%N ~SET %F の`内容~navigable$
</li>
			<li>
~IF［
%N ~EQ ~NULL
］
⇒
~RET ~F
</li>
		</ol>
◎
Let candidate be target's node navigable's top-level traversable's active document.
◎
While true:
• If candidate is target, then return true.
• If the focused area of candidate is a navigable container with a non-null content navigable, then set candidate to the active document of that navigable container's content navigable.
• Otherwise, return false.
</li>
</ol>
</div>

			</section>
			<section id="sequential-focus-navigation">
<h4 title="Sequential focus navigation">6.6.5. 連列的~focus~navi</h4>

<p>
所与の`文書$に属する`~focus可能な区画$のうち いくつかは，
`連列的~focus~navi順序@
により順序付けられる：
◎
Each Document has a sequential focus navigation order, which orders some or all of the focusable areas in the Document relative to each other.＼
</p>

<ul>
	<li>
<p>
その内容と順序付けは、
当の文書の`平坦~化された~tabindex順な~focus~navi視野$により与えられる。
◎
Its contents and ordering are given by the flattened tabindex-ordered focus navigation scope of the Document.
</p>

<p class="note">
`平坦~化された~tabindex順な~focus~navi視野$を定義している規則から、
この順序付けは，当の文書の`~tree順序$に関係するとは限らない。
◎
Per the rules defining the flattened tabindex-ordered focus navigation scope, the ordering is not necessarily related to the tree order of the Document.
</p>
	</li>
	<li>
この順序から外された`~focus可能な区画$は、
`連列的~focus~navi$を介しては到達-可能でなくなる。
◎
If a focusable area is omitted from the sequential focus navigation order of its Document, then it is unreachable via sequential focus navigation.
</li>
</ul>

<p>
連列的~focus~naviには
`連列的~focus~naviの始点@
もある。
それは、
初期~時には ε （未設定）とする。
~UAは、
利用者がそれを移動すべく指示したときに，この始点を設定してもヨイ。
◎
There can also be a sequential focus navigation starting point. It is initially unset. The user agent may set it when the user indicates that it should be moved.
</p>

<p class="example">
例えば~UAは、
利用者が文書の内容を~clickしたときに，
その~click位置に設定することもできる。
◎
For example, the user agent could set it to the position of the user's click if the user clicks on the document contents.
</p>

<p class="note">注記：
~UAには、
`素片へ~navigateする$ときには，
`連列的~focus~naviの始点$を`~target要素$に設定することが要求される。
◎
User agents are required to set the sequential focus navigation starting point to the target element when navigating to a fragment.
</p>

<div>
<p>
以下の~algoにおいては、
次に挙げるものが利用される：
</p>
<dl>
	<dt>`連列的~focus方向@</dt>
	<dd>
［
`前方@i,
`後方@i
］いずれかをとる。
</dd>
	<dd>
利用者の要請に応じて連列的~focusが巡る方向を述べる。
</dd>

	<dt>`選定法@</dt>
	<dd>
［
`~DOM順@i,
`連列的@i
］いずれかをとる。
</dd>
	<dd>
`連列的~navi探索~algo$が結果の`~focus可能な区画$をどう見出すかを述べる。
</dd>
</dl>

◎
A sequential focus direction is one of two possible values: "forward", or "backward". They are used in the below algorithms to describe the direction in which sequential focus travels at the user's request.
◎
A selection mechanism is one of two possible values: "DOM", or "sequential". They are used to describe how the sequential navigation search algorithm finds the focusable area it returns.
</div>

<div class="algo">
<div class="p">
<p>
~UAは：
</p>
<ul>
	<li>
<p>
ある`~top-level辿可能$ %top 内で：
</p>
		<ul>
			<li>
(A) %top の`現在の被focus区画$tlTから, または
</li>
			<li>
(B) %top の外側（例：~browserの~URL~bar）から 先ず %top へ~focusを移動した上で，
</li>
		</ul>
	</li>
	<li>
ある`連列的~focus方向$ %方向 へ
</li>
</ul>

<p>
~focusを移動するよう，利用者から要請されたときには
（例： `Tab^Key ~UIkeyを押下げることによる既定の動作として）、
以下の~algoを利用するモノトスル：
</p>

<p class="note">注記：
概して、［
`Tab^Key ／［
`Shift^Key + `Tab^Key
］］を押下げることは［
前方／後方
］にある~controlへ移動することを要請する。
</p>
◎
When the user requests that focus move from the currently focused area of a top-level traversable to the next or previous focusable area (e.g., as the default action of pressing the tab key), or when the user requests that focus sequentially move to a top-level traversable in the first place (e.g., from the browser's location bar), the user agent must use the following algorithm:
</div>

<ol>
	<li>
%始点 ~LET 上述の［
(A) ならば %top の`現在の被focus区画$tlT ／ (B) ならば %top
］
◎
Let starting point be the currently focused area of a top-level traversable, if the user requested to move focus sequentially from there, or else the top-level traversable itself, if the user instead requested to move focus from outside the top-level traversable.
</li>
	<li>
%~focus始点 ~LET `連列的~focus~naviの始点$
◎
↓</li>
	<li>
~IF［
%~focus始点 ~NEQ ε
］~AND［
%~focus始点 は %始点 の内側にある
］
⇒
%始点 ~SET %~focus始点
◎
If there is a sequential focus navigation starting point defined and it is inside starting point, then let starting point be the sequential focus navigation starting point instead.
◎
Let direction be "forward" if the user requested the next control, and "backward" if the user requested the previous control.
◎
Typically, pressing tab requests the next control, and pressing shift + tab requests the previous control.
</li>
	<li>
<p>
~WHILE 無条件：
◎
Loop:＼
</p>
		<ol>
			<li>
%選定法 ~LET ［
次が満たされるならば `連列的$i ／
~ELSE_ `~DOM順$i
］
⇒
［
%始点 は`~navigable$である
］~OR［
%始点 は それが属する`文書$の`連列的~focus~navi順序$に含まれている
］
◎
Let selection mechanism be "sequential" if starting point is a navigable or if starting point is in its Document's sequential focus navigation order.
◎
Otherwise, starting point is not in its Document's sequential focus navigation order; let selection mechanism be "DOM".
</li>
			<li>
%候補 ~LET `連列的~navi探索~algo$( %始点, %方向, %選定法 )
◎
Let candidate be the result of running the sequential navigation search algorithm with starting point, direction, and selection mechanism.
</li>
			<li>
~IF［
%候補 ~NEQ ~NULL
］
⇒＃
`~objを~focusする$( %候補 )；
~RET
◎
If candidate is not null, then run the focusing steps for candidate and return.
</li>
			<li>
`連列的~focus~naviの始点$ ~SET ε
◎
Otherwise, unset the sequential focus navigation starting point.
</li>
			<li>
<p>
~IF［
%始点 ~EQ %top
］~OR［
%始点 は %top 内の`~focus可能な区画$である
］：
◎
If starting point is a top-level traversable, or a focusable area in the top-level traversable,＼
</p>
				<ol>
					<li>
<p>
~IF［
~UAには、
自前の~focus可能な~controlがある
］
⇒
~UAは、
次を行うベキである
⇒
%方向 を尊守しつつ，~focusを自前の~focus可能な~controlのいずれかに適切に転送する
◎
the user agent should transfer focus to its own controls appropriately (if any), honouring direction, and then return.
</p>

<p class="example">
例えば，［
%方向 ~EQ `後方$i
］の場合、［
~browserの具現化~区画の直前にある，`連列的に~focus可能$な~control
］に~focusすることになる。
◎
For example, if direction is backward, then the last sequentially focusable control before the browser's rendering area would be the control to focus.
</p>
					</li>
					<li>
<p>
~ELIF［
`連列的に~focus可能$な~controlは無い
］
⇒
~UAは、
次を行ってもヨイ
⇒＃
%始点 ~SET %top；
~CONTINUE
</p>

<p class="example">
~kiosk~mode~browserなど、
自前の~focus可能な~controlがない~UAもあり得る。
</p>

◎
If the user agent has no sequentially focusable controls — a kiosk-mode browser, for instance — then the user agent may instead restart these steps with the starting point being the top-level traversable itself.
</li>
					<li>
~RET
◎
↑</li>
				</ol>
			</li>
			<li>
~ELSE（ %始点 は ある`子~navigable$ %N 内の`~focus可能な区画$である）
⇒
%始点 ~SET %N の`親$nav
◎
Otherwise, starting point is a focusable area in a child navigable. Set starting point to that child navigable's parent and return to the step labeled loop.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`連列的~navi探索~algo@
は、
所与の
( `~focus可能な区画$【／`~navigable$】 %始点, `連列的~focus方向$ %方向, `選定法$ %選定法 )
に対し，［
~NULL ／`~focus可能な区画$
］を返す：
◎
The sequential navigation search algorithm, given a focusable area starting point, sequential focus direction direction, and selection mechanism selection mechanism, consists of the following steps. They return a focusable area-or-null.
</p>

<div>
<ol>
	<li>
%文書 ~LET %始点 に応じて
⇒＃
`~navigable$であるならば %始点 にて`作動中な文書$nav ／
`~focus可能な区画$であるならば %始点 が属する`文書$
</li>
	<li>
<p>
%候補~群 ~LET %文書 の`連列的~focus~navi順序$に含まれている`~focus可能な区画$のうち次を満たすもの†たちが成す集合
⇒
［
その`~DOM~anchor$は`不活$でない
］~AND［
`連列的に~focus可能$である
］
</p>

<p>
これらの順序は、
%選定法 に応じて［
`連列的$i ならば`連列的~focus~navi順序$ ／
`~DOM順$i ならば`~shadowも含めた~tree順序$
］に従うとする。
</p>

<p class="trans-note">【†
条件を満たすものは、
原文では
`相応しい連列的に~focus可能な区画@
と称されるが，この訳では利用しない
（その各~利用を，この段の中へ集約したので）。
】</p>
	</li>
	<li>
<p>
~IF［
%始点 は`~navigable$である
］
⇒
~Assert：
%選定法 ~EQ `連列的$i
</p>

<p class="trans-note">【
この表明は、
この訳による補完。
この事例では、
順序は，常に`連列的~focus~navi順序$に従う。
】</p>
</li>
	<li>
<p>
~ELSE
⇒
%候補~群 から %方向 に応じて［
`前方$i ならば %始点 より後／
`後方$i ならば %始点 より前
］に現れないものを除去する
</p>

<p class="note">注記：
［
%選定法 ~EQ `~DOM順$i
］~AND［
%方向 ~EQ `前方$i
］の事例では、［
%始点 ~IN %候補~群
］になるとは限らない
— その場合も、
“より後” は`~shadowも含めた~tree順序$に基づく。
</p>
	</li>
	<li>
~IF［
%候補~群 は空である
］
⇒
~RET ~NULL
</li>
	<li>
%候補 ~LET %方向 に応じて
⇒＃
`前方$i ならば %候補~群 を成す最初の~item ／
`後方$i ならば %候補~群 を成す最後の~item
</li>
	<li>
~IF［
%候補 は`~navigable容器$でない
］
⇒
~RET %候補
</li>
	<li>
%~navigable ~LET %候補 の`内容~navigable$
</li>
	<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
~RET %候補
</li>
	<li>
%再帰的~候補 ~LET `連列的~navi探索~algo$( %~navigable, %方向, `連列的$i )
</li>
	<li>
~IF［
%再帰的~候補 ~NEQ ~NULL
］
⇒
~RET %再帰的~候補
</li>
	<li>
~RET `連列的~navi探索~algo$( %候補, %方向, %選定法 )
</li>
</ol>

<p class="trans-note">【
この手続きの~~構成は、
簡潔に述べるよう，原文から大きく違えている。
】</p>

<p>
<ol lang="en" class="_en">
	<li>
<p>
Pick the appropriate cell from the following table, and follow the instructions in that cell.
<p>
The appropriate cell is the one that is from the column whose header describes direction and from the first row whose header describes starting point and selection mechanism.

<table><thead>
<tr><th>
<th>direction is "forward"
<th>direction is "backward"

<tbody><tr><th>
starting point is a navigable
<td>
Let candidate be the first suitable sequentially focusable area in starting point's active document, if any; or else null
<td>
Let candidate be the last suitable sequentially focusable area in starting point's active document, if any; or else null
<tr><th>
selection mechanism is "DOM"
<td>
<p>
Let candidate be the suitable sequentially focusable area, that appears nearest after starting point in starting point's Document, in shadow-including tree order, if any; or else null
<p>
In this case, starting point does not necessarily belong to its Document's sequential focus navigation order, so we'll select the suitable item from that list that comes after starting point in shadow-including tree order.
<td>
Let candidate be the suitable sequentially focusable area, that appears nearest before starting point in starting point's Document, in shadow-including tree order, if any; or else null
<tr><th>
selection mechanism is "sequential"
<td>
Let candidate be the first suitable sequentially focusable area after starting point, in starting point's Document's sequential focus navigation order, if any; or else null
<td>
Let candidate be the last suitable sequentially focusable area before starting point, in starting point's Document's sequential focus navigation order, if any; or else null
</table>

<p>
A suitable sequentially focusable area is a focusable area whose DOM anchor is not inert and is sequentially focusable.
	<li>
<p>
If candidate is a navigable container with a non-null content navigable, then:
</p>
		<ol>
			<li>
Let recursive candidate be the result of running the sequential navigation search algorithm with candidate's content navigable, direction, and "sequential".
</li>
			<li>
If recursive candidate is null, then return the result of running the sequential navigation search algorithm with candidate, direction, and selection mechanism.
</li>
			<li>
Otherwise, set candidate to recursive candidate.
</li>
		</ol>
	<li>
Return candidate.
</ol>
</div>
</div>

			</section>
			<section id="focus-management-apis">
<h4 title="Focus management APIs">6.6.6. ~focus管理~API</h4>

<pre class="idl">
dictionary `FocusOptions@I {
  boolean `preventScroll$mb = false;
  boolean `focusVisible$mb;
};
</pre>

<dl class="domintro">
	<dt>%documentOrShadowRoot.`activeElement$m</dt>
	<dd>
%documentOrShadowRoot 内の要素のうち，~UIkey~eventが［
それを経て／それに向けて
］届けられることになるような，最も深い要素を返す。
これは、
概ね，当の文書~内の~focusされた要素になる。
◎
Returns the deepest element in documentOrShadowRoot through which or to which key events are being routed. This is, roughly speaking, the focused element in the document.
</dd>
	<dd>
この~APIの目的においては、
`子~navigable$が~focusされるときには，その`容器$navが`親$navにて`作動中な文書$navの中で`~focusされる＠#bc-focus-ergo-bcc-focus$。
例えば，利用者が~focusを `iframe$e 内のある~text~controlに移動したとき、
その `iframe$e が，その`~node文書$の `activeElement$m から返される要素になる。
◎
For the purposes of this API, when a child navigable is focused, its container is focused within its parent's active document. For example, if the user moves the focus to a text control in an iframe, the iframe is the element returned by the activeElement API in the iframe's node document.
</dd>
	<dd>
類似に，~focusされた要素が
%documentOrShadowRoot とは異なる`~node~tree$内にある場合、
返される要素は，［
%documentOrShadowRoot は~focusされた要素の`~shadowも含めた広義-先祖$であるならば
%documentOrShadowRoot と同じ`~node~tree$内に所在する`~host$ ／
~ELSE_ ~NULL
］になる。
◎
Similarly, when the focused element is in a different node tree than documentOrShadowRoot, the element returned will be the host that's located in the same node tree as documentOrShadowRoot if documentOrShadowRoot is a shadow-including inclusive ancestor of the focused element, and null if not.
</dd>

	<dt>%document.`hasFocus()$m</dt>
	<dd>
~UIkey~eventは［
%document へ, または %document を経て
］届けられているならば ~T を返す。
~ELSE_ ~F を返す。
これは概ね、
~focusされている［
当の文書, または
その内側に入子にされている文書
］に対応する。
◎
Returns true if key events are being routed through or to the document; otherwise, returns false. Roughly speaking, this corresponds to the document, or a document nested inside this one, being focused.
</dd>

	<dt>%window.`focus()$m</dt>
	<dd>
~focusを %window に`対応する~navigable$（もしあれば）へ移動する。
◎
Moves the focus to window's navigable, if any.
</dd>

	<dt>%element.`focus$mE({ `preventScroll$mb, `focusVisible$mb })</dt>
	<dd>
~focusを %element へ移動する。
◎
Moves the focus to the element.
</dd>
	<dd>
%element は`~navigable容器$である場合、
~focusは，代わりに 要素の`内容~navigable$へ移動される。
◎
If element is a navigable container, moves the focus to its content navigable instead.
</dd>
	<dd>
既定では、
この~methodはまた， %element を~viewの中へ~scrollする。
`preventScroll$mb ~optionを供して ~T に設定すれば、
この挙動は防止される。
◎
By default, this method also scrolls element into view. Providing the preventScroll option and setting it to true prevents this behavior.
</dd>
	<dd>
既定では、
~UAは，~focus環を介して`~focusを指示する＠~SELECTORS4#indicate-focus$か否かを`実装定義$な経験則を利用して決定する。
`focusVisible$mb  ~optionを供して ~T に設定すれば、
~focus環が常に可視になることが確保される。
◎
By default, user agents use implementation-defined heuristics to determine whether to indicate focus via a focus ring. Providing the focusVisible option and setting it to true will ensure the focus ring is always visible.
</dd>

	<dt>%element.`blur()$mE</dt>
	<dd>
~focusを`表示域$へ移動する。
この~methodは、
利用しないことが奨励される。
`表示域$を~focusするよう求める場合、
`文書$の`文書~要素$に対し，
`focus()$mE ~methodを~callすること。
◎
Moves the focus to the viewport. Use of this method is discouraged; if you want to focus the viewport, call the focus() method on the Document's document element.
</dd>
	<dd>
~focus環が目障りであっても、
~focus環を隠すためにこの~methodを利用しないこと。
代わりに、
`focus-visible$ps 疑似類を利用して `outline$p ~prop（外形線）を上書きした上で，
~focusされる要素を示すような他の仕方を供すること。
そのような代替な~focus時の~styleを可用にできなかった場合、［
~keyboardを首に利用して~pageを~navigateしている者や，
~navigateし易くするため~focus外形線を利用している弱視者
］にとっては，~pageの使い勝手がすこぶる悪くなることに留意すること。
◎
Do not use this method to hide the focus ring if you find the focus ring unsightly. Instead, use the :focus-visible pseudo-class to override the 'outline' property, and provide a different way to show what element is focused. Be aware that if an alternative focusing style isn't made available, the page will be significantly less usable for people who primarily navigate pages using a keyboard, or those with reduced vision who use focus outlines to help them navigate the page.
</dd>
	<dd class="example">
<p>
例えば、
`textarea$e 要素の外形線を隠す代わりに，黄色な背景を利用して~focusを指示したければ、
次も利用できる：
◎
For example, to hide the outline from textarea elements and instead use a yellow background to indicate focus, you could use:
</p>

<pre class="lang-css">
textarea:focus-visible { outline: none; background: yellow; color: black; }
</pre>

	</dd>
</dl>

<div class="algo">
<p>
`DocumentOrShadowRoot$I の
`activeElement@m
取得子~手続きは：
◎
The DocumentOrShadowRoot activeElement getter steps are:
</p>
<ol>
	<li>
%候補 ~LET コレの`~node文書$が`指名する被focus区画$docの`~DOM~anchor$
◎
Let candidate be this's node document's focused area's DOM anchor.
</li>
	<li>
%候補 ~SET %候補 をコレに向けて`~targetし直す$
◎
Set candidate to the result of retargeting candidate against this.
</li>
	<li>
~IF［
%候補 の`根$ ~NEQ コレ
］
⇒
~RET ~NULL
◎
If candidate's root is not this, then return null.
</li>
	<li>
~IF［
%候補 は`文書$でない
］
⇒
~RET %候補
◎
If candidate is not a Document object, then return candidate.
</li>
	<li>
~RET ［
%候補 の`~body要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %候補 の`文書~要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ ~NULL
］
◎
If candidate has a body element, then return that body element.
◎
If candidate's document element is non-null, then return that document element.
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
`Document$I の
`hasFocus()@m
~method手続きは
⇒
~RET `~focusを有するか？$( コレ )
◎
The Document hasFocus() method steps are to return the result of running the has focus steps given this.
</div>

<div class="algo">
<p>
`Window$I の
`focus()@m
~method手続きは：
◎
The Window focus() method steps are:
</p>
<ol>
	<li>
%~navigable ~LET コレに`対応する~navigable$
◎
Let current be this's navigable.
</li>
	<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
~RET
◎
If current is null, then return.
</li>
	<li>
~IF［
`~focusを許容する手続き$( %~navigable にて`作動中な文書$nav ) ~EQ ~F
］
⇒
~RET
◎
If the allow focus steps given current's active document return false, then return.
</li>
	<li>
`~objを~focusする$( %~navigable )
◎
Run the focusing steps with current.
</li>
	<li>
~IF［
%~navigable は`~top-level辿可能$である
］
⇒
~UAには，次を誘発することが奨励される
⇒
［
~pageが~focusを得るよう試みていることを，利用者に向けて指示する
］ような，何らかの類の通知
◎
If current is a top-level traversable, user agents are encouraged to trigger some sort of notification to indicate to the user that the page is attempting to gain focus.
</li>
</ol>
</div>

<div class="algo">
<p>
`Window$I の
`blur()@m
~method手続きは、
何もしない。
◎
The Window blur() method steps are to do nothing.
</p>

<p class="note">注記：
歴史的に、［
`focus()$m ／ `blur()$m
］~methodは，
実際には~system~levelの~focus
— 当の`~navigable$を包含している~system~widget（例：~UItabや~UIwindow）の~focus —
にも影響していたが、
この挙動は，利用者をないがしろに敵対的~siteから広く濫用されている。
◎
Historically, the focus() and blur() methods actually affected the system-level focus of the system widget (e.g., tab or window) that contained the navigable, but hostile sites widely abuse this behavior to the user's detriment.
</p>
</div>

<div class="algo">
<p>
`HTMLOrSVGElement$I の
`focus(options)@mE
~method手続きは：
◎
The HTMLOrSVGElement focus(options) method steps are:
</p>
<ol>
	<li>
~IF［
`~focusを許容する手続き$( コレの`~node文書$ ) ~EQ ~F
］
⇒
~RET
◎
If the allow focus steps given this's node document return false, then return.
</li>
	<li>
`~objを~focusする$( コレ )
◎
Run the focusing steps for this.
</li>
	<li>
%~focusを指示するか ~LET %options[ "`focusVisible@mb" ]
◎
↓</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%~focusを指示するか ~EQ ~T
</li>
			<li>
［
%~focusを指示するか ~EQ ε
］~AND［
~UAは、
`~focusを指示する$ことが最善であると決定した
］
</li>
		</ul>

<p>
…ならば
⇒
`実装定義$な仕方で`~focusを指示する$
</p>
◎
If options["focusVisible"] is true, or does not exist but in an implementation-defined way the user agent determines it would be best to do so, then indicate focus.
</li>
	<li>
~IF［
%options[
"`preventScroll@mb"
] ~EQ ~F
］
⇒
`~targetを~viewの中へ~scrollする$( コレ, `auto^l, `center^l, `center^l )
◎
If options["preventScroll"] is false, then scroll a target into view given this, "auto", "center", and "center".
</li>
</ol>
</div>

<div class="algo">
<p>
`HTMLOrSVGElement$I の
`blur()@mE
~method手続きは
⇒
次を走らすベキであるが、
使い勝手の理由から
— 選択的に, または一様に —
何もしないことにしてもヨイ
⇒
`~objを~unfocusする$( コレ )
◎
The HTMLOrSVGElement blur() method steps are:
• The user agent should run the unfocusing steps given this.
• User agents may instead selectively or uniformly do nothing, for usability reasons.
</p>

<p class="example">
例えば、
ただ美観の理由で，
`blur()$mE ~methodを利用して無思慮に~focus環が除去された場合、
~keyboard利用者にとって，~pageの使い勝手は悪くなるであろう。
この~methodの~callを無視すれば、
~keyboardのみで~pageとヤリトリすることを利用者に許容することになろう。
◎
For example, if the blur() method is unwisely being used to remove the focus ring for aesthetics reasons, the page would become unusable by keyboard users. Ignoring calls to this method would thus allow keyboard users to interact with the page.
</p>
</div>

<hr>

<div class="algo">
`~focusを許容する手続き@
は、
所与の
( `文書$ %~target )
に対し
⇒
~RET ~IS［
%~target には `focus-without-user-activation$l 特能の`利用は許容されて$いる
］~OR［
%~target に`関連な大域~obj$は`一過な作動化を有して$いる
］
◎
The allow focus steps, given a Document object target, are:
• If target is allowed to use the "focus-without-user-activation" feature, then return true.
• If target's relevant global object has transient activation, then return true.
• Return false.
</div>

			</section>
			<section id="the-autofocus-attribute">
<h4 title="The autofocus attribute">6.6.7. `autofocus^a 属性</h4>

<p>
`autofocus@a
内容~属性は、［
~pageが読込まれたとき，ただちに要素を~focusする
］よう指示することを作者に許容する
— それは、［
当の要素に手動で~focusせずに，打込みを開始する
］ことを利用者に許容する。
◎
The autofocus content attribute allows the author to indicate that an element is to be focused as soon as the page is loaded, allowing the user to just start typing without having to manually focus the main element.
</p>

<p>
`autofocus$a 属性が［
`dialog$e 要素／ `~popover要素$
］ %先祖 の内側にある要素 %要素 に指定された場合、
%要素 は， %先祖 が示されるようになったとき~focusされることになる。
◎
When the autofocus attribute is specified on an element inside dialog elements or HTML elements whose popover attribute is set, then it will be focused when the dialog or popover becomes shown.
</p>

<p>
`autofocus$a 属性は、
`真偽-属性$である。
◎
The autofocus attribute is a boolean attribute.
</p>

<div class="algo">
<p>
`自動focus根@
を見出す~algoは、
所与の
( `要素$ %要素 )
に対し：
</p>
<ol>
	<li>
<p>
~WHILE 無条件
</p>
		<ol>
			<li>
~IF［
%要素 は `dialog$e 要素である
］
⇒
~RET %要素
</li>
			<li>
~IF［
%要素 は`~popover要素$である
］
⇒
~RET %要素
</li>
			<li>
%親 ~SET %要素 の`親~要素$
</li>
			<li>
~IF［
%親 ~EQ ~NULL
］
⇒
~RET %要素
</li>
			<li>
%要素 ~SET %親
</li>
		</ol>
	</li>
</ol>

<p class="trans-note">【
`自動focus根$は，原文では
“`nearest ancestor autofocus scoping root element^en”
と称されるが、
いかにも長いので，この訳では略語化する。
】</p>

◎
To find the nearest ancestor autofocus scoping root element given an Element element:
• If element is a dialog element, then return element.
• If element's popover attribute is not in the No Popover state, then return element.
• Let ancestor be element.
• While ancestor has a parent element:
•• Set ancestor to ancestor's parent element.
•• If ancestor is a dialog element, then return ancestor.
•• If ancestor's popover attribute is not in the No Popover state, then return ancestor.
• Return ancestor.
</div>

<p>
`自動focus根$が同じになる複数個の要素が，
`autofocus$a 属性を有していてはナラナイ。
◎
There must not be two elements with the same nearest ancestor autofocus scoping root element that both have the autofocus attribute specified.
</p>

<div class="p">
<p>
各 `文書$には、
次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`自動focus候補~群@</dt>
	<dd>
`~list$
— 初期~時は空とする。
</dd>

	<dt>`自動focusは処理-済みか@</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
</dd>
</dl>

◎
Each Document has an autofocus candidates list, initially empty.
◎
Each Document has an autofocus processed flag boolean, initially false.
</div>

<div class="algo">
<p>
`autofocus$a 属性を有する要素 %要素 が，`文書の中へ挿入された$ときは、
次の手続きを走らす：
◎
When an element with the autofocus attribute specified is inserted into a document, run the following steps:
</p>
<ol>
	<li>
任意選択で
⇒
~IF［
利用者は~focusを変更しないよう望むことを指示した（例えば，~form~control内で打込みを開始することにより）
］
⇒
~RET
◎
If the user has indicated (for example, by starting to type in a form control) that they do not wish focus to be changed, then optionally return.
</li>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let target be the element's node document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET
◎
If target is not fully active, then return.
</li>
	<li>
~IF［
`閲覧~文脈~sandbox化( 自動的な特能 )~flag$ ~IN %文書 の`作動中な~sandbox法~flag集合$
］
⇒
~RET
◎
If target's active sandboxing flag set has the sandboxed automatic features browsing context flag, then return.
</li>
	<li>
~IF［
`~focusを許容する手続き$( %文書 ) ~EQ ~F
］
⇒
~RET
◎
If the allow focus steps given target return false, then return.
</li>
	<li>
%~top文書 ~LET %文書 の`~node~navigable$の`~top-level辿可能$navにて`作動中な文書$nav
◎
Let topDocument be target's node navigable's top-level traversable's active document.
</li>
	<li>
~IF［
%~top文書 の`自動focusは処理-済みか$ ~EQ ~F
］
⇒＃
%~top文書 の`自動focus候補~群$から %要素 を`除去する$；
%~top文書 の`自動focus候補~群$に %要素 を`付加する$
◎
If topDocument's autofocus processed flag is false, then＼
remove the element from topDocument's autofocus candidates, and＼
append the element to topDocument's autofocus candidates.
</li>
</ol>

<p class="note">注記：
%要素 は、
`~focus可能な区画$でない場合でも，`自動focus候補~群$が成す~listに格納される
— 文書の中へ挿入された時点では，~focus可能な区画でなくとも、
`自動focus候補~群を洗出す$時点では そうなり得るので。
◎
We do not check if an element is a focusable area before storing it in the autofocus candidates list, because even if it is not a focusable area when it is inserted, it could become one by the time flush autofocus candidates sees it.
</p>
</div>

<div class="algo">
<p>
`自動focus候補~群を洗出す@
~algoは、
所与の
( 文書 %~top文書 )
に対し：
◎
To flush autofocus candidates for a document topDocument, run these steps:
</p>

<ol>
	<li>
~IF［
%~top文書 の`自動focusは処理-済みか$ ~EQ ~T
］
⇒
~RET
◎
If topDocument's autofocus processed flag is true, then return.
</li>
	<li>
%候補~群 ~LET %~top文書 の`自動focus候補~群$
◎
Let candidates be topDocument's autofocus candidates.
</li>
	<li>
~IF［
%候補~群 は`空$である
］
⇒
~RET
◎
If candidates is empty, then return.
</li>
	<li>
<p>
~IF［
%~top文書 が`指名する被focus区画$doc ~NEQ %~top文書
］~OR［
%~top文書 の`~target要素$ ~NEQ ~NULL
］：
◎
If topDocument's focused area is not topDocument itself, or topDocument has non-null target element, then:
</p>
		<ol>
			<li>
%候補~群 を`空にする$
◎
Empty candidates.
</li>
			<li>
%~top文書 の`自動focusは処理-済みか$ ~SET ~T
◎
Set topDocument's autofocus processed flag to true.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~WHILE［
%候補~群 は`空$でない
］：
◎
While candidates is not empty:
</p>
		<ol>
			<li>
%要素 ~LET %候補~群[ 0 ]
◎
Let element be candidates[0].
</li>
			<li>
%文書 ~LET %要素 の`~node文書$
◎
Let doc be element's node document.
</li>
			<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒＃
%候補~群 から %要素 を`除去する$；
~CONTINUE
◎
If doc is not fully active, then remove element from candidates, and continue.
</li>
			<li>
~IF［
%文書 の`~node~navigable$の`~top-level辿可能$ ~NEQ %~top文書 の`~node~navigable$
］
⇒＃
%候補~群 から %要素 を`除去する$；
~CONTINUE
◎
If doc's node navigable's top-level traversable is not the same as topDocument's node navigable, then remove element from candidates, and continue.
</li>
			<li>
<p>
~IF［
%文書 の`~scriptを阻んでいる~stylesheet集合$は`空$でない
］
⇒
~RET
◎
If doc's script-blocking style sheet set is not empty, then return.
</p>

<p class="note">注記：
この事例では、
%要素 は現時点で最良な候補であるが，
%文書 は自動focusするに準備済みでない。
次回に`自動focus候補~群を洗出す$が~callされるとき，再び試行されることになる。
◎
In this case, element is the currently-best candidate, but doc is not ready for autofocusing. We'll try again next time flush autofocus candidates is called.
</p>
			</li>
			<li>
%候補~群 から %要素 を`除去する$
◎
Remove element from candidates.
</li>
			<li>
%文書 の`広義-先祖~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
~IF［
%~navigable にて`作動中な文書$navの`~target要素$ ~NEQ ~NULL
］
⇒
~CONTINUE
◎
Let inclusiveAncestorDocuments be a list consisting of the active document of doc's inclusive ancestor navigables.
◎
If any Document in inclusiveAncestorDocuments has non-null target element, then continue.
</li>
			<li>
%~target ~LET %要素
◎
Let target be element.
</li>
			<li>
<p>
~IF［
%~target は`~focus可能な区画$でない
］
⇒
%~target ~SET `~focus可能な区画を取得する$( %~target )
◎
If target is not a focusable area, then set target to the result of getting the focusable area for target.
</p>

<div class="note">
<p>注記：
`自動focus候補~群$は、
`~focus可能な区画$でない要素を包含し得る。
`~focus可能な区画を取得する$~algoにて取扱われる特別な事例に加えて、
これが起こり得るわけには，次が挙げられる：
</p>
<ul>
	<li>
`autofocus$a 属性を有するが［
`~focus可能な区画$ではなく，決して~focus可能にならない要素
］が`文書の中へ挿入された$。
</li>
	<li>
要素は~focus可能であったが、
`自動focus候補~群$に格納されたときには，状態sが変化した。
</li>
</ul>
◎
Autofocus candidates can contain elements which are not focusable areas. In addition to the special cases handled in the get the focusable area algorithm, this can happen because a non-focusable area element with an autofocus attribute was inserted into a document and it never became focusable, or because the element was focusable but its status changed while it was stored in autofocus candidates.
</div>
			</li>
			<li>
<p>
~IF［
%~target ~NEQ ~NULL
］：
◎
If target is not null, then:
</p>
				<ol>
					<li>
%候補~群 を`空にする$
◎
Empty candidates.
</li>
					<li>
%~top文書 の`自動focusは処理-済みか$ ~SET ~T
◎
Set topDocument's autofocus processed flag to true.
</li>
					<li>
`~objを~focusする$( %~target )
◎
Run the focusing steps for target.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
これは、
文書を読込んでいる間の自動的な~focusを取扱う。
`dialog$e 要素の［
`show()$m ／ `showModal()$m
］~methodも， `autofocus$a 属性を処理する。
◎
This handles the automatic focusing during document load. The show() and showModal() methods of dialog elements also processes the autofocus attribute.
</p>
</div>

<p class="note">注記：
要素を~focusするとき、
~UAは，当の~browser~UIwindowを
— それが【~OSにおいて】~focusを失っていた場合に —
~focusする必要があるわけでない。
◎
Focusing the element does not imply that the user agent has to focus the browser window if it has lost focus.
</p>

<div class="example">
<p>
次の~code片の~text~controlは、
文書が読込まれたときに~focusされることになる。
◎
In the following snippet, the text control would be focused when the document was loaded.
</p>

`autofocus-1^xCode
</div>

<div class="example">
<p>
`autofocus$a 属性は、
~form~controlのみならず，すべての要素に適用される。
これにより，次の例も許容される。
◎
The autofocus attribute applies to all elements, not just to form controls. This allows examples such as the following:
</p>

`autofocus-2^xCode
</div>

			</section>
		</section>
		<section id="assigning-keyboard-shortcuts">
<h3 title="Assigning keyboard shortcuts">6.7. ~keyboard~shortcutのアテガイ</h3>

			<section id="introduction-9">
<h4 title="Introduction">6.7.1. 序論</h4>

◎非規範的

<p>
［
作動化-／~focus
］され得る各~要素には、
`accesskey$a 属性を利用して，それを作動化させる単独の~UIkey組合nをアテガえる。
◎
Each element that can be activated or focused can be assigned a single key combination to activate it, using the accesskey attribute.
</p>

<p>
正確な~shortcutは、
`accesskey$a 属性から供される情報を基に，利用者の~keyboardについての情報
— ［
~platform上にすでに存在する ／
~page上で他に指定されている
］~shortcutなど —
に基づいて、
~UAにより決定される
◎
The exact shortcut is determined by the user agent, based on information about the user's keyboard, what keyboard shortcuts already exist on the platform, and what other shortcuts have been specified on the page, using the information provided in the accesskey attribute as a guide.
</p>

<p>
`accesskey$a 属性~内にいくつもの代替を供すれば、
作者は，［
多様な入力~装置にわたり，関連な~keyboard~shortcutが可用になる
］ことを確保できる。
◎
In order to ensure that a relevant keyboard shortcut is available on a wide variety of input devices, the author can provide a number of alternatives in the accesskey attribute.
</p>

<p>
各~代替は、
普通字や数字などの単独の文字からなる。
◎
Each alternative consists of a single character, such as a letter or digit.
</p>

<p>
~UAは，~keyboard~shortcutの~listを利用者に供せるが、
作者も，そうすることが奨励される。
`accessKeyLabel$m ~IDL属性は、
~UAが実際にアテガった~UIkey組合nを表現している文字列を返す。
◎
User agents can provide users with a list of the keyboard shortcuts, but authors are encouraged to do so also. The accessKeyLabel IDL attribute returns a string representing the actual key combination assigned by the user agent.
</p>

<div class="example">
<p>
次の例には、
~shortcut~UIkeyを利用して呼出せる~buttonが供されている。
作者は、
アリな~UIkeyとして，~full~keyboard用の "C" に加え，
十keyしかないときに備えて別の~UIkey "1" も供している。
◎
In this example, an author has provided a button that can be invoked using a shortcut key. To support full keyboards, the author has provided "C" as a possible key. To support devices equipped only with numeric keypads, the author has provided "1" as another possible key.
</p>

`intro9-1^xCode
</div>

<div class="example">
<p>
どの~shortcut~UIkeyがあるか，利用者に伝えるため、
~buttonの~labelに~UIkey組合nを明示的に追加する例：
【！ opted to＊ 】
◎
To tell the user what the shortcut key is, the author has here opted to explicitly add the key combination to the button's label:
</p>

<pre class="lang-js">
function addShortcutKeyLabel(%button) {
<strong>  if (%button.accessKeyLabel != '')
    %button.value += ' (' + %button.accessKeyLabel + ')';</strong>
}
addShortcutKeyLabel(document.getElementById('c'));
</pre>

<p>
同じ~UIkey組合nであっても、
~browserが示す~labelは，各~platformに普及している規約に応じて異なり得る。
例えば、
~UIkey組合nが［
`Control^Key + `Shift^Key + `C^Key
］ならば、［
Windows ~browserでは `Ctrl+Shift+C^samp ／
Mac ~browserでは `^⇧C^samp ／
Emacs ~browserでは `C-C^samp
］のように表示されるであろう。
類似に，~UIkey組合nが［
`Alt^Key + `Escape^Key
］であれば、［
Windows では `Alt+Esc^samp ／
Mac では `⌥⎋^samp ／
Emacs ~browserでは `M-ESC^samp または `ESC ESC^samp
］が利用されるであろう。
◎
Browsers on different platforms will show different labels, even for the same key combination, based on the convention prevalent on that platform. For example, if the key combination is the Control key, the Shift key, and the letter C, a Windows browser might display "Ctrl+Shift+C", whereas a Mac browser might display "^⇧C", while an Emacs browser might just display "C-C". Similarly, if the key combination is the Alt key and the Escape key, Windows might use "Alt+Esc", Mac might use "⌥⎋", and an Emacs browser might use "M-ESC" or "ESC ESC".
</p>

<p>
したがって一般に、
`accessKeyLabel$m ~IDL属性から返される値を構文解析するよう試みるのは，
賢明とは言えない。
◎
In general, therefore, it is unwise to attempt to parse the value returned from the accessKeyLabel IDL attribute.
</p>
</div>

			</section>
			<section id="the-accesskey-attribute">
<h4 title="The accesskey attribute">6.7.2. `accesskey^a 属性</h4>

<p>
`accesskey$a 内容~属性は、
すべての`~HTML要素$に設定できる。
この属性の値は、
要素を［
作動化する／~focusする
］ための~keyboard~shortcutを作成する基になる情報として，~UAにより利用される。
◎
All HTML elements may have the accesskey content attribute set. The accesskey attribute's value is used by the user agent as a guide for creating a keyboard shortcut that activates or focuses the element.
</p>

<p>
この属性に指定する値は、
`~space等で分離された~token集合$（一意, 有順序）であって，
それを成す各~tokenは正確に 1 個の符号位置でなければナラナイ。
◎
If specified, the value must be an ordered set of unique space-separated tokens none of which are identical to another token and each of which must be exactly one code point in length.
</p>

<div class="example">
<p>
次の例では、
各~linkに~access~UIkeyがアテガわれている
— ~siteに馴染んでいる~keyboard利用者は、
関連な~pageに素早く~navigateできるようになる：
◎
In the following example, a variety of links are given with access keys so that keyboard users familiar with the site can more quickly navigate to the relevant pages:
</p>

`accesskey-1^xCode
</div>

<div class="example">
<p>
次の例では、
探索~欄に，アリな~access~UIkeyとして
`s^l, `0^l
の 2 つがこの順で与えられている。
~full~keyboard装置を備えている~UAは、
~shortcut~UIkeyとして［
`Ctrl^Key + `Alt^Key + `S^Key
］を~~選ぶであろう。
一方で，十keyしか備えていない装置~上の~UAは、
~UIkey
`0^Key
を~~選ぶであろう：
◎
In the following example, the search field is given two possible access keys, "s" and "0" (in that order). A user agent on a device with a full keyboard might pick Ctrl + Alt + S as the shortcut key, while a user agent on a small device with just a numeric keypad might pick just the plain unadorned key 0:
</p>

`accesskey-2^xCode
</div>

<div class="example">
<p>
次の例では、
アリな~access~UIkeyが~buttonに記述されている。
加えて，~UAが選択した~UIkey組合nを告知するため、
~scriptは，~buttonの~labelを更新するよう試行する。
◎
In the following example, a button has possible access keys described. A script then tries to update the button's label to advertise the key combination the user agent selected.
</p>

<pre class="lang-html">
&lt;input type=submit accesskey="N @ 1" value="Compose"&gt;
...
&lt;script&gt;
 function labelButton(%button) {
   if (%button.accessKeyLabel)
     %button.value += ' (' + %button.accessKeyLabel + ')';
 }
 var %inputs = document.getElementsByTagName('input');
 for (var %i = 0; %i &lt; %inputs.length; %i += 1) {
   if (%inputs[%i].type == "submit")
     labelButton(%inputs[%i]);
 }
&lt;/script&gt;
</pre>

<p>
~buttonの~labelは、
~UAに応じて，
`Compose (⌘N)^l にも `Compose (Alt+⇧+1)^l にもなり得る。
~UAが~UIkeyをアテガわなければ、
`Compose^l のみになる。
正確な文字列は、
`アテガわれた~access~UIkey$, および
~UAがその~UIkey組合nをどう表現するかに依存する。
◎
On one user agent, the button's label might become "Compose (⌘N)". On another, it might become "Compose (Alt+⇧+1)". If the user agent doesn't assign a key, it will be just "Compose". The exact string depends on what the assigned access key is, and on how the user agent represents that key combination.
</p>
</div>

			</section>
			<section id="keyboard-shortcuts-processing-model">
<h4 title="Processing model">6.7.3. 処理~model</h4>

<p>
要素に
`アテガわれた~access~UIkey@
とは、
要素の `accesskey$a 内容~属性から導出される~UIkey組合nである
— 初期~時には、
どのような~access~UIkeyもアテガわれないモノトスル。
◎
An element's assigned access key is a key combination derived from the element's accesskey content attribute. Initially, an element must not have an assigned access key.
</p>

<div class="algo">
<p>
~UAは、
要素 %要素 の `accesskey$a 属性が［
設定-／変更-／除去-
］される度に，
%要素 に`アテガわれた~access~UIkey$を［
次の手続きを走らせた結果
］になるよう更新するモノトスル：
◎
Whenever an element's accesskey attribute is set, changed, or removed, the user agent must update the element's assigned access key by running the following steps:
</p>
<ol>
	<li>
<p>
~IF［
%要素 は `accesskey$a 属性を有する
］
⇒
`~ASCII空白で分割する$( 属性の値 )
— その結果を成す
~EACH( %値 )
に対し：
◎
If the element has no accesskey attribute, then skip to the fallback step below.
◎
Otherwise, split the attribute's value on ASCII whitespace, and let keys be the resulting tokens.
◎
For each value in keys in turn, in the order the tokens appeared in the attribute's value, run the following substeps:
</p>
		<ol>
			<li>
~IF［
%値 を成す符号位置の個数 ~NEQ 1
］
⇒
~CONTINUE
◎
If the value is not a string exactly one code point in length, then skip the remainder of these steps for this value.
</li>
			<li>
~IF［
%値 は~systemの~keyboard上のどの~UIkeyにも対応しない
］
⇒
~CONTINUE
◎
If the value does not correspond to a key on the system's keyboard, then skip the remainder of these steps for this value.
</li>
			<li>
◎追跡路
任意選択で
⇒
~IF［［
%値 に対応する~UIkey, 0 個以上の修飾~UIkey
］の組み合わせに，~access~UIkeyとして利用できるものがある
］
⇒
~RET その~UIkey組合n
◎
(This is a tracking vector.)
If the user agent can find a mix of zero or more modifier keys that, combined with the key that corresponds to the value given in the attribute, can be used as the access key, then the user agent may assign that combination of keys as the element's assigned access key and return.
</li>
		</ol>
	</li>
	<li>
任意選択で
⇒
~RET ~UAが選んだ~UIkey組合n
◎
Fallback: Optionally, the user agent may assign a key combination of its choosing as the element's assigned access key and then return.
</li>
	<li>
~RET ~access~UIkeyなし
◎
If this step is reached, the element has no assigned access key.
</li>
</ol>
</div>

<p>
~UAは、
所与の要素 %要素 に対し：
◎
↓</p>
<ul>
	<li>
%要素 用に~access~UIkeyを選定してアテガったなら、［
%要素 の `accesskey$a 内容~属性が変更される］
か［
%要素 が別の`文書$へ移動される
］までは，
%要素 に`アテガわれた~access~UIkey$を変更するベキでない。
◎
Once a user agent has selected and assigned an access key for an element, the user agent should not change the element's assigned access key unless the accesskey content attribute is changed or the element is moved to another Document.
</li>
	<li>
<p>
%要素 が ある`~command$ %~command を定義する場合、
利用者が［
%要素 に`アテガわれた~access~UIkey$に対応する~UIkey組合n
］を押下げたときは，［
~AND↓ が満たされるならば，
%~command の`動作$cFを誘発する
］モノトスル：
</p>
<ul>
	<li>
%~command の`隠されるか$cF ~EQ ~F （可視である）
</li>
	<li>
%~command の`不能化されるか$cF ~EQ ~F （可能化されている）
</li>
	<li>
%要素 は、
次を満たす`文書~内にある$
⇒
`属する閲覧~文脈$ ~NEQ ~NULL
</li>
	<li>
%要素 の どの`広義-先祖$も `hidden$a 属性を有さない
</li>
</ul>
◎
When the user presses the key combination corresponding to the assigned access key for an element,＼
if the element defines a command,＼
the command's Hidden State facet is false (visible),＼
the command's Disabled State facet is also false (enabled),＼
the element is in a document that has a non-null browsing context,＼
and neither the element nor any of its ancestors has a hidden attribute specified,＼
then the user agent must trigger the Action of the command.
</li>
</ul>

<p class="note">注記：
~UAは、
`accesskey$a 属性を有する要素を，他の仕方で
— 例：特定の~UIkey組合nに呼応して表示される~menu内に —
`公開することもある＠~HEinteractive#expose-commands-in-ui$。
◎
User agents might expose elements that have an accesskey attribute in other ways as well, e.g. in a menu displayed in response to a specific key combination.
</p> 

<hr>

<div class="algo">
`accessKeyLabel@m
取得子~手続きは
⇒
~RET ［
要素に`アテガわれた~access~UIkey$はあるならば それを表現する文字列 ／
~ELSE_ 空~文字列
］
◎
The accessKeyLabel IDL attribute must return a string that represents the element's assigned access key, if any. If the element does not have one, then the IDL attribute must return the empty string.
</div>

			</section>
		</section>
		<section id="editing-2">
<h3 title="Editing">6.8. 編集</h3>

			<section id="contenteditable">
<h4 title="Making document regions editable: The contenteditable content attribute">6.8.1. 文書の領域を編集-可能にする： `contenteditable^a 属性</h4>

<pre class="idl">
interface mixin `ElementContentEditable@I {
  [`CEReactions$] attribute DOMString `contentEditable$m;
  [`CEReactions$] attribute DOMString `enterKeyHint$m;
  readonly attribute boolean `isContentEditable$m;
  [`CEReactions$] attribute DOMString `inputMode$m;
};
</pre>

<p>
`contenteditable@a
内容~属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The contenteditable content attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態
<th>概略的な記述
<tbody>

<tr><td>`true@v
<td>`~T@st
<td>
当の要素は、
編集-可能である。

<tr><td>`false@v
<td>`~F@st
<td>当の要素は、
編集-可能でない。

<tr><td>`plaintext-only@v
<td>`素な~textのみ@st
<td>当の要素は，
生な~text内容に限り編集-可能であり、
~rich~text形式~化は不能化される。

<tr><td>
<td>`継承-@st
<td>当の要素が編集-可能になるか否かは、
親の［
この属性の状態
］に基づく。
</table>

<p>
`contenteditable$a 属性の
⇒＃
`欠落~値~用の既定の状態$は `継承-$st とする。
`妥当でない値~用の既定の状態$は `継承-$st とする。
`空~文字列~用の既定の状態$は `~T$st とする。
</p>
◎
Keyword｜State｜Brief description
true｜True｜The element is editable.
false｜False｜The element is not editable.
plaintext-only｜Plaintext-Only｜Only the element's raw text content is editable; rich formatting is disabled.
◎
The attribute's missing value default and invalid value default are both the Inherit state.＼
The inherit state indicates that the element is editable (or not) based on the parent element's state.＼
The attribute's empty value default is the True state.
</div>

<div class="example">
<p>
例えば、
~page内に 新たな~~記事の~~投稿用に `form$e と `textarea$e があって，
利用者は~HTMLで~~記事を書くよう期待されているとする：
◎
For example, consider a page that has a form and a textarea to publish a new article, where the user is expected to write the article using HTML:
</p>

`contenteditable-1^xCode

<p>
~scriptが可能化されている下では、
`contenteditable$a 属性を利用して，
`textarea$e 要素を~rich~text~controlに置換することもできる：
◎
When scripting is enabled, the textarea element could be replaced with a rich text control instead, using the contenteditable attribute:
</p>

`contenteditable-2^xCode

<p>
例：~linkを挿入-可能にする特能は、
`execCommand()$m ~APIを利用して, あるいは
`Selection$I ~APIと他の~DOM~APIを利用して実装できる。
`EXECCOMMAND$r `SELECTION$r `DOM$r
◎
Features to enable, e.g., inserting links, can be implemented using the document.execCommand() API, or using Selection APIs and other DOM APIs. [EXECCOMMAND] [SELECTION] [DOM]
</p>
</div>

<div class="example">
<p>
`contenteditable$a 属性は、
効果を great にする【？】ためにも利用できる：
◎
The contenteditable attribute can also be used to great effect:
</p>

`contenteditable-3^xCode
</div>

<dl class="domintro">
	<dt>%element.`contentEditable$m [ = %value ]</dt>
	<dd>
`contenteditable$a 属性の状態に基づいて，次に挙げるいずれかを返す
⇒＃
`true^l,
`plaintext-only^l,
`false^l,
`inherit^l
◎
Returns "true", "plaintext-only", "false", or "inherit", based on the state of the contenteditable attribute.
</dd>
	<dd>
設定して，その状態を変更できる
— 新たな値が，上に挙げたどの文字列でもない場合、
`SyntaxError$E 例外が投出される。
◎
Can be set, to change that state.
◎
Throws a "SyntaxError" DOMException if the new value isn't one of those strings.
</dd>

	<dt>%element.`isContentEditable$m</dt>
	<dd>
当の要素は編集-可能ならば ~T ／
~ELSE_ ~F
を返す。
◎
Returns true if the element is editable; otherwise, returns false.
</dd>
</dl>

<p>
`contentEditable@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET コレの `contenteditable$a 内容~属性の状態に応じて
⇒＃
`~T$st ならば `true^l ／
`素な~textのみ$st ならば `plaintext-only^l ／
`~F$st ならば `false^l ／
`継承-$st ならば【！otherwise】 `inherit^l
◎
The contentEditable IDL attribute, on getting, must return the string "true" if the content attribute is set to the True state, "plaintext-only" if the content attribute is set to the Plaintext-Only state, "false" if the content attribute is set to the False state, and "inherit" otherwise.＼
</li>
	<li class="algo">
<p>
設定子~手続きは：
</p>
		<ol>
			<li>
%値 ~LET `~ASCII小文字~化する$( 所与の値 )
</li>
			<li>
~IF［
%値 ~IN { `true^l, `plaintext-only^l, `false^l }
］
⇒
コレの `contenteditable$a 内容~属性の値 ~SET %値
</li>
			<li>
~ELIF［
%値 ~EQ `inherit^l
］
⇒
コレの `contenteditable$a 内容~属性を除去する
</li>
			<li>
~ELSE
⇒
~THROW `SyntaxError$E
</li>
		</ol>
◎
On setting, if the new value is an ASCII case-insensitive match for the string "inherit", then the content attribute must be removed, if the new value is an ASCII case-insensitive match for the string "true", then the content attribute must be set to the string "true", if the new value is an ASCII case-insensitive match for the string "plaintext-only", then the content attribute must be set to the string "plaintext-only", if the new value is an ASCII case-insensitive match for the string "false", then the content attribute must be set to the string "false", and otherwise the attribute setter must throw a "SyntaxError" DOMException.
</li>
</ul>


<div class="algo">
<p>
`isContentEditable@m
取得子~手続きは
⇒
~RET ~IS［
コレは`編集中の~host$である
］~OR［
コレは`編集-可能$である
］
◎
The isContentEditable IDL attribute, on getting, must return true if the element is either an editing host or editable, and false otherwise.
</div>

			</section>
			<section id="making-entire-documents-editable:-the-designmode-idl-attribute">
<h4 title="Making entire documents editable: the designMode getter and setter">6.8.2. 文書~全体を編集-可能にする： `designMode^m の取得子と設定子</h4>

<dl class="domintro">
	<dt>%document.`designMode$m [ = %value ]</dt>
	<dd>
文書は［
編集-可能ならば `on^l ／
~ELSE_ `off^l
］返す。
◎
Returns "on" if the document is editable, and "off" if it isn't.
</dd>
	<dd>
設定して文書の現在の状態を変更できる。
これは、
文書を~focusした上で，文書~内の選択を設定し直す。
◎
Can be set, to change the document's current state. This focuses the document and resets the selection in that document.
</dd>
</dl>

<p>
各 `文書$には，真偽値をとる
`~design~modeは可能化されるか@
が結付けられ、
初期~時には ~F をとるとする。
◎
Document objects have an associated design mode enabled, which is a boolean. It is initially false.
</p>

<p>
`designMode@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET コレの`~design~modeは可能化されるか$に応じて
⇒＃
~T ならば `on^l ／
~F ならば `off^l
◎
The designMode getter steps are to return "on" if this's design mode enabled is true; otherwise "off".
</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The designMode setter steps are:
</p>
		<ol>
			<li>
%値 ~LET `~ASCII小文字~化する$( 所与の値 )
◎
Let value be the given value, converted to ASCII lowercase.
</li>
			<li>
<p>
~IF［
%値 ~EQ `on^l
］~AND［
コレの`~design~modeは可能化されるか$ ~EQ ~F
］：
◎
If value is "on" and this's design mode enabled is false, then:
</p>
				<ol>
					<li>
コレの`~design~modeは可能化されるか$ ~SET ~T
◎
Set this's design mode enabled to true.
</li>
					<li>
コレにて`作動中な範囲$の［
始端, 終端
］境界点をコレの始端に設定し直す
◎
Reset this's active range's start and end boundary points to be at the start of this.
</li>
					<li>
~IF［
コレの`文書~要素$ ~NEQ ~NULL
］
⇒
`~objを~focusする$( コレの`文書~要素$ )
◎
Run the focusing steps for this's document element, if non-null.
</li>
				</ol>
			</li>
			<li>
~IF［
%値 ~EQ `off^l
］
⇒
コレの`~design~modeは可能化されるか$ ~SET ~F
◎
If value is "off", then set this's design mode enabled to false.
</li>
		</ol>
	</li>
</ul>

			</section>
			<section id="best-practices-for-in-page-editors">
<h4 title="Best practices for in-page editors">6.8.3. ~page編集者による最善な実施</h4>

<p>
作者には、［
`編集中の~host$, および
編集-用の仕組みを通して作成された~markup
］上の `white-space$p ~propを値 `pre-wrap^v に設定することが奨励される。
~HTMLにおける空白に対する既定の取扱いは、
WYSIWYG 編集には不向きである
— `white-space$p が初期~値【！既定~値】のままだと、
一部のきわどい事例では，行lの折返ngが正しく働かなくなる。
◎
Authors are encouraged to set the 'white-space' property on editing hosts and on markup that was originally created through these editing mechanisms to the value 'pre-wrap'. Default HTML whitespace handling is not well suited to WYSIWYG editing, and line wrapping will not work correctly in some corner cases if 'white-space' is left at its default value.
</p>

<div class="example">
<p>
`white-space$p に初期~値【！既定~値】 `normal^v が利用された場合に生じる問題の一例として
— 以下，［
`space^i【！ "␣"】 は定例の space（ U+0020 ）,
`nbsp^i は分断不可 space（ `non-breaking space^en ）
］を表す —
利用者が［
"`yellow^kbd", `space^i, `space^i, `ball^kbd"
］を続けて打込んだときを考える。
初期~値【！既定~値】 `normal^v の下では，
~~連続する `space^i は 1 個に縮約する呈示が要求されるので、
結果の~markupにおいては，［
`yellow^l, `nbsp^i, `space^i, `ball^l
］並び, または［
`yellow^l, `space^i, `nbsp^i, `ball^l
］並びに代えるような編集~規則が必要yである。
単語 `yellow^l, `ball^l の合間で行lを折返す必要がある場合：
◎
As an example of problems that occur if the default 'normal' value is used instead, consider the case of the user typing "yellow␣␣ball", with two spaces (here represented by "␣") between the words. With the editing rules in place for the default value of 'white-space' ('normal'), the resulting markup will either consist of "yellow&amp;nbsp; ball" or "yellow &amp;nbsp;ball"; i.e., there will be a non-breaking space between the two words in addition to the regular space. This is necessary because the 'normal' value for 'white-space' requires adjacent regular spaces to be collapsed together.
</p>
<ul>
	<li>
前者の事例（ `nbsp^i, `space^i ）では、
`yellow^l と `nbsp^i が次の行lへ折返されるかもしれない
— `yellow^l だけなら行lの終端までに収まる場合でも。
◎
In the former case, "yellow⍽" might wrap to the next line ("⍽" being used here to represent a non-breaking space) even though "yellow" alone might fit at the end of the line;＼
</li>
	<li>
前者の事例（ `space^i, `nbsp^i ）では、
`nbsp^i の直前で次の行lへ折返される結果，単語 `ball^l の前に字下げが露わになる。
◎
in the latter case, "⍽ball", if wrapped to the start of the line, would have visible indentation from the non-breaking space.
</li>
</ul>

<p>
一方で、
`white-space$p が `pre-wrap^v に設定された下での編集~規則は，
単語の合間に 2 個の `space^i を挟むだけ済む。
その結果，単語 `yellow^l, `ball^l は行lの終端にて分割され、
`space^i たちは具現化からきれいに除去されることになる。
◎
When 'white-space' is set to 'pre-wrap', however, the editing rules will instead simply put two regular spaces between the words, and should the two words be split at the end of a line, the spaces would be neatly removed from the rendering.
</p>
</div>

			</section>
			<section id="editing-apis">
<h4 title="Editing APIs">6.8.4. 編集~API</h4>

<p>
`編集中の~host@
とは、
~OR↓ を満たす`~HTML要素$である：
◎
An editing host is either＼
</p>
<ul>
	<li>
`contenteditable$a 属性の状態 ~IN { `~T$st, `素な~textのみ$st }
◎
an HTML element with its contenteditable attribute in the true state or Plaintext-Only state, or＼
</li>
	<li>
次を満たす`文書$の`子$である
⇒
`~design~modeは可能化されるか$ ~EQ ~T
◎
a child HTML element of a Document whose design mode enabled is true.
</li>
</ul>

<div>
<p>
次に挙げるものは、
`EXECCOMMAND$r 仕様にて定義される：
</p>
<ul>
	<li id="active-range">
`作動中な範囲$
</li>
	<li id="editing-host-of">
~nodeが`属する編集中の~host$
</li>
	<li id="editable">
`編集-可能$
</li>
	<li>
［
`編集中の~host$ ／ `編集-可能$
］である要素に課される~UI要件
</li>
	<li>
~text選択
</li>
	<li id="delete-the-selection">
`選択を削除-$する~algo
</li>
	<li>
次に挙げる各種~method
⇒＃
`execCommand()$m,
`queryCommandEnabled()$m,
`queryCommandIndeterm()$m,
`queryCommandState()$m,
`queryCommandSupported()$m,
`queryCommandValue()$m
</li>
</ul>
◎
The definition of the terms active range, editing host of, and editable, the user interface requirements of elements that are editing hosts or editable, the execCommand(), queryCommandEnabled(), queryCommandIndeterm(), queryCommandState(), queryCommandSupported(), and queryCommandValue() methods, text selections, and the delete the selection algorithm are defined in execCommand. [EXECCOMMAND]
</div>

			</section>
			<section id="spelling-and-grammar-checking">
<h4 title="Spelling and grammar checking">6.8.5. 綴りや文法の検査ng： `spellcheck^a 属性</h4>

<p>
~UAは、［
~form~control（ `textarea$e 要素の値など）や,
`編集中の~host$内の要素（例： `contenteditable$a を利用して）
］内の編集-可能な~textに対する綴りや文法の検査ngを~supportできる。
◎
User agents can support the checking of spelling and grammar of editable text, either in form controls (such as the value of textarea elements), or in elements in an editing host (e.g. using contenteditable).
</p>

<p>
~UAは、
各~要素に対し，［
既定のもの, または利用者が表出した選好
］を通して、
`既定の挙動@
を確立するモノトスル。
各~要素~用にアリな`既定の挙動$には、
次に挙げる 3 種がある：
◎
For each element, user agents must establish a default behavior, either through defaults or through preferences expressed by the user. There are three possible default behaviors for each element:
</p>
<dl>
	<dt>
`既定では~T@i
◎
true-by-default
</dt>
	<dd>
要素の内容の綴りや文法は、［
その内容が編集-可能であって，
その検査ngは `spellcheck$a 属性を通して明示的に不能化されていない
］ならば，検査される。
◎
The element will be checked for spelling and grammar if its contents are editable and spellchecking is not explicitly disabled through the spellcheck attribute.
</dd>
	<dt>
`既定では~F@i
◎
false-by-default
</dt>
	<dd>
要素の綴りや文法は、
`spellcheck$a 属性を通して明示的に可能化されていない限り，
決して検査されない。
◎
The element will never be checked for spelling and grammar unless spellchecking is explicitly enabled through the spellcheck attribute.
</dd>
	<dt>
`既定では継承する@i
◎
inherit-by-default
</dt>
	<dd>
要素の既定の挙動は、
その親~要素のそれと同じになる。
親~要素が無い場合、
既定の挙動は無い。
◎
The element's default behavior is the same as its parent element's. Elements that have no parent element cannot have this as their default behavior.
</dd>
</dl>

<hr>

<p>
`spellcheck@a
属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The spellcheck attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態
<th>概略的な記述
<tbody>

<tr><td>`true@vS
<td>`~T@stS
<td>綴りや文法は検査される。

<tr><td>`false@vS
<td>`~F@stS
<td>綴りや文法は検査されない。

<tr><td>
<td>`既定@stS
<td>
以下に定義されるとおり，既定の挙動に則って動作する
— 場合によっては、
親~要素の `spellcheck$a の状態に基づいて。
</table>

<p>
`spellcheck$a 属性の
⇒＃
`欠落~値~用の既定の状態$は `既定$stS とする。
`妥当でない値~用の既定の状態$は `既定$stS とする。
`空~文字列~用の既定の状態$は `~T$stS とする。
</p>
◎
Keyword｜State｜Brief description
true｜True｜Spelling and grammar will be checked.
false｜False｜Spelling and grammar will not be checked.
◎
The attribute's missing value default and invalid value default are both the Default state. The default state indicates that the element is to act according to a default behavior, possibly based on the parent element's own spellcheck state, as defined below. The attribute's empty value default is the True state.
</div>

<hr>

<dl class="domintro">
	<dt>%element.`spellcheck$m [ = %value ]</dt>
	<dd>
要素の綴りや文法が検査されるならば ~T ／
~ELSE_ ~F
を返す。
◎
Returns true if the element is to have its spelling and grammar checked; otherwise, returns false.
</dd>
	<dd>
設定して、
既定の挙動を上書きしつつ，
`spellcheck$a 内容~属性を設定できる。
◎
Can be set, to override the default and set the spellcheck content attribute.
</dd>
</dl>

<p>
`spellcheck@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<div>
<p>
取得子~手続きは：
</p>
		<ol>
			<li>
<p>
コレの `spellcheck$a 内容~属性の状態に応じて：
</p>
				<ul class="switch">
					<li>
`~T$stS
⇒
~RET ~T
</li>
					<li>
`~F$stS
⇒
~RET ~F
</li>
					<li>
`既定$stS
⇒
何もしない
</li>
				</ul>
			</li>
			<li>
<p>
コレの`既定の挙動$に応じて：
</p>
				<ul class="switch">
					<li>
`既定では~T$i
⇒
~RET ~T
</li>
					<li>
`既定では~F$i
⇒
~RET ~F
</li>
					<li>
<p>
`既定では継承する$i：
</p>
						<ol>
							<li>
%親 ~LET コレの`親~要素$
</li>
							<li>
~IF［
%親 ~NEQ ~NULL
］
⇒
~RET %親 上の `spellcheck$m 取得子~手続き()
</li>
							<li>
~RET ~F
</li>
						</ol>
					</li>
				</ul>
			</li>
		</ol>
◎
The spellcheck IDL attribute, on getting, must return true＼
if the element's spellcheck content attribute is in the True state,＼
or if the element's spellcheck content attribute is in the Default state and the element's default behavior is true-by-default,＼
or if the element's spellcheck content attribute is in the Default state and the element's default behavior is inherit-by-default and the element's parent element's spellcheck IDL attribute would return true;＼
otherwise, if none of those conditions applies, then the attribute must instead return false.
</div>

<p class="note">注記：
`spellcheck$m ~IDL属性は、［
利用者による， `spellcheck$a 内容~属性を上書きする選好
］からは影響されないため、
実際の綴りや文法に対する検査ng状態を反映しないこともある。
◎
The spellcheck IDL attribute is not affected by user preferences that override the spellcheck content attribute, and therefore might not reflect the actual spellchecking state.
</p>
	</li>
	<li class="algo">
設定子~手続きは
⇒
コレの `spellcheck$a 内容~属性の値 ~SET 所与の値に応じて
⇒＃
~T ならば `true^l ／
~F ならば `false^l
◎
On setting, if the new value is true, then the element's spellcheck content attribute must be set to "true", otherwise it must be set to "false".
</li>
</ul>

<hr>

<p>
この特能の目的においては：
◎
User agents should only consider the following pieces of text as checkable for the purposes of this feature:
</p>
<ul>
	<li>
<p>
検査-可能な~textは、
次に挙げる~text片に限るベキである：
◎
↑</p>
		<ul>
			<li>
<p>
［
~AND↓ を満たす `input$e 要素
］の`値$fe：
</p>
				<ul>
					<li>
`type$a 属性の状態 ~IN { `Text$st, `Search$st, `Url$st, `Email$st }
</li>
					<li>
`変異-可能$fe
（すなわち、
`readonly$a 属性を有さない, かつ`不能化されて$feいない）
</li>
				</ul>
◎
The value of input elements whose type attributes are in the Text, Search, URL, or Email states and that are mutable (i.e. that do not have the readonly attribute specified and that are not disabled).
</li>
			<li>
<p>
［
~AND↓ を満たす `textarea$e 要素
］の`値$fe：
</p>
				<ul>
					<li>
`~readonly0$a 属性を有さない
</li>
					<li>
`不能化されて$feいない
</li>
				</ul>

◎
The value of textarea elements that do not have a readonly attribute and that are not disabled.
</li>
			<li>
［
`編集中の~host$ ／ `編集-可能$な要素
］の子である `Text$I ~node内の~text。
◎
Text in Text nodes that are children of editing hosts or editable elements.
</li>
			<li>
`編集-可能$な要素の属性~内の~text。
◎
Text in attributes of editable elements.
</li>
		</ul>
	</li>
	<li>
<p>
所与の~textが属するとされる要素は、
当の~textが：
</p>
		<ul class="switch">
			<li>
`Text$I ~nodeたちの一部を成す場合
⇒
それらのうち`~tree順序$で最初のもの
（当の［
単語／一文／その他の~text片
］を成す最初の文字を含むもの）
の`親~要素$
</li>
			<li>
ある内容~属性の一部を成す場合
⇒
当の属性を有している要素
</li>
			<li>
［
`input$e ／ `textarea$e
］要素の値の一部を成す場合
⇒
当の要素
</li>
		</ul>
◎
For text that is part of a Text node, the element with which the text is associated is the element that is the immediate parent of the first character of the word, sentence, or other piece of text. For text in attributes, it is the attribute's element. For the values of input and textarea elements, it is the element itself.
</li>
</ul>

<div class="algo">
<p>
綴りや文法の検査ngが適用-可能な要素 %要素 に属する~textに対する検査ngは、
次の~algoの結果が［
`可能化される^i ならば可能化される ／
`不能化される^i ならば不能化される
］モノトスル：
◎
To determine if a word, sentence, or other piece of text in an applicable element (as defined above) is to have spelling- and grammar-checking enabled, the UA must use the following algorithm:
</p>
<ol>
	<li>
~IF［
利用者は、
この~textに対する検査ngを不能化している
］
⇒
~RET `不能化される^i
◎
If the user has disabled the checking for this text, then the checking is disabled.
</li>
	<li>
~IF［
利用者は、
この~textの検査ngを常に可能化するように強制している
］
⇒
~RET `可能化される^i
◎
Otherwise, if the user has forced the checking for this text to always be enabled, then the checking is enabled.
</li>
	<li>
%要素~list ~SET［
%要素 , および その先祖~要素
］からなる，%要素 に近い順の~list
◎
↓</li>
	<li>
<p>
%要素~list を成す
~EACH( %E )
に対し：
</p>
		<ol>
			<li>
%状態 ~LET %E の `spellcheck$a 内容~属性の状態
</li>
			<li>
~IF［
%状態 ~EQ `既定$stS
］
⇒
~CONTINUE
</li>
			<li>
~RET %状態 に応じて
⇒＃
`~T$stS ならば `可能化される^i ／
`~F$stS ならば `不能化される^i
</li>
		</ol>
◎
Otherwise, if the element with which the text is associated has a spellcheck content attribute, then: if that attribute is in the True state, then checking is enabled; otherwise, if that attribute is in the False state, then checking is disabled.
◎
Otherwise, if there is an ancestor element with a spellcheck content attribute that is not in the Default state, then: if the nearest such ancestor's spellcheck content attribute is in the True state, then checking is enabled; otherwise, checking is disabled.
</li>
	<li>
<p>
%要素~list を成す
~EACH( %E )
に対し：
</p>
		<ol>
			<li>
%挙動 ~LET %E の`既定の挙動$
</li>
			<li>
~IF［
%挙動 ~EQ `既定では継承する$i
］
⇒
~CONTINUE†
</li>
			<li>
~RET %挙動 に応じて
⇒＃
`既定では~T$i ならば `可能化される^i ／
`既定では~F$i ならば `不能化される^i
</li>
		</ol>

<p class="trans-note">【†
原文では，この~algoを %E の親に対し再帰的に呼出しているが、
前~段にて， %E のどの先祖の `spellcheck$a 内容~属性の状態も `既定$stS であることはすでに判っているので、
この段で反復することで十分になる。
】</p>

◎
Otherwise, if the element's default behavior is true-by-default, then checking is enabled.
◎
Otherwise, if the element's default behavior is false-by-default, then checking is disabled.
◎
Otherwise, if the element's parent element has its checking enabled, then checking is enabled.
</li>
	<li>
~RET `不能化される^i
◎
Otherwise, checking is disabled.
</li>
</ol>
</div>

<p>
単語や一文などの~textに対する検査ngが可能化されている場合、
~UAは，［
当の~text内に綴りや文法の誤りがある場合
］は それを指示するベキである。
~UAは、
綴りや文法の訂正を示唆するときには，［
文書~内に与えられた他の意味論
］も織り込むベキである
— これには、
次に挙げるものが含まれる：
◎
If the checking is enabled for a word/sentence/text, the user agent should indicate spelling and grammar errors in that text. User agents should take into account the other semantics given in the document when suggesting spelling and grammar corrections.＼
</p>
<ul>
	<li>
綴りや文法に利用する規則を［
要素に指定された自然言語
］や［
利用者が選好した自然言語~設定群
］から決定してもヨイ。
◎
User agents may use the language of the element to determine what spelling and grammar rules to use, or may use the user's preferred language settings.＼
</li>
	<li>
アリな所では、
`input$e 要素~用の一部の属性
— `pattern$a など —
を利用して，結果の値が妥当になることを確保するベキである。
◎
UAs should use input element attributes such as pattern to ensure that the resulting value is valid, where possible.
</li>
</ul>

<p>
検査ngが不能化されている場合、
~UAは，［
当の~textに対する綴りや文法の誤り
］を指示するベキでない。
◎
If checking is disabled, the user agent should not indicate spelling or grammar errors for that text.
</p>

<div class="example">
<p>
次の例の単語 `Hello^l に対しては、
その綴りを検査するかどうかを決定するときに，~ID `a^l を伴う要素が利用され、
その結果，検査されない。
◎
The element with ID "a" in the following example would be the one used to determine if the word "Hello" is checked for spelling errors. In this example, it would not be.
</p>

`spelling-1^xCode

<p>
次の例における~ID `b^l を伴う要素に対しては、
検査ngは可能化される
（ `input$e 要素の `spellcheck^a 属性~値における先頭の~ASCII空白は，当の属性を無視させるので、
既定の挙動にかかわらず，先祖の値が代わりに利用される）。
◎
The element with ID "b" in the following example would have checking enabled (the leading space character in the attribute's value on the input element causes the attribute to be ignored, so the ancestor's value is used instead, regardless of the default).
</p>

`spelling-2^xCode
</div>

<p class="note">注記：
この仕様は、［
綴りや文法
］検査器~用の~UIを定義しない。
~UAは、［
その場で検査ngを提供する／
検査ngが可能化されている間，継続的に検査ngを遂行する／
その他の~UIを利用する
］こともできる。
◎
This specification does not define the user interface for spelling and grammar checkers. A user agent could offer on-demand checking, could perform continuous checking while the checking is enabled, or could use other interfaces.
</p>

			</section>
			<section id="writing-suggestions">
<h4 title="Writing suggestions">6.8.6 書法~示唆</h4>

<p>
~UAは、
利用者が［
~form~control（例： `textarea$e 要素）／
`編集中の~host$内の要素
］内の編集-可能な領域の中へ打込むに伴い，書法~示唆を提供する。
◎
User agents offer writing suggestions as users type into editable regions, either in form controls (e.g., the textarea element) or in elements in an editing host.
</p>

<p>
`writingsuggestions@a
内容~属性は、
`列挙d属性$であり，
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The writingsuggestions content attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態
<th>概略的な記述
</thead><tbody>

<tr><td>`true@vW
<td>`~T@stW
<td>この要素に対しては、
書法~示唆を提供するベキである。

<tr><td>`false@vW
<td>`~F@stW
<td>この要素に対しては、
書法~示唆を提供するベキでない。

<tr><td>
<td>`既定@stW
<td>
以下に定義されるとおり，既定の挙動に則って動作する
— 場合によっては、
親~要素の `writingsuggestions$a の状態に基づいて。
</table>

<p>
`writingsuggestions$a 属性の
⇒＃
`欠落~値~用の既定の状態$は `既定$stW とする。
`妥当でない値~用の既定の状態$は `~T$stW とする。
`空~文字列~用の既定の状態$は `~T$st とする。
</p>
◎
Keyword｜State｜Brief description
true｜True｜Writing suggestions should be offered on this element.
false｜False｜Writing suggestions should not be offered on this element.
◎
The attribute's missing value default is the Default state. The default state indicates that the element is to act according to a default behavior, possibly based on the parent element's own writingsuggestions state, as defined below.
◎
The attribute's invalid value default and empty value default are both the True state.
</div>

<dl class="domintro">
	<dt>%element.`writingSuggestions$m [ = %value ]</dt>
	<dd>
~UAは、
%element の視野の下で書法~示唆を［
提供するならば `true^l ／
提供しないならば `false^l
］を返す。
◎
Returns "true" if the user agent is to offer writing suggestions under the scope of the element; otherwise, returns "false".
</dd>
	<dd>
設定して，
既定を上書きできる
— それに伴い，
%element の `writingsuggestions$a 内容~属性も設定される。
◎
Can be set, to override the default and set the writingsuggestions content attribute.
</dd>
</dl>

<div class="algo">
<p>
`書法~示唆~値を算出する@
~algoは、
所与の
( %要素 )
に対し：
◎
The computed writing suggestions value of a given element is determined by running the following steps:
</p>
<ol>
	<li>
<p>
%要素 の `writingsuggestions$a 内容~属性の状態に応じて：
</p>
		<ul class="switch">
			<li>
`~F$stW
⇒
~RET `false^l
</li>
			<li>
`~T$stW
⇒
~RET `true^l
</li>
			<li>
<p>
`既定$stW
</p>
				<ol>
					<li>
%親 ~LET %要素 の`親~要素$
</li>
					<li>
~IF［
%親 ~EQ ~NULL
］
⇒
~RET `true^l
</li>
					<li>
~RET `書法~示唆~値を算出する$( %親 )
</li>
				</ol>
			</li>
		</ul>

◎
If element's writingsuggestions content attribute is in the False state, return "false".
◎
If element's writingsuggestions content attribute is in the Default state, element has a parent element, and the computed writing suggestions value of element's parent element is "false", then return "false".
◎
Return "true".
</li>
</ol>
</div>

<div class="algo">
<p>
`writingSuggestions@m
取得子~手続きは
⇒
~RET `書法~示唆~値を算出する$( コレ )
◎
The writingSuggestions getter steps are:
• Return this's computed writing suggestions value.
</p>

<p class="note">注記：
`writingSuggestions$m ~IDL属性は、［
`writingsuggestions$a 内容~属性を上書きする利用者~選好
］により影響されないので，
書法~示唆の実際の状態を反映しないかもしれない。
◎
The writingSuggestions IDL attribute is not affected by user preferences that override the writingsuggestions content attribute, and therefore might not reflect the actual writing suggestions state.
</p>
</div>

<hr>

<div class="algo">
<p>
~UAは、［
次の~algoが ~T を返す場合
］に限り，
要素の視野の中に示唆を提供するベキである
— ~algoは、
所与の
( %要素 )
に対し：
◎
User agents should only offer suggestions within an element's scope if the result of running the following algorithm given element returns true:
</p>
<ol>
	<li>
~IF［
利用者は書法~示唆を不能化した
］
⇒
~RET ~F
◎
If the user has disabled writing suggestions, then return false.
</li>
	<li>
<p>
~IF［
%要素 は ~OR↓ を満たさない
］…
◎
If none of the following conditions are true:
</p>
		<ul>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
`input$e 要素である
</li>
					<li>
その `type$a 属性の状態 ~IN { `Text$st, `Text$st, `Tel$st, `Url$st, `Email$st }
</li>
					<li>
`変異-可能$feである
</li>
				</ul>
◎
element is an input element whose type attribute is in either the Text, Search, Telephone, URL, or Email state and is mutable;
</li>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
`textarea$e 要素である
</li>
					<li>
`変異-可能$feである
</li>
				</ul>
◎
element is a textarea element that is mutable; or
</li>
			<li>
`編集中の~host$である
◎
element is an editing host＼
</li>
			<li>
`編集-可能$である
◎
or is editable,
</li>
		</ul>
<p>
…ならば
⇒
~RET ~F
◎
then return false.
</p>
	</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
<p>
%要素 の `writingsuggestions$a 内容~属性の状態に応じて：
</p>
				<ul class="switch">
					<li>
`~T$stW
⇒
~RET ~T
</li>
					<li>
`~F$stW
⇒
~RET ~F
</li>
					<li>
`既定$stW
⇒
%要素 ~SET %要素 の`親~要素$
</li>
				</ul>
			</li>
			<li>
~IF［
%要素 ~EQ ~NULL
］
⇒
~RET ~T
</li>
		</ol>
◎
If element has an inclusive ancestor with a writingsuggestions content attribute that's not in the Default and the nearest such ancestor's writingsuggestions content attribute is in the False state, then return false.
◎
Otherwise, return true.
</li>
</ol>
</div>

<p class="note">注記：
この仕様は、
書法~示唆~用の~UIを定義しない。
~UAは、
次に挙げるもの，その他の~UIを利用して示唆を提供することもできる
⇒＃
利用者が打込むに伴う［その場の／継続的な］示唆／
~inlineな示唆／
~popup内に，`~autofill＠~HTMLautofill#autofill$の様な示唆
◎
This specification does not define the user interface for writing suggestions. A user agent could offer on-demand suggestions, continuous suggestions as the user types, inline suggestions, autofill-like suggestions in a popup, or could use other interfaces.
</p>

			</section>
			<section id="autocapitalization">
<h4 title="Autocapitalization">6.8.7. 自動頭字化： `autocapitalize^a 属性</h4>

<p>
~textを手入力する~methodには、
例えば，携帯~機器~上の~virtual-keyboardや~voice入力などもあり，
各~一文の最初の字l（ `letter^en ）
【約物等を除く，“普通の” 文字】
を自動的に頭字化（ `capitalize^en ）して，利用者を支援することが多い
（当の自然言語に この規約がある下で，~textを組成しているならば）。
自動頭字化を実装する~virtual-keyboardは、
自動頭字化されるべき字lが打込まれつつあるとき，
自動的に字lを大文字で示すよう切替えるかもしれない
（利用者が小文字に戻せるようにしつつ）。
他の型の入力，例えば~voice入力では、
最初に介入する~~余地を利用者に与えない仕方で，
自動頭字化を遂行することもある。
`autocapitalize$a 属性は、
そのような挙動を制御することを作者に許容する。
◎
Some methods of entering text, for example virtual keyboards on mobile devices, and also voice input, often assist users by automatically capitalizing the first letter of sentences (when composing text in a language with this convention). A virtual keyboard that implements autocapitalization might automatically switch to showing uppercase letters (but allow the user to toggle it back to lowercase) when a letter that should be autocapitalized is about to be typed. Other types of input, for example voice input, may perform autocapitalization in a way that does not give users an option to intervene first. The autocapitalize attribute allows authors to control such behavior.
</p>

<p>
`autocapitalize$a 属性は、
概して，［
物理的~keyboardを打込むときの挙動には影響しない
］ように実装される。
（この理由から, および［
一部の事例で自動頭字化の挙動を上書きできる／初期~入力の後に~textを編集する
］能を利用者に与えるため、
いかなる類の入力~検証も，この属性には依拠しないモノトスル。）
◎
The autocapitalize attribute, as typically implemented, does not affect behavior when typing on a physical keyboard. (For this reason, as well as the ability for users to override the autocapitalization behavior in some cases or edit the text after initial input, the attribute must not be relied on for any sort of input validation.)
</p>

<div>
<p>
`autocapitalize$a 属性は、
次の表tを成す 1 列目に挙げる要素に利用することで，
同じ行の 2 列目における自動頭字化の挙動を制御できる：
</p>

<table><thead><tr>
<th>要素
<th>対象
<tbody>

<tr><td>`編集中の~host$
<td>当の要素に~hostされる編集-可能な領域

<tr><td>`input$e ／ `textarea$e
<td>当の要素の中へ~textを挿入するとき

<tr><td>`form$e
<td>当の要素に所有される要素のうち`自動頭字化-と自動訂正-を継承-$するもの すべて用の既定
</table>
◎
The autocapitalize attribute can be used on an editing host to control autocapitalization behavior for the hosted editable region, on an input or textarea element to control the behavior for inputting text into that element, or on a form element to control the default behavior for all autocapitalize-and-autocorrect inheriting elements associated with the form element.
</div>

<p>
`autocapitalize$a 属性は、
`input$e 要素のうち［
その `type$a 属性の状態 ~IN { `Url$st, `Email$st, `Password$st }
］を満たすものに対しては，自動頭字化を可能化させることは決してない
（この挙動は、
`利用する自動頭字化~hintを算出する$~algo内に含まれる）。
◎
The autocapitalize attribute never causes autocapitalization to be enabled for input elements whose type attribute is in one of the URL, Email, or Password states. (This behavior is included in the used autocapitalization hint algorithm below.)
</p>

<p>
自動頭字化の処理~modelは、
次に定義される 5 種の
`自動頭字化~hint@
から選定することに基づく：
◎
The autocapitalization processing model is based on selecting among five autocapitalization hints, defined as follows:
</p>

<ul>
	<li>
`既定@aH
⇒
［
~UA／入力~method
］は、
自動頭字化を可能化するか否か，自前の決定を為すベキである。
◎
Default
• The user agent and input method should make their own determination of whether or not to enable autocapitalization.
</li>
	<li>
`なし@aH
⇒
自動頭字化は適用されるベキでない
（すべての字lは、
既定では小文字になるベキである）。
◎
None
• No autocapitalization should be applied (all letters should default to lowercase).
</li>
	<li>
`一文ごと@aH
⇒
各~一文の最初の字lは、
既定では頭字になるベキである。
他のすべての字lは、
既定では小文字になるベキである。
◎
Sentences
• The first letter of each sentence should default to a capital letter; all other letters should default to lowercase.
</li>
	<li>
`単語ごと@aH
⇒
各~単語の最初の字lは、
既定では頭字になるベキである。
他のすべての字lは、
既定では小文字になるベキである
◎
Words
• The first letter of each word should default to a capital letter; all other letters should default to lowercase.
</li>
	<li>
`文字ごと@aH
⇒
すべての字lは、
既定では大文字になるベキである。
◎
Characters
• All letters should default to uppercase.
</li>
</ul>

<p>
`autocapitalize@a
属性は、
`自動頭字化~hint$を与える。
この~hintは、［
`利用する自動頭字化~hintを算出する$ための他の考慮点
］と組合されて，~UAの挙動を伝える。
この属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The autocapitalize attribute is an enumerated attribute whose states are the possible autocapitalization hints. The autocapitalization hint specified by the attribute's state combines with other considerations to form the used autocapitalization hint, which informs the behavior of the user agent. The keywords for this attribute and their state mappings are as follows:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態
<tbody>

<tr><td>`off@vC
<td>`なし$aH

<tr><td>`none@vC
<td>`なし$aH

<tr><td>`on@vC
<td>`一文ごと$aH
<tr><td>`sentences@vC
<td>`一文ごと$aH

<tr><td>`words@vC
<td>`単語ごと$aH

<tr><td>`characters@vC
<td>`文字ごと$aH

<tr><td>（なし）
<td>`既定$aH
</table>
◎
Keyword｜State
off｜None
none｜
on｜Sentences
sentences｜
words｜Words
characters｜Characters
</div>

<p>
`autocapitalize$a 属性の
⇒＃
`欠落~値~用の既定の状態$は `既定$aH とする。
`妥当でない値~用の既定の状態$は `一文ごと$aH とする。
◎
The attribute's missing value default is the Default state, and its invalid value default is the Sentences state.
</p>

<dl class="domintro">
	<dt>%element.`autocapitalize$m [ = %value ]</dt>
	<dd>
%element の現在の自動頭字化~状態【を述べる~keyword】
— あるいは、
設定されていない場合は空~文字列 —
を返す。
これは、
%element が［
`自動頭字化-と自動訂正-を継承-$する【！input and textarea】要素であって，ある `form$e 要素から状態を継承する場合
］には［
当の `form$e 要素の自動頭字化~状態
］を返すことになるが，
%element が［
編集-可能な領域~内にある要素である（かつ 自身は`編集中の~host$でない）場合
］には［
当の`編集中の~host$の自動頭字化~状態
］を返さないことに注意。
◎
Returns the current autocapitalization state for the element, or an empty string if it hasn't been set. Note that for input and textarea elements that inherit their state from a form element, this will return the autocapitalization state of the form element, but for an element in an editable region, this will not return the autocapitalization state of the editing host (unless this element is, in fact, the editing host).
</dd>
	<dd>
設定して， `autocapitalize$a 内容~属性を設定できる
（それにより，要素~用の自動頭字化の挙動を変更する）。
◎
Can be set, to set the autocapitalize content attribute (and thereby change the autocapitalization behavior for the element).
</dd>
</dl>

<div class="algo">
<p>
`自前の自動頭字化~hintを算出する@
~algoは、
所与の ( 要素 %要素 )
に対し：
◎
To compute the own autocapitalization hint of an element element, run the following steps:
</p>
<ol>
	<li>
~IF［
%要素 は `autocapitalize$a 内容~属性を有していて，その値 ~NEQ 空~文字列
］
⇒
~RET その属性の状態
◎
If the autocapitalize content attribute is present on element, and its value is not the empty string, return the state of the attribute.
</li>
	<li>
<p>
~IF［
%要素 は`自動頭字化-と自動訂正-を継承-$する
］：
</p>
		<ol>
			<li>
%所有者 ~LET %要素 の`~form所有者$
</li>
			<li>
~IF［
%所有者 ~NEQ ~NULL
］
⇒
~RET `自前の自動頭字化~hintを算出する$( %所有者 )
</li>
		</ol>
◎
If element is an autocapitalize-and-autocorrect inheriting element and has a non-null form owner, return the own autocapitalization hint of element's form owner.
</li>
	<li>
~RET `既定$aH
◎
Return Default.
</li>
</ol>
</div>

<div class="algo">
<p>
`autocapitalize@m
取得子~手続きは：
</p>
<ol>
	<li>
%状態 ~LET `自前の自動頭字化~hintを算出する$( コレ )
</li>
	<li>
~RET %状態 に応じて
⇒＃
`既定$aH ならば 空~文字列 ／
`なし$aH ならば "`none$vC" ／
`一文ごと$aH ならば "`sentences$vC" ／
`単語ごと$aH ならば "`words$vC" ／
`文字ごと$aH ならば "`characters$vC"
</li>
</ol>
◎
The autocapitalize getter steps are to:
• Let state be the own autocapitalization hint of this.
• If state is Default, then return the empty string.
• If state is None, then return "none".
• If state is Sentences, then return "sentences".
• Return the keyword value corresponding to state.
</div>

<hr>

<p>
~UAは，［
~text入力~method用に自動頭字化の挙動を~custom化する機能性
］を~supportしていて［
それを制御することを~web開発者に許容する
］よう望むならば、
要素の中へ~textを入力する間，要素~用に`利用する自動頭字化~hintを算出する$ベキである。
その結果は、［
要素の中への~text入力~用に推奨される，自動頭字化の挙動
］を述べる`自動頭字化~hint$になる。
◎
User agents that support customizable autocapitalization behavior for a text input method and wish to allow web developers to control this functionality should, during text input into an element, compute the used autocapitalization hint for the element. This will be an autocapitalization hint that describes the recommended autocapitalization behavior for text input into the element.
</p>

<p>
ある種の状況下においては、［
~UA／入力~method
］は，`利用する自動頭字化~hintを算出する$~algoを［
無視する／上書きする
］（順不同）ことを選んでもヨイ。
◎
User agents or input methods may choose to ignore or override the used autocapitalization hint in certain circumstances.
</p>

<div class="algo">
<p>
`利用する自動頭字化~hintを算出する@
~algoは、
所与の ( 要素 %要素 )
に対し：
◎
The used autocapitalization hint for an element element is computed using the following algorithm:
</p>
<ol>
	<li>
~IF［
%要素 は `input$e 要素である
］~AND［
%要素 の `type$a 属性の状態 ~IN { `Url$st, `Email$st, `Password$st }
］
⇒
~RET `既定$aH
◎
If element is an input element whose type attribute is in one of the URL, Email, or Password states, then return Default.
</li>
	<li>
~IF［
%要素 は［
`input$e ／ `textarea$e
］要素である
］
⇒
~RET `自前の自動頭字化~hintを算出する$( %要素 )
◎
If element is an input element or a textarea element, then return element's own autocapitalization hint.
</li>
	<li>
~IF［
%要素 は［
`編集中の~host$ ／ `編集-可能$な要素
］である
］
⇒
~RET `自前の自動頭字化~hintを算出する$( %要素 が`属する編集中の~host$ )
◎
If element is an editing host or an editable element, then return the own autocapitalization hint of the editing host of element.
</li>
	<li>
~Assert：
この段に到達することは決してない
— ~text入力が生じる要素は，上の判定基準のうちいずれかを満たすものに限られるので。
◎
Assert: this step is never reached, since text input only occurs in elements that meet one of the above criteria.
</li>
</ol>
</div>

			</section>
			<section id="autocorrection">
<h4 title="Autocorrection">6.8.8. 自動訂正： `autocorrect^a 属性</h4>

<p>
~textを手入力するための~methodには、［
利用者が打込んでいる間に誤綴な単語を自動的に正す
］ことにより支援するものもある
— この処理nは、
自動訂正（ `autocorrection^en ）としても知られる。
~UAは、［
~form~control（ `textarea$e 要素の値など）／
`編集中の~host$内の要素（例： `contenteditable$a を利用している）
］において，編集-可能な~textの自動訂正を~supportし得る。
自動訂正には、
~textが自動訂正-［
されつつある／された
］ことを指示する~UIが付随してもヨイ。
自動訂正は、
誤綴な単語の後に［
約物／~space／新たな段落
］を挿入するときに共通的に遂行される。
`autocorrect$a 属性は、
そのような挙動を制御することを作者に許容する。
◎
Some methods of entering text assist users by automatically correcting misspelled words while typing, a process also known as autocorrection. User agents can support autocorrection of editable text, either in form controls (such as the value of textarea elements), or in elements in an editing host (e.g., using contenteditable). Autocorrection may be accompanied by user interfaces indicating that text is about to be autocorrected or has been autocorrected, and is commonly performed when inserting punctuation characters, spaces, or new paragraphs after misspelled words. The autocorrect attribute allows authors to control such behavior.
</p>

<div>
<p>
`autocorrect$a 属性は、
次の表tを成す 1 列目に挙げる要素に利用することで，
同じ行の 2 列目における自動訂正の挙動を制御できる：
</p>
<table><thead><tr>
<th>要素
<th>対象
<tbody>

<tr><td>`編集中の~host$
<td>当の要素に~hostされる編集-可能な領域

<tr><td>`input$e ／ `textarea$e
<td>当の要素の中へ~textを挿入するとき

<tr><td>`form$e
<td>当の要素に所有される要素のうち`自動頭字化-と自動訂正-を継承-$するもの すべて用の既定

</table>
◎
The autocorrect attribute can be used on an editing host to control autocorrection behavior for the hosted editable region, on an input or textarea element to control the behavior when inserting text into that element, or on a form element to control the default behavior for all autocapitalize-and-autocorrect inheriting elements associated with the form element.
</div>

<p>
`autocorrect$a 属性は、
`input$e 要素のうち［
その `type$a 属性の状態 ~IN { `Url$st, `Email$st, `Password$st }
］を満たすものに対しては，自動訂正を可能化させることは決してない
（この挙動は、
`利用する自動訂正~状態を算出する$~algo内に含まれる）。
◎
The autocorrect attribute never causes autocorrection to be enabled for input elements whose type attribute is in one of the URL, Email, or Password states. (This behavior is included in the used autocorrection state algorithm below.)
</p>

<p>
`autocorrect@a
属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The autocorrect attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead><tr><th>~keyword
<th>状態
<th>概略的な記述
<tbody>

<tr><td>`on@v
<td>`~on@st
<td>
~UAには［
利用者が打込んでいる間に綴りの誤りを自動的に正す
］ことが許可される。
自動的に正すかどうかは、
~UAの裁定に委ねられ【！left is for】，
当の要素に加えて利用者の選好にも依存する。

<tr><td>`off@v
<td>`~off@st
<td>
~UAには［
利用者が打込んでいる間に綴りの誤りを自動的に正す
］ことは許容されない。
</table>
◎
Keyword｜State｜Brief description
on｜On｜The user agent is permitted to automatically correct spelling errors while the user types. Whether spelling is automatically corrected while typing left is for the user agent to decide, and may depend on the element as well as the user's preferences.
off｜Off｜The user agent is not allowed to automatically correct spelling while the user types.
</div>

<p>
`autocorrect$a 属性の
⇒＃
`欠落~値~用の既定の状態$は `~on$st とする。
`妥当でない値~用の既定の状態$は `~on$st とする。
`空~文字列~用の既定の状態$は `~on$st とする。
◎
The attribute's invalid value default, missing value default, and empty value default are all the On state.
</p>

<p>
`autocorrect@m
用の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
</p>
		<ol>
			<li>
%状態 ~LET `利用する自動訂正~状態を算出する$( コレ )
</li>
			<li>
~RET %状態 に応じて
⇒＃
`~on$st ならば ~T ／
`~off$st ならば ~F
</li>
		</ol>
◎
The autocorrect getter steps are:＼
return true if the element's used autocorrection state is On and false if the element's used autocorrection state is Off.＼
</li>
	<li class="algo">
設定子~手続きは
⇒
コレの `autocorrect$a 属性 ~SET 所与の値に応じて
⇒＃
~T ならば `on^l ／
~F ならば `off^l
◎
The setter steps are:＼
if the given value is true, then the element's autocorrect attribute must be set to "on";＼
otherwise it must be set to "off".
</li>
</ul>

<div class="algo">
<p>
`利用する自動訂正~状態を算出する@
~algoは、
所与の
( 要素 %要素 )
に対し：
◎
To compute the used autocorrection state of an element element, run these steps:
</p>
<ol>
	<li>
~IF［
%要素 は `input$e 要素である
］~AND［
%要素 の `type$a 属性の状態 ~IN { `Url$st, `Email$st, `Password$st }
］
⇒
~RET `~off$st
◎
If element is an input element whose type attribute is in one of the URL, Email, or Password states, then return Off.
</li>
	<li>
~IF［
%要素 は `autocorrect$a 内容~属性を有する
］
⇒
~RET %要素 の `autocorrect^a 属性の状態
◎
If the autocorrect content attribute is present on element, then return the state of the attribute.
</li>
	<li>
<p>
~IF［
%要素 は`自動頭字化-と自動訂正-を継承-$する
］：
</p>
		<ol>
			<li>
%所有者 ~LET %要素 の`~form所有者$
</li>
			<li>
~IF［
%所有者 ~NEQ ~NULL
］
⇒
~RET %所有者 の `autocorrect$a 属性の状態
</li>
		</ol>
◎
If element is an autocapitalize-and-autocorrect inheriting element＼
and has a non-null form owner,＼
then return the state of element's form owner's autocorrect attribute.
</li>
	<li>
~RET `~on$st
◎
Return On.
</li>
</ol>
</div>


<dl class="domintro">
	<dt>%element . `autocorrect$m</dt>
	<dd>
%element の自動訂正の挙動を返す。
これは、
%element が［
`自動頭字化-と自動訂正-を継承-$する要素であって，ある `form$e 要素から状態を継承する場合
］には［
当の `form$e 要素の自動訂正の挙動
］を返すことになるが，
%element が［
編集-可能な領域~内にある要素である（かつ自身は`編集中の~host$でない）場合
］には［
当の`編集中の~host$の自動訂正の挙動
］を返さないことに注意。
◎
Returns the autocorrection behavior of the element. Note that for autocapitalize-and-autocorrect inheriting elements that inherit their state from a form element, this will return the autocorrection behavior of the form element, but for an element in an editable region, this will not return the autocorrection behavior of the editing host (unless this element is, in fact, the editing host).
</dd>

	<dt>%element . `autocorrect$m =  %value</dt>
	<dd>
%element の `autocorrect$a 内容~属性を更新する
（それにより， %element の自動訂正の挙動を変更する）。
◎
Updates the autocorrect content attribute (and thereby changes the autocorrection behavior of the element).
</dd>
</dl>

<div class="example">
<p>
次の例における `input$e 要素は、
自動訂正を許容しないことになる
— それは `autocorrect$a 内容~属性を有さないので，
【自動訂正の挙動】を `form$e 要素から継承することになるが、
`form$e 要素の `autocorrect$a 内容~属性は，値 `off$v をとるので。
しかしながら，
`textarea$e 要素は，自動訂正を許容することになる
— それは `autocorrect$a 内容~属性を有していて，その値は `on$v をとるので。
◎
The input element in the following example would not allow autocorrection, since it does not have an autocorrect content attribute and therefore inherits from the form element, which has an attribute of "off". However, the textarea element would allow autocorrection, since it has an autocorrect content attribute with a value of "on".
</p>

`autocorrect-1^xCode
</div>

			</section>
			<section id="input-modalities:-the-inputmode-attribute">
<h4 title="Input modalities: the inputmode attribute">6.8.9. 入力~modal性： `inputmode^a 属性</h4>

<p>
~UAは、
次に挙げるものに対し，
`inputmode$a 属性を~supportできる
⇒＃
~form~control（`textarea$e 要素の値など） ／
`編集中の~host$内の要素（例： `contenteditable$a を利用しているものなど）
◎
User agents can support the inputmode attribute on form controls (such as the value of textarea elements), or in elements in an editing host (e.g., using contenteditable).
</p>

<p>
`inputmode@a
内容~属性は、［
内容を手入力している利用者にとって，どの種類の入力の仕組みが最も助けになるか
］を指定する。
この属性は，`列挙d属性$であり、
次に挙げる~keywordが定義される。
~UAは、
~keywordに応じて，
次の表tに述べる~virtual-keyboardを表示するベキである：
◎
The inputmode content attribute is an enumerated attribute that specifies what kind of input mechanism would be most helpful for users entering content.
◎
↓</p>

<table><thead>
<tr><th>~keyword
<th>記述
<tbody>

<tr><td>`none@v
<td>
~virtual-keyboardを表示するベキでない。
この~keywordは、
内容が自前の~keyboard~controlを具現化する場合に，有用になる。
◎
The user agent should not display a virtual keyboard. This keyword is useful for content that renders its own keyboard control.

<tr><td>`text@v
<td>
利用者の~localeにおける~textを入力できるもの。
◎
The user agent should display a virtual keyboard capable of text input in the user's locale.

<tr><td>`tel@v
<td>
電話番号を入力できるもの。
これは、［
数字 0 〜 9, 文字 "#", "*"
］用の~UIkeyを含むベキである。
~localeによっては、
これには~alphabetic-mnemonicも含まれる
（例：米国では、
歴史的に，~label "2" を伴う~UIkeyは ~label "A", "B", "C" も伴う）。
◎
The user agent should display a virtual keyboard capable of telephone number input. This should including keys for the digits 0 to 9, the "#" character, and the "*" character. In some locales, this can also include alphabetic mnemonic labels (e.g., in the US, the key labeled "2" is historically also labeled with the letters A, B, and C).

<tr><td>`url@v
<td>
利用者の~localeにおける~textを入力できる, かつ
`~URL$の入力を援助する~UIkeyも伴うもの
— ~domain名に共通的に見出される文字列
（  "/", ".", "www.", ".com" など）
を手早く入力するための。
◎
The user agent should display a virtual keyboard capable of text input in the user's locale, with keys for aiding in the input of URLs, such as that for the "/" and "." characters and for quick input of strings commonly found in domain names such as "www." or ".com".

<tr><td>`email@v
<td>
利用者の~localeにおける~textを入力できる, かつ
~email~addressの入力を援助する~UIkeyも伴うもの
— 文字 "@", "." 用の~UIkeyなど。
◎
The user agent should display a virtual keyboard capable of text input in the user's locale, with keys for aiding in the input of email addresses, such as that for the "@" character and the "." character.

<tr><td>`numeric@v
<td>
数を入力できるもの。
この~keywordは、
PIN を手入力するときに有用になる。
◎
The user agent should display a virtual keyboard capable of numeric input. This keyword is useful for PIN entry.

<tr><td>`decimal@v
<td>
小数を含む数を入力できるもの。
利用者の~locale用の数量-~UIkeyと書式~分離子が示されるベキである。
◎
The user agent should display a virtual keyboard capable of fractional numeric input. Numeric keys and the format separator for the locale should be shown.

<tr><td>`search@v
<td>
探索~用に最適化されたもの。
◎
The user agent should display a virtual keyboard optimized for search.
</table>

<p>
`inputMode@m
~IDL属性は、
`既知な値のみに制限される$下で，
`inputmode$a 内容~属性を`反映する$モノトスル。
◎
The inputMode IDL attribute must reflect the inputmode content attribute, limited to only known values.
</p>

<p>
~UAは、
`inputmode$a が未指定なときは
（あるいは，その状態を~supportしないときは），
既定の~virtual-keyboardを決定して利用者に呈示するベキである。
これを決定するときには、
文脈に応じた情報
— `input$e の［
`type$a, `pattern$a
］属性など —
を利用するベキである。
◎
When inputmode is unspecified (or is in a state not supported by the user agent), the user agent should determine the default virtual keyboard to be shown. Contextual information such as the input type or pattern attributes should be used to determine which type of virtual keyboard should be presented to the user.
</p>

			</section>
			<section id="input-modalities:-the-enterkeyhint-attribute">
<h4 title="Input modalities: the enterkeyhint attribute">6.8.10. 入力~modal性： `enterkeyhint^a 属性</h4>

<p>
~UAは、
~form~control（ `textarea$e 要素の値などの）や,
`編集中の~host$内の要素（例： `contenteditable$a を利用しているもの）に対し，
`enterkeyhint$a 属性を~supportできる。
◎
User agents can support the enterkeyhint attribute on form controls (such as the value of textarea elements), or in elements in an editing host (e.g., using contenteditable).
</p>

<p>
`enterkeyhint@a
内容~属性は、
`列挙d属性$であり，［
~virtual-keyboard上の `Enter^Key ~UIkey
］用に［
どの動作~label（または~icon）を呈示するか
］を指定する。
これは、
`Enter^Key ~UIkeyの呈示を［
利用者にもっと助けになるよう~custom化する
］ことを作者に許容する。
◎
The enterkeyhint content attribute is an enumerated attribute that specifies what action label (or icon) to present for the enter key on virtual keyboards. This allows authors to customize the presentation of the enter key in order to make it more helpful for users.
</p>

<table><thead>
<tr><th>~keyword
<th>
~UAは、［
代表的に，この列に述べる操作o
］用の~cueを呈示するベキである。
<tbody>

<tr><td>`enter@v
<td>
改行を挿入する。
◎
The user agent should present a cue for the operation 'enter', typically inserting a new line.

<tr><td>`done@v
<td>
入力するものはそれ以上なく，~IMEは閉じられることになる。
◎
The user agent should present a cue for the operation 'done', typically meaning there is nothing more to input and the input method editor (IME) will be closed.

<tr><td>`go@v
<td>
打込んだ~textの~targetへ利用者を導く。
◎
The user agent should present a cue for the operation 'go', typically meaning to take the user to the target of the text they typed.

<tr><td>`next@v
<td>
次にある［
~textを受容する欄
］へ利用者を導く。
◎
The user agent should present a cue for the operation 'next', typically taking the user to the next field that will accept text.

<tr><td>`previous@v
<td>
前にある［
~textを受容する欄
］へ利用者を導く。
◎
The user agent should present a cue for the operation 'previous', typically taking the user to the previous field that will accept text.

<tr><td>`~search0@v
<td>
打込んだ~textを探索した結果へ利用者を導く。
◎
The user agent should present a cue for the operation 'search', typically taking the user to the results of searching for the text they have typed.

<tr><td>`send@v
<td>
~textをその~targetへ送達する。
◎
The user agent should present a cue for the operation 'send', typically delivering the text to its target.
</table>

<p>
`enterKeyHint@m
~IDL属性は、
`既知な値のみに制限される$下で，
`enterkeyhint$a 内容~属性を`反映する$モノトスル。
◎
The enterKeyHint IDL attribute must reflect the enterkeyhint content attribute, limited to only known values.
</p>

<p>
~UAは、
`enterkeyhint$a が未指定なときは
（あるいは，その状態を~supportしないときは），
~virtual-keyboard上に既定で呈示する動作~label（または~icon）を決定するベキである。
これを決定するときには、
文脈に応じた情報
— ［
`inputmode$a, `type$a, `pattern$a
］属性など —
を利用するベキである。
◎
When enterkeyhint is unspecified (or is in a state not supported by the user agent), the user agent should determine the default action label (or icon) to present. Contextual information such as the inputmode, type, or pattern attributes should be used to determine which action label (or icon) to present on the virtual keyboard.
</p>

			</section>
		</section>
		<section id="find-in-page">
<h3 title="Find-in-page">6.9. ~find-in-page</h3>

			<section id="introduction-10">
<h4 title="Introduction">6.9.1. 序論</h4>

<p>
この節では、
`~find-in-page@
（ `find-in-page^en ）を定義する
— それは、
~UAに共通的な仕組みであり，特定0の情報に関して~pageの内容を探索することを利用者に許容する。
◎
This section defines find-in-page — a common user-agent mechanism which allows users to search through the contents of the page for particular information.
</p>

<p>
`~find-in-page$特能への~accessは、
`~find-in-page~UI@
を介して供される。
これは、
~UAが供する~UIであり，［
探索への入力と~parameter群を指定する
］ことを利用者に許容する。
この~UIは、［
~shortcut／~menu選択
］の結果として現れることもある。
◎
Access to the find-in-page feature is provided via a find-in-page interface. This is a user-agent provided user interface, which allows the user to specify input and the parameters of the search. This interface can appear as a result of a shortcut or a menu selection.
</p>

<p>
`~find-in-page~UI$内の［
~text入力, 設定群
］の組合nは、
利用者の
`~query@fiP
を表現する。
これは，概して、
利用者が探索したいと求める~textに加え，省略可能な各種~設定
（例：一体としての単語に限り†探索するよう制約する能）
も含む。
【† 例えば `strict^l は `restrict^l には合致しないよう。】
◎
A combination of text input and settings in the find-in-page interface represents the user query. This typically includes the text that the user wants to search for, as well as optional settings (e.g., the ability to restrict the search to whole words only).
</p>

<p>
~UAは、
所与の`~query$fiPに対し~page内容を処理して，
0 個以上の合致-からなる
`合致-~list@fiP
を識別する。
各~合致-は、
利用者-`~query$fiPを満足する内容~範囲を与える。
◎
The user-agent processes page contents for a given query, and identifies zero or more matches, which are content ranges that satisfy the user query.
</p>

<p>
`合致-~list$fiPを成す合致-のうち一つが、
強調され, ~viewの中へ~scrollされることにより，利用者から
`作動中な合致-@fiP
として識別されるようになる。
利用者は、［
`~find-in-page~UI$を利用して`作動中な合致-$fiPを次へ進める
］ことにより，
`合致-~list$fiPを成す各~合致-を~navigateできる。
◎
One of the matches is identified to the user as the active match. It is highlighted and scrolled into view. The user can navigate through the matches by advancing the active match using the find-in-page interface.
</p>

<p class="XXX">
`~find-in-page$が［
現在は未指定な `window.find()^c ~API
］の下層をどう成すか標準~化することは、
`課題 #3539＠~HTMLissue/3539$
にて追跡されている。
◎
Issue #3539 tracks standardizing how find-in-page underlies the currently-unspecified window.find() API.
</p>

			</section>
			<section id="interaction-with-details-and-hidden=until-found">
<h4 title="Interaction with details and hidden=until-found">6.9.2. `details^e 要素と見出されるまでは非可視な要素との相互作用</h4>

<p>
`~find-in-page$が合致するものを探索し始めるときは、
当の~page内の：
◎
When find-in-page begins searching for matches,＼
</p>
<ul>
	<li>
各 `details$e 要素のうち［
`open$a 属性を有さないもの
］の［
`2 個目の~slot＠~HTMLrendering#_details-slots$の中の`飛ばされた内容$
］は、
`~find-in-page$で探索~可能になるよう，［
`open$a 属性を改変することなく，~access可能になる
］べきである。
◎
all details elements in the page which do not have their open attribute set should have the skipped contents of their second slot become accessible, without modifying the open attribute, in order to make find-in-page able to search through it.＼
</li>
	<li>
各`~HTML要素$のうち［
その `hidden$a 属性の状態 ~EQ `見出されるまでは非可視$st
］を満たすものの`飛ばされた内容$は、
`~find-in-page$で探索~可能になるよう，［
`hidden$a 属性を改変することなく，~access可能になる
］ベキである。
◎
Similarly, all HTML elements with the hidden attribute in the Hidden Until Found state should have their skipped contents become accessible without modifying the hidden attribute in order to make find-in-page able to search through them.＼
</li>
</ul>

<p>
これらに該当する要素は、
`~find-in-page$が合致するものを探索し終えた後には，再び［
その`内容は飛ばされ$るようになる
］べきである。
この処理n全体は、
同期的に起こるモノトスル
（なので、
利用者や作者~codeからは観測-可能にならない）。
`CSSCONTAIN$r
◎
After find-in-page finishes searching for matches, the details elements and the elements with the hidden attribute in the Hidden Until Found state should have their contents become skipped again. This entire process must happen synchronously (and so is not observable to users or to author code). [CSSCONTAIN]
</p>

<div class="algo">
<p>
`~find-in-page$が新たな`作動中な合致-$fiPを選ぶときは、
次の手続きを遂行する：
◎
When find-in-page chooses a new active match, perform the following steps:
</p>
<ol>
	<li>
%~node ~LET `作動中な合致-$fiP内の最初の~node
◎
Let node be the first node in the active match.
</li>
	<li>
<p>
`大域~taskを~queueする$( `利用者ヤリトリ~task~source$, %~node に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the user interaction task source given node's relevant global object to run＼
</p>

<div class="algo">
手続きは
⇒
`先祖を露呈する$( %~node )
◎
the ancestor revealing algorithm on node.
</div>
	</li>
</ol>
</div>

<div class="warning">
<p>
◎追跡路
~find-in-pageが `details$e 要素を この様に自動-展開するとき、
`toggle$et ~eventを発火することになる。
~find-in-pageが発火する別々な `scroll$et ~eventと同じく、
この~eventも，~pageにより［
利用者が~find-in-page~dialogの中に何を打込んでいるか発見する
］ために利用され得る。
◎
(This is a tracking vector.)＼
When find-in-page auto-expands a details element like this, it will fire a toggle event. As with the separate scroll event that find-in-page fires, this event could be used by the page to discover what the user is typing into the find-in-page dialog.＼
</p>

<p>
【`scroll^et ~eventを利用する場合、】
~pageは、［
ごく狭い~scroll可能な区画 %区画 を作成した上で，次を繰返す
］ことにより，検索語を増分的に築くこともできる：
◎
If the page creates a tiny scrollable area＼
</p>
<ol>
	<li>
利用者が次に打込みそうな あらゆる文字に対し、
各［
現在の検索語と そのような文字が成す並び
］を，互いに間を~~空けて %区画 内に含める。
◎
with the current search term and every possible next character the user could type separated by a gap,＼
</li>
	<li>
~browserが どの文字へ~scrollするか観測する。
◎
and observes which one the browser scrolls to,＼
</li>
	<li>
観測された文字を追加して，現在の検索語を更新する。
◎
it can add that character to the search term and update the scrollable area＼
to incrementally build the search term.＼
</li>
</ol>

<p>
~pageは、
各［
アリな次回の合致-
］を閉じられた `details$e 要素~内に包装することにより，
`scroll$et ~eventの代わりに `toggle$et ~eventを~listenすることもできる。
◎
By wrapping each possible next match in a closed details element, the page could listen to toggle events instead of scroll events.＼
</p>

<p>
この攻撃は、
次により取組むこともできる
⇒
どちらの~eventも、
利用者が~find-in-page~dialogの中に文字を打込むたびに動作しないようにする。
◎
This attack could be addressed for both events by not acting on every character the user types into the find-in-page dialog.
</p>
</div>

			</section>
			<section id="interaction-with-selection">
<h4 title="Interaction with selection">6.9.3. 選択との相互作用</h4>

<p>
`~find-in-page$処理nは、
文書の文脈~内で呼出され，その文書の`選択$に効果を及ぼしてもヨイ。
特定的には、
`作動中な合致-$fiPを定義する範囲が，現在の選択を規定し得る。
しかしながら、［
~find-in-page処理nの間，この選択~更新が起こる時点
］は，いくつかあり得る
（例：
`~find-in-page~UI$が退けられた時点／
`作動中な合致-$fiPの範囲が変化した時点）。
◎
The find-in-page process is invoked in the context of a document, and may have an effect on the selection of that document. Specifically, the range that defines the active match can dictate the current selection. These selection updates, however, can happen at different times during the find-in-page process (e.g. upon the find-in-page interface dismissal or upon a change in the active match range).
</p>

			</section>
		</section>
		<section id="close-requests-and-close-watchers">
<h3 title="Close requests and close watchers">6.10 閉-要請と閉-注視器</h3>

			<section id="close-requests">
<h4 title="Close requests">6.10.1. 閉-要請</h4>

<p>
利用者は，`実装定義$な（かつ およそ機器に特有な）方式で，~UAに向けて
`閉-要請@
（ `close request^en ）を送信し得る。
これは、
現在は~screen上に示されている何か
— ~popover, ~menu, ~dialog, ~picker, 表示~modeなど —
を閉じるよう利用者が望むことを指示する。
◎
In an implementation-defined (and likely device-specific) manner, a user can send a close request to the user agent. This indicates that the user wishes to close something that is currently being shown on the screen, such as a popover, menu, dialog, picker, or display mode.
</p>

<div class="example">
<p>
閉-要請の例：
◎
Some example close requests are:
</p>
<ul>
	<li>
~desktop~platformにおける ~Esc ~UIkey。
◎
The Esc key on desktop platforms.
</li>
	<li>
ある種の~mobile~platform（ `Android^en など）における “戻り” ［
~button／~gesture
］。
◎
The back button or gesture on certain mobile platforms such as Android.
</li>
	<li>
支援技術~用の退-~gesture
— `iOS VoiceOver^en の “2 本指で “z” に こする” （ `two-finger scrub “z”^en ）~gestureなど。
◎
Any assistive technology's dismiss gesture, such as iOS VoiceOver's two-finger scrub "z" gesture.
</li>
	<li>
~game~controllerの正準的な “戻り” ~button
— `DualShock^en ~gamepad上の `circle^en 【 ⭕ 】~buttonなど。️
◎
A game controller's canonical "back" button, such as the circle button on a DualShock gamepad.
</li>
</ul>
</div>

<div class="algo">
<p>
~UAは、
`文書$ %文書 を~targetにする閉-要請になり得るものを受信したときは，
次を遂行するモノトスル
⇒
`大域~taskを~queueする$( `利用者ヤリトリ~task~source$, %文書 に`関連な大域~obj$, `閉-要請~手続き$ )
◎
Whenever the user agent receives a potential close request targeted at a Document document, it must queue a global task on the user interaction task source given document's relevant global object to＼
</p>
</div>

<div class="algo">
<p>
`閉-要請~手続き@
は、
次を遂行する：
◎
perform the following close request steps:
</p>
<ol>
	<li>
<p>
~IF［
%文書 の`~fullscreen要素$ ~NEQ ~NULL
］：
◎
If document's fullscreen element is not null, then:
</p>
		<ol>
			<li>
`~fullscreenから全部的に抜出る$( %文書 の`~node~navigable$の`~top-level辿可能$navにて`作動中な文書$nav )
◎
Fully exit fullscreen given document's node navigable's top-level traversable's active document.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>

<p class="note">注記：
これは、
最終的に `fullscreenchange$et を発火させる他には，
関連な~event
— `keydown$et など —
を`発火しない^em。
◎
This does not fire any relevant event, such as keydown; it only causes fullscreenchange to be eventually fired.
</p>
	</li>
	<li>
<p>
任意選択で
⇒
~GOTO `代替な処理＠#close-request-fallback$i
◎
Optionally, skip to the step labeled alternative processing.
</p>

<p class="note">注記：
例えば，~UAは、
現在の~web~pageにより［
利用者をいらつかせるような閉-要請の横取nが繰返された
］ことを検出した場合には，
この道をとることもあろう。
◎
For example, if the user agent detects user frustration at repeated close request interception by the current web page, it might take this path.
</p>
	</li>
	<li>
<p>
関連な~eventがあれば、
`UI Events^cite `UIEVENTS$r や他の関連な仕様に従って，それらを発火する
◎
Fire any relevant events, per UI Events or other relevant specifications. [UIEVENTS]
</p>

<p class="example">
`UI Events^cite ~modelにおける関連な~eventを成す例には、
`keydown$et ~eventが挙げられる
— それは、［
利用者が~keyboardの ~Esc ~UIkeyを押下げたとき，発火するもの
］として［
`UI Events^cite が`示唆するもの＠~UIEVENTS#events-keyboard-event-order$
］である。
ほとんどの［
~keyboardを伴う~platform
］では、
これは，`閉-要請$として扱われる
— なので、
`閉-要請~手続き$を誘発することになる。
◎
An example of a relevant event in the UI Events model would be the keydown event that UI Events suggests firing when the user presses the Esc key on their keyboard. On most platforms with keyboards, this is treated as a close request, and so would trigger these close request steps.
</p>

<p class="example">
`UI Events^cite ~modelの外側にある関連な~eventを成す例には、［
利用者が退-~gestureを利用して`閉-要請$を送信した
］とき，支援技術が ~Esc による `keydown$et ~eventを合成することが挙げられる。
◎
An example of relevant events that are outside of the model given in UI Events would be assistive technology synthesizing an Esc keydown event when the user sends a close request by using a dismiss gesture.
</p>
	</li>
	<li>
%~event ~LET 前~段により発火された~eventは［
無いならば ~NULL／
在るならば それらのうち いずれかを表現している `Event$I ~obj
］
— 複数個の~eventが発火された場合、
どれを選ぶかは`実装定義$とする。
◎
Let event be null if no such events are fired, or the Event object representing one of the fired events otherwise. If multiple events are fired, which one is chosen is implementation-defined.
</li>
	<li>
~IF［
%~event ~NEQ ~NULL
］~AND［
%~event の`取消されたか$ev ~EQ ~T
］
⇒
~RET
◎
If event is not null, and its canceled flag is set, then return.
</li>
	<li>
<p>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET
◎
If document is not fully active, then return.
</p>

<p class="note">注記：
この段は必要yある
— %~event ~NEQ ~NULL の場合、
ある~event~listenerが， %文書 を`全部的に作動中$でなくするかもしれないので。
◎
This step is necessary because, if event is not null, then an event listener might have caused document to no longer be fully active.
</p>
	</li>
	<li>
%何か閉じられたか ~LET `閉-注視器たちを処理する$( %文書 に`関連な大域~obj$ )
◎
Let closedSomething be the result of processing close watchers on document's relevant global object.
</li>
	<li>
~IF［
%何か閉じられたか ~EQ ~T
］
⇒
~RET
◎
If closedSomething is true, then return.
</li>
	<li id="close-request-fallback">
`代替な処理^i
⇒
`閉-要請$を注視していたものは無い
— ~UAは、
このヤリトリを閉-要請として解釈する代わりに，他の何らかの動作として解釈してもヨイ。
◎
Alternative processing: Otherwise, there was nothing watching for a close request. The user agent may instead interpret this interaction as some other action, instead of interpreting it as a close request.
</li>
</ol>
</div>

<p>
~Esc ~UIkeyが押下げられたとき【から放されるまでのどこかで？】，`閉-要請$として解釈される~platformにおいては、
~UAは，~UIkeyが`押下げられた^em【！pressed down】とき，`閉-要請$として解釈するモノトスル
— 放されたときではなく。
したがって，上の~algoにおいて発火される “関連な~event” は、
`keydown$et ~event一つだけになるモノトスル
【 `keyup^et も発火することなく】。
◎
On platforms where pressing the Esc key is interpreted as a close request, the user agent must interpret the key being pressed down as the close request, instead of the key being released. Thus, in the above algorithm, the "relevant events" that are fired must be the single keydown event.
</p>

<p class="example">
~Esc ~UIkeyが押下げられたとき，それが`閉-要請$になる~platformにおいては、
~UAは，適切に初期化された `keydown$et ~eventを発火することになる。
~web開発者が `preventDefault()$m を~callして当の~eventを取消した場合、
それ以上何も起こらない。
取消されなかった場合、
~UAは，`閉-注視器たちを処理する$所まで続行する。
◎
On platforms where Esc is the close request, the user agent will first fire an appropriately-initialized keydown event. If the web developer cancels the event by calling preventDefault(), then nothing further happens. But if the event fires without being canceled, then the user agent proceeds to process close watchers.
</p>

<p class="example">
“戻り” ~buttonが押下げられたとき，
それが`閉-要請$になり得る~platformにおいては、
~UAは，`閉-注視器たちを処理する$所へ直行する
— そこに孕まれる~eventは無いので。
`作動中$cWな`閉-注視器$が在る場合、
それが誘発されるようになる
— 無い場合、
~UAは， “戻り” ~buttonの押下nを別の仕方で解釈できる
— 例えば，
履歴を差分 −1 だけ`辿る＠~HTMLnav#traverse-the-history-by-a-delta$よう要請されたものとして。
◎
On platforms where a back button is a potential close request, no event is involved, so when the back button is pressed, the user agent proceeds directly to process close watchers. If there is an active close watcher, then that will get triggered. If there is not, then the user agent can interpret the back button press in another way, for example as a request to traverse the history by a delta of −1.
</p>

			</section>
			<section id="close-watcher-infrastructure">
<h4 title="Close watcher infrastructure">6.10.2. 閉-注視器の基盤</h4>

<p>
各`~window$は
`閉-注視器~管理器@
（ `close watcher manager^en ）を有する
— それは、
`構造体$であり，次を挙げる`~item$sctを伴う：
◎
Each Window has a close watcher manager, which is a struct with the following items:
</p>
<ul>
	<li>
`~group群@cwM
⇒
`閉-注視器$たちが成す`~list$たちが成す`~list$
— 初期~時は空とする。
◎
Groups, a list of lists of close watchers, initially empty.
</li>
	<li>
`許容される~groupの個数@cwM
⇒
整数
— 初期~時は 1 とする。
◎
Allowed number of groups, a number, initially 1.
</li>
	<li>
`次回の利用者-作動化は新たな~groupを許容するか@cwM
⇒
真偽値
— 初期~時は ~T とする。
◎
Next user interaction allows a new group, a boolean, initially true.
</li>
</ul>

<p>
`閉-注視器~管理器$の複階性を成すほとんどは、［
利用者が履歴を辿る能を開発者が不能化する
］ことを防止するために設計された［
濫用に抗する保護
］に~~由来する
— それは、
`閉-要請$の`~fallback動作＠#close-request-fallback$が履歴の辿りを成す主な仕組みである~platform用にある。
特に：
◎
Most of the complexity of the close watcher manager comes from anti-abuse protections designed to prevent developers from disabling users' history traversal abilities, for platforms where a close request's fallback action is the main mechanism of history traversal. In particular:
</p>
<ul>
	<li>
`閉-注視器$の~group法は、［
`履歴~動作による作動化を有して$いない間に複数個の閉-注視器が作成された場合
］に，それらを一緒に~group化して、［
利用者が誘発した`閉-要請$が，~group内の閉-注視器~すべてを閉じる
］ことになるように設計された。
これは、
~web開発者が［
閉-注視器をいくつも作成することにより，閉-要請を何回でも無制限に横取りできなくする
］ことを確保する
— 代わりに，開発者は、
( 1 ~PLUS `利用者が~pageを作動化-＠#tracking-user-activation$した回数 )
以下までは，それを作成できる。
◎
The grouping of close watchers is designed so that if multiple close watchers are created without history-action activation, they are grouped together, so that a user-triggered close request will close all of the close watchers in a group. This ensures that web developers can't intercept an unlimited number of close requests by creating close watchers; instead they can create a number equal to at most 1 + the number of times the user activates the page.
</li>
	<li>
<p>
真偽値をとる`次回の利用者-作動化は新たな~groupを許容するか$cwMは、［
個々の`利用者-作動化＠#tracking-user-activation$に束ねられる仕方で`閉-注視器$を作成する
］よう，~web開発者に奨励する。
これが無いと、［
~web開発者が閉-注視器を作成するために利用者-作動化を “利用していない” 場合
］でも［
利用者-作動化が生じるたびに`許容される~groupの個数$cwMは増える
］ことになる。
短く言えば：
◎
The next user interaction allows a new group boolean encourages web developers to create close watchers in a way that is tied to individual user activations. Without it, each user activation would increase the allowed number of groups, even if the web developer isn't "using" those user activations to create close watchers. In short:
</p>
		<ul>
			<li>
次【が順に生じること】は許容される
⇒＃
利用者-ヤリトリ,
閉-注視器を その自前の~group内に作成する,
利用者-ヤリトリ,
閉-注視器を別な~group内に作成する
◎
Allowed: user interaction; create a close watcher in its own group; user interaction; create a close watcher in a second independent group.
</li>
			<li>
次は許容されない
⇒＃
利用者-ヤリトリ,
利用者-ヤリトリ,
閉-注視器を その自前の~group内に作成する,
閉-注視器を別な~group内に作成する
◎
Disallowed: user interaction; user interaction; create a close watcher in its own group; create a close watcher in a second independent group.
</li>
			<li>
次は許容される
⇒＃
利用者-ヤリトリ,
利用者-ヤリトリ,
閉-注視器を その自前の~group内に作成する,
閉-注視器を 前と同じ~group内に作成する
◎
Allowed: user interaction; user interaction; create a close watcher in its own group; create a close watcher grouped with the previous one.
</li>
		</ul>
<p>
この保護は、
欲される不変則
— 作成される~groupの個数は［
1 ~PLUS `利用者が~pageを作動化-＠#tracking-user-activation$した回数
］までになる —
を支えるために重要なもの`ではない^em。
確信犯な濫用者は、
利用者-ヤリトリごとに閉-注視器を 1 個だけ作成して，
未来の濫用-用にそれらを “貯蓄する” ことになる。
それでも，この~systemは、
通常の事例~用には，より予測-可能な挙動をもたらし、
濫用的でない開発者が［
利用者-ヤリトリに呼応して閉-注視器を直に作成する
］ことを奨励する。
◎
This protection is not important for upholding our desired invariant of creating at most (1 + the number of times the user activates the page) groups. A determined abuser will just create one close watcher per user interaction, "banking" them for future abuse. But this system causes more predictable behavior for the normal case, and encourages non-abusive developers to create close watchers directly in response to user interactions.
</p>
	</li>
</ul>

<div class="algo">
<p>
`利用者-作動化について閉-注視器~管理器に通知する@
~algoは、
所与の
( `~window$ %~window )
に対し：
◎
To notify the close watcher manager about user activation given a Window window:
</p>
<ol>
	<li>
%管理器 ~LET %~window の`閉-注視器~管理器$
◎
Let manager be window's close watcher manager.
</li>
	<li>
~IF［
%管理器 の`次回の利用者-作動化は新たな~groupを許容するか$cwM ~EQ ~T
］
⇒
%管理器 の`許容される~groupの個数$cwM ~INCBY 1
◎
If manager's next user interaction allows a new group is true, then increment manager's allowed number of groups.
</li>
	<li>
%管理器 の`次回の利用者-作動化は新たな~groupを許容するか$cwM ~SET ~F
◎
Set manager's next user interaction allows a new group to false.
</li>
</ol>
</div>

<hr>

<p>
`閉-注視器@
（ `close watcher^en ）は、
`構造体$であり，次を挙げる`~item$sctを伴う：
◎
A close watcher is a struct with the following items:
</p>
<ul>
	<li>
`~window@cW
（ `window^en ）
⇒
ある`~window$
◎
A window, a Window.
</li>
	<li>
<p>
`取消-動作@cW
（ `cancel action^en ）
⇒
次に従う~algo
⇒＃
真偽値を受容する,
真偽値を返す,
例外を投出しない
</p>

<p>
引数は、［
取消-動作~algoの返り値
］を介して［
当の`閉-要請$は閉-動作~algoへ続行することを防止し得るか否か
］を指示する。
この~algoは、
引数に応じて［
~T ならば，［
~T, ~F
］どちらも返し得る／
~F ならば，常に ~F を返す
］
— ［
~T ／ ~F
］を返す場合、
~call元は`閉-動作$cWへ続行するように［
なる／ならない
］ことを指示する。
</p>
◎
A cancel action, an algorithm accepting a boolean argument and returning a boolean.＼
The argument indicates whether or not the cancel action algorithm can prevent the close request from proceeding via the algorithm's return value.＼
If the boolean argument is true, then the algorithm can return either true to indicate that the caller will proceed to the close action, or false to indicate that the caller will bail out.＼
If the argument is false, then the return value is always false.＼
This algorithm can never throw an exception.
</li>
	<li>
`閉-動作@cW
（ `close action^en ）
⇒
次に従う~algo
⇒＃
何も受容しない,
何も返さない,
例外を投出しない
◎
A close action, an algorithm accepting no arguments and returning nothing. This algorithm can never throw an exception.
</li>
	<li>
`取消-動作を走らせているか@cW
（ `is running cancel action^en ）
⇒
真偽値
◎
An is running cancel action boolean.
</li>
	<li>
`可能化~状態を取得する@cW
⇒
次に従う~algo
⇒＃
何も受容しない,
真偽値を返す,
例外を投出しない
◎
A get enabled state, an algorithm accepting no arguments and returning a boolean. This algorithm can never throw an exception.
</li>
</ul>

<p>
`閉-注視器$ %閉-注視器 が
`作動中@cW
であるとは、
次を満たす %~list が在ることをいう
⇒
［
%閉-注視器 ~IN %~list
］~AND［
%~list ~IN %閉-注視器 の`~window$cWの`閉-注視器~管理器$
］
◎
A close watcher closeWatcher is active if closeWatcher's window's close watcher manager contains any list which contains closeWatcher.
</p>

<hr>

<div class="algo">
<div>
<p>
`閉-注視器を確立する@
~algoは、
所与の
( `~window$, %~window )
および
</p>
<ul>
	<li id="create-close-watcher-cancelaction">
ある手続き %取消-動作
</li>
	<li id="create-close-watcher-closeaction">
ある手続き %閉-動作
</li>
	<li id="create-close-watcher-getenabledstate">
真偽値を返す~algo %可能化~状態を取得する
</li>
</ul>
<p>
に対し：
</p>
◎
To establish a close watcher given a Window window, a list of steps cancelAction, a list of steps closeAction, and an algorithm that returns a boolean getEnabledState:
</div>
<ol>
	<li>
~Assert：
%~window に`結付けられた文書$は`全部的に作動中$である。
◎
Assert: window's associated Document is fully active.
</li>
	<li>
%閉-注視器 ~LET 新たな`閉-注視器$
— その
⇒＃
`~window$cW ~SET %~window,
`取消-動作$cW ~SET %取消-動作,
`閉-動作$cW ~SET %閉-動作,
`取消-動作を走らせているか$cW ~SET ~F,
`可能化~状態を取得する$cW ~SET %可能化~状態を取得する
◎
Let closeWatcher be a new close watcher, with
• window
•• window
• cancel action
•• cancelAction
• close action
•• closeAction
• is running cancel action
•• false
• get enabled state
•• getEnabledState
</li>
	<li>
%管理器 ~LET %~window の`閉-注視器~管理器$
◎
Let manager be window's close watcher manager.
</li>
	<li>
~IF［
%管理器 の`~group群$cwMの`~size$ ~LT %管理器 の`許容される~groupの個数$cwM
］
⇒
%管理器 の`~group群$cwMに « %閉-注視器 » を`付加する$
◎
If manager's groups's size is less than manager's allowed number of groups, then append « closeWatcher » to manager's groups.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
~Assert：
%管理器 の`~group群$cwMの`~size$ ~GTE 1
（`許容される~groupの個数$cwMは常に 1 以上なので）
◎
Assert: manager's groups's size is at least 1 in this branch, since manager's allowed number of groups is always at least 1.
</li>
			<li>
%管理器 の`~group群$cwMを成す最後の`~item$に %閉-注視器 を`付加する$
◎
Append closeWatcher to manager's groups's last item.
</li>
		</ol>
	</li>
	<li>
%管理器 の`次回の利用者-作動化は新たな~groupを許容するか$cwM ~SET ~T
◎
Set manager's next user interaction allows a new group to true.
</li>
	<li>
~RET %閉-注視器
◎
Return closeWatcher.
</li>
</ol>
</div>

<div class="algo">
<p>
`閉-注視器に閉じるよう要請する@
~algoは、
所与の
( `閉-注視器$ %閉-注視器, 真偽値 %履歴~動作による作動化を要求するか )
に対し：
◎
To request to close a close watcher closeWatcher with boolean requireHistoryActionActivation:
</p>
<ol>
	<li>
~IF［
%閉-注視器 は`作動中$cWでない
］
⇒
~RET ~T
◎
If closeWatcher is not active, then return true.
</li>
	<li>
~IF［
%閉-注視器 の`可能化~状態を取得する$cW() ~EQ ~F
］
⇒
~RET ~T
◎
If the result of running closeWatcher's get enabled state is false, then return true.
</li>
	<li>
~IF［
%閉-注視器 の`取消-動作を走らせているか$cW ~EQ ~T
］
⇒
~RET ~T
◎
If closeWatcher's is running cancel action is true, then return true.
</li>
	<li>
%~window ~LET %閉-注視器 の`~window$cW
◎
Let window be closeWatcher's window.
</li>
	<li>
~IF［
%~window に`結付けられた文書$は`全部的に作動中$でない
］
⇒
~RET ~T
◎
If window's associated Document is not fully active, then return true.
</li>
	<li>
%管理器 ~LET %~window の`閉-注視器~管理器$
◎
↓</li>
	<li>
<p>
%閉-を防止し得るか ~LET ~IS ~OR↓：
</p>
		<ul>
			<li>
%履歴~動作による作動化を要求するか ~EQ ~F
</li>
			<li>
［
%管理器 の`~group群$cwMの`~size$ ~LT %管理器 の`許容される~groupの個数$cwM
］~AND［
%~window は`履歴~動作による作動化を有して$いる
］
</li>
		</ul>
◎
Let canPreventClose be true if requireHistoryActionActivation is false, or if window's close watcher manager's groups's size is less than window's close watcher manager's allowed number of groups, and window has history-action activation; otherwise false.
</li>
	<li>
%閉-注視器 の`取消-動作を走らせているか$cW ~SET ~T
◎
Set closeWatcher's is running cancel action to true.
</li>
	<li>
%継続するべきか ~LET %閉-注視器 の`取消-動作$cW( %閉-を防止し得るか )
◎
Let shouldContinue be the result of running closeWatcher's cancel action given canPreventClose.
</li>
	<li>
%閉-注視器 の`取消-動作を走らせているか$cW ~SET ~F
◎
Set closeWatcher's is running cancel action to false.
</li>
	<li>
<p>
~IF［
%継続するべきか ~EQ ~F
］：
◎
If shouldContinue is false, then:
</p>
		<ol>
			<li>
~Assert：
%閉-を防止し得るか ~EQ ~T
◎
Assert: canPreventClose is true.
</li>
			<li>
`履歴~動作による作動化を消費する$( %~window )
◎
Consume history-action user activation given window.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>

<p class="note">注記：
この段の中では`履歴~動作による作動化を消費する$ので、
`閉-注視器$に対し
— `利用者-作動化＠#tracking-user-activation$が介入することなく —
続けて`閉じる＠#close-watcher-request-close$よう要請したときは，
2 回目においては %閉-を防止し得るか は ~F になる。
◎
Note that since these substeps consume history-action user activation, requesting to close a close watcher twice without any intervening user activation will result in canPreventClose being false the second time.
</p>
	</li>
	<li>
`閉-注視器を閉じる$( %閉-注視器 )
◎
Close closeWatcher.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`閉-注視器を閉じる@
~algoは、
所与の
( `閉-注視器$ %閉-注視器 )
に対し：
◎
To close a close watcher closeWatcher:
</p>
<ol>
	<li>
~IF［
%閉-注視器 は`作動中$cWでない
］
⇒
~RET
◎
If closeWatcher is not active, then return.
</li>
	<li>
~IF［
%閉-注視器 の`可能化~状態を取得する$cW() ~EQ ~F
］
⇒
~RET
◎
If the result of running closeWatcher's get enabled state is false, then return.
</li>
	<li>
~IF［
%閉-注視器 の`~window$cWに`結付けられた文書$は`全部的に作動中$でない
］
⇒
~RET
◎
If closeWatcher's window's associated Document is not fully active, then return.
</li>
	<li>
`閉-注視器を破壊する$( %閉-注視器 )
◎
Destroy closeWatcher.
</li>
	<li>
%閉-注視器 の`閉-動作$cW()
◎
Run closeWatcher's close action.
</li>
</ol>
</div>

<div class="algo">
<p>
`閉-注視器を破壊する@
~algoは、
所与の
( `閉-注視器$ %閉-注視器 )
に対し：
◎
To destroy a close watcher closeWatcher:
</p>
<ol>
	<li>
%管理器 ~LET %閉-注視器 の`~window$cWの`閉-注視器~管理器$
◎
Let manager be closeWatcher's window's close watcher manager.
</li>
	<li>
<p>
%管理器 の`~group群$cwMを成す
~EACH( %~group )
に対し：
</p>
		<ol>
			<li>
%~group から %閉-注視器 を`除去する$
</li>
			<li>
~IF［
%~group は`空$である
］
⇒
%管理器 の`~group群$cwMから %~group を`除去する$
</li>
		</ol>
◎
For each group of manager's groups: remove closeWatcher from group.
◎
Remove any item from manager's groups that is empty.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`閉-注視器たちを処理する@
~algoは、
所与の
( `~window$ %~window )
に対し：
◎
To process close watchers given a Window window:
</p>
<ol>
	<li>
%閉-注視器を処理したか ~LET ~F
◎
Let processedACloseWatcher be false.
</li>
	<li>
%管理器 ~LET %~window の`閉-注視器~管理器$
◎
↓</li>
	<li>
<p>
~IF［
%管理器 の`~group群$cwMは`空$でない
］：
◎
If window's close watcher manager's groups is not empty:
</p>
		<ol>
			<li>
%~group ~LET %管理器 の`~group群$cwMを成す最後の`~item$
◎
Let group be the last item in window's close watcher manager's groups.
</li>
			<li>
<p>
%~group を成す
~EACH( %閉-注視器 )
に対し，逆順に：
◎
For each closeWatcher of group, in reverse order:
</p>
				<ol>
					<li>
~IF［
%閉-注視器 の`可能化~状態を取得する$cW() ~EQ ~T
］
⇒
%閉-注視器を処理したか ~SET ~T
◎
If the result of running closeWatcher's get enabled state is true, set processedACloseWatcher to true.
</li>
					<li>
%続行するべきか ~LET `閉-注視器に閉じるよう要請する$( %閉-注視器, ~T )
◎
Let shouldProceed be the result of requesting to close closeWatcher with true.
</li>
					<li>
~IF［
%続行するべきか ~EQ ~F
］
⇒
~BREAK
◎
If shouldProceed is false, then break.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
%管理器 の`許容される~groupの個数$cwM ~GT 1
］
⇒
%管理器 の`許容される~groupの個数$cwM ~DECBY 1
◎
If window's close watcher manager's allowed number of groups is greater than 1, decrement it by 1.
</li>
	<li>
~RET %閉-注視器を処理したか
◎
Return processedACloseWatcher.
</li>
</ol>
</div>

			</section>
			<section id="the-closewatcher-interface">
<h4 title="The CloseWatcher interface">6.10.3. `CloseWatcher^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `CloseWatcher@I : `EventTarget$I {
  `constructor＠#dom-closewatcher$(optional `CloseWatcherOptions$I %options = {});

  undefined `requestClose$m();
  undefined `close$m();
  undefined `destroy$m();

  attribute `EventHandler$I `oncancel$m;
  attribute `EventHandler$I `onclose$m;
};

dictionary `CloseWatcherOptions@I {
  `AbortSignal$I `signal@mb;
};
</pre>

<dl class="domintro">
	<dt>%watcher = `new CloseWatcher()$m</dt>
	<dt>%watcher = `new CloseWatcher(option)$m【！({ signal })】</dt>
	<dd>
新たな `CloseWatcher$I ~instanceを作成する。
◎
Creates a new CloseWatcher instance.
</dd>
	<dd>
%option にて `signal$mb が供された場合、
それ（ `AbortSignal$I ）を中止する
【その `abort()^m ~methodを~callする】
ことにより，
%watcher を破壊できる
（ `destroy()$m を~callしたかのように）。
◎
If the signal option is provided, then watcher can be destroyed (as if by watcher.destroy()) by aborting the given AbortSignal.
</dd>
	<dd>
すでに作動中な`閉-注視器$ %閉-注視器 が在って，
`~window$は`履歴~動作による作動化を有して$いない間に~callされた場合、
結果の `CloseWatcher$I は，［
どの`閉-要請$に対しても、
それに呼応して， %閉-注視器 と一緒に閉じられる
］ことになる
（ %閉-注視器 は，
`CloseWatcher$I ~objになるとは限らず，［
~modalな `dialog$e 要素／ `~popover要素$により生成された~popover
］にもなり得る。）
◎
If any close watcher is already active, and the Window does not have history-action activation, then the resulting CloseWatcher will be closed together with that already-active close watcher in response to any close request. (This already-active close watcher does not necessarily have to be a CloseWatcher object; it could be a modal dialog element, or a popover generated by an element with the popover attribute.)
</dd>

	<dt>%watcher.`requestClose$m()</dt>
	<dd>
%watcher を~targetにしている`閉-要請$が送信されたかのように動作する
— 次により
⇒
まず `cancel$et ~eventを発火する
— それが `preventDefault()$m で取消されなかった場合，
続行して `close$et ~eventを発火する
— 当の閉-注視器を非作動化する前に `destroy()$m を~callしたかのように。
◎
Acts as if a close request was sent targeting watcher, by first firing a cancel event, and if that event is not canceled with preventDefault(), proceeding to fire a close event before deactivating the close watcher as if watcher.destroy() was called.
</dd>
	<dd>
これは、［
`閉-要請$ではない閉じるための~affordanceすべてが，この~methodを~callする
］ようにすることにより，［
取消す, 閉じる
］際の~logicを［
`cancel$et, `close$et
］~event~handlerの中に~~統合するための便利用として利用できる。
◎
This is a helper utility that can be used to consolidate cancelation and closing logic into the cancel and close event handlers, by having all non-close request closing affordances call this method.
</dd>

	<dt>%watcher.`close$m()</dt>
	<dd>
`close$et ~eventを即時に発火してから
当の閉-注視器を
— `destroy()$m を~callしたかのように —
非作動化する。
◎
Immediately fires the close event, and then deactivates the close watcher as if watcher.destroy() was called.
</dd>
	<dd>
これは、［
閉じる際の~logicを `close$et ~event~handlerの中で誘発しつつ，
`cancel$et ~event~handler内のそれを飛ばす
］ための便利用として利用できる。
◎
This is a helper utility that can be used trigger the closing logic into the close event handler, skipping any logic in the cancel event handler.
</dd>

	<dt>%watcher.`destroy$m()</dt>
	<dd>
%watcher を非作動化する
— %watcher は `close$et ~eventを受信しなくなり，
新たな独立な `CloseWatcher$I ~instanceを構築できるよう。
◎
Deactivates watcher, so that it will no longer receive close events and so that new independent CloseWatcher instances can be constructed.
</dd>
	<dd>
これは、［
閉じられる以外の何らかの仕方
］で［
関連な~UI要素が解体される場合
］に~callされるものとして意図される。
◎
This is intended to be called if the relevant UI element is torn down in some other way than being closed.
</dd>
</dl>

<p>
各 `CloseWatcher$I ~instanceは、
`内部~閉-注視器@
（ `internal close watcher^en ）を有する
— それは、
`閉-注視器$である。
◎
Each CloseWatcher instance has an internal close watcher, which is a close watcher.
</p>

<div class="algo">
<p>
`new CloseWatcher(options)@m
構築子~手続きは：
◎
The new CloseWatcher(options) constructor steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な大域~obj$に`結付けられた文書$は`全部的に作動中$でない
］
⇒
~THROW `InvalidStateError$E
◎
If this's relevant global object's associated Document is not fully active, then throw an "InvalidStateError" DOMException.
</li>
	<li>
<p>
%閉-注視器 ~LET `閉-注視器を確立する$( コレに`関連な大域~obj$ )
— 次も与える下で：
◎
Let closeWatcher be the result of establishing a close watcher given this's relevant global object, with:
</p>
		<ul>
			<li class="algo">
`取消-動作^i は、
所与の
( %閉-を防止し得るか )
に対し
⇒
~RET `~eventを発火する$( コレ, `cancel$et )
— 次のように初期化して
⇒＃
`cancelable$m 属性 ~SET %閉-を防止し得るか
◎
cancelAction given canPreventClose being to return the result of firing an event named cancel at this, with the cancelable attribute initialized to canPreventClose.
</li>
			<li class="algo">
`閉-動作^i は
⇒
`~eventを発火する$( コレ, `close$et )
◎
closeAction being to fire an event named close at this.
</li>
			<li class="algo">
`可能化~状態を取得する^i は
⇒
~RET ~T
◎
getEnabledState being to return true.
</li>
		</ul>
	</li>
	<li>
%signal ~LET %options[ "`signal$mb" ]
◎
↓</li>
	<li>
<p>
~IF［
%signal ~NEQ ε
］：
◎
If options["signal"] exists, then:
</p>
		<ol>
			<li>
~IF［
%signal は`中止-済み$aBである
］
⇒
`閉-注視器を破壊する$( %閉-注視器 )
◎
If options["signal"] is aborted, then destroy closeWatcher.
</li>
			<li>
<p>
`通達に~algoを追加する$( %signal, 次の手続き )
◎
Add the following steps to options["signal"]:
</p>

<div class="algo">
手続きは
⇒
`閉-注視器を破壊する$( %閉-注視器 )
◎
Destroy closeWatcher.
</div>
			</li>
		</ol>
	</li>
	<li>
コレ の`内部~閉-注視器$ ~SET %閉-注視器
◎
Set this's internal close watcher to closeWatcher.
</li>
</ol>
</div>

<div class="algo">
<p>
`requestClose()@m
~method手続きは
⇒
`閉-注視器に閉じるよう要請する$( コレの`内部~閉-注視器$, ~F )
◎
The requestClose() method steps are to request to close this's internal close watcher with false.
</p>
</div>

<div class="algo">
<p>
`close()@m
~method手続きは
⇒
`閉-注視器を閉じる$( コレの`内部~閉-注視器$ )
◎
The close() method steps are to close this's internal close watcher.
</p>
</div>

<div class="algo">
<p>
`destroy()@m
~method手続きは
⇒
`閉-注視器を破壊する$( コレの`内部~閉-注視器$ )
◎
The destroy() method steps are to destroy this's internal close watcher.
</p>
</div>

<p>
`CloseWatcher$I ~interfaceを実装している すべての~objは、［
以下に挙げる`~event~handler$, および対応する`~event~handler~event型$
］を`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the CloseWatcher interface:
</p>

<div>
<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
<tbody><tr><td>`oncancel@m
<td> `cancel$et

<tr><td>`onclose@m
<td> `close$et
</table>

◎
Event handler｜Event handler event type
oncancel｜cancel
onclose｜close
</div>

<div class="example" id="example-CloseWatcher-basic">
<p>
ある~custom~picker~control
— 利用者から`閉-要請$が供されたときに加え，
閉-~buttonが押下げられたときにも自身を閉じるようなそれ —
を実装することが求まれる場合に，
`CloseWatcher$I ~APIを利用して閉-要請をどう処理するかを次の~codeに示す：
◎
If one wanted to implement a custom picker control, which closed itself on a user-provided close request as well as when a close button is pressed, the following code shows how one would use the CloseWatcher API to process close requests:
</p>

<pre class="lang-js">
const %watcher = new CloseWatcher();
const %picker = setUpAndShowPickerDOMElement();

let %chosenValue = null;

watcher.onclose = () =&gt; {
  %chosenValue = %picker.querySelector('input').value;
  %picker.remove();
};

%picker.querySelector('.close-button').onclick = () =&gt; watcher.requestClose();
</pre>

<p>
選ばれた値を集める~logicは［
`CloseWatcher$I ~objの `close$et ~event~handler
］内に集約され、
それに伴い，
閉-~button用の `click$et ~event~handlerは［
`requestClose()$m を~callすることで，その~logicへ委任している
］ことに注意。
◎
Note how the logic to gather the chosen value is centralized in the CloseWatcher object's close event handler, with the click event handler for the close button delegating to that logic by calling requestClose().
</p>
</div>

<div class="example" id="example-CloseWatcher-cancel">
<p>
`CloseWatcher$I ~obj用の `cancel$et ~eventを利用すれば、［
`close$et ~eventが発火され， `CloseWatcher$I が破壊される
］ことを防止できる。
典型的な利用事例は：
◎
The cancel event on CloseWatcher objects can be used to prevent the close event from firing, and the CloseWatcher from being destroying. A typical use case is as follows:
</p>

<pre class="lang-js">
%watcher.oncancel = async (%e) =&gt; {
  if (%hasUnsavedData &amp;&amp; %e.cancelable) {
    e.preventDefault();

    /* <span class="comment">
~dataを保存することなく閉じるかどうか利用者に確認を依頼する
</span> */
    const %userReallyWantsToClose = await askForConfirmation("Are you sure you want to close?");
    if (%userReallyWantsToClose) {
      %hasUnsavedData = false;
      %watcher.close();
    }
  }
};
</pre>

<p>
濫用を防止するため、
この~eventの `cancelable$m が ~T になるのは，［
当の~pageが`履歴~動作による作動化を有して$いる間
］に限られる
— それは、
どの`閉-要請$が与えられた後も失われる。
このことは、［
利用者が閉-要請を
— 利用者-作動化が介入することなく —
続けて送信した場合に，要請は紛れもなく成功する
］ことを確保する
— 2 回目の要請は、
`cancel$et ~event~handlerによる `preventDefault()$m を~callする試みを無視して，
当の `CloseWatcher$I を閉じるよう続行する。
◎
For abuse prevention purposes, this event is only cancelable if the page has history-action activation, which will be lost after any given close request. This ensures that if the user sends a close request twice in a row without any intervening user activation, the request definitely succeeds; the second request ignores any cancel event handler's attempt to call preventDefault() and proceeds to close the CloseWatcher.
</p>
</div>

<p>
上の 2 つの例は、［
`requestClose()$m と `close()$m がどう相違するか
］を示す。
最初の例では，［
`click$et ~event~handler内で閉-~button用に `requestClose()$m を利用した
］ので、［
その~buttonを~clickすると `CloseWatcher$I の `cancel$et ~eventを誘発する
］ことになる
— したがって、［
保存されてない~dataが在る場合に利用者に確認を依頼する
］ようになり得る。
`close()$m を利用していた場合、
この検査は飛ばされるようになる。
それが適切になるときもあるが、
利用者が誘発した閉-要請~用には，
`requestClose()$m の方が通例的に良い~optionになる。
◎
Combined, the above two examples show how requestClose() and close() differ. Because we used requestClose() in the click event handler for the close button, clicking that button will trigger the CloseWatcher's cancel event, and thus potentially ask the user for confirmation if there is unsaved data. If we had used close(), then this check would be skipped. Sometimes that is appropriate, but usually requestClose() is the better option for user-triggered close requests.
</p>

<div class="example" id="example-CloseWatcher-grouping">
<p>
`利用者-作動化＠#tracking-user-activation$には、
それに関する `cancel$et ~event用の制約に加えて，
もっと微妙な形で `CloseWatcher$I の構築を通過制御するものが在る。
利用者-作動化を伴わずに複数個の `CloseWatcher$I を作成する場合、
後から作成された`閉-注視器$は，最も近過去に作成されたものと一緒に~group化されるようになる
— 単独の`閉-要請$が どちらも閉じるよう：
◎
In addition to the user activation restrictions for cancel events, there is a more subtle form of user activation gating for CloseWatcher construction. If one creates more than one CloseWatcher without user activation, then the newly-created one will get grouped together with the most-recently-created close watcher, so that a single close request will close them both:
</p>

<pre class="lang-js">
window.onload = () =&gt; {
  /* <span class="comment">
次の注視器は、
通常通り働くことになる
— それは、
利用者-作動化を伴わずに作成された注視器のうち最初のものを閉じる。
◎
This will work as normal: it is the first close watcher created without user activation.
</span> */
  (new CloseWatcher()).onclose = () =&gt; { /* ... */ };
};

%button1.onclick = () =&gt; {
    /* <span class="comment">
次の注視器は、
通常通り働くことになる
— ~button~clickは，利用者-作動化として数えられる。
◎
This will work as normal: the button click counts as user activation.
</span> */
  (new CloseWatcher()).onclose = () =&gt; { /* ... */ };
};

%button2.onclick = () =&gt; {
  /* <span class="comment">
次の注視器たちは、
一緒に~group化される
— それらは、
単独の閉-要請に呼応して，どちらも閉じられるようになる。
◎
These will be grouped together, and both will close in response to a single close request.
</span> */
  (new CloseWatcher()).onclose = () =&gt; { /* ... */ };
  (new CloseWatcher()).onclose = () =&gt; { /* ... */ };
};
</pre>

<p>
このことは、［
`destroy()$m, `close()$m, `requestClose()$m
］を適正に~callすることが重要になることを意味する。
そうすることが［
“自由な” ~group化されてない閉-注視器まで戻る
］ための唯一の仕方である。
そのような利用者-作動化を伴わずに作成された閉-注視器は、
次の様な事例~用に有用になる
⇒
［
利用者-作動化に呼応して生成されたものではない，~serverが誘発した~event
］を成す［
活動が無い~sessionの時間切れに伴う~dialog／至急な通知
］。
◎
This means that calling destroy(), close(), or requestClose() properly is important. Doing so is the only way to get back the "free" ungrouped close watcher slot. Such close watchers created without user activation are useful for cases like session inactivity timeout dialogs or urgent notifications of server-triggered events, which are not generated in response to user activation.
</p>
</div>

			</section>
		</section>
	</section>
</main>
