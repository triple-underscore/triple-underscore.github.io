<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — User interaction（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'editing',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ー]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'mE':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'a':
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'h':
	text = `<code class="header">${text}</code>`;
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'Key': 
	text = `<kbd><kbd>${key}</kbd></kbd>`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2023-08-25
trans_update:2023-08-26
source_checked:230626
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/interaction.html
	abbr_url:HTMLinteraction
site_nav:uievents,html
nav_prev:HTMLselectors
nav_next:HTMLdnd
trans_1st_pub:2016-11-06


●●class_map
e:element
a:attr
et:event-type
p:property
ps:pseudo
st:attr-state
aH:attr-state
css:css
v:value
E:error
h:header
M:method

●●tag_map
I:code
m:code
mE:code
pE:code
E:code
c:code
e:code
a:code
et:code
st:i
aH:span
h:code
M:code
p:code
ps:code
css:code
samp:samp
v:code
i:i
kbd:kbd
em:em

●●original_id_map


dom-document-designmode:designMode
	system-focus:tlbc-system-focus
	currently-focused-area-of-a-top-level-traversable:currently-focused-area-of-a-top-level-browsing-context
	current-focus-chain-of-a-top-level-traversable:current-focus-chain-of-a-top-level-browsing-context

●●mdn_urls
	elementcontenteditable:API/ElementContentEditable
	focusoptions:API/FocusOptions

the-accesskey-attribute:HTML/Global_attributes/accesskey
attr-enterkeyhint:HTML/Global_attributes/enterkeyhint
attr-hidden:HTML/Global_attributes/hidden
attr-contenteditable:HTML/Global_attributes/contenteditable
attr-autocapitalize:HTML/Global_attributes/autocapitalize
attr-fe-autofocus:HTML/Global_attributes/autofocus
attr-inputmode:HTML/Global_attributes/inputmode
attr-tabindex:HTML/Global_attributes/tabindex

●●link_map

E.SyntaxError:~WEBIDL#syntaxerror

I.ToggleEvent:#toggleevent
I.ToggleEventInit:#toggleeventinit
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.Document:~HTMLdom#document
I.DocumentOrShadowRoot:~HTMLdom#documentorshadowroot
I.ElementContentEditable:#elementcontenteditable
I.Element:~DOM4#interface-element
I.FocusEvent:~UIEVENTS#focusevent
I.Node:~DOM4#interface-node
I.Text:~DOM4#interface-text
I.Window:~WINDOW#window
I.Selection:~SELECTIONAPI#dom-selection
I.FocusOptions:#focusoptions
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.Navigator:~HTMLnavigator#navigator
I.UserActivation:#useractivation
I.VisibilityStateEntry:#visibilitystateentry
I.PerformanceEntry:~TIMELINE#dom-performanceentry

CEReactions:~HEcustom#cereactions


	■DOM
m.isTrusted:~DOM4#dom-event-istrusted
m.bubbles:~DOM4#dom-event-bubbles
m.type:~DOM4#dom-event-type

m.autofocus:#dom-fe-autofocus
m.accessKey:#dom-accesskey
m.accessKeyLabel:#dom-accesskeylabel
m.activeElement:#dom-documentorshadowroot-activeelement
m.autocapitalize:#dom-autocapitalize
m.blur:#dom-window-blur
mE.blur:#dom-blur
m.focus:#dom-window-focus
mE.focus:#dom-focus
m.enterKeyHint:#dom-enterkeyhint
m.click:#dom-click
m.contentEditable:#dom-contenteditable
m.hasFocus:#dom-document-hasfocus
m.hidden:#dom-document-hidden
mE.hidden:#dom-hidden
m.isContentEditable:#dom-iscontenteditable
m.inert:#dom-inert
m.inputMode:#dom-inputmode
m.newState:#dom-toggleevent-newstate
m.oldState:#dom-toggleevent-oldstate
m.preventScroll:#dom-focusoptions-preventscroll
m.focusVisible:#dom-focusoptions-focusvisible
m.visibilityState:#dom-document-visibilitystate

m.navigator:~HTMLnavigator#dom-window-navigator
m.userActivation:#dom-navigator-useractivation
m.hasBeenActive:#dom-useractivation-hasbeenactive
m.isActive:#dom-useractivation-isactive

m.name:#visibilitystateentry-name
m.entryType:#visibilitystateentry-entrytype
m.startTime:#visibilitystateentry-starttime
m.duration:#visibilitystateentry-duration

	m.execCommand:#execCommand
m.execCommand:~EXEC-COMMAND#execcommand%28%29
m.queryCommandEnabled:~EXEC-COMMAND#dom-document-querycommandenabled%28%29
m.queryCommandIndeterm:~EXEC-COMMAND#dom-document-querycommandindeterm%28%29
m.queryCommandState:~EXEC-COMMAND#dom-document-querycommandstate%28%29
m.queryCommandSupported:~EXEC-COMMAND#dom-document-querycommandsupported%28%29
m.queryCommandValue:~EXEC-COMMAND#dom-document-querycommandvalue%28%29

m.spellcheck:#dom-spellcheck
m.tabIndex:#dom-tabindex

m.relatedTarget:~UIEVENTS#dom-focusevent-relatedtarget
m.detail:~UIEVENTS#dom-uievent-detail
m.view:~UIEVENTS#dom-uievent-view
m.show:~HEinteractive#dom-dialog-show
m.showModal:~HEinteractive#dom-dialog-showmodal
m.designMode:#dom-document-designmode

m.pointerType:~POINTEREVENTS#dom-pointerevent-pointertype

	■css
p.outline:~CSSUI#propdef-outline
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.white-space:~CSSTEXT#propdef-white-space
p.pointer-events:~CSSUI#pointer-events-control
p.user-select:~CSSUI#content-selection
p.content-visibility:~CSSCONTAIN#propdef-content-visibility
p.display:~CSSDISP#propdef-display

	■e
e.a:~HEtextlevel#the-a-element

e.area:~HEimages#the-area-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.frame:~HTMLobs#frame

e.canvas:~HEcanvas#the-canvas-element

e.input:~HEinput#the-input-element
e.button:~HEforms#the-button-element
e.form:~HEforms#the-form-element
e.label:~HEforms#the-label-element
e.output:~HEforms#the-output-element
e.select:~HEforms#the-select-element
e.textarea:~HEforms#the-textarea-element

e.details:~HEinteractive#the-details-element
e.dialog:~HEinteractive#the-dialog-element
e.summary:~HEinteractive#the-summary-element

e.div:~HEgrouping#the-div-element
e.link:~HEmetadata#the-link-element
e.object:~HEembed#the-object-element
e.video:~HEmedia#the-video-element

e.slot:~HEscripting#the-slot-element

	e.a:~SVGlinking#elementdef-a


	■#attr-

a.accesskey:#the-accesskey-attribute
a.aria-describedby:~ARIA1#aria-describedby
a.autocapitalize:#attr-autocapitalize
a.autofocus:#attr-fe-autofocus
a.contenteditable:#attr-contenteditable
a.disabled:~HTMLforms#attr-fe-disabled
a.draggable:~HTMLdnd#attr-draggable
a.enterkeyhint:#attr-enterkeyhint
a.form:~HTMLforms#attr-fae-form
a.hidden:#attr-hidden
a.href:~HTMLlinks#attr-hyperlink-href
a.inert:#the-inert-attribute
a.inputmode:#attr-inputmode
a.open:~HEinteractive#attr-details-open
a.pattern:~HEinput#attr-input-pattern
a.readonly:~HEinput#attr-input-readonly
a.spellcheck:#attr-spellcheck
a.src:~HEimages#attr-img-src
a.tabindex:#attr-tabindex
a.title:~HTMLdom#attr-title
a.type:~HEinput#attr-input-type
a.~readonly0:~HEforms#attr-textarea-readonly

v.none:#attr-inputmode-keyword-none
v.text:#attr-inputmode-keyword-text
v.tel:#attr-inputmode-keyword-tel
v.url:#attr-inputmode-keyword-url
v.email:#attr-inputmode-keyword-email
v.numeric:#attr-inputmode-keyword-numeric
v.decimal:#attr-inputmode-keyword-decimal
v.search:#attr-inputmode-keyword-search

v.off:#attr-autocapitalize-off
v.~noneC:#attr-autocapitalize-none
v.on:#attr-autocapitalize-on
v.sentences:#attr-autocapitalize-sentences
v.words:#attr-autocapitalize-words
v.characters:#attr-autocapitalize-characters

v.enter:#attr-enterkeyhint-keyword-enter
v.done:#attr-enterkeyhint-keyword-done
v.go:#attr-enterkeyhint-keyword-go
v.next:#attr-enterkeyhint-keyword-next
v.previous:#attr-enterkeyhint-keyword-previous
v.~search0:#attr-enterkeyhint-keyword-search
v.send:#attr-enterkeyhint-keyword-send

v.until-found:#attr-hidden-until-found-keyword
v.hidden:#attr-hidden-hidden-keyword

	■event
et.beforematch:~HTMLindex#event-beforematch
et.blur:~HTMLindex#event-blur
et.change:~HTMLindex#event-change
et.focus:~HTMLindex#event-focus
et.click:~UIEVENTS#event-type-click
et.keydown:~UIEVENTS#event-type-keydown
et.mousedown:~UIEVENTS#event-type-mousedown
et.pointerup:~POINTEREVENTS#the-pointerup-event
et.pointerdown:~POINTEREVENTS#the-pointerdown-event
et.scroll:~CSSOMVIEW#eventdef-document-scroll
et.toggle:~HTMLindex#event-toggle
et.touchend:~TOUCHEVENTS#event-touchend
et.visibilitychange:~HTMLindex#event-visibilitychange

st.Email:~HEinput#email-state-(type=email)
st.Hidden:~HEinput#hidden-state-(type=hidden)
st.Number:~HEinput#number-state-(type=number)
st.Password:~HEinput#password-state-(type=password)
st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Tel:~HEinput#telephone-state-(type=tel)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Url:~HEinput#url-state-(type=url)

st.非可視でない:#attr-hidden-not-hidden-state
st.非可視:#attr-hidden-hidden-state
st.見出されるまでは非可視:#attr-hidden-until-found-state

aH.既定:#autocap-hint-default
aH.なし:#autocap-hint-none
aH.一文ごと:#autocap-hint-sentences
aH.単語ごと:#autocap-hint-words
aH.文字ごと:#autocap-hint-characters


cF.動作:~HEinteractive#command-facet-action
cF.不能化されるか:~HEinteractive#command-facet-disabledstate
cF.隠されるか:~HEinteractive#command-facet-hiddenstate
先祖~detailsを露呈する:~HEinteractive#ancestor-details-revealing-algorithm

ps.focus-visible:~SELECTORS4#focus-visible-pseudo

	●用語
要素:#_element

文書:~HTMLdom#the-document-object
~tabindex値:#tabindex-value

失効-:#activation-expiry
作動化を誘発する入力~event:#activation-triggering-input-event

利用者-作動化を消費-:#consume-user-activation
履歴~動作による作動化を消費-:#consume-history-action-user-activation

最後の作動化の時刻印:#last-activation-timestamp
最後の履歴~動作による作動化の時刻印:#last-history-action-activation-timestamp

非一過な作動化？:#sticky-activation
一過な作動化？:#transient-activation
履歴~動作による作動化？:#history-action-activation
一過な作動化の所要時間:#transient-activation-duration

作動化を通知する:#activation-notification
作動化を消費する:#activation-consuming-api
一過な作動化を消費する~API:#activation-consuming-api
履歴~動作による作動化を消費する~API:#history-action-activation-consuming-api
非一過な作動化で通過制御される~API:#sticky-activation-gated-api
一過な作動化で通過制御される~API:#transient-activation-gated-api
利用者-作動化で通過制御される~API:#user-activation-gated-apis
結付けられた~UserActivation:#associated-useractivation

アテガわれた~access~UIkey:#assigned-access-key
阻んでいる~modal~dialog:#blocked-by-a-modal-dialog

doc.可視性~状態:#visibility-state
可視性~状態を更新する:#update-the-visibility-state
~page可視性~変化-時の手続き:#page-visibility-change-steps
vsE.時刻印:#visibilitystateentry-timestamp
vsE.可視性~状態:#visibilitystateentry-state

~design~modeは可能化されるか:#design-mode-enabled
編集中の~host:#editing-host
編集-可能:~EXEC-COMMAND#editable
属する編集中の~host:~EXEC-COMMAND#editing-host-of
作動中な範囲:~EXEC-COMMAND#active-range
選択を削除-:~EXEC-COMMAND#delete-the-selection

~task:~WAPI#concept-task
~taskを~queueする:~WAPI#queue-a-task
~click~eventを発火する:~WAPI#fire-a-click-event
~focus~eventを発火する:#fire-a-focus-event
合成な~pointer~eventを発火する:~WAPI#fire-a-synthetic-pointer-event
関連な~realm:~WAPI#concept-relevant-realm
関連な大域~obj:~WAPI#concept-relevant-global
利用者~対話~task~source:~WAPI#user-interaction-task-source
大域~taskを~queueする:~WAPI#queue-a-global-task

~clickは進捗-中か:#click-in-progress-flag

~toggle~task追跡子:#toggle-task-tracker
tTk.~task:#toggle-task-task
tTk.旧-状態:#toggle-task-old-state

~DOM~anchor:#dom-anchor
~focus鎖:#focus-chain
~focusを獲得した:#gains-focus
~focusを得ている:#has-focus-steps
~focusされて:#focused

~focus可能な区画:#focusable-area
~focus可能な図形:#_focusable-shape

~focus可能:#focusable
逐次的に~focus可能:#sequentially-focusable
~clickで~focus可能:#click-focusable
~system~focus:#system-focus
利用者の注目:#user-attention
~top-level辿可能にて全部的に作動中かつ利用者の注目を得ている子孫:#fully-active-descendant-of-a-top-level-traversable-with-user-attention

tlT.現在の~focus鎖:#current-focus-chain-of-a-top-level-traversable
tlT.現在の被focus区画:#currently-focused-area-of-a-top-level-traversable

doc.指名する被focus区画:#focused-area-of-the-document

~focusを更新する:#focus-update-steps
~objを~unfocusする:#unfocusing-steps
~objを~focusする:#focusing-steps
~focus可能な区画を取得する:#get-the-focusable-area

自動focusは処理-済みか:#autofocus-processed-flag
自動focus候補~群:#autofocus-candidates
自動focus候補~群を洗出す:#flush-autofocus-candidates
自動focus委任-先:#autofocus-delegate
~focus委任-先:#focus-delegate

	:#bc-focus-ergo-bcc-focus

~home逐次的~focus~navi順序:#home-sequential-focus-navigation-order
~home文書:#home-document
相応しい逐次的に~focus可能な区画:#suitable-sequentially-focusable-area

~focus用に~lockされたか:#locked-for-focus
逐次的~focus~navi:#sequential-focus-navigation
逐次的~focus~navi順序:#sequential-focus-navigation-order
逐次的~focus~naviの始点:#sequential-focus-navigation-starting-point
	適切になるなら:#concept-platform-dropeffect-override
	concept-platform-dropeffect-override-

不活:#inert
既定の挙動:#concept-spellcheck-default
既定で継承する:#concept-spellcheck-default-inherit
既定で行う:#concept-spellcheck-default-true
既定で行わない:#concept-spellcheck-default-false

逐次的~navi探索~algo:#sequential-navigation-search-algorithm
~source~node:#source-node

~focus~navi視野:#focus-navigation-scope
~tabindex順な~focus~navi視野:#tabindex-ordered-focus-navigation-scope
平坦~化された~tabindex順な~focus~navi視野:#flattened-tabindex-ordered-focus-navigation-scope
結付けられた~focus~navi所有者:#associated-focus-navigation-owner
~focus~navi視野の所有者:#focus-navigation-scope-owner

自動頭字化~hint:#autocapitalization-hint
自前の自動頭字化~hint:#own-autocapitalization-hint
利用する自動頭字化~hint:#used-autocapitalization-hint
自動頭字化-を継承-:~HEforms#category-autocapitalize

自動focus根:#nearest-ancestor-autofocus-scoping-root-element


~find-in-page:#find-in-page-2
~find-in-page~UI:#find-in-page-interface
fiP.~query:#fip-query
fiP.合致-~list:#fip-matches
fiP.作動中な合致-:#fip-active-match
見出されるまでは非可視な先祖を露呈する:#ancestor-hidden-until-found-revealing-algorithm

	●用語（HTML
~HTML要素:~HTMLINFRA#html-elements
即時に:~HTMLINFRA#immediately
~live:~HTMLINFRA#live
文書の中へ挿入された:~HTMLINFRA#insert-an-element-into-a-document

反映する:~HTMLcdom#reflect
既定の値:~HTMLcdom#default-value
既知な値のみに制限され:~HTMLcdom#limited-to-only-known-values

列挙d属性:~HTMLcms#enumerated-attribute
真偽-属性:~HTMLcms#boolean-attribute
妥当でない値~用の既定の状態:~HTMLcms#invalid-value-default
欠落~値~用の既定の状態:~HTMLcms#missing-value-default
整数として構文解析する:~HTMLcms#rules-for-parsing-integers
~space等で分離された~token集合:~HTMLcms#set-of-space-separated-tokens
妥当な整数:~HTMLcms#valid-integer

~body要素:~HTMLdom#the-body-element-2

~navigable:~HTMLds#navigable
nav.親:~HTMLds#nav-parent
nav.作動中な文書:~HTMLds#nav-document
nav.作動中な~window:~HTMLds#nav-window
nav.~top-level辿可能:~HTMLds#nav-top
nav.容器:~HTMLds#nav-container
子~navigable:~HTMLds#child-navigable
~top-level辿可能:~HTMLds#top-level-traversable
辿可能な~navigable:~HTMLds#traversable-navigable
nav.~system可視性~状態:~HTMLds#system-visibility-state
先祖~navigable群:~HTMLds#ancestor-navigables
子孫~navigable群:~HTMLds#descendant-navigables
広義-先祖~navigable群:~HTMLds#inclusive-ancestor-navigables
広義-子孫~navigable群:~HTMLds#inclusive-descendant-navigables
~navigable容器:~HTMLds#navigable-container
内容~navigable:~HTMLds#content-navigable
~node~navigable:~HTMLds#node-navigable
全部的に作動中:~HTMLds#fully-active

閲覧~文脈:~HTMLds#browsing-context
属する閲覧~文脈:~HTMLds#concept-document-bc
bc.作動中な~window:~HTMLds#active-window

対応する~navigable:~WINDOW#window-navigable
~navi~API:~HTMLnavAPI#window-navigation-api
進行中な~naviの間に~focusは変化したか:~HTMLnavAPI#focus-changed-during-ongoing-navigation

~target要素:~HTMLnav#target-element
素片へ~navigateする:~HTMLnav#navigate-fragid

作動中な~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
閲覧~文脈~sandbox化( 自動的な特能 )~flag:~ORIGIN#sandboxed-automatic-features-browsing-context-flag
同一-生成元:~ORIGIN#same-origin

不能化されて:~HTMLforms#concept-fe-disabled
変異-可能:~HTMLforms#concept-fe-mutable
fe.値:~HTMLforms#concept-fe-value
~form所有者:~HTMLforms#form-owner

入力~eventを発火する:~HEinput#_fire-input-event
選択された~file~list:~HEinput#concept-input-type-file-selected
	~HEtextlevel#the-a-element
	~HEinput#number-state-(type=number)
	~HEinput#range-state-(type=range)
	~HEinput#text-(type=text)-state-and-search-state-(type=search)
	適用される:~HEinput#concept-input-apply

~commandを定義する:~HEinteractive#concept-command
親~details用の~summary:~HEinteractive#summary-for-its-parent-details

i.示している:~HTMLpopover#popover-showing-state
elm.~popover呼出元:~HTMLpopover#popover-invoker
a.popover:~HTMLpopover#attr-popover
~popover要素:~HTMLpopover#_popover-element
	st.~popoverなし:~HTMLpopover#attr-popover-none-state
~popover可視性~状態:~HTMLpopover#popover-visibility-state

実際に不能化-:~HTMLselectors#concept-element-disabled
~UI内に公開されている~control:~HEmedia#expose-a-user-interface-to-the-user
~scriptを阻んでいる~stylesheet集合:~HEmetadata#script-blocking-style-sheet-set
具現化され:~HTMLrendering#being-rendered
具現化されて:~HTMLrendering#being-rendered
~hyperlink:~HTMLlinks#hyperlink
画像~map:~HEimages#image-map

	●用語（外部
新たな:~WEBIDLjs#new

実装定義:~INFRA#implementation-defined

~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII空白:~INFRA#ascii-whitespace
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
~list:~INFRA#list
空:~INFRA#list-is-empty
除去する:~INFRA#list-remove
付加する:~INFRA#list-append
空にする:~INFRA#list-empty
~cloneする:~INFRA#list-clone
拡張する:~INFRA#list-extend
構造体:~INFRA#struct

表示域:~CSS2J#viewport
~box~tree:~CSSDISP#box-tree
~CSS~box:~CSSDISP#box
~viewの中へ~scrollする:~CSSOMVIEW#scroll-a-target-into-view
平坦~tree:~CSSSCOPING#flat-tree

~focusを指示する:~SELECTORS4#indicate-focus

~node文書:~DOM4#concept-node-document
~tree順序:~DOM4#concept-tree-order
子:~DOM4#concept-tree-child
子孫:~DOM4#concept-tree-descendant
~node~tree:~DOM4#concept-node-tree
根:~DOM4#concept-tree-root
文書~内にある:~DOM4#in-a-document
文書~要素:~DOM4#document-element
親~要素:~DOM4#parent-element
~eventを配送する:~DOM4#concept-event-dispatch
~eventを発火する:~DOM4#concept-event-fire
作動化の挙動:~DOM4#eventtarget-activation-behavior
接続されて:~DOM4#connected
~host:~DOM4#concept-documentfragment-host
~shadow根:~DOM4#concept-shadow-root
~shadowも含めた子孫:~DOM4#concept-shadow-including-descendant
~shadowも含めた~tree順序:~DOM4#concept-shadow-including-tree-order
~shadowも含めた広義-先祖:~DOM4#concept-shadow-including-inclusive-ancestor
~shadow~host:~DOM4#element-shadow-host
elm.~shadow根:~DOM4#concept-element-shadow-root
sR.~focusを委任するか:~DOM4#shadowroot-delegates-focus
割当-先~slot:~DOM4#slotable-assigned-slot
ev.~composedか:~DOM4#composed-flag
~targetし直す:~DOM4#retarget
doc.生成元:~DOM4#concept-document-origin

現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time
処理能~entryを~queueする:~TIMELINE#queue-a-performanceentry

上端~層:~CSSPOS4#document-top-layer

~screen方位~変更~手続き:~SCREEN-ORIENTATION#dfn-screen-orientation-change-steps

~URL:~URL1#concept-url

飛ばされた内容:~CSSCONTAIN#skips-its-contents
内容は飛ばされ:~CSSCONTAIN#skips-its-contents
~layout封込め:~CSSCONTAIN#layout-containment
選択:~SELECTIONAPI#dfn-selection

拡張~command:~WEBDRIVER#dfn-extension-commands
~remote端~手続き:~WEBDRIVER#dfn-remote-end-steps
現在の閲覧~文脈:~WEBDRIVER#dfn-current-browsing-context
成功:~WEBDRIVER#dfn-success


●●words_table1

TOUCHEVENTS:touch-events-ja.html
WEBDRIVER:https://w3c.github.io/webdriver/

readonly0:readonly
noneC:none
search0:search
svg-a:a

●●words_table

	●focus／dialog
順な:ordered:順による
	逐次的~focus~navi順序
	~focus~navi序列
blur:
	~focus可能:focusable
	~focus不能:non-focusable
	~focus時の:focusing
	~focus能:focusability
被focus:focused::被 focus:被フォーカス
自動focus:autofocus::自動 focus:自動フォーカス
unfocus::::未フォーカスに
	~unfocus時の:unfocusing

指名-:designate::~
届けら:routeさ::~
届ける:routeする::~
	経由-:channeled
	から経由され:channeled form
	委任-先:delegate
	委任-先~list:delegates

獲得した:gainした::得た
獲得しよ:gainしよ::得よ

tabindex:
図形:shape::~
	到達-可能でない:unreachable

前方:forward::~
後方:backward::~
不活:inert::~
	不活 性:inertness
環:ring::~
逐次的:sequential::~
鎖:chain::~
隠す:hideする::~
隠-:hide::~

操作o:operation:操作
操作不能:inoperable:~
代役:placeholder:~
候補:candidate:~
選定法:selection mechanism:~
始点:starting point:~
scrolling::::スクロール
home:
誘発元:trigger:~
注目:attention:~

	進捗-中:in progress
	ただちに:as soon as


	●編集
綴り:spelling:~
	綴りが誤っている:misspelt
検査ng:checking:検査
編集:editing::~
編集-:edit::~
編集中の:editing::~
	編集-不能:non-editable
折返す:wrapする::折り返す
折返され:wrapされ::折り返され
折返ng:wrapping::折り返し
境界点:boundary point::~
選択-:select:~

選択:selection:~
字下げ:indentation:~
一文:sentence:文
自然言語:language:~
誤り:error::~::エラー
訂正:correction:~
	不向き: not well suited

	●UI／呈示
	tab化された:tabbed
	^en:tabbing
	UI:interface／user interface
design:
kiosk:
bar::::バー
panel::::パネル
popup::::
bullet::::ビュレット
drag::::ドラッグ
drop::::ドロップ
toggle::::トグル
開な:openな:開いた
閉な:closedな:閉じた

find-in-page::::ページ内検索
popover:
下位widget:subwidget::下位 widget:下位ウィジェット
full::::フル
pointing::::ポインタ指示
十key:numeric keypad:::テンキーの類
修飾:modifier:~
呼出元:invoker:呼び出し元
声:voice:~
押下げた:pressした:~
click:
外形線:outline:~
美観:aesthetics:~
欄:field::~::フィールド
	合致するものを探索-:searching for matches
振動-:vibrate::~
示され:showされ:~
示して:showして:~
示す:showする:~

alphabetic-mnemonic:alphabetic mnemonic::alphabetic 符号:アルファベット符号
電話番号:telephone number:~
email::::メール
手早く:quickに:~
書式:format::~
locale::::ロケール
virtual-keyboard:virtual keyboard:::ソフトウェアキーボード
	~keyboardのみの:keyboard-only
	小数を含む:fractional
数的:numeric:~
	数:numeric
	PIN

自動頭字化-:autocapitalize::~
自動頭字化:autocapitalization::~
字l:letter::字°
頭字化:capitalize::~
頭字:capital letter::~
	頭字に:to a capital letter
voice:::声::ボイス
打込む:typeする:打ち込む:::タイプする
打込まれ:typeされ:打ち込まれ:::タイプされ
打込みそ:typeしそ:打ち込みそ
打込み:typing:打ち込み:::タイピング
打込んで:typeして:打ち込んで:::タイプして
打込んだ:typeした:打ち込んだ:::タイプした
組成-:compose::~
	助けに:helpful
改行:new line:~
	`Enter^Key ~UIkey:enter key
cue:
IME:input method editor:IME

能動的:active::~
知覚-:perceive:~
一過:transient::~
非一過:sticky::~
近過去:recent:~
経過-:elapse:~
失効:expiry:~
失効-:expire:~

閉じら:closeさ:~
開く:openする:~
強調-:highlight:~
退けら:dismissさ:~
	退けられた時点:upon dismissal
露呈-:reveal:露わに
展開-:expand:~
検索語:search term::~
切替器:switcher:~
最小化-:minimize:~
遮って:obscureして:~
遮られ:obscureされ:~
遮る:obscureする:~
拡大鏡:magnifier:~
接触判定:hit-testing::~
持続的:persistent::~
封込め:containment::封じ込め
非可視:hidden:~
UserActivation:
後景:backdrop::~
上層:overlay::~::オーバーレイ
	上層を成す:overlaid／:overlaid
生の:raw:~
rich:
	形式~化:formatting
shortcut::::ショートカット
洗出す:flushする:洗い出す
履歴上の:historicalな:~
経路:path::~
off-screen::::オフスクリーン
	開閉すること:to be opened or closed
塗り:paint:~
間引かせ:throttleさせ:~
間引き:throttling:~
活動:activity:~
	活動が無い:inactivity

	ヤリトリ-可能:interactive
	長く:long
	長くとも:at most
	数秒:a few seconds
	導く:take 〜 to
	煩わしい:annoying
	受けた:get／:got
	使い勝手:usability
	使い勝手がすこぶる悪く:significantly less usable
	使い勝手は悪くなる:become unusable
	押すこと:pressing
	最後の（最も手前に~~示される）:topmost
	次へ進める:advance
	間を~~空け:separated by a gap
	ごく狭い:tiny
	~~背後に:background
	いらつかせる:get frustrated
	指示するもの:indication
	見えてない:not be able to see
	^Key:Control
	^Key:Escape
	^Key:Shift
	WYSIWYG
	長期間:long period
	になって以降:from the moment
	失う:lose
	失った:lose
	失われ:lose
	〜が~focusを得るに伴い失われる:lost to
	失って:lost

	●構文

	-:literal
縮約-:collapse:~
普通字:letter:~
頭部の:leading:~

	●内容／DOM
body:
details:
summary:
	後続-:
	子たち:children
広義-:inclusive:~
割当-:assign::あてがい
	割当-先:assigned 先
アテガイ:assign 法::あてがい方
一節:section:~
見出し:heading::~

	●処理
旧-:old:~
新-:new:~
追跡子:tracker::~::トラッカー

	%取扱えるか:canHandle
	%文書:target
	%文書:d
	%~top文書:topDocument
	%文書:doc
	-:inclusiveAncestorDocuments
	%~focus誘発元:focus trigger
	%~target:focus target
	%~target:new focus target
	%~target:focusTarget
	%自動focus委任-先:autofocusDelegate
	%~focus可能な区画:focusableArea
	%~focus可能な区画:focusable area
	%~~注目先:whereToLook
	%~target:parent
	%親:-
	%子孫:descendant
	%新たな状態:newState
	%新-鎖:new chain
	%可視性~状態:visibilityState
	%現在の~node:currentNode
	%~focusを指示するか:-
	%被focus要素
	%先祖~navigable:ancestorNavigable
	%~navigable群:navigables
	%~navigable:navigable
	%~window:W
	%~window群:windows
	%消費するか:consume

	●保安
通過制御-:gate::~
濫用-:abuse:~
悪用-:exploit:~

	●仕様
素早く:quickに:~
	-:non-normative
正当:legitimate:~
略式的:skeletal:~
文脈的な:contextual::~
遺物:artifact:~
選択的:selective:~
支援-:assist:~
支援技術:assistive technologies:~
介入-:intervene:~
構成-:compose:~
網羅的:exhaustive:~
用心深く:deliberateに:~
類別-:classify:~
複雑:complicated:~
規定-:dictate:~
満足-:satisfy:~
明白:obvious:~
連関:link:~
	同様に:similar fashion
逃れる:escapeする:~
維持-:retain:~
critical:
変種:variant:~

	なり得る:possible
	きれいに:neatly
	きわどい:corner
	それに代わる:in its stead
	ないがしろに:detriment
	に過ぎない:merely
	も:opt to
	何らかの方法:somehow
	何らかの類の:some sort of
	普及している:prevalent:
	〜の違いを除いて:modulo
	申し分ない:fine
	可能性が高い:likely
	多様な:wide variety of
	様々な:variety
	-:in fact
	それに伴い:thereby
	現時点で最良:currently-best
	対照的に:in contrast
	~~直に:immediately

	custom化:customizable
	-:abstract concept
	ある:particular
	易くする:help
	概ね、:roughly speaking
	正当化される:well justify
	呼応:in response to
	できる:capable of
	満たす:meet
	も併用することなく:as opposed to
	-:aforementioned
	下層を〜成す:underlie
	cause:結果〜ことになる
	変わらない:stay
	~CSSも~supportする:HTML+CSS
	留意すること:worth remembering
	挙げる点:two caveats
	変化しない:original 〜 remains unchanged
	〜かどうか:status
	に注意:notice
	~~現在:presently
	~~明らか:apparent
	~~注目-:looking at
	難しくなる:harder

	●未分類
広義-:inclusive:~
trust:
	~trustされない:not trusted
composed:
commit:
game::::ゲーム
log-in:log in:::ログイン
main::::メイン
macOS:
逆順:reverse order:~
携帯:mobile::~::モバイル
電話:phone:~
非対称:asymmetry:~
深い:deepな:~
	最も深い:deepest
高分解能:high resolution::~
消費:consumption::~
再帰-:recurse::~

代用:substitute:~
合成な:syntheticな:~
告知-:advertise:~
保つ:keepする:~
	なくなった:stop
切替える:switchする:切り替える
所在-:locate::~
増分的:incremental:~
族:family::~
screenshot::::スクリーンショット
現在に:currently:現在
一様:uniform:~
top::::トップ
端:end:~
template:
URI:
相関:correlation:~
隠蔽-:shadow:~

	遡り続け:continues up 〜 up to
	素な~textのみ:plaintext-only
	この属性の状態:kind of editable (or not editable)
	合致-~list:matches
	designated focused
	-:header
	~text片:piece of text
	-:time
	-:argument
	-:required
	-:relative
	~~記事:article
	数:number
	小さい／小さな:small
	定数:constant number

	投稿-:publish
	未設定:unset
	外された:omitted
	戻せるように:allow 〜 toggle it back
	したい:want
	始-:begin
	伝える:tell／:inform
	~~由来する:comes from
	~~検索
	~~生成
	~~要請
	~~連続する:adjacent
	〜されない:opposed
	選び取る:pick
	選んだ:choosing
	選ぶ:choose
	-:exception
	-:setting
	-:map
	-:place
	属する:belong
	実際に不能化-:disable
	起こる時点は、いくつかあり得る:can happen at different times
	語全体:whole words
	各~合致を:through
	し始める:begin
	し終えた:finish
	他へ~navigate:navigating away
	に基づくか:base 〜 off
	またがる:span
	直の:immediate
	先ず:first place
	などなど:and so forth
	-:second／third
	以前の:previous
	次の:next
	前の:previous
	-:originally
	先ず:first
	次:next
	一つに:together
	一回の:single
	一回の:per
	一回以上は:at least once
	初めて:very first
	一部に限られる:subset of those
	何度も続けて:too frequently
	何度も続けて:multiple times in a row
	~~後方へ:back
	一方
	一種
	一連
	一部
	一部分:part of
	一体としての:whole
	上述
	以上
	以下
	以前
	以外
	以降
	任意
	個
	個数
	全体
	各種
	場合
	前後の:next or previous
	前述
	〜単独:alone
	〜しか:just
	右列:cells in the right column
	左列:The cells in the left column
	左右列にまたがるセル:cells that span both columns
	直前
	直前に:just
	直後
	自身
	新
	旧
	その検査／:spellchecking
	とする／:suppose
	またがる:span
	利用-中に:being used
	つつある:about to be
	いかなる類の:any sort of
	次回:next time
	次回:next
	次に:next
	高い〜ほど:higher
	ほとんど:mostly
	所与の時点:at any particular time
	在るならば:by its presence
	Population by City
	“読込n中…”:"loading"
	~targetにされ:targeted at

	●他の語
	-:facet
	-:in place for
	-:in the middle
	-:lack thereof
	ARIA
	Alt
	C:
	CSS
	Emacs
	Mac
	Windows
	aforementioned
	amongst
	aware
	became
	become
	care
	caused
	cell
	column
	committing
	consist
	earlier:#1
	equipped
	express
	finally
	follow
	home
	instruction
	lack
	later
	lead
	left
	mac
	made
	marked
	matching
	moving
	opted
	in-
	middle
	point
	pre-order
	put
	redo
	reduce
	referenced
	rerouting
	right
	row
	said
	sometime
	spin-control
	sure
	thereof
	top
	toward
	unable
	unadorned
	unmark
	unset
	vision
	その場で:on-demand
	セル
	一枚の大きな:one big
	者:people
	分断不可:non-breaking
	前順, 深さ優先:pre-order, depth-first
	だけで:simply
	参照
	参照元:
	同時:
	同等に:equally
	名称:
	増減:button:up and down buttons in a spin-control version

	対応
	必ず:make sure
	指-:refer
	指す~refer
	新着:New
	方法
	昇順に整列
	時点
	普通の:regular
	条件:conditions
	注意:
	注記
	用途
	留意
	省略時
	組み合わせ:mix
	複数:
	該当:
	詳細:
	黄色:yellow

	無条件
	無用に煩雑
	現時点

●●html_code_list
■inert-1
<section aria-labelledby=s1>
  <h3 id=s1>Population by City</h3>
  <div class=container>
    <div class=loading><p>Loading...</p></div>
    <div inert>
      <form>
        <fieldset>
          <legend>Date range</legend>
          <div>
            <label for=start>Start</label>
            <input type=date id=start>
          </div>
          <div>
            <label for=end>End</label>
            <input type=date id=end>
          </div>
          <div>
            <button>Apply</button>
          </div>
        </fieldset>
      </form>
      <table>
        <caption>From 20-- to 20--</caption>
        <thead>
          <tr>
            <th>City</th>
            <th>State</th>
            <th>20-- Population</th>
            <th>20-- Population</th>
            <th>Percentage change</th>
          </tr>
        </thead>
        <tbody>
          <!-- ... -->
        </tbody>
      </table>
    </div>
  </div>
</section>

都市人口
読み込み中…
データ範囲
開始年
終了年
適用
20XX年から 20XX年まで
都市
州
20XX年の人口
20XX年の人口
変化率（百分率）

■data-model-1
<map id=wallmap><area alt="入り口ドア" coords="10,10,100,200" href="door.html"></map>
...
<img src="images/innerwall.jpeg" alt="ドア付きの白い壁がここにある" usemap="#wallmap">
...
<img src="images/outerwall.jpeg" alt="ドア付きの赤い壁がここにある" usemap="#wallmap">

alt="Enter Door"
...
alt="There is a white wall here, with a door."
...
alt="There is a red wall here, with a door."


■autofocus-1
<input maxlength="256" name="q" value="" ＜autofocus＞>
<input type="submit" value="Search">

■autofocus-2
<div contenteditable ＜autofocus＞>Edit <strong>me!</strong><div>

■intro9-1
<input type=button value=Collect onclick="collect()"
       ＜accesskey="C 1"＞ id=c>

■accesskey-1
<nav>
 <p>
  <a
    title="Consortium Activities"
    ＜accesskey="A"＞
    href="/Consortium/activities"
  >Activities</a> |
  <a
    title="Technical Reports and Recommendations"
    ＜accesskey="T"＞
    href="/TR/"
  >Technical Reports</a> |
  <a
    title="Alphabetical Site Index"
    ＜accesskey="S"＞
    href="/Consortium/siteindex"
  >Site Index</a> |
  <a
    title="About This Site"
    ＜accesskey="B"＞
    href="/Consortium/"
  >About Consortium</a> |
  <a
    title="Contact Consortium"
    ＜accesskey="C"＞
    href="/Consortium/contact"
  >Contact</a>
 </p>
</nav>

<nav>
 <p>
  <a title="Consortium Activities" accesskey="A" href="/Consortium/activities">Activities</a> |
  <a title="Technical Reports and Recommendations" accesskey="T" href="/TR/">Technical Reports</a> |
  <a title="Alphabetical Site Index" accesskey="S" href="/Consortium/siteindex">Site Index</a> |
  <a title="About This Site" accesskey="B" href="/Consortium/">About Consortium</a> |
  <a title="Contact Consortium" accesskey="C" href="/Consortium/contact">Contact</a>
 </p>
</nav>

■accesskey-2
<form action="/search">
 <label>Search: <input type="search" name="q" ＜accesskey="s 0"＞></label>
 <input type="submit">
</form>

■contenteditable-1
<form method=POST>
 <fieldset>
  <legend>新着記事</legend>
  <textarea name=article>&lt;p>こんにちは&lt;/p></textarea>
 </fieldset>
 <p><button>投稿</button></p>
</form>

<form method=POST>
 <fieldset>
  <legend>New article</legend>
  <textarea name=article>&lt;p>Hello world.&lt;/p></textarea>
 </fieldset>
 <p><button>Publish</button></p>
</form>

■contenteditable-2
<form method=POST>
 <fieldset>
  <legend>新着記事</legend>
  <textarea id=textarea name=article>&lt;p>こんにちは&lt;/p></textarea>
＜  <div id=div style="white-space: pre-wrap" hidden><p>こんにちは</p></div>
  <％script>
   let %textarea = document.getElementById("textarea");
   let %div = document.getElementById("div");
   %textarea.hidden = true;
   %div.hidden = false;
   %div.contentEditable = "true";
   %div.oninput = (%e) => {
     %textarea.value = %div.innerHTML;
   };
  </％script>＞
 </fieldset>
 <p><button>投稿</button></p>
</form>

■contenteditable-3
<!doctype html>
<html lang=en>
<title>Live CSS editing!</title>
<style style=white-space:pre contenteditable>
html { margin:.2em; font-size:2em; color:lime; background:purple }
head, title, style { display:block }
body { display:none }
</style>

■spelling-1
<div contenteditable="true">
 <span spellcheck="false" id="a">Hell</span><em>o!</em>
</div>

■spelling-2 bad
<p spellcheck="true">
 <label>Name: <input spellcheck=" false" id="b"></label>
</p>

●●images
＠HTML-resources/
inert-example-loading-section｜height:243px;｜｜.png
focus-tree｜height:450px;｜｜.png

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ User interaction</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>
</head>
<body>

<header>
	<hgroup>
<h1>HTML — 利用者対話</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="editing">
<h2 title="User interaction">6. 利用者~対話</h2>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

<p>
用語
`要素@
は、
`Element$I ~objの略記として用いられる。
</p>

		</section>
		<section id="the-hidden-attribute">
<h3 title="The hidden attribute">6.1. `hidden^a 属性</h3>

<p>
`hidden@a
内容~属性は、
どの`~HTML要素$に設定してもヨイ。
この属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
All HTML elements may have the hidden content attribute set. The hidden attribute is an enumerated attribute. The following table lists the states for this attribute:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態
<tbody>

<tr><td>`until-found@v
<td>`見出されるまでは非可視$st

<tr><td>空~文字列
<td>`非可視$st

<tr><td>`hidden@v
<td>`非可視$st

<tr><td>
<td>`非可視でない$st
</table>
◎
State｜Keywords
Until found state｜until-found
Hidden state｜The empty string
｜hidden
</div>

<p>
この属性は、
省略してもヨイ。
`妥当でない値~用の既定の状態$は、
`非可視$stとする。
`欠落~値~用の既定の状態$は、
`非可視でない$stとする。
◎
The attribute may be omitted. The invalid value default is the hidden state. The missing value default is the not hidden state.
</p>

<p>
上に挙げた各~状態は、
次を指示する：
◎
↓</p>
<dl>
	<dt>
`非可視でない@st
</dt>
	<dd>
利用者は，常に、
当の要素に直に~accessできる。
【この項は、この訳による補完。】
</dd>
	<dt>
`非可視@st
◎
When an element has the hidden attribute in the hidden state, it indicates that＼
</dt>
	<dd>
当の要素は、
利用者からは直に~accessできない
— すなわち、次のいずれか
⇒＃
まだ, あるいは設定して以降、~pageの現在の状態に直には関連しない／
~pageの他の部分に再利用される内容を宣言するために利用されている
◎
the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user.＼
</dd>
	<dd>
~UAは、
この状態にある要素を具現化するベキでない。
この要件は、
~style層を通して間接的に実装してもヨイ。
例えば，~UAは、
これらの要件を
`§ 具現化にて示唆されている規則＠~HTMLrendering#hiddenCSS$を利用して実装することもできる。
◎
User agents should not render elements that are in the hidden state. This requirement may be implemented indirectly through the style layer. For example, a web browser could implement these requirements using the rules suggested in the Rendering section.
</dd>

	<dt>
`見出されるまでは非可視@st
◎
When an element has the hidden attribute in the hidden until found state, it indicates that＼
</dt>
	<dd>
当の要素は`非可視$stのときと同様に非可視になるが、
その内容は［
`~find-in-page$／`素片へ~navigateする$こと
］により~access可能になる。
◎
the element is hidden like the hidden state but the content inside the element will be accessible to find-in-page and fragment navigation.＼
</dd>
	<dd>
これらの特能が，当の要素の下位tree内にある~targetへ~scrollしようと試みたときは、
~UAは，そこへ~scrollする前に［
当の要素に向けて名前 `beforematch$et の~eventも発火して
］から［
要素の内容を露呈するよう `hidden$a 属性を除去する
］ことになる。
◎
When these features attempt to scroll to a target which is in the element's subtree, the user agent will remove the hidden attribute in order to reveal the content before scrolling to it. In addition to removing the hidden attribute, an event named beforematch is also fired on the element before the hidden attribute is removed.
</dd>
</dl>

<p>
~web~browserは、
`hidden$a 属性の状態が`見出されるまでは非可視$stのときは
— `§ 具現化＠~HTMLrendering#hiddenCSS$にて指定されるとおり —
<code class="css">`display$p: `none^v</code>
に代えて
<code class="css">`content-visibility$p: `hidden^v</code>
を利用することになる。
◎
Web browsers will use 'content-visibility: hidden' instead of 'display: none' when the hidden attribute is in the hidden until found state, as specified in the Rendering section.
</p>

<div class="note">
<p>注記：
この属性は、
概して~CSSを利用して実装されるので，
~CSSを利用して上書きすることもアリである。
一例として、
すべての要素に
<code class="css">`display^p: `block^v</code>
を適用する規則は，
`非可視$st 状態の効果を取消すことになる。
したがって、
~stylesheetを書く作者は，［
この属性を有する要素に依然として期待されるとおり~styleされる
］よう注意する必要がある。
加えて、［
`見出されるまでは非可視$st 状態を~supportしない旧来の~UA
］では，［
<code class="css">`content-visibility^p: `hidden^v</code>
にされない代わりに
<code class="css">`display^p: `none^v</code>
になる
］ので、
作者は，
自身の~stylesheetにおいて`見出されるまでは非可視$st 状態にある要素の［
`display$p, `content-visibility$p
］~propが変化しないようにすることが奨励される。
◎
Because this attribute is typically implemented using CSS, it's also possible to override it using CSS. For instance, a rule that applies 'display: block' to all elements will cancel the effects of the hidden state. Authors therefore have to take care when writing their style sheets to make sure that the attribute is still styled as expected. In addition, legacy user agents which don't support the hidden until found state will have 'display: none' instead of 'content-visibility: hidden', so authors are encouraged to make sure that their style sheets don't change the 'display' or 'content-visibility' properties of hidden until found elements.
</p>

<p>
要素の `hidden$a 属性の状態が `見出されるまでは非可視$st のときは，
<code class="css">`display^p: `none^v</code>
に代えて
<code class="css">`content-visibility^p: `hidden^v</code>
が利用されるので、
そのような要素は，次に挙げる点で `非可視$st 状態にあるものと異なる：
◎
Since elements with the hidden attribute in the hidden until found state use 'content-visibility: hidden' instead of 'display: none', there are two caveats of the hidden until found state that make it different from the hidden state:
</p>
<ul>
	<li>
要素が`~find-in-page$により露呈されるためには、
`~layout封込め$に影響される必要がある。
したがって、
要素の `display$p 値が［
`none^v ／ `contents^v ／ `inline^v
］にされた場合，
要素は`~find-in-page$により露呈されなくなる。
◎
The element needs to be affected by layout containment in order to be revealed by find-in-page. This means that if the element in the hidden until found state has a 'display' value of 'none', 'contents', or 'inline', then the element will not be revealed by find-in-page.
</li>
	<li>
要素は、
依然として，`~boxを生成する＠~CSSDISP#propdef-visibility$
— すなわち、
要素の周りには［
~border, ~margin, ~padding
］が描画される。
◎
The element will still have a generated box when in the hidden until found state, which means that borders, margin, and padding will still be rendered around the element.
</li>
</ul>
</div>

<div class="example">
<p>
次の略式的な例では、［
利用者が~log-inするまで，~web~gameの~main~screenを隠す
］ために，この属性が利用されている：
◎
In the following skeletal example, the attribute is used to hide the web game's main screen until the user logs in:
</p>

<pre class="lang-html">
&lt;h1&gt;The Example Game&lt;/h1&gt;
&lt;section id="login"&gt;
 &lt;h2&gt;Login&lt;/h2&gt;
 &lt;form&gt;
  ...
  &lt;!-- 利用者~資格を検査したなら， login() を~callする --&gt;
 &lt;/form&gt;
 &lt;script&gt;
  function login() {
    // ~screenを切り替える
    document.getElementById('login').hidden = true;
    document.getElementById('game').hidden = false;
  }
 &lt;/script&gt;
&lt;/section&gt;
&lt;section id="game" hidden&gt;
 ...
&lt;/section&gt;
</pre>
</div>

<!-- 
The Example Game
Login

calls login() once the user's credentials have been checked

// switch screens
-->
<p>
`hidden$a 属性は、［
他の呈示では正当に示され得るような内容に対し，それを隠す用途
］には，利用してはナラナイ。
例えば、［
~UItab化された~dialog内の~panelを隠す用途
］に `hidden$a を利用することは，不正である
— ~UItab化された~interfaceは，~overflow呈示の一種に過ぎず、
単に［
~scrollbarを伴う大きな~pageに すべての~form~controlを示すこと
］に同等なので。
類似に，この属性を［
ある呈示に限って内容を隠す用途
］に利用することは、
不正である
— `hidden$a 属性を有するものは、
~screen読取器も含め，すべての呈示から隠される。
◎
The hidden attribute must not be used to hide content that could legitimately be shown in another presentation. For example, it is incorrect to use hidden to hide panels in a tabbed dialog, because the tabbed interface is merely a kind of overflow presentation — one could equally well just show all the form controls in one big page with a scrollbar. It is similarly incorrect to use this attribute to hide content just from one presentation — if something is marked hidden, it is hidden from all presentations, including, for instance, screen readers.
</p>

<p>
`hidden$a 属性を有さない要素から，
`hidden$a 属性を有する要素へ`~hyperlink$してはナラナイ。
類似に，
`hidden$a 属性を有さない［
`label$e ／ `output$e
］要素の `for^a 属性は、
`hidden$a 属性を有する要素を指してはナラナイ。
いずれの参照も，利用者を惑わすことになるので。
◎
Elements that are not themselves hidden must not hyperlink to elements that are hidden. The for attributes of label and output elements that are not themselves hidden must similarly not refer to elements that are hidden. In both cases, such references would cause user confusion.
</p>

<p>
しかしながら，他の文脈においては、
要素や~scriptが `hidden$a 属性を有する要素を指すこともある。
◎
Elements and scripts may, however, refer to elements that are hidden in other contexts.
</p>

<div class="example">
<p>
例えば、［
`href$a 属性の~link先に `hidden$a 属性を有する一節をアテガう
］のは，不正になる。
当の内容が［
適用-可能でない／関連しない
］ならば、
そこへ~linkする理由はない。
◎
For example, it would be incorrect to use the href attribute to link to a section marked with the hidden attribute. If the content is not applicable or relevant, then there is no reason to link to it.
</p>

<p>
しかしながら、［
ARIA `aria-describedby$a 属性を利用して `hidden$a 属性を有する記述を指す
］ことは，申し分ない。
記述を隠すことは，それ~~単独では有用でないことを含意するが、［
ある要素についての記述を，その要素から参照する
］ような［
特定の文脈において有用になるよう書く
］ことはできるので。
◎
It would be fine, however, to use the ARIA aria-describedby attribute to refer to descriptions that are themselves hidden. While hiding the descriptions implies that they are not useful alone, they could be written in such a way that they are useful in the specific context of being referenced from the elements that they describe.
</p>

<p>
類似に、
`hidden$a 属性を有する `canvas$e 要素は，［
~scriptによる~graphic~engineにより，~off-screen~bufferとして利用される
］こともあり、
~form~controlの `form$a 属性は，
`hidden$a 属性を有する `form$e 要素を指すこともある。
◎
Similarly, a canvas element with the hidden attribute could be used by a scripted graphics engine as an off-screen buffer, and a form control could refer to a hidden form element using its form attribute.
</p>
</div>

<p>
`hidden$a 属性を有する一節~内の要素であっても、
依然として作動中であり続ける
— 例えば，そのような一節~内の［
~script／~form~control
］は、
依然として［
実行される／提出される
］。
変化するのは、
利用者~向けの呈示に限られる。
◎
Elements in a section hidden by the hidden attribute are still active, e.g. scripts and form controls in such sections still execute and submit respectively. Only their presentation to the user changes.
</p>

<div class="algo">
<p>
`hidden@mE
取得子~手続きは：
◎
The hidden getter steps are:
</p>
<ol>
	<li>
~IF［
コレの `hidden$a 属性の状態 ~EQ `見出されるまでは非可視$st
］
⇒
~RET "`until-found$v"
◎
If the hidden attribute is in the until-found state, then return "until-found".
</li>
	<li>
~IF［
コレは `hidden$a 属性を有する
］
⇒
~RET ~T
◎
If the hidden attribute is set, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`hidden$mE 設定子~手続きは、
所与の値に応じて：
◎
The hidden setter steps are:
</p>
<ol>
	<li>
~IF［
所与の値は、
`~ASCII大小無視$で "`until-found$v" に合致する文字列である
］
⇒
コレの `hidden$a 属性の値 ~SET "`until-found$v"
◎
If the given value is a string that is an ASCII case-insensitive match for "until-found", then set the hidden attribute to "until-found".
</li>
	<li>
~ELIF［
所与の値 ~IN { ~F, 空~文字列, ~NULL, 0, NaN }
］
⇒
コレの `hidden$a 属性を除去する
◎
Otherwise, if the given value is false, then remove the hidden attribute.
◎
Otherwise, if the given value is the empty string, then remove the hidden attribute.
◎
Otherwise, if the given value is null, then remove the hidden attribute.
◎
Otherwise, if the given value is 0, then remove the hidden attribute.
◎
Otherwise, if the given value is NaN, then remove the hidden attribute.
</li>
	<li>
~ELSE
⇒
コレの `hidden$a 属性の値 ~SET 空~文字列
◎
Otherwise, set the hidden attribute to the empty string.
</li>
</ol>
</div>

<div class="algo">
<p>
`見出されるまでは非可視な先祖を露呈する@
ときは、
所与の
( %現在の~node )
に対し，次の手続きを走らす：
◎
The ancestor hidden-until-found revealing algorithm is to run the following steps on currentNode:
</p>
<ol>
	<li>
<p>
~WHILE［
`平坦~tree$の中の %現在の~node の親~nodeは在る
］：
◎
While currentNode has a parent node within the flat tree:
</p>
		<ol>
			<li>
<p>
~IF［
%現在の~node の `hidden$a 属性の状態 ~EQ `見出されるまでは非可視$st
］：
◎
If currentNode has the hidden attribute in the hidden until found state, then:
</p>
				<ol>
					<li>
`~eventを発火する$( %現在の~node, `beforematch$et )
◎
Fire an event named beforematch at currentNode.
</li>
					<li>
%現在の~node から `hidden$a 属性を除去する
◎
Remove the hidden attribute from currentNode.
</li>
				</ol>
			</li>
			<li>
%現在の~node ~SET `平坦~tree$の中の %現在の~node の親~node
◎
Set currentNode to the parent node of currentNode within the flat tree.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="page-visibility">
<h3 title="Page visibility">6.2. ~page可視性</h3>

<p>
`辿可能な~navigable$の`~system可視性~状態$navは、
~UAにより決定される
— 作成~時における初期~値も含めて。
それは、
例えば，次に挙げるいずれかに該当するかどうかを表現する
⇒＃
~browser~UIwindowは最小化されている／
~browser~UItabは現在~~背後にある／
~task切替器などの~system要素が~pageを遮っている
◎
A traversable navigable's system visibility state, including its initial value upon creation, is determined by the user agent. It represents, for example, whether the browser window is minimized, a browser tab is currently in the background, or a system element such as a task switcher obscures the page.
</p>

<div class="algo">
<p>
~UAは、［
`辿可能な~navigable$ %辿可能 用の`~system可視性~状態$navが %新たな状態 に変化した
］ものと決定したときは，
次の手続きを走らすモノトスル：
◎
When a user-agent determines that the system visibility state for traversable navigable traversable has changed to newState, it must run the following steps:
</p>
<ol>
	<li>
%~navigable群 ~LET %辿可能 の`広義-子孫~navigable群$
◎
Let navigables be the inclusive descendant navigables of traversable.
</li>
	<li>
<p>
%~navigable群 を成す
~EACH( %~navigable )
に対し
<span class="XXX">順序は？</span>：
◎
For each navigable of navigables in what order?:
</p>
		<ol>
			<li>
%文書 ~LET %~navigable にて`作動中な文書$nav
◎
Let document be navigable's active document.
</li>
			<li class="algo">
次を走らす`大域~taskを~queueする$( `利用者~対話~task~source$, %文書 に`関連な大域~obj$ )
⇒
`可視性~状態を更新する$( %文書, %新たな状態 )
◎
Queue a global task on the user interaction task source given document's relevant global object to update the visibility state of document with newState.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
各`文書$は、
`可視性~状態@doc
を持つ
— それは、［
`hidden^l ／ `visible^l
］いずれかをとり，
初期~時は `hidden^l に設定されるとする。
◎
A Document has a visibility state, which is either "hidden" or "visible", initially set to "hidden".
</p>

<div class="algo">
<p>
`visibilityState@m
取得子~手続きは
⇒
~RET コレの`可視性~状態$doc
◎
The visibilityState getter steps are to return this's visibility state.
</p>
</div>

<div class="algo">
<p>
`hidden@m
取得子~手続きは
⇒
~RET コレの`可視性~状態$docに応じて
⇒＃
`hidden^l ならば ~T ／
~ELSE_ ~F
◎
The hidden getter steps are to return true if this's visibility state is "hidden", otherwise false.
</p>
</div>

<div class="algo">
<p>
`可視性~状態を更新する@
ときは、所与の
( `文書$ %文書, %可視性~状態 )
に対し：
◎
To update the visibility state of Document document to visibilityState:
</p>
<ol>
	<li>
~IF［
%文書 の`可視性~状態$doc ~EQ %可視性~状態
］
⇒
~RET
◎
If document's visibility state equals visibilityState, then return.
</li>
	<li>
%文書 の`可視性~状態$doc ~SET %可視性~状態
◎
Set document's visibility state to visibilityState.
</li>
	<li>
%処理能~entry ~LET 新たな `VisibilityStateEntry$I
— その
⇒＃
`可視性~状態$vsE ~SET %可視性~状態,
`時刻印$vsE ~SET `現在の高分解能~時刻$( %文書 に`関連な大域~obj$ )
◎
Queue a new VisibilityStateEntry whose visibility state is visibilityState and whose timestamp is the current high resolution time given document's relevant global object.
</li>
	<li>
`処理能~entryを~queueする$( %処理能~entry )
◎
↑</li>
	<li>
`~screen方位~変更~手続き$( %文書 )
`SCREENORIENTATION$r
◎
Run the screen orientation change steps with document. [SCREENORIENTATION]
</li>
	<li>
<p>
他の仕様に定義される
`~page可視性~変化-時の手続き@
があれば、［
`可視性~状態$doc, %文書
］を与える下で，それらを走らす
◎
Run any page visibility change steps which may be defined in other specifications, with visibility state and document.
</p>

<p class="XXX">
これを書いている時点では、［
`DEVICEPOSTURE$r
`WEBNFC$r
］が，`~page可視性~変化-時の手続き$を~hookとして利用していることが知られているが、
それらが走る順序は，指定されていない。
そのような仕様は、
この~hookを利用する代わりに［
その策定者が `pull request^en を送信して，
ここからの~callを自身の仕様の中に直に追加する
］方が，それらの~hookが~callされる順序がきちんと定義されるので良いであろう。
【各~仕様が個別に追加しようが、順序は定義されないように思われるが？】
◎
It would be better if specification authors sent a pull request to add calls from here into their specifications directly, instead of using the page visibility change steps hook, to ensure well-defined cross-specification call order. As of the time of this writing the following specifications are known to have page visibility change steps, which will be run in an unspecified order: Device Posture API and Web NFC. [DEVICEPOSTURE] [WEBNFC]
</p>
	</li>
	<li>
`~eventを発火する$( %文書, `visibilitychange$et )
— 次のように初期化して
⇒
`bubbles$m 属性 ~SET ~T
◎
Fire an event named visibilitychange at document, with its bubbles attribute initialized to true.
</li>
</ol>
</div>

			<section id="the-visibilitystateentry-interface">
<h4 title="The VisibilityStateEntry interface">6.2.1. `VisibilityStateEntry$I ~interface</h4>

<p>
`VisibilityStateEntry$I ~interfaceは、
文書が作動中になって以降における文書の可視性の変化を公開する。
◎
The VisibilityStateEntry interface exposes visibility changes to the document, from the moment the document becomes active.
</p>

<div class="example">
<p>
これは例えば、
~page内の~JS~codeが，可視性の変化と塗り計時との相関を精査することを許容する：
◎
For example, this allows JavaScript code in the page to examine correlation between visibility changes and paint timing:
</p>

<pre class="lang-js">
function wasHiddenBeforeFirstContentfulPaint() {
    const %fcpEntry = performance.getEntriesByName("first-contentful-paint")[0];
    const %visibilityStateEntries = performance.getEntriesByType("visibility-state");
    return %visibilityStateEntries.some(e =&gt;
        e.startTime &lt; %fcpEntry.startTime &amp;&amp;
        e.name === "hidden");
}
</pre>

</div>

<p class="note">注記：
~pageを隠すことは，描画~その他の~UA演算を間引かせ得るので、
可視性の変化を［
そのような間引きが生じたことの指示
］として利用することは，共通的にある。
しかしながら、
間引かせ得るものは，~browserに応じて他にもある
— 長期間，活動【利用者とのヤリトリ等】が無いなど。
◎
Since hiding a page can cause throttling of rendering and other user-agent operations, it is common to use visibility changes as an indication that such throttling has occurred. However, other things could also cause throttling in different browsers, such as long periods of inactivity.
</p>

<pre class="idl">
[Exposed=(Window)]
interface `VisibilityStateEntry@I : `PerformanceEntry$I {
  readonly attribute DOMString `name$m;                 /* <span class="comment">
継承した `name＠~TIMELINE#dom-performanceentry-name$m を隠蔽する
◎
shadows inherited name
</span> */
  readonly attribute DOMString `entryType$m;            /* <span class="comment">
継承した `entryType＠~TIMELINE#dom-performanceentry-entrytype$m を隠蔽する
◎
shadows inherited entryType
</span> */
  readonly attribute DOMHighResTimeStamp `startTime$m;  /* <span class="comment">
継承した `startTime＠~TIMELINE#dom-performanceentry-starttime$m を隠蔽する
◎
shadows inherited startTime
</span> */
  readonly attribute unsigned long `duration$m;         /* <span class="comment">
継承した `duration＠~TIMELINE#dom-performanceentry-duration$m を隠蔽する
◎
shadows inherited duration
</span> */
};
</pre>

<p>
各 `VisibilityStateEntry$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`時刻印@vsE
⇒
`DOMHighResTimeStamp$I 値
◎
The VisibilityStateEntry has an associated DOMHighResTimeStamp timestamp.
</li>
	<li>
`可視性~状態@vsE
⇒
`visible^l ／ `hidden^l
◎
The VisibilityStateEntry has an associated "visible" or "hidden" visibility state.
</li>
</ul>

<div class="algo">
`name@m
取得子~手続きは
⇒
~RET コレの`可視性~状態$vsE
◎
The name getter steps are to return this's visibility state.
</div>

<div class="algo">
`entryType@m
取得子~手続きは
⇒
~RET `visibility-state^l
◎
The entryType getter steps are to return "visibility-state".
</div>

<div class="algo">
`startTime@m
取得子~手続きは
⇒
~RET コレの`時刻印$vsE
◎
The startTime getter steps are to return this's timestamp.
</div>

<div class="algo">
`duration@m
取得子~手続きは
⇒
~RET 0
◎
The duration getter steps are to return zero.
</div>

			</section>
		</section>
		<section id="inert-subtrees">
<h3 title="Inert subtrees">6.3. 不活な下位tree</h3>

<p class="note">注記：
同じ名前【不活, `inert^en】の属性についての説明は、
`inert$a も見よ。
◎
See also inert for an explanation of the attribute of the same name.
</p>

<p>
~node（特に，要素／~text~node）は、
`不活@
にし得る。
~nodeが`不活$にされたときは：
◎
A node (in particular elements and text nodes) can be inert. When a node is inert:
</p>
<ul>
	<li>
接触判定は、［
`pointer-events$p ~CSS~propは `none^v に設定されていた
］かのように，動作するモノトスル。
◎
Hit-testing must act as if the 'pointer-events' CSS property were set to 'none'.
</li>
	<li>
~text選択の機能性は、［
`user-select$p ~CSS~propは `none^v に設定されていた
］かのように，動作するモノトスル
◎
Text selection functionality must act as if the 'user-select' CSS property were set to 'none'.
</li>
	<li>
当の~nodeが`編集-可能$である場合、
編集-可能でなかったかのように，挙動するモノトスル。
◎
If it is editable, the node behaves as if it were non-editable.
</li>
	<li>
~UAは、
`~find-in-page$の目的においては，当の~nodeを無視するベキである。
◎
The user agent should ignore the node for the purposes of find-in-page.
</li>
</ul>

<p class="note">注記：
`不活$な~nodeは、
一般に，~focusし得ない。
~UAは、
不活な~nodeを~accessibility~APIや支援技術に公開しない。
不活な~nodeのうち`~commandを定義する$ものも、
上で述べた方式では，利用者からは操作不能になる。
◎
Inert nodes generally cannot be focused, and user agents do not expose the inert nodes to accessibility APIs or assistive technologies. Inert nodes that are commands will become inoperable to users, in the manner described above.
</p>

<p>
しかしながら，~UAは、
`~find-in-page$と~text選択については，
上の制約を上書きすることを利用者に許容してもヨイ。
◎
User agents may allow the user to override the restrictions on find-in-page and text selection, however.
</p>

<p>
既定では、
~nodeは`不活$でない。
◎
By default, a node is not inert.
</p>

			<section id="modal-dialogs-and-inert-subtrees">
<h4 title="Modal dialogs and inert subtrees">6.3.1. ~modal~dialogと不活な下位tree</h4>

<p>
`文書$ %文書 の`上端~層$を成す最後の（最も手前に~~示される）要素【！subject】が `dialog$e 要素であるとき、
当の要素を指して，
%文書 を
`阻んでいる~modal~dialog@
という。
そのような要素 %dialog が在る間は、
%文書 に`接続されて$いる~nodeのうち［
%dialog と その`平坦~tree$における子孫
］以外は，`不活$になるモノトスル。
◎
A Document document is blocked by a modal dialog subject if subject is the topmost dialog element in document's top layer.＼
While document is so blocked, every node that is connected to document, with the exception of the subject element and its flat tree descendants, must become inert.
</p>

<p>
%dialog も `inert$a 属性を介して追加的に`不活$になり得るが、
それは，この属性が %dialog 自身に指定された場合に限られる
（すなわち、 %dialog は， “先祖の不活 性から逃れる”
【 %dialog は、この属性を有さないならば，先祖が不活でも不活にならない】）。
%dialog の`平坦~tree$を成す各~子孫も，同様に`不活$になり得る。
◎
subject can additionally become inert via the inert attribute, but only if specified on subject itself (i.e., subject escapes inertness of ancestors); subject's flat tree descendants can become inert in a similar fashion.
</p>

<p class="note">注記：
`dialog$e 要素の `showModal()$m ~methodは、
要素の`~node文書$の`上端~層$に要素を`追加する＠~CSSPOS4#add-an-element-to-the-top-layer$ことにより，
この仕組みを誘発する。
◎
The dialog element's showModal() method causes this mechanism to trigger, by adding the dialog element to its node document's top layer.
</p>

			</section>
			<section id="the-inert-attribute">
<h4 title="The inert attribute">6.3.2. `inert^a 属性</h4>

<p>
`inert$a 属性は、
`真偽-属性$であり，在るならば次を指示する
⇒
当の要素, および［
当の要素の`平坦~tree$を成す子孫のうち［
“先祖の不活 性から逃れる” もの（~modal~dialogなど）以外のもの
］すべて
］は、
~UAにより`不活$にされる。
◎
The inert attribute is a boolean attribute that indicates, by its presence, that the element and all its flat tree descendants which don't otherwise escape inertness (such as modal dialogs) are to be made inert by the user agent.
</p>

<p>
`不活$な下位treeは、［
当の~pageを成す，不活~状態ではない側面
］を［
理解する／利用する
］ために~criticalな［
内容／~control
］を包含するベキでない。
不活な下位tree内の内容は、
どの利用者からも［
知覚-可能／ヤリトリ-可能
］になるとは限らない。
作者は、
要素が表現する内容が何らかの仕方で視覚的に遮られていない限り，
要素を不活として指定するベキでない。
ほとんどの事例では、
作者は，個々の~form~controlに対し `inert$a【！`不活$】 属性を指定するベキでない
— それらには、
`disabled$a 属性の方が，おそらく適切になる。
◎
An inert subtree should not contain any content or controls which are critical to understanding or using aspects of the page which are not in the inert state. Content in an inert subtree will not be perceivable by all users, or interactive. Authors should not specify elements as inert unless the content they represent are also visually obscured in some way. In most cases, authors should not specify the inert attribute on individual form controls. In these instances, the disabled attribute is probably more appropriate.
</p>

<div class="example">
<p>
次の例に，［
部分的に読込まれ，
“読込n中…” ~messageにより視覚的に遮られた内容
］を［
不活として~markする方法
］を示す。
◎
The following example shows how to mark partially loaded content, visually obscured by a "loading" message, as inert.
</p>

`inert-1^xCode

<p id="_dgm-inert-example-loading-section">
“Population by City” 内容の~screenshot
— そこには、［
上層を成す~message “読込n中…（ `Loading...^en ）
］があり，［
~form~controlや~data~tableなどの内容
］を視覚的に遮る。
内容は、
まだ全部的に描画されてないので，不活~状態にある。
◎
Screenshot of Population by City content with an overlaid loading message which visually obscures the form controls and data table which have not fully rendered, and thus are in the inert state.
</p>

<p>
上層を成す “読込n中…” は、
不活な内容を遮ることで，［
不活な内容が，~~現在~access可能でない
］ことを視覚的に~~明らかにする。
見出しと “読込n中…” ~textは、
`inert$a【！`不活$】 属性を有する要素の子孫でないことに注意。
これは、
どの利用者も［
この~textには~access可能になる一方で，不活な内容とはヤリトリし得ない
］ことを確保することになる。
◎
The "loading" overlay obscures the inert content, making it visually apparent that the inert content is not presently accessible. Notice that the heading and "loading" text are not descendants of the element with the inert attribute. This will ensure this text is accessible to all users, while the inert content cannot be interacted with by anyone.
</p>
</div>

<div class="note">
<p>注記：
既定では、［
要素／要素の下位tree
］が不活であることを持続的に視覚的に指示するものは無い。
そのような内容に適切な視覚的~styleは、
文脈に依存することが多い。
一例として、
~off-screen~navi~panelは，既定の~styleを要求しない
— その~off-screen位置は、
当の内容を視覚的に遮るので
【この “~off-screen” は、何を意味する？】。
類似に，~modalな `dialog$e 要素の後景は、
~web~pageを成す不活な内容を視覚的に遮るための手段として~serveすることになる
— 不活な内容を特定的に~styleするためではなく。
◎
By default, there is no persistent visual indication of an element or its subtree being inert. Appropriate visual styles for such content is often context-dependent. For instance, an inert off-screen navigation panel would not require a default style, as its off-screen position visually obscures the content. Similarly, a modal dialog element's backdrop will serve as the means to visually obscure the inert content of the web page, rather than styling the inert content specifically.
</p>

<p>
しかしながら，他の多くの状況~用には、
利用者-混同を避けるため，作者には［
自身の文書を成す［
どの部分が作動中か，どの部分が不活か
］を明瞭に~markする
］ことが強く奨励される。
特に、［
どの利用者も，~page全体を一度に見れる
］とは限らないことに留意すること
— 例えば、［
~screen読取器／小さな機器／拡大鏡
］の利用者，あるいは特に小さい~UIwindowを利用している利用者さえも，
~pageにて作動中な部分が見えてないかもしれず、
不活な一節が明白に不活でない場合，利用者をいらつかせるかもしれない。
◎
However, for many other situations authors are strongly encouraged to clearly mark what parts of their document are active and which are inert, to avoid user confusion. In particular, it is worth remembering that not all users can see all parts of a page at once; for example, users of screen readers, users on small devices or with magnifiers, and even users using particularly small windows might not be able to see the active part of a page and might get frustrated if inert sections are not obviously inert.
</p>
</div>

<p>
`inert@m
~IDL属性は、
`inert$m 内容~属性を`反映する$モノトスル。
◎
The inert IDL attribute must reflect the content attribute of the same name.
</p>

			</section>
		</section>
		<section id="tracking-user-activation">
<h3 title="Tracking user activation">6.4. 利用者-作動化の追跡-法</h3>

<p>
ある種の［
利用者に煩わしくもなり得る~API
］の濫用-を防止するため
（例：~popupを開く／電話を振動する）、
~UAがこれらの~APIを許容するのは，利用者が［
~web~pageと能動的にヤリトリしている／~pageと一回以上はヤリトリした
］ときに限られる。
この “能動的なヤリトリ” の状態は、
この節に定義する仕組みを通して保守される。
◎
To prevent abuse of certain APIs that could be annoying to users (e.g., opening popups or vibrating phones), user agents allow these APIs only when the user is actively interacting with the web page or has interacted with the page at least once. This "active interaction" state is maintained through the mechanisms defined in this section.
</p>

			<section id="user-activation-data-model">
<h4 title="Data model">6.4.1. ~data~model</h4>

<p>
各 `Window$I %~window には、
次に挙げる［
利用者-作動化を追跡する目的に関連な値
］がある：
◎
For the purpose of tracking user activation, each Window W has two relevant values:
</p>
<ul>
	<li>
<p>
`最後の作動化の時刻印@
⇒
`DOMHighResTimeStamp$I 型の値 ／ 正な無限大 ／ 負な無限大
— 初期~時は正な無限大とする。
</p>
		<ul>
			<li>
正な無限大は、
次を指示する
⇒
%~window は、
まだ作動化されたことがない。
</li>
			<li>
負な無限大は、
次を指示する
⇒
%~window に対する最後の`利用者-作動化を消費-$した。
</li>
		</ul>
◎
A last activation timestamp, which is either a DOMHighResTimeStamp, positive infinity (indicating that W has never been activated), or negative infinity (indicating that the activation has been consumed). Initially positive infinity.
</li>
	<li>
`最後の履歴~動作による作動化の時刻印@
⇒
`DOMHighResTimeStamp$I 型の値 ／ 正な無限大
— 初期~時は正な無限大とする。
◎
A last history-action activation timestamp, which is either a DOMHighResTimeStamp or positive infinity, initially positive infinity.
</li>
</ul>

<p>
~UAはまた，
`一過な作動化の所要時間@
を定義する。
それは、［
ある種の`利用者-作動化で通過制御される~API$（例：~popupを開く）
］用に［
利用者-作動化はどれだけ長く可用にされるか
］を指示する定数である。
◎
A user agent also defines a transient activation duration, which is a constant number indicating how long a user activation is available for certain user activation-gated APIs (e.g., for opening popups).
</p>

<p class="note">注記：
`一過な作動化の所要時間$は、
長くとも数秒までにすることが期待される
— 利用者が、
場合によっては［
~pageとのヤリトリ, 作動化で通過制御される~APIを~callしている~page
］の間の連関を知覚できるように。
◎
The transient activation duration is expected be at most a few seconds, so that the user can possibly perceive the link between an interaction with the page and the page calling the activation-gated API.
</p>

<p>
%~window には、
次に挙げる［
利用者-作動化の状態を含意する真偽値
］がある：
◎
We then have the following boolean user activation states for W:
</p>
<dl>
	<dt>
`非一過な作動化？@
（ `sticky activation^en ）
◎
Sticky activation
</dt>
	<dd>
［
次が満たされる間は ~T ／
他のときは ~F
］をとるとする
⇒
%~window における`最後の作動化の時刻印$ ~LTE `現在の高分解能~時刻$( %~window )
◎
When the current high resolution time given W is greater than or equal to the last activation timestamp in W, W is said to have sticky activation.
</dd>
	<dd>
これは、［
利用者は，これまで %~window とヤリトリしたことがあるかどうか
］を指示する。
これは， %~window の履歴上の作動化~状態であり、
~F から開始して，
%~window が初めて`作動化を通知する$とき ~T に変化する
（また、
~F に戻ることは決してない）。
◎
This is W's historical activation state, indicating whether the user has ever interacted in W. It starts false, then changes to true (and never changes back to false) when W gets the very first activation notification.
</dd>

	<dt>
`一過な作動化？@
（ `transient activation^en ）
◎
Transient activation
</dt>
	<dd>
［
次が満たされる間は ~T ／
他のときは ~F
］をとるとする
⇒
%~window における`最後の作動化の時刻印$ ~LTE `現在の高分解能~時刻$( %~window ) ~LT ( %~window における`最後の作動化の時刻印$ ~PLUS `一過な作動化の所要時間$ )
◎
When the current high resolution time given W is greater than or equal to the last activation timestamp in W, and less than the last activation timestamp in W plus the transient activation duration, then W is said to have transient activation.
</dd>
	<dd>
これは、［
利用者は，近過去に %~window とヤリトリしたかどうか
］を指示する。
これは， %~window の現在の作動化~状態であり、
~F 値から開始して，
%~window が毎回`作動化を通知する$ごとに制限された時間だけ ~T であり続ける。
◎
This is W's current activation state, indicating whether the user has interacted in W recently. This starts with a false value, and remains true for a limited time after every activation notification W gets.
</dd>
	<dd>
`一過な作動化？$の状態は、［
最後の利用者-作動化から`一過な作動化の所要時間$が経過したために， ~F になった場合
］には，
`失効-@
したものと見なされる。
これは、
`作動化を消費する$ことを通して，失効~時刻より前に ~F になり得ることに注意。
◎
The transient activation state is considered expired if it becomes false because the transient activation duration time has elapsed since the last user activation. Note that it can become false even before the expiry time through an activation consumption.
</dd>

	<dt>
`履歴~動作による作動化？@
◎
History-action activation
</dt>
	<dd>
［
次が満たされる間は ~T ／
他のときは ~F
］をとるとする
⇒
%~window の`最後の履歴~動作による作動化の時刻印$ ~NEQ %~window の`最後の作動化の時刻印$
◎
When the last history-action activation timestamp of W is not equal to the last activation timestamp of W, then W is said to have history-action activation.
</dd>
	<dd>
これは，利用者-作動化の特別な変種であり、
ある種の~session履歴~APIへの~accessを許容するために利用される
— そのような~APIは、
何度も続けて利用された場合，利用者は`~browser~UI＠~HTMLlifecycle#nav-traversal-ui$を利用して~~後方へ辿ることが難しくなる。
これは、
~F から開始して，利用者が %~window とヤリトリしたとき ~T になるが、
`履歴~動作による作動化を消費-$することを通して ~F に設定し直される。
これは、［
そのような~APIは、
利用者-作動化が介入しない限り，何度も続けて利用され得ない
］ことを確保する。
が、
`一過な作動化？$と違って，そのような~APIを利用する際の時間~制限-は無い。
◎
This is a special variant of user activation, used to allow access to certain session history APIs which, if used too frequently, would make it harder for the user to traverse back using browser UI. It starts with a false value, and becomes true whenever the user interacts with W, but is reset to false through history-action activation consumption. This ensures such APIs cannot be used multiple times in a row without an intervening user activation. But unlike transient activation, there is no time limit within which such APIs must be used.
</dd>
</dl>

<p class="note">注記：
［
`最後の作動化の時刻印$, `最後の履歴~動作による作動化の時刻印$
］は、
当の`文書$が`全部的に作動中$かどうかが変化した後も維持される
（例：`文書$から 他へ~navigateした後／~cacheされた`文書$へ~navigateした後）。
このことは、［
`非一過な作動化？$ ~EQ ~T
］の状態は、
同じ`文書$が再利用され続ける限り，複数回の~naviにまたがることを意味する。
対して，［
`一過な作動化？$ ~EQ ~T
］の状態が`失効-$する時刻は、
変化しない
（すなわち、
元の`作動化を誘発する入力~event$から`一過な作動化の所要時間$までに失効する）。
ある種のものが［
`非一過な作動化？$, `一過な作動化？$
］どちらに基づくか裁定するときは、
このことを考慮することが重要になる。
◎
The last activation timestamp and last history-action activation timestamp are retained even after the Document changes its fully active status (e.g., after navigating away from a Document, or navigating to a cached Document). This means sticky activation state spans multiple navigations as long as the same Document gets reused. For the transient activation state, the original expiry time remains unchanged (i.e., the state still expires within the transient activation duration limit from the original activation triggering input event). It is important to consider this when deciding whether to base certain things off sticky activation or transient activation.
</p>

			</section>
			<section id="user-activation-processing-model">
<h4 title="Processing model">6.4.2. 処理~model</h4>

<div class="algo">
<p>
利用者がヤリトリした結果，［
`文書$ %文書 に向けて，`作動化を誘発する入力~event$が発火される
］ことになる場合、
~UAは
— `~eventを配送する$より`前に^em —
次に与える
`作動化を通知する@
手続きを遂行するモノトスル：
◎
When a user interaction causes firing of an activation triggering input event in a Document document, the user agent must perform the following activation notification steps before dispatching the event:
</p>
<ol>
	<li>
~Assert：
%文書 は`全部的に作動中$である。
◎
Assert: document is fully active.
</li>
	<li>
%~window群 ~LET « %文書 に`関連な大域~obj$ »
◎
Let windows be « document's relevant global object ».
</li>
	<li>
<p>
%文書 の`先祖~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
%~window群 に %~navigable にて`作動中な~window$nav を`付加する$
◎
Extend windows with the active window of each of document's ancestor navigables.
</li>
	<li>
%文書 の`子孫~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
~IF［
( `作動中な文書$navの`生成元$doc, %文書 の`生成元$doc )
は`同一-生成元$である
］
⇒
%~window群 に %~navigable にて`作動中な~window$nav を`付加する$
◎
Extend windows with the active window of each of document's descendant navigables, filtered to include only those navigables whose active document's origin is same origin with document's origin.
</li>
	<li>
%~window群 を成す
~EACH( %~window )
に対し
⇒
%~window の`最後の作動化の時刻印$ ~SET `現在の高分解能~時刻$
◎
For each window in windows, set window's last activation timestamp to the current high resolution time.
</li>
</ol>
</div>

<p>
次を満たす~eventは、
`作動化を誘発する入力~event@
とされる
⇒
［
`isTrusted$m ~EQ ~T
］~AND［
`type$m は 次の表tの 1 列目に挙げるいずれかである
］~AND［
同じ行の 2 列目に与える条件は満たされる
］：
◎
An activation triggering input event is any event whose isTrusted attribute is true and whose type is one of:
</p>

<div>
<table><thead>
<tr><th>`type$m
<th>条件
<tbody>

<tr><td>"`keydown$et"
<td>当の~UIkeyは、
`Esc^Key ~UIkeyでも ~UAにより予約された~shortcut~UIkeyでもない

<tr><td>"`mousedown$et"
<td>無条件

<tr><td>"`pointerdown$et"
<td>~eventの `pointerType$m ~EQ `mouse^l

<tr><td>"`pointerup$et"
<td>~eventの `pointerType$m ~NEQ `mouse^l

<tr><td>"`touchend$et"
<td>無条件
</table>
◎
• "keydown", provided the key is neither the Esc key nor a shortcut key reserved by the user agent.
• "mousedown".
• "pointerdown", provided the event's pointerType is "mouse".
• "pointerup", provided the event's pointerType is not "mouse".
• "touchend".
</div>

<div class="algo">
<p>
［
この仕様／他の仕様
］にて定義される`一過な作動化を消費する~API$は、
次の手続きを遂行することにより，
`利用者-作動化を消費-@
し得る
— それは、
所与の
( `Window$I %~window )
に対し：
◎
Activation consuming APIs defined in this and other specifications can consume user activation by performing the following steps, given a Window W:
</p>
<ol>
	<li>
~IF［
%~window に`対応する~navigable$ ~EQ ~NULL
］
⇒
~RET
◎
If W's navigable is null, then return.
</li>
	<li>
%~window に`対応する~navigable$の`~top-level辿可能$navにて`作動中な文書$navの`広義-子孫~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
%~navigable にて`作動中な~window$navの`最後の作動化の時刻印$ ~SET 負な無限大
◎
Let top be W's navigable's top-level traversable.
◎
Let navigables be the inclusive descendant navigables of top's active document.
◎
Let windows be the list of Window objects constructed by taking the active window of each item in navigables.
◎
For each window in windows, if window's last activation timestamp is not positive infinity, then set window's last activation timestamp to negative infinity.
</li>
</ol>
</div>

<div class="algo">
<p>
`履歴~動作による作動化を消費する~API$は、
次の手続きを遂行することにより，
`履歴~動作による作動化を消費-@
し得る
— それは、
所与の
( `Window$I %~window )
に対し：
◎
History-action activation-consuming APIs can consume history-action user activation by performing the following steps, given a Window W:
</p>
<ol>
	<li>
~IF［
%~window に`対応する~navigable$ ~EQ ~NULL
］
⇒
~RET
◎
If W's navigable is null, then return.
</li>
	<li>
%~window に`対応する~navigable$の`~top-level辿可能$navにて`作動中な文書$navの`広義-子孫~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
%~navigable にて`作動中な~window$navの`最後の履歴~動作による作動化の時刻印$ ~SET %~window の`最後の作動化の時刻印$
◎
Let top be W's navigable's top-level traversable.
◎
Let navigables be the inclusive descendant navigables of top's active document.
◎
Let windows be the list of Window objects constructed by taking the active window of each item in navigables.
◎
For each window in windows, set window's last history-action activation timestamp to window's window's last activation timestamp.
</li>
</ol>
</div>

<p class="note">注記：
~page内の［
`作動化を通知する$, `作動化を消費する$
］ことにより影響される`閲覧~文脈$たちが成す集合は、
非対称であることに注意：
作動化を消費するときは，~page内のすべての閲覧~文脈に対し`一過な作動化？$を（ ~F に）変化させるが、
作動化を通知するときに それを（ ~T に）変化させるのは，それらのうち一部の閲覧~文脈に限られる。
ここでの消費における網羅的な資質は、
次の~~点で~~用心深い：
それは、
悪意的な~siteが，
（場合によっては、
`iframe$e たちが成す深い階層を悪用することにより）
一回の［
利用者-作動化
］に対し［
`一過な作動化を消費する~API$の~callを複数回~為すこと
］を防止する。
◎
Note the asymmetry in the sets of browsing contexts in the page that are affected by an activation notification vs an activation consumption: an activation consumption changes (to false) the transient activation states for all browsing contexts in the page, but an activation notification changes (to true) the states for a subset of those browsing contexts. The exhaustive nature of consumption here is deliberate: it prevents malicious sites from making multiple calls to an activation consuming API from a single user activation (possibly by exploiting a deep hierarchy of iframes).
</p>

			</section>
			<section id="user-activation-gated-apis">
<h4 title="APIs gated by user activation">6.4.3. 利用者-作動化で通過制御される~API</h4>

<p>
利用者-作動化に依存する~APIは、
次に挙げる~levelに類別される
◎
APIs that are dependent on user activation are classified into different levels:
</p>
<dl>
	<dt>
`非一過な作動化で通過制御される~API@
◎
Sticky activation-gated APIs
</dt>
	<dd>
これらの~APIは、［
`非一過な作動化？$ ~EQ ~T
］を要求する
— なので，利用者-作動化が初めて生じるまでは、
阻止される。
◎
These APIs require the sticky activation state to be true, so they are blocked until the very first user activation.
</dd>

	<dt>
`一過な作動化で通過制御される~API@
◎
Transient activation-gated APIs
</dt>
	<dd>
これらの~APIは、［
`一過な作動化？$ ~EQ ~T
］を要求するが，`利用者-作動化を消費-$しない
— なので，一過な状態が`失効-$するまでは、
一回の利用者-作動化に対し複数回の~callが許容される。
◎
These APIs require the transient activation state to be true, but they don't consume it, so multiple calls are allowed per user activation until the transient state expires.
</dd>

	<dt>
`一過な作動化を消費する~API@
◎
Transient activation-consuming APIs
</dt>
	<dd>
これらの~APIは、［
`一過な作動化？$ ~EQ ~T
］を要求することに加え、
各~callごとに`利用者-作動化を消費-$することにより，
一回の利用者-作動化に対する複数回の~callを防止する。
◎
These APIs require the transient activation state to be true, and they consume user activation in each call to prevent multiple calls per user activation.
</dd>

	<dt>
`履歴~動作による作動化を消費する~API@
◎
History-action activation-consuming APIs
</dt>
	<dd>
これらの~APIは、［
`履歴~動作による作動化？$ ~EQ ~T
］を要求することに加え、
各~callごとに`履歴~動作による作動化を消費-$することにより，
一回の利用者-作動化に対する複数回の~callを防止する。
◎
These APIs require the history-action activation state to be true, and they consume history-action user activation in each call to prevent multiple calls per user activation.
</dd>
</dl>

			</section>
			<section id="the-useractivation-interface">
<h4 title="The UserActivation interface">6.4.4. `UserActivation^I ~interface</h4>

<p>
各 `Window$I ~obj %~window には、
それに
`結付けられた~UserActivation@
がある
— それは、
ある `UserActivation$I ~objである。
%~window の作成~時には、
%~window に`結付けられた~UserActivation$を［
%~window に`関連な~realm$内に作成される`新たな$ `UserActivation$I ~obj
］に設定するモノトスル。
◎
Each Window has an associated UserActivation, which is a UserActivation object. Upon creation of the Window object, its associated UserActivation must be set to a new UserActivation object created in the Window object's relevant realm.
</p>

<pre class="idl">
[Exposed=Window]
interface `UserActivation@I {
  readonly attribute boolean `hasBeenActive$m;
  readonly attribute boolean `isActive$m;
};

partial interface <dfn id="NavigatorUserActivation-partial">`Navigator$I</dfn> {
  [SameObject] readonly attribute `UserActivation$I `userActivation$m;
};
</pre>

<dl class="domintro">
	<dt>`navigator$m.`userActivation$m.`hasBeenActive$m</dt>
	<dd>
当の~windowの`非一過な作動化？$を返す。
◎
Returns whether the window has sticky activation.
</dd>

	<dt>`navigator$m.`userActivation$m.`isActive$m</dt>
	<dd>
当の~windowの`一過な作動化？$を返す。
◎
Returns whether the window has transient activation.
</dd>
</dl>

<div class="algo">
`userActivation@m
取得子~手続きは
⇒
~RET コレに`関連な大域~obj$に`結付けられた~UserActivation$
◎
The userActivation getter steps are to return this's relevant global object's associated UserActivation.
</div>

<div class="algo">
`hasBeenActive@m
取得子~手続きは
⇒
~RET コレに`関連な大域~obj$の`非一過な作動化？$
◎
The hasBeenActive getter steps are to return true if this's relevant global object has sticky activation, and false otherwise.
</div>

<div class="algo">
`isActive@m
取得子~手続きは
⇒
~RET コレに`関連な大域~obj$の`一過な作動化？$
◎
The isActive getter steps are to return true if this's relevant global object has transient activation, and false otherwise.
</div>

			</section>
			<section id="user-activation-user-agent-automation">
<h4 title="User agent automation">6.4.5. ~UAの自動化</h4>

<p>
この仕様は、［
~UAを自動化する／~appを~testする
］目的で，
`WEBDRIVER$r 用に次の`拡張~command$を定義する
— ~UAがこの拡張~commandを~supportするのは、
任意選択である：
◎
For the purposes of user-agent automation and application testing, this specification defines the following extension command for the Web Driver specification. It is optional for a user agent to support the following extension command. [WEBDRIVER]
</p>

<div>
<table><thead>
<tr><th>
~HTTP~method
<th>~URI~template
<tbody>

<tr><td>`POST^M
<td>`/session/{<var>session id</var>}/window/consume-user-activation^c
</table>

◎
HTTP Method｜URI Template
`POST`｜/session/{session id}/window/consume-user-activation
</div>

<div class="algo">
<p>
この拡張~command用の`~remote端~手続き$は：
◎
The remote end steps are:
</p>
<ol>
	<li>
%~window ~LET `現在の閲覧~文脈$にて`作動中な~window$bc
◎
Let window be current browsing context's active window.
</li>
	<li>
%消費するか ~LET %~window の`一過な作動化？$
◎
Let consume be true if window has transient activation; otherwise false.
</li>
	<li>
~IF［
%消費するか ~EQ ~T
］
⇒
%~window に対する`利用者-作動化を消費-$する
◎
If consume is true, then consume user activation of window.
</li>
	<li>
~RET 新たな`成功$
— その
⇒
~data ~SET %消費するか
◎
Return success with data consume.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="activation">
<h3 title="Activation behavior of elements">6.5. 要素に備わる作動化の挙動</h3>

<p>
~HTMLにおける ある種の要素は、
`作動化の挙動$を備える
— すなわち、
利用者はそれを作動化できる。
これは、
常に `click$et ~eventにより生じる。
◎
Certain elements in HTML have an activation behavior, which means that the user can activate them. This is always caused by a click event.
</p>

<p>
~UAは、
`作動化の挙動$を備える要素を手動で
— 一例として、
~keyboardや声~入力を利用したり，~mouse~clickを通して —
誘発することを利用者に許容するベキである。
利用者が，
`作動化の挙動$が定義されている要素を~click以外の方式で誘発したときは、
対話~eventの既定の動作においては，
要素に向けて`~click~eventを発火する$モノトスル。
◎
The user agent should allow the user to manually trigger elements that have an activation behavior, for instance using keyboard or voice input, or through mouse clicks. When the user triggers an element with a defined activation behavior in a manner other than clicking it, the default action of the interaction event must be to fire a click event at the element.
</p>

<dl class="domintro">
	<dt>%element.`click()$m</dt>
	<dd>
要素が~clickされたかのように動作させる。
◎
Acts as if the element was clicked.
</dd>
</dl>

<p>
各~要素には
`~clickは進捗-中か@
が結付けられ、
初期~時は ~F をとるとする。
◎
Each element has an associated click in progress flag, which is initially unset.
</p>

<div class="algo">
<p>
`click()@m
~method~手続きは：
◎
The click() method must run the following steps:
</p>
<ol>
	<li>
コレは`不能化されて$いる~form~controlである
⇒
~RET
◎
If this element is a form control that is disabled, then return.
</li>
	<li>
~IF［
コレの`~clickは進捗-中か$ ~EQ ~T
］
⇒
~RET
◎
If this element's click in progress flag is set, then return.
</li>
	<li>
コレの`~clickは進捗-中か$ ~SET ~T
◎
Set this element's click in progress flag.
</li>
	<li>
`合成な~pointer~eventを発火する$( コレ, `click^et, `~trustされない^i )
◎
Fire a synthetic pointer event named click at this element, with the not trusted flag set.
</li>
	<li>
コレの`~clickは進捗-中か$ ~SET ~F
◎
Unset this element's click in progress flag.
</li>
</ol>
</div>

			<section id="the-toggleevent-interface">
<h4 title="The ToggleEvent interface">6.5.1. `ToggleEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `ToggleEvent@I : `Event$I {
  constructor(DOMString type, optional `ToggleEventInit$I %eventInitDict = {});
  readonly attribute DOMString `oldState$m;
  readonly attribute DOMString `newState$m;
};

dictionary `ToggleEventInit@I : `EventInit$I {
  DOMString oldState = "";
  DOMString newState = "";
};
</pre>

<dl class="domintro">
	<dt>%event.`oldState$m</dt>
	<dd>
［
閉な状態から開な状態へ遷移しているときは `closed^l ／
逆へ遷移しているときは `open^l
］に設定される。
◎
Set to "closed" when transitioning from closed to open, or set to "open" when transitioning from open to closed.
</dd>
	<dt>%event.`newState$m</dt>
	<dd>
［
開な状態から閉な状態へ遷移しているときは `closed^l ／
逆へ遷移しているときは `open^l
］に設定される。
◎
Set to "open" when transitioning from closed to open, or set to "closed" when transitioning from open to closed.
</dd>
</dl>

<p>
`oldState@m
／
`newState@m
属性は、
初期化~時の値を返すモノトスル。
◎
The oldState and newState attributes must return the values they are initialized to.
</p>

<p>
`~toggle~task追跡子@
は、
`構造体$であり，次を挙げる~itemを伴う：
◎
A toggle task tracker is a struct which has:
</p>
<ul>
	<li>
`~task@tTk
⇒
`ToggleEvent$I を発火する`~task$
◎
task
• A task which fires a ToggleEvent.
</li>
	<li>
`旧-状態@tTk
⇒
`~task$tTkが発火する~eventの `oldState$m 属性用の値を表現する文字列
◎
old state
• A string which represents the task's event's value for the oldState attribute.
</li>
</ul>

			</section>
		</section>
		<section id="focus">
<h3 title="Focus">6.6. ~focus</h3>

			<section id="introduction-8">
<h4 title="Introduction">6.6.1. 序論</h4>

◎非規範的

<p>
~HTML~UIは、
概して複数の対話的~widgetからなる
—
~form~control,
~scroll可能な領域,
~link,
~dialog~box,
~browser~UItab,
などなど。
これらの~widgetは、
あるもの（例： ~browser~UItab, ~dialog~box）が他のもの（例： ~link, ~form~control）を包含しているような，階層を形成する。
◎
An HTML user interface typically consists of multiple interactive widgets, such as form controls, scrollable regions, links, dialog boxes, browser tabs, and so forth. These widgets form a hierarchy, with some (e.g. browser tabs, dialog boxes) containing others (e.g. links, form controls).
</p>

<p>
~keyboard~UIによるヤリトリ-時の~UIkey入力は、
~systemから対話的~widgetの階層を経由して，`~focusされて$いる作動中な~widgetにたどり着く。
◎
When interacting with an interface using a keyboard, key input is channeled from the system, through the hierarchy of interactive widgets, to an active widget, which is said to be focused.
</p>

<div class="example">
<p>
~graphicな環境~内で走っている~browser~UItab内で走っている~HTML~appを考える。
この~appの~pageには，いくつかの~text~controlや~linkがあり、
~modal~dialogを現在に示していて，その中にも~text~controlや~buttonがあるとする。
この局面における~focus可能な~widgetの階層は：
◎
Consider an HTML application running in a browser tab running in a graphical environment. Suppose this application had a page with some text controls and links, and was currently showing a modal dialog, which itself had a text control and a button.
</p>

<p>
先ず~browser~UIwindowを含み、
⇒
~UIwindowは，~HTML~appを包含している~browser~UItabを子として持ち、
⇒
~UItabは，前述の~dialogの他に種々の~linkや~text~controlを子として持ち、
⇒
~dialogは，~text~controlや~buttonを子として持つことになる。
◎
The hierarchy of focusable widgets, in this scenario, would include the browser window, which would have, amongst its children, the browser tab containing the HTML application. The tab itself would have as its children the various links and text controls, as well as the dialog. The dialog itself would have as its children the text control and the button.
</p>

<p id="_dgm-focus-tree">
この例において `~focusされて$いる~widgetが，~dialog~box内の~text~controlであった場合、~UIkey入力は、［
~graphicな~system →
① ~web~browser →
② ~UItab →
③ ~dialog →
④ ~text~control
］の順に経由することになる。
◎
If the widget with focus in this example was the text control in the dialog box, then key input would be channeled from the graphical system to ① the web browser, then to ② the tab, then to ③ the dialog, and finally to ④ the text control.
</p>
</div>

<p>
~keyboard~eventは、
常に，この`~focusされて$いる要素を~targetにする。
◎
Keyboard events are always targeted at this focused element.
</p>

			</section>
			<section id="data-model">
<h4 title="Data model">6.6.2. ~data~model</h4>

<p>
所与の`~top-level辿可能$ %辿可能 は：
◎
↓</p>
<ul>
	<li>
<p>
次を満たすとき，
`~system~focus@
を得ているとされる
⇒
%辿可能 は~OSから経由された~keyboard入力を受取れる
◎
A top-level traversable has system focus when it can receive keyboard input channeled from the operating system,＼
</p>

<p>
このときは，場合によっては、［
ある`~navigable$ ~IN %辿可能 にて`作動中な文書$navの`子孫~navigable群$
］が，そのような入力の~targetになる。
◎
possibly targeted at one of its active document's descendant navigables.
</p>
	</li>
	<li>
次を満たすとき，
`利用者の注目@
を得ているとされる
⇒
［
%辿可能 の`~system可視性~状態$nav ~EQ `visible^l
］~AND［［
%辿可能 は`~system~focus$を得ている
］~OR［
%辿可能 に直に関係する~UA~widgetが在って，
それは~OSから経由された~keyboard入力を受取れる
］］
◎
A top-level traversable has user attention when its system visibility state is "visible", and it either has system focus or user agent widgets directly related to it can receive keyboard input channeled from the operating system.
</li>
</ul>

<p class="note">注記：
`利用者の注目$は、
~browser~UIwindowが~focusを失ったときには失われる。
一方で，`~system~focus$は、
~browser~UIwindow内の他の~system~widget
— 所在~barなど —
が~focusを得るに伴い失われることもある。
◎
User attention is lost when a browser window loses focus, whereas system focus might also be lost to other system widgets in the browser window such as a location bar.
</p>

<p>
所与の`文書$ %文書 は、
次を満たすとき
`~top-level辿可能にて全部的に作動中かつ利用者の注目を得ている子孫@
とされる
⇒
［
%文書 は`全部的に作動中$である
］~AND［
%文書 の`~node~navigable$の`~top-level辿可能$navは，`利用者の注目$を得ている
］
◎
A Document d is a fully active descendant of a top-level traversable with user attention when d is fully active and d's node navigable's top-level traversable has user attention.
</p>

<p>
用語
`~focus可能な区画@
は、
~UIを成す領域のうち，~keyboard入力などの~targetにもなり得るものを指す。
［
要素／要素の一部分／その他の~UAにより管理される領域
］は、
~focus可能な区画になり得る。
◎
The term focusable area is used to refer to regions of the interface that can further become the target of such keyboard input. Focusable areas can be elements, parts of elements, or other regions managed by the user agent.
</p>

<p>
各 `~focus可能な区画$は、
`~DOM~anchor@
を持つ
— それは、
`~focus可能な区画$の~DOMにおける位置を表現する `Node$I ~objである
（`~focus可能な区画$自身が `Node$I であれば，それがそのまま`~DOM~anchor$になる）。
`~DOM~anchor$は、
`~focus可能な区画$を表現する~DOM~objが他にないときに，
一部の~APIにより`~focus可能な区画$の代用として利用される。
◎
Each focusable area has a DOM anchor, which is a Node object that represents the position of the focusable area in the DOM. (When the focusable area is itself a Node, it is its own DOM anchor.) The DOM anchor is used in some APIs as a substitute for the focusable area when there is no other DOM object to represent the focusable area.
</p>

<p>
次の表tの 1 列目に、
どの~objが`~focus可能な区画$になり得るかを述べる。
対応する`~DOM~anchor$を表tの 2 列目に述べる。
◎
The following table describes what objects can be focusable areas. The cells in the left column describe objects that can be focusable areas; the cells in the right column describe the DOM anchors for those elements. (The cells that span both columns are non-normative examples.)
</p>

<table id="table-fa"><thead>
<tr><th>`~focus可能な区画$
<th id="th-fa-dom-rep">`~DOM~anchor$
<tr><th colspan="2">
<div class="example">
<i>左右列にまたがるセルには、
例を示す。</i></div>

<tbody><tr><th id="td-fa-1">
<p>
~AND↓ を満たす要素：
◎
Elements that meet all the following criteria:
</p>
		<ul>
			<li>
［
要素の`~tabindex値$ ~NEQ ~NULL
］~OR［
~UAは要素を~focus可能と決定した
］
◎
the element's tabindex value is non-null, or the element is determined by the user agent to be focusable;
</li>
			<li>
［
`~shadow~host$でない
］~OR［［
その`~shadow根$elm ~NEQ ~NULL
］~AND［
その`~shadow根$elmの`~focusを委任するか$sR ~EQ ~F
］］
◎
the element is either not a shadow host, or has a shadow root whose delegates focus is false;
</li>
			<li>
`実際に不能化-$されていない
◎
the element is not actually disabled;
</li>
			<li>
`不活$でない
◎
the element is not inert;
</li>
			<li>
［
`具現化されて$いる
］~OR［
`関連な~canvas~fallback内容として利用-中にある＠~HEcanvas#being-used-as-relevant-canvas-fallback-content$
］
◎
the element is either being rendered or being used as relevant canvas fallback content.
</li>
		</ul>

<td>
要素~自身。
◎
The element itself.
<tr><td colspan="2">

<div class="example">
<ul>
	<li>
`iframe$e
</li>
	<li>
`dialog$e
</li>
	<li>
`&lt;input type=text&gt;＠~HEinput#text-(type=text)-state-and-search-state-(type=search)$e,
</li>
	<li>
場合によっては（~platform規約に依存する）
`&lt;a href="…"&gt;＠~HEtextlevel#the-a-element$e
</li>
</ul>
◎
iframe, dialog, &lt;input type=text&gt;, sometimes &lt;a href=""&gt; (depending on platform conventions).
</div>

<tbody><tr><th id="td-fa-2">
<p>
`画像~map$内の
`~focus可能な図形@
— そのような図形は、
次を満たす各~組
( `area$e 要素 %area , `img$e 要素 %img )
ごとに作成される：
</p>
<ul>
	<li>
%img は、
その `usemap^a 属性を通して %area の親である `map^e 要素を指している
</li>
	<li>
%img は、
`具現化されて$いる, かつ`不活$でない
</li>
</ul>

<p class="trans-note">【
以下では、
%area を指して
“図形を`定義している^i `area$e 要素”，
%img を指して
“図形が`属する^i `img$e 要素”
と称することにする。
】</p>

◎
The shapes of area elements in an image map associated with an img element that is being rendered and is not inert.
<td>
その図形が属する `img$e 要素。
◎
The img element.
<tr><td colspan="2">

<div class="example">
<p>
次の例の `area$e 要素は、［
その親である `map^e 要素への参照を通して それを利用している各 `img$e 要素
］ごとに 1 個ずつ，計 2 個の図形を作成する。
各~図形の`~DOM~anchor$は、
参照元の `img^e 要素になる。
◎
In the following example, the area element creates two shapes, one on each image. The DOM anchor of the first shape is the first img element, and the DOM anchor of the second shape is the second img element.
</p>

`data-model-1^xCode
</div>

<tbody><tr><th id="td-fa-3">
~UAが［
次を満たす要素
］用に供した下位widget
⇒
［
`具現化されて$いる
］~AND［
`実際に不能化-$されてない
］~AND［
`不活$でない
］
◎
The user-agent provided subwidgets of elements that are being rendered and are not actually disabled or inert.
<td>
当の要素。
◎
The element for which the focusable area is a subwidget.
<tr><td colspan="2" headers="td-fa-3">

<div class="example">
<ul>
	<li>
`video$e 要素~用に`~UI内に公開されている~control$
◎
The controls in the user interface for a video element,＼
</li>
	<li>
`&lt;input type=number&gt;＠~HEinput#number-state-(type=number)$e
用の増減~button
◎
the up and down buttons in a spin-control version of &lt;input type=number&gt;,＼
</li>
	<li>
`details$e 要素の具現化の一部を成していて，~keyboard入力で当の要素を開閉することを可能化しているもの。
◎
the part of a details element's rendering that enables the element to be opened or closed using keyboard input.
</li>
</ul>
</div>

<tbody><tr><th id="td-fa-4">
［
次を満たす要素
］により作成された~scroll可能な領域
⇒
［
`具現化されて$いる
］~AND［
`不活$でない
］
◎
The scrollable regions of elements that are being rendered and are not inert.
<td>
当の要素。
◎
The element for which the box that the scrollable region scrolls was created.
<tr><td colspan="2">

<div class="example">
<p>
~CSS `overflow$p ~propに対する `scroll^v 値は、
概して，~scroll可能な領域を作成させる。
◎
The CSS 'overflow' property's 'scroll' value typically creates a scrollable region.
</p>
</div>

<tbody><tr><th id="td-fa-5">
［
次を満たす`文書$
］用の`表示域$
⇒
［
`属する閲覧~文脈$ ~NEQ ~NULL
］~AND［
`不活$でない
］
◎
The viewport of a Document that has a non-null browsing context and is not inert.
<td>
当の`文書$。
◎
The Document for which the viewport was created.
<tr><td colspan="2">
<div class="example">
<p>
`iframe$e の内容。
◎
The contents of an iframe.
</p>
</div>

<tbody><tr><th id="td-fa-6">
他の任意の，~UAにより~focus可能な区画であると決定された［
要素, または要素の
— とりわけ、［
~accessibilityを援助する／~platform規約により良く合致する
］ような —
一部分
］。
◎
Any other element or part of an element determined by the user agent to be a focusable area, especially to aid with accessibility or to better match platform conventions.

<td>
当の要素。
◎
The element.
<tr><td colspan="2">

<div class="example">
<p>
~UAは、
利用者が~listを容易に~navigateできるよう，
すべての~list~item~bulletを`逐次的に~focus可能$にすることもできる。
◎
A user agent could make all list item bullets sequentially focusable, so that a user can more easily navigate lists.
</p>

<p>
類似に，~UAは、
`title$a 属性を有する すべての要素に対し，
それらの助言的~情報に~accessできるよう，
`逐次的に~focus可能$にすることもできる。
◎
Similarly, a user agent could make all elements with title attributes sequentially focusable, so that their advisory information can be accessed.
</p>
</div>
</table>

<p id="bc-focus-ergo-bcc-focus" class="note">注記：
`~navigable容器$ %容器 （例： `iframe$e ）は `~focus可能な区画$であるが、［
%容器 の`内容~navigable$ %N ~NEQ ~NULL
］の場合，［
%容器 へ届けられる~UIkey~eventは、
%N にて`作動中な文書$nav %文書 へ~~直に届けられる
］ようになる。
類似に，`逐次的~focus~navi$においては、
%容器 は，本質的には %文書 の代役として動作するに過ぎない。
◎
A navigable container (e.g. an iframe) is a focusable area, but key events routed to a navigable container get immediately routed to its content navigable's active document. Similarly, in sequential focus navigation a navigable container essentially acts merely as a placeholder for its content navigable's active document.
</p>

<hr>

<p>
各 `文書$が
`指名する被focus区画@doc
は、
文書に属する`~focus可能な区画$のうち 1 つを指す【か，何も指さずに ~NULL になる】。
どの~focus可能な区画がそう指名されるかは、
この仕様の各種~algoに基づいて，時間~越しに変化する。
◎
One focusable area in each Document is designated the focused area of the document. Which control is so designated changes over time, based on algorithms in this specification.
</p>

<p class="trans-note">【
原文は，何も指さない場合ついて述べていないが、
それもあり得るらしい
（ `課題 #5835＠~HTMLissue/5835$
— 場合によっては、
表示域に~fallbackするよう定義されるかもしれない）。
加えて、
~NULL にもなり得ることは，`現在の被focus区画$tlTの定義からも要請される。
】</p>

<p class="note">注記：
文書は`全部的に作動中$でなく，利用者に示されていない場合でも、
依然として，文書は`指名する被focus区画$docを持ち得る。
文書が`全部的に作動中$かどうかが変化しても、
文書が`指名する被focus区画$docは，同じまま変わらない。
◎
Even if a document is not fully active and not shown to the user, it can still have a focused area of the document. If a document's fully active state changes, its focused area of the document will stay the same.
</p>

<div class="algo">
<p>
`~top-level辿可能$ %辿可能 の
`現在の被focus区画@tlT
は、
次を走らせた結果の［
`~focus可能な区画$／~NULL
］である：
</p>
<ol>
	<li>
~IF［
%辿可能 は`~system~focus$を得ていない
］
⇒
~RET ~NULL
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
%文書 ~SET %辿可能 にて`作動中な文書$nav
</li>
			<li>
%区画 ~LET %文書 が`指名する被focus区画$doc
</li>
			<li>
~IF［
%区画 ~EQ ~NULL
］
⇒
~RET %文書
</li>
			<li>
~IF［
%区画 は`~navigable容器$でない
］
⇒
~RET %区画
</li>
			<li>
%辿可能 ~SET %区画 の`内容~navigable$
</li>
			<li>
~IF［
%辿可能 ~EQ ~NULL
］
⇒
~RET %区画
</li>
		</ol>
	</li>
</ol>
◎
The currently focused area of a top-level traversable traversable is the focusable area-or-null returned by this algorithm:
• If traversable does not have system focus, then return null.
• Let candidate be traversable's active document.
• While candidate's focused area is a navigable container with a non-null content navigable: set candidate to the active document of that navigable container's content navigable.
• If candidate's focused area is non-null, set candidate to candidate's focused area.
• Return candidate.
</div>

<p>
`~top-level辿可能$ %辿可能 の
`現在の~focus鎖@tlT
は、［
%辿可能 の`現在の被focus区画$tlT ~NEQ ~NULL ならば その`~focus鎖$／
~ELSE_ 空~list
］とする。
◎
The current focus chain of a top-level traversable traversable is the focus chain of the currently focused area of traversable, if traversable is non-null, or an empty list otherwise.
</p>

<p>
`現在の被focus区画$tlTの`~DOM~anchor$である要素は、
`~focusされて@
いるという。
そうでない要素がそうなることを，要素は
`~focusを獲得した@
という。
◎
An element that is the DOM anchor of a focusable area is said to gain focus when that focusable area becomes the currently focused area of a top-level traversable. When an element is the DOM anchor of a focusable area of the currently focused area of a top-level traversable, it is focused.
</p>

<div class="algo">
<p>
`~focus可能な区画$ %~subject の
`~focus鎖@
は、
次に従って構築される有順序~listである：
◎
The focus chain of a focusable area subject is the ordered list constructed as follows:
</p>

<ol>
	<li>
%出力 ~LET 空~list
◎
Let output be an empty list.
◎
Let currentObject be subject.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%出力 に %~subject を付加する
◎
Append currentObject to output.
</li>
			<li>
%~DOM~anchor ~LET ［
%~subject は`~focus可能な区画$であるならば %~subject の`~DOM~anchor$ ／
~ELSE_ ε
］
◎
↓</li>
			<li>
~IF［
%~subject は`~focus可能な図形$である
］
⇒
%出力 に %~subject を定義している `area$e 要素を付加する
◎
If currentObject is an area element's shape, then append that area element to output.
</li>
			<li>
~ELIF［
%~DOM~anchor は要素である
］~AND［
%~DOM~anchor ~NEQ %~subject
］
⇒
%出力 に %~DOM~anchor を付加する
◎
Otherwise, if currentObject's DOM anchor is an element that is not currentObject itself, then append currentObject's DOM anchor to output.
</li>
			<li>
~IF［
%~DOM~anchor ~NEQ ε
］
⇒
%~subject ~SET %~DOM~anchor の`~node文書$
◎
If currentObject is a focusable area, then set currentObject to currentObject's DOM anchor's node document.
</li>
			<li>
<p>
~ELIF［
%~subject は`文書$である
］：
</p>
				<ol>
					<li>
%~subject ~SET %~subject の`~node~navigable$の`親$nav
</li>
					<li>
~IF［
%~subject ~EQ ~NULL
］
⇒
~BREAK
</li>
				</ol>
◎
Otherwise, if currentObject is a Document whose node navigable's parent is non-null, then set currentObject to currentObject's node navigable's parent.
</li>
			<li>
~ELSE
⇒
~BREAK
◎
Otherwise, break.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
~focus鎖は、
%~subject から開始して，
（ %~subject が［
`現在の被focus区画$tlTであるか，そうなり得るものである
］ならば）
`~top-level辿可能$に属する`文書$まで，~focus階層を遡り続ける。
◎
The chain starts with subject and (if subject is or can be the currently focused area of a top-level traversable) continues up the focus hierarchy up to the Document of the top-level traversable.
</p>
</div>

<p>
`~focus可能な区画$である すべての要素は、
`~focus可能@
であるという。
◎
All elements that are focusable areas are said to be focusable.
</p>

<p class="trans-note">【
`~focus可能な区画$の`~DOM~anchor$も
この定義に含まれるのかどうか，はっきりしないが、
“要素が`~focusされて$いる” の意味論に従うなら，含まれるように思われる。
】</p>

<p>
`~focus可能な区画$には、
次に挙げる特別な~focus能を有する種別もある：
◎
There are two special types of focusability for focusable areas:
</p>

<ul>
	<li>
`逐次的に~focus可能@
⇒
［
`~focus可能な区画$であって，
それが属する`文書$の`逐次的~focus~navi順序$に含まれているもの
］のうち，~UAが［
逐次的に~focus可能である
］と決定したもの。
◎
A focusable area is said to be sequentially focusable if it is included in its Document's sequential focus navigation order and the user agent determines that it is sequentially focusable.
</li>
	<li>
`~clickで~focus可能@
⇒
`~focus可能な区画$のうち，~UAが［
~clickで~focus可能である
］と決定したもの。
~UAは、
~focus可能な区画のうち［
`~tabindex値$ ~NEQ ~NULL
］なるものは，~clickで~focus可能と見なすベキである。
◎
A focusable area is said to be click focusable if the user agent determines that it is click focusable. User agents should consider focusable areas with non-null tabindex values to be click focusable.
</li>
</ul>

<p class="note">注記：
`~focus可能$でない要素は、
`~focus可能な区画$にならないので，
`逐次的に~focus可能$にも`~clickで~focus可能$にもならない。
◎
Elements which are not focusable are not focusable areas, and thus not sequentially focusable and not click focusable.
</p>

<div class="note">
<p>注記：
“要素が`~focus可能$である”
は、［
要素を~program的に
— 例えば， `focus()$mE ~methodや `autofocus$a 属性を介して —
~focusできるかどうか
］についての言明である。
対照的に，［
`逐次的に~focus可能$／`~clickで~focus可能$
］は、［
`逐次的~focus~navi$／
`~focus作動化の挙動^【！#focus-activation-behavior】
］において，~UAが利用者-ヤリトリに どう応答するかを統治する。
◎
Being focusable is a statement about whether an element can be focused programmatically, e.g. via the focus() method or autofocus attribute. In contrast, sequentially focusable and click focusable govern how the user agent responds to user interaction: respectively, to sequential focus navigation and as activation behavior.
</p>

<p>
~UAは、
要素は［
`~focus可能$であって，自身が属する`文書$の`逐次的~focus~navi順序$に含まれて
］いても，［
利用者-選好に則って，`逐次的に~focus可能$でないものと決定する
］かもしれない。
例えば，~macOS利用者は、
~form~controlでない要素を飛ばすよう，~UAを設定できたり、
`逐次的~focus~navi$を `Tab^Key ~UIkeyだけで（ `Option^Key ~UIkeyも併用することなく）行うときは，~linkを飛ばせる。
◎
The user agent might determine that an element is not sequentially focusable even if it is focusable and is included in its Document's sequential focus navigation order, according to user preferences. For example, macOS users can set the user agent to skip non-form control elements, or can skip links when doing sequential focus navigation with just the Tab key (as opposed to using both the Option and Tab keys).
</p>

<p>
類似に，~UAは、
ある要素を［
`~focus可能$であっても，`~clickで~focus可能$ではないと決定する
］かもしれない。
例えば，一部の~UAにおいては、
編集-不能な~form~controlは，~clickしても~focusされない
— すなわち~UAは、
そのような~controlを［
~clickで~focus可能でないもの
］と決定したことになる。
◎
Similarly, the user agent might determine that an element is not click focusable even if it is focusable. For example, in some user agents, clicking on a non-editable form control does not focus it, i.e. the user agent has determined that such controls are not click focusable.
</p>

<p>
したがって，要素は、［
`~focus可能$でありながら，
`逐次的に~focus可能$にも`~clickで~focus可能$にもならない
］こともある。
例えば，一部の~UAにおいては、［
編集-不能な~form~controlのうち，
その`~tabindex値$は負な整数であるもの
］は，［
利用者-ヤリトリを介しては，~focus可能にならず、
~program的~APIを介するとき限り，~focus可能になる
］。
◎
Thus, an element can be focusable, but neither sequentially focusable nor click focusable. For example, in some user agents, a non-editable form-control with a negative-integer tabindex value would not be focusable via user interaction, only via programmatic APIs.
</p>
</div>

<div class="algo">
<p>
利用者が［
`~focus可能な区画$のうち`~clickで~focus可能$なもの
］を`作動化した＠#activation$ときは、
~UAは次を走らすモノトスル
⇒
`~objを~focusする$( 当の`~focus可能な区画$, ε, `click^l )
◎
When a user activates a click focusable focusable area, the user agent must run the focusing steps on the focusable area with focus trigger set to "click".
</p>
</div>

<p class="note">注記：
~focusすることは、
`作動化の挙動$ではないことに注意
— すなわち、
要素に対し［
`click()$m ~methodを~callしても／
合成な `click$et ~eventを配送しても
］要素が~focusを得ることはない。
◎
Note that focusing is not an activation behavior, i.e. calling the click() method on an element or dispatching a synthetic click event on it won't cause the element to get focused.
</p>

<hr>

<div class="p">
<p>
次に挙げる~nodeは、
`~focus~navi視野の所有者@
であるとされる：
</p>
<ul>
	<li>
`文書$
</li>
	<li>
`~shadow~host$
</li>
	<li>
`slot$e 要素
</li>
	<li>
次を満たす`~HTML要素$
⇒
［
`~popover可視性~状態$ ~EQ `示している$i
］~AND［
`~popover呼出元$elm ~NEQ ~NULL
］
</li>
</ul>
◎
A node is a focus navigation scope owner if it is a Document, a shadow host, a slot, or an element in the popover showing state which also has a popover invoker set.
</div>

<p>
各`~focus~navi視野の所有者$は、
`~focus~navi視野@
を持つ
— それは，要素たちが成す~listであり、
その内容は，次に従って決定される：
◎
Each focus navigation scope owner has a focus navigation scope, which is a list of elements. Its contents are determined as follows:
</p>
<ul>
	<li class="algo">
<p>
先ず，所与の要素 %要素 に
`結付けられた~focus~navi所有者@
は、
次の~algoで決定される［
~NULL ／ `~focus~navi視野の所有者$
］になる：
◎
Every element element has an associated focus navigation owner, which is either null or a focus navigation scope owner. It is determined by the following algorithm:
</p>
		<ol>
			<li>
%親 ~LET %要素 の親
◎
↓</li>
			<li>
~IF［
%親 ~EQ  ~NULL
］
⇒
~RET ~NULL
◎
If element's parent is null, then return null.
</li>
			<li>
~IF［
%親 は`~shadow~host$である
］
⇒
~RET %要素 の`割当-先~slot$
◎
If element's parent is a shadow host, then return element's assigned slot.
</li>
			<li>
~IF［
%親 は`~shadow根$である
］
⇒
~RET %親 の`~host$
◎
If element's parent is a shadow root, then return the parent's host.
</li>
			<li>
~IF［
%親 は`文書~要素$である
］
⇒
~RET %親 の`~node文書$
◎
If element's parent is the document element, then return the parent's node document.
</li>
			<li>
~IF［
%要素 は`~HTML要素$である
］~AND［
%要素 の`~popover可視性~状態$ ~EQ `示している$i
］~AND［
%要素 の`~popover呼出元$elm ~NEQ ~NULL
］
⇒
~RET %要素
◎
If element is in the popover showing state and has a popover invoker set, then return element.
</li>
			<li>
~RET %親 に`結付けられた~focus~navi所有者$
◎
Return element's parent's associated focus navigation owner.
</li>
		</ol>
	</li>
	<li>
所与の`~focus~navi視野の所有者$ %所有者 の`~focus~navi視野$は、
次を満たす要素からなる
⇒
それに`結付けられた~focus~navi所有者$ ~EQ %所有者
◎
Then, the contents of a given focus navigation scope owner owner's focus navigation scope are all elements whose associated focus navigation owner is owner.
</li>
</ul>

<p class="note">注記：
`~focus~navi視野$の中における要素の順序は、
この仕様~のどの~algoにも影響iしない。
順序付けが重要になるのは、
下に定義する［
`~tabindex順な~focus~navi視野$／
`平坦~化された~tabindex順な~focus~navi視野$
］の概念に限られる。
◎
The order of elements within a focus navigation scope does not impact any of the algorithms in this specification. Ordering only becomes important for the tabindex-ordered focus navigation scope and flattened tabindex-ordered focus navigation scope concepts defined below.
</p>

<p>
各`~focus~navi視野の所有者$ %所有者 は、
`~tabindex順な~focus~navi視野@
を持つ。
それは，［
`~focus可能な区画$,
`~focus~navi視野の所有者$
］たちが成す`~list$であり、
その内容は，次に従って決定される：
◎
A tabindex-ordered focus navigation scope is a list of focusable areas and focus navigation scope owners. Every focus navigation scope owner owner has tabindex-ordered focus navigation scope, whose contents are determined as follows:
</p>

<ul>
	<li>
次を満たす すべての要素を包含する
⇒
［
要素 ~IN %所有者 の`~focus~navi視野$
］~AND［
`~focus~navi視野の所有者$である
］~AND［
その`~tabindex値$は負な整数でない
］
◎
It contains all elements in owner's focus navigation scope that are themselves focus navigation scope owners, except the elements whose tabindex value is a negative integer.
</li>
	<li>
次を満たす すべての`~focus可能な区画$を包含する
⇒
［
その`~DOM~anchor$ ~IN %所有者 の`~focus~navi視野$
］~AND［
その`~tabindex値$は負な整数でない
］
◎
It contains all of the focusable areas whose DOM anchor is an element in owner's focus navigation scope, except the focusable areas whose tabindex value is a negative integer.
</li>
</ul>

<p>
`~tabindex順な~focus~navi視野$の中における順序は、
以下の節に述べるように，各~要素の`~tabindex値$により決定される。
◎
The order within a tabindex-ordered focus navigation scope is determined by each element's tabindex value, as described in the section below.
</p>

<p class="note">注記：
そこに与える規則は、
ほとんどが “ベキである” 言明による相対-順序付けで構成されているので，
精確な順序付けは与えない。
◎
The rules there do not give a precise ordering, as they are composed mostly of "should" statements and relative orderings.
</p>

<div class="algo">
<p>
各`~focus~navi視野の所有者$ %所有者 は、
互いに別個な
`平坦~化された~tabindex順な~focus~navi視野@
を所有する。
それは，`~focus可能な区画$たちが成す`~list$であり、
その内容は，次の~algoに従って決定される：
◎
A flattened tabindex-ordered focus navigation scope is a list of focusable areas. Every focus navigation scope owner owner owns a distinct flattened tabindex-ordered focus navigation scope, whose contents are determined by the following algorithm:
</p>

<ol>
	<li>
%結果 ~LET 新たな`~list$
◎
↓</li>
	<li>
<p>
%所有者 の`~tabindex順な~focus~navi視野$を成す
~EACH( %~item )
に対し：
</p>
		<ol>
			<li>
~IF［
%~item は`~focus~navi視野の所有者$でない
］~OR［
%~item は`~focus可能な区画$である
］
⇒
%結果 に %~item を`付加する$
</li>
			<li>
~IF［
%~item は`~focus~navi視野の所有者$である
］
⇒
%結果 を［
%~item の`平坦~化された~tabindex順な~focus~navi視野$
］で`拡張する$
</li>
		</ol>
◎
Let result be a clone of owner's tabindex-ordered focus navigation scope.
◎
For each item of result:
• If item is not a focus navigation scope owner, then continue.
• If item is not a focusable area, then replace item with all of the items in item's flattened tabindex-ordered focus navigation scope.
• Otherwise, insert the contents of item's flattened tabindex-ordered focus navigation scope after item.
</li>
</ol>

<p class="trans-note">【
この訳では、
“`拡張する$” を利用して，原文の~algoを簡素化している。
】</p>
</div>

			</section>
			<section id="the-tabindex-attribute">
<h4 title="The tabindex attribute">6.6.3. `tabindex^a 属性</h4>

<p>
`tabindex@a
内容~属性は、［
要素, および それを`~DOM~anchor$とする`~focus可能な区画$
］を`~focus可能な区画$にすること, その場合に［
`逐次的に~focus可能$になるのを［
許容する／防止する
］こと
］を，作者に許容する。
加えて、
`逐次的~focus~navi$における それらの相対-順序付けを決定する。
◎
The tabindex content attribute allows authors to make an element and regions that have the element as its DOM anchor be focusable areas, allow or prevent them from being sequentially focusable, and determine their relative ordering for sequential focus navigation.
</p>

<p>
“tab index” という名称は、
一連の~focus可能な要素を~navigateするときに，
`Tab^Key ~UIkeyが共通的に利用されることに~~由来する。
語 “`tabbing^en” とは、
逐次的~focus~naviを利用して到達し得る［
`逐次的に~focus可能$な`~focus可能な区画$
］を，前方へ辿ることを指す。
◎
The name "tab index" comes from the common use of the Tab key to navigate through the focusable elements. The term "tabbing" refers to moving forward through sequentially focusable focusable areas.
</p>

<p>
`tabindex$a 属性に指定される値は、
`妥当な整数$でなければナラナイ。
正な整数は、
要素の`~focus可能な区画$の［
`逐次的~focus~navi順序$における位置
］を指定する。
負な整数は、
当の~controlは`逐次的に~focus可能$にしないことを指示する。
◎
The tabindex attribute, if specified, must have a value that is a valid integer. Positive numbers specify the relative position of the element's focusable areas in the sequential focus navigation order, and negative numbers indicate that the control is not sequentially focusable.
</p>

<p>
開発者は、
`tabindex$a 属性に対する 0, −1 以外の値は注意して利用するベキである
— 正しく利用するのは複雑なので。
◎
Developers should use caution when using values other than 0 or −1 for their tabindex attributes as this is complicated to do correctly.
</p>

<div class="note">
<p>注記：
`tabindex$a 属性にアリな各~値の挙動についての規範的でない要約を次に挙げる
（より精確な規則は、下の処理~modelに与える）。
◎
The following provides a non-normative summary of the behaviors of the possible tabindex attribute values. The below processing model gives the more precise rules.
</p>

<dl>
	<dt>
省略されている／整数でない【値は妥当でない】
◎
omitted (or non-integer values)
</dt>
	<dd>
要素が`~focus可能$かどうか, および そうなる場合に［
`逐次的に~focus可能$／`~clickで~focus可能$
］になるかどうかは、
~UAが裁定することになる。
◎
The user agent will decide whether the element is focusable, and if it is, whether it is sequentially focusable or click focusable (or both).
</dd>
	<dt>
負な整数
◎
−1 (or other negative integer values)
</dt>
	<dd>
要素を`~focus可能$にすることに加え、
作者は［
要素は，`~clickで~focus可能$であるが`逐次的に~focus可能$にならない
］ことを選好することを指示する。
~UAは、［
~click, 逐次的
］~focus能に関するこの選好を無視するかもしれない
— 例えば、
特定の要素~型~用に~platform規約に則って，
あるいは~keyboardのみの利用者~用に。
◎
Causes the element to be focusable, and indicates that the author would prefer the element to be click focusable but not sequentially focusable. The user agent might ignore this preference for click and sequential focusability, e.g., for specific element types according to platform conventions, or for keyboard-only users.
</dd>

	<dt>0</dt>
	<dd>
要素を`~focus可能$にすることに加え、
作者は［
要素は，`~clickで~focus可能$かつ`逐次的に~focus可能$になる
］ことを選好することを指示する。
~UAは、［
~click, 逐次的
］~focus能に関するこの選好を無視するかもしれない。
◎
Causes the element to be focusable, and indicates that the author would prefer the element to be both click focusable and sequentially focusable. The user agent might ignore this preference for click and sequential focusability.
</dd>
	<dt>
正な整数
◎
positive integer values
</dt>
	<dd>
0 と同じに挙動するが，それに加え、
`tabindex$a 属性~値が高い要素ほど後になるよう，`~tabindex順な~focus~navi視野$の中での順序付けを与える。
◎
Behaves the same as 0, but in addition creates a relative ordering within a tabindex-ordered focus navigation scope, so that elements with higher tabindex attribute value come later.
</dd>
</dl>

<p>
`tabindex$a 属性は、
要素を~focus不能にする用途には利用できないことに注意。
~page作者がそれを行うには、
要素を［
`実際に不能化-$するか, `不活$にする
］他にない。
◎
Note that the tabindex attribute cannot be used to make an element non-focusable. The only way a page author can do that is by disabling the element, or making it inert.
</p>
</div>

<hr>

<p>
所与の要素の
`~tabindex値@
は、［
要素は `tabindex$a 属性 %A を有する
］~AND［
`整数として構文解析する$( %A の値 ) ~NEQ `失敗^i
］ならば その結果 ／
~ELSE_ ~NULL
］とする。
◎
The tabindex value of an element is the value of its tabindex attribute, parsed using the rules for parsing integers. If parsing fails or the attribute is not specified, then the tabindex value is null.
</p>

<p>
所与の`~focus可能な区画$の`~tabindex値$は、
その`~DOM~anchor$の`~tabindex値$とする。
◎
The tabindex value of a focusable area is the tabindex value of its DOM anchor.
</p>

<p>
要素の`~tabindex値$は、
次に従って解釈するモノトスル：
◎
The tabindex value of an element must be interpreted as follows:
</p>

<ul>
	<li>
<p>
`~tabindex値$ ~EQ ~NULL の場合：
◎
If the value is null
</p>
		<ul>
			<li>
~UAは、
~platform規約に従って，次を決定するベキである
⇒
要素は`~focus可能な区画$であると見なすベキかどうか
— そうであれば
⇒
［
要素, および それを`~DOM~anchor$とする`~focus可能な区画$
］は`逐次的に~focus可能$になるかどうか
— そうであれば
⇒
それらは、
`~tabindex順な~focus~navi視野$において どこに位置するか？
◎
The user agent should follow platform conventions to determine if the element should be considered as a focusable area and if so, whether the element and any focusable areas that have the element as their DOM anchor are sequentially focusable, and if so, what their relative position in their tabindex-ordered focus navigation scope is to be.＼
</li>
			<li>
要素は`~focus~navi視野の所有者$である場合、
`~focus可能な区画$でない場合でも，
自身の`~tabindex順な~focus~navi視野$には含めるモノトスル。
◎
If the element is a focus navigation scope owner, it must be included in its tabindex-ordered focus navigation scope even if it is not a focusable area.
</li>
			<li>
同じ`~focus~navi視野$に属する［
要素, `~focus可能な区画$
］のうち［
`~tabindex値$ ~EQ ~NULL
］なるものたちの［
`~tabindex順な~focus~navi視野$の中での順序
］は、
`~shadowも含めた~tree順序$に従うベキである。
◎
The relative ordering within a tabindex-ordered focus navigation scope for elements and focusable areas that belong to the same focus navigation scope and whose tabindex value is null should be in shadow-including tree order.
</li>
			<li>
<p>
~platform規約の違いを除き、
次に挙げる要素は［
`~focus可能な区画$と見なされ，`逐次的に~focus可能$である
］ベキであることが示唆される：
◎
Modulo platform conventions, it is suggested that the following elements should be considered as focusable areas and be sequentially focusable:
</p>
				<ul>
					<li>
`a$e 要素のうち， `href$a 属性を有するもの
◎
a elements that have an href attribute
</li>
					<li>
`button$e 要素
◎
button elements
</li>
					<li>
`input$e 要素のうち，［
その `type$a 属性の状態 ~NEQ `Hidden$st
］なるもの
◎
input elements whose type attribute are not in the Hidden state
</li>
					<li>
`select$e 要素
◎
select elements
</li>
					<li>
`textarea$e 要素
◎
textarea elements
</li>
					<li>
`details$e 要素の子である `summary$e 要素のうち，最初のもの
◎
summary elements that are the first summary element child of a details element
</li>
					<li>
`draggable$a 属性を有する要素のうち、
~UAが［
利用者が~pointing装置を利用することなく，その要素~用の~drag操作oを始める
］ことを可能化するもの。
◎
Elements with a draggable attribute set, if that would enable the user agent to allow the user to begin drag operations for those elements without the use of a pointing device
</li>
					<li>
`編集中の~host$
◎
Editing hosts
</li>
					<li>
`~navigable容器$
◎
Navigable containers
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
<p>
`~tabindex値$ ~NEQ ~NULL の場合、
要素を`~focus可能な区画$と見なすモノトスル。
加えて：

<!-- 
must consider the element as 
と
must allow the element to be considered as
の違いはどこに？
-->
◎
↓</p>
		<ul>
			<li>
<p>
`~tabindex値$ ~LT 0 の場合、
要素を`~tabindex順な~focus~navi視野$からは外すベキである。
◎
If the value is a negative integer
◎
The user agent must consider the element as a focusable area, but should omit the element from any tabindex-ordered focus navigation scope.
</p>

<p class="note">注記：
［
要素を逐次的~focus~naviから外すとする，作者からの要件
］を無視する妥当な理由としては、［
利用者が~focusを移動する仕組みが，逐次的~focus~naviの他にない場合
］が挙げられる。
一例として、［
~keyboardのみの利用者は、
負な `tabindex$a を伴う~text~controlを~clickできない
］ので，~UAが［
利用者が~tab~UIkeyで当の~controlへ移れる
］ようにすることは正当化される。
◎
One valid reason to ignore the requirement that sequential focus navigation not allow the author to lead to the element would be if the user's only mechanism for moving the focus is sequential focus navigation. For instance, a keyboard-only user would be unable to click on a text control with a negative tabindex, so that user's user agent would be well justified in allowing the user to tab to the control regardless.
</p>
			</li>
			<li>
`~tabindex値$ ~GTE 0 の場合、［
要素, および それを`~DOM~anchor$とする`~focus可能な区画$
］は`逐次的に~focus可能$にするベキである。
◎
If the value is a zero
◎
The user agent must allow the element to be considered as a focusable area and should allow the element and any focusable areas that have the element as their DOM anchor to be sequentially focusable.
◎
↓↓The relative ordering within a tabindex-ordered focus navigation scope for elements and focusable areas that belong to the same focus navigation scope and whose tabindex value is zero should be in shadow-including tree order.
◎
If the value is greater than zero
◎
The user agent must allow the element to be considered as a focusable area and should allow the element and any focusable areas that have the element as their DOM anchor to be sequentially focusable,＼
</li>
		</ul>
	</li>
	<li>
<p>
同じ`~focus~navi視野$に属する［
要素, `~focus可能な区画$
］ものたちの［
`~tabindex順な~focus~navi視野$の中での順序
］は、
以下に従うベキである：
</p>

		<ul>
			<li>
［
`~tabindex値$ ~GT 0
］なるものは、
他のものより先にする。
</li>
			<li>
［
`~tabindex値$ ~GT 0
］なるものどうしの順序は、
`~tabindex値$の昇順にする（値が小さいものが先）。
</li>
			<li>
［
`~tabindex値$ ~GTE 0
］かつ`~tabindex値$が同じものどうしの順序は、
`~DOM~anchor$の`~shadowも含めた~tree順序$に従う。
</li>
		</ul>

<p class="trans-note">【
`~tabindex値$が［
負なものどうし／
負なものと 0 のものどうし
］の順序は、
定義されていない
（元々、`~tabindex順な~focus~navi視野$からは外す “ベキ” とされている）。
同じ`~DOM~anchor$を共有するものどうしの順序も、
定義されていない。
】</p>

◎
and should place the element — referenced as candidate below — and the aforementioned focusable areas in the tabindex-ordered focus navigation scope where the element is a part of so that, relative to other elements and focusable areas that belong to the same focus navigation scope, they are:
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has been omitted or whose value, when parsed, returns an error,
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to or less than zero,
◎
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than zero but less than the value of the tabindex attribute on candidate,
◎
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is located earlier than candidate in shadow-including tree order,
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is located later than candidate in shadow-including tree order, and
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than the value of the tabindex attribute on candidate.
</li>
</ul>

<p>
`tabIndex@m
~IDL属性は、
`tabindex$a 内容~属性の値を`反映する$モノトスル。
その`既定の値$は、［
次に挙げる要素においては 0 ／
~ELSE_ −1
］とする
⇒＃
`area$e,
`button$e,
`frame$e,
`iframe$e,
`input$e,
`object$e,
`select$e,
`textarea$e,
~SVG `a＠~SVGlinking#elementdef-a$e,
`親~details用の~summary$
◎
The tabIndex IDL attribute must reflect the value of the tabindex content attribute.＼
The default value is 0 if the element is an a, area, button, frame, iframe, input, object, select, textarea, or SVG a element, or is a summary element that is a summary for its parent details. The default value is −1 otherwise.
</p>

<p class="note">注記：
要素~型に応じて既定の値が変わるのは、
歴史的な遺物である。
◎
The varying default value based on element type is a historical artifact.
</p>

			</section>
			<section id="focus-processing-model">
<h4 title="Processing model">6.6.4. 処理~model</h4>

<div class="algo">
<p>
`~focus可能な区画を取得する@
ときは、
所与の
( %~target, 文字列 %~focus誘発元 （省略時は `other^l ） )
に対し，次の手続きを走らす：
◎
To get the focusable area for a focus target that is either an element that is not a focusable area, or is a navigable, given an optional string focus trigger (default "other"), run the first matching set of steps from the following list:
</p>
<ol>
	<li>
~Assert：
%~target は次のいずれかである
⇒
`~focus可能な区画$でない要素 ／ `~navigable$
◎
↑</li>
	<li>
~IF［
%~target は `area$e 要素である
］~AND［
%~target は`~focus可能な図形$を定義している
］
⇒
~RET それらの図形の`~DOM~anchor$のうち，`~tree順序$で最初のもの
◎
If focus target is an area element with one or more shapes that are focusable areas
• Return the shape corresponding to the first img element in tree order that uses the image map to which the area element belongs.
</li>
	<li>
~IF［
%~target は要素である
］~AND［
%~target は 1 個以上の［
`~focus可能な区画$である~scroll可能な領域
］を伴う
］
⇒
~RET それらの領域のうち，`~DOM~anchor$が［
`平坦~tree$における`~tree順序$（前順, 深さ優先の順序）で最初に来る
］もの
`CSSSCOPING$r
◎
If focus target is an element with one or more scrollable regions that are focusable areas
• Return the element's first scrollable region, according to a pre-order, depth-first traversal of the flat tree. [CSSSCOPING]
</li>
	<li>
~IF［
%~target は`文書~要素$である
］
⇒
~RET %~target の`文書$の`表示域$
◎
If focus target is the document element of its Document
• Return the Document's viewport.
</li>
	<li>
~IF［
%~target は`~navigable$である
］
⇒
~RET %~target にて`作動中な文書$nav
◎
If focus target is a navigable
• Return the navigable's active document.
</li>
	<li>
~IF［
%~target は`~navigable容器$である
］~AND［
%~target の`内容~navigable$ %N ~NEQ ~NULL
］
⇒
~RET %N にて`作動中な文書$nav
◎
If focus target is a navigable container with a non-null content navigable
• Return the navigable container's content navigable's active document.
</li>
	<li>
<p>
~IF［
%~target は`~shadow~host$である
］~AND［
%~target の`~shadow根$elmの`~focusを委任するか$sR ~EQ ~T
］：
◎
If focus target is a shadow host whose shadow root's delegates focus is true
</p>
		<ol>
			<li>
%被focus要素 ~LET `現在の被focus区画$tlTの`~DOM~anchor$
◎
Let focusedElement be the currently focused area of a top-level traversable's DOM anchor.
</li>
			<li>
~IF［
%~target は %被focus要素 の`~shadowも含めた広義-先祖$である
］
⇒
~RET %被focus要素
◎
If focus target is a shadow-including inclusive ancestor of focusedElement, then return focusedElement.
</li>
			<li>
~RET `~focus委任-先$( %~target, %~focus誘発元 )
◎
Return the focus delegate for focus target given focus trigger.
</li>
		</ol>

<p class="note">注記：
`逐次的に~focus可能$かどうかについては、［
`~shadow~host$,
`~focusを委任するか$sR
］の取扱いは，`逐次的~focus~navi順序$を構築するとき行われる。
すなわち，そのような`~shadow~host$に対しては、
逐次的~focus~naviの一部として
`~objを~focusする$() が~callされることは決してない。
◎
For sequential focusability, the handling of shadow hosts and delegates focus is done when constructing the sequential focus navigation order. That is, the focusing steps will never be called on such shadow hosts as part of sequential focus navigation.
</p>
	</li>
	<li>
~RET ~NULL
◎
Otherwise
• Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~focus委任-先@
は、
所与の
( %~target, 文字列 %~focus誘発元（省略時は `other^l ） )
に対し，次の手続きを走らす：
◎
The focus delegate for a focusTarget, given an optional string focusTrigger (default "other"), is given by the following steps:
</p>
<ol>
	<li>
~IF［
%~target は`~shadow~host$である
］~AND［
%~target の`~shadow根$elmの`~focusを委任するか$sR ~EQ ~F
］
⇒
~RET ~NULL
◎
If focusTarget is a shadow host and its shadow root's delegates focus is false, then return null.
</li>
	<li>
%~~注目先 ~LET %~target
◎
Let whereToLook be focusTarget.
</li>
	<li>
~IF［
%~~注目先 は`~shadow~host$である
］
⇒
%~~注目先 ~SET %~~注目先 の`~shadow根$elm
◎
If whereToLook is a shadow host, then set whereToLook to whereToLook's shadow root.
</li>
	<li>
%自動focus委任-先 ~LET `自動focus委任-先$( %~~注目先, %~focus誘発元 )
◎
Let autofocusDelegate be the autofocus delegate for whereToLook given focusTrigger.
</li>
	<li>
~IF［
%自動focus委任-先 ~NEQ ~NULL
］
⇒
~RET %自動focus委任-先
◎
If autofocusDelegate is not null, then return autofocusDelegate.
</li>
	<li>
<p>
%~~注目先 の
~EACH( `子孫$ %子孫 )
に対し，`~tree順序$で：
◎
For each descendant of whereToLook's descendants, in tree order:
</p>
		<ol>
			<li>
<p>
~IF［
~OR↓
］…
</p>
				<ul>
					<li>
［
%~target は `dialog$e 要素である
］~AND［
%子孫 は`逐次的に~focus可能$である
］
</li>
					<li>
［
%~target は `dialog$e 要素でない
］~AND［
%子孫 は`~focus可能な区画$である
］
</li>
				</ul>
<p>
…ならば
⇒
~RET %子孫
</p>
◎
Let focusableArea be null.
◎
If focusTarget is a dialog element and descendant is sequentially focusable, then set focusableArea to descendant.
◎
Otherwise, if focusTarget is not a dialog and descendant is a focusable area, set focusableArea to descendant.
◎
↓</li>
			<li>
<p>
%~focus可能な区画 ~LET `~focus可能な区画を取得する$( %子孫, %~focus誘発元 )
◎
Otherwise, set focusableArea to the result of getting the focusable area for descendant given focusTrigger.
</p>

<p class="note">注記：
この段は，この~algoに再帰し得る
— すなわち、
`~focus可能な区画を取得する$手続きは，
%子孫 の`~focus委任-先$を返すかもしれない。
◎
This step can end up recursing, i.e., the get the focusable area steps might return the focus delegate of descendant.
</p>
			</li>
			<li>
~IF［
%~focus可能な区画 ~NEQ ~NULL
］
⇒
~RET %~focus可能な区画
◎
If focusableArea is not null, then return focusableArea.
</li>
		</ol>
<p class="note">注記：
ここでは、
`~shadowも含めた子孫$は`~~注目しない^emで`子孫$に限り~~注目することが，重要になる。
`~shadow~host$は、
代わりに，上で言及した再帰的な事例により取扱われる。
◎
It's important that we are not looking at the shadow-including descendants here, but instead only at the descendants. Shadow hosts are instead handled by the recursive case mentioned above.
</p>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

<p class="note">注記：
上の~algoは、
本質的に，［
相応しい`~focus可能な区画$のうち，次に該当する最初のもの
］を返す
⇒
その`~DOM~anchor$から %~target までの経路では、
どの~shadow~tree境界においても~focusを委任する
◎
The above algorithm essentially returns the first suitable focusable area where the path between its DOM anchor and focusTarget delegates focus at any shadow tree boundaries.
</p>
</div>

<div class="algo">
<p>
`自動focus委任-先@
は、
所与の
( %~target, %~focus誘発元 )
に対し，次の手続きを走らす：
◎
The autofocus delegate for a focus target given a focus trigger is given by the following steps:
</p>
<ol>
	<li>
<p>
%~target の
~EACH( `子孫$ %子孫 )
に対し，`~tree順序$で：
◎
For each descendant descendant of focus target, in tree order:
</p>
		<ol>
			<li>
~IF［
%子孫 は `autofocus$a 内容~属性を有さない
］
⇒
~CONTINUE
◎
If descendant does not have an autofocus content attribute, then continue.
</li>
			<li>
%~focus可能な区画 ~LET ［
%子孫 は`~focus可能な区画$であるならば %子孫 ／
~ELSE_ `~focus可能な区画を取得する$( %子孫, %~focus誘発元 )
］
◎
Let focusable area be descendant, if descendant is a focusable area; otherwise let focusable area be the result of getting the focusable area for descendant given focus trigger.
</li>
			<li>
~IF［
%~focus可能な区画 ~EQ ~NULL
］
⇒
~CONTINUE
◎
If focusable area is null, then continue.
</li>
			<li>
~IF［
%~focus可能な区画 は`~clickで~focus可能$でない
］~AND［
%~focus誘発元 ~EQ `click^l
］
⇒
~CONTINUE
◎
If focusable area is not click focusable and focus trigger is "click", then continue.
</li>
			<li>
~RET %~focus可能な区画
◎
Return focusable area.
</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~objを~focusする@
ときは、
所与の
( %~target, %~fallback~target （省略時は ε ）, 文字列 %~focus誘発元 （省略時は ε ） )
に対し，次の手続きを走らす：
◎
The focusing steps for an object new focus target that is either a focusable area, or an element that is not a focusable area, or a navigable, are as follows. They can optionally be run with a fallback target and a string focus trigger.
</p>

<ol>
	<li>
~Assert：
%~target は次のいずれかである
⇒
`~focus可能な区画$ ／
`~focus可能な区画$でない要素 ／
`~navigable$
◎
↑</li>
	<li>
~IF［
%~target は`~focus可能な区画$でない
］
⇒
%~target ~SET `~focus可能な区画を取得する$( %~target, %~focus誘発元 )
◎
If new focus target is not a focusable area, then set new focus target to the result of getting the focusable area for new focus target, given focus trigger if it was passed.
</li>
	<li>
<p>
~IF［
%~target ~EQ ~NULL
］：
◎
If new focus target is null, then:
</p>
		<ol>
			<li>
~IF［
%~fallback~target ~EQ ε
］
⇒
~RET
◎
If no fallback target was specified, then return.
</li>
			<li>
%~target ~SET %~fallback~target
◎
Otherwise, set new focus target to the fallback target.
</li>
		</ol>
	</li>
	<li>
~IF［
%~target は`~navigable容器$である
］~AND［
%~target の`内容~navigable$ %N ~NEQ ~NULL
］
⇒＃
%~target ~SET %N にて`作動中な文書$nav
◎
If new focus target is a navigable container with non-null content navigable, then set new focus target to the content navigable's active document.
</li>
	<li>
~IF［
%~target は`~focus可能な区画$である
］~AND［
%~target の`~DOM~anchor$は`不活$である
］
⇒
~RET
◎
If new focus target is a focusable area and its DOM anchor is inert, then return.
</li>
	<li>
~IF［
%~target ~EQ `現在の被focus区画$tlT
］
⇒
~RET
◎
If new focus target is the currently focused area of a top-level traversable, then return.
</li>
	<li>
%旧-鎖 ~LET ［
%~target が見出される`~top-level辿可能$
］の`現在の~focus鎖$tlT
◎
Let old chain be the current focus chain of the top-level traversable in which new focus target finds itself.
</li>
	<li>
%新-鎖 ~LET %~target の`~focus鎖$
◎
Let new chain be the focus chain of new focus target.
</li>
	<li>
`~focusを更新する$( %旧-鎖, %新-鎖, %~target )
◎
Run the focus update steps with old chain, new chain, and new focus target respectively.
</li>
</ol>
</div>

<div class="algo">
<p>
~UAは，利用者が［
`~focus可能な区画$ ／ `~navigable$
］ %候補 に~focusを移動しようと試みたときには、
`即時に$次を走らすモノトスル
⇒
`~objを~focusする$( %候補 )
◎
User agents must immediately run the focusing steps for a focusable area or navigable candidate whenever the user attempts to move the focus to candidate.
</p>
</div>

<div class="algo">
<p>
`~objを~unfocusする@
ときは、
所与の
( ［ `~focus可能な区画$ ／ `~focus可能な区画$でない要素 ］ %旧-~target )
に対し，次の手続きを走らす：
◎
The unfocusing steps for an object old focus target that is either a focusable area or an element that is not a focusable area are as follows:
</p>
<ol>
	<li>
%辿可能 ~LET %旧-~target が見出される`~top-level辿可能$
◎
↓</li>
	<li>
%現在の被focus区画 ~SET %辿可能 の`現在の被focus区画$tlT
◎
↓</li>
	<li>
<p>
~Assert：
%現在の被focus区画 ~NEQ ~NULL
</p>
<p class="trans-note">【
この段までは、
以下を［
集約する／明確化する
］ための，この訳による追加。
原文には［
%現在の被focus区画 ~EQ ~NULL
］の場合に対する取扱いが述べられていないが、
その事例は生じ得ないので省略されたと思われる。
】</p>
◎
↓</li>
	<li>
<p>
~IF［
%旧-~target は`~shadow~host$である
］~AND［
%旧-~target の`~shadow根$elmは ~AND↓ を満たす
］…
</p>
		<ul>
			<li>
その`~focusを委任するか$sR ~EQ ~T
</li>
			<li>
%現在の被focus区画 の`~DOM~anchor$の`~shadowも含めた広義-先祖$である
</li>
		</ul>
<p>
…ならば
⇒
%旧-~target ~SET %現在の被focus区画
</p>
◎
If old focus target is a shadow host whose shadow root's delegates focus is true, and old focus target's shadow root is a shadow-including inclusive ancestor of the currently focused area of a top-level traversable's DOM anchor, then set old focus target to that currently focused area of a top-level traversable.
</li>
	<li>
~IF［
%旧-~target は`不活$である
］
⇒
~RET
◎
If old focus target is inert, then return.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
［
%現在の被focus区画 は`~focus可能な図形$である
］~AND［
 %旧-~target は その図形を定義している `area$e 要素である
</li>
			<li>
［
%現在の被focus区画 は~scroll可能な領域である
］~AND［
%旧-~target は その~scroll可能な領域を有する要素である
］
</li>
		</ul>
<p>
…ならば
⇒
%旧-~target ~SET %現在の被focus区画
</p>
◎
If old focus target is an area element and one of its shapes is the currently focused area of a top-level traversable, or, if old focus target is an element with one or more scrollable regions, and one of them is the currently focused area of a top-level traversable, then let old focus target be that currently focused area of a top-level traversable.
</li>
	<li>
%旧-鎖 ~LET %辿可能 の`現在の~focus鎖$tlT
◎
Let old chain be the current focus chain of the top-level traversable in which old focus target finds itself.
</li>
	<li>
~IF［
%旧-~target ~NIN %旧-鎖
］
⇒
~RET
◎
If old focus target is not one of the entries in old chain, then return.
</li>
	<li>
~IF［
%旧-~target は`~focus可能な区画$でない
］
⇒
~RET
◎
If old focus target is not a focusable area, then return.
</li>
	<li>
%~top文書 ~LET %旧-鎖 の最後の~entry
◎
Let topDocument be old chain's last entry.
</li>
	<li>
~IF［
%~top文書 の`~node~navigable$は`~system~focus$を得ている
］
⇒
`~objを~focusする$( %~top文書 の`表示域$ )
◎
If topDocument's node navigable has system focus, then run the focusing steps for topDocument's viewport.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise,＼
</p>
		<ol>
			<li>
%~top文書 の`~node~navigable$から`~system~focus$を除去するための，~platformに特有な関連な規約を適用する
◎
apply any relevant platform-specific conventions for removing system focus from topDocument's node navigable,＼
</li>
			<li>
`~focusを更新する$( %旧-鎖, 空~list, ~NULL )
◎
and run the focus update steps given old chain, an empty list, and null.
</li>
		</ol>
	</li>
</ol>
</div>

<p class="note">注記：
`~objを~unfocusする$ことにより，常に~focusが変更されるとは限らない
— `現在の被focus区画$tlTに適用されるときであっても。
例えば，
`現在の被focus区画$tlTは`表示域$である場合、
通例的には，［
`~objを~focusする$ことにより，別の`~focus可能な区画$が明示的に~focusされる
］までは［
その~focusを保つ
］ことになる。
◎
The unfocusing steps do not always result in the focus changing, even when applied to the currently focused area of a top-level traversable. For example, if the currently focused area of a top-level traversable is a viewport, then it will usually keep its focus regardless until another focusable area is explicitly focused with the focusing steps.
</p>

<hr>

<div class="algo">
<p>
`~focusを更新する@
ときは、
所与の
( %旧-鎖, %新-鎖, %新-~target )
に対し，次の手続きを走らす：
◎
The focus update steps, given an old chain, a new chain, and a new focus target respectively, are as follows:
</p>

<ol>
	<li>
~WHILE［
%旧-鎖 内の最後の~entry ~EQ %新-鎖 内の最後の~entry
］
⇒＃
%旧-鎖 内から最後の~entryを~popする；
%新-鎖 内から最後の~entryを~popする
◎
If the last entry in old chain and the last entry in new chain are the same, pop the last entry from old chain and the last entry from new chain and redo this step.
</li>
	<li>
<p>
%旧-鎖 を成す
~EACH( ~entry %~entry )
に対し：
◎
For each entry entry in old chain, in order, run these substeps:
</p>
		<ol>
			<li id="unfocus-causes-change-event">
<p>
~IF［
~AND↓
］…
</p>
				<ul>
					<li>
%~entry は `input$e 要素 %要素 である
</li>
					<li>
%要素 には `change$et ~eventが`適用される＠~HEinput#concept-input-apply$
</li>
					<li>
%要素 には`作動化の挙動$は定義されていない
</li>
					<li>
%要素 が~focusされている間に，利用者は %要素 の［
`値$fe ／ `選択された~file~list$
］を変更していて、
その（~controlが最初に~focusされたときと異なるような）変更はまだ~commitされていない
</li>
				</ul>
<p>
…ならば
⇒
`入力~eventを発火する$( %要素, `change$et )
</p>
◎
If entry is an input element, and the change event applies to the element, and the element does not have a defined activation behavior, and the user has changed the element's value or its list of selected files while the control was focused without committing that change (such that it is different to what it was when the control was first focused), then fire an event named change at the element, with the bubbles attribute initialized to true.
</li>
			<li>
%~blur~event~target ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry は要素である
］
⇒
%~blur~event~target ~LET %~entry
◎
If entry is an element, let blur event target be entry.
</li>
			<li>
~ELIF［
%~entry は`文書$である
］
⇒
%~blur~event~target ~LET %~entry に`関連な大域~obj$
◎
If entry is a Document object, let blur event target be that Document object's relevant global object.
◎
Otherwise, let blur event target be null.
</li>
			<li>
%関係する~target ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry ~EQ %旧-鎖 内の最後の~entry
］~AND［
%~entry は`要素$である
］~AND［
%新-鎖 内の最後の~entryは`要素$である
］
⇒
%関係する~target ~LET %新-鎖 内の最後の~entry
◎
If entry is the last entry in old chain, and entry is an Element, and the last entry in new chain is also an Element, then let related blur target be the last entry in new chain. Otherwise, let related blur target be null.
</li>
			<li>
<p>
~IF［
%~blur~event~target ~NEQ ~NULL
］
⇒
`~focus~eventを発火する$( %~blur~event~target, `blur$et, %関係する~target )
◎
If blur event target is not null, fire a focus event named blur at blur event target, with related blur target as the related target.
</p>

<p class="note" id="note-sometimes-no-blur-event">注記：
~eventは発火されない事例もある
— 例えば、
%~entry は［
`~focus可能な図形$ ／ ~scroll可能な領域 ／ `表示域$
］であるとき。
◎
In some cases, e.g., if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%新-~target の~focus時に，~platformに特有な関連な規約がある
］
⇒
その規約を適用する
（例えば，一部の~platformは、
~text~controlに~focusされたときに，その内容を選択する）
◎
Apply any relevant platform-specific conventions for focusing new focus target. (For example, some platforms select the contents of a text control when that control is focused.)
</li>
	<li>
<p>
%新-鎖 を成す
~EACH( ~entry %~entry )
に対し，逆順に：
◎
For each entry entry in new chain, in reverse order, run these substeps:
</p>
		<ol>
			<li>
<p>
~IF［
%~entry は`~focus可能な区画$である
］~AND［
%~entry が`指名する被focus区画$doc ~NEQ %~entry
］：
◎
If entry is a focusable area, and the focused area of the document is not entry:
</p>
				<ol>
					<li>
%文書 に`関連な大域~obj$の`~navi~API$の`進行中な~naviの間に~focusは変化したか$ ~SET ~T
◎
Set document's relevant global object's navigation API's focus changed during ongoing navigation to true.
</li>
					<li>
%~entry が属する`文書$が`指名する被focus区画$doc ~SET %~entry
◎
Designate entry as the focused area of the document.
</li>
				</ol>
			</li>
			<li>
%~focus~event~target ~LET %~entry に応じて
⇒＃
要素であるならば %~entry ／
`文書$であるならば %~entry に`関連な大域~obj$ ／
~ELSE_ ~NULL
◎
If entry is an element, let focus event target be entry.
◎
If entry is a Document object, let focus event target be that Document object's relevant global object.
◎
Otherwise, let focus event target be null.
</li>
			<li>
%関係する~target ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry ~EQ %新-鎖 内の最後の~entry
］~AND［
%~entry は`要素$である
］~AND［
%旧-鎖 内の最後の~entryは`要素$である
］
⇒
%関係する~target ~SET %旧-鎖 内の最後の~entry
◎
If entry is the last entry in new chain, and entry is an Element, and the last entry in old chain is also an Element, then let related focus target be the last entry in old chain. Otherwise, let related focus target be null.
</li>
			<li>
<p>
~IF［
%~focus~event~target ~NEQ ~NULL
］
⇒
`~focus~eventを発火する$( %~focus~event~target, `focus$et, %関係する~target )
◎
If focus event target is not null, fire a focus event named focus at focus event target, with related focus target as the related target.
</p>

<p class="note">注記：
~eventは発火されない事例もある
— 例えば、
%~entry は［
`~focus可能な図形$ ／ ~scroll可能な領域 ／ `表示域$
］であるとき。
◎
In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.
</p>

			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~focus~eventを発火する@
ときは、
所与の
( 要素 %~target, 名前 %e, 関係する~target %r )
に対し
⇒
`~eventを発火する$( %~target, %e, `FocusEvent$I )
— 次のように初期化して
⇒＃
`relatedTarget$m 属性 ~SET %r,
`view$m 属性 ~SET %~target の`~node文書$に`関連な大域~obj$,
`~composedか$ev ~SET ~T
◎
To fire a focus event named e at an element t with a given related target r, fire an event named e at t, using FocusEvent, with the relatedTarget attribute initialized to r, the view attribute initialized to t's node document's relevant global object, and the composed flag set.
</p>
</div>

<hr>

<div class="algo">
<p>
~UAは、
`~top-level辿可能$ %辿可能 内で~UIkey~event %~event を届けるときは，
次の手続きを走らすモノトスル：
◎
When a key event is to be routed in a top-level traversable, the user agent must run the following steps:
</p>
<ol>
	<li>
%~target区画 ~LET %辿可能 の`現在の被focus区画$tlT
◎
Let target area be the currently focused area of the top-level traversable.
</li>
	<li>
~Assert：
%~target区画 は ~NULL でない
— ~UIkey~eventが届けられる`~top-level辿可能$は、
`~system~focus$を得ているものに限られるので。
したがって、
%~target区画 は`~focus可能な区画$である。
◎
Assert: target area is not null, since key events are only routed to top-level traversables that have system focus. Therefore, target area is a focusable area.
</li>
	<li>
%~target~node ~LET %~target区画 の`~DOM~anchor$
◎
Let target node be target area's DOM anchor.
</li>
	<li>
~IF［
%~target~node は`文書$である
］
⇒
%~target~node ~SET ［
%~target~node の`~body要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %~target~node の`文書~要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %~target~node
］
◎
If target node is a Document that has a body element, then let target node be the body element of that Document.
◎
Otherwise, if target node is a Document object that has a non-null document element, then let target node be that document element.
</li>
	<li>
~IF［
%~target~node は`不活$である
］
⇒
~RET
◎
If target node is not inert, then:
</li>
	<li>
%取扱えるか ~LET `~eventを配送する$( %~target~node, %~event )
◎
Let canHandle be the result of dispatching the key event at target node.
</li>
	<li>
~IF［
%取扱えるか ~EQ ~T
］
⇒
%~target区画 に %~event を取扱わせる
— これは、
%~target~node に向けて`~click~eventを発火する$ことも含み得る。
◎
If canHandle is true, then let target area handle the key event. This might include firing a click event at target node.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
所与の`文書$ %~target は、
所与の時点で，次の手続きが ~T を返すならば
`~focusを得ている@
とされる：
◎
The has focus steps, given a Document object target, are as follows:
</p>

<ol>
	<li>
%N ~LET %~target の`~node~navigable$の`~top-level辿可能$nav
◎
↓</li>
	<li>
~IF［
%N は`~system~focus$を得ていない
］
⇒
~RET ~F
◎
If target's node navigable's top-level traversable does not have system focus, then return false.
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
%候補 ~LET %N にて`作動中な文書$nav
</li>
			<li>
~IF［
%候補 ~EQ %~target
］
⇒
~RET ~T
</li>
			<li>
%F ~LET %候補 が`指名する被focus区画$doc
</li>
			<li>
~IF［
%F は`~navigable容器$でない
］
⇒
~RET ~F
</li>
			<li>
%N ~SET %F の`内容~navigable$
</li>
			<li>
~IF［
%N ~EQ ~NULL
］
⇒
~RET ~F
</li>
		</ol>
◎
Let candidate be target's node navigable's top-level traversable's active document.
◎
While true:
• If candidate is target, then return true.
• If the focused area of candidate is a navigable container with a non-null content navigable, then set candidate to the active document of that navigable container's content navigable.
• Otherwise, return false.
</li>
</ol>
</div>

			</section>
			<section id="sequential-focus-navigation">
<h4 title="Sequential focus navigation">6.6.5. 逐次的~focus~navi</h4>

<p>
所与の`文書$に属する`~focus可能な区画$のうち いくつかは，
`逐次的~focus~navi順序@
により順序付けられる：
◎
Each Document has a sequential focus navigation order, which orders some or all of the focusable areas in the Document relative to each other.＼
</p>

<ul>
	<li>
<p>
その内容と順序付けは、
当の文書の`平坦~化された~tabindex順な~focus~navi視野$により与えられる。
◎
Its contents and ordering are given by the flattened tabindex-ordered focus navigation scope of the Document.
</p>

<p class="note">
`平坦~化された~tabindex順な~focus~navi視野$を定義している規則から、
この順序付けは，当の文書の`~tree順序$に関係するとは限らない。
◎
Per the rules defining the flattened tabindex-ordered focus navigation scope, the ordering is not necessarily related to the tree order of the Document.
</p>
	</li>
	<li>
この順序から外された`~focus可能な区画$は、
`逐次的~focus~navi$を介しては到達-可能でなくなる。
◎
If a focusable area is omitted from the sequential focus navigation order of its Document, then it is unreachable via sequential focus navigation.
</li>
</ul>

<p>
逐次的~focus~naviには
`逐次的~focus~naviの始点@
もある。
それは、
初期~時には ε （未設定）とする。
~UAは、
利用者がそれを移動すべく指示したときに，この始点を設定してもヨイ。
◎
There can also be a sequential focus navigation starting point. It is initially unset. The user agent may set it when the user indicates that it should be moved.
</p>

<p class="example">
例えば~UAは、
利用者が文書の内容を~clickしたときに，
その~click位置に設定することもできる。
◎
For example, the user agent could set it to the position of the user's click if the user clicks on the document contents.
</p>

<p class="note">注記：
~UAには、
`素片へ~navigateする$ときには，
`逐次的~focus~naviの始点$を`~target要素$に設定することが要求される。
◎
User agents are required to set the sequential focus navigation starting point to the target element when navigating to a fragment.
</p>

<div class="algo">
<div class="p">
<p>
~UAは、
利用者から~focusを移動するよう要請されたとき
— 一例として：
</p>
<ul>
	<li>
ある`~top-level辿可能$ %top 内で，
</li>
	<li>
		<ul>
			<li>
(A) %top の`現在の被focus区画$tlTから, または
</li>
			<li>
(B) %top の外側（例えば，~browserの所在~bar）から 先ず %top へ~focusを移動した上で，
</li>
		</ul>
	</li>
	<li>
ある %方向 ［
`前方^i または `後方^i
］へ，
</li>
	<li>
~focusを移動するよう要請された
</li>
</ul>
<p>
ときには（例えば， `Tab^Key ~UIkeyを押すことによる既定の動作として）、
以下の~algoを利用するモノトスル：
</p>

<p class="note">注記：
概して、［
`Tab^Key ／［
`Shift^Key + `Tab^Key
］］を押すことは［
前方／後方
］にある~controlへ移動することを要請する。
</p>

◎
When the user requests that focus move from the currently focused area of a top-level traversable to the next or previous focusable area (e.g. as the default action of pressing the tab key), or when the user requests that focus sequentially move to a top-level traversable in the first place (e.g. from the browser's location bar), the user agent must use the following algorithm:
</div>

<ol>
	<li>
%始点 ~LET 上述の［
(A) ならば %top の`現在の被focus区画$tlT ／ (B) ならば %top
］
◎
Let starting point be the currently focused area of a top-level traversable, if the user requested to move focus sequentially from there, or else the top-level traversable itself, if the user instead requested to move focus from outside the top-level traversable.
</li>
	<li>
%~focus始点 ~LET `逐次的~focus~naviの始点$
◎
↓</li>
	<li>
~IF［
%~focus始点 ~NEQ ε
］~AND［
%~focus始点 は %始点 の内側にある
］
⇒
%始点 ~SET %~focus始点
◎
If there is a sequential focus navigation starting point defined and it is inside starting point, then let starting point be the sequential focus navigation starting point instead.
◎
Let direction be forward if the user requested the next control, and backward if the user requested the previous control.
◎
Typically, pressing tab requests the next control, and pressing shift + tab requests the previous control.
</li>
	<li>
<p>
~WHILE 無条件：
◎
Loop:＼
</p>
		<ol>
			<li>
%選定法 ~LET ［
次が満たされるならば `逐次的^i ／
~ELSE_ `~DOM順^i
］：
⇒
［
%始点 は`~navigable$である
］~OR［
%始点 ~IN %始点 が属する`文書$の`逐次的~focus~navi順序$
］
◎
Let selection mechanism be sequential if the starting point is a navigable or if starting point is in its Document's sequential focus navigation order.
◎
Otherwise, starting point is not in its Document's sequential focus navigation order; let selection mechanism be DOM.
</li>
			<li>
%候補 ~LET `逐次的~navi探索~algo$( %始点, %方向, %選定法 )
◎
Let candidate be the result of running the sequential navigation search algorithm with starting point, direction, and selection mechanism as the arguments.
</li>
			<li>
~IF［
%候補 ~NEQ ~NULL
］
⇒＃
`~objを~focusする$( %候補 )；
~RET
◎
If candidate is not null, then run the focusing steps for candidate and return.
</li>
			<li>
`逐次的~focus~naviの始点$ ~SET ε
◎
Otherwise, unset the sequential focus navigation starting point.
</li>
			<li>
<p>
~IF［
%始点 ~EQ %top
］~OR［
%始点 は %top 内の`~focus可能な区画$である
］：
◎
If starting point is a top-level traversable, or a focusable area in the top-level traversable,＼
</p>
				<ol>
					<li>
<p>
~IF［
~UAには、
自前の~focus可能な~controlがある
］
⇒
~UAは、
次を行うベキである
⇒
%方向 を尊守しつつ，~focusを自前の~focus可能な~controlのいずれかに適切に転送する
◎
the user agent should transfer focus to its own controls appropriately (if any), honouring direction, and then return.
</p>

<p class="example">
例えば，［
%方向 ~EQ `後方^i
］の場合、［
~browserの具現化~区画の直前にある，`逐次的に~focus可能$な~control
］に~focusすることになる。
◎
For example, if direction is backward, then the last sequentially focusable control before the browser's rendering area would be the control to focus.
</p>
					</li>
					<li>
<p>
~ELIF［
`逐次的に~focus可能$な~controlは無い
］
⇒
~UAは、
次を行ってもヨイ
⇒＃
%始点 ~SET %top；
~CONTINUE
</p>

<p class="example">
~kiosk~mode~browserなど、
自前の~focus可能な~controlがない~UAもあり得る。
</p>

◎
If the user agent has no sequentially focusable controls — a kiosk-mode browser, for instance — then the user agent may instead restart these steps with the starting point being the top-level traversable itself.
</li>
					<li>
~RET
◎
↑</li>
				</ol>
			</li>
			<li>
~ELSE（ %始点 は ある`子~navigable$ %N 内の`~focus可能な区画$である）
⇒
%始点 ~SET %N の`親$nav
◎
Otherwise, starting point is a focusable area in a child navigable. Set starting point to that child navigable's parent and return to the step labeled loop.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`逐次的~navi探索~algo@
は、所与の
( %始点, %方向, %選定法 )
に対し，次を走らす：
◎
The sequential navigation search algorithm consists of the following steps. This algorithm takes three arguments: starting point, direction, and selection mechanism.
</p>

<div >

<ol>
	<li>
%文書 ~LET %始点 に応じて
⇒＃
`~navigable$であるならば %始点 にて`作動中な文書$nav ／
`~focus可能な区画$であるならば %始点 が属する`文書$†1【 %始点 の`~DOM~anchor$の`~node文書$】
</li>
	<li>
%候補~群 ~LET %文書 の`逐次的~focus~navi順序$
</li>
	<li>
~Assert：
次が満たされるならば［
%始点 ~IN %候補~群 †2
］である
⇒
［
%始点 は`~focus可能な区画$である
］~AND［
%選定法 ~EQ `逐次的^i
］
【！ ↓ class="note" 】
</li>
	<li>
%候補~群 ~SET %候補~群 内の`~focus可能な区画$のうち，次を満たすものからなる集合†3
⇒
［
その`~DOM~anchor$は`不活$でない
］~AND［
`逐次的に~focus可能$である
］
</li>
	<li>
<p>
~IF［
%始点 は`~focus可能な区画$である
］
⇒
%候補~群 ~SET %候補~群 内の~focus可能な区画のうち， %方向 に応じて 次に該当するものからなる集合
⇒＃
`前方^i ならば %始点 に後続しているもの／
`後方^i ならば %始点 に先行しているもの
</p>

<p class="trans-note">【
明示的に言及されていないが、
順序は， %選定法 に応じて［
`逐次的^i ならば `逐次的~focus~navi順序$ ／
`~DOM順^i ならば （`平坦~tree$における）`~tree順序$
］に基づくと見受けられる。
一方で，次の次の段では、
%選定法 を問わず，`逐次的~focus~navi順序$に基づくと見受けられる。
】</p>

	</li>
	<li>
~IF［
%候補~群 は空である
］
⇒
~RET ~NULL
</li>
	<li>
%候補 ~SET %候補~群 内の~focus可能な区画のうち， %方向 に応じて
⇒＃
`前方^i ならば 最初のもの ／
`後方^i ならば 最後のもの
</li>
	<li>
~IF［
%候補 は`~navigable容器$でない
］
⇒
~RET %候補
</li>
	<li>
%~navigable ~LET %候補 の`内容~navigable$
</li>
	<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
~RET %候補
</li>
	<li>
%新-候補 ~LET `逐次的~navi探索~algo$( %~navigable, %方向, `逐次的^i )
</li>
	<li>
~IF［
%新-候補 ~NEQ ~NULL
］
⇒
~RET %新-候補
</li>
	<li>
~RET `逐次的~navi探索~algo$( %候補, %方向, %選定法 )
</li>
</ol>

<div class="trans-note">
<p>【
簡明にするため、
この手続きの~~構成は，原文から大きく違えている。
原文では、
この手続きにて次の用語が定義されている：
</p>
<ul>
	<li>
†1 を指して， %始点 の
`~home文書@
という。
</li>
	<li>
†2 を指して
— そこに記された条件が満たされる場合に限り —
%始点 の
`~home逐次的~focus~navi順序@
という。
</li>
	<li>
†3 を指して，
`相応しい逐次的に~focus可能な区画@
という。
</li>
</ul>
<p>
が、
これらの用語を利用しても無用に まわりくどくなるだけで
（現時点では）他からも参照されていないので、
この訳では利用しない。
】</p>
</div>

<ol lang="en" class="_en">
	<li>
<p>
Pick the appropriate cell from the following table, and follow the instructions in that cell.
<p>
The appropriate cell is the one that is from the column whose header describes direction and from the first row whose header describes starting point and selection mechanism.

<table><thead>
<tr><th>
<th>direction is forward
<th>direction is backward

<tbody><tr><th>
starting point is a navigable
<td>
Let candidate be the first suitable sequentially focusable area in starting point's active document, if any; or else null
<td>
Let candidate be the last suitable sequentially focusable area in starting point's active document, if any; or else null
<tr><th>
selection mechanism is DOM
<td>
Let candidate be the first suitable sequentially focusable area in the home document following starting point, if any; or else null
<td>
Let candidate be the last suitable sequentially focusable area in the home document preceding starting point, if any; or else null
<tr><th>
selection mechanism is sequential
<td>
Let candidate be the first suitable sequentially focusable area in the home sequential focus navigation order following starting point, if any; or else null
<td>
Let candidate be the last suitable sequentially focusable area in the home sequential focus navigation order preceding starting point, if any; or else null
</table>

<p>
A suitable sequentially focusable area is a focusable area whose DOM anchor is not inert and is sequentially focusable.
<p>
The home document is the Document to which starting point belongs.
<p>
The home sequential focus navigation order is the sequential focus navigation order to which starting point belongs.
<p class="note">
The home sequential focus navigation order is the home document's sequential focus navigation order, but is only used when the starting point is in that sequential focus navigation order (when it's not, selection mechanism will be DOM).
</p>
	<li>
<p>
If candidate is a navigable container with a non-null content navigable, then let new candidate be the result of running the sequential navigation search algorithm with candidate's content navigable as the first argument, direction as the second, and sequential as the third.
<p>
If new candidate is null, then let starting point be candidate, and return to the top of this algorithm. Otherwise, let candidate be new candidate.
	<li>
Return candidate.
</ol>
</div>
</div>

			</section>
			<section id="focus-management-apis">
<h4 title="Focus management APIs">6.6.6. ~focus管理~API</h4>

<pre class="idl">
dictionary `FocusOptions@I {
  boolean `preventScroll$m = false;
  boolean `focusVisible$m;
};
</pre>

<dl class="domintro">
	<dt>%documentOrShadowRoot.`activeElement$m</dt>
	<dd>
文書~内の要素のうち，~UIkey~eventが［
それを経て／それに向けて
］届けられることになるような，最も深い要素を返す。
これは概ね、
文書~内の~focusされた要素になる。
◎
Returns the deepest element in the document through which or to which key events are being routed. This is, roughly speaking, the focused element in the document.
</dd>
	<dd>
この~APIの目的においては、
`子~navigable$が~focusされるときには，その`容器$navが`親$navにて`作動中な文書$navの中で`~focusされる＠#bc-focus-ergo-bcc-focus$。
例えば，利用者が~focusを `iframe$e 内のある~text~controlに移動したとき、
その `iframe$e が，その`~node文書$の `activeElement$m から返される要素になる。
◎
For the purposes of this API, when a child navigable is focused, its container is focused within its parent's active document. For example, if the user moves the focus to a text control in an iframe, the iframe is the element returned by the activeElement API in the iframe's node document.
</dd>
	<dd>
類似に，~focusされた要素が
%documentOrShadowRoot とは異なる`~node~tree$内にある場合、
返される要素は，［
%documentOrShadowRoot は~focusされた要素の`~shadowも含めた広義-先祖$であるならば
%documentOrShadowRoot と同じ`~node~tree$内に所在する`~host$ ／
~ELSE_ ~NULL
］になる。
◎
Similarly, when the focused element is in a different node tree than documentOrShadowRoot, the element returned will be the host that's located in the same node tree as documentOrShadowRoot if documentOrShadowRoot is a shadow-including inclusive ancestor of the focused element, and null if not.
</dd>

	<dt>%document.`hasFocus()$m</dt>
	<dd>
~UIkey~eventは［
%document へ, または %document を経て
］届けられているならば ~T を返す。
~ELSE_ ~F を返す。
これは概ね、
~focusされている［
当の文書, または
その内側に入子にされている文書
］に対応する。
◎
Returns true if key events are being routed through or to the document; otherwise, returns false. Roughly speaking, this corresponds to the document, or a document nested inside this one, being focused.
</dd>

	<dt>%window.`focus()$m</dt>
	<dd>
~focusを %window に`対応する~navigable$（もしあれば）へ移動させる。
◎
Moves the focus to the window's navigable, if any.
</dd>

	<dt>%element.`focus$mE([ { `preventScroll$m: true } ])</dt>
	<dd>
~focusを %element へ移動させる。
◎
Moves the focus to the element.
</dd>
	<dd>
要素が`~navigable容器$である場合、
~focusは，代わりに 要素の`内容~navigable$へ移動される。
◎
If the element is a navigable container, moves the focus to its content navigable instead.
</dd>
	<dd>
既定では、
この~methodはまた，要素を~viewの中へ~scrollする。
`preventScroll$m ~optionを供して ~T に設定すれば、
この挙動は防止される。
◎
By default, this method also scrolls the element into view. Providing the preventScroll option and setting it to true prevents this behavior.
</dd>

	<dt>%element.`blur()$mE</dt>
	<dd>
~focusを`表示域$へ移動させる。
この~methodは、
利用しないことが奨励される。
`表示域$を~focusしたければ、
`文書$の`文書~要素$上で，
`focus()$mE ~methodを~callすること。
◎
Moves the focus to the viewport. Use of this method is discouraged; if you want to focus the viewport, call the focus() method on the Document's document element.
</dd>
	<dd>
~focus環が目障りであっても、
~focus環を隠すためにこの~methodを利用しないこと。
代わりに、
`focus-visible$ps 疑似類を利用して `outline$p ~prop（外形線）を上書きした上で，
~focusされる要素を示すような他の仕方を供すること。
そのような代替な~focus時の~styleを可用にできなかった場合、［
~keyboardを首に利用して~pageを~navigateしている者や，
~navigateし易くするため~focus外形線を利用している弱視者
］にとっては，~pageの使い勝手がすこぶる悪くなることに留意すること。
◎
Do not use this method to hide the focus ring if you find the focus ring unsightly. Instead, use the :focus-visible pseudo-class to override the 'outline' property, and provide a different way to show what element is focused. Be aware that if an alternative focusing style isn't made available, the page will be significantly less usable for people who primarily navigate pages using a keyboard, or those with reduced vision who use focus outlines to help them navigate the page.
</dd>
	<dd class="example">
<p>
例えば、
`textarea$e 要素の外形線を隠す代わりに，黄色な背景を利用して~focusを指示したければ、
次も利用できる：
◎
For example, to hide the outline from textarea elements and instead use a yellow background to indicate focus, you could use:
</p>

<pre class="lang-css">
textarea:focus-visible { outline: none; background: yellow; color: black; }
</pre>

	</dd>
</dl>

<div class="algo">
<p>
`DocumentOrShadowRoot$I の
`activeElement@m
取得子~手続きは：
◎
The activeElement attribute's getter must run these steps:
</p>
<ol>
	<li>
%候補 ~LET コレの`~node文書$が`指名する被focus区画$docの`~DOM~anchor$
◎
Let candidate be the DOM anchor of the focused area of this DocumentOrShadowRoot's node document.
</li>
	<li>
%候補 ~SET %候補 をコレに向けて`~targetし直す$
◎
Set candidate to the result of retargeting candidate against this DocumentOrShadowRoot.
</li>
	<li>
~IF［
%候補 の`根$ ~NEQ コレ
］
⇒
~RET ~NULL
◎
If candidate's root is not this DocumentOrShadowRoot, then return null.
</li>
	<li>
~IF［
%候補 は`文書$でない
］
⇒
~RET %候補
◎
If candidate is not a Document object, then return candidate.
</li>
	<li>
~RET ［
%候補 の`~body要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %候補 の`文書~要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ ~NULL
］
◎
If candidate has a body element, then return that body element.
◎
If candidate's document element is non-null, then return that document element.
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
`Document$I の
`hasFocus()@m
~method~手続きは
⇒
~RET ［
コレは`~focusを得ている$ならば ~T ／
~ELSE_ ~F
］
◎
The hasFocus() method on the Document object, when invoked, must return the result of running the has focus steps with the Document object as the argument.
</div>

<div class="algo">
<p>
`Window$I の
`focus()@m
~method~手続きは：
◎
The focus() method, when invoked, must run these steps:
</p>
<ol>
	<li>
%~navigable ~LET コレに`対応する~navigable$
◎
Let current be this Window object's navigable.
</li>
	<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
~RET
◎
If current is null, then return.
</li>
	<li>
`~objを~focusする$( %~navigable )
◎
Run the focusing steps with current.
</li>
	<li>
~IF［
%~navigable は`~top-level辿可能$である
］
⇒
~UAには，次を誘発することが奨励される
⇒
［
~pageが~focusを獲得しようと試みていることを，利用者に向けて指示する
］ような，何らかの類の通知
◎
If current is a top-level traversable, user agents are encouraged to trigger some sort of notification to indicate to the user that the page is attempting to gain focus.
</li>
</ol>
</div>

<div class="algo">
<p>
`Window$I の
`blur()@m
~method手続きは、
何もしない。
◎
The blur() method steps are to do nothing.
</p>

<p class="note">注記：
歴史的に、［
`focus()$m ／ `blur()$m
］~methodは，
実際には~system~levelの~focus
— 当の`~navigable$を包含している~system~widget（例：~UItabや~UIwindow）の~focus —
にも影響していたが、
この挙動は，利用者をないがしろに敵対的~siteから広く濫用されている。
◎
Historically, the focus() and blur() methods actually affected the system-level focus of the system widget (e.g., tab or window) that contained the navigable, but hostile sites widely abuse this behavior to the user's detriment.
</p>
</div>

<div class="algo">
<p>
要素の
`focus(options)@mE
~method~手続きは：
◎
The focus(options) method on elements, when invoked, must run the following steps:
</p>
<ol>
	<li>
~IF［
コレの`~focus用に~lockされたか$ ~EQ ~T
］
⇒
~RET
◎
If the element is marked as locked for focus, then return.
</li>
	<li>
コレの
`~focus用に~lockされたか@
【初期~時は ~F 】
~SET ~T
◎
Mark the element as locked for focus.
</li>
	<li>
`~objを~focusする$( コレ )
◎
Run the focusing steps for the element.
</li>
	<li>
%~focusを指示するか ~LET %options[ "`focusVisible@m" ]
◎
↓</li>
	<li>
~IF［
%~focusを指示するか ~EQ ε
］~AND［
~UAは、`~focusを指示する$ことが最善であると決定した
］
⇒
%~focusを指示するか ~SET ~T
◎
↓</li>
	<li>
~IF［
%~focusを指示するか ~EQ ~T
］
⇒
`実装定義$な仕方で`~focusを指示する$
◎
If the value of the focusVisible dictionary member of options is true, or is not present but in an implementation-defined way the user agent determines it would be best to do so, then indicate focus.
</li>
	<li>
~IF［
%options[
"`preventScroll@m"
] ~EQ ~F
］
⇒
コレを`~viewの中へ~scrollする$( `auto^l, `center^l, `center^l )
◎
If the value of the preventScroll dictionary member of options is false, then scroll the element into view given "auto", "center", and "center".
</li>
	<li>
コレの`~focus用に~lockされたか$ ~SET ~F
◎
Unmark the element as locked for focus.
</li>
</ol>
</div>

<div class="algo">
<p>
要素の
`blur()@mE
~method~手続きは
⇒
`~objを~unfocusする$( コレ )
◎
The blur() method, when invoked, should run the unfocusing steps for the element on which the method was called.＼
</p>

<p>
~UAは、
使い勝手の理由から
— 選択的に, または一様に —
この~methodの~callを無視してもヨイ。
◎
User agents may selectively or uniformly ignore calls to this method for usability reasons.
</p>

<p class="example">
例えば、
ただ美観の理由で，
`blur()$mE ~methodを利用して無思慮に~focus環が除去された場合、
~keyboard利用者からは，~pageの使い勝手は悪くなるであろう。
この~methodの~callを無視すれば、
~keyboardのみで~pageとヤリトリすることを利用者に許容することになろう。
◎
For example, if the blur() method is unwisely being used to remove the focus ring for aesthetics reasons, the page would become unusable by keyboard users. Ignoring calls to this method would thus allow keyboard users to interact with the page.
</p>
</div>

			</section>
			<section id="the-autofocus-attribute">
<h4 title="The autofocus attribute">6.6.7. `autofocus^a 属性</h4>

<p>
`autofocus@a
内容~属性は、［
~pageが読込まれたとき，ただちに要素を~focusする
］よう指示することを作者に許容する
— それは、［
当の要素に手動で~focusせずに，打込みを開始する
］ことを利用者に許容する。
◎
The autofocus content attribute allows the author to indicate that an element is to be focused as soon as the page is loaded, allowing the user to just start typing without having to manually focus the main element.
</p>

<p>
`autofocus$a 属性が［
`dialog$e 要素／ `~popover要素$
］ %先祖 の内側にある要素 %要素 に指定された場合、
%要素 は， %先祖 が示されるようになったとき~focusされることになる。
◎
When the autofocus attribute is specified on an element inside dialog elements or HTML elements whose popover attribute is set, then it will be focused when the dialog or popover becomes shown.
</p>

<p>
`autofocus$a 属性は、
`真偽-属性$である。
◎
The autofocus attribute is a boolean attribute.
</p>

<div class="algo">
<p>
`自動focus根@
を見出すときは、
所与の
( `要素$ %要素 )
に対し：
</p>
<ol>
	<li>
<p>
~WHILE 無条件
</p>
		<ol>
			<li>
~IF［
%要素 は `dialog$e 要素である
］
⇒
~RET %要素
</li>
			<li>
~IF［
%要素 は`~popover要素$である
］
⇒
~RET %要素
</li>
			<li>
%親 ~SET %要素 の`親~要素$
</li>
			<li>
~IF［
%親 ~EQ ~NULL
］
⇒
~RET %要素
</li>
			<li>
%要素 ~SET %親
</li>
		</ol>
	</li>
</ol>

<p class="trans-note">【
`自動focus根$は，原文では
“`nearest ancestor autofocus scoping root element^en”
と称されるが、
いかにも長いので，この訳では略語化する。
】</p>

◎
To find the nearest ancestor autofocus scoping root element given an Element element:
• If element is a dialog element, then return element.
• If element's popover attribute is not in the no popover state, then return element.
• Let ancestor be element.
• While ancestor has a parent element:
•• Set ancestor to ancestor's parent element.
•• If ancestor is a dialog element, then return ancestor.
•• If ancestor's popover attribute is not in the no popover state, then return ancestor.
• Return ancestor.
</div>

<p>
`自動focus根$が同じになる複数の要素が，
`autofocus$a 属性を有していてはナラナイ。
◎
There must not be two elements with the same nearest ancestor autofocus scoping root element that both have the autofocus attribute specified.
</p>

<div class="p">
<p>
各 `文書$には、
次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`自動focus候補~群@</dt>
	<dd>
`~list$
— 初期~時は空とする。
</dd>

	<dt>`自動focusは処理-済みか@</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
</dd>
</dl>

◎
Each Document has an autofocus candidates list, initially empty.
◎
Each Document has an autofocus processed flag boolean, initially false.
</div>

<div class="algo">
<p>
`autofocus$a 属性を有する要素 %要素 が，`文書の中へ挿入された$ときは、
次の手続きを走らす：
◎
When an element with the autofocus attribute specified is inserted into a document, run the following steps:
</p>

<ol>
	<li>
任意選択で
⇒
~IF［
利用者は~focusを変更しないよう望むことを指示した（例えば，~form~control内で打込みを開始することにより）
］
⇒
~RET
◎
If the user has indicated (for example, by starting to type in a form control) that they do not wish focus to be changed, then optionally return.
</li>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let target be the element's node document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET
◎
If target is not fully active, then return.
</li>
	<li>
~IF［
`閲覧~文脈~sandbox化( 自動的な特能 )~flag$ ~IN %文書 の`作動中な~sandbox法~flag集合$
］
⇒
~RET
◎
If target's active sandboxing flag set has the sandboxed automatic features browsing context flag, then return.
</li>
	<li>
%文書 の`先祖~navigable群$を成す
~EACH( %先祖~navigable )
に対し
⇒
~IF［
( %先祖~navigable にて`作動中な文書$navの`生成元$doc, %文書 の`生成元$doc )
は`同一-生成元$でない
］
⇒
~RET
◎
For each ancestorNavigable of target's ancestor navigables: if ancestorNavigable's active document's origin is not same origin with target's origin, then return.
</li>
	<li>
%~top文書 ~LET %文書 の`~node~navigable$の`~top-level辿可能$navにて`作動中な文書$nav
◎
Let topDocument be target's node navigable's top-level traversable's active document.
</li>
	<li>
~IF［
%~top文書 の`自動focusは処理-済みか$ ~EQ ~F
］
⇒＃
%~top文書 の`自動focus候補~群$から %要素 を`除去する$；
%~top文書 の`自動focus候補~群$に %要素 を`付加する$
◎
If topDocument's autofocus processed flag is false, then＼
remove the element from topDocument's autofocus candidates, and＼
append the element to topDocument's autofocus candidates.
</li>
</ol>

<p class="note">注記：
%要素 は、
`~focus可能な区画$でない場合でも，`自動focus候補~群$が成す~listに格納される
— 文書の中へ挿入された時点では，~focus可能な区画でなくとも、
`自動focus候補~群を洗出す$時点では そうなり得るので。
◎
We do not check if an element is a focusable area before storing it in the autofocus candidates list, because even if it is not a focusable area when it is inserted, it could become one by the time flush autofocus candidates sees it.
</p>
</div>

<div class="algo">
<p>
`自動focus候補~群を洗出す@
ときは、所与の
( 文書 %~top文書 )
に対し，次の手続きを走らす：
◎
To flush autofocus candidates for a document topDocument, run these steps:
</p>

<ol>
	<li>
~IF［
%~top文書 の`自動focusは処理-済みか$ ~EQ ~T
］
⇒
~RET
◎
If topDocument's autofocus processed flag is true, then return.
</li>
	<li>
%候補~群 ~LET %~top文書 の`自動focus候補~群$
◎
Let candidates be topDocument's autofocus candidates.
</li>
	<li>
~IF［
%候補~群 は`空$である
］
⇒
~RET
◎
If candidates is empty, then return.
</li>
	<li>
<p>
~IF［
%~top文書 が`指名する被focus区画$doc ~NEQ %~top文書
］~OR［
%~top文書 の`~target要素$ ~NEQ ~NULL
］：
◎
If topDocument's focused area is not topDocument itself, or topDocument has non-null target element, then:
</p>
		<ol>
			<li>
%候補~群 を`空にする$
◎
Empty candidates.
</li>
			<li>
%~top文書 の`自動focusは処理-済みか$ ~SET ~T
◎
Set topDocument's autofocus processed flag to true.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~WHILE［
%候補~群 は`空$でない
］：
◎
While candidates is not empty:
</p>
		<ol>
			<li>
%要素 ~LET %候補~群[ 0 ]
◎
Let element be candidates[0].
</li>
			<li>
%文書 ~LET %要素 の`~node文書$
◎
Let doc be element's node document.
</li>
			<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒＃
%候補~群 から %要素 を`除去する$；
~CONTINUE
◎
If doc is not fully active, then remove element from candidates, and continue.
</li>
			<li>
~IF［
%文書 の`~node~navigable$の`~top-level辿可能$ ~NEQ %~top文書 の`~node~navigable$
］
⇒＃
%候補~群 から %要素 を`除去する$；
~CONTINUE
◎
If doc's node navigable's top-level traversable is not the same as topDocument's node navigable, then remove element from candidates, and continue.
</li>
			<li>
<p>
~IF［
%文書 の`~scriptを阻んでいる~stylesheet集合$は`空$でない
］
⇒
~RET
◎
If doc's script-blocking style sheet set is not empty, then return.
</p>

<p class="note">注記：
この事例では、
%要素 は現時点で最良な候補であるが，
%文書 は自動focusするに準備済みでない。
次回に`自動focus候補~群を洗出す$が~callされるとき，再び試行されることになる。
◎
In this case, element is the currently-best candidate, but doc is not ready for autofocusing. We'll try again next time flush autofocus candidates is called.
</p>
			</li>
			<li>
%候補~群 から %要素 を`除去する$
◎
Remove element from candidates.
</li>
			<li>
%文書 の`広義-先祖~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
~IF［
%~navigable にて`作動中な文書$navの`~target要素$ ~NEQ ~NULL
］
⇒
~CONTINUE
◎
Let inclusiveAncestorDocuments be a list consisting of the active document of doc's inclusive ancestor navigables.
◎
If any Document in inclusiveAncestorDocuments has non-null target element, then continue.
</li>
			<li>
%~target ~LET %要素
◎
Let target be element.
</li>
			<li>
<p>
~IF［
%~target は`~focus可能な区画$でない
］
⇒
%~target ~SET `~focus可能な区画を取得する$( %~target )
◎
If target is not a focusable area, then set target to the result of getting the focusable area for target.
</p>

<div class="note">
<p>注記：
`自動focus候補~群$は、
`~focus可能な区画$でない要素を包含し得る。
`~focus可能な区画を取得する$~algoにて取扱われる特別な事例に加えて、
これが起こり得るわけには，次が挙げられる：
</p>
<ul>
	<li>
`autofocus$a 属性を有するが［
`~focus可能な区画$ではなく，決して~focus可能にならない要素
］が`文書の中へ挿入された$。
</li>
	<li>
要素は~focus可能であったが、
`自動focus候補~群$に格納されたときには，状態sが変化した。
</li>
</ul>
◎
Autofocus candidates can contain elements which are not focusable areas. In addition to the special cases handled in the get the focusable area algorithm, this can happen because a non-focusable area element with an autofocus attribute was inserted into a document and it never became focusable, or because the element was focusable but its status changed while it was stored in autofocus candidates.
</div>
			</li>
			<li>
<p>
~IF［
%~target ~NEQ ~NULL
］：
◎
If target is not null, then:
</p>
				<ol>
					<li>
%候補~群 を`空にする$
◎
Empty candidates.
</li>
					<li>
%~top文書 の`自動focusは処理-済みか$ ~SET ~T
◎
Set topDocument's autofocus processed flag to true.
</li>
					<li>
`~objを~focusする$( %~target )
◎
Run the focusing steps for target.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
これは、
文書を読込んでいる間の自動的な~focusを取扱う。
`dialog$e 要素の［
`show()$m ／ `showModal()$m
］~methodも， `autofocus$a 属性を処理する。
◎
This handles the automatic focusing during document load. The show() and showModal() methods of dialog elements also processes the autofocus attribute.
</p>
</div>

<p class="note">注記：
要素を~focusするとき、
~UAは，当の~browser~UIwindowを
— それが【~OSにおいて】~focusを失っていた場合に —
~focusする必要があるわけでない。
◎
Focusing the element does not imply that the user agent has to focus the browser window if it has lost focus.
</p>

<p>
`autofocus@m
~IDL属性は、
`autofocus$a 内容~属性を`反映する$モノトスル。
◎
The autofocus IDL attribute must reflect the content attribute of the same name.
</p>

<div class="example">
<p>
次の~code片の~text~controlは、
文書が読込まれたときに~focusされることになる。
◎
In the following snippet, the text control would be focused when the document was loaded.
</p>

`autofocus-1^xCode
</div>

<div class="example">
<p>
`autofocus$a 属性は、
~form~controlのみならず，すべての要素に適用される。
これにより，次の例も許容される。
◎
The autofocus attribute applies to all elements, not just to form controls. This allows examples such as the following:
</p>

`autofocus-2^xCode
</div>

			</section>
		</section>
		<section id="assigning-keyboard-shortcuts">
<h3 title="Assigning keyboard shortcuts">6.7. ~keyboard~shortcutのアテガイ</h3>

			<section id="introduction-9">
<h4 title="Introduction">6.7.1. 序論</h4>

◎非規範的

<p>
［
作動化-／~focus
］され得る各~要素には、
`accesskey$a 属性を利用して，それを作動化させる単独の~UIkey組合nをアテガえる。
◎
Each element that can be activated or focused can be assigned a single key combination to activate it, using the accesskey attribute.
</p>

<p>
正確な~shortcutは、
`accesskey$a 属性から供される情報を基に，利用者の~keyboardについての情報
— ［
~platform上にすでに存在する ／
~page上で他に指定されている
］~shortcutなど —
に基づいて、
~UAにより決定される
◎
The exact shortcut is determined by the user agent, based on information about the user's keyboard, what keyboard shortcuts already exist on the platform, and what other shortcuts have been specified on the page, using the information provided in the accesskey attribute as a guide.
</p>

<p>
`accesskey$a 属性~内にいくつもの代替を供すれば、
作者は，［
多様な入力~装置にわたり，関連な~keyboard~shortcutが可用になる
］ことを確保できる。
◎
In order to ensure that a relevant keyboard shortcut is available on a wide variety of input devices, the author can provide a number of alternatives in the accesskey attribute.
</p>

<p>
各~代替は、
普通字や数字などの単独の文字からなる。
◎
Each alternative consists of a single character, such as a letter or digit.
</p>

<p>
~UAは，~keyboard~shortcutの~listを利用者に供せるが、
作者も，そうすることが奨励される。
`accessKeyLabel$m ~IDL属性は、
~UAが実際にアテガった~UIkey組合nを表現している文字列を返す。
◎
User agents can provide users with a list of the keyboard shortcuts, but authors are encouraged to do so also. The accessKeyLabel IDL attribute returns a string representing the actual key combination assigned by the user agent.
</p>

<div class="example">
<p>
次の例には、
~shortcut~UIkeyを利用して呼出せる~buttonが供されている。
作者は、
アリな~UIkeyとして，~full~keyboard用の "C" に加え，
十keyしかないときに備えて別の~UIkey "1" も供している。
◎
In this example, an author has provided a button that can be invoked using a shortcut key. To support full keyboards, the author has provided "C" as a possible key. To support devices equipped only with numeric keypads, the author has provided "1" as another possible key.
</p>

`intro9-1^xCode
</div>

<div class="example">
<p>
どの~shortcut~UIkeyがあるか，利用者に伝えるため、
次の~scriptでは，~buttonの~labelに ~UIkey組合nを明示的に追加する：
【！ opted to＊ 】
◎
To tell the user what the shortcut key is, the author has this script here opted to explicitly add the key combination to the button's label:
</p>

<pre class="lang-js">
function addShortcutKeyLabel(%button) {
<strong>  if (%button.accessKeyLabel != '')
    %button.value += ' (' + %button.accessKeyLabel + ')';</strong>
}
addShortcutKeyLabel(document.getElementById('c'));
</pre>

<p>
同じ~UIkey組合nであっても、
~browserが示す~labelは，各~platformに普及している規約に応じて異なり得る。
例えば、
~UIkey組合nが［
`Control^Key + `Shift^Key + `C^Key
］ならば、［
Windows ~browserでは `Ctrl+Shift+C^samp ／
Mac ~browserでは `^⇧C^samp ／
Emacs ~browserでは `C-C^samp
］のように表示されるであろう。
類似に，~UIkey組合nが［
`Alt^Key + `Escape^Key
］であれば、［
Windows では `Alt+Esc^samp ／
Mac では `⌥⎋^samp ／
Emacs ~browserでは `M-ESC^samp または `ESC ESC^samp
］が利用されるであろう。
◎
Browsers on different platforms will show different labels, even for the same key combination, based on the convention prevalent on that platform. For example, if the key combination is the Control key, the Shift key, and the letter C, a Windows browser might display "Ctrl+Shift+C", whereas a Mac browser might display "^⇧C", while an Emacs browser might just display "C-C". Similarly, if the key combination is the Alt key and the Escape key, Windows might use "Alt+Esc", Mac might use "⌥⎋", and an Emacs browser might use "M-ESC" or "ESC ESC".
</p>

<p>
したがって一般に、
`accessKeyLabel$m ~IDL属性から返される値を構文解析しようと試みるのは，
賢明とは言えない。
◎
In general, therefore, it is unwise to attempt to parse the value returned from the accessKeyLabel IDL attribute.
</p>
</div>

			</section>
			<section id="the-accesskey-attribute">
<h4 title="The accesskey attribute">6.7.2. `accesskey^a 属性</h4>

<p>
`accesskey$a 内容~属性は、
すべての`~HTML要素$に設定できる。
この属性の値は、
要素を［
作動化する／~focusする
］ための~keyboard~shortcutを作成する基になる情報として，~UAにより利用される。
◎
All HTML elements may have the accesskey content attribute set. The accesskey attribute's value is used by the user agent as a guide for creating a keyboard shortcut that activates or focuses the element.
</p>

<p>
この属性に指定する値は、
`~space等で分離された~token集合$（一意, 有順序）であって、
各~tokenは，正確に 1 個の符号位置でなければナラナイ。
◎
If specified, the value must be an ordered set of unique space-separated tokens none of which are identical to another token and each of which must be exactly one code point in length.
</p>

<div class="example">
<p>
次の例では、
各~linkに~access~UIkeyがアテガわれている
— ~siteに馴染んでいる~keyboard利用者は、
関連な~pageに素早く~navigateできるようになる：
◎
In the following example, a variety of links are given with access keys so that keyboard users familiar with the site can more quickly navigate to the relevant pages:
</p>

`accesskey-1^xCode
</div>

<div class="example">
<p>
次の例では、
探索~欄に，アリな~access~UIkeyとして
`s^l, `0^l
の 2 つがこの順で与えられている。
~full~keyboard装置を備えている~UAは、
~shortcut~UIkeyとして［
`Ctrl^Key + `Alt^Key + `S^Key
］を選び取るであろう。
一方で，十keyしか備えていない装置~上の~UAは、
~UIkey
`0^Key
を選び取るであろう：
◎
In the following example, the search field is given two possible access keys, "s" and "0" (in that order). A user agent on a device with a full keyboard might pick Ctrl + Alt + S as the shortcut key, while a user agent on a small device with just a numeric keypad might pick just the plain unadorned key 0:
</p>

`accesskey-2^xCode
</div>

<div class="example">
<p>
次の例では、
アリな~access~UIkeyが~buttonに記述されている。
加えて，~UAが選択した~UIkey組合nを告知するため、
~scriptは，~buttonの~labelを更新しようと試行する。
◎
In the following example, a button has possible access keys described. A script then tries to update the button's label to advertise the key combination the user agent selected.
</p>

<pre class="lang-html">
&lt;input type=submit accesskey="N @ 1" value="Compose"&gt;
...
&lt;script&gt;
 function labelButton(%button) {
   if (%button.accessKeyLabel)
     %button.value += ' (' + %button.accessKeyLabel + ')';
 }
 var %inputs = document.getElementsByTagName('input');
 for (var %i = 0; %i &lt; %inputs.length; %i += 1) {
   if (%inputs[%i].type == "submit")
     labelButton(%inputs[%i]);
 }
&lt;/script&gt;
</pre>

<p>
~buttonの~labelは、
~UAに応じて，
`Compose (⌘N)^l にも `Compose (Alt+⇧+1)^l にもなり得る。
~UAが~UIkeyをアテガわなければ、
`Compose^l のみになる。
正確な文字列は、
`アテガわれた~access~UIkey$, および
~UAがその~UIkey組合nをどう表現するかに依存する。
◎
On one user agent, the button's label might become "Compose (⌘N)". On another, it might become "Compose (Alt+⇧+1)". If the user agent doesn't assign a key, it will be just "Compose". The exact string depends on what the assigned access key is, and on how the user agent represents that key combination.
</p>
</div>

			</section>
			<section id="keyboard-shortcuts-processing-model">
<h4 title="Processing model">6.7.3. 処理~model</h4>

<p>
要素に
`アテガわれた~access~UIkey@
とは、
要素の `accesskey$a 内容~属性から導出される~UIkey組合nである
— 初期~時には、
どのような~access~UIkeyもアテガわれないモノトスル。
◎
An element's assigned access key is a key combination derived from the element's accesskey content attribute. Initially, an element must not have an assigned access key.
</p>

<div class="algo">
<p>
~UAは、
要素の `accesskey$a 属性が［
設定- ／ 変更- ／除去-
］される度に、
次の手続きを走らせて得られる~access~UIkeyで，要素に`アテガわれた~access~UIkey$を更新するモノトスル：
◎
Whenever an element's accesskey attribute is set, changed, or removed, the user agent must update the element's assigned access key by running the following steps:
</p>

<ol>
	<li>
<p>
~IF［
要素は `accesskey$a 属性を有する
］
⇒
`~ASCII空白で分割する$( 属性の値 )
— その結果を成す
~EACH( %値 )
に対し：
◎
If the element has no accesskey attribute, then skip to the fallback step below.
◎
Otherwise, split the attribute's value on ASCII whitespace, and let keys be the resulting tokens.
◎
For each value in keys in turn, in the order the tokens appeared in the attribute's value, run the following substeps:
</p>
		<ol>
			<li>
~IF［
%値 を成す符号位置の個数 ~NEQ 1
］
⇒
~CONTINUE
◎
If the value is not a string exactly one code point in length, then skip the remainder of these steps for this value.
</li>
			<li>
~IF［
%値 は~systemの~keyboard上のどの~UIkeyにも対応しない
］
⇒
~CONTINUE
◎
If the value does not correspond to a key on the system's keyboard, then skip the remainder of these steps for this value.
</li>
			<li>
◎追跡路
任意選択で
⇒
~IF［
%値 に対応する~UIkeyと, 0 個以上の修飾~UIkeyとの組み合わせに，~access~UIkeyとして利用できるものがある
］
⇒
~RET その~UIkey組合n
◎
(This is a tracking vector.)
If the user agent can find a mix of zero or more modifier keys that, combined with the key that corresponds to the value given in the attribute, can be used as the access key, then the user agent may assign that combination of keys as the element's assigned access key and return.
</li>
		</ol>
	</li>
	<li>
任意選択で
⇒
~RET ~UAが選んだ~UIkey組合n
◎
Fallback: Optionally, the user agent may assign a key combination of its choosing as the element's assigned access key and then return.
</li>
	<li>
~RET ~access~UIkeyなし
◎
If this step is reached, the element has no assigned access key.
</li>
</ol>
</div>

<p>
要素~用に~access~UIkeyを選択してアテガった~UAは、［
要素の `accesskey$a 内容~属性が変更されるか，要素が別の`文書$へ移動される
］までは，要素に`アテガわれた~access~UIkey$を変更するベキでない。
◎
Once a user agent has selected and assigned an access key for an element, the user agent should not change the element's assigned access key unless the accesskey content attribute is changed or the element is moved to another Document.
</p>

<div class="p">
<p>
要素のうち`~commandを定義する$ものに対しては，［
利用者が，要素に`アテガわれた~access~UIkey$に対応する~UIkey組合nを押下げた
］ときは、
~UAは，［
~AND↓ が満たされるならば，その~commandの`動作$cFを誘発する
］モノトスル：
</p>
<ul>
	<li>
~commandの`隠されるか$cF ~EQ ~F （可視である）
</li>
	<li>
~commandの`不能化されるか$cF ~EQ ~F （可能化されている）
</li>
	<li>
要素は、
次を満たす`文書~内にある$
⇒
`属する閲覧~文脈$ ~NEQ ~NULL
</li>
	<li>
要素, および そのどの先祖も， `hidden$a 属性を有さない
</li>
</ul>
◎
When the user presses the key combination corresponding to the assigned access key for an element, if the element defines a command, the command's Hidden State facet is false (visible), the command's Disabled State facet is also false (enabled), the element is in a document that has a non-null browsing context, and neither the element nor any of its ancestors has a hidden attribute specified, then the user agent must trigger the Action of the command.
</div>

<p class="note">注記：
~UAは、
`accesskey$a 属性を有する要素を，他の仕方で
— 例えば，特定の~UIkey組合nに呼応して表示される~menu内に —
`公開することもある＠~HEinteractive#expose-commands-in-ui$。
◎
User agents might expose elements that have an accesskey attribute in other ways as well, e.g. in a menu displayed in response to a specific key combination.
</p> 

<hr>

<p>
`accessKey@m
~IDL属性は、
`accesskey$a 内容~属性を`反映する$モノトスル。
◎
The accessKey IDL attribute must reflect the accesskey content attribute.
</p>

<div class="algo">
`accessKeyLabel@m
取得子~手続きは
⇒
~RET ［
要素に`アテガわれた~access~UIkey$はあるならば それを表現する文字列 ／
~ELSE_ 空~文字列
］
◎
The accessKeyLabel IDL attribute must return a string that represents the element's assigned access key, if any. If the element does not have one, then the IDL attribute must return the empty string.
</div>

			</section>
		</section>
		<section id="editing-2">
<h3 title="Editing">6.8. 編集</h3>

			<section id="contenteditable">
<h4 title="Making document regions editable: The contenteditable content attribute">6.8.1. 文書の領域を編集-可能にする： `contenteditable^a 属性</h4>

<pre class="idl">
interface mixin `ElementContentEditable@I {
  [`CEReactions$] attribute DOMString `contentEditable$m;
  [`CEReactions$] attribute DOMString `enterKeyHint$m;
  readonly attribute boolean `isContentEditable$m;
  [`CEReactions$] attribute DOMString `inputMode$m;
};
</pre>

<div class="p">
<p>
`contenteditable@a
内容~属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
</p>

<table><thead>
<tr><th>~keyword
<th>状態
<tbody>

<tr><td>空~文字列
<td>`~T^st

<tr><td>`true^v
<td>`~T^st

<tr><td>`plaintext-only^v
<td>`素な~textのみ^st

<tr><td>`false^v
<td>`~F^st

<tr><td>
<td>`継承-^st
</table>

◎
The contenteditable content attribute is an enumerated attribute whose keywords are the empty string, true, plaintext-only and false. The empty string and the true keyword map to the true state. The plaintext-only keyword maps to the plaintext-only state. The false keyword maps to the false state.＼
</div>

<p>
この属性の［
`妥当でない値~用の既定の状態$／`欠落~値~用の既定の状態$
］は、
`継承-^stとする。
◎
In addition, there is a fourth state, the inherit state, which is the missing value default and the invalid value default.
</p>

<p>
上に挙げた各~状態は、
次を指示する：
◎
↓</p>
<ul>
	<li>
`~T^st
⇒
当の要素は、
編集-可能である。
◎
The true state indicates that the element is editable.＼
</li>
	<li>
`素な~textのみ^st
⇒
当の要素は，
生の~text内容に限り編集-可能であり、
~rich~text形式~化は不能化される。
◎
The plaintext-only state indicates that only the element's raw text content is editable, but rich text formatting is disabled.
</li>
	<li>
`継承-^st
⇒
当の要素は、
親の［
この属性の状態
］と同じになる。
◎
The inherit state indicates that the element is the same kind of editable (or not editable) as the parent element.＼
</li>
	<li>
`~F^st
⇒
当の要素は、
編集-可能でない。
◎
The false state indicates that the element is not editable.
</li>
</ul>

<div class="example">
<p>
例えば、
~page内に 新たな~~記事の~~投稿用に `form$e と `textarea$e があって，
利用者は~HTMLで~~記事を書くよう期待されているとする：
◎
For example, consider a page that has a form and a textarea to publish a new article, where the user is expected to write the article using HTML:
</p>

`contenteditable-1^xCode

<p>
~scriptが可能化されている下では、
`contenteditable$a 属性を利用して，
`textarea$e 要素を~rich~text~controlに置換することもできる：
◎
When scripting is enabled, the textarea element could be replaced with a rich text control instead, using the contenteditable attribute:
</p>

`contenteditable-2^xCode

<p>
例えば，~linkを挿入-可能にする特能は、
`execCommand()$m ~APIを利用して, あるいは
`Selection$I ~APIと他の~DOM~APIを利用して実装できる。
`EXECCOMMAND$r `SELECTION$r `DOM$r
◎
Features to enable, e.g., inserting links, can be implemented using the document.execCommand() API, or using Selection APIs and other DOM APIs. [EXECCOMMAND] [SELECTION] [DOM]
</p>
</div>

<div class="example">
<p>
`contenteditable$a 属性は、
効果を great にする【？】ためにも利用できる：
◎
The contenteditable attribute can also be used to great effect:
</p>

`contenteditable-3^xCode
</div>

<dl class="domintro">
	<dt>%element.`contentEditable$m [ = %value ]</dt>
	<dd>
`contenteditable$a 属性の状態に基づいて，次に挙げるいずれかを返す
⇒＃
`true^l,
`plaintext-only^l,
`false^l,
`inherit^l
◎
Returns "true", "plaintext-only", "false", or "inherit", based on the state of the contenteditable attribute.
</dd>
	<dd>
設定してその状態を変更できる
— 新たな値がこれらの文字列のいずれでもない場合、
`SyntaxError$E 例外が投出される。
◎
Can be set, to change that state.
◎
Throws a "SyntaxError" DOMException if the new value isn't one of those strings.
</dd>

	<dt>%element.`isContentEditable$m</dt>
	<dd>
要素が編集-可能ならば ~T ／
~ELSE_ ~F
を返す。
◎
Returns true if the element is editable; otherwise, returns false.
</dd>
</dl>

<div class="algo">
要素の
`contentEditable@m
取得子~手続きは
⇒
~RET コレの
`contenteditable$a 内容~属性の状態に応じて
⇒＃
`~T^st ならば `true^l ／
`素な~textのみ^st ならば `plaintext-only^l ／
`~F^st ならば `false^l ／
~ELSE_ `inherit^l
◎
The contentEditable IDL attribute, on getting, must return the string "true" if the content attribute is set to the true state, "plaintext-only" if the content attribute is set to the plaintext-only state, "false" if the content attribute is set to the false state, and "inherit" otherwise.＼
</div>

<div class="algo">
<p>
要素の
`contentEditable$m
設定子~手続きは：
</p>
<ol>
	<li>
%値 ~LET `~ASCII小文字~化する$( 所与の値 )
</li>
	<li>
~IF［
%値 ~IN { `true^l, `plaintext-only^l, `false^l }
］
⇒
コレの `contenteditable$a 内容~属性の値 ~SET %値
</li>
	<li>
~ELIF［
%値 ~EQ `inherit^l
］
⇒
コレの `contenteditable$a 内容~属性を除去する
</li>
	<li>
~ELSE：
⇒
~THROW `SyntaxError$E
</li>
</ol>
◎
On setting, if the new value is an ASCII case-insensitive match for the string "inherit" then the content attribute must be removed, if the new value is an ASCII case-insensitive match for the string "true" then the content attribute must be set to the string "true", if the new value is an ASCII case-insensitive match for the string "plaintext-only" then the content attribute must be set to the string "plaintext-only", if the new value is an ASCII case-insensitive match for the string "false" then the content attribute must be set to the string "false", and otherwise the attribute setter must throw a "SyntaxError" DOMException.
</div>

<div class="algo">
<p>
要素の
`isContentEditable@m
取得子~手続きは
⇒
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
コレは`編集中の~host$または `編集-可能$である
◎
The isContentEditable IDL attribute, on getting, must return true if the element is either an editing host or editable, and false otherwise.
</div>

			</section>
			<section id="making-entire-documents-editable:-the-designmode-idl-attribute">
<h4 title="Making entire documents editable: the designMode getter and setter">6.8.2. 文書~全体を編集-可能にする： `designMode^m の取得子と設定子</h4>

<dl class="domintro">
	<dt>%document.`designMode$m [ = %value ]</dt>
	<dd>
文書は［
編集-可能ならば `on^l ／
~ELSE_ `off^l
］返す。
◎
Returns "on" if the document is editable, and "off" if it isn't.
</dd>
	<dd>
設定して文書の現在の状態を変更できる。
これは、
文書を~focusした上で，文書~内の選択を設定し直す。
◎
Can be set, to change the document's current state. This focuses the document and resets the selection in that document.
</dd>
</dl>

<p>
各 `文書$には，真偽値をとる
`~design~modeは可能化されるか@
が結付けられ、
初期~時には ~F をとるとする。
◎
Document objects have an associated design mode enabled, which is a boolean. It is initially false.
</p>

<div class="algo">
`designMode@m
取得子~手続きは
⇒
~RET コレの`~design~modeは可能化されるか$に応じて
⇒＃
~T ならば `on^l ／
~F ならば `off^l
◎
The designMode getter steps are to return "on" if this's design mode enabled is true; otherwise "off".
</div>

<div class="algo">
<p>
`designMode$m
設定子~手続きは：
◎
The designMode setter steps are:
</p>
<ol>
	<li>
%値 ~LET `~ASCII小文字~化する$( 所与の値 )
◎
Let value be the given value, converted to ASCII lowercase.
</li>
	<li>
<p>
~IF［
%値 ~EQ `on^l
］~AND［
コレの`~design~modeは可能化されるか$ ~EQ ~F
］：
◎
If value is "on" and this's design mode enabled is false, then:
</p>
		<ol>
			<li>
コレの`~design~modeは可能化されるか$ ~SET ~T
◎
Set this's design mode enabled to true.
</li>
			<li>
コレにて`作動中な範囲$の［
始端, 終端
］境界点をコレの始端に設定し直す
◎
Reset this's active range's start and end boundary points to be at the start of this.
</li>
			<li>
~IF［
コレの`文書~要素$ ~NEQ ~NULL
］
⇒
`~objを~focusする$( コレの`文書~要素$ )
◎
Run the focusing steps for this's document element, if non-null.
</li>
		</ol>
	</li>
	<li>
~IF［
%値 ~EQ `off^l
］
⇒
コレの`~design~modeは可能化されるか$ ~SET ~F
◎
If value is "off", then set this's design mode enabled to false.
</li>
</ol>
</div>

			</section>
			<section id="best-practices-for-in-page-editors">
<h4 title="Best practices for in-page editors">6.8.3. ~page編集者による最善な実施</h4>

<p>
作者には、［
`編集中の~host$, および
編集-用の仕組みを通して作成された~markup
］上の `white-space$p ~propを値 `pre-wrap^v に設定することが奨励される。
~HTMLにおける空白に対する既定の取扱いは， WYSIWYG 編集には不向きであり、
`white-space$p が既定~値のままだと，
一部のきわどい事例では，行lの折返ngが正しく働かなくなる。
◎
Authors are encouraged to set the 'white-space' property on editing hosts and on markup that was originally created through these editing mechanisms to the value 'pre-wrap'. Default HTML whitespace handling is not well suited to WYSIWYG editing, and line wrapping will not work correctly in some corner cases if 'white-space' is left at its default value.
</p>

<div class="example">
<p>
既定の `normal^v 値が利用された場合に生じる問題の一例として、
利用者が［
"`yellow^kbd", `space^i, `space^i, `ball^kbd"
］を続けて打込んだときを考える。
`white-space$p の既定の値（ `normal^v ）の下では，~~連続する `space^i は一つに縮約する呈示が要求されるため、
結果の~markupを［
`yellow^l, `nbsp^i, `space^i, `ball^l
］の並び, または［
`yellow^l, `space^i, `nbsp^i, `ball^l
］の並びとするような編集~規則が必要yである
— ここで， `nbsp^i は分断不可 space（ non-breaking space ）,
`space^i は普通の space（ U+0020 ）を表すとする。
【！ "␣"】
◎
As an example of problems that occur if the default 'normal' value is used instead, consider the case of the user typing "yellow␣␣ball", with two spaces (here represented by "␣") between the words. With the editing rules in place for the default value of 'white-space' ('normal'), the resulting markup will either consist of "yellow&amp;nbsp; ball" or "yellow &amp;nbsp;ball"; i.e., there will be a non-breaking space between the two words in addition to the regular space. This is necessary because the 'normal' value for 'white-space' requires adjacent regular spaces to be collapsed together.
</p>

<p>
2 つの単語の合間で行lを折返す必要がある場合、
前者の［
`nbsp^i, `space^i
］並びの事例では
— 行lの終端までに単語 `yellow^l のみが収まる場合でも —
`nbsp^i の直後で次の行lへ折返され、
後者の［
`space^i, `nbsp^i
］並びの事例では， `nbsp^i の直前で次の行lへ折返される
— その結果、
単語 `ball^l の前に字下げが露わになる。
◎
In the former case, "yellow⍽" might wrap to the next line ("⍽" being used here to represent a non-breaking space) even though "yellow" alone might fit at the end of the line; in the latter case, "⍽ball", if wrapped to the start of the line, would have visible indentation from the non-breaking space.
</p>

<p>
一方で、
`white-space$p が `pre-wrap^v に設定されている下での編集~規則は，
単語の合間に 2 個の `space^i を挟むだけ済む。
その結果、
2 個の単語は行lの終端の所で分割され，
~spaceは具現化からきれいに除去されることになる。
◎
When 'white-space' is set to 'pre-wrap', however, the editing rules will instead simply put two regular spaces between the words, and should the two words be split at the end of a line, the spaces would be neatly removed from the rendering.
</p>
</div>

			</section>
			<section id="editing-apis">
<h4 title="Editing APIs">6.8.4. 編集~API</h4>

<p>
`編集中の~host@
とは、
~OR↓ を満たす`~HTML要素$である：
◎
An editing host is either＼
</p>
<ul>
	<li>
`contenteditable$a 属性の状態 ~IN { `~T^st, `素な~textのみ^st }
◎
an HTML element with its contenteditable attribute in the true state or plaintext-only state, or＼
</li>
	<li>
次を満たす`文書$の`子$である
⇒
`~design~modeは可能化されるか$ ~EQ ~T
◎
a child HTML element of a Document whose design mode enabled is true.
</li>
</ul>

<div>
<p>
次に挙げるものは、
`EXECCOMMAND$r 仕様にて定義される：
</p>
<ul>
	<li id="active-range">
`作動中な範囲$
</li>
	<li id="editing-host-of">
~nodeが`属する編集中の~host$
</li>
	<li id="editable">
`編集-可能$
</li>
	<li>
［
`編集中の~host$ ／ `編集-可能$
］である要素に課される~UI要件
</li>
	<li>
~text選択
</li>
	<li id="delete-the-selection">
`選択を削除-$する~algo
</li>
	<li>
次に挙げる各種~method
⇒＃
`execCommand()$m,
`queryCommandEnabled()$m,
`queryCommandIndeterm()$m,
`queryCommandState()$m,
`queryCommandSupported()$m,
`queryCommandValue()$m
</li>
</ul>
◎
The definition of the terms active range, editing host of, and editable, the user interface requirements of elements that are editing hosts or editable, the execCommand(), queryCommandEnabled(), queryCommandIndeterm(), queryCommandState(), queryCommandSupported(), and queryCommandValue() methods, text selections, and the delete the selection algorithm are defined in execCommand. [EXECCOMMAND]
</div>

			</section>
			<section id="spelling-and-grammar-checking">
<h4 title="Spelling and grammar checking">6.8.5. 綴りや文法の検査ng： `spellcheck^a 属性</h4>

<p>
~UAは、［
~form~control（ `textarea$e 要素の値など）や,
`編集中の~host$内の要素（例： `contenteditable$a を利用して）
］内の編集-可能な~textに対する綴りや文法の検査ngを~supportできる。
◎
User agents can support the checking of spelling and grammar of editable text, either in form controls (such as the value of textarea elements), or in elements in an editing host (e.g. using contenteditable).
</p>

<p>
~UAは、
各~要素に対し，［
既定のもの, または利用者が表出した選好
］を通して、
`既定の挙動@
を確立するモノトスル。
各~要素に対してアリな既定の挙動には、
次の 3 種がある：
◎
For each element, user agents must establish a default behavior, either through defaults or through preferences expressed by the user. There are three possible default behaviors for each element:
</p>

<dl>
	<dt>
`既定で行う@
◎
true-by-default
</dt>
	<dd>
要素の内容の綴りや文法は、［
その内容が編集-可能であって，
その検査ngは `spellcheck$a 属性を通して明示的に不能化されていない
］ならば，検査される。
◎
The element will be checked for spelling and grammar if its contents are editable and spellchecking is not explicitly disabled through the spellcheck attribute.
</dd>
	<dt>
`既定で行わない@
◎
false-by-default
</dt>
	<dd>
要素の綴りや文法は、
`spellcheck$a 属性を通して明示的に可能化されていない限り，
決して検査されない。
◎
The element will never be checked for spelling and grammar unless spellchecking is explicitly enabled through the spellcheck attribute.
</dd>
	<dt>
`既定で継承する@
◎
inherit-by-default
</dt>
	<dd>
要素の既定の挙動は、
その親~要素のそれと同じになる。
親~要素がない場合、
既定の挙動はない。
◎
The element's default behavior is the same as its parent element's. Elements that have no parent element cannot have this as their default behavior.
</dd>

</dl>

<hr>

<div class="p">
<p>
`spellcheck@a
属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
</p>

<table><thead>
<tr><th>~keyword
<th>状態
<tbody>

<tr><td>空~文字列
<td>`~T^st

<tr><td>`true^v
<td>`~T^st

<tr><td>`false^v
<td>`~F^st

<tr><td>
<td>`既定の挙動^st
</table>
◎
The spellcheck attribute is an enumerated attribute whose keywords are the empty string, true and false. The empty string and the true keyword map to the true state. The false keyword maps to the false state.＼
</div>

<p>
この属性の［
`妥当でない値~用の既定の状態$／`欠落~値~用の既定の状態$
］は、
`既定の挙動^st とする。
◎
In addition, there is a third state, the default state, which is the missing value default and the invalid value default.
</p>

<p class="note">注記：
［
`~T^st ／
`~F^st ／
`既定の挙動^st
］状態は、
当の要素の綴りや文法が［
検査される／
検査されない／
検査されるかどうかは`既定の挙動$に則る
］ことを指示する。
`既定の挙動$に則る場合、
場合によっては親~要素の `spellcheck$a 状態に基づくことになる。
◎
The true state indicates that the element is to have its spelling and grammar checked. The default state indicates that the element is to act according to a default behavior, possibly based on the parent element's own spellcheck state, as defined below. The false state indicates that the element is not to be checked.
</p>

<hr>

<dl class="domintro">
	<dt>%element.`spellcheck$m [ = %value ]</dt>
	<dd>
要素の綴りや文法が検査されるならば ~T ／
~ELSE_ ~F
を返す。
◎
Returns true if the element is to have its spelling and grammar checked; otherwise, returns false.
</dd>
	<dd>
設定して、
既定の挙動を上書きしつつ，
`spellcheck$a 内容~属性を設定できる。
◎
Can be set, to override the default and set the spellcheck content attribute.
</dd>
</dl>

<div class="algo">
<div>
<p>
要素の
`spellcheck@m
取得子~手続きは
⇒
~RET コレの `spellcheck$a 内容~属性の状態に応じて
⇒＃
`~T^st ならば ~T ／
`~F^st ならば ~F ／
`既定の挙動^st ならば コレの`既定の挙動$に応じて ⇒＃
`既定で行う$ならば ~T ／
`既定で行わない$ならば ~F ／
`既定で継承する$ならば コレの親~要素の `spellcheck$m 取得子~手続き() 【親~要素がない場合は ~F ？（はっきりしない）】
◎
The spellcheck IDL attribute, on getting, must return true if the element's spellcheck content attribute is in the true state, or if the element's spellcheck content attribute is in the default state and the element's default behavior is true-by-default, or if the element's spellcheck content attribute is in the default state and the element's default behavior is inherit-by-default and the element's parent element's spellcheck IDL attribute would return true; otherwise, if none of those conditions applies, then the attribute must instead return false.
</div>

<p class="note">注記：
`spellcheck$m ~IDL属性は、［
利用者による， `spellcheck$a 内容~属性を上書きする選好
］からは影響されないため、
実際の綴りや文法に対する検査ng状態を反映しないこともある。
◎
The spellcheck IDL attribute is not affected by user preferences that override the spellcheck content attribute, and therefore might not reflect the actual spellchecking state.
</p>
</div>

<div class="algo">
<p>
要素の `spellcheck$m 設定子~手続きは
⇒
コレの `spellcheck$a 内容~属性の値 ~SET 所与の値に応じて，次に与える文字列
⇒＃
~T ならば `true^l ／
~F ならば `false^l
◎
On setting, if the new value is true, then the element's spellcheck content attribute must be set to the literal string "true", otherwise it must be set to the literal string "false".
</div>

<hr>

<p>
この特能の目的においては：
◎
User agents must only consider the following pieces of text as checkable for the purposes of this feature:
</p>
<ul>
	<li>
<p>
検査-可能な~textは、
次に挙げる~text片に限られるモノトスル：
◎
↑</p>
		<ul>
			<li>
<p>
［
~AND↓ を満たす `input$e 要素
］の`値$fe：
</p>
				<ul>
					<li>
`type$a 属性の状態 ~IN { `Text$st, `Search$st, `Url$st, `Email$st }
</li>
					<li>
`変異-可能$
（すなわち、
`readonly$a 属性は有さない, かつ`不能化されて$いない）
</li>
				</ul>
◎
The value of input elements whose type attributes are in the Text, Search, URL, or Email states and that are mutable (i.e. that do not have the readonly attribute specified and that are not disabled).
</li>
			<li>
<p>
［
~AND↓ を満たす `textarea$e 要素
］の`値$fe：
</p>
				<ul>
					<li>
`~readonly0$a 属性は有さない
</li>
					<li>
`不能化されて$いない
</li>
				</ul>

◎
The value of textarea elements that do not have a readonly attribute and that are not disabled.
</li>
			<li>
［
`編集中の~host$ ／ `編集-可能$な要素
］の子である `Text$I ~node内の~text。
◎
Text in Text nodes that are children of editing hosts or editable elements.
</li>
			<li>
`編集-可能$な要素の属性~内の~text。
◎
Text in attributes of editable elements.
</li>
		</ul>
	</li>
	<li>
<p>
所与の~textが属するとされる要素は、
次で与えられる：
</p>
		<ul>
			<li>
`Text$I ~nodeの一部を成す~textに対しては、［
単語, 一文, その他の~text片
］の最初の文字の直の親である要素。
</li>
			<li>
属性~内の~textに対しては、
当の属性を有している要素。
</li>
			<li>
［
`input$e ／ `textarea$e
］要素の値に対しては、
要素~自身。
</li>
		</ul>
◎
For text that is part of a Text node, the element with which the text is associated is the element that is the immediate parent of the first character of the word, sentence, or other piece of text. For text in attributes, it is the attribute's element. For the values of input and textarea elements, it is the element itself.
</li>
</ul>

<div class="algo">
<p>
綴りや文法の検査ngが適用-可能な要素 %要素 に属する~textに対する検査ngは、
次の~algoの結果が［
`可能化される^i ならば可能化される ／
`不能化される^i ならば不能化される
］モノトスル：
◎
To determine if a word, sentence, or other piece of text in an applicable element (as defined above) is to have spelling- and grammar-checking enabled, the UA must use the following algorithm:
</p>
<ol>
	<li>
~IF［
利用者は、
この~textに対する検査ngを不能化している
］
⇒
~RET `不能化される^i
◎
If the user has disabled the checking for this text, then the checking is disabled.
</li>
	<li>
~IF［
利用者は、
この~textの検査ngを常に可能化するように強制している
］
⇒
~RET `可能化される^i
◎
Otherwise, if the user has forced the checking for this text to always be enabled, then the checking is enabled.
</li>
	<li>
%要素~list ~SET［
%要素 , および その先祖~要素
］からなる，%要素 に近い順の~list
◎
↓</li>
	<li>
<p>
%要素~list を成す
~EACH( %E )
に対し：
</p>
		<ol>
			<li>
%状態 ~LET %E の `spellcheck$a 内容~属性の状態
</li>
			<li>
~IF［
%状態 ~EQ `既定の挙動^st
］
⇒
~CONTINUE
</li>
			<li>
~RET %状態 に応じて
⇒＃
`~T^st ならば `可能化される^i ／
`~F^st ならば `不能化される^i
</li>
		</ol>
◎
Otherwise, if the element with which the text is associated has a spellcheck content attribute, then: if that attribute is in the true state, then checking is enabled; otherwise, if that attribute is in the false state, then checking is disabled.
◎
Otherwise, if there is an ancestor element with a spellcheck content attribute that is not in the default state, then: if the nearest such ancestor's spellcheck content attribute is in the true state, then checking is enabled; otherwise, checking is disabled.
</li>
	<li>
<p>
%要素~list を成す
~EACH( %E )
に対し：
</p>
		<ol>
			<li>
%挙動 ~LET %E の`既定の挙動$
</li>
			<li>
~IF［
%挙動 ~EQ `既定で継承する$
］
⇒
~CONTINUE†
</li>
			<li>
~RET %挙動 に応じて
⇒＃
`既定で行う$ならば `可能化される^i ／
`既定で行わない$ならば `不能化される^i
</li>
		</ol>

<p class="trans-note">【†
原文では，この~algoを %E の親に対し再帰的に呼出しているが、
前~段にて， %E のどの先祖の `spellcheck$a 内容~属性の状態も `既定の挙動^st であることはすでに判っているので、
この段で反復することで十分になる。
】</p>

◎
Otherwise, if the element's default behavior is true-by-default, then checking is enabled.
◎
Otherwise, if the element's default behavior is false-by-default, then checking is disabled.
◎
Otherwise, if the element's parent element has its checking enabled, then checking is enabled.
</li>
	<li>
~RET `不能化される^i
◎
Otherwise, checking is disabled.
</li>
</ol>
</div>

<p>
単語や一文などの~textに対する検査ngが可能化されている場合、
~UAは，その~text内に綴りや文法の誤りがあれば それを指示するベキである。
~UAは、
綴りや文法の訂正を示唆するときには，文書~内に所与の他の意味論も織り込むベキである
— これには、次が含まれる：
◎
If the checking is enabled for a word/sentence/text, the user agent should indicate spelling and grammar errors in that text. User agents should take into account the other semantics given in the document when suggesting spelling and grammar corrections.＼
</p>

<ul>
	<li>
綴りや文法に利用する規則を、
要素に指定されている自然言語や, 利用者が選好している自然言語~設定群から決定してもヨイ。
◎
User agents may use the language of the element to determine what spelling and grammar rules to use, or may use the user's preferred language settings.＼
</li>
	<li>
アリな所では、
`pattern$a などの `input$e 要素~属性を利用して，
結果の値が妥当になることを確保するベキである。
◎
UAs should use input element attributes such as pattern to ensure that the resulting value is valid, where possible.
</li>
</ul>

<p>
検査ngが不能化されている場合、
~UAは，その~textに対する綴りや文法の誤りを指示するベキでない。
◎
If checking is disabled, the user agent should not indicate spelling or grammar errors for that text.
</p>

<div class="example">
<p>
次の例の単語 `Hello^l に対しては、
その綴りを検査するかどうかを決定するときに，~ID `a^l の要素が利用され、
その結果，検査されない。
◎
The element with ID "a" in the following example would be the one used to determine if the word "Hello" is checked for spelling errors. In this example, it would not be.
</p>

`spelling-1^xCode

<p>
次の例における~ID `b^l の要素に対しては、
検査ngは可能化される
（ `input$e 要素~上の属性~値~内の頭部の~ASCII空白は，属性を無視させるので、
既定の挙動にかかわらず，先祖の値が代わりに利用される）。
◎
The element with ID "b" in the following example would have checking enabled (the leading space character in the attribute's value on the input element causes the attribute to be ignored, so the ancestor's value is used instead, regardless of the default).
</p>

`spelling-2^xCode
</div>

<p class="note">注記：
この仕様は、
綴りや文法~検査器~用の~UIは定義しない。
例えば~UAは、［
その場で検査ngを提供する ／
検査ngが可能化されている間，継続的に検査ngを遂行する ／
その他の~UI
］のいずれも利用できる。
◎
This specification does not define the user interface for spelling and grammar checkers. A user agent could offer on-demand checking, could perform continuous checking while the checking is enabled, or could use other interfaces.
</p>

			</section>
			<section id="autocapitalization">
<h4 title="Autocapitalization">6.8.6. 自動頭字化： `autocapitalize^a 属性</h4>

<p>
~textを手入力する~methodには、
例えば，携帯~機器~上の~virtual-keyboardや~voice入力などもあり、
各~一文の最初の字l（ `letter^en ）
【約物等を除く，“普通の” 文字】
を自動的に頭字化（ capital 化 ）して，利用者を支援することが多い
（当の自然言語に この規約がある下で，~textを組成しているならば）。
自動頭字化を実装する~virtual-keyboardは、
自動頭字化されるべき字lが打込まれつつあるとき，
自動的に字lを大文字で示すよう切替えるかもしれない
（利用者が小文字に戻せるようにしつつ）。
他の型の入力，例えば~voice入力では、
最初に介入する~~余地を利用者に与えない仕方で，
自動頭字化を遂行することもある。
`autocapitalize$a 属性は、
そのような挙動を制御することを作者に許容する。
◎
Some methods of entering text, for example virtual keyboards on mobile devices, and also voice input, often assist users by automatically capitalizing the first letter of sentences (when composing text in a language with this convention). A virtual keyboard that implements autocapitalization might automatically switch to showing uppercase letters (but allow the user to toggle it back to lowercase) when a letter that should be autocapitalized is about to be typed. Other types of input, for example voice input, may perform autocapitalization in a way that does not give users an option to intervene first. The autocapitalize attribute allows authors to control such behavior.
</p>

<p>
`autocapitalize$a 属性は、
概して，［
物理的~keyboardを打込むときの挙動には影響しない
］ように実装される。
（この理由から, および［
一部の事例で自動頭字化の挙動を上書きできる／初期~入力の後に~textを編集する
］能を利用者に与えるため、
いかなる類の入力~検証も，この属性には依拠しないモノトスル。）
◎
The autocapitalize attribute, as typically implemented, does not affect behavior when typing on a physical keyboard. (For this reason, as well as the ability for users to override the autocapitalization behavior in some cases or edit the text after initial input, the attribute must not be relied on for any sort of input validation.)
</p>

<p>
`autocapitalize$a 属性は、
次に挙げる挙動を制御するために利用できる：
◎
The autocapitalize attribute can be used＼
</p>

<ul>
	<li>
`編集中の~host$においては
⇒
~hostされている編集-可能な領域~用の，自動頭字化の挙動。
◎
on an editing host to control autocapitalization behavior for the hosted editable region,＼
</li>
	<li>
［
`input$e ／ `textarea$e
］要素においては
⇒
要素の中に~textを入力するときの挙動。
◎
on an input or textarea element to control the behavior for inputting text into that element, or＼
</li>
	<li>
`form$e 要素においては
⇒
［
当の~formが所有している要素のうち，`自動頭字化-を継承-$するもの
］すべてに対する既定の挙動。
◎
on a form element to control the default behavior for all autocapitalize-inheriting elements associated with the form element. 
</li>
</ul>

<p>
`autocapitalize$a 属性は、
次に該当するものに対しては，
決して自動頭字化を可能化させない
（この挙動は、
下の`利用する自動頭字化~hint$を算出する~algoに含まれている）
⇒
`input$e 要素のうち，［
その`type$a 属性の状態 ~IN { `Url$st, `Email$st, `Password$st }
］なるもの
◎
The autocapitalize attribute never causes autocapitalization to be enabled for input elements whose type attribute is in one of the URL, Email, or Password states. (This behavior is included in the used autocapitalization hint algorithm below.)
</p>

<p>
自動頭字化の処理~modelは、
次に定義される 5 種の
`自動頭字化~hint@
から選定することに基づく：
◎
The autocapitalization processing model is based on selecting among five autocapitalization hints, defined as follows:
</p>

<dl>
	<dt>`既定@aH</dt>
	<dd>
［
~UA／入力~method
］は、
自前の決定を用立てて，自動頭字化を可能化するベキである。
【！use make = make use？】
◎
The user agent and input method should use make their own determination of whether or not to enable autocapitalization.
</dd>

	<dt>`なし@aH</dt>
	<dd>
自動頭字化は適用されるベキでない
（すべての字lは、
既定で小文字にされるベキである）。
◎
No autocapitalization should be applied (all letters should default to lowercase).
</dd>

	<dt>`一文ごと@aH</dt>
	<dd>
各~一文の最初の字lは、
既定で頭字にされるベキである。
他のすべての字lは、
既定で小文字にされるベキである。
◎
The first letter of each sentence should default to a capital letter; all other letters should default to lowercase.
</dd>

	<dt>`単語ごと@aH</dt>
	<dd>
各~単語の最初の字lは、
既定で頭字にされるベキである。
他のすべての字lは、
既定で小文字にされるベキである
◎
The first letter of each word should default to a capital letter; all other letters should default to lowercase.
</dd>
	<dt>`文字ごと@aH</dt>
	<dd>
すべての字lは、
既定で大文字にされるベキである。
◎
All letters should default to uppercase.
</dd>
</dl>

<p>
`autocapitalize@a
属性は，`自動頭字化~hint$を与える。
この~hintは、［
`利用する自動頭字化~hint$を形成するための他の考慮点
］と組合されて，~UAの挙動を伝える。
この属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The autocapitalize attribute is an enumerated attribute whose states are the possible autocapitalization hints. The autocapitalization hint specified by the attribute's state combines with other considerations to form the used autocapitalization hint, which informs the behavior of the user agent. The keywords for this attribute and their state mappings are as follows:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態
<tbody>

<tr><td>`off@v
<td>`なし$aH

<tr><td>`~noneC@v
<td>`なし$aH

<tr><td>`on@v
<td>`一文ごと$aH
<tr><td>`sentences@v
<td>`一文ごと$aH

<tr><td>`words@v
<td>`単語ごと$aH

<tr><td>`characters@v
<td>`文字ごと$aH
</table>
◎
Keyword｜State
off｜none
none｜none
on｜sentences
sentences｜sentences
words｜words
characters｜characters
</div>

<p>
この属性の［
`妥当でない値~用の既定の状態$は，`一文ごと$aH／
`欠落~値~用の既定の状態$は，`既定$aH
］とする。
◎
The invalid value default is the sentences state. The missing value default is the default state.
</p>

<dl class="domintro">
	<dt>%element.`autocapitalize$m [ = %value ]</dt>
	<dd>
この要素~用の［
現在の自動頭字化~状態, または
未~設定-の場合は空~文字列
］を返す。
［
`input$e ／ `textarea$e
］要素は、
自身の状態を `form$e 要素から継承することに注意：
その場合， `form$e 要素の自動頭字化~状態を返すことになり、［
編集-可能な領域~内の要素であっても，編集中の~hostの自動頭字化~状態は返さない
］ことになる
（要素~自身が，`編集中の~host$でない限り）。
◎
Returns the current autocapitalization state for the element, or an empty string if it hasn't been set. Note that for input and textarea elements that inherit their state from a form element, this will return the autocapitalization state of the form element, but for an element in an editable region, this will not return the autocapitalization state of the editing host (unless this element is, in fact, the editing host).
</dd>
	<dd>
設定して， `autocapitalize$a 内容~属性を設定できる（それに伴い，要素~用の自動頭字化の挙動も変更する）。
◎
Can be set, to set the autocapitalize content attribute (and thereby change the autocapitalization behavior for the element).
</dd>
</dl>

<p>
所与の要素 %要素 の
`自前の自動頭字化~hint@
を算出するときは、
次を走らす：
◎
To compute the own autocapitalization hint of an element element, run the following steps:
</p>

<ol>
	<li>
~IF［
%要素 は `autocapitalize$a 内容~属性を有していて，その値 ~NEQ 空~文字列
］
⇒
~RET その属性の状態
◎
If the autocapitalize content attribute is present on element, and its value is not the empty string, return the state of the attribute.
</li>
	<li>
~IF［
%要素 は`自動頭字化-を継承-$する
］~AND［
%要素 の`~form所有者$ ~NEQ ~NULL
］
⇒
~RET %要素 の`~form所有者$の`自前の自動頭字化~hint$
◎
If element is an autocapitalize-inheriting element and has a non-null form owner, return the own autocapitalization hint of element's form owner.
</li>
	<li>
~RET `既定$aH
◎
Return default.
</li>
</ol>

<div class="algo">
`autocapitalize@m
取得子~手続きは
⇒
~RET コレの`自前の自動頭字化~hint$に応じて
⇒＃
`既定$aH ならば 空~文字列 ／
`なし$aH ならば "`~noneC$v" ／
`一文ごと$aH ならば "`sentences$v" ／
`単語ごと$aH ならば "`words$v" ／
`文字ごと$aH ならば "`characters$v"
◎
The autocapitalize getter steps are to:
• Let state be the own autocapitalization hint of this.
• If state is default, then return the empty string.
• If state is none, then return "none".
• If state is sentences, then return "sentences".
• Return the keyword value corresponding to state.
</div>

<div class="algo">
<p>
`autocapitalize$m 設定子~手続きは
⇒
コレの `autocapitalize$a 内容~属性 ~SET 所与の値
◎
The autocapitalize setter steps are to set the autocapitalize content attribute to the given value.
</div>

<hr>

<p>
~UAは，［
~text入力~methodに対する自動頭字化の挙動を~custom化する機能性
］を~supportしていて［
~web開発者がそれを制御できる
］ようにしたいと望むならば、
要素の中に~textを入力する間，要素~用に
`利用する自動頭字化~hint@
を算出するベキである。
これは、［
要素の中への~text入力~用に推奨される，自動頭字化の挙動
］を述べる，`自動頭字化~hint$になる。
◎
User agents that support customizable autocapitalization behavior for a text input method and wish to allow web developers to control this functionality should, during text input into an element, compute the used autocapitalization hint for the element. This will be an autocapitalization hint that describes the recommended autocapitalization behavior for text input into the element.
</p>

<p>
ある種の状況下においては、［
~UA／入力~method
］は，`利用する自動頭字化~hint$を［
無視する, または上書きする
］ことを選んでもヨイ。
◎
User agents or input methods may choose to ignore or override the used autocapitalization hint in certain circumstances.
</p>

<p>
要素 %要素 用に`利用する自動頭字化~hint$は、
次の~algoを利用して算出される：
◎
The used autocapitalization hint for an element element is computed using the following algorithm:
</p>

<ol>
	<li>
~IF［
%要素 は `input$e 要素である
］~AND［
%要素 の `type$a 属性の状態 ~IN { `Url$st, `Email$st, `Password$st }
］
⇒
~RET `既定$aH
◎
If element is an input element whose type attribute is in one of the URL, Email, or Password states, then return default.
</li>
	<li>
~IF［
%要素 は［
`input$e ／ `textarea$e
］要素である
］
⇒
~RET %要素 の`自前の自動頭字化~hint$
◎
If element is an input element or a textarea element, then return element's own autocapitalization hint.
</li>
	<li>
~IF［
%要素 は［
`編集中の~host$ ／ `編集-可能$な要素
］である
］
⇒
~RET
%要素 が`属する編集中の~host$の`自前の自動頭字化~hint$
◎
If element is an editing host or an editable element, then return the own autocapitalization hint of the editing host of element.
</li>
	<li>
~Assert：
この段に到達することは決してない
— ~text入力が生じるのは，上の判定基準のいずれかを満たす要素に限られるので。
◎
Assert: this step is never reached, since text input only occurs in elements that meet one of the above criteria.
</li>
</ol>

			</section>
			<section id="input-modalities:-the-inputmode-attribute">
<h4 title="Input modalities: the inputmode attribute">6.8.7. 入力~modal性： `inputmode^a 属性</h4>

<p>
~UAは、
次に挙げるものに対し，
`inputmode$a 属性を~supportできる
⇒＃
~form~control（`textarea$e 要素の値など） ／
`編集中の~host$内の要素（ `contenteditable$a を利用しているものなど）
◎
User agents can support the inputmode attribute on form controls (such as the value of textarea elements), or in elements in an editing host (e.g., using contenteditable).
</p>

<p>
`inputmode@a
内容~属性は、［
内容を手入力している利用者にとって，どの種類の入力の仕組みが最も助けになるか
］を指定する。
この属性は，`列挙d属性$であり、
次に挙げる~keywordが定義される。
~UAは、
~keywordに応じて，
次に述べるような~virtual-keyboardを表示するベキである：
◎
The inputmode content attribute is an enumerated attribute that specifies what kind of input mechanism would be most helpful for users entering content.
◎
↓</p>

<table><thead>
<tr><th>~keyword
<th>記述
<tbody>

<tr><td>`none@v
</td><td>
~virtual-keyboardは表示するベキでない。
この~keywordは、
自前の~keyboard~controlを具現化するような内容に，有用になる。
◎
The user agent should not display a virtual keyboard. This keyword is useful for content that renders its own keyboard control.

<tr><td>`text@v
</td><td>
利用者の~localeにおける~textを入力できるもの。
◎
The user agent should display a virtual keyboard capable of text input in the user's locale.

<tr><td>`tel@v
</td><td>
電話番号を入力できるもの。
これは、［
数字 0 〜 9, 文字 "#", "*"
］用の~UIkeyを含むベキである。
~localeによっては、
これには~alphabetic-mnemonicも含まれる
（例えば米国では、
歴史的に，~label "2" の~UIkeyには ~label "A", "B", "C" も付与されている）。
◎
The user agent should display a virtual keyboard capable of telephone number input. This should including keys for the digits 0 to 9, the "#" character, and the "*" character. In some locales, this can also include alphabetic mnemonic labels (e.g., in the US, the key labeled "2" is historically also labeled with the letters A, B, and C).

<tr><td>`url@v
</td><td>
利用者の~localeにおける~textを入力できるものであって，
`~URL$の入力を援助する~UIkeyも伴うもの
— ［
次に挙げるような，~domain名に共通的に見出される文字列
］を手早く入力するための
⇒
`/^l, `.^l, `www.^l, `.com^l
◎
The user agent should display a virtual keyboard capable of text input in the user's locale, with keys for aiding in the input of URLs, such as that for the "/" and "." characters and for quick input of strings commonly found in domain names such as "www." or ".com".

<tr><td>`email@v
</td><td>
利用者の~localeにおける~textを入力できるものであって，
~email~addressの入力を援助する~UIkeyも伴うもの
— 文字 `@^l, `.^l 用の~UIkeyなど。
◎
The user agent should display a virtual keyboard capable of text input in the user's locale, with keys for aiding in the input of email addresses, such as that for the "@" character and the "." character.

<tr><td>`numeric@v
</td><td>
数を入力できるもの。
この~keywordは、
PIN を手入力するときに有用になる。
◎
The user agent should display a virtual keyboard capable of numeric input. This keyword is useful for PIN entry.

<tr><td>`decimal@v
</td><td>
小数を含む数を入力できるもの。
利用者の~locale用の数的~UIkeyと書式~分離子が示されるベキである。
◎
The user agent should display a virtual keyboard capable of fractional numeric input. Numeric keys and the format separator for the locale should be shown.

<tr><td>`search@v
</td><td>
探索~用に最適化されたもの。
◎
The user agent should display a virtual keyboard optimized for search.
</table>

<p>
`inputMode@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`inputmode$a 内容~属性を`反映する$モノトスル。
◎
The inputMode IDL attribute must reflect the inputmode content attribute, limited to only known values.
</p>

<p>
`inputmode$a が未指定なときは
（または、~UAは その状態を~supportしないときは）、
~UAは，
既定の~virtual-keyboardを決定して利用者に呈示するベキである
— 決定する際には、
入力の［
`type$a や `pattern$a
］属性などの文脈的な情報を利用するベキである。
◎
When inputmode is unspecified (or is in a state not supported by the user agent), the user agent should determine the default virtual keyboard to be shown. Contextual information such as the input type or pattern attributes should be used to determine which type of virtual keyboard should be presented to the user.
</p>

			</section>
			<section id="input-modalities:-the-enterkeyhint-attribute">
<h4 title="Input modalities: the enterkeyhint attribute">6.8.8. 入力~modal性： `enterkeyhint^a 属性</h4>

<p>
~UAは、
~form~control（ `textarea$e 要素の値などの）や,
`編集中の~host$内の要素（例： `contenteditable$a を利用しているもの）に対し，
`enterkeyhint$a 属性を~supportできる。
◎
User agents can support the enterkeyhint attribute on form controls (such as the value of textarea elements), or in elements in an editing host (e.g., using contenteditable).
</p>

<p>
`enterkeyhint@a
内容~属性は、
`列挙d属性$であり，［
~virtual-keyboard上の `Enter^Key ~UIkey
］用に［
どの動作~label（または~icon）を呈示するか
］を指定する。
これは、
`Enter^Key ~UIkeyの呈示を［
利用者にもっと助けになるよう~custom化する
］ことを作者に許容する。
◎
The enterkeyhint content attribute is an enumerated attribute that specifies what action label (or icon) to present for the enter key on virtual keyboards. This allows authors to customize the presentation of the enter key in order to make it more helpful for users.
</p>

<table><thead>
<tr><th>~keyword
<th>
~UAは、［
代表的に、
この列に述べる操作o
］用の~cueを呈示するベキである。
<tbody>

<tr><td>`enter@v
<td>
改行を挿入する。
◎
The user agent should present a cue for the operation 'enter', typically inserting a new line.

<tr><td>`done@v
<td>
入力するものはそれ以上なく，~IMEは閉じられることになる。
◎
The user agent should present a cue for the operation 'done', typically meaning there is nothing more to input and the input method editor (IME) will be closed.

<tr><td>`go@v
<td>
打込んだ~textの~targetへ利用者を導く。
◎
The user agent should present a cue for the operation 'go', typically meaning to take the user to the target of the text they typed.

<tr><td>`next@v
<td>
~textを受容する次の欄へ利用者を導く。
◎
The user agent should present a cue for the operation 'next', typically taking the user to the next field that will accept text.

<tr><td>`previous@v
<td>
~textを受容する前の欄へ利用者を導く。
◎
The user agent should present a cue for the operation 'previous', typically taking the user to the previous field that will accept text.

<tr><td>`~search0@v
<td>
打込んだ~textを探索した結果へ利用者を導く。
◎
The user agent should present a cue for the operation 'search', typically taking the user to the results of searching for the text they have typed.

<tr><td>`send@v
<td>
~textをその~targetへ送達する。
◎
The user agent should present a cue for the operation 'send', typically delivering the text to its target.
</table>

<p>
`enterKeyHint@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`enterkeyhint$a 内容~属性を`反映する$モノトスル。
◎
The enterKeyHint IDL attribute must reflect the enterkeyhint content attribute, limited to only known values.
</p>

<p>
`enterkeyhint$a が未指定なときは
（または、~UAは その状態を~supportしないときは）、
~UAは，~virtual-keyboard上に既定で呈示する動作~label（または~icon）を決定するベキである
— これを決定するときには、［
`inputmode$a ／ `type$a ／ `pattern$a
］属性などの文脈的な情報を利用するベキである。
◎
When enterkeyhint is unspecified (or is in a state not supported by the user agent), the user agent should determine the default action label (or icon) to present. Contextual information such as the inputmode, type, or pattern attributes should be used to determine which action label (or icon) to present on the virtual keyboard.
</p>

			</section>
		</section>
		<section id="find-in-page">
<h3 title="Find-in-page">6.9. ~find-in-page</h3>

			<section id="introduction-10">
<h4 title="Introduction">6.9.1. 序論</h4>

<p>
この節では、
`~find-in-page@
（ `find-in-page^en ）を定義する
— それは、
~UAに共通的な仕組みであり，特定0の情報に関して~pageの内容を探索することを利用者に許容する。
◎
This section defines find-in-page — a common user-agent mechanism which allows users to search through the contents of the page for particular information.
</p>

<p>
`~find-in-page$特能への~accessは、
`~find-in-page~UI@
を介して供される。
これは、
~UAが供する~UIであり、［
探索への入力と~parameter群を指定する
］ことを利用者に許容する。
この~UIは、［
~shortcut／~menu選択
］の結果として現れることもある。
◎
Access to the find-in-page feature is provided via a find-in-page interface. This is a user-agent provided user interface, which allows the user to specify input and the parameters of the search. This interface can appear as a result of a shortcut or a menu selection.
</p>

<p>
`~find-in-page~UI$内の［
~text入力, 設定群
］の組合nは、
利用者の
`~query@fiP
を表現する。
これは，概して、
利用者が探索したいと求める~textに加え，省略可能な設定群
（例：一体としての単語に限り†探索するよう制約する能）
も含む。
【† 例えば `strict^l は `restrict^l には合致しないよう。】
◎
A combination of text input and settings in the find-in-page interface represents the user query. This typically includes the text that the user wants to search for, as well as optional settings (e.g., the ability to restrict the search to whole words only).
</p>

<p>
~UAは、
所与の`~query$fiPに対し~page内容を処理して，
0 個以上の合致-からなる
`合致-~list@fiP
を識別する。
各~合致-は、
利用者からの`~query$fiPを満足する内容~範囲を与える。
◎
The user-agent processes page contents for a given query, and identifies zero or more matches, which are content ranges that satisfy the user query.
</p>

<p>
`合致-~list$fiP内のある 1 つの合致-は、
強調され, ~viewの中へ~scrollされることにより，利用者から
`作動中な合致-@fiP
として識別されるようになる。
利用者は、［
`~find-in-page~UI$を利用して`作動中な合致-$fiPを次へ進める
］ことにより，
`合致-~list$fiPを成す各~合致-を~navigateできる。
◎
One of the matches is identified to the user as the active match. It is highlighted and scrolled into view. The user can navigate through the matches by advancing the active match using the find-in-page interface.
</p>

<p class="XXX">
`~find-in-page$が［
現在は未指定な `window.find()^c ~API
］の下層をどう成すか標準~化することは、
`課題 #3539＠~HTMLissue/3539$
にて追跡されている。
◎
Issue #3539 tracks standardizing how find-in-page underlies the currently-unspecified window.find() API.
</p>

			</section>
			<section id="interaction-with-details-and-hidden=until-found">
<h4 title="Interaction with details and hidden=until-found">6.9.2. `details^e 要素と見出されるまでは非可視な要素の相互作用</h4>

<p>
`~find-in-page$が合致するものを探索し始めるときは、
当の~page内の：
◎
When find-in-page begins searching for matches,＼
</p>
<ul>
	<li>
［
各 `details$e 要素のうち，
`open$a 属性を有さないもの
］の［
`2 個目の~slot＠~HTMLrendering#_details-slots$の中の`飛ばされた内容$
］は、
`~find-in-page$で探索~可能になるよう，［
`open$a 属性を改変することなく，~access可能になる
］べきである。
◎
all details elements in the page which do not have their open attribute set should have the skipped contents of their second slot become accessible, without modifying the open attribute, in order to make find-in-page able to search through it.＼
</li>
	<li>
各`~HTML要素$のうち，［
その `hidden$a 属性の状態 ~EQ `見出されるまでは非可視$st
］なるものの`飛ばされた内容$は、
`~find-in-page$で探索~可能になるよう，［
`hidden$a 属性を改変することなく，~access可能になる
］ベキである。
◎
Similarly, all HTML elements with the hidden attribute in the hidden until found state should have their skipped contents become accessible without modifying the hidden attribute in order to make find-in-page able to search through them.＼
</li>
</ul>

<p>
これらに該当する要素は、
`~find-in-page$が合致するものを探索し終えた後に，再び［
その`内容は飛ばされ$るようになる
］べきである。
この処理n全体は、
同期的に起こるモノトスル
（なので、
利用者や作者~codeからは観測-可能にならない）。
`CSSCONTAIN$r
◎
After find-in-page finishes searching for matches, the details elements and the elements with the hidden attribute in the hidden until found state should have their contents become skipped again. This entire process must happen synchronously (and so is not observable to users or to author code). [CSSCONTAIN]
</p>

<div class="algo">
<p>
`~find-in-page$が新たな`作動中な合致-$fiPを選ぶときは、
次の手続きを遂行する：
◎
When find-in-page chooses a new active match, perform the following steps:
</p>
<ol>
	<li>
%~node ~LET `作動中な合致-$fiP内の最初の~node
◎
Let node be the first node in the active match.
</li>
	<li class="algo">
<p>
次を走らす`大域~taskを~queueする$( `利用者~対話~task~source$, %~node に`関連な大域~obj$ )：
◎
Queue a global task on the user interaction task source given node's relevant global object to run the following steps:
</p>
		<ol>
			<li>
`先祖~detailsを露呈する$( %~node )；
◎
Run the ancestor details revealing algorithm on node.
</li>
			<li>
`見出されるまでは非可視な先祖を露呈する$( %~node )
◎
Run the ancestor hidden-until-found revealing algorithm on node.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="warning">
<p>
◎追跡路
~find-in-pageが `details$e 要素を この様に自動-展開するとき、
`toggle$et ~eventを発火することになる。
~find-in-pageが発火する別々な `scroll$et ~eventと同じく、
この~eventも，~pageにより［
利用者が~find-in-page~dialogの中に何を打込んでいるか発見する
］ために利用され得る。
◎
(This is a tracking vector.)＼
When find-in-page auto-expands a details element like this, it will fire a toggle event. As with the separate scroll event that find-in-page fires, this event could be used by the page to discover what the user is typing into the find-in-page dialog.＼
</p>

<p>
【`scroll^et ~eventを利用する場合、】
~pageは、［
ごく狭い~scroll可能な区画 %区画 を作成した上で，次を繰返す
］ことにより，検索語を増分的に築くこともできる：
◎
If the page creates a tiny scrollable area＼
</p>
<ol>
	<li>
利用者が次に打込みそうな あらゆる文字に対し、
各［
現在の検索語と そのような文字が成す並び
］を，互いに間を~~空けて %区画 内に含める。
◎
with the current search term and every possible next character the user could type separated by a gap,＼
</li>
	<li>
~browserが どの文字へ~scrollするか観測する。
◎
and observes which one the browser scrolls to,＼
</li>
	<li>
観測された文字を追加して，現在の検索語を更新する。
◎
it can add that character to the search term and update the scrollable area＼
to incrementally build the search term.＼
</li>
</ol>

<p>
~pageは、
各［
アリな次回の合致-
］を閉じられた `details$e 要素~内に包装することにより，
`scroll$et ~eventの代わりに `toggle$et ~eventを~listenすることもできる。
◎
By wrapping each possible next match in a closed details element, the page could listen to toggle events instead of scroll events.＼
</p>

<p>
この攻撃は、
次により取組むこともできる
⇒
どちらの~eventも、
利用者が~find-in-page~dialogの中に文字を打込むたびに動作しないようにする。
◎
This attack could be addressed for both events by not acting on every character the user types into the find-in-page dialog.
</p>
</div>

			</section>
			<section id="interaction-with-selection">
<h4 title="Interaction with selection">6.9.3. 選択との相互作用</h4>

<p>
`~find-in-page$処理nは、
文書の文脈~内で呼出され，その文書の`選択$に効果を及ぼしてもヨイ。
特定的には、
`作動中な合致-$fiPを定義する範囲が，現在の選択を規定し得る。
しかしながら、［
~find-in-page処理nの間，この選択~更新が起こる時点
］は，いくつかあり得る
（例：
`~find-in-page~UI$が退けられた時点／
`作動中な合致-$fiPの範囲が変化した時点）。
◎
The find-in-page process is invoked in the context of a document, and may have an effect on the selection of that document. Specifically, the range that defines the active match can dictate the current selection. These selection updates, however, can happen at different times during the find-in-page process (e.g. upon the find-in-page interface dismissal or upon a change in the active match range).
</p>

			</section>
		</section>
	</section>
</main>
